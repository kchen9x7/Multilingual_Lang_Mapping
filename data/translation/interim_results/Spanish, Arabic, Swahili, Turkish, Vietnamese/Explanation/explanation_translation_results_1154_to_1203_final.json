[
  {
    "task_id": "PHP/1",
    "prompt": {
      "en": "<?php\nassert_options(ASSERT_ACTIVE, 1);\nassert_options(ASSERT_BAIL, 1);\n/**\n    * Check if in given list of numbers, any two numbers are closer to each other than\n    * given threshold.\n*/\nfunction has_close_elements($numbers, $threshold) ",
      "es": "<?php\nassert_options(ASSERT_ACTIVE, 1);\nassert_options(ASSERT_BAIL, 1);\n/**\n    * Verificar si en la lista dada de números, hay dos números que están más cerca uno del otro que\n    * el umbral dado.\n*/\nfunction has_close_elements($numbers, $threshold) ",
      "arb": "<?php\nassert_options(ASSERT_ACTIVE, 1);\nassert_options(ASSERT_BAIL, 1);\n/**\n    * التحقق مما إذا كان في قائمة الأرقام المعطاة، أي رقمين أقرب إلى بعضهما البعض من\n    * العتبة المعطاة.\n*/\nfunction has_close_elements($numbers, $threshold) ",
      "sw": "<?php\nassert_options(ASSERT_ACTIVE, 1);\nassert_options(ASSERT_BAIL, 1);\n/**\n    * Angalia kama katika orodha iliyotolewa ya nambari, nambari zozote mbili ziko karibu zaidi na kila moja kuliko\n    * kizingiti kilichotolewa.\n*/\nfunction has_close_elements($numbers, $threshold) ",
      "tr": "<?php\nassert_options(ASSERT_ACTIVE, 1);\nassert_options(ASSERT_BAIL, 1);\n/**\n    * Verilen sayı listesindeki herhangi iki sayının\n    * verilen eşikten daha yakın olup olmadığını kontrol edin.\n*/\nfunction has_close_elements($numbers, $threshold) ",
      "vi": "<?php\nassert_options(ASSERT_ACTIVE, 1);\nassert_options(ASSERT_BAIL, 1);\n/**\n    * Kiểm tra xem trong danh sách số đã cho, có hai số nào gần nhau hơn\n    * ngưỡng đã cho hay không.\n*/\nfunction has_close_elements($numbers, $threshold) "
    },
    "prompt_bertscore": {
      "es": "0.9791446045128609",
      "arb": "0.9924593948447725",
      "sw": "0.9924593948447725",
      "tr": "0.9703538197393998",
      "vi": "0.9564012272539851"
    },
    "canonical_solution": "{\n    $count = count($numbers);\n    for ($i = 0; $i < $count; $i++) {\n        for ($j = 0; $j < $count; $j++) {\n            if ($i != $j) {\n                $distance = abs($numbers[$i] - $numbers[$j]);\n                if ($distance < $threshold) {\n                    return true;\n                }\n            }\n        }\n    }\n    return false;\n}",
    "instruction": {
      "en": "function has_close_elements($numbers, $threshold)\n{\n    $count = count($numbers);\n    for ($i = 0; $i < $count; $i++) {\n        for ($j = 0; $j < $count; $j++) {\n            if ($i != $j) {\n                $distance = abs($numbers[$i] - $numbers[$j]);\n                if ($distance < $threshold) {\n                    return true;\n                }\n            }\n        }\n    }\n    return false;\n}\n\nProvide a concise natural language description (docstring) of the PHP code in English using at most 500 characters.",
      "es": "function has_close_elements($numbers, $threshold)\n{\n    $count = count($numbers);\n    for ($i = 0; $i < $count; $i++) {\n        for ($j = 0; $j < $count; $j++) {\n            if ($i != $j) {\n                $distance = abs($numbers[$i] - $numbers[$j]);\n                if ($distance < $threshold) {\n                    return true;\n                }\n            }\n        }\n    }\n    return false;\n}\n\nProporcione una descripción concisa en lenguaje natural (docstring) del código PHP en español utilizando un máximo de 500 caracteres.",
      "arb": "function has_close_elements($numbers, $threshold)\n{\n    $count = count($numbers);\n    for ($i = 0; $i < $count; $i++) {\n        for ($j = 0; $j < $count; $j++) {\n            if ($i != $j) {\n                $distance = abs($numbers[$i] - $numbers[$j]);\n                if ($distance < $threshold) {\n                    return true;\n                }\n            }\n        }\n    }\n    return false;\n}\n\nيرجى تقديم وصف موجز بلغة طبيعية (docstring) للكود البرمجي المكتوب بلغة PHP باللغة العربية الفصحى، بحيث لا يتجاوز 500 حرف.",
      "sw": "function has_close_elements($numbers, $threshold)\n{\n    $count = count($numbers);\n    for ($i = 0; $i < $count; $i++) {\n        for ($j = 0; $j < $count; $j++) {\n            if ($i != $j) {\n                $distance = abs($numbers[$i] - $numbers[$j]);\n                if ($distance < $threshold) {\n                    return true;\n                }\n            }\n        }\n    }\n    return false;\n}\n\nToa maelezo mafupi ya lugha ya asili (docstring) ya msimbo wa PHP kwa Kiswahili kwa kutumia herufi zisizozidi 500.",
      "tr": "function has_close_elements($numbers, $threshold)\n{\n    $count = count($numbers);\n    for ($i = 0; $i < $count; $i++) {\n        for ($j = 0; $j < $count; $j++) {\n            if ($i != $j) {\n                $distance = abs($numbers[$i] - $numbers[$j]);\n                if ($distance < $threshold) {\n                    return true;\n                }\n            }\n        }\n    }\n    return false;\n}\n\nAşağıdaki PHP kodunun işlevini açıklayan, en fazla 500 karakter uzunluğunda özlü bir doğal dil açıklaması (docstring) sağlayın.",
      "vi": "function has_close_elements($numbers, $threshold)\n{\n    $count = count($numbers);\n    for ($i = 0; $i < $count; $i++) {\n        for ($j = 0; $j < $count; $j++) {\n            if ($i != $j) {\n                $distance = abs($numbers[$i] - $numbers[$j]);\n                if ($distance < $threshold) {\n                    return true;\n                }\n            }\n        }\n    }\n    return false;\n}\n\nCung cấp mô tả ngắn gọn bằng ngôn ngữ tự nhiên (docstring) cho mã PHP bằng tiếng Việt với tối đa 500 ký tự."
    },
    "instruction_bertscore": {
      "es": "0.9687069752502395",
      "arb": "0.905616007322128",
      "sw": "0.9428367585331127",
      "tr": "0.8581880380905226",
      "vi": "0.9017250367880356"
    },
    "level": "",
    "test": "// Test cases\nfunction test_has_close_elements() {\n    if (has_close_elements([1.0, 2.0, 3.9, 4.0, 5.0, 2.2], 0.3) != true){\n        exit(1);\n    }\n\n    if (has_close_elements([1.0, 2.0, 3.9, 4.0, 5.0, 2.2], 0.05) != false){\n        exit(1);\n    }\n    if (has_close_elements([1.0, 2.0, 5.9, 4.0, 5.0], 0.95) != true){\n        exit(1);\n    }\n    if (has_close_elements([1.0, 2.0, 5.9, 4.0, 5.0], 0.8) != false){\n        exit(1);\n    }\n    if (has_close_elements([1.0, 2.0, 3.0, 4.0, 5.0, 2.0], 0.1) != true){\n        exit(1);\n    }\n    if (has_close_elements([1.1, 2.2, 3.1, 4.1, 5.1], 1.0) != true){\n        exit(1);\n    }\n    if (has_close_elements([1.1, 2.2, 3.1, 4.1, 5.1], 0.5) != false){\n        exit(1);\n    }\n}\n\ntest_has_close_elements();\n\n?>",
    "entry_point": "has_close_elements",
    "signature": "function has_close_elements($numbers, $threshold)",
    "docstring": {
      "en": "Check if in given list of numbers, any two numbers are closer to each other than\ngiven threshold.",
      "es": "Verificar si en la lista dada de números, dos números cualesquiera están más cerca uno del otro que el umbral dado.",
      "arb": "تحقق مما إذا كان في قائمة الأرقام المعطاة، أي رقمين أقرب إلى بعضهما البعض من العتبة المعطاة.",
      "sw": "Angalia ikiwa katika orodha iliyotolewa ya namba, namba yoyote mbili ziko karibu zaidi na kila mmoja kuliko kizingiti kilichopeanwa.",
      "tr": "Verilen sayı listesindeki herhangi iki sayının, verilen eşikten daha yakın olup olmadığını kontrol edin.",
      "vi": "Kiểm tra xem trong danh sách số đã cho, có bất kỳ hai số nào gần nhau hơn ngưỡng đã cho hay không."
    },
    "docstring_bertscore": {
      "es": "0.9754973534562983",
      "arb": "0.9754973534562983",
      "sw": "0.9613544730658522",
      "tr": "0.892139730490435",
      "vi": "0.9516579337548721"
    }
  },
  {
    "task_id": "PHP/2",
    "prompt": {
      "en": "<?php\n\n\n/**\n    * Determines the outcome of a \"Rock, Paper, Scissors\" game.\n    * In this game, each player selects either rock (0), paper (1), or scissors (2).\n    * The rules are as follows:\n    * - Paper beats rock\n    * - Rock beats scissors\n    * - Scissors beats paper\n    * If both players choose the same item, it's a draw.\n    * Input: Two integers representing the choices of two players.\n    * Output: Returns 1 if the first player wins, -1 if the second player wins, and 0 for a draw.\n*/\n\nfunction determineGameOutcome($player1, $player2) ",
      "es": "<?php\n\n\n/**\n    * Determina el resultado de un juego de \"Piedra, Papel, Tijeras\".\n    * En este juego, cada jugador selecciona piedra (0), papel (1) o tijeras (2).\n    * Las reglas son las siguientes:\n    * - El papel vence a la piedra\n    * - La piedra vence a las tijeras\n    * - Las tijeras vencen al papel\n    * Si ambos jugadores eligen el mismo elemento, es un empate.\n    * Entrada: Dos enteros que representan las elecciones de dos jugadores.\n    * Salida: Devuelve 1 si el primer jugador gana, -1 si el segundo jugador gana, y 0 para un empate.\n*/\n\nfunction determineGameOutcome($player1, $player2) ",
      "arb": "<?php\n\n\n/**\n    * يحدد نتيجة لعبة \"حجر، ورقة، مقص\".\n    * في هذه اللعبة، يختار كل لاعب إما حجر (0)، ورقة (1)، أو مقص (2).\n    * القواعد كالتالي:\n    * - الورقة تهزم الحجر\n    * - الحجر يهزم المقص\n    * - المقص يهزم الورقة\n    * إذا اختار كلا اللاعبين نفس العنصر، تكون النتيجة تعادل.\n    * المدخل: عددان صحيحان يمثلان اختيارات اللاعبين.\n    * المخرج: يعيد 1 إذا فاز اللاعب الأول، -1 إذا فاز اللاعب الثاني، و0 للتعادل.\n*/\n\nfunction determineGameOutcome($player1, $player2) ",
      "sw": "<?php\n\n\n/**\n    * Inatambua matokeo ya mchezo wa \"Jiwe, Karatasi, Mkasi\".\n    * Katika mchezo huu, kila mchezaji huchagua jiwe (0), karatasi (1), au mkasi (2).\n    * Sheria ni kama ifuatavyo:\n    * - Karatasi inashinda jiwe\n    * - Jiwe linashinda mkasi\n    * - Mkasi unashinda karatasi\n    * Ikiwa wachezaji wote wawili wanachagua kipengee sawa, ni sare.\n    * Ingizo: Nambari mbili za mzima zinazowakilisha chaguo la wachezaji wawili.\n    * Matokeo: Inarudisha 1 ikiwa mchezaji wa kwanza anashinda, -1 ikiwa mchezaji wa pili anashinda, na 0 kwa sare.\n*/\n\nfunction determineGameOutcome($player1, $player2) ",
      "tr": "<?php\n\n\n/**\n    * \"Taş, Kağıt, Makas\" oyununun sonucunu belirler.\n    * Bu oyunda, her oyuncu ya taş (0), kağıt (1) ya da makas (2) seçer.\n    * Kurallar aşağıdaki gibidir:\n    * - Kağıt taşı yener\n    * - Taş makası yener\n    * - Makas kağıdı yener\n    * Her iki oyuncu da aynı öğeyi seçerse, oyun berabere biter.\n    * Girdi: İki oyuncunun seçimlerini temsil eden iki tam sayı.\n    * Çıktı: İlk oyuncu kazanırsa 1, ikinci oyuncu kazanırsa -1 ve beraberlik için 0 döner.\n*/\n\nfunction determineGameOutcome($player1, $player2) ",
      "vi": "<?php\n\n\n/**\n    * Xác định kết quả của trò chơi \"Kéo, Búa, Bao\".\n    * Trong trò chơi này, mỗi người chơi chọn kéo (0), búa (1), hoặc bao (2).\n    * Các quy tắc như sau:\n    * - Bao thắng búa\n    * - Búa thắng kéo\n    * - Kéo thắng bao\n    * Nếu cả hai người chơi chọn cùng một vật, đó là hòa.\n    * Đầu vào: Hai số nguyên đại diện cho lựa chọn của hai người chơi.\n    * Đầu ra: Trả về 1 nếu người chơi thứ nhất thắng, -1 nếu người chơi thứ hai thắng, và 0 cho hòa.\n*/\n\nfunction determineGameOutcome($player1, $player2) "
    },
    "prompt_bertscore": {
      "es": "0.9836654319852149",
      "arb": "0.9735730223248322",
      "sw": "0.9841435353123659",
      "tr": "0.988402369312135",
      "vi": "0.9835698907719371"
    },
    "canonical_solution": "{\n    if ($player1 === $player2) {\n        return 0; // Draw\n    } elseif (($player1 === 0 && $player2 === 1) || // Paper beats Rock\n              ($player1 === 1 && $player2 === 2) || // Scissors beats Paper\n              ($player1 === 2 && $player2 === 0)) { // Rock beats Scissors\n        return -1; // Player 2 wins\n    } else {\n        return 1; // Player 1 wins\n    }\n}",
    "instruction": {
      "en": "function determineGameOutcome($player1, $player2)\n{\n    if ($player1 === $player2) {\n        return 0; // Draw\n    } elseif (($player1 === 0 && $player2 === 1) || // Paper beats Rock\n              ($player1 === 1 && $player2 === 2) || // Scissors beats Paper\n              ($player1 === 2 && $player2 === 0)) { // Rock beats Scissors\n        return -1; // Player 2 wins\n    } else {\n        return 1; // Player 1 wins\n    }\n}\n\nProvide a concise natural language description (docstring) of the PHP code in English using at most 500 characters.",
      "es": "function determineGameOutcome($player1, $player2)\n{\n    if ($player1 === $player2) {\n        return 0; // Draw\n    } elseif (($player1 === 0 && $player2 === 1) || // Paper beats Rock\n              ($player1 === 1 && $player2 === 2) || // Scissors beats Paper\n              ($player1 === 2 && $player2 === 0)) { // Rock beats Scissors\n        return -1; // Player 2 wins\n    } else {\n        return 1; // Player 1 wins\n    }\n}\n\nProporcione una descripción concisa en lenguaje natural (docstring) del código PHP en español utilizando un máximo de 500 caracteres.",
      "arb": "function determineGameOutcome($player1, $player2)\n{\n    if ($player1 === $player2) {\n        return 0; // Draw\n    } elseif (($player1 === 0 && $player2 === 1) || // Paper beats Rock\n              ($player1 === 1 && $player2 === 2) || // Scissors beats Paper\n              ($player1 === 2 && $player2 === 0)) { // Rock beats Scissors\n        return -1; // Player 2 wins\n    } else {\n        return 1; // Player 1 wins\n    }\n}\n\nقدم وصفًا موجزًا بلغة طبيعية (docstring) لشيفرة PHP باللغة العربية الفصحى باستخدام 500 حرف على الأكثر.",
      "sw": "function determineGameOutcome($player1, $player2)\n{\n    if ($player1 === $player2) {\n        return 0; // Draw\n    } elseif (($player1 === 0 && $player2 === 1) || // Paper beats Rock\n              ($player1 === 1 && $player2 === 2) || // Scissors beats Paper\n              ($player1 === 2 && $player2 === 0)) { // Rock beats Scissors\n        return -1; // Player 2 wins\n    } else {\n        return 1; // Player 1 wins\n    }\n}\n\nToa maelezo mafupi ya lugha ya asili (docstring) ya msimbo wa PHP kwa Kiswahili kwa kutumia herufi zisizozidi 500.",
      "tr": "function determineGameOutcome($player1, $player2)\n{\n    if ($player1 === $player2) {\n        return 0; // Draw\n    } elseif (($player1 === 0 && $player2 === 1) || // Paper beats Rock\n              ($player1 === 1 && $player2 === 2) || // Scissors beats Paper\n              ($player1 === 2 && $player2 === 0)) { // Rock beats Scissors\n        return -1; // Player 2 wins\n    } else {\n        return 1; // Player 1 wins\n    }\n}\n\nAşağıdaki PHP kodunun işlevini açıklayan kısa bir doğal dil tanımı (docstring) sağlayın. Açıklama, en fazla 500 karakter kullanılarak Türkçe dilinde olmalıdır.",
      "vi": "function determineGameOutcome($player1, $player2)\n{\n    if ($player1 === $player2) {\n        return 0; // Draw\n    } elseif (($player1 === 0 && $player2 === 1) || // Paper beats Rock\n              ($player1 === 1 && $player2 === 2) || // Scissors beats Paper\n              ($player1 === 2 && $player2 === 0)) { // Rock beats Scissors\n        return -1; // Player 2 wins\n    } else {\n        return 1; // Player 1 wins\n    }\n}\n\nCung cấp mô tả ngắn gọn bằng ngôn ngữ tự nhiên (docstring) cho mã PHP bằng tiếng Việt, sử dụng tối đa 500 ký tự."
    },
    "instruction_bertscore": {
      "es": "0.9687069752502395",
      "arb": "0.9213950061611585",
      "sw": "0.91585798565943",
      "tr": "0.8625074543565073",
      "vi": "0.9202302376067699"
    },
    "level": "",
    "test": "function main(){\n    \n    assert(determineGameOutcome(0, 1) === -1);\n    assert(determineGameOutcome(1, 2) === -1);\n    assert(determineGameOutcome(2, 0) === -1);\n    assert(determineGameOutcome(0, 2) === 1);\n    assert(determineGameOutcome(1, 0) === 1);\n    assert(determineGameOutcome(2, 1) === 1);\n    assert(determineGameOutcome(0, 0) === 0);\n    assert(determineGameOutcome(1, 1) === 0);\n    assert(determineGameOutcome(2, 2) === 0);\n}\nmain();\n// echo \"All test passed!\\n\";\n?>",
    "entry_point": "determineGameOutcome",
    "signature": "function determineGameOutcome($player1, $player2)",
    "docstring": {
      "en": "Determines the outcome of a \"Rock, Paper, Scissors\" game.\nIn this game, each player selects either rock (0), paper (1), or scissors (2).\nThe rules are as follows:\n- Paper beats rock\n- Rock beats scissors\n- Scissors beats paper\nIf both players choose the same item, it's a draw.\nInput: Two integers representing the choices of two players.\nOutput: Returns 1 if the first player wins, -1 if the second player wins, and 0 for a draw.",
      "es": "Determina el resultado de un juego de \"Piedra, Papel, Tijeras\".  \nEn este juego, cada jugador selecciona piedra (0), papel (1) o tijeras (2).  \nLas reglas son las siguientes:  \n- Papel vence a piedra  \n- Piedra vence a tijeras  \n- Tijeras vence a papel  \nSi ambos jugadores eligen el mismo elemento, es un empate.  \nEntrada: Dos enteros que representan las elecciones de dos jugadores.  \nSalida: Devuelve 1 si el primer jugador gana, -1 si el segundo jugador gana, y 0 para un empate.  ",
      "arb": "يحدد نتيجة لعبة \"حجر، ورقة، مقص\".\nفي هذه اللعبة، يختار كل لاعب إما حجر (0)، ورقة (1)، أو مقص (2).\nالقواعد كالتالي:\n- الورقة تغلب الحجر\n- الحجر يغلب المقص\n- المقص يغلب الورقة\nإذا اختار كلا اللاعبين نفس العنصر، تكون النتيجة تعادل.\nالمدخلات: عددان صحيحان يمثلان اختيارات اللاعبين.\nالمخرجات: يعيد 1 إذا فاز اللاعب الأول، -1 إذا فاز اللاعب الثاني، و0 في حالة التعادل.",
      "sw": "Inatambua matokeo ya mchezo wa \"Jiwe, Karatasi, Mkasi\".  \nKatika mchezo huu, kila mchezaji huchagua jiwe (0), karatasi (1), au mkasi (2).  \nSheria ni kama ifuatavyo:  \n- Karatasi inashinda jiwe  \n- Jiwe linashinda mkasi  \n- Mkasi unashinda karatasi  \nIkiwa wachezaji wote wawili watachagua kitu sawa, ni sare.  \nIngizo: Nambari mbili za mzima zinazoashiria chaguo za wachezaji wawili.  \nMatokeo: Inarudisha 1 ikiwa mchezaji wa kwanza anashinda, -1 ikiwa mchezaji wa pili anashinda, na 0 kwa sare.",
      "tr": "\"Taş, Kağıt, Makas\" oyununun sonucunu belirler.  \nBu oyunda, her oyuncu ya taş (0), kağıt (1) ya da makas (2) seçer.  \nKurallar aşağıdaki gibidir:  \n- Kağıt taşı yener  \n- Taş makası yener  \n- Makas kağıdı yener  \nEğer her iki oyuncu da aynı öğeyi seçerse, oyun berabere biter.  \nGirdi: İki oyuncunun seçimlerini temsil eden iki tamsayı.  \nÇıktı: İlk oyuncu kazanırsa 1, ikinci oyuncu kazanırsa -1 ve beraberlik için 0 döndürür.",
      "vi": "Xác định kết quả của trò chơi \"Kéo, Búa, Bao\".  \nTrong trò chơi này, mỗi người chơi chọn kéo (0), búa (1), hoặc bao (2).  \nCác quy tắc như sau:  \n- Bao thắng búa  \n- Búa thắng kéo  \n- Kéo thắng bao  \nNếu cả hai người chơi chọn cùng một vật phẩm, đó là hòa.  \nĐầu vào: Hai số nguyên đại diện cho lựa chọn của hai người chơi.  \nĐầu ra: Trả về 1 nếu người chơi thứ nhất thắng, -1 nếu người chơi thứ hai thắng, và 0 cho hòa.  "
    },
    "docstring_bertscore": {
      "es": "0.9704437993020086",
      "arb": "0.959497874894319",
      "sw": "0.9814957923331709",
      "tr": "0.978655775145134",
      "vi": "0.9673852886948334"
    }
  },
  {
    "task_id": "PHP/3",
    "prompt": {
      "en": "<?php\n\n/**\n    * Removes all asterisks (*) from a string except those at the beginning.\n    * This function takes a string that may contain alphabetic characters and asterisks.\n    * It will preserve any asterisks that appear at the start of the string but remove all others.\n    * For example, a string like \"***Hello*World**\" would be transformed to \"***HelloWorld\".\n    * Input: A single string.\n    * Output: The modified string with only the leading asterisks retained.\n*/\nfunction removeInnerAsterisks($string) ",
      "es": "<?php\n\n/**\n    * Elimina todos los asteriscos (*) de una cadena excepto aquellos al principio.\n    * Esta función toma una cadena que puede contener caracteres alfabéticos y asteriscos.\n    * Preservará cualquier asterisco que aparezca al inicio de la cadena pero eliminará todos los demás.\n    * Por ejemplo, una cadena como \"***Hello*World**\" se transformaría en \"***HelloWorld\".\n    * Entrada: Una sola cadena.\n    * Salida: La cadena modificada con solo los asteriscos iniciales retenidos.\n*/\nfunction removeInnerAsterisks($string) ",
      "arb": "<?php\n\n/**\n    * يزيل جميع النجوم (*) من سلسلة نصية باستثناء تلك الموجودة في البداية.\n    * تأخذ هذه الدالة سلسلة نصية قد تحتوي على أحرف أبجدية ونجوم.\n    * ستحتفظ بأي نجوم تظهر في بداية السلسلة ولكن ستزيل جميع النجوم الأخرى.\n    * على سبيل المثال، سيتم تحويل سلسلة مثل \"***Hello*World**\" إلى \"***HelloWorld\".\n    * المدخلات: سلسلة نصية واحدة.\n    * المخرجات: السلسلة المعدلة مع الاحتفاظ بالنجوم الموجودة في البداية فقط.\n*/\nfunction removeInnerAsterisks($string) ",
      "sw": "<?php\n\n/**\n    * Huondoa nyota zote (*) kutoka kwa kamba isipokuwa zile zilizo mwanzoni.\n    * Kazi hii inachukua kamba ambayo inaweza kuwa na herufi za alfabeti na nyota.\n    * Itahifadhi nyota zozote zinazotokea mwanzoni mwa kamba lakini itaondoa zote nyingine.\n    * Kwa mfano, kamba kama \"***Hello*World**\" itabadilishwa kuwa \"***HelloWorld\".\n    * Ingizo: Kamba moja.\n    * Tokeo: Kamba iliyorekebishwa na nyota za mwanzo pekee zilizohifadhiwa.\n*/\nfunction removeInnerAsterisks($string) ",
      "tr": "<?php\n\n/**\n    * Bir dizgedeki başlangıçtaki yıldız işaretleri (*) hariç tüm yıldız işaretlerini kaldırır.\n    * Bu fonksiyon, alfabetik karakterler ve yıldız işaretleri içerebilen bir dizge alır.\n    * Dizgenin başlangıcında görünen yıldız işaretlerini koruyacak, ancak diğerlerini kaldıracaktır.\n    * Örneğin, \"***Hello*World**\" gibi bir dizge \"***HelloWorld\" olarak dönüştürülecektir.\n    * Girdi: Tek bir dizge.\n    * Çıktı: Sadece baştaki yıldız işaretlerinin korunduğu değiştirilmiş dizge.\n*/\nfunction removeInnerAsterisks($string) ",
      "vi": "<?php\n\n/**\n    * Loại bỏ tất cả dấu hoa thị (*) khỏi một chuỗi ngoại trừ những dấu ở đầu.\n    * Hàm này nhận một chuỗi có thể chứa các ký tự chữ cái và dấu hoa thị.\n    * Nó sẽ giữ lại bất kỳ dấu hoa thị nào xuất hiện ở đầu chuỗi nhưng loại bỏ tất cả các dấu khác.\n    * Ví dụ, một chuỗi như \"***Hello*World**\" sẽ được chuyển thành \"***HelloWorld\".\n    * Đầu vào: Một chuỗi đơn.\n    * Đầu ra: Chuỗi đã được chỉnh sửa với chỉ các dấu hoa thị đầu tiên được giữ lại.\n*/\nfunction removeInnerAsterisks($string) "
    },
    "prompt_bertscore": {
      "es": "0.9905169883486323",
      "arb": "0.9726517746175924",
      "sw": "0.9820996286915169",
      "tr": "0.9684553105574684",
      "vi": "0.9844827960031735"
    },
    "canonical_solution": "{\n    $result = '';\n    $leadingAsterisk = true;\n    for ($i = 0; $i < strlen($string); $i++) {\n        if ($string[$i] != '*' || $leadingAsterisk) {\n            $result .= $string[$i];\n        }\n        if ($string[$i] != '*' && $leadingAsterisk) {\n            $leadingAsterisk = false;\n        }\n    }\n    return $result;\n}",
    "instruction": {
      "en": "function removeInnerAsterisks($string)\n{\n    $result = '';\n    $leadingAsterisk = true;\n    for ($i = 0; $i < strlen($string); $i++) {\n        if ($string[$i] != '*' || $leadingAsterisk) {\n            $result .= $string[$i];\n        }\n        if ($string[$i] != '*' && $leadingAsterisk) {\n            $leadingAsterisk = false;\n        }\n    }\n    return $result;\n}\n\nProvide a concise natural language description (docstring) of the PHP code in English using at most 500 characters.",
      "es": "function removeInnerAsterisks($string)\n{\n    $result = '';\n    $leadingAsterisk = true;\n    for ($i = 0; $i < strlen($string); $i++) {\n        if ($string[$i] != '*' || $leadingAsterisk) {\n            $result .= $string[$i];\n        }\n        if ($string[$i] != '*' && $leadingAsterisk) {\n            $leadingAsterisk = false;\n        }\n    }\n    return $result;\n}\n\nProporcione una descripción concisa en lenguaje natural (docstring) del código PHP en español utilizando como máximo 500 caracteres.",
      "arb": "function removeInnerAsterisks($string)\n{\n    $result = '';\n    $leadingAsterisk = true;\n    for ($i = 0; $i < strlen($string); $i++) {\n        if ($string[$i] != '*' || $leadingAsterisk) {\n            $result .= $string[$i];\n        }\n        if ($string[$i] != '*' && $leadingAsterisk) {\n            $leadingAsterisk = false;\n        }\n    }\n    return $result;\n}\n\nيرجى تقديم وصف موجز بلغة طبيعية (docstring) لشيفرة PHP باللغة العربية الفصحى، بحيث لا يتجاوز 500 حرف.",
      "sw": "function removeInnerAsterisks($string)\n{\n    $result = '';\n    $leadingAsterisk = true;\n    for ($i = 0; $i < strlen($string); $i++) {\n        if ($string[$i] != '*' || $leadingAsterisk) {\n            $result .= $string[$i];\n        }\n        if ($string[$i] != '*' && $leadingAsterisk) {\n            $leadingAsterisk = false;\n        }\n    }\n    return $result;\n}\n\nToa maelezo mafupi ya lugha ya asili (docstring) ya msimbo wa PHP kwa Kiswahili kwa kutumia herufi zisizozidi 500.",
      "tr": "function removeInnerAsterisks($string)\n{\n    $result = '';\n    $leadingAsterisk = true;\n    for ($i = 0; $i < strlen($string); $i++) {\n        if ($string[$i] != '*' || $leadingAsterisk) {\n            $result .= $string[$i];\n        }\n        if ($string[$i] != '*' && $leadingAsterisk) {\n            $leadingAsterisk = false;\n        }\n    }\n    return $result;\n}\n\nPHP kodunun işlevini açıklayan kısa bir doğal dil açıklaması (docstring) sağlayın. Açıklama, en fazla 500 karakter kullanılarak Türkçe olarak yazılmalıdır.",
      "vi": "function removeInnerAsterisks($string)\n{\n    $result = '';\n    $leadingAsterisk = true;\n    for ($i = 0; $i < strlen($string); $i++) {\n        if ($string[$i] != '*' || $leadingAsterisk) {\n            $result .= $string[$i];\n        }\n        if ($string[$i] != '*' && $leadingAsterisk) {\n            $leadingAsterisk = false;\n        }\n    }\n    return $result;\n}\n\nCung cấp mô tả ngắn gọn bằng ngôn ngữ tự nhiên (docstring) cho mã PHP bằng tiếng Việt với tối đa 500 ký tự."
    },
    "instruction_bertscore": {
      "es": "0.9687069752502395",
      "arb": "0.8959591940873549",
      "sw": "0.91585798565943",
      "tr": "0.881863190466833",
      "vi": "0.9017250367880356"
    },
    "level": "",
    "test": "function main(){\n    assert(removeInnerAsterisks(\"***Hello*World**\") === \"***HelloWorld\");\n    assert(removeInnerAsterisks(\"****\") === \"****\");\n    assert(removeInnerAsterisks(\"abc*def**ghi\") === \"abcdefghi\");\n    assert(removeInnerAsterisks(\"*a*b*c*\") === \"*abc\");\n    assert(removeInnerAsterisks(\"\") === \"\");\n    \n}\n\nmain();\n?>",
    "entry_point": "removeInnerAsterisks",
    "signature": "function removeInnerAsterisks($string)",
    "docstring": {
      "en": "Removes all asterisks (*) from a string except those at the beginning.\nThis function takes a string that may contain alphabetic characters and asterisks.\nIt will preserve any asterisks that appear at the start of the string but remove all others.\nFor example, a string like \"***Hello*World**\" would be transformed to \"***HelloWorld\".\nInput: A single string.\nOutput: The modified string with only the leading asterisks retained.",
      "es": "Elimina todos los asteriscos (*) de una cadena excepto los del principio.  \nEsta función toma una cadena que puede contener caracteres alfabéticos y asteriscos.  \nPreservará cualquier asterisco que aparezca al inicio de la cadena, pero eliminará todos los demás.  \nPor ejemplo, una cadena como \"***Hello*World**\" se transformaría en \"***HelloWorld\".  \nEntrada: Una sola cadena.  \nSalida: La cadena modificada con solo los asteriscos iniciales retenidos.  ",
      "arb": "يزيل جميع النجوم (*) من سلسلة نصية باستثناء تلك الموجودة في البداية.\nتأخذ هذه الدالة سلسلة نصية قد تحتوي على أحرف أبجدية ونجوم.\nستحافظ على أي نجوم تظهر في بداية السلسلة ولكن ستزيل جميع النجوم الأخرى.\nعلى سبيل المثال، سيتم تحويل سلسلة مثل \"***Hello*World**\" إلى \"***HelloWorld\".\nالمدخل: سلسلة نصية واحدة.\nالمخرج: السلسلة المعدلة مع الاحتفاظ بالنجوم الرائدة فقط.",
      "sw": "Huondoa nyota zote (*) kutoka kwa kamba isipokuwa zile zilizo mwanzoni.\nKazi hii inachukua kamba ambayo inaweza kuwa na herufi za alfabeti na nyota.\nItahifadhi nyota zozote zinazotokea mwanzoni mwa kamba lakini itaondoa nyota zote nyingine.\nKwa mfano, kamba kama \"***Hello*World**\" itabadilishwa kuwa \"***HelloWorld\".\nIngizo: Kamba moja.\nMatokeo: Kamba iliyobadilishwa na nyota za mwanzo pekee zilizohifadhiwa.",
      "tr": "Başlangıçtaki asterisks (*) hariç bir dizgedeki tüm asterisksleri kaldırır.\nBu fonksiyon, alfabetik karakterler ve asterisks içerebilecek bir dizge alır.\nDizgenin başında görünen asterisksleri koruyacak, ancak diğer tüm asterisksleri kaldıracaktır.\nÖrneğin, \"***Hello*World**\" gibi bir dizge \"***HelloWorld\" olarak dönüştürülecektir.\nGirdi: Tek bir dizge.\nÇıktı: Sadece baştaki asteriskslerin korunduğu değiştirilmiş dizge.",
      "vi": "Loại bỏ tất cả các dấu sao (*) khỏi một chuỗi ngoại trừ những dấu sao ở đầu chuỗi.  \nHàm này nhận một chuỗi có thể chứa các ký tự chữ cái và dấu sao.  \nNó sẽ giữ lại bất kỳ dấu sao nào xuất hiện ở đầu chuỗi nhưng loại bỏ tất cả các dấu sao khác.  \nVí dụ, một chuỗi như \"***Hello*World**\" sẽ được chuyển đổi thành \"***HelloWorld\".  \nĐầu vào: Một chuỗi đơn.  \nĐầu ra: Chuỗi đã được chỉnh sửa chỉ giữ lại các dấu sao ở đầu."
    },
    "docstring_bertscore": {
      "es": "0.983551815407263",
      "arb": "0.9816211281036039",
      "sw": "0.9266636770181089",
      "tr": "0.9513701183327524",
      "vi": "0.9623750359636094"
    }
  },
  {
    "task_id": "PHP/4",
    "prompt": {
      "en": "<?php\n\n/**\n * Converts a numerical score to its corresponding letter grade.\n * The grading system is as follows:\n * - A score between 90 and 100 (inclusive) is graded as 'A'.\n * - A score between 80 and 89 (inclusive) is graded as 'B'.\n * - A score between 70 and 79 (inclusive) is graded as 'C'.\n * - A score between 60 and 69 (inclusive) is graded as 'D'.\n * - A score below 60 is graded as 'E'.\n * If the score is outside the range of 0 to 100, an error message is returned.\n * Input: A numeric score.\n * Output: Returns the corresponding letter grade or an error message if the score is out of range.\n */\n \nfunction convertScoreToGrade($score) ",
      "es": "<?php\n\n/**\n * Convierte una calificación numérica en su correspondiente calificación con letra.\n * El sistema de calificación es el siguiente:\n * - Una calificación entre 90 y 100 (inclusive) se califica como 'A'.\n * - Una calificación entre 80 y 89 (inclusive) se califica como 'B'.\n * - Una calificación entre 70 y 79 (inclusive) se califica como 'C'.\n * - Una calificación entre 60 y 69 (inclusive) se califica como 'D'.\n * - Una calificación por debajo de 60 se califica como 'E'.\n * Si la calificación está fuera del rango de 0 a 100, se devuelve un mensaje de error.\n * Entrada: Una calificación numérica.\n * Salida: Devuelve la calificación con letra correspondiente o un mensaje de error si la calificación está fuera de rango.\n */\n \nfunction convertScoreToGrade($score) ",
      "arb": "<?php\n\n/**\n * يحول درجة رقمية إلى الدرجة الحرفية المقابلة لها.\n * نظام التقييم هو كما يلي:\n * - الدرجة بين 90 و 100 (شاملاً) تُصنف كـ 'A'.\n * - الدرجة بين 80 و 89 (شاملاً) تُصنف كـ 'B'.\n * - الدرجة بين 70 و 79 (شاملاً) تُصنف كـ 'C'.\n * - الدرجة بين 60 و 69 (شاملاً) تُصنف كـ 'D'.\n * - الدرجة أقل من 60 تُصنف كـ 'E'.\n * إذا كانت الدرجة خارج نطاق 0 إلى 100، يتم إرجاع رسالة خطأ.\n * المدخل: درجة رقمية.\n * المخرج: يعيد الدرجة الحرفية المقابلة أو رسالة خطأ إذا كانت الدرجة خارج النطاق.\n */\n \nfunction convertScoreToGrade($score) ",
      "sw": "<?php\n\n/**\n * Hubadilisha alama ya nambari kuwa daraja la herufi linalolingana.\n * Mfumo wa upangaji ni kama ifuatavyo:\n * - Alama kati ya 90 na 100 (ikijumuisha) inapewa daraja 'A'.\n * - Alama kati ya 80 na 89 (ikijumuisha) inapewa daraja 'B'.\n * - Alama kati ya 70 na 79 (ikijumuisha) inapewa daraja 'C'.\n * - Alama kati ya 60 na 69 (ikijumuisha) inapewa daraja 'D'.\n * - Alama chini ya 60 inapewa daraja 'E'.\n * Ikiwa alama iko nje ya kiwango cha 0 hadi 100, ujumbe wa kosa unarejeshwa.\n * Ingizo: Alama ya nambari.\n * Tokeo: Inarejesha daraja la herufi linalolingana au ujumbe wa kosa ikiwa alama iko nje ya kiwango.\n */\n \nfunction convertScoreToGrade($score) ",
      "tr": "<?php\n\n/**\n * Sayısal bir puanı karşılık gelen harf notuna dönüştürür.\n * Notlandırma sistemi aşağıdaki gibidir:\n * - 90 ile 100 (dahil) arasındaki bir puan 'A' olarak derecelendirilir.\n * - 80 ile 89 (dahil) arasındaki bir puan 'B' olarak derecelendirilir.\n * - 70 ile 79 (dahil) arasındaki bir puan 'C' olarak derecelendirilir.\n * - 60 ile 69 (dahil) arasındaki bir puan 'D' olarak derecelendirilir.\n * - 60'ın altındaki bir puan 'E' olarak derecelendirilir.\n * Puan 0 ile 100 aralığının dışındaysa, bir hata mesajı döndürülür.\n * Girdi: Sayısal bir puan.\n * Çıktı: Karşılık gelen harf notunu veya puan aralık dışındaysa bir hata mesajı döndürür.\n */\n \nfunction convertScoreToGrade($score) ",
      "vi": "<?php\n\n/**\n * Chuyển đổi điểm số thành điểm chữ tương ứng.\n * Hệ thống chấm điểm như sau:\n * - Điểm số từ 90 đến 100 (bao gồm) được chấm là 'A'.\n * - Điểm số từ 80 đến 89 (bao gồm) được chấm là 'B'.\n * - Điểm số từ 70 đến 79 (bao gồm) được chấm là 'C'.\n * - Điểm số từ 60 đến 69 (bao gồm) được chấm là 'D'.\n * - Điểm số dưới 60 được chấm là 'E'.\n * Nếu điểm số nằm ngoài phạm vi từ 0 đến 100, một thông báo lỗi sẽ được trả về.\n * Đầu vào: Một điểm số dạng số.\n * Đầu ra: Trả về điểm chữ tương ứng hoặc một thông báo lỗi nếu điểm số nằm ngoài phạm vi.\n */\n \nfunction convertScoreToGrade($score) "
    },
    "prompt_bertscore": {
      "es": "0.9729598503385776",
      "arb": "0.9728730488620653",
      "sw": "0.9644912440431551",
      "tr": "0.9967736467208503",
      "vi": "0.9597445738275644"
    },
    "canonical_solution": "{\n    if ($score < 0 || $score > 100) {\n        return \"Score is error!\";\n    } elseif ($score >= 90) {\n        return 'A';\n    } elseif ($score >= 80) {\n        return 'B';\n    } elseif ($score >= 70) {\n        return 'C';\n    } elseif ($score >= 60) {\n        return 'D';\n    } else {\n        return 'E';\n    }\n}",
    "instruction": {
      "en": "function convertScoreToGrade($score)\n{\n    if ($score < 0 || $score > 100) {\n        return \"Score is error!\";\n    } elseif ($score >= 90) {\n        return 'A';\n    } elseif ($score >= 80) {\n        return 'B';\n    } elseif ($score >= 70) {\n        return 'C';\n    } elseif ($score >= 60) {\n        return 'D';\n    } else {\n        return 'E';\n    }\n}\n\nProvide a concise natural language description (docstring) of the PHP code in English using at most 500 characters.",
      "es": "function convertScoreToGrade($score)\n{\n    if ($score < 0 || $score > 100) {\n        return \"Score is error!\";\n    } elseif ($score >= 90) {\n        return 'A';\n    } elseif ($score >= 80) {\n        return 'B';\n    } elseif ($score >= 70) {\n        return 'C';\n    } elseif ($score >= 60) {\n        return 'D';\n    } else {\n        return 'E';\n    }\n}\n\nProporcione una descripción concisa en lenguaje natural (docstring) del código PHP en español utilizando un máximo de 500 caracteres.",
      "arb": "function convertScoreToGrade($score)\n{\n    if ($score < 0 || $score > 100) {\n        return \"Score is error!\";\n    } elseif ($score >= 90) {\n        return 'A';\n    } elseif ($score >= 80) {\n        return 'B';\n    } elseif ($score >= 70) {\n        return 'C';\n    } elseif ($score >= 60) {\n        return 'D';\n    } else {\n        return 'E';\n    }\n}\n\nيرجى تقديم وصف موجز بلغة طبيعية (docstring) للكود المكتوب بلغة PHP باللغة العربية الفصحى، بحيث لا يتجاوز 500 حرف.",
      "sw": "function convertScoreToGrade($score)\n{\n    if ($score < 0 || $score > 100) {\n        return \"Score is error!\";\n    } elseif ($score >= 90) {\n        return 'A';\n    } elseif ($score >= 80) {\n        return 'B';\n    } elseif ($score >= 70) {\n        return 'C';\n    } elseif ($score >= 60) {\n        return 'D';\n    } else {\n        return 'E';\n    }\n}\n\nToa maelezo mafupi ya lugha ya asili (docstring) ya msimbo wa PHP kwa Kiswahili kwa kutumia herufi zisizozidi 500.",
      "tr": "function convertScoreToGrade($score)\n{\n    if ($score < 0 || $score > 100) {\n        return \"Score is error!\";\n    } elseif ($score >= 90) {\n        return 'A';\n    } elseif ($score >= 80) {\n        return 'B';\n    } elseif ($score >= 70) {\n        return 'C';\n    } elseif ($score >= 60) {\n        return 'D';\n    } else {\n        return 'E';\n    }\n}\n\nPHP kodunun işlevselliğini açıklayan, en fazla 500 karakter uzunluğunda Türkçe bir açıklama (docstring) sağlayın.",
      "vi": "function convertScoreToGrade($score)\n{\n    if ($score < 0 || $score > 100) {\n        return \"Score is error!\";\n    } elseif ($score >= 90) {\n        return 'A';\n    } elseif ($score >= 80) {\n        return 'B';\n    } elseif ($score >= 70) {\n        return 'C';\n    } elseif ($score >= 60) {\n        return 'D';\n    } else {\n        return 'E';\n    }\n}\n\nCung cấp mô tả ngắn gọn bằng ngôn ngữ tự nhiên (docstring) cho mã PHP bằng tiếng Việt, không quá 500 ký tự."
    },
    "instruction_bertscore": {
      "es": "0.9687069752502395",
      "arb": "0.8833251100712498",
      "sw": "0.91585798565943",
      "tr": "0.8343841732273016",
      "vi": "0.9159233350547905"
    },
    "level": "",
    "test": "function main(){\n    assert(convertScoreToGrade(95) === 'A');\n    assert(convertScoreToGrade(85) === 'B');\n    assert(convertScoreToGrade(75) === 'C');\n    assert(convertScoreToGrade(65) === 'D');\n    assert(convertScoreToGrade(55) === 'E');\n    assert(convertScoreToGrade(-1) === 'Score is error!');\n    assert(convertScoreToGrade(101) === 'Score is error!');\n    \n}\n\nmain();\n?>",
    "entry_point": "convertScoreToGrade",
    "signature": "function convertScoreToGrade($score)",
    "docstring": {
      "en": "Converts a numerical score to its corresponding letter grade.\nThe grading system is as follows:\n- A score between 90 and 100 (inclusive) is graded as 'A'.\n- A score between 80 and 89 (inclusive) is graded as 'B'.\n- A score between 70 and 79 (inclusive) is graded as 'C'.\n- A score between 60 and 69 (inclusive) is graded as 'D'.\n- A score below 60 is graded as 'E'.\nIf the score is outside the range of 0 to 100, an error message is returned.\nInput: A numeric score.\nOutput: Returns the corresponding letter grade or an error message if the score is out of range.",
      "es": "Convierte una puntuación numérica en su correspondiente calificación con letra.  \nEl sistema de calificación es el siguiente:  \n- Una puntuación entre 90 y 100 (inclusive) se califica como 'A'.  \n- Una puntuación entre 80 y 89 (inclusive) se califica como 'B'.  \n- Una puntuación entre 70 y 79 (inclusive) se califica como 'C'.  \n- Una puntuación entre 60 y 69 (inclusive) se califica como 'D'.  \n- Una puntuación por debajo de 60 se califica como 'E'.  \nSi la puntuación está fuera del rango de 0 a 100, se devuelve un mensaje de error.  \nEntrada: Una puntuación numérica.  \nSalida: Devuelve la calificación con letra correspondiente o un mensaje de error si la puntuación está fuera de rango.",
      "arb": "يحول درجة رقمية إلى درجة حرفية مقابلة لها. نظام التقييم هو كما يلي:\n- الدرجة بين 90 و 100 (شاملة) تُصنف كـ 'A'.\n- الدرجة بين 80 و 89 (شاملة) تُصنف كـ 'B'.\n- الدرجة بين 70 و 79 (شاملة) تُصنف كـ 'C'.\n- الدرجة بين 60 و 69 (شاملة) تُصنف كـ 'D'.\n- الدرجة أقل من 60 تُصنف كـ 'E'.\nإذا كانت الدرجة خارج النطاق من 0 إلى 100، يتم إرجاع رسالة خطأ.\nالمدخل: درجة رقمية.\nالمخرج: يُرجع الدرجة الحرفية المقابلة أو رسالة خطأ إذا كانت الدرجة خارج النطاق.",
      "sw": "Hurekebisha alama ya nambari kuwa daraja la herufi linalolingana.\nMfumo wa upangaji ni kama ifuatavyo:\n- Alama kati ya 90 na 100 (pamoja) inapewa daraja la 'A'.\n- Alama kati ya 80 na 89 (pamoja) inapewa daraja la 'B'.\n- Alama kati ya 70 na 79 (pamoja) inapewa daraja la 'C'.\n- Alama kati ya 60 na 69 (pamoja) inapewa daraja la 'D'.\n- Alama chini ya 60 inapewa daraja la 'E'.\nIkiwa alama iko nje ya kiwango cha 0 hadi 100, ujumbe wa kosa utarejeshwa.\nIngizo: Alama ya nambari.\nPato: Inarejesha daraja la herufi linalolingana au ujumbe wa kosa ikiwa alama iko nje ya kiwango.",
      "tr": "Sayısal bir puanı, karşılık gelen harf notuna dönüştürür. Not sistemi aşağıdaki gibidir:\n- 90 ile 100 (dahil) arasındaki bir puan 'A' olarak derecelendirilir.\n- 80 ile 89 (dahil) arasındaki bir puan 'B' olarak derecelendirilir.\n- 70 ile 79 (dahil) arasındaki bir puan 'C' olarak derecelendirilir.\n- 60 ile 69 (dahil) arasındaki bir puan 'D' olarak derecelendirilir.\n- 60'ın altındaki bir puan 'E' olarak derecelendirilir.\nEğer puan 0 ile 100 aralığında değilse, bir hata mesajı döndürülür.\nGirdi: Sayısal bir puan.\nÇıktı: Karşılık gelen harf notunu veya puan aralık dışındaysa bir hata mesajı döndürür.",
      "vi": "Chuyển đổi điểm số thành điểm chữ tương ứng.  \nHệ thống chấm điểm như sau:  \n- Điểm từ 90 đến 100 (bao gồm cả hai) được chấm là 'A'.  \n- Điểm từ 80 đến 89 (bao gồm cả hai) được chấm là 'B'.  \n- Điểm từ 70 đến 79 (bao gồm cả hai) được chấm là 'C'.  \n- Điểm từ 60 đến 69 (bao gồm cả hai) được chấm là 'D'.  \n- Điểm dưới 60 được chấm là 'E'.  \nNếu điểm nằm ngoài phạm vi từ 0 đến 100, một thông báo lỗi sẽ được trả về.  \nĐầu vào: Một điểm số.  \nĐầu ra: Trả về điểm chữ tương ứng hoặc một thông báo lỗi nếu điểm nằm ngoài phạm vi.  "
    },
    "docstring_bertscore": {
      "es": "0.9983305116474017",
      "arb": "0.9700608399273734",
      "sw": "0.9500698838584981",
      "tr": "0.9919963874265803",
      "vi": "0.9453597616330178"
    }
  },
  {
    "task_id": "PHP/5",
    "prompt": {
      "en": "<?php\n/**\n * Calculates the day number of the year for a given date.\n * This function takes a date in the format 'YYYY/MM/DD' and returns the day number\n * in the year for that date. For example, '2024/01/01' would return 1, as it is the first day of the year,\n * while '2024/12/31' would return 366 for a leap year or 365 otherwise.\n * Input: A string representing the date in 'YYYY/MM/DD' format.\n * Output: An integer representing the day number in the year.\n */\n\nfunction getDayOfYear($date): int ",
      "es": "<?php\n/**\n * Calcula el número de día del año para una fecha dada.\n * Esta función toma una fecha en el formato 'YYYY/MM/DD' y devuelve el número de día\n * en el año para esa fecha. Por ejemplo, '2024/01/01' devolvería 1, ya que es el primer día del año,\n * mientras que '2024/12/31' devolvería 366 para un año bisiesto o 365 de lo contrario.\n * Entrada: Una cadena que representa la fecha en formato 'YYYY/MM/DD'.\n * Salida: Un entero que representa el número de día en el año.\n */\n\nfunction getDayOfYear($date): int ",
      "arb": "<?php\n/**\n * يحسب رقم اليوم في السنة لتاريخ معين.\n * تأخذ هذه الدالة تاريخًا بصيغة 'YYYY/MM/DD' وتعيد رقم اليوم\n * في السنة لذلك التاريخ. على سبيل المثال، '2024/01/01' ستعيد 1، لأنه اليوم الأول من السنة،\n * بينما '2024/12/31' ستعيد 366 في سنة كبيسة أو 365 خلاف ذلك.\n * المدخل: سلسلة تمثل التاريخ بصيغة 'YYYY/MM/DD'.\n * المخرج: عدد صحيح يمثل رقم اليوم في السنة.\n */\n\nfunction getDayOfYear($date): int ",
      "sw": "<?php\n/**\n * Inahesabu nambari ya siku ya mwaka kwa tarehe iliyotolewa.\n * Kazi hii inachukua tarehe katika muundo wa 'YYYY/MM/DD' na kurudisha nambari ya siku\n * katika mwaka kwa tarehe hiyo. Kwa mfano, '2024/01/01' itarudisha 1, kwa kuwa ni siku ya kwanza ya mwaka,\n * wakati '2024/12/31' itarudisha 366 kwa mwaka wa kuruka au 365 vinginevyo.\n * Ingizo: Kamba inayowakilisha tarehe katika muundo wa 'YYYY/MM/DD'.\n * Matokeo: Nambari ya mzima inayowakilisha nambari ya siku katika mwaka.\n */\n\nfunction getDayOfYear($date): int ",
      "tr": "<?php\n/**\n * Belirli bir tarih için yılın gün numarasını hesaplar.\n * Bu fonksiyon 'YYYY/MM/DD' formatında bir tarih alır ve o tarihin yıl içindeki gün numarasını döndürür.\n * Örneğin, '2024/01/01' yılı ilk gün olduğu için 1 döndürecektir,\n * '2024/12/31' ise artık yıl için 366 veya diğer durumlarda 365 döndürecektir.\n * Girdi: 'YYYY/MM/DD' formatında tarihi temsil eden bir dize.\n * Çıktı: Yıl içindeki gün numarasını temsil eden bir tamsayı.\n */\n\nfunction getDayOfYear($date): int ",
      "vi": "<?php\n/**\n * Tính toán số thứ tự của ngày trong năm cho một ngày nhất định.\n * Hàm này nhận một ngày ở định dạng 'YYYY/MM/DD' và trả về số thứ tự\n * của ngày đó trong năm. Ví dụ, '2024/01/01' sẽ trả về 1, vì đó là ngày đầu tiên của năm,\n * trong khi '2024/12/31' sẽ trả về 366 cho năm nhuận hoặc 365 nếu không phải năm nhuận.\n * Đầu vào: Một chuỗi đại diện cho ngày ở định dạng 'YYYY/MM/DD'.\n * Đầu ra: Một số nguyên đại diện cho số thứ tự của ngày trong năm.\n */\n\nfunction getDayOfYear($date): int "
    },
    "prompt_bertscore": {
      "es": "1",
      "arb": "0.9870483060046201",
      "sw": "0.9840509735548036",
      "tr": "0.9634281742438564",
      "vi": "0.936456750694272"
    },
    "canonical_solution": "{\n    $dateParts = explode('/', $date);\n    $year = (int) $dateParts[0];\n    $month = (int) $dateParts[1];\n    $day = (int) $dateParts[2];\n\n    $isLeapYear = ($year % 4 == 0 && $year % 100 != 0) || $year % 400 == 0;\n    $monthDays = [31, $isLeapYear ? 29 : 28, 31, 30, 31, 30, 31, 31, 30, 31, 30, 31];\n\n    $dayOfYear = 0;\n    for ($i = 0; $i < $month - 1; $i++) {\n        $dayOfYear += $monthDays[$i];\n    }\n    $dayOfYear += $day;\n\n    return $dayOfYear;\n}",
    "instruction": {
      "en": "function getDayOfYear($date): int\n{\n    $dateParts = explode('/', $date);\n    $year = (int) $dateParts[0];\n    $month = (int) $dateParts[1];\n    $day = (int) $dateParts[2];\n\n    $isLeapYear = ($year % 4 == 0 && $year % 100 != 0) || $year % 400 == 0;\n    $monthDays = [31, $isLeapYear ? 29 : 28, 31, 30, 31, 30, 31, 31, 30, 31, 30, 31];\n\n    $dayOfYear = 0;\n    for ($i = 0; $i < $month - 1; $i++) {\n        $dayOfYear += $monthDays[$i];\n    }\n    $dayOfYear += $day;\n\n    return $dayOfYear;\n}\n\nProvide a concise natural language description (docstring) of the PHP code in English using at most 500 characters.",
      "es": "function getDayOfYear($date): int\n{\n    $dateParts = explode('/', $date);\n    $year = (int) $dateParts[0];\n    $month = (int) $dateParts[1];\n    $day = (int) $dateParts[2];\n\n    $isLeapYear = ($year % 4 == 0 && $year % 100 != 0) || $year % 400 == 0;\n    $monthDays = [31, $isLeapYear ? 29 : 28, 31, 30, 31, 30, 31, 31, 30, 31, 30, 31];\n\n    $dayOfYear = 0;\n    for ($i = 0; $i < $month - 1; $i++) {\n        $dayOfYear += $monthDays[$i];\n    }\n    $dayOfYear += $day;\n\n    return $dayOfYear;\n}\n\nProporcione una descripción concisa en lenguaje natural (docstring) del código PHP en español utilizando un máximo de 500 caracteres.",
      "arb": "function getDayOfYear($date): int\n{\n    $dateParts = explode('/', $date);\n    $year = (int) $dateParts[0];\n    $month = (int) $dateParts[1];\n    $day = (int) $dateParts[2];\n\n    $isLeapYear = ($year % 4 == 0 && $year % 100 != 0) || $year % 400 == 0;\n    $monthDays = [31, $isLeapYear ? 29 : 28, 31, 30, 31, 30, 31, 31, 30, 31, 30, 31];\n\n    $dayOfYear = 0;\n    for ($i = 0; $i < $month - 1; $i++) {\n        $dayOfYear += $monthDays[$i];\n    }\n    $dayOfYear += $day;\n\n    return $dayOfYear;\n}\n\nيرجى تقديم وصف موجز بلغة طبيعية (docstring) لشيفرة PHP باللغة العربية الفصحى باستخدام 500 حرف كحد أقصى.",
      "sw": "function getDayOfYear($date): int\n{\n    $dateParts = explode('/', $date);\n    $year = (int) $dateParts[0];\n    $month = (int) $dateParts[1];\n    $day = (int) $dateParts[2];\n\n    $isLeapYear = ($year % 4 == 0 && $year % 100 != 0) || $year % 400 == 0;\n    $monthDays = [31, $isLeapYear ? 29 : 28, 31, 30, 31, 30, 31, 31, 30, 31, 30, 31];\n\n    $dayOfYear = 0;\n    for ($i = 0; $i < $month - 1; $i++) {\n        $dayOfYear += $monthDays[$i];\n    }\n    $dayOfYear += $day;\n\n    return $dayOfYear;\n}\n\nToa maelezo mafupi ya lugha ya asili (docstring) ya msimbo wa PHP kwa Kiswahili kwa kutumia herufi zisizozidi 500.",
      "tr": "function getDayOfYear($date): int\n{\n    $dateParts = explode('/', $date);\n    $year = (int) $dateParts[0];\n    $month = (int) $dateParts[1];\n    $day = (int) $dateParts[2];\n\n    $isLeapYear = ($year % 4 == 0 && $year % 100 != 0) || $year % 400 == 0;\n    $monthDays = [31, $isLeapYear ? 29 : 28, 31, 30, 31, 30, 31, 31, 30, 31, 30, 31];\n\n    $dayOfYear = 0;\n    for ($i = 0; $i < $month - 1; $i++) {\n        $dayOfYear += $monthDays[$i];\n    }\n    $dayOfYear += $day;\n\n    return $dayOfYear;\n}\n\nPHP kodunun işlevini açıklayan kısa bir doğal dil açıklaması (docstring) sağlayın. Açıklama, en fazla 500 karakter kullanılarak Türkçe olarak yazılmalıdır.",
      "vi": "function getDayOfYear($date): int\n{\n    $dateParts = explode('/', $date);\n    $year = (int) $dateParts[0];\n    $month = (int) $dateParts[1];\n    $day = (int) $dateParts[2];\n\n    $isLeapYear = ($year % 4 == 0 && $year % 100 != 0) || $year % 400 == 0;\n    $monthDays = [31, $isLeapYear ? 29 : 28, 31, 30, 31, 30, 31, 31, 30, 31, 30, 31];\n\n    $dayOfYear = 0;\n    for ($i = 0; $i < $month - 1; $i++) {\n        $dayOfYear += $monthDays[$i];\n    }\n    $dayOfYear += $day;\n\n    return $dayOfYear;\n}\n\nCung cấp mô tả ngắn gọn bằng ngôn ngữ tự nhiên (docstring) cho mã PHP bằng tiếng Việt với tối đa 500 ký tự."
    },
    "instruction_bertscore": {
      "es": "0.9687069752502395",
      "arb": "0.9148910529645522",
      "sw": "0.9428367585331127",
      "tr": "0.8849808929275567",
      "vi": "0.9468731265061225"
    },
    "level": "",
    "test": "function main(){\n    assert(getDayOfYear('2024/01/01') === 1);\n    assert(getDayOfYear('2024/03/01') === 61); // Non-leap year\n    assert(getDayOfYear('2024/12/31') === 366); // Leap year\n    assert(getDayOfYear('2023/12/31') === 365); // Non-leap year\n    \n}\n\nmain();\n?>",
    "entry_point": "getDayOfYear",
    "signature": "function getDayOfYear($date): int",
    "docstring": {
      "en": "Calculates the day number of the year for a given date.\nThis function takes a date in the format 'YYYY/MM/DD' and returns the day number\nin the year for that date. For example, '2024/01/01' would return 1, as it is the first day of the year,\nwhile '2024/12/31' would return 366 for a leap year or 365 otherwise.\nInput: A string representing the date in 'YYYY/MM/DD' format.\nOutput: An integer representing the day number in the year.",
      "es": "Calcula el número de día del año para una fecha dada.  \nEsta función toma una fecha en el formato 'YYYY/MM/DD' y devuelve el número de día  \nen el año para esa fecha. Por ejemplo, '2024/01/01' devolvería 1, ya que es el primer día del año,  \nmientras que '2024/12/31' devolvería 366 para un año bisiesto o 365 de lo contrario.  \nEntrada: Una cadena que representa la fecha en formato 'YYYY/MM/DD'.  \nSalida: Un entero que representa el número de día en el año.",
      "arb": "يحسب رقم اليوم في السنة لتاريخ معين.  \nتأخذ هذه الدالة تاريخًا بالتنسيق 'YYYY/MM/DD' وتعيد رقم اليوم في السنة لذلك التاريخ. على سبيل المثال، '2024/01/01' ستعيد 1، لأنه اليوم الأول من السنة، بينما '2024/12/31' ستعيد 366 في سنة كبيسة أو 365 خلاف ذلك.  \nالمدخل: سلسلة تمثل التاريخ بالتنسيق 'YYYY/MM/DD'.  \nالمخرج: عدد صحيح يمثل رقم اليوم في السنة.",
      "sw": "Hesabu namba ya siku ya mwaka kwa tarehe iliyotolewa.\nKazi hii inachukua tarehe katika muundo wa 'YYYY/MM/DD' na inarejesha namba ya siku\nkatika mwaka kwa tarehe hiyo. Kwa mfano, '2024/01/01' itarejesha 1, kwani ni siku ya kwanza ya mwaka,\nwakati '2024/12/31' itarejesha 366 kwa mwaka wa kuruka au 365 vinginevyo.\nIngizo: Kamba inayowakilisha tarehe katika muundo wa 'YYYY/MM/DD'.\nMatokeo: Nambari ya kipekee inayowakilisha namba ya siku katika mwaka.",
      "tr": "Yılın gün numarasını verilen bir tarih için hesaplar.\nBu fonksiyon, 'YYYY/MM/DD' formatında bir tarihi alır ve o tarih için yılın gün numarasını döndürür. Örneğin, '2024/01/01' yılı ilk gün olduğu için 1 döndürecektir, '2024/12/31' ise artık yıl için 366 veya aksi takdirde 365 döndürecektir.\nGirdi: 'YYYY/MM/DD' formatında tarihi temsil eden bir dize.\nÇıktı: Yılın gün numarasını temsil eden bir tamsayı.",
      "vi": "Tính toán số ngày trong năm cho một ngày nhất định.  \nHàm này nhận một ngày theo định dạng 'YYYY/MM/DD' và trả về số ngày trong năm cho ngày đó. Ví dụ, '2024/01/01' sẽ trả về 1, vì đó là ngày đầu tiên của năm, trong khi '2024/12/31' sẽ trả về 366 cho một năm nhuận hoặc 365 nếu không phải.  \nĐầu vào: Một chuỗi đại diện cho ngày theo định dạng 'YYYY/MM/DD'.  \nĐầu ra: Một số nguyên đại diện cho số ngày trong năm."
    },
    "docstring_bertscore": {
      "es": "0.997387017337486",
      "arb": "0.9788065356043395",
      "sw": "0.9765939917899918",
      "tr": "0.9796393927920188",
      "vi": "0.9459977624169018"
    }
  },
  {
    "task_id": "PHP/6",
    "prompt": {
      "en": "<?php\n/**\n    * Calculates the sum of all positive integers less than or equal to a given number N that are not 'related' to the number 2.\n    * A number is 'related' to 2 if it is divisible by 2 or if any of its digits is 2.\n    * For example, for N = 8, the numbers not related to 2 are 1, 3, 5, and 7, and their sum is 16.\n    * Input: An integer N.\n    * Output: Returns the sum of all integers less than or equal to N that are not related to 2.\n*/\n\nfunction sumOfUnrelatedToTwo($N) ",
      "es": "<?php\n/**\n    * Calcula la suma de todos los enteros positivos menores o iguales a un número dado N que no están 'relacionados' con el número 2.\n    * Un número está 'relacionado' con 2 si es divisible por 2 o si alguno de sus dígitos es 2.\n    * Por ejemplo, para N = 8, los números no relacionados con 2 son 1, 3, 5 y 7, y su suma es 16.\n    * Entrada: Un entero N.\n    * Salida: Devuelve la suma de todos los enteros menores o iguales a N que no están relacionados con 2.\n*/\n\nfunction sumOfUnrelatedToTwo($N) ",
      "arb": "<?php\n/**\n    * يحسب مجموع جميع الأعداد الصحيحة الموجبة الأقل من أو تساوي عدد معين N التي لا ترتبط بالعدد 2.\n    * يُعتبر العدد 'مرتبطًا' بالعدد 2 إذا كان قابلاً للقسمة على 2 أو إذا كان يحتوي أي من أرقامه على الرقم 2.\n    * على سبيل المثال، بالنسبة لـ N = 8، الأعداد التي لا ترتبط بالعدد 2 هي 1، 3، 5، و7، ومجموعها هو 16.\n    * المدخل: عدد صحيح N.\n    * المخرج: يعيد مجموع جميع الأعداد الصحيحة الأقل من أو تساوي N التي لا ترتبط بالعدد 2.\n*/\n\nfunction sumOfUnrelatedToTwo($N) ",
      "sw": "<?php\n/**\n    * Hutafuta jumla ya namba zote nzima chanya zilizo chini au sawa na namba fulani N ambazo hazihusiani na namba 2.\n    * Namba inahusiana na 2 ikiwa inagawanyika kwa 2 au ikiwa yoyote ya tarakimu zake ni 2.\n    * Kwa mfano, kwa N = 8, namba ambazo hazihusiani na 2 ni 1, 3, 5, na 7, na jumla yao ni 16.\n    * Ingizo: Namba nzima N.\n    * Matokeo: Inarudisha jumla ya namba zote zilizo chini au sawa na N ambazo hazihusiani na 2.\n*/\n\nfunction sumOfUnrelatedToTwo($N) ",
      "tr": "<?php\n/**\n    * 2 ile 'ilişkili' olmayan, verilen bir sayı N'den küçük veya ona eşit olan tüm pozitif tam sayıların toplamını hesaplar.\n    * Bir sayı, 2'ye bölünebiliyorsa veya herhangi bir basamağı 2 ise 'ilişkili' kabul edilir.\n    * Örneğin, N = 8 için, 2 ile ilişkili olmayan sayılar 1, 3, 5 ve 7'dir ve bunların toplamı 16'dır.\n    * Girdi: Bir tam sayı N.\n    * Çıktı: 2 ile ilişkili olmayan, N'den küçük veya ona eşit olan tüm tam sayıların toplamını döndürür.\n*/\n\nfunction sumOfUnrelatedToTwo($N) ",
      "vi": "<?php\n/**\n    * Tính tổng của tất cả các số nguyên dương nhỏ hơn hoặc bằng một số cho trước N mà không 'liên quan' đến số 2.\n    * Một số được coi là 'liên quan' đến 2 nếu nó chia hết cho 2 hoặc nếu bất kỳ chữ số nào của nó là 2.\n    * Ví dụ, với N = 8, các số không liên quan đến 2 là 1, 3, 5, và 7, và tổng của chúng là 16.\n    * Đầu vào: Một số nguyên N.\n    * Đầu ra: Trả về tổng của tất cả các số nguyên nhỏ hơn hoặc bằng N mà không liên quan đến 2.\n*/\n\nfunction sumOfUnrelatedToTwo($N) "
    },
    "prompt_bertscore": {
      "es": "1",
      "arb": "0.9687957630305621",
      "sw": "0.9688380713017226",
      "tr": "0.9845789331075944",
      "vi": "0.99306541613731"
    },
    "canonical_solution": "{\n    $sum = 0;\n    for ($i = 1; $i <= $N; $i++) {\n        if ($i % 2 != 0 && strpos((string)$i, '2') === false) {\n            $sum += $i;\n        }\n    }\n    return $sum;\n}",
    "instruction": {
      "en": "function sumOfUnrelatedToTwo($N)\n{\n    $sum = 0;\n    for ($i = 1; $i <= $N; $i++) {\n        if ($i % 2 != 0 && strpos((string)$i, '2') === false) {\n            $sum += $i;\n        }\n    }\n    return $sum;\n}\n\nProvide a concise natural language description (docstring) of the PHP code in English using at most 500 characters.",
      "es": "function sumOfUnrelatedToTwo($N)\n{\n    $sum = 0;\n    for ($i = 1; $i <= $N; $i++) {\n        if ($i % 2 != 0 && strpos((string)$i, '2') === false) {\n            $sum += $i;\n        }\n    }\n    return $sum;\n}\n\nProporcione una descripción concisa en lenguaje natural (docstring) del código PHP en español utilizando un máximo de 500 caracteres.",
      "arb": "function sumOfUnrelatedToTwo($N)\n{\n    $sum = 0;\n    for ($i = 1; $i <= $N; $i++) {\n        if ($i % 2 != 0 && strpos((string)$i, '2') === false) {\n            $sum += $i;\n        }\n    }\n    return $sum;\n}\n\nيرجى تقديم وصف موجز بلغة طبيعية (docstring) لشيفرة PHP باللغة العربية الفصحى، بحيث لا يتجاوز 500 حرف.",
      "sw": "function sumOfUnrelatedToTwo($N)\n{\n    $sum = 0;\n    for ($i = 1; $i <= $N; $i++) {\n        if ($i % 2 != 0 && strpos((string)$i, '2') === false) {\n            $sum += $i;\n        }\n    }\n    return $sum;\n}\n\nToa maelezo mafupi ya lugha asilia (docstring) ya msimbo wa PHP kwa Kiswahili kwa kutumia herufi zisizozidi 500.",
      "tr": "function sumOfUnrelatedToTwo($N)\n{\n    $sum = 0;\n    for ($i = 1; $i <= $N; $i++) {\n        if ($i % 2 != 0 && strpos((string)$i, '2') === false) {\n            $sum += $i;\n        }\n    }\n    return $sum;\n}\n\nPHP kodunun işlevini açıklayan kısa bir doğal dil açıklaması (docstring) sağlayın. Açıklama, en fazla 500 karakter kullanılarak Türkçe olarak yazılmalıdır.",
      "vi": "function sumOfUnrelatedToTwo($N)\n{\n    $sum = 0;\n    for ($i = 1; $i <= $N; $i++) {\n        if ($i % 2 != 0 && strpos((string)$i, '2') === false) {\n            $sum += $i;\n        }\n    }\n    return $sum;\n}\n\nCung cấp mô tả ngắn gọn bằng ngôn ngữ tự nhiên (docstring) cho mã PHP bằng tiếng Việt, sử dụng tối đa 500 ký tự."
    },
    "instruction_bertscore": {
      "es": "0.9687069752502395",
      "arb": "0.905616007322128",
      "sw": "0.9428367585331127",
      "tr": "0.881863190466833",
      "vi": "0.95069020653847"
    },
    "level": "",
    "test": "function main(){\n    assert(sumOfUnrelatedToTwo(8) === 16);  // 1 + 3 + 5 + 7\n    assert(sumOfUnrelatedToTwo(10) === 25); // 1 + 3 + 5 + 7 + 9\n    assert(sumOfUnrelatedToTwo(2) === 1);   // 1\n    assert(sumOfUnrelatedToTwo(22) === 100); // Sum of numbers not containing 2 and not even, up to 22\n    assert(sumOfUnrelatedToTwo(0) === 0);   // No numbers to sum\n    \n}\n\n\nmain();\n?>",
    "entry_point": "sumOfUnrelatedToTwo",
    "signature": "function sumOfUnrelatedToTwo($N)",
    "docstring": {
      "en": "Calculates the sum of all positive integers less than or equal to a given number N that are not 'related' to the number 2.\nA number is 'related' to 2 if it is divisible by 2 or if any of its digits is 2.\nFor example, for N = 8, the numbers not related to 2 are 1, 3, 5, and 7, and their sum is 16.\nInput: An integer N.\nOutput: Returns the sum of all integers less than or equal to N that are not related to 2.",
      "es": "Calcula la suma de todos los enteros positivos menores o iguales a un número dado N que no están 'relacionados' con el número 2.  \nUn número está 'relacionado' con 2 si es divisible por 2 o si alguno de sus dígitos es 2.  \nPor ejemplo, para N = 8, los números no relacionados con 2 son 1, 3, 5 y 7, y su suma es 16.  \nEntrada: Un entero N.  \nSalida: Devuelve la suma de todos los enteros menores o iguales a N que no están relacionados con 2.",
      "arb": "يحسب مجموع جميع الأعداد الصحيحة الموجبة الأقل من أو تساوي عدد معين N والتي لا تكون 'مرتبطة' بالعدد 2.  \nيعتبر العدد 'مرتبطًا' بالعدد 2 إذا كان قابلاً للقسمة على 2 أو إذا كان يحتوي على الرقم 2 في أي من أرقامه.  \nعلى سبيل المثال، بالنسبة لـ N = 8، الأعداد التي لا ترتبط بالعدد 2 هي 1، 3، 5، و7، ومجموعها هو 16.  \nالمدخلات: عدد صحيح N.  \nالمخرجات: يعيد مجموع جميع الأعداد الصحيحة الأقل من أو تساوي N والتي لا ترتبط بالعدد 2.  ",
      "sw": "Hesabu jumla ya namba zote nzima chanya zilizo chini au sawa na namba fulani N ambazo hazihusiani na namba 2. \nNamba inahusiana na 2 ikiwa inagawanyika kwa 2 au ikiwa yoyote ya tarakimu zake ni 2. \nKwa mfano, kwa N = 8, namba ambazo hazihusiani na 2 ni 1, 3, 5, na 7, na jumla yao ni 16.\n\nIngizo:\n    N: Nambari nzima.\n\n Matokeo: Inarudisha jumla ya namba zote zilizo chini au sawa na N ambazo hazihusiani na 2.",
      "tr": "Verilen bir sayı N'den küçük veya ona eşit olan ve 2 ile 'ilişkili' olmayan tüm pozitif tam sayıların toplamını hesaplar.\nBir sayı, 2'ye bölünebiliyorsa veya herhangi bir basamağı 2 ise 'ilişkili' kabul edilir.\nÖrneğin, N = 8 için, 2 ile ilişkili olmayan sayılar 1, 3, 5 ve 7'dir ve bunların toplamı 16'dır.\nGirdi: Bir tam sayı N.\nÇıktı: 2 ile ilişkili olmayan ve N'den küçük veya eşit olan tüm tam sayıların toplamını döndürür.",
      "vi": "Tính tổng của tất cả các số nguyên dương nhỏ hơn hoặc bằng một số cho trước N mà không 'liên quan' đến số 2.  \nMột số được coi là 'liên quan' đến 2 nếu nó chia hết cho 2 hoặc nếu bất kỳ chữ số nào của nó là 2.  \nVí dụ, với N = 8, các số không liên quan đến 2 là 1, 3, 5 và 7, và tổng của chúng là 16.  \nĐầu vào: Một số nguyên N.  \nĐầu ra: Trả về tổng của tất cả các số nguyên nhỏ hơn hoặc bằng N mà không liên quan đến 2."
    },
    "docstring_bertscore": {
      "es": "0.9979471550120045",
      "arb": "0.9397172683989597",
      "sw": "0.9502055484087449",
      "tr": "0.9773311091340123",
      "vi": "0.9912386125229321"
    }
  },
  {
    "task_id": "PHP/7",
    "prompt": {
      "en": "<?php\n\n/**\n    * Calculates the number of different ways to exchange a paper bill into coins.\n    * Given a paper bill of value N (1 <= N <= 10), there are two types of coins available: 1 and 2 units.\n    * The function determines how many distinct combinations of these coins can sum up to the value of the bill.\n    * Example: For a bill of value 4, there are 5 ways:\n    * 4 = 1 + 1 + 1 + 1\n    * 4 = 2 + 1 + 1\n    * 4 = 1 + 2 + 1\n    * 4 = 1 + 1 + 2\n    * 4 = 2 + 2\n    * Input: An integer representing the bill value.\n    * Output: Returns the number of different ways to exchange the bill into coins.\n*/\nfunction countCoinExchangeWays($billValue) ",
      "es": "<?php\n\n/**\n    * Calcula el número de diferentes maneras de cambiar un billete por monedas.\n    * Dado un billete de valor N (1 <= N <= 10), hay dos tipos de monedas disponibles: 1 y 2 unidades.\n    * La función determina cuántas combinaciones distintas de estas monedas pueden sumar el valor del billete.\n    * Ejemplo: Para un billete de valor 4, hay 5 maneras:\n    * 4 = 1 + 1 + 1 + 1\n    * 4 = 2 + 1 + 1\n    * 4 = 1 + 2 + 1\n    * 4 = 1 + 1 + 2\n    * 4 = 2 + 2\n    * Entrada: Un entero que representa el valor del billete.\n    * Salida: Devuelve el número de diferentes maneras de cambiar el billete por monedas.\n*/\nfunction countCoinExchangeWays($billValue) ",
      "arb": "<?php\n\n/**\n    * يحسب عدد الطرق المختلفة لتحويل ورقة نقدية إلى عملات معدنية.\n    * بالنظر إلى ورقة نقدية بقيمة N (1 <= N <= 10)، هناك نوعان من العملات المتاحة: 1 و 2 وحدة.\n    * تحدد الدالة عدد التوليفات المختلفة لهذه العملات التي يمكن أن تصل إلى قيمة الورقة النقدية.\n    * مثال: لورقة نقدية بقيمة 4، هناك 5 طرق:\n    * 4 = 1 + 1 + 1 + 1\n    * 4 = 2 + 1 + 1\n    * 4 = 1 + 2 + 1\n    * 4 = 1 + 1 + 2\n    * 4 = 2 + 2\n    * المدخل: عدد صحيح يمثل قيمة الورقة النقدية.\n    * المخرج: يعيد عدد الطرق المختلفة لتحويل الورقة النقدية إلى عملات معدنية.\n*/\nfunction countCoinExchangeWays($billValue) ",
      "sw": "<?php\n\n/**\n    * Inahesabu idadi ya njia tofauti za kubadilisha noti kuwa sarafu.\n    * Ukipewa noti yenye thamani ya N (1 <= N <= 10), kuna aina mbili za sarafu zinazopatikana: 1 na 2.\n    * Kazi hii inaamua ni mchanganyiko gani tofauti wa sarafu hizi unaweza kufikia thamani ya noti.\n    * Mfano: Kwa noti ya thamani 4, kuna njia 5:\n    * 4 = 1 + 1 + 1 + 1\n    * 4 = 2 + 1 + 1\n    * 4 = 1 + 2 + 1\n    * 4 = 1 + 1 + 2\n    * 4 = 2 + 2\n    * Ingizo: Nambari nzima inayowakilisha thamani ya noti.\n    * Tokeo: Inarudisha idadi ya njia tofauti za kubadilisha noti kuwa sarafu.\n*/\nfunction countCoinExchangeWays($billValue) ",
      "tr": "<?php\n\n/**\n    * Bir kağıt parayı bozuk paralara çevirmenin farklı yollarının sayısını hesaplar.\n    * Değeri N olan bir kağıt para verildiğinde (1 <= N <= 10), iki tür bozuk para mevcuttur: 1 ve 2 birim.\n    * Fonksiyon, bu bozuk paraların kağıt paranın değerine eşit olacak şekilde kaç farklı kombinasyon oluşturabileceğini belirler.\n    * Örnek: Değeri 4 olan bir kağıt para için 5 yol vardır:\n    * 4 = 1 + 1 + 1 + 1\n    * 4 = 2 + 1 + 1\n    * 4 = 1 + 2 + 1\n    * 4 = 1 + 1 + 2\n    * 4 = 2 + 2\n    * Girdi: Kağıt para değerini temsil eden bir tamsayı.\n    * Çıktı: Parayı bozuk paralara çevirmenin farklı yollarının sayısını döndürür.\n*/\nfunction countCoinExchangeWays($billValue) ",
      "vi": "<?php\n\n/**\n    * Tính số cách khác nhau để đổi một tờ tiền giấy thành tiền xu.\n    * Cho một tờ tiền giấy có giá trị N (1 <= N <= 10), có hai loại tiền xu có sẵn: 1 và 2 đơn vị.\n    * Hàm xác định có bao nhiêu tổ hợp khác nhau của các đồng xu này có thể cộng lại thành giá trị của tờ tiền giấy.\n    * Ví dụ: Đối với tờ tiền có giá trị 4, có 5 cách:\n    * 4 = 1 + 1 + 1 + 1\n    * 4 = 2 + 1 + 1\n    * 4 = 1 + 2 + 1\n    * 4 = 1 + 1 + 2\n    * 4 = 2 + 2\n    * Đầu vào: Một số nguyên đại diện cho giá trị của tờ tiền giấy.\n    * Đầu ra: Trả về số cách khác nhau để đổi tờ tiền giấy thành tiền xu.\n*/\nfunction countCoinExchangeWays($billValue) "
    },
    "prompt_bertscore": {
      "es": "0.9859407429999696",
      "arb": "0.9333064728510587",
      "sw": "0.9619602957280086",
      "tr": "0.9649039979749456",
      "vi": "0.948383909184274"
    },
    "canonical_solution": "{\n    // Base case: When bill value is 0\n    if ($billValue == 1) {\n        return 1;\n    }\n\n    // When bill value becomes negative, no valid combination\n    if ($billValue == 2) {\n        return 2;\n    }\n\n    // Count combinations by subtracting 1 and 2 from the current bill value\n    return countCoinExchangeWays($billValue - 1) + countCoinExchangeWays($billValue - 2);\n}",
    "instruction": {
      "en": "function countCoinExchangeWays($billValue)\n{\n    // Base case: When bill value is 0\n    if ($billValue == 1) {\n        return 1;\n    }\n\n    // When bill value becomes negative, no valid combination\n    if ($billValue == 2) {\n        return 2;\n    }\n\n    // Count combinations by subtracting 1 and 2 from the current bill value\n    return countCoinExchangeWays($billValue - 1) + countCoinExchangeWays($billValue - 2);\n}\n\nProvide a concise natural language description (docstring) of the PHP code in English using at most 500 characters.",
      "es": "function countCoinExchangeWays($billValue)\n{\n    // Base case: When bill value is 0\n    if ($billValue == 1) {\n        return 1;\n    }\n\n    // When bill value becomes negative, no valid combination\n    if ($billValue == 2) {\n        return 2;\n    }\n\n    // Count combinations by subtracting 1 and 2 from the current bill value\n    return countCoinExchangeWays($billValue - 1) + countCoinExchangeWays($billValue - 2);\n}\n\nProporcione una descripción concisa en lenguaje natural (docstring) del código PHP en español utilizando un máximo de 500 caracteres.",
      "arb": "function countCoinExchangeWays($billValue)\n{\n    // Base case: When bill value is 0\n    if ($billValue == 1) {\n        return 1;\n    }\n\n    // When bill value becomes negative, no valid combination\n    if ($billValue == 2) {\n        return 2;\n    }\n\n    // Count combinations by subtracting 1 and 2 from the current bill value\n    return countCoinExchangeWays($billValue - 1) + countCoinExchangeWays($billValue - 2);\n}\n\nيرجى تقديم وصف موجز بلغة طبيعية (docstring) للكود المكتوب بلغة PHP باللغة العربية الفصحى، باستخدام ما لا يزيد عن 500 حرف.",
      "sw": "function countCoinExchangeWays($billValue)\n{\n    // Base case: When bill value is 0\n    if ($billValue == 1) {\n        return 1;\n    }\n\n    // When bill value becomes negative, no valid combination\n    if ($billValue == 2) {\n        return 2;\n    }\n\n    // Count combinations by subtracting 1 and 2 from the current bill value\n    return countCoinExchangeWays($billValue - 1) + countCoinExchangeWays($billValue - 2);\n}\n\nToa maelezo mafupi ya lugha ya asili (docstring) ya msimbo wa PHP kwa Kiswahili kwa kutumia herufi zisizozidi 500.",
      "tr": "function countCoinExchangeWays($billValue)\n{\n    // Base case: When bill value is 0\n    if ($billValue == 1) {\n        return 1;\n    }\n\n    // When bill value becomes negative, no valid combination\n    if ($billValue == 2) {\n        return 2;\n    }\n\n    // Count combinations by subtracting 1 and 2 from the current bill value\n    return countCoinExchangeWays($billValue - 1) + countCoinExchangeWays($billValue - 2);\n}\n\nPHP kodunun işlevini açıklayan kısa bir doğal dil açıklaması (docstring) sağlayın. Açıklama Türkçe olmalı ve en fazla 500 karakter kullanılmalıdır.",
      "vi": "function countCoinExchangeWays($billValue)\n{\n    // Base case: When bill value is 0\n    if ($billValue == 1) {\n        return 1;\n    }\n\n    // When bill value becomes negative, no valid combination\n    if ($billValue == 2) {\n        return 2;\n    }\n\n    // Count combinations by subtracting 1 and 2 from the current bill value\n    return countCoinExchangeWays($billValue - 1) + countCoinExchangeWays($billValue - 2);\n}\n\nCung cấp mô tả ngắn gọn bằng ngôn ngữ tự nhiên (docstring) cho mã PHP bằng tiếng Việt với tối đa 500 ký tự."
    },
    "instruction_bertscore": {
      "es": "0.9687069752502395",
      "arb": "0.8976292783310962",
      "sw": "0.91585798565943",
      "tr": "0.8604091230112547",
      "vi": "0.9150604846795749"
    },
    "level": "",
    "test": "function main(){\n    assert(countCoinExchangeWays(4) === 5);\n    assert(countCoinExchangeWays(3) === 3);\n    assert(countCoinExchangeWays(2) === 2);\n    assert(countCoinExchangeWays(1) === 1);\n}\n\nmain();\n?>",
    "entry_point": "countCoinExchangeWays",
    "signature": "function countCoinExchangeWays($billValue)",
    "docstring": {
      "en": "Calculates the number of different ways to exchange a paper bill into coins.\nGiven a paper bill of value N (1 <= N <= 10), there are two types of coins available: 1 and 2 units.\nThe function determines how many distinct combinations of these coins can sum up to the value of the bill.\nExample: For a bill of value 4, there are 5 ways:\n4 = 1 + 1 + 1 + 1\n4 = 2 + 1 + 1\n4 = 1 + 2 + 1\n4 = 1 + 1 + 2\n4 = 2 + 2\nInput: An integer representing the bill value.\nOutput: Returns the number of different ways to exchange the bill into coins.",
      "es": "Calcula el número de diferentes maneras de cambiar un billete de papel en monedas.  \nDado un billete de valor N (1 <= N <= 10), hay dos tipos de monedas disponibles: 1 y 2 unidades.  \nLa función determina cuántas combinaciones distintas de estas monedas pueden sumar el valor del billete.  \nEjemplo: Para un billete de valor 4, hay 5 maneras:  \n4 = 1 + 1 + 1 + 1  \n4 = 2 + 1 + 1  \n4 = 1 + 2 + 1  \n4 = 1 + 1 + 2  \n4 = 2 + 2  \nEntrada: Un entero que representa el valor del billete.  \nSalida: Devuelve el número de diferentes maneras de cambiar el billete en monedas.  ",
      "arb": "يحسب عدد الطرق المختلفة لتحويل ورقة نقدية إلى عملات معدنية.  \nبالنظر إلى ورقة نقدية بقيمة N (1 <= N <= 10)، هناك نوعان من العملات المتاحة: 1 و 2 وحدة.  \nتحدد الدالة عدد التركيبات المختلفة لهذه العملات التي يمكن أن تصل مجموعها إلى قيمة الورقة النقدية.  \nمثال: بالنسبة لورقة نقدية بقيمة 4، هناك 5 طرق:  \n4 = 1 + 1 + 1 + 1  \n4 = 2 + 1 + 1  \n4 = 1 + 2 + 1  \n4 = 1 + 1 + 2  \n4 = 2 + 2  \nالمدخل: عدد صحيح يمثل قيمة الورقة النقدية.  \nالمخرج: يعيد عدد الطرق المختلفة لتحويل الورقة النقدية إلى عملات معدنية.  ",
      "sw": "Hesabu idadi ya njia tofauti za kubadilisha noti ya karatasi kuwa sarafu. \nKwa kupewa noti ya karatasi yenye thamani ya N (1 <= N <= 10), kuna aina mbili za sarafu zinazopatikana: 1 na 2. \nKazi hii inaamua ni mchanganyiko gani tofauti wa sarafu hizi unaweza kufikia thamani ya noti. \nMfano: Kwa noti yenye thamani ya 4, kuna njia 5: \n4 = 1 + 1 + 1 + 1 \n4 = 2 + 1 + 1 \n4 = 1 + 2 + 1 \n4 = 1 + 1 + 2 \n4 = 2 + 2 \nIngizo: Nambari nzima inayowakilisha thamani ya noti. \nMatokeo: Inarudisha idadi ya njia tofauti za kubadilisha noti kuwa sarafu.",
      "tr": "Kağıt parayı bozuk paralara çevirmenin farklı yollarının sayısını hesaplar.\nDeğeri N (1 <= N <= 10) olan bir kağıt para verildiğinde, iki tür bozuk para mevcuttur: 1 ve 2 birim.\nFonksiyon, bu bozuk paraların kağıt paranın değerine eşit olacak şekilde kaç farklı kombinasyon oluşturabileceğini belirler.\nÖrnek: Değeri 4 olan bir kağıt para için 5 yol vardır:\n4 = 1 + 1 + 1 + 1\n4 = 2 + 1 + 1\n4 = 1 + 2 + 1\n4 = 1 + 1 + 2\n4 = 2 + 2\nGirdi: Kağıt para değerini temsil eden bir tamsayı.\nÇıktı: Kağıt parayı bozuk paralara çevirmenin farklı yollarının sayısını döndürür.",
      "vi": "Tính toán số cách khác nhau để đổi một tờ tiền giấy thành tiền xu.  \nCho một tờ tiền giấy có giá trị N (1 <= N <= 10), có hai loại tiền xu có sẵn: 1 và 2 đơn vị.  \nHàm xác định có bao nhiêu tổ hợp khác nhau của các đồng xu này có thể cộng lại thành giá trị của tờ tiền giấy.  \nVí dụ: Đối với một tờ tiền có giá trị 4, có 5 cách:  \n4 = 1 + 1 + 1 + 1  \n4 = 2 + 1 + 1  \n4 = 1 + 2 + 1  \n4 = 1 + 1 + 2  \n4 = 2 + 2  \n\nTham số:  \n    Đầu vào: Một số nguyên đại diện cho giá trị của tờ tiền giấy.  \n    Đầu ra: Trả về số cách khác nhau để đổi tờ tiền giấy thành tiền xu.  "
    },
    "docstring_bertscore": {
      "es": "0.9845612550036823",
      "arb": "0.9221784043839601",
      "sw": "0.9174911246522989",
      "tr": "0.9174710629838143",
      "vi": "0.9135556609128546"
    }
  },
  {
    "task_id": "PHP/8",
    "prompt": {
      "en": "<?php\n\n/**\n * Compares two playing cards to determine which one is higher based on a given trump suit.\n * In this game, each card is represented by its suit and rank (e.g., '8D', 'QS').\n * The trump suit is one of the four suits: Spades (S), Hearts (H), Diamonds (D), or Clubs (C).\n * The rules for comparison are as follows:\n * - If neither card is of the trump suit, the card with the higher rank wins.\n * - If both cards are of the trump suit, the card with the higher rank wins.\n * - If one card is of the trump suit and the other is not, the trump suit card wins regardless of rank.\n * - If both cards have the same rank, the result is a draw.\n * Input: The trump suit and two card strings.\n * Output: Returns 1 if the first card wins, -1 if the second card wins, and 0 for a draw.\n */\n\nfunction compareCards($trumpSuit, $card1, $card2) ",
      "es": "<?php\n\n/**\n * Compara dos cartas para determinar cuál es más alta basándose en un palo de triunfo dado.\n * En este juego, cada carta está representada por su palo y rango (por ejemplo, '8D', 'QS').\n * El palo de triunfo es uno de los cuatro palos: Espadas (S), Corazones (H), Diamantes (D) o Tréboles (C).\n * Las reglas para la comparación son las siguientes:\n * - Si ninguna de las cartas es del palo de triunfo, la carta con el rango más alto gana.\n * - Si ambas cartas son del palo de triunfo, la carta con el rango más alto gana.\n * - Si una carta es del palo de triunfo y la otra no, la carta del palo de triunfo gana independientemente del rango.\n * - Si ambas cartas tienen el mismo rango, el resultado es un empate.\n * Entrada: El palo de triunfo y dos cadenas de cartas.\n * Salida: Devuelve 1 si la primera carta gana, -1 si la segunda carta gana, y 0 para un empate.\n */\n\nfunction compareCards($trumpSuit, $card1, $card2) ",
      "arb": "<?php\n\n/**\n * يقارن بين ورقتين لعب لتحديد أيهما أعلى بناءً على نوع الورقة الرابحة المعطى.\n * في هذه اللعبة، يتم تمثيل كل ورقة بنوعها ورتبتها (مثال: '8D', 'QS').\n * نوع الورقة الرابحة هو واحد من الأنواع الأربعة: البستوني (S)، القلوب (H)، الألماس (D)، أو النوادي (C).\n * القواعد للمقارنة هي كما يلي:\n * - إذا لم تكن أي من الورقتين من نوع الورقة الرابحة، تفوز الورقة ذات الرتبة الأعلى.\n * - إذا كانت كلتا الورقتين من نوع الورقة الرابحة، تفوز الورقة ذات الرتبة الأعلى.\n * - إذا كانت إحدى الورقتين من نوع الورقة الرابحة والأخرى ليست كذلك، تفوز الورقة من نوع الورقة الرابحة بغض النظر عن الرتبة.\n * - إذا كانت كلتا الورقتين لهما نفس الرتبة، تكون النتيجة تعادل.\n * المدخلات: نوع الورقة الرابحة وسلسلتين تمثلان الورقتين.\n * المخرجات: يعيد 1 إذا فازت الورقة الأولى، -1 إذا فازت الورقة الثانية، و 0 للتعادل.\n */\n\nfunction compareCards($trumpSuit, $card1, $card2) ",
      "sw": "<?php\n\n/**\n * Inalinganisha kadi mbili za kucheza ili kubaini ipi ni ya juu zaidi kulingana na rangi ya trump iliyotolewa.\n * Katika mchezo huu, kila kadi inawakilishwa na rangi na cheo chake (mfano, '8D', 'QS').\n * Rangi ya trump ni mojawapo ya rangi nne: Spades (S), Hearts (H), Diamonds (D), au Clubs (C).\n * Sheria za kulinganisha ni kama ifuatavyo:\n * - Ikiwa hakuna kadi yoyote iliyo na rangi ya trump, kadi yenye cheo cha juu inashinda.\n * - Ikiwa kadi zote mbili zina rangi ya trump, kadi yenye cheo cha juu inashinda.\n * - Ikiwa kadi moja ina rangi ya trump na nyingine haina, kadi yenye rangi ya trump inashinda bila kujali cheo.\n * - Ikiwa kadi zote mbili zina cheo sawa, matokeo ni sare.\n * Ingizo: Rangi ya trump na kamba mbili za kadi.\n * Matokeo: Inarudisha 1 ikiwa kadi ya kwanza inashinda, -1 ikiwa kadi ya pili inashinda, na 0 kwa sare.\n */\n\nfunction compareCards($trumpSuit, $card1, $card2) ",
      "tr": "<?php\n\n/**\n * İki iskambil kartını, verilen koz rengine göre hangisinin daha yüksek olduğunu belirlemek için karşılaştırır.\n * Bu oyunda, her kart rengi ve rütbesi ile temsil edilir (örneğin, '8D', 'QS').\n * Koz rengi dört renkten biridir: Maça (S), Kupa (H), Karo (D) veya Sinek (C).\n * Karşılaştırma kuralları aşağıdaki gibidir:\n * - Eğer hiçbir kart koz renginde değilse, daha yüksek rütbeye sahip kart kazanır.\n * - Eğer her iki kart da koz rengindeyse, daha yüksek rütbeye sahip kart kazanır.\n * - Eğer bir kart koz rengindeyse ve diğeri değilse, koz rengindeki kart rütbesi ne olursa olsun kazanır.\n * - Eğer her iki kartın rütbesi aynıysa, sonuç beraberedir.\n * Girdi: Koz rengi ve iki kart dizgesi.\n * Çıktı: İlk kart kazanırsa 1, ikinci kart kazanırsa -1 ve beraberlik için 0 döner.\n */\n\nfunction compareCards($trumpSuit, $card1, $card2) ",
      "vi": "<?php\n\n/**\n * So sánh hai lá bài để xác định lá nào cao hơn dựa trên chất chủ bài đã cho.\n * Trong trò chơi này, mỗi lá bài được biểu diễn bằng chất và hạng của nó (ví dụ: '8D', 'QS').\n * Chất chủ bài là một trong bốn chất: Bích (S), Cơ (H), Rô (D), hoặc Nhép (C).\n * Các quy tắc so sánh như sau:\n * - Nếu không có lá bài nào thuộc chất chủ bài, lá bài có hạng cao hơn sẽ thắng.\n * - Nếu cả hai lá bài đều thuộc chất chủ bài, lá bài có hạng cao hơn sẽ thắng.\n * - Nếu một lá bài thuộc chất chủ bài và lá kia không, lá bài thuộc chất chủ bài sẽ thắng bất kể hạng.\n * - Nếu cả hai lá bài có cùng hạng, kết quả là hòa.\n * Đầu vào: Chất chủ bài và hai chuỗi lá bài.\n * Đầu ra: Trả về 1 nếu lá bài thứ nhất thắng, -1 nếu lá bài thứ hai thắng, và 0 cho hòa.\n */\n\nfunction compareCards($trumpSuit, $card1, $card2) "
    },
    "prompt_bertscore": {
      "es": "0.9846536181308635",
      "arb": "0.9774633969677816",
      "sw": "0.9765061971615745",
      "tr": "0.9833233904690729",
      "vi": "0.9702761552604152"
    },
    "canonical_solution": "{\n    // Function to convert card rank to numerical value\n    $getNumericRank = function($card) {\n        $rank = substr($card, 0, -1);\n        switch ($rank) {\n            case 'A': return 14;\n            case 'K': return 13;\n            case 'Q': return 12;\n            case 'J': return 11;\n            default: return intval($rank);\n        }\n    };\n\n    $rank1 = $getNumericRank($card1);\n    $rank2 = $getNumericRank($card2);\n    $suit1 = substr($card1, -1);\n    $suit2 = substr($card2, -1);\n\n    $isTrump1 = $suit1 === $trumpSuit;\n    $isTrump2 = $suit2 === $trumpSuit;\n\n    if ($isTrump1 && !$isTrump2) {\n        return 1;\n    } elseif (!$isTrump1 && $isTrump2) {\n        return -1;\n    } elseif ($rank1 === $rank2) {\n        return 0;\n    } elseif ($rank1 > $rank2) {\n        return 1;\n    } else {\n        return -1;\n    }\n}",
    "instruction": {
      "en": "function compareCards($trumpSuit, $card1, $card2)\n{\n    // Function to convert card rank to numerical value\n    $getNumericRank = function($card) {\n        $rank = substr($card, 0, -1);\n        switch ($rank) {\n            case 'A': return 14;\n            case 'K': return 13;\n            case 'Q': return 12;\n            case 'J': return 11;\n            default: return intval($rank);\n        }\n    };\n\n    $rank1 = $getNumericRank($card1);\n    $rank2 = $getNumericRank($card2);\n    $suit1 = substr($card1, -1);\n    $suit2 = substr($card2, -1);\n\n    $isTrump1 = $suit1 === $trumpSuit;\n    $isTrump2 = $suit2 === $trumpSuit;\n\n    if ($isTrump1 && !$isTrump2) {\n        return 1;\n    } elseif (!$isTrump1 && $isTrump2) {\n        return -1;\n    } elseif ($rank1 === $rank2) {\n        return 0;\n    } elseif ($rank1 > $rank2) {\n        return 1;\n    } else {\n        return -1;\n    }\n}\n\nProvide a concise natural language description (docstring) of the PHP code in English using at most 500 characters.",
      "es": "function compareCards($trumpSuit, $card1, $card2)\n{\n    // Function to convert card rank to numerical value\n    $getNumericRank = function($card) {\n        $rank = substr($card, 0, -1);\n        switch ($rank) {\n            case 'A': return 14;\n            case 'K': return 13;\n            case 'Q': return 12;\n            case 'J': return 11;\n            default: return intval($rank);\n        }\n    };\n\n    $rank1 = $getNumericRank($card1);\n    $rank2 = $getNumericRank($card2);\n    $suit1 = substr($card1, -1);\n    $suit2 = substr($card2, -1);\n\n    $isTrump1 = $suit1 === $trumpSuit;\n    $isTrump2 = $suit2 === $trumpSuit;\n\n    if ($isTrump1 && !$isTrump2) {\n        return 1;\n    } elseif (!$isTrump1 && $isTrump2) {\n        return -1;\n    } elseif ($rank1 === $rank2) {\n        return 0;\n    } elseif ($rank1 > $rank2) {\n        return 1;\n    } else {\n        return -1;\n    }\n}\n\nProporcione una descripción concisa en lenguaje natural (docstring) del código PHP en español utilizando un máximo de 500 caracteres.",
      "arb": "function compareCards($trumpSuit, $card1, $card2)\n{\n    // Function to convert card rank to numerical value\n    $getNumericRank = function($card) {\n        $rank = substr($card, 0, -1);\n        switch ($rank) {\n            case 'A': return 14;\n            case 'K': return 13;\n            case 'Q': return 12;\n            case 'J': return 11;\n            default: return intval($rank);\n        }\n    };\n\n    $rank1 = $getNumericRank($card1);\n    $rank2 = $getNumericRank($card2);\n    $suit1 = substr($card1, -1);\n    $suit2 = substr($card2, -1);\n\n    $isTrump1 = $suit1 === $trumpSuit;\n    $isTrump2 = $suit2 === $trumpSuit;\n\n    if ($isTrump1 && !$isTrump2) {\n        return 1;\n    } elseif (!$isTrump1 && $isTrump2) {\n        return -1;\n    } elseif ($rank1 === $rank2) {\n        return 0;\n    } elseif ($rank1 > $rank2) {\n        return 1;\n    } else {\n        return -1;\n    }\n}\n\nيرجى تقديم وصف موجز بلغة طبيعية (docstring) لشيفرة PHP باللغة العربية الفصحى باستخدام 500 حرف كحد أقصى.",
      "sw": "function compareCards($trumpSuit, $card1, $card2)\n{\n    // Function to convert card rank to numerical value\n    $getNumericRank = function($card) {\n        $rank = substr($card, 0, -1);\n        switch ($rank) {\n            case 'A': return 14;\n            case 'K': return 13;\n            case 'Q': return 12;\n            case 'J': return 11;\n            default: return intval($rank);\n        }\n    };\n\n    $rank1 = $getNumericRank($card1);\n    $rank2 = $getNumericRank($card2);\n    $suit1 = substr($card1, -1);\n    $suit2 = substr($card2, -1);\n\n    $isTrump1 = $suit1 === $trumpSuit;\n    $isTrump2 = $suit2 === $trumpSuit;\n\n    if ($isTrump1 && !$isTrump2) {\n        return 1;\n    } elseif (!$isTrump1 && $isTrump2) {\n        return -1;\n    } elseif ($rank1 === $rank2) {\n        return 0;\n    } elseif ($rank1 > $rank2) {\n        return 1;\n    } else {\n        return -1;\n    }\n}\n\nToa maelezo mafupi ya lugha asilia (docstring) ya msimbo wa PHP kwa Kiswahili kwa kutumia herufi zisizozidi 500.",
      "tr": "function compareCards($trumpSuit, $card1, $card2)\n{\n    // Function to convert card rank to numerical value\n    $getNumericRank = function($card) {\n        $rank = substr($card, 0, -1);\n        switch ($rank) {\n            case 'A': return 14;\n            case 'K': return 13;\n            case 'Q': return 12;\n            case 'J': return 11;\n            default: return intval($rank);\n        }\n    };\n\n    $rank1 = $getNumericRank($card1);\n    $rank2 = $getNumericRank($card2);\n    $suit1 = substr($card1, -1);\n    $suit2 = substr($card2, -1);\n\n    $isTrump1 = $suit1 === $trumpSuit;\n    $isTrump2 = $suit2 === $trumpSuit;\n\n    if ($isTrump1 && !$isTrump2) {\n        return 1;\n    } elseif (!$isTrump1 && $isTrump2) {\n        return -1;\n    } elseif ($rank1 === $rank2) {\n        return 0;\n    } elseif ($rank1 > $rank2) {\n        return 1;\n    } else {\n        return -1;\n    }\n}\n\nAşağıdaki PHP kodunun işlevini açıklayan, en fazla 500 karakter uzunluğunda, doğal dilde bir açıklama (docstring) sağlayın.",
      "vi": "function compareCards($trumpSuit, $card1, $card2)\n{\n    // Function to convert card rank to numerical value\n    $getNumericRank = function($card) {\n        $rank = substr($card, 0, -1);\n        switch ($rank) {\n            case 'A': return 14;\n            case 'K': return 13;\n            case 'Q': return 12;\n            case 'J': return 11;\n            default: return intval($rank);\n        }\n    };\n\n    $rank1 = $getNumericRank($card1);\n    $rank2 = $getNumericRank($card2);\n    $suit1 = substr($card1, -1);\n    $suit2 = substr($card2, -1);\n\n    $isTrump1 = $suit1 === $trumpSuit;\n    $isTrump2 = $suit2 === $trumpSuit;\n\n    if ($isTrump1 && !$isTrump2) {\n        return 1;\n    } elseif (!$isTrump1 && $isTrump2) {\n        return -1;\n    } elseif ($rank1 === $rank2) {\n        return 0;\n    } elseif ($rank1 > $rank2) {\n        return 1;\n    } else {\n        return -1;\n    }\n}\n\nCung cấp mô tả ngắn gọn bằng ngôn ngữ tự nhiên (docstring) cho mã PHP bằng tiếng Việt với tối đa 500 ký tự."
    },
    "instruction_bertscore": {
      "es": "0.9687069752502395",
      "arb": "0.9148910529645522",
      "sw": "0.9428367585331127",
      "tr": "0.8371898273594194",
      "vi": "0.9367207304706674"
    },
    "level": "",
    "test": "function main(){\n    assert(compareCards('S', '8D', '3S') === -1); \n    assert(compareCards('S', '8D', '9S') === -1); // Non-trump vs trump\n    assert(compareCards('H', '8H', '7H') === 1);  // Both trump, first higher\n    assert(compareCards('D', '9C', '9S') === 0);  // Same rank, non-trump\n    assert(compareCards('C', 'QH', 'JS') === 1);  // Neither trump, first higher\n    assert(compareCards('D', 'KD', 'AD') === -1); // Both trump, second higher\n\n}\nmain();\n?>",
    "entry_point": "compareCards",
    "signature": "function compareCards($trumpSuit, $card1, $card2)",
    "docstring": {
      "en": "Compares two playing cards to determine which one is higher based on a given trump suit.\nIn this game, each card is represented by its suit and rank (e.g., '8D', 'QS').\nThe trump suit is one of the four suits: Spades (S), Hearts (H), Diamonds (D), or Clubs (C).\nThe rules for comparison are as follows:\n- If neither card is of the trump suit, the card with the higher rank wins.\n- If both cards are of the trump suit, the card with the higher rank wins.\n- If one card is of the trump suit and the other is not, the trump suit card wins regardless of rank.\n- If both cards have the same rank, the result is a draw.\nInput: The trump suit and two card strings.\nOutput: Returns 1 if the first card wins, -1 if the second card wins, and 0 for a draw.",
      "es": "Compara dos cartas de juego para determinar cuál es más alta basándose en un palo de triunfo dado. En este juego, cada carta está representada por su palo y rango (por ejemplo, '8D', 'QS'). El palo de triunfo es uno de los cuatro palos: Espadas (S), Corazones (H), Diamantes (D) o Tréboles (C). Las reglas para la comparación son las siguientes: - Si ninguna de las cartas es del palo de triunfo, la carta con el rango más alto gana. - Si ambas cartas son del palo de triunfo, la carta con el rango más alto gana. - Si una carta es del palo de triunfo y la otra no, la carta del palo de triunfo gana independientemente del rango. - Si ambas cartas tienen el mismo rango, el resultado es un empate. Entrada: El palo de triunfo y dos cadenas de cartas. Salida: Devuelve 1 si la primera carta gana, -1 si la segunda carta gana, y 0 para un empate.",
      "arb": "يقارن بين ورقتين لعب لتحديد أيهما أعلى بناءً على نوع الورقة الرابحة المعطى.  \nفي هذه اللعبة، يتم تمثيل كل ورقة بنوعها ورتبتها (على سبيل المثال، '8D'، 'QS').  \nنوع الورقة الرابحة هو واحد من الأنواع الأربعة: البستوني (S)، القلوب (H)، الألماس (D)، أو النوادي (C).  \nالقواعد للمقارنة هي كما يلي:  \n- إذا لم تكن أي من الورقتين من نوع الورقة الرابحة، تفوز الورقة ذات الرتبة الأعلى.  \n- إذا كانت كلتا الورقتين من نوع الورقة الرابحة، تفوز الورقة ذات الرتبة الأعلى.  \n- إذا كانت إحدى الورقتين من نوع الورقة الرابحة والأخرى ليست كذلك، تفوز الورقة من نوع الورقة الرابحة بغض النظر عن الرتبة.  \n- إذا كانت كلتا الورقتين لهما نفس الرتبة، تكون النتيجة تعادل.  \nالمدخلات: نوع الورقة الرابحة وسلسلتين نصيتين تمثلان الورقتين.  \nالمخرجات: يعيد 1 إذا فازت الورقة الأولى، -1 إذا فازت الورقة الثانية، و0 في حالة التعادل.",
      "sw": "Inalinganisha kadi mbili za kucheza ili kubaini ipi ni ya juu zaidi kulingana na rangi ya trump iliyotolewa. Katika mchezo huu, kila kadi inawakilishwa na rangi na cheo chake (mfano, '8D', 'QS'). Rangi ya trump ni mojawapo ya rangi nne: Spades (S), Hearts (H), Diamonds (D), au Clubs (C). Sheria za kulinganisha ni kama ifuatavyo: - Ikiwa hakuna kadi yoyote ni ya rangi ya trump, kadi yenye cheo cha juu inashinda. - Ikiwa kadi zote mbili ni za rangi ya trump, kadi yenye cheo cha juu inashinda. - Ikiwa kadi moja ni ya rangi ya trump na nyingine sio, kadi ya rangi ya trump inashinda bila kujali cheo. - Ikiwa kadi zote mbili zina cheo sawa, matokeo ni sare. Ingizo: Rangi ya trump na kamba mbili za kadi. Tokeo: Inarejesha 1 ikiwa kadi ya kwanza inashinda, -1 ikiwa kadi ya pili inashinda, na 0 kwa sare.",
      "tr": "Verilen koz rengine göre hangi kartın daha yüksek olduğunu belirlemek için iki oyun kartını karşılaştırır. \nBu oyunda, her kart maça ve rütbesi ile temsil edilir (örneğin, '8D', 'QS'). \nKoz rengi dört renkten biridir: Maça (S), Kupa (H), Karo (D) veya Sinek (C). \nKarşılaştırma kuralları aşağıdaki gibidir:\n- Eğer hiçbir kart koz renginde değilse, daha yüksek rütbeye sahip kart kazanır.\n- Eğer her iki kart da koz rengindeyse, daha yüksek rütbeye sahip kart kazanır.\n- Eğer bir kart koz rengindeyse ve diğeri değilse, koz rengindeki kart rütbesi ne olursa olsun kazanır.\n- Eğer her iki kart da aynı rütbeye sahipse, sonuç beraberedir.\nGirdi: Koz rengi ve iki kart dizgesi.\nÇıktı: İlk kart kazanırsa 1, ikinci kart kazanırsa -1 ve beraberlik için 0 döner.",
      "vi": "So sánh hai lá bài để xác định lá nào cao hơn dựa trên chất chủ bài đã cho. Trong trò chơi này, mỗi lá bài được biểu diễn bởi chất và hạng của nó (ví dụ: '8D', 'QS'). Chất chủ bài là một trong bốn chất: Bích (S), Cơ (H), Rô (D), hoặc Tép (C). Các quy tắc so sánh như sau:\n- Nếu không có lá bài nào thuộc chất chủ bài, lá bài có hạng cao hơn sẽ thắng.\n- Nếu cả hai lá bài đều thuộc chất chủ bài, lá bài có hạng cao hơn sẽ thắng.\n- Nếu một lá bài thuộc chất chủ bài và lá kia không thuộc, lá bài thuộc chất chủ bài sẽ thắng bất kể hạng.\n- Nếu cả hai lá bài có cùng hạng, kết quả là hòa.\nĐầu vào: Chất chủ bài và hai chuỗi lá bài. Đầu ra: Trả về 1 nếu lá bài đầu tiên thắng, -1 nếu lá bài thứ hai thắng, và 0 cho hòa."
    },
    "docstring_bertscore": {
      "es": "0.9814906279432639",
      "arb": "0.9757164427665798",
      "sw": "0.9889068904799636",
      "tr": "0.9620331930778484",
      "vi": "0.9629520572205158"
    }
  },
  {
    "task_id": "PHP/9",
    "prompt": {
      "en": "<?php\n\n/**\n    * This function calculates the minimum number of 6x6xh packages required to ship an order of products of various sizes.\n    * The sizes of the products range from 1x1 to 6x6, and each product requires a certain amount of space in the package.\n    * The goal is to efficiently pack these products to minimize the number of packages, reducing shipping costs.\n    *\n    * Input: Six integers ($a, $b, $c, $d, $e, $f), each representing the quantity of products from size 1x1 to 6x6.\n    * Output: An integer representing the minimum number of 6x6xh packages required to ship the order.\n    *\n    * Example:\n    * For an order with 1 product of size 1x1, 2 products of size 2x2, and 1 product of size 3x3,\n    * the function will calculate and return the minimum number of packages needed.\n    */\n\nfunction calculateMinimumPackages($a, $b, $c, $d, $e, $f): int ",
      "es": "<?php\n\n/**\n    * Esta función calcula el número mínimo de paquetes de 6x6xh necesarios para enviar un pedido de productos de varios tamaños.\n    * Los tamaños de los productos varían de 1x1 a 6x6, y cada producto requiere una cierta cantidad de espacio en el paquete.\n    * El objetivo es empacar estos productos de manera eficiente para minimizar el número de paquetes, reduciendo los costos de envío.\n    *\n    * Entrada: Seis enteros ($a, $b, $c, $d, $e, $f), cada uno representando la cantidad de productos de tamaño 1x1 a 6x6.\n    * Salida: Un entero que representa el número mínimo de paquetes de 6x6xh necesarios para enviar el pedido.\n    *\n    * Ejemplo:\n    * Para un pedido con 1 producto de tamaño 1x1, 2 productos de tamaño 2x2, y 1 producto de tamaño 3x3,\n    * la función calculará y devolverá el número mínimo de paquetes necesarios.\n    */\n\nfunction calculateMinimumPackages($a, $b, $c, $d, $e, $f): int ",
      "arb": "<?php\n\n/**\n    * تقوم هذه الدالة بحساب الحد الأدنى لعدد الطرود ذات الحجم 6x6xh المطلوبة لشحن طلب من المنتجات ذات الأحجام المختلفة.\n    * تتراوح أحجام المنتجات من 1x1 إلى 6x6، وكل منتج يتطلب مساحة معينة في الطرد.\n    * الهدف هو تعبئة هذه المنتجات بكفاءة لتقليل عدد الطرود، مما يقلل من تكاليف الشحن.\n    *\n    * المدخلات: ستة أعداد صحيحة ($a, $b, $c, $d, $e, $f)، كل منها يمثل كمية المنتجات من الحجم 1x1 إلى 6x6.\n    * المخرجات: عدد صحيح يمثل الحد الأدنى لعدد الطرود ذات الحجم 6x6xh المطلوبة لشحن الطلب.\n    *\n    * مثال:\n    * لطلب يحتوي على منتج واحد بحجم 1x1، و2 منتجات بحجم 2x2، ومنتج واحد بحجم 3x3،\n    * ستقوم الدالة بحساب وإرجاع الحد الأدنى لعدد الطرود المطلوبة.\n    */\n\nfunction calculateMinimumPackages($a, $b, $c, $d, $e, $f): int ",
      "sw": "<?php\n\n/**\n    * Kazi ya hii function ni kuhesabu idadi ndogo ya vifurushi vya 6x6xh vinavyohitajika kusafirisha oda ya bidhaa za ukubwa mbalimbali.\n    * Ukubwa wa bidhaa unatoka 1x1 hadi 6x6, na kila bidhaa inahitaji nafasi fulani ndani ya kifurushi.\n    * Lengo ni kupakia bidhaa hizi kwa ufanisi ili kupunguza idadi ya vifurushi, hivyo kupunguza gharama za usafirishaji.\n    *\n    * Ingizo: Nambari sita ($a, $b, $c, $d, $e, $f), kila moja ikiwakilisha idadi ya bidhaa kutoka ukubwa wa 1x1 hadi 6x6.\n    * Matokeo: Nambari inayoonyesha idadi ndogo ya vifurushi vya 6x6xh vinavyohitajika kusafirisha oda.\n    *\n    * Mfano:\n    * Kwa oda yenye bidhaa 1 ya ukubwa 1x1, bidhaa 2 za ukubwa 2x2, na bidhaa 1 ya ukubwa 3x3,\n    * function itahesabu na kurudisha idadi ndogo ya vifurushi vinavyohitajika.\n    */\n\nfunction calculateMinimumPackages($a, $b, $c, $d, $e, $f): int ",
      "tr": "<?php\n\n/**\n    * Bu fonksiyon, çeşitli boyutlardaki ürünlerden oluşan bir siparişi göndermek için gereken minimum 6x6xh paket sayısını hesaplar.\n    * Ürünlerin boyutları 1x1'den 6x6'ya kadar değişir ve her ürün pakette belirli bir miktar alan gerektirir.\n    * Amaç, bu ürünleri etkin bir şekilde paketleyerek paket sayısını en aza indirmek ve nakliye maliyetlerini azaltmaktır.\n    *\n    * Girdi: 1x1'den 6x6'ya kadar olan ürünlerin miktarını temsil eden altı tamsayı ($a, $b, $c, $d, $e, $f).\n    * Çıktı: Siparişi göndermek için gereken minimum 6x6xh paket sayısını temsil eden bir tamsayı.\n    *\n    * Örnek:\n    * 1 adet 1x1 boyutunda ürün, 2 adet 2x2 boyutunda ürün ve 1 adet 3x3 boyutunda ürün içeren bir sipariş için,\n    * fonksiyon gereken minimum paket sayısını hesaplayacak ve döndürecektir.\n    */\n\nfunction calculateMinimumPackages($a, $b, $c, $d, $e, $f): int ",
      "vi": "<?php\n\n/**\n    * Hàm này tính toán số lượng tối thiểu các gói 6x6xh cần thiết để vận chuyển một đơn hàng gồm các sản phẩm có kích thước khác nhau.\n    * Kích thước của các sản phẩm dao động từ 1x1 đến 6x6, và mỗi sản phẩm yêu cầu một lượng không gian nhất định trong gói.\n    * Mục tiêu là đóng gói các sản phẩm này một cách hiệu quả để giảm thiểu số lượng gói, từ đó giảm chi phí vận chuyển.\n    *\n    * Đầu vào: Sáu số nguyên ($a, $b, $c, $d, $e, $f), mỗi số đại diện cho số lượng sản phẩm từ kích thước 1x1 đến 6x6.\n    * Đầu ra: Một số nguyên đại diện cho số lượng tối thiểu các gói 6x6xh cần thiết để vận chuyển đơn hàng.\n    *\n    * Ví dụ:\n    * Đối với một đơn hàng có 1 sản phẩm kích thước 1x1, 2 sản phẩm kích thước 2x2, và 1 sản phẩm kích thước 3x3,\n    * hàm sẽ tính toán và trả về số lượng gói tối thiểu cần thiết.\n    */\n\nfunction calculateMinimumPackages($a, $b, $c, $d, $e, $f): int "
    },
    "prompt_bertscore": {
      "es": "0.998223648502405",
      "arb": "0.9715998281196316",
      "sw": "0.9679142413995293",
      "tr": "0.9752373462875236",
      "vi": "0.9892572744721091"
    },
    "canonical_solution": "{\n        $need2 = [0, 5, 3, 1];\n        $box = $f + $e + $d + intdiv($c + 3, 4);\n    \n        $need2num = $d * 5 + $need2[$c % 4];\n        if ($need2num < $b) {\n            $box += intdiv($b - $need2num + 8, 9);\n        }\n    \n        $need1num = $box * 36 - ($f * 36 + $e * 25 + $d * 16 + $c * 9 + $b * 4);\n        if ($need1num < $a) {\n            $box += intdiv($a - $need1num + 35, 36);\n        }\n        return $box;\n}",
    "instruction": {
      "en": "function calculateMinimumPackages($a, $b, $c, $d, $e, $f): int\n{\n        $need2 = [0, 5, 3, 1];\n        $box = $f + $e + $d + intdiv($c + 3, 4);\n    \n        $need2num = $d * 5 + $need2[$c % 4];\n        if ($need2num < $b) {\n            $box += intdiv($b - $need2num + 8, 9);\n        }\n    \n        $need1num = $box * 36 - ($f * 36 + $e * 25 + $d * 16 + $c * 9 + $b * 4);\n        if ($need1num < $a) {\n            $box += intdiv($a - $need1num + 35, 36);\n        }\n        return $box;\n}\n\nProvide a concise natural language description (docstring) of the PHP code in English using at most 500 characters.",
      "es": "function calculateMinimumPackages($a, $b, $c, $d, $e, $f): int\n{\n        $need2 = [0, 5, 3, 1];\n        $box = $f + $e + $d + intdiv($c + 3, 4);\n    \n        $need2num = $d * 5 + $need2[$c % 4];\n        if ($need2num < $b) {\n            $box += intdiv($b - $need2num + 8, 9);\n        }\n    \n        $need1num = $box * 36 - ($f * 36 + $e * 25 + $d * 16 + $c * 9 + $b * 4);\n        if ($need1num < $a) {\n            $box += intdiv($a - $need1num + 35, 36);\n        }\n        return $box;\n}\n\nProporcione una descripción concisa en lenguaje natural (docstring) del código PHP en español utilizando un máximo de 500 caracteres.",
      "arb": "function calculateMinimumPackages($a, $b, $c, $d, $e, $f): int\n{\n        $need2 = [0, 5, 3, 1];\n        $box = $f + $e + $d + intdiv($c + 3, 4);\n    \n        $need2num = $d * 5 + $need2[$c % 4];\n        if ($need2num < $b) {\n            $box += intdiv($b - $need2num + 8, 9);\n        }\n    \n        $need1num = $box * 36 - ($f * 36 + $e * 25 + $d * 16 + $c * 9 + $b * 4);\n        if ($need1num < $a) {\n            $box += intdiv($a - $need1num + 35, 36);\n        }\n        return $box;\n}\n\nيرجى تقديم وصف موجز بلغة طبيعية (docstring) للشفرة البرمجية بلغة PHP باللغة العربية الفصحى باستخدام ما لا يزيد عن 500 حرف.",
      "sw": "function calculateMinimumPackages($a, $b, $c, $d, $e, $f): int\n{\n        $need2 = [0, 5, 3, 1];\n        $box = $f + $e + $d + intdiv($c + 3, 4);\n    \n        $need2num = $d * 5 + $need2[$c % 4];\n        if ($need2num < $b) {\n            $box += intdiv($b - $need2num + 8, 9);\n        }\n    \n        $need1num = $box * 36 - ($f * 36 + $e * 25 + $d * 16 + $c * 9 + $b * 4);\n        if ($need1num < $a) {\n            $box += intdiv($a - $need1num + 35, 36);\n        }\n        return $box;\n}\n\nToa maelezo mafupi ya lugha ya asili (docstring) ya msimbo wa PHP kwa Kiswahili kwa kutumia herufi zisizozidi 500.",
      "tr": "function calculateMinimumPackages($a, $b, $c, $d, $e, $f): int\n{\n        $need2 = [0, 5, 3, 1];\n        $box = $f + $e + $d + intdiv($c + 3, 4);\n    \n        $need2num = $d * 5 + $need2[$c % 4];\n        if ($need2num < $b) {\n            $box += intdiv($b - $need2num + 8, 9);\n        }\n    \n        $need1num = $box * 36 - ($f * 36 + $e * 25 + $d * 16 + $c * 9 + $b * 4);\n        if ($need1num < $a) {\n            $box += intdiv($a - $need1num + 35, 36);\n        }\n        return $box;\n}\n\nPHP kodunun işlevselliğini açıklayan kısa bir doğal dil açıklaması (docstring) sağlayın. Açıklama, en fazla 500 karakter kullanılarak Türkçe dilinde yazılmalıdır.",
      "vi": "function calculateMinimumPackages($a, $b, $c, $d, $e, $f): int\n{\n        $need2 = [0, 5, 3, 1];\n        $box = $f + $e + $d + intdiv($c + 3, 4);\n    \n        $need2num = $d * 5 + $need2[$c % 4];\n        if ($need2num < $b) {\n            $box += intdiv($b - $need2num + 8, 9);\n        }\n    \n        $need1num = $box * 36 - ($f * 36 + $e * 25 + $d * 16 + $c * 9 + $b * 4);\n        if ($need1num < $a) {\n            $box += intdiv($a - $need1num + 35, 36);\n        }\n        return $box;\n}\n\nCung cấp mô tả ngắn gọn bằng ngôn ngữ tự nhiên (docstring) cho mã PHP bằng tiếng Việt với tối đa 500 ký tự."
    },
    "instruction_bertscore": {
      "es": "0.9687069752502395",
      "arb": "0.9025058528158838",
      "sw": "0.91585798565943",
      "tr": "0.8854375441735558",
      "vi": "0.9017250367880356"
    },
    "level": "",
    "test": "function main(){\n    assert(calculateMinimumPackages(0, 0, 4, 0, 0, 1) === 2);\n    assert(calculateMinimumPackages(7, 5, 1, 0, 0, 0) === 1);\n    assert(calculateMinimumPackages(0, 0, 0, 0, 0, 0) === 0);\n    assert(calculateMinimumPackages(0, 0, 4, 1, 1, 1) === 4);\n    assert(calculateMinimumPackages(1, 2, 1, 1, 1, 1) === 4);\n    \n}\n\n\nmain();\n?>",
    "entry_point": "calculateMinimumPackages",
    "signature": "function calculateMinimumPackages($a, $b, $c, $d, $e, $f): int",
    "docstring": {
      "en": "This function calculates the minimum number of 6x6xh packages required to ship an order of products of various sizes.\nThe sizes of the products range from 1x1 to 6x6, and each product requires a certain amount of space in the package.\nThe goal is to efficiently pack these products to minimize the number of packages, reducing shipping costs.\n\nInput: Six integers ($a, $b, $c, $d, $e, $f), each representing the quantity of products from size 1x1 to 6x6.\nOutput: An integer representing the minimum number of 6x6xh packages required to ship the order.\n\nExample:\nFor an order with 1 product of size 1x1, 2 products of size 2x2, and 1 product of size 3x3,\nthe function will calculate and return the minimum number of packages needed.",
      "es": "Esta función calcula el número mínimo de paquetes de 6x6xh necesarios para enviar un pedido de productos de varios tamaños.  \nLos tamaños de los productos varían de 1x1 a 6x6, y cada producto requiere una cierta cantidad de espacio en el paquete.  \nEl objetivo es empaquetar estos productos de manera eficiente para minimizar el número de paquetes, reduciendo los costos de envío.\n\nEntrada: Seis enteros ($a, $b, $c, $d, $e, $f), cada uno representando la cantidad de productos de tamaño 1x1 a 6x6.  \nSalida: Un entero que representa el número mínimo de paquetes de 6x6xh necesarios para enviar el pedido.\n\nEjemplo:  \nPara un pedido con 1 producto de tamaño 1x1, 2 productos de tamaño 2x2, y 1 producto de tamaño 3x3,  \nla función calculará y devolverá el número mínimo de paquetes necesarios.",
      "arb": "هذه الدالة تحسب الحد الأدنى لعدد الطرود ذات الحجم 6x6xh المطلوبة لشحن طلب من المنتجات ذات الأحجام المختلفة. تتراوح أحجام المنتجات من 1x1 إلى 6x6، وكل منتج يتطلب مقدارًا معينًا من المساحة في الطرد. الهدف هو تعبئة هذه المنتجات بكفاءة لتقليل عدد الطرود، مما يقلل من تكاليف الشحن.\n\nالمدخلات: ستة أعداد صحيحة ($a, $b, $c, $d, $e, $f)، كل منها يمثل كمية المنتجات من الحجم 1x1 إلى 6x6.\nالمخرجات: عدد صحيح يمثل الحد الأدنى لعدد الطرود ذات الحجم 6x6xh المطلوبة لشحن الطلب.\n\nمثال:\nبالنسبة لطلب يحتوي على منتج واحد بحجم 1x1، و2 من المنتجات بحجم 2x2، ومنتج واحد بحجم 3x3،\nستقوم الدالة بحساب وإرجاع الحد الأدنى لعدد الطرود المطلوبة.",
      "sw": "Kazi hii inahesabu idadi ndogo ya vifurushi vya 6x6xh vinavyohitajika kusafirisha agizo la bidhaa za ukubwa mbalimbali. Ukubwa wa bidhaa hutoka 1x1 hadi 6x6, na kila bidhaa inahitaji kiasi fulani cha nafasi kwenye kifurushi. Lengo ni kufunga bidhaa hizi kwa ufanisi ili kupunguza idadi ya vifurushi, na hivyo kupunguza gharama za usafirishaji.\n\nIngizo: Nambari sita ($a, $b, $c, $d, $e, $f), kila moja ikiwakilisha idadi ya bidhaa kutoka ukubwa wa 1x1 hadi 6x6. \nMatokeo: Nambari moja inayowakilisha idadi ndogo ya vifurushi vya 6x6xh vinavyohitajika kusafirisha agizo.\n\nMfano:\nKwa agizo lenye bidhaa 1 ya ukubwa 1x1, bidhaa 2 za ukubwa 2x2, na bidhaa 1 ya ukubwa 3x3,\nkazi itahesabu na kurudisha idadi ndogo ya vifurushi vinavyohitajika.",
      "tr": "Bu fonksiyon, çeşitli boyutlardaki ürün siparişini göndermek için gereken minimum 6x6xh paket sayısını hesaplar.\nÜrün boyutları 1x1'den 6x6'ya kadar değişir ve her ürün pakette belirli bir miktarda alan gerektirir.\nAmaç, nakliye maliyetlerini azaltmak için bu ürünleri verimli bir şekilde paketlemektir.\n\nGirdi: 1x1'den 6x6'ya kadar olan ürünlerin miktarını temsil eden altı tamsayı ($a, $b, $c, $d, $e, $f).\nÇıktı: Siparişi göndermek için gereken minimum 6x6xh paket sayısını temsil eden bir tamsayı.\n\nÖrnek:\n1 adet 1x1 boyutunda ürün, 2 adet 2x2 boyutunda ürün ve 1 adet 3x3 boyutunda ürün içeren bir sipariş için,\nfonksiyon gereken minimum paket sayısını hesaplayacak ve döndürecektir.",
      "vi": "Hàm này tính toán số lượng tối thiểu các gói 6x6xh cần thiết để vận chuyển một đơn hàng gồm các sản phẩm có kích thước khác nhau.  \nKích thước của các sản phẩm dao động từ 1x1 đến 6x6, và mỗi sản phẩm yêu cầu một lượng không gian nhất định trong gói.  \nMục tiêu là đóng gói các sản phẩm này một cách hiệu quả để giảm thiểu số lượng gói, giảm chi phí vận chuyển.\n\nĐầu vào: Sáu số nguyên ($a, $b, $c, $d, $e, $f), mỗi số đại diện cho số lượng sản phẩm từ kích thước 1x1 đến 6x6.  \nĐầu ra: Một số nguyên đại diện cho số lượng tối thiểu các gói 6x6xh cần thiết để vận chuyển đơn hàng.\n\nVí dụ:  \nĐối với một đơn hàng với 1 sản phẩm kích thước 1x1, 2 sản phẩm kích thước 2x2, và 1 sản phẩm kích thước 3x3,  \nhàm sẽ tính toán và trả về số lượng gói tối thiểu cần thiết."
    },
    "docstring_bertscore": {
      "es": "0.9960905568404713",
      "arb": "0.9618973298972205",
      "sw": "0.9706092584094107",
      "tr": "0.9759486416820096",
      "vi": "0.9944256369866369"
    }
  },
  {
    "task_id": "PHP/10",
    "prompt": {
      "en": "<?php\n\n/**\n    * Calculates the number of chickens and rabbits in a farm.\n    * Given the total number of animals and the total number of legs, the function determines\n    * how many chickens and rabbits are there. \n    * Assumptions: \n    * - Each chicken has 2 legs.\n    * - Each rabbit has 4 legs.\n    * - The total number of animals and legs are non-negative integers.\n    * \n    * Input: Two integers, $totalAnimals (total number of animals) and $totalLegs (total number of legs).\n    * Output: Returns an array [number_of_chickens, number_of_rabbits] if a valid solution exists, \n    *         or \"No answer\" if no valid solution is found.\n    * \n    * Example:\n    * For 5 animals and 12 legs, the function will return [4, 1] (4 chickens and 1 rabbit).\n    * For 10 animals and 16 legs, the function will return \"No answer\" as no valid combination exists.\n    */\n\n    function calculateAnimals($totalAnimals, $totalLegs) ",
      "es": "<?php\n\n/**\n    * Calcula el número de gallinas y conejos en una granja.\n    * Dado el número total de animales y el número total de patas, la función determina\n    * cuántas gallinas y conejos hay.\n    * Suposiciones:\n    * - Cada gallina tiene 2 patas.\n    * - Cada conejo tiene 4 patas.\n    * - El número total de animales y patas son enteros no negativos.\n    * \n    * Entrada: Dos enteros, $totalAnimals (número total de animales) y $totalLegs (número total de patas).\n    * Salida: Devuelve un arreglo [number_of_chickens, number_of_rabbits] si existe una solución válida,\n    *         o \"No answer\" si no se encuentra una solución válida.\n    * \n    * Ejemplo:\n    * Para 5 animales y 12 patas, la función devolverá [4, 1] (4 gallinas y 1 conejo).\n    * Para 10 animales y 16 patas, la función devolverá \"No answer\" ya que no existe una combinación válida.\n    */\n\n    function calculateAnimals($totalAnimals, $totalLegs) ",
      "arb": "<?php\n\n/**\n    * يحسب عدد الدجاج والأرانب في المزرعة.\n    * بالنظر إلى العدد الإجمالي للحيوانات والعدد الإجمالي للأرجل، تحدد الدالة\n    * كم عدد الدجاج والأرانب هناك.\n    * الافتراضات:\n    * - كل دجاجة لها 2 أرجل.\n    * - كل أرنب له 4 أرجل.\n    * - العدد الإجمالي للحيوانات والأرجل هي أعداد صحيحة غير سلبية.\n    * \n    * المدخلات: عددان صحيحان، $totalAnimals (العدد الإجمالي للحيوانات) و $totalLegs (العدد الإجمالي للأرجل).\n    * المخرجات: تعيد مصفوفة [عدد_الدجاج, عدد_الأرانب] إذا كانت هناك حل صحيح موجود، \n    *         أو \"لا إجابة\" إذا لم يتم العثور على حل صحيح.\n    * \n    * مثال:\n    * بالنسبة لـ 5 حيوانات و 12 أرجل، ستعيد الدالة [4, 1] (4 دجاجات و 1 أرنب).\n    * بالنسبة لـ 10 حيوانات و 16 أرجل، ستعيد الدالة \"لا إجابة\" لأنه لا يوجد تركيبة صحيحة.\n    */\n\n    function calculateAnimals($totalAnimals, $totalLegs) ",
      "sw": "<?php\n\n/**\n    * Inahesabu idadi ya kuku na sungura katika shamba.\n    * Ukipewa jumla ya idadi ya wanyama na jumla ya idadi ya miguu, kazi hii inaamua\n    * ni kuku wangapi na sungura wangapi wapo. \n    * Dhana:\n    * - Kila kuku ana miguu 2.\n    * - Kila sungura ana miguu 4.\n    * - Jumla ya idadi ya wanyama na miguu ni namba zisizo hasi.\n    * \n    * Ingizo: Namba mbili, $totalAnimals (jumla ya idadi ya wanyama) na $totalLegs (jumla ya idadi ya miguu).\n    * Tokeo: Inarudisha array [number_of_chickens, number_of_rabbits] ikiwa suluhisho sahihi lipo, \n    *         au \"Hakuna jibu\" ikiwa hakuna suluhisho sahihi lililopatikana.\n    * \n    * Mfano:\n    * Kwa wanyama 5 na miguu 12, kazi hii itarudisha [4, 1] (kuku 4 na sungura 1).\n    * Kwa wanyama 10 na miguu 16, kazi hii itarudisha \"Hakuna jibu\" kwani hakuna mchanganyiko sahihi uliopo.\n    */\n\n    function calculateAnimals($totalAnimals, $totalLegs) ",
      "tr": "<?php\n\n/**\n    * Bir çiftlikteki tavuk ve tavşanların sayısını hesaplar.\n    * Toplam hayvan sayısı ve toplam bacak sayısı verildiğinde, fonksiyon\n    * kaç tavuk ve kaç tavşan olduğunu belirler.\n    * Varsayımlar:\n    * - Her tavuk 2 bacağa sahiptir.\n    * - Her tavşan 4 bacağa sahiptir.\n    * - Toplam hayvan ve bacak sayıları negatif olmayan tam sayılardır.\n    * \n    * Girdi: İki tam sayı, $totalAnimals (toplam hayvan sayısı) ve $totalLegs (toplam bacak sayısı).\n    * Çıktı: Geçerli bir çözüm varsa bir dizi [number_of_chickens, number_of_rabbits] döndürür,\n    *         veya geçerli bir çözüm bulunamazsa \"No answer\" döndürür.\n    * \n    * Örnek:\n    * 5 hayvan ve 12 bacak için, fonksiyon [4, 1] (4 tavuk ve 1 tavşan) döndürecektir.\n    * 10 hayvan ve 16 bacak için, fonksiyon \"No answer\" döndürecektir çünkü geçerli bir kombinasyon yoktur.\n    */\n\n    function calculateAnimals($totalAnimals, $totalLegs) ",
      "vi": "<?php\n\n/**\n    * Tính toán số lượng gà và thỏ trong một trang trại.\n    * Cho tổng số lượng động vật và tổng số chân, hàm sẽ xác định\n    * có bao nhiêu con gà và thỏ.\n    * Giả định:\n    * - Mỗi con gà có 2 chân.\n    * - Mỗi con thỏ có 4 chân.\n    * - Tổng số lượng động vật và chân là các số nguyên không âm.\n    * \n    * Đầu vào: Hai số nguyên, $totalAnimals (tổng số động vật) và $totalLegs (tổng số chân).\n    * Đầu ra: Trả về một mảng [số lượng gà, số lượng thỏ] nếu tồn tại một giải pháp hợp lệ,\n    *         hoặc \"No answer\" nếu không tìm thấy giải pháp hợp lệ.\n    * \n    * Ví dụ:\n    * Với 5 động vật và 12 chân, hàm sẽ trả về [4, 1] (4 con gà và 1 con thỏ).\n    * Với 10 động vật và 16 chân, hàm sẽ trả về \"No answer\" vì không tồn tại kết hợp hợp lệ.\n    */\n\n    function calculateAnimals($totalAnimals, $totalLegs) "
    },
    "prompt_bertscore": {
      "es": "0.9959227141684969",
      "arb": "0.9872703747706171",
      "sw": "0.9697436272088606",
      "tr": "0.981103894591389",
      "vi": "0.9742030778934749"
    },
    "canonical_solution": "{\n        // Check if the total number of legs is even\n        if ($totalLegs % 2 != 0) {\n            return \"No answer\";\n        }\n    \n        // Calculate the number of rabbits\n        $rabbits = ($totalLegs - 2 * $totalAnimals) / 2;\n    \n        // Calculate the number of chickens\n        $chickens = $totalAnimals - $rabbits;\n    \n        // Check if the number of rabbits and chickens are non-negative integers\n        if ($rabbits < 0 || $chickens < 0 || $rabbits != (int)$rabbits || $chickens != (int)$chickens) {\n            return \"No answer\";\n        }\n    \n        return [$chickens, $rabbits];\n    }",
    "instruction": {
      "en": "function calculateAnimals($totalAnimals, $totalLegs)\n{\n        // Check if the total number of legs is even\n        if ($totalLegs % 2 != 0) {\n            return \"No answer\";\n        }\n    \n        // Calculate the number of rabbits\n        $rabbits = ($totalLegs - 2 * $totalAnimals) / 2;\n    \n        // Calculate the number of chickens\n        $chickens = $totalAnimals - $rabbits;\n    \n        // Check if the number of rabbits and chickens are non-negative integers\n        if ($rabbits < 0 || $chickens < 0 || $rabbits != (int)$rabbits || $chickens != (int)$chickens) {\n            return \"No answer\";\n        }\n    \n        return [$chickens, $rabbits];\n    }\n\nProvide a concise natural language description (docstring) of the PHP code in English using at most 500 characters.",
      "es": "function calculateAnimals($totalAnimals, $totalLegs)\n{\n        // Check if the total number of legs is even\n        if ($totalLegs % 2 != 0) {\n            return \"No answer\";\n        }\n    \n        // Calculate the number of rabbits\n        $rabbits = ($totalLegs - 2 * $totalAnimals) / 2;\n    \n        // Calculate the number of chickens\n        $chickens = $totalAnimals - $rabbits;\n    \n        // Check if the number of rabbits and chickens are non-negative integers\n        if ($rabbits < 0 || $chickens < 0 || $rabbits != (int)$rabbits || $chickens != (int)$chickens) {\n            return \"No answer\";\n        }\n    \n        return [$chickens, $rabbits];\n    }\n\nProporcione una descripción concisa en lenguaje natural (docstring) del código PHP en español utilizando como máximo 500 caracteres.",
      "arb": "function calculateAnimals($totalAnimals, $totalLegs)\n{\n        // Check if the total number of legs is even\n        if ($totalLegs % 2 != 0) {\n            return \"No answer\";\n        }\n    \n        // Calculate the number of rabbits\n        $rabbits = ($totalLegs - 2 * $totalAnimals) / 2;\n    \n        // Calculate the number of chickens\n        $chickens = $totalAnimals - $rabbits;\n    \n        // Check if the number of rabbits and chickens are non-negative integers\n        if ($rabbits < 0 || $chickens < 0 || $rabbits != (int)$rabbits || $chickens != (int)$chickens) {\n            return \"No answer\";\n        }\n    \n        return [$chickens, $rabbits];\n    }\n\nيرجى تقديم وصف موجز بلغة طبيعية (docstring) للكود المكتوب بلغة PHP باللغة العربية الفصحى، بحيث لا يتجاوز 500 حرف.",
      "sw": "function calculateAnimals($totalAnimals, $totalLegs)\n{\n        // Check if the total number of legs is even\n        if ($totalLegs % 2 != 0) {\n            return \"No answer\";\n        }\n    \n        // Calculate the number of rabbits\n        $rabbits = ($totalLegs - 2 * $totalAnimals) / 2;\n    \n        // Calculate the number of chickens\n        $chickens = $totalAnimals - $rabbits;\n    \n        // Check if the number of rabbits and chickens are non-negative integers\n        if ($rabbits < 0 || $chickens < 0 || $rabbits != (int)$rabbits || $chickens != (int)$chickens) {\n            return \"No answer\";\n        }\n    \n        return [$chickens, $rabbits];\n    }\n\nToa maelezo mafupi ya lugha ya asili (docstring) ya msimbo wa PHP kwa Kiswahili kwa kutumia herufi zisizozidi 500.",
      "tr": "function calculateAnimals($totalAnimals, $totalLegs)\n{\n        // Check if the total number of legs is even\n        if ($totalLegs % 2 != 0) {\n            return \"No answer\";\n        }\n    \n        // Calculate the number of rabbits\n        $rabbits = ($totalLegs - 2 * $totalAnimals) / 2;\n    \n        // Calculate the number of chickens\n        $chickens = $totalAnimals - $rabbits;\n    \n        // Check if the number of rabbits and chickens are non-negative integers\n        if ($rabbits < 0 || $chickens < 0 || $rabbits != (int)$rabbits || $chickens != (int)$chickens) {\n            return \"No answer\";\n        }\n    \n        return [$chickens, $rabbits];\n    }\n\nAşağıdaki PHP kodunun işlevini açıklayan, en fazla 500 karakter uzunluğunda özlü bir doğal dil açıklaması (docstring) sağlayın.",
      "vi": "function calculateAnimals($totalAnimals, $totalLegs)\n{\n        // Check if the total number of legs is even\n        if ($totalLegs % 2 != 0) {\n            return \"No answer\";\n        }\n    \n        // Calculate the number of rabbits\n        $rabbits = ($totalLegs - 2 * $totalAnimals) / 2;\n    \n        // Calculate the number of chickens\n        $chickens = $totalAnimals - $rabbits;\n    \n        // Check if the number of rabbits and chickens are non-negative integers\n        if ($rabbits < 0 || $chickens < 0 || $rabbits != (int)$rabbits || $chickens != (int)$chickens) {\n            return \"No answer\";\n        }\n    \n        return [$chickens, $rabbits];\n    }\n\nCung cấp mô tả ngắn gọn bằng ngôn ngữ tự nhiên (docstring) cho mã PHP bằng tiếng Việt với tối đa 500 ký tự."
    },
    "instruction_bertscore": {
      "es": "0.9687069752502395",
      "arb": "0.8833251100712498",
      "sw": "0.91585798565943",
      "tr": "0.8581880380905226",
      "vi": "0.9222151510044516"
    },
    "level": "",
    "test": "function main(){\n    assert(calculateAnimals(14, 32) === [12, 2]);\n    assert(calculateAnimals(10, 16) === \"No answer\");\n    assert(calculateAnimals(5, 12) === [4, 1]);\n    assert(calculateAnimals(3, 10) === [1, 2]);\n    assert(calculateAnimals(0, 0) === [0, 0]);\n}\n\n\nmain();\n?>",
    "entry_point": "calculateAnimals",
    "signature": "function calculateAnimals($totalAnimals, $totalLegs)",
    "docstring": {
      "en": "Calculates the number of chickens and rabbits in a farm.\nGiven the total number of animals and the total number of legs, the function determines\nhow many chickens and rabbits are there.\nAssumptions:\n- Each chicken has 2 legs.\n- Each rabbit has 4 legs.\n- The total number of animals and legs are non-negative integers.\n\nInput: Two integers, $totalAnimals (total number of animals) and $totalLegs (total number of legs).\nOutput: Returns an array [number_of_chickens, number_of_rabbits] if a valid solution exists,\nor \"No answer\" if no valid solution is found.\n\nExample:\nFor 5 animals and 12 legs, the function will return [4, 1] (4 chickens and 1 rabbit).\nFor 10 animals and 16 legs, the function will return \"No answer\" as no valid combination exists.",
      "es": "Calcula el número de gallinas y conejos en una granja.\nDado el número total de animales y el número total de patas, la función determina\ncuántas gallinas y conejos hay.\nSuposiciones:\n- Cada gallina tiene 2 patas.\n- Cada conejo tiene 4 patas.\n- El número total de animales y patas son enteros no negativos.\n\nEntrada: Dos enteros, $totalAnimals (número total de animales) y $totalLegs (número total de patas).\nSalida: Devuelve un array [number_of_chickens, number_of_rabbits] si existe una solución válida,\no \"No answer\" si no se encuentra una solución válida.\n\nEjemplo:\nPara 5 animales y 12 patas, la función devolverá [4, 1] (4 gallinas y 1 conejo).\nPara 10 animales y 16 patas, la función devolverá \"No answer\" ya que no existe una combinación válida.",
      "arb": "يحسب عدد الدجاج والأرانب في المزرعة.  \nبالنظر إلى العدد الإجمالي للحيوانات والعدد الإجمالي للأرجل، تحدد الدالة  \nعدد الدجاج والأرانب الموجودين.  \nالافتراضات:  \n- كل دجاجة لها 2 رجلين.  \n- كل أرنب له 4 أرجل.  \n- العدد الإجمالي للحيوانات والأرجل هما عددان صحيحان غير سالبين.  \n\nالمدخلات: عددان صحيحان، $totalAnimals (العدد الإجمالي للحيوانات) و $totalLegs (العدد الإجمالي للأرجل).  \nالمخرجات: تعيد مصفوفة [عدد_الدجاج، عدد_الأرانب] إذا كانت هناك حل صالح،  \nأو \"لا يوجد جواب\" إذا لم يتم العثور على حل صالح.  \n\nمثال:  \nبالنسبة لـ 5 حيوانات و 12 رجلًا، ستعيد الدالة [4, 1] (4 دجاجات و 1 أرنب).  \nبالنسبة لـ 10 حيوانات و 16 رجلًا، ستعيد الدالة \"لا يوجد جواب\" حيث لا يوجد تركيبة صالحة.",
      "sw": "Hesabu idadi ya kuku na sungura katika shamba.  \nKwa kuzingatia jumla ya idadi ya wanyama na jumla ya miguu, kazi hii inaamua ni kuku wangapi na sungura wangapi wapo.  \nMadhumuni:  \n- Kila kuku ana miguu 2.  \n- Kila sungura ana miguu 4.  \n- Jumla ya idadi ya wanyama na miguu ni namba zisizo hasi.  \n\nIngizo: Namba mbili za mzima, $totalAnimals (jumla ya idadi ya wanyama) na $totalLegs (jumla ya miguu).  \nMatokeo: Inarudisha safu [number_of_chickens, number_of_rabbits] ikiwa suluhisho halali lipo, au \"Hakuna jibu\" ikiwa hakuna suluhisho halali lililopatikana.  \n\nMfano:  \nKwa wanyama 5 na miguu 12, kazi itarudisha [4, 1] (kuku 4 na sungura 1).  \nKwa wanyama 10 na miguu 16, kazi itarudisha \"Hakuna jibu\" kwani hakuna mchanganyiko halali uliopo.  ",
      "tr": "Tavuk ve tavşan sayısını bir çiftlikte hesaplar.\nToplam hayvan sayısı ve toplam bacak sayısı verildiğinde, fonksiyon\nkaç tavuk ve tavşan olduğunu belirler.\nVarsayımlar:\n- Her tavuk 2 bacağa sahiptir.\n- Her tavşan 4 bacağa sahiptir.\n- Toplam hayvan ve bacak sayıları negatif olmayan tam sayılardır.\n\nGirdi: İki tam sayı, $totalAnimals (toplam hayvan sayısı) ve $totalLegs (toplam bacak sayısı).\nÇıktı: Geçerli bir çözüm varsa [number_of_chickens, number_of_rabbits] dizisini döndürür,\nveya geçerli bir çözüm bulunamazsa \"No answer\" döndürür.\n\nÖrnek:\n5 hayvan ve 12 bacak için, fonksiyon [4, 1] (4 tavuk ve 1 tavşan) döndürecektir.\n10 hayvan ve 16 bacak için, fonksiyon \"No answer\" döndürecektir çünkü geçerli bir kombinasyon yoktur.",
      "vi": "Tính toán số lượng gà và thỏ trong một trang trại.  \nDựa trên tổng số lượng động vật và tổng số lượng chân, hàm xác định  \ncó bao nhiêu con gà và con thỏ.  \nGiả định:  \n- Mỗi con gà có 2 chân.  \n- Mỗi con thỏ có 4 chân.  \n- Tổng số lượng động vật và chân là các số nguyên không âm.  \n\nĐầu vào: Hai số nguyên, $totalAnimals (tổng số động vật) và $totalLegs (tổng số chân).  \nĐầu ra: Trả về một mảng [number_of_chickens, number_of_rabbits] nếu tồn tại một giải pháp hợp lệ,  \nhoặc \"No answer\" nếu không tìm thấy giải pháp hợp lệ nào.  \n\nVí dụ:  \nVới 5 động vật và 12 chân, hàm sẽ trả về [4, 1] (4 con gà và 1 con thỏ).  \nVới 10 động vật và 16 chân, hàm sẽ trả về \"No answer\" vì không tồn tại kết hợp hợp lệ nào."
    },
    "docstring_bertscore": {
      "es": "0.9929710667063184",
      "arb": "0.9791900908701179",
      "sw": "0.9512864949423367",
      "tr": "0.9849233581883089",
      "vi": "0.9873657173535139"
    }
  },
  {
    "task_id": "PHP/11",
    "prompt": {
      "en": "<?php\n\n/**\n * Identifies the most frequently occurring character in a given string.\n * The string is composed of lowercase letters from 'a' to 'z'.\n * If there are multiple characters with the same highest frequency,\n * the character with the smallest ASCII value is returned.\n * \n * Example:\n * Input: \"apple\"\n * Output: \"p 2\" (The character 'p' appears twice)\n * \n * Input: \"environment\"\n * Output: \"n 3\" (The character 'n' appears three times, the most frequent)\n */\n\nfunction findMostFrequentChar($string) ",
      "es": "<?php\n\n/**\n * Identifica el carácter que aparece con mayor frecuencia en una cadena dada.\n * La cadena está compuesta por letras minúsculas de 'a' a 'z'.\n * Si hay múltiples caracteres con la misma frecuencia más alta,\n * se devuelve el carácter con el valor ASCII más pequeño.\n * \n * Ejemplo:\n * Entrada: \"apple\"\n * Salida: \"p 2\" (El carácter 'p' aparece dos veces)\n * \n * Entrada: \"environment\"\n * Salida: \"n 3\" (El carácter 'n' aparece tres veces, el más frecuente)\n */\n\nfunction findMostFrequentChar($string) ",
      "arb": "<?php\n\n/**\n * يحدد الحرف الأكثر تكرارًا في سلسلة معينة.\n * تتكون السلسلة من أحرف صغيرة من 'a' إلى 'z'.\n * إذا كان هناك عدة أحرف بنفس التكرار الأعلى،\n * يتم إرجاع الحرف ذو القيمة ASCII الأصغر.\n * \n * مثال:\n * المدخل: \"apple\"\n * المخرج: \"p 2\" (الحرف 'p' يظهر مرتين)\n * \n * المدخل: \"environment\"\n * المخرج: \"n 3\" (الحرف 'n' يظهر ثلاث مرات، الأكثر تكرارًا)\n */\n\nfunction findMostFrequentChar($string) ",
      "sw": "<?php\n\n/**\n * Inatambua herufi inayojitokeza mara nyingi zaidi katika kamba iliyotolewa.\n * Kamba inaundwa na herufi ndogo kutoka 'a' hadi 'z'.\n * Ikiwa kuna herufi nyingi zenye mzunguko sawa wa juu,\n * herufi yenye thamani ndogo zaidi ya ASCII inarejeshwa.\n * \n * Mfano:\n * Ingizo: \"apple\"\n * Matokeo: \"p 2\" (Herufi 'p' inaonekana mara mbili)\n * \n * Ingizo: \"environment\"\n * Matokeo: \"n 3\" (Herufi 'n' inaonekana mara tatu, mara nyingi zaidi)\n */\n\nfunction findMostFrequentChar($string) ",
      "tr": "<?php\n\n/**\n * Verilen bir stringde en sık görülen karakteri belirler.\n * String, 'a'dan 'z'ye kadar küçük harflerden oluşur.\n * Eğer en yüksek sıklığa sahip birden fazla karakter varsa,\n * ASCII değeri en küçük olan karakter döndürülür.\n * \n * Örnek:\n * Girdi: \"apple\"\n * Çıktı: \"p 2\" (Karakter 'p' iki kez görülür)\n * \n * Girdi: \"environment\"\n * Çıktı: \"n 3\" (Karakter 'n' üç kez görülür, en sık)\n */\n\nfunction findMostFrequentChar($string) ",
      "vi": "<?php\n\n/**\n * Xác định ký tự xuất hiện thường xuyên nhất trong một chuỗi cho trước.\n * Chuỗi được tạo thành từ các chữ cái thường từ 'a' đến 'z'.\n * Nếu có nhiều ký tự có cùng tần suất cao nhất,\n * ký tự có giá trị ASCII nhỏ nhất sẽ được trả về.\n * \n * Ví dụ:\n * Đầu vào: \"apple\"\n * Đầu ra: \"p 2\" (Ký tự 'p' xuất hiện hai lần)\n * \n * Đầu vào: \"environment\"\n * Đầu ra: \"n 3\" (Ký tự 'n' xuất hiện ba lần, là tần suất cao nhất)\n */\n\nfunction findMostFrequentChar($string) "
    },
    "prompt_bertscore": {
      "es": "0.9907068789929018",
      "arb": "0.9838271171153773",
      "sw": "0.9920506135206028",
      "tr": "0.9692448663220821",
      "vi": "0.9723580002840418"
    },
    "canonical_solution": "{\n    $frequency = [];\n    $maxFreq = 0;\n    $resultChar = '';\n\n    for ($i = 0; $i < strlen($string); $i++) {\n        $char = $string[$i];\n        if (!isset($frequency[$char])) {\n            $frequency[$char] = 0;\n        }\n        $frequency[$char]++;\n\n        if ($frequency[$char] > $maxFreq || \n            ($frequency[$char] == $maxFreq && $char < $resultChar)) {\n            $maxFreq = $frequency[$char];\n            $resultChar = $char;\n        }\n    }\n\n    return $resultChar . \" \" . $maxFreq;\n}",
    "instruction": {
      "en": "function findMostFrequentChar($string)\n{\n    $frequency = [];\n    $maxFreq = 0;\n    $resultChar = '';\n\n    for ($i = 0; $i < strlen($string); $i++) {\n        $char = $string[$i];\n        if (!isset($frequency[$char])) {\n            $frequency[$char] = 0;\n        }\n        $frequency[$char]++;\n\n        if ($frequency[$char] > $maxFreq || \n            ($frequency[$char] == $maxFreq && $char < $resultChar)) {\n            $maxFreq = $frequency[$char];\n            $resultChar = $char;\n        }\n    }\n\n    return $resultChar . \" \" . $maxFreq;\n}\n\nProvide a concise natural language description (docstring) of the PHP code in English using at most 500 characters.",
      "es": "function findMostFrequentChar($string)\n{\n    $frequency = [];\n    $maxFreq = 0;\n    $resultChar = '';\n\n    for ($i = 0; $i < strlen($string); $i++) {\n        $char = $string[$i];\n        if (!isset($frequency[$char])) {\n            $frequency[$char] = 0;\n        }\n        $frequency[$char]++;\n\n        if ($frequency[$char] > $maxFreq || \n            ($frequency[$char] == $maxFreq && $char < $resultChar)) {\n            $maxFreq = $frequency[$char];\n            $resultChar = $char;\n        }\n    }\n\n    return $resultChar . \" \" . $maxFreq;\n}\n\nProporcione una descripción concisa en lenguaje natural (docstring) del código PHP en español utilizando como máximo 500 caracteres.",
      "arb": "function findMostFrequentChar($string)\n{\n    $frequency = [];\n    $maxFreq = 0;\n    $resultChar = '';\n\n    for ($i = 0; $i < strlen($string); $i++) {\n        $char = $string[$i];\n        if (!isset($frequency[$char])) {\n            $frequency[$char] = 0;\n        }\n        $frequency[$char]++;\n\n        if ($frequency[$char] > $maxFreq || \n            ($frequency[$char] == $maxFreq && $char < $resultChar)) {\n            $maxFreq = $frequency[$char];\n            $resultChar = $char;\n        }\n    }\n\n    return $resultChar . \" \" . $maxFreq;\n}\n\nيرجى تقديم وصف موجز بلغة طبيعية (docstring) لشيفرة PHP باللغة العربية الفصحى باستخدام 500 حرف كحد أقصى.",
      "sw": "function findMostFrequentChar($string)\n{\n    $frequency = [];\n    $maxFreq = 0;\n    $resultChar = '';\n\n    for ($i = 0; $i < strlen($string); $i++) {\n        $char = $string[$i];\n        if (!isset($frequency[$char])) {\n            $frequency[$char] = 0;\n        }\n        $frequency[$char]++;\n\n        if ($frequency[$char] > $maxFreq || \n            ($frequency[$char] == $maxFreq && $char < $resultChar)) {\n            $maxFreq = $frequency[$char];\n            $resultChar = $char;\n        }\n    }\n\n    return $resultChar . \" \" . $maxFreq;\n}\n\nToa maelezo mafupi ya lugha asilia (docstring) ya msimbo wa PHP kwa Kiswahili kwa kutumia herufi zisizozidi 500.",
      "tr": "function findMostFrequentChar($string)\n{\n    $frequency = [];\n    $maxFreq = 0;\n    $resultChar = '';\n\n    for ($i = 0; $i < strlen($string); $i++) {\n        $char = $string[$i];\n        if (!isset($frequency[$char])) {\n            $frequency[$char] = 0;\n        }\n        $frequency[$char]++;\n\n        if ($frequency[$char] > $maxFreq || \n            ($frequency[$char] == $maxFreq && $char < $resultChar)) {\n            $maxFreq = $frequency[$char];\n            $resultChar = $char;\n        }\n    }\n\n    return $resultChar . \" \" . $maxFreq;\n}\n\nPHP kodunun işlevini açıklayan kısa bir doğal dil açıklaması (docstring) sağlayın. Açıklama, en fazla 500 karakter kullanarak Türkçe olmalıdır.",
      "vi": "function findMostFrequentChar($string)\n{\n    $frequency = [];\n    $maxFreq = 0;\n    $resultChar = '';\n\n    for ($i = 0; $i < strlen($string); $i++) {\n        $char = $string[$i];\n        if (!isset($frequency[$char])) {\n            $frequency[$char] = 0;\n        }\n        $frequency[$char]++;\n\n        if ($frequency[$char] > $maxFreq || \n            ($frequency[$char] == $maxFreq && $char < $resultChar)) {\n            $maxFreq = $frequency[$char];\n            $resultChar = $char;\n        }\n    }\n\n    return $resultChar . \" \" . $maxFreq;\n}\n\nCung cấp mô tả ngắn gọn bằng ngôn ngữ tự nhiên (docstring) cho mã PHP bằng tiếng Việt với tối đa 500 ký tự."
    },
    "instruction_bertscore": {
      "es": "0.9687069752502395",
      "arb": "0.9148910529645522",
      "sw": "0.9428367585331127",
      "tr": "0.8785945289165229",
      "vi": "0.9150604846795749"
    },
    "level": "",
    "test": "function main(){\n    assert(findMostFrequentChar(\"abbccc\") === \"c 3\");\n    assert(findMostFrequentChar(\"adfadffasdf\") === \"f 4\");\n    assert(findMostFrequentChar(\"environment\") === \"n 3\");\n    assert(findMostFrequentChar(\"apple\") === \"p 2\");\n    assert(findMostFrequentChar(\"banana\") === \"a 3\");\n    \n}\n\n\nmain();\n?>",
    "entry_point": "findMostFrequentChar",
    "signature": "function findMostFrequentChar($string)",
    "docstring": {
      "en": "Identifies the most frequently occurring character in a given string.\nThe string is composed of lowercase letters from 'a' to 'z'.\nIf there are multiple characters with the same highest frequency,\nthe character with the smallest ASCII value is returned.\n\nExample:\nInput: \"apple\"\nOutput: \"p 2\" (The character 'p' appears twice)\n\nInput: \"environment\"\nOutput: \"n 3\" (The character 'n' appears three times, the most frequent)",
      "es": "Identifica el carácter que ocurre con mayor frecuencia en una cadena dada. La cadena está compuesta por letras minúsculas de 'a' a 'z'. Si hay varios caracteres con la misma frecuencia más alta, se devuelve el carácter con el valor ASCII más pequeño.\n\nEjemplo:\nEntrada: \"apple\"\nSalida: \"p 2\" (El carácter 'p' aparece dos veces)\n\nEntrada: \"environment\"\nSalida: \"n 3\" (El carácter 'n' aparece tres veces, el más frecuente)",
      "arb": "يحدد الحرف الأكثر تكرارًا في سلسلة معينة.  \nالسلسلة تتكون من أحرف صغيرة من 'a' إلى 'z'.  \nإذا كان هناك عدة أحرف بنفس التكرار الأعلى،  \nيتم إرجاع الحرف ذو القيمة ASCII الأصغر.\n\nمثال:  \nالمدخل: \"apple\"  \nالمخرج: \"p 2\" (الحرف 'p' يظهر مرتين)\n\nالمدخل: \"environment\"  \nالمخرج: \"n 3\" (الحرف 'n' يظهر ثلاث مرات، الأكثر تكرارًا)",
      "sw": "Inatambua herufi inayotokea mara nyingi zaidi katika kamba iliyotolewa.\nKamba inaundwa na herufi ndogo kutoka 'a' hadi 'z'.\nIkiwa kuna herufi nyingi zenye frequency sawa ya juu,\nherufi iliyo na thamani ndogo zaidi ya ASCII inarejeshwa.\n\nMfano:\nIngizo: \"apple\"\nMatokeo: \"p 2\" (Herufi 'p' inaonekana mara mbili)\n\nIngizo: \"environment\"\nMatokeo: \"n 3\" (Herufi 'n' inaonekana mara tatu, mara nyingi zaidi)",
      "tr": "Verilen bir stringde en sık görülen karakteri belirler. String, 'a' ile 'z' arasında küçük harflerden oluşur. Eğer aynı en yüksek frekansa sahip birden fazla karakter varsa, ASCII değeri en küçük olan karakter döndürülür.\n\nÖrnek:\nGirdi: \"apple\"\nÇıktı: \"p 2\" (Karakter 'p' iki kez görünür)\n\nGirdi: \"environment\"\nÇıktı: \"n 3\" (Karakter 'n' üç kez görünür, en sık olan)",
      "vi": "Xác định ký tự xuất hiện thường xuyên nhất trong một chuỗi cho trước.  \nChuỗi được tạo thành từ các chữ cái thường từ 'a' đến 'z'.  \nNếu có nhiều ký tự có cùng tần suất cao nhất,  \nký tự có giá trị ASCII nhỏ nhất sẽ được trả về.  \n\nVí dụ:  \nĐầu vào: \"apple\"  \nĐầu ra: \"p 2\" (Ký tự 'p' xuất hiện hai lần)  \n\nĐầu vào: \"environment\"  \nĐầu ra: \"n 3\" (Ký tự 'n' xuất hiện ba lần, thường xuyên nhất)  "
    },
    "docstring_bertscore": {
      "es": "0.986740230283635",
      "arb": "0.977494184676842",
      "sw": "0.975479278091624",
      "tr": "0.9653705807399966",
      "vi": "0.9676381451698909"
    }
  },
  {
    "task_id": "PHP/12",
    "prompt": {
      "en": "<?php\n\n\n/**\n    * Finds the fractional element in a diagonally arranged sequence.\n    * In this sequence, fractions are arranged in a diagonal pattern. The first row contains fractions with the numerator 1 and increasing denominators. Each subsequent row increases the numerator and decreases the denominator until it reaches 1.\n    * For example, the sequence starts with 1/1, 1/2, 2/1, 3/1, 2/2, ...\n        1/1   1/2   1/3   1/4   1/5\n\n        2/1   2/2   2/3   2/4\n\n        3/1   3/2   3/3\n\n        4/1   4/2\n\n        5/1\n\n    * The function takes an integer 'n' and returns the 'n'th element in this sequence as a string in the form 'numerator/denominator'.\n    * Input: An integer 'n' (n < 20000).\n    * Output: A string representing the 'n'th element in the sequence.\n    * Examples:\n    * - Input: 3, Output: \"2/1\"\n    * - Input: 14, Output: \"2/4\"\n*/\n\n\nfunction findFractionalElement($n) ",
      "es": "<?php\n\n\n/**\n    * Encuentra el elemento fraccional en una secuencia dispuesta diagonalmente.\n    * En esta secuencia, las fracciones están dispuestas en un patrón diagonal. La primera fila contiene fracciones con el numerador 1 y denominadores crecientes. Cada fila subsiguiente incrementa el numerador y disminuye el denominador hasta que alcanza 1.\n    * Por ejemplo, la secuencia comienza con 1/1, 1/2, 2/1, 3/1, 2/2, ...\n        1/1   1/2   1/3   1/4   1/5\n\n        2/1   2/2   2/3   2/4\n\n        3/1   3/2   3/3\n\n        4/1   4/2\n\n        5/1\n\n    * La función toma un entero 'n' y devuelve el elemento 'n' en esta secuencia como una cadena en la forma 'numerador/denominador'.\n    * Entrada: Un entero 'n' (n < 20000).\n    * Salida: Una cadena que representa el elemento 'n' en la secuencia.\n    * Ejemplos:\n    * - Entrada: 3, Salida: \"2/1\"\n    * - Entrada: 14, Salida: \"2/4\"\n*/\n\n\nfunction findFractionalElement($n) ",
      "arb": "<?php\n\n\n/**\n    * يجد العنصر الكسري في تسلسل مرتب بشكل قطري.\n    * في هذا التسلسل، يتم ترتيب الكسور في نمط قطري. يحتوي الصف الأول على كسور مع البسط 1 والمقامات المتزايدة. كل صف لاحق يزيد البسط ويقلل المقام حتى يصل إلى 1.\n    * على سبيل المثال، يبدأ التسلسل بـ 1/1، 1/2، 2/1، 3/1، 2/2، ...\n        1/1   1/2   1/3   1/4   1/5\n\n        2/1   2/2   2/3   2/4\n\n        3/1   3/2   3/3\n\n        4/1   4/2\n\n        5/1\n\n    * تأخذ الدالة عددًا صحيحًا 'n' وتعيد العنصر 'n' في هذا التسلسل كـ سلسلة نصية في الشكل 'بسط/مقام'.\n    * المدخل: عدد صحيح 'n' (n < 20000).\n    * المخرج: سلسلة نصية تمثل العنصر 'n' في التسلسل.\n    * أمثلة:\n    * - المدخل: 3، المخرج: \"2/1\"\n    * - المدخل: 14، المخرج: \"2/4\"\n*/\n\n\nfunction findFractionalElement($n) ",
      "sw": "<?php\n\n\n/**\n    * Inapata kipengele cha sehemu katika mlolongo uliopangwa kwa diagonali.\n    * Katika mlolongo huu, sehemu zimepangwa kwa mtindo wa diagonali. Safu ya kwanza ina sehemu zenye numerator 1 na denominator zinazoongezeka. Kila safu inayofuata inaongeza numerator na kupunguza denominator hadi ifikie 1.\n    * Kwa mfano, mlolongo unaanza na 1/1, 1/2, 2/1, 3/1, 2/2, ...\n        1/1   1/2   1/3   1/4   1/5\n\n        2/1   2/2   2/3   2/4\n\n        3/1   3/2   3/3\n\n        4/1   4/2\n\n        5/1\n\n    * Kazi inachukua nambari nzima 'n' na inarudisha kipengele cha 'n' katika mlolongo huu kama kamba katika umbo la 'numerator/denominator'.\n    * Ingizo: Nambari nzima 'n' (n < 20000).\n    * Matokeo: Kamba inayowakilisha kipengele cha 'n' katika mlolongo.\n    * Mifano:\n    * - Ingizo: 3, Matokeo: \"2/1\"\n    * - Ingizo: 14, Matokeo: \"2/4\"\n*/\n\n\nfunction findFractionalElement($n) ",
      "tr": "<?php\n\n\n/**\n    * Diyagonal olarak düzenlenmiş bir dizideki kesirli elemanı bulur.\n    * Bu dizide, kesirler diyagonal bir desende düzenlenmiştir. İlk satır, payı 1 olan ve paydası artan kesirleri içerir. Her bir sonraki satır, payı artırır ve paydayı 1'e ulaşana kadar azaltır.\n    * Örneğin, dizi 1/1, 1/2, 2/1, 3/1, 2/2, ... ile başlar.\n        1/1   1/2   1/3   1/4   1/5\n\n        2/1   2/2   2/3   2/4\n\n        3/1   3/2   3/3\n\n        4/1   4/2\n\n        5/1\n\n    * Fonksiyon bir tamsayı 'n' alır ve bu dizideki 'n'inci elemanı 'pay/payda' şeklinde bir string olarak döndürür.\n    * Girdi: Bir tamsayı 'n' (n < 20000).\n    * Çıktı: Dizideki 'n'inci elemanı temsil eden bir string.\n    * Örnekler:\n    * - Girdi: 3, Çıktı: \"2/1\"\n    * - Girdi: 14, Çıktı: \"2/4\"\n*/\n\n\nfunction findFractionalElement($n) ",
      "vi": "<?php\n\n\n/**\n    * Tìm phần tử phân số trong một dãy sắp xếp theo đường chéo.\n    * Trong dãy này, các phân số được sắp xếp theo một mẫu đường chéo. Hàng đầu tiên chứa các phân số với tử số là 1 và mẫu số tăng dần. Mỗi hàng tiếp theo tăng tử số và giảm mẫu số cho đến khi đạt 1.\n    * Ví dụ, dãy bắt đầu với 1/1, 1/2, 2/1, 3/1, 2/2, ...\n        1/1   1/2   1/3   1/4   1/5\n\n        2/1   2/2   2/3   2/4\n\n        3/1   3/2   3/3\n\n        4/1   4/2\n\n        5/1\n\n    * Hàm nhận một số nguyên 'n' và trả về phần tử thứ 'n' trong dãy này dưới dạng chuỗi theo định dạng 'tử số/mẫu số'.\n    * Đầu vào: Một số nguyên 'n' (n < 20000).\n    * Đầu ra: Một chuỗi đại diện cho phần tử thứ 'n' trong dãy.\n    * Ví dụ:\n    * - Đầu vào: 3, Đầu ra: \"2/1\"\n    * - Đầu vào: 14, Đầu ra: \"2/4\"\n*/\n\n\nfunction findFractionalElement($n) "
    },
    "prompt_bertscore": {
      "es": "0.9829972393834135",
      "arb": "0.9814306415681914",
      "sw": "0.9654921425331899",
      "tr": "0.9798560985377278",
      "vi": "0.9742044683061422"
    },
    "canonical_solution": "{\n    // Find the diagonal this element is on\n    $d = 1;\n    while ($d * ($d + 1) / 2 < $n) {\n        $d++;\n    }\n\n    // Position within the diagonal\n    $p = $n - ($d * ($d - 1) / 2);\n\n    // Check if the diagonal is even or odd\n    if ($d % 2 == 0) {\n        // Even diagonal: numerator increases, denominator decreases\n        $numerator = $p;\n        $denominator = $d - $p + 1;\n    } else {\n        // Odd diagonal: numerator decreases, denominator increases\n        $numerator = $d - $p + 1;\n        $denominator = $p;\n    }\n\n    return \"$numerator/$denominator\";\n}",
    "instruction": {
      "en": "function findFractionalElement($n)\n{\n    // Find the diagonal this element is on\n    $d = 1;\n    while ($d * ($d + 1) / 2 < $n) {\n        $d++;\n    }\n\n    // Position within the diagonal\n    $p = $n - ($d * ($d - 1) / 2);\n\n    // Check if the diagonal is even or odd\n    if ($d % 2 == 0) {\n        // Even diagonal: numerator increases, denominator decreases\n        $numerator = $p;\n        $denominator = $d - $p + 1;\n    } else {\n        // Odd diagonal: numerator decreases, denominator increases\n        $numerator = $d - $p + 1;\n        $denominator = $p;\n    }\n\n    return \"$numerator/$denominator\";\n}\n\nProvide a concise natural language description (docstring) of the PHP code in English using at most 500 characters.",
      "es": "function findFractionalElement($n)\n{\n    // Find the diagonal this element is on\n    $d = 1;\n    while ($d * ($d + 1) / 2 < $n) {\n        $d++;\n    }\n\n    // Position within the diagonal\n    $p = $n - ($d * ($d - 1) / 2);\n\n    // Check if the diagonal is even or odd\n    if ($d % 2 == 0) {\n        // Even diagonal: numerator increases, denominator decreases\n        $numerator = $p;\n        $denominator = $d - $p + 1;\n    } else {\n        // Odd diagonal: numerator decreases, denominator increases\n        $numerator = $d - $p + 1;\n        $denominator = $p;\n    }\n\n    return \"$numerator/$denominator\";\n}\n\nProporcione una descripción concisa en lenguaje natural (docstring) del código PHP en español utilizando un máximo de 500 caracteres.",
      "arb": "function findFractionalElement($n)\n{\n    // Find the diagonal this element is on\n    $d = 1;\n    while ($d * ($d + 1) / 2 < $n) {\n        $d++;\n    }\n\n    // Position within the diagonal\n    $p = $n - ($d * ($d - 1) / 2);\n\n    // Check if the diagonal is even or odd\n    if ($d % 2 == 0) {\n        // Even diagonal: numerator increases, denominator decreases\n        $numerator = $p;\n        $denominator = $d - $p + 1;\n    } else {\n        // Odd diagonal: numerator decreases, denominator increases\n        $numerator = $d - $p + 1;\n        $denominator = $p;\n    }\n\n    return \"$numerator/$denominator\";\n}\n\nيرجى تقديم وصف موجز بلغة طبيعية (docstring) للكود PHP باللغة العربية الفصحى باستخدام 500 حرف كحد أقصى.",
      "sw": "function findFractionalElement($n)\n{\n    // Find the diagonal this element is on\n    $d = 1;\n    while ($d * ($d + 1) / 2 < $n) {\n        $d++;\n    }\n\n    // Position within the diagonal\n    $p = $n - ($d * ($d - 1) / 2);\n\n    // Check if the diagonal is even or odd\n    if ($d % 2 == 0) {\n        // Even diagonal: numerator increases, denominator decreases\n        $numerator = $p;\n        $denominator = $d - $p + 1;\n    } else {\n        // Odd diagonal: numerator decreases, denominator increases\n        $numerator = $d - $p + 1;\n        $denominator = $p;\n    }\n\n    return \"$numerator/$denominator\";\n}\n\nToa maelezo mafupi ya lugha ya asili (docstring) ya msimbo wa PHP kwa Kiswahili kwa kutumia herufi zisizozidi 500.",
      "tr": "function findFractionalElement($n)\n{\n    // Find the diagonal this element is on\n    $d = 1;\n    while ($d * ($d + 1) / 2 < $n) {\n        $d++;\n    }\n\n    // Position within the diagonal\n    $p = $n - ($d * ($d - 1) / 2);\n\n    // Check if the diagonal is even or odd\n    if ($d % 2 == 0) {\n        // Even diagonal: numerator increases, denominator decreases\n        $numerator = $p;\n        $denominator = $d - $p + 1;\n    } else {\n        // Odd diagonal: numerator decreases, denominator increases\n        $numerator = $d - $p + 1;\n        $denominator = $p;\n    }\n\n    return \"$numerator/$denominator\";\n}\n\nPHP kodunun işlevini açıklayan kısa bir doğal dil açıklaması (docstring) sağlayın. Açıklama, en fazla 500 karakter kullanılarak Türkçe olarak yazılmalıdır.",
      "vi": "function findFractionalElement($n)\n{\n    // Find the diagonal this element is on\n    $d = 1;\n    while ($d * ($d + 1) / 2 < $n) {\n        $d++;\n    }\n\n    // Position within the diagonal\n    $p = $n - ($d * ($d - 1) / 2);\n\n    // Check if the diagonal is even or odd\n    if ($d % 2 == 0) {\n        // Even diagonal: numerator increases, denominator decreases\n        $numerator = $p;\n        $denominator = $d - $p + 1;\n    } else {\n        // Odd diagonal: numerator decreases, denominator increases\n        $numerator = $d - $p + 1;\n        $denominator = $p;\n    }\n\n    return \"$numerator/$denominator\";\n}\n\nCung cấp mô tả ngắn gọn bằng ngôn ngữ tự nhiên (docstring) cho mã PHP bằng tiếng Việt với tối đa 500 ký tự."
    },
    "instruction_bertscore": {
      "es": "0.9687069752502395",
      "arb": "0.924580242951434",
      "sw": "0.91585798565943",
      "tr": "0.881863190466833",
      "vi": "0.9017250367880356"
    },
    "level": "",
    "test": "function main(){\n    assert(findFractionalElement(3) === \"2/1\");\n    assert(findFractionalElement(14) === \"2/4\");\n    assert(findFractionalElement(7) === \"1/4\");\n    assert(findFractionalElement(12345) === \"59/99\");\n    \n}\n\nmain();\n?>",
    "entry_point": "findFractionalElement",
    "signature": "function findFractionalElement($n)",
    "docstring": {
      "en": "Finds the fractional element in a diagonally arranged sequence.\nIn this sequence, fractions are arranged in a diagonal pattern. The first row contains fractions with the numerator 1 and increasing denominators. Each subsequent row increases the numerator and decreases the denominator until it reaches 1.\nFor example, the sequence starts with 1/1, 1/2, 2/1, 3/1, 2/2, ...\n1/1   1/2   1/3   1/4   1/5\n\n2/1   2/2   2/3   2/4\n\n3/1   3/2   3/3\n\n4/1   4/2\n\n5/1\n\nThe function takes an integer 'n' and returns the 'n'th element in this sequence as a string in the form 'numerator/denominator'.\nInput: An integer 'n' (n < 20000).\nOutput: A string representing the 'n'th element in the sequence.\nExamples:\n- Input: 3, Output: \"2/1\"\n- Input: 14, Output: \"2/4\"",
      "es": "Encuentra el elemento fraccionario en una secuencia dispuesta diagonalmente.\nEn esta secuencia, las fracciones están dispuestas en un patrón diagonal. La primera fila contiene fracciones con el numerador 1 y denominadores crecientes. Cada fila subsiguiente aumenta el numerador y disminuye el denominador hasta que llega a 1.\nPor ejemplo, la secuencia comienza con 1/1, 1/2, 2/1, 3/1, 2/2, ...\n1/1   1/2   1/3   1/4   1/5\n\n2/1   2/2   2/3   2/4\n\n3/1   3/2   3/3\n\n4/1   4/2\n\n5/1\n\nLa función toma un entero 'n' y devuelve el elemento 'n'-ésimo en esta secuencia como una cadena en la forma 'numerador/denominador'.\nEntrada: Un entero 'n' (n < 20000).\nSalida: Una cadena que representa el elemento 'n'-ésimo en la secuencia.\nEjemplos:\n- Entrada: 3, Salida: \"2/1\"\n- Entrada: 14, Salida: \"2/4\"",
      "arb": "يعثر على العنصر الكسري في تسلسل مرتب بشكل قطري.\nفي هذا التسلسل، يتم ترتيب الكسور في نمط قطري. يحتوي الصف الأول على كسور مع البسط 1 والمقامات المتزايدة. كل صف لاحق يزيد البسط ويقلل المقام حتى يصل إلى 1.\nعلى سبيل المثال، يبدأ التسلسل بـ 1/1، 1/2، 2/1، 3/1، 2/2، ...\n1/1   1/2   1/3   1/4   1/5\n\n2/1   2/2   2/3   2/4\n\n3/1   3/2   3/3\n\n4/1   4/2\n\n5/1\n\nتأخذ الدالة عددًا صحيحًا 'n' وتعيد العنصر 'n' في هذا التسلسل كـ سلسلة نصية في الشكل 'بسط/مقام'.\nالمدخل: عدد صحيح 'n' (n < 20000).\nالمخرج: سلسلة نصية تمثل العنصر 'n' في التسلسل.\nأمثلة:\n- المدخل: 3، المخرج: \"2/1\"\n- المدخل: 14، المخرج: \"2/4\"",
      "sw": "Inapata kipengele cha sehemu katika mlolongo uliopangwa kwa diagonal.\nKatika mlolongo huu, sehemu zimepangwa katika muundo wa diagonal. Safu ya kwanza ina sehemu zenye kigezo cha juu 1 na vigezo vya chini vinavyoongezeka. Kila safu inayofuata huongeza kigezo cha juu na kupunguza kigezo cha chini hadi ifikie 1.\nKwa mfano, mlolongo unaanza na 1/1, 1/2, 2/1, 3/1, 2/2, ...\n1/1   1/2   1/3   1/4   1/5\n\n2/1   2/2   2/3   2/4\n\n3/1   3/2   3/3\n\n4/1   4/2\n\n5/1\n\nKazi inachukua nambari nzima 'n' na inarudisha kipengele cha 'n' katika mlolongo huu kama kamba katika umbo la 'kigezo cha juu/kigezo cha chini'.\nIngizo: Nambari nzima 'n' (n < 20000).\nPato: Kamba inayowakilisha kipengele cha 'n' katika mlolongo.\nMifano:\n- Ingizo: 3, Pato: \"2/1\"\n- Ingizo: 14, Pato: \"2/4\"",
      "tr": "Diyagonal olarak düzenlenmiş bir dizide kesirli elemanı bulur.\nBu dizide, kesirler diyagonal bir desenle düzenlenmiştir. İlk satırda payı 1 olan ve paydaları artan kesirler bulunur. Her bir sonraki satır, payı artırır ve payda 1'e ulaşana kadar azaltır.\nÖrneğin, dizi 1/1, 1/2, 2/1, 3/1, 2/2, ... ile başlar.\n1/1   1/2   1/3   1/4   1/5\n\n2/1   2/2   2/3   2/4\n\n3/1   3/2   3/3\n\n4/1   4/2\n\n5/1\n\nFonksiyon bir tamsayı 'n' alır ve bu dizideki 'n'inci elemanı 'pay/payda' biçiminde bir string olarak döndürür.\nGirdi: Bir tamsayı 'n' (n < 20000).\nÇıktı: Dizideki 'n'inci elemanı temsil eden bir string.\nÖrnekler:\n- Girdi: 3, Çıktı: \"2/1\"\n- Girdi: 14, Çıktı: \"2/4\"",
      "vi": "Tìm phần tử phân số trong một dãy sắp xếp theo đường chéo.  \nTrong dãy này, các phân số được sắp xếp theo mẫu hình đường chéo. Hàng đầu tiên chứa các phân số với tử số là 1 và mẫu số tăng dần. Mỗi hàng tiếp theo tăng tử số và giảm mẫu số cho đến khi đạt 1.  \nVí dụ, dãy bắt đầu với 1/1, 1/2, 2/1, 3/1, 2/2, ...  \n1/1   1/2   1/3   1/4   1/5  \n\n2/1   2/2   2/3   2/4  \n\n3/1   3/2   3/3  \n\n4/1   4/2  \n\n5/1  \n\nHàm nhận một số nguyên 'n' và trả về phần tử thứ 'n' trong dãy này dưới dạng một chuỗi theo dạng 'tử số/mẫu số'.  \nĐầu vào: Một số nguyên 'n' (n < 20000).  \nĐầu ra: Một chuỗi đại diện cho phần tử thứ 'n' trong dãy.  \nVí dụ:  \n- Đầu vào: 3, Đầu ra: \"2/1\"  \n- Đầu vào: 14, Đầu ra: \"2/4\"  "
    },
    "docstring_bertscore": {
      "es": "0.9741270024575386",
      "arb": "0.9798415985199123",
      "sw": "0.9172398572202897",
      "tr": "0.9944057739485334",
      "vi": "0.9764553477840295"
    }
  },
  {
    "task_id": "PHP/13",
    "prompt": {
      "en": "<?php\n\n/**\n    * Calculates the monthly repayment amount for an equal principal repayment loan.\n    * In this repayment model, each month's repayment amount consists of two parts:\n    * - A constant principal payment, which is the total loan amount divided by the total number of months.\n    * - The interest payment, which is the outstanding loan amount multiplied by the monthly interest rate.\n    * Input: \n    * - $loanAmount (int): The total loan amount in ten-thousands.\n    * - $monthlyInterestRate (float): The monthly interest rate.\n    * - $totalMonths (int): The total number of months for loan repayment.\n    * Output: Returns the first month's repayment amount as an integer (in Yuan). Discard the decimal point and do not round\n    * Example: calculateMonthlyRepayment(500, 0.004, 360) should return 33889.\n*/\n\nfunction calculateMonthlyRepayment($loanAmount, $monthlyInterestRate, $totalMonths): int ",
      "es": "<?php\n\n/**\n    * Calcula el monto del pago mensual para un préstamo de reembolso de capital igual.\n    * En este modelo de reembolso, el monto del pago de cada mes consta de dos partes:\n    * - Un pago de capital constante, que es el monto total del préstamo dividido por el número total de meses.\n    * - El pago de intereses, que es el monto del préstamo pendiente multiplicado por la tasa de interés mensual.\n    * Entrada: \n    * - $loanAmount (int): El monto total del préstamo en decenas de miles.\n    * - $monthlyInterestRate (float): La tasa de interés mensual.\n    * - $totalMonths (int): El número total de meses para el reembolso del préstamo.\n    * Salida: Devuelve el monto del pago del primer mes como un entero (en Yuanes). Descartar el punto decimal y no redondear\n    * Ejemplo: calculateMonthlyRepayment(500, 0.004, 360) debería devolver 33889.\n*/\n\nfunction calculateMonthlyRepayment($loanAmount, $monthlyInterestRate, $totalMonths): int ",
      "arb": "<?php\n\n/**\n    * يحسب مبلغ السداد الشهري لقرض بسداد رأس المال المتساوي.\n    * في هذا النموذج من السداد، يتكون مبلغ السداد الشهري من جزئين:\n    * - دفعة رأس المال الثابتة، وهي إجمالي مبلغ القرض مقسومًا على إجمالي عدد الأشهر.\n    * - دفعة الفائدة، وهي مبلغ القرض المتبقي مضروبًا في معدل الفائدة الشهري.\n    * المدخلات:\n    * - $loanAmount (int): إجمالي مبلغ القرض بالآلاف.\n    * - $monthlyInterestRate (float): معدل الفائدة الشهري.\n    * - $totalMonths (int): إجمالي عدد الأشهر لسداد القرض.\n    * المخرجات: يعيد مبلغ السداد للشهر الأول كعدد صحيح (باليوان). تجاهل العلامة العشرية ولا تقم بالتقريب\n    * مثال: calculateMonthlyRepayment(500, 0.004, 360) يجب أن تعيد 33889.\n*/\n\nfunction calculateMonthlyRepayment($loanAmount, $monthlyInterestRate, $totalMonths): int ",
      "sw": "<?php\n\n/**\n    * Inakokotoa kiasi cha malipo ya kila mwezi kwa mkopo wa kulipa kwa usawa wa mtaji.\n    * Katika mfano huu wa ulipaji, kiasi cha malipo ya kila mwezi kinajumuisha sehemu mbili:\n    * - Malipo ya mtaji ya kudumu, ambayo ni jumla ya kiasi cha mkopo kilichogawanywa na jumla ya idadi ya miezi.\n    * - Malipo ya riba, ambayo ni kiasi cha mkopo kilichobaki kinachozidishwa na kiwango cha riba cha kila mwezi.\n    * Ingizo: \n    * - $loanAmount (int): Jumla ya kiasi cha mkopo katika makumi ya maelfu.\n    * - $monthlyInterestRate (float): Kiwango cha riba cha kila mwezi.\n    * - $totalMonths (int): Jumla ya idadi ya miezi ya ulipaji wa mkopo.\n    * Tokeo: Inarudisha kiasi cha malipo ya mwezi wa kwanza kama nambari kamili (katika Yuan). Puuza nukta ya desimali na usipandishe\n    * Mfano: calculateMonthlyRepayment(500, 0.004, 360) inapaswa kurudisha 33889.\n*/\n\nfunction calculateMonthlyRepayment($loanAmount, $monthlyInterestRate, $totalMonths): int ",
      "tr": "<?php\n\n/**\n    * Eşit anapara geri ödemeli bir kredi için aylık geri ödeme tutarını hesaplar.\n    * Bu geri ödeme modelinde, her ayın geri ödeme tutarı iki bölümden oluşur:\n    * - Sabit bir anapara ödemesi, bu toplam kredi tutarının toplam ay sayısına bölünmesiyle elde edilir.\n    * - Faiz ödemesi, kalan kredi tutarının aylık faiz oranı ile çarpılmasıyla elde edilir.\n    * Girdi: \n    * - $loanAmount (int): On binler cinsinden toplam kredi tutarı.\n    * - $monthlyInterestRate (float): Aylık faiz oranı.\n    * - $totalMonths (int): Kredi geri ödemesi için toplam ay sayısı.\n    * Çıktı: İlk ayın geri ödeme tutarını bir tamsayı olarak (Yuan cinsinden) döndürür. Ondalık noktayı atın ve yuvarlamayın\n    * Örnek: calculateMonthlyRepayment(500, 0.004, 360) 33889 döndürmelidir.\n*/\n\nfunction calculateMonthlyRepayment($loanAmount, $monthlyInterestRate, $totalMonths): int ",
      "vi": "<?php\n\n/**\n    * Tính toán số tiền trả hàng tháng cho khoản vay trả góp gốc đều.\n    * Trong mô hình trả nợ này, số tiền trả hàng tháng bao gồm hai phần:\n    * - Một khoản trả gốc cố định, là tổng số tiền vay chia cho tổng số tháng.\n    * - Khoản trả lãi, là số tiền vay còn lại nhân với lãi suất hàng tháng.\n    * Đầu vào:\n    * - $loanAmount (int): Tổng số tiền vay tính bằng hàng chục nghìn.\n    * - $monthlyInterestRate (float): Lãi suất hàng tháng.\n    * - $totalMonths (int): Tổng số tháng để trả nợ vay.\n    * Đầu ra: Trả về số tiền trả tháng đầu tiên dưới dạng số nguyên (tính bằng Nhân dân tệ). Bỏ phần thập phân và không làm tròn\n    * Ví dụ: calculateMonthlyRepayment(500, 0.004, 360) sẽ trả về 33889.\n*/\n\nfunction calculateMonthlyRepayment($loanAmount, $monthlyInterestRate, $totalMonths): int "
    },
    "prompt_bertscore": {
      "es": "0.9763909915405742",
      "arb": "0.9606884653982422",
      "sw": "0.9532241343093321",
      "tr": "0.9513832279379008",
      "vi": "0.9446198634636628"
    },
    "canonical_solution": "{\n    $principalPayment = ($loanAmount * 10000) / $totalMonths;\n    $interestPayment = $loanAmount * 10000 * $monthlyInterestRate;\n    return (int) $principalPayment + $interestPayment;\n}",
    "instruction": {
      "en": "function calculateMonthlyRepayment($loanAmount, $monthlyInterestRate, $totalMonths): int\n{\n    $principalPayment = ($loanAmount * 10000) / $totalMonths;\n    $interestPayment = $loanAmount * 10000 * $monthlyInterestRate;\n    return (int) $principalPayment + $interestPayment;\n}\n\nProvide a concise natural language description (docstring) of the PHP code in English using at most 500 characters.",
      "es": "function calculateMonthlyRepayment($loanAmount, $monthlyInterestRate, $totalMonths): int\n{\n    $principalPayment = ($loanAmount * 10000) / $totalMonths;\n    $interestPayment = $loanAmount * 10000 * $monthlyInterestRate;\n    return (int) $principalPayment + $interestPayment;\n}\n\nProporcione una descripción concisa en lenguaje natural (docstring) del código PHP en español utilizando como máximo 500 caracteres.",
      "arb": "function calculateMonthlyRepayment($loanAmount, $monthlyInterestRate, $totalMonths): int\n{\n    $principalPayment = ($loanAmount * 10000) / $totalMonths;\n    $interestPayment = $loanAmount * 10000 * $monthlyInterestRate;\n    return (int) $principalPayment + $interestPayment;\n}\n\nيرجى تقديم وصف موجز بلغة طبيعية (docstring) لشيفرة PHP باللغة العربية الفصحى باستخدام 500 حرف كحد أقصى.",
      "sw": "function calculateMonthlyRepayment($loanAmount, $monthlyInterestRate, $totalMonths): int\n{\n    $principalPayment = ($loanAmount * 10000) / $totalMonths;\n    $interestPayment = $loanAmount * 10000 * $monthlyInterestRate;\n    return (int) $principalPayment + $interestPayment;\n}\n\nToa maelezo mafupi ya lugha ya asili (docstring) ya msimbo wa PHP kwa Kiswahili kwa kutumia herufi zisizozidi 500.",
      "tr": "function calculateMonthlyRepayment($loanAmount, $monthlyInterestRate, $totalMonths): int\n{\n    $principalPayment = ($loanAmount * 10000) / $totalMonths;\n    $interestPayment = $loanAmount * 10000 * $monthlyInterestRate;\n    return (int) $principalPayment + $interestPayment;\n}\n\nPHP kodunun işlevselliğini açıklayan kısa bir doğal dil tanımı (docstring) sağlayın. Açıklama Türkçe olacak ve en fazla 500 karakter kullanılacaktır.",
      "vi": "function calculateMonthlyRepayment($loanAmount, $monthlyInterestRate, $totalMonths): int\n{\n    $principalPayment = ($loanAmount * 10000) / $totalMonths;\n    $interestPayment = $loanAmount * 10000 * $monthlyInterestRate;\n    return (int) $principalPayment + $interestPayment;\n}\n\nCung cấp mô tả ngắn gọn bằng ngôn ngữ tự nhiên (docstring) cho mã PHP bằng tiếng Việt, sử dụng tối đa 500 ký tự."
    },
    "instruction_bertscore": {
      "es": "0.9687069752502395",
      "arb": "0.9079099895927",
      "sw": "0.91585798565943",
      "tr": "0.8783696793251914",
      "vi": "0.9202302376067699"
    },
    "level": "",
    "test": "function main(){\n    assert(calculateMonthlyRepayment(500, 0.004, 360) === 33888);\n    assert(calculateMonthlyRepayment(300, 0.005, 180) === 31666); // Example test case\n\n}\n\nmain();\n?>",
    "entry_point": "calculateMonthlyRepayment",
    "signature": "function calculateMonthlyRepayment($loanAmount, $monthlyInterestRate, $totalMonths): int",
    "docstring": {
      "en": "Calculates the monthly repayment amount for an equal principal repayment loan.\nIn this repayment model, each month's repayment amount consists of two parts:\n- A constant principal payment, which is the total loan amount divided by the total number of months.\n- The interest payment, which is the outstanding loan amount multiplied by the monthly interest rate.\nInput:\n- $loanAmount (int): The total loan amount in ten-thousands.\n- $monthlyInterestRate (float): The monthly interest rate.\n- $totalMonths (int): The total number of months for loan repayment.\nOutput: Returns the first month's repayment amount as an integer (in Yuan). Discard the decimal point and do not round\nExample: calculateMonthlyRepayment(500, 0.004, 360) should return 33889.",
      "es": "Calcula el monto de reembolso mensual para un préstamo de amortización de principal igual. En este modelo de reembolso, el monto de reembolso de cada mes consta de dos partes:\n- Un pago de principal constante, que es el monto total del préstamo dividido por el número total de meses.\n- El pago de intereses, que es el monto del préstamo pendiente multiplicado por la tasa de interés mensual.\nEntrada:\n- $loanAmount (int): El monto total del préstamo en decenas de miles.\n- $monthlyInterestRate (float): La tasa de interés mensual.\n- $totalMonths (int): El número total de meses para el reembolso del préstamo.\nSalida: Devuelve el monto del reembolso del primer mes como un entero (en Yuanes). Descartar el punto decimal y no redondear.\nEjemplo: calculateMonthlyRepayment(500, 0.004, 360) debería devolver 33889.",
      "arb": "يحسب مبلغ السداد الشهري لقرض سداد رأس المال المتساوي.  \nفي نموذج السداد هذا، يتكون مبلغ السداد الشهري من جزئين:  \n- دفعة رأس مال ثابتة، وهي إجمالي مبلغ القرض مقسومًا على إجمالي عدد الأشهر.  \n- دفعة الفائدة، وهي مبلغ القرض المتبقي مضروبًا في معدل الفائدة الشهري.  \nالمدخلات:  \n- $loanAmount (int): إجمالي مبلغ القرض بعشرات الآلاف.  \n- $monthlyInterestRate (float): معدل الفائدة الشهري.  \n- $totalMonths (int): إجمالي عدد الأشهر لسداد القرض.  \nالمخرجات: يعيد مبلغ السداد للشهر الأول كعدد صحيح (باليوان). تجاهل الفاصلة العشرية ولا تقم بالتقريب  \nمثال: calculateMonthlyRepayment(500, 0.004, 360) يجب أن يعيد 33889.",
      "sw": "Hesabu kiasi cha malipo ya kila mwezi kwa mkopo wa malipo ya mtaji sawa.\nKatika mfano huu wa malipo, kiasi cha malipo ya kila mwezi kinajumuisha sehemu mbili:\n- Malipo ya mtaji ya kudumu, ambayo ni jumla ya kiasi cha mkopo kilichogawanywa na jumla ya idadi ya miezi.\n- Malipo ya riba, ambayo ni kiasi cha mkopo kilichobaki kikiwa kimezidishwa na kiwango cha riba cha kila mwezi.\nIngizo:\n- $loanAmount (int): Jumla ya kiasi cha mkopo katika makumi ya maelfu.\n- $monthlyInterestRate (float): Kiwango cha riba cha kila mwezi.\n- $totalMonths (int): Jumla ya idadi ya miezi kwa ulipaji wa mkopo.\nPato: Inarudisha kiasi cha malipo ya mwezi wa kwanza kama nambari nzima (katika Yuan). Puuza nukta ya desimali na usikadirie\nMfano: calculateMonthlyRepayment(500, 0.004, 360) inapaswa kurudisha 33889.",
      "tr": "Aylık eşit anapara ödemeli bir kredi için aylık geri ödeme tutarını hesaplar.\nBu geri ödeme modelinde, her ayın geri ödeme tutarı iki bölümden oluşur:\n- Sabit bir anapara ödemesi, bu toplam kredi tutarının toplam ay sayısına bölünmesiyle elde edilir.\n- Faiz ödemesi, kalan kredi tutarının aylık faiz oranı ile çarpılmasıyla elde edilir.\nGirdi:\n- $loanAmount (int): On binler cinsinden toplam kredi tutarı.\n- $monthlyInterestRate (float): Aylık faiz oranı.\n- $totalMonths (int): Kredi geri ödemesi için toplam ay sayısı.\nÇıktı: İlk ayın geri ödeme tutarını tam sayı olarak (Yuan cinsinden) döndürür. Ondalık kısmı atın ve yuvarlamayın.\nÖrnek: calculateMonthlyRepayment(500, 0.004, 360) 33889 döndürmelidir.",
      "vi": "Tính toán số tiền trả hàng tháng cho khoản vay trả gốc đều.  \nTrong mô hình trả nợ này, số tiền trả hàng tháng bao gồm hai phần:  \n- Một khoản trả gốc cố định, là tổng số tiền vay chia cho tổng số tháng.  \n- Khoản trả lãi, là số tiền vay còn lại nhân với lãi suất hàng tháng.  \nĐầu vào:  \n- $loanAmount (int): Tổng số tiền vay tính bằng mười nghìn.  \n- $monthlyInterestRate (float): Lãi suất hàng tháng.  \n- $totalMonths (int): Tổng số tháng để trả nợ vay.  \nĐầu ra: Trả về số tiền trả tháng đầu tiên dưới dạng số nguyên (tính bằng Nhân dân tệ). Bỏ phần thập phân và không làm tròn  \nVí dụ: calculateMonthlyRepayment(500, 0.004, 360) sẽ trả về 33889."
    },
    "docstring_bertscore": {
      "es": "0.9756077919481536",
      "arb": "0.9552283148539741",
      "sw": "0.9426424980204605",
      "tr": "0.9394922201772472",
      "vi": "0.9483120049863393"
    }
  },
  {
    "task_id": "PHP/14",
    "prompt": {
      "en": "<?php\n/**\n * Converts a decimal number into a sum of powers of 2.\n * This function is useful for understanding the binary representation of a decimal number.\n * It breaks down the number into a sum of powers of 2, which are easier to understand and work with,\n * especially in contexts where binary calculations are frequent.\n * \n * For example:\n * - Input: 7\n * - Output: \"7=4+2+1\"\n * - Input: 43\n * - Output: \"43=32+8+2+1\"\n * \n * Input: A single integer ($number), where 0 < $number < 1000000.\n * Output: A string representing the equation of the sum of powers of 2 that equals the input number.\n */\n\nfunction decimalToBinarySum($number) ",
      "es": "<?php\n/**\n * Convierte un número decimal en una suma de potencias de 2.\n * Esta función es útil para entender la representación binaria de un número decimal.\n * Descompone el número en una suma de potencias de 2, que son más fáciles de entender y manejar,\n * especialmente en contextos donde los cálculos binarios son frecuentes.\n * \n * Por ejemplo:\n * - Entrada: 7\n * - Salida: \"7=4+2+1\"\n * - Entrada: 43\n * - Salida: \"43=32+8+2+1\"\n * \n * Entrada: Un solo entero ($number), donde 0 < $number < 1000000.\n * Salida: Una cadena que representa la ecuación de la suma de potencias de 2 que es igual al número de entrada.\n */\n\nfunction decimalToBinarySum($number) ",
      "arb": "<?php\n/**\n * يحول رقم عشري إلى مجموع قوى العدد 2.\n * هذه الدالة مفيدة لفهم التمثيل الثنائي لرقم عشري.\n * تقوم بتفكيك الرقم إلى مجموع قوى العدد 2، مما يسهل فهمه والعمل معه،\n * خاصة في السياقات التي تكون فيها الحسابات الثنائية متكررة.\n * \n * على سبيل المثال:\n * - المدخل: 7\n * - المخرج: \"7=4+2+1\"\n * - المدخل: 43\n * - المخرج: \"43=32+8+2+1\"\n * \n * المدخل: عدد صحيح واحد ($number)، حيث 0 < $number < 1000000.\n * المخرج: سلسلة نصية تمثل معادلة مجموع قوى العدد 2 التي تساوي الرقم المدخل.\n */\n\nfunction decimalToBinarySum($number) ",
      "sw": "<?php\n/**\n * Hubadilisha nambari ya desimali kuwa jumla ya nguvu za 2.\n * Kazi hii ni muhimu kwa kuelewa uwakilishi wa binary wa nambari ya desimali.\n * Inavunja nambari kuwa jumla ya nguvu za 2, ambazo ni rahisi kuelewa na kufanya kazi nazo,\n * hasa katika muktadha ambapo mahesabu ya binary ni ya mara kwa mara.\n * \n * Kwa mfano:\n * - Ingizo: 7\n * - Matokeo: \"7=4+2+1\"\n * - Ingizo: 43\n * - Matokeo: \"43=32+8+2+1\"\n * \n * Ingizo: Nambari moja ($number), ambapo 0 < $number < 1000000.\n * Matokeo: Mstari wa maandishi unaowakilisha mlinganyo wa jumla ya nguvu za 2 inayolingana na nambari ya ingizo.\n */\n\nfunction decimalToBinarySum($number) ",
      "tr": "<?php\n/**\n * Ondalık bir sayıyı 2'nin kuvvetlerinin toplamına dönüştürür.\n * Bu fonksiyon, ondalık bir sayının ikili gösterimini anlamak için kullanışlıdır.\n * Sayıyı, anlaması ve çalışması daha kolay olan 2'nin kuvvetlerinin toplamına ayırır,\n * özellikle ikili hesaplamaların sık olduğu bağlamlarda.\n * \n * Örneğin:\n * - Girdi: 7\n * - Çıktı: \"7=4+2+1\"\n * - Girdi: 43\n * - Çıktı: \"43=32+8+2+1\"\n * \n * Girdi: Tek bir tamsayı ($number), burada 0 < $number < 1000000.\n * Çıktı: Girdi sayısına eşit olan 2'nin kuvvetlerinin toplamının denklemini temsil eden bir dize.\n */\n\nfunction decimalToBinarySum($number) ",
      "vi": "<?php\n/**\n * Chuyển đổi một số thập phân thành tổng của các lũy thừa của 2.\n * Hàm này hữu ích để hiểu cách biểu diễn nhị phân của một số thập phân.\n * Nó phân tích số thành tổng của các lũy thừa của 2, dễ hiểu và làm việc hơn,\n * đặc biệt trong các ngữ cảnh mà tính toán nhị phân thường xuyên xảy ra.\n * \n * Ví dụ:\n * - Đầu vào: 7\n * - Đầu ra: \"7=4+2+1\"\n * - Đầu vào: 43\n * - Đầu ra: \"43=32+8+2+1\"\n * \n * Đầu vào: Một số nguyên ($number), nơi 0 < $number < 1000000.\n * Đầu ra: Một chuỗi đại diện cho phương trình của tổng các lũy thừa của 2 bằng với số đầu vào.\n */\n\nfunction decimalToBinarySum($number) "
    },
    "prompt_bertscore": {
      "es": "0.9924460866092432",
      "arb": "0.9894187609718905",
      "sw": "0.9726422403593028",
      "tr": "0.9880637045124705",
      "vi": "0.9704992171783173"
    },
    "canonical_solution": "{\n    $result = $number . \"=\";\n    $power = 0;\n\n    while ((1 << $power) <= $number) {\n        $power++;\n    }\n\n    while ($number > 0) {\n        $power--;\n        $currentPowerOfTwo = 1 << $power;\n        if ($currentPowerOfTwo <= $number) {\n            $number -= $currentPowerOfTwo;\n            $result .= $currentPowerOfTwo . \"+\";\n        }\n    }\n\n    return rtrim($result, \"+\");\n}",
    "instruction": {
      "en": "function decimalToBinarySum($number)\n{\n    $result = $number . \"=\";\n    $power = 0;\n\n    while ((1 << $power) <= $number) {\n        $power++;\n    }\n\n    while ($number > 0) {\n        $power--;\n        $currentPowerOfTwo = 1 << $power;\n        if ($currentPowerOfTwo <= $number) {\n            $number -= $currentPowerOfTwo;\n            $result .= $currentPowerOfTwo . \"+\";\n        }\n    }\n\n    return rtrim($result, \"+\");\n}\n\nProvide a concise natural language description (docstring) of the PHP code in English using at most 500 characters.",
      "es": "function decimalToBinarySum($number)\n{\n    $result = $number . \"=\";\n    $power = 0;\n\n    while ((1 << $power) <= $number) {\n        $power++;\n    }\n\n    while ($number > 0) {\n        $power--;\n        $currentPowerOfTwo = 1 << $power;\n        if ($currentPowerOfTwo <= $number) {\n            $number -= $currentPowerOfTwo;\n            $result .= $currentPowerOfTwo . \"+\";\n        }\n    }\n\n    return rtrim($result, \"+\");\n}\n\nProporcione una descripción concisa en lenguaje natural (docstring) del código PHP en español utilizando un máximo de 500 caracteres.",
      "arb": "function decimalToBinarySum($number)\n{\n    $result = $number . \"=\";\n    $power = 0;\n\n    while ((1 << $power) <= $number) {\n        $power++;\n    }\n\n    while ($number > 0) {\n        $power--;\n        $currentPowerOfTwo = 1 << $power;\n        if ($currentPowerOfTwo <= $number) {\n            $number -= $currentPowerOfTwo;\n            $result .= $currentPowerOfTwo . \"+\";\n        }\n    }\n\n    return rtrim($result, \"+\");\n}\n\nيرجى تقديم وصف موجز بلغة طبيعية (docstring) لشيفرة PHP باللغة العربية الفصحى باستخدام 500 حرف كحد أقصى.",
      "sw": "function decimalToBinarySum($number)\n{\n    $result = $number . \"=\";\n    $power = 0;\n\n    while ((1 << $power) <= $number) {\n        $power++;\n    }\n\n    while ($number > 0) {\n        $power--;\n        $currentPowerOfTwo = 1 << $power;\n        if ($currentPowerOfTwo <= $number) {\n            $number -= $currentPowerOfTwo;\n            $result .= $currentPowerOfTwo . \"+\";\n        }\n    }\n\n    return rtrim($result, \"+\");\n}\n\nToa maelezo mafupi ya lugha asilia (docstring) ya msimbo wa PHP kwa Kiswahili kwa kutumia herufi zisizozidi 500.",
      "tr": "function decimalToBinarySum($number)\n{\n    $result = $number . \"=\";\n    $power = 0;\n\n    while ((1 << $power) <= $number) {\n        $power++;\n    }\n\n    while ($number > 0) {\n        $power--;\n        $currentPowerOfTwo = 1 << $power;\n        if ($currentPowerOfTwo <= $number) {\n            $number -= $currentPowerOfTwo;\n            $result .= $currentPowerOfTwo . \"+\";\n        }\n    }\n\n    return rtrim($result, \"+\");\n}\n\nPHP kodunun işlevini açıklayan kısa bir doğal dil tanımı (docstring) sağlayın. Açıklama Türkçe olmalı ve en fazla 500 karakter kullanılmalıdır.",
      "vi": "function decimalToBinarySum($number)\n{\n    $result = $number . \"=\";\n    $power = 0;\n\n    while ((1 << $power) <= $number) {\n        $power++;\n    }\n\n    while ($number > 0) {\n        $power--;\n        $currentPowerOfTwo = 1 << $power;\n        if ($currentPowerOfTwo <= $number) {\n            $number -= $currentPowerOfTwo;\n            $result .= $currentPowerOfTwo . \"+\";\n        }\n    }\n\n    return rtrim($result, \"+\");\n}\n\nCung cấp mô tả ngắn gọn bằng ngôn ngữ tự nhiên (docstring) cho mã PHP bằng tiếng Việt với tối đa 500 ký tự."
    },
    "instruction_bertscore": {
      "es": "0.9687069752502395",
      "arb": "0.924580242951434",
      "sw": "0.9428367585331127",
      "tr": "0.8772112669429959",
      "vi": "0.9017250367880356"
    },
    "level": "",
    "test": "function main(){\n    assert(decimalToBinarySum(7) === \"7=4+2+1\");\n    assert(decimalToBinarySum(43) === \"43=32+8+2+1\");\n    assert(decimalToBinarySum(15) === \"15=8+4+2+1\");\n    assert(decimalToBinarySum(1) === \"1=1\");\n    assert(decimalToBinarySum(32) === \"32=32\");\n    \n}\n\nmain();\n?>",
    "entry_point": "decimalToBinarySum",
    "signature": "function decimalToBinarySum($number)",
    "docstring": {
      "en": "Converts a decimal number into a sum of powers of 2.\nThis function is useful for understanding the binary representation of a decimal number.\nIt breaks down the number into a sum of powers of 2, which are easier to understand and work with,\nespecially in contexts where binary calculations are frequent.\n\nFor example:\n- Input: 7\n- Output: \"7=4+2+1\"\n- Input: 43\n- Output: \"43=32+8+2+1\"\n\nInput: A single integer ($number), where 0 < $number < 1000000.\nOutput: A string representing the equation of the sum of powers of 2 that equals the input number.",
      "es": "Convierte un número decimal en una suma de potencias de 2.  \nEsta función es útil para entender la representación binaria de un número decimal.  \nDescompone el número en una suma de potencias de 2, que son más fáciles de entender y trabajar,  \nespecialmente en contextos donde los cálculos binarios son frecuentes.\n\nPor ejemplo:  \n- Entrada: 7  \n- Salida: \"7=4+2+1\"  \n- Entrada: 43  \n- Salida: \"43=32+8+2+1\"\n\nEntrada: Un solo entero ($number), donde 0 < $number < 1000000.  \nSalida: Una cadena que representa la ecuación de la suma de potencias de 2 que es igual al número de entrada.",
      "arb": "تحول رقم عشري إلى مجموع قوى 2.  \nهذه الدالة مفيدة لفهم التمثيل الثنائي لرقم عشري.  \nتقوم بتفكيك الرقم إلى مجموع قوى 2، وهو ما يكون أسهل للفهم والعمل معه،  \nخاصة في السياقات التي تكون فيها الحسابات الثنائية متكررة.\n\nعلى سبيل المثال:  \n- المدخل: 7  \n- المخرج: \"7=4+2+1\"  \n- المدخل: 43  \n- المخرج: \"43=32+8+2+1\"  \n\nالمدخل: عدد صحيح واحد ($number)، حيث 0 < $number < 1000000.  \nالمخرج: سلسلة نصية تمثل معادلة مجموع قوى 2 التي تساوي الرقم المدخل.",
      "sw": "Inabadilisha nambari ya desimali kuwa jumla ya nguvu za 2.  \nKazi hii ni muhimu kwa kuelewa uwakilishi wa nambari ya desimali katika mfumo wa binary.  \nInavunja nambari kuwa jumla ya nguvu za 2, ambazo ni rahisi kuelewa na kufanya kazi nazo,  \nhasa katika muktadha ambapo mahesabu ya binary ni ya mara kwa mara.  \n\nKwa mfano:  \n- Ingizo: 7  \n- Matokeo: \"7=4+2+1\"  \n- Ingizo: 43  \n- Matokeo: \"43=32+8+2+1\"  \n\nIngizo: Nambari moja ($number), ambapo 0 < $number < 1000000.  \nMatokeo: Mstari wa maandishi unaowakilisha mlinganyo wa jumla ya nguvu za 2 inayolingana na nambari ya ingizo.",
      "tr": "Onluk tabandaki bir sayıyı 2'nin kuvvetlerinin toplamına dönüştürür.\nBu fonksiyon, bir onluk tabanlı sayının ikili gösterimini anlamak için faydalıdır.\nSayının, özellikle ikili hesaplamaların sık olduğu bağlamlarda anlaması ve çalışması daha kolay olan 2'nin kuvvetlerinin toplamına ayrılmasını sağlar.\n\nÖrneğin:\n- Girdi: 7\n- Çıktı: \"7=4+2+1\"\n- Girdi: 43\n- Çıktı: \"43=32+8+2+1\"\n\nGirdi: 0 < $number < 1000000 koşulunu sağlayan tek bir tamsayı ($number).\nÇıktı: Girdi sayısına eşit olan 2'nin kuvvetlerinin toplamının denklemini temsil eden bir dize.",
      "vi": "Chuyển đổi một số thập phân thành tổng của các lũy thừa của 2.  \nHàm này hữu ích để hiểu biểu diễn nhị phân của một số thập phân.  \nNó phân tích số thành tổng của các lũy thừa của 2, dễ hiểu và làm việc hơn,  \nđặc biệt trong các ngữ cảnh mà tính toán nhị phân thường xuyên xảy ra.  \n\nVí dụ:  \n- Đầu vào: 7  \n- Đầu ra: \"7=4+2+1\"  \n- Đầu vào: 43  \n- Đầu ra: \"43=32+8+2+1\"  \n\nĐầu vào: Một số nguyên duy nhất ($number), nơi 0 < $number < 1000000.  \nĐầu ra: Một chuỗi đại diện cho phương trình của tổng các lũy thừa của 2 bằng với số đầu vào.  "
    },
    "docstring_bertscore": {
      "es": "1",
      "arb": "0.9838144047709911",
      "sw": "0.9627385295609032",
      "tr": "0.9650833612090202",
      "vi": "0.9681329334490487"
    }
  },
  {
    "task_id": "PHP/15",
    "prompt": {
      "en": "<?php\n\n\n/**\n * Finds the rectangle with the largest area that includes a given point.\n * In this task, we are given a list of rectangles, each defined by two opposite corner points,\n * and a point referred to as the \"needle\". The rectangles' sides are parallel to the coordinate axes.\n * The goal is to find the rectangle with the maximum area that contains the needle (including its boundary).\n * Input: An array of rectangles (each rectangle is an array of two points [x1, y1, x2, y2]),\n *        and a needle point [x, y].\n * Output: Returns the index (1-based) of the rectangle with the largest area that contains the needle.\n * Example: For rectangles [[1,1,4,4], [2,2,6,6]] and needle point [3,3],\n *          the function should return 2, as the second rectangle is larger and contains the needle.\n */\n\n\nfunction findMaxAreaRectangle($rectangles, $needle)",
      "es": "<?php\n\n\n/**\n * Encuentra el rectángulo con el área más grande que incluye un punto dado.\n * En esta tarea, se nos da una lista de rectángulos, cada uno definido por dos puntos de esquina opuestos,\n * y un punto referido como la \"aguja\". Los lados de los rectángulos son paralelos a los ejes de coordenadas.\n * El objetivo es encontrar el rectángulo con el área máxima que contiene la aguja (incluyendo su límite).\n * Entrada: Un arreglo de rectángulos (cada rectángulo es un arreglo de dos puntos [x1, y1, x2, y2]),\n *          y un punto aguja [x, y].\n * Salida: Devuelve el índice (basado en 1) del rectángulo con el área más grande que contiene la aguja.\n * Ejemplo: Para los rectángulos [[1,1,4,4], [2,2,6,6]] y el punto aguja [3,3],\n *          la función debería devolver 2, ya que el segundo rectángulo es más grande y contiene la aguja.\n */\n\n\nfunction findMaxAreaRectangle($rectangles, $needle)",
      "arb": "<?php\n\n\n/**\n * يجد المستطيل ذو المساحة الأكبر الذي يشمل نقطة معينة.\n * في هذه المهمة، يتم إعطاؤنا قائمة من المستطيلات، كل منها معرف بنقطتين متقابلتين،\n * ونقطة يشار إليها باسم \"الإبرة\". تكون جوانب المستطيلات موازية لمحاور الإحداثيات.\n * الهدف هو العثور على المستطيل ذو المساحة القصوى الذي يحتوي على الإبرة (بما في ذلك حدوده).\n * المدخلات: مصفوفة من المستطيلات (كل مستطيل هو مصفوفة من نقطتين [x1, y1, x2, y2]),\n *          ونقطة الإبرة [x, y].\n * المخرجات: يعيد الفهرس (مبني على 1) للمستطيل ذو المساحة الأكبر الذي يحتوي على الإبرة.\n * مثال: للمستطيلات [[1,1,4,4], [2,2,6,6]] ونقطة الإبرة [3,3],\n *        يجب أن تعيد الدالة 2، حيث أن المستطيل الثاني أكبر ويحتوي على الإبرة.\n */\n\n\nfunction findMaxAreaRectangle($rectangles, $needle)",
      "sw": "<?php\n\n\n/**\n * Inapata mstatili wenye eneo kubwa zaidi ambalo linajumuisha nukta fulani.\n * Katika kazi hii, tunapewa orodha ya mstatili, kila moja ikifafanuliwa na pointi mbili za pembe zilizokinzana,\n * na nukta inayorejelewa kama \"sindano\". Upande wa mstatili ni sambamba na mhimili wa kuratibu.\n * Lengo ni kupata mstatili wenye eneo kubwa zaidi ambalo linajumuisha sindano (ikiwemo mpaka wake).\n * Ingizo: Safu ya mstatili (kila mstatili ni safu ya pointi mbili [x1, y1, x2, y2]),\n *        na nukta ya sindano [x, y].\n * Tokeo: Inarejesha faharasa (inayoanza na 1) ya mstatili wenye eneo kubwa zaidi ambalo linajumuisha sindano.\n * Mfano: Kwa mstatili [[1,1,4,4], [2,2,6,6]] na nukta ya sindano [3,3],\n *          kazi inapaswa kurejesha 2, kwani mstatili wa pili ni mkubwa zaidi na unajumuisha sindano.\n */\n\n\nfunction findMaxAreaRectangle($rectangles, $needle)",
      "tr": "<?php\n\n\n/**\n * Belirli bir noktayı içeren en büyük alana sahip dikdörtgeni bulur.\n * Bu görevde, her biri iki zıt köşe noktası ile tanımlanan bir dizi dikdörtgen\n * ve \"iğne\" olarak adlandırılan bir nokta verilmektedir. Dikdörtgenlerin kenarları koordinat eksenlerine paraleldir.\n * Amaç, iğneyi içeren (sınırı dahil) maksimum alana sahip dikdörtgeni bulmaktır.\n * Girdi: Dikdörtgenlerin bir dizisi (her dikdörtgen iki noktadan oluşan bir dizi [x1, y1, x2, y2]),\n *        ve bir iğne noktası [x, y].\n * Çıktı: İğneyi içeren en büyük alana sahip dikdörtgenin indeksini (1 tabanlı) döndürür.\n * Örnek: Dikdörtgenler [[1,1,4,4], [2,2,6,6]] ve iğne noktası [3,3] için,\n *          fonksiyon 2 döndürmelidir, çünkü ikinci dikdörtgen daha büyük ve iğneyi içerir.\n */\n\n\nfunction findMaxAreaRectangle($rectangles, $needle)",
      "vi": "<?php\n\n\n/**\n * Tìm hình chữ nhật có diện tích lớn nhất bao gồm một điểm cho trước.\n * Trong nhiệm vụ này, chúng ta được cung cấp một danh sách các hình chữ nhật, mỗi hình được xác định bởi hai điểm góc đối diện,\n * và một điểm được gọi là \"kim\". Các cạnh của hình chữ nhật song song với các trục tọa độ.\n * Mục tiêu là tìm hình chữ nhật có diện tích lớn nhất chứa kim (bao gồm cả biên của nó).\n * Đầu vào: Một mảng các hình chữ nhật (mỗi hình chữ nhật là một mảng của hai điểm [x1, y1, x2, y2]),\n *         và một điểm kim [x, y].\n * Đầu ra: Trả về chỉ số (dựa trên 1) của hình chữ nhật có diện tích lớn nhất chứa kim.\n * Ví dụ: Đối với các hình chữ nhật [[1,1,4,4], [2,2,6,6]] và điểm kim [3,3],\n *         hàm nên trả về 2, vì hình chữ nhật thứ hai lớn hơn và chứa kim.\n */\n\n\nfunction findMaxAreaRectangle($rectangles, $needle)"
    },
    "prompt_bertscore": {
      "es": "0.9915707225200224",
      "arb": "0.9876084436791385",
      "sw": "0.974693297673869",
      "tr": "0.973275672644423",
      "vi": "0.9791084537835125"
    },
    "canonical_solution": "{\n    $maxArea = 0;\n    $maxRectIndex = -1;\n\n    for ($i = 0; $i < count($rectangles); $i++) {\n        $rect = $rectangles[$i];\n        if ($needle[0] >= min($rect[0], $rect[2]) && $needle[0] <= max($rect[0], $rect[2]) &&\n            $needle[1] >= min($rect[1], $rect[3]) && $needle[1] <= max($rect[1], $rect[3])) {\n            $area = abs($rect[2] - $rect[0]) * abs($rect[3] - $rect[1]);\n            if ($area > $maxArea) {\n                $maxArea = $area;\n                $maxRectIndex = $i + 1;\n            }\n        }\n    }\n    \n    return $maxRectIndex;\n}",
    "instruction": {
      "en": "function findMaxAreaRectangle($rectangles, $needle)\n{\n    $maxArea = 0;\n    $maxRectIndex = -1;\n\n    for ($i = 0; $i < count($rectangles); $i++) {\n        $rect = $rectangles[$i];\n        if ($needle[0] >= min($rect[0], $rect[2]) && $needle[0] <= max($rect[0], $rect[2]) &&\n            $needle[1] >= min($rect[1], $rect[3]) && $needle[1] <= max($rect[1], $rect[3])) {\n            $area = abs($rect[2] - $rect[0]) * abs($rect[3] - $rect[1]);\n            if ($area > $maxArea) {\n                $maxArea = $area;\n                $maxRectIndex = $i + 1;\n            }\n        }\n    }\n    \n    return $maxRectIndex;\n}\n\nProvide a concise natural language description (docstring) of the PHP code in English using at most 500 characters.",
      "es": "function findMaxAreaRectangle($rectangles, $needle)\n{\n    $maxArea = 0;\n    $maxRectIndex = -1;\n\n    for ($i = 0; $i < count($rectangles); $i++) {\n        $rect = $rectangles[$i];\n        if ($needle[0] >= min($rect[0], $rect[2]) && $needle[0] <= max($rect[0], $rect[2]) &&\n            $needle[1] >= min($rect[1], $rect[3]) && $needle[1] <= max($rect[1], $rect[3])) {\n            $area = abs($rect[2] - $rect[0]) * abs($rect[3] - $rect[1]);\n            if ($area > $maxArea) {\n                $maxArea = $area;\n                $maxRectIndex = $i + 1;\n            }\n        }\n    }\n    \n    return $maxRectIndex;\n}\n\nProporcione una descripción concisa en lenguaje natural (docstring) del código PHP en español utilizando un máximo de 500 caracteres.",
      "arb": "function findMaxAreaRectangle($rectangles, $needle)\n{\n    $maxArea = 0;\n    $maxRectIndex = -1;\n\n    for ($i = 0; $i < count($rectangles); $i++) {\n        $rect = $rectangles[$i];\n        if ($needle[0] >= min($rect[0], $rect[2]) && $needle[0] <= max($rect[0], $rect[2]) &&\n            $needle[1] >= min($rect[1], $rect[3]) && $needle[1] <= max($rect[1], $rect[3])) {\n            $area = abs($rect[2] - $rect[0]) * abs($rect[3] - $rect[1]);\n            if ($area > $maxArea) {\n                $maxArea = $area;\n                $maxRectIndex = $i + 1;\n            }\n        }\n    }\n    \n    return $maxRectIndex;\n}\n\nيرجى تقديم وصف موجز بلغة طبيعية (docstring) لشيفرة PHP باللغة العربية الفصحى باستخدام 500 حرف على الأكثر.",
      "sw": "function findMaxAreaRectangle($rectangles, $needle)\n{\n    $maxArea = 0;\n    $maxRectIndex = -1;\n\n    for ($i = 0; $i < count($rectangles); $i++) {\n        $rect = $rectangles[$i];\n        if ($needle[0] >= min($rect[0], $rect[2]) && $needle[0] <= max($rect[0], $rect[2]) &&\n            $needle[1] >= min($rect[1], $rect[3]) && $needle[1] <= max($rect[1], $rect[3])) {\n            $area = abs($rect[2] - $rect[0]) * abs($rect[3] - $rect[1]);\n            if ($area > $maxArea) {\n                $maxArea = $area;\n                $maxRectIndex = $i + 1;\n            }\n        }\n    }\n    \n    return $maxRectIndex;\n}\n\nToa maelezo mafupi ya lugha asilia (docstring) ya msimbo wa PHP kwa Kiswahili kwa kutumia herufi zisizozidi 500.",
      "tr": "function findMaxAreaRectangle($rectangles, $needle)\n{\n    $maxArea = 0;\n    $maxRectIndex = -1;\n\n    for ($i = 0; $i < count($rectangles); $i++) {\n        $rect = $rectangles[$i];\n        if ($needle[0] >= min($rect[0], $rect[2]) && $needle[0] <= max($rect[0], $rect[2]) &&\n            $needle[1] >= min($rect[1], $rect[3]) && $needle[1] <= max($rect[1], $rect[3])) {\n            $area = abs($rect[2] - $rect[0]) * abs($rect[3] - $rect[1]);\n            if ($area > $maxArea) {\n                $maxArea = $area;\n                $maxRectIndex = $i + 1;\n            }\n        }\n    }\n    \n    return $maxRectIndex;\n}\n\nPHP kodunun işlevini açıklayan kısa bir doğal dil tanımı (docstring) sağlayın. Açıklama, Türkçe olarak en fazla 500 karakter kullanılarak yazılmalıdır.",
      "vi": "function findMaxAreaRectangle($rectangles, $needle)\n{\n    $maxArea = 0;\n    $maxRectIndex = -1;\n\n    for ($i = 0; $i < count($rectangles); $i++) {\n        $rect = $rectangles[$i];\n        if ($needle[0] >= min($rect[0], $rect[2]) && $needle[0] <= max($rect[0], $rect[2]) &&\n            $needle[1] >= min($rect[1], $rect[3]) && $needle[1] <= max($rect[1], $rect[3])) {\n            $area = abs($rect[2] - $rect[0]) * abs($rect[3] - $rect[1]);\n            if ($area > $maxArea) {\n                $maxArea = $area;\n                $maxRectIndex = $i + 1;\n            }\n        }\n    }\n    \n    return $maxRectIndex;\n}\n\nCung cấp mô tả ngắn gọn bằng ngôn ngữ tự nhiên (docstring) cho mã PHP bằng tiếng Việt với tối đa 500 ký tự."
    },
    "instruction_bertscore": {
      "es": "0.9687069752502395",
      "arb": "0.8933384648399806",
      "sw": "0.9428367585331127",
      "tr": "0.881863190466833",
      "vi": "0.9017250367880356"
    },
    "level": "",
    "test": "function main(){\n    assert(findMaxAreaRectangle([[2,3,6,8], [1,3,5,6], [8, 2, 1, 9]], [4,4]) === 3);\n    assert(findMaxAreaRectangle([[6,8,2,3], [1,3,5,6], [8, 2, 1, 9]], [4,4]) === 3);\n    assert(findMaxAreaRectangle([[1,1,4,4], [2,2,6,6]], [3,3]) === 2);\n    assert(findMaxAreaRectangle([[0,0,5,5], [1,1,3,3]], [2,2]) === 1);\n    assert(findMaxAreaRectangle([[1,1,2,2], [2,2,4,4]], [5,5]) === -1); // Needle is outside all rectangles\n    \n}\n\n\nmain();\n?>",
    "entry_point": "findMaxAreaRectangle",
    "signature": "function findMaxAreaRectangle($rectangles, $needle)",
    "docstring": {
      "en": "Finds the rectangle with the largest area that includes a given point.\nIn this task, we are given a list of rectangles, each defined by two opposite corner points,\nand a point referred to as the \"needle\". The rectangles' sides are parallel to the coordinate axes.\nThe goal is to find the rectangle with the maximum area that contains the needle (including its boundary).\nInput: An array of rectangles (each rectangle is an array of two points [x1, y1, x2, y2]),\nand a needle point [x, y].\nOutput: Returns the index (1-based) of the rectangle with the largest area that contains the needle.\nExample: For rectangles [[1,1,4,4], [2,2,6,6]] and needle point [3,3],\nthe function should return 2, as the second rectangle is larger and contains the needle.",
      "es": "Encuentra el rectángulo con el área más grande que incluye un punto dado.\nEn esta tarea, se nos proporciona una lista de rectángulos, cada uno definido por dos puntos de esquina opuestos,\ny un punto referido como la \"aguja\". Los lados de los rectángulos son paralelos a los ejes de coordenadas.\nEl objetivo es encontrar el rectángulo con el área máxima que contiene la aguja (incluyendo su frontera).\nEntrada: Un array de rectángulos (cada rectángulo es un array de dos puntos [x1, y1, x2, y2]),\ny un punto aguja [x, y].\nSalida: Devuelve el índice (basado en 1) del rectángulo con el área más grande que contiene la aguja.\nEjemplo: Para los rectángulos [[1,1,4,4], [2,2,6,6]] y el punto aguja [3,3],\nla función debería devolver 2, ya que el segundo rectángulo es más grande y contiene la aguja.",
      "arb": "يعثر على المستطيل ذو المساحة الأكبر الذي يشمل نقطة معينة.\nفي هذه المهمة، يتم إعطاؤنا قائمة من المستطيلات، كل منها معرف بنقطتين متقابلتين،\nونقطة يشار إليها باسم \"الإبرة\". تكون جوانب المستطيلات موازية لمحاور الإحداثيات.\nالهدف هو العثور على المستطيل ذو المساحة القصوى الذي يحتوي على الإبرة (بما في ذلك حدوده).\nالمدخلات: مصفوفة من المستطيلات (كل مستطيل هو مصفوفة من نقطتين [x1, y1, x2, y2])،\nونقطة الإبرة [x, y].\nالمخرجات: يعيد فهرس (مبني على 1) المستطيل ذو المساحة الأكبر الذي يحتوي على الإبرة.\nمثال: بالنسبة للمستطيلات [[1,1,4,4], [2,2,6,6]] ونقطة الإبرة [3,3]،\nيجب أن تعيد الدالة 2، حيث أن المستطيل الثاني أكبر ويحتوي على الإبرة.",
      "sw": "Inapata mstatili wenye eneo kubwa zaidi ambalo linajumuisha nukta iliyopewa.\nKatika kazi hii, tunapewa orodha ya mistatili, kila moja ikifafanuliwa na pointi mbili za pembe zinazopingana,\nna nukta inayorejelewa kama \"sindano\". Pande za mistatili ziko sambamba na mhimili wa kuratibu.\nLengo ni kupata mstatili wenye eneo kubwa zaidi ambalo linajumuisha sindano (ikiwa ni pamoja na mpaka wake).\nIngizo: Kifurushi cha mistatili (kila mstatili ni kifurushi cha pointi mbili [x1, y1, x2, y2]),\nna nukta ya sindano [x, y].\nPato: Inarejesha faharasa (inayohesabiwa kuanzia 1) ya mstatili wenye eneo kubwa zaidi ambalo linajumuisha sindano.\nMfano: Kwa mistatili [[1,1,4,4], [2,2,6,6]] na nukta ya sindano [3,3],\nkazi inapaswa kurejesha 2, kwani mstatili wa pili ni mkubwa zaidi na unajumuisha sindano.",
      "tr": "Verilen bir noktayı içeren en büyük alanlı dikdörtgeni bulur.\nBu görevde, her biri iki zıt köşe noktasıyla tanımlanan bir dikdörtgen listesi ve \"iğne\" olarak adlandırılan bir nokta verilmektedir. Dikdörtgenlerin kenarları koordinat eksenlerine paraleldir. Amaç, iğneyi (sınırları dahil) içeren en büyük alana sahip dikdörtgeni bulmaktır.\nGirdi: Dikdörtgenlerin bir dizisi (her dikdörtgen iki noktadan oluşan bir dizi [x1, y1, x2, y2]) ve bir iğne noktası [x, y].\nÇıktı: İğneyi içeren en büyük alanlı dikdörtgenin indeksini (1 tabanlı) döndürür.\nÖrnek: Dikdörtgenler [[1,1,4,4], [2,2,6,6]] ve iğne noktası [3,3] için, fonksiyon 2 döndürmelidir, çünkü ikinci dikdörtgen daha büyüktür ve iğneyi içerir.",
      "vi": "Tìm hình chữ nhật có diện tích lớn nhất bao gồm một điểm cho trước.  \nTrong nhiệm vụ này, chúng ta được cung cấp một danh sách các hình chữ nhật, mỗi hình được xác định bởi hai điểm góc đối diện,  \nvà một điểm được gọi là \"kim\". Các cạnh của hình chữ nhật song song với các trục tọa độ.  \nMục tiêu là tìm hình chữ nhật có diện tích lớn nhất chứa kim (bao gồm cả biên của nó).  \nĐầu vào: Một mảng các hình chữ nhật (mỗi hình chữ nhật là một mảng của hai điểm [x1, y1, x2, y2]),  \nvà một điểm kim [x, y].  \nĐầu ra: Trả về chỉ số (bắt đầu từ 1) của hình chữ nhật có diện tích lớn nhất chứa kim.  \nVí dụ: Đối với các hình chữ nhật [[1,1,4,4], [2,2,6,6]] và điểm kim [3,3],  \nhàm nên trả về 2, vì hình chữ nhật thứ hai lớn hơn và chứa kim."
    },
    "docstring_bertscore": {
      "es": "0.9864402984082723",
      "arb": "0.9865135930188742",
      "sw": "0.9764609094346985",
      "tr": "0.9726960691925632",
      "vi": "0.9621021178200675"
    }
  },
  {
    "task_id": "PHP/16",
    "prompt": {
      "en": "<?php\n\n/**\n * Calculates the maximum value of a segment from a given array of values.\n * Imagine a tailor has a ribbon with various segments, each having a different value, positive or negative.\n * The goal is to find the maximum total value that can be obtained by cutting a continuous segment of the ribbon.\n * This is akin to finding the most valuable portion of the ribbon to sell or use.\n *\n * Input: \n * An array $values of integers representing the value of each segment of the ribbon.\n *\n * Output:\n * Returns an integer representing the maximum value that can be obtained from any continuous segment of the ribbon.\n *\n * Example:\n * For a ribbon of length 4 with values [-1, 3, 2, -4], the function should return 5, \n * as the segment [3, 2] gives the maximum value.\n */\n\n function maxSegmentValue($values)",
      "es": "<?php\n\n/**\n * Calcula el valor máximo de un segmento de un arreglo dado de valores.\n * Imagina que un sastre tiene una cinta con varios segmentos, cada uno con un valor diferente, positivo o negativo.\n * El objetivo es encontrar el valor total máximo que se puede obtener cortando un segmento continuo de la cinta.\n * Esto es similar a encontrar la porción más valiosa de la cinta para vender o usar.\n *\n * Entrada: \n * Un arreglo $values de enteros que representa el valor de cada segmento de la cinta.\n *\n * Salida:\n * Devuelve un entero que representa el valor máximo que se puede obtener de cualquier segmento continuo de la cinta.\n *\n * Ejemplo:\n * Para una cinta de longitud 4 con valores [-1, 3, 2, -4], la función debería devolver 5, \n * ya que el segmento [3, 2] da el valor máximo.\n */\n\n function maxSegmentValue($values)",
      "arb": "<?php\n\n/**\n * يحسب القيمة القصوى لمقطع من مصفوفة معينة من القيم.\n * تخيل أن خياطًا لديه شريط يحتوي على مقاطع مختلفة، كل منها له قيمة مختلفة، إيجابية أو سلبية.\n * الهدف هو العثور على القيمة الإجمالية القصوى التي يمكن الحصول عليها عن طريق قطع مقطع مستمر من الشريط.\n * هذا يشبه العثور على الجزء الأكثر قيمة من الشريط لبيعه أو استخدامه.\n *\n * المدخلات:\n * مصفوفة $values من الأعداد الصحيحة تمثل قيمة كل مقطع من الشريط.\n *\n * المخرجات:\n * يعيد عددًا صحيحًا يمثل القيمة القصوى التي يمكن الحصول عليها من أي مقطع مستمر من الشريط.\n *\n * مثال:\n * لشريط طوله 4 بقيم [-1, 3, 2, -4]، يجب أن تعيد الدالة 5،\n * حيث أن المقطع [3, 2] يعطي القيمة القصوى.\n */\n\n function maxSegmentValue($values)",
      "sw": "<?php\n\n/**\n * Inahesabu thamani ya juu zaidi ya kipande kutoka kwa safu iliyotolewa ya thamani.\n * Fikiria fundi cherehani ana utepe wenye vipande mbalimbali, kila kimoja kikiwa na thamani tofauti, chanya au hasi.\n * Lengo ni kupata jumla ya thamani ya juu zaidi inayoweza kupatikana kwa kukata kipande endelevu cha utepe.\n * Hii ni sawa na kutafuta sehemu ya thamani kubwa zaidi ya utepe kuuza au kutumia.\n *\n * Ingizo: \n * Safu $values ya nambari za mzima inayowakilisha thamani ya kila kipande cha utepe.\n *\n * Matokeo:\n * Inarudisha nambari ya mzima inayowakilisha thamani ya juu zaidi inayoweza kupatikana kutoka kwa kipande chochote endelevu cha utepe.\n *\n * Mfano:\n * Kwa utepe wa urefu wa 4 wenye thamani [-1, 3, 2, -4], kazi inapaswa kurudisha 5, \n * kwani kipande [3, 2] kinatoa thamani ya juu zaidi.\n */\n\n function maxSegmentValue($values)",
      "tr": "<?php\n\n/**\n * Bir dizi değerinden bir segmentin maksimum değerini hesaplar.\n * Bir terzinin, her biri farklı bir değere sahip çeşitli segmentlere sahip bir kurdeleye sahip olduğunu hayal edin, pozitif veya negatif.\n * Amaç, kurdelenin sürekli bir segmentini keserek elde edilebilecek maksimum toplam değeri bulmaktır.\n * Bu, satmak veya kullanmak için kurdelenin en değerli kısmını bulmaya benzer.\n *\n * Girdi: \n * Kurdele segmentlerinin değerini temsil eden tamsayılar dizisi $values.\n *\n * Çıktı:\n * Kurdelenin herhangi bir sürekli segmentinden elde edilebilecek maksimum değeri temsil eden bir tamsayı döndürür.\n *\n * Örnek:\n * Değerleri [-1, 3, 2, -4] olan 4 uzunluğunda bir kurdele için, fonksiyon 5 döndürmelidir,\n * çünkü [3, 2] segmenti maksimum değeri verir.\n */\n\n function maxSegmentValue($values)",
      "vi": "<?php\n\n/**\n * Tính giá trị tối đa của một đoạn từ một mảng giá trị cho trước.\n * Hãy tưởng tượng một thợ may có một dải ruy băng với các đoạn khác nhau, mỗi đoạn có giá trị khác nhau, có thể là dương hoặc âm.\n * Mục tiêu là tìm tổng giá trị tối đa có thể đạt được bằng cách cắt một đoạn liên tục của dải ruy băng.\n * Điều này giống như tìm phần có giá trị nhất của dải ruy băng để bán hoặc sử dụng.\n *\n * Đầu vào: \n * Một mảng $values của các số nguyên đại diện cho giá trị của mỗi đoạn của dải ruy băng.\n *\n * Đầu ra:\n * Trả về một số nguyên đại diện cho giá trị tối đa có thể đạt được từ bất kỳ đoạn liên tục nào của dải ruy băng.\n *\n * Ví dụ:\n * Đối với một dải ruy băng có độ dài 4 với các giá trị [-1, 3, 2, -4], hàm nên trả về 5, \n * vì đoạn [3, 2] cho giá trị tối đa.\n */\n\n function maxSegmentValue($values)"
    },
    "prompt_bertscore": {
      "es": "0.9901062207206522",
      "arb": "0.9940973009667863",
      "sw": "0.9672259871292435",
      "tr": "0.9737793992907275",
      "vi": "0.979788762838557"
    },
    "canonical_solution": "  {\n    $maxSoFar = PHP_INT_MIN;\n    $maxEndingHere = 0;\n\n    foreach ($values as $value) {\n        $maxEndingHere += $value;\n        if ($maxSoFar < $maxEndingHere) {\n            $maxSoFar = $maxEndingHere;\n        }\n\n        if ($maxEndingHere < 0) {\n            $maxEndingHere = 0;\n        }\n    }\n\n    return $maxSoFar;\n}",
    "instruction": {
      "en": "function maxSegmentValue($values)\n  {\n    $maxSoFar = PHP_INT_MIN;\n    $maxEndingHere = 0;\n\n    foreach ($values as $value) {\n        $maxEndingHere += $value;\n        if ($maxSoFar < $maxEndingHere) {\n            $maxSoFar = $maxEndingHere;\n        }\n\n        if ($maxEndingHere < 0) {\n            $maxEndingHere = 0;\n        }\n    }\n\n    return $maxSoFar;\n}\n\nProvide a concise natural language description (docstring) of the PHP code in English using at most 500 characters.",
      "es": "function maxSegmentValue($values)\n  {\n    $maxSoFar = PHP_INT_MIN;\n    $maxEndingHere = 0;\n\n    foreach ($values as $value) {\n        $maxEndingHere += $value;\n        if ($maxSoFar < $maxEndingHere) {\n            $maxSoFar = $maxEndingHere;\n        }\n\n        if ($maxEndingHere < 0) {\n            $maxEndingHere = 0;\n        }\n    }\n\n    return $maxSoFar;\n}\n\nProporcione una descripción concisa en lenguaje natural (docstring) del código PHP en español utilizando un máximo de 500 caracteres.",
      "arb": "function maxSegmentValue($values)\n  {\n    $maxSoFar = PHP_INT_MIN;\n    $maxEndingHere = 0;\n\n    foreach ($values as $value) {\n        $maxEndingHere += $value;\n        if ($maxSoFar < $maxEndingHere) {\n            $maxSoFar = $maxEndingHere;\n        }\n\n        if ($maxEndingHere < 0) {\n            $maxEndingHere = 0;\n        }\n    }\n\n    return $maxSoFar;\n}\n\nيرجى تقديم وصف موجز بلغة طبيعية (docstring) للكود PHP باللغة العربية الفصحى، باستخدام 500 حرف كحد أقصى.",
      "sw": "function maxSegmentValue($values)\n  {\n    $maxSoFar = PHP_INT_MIN;\n    $maxEndingHere = 0;\n\n    foreach ($values as $value) {\n        $maxEndingHere += $value;\n        if ($maxSoFar < $maxEndingHere) {\n            $maxSoFar = $maxEndingHere;\n        }\n\n        if ($maxEndingHere < 0) {\n            $maxEndingHere = 0;\n        }\n    }\n\n    return $maxSoFar;\n}\n\nToa maelezo mafupi ya lugha asilia (docstring) ya msimbo wa PHP kwa Kiswahili kwa kutumia herufi zisizozidi 500.",
      "tr": "function maxSegmentValue($values)\n  {\n    $maxSoFar = PHP_INT_MIN;\n    $maxEndingHere = 0;\n\n    foreach ($values as $value) {\n        $maxEndingHere += $value;\n        if ($maxSoFar < $maxEndingHere) {\n            $maxSoFar = $maxEndingHere;\n        }\n\n        if ($maxEndingHere < 0) {\n            $maxEndingHere = 0;\n        }\n    }\n\n    return $maxSoFar;\n}\n\nAşağıdaki PHP kodunun işlevini açıklayan, en fazla 500 karakterlik kısa bir doğal dil açıklaması (docstring) sağlayın.",
      "vi": "function maxSegmentValue($values)\n  {\n    $maxSoFar = PHP_INT_MIN;\n    $maxEndingHere = 0;\n\n    foreach ($values as $value) {\n        $maxEndingHere += $value;\n        if ($maxSoFar < $maxEndingHere) {\n            $maxSoFar = $maxEndingHere;\n        }\n\n        if ($maxEndingHere < 0) {\n            $maxEndingHere = 0;\n        }\n    }\n\n    return $maxSoFar;\n}\n\nCung cấp mô tả ngắn gọn bằng ngôn ngữ tự nhiên (docstring) cho mã PHP bằng tiếng Việt với tối đa 500 ký tự."
    },
    "instruction_bertscore": {
      "es": "0.9687069752502395",
      "arb": "0.924580242951434",
      "sw": "0.9428367585331127",
      "tr": "0.8538563067409137",
      "vi": "0.9150604846795749"
    },
    "level": "",
    "test": "function main(){\n    assert(maxSegmentValue([-1, 3, 2, -4]) === 5);\n    assert(maxSegmentValue([-2, -3, 4, -1, -2, 1, 5, -3]) === 7);\n    assert(maxSegmentValue([-1, -2, -3]) === -1);\n    assert(maxSegmentValue([10]) === 10);\n    assert(maxSegmentValue([1, -3]) === 1);\n    \n    \n}\n\n\nmain();\n?>",
    "entry_point": "maxSegmentValue",
    "signature": "function maxSegmentValue($values)",
    "docstring": {
      "en": "Calculates the maximum value of a segment from a given array of values.\nImagine a tailor has a ribbon with various segments, each having a different value, positive or negative.\nThe goal is to find the maximum total value that can be obtained by cutting a continuous segment of the ribbon.\nThis is akin to finding the most valuable portion of the ribbon to sell or use.\n\nInput:\nAn array $values of integers representing the value of each segment of the ribbon.\n\nOutput:\nReturns an integer representing the maximum value that can be obtained from any continuous segment of the ribbon.\n\nExample:\nFor a ribbon of length 4 with values [-1, 3, 2, -4], the function should return 5,\nas the segment [3, 2] gives the maximum value.",
      "es": "Calcula el valor máximo de un segmento de un arreglo dado de valores.  \nImagina que un sastre tiene una cinta con varios segmentos, cada uno con un valor diferente, positivo o negativo.  \nEl objetivo es encontrar el valor total máximo que se puede obtener cortando un segmento continuo de la cinta.  \nEsto es similar a encontrar la porción más valiosa de la cinta para vender o usar.\n\nEntrada:  \nUn arreglo $values de enteros que representa el valor de cada segmento de la cinta.\n\nSalida:  \nDevuelve un entero que representa el valor máximo que se puede obtener de cualquier segmento continuo de la cinta.\n\nEjemplo:  \nPara una cinta de longitud 4 con valores [-1, 3, 2, -4], la función debería devolver 5,  \nya que el segmento [3, 2] da el valor máximo.",
      "arb": "يحسب القيمة القصوى لمقطع من مصفوفة معينة من القيم.\nتخيل أن هناك خياط لديه شريط يحتوي على مقاطع مختلفة، كل منها له قيمة مختلفة، سواء كانت إيجابية أو سلبية.\nالهدف هو العثور على القيمة الإجمالية القصوى التي يمكن الحصول عليها عن طريق قطع مقطع متواصل من الشريط.\nهذا يشبه العثور على الجزء الأكثر قيمة من الشريط لبيعه أو استخدامه.\n\nالمدخلات:\nمصفوفة $values من الأعداد الصحيحة تمثل قيمة كل مقطع من الشريط.\n\nالمخرجات:\nيعيد عددًا صحيحًا يمثل القيمة القصوى التي يمكن الحصول عليها من أي مقطع متواصل من الشريط.\n\nمثال:\nبالنسبة لشريط بطول 4 مع القيم [-1, 3, 2, -4]، يجب أن تعيد الدالة 5،\nحيث أن المقطع [3, 2] يعطي القيمة القصوى.",
      "sw": "Hesabu thamani ya juu zaidi ya kipande kutoka kwenye safu iliyotolewa ya thamani.\nFikiria fundi cherehani ana utepe wenye vipande mbalimbali, kila kimoja kikiwa na thamani tofauti, chanya au hasi.\nLengo ni kupata jumla ya thamani ya juu zaidi inayoweza kupatikana kwa kukata kipande cha mfululizo cha utepe.\nHii ni sawa na kutafuta sehemu ya utepe yenye thamani kubwa zaidi kuuza au kutumia.\n\nIngizo:\nSafu $values ya nambari za mzima zinazowakilisha thamani ya kila kipande cha utepe.\n\nMatokeo:\nRudisha nambari ya mzima inayowakilisha thamani ya juu zaidi inayoweza kupatikana kutoka kwenye kipande chochote cha mfululizo cha utepe.\n\nMfano:\nKwa utepe wa urefu wa 4 wenye thamani [-1, 3, 2, -4], kazi inapaswa kurudisha 5,\nkwa kuwa kipande [3, 2] kinatoa thamani ya juu zaidi.",
      "tr": "Belirtilen bir değerler dizisinden bir segmentin maksimum değerini hesaplar.\nBir terzinin, her biri farklı bir değere sahip çeşitli segmentleri olan bir kurdeleye sahip olduğunu hayal edin, bu değerler pozitif veya negatif olabilir.\nAmaç, kurdelenin sürekli bir segmentini keserek elde edilebilecek maksimum toplam değeri bulmaktır.\nBu, satmak veya kullanmak için kurdelenin en değerli kısmını bulmaya benzer.\n\nGirdi:\nKurdele üzerindeki her segmentin değerini temsil eden bir tamsayılar dizisi $values.\n\nÇıktı:\nKurdeleden herhangi bir sürekli segmentten elde edilebilecek maksimum değeri temsil eden bir tamsayı döndürür.\n\nÖrnek:\nUzunluğu 4 olan ve değerleri [-1, 3, 2, -4] olan bir kurdele için, fonksiyon 5 döndürmelidir,\nçünkü [3, 2] segmenti maksimum değeri verir.",
      "vi": "Tính giá trị lớn nhất của một đoạn từ một mảng các giá trị đã cho.  \nHãy tưởng tượng một thợ may có một dải ruy băng với các đoạn khác nhau, mỗi đoạn có một giá trị khác nhau, có thể dương hoặc âm.  \nMục tiêu là tìm tổng giá trị lớn nhất có thể thu được bằng cách cắt một đoạn liên tục của dải ruy băng.  \nĐiều này giống như tìm phần có giá trị nhất của dải ruy băng để bán hoặc sử dụng.\n\nĐầu vào:  \nMột mảng $values của các số nguyên đại diện cho giá trị của mỗi đoạn của dải ruy băng.\n\nĐầu ra:  \nTrả về một số nguyên đại diện cho giá trị lớn nhất có thể thu được từ bất kỳ đoạn liên tục nào của dải ruy băng.\n\nVí dụ:  \nĐối với một dải ruy băng dài 4 với các giá trị [-1, 3, 2, -4], hàm nên trả về 5,  \nvì đoạn [3, 2] cho giá trị lớn nhất."
    },
    "docstring_bertscore": {
      "es": "0.9858839347109936",
      "arb": "0.9758914361322715",
      "sw": "0.9253475521133717",
      "tr": "0.96924446906132",
      "vi": "0.9776902328629234"
    }
  },
  {
    "task_id": "PHP/17",
    "prompt": {
      "en": "<?php\n\n/**\n * Determines the position of a new student in a choir formation.\n * The choir is arranged with the shortest members on the sides and the tallest in the center.\n * The new student may stand on the left or right side, or, if they are the tallest, to the right of the current tallest student.\n * If the new student is not the tallest, their position is based on the teacher's preference: left or right side.\n *\n * Input:\n * - $newStudentHeight (int): The height of the new student.\n * - $heights (array): An array of integers representing the heights of the current choir members from left to right.\n * - $teacherPreference (int): The teacher's preference for the new student's position (1 for left, 2 for right).\n *\n * Output:\n * - Returns an integer representing the position (1-indexed) where the new student will stand.\n *\n * Examples:\n * - determineChoirPosition(20, [1, 3, 8, 10, 14, 40, 22, 16, 8], 2) should return 8.\n * - determineChoirPosition(15, [5, 10, 20, 10, 5], 3) should return 3.\n */\n\nfunction determineChoirPosition(int $newStudentHeight, array $heights, int $teacherPreference): int ",
      "es": "<?php\n\n/**\n * Determina la posición de un nuevo estudiante en una formación de coro.\n * El coro está organizado con los miembros más bajos en los lados y los más altos en el centro.\n * El nuevo estudiante puede estar en el lado izquierdo o derecho, o, si es el más alto, a la derecha del estudiante más alto actual.\n * Si el nuevo estudiante no es el más alto, su posición se basa en la preferencia del maestro: lado izquierdo o derecho.\n *\n * Entrada:\n * - $newStudentHeight (int): La altura del nuevo estudiante.\n * - $heights (array): Un arreglo de enteros que representa las alturas de los miembros actuales del coro de izquierda a derecha.\n * - $teacherPreference (int): La preferencia del maestro para la posición del nuevo estudiante (1 para izquierda, 2 para derecha).\n *\n * Salida:\n * - Devuelve un entero que representa la posición (indexada desde 1) donde el nuevo estudiante se ubicará.\n *\n * Ejemplos:\n * - determineChoirPosition(20, [1, 3, 8, 10, 14, 40, 22, 16, 8], 2) debería devolver 8.\n * - determineChoirPosition(15, [5, 10, 20, 10, 5], 3) debería devolver 3.\n */\n\nfunction determineChoirPosition(int $newStudentHeight, array $heights, int $teacherPreference): int ",
      "arb": "<?php\n\n/**\n * يحدد موضع طالب جديد في تشكيل الكورال.\n * يتم ترتيب الكورال بحيث يكون الأعضاء الأقصر على الجوانب والأطول في المركز.\n * يمكن للطالب الجديد الوقوف على الجانب الأيسر أو الأيمن، أو إذا كان الأطول، إلى يمين الطالب الأطول الحالي.\n * إذا لم يكن الطالب الجديد هو الأطول، فإن موضعه يعتمد على تفضيل المعلم: الجانب الأيسر أو الأيمن.\n *\n * المدخلات:\n * - $newStudentHeight (int): ارتفاع الطالب الجديد.\n * - $heights (array): مصفوفة من الأعداد الصحيحة تمثل ارتفاعات أعضاء الكورال الحاليين من اليسار إلى اليمين.\n * - $teacherPreference (int): تفضيل المعلم لموضع الطالب الجديد (1 للجانب الأيسر، 2 للجانب الأيمن).\n *\n * المخرجات:\n * - يعيد عددًا صحيحًا يمثل الموضع (مؤشر يبدأ من 1) حيث سيقف الطالب الجديد.\n *\n * أمثلة:\n * - determineChoirPosition(20, [1, 3, 8, 10, 14, 40, 22, 16, 8], 2) يجب أن تعيد 8.\n * - determineChoirPosition(15, [5, 10, 20, 10, 5], 3) يجب أن تعيد 3.\n */\n\nfunction determineChoirPosition(int $newStudentHeight, array $heights, int $teacherPreference): int ",
      "sw": "<?php\n\n/**\n * Huamua nafasi ya mwanafunzi mpya katika mpangilio wa kwaya.\n * Kwaya imepangwa na wanachama wafupi zaidi wakiwa pembeni na warefu zaidi katikati.\n * Mwanafunzi mpya anaweza kusimama upande wa kushoto au kulia, au, ikiwa ndiye mrefu zaidi, upande wa kulia wa mwanafunzi mrefu zaidi wa sasa.\n * Ikiwa mwanafunzi mpya si mrefu zaidi, nafasi yake inategemea upendeleo wa mwalimu: upande wa kushoto au kulia.\n *\n * Ingizo:\n * - $newStudentHeight (int): Urefu wa mwanafunzi mpya.\n * - $heights (array): Mfululizo wa nambari za mzima zinazoashiria urefu wa wanachama wa sasa wa kwaya kutoka kushoto kwenda kulia.\n * - $teacherPreference (int): Upendeleo wa mwalimu kwa nafasi ya mwanafunzi mpya (1 kwa kushoto, 2 kwa kulia).\n *\n * Tokeo:\n * - Inarudisha nambari inayoashiria nafasi (1-indexed) ambapo mwanafunzi mpya atasimama.\n *\n * Mifano:\n * - determineChoirPosition(20, [1, 3, 8, 10, 14, 40, 22, 16, 8], 2) inapaswa kurudisha 8.\n * - determineChoirPosition(15, [5, 10, 20, 10, 5], 3) inapaswa kurudisha 3.\n */\n\nfunction determineChoirPosition(int $newStudentHeight, array $heights, int $teacherPreference): int ",
      "tr": "<?php\n\n/**\n * Yeni bir öğrencinin bir koro oluşumundaki pozisyonunu belirler.\n * Koro, en kısa üyeler yanlarda ve en uzun üyeler ortada olacak şekilde düzenlenmiştir.\n * Yeni öğrenci, sol veya sağ tarafa ya da en uzun ise mevcut en uzun öğrencinin sağına geçebilir.\n * Eğer yeni öğrenci en uzun değilse, pozisyonu öğretmenin tercihlerine göre belirlenir: sol veya sağ taraf.\n *\n * Girdi:\n * - $newStudentHeight (int): Yeni öğrencinin boyu.\n * - $heights (array): Mevcut koro üyelerinin soldan sağa doğru boylarını temsil eden bir tamsayı dizisi.\n * - $teacherPreference (int): Yeni öğrencinin pozisyonu için öğretmenin tercihi (1 sol için, 2 sağ için).\n *\n * Çıktı:\n * - Yeni öğrencinin duracağı pozisyonu (1-indexli) temsil eden bir tamsayı döndürür.\n *\n * Örnekler:\n * - determineChoirPosition(20, [1, 3, 8, 10, 14, 40, 22, 16, 8], 2) 8 döndürmelidir.\n * - determineChoirPosition(15, [5, 10, 20, 10, 5], 3) 3 döndürmelidir.\n */\n\nfunction determineChoirPosition(int $newStudentHeight, array $heights, int $teacherPreference): int ",
      "vi": "<?php\n\n/**\n * Xác định vị trí của một học sinh mới trong đội hình hợp xướng.\n * Đội hợp xướng được sắp xếp với các thành viên thấp nhất ở hai bên và cao nhất ở trung tâm.\n * Học sinh mới có thể đứng ở bên trái hoặc bên phải, hoặc nếu họ là người cao nhất, đứng bên phải của học sinh cao nhất hiện tại.\n * Nếu học sinh mới không phải là người cao nhất, vị trí của họ dựa trên sự ưu tiên của giáo viên: bên trái hoặc bên phải.\n *\n * Đầu vào:\n * - $newStudentHeight (int): Chiều cao của học sinh mới.\n * - $heights (array): Một mảng các số nguyên đại diện cho chiều cao của các thành viên hiện tại của đội hợp xướng từ trái sang phải.\n * - $teacherPreference (int): Sự ưu tiên của giáo viên cho vị trí của học sinh mới (1 cho bên trái, 2 cho bên phải).\n *\n * Đầu ra:\n * - Trả về một số nguyên đại diện cho vị trí (đánh số từ 1) nơi học sinh mới sẽ đứng.\n *\n * Ví dụ:\n * - determineChoirPosition(20, [1, 3, 8, 10, 14, 40, 22, 16, 8], 2) sẽ trả về 8.\n * - determineChoirPosition(15, [5, 10, 20, 10, 5], 3) sẽ trả về 3.\n */\n\nfunction determineChoirPosition(int $newStudentHeight, array $heights, int $teacherPreference): int "
    },
    "prompt_bertscore": {
      "es": "0.989467624045625",
      "arb": "0.9665025752815144",
      "sw": "0.9812888194761324",
      "tr": "0.9811926823717116",
      "vi": "0.973457816703832"
    },
    "canonical_solution": "{\n    // Check if the new student is the tallest\n    if ($newStudentHeight > max($heights)) {\n        return count($heights) + 1; // Tallest student goes to the right of the current tallest\n    }\n\n    // If the new student is not the tallest, find their position based on teacher's preference\n    if ($teacherPreference == 1) { // Teacher prefers left side\n        for ($i = 0; $i < count($heights); $i++) {\n            if ($newStudentHeight < $heights[$i]) {\n                return $i + 1; // 1-indexed position\n            }\n        }\n    } else { // Teacher prefers right side\n        for ($i = count($heights) - 1; $i >= 0; $i--) {\n            if ($newStudentHeight < $heights[$i]) {\n                return $i + 2; // 1-indexed position\n            }\n        }\n    }\n    // If the new student is the shortest, they go to the left or right side based on teacher's preference\n    return $teacherPreference == 1 ? 1 : count($heights) + 1;\n}",
    "instruction": {
      "en": "function determineChoirPosition(int $newStudentHeight, array $heights, int $teacherPreference): int\n{\n    // Check if the new student is the tallest\n    if ($newStudentHeight > max($heights)) {\n        return count($heights) + 1; // Tallest student goes to the right of the current tallest\n    }\n\n    // If the new student is not the tallest, find their position based on teacher's preference\n    if ($teacherPreference == 1) { // Teacher prefers left side\n        for ($i = 0; $i < count($heights); $i++) {\n            if ($newStudentHeight < $heights[$i]) {\n                return $i + 1; // 1-indexed position\n            }\n        }\n    } else { // Teacher prefers right side\n        for ($i = count($heights) - 1; $i >= 0; $i--) {\n            if ($newStudentHeight < $heights[$i]) {\n                return $i + 2; // 1-indexed position\n            }\n        }\n    }\n    // If the new student is the shortest, they go to the left or right side based on teacher's preference\n    return $teacherPreference == 1 ? 1 : count($heights) + 1;\n}\n\nProvide a concise natural language description (docstring) of the PHP code in English using at most 500 characters.",
      "es": "function determineChoirPosition(int $newStudentHeight, array $heights, int $teacherPreference): int\n{\n    // Check if the new student is the tallest\n    if ($newStudentHeight > max($heights)) {\n        return count($heights) + 1; // Tallest student goes to the right of the current tallest\n    }\n\n    // If the new student is not the tallest, find their position based on teacher's preference\n    if ($teacherPreference == 1) { // Teacher prefers left side\n        for ($i = 0; $i < count($heights); $i++) {\n            if ($newStudentHeight < $heights[$i]) {\n                return $i + 1; // 1-indexed position\n            }\n        }\n    } else { // Teacher prefers right side\n        for ($i = count($heights) - 1; $i >= 0; $i--) {\n            if ($newStudentHeight < $heights[$i]) {\n                return $i + 2; // 1-indexed position\n            }\n        }\n    }\n    // If the new student is the shortest, they go to the left or right side based on teacher's preference\n    return $teacherPreference == 1 ? 1 : count($heights) + 1;\n}\n\nProporcione una descripción concisa en lenguaje natural (docstring) del código PHP en español utilizando un máximo de 500 caracteres.",
      "arb": "function determineChoirPosition(int $newStudentHeight, array $heights, int $teacherPreference): int\n{\n    // Check if the new student is the tallest\n    if ($newStudentHeight > max($heights)) {\n        return count($heights) + 1; // Tallest student goes to the right of the current tallest\n    }\n\n    // If the new student is not the tallest, find their position based on teacher's preference\n    if ($teacherPreference == 1) { // Teacher prefers left side\n        for ($i = 0; $i < count($heights); $i++) {\n            if ($newStudentHeight < $heights[$i]) {\n                return $i + 1; // 1-indexed position\n            }\n        }\n    } else { // Teacher prefers right side\n        for ($i = count($heights) - 1; $i >= 0; $i--) {\n            if ($newStudentHeight < $heights[$i]) {\n                return $i + 2; // 1-indexed position\n            }\n        }\n    }\n    // If the new student is the shortest, they go to the left or right side based on teacher's preference\n    return $teacherPreference == 1 ? 1 : count($heights) + 1;\n}\n\nيرجى تقديم وصف موجز بلغة طبيعية (docstring) للكود المكتوب بلغة PHP باللغة العربية الفصحى، بحيث لا يتجاوز 500 حرف.",
      "sw": "function determineChoirPosition(int $newStudentHeight, array $heights, int $teacherPreference): int\n{\n    // Check if the new student is the tallest\n    if ($newStudentHeight > max($heights)) {\n        return count($heights) + 1; // Tallest student goes to the right of the current tallest\n    }\n\n    // If the new student is not the tallest, find their position based on teacher's preference\n    if ($teacherPreference == 1) { // Teacher prefers left side\n        for ($i = 0; $i < count($heights); $i++) {\n            if ($newStudentHeight < $heights[$i]) {\n                return $i + 1; // 1-indexed position\n            }\n        }\n    } else { // Teacher prefers right side\n        for ($i = count($heights) - 1; $i >= 0; $i--) {\n            if ($newStudentHeight < $heights[$i]) {\n                return $i + 2; // 1-indexed position\n            }\n        }\n    }\n    // If the new student is the shortest, they go to the left or right side based on teacher's preference\n    return $teacherPreference == 1 ? 1 : count($heights) + 1;\n}\n\nToa maelezo mafupi ya lugha ya asili (docstring) ya msimbo wa PHP kwa Kiswahili kwa kutumia herufi zisizozidi 500.",
      "tr": "function determineChoirPosition(int $newStudentHeight, array $heights, int $teacherPreference): int\n{\n    // Check if the new student is the tallest\n    if ($newStudentHeight > max($heights)) {\n        return count($heights) + 1; // Tallest student goes to the right of the current tallest\n    }\n\n    // If the new student is not the tallest, find their position based on teacher's preference\n    if ($teacherPreference == 1) { // Teacher prefers left side\n        for ($i = 0; $i < count($heights); $i++) {\n            if ($newStudentHeight < $heights[$i]) {\n                return $i + 1; // 1-indexed position\n            }\n        }\n    } else { // Teacher prefers right side\n        for ($i = count($heights) - 1; $i >= 0; $i--) {\n            if ($newStudentHeight < $heights[$i]) {\n                return $i + 2; // 1-indexed position\n            }\n        }\n    }\n    // If the new student is the shortest, they go to the left or right side based on teacher's preference\n    return $teacherPreference == 1 ? 1 : count($heights) + 1;\n}\n\nPHP kodunun işlevini açıklayan, en fazla 500 karakter uzunluğunda Türkçe bir doğal dil açıklaması (docstring) sağlayın.",
      "vi": "function determineChoirPosition(int $newStudentHeight, array $heights, int $teacherPreference): int\n{\n    // Check if the new student is the tallest\n    if ($newStudentHeight > max($heights)) {\n        return count($heights) + 1; // Tallest student goes to the right of the current tallest\n    }\n\n    // If the new student is not the tallest, find their position based on teacher's preference\n    if ($teacherPreference == 1) { // Teacher prefers left side\n        for ($i = 0; $i < count($heights); $i++) {\n            if ($newStudentHeight < $heights[$i]) {\n                return $i + 1; // 1-indexed position\n            }\n        }\n    } else { // Teacher prefers right side\n        for ($i = count($heights) - 1; $i >= 0; $i--) {\n            if ($newStudentHeight < $heights[$i]) {\n                return $i + 2; // 1-indexed position\n            }\n        }\n    }\n    // If the new student is the shortest, they go to the left or right side based on teacher's preference\n    return $teacherPreference == 1 ? 1 : count($heights) + 1;\n}\n\nCung cấp mô tả ngắn gọn bằng ngôn ngữ tự nhiên (docstring) cho mã PHP bằng tiếng Việt với tối đa 500 ký tự."
    },
    "instruction_bertscore": {
      "es": "0.9687069752502395",
      "arb": "0.8898884537517856",
      "sw": "0.91585798565943",
      "tr": "0.867965817227346",
      "vi": "0.9017250367880356"
    },
    "level": "",
    "test": "function main(){\n    \n    assert(determineChoirPosition(20, [1, 3, 8, 10, 14, 40, 22, 16, 8], 2) === 8);\n    assert(determineChoirPosition(15, [5, 10, 20, 10, 5], 1) === 3);\n    assert(determineChoirPosition(12, [10, 15, 20, 15], 2) === 5);\n    assert(determineChoirPosition(18, [6, 9, 12, 15, 17, 21], 1) === 6);\n    assert(determineChoirPosition(18, [6, 9, 12, 15], 1) === 5);\n    assert(determineChoirPosition(10, [5, 8, 12], 2) === 4);   \n}\n\n\nmain();\n?>",
    "entry_point": "determineChoirPosition",
    "signature": "function determineChoirPosition(int $newStudentHeight, array $heights, int $teacherPreference): int",
    "docstring": {
      "en": "Determines the position of a new student in a choir formation.\nThe choir is arranged with the shortest members on the sides and the tallest in the center.\nThe new student may stand on the left or right side, or, if they are the tallest, to the right of the current tallest student.\nIf the new student is not the tallest, their position is based on the teacher's preference: left or right side.\n\nInput:\n- $newStudentHeight (int): The height of the new student.\n- $heights (array): An array of integers representing the heights of the current choir members from left to right.\n- $teacherPreference (int): The teacher's preference for the new student's position (1 for left, 2 for right).\n\nOutput:\n- Returns an integer representing the position (1-indexed) where the new student will stand.\n\nExamples:\n- determineChoirPosition(20, [1, 3, 8, 10, 14, 40, 22, 16, 8], 2) should return 8.\n- determineChoirPosition(15, [5, 10, 20, 10, 5], 3) should return 3.",
      "es": "Determina la posición de un nuevo estudiante en una formación de coro.  \nEl coro está organizado con los miembros más bajos en los lados y los más altos en el centro.  \nEl nuevo estudiante puede estar en el lado izquierdo o derecho, o, si es el más alto, a la derecha del estudiante más alto actual.  \nSi el nuevo estudiante no es el más alto, su posición se basa en la preferencia del maestro: lado izquierdo o derecho.\n\nEntrada:  \n- $newStudentHeight (int): La altura del nuevo estudiante.  \n- $heights (array): Un arreglo de enteros que representa las alturas de los miembros actuales del coro de izquierda a derecha.  \n- $teacherPreference (int): La preferencia del maestro para la posición del nuevo estudiante (1 para izquierda, 2 para derecha).\n\nSalida:  \n- Devuelve un entero que representa la posición (indexada desde 1) donde el nuevo estudiante se ubicará.\n\nEjemplos:  \n- determineChoirPosition(20, [1, 3, 8, 10, 14, 40, 22, 16, 8], 2) debería devolver 8.  \n- determineChoirPosition(15, [5, 10, 20, 10, 5], 3) debería devolver 3.",
      "arb": "يحدد موضع الطالب الجديد في تشكيل الكورال.\nيتم ترتيب الكورال بحيث يكون الأعضاء الأقصر على الجوانب والأطول في المركز.\nيمكن للطالب الجديد الوقوف على الجانب الأيسر أو الأيمن، أو إذا كان هو الأطول، إلى يمين أطول طالب حالي.\nإذا لم يكن الطالب الجديد هو الأطول، فإن موضعه يعتمد على تفضيل المعلم: الجانب الأيسر أو الأيمن.\n\nالمدخلات:\n- $newStudentHeight (int): ارتفاع الطالب الجديد.\n- $heights (array): مصفوفة من الأعداد الصحيحة تمثل ارتفاعات أعضاء الكورال الحاليين من اليسار إلى اليمين.\n- $teacherPreference (int): تفضيل المعلم لموضع الطالب الجديد (1 للجانب الأيسر، 2 للجانب الأيمن).\n\nالمخرجات:\n- يعيد عددًا صحيحًا يمثل الموضع (مؤشر يبدأ من 1) حيث سيقف الطالب الجديد.\n\nأمثلة:\n- determineChoirPosition(20, [1, 3, 8, 10, 14, 40, 22, 16, 8], 2) يجب أن تعيد 8.\n- determineChoirPosition(15, [5, 10, 20, 10, 5], 3) يجب أن تعيد 3.",
      "sw": "Inabainisha nafasi ya mwanafunzi mpya katika mpangilio wa kwaya.\nKwaya imepangwa na wanachama wafupi zaidi pembeni na warefu zaidi katikati.\nMwanafunzi mpya anaweza kusimama upande wa kushoto au kulia, au, ikiwa ndiye mrefu zaidi, upande wa kulia wa mwanafunzi mrefu zaidi wa sasa.\nIkiwa mwanafunzi mpya si mrefu zaidi, nafasi yake inategemea upendeleo wa mwalimu: upande wa kushoto au kulia.\n\nIngizo:\n- $newStudentHeight (int): Urefu wa mwanafunzi mpya.\n- $heights (array): Orodha ya nambari za mzima zinazoonyesha urefu wa wanachama wa sasa wa kwaya kutoka kushoto kwenda kulia.\n- $teacherPreference (int): Upendeleo wa mwalimu kwa nafasi ya mwanafunzi mpya (1 kwa kushoto, 2 kwa kulia).\n\nMatokeo:\n- Inarudisha nambari mzima inayowakilisha nafasi (1-indexed) ambapo mwanafunzi mpya atasimama.\n\nMifano:\n- determineChoirPosition(20, [1, 3, 8, 10, 14, 40, 22, 16, 8], 2) inapaswa kurudisha 8.\n- determineChoirPosition(15, [5, 10, 20, 10, 5], 3) inapaswa kurudisha 3.",
      "tr": "Yeni bir öğrencinin bir koro oluşumundaki konumunu belirler.  \nKoro, en kısa üyeler yanlarda ve en uzun üyeler ortada olacak şekilde düzenlenmiştir.  \nYeni öğrenci sol veya sağ tarafta durabilir veya en uzun öğrenci ise mevcut en uzun öğrencinin sağına geçebilir.  \nYeni öğrenci en uzun değilse, konumu öğretmenin tercihlerine göre belirlenir: sol veya sağ taraf.\n\nGirdi:  \n- $newStudentHeight (int): Yeni öğrencinin boyu.  \n- $heights (array): Mevcut koro üyelerinin boylarını soldan sağa temsil eden bir tamsayı dizisi.  \n- $teacherPreference (int): Yeni öğrencinin konumu için öğretmenin tercihi (1 sol için, 2 sağ için).\n\nÇıktı:  \n- Yeni öğrencinin duracağı konumu (1-indexli) temsil eden bir tamsayı döndürür.\n\nÖrnekler:  \n- determineChoirPosition(20, [1, 3, 8, 10, 14, 40, 22, 16, 8], 2) 8 döndürmelidir.  \n- determineChoirPosition(15, [5, 10, 20, 10, 5], 3) 3 döndürmelidir.",
      "vi": "Xác định vị trí của một học sinh mới trong đội hình dàn hợp xướng.  \nDàn hợp xướng được sắp xếp với các thành viên thấp nhất ở hai bên và cao nhất ở trung tâm.  \nHọc sinh mới có thể đứng ở bên trái hoặc bên phải, hoặc nếu họ là người cao nhất, thì đứng bên phải của học sinh cao nhất hiện tại.  \nNếu học sinh mới không phải là người cao nhất, vị trí của họ dựa trên sự ưu tiên của giáo viên: bên trái hoặc bên phải.  \n\nĐầu vào:  \n- $newStudentHeight (int): Chiều cao của học sinh mới.  \n- $heights (array): Một mảng số nguyên đại diện cho chiều cao của các thành viên hiện tại của dàn hợp xướng từ trái sang phải.  \n- $teacherPreference (int): Sự ưu tiên của giáo viên cho vị trí của học sinh mới (1 cho bên trái, 2 cho bên phải).  \n\nĐầu ra:  \n- Trả về một số nguyên đại diện cho vị trí (đánh số từ 1) nơi học sinh mới sẽ đứng.  \n\nVí dụ:  \n- determineChoirPosition(20, [1, 3, 8, 10, 14, 40, 22, 16, 8], 2) sẽ trả về 8.  \n- determineChoirPosition(15, [5, 10, 20, 10, 5], 3) sẽ trả về 3.  "
    },
    "docstring_bertscore": {
      "es": "0.9860917020895561",
      "arb": "0.9619972409788811",
      "sw": "0.9681200224742815",
      "tr": "0.9675571039744286",
      "vi": "0.9614903362464801"
    }
  },
  {
    "task_id": "PHP/18",
    "prompt": {
      "en": "<?php\n\n/**\n * Determines the exact price of an item within a specified range based on a series of hints.\n * The item's price is within the range [1, maxPrice].\n * Hints are given in a string where:\n * - 'u' indicates the actual price is higher than the current guess.\n * - 'd' indicates the actual price is lower than the current guess.\n * - 'y' indicates the current guess is correct.\n * The function uses a binary search approach to narrow down the possible price.\n * Input: The maximum price (maxPrice) and a string of hints.\n * Output: Returns the exact price of the item.\n * Example: For maxPrice = 1000000 and hints = \"uddy\", the function returns 562500.\n */\n\nfunction guessItemPrice(int $maxPrice, string $hints): int ",
      "es": "<?php\n\n/**\n * Determina el precio exacto de un artículo dentro de un rango especificado basado en una serie de pistas.\n * El precio del artículo está dentro del rango [1, maxPrice].\n * Las pistas se dan en una cadena donde:\n * - 'u' indica que el precio real es mayor que la suposición actual.\n * - 'd' indica que el precio real es menor que la suposición actual.\n * - 'y' indica que la suposición actual es correcta.\n * La función utiliza un enfoque de búsqueda binaria para reducir el posible precio.\n * Entrada: El precio máximo (maxPrice) y una cadena de pistas.\n * Salida: Devuelve el precio exacto del artículo.\n * Ejemplo: Para maxPrice = 1000000 y pistas = \"uddy\", la función devuelve 562500.\n */\n\nfunction guessItemPrice(int $maxPrice, string $hints): int ",
      "arb": "<?php\n\n/**\n * يحدد السعر الدقيق لعنصر ضمن نطاق محدد بناءً على سلسلة من التلميحات.\n * سعر العنصر يقع ضمن النطاق [1, maxPrice].\n * تُعطى التلميحات في سلسلة حيث:\n * - 'u' تشير إلى أن السعر الفعلي أعلى من التخمين الحالي.\n * - 'd' تشير إلى أن السعر الفعلي أقل من التخمين الحالي.\n * - 'y' تشير إلى أن التخمين الحالي صحيح.\n * تستخدم الدالة نهج البحث الثنائي لتضييق نطاق السعر المحتمل.\n * المدخلات: السعر الأقصى (maxPrice) وسلسلة من التلميحات.\n * المخرجات: تعيد السعر الدقيق للعنصر.\n * مثال: بالنسبة لـ maxPrice = 1000000 و hints = \"uddy\"، تعيد الدالة 562500.\n */\n\nfunction guessItemPrice(int $maxPrice, string $hints): int ",
      "sw": "<?php\n\n/**\n * Huamua bei halisi ya kipengee ndani ya safu maalum kulingana na mfululizo wa vidokezo.\n * Bei ya kipengee iko ndani ya safu [1, maxPrice].\n * Vidokezo vinatolewa katika kamba ambapo:\n * - 'u' inaashiria bei halisi ni ya juu kuliko makisio ya sasa.\n * - 'd' inaashiria bei halisi ni ya chini kuliko makisio ya sasa.\n * - 'y' inaashiria makisio ya sasa ni sahihi.\n * Kazi hii inatumia mbinu ya utafutaji wa nusu (binary search) kupunguza uwezekano wa bei.\n * Ingizo: Bei ya juu zaidi (maxPrice) na kamba ya vidokezo.\n * Tokeo: Inarudisha bei halisi ya kipengee.\n * Mfano: Kwa maxPrice = 1000000 na hints = \"uddy\", kazi inarudisha 562500.\n */\n\nfunction guessItemPrice(int $maxPrice, string $hints): int ",
      "tr": "<?php\n\n/**\n * Belirtilen bir aralık içinde bir öğenin kesin fiyatını, bir dizi ipucu temelinde belirler.\n * Öğenin fiyatı [1, maxPrice] aralığındadır.\n * İpuçları, şu şekilde bir dizede verilir:\n * - 'u' mevcut tahminden daha yüksek bir gerçek fiyatı belirtir.\n * - 'd' mevcut tahminden daha düşük bir gerçek fiyatı belirtir.\n * - 'y' mevcut tahminin doğru olduğunu belirtir.\n * Fonksiyon, olası fiyatı daraltmak için ikili arama yaklaşımını kullanır.\n * Girdi: Maksimum fiyat (maxPrice) ve bir ipucu dizisi.\n * Çıktı: Öğenin kesin fiyatını döndürür.\n * Örnek: maxPrice = 1000000 ve hints = \"uddy\" için, fonksiyon 562500 döndürür.\n */\n\nfunction guessItemPrice(int $maxPrice, string $hints): int ",
      "vi": "<?php\n\n/**\n * Xác định giá chính xác của một mặt hàng trong một phạm vi được chỉ định dựa trên một loạt các gợi ý.\n * Giá của mặt hàng nằm trong phạm vi [1, maxPrice].\n * Gợi ý được đưa ra trong một chuỗi nơi:\n * - 'u' chỉ ra rằng giá thực tế cao hơn giá đoán hiện tại.\n * - 'd' chỉ ra rằng giá thực tế thấp hơn giá đoán hiện tại.\n * - 'y' chỉ ra rằng giá đoán hiện tại là chính xác.\n * Hàm sử dụng phương pháp tìm kiếm nhị phân để thu hẹp giá có thể có.\n * Đầu vào: Giá tối đa (maxPrice) và một chuỗi gợi ý.\n * Đầu ra: Trả về giá chính xác của mặt hàng.\n * Ví dụ: Với maxPrice = 1000000 và hints = \"uddy\", hàm trả về 562500.\n */\n\nfunction guessItemPrice(int $maxPrice, string $hints): int "
    },
    "prompt_bertscore": {
      "es": "0.9833271644463125",
      "arb": "0.9816682035039092",
      "sw": "0.9846097208166548",
      "tr": "0.9914894826941791",
      "vi": "0.9786468367779875"
    },
    "canonical_solution": "{\n    $low = 1;\n    $high = $maxPrice;\n\n    foreach (str_split($hints) as $hint) {\n        $mid = intdiv($low + $high, 2);\n\n        if ($hint === 'u') {\n            $low = $mid + 1;\n        } elseif ($hint === 'd') {\n            $high = $mid - 1;\n        } elseif ($hint === 'y') {\n            return $mid;\n        }\n    }\n\n    // In case the hints do not determine the price correctly, return an error or a default value\n    return -1; // or any other appropriate error handling\n}",
    "instruction": {
      "en": "function guessItemPrice(int $maxPrice, string $hints): int\n{\n    $low = 1;\n    $high = $maxPrice;\n\n    foreach (str_split($hints) as $hint) {\n        $mid = intdiv($low + $high, 2);\n\n        if ($hint === 'u') {\n            $low = $mid + 1;\n        } elseif ($hint === 'd') {\n            $high = $mid - 1;\n        } elseif ($hint === 'y') {\n            return $mid;\n        }\n    }\n\n    // In case the hints do not determine the price correctly, return an error or a default value\n    return -1; // or any other appropriate error handling\n}\n\nProvide a concise natural language description (docstring) of the PHP code in English using at most 500 characters.",
      "es": "function guessItemPrice(int $maxPrice, string $hints): int\n{\n    $low = 1;\n    $high = $maxPrice;\n\n    foreach (str_split($hints) as $hint) {\n        $mid = intdiv($low + $high, 2);\n\n        if ($hint === 'u') {\n            $low = $mid + 1;\n        } elseif ($hint === 'd') {\n            $high = $mid - 1;\n        } elseif ($hint === 'y') {\n            return $mid;\n        }\n    }\n\n    // In case the hints do not determine the price correctly, return an error or a default value\n    return -1; // or any other appropriate error handling\n}\n\nProporcione una descripción concisa en lenguaje natural (docstring) del código PHP en español utilizando un máximo de 500 caracteres.",
      "arb": "function guessItemPrice(int $maxPrice, string $hints): int\n{\n    $low = 1;\n    $high = $maxPrice;\n\n    foreach (str_split($hints) as $hint) {\n        $mid = intdiv($low + $high, 2);\n\n        if ($hint === 'u') {\n            $low = $mid + 1;\n        } elseif ($hint === 'd') {\n            $high = $mid - 1;\n        } elseif ($hint === 'y') {\n            return $mid;\n        }\n    }\n\n    // In case the hints do not determine the price correctly, return an error or a default value\n    return -1; // or any other appropriate error handling\n}\n\nيرجى تقديم وصف موجز بلغة طبيعية (docstring) للشفرة البرمجية بلغة PHP باللغة العربية الفصحى، بحيث لا يتجاوز 500 حرف.",
      "sw": "function guessItemPrice(int $maxPrice, string $hints): int\n{\n    $low = 1;\n    $high = $maxPrice;\n\n    foreach (str_split($hints) as $hint) {\n        $mid = intdiv($low + $high, 2);\n\n        if ($hint === 'u') {\n            $low = $mid + 1;\n        } elseif ($hint === 'd') {\n            $high = $mid - 1;\n        } elseif ($hint === 'y') {\n            return $mid;\n        }\n    }\n\n    // In case the hints do not determine the price correctly, return an error or a default value\n    return -1; // or any other appropriate error handling\n}\n\nToa maelezo mafupi ya lugha ya asili (docstring) ya msimbo wa PHP kwa Kiswahili kwa kutumia herufi zisizozidi 500.",
      "tr": "function guessItemPrice(int $maxPrice, string $hints): int\n{\n    $low = 1;\n    $high = $maxPrice;\n\n    foreach (str_split($hints) as $hint) {\n        $mid = intdiv($low + $high, 2);\n\n        if ($hint === 'u') {\n            $low = $mid + 1;\n        } elseif ($hint === 'd') {\n            $high = $mid - 1;\n        } elseif ($hint === 'y') {\n            return $mid;\n        }\n    }\n\n    // In case the hints do not determine the price correctly, return an error or a default value\n    return -1; // or any other appropriate error handling\n}\n\nPHP kodunun işlevini açıklayan kısa bir doğal dil açıklaması (docstring) sağlayın. Açıklama, en fazla 500 karakter kullanılarak Türkçe olarak yazılmalıdır.",
      "vi": "function guessItemPrice(int $maxPrice, string $hints): int\n{\n    $low = 1;\n    $high = $maxPrice;\n\n    foreach (str_split($hints) as $hint) {\n        $mid = intdiv($low + $high, 2);\n\n        if ($hint === 'u') {\n            $low = $mid + 1;\n        } elseif ($hint === 'd') {\n            $high = $mid - 1;\n        } elseif ($hint === 'y') {\n            return $mid;\n        }\n    }\n\n    // In case the hints do not determine the price correctly, return an error or a default value\n    return -1; // or any other appropriate error handling\n}\n\nCung cấp mô tả ngắn gọn bằng ngôn ngữ tự nhiên (docstring) cho mã PHP bằng tiếng Việt với tối đa 500 ký tự."
    },
    "instruction_bertscore": {
      "es": "0.9687069752502395",
      "arb": "0.8927997792466139",
      "sw": "0.9428367585331127",
      "tr": "0.881863190466833",
      "vi": "0.9017250367880356"
    },
    "level": "",
    "test": "function main(){\n    assert(guessItemPrice(1000000, \"uddy\") === 562500);\n    assert(guessItemPrice(500, \"ududy\") === 327);\n    assert(guessItemPrice(100, \"uuudy\") === 91);\n    assert(guessItemPrice(1000, \"ddduy\") === 93);\n    \n}\n\n\nmain();\n?>",
    "entry_point": "guessItemPrice",
    "signature": "function guessItemPrice(int $maxPrice, string $hints): int",
    "docstring": {
      "en": "Determines the exact price of an item within a specified range based on a series of hints.\nThe item's price is within the range [1, maxPrice].\nHints are given in a string where:\n- 'u' indicates the actual price is higher than the current guess.\n- 'd' indicates the actual price is lower than the current guess.\n- 'y' indicates the current guess is correct.\nThe function uses a binary search approach to narrow down the possible price.\nInput: The maximum price (maxPrice) and a string of hints.\nOutput: Returns the exact price of the item.\nExample: For maxPrice = 1000000 and hints = \"uddy\", the function returns 562500.",
      "es": "Determina el precio exacto de un artículo dentro de un rango especificado basado en una serie de pistas.  \nEl precio del artículo está dentro del rango [1, maxPrice].  \nLas pistas se dan en una cadena donde:  \n- 'u' indica que el precio real es mayor que la suposición actual.  \n- 'd' indica que el precio real es menor que la suposición actual.  \n- 'y' indica que la suposición actual es correcta.  \nLa función utiliza un enfoque de búsqueda binaria para reducir el posible precio.  \nEntrada: El precio máximo (maxPrice) y una cadena de pistas.  \nSalida: Devuelve el precio exacto del artículo.  \nEjemplo: Para maxPrice = 1000000 y hints = \"uddy\", la función devuelve 562500.",
      "arb": "يحدد السعر الدقيق لعنصر ما ضمن نطاق محدد بناءً على سلسلة من التلميحات.  \nسعر العنصر يقع ضمن النطاق [1، maxPrice].  \nيتم إعطاء التلميحات في سلسلة حيث:  \n- 'u' تشير إلى أن السعر الفعلي أعلى من التخمين الحالي.  \n- 'd' تشير إلى أن السعر الفعلي أقل من التخمين الحالي.  \n- 'y' تشير إلى أن التخمين الحالي صحيح.  \nتستخدم الدالة نهج البحث الثنائي لتضييق نطاق السعر المحتمل.  \nالمدخلات: السعر الأقصى (maxPrice) وسلسلة من التلميحات.  \nالمخرجات: تعيد السعر الدقيق للعنصر.  \nمثال: لـ maxPrice = 1000000 و hints = \"uddy\"، تعيد الدالة 562500.",
      "sw": "Inabainisha bei halisi ya bidhaa ndani ya kiwango maalum kulingana na mfululizo wa vihisishi. \nBei ya bidhaa iko ndani ya kiwango [1, maxPrice]. \nVihisishi vinatolewa katika kamba ambapo: \n- 'u' inaashiria kuwa bei halisi ni ya juu kuliko makisio ya sasa. \n- 'd' inaashiria kuwa bei halisi ni ya chini kuliko makisio ya sasa. \n- 'y' inaashiria kuwa makisio ya sasa ni sahihi. \nKazi hii inatumia mbinu ya utafutaji wa nusu ili kupunguza uwezekano wa bei. \nIngizo: Bei ya juu zaidi (maxPrice) na kamba ya vihisishi. \nPato: Inarudisha bei halisi ya bidhaa. \nMfano: Kwa maxPrice = 1000000 na vihisishi = \"uddy\", kazi inarudisha 562500.",
      "tr": "Belirtilen bir aralık içinde bir dizi ipucu temelinde bir öğenin tam fiyatını belirler.\nÖğenin fiyatı [1, maxPrice] aralığındadır.\nİpuçları, şu anki tahminle ilgili olarak:\n- 'u', gerçek fiyatın mevcut tahminden daha yüksek olduğunu belirtir.\n- 'd', gerçek fiyatın mevcut tahminden daha düşük olduğunu belirtir.\n- 'y', mevcut tahminin doğru olduğunu belirtir.\nFonksiyon, olası fiyatı daraltmak için ikili arama yaklaşımını kullanır.\nGirdi: Maksimum fiyat (maxPrice) ve bir ipucu dizisi.\nÇıktı: Öğenin tam fiyatını döndürür.\nÖrnek: maxPrice = 1000000 ve hints = \"uddy\" için, fonksiyon 562500 değerini döndürür.",
      "vi": "Xác định giá chính xác của một mặt hàng trong một phạm vi cụ thể dựa trên một loạt các gợi ý.  \nGiá của mặt hàng nằm trong phạm vi [1, maxPrice].  \nCác gợi ý được đưa ra trong một chuỗi nơi:  \n- 'u' chỉ ra rằng giá thực tế cao hơn so với dự đoán hiện tại.  \n- 'd' chỉ ra rằng giá thực tế thấp hơn so với dự đoán hiện tại.  \n- 'y' chỉ ra rằng dự đoán hiện tại là chính xác.  \nHàm sử dụng phương pháp tìm kiếm nhị phân để thu hẹp giá có thể có.  \nĐầu vào: Giá tối đa (maxPrice) và một chuỗi các gợi ý.  \nĐầu ra: Trả về giá chính xác của mặt hàng.  \nVí dụ: Với maxPrice = 1000000 và hints = \"uddy\", hàm trả về 562500.  "
    },
    "docstring_bertscore": {
      "es": "0.9746990579549191",
      "arb": "0.9798823177480245",
      "sw": "0.9379087387796371",
      "tr": "0.9588245179026108",
      "vi": "0.9744861261864497"
    }
  },
  {
    "task_id": "PHP/19",
    "prompt": {
      "en": "<?php\n\n/**\n * Calculates the total effort required to sort a list of disordered elements.\n * In this scenario, imagine a series of numbered containers in a warehouse. Each container must be arranged in ascending order. \n * The effort to swap two containers is proportional to the distance between them, measured as double their positional difference.\n * Input: An array of integers representing the unsorted container numbers.\n * Output: Returns an integer representing the total effort required to sort the containers.\n * Example: For input [3, 1, 4, 2], the output is 8.\n */\n\nfunction calculateEffort($horseNumbers) ",
      "es": "<?php\n\n/**\n * Calcula el esfuerzo total requerido para ordenar una lista de elementos desordenados.\n * En este escenario, imagina una serie de contenedores numerados en un almacén. Cada contenedor debe ser ordenado en orden ascendente.\n * El esfuerzo para intercambiar dos contenedores es proporcional a la distancia entre ellos, medida como el doble de su diferencia posicional.\n * Entrada: Un arreglo de enteros que representa los números de contenedores desordenados.\n * Salida: Devuelve un entero que representa el esfuerzo total requerido para ordenar los contenedores.\n * Ejemplo: Para la entrada [3, 1, 4, 2], la salida es 8.\n */\n\nfunction calculateEffort($horseNumbers) ",
      "arb": "<?php\n\n/**\n * يحسب الجهد الكلي المطلوب لترتيب قائمة من العناصر غير المرتبة.\n * في هذا السيناريو، تخيل سلسلة من الحاويات المرقمة في مستودع. يجب ترتيب كل حاوية بترتيب تصاعدي.\n * الجهد المبذول لتبديل حاويتين يتناسب مع المسافة بينهما، ويقاس على أنه ضعف الفرق في موضعهما.\n * المدخل: مصفوفة من الأعداد الصحيحة تمثل أرقام الحاويات غير المرتبة.\n * المخرج: يُرجع عددًا صحيحًا يمثل الجهد الكلي المطلوب لترتيب الحاويات.\n * مثال: للمدخل [3, 1, 4, 2]، يكون المخرج 8.\n */\n\nfunction calculateEffort($horseNumbers) ",
      "sw": "<?php\n\n/**\n * Hukokotoa juhudi jumla zinazohitajika kupanga orodha ya vipengele visivyopangwa.\n * Katika hali hii, fikiria mfululizo wa makontena yenye namba katika ghala. Kila kontena lazima lipangwe kwa mpangilio wa kupanda.\n * Juhudi za kubadilisha makontena mawili ni sawia na umbali kati yao, kipimo chake ni mara mbili ya tofauti ya nafasi zao.\n * Ingizo: Mfululizo wa nambari za mzima zikiwakilisha nambari za makontena yasiyopangwa.\n * Matokeo: Inarudisha nambari nzima inayowakilisha juhudi jumla zinazohitajika kupanga makontena.\n * Mfano: Kwa ingizo [3, 1, 4, 2], matokeo ni 8.\n */\n\nfunction calculateEffort($horseNumbers) ",
      "tr": "<?php\n\n/**\n * Düzensiz elemanlardan oluşan bir listeyi sıralamak için gereken toplam çabayı hesaplar.\n * Bu senaryoda, bir depodaki numaralandırılmış konteynerler serisini hayal edin. Her konteynerin artan sırayla düzenlenmesi gerekir.\n * İki konteyneri değiştirme çabası, aralarındaki mesafeye orantılıdır ve bu mesafe, konumsal farklarının iki katı olarak ölçülür.\n * Girdi: Sırasız konteyner numaralarını temsil eden bir tamsayı dizisi.\n * Çıktı: Konteynerleri sıralamak için gereken toplam çabayı temsil eden bir tamsayı döndürür.\n * Örnek: [3, 1, 4, 2] girişi için çıktı 8'dir.\n */\n\nfunction calculateEffort($horseNumbers) ",
      "vi": "<?php\n\n/**\n * Tính toán tổng công sức cần thiết để sắp xếp một danh sách các phần tử không theo thứ tự.\n * Trong kịch bản này, hãy tưởng tượng một loạt các thùng được đánh số trong một kho hàng. Mỗi thùng phải được sắp xếp theo thứ tự tăng dần.\n * Công sức để hoán đổi hai thùng tỷ lệ thuận với khoảng cách giữa chúng, được đo bằng gấp đôi sự khác biệt vị trí của chúng.\n * Đầu vào: Một mảng các số nguyên đại diện cho các số thùng chưa được sắp xếp.\n * Đầu ra: Trả về một số nguyên đại diện cho tổng công sức cần thiết để sắp xếp các thùng.\n * Ví dụ: Với đầu vào [3, 1, 4, 2], đầu ra là 8.\n */\n\nfunction calculateEffort($horseNumbers) "
    },
    "prompt_bertscore": {
      "es": "0.9783621994419645",
      "arb": "0.965230546321367",
      "sw": "0.9478549564795781",
      "tr": "0.9567222139497376",
      "vi": "0.9565740356854855"
    },
    "canonical_solution": "{\n    $effort = 0;\n    $n = count($horseNumbers);\n    for ($i = 0; $i < $n - 1; $i++) {\n        for ($j = $i + 1; $j < $n; $j++) {\n            if ($horseNumbers[$i] > $horseNumbers[$j]) {\n                // Swapping\n                $temp = $horseNumbers[$i];\n                $horseNumbers[$i] = $horseNumbers[$j];\n                $horseNumbers[$j] = $temp;\n                // Calculating effort\n                $effort += ($j - $i) * 2;\n            }\n        }\n    }\n    return $effort;\n}",
    "instruction": {
      "en": "function calculateEffort($horseNumbers)\n{\n    $effort = 0;\n    $n = count($horseNumbers);\n    for ($i = 0; $i < $n - 1; $i++) {\n        for ($j = $i + 1; $j < $n; $j++) {\n            if ($horseNumbers[$i] > $horseNumbers[$j]) {\n                // Swapping\n                $temp = $horseNumbers[$i];\n                $horseNumbers[$i] = $horseNumbers[$j];\n                $horseNumbers[$j] = $temp;\n                // Calculating effort\n                $effort += ($j - $i) * 2;\n            }\n        }\n    }\n    return $effort;\n}\n\nProvide a concise natural language description (docstring) of the PHP code in English using at most 500 characters.",
      "es": "function calculateEffort($horseNumbers)\n{\n    $effort = 0;\n    $n = count($horseNumbers);\n    for ($i = 0; $i < $n - 1; $i++) {\n        for ($j = $i + 1; $j < $n; $j++) {\n            if ($horseNumbers[$i] > $horseNumbers[$j]) {\n                // Swapping\n                $temp = $horseNumbers[$i];\n                $horseNumbers[$i] = $horseNumbers[$j];\n                $horseNumbers[$j] = $temp;\n                // Calculating effort\n                $effort += ($j - $i) * 2;\n            }\n        }\n    }\n    return $effort;\n}\n\nProporcione una descripción concisa en lenguaje natural (docstring) del código PHP en español utilizando como máximo 500 caracteres.",
      "arb": "function calculateEffort($horseNumbers)\n{\n    $effort = 0;\n    $n = count($horseNumbers);\n    for ($i = 0; $i < $n - 1; $i++) {\n        for ($j = $i + 1; $j < $n; $j++) {\n            if ($horseNumbers[$i] > $horseNumbers[$j]) {\n                // Swapping\n                $temp = $horseNumbers[$i];\n                $horseNumbers[$i] = $horseNumbers[$j];\n                $horseNumbers[$j] = $temp;\n                // Calculating effort\n                $effort += ($j - $i) * 2;\n            }\n        }\n    }\n    return $effort;\n}\n\nيرجى تقديم وصف موجز بلغة طبيعية (docstring) للكود المكتوب بلغة PHP باللغة العربية الفصحى، بحيث لا يتجاوز 500 حرف.",
      "sw": "function calculateEffort($horseNumbers)\n{\n    $effort = 0;\n    $n = count($horseNumbers);\n    for ($i = 0; $i < $n - 1; $i++) {\n        for ($j = $i + 1; $j < $n; $j++) {\n            if ($horseNumbers[$i] > $horseNumbers[$j]) {\n                // Swapping\n                $temp = $horseNumbers[$i];\n                $horseNumbers[$i] = $horseNumbers[$j];\n                $horseNumbers[$j] = $temp;\n                // Calculating effort\n                $effort += ($j - $i) * 2;\n            }\n        }\n    }\n    return $effort;\n}\n\nToa maelezo mafupi ya lugha ya asili (docstring) ya msimbo wa PHP kwa Kiswahili kwa kutumia herufi zisizozidi 500.",
      "tr": "function calculateEffort($horseNumbers)\n{\n    $effort = 0;\n    $n = count($horseNumbers);\n    for ($i = 0; $i < $n - 1; $i++) {\n        for ($j = $i + 1; $j < $n; $j++) {\n            if ($horseNumbers[$i] > $horseNumbers[$j]) {\n                // Swapping\n                $temp = $horseNumbers[$i];\n                $horseNumbers[$i] = $horseNumbers[$j];\n                $horseNumbers[$j] = $temp;\n                // Calculating effort\n                $effort += ($j - $i) * 2;\n            }\n        }\n    }\n    return $effort;\n}\n\nPHP kodunun işlevini açıklayan kısa bir doğal dil açıklaması (docstring) sağlayın. Açıklama, en fazla 500 karakter kullanılarak Türkçe olarak yazılmalıdır.",
      "vi": "function calculateEffort($horseNumbers)\n{\n    $effort = 0;\n    $n = count($horseNumbers);\n    for ($i = 0; $i < $n - 1; $i++) {\n        for ($j = $i + 1; $j < $n; $j++) {\n            if ($horseNumbers[$i] > $horseNumbers[$j]) {\n                // Swapping\n                $temp = $horseNumbers[$i];\n                $horseNumbers[$i] = $horseNumbers[$j];\n                $horseNumbers[$j] = $temp;\n                // Calculating effort\n                $effort += ($j - $i) * 2;\n            }\n        }\n    }\n    return $effort;\n}\n\nCung cấp mô tả ngắn gọn bằng ngôn ngữ tự nhiên (docstring) cho mã PHP bằng tiếng Việt với tối đa 500 ký tự."
    },
    "instruction_bertscore": {
      "es": "0.9687069752502395",
      "arb": "0.8833251100712498",
      "sw": "0.91585798565943",
      "tr": "0.881863190466833",
      "vi": "0.9017250367880356"
    },
    "level": "",
    "test": "function main(){\n    assert(calculateEffort([2, 3, 6, 5, 8, 4]) === 14);\n    assert(calculateEffort([3, 1, 4, 2]) === 8);\n    assert(calculateEffort([1, 2, 3, 4]) === 0); // Already sorted\n    assert(calculateEffort([4, 3, 2, 1]) === 20); // Reverse order\n    \n}\n\n\nmain();\n?>",
    "entry_point": "calculateEffort",
    "signature": "function calculateEffort($horseNumbers)",
    "docstring": {
      "en": "Calculates the total effort required to sort a list of disordered elements.\nIn this scenario, imagine a series of numbered containers in a warehouse. Each container must be arranged in ascending order.\nThe effort to swap two containers is proportional to the distance between them, measured as double their positional difference.\nInput: An array of integers representing the unsorted container numbers.\nOutput: Returns an integer representing the total effort required to sort the containers.\nExample: For input [3, 1, 4, 2], the output is 8.",
      "es": "Calcula el esfuerzo total requerido para ordenar una lista de elementos desordenados.  \nEn este escenario, imagina una serie de contenedores numerados en un almacén. Cada contenedor debe ser ordenado en orden ascendente.  \nEl esfuerzo para intercambiar dos contenedores es proporcional a la distancia entre ellos, medida como el doble de su diferencia posicional.  \nEntrada: Un arreglo de enteros que representa los números de los contenedores desordenados.  \nSalida: Devuelve un entero que representa el esfuerzo total requerido para ordenar los contenedores.  \nEjemplo: Para la entrada [3, 1, 4, 2], la salida es 8.",
      "arb": "يحسب الجهد الكلي المطلوب لترتيب قائمة من العناصر غير المرتبة. في هذا السيناريو، تخيل سلسلة من الحاويات المرقمة في مستودع. يجب ترتيب كل حاوية بترتيب تصاعدي. الجهد المطلوب لتبديل حاويتين يتناسب مع المسافة بينهما، مقاسة بمضاعفة الفرق في مواقعها. \n\nيعيدالحجج:\n    المدخلات: مصفوفة من الأعداد الصحيحة تمثل أرقام الحاويات غير المرتبة.\n   الناتج: يُرجع عددًا صحيحًا يمثل الجهد الكلي المطلوب لترتيب الحاويات.\n   مثال: للمدخل [3, 1, 4, 2]، يكون المخرج 8",
      "sw": "Hesabu juhudi jumla zinazohitajika kupanga orodha ya vipengele visivyopangwa.\nKatika hali hii, fikiria mfululizo wa makontena yenye namba kwenye ghala. Kila kontena lazima lipangwe kwa mpangilio wa kupanda.\nJuhudi za kubadilisha makontena mawili zinategemea umbali kati yao, kipimo chake ni mara mbili ya tofauti ya nafasi zao.\nIngizo: Safu ya nambari za mzima zinazoonyesha namba za makontena yasiyopangwa.\nPato: Inarudisha nambari nzima inayowakilisha juhudi jumla zinazohitajika kupanga makontena.\nMfano: Kwa ingizo [3, 1, 4, 2], pato ni 8.",
      "tr": "Bir dizi düzensiz elemanı sıralamak için gereken toplam çabayı hesaplar.\nBu senaryoda, bir depodaki numaralandırılmış konteyner serisini hayal edin. Her konteyner artan sırayla düzenlenmelidir.\nİki konteyneri değiştirme çabası, aralarındaki mesafeye orantılıdır ve bu mesafe, konumsal farklarının iki katı olarak ölçülür.\nGirdi: Sırasız konteyner numaralarını temsil eden bir tamsayı dizisi.\nÇıktı: Konteynerleri sıralamak için gereken toplam çabayı temsil eden bir tamsayı döndürür.\nÖrnek: Girdi [3, 1, 4, 2] için, çıktı 8'dir.",
      "vi": "Tính toán tổng công sức cần thiết để sắp xếp một danh sách các phần tử không theo thứ tự.  \nTrong tình huống này, hãy tưởng tượng một loạt các thùng chứa được đánh số trong một nhà kho. Mỗi thùng chứa phải được sắp xếp theo thứ tự tăng dần.  \nCông sức để hoán đổi hai thùng chứa tỷ lệ thuận với khoảng cách giữa chúng, được đo bằng gấp đôi sự khác biệt về vị trí của chúng.  \nĐầu vào: Một mảng các số nguyên đại diện cho các số thùng chứa chưa được sắp xếp.  \nĐầu ra: Trả về một số nguyên đại diện cho tổng công sức cần thiết để sắp xếp các thùng chứa.  \nVí dụ: Với đầu vào [3, 1, 4, 2], đầu ra là 8."
    },
    "docstring_bertscore": {
      "es": "0.973901755605445",
      "arb": "0.9416453735076654",
      "sw": "0.9494062597554606",
      "tr": "0.9562929736963212",
      "vi": "0.9625857827978874"
    }
  },
  {
    "task_id": "PHP/20",
    "prompt": {
      "en": "<?php\n/**\n * Determines the ranking of a player at the time of their entry in a competition.\n * \n * In this competition, scores are announced one after another, updating the leaderboard each time.\n * This function calculates the rank of a specific player at the time they were added to the leaderboard.\n * \n * Input: \n * - $scores: An array of integers representing the scores of each player.\n * - $playerIndex: An integer representing the index of the player (1-based index).\n * \n * Output: \n * - Returns an integer, the rank of the player at the time of their entry.\n * \n * Example: \n * For scores [95, 92, 93, 100, 102, 99] and playerIndex 3, the function should return 2.\n */\n\n\nfunction getPlayerRankingAtEntry($scores, $playerIndex) ",
      "es": "<?php\n/**\n * Determina la clasificación de un jugador en el momento de su entrada en una competencia.\n * \n * En esta competencia, las puntuaciones se anuncian una tras otra, actualizando la tabla de clasificación cada vez.\n * Esta función calcula la clasificación de un jugador específico en el momento en que se añadió a la tabla de clasificación.\n * \n * Entrada: \n * - $scores: Un arreglo de enteros que representa las puntuaciones de cada jugador.\n * - $playerIndex: Un entero que representa el índice del jugador (índice basado en 1).\n * \n * Salida: \n * - Devuelve un entero, la clasificación del jugador en el momento de su entrada.\n * \n * Ejemplo: \n * Para puntuaciones [95, 92, 93, 100, 102, 99] y playerIndex 3, la función debería devolver 2.\n */\n\n\nfunction getPlayerRankingAtEntry($scores, $playerIndex) ",
      "arb": "<?php\n/**\n * يحدد ترتيب اللاعب في وقت دخوله في مسابقة.\n * \n * في هذه المسابقة، يتم الإعلان عن الدرجات واحدة تلو الأخرى، مما يحدث تحديثًا للوحة الصدارة في كل مرة.\n * تقوم هذه الدالة بحساب ترتيب لاعب معين في الوقت الذي أُضيف فيه إلى لوحة الصدارة.\n * \n * المدخلات:\n * - $scores: مصفوفة من الأعداد الصحيحة تمثل درجات كل لاعب.\n * - $playerIndex: عدد صحيح يمثل مؤشر اللاعب (مؤشر يبدأ من 1).\n * \n * المخرجات:\n * - تُرجع عددًا صحيحًا، وهو ترتيب اللاعب في وقت دخوله.\n * \n * مثال:\n * للدرجات [95, 92, 93, 100, 102, 99] و playerIndex 3، يجب أن تُرجع الدالة 2.\n */\n\n\nfunction getPlayerRankingAtEntry($scores, $playerIndex) ",
      "sw": "<?php\n/**\n * Huamua cheo cha mchezaji wakati wa kuingia kwao kwenye mashindano.\n * \n * Katika mashindano haya, alama zinatangazwa moja baada ya nyingine, zikisasisha ubao wa viongozi kila wakati.\n * Kazi hii inahesabu cheo cha mchezaji maalum wakati waliongezwa kwenye ubao wa viongozi.\n * \n * Ingizo: \n * - $scores: Safu ya nambari za mzima inayoonyesha alama za kila mchezaji.\n * - $playerIndex: Nambari ya mzima inayoonyesha faharasa ya mchezaji (faharasa ya kuanzia 1).\n * \n * Tokeo: \n * - Inarudisha nambari ya mzima, cheo cha mchezaji wakati wa kuingia kwao.\n * \n * Mfano: \n * Kwa alama [95, 92, 93, 100, 102, 99] na playerIndex 3, kazi inapaswa kurudisha 2.\n */\n\n\nfunction getPlayerRankingAtEntry($scores, $playerIndex) ",
      "tr": "<?php\n/**\n * Bir oyuncunun bir yarışmaya katıldığı zamandaki sıralamasını belirler.\n * \n * Bu yarışmada, skorlar birbiri ardına açıklanır ve her seferinde liderlik tablosu güncellenir.\n * Bu fonksiyon, belirli bir oyuncunun liderlik tablosuna eklendiği zamandaki sıralamasını hesaplar.\n * \n * Girdi: \n * - $scores: Her oyuncunun skorunu temsil eden bir tamsayı dizisi.\n * - $playerIndex: Oyuncunun indeksini temsil eden bir tamsayı (1 tabanlı indeks).\n * \n * Çıktı: \n * - Oyuncunun katıldığı zamandaki sıralamasını belirten bir tamsayı döndürür.\n * \n * Örnek: \n * Skorlar [95, 92, 93, 100, 102, 99] ve playerIndex 3 için, fonksiyon 2 döndürmelidir.\n */\n\n\nfunction getPlayerRankingAtEntry($scores, $playerIndex) ",
      "vi": "<?php\n/**\n * Xác định xếp hạng của một người chơi tại thời điểm họ tham gia vào một cuộc thi.\n * \n * Trong cuộc thi này, điểm số được công bố lần lượt, cập nhật bảng xếp hạng mỗi lần.\n * Hàm này tính toán xếp hạng của một người chơi cụ thể tại thời điểm họ được thêm vào bảng xếp hạng.\n * \n * Đầu vào: \n * - $scores: Một mảng các số nguyên đại diện cho điểm số của mỗi người chơi.\n * - $playerIndex: Một số nguyên đại diện cho chỉ số của người chơi (chỉ số bắt đầu từ 1).\n * \n * Đầu ra: \n * - Trả về một số nguyên, xếp hạng của người chơi tại thời điểm họ tham gia.\n * \n * Ví dụ: \n * Với điểm số [95, 92, 93, 100, 102, 99] và playerIndex 3, hàm nên trả về 2.\n */\n\n\nfunction getPlayerRankingAtEntry($scores, $playerIndex) "
    },
    "prompt_bertscore": {
      "es": "0.9897018092648652",
      "arb": "0.9688750165525951",
      "sw": "0.9608986163413771",
      "tr": "0.9576835849939463",
      "vi": "0.9541795464421099"
    },
    "canonical_solution": "{\n    $playerScore = $scores[$playerIndex - 1];\n    $rank = 1;\n\n    for ($i = 0; $i < $playerIndex - 1; $i++) {\n        if ($scores[$i] >= $playerScore) {\n            $rank++;\n        }\n    }\n\n    return $rank;\n}",
    "instruction": {
      "en": "function getPlayerRankingAtEntry($scores, $playerIndex)\n{\n    $playerScore = $scores[$playerIndex - 1];\n    $rank = 1;\n\n    for ($i = 0; $i < $playerIndex - 1; $i++) {\n        if ($scores[$i] >= $playerScore) {\n            $rank++;\n        }\n    }\n\n    return $rank;\n}\n\nProvide a concise natural language description (docstring) of the PHP code in English using at most 500 characters.",
      "es": "function getPlayerRankingAtEntry($scores, $playerIndex)\n{\n    $playerScore = $scores[$playerIndex - 1];\n    $rank = 1;\n\n    for ($i = 0; $i < $playerIndex - 1; $i++) {\n        if ($scores[$i] >= $playerScore) {\n            $rank++;\n        }\n    }\n\n    return $rank;\n}\n\nProporcione una descripción concisa en lenguaje natural (docstring) del código PHP en español utilizando como máximo 500 caracteres.",
      "arb": "function getPlayerRankingAtEntry($scores, $playerIndex)\n{\n    $playerScore = $scores[$playerIndex - 1];\n    $rank = 1;\n\n    for ($i = 0; $i < $playerIndex - 1; $i++) {\n        if ($scores[$i] >= $playerScore) {\n            $rank++;\n        }\n    }\n\n    return $rank;\n}\n\nيرجى تقديم وصف موجز بلغة طبيعية (docstring) لشيفرة PHP باللغة العربية الفصحى، باستخدام 500 حرف كحد أقصى.",
      "sw": "function getPlayerRankingAtEntry($scores, $playerIndex)\n{\n    $playerScore = $scores[$playerIndex - 1];\n    $rank = 1;\n\n    for ($i = 0; $i < $playerIndex - 1; $i++) {\n        if ($scores[$i] >= $playerScore) {\n            $rank++;\n        }\n    }\n\n    return $rank;\n}\n\nToa maelezo mafupi ya lugha ya asili (docstring) ya msimbo wa PHP kwa Kiswahili kwa kutumia herufi zisizozidi 500.",
      "tr": "function getPlayerRankingAtEntry($scores, $playerIndex)\n{\n    $playerScore = $scores[$playerIndex - 1];\n    $rank = 1;\n\n    for ($i = 0; $i < $playerIndex - 1; $i++) {\n        if ($scores[$i] >= $playerScore) {\n            $rank++;\n        }\n    }\n\n    return $rank;\n}\n\nPHP kodunun işlevini açıklayan kısa bir doğal dil açıklaması (docstring) sağlayın. Açıklama, en fazla 500 karakter kullanılarak Türkçe olarak yazılmalıdır.",
      "vi": "function getPlayerRankingAtEntry($scores, $playerIndex)\n{\n    $playerScore = $scores[$playerIndex - 1];\n    $rank = 1;\n\n    for ($i = 0; $i < $playerIndex - 1; $i++) {\n        if ($scores[$i] >= $playerScore) {\n            $rank++;\n        }\n    }\n\n    return $rank;\n}\n\nCung cấp mô tả ngắn gọn bằng ngôn ngữ tự nhiên (docstring) cho mã PHP bằng tiếng Việt với tối đa 500 ký tự."
    },
    "instruction_bertscore": {
      "es": "0.946829825083057",
      "arb": "0.924580242951434",
      "sw": "0.91585798565943",
      "tr": "0.869166935141464",
      "vi": "0.9017250367880356"
    },
    "level": "",
    "test": "function main(){\n    assert(getPlayerRankingAtEntry([95, 92, 93, 100, 102, 99], 3) === 2);\n    assert(getPlayerRankingAtEntry([90, 85, 95, 88, 92], 5) === 2);\n    assert(getPlayerRankingAtEntry([100, 105, 95, 110, 90], 1) === 1);\n    assert(getPlayerRankingAtEntry([70, 80, 60, 90, 85], 4) === 1);\n    assert(getPlayerRankingAtEntry([95, 95, 95, 95, 95], 3) === 3);\n    \n}\n\n\nmain();\n?>",
    "entry_point": "getPlayerRankingAtEntry",
    "signature": "function getPlayerRankingAtEntry($scores, $playerIndex)",
    "docstring": {
      "en": "Determines the ranking of a player at the time of their entry in a competition.\n\nIn this competition, scores are announced one after another, updating the leaderboard each time.\nThis function calculates the rank of a specific player at the time they were added to the leaderboard.\n\nInput:\n- $scores: An array of integers representing the scores of each player.\n- $playerIndex: An integer representing the index of the player (1-based index).\n\nOutput:\n- Returns an integer, the rank of the player at the time of their entry.\n\nExample:\nFor scores [95, 92, 93, 100, 102, 99] and playerIndex 3, the function should return 2.",
      "es": "Determina la clasificación de un jugador en el momento de su entrada en una competición.\n\nEn esta competición, las puntuaciones se anuncian una tras otra, actualizando la tabla de clasificación cada vez.\nEsta función calcula la clasificación de un jugador específico en el momento en que se añadió a la tabla de clasificación.\n\nEntrada:\n- $scores: Un array de enteros que representa las puntuaciones de cada jugador.\n- $playerIndex: Un entero que representa el índice del jugador (índice basado en 1).\n\nSalida:\n- Devuelve un entero, la clasificación del jugador en el momento de su entrada.\n\nEjemplo:\nPara scores [95, 92, 93, 100, 102, 99] y playerIndex 3, la función debería devolver 2.",
      "arb": "يحدد ترتيب اللاعب في وقت دخوله في المسابقة.\n\nفي هذه المسابقة، يتم الإعلان عن الدرجات واحدة تلو الأخرى، مما يحدث تحديثًا للوحة الصدارة في كل مرة.\nتقوم هذه الدالة بحساب ترتيب لاعب معين في الوقت الذي تمت إضافته إلى لوحة الصدارة.\n\nالمدخلات:\n- $scores: مصفوفة من الأعداد الصحيحة تمثل درجات كل لاعب.\n- $playerIndex: عدد صحيح يمثل مؤشر اللاعب (مؤشر يبدأ من 1).\n\nالمخرجات:\n- تعيد عددًا صحيحًا، وهو ترتيب اللاعب في وقت دخوله.\n\nمثال:\nبالنسبة للدرجات [95, 92, 93, 100, 102, 99] وplayerIndex 3، يجب أن تعيد الدالة 2.",
      "sw": "Inabainisha nafasi ya mchezaji wakati wa kuingia kwake katika mashindano.\n\nKatika mashindano haya, alama zinatangazwa moja baada ya nyingine, zikisasisha ubao wa viongozi kila wakati.\nKazi hii inahesabu nafasi ya mchezaji maalum wakati aliongezwa kwenye ubao wa viongozi.\n\nIngizo:\n- $scores: Kundi la namba za mzima linalowakilisha alama za kila mchezaji.\n- $playerIndex: Namba ya mzima inayowakilisha faharasa ya mchezaji (faharasa inayotegemea 1).\n\nMatokeo:\n- Inarudisha namba ya mzima, nafasi ya mchezaji wakati wa kuingia kwake.\n\nMfano:\nKwa alama [95, 92, 93, 100, 102, 99] na playerIndex 3, kazi inapaswa kurudisha 2.",
      "tr": "Bir oyuncunun bir yarışmaya katıldığı zamandaki sıralamasını belirler.\n\nBu yarışmada, puanlar birbiri ardına açıklanır ve her seferinde liderlik tablosu güncellenir. Bu fonksiyon, belirli bir oyuncunun liderlik tablosuna eklendiği zamandaki sıralamasını hesaplar.\n\nGirdi:\n- $scores: Her oyuncunun puanlarını temsil eden bir tamsayı dizisi.\n- $playerIndex: Oyuncunun indeksini temsil eden bir tamsayı (1 tabanlı indeks).\n\nÇıktı:\n- Oyuncunun katıldığı zamandaki sıralamasını belirten bir tamsayı döndürür.\n\nÖrnek:\nscores [95, 92, 93, 100, 102, 99] ve playerIndex 3 için, fonksiyon 2 döndürmelidir.",
      "vi": "Xác định thứ hạng của một người chơi tại thời điểm họ tham gia vào một cuộc thi.\n\nTrong cuộc thi này, điểm số được công bố lần lượt, cập nhật bảng xếp hạng mỗi lần.\nHàm này tính toán thứ hạng của một người chơi cụ thể tại thời điểm họ được thêm vào bảng xếp hạng.\n\nĐầu vào:\n- $scores: Một mảng các số nguyên đại diện cho điểm số của từng người chơi.\n- $playerIndex: Một số nguyên đại diện cho chỉ số của người chơi (chỉ số bắt đầu từ 1).\n\nĐầu ra:\n- Trả về một số nguyên, thứ hạng của người chơi tại thời điểm họ tham gia.\n\nVí dụ:\nVới scores [95, 92, 93, 100, 102, 99] và playerIndex 3, hàm nên trả về 2."
    },
    "docstring_bertscore": {
      "es": "0.9867549289318316",
      "arb": "0.9646803401659003",
      "sw": "0.9464643451819528",
      "tr": "0.9526151335610792",
      "vi": "0.9402412553441297"
    }
  },
  {
    "task_id": "PHP/21",
    "prompt": {
      "en": "<?php\n\n\n/**\n * Determines if two months in a given year are \"related\".\n * Two months are considered related if the first day of each month falls on the same day of the week.\n * This condition is true if the difference in days between the first day of these months is divisible by 7.\n * Leap years are taken into account, as February has 29 days in a leap year.\n *\n * Input: \n * - $year: An integer representing the year.\n * - $month1: An integer representing the first month.\n * - $month2: An integer representing the second month.\n *\n * Output: \n * - Returns 'YES' if the months are related; 'NO' otherwise.\n *\n * Examples:\n * - areRelatedMonths(1994, 10, 9) -> 'NO'\n * - areRelatedMonths(1948, 1, 4) -> 'YES'\n */\nfunction areRelatedMonths($year, $month1, $month2): string ",
      "es": "<?php\n\n\n/**\n * Determina si dos meses en un año dado están \"relacionados\".\n * Se considera que dos meses están relacionados si el primer día de cada mes cae en el mismo día de la semana.\n * Esta condición es verdadera si la diferencia en días entre el primer día de estos meses es divisible por 7.\n * Se tienen en cuenta los años bisiestos, ya que febrero tiene 29 días en un año bisiesto.\n *\n * Entrada: \n * - $year: Un entero que representa el año.\n * - $month1: Un entero que representa el primer mes.\n * - $month2: Un entero que representa el segundo mes.\n *\n * Salida: \n * - Devuelve 'YES' si los meses están relacionados; 'NO' en caso contrario.\n *\n * Ejemplos:\n * - areRelatedMonths(1994, 10, 9) -> 'NO'\n * - areRelatedMonths(1948, 1, 4) -> 'YES'\n */\nfunction areRelatedMonths($year, $month1, $month2): string ",
      "arb": "<?php\n\n\n/**\n * يحدد ما إذا كان هناك شهران في سنة معينة \"مرتبطان\".\n * يعتبر الشهران مرتبطين إذا كان اليوم الأول من كل شهر يقع في نفس اليوم من الأسبوع.\n * تكون هذه الحالة صحيحة إذا كان الفرق في الأيام بين اليوم الأول من هذه الأشهر قابلاً للقسمة على 7.\n * يتم أخذ السنوات الكبيسة في الاعتبار، حيث يحتوي شهر فبراير على 29 يومًا في السنة الكبيسة.\n *\n * المدخلات:\n * - $year: عدد صحيح يمثل السنة.\n * - $month1: عدد صحيح يمثل الشهر الأول.\n * - $month2: عدد صحيح يمثل الشهر الثاني.\n *\n * المخرجات:\n * - يعيد 'YES' إذا كانت الأشهر مرتبطة؛ 'NO' خلاف ذلك.\n *\n * أمثلة:\n * - areRelatedMonths(1994, 10, 9) -> 'NO'\n * - areRelatedMonths(1948, 1, 4) -> 'YES'\n */\nfunction areRelatedMonths($year, $month1, $month2): string ",
      "sw": "<?php\n\n\n/**\n * Inabainisha ikiwa miezi miwili katika mwaka fulani ni \"inayohusiana\".\n * Miezi miwili inachukuliwa kuwa inayohusiana ikiwa siku ya kwanza ya kila mwezi inaangukia siku moja ya wiki.\n * Hali hii ni kweli ikiwa tofauti ya siku kati ya siku ya kwanza ya miezi hii inagawanyika kwa 7.\n * Miaka ya kuruka inazingatiwa, kwani Februari ina siku 29 katika mwaka wa kuruka.\n *\n * Ingizo: \n * - $year: Nambari nzima inayowakilisha mwaka.\n * - $month1: Nambari nzima inayowakilisha mwezi wa kwanza.\n * - $month2: Nambari nzima inayowakilisha mwezi wa pili.\n *\n * Matokeo: \n * - Inarudisha 'YES' ikiwa miezi inahusiana; 'NO' vinginevyo.\n *\n * Mifano:\n * - areRelatedMonths(1994, 10, 9) -> 'NO'\n * - areRelatedMonths(1948, 1, 4) -> 'YES'\n */\nfunction areRelatedMonths($year, $month1, $month2): string ",
      "tr": "<?php\n\n\n/**\n * Belirli bir yıldaki iki ayın \"ilişkili\" olup olmadığını belirler.\n * İki ay, her ayın ilk günü haftanın aynı gününe denk geliyorsa ilişkili kabul edilir.\n * Bu koşul, bu ayların ilk günü arasındaki gün farkının 7'ye bölünebilir olması durumunda doğrudur.\n * Artık yıllar dikkate alınır, çünkü Şubat ayı artık yılda 29 gündür.\n *\n * Girdi: \n * - $year: Yılı temsil eden bir tamsayı.\n * - $month1: İlk ayı temsil eden bir tamsayı.\n * - $month2: İkinci ayı temsil eden bir tamsayı.\n *\n * Çıktı: \n * - Aylar ilişkiliyse 'YES' döner; aksi takdirde 'NO' döner.\n *\n * Örnekler:\n * - areRelatedMonths(1994, 10, 9) -> 'NO'\n * - areRelatedMonths(1948, 1, 4) -> 'YES'\n */\nfunction areRelatedMonths($year, $month1, $month2): string ",
      "vi": "<?php\n\n\n/**\n * Xác định xem hai tháng trong một năm nhất định có \"liên quan\" hay không.\n * Hai tháng được coi là liên quan nếu ngày đầu tiên của mỗi tháng rơi vào cùng một ngày trong tuần.\n * Điều kiện này đúng nếu chênh lệch số ngày giữa ngày đầu tiên của các tháng này chia hết cho 7.\n * Năm nhuận được tính đến, vì tháng Hai có 29 ngày trong năm nhuận.\n *\n * Đầu vào: \n * - $year: Một số nguyên đại diện cho năm.\n * - $month1: Một số nguyên đại diện cho tháng đầu tiên.\n * - $month2: Một số nguyên đại diện cho tháng thứ hai.\n *\n * Đầu ra: \n * - Trả về 'YES' nếu các tháng có liên quan; 'NO' nếu không.\n *\n * Ví dụ:\n * - areRelatedMonths(1994, 10, 9) -> 'NO'\n * - areRelatedMonths(1948, 1, 4) -> 'YES'\n */\nfunction areRelatedMonths($year, $month1, $month2): string "
    },
    "prompt_bertscore": {
      "es": "0.999999801369619",
      "arb": "0.9816245048200815",
      "sw": "0.999999801369619",
      "tr": "0.9912260988089269",
      "vi": "0.9894026719110266"
    },
    "canonical_solution": "{\n    // Check for leap year\n    $isLeapYear = ($year % 4 == 0) && ($year % 100 != 0 || $year % 400 == 0);\n\n    // Days in each month\n    $daysInMonth = [31, $isLeapYear ? 29 : 28, 31, 30, 31, 30, 31, 31, 30, 31, 30, 31];\n\n    // Calculate the day of the year for the first day of each month\n    $dayOfYear1 = array_sum(array_slice($daysInMonth, 0, $month1 - 1));\n    $dayOfYear2 = array_sum(array_slice($daysInMonth, 0, $month2 - 1));\n\n    // Check if the difference in days is divisible by 7\n    return abs($dayOfYear1 - $dayOfYear2) % 7 == 0 ? 'YES' : 'NO';\n}",
    "instruction": {
      "en": "function areRelatedMonths($year, $month1, $month2): string\n{\n    // Check for leap year\n    $isLeapYear = ($year % 4 == 0) && ($year % 100 != 0 || $year % 400 == 0);\n\n    // Days in each month\n    $daysInMonth = [31, $isLeapYear ? 29 : 28, 31, 30, 31, 30, 31, 31, 30, 31, 30, 31];\n\n    // Calculate the day of the year for the first day of each month\n    $dayOfYear1 = array_sum(array_slice($daysInMonth, 0, $month1 - 1));\n    $dayOfYear2 = array_sum(array_slice($daysInMonth, 0, $month2 - 1));\n\n    // Check if the difference in days is divisible by 7\n    return abs($dayOfYear1 - $dayOfYear2) % 7 == 0 ? 'YES' : 'NO';\n}\n\nProvide a concise natural language description (docstring) of the PHP code in English using at most 500 characters.",
      "es": "function areRelatedMonths($year, $month1, $month2): string\n{\n    // Check for leap year\n    $isLeapYear = ($year % 4 == 0) && ($year % 100 != 0 || $year % 400 == 0);\n\n    // Days in each month\n    $daysInMonth = [31, $isLeapYear ? 29 : 28, 31, 30, 31, 30, 31, 31, 30, 31, 30, 31];\n\n    // Calculate the day of the year for the first day of each month\n    $dayOfYear1 = array_sum(array_slice($daysInMonth, 0, $month1 - 1));\n    $dayOfYear2 = array_sum(array_slice($daysInMonth, 0, $month2 - 1));\n\n    // Check if the difference in days is divisible by 7\n    return abs($dayOfYear1 - $dayOfYear2) % 7 == 0 ? 'YES' : 'NO';\n}\n\nProporcione una descripción concisa en lenguaje natural (docstring) del código PHP en español utilizando un máximo de 500 caracteres.",
      "arb": "function areRelatedMonths($year, $month1, $month2): string\n{\n    // Check for leap year\n    $isLeapYear = ($year % 4 == 0) && ($year % 100 != 0 || $year % 400 == 0);\n\n    // Days in each month\n    $daysInMonth = [31, $isLeapYear ? 29 : 28, 31, 30, 31, 30, 31, 31, 30, 31, 30, 31];\n\n    // Calculate the day of the year for the first day of each month\n    $dayOfYear1 = array_sum(array_slice($daysInMonth, 0, $month1 - 1));\n    $dayOfYear2 = array_sum(array_slice($daysInMonth, 0, $month2 - 1));\n\n    // Check if the difference in days is divisible by 7\n    return abs($dayOfYear1 - $dayOfYear2) % 7 == 0 ? 'YES' : 'NO';\n}\n\nيرجى تقديم وصف موجز بلغة طبيعية (docstring) لشيفرة PHP باللغة العربية الفصحى، بحيث لا يتجاوز 500 حرف.",
      "sw": "function areRelatedMonths($year, $month1, $month2): string\n{\n    // Check for leap year\n    $isLeapYear = ($year % 4 == 0) && ($year % 100 != 0 || $year % 400 == 0);\n\n    // Days in each month\n    $daysInMonth = [31, $isLeapYear ? 29 : 28, 31, 30, 31, 30, 31, 31, 30, 31, 30, 31];\n\n    // Calculate the day of the year for the first day of each month\n    $dayOfYear1 = array_sum(array_slice($daysInMonth, 0, $month1 - 1));\n    $dayOfYear2 = array_sum(array_slice($daysInMonth, 0, $month2 - 1));\n\n    // Check if the difference in days is divisible by 7\n    return abs($dayOfYear1 - $dayOfYear2) % 7 == 0 ? 'YES' : 'NO';\n}\n\nToa maelezo mafupi ya lugha asilia (docstring) ya msimbo wa PHP kwa Kiswahili kwa kutumia herufi zisizozidi 500.",
      "tr": "function areRelatedMonths($year, $month1, $month2): string\n{\n    // Check for leap year\n    $isLeapYear = ($year % 4 == 0) && ($year % 100 != 0 || $year % 400 == 0);\n\n    // Days in each month\n    $daysInMonth = [31, $isLeapYear ? 29 : 28, 31, 30, 31, 30, 31, 31, 30, 31, 30, 31];\n\n    // Calculate the day of the year for the first day of each month\n    $dayOfYear1 = array_sum(array_slice($daysInMonth, 0, $month1 - 1));\n    $dayOfYear2 = array_sum(array_slice($daysInMonth, 0, $month2 - 1));\n\n    // Check if the difference in days is divisible by 7\n    return abs($dayOfYear1 - $dayOfYear2) % 7 == 0 ? 'YES' : 'NO';\n}\n\nAşağıdaki PHP kodunun işlevini açıklayan en fazla 500 karakterlik özlü bir doğal dil açıklaması (docstring) sağlayın.",
      "vi": "function areRelatedMonths($year, $month1, $month2): string\n{\n    // Check for leap year\n    $isLeapYear = ($year % 4 == 0) && ($year % 100 != 0 || $year % 400 == 0);\n\n    // Days in each month\n    $daysInMonth = [31, $isLeapYear ? 29 : 28, 31, 30, 31, 30, 31, 31, 30, 31, 30, 31];\n\n    // Calculate the day of the year for the first day of each month\n    $dayOfYear1 = array_sum(array_slice($daysInMonth, 0, $month1 - 1));\n    $dayOfYear2 = array_sum(array_slice($daysInMonth, 0, $month2 - 1));\n\n    // Check if the difference in days is divisible by 7\n    return abs($dayOfYear1 - $dayOfYear2) % 7 == 0 ? 'YES' : 'NO';\n}\n\nCung cấp mô tả ngắn gọn bằng ngôn ngữ tự nhiên (docstring) cho mã PHP bằng tiếng Việt với tối đa 500 ký tự."
    },
    "instruction_bertscore": {
      "es": "0.9687069752502395",
      "arb": "0.905616007322128",
      "sw": "0.9428367585331127",
      "tr": "0.8640365110297139",
      "vi": "0.9222151510044516"
    },
    "level": "",
    "test": "function main(){\n    assert(areRelatedMonths(1994, 10, 9) === 'NO');\n    assert(areRelatedMonths(1935, 12, 1) === 'NO');\n    assert(areRelatedMonths(1957, 1, 9) === 'NO');\n    assert(areRelatedMonths(1917, 9, 12) === 'YES');\n    assert(areRelatedMonths(1948, 1, 4) === 'YES');\n    \n}\n\nmain();\n?>",
    "entry_point": "areRelatedMonths",
    "signature": "function areRelatedMonths($year, $month1, $month2): string",
    "docstring": {
      "en": "Determines if two months in a given year are \"related\".\nTwo months are considered related if the first day of each month falls on the same day of the week.\nThis condition is true if the difference in days between the first day of these months is divisible by 7.\nLeap years are taken into account, as February has 29 days in a leap year.\n\nInput:\n- $year: An integer representing the year.\n- $month1: An integer representing the first month.\n- $month2: An integer representing the second month.\n\nOutput:\n- Returns 'YES' if the months are related; 'NO' otherwise.\n\nExamples:\n- areRelatedMonths(1994, 10, 9) -> 'NO'\n- areRelatedMonths(1948, 1, 4) -> 'YES'",
      "es": "Determina si dos meses en un año dado están \"relacionados\".\nDos meses se consideran relacionados si el primer día de cada mes cae en el mismo día de la semana.\nEsta condición es verdadera si la diferencia en días entre el primer día de estos meses es divisible por 7.\nSe tienen en cuenta los años bisiestos, ya que febrero tiene 29 días en un año bisiesto.\n\nEntrada:\n- $year: Un entero que representa el año.\n- $month1: Un entero que representa el primer mes.\n- $month2: Un entero que representa el segundo mes.\n\nSalida:\n- Devuelve 'YES' si los meses están relacionados; 'NO' de lo contrario.\n\nEjemplos:\n- areRelatedMonths(1994, 10, 9) -> 'NO'\n- areRelatedMonths(1948, 1, 4) -> 'YES'",
      "arb": "يحدد ما إذا كان هناك شهران في سنة معينة \"مرتبطان\".\nيعتبر الشهران مرتبطين إذا كان اليوم الأول من كل شهر يقع في نفس اليوم من الأسبوع.\nتكون هذه الحالة صحيحة إذا كان الفرق في الأيام بين اليوم الأول من هذه الأشهر قابلاً للقسمة على 7.\nيتم أخذ السنوات الكبيسة في الاعتبار، حيث يحتوي شهر فبراير على 29 يومًا في السنة الكبيسة.\n\nالمدخلات:\n- $year: عدد صحيح يمثل السنة.\n- $month1: عدد صحيح يمثل الشهر الأول.\n- $month2: عدد صحيح يمثل الشهر الثاني.\n\nالمخرجات:\n- يعيد 'YES' إذا كانت الأشهر مرتبطة؛ 'NO' خلاف ذلك.\n\nأمثلة:\n- areRelatedMonths(1994, 10, 9) -> 'NO'\n- areRelatedMonths(1948, 1, 4) -> 'YES'",
      "sw": "Inabainisha ikiwa miezi miwili katika mwaka uliotolewa ni \"inayohusiana\".  \nMiezi miwili inachukuliwa kuwa inahusiana ikiwa siku ya kwanza ya kila mwezi inaangukia siku moja ya wiki. \nHali hii ni kweli ikiwa tofauti ya siku kati ya siku ya kwanza ya miezi hii inagawanyika kwa 7.  \nMiaka ya kuruka inazingatiwa, kwani Februari ina siku 29 katika mwaka wa kuruka.  \n\nIngizo:  \n- $year: Nambari nzima inayowakilisha mwaka.  \n- $month1: Nambari nzima inayowakilisha mwezi wa kwanza.  \n- $month2: Nambari nzima inayowakilisha mwezi wa pili.  \n\nMatokeo:  \n- Inarudisha 'YES' ikiwa miezi inahusiana; 'NO' vinginevyo. \n\nMifano:  \n- areRelatedMonths(1994, 10, 9) -> 'NO'  \n- areRelatedMonths(1948, 1, 4) -> 'YES'  ",
      "tr": "Belirtilen bir yıldaki iki ayın \"ilişkili\" olup olmadığını belirler.\nİki ay, her ayın ilk günü haftanın aynı gününe denk geliyorsa ilişkili kabul edilir.\nBu koşul, bu ayların ilk günü arasındaki gün farkı 7'ye bölünebiliyorsa doğrudur.\nArtık yıllar dikkate alınır, çünkü artık yıllarda Şubat ayı 29 gündür.\n\nGirdi:\n- $year: Yılı temsil eden bir tamsayı.\n- $month1: İlk ayı temsil eden bir tamsayı.\n- $month2: İkinci ayı temsil eden bir tamsayı.\n\nÇıktı:\n- Aylar ilişkiliyse 'YES' döner; aksi takdirde 'NO' döner.\n\nÖrnekler:\n- areRelatedMonths(1994, 10, 9) -> 'NO'\n- areRelatedMonths(1948, 1, 4) -> 'YES'",
      "vi": "Xác định xem hai tháng trong một năm nhất định có \"liên quan\" hay không.  \nHai tháng được coi là liên quan nếu ngày đầu tiên của mỗi tháng rơi vào cùng một ngày trong tuần.  \nĐiều kiện này đúng nếu chênh lệch số ngày giữa ngày đầu tiên của các tháng này chia hết cho 7.  \nNăm nhuận được tính đến, vì tháng Hai có 29 ngày trong năm nhuận.\n\nĐầu vào:  \n- $year: Một số nguyên đại diện cho năm.  \n- $month1: Một số nguyên đại diện cho tháng thứ nhất.  \n- $month2: Một số nguyên đại diện cho tháng thứ hai.  \n\nĐầu ra:  \n- Trả về 'YES' nếu các tháng có liên quan; 'NO' nếu không.\n\nVí dụ:  \n- areRelatedMonths(1994, 10, 9) -> 'NO'  \n- areRelatedMonths(1948, 1, 4) -> 'YES'  "
    },
    "docstring_bertscore": {
      "es": "0.999999801369619",
      "arb": "0.9799655438776781",
      "sw": "0.8585747714423976",
      "tr": "0.9833394795299367",
      "vi": "0.9845473508770098"
    }
  },
  {
    "task_id": "PHP/22",
    "prompt": {
      "en": "<?php\n/**\n    * Converts a number from one base to another.\n    * The function accepts three parameters: the number to convert, the base it's currently in, and the base to convert it to.\n    * The bases can range from 2 to 36.\n    * The number is assumed to be a string to accommodate larger bases and values.\n    * Characters in the number may include 0-9 and A-Z, representing values 0 through 35.\n    * Input: A string representing the number, an integer for the current base, and an integer for the target base.\n    * Output: The number converted to the target base as a string.\n    * Example: convertBase(\"123AB\", 16, 10) returns \"74667\".\n*/\n\nfunction convertBase($number, $fromBase, $toBase) ",
      "es": "<?php\n/**\n    * Convierte un número de una base a otra.\n    * La función acepta tres parámetros: el número a convertir, la base en la que está actualmente y la base a la que se va a convertir.\n    * Las bases pueden variar de 2 a 36.\n    * Se asume que el número es una cadena para acomodar bases y valores más grandes.\n    * Los caracteres en el número pueden incluir 0-9 y A-Z, representando valores del 0 al 35.\n    * Entrada: Una cadena que representa el número, un entero para la base actual y un entero para la base objetivo.\n    * Salida: El número convertido a la base objetivo como una cadena.\n    * Ejemplo: convertBase(\"123AB\", 16, 10) devuelve \"74667\".\n*/\n\nfunction convertBase($number, $fromBase, $toBase) ",
      "arb": "<?php\n/**\n    * يحول رقمًا من قاعدة إلى أخرى.\n    * تقبل الدالة ثلاثة معلمات: الرقم المراد تحويله، القاعدة التي هو فيها حاليًا، والقاعدة المراد تحويله إليها.\n    * يمكن أن تتراوح القواعد من 2 إلى 36.\n    * يُفترض أن الرقم عبارة عن سلسلة نصية لاستيعاب القواعد والقيم الأكبر.\n    * قد تتضمن الأحرف في الرقم 0-9 و A-Z، مما يمثل القيم من 0 إلى 35.\n    * المدخلات: سلسلة نصية تمثل الرقم، عدد صحيح للقاعدة الحالية، وعدد صحيح للقاعدة المستهدفة.\n    * المخرجات: الرقم المحول إلى القاعدة المستهدفة كسلسلة نصية.\n    * مثال: convertBase(\"123AB\", 16, 10) يعيد \"74667\".\n*/\n\nfunction convertBase($number, $fromBase, $toBase) ",
      "sw": "<?php\n/**\n    * Inabadilisha nambari kutoka msingi mmoja hadi mwingine.\n    * Kazi inakubali vigezo vitatu: nambari ya kubadilisha, msingi ambao iko sasa, na msingi wa kubadilisha.\n    * Misingi inaweza kuwa kati ya 2 hadi 36.\n    * Nambari inadhaniwa kuwa ni kamba ili kuendana na misingi na thamani kubwa zaidi.\n    * Herufi katika nambari zinaweza kujumuisha 0-9 na A-Z, zikionyesha thamani 0 hadi 35.\n    * Ingizo: Kamba inayowakilisha nambari, nambari kamili kwa msingi wa sasa, na nambari kamili kwa msingi lengwa.\n    * Matokeo: Nambari iliyobadilishwa hadi msingi lengwa kama kamba.\n    * Mfano: convertBase(\"123AB\", 16, 10) inarudisha \"74667\".\n*/\n\nfunction convertBase($number, $fromBase, $toBase) ",
      "tr": "<?php\n/**\n    * Bir sayıyı bir tabandan diğerine dönüştürür.\n    * Fonksiyon üç parametre kabul eder: dönüştürülecek sayı, şu anki tabanı ve dönüştürülecek taban.\n    * Tabanlar 2 ile 36 arasında olabilir.\n    * Sayının daha büyük tabanlar ve değerler için bir dize olduğu varsayılır.\n    * Sayıdaki karakterler 0-9 ve A-Z'yi içerebilir, bu da 0'dan 35'e kadar olan değerleri temsil eder.\n    * Girdi: Sayıyı temsil eden bir dize, mevcut taban için bir tamsayı ve hedef taban için bir tamsayı.\n    * Çıktı: Hedef tabana dönüştürülmüş sayının bir dize olarak ifadesi.\n    * Örnek: convertBase(\"123AB\", 16, 10) \"74667\" döndürür.\n*/\n\nfunction convertBase($number, $fromBase, $toBase) ",
      "vi": "<?php\n/**\n    * Chuyển đổi một số từ một cơ số này sang cơ số khác.\n    * Hàm chấp nhận ba tham số: số cần chuyển đổi, cơ số hiện tại của nó, và cơ số cần chuyển đổi sang.\n    * Các cơ số có thể từ 2 đến 36.\n    * Số được giả định là một chuỗi để phù hợp với các cơ số và giá trị lớn hơn.\n    * Các ký tự trong số có thể bao gồm 0-9 và A-Z, đại diện cho các giá trị từ 0 đến 35.\n    * Đầu vào: Một chuỗi đại diện cho số, một số nguyên cho cơ số hiện tại, và một số nguyên cho cơ số đích.\n    * Đầu ra: Số đã được chuyển đổi sang cơ số đích dưới dạng một chuỗi.\n    * Ví dụ: convertBase(\"123AB\", 16, 10) trả về \"74667\".\n*/\n\nfunction convertBase($number, $fromBase, $toBase) "
    },
    "prompt_bertscore": {
      "es": "0.9758912375018904",
      "arb": "0.9749864761162765",
      "sw": "0.9883074239900003",
      "tr": "0.9603072936970363",
      "vi": "0.9738264746910328"
    },
    "canonical_solution": "{\n    // Check if the bases are within the valid range\n    if ($fromBase < 2 || $fromBase > 36 || $toBase < 2 || $toBase > 36) {\n        return \"Invalid base. Bases must be between 2 and 36.\";\n    }\n\n    // Convert the number from the original base to base 10\n    $decValue = base_convert($number, $fromBase, 10);\n\n    // Convert the base 10 number to the target base\n\n    return strtoupper(base_convert($decValue, 10, $toBase));\n}",
    "instruction": {
      "en": "function convertBase($number, $fromBase, $toBase)\n{\n    // Check if the bases are within the valid range\n    if ($fromBase < 2 || $fromBase > 36 || $toBase < 2 || $toBase > 36) {\n        return \"Invalid base. Bases must be between 2 and 36.\";\n    }\n\n    // Convert the number from the original base to base 10\n    $decValue = base_convert($number, $fromBase, 10);\n\n    // Convert the base 10 number to the target base\n\n    return strtoupper(base_convert($decValue, 10, $toBase));\n}\n\nProvide a concise natural language description (docstring) of the PHP code in English using at most 500 characters.",
      "es": "function convertBase($number, $fromBase, $toBase)\n{\n    // Check if the bases are within the valid range\n    if ($fromBase < 2 || $fromBase > 36 || $toBase < 2 || $toBase > 36) {\n        return \"Invalid base. Bases must be between 2 and 36.\";\n    }\n\n    // Convert the number from the original base to base 10\n    $decValue = base_convert($number, $fromBase, 10);\n\n    // Convert the base 10 number to the target base\n\n    return strtoupper(base_convert($decValue, 10, $toBase));\n}\n\nProporcione una descripción concisa en lenguaje natural (docstring) del código PHP en español utilizando un máximo de 500 caracteres.",
      "arb": "function convertBase($number, $fromBase, $toBase)\n{\n    // Check if the bases are within the valid range\n    if ($fromBase < 2 || $fromBase > 36 || $toBase < 2 || $toBase > 36) {\n        return \"Invalid base. Bases must be between 2 and 36.\";\n    }\n\n    // Convert the number from the original base to base 10\n    $decValue = base_convert($number, $fromBase, 10);\n\n    // Convert the base 10 number to the target base\n\n    return strtoupper(base_convert($decValue, 10, $toBase));\n}\n\nيرجى تقديم وصف موجز بلغة طبيعية (docstring) للكود المكتوب بلغة PHP باللغة العربية الفصحى، بحيث لا يتجاوز 500 حرف.",
      "sw": "function convertBase($number, $fromBase, $toBase)\n{\n    // Check if the bases are within the valid range\n    if ($fromBase < 2 || $fromBase > 36 || $toBase < 2 || $toBase > 36) {\n        return \"Invalid base. Bases must be between 2 and 36.\";\n    }\n\n    // Convert the number from the original base to base 10\n    $decValue = base_convert($number, $fromBase, 10);\n\n    // Convert the base 10 number to the target base\n\n    return strtoupper(base_convert($decValue, 10, $toBase));\n}\n\nToa maelezo mafupi ya lugha ya asili (docstring) ya msimbo wa PHP kwa Kiswahili kwa kutumia herufi zisizozidi 500.",
      "tr": "function convertBase($number, $fromBase, $toBase)\n{\n    // Check if the bases are within the valid range\n    if ($fromBase < 2 || $fromBase > 36 || $toBase < 2 || $toBase > 36) {\n        return \"Invalid base. Bases must be between 2 and 36.\";\n    }\n\n    // Convert the number from the original base to base 10\n    $decValue = base_convert($number, $fromBase, 10);\n\n    // Convert the base 10 number to the target base\n\n    return strtoupper(base_convert($decValue, 10, $toBase));\n}\n\nPHP kodunun işlevini açıklayan kısa bir doğal dil açıklaması (docstring) sağlayın. Açıklama, en fazla 500 karakter kullanılarak Türkçe olarak yazılmalıdır.",
      "vi": "function convertBase($number, $fromBase, $toBase)\n{\n    // Check if the bases are within the valid range\n    if ($fromBase < 2 || $fromBase > 36 || $toBase < 2 || $toBase > 36) {\n        return \"Invalid base. Bases must be between 2 and 36.\";\n    }\n\n    // Convert the number from the original base to base 10\n    $decValue = base_convert($number, $fromBase, 10);\n\n    // Convert the base 10 number to the target base\n\n    return strtoupper(base_convert($decValue, 10, $toBase));\n}\n\nCung cấp mô tả ngắn gọn bằng ngôn ngữ tự nhiên (docstring) cho mã PHP bằng tiếng Việt, sử dụng tối đa 500 ký tự."
    },
    "instruction_bertscore": {
      "es": "0.9687069752502395",
      "arb": "0.8898884537517856",
      "sw": "0.91585798565943",
      "tr": "0.8711236430250386",
      "vi": "0.9202302376067699"
    },
    "level": "",
    "test": "function main(){\n    assert(convertBase('2345678A123', 18, 18) === '2345678A123');\n    assert(convertBase('23456', 15, 18) === '114E0');\n    assert(convertBase('2345678', 12, 20) === '22B7A4');\n    assert(convertBase('12345678', 16, 23) === '21A976L');\n    assert(convertBase('3456AB', 25, 21) === '7C2136');\n    assert(convertBase('AB1234567', 18, 22) === '22JF0G367');\n    \n}\n\nmain();\n?>",
    "entry_point": "convertBase",
    "signature": "function convertBase($number, $fromBase, $toBase)",
    "docstring": {
      "en": "Converts a number from one base to another.\nThe function accepts three parameters: the number to convert, the base it's currently in, and the base to convert it to.\nThe bases can range from 2 to 36.\nThe number is assumed to be a string to accommodate larger bases and values.\nCharacters in the number may include 0-9 and A-Z, representing values 0 through 35.\nInput: A string representing the number, an integer for the current base, and an integer for the target base.\nOutput: The number converted to the target base as a string.\nExample: convertBase(\"123AB\", 16, 10) returns \"74667\".",
      "es": "Convierte un número de una base a otra.  \nLa función acepta tres parámetros: el número a convertir, la base en la que está actualmente y la base a la que se va a convertir.  \nLas bases pueden variar de 2 a 36.  \nSe asume que el número es una cadena para acomodar bases y valores más grandes.  \nLos caracteres en el número pueden incluir 0-9 y A-Z, representando valores de 0 a 35.  \nEntrada: Una cadena que representa el número, un entero para la base actual y un entero para la base objetivo.  \nSalida: El número convertido a la base objetivo como una cadena.  \nEjemplo: convertBase(\"123AB\", 16, 10) devuelve \"74667\".",
      "arb": "تحويل رقم من قاعدة إلى أخرى.  \nتقبل الدالة ثلاثة معلمات: الرقم المراد تحويله، القاعدة التي هو فيها حاليًا، والقاعدة المراد تحويله إليها.  \nيمكن أن تتراوح القواعد من 2 إلى 36.  \nيُفترض أن الرقم عبارة عن سلسلة نصية لاستيعاب القواعد والقيم الأكبر.  \nقد تتضمن الأحرف في الرقم 0-9 و A-Z، والتي تمثل القيم من 0 إلى 35.  \n\nيعيدالحجج:  \n    رقم يمثل الرقم كسلسلة نصية، عدد صحيح للقاعدة الحالية، وعدد صحيح للقاعدة المستهدفة.  \n\n   الرقم المحول إلى القاعدة المستهدفة كسلسلة نصية.  \n\nامثله:  \n    convertBase(\"123AB\", 16, 10) يعيد \"74667\".",
      "sw": "Inabadilisha nambari kutoka msingi mmoja hadi mwingine.\nKazi inakubali vigezo vitatu: nambari ya kubadilisha, msingi ambao iko kwa sasa, na msingi wa kuibadilisha.\nMisingi inaweza kuwa kati ya 2 hadi 36.\nNambari inadhaniwa kuwa ni kamba ili kuendana na misingi na thamani kubwa zaidi.\nHerufi katika nambari zinaweza kujumuisha 0-9 na A-Z, zikionyesha thamani 0 hadi 35.\nIngizo: Kamba inayowakilisha nambari, nambari kamili kwa msingi wa sasa, na nambari kamili kwa msingi lengwa.\nPato: Nambari iliyobadilishwa hadi msingi lengwa kama kamba.\nMfano: convertBase(\"123AB\", 16, 10) inarudisha \"74667\".",
      "tr": "Bir sayıyı bir tabandan başka bir tabana dönüştürür.\nFonksiyon, dönüştürülecek sayıyı, şu anki tabanını ve dönüştürüleceği tabanı kabul eder.\nTabanlar 2 ile 36 arasında olabilir.\nSayı, daha büyük tabanlar ve değerler için bir dize olarak kabul edilir.\nSayıdaki karakterler, 0'dan 9'a ve A'dan Z'ye kadar olan değerleri temsil edebilir ve bu da 0 ile 35 arasındaki değerleri ifade eder.\nGirdi: Sayıyı temsil eden bir dize, mevcut taban için bir tamsayı ve hedef taban için bir tamsayı.\nÇıktı: Hedef tabana dönüştürülmüş sayının bir dize olarak çıktısı.\nÖrnek: convertBase(\"123AB\", 16, 10) \"74667\" döndürür.",
      "vi": "Chuyển đổi một số từ một cơ số này sang một cơ số khác.  \nHàm chấp nhận ba tham số: số cần chuyển đổi, cơ số hiện tại của nó, và cơ số cần chuyển đổi sang.  \nCác cơ số có thể nằm trong khoảng từ 2 đến 36.  \nSố được giả định là một chuỗi để phù hợp với các cơ số và giá trị lớn hơn.  \nCác ký tự trong số có thể bao gồm 0-9 và A-Z, đại diện cho các giá trị từ 0 đến 35.  \nĐầu vào: Một chuỗi đại diện cho số, một số nguyên cho cơ số hiện tại, và một số nguyên cho cơ số đích.  \nĐầu ra: Số được chuyển đổi sang cơ số đích dưới dạng một chuỗi.  \nVí dụ: convertBase(\"123AB\", 16, 10) trả về \"74667\"."
    },
    "docstring_bertscore": {
      "es": "0.9701180454771114",
      "arb": "0.9597473546528988",
      "sw": "0.9840899051094865",
      "tr": "0.9194778257234097",
      "vi": "0.9690774209108697"
    }
  },
  {
    "task_id": "PHP/23",
    "prompt": {
      "en": "<?php\n\n/**\n * Performs division of two large numbers provided as strings.\n * This function handles division of large numbers that may exceed the integer\n * or float limit in PHP. It only returns the integer part of the quotient.\n * \n * Inputs:\n * - $dividend: String representing the dividend (the number to be divided).\n * - $divisor: String representing the divisor (the number by which we divide).\n * \n * Output:\n * - Returns a string representing the integer part of the quotient.\n * \n * Example Cases:\n * - largeNumberDivision(\"2376\", \"24\") returns \"99\"\n * - largeNumberDivision(\"1000\", \"10\") returns \"100\"\n */\n\n function largeNumberDivision($dividend, $divisor) ",
      "es": "<?php\n\n/**\n * Realiza la división de dos números grandes proporcionados como cadenas.\n * Esta función maneja la división de números grandes que pueden exceder el límite\n * de enteros o flotantes en PHP. Solo devuelve la parte entera del cociente.\n * \n * Entradas:\n * - $dividend: Cadena que representa el dividendo (el número a dividir).\n * - $divisor: Cadena que representa el divisor (el número por el cual dividimos).\n * \n * Salida:\n * - Devuelve una cadena que representa la parte entera del cociente.\n * \n * Casos de Ejemplo:\n * - largeNumberDivision(\"2376\", \"24\") devuelve \"99\"\n * - largeNumberDivision(\"1000\", \"10\") devuelve \"100\"\n */\n\n function largeNumberDivision($dividend, $divisor) ",
      "arb": "<?php\n\n/**\n * يقوم بإجراء القسمة بين رقمين كبيرين مقدمان كسلاسل.\n * تتعامل هذه الدالة مع قسمة الأرقام الكبيرة التي قد تتجاوز حد الأعداد الصحيحة\n * أو الأعداد العشرية في PHP. تعيد فقط الجزء الصحيح من خارج القسمة.\n * \n * المدخلات:\n * - $dividend: سلسلة تمثل المقسوم (الرقم الذي سيتم قسمته).\n * - $divisor: سلسلة تمثل القاسم (الرقم الذي نقسم عليه).\n * \n * المخرجات:\n * - تعيد سلسلة تمثل الجزء الصحيح من خارج القسمة.\n * \n * أمثلة الحالات:\n * - largeNumberDivision(\"2376\", \"24\") تعيد \"99\"\n * - largeNumberDivision(\"1000\", \"10\") تعيد \"100\"\n */\n\n function largeNumberDivision($dividend, $divisor) ",
      "sw": "<?php\n\n/**\n * Hufanya mgawanyo wa namba kubwa mbili zinazotolewa kama mistari ya maandishi.\n * Kazi hii inashughulikia mgawanyo wa namba kubwa ambazo zinaweza kuzidi kikomo cha integer\n * au float katika PHP. Inarudisha tu sehemu ya nambari kamili ya mgawo.\n * \n * Ingizo:\n * - $dividend: String inayowakilisha dividend (namba inayogawanywa).\n * - $divisor: String inayowakilisha divisor (namba tunayotumia kugawanya).\n * \n * Tokeo:\n * - Inarudisha string inayowakilisha sehemu ya nambari kamili ya mgawo.\n * \n * Mifano ya Kesi:\n * - largeNumberDivision(\"2376\", \"24\") inarudisha \"99\"\n * - largeNumberDivision(\"1000\", \"10\") inarudisha \"100\"\n */\n\n function largeNumberDivision($dividend, $divisor) ",
      "tr": "<?php\n\n/**\n * İki büyük sayının bölünmesini gerçekleştirir.\n * Bu fonksiyon, PHP'de tamsayı veya float sınırını aşabilecek büyük sayıların\n * bölünmesini ele alır. Yalnızca bölümün tam sayı kısmını döndürür.\n * \n * Girdiler:\n * - $dividend: Bölüneni temsil eden string (bölünecek sayı).\n * - $divisor: Böleni temsil eden string (böldüğümüz sayı).\n * \n * Çıktı:\n * - Bölümün tam sayı kısmını temsil eden bir string döndürür.\n * \n * Örnek Durumlar:\n * - largeNumberDivision(\"2376\", \"24\") \"99\" döndürür\n * - largeNumberDivision(\"1000\", \"10\") \"100\" döndürür\n */\n\n function largeNumberDivision($dividend, $divisor) ",
      "vi": "<?php\n\n/**\n * Thực hiện phép chia hai số lớn được cung cấp dưới dạng chuỗi.\n * Hàm này xử lý phép chia các số lớn có thể vượt quá giới hạn số nguyên\n * hoặc số thực trong PHP. Nó chỉ trả về phần nguyên của thương.\n * \n * Đầu vào:\n * - $dividend: Chuỗi đại diện cho số bị chia (số cần chia).\n * - $divisor: Chuỗi đại diện cho số chia (số mà chúng ta chia).\n * \n * Đầu ra:\n * - Trả về một chuỗi đại diện cho phần nguyên của thương.\n * \n * Ví dụ:\n * - largeNumberDivision(\"2376\", \"24\") trả về \"99\"\n * - largeNumberDivision(\"1000\", \"10\") trả về \"100\"\n */\n\n function largeNumberDivision($dividend, $divisor) "
    },
    "prompt_bertscore": {
      "es": "0.9806949146368382",
      "arb": "0.9615048362642956",
      "sw": "0.9767036357603232",
      "tr": "0.9813686688893085",
      "vi": "0.9788053438220533"
    },
    "canonical_solution": " {\n    // Handle division by zero\n    if ($divisor === \"0\") {\n        throw new Exception(\"Division by zero.\");\n    }\n\n    // Initialize variables\n    $quotient = \"\";\n    $remainder = \"\";\n\n    // Loop through each digit of the dividend\n    for ($i = 0; $i < strlen($dividend); $i++) {\n        $remainder .= $dividend[$i];\n        $partialQuotient = 0;\n\n        // Find the maximum quotient for this partial dividend\n        while ((int)$remainder >= (int)$divisor) {\n            $remainder = (string)((int)$remainder - (int)$divisor);\n            $partialQuotient++;\n        }\n\n        $quotient .= (string)$partialQuotient;\n    }\n\n    // Remove leading zeros and return the quotient\n    return ltrim($quotient, \"0\") ?: \"0\";\n}",
    "instruction": {
      "en": "function largeNumberDivision($dividend, $divisor)\n {\n    // Handle division by zero\n    if ($divisor === \"0\") {\n        throw new Exception(\"Division by zero.\");\n    }\n\n    // Initialize variables\n    $quotient = \"\";\n    $remainder = \"\";\n\n    // Loop through each digit of the dividend\n    for ($i = 0; $i < strlen($dividend); $i++) {\n        $remainder .= $dividend[$i];\n        $partialQuotient = 0;\n\n        // Find the maximum quotient for this partial dividend\n        while ((int)$remainder >= (int)$divisor) {\n            $remainder = (string)((int)$remainder - (int)$divisor);\n            $partialQuotient++;\n        }\n\n        $quotient .= (string)$partialQuotient;\n    }\n\n    // Remove leading zeros and return the quotient\n    return ltrim($quotient, \"0\") ?: \"0\";\n}\n\nProvide a concise natural language description (docstring) of the PHP code in English using at most 500 characters.",
      "es": "function largeNumberDivision($dividend, $divisor)\n {\n    // Handle division by zero\n    if ($divisor === \"0\") {\n        throw new Exception(\"Division by zero.\");\n    }\n\n    // Initialize variables\n    $quotient = \"\";\n    $remainder = \"\";\n\n    // Loop through each digit of the dividend\n    for ($i = 0; $i < strlen($dividend); $i++) {\n        $remainder .= $dividend[$i];\n        $partialQuotient = 0;\n\n        // Find the maximum quotient for this partial dividend\n        while ((int)$remainder >= (int)$divisor) {\n            $remainder = (string)((int)$remainder - (int)$divisor);\n            $partialQuotient++;\n        }\n\n        $quotient .= (string)$partialQuotient;\n    }\n\n    // Remove leading zeros and return the quotient\n    return ltrim($quotient, \"0\") ?: \"0\";\n}\n\nProporcione una descripción concisa en lenguaje natural (docstring) del código PHP en español utilizando como máximo 500 caracteres.",
      "arb": "function largeNumberDivision($dividend, $divisor)\n {\n    // Handle division by zero\n    if ($divisor === \"0\") {\n        throw new Exception(\"Division by zero.\");\n    }\n\n    // Initialize variables\n    $quotient = \"\";\n    $remainder = \"\";\n\n    // Loop through each digit of the dividend\n    for ($i = 0; $i < strlen($dividend); $i++) {\n        $remainder .= $dividend[$i];\n        $partialQuotient = 0;\n\n        // Find the maximum quotient for this partial dividend\n        while ((int)$remainder >= (int)$divisor) {\n            $remainder = (string)((int)$remainder - (int)$divisor);\n            $partialQuotient++;\n        }\n\n        $quotient .= (string)$partialQuotient;\n    }\n\n    // Remove leading zeros and return the quotient\n    return ltrim($quotient, \"0\") ?: \"0\";\n}\n\nيرجى تقديم وصف موجز بلغة طبيعية (docstring) للشفرة البرمجية بلغة PHP باللغة العربية الفصحى باستخدام 500 حرف كحد أقصى.",
      "sw": "function largeNumberDivision($dividend, $divisor)\n {\n    // Handle division by zero\n    if ($divisor === \"0\") {\n        throw new Exception(\"Division by zero.\");\n    }\n\n    // Initialize variables\n    $quotient = \"\";\n    $remainder = \"\";\n\n    // Loop through each digit of the dividend\n    for ($i = 0; $i < strlen($dividend); $i++) {\n        $remainder .= $dividend[$i];\n        $partialQuotient = 0;\n\n        // Find the maximum quotient for this partial dividend\n        while ((int)$remainder >= (int)$divisor) {\n            $remainder = (string)((int)$remainder - (int)$divisor);\n            $partialQuotient++;\n        }\n\n        $quotient .= (string)$partialQuotient;\n    }\n\n    // Remove leading zeros and return the quotient\n    return ltrim($quotient, \"0\") ?: \"0\";\n}\n\nToa maelezo mafupi ya lugha ya asili (docstring) ya msimbo wa PHP kwa Kiswahili kwa kutumia herufi zisizozidi 500.",
      "tr": "function largeNumberDivision($dividend, $divisor)\n {\n    // Handle division by zero\n    if ($divisor === \"0\") {\n        throw new Exception(\"Division by zero.\");\n    }\n\n    // Initialize variables\n    $quotient = \"\";\n    $remainder = \"\";\n\n    // Loop through each digit of the dividend\n    for ($i = 0; $i < strlen($dividend); $i++) {\n        $remainder .= $dividend[$i];\n        $partialQuotient = 0;\n\n        // Find the maximum quotient for this partial dividend\n        while ((int)$remainder >= (int)$divisor) {\n            $remainder = (string)((int)$remainder - (int)$divisor);\n            $partialQuotient++;\n        }\n\n        $quotient .= (string)$partialQuotient;\n    }\n\n    // Remove leading zeros and return the quotient\n    return ltrim($quotient, \"0\") ?: \"0\";\n}\n\nPHP kodunun işlevini açıklayan kısa bir doğal dil açıklaması (docstring) sağlayın. Açıklama Türkçe olmalı ve en fazla 500 karakter kullanılmalıdır.",
      "vi": "function largeNumberDivision($dividend, $divisor)\n {\n    // Handle division by zero\n    if ($divisor === \"0\") {\n        throw new Exception(\"Division by zero.\");\n    }\n\n    // Initialize variables\n    $quotient = \"\";\n    $remainder = \"\";\n\n    // Loop through each digit of the dividend\n    for ($i = 0; $i < strlen($dividend); $i++) {\n        $remainder .= $dividend[$i];\n        $partialQuotient = 0;\n\n        // Find the maximum quotient for this partial dividend\n        while ((int)$remainder >= (int)$divisor) {\n            $remainder = (string)((int)$remainder - (int)$divisor);\n            $partialQuotient++;\n        }\n\n        $quotient .= (string)$partialQuotient;\n    }\n\n    // Remove leading zeros and return the quotient\n    return ltrim($quotient, \"0\") ?: \"0\";\n}\n\nCung cấp mô tả ngắn gọn bằng ngôn ngữ tự nhiên (docstring) cho mã PHP bằng tiếng Việt, sử dụng tối đa 500 ký tự."
    },
    "instruction_bertscore": {
      "es": "0.9687069752502395",
      "arb": "0.9176160631619698",
      "sw": "0.91585798565943",
      "tr": "0.8654434100185839",
      "vi": "0.9362267367130336"
    },
    "level": "",
    "test": "function main(){\n    assert(largeNumberDivision(\"2376\", \"24\") === \"99\");\n    assert(largeNumberDivision(\"1000\", \"10\") === \"100\");\n    assert(largeNumberDivision(\"5000\", \"25\") === \"200\");\n    assert(largeNumberDivision(\"123456789\", \"12345\") === \"10000\");\n    assert(largeNumberDivision(\"102030\", \"5101\") === \"20\");\n    assert(largeNumberDivision(\"1020300000000000000000000000000000000000000000000\", \"10\") === \"102030000000000000000000000000000000000000000000\");\n    \n}\n\n\nmain();\n?>",
    "entry_point": "largeNumberDivision",
    "signature": "function largeNumberDivision($dividend, $divisor)",
    "docstring": {
      "en": "Performs division of two large numbers provided as strings.\nThis function handles division of large numbers that may exceed the integer\nor float limit in PHP. It only returns the integer part of the quotient.\n\nInputs:\n- $dividend: String representing the dividend (the number to be divided).\n- $divisor: String representing the divisor (the number by which we divide).\n\nOutput:\n- Returns a string representing the integer part of the quotient.\n\nExample Cases:\n- largeNumberDivision(\"2376\", \"24\") returns \"99\"\n- largeNumberDivision(\"1000\", \"10\") returns \"100\"",
      "es": "Realiza la división de dos números grandes proporcionados como cadenas.\nEsta función maneja la división de números grandes que pueden exceder el límite de enteros\no flotantes en PHP. Solo devuelve la parte entera del cociente.\n\nEntradas:\n- $dividend: Cadena que representa el dividendo (el número a dividir).\n- $divisor: Cadena que representa el divisor (el número por el cual dividimos).\n\nSalida:\n- Devuelve una cadena que representa la parte entera del cociente.\n\nCasos de Ejemplo:\n- largeNumberDivision(\"2376\", \"24\") devuelve \"99\"\n- largeNumberDivision(\"1000\", \"10\") devuelve \"100\"",
      "arb": "يقوم بإجراء قسمة لعددين كبيرين يتم تقديمهما كسلاسل نصية.\nتتعامل هذه الدالة مع قسمة الأعداد الكبيرة التي قد تتجاوز حد الأعداد الصحيحة أو العائمة في PHP. تقوم فقط بإرجاع الجزء الصحيح من خارج القسمة.\n\nالمدخلات:\n- $dividend: سلسلة نصية تمثل المقسوم (العدد الذي سيتم قسمته).\n- $divisor: سلسلة نصية تمثل المقسوم عليه (العدد الذي نقسم عليه).\n\nالمخرجات:\n- يُرجع سلسلة نصية تمثل الجزء الصحيح من خارج القسمة.\n\nحالات المثال:\n- largeNumberDivision(\"2376\", \"24\") يُرجع \"99\"\n- largeNumberDivision(\"1000\", \"10\") يُرجع \"100\"",
      "sw": "Inafanya mgawanyo wa namba kubwa mbili zilizotolewa kama mistari ya maandishi.\nKazi hii inashughulikia mgawanyo wa namba kubwa ambazo zinaweza kuzidi kikomo cha integer au float katika PHP. Inarudisha tu sehemu ya nambari kamili ya mgawo.\n\nIngizo:\n- $dividend: Mstari wa maandishi unaowakilisha gawanywaji (namba inayogawanywa).\n- $divisor: Mstari wa maandishi unaowakilisha mgawanyaji (namba tunayogawanya nayo).\n\nMatokeo:\n- Inarudisha mstari wa maandishi unaowakilisha sehemu ya nambari kamili ya mgawo.\n\nMifano ya Kesi:\n- largeNumberDivision(\"2376\", \"24\") inarudisha \"99\"\n- largeNumberDivision(\"1000\", \"10\") inarudisha \"100\"",
      "tr": "İki büyük sayının bölünmesini gerçekleştirir, bu sayılar string olarak verilmiştir.\nBu fonksiyon, PHP'deki tam sayı veya float limitini aşabilecek büyük sayıların bölünmesini ele alır. Sadece bölümün tam sayı kısmını döndürür.\n\nGirdiler:\n- $dividend: Bölüneni temsil eden string (bölünecek sayı).\n- $divisor: Böleni temsil eden string (bölen sayı).\n\nÇıktı:\n- Bölümün tam sayı kısmını temsil eden bir string döndürür.\n\nÖrnek Durumlar:\n- largeNumberDivision(\"2376\", \"24\") \"99\" döndürür\n- largeNumberDivision(\"1000\", \"10\") \"100\" döndürür",
      "vi": "Thực hiện phép chia của hai số lớn được cung cấp dưới dạng chuỗi.\nHàm này xử lý phép chia của các số lớn có thể vượt quá giới hạn số nguyên\nhoặc số thực trong PHP. Nó chỉ trả về phần nguyên của thương số.\n\nĐầu vào:\n- $dividend: Chuỗi đại diện cho số bị chia (số cần chia).\n- $divisor: Chuỗi đại diện cho số chia (số mà chúng ta chia).\n\nĐầu ra:\n- Trả về một chuỗi đại diện cho phần nguyên của thương số.\n\nCác trường hợp ví dụ:\n- largeNumberDivision(\"2376\", \"24\") trả về \"99\"\n- largeNumberDivision(\"1000\", \"10\") trả về \"100\""
    },
    "docstring_bertscore": {
      "es": "0.9806901475076933",
      "arb": "0.9512215428077384",
      "sw": "0.958899401556261",
      "tr": "0.9715692390409523",
      "vi": "0.9748422704596452"
    }
  },
  {
    "task_id": "PHP/24",
    "prompt": {
      "en": "<?php\n\n\n/**\n * Calculates the largest integer x such that ax <= b < ax+1 or x <= logab < x + 1.\n * This function helps in understanding the relationship between two numbers in terms of logarithms and exponents.\n * - The function takes two positive integers 'a' and 'b' as inputs.\n * - It finds the largest integer 'x' that satisfies the conditions mentioned above.\n * \n * Args:\n *      $a (int): The base number, must be greater than 1.\n *      $b (int): The comparison number.\n * \n * Returns:\n *      int: The largest integer x satisfying the conditions.\n * \n * Examples:\n *      - If a = 10000 and b = 1000000000001, then the output should be 3.\n *      - If a = 3 and b = 27, then the output should be 3.\n */\n\nfunction calculateLogLimit($a, $b) ",
      "es": "<?php\n\n\n/**\n * Calcula el mayor entero x tal que ax <= b < ax+1 o x <= logab < x + 1.\n * Esta función ayuda a entender la relación entre dos números en términos de logaritmos y exponentes.\n * - La función toma dos enteros positivos 'a' y 'b' como entradas.\n * - Encuentra el mayor entero 'x' que satisface las condiciones mencionadas anteriormente.\n * \n * Argumentos:\n *      $a (int): El número base, debe ser mayor que 1.\n *      $b (int): El número de comparación.\n * \n * Devuelve:\n *      int: El mayor entero x que satisface las condiciones.\n * \n * Ejemplos:\n *      - Si a = 10000 y b = 1000000000001, entonces la salida debería ser 3.\n *      - Si a = 3 y b = 27, entonces la salida debería ser 3.\n */\n\nfunction calculateLogLimit($a, $b) ",
      "arb": "<?php\n\n\n/**\n * يحسب أكبر عدد صحيح x بحيث ax <= b < ax+1 أو x <= logab < x + 1.\n * تساعد هذه الدالة في فهم العلاقة بين رقمين من حيث اللوغاريتمات والأسس.\n * - تأخذ الدالة عددين صحيحين موجبين 'a' و 'b' كمدخلات.\n * - تجد أكبر عدد صحيح 'x' يحقق الشروط المذكورة أعلاه.\n * \n * يعيدالحجج:\n *      $a (int): الرقم الأساسي، يجب أن يكون أكبر من 1.\n *      $b (int): الرقم المقارن.\n * \n * Returns:\n *      int: أكبر عدد صحيح x يحقق الشروط.\n * \n * أمثلة:\n *      - إذا كان a = 10000 و b = 1000000000001، فيجب أن يكون الناتج 3.\n *      - إذا كان a = 3 و b = 27، فيجب أن يكون الناتج 3.\n */\n\nfunction calculateLogLimit($a, $b) ",
      "sw": "<?php\n\n\n/**\n * Inahesabu nambari kubwa zaidi x ambapo ax <= b < ax+1 au x <= logab < x + 1.\n * Kazi hii inasaidia kuelewa uhusiano kati ya nambari mbili kwa kutumia logaritimu na eksponenti.\n * - Kazi inachukua nambari mbili chanya 'a' na 'b' kama pembejeo.\n * - Inapata nambari kubwa zaidi 'x' inayoridhisha masharti yaliyotajwa hapo juu.\n * \n * Hoja:\n *      $a (int): Nambari msingi, lazima iwe kubwa kuliko 1.\n *      $b (int): Nambari ya kulinganisha.\n * \n * Inarejesha:\n *      int: Nambari kubwa zaidi x inayoridhisha masharti.\n * \n * Mifano:\n *      - Ikiwa a = 10000 na b = 1000000000001, basi matokeo yanapaswa kuwa 3.\n *      - Ikiwa a = 3 na b = 27, basi matokeo yanapaswa kuwa 3.\n */\n\nfunction calculateLogLimit($a, $b) ",
      "tr": "<?php\n\n\n/**\n * ax <= b < ax+1 veya x <= logab < x + 1 olacak şekilde en büyük tamsayı x'i hesaplar.\n * Bu fonksiyon, iki sayı arasındaki ilişkiyi logaritmalar ve üsler açısından anlamaya yardımcı olur.\n * - Fonksiyon, iki pozitif tam sayı 'a' ve 'b' yi girdi olarak alır.\n * - Yukarıda belirtilen koşulları sağlayan en büyük tamsayı 'x'i bulur.\n * \n * Argümanlar:\n *      $a (int): Taban numarası, 1'den büyük olmalıdır.\n *      $b (int): Karşılaştırma numarası.\n * \n * Döndürür:\n *      int: Koşulları sağlayan en büyük tamsayı x.\n * \n * Örnekler:\n *      - Eğer a = 10000 ve b = 1000000000001 ise, çıktı 3 olmalıdır.\n *      - Eğer a = 3 ve b = 27 ise, çıktı 3 olmalıdır.\n */\n\nfunction calculateLogLimit($a, $b) ",
      "vi": "<?php\n\n\n/**\n * Tính toán số nguyên lớn nhất x sao cho ax <= b < ax+1 hoặc x <= logab < x + 1.\n * Hàm này giúp hiểu mối quan hệ giữa hai số theo lôgarit và số mũ.\n * - Hàm nhận hai số nguyên dương 'a' và 'b' làm đầu vào.\n * - Nó tìm số nguyên lớn nhất 'x' thỏa mãn các điều kiện đã nêu ở trên.\n * \n * Tham số:\n *      $a (int): Số cơ sở, phải lớn hơn 1.\n *      $b (int): Số để so sánh.\n * \n * Trả về:\n *      int: Số nguyên lớn nhất x thỏa mãn các điều kiện.\n * \n * Ví dụ:\n *      - Nếu a = 10000 và b = 1000000000001, thì kết quả phải là 3.\n *      - Nếu a = 3 và b = 27, thì kết quả phải là 3.\n */\n\nfunction calculateLogLimit($a, $b) "
    },
    "prompt_bertscore": {
      "es": "0.9929416694099252",
      "arb": "0.9882398896604484",
      "sw": "0.9597207381818402",
      "tr": "0.9771884925204293",
      "vi": "0.9682846870601594"
    },
    "canonical_solution": "{\n    $x = 0;\n    while (pow($a, $x) <= $b) {\n        $x++;\n    }\n    return $x - 1;\n}",
    "instruction": {
      "en": "function calculateLogLimit($a, $b)\n{\n    $x = 0;\n    while (pow($a, $x) <= $b) {\n        $x++;\n    }\n    return $x - 1;\n}\n\nProvide a concise natural language description (docstring) of the PHP code in English using at most 500 characters.",
      "es": "function calculateLogLimit($a, $b)\n{\n    $x = 0;\n    while (pow($a, $x) <= $b) {\n        $x++;\n    }\n    return $x - 1;\n}\n\nProporcione una descripción concisa en lenguaje natural (docstring) del código PHP en español utilizando como máximo 500 caracteres.",
      "arb": "function calculateLogLimit($a, $b)\n{\n    $x = 0;\n    while (pow($a, $x) <= $b) {\n        $x++;\n    }\n    return $x - 1;\n}\n\nيرجى تقديم وصف موجز بلغة طبيعية (docstring) لشيفرة PHP باللغة العربية الفصحى باستخدام 500 حرف كحد أقصى.",
      "sw": "function calculateLogLimit($a, $b)\n{\n    $x = 0;\n    while (pow($a, $x) <= $b) {\n        $x++;\n    }\n    return $x - 1;\n}\n\nToa maelezo mafupi ya lugha asilia (docstring) ya msimbo wa PHP kwa Kiswahili kwa kutumia herufi zisizozidi 500.",
      "tr": "function calculateLogLimit($a, $b)\n{\n    $x = 0;\n    while (pow($a, $x) <= $b) {\n        $x++;\n    }\n    return $x - 1;\n}\n\nPHP kodunun işlevini açıklayan kısa bir doğal dil açıklaması (docstring) sağlayın. Açıklama Türkçe olmalı ve en fazla 500 karakter içermelidir.",
      "vi": "function calculateLogLimit($a, $b)\n{\n    $x = 0;\n    while (pow($a, $x) <= $b) {\n        $x++;\n    }\n    return $x - 1;\n}\n\nCung cấp mô tả ngắn gọn bằng ngôn ngữ tự nhiên (docstring) cho mã PHP bằng tiếng Việt với tối đa 500 ký tự."
    },
    "instruction_bertscore": {
      "es": "0.9687069752502395",
      "arb": "0.8943554523908792",
      "sw": "0.9428367585331127",
      "tr": "0.8728898643732009",
      "vi": "0.9017250367880356"
    },
    "level": "",
    "test": "function main(){\n    assert(calculateLogLimit(10000, 1000000000001) === 3);\n    assert(calculateLogLimit(3, 27) === 3);\n    assert(calculateLogLimit(2, 32) === 5);\n    assert(calculateLogLimit(5, 3125) === 5);\n   \n    \n}\n\nmain();\n?>",
    "entry_point": "calculateLogLimit",
    "signature": "function calculateLogLimit($a, $b)",
    "docstring": {
      "en": "Calculates the largest integer x such that ax <= b < ax+1 or x <= logab < x + 1.\nThis function helps in understanding the relationship between two numbers in terms of logarithms and exponents.\n- The function takes two positive integers 'a' and 'b' as inputs.\n- It finds the largest integer 'x' that satisfies the conditions mentioned above.\n\nArgs:\n$a (int): The base number, must be greater than 1.\n$b (int): The comparison number.\n\nReturns:\nint: The largest integer x satisfying the conditions.\n\nExamples:\n- If a = 10000 and b = 1000000000001, then the output should be 3.\n- If a = 3 and b = 27, then the output should be 3.",
      "es": "Calcula el mayor entero x tal que ax <= b < ax+1 o x <= logab < x + 1.  \nEsta función ayuda a entender la relación entre dos números en términos de logaritmos y exponentes.  \n- La función toma dos enteros positivos 'a' y 'b' como entradas.  \n- Encuentra el mayor entero 'x' que satisface las condiciones mencionadas anteriormente.  \n\nArgumentos:  \n$a (int): El número base, debe ser mayor que 1.  \n$b (int): El número de comparación.  \n\nيعيد:  \nint: El mayor entero x que satisface las condiciones.  \n\nEjemplos:  \n- Si a = 10000 y b = 1000000000001, entonces la salida debe ser 3.  \n- Si a = 3 y b = 27, entonces la salida debe ser 3.  ",
      "arb": "يحسب أكبر عدد صحيح x بحيث ax <= b < ax+1 أو x <= logab < x + 1.  \nتساعد هذه الدالة في فهم العلاقة بين رقمين من حيث اللوغاريتمات والأسس.  \n- تأخذ الدالة عددين صحيحين موجبين 'a' و 'b' كمدخلات.  \n- تجد أكبر عدد صحيح 'x' يحقق الشروط المذكورة أعلاه.\n\nالمعاملات:\n$a (int): الرقم الأساسي، يجب أن يكون أكبر من 1.\n$b (int): الرقم المقارن.\n\nالقيم المعادة:\nint: أكبر عدد صحيح x يحقق الشروط.\n\nأمثلة:\n- إذا كان a = 10000 و b = 1000000000001، فيجب أن يكون الناتج 3.\n- إذا كان a = 3 و b = 27، فيجب أن يكون الناتج 3.",
      "sw": "Inakokotoa nambari kubwa zaidi ya x ambapo ax <= b < ax+1 au x <= logab < x + 1. \nKazi hii inasaidia kuelewa uhusiano kati ya nambari mbili kwa kutumia logariti na viinua.\n- Kazi hii inachukua nambari mbili chanya 'a' na 'b' kama pembejeo.\n- Inapata nambari kubwa zaidi ya 'x' inayokidhi masharti yaliyotajwa hapo juu.\n\nHoja:\n$a (int): Nambari ya msingi, lazima iwe kubwa kuliko 1.\n$b (int): Nambari ya kulinganisha.\n\nInarejesha:\nint: Nambari kubwa zaidi ya x inayokidhi masharti.\n\nMifano:\n- Ikiwa a = 10000 na b = 1000000000001, basi matokeo yanapaswa kuwa 3.\n- Ikiwa a = 3 na b = 27, basi matokeo yanapaswa kuwa 3.",
      "tr": "Hesaplar ax <= b < ax+1 veya x <= logab < x + 1 olacak şekilde en büyük tamsayı x.\nBu fonksiyon, iki sayı arasındaki ilişkiyi logaritmalar ve üsler açısından anlamaya yardımcı olur.\n- Fonksiyon, 'a' ve 'b' pozitif tamsayılarını girdi olarak alır.\n- Yukarıda belirtilen koşulları sağlayan en büyük tamsayı 'x'i bulur.\n\nArgümanlar:\n$a (int): Taban sayısı, 1'den büyük olmalıdır.\n$b (int): Karşılaştırma sayısı.\n\nDöndürür:\nint: Koşulları sağlayan en büyük tamsayı x.\n\nÖrnekler:\n- Eğer a = 10000 ve b = 1000000000001 ise, çıktı 3 olmalıdır.\n- Eğer a = 3 ve b = 27 ise, çıktı 3 olmalıdır.",
      "vi": "Tính toán số nguyên lớn nhất x sao cho ax <= b < ax+1 hoặc x <= logab < x + 1. Hàm này giúp hiểu mối quan hệ giữa hai số theo logarit và số mũ.\n- Hàm nhận hai số nguyên dương 'a' và 'b' làm đầu vào.\n- Nó tìm số nguyên lớn nhất 'x' thỏa mãn các điều kiện đã đề cập ở trên.\n\nTham số:\n$a (int): Số cơ số, phải lớn hơn 1.\n$b (int): Số so sánh.\n\nTrả về:\nint: Số nguyên lớn nhất x thỏa mãn các điều kiện.\n\nVí dụ:\n- Nếu a = 10000 và b = 1000000000001, thì kết quả nên là 3.\n- Nếu a = 3 và b = 27, thì kết quả nên là 3."
    },
    "docstring_bertscore": {
      "es": "0.9925287168477537",
      "arb": "0.9825340333348402",
      "sw": "0.941466804795115",
      "tr": "0.9565833713133941",
      "vi": "0.9682646253916749"
    }
  },
  {
    "task_id": "PHP/25",
    "prompt": {
      "en": "<?php\n\n/**\n   * Distribute candy to five children sitting around a round table.\n   *Each child initially has a certain number of candies. They play a game where, starting with one child, and going clockwise, each child divides their candy into three equal parts, and if there are extra candies that cannot be divided equally, the child eats them. Each child keeps one copy and gives the other two copies to their neighbors. The five children completed the above operations in turn.\n   * Input: An array of five integers representing the number of candies each child has.\n   * Output: An array of five integers representing the number of candies each child has after playing the game.\n   */\n\n function distributeCandies(array $candies): array",
      "es": "<?php\n\n/**\n   * Distribuir caramelos a cinco niños sentados alrededor de una mesa redonda.\n   * Cada niño tiene inicialmente un cierto número de caramelos. Juegan un juego donde, comenzando con un niño y yendo en el sentido de las agujas del reloj, cada niño divide sus caramelos en tres partes iguales, y si hay caramelos extra que no pueden dividirse equitativamente, el niño se los come. Cada niño guarda una copia y da las otras dos copias a sus vecinos. Los cinco niños completaron las operaciones anteriores por turno.\n   * Entrada: Un arreglo de cinco enteros que representa el número de caramelos que tiene cada niño.\n   * Salida: Un arreglo de cinco enteros que representa el número de caramelos que tiene cada niño después de jugar el juego.\n   */\n\n function distributeCandies(array $candies): array",
      "arb": "<?php\n\n/**\n   * توزيع الحلوى على خمسة أطفال يجلسون حول طاولة مستديرة.\n   * كل طفل لديه في البداية عدد معين من الحلوى. يلعبون لعبة حيث يبدأون بطفل واحد، ويمرون في اتجاه عقارب الساعة، يقوم كل طفل بتقسيم حلواته إلى ثلاثة أجزاء متساوية، وإذا كانت هناك حلوى زائدة لا يمكن تقسيمها بالتساوي، يأكلها الطفل. يحتفظ كل طفل بنسخة واحدة ويعطي النسختين الأخريين لجيرانه. أكمل الأطفال الخمسة العمليات المذكورة أعلاه بالتناوب.\n   * المدخلات: مصفوفة من خمسة أعداد صحيحة تمثل عدد الحلوى التي يمتلكها كل طفل.\n   * المخرجات: مصفوفة من خمسة أعداد صحيحة تمثل عدد الحلوى التي يمتلكها كل طفل بعد لعب اللعبة.\n   */\n\n function distributeCandies(array $candies): array",
      "sw": "<?php\n\n/**\n   * Gawa pipi kwa watoto watano waliokaa kwenye meza ya mviringo.\n   * Kila mtoto awali ana idadi fulani ya pipi. Wanacheza mchezo ambapo, wakianza na mtoto mmoja, na kwenda kwa mzunguko wa saa, kila mtoto anagawanya pipi zake katika sehemu tatu sawa, na kama kuna pipi za ziada ambazo haziwezi kugawanywa sawa, mtoto huyo anazila. Kila mtoto anabaki na nakala moja na anawapa majirani zake nakala mbili nyingine. Watoto watano walikamilisha operesheni zilizo hapo juu kwa zamu.\n   * Ingizo: Mfululizo wa nambari tano za mzima zinazoonyesha idadi ya pipi kila mtoto anazo.\n   * Tokeo: Mfululizo wa nambari tano za mzima zinazoonyesha idadi ya pipi kila mtoto anazo baada ya kucheza mchezo.\n   */\n\n function distributeCandies(array $candies): array",
      "tr": "<?php\n\n/**\n   * Yuvarlak bir masa etrafında oturan beş çocuğa şeker dağıtın.\n   * Her çocuğun başlangıçta belirli sayıda şekeri vardır. Bir oyun oynarlar, bir çocukla başlayarak ve saat yönünde ilerleyerek, her çocuk şekerlerini üç eşit parçaya böler ve eğer eşit olarak bölünemeyen ekstra şekerler varsa, çocuk onları yer. Her çocuk bir kopyayı kendine saklar ve diğer iki kopyayı komşularına verir. Beş çocuk yukarıdaki işlemleri sırayla tamamlar.\n   * Girdi: Her çocuğun sahip olduğu şeker sayısını temsil eden beş tamsayıdan oluşan bir dizi.\n   * Çıktı: Oyunu oynadıktan sonra her çocuğun sahip olduğu şeker sayısını temsil eden beş tamsayıdan oluşan bir dizi.\n   */\n\n function distributeCandies(array $candies): array",
      "vi": "<?php\n\n/**\n   * Phân phát kẹo cho năm đứa trẻ ngồi quanh một bàn tròn.\n   * Mỗi đứa trẻ ban đầu có một số lượng kẹo nhất định. Chúng chơi một trò chơi mà, bắt đầu từ một đứa trẻ, và đi theo chiều kim đồng hồ, mỗi đứa trẻ chia kẹo của mình thành ba phần bằng nhau, và nếu có kẹo thừa không thể chia đều, đứa trẻ sẽ ăn chúng. Mỗi đứa trẻ giữ một phần và đưa hai phần còn lại cho hai người hàng xóm. Năm đứa trẻ hoàn thành các thao tác trên theo lượt.\n   * Đầu vào: Một mảng gồm năm số nguyên đại diện cho số lượng kẹo mỗi đứa trẻ có.\n   * Đầu ra: Một mảng gồm năm số nguyên đại diện cho số lượng kẹo mỗi đứa trẻ có sau khi chơi trò chơi.\n   */\n\n function distributeCandies(array $candies): array"
    },
    "prompt_bertscore": {
      "es": "0.9934370535802263",
      "arb": "0.95622365169334",
      "sw": "0.9662254858999707",
      "tr": "0.973338241214449",
      "vi": "0.9683246117667474"
    },
    "canonical_solution": " {\n    $n = count($candies);\n    if ($n != 5) {\n        throw new InvalidArgumentException(\"Input must be an array of five integers.\");\n    }\n\n    // Calculate the candies to give and the new count for each child\n    for ($i = 0; $i < $n; $i++) {\n        $divided = intdiv($candies[$i], 3);\n  \n        $candies[$i] = $divided;\n        $leftNeighbor = ($i + $n - 1) % $n;\n        $rightNeighbor = ($i + 1) % $n;\n        $candies[$leftNeighbor]  += $divided;\n        $candies[$rightNeighbor] += $divided;\n    }\n    return $candies;\n}",
    "instruction": {
      "en": "function distributeCandies(array $candies): array\n {\n    $n = count($candies);\n    if ($n != 5) {\n        throw new InvalidArgumentException(\"Input must be an array of five integers.\");\n    }\n\n    // Calculate the candies to give and the new count for each child\n    for ($i = 0; $i < $n; $i++) {\n        $divided = intdiv($candies[$i], 3);\n  \n        $candies[$i] = $divided;\n        $leftNeighbor = ($i + $n - 1) % $n;\n        $rightNeighbor = ($i + 1) % $n;\n        $candies[$leftNeighbor]  += $divided;\n        $candies[$rightNeighbor] += $divided;\n    }\n    return $candies;\n}\n\nProvide a concise natural language description (docstring) of the PHP code in English using at most 500 characters.",
      "es": "function distributeCandies(array $candies): array\n {\n    $n = count($candies);\n    if ($n != 5) {\n        throw new InvalidArgumentException(\"Input must be an array of five integers.\");\n    }\n\n    // Calculate the candies to give and the new count for each child\n    for ($i = 0; $i < $n; $i++) {\n        $divided = intdiv($candies[$i], 3);\n  \n        $candies[$i] = $divided;\n        $leftNeighbor = ($i + $n - 1) % $n;\n        $rightNeighbor = ($i + 1) % $n;\n        $candies[$leftNeighbor]  += $divided;\n        $candies[$rightNeighbor] += $divided;\n    }\n    return $candies;\n}\n\nProporcione una descripción concisa en lenguaje natural (docstring) del código PHP en español utilizando un máximo de 500 caracteres.",
      "arb": "function distributeCandies(array $candies): array\n {\n    $n = count($candies);\n    if ($n != 5) {\n        throw new InvalidArgumentException(\"Input must be an array of five integers.\");\n    }\n\n    // Calculate the candies to give and the new count for each child\n    for ($i = 0; $i < $n; $i++) {\n        $divided = intdiv($candies[$i], 3);\n  \n        $candies[$i] = $divided;\n        $leftNeighbor = ($i + $n - 1) % $n;\n        $rightNeighbor = ($i + 1) % $n;\n        $candies[$leftNeighbor]  += $divided;\n        $candies[$rightNeighbor] += $divided;\n    }\n    return $candies;\n}\n\nيرجى تقديم وصف موجز بلغة طبيعية (docstring) للكود المكتوب بلغة PHP باللغة العربية الفصحى، بحيث لا يتجاوز 500 حرف.",
      "sw": "function distributeCandies(array $candies): array\n {\n    $n = count($candies);\n    if ($n != 5) {\n        throw new InvalidArgumentException(\"Input must be an array of five integers.\");\n    }\n\n    // Calculate the candies to give and the new count for each child\n    for ($i = 0; $i < $n; $i++) {\n        $divided = intdiv($candies[$i], 3);\n  \n        $candies[$i] = $divided;\n        $leftNeighbor = ($i + $n - 1) % $n;\n        $rightNeighbor = ($i + 1) % $n;\n        $candies[$leftNeighbor]  += $divided;\n        $candies[$rightNeighbor] += $divided;\n    }\n    return $candies;\n}\n\nToa maelezo mafupi ya lugha ya asili (docstring) ya msimbo wa PHP kwa Kiswahili kwa kutumia herufi zisizozidi 500.",
      "tr": "function distributeCandies(array $candies): array\n {\n    $n = count($candies);\n    if ($n != 5) {\n        throw new InvalidArgumentException(\"Input must be an array of five integers.\");\n    }\n\n    // Calculate the candies to give and the new count for each child\n    for ($i = 0; $i < $n; $i++) {\n        $divided = intdiv($candies[$i], 3);\n  \n        $candies[$i] = $divided;\n        $leftNeighbor = ($i + $n - 1) % $n;\n        $rightNeighbor = ($i + 1) % $n;\n        $candies[$leftNeighbor]  += $divided;\n        $candies[$rightNeighbor] += $divided;\n    }\n    return $candies;\n}\n\nPHP kodunun işlevini açıklayan kısa bir doğal dil tanımı (docstring) sağlayın. Açıklama, Türkçe dilinde ve en fazla 500 karakter olmalıdır.",
      "vi": "function distributeCandies(array $candies): array\n {\n    $n = count($candies);\n    if ($n != 5) {\n        throw new InvalidArgumentException(\"Input must be an array of five integers.\");\n    }\n\n    // Calculate the candies to give and the new count for each child\n    for ($i = 0; $i < $n; $i++) {\n        $divided = intdiv($candies[$i], 3);\n  \n        $candies[$i] = $divided;\n        $leftNeighbor = ($i + $n - 1) % $n;\n        $rightNeighbor = ($i + 1) % $n;\n        $candies[$leftNeighbor]  += $divided;\n        $candies[$rightNeighbor] += $divided;\n    }\n    return $candies;\n}\n\nCung cấp mô tả ngắn gọn bằng ngôn ngữ tự nhiên (docstring) cho mã PHP bằng tiếng Việt với tối đa 500 ký tự."
    },
    "instruction_bertscore": {
      "es": "0.9687069752502395",
      "arb": "0.8833251100712498",
      "sw": "0.91585798565943",
      "tr": "0.858384086276604",
      "vi": "0.9017250367880356"
    },
    "level": "",
    "test": "function main(){\n    $candies = distributeCandies([8, 9, 10, 11, 12]);\n    assert($candies === [11, 7, 9, 11, 6]);\n    \n    \n}\n\nmain();\n?>",
    "entry_point": "distributeCandies",
    "signature": "function distributeCandies(array $candies): array",
    "docstring": {
      "en": "Distribute candy to five children sitting around a round table.\nEach child initially has a certain number of candies. They play a game where, starting with one child, and going clockwise, each child divides their candy into three equal parts, and if there are extra candies that cannot be divided equally, the child eats them. Each child keeps one copy and gives the other two copies to their neighbors. The five children completed the above operations in turn.\nInput: An array of five integers representing the number of candies each child has.\nOutput: An array of five integers representing the number of candies each child has after playing the game.",
      "es": "Distribuir caramelos a cinco niños sentados alrededor de una mesa redonda.  \nCada niño inicialmente tiene una cierta cantidad de caramelos. Juegan un juego donde, comenzando con un niño y siguiendo en el sentido de las agujas del reloj, cada niño divide sus caramelos en tres partes iguales, y si hay caramelos extra que no se pueden dividir equitativamente, el niño se los come. Cada niño guarda una copia y da las otras dos copias a sus vecinos. Los cinco niños completaron las operaciones anteriores por turno.  \nEntrada: Un arreglo de cinco enteros que representa la cantidad de caramelos que tiene cada niño.  \nSalida: Un arreglo de cinco enteros que representa la cantidad de caramelos que tiene cada niño después de jugar el juego.",
      "arb": "توزيع الحلوى على خمسة أطفال يجلسون حول طاولة مستديرة.  \nكل طفل لديه في البداية عدد معين من الحلوى. يلعبون لعبة حيث، بدءًا من طفل واحد، وبالاتجاه عقارب الساعة، يقوم كل طفل بتقسيم حلواته إلى ثلاثة أجزاء متساوية، وإذا كانت هناك حلوى إضافية لا يمكن تقسيمها بالتساوي، يأكلها الطفل. يحتفظ كل طفل بنسخة واحدة ويعطي النسختين الأخريين لجيرانه. أكمل الأطفال الخمسة العمليات المذكورة أعلاه بالتناوب.  \nالمدخلات: مصفوفة من خمسة أعداد صحيحة تمثل عدد الحلوى التي يمتلكها كل طفل.  \nالمخرجات: مصفوفة من خمسة أعداد صحيحة تمثل عدد الحلوى التي يمتلكها كل طفل بعد لعب اللعبة.",
      "sw": "Sambaza pipi kwa watoto watano waliokaa kuzunguka meza ya mviringo.  \nKila mtoto awali ana idadi fulani ya pipi. Wanacheza mchezo ambapo, wakianza na mtoto mmoja, na kwenda kwa mzunguko wa saa, kila mtoto anagawanya pipi zake katika sehemu tatu sawa, na ikiwa kuna pipi za ziada ambazo haziwezi kugawanywa sawa, mtoto huyo anazila. Kila mtoto anabaki na nakala moja na anawapa majirani zake nakala mbili nyingine. Watoto watano wanakamilisha shughuli zilizo hapo juu kwa zamu.  \nIngizo: Safu ya nambari tano za mzima zinazoashiria idadi ya pipi kila mtoto anayo.  \nPato: Safu ya nambari tano za mzima zinazoashiria idadi ya pipi kila mtoto anayo baada ya kucheza mchezo.",
      "tr": "Beş çocuğa yuvarlak bir masa etrafında şeker dağıtın.  \nHer çocuğun başlangıçta belirli sayıda şekeri vardır. Bir oyun oynarlar, burada bir çocukla başlayarak ve saat yönünde ilerleyerek, her çocuk şekerlerini üç eşit parçaya böler ve eşit olarak bölünemeyen ekstra şekerler varsa, çocuk onları yer. Her çocuk bir kopyayı kendine saklar ve diğer iki kopyayı komşularına verir. Beş çocuk yukarıdaki işlemleri sırayla tamamladı.  \nGirdi: Her çocuğun sahip olduğu şeker sayısını temsil eden beş tam sayıdan oluşan bir dizi.  \nÇıktı: Oyunu oynadıktan sonra her çocuğun sahip olduğu şeker sayısını temsil eden beş tam sayıdan oluşan bir dizi.",
      "vi": "Phân phát kẹo cho năm đứa trẻ ngồi quanh một bàn tròn.  \nMỗi đứa trẻ ban đầu có một số lượng kẹo nhất định. Chúng chơi một trò chơi mà, bắt đầu từ một đứa trẻ, và đi theo chiều kim đồng hồ, mỗi đứa trẻ chia kẹo của mình thành ba phần bằng nhau, và nếu có kẹo dư không thể chia đều, đứa trẻ sẽ ăn chúng. Mỗi đứa trẻ giữ một phần và đưa hai phần còn lại cho hai đứa trẻ bên cạnh. Năm đứa trẻ thực hiện các thao tác trên lần lượt.  \nĐầu vào: Một mảng gồm năm số nguyên đại diện cho số lượng kẹo mỗi đứa trẻ có.  \nĐầu ra: Một mảng gồm năm số nguyên đại diện cho số lượng kẹo mỗi đứa trẻ có sau khi chơi trò chơi.  "
    },
    "docstring_bertscore": {
      "es": "0.9807980038045953",
      "arb": "0.9612944866907797",
      "sw": "0.9646594839758916",
      "tr": "0.9649147240155215",
      "vi": "0.9511961181189659"
    }
  },
  {
    "task_id": "PHP/26",
    "prompt": {
      "en": "<?php\n\n/**\n * Determines a pen purchase plan to maximize the number of pens bought with a given amount of class fund.\n * There are three types of pens available at prices of 6, 5, and 4 units respectively.\n * The objective is to buy as many pens as possible without any remaining class fund.\n * \n * Input: An integer representing the total class fund available.\n * Output: An array with three integers representing the count of pens bought at 6 units, 5 units, and 4 units, in that order.\n * \n * Example:\n * findPenPurchasePlan(10)\n * Output: [1, 0, 1] (One pen of 6 units and one pen of 4 units)\n */\nfunction findPenPurchasePlan(int $totalFund): array ",
      "es": "<?php\n\n/**\n * Determina un plan de compra de bolígrafos para maximizar el número de bolígrafos comprados con una cantidad dada del fondo de la clase.\n * Hay tres tipos de bolígrafos disponibles a precios de 6, 5 y 4 unidades respectivamente.\n * El objetivo es comprar tantos bolígrafos como sea posible sin que quede ningún fondo de la clase.\n * \n * Entrada: Un entero que representa el fondo total de la clase disponible.\n * Salida: Un arreglo con tres enteros que representan la cantidad de bolígrafos comprados a 6 unidades, 5 unidades y 4 unidades, en ese orden.\n * \n * Ejemplo:\n * findPenPurchasePlan(10)\n * Salida: [1, 0, 1] (Un bolígrafo de 6 unidades y un bolígrafo de 4 unidades)\n */\nfunction findPenPurchasePlan(int $totalFund): array ",
      "arb": "<?php\n\n/**\n * يحدد خطة شراء الأقلام لتعظيم عدد الأقلام المشتراة بمبلغ معين من صندوق الفصل.\n * هناك ثلاثة أنواع من الأقلام متوفرة بأسعار 6 و 5 و 4 وحدات على التوالي.\n * الهدف هو شراء أكبر عدد ممكن من الأقلام دون أي بقايا من صندوق الفصل.\n * \n * المدخلات: عدد صحيح يمثل إجمالي صندوق الفصل المتاح.\n * المخرجات: مصفوفة تحتوي على ثلاثة أعداد صحيحة تمثل عدد الأقلام المشتراة بأسعار 6 وحدات، 5 وحدات، و 4 وحدات، بهذا الترتيب.\n * \n * مثال:\n * findPenPurchasePlan(10)\n * المخرجات: [1, 0, 1] (قلم واحد بسعر 6 وحدات وقلم واحد بسعر 4 وحدات)\n */\nfunction findPenPurchasePlan(int $totalFund): array ",
      "sw": "<?php\n\n/**\n * Huamua mpango wa ununuzi wa kalamu ili kuongeza idadi ya kalamu zinazoweza kununuliwa kwa kiasi fulani cha fedha za darasa.\n * Kuna aina tatu za kalamu zinazopatikana kwa bei ya vitengo 6, 5, na 4 mtawalia.\n * Lengo ni kununua kalamu nyingi iwezekanavyo bila kubakiza fedha za darasa.\n * \n * Ingizo: Nambari nzima inayowakilisha jumla ya fedha za darasa zinazopatikana.\n * Matokeo: Mfululizo wa nambari tatu zinazowakilisha idadi ya kalamu zilizonunuliwa kwa vitengo 6, 5, na 4, kwa mpangilio huo.\n * \n * Mfano:\n * findPenPurchasePlan(10)\n * Matokeo: [1, 0, 1] (Kalamu moja ya vitengo 6 na kalamu moja ya vitengo 4)\n */\nfunction findPenPurchasePlan(int $totalFund): array ",
      "tr": "<?php\n\n/**\n * Belirli bir sınıf fonuyla alınabilecek maksimum kalem sayısını belirleyen bir kalem satın alma planı.\n * Sırasıyla 6, 5 ve 4 birim fiyatlarında üç tür kalem bulunmaktadır.\n * Amaç, hiç sınıf fonu kalmayacak şekilde mümkün olduğunca fazla kalem satın almaktır.\n * \n * Girdi: Kullanılabilir toplam sınıf fonunu temsil eden bir tamsayı.\n * Çıktı: Sırasıyla 6 birim, 5 birim ve 4 birim fiyatındaki kalemlerin sayısını temsil eden üç tamsayıdan oluşan bir dizi.\n * \n * Örnek:\n * findPenPurchasePlan(10)\n * Çıktı: [1, 0, 1] (Bir adet 6 birimlik kalem ve bir adet 4 birimlik kalem)\n */\nfunction findPenPurchasePlan(int $totalFund): array ",
      "vi": "<?php\n\n/**\n * Xác định kế hoạch mua bút để tối đa hóa số lượng bút mua được với một số tiền quỹ lớp cho trước.\n * Có ba loại bút có sẵn với giá lần lượt là 6, 5 và 4 đơn vị.\n * Mục tiêu là mua càng nhiều bút càng tốt mà không còn lại quỹ lớp.\n * \n * Đầu vào: Một số nguyên đại diện cho tổng số tiền quỹ lớp có sẵn.\n * Đầu ra: Một mảng với ba số nguyên đại diện cho số lượng bút mua được ở mức giá 6 đơn vị, 5 đơn vị và 4 đơn vị, theo thứ tự đó.\n * \n * Ví dụ:\n * findPenPurchasePlan(10)\n * Đầu ra: [1, 0, 1] (Một bút giá 6 đơn vị và một bút giá 4 đơn vị)\n */\nfunction findPenPurchasePlan(int $totalFund): array "
    },
    "prompt_bertscore": {
      "es": "0.9872967926112948",
      "arb": "0.96465531273789",
      "sw": "0.951577885711315",
      "tr": "0.9318032381273866",
      "vi": "0.9614120758763522"
    },
    "canonical_solution": "{\n    $pensAt6Units = 0;\n    $pensAt5Units = 0;\n    $pensAt4Units = 0;\n\n    switch ($totalFund % 4) {\n        case 0:\n            $pensAt4Units = $totalFund / 4;\n            break;\n        case 1:\n            if ($totalFund >= 9) { // To avoid negative counts\n                $pensAt5Units = 1;\n                $pensAt4Units = ($totalFund - 9) / 4;\n            }\n            break;\n        case 2:\n            if ($totalFund >= 6) { // To avoid negative counts\n                $pensAt6Units = 1;\n                $pensAt4Units = ($totalFund - 6) / 4;\n            }\n            break;\n        case 3:\n            if ($totalFund >= 15) { // Ensures no negative counts\n                $pensAt6Units = 1;\n                $pensAt5Units = 1;\n                $pensAt4Units = ($totalFund - 15) / 4;\n            }\n            break;\n    }\n    echo $pensAt6Units;\n    echo \"\\n\";\n    echo $pensAt5Units;\n    echo \"\\n\";\n    echo $pensAt4Units;\n    echo \"\\n\";\n    return [$pensAt6Units, $pensAt5Units, $pensAt4Units];\n}",
    "instruction": {
      "en": "function findPenPurchasePlan(int $totalFund): array\n{\n    $pensAt6Units = 0;\n    $pensAt5Units = 0;\n    $pensAt4Units = 0;\n\n    switch ($totalFund % 4) {\n        case 0:\n            $pensAt4Units = $totalFund / 4;\n            break;\n        case 1:\n            if ($totalFund >= 9) { // To avoid negative counts\n                $pensAt5Units = 1;\n                $pensAt4Units = ($totalFund - 9) / 4;\n            }\n            break;\n        case 2:\n            if ($totalFund >= 6) { // To avoid negative counts\n                $pensAt6Units = 1;\n                $pensAt4Units = ($totalFund - 6) / 4;\n            }\n            break;\n        case 3:\n            if ($totalFund >= 15) { // Ensures no negative counts\n                $pensAt6Units = 1;\n                $pensAt5Units = 1;\n                $pensAt4Units = ($totalFund - 15) / 4;\n            }\n            break;\n    }\n    echo $pensAt6Units;\n    echo \"\\n\";\n    echo $pensAt5Units;\n    echo \"\\n\";\n    echo $pensAt4Units;\n    echo \"\\n\";\n    return [$pensAt6Units, $pensAt5Units, $pensAt4Units];\n}\n\nProvide a concise natural language description (docstring) of the PHP code in English using at most 500 characters.",
      "es": "function findPenPurchasePlan(int $totalFund): array\n{\n    $pensAt6Units = 0;\n    $pensAt5Units = 0;\n    $pensAt4Units = 0;\n\n    switch ($totalFund % 4) {\n        case 0:\n            $pensAt4Units = $totalFund / 4;\n            break;\n        case 1:\n            if ($totalFund >= 9) { // To avoid negative counts\n                $pensAt5Units = 1;\n                $pensAt4Units = ($totalFund - 9) / 4;\n            }\n            break;\n        case 2:\n            if ($totalFund >= 6) { // To avoid negative counts\n                $pensAt6Units = 1;\n                $pensAt4Units = ($totalFund - 6) / 4;\n            }\n            break;\n        case 3:\n            if ($totalFund >= 15) { // Ensures no negative counts\n                $pensAt6Units = 1;\n                $pensAt5Units = 1;\n                $pensAt4Units = ($totalFund - 15) / 4;\n            }\n            break;\n    }\n    echo $pensAt6Units;\n    echo \"\\n\";\n    echo $pensAt5Units;\n    echo \"\\n\";\n    echo $pensAt4Units;\n    echo \"\\n\";\n    return [$pensAt6Units, $pensAt5Units, $pensAt4Units];\n}\n\nProporcione una descripción concisa en lenguaje natural (docstring) del código PHP en español utilizando un máximo de 500 caracteres.",
      "arb": "function findPenPurchasePlan(int $totalFund): array\n{\n    $pensAt6Units = 0;\n    $pensAt5Units = 0;\n    $pensAt4Units = 0;\n\n    switch ($totalFund % 4) {\n        case 0:\n            $pensAt4Units = $totalFund / 4;\n            break;\n        case 1:\n            if ($totalFund >= 9) { // To avoid negative counts\n                $pensAt5Units = 1;\n                $pensAt4Units = ($totalFund - 9) / 4;\n            }\n            break;\n        case 2:\n            if ($totalFund >= 6) { // To avoid negative counts\n                $pensAt6Units = 1;\n                $pensAt4Units = ($totalFund - 6) / 4;\n            }\n            break;\n        case 3:\n            if ($totalFund >= 15) { // Ensures no negative counts\n                $pensAt6Units = 1;\n                $pensAt5Units = 1;\n                $pensAt4Units = ($totalFund - 15) / 4;\n            }\n            break;\n    }\n    echo $pensAt6Units;\n    echo \"\\n\";\n    echo $pensAt5Units;\n    echo \"\\n\";\n    echo $pensAt4Units;\n    echo \"\\n\";\n    return [$pensAt6Units, $pensAt5Units, $pensAt4Units];\n}\n\nيرجى تقديم وصف موجز بلغة طبيعية (docstring) للكود المكتوب بلغة PHP باللغة العربية الفصحى، على ألا يتجاوز 500 حرف.",
      "sw": "function findPenPurchasePlan(int $totalFund): array\n{\n    $pensAt6Units = 0;\n    $pensAt5Units = 0;\n    $pensAt4Units = 0;\n\n    switch ($totalFund % 4) {\n        case 0:\n            $pensAt4Units = $totalFund / 4;\n            break;\n        case 1:\n            if ($totalFund >= 9) { // To avoid negative counts\n                $pensAt5Units = 1;\n                $pensAt4Units = ($totalFund - 9) / 4;\n            }\n            break;\n        case 2:\n            if ($totalFund >= 6) { // To avoid negative counts\n                $pensAt6Units = 1;\n                $pensAt4Units = ($totalFund - 6) / 4;\n            }\n            break;\n        case 3:\n            if ($totalFund >= 15) { // Ensures no negative counts\n                $pensAt6Units = 1;\n                $pensAt5Units = 1;\n                $pensAt4Units = ($totalFund - 15) / 4;\n            }\n            break;\n    }\n    echo $pensAt6Units;\n    echo \"\\n\";\n    echo $pensAt5Units;\n    echo \"\\n\";\n    echo $pensAt4Units;\n    echo \"\\n\";\n    return [$pensAt6Units, $pensAt5Units, $pensAt4Units];\n}\n\nToa maelezo mafupi ya lugha ya asili (docstring) ya msimbo wa PHP kwa Kiswahili kwa kutumia herufi zisizozidi 500.",
      "tr": "function findPenPurchasePlan(int $totalFund): array\n{\n    $pensAt6Units = 0;\n    $pensAt5Units = 0;\n    $pensAt4Units = 0;\n\n    switch ($totalFund % 4) {\n        case 0:\n            $pensAt4Units = $totalFund / 4;\n            break;\n        case 1:\n            if ($totalFund >= 9) { // To avoid negative counts\n                $pensAt5Units = 1;\n                $pensAt4Units = ($totalFund - 9) / 4;\n            }\n            break;\n        case 2:\n            if ($totalFund >= 6) { // To avoid negative counts\n                $pensAt6Units = 1;\n                $pensAt4Units = ($totalFund - 6) / 4;\n            }\n            break;\n        case 3:\n            if ($totalFund >= 15) { // Ensures no negative counts\n                $pensAt6Units = 1;\n                $pensAt5Units = 1;\n                $pensAt4Units = ($totalFund - 15) / 4;\n            }\n            break;\n    }\n    echo $pensAt6Units;\n    echo \"\\n\";\n    echo $pensAt5Units;\n    echo \"\\n\";\n    echo $pensAt4Units;\n    echo \"\\n\";\n    return [$pensAt6Units, $pensAt5Units, $pensAt4Units];\n}\n\nPHP kodunun işlevini açıklayan kısa bir doğal dil açıklaması (docstring) sağlayın. Açıklama, en fazla 500 karakter kullanılarak Türkçe olarak yazılmalıdır.",
      "vi": "function findPenPurchasePlan(int $totalFund): array\n{\n    $pensAt6Units = 0;\n    $pensAt5Units = 0;\n    $pensAt4Units = 0;\n\n    switch ($totalFund % 4) {\n        case 0:\n            $pensAt4Units = $totalFund / 4;\n            break;\n        case 1:\n            if ($totalFund >= 9) { // To avoid negative counts\n                $pensAt5Units = 1;\n                $pensAt4Units = ($totalFund - 9) / 4;\n            }\n            break;\n        case 2:\n            if ($totalFund >= 6) { // To avoid negative counts\n                $pensAt6Units = 1;\n                $pensAt4Units = ($totalFund - 6) / 4;\n            }\n            break;\n        case 3:\n            if ($totalFund >= 15) { // Ensures no negative counts\n                $pensAt6Units = 1;\n                $pensAt5Units = 1;\n                $pensAt4Units = ($totalFund - 15) / 4;\n            }\n            break;\n    }\n    echo $pensAt6Units;\n    echo \"\\n\";\n    echo $pensAt5Units;\n    echo \"\\n\";\n    echo $pensAt4Units;\n    echo \"\\n\";\n    return [$pensAt6Units, $pensAt5Units, $pensAt4Units];\n}\n\nCung cấp mô tả ngắn gọn bằng ngôn ngữ tự nhiên (docstring) cho mã PHP bằng tiếng Việt với tối đa 500 ký tự."
    },
    "instruction_bertscore": {
      "es": "0.9687069752502395",
      "arb": "0.8898884537517856",
      "sw": "0.9428367585331127",
      "tr": "0.869166935141464",
      "vi": "0.9150604846795749"
    },
    "level": "",
    "test": "function main(){\n    assert(findPenPurchasePlan(10) === [1, 0, 1]);\n    assert(findPenPurchasePlan(14) === [1, 0, 2]);\n    assert(findPenPurchasePlan(24) === [0, 0, 6]);\n    \n}\n\nmain();\n?>",
    "entry_point": "findPenPurchasePlan",
    "signature": "function findPenPurchasePlan(int $totalFund): array",
    "docstring": {
      "en": "Determines a pen purchase plan to maximize the number of pens bought with a given amount of class fund.\nThere are three types of pens available at prices of 6, 5, and 4 units respectively.\nThe objective is to buy as many pens as possible without any remaining class fund.\n\nInput: An integer representing the total class fund available.\nOutput: An array with three integers representing the count of pens bought at 6 units, 5 units, and 4 units, in that order.\n\nExample:\nfindPenPurchasePlan(10)\nOutput: [1, 0, 1] (One pen of 6 units and one pen of 4 units)",
      "es": "Determina un plan de compra de bolígrafos para maximizar la cantidad de bolígrafos comprados con una cantidad dada del fondo de la clase. Hay tres tipos de bolígrafos disponibles a precios de 6, 5 y 4 unidades respectivamente. El objetivo es comprar la mayor cantidad posible de bolígrafos sin que quede ningún fondo de la clase.\n\nEntrada: Un entero que representa el total del fondo de la clase disponible. Salida: Un arreglo con tres enteros que representan la cantidad de bolígrafos comprados a 6 unidades, 5 unidades y 4 unidades, en ese orden.\n\nEjemplo: findPenPurchasePlan(10) Salida: [1, 0, 1] (Un bolígrafo de 6 unidades y un bolígrafo de 4 unidades)",
      "arb": "يحدد خطة شراء الأقلام لتعظيم عدد الأقلام المشتراة بمبلغ معين من صندوق الفصل.\nهناك ثلاثة أنواع من الأقلام المتاحة بأسعار 6 و 5 و 4 وحدات على التوالي.\nالهدف هو شراء أكبر عدد ممكن من الأقلام دون أي بقايا من صندوق الفصل.\n\nالمدخلات: عدد صحيح يمثل إجمالي صندوق الفصل المتاح.\nالمخرجات: مصفوفة تحتوي على ثلاثة أعداد صحيحة تمثل عدد الأقلام المشتراة بأسعار 6 وحدات، 5 وحدات، و 4 وحدات، بهذا الترتيب.\n\nمثال:\nfindPenPurchasePlan(10)\nالمخرجات: [1, 0, 1] (قلم واحد بسعر 6 وحدات وقلم واحد بسعر 4 وحدات)",
      "sw": "Inabainisha mpango wa ununuzi wa kalamu ili kuongeza idadi ya kalamu zinazoweza kununuliwa kwa kiasi fulani cha fedha za darasa.\nKuna aina tatu za kalamu zinazopatikana kwa bei ya vitengo 6, 5, na 4 mtawalia.\nLengo ni kununua kalamu nyingi iwezekanavyo bila kubakiza fedha zozote za darasa.\n\nIngizo: Nambari kamili inayowakilisha jumla ya fedha za darasa zinazopatikana.\nMatokeo: Mfululizo wa nambari tatu kamili zinazowakilisha idadi ya kalamu zilizonunuliwa kwa vitengo 6, 5, na 4, kwa mpangilio huo.\n\nMfano:\nfindPenPurchasePlan(10)\nMatokeo: [1, 0, 1] (Kalamu moja ya vitengo 6 na kalamu moja ya vitengo 4)",
      "tr": "Verilen sınıf fonuyla satın alınabilecek maksimum kalem sayısını belirleyen bir kalem satın alma planı belirler.\nFiyatları sırasıyla 6, 5 ve 4 birim olan üç tür kalem mevcuttur.\nAmaç, sınıf fonunda hiç para kalmayacak şekilde mümkün olduğunca fazla kalem satın almaktır.\n\nGirdi: Kullanılabilir toplam sınıf fonunu temsil eden bir tamsayı.\nÇıktı: Sırasıyla 6 birim, 5 birim ve 4 birim fiyatlı kalemlerden satın alınan miktarları temsil eden üç tamsayıdan oluşan bir dizi.\n\nÖrnek:\nfindPenPurchasePlan(10)\nÇıktı: [1, 0, 1] (Bir adet 6 birimlik kalem ve bir adet 4 birimlik kalem)",
      "vi": "Xác định kế hoạch mua bút để tối đa hóa số lượng bút mua được với một số tiền quỹ lớp cho trước.  \nCó ba loại bút có giá lần lượt là 6, 5 và 4 đơn vị.  \nMục tiêu là mua càng nhiều bút càng tốt mà không còn lại quỹ lớp.\n\nĐầu vào: Một số nguyên đại diện cho tổng số quỹ lớp có sẵn.  \nĐầu ra: Một mảng với ba số nguyên đại diện cho số lượng bút mua được với giá 6 đơn vị, 5 đơn vị và 4 đơn vị, theo thứ tự đó.\n\nVí dụ:  \nfindPenPurchasePlan(10)  \nĐầu ra: [1, 0, 1] (Một bút giá 6 đơn vị và một bút giá 4 đơn vị)"
    },
    "docstring_bertscore": {
      "es": "0.9762199707825032",
      "arb": "0.95298379154828",
      "sw": "0.9302173731652041",
      "tr": "0.9036046760837687",
      "vi": "0.9474185655324444"
    }
  },
  {
    "task_id": "PHP/27",
    "prompt": {
      "en": "<?php\n\n/**\n    * Finds the smallest integer divisor greater than 1 that yields the same remainder when dividing three given numbers.\n    * This problem involves finding the minimum value of x (where x > 1) such that when x divides each of the \n    * three integers a, b, and c, the remainders are the same.\n    * Input: Three positive integers a, b, and c, each not exceeding 1,000,000.\n    * Output: Returns the smallest integer value of x that satisfies the condition.\n    * Example: For a = 300, b = 262, c = 205, the function returns 19.\n*/\n\nfunction findMinimumDivisor($a, $b, $c)",
      "es": "<?php\n\n/**\n    * Encuentra el divisor entero más pequeño mayor que 1 que produce el mismo residuo al dividir tres números dados.\n    * Este problema implica encontrar el valor mínimo de x (donde x > 1) tal que cuando x divide cada uno de los \n    * tres enteros a, b y c, los residuos son los mismos.\n    * Entrada: Tres enteros positivos a, b y c, cada uno no excede 1,000,000.\n    * Salida: Devuelve el valor entero más pequeño de x que satisface la condición.\n    * Ejemplo: Para a = 300, b = 262, c = 205, la función devuelve 19.\n*/\n\nfunction findMinimumDivisor($a, $b, $c)",
      "arb": "<?php\n\n/**\n    * يجد أصغر مقسوم صحيح أكبر من 1 الذي يعطي نفس الباقي عند قسمة ثلاثة أعداد معطاة.\n    * تتضمن هذه المشكلة إيجاد القيمة الدنيا لـ x (حيث x > 1) بحيث عندما يقسم x كل من \n    * الأعداد الصحيحة الثلاثة a و b و c، تكون البواقي متساوية.\n    * المدخلات: ثلاثة أعداد صحيحة موجبة a و b و c، كل منها لا يتجاوز 1,000,000.\n    * المخرجات: يعيد أصغر قيمة صحيحة لـ x التي تحقق الشرط.\n    * مثال: لـ a = 300 و b = 262 و c = 205، تعيد الدالة 19.\n*/\n\nfunction findMinimumDivisor($a, $b, $c)",
      "sw": "<?php\n\n/**\n    * Inapata mgawanyiko mdogo zaidi wa nambari nzima zaidi ya 1 ambao unatoa baki sawa wakati wa kugawanya nambari tatu zilizotolewa.\n    * Shida hii inahusisha kupata thamani ndogo ya x (ambapo x > 1) ili kwamba x inapogawa kila moja ya \n    * nambari tatu a, b, na c, mabaki ni sawa.\n    * Ingizo: Nambari tatu chanya a, b, na c, kila moja haizidi 1,000,000.\n    * Matokeo: Inarudisha thamani ndogo zaidi ya x inayokidhi hali hiyo.\n    * Mfano: Kwa a = 300, b = 262, c = 205, kazi inarudisha 19.\n*/\n\nfunction findMinimumDivisor($a, $b, $c)",
      "tr": "<?php\n\n/**\n    * Üç verilen sayıyı bölerken aynı kalanı veren 1'den büyük en küçük tam sayı bölenini bulur.\n    * Bu problem, x > 1 olan x'in minimum değerini bulmayı içerir, öyle ki x, \n    * üç tam sayı a, b ve c'nin her birini böldüğünde kalanlar aynı olur.\n    * Girdi: Her biri 1.000.000'u geçmeyen üç pozitif tam sayı a, b ve c.\n    * Çıktı: Koşulu sağlayan en küçük tam sayı x değerini döndürür.\n    * Örnek: a = 300, b = 262, c = 205 için, fonksiyon 19 döndürür.\n*/\n\nfunction findMinimumDivisor($a, $b, $c)",
      "vi": "<?php\n\n/**\n    * Tìm ước số nguyên nhỏ nhất lớn hơn 1 mà cho cùng một số dư khi chia ba số đã cho.\n    * Vấn đề này liên quan đến việc tìm giá trị nhỏ nhất của x (với x > 1) sao cho khi x chia mỗi \n    * ba số nguyên a, b và c, các số dư là như nhau.\n    * Đầu vào: Ba số nguyên dương a, b và c, mỗi số không vượt quá 1,000,000.\n    * Đầu ra: Trả về giá trị nguyên nhỏ nhất của x thỏa mãn điều kiện.\n    * Ví dụ: Với a = 300, b = 262, c = 205, hàm trả về 19.\n*/\n\nfunction findMinimumDivisor($a, $b, $c)"
    },
    "prompt_bertscore": {
      "es": "0.9974593187961828",
      "arb": "0.9902363236202301",
      "sw": "0.9775271573200938",
      "tr": "0.959184237522665",
      "vi": "0.9795472282952186"
    },
    "canonical_solution": " {\n    $minDiff = min(abs($a - $b), abs($b - $c), abs($c - $a));\n\n    for ($x = 2; $x <= $minDiff; $x++) {\n        if ($a % $x === $b % $x && $b % $x === $c % $x) {\n            return $x;\n        }\n    }\n\n    // In case no common divisor is found, which should not happen as per the problem's guarantee.\n    return -1;\n}",
    "instruction": {
      "en": "function findMinimumDivisor($a, $b, $c)\n {\n    $minDiff = min(abs($a - $b), abs($b - $c), abs($c - $a));\n\n    for ($x = 2; $x <= $minDiff; $x++) {\n        if ($a % $x === $b % $x && $b % $x === $c % $x) {\n            return $x;\n        }\n    }\n\n    // In case no common divisor is found, which should not happen as per the problem's guarantee.\n    return -1;\n}\n\nProvide a concise natural language description (docstring) of the PHP code in English using at most 500 characters.",
      "es": "function findMinimumDivisor($a, $b, $c)\n {\n    $minDiff = min(abs($a - $b), abs($b - $c), abs($c - $a));\n\n    for ($x = 2; $x <= $minDiff; $x++) {\n        if ($a % $x === $b % $x && $b % $x === $c % $x) {\n            return $x;\n        }\n    }\n\n    // In case no common divisor is found, which should not happen as per the problem's guarantee.\n    return -1;\n}\n\nProporcione una descripción concisa en lenguaje natural (docstring) del código PHP en español utilizando un máximo de 500 caracteres.",
      "arb": "function findMinimumDivisor($a, $b, $c)\n {\n    $minDiff = min(abs($a - $b), abs($b - $c), abs($c - $a));\n\n    for ($x = 2; $x <= $minDiff; $x++) {\n        if ($a % $x === $b % $x && $b % $x === $c % $x) {\n            return $x;\n        }\n    }\n\n    // In case no common divisor is found, which should not happen as per the problem's guarantee.\n    return -1;\n}\n\nيرجى تقديم وصف موجز بلغة طبيعية (docstring) للكود البرمجي المكتوب بلغة PHP باللغة العربية الفصحى، بحيث لا يتجاوز 500 حرف.",
      "sw": "function findMinimumDivisor($a, $b, $c)\n {\n    $minDiff = min(abs($a - $b), abs($b - $c), abs($c - $a));\n\n    for ($x = 2; $x <= $minDiff; $x++) {\n        if ($a % $x === $b % $x && $b % $x === $c % $x) {\n            return $x;\n        }\n    }\n\n    // In case no common divisor is found, which should not happen as per the problem's guarantee.\n    return -1;\n}\n\nToa maelezo mafupi ya lugha ya asili (docstring) ya msimbo wa PHP kwa Kiswahili kwa kutumia herufi zisizozidi 500.",
      "tr": "function findMinimumDivisor($a, $b, $c)\n {\n    $minDiff = min(abs($a - $b), abs($b - $c), abs($c - $a));\n\n    for ($x = 2; $x <= $minDiff; $x++) {\n        if ($a % $x === $b % $x && $b % $x === $c % $x) {\n            return $x;\n        }\n    }\n\n    // In case no common divisor is found, which should not happen as per the problem's guarantee.\n    return -1;\n}\n\nPHP kodunun işlevini açıklayan kısa bir doğal dil açıklaması (docstring) sağlayın. Açıklama Türkçe olmalı ve en fazla 500 karakter kullanılmalıdır.",
      "vi": "function findMinimumDivisor($a, $b, $c)\n {\n    $minDiff = min(abs($a - $b), abs($b - $c), abs($c - $a));\n\n    for ($x = 2; $x <= $minDiff; $x++) {\n        if ($a % $x === $b % $x && $b % $x === $c % $x) {\n            return $x;\n        }\n    }\n\n    // In case no common divisor is found, which should not happen as per the problem's guarantee.\n    return -1;\n}\n\nCung cấp mô tả ngắn gọn bằng ngôn ngữ tự nhiên (docstring) cho mã PHP bằng tiếng Việt, sử dụng tối đa 500 ký tự."
    },
    "instruction_bertscore": {
      "es": "0.9687069752502395",
      "arb": "0.905616007322128",
      "sw": "0.91585798565943",
      "tr": "0.8654434100185839",
      "vi": "0.9202302376067699"
    },
    "level": "",
    "test": "function main(){\n    assert(findMinimumDivisor(300, 262, 205) === 19);\n    assert(findMinimumDivisor(100, 200, 300) === 2);\n    assert(findMinimumDivisor(15, 25, 35) === 2);\n    assert(findMinimumDivisor(7, 14, 21) === 7);\n    assert(findMinimumDivisor(9, 18, 27) === 3);\n    \n}\n\n\nmain();\n?>",
    "entry_point": "findMinimumDivisor",
    "signature": "function findMinimumDivisor($a, $b, $c)",
    "docstring": {
      "en": "Finds the smallest integer divisor greater than 1 that yields the same remainder when dividing three given numbers.\nThis problem involves finding the minimum value of x (where x > 1) such that when x divides each of the\nthree integers a, b, and c, the remainders are the same.\nInput: Three positive integers a, b, and c, each not exceeding 1,000,000.\nOutput: Returns the smallest integer value of x that satisfies the condition.\nExample: For a = 300, b = 262, c = 205, the function returns 19.",
      "es": "Encuentra el divisor entero más pequeño mayor que 1 que produce el mismo residuo al dividir tres números dados. Este problema implica encontrar el valor mínimo de x (donde x > 1) tal que cuando x divide cada uno de los tres enteros a, b y c, los residuos sean los mismos. \n\nEntrada: Tres enteros positivos a, b y c, cada uno no excede 1,000,000. \n\nSalida: Devuelve el valor entero más pequeño de x que satisface la condición. \n\nEjemplo: Para a = 300, b = 262, c = 205, la función devuelve 19.",
      "arb": "يعثر على أصغر مقسوم صحيح أكبر من 1 يعطي نفس الباقي عند قسمة ثلاثة أعداد معطاة.\nتتضمن هذه المشكلة إيجاد القيمة الدنيا لـ x (حيث x > 1) بحيث عندما يقسم x كل من الأعداد الصحيحة الثلاثة a و b و c، تكون البواقي متساوية.\nالمدخلات: ثلاثة أعداد صحيحة موجبة a و b و c، كل منها لا يتجاوز 1,000,000.\nالمخرجات: يعيد أصغر قيمة صحيحة لـ x تحقق الشرط.\nمثال: لـ a = 300، b = 262، c = 205، تعيد الدالة 19.",
      "sw": "Inapata mgawanyiko mdogo zaidi wa nambari nzima zaidi ya 1 ambao unatoa baki sawa wakati wa kugawa nambari tatu zilizotolewa. \nTatizo hili linahusisha kutafuta thamani ndogo ya x (ambapo x > 1) ili kwamba wakati x inapogawa kila moja ya nambari tatu a, b, na c, mabaki ni sawa.\n\nIngizo: Nambari tatu chanya za nambari nzima a, b, na c, kila moja haizidi 1,000,000.\n\nPato: Inarudisha thamani ndogo zaidi ya nambari nzima ya x inayokidhi sharti.\n\nMfano: Kwa a = 300, b = 262, c = 205, kazi inarudisha 19.",
      "tr": "Üç verilen sayıyı bölerken aynı kalanı veren 1'den büyük en küçük tam sayı bölenini bulur.\nBu problem, x > 1 olan en küçük x değerini bulmayı içerir, öyle ki x, a, b ve c üç tam sayısını böldüğünde kalanlar aynı olur.\nGirdi: Her biri 1.000.000'u aşmayan üç pozitif tam sayı a, b ve c.\nÇıktı: Koşulu sağlayan en küçük tam sayı x değerini döndürür.\nÖrnek: a = 300, b = 262, c = 205 için, fonksiyon 19 döndürür.",
      "vi": "Tìm ước số nguyên nhỏ nhất lớn hơn 1 mà cho cùng một số dư khi chia ba số đã cho.\nVấn đề này liên quan đến việc tìm giá trị nhỏ nhất của x (với x > 1) sao cho khi x chia mỗi\nba số nguyên a, b và c, các số dư là như nhau.\nĐầu vào: Ba số nguyên dương a, b và c, mỗi số không vượt quá 1.000.000.\nĐầu ra: Trả về giá trị nguyên nhỏ nhất của x thỏa mãn điều kiện.\nVí dụ: Với a = 300, b = 262, c = 205, hàm trả về 19."
    },
    "docstring_bertscore": {
      "es": "0.9917129418728434",
      "arb": "0.9925154086122244",
      "sw": "0.9776957945135925",
      "tr": "0.9745202906119876",
      "vi": "0.9786241929145495"
    }
  },
  {
    "task_id": "PHP/28",
    "prompt": {
      "en": "<?php\n\n\n/**\n * Calculates the minimum number of apples required to be distributed among children.\n * Each child should receive a different number of apples and every child must receive at least one apple.\n * The total count of children is a positive integer not greater than 1000.\n * Input: An integer representing the number of children.\n * Output: An integer representing the minimum number of apples required.\n */\n\n function minimumApplesForChildren(int $childrenCount): int ",
      "es": "<?php\n\n\n/**\n * Calcula el número mínimo de manzanas que se deben distribuir entre los niños.\n * Cada niño debe recibir un número diferente de manzanas y cada niño debe recibir al menos una manzana.\n * El número total de niños es un entero positivo no mayor que 1000.\n * Entrada: Un entero que representa el número de niños.\n * Salida: Un entero que representa el número mínimo de manzanas requeridas.\n */\n\n function minimumApplesForChildren(int $childrenCount): int ",
      "arb": "<?php\n\n\n/**\n * يحسب الحد الأدنى لعدد التفاح المطلوب توزيعه بين الأطفال.\n * يجب أن يتلقى كل طفل عددًا مختلفًا من التفاح ويجب أن يتلقى كل طفل تفاحة واحدة على الأقل.\n * العدد الإجمالي للأطفال هو عدد صحيح موجب لا يزيد عن 1000.\n * المدخل: عدد صحيح يمثل عدد الأطفال.\n * المخرج: عدد صحيح يمثل الحد الأدنى لعدد التفاح المطلوب.\n */\n\n function minimumApplesForChildren(int $childrenCount): int ",
      "sw": "<?php\n\n\n/**\n * Inahesabu idadi ndogo ya tufaha zinazohitajika kugawanywa kati ya watoto.\n * Kila mtoto anapaswa kupokea idadi tofauti ya tufaha na kila mtoto lazima apokee angalau tufaha moja.\n * Jumla ya idadi ya watoto ni nambari chanya isiyozidi 1000.\n * Ingizo: Nambari nzima inayowakilisha idadi ya watoto.\n * Tokeo: Nambari nzima inayowakilisha idadi ndogo ya tufaha zinazohitajika.\n */\n\n function minimumApplesForChildren(int $childrenCount): int ",
      "tr": "<?php\n\n\n/**\n * Çocuklar arasında dağıtılması gereken minimum elma sayısını hesaplar.\n * Her çocuk farklı sayıda elma almalı ve her çocuk en az bir elma almalıdır.\n * Çocukların toplam sayısı 1000'den büyük olmayan pozitif bir tam sayıdır.\n * Girdi: Çocuk sayısını temsil eden bir tam sayı.\n * Çıktı: Gerekli minimum elma sayısını temsil eden bir tam sayı.\n */\n\n function minimumApplesForChildren(int $childrenCount): int ",
      "vi": "<?php\n\n\n/**\n * Tính toán số lượng táo tối thiểu cần được phân phát cho trẻ em.\n * Mỗi trẻ em nên nhận một số lượng táo khác nhau và mỗi trẻ em phải nhận ít nhất một quả táo.\n * Tổng số trẻ em là một số nguyên dương không lớn hơn 1000.\n * Đầu vào: Một số nguyên đại diện cho số lượng trẻ em.\n * Đầu ra: Một số nguyên đại diện cho số lượng táo tối thiểu cần thiết.\n */\n\n function minimumApplesForChildren(int $childrenCount): int "
    },
    "prompt_bertscore": {
      "es": "0.9794389747375546",
      "arb": "0.9733219535232042",
      "sw": "0.9782259390005745",
      "tr": "0.9787038436973444",
      "vi": "0.977795705595253"
    },
    "canonical_solution": "{\n    // Sum of first n natural numbers\n    return ($childrenCount * ($childrenCount + 1)) / 2;\n}",
    "instruction": {
      "en": "function minimumApplesForChildren(int $childrenCount): int\n{\n    // Sum of first n natural numbers\n    return ($childrenCount * ($childrenCount + 1)) / 2;\n}\n\nProvide a concise natural language description (docstring) of the PHP code in English using at most 500 characters.",
      "es": "function minimumApplesForChildren(int $childrenCount): int\n{\n    // Sum of first n natural numbers\n    return ($childrenCount * ($childrenCount + 1)) / 2;\n}\n\nProporcione una descripción concisa en lenguaje natural (docstring) del código PHP en español usando como máximo 500 caracteres.",
      "arb": "function minimumApplesForChildren(int $childrenCount): int\n{\n    // Sum of first n natural numbers\n    return ($childrenCount * ($childrenCount + 1)) / 2;\n}\n\nيرجى تقديم وصف موجز بلغة طبيعية (docstring) لشيفرة PHP باللغة العربية الفصحى باستخدام 500 حرف كحد أقصى.",
      "sw": "function minimumApplesForChildren(int $childrenCount): int\n{\n    // Sum of first n natural numbers\n    return ($childrenCount * ($childrenCount + 1)) / 2;\n}\n\nToa maelezo mafupi ya lugha asilia (docstring) ya msimbo wa PHP kwa Kiswahili kwa kutumia herufi zisizozidi 500.",
      "tr": "function minimumApplesForChildren(int $childrenCount): int\n{\n    // Sum of first n natural numbers\n    return ($childrenCount * ($childrenCount + 1)) / 2;\n}\n\nPHP kodunun işlevini açıklayan kısa bir doğal dil açıklaması (docstring) sağlayın. Açıklama, en fazla 500 karakter kullanılarak Türkçe olarak yazılmalıdır.",
      "vi": "function minimumApplesForChildren(int $childrenCount): int\n{\n    // Sum of first n natural numbers\n    return ($childrenCount * ($childrenCount + 1)) / 2;\n}\n\nCung cấp mô tả ngắn gọn bằng ngôn ngữ tự nhiên (docstring) cho mã PHP bằng tiếng Việt, không quá 500 ký tự."
    },
    "instruction_bertscore": {
      "es": "0.9687069752502395",
      "arb": "0.9076410440567787",
      "sw": "0.9428367585331127",
      "tr": "0.881863190466833",
      "vi": "0.8979897924726745"
    },
    "level": "",
    "test": "function main(){\n    assert(minimumApplesForChildren(1) === 1);\n    assert(minimumApplesForChildren(2) === 3);\n    assert(minimumApplesForChildren(3) === 6);\n    assert(minimumApplesForChildren(8) === 36);\n    assert(minimumApplesForChildren(10) === 55);\n    \n}\n\n\nmain();\n?>",
    "entry_point": "minimumApplesForChildren",
    "signature": "function minimumApplesForChildren(int $childrenCount): int",
    "docstring": {
      "en": "Calculates the minimum number of apples required to be distributed among children.\nEach child should receive a different number of apples and every child must receive at least one apple.\nThe total count of children is a positive integer not greater than 1000.\nInput: An integer representing the number of children.\nOutput: An integer representing the minimum number of apples required.",
      "es": "Calcula el número mínimo de manzanas que se deben distribuir entre los niños.  \nCada niño debe recibir un número diferente de manzanas y cada niño debe recibir al menos una manzana.  \nEl número total de niños es un entero positivo no mayor que 1000.  \nEntrada: Un entero que representa el número de niños.  \nSalida: Un entero que representa el número mínimo de manzanas requerido.",
      "arb": "يحسب الحد الأدنى لعدد التفاح المطلوب توزيعه بين الأطفال.  \nيجب أن يحصل كل طفل على عدد مختلف من التفاح ويجب أن يحصل كل طفل على تفاحة واحدة على الأقل.  \nإجمالي عدد الأطفال هو عدد صحيح موجب لا يزيد عن 1000.  \nالمدخلات: عدد صحيح يمثل عدد الأطفال.  \nالمخرجات: عدد صحيح يمثل الحد الأدنى لعدد التفاح المطلوب.",
      "sw": "Hesabu idadi ndogo zaidi ya tufaha zinazohitajika kugawanywa kati ya watoto.  \nKila mtoto anapaswa kupokea idadi tofauti ya tufaha na kila mtoto lazima apokee angalau tufaha moja.  \nJumla ya idadi ya watoto ni nambari chanya isiyozidi 1000.  \nIngizo: Nambari nzima inayowakilisha idadi ya watoto.  \nPato: Nambari nzima inayowakilisha idadi ndogo zaidi ya tufaha zinazohitajika.",
      "tr": "Çocuklar arasında dağıtılması gereken minimum elma sayısını hesaplar.  \nHer çocuk farklı sayıda elma almalı ve her çocuk en az bir elma almalıdır.  \nToplam çocuk sayısı 1000'den büyük olmayan pozitif bir tam sayıdır.  \nGirdi: Çocuk sayısını temsil eden bir tam sayı.  \nÇıktı: Gerekli minimum elma sayısını temsil eden bir tam sayı.",
      "vi": "Tính toán số lượng táo tối thiểu cần được phân phát cho trẻ em.  \nMỗi trẻ em nên nhận một số lượng táo khác nhau và mỗi trẻ em phải nhận ít nhất một quả táo.  \nTổng số trẻ em là một số nguyên dương không lớn hơn 1000.  \nĐầu vào: Một số nguyên đại diện cho số lượng trẻ em.  \nĐầu ra: Một số nguyên đại diện cho số lượng táo tối thiểu cần thiết.  "
    },
    "docstring_bertscore": {
      "es": "0.9698004354978367",
      "arb": "0.9786210148284529",
      "sw": "0.9639265378698729",
      "tr": "0.9710909370834203",
      "vi": "0.9649028061926594"
    }
  },
  {
    "task_id": "PHP/29",
    "prompt": {
      "en": "<?php\n\n\n/**\n * Finds the nth digit after the decimal point in the decimal representation of the fraction a/b.\n * The function takes three integers as input: a (numerator), b (denominator), and n (position of the digit after the decimal point).\n * Conditions: 0 < a < b < 100, 1 <= n <= 10000.\n * The function calculates the decimal representation of a/b and returns the nth digit after the decimal point.\n * \n * Example:\n * Input: a = 1, b = 2, n = 1\n * Output: 5 (since 1/2 = 0.5)\n */\n\n function getDecimalDigit($a, $b, $n): int",
      "es": "<?php\n\n\n/**\n * Encuentra el enésimo dígito después del punto decimal en la representación decimal de la fracción a/b.\n * La función toma tres enteros como entrada: a (numerador), b (denominador), y n (posición del dígito después del punto decimal).\n * Condiciones: 0 < a < b < 100, 1 <= n <= 10000.\n * La función calcula la representación decimal de a/b y devuelve el enésimo dígito después del punto decimal.\n * \n * Ejemplo:\n * Entrada: a = 1, b = 2, n = 1\n * Salida: 5 (ya que 1/2 = 0.5)\n */\n\n function getDecimalDigit($a, $b, $n): int",
      "arb": "<?php\n\n\n/**\n * يجد الرقم العاشر بعد الفاصلة العشرية في التمثيل العشري للكسر a/b.\n * تأخذ الدالة ثلاثة أعداد صحيحة كمدخل: a (البسط)، b (المقام)، و n (موضع الرقم بعد الفاصلة العشرية).\n * الشروط: 0 < a < b < 100, 1 <= n <= 10000.\n * تقوم الدالة بحساب التمثيل العشري لـ a/b وتعيد الرقم العاشر بعد الفاصلة العشرية.\n * \n * مثال:\n * المدخلات: a = 1, b = 2, n = 1\n * الناتج: 5 (since 1/2 = 0.5)\n */\n\n function getDecimalDigit($a, $b, $n): int",
      "sw": "<?php\n\n\n/**\n * Inapata tarakimu ya n baada ya nukta katika uwakilishi wa desimali wa sehemu a/b.\n * Kazi inachukua namba tatu kama pembejeo: a (kizidishi), b (mgawanyiko), na n (nafasi ya tarakimu baada ya nukta).\n * Masharti: 0 < a < b < 100, 1 <= n <= 10000.\n * Kazi inahesabu uwakilishi wa desimali wa a/b na inarudisha tarakimu ya n baada ya nukta.\n * \n * Mfano:\n * Ingizo: a = 1, b = 2, n = 1\n * Matokeo: 5 (kwa kuwa 1/2 = 0.5)\n */\n\n function getDecimalDigit($a, $b, $n): int",
      "tr": "<?php\n\n\n/**\n * Kesir a/b'nin ondalık gösteriminde ondalık noktadan sonraki n. basamağı bulur.\n * Fonksiyon üç tamsayı alır: a (pay), b (payda) ve n (ondalık noktadan sonraki basamağın konumu).\n * Koşullar: 0 < a < b < 100, 1 <= n <= 10000.\n * Fonksiyon a/b'nin ondalık gösterimini hesaplar ve ondalık noktadan sonraki n. basamağı döndürür.\n * \n * Örnek:\n * Girdi: a = 1, b = 2, n = 1\n * Çıktı: 5 (çünkü 1/2 = 0.5)\n */\n\n function getDecimalDigit($a, $b, $n): int",
      "vi": "<?php\n\n\n/**\n * Tìm chữ số thứ n sau dấu thập phân trong biểu diễn thập phân của phân số a/b.\n * Hàm nhận ba số nguyên làm đầu vào: a (tử số), b (mẫu số), và n (vị trí của chữ số sau dấu thập phân).\n * Điều kiện: 0 < a < b < 100, 1 <= n <= 10000.\n * Hàm tính toán biểu diễn thập phân của a/b và trả về chữ số thứ n sau dấu thập phân.\n * \n * Ví dụ:\n * Đầu vào: a = 1, b = 2, n = 1\n * Đầu ra: 5 (vì 1/2 = 0.5)\n */\n\n function getDecimalDigit($a, $b, $n): int"
    },
    "prompt_bertscore": {
      "es": "1",
      "arb": "1",
      "sw": "0.9881139579988722",
      "tr": "0.9861991611256959",
      "vi": "0.991266222145896"
    },
    "canonical_solution": "  {\n    if ($a <= 0 || $a >= $b || $b >= 100 || $n < 1 || $n > 10000) {\n        // Handle invalid input\n        return -1;\n    }\n\n    $decimal = $a / $b;\n    $decimalString = (string)$decimal;\n    $decimalPointPosition = strpos($decimalString, '.');\n\n    if ($decimalPointPosition === false || $decimalPointPosition + $n >= strlen($decimalString)) {\n        // Decimal point not found or n is beyond the length of the decimal part\n        return -1;\n    }\n\n    return (int)$decimalString[$decimalPointPosition + $n];\n}",
    "instruction": {
      "en": "function getDecimalDigit($a, $b, $n): int\n  {\n    if ($a <= 0 || $a >= $b || $b >= 100 || $n < 1 || $n > 10000) {\n        // Handle invalid input\n        return -1;\n    }\n\n    $decimal = $a / $b;\n    $decimalString = (string)$decimal;\n    $decimalPointPosition = strpos($decimalString, '.');\n\n    if ($decimalPointPosition === false || $decimalPointPosition + $n >= strlen($decimalString)) {\n        // Decimal point not found or n is beyond the length of the decimal part\n        return -1;\n    }\n\n    return (int)$decimalString[$decimalPointPosition + $n];\n}\n\nProvide a concise natural language description (docstring) of the PHP code in English using at most 500 characters.",
      "es": "function getDecimalDigit($a, $b, $n): int\n  {\n    if ($a <= 0 || $a >= $b || $b >= 100 || $n < 1 || $n > 10000) {\n        // Handle invalid input\n        return -1;\n    }\n\n    $decimal = $a / $b;\n    $decimalString = (string)$decimal;\n    $decimalPointPosition = strpos($decimalString, '.');\n\n    if ($decimalPointPosition === false || $decimalPointPosition + $n >= strlen($decimalString)) {\n        // Decimal point not found or n is beyond the length of the decimal part\n        return -1;\n    }\n\n    return (int)$decimalString[$decimalPointPosition + $n];\n}\n\nProporcione una descripción concisa en lenguaje natural (docstring) del código PHP en español utilizando un máximo de 500 caracteres.",
      "arb": "function getDecimalDigit($a, $b, $n): int\n  {\n    if ($a <= 0 || $a >= $b || $b >= 100 || $n < 1 || $n > 10000) {\n        // Handle invalid input\n        return -1;\n    }\n\n    $decimal = $a / $b;\n    $decimalString = (string)$decimal;\n    $decimalPointPosition = strpos($decimalString, '.');\n\n    if ($decimalPointPosition === false || $decimalPointPosition + $n >= strlen($decimalString)) {\n        // Decimal point not found or n is beyond the length of the decimal part\n        return -1;\n    }\n\n    return (int)$decimalString[$decimalPointPosition + $n];\n}\n\nيرجى تقديم وصف موجز بلغة طبيعية (docstring) لكود PHP باللغة العربية الفصحى، بحيث لا يتجاوز 500 حرف.",
      "sw": "function getDecimalDigit($a, $b, $n): int\n  {\n    if ($a <= 0 || $a >= $b || $b >= 100 || $n < 1 || $n > 10000) {\n        // Handle invalid input\n        return -1;\n    }\n\n    $decimal = $a / $b;\n    $decimalString = (string)$decimal;\n    $decimalPointPosition = strpos($decimalString, '.');\n\n    if ($decimalPointPosition === false || $decimalPointPosition + $n >= strlen($decimalString)) {\n        // Decimal point not found or n is beyond the length of the decimal part\n        return -1;\n    }\n\n    return (int)$decimalString[$decimalPointPosition + $n];\n}\n\nToa maelezo mafupi ya lugha ya asili (docstring) ya msimbo wa PHP kwa Kiswahili kwa kutumia herufi zisizozidi 500.",
      "tr": "function getDecimalDigit($a, $b, $n): int\n  {\n    if ($a <= 0 || $a >= $b || $b >= 100 || $n < 1 || $n > 10000) {\n        // Handle invalid input\n        return -1;\n    }\n\n    $decimal = $a / $b;\n    $decimalString = (string)$decimal;\n    $decimalPointPosition = strpos($decimalString, '.');\n\n    if ($decimalPointPosition === false || $decimalPointPosition + $n >= strlen($decimalString)) {\n        // Decimal point not found or n is beyond the length of the decimal part\n        return -1;\n    }\n\n    return (int)$decimalString[$decimalPointPosition + $n];\n}\n\nPHP kodunun işlevini açıklayan kısa bir doğal dil açıklaması (docstring) sağlayın. Açıklama en fazla 500 karakter olmalıdır.",
      "vi": "function getDecimalDigit($a, $b, $n): int\n  {\n    if ($a <= 0 || $a >= $b || $b >= 100 || $n < 1 || $n > 10000) {\n        // Handle invalid input\n        return -1;\n    }\n\n    $decimal = $a / $b;\n    $decimalString = (string)$decimal;\n    $decimalPointPosition = strpos($decimalString, '.');\n\n    if ($decimalPointPosition === false || $decimalPointPosition + $n >= strlen($decimalString)) {\n        // Decimal point not found or n is beyond the length of the decimal part\n        return -1;\n    }\n\n    return (int)$decimalString[$decimalPointPosition + $n];\n}\n\nCung cấp mô tả ngắn gọn bằng ngôn ngữ tự nhiên (docstring) cho mã PHP bằng tiếng Việt với tối đa 500 ký tự."
    },
    "instruction_bertscore": {
      "es": "0.9687069752502395",
      "arb": "0.905616007322128",
      "sw": "0.91585798565943",
      "tr": "0.8406400370779954",
      "vi": "0.9150604846795749"
    },
    "level": "",
    "test": "function main(){\n    assert(getDecimalDigit(1, 2, 1) === 5);\n    assert(getDecimalDigit(1, 3, 1) === 3);\n    assert(getDecimalDigit(1, 4, 2) === 5);\n    assert(getDecimalDigit(3, 7, 3) === 8);\n    assert(getDecimalDigit(50, 99, 4) === 0);   \n}\n\n\nmain();\n?>",
    "entry_point": "getDecimalDigit",
    "signature": "function getDecimalDigit($a, $b, $n): int",
    "docstring": {
      "en": "Finds the nth digit after the decimal point in the decimal representation of the fraction a/b.\nThe function takes three integers as input: a (numerator), b (denominator), and n (position of the digit after the decimal point).\nConditions: 0 < a < b < 100, 1 <= n <= 10000.\nThe function calculates the decimal representation of a/b and returns the nth digit after the decimal point.\n\nExample:\nInput: a = 1, b = 2, n = 1\nOutput: 5 (since 1/2 = 0.5)",
      "es": "Encuentra el enésimo dígito después del punto decimal en la representación decimal de la fracción a/b.\nLa función toma tres enteros como entrada: a (numerador), b (denominador), y n (posición del dígito después del punto decimal).\nCondiciones: 0 < a < b < 100, 1 <= n <= 10000.\nLa función calcula la representación decimal de a/b y devuelve el enésimo dígito después del punto decimal.\n\nEjemplo:\nEntrada: a = 1, b = 2, n = 1\nSalida: 5 (ya que 1/2 = 0.5)",
      "arb": "يجد الرقم العاشر بعد الفاصلة العشرية في التمثيل العشري للكسر a/b.  \nتأخذ الدالة ثلاثة أعداد صحيحة كمدخلات: a (البسط)، b (المقام)، و n (موضع الرقم بعد الفاصلة العشرية).  \nالشروط: 0 < a < b < 100، 1 <= n <= 10000.  \nتحسب الدالة التمثيل العشري لـ a/b وتعيد الرقم العاشر بعد الفاصلة العشرية.  \n\nمثال:  \nالمدخل: a = 1, b = 2, n = 1  \nالمخرج: 5 (لأن 1/2 = 0.5)",
      "sw": "Inapata tarakimu ya nth baada ya nukta katika uwakilishi wa desimali wa sehemu a/b. \nKazi inachukua nambari tatu za mzima kama pembejeo: a (kizidishi), b (mgawanyiko), na n (nafasi ya tarakimu baada ya nukta ya desimali). \nMasharti: 0 < a < b < 100, 1 <= n <= 10000. \nKazi inahesabu uwakilishi wa desimali wa a/b na inarudisha tarakimu ya nth baada ya nukta ya desimali.\n\nMfano:\nPembejeo: a = 1, b = 2, n = 1\nMatokeo: 5 (kwa kuwa 1/2 = 0.5)",
      "tr": "Ondalık kesir a/b'nin ondalık gösteriminde, ondalık noktadan sonraki n. basamağı bulur.\nFonksiyon üç tam sayı alır: a (pay), b (payda) ve n (ondalık noktadan sonraki basamağın konumu).\nKoşullar: 0 < a < b < 100, 1 <= n <= 10000.\nFonksiyon, a/b'nin ondalık gösterimini hesaplar ve ondalık noktadan sonraki n. basamağı döndürür.\n\nÖrnek:\nGirdi: a = 1, b = 2, n = 1\nÇıktı: 5 (çünkü 1/2 = 0.5)",
      "vi": "Tìm chữ số thứ n sau dấu thập phân trong biểu diễn thập phân của phân số a/b.  \nHàm nhận ba số nguyên làm đầu vào: a (tử số), b (mẫu số), và n (vị trí của chữ số sau dấu thập phân).  \nĐiều kiện: 0 < a < b < 100, 1 <= n <= 10000.  \nHàm tính toán biểu diễn thập phân của a/b và trả về chữ số thứ n sau dấu thập phân.  \n\nVí dụ:  \nĐầu vào: a = 1, b = 2, n = 1  \nĐầu ra: 5 (vì 1/2 = 0.5)"
    },
    "docstring_bertscore": {
      "es": "0.9920821957511873",
      "arb": "0.9881300470597362",
      "sw": "0.9763590120492276",
      "tr": "0.9823089851131277",
      "vi": "0.9868552372742542"
    }
  },
  {
    "task_id": "PHP/30",
    "prompt": {
      "en": "<?php\n/**\n * Solves the Josephus Problem.\n * In this problem, N people are arranged in a circle and eliminated in every Mth position\n * until only one person remains. The function simulates this process and returns the order\n * in which people are eliminated.\n * \n * For example, with N = 8 and M = 5, the elimination order is 5, 2, 8, 7, 1, 4, 6, 3.\n * \n * Input: Two integers, N (number of people in the circle) and M (the elimination step).\n * Output: Returns an array representing the order in which people are eliminated.\n */\n\nfunction josephusProblem($n, $m) ",
      "es": "<?php\n/**\n * Resuelve el Problema de Josephus.\n * En este problema, N personas están dispuestas en un círculo y se eliminan en cada M-ésima posición\n * hasta que solo queda una persona. La función simula este proceso y devuelve el orden\n * en el que las personas son eliminadas.\n * \n * Por ejemplo, con N = 8 y M = 5, el orden de eliminación es 5, 2, 8, 7, 1, 4, 6, 3.\n * \n * Entrada: Dos enteros, N (número de personas en el círculo) y M (el paso de eliminación).\n * Salida: Devuelve un arreglo que representa el orden en el que las personas son eliminadas.\n */\n\nfunction josephusProblem($n, $m) ",
      "arb": "<?php\n/**\n * يحل مشكلة جوزيفوس.\n * في هذه المشكلة، يتم ترتيب N شخصًا في دائرة ويتم القضاء عليهم في كل موضع M حتى يبقى شخص واحد فقط.\n * تقوم الدالة بمحاكاة هذه العملية وتعيد الترتيب الذي يتم فيه القضاء على الأشخاص.\n * \n * على سبيل المثال، مع N = 8 و M = 5، يكون ترتيب الإقصاء هو 5، 2، 8، 7، 1، 4، 6، 3.\n * \n * المدخلات: عددان صحيحان، N (عدد الأشخاص في الدائرة) و M (خطوة الإقصاء).\n * المخرجات: تعيد مصفوفة تمثل الترتيب الذي يتم فيه القضاء على الأشخاص.\n */\n\nfunction josephusProblem($n, $m) ",
      "sw": "<?php\n/**\n * Hutatua Shida ya Josephus.\n * Katika tatizo hili, watu N wamepangwa kwenye mduara na kuondolewa katika kila nafasi ya M\n * hadi mtu mmoja tu abaki. Kazi hii inaiga mchakato huu na kurudisha mpangilio\n * ambao watu wanaondolewa.\n * \n * Kwa mfano, ukiwa na N = 8 na M = 5, mpangilio wa kuondolewa ni 5, 2, 8, 7, 1, 4, 6, 3.\n * \n * Ingizo: Nambari mbili, N (idadi ya watu kwenye mduara) na M (hatua ya kuondolewa).\n * Tokeo: Inarudisha safu inayowakilisha mpangilio ambao watu wanaondolewa.\n */\n\nfunction josephusProblem($n, $m) ",
      "tr": "<?php\n/**\n * Josephus Problemini çözer.\n * Bu problemde, N kişi bir çemberde dizilir ve her M. pozisyonda bir kişi\n * elenerek sadece bir kişi kalana kadar devam edilir. Fonksiyon bu süreci simüle eder ve\n * insanların elendiği sırayı döndürür.\n * \n * Örneğin, N = 8 ve M = 5 olduğunda, eleme sırası 5, 2, 8, 7, 1, 4, 6, 3 şeklindedir.\n * \n * Girdi: İki tamsayı, N (çemberdeki kişi sayısı) ve M (eleme adımı).\n * Çıktı: İnsanların elendiği sırayı temsil eden bir dizi döndürür.\n */\n\nfunction josephusProblem($n, $m) ",
      "vi": "<?php\n/**\n * Giải quyết Vấn đề Josephus.\n * Trong vấn đề này, N người được sắp xếp thành một vòng tròn và bị loại bỏ ở mỗi vị trí thứ M\n * cho đến khi chỉ còn lại một người. Hàm này mô phỏng quá trình này và trả về thứ tự\n * mà mọi người bị loại bỏ.\n * \n * Ví dụ, với N = 8 và M = 5, thứ tự loại bỏ là 5, 2, 8, 7, 1, 4, 6, 3.\n * \n * Đầu vào: Hai số nguyên, N (số người trong vòng tròn) và M (bước loại bỏ).\n * Đầu ra: Trả về một mảng đại diện cho thứ tự mà mọi người bị loại bỏ.\n */\n\nfunction josephusProblem($n, $m) "
    },
    "prompt_bertscore": {
      "es": "0.9872842788972895",
      "arb": "0.9791428168394316",
      "sw": "0.9801304070939371",
      "tr": "0.9696552366893001",
      "vi": "0.9791179880418022"
    },
    "canonical_solution": "{\n    $people = range(1, $n);\n    $result = [];\n    $i = 0;\n\n    while (count($people) > 0) {\n        $i = ($i + $m - 1) % count($people);\n        $result[] = $people[$i];\n        array_splice($people, $i, 1);\n    }\n\n    return $result;\n}",
    "instruction": {
      "en": "function josephusProblem($n, $m)\n{\n    $people = range(1, $n);\n    $result = [];\n    $i = 0;\n\n    while (count($people) > 0) {\n        $i = ($i + $m - 1) % count($people);\n        $result[] = $people[$i];\n        array_splice($people, $i, 1);\n    }\n\n    return $result;\n}\n\nProvide a concise natural language description (docstring) of the PHP code in English using at most 500 characters.",
      "es": "function josephusProblem($n, $m)\n{\n    $people = range(1, $n);\n    $result = [];\n    $i = 0;\n\n    while (count($people) > 0) {\n        $i = ($i + $m - 1) % count($people);\n        $result[] = $people[$i];\n        array_splice($people, $i, 1);\n    }\n\n    return $result;\n}\n\nProporcione una descripción concisa en lenguaje natural (docstring) del código PHP en español utilizando un máximo de 500 caracteres.",
      "arb": "function josephusProblem($n, $m)\n{\n    $people = range(1, $n);\n    $result = [];\n    $i = 0;\n\n    while (count($people) > 0) {\n        $i = ($i + $m - 1) % count($people);\n        $result[] = $people[$i];\n        array_splice($people, $i, 1);\n    }\n\n    return $result;\n}\n\nيرجى تقديم وصف موجز بلغة طبيعية (docstring) لشيفرة PHP باللغة العربية الفصحى باستخدام ما لا يزيد عن 500 حرف.",
      "sw": "function josephusProblem($n, $m)\n{\n    $people = range(1, $n);\n    $result = [];\n    $i = 0;\n\n    while (count($people) > 0) {\n        $i = ($i + $m - 1) % count($people);\n        $result[] = $people[$i];\n        array_splice($people, $i, 1);\n    }\n\n    return $result;\n}\n\nToa maelezo mafupi ya lugha asilia (docstring) ya msimbo wa PHP kwa Kiswahili kwa kutumia herufi zisizozidi 500.",
      "tr": "function josephusProblem($n, $m)\n{\n    $people = range(1, $n);\n    $result = [];\n    $i = 0;\n\n    while (count($people) > 0) {\n        $i = ($i + $m - 1) % count($people);\n        $result[] = $people[$i];\n        array_splice($people, $i, 1);\n    }\n\n    return $result;\n}\n\nPHP kodunun işlevini açıklayan kısa bir doğal dil açıklaması (docstring) sağlayın. Açıklama, en fazla 500 karakter kullanılarak Türkçe olarak yazılmalıdır.",
      "vi": "function josephusProblem($n, $m)\n{\n    $people = range(1, $n);\n    $result = [];\n    $i = 0;\n\n    while (count($people) > 0) {\n        $i = ($i + $m - 1) % count($people);\n        $result[] = $people[$i];\n        array_splice($people, $i, 1);\n    }\n\n    return $result;\n}\n\nCung cấp mô tả ngắn gọn bằng ngôn ngữ tự nhiên (docstring) cho mã PHP bằng tiếng Việt với tối đa 500 ký tự."
    },
    "instruction_bertscore": {
      "es": "0.9687069752502395",
      "arb": "0.9057036033201644",
      "sw": "0.9428367585331127",
      "tr": "0.8849808929275567",
      "vi": "0.9017250367880356"
    },
    "level": "",
    "test": "function main(){\n    assert(josephusProblem(8, 5) === [5, 2, 8, 7, 1, 4, 6, 3]);\n    assert(josephusProblem(4, 2) === [2, 4, 3, 1]);\n    assert(josephusProblem(6, 3) === [3, 6, 4, 2, 5, 1]);    \n}\n\n\nmain();\n?>",
    "entry_point": "josephusProblem",
    "signature": "function josephusProblem($n, $m)",
    "docstring": {
      "en": "Solves the Josephus Problem.\nIn this problem, N people are arranged in a circle and eliminated in every Mth position\nuntil only one person remains. The function simulates this process and returns the order\nin which people are eliminated.\n\nFor example, with N = 8 and M = 5, the elimination order is 5, 2, 8, 7, 1, 4, 6, 3.\n\nInput: Two integers, N (number of people in the circle) and M (the elimination step).\nOutput: Returns an array representing the order in which people are eliminated.",
      "es": "Resuelve el Problema de Josephus.  \nEn este problema, N personas están dispuestas en un círculo y se eliminan en cada M-ésima posición  \nhasta que solo queda una persona. La función simula este proceso y devuelve el orden  \nen el que las personas son eliminadas.\n\nPor ejemplo, con N = 8 y M = 5, el orden de eliminación es 5, 2, 8, 7, 1, 4, 6, 3.\n\nEntrada: Dos enteros, N (número de personas en el círculo) y M (el paso de eliminación).  \nSalida: Devuelve un arreglo que representa el orden en el que las personas son eliminadas.",
      "arb": "يحل مشكلة جوزيفوس.  \nفي هذه المشكلة، يتم ترتيب N شخصًا في دائرة ويتم التخلص منهم في كل موضع M حتى يبقى شخص واحد فقط. تحاكي الدالة هذه العملية وتعيد الترتيب الذي يتم فيه التخلص من الأشخاص.\n\nعلى سبيل المثال، مع N = 8 و M = 5، يكون ترتيب الإقصاء هو 5، 2، 8، 7، 1، 4، 6، 3.\n\nالمدخلات: عددان صحيحان، N (عدد الأشخاص في الدائرة) و M (خطوة الإقصاء).  \nالمخرجات: تعيد مصفوفة تمثل الترتيب الذي يتم فيه التخلص من الأشخاص.",
      "sw": "```\nInatatua Tatizo la Josephus.\nKatika tatizo hili, watu N wamepangwa katika mduara na kuondolewa katika kila nafasi ya M\nmpaka mtu mmoja tu abaki. Kazi hii inasimulate mchakato huu na kurudisha mpangilio\nambapo watu wanaondolewa.\n\nKwa mfano, ukiwa na N = 8 na M = 5, mpangilio wa kuondolewa ni 5, 2, 8, 7, 1, 4, 6, 3.\n\nIngizo: Nambari mbili za mzima, N (idadi ya watu katika mduara) na M (hatua ya kuondolewa).\nPato: Inarudisha safu inayowakilisha mpangilio ambao watu wanaondolewa.\n```",
      "tr": "Josephus Problemini çözer.  \nBu problemde, N kişi bir çember içinde dizilir ve her M. pozisyonda bir kişi elenir  \nve sadece bir kişi kalana kadar devam edilir. Fonksiyon bu süreci simüle eder ve  \nkişilerin elenme sırasını döndürür.\n\nÖrneğin, N = 8 ve M = 5 olduğunda, elenme sırası 5, 2, 8, 7, 1, 4, 6, 3 olur.\n\nGirdi: İki tamsayı, N (çemberdeki kişi sayısı) ve M (elenme adımı).  \nÇıktı: Kişilerin elenme sırasını temsil eden bir dizi döndürür.",
      "vi": "Giải quyết Vấn đề Josephus.  \nTrong vấn đề này, N người được sắp xếp thành một vòng tròn và bị loại bỏ ở mỗi vị trí thứ M cho đến khi chỉ còn lại một người. Hàm này mô phỏng quá trình này và trả về thứ tự mà mọi người bị loại bỏ.\n\nVí dụ, với N = 8 và M = 5, thứ tự loại bỏ là 5, 2, 8, 7, 1, 4, 6, 3.\n\nĐầu vào: Hai số nguyên, N (số người trong vòng tròn) và M (bước loại bỏ).  \nĐầu ra: Trả về một mảng đại diện cho thứ tự mà mọi người bị loại bỏ."
    },
    "docstring_bertscore": {
      "es": "0.9853265778618097",
      "arb": "0.9829960476011274",
      "sw": "0.9499906303364651",
      "tr": "0.946164214676209",
      "vi": "0.9827704034882717"
    }
  },
  {
    "task_id": "PHP/31",
    "prompt": {
      "en": "<?php\n\n\n/**\n * Finds the positions of the k-th largest number in an array.\n * This function takes an array of integers and an integer k, \n * and returns the positions of the k-th largest number in the array. \n * If there are duplicates of the k-th largest number, it returns all positions.\n * If k is greater than the array's length or the array is empty, it returns an empty array.\n *\n * Example:\n * Input: numbers = [67, 43, 90, 78, 32], k = 1\n * Output: [3]\n * \n * Input: numbers = [1, 2, 3, 4, 5], k = 3\n * Output: [3]\n */\n function findKthLargestPositions(array $numbers, int $k): array ",
      "es": "<?php\n\n\n/**\n * Encuentra las posiciones del k-ésimo número más grande en un arreglo.\n * Esta función toma un arreglo de enteros y un entero k,\n * y devuelve las posiciones del k-ésimo número más grande en el arreglo.\n * Si hay duplicados del k-ésimo número más grande, devuelve todas las posiciones.\n * Si k es mayor que la longitud del arreglo o el arreglo está vacío, devuelve un arreglo vacío.\n *\n * Ejemplo:\n * Entrada: numbers = [67, 43, 90, 78, 32], k = 1\n * Salida: [3]\n * \n * Entrada: numbers = [1, 2, 3, 4, 5], k = 3\n * Salida: [3]\n */\n function findKthLargestPositions(array $numbers, int $k): array ",
      "arb": "<?php\n\n\n/**\n * يجد مواقع الرقم الأكبر k في مصفوفة.\n * تأخذ هذه الدالة مصفوفة من الأعداد الصحيحة وعدد صحيح k، \n * وتعيد مواقع الرقم الأكبر k في المصفوفة. \n * إذا كانت هناك تكرارات للرقم الأكبر k، فإنها تعيد جميع المواقع.\n * إذا كان k أكبر من طول المصفوفة أو كانت المصفوفة فارغة، فإنها تعيد مصفوفة فارغة.\n *\n * مثال:\n * المدخلات: numbers = [67, 43, 90, 78, 32], k = 1\n * المخرجات: [3]\n * \n * المدخلات: numbers = [1, 2, 3, 4, 5], k = 3\n * المخرجات: [3]\n */\n function findKthLargestPositions(array $numbers, int $k): array ",
      "sw": "<?php\n\n\n/**\n * Inapata nafasi za nambari ya k-th kubwa zaidi katika safu.\n * Kazi hii inachukua safu ya nambari za mzima na nambari k, \n * na inarudisha nafasi za nambari ya k-th kubwa zaidi katika safu. \n * Ikiwa kuna marudio ya nambari ya k-th kubwa zaidi, inarudisha nafasi zote.\n * Ikiwa k ni kubwa kuliko urefu wa safu au safu ni tupu, inarudisha safu tupu.\n *\n * Mfano:\n * Ingizo: numbers = [67, 43, 90, 78, 32], k = 1\n * Matokeo: [3]\n * \n * Ingizo: numbers = [1, 2, 3, 4, 5], k = 3\n * Matokeo: [3]\n */\n function findKthLargestPositions(array $numbers, int $k): array ",
      "tr": "<?php\n\n\n/**\n * Bir dizideki k. en büyük sayının konumlarını bulur.\n * Bu fonksiyon bir tamsayı dizisi ve bir tamsayı k alır,\n * ve dizideki k. en büyük sayının konumlarını döndürür.\n * Eğer k. en büyük sayının kopyaları varsa, tüm konumları döndürür.\n * Eğer k dizinin uzunluğundan büyükse veya dizi boşsa, boş bir dizi döndürür.\n *\n * Örnek:\n * Girdi: numbers = [67, 43, 90, 78, 32], k = 1\n * Çıktı: [3]\n * \n * Girdi: numbers = [1, 2, 3, 4, 5], k = 3\n * Çıktı: [3]\n */\n function findKthLargestPositions(array $numbers, int $k): array ",
      "vi": "<?php\n\n\n/**\n * Tìm vị trí của số lớn thứ k trong một mảng.\n * Hàm này nhận một mảng số nguyên và một số nguyên k,\n * và trả về các vị trí của số lớn thứ k trong mảng.\n * Nếu có các số trùng lặp của số lớn thứ k, nó trả về tất cả các vị trí.\n * Nếu k lớn hơn độ dài của mảng hoặc mảng trống, nó trả về một mảng trống.\n *\n * Ví dụ:\n * Đầu vào: numbers = [67, 43, 90, 78, 32], k = 1\n * Đầu ra: [3]\n * \n * Đầu vào: numbers = [1, 2, 3, 4, 5], k = 3\n * Đầu ra: [3]\n */\n function findKthLargestPositions(array $numbers, int $k): array "
    },
    "prompt_bertscore": {
      "es": "0.9955751110016858",
      "arb": "0.9629460983090847",
      "sw": "0.9901362139081885",
      "tr": "0.9927497924618456",
      "vi": "0.9938672869855478"
    },
    "canonical_solution": " {\n    $length = count($numbers);\n    if ($length === 0 || $k > $length) {\n        return [];\n    }\n\n    $indexedNumbers = array_combine(range(1, $length), $numbers);\n    arsort($indexedNumbers);\n    $sortedNumbers = array_values($indexedNumbers);\n    $kthLargest = $sortedNumbers[$k - 1];\n\n    return array_keys($indexedNumbers, $kthLargest);\n}",
    "instruction": {
      "en": "function findKthLargestPositions(array $numbers, int $k): array\n {\n    $length = count($numbers);\n    if ($length === 0 || $k > $length) {\n        return [];\n    }\n\n    $indexedNumbers = array_combine(range(1, $length), $numbers);\n    arsort($indexedNumbers);\n    $sortedNumbers = array_values($indexedNumbers);\n    $kthLargest = $sortedNumbers[$k - 1];\n\n    return array_keys($indexedNumbers, $kthLargest);\n}\n\nProvide a concise natural language description (docstring) of the PHP code in English using at most 500 characters.",
      "es": "function findKthLargestPositions(array $numbers, int $k): array\n {\n    $length = count($numbers);\n    if ($length === 0 || $k > $length) {\n        return [];\n    }\n\n    $indexedNumbers = array_combine(range(1, $length), $numbers);\n    arsort($indexedNumbers);\n    $sortedNumbers = array_values($indexedNumbers);\n    $kthLargest = $sortedNumbers[$k - 1];\n\n    return array_keys($indexedNumbers, $kthLargest);\n}\n\nProporcione una descripción concisa en lenguaje natural (docstring) del código PHP en español usando un máximo de 500 caracteres.",
      "arb": "function findKthLargestPositions(array $numbers, int $k): array\n {\n    $length = count($numbers);\n    if ($length === 0 || $k > $length) {\n        return [];\n    }\n\n    $indexedNumbers = array_combine(range(1, $length), $numbers);\n    arsort($indexedNumbers);\n    $sortedNumbers = array_values($indexedNumbers);\n    $kthLargest = $sortedNumbers[$k - 1];\n\n    return array_keys($indexedNumbers, $kthLargest);\n}\n\nيرجى تقديم وصف موجز بلغة طبيعية (docstring) لشيفرة PHP باللغة العربية الفصحى باستخدام 500 حرف كحد أقصى.",
      "sw": "function findKthLargestPositions(array $numbers, int $k): array\n {\n    $length = count($numbers);\n    if ($length === 0 || $k > $length) {\n        return [];\n    }\n\n    $indexedNumbers = array_combine(range(1, $length), $numbers);\n    arsort($indexedNumbers);\n    $sortedNumbers = array_values($indexedNumbers);\n    $kthLargest = $sortedNumbers[$k - 1];\n\n    return array_keys($indexedNumbers, $kthLargest);\n}\n\nToa maelezo mafupi ya lugha asilia (docstring) ya msimbo wa PHP kwa Kiswahili kwa kutumia herufi zisizozidi 500.",
      "tr": "function findKthLargestPositions(array $numbers, int $k): array\n {\n    $length = count($numbers);\n    if ($length === 0 || $k > $length) {\n        return [];\n    }\n\n    $indexedNumbers = array_combine(range(1, $length), $numbers);\n    arsort($indexedNumbers);\n    $sortedNumbers = array_values($indexedNumbers);\n    $kthLargest = $sortedNumbers[$k - 1];\n\n    return array_keys($indexedNumbers, $kthLargest);\n}\n\nPHP kodunun işlevini açıklayan kısa bir doğal dil açıklaması (docstring) sağlayın. Açıklama Türkçe olmalı ve en fazla 500 karakter içermelidir.",
      "vi": "function findKthLargestPositions(array $numbers, int $k): array\n {\n    $length = count($numbers);\n    if ($length === 0 || $k > $length) {\n        return [];\n    }\n\n    $indexedNumbers = array_combine(range(1, $length), $numbers);\n    arsort($indexedNumbers);\n    $sortedNumbers = array_values($indexedNumbers);\n    $kthLargest = $sortedNumbers[$k - 1];\n\n    return array_keys($indexedNumbers, $kthLargest);\n}\n\nCung cấp mô tả ngắn gọn bằng ngôn ngữ tự nhiên (docstring) cho mã PHP bằng tiếng Việt, sử dụng tối đa 500 ký tự."
    },
    "instruction_bertscore": {
      "es": "0.9687069752502395",
      "arb": "0.9008484809165287",
      "sw": "0.9428367585331127",
      "tr": "0.8609130482879402",
      "vi": "0.9202302376067699"
    },
    "level": "",
    "test": "function main(){\n    // Test case 1: k-th largest is unique\n    assert(findKthLargestPositions([67, 43, 90, 78, 32], 1) === [3]);\n\n    // Test case 2: k-th largest has duplicates\n    assert(findKthLargestPositions([20, 50, 20, 40], 3) === [1, 3]);\n\n    // Test case 3: k is larger than the array length\n    assert(findKthLargestPositions([10, 20, 30], 4) === []);\n\n    // Test case 4: Array is empty\n    assert(findKthLargestPositions([], 1) === []);\n\n    // Test case 5: k-th largest in the middle\n    assert(findKthLargestPositions([1, 2, 3, 4, 5], 3) === [3]);\n}\n\n\nmain();\n?>",
    "entry_point": "findKthLargestPositions",
    "signature": "function findKthLargestPositions(array $numbers, int $k): array",
    "docstring": {
      "en": "Finds the positions of the k-th largest number in an array.\nThis function takes an array of integers and an integer k,\nand returns the positions of the k-th largest number in the array.\nIf there are duplicates of the k-th largest number, it returns all positions.\nIf k is greater than the array's length or the array is empty, it returns an empty array.\n\nExample:\nInput: numbers = [67, 43, 90, 78, 32], k = 1\nOutput: [3]\n\nInput: numbers = [1, 2, 3, 4, 5], k = 3\nOutput: [3]",
      "es": "Encuentra las posiciones del k-ésimo número más grande en un array.  \nEsta función toma un array de enteros y un entero k,  \ny devuelve las posiciones del k-ésimo número más grande en el array.  \nSi hay duplicados del k-ésimo número más grande, devuelve todas las posiciones.  \nSi k es mayor que la longitud del array o el array está vacío, devuelve un array vacío.  \n\nEjemplo:  \nEntrada: numbers = [67, 43, 90, 78, 32], k = 1  \nSalida: [3]  \n\nEntrada: numbers = [1, 2, 3, 4, 5], k = 3  \nSalida: [3]",
      "arb": "يعثر على مواقع العدد الأكبر في ترتيب k في مصفوفة.\nتأخذ هذه الدالة مصفوفة من الأعداد الصحيحة وعدد صحيح k،\nوتعيد مواقع العدد الأكبر في ترتيب k في المصفوفة.\nإذا كانت هناك تكرارات للعدد الأكبر في ترتيب k، فإنها تعيد جميع المواقع.\nإذا كان k أكبر من طول المصفوفة أو كانت المصفوفة فارغة، فإنها تعيد مصفوفة فارغة.\n\nمثال:\nالمدخل: numbers = [67, 43, 90, 78, 32], k = 1\nالمخرج: [3]\n\nالمدخل: numbers = [1, 2, 3, 4, 5], k = 3\nالمخرج: [3]",
      "sw": "Inapata nafasi za nambari ya k-th kubwa zaidi katika safu.\nKazi hii inachukua safu ya nambari za mzima na nambari k,\nna inarudisha nafasi za nambari ya k-th kubwa zaidi katika safu.\nIkiwa kuna nakala za nambari ya k-th kubwa zaidi, inarudisha nafasi zote.\nIkiwa k ni kubwa kuliko urefu wa safu au safu ni tupu, inarudisha safu tupu.\n\nMfano:\nIngizo: numbers = [67, 43, 90, 78, 32], k = 1\nMatokeo: [3]\n\nIngizo: numbers = [1, 2, 3, 4, 5], k = 3\nMatokeo: [3]",
      "tr": "k. en büyük sayının bir dizideki konumlarını bulur.\nBu fonksiyon bir tamsayı dizisi ve bir tamsayı k alır ve dizideki k. en büyük sayının konumlarını döndürür.\nEğer k. en büyük sayının tekrarları varsa, tüm konumları döndürür.\nEğer k dizinin uzunluğundan büyükse veya dizi boşsa, boş bir dizi döndürür.\n\nÖrnek:\nGirdi: numbers = [67, 43, 90, 78, 32], k = 1\nÇıktı: [3]\n\nGirdi: numbers = [1, 2, 3, 4, 5], k = 3\nÇıktı: [3]",
      "vi": "Tìm vị trí của số lớn thứ k trong một mảng.  \nHàm này nhận một mảng số nguyên và một số nguyên k,  \nvà trả về các vị trí của số lớn thứ k trong mảng.  \nNếu có các bản sao của số lớn thứ k, nó trả về tất cả các vị trí.  \nNếu k lớn hơn độ dài của mảng hoặc mảng trống, nó trả về một mảng trống.  \n\nVí dụ:  \nĐầu vào: numbers = [67, 43, 90, 78, 32], k = 1  \nĐầu ra: [3]  \n\nĐầu vào: numbers = [1, 2, 3, 4, 5], k = 3  \nĐầu ra: [3]"
    },
    "docstring_bertscore": {
      "es": "0.9919177297956904",
      "arb": "0.9619370559734275",
      "sw": "0.991164324760425",
      "tr": "0.9350440914243519",
      "vi": "0.9903630498033303"
    }
  },
  {
    "task_id": "PHP/32",
    "prompt": {
      "en": "<?php\n\n/**\n    * Calculates the k-th term of the Pell sequence modulo 32767.\n    * The Pell sequence is defined as follows:\n    *   a[1] = 1, a[2] = 2, and a[n] = 2*a[n-1] + a[n-2] for n > 2.\n    * This function computes the k-th term of this sequence modulo 32767.\n    * Input: An integer $k (1 ≤ $k < 1000000), representing the position in the sequence.\n    * Output: Returns the k-th term of the Pell sequence modulo 32767 as an integer.\n    * Example:\n    *   For $k = 1, the function returns 1.\n    *   For $k = 8, the function returns 408.\n    */\n\n    function getPellNumberModulo($k)",
      "es": "<?php\n\n/**\n    * Calcula el término k-ésimo de la secuencia de Pell módulo 32767.\n    * La secuencia de Pell se define de la siguiente manera:\n    *   a[1] = 1, a[2] = 2, y a[n] = 2*a[n-1] + a[n-2] para n > 2.\n    * Esta función calcula el término k-ésimo de esta secuencia módulo 32767.\n    * Entrada: Un entero $k (1 ≤ $k < 1000000), que representa la posición en la secuencia.\n    * Salida: Devuelve el término k-ésimo de la secuencia de Pell módulo 32767 como un entero.\n    * Ejemplo:\n    *   Para $k = 1, la función devuelve 1.\n    *   Para $k = 8, la función devuelve 408.\n    */\n\n    function getPellNumberModulo($k)",
      "arb": "<?php\n\n/**\n    * يحسب الحد k من متتالية بيل بتردد 32767.\n    * تُعرّف متتالية بيل كما يلي:\n    *   a[1] = 1, a[2] = 2, و a[n] = 2*a[n-1] + a[n-2] عندما n > 2.\n    * تقوم هذه الدالة بحساب الحد k من هذه المتتالية بتردد 32767.\n    * المدخل: عدد صحيح $k (1 ≤ $k < 1000000)، يمثل الموضع في المتتالية.\n    * المخرج: تعيد الحد k من متتالية بيل بتردد 32767 كعدد صحيح.\n    * مثال:\n    *   بالنسبة لـ $k = 1، تعيد الدالة 1.\n    *   بالنسبة لـ $k = 8، تعيد الدالة 408.\n    */\n\n    function getPellNumberModulo($k)",
      "sw": "<?php\n\n/**\n    * Inahesabu neno la k katika mlolongo wa Pell modulo 32767.\n    * Mlolongo wa Pell umefafanuliwa kama ifuatavyo:\n    *   a[1] = 1, a[2] = 2, na a[n] = 2*a[n-1] + a[n-2] kwa n > 2.\n    * Kazi hii inahesabu neno la k katika mlolongo huu modulo 32767.\n    * Ingizo: Nambari kamili $k (1 ≤ $k < 1000000), inayowakilisha nafasi katika mlolongo.\n    * Tokeo: Inarudisha neno la k katika mlolongo wa Pell modulo 32767 kama nambari kamili.\n    * Mfano:\n    *   Kwa $k = 1, kazi inarudisha 1.\n    *   Kwa $k = 8, kazi inarudisha 408.\n    */\n\n    function getPellNumberModulo($k)",
      "tr": "<?php\n\n/**\n    * Pell dizisinin k-terimini 32767 modunda hesaplar.\n    * Pell dizisi şu şekilde tanımlanır:\n    *   a[1] = 1, a[2] = 2 ve a[n] = 2*a[n-1] + a[n-2] for n > 2.\n    * Bu fonksiyon, bu dizinin k-terimini 32767 modunda hesaplar.\n    * Girdi: Dizideki konumu temsil eden bir tamsayı $k (1 ≤ $k < 1000000).\n    * Çıktı: Pell dizisinin k-terimini 32767 modunda bir tamsayı olarak döndürür.\n    * Örnek:\n    *   $k = 1 için, fonksiyon 1 döndürür.\n    *   $k = 8 için, fonksiyon 408 döndürür.\n    */\n\n    function getPellNumberModulo($k)",
      "vi": "<?php\n\n/**\n    * Tính toán số hạng thứ k của dãy Pell theo modulo 32767.\n    * Dãy Pell được định nghĩa như sau:\n    *   a[1] = 1, a[2] = 2, và a[n] = 2*a[n-1] + a[n-2] cho n > 2.\n    * Hàm này tính toán số hạng thứ k của dãy này theo modulo 32767.\n    * Đầu vào: Một số nguyên $k (1 ≤ $k < 1000000), đại diện cho vị trí trong dãy.\n    * Đầu ra: Trả về số hạng thứ k của dãy Pell theo modulo 32767 dưới dạng một số nguyên.\n    * Ví dụ:\n    *   Với $k = 1, hàm trả về 1.\n    *   Với $k = 8, hàm trả về 408.\n    */\n\n    function getPellNumberModulo($k)"
    },
    "prompt_bertscore": {
      "es": "0.9958676935529502",
      "arb": "0.9602286360661464",
      "sw": "0.9914932566714189",
      "tr": "0.9841900148215281",
      "vi": "0.9932398136118586"
    },
    "canonical_solution": "{\n        if ($k === 1) return 1;\n        if ($k === 2) return 2;\n    \n        $a = 1; // a[1]\n        $b = 2; // a[2]\n    \n        for ($i = 3; $i <= $k; $i++) {\n            $temp = (2 * $b + $a) % 32767;\n            $a = $b;\n            $b = $temp;\n        }\n    \n        return $b;\n    }",
    "instruction": {
      "en": "function getPellNumberModulo($k)\n{\n        if ($k === 1) return 1;\n        if ($k === 2) return 2;\n    \n        $a = 1; // a[1]\n        $b = 2; // a[2]\n    \n        for ($i = 3; $i <= $k; $i++) {\n            $temp = (2 * $b + $a) % 32767;\n            $a = $b;\n            $b = $temp;\n        }\n    \n        return $b;\n    }\n\nProvide a concise natural language description (docstring) of the PHP code in English using at most 500 characters.",
      "es": "function getPellNumberModulo($k)\n{\n        if ($k === 1) return 1;\n        if ($k === 2) return 2;\n    \n        $a = 1; // a[1]\n        $b = 2; // a[2]\n    \n        for ($i = 3; $i <= $k; $i++) {\n            $temp = (2 * $b + $a) % 32767;\n            $a = $b;\n            $b = $temp;\n        }\n    \n        return $b;\n    }\n\nProporcione una descripción concisa en lenguaje natural (docstring) del código PHP en español utilizando un máximo de 500 caracteres.",
      "arb": "function getPellNumberModulo($k)\n{\n        if ($k === 1) return 1;\n        if ($k === 2) return 2;\n    \n        $a = 1; // a[1]\n        $b = 2; // a[2]\n    \n        for ($i = 3; $i <= $k; $i++) {\n            $temp = (2 * $b + $a) % 32767;\n            $a = $b;\n            $b = $temp;\n        }\n    \n        return $b;\n    }\n\nيرجى تقديم وصف موجز بلغة طبيعية (docstring) للشفرة البرمجية بلغة PHP باللغة العربية الفصحى، بحيث لا يتجاوز 500 حرف.",
      "sw": "function getPellNumberModulo($k)\n{\n        if ($k === 1) return 1;\n        if ($k === 2) return 2;\n    \n        $a = 1; // a[1]\n        $b = 2; // a[2]\n    \n        for ($i = 3; $i <= $k; $i++) {\n            $temp = (2 * $b + $a) % 32767;\n            $a = $b;\n            $b = $temp;\n        }\n    \n        return $b;\n    }\n\nToa maelezo mafupi ya lugha asilia (docstring) ya msimbo wa PHP kwa Kiswahili kwa kutumia herufi zisizozidi 500.",
      "tr": "function getPellNumberModulo($k)\n{\n        if ($k === 1) return 1;\n        if ($k === 2) return 2;\n    \n        $a = 1; // a[1]\n        $b = 2; // a[2]\n    \n        for ($i = 3; $i <= $k; $i++) {\n            $temp = (2 * $b + $a) % 32767;\n            $a = $b;\n            $b = $temp;\n        }\n    \n        return $b;\n    }\n\nPHP kodunun işlevini açıklayan, en fazla 500 karakter uzunluğunda özlü bir doğal dil açıklaması (docstring) sağlayın.",
      "vi": "function getPellNumberModulo($k)\n{\n        if ($k === 1) return 1;\n        if ($k === 2) return 2;\n    \n        $a = 1; // a[1]\n        $b = 2; // a[2]\n    \n        for ($i = 3; $i <= $k; $i++) {\n            $temp = (2 * $b + $a) % 32767;\n            $a = $b;\n            $b = $temp;\n        }\n    \n        return $b;\n    }\n\nCung cấp mô tả ngắn gọn bằng ngôn ngữ tự nhiên (docstring) cho mã PHP bằng tiếng Việt với tối đa 500 ký tự."
    },
    "instruction_bertscore": {
      "es": "0.9687069752502395",
      "arb": "0.9135844623181046",
      "sw": "0.9428367585331127",
      "tr": "0.8724294391499621",
      "vi": "0.9017250367880356"
    },
    "level": "",
    "test": "function main(){\n    assert(getPellNumberModulo(1) === 1);\n    assert(getPellNumberModulo(8) === 408);\n    assert(getPellNumberModulo(3) === 5);\n    assert(getPellNumberModulo(5) === 29);\n    assert(getPellNumberModulo(10) === 2378);\n    assert(getPellNumberModulo(100000) === 27550);\n    assert(getPellNumberModulo(999999) === 21600);\n    \n}",
    "entry_point": "getPellNumberModulo",
    "signature": "function getPellNumberModulo($k)",
    "docstring": {
      "en": "Calculates the k-th term of the Pell sequence modulo 32767.\nThe Pell sequence is defined as follows:\na[1] = 1, a[2] = 2, and a[n] = 2*a[n-1] + a[n-2] for n > 2.\nThis function computes the k-th term of this sequence modulo 32767.\nInput: An integer $k (1 ≤ $k < 1000000), representing the position in the sequence.\nOutput: Returns the k-th term of the Pell sequence modulo 32767 as an integer.\nExample:\nFor $k = 1, the function returns 1.\nFor $k = 8, the function returns 408.",
      "es": "Calcula el término k-ésimo de la secuencia de Pell módulo 32767.  \nLa secuencia de Pell se define de la siguiente manera:  \na[1] = 1, a[2] = 2, y a[n] = 2*a[n-1] + a[n-2] para n > 2.  \nEsta función calcula el término k-ésimo de esta secuencia módulo 32767.  \nEntrada: Un entero $k (1 ≤ $k < 1000000), que representa la posición en la secuencia.  \nSalida: Devuelve el término k-ésimo de la secuencia de Pell módulo 32767 como un entero.  \nEjemplo:  \nPara $k = 1, la función devuelve 1.  \nPara $k = 8, la función devuelve 408.",
      "arb": "يحسب الحد k من متتالية بيل بتردد 32767.\nتعرف متتالية بيل كما يلي:\na[1] = 1, a[2] = 2, و a[n] = 2*a[n-1] + a[n-2] لـ n > 2.\nتقوم هذه الدالة بحساب الحد k من هذه المتتالية بتردد 32767.\nالمدخل: عدد صحيح $k (1 ≤ $k < 1000000)، يمثل الموضع في المتتالية.\nالمخرج: تعيد الحد k من متتالية بيل بتردد 32767 كعدد صحيح.\nمثال:\nبالنسبة لـ $k = 1، تعيد الدالة 1.\nبالنسبة لـ $k = 8، تعيد الدالة 408.",
      "sw": "Inahesabu neno la k katika mlolongo wa Pell modulo 32767. \nMlolongo wa Pell umefafanuliwa kama ifuatavyo: \na[1] = 1, a[2] = 2, na a[n] = 2*a[n-1] + a[n-2] kwa n > 2. \nKazi hii inahesabu neno la k katika mlolongo huu modulo 32767. \nIngizo: Nambari kamili $k (1 ≤ $k < 1000000), inayowakilisha nafasi katika mlolongo. \nPato: Inarudisha neno la k katika mlolongo wa Pell modulo 32767 kama nambari kamili. \nMfano: \nKwa $k = 1, kazi inarudisha 1. \nKwa $k = 8, kazi inarudisha 408.",
      "tr": "Pell dizisinin k. terimini 32767 modunda hesaplar.\nPell dizisi şu şekilde tanımlanır:\na[1] = 1, a[2] = 2 ve a[n] = 2*a[n-1] + a[n-2] for n > 2.\nBu fonksiyon, bu dizinin k. terimini 32767 modunda hesaplar.\nGirdi: Dizideki konumu temsil eden bir tamsayı $k (1 ≤ $k < 1000000).\nÇıktı: Pell dizisinin k. terimini 32767 modunda bir tamsayı olarak döndürür.\nÖrnek:\n$k = 1 için, fonksiyon 1 döndürür.\n$k = 8 için, fonksiyon 408 döndürür.",
      "vi": "Tính toán số hạng thứ k của dãy Pell theo modulo 32767.  \nDãy Pell được định nghĩa như sau:  \na[1] = 1, a[2] = 2, và a[n] = 2*a[n-1] + a[n-2] cho n > 2.  \nHàm này tính toán số hạng thứ k của dãy này theo modulo 32767.  \nĐầu vào: Một số nguyên $k (1 ≤ $k < 1000000), đại diện cho vị trí trong dãy.  \nĐầu ra: Trả về số hạng thứ k của dãy Pell theo modulo 32767 dưới dạng số nguyên.  \nVí dụ:  \nVới $k = 1, hàm trả về 1.  \nVới $k = 8, hàm trả về 408.  "
    },
    "docstring_bertscore": {
      "es": "0.9872080048309722",
      "arb": "0.9403610294638938",
      "sw": "0.9859385580657782",
      "tr": "0.98360306204557",
      "vi": "0.9855834069444878"
    }
  },
  {
    "task_id": "PHP/33",
    "prompt": {
      "en": "<?php\n\n/**\n    * Counts the number of flu infections in a dormitory grid after a certain number of days.\n    * The dormitory is represented as an n*n grid where each cell can have:\n    * - '.' representing a healthy person\n    * - '#' representing an empty room\n    * - '@' representing a person infected with the flu\n    * Each day, infected individuals spread the flu to adjacent (up, down, left, right) healthy individuals.\n    * The function calculates the total number of infected individuals after 'm' days.\n    * Input: \n    *   - $dormitory: A 2D array representing the n*n dormitory grid.\n    *   - $days: An integer representing the number of days.\n    * Output: Returns the total number of flu infections after 'm' days.\n    * Example:\n    *   Input: [['.','.','.','.','#'], \n                ['.','#','.','@','.'], \n                ['.','#','@','.','.'], \n                ['#','.','.','.','.'], \n                ['#','.','.','.','.']], 4\n    *   Output: 16\n*/\nfunction countFluInfections($dormitory, $days) ",
      "es": "<?php\n\n/**\n    * Cuenta el número de infecciones de gripe en una cuadrícula de dormitorio después de un cierto número de días.\n    * El dormitorio se representa como una cuadrícula n*n donde cada celda puede tener:\n    * - '.' representando a una persona sana\n    * - '#' representando una habitación vacía\n    * - '@' representando a una persona infectada con la gripe\n    * Cada día, los individuos infectados propagan la gripe a los individuos sanos adyacentes (arriba, abajo, izquierda, derecha).\n    * La función calcula el número total de individuos infectados después de 'm' días.\n    * Entrada:\n    *   - $dormitory: Un arreglo 2D que representa la cuadrícula del dormitorio n*n.\n    *   - $days: Un entero que representa el número de días.\n    * Salida: Devuelve el número total de infecciones de gripe después de 'm' días.\n    * Ejemplo:\n    *   Entrada: [['.','.','.','.','#'], \n                ['.','#','.','@','.'], \n                ['.','#','@','.','.'], \n                ['#','.','.','.','.'], \n                ['#','.','.','.','.']], 4\n    *   Salida: 16\n*/\nfunction countFluInfections($dormitory, $days) ",
      "arb": "<?php\n\n/**\n    * يحسب عدد الإصابات بالإنفلونزا في شبكة سكنية بعد عدد معين من الأيام.\n    * يتم تمثيل السكن كشبكة n*n حيث يمكن أن تحتوي كل خلية على:\n    * - '.' تمثل شخصًا سليمًا\n    * - '#' تمثل غرفة فارغة\n    * - '@' تمثل شخصًا مصابًا بالإنفلونزا\n    * كل يوم، ينشر الأفراد المصابون الإنفلونزا إلى الأفراد الأصحاء المجاورين (أعلى، أسفل، يسار، يمين).\n    * تقوم الدالة بحساب العدد الإجمالي للأفراد المصابين بعد 'm' أيام.\n    * المدخلات: \n    *   - $dormitory: مصفوفة ثنائية الأبعاد تمثل شبكة السكن n*n.\n    *   - $days: عدد صحيح يمثل عدد الأيام.\n    * المخرجات: تعيد العدد الإجمالي للإصابات بالإنفلونزا بعد 'm' أيام.\n    * مثال:\n    *   المدخل: [['.','.','.','.','#'], \n                ['.','#','.','@','.'], \n                ['.','#','@','.','.'], \n                ['#','.','.','.','.'], \n                ['#','.','.','.','.']], 4\n    *   المخرج: 16\n*/\nfunction countFluInfections($dormitory, $days) ",
      "sw": "<?php\n\n/**\n    * Inahesabu idadi ya maambukizi ya mafua katika gridi ya bweni baada ya siku kadhaa.\n    * Bweni linawakilishwa kama gridi ya n*n ambapo kila seli inaweza kuwa na:\n    * - '.' inawakilisha mtu mwenye afya\n    * - '#' inawakilisha chumba tupu\n    * - '@' inawakilisha mtu aliyeambukizwa na mafua\n    * Kila siku, watu walioambukizwa hueneza mafua kwa watu wenye afya walioko karibu (juu, chini, kushoto, kulia).\n    * Kazi hii inahesabu jumla ya watu walioambukizwa baada ya siku 'm'.\n    * Ingizo: \n    *   - $dormitory: Mfululizo wa 2D unaowakilisha gridi ya bweni ya n*n.\n    *   - $days: Nambari kamili inayoonyesha idadi ya siku.\n    * Tokeo: Inarudisha jumla ya maambukizi ya mafua baada ya siku 'm'.\n    * Mfano:\n    *   Ingizo: [['.','.','.','.','#'], \n                ['.','#','.','@','.'], \n                ['.','#','@','.','.'], \n                ['#','.','.','.','.'], \n                ['#','.','.','.','.']], 4\n    *   Tokeo: 16\n*/\nfunction countFluInfections($dormitory, $days) ",
      "tr": "<?php\n\n/**\n    * Belirli bir gün sayısından sonra bir yurt ızgarasında grip enfeksiyonlarının sayısını sayar.\n    * Yurt, her hücrenin şu durumlardan birine sahip olabileceği n*n bir ızgara olarak temsil edilir:\n    * - '.' sağlıklı bir kişiyi temsil eder\n    * - '#' boş bir odayı temsil eder\n    * - '@' grip ile enfekte olmuş bir kişiyi temsil eder\n    * Her gün, enfekte bireyler grip virüsünü bitişik (yukarı, aşağı, sol, sağ) sağlıklı bireylere yayar.\n    * Fonksiyon, 'm' gününden sonra toplam enfekte birey sayısını hesaplar.\n    * Girdi: \n    *   - $dormitory: n*n yurt ızgarasını temsil eden 2D bir dizi.\n    *   - $days: Gün sayısını temsil eden bir tamsayı.\n    * Çıktı: 'm' gününden sonra toplam grip enfeksiyonu sayısını döndürür.\n    * Örnek:\n    *   Girdi: [['.','.','.','.','#'], \n                ['.','#','.','@','.'], \n                ['.','#','@','.','.'], \n                ['#','.','.','.','.'], \n                ['#','.','.','.','.']], 4\n    *   Çıktı: 16\n*/\nfunction countFluInfections($dormitory, $days) ",
      "vi": "<?php\n\n/**\n    * Đếm số lượng ca nhiễm cúm trong một lưới ký túc xá sau một số ngày nhất định.\n    * Ký túc xá được biểu diễn dưới dạng lưới n*n, trong đó mỗi ô có thể có:\n    * - '.' đại diện cho một người khỏe mạnh\n    * - '#' đại diện cho một phòng trống\n    * - '@' đại diện cho một người bị nhiễm cúm\n    * Mỗi ngày, các cá nhân bị nhiễm bệnh lây lan cúm cho các cá nhân khỏe mạnh liền kề (trên, dưới, trái, phải).\n    * Hàm tính toán tổng số cá nhân bị nhiễm bệnh sau 'm' ngày.\n    * Đầu vào: \n    *   - $dormitory: Một mảng 2D đại diện cho lưới ký túc xá n*n.\n    *   - $days: Một số nguyên đại diện cho số ngày.\n    * Đầu ra: Trả về tổng số ca nhiễm cúm sau 'm' ngày.\n    * Ví dụ:\n    *   Đầu vào: [['.','.','.','.','#'], \n                ['.','#','.','@','.'], \n                ['.','#','@','.','.'], \n                ['#','.','.','.','.'], \n                ['#','.','.','.','.']], 4\n    *   Đầu ra: 16\n*/\nfunction countFluInfections($dormitory, $days) "
    },
    "prompt_bertscore": {
      "es": "0.993736985455589",
      "arb": "0.9671423637388278",
      "sw": "0.9631649889889852",
      "tr": "0.962942125701464",
      "vi": "0.9915274210969568"
    },
    "canonical_solution": "{\n    $n = count($dormitory);\n    $directions = [[-1, 0], [0, 1], [1, 0], [0, -1]];\n    $b = $dormitory;\n\n    for ($k = 2; $k <= $days; $k++) {\n        for ($i = 0; $i < $n; $i++) {\n            for ($j = 0; $j < $n; $j++) {\n                if ($dormitory[$i][$j] == '@') {\n                    foreach ($directions as $dir) {\n                        $xx = $i + $dir[0];\n                        $yy = $j + $dir[1];\n                        if ($xx >= 0 && $xx < $n && $yy >= 0 && $yy < $n && $b[$xx][$yy] == '.') {\n                            $b[$xx][$yy] = '@';\n                        }\n                    }\n                }\n            }\n        }\n        $dormitory = $b;\n    }\n\n    $ans = 0;\n    for ($i = 0; $i < $n; $i++) {\n        for ($j = 0; $j < $n; $j++) {\n            if ($dormitory[$i][$j] == '@') {\n                $ans++;\n            }\n        }\n    }\n    // echo $ans;\n    return $ans;\n}",
    "instruction": {
      "en": "function countFluInfections($dormitory, $days)\n{\n    $n = count($dormitory);\n    $directions = [[-1, 0], [0, 1], [1, 0], [0, -1]];\n    $b = $dormitory;\n\n    for ($k = 2; $k <= $days; $k++) {\n        for ($i = 0; $i < $n; $i++) {\n            for ($j = 0; $j < $n; $j++) {\n                if ($dormitory[$i][$j] == '@') {\n                    foreach ($directions as $dir) {\n                        $xx = $i + $dir[0];\n                        $yy = $j + $dir[1];\n                        if ($xx >= 0 && $xx < $n && $yy >= 0 && $yy < $n && $b[$xx][$yy] == '.') {\n                            $b[$xx][$yy] = '@';\n                        }\n                    }\n                }\n            }\n        }\n        $dormitory = $b;\n    }\n\n    $ans = 0;\n    for ($i = 0; $i < $n; $i++) {\n        for ($j = 0; $j < $n; $j++) {\n            if ($dormitory[$i][$j] == '@') {\n                $ans++;\n            }\n        }\n    }\n    // echo $ans;\n    return $ans;\n}\n\nProvide a concise natural language description (docstring) of the PHP code in English using at most 500 characters.",
      "es": "function countFluInfections($dormitory, $days)\n{\n    $n = count($dormitory);\n    $directions = [[-1, 0], [0, 1], [1, 0], [0, -1]];\n    $b = $dormitory;\n\n    for ($k = 2; $k <= $days; $k++) {\n        for ($i = 0; $i < $n; $i++) {\n            for ($j = 0; $j < $n; $j++) {\n                if ($dormitory[$i][$j] == '@') {\n                    foreach ($directions as $dir) {\n                        $xx = $i + $dir[0];\n                        $yy = $j + $dir[1];\n                        if ($xx >= 0 && $xx < $n && $yy >= 0 && $yy < $n && $b[$xx][$yy] == '.') {\n                            $b[$xx][$yy] = '@';\n                        }\n                    }\n                }\n            }\n        }\n        $dormitory = $b;\n    }\n\n    $ans = 0;\n    for ($i = 0; $i < $n; $i++) {\n        for ($j = 0; $j < $n; $j++) {\n            if ($dormitory[$i][$j] == '@') {\n                $ans++;\n            }\n        }\n    }\n    // echo $ans;\n    return $ans;\n}\n\nProporcione una descripción concisa en lenguaje natural (docstring) del código PHP en español utilizando como máximo 500 caracteres.",
      "arb": "function countFluInfections($dormitory, $days)\n{\n    $n = count($dormitory);\n    $directions = [[-1, 0], [0, 1], [1, 0], [0, -1]];\n    $b = $dormitory;\n\n    for ($k = 2; $k <= $days; $k++) {\n        for ($i = 0; $i < $n; $i++) {\n            for ($j = 0; $j < $n; $j++) {\n                if ($dormitory[$i][$j] == '@') {\n                    foreach ($directions as $dir) {\n                        $xx = $i + $dir[0];\n                        $yy = $j + $dir[1];\n                        if ($xx >= 0 && $xx < $n && $yy >= 0 && $yy < $n && $b[$xx][$yy] == '.') {\n                            $b[$xx][$yy] = '@';\n                        }\n                    }\n                }\n            }\n        }\n        $dormitory = $b;\n    }\n\n    $ans = 0;\n    for ($i = 0; $i < $n; $i++) {\n        for ($j = 0; $j < $n; $j++) {\n            if ($dormitory[$i][$j] == '@') {\n                $ans++;\n            }\n        }\n    }\n    // echo $ans;\n    return $ans;\n}\n\nيرجى تقديم وصف موجز بلغة طبيعية (docstring) لشيفرة PHP باللغة العربية الفصحى باستخدام 500 حرف كحد أقصى.",
      "sw": "function countFluInfections($dormitory, $days)\n{\n    $n = count($dormitory);\n    $directions = [[-1, 0], [0, 1], [1, 0], [0, -1]];\n    $b = $dormitory;\n\n    for ($k = 2; $k <= $days; $k++) {\n        for ($i = 0; $i < $n; $i++) {\n            for ($j = 0; $j < $n; $j++) {\n                if ($dormitory[$i][$j] == '@') {\n                    foreach ($directions as $dir) {\n                        $xx = $i + $dir[0];\n                        $yy = $j + $dir[1];\n                        if ($xx >= 0 && $xx < $n && $yy >= 0 && $yy < $n && $b[$xx][$yy] == '.') {\n                            $b[$xx][$yy] = '@';\n                        }\n                    }\n                }\n            }\n        }\n        $dormitory = $b;\n    }\n\n    $ans = 0;\n    for ($i = 0; $i < $n; $i++) {\n        for ($j = 0; $j < $n; $j++) {\n            if ($dormitory[$i][$j] == '@') {\n                $ans++;\n            }\n        }\n    }\n    // echo $ans;\n    return $ans;\n}\n\nToa maelezo mafupi ya lugha asilia (docstring) ya msimbo wa PHP kwa Kiswahili kwa kutumia herufi zisizozidi 500.",
      "tr": "function countFluInfections($dormitory, $days)\n{\n    $n = count($dormitory);\n    $directions = [[-1, 0], [0, 1], [1, 0], [0, -1]];\n    $b = $dormitory;\n\n    for ($k = 2; $k <= $days; $k++) {\n        for ($i = 0; $i < $n; $i++) {\n            for ($j = 0; $j < $n; $j++) {\n                if ($dormitory[$i][$j] == '@') {\n                    foreach ($directions as $dir) {\n                        $xx = $i + $dir[0];\n                        $yy = $j + $dir[1];\n                        if ($xx >= 0 && $xx < $n && $yy >= 0 && $yy < $n && $b[$xx][$yy] == '.') {\n                            $b[$xx][$yy] = '@';\n                        }\n                    }\n                }\n            }\n        }\n        $dormitory = $b;\n    }\n\n    $ans = 0;\n    for ($i = 0; $i < $n; $i++) {\n        for ($j = 0; $j < $n; $j++) {\n            if ($dormitory[$i][$j] == '@') {\n                $ans++;\n            }\n        }\n    }\n    // echo $ans;\n    return $ans;\n}\n\nPHP kodunun işlevini açıklayan en fazla 500 karakterlik öz bir doğal dil açıklaması (docstring) sağlayın.",
      "vi": "function countFluInfections($dormitory, $days)\n{\n    $n = count($dormitory);\n    $directions = [[-1, 0], [0, 1], [1, 0], [0, -1]];\n    $b = $dormitory;\n\n    for ($k = 2; $k <= $days; $k++) {\n        for ($i = 0; $i < $n; $i++) {\n            for ($j = 0; $j < $n; $j++) {\n                if ($dormitory[$i][$j] == '@') {\n                    foreach ($directions as $dir) {\n                        $xx = $i + $dir[0];\n                        $yy = $j + $dir[1];\n                        if ($xx >= 0 && $xx < $n && $yy >= 0 && $yy < $n && $b[$xx][$yy] == '.') {\n                            $b[$xx][$yy] = '@';\n                        }\n                    }\n                }\n            }\n        }\n        $dormitory = $b;\n    }\n\n    $ans = 0;\n    for ($i = 0; $i < $n; $i++) {\n        for ($j = 0; $j < $n; $j++) {\n            if ($dormitory[$i][$j] == '@') {\n                $ans++;\n            }\n        }\n    }\n    // echo $ans;\n    return $ans;\n}\n\nCung cấp mô tả ngắn gọn bằng ngôn ngữ tự nhiên (docstring) cho mã PHP bằng tiếng Việt với tối đa 500 ký tự."
    },
    "instruction_bertscore": {
      "es": "0.9521656330087972",
      "arb": "0.9148910529645522",
      "sw": "0.9428367585331127",
      "tr": "0.884584823947773",
      "vi": "0.9125917076736922"
    },
    "level": "",
    "test": "function main(){\n    assert(countFluInfections([\n        ['.','.','.','.','#'], \n        ['.','#','.','@','.'], \n        ['.','#','@','.','.'], \n        ['#','.','.','.','.'], \n        ['#','.','.','.','.']], 4) === 16);\n    \n\n    assert(countFluInfections([\n            ['.','.','.','.','#'], \n            ['.','#','.','@','.'], \n            ['.','#','@','.','.'], \n            ['#','.','.','.','.'], \n            ['#','.','.','.','.']], 1) === 2);\n    \n\n    assert(countFluInfections([\n                ['.','.','.','.','#'], \n                ['.','#','.','@','.'], \n                ['.','#','@','.','.'], \n                ['#','.','.','.','.'], \n                ['#','.','.','.','.']], 2) === 7);\n\n    assert(countFluInfections([\n                    ['.','.','.','.','#'], \n                    ['.','#','.','#','.'], \n                    ['.','#','#','.','.'], \n                    ['#','.','.','.','.'], \n                    ['#','.','.','.','.']], 100) === 0);\n}\n\n\nmain();\n?>",
    "entry_point": "countFluInfections",
    "signature": "function countFluInfections($dormitory, $days)",
    "docstring": {
      "en": "Counts the number of flu infections in a dormitory grid after a certain number of days.\nThe dormitory is represented as an n*n grid where each cell can have:\n- '.' representing a healthy person\n- '#' representing an empty room\n- '@' representing a person infected with the flu\nEach day, infected individuals spread the flu to adjacent (up, down, left, right) healthy individuals.\nThe function calculates the total number of infected individuals after 'm' days.\nInput:\n- $dormitory: A 2D array representing the n*n dormitory grid.\n- $days: An integer representing the number of days.\nOutput: Returns the total number of flu infections after 'm' days.\nExample:\nInput: [['.','.','.','.','#'],\n['.','#','.','@','.'],\n['.','#','@','.','.'],\n['#','.','.','.','.'],\n['#','.','.','.','.']], 4\nOutput: 16",
      "es": "Cuenta el número de infecciones de gripe en una cuadrícula de dormitorio después de un cierto número de días.  \nEl dormitorio está representado como una cuadrícula de n*n donde cada celda puede tener:  \n- '.' representando a una persona sana  \n- '#' representando una habitación vacía  \n- '@' representando a una persona infectada con la gripe  \nCada día, los individuos infectados propagan la gripe a los individuos sanos adyacentes (arriba, abajo, izquierda, derecha).  \nLa función calcula el número total de individuos infectados después de 'm' días.  \nEntrada:  \n- $dormitory: Un arreglo 2D que representa la cuadrícula de dormitorio n*n.  \n- $days: Un entero que representa el número de días.  \nSalida: Devuelve el número total de infecciones de gripe después de 'm' días.  \nEjemplo:  \nEntrada: [['.','.','.','.','#'],  \n['.','#','.','@','.'],  \n['.','#','@','.','.'],  \n['#','.','.','.','.'],  \n['#','.','.','.','.']], 4  \nSalida: 16  ",
      "arb": "يحسب عدد الإصابات بالإنفلونزا في شبكة سكنية بعد عدد معين من الأيام. يتم تمثيل السكن كشبكة n*n حيث يمكن أن تحتوي كل خلية على:\n- '.' تمثل شخصًا سليمًا\n- '#' تمثل غرفة فارغة\n- '@' تمثل شخصًا مصابًا بالإنفلونزا\nكل يوم، ينشر الأفراد المصابون الإنفلونزا إلى الأفراد الأصحاء المجاورين (أعلى، أسفل، يسار، يمين).\nتحسب الدالة العدد الإجمالي للأفراد المصابين بعد 'm' أيام.\nالمدخلات:\n- $dormitory: مصفوفة ثنائية الأبعاد تمثل شبكة السكن n*n.\n- $days: عدد صحيح يمثل عدد الأيام.\nالمخرجات: تعيد العدد الإجمالي للإصابات بالإنفلونزا بعد 'm' أيام.\nمثال:\nالمدخلات: [['.','.','.','.','#'],\n['.','#','.','@','.'],\n['.','#','@','.','.'],\n['#','.','.','.','.'],\n['#','.','.','.','.']], 4\nالمخرجات: 16",
      "sw": "Hesabu idadi ya maambukizi ya mafua katika gridi ya bweni baada ya siku kadhaa.\nBweni linaonyeshwa kama gridi ya n*n ambapo kila seli inaweza kuwa na:\n- '.' inawakilisha mtu mwenye afya\n- '#' inawakilisha chumba tupu\n- '@' inawakilisha mtu aliyeambukizwa na mafua\nKila siku, watu walioambukizwa hueneza mafua kwa watu wenye afya walio karibu (juu, chini, kushoto, kulia).\nKazi hii huhesabu jumla ya watu walioambukizwa baada ya siku 'm'.\nIngizo:\n- $dormitory: Safu mbili inayoonyesha gridi ya bweni ya n*n.\n- $days: Nambari kamili inayoonyesha idadi ya siku.\nPato: Inarudisha jumla ya maambukizi ya mafua baada ya siku 'm'.\nMfano:\nIngizo: [['.','.','.','.','#'],\n['.','#','.','@','.'],\n['.','#','@','.','.'],\n['#','.','.','.','.'],\n['#','.','.','.','.']], 4\nPato: 16",
      "tr": "Belirli bir gün sayısından sonra bir yurt ızgarasındaki grip enfeksiyonlarının sayısını sayar.\nYurt, her hücrenin şu durumlardan birine sahip olabileceği n*n bir ızgara olarak temsil edilir:\n- '.' sağlıklı bir kişiyi temsil eder\n- '#' boş bir odayı temsil eder\n- '@' grip ile enfekte olmuş bir kişiyi temsil eder\nHer gün, enfekte bireyler grip virüsünü bitişik (yukarı, aşağı, sol, sağ) sağlıklı bireylere yayar.\nFonksiyon, 'm' gününden sonra enfekte olmuş toplam birey sayısını hesaplar.\nGirdi:\n- $dormitory: n*n yurt ızgarasını temsil eden bir 2D dizi.\n- $days: Gün sayısını temsil eden bir tamsayı.\nÇıktı: 'm' gününden sonra grip enfeksiyonlarının toplam sayısını döndürür.\nÖrnek:\nGirdi: [['.','.','.','.','#'],\n['.','#','.','@','.'],\n['.','#','@','.','.'],\n['#','.','.','.','.'],\n['#','.','.','.','.']], 4\nÇıktı: 16",
      "vi": "Đếm số ca nhiễm cúm trong một lưới ký túc xá sau một số ngày nhất định. Ký túc xá được biểu diễn dưới dạng lưới n*n, trong đó mỗi ô có thể là:\n- '.' biểu thị một người khỏe mạnh\n- '#' biểu thị một phòng trống\n- '@' biểu thị một người bị nhiễm cúm\nMỗi ngày, các cá nhân bị nhiễm bệnh lây lan cúm cho những người khỏe mạnh liền kề (trên, dưới, trái, phải).\nHàm tính toán tổng số người bị nhiễm bệnh sau 'm' ngày.\nĐầu vào:\n- $dormitory: Một mảng 2D biểu diễn lưới ký túc xá n*n.\n- $days: Một số nguyên biểu thị số ngày.\nĐầu ra: Trả về tổng số ca nhiễm cúm sau 'm' ngày.\nVí dụ:\nĐầu vào: [['.','.','.','.','#'],\n['.','#','.','@','.'],\n['.','#','@','.','.'],\n['#','.','.','.','.'],\n['#','.','.','.','.']], 4\nĐầu ra: 16"
    },
    "docstring_bertscore": {
      "es": "0.9823491084500967",
      "arb": "0.9620834465642502",
      "sw": "0.9459405568671638",
      "tr": "0.962537515615296",
      "vi": "0.9786629258388513"
    }
  },
  {
    "task_id": "PHP/34",
    "prompt": {
      "en": "<?php\n\n\n/**\n * Counts the number of unique paths an ant can take to move from the bottom-left to the top-right corner of a grid.\n * The grid is defined by m rows and n columns. The ant starts at (1,1) and can only move right or up due to an injury.\n * - For a 1x1 grid (m = 1, n = 1), there is only 1 path.\n * - For a 2x3 grid (m = 2, n = 3), there are 3 possible paths.\n * Input: Two integers, m and n, representing the number of rows and columns of the grid.\n * Output: Returns the count of unique paths from (1,1) to (m,n).\n */\n\n function countAntPaths($m, $n): int ",
      "es": "<?php\n\n\n/**\n * Cuenta el número de caminos únicos que una hormiga puede tomar para moverse desde la esquina inferior izquierda hasta la esquina superior derecha de una cuadrícula.\n * La cuadrícula está definida por m filas y n columnas. La hormiga comienza en (1,1) y solo puede moverse a la derecha o hacia arriba debido a una lesión.\n * - Para una cuadrícula de 1x1 (m = 1, n = 1), solo hay 1 camino.\n * - Para una cuadrícula de 2x3 (m = 2, n = 3), hay 3 caminos posibles.\n * Entrada: Dos enteros, m y n, que representan el número de filas y columnas de la cuadrícula.\n * Salida: Devuelve el conteo de caminos únicos desde (1,1) hasta (m,n).\n */\n\n function countAntPaths($m, $n): int ",
      "arb": "<?php\n\n\n/**\n * يحسب عدد المسارات الفريدة التي يمكن لنملة أن تسلكها للتحرك من الزاوية السفلية اليسرى إلى الزاوية العلوية اليمنى لشبكة.\n * يتم تعريف الشبكة بواسطة m صفوف و n أعمدة. تبدأ النملة عند (1,1) ولا يمكنها التحرك إلا إلى اليمين أو للأعلى بسبب إصابة.\n * - بالنسبة لشبكة 1x1 (m = 1, n = 1)، هناك مسار واحد فقط.\n * - بالنسبة لشبكة 2x3 (m = 2, n = 3)، هناك 3 مسارات ممكنة.\n * المدخلات: عددان صحيحان، m و n، يمثلان عدد الصفوف والأعمدة في الشبكة.\n * المخرجات: يعيد عدد المسارات الفريدة من (1,1) إلى (m,n).\n */\n\n function countAntPaths($m, $n): int ",
      "sw": "<?php\n\n\n/**\n * Inahesabu idadi ya njia za kipekee ambazo sisimizi anaweza kuchukua ili kuhamia kutoka kona ya chini-kushoto hadi kona ya juu-kulia ya gridi.\n * Gridi inafafanuliwa na mistari m na safu n. Sisimizi huanza katika (1,1) na anaweza kusonga kulia au juu tu kutokana na jeraha.\n * - Kwa gridi ya 1x1 (m = 1, n = 1), kuna njia 1 tu.\n * - Kwa gridi ya 2x3 (m = 2, n = 3), kuna njia 3 zinazowezekana.\n * Ingizo: Nambari mbili za mzima, m na n, zinazowakilisha idadi ya mistari na safu za gridi.\n * Matokeo: Inarudisha idadi ya njia za kipekee kutoka (1,1) hadi (m,n).\n */\n\n function countAntPaths($m, $n): int ",
      "tr": "<?php\n\n\n/**\n * Bir karıncanın bir ızgaranın sol alt köşesinden sağ üst köşesine hareket etmek için alabileceği benzersiz yolların sayısını sayar.\n * Izgara m satır ve n sütun ile tanımlanır. Karınca (1,1) noktasında başlar ve bir yaralanma nedeniyle sadece sağa veya yukarı hareket edebilir.\n * - 1x1 ızgara için (m = 1, n = 1), sadece 1 yol vardır.\n * - 2x3 ızgara için (m = 2, n = 3), 3 olası yol vardır.\n * Girdi: Izgara satır ve sütun sayısını temsil eden iki tamsayı, m ve n.\n * Çıktı: (1,1) noktasından (m,n) noktasına benzersiz yolların sayısını döndürür.\n */\n\n function countAntPaths($m, $n): int ",
      "vi": "<?php\n\n\n/**\n * Đếm số lượng đường đi duy nhất mà một con kiến có thể đi từ góc dưới bên trái đến góc trên bên phải của một lưới.\n * Lưới được xác định bởi m hàng và n cột. Con kiến bắt đầu tại (1,1) và chỉ có thể di chuyển sang phải hoặc lên trên do bị thương.\n * - Đối với lưới 1x1 (m = 1, n = 1), chỉ có 1 đường đi.\n * - Đối với lưới 2x3 (m = 2, n = 3), có 3 đường đi có thể.\n * Đầu vào: Hai số nguyên, m và n, đại diện cho số hàng và số cột của lưới.\n * Đầu ra: Trả về số lượng đường đi duy nhất từ (1,1) đến (m,n).\n */\n\n function countAntPaths($m, $n): int "
    },
    "prompt_bertscore": {
      "es": "0.988272067782176",
      "arb": "0.9837389252261979",
      "sw": "0.9823872454832554",
      "tr": "0.9739031460181122",
      "vi": "0.9839756926403914"
    },
    "canonical_solution": " {\n    // Base case\n    if ($m == 1 || $n == 1) {\n        return 1;\n    }\n\n    // Create a 2D array to store path counts\n    $pathCount = array_fill(0, $m, array_fill(0, $n, 0));\n\n    // Initialize the first row and first column\n    for ($i = 0; $i < $m; $i++) {\n        $pathCount[$i][0] = 1;\n    }\n    for ($j = 0; $j < $n; $j++) {\n        $pathCount[0][$j] = 1;\n    }\n\n    // Calculate path counts for other cells\n    for ($i = 1; $i < $m; $i++) {\n        for ($j = 1; $j < $n; $j++) {\n            $pathCount[$i][$j] = $pathCount[$i - 1][$j] + $pathCount[$i][$j - 1];\n        }\n    }\n\n    return $pathCount[$m - 1][$n - 1];\n}",
    "instruction": {
      "en": "function countAntPaths($m, $n): int\n {\n    // Base case\n    if ($m == 1 || $n == 1) {\n        return 1;\n    }\n\n    // Create a 2D array to store path counts\n    $pathCount = array_fill(0, $m, array_fill(0, $n, 0));\n\n    // Initialize the first row and first column\n    for ($i = 0; $i < $m; $i++) {\n        $pathCount[$i][0] = 1;\n    }\n    for ($j = 0; $j < $n; $j++) {\n        $pathCount[0][$j] = 1;\n    }\n\n    // Calculate path counts for other cells\n    for ($i = 1; $i < $m; $i++) {\n        for ($j = 1; $j < $n; $j++) {\n            $pathCount[$i][$j] = $pathCount[$i - 1][$j] + $pathCount[$i][$j - 1];\n        }\n    }\n\n    return $pathCount[$m - 1][$n - 1];\n}\n\nProvide a concise natural language description (docstring) of the PHP code in English using at most 500 characters.",
      "es": "function countAntPaths($m, $n): int\n {\n    // Base case\n    if ($m == 1 || $n == 1) {\n        return 1;\n    }\n\n    // Create a 2D array to store path counts\n    $pathCount = array_fill(0, $m, array_fill(0, $n, 0));\n\n    // Initialize the first row and first column\n    for ($i = 0; $i < $m; $i++) {\n        $pathCount[$i][0] = 1;\n    }\n    for ($j = 0; $j < $n; $j++) {\n        $pathCount[0][$j] = 1;\n    }\n\n    // Calculate path counts for other cells\n    for ($i = 1; $i < $m; $i++) {\n        for ($j = 1; $j < $n; $j++) {\n            $pathCount[$i][$j] = $pathCount[$i - 1][$j] + $pathCount[$i][$j - 1];\n        }\n    }\n\n    return $pathCount[$m - 1][$n - 1];\n}\n\nProporcione una descripción concisa en lenguaje natural (docstring) del código PHP en español utilizando un máximo de 500 caracteres.",
      "arb": "function countAntPaths($m, $n): int\n {\n    // Base case\n    if ($m == 1 || $n == 1) {\n        return 1;\n    }\n\n    // Create a 2D array to store path counts\n    $pathCount = array_fill(0, $m, array_fill(0, $n, 0));\n\n    // Initialize the first row and first column\n    for ($i = 0; $i < $m; $i++) {\n        $pathCount[$i][0] = 1;\n    }\n    for ($j = 0; $j < $n; $j++) {\n        $pathCount[0][$j] = 1;\n    }\n\n    // Calculate path counts for other cells\n    for ($i = 1; $i < $m; $i++) {\n        for ($j = 1; $j < $n; $j++) {\n            $pathCount[$i][$j] = $pathCount[$i - 1][$j] + $pathCount[$i][$j - 1];\n        }\n    }\n\n    return $pathCount[$m - 1][$n - 1];\n}\n\nيرجى تقديم وصف موجز بلغة طبيعية (docstring) للكود المكتوب بلغة PHP باللغة العربية الفصحى باستخدام 500 حرف كحد أقصى.",
      "sw": "function countAntPaths($m, $n): int\n {\n    // Base case\n    if ($m == 1 || $n == 1) {\n        return 1;\n    }\n\n    // Create a 2D array to store path counts\n    $pathCount = array_fill(0, $m, array_fill(0, $n, 0));\n\n    // Initialize the first row and first column\n    for ($i = 0; $i < $m; $i++) {\n        $pathCount[$i][0] = 1;\n    }\n    for ($j = 0; $j < $n; $j++) {\n        $pathCount[0][$j] = 1;\n    }\n\n    // Calculate path counts for other cells\n    for ($i = 1; $i < $m; $i++) {\n        for ($j = 1; $j < $n; $j++) {\n            $pathCount[$i][$j] = $pathCount[$i - 1][$j] + $pathCount[$i][$j - 1];\n        }\n    }\n\n    return $pathCount[$m - 1][$n - 1];\n}\n\nToa maelezo mafupi ya lugha ya asili (docstring) ya msimbo wa PHP kwa Kiswahili kwa kutumia herufi zisizozidi 500.",
      "tr": "function countAntPaths($m, $n): int\n {\n    // Base case\n    if ($m == 1 || $n == 1) {\n        return 1;\n    }\n\n    // Create a 2D array to store path counts\n    $pathCount = array_fill(0, $m, array_fill(0, $n, 0));\n\n    // Initialize the first row and first column\n    for ($i = 0; $i < $m; $i++) {\n        $pathCount[$i][0] = 1;\n    }\n    for ($j = 0; $j < $n; $j++) {\n        $pathCount[0][$j] = 1;\n    }\n\n    // Calculate path counts for other cells\n    for ($i = 1; $i < $m; $i++) {\n        for ($j = 1; $j < $n; $j++) {\n            $pathCount[$i][$j] = $pathCount[$i - 1][$j] + $pathCount[$i][$j - 1];\n        }\n    }\n\n    return $pathCount[$m - 1][$n - 1];\n}\n\nPHP kodunun işlevini açıklayan kısa bir doğal dil açıklaması (docstring) sağlayın. Açıklama, en fazla 500 karakter kullanılarak Türkçe olarak yazılmalıdır.",
      "vi": "function countAntPaths($m, $n): int\n {\n    // Base case\n    if ($m == 1 || $n == 1) {\n        return 1;\n    }\n\n    // Create a 2D array to store path counts\n    $pathCount = array_fill(0, $m, array_fill(0, $n, 0));\n\n    // Initialize the first row and first column\n    for ($i = 0; $i < $m; $i++) {\n        $pathCount[$i][0] = 1;\n    }\n    for ($j = 0; $j < $n; $j++) {\n        $pathCount[0][$j] = 1;\n    }\n\n    // Calculate path counts for other cells\n    for ($i = 1; $i < $m; $i++) {\n        for ($j = 1; $j < $n; $j++) {\n            $pathCount[$i][$j] = $pathCount[$i - 1][$j] + $pathCount[$i][$j - 1];\n        }\n    }\n\n    return $pathCount[$m - 1][$n - 1];\n}\n\nCung cấp mô tả ngắn gọn bằng ngôn ngữ tự nhiên (docstring) cho mã PHP bằng tiếng Việt với tối đa 500 ký tự."
    },
    "instruction_bertscore": {
      "es": "0.9687069752502395",
      "arb": "0.8896079876537644",
      "sw": "0.91585798565943",
      "tr": "0.8709212386667641",
      "vi": "0.9017250367880356"
    },
    "level": "",
    "test": "function main(){\n    assert(countAntPaths(1, 1) === 1); // One path in a 1x1 grid\n    assert(countAntPaths(2, 3) === 3); // Three paths in a 2x3 grid\n    assert(countAntPaths(3, 3) === 6); // Six paths in a 3x3 grid    \n    assert(countAntPaths(7, 13) === 18564);    \n}\n\n\nmain();\n?>",
    "entry_point": "countAntPaths",
    "signature": "function countAntPaths($m, $n): int",
    "docstring": {
      "en": "Counts the number of unique paths an ant can take to move from the bottom-left to the top-right corner of a grid.\nThe grid is defined by m rows and n columns. The ant starts at (1,1) and can only move right or up due to an injury.\n- For a 1x1 grid (m = 1, n = 1), there is only 1 path.\n- For a 2x3 grid (m = 2, n = 3), there are 3 possible paths.\nInput: Two integers, m and n, representing the number of rows and columns of the grid.\nOutput: Returns the count of unique paths from (1,1) to (m,n).",
      "es": "Cuenta el número de caminos únicos que una hormiga puede tomar para moverse desde la esquina inferior izquierda hasta la esquina superior derecha de una cuadrícula.  \nLa cuadrícula está definida por m filas y n columnas. La hormiga comienza en (1,1) y solo puede moverse a la derecha o hacia arriba debido a una lesión.  \n- Para una cuadrícula de 1x1 (m = 1, n = 1), solo hay 1 camino.  \n- Para una cuadrícula de 2x3 (m = 2, n = 3), hay 3 caminos posibles.  \nEntrada: Dos enteros, m y n, que representan el número de filas y columnas de la cuadrícula.  \nSalida: Devuelve el conteo de caminos únicos desde (1,1) hasta (m,n).",
      "arb": "يحسب عدد المسارات الفريدة التي يمكن لنملة أن تسلكها للتحرك من الزاوية السفلية اليسرى إلى الزاوية العلوية اليمنى لشبكة.\nيتم تعريف الشبكة بواسطة m صفوف و n أعمدة. تبدأ النملة عند (1,1) ويمكنها التحرك فقط إلى اليمين أو للأعلى بسبب إصابة.\n- بالنسبة لشبكة 1x1 (m = 1, n = 1)، هناك مسار واحد فقط.\n- بالنسبة لشبكة 2x3 (m = 2, n = 3)، هناك 3 مسارات ممكنة.\nالمدخلات: عددان صحيحان، m و n، يمثلان عدد الصفوف والأعمدة في الشبكة.\nالمخرجات: يعيد عدد المسارات الفريدة من (1,1) إلى (m,n).",
      "sw": "Hesabu idadi ya njia za kipekee ambazo sisimizi anaweza kuchukua ili kuhamia kutoka kona ya chini-kushoto hadi kona ya juu-kulia ya gridi.\nGridi imefafanuliwa na mistari m na safu n. Sisimizi huanza katika (1,1) na anaweza tu kusonga kulia au juu kutokana na jeraha.\n- Kwa gridi ya 1x1 (m = 1, n = 1), kuna njia 1 pekee.\n- Kwa gridi ya 2x3 (m = 2, n = 3), kuna njia 3 zinazowezekana.\nIngizo: Nambari mbili za mzima, m na n, zinazoashiria idadi ya mistari na safu za gridi.\nPato: Inarudisha hesabu ya njia za kipekee kutoka (1,1) hadi (m,n).",
      "tr": "Eşsiz yolların sayısını, bir karıncanın bir ızgaranın sol alt köşesinden sağ üst köşesine hareket edebileceği yolları sayar.\nIzgara, m satır ve n sütun ile tanımlanır. Karınca (1,1) noktasında başlar ve bir yaralanma nedeniyle sadece sağa veya yukarı hareket edebilir.\n- 1x1 bir ızgara için (m = 1, n = 1), yalnızca 1 yol vardır.\n- 2x3 bir ızgara için (m = 2, n = 3), 3 olası yol vardır.\nGirdi: Izgaranın satır ve sütun sayısını temsil eden iki tam sayı, m ve n.\nÇıktı: (1,1) noktasından (m,n) noktasına kadar olan eşsiz yolların sayısını döndürür.",
      "vi": "Đếm số lượng đường đi duy nhất mà một con kiến có thể đi từ góc dưới bên trái đến góc trên bên phải của một lưới.\nLưới được định nghĩa bởi m hàng và n cột. Con kiến bắt đầu tại (1,1) và chỉ có thể di chuyển sang phải hoặc lên trên do bị thương.\n- Đối với lưới 1x1 (m = 1, n = 1), chỉ có 1 đường đi.\n- Đối với lưới 2x3 (m = 2, n = 3), có 3 đường đi khả dĩ.\nĐầu vào: Hai số nguyên, m và n, đại diện cho số hàng và số cột của lưới.\nĐầu ra: Trả về số lượng đường đi duy nhất từ (1,1) đến (m,n)."
    },
    "docstring_bertscore": {
      "es": "0.9908923997687883",
      "arb": "0.9804587431137877",
      "sw": "0.9792719265871043",
      "tr": "0.9529941203280937",
      "vi": "0.9795223994975892"
    }
  },
  {
    "task_id": "PHP/35",
    "prompt": {
      "en": "<?php\n\n/**\n * Determines if there exists at least one permutation of adding '+' or '-' \n * before each number in a sequence such that the sum of the sequence is \n * divisible by a given number k.\n * \n * The function takes two arguments: \n * - $numbers: An array of positive integers representing the sequence.\n * - $k: An integer representing the divisor.\n * \n * The function returns \"YES\" if at least one permutation of the sequence \n * can be divided by $k, otherwise returns \"NO\".\n * \n * Example:\n * Given $numbers = [1, 2, 4] and $k = 2, the function will return \"NO\".\n * Given $numbers = [1, 2, 4] and $k = 3, the function will return \"YES\".\n */\n\n function canBeDivided(array $numbers, int $k): string ",
      "es": "<?php\n\n/**\n * Determina si existe al menos una permutación de añadir '+' o '-' \n * antes de cada número en una secuencia tal que la suma de la secuencia \n * sea divisible por un número dado k.\n * \n * La función toma dos argumentos: \n * - $numbers: Un arreglo de enteros positivos que representa la secuencia.\n * - $k: Un entero que representa el divisor.\n * \n * La función devuelve \"YES\" si al menos una permutación de la secuencia \n * puede ser dividida por $k, de lo contrario devuelve \"NO\".\n * \n * Ejemplo:\n * Dado $numbers = [1, 2, 4] y $k = 2, la función devolverá \"NO\".\n * Dado $numbers = [1, 2, 4] y $k = 3, la función devolverá \"YES\".\n */\n\n function canBeDivided(array $numbers, int $k): string ",
      "arb": "<?php\n\n/**\n * يحدد ما إذا كان هناك على الأقل ترتيب واحد لإضافة '+' أو '-' \n * قبل كل رقم في تسلسل بحيث يكون مجموع التسلسل \n * قابلاً للقسمة على عدد معين k.\n * \n * تأخذ الدالة وسيطين: \n * - $numbers: مصفوفة من الأعداد الصحيحة الموجبة تمثل التسلسل.\n * - $k: عدد صحيح يمثل القاسم.\n * \n * تعيد الدالة \"YES\" إذا كان هناك على الأقل ترتيب واحد للتسلسل \n * يمكن قسمته على $k، وإلا تعيد \"NO\".\n * \n * مثال:\n * إذا كان $numbers = [1, 2, 4] و $k = 2، ستعيد الدالة \"NO\".\n * إذا كان $numbers = [1, 2, 4] و $k = 3، ستعيد الدالة \"YES\".\n */\n\n function canBeDivided(array $numbers, int $k): string ",
      "sw": "<?php\n\n/**\n * Huamua ikiwa kuna angalau mpangilio mmoja wa kuongeza '+' au '-' \n * kabla ya kila nambari katika mlolongo ili jumla ya mlolongo huo \n * iweze kugawanyika kwa nambari fulani k.\n * \n * Kazi inachukua hoja mbili: \n * - $numbers: Mfululizo wa nambari za mzima chanya zinazowakilisha mlolongo.\n * - $k: Nambari ya mzima inayowakilisha mgawanyiko.\n * \n * Kazi inarudisha \"YES\" ikiwa angalau mpangilio mmoja wa mlolongo \n * unaweza kugawanyika kwa $k, vinginevyo inarudisha \"NO\".\n * \n * Mfano:\n * Ukipewa $numbers = [1, 2, 4] na $k = 2, kazi itarudisha \"NO\".\n * Ukipewa $numbers = [1, 2, 4] na $k = 3, kazi itarudisha \"YES\".\n */\n\n function canBeDivided(array $numbers, int $k): string ",
      "tr": "<?php\n\n/**\n * Bir dizideki her sayının önüne '+' veya '-' ekleyerek en az bir permütasyonun \n * toplamının verilen bir sayı k ile bölünebilir olup olmadığını belirler.\n * \n * Fonksiyon iki argüman alır: \n * - $numbers: Diziyi temsil eden pozitif tam sayılardan oluşan bir dizi.\n * - $k: Böleni temsil eden bir tam sayı.\n * \n * Fonksiyon, dizinin en az bir permütasyonunun $k ile bölünebilir olması durumunda \"YES\", \n * aksi takdirde \"NO\" döndürür.\n * \n * Örnek:\n * Verilen $numbers = [1, 2, 4] ve $k = 2 olduğunda, fonksiyon \"NO\" döndürecektir.\n * Verilen $numbers = [1, 2, 4] ve $k = 3 olduğunda, fonksiyon \"YES\" döndürecektir.\n */\n\n function canBeDivided(array $numbers, int $k): string ",
      "vi": "<?php\n\n/**\n * Xác định xem có tồn tại ít nhất một hoán vị của việc thêm '+' hoặc '-' \n * trước mỗi số trong một dãy số sao cho tổng của dãy số có thể chia hết \n * cho một số cho trước k hay không.\n * \n * Hàm nhận hai tham số: \n * - $numbers: Một mảng các số nguyên dương đại diện cho dãy số.\n * - $k: Một số nguyên đại diện cho số chia.\n * \n * Hàm trả về \"YES\" nếu ít nhất một hoán vị của dãy số có thể chia hết cho $k, \n * ngược lại trả về \"NO\".\n * \n * Ví dụ:\n * Với $numbers = [1, 2, 4] và $k = 2, hàm sẽ trả về \"NO\".\n * Với $numbers = [1, 2, 4] và $k = 3, hàm sẽ trả về \"YES\".\n */\n\n function canBeDivided(array $numbers, int $k): string "
    },
    "prompt_bertscore": {
      "es": "0.9939818967154049",
      "arb": "0.9657074578662317",
      "sw": "0.968458488643565",
      "tr": "0.959224360859634",
      "vi": "0.9866564082628383"
    },
    "canonical_solution": " {\n    $totalCombinations = pow(2, count($numbers));\n    for ($i = 0; $i < $totalCombinations; $i++) {\n        $sum = 0;\n        for ($j = 0; $j < count($numbers); $j++) {\n            // Check if the jth bit in i is set to decide if to add or subtract\n            if ($i & (1 << $j)) {\n                $sum += $numbers[$j];\n            } else {\n                $sum -= $numbers[$j];\n            }\n        }\n        if ($sum % $k == 0) {\n            return \"YES\";\n        }\n    }\n    return \"NO\";\n}",
    "instruction": {
      "en": "function canBeDivided(array $numbers, int $k): string\n {\n    $totalCombinations = pow(2, count($numbers));\n    for ($i = 0; $i < $totalCombinations; $i++) {\n        $sum = 0;\n        for ($j = 0; $j < count($numbers); $j++) {\n            // Check if the jth bit in i is set to decide if to add or subtract\n            if ($i & (1 << $j)) {\n                $sum += $numbers[$j];\n            } else {\n                $sum -= $numbers[$j];\n            }\n        }\n        if ($sum % $k == 0) {\n            return \"YES\";\n        }\n    }\n    return \"NO\";\n}\n\nProvide a concise natural language description (docstring) of the PHP code in English using at most 500 characters.",
      "es": "function canBeDivided(array $numbers, int $k): string\n {\n    $totalCombinations = pow(2, count($numbers));\n    for ($i = 0; $i < $totalCombinations; $i++) {\n        $sum = 0;\n        for ($j = 0; $j < count($numbers); $j++) {\n            // Check if the jth bit in i is set to decide if to add or subtract\n            if ($i & (1 << $j)) {\n                $sum += $numbers[$j];\n            } else {\n                $sum -= $numbers[$j];\n            }\n        }\n        if ($sum % $k == 0) {\n            return \"YES\";\n        }\n    }\n    return \"NO\";\n}\n\nProporcione una descripción concisa en lenguaje natural (docstring) del código PHP en español utilizando como máximo 500 caracteres.",
      "arb": "function canBeDivided(array $numbers, int $k): string\n {\n    $totalCombinations = pow(2, count($numbers));\n    for ($i = 0; $i < $totalCombinations; $i++) {\n        $sum = 0;\n        for ($j = 0; $j < count($numbers); $j++) {\n            // Check if the jth bit in i is set to decide if to add or subtract\n            if ($i & (1 << $j)) {\n                $sum += $numbers[$j];\n            } else {\n                $sum -= $numbers[$j];\n            }\n        }\n        if ($sum % $k == 0) {\n            return \"YES\";\n        }\n    }\n    return \"NO\";\n}\n\nيرجى تقديم وصف موجز بلغة طبيعية (docstring) لشيفرة PHP باللغة العربية الفصحى باستخدام ما لا يزيد عن 500 حرف.",
      "sw": "function canBeDivided(array $numbers, int $k): string\n {\n    $totalCombinations = pow(2, count($numbers));\n    for ($i = 0; $i < $totalCombinations; $i++) {\n        $sum = 0;\n        for ($j = 0; $j < count($numbers); $j++) {\n            // Check if the jth bit in i is set to decide if to add or subtract\n            if ($i & (1 << $j)) {\n                $sum += $numbers[$j];\n            } else {\n                $sum -= $numbers[$j];\n            }\n        }\n        if ($sum % $k == 0) {\n            return \"YES\";\n        }\n    }\n    return \"NO\";\n}\n\nToa maelezo mafupi ya lugha asilia (docstring) ya msimbo wa PHP kwa Kiswahili kwa kutumia herufi zisizozidi 500.",
      "tr": "function canBeDivided(array $numbers, int $k): string\n {\n    $totalCombinations = pow(2, count($numbers));\n    for ($i = 0; $i < $totalCombinations; $i++) {\n        $sum = 0;\n        for ($j = 0; $j < count($numbers); $j++) {\n            // Check if the jth bit in i is set to decide if to add or subtract\n            if ($i & (1 << $j)) {\n                $sum += $numbers[$j];\n            } else {\n                $sum -= $numbers[$j];\n            }\n        }\n        if ($sum % $k == 0) {\n            return \"YES\";\n        }\n    }\n    return \"NO\";\n}\n\nPHP kodunun işlevini açıklayan kısa bir doğal dil açıklaması (docstring) sağlayın. Açıklama, en fazla 500 karakter kullanılarak Türkçe olarak yazılmalıdır.",
      "vi": "function canBeDivided(array $numbers, int $k): string\n {\n    $totalCombinations = pow(2, count($numbers));\n    for ($i = 0; $i < $totalCombinations; $i++) {\n        $sum = 0;\n        for ($j = 0; $j < count($numbers); $j++) {\n            // Check if the jth bit in i is set to decide if to add or subtract\n            if ($i & (1 << $j)) {\n                $sum += $numbers[$j];\n            } else {\n                $sum -= $numbers[$j];\n            }\n        }\n        if ($sum % $k == 0) {\n            return \"YES\";\n        }\n    }\n    return \"NO\";\n}\n\nCung cấp mô tả ngắn gọn bằng ngôn ngữ tự nhiên (docstring) cho mã PHP bằng tiếng Việt, sử dụng tối đa 500 ký tự."
    },
    "instruction_bertscore": {
      "es": "0.9521656330087972",
      "arb": "0.9057036033201644",
      "sw": "0.9428367585331127",
      "tr": "0.8711236430250386",
      "vi": "0.9202302376067699"
    },
    "level": "",
    "test": "function main(){\n    assert(canBeDivided([1, 2, 4], 2) === \"NO\");\n    assert(canBeDivided([1, 2, 4], 3) === \"YES\");\n    assert(canBeDivided([1, 2, 3], 6) === \"YES\");\n    assert(canBeDivided([5, 10, 15], 7) === \"YES\");\n    assert(canBeDivided([10, 20, 30], 10) === \"YES\");\n    \n}\n\n\nmain();\n?>",
    "entry_point": "canBeDivided",
    "signature": "function canBeDivided(array $numbers, int $k): string",
    "docstring": {
      "en": "Determines if there exists at least one permutation of adding '+' or '-'\nbefore each number in a sequence such that the sum of the sequence is\ndivisible by a given number k.\n\nThe function takes two arguments:\n- $numbers: An array of positive integers representing the sequence.\n- $k: An integer representing the divisor.\n\nThe function returns \"YES\" if at least one permutation of the sequence\ncan be divided by $k, otherwise returns \"NO\".\n\nExample:\nGiven $numbers = [1, 2, 4] and $k = 2, the function will return \"NO\".\nGiven $numbers = [1, 2, 4] and $k = 3, the function will return \"YES\".",
      "es": "Determina si existe al menos una permutación de añadir '+' o '-' antes de cada número en una secuencia tal que la suma de la secuencia sea divisible por un número dado k.\n\nLa función toma dos argumentos:\n- $numbers: Un arreglo de enteros positivos que representa la secuencia.\n- $k: Un entero que representa el divisor.\n\nLa función devuelve \"YES\" si al menos una permutación de la secuencia puede ser dividida por $k, de lo contrario devuelve \"NO\".\n\nEjemplo:\nDado $numbers = [1, 2, 4] y $k = 2, la función devolverá \"NO\".\nDado $numbers = [1, 2, 4] y $k = 3, la función devolverá \"YES\".",
      "arb": "يحدد ما إذا كان هناك على الأقل ترتيب واحد لإضافة '+' أو '-'\nقبل كل رقم في تسلسل بحيث يكون مجموع التسلسل قابلاً للقسمة\nعلى عدد معين k.\n\nتأخذ الدالة وسيطين:\n- $numbers: مصفوفة من الأعداد الصحيحة الموجبة تمثل التسلسل.\n- $k: عدد صحيح يمثل القاسم.\n\nتعيد الدالة \"YES\" إذا كان هناك على الأقل ترتيب واحد للتسلسل\nيمكن قسمته على $k، وإلا تعيد \"NO\".\n\nمثال:\nبالنظر إلى $numbers = [1, 2, 4] و $k = 2، ستعيد الدالة \"NO\".\nبالنظر إلى $numbers = [1, 2, 4] و $k = 3، ستعيد الدالة \"YES\".",
      "sw": "Inabainisha ikiwa kuna angalau mpangilio mmoja wa kuongeza '+' au '-'\nkabla ya kila nambari katika mlolongo ili jumla ya mlolongo huo iweze\nkugawanywa kwa nambari fulani $k.\n\nKazi inachukua hoja mbili:\n- $numbers: Safu ya nambari za mzima chanya zinazowakilisha mlolongo.\n- $k: Nambari ya mzima inayowakilisha mgawanyaji.\n\nKazi inarejesha \"YES\" ikiwa angalau mpangilio mmoja wa mlolongo\nunaweza kugawanywa kwa $k, vinginevyo inarejesha \"NO\".\n\nMfano:\nUkipatiwa $numbers = [1, 2, 4] na $k = 2, kazi itarejesha \"NO\".\nUkipatiwa $numbers = [1, 2, 4] na $k = 3, kazi itarejesha \"YES\".",
      "tr": "Belirli bir sayı dizisinin her bir sayısının önüne '+' veya '-' ekleyerek en az bir permütasyonunun toplamının verilen bir sayı k ile bölünebilir olup olmadığını belirler.\n\nFonksiyon iki argüman alır:\n- $numbers: Diziyi temsil eden pozitif tamsayıların bir dizisi.\n- $k: Böleni temsil eden bir tamsayı.\n\nFonksiyon, dizinin en az bir permütasyonunun $k ile bölünebilir olması durumunda \"YES\" döndürür, aksi takdirde \"NO\" döndürür.\n\nÖrnek:\n$numbers = [1, 2, 4] ve $k = 2 verildiğinde, fonksiyon \"NO\" döndürecektir.\n$numbers = [1, 2, 4] ve $k = 3 verildiğinde, fonksiyon \"YES\" döndürecektir.",
      "vi": "Xác định xem có tồn tại ít nhất một hoán vị của việc thêm '+' hoặc '-'\ntrước mỗi số trong một dãy số sao cho tổng của dãy số chia hết cho một số cho trước k.\n\nHàm nhận hai đối số:\n- $numbers: Một mảng các số nguyên dương đại diện cho dãy số.\n- $k: Một số nguyên đại diện cho số chia.\n\nHàm trả về \"YES\" nếu ít nhất một hoán vị của dãy số có thể chia hết cho $k, nếu không trả về \"NO\".\n\nVí dụ:\nCho $numbers = [1, 2, 4] và $k = 2, hàm sẽ trả về \"NO\".\nCho $numbers = [1, 2, 4] và $k = 3, hàm sẽ trả về \"YES\"."
    },
    "docstring_bertscore": {
      "es": "0.9944808562325645",
      "arb": "0.9664102121543332",
      "sw": "0.9560087336210602",
      "tr": "0.9488687659443801",
      "vi": "0.9870890252327322"
    }
  },
  {
    "task_id": "PHP/36",
    "prompt": {
      "en": "<?php\n\n\n/**\n * Evaluate a Polish expression and return the result.\n * In Polish notation, operators precede their operands. For example, the expression \"+ 11.0 12.0\" is equivalent to \"11.0 + 12.0\".\n * Supported operators are +, -, *, and /.\n * Input: A string containing a valid Polish expression separated by spaces.\n * Output: A float representing the result of evaluating the expression.\n * \n * Example:\n * - For the input \"+ 11.0 12.0\", the function should return 23.0.\n * - For the input \"* + 2.0 3.0 4.0\", the function should return 20.0.\n */\n\n\n function evaluatePolishExpression($expression) ",
      "es": "<?php\n\n\n/**\n * Evaluar una expresión polaca y devolver el resultado.\n * En notación polaca, los operadores preceden a sus operandos. Por ejemplo, la expresión \"+ 11.0 12.0\" es equivalente a \"11.0 + 12.0\".\n * Los operadores soportados son +, -, * y /.\n * Entrada: Una cadena que contiene una expresión polaca válida separada por espacios.\n * Salida: Un flotante que representa el resultado de evaluar la expresión.\n * \n * Ejemplo:\n * - Para la entrada \"+ 11.0 12.0\", la función debería devolver 23.0.\n * - Para la entrada \"* + 2.0 3.0 4.0\", la función debería devolver 20.0.\n */\n\n\n function evaluatePolishExpression($expression) ",
      "arb": "<?php\n\n\n/**\n * تقييم تعبير بولندي وإرجاع النتيجة.\n * في التدوين البولندي، تسبق العمليات الحسابية المعاملات. على سبيل المثال، التعبير \"+ 11.0 12.0\" يعادل \"11.0 + 12.0\".\n * العمليات المدعومة هي +، -، *، و /.\n * المدخل: سلسلة تحتوي على تعبير بولندي صالح مفصول بمسافات.\n * المخرج: عدد عشري يمثل نتيجة تقييم التعبير.\n * \n * مثال:\n * - بالنسبة للمدخل \"+ 11.0 12.0\"، يجب أن تعيد الدالة 23.0.\n * - بالنسبة للمدخل \"* + 2.0 3.0 4.0\"، يجب أن تعيد الدالة 20.0.\n */\n\n\n function evaluatePolishExpression($expression) ",
      "sw": "<?php\n\n\n/**\n * Tambua usemi wa Kipolandi na urejeshe matokeo.\n * Katika noti ya Kipolandi, waendeshaji hutangulia waendeshaji wao. Kwa mfano, usemi \"+ 11.0 12.0\" ni sawa na \"11.0 + 12.0\".\n * Waendeshaji wanaoungwa mkono ni +, -, *, na /.\n * Ingizo: Mstari wa maandishi unao na usemi sahihi wa Kipolandi uliotenganishwa na nafasi.\n * Tokeo: Nambari ya desimali inayowakilisha matokeo ya kutathmini usemi.\n * \n * Mfano:\n * - Kwa ingizo \"+ 11.0 12.0\", kazi inapaswa kurejesha 23.0.\n * - Kwa ingizo \"* + 2.0 3.0 4.0\", kazi inapaswa kurejesha 20.0.\n */\n\n\n function evaluatePolishExpression($expression) ",
      "tr": "<?php\n\n\n/**\n * Bir Polonya ifadesini değerlendir ve sonucu döndür.\n * Polonya gösteriminde, operatörler operatörlerin önünde yer alır. Örneğin, \"+ 11.0 12.0\" ifadesi \"11.0 + 12.0\" ile eşdeğerdir.\n * Desteklenen operatörler +, -, *, ve /'dir.\n * Girdi: Boşluklarla ayrılmış geçerli bir Polonya ifadesi içeren bir dize.\n * Çıktı: İfadenin değerlendirilmesinin sonucunu temsil eden bir float.\n * \n * Örnek:\n * - \"+ 11.0 12.0\" girişi için, fonksiyon 23.0 döndürmelidir.\n * - \"* + 2.0 3.0 4.0\" girişi için, fonksiyon 20.0 döndürmelidir.\n */\n\n\n function evaluatePolishExpression($expression) ",
      "vi": "<?php\n\n\n/**\n * Đánh giá một biểu thức Ba Lan và trả về kết quả.\n * Trong ký pháp Ba Lan, các toán tử đứng trước toán hạng của chúng. Ví dụ, biểu thức \"+ 11.0 12.0\" tương đương với \"11.0 + 12.0\".\n * Các toán tử được hỗ trợ là +, -, *, và /.\n * Đầu vào: Một chuỗi chứa một biểu thức Ba Lan hợp lệ được phân tách bằng dấu cách.\n * Đầu ra: Một số thực biểu diễn kết quả của việc đánh giá biểu thức.\n * \n * Ví dụ:\n * - Với đầu vào \"+ 11.0 12.0\", hàm sẽ trả về 23.0.\n * - Với đầu vào \"* + 2.0 3.0 4.0\", hàm sẽ trả về 20.0.\n */\n\n\n function evaluatePolishExpression($expression) "
    },
    "prompt_bertscore": {
      "es": "0.9944564246956973",
      "arb": "0.984924152709833",
      "sw": "0.9738207144099827",
      "tr": "0.999999801369619",
      "vi": "0.9715430198306557"
    },
    "canonical_solution": " {\n    $tokens = explode(' ', $expression);\n    $stack = new SplStack();\n\n    foreach (array_reverse($tokens) as $token) {\n        if (is_numeric($token)) {\n            $stack->push((float)$token);\n        } else {\n            $a = $stack->pop();\n            $b = $stack->pop();\n\n            switch ($token) {\n                case '+':\n                    $stack->push($a + $b);\n                    break;\n                case '-':\n                    $stack->push($a - $b);\n                    break;\n                case '*':\n                    $stack->push($a * $b);\n                    break;\n                case '/':\n                    $stack->push($a / $b);\n                    break;\n            }\n        }\n    }\n\n    return $stack->pop();\n}\n",
    "instruction": {
      "en": "function evaluatePolishExpression($expression)\n {\n    $tokens = explode(' ', $expression);\n    $stack = new SplStack();\n\n    foreach (array_reverse($tokens) as $token) {\n        if (is_numeric($token)) {\n            $stack->push((float)$token);\n        } else {\n            $a = $stack->pop();\n            $b = $stack->pop();\n\n            switch ($token) {\n                case '+':\n                    $stack->push($a + $b);\n                    break;\n                case '-':\n                    $stack->push($a - $b);\n                    break;\n                case '*':\n                    $stack->push($a * $b);\n                    break;\n                case '/':\n                    $stack->push($a / $b);\n                    break;\n            }\n        }\n    }\n\n    return $stack->pop();\n}\n\n\nProvide a concise natural language description (docstring) of the PHP code in English using at most 500 characters.",
      "es": "function evaluatePolishExpression($expression)\n {\n    $tokens = explode(' ', $expression);\n    $stack = new SplStack();\n\n    foreach (array_reverse($tokens) as $token) {\n        if (is_numeric($token)) {\n            $stack->push((float)$token);\n        } else {\n            $a = $stack->pop();\n            $b = $stack->pop();\n\n            switch ($token) {\n                case '+':\n                    $stack->push($a + $b);\n                    break;\n                case '-':\n                    $stack->push($a - $b);\n                    break;\n                case '*':\n                    $stack->push($a * $b);\n                    break;\n                case '/':\n                    $stack->push($a / $b);\n                    break;\n            }\n        }\n    }\n\n    return $stack->pop();\n}\n\n\nProporcione una descripción concisa en lenguaje natural (docstring) del código PHP en español utilizando un máximo de 500 caracteres.",
      "arb": "function evaluatePolishExpression($expression)\n {\n    $tokens = explode(' ', $expression);\n    $stack = new SplStack();\n\n    foreach (array_reverse($tokens) as $token) {\n        if (is_numeric($token)) {\n            $stack->push((float)$token);\n        } else {\n            $a = $stack->pop();\n            $b = $stack->pop();\n\n            switch ($token) {\n                case '+':\n                    $stack->push($a + $b);\n                    break;\n                case '-':\n                    $stack->push($a - $b);\n                    break;\n                case '*':\n                    $stack->push($a * $b);\n                    break;\n                case '/':\n                    $stack->push($a / $b);\n                    break;\n            }\n        }\n    }\n\n    return $stack->pop();\n}\n\n\nيرجى تقديم وصف موجز بلغة طبيعية (docstring) للشفرة البرمجية بلغة PHP باللغة العربية الفصحى باستخدام 500 حرف كحد أقصى.",
      "sw": "function evaluatePolishExpression($expression)\n {\n    $tokens = explode(' ', $expression);\n    $stack = new SplStack();\n\n    foreach (array_reverse($tokens) as $token) {\n        if (is_numeric($token)) {\n            $stack->push((float)$token);\n        } else {\n            $a = $stack->pop();\n            $b = $stack->pop();\n\n            switch ($token) {\n                case '+':\n                    $stack->push($a + $b);\n                    break;\n                case '-':\n                    $stack->push($a - $b);\n                    break;\n                case '*':\n                    $stack->push($a * $b);\n                    break;\n                case '/':\n                    $stack->push($a / $b);\n                    break;\n            }\n        }\n    }\n\n    return $stack->pop();\n}\n\n\nToa maelezo mafupi ya lugha asilia (docstring) ya msimbo wa PHP kwa Kiswahili kwa kutumia herufi zisizozidi 500.",
      "tr": "function evaluatePolishExpression($expression)\n {\n    $tokens = explode(' ', $expression);\n    $stack = new SplStack();\n\n    foreach (array_reverse($tokens) as $token) {\n        if (is_numeric($token)) {\n            $stack->push((float)$token);\n        } else {\n            $a = $stack->pop();\n            $b = $stack->pop();\n\n            switch ($token) {\n                case '+':\n                    $stack->push($a + $b);\n                    break;\n                case '-':\n                    $stack->push($a - $b);\n                    break;\n                case '*':\n                    $stack->push($a * $b);\n                    break;\n                case '/':\n                    $stack->push($a / $b);\n                    break;\n            }\n        }\n    }\n\n    return $stack->pop();\n}\n\n\nPHP kodunun işlevini açıklayan kısa bir doğal dil açıklaması (docstring) sağlayın. Açıklama, Türkçe olarak en fazla 500 karakter kullanılarak yazılmalıdır.",
      "vi": "function evaluatePolishExpression($expression)\n {\n    $tokens = explode(' ', $expression);\n    $stack = new SplStack();\n\n    foreach (array_reverse($tokens) as $token) {\n        if (is_numeric($token)) {\n            $stack->push((float)$token);\n        } else {\n            $a = $stack->pop();\n            $b = $stack->pop();\n\n            switch ($token) {\n                case '+':\n                    $stack->push($a + $b);\n                    break;\n                case '-':\n                    $stack->push($a - $b);\n                    break;\n                case '*':\n                    $stack->push($a * $b);\n                    break;\n                case '/':\n                    $stack->push($a / $b);\n                    break;\n            }\n        }\n    }\n\n    return $stack->pop();\n}\n\n\nCung cấp mô tả ngắn gọn bằng ngôn ngữ tự nhiên (docstring) cho mã PHP bằng tiếng Việt với tối đa 500 ký tự."
    },
    "instruction_bertscore": {
      "es": "0.9687069752502395",
      "arb": "0.924580242951434",
      "sw": "0.9428367585331127",
      "tr": "0.8711236430250386",
      "vi": "0.9017250367880356"
    },
    "level": "",
    "test": "function main(){\n    assert(evaluatePolishExpression(\"* + 11.0 12.0 + 24.0 35.0\") === 1357.0);\n    assert(evaluatePolishExpression(\"+ 2.0 2.0\") === 4.0);\n    assert(evaluatePolishExpression(\"- 10.0 5.0\") === 5.0);\n    // Testcase 1\n    $expression1 = \"+ 11.0 12.0\";\n    $result1 = evaluatePolishExpression($expression1);\n    assert($result1 === 23.0);\n\n    // Testcase 2\n    $expression2 = \"* + 2.0 3.0 4.0\";\n    $result2 = evaluatePolishExpression($expression2);\n    assert($result2 === 20.0);\n\n\n\n}\n\nmain();\n?>",
    "entry_point": "evaluatePolishExpression",
    "signature": "function evaluatePolishExpression($expression)",
    "docstring": {
      "en": "Evaluate a Polish expression and return the result.\nIn Polish notation, operators precede their operands. For example, the expression \"+ 11.0 12.0\" is equivalent to \"11.0 + 12.0\".\nSupported operators are +, -, *, and /.\nInput: A string containing a valid Polish expression separated by spaces.\nOutput: A float representing the result of evaluating the expression.\n\nExample:\n- For the input \"+ 11.0 12.0\", the function should return 23.0.\n- For the input \"* + 2.0 3.0 4.0\", the function should return 20.0.",
      "es": "Evaluar una expresión en notación polaca y devolver el resultado.  \nEn la notación polaca, los operadores preceden a sus operandos. Por ejemplo, la expresión \"+ 11.0 12.0\" es equivalente a \"11.0 + 12.0\".  \nLos operadores soportados son +, -, *, y /.  \nEntrada: Una cadena que contiene una expresión polaca válida separada por espacios.  \nSalida: Un flotante que representa el resultado de evaluar la expresión.  \n\nEjemplo:  \n- Para la entrada \"+ 11.0 12.0\", la función debería devolver 23.0.  \n- Para la entrada \"* + 2.0 3.0 4.0\", la función debería devolver 20.0.  ",
      "arb": "تقييم تعبير بولندي وإرجاع النتيجة.  \nفي التدوين البولندي، تسبق العوامل معاملاتها. على سبيل المثال، التعبير \"+ 11.0 12.0\" يعادل \"11.0 + 12.0\".  \nالعوامل المدعومة هي +، -، *، و /.  \nالمدخل: سلسلة تحتوي على تعبير بولندي صالح مفصول بمسافات.  \nالمخرج: عدد عشري يمثل نتيجة تقييم التعبير.\n\nمثال:  \n- بالنسبة للمدخل \"+ 11.0 12.0\"، يجب أن تُرجع الدالة 23.0.  \n- بالنسبة للمدخل \"* + 2.0 3.0 4.0\"، يجب أن تُرجع الدالة 20.0.",
      "sw": "Tathmini usemi wa Kipolandi na urejeshe matokeo.\nKatika noti ya Kipolandi, waendeshaji hutangulia wahusika wao. Kwa mfano, usemi \"+ 11.0 12.0\" ni sawa na \"11.0 + 12.0\".\nWaendeshaji wanaoungwa mkono ni +, -, *, na /.\nIngizo: Kamba iliyo na usemi halali wa Kipolandi uliotenganishwa na nafasi.\nPato: Nambari ya desimali inayowakilisha matokeo ya kutathmini usemi.\n\nMfano:\n- Kwa ingizo \"+ 11.0 12.0\", kazi inapaswa kurejesha 23.0.\n- Kwa ingizo \"* + 2.0 3.0 4.0\", kazi inapaswa kurejesha 20.0.",
      "tr": "Bir Polonya ifadesini değerlendir ve sonucu döndür.\nPolonya gösteriminde, operatörler operantlarının önünde yer alır. Örneğin, \"+ 11.0 12.0\" ifadesi \"11.0 + 12.0\" ile eşdeğerdir.\nDesteklenen operatörler +, -, *, ve /'dir.\nGirdi: Boşluklarla ayrılmış geçerli bir Polonya ifadesi içeren bir dize.\nÇıktı: İfadenin değerlendirilmesinin sonucunu temsil eden bir float.\n\nÖrnek:\n- Girdi \"+ 11.0 12.0\" için, fonksiyon 23.0 döndürmelidir.\n- Girdi \"* + 2.0 3.0 4.0\" için, fonksiyon 20.0 döndürmelidir.",
      "vi": "Đánh giá một biểu thức Ba Lan và trả về kết quả.  \nTrong ký hiệu Ba Lan, các toán tử đứng trước toán hạng của chúng. Ví dụ, biểu thức \"+ 11.0 12.0\" tương đương với \"11.0 + 12.0\".  \nCác toán tử được hỗ trợ là +, -, *, và /.  \nĐầu vào: Một chuỗi chứa một biểu thức Ba Lan hợp lệ được tách biệt bằng dấu cách.  \nĐầu ra: Một số thực đại diện cho kết quả của việc đánh giá biểu thức.  \n\nVí dụ:  \n- Với đầu vào \"+ 11.0 12.0\", hàm sẽ trả về 23.0.  \n- Với đầu vào \"* + 2.0 3.0 4.0\", hàm sẽ trả về 20.0.  "
    },
    "docstring_bertscore": {
      "es": "0.9812270454276306",
      "arb": "0.9818118132693974",
      "sw": "0.9702421894652582",
      "tr": "0.9841463161377004",
      "vi": "0.9736568443456289"
    }
  },
  {
    "task_id": "PHP/37",
    "prompt": {
      "en": "<?php\n/**\n * Question Description:\nYou are given a string consisting of distinct lowercase letters. Your task is to write a function generatePermutations that generates all possible permutations of the input string and returns them in lexicographical order.\n\nInput:\nA string consisting of distinct lowercase letters, where the length of the string is at most 6.\n\nOutput:\nAn array containing all permutations of the input string, sorted in lexicographical order.\n\nExample:\n    $permutations = generatePermutations(\"abc\");\n    $permutations should contain the following array:\n    [\"abc\", \"acb\", \"bac\", \"bca\", \"cab\", \"cba\"]\n */\n\n\n function generatePermutations($str) ",
      "es": "<?php\n/**\n * Descripción de la pregunta:\nSe te da una cadena que consiste en letras minúsculas distintas. Tu tarea es escribir una función generatePermutations que genere todas las permutaciones posibles de la cadena de entrada y las devuelva en orden lexicográfico.\n\nEntrada:\nUna cadena que consiste en letras minúsculas distintas, donde la longitud de la cadena es como máximo 6.\n\nSalida:\nUn arreglo que contiene todas las permutaciones de la cadena de entrada, ordenadas en orden lexicográfico.\n\nEjemplo:\n    $permutations = generatePermutations(\"abc\");\n    $permutations debería contener el siguiente arreglo:\n    [\"abc\", \"acb\", \"bac\", \"bca\", \"cab\", \"cba\"]\n */\n\n\n function generatePermutations($str) ",
      "arb": "<?php\n/**\n * وصف السؤال:\n لديك سلسلة تتكون من أحرف صغيرة مميزة. مهمتك هي كتابة دالة generatePermutations التي تولد جميع التباديل الممكنة للسلسلة المدخلة وتعيدها بترتيب معجمي.\n\n المدخل:\n سلسلة تتكون من أحرف صغيرة مميزة، حيث أن طول السلسلة لا يزيد عن 6.\n\n المخرج:\n مصفوفة تحتوي على جميع التباديل للسلسلة المدخلة، مرتبة بترتيب معجمي.\n\n مثال:\n    $permutations = generatePermutations(\"abc\");\n    $permutations يجب أن تحتوي على المصفوفة التالية:\n    [\"abc\", \"acb\", \"bac\", \"bca\", \"cab\", \"cba\"]\n */\n\n\n function generatePermutations($str) ",
      "sw": "<?php\n/**\n * Maelezo ya Swali:\nUnapewa kamba inayojumuisha herufi ndogo za kipekee. Kazi yako ni kuandika kazi generatePermutations ambayo inazalisha permutazioni zote zinazowezekana za kamba ya pembejeo na kuzirudisha katika mpangilio wa lexicographical.\n\nIngizo:\nKamba inayojumuisha herufi ndogo za kipekee, ambapo urefu wa kamba ni zaidi ya 6.\n\nPato:\nArray inayojumuisha permutazioni zote za kamba ya pembejeo, zilizopangwa katika mpangilio wa lexicographical.\n\nMfano:\n    $permutations = generatePermutations(\"abc\");\n    $permutations inapaswa kuwa na array ifuatayo:\n    [\"abc\", \"acb\", \"bac\", \"bca\", \"cab\", \"cba\"]\n */\n\n\n function generatePermutations($str) ",
      "tr": "<?php\n/**\n * Soru Açıklaması:\nElinizde birbirinden farklı küçük harflerden oluşan bir dize bulunmaktadır. Göreviniz, girdi dizisinin tüm olası permütasyonlarını üreten ve bunları sözlük sırasına göre döndüren bir generatePermutations fonksiyonu yazmaktır.\n\nGirdi:\nBirbirinden farklı küçük harflerden oluşan bir dize, dizenin uzunluğu en fazla 6'dır.\n\nÇıktı:\nGirdi dizisinin tüm permütasyonlarını içeren ve sözlük sırasına göre sıralanmış bir dizi.\n\nÖrnek:\n    $permutations = generatePermutations(\"abc\");\n    $permutations aşağıdaki diziyi içermelidir:\n    [\"abc\", \"acb\", \"bac\", \"bca\", \"cab\", \"cba\"]\n */\n\n\n function generatePermutations($str) ",
      "vi": "<?php\n/**\n * Mô tả câu hỏi:\nBạn được cung cấp một chuỗi gồm các chữ cái thường khác nhau. Nhiệm vụ của bạn là viết một hàm generatePermutations để tạo ra tất cả các hoán vị có thể của chuỗi đầu vào và trả về chúng theo thứ tự từ điển.\n\nĐầu vào:\nMột chuỗi gồm các chữ cái thường khác nhau, trong đó độ dài của chuỗi tối đa là 6.\n\nĐầu ra:\nMột mảng chứa tất cả các hoán vị của chuỗi đầu vào, được sắp xếp theo thứ tự từ điển.\n\nVí dụ:\n    $permutations = generatePermutations(\"abc\");\n    $permutations nên chứa mảng sau:\n    [\"abc\", \"acb\", \"bac\", \"bca\", \"cab\", \"cba\"]\n */\n\n\n function generatePermutations($str) "
    },
    "prompt_bertscore": {
      "es": "0.9942975203908694",
      "arb": "0.9740417900240746",
      "sw": "0.9846069399913203",
      "tr": "0.9728555693885342",
      "vi": "0.9818878887053337"
    },
    "canonical_solution": " {\n    // Base case: if the string is empty, return an empty array\n    if (strlen($str) == 0) {\n        return [];\n    }\n\n    // If the string has only one character, return an array with that character\n    if (strlen($str) == 1) {\n        return [$str];\n    }\n\n    $permutations = [];\n\n    // Iterate through each character in the string\n    for ($i = 0; $i < strlen($str); $i++) {\n        // Remove the character at index $i\n        $char = $str[$i];\n        $remaining = substr($str, 0, $i) . substr($str, $i + 1);\n\n        // Generate permutations of the remaining string\n        $remainingPermutations = generatePermutations($remaining);\n\n        // Prepend the removed character to each permutation\n        foreach ($remainingPermutations as $perm) {\n            $permutations[] = $char . $perm;\n        }\n    }\n\n    // Sort the permutations in lexicographical order\n    sort($permutations);\n\n\n    return $permutations;\n}",
    "instruction": {
      "en": "function generatePermutations($str)\n {\n    // Base case: if the string is empty, return an empty array\n    if (strlen($str) == 0) {\n        return [];\n    }\n\n    // If the string has only one character, return an array with that character\n    if (strlen($str) == 1) {\n        return [$str];\n    }\n\n    $permutations = [];\n\n    // Iterate through each character in the string\n    for ($i = 0; $i < strlen($str); $i++) {\n        // Remove the character at index $i\n        $char = $str[$i];\n        $remaining = substr($str, 0, $i) . substr($str, $i + 1);\n\n        // Generate permutations of the remaining string\n        $remainingPermutations = generatePermutations($remaining);\n\n        // Prepend the removed character to each permutation\n        foreach ($remainingPermutations as $perm) {\n            $permutations[] = $char . $perm;\n        }\n    }\n\n    // Sort the permutations in lexicographical order\n    sort($permutations);\n\n\n    return $permutations;\n}\n\nProvide a concise natural language description (docstring) of the PHP code in English using at most 500 characters.",
      "es": "function generatePermutations($str)\n {\n    // Base case: if the string is empty, return an empty array\n    if (strlen($str) == 0) {\n        return [];\n    }\n\n    // If the string has only one character, return an array with that character\n    if (strlen($str) == 1) {\n        return [$str];\n    }\n\n    $permutations = [];\n\n    // Iterate through each character in the string\n    for ($i = 0; $i < strlen($str); $i++) {\n        // Remove the character at index $i\n        $char = $str[$i];\n        $remaining = substr($str, 0, $i) . substr($str, $i + 1);\n\n        // Generate permutations of the remaining string\n        $remainingPermutations = generatePermutations($remaining);\n\n        // Prepend the removed character to each permutation\n        foreach ($remainingPermutations as $perm) {\n            $permutations[] = $char . $perm;\n        }\n    }\n\n    // Sort the permutations in lexicographical order\n    sort($permutations);\n\n\n    return $permutations;\n}\n\nProporcione una descripción concisa en lenguaje natural (docstring) del código PHP en español utilizando un máximo de 500 caracteres.",
      "arb": "function generatePermutations($str)\n {\n    // Base case: if the string is empty, return an empty array\n    if (strlen($str) == 0) {\n        return [];\n    }\n\n    // If the string has only one character, return an array with that character\n    if (strlen($str) == 1) {\n        return [$str];\n    }\n\n    $permutations = [];\n\n    // Iterate through each character in the string\n    for ($i = 0; $i < strlen($str); $i++) {\n        // Remove the character at index $i\n        $char = $str[$i];\n        $remaining = substr($str, 0, $i) . substr($str, $i + 1);\n\n        // Generate permutations of the remaining string\n        $remainingPermutations = generatePermutations($remaining);\n\n        // Prepend the removed character to each permutation\n        foreach ($remainingPermutations as $perm) {\n            $permutations[] = $char . $perm;\n        }\n    }\n\n    // Sort the permutations in lexicographical order\n    sort($permutations);\n\n\n    return $permutations;\n}\n\nيرجى تقديم وصف موجز بلغة طبيعية (docstring) للكود المكتوب بلغة PHP باللغة العربية الفصحى، بحيث لا يتجاوز 500 حرف.",
      "sw": "function generatePermutations($str)\n {\n    // Base case: if the string is empty, return an empty array\n    if (strlen($str) == 0) {\n        return [];\n    }\n\n    // If the string has only one character, return an array with that character\n    if (strlen($str) == 1) {\n        return [$str];\n    }\n\n    $permutations = [];\n\n    // Iterate through each character in the string\n    for ($i = 0; $i < strlen($str); $i++) {\n        // Remove the character at index $i\n        $char = $str[$i];\n        $remaining = substr($str, 0, $i) . substr($str, $i + 1);\n\n        // Generate permutations of the remaining string\n        $remainingPermutations = generatePermutations($remaining);\n\n        // Prepend the removed character to each permutation\n        foreach ($remainingPermutations as $perm) {\n            $permutations[] = $char . $perm;\n        }\n    }\n\n    // Sort the permutations in lexicographical order\n    sort($permutations);\n\n\n    return $permutations;\n}\n\nToa maelezo mafupi ya lugha asilia (docstring) ya msimbo wa PHP kwa Kiswahili kwa kutumia herufi zisizozidi 500.",
      "tr": "function generatePermutations($str)\n {\n    // Base case: if the string is empty, return an empty array\n    if (strlen($str) == 0) {\n        return [];\n    }\n\n    // If the string has only one character, return an array with that character\n    if (strlen($str) == 1) {\n        return [$str];\n    }\n\n    $permutations = [];\n\n    // Iterate through each character in the string\n    for ($i = 0; $i < strlen($str); $i++) {\n        // Remove the character at index $i\n        $char = $str[$i];\n        $remaining = substr($str, 0, $i) . substr($str, $i + 1);\n\n        // Generate permutations of the remaining string\n        $remainingPermutations = generatePermutations($remaining);\n\n        // Prepend the removed character to each permutation\n        foreach ($remainingPermutations as $perm) {\n            $permutations[] = $char . $perm;\n        }\n    }\n\n    // Sort the permutations in lexicographical order\n    sort($permutations);\n\n\n    return $permutations;\n}\n\nPHP kodunun işlevini açıklayan kısa bir doğal dil açıklaması (docstring) sağlayın. Açıklama, en fazla 500 karakter kullanarak Türkçe olarak yazılmalıdır.",
      "vi": "function generatePermutations($str)\n {\n    // Base case: if the string is empty, return an empty array\n    if (strlen($str) == 0) {\n        return [];\n    }\n\n    // If the string has only one character, return an array with that character\n    if (strlen($str) == 1) {\n        return [$str];\n    }\n\n    $permutations = [];\n\n    // Iterate through each character in the string\n    for ($i = 0; $i < strlen($str); $i++) {\n        // Remove the character at index $i\n        $char = $str[$i];\n        $remaining = substr($str, 0, $i) . substr($str, $i + 1);\n\n        // Generate permutations of the remaining string\n        $remainingPermutations = generatePermutations($remaining);\n\n        // Prepend the removed character to each permutation\n        foreach ($remainingPermutations as $perm) {\n            $permutations[] = $char . $perm;\n        }\n    }\n\n    // Sort the permutations in lexicographical order\n    sort($permutations);\n\n\n    return $permutations;\n}\n\nCung cấp mô tả ngắn gọn bằng ngôn ngữ tự nhiên (docstring) cho mã PHP bằng tiếng Việt, sử dụng tối đa 500 ký tự."
    },
    "instruction_bertscore": {
      "es": "0.9687069752502395",
      "arb": "0.8833251100712498",
      "sw": "0.9428367585331127",
      "tr": "0.8734100773411313",
      "vi": "0.9202302376067699"
    },
    "level": "",
    "test": "function main(){\n    $permutations = generatePermutations(\"abc\");\n    assert($permutations === [\"abc\", \"acb\", \"bac\", \"bca\", \"cab\", \"cba\"]);\n    $permutations = generatePermutations(\"abcd\");\n    assert($permutations === [\"abcd\",\"abdc\",\"acbd\",\"acdb\",\"adbc\",\"adcb\",\"bacd\",\"badc\",\"bcad\",\"bcda\",\"bdac\",\"bdca\",\"cabd\",\"cadb\",\"cbad\",\"cbda\",\"cdab\",\"cdba\",\"dabc\",\"dacb\",\"dbac\",\"dbca\",\"dcab\",\"dcba\"]);\n\n}\n\n\nmain();\n?>",
    "entry_point": "generatePermutations",
    "signature": "function generatePermutations($str)",
    "docstring": {
      "en": "Question Description:\nYou are given a string consisting of distinct lowercase letters. Your task is to write a function generatePermutations that generates all possible permutations of the input string and returns them in lexicographical order.\n\nInput:\nA string consisting of distinct lowercase letters, where the length of the string is at most 6.\n\nOutput:\nAn array containing all permutations of the input string, sorted in lexicographical order.\n\nExample:\n$permutations = generatePermutations(\"abc\");\n$permutations should contain the following array:\n[\"abc\", \"acb\", \"bac\", \"bca\", \"cab\", \"cba\"]",
      "es": "Descripción de la pregunta:\nSe te da una cadena que consiste en letras minúsculas distintas. Tu tarea es escribir una función generatePermutations que genere todas las posibles permutaciones de la cadena de entrada y las devuelva en orden lexicográfico.\n\nEntrada:\nUna cadena que consiste en letras minúsculas distintas, donde la longitud de la cadena es como máximo 6.\n\nSalida:\nUn arreglo que contiene todas las permutaciones de la cadena de entrada, ordenadas en orden lexicográfico.\n\nEjemplo:\n$permutations = generatePermutations(\"abc\");\n$permutations debería contener el siguiente arreglo:\n[\"abc\", \"acb\", \"bac\", \"bca\", \"cab\", \"cba\"]",
      "arb": "وصف السؤال:\nأنت لديك سلسلة تتكون من أحرف صغيرة مميزة. مهمتك هي كتابة دالة generatePermutations التي تولد جميع التباديل الممكنة للسلسلة المدخلة وتعيدها بترتيب معجمي.\n\nالمدخل:\nسلسلة تتكون من أحرف صغيرة مميزة، حيث أن طول السلسلة لا يزيد عن 6.\n\nالمخرج:\nمصفوفة تحتوي على جميع التباديل للسلسلة المدخلة، مرتبة بترتيب معجمي.\n\nمثال:\n$permutations = generatePermutations(\"abc\");\nيجب أن تحتوي $permutations على المصفوفة التالية:\n[\"abc\", \"acb\", \"bac\", \"bca\", \"cab\", \"cba\"]",
      "sw": "Maelezo ya Swali:\nUmepewa kamba inayojumuisha herufi ndogo za kipekee. Kazi yako ni kuandika kazi generatePermutations ambayo inazalisha mchanganyiko wote wa kamba ya pembejeo na kuyarudisha kwa mpangilio wa herufi.\n\nIngizo:\nKamba inayojumuisha herufi ndogo za kipekee, ambapo urefu wa kamba ni zaidi ya 6.\n\nPato:\nArray inayojumuisha mchanganyiko yote ya kamba ya pembejeo, iliyopangwa kwa mpangilio wa herufi.\n\nMfano:\n$permutations = generatePermutations(\"abc\");\n$permutations inapaswa kuwa na array ifuatayo:\n[\"abc\", \"acb\", \"bac\", \"bca\", \"cab\", \"cba\"]",
      "tr": "Soru Açıklaması:\nSize, farklı küçük harflerden oluşan bir dize verilmektedir. Göreviniz, girdi dizisinin tüm olası permütasyonlarını üreten ve bunları sözlük sırasına göre döndüren generatePermutations adlı bir fonksiyon yazmaktır.\n\nGirdi:\nDizinin uzunluğunun en fazla 6 olduğu, farklı küçük harflerden oluşan bir dize.\n\nÇıktı:\nGirdi dizisinin tüm permütasyonlarını içeren ve sözlük sırasına göre sıralanmış bir dizi.\n\nÖrnek:\n$permutations = generatePermutations(\"abc\");\n$permutations aşağıdaki diziyi içermelidir:\n[\"abc\", \"acb\", \"bac\", \"bca\", \"cab\", \"cba\"]",
      "vi": "Mô tả Câu hỏi:\nBạn được cung cấp một chuỗi bao gồm các chữ cái thường khác nhau. Nhiệm vụ của bạn là viết một hàm generatePermutations để tạo ra tất cả các hoán vị có thể của chuỗi đầu vào và trả về chúng theo thứ tự từ điển.\n\nĐầu vào:\nMột chuỗi bao gồm các chữ cái thường khác nhau, trong đó độ dài của chuỗi tối đa là 6.\n\nĐầu ra:\nMột mảng chứa tất cả các hoán vị của chuỗi đầu vào, được sắp xếp theo thứ tự từ điển.\n\nVí dụ:\n$permutations = generatePermutations(\"abc\");\n$permutations nên chứa mảng sau:\n[\"abc\", \"acb\", \"bac\", \"bca\", \"cab\", \"cba\"]"
    },
    "docstring_bertscore": {
      "es": "0.9795160433253961",
      "arb": "0.9649200870358094",
      "sw": "0.9348250021140704",
      "tr": "0.9698256615562281",
      "vi": "0.8128393316875904"
    }
  },
  {
    "task_id": "PHP/38",
    "prompt": {
      "en": "<?php\n\n/**\n * Question:\n * You have M identical apples that need to be placed into N identical plates. You are allowed\n * to have some plates empty. How many different ways are there to distribute the apples into the plates?\n * 5,1,1 and 1,5,1 are the same division method.\n *\n * Example:\n * - Input: M = 7, N = 3\n * - Output: 8\n\n */\n\n function countDistributionMethods($M, $N) ",
      "es": "<?php\n\n/**\n * Pregunta:\n * Tienes M manzanas idénticas que deben colocarse en N platos idénticos. Se permite\n * tener algunos platos vacíos. ¿De cuántas maneras diferentes se pueden distribuir las manzanas en los platos?\n * 5,1,1 y 1,5,1 son el mismo método de división.\n *\n * Ejemplo:\n * - Entrada: M = 7, N = 3\n * - Salida: 8\n *\n */\n\n function countDistributionMethods($M, $N) ",
      "arb": "<?php\n\n/**\n * سؤال:\n * لديك M من التفاح المتطابق الذي يجب وضعه في N من الأطباق المتطابقة. يُسمح لك\n * بترك بعض الأطباق فارغة. كم عدد الطرق المختلفة لتوزيع التفاح في الأطباق؟\n * 5,1,1 و 1,5,1 هما نفس طريقة التقسيم.\n *\n * مثال:\n * - المدخلات: M = 7, N = 3\n * - المخرجات: 8\n\n */\n\n function countDistributionMethods($M, $N) ",
      "sw": "<?php\n\n/**\n * Swali:\n * Una maapulo M yanayofanana ambayo yanahitaji kuwekwa kwenye sahani N zinazofanana. Unaruhusiwa\n * kuwa na baadhi ya sahani tupu. Kuna njia ngapi tofauti za kugawa maapulo kwenye sahani?\n * 5,1,1 na 1,5,1 ni njia sawa ya kugawa.\n *\n * Mfano:\n * - Ingizo: M = 7, N = 3\n * - Matokeo: 8\n */\n\n function countDistributionMethods($M, $N) ",
      "tr": "<?php\n\n/**\n * Soru:\n * M tane aynı elmayı N tane aynı tabağa yerleştirmeniz gerekiyor. Bazı tabakların boş olmasına izin verilir.\n * Elmaların tabaklara dağıtılmasının kaç farklı yolu vardır?\n * 5,1,1 ve 1,5,1 aynı bölme yöntemidir.\n *\n * Örnek:\n * - Girdi: M = 7, N = 3\n * - Çıktı: 8\n */\n\n function countDistributionMethods($M, $N) ",
      "vi": "<?php\n\n/**\n * Câu hỏi:\n * Bạn có M quả táo giống hệt nhau cần được đặt vào N đĩa giống hệt nhau. Bạn được phép\n * để một số đĩa trống. Có bao nhiêu cách khác nhau để phân phối táo vào các đĩa?\n * 5,1,1 và 1,5,1 là cùng một phương pháp phân chia.\n *\n * Ví dụ:\n * - Đầu vào: M = 7, N = 3\n * - Đầu ra: 8\n\n */\n\n function countDistributionMethods($M, $N) "
    },
    "prompt_bertscore": {
      "es": "0.9680630155549245",
      "arb": "0.9815204225004192",
      "sw": "0.97263787049092",
      "tr": "0.9612003358901691",
      "vi": "0.9830321983304757"
    },
    "canonical_solution": " {\n    // Initialize a 2D array to store the number of ways to distribute M apples into N plates\n    $dp = array_fill(0, $M + 1, array_fill(0, $N + 1, 0));\n\n    // There is one way to distribute 0 apples into any number of plates\n    for ($i = 0; $i <= $N; $i++) {\n        $dp[0][$i] = 1;\n    }\n\n    // Fill the dp array\n    for ($i = 1; $i <= $M; $i++) {\n        for ($j = 1; $j <= $N; $j++) {\n            // If the number of apples is less than the number of plates,\n            // the number of ways is the same as the number of ways to distribute i apples into j - 1 plates\n            if ($i < $j) {\n                $dp[$i][$j] = $dp[$i][$j - 1];\n            } else {\n                // Otherwise, the number of ways is the sum of the number of ways to distribute i apples into j - 1 plates\n                // and the number of ways to distribute i - j apples into j plates\n                $dp[$i][$j] = $dp[$i][$j - 1] + $dp[$i - $j][$j];\n            }\n        }\n    }\n\n    // The number of ways to distribute M apples into N plates is stored in dp[M][N]\n    return $dp[$M][$N];\n}\n",
    "instruction": {
      "en": "function countDistributionMethods($M, $N)\n {\n    // Initialize a 2D array to store the number of ways to distribute M apples into N plates\n    $dp = array_fill(0, $M + 1, array_fill(0, $N + 1, 0));\n\n    // There is one way to distribute 0 apples into any number of plates\n    for ($i = 0; $i <= $N; $i++) {\n        $dp[0][$i] = 1;\n    }\n\n    // Fill the dp array\n    for ($i = 1; $i <= $M; $i++) {\n        for ($j = 1; $j <= $N; $j++) {\n            // If the number of apples is less than the number of plates,\n            // the number of ways is the same as the number of ways to distribute i apples into j - 1 plates\n            if ($i < $j) {\n                $dp[$i][$j] = $dp[$i][$j - 1];\n            } else {\n                // Otherwise, the number of ways is the sum of the number of ways to distribute i apples into j - 1 plates\n                // and the number of ways to distribute i - j apples into j plates\n                $dp[$i][$j] = $dp[$i][$j - 1] + $dp[$i - $j][$j];\n            }\n        }\n    }\n\n    // The number of ways to distribute M apples into N plates is stored in dp[M][N]\n    return $dp[$M][$N];\n}\n\n\nProvide a concise natural language description (docstring) of the PHP code in English using at most 500 characters.",
      "es": "function countDistributionMethods($M, $N)\n {\n    // Initialize a 2D array to store the number of ways to distribute M apples into N plates\n    $dp = array_fill(0, $M + 1, array_fill(0, $N + 1, 0));\n\n    // There is one way to distribute 0 apples into any number of plates\n    for ($i = 0; $i <= $N; $i++) {\n        $dp[0][$i] = 1;\n    }\n\n    // Fill the dp array\n    for ($i = 1; $i <= $M; $i++) {\n        for ($j = 1; $j <= $N; $j++) {\n            // If the number of apples is less than the number of plates,\n            // the number of ways is the same as the number of ways to distribute i apples into j - 1 plates\n            if ($i < $j) {\n                $dp[$i][$j] = $dp[$i][$j - 1];\n            } else {\n                // Otherwise, the number of ways is the sum of the number of ways to distribute i apples into j - 1 plates\n                // and the number of ways to distribute i - j apples into j plates\n                $dp[$i][$j] = $dp[$i][$j - 1] + $dp[$i - $j][$j];\n            }\n        }\n    }\n\n    // The number of ways to distribute M apples into N plates is stored in dp[M][N]\n    return $dp[$M][$N];\n}\n\n\nProporcione una descripción concisa en lenguaje natural (docstring) del código PHP en español utilizando un máximo de 500 caracteres.",
      "arb": "function countDistributionMethods($M, $N)\n {\n    // Initialize a 2D array to store the number of ways to distribute M apples into N plates\n    $dp = array_fill(0, $M + 1, array_fill(0, $N + 1, 0));\n\n    // There is one way to distribute 0 apples into any number of plates\n    for ($i = 0; $i <= $N; $i++) {\n        $dp[0][$i] = 1;\n    }\n\n    // Fill the dp array\n    for ($i = 1; $i <= $M; $i++) {\n        for ($j = 1; $j <= $N; $j++) {\n            // If the number of apples is less than the number of plates,\n            // the number of ways is the same as the number of ways to distribute i apples into j - 1 plates\n            if ($i < $j) {\n                $dp[$i][$j] = $dp[$i][$j - 1];\n            } else {\n                // Otherwise, the number of ways is the sum of the number of ways to distribute i apples into j - 1 plates\n                // and the number of ways to distribute i - j apples into j plates\n                $dp[$i][$j] = $dp[$i][$j - 1] + $dp[$i - $j][$j];\n            }\n        }\n    }\n\n    // The number of ways to distribute M apples into N plates is stored in dp[M][N]\n    return $dp[$M][$N];\n}\n\n\nيرجى تقديم وصف موجز بلغة طبيعية (docstring) للكود البرمجي بلغة PHP باللغة العربية الفصحى، بحيث لا يتجاوز 500 حرف.",
      "sw": "function countDistributionMethods($M, $N)\n {\n    // Initialize a 2D array to store the number of ways to distribute M apples into N plates\n    $dp = array_fill(0, $M + 1, array_fill(0, $N + 1, 0));\n\n    // There is one way to distribute 0 apples into any number of plates\n    for ($i = 0; $i <= $N; $i++) {\n        $dp[0][$i] = 1;\n    }\n\n    // Fill the dp array\n    for ($i = 1; $i <= $M; $i++) {\n        for ($j = 1; $j <= $N; $j++) {\n            // If the number of apples is less than the number of plates,\n            // the number of ways is the same as the number of ways to distribute i apples into j - 1 plates\n            if ($i < $j) {\n                $dp[$i][$j] = $dp[$i][$j - 1];\n            } else {\n                // Otherwise, the number of ways is the sum of the number of ways to distribute i apples into j - 1 plates\n                // and the number of ways to distribute i - j apples into j plates\n                $dp[$i][$j] = $dp[$i][$j - 1] + $dp[$i - $j][$j];\n            }\n        }\n    }\n\n    // The number of ways to distribute M apples into N plates is stored in dp[M][N]\n    return $dp[$M][$N];\n}\n\n\nToa maelezo mafupi ya lugha asilia (docstring) ya msimbo wa PHP kwa Kiswahili kwa kutumia herufi zisizozidi 500.",
      "tr": "function countDistributionMethods($M, $N)\n {\n    // Initialize a 2D array to store the number of ways to distribute M apples into N plates\n    $dp = array_fill(0, $M + 1, array_fill(0, $N + 1, 0));\n\n    // There is one way to distribute 0 apples into any number of plates\n    for ($i = 0; $i <= $N; $i++) {\n        $dp[0][$i] = 1;\n    }\n\n    // Fill the dp array\n    for ($i = 1; $i <= $M; $i++) {\n        for ($j = 1; $j <= $N; $j++) {\n            // If the number of apples is less than the number of plates,\n            // the number of ways is the same as the number of ways to distribute i apples into j - 1 plates\n            if ($i < $j) {\n                $dp[$i][$j] = $dp[$i][$j - 1];\n            } else {\n                // Otherwise, the number of ways is the sum of the number of ways to distribute i apples into j - 1 plates\n                // and the number of ways to distribute i - j apples into j plates\n                $dp[$i][$j] = $dp[$i][$j - 1] + $dp[$i - $j][$j];\n            }\n        }\n    }\n\n    // The number of ways to distribute M apples into N plates is stored in dp[M][N]\n    return $dp[$M][$N];\n}\n\n\nPHP kodunun işlevini açıklayan kısa bir doğal dil açıklaması (docstring) sağlayın. Açıklama, en fazla 500 karakter kullanarak Türkçe yazılmalıdır.",
      "vi": "function countDistributionMethods($M, $N)\n {\n    // Initialize a 2D array to store the number of ways to distribute M apples into N plates\n    $dp = array_fill(0, $M + 1, array_fill(0, $N + 1, 0));\n\n    // There is one way to distribute 0 apples into any number of plates\n    for ($i = 0; $i <= $N; $i++) {\n        $dp[0][$i] = 1;\n    }\n\n    // Fill the dp array\n    for ($i = 1; $i <= $M; $i++) {\n        for ($j = 1; $j <= $N; $j++) {\n            // If the number of apples is less than the number of plates,\n            // the number of ways is the same as the number of ways to distribute i apples into j - 1 plates\n            if ($i < $j) {\n                $dp[$i][$j] = $dp[$i][$j - 1];\n            } else {\n                // Otherwise, the number of ways is the sum of the number of ways to distribute i apples into j - 1 plates\n                // and the number of ways to distribute i - j apples into j plates\n                $dp[$i][$j] = $dp[$i][$j - 1] + $dp[$i - $j][$j];\n            }\n        }\n    }\n\n    // The number of ways to distribute M apples into N plates is stored in dp[M][N]\n    return $dp[$M][$N];\n}\n\n\nCung cấp mô tả ngắn gọn bằng ngôn ngữ tự nhiên (docstring) cho mã PHP bằng tiếng Việt, sử dụng tối đa 500 ký tự."
    },
    "instruction_bertscore": {
      "es": "0.9687069752502395",
      "arb": "0.905616007322128",
      "sw": "0.9428367585331127",
      "tr": "0.881863190466833",
      "vi": "0.9202302376067699"
    },
    "level": "",
    "test": "function main(){\n    // Test cases\n    assert(countDistributionMethods(7, 3) === 8);\n    assert(countDistributionMethods(5, 2) === 3);\n    assert(countDistributionMethods(10, 5) === 30);\n\n}\n\n\nmain();\n?>",
    "entry_point": "countDistributionMethods",
    "signature": "function countDistributionMethods($M, $N)",
    "docstring": {
      "en": "Question:\nYou have M identical apples that need to be placed into N identical plates. You are allowed\nto have some plates empty. How many different ways are there to distribute the apples into the plates?\n5,1,1 and 1,5,1 are the same division method.\n\nExample:\n- Input: M = 7, N = 3\n- Output: 8",
      "es": "Pregunta:\nTienes M manzanas idénticas que deben colocarse en N platos idénticos. Se permite tener algunos platos vacíos. ¿Cuántas formas diferentes hay de distribuir las manzanas en los platos?\n5,1,1 y 1,5,1 son el mismo método de división.\n\nEjemplo:\n- Entrada: M = 7, N = 3\n- Salida: 8",
      "arb": "سؤال:\nلديك M من التفاح المتطابق الذي يجب وضعه في N من الأطباق المتطابقة. يُسمح لك بترك بعض الأطباق فارغة. كم عدد الطرق المختلفة لتوزيع التفاح في الأطباق؟\n5,1,1 و 1,5,1 هما نفس طريقة التقسيم.\n\nمثال:\n- المدخلات: M = 7, N = 3\n- المخرجات: 8",
      "sw": "Swali:\nUna maapulo M yanayofanana ambayo yanahitaji kuwekwa kwenye sahani N zinazofanana. Unaruhusiwa kuwa na baadhi ya sahani zikiwa tupu. Kuna njia ngapi tofauti za kugawa maapulo kwenye sahani?\n5,1,1 na 1,5,1 ni njia sawa ya kugawa.\n\nMfano:\n- Ingizo: M = 7, N = 3\n- Matokeo: 8",
      "tr": "Soru:\nM adet özdeş elmanız var ve bunlar N adet özdeş tabağa yerleştirilmeli. Bazı tabakların boş kalmasına izin veriliyor. Elmaların tabaklara dağıtılmasının kaç farklı yolu vardır?\n5,1,1 ve 1,5,1 aynı bölme yöntemidir.\n\nÖrnek:\n- Girdi: M = 7, N = 3\n- Çıktı: 8",
      "vi": "Câu hỏi:  \nBạn có M quả táo giống hệt nhau cần được đặt vào N đĩa giống hệt nhau. Bạn được phép để một số đĩa trống. Có bao nhiêu cách khác nhau để phân phối táo vào các đĩa?  \n5,1,1 và 1,5,1 là cùng một phương pháp phân chia.\n\nVí dụ:  \n- Đầu vào: M = 7, N = 3  \n- Đầu ra: 8"
    },
    "docstring_bertscore": {
      "es": "0.9832091779999778",
      "arb": "0.9725737128778458",
      "sw": "0.9591629840718943",
      "tr": "0.9722145891489347",
      "vi": "0.9787018573935341"
    }
  },
  {
    "task_id": "PHP/39",
    "prompt": {
      "en": "<?php\n\n/**\n * Generates all possible ways to express a natural number as the sum of smaller natural numbers.\n * For example, when n=7, there are 14 different ways to express it as the sum of smaller natural numbers.\n * This function returns all these expressions in lexicographical (dictionary) order.\n * below is output when n = 7\n *  7=1+1+1+1+1+1+1\n    7=1+1+1+1+1+2\n    7=1+1+1+1+3\n    7=1+1+1+2+2\n    7=1+1+1+4\n    7=1+1+2+3\n    7=1+1+5\n    7=1+2+2+2\n    7=1+2+4\n    7=1+3+3\n    7=1+6\n    7=2+2+3\n    7=2+5\n    7=3+4\n * @param int $n The input natural number (greater than 1).\n * @return array An array of strings representing all possible expressions.\n */\n\n function generateNumberExpressions($n) ",
      "es": "<?php\n\n/**\n * Genera todas las formas posibles de expresar un número natural como la suma de números naturales más pequeños.\n * Por ejemplo, cuando n=7, hay 14 formas diferentes de expresarlo como la suma de números naturales más pequeños.\n * Esta función devuelve todas estas expresiones en orden lexicográfico (de diccionario).\n * abajo está el resultado cuando n = 7\n *  7=1+1+1+1+1+1+1\n    7=1+1+1+1+1+2\n    7=1+1+1+1+3\n    7=1+1+1+2+2\n    7=1+1+1+4\n    7=1+1+2+3\n    7=1+1+5\n    7=1+2+2+2\n    7=1+2+4\n    7=1+3+3\n    7=1+6\n    7=2+2+3\n    7=2+5\n    7=3+4\n * @param int $n El número natural de entrada (mayor que 1).\n * @return array Un arreglo de cadenas que representa todas las posibles expresiones.\n */\n\n function generateNumberExpressions($n) ",
      "arb": "<?php\n\n/**\n * يولد جميع الطرق الممكنة للتعبير عن عدد طبيعي كمجموع لأعداد طبيعية أصغر.\n * على سبيل المثال، عندما n=7، هناك 14 طريقة مختلفة للتعبير عنه كمجموع لأعداد طبيعية أصغر.\n * تقوم هذه الدالة بإرجاع جميع هذه التعبيرات بترتيب معجمي (قاموسي).\n * أدناه هو المخرج عندما n = 7\n *  7=1+1+1+1+1+1+1\n    7=1+1+1+1+1+2\n    7=1+1+1+1+3\n    7=1+1+1+2+2\n    7=1+1+1+4\n    7=1+1+2+3\n    7=1+1+5\n    7=1+2+2+2\n    7=1+2+4\n    7=1+3+3\n    7=1+6\n    7=2+2+3\n    7=2+5\n    7=3+4\n * @param int $n العدد الطبيعي المدخل (أكبر من 1).\n * @return array مصفوفة من السلاسل النصية تمثل جميع التعبيرات الممكنة.\n */\n\n function generateNumberExpressions($n) ",
      "sw": "<?php\n\n/**\n * Hutengeneza njia zote zinazowezekana za kuelezea nambari ya asili kama jumla ya nambari ndogo za asili.\n * Kwa mfano, wakati n=7, kuna njia 14 tofauti za kuielezea kama jumla ya nambari ndogo za asili.\n * Kazi hii inarudisha maelezo haya yote katika mpangilio wa lexicographical (kamusi).\n * hapa chini ni matokeo wakati n = 7\n *  7=1+1+1+1+1+1+1\n    7=1+1+1+1+1+2\n    7=1+1+1+1+3\n    7=1+1+1+2+2\n    7=1+1+1+4\n    7=1+1+2+3\n    7=1+1+5\n    7=1+2+2+2\n    7=1+2+4\n    7=1+3+3\n    7=1+6\n    7=2+2+3\n    7=2+5\n    7=3+4\n * @param int $n Nambari ya asili ya ingizo (kubwa kuliko 1).\n * @return array Mfululizo wa maandishi yanayowakilisha maelezo yote yanayowezekana.\n */\n\n function generateNumberExpressions($n) ",
      "tr": "<?php\n\n/**\n * Bir doğal sayıyı daha küçük doğal sayıların toplamı olarak ifade etmenin tüm olası yollarını üretir.\n * Örneğin, n=7 olduğunda, bunu daha küçük doğal sayıların toplamı olarak ifade etmenin 14 farklı yolu vardır.\n * Bu fonksiyon, bu ifadelerin tümünü sözlük sırasına göre döndürür.\n * n = 7 olduğunda çıktı aşağıdaki gibidir\n *  7=1+1+1+1+1+1+1\n    7=1+1+1+1+1+2\n    7=1+1+1+1+3\n    7=1+1+1+2+2\n    7=1+1+1+4\n    7=1+1+2+3\n    7=1+1+5\n    7=1+2+2+2\n    7=1+2+4\n    7=1+3+3\n    7=1+6\n    7=2+2+3\n    7=2+5\n    7=3+4\n * @param int $n Girdi doğal sayısı (1'den büyük).\n * @return array Tüm olası ifadeleri temsil eden bir dizi döndürür.\n */\n\n function generateNumberExpressions($n) ",
      "vi": "<?php\n\n/**\n * Tạo ra tất cả các cách có thể để biểu diễn một số tự nhiên như là tổng của các số tự nhiên nhỏ hơn.\n * Ví dụ, khi n=7, có 14 cách khác nhau để biểu diễn nó như là tổng của các số tự nhiên nhỏ hơn.\n * Hàm này trả về tất cả các biểu thức này theo thứ tự từ điển.\n * dưới đây là đầu ra khi n = 7\n *  7=1+1+1+1+1+1+1\n    7=1+1+1+1+1+2\n    7=1+1+1+1+3\n    7=1+1+1+2+2\n    7=1+1+1+4\n    7=1+1+2+3\n    7=1+1+5\n    7=1+2+2+2\n    7=1+2+4\n    7=1+3+3\n    7=1+6\n    7=2+2+3\n    7=2+5\n    7=3+4\n * @param int $n Số tự nhiên đầu vào (lớn hơn 1).\n * @return array Một mảng các chuỗi biểu diễn tất cả các biểu thức có thể.\n */\n\n function generateNumberExpressions($n) "
    },
    "prompt_bertscore": {
      "es": "0.9923978194266517",
      "arb": "0.9921439697996891",
      "sw": "0.988129451168593",
      "tr": "0.9715072663620694",
      "vi": "0.9680093853520451"
    },
    "canonical_solution": " {\n    // This function will store the results\n    $results = [];\n\n\n\n    // Initialize the recursion with an empty array for the output\n    findCombinations($n, 1, [], $results);\n\n    // Format the results\n    return array_map(function($expression) use ($n) {\n        return \"$n=$expression\";\n    }, $results);\n}\n\n    // Helper function for recursion\nfunction findCombinations($n, $start, $output, &$results)\n    {\n        if ($n == 0) {\n            // Add to results only if there are more than one number in the combination\n            if (count($output) > 1) {\n                $results[] = implode('+', $output);\n            }\n            return;\n        }\n\n        for ($i = $start; $i <= $n; $i++) {\n            findCombinations($n - $i, $i, array_merge($output, [$i]), $results);\n        }\n}\n",
    "instruction": {
      "en": "function generateNumberExpressions($n)\n {\n    // This function will store the results\n    $results = [];\n\n\n\n    // Initialize the recursion with an empty array for the output\n    findCombinations($n, 1, [], $results);\n\n    // Format the results\n    return array_map(function($expression) use ($n) {\n        return \"$n=$expression\";\n    }, $results);\n}\n\n    // Helper function for recursion\nfunction findCombinations($n, $start, $output, &$results)\n    {\n        if ($n == 0) {\n            // Add to results only if there are more than one number in the combination\n            if (count($output) > 1) {\n                $results[] = implode('+', $output);\n            }\n            return;\n        }\n\n        for ($i = $start; $i <= $n; $i++) {\n            findCombinations($n - $i, $i, array_merge($output, [$i]), $results);\n        }\n}\n\n\nProvide a concise natural language description (docstring) of the PHP code in English using at most 500 characters.",
      "es": "function generateNumberExpressions($n)\n {\n    // This function will store the results\n    $results = [];\n\n\n\n    // Initialize the recursion with an empty array for the output\n    findCombinations($n, 1, [], $results);\n\n    // Format the results\n    return array_map(function($expression) use ($n) {\n        return \"$n=$expression\";\n    }, $results);\n}\n\n    // Helper function for recursion\nfunction findCombinations($n, $start, $output, &$results)\n    {\n        if ($n == 0) {\n            // Add to results only if there are more than one number in the combination\n            if (count($output) > 1) {\n                $results[] = implode('+', $output);\n            }\n            return;\n        }\n\n        for ($i = $start; $i <= $n; $i++) {\n            findCombinations($n - $i, $i, array_merge($output, [$i]), $results);\n        }\n}\n\n\nProporcione una descripción concisa en lenguaje natural (docstring) del código PHP en español utilizando como máximo 500 caracteres.",
      "arb": "function generateNumberExpressions($n)\n {\n    // This function will store the results\n    $results = [];\n\n\n\n    // Initialize the recursion with an empty array for the output\n    findCombinations($n, 1, [], $results);\n\n    // Format the results\n    return array_map(function($expression) use ($n) {\n        return \"$n=$expression\";\n    }, $results);\n}\n\n    // Helper function for recursion\nfunction findCombinations($n, $start, $output, &$results)\n    {\n        if ($n == 0) {\n            // Add to results only if there are more than one number in the combination\n            if (count($output) > 1) {\n                $results[] = implode('+', $output);\n            }\n            return;\n        }\n\n        for ($i = $start; $i <= $n; $i++) {\n            findCombinations($n - $i, $i, array_merge($output, [$i]), $results);\n        }\n}\n\n\nيرجى تقديم وصف موجز بلغة طبيعية (docstring) للشفرة البرمجية المكتوبة بلغة PHP باللغة العربية الفصحى، بحيث لا يتجاوز 500 حرف.",
      "sw": "function generateNumberExpressions($n)\n {\n    // This function will store the results\n    $results = [];\n\n\n\n    // Initialize the recursion with an empty array for the output\n    findCombinations($n, 1, [], $results);\n\n    // Format the results\n    return array_map(function($expression) use ($n) {\n        return \"$n=$expression\";\n    }, $results);\n}\n\n    // Helper function for recursion\nfunction findCombinations($n, $start, $output, &$results)\n    {\n        if ($n == 0) {\n            // Add to results only if there are more than one number in the combination\n            if (count($output) > 1) {\n                $results[] = implode('+', $output);\n            }\n            return;\n        }\n\n        for ($i = $start; $i <= $n; $i++) {\n            findCombinations($n - $i, $i, array_merge($output, [$i]), $results);\n        }\n}\n\n\nToa maelezo mafupi ya lugha asilia (docstring) ya msimbo wa PHP kwa Kiswahili kwa kutumia herufi zisizozidi 500.",
      "tr": "function generateNumberExpressions($n)\n {\n    // This function will store the results\n    $results = [];\n\n\n\n    // Initialize the recursion with an empty array for the output\n    findCombinations($n, 1, [], $results);\n\n    // Format the results\n    return array_map(function($expression) use ($n) {\n        return \"$n=$expression\";\n    }, $results);\n}\n\n    // Helper function for recursion\nfunction findCombinations($n, $start, $output, &$results)\n    {\n        if ($n == 0) {\n            // Add to results only if there are more than one number in the combination\n            if (count($output) > 1) {\n                $results[] = implode('+', $output);\n            }\n            return;\n        }\n\n        for ($i = $start; $i <= $n; $i++) {\n            findCombinations($n - $i, $i, array_merge($output, [$i]), $results);\n        }\n}\n\n\nPHP kodunun işlevini açıklayan kısa bir doğal dil açıklaması (docstring) sağlayın. Açıklama, en fazla 500 karakter kullanılarak Türkçe olarak yazılmalıdır.",
      "vi": "function generateNumberExpressions($n)\n {\n    // This function will store the results\n    $results = [];\n\n\n\n    // Initialize the recursion with an empty array for the output\n    findCombinations($n, 1, [], $results);\n\n    // Format the results\n    return array_map(function($expression) use ($n) {\n        return \"$n=$expression\";\n    }, $results);\n}\n\n    // Helper function for recursion\nfunction findCombinations($n, $start, $output, &$results)\n    {\n        if ($n == 0) {\n            // Add to results only if there are more than one number in the combination\n            if (count($output) > 1) {\n                $results[] = implode('+', $output);\n            }\n            return;\n        }\n\n        for ($i = $start; $i <= $n; $i++) {\n            findCombinations($n - $i, $i, array_merge($output, [$i]), $results);\n        }\n}\n\n\nCung cấp mô tả ngắn gọn bằng ngôn ngữ tự nhiên (docstring) cho mã PHP bằng tiếng Việt với tối đa 500 ký tự."
    },
    "instruction_bertscore": {
      "es": "0.9687069752502395",
      "arb": "0.8898884537517856",
      "sw": "0.9428367585331127",
      "tr": "0.881863190466833",
      "vi": "0.9017250367880356"
    },
    "level": "",
    "test": "function main(){\n    $result = generateNumberExpressions(7);\n    assert($result===[\"7=1+1+1+1+1+1+1\",\"7=1+1+1+1+1+2\",\"7=1+1+1+1+3\",\"7=1+1+1+2+2\",\"7=1+1+1+4\",\"7=1+1+2+3\",\"7=1+1+5\",\"7=1+2+2+2\",\"7=1+2+4\",\"7=1+3+3\",\"7=1+6\",\"7=2+2+3\",\"7=2+5\",\"7=3+4\"]);\n    $result = generateNumberExpressions(6);\n    assert($result===[  \"6=1+1+1+1+1+1\",\"6=1+1+1+1+2\",\"6=1+1+1+3\",\"6=1+1+2+2\",\"6=1+1+4\",\"6=1+2+3\",\"6=1+5\",\"6=2+2+2\",\"6=2+4\",\"6=3+3\"]);\n  \n  \n}\n\n\nmain();\n?>",
    "entry_point": "generateNumberExpressions",
    "signature": "function generateNumberExpressions($n)",
    "docstring": {
      "en": "Generates all possible ways to express a natural number as the sum of smaller natural numbers.\nFor example, when n=7, there are 14 different ways to express it as the sum of smaller natural numbers.\nThis function returns all these expressions in lexicographical (dictionary) order.\nbelow is output when n = 7\n7=1+1+1+1+1+1+1\n7=1+1+1+1+1+2\n7=1+1+1+1+3\n7=1+1+1+2+2\n7=1+1+1+4\n7=1+1+2+3\n7=1+1+5\n7=1+2+2+2\n7=1+2+4\n7=1+3+3\n7=1+6\n7=2+2+3\n7=2+5\n7=3+4\n@param int $n The input natural number (greater than 1).\n@return array An array of strings representing all possible expressions.",
      "es": "Genera todas las formas posibles de expresar un número natural como la suma de números naturales más pequeños. Por ejemplo, cuando n=7, hay 14 formas diferentes de expresarlo como la suma de números naturales más pequeños. Esta función devuelve todas estas expresiones en orden lexicográfico (de diccionario). a continuación se muestra la salida cuando n = 7 7=1+1+1+1+1+1+1 7=1+1+1+1+1+2 7=1+1+1+1+3 7=1+1+1+2+2 7=1+1+1+4 7=1+1+2+3 7=1+1+5 7=1+2+2+2 7=1+2+4 7=1+3+3 7=1+6 7=2+2+3 7=2+5 7=3+4 @param int $n El número natural de entrada (mayor que 1). @return array Un arreglo de cadenas que representa todas las expresiones posibles.",
      "arb": "يولد جميع الطرق الممكنة للتعبير عن عدد طبيعي كمجموع لأعداد طبيعية أصغر.  \nعلى سبيل المثال، عندما يكون n=7، هناك 14 طريقة مختلفة للتعبير عنه كمجموع لأعداد طبيعية أصغر.  \nتقوم هذه الدالة بإرجاع جميع هذه التعبيرات بترتيب معجمي (قاموسي).  \nأدناه هو الناتج عندما n = 7  \n7=1+1+1+1+1+1+1  \n7=1+1+1+1+1+2  \n7=1+1+1+1+3  \n7=1+1+1+2+2  \n7=1+1+1+4  \n7=1+1+2+3  \n7=1+1+5  \n7=1+2+2+2  \n7=1+2+4  \n7=1+3+3  \n7=1+6  \n7=2+2+3  \n7=2+5  \n7=3+4  \n@param int $n العدد الطبيعي المدخل (أكبر من 1).  \n@return array مصفوفة من السلاسل النصية تمثل جميع التعبيرات الممكنة.  ",
      "sw": "Hutengeneza njia zote zinazowezekana za kuonyesha nambari asilia kama jumla ya nambari asilia ndogo zaidi. Kwa mfano, wakati n=7, kuna njia 14 tofauti za kuionyesha kama jumla ya nambari asilia ndogo zaidi. Kazi hii inarudisha maonyesho haya yote katika mpangilio wa lexicographical (kamusi). hapa chini ni matokeo wakati n = 7 7=1+1+1+1+1+1+1 7=1+1+1+1+1+2 7=1+1+1+1+3 7=1+1+1+2+2 7=1+1+1+4 7=1+1+2+3 7=1+1+5 7=1+2+2+2 7=1+2+4 7=1+3+3 7=1+6 7=2+2+3 7=2+5 7=3+4 @param int $n Nambari asilia ya ingizo (kubwa kuliko 1). @return array Mfululizo wa maandishi yanayowakilisha maonyesho yote yanayowezekana.",
      "tr": "Doğal bir sayıyı daha küçük doğal sayıların toplamı olarak ifade etmenin tüm olası yollarını üretir. Örneğin, n=7 olduğunda, bunu daha küçük doğal sayıların toplamı olarak ifade etmenin 14 farklı yolu vardır. Bu fonksiyon, tüm bu ifadeleri sözlük sırasına göre döndürür. aşağıda n = 7 için çıktı verilmiştir 7=1+1+1+1+1+1+1 7=1+1+1+1+1+2 7=1+1+1+1+3 7=1+1+1+2+2 7=1+1+1+4 7=1+1+2+3 7=1+1+5 7=1+2+2+2 7=1+2+4 7=1+3+3 7=1+6 7=2+2+3 7=2+5 7=3+4 @param int $n Girdi doğal sayısı (1'den büyük). @return array Tüm olası ifadeleri temsil eden bir dizi.",
      "vi": "Tạo ra tất cả các cách có thể để biểu diễn một số tự nhiên như là tổng của các số tự nhiên nhỏ hơn.\nVí dụ, khi n=7, có 14 cách khác nhau để biểu diễn nó như là tổng của các số tự nhiên nhỏ hơn.\nHàm này trả về tất cả các biểu thức này theo thứ tự từ điển.\ndưới đây là đầu ra khi n = 7\n7=1+1+1+1+1+1+1\n7=1+1+1+1+1+2\n7=1+1+1+1+3\n7=1+1+1+2+2\n7=1+1+1+4\n7=1+1+2+3\n7=1+1+5\n7=1+2+2+2\n7=1+2+4\n7=1+3+3\n7=1+6\n7=2+2+3\n7=2+5\n7=3+4\n@param int $n Số tự nhiên đầu vào (lớn hơn 1).\n@return array Một mảng các chuỗi biểu diễn tất cả các biểu thức có thể."
    },
    "docstring_bertscore": {
      "es": "0.9910528931166644",
      "arb": "0.9921074218095787",
      "sw": "0.975866011443499",
      "tr": "0.9628084474550276",
      "vi": "0.963727708858457"
    }
  },
  {
    "task_id": "PHP/40",
    "prompt": {
      "en": "<?php\n\n\n/**\n * Calculates the maximum number of distinct letters one can pass through in a letter matrix.\n * Starting from the top-left corner, you can move up, down, left, or right, but cannot visit a cell more than once.\n * This function finds the maximum number of distinct letters that can be traversed in the matrix.\n * \n * Inputs:\n * - $rows (int): The number of rows in the matrix.\n * - $cols (int): The number of columns in the matrix.\n * - $matrix (array): A 2D array representing the letter matrix.\n *\n * Output:\n * - Returns an integer representing the maximum number of distinct letters that can be traversed.\n *\n * Example:\n * maxDistinctLetters(3, 3, [['A', 'B', 'C'], ['D', 'E', 'F'], ['G', 'H', 'I']]) should return 9.\n */\n\nfunction maxDistinctLetters($rows, $cols, $matrix) ",
      "es": "<?php\n\n\n/**\n * Calcula el número máximo de letras distintas que se pueden atravesar en una matriz de letras.\n * Comenzando desde la esquina superior izquierda, puedes moverte hacia arriba, abajo, izquierda o derecha, pero no puedes visitar una celda más de una vez.\n * Esta función encuentra el número máximo de letras distintas que se pueden recorrer en la matriz.\n * \n * Entradas:\n * - $rows (int): El número de filas en la matriz.\n * - $cols (int): El número de columnas en la matriz.\n * - $matrix (array): Un arreglo 2D que representa la matriz de letras.\n *\n * Salida:\n * - Devuelve un entero que representa el número máximo de letras distintas que se pueden recorrer.\n *\n * Ejemplo:\n * maxDistinctLetters(3, 3, [['A', 'B', 'C'], ['D', 'E', 'F'], ['G', 'H', 'I']]) debería devolver 9.\n */\n\nfunction maxDistinctLetters($rows, $cols, $matrix) ",
      "arb": "<?php\n\n\n/**\n * يحسب الحد الأقصى لعدد الأحرف المميزة التي يمكن المرور بها في مصفوفة الحروف.\n * بدءًا من الزاوية العلوية اليسرى، يمكنك التحرك لأعلى، لأسفل، لليسار، أو لليمين، ولكن لا يمكنك زيارة خلية أكثر من مرة.\n * هذه الدالة تجد الحد الأقصى لعدد الأحرف المميزة التي يمكن المرور بها في المصفوفة.\n * \n * المدخلات:\n * - $rows (int): عدد الصفوف في المصفوفة.\n * - $cols (int): عدد الأعمدة في المصفوفة.\n * - $matrix (array): مصفوفة ثنائية الأبعاد تمثل مصفوفة الحروف.\n *\n * المخرجات:\n * - تعيد عددًا صحيحًا يمثل الحد الأقصى لعدد الأحرف المميزة التي يمكن المرور بها.\n *\n * مثال:\n * maxDistinctLetters(3, 3, [['A', 'B', 'C'], ['D', 'E', 'F'], ['G', 'H', 'I']]) يجب أن تعيد 9.\n */\n\nfunction maxDistinctLetters($rows, $cols, $matrix) ",
      "sw": "<?php\n\n\n/**\n * Inahesabu idadi kubwa zaidi ya herufi tofauti ambazo mtu anaweza kupita katika matriki ya herufi.\n * Kuanzia kona ya juu-kushoto, unaweza kusonga juu, chini, kushoto, au kulia, lakini huwezi kutembelea seli zaidi ya mara moja.\n * Kazi hii inapata idadi kubwa zaidi ya herufi tofauti ambazo zinaweza kupitiwa katika matriki.\n * \n * Ingizo:\n * - $rows (int): Idadi ya safu katika matriki.\n * - $cols (int): Idadi ya nguzo katika matriki.\n * - $matrix (array): Mfululizo wa 2D unaowakilisha matriki ya herufi.\n *\n * Tokeo:\n * - Inarudisha nambari kamili inayowakilisha idadi kubwa zaidi ya herufi tofauti ambazo zinaweza kupitiwa.\n *\n * Mfano:\n * maxDistinctLetters(3, 3, [['A', 'B', 'C'], ['D', 'E', 'F'], ['G', 'H', 'I']]) inapaswa kurudisha 9.\n */\n\nfunction maxDistinctLetters($rows, $cols, $matrix) ",
      "tr": "<?php\n\n\n/**\n * Bir harf matrisinde geçilebilecek maksimum farklı harf sayısını hesaplar.\n * Sol üst köşeden başlayarak yukarı, aşağı, sola veya sağa hareket edebilirsiniz, ancak bir hücreyi birden fazla ziyaret edemezsiniz.\n * Bu fonksiyon, matris içinde geçilebilecek maksimum farklı harf sayısını bulur.\n * \n * Girdiler:\n * - $rows (int): Matristeki satır sayısı.\n * - $cols (int): Matristeki sütun sayısı.\n * - $matrix (array): Harf matrisini temsil eden 2D dizi.\n *\n * Çıktı:\n * - Geçilebilecek maksimum farklı harf sayısını temsil eden bir tamsayı döndürür.\n *\n * Örnek:\n * maxDistinctLetters(3, 3, [['A', 'B', 'C'], ['D', 'E', 'F'], ['G', 'H', 'I']]) 9 döndürmelidir.\n */\n\nfunction maxDistinctLetters($rows, $cols, $matrix) ",
      "vi": "<?php\n\n\n/**\n * Tính toán số lượng chữ cái khác nhau tối đa mà bạn có thể đi qua trong một ma trận chữ cái.\n * Bắt đầu từ góc trên bên trái, bạn có thể di chuyển lên, xuống, trái hoặc phải, nhưng không thể thăm một ô nhiều hơn một lần.\n * Hàm này tìm số lượng chữ cái khác nhau tối đa có thể được đi qua trong ma trận.\n * \n * Đầu vào:\n * - $rows (int): Số hàng trong ma trận.\n * - $cols (int): Số cột trong ma trận.\n * - $matrix (array): Một mảng 2D đại diện cho ma trận chữ cái.\n *\n * Đầu ra:\n * - Trả về một số nguyên đại diện cho số lượng chữ cái khác nhau tối đa có thể được đi qua.\n *\n * Ví dụ:\n * maxDistinctLetters(3, 3, [['A', 'B', 'C'], ['D', 'E', 'F'], ['G', 'H', 'I']]) nên trả về 9.\n */\n\nfunction maxDistinctLetters($rows, $cols, $matrix) "
    },
    "prompt_bertscore": {
      "es": "0.9794681734035667",
      "arb": "0.9688692562715451",
      "sw": "0.983916500786843",
      "tr": "0.973412330346575",
      "vi": "0.9727816788867892"
    },
    "canonical_solution": "{\n    // Global variables to store the maximum count and visited letters\n    $maxCount = 0;\n    $visited = array_fill(0, 1001, false);\n\n    // Directions for movement (up, down, left, right)\n    $dx = [0, 1, -1, 0, 0];\n    $dy = [0, 0, 0, 1, -1];\n\n    // Inner function to perform DFS\n    $dfs = function($x, $y, $count) use (&$visited, &$maxCount, &$dfs, $matrix, $rows, $cols, $dx, $dy) {\n        $maxCount = max($maxCount, $count);\n        for ($i = 1; $i <= 4; $i++) {\n            $tx = $x + $dx[$i];\n            $ty = $y + $dy[$i];\n\n            // Check boundaries and if the cell is not visited\n            if ($tx > 0 && $tx <= $rows && $ty > 0 && $ty <= $cols && !$visited[ord($matrix[$tx - 1][$ty - 1])]) {\n                $visited[ord($matrix[$tx - 1][$ty - 1])] = true;\n                $dfs($tx, $ty, $count + 1);\n                $visited[ord($matrix[$tx - 1][$ty - 1])] = false;\n            }\n        }\n    };\n\n    // Start DFS from the top-left corner\n    $visited[ord($matrix[0][0])] = true;\n    $dfs(1, 1, 1);\n\n    return $maxCount;\n}",
    "instruction": {
      "en": "function maxDistinctLetters($rows, $cols, $matrix)\n{\n    // Global variables to store the maximum count and visited letters\n    $maxCount = 0;\n    $visited = array_fill(0, 1001, false);\n\n    // Directions for movement (up, down, left, right)\n    $dx = [0, 1, -1, 0, 0];\n    $dy = [0, 0, 0, 1, -1];\n\n    // Inner function to perform DFS\n    $dfs = function($x, $y, $count) use (&$visited, &$maxCount, &$dfs, $matrix, $rows, $cols, $dx, $dy) {\n        $maxCount = max($maxCount, $count);\n        for ($i = 1; $i <= 4; $i++) {\n            $tx = $x + $dx[$i];\n            $ty = $y + $dy[$i];\n\n            // Check boundaries and if the cell is not visited\n            if ($tx > 0 && $tx <= $rows && $ty > 0 && $ty <= $cols && !$visited[ord($matrix[$tx - 1][$ty - 1])]) {\n                $visited[ord($matrix[$tx - 1][$ty - 1])] = true;\n                $dfs($tx, $ty, $count + 1);\n                $visited[ord($matrix[$tx - 1][$ty - 1])] = false;\n            }\n        }\n    };\n\n    // Start DFS from the top-left corner\n    $visited[ord($matrix[0][0])] = true;\n    $dfs(1, 1, 1);\n\n    return $maxCount;\n}\n\nProvide a concise natural language description (docstring) of the PHP code in English using at most 500 characters.",
      "es": "function maxDistinctLetters($rows, $cols, $matrix)\n{\n    // Global variables to store the maximum count and visited letters\n    $maxCount = 0;\n    $visited = array_fill(0, 1001, false);\n\n    // Directions for movement (up, down, left, right)\n    $dx = [0, 1, -1, 0, 0];\n    $dy = [0, 0, 0, 1, -1];\n\n    // Inner function to perform DFS\n    $dfs = function($x, $y, $count) use (&$visited, &$maxCount, &$dfs, $matrix, $rows, $cols, $dx, $dy) {\n        $maxCount = max($maxCount, $count);\n        for ($i = 1; $i <= 4; $i++) {\n            $tx = $x + $dx[$i];\n            $ty = $y + $dy[$i];\n\n            // Check boundaries and if the cell is not visited\n            if ($tx > 0 && $tx <= $rows && $ty > 0 && $ty <= $cols && !$visited[ord($matrix[$tx - 1][$ty - 1])]) {\n                $visited[ord($matrix[$tx - 1][$ty - 1])] = true;\n                $dfs($tx, $ty, $count + 1);\n                $visited[ord($matrix[$tx - 1][$ty - 1])] = false;\n            }\n        }\n    };\n\n    // Start DFS from the top-left corner\n    $visited[ord($matrix[0][0])] = true;\n    $dfs(1, 1, 1);\n\n    return $maxCount;\n}\n\nProporcione una descripción concisa en lenguaje natural (docstring) del código PHP en español utilizando como máximo 500 caracteres.",
      "arb": "function maxDistinctLetters($rows, $cols, $matrix)\n{\n    // Global variables to store the maximum count and visited letters\n    $maxCount = 0;\n    $visited = array_fill(0, 1001, false);\n\n    // Directions for movement (up, down, left, right)\n    $dx = [0, 1, -1, 0, 0];\n    $dy = [0, 0, 0, 1, -1];\n\n    // Inner function to perform DFS\n    $dfs = function($x, $y, $count) use (&$visited, &$maxCount, &$dfs, $matrix, $rows, $cols, $dx, $dy) {\n        $maxCount = max($maxCount, $count);\n        for ($i = 1; $i <= 4; $i++) {\n            $tx = $x + $dx[$i];\n            $ty = $y + $dy[$i];\n\n            // Check boundaries and if the cell is not visited\n            if ($tx > 0 && $tx <= $rows && $ty > 0 && $ty <= $cols && !$visited[ord($matrix[$tx - 1][$ty - 1])]) {\n                $visited[ord($matrix[$tx - 1][$ty - 1])] = true;\n                $dfs($tx, $ty, $count + 1);\n                $visited[ord($matrix[$tx - 1][$ty - 1])] = false;\n            }\n        }\n    };\n\n    // Start DFS from the top-left corner\n    $visited[ord($matrix[0][0])] = true;\n    $dfs(1, 1, 1);\n\n    return $maxCount;\n}\n\nيرجى تقديم وصف موجز بلغة طبيعية (docstring) لشيفرة PHP باللغة العربية الفصحى باستخدام 500 حرف كحد أقصى.",
      "sw": "function maxDistinctLetters($rows, $cols, $matrix)\n{\n    // Global variables to store the maximum count and visited letters\n    $maxCount = 0;\n    $visited = array_fill(0, 1001, false);\n\n    // Directions for movement (up, down, left, right)\n    $dx = [0, 1, -1, 0, 0];\n    $dy = [0, 0, 0, 1, -1];\n\n    // Inner function to perform DFS\n    $dfs = function($x, $y, $count) use (&$visited, &$maxCount, &$dfs, $matrix, $rows, $cols, $dx, $dy) {\n        $maxCount = max($maxCount, $count);\n        for ($i = 1; $i <= 4; $i++) {\n            $tx = $x + $dx[$i];\n            $ty = $y + $dy[$i];\n\n            // Check boundaries and if the cell is not visited\n            if ($tx > 0 && $tx <= $rows && $ty > 0 && $ty <= $cols && !$visited[ord($matrix[$tx - 1][$ty - 1])]) {\n                $visited[ord($matrix[$tx - 1][$ty - 1])] = true;\n                $dfs($tx, $ty, $count + 1);\n                $visited[ord($matrix[$tx - 1][$ty - 1])] = false;\n            }\n        }\n    };\n\n    // Start DFS from the top-left corner\n    $visited[ord($matrix[0][0])] = true;\n    $dfs(1, 1, 1);\n\n    return $maxCount;\n}\n\nToa maelezo mafupi ya lugha asilia (docstring) ya msimbo wa PHP kwa Kiswahili kwa kutumia herufi zisizozidi 500.",
      "tr": "function maxDistinctLetters($rows, $cols, $matrix)\n{\n    // Global variables to store the maximum count and visited letters\n    $maxCount = 0;\n    $visited = array_fill(0, 1001, false);\n\n    // Directions for movement (up, down, left, right)\n    $dx = [0, 1, -1, 0, 0];\n    $dy = [0, 0, 0, 1, -1];\n\n    // Inner function to perform DFS\n    $dfs = function($x, $y, $count) use (&$visited, &$maxCount, &$dfs, $matrix, $rows, $cols, $dx, $dy) {\n        $maxCount = max($maxCount, $count);\n        for ($i = 1; $i <= 4; $i++) {\n            $tx = $x + $dx[$i];\n            $ty = $y + $dy[$i];\n\n            // Check boundaries and if the cell is not visited\n            if ($tx > 0 && $tx <= $rows && $ty > 0 && $ty <= $cols && !$visited[ord($matrix[$tx - 1][$ty - 1])]) {\n                $visited[ord($matrix[$tx - 1][$ty - 1])] = true;\n                $dfs($tx, $ty, $count + 1);\n                $visited[ord($matrix[$tx - 1][$ty - 1])] = false;\n            }\n        }\n    };\n\n    // Start DFS from the top-left corner\n    $visited[ord($matrix[0][0])] = true;\n    $dfs(1, 1, 1);\n\n    return $maxCount;\n}\n\nPHP kodunun işlevini açıklayan kısa bir doğal dil tanımı (docstring) sağlayın. Açıklama Türkçe olmalı ve en fazla 500 karakter kullanılmalıdır.",
      "vi": "function maxDistinctLetters($rows, $cols, $matrix)\n{\n    // Global variables to store the maximum count and visited letters\n    $maxCount = 0;\n    $visited = array_fill(0, 1001, false);\n\n    // Directions for movement (up, down, left, right)\n    $dx = [0, 1, -1, 0, 0];\n    $dy = [0, 0, 0, 1, -1];\n\n    // Inner function to perform DFS\n    $dfs = function($x, $y, $count) use (&$visited, &$maxCount, &$dfs, $matrix, $rows, $cols, $dx, $dy) {\n        $maxCount = max($maxCount, $count);\n        for ($i = 1; $i <= 4; $i++) {\n            $tx = $x + $dx[$i];\n            $ty = $y + $dy[$i];\n\n            // Check boundaries and if the cell is not visited\n            if ($tx > 0 && $tx <= $rows && $ty > 0 && $ty <= $cols && !$visited[ord($matrix[$tx - 1][$ty - 1])]) {\n                $visited[ord($matrix[$tx - 1][$ty - 1])] = true;\n                $dfs($tx, $ty, $count + 1);\n                $visited[ord($matrix[$tx - 1][$ty - 1])] = false;\n            }\n        }\n    };\n\n    // Start DFS from the top-left corner\n    $visited[ord($matrix[0][0])] = true;\n    $dfs(1, 1, 1);\n\n    return $maxCount;\n}\n\nCung cấp mô tả ngắn gọn bằng ngôn ngữ tự nhiên (docstring) cho mã PHP bằng tiếng Việt với tối đa 500 ký tự."
    },
    "instruction_bertscore": {
      "es": "0.9687069752502395",
      "arb": "0.924580242951434",
      "sw": "0.9428367585331127",
      "tr": "0.8785945289165229",
      "vi": "0.9017250367880356"
    },
    "level": "",
    "test": "function main(){\n    $matrix = [\n        ['H', 'F', 'D', 'F', 'F', 'B'],\n        ['A', 'J', 'H', 'G', 'D', 'H'],\n        ['D', 'G', 'A', 'G', 'E', 'H']\n    ];\n    assert(maxDistinctLetters(3, 6, $matrix) === 6);\n  \n    $matrix = [\n        ['H', 'F', 'Y' ],\n        ['A', 'J', 'Z' ],\n        ['D', 'G', 'A']\n    ];\n    assert(maxDistinctLetters(3, 3, $matrix) === 8);\n\n    $matrix = [\n        ['A', 'D', 'G' ],\n        ['B', 'E', 'H' ],\n        ['C', 'F', 'I']\n    ];\n    assert(maxDistinctLetters(3, 3, $matrix) === 9);\n\n}\n\n\nmain();\n?>",
    "entry_point": "maxDistinctLetters",
    "signature": "function maxDistinctLetters($rows, $cols, $matrix)",
    "docstring": {
      "en": "Calculates the maximum number of distinct letters one can pass through in a letter matrix.\nStarting from the top-left corner, you can move up, down, left, or right, but cannot visit a cell more than once.\nThis function finds the maximum number of distinct letters that can be traversed in the matrix.\n\nInputs:\n- $rows (int): The number of rows in the matrix.\n- $cols (int): The number of columns in the matrix.\n- $matrix (array): A 2D array representing the letter matrix.\n\nOutput:\n- Returns an integer representing the maximum number of distinct letters that can be traversed.\n\nExample:\nmaxDistinctLetters(3, 3, [['A', 'B', 'C'], ['D', 'E', 'F'], ['G', 'H', 'I']]) should return 9.",
      "es": "Calcula el número máximo de letras distintas que se pueden atravesar en una matriz de letras. Comenzando desde la esquina superior izquierda, puedes moverte hacia arriba, abajo, izquierda o derecha, pero no puedes visitar una celda más de una vez. Esta función encuentra el número máximo de letras distintas que se pueden recorrer en la matriz.\n\nEntradas:\n- $rows (int): El número de filas en la matriz.\n- $cols (int): El número de columnas en la matriz.\n- $matrix (array): Un arreglo 2D que representa la matriz de letras.\n\nSalida:\n- Devuelve un entero que representa el número máximo de letras distintas que se pueden recorrer.\n\nEjemplo:\nmaxDistinctLetters(3, 3, [['A', 'B', 'C'], ['D', 'E', 'F'], ['G', 'H', 'I']]) debería devolver 9.",
      "arb": "تحسب الحد الأقصى لعدد الأحرف المميزة التي يمكن المرور بها في مصفوفة الأحرف. بدءًا من الزاوية العلوية اليسرى، يمكنك التحرك لأعلى، لأسفل، لليسار، أو لليمين، ولكن لا يمكنك زيارة خلية أكثر من مرة. هذه الدالة تجد الحد الأقصى لعدد الأحرف المميزة التي يمكن المرور بها في المصفوفة.\n\nالمدخلات:\n- $rows (int): عدد الصفوف في المصفوفة.\n- $cols (int): عدد الأعمدة في المصفوفة.\n- $matrix (array): مصفوفة ثنائية الأبعاد تمثل مصفوفة الأحرف.\n\nالمخرجات:\n- تعيد عددًا صحيحًا يمثل الحد الأقصى لعدد الأحرف المميزة التي يمكن المرور بها.\n\nمثال:\nmaxDistinctLetters(3, 3, [['A', 'B', 'C'], ['D', 'E', 'F'], ['G', 'H', 'I']]) يجب أن تعيد 9.",
      "sw": "Hesabu idadi kubwa zaidi ya herufi tofauti ambazo mtu anaweza kupita kupitia kwenye matrix ya herufi. \nKuanzia kwenye kona ya juu-kushoto, unaweza kusonga juu, chini, kushoto, au kulia, lakini huwezi kutembelea seli zaidi ya mara moja. \nKazi hii inapata idadi kubwa zaidi ya herufi tofauti ambazo zinaweza kupitiwa kwenye matrix.\n\nVipengele vya Kuingiza:\n- $rows (int): Idadi ya safu kwenye matrix.\n- $cols (int): Idadi ya nguzo kwenye matrix.\n- $matrix (array): Safu mbili inayowakilisha matrix ya herufi.\n\nMatokeo:\n- Inarudisha nambari kamili inayowakilisha idadi kubwa zaidi ya herufi tofauti ambazo zinaweza kupitiwa.\n\nMfano:\nmaxDistinctLetters(3, 3, [['A', 'B', 'C'], ['D', 'E', 'F'], ['G', 'H', 'I']]) inapaswa kurudisha 9.",
      "tr": "Farklı harflerden oluşan bir harf matrisinde geçilebilecek maksimum harf sayısını hesaplar.\nSol üst köşeden başlayarak yukarı, aşağı, sola veya sağa hareket edebilirsiniz, ancak bir hücreyi bir kereden fazla ziyaret edemezsiniz.\nBu fonksiyon, matris içinde geçilebilecek maksimum farklı harf sayısını bulur.\n\nGirdiler:\n- $rows (int): Matrisin satır sayısı.\n- $cols (int): Matrisin sütun sayısı.\n- $matrix (array): Harf matrisini temsil eden 2D dizi.\n\nÇıktı:\n- Geçilebilecek maksimum farklı harf sayısını temsil eden bir tamsayı döndürür.\n\nÖrnek:\nmaxDistinctLetters(3, 3, [['A', 'B', 'C'], ['D', 'E', 'F'], ['G', 'H', 'I']]) 9 döndürmelidir.",
      "vi": "Tính toán số lượng tối đa các chữ cái khác nhau mà bạn có thể đi qua trong một ma trận chữ cái. Bắt đầu từ góc trên bên trái, bạn có thể di chuyển lên, xuống, trái hoặc phải, nhưng không thể thăm một ô nhiều hơn một lần. Hàm này tìm số lượng tối đa các chữ cái khác nhau có thể được đi qua trong ma trận.\n\nĐầu vào:\n- $rows (int): Số hàng trong ma trận.\n- $cols (int): Số cột trong ma trận.\n- $matrix (array): Một mảng 2D đại diện cho ma trận chữ cái.\n\nĐầu ra:\n- Trả về một số nguyên đại diện cho số lượng tối đa các chữ cái khác nhau có thể được đi qua.\n\nVí dụ:\nmaxDistinctLetters(3, 3, [['A', 'B', 'C'], ['D', 'E', 'F'], ['G', 'H', 'I']]) sẽ trả về 9."
    },
    "docstring_bertscore": {
      "es": "0.9780845141692777",
      "arb": "0.965788499061694",
      "sw": "0.9561372474775898",
      "tr": "0.9664711916813109",
      "vi": "0.9801574208257577"
    }
  },
  {
    "task_id": "PHP/41",
    "prompt": {
      "en": "<?php\n\n/**\n * Counts the number of evenly matched pairs of students based on their exam scores.\n * Two students are considered evenly matched if the difference in each subject's score\n * is not greater than 5 and the total score difference is not greater than 10.\n * Input: An integer N representing the number of students followed by N lines of three integers each\n *         representing the scores of each student in Chinese, Mathematics, and English respectively.\n * Output: An integer representing the number of evenly matched pairs of students.\n */\n\nfunction countEvenlyMatchedPairs($N, $students) ",
      "es": "<?php\n\n/**\n * Cuenta el número de pares de estudiantes igualados basados en sus calificaciones de examen.\n * Se considera que dos estudiantes están igualados si la diferencia en la puntuación de cada materia\n * no es mayor que 5 y la diferencia total de puntuación no es mayor que 10.\n * Entrada: Un entero N que representa el número de estudiantes seguido de N líneas de tres enteros cada una\n *          representando las calificaciones de cada estudiante en Chino, Matemáticas e Inglés respectivamente.\n * Salida: Un entero que representa el número de pares de estudiantes igualados.\n */\n\nfunction countEvenlyMatchedPairs($N, $students) ",
      "arb": "<?php\n\n/**\n * يحسب عدد الأزواج المتكافئة من الطلاب بناءً على درجاتهم في الامتحانات.\n * يعتبر طالبان متكافئين إذا كان الفرق في درجة كل مادة لا يزيد عن 5 والفرق الكلي في الدرجات لا يزيد عن 10.\n * المدخلات: عدد صحيح N يمثل عدد الطلاب يليه N سطرًا من ثلاثة أعداد صحيحة\n *          تمثل درجات كل طالب في اللغة الصينية والرياضيات والإنجليزية على التوالي.\n * المخرجات: عدد صحيح يمثل عدد الأزواج المتكافئة من الطلاب.\n */\n\nfunction countEvenlyMatchedPairs($N, $students) ",
      "sw": "<?php\n\n/**\n * Inahesabu idadi ya wanafunzi waliolingana vizuri kulingana na alama zao za mtihani.\n * Wanafunzi wawili wanachukuliwa kuwa wamefanana vizuri ikiwa tofauti ya alama katika kila somo\n * haizidi 5 na tofauti ya jumla ya alama haizidi 10.\n * Ingizo: Nambari nzima N inayoashiria idadi ya wanafunzi ikifuatiwa na mistari N ya nambari tatu kila moja\n *         ikiwakilisha alama za kila mwanafunzi katika Kichina, Hisabati, na Kiingereza mtawalia.\n * Tokeo: Nambari nzima inayoashiria idadi ya wanafunzi waliolingana vizuri.\n */\n\nfunction countEvenlyMatchedPairs($N, $students) ",
      "tr": "<?php\n\n/**\n * Öğrencilerin sınav notlarına göre eşit derecede eşleşen çiftlerin sayısını sayar.\n * İki öğrenci, her bir dersin not farkı 5'ten büyük değilse ve toplam not farkı 10'dan büyük değilse\n * eşit derecede eşleşmiş kabul edilir.\n * Girdi: Öğrenci sayısını temsil eden bir tamsayı N ve ardından her biri öğrencinin\n *         Çince, Matematik ve İngilizce notlarını temsil eden üç tamsayıdan oluşan N satır.\n * Çıktı: Eşit derecede eşleşen öğrenci çiftlerinin sayısını temsil eden bir tamsayı.\n */\n\nfunction countEvenlyMatchedPairs($N, $students) ",
      "vi": "<?php\n\n/**\n * Đếm số cặp học sinh có điểm thi tương đồng.\n * Hai học sinh được coi là tương đồng nếu chênh lệch điểm của từng môn\n * không lớn hơn 5 và tổng chênh lệch điểm không lớn hơn 10.\n * Đầu vào: Một số nguyên N đại diện cho số lượng học sinh, tiếp theo là N dòng, mỗi dòng gồm ba số nguyên\n *         đại diện cho điểm của mỗi học sinh trong các môn Ngữ văn, Toán và Tiếng Anh tương ứng.\n * Đầu ra: Một số nguyên đại diện cho số cặp học sinh có điểm tương đồng.\n */\n\nfunction countEvenlyMatchedPairs($N, $students) "
    },
    "prompt_bertscore": {
      "es": "0.9713080400898915",
      "arb": "0.9708132518107335",
      "sw": "0.9429040942322835",
      "tr": "0.9661770200869982",
      "vi": "0.924437626337851"
    },
    "canonical_solution": "{\n    $count = 0;\n    for ($i = 0; $i < $N - 1; $i++) {\n        for ($j = $i + 1; $j < $N; $j++) {\n            $diff = abs($students[$i][0] - $students[$j][0]) <= 5 &&\n                    abs($students[$i][1] - $students[$j][1]) <= 5 &&\n                    abs($students[$i][2] - $students[$j][2]) <= 5 &&\n                    abs(array_sum($students[$i]) - array_sum($students[$j])) <= 10;\n            if ($diff) {\n                $count++;\n            }\n        }\n    }\n    return $count;\n}",
    "instruction": {
      "en": "function countEvenlyMatchedPairs($N, $students)\n{\n    $count = 0;\n    for ($i = 0; $i < $N - 1; $i++) {\n        for ($j = $i + 1; $j < $N; $j++) {\n            $diff = abs($students[$i][0] - $students[$j][0]) <= 5 &&\n                    abs($students[$i][1] - $students[$j][1]) <= 5 &&\n                    abs($students[$i][2] - $students[$j][2]) <= 5 &&\n                    abs(array_sum($students[$i]) - array_sum($students[$j])) <= 10;\n            if ($diff) {\n                $count++;\n            }\n        }\n    }\n    return $count;\n}\n\nProvide a concise natural language description (docstring) of the PHP code in English using at most 500 characters.",
      "es": "function countEvenlyMatchedPairs($N, $students)\n{\n    $count = 0;\n    for ($i = 0; $i < $N - 1; $i++) {\n        for ($j = $i + 1; $j < $N; $j++) {\n            $diff = abs($students[$i][0] - $students[$j][0]) <= 5 &&\n                    abs($students[$i][1] - $students[$j][1]) <= 5 &&\n                    abs($students[$i][2] - $students[$j][2]) <= 5 &&\n                    abs(array_sum($students[$i]) - array_sum($students[$j])) <= 10;\n            if ($diff) {\n                $count++;\n            }\n        }\n    }\n    return $count;\n}\n\nProporcione una descripción concisa en lenguaje natural (docstring) del código PHP en español utilizando un máximo de 500 caracteres.",
      "arb": "function countEvenlyMatchedPairs($N, $students)\n{\n    $count = 0;\n    for ($i = 0; $i < $N - 1; $i++) {\n        for ($j = $i + 1; $j < $N; $j++) {\n            $diff = abs($students[$i][0] - $students[$j][0]) <= 5 &&\n                    abs($students[$i][1] - $students[$j][1]) <= 5 &&\n                    abs($students[$i][2] - $students[$j][2]) <= 5 &&\n                    abs(array_sum($students[$i]) - array_sum($students[$j])) <= 10;\n            if ($diff) {\n                $count++;\n            }\n        }\n    }\n    return $count;\n}\n\nيرجى تقديم وصف موجز بلغة طبيعية (docstring) للكود المكتوب بلغة PHP باللغة العربية الفصحى، بحيث لا يتجاوز 500 حرف.",
      "sw": "function countEvenlyMatchedPairs($N, $students)\n{\n    $count = 0;\n    for ($i = 0; $i < $N - 1; $i++) {\n        for ($j = $i + 1; $j < $N; $j++) {\n            $diff = abs($students[$i][0] - $students[$j][0]) <= 5 &&\n                    abs($students[$i][1] - $students[$j][1]) <= 5 &&\n                    abs($students[$i][2] - $students[$j][2]) <= 5 &&\n                    abs(array_sum($students[$i]) - array_sum($students[$j])) <= 10;\n            if ($diff) {\n                $count++;\n            }\n        }\n    }\n    return $count;\n}\n\nToa maelezo mafupi ya lugha ya asili (docstring) ya msimbo wa PHP kwa Kiswahili kwa kutumia herufi zisizozidi 500.",
      "tr": "function countEvenlyMatchedPairs($N, $students)\n{\n    $count = 0;\n    for ($i = 0; $i < $N - 1; $i++) {\n        for ($j = $i + 1; $j < $N; $j++) {\n            $diff = abs($students[$i][0] - $students[$j][0]) <= 5 &&\n                    abs($students[$i][1] - $students[$j][1]) <= 5 &&\n                    abs($students[$i][2] - $students[$j][2]) <= 5 &&\n                    abs(array_sum($students[$i]) - array_sum($students[$j])) <= 10;\n            if ($diff) {\n                $count++;\n            }\n        }\n    }\n    return $count;\n}\n\nPHP kodunun işlevselliğini açıklayan en fazla 500 karakterlik kısa bir doğal dil tanımı (docstring) sağlayın.",
      "vi": "function countEvenlyMatchedPairs($N, $students)\n{\n    $count = 0;\n    for ($i = 0; $i < $N - 1; $i++) {\n        for ($j = $i + 1; $j < $N; $j++) {\n            $diff = abs($students[$i][0] - $students[$j][0]) <= 5 &&\n                    abs($students[$i][1] - $students[$j][1]) <= 5 &&\n                    abs($students[$i][2] - $students[$j][2]) <= 5 &&\n                    abs(array_sum($students[$i]) - array_sum($students[$j])) <= 10;\n            if ($diff) {\n                $count++;\n            }\n        }\n    }\n    return $count;\n}\n\nCung cấp mô tả ngắn gọn bằng ngôn ngữ tự nhiên (docstring) cho mã PHP bằng tiếng Việt, sử dụng tối đa 500 ký tự."
    },
    "instruction_bertscore": {
      "es": "0.9687069752502395",
      "arb": "0.8833251100712498",
      "sw": "0.9428367585331127",
      "tr": "0.8671083298724184",
      "vi": "0.9072455709681383"
    },
    "level": "",
    "test": "function main(){\n    assert(countEvenlyMatchedPairs(3, [[90, 90, 90], [85, 95, 90], [80, 100, 91]]) === 2);\n    assert(countEvenlyMatchedPairs(3, [[100, 100, 100], [85, 95, 90], [80, 100, 91]]) === 1);\n    assert(countEvenlyMatchedPairs(4, [[100, 100, 100],[100, 100, 100],[100, 100, 100],[100, 100, 100]]) === 6);\n    \n}\n\n\nmain();\n?>",
    "entry_point": "countEvenlyMatchedPairs",
    "signature": "function countEvenlyMatchedPairs($N, $students)",
    "docstring": {
      "en": "Counts the number of evenly matched pairs of students based on their exam scores.\n  Two students are considered evenly matched if the difference in each subject's score\n  is not greater than 5 and the total score difference is not greater than 10.\n  Input: An integer N representing the number of students followed by N lines of three integers each\n          representing the scores of each student in Chinese, Mathematics, and English respectively.\n  Output: An integer representing the number of evenly matched pairs of students.",
      "es": "Cuenta el número de pares de estudiantes emparejados uniformemente según sus puntajes de examen.\n  Se considera que dos estudiantes están emparejados uniformemente si la diferencia en el puntaje de cada materia\n  no es mayor que 5 y la diferencia total de puntajes no es mayor que 10.\n  Entrada: Un entero N que representa el número de estudiantes seguido de N líneas de tres enteros cada una\n          representando los puntajes de cada estudiante en Chino, Matemáticas e Inglés respectivamente.\n  Salida: Un entero que representa el número de pares de estudiantes emparejados uniformemente.",
      "arb": "يحسب عدد الأزواج المتطابقة من الطلاب بناءً على درجاتهم في الامتحانات.\nيعتبر الطالبان متطابقين إذا لم يكن الفرق في درجات كل مادة أكبر من 5 ولم يكن الفرق في الدرجات الإجمالية أكبر من 10.\nالمدخلات: عدد صحيح N يمثل عدد الطلاب يليه N سطرًا يحتوي كل منها على ثلاثة أعداد صحيحة\n          تمثل درجات كل طالب في اللغة الصينية والرياضيات والإنجليزية على التوالي.\nالمخرجات: عدد صحيح يمثل عدد الأزواج المتطابقة من الطلاب.",
      "sw": "Hesabu idadi ya jozi za wanafunzi waliolingana vizuri kulingana na alama zao za mtihani.\n  Wanafunzi wawili wanachukuliwa kuwa wamefanana vizuri ikiwa tofauti ya alama katika kila somo\n  haizidi 5 na tofauti ya jumla ya alama haizidi 10.\n  Ingizo: Nambari ya mzima N inayoashiria idadi ya wanafunzi ikifuatiwa na mistari N ya nambari tatu kila moja\n          inayoashiria alama za kila mwanafunzi katika Kichina, Hisabati, na Kiingereza mtawalia.\n  Tokeo: Nambari ya mzima inayoashiria idadi ya jozi za wanafunzi waliolingana vizuri.",
      "tr": "Öğrencilerin sınav puanlarına göre eşit derecede eşleşmiş çiftlerin sayısını sayar.\n  İki öğrenci, her dersin puan farkı 5'ten büyük değilse ve toplam puan farkı 10'dan büyük değilse eşit derecede eşleşmiş kabul edilir.\n  Girdi: Her biri sırasıyla öğrencinin Çince, Matematik ve İngilizce puanlarını temsil eden üç tam sayıdan oluşan N satırını takip eden, öğrenci sayısını temsil eden bir tam sayı N.\n  Çıktı: Eşit derecede eşleşmiş öğrenci çiftlerinin sayısını temsil eden bir tam sayı.",
      "vi": "Đếm số cặp học sinh có điểm thi tương đồng nhau.\n  Hai học sinh được coi là tương đồng nếu chênh lệch điểm của từng môn không lớn hơn 5\n  và chênh lệch tổng điểm không lớn hơn 10.\n  Đầu vào: Một số nguyên N đại diện cho số lượng học sinh, tiếp theo là N dòng, mỗi dòng gồm ba số nguyên\n          đại diện cho điểm của mỗi học sinh trong các môn Tiếng Trung, Toán và Tiếng Anh tương ứng.\n  Đầu ra: Một số nguyên đại diện cho số cặp học sinh có điểm tương đồng nhau."
    },
    "docstring_bertscore": {
      "es": "0.9684652420765201",
      "arb": "0.9481711760461856",
      "sw": "0.9230360903692688",
      "tr": "0.9610237534814291",
      "vi": "0.9164463288480553"
    }
  },
  {
    "task_id": "PHP/42",
    "prompt": {
      "en": "<?php\n\n\n/**\n * Calculates the total number of cigarettes Peter can smoke.\n * Peter starts with a certain number of cigarettes and can exchange a specific number of cigarette butts for a new cigarette.\n * This process repeats until he can no longer exchange butts for new cigarettes.\n *\n * Parameters:\n * - $initialCigarettes (int): The initial number of cigarettes Peter has.\n * - $buttsRequiredForNew (int): The number of cigarette butts required to exchange for a new cigarette.\n *\n * Returns:\n * int: The total number of cigarettes Peter can smoke.\n *\n * Example:\n * - With 4 initial cigarettes and 3 butts required for a new one, Peter can smoke 5 cigarettes in total.\n * - With 10 initial cigarettes and 3 butts required for a new one, Peter can smoke 14 cigarettes in total.\n */\nfunction calculateTotalCigarettes($initialCigarettes, $buttsRequiredForNew): int ",
      "es": "<?php\n\n\n/**\n * Calcula el número total de cigarrillos que Peter puede fumar.\n * Peter comienza con un cierto número de cigarrillos y puede intercambiar una cantidad específica de colillas de cigarrillo por un cigarrillo nuevo.\n * Este proceso se repite hasta que ya no pueda intercambiar colillas por cigarrillos nuevos.\n *\n * Parámetros:\n * - $initialCigarettes (int): El número inicial de cigarrillos que Peter tiene.\n * - $buttsRequiredForNew (int): El número de colillas de cigarrillo requeridas para intercambiar por un cigarrillo nuevo.\n *\n * Retorna:\n * int: El número total de cigarrillos que Peter puede fumar.\n *\n * Ejemplo:\n * - Con 4 cigarrillos iniciales y 3 colillas requeridas para uno nuevo, Peter puede fumar 5 cigarrillos en total.\n * - Con 10 cigarrillos iniciales y 3 colillas requeridas para uno nuevo, Peter puede fumar 14 cigarrillos en total.\n */\nfunction calculateTotalCigarettes($initialCigarettes, $buttsRequiredForNew): int ",
      "arb": "<?php\n\n\n/**\n * يحسب العدد الإجمالي للسجائر التي يمكن لبيتر تدخينها.\n * يبدأ بيتر بعدد معين من السجائر ويمكنه تبادل عدد محدد من أعقاب السجائر للحصول على سيجارة جديدة.\n * تتكرر هذه العملية حتى لا يتمكن من تبادل الأعقاب للحصول على سجائر جديدة.\n *\n * المعاملات:\n * - $initialCigarettes (int): العدد الأولي للسجائر التي يمتلكها بيتر.\n * - $buttsRequiredForNew (int): عدد أعقاب السجائر المطلوبة للتبادل للحصول على سيجارة جديدة.\n *\n * يعيد:\n * int: العدد الإجمالي للسجائر التي يمكن لبيتر تدخينها.\n *\n * مثال:\n * - مع 4 سجائر أولية و3 أعقاب مطلوبة لسيجارة جديدة، يمكن لبيتر تدخين 5 سجائر في المجموع.\n * - مع 10 سجائر أولية و3 أعقاب مطلوبة لسيجارة جديدة، يمكن لبيتر تدخين 14 سيجارة في المجموع.\n */\nfunction calculateTotalCigarettes($initialCigarettes, $buttsRequiredForNew): int ",
      "sw": "<?php\n\n\n/**\n * Inahesabu jumla ya sigara ambazo Peter anaweza kuvuta.\n * Peter anaanza na idadi fulani ya sigara na anaweza kubadilisha idadi maalum ya vishungi vya sigara kwa sigara mpya.\n * Mchakato huu unarudiwa hadi pale ambapo hawezi tena kubadilisha vishungi kwa sigara mpya.\n *\n * Vigezo:\n * - $initialCigarettes (int): Idadi ya awali ya sigara ambazo Peter anazo.\n * - $buttsRequiredForNew (int): Idadi ya vishungi vya sigara vinavyohitajika kubadilishwa kwa sigara mpya.\n *\n * Inarudisha:\n * int: Jumla ya sigara ambazo Peter anaweza kuvuta.\n *\n * Mfano:\n * - Akiwa na sigara 4 za awali na vishungi 3 vinavyohitajika kwa moja mpya, Peter anaweza kuvuta sigara 5 kwa jumla.\n * - Akiwa na sigara 10 za awali na vishungi 3 vinavyohitajika kwa moja mpya, Peter anaweza kuvuta sigara 14 kwa jumla.\n */\nfunction calculateTotalCigarettes($initialCigarettes, $buttsRequiredForNew): int ",
      "tr": "<?php\n\n\n/**\n * Peter'ın içebileceği toplam sigara sayısını hesaplar.\n * Peter belirli bir sayıda sigara ile başlar ve belirli bir sayıda sigara izmaritini yeni bir sigara ile değiştirebilir.\n * Bu süreç, izmaritleri yeni sigaralarla değiştiremediği ana kadar tekrar eder.\n *\n * Parametreler:\n * - $initialCigarettes (int): Peter'ın sahip olduğu başlangıç sigara sayısı.\n * - $buttsRequiredForNew (int): Yeni bir sigara ile değiştirmek için gereken sigara izmariti sayısı.\n *\n * Döndürür:\n * int: Peter'ın içebileceği toplam sigara sayısı.\n *\n * Örnek:\n * - 4 başlangıç sigarası ve yeni bir tane için gereken 3 izmarit ile, Peter toplamda 5 sigara içebilir.\n * - 10 başlangıç sigarası ve yeni bir tane için gereken 3 izmarit ile, Peter toplamda 14 sigara içebilir.\n */\nfunction calculateTotalCigarettes($initialCigarettes, $buttsRequiredForNew): int ",
      "vi": "<?php\n\n\n/**\n * Tính tổng số điếu thuốc mà Peter có thể hút.\n * Peter bắt đầu với một số lượng điếu thuốc nhất định và có thể đổi một số lượng đầu lọc thuốc lá nhất định để lấy một điếu thuốc mới.\n * Quá trình này lặp lại cho đến khi anh ấy không thể đổi đầu lọc lấy điếu thuốc mới nữa.\n *\n * Tham số:\n * - $initialCigarettes (int): Số lượng điếu thuốc ban đầu mà Peter có.\n * - $buttsRequiredForNew (int): Số lượng đầu lọc thuốc lá cần để đổi lấy một điếu thuốc mới.\n *\n * Trả về:\n * int: Tổng số điếu thuốc mà Peter có thể hút.\n *\n * Ví dụ:\n * - Với 4 điếu thuốc ban đầu và 3 đầu lọc cần cho một điếu mới, Peter có thể hút tổng cộng 5 điếu thuốc.\n * - Với 10 điếu thuốc ban đầu và 3 đầu lọc cần cho một điếu mới, Peter có thể hút tổng cộng 14 điếu thuốc.\n */\nfunction calculateTotalCigarettes($initialCigarettes, $buttsRequiredForNew): int "
    },
    "prompt_bertscore": {
      "es": "0.989023089252869",
      "arb": "0.9912872769662857",
      "sw": "0.9703019772099497",
      "tr": "0.991420160691198",
      "vi": "0.9725528566878371"
    },
    "canonical_solution": "{\n    $totalSmoked = $initialCigarettes;\n    $currentButts = $initialCigarettes;\n    \n    while ($currentButts >= $buttsRequiredForNew) {\n        $newCigarettes = intdiv($currentButts, $buttsRequiredForNew);\n        $totalSmoked += $newCigarettes;\n        $currentButts = ($currentButts % $buttsRequiredForNew) + $newCigarettes;\n    }\n    \n    return $totalSmoked;\n}",
    "instruction": {
      "en": "function calculateTotalCigarettes($initialCigarettes, $buttsRequiredForNew): int\n{\n    $totalSmoked = $initialCigarettes;\n    $currentButts = $initialCigarettes;\n    \n    while ($currentButts >= $buttsRequiredForNew) {\n        $newCigarettes = intdiv($currentButts, $buttsRequiredForNew);\n        $totalSmoked += $newCigarettes;\n        $currentButts = ($currentButts % $buttsRequiredForNew) + $newCigarettes;\n    }\n    \n    return $totalSmoked;\n}\n\nProvide a concise natural language description (docstring) of the PHP code in English using at most 500 characters.",
      "es": "function calculateTotalCigarettes($initialCigarettes, $buttsRequiredForNew): int\n{\n    $totalSmoked = $initialCigarettes;\n    $currentButts = $initialCigarettes;\n    \n    while ($currentButts >= $buttsRequiredForNew) {\n        $newCigarettes = intdiv($currentButts, $buttsRequiredForNew);\n        $totalSmoked += $newCigarettes;\n        $currentButts = ($currentButts % $buttsRequiredForNew) + $newCigarettes;\n    }\n    \n    return $totalSmoked;\n}\n\nProporcione una descripción concisa en lenguaje natural (docstring) del código PHP en español utilizando un máximo de 500 caracteres.",
      "arb": "function calculateTotalCigarettes($initialCigarettes, $buttsRequiredForNew): int\n{\n    $totalSmoked = $initialCigarettes;\n    $currentButts = $initialCigarettes;\n    \n    while ($currentButts >= $buttsRequiredForNew) {\n        $newCigarettes = intdiv($currentButts, $buttsRequiredForNew);\n        $totalSmoked += $newCigarettes;\n        $currentButts = ($currentButts % $buttsRequiredForNew) + $newCigarettes;\n    }\n    \n    return $totalSmoked;\n}\n\nيرجى تقديم وصف موجز بلغة طبيعية (docstring) للكود المكتوب بلغة PHP باللغة العربية الفصحى، بحيث لا يتجاوز 500 حرف.",
      "sw": "function calculateTotalCigarettes($initialCigarettes, $buttsRequiredForNew): int\n{\n    $totalSmoked = $initialCigarettes;\n    $currentButts = $initialCigarettes;\n    \n    while ($currentButts >= $buttsRequiredForNew) {\n        $newCigarettes = intdiv($currentButts, $buttsRequiredForNew);\n        $totalSmoked += $newCigarettes;\n        $currentButts = ($currentButts % $buttsRequiredForNew) + $newCigarettes;\n    }\n    \n    return $totalSmoked;\n}\n\nToa maelezo mafupi ya lugha asilia (docstring) ya msimbo wa PHP kwa Kiswahili kwa kutumia herufi zisizozidi 500.",
      "tr": "function calculateTotalCigarettes($initialCigarettes, $buttsRequiredForNew): int\n{\n    $totalSmoked = $initialCigarettes;\n    $currentButts = $initialCigarettes;\n    \n    while ($currentButts >= $buttsRequiredForNew) {\n        $newCigarettes = intdiv($currentButts, $buttsRequiredForNew);\n        $totalSmoked += $newCigarettes;\n        $currentButts = ($currentButts % $buttsRequiredForNew) + $newCigarettes;\n    }\n    \n    return $totalSmoked;\n}\n\nPHP kodunun işlevini açıklayan kısa bir doğal dil açıklaması (docstring) sağlayın. Açıklama, en fazla 500 karakter kullanılarak Türkçe olarak yazılmalıdır.",
      "vi": "function calculateTotalCigarettes($initialCigarettes, $buttsRequiredForNew): int\n{\n    $totalSmoked = $initialCigarettes;\n    $currentButts = $initialCigarettes;\n    \n    while ($currentButts >= $buttsRequiredForNew) {\n        $newCigarettes = intdiv($currentButts, $buttsRequiredForNew);\n        $totalSmoked += $newCigarettes;\n        $currentButts = ($currentButts % $buttsRequiredForNew) + $newCigarettes;\n    }\n    \n    return $totalSmoked;\n}\n\nCung cấp mô tả ngắn gọn bằng ngôn ngữ tự nhiên (docstring) cho mã PHP bằng tiếng Việt với tối đa 500 ký tự."
    },
    "instruction_bertscore": {
      "es": "0.9687069752502395",
      "arb": "0.8833251100712498",
      "sw": "0.9428367585331127",
      "tr": "0.8711236430250386",
      "vi": "0.9017250367880356"
    },
    "level": "",
    "test": "function main(){\n    assert(calculateTotalCigarettes(4, 3) === 5, 'Test Case 1 Failed');\n    assert(calculateTotalCigarettes(10, 3) === 14, 'Test Case 2 Failed');\n    assert(calculateTotalCigarettes(1, 2) === 1, 'Test Case 3 Failed');\n    assert(calculateTotalCigarettes(20, 5) === 24, 'Test Case 4 Failed');\n    assert(calculateTotalCigarettes(0, 3) === 0, 'Test Case 5 Failed');\n}\n\n\nmain();\n?>",
    "entry_point": "calculateTotalCigarettes",
    "signature": "function calculateTotalCigarettes($initialCigarettes, $buttsRequiredForNew): int",
    "docstring": {
      "en": "Calculates the total number of cigarettes Peter can smoke.\n  Peter starts with a certain number of cigarettes and can exchange a specific number of cigarette butts for a new cigarette.\n  This process repeats until he can no longer exchange butts for new cigarettes.\n \n  Parameters:\n  - $initialCigarettes (int): The initial number of cigarettes Peter has.\n  - $buttsRequiredForNew (int): The number of cigarette butts required to exchange for a new cigarette.\n \n  Returns:\n  int: The total number of cigarettes Peter can smoke.\n \n  Example:\n  - With 4 initial cigarettes and 3 butts required for a new one, Peter can smoke 5 cigarettes in total.\n  - With 10 initial cigarettes and 3 butts required for a new one, Peter can smoke 14 cigarettes in total.",
      "es": "Calcula el número total de cigarrillos que Peter puede fumar. \n  Peter comienza con una cierta cantidad de cigarrillos y puede intercambiar un número específico de colillas de cigarrillo por un cigarrillo nuevo. \n  Este proceso se repite hasta que ya no pueda intercambiar colillas por cigarrillos nuevos.\n\n  Parámetros:\n  - $initialCigarettes (int): El número inicial de cigarrillos que tiene Peter.\n  - $buttsRequiredForNew (int): El número de colillas de cigarrillo requerido para intercambiar por un cigarrillo nuevo.\n\n  Devuelve:\n  int: El número total de cigarrillos que Peter puede fumar.\n\n  Ejemplo:\n  - Con 4 cigarrillos iniciales y 3 colillas requeridas para uno nuevo, Peter puede fumar 5 cigarrillos en total.\n  - Con 10 cigarrillos iniciales y 3 colillas requeridas para uno nuevo, Peter puede fumar 14 cigarrillos en total.",
      "arb": "يحسب العدد الإجمالي للسجائر التي يمكن لبيتر تدخينها.\n  يبدأ بيتر بعدد معين من السجائر ويمكنه تبديل عدد محدد من أعقاب السجائر للحصول على سيجارة جديدة.\n  تتكرر هذه العملية حتى لا يتمكن من تبديل الأعقاب للحصول على سجائر جديدة.\n\n  المعاملات:\n  - $initialCigarettes (int): عدد السجائر الأولي الذي يملكه بيتر.\n  - $buttsRequiredForNew (int): عدد أعقاب السجائر المطلوب لتبديلها بسيجارة جديدة.\n\n  العوائد:\n  int: العدد الإجمالي للسجائر التي يمكن لبيتر تدخينها.\n\n  مثال:\n  - مع 4 سجائر أولية و3 أعقاب مطلوبة لواحدة جديدة، يمكن لبيتر تدخين 5 سجائر في المجموع.\n  - مع 10 سجائر أولية و3 أعقاب مطلوبة لواحدة جديدة، يمكن لبيتر تدخين 14 سيجارة في المجموع.",
      "sw": "Hesabu jumla ya sigara ambazo Peter anaweza kuvuta.  \nPeter anaanza na idadi fulani ya sigara na anaweza kubadilisha idadi maalum ya vishungi vya sigara kwa sigara mpya.  \nMchakato huu unarudiwa hadi pale ambapo hawezi tena kubadilisha vishungi kwa sigara mpya.  \n\nVigezo:  \n- $initialCigarettes (int): Idadi ya awali ya sigara ambazo Peter anazo.  \n- $buttsRequiredForNew (int): Idadi ya vishungi vya sigara vinavyohitajika kubadilishwa kwa sigara mpya.  \n\nInarejesha:  \nint: Jumla ya sigara ambazo Peter anaweza kuvuta.  \n\nMfano:  \n- Akiwa na sigara 4 za awali na vishungi 3 vinavyohitajika kwa sigara mpya, Peter anaweza kuvuta sigara 5 kwa jumla.  \n- Akiwa na sigara 10 za awali na vishungi 3 vinavyohitajika kwa sigara mpya, Peter anaweza kuvuta sigara 14 kwa jumla.",
      "tr": "Peter'ın içebileceği toplam sigara sayısını hesaplar.\n  Peter belirli bir sayıda sigara ile başlar ve belirli bir sayıda sigara izmaritini yeni bir sigara ile değiştirebilir.\n  Bu işlem, izmaritleri yeni sigaralarla değiştiremeyeceği ana kadar tekrar eder.\n \n  Parametreler:\n  - $initialCigarettes (int): Peter'ın sahip olduğu başlangıç sigara sayısı.\n  - $buttsRequiredForNew (int): Yeni bir sigara ile değiştirmek için gereken sigara izmariti sayısı.\n \n  Döndürür:\n  int: Peter'ın içebileceği toplam sigara sayısı.\n \n  Örnek:\n  - 4 başlangıç sigarası ve yeni bir sigara için gereken 3 izmarit ile, Peter toplamda 5 sigara içebilir.\n  - 10 başlangıç sigarası ve yeni bir sigara için gereken 3 izmarit ile, Peter toplamda 14 sigara içebilir.",
      "vi": "Tính tổng số điếu thuốc mà Peter có thể hút.  \nPeter bắt đầu với một số lượng điếu thuốc nhất định và có thể đổi một số lượng đầu lọc thuốc lá cụ thể để lấy một điếu thuốc mới.  \nQuá trình này lặp lại cho đến khi anh ta không thể đổi đầu lọc lấy điếu thuốc mới nữa.\n\nTham số:\n- $initialCigarettes (int): Số lượng điếu thuốc ban đầu mà Peter có.\n- $buttsRequiredForNew (int): Số lượng đầu lọc thuốc lá cần thiết để đổi lấy một điếu thuốc mới.\n\nTrả về:\nint: Tổng số điếu thuốc mà Peter có thể hút.\n\nVí dụ:\n- Với 4 điếu thuốc ban đầu và 3 đầu lọc cần thiết cho một điếu mới, Peter có thể hút tổng cộng 5 điếu thuốc.\n- Với 10 điếu thuốc ban đầu và 3 đầu lọc cần thiết cho một điếu mới, Peter có thể hút tổng cộng 14 điếu thuốc."
    },
    "docstring_bertscore": {
      "es": "0.9917528665794314",
      "arb": "0.977932760558167",
      "sw": "0.9753295107843237",
      "tr": "0.9760135938166079",
      "vi": "0.9800886947139197"
    }
  },
  {
    "task_id": "PHP/43",
    "prompt": {
      "en": "<?php\n\n/**\n * Finds the length of the longest sequence of consecutive numbers in an array.\n * Consecutive numbers are numbers which come one after the other in sequence without any gaps.\n * For example, in the array [1, 3, 5, 4, 2, 6], the longest sequence of consecutive numbers is [1, 2, 3, 4, 5, 6], which has a length of 6.\n * Input: An array of integers.\n * Output: The length of the longest sequence of consecutive numbers found in the array.\n */\nfunction findLongestConsecutiveSequence(array $numbers): int ",
      "es": "<?php\n\n/**\n * Encuentra la longitud de la secuencia más larga de números consecutivos en un arreglo.\n * Los números consecutivos son números que vienen uno tras otro en secuencia sin ningún hueco.\n * Por ejemplo, en el arreglo [1, 3, 5, 4, 2, 6], la secuencia más larga de números consecutivos es [1, 2, 3, 4, 5, 6], que tiene una longitud de 6.\n * Entrada: Un arreglo de enteros.\n * Salida: La longitud de la secuencia más larga de números consecutivos encontrada en el arreglo.\n */\nfunction findLongestConsecutiveSequence(array $numbers): int ",
      "arb": "<?php\n\n/**\n * يجد طول أطول تسلسل من الأرقام المتتالية في مصفوفة.\n * الأرقام المتتالية هي الأرقام التي تأتي واحدة تلو الأخرى في تسلسل بدون أي فجوات.\n * على سبيل المثال، في المصفوفة [1, 3, 5, 4, 2, 6]، أطول تسلسل من الأرقام المتتالية هو [1, 2, 3, 4, 5, 6]، والذي له طول 6.\n * المدخل: مصفوفة من الأعداد الصحيحة.\n * المخرج: طول أطول تسلسل من الأرقام المتتالية الموجود في المصفوفة.\n */\nfunction findLongestConsecutiveSequence(array $numbers): int ",
      "sw": "<?php\n\n/**\n * Inapata urefu wa mlolongo mrefu zaidi wa namba zinazofuatana katika safu.\n * Namba zinazofuatana ni namba ambazo zinakuja moja baada ya nyingine katika mlolongo bila mapengo yoyote.\n * Kwa mfano, katika safu [1, 3, 5, 4, 2, 6], mlolongo mrefu zaidi wa namba zinazofuatana ni [1, 2, 3, 4, 5, 6], ambao una urefu wa 6.\n * Ingizo: Safu ya namba nzima.\n * Tokeo: Urefu wa mlolongo mrefu zaidi wa namba zinazofuatana uliopatikana katika safu.\n */\nfunction findLongestConsecutiveSequence(array $numbers): int ",
      "tr": "<?php\n\n/**\n * Bir dizideki ardışık sayıların en uzun dizisinin uzunluğunu bulur.\n * Ardışık sayılar, aralarında boşluk olmadan sırayla gelen sayılardır.\n * Örneğin, [1, 3, 5, 4, 2, 6] dizisinde, ardışık sayıların en uzun dizisi [1, 2, 3, 4, 5, 6] olup, uzunluğu 6'dır.\n * Girdi: Bir tamsayı dizisi.\n * Çıktı: Dizide bulunan ardışık sayıların en uzun dizisinin uzunluğu.\n */\nfunction findLongestConsecutiveSequence(array $numbers): int ",
      "vi": "<?php\n\n/**\n * Tìm độ dài của dãy số liên tiếp dài nhất trong một mảng.\n * Các số liên tiếp là các số xuất hiện liền kề nhau trong dãy mà không có khoảng trống.\n * Ví dụ, trong mảng [1, 3, 5, 4, 2, 6], dãy số liên tiếp dài nhất là [1, 2, 3, 4, 5, 6], có độ dài là 6.\n * Đầu vào: Một mảng các số nguyên.\n * Đầu ra: Độ dài của dãy số liên tiếp dài nhất được tìm thấy trong mảng.\n */\nfunction findLongestConsecutiveSequence(array $numbers): int "
    },
    "prompt_bertscore": {
      "es": "0.9959137758013503",
      "arb": "0.9911168520993577",
      "sw": "0.9863548873444273",
      "tr": "0.9726648842227408",
      "vi": "0.9463697971205802"
    },
    "canonical_solution": "{\n    if (empty($numbers)) {\n        return 0;\n    }\n    sort($numbers);\n    $longest = 1;\n    $currentLength = 1;\n    for ($i = 1; $i < count($numbers); $i++) {\n        if ($numbers[$i] == $numbers[$i - 1] + 1) {\n            $currentLength++;\n        } elseif ($numbers[$i] != $numbers[$i - 1]) {\n            $longest = max($longest, $currentLength);\n            $currentLength = 1;\n        }\n    }\n    return max($longest, $currentLength);\n}",
    "instruction": {
      "en": "function findLongestConsecutiveSequence(array $numbers): int\n{\n    if (empty($numbers)) {\n        return 0;\n    }\n    sort($numbers);\n    $longest = 1;\n    $currentLength = 1;\n    for ($i = 1; $i < count($numbers); $i++) {\n        if ($numbers[$i] == $numbers[$i - 1] + 1) {\n            $currentLength++;\n        } elseif ($numbers[$i] != $numbers[$i - 1]) {\n            $longest = max($longest, $currentLength);\n            $currentLength = 1;\n        }\n    }\n    return max($longest, $currentLength);\n}\n\nProvide a concise natural language description (docstring) of the PHP code in English using at most 500 characters.",
      "es": "function findLongestConsecutiveSequence(array $numbers): int\n{\n    if (empty($numbers)) {\n        return 0;\n    }\n    sort($numbers);\n    $longest = 1;\n    $currentLength = 1;\n    for ($i = 1; $i < count($numbers); $i++) {\n        if ($numbers[$i] == $numbers[$i - 1] + 1) {\n            $currentLength++;\n        } elseif ($numbers[$i] != $numbers[$i - 1]) {\n            $longest = max($longest, $currentLength);\n            $currentLength = 1;\n        }\n    }\n    return max($longest, $currentLength);\n}\n\nProporcione una descripción concisa en lenguaje natural (docstring) del código PHP en español utilizando como máximo 500 caracteres.",
      "arb": "function findLongestConsecutiveSequence(array $numbers): int\n{\n    if (empty($numbers)) {\n        return 0;\n    }\n    sort($numbers);\n    $longest = 1;\n    $currentLength = 1;\n    for ($i = 1; $i < count($numbers); $i++) {\n        if ($numbers[$i] == $numbers[$i - 1] + 1) {\n            $currentLength++;\n        } elseif ($numbers[$i] != $numbers[$i - 1]) {\n            $longest = max($longest, $currentLength);\n            $currentLength = 1;\n        }\n    }\n    return max($longest, $currentLength);\n}\n\nيرجى تقديم وصف موجز بلغة طبيعية (docstring) لشيفرة PHP باللغة العربية الفصحى، باستخدام 500 حرف كحد أقصى.",
      "sw": "function findLongestConsecutiveSequence(array $numbers): int\n{\n    if (empty($numbers)) {\n        return 0;\n    }\n    sort($numbers);\n    $longest = 1;\n    $currentLength = 1;\n    for ($i = 1; $i < count($numbers); $i++) {\n        if ($numbers[$i] == $numbers[$i - 1] + 1) {\n            $currentLength++;\n        } elseif ($numbers[$i] != $numbers[$i - 1]) {\n            $longest = max($longest, $currentLength);\n            $currentLength = 1;\n        }\n    }\n    return max($longest, $currentLength);\n}\n\nToa maelezo mafupi ya lugha asilia (docstring) ya msimbo wa PHP kwa Kiswahili kwa kutumia herufi zisizozidi 500.",
      "tr": "function findLongestConsecutiveSequence(array $numbers): int\n{\n    if (empty($numbers)) {\n        return 0;\n    }\n    sort($numbers);\n    $longest = 1;\n    $currentLength = 1;\n    for ($i = 1; $i < count($numbers); $i++) {\n        if ($numbers[$i] == $numbers[$i - 1] + 1) {\n            $currentLength++;\n        } elseif ($numbers[$i] != $numbers[$i - 1]) {\n            $longest = max($longest, $currentLength);\n            $currentLength = 1;\n        }\n    }\n    return max($longest, $currentLength);\n}\n\nPHP kodunun işlevini açıklayan kısa bir doğal dil açıklaması (docstring) sağlayın. Açıklama, en fazla 500 karakter kullanılarak Türkçe olarak yazılmalıdır.",
      "vi": "function findLongestConsecutiveSequence(array $numbers): int\n{\n    if (empty($numbers)) {\n        return 0;\n    }\n    sort($numbers);\n    $longest = 1;\n    $currentLength = 1;\n    for ($i = 1; $i < count($numbers); $i++) {\n        if ($numbers[$i] == $numbers[$i - 1] + 1) {\n            $currentLength++;\n        } elseif ($numbers[$i] != $numbers[$i - 1]) {\n            $longest = max($longest, $currentLength);\n            $currentLength = 1;\n        }\n    }\n    return max($longest, $currentLength);\n}\n\nCung cấp mô tả ngắn gọn bằng ngôn ngữ tự nhiên (docstring) cho mã PHP bằng tiếng Việt, sử dụng tối đa 500 ký tự."
    },
    "instruction_bertscore": {
      "es": "0.9687069752502395",
      "arb": "0.924580242951434",
      "sw": "0.9428367585331127",
      "tr": "0.881863190466833",
      "vi": "0.9202302376067699"
    },
    "level": "",
    "test": "function main(){\n    assert(findLongestConsecutiveSequence([1, 5, 6, 2, 3, 4, 5, 6, 8, 9]) === 6);\n    assert(findLongestConsecutiveSequence([10, 4, 20, 1, 3, 2]) === 4);\n    assert(findLongestConsecutiveSequence([1, 2, 2, 3]) === 3);\n    assert(findLongestConsecutiveSequence([]) === 0);\n    assert(findLongestConsecutiveSequence([7]) === 1);\n    \n}\n\n\nmain();\n?>",
    "entry_point": "findLongestConsecutiveSequence",
    "signature": "function findLongestConsecutiveSequence(array $numbers): int",
    "docstring": {
      "en": "Finds the length of the longest sequence of consecutive numbers in an array.\n  Consecutive numbers are numbers which come one after the other in sequence without any gaps.\n  For example, in the array [1, 3, 5, 4, 2, 6], the longest sequence of consecutive numbers is [1, 2, 3, 4, 5, 6], which has a length of 6.\n  Input: An array of integers.\n  Output: The length of the longest sequence of consecutive numbers found in the array.",
      "es": "Encuentra la longitud de la secuencia más larga de números consecutivos en un arreglo.\n  Los números consecutivos son números que vienen uno tras otro en secuencia sin ningún hueco.\n  Por ejemplo, en el arreglo [1, 3, 5, 4, 2, 6], la secuencia más larga de números consecutivos es [1, 2, 3, 4, 5, 6], que tiene una longitud de 6.\n  Entrada: Un arreglo de enteros.\n  Salida: La longitud de la secuencia más larga de números consecutivos encontrada en el arreglo.",
      "arb": "يجد طول أطول تسلسل من الأرقام المتتالية في مصفوفة. الأرقام المتتالية هي الأرقام التي تأتي واحدة تلو الأخرى في تسلسل بدون أي فجوات. على سبيل المثال، في المصفوفة [1, 3, 5, 4, 2, 6]، أطول تسلسل من الأرقام المتتالية هو [1, 2, 3, 4, 5, 6]، والذي له طول 6. المدخلات: مصفوفة من الأعداد الصحيحة. المخرجات: طول أطول تسلسل من الأرقام المتتالية الموجود في المصفوفة.",
      "sw": "Inapata urefu wa mlolongo mrefu zaidi wa namba zinazofuatana katika safu.\n  Namba zinazofuatana ni namba ambazo zinakuja moja baada ya nyingine katika mlolongo bila mapengo yoyote.\n  Kwa mfano, katika safu [1, 3, 5, 4, 2, 6], mlolongo mrefu zaidi wa namba zinazofuatana ni [1, 2, 3, 4, 5, 6], ambao una urefu wa 6.\n  Ingizo: Safu ya namba za mzima.\n  Tokeo: Urefu wa mlolongo mrefu zaidi wa namba zinazofuatana uliopatikana katika safu.",
      "tr": "Dizideki ardışık sayıların en uzun dizisinin uzunluğunu bulur.\n  Ardışık sayılar, aralarında boşluk olmadan sırayla gelen sayılardır.\n  Örneğin, [1, 3, 5, 4, 2, 6] dizisinde, en uzun ardışık sayı dizisi [1, 2, 3, 4, 5, 6] olup, uzunluğu 6'dır.\n  Girdi: Bir tamsayı dizisi.\n  Çıktı: Dizide bulunan ardışık sayıların en uzun dizisinin uzunluğu.",
      "vi": "Tìm độ dài của dãy số liên tiếp dài nhất trong một mảng. \n  Các số liên tiếp là các số xuất hiện liền kề nhau trong dãy mà không có khoảng trống nào. \n  Ví dụ, trong mảng [1, 3, 5, 4, 2, 6], dãy số liên tiếp dài nhất là [1, 2, 3, 4, 5, 6], có độ dài là 6. \n  Đầu vào: Một mảng các số nguyên. \n  Đầu ra: Độ dài của dãy số liên tiếp dài nhất được tìm thấy trong mảng."
    },
    "docstring_bertscore": {
      "es": "0.9875224367241504",
      "arb": "0.9909384820171884",
      "sw": "0.9991107317841068",
      "tr": "0.9605045336654039",
      "vi": "0.9401047962723588"
    }
  },
  {
    "task_id": "PHP/44",
    "prompt": {
      "en": "<?php\n\n/**\n * Compares the area of a square and a rectangle to determine which is larger.\n * The square's side length is represented by $a, while the rectangle's dimensions are represented by $b and $c.\n * Input: Three integers $a, $b, and $c, where $a is the side length of the square, and $b and $c are the width and height of the rectangle, respectively.\n * Output: Returns a string \"Alice\" if the square's area is greater, \"Bob\" if the rectangle's area is greater, or \"Equal\" if both areas are the same.\n */\nfunction compareArea($a, $b, $c): string ",
      "es": "<?php\n\n/**\n * Compara el área de un cuadrado y un rectángulo para determinar cuál es mayor.\n * La longitud del lado del cuadrado está representada por $a, mientras que las dimensiones del rectángulo están representadas por $b y $c.\n * Entrada: Tres enteros $a, $b, y $c, donde $a es la longitud del lado del cuadrado, y $b y $c son el ancho y la altura del rectángulo, respectivamente.\n * Salida: Devuelve una cadena \"Alice\" si el área del cuadrado es mayor, \"Bob\" si el área del rectángulo es mayor, o \"Equal\" si ambas áreas son iguales.\n */\nfunction compareArea($a, $b, $c): string ",
      "arb": "<?php\n\n/**\n * يقارن بين مساحة المربع والمستطيل لتحديد أيهما أكبر.\n * طول ضلع المربع يُمثل بواسطة $a، بينما أبعاد المستطيل تُمثل بواسطة $b و$c.\n * المدخلات: ثلاثة أعداد صحيحة $a، $b، و$c، حيث $a هو طول ضلع المربع، و$b و$c هما عرض وارتفاع المستطيل، على التوالي.\n * المخرجات: يعيد سلسلة نصية \"Alice\" إذا كانت مساحة المربع أكبر، \"Bob\" إذا كانت مساحة المستطيل أكبر، أو \"Equal\" إذا كانت المساحتان متساويتين.\n */\nfunction compareArea($a, $b, $c): string ",
      "sw": "<?php\n\n/**\n * Inalinganisha eneo la mraba na mstatili ili kubaini lipi ni kubwa zaidi.\n * Urefu wa upande wa mraba unawakilishwa na $a, wakati vipimo vya mstatili vinawakilishwa na $b na $c.\n * Ingizo: Nambari tatu za mzima $a, $b, na $c, ambapo $a ni urefu wa upande wa mraba, na $b na $c ni upana na urefu wa mstatili, mtawalia.\n * Matokeo: Inarudisha kamba \"Alice\" ikiwa eneo la mraba ni kubwa zaidi, \"Bob\" ikiwa eneo la mstatili ni kubwa zaidi, au \"Equal\" ikiwa maeneo yote mawili ni sawa.\n */\nfunction compareArea($a, $b, $c): string ",
      "tr": "<?php\n\n/**\n * Bir karenin ve bir dikdörtgenin alanını karşılaştırarak hangisinin daha büyük olduğunu belirler.\n * Karenin kenar uzunluğu $a ile temsil edilirken, dikdörtgenin boyutları $b ve $c ile temsil edilir.\n * Girdi: Üç tamsayı $a, $b ve $c, burada $a karenin kenar uzunluğudur ve $b ile $c sırasıyla dikdörtgenin genişliği ve yüksekliğidir.\n * Çıktı: Karenin alanı daha büyükse \"Alice\", dikdörtgenin alanı daha büyükse \"Bob\" veya her iki alan da aynıysa \"Equal\" bir dize döndürür.\n */\nfunction compareArea($a, $b, $c): string ",
      "vi": "<?php\n\n/**\n * So sánh diện tích của một hình vuông và một hình chữ nhật để xác định cái nào lớn hơn.\n * Độ dài cạnh của hình vuông được biểu diễn bởi $a, trong khi kích thước của hình chữ nhật được biểu diễn bởi $b và $c.\n * Đầu vào: Ba số nguyên $a, $b và $c, trong đó $a là độ dài cạnh của hình vuông, và $b và $c là chiều rộng và chiều cao của hình chữ nhật, tương ứng.\n * Đầu ra: Trả về một chuỗi \"Alice\" nếu diện tích của hình vuông lớn hơn, \"Bob\" nếu diện tích của hình chữ nhật lớn hơn, hoặc \"Equal\" nếu cả hai diện tích đều bằng nhau.\n */\nfunction compareArea($a, $b, $c): string "
    },
    "prompt_bertscore": {
      "es": "0.9774973627629385",
      "arb": "0.9655509371259763",
      "sw": "0.9696280243270984",
      "tr": "0.9669069867373015",
      "vi": "0.9739657145881382"
    },
    "canonical_solution": "{\n    $squareArea = $a * $a;\n    $rectangleArea = $b * $c;\n    if ($squareArea > $rectangleArea) {\n        return \"Alice\";\n    } elseif ($squareArea < $rectangleArea) {\n        return \"Bob\";\n    } else {\n        return \"Equal\";\n    }\n}",
    "instruction": {
      "en": "function compareArea($a, $b, $c): string\n{\n    $squareArea = $a * $a;\n    $rectangleArea = $b * $c;\n    if ($squareArea > $rectangleArea) {\n        return \"Alice\";\n    } elseif ($squareArea < $rectangleArea) {\n        return \"Bob\";\n    } else {\n        return \"Equal\";\n    }\n}\n\nProvide a concise natural language description (docstring) of the PHP code in English using at most 500 characters.",
      "es": "function compareArea($a, $b, $c): string\n{\n    $squareArea = $a * $a;\n    $rectangleArea = $b * $c;\n    if ($squareArea > $rectangleArea) {\n        return \"Alice\";\n    } elseif ($squareArea < $rectangleArea) {\n        return \"Bob\";\n    } else {\n        return \"Equal\";\n    }\n}\n\nProporcione una descripción concisa en lenguaje natural (docstring) del código PHP en español utilizando como máximo 500 caracteres.",
      "arb": "function compareArea($a, $b, $c): string\n{\n    $squareArea = $a * $a;\n    $rectangleArea = $b * $c;\n    if ($squareArea > $rectangleArea) {\n        return \"Alice\";\n    } elseif ($squareArea < $rectangleArea) {\n        return \"Bob\";\n    } else {\n        return \"Equal\";\n    }\n}\n\nيرجى تقديم وصف موجز بلغة طبيعية (docstring) لشيفرة PHP باللغة العربية الفصحى باستخدام 500 حرف كحد أقصى.",
      "sw": "function compareArea($a, $b, $c): string\n{\n    $squareArea = $a * $a;\n    $rectangleArea = $b * $c;\n    if ($squareArea > $rectangleArea) {\n        return \"Alice\";\n    } elseif ($squareArea < $rectangleArea) {\n        return \"Bob\";\n    } else {\n        return \"Equal\";\n    }\n}\n\nToa maelezo mafupi ya lugha ya asili (docstring) ya msimbo wa PHP kwa Kiswahili kwa kutumia herufi zisizozidi 500.",
      "tr": "function compareArea($a, $b, $c): string\n{\n    $squareArea = $a * $a;\n    $rectangleArea = $b * $c;\n    if ($squareArea > $rectangleArea) {\n        return \"Alice\";\n    } elseif ($squareArea < $rectangleArea) {\n        return \"Bob\";\n    } else {\n        return \"Equal\";\n    }\n}\n\nPHP kodunun işlevini açıklayan, en fazla 500 karakterlik özlü bir doğal dil açıklaması (docstring) sağlayın.",
      "vi": "function compareArea($a, $b, $c): string\n{\n    $squareArea = $a * $a;\n    $rectangleArea = $b * $c;\n    if ($squareArea > $rectangleArea) {\n        return \"Alice\";\n    } elseif ($squareArea < $rectangleArea) {\n        return \"Bob\";\n    } else {\n        return \"Equal\";\n    }\n}\n\nCung cấp mô tả ngắn gọn bằng ngôn ngữ tự nhiên (docstring) cho mã PHP bằng tiếng Việt với tối đa 500 ký tự."
    },
    "instruction_bertscore": {
      "es": "0.9687069752502395",
      "arb": "0.9148910529645522",
      "sw": "0.91585798565943",
      "tr": "0.8853010851017848",
      "vi": "0.9150604846795749"
    },
    "level": "",
    "test": "function main(){\n    // Test cases\n    assert(compareArea(5, 4, 6) === \"Alice\"); \n    assert(compareArea(7, 5, 10) === \"Bob\"); \n    assert(compareArea(6, 3, 12) === \"Equal\"); \n\n}\n\n\nmain();\n?>",
    "entry_point": "compareArea",
    "signature": "function compareArea($a, $b, $c): string",
    "docstring": {
      "en": "Compares the area of a square and a rectangle to determine which is larger.\n  The square's side length is represented by $a, while the rectangle's dimensions are represented by $b and $c.\n  Input: Three integers $a, $b, and $c, where $a is the side length of the square, and $b and $c are the width and height of the rectangle, respectively.\n  Output: Returns a string \"Alice\" if the square's area is greater, \"Bob\" if the rectangle's area is greater, or \"Equal\" if both areas are the same.",
      "es": "Compara el área de un cuadrado y un rectángulo para determinar cuál es más grande.\n  La longitud del lado del cuadrado está representada por $a, mientras que las dimensiones del rectángulo están representadas por $b y $c.\n  Entrada: Tres enteros $a, $b, y $c, donde $a es la longitud del lado del cuadrado, y $b y $c son el ancho y la altura del rectángulo, respectivamente.\n  Salida: Devuelve una cadena \"Alice\" si el área del cuadrado es mayor, \"Bob\" si el área del rectángulo es mayor, o \"Equal\" si ambas áreas son iguales.",
      "arb": "يقارن بين مساحة المربع والمستطيل لتحديد أيهما أكبر.\n  طول ضلع المربع يُمثل بالرمز $a، بينما أبعاد المستطيل تُمثل بالرمزين $b و $c.\n  المدخلات: ثلاثة أعداد صحيحة $a، $b، و $c، حيث $a هو طول ضلع المربع، و $b و $c هما عرض وارتفاع المستطيل، على التوالي.\n  المخرجات: يعيد سلسلة نصية \"Alice\" إذا كانت مساحة المربع أكبر، \"Bob\" إذا كانت مساحة المستطيل أكبر، أو \"Equal\" إذا كانت المساحتان متساويتين.",
      "sw": "Inalinganisha eneo la mraba na mstatili ili kubaini lipi ni kubwa zaidi.\n  Urefu wa upande wa mraba unawakilishwa na $a, wakati vipimo vya mstatili vinawakilishwa na $b na $c.\n  Ingizo: Nambari tatu za mzima $a, $b, na $c, ambapo $a ni urefu wa upande wa mraba, na $b na $c ni upana na urefu wa mstatili, mtawalia.\n  Matokeo: Inarudisha kamba \"Alice\" ikiwa eneo la mraba ni kubwa zaidi, \"Bob\" ikiwa eneo la mstatili ni kubwa zaidi, au \"Equal\" ikiwa maeneo yote ni sawa.",
      "tr": "Kare ve dikdörtgenin alanlarını karşılaştırarak hangisinin daha büyük olduğunu belirler.\n  Karenin kenar uzunluğu $a ile, dikdörtgenin boyutları ise $b ve $c ile temsil edilir.\n  Girdi: $a, $b ve $c olmak üzere üç tamsayı, burada $a karenin kenar uzunluğunu, $b ve $c ise sırasıyla dikdörtgenin genişlik ve yüksekliğini temsil eder.\n  Çıktı: Karenin alanı daha büyükse \"Alice\", dikdörtgenin alanı daha büyükse \"Bob\" veya her iki alan da aynıysa \"Equal\" döndüren bir dize.",
      "vi": "So sánh diện tích của một hình vuông và một hình chữ nhật để xác định cái nào lớn hơn.  \nChiều dài cạnh của hình vuông được biểu diễn bởi $a, trong khi kích thước của hình chữ nhật được biểu diễn bởi $b và $c.  \nĐầu vào: Ba số nguyên $a, $b, và $c, trong đó $a là chiều dài cạnh của hình vuông, và $b và $c là chiều rộng và chiều cao của hình chữ nhật, tương ứng.  \nĐầu ra: Trả về một chuỗi \"Alice\" nếu diện tích của hình vuông lớn hơn, \"Bob\" nếu diện tích của hình chữ nhật lớn hơn, hoặc \"Equal\" nếu cả hai diện tích bằng nhau."
    },
    "docstring_bertscore": {
      "es": "0.9578230235214329",
      "arb": "0.9465557151572288",
      "sw": "0.9563895080615041",
      "tr": "0.9625019607770907",
      "vi": "0.9626251116133323"
    }
  },
  {
    "task_id": "PHP/45",
    "prompt": {
      "en": "<?php\n\n\n/**\n * Finds M positive integers whose sum is N and whose product is as large as possible.\n * Outputs the combination with the smallest lexicographical order if there are multiple possibilities.\n * The function aims to distribute the total sum N into M parts such that the product of these parts is maximized.\n * \n * Input: Two integers, $N representing the total sum and $M representing the number of parts.\n * Output: An array of integers representing the distribution that maximizes the product.\n * Example: Given N = 6 and M = 3, the function returns [2, 2, 2] as dividing 6 into three parts of 2 each maximizes the product 2*2*2 = 8.\n */\n\nfunction maxProductDistribution($N, $M) ",
      "es": "<?php\n\n\n/**\n * Encuentra M enteros positivos cuya suma es N y cuyo producto es lo más grande posible.\n * Devuelve la combinación con el orden lexicográfico más pequeño si hay múltiples posibilidades.\n * La función tiene como objetivo distribuir la suma total N en M partes de manera que el producto de estas partes se maximice.\n * \n * Entrada: Dos enteros, $N que representa la suma total y $M que representa el número de partes.\n * Salida: Un arreglo de enteros que representa la distribución que maximiza el producto.\n * Ejemplo: Dado N = 6 y M = 3, la función devuelve [2, 2, 2] ya que dividir 6 en tres partes de 2 cada una maximiza el producto 2*2*2 = 8.\n */\n\nfunction maxProductDistribution($N, $M) ",
      "arb": "<?php\n\n\n/**\n * يجد M أعداد صحيحة موجبة مجموعها N ومنتجها هو الأكبر قدر الإمكان.\n * يُخرج التوليفة بترتيب معجمي أصغر إذا كانت هناك احتمالات متعددة.\n * تهدف الدالة إلى توزيع المجموع الكلي N إلى M أجزاء بحيث يتم تعظيم ناتج هذه الأجزاء.\n * \n * المدخلات: عددان صحيحان، $N يمثل المجموع الكلي و $M يمثل عدد الأجزاء.\n * المخرجات: مصفوفة من الأعداد الصحيحة تمثل التوزيع الذي يعظم الناتج.\n * مثال: إذا كان N = 6 و M = 3، فإن الدالة تُرجع [2, 2, 2] حيث أن تقسيم 6 إلى ثلاثة أجزاء كل منها 2 يعظم الناتج 2*2*2 = 8.\n */\n\nfunction maxProductDistribution($N, $M) ",
      "sw": "<?php\n\n\n/**\n * Inapata nambari M ambazo jumla yake ni N na ambazo bidhaa yake ni kubwa iwezekanavyo.\n * Inatoa mchanganyiko wenye mpangilio mdogo zaidi wa lexicographical ikiwa kuna uwezekano mwingi.\n * Kazi inalenga kusambaza jumla ya N katika sehemu M ili bidhaa ya sehemu hizi iwe kubwa zaidi.\n * \n * Ingizo: Nambari mbili, $N inayowakilisha jumla ya jumla na $M inayowakilisha idadi ya sehemu.\n * Tokeo: Safu ya nambari inayoonyesha usambazaji unaoongeza bidhaa.\n * Mfano: Ikitolewa N = 6 na M = 3, kazi inarudisha [2, 2, 2] kwani kugawanya 6 katika sehemu tatu za 2 kila moja kunakuza bidhaa 2*2*2 = 8.\n */\n\nfunction maxProductDistribution($N, $M) ",
      "tr": "<?php\n\n\n/**\n * Toplamı N olan ve çarpımı mümkün olduğunca büyük olan M pozitif tam sayı bulur.\n * Birden fazla olasılık varsa, en küçük sözlük sırasına sahip kombinasyonu çıktılar.\n * Fonksiyon, toplam N'yi M parçaya dağıtarak bu parçaların çarpımını maksimize etmeyi amaçlar.\n * \n * Girdi: Toplamı temsil eden $N ve parça sayısını temsil eden $M olmak üzere iki tam sayı.\n * Çıktı: Çarpımı maksimize eden dağılımı temsil eden bir tam sayı dizisi.\n * Örnek: N = 6 ve M = 3 verildiğinde, fonksiyon [2, 2, 2] döndürür çünkü 6'yı her biri 2 olan üç parçaya bölmek çarpımı maksimize eder: 2*2*2 = 8.\n */\n\nfunction maxProductDistribution($N, $M) ",
      "vi": "<?php\n\n\n/**\n * Tìm M số nguyên dương có tổng là N và có tích lớn nhất có thể.\n * Xuất ra tổ hợp có thứ tự từ điển nhỏ nhất nếu có nhiều khả năng.\n * Hàm nhằm phân phối tổng N thành M phần sao cho tích của các phần này được tối đa hóa.\n * \n * Đầu vào: Hai số nguyên, $N đại diện cho tổng và $M đại diện cho số phần.\n * Đầu ra: Một mảng các số nguyên đại diện cho sự phân phối tối đa hóa tích.\n * Ví dụ: Cho N = 6 và M = 3, hàm trả về [2, 2, 2] vì chia 6 thành ba phần mỗi phần là 2 sẽ tối đa hóa tích 2*2*2 = 8.\n */\n\nfunction maxProductDistribution($N, $M) "
    },
    "prompt_bertscore": {
      "es": "0.9917208870880848",
      "arb": "0.9814558676265829",
      "sw": "0.9505767885908991",
      "tr": "0.9530272916017265",
      "vi": "0.9558524115111857"
    },
    "canonical_solution": "{\n    // Initial equal distribution\n    $baseValue = intdiv($N, $M);\n    $remainder = $N % $M;\n    \n    $result = array_fill(0, $M, $baseValue);\n    \n    // Adjust the distribution to distribute the remainder, enhancing the product\n    for ($i = 0; $i < $remainder; $i++) {\n        $result[$i]++;\n    }\n    \n    // Ensure lexicographical order is smallest by distributing remainder from the start\n    sort($result);\n    \n    return $result;\n}",
    "instruction": {
      "en": "function maxProductDistribution($N, $M)\n{\n    // Initial equal distribution\n    $baseValue = intdiv($N, $M);\n    $remainder = $N % $M;\n    \n    $result = array_fill(0, $M, $baseValue);\n    \n    // Adjust the distribution to distribute the remainder, enhancing the product\n    for ($i = 0; $i < $remainder; $i++) {\n        $result[$i]++;\n    }\n    \n    // Ensure lexicographical order is smallest by distributing remainder from the start\n    sort($result);\n    \n    return $result;\n}\n\nProvide a concise natural language description (docstring) of the PHP code in English using at most 500 characters.",
      "es": "function maxProductDistribution($N, $M)\n{\n    // Initial equal distribution\n    $baseValue = intdiv($N, $M);\n    $remainder = $N % $M;\n    \n    $result = array_fill(0, $M, $baseValue);\n    \n    // Adjust the distribution to distribute the remainder, enhancing the product\n    for ($i = 0; $i < $remainder; $i++) {\n        $result[$i]++;\n    }\n    \n    // Ensure lexicographical order is smallest by distributing remainder from the start\n    sort($result);\n    \n    return $result;\n}\n\nProporcione una descripción concisa en lenguaje natural (docstring) del código PHP en español utilizando como máximo 500 caracteres.",
      "arb": "function maxProductDistribution($N, $M)\n{\n    // Initial equal distribution\n    $baseValue = intdiv($N, $M);\n    $remainder = $N % $M;\n    \n    $result = array_fill(0, $M, $baseValue);\n    \n    // Adjust the distribution to distribute the remainder, enhancing the product\n    for ($i = 0; $i < $remainder; $i++) {\n        $result[$i]++;\n    }\n    \n    // Ensure lexicographical order is smallest by distributing remainder from the start\n    sort($result);\n    \n    return $result;\n}\n\nيرجى تقديم وصف موجز بلغة طبيعية (docstring) لشيفرة PHP باللغة العربية الفصحى باستخدام 500 حرف كحد أقصى.",
      "sw": "function maxProductDistribution($N, $M)\n{\n    // Initial equal distribution\n    $baseValue = intdiv($N, $M);\n    $remainder = $N % $M;\n    \n    $result = array_fill(0, $M, $baseValue);\n    \n    // Adjust the distribution to distribute the remainder, enhancing the product\n    for ($i = 0; $i < $remainder; $i++) {\n        $result[$i]++;\n    }\n    \n    // Ensure lexicographical order is smallest by distributing remainder from the start\n    sort($result);\n    \n    return $result;\n}\n\nToa maelezo mafupi ya lugha ya asili (docstring) ya msimbo wa PHP kwa Kiswahili kwa kutumia herufi zisizozidi 500.",
      "tr": "function maxProductDistribution($N, $M)\n{\n    // Initial equal distribution\n    $baseValue = intdiv($N, $M);\n    $remainder = $N % $M;\n    \n    $result = array_fill(0, $M, $baseValue);\n    \n    // Adjust the distribution to distribute the remainder, enhancing the product\n    for ($i = 0; $i < $remainder; $i++) {\n        $result[$i]++;\n    }\n    \n    // Ensure lexicographical order is smallest by distributing remainder from the start\n    sort($result);\n    \n    return $result;\n}\n\nPHP kodunun işlevini açıklayan kısa bir doğal dil açıklaması (docstring) sağlayın. Açıklama Türkçe olmalı ve en fazla 500 karakter kullanılmalıdır.",
      "vi": "function maxProductDistribution($N, $M)\n{\n    // Initial equal distribution\n    $baseValue = intdiv($N, $M);\n    $remainder = $N % $M;\n    \n    $result = array_fill(0, $M, $baseValue);\n    \n    // Adjust the distribution to distribute the remainder, enhancing the product\n    for ($i = 0; $i < $remainder; $i++) {\n        $result[$i]++;\n    }\n    \n    // Ensure lexicographical order is smallest by distributing remainder from the start\n    sort($result);\n    \n    return $result;\n}\n\nCung cấp mô tả ngắn gọn bằng ngôn ngữ tự nhiên (docstring) cho mã PHP bằng tiếng Việt, sử dụng tối đa 500 ký tự."
    },
    "instruction_bertscore": {
      "es": "0.9687069752502395",
      "arb": "0.9105356845996001",
      "sw": "0.91585798565943",
      "tr": "0.8654434100185839",
      "vi": "0.9202302376067699"
    },
    "level": "",
    "test": "function main(){\n    // Test Case 1: Simple distribution\n    assert(maxProductDistribution(6, 3) === [2, 2, 2]);\n\n    // Test Case 2: When distribution is not perfectly even\n    assert(maxProductDistribution(7, 3) === [2, 2, 3]);\n\n    // Test Case 3: Larger numbers with an even distribution\n    assert(maxProductDistribution(10, 2) === [5, 5]);\n\n    // Test Case 4: Larger numbers with a remainder\n    assert(maxProductDistribution(9, 4) === [2, 2, 2, 3]);\n    assert(maxProductDistribution(9, 3) === [3,3, 3]);\n\n    // Test Case 5: Single part (edge case)\n    assert(maxProductDistribution(5, 1) === [5]);\n\n}\n\n\nmain();\n?>",
    "entry_point": "maxProductDistribution",
    "signature": "function maxProductDistribution($N, $M)",
    "docstring": {
      "en": "Finds M positive integers whose sum is N and whose product is as large as possible.\n  Outputs the combination with the smallest lexicographical order if there are multiple possibilities.\n  The function aims to distribute the total sum N into M parts such that the product of these parts is maximized.\n  \n  Input: Two integers, $N representing the total sum and $M representing the number of parts.\n  Output: An array of integers representing the distribution that maximizes the product.\n  Example: Given N = 6 and M = 3, the function returns [2, 2, 2] as dividing 6 into three parts of 2 each maximizes the product 222 = 8.",
      "es": "Encuentra M enteros positivos cuya suma sea N y cuyo producto sea lo más grande posible.\n  Muestra la combinación con el orden lexicográfico más pequeño si hay múltiples posibilidades.\n  La función tiene como objetivo distribuir la suma total N en M partes de tal manera que el producto de estas partes sea maximizado.\n  \n  Entrada: Dos enteros, $N que representa la suma total y $M que representa el número de partes.\n  Salida: Un arreglo de enteros que representa la distribución que maximiza el producto.\n  Ejemplo: Dado N = 6 y M = 3, la función devuelve [2, 2, 2] ya que dividir 6 en tres partes de 2 cada una maximiza el producto 222 = 8.",
      "arb": "يجد M أعداد صحيحة موجبة يكون مجموعها N ويكون حاصل ضربها أكبر ما يمكن.\n  يُخرج التوليفة ذات الترتيب المعجمي الأصغر إذا كانت هناك احتمالات متعددة.\n  تهدف الدالة إلى توزيع المجموع الكلي N إلى M أجزاء بحيث يتم تعظيم حاصل ضرب هذه الأجزاء.\n\n  المدخلات: عددان صحيحان، $N يمثل المجموع الكلي و $M يمثل عدد الأجزاء.\n  المخرجات: مصفوفة من الأعداد الصحيحة تمثل التوزيع الذي يعظم حاصل الضرب.\n  مثال: بالنظر إلى N = 6 و M = 3، تُرجع الدالة [2, 2, 2] حيث أن تقسيم 6 إلى ثلاثة أجزاء كل منها 2 يعظم حاصل الضرب 222 = 8.",
      "sw": "Inapata nambari za asili M ambazo jumla yake ni N na ambazo bidhaa yake ni kubwa iwezekanavyo.\n  Inatoa mchanganyiko wenye mpangilio mdogo wa alfabeti ikiwa kuna uwezekano mwingi.\n  Kazi inalenga kugawa jumla ya N katika sehemu M ili bidhaa ya sehemu hizi iwe kubwa zaidi.\n  \n  Ingizo: Nambari mbili za asili, $N inayoashiria jumla ya jumla na $M inayoashiria idadi ya sehemu.\n  Tokeo: Safu ya nambari za asili inayoashiria mgawanyo unaoongeza bidhaa.\n  Mfano: Ukipewa N = 6 na M = 3, kazi inarudisha [2, 2, 2] kwani kugawa 6 katika sehemu tatu za 2 kila moja kunakuza bidhaa 222 = 8.",
      "tr": "M pozitif tam sayının toplamı N olan ve çarpımı mümkün olduğunca büyük olanları bulur.\n  Birden fazla olasılık varsa, en küçük sözlük sırasına sahip kombinasyonu çıktılar.\n  Fonksiyon, toplam N'i M parçaya dağıtarak bu parçaların çarpımını maksimize etmeyi amaçlar.\n  \n  Girdi: Toplamı temsil eden $N ve parça sayısını temsil eden $M olmak üzere iki tam sayı.\n  Çıktı: Çarpımı maksimize eden dağılımı temsil eden bir tam sayı dizisi.\n  Örnek: N = 6 ve M = 3 verildiğinde, fonksiyon [2, 2, 2] döndürür çünkü 6'yı her biri 2 olan üç parçaya bölmek çarpımı maksimize eder, 222 = 8.",
      "vi": "Tìm M số nguyên dương có tổng là N và có tích lớn nhất có thể.\n  Xuất ra tổ hợp có thứ tự từ điển nhỏ nhất nếu có nhiều khả năng.\n  Hàm này nhằm phân phối tổng số N thành M phần sao cho tích của các phần này được tối đa hóa.\n  \n  Đầu vào: Hai số nguyên, $N đại diện cho tổng số và $M đại diện cho số phần.\n  Đầu ra: Một mảng các số nguyên đại diện cho sự phân phối mà tối đa hóa tích.\n  Ví dụ: Cho N = 6 và M = 3, hàm trả về [2, 2, 2] vì chia 6 thành ba phần mỗi phần là 2 sẽ tối đa hóa tích 222 = 8."
    },
    "docstring_bertscore": {
      "es": "0.977414533894047",
      "arb": "0.9503267129411762",
      "sw": "0.9229361792876082",
      "tr": "0.9284565148373298",
      "vi": "0.9406518243417289"
    }
  },
  {
    "task_id": "PHP/46",
    "prompt": {
      "en": "<?php\n\n\n/**\n * Calculates the number of characters in a composition's title.\n * The title may contain uppercase and lowercase English letters, digits, spaces, and newline characters.\n * The function counts the characters excluding spaces and newline characters.\n * \n * Example usage:\n * - For a title \"234\", the function returns 3.\n * - For a title \"Ca 45\\n\", including a newline character, the function returns 4.\n * \n * @param string $title The title of the composition.\n * @return int The number of characters in the title, excluding spaces and newline characters.\n */\n\nfunction countTitleCharacters(string $title): int ",
      "es": "<?php\n\n\n/**\n * Calcula el número de caracteres en el título de una composición.\n * El título puede contener letras mayúsculas y minúsculas en inglés, dígitos, espacios y caracteres de nueva línea.\n * La función cuenta los caracteres excluyendo espacios y caracteres de nueva línea.\n * \n * Ejemplo de uso:\n * - Para un título \"234\", la función devuelve 3.\n * - Para un título \"Ca 45\\n\", incluyendo un carácter de nueva línea, la función devuelve 4.\n * \n * @param string $title El título de la composición.\n * @return int El número de caracteres en el título, excluyendo espacios y caracteres de nueva línea.\n */\n\nfunction countTitleCharacters(string $title): int ",
      "arb": "<?php\n\n\n/**\n * يحسب عدد الأحرف في عنوان التركيبة.\n * قد يحتوي العنوان على أحرف إنجليزية كبيرة وصغيرة، أرقام، مسافات، وأحرف سطر جديد.\n * تقوم الدالة بعد الأحرف باستثناء المسافات وأحرف السطر الجديد.\n * \n * مثال على الاستخدام:\n * - بالنسبة لعنوان \"234\"، تعيد الدالة 3.\n * - بالنسبة لعنوان \"Ca 45\\n\"، بما في ذلك حرف السطر الجديد، تعيد الدالة 4.\n * \n * @param string $title عنوان التركيبة.\n * @return int عدد الأحرف في العنوان، باستثناء المسافات وأحرف السطر الجديد.\n */\n\nfunction countTitleCharacters(string $title): int ",
      "sw": "<?php\n\n\n/**\n * Inahesabu idadi ya herufi katika kichwa cha utunzi.\n * Kichwa kinaweza kuwa na herufi kubwa na ndogo za Kiingereza, tarakimu, nafasi, na herufi za kurudi mstari mpya.\n * Kazi hii inahesabu herufi isipokuwa nafasi na herufi za kurudi mstari mpya.\n * \n * Mfano wa matumizi:\n * - Kwa kichwa \"234\", kazi inarudisha 3.\n * - Kwa kichwa \"Ca 45\\n\", ikiwa ni pamoja na herufi ya kurudi mstari mpya, kazi inarudisha 4.\n * \n * @param string $title Kichwa cha utunzi.\n * @return int Idadi ya herufi katika kichwa, isipokuwa nafasi na herufi za kurudi mstari mpya.\n */\n\nfunction countTitleCharacters(string $title): int ",
      "tr": "<?php\n\n\n/**\n * Bir kompozisyonun başlığındaki karakter sayısını hesaplar.\n * Başlık büyük ve küçük İngilizce harfler, rakamlar, boşluklar ve yeni satır karakterleri içerebilir.\n * Fonksiyon, boşluklar ve yeni satır karakterleri hariç karakterleri sayar.\n * \n * Örnek kullanım:\n * - \"234\" başlığı için, fonksiyon 3 döndürür.\n * - Yeni satır karakteri içeren \"Ca 45\\n\" başlığı için, fonksiyon 4 döndürür.\n * \n * @param string $title Kompozisyonun başlığı.\n * @return int Boşluklar ve yeni satır karakterleri hariç başlıktaki karakter sayısı.\n */\n\nfunction countTitleCharacters(string $title): int ",
      "vi": "<?php\n\n\n/**\n * Tính số ký tự trong tiêu đề của một tác phẩm.\n * Tiêu đề có thể chứa các chữ cái tiếng Anh viết hoa và viết thường, chữ số, khoảng trắng và ký tự xuống dòng.\n * Hàm đếm các ký tự ngoại trừ khoảng trắng và ký tự xuống dòng.\n * \n * Ví dụ sử dụng:\n * - Đối với tiêu đề \"234\", hàm trả về 3.\n * - Đối với tiêu đề \"Ca 45\\n\", bao gồm một ký tự xuống dòng, hàm trả về 4.\n * \n * @param string $title Tiêu đề của tác phẩm.\n * @return int Số ký tự trong tiêu đề, ngoại trừ khoảng trắng và ký tự xuống dòng.\n */\n\nfunction countTitleCharacters(string $title): int "
    },
    "prompt_bertscore": {
      "es": "0.986244846113334",
      "arb": "0.9709441492318355",
      "sw": "0.9639183940242505",
      "tr": "0.9807344420826641",
      "vi": "0.9767971906697905"
    },
    "canonical_solution": "{\n    $count = 0;\n    for ($i = 0; $i < strlen($title); $i++) {\n        if ($title[$i] != \" \" && $title[$i] != \"\\n\") {\n            $count++;\n        }\n    }\n    return $count;\n}",
    "instruction": {
      "en": "function countTitleCharacters(string $title): int\n{\n    $count = 0;\n    for ($i = 0; $i < strlen($title); $i++) {\n        if ($title[$i] != \" \" && $title[$i] != \"\\n\") {\n            $count++;\n        }\n    }\n    return $count;\n}\n\nProvide a concise natural language description (docstring) of the PHP code in English using at most 500 characters.",
      "es": "function countTitleCharacters(string $title): int\n{\n    $count = 0;\n    for ($i = 0; $i < strlen($title); $i++) {\n        if ($title[$i] != \" \" && $title[$i] != \"\\n\") {\n            $count++;\n        }\n    }\n    return $count;\n}\n\nProporcione una descripción concisa en lenguaje natural (docstring) del código PHP en español utilizando un máximo de 500 caracteres.",
      "arb": "function countTitleCharacters(string $title): int\n{\n    $count = 0;\n    for ($i = 0; $i < strlen($title); $i++) {\n        if ($title[$i] != \" \" && $title[$i] != \"\\n\") {\n            $count++;\n        }\n    }\n    return $count;\n}\n\nيرجى تقديم وصف موجز بلغة طبيعية (docstring) للكود المكتوب بلغة PHP باللغة العربية الفصحى، بحيث لا يتجاوز 500 حرف.",
      "sw": "function countTitleCharacters(string $title): int\n{\n    $count = 0;\n    for ($i = 0; $i < strlen($title); $i++) {\n        if ($title[$i] != \" \" && $title[$i] != \"\\n\") {\n            $count++;\n        }\n    }\n    return $count;\n}\n\nToa maelezo mafupi ya lugha ya asili (docstring) ya msimbo wa PHP kwa Kiswahili kwa kutumia herufi zisizozidi 500.",
      "tr": "function countTitleCharacters(string $title): int\n{\n    $count = 0;\n    for ($i = 0; $i < strlen($title); $i++) {\n        if ($title[$i] != \" \" && $title[$i] != \"\\n\") {\n            $count++;\n        }\n    }\n    return $count;\n}\n\nPHP kodunun işlevini açıklayan kısa bir doğal dil açıklaması (docstring) sağlayın. Açıklama, en fazla 500 karakter kullanılarak Türkçe yazılmalıdır.",
      "vi": "function countTitleCharacters(string $title): int\n{\n    $count = 0;\n    for ($i = 0; $i < strlen($title); $i++) {\n        if ($title[$i] != \" \" && $title[$i] != \"\\n\") {\n            $count++;\n        }\n    }\n    return $count;\n}\n\nCung cấp mô tả ngắn gọn bằng ngôn ngữ tự nhiên (docstring) cho mã PHP bằng tiếng Việt, không quá 500 ký tự."
    },
    "instruction_bertscore": {
      "es": "0.9687069752502395",
      "arb": "0.8898884537517856",
      "sw": "0.91585798565943",
      "tr": "0.881863190466833",
      "vi": "0.9241565643486865"
    },
    "level": "",
    "test": "function main(){\n    assert(countTitleCharacters(\"234\") === 3, 'Testcase 1 failed');\n    assert(countTitleCharacters(\"Ca 45\") === 4, 'Testcase 2 failed');\n    assert(countTitleCharacters(\" \\nCa 45\\n \") === 4, 'Testcase 3 failed');\n    assert(countTitleCharacters(\"\") === 0, 'Testcase 5 failed');\n    \n}\n\n\nmain();\n?>",
    "entry_point": "countTitleCharacters",
    "signature": "function countTitleCharacters(string $title): int",
    "docstring": {
      "en": "* Calculates the number of characters in a composition's title.\n * The title may contain uppercase and lowercase English letters, digits, spaces, and newline characters.\n * The function counts the characters excluding spaces and newline characters.\n * \n * Example usage:\n * - For a title \"234\", the function returns 3.\n * - For a title \"Ca 45\\n\", including a newline character, the function returns 4.\n * \n * @param string $title The title of the composition.\n * @return int The number of characters in the title, excluding spaces and newline characters.  Calculates the number of characters in a composition's title.\n  The title may contain uppercase and lowercase English letters, digits, spaces, and newline characters.\n  The function counts the characters excluding spaces and newline characters.\n  \n  Example usage:\n  - For a title \"234\", the function returns 3.\n  - For a title \"Ca 45\\n\", including a newline character, the function returns 4.\n  \n  @param string $title The title of the composition.\n  @return int The number of characters in the title, excluding spaces and newline characters.",
      "es": "* Calcula el número de caracteres en el título de una composición.\n * El título puede contener letras mayúsculas y minúsculas en inglés, dígitos, espacios y caracteres de nueva línea.\n * La función cuenta los caracteres excluyendo espacios y caracteres de nueva línea.\n * \n * Ejemplo de uso:\n * - Para un título \"234\", la función devuelve 3.\n * - Para un título \"Ca 45\\n\", incluyendo un carácter de nueva línea, la función devuelve 4.\n * \n * @param string $title El título de la composición.\n * @return int El número de caracteres en el título, excluyendo espacios y caracteres de nueva línea. Calcula el número de caracteres en el título de una composición.\n  El título puede contener letras mayúsculas y minúsculas en inglés, dígitos, espacios y caracteres de nueva línea.\n  La función cuenta los caracteres excluyendo espacios y caracteres de nueva línea.\n  \n  Ejemplo de uso:\n  - Para un título \"234\", la función devuelve 3.\n  - Para un título \"Ca 45\\n\", incluyendo un carácter de nueva línea, la función devuelve 4.\n  \n  @param string $title El título de la composición.\n  @return int El número de caracteres en el título, excluyendo espacios y caracteres de nueva línea.",
      "arb": "* يحسب عدد الأحرف في عنوان التركيبة.\n * قد يحتوي العنوان على أحرف إنجليزية كبيرة وصغيرة، وأرقام، ومسافات، وأحرف سطر جديد.\n * تقوم الدالة بحساب الأحرف باستثناء المسافات وأحرف السطر الجديد.\n * \n * مثال على الاستخدام:\n * - بالنسبة لعنوان \"234\"، تعيد الدالة 3.\n * - بالنسبة لعنوان \"Ca 45\\n\"، بما في ذلك حرف السطر الجديد، تعيد الدالة 4.\n * \n * @param string $title عنوان التركيبة.\n * @return int عدد الأحرف في العنوان، باستثناء المسافات وأحرف السطر الجديد.  يحسب عدد الأحرف في عنوان التركيبة.\n  قد يحتوي العنوان على أحرف إنجليزية كبيرة وصغيرة، وأرقام، ومسافات، وأحرف سطر جديد.\n  تقوم الدالة بحساب الأحرف باستثناء المسافات وأحرف السطر الجديد.\n  \n  مثال على الاستخدام:\n  - بالنسبة لعنوان \"234\"، تعيد الدالة 3.\n  - بالنسبة لعنوان \"Ca 45\\n\"، بما في ذلك حرف السطر الجديد، تعيد الدالة 4.\n  \n  @param string $title عنوان التركيبة.\n  @return int عدد الأحرف في العنوان، باستثناء المسافات وأحرف السطر الجديد.",
      "sw": "* Inahesabu idadi ya herufi katika kichwa cha utunzi.\n * Kichwa kinaweza kuwa na herufi kubwa na ndogo za Kiingereza, nambari, nafasi, na herufi za kurudi mstari mpya.\n * Kazi inahesabu herufi isipokuwa nafasi na herufi za kurudi mstari mpya.\n * \n * Mfano wa matumizi:\n * - Kwa kichwa \"234\", kazi inarudisha 3.\n * - Kwa kichwa \"Ca 45\\n\", ikijumuisha herufi ya kurudi mstari mpya, kazi inarudisha 4.\n * \n * @param string $title Kichwa cha utunzi.\n * @return int Idadi ya herufi katika kichwa, isipokuwa nafasi na herufi za kurudi mstari mpya. Inahesabu idadi ya herufi katika kichwa cha utunzi.\n  Kichwa kinaweza kuwa na herufi kubwa na ndogo za Kiingereza, nambari, nafasi, na herufi za kurudi mstari mpya.\n  Kazi inahesabu herufi isipokuwa nafasi na herufi za kurudi mstari mpya.\n  \n  Mfano wa matumizi:\n  - Kwa kichwa \"234\", kazi inarudisha 3.\n  - Kwa kichwa \"Ca 45\\n\", ikijumuisha herufi ya kurudi mstari mpya, kazi inarudisha 4.\n  \n  @param string $title Kichwa cha utunzi.\n  @return int Idadi ya herufi katika kichwa, isipokuwa nafasi na herufi za kurudi mstari mpya.",
      "tr": "* Bir kompozisyonun başlığındaki karakterlerin sayısını hesaplar.\n * Başlık, büyük ve küçük İngilizce harfler, rakamlar, boşluklar ve yeni satır karakterleri içerebilir.\n * Fonksiyon, boşluklar ve yeni satır karakterleri hariç karakterleri sayar.\n * \n * Örnek kullanım:\n * - \"234\" başlığı için, fonksiyon 3 döndürür.\n * - Yeni satır karakteri içeren \"Ca 45\\n\" başlığı için, fonksiyon 4 döndürür.\n * \n * @param string $title Kompozisyonun başlığı.\n * @return int Başlıktaki karakterlerin sayısı, boşluklar ve yeni satır karakterleri hariç. Bir kompozisyonun başlığındaki karakterlerin sayısını hesaplar.\n  Başlık, büyük ve küçük İngilizce harfler, rakamlar, boşluklar ve yeni satır karakterleri içerebilir.\n  Fonksiyon, boşluklar ve yeni satır karakterleri hariç karakterleri sayar.\n  \n  Örnek kullanım:\n  - \"234\" başlığı için, fonksiyon 3 döndürür.\n  - Yeni satır karakteri içeren \"Ca 45\\n\" başlığı için, fonksiyon 4 döndürür.\n  \n  @param string $title Kompozisyonun başlığı.\n  @return int Başlıktaki karakterlerin sayısı, boşluklar ve yeni satır karakterleri hariç.",
      "vi": "* Tính số ký tự trong tiêu đề của một tác phẩm.\n * Tiêu đề có thể chứa chữ cái tiếng Anh viết hoa và viết thường, chữ số, khoảng trắng và ký tự xuống dòng.\n * Hàm này đếm các ký tự ngoại trừ khoảng trắng và ký tự xuống dòng.\n * \n * Ví dụ sử dụng:\n * - Với tiêu đề \"234\", hàm trả về 3.\n * - Với tiêu đề \"Ca 45\\n\", bao gồm một ký tự xuống dòng, hàm trả về 4.\n * \n * @param string $title Tiêu đề của tác phẩm.\n * @return int Số ký tự trong tiêu đề, không bao gồm khoảng trắng và ký tự xuống dòng.  Tính số ký tự trong tiêu đề của một tác phẩm.\n  Tiêu đề có thể chứa chữ cái tiếng Anh viết hoa và viết thường, chữ số, khoảng trắng và ký tự xuống dòng.\n  Hàm này đếm các ký tự ngoại trừ khoảng trắng và ký tự xuống dòng.\n  \n  Ví dụ sử dụng:\n  - Với tiêu đề \"234\", hàm trả về 3.\n  - Với tiêu đề \"Ca 45\\n\", bao gồm một ký tự xuống dòng, hàm trả về 4.\n  \n  @param string $title Tiêu đề của tác phẩm.\n  @return int Số ký tự trong tiêu đề, không bao gồm khoảng trắng và ký tự xuống dòng."
    },
    "docstring_bertscore": {
      "es": "0.9748955034017626",
      "arb": "0.9552243422463534",
      "sw": "0.9538543885083558",
      "tr": "0.9682096047761282",
      "vi": "0.9633348179647699"
    }
  },
  {
    "task_id": "PHP/47",
    "prompt": {
      "en": "<?php\n\n\n/**\n * Counts the number of students enrolled in both courses A and B.\n * Given two arrays representing the student IDs of those who have enrolled in courses A and B,\n * this function calculates the total number of students who have enrolled in both courses.\n * \n * The function accepts two parameters:\n * - $courseA (array): An array of integers representing the IDs of students enrolled in course A.\n * - $courseB (array): An array of integers representing the IDs of students enrolled in course B.\n * \n * The function returns an integer representing the number of students enrolled in both courses.\n * \n * Example:\n * If course A has students with IDs [1, 2, 3, 4, 5] and course B has students with IDs [1, 3, 4, 5, 6],\n * the function should return 4 because students with IDs 1, 3, 4, and 5 are enrolled in both courses.\n */\n\nfunction countCommonStudents(array $courseA, array $courseB): int ",
      "es": "<?php\n\n\n/**\n * Cuenta el número de estudiantes inscritos en ambos cursos A y B.\n * Dadas dos matrices que representan los ID de estudiantes que se han inscrito en los cursos A y B,\n * esta función calcula el número total de estudiantes que se han inscrito en ambos cursos.\n * \n * La función acepta dos parámetros:\n * - $courseA (array): Una matriz de enteros que representa los ID de los estudiantes inscritos en el curso A.\n * - $courseB (array): Una matriz de enteros que representa los ID de los estudiantes inscritos en el curso B.\n * \n * La función devuelve un entero que representa el número de estudiantes inscritos en ambos cursos.\n * \n * Ejemplo:\n * Si el curso A tiene estudiantes con ID [1, 2, 3, 4, 5] y el curso B tiene estudiantes con ID [1, 3, 4, 5, 6],\n * la función debería devolver 4 porque los estudiantes con ID 1, 3, 4 y 5 están inscritos en ambos cursos.\n */\n\nfunction countCommonStudents(array $courseA, array $courseB): int ",
      "arb": "<?php\n\n\n/**\n * يحسب عدد الطلاب المسجلين في كلا الدورتين A و B.\n * بالنظر إلى مصفوفتين تمثلان معرفات الطلاب الذين سجلوا في الدورتين A و B،\n * تقوم هذه الدالة بحساب العدد الإجمالي للطلاب الذين سجلوا في كلا الدورتين.\n * \n * تقبل الدالة معاملين:\n * - $courseA (array): مصفوفة من الأعداد الصحيحة تمثل معرفات الطلاب المسجلين في الدورة A.\n * - $courseB (array): مصفوفة من الأعداد الصحيحة تمثل معرفات الطلاب المسجلين في الدورة B.\n * \n * تعيد الدالة عددًا صحيحًا يمثل عدد الطلاب المسجلين في كلا الدورتين.\n * \n * مثال:\n * إذا كانت الدورة A تحتوي على طلاب بمعرفات [1, 2, 3, 4, 5] والدورة B تحتوي على طلاب بمعرفات [1, 3, 4, 5, 6]،\n * يجب أن تعيد الدالة 4 لأن الطلاب بمعرفات 1، 3، 4، و5 مسجلون في كلا الدورتين.\n */\n\nfunction countCommonStudents(array $courseA, array $courseB): int ",
      "sw": "<?php\n\n\n/**\n * Inahesabu idadi ya wanafunzi waliojiandikisha katika kozi zote A na B.\n * Ukipewa safu mbili zinazoonyesha nambari za utambulisho za wanafunzi waliojiandikisha katika kozi A na B,\n * kazi hii inahesabu jumla ya wanafunzi waliojiandikisha katika kozi zote mbili.\n * \n * Kazi inakubali vigezo viwili:\n * - $courseA (array): Safu ya nambari zinazoonyesha nambari za utambulisho za wanafunzi waliojiandikisha katika kozi A.\n * - $courseB (array): Safu ya nambari zinazoonyesha nambari za utambulisho za wanafunzi waliojiandikisha katika kozi B.\n * \n * Kazi inarudisha nambari inayoonyesha idadi ya wanafunzi waliojiandikisha katika kozi zote mbili.\n * \n * Mfano:\n * Ikiwa kozi A ina wanafunzi wenye nambari za utambulisho [1, 2, 3, 4, 5] na kozi B ina wanafunzi wenye nambari za utambulisho [1, 3, 4, 5, 6],\n * kazi inapaswa kurudisha 4 kwa sababu wanafunzi wenye nambari za utambulisho 1, 3, 4, na 5 wamejiandikisha katika kozi zote mbili.\n */\n\nfunction countCommonStudents(array $courseA, array $courseB): int ",
      "tr": "<?php\n\n\n/**\n * Hem A hem de B derslerine kayıtlı olan öğrencilerin sayısını sayar.\n * A ve B derslerine kayıtlı olan öğrencilerin kimlik numaralarını temsil eden iki dizi verildiğinde,\n * bu fonksiyon her iki derse de kayıtlı olan toplam öğrenci sayısını hesaplar.\n * \n * Fonksiyon iki parametre kabul eder:\n * - $courseA (array): A dersine kayıtlı öğrencilerin kimlik numaralarını temsil eden bir tamsayı dizisi.\n * - $courseB (array): B dersine kayıtlı öğrencilerin kimlik numaralarını temsil eden bir tamsayı dizisi.\n * \n * Fonksiyon, her iki derse de kayıtlı olan öğrencilerin sayısını temsil eden bir tamsayı döndürür.\n * \n * Örnek:\n * Eğer A dersi [1, 2, 3, 4, 5] kimlik numaralı öğrencilere ve B dersi [1, 3, 4, 5, 6] kimlik numaralı öğrencilere sahipse,\n * fonksiyon 4 döndürmelidir çünkü 1, 3, 4 ve 5 kimlik numaralı öğrenciler her iki derse de kayıtlıdır.\n */\n\nfunction countCommonStudents(array $courseA, array $courseB): int ",
      "vi": "<?php\n\n\n/**\n * Đếm số lượng sinh viên đăng ký cả hai khóa học A và B.\n * Cho hai mảng đại diện cho mã số sinh viên của những người đã đăng ký các khóa học A và B,\n * hàm này tính tổng số sinh viên đã đăng ký cả hai khóa học.\n * \n * Hàm chấp nhận hai tham số:\n * - $courseA (array): Một mảng số nguyên đại diện cho mã số sinh viên đăng ký khóa học A.\n * - $courseB (array): Một mảng số nguyên đại diện cho mã số sinh viên đăng ký khóa học B.\n * \n * Hàm trả về một số nguyên đại diện cho số lượng sinh viên đăng ký cả hai khóa học.\n * \n * Ví dụ:\n * Nếu khóa học A có sinh viên với mã số [1, 2, 3, 4, 5] và khóa học B có sinh viên với mã số [1, 3, 4, 5, 6],\n * hàm nên trả về 4 vì sinh viên với mã số 1, 3, 4 và 5 đã đăng ký cả hai khóa học.\n */\n\nfunction countCommonStudents(array $courseA, array $courseB): int "
    },
    "prompt_bertscore": {
      "es": "0.9945748084027941",
      "arb": "0.974784469018764",
      "sw": "0.9548652185174423",
      "tr": "0.9757585524073591",
      "vi": "0.9681623307454419"
    },
    "canonical_solution": "{\n    // Find the intersection of both arrays to get common student IDs\n    $commonStudents = array_intersect($courseA, $courseB);\n    // Count and return the number of common student IDs\n    return count($commonStudents);\n}",
    "instruction": {
      "en": "function countCommonStudents(array $courseA, array $courseB): int\n{\n    // Find the intersection of both arrays to get common student IDs\n    $commonStudents = array_intersect($courseA, $courseB);\n    // Count and return the number of common student IDs\n    return count($commonStudents);\n}\n\nProvide a concise natural language description (docstring) of the PHP code in English using at most 500 characters.",
      "es": "function countCommonStudents(array $courseA, array $courseB): int\n{\n    // Find the intersection of both arrays to get common student IDs\n    $commonStudents = array_intersect($courseA, $courseB);\n    // Count and return the number of common student IDs\n    return count($commonStudents);\n}\n\nProporcione una descripción concisa en lenguaje natural (docstring) del código PHP en español utilizando un máximo de 500 caracteres.",
      "arb": "function countCommonStudents(array $courseA, array $courseB): int\n{\n    // Find the intersection of both arrays to get common student IDs\n    $commonStudents = array_intersect($courseA, $courseB);\n    // Count and return the number of common student IDs\n    return count($commonStudents);\n}\n\nيرجى تقديم وصف موجز بلغة طبيعية (docstring) للكود المكتوب بلغة PHP باللغة العربية الفصحى، بحيث لا يتجاوز 500 حرف.",
      "sw": "function countCommonStudents(array $courseA, array $courseB): int\n{\n    // Find the intersection of both arrays to get common student IDs\n    $commonStudents = array_intersect($courseA, $courseB);\n    // Count and return the number of common student IDs\n    return count($commonStudents);\n}\n\nToa maelezo mafupi ya lugha ya asili (docstring) ya msimbo wa PHP kwa Kiswahili kwa kutumia herufi zisizozidi 500.",
      "tr": "function countCommonStudents(array $courseA, array $courseB): int\n{\n    // Find the intersection of both arrays to get common student IDs\n    $commonStudents = array_intersect($courseA, $courseB);\n    // Count and return the number of common student IDs\n    return count($commonStudents);\n}\n\nAşağıdaki PHP kodunun Türkçe olarak en fazla 500 karakter kullanarak doğal dilde kısa bir açıklamasını (docstring) sağlayın.",
      "vi": "function countCommonStudents(array $courseA, array $courseB): int\n{\n    // Find the intersection of both arrays to get common student IDs\n    $commonStudents = array_intersect($courseA, $courseB);\n    // Count and return the number of common student IDs\n    return count($commonStudents);\n}\n\nCung cấp mô tả ngắn gọn bằng ngôn ngữ tự nhiên (docstring) cho mã PHP bằng tiếng Việt với tối đa 500 ký tự."
    },
    "instruction_bertscore": {
      "es": "0.9687069752502395",
      "arb": "0.8833251100712498",
      "sw": "0.91585798565943",
      "tr": "0.8505872479298415",
      "vi": "0.9017250367880356"
    },
    "level": "",
    "test": "function main(){\n    assert(countCommonStudents([1, 2, 3, 4, 5], [1, 3, 4, 5, 6]) === 4); // Expected: 4\n    assert(countCommonStudents([2, 4, 6, 8], [1, 3, 5, 7]) === 0); // Expected: 0, no common students\n    assert(countCommonStudents([1, 3, 5, 7, 9], [2, 3, 5, 7]) === 3); // Expected: 3, students with IDs 3, 5, and 7 are common\n    \n}\n\n\nmain();\n?>",
    "entry_point": "countCommonStudents",
    "signature": "function countCommonStudents(array $courseA, array $courseB): int",
    "docstring": {
      "en": "Counts the number of students enrolled in both courses A and B.\n  Given two arrays representing the student IDs of those who have enrolled in courses A and B,\n  this function calculates the total number of students who have enrolled in both courses.\n  \n  The function accepts two parameters:\n  - $courseA (array): An array of integers representing the IDs of students enrolled in course A.\n  - $courseB (array): An array of integers representing the IDs of students enrolled in course B.\n  \n  The function returns an integer representing the number of students enrolled in both courses.\n  \n  Example:\n  If course A has students with IDs [1, 2, 3, 4, 5] and course B has students with IDs [1, 3, 4, 5, 6],\n  the function should return 4 because students with IDs 1, 3, 4, and 5 are enrolled in both courses.",
      "es": "Cuenta el número de estudiantes inscritos en ambos cursos A y B.\n  Dadas dos matrices que representan los IDs de los estudiantes que se han inscrito en los cursos A y B,\n  esta función calcula el número total de estudiantes que se han inscrito en ambos cursos.\n  \n  La función acepta dos parámetros:\n  - $courseA (array): Una matriz de enteros que representa los IDs de los estudiantes inscritos en el curso A.\n  - $courseB (array): Una matriz de enteros que representa los IDs de los estudiantes inscritos en el curso B.\n  \n  La función devuelve un entero que representa el número de estudiantes inscritos en ambos cursos.\n  \n  Ejemplo:\n  Si el curso A tiene estudiantes con IDs [1, 2, 3, 4, 5] y el curso B tiene estudiantes con IDs [1, 3, 4, 5, 6],\n  la función debería devolver 4 porque los estudiantes con IDs 1, 3, 4 y 5 están inscritos en ambos cursos.",
      "arb": "يحسب عدد الطلاب المسجلين في كلا الدورتين A و B.\n  بالنظر إلى مصفوفتين تمثلان معرفات الطلاب الذين سجلوا في الدورتين A و B،\n  تقوم هذه الدالة بحساب العدد الإجمالي للطلاب الذين سجلوا في كلا الدورتين.\n  \n  تقبل الدالة معاملين:\n  - $courseA (array): مصفوفة من الأعداد الصحيحة تمثل معرفات الطلاب المسجلين في الدورة A.\n  - $courseB (array): مصفوفة من الأعداد الصحيحة تمثل معرفات الطلاب المسجلين في الدورة B.\n  \n  تعيد الدالة عددًا صحيحًا يمثل عدد الطلاب المسجلين في كلا الدورتين.\n  \n  مثال:\n  إذا كان لدى الدورة A طلاب بمعرفات [1, 2, 3, 4, 5] ولدى الدورة B طلاب بمعرفات [1, 3, 4, 5, 6]،\n  يجب أن تعيد الدالة 4 لأن الطلاب بمعرفات 1، 3، 4، و5 مسجلون في كلا الدورتين.",
      "sw": "Hesabu idadi ya wanafunzi waliojiandikisha katika kozi zote A na B.  \n  Ukipewa safu mbili zinazoonyesha nambari za kitambulisho za wanafunzi waliojiandikisha katika kozi A na B,  \n  kazi hii inahesabu jumla ya wanafunzi waliojiandikisha katika kozi zote mbili.  \n  \n  Kazi inakubali vigezo viwili:  \n  - $courseA (array): Safu ya nambari za kitambulisho za wanafunzi waliojiandikisha katika kozi A.  \n  - $courseB (array): Safu ya nambari za kitambulisho za wanafunzi waliojiandikisha katika kozi B.  \n  \n  Kazi inarejesha nambari inayowakilisha idadi ya wanafunzi waliojiandikisha katika kozi zote mbili.  \n  \n  Mfano:  \n  Ikiwa kozi A ina wanafunzi wenye nambari za kitambulisho [1, 2, 3, 4, 5] na kozi B ina wanafunzi wenye nambari za kitambulisho [1, 3, 4, 5, 6],  \n  kazi inapaswa kurejesha 4 kwa sababu wanafunzi wenye nambari za kitambulisho 1, 3, 4, na 5 wamejiandikisha katika kozi zote mbili.",
      "tr": "Hem A hem de B derslerine kayıtlı olan öğrencilerin sayısını sayar.\n  İki dizi verildiğinde, bu diziler kurs A ve B'ye kayıtlı olan öğrencilerin kimlik numaralarını temsil eder,\n  bu fonksiyon her iki kursa da kayıtlı olan toplam öğrenci sayısını hesaplar.\n  \n  Fonksiyon iki parametre alır:\n  - $courseA (array): Kurs A'ya kayıtlı öğrencilerin kimlik numaralarını temsil eden bir tamsayı dizisi.\n  - $courseB (array): Kurs B'ye kayıtlı öğrencilerin kimlik numaralarını temsil eden bir tamsayı dizisi.\n  \n  Fonksiyon, her iki kursa da kayıtlı olan öğrenci sayısını temsil eden bir tamsayı döndürür.\n  \n  Örnek:\n  Eğer kurs A'da kimlik numaraları [1, 2, 3, 4, 5] olan öğrenciler ve kurs B'de kimlik numaraları [1, 3, 4, 5, 6] olan öğrenciler varsa,\n  fonksiyon 4 döndürmelidir çünkü kimlik numaraları 1, 3, 4 ve 5 olan öğrenciler her iki kursa da kayıtlıdır.",
      "vi": "Đếm số lượng sinh viên đăng ký cả hai khóa học A và B.  \nCho hai mảng đại diện cho ID sinh viên đã đăng ký các khóa học A và B,  \nhàm này tính tổng số sinh viên đã đăng ký cả hai khóa học.\n\nHàm chấp nhận hai tham số:  \n- $courseA (array): Một mảng số nguyên đại diện cho ID của sinh viên đã đăng ký khóa học A.  \n- $courseB (array): Một mảng số nguyên đại diện cho ID của sinh viên đã đăng ký khóa học B.\n\nHàm trả về một số nguyên đại diện cho số lượng sinh viên đăng ký cả hai khóa học.\n\nVí dụ:  \nNếu khóa học A có sinh viên với ID [1, 2, 3, 4, 5] và khóa học B có sinh viên với ID [1, 3, 4, 5, 6],  \nhàm nên trả về 4 vì sinh viên với ID 1, 3, 4 và 5 đã đăng ký cả hai khóa học."
    },
    "docstring_bertscore": {
      "es": "0.9784954804276389",
      "arb": "0.9741401120626869",
      "sw": "0.9279579525809323",
      "tr": "0.9541700121838202",
      "vi": "0.9763800668696173"
    }
  },
  {
    "task_id": "PHP/48",
    "prompt": {
      "en": "<?php\n\n\n\n/**\n * Calculates the total earnings of Deliv-e-droid based on the number of successfully delivered and failed deliveries.\n * Deliv-e-droid earns 50 units of money for each successful delivery and loses 10 units for each failed delivery.\n * Additionally, if the number of successful deliveries is greater than the number of failed ones, Deliv-e-droid receives a bonus of 500 units.\n * \n * Arguments:\n * - $delivered: The number of successfully delivered packages (0 <= $delivered <= 100).\n * - $failed: The number of failed deliveries (0 <= $failed <= 100).\n * \n * Returns:\n * - The total earnings of Deliv-e-droid, which can be negative if the losses outweigh the gains.\n * \n * Examples:\n * - calculateDroidEarnings(5, 2) returns 730.\n * - calculateDroidEarnings(0, 10) returns -100.\n */\n\n function calculateDroidEarnings(int $delivered, int $failed): int ",
      "es": "<?php\n\n\n\n/**\n * Calcula las ganancias totales de Deliv-e-droid basadas en el número de entregas exitosas y fallidas.\n * Deliv-e-droid gana 50 unidades de dinero por cada entrega exitosa y pierde 10 unidades por cada entrega fallida.\n * Además, si el número de entregas exitosas es mayor que el número de fallidas, Deliv-e-droid recibe un bono de 500 unidades.\n * \n * Argumentos:\n * - $delivered: El número de paquetes entregados exitosamente (0 <= $delivered <= 100).\n * - $failed: El número de entregas fallidas (0 <= $failed <= 100).\n * \n * Devuelve:\n * - Las ganancias totales de Deliv-e-droid, que pueden ser negativas si las pérdidas superan las ganancias.\n * \n * Ejemplos:\n * - calculateDroidEarnings(5, 2) devuelve 730.\n * - calculateDroidEarnings(0, 10) devuelve -100.\n */\n\n function calculateDroidEarnings(int $delivered, int $failed): int ",
      "arb": "<?php\n\n\n\n/**\n * يحسب الأرباح الإجمالية لـ Deliv-e-droid بناءً على عدد عمليات التسليم الناجحة والفاشلة.\n * يكسب Deliv-e-droid 50 وحدة من المال لكل عملية تسليم ناجحة ويفقد 10 وحدات لكل عملية تسليم فاشلة.\n * بالإضافة إلى ذلك، إذا كان عدد عمليات التسليم الناجحة أكبر من عدد الفاشلة، يحصل Deliv-e-droid على مكافأة قدرها 500 وحدة.\n * \n * الوسائط:\n * - $delivered: عدد الطرود التي تم تسليمها بنجاح (0 <= $delivered <= 100).\n * - $failed: عدد عمليات التسليم الفاشلة (0 <= $failed <= 100).\n * \n * يعيد:\n * - الأرباح الإجمالية لـ Deliv-e-droid، والتي يمكن أن تكون سلبية إذا كانت الخسائر تفوق المكاسب.\n * \n * أمثلة:\n * - calculateDroidEarnings(5, 2) يعيد 730.\n * - calculateDroidEarnings(0, 10) يعيد -100.\n */\n\n function calculateDroidEarnings(int $delivered, int $failed): int ",
      "sw": "<?php\n\n\n\n/**\n * Inahesabu mapato ya jumla ya Deliv-e-droid kulingana na idadi ya uwasilishaji uliofanikiwa na uliyoshindwa.\n * Deliv-e-droid hupata vitengo 50 vya pesa kwa kila uwasilishaji uliofanikiwa na hupoteza vitengo 10 kwa kila uwasilishaji ulioshindwa.\n * Zaidi ya hayo, ikiwa idadi ya uwasilishaji uliofanikiwa ni kubwa kuliko ile ya uliyoshindwa, Deliv-e-droid hupokea bonasi ya vitengo 500.\n * \n * Hoja:\n * - $delivered: Idadi ya vifurushi vilivyowasilishwa kwa mafanikio (0 <= $delivered <= 100).\n * - $failed: Idadi ya uwasilishaji ulioshindwa (0 <= $failed <= 100).\n * \n * Inarudisha:\n * - Mapato ya jumla ya Deliv-e-droid, ambayo yanaweza kuwa hasi ikiwa hasara inazidi faida.\n * \n * Mifano:\n * - calculateDroidEarnings(5, 2) inarudisha 730.\n * - calculateDroidEarnings(0, 10) inarudisha -100.\n */\n\n function calculateDroidEarnings(int $delivered, int $failed): int ",
      "tr": "<?php\n\n\n\n/**\n * Deliv-e-droid'un başarılı teslimatlar ve başarısız teslimatlar sayısına göre toplam kazancını hesaplar.\n * Deliv-e-droid her başarılı teslimat için 50 birim para kazanır ve her başarısız teslimat için 10 birim kaybeder.\n * Ayrıca, başarılı teslimatların sayısı başarısız olanlardan fazlaysa, Deliv-e-droid 500 birim bonus alır.\n * \n * Argümanlar:\n * - $delivered: Başarıyla teslim edilen paketlerin sayısı (0 <= $delivered <= 100).\n * - $failed: Başarısız teslimatların sayısı (0 <= $failed <= 100).\n * \n * Döndürür:\n * - Deliv-e-droid'un toplam kazancı, kayıplar kazançları aşıyorsa negatif olabilir.\n * \n * Örnekler:\n * - calculateDroidEarnings(5, 2) 730 döndürür.\n * - calculateDroidEarnings(0, 10) -100 döndürür.\n */\n\n function calculateDroidEarnings(int $delivered, int $failed): int ",
      "vi": "<?php\n\n\n\n/**\n * Tính tổng thu nhập của Deliv-e-droid dựa trên số lượng giao hàng thành công và giao hàng thất bại.\n * Deliv-e-droid kiếm được 50 đơn vị tiền cho mỗi lần giao hàng thành công và mất 10 đơn vị cho mỗi lần giao hàng thất bại.\n * Ngoài ra, nếu số lượng giao hàng thành công lớn hơn số lượng giao hàng thất bại, Deliv-e-droid nhận được một khoản thưởng 500 đơn vị.\n * \n * Tham số:\n * - $delivered: Số lượng gói hàng được giao thành công (0 <= $delivered <= 100).\n * - $failed: Số lượng giao hàng thất bại (0 <= $failed <= 100).\n * \n * Trả về:\n * - Tổng thu nhập của Deliv-e-droid, có thể là số âm nếu tổn thất vượt quá lợi nhuận.\n * \n * Ví dụ:\n * - calculateDroidEarnings(5, 2) trả về 730.\n * - calculateDroidEarnings(0, 10) trả về -100.\n */\n\n function calculateDroidEarnings(int $delivered, int $failed): int "
    },
    "prompt_bertscore": {
      "es": "0.992371004325212",
      "arb": "0.9800308932730386",
      "sw": "0.978638097041222",
      "tr": "0.9806132775502329",
      "vi": "0.9723345618990797"
    },
    "canonical_solution": " {\n    $earnings = $delivered * 50;\n    $losses = $failed * 10;\n    if ($delivered > $failed) {\n        $earnings += 500; // Bonus\n    }\n    return $earnings - $losses;\n}\n",
    "instruction": {
      "en": "function calculateDroidEarnings(int $delivered, int $failed): int\n {\n    $earnings = $delivered * 50;\n    $losses = $failed * 10;\n    if ($delivered > $failed) {\n        $earnings += 500; // Bonus\n    }\n    return $earnings - $losses;\n}\n\n\nProvide a concise natural language description (docstring) of the PHP code in English using at most 500 characters.",
      "es": "function calculateDroidEarnings(int $delivered, int $failed): int\n {\n    $earnings = $delivered * 50;\n    $losses = $failed * 10;\n    if ($delivered > $failed) {\n        $earnings += 500; // Bonus\n    }\n    return $earnings - $losses;\n}\n\n\nProporcione una descripción concisa en lenguaje natural (docstring) del código PHP en español utilizando como máximo 500 caracteres.",
      "arb": "function calculateDroidEarnings(int $delivered, int $failed): int\n {\n    $earnings = $delivered * 50;\n    $losses = $failed * 10;\n    if ($delivered > $failed) {\n        $earnings += 500; // Bonus\n    }\n    return $earnings - $losses;\n}\n\n\nيرجى تقديم وصف موجز بلغة طبيعية (docstring) لشيفرة PHP باللغة العربية الفصحى، بحيث لا يتجاوز 500 حرف.",
      "sw": "function calculateDroidEarnings(int $delivered, int $failed): int\n {\n    $earnings = $delivered * 50;\n    $losses = $failed * 10;\n    if ($delivered > $failed) {\n        $earnings += 500; // Bonus\n    }\n    return $earnings - $losses;\n}\n\n\nToa maelezo mafupi ya lugha ya asili (docstring) ya msimbo wa PHP kwa Kiswahili kwa kutumia herufi zisizozidi 500.",
      "tr": "function calculateDroidEarnings(int $delivered, int $failed): int\n {\n    $earnings = $delivered * 50;\n    $losses = $failed * 10;\n    if ($delivered > $failed) {\n        $earnings += 500; // Bonus\n    }\n    return $earnings - $losses;\n}\n\n\nPHP kodunun işlevselliğini açıklayan kısa bir doğal dil açıklaması (docstring) sağlayın. Açıklama, en fazla 500 karakter kullanılarak Türkçe olarak yazılmalıdır.",
      "vi": "function calculateDroidEarnings(int $delivered, int $failed): int\n {\n    $earnings = $delivered * 50;\n    $losses = $failed * 10;\n    if ($delivered > $failed) {\n        $earnings += 500; // Bonus\n    }\n    return $earnings - $losses;\n}\n\n\nCung cấp mô tả ngắn gọn bằng ngôn ngữ tự nhiên (docstring) cho mã PHP bằng tiếng Việt, sử dụng tối đa 500 ký tự."
    },
    "instruction_bertscore": {
      "es": "0.9687069752502395",
      "arb": "0.905616007322128",
      "sw": "0.91585798565943",
      "tr": "0.8854375441735558",
      "vi": "0.9202302376067699"
    },
    "level": "",
    "test": "function main(){\n    assert(calculateDroidEarnings(5, 2) === 730, 'Test case 1 failed');\n    assert(calculateDroidEarnings(0, 10) === -100, 'Test case 2 failed');\n    assert(calculateDroidEarnings(10, 0) === 1000, 'Test case 3 failed');\n    assert(calculateDroidEarnings(3, 3) === 120, 'Test case 4 failed');\n    assert(calculateDroidEarnings(0, 0) === 0, 'Test case 5 failed');\n    \n}\n\n\nmain();\n?>",
    "entry_point": "calculateDroidEarnings",
    "signature": "function calculateDroidEarnings(int $delivered, int $failed): int",
    "docstring": {
      "en": "Calculates the total earnings of Deliv-e-droid based on the number of successfully delivered and failed deliveries.\n  Deliv-e-droid earns 50 units of money for each successful delivery and loses 10 units for each failed delivery.\n  Additionally, if the number of successful deliveries is greater than the number of failed ones, Deliv-e-droid receives a bonus of 500 units.\n  \n  Arguments:\n  - $delivered: The number of successfully delivered packages (0 <= $delivered <= 100).\n  - $failed: The number of failed deliveries (0 <= $failed <= 100).\n  \n  Returns:\n  - The total earnings of Deliv-e-droid, which can be negative if the losses outweigh the gains.\n  \n  Examples:\n  - calculateDroidEarnings(5, 2) returns 730.\n  - calculateDroidEarnings(0, 10) returns -100.",
      "es": "Calcula las ganancias totales de Deliv-e-droid basadas en el número de entregas exitosas y fallidas.\n  Deliv-e-droid gana 50 unidades de dinero por cada entrega exitosa y pierde 10 unidades por cada entrega fallida.\n  Además, si el número de entregas exitosas es mayor que el de fallidas, Deliv-e-droid recibe un bono de 500 unidades.\n  \n  Argumentos:\n  - $delivered: El número de paquetes entregados exitosamente (0 <= $delivered <= 100).\n  - $failed: El número de entregas fallidas (0 <= $failed <= 100).\n  \n  Retorna:\n  - Las ganancias totales de Deliv-e-droid, que pueden ser negativas si las pérdidas superan las ganancias.\n  \n  Ejemplos:\n  - calculateDroidEarnings(5, 2) retorna 730.\n  - calculateDroidEarnings(0, 10) retorna -100.",
      "arb": "يحسب إجمالي أرباح Deliv-e-droid بناءً على عدد عمليات التسليم الناجحة والفاشلة. يكسب Deliv-e-droid 50 وحدة من المال لكل عملية تسليم ناجحة ويفقد 10 وحدات لكل عملية تسليم فاشلة. بالإضافة إلى ذلك، إذا كان عدد عمليات التسليم الناجحة أكبر من عدد العمليات الفاشلة، يحصل Deliv-e-droid على مكافأة قدرها 500 وحدة.\n\nحجج:\n- $delivered: عدد الطرود التي تم تسليمها بنجاح (0 <= $delivered <= 100).\n- $failed: عدد عمليات التسليم الفاشلة (0 <= $failed <= 100).\n\nإرجاع:\n- إجمالي أرباح Deliv-e-droid، والتي يمكن أن تكون سلبية إذا كانت الخسائر تفوق المكاسب.\n\nأمثلة:\n- calculateDroidEarnings(5, 2) returns 730.\n- calculateDroidEarnings(0, 10) returns -100.",
      "sw": "Hesabu mapato ya jumla ya Deliv-e-droid kulingana na idadi ya usafirishaji uliofanikiwa na usafirishaji uliofeli.\n  Deliv-e-droid hupata vitengo 50 vya pesa kwa kila usafirishaji uliofanikiwa na hupoteza vitengo 10 kwa kila usafirishaji uliofeli.\n  Zaidi ya hayo, ikiwa idadi ya usafirishaji uliofanikiwa ni kubwa kuliko ile ya uliofeli, Deliv-e-droid hupokea bonasi ya vitengo 500.\n  \n  Hoja:\n  - $delivered: Idadi ya vifurushi vilivyosafirishwa kwa mafanikio (0 <= $delivered <= 100).\n  - $failed: Idadi ya usafirishaji uliofeli (0 <= $failed <= 100).\n  \n  Inarudi:\n  - Mapato ya jumla ya Deliv-e-droid, ambayo yanaweza kuwa hasi ikiwa hasara inazidi faida.\n  \n  Mifano:\n  - calculateDroidEarnings(5, 2) inarudi 730.\n  - calculateDroidEarnings(0, 10) inarudi -100.",
      "tr": "Deliv-e-droid'un başarılı ve başarısız teslimat sayısına göre toplam kazancını hesaplar. \nDeliv-e-droid, her başarılı teslimat için 50 birim para kazanır ve her başarısız teslimat için 10 birim kaybeder. \nEk olarak, başarılı teslimat sayısı başarısız olanlardan fazlaysa, Deliv-e-droid 500 birim bonus alır.\n\nArgümanlar:\n- $delivered: Başarıyla teslim edilen paketlerin sayısı (0 <= $delivered <= 100).\n- $failed: Başarısız teslimatların sayısı (0 <= $failed <= 100).\n\nDöndürür:\n- Deliv-e-droid'un toplam kazancı, kayıplar kazançlardan fazla olduğunda negatif olabilir.\n\nÖrnekler:\n- calculateDroidEarnings(5, 2) 730 döndürür.\n- calculateDroidEarnings(0, 10) -100 döndürür.",
      "vi": "Tính toán tổng thu nhập của Deliv-e-droid dựa trên số lượng giao hàng thành công và thất bại. Deliv-e-droid kiếm được 50 đơn vị tiền cho mỗi lần giao hàng thành công và mất 10 đơn vị cho mỗi lần giao hàng thất bại. Ngoài ra, nếu số lượng giao hàng thành công lớn hơn số lượng giao hàng thất bại, Deliv-e-droid nhận được một khoản thưởng 500 đơn vị.\n\nArguments:\n- $delivered: Số lượng gói hàng được giao thành công (0 <= $delivered <= 100).\n- $failed: Số lượng giao hàng thất bại (0 <= $failed <= 100).\n\nTrả về:\n- Tổng thu nhập của Deliv-e-droid, có thể là số âm nếu tổn thất lớn hơn lợi nhuận.\n\nVí dụ:\n- calculateDroidEarnings(5, 2) trả về 730.\n- calculateDroidEarnings(0, 10) trả về -100."
    },
    "docstring_bertscore": {
      "es": "0.9837234320564772",
      "arb": "0.9893891650451163",
      "sw": "0.971220046831093",
      "tr": "0.9753779765972963",
      "vi": "0.98428059027528"
    }
  },
  {
    "task_id": "PHP/49",
    "prompt": {
      "en": "<?php\n\n\n/**\n * Identifies the missing (broken) and duplicate IDs from a given set of ID groups.\n * Each ID group represents a collection of ticket IDs which are supposed to be consecutive but contain a mistake:\n * one ID is missing, and one ID is duplicated. This function calculates and returns the missing and duplicated IDs.\n *\n * Note: The missing ID will not be at the start or end of the overall ID range.\n *\n * Input: An array of arrays, where each sub-array contains integers representing ticket IDs.\n * Output: An array with two integers, the first being the missing (broken) ID and the second the duplicate ID.\n *\n * Example:\n * Input: [[5, 6, 8, 11, 9], [10, 12, 9]]\n * Output: [7, 9] // 7 is missing, and 9 is duplicated.\n */\nfunction findMissingAndDuplicateIDs(array $idGroups): array ",
      "es": "<?php\n\n\n/**\n * Identifica los IDs faltantes (rotos) y duplicados de un conjunto dado de grupos de IDs.\n * Cada grupo de IDs representa una colección de IDs de tickets que se supone que son consecutivos pero contienen un error:\n * falta un ID y hay un ID duplicado. Esta función calcula y devuelve los IDs faltantes y duplicados.\n *\n * Nota: El ID faltante no estará al inicio o al final del rango total de IDs.\n *\n * Entrada: Un array de arrays, donde cada sub-array contiene enteros que representan IDs de tickets.\n * Salida: Un array con dos enteros, el primero siendo el ID faltante (roto) y el segundo el ID duplicado.\n *\n * Ejemplo:\n * Entrada: [[5, 6, 8, 11, 9], [10, 12, 9]]\n * Salida: [7, 9] // 7 falta, y 9 está duplicado.\n */\nfunction findMissingAndDuplicateIDs(array $idGroups): array ",
      "arb": "<?php\n\n\n/**\n * يحدد المعرفات المفقودة (المكسورة) والمكررة من مجموعة معينة من مجموعات المعرفات.\n * تمثل كل مجموعة معرفات مجموعة من معرفات التذاكر التي من المفترض أن تكون متتالية ولكن تحتوي على خطأ:\n * معرف واحد مفقود، ومعرف واحد مكرر. تقوم هذه الدالة بحساب وإرجاع المعرفات المفقودة والمكررة.\n *\n * ملاحظة: لن يكون المعرف المفقود في بداية أو نهاية نطاق المعرفات الكلي.\n *\n * المدخل: مصفوفة من المصفوفات، حيث تحتوي كل مصفوفة فرعية على أعداد صحيحة تمثل معرفات التذاكر.\n * المخرج: مصفوفة تحتوي على عددين صحيحين، الأول هو المعرف المفقود (المكسور) والثاني هو المعرف المكرر.\n *\n * مثال:\n * المدخل: [[5, 6, 8, 11, 9], [10, 12, 9]]\n * المخرج: [7, 9] // 7 مفقود، و9 مكرر.\n */\nfunction findMissingAndDuplicateIDs(array $idGroups): array ",
      "sw": "<?php\n\n\n/**\n * Inatambua vitambulisho vilivyokosekana (vilivyovunjika) na vilivyojirudia kutoka kwenye seti ya makundi ya vitambulisho.\n * Kila kundi la vitambulisho linawakilisha mkusanyiko wa vitambulisho vya tiketi ambavyo vinapaswa kuwa mfululizo lakini vina kosa:\n * kitambulisho kimoja kinakosekana, na kitambulisho kimoja kimejirudia. Kazi hii inahesabu na kurudisha vitambulisho vilivyokosekana na vilivyojirudia.\n *\n * Kumbuka: Kitambulisho kilichokosekana hakitakuwa mwanzoni au mwisho wa safu ya jumla ya vitambulisho.\n *\n * Ingizo: Safu ya safu, ambapo kila safu ndogo ina namba nzima zinazowakilisha vitambulisho vya tiketi.\n * Tokeo: Safu yenye namba mbili nzima, ya kwanza ikiwa ni kitambulisho kilichokosekana (kilichovunjika) na ya pili ni kitambulisho kilichojirudia.\n *\n * Mfano:\n * Ingizo: [[5, 6, 8, 11, 9], [10, 12, 9]]\n * Tokeo: [7, 9] // 7 kinakosekana, na 9 kimejirudia.\n */\nfunction findMissingAndDuplicateIDs(array $idGroups): array ",
      "tr": "<?php\n\n\n/**\n * Belirtilen bir ID grubu kümesinden eksik (bozuk) ve yinelenen ID'leri tanımlar.\n * Her ID grubu, ardışık olması gereken ancak bir hata içeren bilet ID'lerinin bir koleksiyonunu temsil eder:\n * bir ID eksik ve bir ID yinelenmiştir. Bu fonksiyon eksik ve yinelenen ID'leri hesaplar ve döndürür.\n *\n * Not: Eksik ID, genel ID aralığının başlangıcında veya sonunda olmayacaktır.\n *\n * Girdi: Her alt dizinin bilet ID'lerini temsil eden tamsayılar içerdiği bir dizi dizisi.\n * Çıktı: İlk elemanı eksik (bozuk) ID ve ikinci elemanı yinelenen ID olan iki tamsayıdan oluşan bir dizi.\n *\n * Örnek:\n * Girdi: [[5, 6, 8, 11, 9], [10, 12, 9]]\n * Çıktı: [7, 9] // 7 eksik ve 9 yinelenmiştir.\n */\nfunction findMissingAndDuplicateIDs(array $idGroups): array ",
      "vi": "<?php\n\n\n/**\n * Xác định các ID bị thiếu (bị hỏng) và trùng lặp từ một tập hợp các nhóm ID đã cho.\n * Mỗi nhóm ID đại diện cho một tập hợp các ID vé được cho là liên tiếp nhưng chứa một lỗi:\n * một ID bị thiếu và một ID bị trùng lặp. Hàm này tính toán và trả về các ID bị thiếu và trùng lặp.\n *\n * Lưu ý: ID bị thiếu sẽ không nằm ở đầu hoặc cuối của phạm vi ID tổng thể.\n *\n * Đầu vào: Một mảng các mảng, trong đó mỗi mảng con chứa các số nguyên đại diện cho các ID vé.\n * Đầu ra: Một mảng với hai số nguyên, số đầu tiên là ID bị thiếu (bị hỏng) và số thứ hai là ID trùng lặp.\n *\n * Ví dụ:\n * Đầu vào: [[5, 6, 8, 11, 9], [10, 12, 9]]\n * Đầu ra: [7, 9] // 7 bị thiếu, và 9 bị trùng lặp.\n */\nfunction findMissingAndDuplicateIDs(array $idGroups): array "
    },
    "prompt_bertscore": {
      "es": "0.98003307820723",
      "arb": "0.9509410767097171",
      "sw": "0.9732883849888093",
      "tr": "0.9674832134726836",
      "vi": "0.9674450764395249"
    },
    "canonical_solution": "{\n    // Flatten the array of ID groups into a single array\n    $allIds = array_merge(...$idGroups);\n    \n    // Sort the IDs to make it easier to find duplicates and missing IDs\n    sort($allIds);\n    \n    $missingID = null;\n    $duplicateID = null;\n    \n    // Iterate over the sorted IDs to find the missing and duplicate IDs\n    for ($i = 0; $i < count($allIds) - 1; $i++) {\n        // Check if the next ID is the same as the current ID (duplicate)\n        if ($allIds[$i] == $allIds[$i + 1]) {\n            $duplicateID = $allIds[$i];\n        }\n        // Check if the next ID is not the immediate successor (missing)\n        elseif ($allIds[$i] + 1 != $allIds[$i + 1]) {\n            $missingID = $allIds[$i] + 1;\n        }\n    }\n    \n    // Return both the missing and the duplicate IDs\n    return [$missingID, $duplicateID];\n}",
    "instruction": {
      "en": "function findMissingAndDuplicateIDs(array $idGroups): array\n{\n    // Flatten the array of ID groups into a single array\n    $allIds = array_merge(...$idGroups);\n    \n    // Sort the IDs to make it easier to find duplicates and missing IDs\n    sort($allIds);\n    \n    $missingID = null;\n    $duplicateID = null;\n    \n    // Iterate over the sorted IDs to find the missing and duplicate IDs\n    for ($i = 0; $i < count($allIds) - 1; $i++) {\n        // Check if the next ID is the same as the current ID (duplicate)\n        if ($allIds[$i] == $allIds[$i + 1]) {\n            $duplicateID = $allIds[$i];\n        }\n        // Check if the next ID is not the immediate successor (missing)\n        elseif ($allIds[$i] + 1 != $allIds[$i + 1]) {\n            $missingID = $allIds[$i] + 1;\n        }\n    }\n    \n    // Return both the missing and the duplicate IDs\n    return [$missingID, $duplicateID];\n}\n\nProvide a concise natural language description (docstring) of the PHP code in English using at most 500 characters.",
      "es": "function findMissingAndDuplicateIDs(array $idGroups): array\n{\n    // Flatten the array of ID groups into a single array\n    $allIds = array_merge(...$idGroups);\n    \n    // Sort the IDs to make it easier to find duplicates and missing IDs\n    sort($allIds);\n    \n    $missingID = null;\n    $duplicateID = null;\n    \n    // Iterate over the sorted IDs to find the missing and duplicate IDs\n    for ($i = 0; $i < count($allIds) - 1; $i++) {\n        // Check if the next ID is the same as the current ID (duplicate)\n        if ($allIds[$i] == $allIds[$i + 1]) {\n            $duplicateID = $allIds[$i];\n        }\n        // Check if the next ID is not the immediate successor (missing)\n        elseif ($allIds[$i] + 1 != $allIds[$i + 1]) {\n            $missingID = $allIds[$i] + 1;\n        }\n    }\n    \n    // Return both the missing and the duplicate IDs\n    return [$missingID, $duplicateID];\n}\n\nProporciona una descripción concisa en lenguaje natural (docstring) del código PHP en español usando un máximo de 500 caracteres.",
      "arb": "function findMissingAndDuplicateIDs(array $idGroups): array\n{\n    // Flatten the array of ID groups into a single array\n    $allIds = array_merge(...$idGroups);\n    \n    // Sort the IDs to make it easier to find duplicates and missing IDs\n    sort($allIds);\n    \n    $missingID = null;\n    $duplicateID = null;\n    \n    // Iterate over the sorted IDs to find the missing and duplicate IDs\n    for ($i = 0; $i < count($allIds) - 1; $i++) {\n        // Check if the next ID is the same as the current ID (duplicate)\n        if ($allIds[$i] == $allIds[$i + 1]) {\n            $duplicateID = $allIds[$i];\n        }\n        // Check if the next ID is not the immediate successor (missing)\n        elseif ($allIds[$i] + 1 != $allIds[$i + 1]) {\n            $missingID = $allIds[$i] + 1;\n        }\n    }\n    \n    // Return both the missing and the duplicate IDs\n    return [$missingID, $duplicateID];\n}\n\nيرجى تقديم وصف موجز بلغة طبيعية (docstring) لشيفرة PHP باللغة العربية الفصحى باستخدام 500 حرف كحد أقصى.",
      "sw": "function findMissingAndDuplicateIDs(array $idGroups): array\n{\n    // Flatten the array of ID groups into a single array\n    $allIds = array_merge(...$idGroups);\n    \n    // Sort the IDs to make it easier to find duplicates and missing IDs\n    sort($allIds);\n    \n    $missingID = null;\n    $duplicateID = null;\n    \n    // Iterate over the sorted IDs to find the missing and duplicate IDs\n    for ($i = 0; $i < count($allIds) - 1; $i++) {\n        // Check if the next ID is the same as the current ID (duplicate)\n        if ($allIds[$i] == $allIds[$i + 1]) {\n            $duplicateID = $allIds[$i];\n        }\n        // Check if the next ID is not the immediate successor (missing)\n        elseif ($allIds[$i] + 1 != $allIds[$i + 1]) {\n            $missingID = $allIds[$i] + 1;\n        }\n    }\n    \n    // Return both the missing and the duplicate IDs\n    return [$missingID, $duplicateID];\n}\n\nToa maelezo mafupi ya lugha ya asili (docstring) ya msimbo wa PHP kwa Kiswahili kwa kutumia herufi zisizozidi 500.",
      "tr": "function findMissingAndDuplicateIDs(array $idGroups): array\n{\n    // Flatten the array of ID groups into a single array\n    $allIds = array_merge(...$idGroups);\n    \n    // Sort the IDs to make it easier to find duplicates and missing IDs\n    sort($allIds);\n    \n    $missingID = null;\n    $duplicateID = null;\n    \n    // Iterate over the sorted IDs to find the missing and duplicate IDs\n    for ($i = 0; $i < count($allIds) - 1; $i++) {\n        // Check if the next ID is the same as the current ID (duplicate)\n        if ($allIds[$i] == $allIds[$i + 1]) {\n            $duplicateID = $allIds[$i];\n        }\n        // Check if the next ID is not the immediate successor (missing)\n        elseif ($allIds[$i] + 1 != $allIds[$i + 1]) {\n            $missingID = $allIds[$i] + 1;\n        }\n    }\n    \n    // Return both the missing and the duplicate IDs\n    return [$missingID, $duplicateID];\n}\n\nPHP kodunun işlevini açıklayan en fazla 500 karakterlik kısa bir doğal dil tanımı (docstring) sağlayın.",
      "vi": "function findMissingAndDuplicateIDs(array $idGroups): array\n{\n    // Flatten the array of ID groups into a single array\n    $allIds = array_merge(...$idGroups);\n    \n    // Sort the IDs to make it easier to find duplicates and missing IDs\n    sort($allIds);\n    \n    $missingID = null;\n    $duplicateID = null;\n    \n    // Iterate over the sorted IDs to find the missing and duplicate IDs\n    for ($i = 0; $i < count($allIds) - 1; $i++) {\n        // Check if the next ID is the same as the current ID (duplicate)\n        if ($allIds[$i] == $allIds[$i + 1]) {\n            $duplicateID = $allIds[$i];\n        }\n        // Check if the next ID is not the immediate successor (missing)\n        elseif ($allIds[$i] + 1 != $allIds[$i + 1]) {\n            $missingID = $allIds[$i] + 1;\n        }\n    }\n    \n    // Return both the missing and the duplicate IDs\n    return [$missingID, $duplicateID];\n}\n\nCung cấp mô tả ngắn gọn bằng ngôn ngữ tự nhiên (docstring) của mã PHP bằng tiếng Việt, không quá 500 ký tự."
    },
    "instruction_bertscore": {
      "es": "0.9687069752502395",
      "arb": "0.9008484809165287",
      "sw": "0.91585798565943",
      "tr": "0.8675860359388073",
      "vi": "0.9253207370119321"
    },
    "level": "",
    "test": "function main(){\n\n    // Test case based on the example provided\n    assert(findMissingAndDuplicateIDs([[5, 6, 8, 11, 9], [10, 12, 9]]) === [7, 9]);\n    \n    // Additional test cases\n    assert(findMissingAndDuplicateIDs([[1, 2, 4], [3, 5, 5, 7]]) === [6, 5]);\n    assert(findMissingAndDuplicateIDs([[10, 11, 12, 14, 17], [13, 15, 12]]) === [16, 12]);\n    \n}\n\n\nmain();\n?>",
    "entry_point": "findMissingAndDuplicateIDs",
    "signature": "function findMissingAndDuplicateIDs(array $idGroups): array",
    "docstring": {
      "en": "Identifies the missing (broken) and duplicate IDs from a given set of ID groups.\n  Each ID group represents a collection of ticket IDs which are supposed to be consecutive but contain a mistake:\n  one ID is missing, and one ID is duplicated. This function calculates and returns the missing and duplicated IDs.\n \n  Note: The missing ID will not be at the start or end of the overall ID range.\n \n  Input: An array of arrays, where each sub-array contains integers representing ticket IDs.\n  Output: An array with two integers, the first being the missing (broken) ID and the second the duplicate ID.\n \n  Example:\n  Input: [[5, 6, 8, 11, 9], [10, 12, 9]]\n  Output: [7, 9] // 7 is missing, and 9 is duplicated.",
      "es": "Identifica los IDs faltantes (rotos) y duplicados de un conjunto dado de grupos de IDs. \n  Cada grupo de IDs representa una colección de IDs de boletos que se supone que son consecutivos pero contienen un error:\n  falta un ID y un ID está duplicado. Esta función calcula y devuelve los IDs faltantes y duplicados.\n \n  Nota: El ID faltante no estará al principio o al final del rango total de IDs.\n \n  Entrada: Un array de arrays, donde cada sub-array contiene enteros que representan IDs de boletos.\n  Salida: Un array con dos enteros, el primero siendo el ID faltante (roto) y el segundo el ID duplicado.\n \n  Ejemplo:\n  Entrada: [[5, 6, 8, 11, 9], [10, 12, 9]]\n  Salida: [7, 9] // 7 falta, y 9 está duplicado.",
      "arb": "يحدد المعرفات المفقودة (المكسورة) والمكررة من مجموعة معينة من مجموعات المعرفات.\n  يمثل كل مجموعة معرفات مجموعة من معرفات التذاكر التي من المفترض أن تكون متتالية ولكن تحتوي على خطأ:\n  معرف واحد مفقود، ومعرف واحد مكرر. تقوم هذه الدالة بحساب وإرجاع المعرفات المفقودة والمكررة.\n \n  ملاحظة: لن يكون المعرف المفقود في بداية أو نهاية النطاق الكلي للمعرفات.\n \n  المدخل: مصفوفة من المصفوفات، حيث تحتوي كل مصفوفة فرعية على أعداد صحيحة تمثل معرفات التذاكر.\n  المخرج: مصفوفة تحتوي على عددين صحيحين، الأول هو المعرف المفقود (المكسور) والثاني هو المعرف المكرر.\n \n  مثال:\n  المدخل: [[5, 6, 8, 11, 9], [10, 12, 9]]\n  المخرج: [7, 9] // 7 مفقود، و9 مكرر.",
      "sw": "Inatambua vitambulisho vilivyokosekana (vilivyovunjika) na vilivyodurufu kutoka kwenye seti iliyotolewa ya makundi ya vitambulisho.\n  Kila kundi la vitambulisho linawakilisha mkusanyiko wa vitambulisho vya tiketi ambavyo vinapaswa kuwa mfululizo lakini vina kosa:\n  kitambulisho kimoja kinakosekana, na kitambulisho kimoja kimerudiwa. Kazi hii inahesabu na kurudisha vitambulisho vilivyokosekana na vilivyodurufu.\n\n  Kumbuka: Kitambulisho kilichokosekana hakitakuwa mwanzoni au mwishoni mwa safu ya jumla ya vitambulisho.\n\n  Ingizo: Safu ya safu, ambapo kila safu ndogo ina namba ambazo zinawakilisha vitambulisho vya tiketi.\n  Tokeo: Safu yenye namba mbili, ya kwanza ikiwa ni kitambulisho kilichokosekana (kilichovunjika) na ya pili ikiwa ni kitambulisho kilichodurufu.\n\n  Mfano:\n  Ingizo: [[5, 6, 8, 11, 9], [10, 12, 9]]\n  Tokeo: [7, 9] // 7 kinakosekana, na 9 kimerudiwa.",
      "tr": "Verilen bir ID grubu kümesinden eksik (bozuk) ve yinelenen ID'leri tanımlar. \n  Her ID grubu, ardışık olması gereken ancak bir hata içeren bilet ID'lerinin bir koleksiyonunu temsil eder: \n  bir ID eksiktir ve bir ID yinelenmiştir. Bu fonksiyon, eksik ve yinelenen ID'leri hesaplar ve döndürür.\n \n  Not: Eksik ID, genel ID aralığının başlangıcında veya sonunda olmayacaktır.\n \n  Girdi: Her alt dizi, bilet ID'lerini temsil eden tamsayılar içeren dizilerin bir dizisi.\n  Çıktı: İlk tamsayı eksik (bozuk) ID ve ikincisi yinelenen ID olan iki tamsayı içeren bir dizi.\n \n  Örnek:\n  Girdi: [[5, 6, 8, 11, 9], [10, 12, 9]]\n  Çıktı: [7, 9] // 7 eksik ve 9 yinelenmiştir.",
      "vi": "Xác định các ID bị thiếu (bị lỗi) và trùng lặp từ một tập hợp các nhóm ID đã cho. \nMỗi nhóm ID đại diện cho một tập hợp các ID vé được cho là liên tiếp nhưng chứa một lỗi: \nmột ID bị thiếu và một ID bị trùng lặp. Hàm này tính toán và trả về các ID bị thiếu và trùng lặp.\n\nLưu ý: ID bị thiếu sẽ không nằm ở đầu hoặc cuối của phạm vi ID tổng thể.\n\nĐầu vào: Một mảng các mảng, trong đó mỗi mảng con chứa các số nguyên đại diện cho các ID vé.\nĐầu ra: Một mảng với hai số nguyên, số đầu tiên là ID bị thiếu (bị lỗi) và số thứ hai là ID trùng lặp.\n\nVí dụ:\nĐầu vào: [[5, 6, 8, 11, 9], [10, 12, 9]]\nĐầu ra: [7, 9] // 7 bị thiếu, và 9 bị trùng lặp."
    },
    "docstring_bertscore": {
      "es": "0.983375630259285",
      "arb": "0.9369147923529385",
      "sw": "0.9470147499678004",
      "tr": "0.937965547068613",
      "vi": "0.9557662059258166"
    }
  },
  {
    "task_id": "PHP/50",
    "prompt": {
      "en": "<?php\n\n\n/**\n * Counts the number of digits, lowercase letters, and uppercase letters in an 8-character string.\n *\n * This function takes a single string of exactly 8 characters as input.\n * It then counts and returns the number of digits, lowercase letters, and uppercase letters within the string.\n *\n * Input: A string of 8 characters.\n * Output: An array of three integers, where:\n * - The first integer is the count of digits in the string.\n * - The second integer is the count of lowercase letters in the string.\n * - The third integer is the count of uppercase letters in the string.\n *\n * Examples:\n * - For the string \"yLOI2022\", the output should be [4, 1, 3].\n * - For the string \"IAKIOIOI\", the output should be [0, 0, 8].\n * - For the string \"1n2s0e1s\", the output should be [4, 4, 0].\n */\n\n function countCharacters($s) ",
      "es": "<?php\n\n\n/**\n * Cuenta el número de dígitos, letras minúsculas y letras mayúsculas en una cadena de 8 caracteres.\n *\n * Esta función toma una sola cadena de exactamente 8 caracteres como entrada.\n * Luego cuenta y devuelve el número de dígitos, letras minúsculas y letras mayúsculas dentro de la cadena.\n *\n * Entrada: Una cadena de 8 caracteres.\n * Salida: Un arreglo de tres enteros, donde:\n * - El primer entero es el conteo de dígitos en la cadena.\n * - El segundo entero es el conteo de letras minúsculas en la cadena.\n * - El tercer entero es el conteo de letras mayúsculas en la cadena.\n *\n * Ejemplos:\n * - Para la cadena \"yLOI2022\", la salida debería ser [4, 1, 3].\n * - Para la cadena \"IAKIOIOI\", la salida debería ser [0, 0, 8].\n * - Para la cadena \"1n2s0e1s\", la salida debería ser [4, 4, 0].\n */\n\n function countCharacters($s) ",
      "arb": "<?php\n\n\n/**\n * يحسب عدد الأرقام، الأحرف الصغيرة، والأحرف الكبيرة في سلسلة مكونة من 8 أحرف.\n *\n * تأخذ هذه الدالة سلسلة واحدة مكونة من 8 أحرف بالضبط كمدخل.\n * ثم تقوم بحساب وإرجاع عدد الأرقام، الأحرف الصغيرة، والأحرف الكبيرة داخل السلسلة.\n *\n * المدخل: سلسلة مكونة من 8 أحرف.\n * المخرج: مصفوفة من ثلاثة أعداد صحيحة، حيث:\n * - العدد الصحيح الأول هو عدد الأرقام في السلسلة.\n * - العدد الصحيح الثاني هو عدد الأحرف الصغيرة في السلسلة.\n * - العدد الصحيح الثالث هو عدد الأحرف الكبيرة في السلسلة.\n *\n * أمثلة:\n * - بالنسبة للسلسلة \"yLOI2022\"، يجب أن يكون المخرج [4, 1, 3].\n * - بالنسبة للسلسلة \"IAKIOIOI\"، يجب أن يكون المخرج [0, 0, 8].\n * - بالنسبة للسلسلة \"1n2s0e1s\"، يجب أن يكون المخرج [4, 4, 0].\n */\n\n function countCharacters($s) ",
      "sw": "<?php\n\n\n/**\n * Inahesabu idadi ya tarakimu, herufi ndogo, na herufi kubwa katika kamba yenye herufi 8.\n *\n * Kazi hii inachukua kamba moja yenye herufi 8 kamili kama ingizo.\n * Kisha inahesabu na kurudisha idadi ya tarakimu, herufi ndogo, na herufi kubwa ndani ya kamba.\n *\n * Ingizo: Kamba yenye herufi 8.\n * Tokeo: Mfululizo wa namba tatu, ambapo:\n * - Namba ya kwanza ni idadi ya tarakimu katika kamba.\n * - Namba ya pili ni idadi ya herufi ndogo katika kamba.\n * - Namba ya tatu ni idadi ya herufi kubwa katika kamba.\n *\n * Mifano:\n * - Kwa kamba \"yLOI2022\", matokeo yanapaswa kuwa [4, 1, 3].\n * - Kwa kamba \"IAKIOIOI\", matokeo yanapaswa kuwa [0, 0, 8].\n * - Kwa kamba \"1n2s0e1s\", matokeo yanapaswa kuwa [4, 4, 0].\n */\n\n function countCharacters($s) ",
      "tr": "<?php\n\n\n/**\n * Bir 8 karakterlik stringdeki rakamların, küçük harflerin ve büyük harflerin sayısını sayar.\n *\n * Bu fonksiyon, tam olarak 8 karakterden oluşan bir string alır.\n * Daha sonra stringdeki rakamların, küçük harflerin ve büyük harflerin sayısını sayar ve döndürür.\n *\n * Girdi: 8 karakterlik bir string.\n * Çıktı: Üç tam sayıdan oluşan bir dizi, burada:\n * - İlk tam sayı stringdeki rakamların sayısıdır.\n * - İkinci tam sayı stringdeki küçük harflerin sayısıdır.\n * - Üçüncü tam sayı stringdeki büyük harflerin sayısıdır.\n *\n * Örnekler:\n * - \"yLOI2022\" stringi için, çıktı [4, 1, 3] olmalıdır.\n * - \"IAKIOIOI\" stringi için, çıktı [0, 0, 8] olmalıdır.\n * - \"1n2s0e1s\" stringi için, çıktı [4, 4, 0] olmalıdır.\n */\n\n function countCharacters($s) ",
      "vi": "<?php\n\n\n/**\n * Đếm số chữ số, chữ cái thường, và chữ cái hoa trong một chuỗi có 8 ký tự.\n *\n * Hàm này nhận một chuỗi có đúng 8 ký tự làm đầu vào.\n * Sau đó, nó đếm và trả về số chữ số, chữ cái thường, và chữ cái hoa trong chuỗi.\n *\n * Đầu vào: Một chuỗi có 8 ký tự.\n * Đầu ra: Một mảng gồm ba số nguyên, trong đó:\n * - Số nguyên đầu tiên là số lượng chữ số trong chuỗi.\n * - Số nguyên thứ hai là số lượng chữ cái thường trong chuỗi.\n * - Số nguyên thứ ba là số lượng chữ cái hoa trong chuỗi.\n *\n * Ví dụ:\n * - Với chuỗi \"yLOI2022\", đầu ra sẽ là [4, 1, 3].\n * - Với chuỗi \"IAKIOIOI\", đầu ra sẽ là [0, 0, 8].\n * - Với chuỗi \"1n2s0e1s\", đầu ra sẽ là [4, 4, 0].\n */\n\n function countCharacters($s) "
    },
    "prompt_bertscore": {
      "es": "0.999999801369619",
      "arb": "0.9742531327494958",
      "sw": "0.969609353071281",
      "tr": "0.9847424059111861",
      "vi": "0.9710051287588133"
    },
    "canonical_solution": " {\n    $digitCount = $lowerCount = $upperCount = 0;\n    \n    for ($i = 0; $i < strlen($s); $i++) {\n        if (ctype_digit($s[$i])) {\n            $digitCount++;\n        } elseif (ctype_lower($s[$i])) {\n            $lowerCount++;\n        } elseif (ctype_upper($s[$i])) {\n            $upperCount++;\n        }\n    }\n    \n    return [$digitCount, $lowerCount, $upperCount];\n}",
    "instruction": {
      "en": "function countCharacters($s)\n {\n    $digitCount = $lowerCount = $upperCount = 0;\n    \n    for ($i = 0; $i < strlen($s); $i++) {\n        if (ctype_digit($s[$i])) {\n            $digitCount++;\n        } elseif (ctype_lower($s[$i])) {\n            $lowerCount++;\n        } elseif (ctype_upper($s[$i])) {\n            $upperCount++;\n        }\n    }\n    \n    return [$digitCount, $lowerCount, $upperCount];\n}\n\nProvide a concise natural language description (docstring) of the PHP code in English using at most 500 characters.",
      "es": "function countCharacters($s)\n {\n    $digitCount = $lowerCount = $upperCount = 0;\n    \n    for ($i = 0; $i < strlen($s); $i++) {\n        if (ctype_digit($s[$i])) {\n            $digitCount++;\n        } elseif (ctype_lower($s[$i])) {\n            $lowerCount++;\n        } elseif (ctype_upper($s[$i])) {\n            $upperCount++;\n        }\n    }\n    \n    return [$digitCount, $lowerCount, $upperCount];\n}\n\nProporcione una descripción concisa en lenguaje natural (docstring) del código PHP en español utilizando un máximo de 500 caracteres.",
      "arb": "function countCharacters($s)\n {\n    $digitCount = $lowerCount = $upperCount = 0;\n    \n    for ($i = 0; $i < strlen($s); $i++) {\n        if (ctype_digit($s[$i])) {\n            $digitCount++;\n        } elseif (ctype_lower($s[$i])) {\n            $lowerCount++;\n        } elseif (ctype_upper($s[$i])) {\n            $upperCount++;\n        }\n    }\n    \n    return [$digitCount, $lowerCount, $upperCount];\n}\n\nيرجى تقديم وصف موجز بلغة طبيعية (docstring) للكود المكتوب بلغة PHP باللغة العربية الفصحى، بحيث لا يتجاوز 500 حرف.",
      "sw": "function countCharacters($s)\n {\n    $digitCount = $lowerCount = $upperCount = 0;\n    \n    for ($i = 0; $i < strlen($s); $i++) {\n        if (ctype_digit($s[$i])) {\n            $digitCount++;\n        } elseif (ctype_lower($s[$i])) {\n            $lowerCount++;\n        } elseif (ctype_upper($s[$i])) {\n            $upperCount++;\n        }\n    }\n    \n    return [$digitCount, $lowerCount, $upperCount];\n}\n\nToa maelezo mafupi ya lugha ya asili (docstring) ya msimbo wa PHP kwa Kiswahili kwa kutumia herufi zisizozidi 500.",
      "tr": "function countCharacters($s)\n {\n    $digitCount = $lowerCount = $upperCount = 0;\n    \n    for ($i = 0; $i < strlen($s); $i++) {\n        if (ctype_digit($s[$i])) {\n            $digitCount++;\n        } elseif (ctype_lower($s[$i])) {\n            $lowerCount++;\n        } elseif (ctype_upper($s[$i])) {\n            $upperCount++;\n        }\n    }\n    \n    return [$digitCount, $lowerCount, $upperCount];\n}\n\nPHP kodunun işlevini açıklayan kısa bir doğal dil açıklaması (docstring) sağlayın. Açıklama, en fazla 500 karakter kullanarak Türkçe olarak yazılmalıdır.",
      "vi": "function countCharacters($s)\n {\n    $digitCount = $lowerCount = $upperCount = 0;\n    \n    for ($i = 0; $i < strlen($s); $i++) {\n        if (ctype_digit($s[$i])) {\n            $digitCount++;\n        } elseif (ctype_lower($s[$i])) {\n            $lowerCount++;\n        } elseif (ctype_upper($s[$i])) {\n            $upperCount++;\n        }\n    }\n    \n    return [$digitCount, $lowerCount, $upperCount];\n}\n\nCung cấp mô tả ngắn gọn bằng ngôn ngữ tự nhiên (docstring) cho mã PHP bằng tiếng Việt với tối đa 500 ký tự."
    },
    "instruction_bertscore": {
      "es": "0.9687069752502395",
      "arb": "0.8898884537517856",
      "sw": "0.91585798565943",
      "tr": "0.881863190466833",
      "vi": "0.9017250367880356"
    },
    "level": "",
    "test": "function main(){\n    // Testcases\n    assert(countCharacters(\"yLOI2022\") === [4, 1, 3]);\n    assert(countCharacters(\"IAKIOIOI\") === [0, 0, 8]);\n    assert(countCharacters(\"1n2s0e1s\") === [4, 4, 0]);\n\n    // echo \"All test cases passed!\";\n\n}\n\n\nmain();\n?>",
    "entry_point": "countCharacters",
    "signature": "function countCharacters($s)",
    "docstring": {
      "en": "Counts the number of digits, lowercase letters, and uppercase letters in an 8-character string.\n \n  This function takes a single string of exactly 8 characters as input.\n  It then counts and returns the number of digits, lowercase letters, and uppercase letters within the string.\n \n  Input: A string of 8 characters.\n  Output: An array of three integers, where:\n  - The first integer is the count of digits in the string.\n  - The second integer is the count of lowercase letters in the string.\n  - The third integer is the count of uppercase letters in the string.\n \n  Examples:\n  - For the string \"yLOI2022\", the output should be [4, 1, 3].\n  - For the string \"IAKIOIOI\", the output should be [0, 0, 8].\n  - For the string \"1n2s0e1s\", the output should be [4, 4, 0].",
      "es": "Cuenta el número de dígitos, letras minúsculas y letras mayúsculas en una cadena de 8 caracteres.\n\n  Esta función toma una sola cadena de exactamente 8 caracteres como entrada.\n  Luego cuenta y devuelve el número de dígitos, letras minúsculas y letras mayúsculas dentro de la cadena.\n\n  Entrada: Una cadena de 8 caracteres.\n  Salida: Un arreglo de tres enteros, donde:\n  - El primer entero es el conteo de dígitos en la cadena.\n  - El segundo entero es el conteo de letras minúsculas en la cadena.\n  - El tercer entero es el conteo de letras mayúsculas en la cadena.\n\n  Ejemplos:\n  - Para la cadena \"yLOI2022\", la salida debería ser [4, 1, 3].\n  - Para la cadena \"IAKIOIOI\", la salida debería ser [0, 0, 8].\n  - Para la cadena \"1n2s0e1s\", la salida debería ser [4, 4, 0].",
      "arb": "يحسب عدد الأرقام والحروف الصغيرة والحروف الكبيرة في سلسلة مكونة من 8 أحرف.\n\nتأخذ هذه الدالة سلسلة واحدة مكونة من 8 أحرف بالضبط كمدخل.\nثم تقوم بعد وإرجاع عدد الأرقام والحروف الصغيرة والحروف الكبيرة داخل السلسلة.\n\nالمدخل: سلسلة مكونة من 8 أحرف.\nالمخرج: مصفوفة من ثلاثة أعداد صحيحة، حيث:\n- العدد الصحيح الأول هو عدد الأرقام في السلسلة.\n- العدد الصحيح الثاني هو عدد الحروف الصغيرة في السلسلة.\n- العدد الصحيح الثالث هو عدد الحروف الكبيرة في السلسلة.\n\nأمثلة:\n- بالنسبة للسلسلة \"yLOI2022\"، يجب أن يكون المخرج [4, 1, 3].\n- بالنسبة للسلسلة \"IAKIOIOI\"، يجب أن يكون المخرج [0, 0, 8].\n- بالنسبة للسلسلة \"1n2s0e1s\"، يجب أن يكون المخرج [4, 4, 0].",
      "sw": "Hesabu idadi ya tarakimu, herufi ndogo, na herufi kubwa katika kamba ya herufi 8.\n\n  Kazi hii inachukua kamba moja ya herufi 8 kamili kama ingizo.\n  Kisha inahesabu na kurudisha idadi ya tarakimu, herufi ndogo, na herufi kubwa ndani ya kamba.\n\n  Ingizo: Kamba ya herufi 8.\n  Tokeo: Mfululizo wa nambari tatu, ambapo:\n  - Nambari ya kwanza ni hesabu ya tarakimu katika kamba.\n  - Nambari ya pili ni hesabu ya herufi ndogo katika kamba.\n  - Nambari ya tatu ni hesabu ya herufi kubwa katika kamba.\n\n  Mifano:\n  - Kwa kamba \"yLOI2022\", matokeo yanapaswa kuwa [4, 1, 3].\n  - Kwa kamba \"IAKIOIOI\", matokeo yanapaswa kuwa [0, 0, 8].\n  - Kwa kamba \"1n2s0e1s\", matokeo yanapaswa kuwa [4, 4, 0].",
      "tr": "8 karakterlik bir dizgideki rakamların, küçük harflerin ve büyük harflerin sayısını sayar.\n\n  Bu fonksiyon, girdi olarak tam olarak 8 karakter uzunluğunda bir dize alır.\n  Daha sonra dizideki rakamların, küçük harflerin ve büyük harflerin sayısını sayar ve geri döndürür.\n\n  Girdi: 8 karakterlik bir dize.\n  Çıktı: Üç tam sayıdan oluşan bir dizi, burada:\n  - İlk tam sayı dizideki rakamların sayısıdır.\n  - İkinci tam sayı dizideki küçük harflerin sayısıdır.\n  - Üçüncü tam sayı dizideki büyük harflerin sayısıdır.\n\n  Örnekler:\n  - \"yLOI2022\" dizisi için çıktı [4, 1, 3] olmalıdır.\n  - \"IAKIOIOI\" dizisi için çıktı [0, 0, 8] olmalıdır.\n  - \"1n2s0e1s\" dizisi için çıktı [4, 4, 0] olmalıdır.",
      "vi": "Đếm số chữ số, chữ cái viết thường và chữ cái viết hoa trong một chuỗi 8 ký tự.\n\nHàm này nhận một chuỗi duy nhất gồm chính xác 8 ký tự làm đầu vào. Sau đó, nó đếm và trả về số lượng chữ số, chữ cái viết thường và chữ cái viết hoa trong chuỗi.\n\nĐầu vào: Một chuỗi gồm 8 ký tự. Đầu ra: Một mảng gồm ba số nguyên, trong đó: - Số nguyên đầu tiên là số lượng chữ số trong chuỗi. - Số nguyên thứ hai là số lượng chữ cái viết thường trong chuỗi. - Số nguyên thứ ba là số lượng chữ cái viết hoa trong chuỗi.\n\nVí dụ: - Đối với chuỗi \"yLOI2022\", đầu ra sẽ là [4, 1, 3]. - Đối với chuỗi \"IAKIOIOI\", đầu ra sẽ là [0, 0, 8]. - Đối với chuỗi \"1n2s0e1s\", đầu ra sẽ là [4, 4, 0]."
    },
    "docstring_bertscore": {
      "es": "0.9961074404228593",
      "arb": "0.9718232872982959",
      "sw": "0.9578405029949639",
      "tr": "0.9771523417910809",
      "vi": "0.9793793856232441"
    }
  }
]