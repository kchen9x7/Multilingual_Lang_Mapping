[
  {
    "task_id": "Common Lisp/1",
    "prompt": {
      "es": "(defun has-close-elements (numbers threshold)\n;;Verificar si en la lista dada de números, hay dos números más cercanos entre sí que\n;;el umbral dado.\n;;>>> has_close_elements([1.0, 2.0, 3.0], 0.5)\n;;nil\n;;>>> has_close_elements([1.0, 2.8, 3.0, 4.0, 5.0, 2.0], 0.3)\n;;t",
      "arb": "(defun has-close-elements (numbers threshold)\n;;تحقق مما إذا كان في قائمة الأرقام المعطاة، هل يوجد أي رقمين أقرب إلى بعضهما البعض من العتبة المعطاة.\n;;>>> has_close_elements([1.0, 2.0, 3.0], 0.5)\n;;nil\n;;>>> has_close_elements([1.0, 2.8, 3.0, 4.0, 5.0, 2.0], 0.3)\n;;t",
      "sw": "(defun has-close-elements (numbers threshold)\n;;Angalia kama katika orodha ya nambari zilizotolewa, kuna nambari mbili zozote zilizo karibu zaidi kuliko\n;;kizingiti kilichotolewa.\n;;>>> has_close_elements([1.0, 2.0, 3.0], 0.5)\n;;nil\n;;>>> has_close_elements([1.0, 2.8, 3.0, 4.0, 5.0, 2.0], 0.3)\n;;t",
      "tr": "(defun has-close-elements (numbers threshold)\n;; Verilen sayı listesindeki herhangi iki sayının birbirine\n;; verilen eşikten daha yakın olup olmadığını kontrol et.\n;;>>> has_close_elements([1.0, 2.0, 3.0], 0.5)\n;;nil\n;;>>> has_close_elements([1.0, 2.8, 3.0, 4.0, 5.0, 2.0], 0.3)\n;;t",
      "vi": "(defun has-close-elements (numbers threshold)\n;;Kiểm tra xem trong danh sách số đã cho, có bất kỳ hai số nào gần nhau hơn\n;;ngưỡng đã cho hay không.\n;;>>> has_close_elements([1.0, 2.0, 3.0], 0.5)\n;;nil\n;;>>> has_close_elements([1.0, 2.8, 3.0, 4.0, 5.0, 2.0], 0.3)\n;;t"
    },
    "prompt_bertscore": {
      "es": "0.977755780888665",
      "arb": "0.9763784778265691",
      "sw": "0.9682209267078472",
      "tr": "0.9725031990925783",
      "vi": "0.9655263069587279"
    },
    "canonical_solution": "(loop for i from 0 below (length numbers)\ndo (loop for j from 0 below (length numbers)\ndo (when (and (/= i j)\n(< (abs (- (nth i numbers) (nth j numbers))) threshold))\n(return-from has-close-elements t))))\nnil)",
    "instruction": {
      "es": "(defun has-close-elements (numbers threshold)\n(loop for i from 0 below (length numbers)\ndo (loop for j from 0 below (length numbers)\ndo (when (and (/= i j)\n(< (abs (- (nth i numbers) (nth j numbers))) threshold))\n(return-from has-close-elements t))))\nnil)\n\nProporcione una descripción concisa en lenguaje natural (docstring) del código Common Lisp en español utilizando un máximo de 500 caracteres.",
      "arb": "(defun has-close-elements (numbers threshold)\n(loop for i from 0 below (length numbers)\ndo (loop for j from 0 below (length numbers)\ndo (when (and (/= i j)\n(< (abs (- (nth i numbers) (nth j numbers))) threshold))\n(return-from has-close-elements t))))\nnil)\n\nيرجى تقديم وصف موجز بلغة طبيعية (docstring) لشفرة Common Lisp باللغة العربية الفصحى، بحيث لا يتجاوز 500 حرف.",
      "sw": "(defun has-close-elements (numbers threshold)\n(loop for i from 0 below (length numbers)\ndo (loop for j from 0 below (length numbers)\ndo (when (and (/= i j)\n(< (abs (- (nth i numbers) (nth j numbers))) threshold))\n(return-from has-close-elements t))))\nnil)\n\nToa maelezo mafupi ya lugha ya asili (docstring) ya msimbo wa Common Lisp kwa Kiswahili kwa kutumia herufi zisizozidi 500.",
      "tr": "(defun has-close-elements (numbers threshold)\n(loop for i from 0 below (length numbers)\ndo (loop for j from 0 below (length numbers)\ndo (when (and (/= i j)\n(< (abs (- (nth i numbers) (nth j numbers))) threshold))\n(return-from has-close-elements t))))\nnil)\n\nAşağıdaki Common Lisp kodunun işlevini açıklayan kısa bir doğal dil açıklaması (docstring) sağlayın. Açıklama, en fazla 500 karakter kullanarak Türkçe olmalıdır.",
      "vi": "(defun has-close-elements (numbers threshold)\n(loop for i from 0 below (length numbers)\ndo (loop for j from 0 below (length numbers)\ndo (when (and (/= i j)\n(< (abs (- (nth i numbers) (nth j numbers))) threshold))\n(return-from has-close-elements t))))\nnil)\n\nCung cấp mô tả ngắn gọn bằng ngôn ngữ tự nhiên (docstring) cho mã Common Lisp bằng tiếng Việt, sử dụng tối đa 500 ký tự."
    },
    "instruction_bertscore": {
      "es": "0.9711352316583911",
      "arb": "0.9060988777784239",
      "sw": "0.9127128722061235",
      "tr": "0.8635782707406664",
      "vi": "0.9119165630085547"
    },
    "level": "",
    "test": "(defun check-has-close-elements ()\n(assert (equal (has-close-elements '(1.0 2.0 3.9 4.0 5.0 2.2) 0.3) t))\n(assert (equal (has-close-elements '(1.0 2.0 3.9 4.0 5.0 2.2) 0.05) nil))\n(assert (equal (has-close-elements '(1.0 2.0 5.9 4.0 5.0) 0.95) t))\n(assert (equal (has-close-elements '(1.0 2.0 5.9 4.0 5.0) 0.8) nil))\n(assert (equal (has-close-elements '(1.0 2.0 3.0 4.0 5.0 2.0) 0.1) t))\n(assert (equal (has-close-elements '(1.1 2.2 3.1 4.1 5.1) 1.0) t))\n(assert (equal (has-close-elements '(1.1 2.2 3.1 4.1 5.1) 0.5) nil)))\n\n(check-has-close-elements)",
    "entry_point": "has-close-elements",
    "signature": "(defun has-close-elements (numbers threshold)",
    "docstring": {
      "es": "Verifica si en una lista dada de números, hay dos números más cercanos entre sí que el umbral dado.\n>>> has_close_elements([1.0, 2.0, 3.0], 0.5)\n'nil\n>>> has_close_elements([1.0, 2.8, 3.0, 4.0, 5.0, 2.0], 0.3)\nt'",
      "arb": "تحقق مما إذا كان في قائمة الأرقام المعطاة، يوجد أي رقمين أقرب إلى بعضهما من العتبة المحددة.  \n>>> has_close_elements([1.0, 2.0, 3.0], 0.5)  \n'nil  \n>>> has_close_elements([1.0, 2.8, 3.0, 4.0, 5.0, 2.0], 0.3)  \nt  ",
      "sw": "Angalia ikiwa katika orodha iliyotolewa ya nambari, kuna nambari mbili zozote zilizo karibu zaidi kuliko kizingiti kilichotolewa.\n>>> has_close_elements([1.0, 2.0, 3.0], 0.5)\n'nil\n>>> has_close_elements([1.0, 2.8, 3.0, 4.0, 5.0, 2.0], 0.3)\nt'",
      "tr": "Verilen sayı listesindeki herhangi iki sayının, verilen eşikten daha yakın olup olmadığını kontrol edin.\n>>> has_close_elements([1.0, 2.0, 3.0], 0.5)\n'nil\n>>> has_close_elements([1.0, 2.8, 3.0, 4.0, 5.0, 2.0], 0.3)\nt'",
      "vi": "Kiểm tra xem trong danh sách số đã cho, có bất kỳ hai số nào gần nhau hơn ngưỡng đã cho không.\n>>> has_close_elements([1.0, 2.0, 3.0], 0.5)\n'nil\n>>> has_close_elements([1.0, 2.8, 3.0, 4.0, 5.0, 2.0], 0.3)\nt'"
    },
    "docstring_bertscore": {
      "es": "0.9724233496794024",
      "arb": "0.9635858867663981",
      "sw": "0.9657481770943439",
      "tr": "0.9586850793751243",
      "vi": "0.972404281162823"
    }
  },
  {
    "task_id": "Common Lisp/2",
    "prompt": {
      "es": "(defun bin-search (obj vec)\n;; Búsqueda binaria de 'obj' en el vector ordenado 'vec'.\n;; Devuelve 't' si se encuentra 'obj', 'nil' en caso contrario.\n;; Ejemplo:\n;; >>> bin-search 3 '#(1 2 3 4 5)\n;; t",
      "arb": "(defun bin-search (obj vec)\n;; البحث الثنائي عن 'obj' في المتجه المرتب 'vec'.\n;; يعيد 't' إذا تم العثور على 'obj'، 'nil' خلاف ذلك.\n;; مثال:\n;; >>> bin-search 3 '#(1 2 3 4 5)\n;; t",
      "sw": "(defun bin-search (obj vec)\n;; Utafutaji wa binary kwa 'obj' katika vector iliyopangwa 'vec'.\n;; Inarudisha 't' ikiwa 'obj' imepatikana, 'nil' vinginevyo.\n;; Mfano:\n;; >>> bin-search 3 '#(1 2 3 4 5)\n;; t",
      "tr": "(defun bin-search (obj vec)\n;; Sıralı vektör 'vec' içinde 'obj' için ikili arama.\n;; 'obj' bulunursa 't', aksi takdirde 'nil' döndürür.\n;; Örnek:\n;; >>> bin-search 3 '#(1 2 3 4 5)\n;; t",
      "vi": "(defun bin-search (obj vec)\n;; Tìm kiếm nhị phân cho 'obj' trong vector đã sắp xếp 'vec'.\n;; Trả về 't' nếu 'obj' được tìm thấy, 'nil' nếu không.\n;; Ví dụ:\n;; >>> bin-search 3 '#(1 2 3 4 5)\n;; t"
    },
    "prompt_bertscore": {
      "es": "0.9954577204464942",
      "arb": "0.9954577204464942",
      "sw": "0.9954577204464942",
      "tr": "0.9636035648703102",
      "vi": "0.9839631789263862"
    },
    "canonical_solution": "(let ((low 0)\n(high (1- (length vec))))\n(loop while (<= low high)\nfor mid = (floor (+ low high) 2)\nfor mid-val = (aref vec mid)\ndo (cond ((= obj mid-val) (return-from bin-search t))\n((< obj mid-val) (setf high (1- mid)))\n((> obj mid-val) (setf low (1+ mid)))))\nnil))",
    "instruction": {
      "es": "(defun bin-search (obj vec)\n(let ((low 0)\n(high (1- (length vec))))\n(loop while (<= low high)\nfor mid = (floor (+ low high) 2)\nfor mid-val = (aref vec mid)\ndo (cond ((= obj mid-val) (return-from bin-search t))\n((< obj mid-val) (setf high (1- mid)))\n((> obj mid-val) (setf low (1+ mid)))))\nnil))\n\nProporcione una descripción concisa en lenguaje natural (docstring) del código Common Lisp en español utilizando un máximo de 500 caracteres.",
      "arb": "(defun bin-search (obj vec)\n(let ((low 0)\n(high (1- (length vec))))\n(loop while (<= low high)\nfor mid = (floor (+ low high) 2)\nfor mid-val = (aref vec mid)\ndo (cond ((= obj mid-val) (return-from bin-search t))\n((< obj mid-val) (setf high (1- mid)))\n((> obj mid-val) (setf low (1+ mid)))))\nnil))\n\nيرجى تقديم وصف موجز بلغة طبيعية (docstring) لشيفرة Common Lisp باللغة العربية الفصحى، بحيث لا يتجاوز 500 حرف.",
      "sw": "(defun bin-search (obj vec)\n(let ((low 0)\n(high (1- (length vec))))\n(loop while (<= low high)\nfor mid = (floor (+ low high) 2)\nfor mid-val = (aref vec mid)\ndo (cond ((= obj mid-val) (return-from bin-search t))\n((< obj mid-val) (setf high (1- mid)))\n((> obj mid-val) (setf low (1+ mid)))))\nnil))\n\nToa maelezo mafupi ya lugha ya asili (docstring) ya msimbo wa Common Lisp kwa Kiswahili kwa kutumia herufi zisizozidi 500.",
      "tr": "(defun bin-search (obj vec)\n(let ((low 0)\n(high (1- (length vec))))\n(loop while (<= low high)\nfor mid = (floor (+ low high) 2)\nfor mid-val = (aref vec mid)\ndo (cond ((= obj mid-val) (return-from bin-search t))\n((< obj mid-val) (setf high (1- mid)))\n((> obj mid-val) (setf low (1+ mid)))))\nnil))\n\nAşağıdaki Common Lisp kodunun işlevini açıklayan kısa bir doğal dil açıklaması (docstring) sağlayın. Açıklama Türkçe olmalı ve en fazla 500 karakter kullanılmalıdır.",
      "vi": "(defun bin-search (obj vec)\n(let ((low 0)\n(high (1- (length vec))))\n(loop while (<= low high)\nfor mid = (floor (+ low high) 2)\nfor mid-val = (aref vec mid)\ndo (cond ((= obj mid-val) (return-from bin-search t))\n((< obj mid-val) (setf high (1- mid)))\n((> obj mid-val) (setf low (1+ mid)))))\nnil))\n\nCung cấp mô tả ngắn gọn bằng ngôn ngữ tự nhiên (docstring) cho mã Common Lisp bằng tiếng Việt, sử dụng tối đa 500 ký tự."
    },
    "instruction_bertscore": {
      "es": "0.9711352316583911",
      "arb": "0.8841158576181497",
      "sw": "0.9127128722061235",
      "tr": "0.8529761755225482",
      "vi": "0.940954537042426"
    },
    "level": "",
    "test": "(defun check-bin-search ()\n;; Test the 'bin-search' function with various cases.\n(assert (equal (bin-search 3 '#(1 2 3 4 5)) t))\n(assert (equal (bin-search 6 '#(1 2 3 4 5)) nil))\n(assert (equal (bin-search 1 '#(1)) t))\n(assert (equal (bin-search 2 '#(1)) nil))\n(assert (equal (bin-search 0 '#()) nil))\n(assert (equal (bin-search 5 '#(2 4 6 8 10)) nil))\n(assert (equal (bin-search 4 '#(2 4 6 8 10)) t)))\n\n(check-bin-search)",
    "entry_point": "bin-search",
    "signature": "(defun bin-search (obj vec)",
    "docstring": {
      "es": "Búsqueda binaria de 'obj' en el vector ordenado 'vec'.  \nDevuelve 't' si se encuentra 'obj', 'nil' de lo contrario.  \nEjemplo:  \n>>> bin-search 3 '#(1 2 3 4 5)  \nt",
      "arb": "البحث الثنائي عن 'obj' في المتجه المرتب 'vec'.  \nيعيد 't' إذا تم العثور على 'obj'، 'nil' خلاف ذلك.  \nمثال:  \n>>> bin-search 3 '#(1 2 3 4 5)  \nt",
      "sw": "Utafutaji wa binary kwa 'obj' katika vekta iliyopangwa 'vec'. \nInarudisha 't' ikiwa 'obj' imepatikana, 'nil' vinginevyo. \nMfano:\n>>> bin-search 3 '#(1 2 3 4 5)\nt",
      "tr": "Sıralı vektör 'vec' içinde 'obj' için ikili arama.\n'obj' bulunursa 't', aksi takdirde 'nil' döndürür.\nÖrnek:\n>>> bin-search 3 '#(1 2 3 4 5)\nt",
      "vi": "Tìm kiếm nhị phân cho 'obj' trong vector đã sắp xếp 'vec'.  \nTrả về 't' nếu 'obj' được tìm thấy, 'nil' nếu không.  \nVí dụ:  \n>>> bin-search 3 '#(1 2 3 4 5)  \nt"
    },
    "docstring_bertscore": {
      "es": "0.9936078757079163",
      "arb": "0.9936078757079163",
      "sw": "0.9936078757079163",
      "tr": "0.9141700246813955",
      "vi": "0.970058456362801"
    }
  },
  {
    "task_id": "Common Lisp/3",
    "prompt": {
      "es": "(defun parse-date (date-str)\n\"Analiza una cadena de fecha en el formato 'DD MMM YYYY' y devuelve una lista (día mes año).\"\n;; Ejemplo:\n;; >>> parse-date \"16 Aug 1980\"\n;; 16 8 1980",
      "arb": "(defun parse-date (date-str)\n\"تحليل سلسلة تاريخ بالتنسيق 'DD MMM YYYY' وإرجاع قائمة (اليوم الشهر السنة).\"\n;; مثال:\n;; >>> parse-date \"16 Aug 1980\"\n;; 16 8 1980",
      "sw": "(defun parse-date (date-str)\n\"Pambanua kamba ya tarehe katika muundo 'DD MMM YYYY' na rudisha orodha (siku mwezi mwaka).\"\n;; Mfano:\n;; >>> parse-date \"16 Aug 1980\"\n;; 16 8 1980",
      "tr": "(defun parse-date (date-str)\n\"Tarihi 'DD MMM YYYY' formatında bir tarih dizesi olarak ayrıştır ve bir liste (gün ay yıl) döndür.\"\n;; Örnek:\n;; >>> parse-date \"16 Aug 1980\"\n;; 16 8 1980",
      "vi": "(defun parse-date (date-str)\n\"Phân tích một chuỗi ngày tháng theo định dạng 'DD MMM YYYY' và trả về một danh sách (ngày tháng năm).\"\n;; Ví dụ:\n;; >>> parse-date \"16 Aug 1980\"\n;; 16 8 1980"
    },
    "prompt_bertscore": {
      "es": "0.9794044130512545",
      "arb": "0.999999801369619",
      "sw": "0.999999801369619",
      "tr": "0.9748251882468763",
      "vi": "0.999999801369619"
    },
    "canonical_solution": "(let ((toks (tokens date-str #'constituent 0)))\n(list (parse-integer (first toks):junk-allowed t)\n(parse-month (second toks))\n(parse-integer (third toks)))))\n\n(defun tokens (str test start)\n(let ((p1 (position-if test str :start start)))\n(if p1\n(let ((p2 (position-if #'(lambda (c)\n(not (funcall test c)))\nstr :start p1)))\n(cons (subseq str p1 p2)\n(if p2\n(tokens str test p2)\nnil)))\nnil)))\n(defun constituent (c)\n(and (graphic-char-p c)\n(not (char= c #\\ ))))\n\n(defconstant month-names\n'(\"jan\" \"feb\" \"mar\" \"apr\" \"may\" \"jun\"\n\"jul\" \"aug\" \"sep\" \"oct\" \"nov\" \"dec\"))\n\n(defun parse-month (str)\n\"Parse the month string and return the month number.\"\n(let ((p (position (string-downcase str) month-names :test #'string-equal)))\n(if p\n(1+ p)\n(error \"Invalid month string: ~A\" str))))",
    "instruction": {
      "es": "(defun parse-date (date-str)\n(let ((toks (tokens date-str #'constituent 0)))\n(list (parse-integer (first toks):junk-allowed t)\n(parse-month (second toks))\n(parse-integer (third toks)))))\n\n(defun tokens (str test start)\n(let ((p1 (position-if test str :start start)))\n(if p1\n(let ((p2 (position-if #'(lambda (c)\n(not (funcall test c)))\nstr :start p1)))\n(cons (subseq str p1 p2)\n(if p2\n(tokens str test p2)\nnil)))\nnil)))\n(defun constituent (c)\n(and (graphic-char-p c)\n(not (char= c #\\ ))))\n\n(defconstant month-names\n'(\"jan\" \"feb\" \"mar\" \"apr\" \"may\" \"jun\"\n\"jul\" \"aug\" \"sep\" \"oct\" \"nov\" \"dec\"))\n\n(defun parse-month (str)\n\"Parse the month string and return the month number.\"\n(let ((p (position (string-downcase str) month-names :test #'string-equal)))\n(if p\n(1+ p)\n(error \"Invalid month string: ~A\" str))))\n\nProporcione una descripción concisa en lenguaje natural (docstring) del código Common Lisp en español utilizando como máximo 500 caracteres.",
      "arb": "(defun parse-date (date-str)\n(let ((toks (tokens date-str #'constituent 0)))\n(list (parse-integer (first toks):junk-allowed t)\n(parse-month (second toks))\n(parse-integer (third toks)))))\n\n(defun tokens (str test start)\n(let ((p1 (position-if test str :start start)))\n(if p1\n(let ((p2 (position-if #'(lambda (c)\n(not (funcall test c)))\nstr :start p1)))\n(cons (subseq str p1 p2)\n(if p2\n(tokens str test p2)\nnil)))\nnil)))\n(defun constituent (c)\n(and (graphic-char-p c)\n(not (char= c #\\ ))))\n\n(defconstant month-names\n'(\"jan\" \"feb\" \"mar\" \"apr\" \"may\" \"jun\"\n\"jul\" \"aug\" \"sep\" \"oct\" \"nov\" \"dec\"))\n\n(defun parse-month (str)\n\"Parse the month string and return the month number.\"\n(let ((p (position (string-downcase str) month-names :test #'string-equal)))\n(if p\n(1+ p)\n(error \"Invalid month string: ~A\" str))))\n\nيرجى تقديم وصف موجز بلغة طبيعية (docstring) لشفرة Common Lisp باللغة العربية الفصحى، بحيث لا يتجاوز 500 حرف.",
      "sw": "(defun parse-date (date-str)\n(let ((toks (tokens date-str #'constituent 0)))\n(list (parse-integer (first toks):junk-allowed t)\n(parse-month (second toks))\n(parse-integer (third toks)))))\n\n(defun tokens (str test start)\n(let ((p1 (position-if test str :start start)))\n(if p1\n(let ((p2 (position-if #'(lambda (c)\n(not (funcall test c)))\nstr :start p1)))\n(cons (subseq str p1 p2)\n(if p2\n(tokens str test p2)\nnil)))\nnil)))\n(defun constituent (c)\n(and (graphic-char-p c)\n(not (char= c #\\ ))))\n\n(defconstant month-names\n'(\"jan\" \"feb\" \"mar\" \"apr\" \"may\" \"jun\"\n\"jul\" \"aug\" \"sep\" \"oct\" \"nov\" \"dec\"))\n\n(defun parse-month (str)\n\"Parse the month string and return the month number.\"\n(let ((p (position (string-downcase str) month-names :test #'string-equal)))\n(if p\n(1+ p)\n(error \"Invalid month string: ~A\" str))))\n\nToa maelezo mafupi ya lugha ya asili (docstring) ya msimbo wa Common Lisp kwa Kiswahili kwa kutumia herufi zisizozidi 500.",
      "tr": "(defun parse-date (date-str)\n(let ((toks (tokens date-str #'constituent 0)))\n(list (parse-integer (first toks):junk-allowed t)\n(parse-month (second toks))\n(parse-integer (third toks)))))\n\n(defun tokens (str test start)\n(let ((p1 (position-if test str :start start)))\n(if p1\n(let ((p2 (position-if #'(lambda (c)\n(not (funcall test c)))\nstr :start p1)))\n(cons (subseq str p1 p2)\n(if p2\n(tokens str test p2)\nnil)))\nnil)))\n(defun constituent (c)\n(and (graphic-char-p c)\n(not (char= c #\\ ))))\n\n(defconstant month-names\n'(\"jan\" \"feb\" \"mar\" \"apr\" \"may\" \"jun\"\n\"jul\" \"aug\" \"sep\" \"oct\" \"nov\" \"dec\"))\n\n(defun parse-month (str)\n\"Parse the month string and return the month number.\"\n(let ((p (position (string-downcase str) month-names :test #'string-equal)))\n(if p\n(1+ p)\n(error \"Invalid month string: ~A\" str))))\n\nAşağıdaki Common Lisp kodunun doğal dilde kısa bir açıklamasını (docstring) Türkçe olarak en fazla 500 karakter kullanarak sağlayın.",
      "vi": "(defun parse-date (date-str)\n(let ((toks (tokens date-str #'constituent 0)))\n(list (parse-integer (first toks):junk-allowed t)\n(parse-month (second toks))\n(parse-integer (third toks)))))\n\n(defun tokens (str test start)\n(let ((p1 (position-if test str :start start)))\n(if p1\n(let ((p2 (position-if #'(lambda (c)\n(not (funcall test c)))\nstr :start p1)))\n(cons (subseq str p1 p2)\n(if p2\n(tokens str test p2)\nnil)))\nnil)))\n(defun constituent (c)\n(and (graphic-char-p c)\n(not (char= c #\\ ))))\n\n(defconstant month-names\n'(\"jan\" \"feb\" \"mar\" \"apr\" \"may\" \"jun\"\n\"jul\" \"aug\" \"sep\" \"oct\" \"nov\" \"dec\"))\n\n(defun parse-month (str)\n\"Parse the month string and return the month number.\"\n(let ((p (position (string-downcase str) month-names :test #'string-equal)))\n(if p\n(1+ p)\n(error \"Invalid month string: ~A\" str))))\n\nCung cấp mô tả ngắn gọn bằng ngôn ngữ tự nhiên (docstring) cho mã Common Lisp bằng tiếng Việt, sử dụng tối đa 500 ký tự."
    },
    "instruction_bertscore": {
      "es": "0.9711352316583911",
      "arb": "0.8841158576181497",
      "sw": "0.9454739741021129",
      "tr": "0.8518106124466355",
      "vi": "0.9119165630085547"
    },
    "level": "",
    "test": "(defun check-parse-date ()\n;; Test the 'parse-date' function with various date strings.\n(assert (equal (parse-date \"16 Aug 1980\") '(16 8 1980)))\n(assert (equal (parse-date \"1 Jan 2023\") '(1 1 2023)))\n(assert (equal (parse-date \"25 Dec 1999\") '(25 12 1999)))\n(assert (equal (parse-date \"31 Oct 2025\") '(31 10 2025)))\n(assert (equal (parse-date \"20 Feb 2010\") '(20 2 2010))))\n\n(check-parse-date)",
    "entry_point": "parse-date",
    "signature": "(defun parse-date (date-str)",
    "docstring": {
      "es": "\"Analiza una cadena de fecha en el formato 'DD MMM YYYY' y devuelve una lista (día mes año).\"\nEjemplo:\n>>> parse-date \"16 Aug 1980\"\n16 8 1980",
      "arb": "\"تحليل سلسلة تاريخ بالتنسيق 'DD MMM YYYY' وإرجاع قائمة (يوم شهر سنة).\"\nمثال:\n>>> parse-date \"16 Aug 1980\"\n16 8 1980",
      "sw": "\"Soma kamba ya tarehe katika muundo 'DD MMM YYYY' na rudisha orodha (siku mwezi mwaka).\"\n\nMfano:\n>>> parse-date \"16 Aug 1980\"\n16 8 1980",
      "tr": "\"Tarihi 'GG AAA YYYY' formatında bir dize olarak ayrıştır ve bir liste (gün ay yıl) döndür.\"\nÖrnek:\n>>> parse-date \"16 Aug 1980\"\n16 8 1980",
      "vi": "\"Phân tích một chuỗi ngày tháng theo định dạng 'DD MMM YYYY' và trả về một danh sách (ngày tháng năm).\"\nVí dụ:\n>>> parse-date \"16 Aug 1980\"\n16 8 1980"
    },
    "docstring_bertscore": {
      "es": "0.9749203321993919",
      "arb": "1",
      "sw": "0.9512521318864178",
      "tr": "0.9675523368452837",
      "vi": "1"
    }
  },
  {
    "task_id": "Common Lisp/4",
    "prompt": {
      "es": "(defun fourth-element (lst)\n;; usar car y cdr para devolver el cuarto elemento en la lista\n;; Ejemplo:\n;; >>> fourth-element '(a b c d e f)\n;; 'd",
      "arb": "(defun fourth-element (lst)\n;; استخدم car و cdr لإرجاع العنصر الرابع في القائمة\n;; مثال:\n;; >>> fourth-element '(a b c d e f)\n;; 'd",
      "sw": "(defun fourth-element (lst)\n;; tumia car na cdr kurudisha kipengele cha nne katika orodha\n;; Mfano:\n;; >>> fourth-element '(a b c d e f)\n;; 'd",
      "tr": "(defun fourth-element (lst)\n;; car ve cdr kullanarak listedeki dördüncü öğeyi döndür\n;; Örnek:\n;; >>> fourth-element '(a b c d e f)\n;; 'd",
      "vi": "(defun fourth-element (lst)\n;; sử dụng car và cdr để trả về phần tử thứ tư trong danh sách\n;; Ví dụ:\n;; >>> fourth-element '(a b c d e f)\n;; 'd"
    },
    "prompt_bertscore": {
      "es": "0.9862631201083892",
      "arb": "0.9845106042565184",
      "sw": "0.9862631201083892",
      "tr": "0.9698395656829005",
      "vi": "0.9862631201083892"
    },
    "canonical_solution": "(car (cdr (cdr (cdr lst)))))",
    "instruction": {
      "es": "(defun fourth-element (lst)\n(car (cdr (cdr (cdr lst)))))\n\nProporcione una descripción concisa en lenguaje natural (docstring) del código Common Lisp en español utilizando un máximo de 500 caracteres.",
      "arb": "(defun fourth-element (lst)\n(car (cdr (cdr (cdr lst)))))\n\nيرجى تقديم وصف موجز بلغة طبيعية (docstring) لكود Common Lisp باللغة العربية الفصحى، بحيث لا يتجاوز 500 حرف.",
      "sw": "(defun fourth-element (lst)\n(car (cdr (cdr (cdr lst)))))\n\nToa maelezo mafupi ya lugha ya asili (docstring) ya msimbo wa Common Lisp kwa Kiswahili kwa kutumia herufi zisizozidi 500.",
      "tr": "(defun fourth-element (lst)\n(car (cdr (cdr (cdr lst)))))\n\nAşağıdaki Common Lisp kodunun doğal dilde kısa bir açıklamasını (docstring) en fazla 500 karakter kullanarak Türkçe olarak sağlayın.",
      "vi": "(defun fourth-element (lst)\n(car (cdr (cdr (cdr lst)))))\n\nCung cấp mô tả ngắn gọn bằng ngôn ngữ tự nhiên (docstring) cho mã Common Lisp bằng tiếng Việt, sử dụng tối đa 500 ký tự."
    },
    "instruction_bertscore": {
      "es": "0.9711352316583911",
      "arb": "0.9060988777784239",
      "sw": "0.9454739741021129",
      "tr": "0.85336231298328",
      "vi": "0.9227200694330423"
    },
    "level": "",
    "test": "(defun check-fourth-element ()\n(assert (equal (fourth-element '(a b c d e f)) 'd))\n(assert (equal (fourth-element '(1 2 3 4 5 6)) 4))\n(assert (equal (fourth-element '(\"one\" \"two\" \"three\" \"four\" \"five\")) \"four\")))\n\n(check-fourth-element)",
    "entry_point": "fourth-element",
    "signature": "(defun fourth-element (lst)",
    "docstring": {
      "es": "usa car y cdr para devolver el cuarto elemento en la lista  \nEjemplo:  \n>>> fourth-element '(a b c d e f)  \n'd",
      "arb": "استخدم car و cdr لإرجاع العنصر الرابع في القائمة  \nمثال:  \n>>> fourth-element '(a b c d e f)  \n'd",
      "sw": "tumia car na cdr kurudisha kipengele cha nne kwenye orodha  \nMfano:  \n>>> fourth-element '(a b c d e f)  \n'd",
      "tr": "dördüncü öğeyi listede döndürmek için car ve cdr kullanın\nÖrnek:\n>>> fourth-element '(a b c d e f)\n'd",
      "vi": "sử dụng car và cdr để trả về phần tử thứ tư trong danh sách\nVí dụ:\n>>> fourth-element '(a b c d e f)\n'd"
    },
    "docstring_bertscore": {
      "es": "0.9929210118502976",
      "arb": "0.9919358051603646",
      "sw": "0.9929210118502976",
      "tr": "0.9929210118502976",
      "vi": "0.9929210118502976"
    }
  },
  {
    "task_id": "Common Lisp/5",
    "prompt": {
      "es": "(defun count-a-in-list (lst)\n;; Calcular el número de veces que 'a' aparece en la lista.\n;; Ejemplo:\n;; >>> count-a-in-list '(a b c d a e f a)\n;; 3",
      "arb": "(defun count-a-in-list (lst)\n;; حساب عدد المرات التي يظهر فيها 'a' في القائمة.\n;; مثال:\n;; >>> count-a-in-list '(a b c d a e f a)\n;; 3",
      "sw": "(defun count-a-in-list (lst)\n;; Hesabu idadi ya mara 'a' inavyoonekana kwenye orodha.\n;; Mfano:\n;; >>> count-a-in-list '(a b c d a e f a)\n;; 3",
      "tr": "(defun count-a-in-list (lst)\n;; Listedeki 'a' harfinin kaç kez göründüğünü hesapla.\n;; Örnek:\n;; >>> count-a-in-list '(a b c d a e f a)\n;; 3",
      "vi": "(defun count-a-in-list (lst)\n;; Tính số lần 'a' xuất hiện trong danh sách.\n;; Ví dụ:\n;; >>> count-a-in-list '(a b c d a e f a)\n;; 3"
    },
    "prompt_bertscore": {
      "es": "0.9692977020034373",
      "arb": "0.9692977020034373",
      "sw": "0.9586517094711104",
      "tr": "0.952278256434844",
      "vi": "0.9692977020034373"
    },
    "canonical_solution": "(loop for item in lst\ncounting (eql item 'a)))",
    "instruction": {
      "es": "(defun count-a-in-list (lst)\n(loop for item in lst\ncounting (eql item 'a)))\n\nProporcione una descripción concisa en lenguaje natural (docstring) del código Common Lisp en español utilizando un máximo de 500 caracteres.",
      "arb": "(defun count-a-in-list (lst)\n(loop for item in lst\ncounting (eql item 'a)))\n\nيرجى تقديم وصف موجز بلغة طبيعية (docstring) لشفرة Common Lisp باللغة العربية الفصحى باستخدام 500 حرف كحد أقصى.",
      "sw": "(defun count-a-in-list (lst)\n(loop for item in lst\ncounting (eql item 'a)))\n\nToa maelezo mafupi ya lugha ya asili (docstring) ya msimbo wa Common Lisp kwa Kiswahili kwa kutumia herufi zisizozidi 500.",
      "tr": "(defun count-a-in-list (lst)\n(loop for item in lst\ncounting (eql item 'a)))\n\nAşağıdaki Common Lisp kodunun doğal dilde kısa bir açıklamasını (docstring) Türkçe olarak en fazla 500 karakter kullanarak sağlayın.",
      "vi": "(defun count-a-in-list (lst)\n(loop for item in lst\ncounting (eql item 'a)))\n\nCung cấp mô tả ngắn gọn bằng ngôn ngữ tự nhiên (docstring) cho mã Common Lisp bằng tiếng Việt, sử dụng tối đa 500 ký tự."
    },
    "instruction_bertscore": {
      "es": "0.9711352316583911",
      "arb": "0.9023485375541042",
      "sw": "0.9177628510135546",
      "tr": "0.847469346838737",
      "vi": "0.9119165630085547"
    },
    "level": "",
    "test": "(defun check-count-a-in-list ()\n(assert (equal (count-a-in-list '(a b c d a e f a)) 3))\n(assert (equal (count-a-in-list '(1 2 3 4 5)) 0))\n(assert (equal (count-a-in-list '(a a a a)) 4))\n(assert (equal (count-a-in-list '(b c d)) 0)))\n\n(check-count-a-in-list)",
    "entry_point": "count-a-in-list",
    "signature": "(defun count-a-in-list (lst)",
    "docstring": {
      "es": "Calcular el número de veces que 'a' aparece en la lista.  \nEjemplo:  \n>>> count-a-in-list '(a b c d a e f a)  \n3",
      "arb": "احسب عدد المرات التي يظهر فيها 'a' في القائمة.\nمثال:\n>>> count-a-in-list '(a b c d a e f a)\n3",
      "sw": "Hesabu idadi ya mara 'a' inavyoonekana kwenye orodha. Mfano:\n>>> count-a-in-list '(a b c d a e f a)\n3",
      "tr": "Listedeki 'a' harfinin kaç kez göründüğünü hesaplayın.\nÖrnek:\n>>> count-a-in-list '(a b c d a e f a)\n3",
      "vi": "Tính số lần 'a' xuất hiện trong danh sách.  \nVí dụ:  \n>>> count-a-in-list '(a b c d a e f a)  \n3"
    },
    "docstring_bertscore": {
      "es": "0.9596762449764884",
      "arb": "0.9596762449764884",
      "sw": "0.9374385806677275",
      "tr": "0.9294637694995578",
      "vi": "0.9374385806677275"
    }
  },
  {
    "task_id": "Common Lisp/6",
    "prompt": {
      "es": "(defun ordered-union (list1 list2)\n;; Escribe una versión de unión que preserve el orden de los elementos en las listas originales:\n;; Ejemplo:\n;; >>> ordered-union '(1 2 3) '(4 5 6)\n;; 1 2 3 4 5 6",
      "arb": "(defun ordered-union (list1 list2)\n;; اكتب نسخة من union التي تحافظ على ترتيب العناصر في القوائم الأصلية:\n;; مثال:\n;; >>> ordered-union '(1 2 3) '(4 5 6)\n;; 1 2 3 4 5 6",
      "sw": "(defun ordered-union (list1 list2)\n;; Andika toleo la muungano ambalo linahifadhi mpangilio wa vipengele katika orodha za awali:\n;; Mfano:\n;; >>> ordered-union '(1 2 3) '(4 5 6)\n;; 1 2 3 4 5 6",
      "tr": "(defun ordered-union (list1 list2)\n;; Orijinal listelerdeki elemanların sırasını koruyan bir union versiyonu yazın:\n;; Örnek:\n;; >>> ordered-union '(1 2 3) '(4 5 6)\n;; 1 2 3 4 5 6",
      "vi": "(defun ordered-union (list1 list2)\n;; Viết một phiên bản của union mà bảo toàn thứ tự của các phần tử trong các danh sách gốc:\n;; Ví dụ:\n;; >>> ordered-union '(1 2 3) '(4 5 6)\n;; 1 2 3 4 5 6"
    },
    "prompt_bertscore": {
      "es": "0.9952356516804972",
      "arb": "0.9952356516804972",
      "sw": "0.992040284740789",
      "tr": "0.9952356516804972",
      "vi": "0.9952356516804972"
    },
    "canonical_solution": "(let ((result nil))\n(loop for item in list1\nunless (member item list2)\ndo (push item result))\n(loop for item in list2\ndo (push item result))\n(nreverse result)))",
    "instruction": {
      "es": "(defun ordered-union (list1 list2)\n(let ((result nil))\n(loop for item in list1\nunless (member item list2)\ndo (push item result))\n(loop for item in list2\ndo (push item result))\n(nreverse result)))\n\nProporcione una descripción concisa en lenguaje natural (docstring) del código Common Lisp en español utilizando como máximo 500 caracteres.",
      "arb": "(defun ordered-union (list1 list2)\n(let ((result nil))\n(loop for item in list1\nunless (member item list2)\ndo (push item result))\n(loop for item in list2\ndo (push item result))\n(nreverse result)))\n\nيرجى تقديم وصف موجز بلغة طبيعية (docstring) لشفرة Common Lisp باللغة العربية الفصحى، بحيث لا يتجاوز 500 حرف.",
      "sw": "(defun ordered-union (list1 list2)\n(let ((result nil))\n(loop for item in list1\nunless (member item list2)\ndo (push item result))\n(loop for item in list2\ndo (push item result))\n(nreverse result)))\n\nToa maelezo mafupi ya lugha ya asili (docstring) ya msimbo wa Common Lisp kwa Kiswahili kwa kutumia herufi zisizozidi 500.",
      "tr": "(defun ordered-union (list1 list2)\n(let ((result nil))\n(loop for item in list1\nunless (member item list2)\ndo (push item result))\n(loop for item in list2\ndo (push item result))\n(nreverse result)))\n\nAşağıdaki Common Lisp kodunun doğal dilde kısa bir açıklamasını (docstring) Türkçe olarak en fazla 500 karakter kullanarak sağlayın.",
      "vi": "(defun ordered-union (list1 list2)\n(let ((result nil))\n(loop for item in list1\nunless (member item list2)\ndo (push item result))\n(loop for item in list2\ndo (push item result))\n(nreverse result)))\n\nCung cấp mô tả ngắn gọn bằng ngôn ngữ tự nhiên (docstring) cho mã Common Lisp bằng tiếng Việt, sử dụng tối đa 500 ký tự."
    },
    "instruction_bertscore": {
      "es": "0.9711352316583911",
      "arb": "0.9060988777784239",
      "sw": "0.9454739741021129",
      "tr": "0.8482843272921231",
      "vi": "0.9119165630085547"
    },
    "level": "",
    "test": "(defun check-ordered-union ()\n(assert (equal (ordered-union '(1 2 3) '(4 5 6)) '(1 2 3 4 5 6)))\n(assert (equal (ordered-union '(1 2 3) '(3 4 5)) '(1 2 3 4 5)))\n(assert (equal (ordered-union '(a b c) '(b c d)) '(a b c d)))\n(assert (equal (ordered-union '() '(1 2 3)) '(1 2 3)))\n(assert (equal (ordered-union '(1 2 3) '()) '(1 2 3))))\n\n(check-ordered-union)",
    "entry_point": "ordered-union",
    "signature": "(defun ordered-union (list1 list2)",
    "docstring": {
      "es": "Escribe una versión de union que preserve el orden de los elementos en las listas originales:\nEjemplo:\n>>> ordered-union '(1 2 3) '(4 5 6)\n1 2 3 4 5 6",
      "arb": "اكتب نسخة من union تحافظ على ترتيب العناصر في القوائم الأصلية:\nمثال:\n>>> ordered-union '(1 2 3) '(4 5 6)\n1 2 3 4 5 6",
      "sw": "Andika toleo la union ambalo linahifadhi mpangilio wa vipengele katika orodha asili:\nMfano:\n>>> ordered-union '(1 2 3) '(4 5 6)\n1 2 3 4 5 6",
      "tr": "Orijinal listelerdeki elemanların sırasını koruyan bir union versiyonu yazın:\nÖrnek:\n>>> ordered-union '(1 2 3) '(4 5 6)\n1 2 3 4 5 6",
      "vi": "Viết một phiên bản của union mà giữ nguyên thứ tự của các phần tử trong các danh sách gốc:\nVí dụ:\n>>> ordered-union '(1 2 3) '(4 5 6)\n1 2 3 4 5 6"
    },
    "docstring_bertscore": {
      "es": "1",
      "arb": "0.9951206446898779",
      "sw": "0.9897681518121308",
      "tr": "0.9951206446898779",
      "vi": "0.9951206446898779"
    }
  },
  {
    "task_id": "Common Lisp/7",
    "prompt": {
      "es": "(defun occurrences (lst)\n;; toma una lista y devuelve una lista que indica el número de veces que aparece cada elemento (eql), ordenada desde el elemento más común hasta el menos común\n;; Ejemplo:\n;; >>> occurrences '(a b a d a c d c a)\n;; (a . 4) (c . 2) (d . 2) (b . 1)",
      "arb": "(defun occurrences (lst)\n;; يأخذ قائمة ويعيد قائمة تشير إلى عدد المرات التي يظهر فيها كل عنصر (eql)، مرتبة من العنصر الأكثر شيوعًا إلى الأقل شيوعًا\n;; مثال:\n;; >>> occurrences '(a b a d a c d c a)\n;; (a . 4) (c . 2) (d . 2) (b . 1)",
      "sw": "(defun occurrences (lst)\n;; inachukua orodha na kurudisha orodha inayoonyesha idadi ya mara kila kipengele (eql) kinavyoonekana, kimepangwa kutoka kipengele kinachoonekana mara nyingi hadi kile kinachoonekana mara chache\n;; Mfano:\n;; >>> occurrences '(a b a d a c d c a)\n;; (a . 4) (c . 2) (d . 2) (b . 1)",
      "tr": "(defun occurrences (lst)\n;; bir liste alır ve her bir (eql) elemanın kaç kez göründüğünü belirten bir liste döndürür, en yaygın olandan en az yaygın olana doğru sıralanmış şekilde\n;; Örnek:\n;; >>> occurrences '(a b a d a c d c a)\n;; (a . 4) (c . 2) (d . 2) (b . 1)",
      "vi": "(defun occurrences (lst)\n;; nhận một danh sách và trả về một danh sách chỉ ra số lần mỗi phần tử (eql) xuất hiện, sắp xếp từ phần tử xuất hiện nhiều nhất đến ít nhất\n;; Ví dụ:\n;; >>> occurrences '(a b a d a c d c a)\n;; (a . 4) (c . 2) (d . 2) (b . 1)"
    },
    "prompt_bertscore": {
      "es": "0.978638097041222",
      "arb": "0.978638692932365",
      "sw": "0.9603374855149536",
      "tr": "0.9863622366685256",
      "vi": "0.9757458400629729"
    },
    "canonical_solution": "(let ((result nil))\n(dolist (obj lst)\n(if (null (assoc obj result))\n(push (cons obj 1) result)\n(incf (cdr (assoc obj result)))\n))\n(sort result #'(lambda (a b) (if (> (cdr a) (cdr b)) t nil)))))",
    "instruction": {
      "es": "(defun occurrences (lst)\n(let ((result nil))\n(dolist (obj lst)\n(if (null (assoc obj result))\n(push (cons obj 1) result)\n(incf (cdr (assoc obj result)))\n))\n(sort result #'(lambda (a b) (if (> (cdr a) (cdr b)) t nil)))))\n\nProporcione una descripción concisa en lenguaje natural (docstring) del código Common Lisp en español utilizando como máximo 500 caracteres.",
      "arb": "(defun occurrences (lst)\n(let ((result nil))\n(dolist (obj lst)\n(if (null (assoc obj result))\n(push (cons obj 1) result)\n(incf (cdr (assoc obj result)))\n))\n(sort result #'(lambda (a b) (if (> (cdr a) (cdr b)) t nil)))))\n\nيرجى تقديم وصف موجز بلغة طبيعية (docstring) لشفرة Common Lisp باللغة العربية الفصحى باستخدام 500 حرف كحد أقصى.",
      "sw": "(defun occurrences (lst)\n(let ((result nil))\n(dolist (obj lst)\n(if (null (assoc obj result))\n(push (cons obj 1) result)\n(incf (cdr (assoc obj result)))\n))\n(sort result #'(lambda (a b) (if (> (cdr a) (cdr b)) t nil)))))\n\nToa maelezo mafupi ya lugha asilia (docstring) ya msimbo wa Common Lisp kwa Kiswahili kwa kutumia herufi zisizozidi 500.",
      "tr": "(defun occurrences (lst)\n(let ((result nil))\n(dolist (obj lst)\n(if (null (assoc obj result))\n(push (cons obj 1) result)\n(incf (cdr (assoc obj result)))\n))\n(sort result #'(lambda (a b) (if (> (cdr a) (cdr b)) t nil)))))\n\nAşağıdaki Common Lisp kodunun doğal dilde kısa bir açıklamasını (docstring) en fazla 500 karakter kullanarak Türkçe olarak sağlayın.",
      "vi": "(defun occurrences (lst)\n(let ((result nil))\n(dolist (obj lst)\n(if (null (assoc obj result))\n(push (cons obj 1) result)\n(incf (cdr (assoc obj result)))\n))\n(sort result #'(lambda (a b) (if (> (cdr a) (cdr b)) t nil)))))\n\nCung cấp mô tả ngắn gọn bằng ngôn ngữ tự nhiên (docstring) cho mã Common Lisp bằng tiếng Việt, sử dụng tối đa 500 ký tự."
    },
    "instruction_bertscore": {
      "es": "0.9711352316583911",
      "arb": "0.9156915334001228",
      "sw": "0.9454739741021129",
      "tr": "0.8482843272921231",
      "vi": "0.9119165630085547"
    },
    "level": "",
    "test": "(defun check-occurrences ()\n;; 测试 'occurrences' 函数。\n(assert (equal (occurrences '(a b a d a c d c a)) '((a . 4) (c . 2) (d . 2) (b . 1))))\n(assert (equal (occurrences '(1 2 2 3 3 3)) '((3 . 3) (2 . 2) (1 . 1))))\n(assert (equal (occurrences '(a b a)) '((a . 2) (b . 1)))))\n\n(check-occurrences)",
    "entry_point": "occurrences",
    "signature": "(defun occurrences (lst)",
    "docstring": {
      "es": "toma una lista y devuelve una lista que indica el número de veces que aparece cada elemento (eql), ordenada desde el elemento más común hasta el menos común  \nEjemplo:  \n>>> occurrences '(a b a d a c d c a)  \n(a . 4) (c . 2) (d . 2) (b . 1)",
      "arb": "يأخذ قائمة ويعيد قائمة تشير إلى عدد المرات التي يظهر فيها كل عنصر (eql)، مرتبة من العنصر الأكثر شيوعًا إلى الأقل شيوعًا  \nمثال:  \n>>> occurrences '(a b a d a c d c a)  \n(a . 4) (c . 2) (d . 2) (b . 1)",
      "sw": "huchukua orodha na kurudisha orodha inayoonyesha idadi ya mara kila kipengele (eql) kinavyoonekana, kimepangwa kutoka kipengele kinachotokea mara nyingi zaidi hadi kinachotokea mara chache zaidi\nMfano:\n>>> occurrences '(a b a d a c d c a)\n(a . 4) (c . 2) (d . 2) (b . 1)",
      "tr": "bir liste alır ve her bir (eql) elemanın kaç kez göründüğünü belirten bir liste döndürür, en yaygın olandan en az yaygın olana doğru sıralanmış\nÖrnek:\n>>> occurrences '(a b a d a c d c a)\n(a . 4) (c . 2) (d . 2) (b . 1)",
      "vi": "nhận một danh sách và trả về một danh sách chỉ ra số lần mỗi phần tử (eql) xuất hiện, sắp xếp từ phần tử phổ biến nhất đến ít phổ biến nhất\n\nVí dụ:\n>>> occurrences '(a b a d a c d c a)\n(a . 4) (c . 2) (d . 2) (b . 1)"
    },
    "docstring_bertscore": {
      "es": "0.9839073637893154",
      "arb": "0.9799476671433849",
      "sw": "0.9570982212610366",
      "tr": "0.9876747862264041",
      "vi": "0.975103469410706"
    }
  },
  {
    "task_id": "Common Lisp/8",
    "prompt": {
      "es": "(defun list-to-dots (lst)\n;; toma una lista y la imprime en notación de puntos\n;; Ejemplo:\n;; >>> list-to-dots '(a b c)\n;; (a . (b . (c . nil)))",
      "arb": "(defun list-to-dots (lst)\n;; يأخذ قائمة ويطبعها بتدوين النقاط\n;; مثال:\n;; >>> list-to-dots '(a b c)\n;; (a . (b . (c . nil)))",
      "sw": "(defun list-to-dots (lst)\n;; inachukua orodha na kuichapisha katika noti ya nukta\n;; Mfano:\n;; >>> list-to-dots '(a b c)\n;; (a . (b . (c . nil)))",
      "tr": "(defun list-to-dots (lst)\n;; bir liste alır ve nokta gösterimiyle yazdırır\n;; Örnek:\n;; >>> list-to-dots '(a b c)\n;; (a . (b . (c . nil)))",
      "vi": "(defun list-to-dots (lst)\n;; nhận một danh sách và in nó theo ký hiệu dấu chấm\n;; Ví dụ:\n;; >>> list-to-dots '(a b c)\n;; (a . (b . (c . nil)))"
    },
    "prompt_bertscore": {
      "es": "0.9730200353440311",
      "arb": "0.9756918125993315",
      "sw": "0.9730200353440311",
      "tr": "0.9785060078378337",
      "vi": "0.9666443973735733"
    },
    "canonical_solution": "(if (null lst)\n'nil\n(cons (car lst) (list-to-dots (cdr lst)))))",
    "instruction": {
      "es": "(defun list-to-dots (lst)\n(if (null lst)\n'nil\n(cons (car lst) (list-to-dots (cdr lst)))))\n\nProporcione una descripción concisa en lenguaje natural (docstring) del código Common Lisp en español utilizando un máximo de 500 caracteres.",
      "arb": "(defun list-to-dots (lst)\n(if (null lst)\n'nil\n(cons (car lst) (list-to-dots (cdr lst)))))\n\nيرجى تقديم وصف موجز بلغة طبيعية (docstring) لشيفرة Common Lisp باللغة العربية الفصحى، بحيث لا يتجاوز 500 حرف.",
      "sw": "(defun list-to-dots (lst)\n(if (null lst)\n'nil\n(cons (car lst) (list-to-dots (cdr lst)))))\n\nToa maelezo mafupi ya lugha asilia (docstring) ya msimbo wa Common Lisp kwa Kiswahili kwa kutumia herufi zisizozidi 500.",
      "tr": "(defun list-to-dots (lst)\n(if (null lst)\n'nil\n(cons (car lst) (list-to-dots (cdr lst)))))\n\nAşağıdaki Common Lisp kodunun doğal dilde kısa bir açıklamasını (docstring) Türkçe olarak en fazla 500 karakter kullanarak sağlayın.",
      "vi": "(defun list-to-dots (lst)\n(if (null lst)\n'nil\n(cons (car lst) (list-to-dots (cdr lst)))))\n\nCung cấp mô tả ngắn gọn bằng ngôn ngữ tự nhiên (docstring) cho mã Common Lisp bằng tiếng Việt, sử dụng tối đa 500 ký tự."
    },
    "instruction_bertscore": {
      "es": "0.9711352316583911",
      "arb": "0.8841158576181497",
      "sw": "0.9454739741021129",
      "tr": "0.8409868457232823",
      "vi": "0.9119165630085547"
    },
    "level": "",
    "test": "(defun check-list-to-dots ()\n;; 测试 'list-to-dots' 函数。\n(assert (equal (list-to-dots '(a b c)) '(a . (b . (c . nil)))))\n(assert (equal (list-to-dots '(1 2 3)) '(1 . (2 . (3 . nil)))))\n(assert (equal (list-to-dots '(x y)) '(x . (y . nil))))\n(assert (equal (list-to-dots '()) 'nil)))\n\n(check-list-to-dots)",
    "entry_point": "list-to-dots",
    "signature": "(defun list-to-dots (lst)",
    "docstring": {
      "es": "toma una lista y la imprime en notación de puntos  \nEjemplo:  \n>>> list-to-dots '(a b c)  \n(a . (b . (c . nil)))",
      "arb": "يأخذ قائمة ويطبعها بتدوين النقاط  \nمثال:  \n>>> list-to-dots '(a b c)  \n(a . (b . (c . nil)))",
      "sw": "huchukua orodha na kuichapisha katika noti ya nukta\nMfano:\n>>> list-to-dots '(a b c)\n(a . (b . (c . nil)))",
      "tr": "bir liste alır ve onu nokta notasyonunda yazdırır\nÖrnek:\n>>> list-to-dots '(a b c)\n(a . (b . (c . nil)))",
      "vi": "takes a list and prints it in dot natation  \nVí dụ:  \n>>> list-to-dots '(a b c)  \n(a . (b . (c . nil)))"
    },
    "docstring_bertscore": {
      "es": "0.9624103921714336",
      "arb": "0.9693000855680097",
      "sw": "0.9624103921714336",
      "tr": "0.9710319438602529",
      "vi": "0.9710319438602529"
    }
  },
  {
    "task_id": "Common Lisp/9",
    "prompt": {
      "es": "(defun contains-nil? (lst)\n;; Verificar si la lista contiene elementos nil\n;; Ejemplo:\n;; >>> contains-nil? '(1 2 3 nil 4 5)\n;; t",
      "arb": "(defun contains-nil? (lst)\n;; التحقق مما إذا كانت القائمة تحتوي على عناصر nil\n;; مثال:\n;; >>> contains-nil? '(1 2 3 nil 4 5)\n;; t",
      "sw": "(defun contains-nil? (lst)\n;; Angalia kama orodha ina vipengele vya nil\n;; Mfano:\n;; >>> contains-nil? '(1 2 3 nil 4 5)\n;; t",
      "tr": "(defun contains-nil? (lst)\n;; Listenin nil öğeleri içerip içermediğini kontrol et\n;; Örnek:\n;; >>> contains-nil? '(1 2 3 nil 4 5)\n;; t",
      "vi": "(defun contains-nil? (lst)\n;; Kiểm tra xem danh sách có chứa phần tử nil hay không\n;; Ví dụ:\n;; >>> contains-nil? '(1 2 3 nil 4 5)\n;; t"
    },
    "prompt_bertscore": {
      "es": "0.9999996027392379",
      "arb": "0.9999996027392379",
      "sw": "0.9999996027392379",
      "tr": "0.9999996027392379",
      "vi": "0.9871170321164582"
    },
    "canonical_solution": "(loop for item in lst\nthereis (null item)))",
    "instruction": {
      "es": "(defun contains-nil? (lst)\n(loop for item in lst\nthereis (null item)))\n\nProporcione una descripción concisa en lenguaje natural (docstring) del código Common Lisp en español utilizando como máximo 500 caracteres.",
      "arb": "(defun contains-nil? (lst)\n(loop for item in lst\nthereis (null item)))\n\nيرجى تقديم وصف موجز بلغة طبيعية (docstring) لشيفرة Common Lisp باللغة العربية الفصحى، بحيث لا يتجاوز 500 حرف.",
      "sw": "(defun contains-nil? (lst)\n(loop for item in lst\nthereis (null item)))\n\nToa maelezo mafupi ya lugha ya asili (docstring) ya msimbo wa Common Lisp kwa Kiswahili kwa kutumia herufi zisizozidi 500.",
      "tr": "(defun contains-nil? (lst)\n(loop for item in lst\nthereis (null item)))\n\nAşağıdaki Common Lisp kodunun işlevini açıklayan, en fazla 500 karakter uzunluğunda bir doğal dil açıklaması (docstring) sağlayın.",
      "vi": "(defun contains-nil? (lst)\n(loop for item in lst\nthereis (null item)))\n\nCung cấp mô tả ngắn gọn bằng ngôn ngữ tự nhiên (docstring) cho mã Common Lisp bằng tiếng Việt, không quá 500 ký tự."
    },
    "instruction_bertscore": {
      "es": "0.9711352316583911",
      "arb": "0.8964802015768094",
      "sw": "0.9127128722061235",
      "tr": "0.833441274808529",
      "vi": "0.9077379756827237"
    },
    "level": "",
    "test": "(defun check-contains-nil? ()\n(assert (equal (contains-nil? '(1 2 3 nil 4 5)) t))\n(assert (equal (contains-nil? '(1 2 3 4 5)) nil))\n(assert (equal (contains-nil? '(nil 1 2 3)) t))\n(assert (equal (contains-nil? '()) nil))\n(assert (equal (contains-nil? '(nil)) t)))\n\n(check-contains-nil?)",
    "entry_point": "contains-nil?",
    "signature": "(defun contains-nil? (lst)",
    "docstring": {
      "es": "Verificar si la lista contiene elementos nulos  \nEjemplo:  \n>>> contains-nil? '(1 2 3 nil 4 5)  \nt",
      "arb": "تحقق مما إذا كانت القائمة تحتوي على عناصر فارغة  \nمثال:  \n>>> contains-nil? '(1 2 3 nil 4 5)  \nt",
      "sw": "Angalia kama orodha ina vipengele vya nil  \nMfano:  \n>>> contains-nil? '(1 2 3 nil 4 5)  \nt",
      "tr": "Liste nil öğeleri içeriyor mu kontrol et  \nÖrnek:  \n>>> contains-nil? '(1 2 3 nil 4 5)  \nt",
      "vi": "Kiểm tra xem danh sách có chứa các phần tử nil không  \nVí dụ:  \n>>> contains-nil? '(1 2 3 nil 4 5)  \nt"
    },
    "docstring_bertscore": {
      "es": "0.9839991310253535",
      "arb": "0.978376500829399",
      "sw": "0.9999996027392379",
      "tr": "0.926920307470406",
      "vi": "0.9999996027392379"
    }
  },
  {
    "task_id": "Common Lisp/10",
    "prompt": {
      "es": "(defun index-of-element (element lst)\n;; Devuelve el índice del elemento en la lista, o nil si el elemento no está en la lista.\n;; Ejemplo:\n;; >>> index-of-element 'a '(a b c d e)\n;; 0",
      "arb": "(defun index-of-element (element lst)\n;; يُرجع فهرس العنصر في القائمة، أو nil إذا لم يكن العنصر في القائمة.\n;; مثال:\n;; >>> index-of-element 'a '(a b c d e)\n;; 0",
      "sw": "(defun index-of-element (element lst)\n;; Inarudisha fahirisi ya kipengele katika orodha, au nil ikiwa kipengele hakipo katika orodha.\n;; Mfano:\n;; >>> index-of-element 'a '(a b c d e)\n;; 0",
      "tr": "(defun index-of-element (element lst)\n;; Listenin içindeki elemanın indeksini döndürür, veya eleman listede yoksa nil döndürür.\n;; Örnek:\n;; >>> index-of-element 'a '(a b c d e)\n;; 0",
      "vi": "(defun index-of-element (element lst)\n;; Trả về chỉ số của phần tử trong danh sách, hoặc nil nếu phần tử không có trong danh sách.\n;; Ví dụ:\n;; >>> index-of-element 'a '(a b c d e)\n;; 0"
    },
    "prompt_bertscore": {
      "es": "1",
      "arb": "1",
      "sw": "1",
      "tr": "0.9921104012652943",
      "vi": "1"
    },
    "canonical_solution": "(loop for item in lst\nfor index from 0\nwhen (eql item element)\ndo (return index)))",
    "instruction": {
      "es": "(defun index-of-element (element lst)\n(loop for item in lst\nfor index from 0\nwhen (eql item element)\ndo (return index)))\n\nProporcione una descripción concisa en lenguaje natural (docstring) del código Common Lisp en español utilizando como máximo 500 caracteres.",
      "arb": "(defun index-of-element (element lst)\n(loop for item in lst\nfor index from 0\nwhen (eql item element)\ndo (return index)))\n\nيرجى تقديم وصف موجز بلغة طبيعية (docstring) لشفرة Common Lisp باللغة العربية الفصحى، بحيث لا يتجاوز 500 حرف.",
      "sw": "(defun index-of-element (element lst)\n(loop for item in lst\nfor index from 0\nwhen (eql item element)\ndo (return index)))\n\nToa maelezo mafupi ya lugha ya asili (docstring) ya msimbo wa Common Lisp kwa Kiswahili kwa kutumia herufi zisizozidi 500.",
      "tr": "(defun index-of-element (element lst)\n(loop for item in lst\nfor index from 0\nwhen (eql item element)\ndo (return index)))\n\nAşağıdaki Common Lisp kodunun işlevini açıklayan kısa bir doğal dil açıklaması (docstring) sağlayın. Açıklama Türkçe olmalı ve en fazla 500 karakter kullanılmalıdır.",
      "vi": "(defun index-of-element (element lst)\n(loop for item in lst\nfor index from 0\nwhen (eql item element)\ndo (return index)))\n\nCung cấp mô tả ngắn gọn bằng ngôn ngữ tự nhiên (docstring) cho mã Common Lisp bằng tiếng Việt, sử dụng tối đa 500 ký tự."
    },
    "instruction_bertscore": {
      "es": "0.9711352316583911",
      "arb": "0.8931430125450422",
      "sw": "0.9177628510135546",
      "tr": "0.8423750734563351",
      "vi": "0.9119165630085547"
    },
    "level": "",
    "test": "(defun check-index-of-element ()\n;; 测试 'index-of-element' 函数。\n(assert (equal (index-of-element 'a '(a b c d e)) 0))\n(assert (equal (index-of-element 'c '(a b c d e)) 2))\n(assert (equal (index-of-element 'e '(a b c d e)) 4))\n(assert (equal (index-of-element 'f '(a b c d e)) nil))\n(assert (equal (index-of-element 3 '(1 2 3 4 5)) 2)))\n\n(check-index-of-element)",
    "entry_point": "index-of-element",
    "signature": "(defun index-of-element (element lst)",
    "docstring": {
      "es": "Devuelve el índice del elemento en la lista, o nil si el elemento no está en la lista.\nEjemplo:\n>>> index-of-element 'a '(a b c d e)\n0",
      "arb": "يعيد فهرس العنصر في القائمة، أو nil إذا لم يكن العنصر موجودًا في القائمة.\nمثال:\n>>> index-of-element 'a '(a b c d e)\n0",
      "sw": "Inarudisha fahirisi ya kipengele katika orodha, au nil ikiwa kipengele hakipo katika orodha. \nMfano:\n>>> index-of-element 'a '(a b c d e)\n0",
      "tr": "Listenin içindeki öğenin indeksini döndürür veya öğe listede yoksa nil döndürür.\nÖrnek:\n>>> index-of-element 'a '(a b c d e)\n0",
      "vi": "Trả về chỉ số của phần tử trong danh sách, hoặc nil nếu phần tử không có trong danh sách.  \nVí dụ:  \n>>> index-of-element 'a '(a b c d e)  \n0"
    },
    "docstring_bertscore": {
      "es": "1",
      "arb": "0.9904909677687168",
      "sw": "0.9916682500371106",
      "tr": "0.9649145253851404",
      "vi": "0.9940883625996396"
    }
  },
  {
    "task_id": "Common Lisp/11",
    "prompt": {
      "es": "(defun contains-list? (lst)\n;; Verifica si la lista contiene un elemento que es una lista.\n;; Ejemplo:\n;; >>> contains-list? '(1 2 (3 4) 5)\n;; t",
      "arb": "(defun contains-list? (lst)\n;; تحقق مما إذا كانت القائمة تحتوي على عنصر قائمة.\n;; مثال:\n;; >>> contains-list? '(1 2 (3 4) 5)\n;; t",
      "sw": "(defun contains-list? (lst)\n;; Angalia kama orodha ina kipengele cha orodha.\n;; Mfano:\n;; >>> contains-list? '(1 2 (3 4) 5)\n;; t",
      "tr": "(defun contains-list? (lst)\n;; Listenin bir liste elemanı içerip içermediğini kontrol et.\n;; Örnek:\n;; >>> contains-list? '(1 2 (3 4) 5)\n;; t",
      "vi": "(defun contains-list? (lst)\n;; Kiểm tra xem danh sách có chứa phần tử danh sách hay không.\n;; Ví dụ:\n;; >>> contains-list? '(1 2 (3 4) 5)\n;; t"
    },
    "prompt_bertscore": {
      "es": "0.9470524897401971",
      "arb": "0.9707582311951869",
      "sw": "0.9707582311951869",
      "tr": "0.9690188249484644",
      "vi": "0.9707582311951869"
    },
    "canonical_solution": "(loop for item in lst\nthereis (listp item)))",
    "instruction": {
      "es": "(defun contains-list? (lst)\n(loop for item in lst\nthereis (listp item)))\n\nProporcione una descripción concisa en lenguaje natural (docstring) del código Common Lisp en español utilizando un máximo de 500 caracteres.",
      "arb": "(defun contains-list? (lst)\n(loop for item in lst\nthereis (listp item)))\n\nيرجى تقديم وصف موجز بلغة طبيعية (docstring) لشفرة Common Lisp باللغة العربية الفصحى، بحيث لا يتجاوز 500 حرف.",
      "sw": "(defun contains-list? (lst)\n(loop for item in lst\nthereis (listp item)))\n\nToa maelezo mafupi ya lugha asilia (docstring) ya msimbo wa Common Lisp kwa Kiswahili kwa kutumia herufi zisizozidi 500.",
      "tr": "(defun contains-list? (lst)\n(loop for item in lst\nthereis (listp item)))\n\nAşağıdaki Common Lisp kodunun doğal dilde kısa bir açıklamasını (docstring) en fazla 500 karakter kullanarak Türkçe olarak sağlayın.",
      "vi": "(defun contains-list? (lst)\n(loop for item in lst\nthereis (listp item)))\n\nCung cấp mô tả ngắn gọn bằng ngôn ngữ tự nhiên (docstring) cho mã Common Lisp bằng tiếng Việt, sử dụng tối đa 500 ký tự."
    },
    "instruction_bertscore": {
      "es": "0.9711352316583911",
      "arb": "0.9060988777784239",
      "sw": "0.9454739741021129",
      "tr": "0.8633800376203935",
      "vi": "0.9119165630085547"
    },
    "level": "",
    "test": "(defun check-contains-list? ()\n;; 测试 'contains-list?' 函数。\n(assert (equal (contains-list? '(1 2 (3 4) 5)) t))\n(assert (equal (contains-list? '(1 2 3 4 5)) nil))\n(assert (equal (contains-list? '((1 2) 3 4 5)) t))\n(assert (equal (contains-list? '()) nil))\n(assert (equal (contains-list? '(\"string\" 123 (a b))) t)))\n\n(check-contains-list?)",
    "entry_point": "contains-list?",
    "signature": "(defun contains-list? (lst)",
    "docstring": {
      "es": "Verifica si la lista contiene un elemento de lista.  \nEjemplo:  \n>>> contains-list? '(1 2 (3 4) 5)  \nt",
      "arb": "تحقق مما إذا كانت القائمة تحتوي على عنصر قائمة.\nمثال:\n>>> contains-list? '(1 2 (3 4) 5)\nt",
      "sw": "Angalia kama orodha ina kipengele cha orodha. Mfano: >>> contains-list? '(1 2 (3 4) 5) t",
      "tr": "Listenin bir liste öğesi içerip içermediğini kontrol edin.\nÖrnek:\n>>> contains-list? '(1 2 (3 4) 5)\nt",
      "vi": "Kiểm tra xem danh sách có chứa một phần tử danh sách hay không.  \nVí dụ:  \n>>> contains-list? '(1 2 (3 4) 5)  \nt"
    },
    "docstring_bertscore": {
      "es": "1",
      "arb": "0.9813452305043464",
      "sw": "0.9613834731014832",
      "tr": "0.9942943423047729",
      "vi": "1"
    }
  },
  {
    "task_id": "Common Lisp/12",
    "prompt": {
      "es": "(defun sum-non-nil-elements (lst)\n;; Calcular la suma de todos los elementos no nulos en la lista.\n;; Ejemplo:\n;; >>> sum-non-nil-elements '(1 2 nil 4 5)\n;; 12",
      "arb": "(defun sum-non-nil-elements (lst)\n;; حساب مجموع جميع العناصر غير nil في القائمة.\n;; مثال:\n;; >>> sum-non-nil-elements '(1 2 nil 4 5)\n;; 12",
      "sw": "(defun sum-non-nil-elements (lst)\n;; Hesabu jumla ya vipengele vyote ambavyo si nil katika orodha.\n;; Mfano:\n;; >>> sum-non-nil-elements '(1 2 nil 4 5)\n;; 12",
      "tr": "(defun sum-non-nil-elements (lst)\n;; Listedeki nil olmayan tüm elemanların toplamını hesapla.\n;; Örnek:\n;; >>> sum-non-nil-elements '(1 2 nil 4 5)\n;; 12",
      "vi": "(defun sum-non-nil-elements (lst)\n;; Tính tổng của tất cả các phần tử không phải nil trong danh sách.\n;; Ví dụ:\n;; >>> sum-non-nil-elements '(1 2 nil 4 5)\n;; 12"
    },
    "prompt_bertscore": {
      "es": "0.9900829809660712",
      "arb": "0.9900829809660712",
      "sw": "0.9742531327494958",
      "tr": "0.9900829809660712",
      "vi": "0.9900829809660712"
    },
    "canonical_solution": "(loop for item in lst\nwhen (not (null item))\nsum item))",
    "instruction": {
      "es": "(defun sum-non-nil-elements (lst)\n(loop for item in lst\nwhen (not (null item))\nsum item))\n\nProporcione una descripción concisa en lenguaje natural (docstring) del código Common Lisp en español utilizando como máximo 500 caracteres.",
      "arb": "(defun sum-non-nil-elements (lst)\n(loop for item in lst\nwhen (not (null item))\nsum item))\n\nيرجى تقديم وصف موجز بلغة طبيعية (docstring) لشفرة Common Lisp باللغة العربية الفصحى، بحيث لا يتجاوز 500 حرف.",
      "sw": "(defun sum-non-nil-elements (lst)\n(loop for item in lst\nwhen (not (null item))\nsum item))\n\nToa maelezo mafupi ya lugha ya asili (docstring) ya msimbo wa Common Lisp kwa Kiswahili kwa kutumia herufi zisizozidi 500.",
      "tr": "(defun sum-non-nil-elements (lst)\n(loop for item in lst\nwhen (not (null item))\nsum item))\n\nAşağıdaki Common Lisp kodunun işlevini açıklayan en fazla 500 karakterlik bir doğal dil açıklaması (docstring) sağlayın. Açıklama Türkçe olmalıdır.",
      "vi": "(defun sum-non-nil-elements (lst)\n(loop for item in lst\nwhen (not (null item))\nsum item))\n\nCung cấp mô tả ngắn gọn bằng ngôn ngữ tự nhiên (docstring) cho mã Common Lisp bằng tiếng Việt, sử dụng tối đa 500 ký tự."
    },
    "instruction_bertscore": {
      "es": "0.9711352316583911",
      "arb": "0.9060988777784239",
      "sw": "0.9177628510135546",
      "tr": "0.8614376311242534",
      "vi": "0.9119165630085547"
    },
    "level": "",
    "test": "(defun check-sum-non-nil-elements ()\n(assert (equal (sum-non-nil-elements '(1 2 nil 4 5)) 12))\n(assert (equal (sum-non-nil-elements '(nil nil nil)) 0))\n(assert (equal (sum-non-nil-elements '(3 4 nil 6)) 13))\n(assert (equal (sum-non-nil-elements '()) 0))\n(assert (equal (sum-non-nil-elements '(nil 7 8)) 15)))\n\n(check-sum-non-nil-elements)",
    "entry_point": "sum-non-nil-elements",
    "signature": "(defun sum-non-nil-elements (lst)",
    "docstring": {
      "es": "Calcular la suma de todos los elementos no nulos en la lista.  \nEjemplo:  \n>>> sum-non-nil-elements '(1 2 nil 4 5)  \n12",
      "arb": "احسب مجموع جميع العناصر غير nil في القائمة.\nمثال:\n>>> sum-non-nil-elements '(1 2 nil 4 5)\n12",
      "sw": "Hesabu jumla ya vipengele vyote ambavyo si nil katika orodha.\nMfano:\n>>> sum-non-nil-elements '(1 2 nil 4 5)\n12",
      "tr": "Tüm nil olmayan elemanların listesindeki toplamını hesapla.\nÖrnek:\n>>> sum-non-nil-elements '(1 2 nil 4 5)\n12",
      "vi": "Tính tổng của tất cả các phần tử không phải nil trong danh sách.  \nVí dụ:  \n>>> sum-non-nil-elements '(1 2 nil 4 5)  \n12"
    },
    "docstring_bertscore": {
      "es": "0.9813462236562516",
      "arb": "0.9849612965910866",
      "sw": "0.930125605929166",
      "tr": "0.9849612965910866",
      "vi": "0.9849612965910866"
    }
  },
  {
    "task_id": "Common Lisp/13",
    "prompt": {
      "es": "(defun conditional-square (x)\n;; Si x es un número entero positivo menor o igual a 5, devuelve x; de lo contrario, devuelve el cuadrado de x.\n;; Ejemplo:\n;; >>> conditional-square 3\n;; 3",
      "arb": "(defun conditional-square (x)\n;; إذا كان x عددًا صحيحًا موجبًا أقل من أو يساوي 5، أعد x؛ وإلا، أعد مربع x.\n;; مثال:\n;; >>> conditional-square 3\n;; 3",
      "sw": "(defun conditional-square (x)\n;; Ikiwa x ni namba nzima chanya iliyo chini au sawa na 5, rudisha x; vinginevyo, rudisha mraba wa x.\n;; Mfano:\n;; >>> conditional-square 3\n;; 3",
      "tr": "(defun conditional-square (x)\n;; Eğer x 5'e eşit veya daha küçük pozitif bir tamsayı ise, x'i döndür; aksi takdirde, x'in karesini döndür.\n;; Örnek:\n;; >>> conditional-square 3\n;; 3",
      "vi": "(defun conditional-square (x)\n;; Nếu x là một số nguyên dương nhỏ hơn hoặc bằng 5, trả về x; ngược lại, trả về bình phương của x.\n;; Ví dụ:\n;; >>> conditional-square 3\n;; 3"
    },
    "prompt_bertscore": {
      "es": "0.999999801369619",
      "arb": "0.999999801369619",
      "sw": "0.999999801369619",
      "tr": "0.9850538583486488",
      "vi": "0.999999801369619"
    },
    "canonical_solution": "(if (and (integerp x) (<= x 5) (> x 0))\nx\n(* x x)))",
    "instruction": {
      "es": "(defun conditional-square (x)\n(if (and (integerp x) (<= x 5) (> x 0))\nx\n(* x x)))\n\nProporcione una descripción concisa en lenguaje natural (docstring) del código Common Lisp en español utilizando un máximo de 500 caracteres.",
      "arb": "(defun conditional-square (x)\n(if (and (integerp x) (<= x 5) (> x 0))\nx\n(* x x)))\n\nيرجى تقديم وصف موجز بلغة طبيعية (docstring) لشفرة Common Lisp باللغة العربية الفصحى، بحيث لا يتجاوز 500 حرف.",
      "sw": "(defun conditional-square (x)\n(if (and (integerp x) (<= x 5) (> x 0))\nx\n(* x x)))\n\nToa maelezo mafupi ya lugha asilia (docstring) ya msimbo wa Common Lisp kwa Kiswahili kwa kutumia herufi zisizozidi 500.",
      "tr": "(defun conditional-square (x)\n(if (and (integerp x) (<= x 5) (> x 0))\nx\n(* x x)))\n\nAşağıdaki Common Lisp kodunun işlevini açıklayan kısa bir doğal dil açıklaması (docstring) sağlayın. Açıklama Türkçe olmalı ve en fazla 500 karakter içermelidir.",
      "vi": "(defun conditional-square (x)\n(if (and (integerp x) (<= x 5) (> x 0))\nx\n(* x x)))\n\nCung cấp mô tả ngắn gọn bằng ngôn ngữ tự nhiên (docstring) cho mã Common Lisp bằng tiếng Việt, sử dụng tối đa 500 ký tự."
    },
    "instruction_bertscore": {
      "es": "0.9711352316583911",
      "arb": "0.9134595238084338",
      "sw": "0.9454739741021129",
      "tr": "0.8595504438740409",
      "vi": "0.9119165630085547"
    },
    "level": "",
    "test": "(defun check-conditional-square ()\n;; 测试 'conditional-square' 函数。\n(assert (equal (conditional-square 3) 3))\n(assert (equal (conditional-square 5) 5))\n(assert (equal (conditional-square 6) 36))\n(assert (equal (conditional-square -3) 9))\n(assert (equal (conditional-square 2.5) 6.25)))\n\n(check-conditional-square)",
    "entry_point": "conditional-square",
    "signature": "(defun conditional-square (x)",
    "docstring": {
      "es": "Si x es un entero positivo menor o igual a 5, devuelve x; de lo contrario, devuelve el cuadrado de x.\nEjemplo:\n>>> conditional-square 3\n3",
      "arb": "إذا كانت x عددًا صحيحًا موجبًا أقل من أو يساوي 5، قم بإرجاع x؛ وإلا، قم بإرجاع مربع x.  \nمثال:  \n>>> conditional-square 3  \n3",
      "sw": "Ikiwa x ni nambari nzima chanya iliyo chini au sawa na 5, rudisha x; vinginevyo, rudisha mraba wa x. \nMfano:\n>>> conditional-square 3\n3",
      "tr": "Eğer x, 5'e eşit veya daha küçük pozitif bir tamsayı ise, x'i döndür; aksi takdirde, x'in karesini döndür.\nÖrnek:\n>>> conditional-square 3\n3",
      "vi": "Nếu x là một số nguyên dương nhỏ hơn hoặc bằng 5, trả về x; nếu không, trả về bình phương của x.  \nVí dụ:  \n>>> conditional-square 3  \n3"
    },
    "docstring_bertscore": {
      "es": "1",
      "arb": "1",
      "sw": "1",
      "tr": "0.9769618552556685",
      "vi": "1"
    }
  },
  {
    "task_id": "Common Lisp/14",
    "prompt": {
      "es": "(defun lines-from-file (filename)\n;; Leer cada línea del archivo y devolverlas como una lista de cadenas.",
      "arb": "(defun lines-from-file (filename)\n;; قراءة كل سطر من الملف وإعادتها كقائمة من السلاسل النصية.",
      "sw": "(defun lines-from-file (filename)\n;; Soma kila mstari kutoka kwenye faili na urejeshe kama orodha ya mistari ya maandishi.",
      "tr": "(defun lines-from-file (filename)\n;; Dosyadan her satırı oku ve bunları bir string listesi olarak döndür.",
      "vi": "(defun lines-from-file (filename)\n;; Đọc từng dòng từ tệp và trả về chúng dưới dạng danh sách chuỗi."
    },
    "prompt_bertscore": {
      "es": "0.9849328924465985",
      "arb": "0.9798384204338157",
      "sw": "0.9425127923816448",
      "tr": "0.9849328924465985",
      "vi": "0.9849328924465985"
    },
    "canonical_solution": "(with-open-file (stream filename)\n(loop for line = (read-line stream nil nil)\nwhile line\ncollect line)))",
    "instruction": {
      "es": "(defun lines-from-file (filename)\n(with-open-file (stream filename)\n(loop for line = (read-line stream nil nil)\nwhile line\ncollect line)))\n\nProporcione una descripción concisa en lenguaje natural (docstring) del código Common Lisp en español utilizando como máximo 500 caracteres.",
      "arb": "(defun lines-from-file (filename)\n(with-open-file (stream filename)\n(loop for line = (read-line stream nil nil)\nwhile line\ncollect line)))\n\nيرجى تقديم وصف موجز بلغة طبيعية (docstring) لشيفرة Common Lisp باللغة العربية الفصحى، بحيث لا يتجاوز 500 حرف.",
      "sw": "(defun lines-from-file (filename)\n(with-open-file (stream filename)\n(loop for line = (read-line stream nil nil)\nwhile line\ncollect line)))\n\nToa maelezo mafupi ya lugha asilia (docstring) ya msimbo wa Common Lisp kwa Kiswahili kwa kutumia herufi zisizozidi 500.",
      "tr": "(defun lines-from-file (filename)\n(with-open-file (stream filename)\n(loop for line = (read-line stream nil nil)\nwhile line\ncollect line)))\n\nAşağıdaki Common Lisp kodunun doğal dilde kısa bir açıklamasını (docstring) Türkçe olarak en fazla 500 karakter kullanarak sağlayın.",
      "vi": "(defun lines-from-file (filename)\n(with-open-file (stream filename)\n(loop for line = (read-line stream nil nil)\nwhile line\ncollect line)))\n\nCung cấp mô tả ngắn gọn bằng ngôn ngữ tự nhiên (docstring) cho mã Common Lisp bằng tiếng Việt, sử dụng tối đa 500 ký tự."
    },
    "instruction_bertscore": {
      "es": "0.9711352316583911",
      "arb": "0.9060988777784239",
      "sw": "0.9454739741021129",
      "tr": "0.8431249031447419",
      "vi": "0.9119165630085547"
    },
    "level": "",
    "test": "(defun check-lines-from-file ()\n(let ((lines (lines-from-file \"../data/Common Lisp/file.txt\")))\n(assert (equal (first lines) \"First line of the file\"))\n(assert (equal (second lines) \"Second line of the file\"))))\n\n(check-lines-from-file)",
    "entry_point": "lines-from-file",
    "signature": "(defun lines-from-file (filename)",
    "docstring": {
      "es": "Leer cada línea del archivo y devolverlas como una lista de cadenas.",
      "arb": "اقرأ كل سطر من الملف وأعدها كقائمة من السلاسل النصية.",
      "sw": "Soma kila mstari kutoka kwenye faili na urejeshe kama orodha ya mistari ya maandishi.",
      "tr": "Dosyadan her satırı okuyun ve bunları bir dize listesi olarak döndürün.",
      "vi": "Đọc từng dòng từ tệp và trả về chúng dưới dạng danh sách chuỗi."
    },
    "docstring_bertscore": {
      "es": "0.9548777322314476",
      "arb": "0.9465241329266443",
      "sw": "0.887038107783935",
      "tr": "0.9725441169510716",
      "vi": "0.9725441169510716"
    }
  },
  {
    "task_id": "Common Lisp/15",
    "prompt": {
      "es": "(defun nondecreasing? (numbers)\n;; Verificar si la lista de números reales está en orden no decreciente.\n;; Ejemplo:\n;; >>> nondecreasing? '(1.0 2.0 2.0 3.0 4.0)\n;; t",
      "arb": "(defun nondecreasing? (numbers)\n;; التحقق مما إذا كانت قائمة الأعداد الحقيقية في ترتيب غير تنازلي.\n;; مثال:\n;; >>> nondecreasing? '(1.0 2.0 2.0 3.0 4.0)\n;; t",
      "sw": "(defun nondecreasing? (numbers)\n;; Angalia kama orodha ya nambari halisi iko katika mpangilio usiopungua.\n;; Mfano:\n;; >>> nondecreasing? '(1.0 2.0 2.0 3.0 4.0)\n;; t",
      "tr": "(defun nondecreasing? (numbers)\n;; Reel sayı listesinin azalmayan sırada olup olmadığını kontrol edin.\n;; Örnek:\n;; >>> nondecreasing? '(1.0 2.0 2.0 3.0 4.0)\n;; t",
      "vi": "(defun nondecreasing? (numbers)\n;; Kiểm tra xem danh sách số thực có theo thứ tự không giảm hay không.\n;; Ví dụ:\n;; >>> nondecreasing? '(1.0 2.0 2.0 3.0 4.0)\n;; t"
    },
    "prompt_bertscore": {
      "es": "0.9662521023710294",
      "arb": "0.9662521023710294",
      "sw": "0.9662521023710294",
      "tr": "0.9662521023710294",
      "vi": "0.9662521023710294"
    },
    "canonical_solution": "(loop for i from 0 below (1- (length numbers))\nalways (<= (nth i numbers) (nth (1+ i) numbers))))",
    "instruction": {
      "es": "(defun nondecreasing? (numbers)\n(loop for i from 0 below (1- (length numbers))\nalways (<= (nth i numbers) (nth (1+ i) numbers))))\n\nProporciona una descripción concisa en lenguaje natural (docstring) del código Common Lisp en español utilizando un máximo de 500 caracteres.",
      "arb": "(defun nondecreasing? (numbers)\n(loop for i from 0 below (1- (length numbers))\nalways (<= (nth i numbers) (nth (1+ i) numbers))))\n\nيرجى تقديم وصف موجز بلغة طبيعية (docstring) لشفرة Common Lisp باللغة العربية الفصحى، بحيث لا يتجاوز 500 حرف.",
      "sw": "(defun nondecreasing? (numbers)\n(loop for i from 0 below (1- (length numbers))\nalways (<= (nth i numbers) (nth (1+ i) numbers))))\n\nToa maelezo mafupi ya lugha asilia (docstring) ya msimbo wa Common Lisp kwa Kiswahili kwa kutumia herufi zisizozidi 500.",
      "tr": "(defun nondecreasing? (numbers)\n(loop for i from 0 below (1- (length numbers))\nalways (<= (nth i numbers) (nth (1+ i) numbers))))\n\nAşağıdaki Common Lisp kodunun işlevini açıklayan, en fazla 500 karakterlik özlü bir doğal dil açıklaması (docstring) sağlayın.",
      "vi": "(defun nondecreasing? (numbers)\n(loop for i from 0 below (1- (length numbers))\nalways (<= (nth i numbers) (nth (1+ i) numbers))))\n\nCung cấp mô tả ngắn gọn bằng ngôn ngữ tự nhiên (docstring) cho mã Common Lisp bằng tiếng Việt, sử dụng tối đa 500 ký tự."
    },
    "instruction_bertscore": {
      "es": "0.9711352316583911",
      "arb": "0.9134595238084338",
      "sw": "0.9454739741021129",
      "tr": "0.8692533393572142",
      "vi": "0.9119165630085547"
    },
    "level": "",
    "test": "(defun check-nondecreasing? ()\n(assert (equal (nondecreasing? '(1.0 2.0 2.0 3.0 4.0)) t))\n(assert (equal (nondecreasing? '(1.0 2.0 3.0 3.9 4.0)) t))\n(assert (equal (nondecreasing? '(1.0 2.0 1.0 4.0 5.0)) nil))\n(assert (equal (nondecreasing? '(5.0 5.0 5.0 5.0)) t))\n(assert (equal (nondecreasing? '(1.0)) t))\n(assert (equal (nondecreasing? '()) t)))\n\n(check-nondecreasing?)",
    "entry_point": "nondecreasing?",
    "signature": "(defun nondecreasing? (numbers)",
    "docstring": {
      "es": "Verificar si la lista de números reales está en orden no decreciente.  \nEjemplo:  \n>>> nondecreasing? '(1.0 2.0 2.0 3.0 4.0)  \nt",
      "arb": "تحقق مما إذا كانت قائمة الأعداد الحقيقية بترتيب غير تنازلي.\nمثال:\n>>> nondecreasing? '(1.0 2.0 2.0 3.0 4.0)\nt",
      "sw": "Angalia kama orodha ya nambari halisi iko katika mpangilio usiopungua.\nMfano:\n>>> nondecreasing? '(1.0 2.0 2.0 3.0 4.0)\nt",
      "tr": "Gerçek sayı listesinin azalmayan sırada olup olmadığını kontrol edin.\nÖrnek:\n>>> nondecreasing? '(1.0 2.0 2.0 3.0 4.0)\nt",
      "vi": "Kiểm tra xem danh sách số thực có theo thứ tự không giảm hay không.  \nVí dụ:  \n>>> nondecreasing? '(1.0 2.0 2.0 3.0 4.0)  \nt  "
    },
    "docstring_bertscore": {
      "es": "0.957527660144834",
      "arb": "0.9522458796827353",
      "sw": "0.9522458796827353",
      "tr": "0.957527660144834",
      "vi": "0.957527660144834"
    }
  },
  {
    "task_id": "Common Lisp/16",
    "prompt": {
      "es": "(defun make-change (cents)\n;; Define una función que acepte un entero cents y devuelva cuatro valores, mostrando los números como 25-, 10-, 5-, 1-, usando el número mínimo de monedas. (Traducción: 25- es 25 centavos, y así sucesivamente)\n;; Ejemplo:\n;; multiple-value-bind (quarters dimes nickels pennies) (make-change 98\n;; quarters 3\n;; dimes 2\n;; nickels 0\n;; pennies 3",
      "arb": "(defun make-change (cents)\n;; تعريف دالة تقبل عددًا صحيحًا يمثل السنتات وتعيد أربعة قيم، تعرض الأرقام كـ 25-، 10-، 5-، 1-، باستخدام أقل عدد من العملات المعدنية. (الترجمة: 25- تعني 25 سنتًا، وهكذا)\n;; مثال:\n;; multiple-value-bind (quarters dimes nickels pennies) (make-change 98\n;; quarters 3\n;; dimes 2\n;; nickels 0\n;; pennies 3",
      "sw": "(defun make-change (cents)\n;; Eleza kazi inayokubali nambari nzima ya senti na kurudisha thamani nne, ikionyesha nambari kama 25-, 10-, 5-, 1-, kwa kutumia idadi ndogo ya sarafu. (Tafsiri: 25- ni senti 25, na kadhalika)\n;; Mfano:\n;; multiple-value-bind (quarters dimes nickels pennies) (make-change 98\n;; quarters 3\n;; dimes 2\n;; nickels 0\n;; pennies 3",
      "tr": "(defun make-change (cents)\n;; Bir tamsayı olarak cents kabul eden ve minimum sayıda madeni para kullanarak 25-, 10-, 5-, 1- değerlerini gösteren dört değer döndüren bir fonksiyon tanımlayın. (Çeviri: 25- 25 centtir, vb.)\n;; Örnek:\n;; multiple-value-bind (quarters dimes nickels pennies) (make-change 98\n;; quarters 3\n;; dimes 2\n;; nickels 0\n;; pennies 3",
      "vi": "(defun make-change (cents)\n;; Định nghĩa một hàm chấp nhận một số nguyên cents và trả về bốn giá trị, hiển thị các số dưới dạng 25-, 10-, 5-, 1-, sử dụng số lượng đồng xu ít nhất. (Dịch: 25- là 25 cents, và cứ thế)\n;; Ví dụ:\n;; multiple-value-bind (quarters dimes nickels pennies) (make-change 98\n;; quarters 3\n;; dimes 2\n;; nickels 0\n;; pennies 3"
    },
    "prompt_bertscore": {
      "es": "0.9976454354632124",
      "arb": "0.983300945236016",
      "sw": "0.9406959202863187",
      "tr": "0.9538899433465611",
      "vi": "0.9937230813289165"
    },
    "canonical_solution": "(let ((quarters (floor cents 25))\n(remaining-after-quarters (mod cents 25)))\n(let ((dimes (floor remaining-after-quarters 10))\n(remaining-after-dimes (mod remaining-after-quarters 10)))\n(let ((nickels (floor remaining-after-dimes 5))\n(pennies (mod remaining-after-dimes 5)))\n(values quarters dimes nickels pennies)))))",
    "instruction": {
      "es": "(defun make-change (cents)\n(let ((quarters (floor cents 25))\n(remaining-after-quarters (mod cents 25)))\n(let ((dimes (floor remaining-after-quarters 10))\n(remaining-after-dimes (mod remaining-after-quarters 10)))\n(let ((nickels (floor remaining-after-dimes 5))\n(pennies (mod remaining-after-dimes 5)))\n(values quarters dimes nickels pennies)))))\n\nProporcione una descripción concisa en lenguaje natural (docstring) del código Common Lisp en español utilizando como máximo 500 caracteres.",
      "arb": "(defun make-change (cents)\n(let ((quarters (floor cents 25))\n(remaining-after-quarters (mod cents 25)))\n(let ((dimes (floor remaining-after-quarters 10))\n(remaining-after-dimes (mod remaining-after-quarters 10)))\n(let ((nickels (floor remaining-after-dimes 5))\n(pennies (mod remaining-after-dimes 5)))\n(values quarters dimes nickels pennies)))))\n\nيرجى تقديم وصف موجز بلغة طبيعية (docstring) لشفرة Common Lisp باللغة العربية الفصحى، بحيث لا يتجاوز 500 حرف.",
      "sw": "(defun make-change (cents)\n(let ((quarters (floor cents 25))\n(remaining-after-quarters (mod cents 25)))\n(let ((dimes (floor remaining-after-quarters 10))\n(remaining-after-dimes (mod remaining-after-quarters 10)))\n(let ((nickels (floor remaining-after-dimes 5))\n(pennies (mod remaining-after-dimes 5)))\n(values quarters dimes nickels pennies)))))\n\nToa maelezo mafupi ya lugha ya asili (docstring) ya msimbo wa Common Lisp kwa Kiswahili kwa kutumia herufi zisizozidi 500.",
      "tr": "(defun make-change (cents)\n(let ((quarters (floor cents 25))\n(remaining-after-quarters (mod cents 25)))\n(let ((dimes (floor remaining-after-quarters 10))\n(remaining-after-dimes (mod remaining-after-quarters 10)))\n(let ((nickels (floor remaining-after-dimes 5))\n(pennies (mod remaining-after-dimes 5)))\n(values quarters dimes nickels pennies)))))\n\nAşağıdaki Common Lisp kodunun işlevini açıklayan, en fazla 500 karakter uzunluğunda, özlü bir doğal dil açıklaması (docstring) sağlayın.",
      "vi": "(defun make-change (cents)\n(let ((quarters (floor cents 25))\n(remaining-after-quarters (mod cents 25)))\n(let ((dimes (floor remaining-after-quarters 10))\n(remaining-after-dimes (mod remaining-after-quarters 10)))\n(let ((nickels (floor remaining-after-dimes 5))\n(pennies (mod remaining-after-dimes 5)))\n(values quarters dimes nickels pennies)))))\n\nCung cấp mô tả ngắn gọn bằng ngôn ngữ tự nhiên (docstring) cho mã Common Lisp bằng tiếng Việt, sử dụng tối đa 500 ký tự."
    },
    "instruction_bertscore": {
      "es": "0.9711352316583911",
      "arb": "0.9134595238084338",
      "sw": "0.9454739741021129",
      "tr": "0.8505745355854554",
      "vi": "0.9283341585226124"
    },
    "level": "",
    "test": "(defun check-make-change ()\n;; 测试 'make-change' 函数。\n(multiple-value-bind (quarters dimes nickels pennies) (make-change 98)\n(assert (equal quarters 3))\n(assert (equal dimes 2))\n(assert (equal nickels 0))\n(assert (equal pennies 3)))\n(multiple-value-bind (quarters dimes nickels pennies) (make-change 41)\n(assert (equal quarters 1))\n(assert (equal dimes 1))\n(assert (equal nickels 1))\n(assert (equal pennies 1)))\n(multiple-value-bind (quarters dimes nickels pennies) (make-change 3)\n(assert (equal quarters 0))\n(assert (equal dimes 0))\n(assert (equal nickels 0))\n(assert (equal pennies 3))))\n\n(check-make-change)",
    "entry_point": "make-change",
    "signature": "(defun make-change (cents)",
    "docstring": {
      "es": "Define una función que acepte un entero en centavos y devuelva cuatro valores, mostrando los números como 25-, 10-, 5-, 1-, utilizando el número mínimo de monedas. (Traducción: 25- es 25 centavos, y así sucesivamente)\nEjemplo:\nmultiple-value-bind (quarters dimes nickels pennies) (make-change 98\nquarters 3\ndimes 2\nnickels 0\npennies 3",
      "arb": "تعريف دالة تقبل عددًا صحيحًا يمثل السنتات وتعيد أربعة قيم، تعرض الأرقام كـ 25-، 10-، 5-، 1-، باستخدام أقل عدد من العملات المعدنية. (الترجمة: 25- تعني 25 سنتًا، وهكذا)\n\nمثال:\nmultiple-value-bind (quarters dimes nickels pennies) (make-change 98\nquarters 3\ndimes 2\nnickels 0\npennies 3",
      "sw": "Tafsiri kazi ifuatayo kwa kutumia maagizo yaliyotolewa:\n\nTafsiri kazi ifuatayo kwa kutumia maagizo yaliyotolewa:\nTambua kazi inayokubali senti kama nambari kamili na kurudisha thamani nne, ikionyesha nambari kama 25-, 10-, 5-, 1-, kwa kutumia idadi ndogo ya sarafu. (Tafsiri: 25- ni senti 25, na kadhalika)\nMfano:\nmultiple-value-bind (quarters dimes nickels pennies) (make-change 98\nquarters 3\ndimes 2\nnickels 0\npennies 3",
      "tr": "Bir fonksiyon tanımlayın, bu fonksiyon bir tamsayı olan \"cents\" değerini kabul eder ve dört değer döndürür, sayıları en az sayıda madeni para kullanarak 25-, 10-, 5-, 1- olarak gösterir. (Çeviri: 25- 25 centtir, ve bu şekilde devam eder)\nÖrnek:\nmultiple-value-bind (quarters dimes nickels pennies) (make-change 98\nquarters 3\ndimes 2\nnickels 0\npennies 3",
      "vi": "Định nghĩa một hàm chấp nhận một số nguyên cents và trả về bốn giá trị, hiển thị các số dưới dạng 25-, 10-, 5-, 1-, sử dụng số lượng đồng xu ít nhất. (Dịch: 25- là 25 cents, và tương tự)\n\nVí dụ:\nmultiple-value-bind (quarters dimes nickels pennies) (make-change 98\nquarters 3\ndimes 2\nnickels 0\npennies 3"
    },
    "docstring_bertscore": {
      "es": "0.989210993593328",
      "arb": "0.9640488941845904",
      "sw": "0.9209629850824076",
      "tr": "0.9253143808397389",
      "vi": "0.959936450775644"
    }
  },
  {
    "task_id": "Common Lisp/17",
    "prompt": {
      "es": "(defun segments-intersect? (x1 y1 x2 y2 x3 y3 x4 y4)\n;; Define una función que acepta 8 números reales que representan los puntos extremos de dos segmentos de línea en un espacio bidimensional. Si los segmentos de línea no se intersectan, devuelve falso, o devuelve dos valores que representan las coordenadas x e y del punto de intersección\n;; Ejemplo:\n;; >>> segments-intersect? 0 0 1 1 1 0 0 1\n;; x 0.5\n;; y 0.5",
      "arb": "(defun segments-intersect? (x1 y1 x2 y2 x3 y3 x4 y4)\n;; تعريف دالة تقبل 8 أرقام حقيقية تمثل نقاط النهاية لقطعتين مستقيمتين في الفضاء ثنائي الأبعاد. إذا لم تتقاطع القطعتان المستقيمتان، أعد false، أو أعد قيمتين تمثلان الإحداثيات x و y لنقطة التقاطع\n;; مثال:\n;; >>> segments-intersect? 0 0 1 1 1 0 0 1\n;; x 0.5\n;; y 0.5",
      "sw": "(defun segments-intersect? (x1 y1 x2 y2 x3 y3 x4 y4)\n;; Fafanua kazi inayokubali namba 8 halisi zinazowakilisha ncha za mistari miwili katika nafasi ya vipimo viwili. Ikiwa mistari haikatani, rudisha uongo, au rudisha maadili mawili yanayowakilisha kuratibu za x na y za sehemu ya makutano\n;; Mfano:\n;; >>> segments-intersect? 0 0 1 1 1 0 0 1\n;; x 0.5\n;; y 0.5",
      "tr": "(defun segments-intersect? (x1 y1 x2 y2 x3 y3 x4 y4)\n;; İki boyutlu uzayda iki doğru parçasının uç noktalarını temsil eden 8 gerçek sayı kabul eden bir fonksiyon tanımlayın. Eğer doğru parçaları kesişmiyorsa, false döndürün veya kesişim noktasının x ve y koordinatlarını temsil eden iki değer döndürün\n;; Örnek:\n;; >>> segments-intersect? 0 0 1 1 1 0 0 1\n;; x 0.5\n;; y 0.5",
      "vi": "(defun segments-intersect? (x1 y1 x2 y2 x3 y3 x4 y4)\n;; Định nghĩa một hàm nhận 8 số thực đại diện cho các điểm cuối của hai đoạn thẳng trong không gian hai chiều. Nếu các đoạn thẳng không giao nhau, trả về false, hoặc trả về hai giá trị đại diện cho tọa độ x và y của điểm giao nhau\n;; Ví dụ:\n;; >>> segments-intersect? 0 0 1 1 1 0 0 1\n;; x 0.5\n;; y 0.5"
    },
    "prompt_bertscore": {
      "es": "0.9821326013347687",
      "arb": "0.9897979463692861",
      "sw": "0.9899175218586691",
      "tr": "0.9975757161994692",
      "vi": "0.9967023384140588"
    },
    "canonical_solution": "(let ((denom (- (* (- x2 x1) (- y4 y3)) (* (- y2 y1) (- x4 x3)))))\n(unless (zerop denom)\n(let* ((ua (/ (- (* (- x4 x3) (- y1 y3)) (* (- y4 y3) (- x1 x3))) denom))\n(ub (/ (- (* (- x2 x1) (- y1 y3)) (* (- y2 y1) (- x1 x3))) denom))\n(x-on-segment (+ x1 (* ua (- x2 x1))))\n(y-on-segment (+ y1 (* ua (- y2 y1)))))\n(when (and (>= ua 0) (<= ua 1) (>= ub 0) (<= ub 1))\n(values x-on-segment y-on-segment))))))\n\n(defun float-near-equal (a b &optional (tolerance 1e-5))\n(<= (abs (- a b)) tolerance))",
    "instruction": {
      "es": "(defun segments-intersect? (x1 y1 x2 y2 x3 y3 x4 y4)\n(let ((denom (- (* (- x2 x1) (- y4 y3)) (* (- y2 y1) (- x4 x3)))))\n(unless (zerop denom)\n(let* ((ua (/ (- (* (- x4 x3) (- y1 y3)) (* (- y4 y3) (- x1 x3))) denom))\n(ub (/ (- (* (- x2 x1) (- y1 y3)) (* (- y2 y1) (- x1 x3))) denom))\n(x-on-segment (+ x1 (* ua (- x2 x1))))\n(y-on-segment (+ y1 (* ua (- y2 y1)))))\n(when (and (>= ua 0) (<= ua 1) (>= ub 0) (<= ub 1))\n(values x-on-segment y-on-segment))))))\n\n(defun float-near-equal (a b &optional (tolerance 1e-5))\n(<= (abs (- a b)) tolerance))\n\nProporcione una descripción concisa en lenguaje natural (docstring) del código Common Lisp en español utilizando un máximo de 500 caracteres.",
      "arb": "(defun segments-intersect? (x1 y1 x2 y2 x3 y3 x4 y4)\n(let ((denom (- (* (- x2 x1) (- y4 y3)) (* (- y2 y1) (- x4 x3)))))\n(unless (zerop denom)\n(let* ((ua (/ (- (* (- x4 x3) (- y1 y3)) (* (- y4 y3) (- x1 x3))) denom))\n(ub (/ (- (* (- x2 x1) (- y1 y3)) (* (- y2 y1) (- x1 x3))) denom))\n(x-on-segment (+ x1 (* ua (- x2 x1))))\n(y-on-segment (+ y1 (* ua (- y2 y1)))))\n(when (and (>= ua 0) (<= ua 1) (>= ub 0) (<= ub 1))\n(values x-on-segment y-on-segment))))))\n\n(defun float-near-equal (a b &optional (tolerance 1e-5))\n(<= (abs (- a b)) tolerance))\n\nيرجى تقديم وصف موجز بلغة طبيعية (docstring) لشفرة Common Lisp باللغة العربية الفصحى، بحيث لا يتجاوز 500 حرف.",
      "sw": "(defun segments-intersect? (x1 y1 x2 y2 x3 y3 x4 y4)\n(let ((denom (- (* (- x2 x1) (- y4 y3)) (* (- y2 y1) (- x4 x3)))))\n(unless (zerop denom)\n(let* ((ua (/ (- (* (- x4 x3) (- y1 y3)) (* (- y4 y3) (- x1 x3))) denom))\n(ub (/ (- (* (- x2 x1) (- y1 y3)) (* (- y2 y1) (- x1 x3))) denom))\n(x-on-segment (+ x1 (* ua (- x2 x1))))\n(y-on-segment (+ y1 (* ua (- y2 y1)))))\n(when (and (>= ua 0) (<= ua 1) (>= ub 0) (<= ub 1))\n(values x-on-segment y-on-segment))))))\n\n(defun float-near-equal (a b &optional (tolerance 1e-5))\n(<= (abs (- a b)) tolerance))\n\nToa maelezo mafupi ya lugha ya asili (docstring) ya msimbo wa Common Lisp kwa Kiswahili kwa kutumia herufi zisizozidi 500.",
      "tr": "(defun segments-intersect? (x1 y1 x2 y2 x3 y3 x4 y4)\n(let ((denom (- (* (- x2 x1) (- y4 y3)) (* (- y2 y1) (- x4 x3)))))\n(unless (zerop denom)\n(let* ((ua (/ (- (* (- x4 x3) (- y1 y3)) (* (- y4 y3) (- x1 x3))) denom))\n(ub (/ (- (* (- x2 x1) (- y1 y3)) (* (- y2 y1) (- x1 x3))) denom))\n(x-on-segment (+ x1 (* ua (- x2 x1))))\n(y-on-segment (+ y1 (* ua (- y2 y1)))))\n(when (and (>= ua 0) (<= ua 1) (>= ub 0) (<= ub 1))\n(values x-on-segment y-on-segment))))))\n\n(defun float-near-equal (a b &optional (tolerance 1e-5))\n(<= (abs (- a b)) tolerance))\n\nAşağıdaki Common Lisp kodunun işlevini açıklayan kısa bir doğal dil açıklaması (docstring) sağlayın. Açıklama Türkçe olmalı ve en fazla 500 karakter içermelidir.",
      "vi": "(defun segments-intersect? (x1 y1 x2 y2 x3 y3 x4 y4)\n(let ((denom (- (* (- x2 x1) (- y4 y3)) (* (- y2 y1) (- x4 x3)))))\n(unless (zerop denom)\n(let* ((ua (/ (- (* (- x4 x3) (- y1 y3)) (* (- y4 y3) (- x1 x3))) denom))\n(ub (/ (- (* (- x2 x1) (- y1 y3)) (* (- y2 y1) (- x1 x3))) denom))\n(x-on-segment (+ x1 (* ua (- x2 x1))))\n(y-on-segment (+ y1 (* ua (- y2 y1)))))\n(when (and (>= ua 0) (<= ua 1) (>= ub 0) (<= ub 1))\n(values x-on-segment y-on-segment))))))\n\n(defun float-near-equal (a b &optional (tolerance 1e-5))\n(<= (abs (- a b)) tolerance))\n\nCung cấp mô tả ngắn gọn bằng ngôn ngữ tự nhiên (docstring) cho mã Common Lisp bằng tiếng Việt, sử dụng tối đa 500 ký tự."
    },
    "instruction_bertscore": {
      "es": "0.9711352316583911",
      "arb": "0.8964802015768094",
      "sw": "0.9127128722061235",
      "tr": "0.8595504438740409",
      "vi": "0.9119165630085547"
    },
    "level": "",
    "test": "(defun check-segments-intersect? ()\n(multiple-value-bind (x y) (segments-intersect? 0 0 1 1 1 0 0 1)\n(assert (and (float-near-equal x 0.5) (float-near-equal y 0.5))))\n(assert (null (segments-intersect? 0 0 1 1 2 2 3 3))))\n\n(check-segments-intersect?)",
    "entry_point": "segments-intersect?",
    "signature": "(defun segments-intersect? (x1 y1 x2 y2 x3 y3 x4 y4)",
    "docstring": {
      "es": "Define una función que acepte 8 números reales que representen los extremos de dos segmentos de línea en un espacio bidimensional. Si los segmentos de línea no se intersectan, devuelve falso, o devuelve dos valores que representan las coordenadas x e y del punto de intersección.  \nEjemplo:\n>>> segments-intersect? 0 0 1 1 1 0 0 1\nx 0.5\ny 0.5",
      "arb": "تعريف دالة تقبل 8 أرقام حقيقية تمثل نقاط النهاية لمقطعين خطيين في الفضاء ثنائي الأبعاد. إذا لم تتقاطع المقاطع الخطية، أعد false، أو أعد قيمتين تمثلان إحداثيات x و y لنقطة التقاطع.\n\nمثال:\n>>> segments-intersect? 0 0 1 1 1 0 0 1\nx 0.5\ny 0.5",
      "sw": "Tafsiri kazi ifuatayo kwa kutumia maagizo yaliyotolewa:\n\nTafsiri kazi ifuatayo kwa kutumia maagizo yaliyotolewa:\nFafanua kazi inayokubali namba halisi 8 zinazowakilisha ncha za mistari miwili katika nafasi ya vipimo viwili. Ikiwa mistari hiyo haikatani, rudisha uongo, au rudisha maadili mawili yanayowakilisha kuratibu za x na y za sehemu ya makutano.\nMfano:\n>>> segments-intersect? 0 0 1 1 1 0 0 1\nx 0.5\ny 0.5",
      "tr": "Bir fonksiyon tanımlayın, bu fonksiyon iki boyutlu uzayda iki doğru parçasının uç noktalarını temsil eden 8 gerçek sayı kabul eder. Eğer doğru parçaları kesişmiyorsa, false döndürün veya kesişim noktasının x ve y koordinatlarını temsil eden iki değer döndürün.\n\nÖrnek:\n>>> segments-intersect? 0 0 1 1 1 0 0 1\nx 0.5\ny 0.5",
      "vi": "Định nghĩa một hàm chấp nhận 8 số thực đại diện cho các điểm cuối của hai đoạn thẳng trong không gian hai chiều. Nếu các đoạn thẳng không cắt nhau, trả về false, hoặc trả về hai giá trị đại diện cho tọa độ x và y của điểm giao nhau.\n\nVí dụ:\n>>> segments-intersect? 0 0 1 1 1 0 0 1\nx 0.5\ny 0.5"
    },
    "docstring_bertscore": {
      "es": "0.9875502449774953",
      "arb": "0.9913031673967685",
      "sw": "0.948930539992882",
      "tr": "0.9759033539551336",
      "vi": "0.9875502449774953"
    }
  },
  {
    "task_id": "Common Lisp/18",
    "prompt": {
      "es": "(defun quicksort (list)\n;; Ordenar rápidamente la lista\n;; Ejemplo:\n;; quicksort '(3 1 4 1 5 9 2 6 5 3 5)v\n;; 1 1 2 3 3 4 5 5 5 6 9",
      "arb": "(defun quicksort (list)\n;; فرز القائمة بسرعة\n;; مثال:\n;; quicksort '(3 1 4 1 5 9 2 6 5 3 5)v\n;; 1 1 2 3 3 4 5 5 5 6 9",
      "sw": "(defun quicksort (list)\n;; Panga haraka orodha\n;; Mfano:\n;; quicksort '(3 1 4 1 5 9 2 6 5 3 5)\n;; 1 1 2 3 3 4 5 5 5 6 9",
      "tr": "(defun quicksort (list)\n;; Listeyi hızlıca sırala\n;; Örnek:\n;; quicksort '(3 1 4 1 5 9 2 6 5 3 5)v\n;; 1 1 2 3 3 4 5 5 5 6 9",
      "vi": "(defun quicksort (list)\n;; Nhanh chóng sắp xếp danh sách\n;; Ví dụ:\n;; quicksort '(3 1 4 1 5 9 2 6 5 3 5)v\n;; 1 1 2 3 3 4 5 5 5 6 9"
    },
    "prompt_bertscore": {
      "es": "0.9859101539212902",
      "arb": "0.9657098414308042",
      "sw": "0.9657098414308042",
      "tr": "0.9859101539212902",
      "vi": "0.9859101539212902"
    },
    "canonical_solution": "(if (null list)\nnil\n(let ((pivot (first list))\n(rest (rest list)))\n(append (quicksort (remove-if-not #'(lambda (x) (< x pivot)) rest))\n(list pivot)\n(quicksort (remove-if #'(lambda (x) (< x pivot)) rest))))))",
    "instruction": {
      "es": "(defun quicksort (list)\n(if (null list)\nnil\n(let ((pivot (first list))\n(rest (rest list)))\n(append (quicksort (remove-if-not #'(lambda (x) (< x pivot)) rest))\n(list pivot)\n(quicksort (remove-if #'(lambda (x) (< x pivot)) rest))))))\n\nProporcione una descripción concisa en lenguaje natural (docstring) del código Common Lisp en español usando un máximo de 500 caracteres.",
      "arb": "(defun quicksort (list)\n(if (null list)\nnil\n(let ((pivot (first list))\n(rest (rest list)))\n(append (quicksort (remove-if-not #'(lambda (x) (< x pivot)) rest))\n(list pivot)\n(quicksort (remove-if #'(lambda (x) (< x pivot)) rest))))))\n\nيرجى تقديم وصف موجز بلغة طبيعية (docstring) لشفرة Common Lisp باللغة العربية الفصحى باستخدام ما لا يزيد عن 500 حرف.",
      "sw": "(defun quicksort (list)\n(if (null list)\nnil\n(let ((pivot (first list))\n(rest (rest list)))\n(append (quicksort (remove-if-not #'(lambda (x) (< x pivot)) rest))\n(list pivot)\n(quicksort (remove-if #'(lambda (x) (< x pivot)) rest))))))\n\nToa maelezo mafupi ya lugha ya asili (docstring) ya msimbo wa Common Lisp kwa Kiswahili kwa kutumia herufi zisizozidi 500.",
      "tr": "(defun quicksort (list)\n(if (null list)\nnil\n(let ((pivot (first list))\n(rest (rest list)))\n(append (quicksort (remove-if-not #'(lambda (x) (< x pivot)) rest))\n(list pivot)\n(quicksort (remove-if #'(lambda (x) (< x pivot)) rest))))))\n\nAşağıdaki Common Lisp kodunun işlevini açıklayan kısa bir doğal dil açıklaması (docstring) sağlayın. Açıklama Türkçe olmalı ve en fazla 500 karakter kullanılmalıdır.",
      "vi": "(defun quicksort (list)\n(if (null list)\nnil\n(let ((pivot (first list))\n(rest (rest list)))\n(append (quicksort (remove-if-not #'(lambda (x) (< x pivot)) rest))\n(list pivot)\n(quicksort (remove-if #'(lambda (x) (< x pivot)) rest))))))\n\nCung cấp mô tả ngắn gọn bằng ngôn ngữ tự nhiên (docstring) cho mã Common Lisp bằng tiếng Việt, sử dụng tối đa 500 ký tự."
    },
    "instruction_bertscore": {
      "es": "0.9711352316583911",
      "arb": "0.8950613847650772",
      "sw": "0.9127128722061235",
      "tr": "0.8529761755225482",
      "vi": "0.9283341585226124"
    },
    "level": "",
    "test": "(defun check-quicksort ()\n;; 测试 'quicksort' 函数。\n(assert (equal (quicksort '(3 1 4 1 5 9 2 6 5 3 5)) '(1 1 2 3 3 4 5 5 5 6 9)))\n(assert (equal (quicksort '(5 4 3 2 1)) '(1 2 3 4 5)))\n(assert (equal (quicksort '()) '()))\n(assert (equal (quicksort '(1)) '(1))))\n\n(check-quicksort)",
    "entry_point": "quicksort",
    "signature": "(defun quicksort (list)",
    "docstring": {
      "es": "Ordenar rápidamente la lista  \nEjemplo:  \nquicksort '(3 1 4 1 5 9 2 6 5 3 5)v  \n1 1 2 3 3 4 5 5 5 6 9",
      "arb": "فرز القائمة بسرعة  \nمثال:  \nquicksort '(3 1 4 1 5 9 2 6 5 3 5)  \n1 1 2 3 3 4 5 5 5 6 9",
      "sw": "Panga haraka orodha  \nMfano:  \nquicksort '(3 1 4 1 5 9 2 6 5 3 5)  \n1 1 2 3 3 4 5 5 5 6 9",
      "tr": "Hızlıca listeyi sırala  \nÖrnek:  \nquicksort '(3 1 4 1 5 9 2 6 5 3 5)v  \n1 1 2 3 3 4 5 5 5 6 9",
      "vi": "Nhanh chóng sắp xếp danh sách  \nVí dụ:  \nquicksort '(3 1 4 1 5 9 2 6 5 3 5)v  \n1 1 2 3 3 4 5 5 5 6 9"
    },
    "docstring_bertscore": {
      "es": "0.9831470066907139",
      "arb": "0.9773454105214469",
      "sw": "0.9572060775579385",
      "tr": "1",
      "vi": "1"
    }
  },
  {
    "task_id": "Common Lisp/19",
    "prompt": {
      "es": "(defun enqueue-front (object queue)\n;; Define una función que acepta dos parámetros de entrada, object y queue, y puede insertar el objeto al principio de la queue\n;; Ejemplo:\n;; >>> let ((queue '(2 3 4)) enqueue-front 1 queue\n;; 1 2 3 4",
      "arb": "(defun enqueue-front (object queue)\n;; تعريف دالة تقبل معلمين، object و queue، ويمكنها إدراج الكائن في بداية القائمة\n;; مثال:\n;; >>> let ((queue '(2 3 4)) enqueue-front 1 queue\n;; 1 2 3 4",
      "sw": "(defun enqueue-front (object queue)\n;; Fafanua kazi inayokubali vigezo viwili vya ingizo, object na queue, na inaweza kuingiza object mwanzoni mwa queue\n;; Mfano:\n;; >>> let ((queue '(2 3 4)) enqueue-front 1 queue\n;; 1 2 3 4",
      "tr": "(defun enqueue-front (object queue)\n;; İki giriş parametresi, object ve queue kabul eden ve object'i queue'nun başına ekleyebilen bir fonksiyon tanımlayın\n;; Örnek:\n;; >>> let ((queue '(2 3 4)) enqueue-front 1 queue\n;; 1 2 3 4",
      "vi": "(defun enqueue-front (object queue)\n;; Định nghĩa một hàm chấp nhận hai tham số đầu vào, object và queue, và có thể chèn object vào đầu queue\n;; Ví dụ:\n;; >>> let ((queue '(2 3 4)) enqueue-front 1 queue\n;; 1 2 3 4"
    },
    "prompt_bertscore": {
      "es": "0.993475587874147",
      "arb": "0.9697541546190555",
      "sw": "0.993475587874147",
      "tr": "0.9819429093208804",
      "vi": "0.9830695408421103"
    },
    "canonical_solution": "(cons object queue))",
    "instruction": {
      "es": "(defun enqueue-front (object queue)\n(cons object queue))\n\nProporcione una descripción concisa en lenguaje natural (docstring) del código Common Lisp en español utilizando como máximo 500 caracteres.",
      "arb": "(defun enqueue-front (object queue)\n(cons object queue))\n\nيرجى تقديم وصف موجز بلغة طبيعية (docstring) لشيفرة Common Lisp باللغة العربية الفصحى، بحيث لا يتجاوز 500 حرف.",
      "sw": "(defun enqueue-front (object queue)\n(cons object queue))\n\nToa maelezo mafupi ya lugha asilia (docstring) ya msimbo wa Common Lisp kwa Kiswahili kwa kutumia herufi zisizozidi 500.",
      "tr": "(defun enqueue-front (object queue)\n(cons object queue))\n\nAşağıdaki Common Lisp kodunun işlevini açıklayan kısa bir doğal dil açıklaması (docstring) sağlayın. Açıklama Türkçe olmalı ve en fazla 500 karakter içermelidir.",
      "vi": "(defun enqueue-front (object queue)\n(cons object queue))\n\nCung cấp mô tả ngắn gọn bằng ngôn ngữ tự nhiên (docstring) cho mã Common Lisp bằng tiếng Việt, sử dụng tối đa 500 ký tự."
    },
    "instruction_bertscore": {
      "es": "0.9711352316583911",
      "arb": "0.9060988777784239",
      "sw": "0.9454739741021129",
      "tr": "0.8486478208894169",
      "vi": "0.9119165630085547"
    },
    "level": "",
    "test": "(defun check-enqueue-front ()\n(let ((queue '(2 3 4)))\n(setq queue (enqueue-front 1 queue))\n(assert (equal queue '(1 2 3 4))))\n(let ((queue '()))\n(setq queue (enqueue-front 'a queue))\n(assert (equal queue '(a)))))\n\n(check-enqueue-front)",
    "entry_point": "enqueue-front",
    "signature": "(defun enqueue-front (object queue)",
    "docstring": {
      "es": "Define una función que acepte dos parámetros de entrada, objeto y cola, y pueda insertar el objeto al comienzo de la cola\nEjemplo:\n>>> let ((queue '(2 3 4)) enqueue-front 1 queue\n1 2 3 4",
      "arb": "تعريف دالة تقبل معلمين، الكائن والطابور، ويمكنها إدراج الكائن في بداية الطابور  \nمثال:  \n>>> let ((queue '(2 3 4)) enqueue-front 1 queue  \n1 2 3 4",
      "sw": "Tafsiri kazi ambayo inakubali vigezo viwili vya pembejeo, object na queue, na inaweza kuingiza object mwanzoni mwa queue  \nMfano:  \n>>> let ((queue '(2 3 4)) enqueue-front 1 queue  \n1 2 3 4",
      "tr": "Bir nesne ve kuyruk olmak üzere iki giriş parametresi kabul eden ve nesneyi kuyruğun başına ekleyebilen bir fonksiyon tanımlayın.\nÖrnek:\n>>> let ((queue '(2 3 4)) enqueue-front 1 queue\n1 2 3 4",
      "vi": "Định nghĩa một hàm chấp nhận hai tham số đầu vào, object và queue, và có thể chèn object vào đầu queue  \nVí dụ:  \n>>> let ((queue '(2 3 4)) enqueue-front 1 queue  \n1 2 3 4"
    },
    "docstring_bertscore": {
      "es": "0.9918847571524386",
      "arb": "0.9702670182628876",
      "sw": "0.9500974934814619",
      "tr": "0.9452491245107814",
      "vi": "0.9787451588165997"
    }
  },
  {
    "task_id": "Common Lisp/20",
    "prompt": {
      "es": "(defun move-first-instance-to-front (object queue)\n;; Define una función que toma dos parámetros de entrada, object y queue, y puede mover destructivamente la primera instancia de object (equivalente a eql) al comienzo de la queue\n;; Ejemplo:\n;; >>> move-first-instance-to-front 'b '(a b c d)\n;; b a c d",
      "arb": "(defun move-first-instance-to-front (object queue)\n;; تعريف دالة تأخذ مدخلين، الكائن والطابور، ويمكنها نقل أول مثيل للكائن (بما يعادل eql) بشكل مدمر إلى بداية الطابور\n;; مثال:\n;; >>> move-first-instance-to-front 'b '(a b c d)\n;; b a c d",
      "sw": "(defun move-first-instance-to-front (object queue)\n;; Fafanua kazi inayochukua vigezo viwili vya ingizo, object na queue, na inaweza kusogeza kwa uharibifu tukio la kwanza la object (linalolingana na eql) hadi mwanzo wa queue\n;; Mfano:\n;; >>> move-first-instance-to-front 'b '(a b c d)\n;; b a c d",
      "tr": "(defun move-first-instance-to-front (object queue)\n;; İki giriş parametresi alan bir fonksiyon tanımlayın: object ve queue, ve object'in (eql eşdeğerli) ilk örneğini sıranın başına yıkıcı bir şekilde taşıyabilir\n;; Örnek:\n;; >>> move-first-instance-to-front 'b '(a b c d)\n;; b a c d",
      "vi": "(defun move-first-instance-to-front (object queue)\n;; Định nghĩa một hàm nhận hai tham số đầu vào, object và queue, và có thể di chuyển phá hủy trường hợp đầu tiên của object (tương đương eql) lên đầu hàng đợi\n;; Ví dụ:\n;; >>> move-first-instance-to-front 'b '(a b c d)\n;; b a c d"
    },
    "prompt_bertscore": {
      "es": "0.968287666515875",
      "arb": "0.9648583129873076",
      "sw": "0.9669949799960998",
      "tr": "0.971607376074111",
      "vi": "0.9659636910577667"
    },
    "canonical_solution": "(cond ((null queue) nil) \n((eql (first queue) object) queue) \n(t \n(let ((prev nil)\n(current queue))\n(loop while (and current (not (eql (first current) object)))\ndo (setq prev current)\n(setq current (rest current)))\n(if current \n(progn\n(when prev (setf (rest prev) (rest current))) \n(cons object (if prev queue (rest current)))) \nqueue)))))",
    "instruction": {
      "es": "(defun move-first-instance-to-front (object queue)\n(cond ((null queue) nil) \n((eql (first queue) object) queue) \n(t \n(let ((prev nil)\n(current queue))\n(loop while (and current (not (eql (first current) object)))\ndo (setq prev current)\n(setq current (rest current)))\n(if current \n(progn\n(when prev (setf (rest prev) (rest current))) \n(cons object (if prev queue (rest current)))) \nqueue)))))\n\nProporcione una descripción concisa en lenguaje natural (docstring) del código Common Lisp en español utilizando un máximo de 500 caracteres.",
      "arb": "(defun move-first-instance-to-front (object queue)\n(cond ((null queue) nil) \n((eql (first queue) object) queue) \n(t \n(let ((prev nil)\n(current queue))\n(loop while (and current (not (eql (first current) object)))\ndo (setq prev current)\n(setq current (rest current)))\n(if current \n(progn\n(when prev (setf (rest prev) (rest current))) \n(cons object (if prev queue (rest current)))) \nqueue)))))\n\nيرجى تقديم وصف موجز بلغة طبيعية (docstring) لكود Common Lisp باللغة العربية الفصحى باستخدام ما لا يزيد عن 500 حرف.",
      "sw": "(defun move-first-instance-to-front (object queue)\n(cond ((null queue) nil) \n((eql (first queue) object) queue) \n(t \n(let ((prev nil)\n(current queue))\n(loop while (and current (not (eql (first current) object)))\ndo (setq prev current)\n(setq current (rest current)))\n(if current \n(progn\n(when prev (setf (rest prev) (rest current))) \n(cons object (if prev queue (rest current)))) \nqueue)))))\n\nToa maelezo mafupi ya lugha asilia (docstring) ya msimbo wa Common Lisp kwa Kiswahili kwa kutumia herufi zisizozidi 500.",
      "tr": "(defun move-first-instance-to-front (object queue)\n(cond ((null queue) nil) \n((eql (first queue) object) queue) \n(t \n(let ((prev nil)\n(current queue))\n(loop while (and current (not (eql (first current) object)))\ndo (setq prev current)\n(setq current (rest current)))\n(if current \n(progn\n(when prev (setf (rest prev) (rest current))) \n(cons object (if prev queue (rest current)))) \nqueue)))))\n\nAşağıdaki Common Lisp kodunun işlevini açıklayan kısa bir doğal dil açıklaması (docstring) sağlayın. Açıklama, Türkçe olarak en fazla 500 karakter içermelidir.",
      "vi": "(defun move-first-instance-to-front (object queue)\n(cond ((null queue) nil) \n((eql (first queue) object) queue) \n(t \n(let ((prev nil)\n(current queue))\n(loop while (and current (not (eql (first current) object)))\ndo (setq prev current)\n(setq current (rest current)))\n(if current \n(progn\n(when prev (setf (rest prev) (rest current))) \n(cons object (if prev queue (rest current)))) \nqueue)))))\n\nCung cấp mô tả ngắn gọn bằng ngôn ngữ tự nhiên (docstring) cho mã Common Lisp bằng tiếng Việt, sử dụng tối đa 500 ký tự."
    },
    "instruction_bertscore": {
      "es": "0.9711352316583911",
      "arb": "0.904243868649939",
      "sw": "0.9372683544311806",
      "tr": "0.8541028070437781",
      "vi": "0.9119165630085547"
    },
    "level": "",
    "test": "(defun check-move-first-instance-to-front ()\n(assert (equal (move-first-instance-to-front 'b '(a b c d)) '(b a c d)))\n(assert (equal (move-first-instance-to-front 'a '(a b c d)) '(a b c d)))\n(assert (equal (move-first-instance-to-front 'e '(a b c d)) '(a b c d)))\n(assert (equal (move-first-instance-to-front 'd '(a b c d)) '(d a b c))))\n\n(check-move-first-instance-to-front)",
    "entry_point": "move-first-instance-to-front",
    "signature": "(defun move-first-instance-to-front (object queue)",
    "docstring": {
      "es": "Define una función que tome dos parámetros de entrada, objeto y cola, y pueda mover destructivamente la primera instancia del objeto (equivalente a eql) al comienzo de la cola\n\nEjemplo:\n>>> move-first-instance-to-front 'b '(a b c d)\nb a c d",
      "arb": "تعريف دالة تأخذ مدخلين، الكائن والطابور، ويمكنها نقل أول مثيل للكائن (بما يعادل eql) بشكل مدمر إلى بداية الطابور\nمثال:\n>>> move-first-instance-to-front 'b '(a b c d)\nb a c d",
      "sw": "Tafsiri kazi ifuatayo kwa kutumia maagizo yaliyotolewa:\n\nFafanua kazi inayochukua vigezo viwili vya ingizo, object na queue, na inaweza kuhamisha kwa uharibifu mfano wa kwanza wa object (sawa na eql) hadi mwanzo wa queue.\n\nMfano:\n>>> move-first-instance-to-front 'b '(a b c d)\nb a c d",
      "tr": "Bir fonksiyon tanımlayın, bu fonksiyon iki giriş parametresi alır: nesne ve kuyruk. Fonksiyon, nesnenin (eşdeğer olarak eql) ilk örneğini yıkıcı bir şekilde kuyruğun başına taşıyabilir.\nÖrnek:\n>>> move-first-instance-to-front 'b '(a b c d)\nb a c d",
      "vi": "Định nghĩa một hàm nhận hai tham số đầu vào, object và queue, và có thể di chuyển phá hủy phiên bản đầu tiên của object (tương đương eql) đến đầu hàng đợi.  \nVí dụ:  \n>>> move-first-instance-to-front 'b '(a b c d)  \nb a c d"
    },
    "docstring_bertscore": {
      "es": "0.9538877584123697",
      "arb": "0.9374979711516569",
      "sw": "0.943151786317434",
      "tr": "0.9151983341640131",
      "vi": "0.9362301134295112"
    }
  },
  {
    "task_id": "Common Lisp/21",
    "prompt": {
      "es": "(defun find-substring-index (haystack needle)\n;; Encuentra la primera ocurrencia de la subcadena 'needle' dentro de la cadena 'haystack'.\n;; Devuelve el índice del primer carácter de la primera ocurrencia de 'needle'.\n;; Si 'needle' no es parte de 'haystack', devuelve -1.\n;; Ejemplo:\n;; (find-substring-index \"apple pie\" \"pie\") ;; Devuelve 6\n;; (find-substring-index \"hello world\" \"bye\") ;; Devuelve -1",
      "arb": "(defun find-substring-index (haystack needle)\n;; يجد أول ظهور للجزء الفرعي 'needle' داخل السلسلة 'haystack'.\n;; يعيد فهرس الحرف الأول من أول ظهور لـ 'needle'.\n;; إذا لم يكن 'needle' جزءًا من 'haystack'، يعيد -1.\n;; مثال:\n;; (find-substring-index \"apple pie\" \"pie\") ;; يعيد 6\n;; (find-substring-index \"hello world\" \"bye\") ;; يعيد -1",
      "sw": "(defun find-substring-index (haystack needle)\n;; Inapata tukio la kwanza la sehemu ndogo ya 'needle' ndani ya kamba 'haystack'.\n;; Inarudisha faharasa ya herufi ya kwanza ya tukio la kwanza la 'needle'.\n;; Ikiwa 'needle' si sehemu ya 'haystack', inarudisha -1.\n;; Mfano:\n;; (find-substring-index \"apple pie\" \"pie\") ;; Inarudisha 6\n;; (find-substring-index \"hello world\" \"bye\") ;; Inarudisha -1",
      "tr": "(defun find-substring-index (haystack needle)\n;; 'needle' alt dizisinin 'haystack' dizesi içinde ilk geçtiği yeri bulur.\n;; 'needle'in ilk geçtiği yerin ilk karakterinin indeksini döndürür.\n;; Eğer 'needle', 'haystack'in bir parçası değilse, -1 döndürür.\n;; Örnek:\n;; (find-substring-index \"apple pie\" \"pie\") ;; 6 döndürür\n;; (find-substring-index \"hello world\" \"bye\") ;; -1 döndürür",
      "vi": "(defun find-substring-index (haystack needle)\n;; Tìm vị trí xuất hiện đầu tiên của chuỗi con 'needle' trong chuỗi 'haystack'.\n;; Trả về chỉ số của ký tự đầu tiên của lần xuất hiện đầu tiên của 'needle'.\n;; Nếu 'needle' không phải là một phần của 'haystack', trả về -1.\n;; Ví dụ:\n;; (find-substring-index \"apple pie\" \"pie\") ;; Trả về 6\n;; (find-substring-index \"hello world\" \"bye\") ;; Trả về -1"
    },
    "prompt_bertscore": {
      "es": "0.9965895163576309",
      "arb": "0.9977580588892592",
      "sw": "1",
      "tr": "0.983045109305243",
      "vi": "0.9855321603061808"
    },
    "canonical_solution": "(let ((hay-len (length haystack))\n(need-len (length needle)))\n(if (zerop need-len)\n0\n(if (> need-len hay-len)\n-1\n(loop for i below (1+ (- hay-len need-len)) ;; Adjusted loop condition\nwhen (string= (subseq haystack i (min (+ i need-len) hay-len)) needle) ;; Ensure subseq does not exceed bounds\nreturn i\nfinally (return -1))))))",
    "instruction": {
      "es": "(defun find-substring-index (haystack needle)\n(let ((hay-len (length haystack))\n(need-len (length needle)))\n(if (zerop need-len)\n0\n(if (> need-len hay-len)\n-1\n(loop for i below (1+ (- hay-len need-len)) ;; Adjusted loop condition\nwhen (string= (subseq haystack i (min (+ i need-len) hay-len)) needle) ;; Ensure subseq does not exceed bounds\nreturn i\nfinally (return -1))))))\n\nProporcione una descripción concisa en lenguaje natural (docstring) del código Common Lisp en español utilizando como máximo 500 caracteres.",
      "arb": "(defun find-substring-index (haystack needle)\n(let ((hay-len (length haystack))\n(need-len (length needle)))\n(if (zerop need-len)\n0\n(if (> need-len hay-len)\n-1\n(loop for i below (1+ (- hay-len need-len)) ;; Adjusted loop condition\nwhen (string= (subseq haystack i (min (+ i need-len) hay-len)) needle) ;; Ensure subseq does not exceed bounds\nreturn i\nfinally (return -1))))))\n\nيرجى تقديم وصف موجز بلغة طبيعية (docstring) لشفرة Common Lisp باللغة العربية الفصحى، بحيث لا يتجاوز 500 حرف.",
      "sw": "(defun find-substring-index (haystack needle)\n(let ((hay-len (length haystack))\n(need-len (length needle)))\n(if (zerop need-len)\n0\n(if (> need-len hay-len)\n-1\n(loop for i below (1+ (- hay-len need-len)) ;; Adjusted loop condition\nwhen (string= (subseq haystack i (min (+ i need-len) hay-len)) needle) ;; Ensure subseq does not exceed bounds\nreturn i\nfinally (return -1))))))\n\nToa maelezo mafupi ya lugha ya asili (docstring) ya msimbo wa Common Lisp kwa Kiswahili kwa kutumia herufi zisizozidi 500.",
      "tr": "(defun find-substring-index (haystack needle)\n(let ((hay-len (length haystack))\n(need-len (length needle)))\n(if (zerop need-len)\n0\n(if (> need-len hay-len)\n-1\n(loop for i below (1+ (- hay-len need-len)) ;; Adjusted loop condition\nwhen (string= (subseq haystack i (min (+ i need-len) hay-len)) needle) ;; Ensure subseq does not exceed bounds\nreturn i\nfinally (return -1))))))\n\nAşağıdaki Common Lisp kodunun doğal dilde kısa bir açıklamasını (docstring) Türkçe olarak en fazla 500 karakter kullanarak sağlayın.",
      "vi": "(defun find-substring-index (haystack needle)\n(let ((hay-len (length haystack))\n(need-len (length needle)))\n(if (zerop need-len)\n0\n(if (> need-len hay-len)\n-1\n(loop for i below (1+ (- hay-len need-len)) ;; Adjusted loop condition\nwhen (string= (subseq haystack i (min (+ i need-len) hay-len)) needle) ;; Ensure subseq does not exceed bounds\nreturn i\nfinally (return -1))))))\n\nCung cấp mô tả ngắn gọn bằng ngôn ngữ tự nhiên (docstring) cho mã Common Lisp bằng tiếng Việt, sử dụng tối đa 500 ký tự."
    },
    "instruction_bertscore": {
      "es": "0.9711352316583911",
      "arb": "0.8931430125450422",
      "sw": "0.9372683544311806",
      "tr": "0.8482843272921231",
      "vi": "0.9119165630085547"
    },
    "level": "",
    "test": "(defun test-find-substring-index ()\n(assert (equal (find-substring-index \"apple pie\" \"pie\") 6))\n(assert (equal (find-substring-index \"hello world\" \"bye\") -1))\n(assert (equal (find-substring-index \"common lisp\" \"lisp\") 7))\n(assert (equal (find-substring-index \"quick brown fox\" \"brown\") 6))\n(assert (equal (find-substring-index \"abcdef\" \"de\") 3))\n(assert (equal (find-substring-index \"abcdef\" \"xyz\") -1)))\n\n(test-find-substring-index)",
    "entry_point": "find-substring-index",
    "signature": "(defun find-substring-index (haystack needle)",
    "docstring": {
      "es": "Encuentra la primera aparición de la subcadena 'needle' dentro de la cadena 'haystack'.  \nDevuelve el índice del primer carácter de la primera aparición de 'needle'.  \nSi 'needle' no es parte de 'haystack', devuelve -1.  \nEjemplo:  \n(find-substring-index \"apple pie\" \"pie\") Devuelve 6  \n(find-substring-index \"hello world\" \"bye\") Devuelve -1  ",
      "arb": "يعثر على أول ظهور للسلسلة الفرعية 'needle' داخل السلسلة 'haystack'.\nيعيد فهرس الحرف الأول من أول ظهور لـ 'needle'.\nإذا لم تكن 'needle' جزءًا من 'haystack'، يعيد -1.\nمثال:\n(find-substring-index \"apple pie\" \"pie\") يعيد 6\n(find-substring-index \"hello world\" \"bye\") يعيد -1",
      "sw": "Inapata tukio la kwanza la sehemu ndogo 'needle' ndani ya kamba 'haystack'.\nInarudisha faharasa ya herufi ya kwanza ya tukio la kwanza la 'needle'.\nIkiwa 'needle' si sehemu ya 'haystack', inarudisha -1.\nMfano:\n(find-substring-index \"apple pie\" \"pie\") Inarudisha 6\n(find-substring-index \"hello world\" \"bye\") Inarudisha -1",
      "tr": " Dizgi 'haystack' içinde 'needle' alt dizgisinin ilk geçtiği yeri bulur.\n \n'Needle' alt dizgisinin ilk geçtiği yerdeki ilk karakterin indeksini döndürür.\n \nEğer 'needle', 'haystack' dizgisinin bir parçası değilse, -1 döndürür.\n  \nÖrnek:\n\n(find-substring-index \"apple pie\" \"pie\") 6 döndürür  \n(find-substring-index \"hello world\" \"bye\") -1 döndürür",
      "vi": "Tìm lần xuất hiện đầu tiên của chuỗi con 'needle' trong chuỗi 'haystack'.  \nTrả về chỉ số của ký tự đầu tiên của lần xuất hiện đầu tiên của 'needle'.  \nNếu 'needle' không phải là một phần của 'haystack', trả về -1.  \nVí dụ:  \n(find-substring-index \"apple pie\" \"pie\") Trả về 6  \n(find-substring-index \"hello world\" \"bye\") Trả về -1  "
    },
    "docstring_bertscore": {
      "es": "0.9764476011991692",
      "arb": "0.9896001105097754",
      "sw": "0.9940323488321878",
      "tr": "0.8806579013147133",
      "vi": "0.9786720628363789"
    }
  },
  {
    "task_id": "Common Lisp/22",
    "prompt": {
      "es": "(defun min-n-for-sum-greater-than-k (k)\n;; Calcula el entero más pequeño n tal que la suma S_n = 1 + 1/2 + 1/3 + ... + 1/n\n;; es mayor que un entero dado k.\n;; La función devuelve el menor n tal.\n;; Ejemplo:\n;; (min-n-for-sum-greater-than-k 2) ;; Devuelve 4\n;; (min-n-for-sum-greater-than-k 3) ;; Devuelve 11",
      "arb": "(defun min-n-for-sum-greater-than-k (k)\n;; يحسب أصغر عدد صحيح n بحيث يكون المجموع S_n = 1 + 1/2 + 1/3 + ... + 1/n\n;; أكبر من عدد صحيح معين k.\n;; تُرجع الدالة أصغر قيمة n تحقق ذلك.\n;; مثال:\n;; (min-n-for-sum-greater-than-k 2) ;; يُرجع 4\n;; (min-n-for-sum-greater-than-k 3) ;; يُرجع 11",
      "sw": "(defun min-n-for-sum-greater-than-k (k)\n;; Inahesabu namba ndogo kabisa n ambapo jumla S_n = 1 + 1/2 + 1/3 + ... + 1/n\n;; ni kubwa kuliko namba kamili k iliyotolewa.\n;; Kazi inarudisha n ndogo zaidi kama hiyo.\n;; Mfano:\n;; (min-n-for-sum-greater-than-k 2) ;; Inarudisha 4\n;; (min-n-for-sum-greater-than-k 3) ;; Inarudisha 11",
      "tr": "(defun min-n-for-sum-greater-than-k (k)\n;; S_n = 1 + 1/2 + 1/3 + ... + 1/n toplamının\n;; verilen bir tamsayı k'dan büyük olması için en küçük n tamsayısını hesaplar.\n;; Fonksiyon, bu koşulu sağlayan en küçük n'i döndürür.\n;; Örnek:\n;; (min-n-for-sum-greater-than-k 2) ;; 4 döndürür\n;; (min-n-for-sum-greater-than-k 3) ;; 11 döndürür",
      "vi": "(defun min-n-for-sum-greater-than-k (k)\n;; Tính toán số nguyên nhỏ nhất n sao cho tổng S_n = 1 + 1/2 + 1/3 + ... + 1/n\n;; lớn hơn một số nguyên cho trước k.\n;; Hàm trả về n nhỏ nhất như vậy.\n;; Ví dụ:\n;; (min-n-for-sum-greater-than-k 2) ;; Trả về 4\n;; (min-n-for-sum-greater-than-k 3) ;; Trả về 11"
    },
    "prompt_bertscore": {
      "es": "0.999999801369619",
      "arb": "0.9731376245296038",
      "sw": "0.9797816121448397",
      "tr": "0.9661496090944154",
      "vi": "0.9990000946618703"
    },
    "canonical_solution": "(let ((sum 0.0) (n 0))\n(loop do\n(incf n)\n(incf sum (/ 1 n))\n(when (> sum k)\n(return n)))))",
    "instruction": {
      "es": "(defun min-n-for-sum-greater-than-k (k)\n(let ((sum 0.0) (n 0))\n(loop do\n(incf n)\n(incf sum (/ 1 n))\n(when (> sum k)\n(return n)))))\n\nProporcione una descripción concisa en lenguaje natural (docstring) del código Common Lisp en español utilizando un máximo de 500 caracteres.",
      "arb": "(defun min-n-for-sum-greater-than-k (k)\n(let ((sum 0.0) (n 0))\n(loop do\n(incf n)\n(incf sum (/ 1 n))\n(when (> sum k)\n(return n)))))\n\nيرجى تقديم وصف موجز بلغة طبيعية (docstring) لشفرة Common Lisp باللغة العربية الفصحى، باستخدام ما لا يزيد عن 500 حرف.",
      "sw": "(defun min-n-for-sum-greater-than-k (k)\n(let ((sum 0.0) (n 0))\n(loop do\n(incf n)\n(incf sum (/ 1 n))\n(when (> sum k)\n(return n)))))\n\nToa maelezo mafupi ya lugha ya asili (docstring) ya msimbo wa Common Lisp kwa Kiswahili kwa kutumia herufi zisizozidi 500.",
      "tr": "(defun min-n-for-sum-greater-than-k (k)\n(let ((sum 0.0) (n 0))\n(loop do\n(incf n)\n(incf sum (/ 1 n))\n(when (> sum k)\n(return n)))))\n\nAşağıdaki Common Lisp kodunun doğal dilde kısa bir açıklamasını (docstring) en fazla 500 karakter kullanarak Türkçe olarak sağlayın.",
      "vi": "(defun min-n-for-sum-greater-than-k (k)\n(let ((sum 0.0) (n 0))\n(loop do\n(incf n)\n(incf sum (/ 1 n))\n(when (> sum k)\n(return n)))))\n\nCung cấp mô tả ngắn gọn bằng ngôn ngữ tự nhiên (docstring) cho mã Common Lisp bằng tiếng Việt, sử dụng tối đa 500 ký tự."
    },
    "instruction_bertscore": {
      "es": "0.9711352316583911",
      "arb": "0.903298189405832",
      "sw": "0.9127128722061235",
      "tr": "0.8431249031447419",
      "vi": "0.9119165630085547"
    },
    "level": "",
    "test": "(defun test-min-n-for-sum-greater-than-k ()\n(assert (equal (min-n-for-sum-greater-than-k 1) 2))\n(assert (equal (min-n-for-sum-greater-than-k 2) 4))\n(assert (equal (min-n-for-sum-greater-than-k 3) 11))\n(assert (equal (min-n-for-sum-greater-than-k 4) 31))\n(assert (equal (min-n-for-sum-greater-than-k 5) 83))\n(assert (equal (min-n-for-sum-greater-than-k 0) 1)))\n\n(test-min-n-for-sum-greater-than-k)",
    "entry_point": "min-n-for-sum-greater-than-k",
    "signature": "(defun min-n-for-sum-greater-than-k (k)",
    "docstring": {
      "es": "Calcula el entero más pequeño n tal que la suma S_n = 1 + 1/2 + 1/3 + ... + 1/n\nes mayor que un entero dado k.\nLa función devuelve el menor n tal.\nEjemplo:\n(min-n-for-sum-greater-than-k 2) Devuelve 4\n(min-n-for-sum-greater-than-k 3) Devuelve 11",
      "arb": "يحسب أصغر عدد صحيح n بحيث يكون المجموع S_n = 1 + 1/2 + 1/3 + ... + 1/n أكبر من عدد صحيح معين k. تعيد الدالة أصغر n من هذا القبيل.\nمثال:\n(min-n-for-sum-greater-than-k 2) يعيد 4\n(min-n-for-sum-greater-than-k 3) يعيد 11",
      "sw": "Hesabu nambari ndogo zaidi n kama jumla S_n = 1 + 1/2 + 1/3 + ... + 1/n ni kubwa kuliko nambari kamili k uliyopewa. Kazi inarudisha n ndogo zaidi kama hiyo. Mfano: (min-n-for-sum-greater-than-k 2) Inarudisha 4 (min-n-for-sum-greater-than-k 3) Inarudisha 11",
      "tr": "Verilen bir tamsayı k için, toplam S_n = 1 + 1/2 + 1/3 + ... + 1/n\nbu k'dan büyük olacak şekilde en küçük n tamsayısını hesaplar.\nFonksiyon, bu koşulu sağlayan en küçük n değerini döndürür.\nÖrnek:\n(min-n-for-sum-greater-than-k 2) 4 döndürür\n(min-n-for-sum-greater-than-k 3) 11 döndürür",
      "vi": "Tính toán số nguyên nhỏ nhất n sao cho tổng S_n = 1 + 1/2 + 1/3 + ... + 1/n lớn hơn một số nguyên cho trước k. Hàm trả về n nhỏ nhất như vậy. \n\nVí dụ:\n(min-n-for-sum-greater-than-k 2) Trả về 4\n(min-n-for-sum-greater-than-k 3) Trả về 11"
    },
    "docstring_bertscore": {
      "es": "0.9977421684587764",
      "arb": "0.9696498736690122",
      "sw": "0.990190440002211",
      "tr": "0.924956250262733",
      "vi": "0.9977421684587764"
    }
  },
  {
    "task_id": "Common Lisp/23",
    "prompt": {
      "es": "(defun count-reachable-apples (apple-heights fengfeng-height)\n;; Cuenta el número de manzanas que Fengfeng puede alcanzar.\n;; 'apple-heights' es una lista de enteros que representa las alturas de las manzanas.\n;; 'fengfeng-height' es un entero que representa la altura máxima que Fengfeng puede alcanzar.\n;; Fengfeng puede alcanzar manzanas en o por debajo de su altura máxima.\n;; Ejemplo:\n;; (count-reachable-apples '(120 130 140 150 160 170 180 190 200 210) 150) ;; Devuelve 4\n;; (count-reachable-apples '(100 101 102 103 104 105 106 107 108 109) 110) ;; Devuelve 10",
      "arb": "(defun count-reachable-apples (apple-heights fengfeng-height)\n;; يحسب عدد التفاح الذي يمكن لفينغفينغ الوصول إليه.\n;; 'apple-heights' هو قائمة من الأعداد الصحيحة التي تمثل ارتفاعات التفاح.\n;; 'fengfeng-height' هو عدد صحيح يمثل أقصى ارتفاع يمكن لفينغفينغ الوصول إليه.\n;; يمكن لفينغفينغ الوصول إلى التفاح عند أو تحت أقصى ارتفاع لها.\n;; مثال:\n;; (count-reachable-apples '(120 130 140 150 160 170 180 190 200 210) 150) ;; يعيد 4\n;; (count-reachable-apples '(100 101 102 103 104 105 106 107 108 109) 110) ;; يعيد 10",
      "sw": "(defun count-reachable-apples (apple-heights fengfeng-height)\n;; Inahesabu idadi ya maapulo ambayo Fengfeng anaweza kuyafikia.\n;; 'apple-heights' ni orodha ya namba nzima inayowakilisha urefu wa maapulo.\n;; 'fengfeng-height' ni namba nzima inayowakilisha urefu wa juu kabisa ambao Fengfeng anaweza kufikia.\n;; Fengfeng anaweza kufikia maapulo yaliyo kwenye au chini ya urefu wake wa juu kabisa.\n;; Mfano:\n;; (count-reachable-apples '(120 130 140 150 160 170 180 190 200 210) 150) ;; Inarejesha 4\n;; (count-reachable-apples '(100 101 102 103 104 105 106 107 108 109) 110) ;; Inarejesha 10",
      "tr": "(defun count-reachable-apples (apple-heights fengfeng-height)\n;; Fengfeng'in ulaşabileceği elma sayısını sayar.\n;; 'apple-heights', elmaların yüksekliklerini temsil eden bir tamsayı listesidir.\n;; 'fengfeng-height', Fengfeng'in maksimum ulaşma yüksekliğini temsil eden bir tamsayıdır.\n;; Fengfeng, maksimum yüksekliğine eşit veya daha düşük yükseklikteki elmalara ulaşabilir.\n;; Örnek:\n;; (count-reachable-apples '(120 130 140 150 160 170 180 190 200 210) 150) ;; 4 döndürür\n;; (count-reachable-apples '(100 101 102 103 104 105 106 107 108 109) 110) ;; 10 döndürür",
      "vi": "(defun count-reachable-apples (apple-heights fengfeng-height)\n;; Đếm số lượng táo mà Fengfeng có thể với tới.\n;; 'apple-heights' là một danh sách các số nguyên đại diện cho độ cao của các quả táo.\n;; 'fengfeng-height' là một số nguyên đại diện cho chiều cao tối đa mà Fengfeng có thể với tới.\n;; Fengfeng có thể với tới các quả táo ở độ cao bằng hoặc thấp hơn chiều cao tối đa của cô ấy.\n;; Ví dụ:\n;; (count-reachable-apples '(120 130 140 150 160 170 180 190 200 210) 150) ;; Trả về 4\n;; (count-reachable-apples '(100 101 102 103 104 105 106 107 108 109) 110) ;; Trả về 10"
    },
    "prompt_bertscore": {
      "es": "0.981877758555901",
      "arb": "0.9742557149444492",
      "sw": "0.9751364420539579",
      "tr": "0.9746623113344276",
      "vi": "0.970149627707696"
    },
    "canonical_solution": "(count-if (lambda (height) (<= height fengfeng-height)) apple-heights))",
    "instruction": {
      "es": "(defun count-reachable-apples (apple-heights fengfeng-height)\n(count-if (lambda (height) (<= height fengfeng-height)) apple-heights))\n\nProporcione una descripción concisa en lenguaje natural (docstring) del código Common Lisp en español utilizando un máximo de 500 caracteres.",
      "arb": "(defun count-reachable-apples (apple-heights fengfeng-height)\n(count-if (lambda (height) (<= height fengfeng-height)) apple-heights))\n\nيرجى تقديم وصف موجز بلغة طبيعية (docstring) لشيفرة Common Lisp باللغة العربية الفصحى، بحيث لا يتجاوز 500 حرف.",
      "sw": "(defun count-reachable-apples (apple-heights fengfeng-height)\n(count-if (lambda (height) (<= height fengfeng-height)) apple-heights))\n\nToa maelezo mafupi ya lugha ya asili (docstring) ya msimbo wa Common Lisp kwa Kiswahili kwa kutumia herufi zisizozidi 500.",
      "tr": "(defun count-reachable-apples (apple-heights fengfeng-height)\n(count-if (lambda (height) (<= height fengfeng-height)) apple-heights))\n\nAşağıdaki Common Lisp kodunun işlevini açıklayan, en fazla 500 karakter uzunluğunda, kısa ve öz bir doğal dil açıklaması (docstring) sağlayın.",
      "vi": "(defun count-reachable-apples (apple-heights fengfeng-height)\n(count-if (lambda (height) (<= height fengfeng-height)) apple-heights))\n\nCung cấp mô tả ngắn gọn bằng ngôn ngữ tự nhiên (docstring) cho mã Common Lisp bằng tiếng Việt, sử dụng tối đa 500 ký tự."
    },
    "instruction_bertscore": {
      "es": "0.9711352316583911",
      "arb": "0.9060988777784239",
      "sw": "0.8914782913215888",
      "tr": "0.8478656144489015",
      "vi": "0.9233350290927262"
    },
    "level": "",
    "test": "(defun test-count-reachable-apples ()\n(assert (equal (count-reachable-apples '(120 130 140 150 160 170 180 190 200 210) 150) 4))\n(assert (equal (count-reachable-apples '(100 101 102 103 104 105 106 107 108 109) 110) 10))\n(assert (equal (count-reachable-apples '(110 115 120 125 130 135 140 145 150 155) 120) 3))\n(assert (equal (count-reachable-apples '(200 199 198 197 196 195 194 193 192 191) 190) 0))\n(assert (equal (count-reachable-apples '(101 102 103 104 105 106 107 108 109 110) 105) 5)))\n\n(test-count-reachable-apples)",
    "entry_point": "count-reachable-apples",
    "signature": "(defun count-reachable-apples (apple-heights fengfeng-height)",
    "docstring": {
      "es": "Cuenta el número de manzanas que Fengfeng puede alcanzar.\n'apple-heights' es una lista de enteros que representa las alturas de las manzanas.\n'fengfeng-height' es un entero que representa la altura máxima que Fengfeng puede alcanzar.\nFengfeng puede alcanzar manzanas a su altura máxima o por debajo de esta.\nEjemplo:\n(count-reachable-apples '(120 130 140 150 160 170 180 190 200 210) 150) Devuelve 4\n(count-reachable-apples '(100 101 102 103 104 105 106 107 108 109) 110) Devuelve 10",
      "arb": "يحسب عدد التفاح الذي يمكن لـ Fengfeng الوصول إليه.\n'apple-heights' هي قائمة من الأعداد الصحيحة التي تمثل ارتفاعات التفاح.\n'fengfeng-height' هو عدد صحيح يمثل أقصى ارتفاع يمكن لـ Fengfeng الوصول إليه.\nيمكن لـ Fengfeng الوصول إلى التفاح الذي يكون عند أو أقل من ارتفاعها الأقصى.\nمثال:\n(count-reachable-apples '(120 130 140 150 160 170 180 190 200 210) 150) يعيد 4\n(count-reachable-apples '(100 101 102 103 104 105 106 107 108 109) 110) يعيد 10",
      "sw": "Hesabu idadi ya maapulo ambayo Fengfeng anaweza kufikia. \n'apple-heights' ni orodha ya nambari za mzima zinazoonyesha urefu wa maapulo. \n'fengfeng-height' ni nambari inayowakilisha urefu wa juu zaidi ambao Fengfeng anaweza kufikia. \nFengfeng anaweza kufikia maapulo yaliyo kwenye au chini ya urefu wake wa juu zaidi. \nMfano: \n(count-reachable-apples '(120 130 140 150 160 170 180 190 200 210) 150) Inarudisha 4 \n(count-reachable-apples '(100 101 102 103 104 105 106 107 108 109) 110) Inarudisha 10",
      "tr": "Fengfeng'in ulaşabileceği elma sayısını sayar.\n'apple-heights', elmaların yüksekliklerini temsil eden bir tamsayı listesidir.\n'fengfeng-height', Fengfeng'in maksimum ulaşma yüksekliğini temsil eden bir tamsayıdır.\nFengfeng, maksimum yüksekliğine eşit veya daha düşük yükseklikteki elmalara ulaşabilir.\nÖrnek:\n(count-reachable-apples '(120 130 140 150 160 170 180 190 200 210) 150) 4 döndürür\n(count-reachable-apples '(100 101 102 103 104 105 106 107 108 109) 110) 10 döndürür",
      "vi": "Đếm số lượng táo mà Fengfeng có thể với tới.\n'apple-heights' là một danh sách các số nguyên đại diện cho chiều cao của các quả táo.\n'fengfeng-height' là một số nguyên đại diện cho chiều cao tối đa mà Fengfeng có thể với tới.\nFengfeng có thể với tới các quả táo ở chiều cao bằng hoặc thấp hơn chiều cao tối đa của cô ấy.\nVí dụ:\n(count-reachable-apples '(120 130 140 150 160 170 180 190 200 210) 150) Trả về 4\n(count-reachable-apples '(100 101 102 103 104 105 106 107 108 109) 110) Trả về 10"
    },
    "docstring_bertscore": {
      "es": "0.9639207775888229",
      "arb": "0.9627808378320637",
      "sw": "0.9478305249427108",
      "tr": "0.9597189505084109",
      "vi": "0.9609458903720633"
    }
  },
  {
    "task_id": "Common Lisp/24",
    "prompt": {
      "es": "(defun count-remaining-trees (road-length regions)\n;; Cuenta el número de árboles restantes en una carretera de longitud 'road-length' después de eliminar árboles en las 'regions' especificadas.\n;; Cada región es una lista de dos enteros que representan los puntos de inicio y fin en la carretera.\n;; La función devuelve el número de árboles restantes después de la eliminación.\n;; Ejemplo:\n;; (count-remaining-trees 10 '((2 5) (7 9))) ;; Devuelve 4\n;; (count-remaining-trees 15 '((1 3) (5 10))) ;; Devuelve 7",
      "arb": "(defun count-remaining-trees (road-length regions)\n;; يحسب عدد الأشجار المتبقية على طريق بطول 'road-length' بعد إزالة الأشجار في 'regions' المحددة.\n;; كل منطقة هي قائمة تحتوي على عددين صحيحين يمثلان نقطة البداية والنهاية على الطريق.\n;; تعيد الدالة عدد الأشجار المتبقية بعد الإزالة.\n;; مثال:\n;; (count-remaining-trees 10 '((2 5) (7 9))) ;; يعيد 4\n;; (count-remaining-trees 15 '((1 3) (5 10))) ;; يعيد 7",
      "sw": "(defun count-remaining-trees (road-length regions)\n;; Inahesabu idadi ya miti iliyobaki kwenye barabara yenye urefu wa 'road-length' baada ya kuondoa miti katika 'regions' zilizobainishwa.\n;; Kila eneo ni orodha ya namba mbili zinazoashiria mwanzo na mwisho kwenye barabara.\n;; Kazi inarudisha idadi ya miti iliyobaki baada ya kuondolewa.\n;; Mfano:\n;; (count-remaining-trees 10 '((2 5) (7 9))) ;; Inarudisha 4\n;; (count-remaining-trees 15 '((1 3) (5 10))) ;; Inarudisha 7",
      "tr": "(defun count-remaining-trees (road-length regions)\n;; Belirtilen 'regions' içindeki ağaçları kaldırdıktan sonra 'road-length' uzunluğundaki bir yolda kalan ağaçların sayısını sayar.\n;; Her bölge, yoldaki başlangıç ve bitiş noktalarını temsil eden iki tam sayıdan oluşan bir listedir.\n;; Fonksiyon, kaldırma işleminden sonra kalan ağaçların sayısını döndürür.\n;; Örnek:\n;; (count-remaining-trees 10 '((2 5) (7 9))) ;; 4 döndürür\n;; (count-remaining-trees 15 '((1 3) (5 10))) ;; 7 döndürür",
      "vi": "(defun count-remaining-trees (road-length regions)\n;; Đếm số lượng cây còn lại trên một con đường có độ dài 'road-length' sau khi loại bỏ cây trong các 'regions' được chỉ định.\n;; Mỗi vùng là một danh sách gồm hai số nguyên đại diện cho điểm bắt đầu và kết thúc trên con đường.\n;; Hàm trả về số lượng cây còn lại sau khi loại bỏ.\n;; Ví dụ:\n;; (count-remaining-trees 10 '((2 5) (7 9))) ;; Trả về 4\n;; (count-remaining-trees 15 '((1 3) (5 10))) ;; Trả về 7"
    },
    "prompt_bertscore": {
      "es": "0.9934537385322332",
      "arb": "0.9812538605290704",
      "sw": "0.9816801213267712",
      "tr": "0.9765675739493143",
      "vi": "0.9908749202952573"
    },
    "canonical_solution": "(let ((tree-map (make-array (1+ road-length) :initial-element t)))\n(dolist (region regions)\n(loop for i from (first region) to (second region)\ndo (setf (aref tree-map i) nil)))\n(count t tree-map)))",
    "instruction": {
      "es": "(defun count-remaining-trees (road-length regions)\n(let ((tree-map (make-array (1+ road-length) :initial-element t)))\n(dolist (region regions)\n(loop for i from (first region) to (second region)\ndo (setf (aref tree-map i) nil)))\n(count t tree-map)))\n\nProporcione una descripción concisa en lenguaje natural (docstring) del código Common Lisp en español utilizando un máximo de 500 caracteres.",
      "arb": "(defun count-remaining-trees (road-length regions)\n(let ((tree-map (make-array (1+ road-length) :initial-element t)))\n(dolist (region regions)\n(loop for i from (first region) to (second region)\ndo (setf (aref tree-map i) nil)))\n(count t tree-map)))\n\nيرجى تقديم وصف موجز بلغة طبيعية (docstring) لشفرة Common Lisp باللغة العربية الفصحى، بحيث لا يتجاوز 500 حرف.",
      "sw": "(defun count-remaining-trees (road-length regions)\n(let ((tree-map (make-array (1+ road-length) :initial-element t)))\n(dolist (region regions)\n(loop for i from (first region) to (second region)\ndo (setf (aref tree-map i) nil)))\n(count t tree-map)))\n\nToa maelezo mafupi ya lugha asilia (docstring) ya msimbo wa Common Lisp kwa Kiswahili kwa kutumia herufi zisizozidi 500.",
      "tr": "(defun count-remaining-trees (road-length regions)\n(let ((tree-map (make-array (1+ road-length) :initial-element t)))\n(dolist (region regions)\n(loop for i from (first region) to (second region)\ndo (setf (aref tree-map i) nil)))\n(count t tree-map)))\n\nAşağıdaki Common Lisp kodunun doğal dildeki açıklamasını (docstring) en fazla 500 karakter kullanarak Türkçe olarak sağlayın.",
      "vi": "(defun count-remaining-trees (road-length regions)\n(let ((tree-map (make-array (1+ road-length) :initial-element t)))\n(dolist (region regions)\n(loop for i from (first region) to (second region)\ndo (setf (aref tree-map i) nil)))\n(count t tree-map)))\n\nCung cấp mô tả ngắn gọn bằng ngôn ngữ tự nhiên (docstring) cho mã Common Lisp bằng tiếng Việt, sử dụng tối đa 500 ký tự."
    },
    "instruction_bertscore": {
      "es": "0.9711352316583911",
      "arb": "0.9060988777784239",
      "sw": "0.9454739741021129",
      "tr": "0.8647758133079257",
      "vi": "0.9283341585226124"
    },
    "level": "",
    "test": "(defun test-count-remaining-trees ()\n(assert (equal (count-remaining-trees 10 '((2 5) (7 9))) 4))\n(assert (equal (count-remaining-trees 15 '((1 3) (5 10))) 7))\n(assert (equal (count-remaining-trees 20 '((0 5) (10 15))) 9))\n(assert (equal (count-remaining-trees 30 '((3 6) (8 10) (15 20))) 18))\n(assert (equal (count-remaining-trees 50 '((0 10) (20 30) (40 50))) 18)))\n\n(test-count-remaining-trees)",
    "entry_point": "count-remaining-trees",
    "signature": "(defun count-remaining-trees (road-length regions)",
    "docstring": {
      "es": "Cuenta el número de árboles restantes en una carretera de longitud 'road-length' después de eliminar árboles en las 'regions' especificadas.  \nCada región es una lista de dos enteros que representan los puntos de inicio y fin en la carretera.  \nLa función devuelve el número de árboles restantes después de la eliminación.  \nEjemplo:  \n(count-remaining-trees 10 '((2 5) (7 9))) Devuelve 4  \n(count-remaining-trees 15 '((1 3) (5 10))) Devuelve 7  ",
      "arb": "يحسب عدد الأشجار المتبقية على طريق بطول 'road-length' بعد إزالة الأشجار في 'regions' المحددة.\nكل منطقة هي قائمة من عددين صحيحين تمثل نقاط البداية والنهاية على الطريق.\nتعيد الدالة عدد الأشجار المتبقية بعد الإزالة.\nمثال:\n(count-remaining-trees 10 '((2 5) (7 9))) يُرجع 4\n(count-remaining-trees 15 '((1 3) (5 10))) يُرجع 7",
      "sw": "Hesabu idadi ya miti iliyobaki kwenye barabara yenye urefu wa 'road-length' baada ya kuondoa miti katika 'regions' maalum.\nKila eneo ni orodha ya nambari mbili zinazowakilisha mwanzo na mwisho wa barabara.\nKazi inarudisha idadi ya miti iliyobaki baada ya kuondolewa.\n\nMfano:\n(count-remaining-trees 10 '((2 5) (7 9))) Inarudisha 4\n(count-remaining-trees 15 '((1 3) (5 10))) Inarudisha 7",
      "tr": "'road-length' uzunluğundaki bir yolda, belirtilen 'regions' bölgelerindeki ağaçlar kaldırıldıktan sonra kalan ağaçların sayısını sayar.  \nHer bölge, yoldaki başlangıç ve bitiş noktalarını temsil eden iki tam sayıdan oluşan bir listedir.  \nFonksiyon, kaldırma işleminden sonra kalan ağaçların sayısını döndürür.  \nÖrnek:  \n(count-remaining-trees 10 '((2 5) (7 9))) 4 döndürür  \n(count-remaining-trees 15 '((1 3) (5 10))) 7 döndürür  ",
      "vi": "Đếm số cây còn lại trên một con đường có chiều dài 'road-length' sau khi loại bỏ cây trong các 'regions' được chỉ định.  \nMỗi vùng là một danh sách gồm hai số nguyên đại diện cho điểm bắt đầu và điểm kết thúc trên đường.  \nHàm trả về số cây còn lại sau khi loại bỏ.  \nVí dụ:  \n(count-remaining-trees 10 '((2 5) (7 9))) Trả về 4  \n(count-remaining-trees 15 '((1 3) (5 10))) Trả về 7  "
    },
    "docstring_bertscore": {
      "es": "0.9851388721517317",
      "arb": "0.9800408247920903",
      "sw": "0.9699055109694041",
      "tr": "0.9434813141195708",
      "vi": "0.9725915896121389"
    }
  },
  {
    "task_id": "Common Lisp/25",
    "prompt": {
      "es": "(defun larger-prime-factor (n)\n;; Encuentra el factor primo más grande de un entero positivo 'n', que se sabe que es el producto de dos números primos distintos.\n;; La función devuelve el mayor de los dos factores primos.\n;; Ejemplo:\n;; (larger-prime-factor 15) ;; Devuelve 5\n;; (larger-prime-factor 33) ;; Devuelve 11",
      "arb": "(defun larger-prime-factor (n)\n;; يجد العامل الأولي الأكبر لعدد صحيح موجب 'n'، والذي يُعرف بأنه حاصل ضرب عددين أوليين مميزين.\n;; تُرجع الدالة الأكبر بين العاملين الأوليين.\n;; مثال:\n;; (larger-prime-factor 15) ;; يُرجع 5\n;; (larger-prime-factor 33) ;; يُرجع 11",
      "sw": "(defun larger-prime-factor (n)\n;; Inapata kigezo kikubwa zaidi cha nambari kamili chanya 'n', ambayo inajulikana kuwa ni zao la nambari mbili tofauti za kwanza.\n;; Kazi inarudisha kigezo kikubwa zaidi kati ya viwili vya kwanza.\n;; Mfano:\n;; (larger-prime-factor 15) ;; Inarudisha 5\n;; (larger-prime-factor 33) ;; Inarudisha 11",
      "tr": "(defun larger-prime-factor (n)\n;; Pozitif bir tamsayı 'n'nin daha büyük asal çarpanını bulur, bu sayının iki farklı asal sayının çarpımı olduğu bilinir.\n;; Fonksiyon, iki asal çarpandan daha büyüğünü döndürür.\n;; Örnek:\n;; (larger-prime-factor 15) ;; 5 döndürür\n;; (larger-prime-factor 33) ;; 11 döndürür",
      "vi": "(defun larger-prime-factor (n)\n;; Tìm ước số nguyên tố lớn hơn của một số nguyên dương 'n', được biết là tích của hai số nguyên tố khác nhau.\n;; Hàm trả về ước số nguyên tố lớn hơn trong hai ước số.\n;; Ví dụ:\n;; (larger-prime-factor 15) ;; Trả về 5\n;; (larger-prime-factor 33) ;; Trả về 11"
    },
    "prompt_bertscore": {
      "es": "0.9903231250967424",
      "arb": "0.9777853768154391",
      "sw": "0.9910185300607455",
      "tr": "0.994141794172138",
      "vi": "0.9739992831225331"
    },
    "canonical_solution": "(let ((factor 2))\n(loop while (> n factor)\nif (zerop (mod n factor))\ndo (setq n (/ n factor))\nelse\ndo (incf factor))\nn))",
    "instruction": {
      "es": "(defun larger-prime-factor (n)\n(let ((factor 2))\n(loop while (> n factor)\nif (zerop (mod n factor))\ndo (setq n (/ n factor))\nelse\ndo (incf factor))\nn))\n\nProporcione una descripción concisa en lenguaje natural (docstring) del código Common Lisp en español utilizando un máximo de 500 caracteres.",
      "arb": "(defun larger-prime-factor (n)\n(let ((factor 2))\n(loop while (> n factor)\nif (zerop (mod n factor))\ndo (setq n (/ n factor))\nelse\ndo (incf factor))\nn))\n\nيرجى تقديم وصف موجز بلغة طبيعية (docstring) لكود Common Lisp باللغة العربية الفصحى، بحيث لا يتجاوز 500 حرف.",
      "sw": "(defun larger-prime-factor (n)\n(let ((factor 2))\n(loop while (> n factor)\nif (zerop (mod n factor))\ndo (setq n (/ n factor))\nelse\ndo (incf factor))\nn))\n\nToa maelezo mafupi ya lugha asilia (docstring) ya msimbo wa Common Lisp kwa Kiswahili kwa kutumia herufi zisizozidi 500.",
      "tr": "(defun larger-prime-factor (n)\n(let ((factor 2))\n(loop while (> n factor)\nif (zerop (mod n factor))\ndo (setq n (/ n factor))\nelse\ndo (incf factor))\nn))\n\nAşağıdaki Common Lisp kodunun işlevini açıklayan, en fazla 500 karakter uzunluğunda bir doğal dil açıklaması (docstring) sağlayın.",
      "vi": "(defun larger-prime-factor (n)\n(let ((factor 2))\n(loop while (> n factor)\nif (zerop (mod n factor))\ndo (setq n (/ n factor))\nelse\ndo (incf factor))\nn))\n\nCung cấp mô tả ngắn gọn bằng ngôn ngữ tự nhiên (docstring) cho mã Common Lisp bằng tiếng Việt, sử dụng tối đa 500 ký tự."
    },
    "instruction_bertscore": {
      "es": "0.9711352316583911",
      "arb": "0.9060988777784239",
      "sw": "0.9454739741021129",
      "tr": "0.8405576054698659",
      "vi": "0.9115775009481282"
    },
    "level": "",
    "test": "(defun test-larger-prime-factor ()\n(assert (equal (larger-prime-factor 21) 7))\n(assert (equal (larger-prime-factor 15) 5))\n(assert (equal (larger-prime-factor 33) 11))\n(assert (equal (larger-prime-factor 35) 7))\n(assert (equal (larger-prime-factor 77) 11))\n(assert (equal (larger-prime-factor 26) 13)))\n\n(test-larger-prime-factor)",
    "entry_point": "larger-prime-factor",
    "signature": "(defun larger-prime-factor (n)",
    "docstring": {
      "es": "Encuentra el factor primo más grande de un entero positivo 'n', que se sabe que es el producto de dos números primos distintos.  \nLa función devuelve el mayor de los dos factores primos.  \nEjemplo:  \n(larger-prime-factor 15) Devuelve 5  \n(larger-prime-factor 33) Devuelve 11  ",
      "arb": "يعثر على العامل الأولي الأكبر لعدد صحيح موجب 'n' ، والذي يُعرف أنه ناتج عن ضرب عددين أوليين متميزين. \nتعيد الدالة الأكبر بين العاملين الأوليين.\n\nمثال:\n(larger-prime-factor 15) يعيد 5\n(larger-prime-factor 33) يعيد 11",
      "sw": "Inapata kipengele kikubwa zaidi cha nambari ya kwanza ya nambari nzima chanya 'n', ambayo inajulikana kuwa ni zao la nambari mbili tofauti za kwanza. \nKazi inarudisha kipengele kikubwa zaidi kati ya viwili vya kwanza. \nMfano:\n(larger-prime-factor 15) Inarudisha 5\n(larger-prime-factor 33) Inarudisha 11",
      "tr": "İki farklı asal sayının çarpımı olduğu bilinen pozitif bir tamsayı 'n'nin daha büyük asal çarpanını bulur.\nFonksiyon, iki asal çarpandan daha büyüğünü döndürür.\nÖrnek:\n(larger-prime-factor 15) 5 döndürür\n(larger-prime-factor 33) 11 döndürür",
      "vi": "Tìm ước số nguyên tố lớn hơn của một số nguyên dương 'n', được biết là tích của hai số nguyên tố khác nhau. \nHàm trả về ước số nguyên tố lớn hơn trong hai ước số nguyên tố. \nVí dụ: \n(larger-prime-factor 15) Trả về 5 \n(larger-prime-factor 33) Trả về 11"
    },
    "docstring_bertscore": {
      "es": "0.9820660601571221",
      "arb": "0.9847124127236498",
      "sw": "0.9880517866896084",
      "tr": "0.9885866983057353",
      "vi": "0.9605236021819832"
    }
  },
  {
    "task_id": "Common Lisp/26",
    "prompt": {
      "es": "(defun day-of-max-unhappiness (weekly-schedule)\n;; Analiza un horario semanal para encontrar el día en que Binbin estará más infeliz.\n;; 'weekly-schedule' es una lista de siete pares (uno para cada día) que representan horas de escuela y horas de clases extra.\n;; La función devuelve el día de la semana (1-7) en el que Binbin está más infeliz, o 0 si no está infeliz ningún día.\n;; Ejemplo:\n;; (day-of-max-unhappiness '((5 3) (6 2) (7 1) (5 3) (5 4) (0 4) (0 3))) ;; Devuelve 3\n;; (day-of-max-unhappiness '((4 3) (4 3) (4 3) (4 3) (4 3) (2 4) (2 4))) ;; Devuelve 0",
      "arb": "(defun day-of-max-unhappiness (weekly-schedule)\n;; يحلل جدولاً أسبوعياً لمعرفة اليوم الذي سيكون فيه بينبين الأكثر تعاسة.\n;; 'weekly-schedule' هو قائمة تحتوي على سبعة أزواج (واحد لكل يوم) تمثل ساعات المدرسة وساعات الدروس الإضافية.\n;; تعيد الدالة اليوم من الأسبوع (1-7) الذي تكون فيه بينبين الأكثر تعاسة، أو 0 إذا لم تكن تعيسة في أي يوم.\n;; مثال:\n;; (day-of-max-unhappiness '((5 3) (6 2) (7 1) (5 3) (5 4) (0 4) (0 3))) ;; يعيد 3\n;; (day-of-max-unhappiness '((4 3) (4 3) (4 3) (4 3) (4 3) (2 4) (2 4))) ;; يعيد 0",
      "sw": "(defun day-of-max-unhappiness (weekly-schedule)\n;; Huchambua ratiba ya kila wiki ili kupata siku ambayo Binbin atakuwa na huzuni zaidi.\n;; 'weekly-schedule' ni orodha ya jozi saba (moja kwa kila siku) inayowakilisha masaa ya shule na masaa ya ziada ya darasa.\n;; Kazi inarudisha siku ya wiki (1-7) ambayo Binbin ana huzuni zaidi, au 0 ikiwa hana huzuni siku yoyote.\n;; Mfano:\n;; (day-of-max-unhappiness '((5 3) (6 2) (7 1) (5 3) (5 4) (0 4) (0 3))) ;; Inarudisha 3\n;; (day-of-max-unhappiness '((4 3) (4 3) (4 3) (4 3) (4 3) (2 4) (2 4))) ;; Inarudisha 0",
      "tr": "(defun day-of-max-unhappiness (weekly-schedule)\n;; Binbin'in en mutsuz olacağı günü bulmak için haftalık bir programı analiz eder.\n;; 'weekly-schedule', okul saatlerini ve ekstra ders saatlerini temsil eden yedi çift (her gün için bir tane) içeren bir listedir.\n;; Fonksiyon, Binbin'in en mutsuz olduğu haftanın gününü (1-7) veya hiçbir gün mutsuz değilse 0 döndürür.\n;; Örnek:\n;; (day-of-max-unhappiness '((5 3) (6 2) (7 1) (5 3) (5 4) (0 4) (0 3))) ;; 3 döndürür\n;; (day-of-max-unhappiness '((4 3) (4 3) (4 3) (4 3) (4 3) (2 4) (2 4))) ;; 0 döndürür",
      "vi": "(defun day-of-max-unhappiness (weekly-schedule)\n;; Phân tích lịch trình hàng tuần để tìm ra ngày mà Binbin sẽ không vui nhất.\n;; 'weekly-schedule' là một danh sách gồm bảy cặp (một cho mỗi ngày) đại diện cho giờ học ở trường và giờ học thêm.\n;; Hàm trả về ngày trong tuần (1-7) mà Binbin không vui nhất, hoặc 0 nếu cô ấy không không vui vào bất kỳ ngày nào.\n;; Ví dụ:\n;; (day-of-max-unhappiness '((5 3) (6 2) (7 1) (5 3) (5 4) (0 4) (0 3))) ;; Trả về 3\n;; (day-of-max-unhappiness '((4 3) (4 3) (4 3) (4 3) (4 3) (2 4) (2 4))) ;; Trả về 0"
    },
    "prompt_bertscore": {
      "es": "0.9881665950498465",
      "arb": "0.9839460967136172",
      "sw": "0.9884987050469368",
      "tr": "0.9734111385642888",
      "vi": "0.9837746786947841"
    },
    "canonical_solution": "(let ((max-unhappiness 0)\n(most-unhappy-day 0))\n(loop for day from 1 to 7\nfor hours in weekly-schedule\ndo (let ((total-hours (+ (first hours) (second hours))))\n(when (> total-hours max-unhappiness)\n(setq max-unhappiness total-hours)\n(setq most-unhappy-day day))))\n(if (> max-unhappiness 8) most-unhappy-day 0)))",
    "instruction": {
      "es": "(defun day-of-max-unhappiness (weekly-schedule)\n(let ((max-unhappiness 0)\n(most-unhappy-day 0))\n(loop for day from 1 to 7\nfor hours in weekly-schedule\ndo (let ((total-hours (+ (first hours) (second hours))))\n(when (> total-hours max-unhappiness)\n(setq max-unhappiness total-hours)\n(setq most-unhappy-day day))))\n(if (> max-unhappiness 8) most-unhappy-day 0)))\n\nProporcione una descripción concisa en lenguaje natural (docstring) del código Common Lisp en español utilizando un máximo de 500 caracteres.",
      "arb": "(defun day-of-max-unhappiness (weekly-schedule)\n(let ((max-unhappiness 0)\n(most-unhappy-day 0))\n(loop for day from 1 to 7\nfor hours in weekly-schedule\ndo (let ((total-hours (+ (first hours) (second hours))))\n(when (> total-hours max-unhappiness)\n(setq max-unhappiness total-hours)\n(setq most-unhappy-day day))))\n(if (> max-unhappiness 8) most-unhappy-day 0)))\n\nيرجى تقديم وصف موجز بلغة طبيعية (docstring) لشفرة Common Lisp باللغة العربية الفصحى، بحيث لا يتجاوز 500 حرف.",
      "sw": "(defun day-of-max-unhappiness (weekly-schedule)\n(let ((max-unhappiness 0)\n(most-unhappy-day 0))\n(loop for day from 1 to 7\nfor hours in weekly-schedule\ndo (let ((total-hours (+ (first hours) (second hours))))\n(when (> total-hours max-unhappiness)\n(setq max-unhappiness total-hours)\n(setq most-unhappy-day day))))\n(if (> max-unhappiness 8) most-unhappy-day 0)))\n\nToa maelezo mafupi ya lugha ya asili (docstring) ya msimbo wa Common Lisp kwa Kiswahili kwa kutumia herufi zisizozidi 500.",
      "tr": "(defun day-of-max-unhappiness (weekly-schedule)\n(let ((max-unhappiness 0)\n(most-unhappy-day 0))\n(loop for day from 1 to 7\nfor hours in weekly-schedule\ndo (let ((total-hours (+ (first hours) (second hours))))\n(when (> total-hours max-unhappiness)\n(setq max-unhappiness total-hours)\n(setq most-unhappy-day day))))\n(if (> max-unhappiness 8) most-unhappy-day 0)))\n\nAşağıdaki Common Lisp kodunun işlevini açıklayan, en fazla 500 karakter uzunluğunda bir doğal dil açıklaması (docstring) sağlayın.",
      "vi": "(defun day-of-max-unhappiness (weekly-schedule)\n(let ((max-unhappiness 0)\n(most-unhappy-day 0))\n(loop for day from 1 to 7\nfor hours in weekly-schedule\ndo (let ((total-hours (+ (first hours) (second hours))))\n(when (> total-hours max-unhappiness)\n(setq max-unhappiness total-hours)\n(setq most-unhappy-day day))))\n(if (> max-unhappiness 8) most-unhappy-day 0)))\n\nCung cấp mô tả ngắn gọn bằng ngôn ngữ tự nhiên (docstring) cho mã Common Lisp bằng tiếng Việt, sử dụng tối đa 500 ký tự."
    },
    "instruction_bertscore": {
      "es": "0.9711352316583911",
      "arb": "0.9060988777784239",
      "sw": "0.9177628510135546",
      "tr": "0.8405576054698659",
      "vi": "0.9119165630085547"
    },
    "level": "",
    "test": "(defun test-day-of-max-unhappiness ()\n(assert (equal (day-of-max-unhappiness '((5 3) (6 2) (7 2) (5 3) (5 4) (0 4) (0 6))) 3))\n(assert (equal (day-of-max-unhappiness '((4 4) (4 4) (4 4) (4 4) (4 4) (4 4) (4 4))) 0))\n(assert (equal (day-of-max-unhappiness '((3 3) (3 3) (3 3) (3 3) (3 3) (3 3) (3 3))) 0))\n(assert (equal (day-of-max-unhappiness '((2 6) (3 5) (4 4) (5 3) (6 2) (7 1) (1 7))) 0))\n(assert (equal (day-of-max-unhappiness '((5 0) (0 5) (6 3) (3 6) (2 7) (7 2) (4 4))) 3)))\n(test-day-of-max-unhappiness)",
    "entry_point": "day-of-max-unhappiness",
    "signature": "(defun day-of-max-unhappiness (weekly-schedule)",
    "docstring": {
      "es": "Analiza un horario semanal para averiguar el día en que Binbin estará más infeliz. \n'weekly-schedule' es una lista de siete pares (uno para cada día) que representan las horas escolares y las horas de clases extra. \nLa función devuelve el día de la semana (1-7) en el que Binbin está más infeliz, o 0 si no está infeliz ningún día. \nEjemplo: \n(day-of-max-unhappiness '((5 3) (6 2) (7 1) (5 3) (5 4) (0 4) (0 3))) Devuelve 3 \n(day-of-max-unhappiness '((4 3) (4 3) (4 3) (4 3) (4 3) (2 4) (2 4))) Devuelve 0",
      "arb": "يحلل جدولاً أسبوعياً لمعرفة اليوم الذي ستكون فيه بينبين الأكثر تعاسة.  \n'weekly-schedule' هو قائمة مكونة من سبعة أزواج (واحد لكل يوم) تمثل ساعات المدرسة وساعات الدروس الإضافية.  \nتعيد الدالة اليوم من الأسبوع (1-7) الذي تكون فيه بينبين الأكثر تعاسة، أو 0 إذا لم تكن تعيسة في أي يوم.  \nمثال:  \n(day-of-max-unhappiness '((5 3) (6 2) (7 1) (5 3) (5 4) (0 4) (0 3))) يعيد 3  \n(day-of-max-unhappiness '((4 3) (4 3) (4 3) (4 3) (4 3) (2 4) (2 4))) يعيد 0  ",
      "sw": "Huchambua ratiba ya kila wiki ili kugundua ni siku gani Binbin atakuwa na huzuni zaidi.\n'weekly-schedule' ni orodha ya jozi saba (moja kwa kila siku) inayowakilisha saa za shule na saa za masomo ya ziada.\nKazi hii inarudisha siku ya wiki (1-7) ambayo Binbin ana huzuni zaidi, au 0 ikiwa hana huzuni siku yoyote.\nMfano:\n(day-of-max-unhappiness '((5 3) (6 2) (7 1) (5 3) (5 4) (0 4) (0 3))) Inarudisha 3\n(day-of-max-unhappiness '((4 3) (4 3) (4 3) (4 3) (4 3) (2 4) (2 4))) Inarudisha 0",
      "tr": "Haftalık bir programı analiz ederek Binbin'in en mutsuz olacağı günü bulur.\n'weekly-schedule', okul saatlerini ve ekstra ders saatlerini temsil eden yedi çift (her gün için bir tane) içeren bir listedir.\nFonksiyon, Binbin'in en mutsuz olduğu haftanın gününü (1-7) veya hiçbir gün mutsuz değilse 0 döndürür.\nÖrnek:\n(day-of-max-unhappiness '((5 3) (6 2) (7 1) (5 3) (5 4) (0 4) (0 3))) 3 döndürür\n(day-of-max-unhappiness '((4 3) (4 3) (4 3) (4 3) (4 3) (2 4) (2 4))) 0 döndürür ",
      "vi": "Phân tích lịch trình hàng tuần để tìm ra ngày mà Binbin sẽ không vui nhất. 'weekly-schedule' là một danh sách gồm bảy cặp (một cho mỗi ngày) đại diện cho giờ học ở trường và giờ học thêm. Hàm trả về ngày trong tuần (1-7) mà Binbin không vui nhất, hoặc 0 nếu cô ấy không không vui vào ngày nào.\n\nVí dụ:\n(day-of-max-unhappiness '((5 3) (6 2) (7 1) (5 3) (5 4) (0 4) (0 3))) Trả về 3\n(day-of-max-unhappiness '((4 3) (4 3) (4 3) (4 3) (4 3) (2 4) (2 4))) Trả về 0"
    },
    "docstring_bertscore": {
      "es": "0.9886979313191149",
      "arb": "0.9736798854698291",
      "sw": "0.9761953406152548",
      "tr": "0.950268911500295",
      "vi": "0.9829150064056651"
    }
  },
  {
    "task_id": "Common Lisp/27",
    "prompt": {
      "es": "(defun calculate-year-end-amount (monthly-budgets)\n;; Calcula si Jinjin puede seguir su plan de ahorros sin quedarse sin dinero en ningún mes.\n;; 'monthly-budgets' es una lista de 12 enteros que representa el presupuesto mensual de Jinjin.\n;; Si tiene éxito, devuelve la cantidad total de dinero que Jinjin tendrá al final del año, incluyendo un 20% de interés sobre los ahorros.\n;; De lo contrario, devuelve -X, donde X es el primer mes en que Jinjin se queda sin dinero.\n;; Ejemplo:\n;; (calculate-year-end-amount '(290 230 280 200 300 170 340 50 90 80 200 60)) ;; Devuelve -7",
      "arb": "(defun calculate-year-end-amount (monthly-budgets)\n;; يحسب ما إذا كان بإمكان جينجين اتباع خطة التوفير الخاصة بها دون نفاد المال في أي شهر.\n;; 'monthly-budgets' هي قائمة تحتوي على 12 عددًا صحيحًا تمثل ميزانية جينجين الشهرية.\n;; إذا نجحت، تُرجع إجمالي المبلغ الذي سيكون لدى جينجين بحلول نهاية العام، بما في ذلك فائدة بنسبة 20% على المدخرات.\n;; خلاف ذلك، تُرجع -X، حيث X هو أول شهر ينفد فيه المال لجينجين.\n;; مثال:\n;; (calculate-year-end-amount '(290 230 280 200 300 170 340 50 90 80 200 60)) ;; يعيد -7",
      "sw": "(defun calculate-year-end-amount (monthly-budgets)\n;; Inakokotoa kama Jinjin anaweza kufuata mpango wake wa akiba bila kumaliza pesa katika mwezi wowote.\n;; 'monthly-budgets' ni orodha ya namba 12 zinazowakilisha bajeti ya kila mwezi ya Jinjin.\n;; Ikiwa imefanikiwa, inarejesha jumla ya pesa ambazo Jinjin atakuwa nazo mwishoni mwa mwaka, ikiwa ni pamoja na riba ya 20% kwenye akiba.\n;; Vinginevyo, inarejesha -X, ambapo X ni mwezi wa kwanza ambao Jinjin anakosa pesa.\n;; Mfano:\n;; (calculate-year-end-amount '(290 230 280 200 300 170 340 50 90 80 200 60)) ;; Inarudisha -7",
      "tr": "(defun calculate-year-end-amount (monthly-budgets)\n;; Jinjin'in herhangi bir ayda parasız kalmadan tasarruf planına uyup uyamayacağını hesaplar.\n;; 'monthly-budgets', Jinjin'in aylık bütçesini temsil eden 12 tamsayıdan oluşan bir listedir.\n;; Başarılı olursa, yıl sonunda Jinjin'in sahip olacağı toplam para miktarını, tasarruflar üzerindeki %20 faiz dahil olmak üzere döndürür.\n;; Aksi takdirde, Jinjin'in parasız kaldığı ilk ay olan X'i -X olarak döndürür.\n;; Örnek:\n;; (calculate-year-end-amount '(290 230 280 200 300 170 340 50 90 80 200 60)) ;;  -7 döndürür",
      "vi": "(defun calculate-year-end-amount (monthly-budgets)\n;; Tính toán liệu Jinjin có thể tuân theo kế hoạch tiết kiệm của mình mà không hết tiền trong bất kỳ tháng nào.\n;; 'monthly-budgets' là một danh sách gồm 12 số nguyên đại diện cho ngân sách hàng tháng của Jinjin.\n;; Nếu thành công, trả về tổng số tiền Jinjin sẽ có vào cuối năm, bao gồm lãi suất 20% trên số tiền tiết kiệm.\n;; Ngược lại, trả về -X, trong đó X là tháng đầu tiên Jinjin hết tiền.\n;; Ví dụ:\n;; (calculate-year-end-amount '(290 230 280 200 300 170 340 50 90 80 200 60)) ;; Trả về -7"
    },
    "prompt_bertscore": {
      "es": "0.9840714324840503",
      "arb": "0.9767618344619664",
      "sw": "0.97108319049856",
      "tr": "0.97786999335776",
      "vi": "0.9795919201309514"
    },
    "canonical_solution": "(let ((current-amount 0)\n(total-saved 0))\n(loop for month from 1 to 12\nfor budget in monthly-budgets\ndo (progn\n(incf current-amount 300) ;; Add monthly allowance\n(decf current-amount budget) ;; Subtract monthly budget\n(when (< current-amount 0)\n(return-from calculate-year-end-amount (- month))) ;; Check if Jinjin runs out of money\n(let ((savings (floor current-amount 100)))\n(decf current-amount (* 100 savings))\n(incf total-saved (* 100 savings))))\nfinally (return (+ current-amount (* total-saved 1.2)))))) ;; Calculate total with interest",
    "instruction": {
      "es": "(defun calculate-year-end-amount (monthly-budgets)\n(let ((current-amount 0)\n(total-saved 0))\n(loop for month from 1 to 12\nfor budget in monthly-budgets\ndo (progn\n(incf current-amount 300) ;; Add monthly allowance\n(decf current-amount budget) ;; Subtract monthly budget\n(when (< current-amount 0)\n(return-from calculate-year-end-amount (- month))) ;; Check if Jinjin runs out of money\n(let ((savings (floor current-amount 100)))\n(decf current-amount (* 100 savings))\n(incf total-saved (* 100 savings))))\nfinally (return (+ current-amount (* total-saved 1.2)))))) ;; Calculate total with interest\n\nProporcione una descripción concisa en lenguaje natural (docstring) del código Common Lisp en español utilizando un máximo de 500 caracteres.",
      "arb": "(defun calculate-year-end-amount (monthly-budgets)\n(let ((current-amount 0)\n(total-saved 0))\n(loop for month from 1 to 12\nfor budget in monthly-budgets\ndo (progn\n(incf current-amount 300) ;; Add monthly allowance\n(decf current-amount budget) ;; Subtract monthly budget\n(when (< current-amount 0)\n(return-from calculate-year-end-amount (- month))) ;; Check if Jinjin runs out of money\n(let ((savings (floor current-amount 100)))\n(decf current-amount (* 100 savings))\n(incf total-saved (* 100 savings))))\nfinally (return (+ current-amount (* total-saved 1.2)))))) ;; Calculate total with interest\n\nيرجى تقديم وصف موجز بلغة طبيعية (docstring) لشفرة Common Lisp باللغة العربية الفصحى، بحيث لا يتجاوز 500 حرف.",
      "sw": "(defun calculate-year-end-amount (monthly-budgets)\n(let ((current-amount 0)\n(total-saved 0))\n(loop for month from 1 to 12\nfor budget in monthly-budgets\ndo (progn\n(incf current-amount 300) ;; Add monthly allowance\n(decf current-amount budget) ;; Subtract monthly budget\n(when (< current-amount 0)\n(return-from calculate-year-end-amount (- month))) ;; Check if Jinjin runs out of money\n(let ((savings (floor current-amount 100)))\n(decf current-amount (* 100 savings))\n(incf total-saved (* 100 savings))))\nfinally (return (+ current-amount (* total-saved 1.2)))))) ;; Calculate total with interest\n\nToa maelezo mafupi ya lugha ya asili (docstring) ya msimbo wa Common Lisp kwa Kiswahili kwa kutumia herufi zisizozidi 500.",
      "tr": "(defun calculate-year-end-amount (monthly-budgets)\n(let ((current-amount 0)\n(total-saved 0))\n(loop for month from 1 to 12\nfor budget in monthly-budgets\ndo (progn\n(incf current-amount 300) ;; Add monthly allowance\n(decf current-amount budget) ;; Subtract monthly budget\n(when (< current-amount 0)\n(return-from calculate-year-end-amount (- month))) ;; Check if Jinjin runs out of money\n(let ((savings (floor current-amount 100)))\n(decf current-amount (* 100 savings))\n(incf total-saved (* 100 savings))))\nfinally (return (+ current-amount (* total-saved 1.2)))))) ;; Calculate total with interest\n\nAşağıdaki Common Lisp kodunun işlevini açıklayan kısa bir doğal dil açıklaması (docstring) sağlayın. Açıklama, en fazla 500 karakter kullanarak Türkçe olarak yazılmalıdır.",
      "vi": "(defun calculate-year-end-amount (monthly-budgets)\n(let ((current-amount 0)\n(total-saved 0))\n(loop for month from 1 to 12\nfor budget in monthly-budgets\ndo (progn\n(incf current-amount 300) ;; Add monthly allowance\n(decf current-amount budget) ;; Subtract monthly budget\n(when (< current-amount 0)\n(return-from calculate-year-end-amount (- month))) ;; Check if Jinjin runs out of money\n(let ((savings (floor current-amount 100)))\n(decf current-amount (* 100 savings))\n(incf total-saved (* 100 savings))))\nfinally (return (+ current-amount (* total-saved 1.2)))))) ;; Calculate total with interest\n\nCung cấp mô tả ngắn gọn bằng ngôn ngữ tự nhiên (docstring) cho mã Common Lisp bằng tiếng Việt, sử dụng tối đa 500 ký tự."
    },
    "instruction_bertscore": {
      "es": "0.9711352316583911",
      "arb": "0.9060988777784239",
      "sw": "0.8914782913215888",
      "tr": "0.8457565570630731",
      "vi": "0.9397351451332528"
    },
    "level": "",
    "test": "(defun test-calculate-year-end-amount ()\n(assert (equal (calculate-year-end-amount '(290 230 280 200 300 170 340 50 90 80 200 60)) -7))\n(assert (equal (calculate-year-end-amount '(100 100 100 100 100 100 100 100 100 100 100 100)) 2880.0)) ;; Assuming all savings\n(assert (equal (calculate-year-end-amount '(300 300 300 300 300 300 300 300 300 300 300 300)) 0.0)) ;; No savings\n(assert (equal (calculate-year-end-amount '(150 150 150 150 150 150 150 150 150 150 150 150)) 2160.0)) ;; Half savings\n(assert (equal (calculate-year-end-amount '(250 250 250 250 250 250 250 250 250 250 250 250)) 720.0))) ;; Runs out first month\n(test-calculate-year-end-amount)",
    "entry_point": "calculate-year-end-amount",
    "signature": "(defun calculate-year-end-amount (monthly-budgets)",
    "docstring": {
      "es": "Calcula si Jinjin puede seguir su plan de ahorros sin quedarse sin dinero en ningún mes.  \n'monthly-budgets' es una lista de 12 enteros que representa el presupuesto mensual de Jinjin.  \nSi tiene éxito, devuelve la cantidad total de dinero que Jinjin tendrá al final del año, incluyendo un 20% de interés sobre los ahorros.  \nDe lo contrario, devuelve -X, donde X es el primer mes en el que Jinjin se queda sin dinero.  \nEjemplo:  \n(calculate-year-end-amount '(290 230 280 200 300 170 340 50 90 80 200 60)) Devuelve  -7",
      "arb": "يحسب ما إذا كانت جينجين يمكنها اتباع خطة التوفير الخاصة بها دون نفاد المال في أي شهر.\n'monthly-budgets' هي قائمة مكونة من 12 عددًا صحيحًا تمثل ميزانية جينجين الشهرية.\nإذا نجحت، تعيد إجمالي المبلغ الذي ستحصل عليه جينجين بحلول نهاية العام، بما في ذلك فائدة بنسبة 20% على المدخرات.\nوإلا، تعيد -X، حيث X هو الشهر الأول الذي تنفد فيه أموال جينجين.\nمثال:\n(calculate-year-end-amount '(290 230 280 200 300 170 340 50 90 80 200 60)) يعيد -7",
      "sw": "Hesabu kama Jinjin anaweza kufuata mpango wake wa akiba bila kumaliza pesa katika mwezi wowote.\n'monthly-budgets' ni orodha ya namba 12 za mzima zinazoonyesha bajeti ya kila mwezi ya Jinjin.\nIkiwa imefanikiwa, inarudisha jumla ya pesa ambazo Jinjin atakuwa nazo mwishoni mwa mwaka, ikiwa ni pamoja na riba ya 20% kwenye akiba.\nVinginevyo, inarudisha -X, ambapo X ni mwezi wa kwanza ambao Jinjin anakosa pesa.\nMfano:\n(calculate-year-end-amount '(290 230 280 200 300 170 340 50 90 80 200 60)) Inarudisha  -7",
      "tr": "Jinjin'in herhangi bir ayda parasını bitirmeden tasarruf planına uyup uymadığını hesaplar.\n'monthly-budgets', Jinjin'in aylık bütçesini temsil eden 12 tamsayıdan oluşan bir listedir.\nBaşarılı olursa, yıl sonunda Jinjin'in sahip olacağı toplam para miktarını, tasarruflar üzerindeki %20 faizi de dahil ederek döndürür.\nAksi takdirde, Jinjin'in parasının bittiği ilk ay olan X için -X döner.\nÖrnek:\n(calculate-year-end-amount '(290 230 280 200 300 170 340 50 90 80 200 60)) -7 döndürür",
      "vi": "Tính toán liệu Jinjin có thể theo kế hoạch tiết kiệm của mình mà không hết tiền trong bất kỳ tháng nào.\n\n'monthly-budgets' là một danh sách gồm 12 số nguyên đại diện cho ngân sách hàng tháng của Jinjin.\n\nNếu thành công, trả về tổng số tiền Jinjin sẽ có vào cuối năm, bao gồm 20% lãi suất trên số tiền tiết kiệm.\n\nNếu không, trả về -X, trong đó X là tháng đầu tiên Jinjin hết tiền.\n\nVí dụ:\n(calculate-year-end-amount '(290 230 280 200 300 170 340 50 90 80 200 60)) Trả về  -7"
    },
    "docstring_bertscore": {
      "es": "0.974328413663908",
      "arb": "0.9643895452880652",
      "sw": "0.9596069229735072",
      "tr": "0.9533063672870805",
      "vi": "0.9678423372015947"
    }
  },
  {
    "task_id": "Common Lisp/28",
    "prompt": {
      "es": "(defun total-cigarettes-smoked (initial-cigarettes butt-to-cigarette-ratio)\n;; Calcula el número total de cigarrillos que Peter puede fumar.\n;; 'initial-cigarettes' es el número inicial de cigarrillos.\n;; 'butt-to-cigarette-ratio' es el número de colillas de cigarrillo necesarias para obtener un nuevo cigarrillo.\n;; La función devuelve el número total de cigarrillos que Peter puede fumar.\n;; Ejemplo:\n;; (total-cigarettes-smoked 4 3) ;; Devuelve 5\n;; (total-cigarettes-smoked 10 4) ;; Devuelve 13",
      "arb": "(defun total-cigarettes-smoked (initial-cigarettes butt-to-cigarette-ratio)\n;; يحسب العدد الإجمالي للسجائر التي يمكن لبيتر تدخينها.\n;; 'initial-cigarettes' هو العدد الأولي للسجائر.\n;; 'butt-to-cigarette-ratio' هو عدد أعقاب السجائر المطلوبة للحصول على سيجارة جديدة.\n;; تُرجع الدالة العدد الإجمالي للسجائر التي يمكن لبيتر تدخينها.\n;; مثال:\n;; (total-cigarettes-smoked 4 3) ;; يعيد 5\n;; (total-cigarettes-smoked 10 4) ;; يعيد 13",
      "sw": "(defun total-cigarettes-smoked (initial-cigarettes butt-to-cigarette-ratio)\n;; Inahesabu jumla ya sigara ambazo Peter anaweza kuvuta.\n;; 'initial-cigarettes' ni idadi ya awali ya sigara.\n;; 'butt-to-cigarette-ratio' ni idadi ya vipande vya sigara vinavyohitajika kupata sigara mpya.\n;; Kazi inarudisha jumla ya sigara ambazo Peter anaweza kuvuta.\n;; Mfano:\n;; (total-cigarettes-smoked 4 3) ;; Inarudisha 5\n;; (total-cigarettes-smoked 10 4) ;; Inarudisha  13",
      "tr": "(defun total-cigarettes-smoked (initial-cigarettes butt-to-cigarette-ratio)\n;; Peter'ın içebileceği toplam sigara sayısını hesaplar.\n;; 'initial-cigarettes' başlangıçtaki sigara sayısıdır.\n;; 'butt-to-cigarette-ratio' yeni bir sigara elde etmek için gereken izmarit sayısıdır.\n;; Fonksiyon, Peter'ın içebileceği toplam sigara sayısını döndürür.\n;; Örnek:\n;; (total-cigarettes-smoked 4 3) ;; 5 döndürür \n;; (total-cigarettes-smoked 10 4) ;; 13 döndürür ",
      "vi": "(defun total-cigarettes-smoked (initial-cigarettes butt-to-cigarette-ratio)\n;; Tính tổng số điếu thuốc mà Peter có thể hút.\n;; 'initial-cigarettes' là số điếu thuốc ban đầu.\n;; 'butt-to-cigarette-ratio' là số đầu lọc thuốc lá cần thiết để có được một điếu thuốc mới.\n;; Hàm trả về tổng số điếu thuốc mà Peter có thể hút.\n;; Ví dụ:\n;; (total-cigarettes-smoked 4 3) ;; Trả về  5\n;; (total-cigarettes-smoked 10 4) ;; Trả về  13"
    },
    "prompt_bertscore": {
      "es": "0.9875293887874866",
      "arb": "0.9871293472000824",
      "sw": "0.9887589108460926",
      "tr": "0.9902520154203318",
      "vi": "0.9864698943350465"
    },
    "canonical_solution": "(let ((total-smoked initial-cigarettes)\n(butts initial-cigarettes))\n(loop while (>= butts butt-to-cigarette-ratio)\ndo (let ((new-cigarettes (floor butts butt-to-cigarette-ratio)))\n(incf total-smoked new-cigarettes)\n(decf butts (* new-cigarettes butt-to-cigarette-ratio))\n(incf butts new-cigarettes)))\ntotal-smoked))",
    "instruction": {
      "es": "(defun total-cigarettes-smoked (initial-cigarettes butt-to-cigarette-ratio)\n(let ((total-smoked initial-cigarettes)\n(butts initial-cigarettes))\n(loop while (>= butts butt-to-cigarette-ratio)\ndo (let ((new-cigarettes (floor butts butt-to-cigarette-ratio)))\n(incf total-smoked new-cigarettes)\n(decf butts (* new-cigarettes butt-to-cigarette-ratio))\n(incf butts new-cigarettes)))\ntotal-smoked))\n\nProporcione una descripción concisa en lenguaje natural (docstring) del código Common Lisp en español usando como máximo 500 caracteres.",
      "arb": "(defun total-cigarettes-smoked (initial-cigarettes butt-to-cigarette-ratio)\n(let ((total-smoked initial-cigarettes)\n(butts initial-cigarettes))\n(loop while (>= butts butt-to-cigarette-ratio)\ndo (let ((new-cigarettes (floor butts butt-to-cigarette-ratio)))\n(incf total-smoked new-cigarettes)\n(decf butts (* new-cigarettes butt-to-cigarette-ratio))\n(incf butts new-cigarettes)))\ntotal-smoked))\n\nيرجى تقديم وصف موجز بلغة طبيعية (docstring) لشفرة Common Lisp باللغة العربية الفصحى، بحيث لا يتجاوز 500 حرف.",
      "sw": "(defun total-cigarettes-smoked (initial-cigarettes butt-to-cigarette-ratio)\n(let ((total-smoked initial-cigarettes)\n(butts initial-cigarettes))\n(loop while (>= butts butt-to-cigarette-ratio)\ndo (let ((new-cigarettes (floor butts butt-to-cigarette-ratio)))\n(incf total-smoked new-cigarettes)\n(decf butts (* new-cigarettes butt-to-cigarette-ratio))\n(incf butts new-cigarettes)))\ntotal-smoked))\n\nToa maelezo mafupi ya lugha asilia (docstring) ya msimbo wa Common Lisp kwa Kiswahili kwa kutumia herufi zisizozidi 500.",
      "tr": "(defun total-cigarettes-smoked (initial-cigarettes butt-to-cigarette-ratio)\n(let ((total-smoked initial-cigarettes)\n(butts initial-cigarettes))\n(loop while (>= butts butt-to-cigarette-ratio)\ndo (let ((new-cigarettes (floor butts butt-to-cigarette-ratio)))\n(incf total-smoked new-cigarettes)\n(decf butts (* new-cigarettes butt-to-cigarette-ratio))\n(incf butts new-cigarettes)))\ntotal-smoked))\n\nAşağıdaki Common Lisp kodunun işlevini açıklayan, en fazla 500 karakterlik özlü bir doğal dil açıklaması (docstring) sağlayın.",
      "vi": "(defun total-cigarettes-smoked (initial-cigarettes butt-to-cigarette-ratio)\n(let ((total-smoked initial-cigarettes)\n(butts initial-cigarettes))\n(loop while (>= butts butt-to-cigarette-ratio)\ndo (let ((new-cigarettes (floor butts butt-to-cigarette-ratio)))\n(incf total-smoked new-cigarettes)\n(decf butts (* new-cigarettes butt-to-cigarette-ratio))\n(incf butts new-cigarettes)))\ntotal-smoked))\n\nCung cấp mô tả ngắn gọn bằng ngôn ngữ tự nhiên (docstring) cho mã Common Lisp bằng tiếng Việt, sử dụng tối đa 500 ký tự."
    },
    "instruction_bertscore": {
      "es": "0.9711352316583911",
      "arb": "0.8841158576181497",
      "sw": "0.9454739741021129",
      "tr": "0.8800651882577052",
      "vi": "0.9119165630085547"
    },
    "level": "",
    "test": "(defun test-total-cigarettes-smoked ()\n(assert (equal (total-cigarettes-smoked 4 3) 5))\n(assert (equal (total-cigarettes-smoked 10 4) 13))\n(assert (equal (total-cigarettes-smoked 20 5) 24))\n(assert (equal (total-cigarettes-smoked 15 3) 22))\n(assert (equal (total-cigarettes-smoked 7 2) 13))\n(assert (equal (total-cigarettes-smoked 5 5) 6))\n(assert (equal (total-cigarettes-smoked 0 3) 0)))\n\n(test-total-cigarettes-smoked)",
    "entry_point": "total-cigarettes-smoked",
    "signature": "(defun total-cigarettes-smoked (initial-cigarettes butt-to-cigarette-ratio)",
    "docstring": {
      "es": "Calcula el número total de cigarrillos que Peter puede fumar.\n'initial-cigarettes' es el número inicial de cigarrillos.\n'butt-to-cigarette-ratio' es el número de colillas de cigarrillo necesarias para obtener un nuevo cigarrillo.\nLa función devuelve el número total de cigarrillos que Peter puede fumar.\nEjemplo:\n(total-cigarettes-smoked 4 3) Devuelve 5\n(total-cigarettes-smoked 10 4) Devuelve 13",
      "arb": "يحسب العدد الإجمالي للسجائر التي يمكن لبيتر تدخينها.\n'initial-cigarettes' هو العدد الأولي للسجائر.\n'butt-to-cigarette-ratio' هو عدد أعقاب السجائر المطلوبة للحصول على سيجارة جديدة.\nتعيد الدالة العدد الإجمالي للسجائر التي يمكن لبيتر تدخينها.\nمثال:\n(total-cigarettes-smoked 4 3) يعيد 5\n(total-cigarettes-smoked 10 4) يعيد 13",
      "sw": "Hesabu jumla ya sigara ambazo Peter anaweza kuvuta.  \n'initial-cigarettes' ni idadi ya awali ya sigara.  \n'butt-to-cigarette-ratio' ni idadi ya vipande vya sigara vinavyohitajika kupata sigara mpya.  \nKazi hii inarejesha jumla ya sigara ambazo Peter anaweza kuvuta.  \nMfano:  \n(total-cigarettes-smoked 4 3) Inarejesha 5  \n(total-cigarettes-smoked 10 4) Inarudisha 13  ",
      "tr": "Toplamda Peter'ın içebileceği sigara sayısını hesaplar.\n'initial-cigarettes' başlangıçtaki sigara sayısıdır.\n'butt-to-cigarette-ratio' yeni bir sigara elde etmek için gereken izmarit sayısıdır.\nFonksiyon, Peter'ın içebileceği toplam sigara sayısını döndürür.\nÖrnek:\n(total-cigarettes-smoked 4 3) 5 Döndürür\n(total-cigarettes-smoked 10 4) 13 Döndürür",
      "vi": "Tính tổng số điếu thuốc mà Peter có thể hút.\n'initial-cigarettes' là số điếu thuốc ban đầu.\n'butt-to-cigarette-ratio' là số đầu mẩu thuốc cần thiết để có được một điếu thuốc mới.\nHàm trả về tổng số điếu thuốc mà Peter có thể hút.\nVí dụ:\n(total-cigarettes-smoked 4 3) Trả về 5\n(total-cigarettes-smoked 10 4) Trả về 13"
    },
    "docstring_bertscore": {
      "es": "0.9814441484341018",
      "arb": "0.9839288158704672",
      "sw": "0.9781824389471279",
      "tr": "0.9894062472578853",
      "vi": "0.9832721438307659"
    }
  },
  {
    "task_id": "Common Lisp/29",
    "prompt": {
      "es": "(defun divisible-five-digit-numbers (k)\n;; Encuentra todos los números de cinco dígitos entre 10000 y 30000 donde tres subnúmeros \n;; (formados por dígitos consecutivos) son divisibles por 'k'.\n;; Cada subnúmero consiste en tres dígitos consecutivos del número original.\n;; La función devuelve una lista de tales números de cinco dígitos.\n;; Ejemplo:\n;; (divisible-five-digit-numbers 15) ;; Devuelve (22555 25555 28555 30000)\n;; (divisible-five-digit-numbers 7) ;; Devuelve una lista de números o 'No' si no existen tales números",
      "arb": "(defun divisible-five-digit-numbers (k)\n;; يجد جميع الأرقام المكونة من خمسة أرقام بين 10000 و 30000 حيث تكون ثلاثة أرقام فرعية \n;; (تتكون من أرقام متتالية) قابلة للقسمة على 'k'.\n;; كل رقم فرعي يتكون من ثلاثة أرقام متتالية من الرقم الأصلي.\n;; تعيد الدالة قائمة من هذه الأرقام المكونة من خمسة أرقام.\n;; مثال:\n;; (divisible-five-digit-numbers 15) ;; يعيد (22555 25555 28555 30000)\n;; (divisible-five-digit-numbers 7) ;; يعيد قائمة من الأرقام أو 'No' إذا لم توجد مثل هذه الأرقام",
      "sw": "(defun divisible-five-digit-numbers (k)\n;; Inapata nambari zote za tarakimu tano kati ya 10000 na 30000 ambapo nambari ndogo tatu \n;; (zilizoundwa na tarakimu mfululizo) zinagawanyika kwa 'k'.\n;; Kila nambari ndogo inajumuisha tarakimu tatu mfululizo kutoka kwa nambari ya awali.\n;; Kazi inarudisha orodha ya nambari hizo za tarakimu tano.\n;; Mfano:\n;; (divisible-five-digit-numbers 15) ;; Inarudisha (22555 25555 28555 30000)\n;; (divisible-five-digit-numbers 7) ;; Inarudisha orodha ya nambari au 'No' ikiwa hakuna nambari kama hizo zilizopo",
      "tr": "(defun divisible-five-digit-numbers (k)\n;; 10000 ile 30000 arasındaki tüm beş basamaklı sayıları bulur, \n;; burada üç alt sayı (ardışık rakamlardan oluşan) 'k' ile bölünebilir.\n;; Her alt sayı, orijinal sayıdan ardışık üç rakamdan oluşur.\n;; Fonksiyon, bu tür beş basamaklı sayıların bir listesini döndürür.\n;; Örnek:\n;; (divisible-five-digit-numbers 15) ;; (22555 25555 28555 30000) döndürür\n;; (divisible-five-digit-numbers 7) ;; Sayıların bir listesini veya böyle bir sayı yoksa 'No' döndürür",
      "vi": "(defun divisible-five-digit-numbers (k)\n;; Tìm tất cả các số có năm chữ số giữa 10000 và 30000 mà ba số con \n;; (được tạo thành từ các chữ số liên tiếp) chia hết cho 'k'.\n;; Mỗi số con bao gồm ba chữ số liên tiếp từ số gốc.\n;; Hàm trả về một danh sách các số có năm chữ số như vậy.\n;; Ví dụ:\n;; (divisible-five-digit-numbers 15) ;; Trả về (22555 25555 28555 30000)\n;; (divisible-five-digit-numbers 7) ;; Trả về một danh sách các số hoặc 'No' nếu không tồn tại số nào như vậy"
    },
    "prompt_bertscore": {
      "es": "0.9865310724924052",
      "arb": "0.9844533987067804",
      "sw": "0.9817577858057559",
      "tr": "0.9699877439471525",
      "vi": "0.9888000273349667"
    },
    "canonical_solution": "(let ((results '()))\n(loop for num from 10000 to 30000\nwhen (and (zerop (mod (parse-integer (subseq (write-to-string num) 0 3)) k))\n(zerop (mod (parse-integer (subseq (write-to-string num) 1 4)) k))\n(zerop (mod (parse-integer (subseq (write-to-string num) 2 5)) k)))\ndo (push num results))\n(if (null results)\n'No\n(nreverse results))))",
    "instruction": {
      "es": "(defun divisible-five-digit-numbers (k)\n(let ((results '()))\n(loop for num from 10000 to 30000\nwhen (and (zerop (mod (parse-integer (subseq (write-to-string num) 0 3)) k))\n(zerop (mod (parse-integer (subseq (write-to-string num) 1 4)) k))\n(zerop (mod (parse-integer (subseq (write-to-string num) 2 5)) k)))\ndo (push num results))\n(if (null results)\n'No\n(nreverse results))))\n\nProporcione una descripción concisa en lenguaje natural (docstring) del código Common Lisp en español utilizando un máximo de 500 caracteres.",
      "arb": "(defun divisible-five-digit-numbers (k)\n(let ((results '()))\n(loop for num from 10000 to 30000\nwhen (and (zerop (mod (parse-integer (subseq (write-to-string num) 0 3)) k))\n(zerop (mod (parse-integer (subseq (write-to-string num) 1 4)) k))\n(zerop (mod (parse-integer (subseq (write-to-string num) 2 5)) k)))\ndo (push num results))\n(if (null results)\n'No\n(nreverse results))))\n\nيرجى تقديم وصف موجز بلغة طبيعية (docstring) لشفرة Common Lisp باللغة العربية الفصحى، بحيث لا يتجاوز 500 حرف.",
      "sw": "(defun divisible-five-digit-numbers (k)\n(let ((results '()))\n(loop for num from 10000 to 30000\nwhen (and (zerop (mod (parse-integer (subseq (write-to-string num) 0 3)) k))\n(zerop (mod (parse-integer (subseq (write-to-string num) 1 4)) k))\n(zerop (mod (parse-integer (subseq (write-to-string num) 2 5)) k)))\ndo (push num results))\n(if (null results)\n'No\n(nreverse results))))\n\nToa maelezo mafupi ya lugha ya asili (docstring) ya msimbo wa Common Lisp kwa Kiswahili kwa kutumia herufi zisizozidi 500.",
      "tr": "(defun divisible-five-digit-numbers (k)\n(let ((results '()))\n(loop for num from 10000 to 30000\nwhen (and (zerop (mod (parse-integer (subseq (write-to-string num) 0 3)) k))\n(zerop (mod (parse-integer (subseq (write-to-string num) 1 4)) k))\n(zerop (mod (parse-integer (subseq (write-to-string num) 2 5)) k)))\ndo (push num results))\n(if (null results)\n'No\n(nreverse results))))\n\nAşağıdaki Common Lisp kodunun işlevini açıklayan kısa bir doğal dil açıklaması (docstring) sağlayın. Açıklama, Türkçe olarak en fazla 500 karakter içermelidir.",
      "vi": "(defun divisible-five-digit-numbers (k)\n(let ((results '()))\n(loop for num from 10000 to 30000\nwhen (and (zerop (mod (parse-integer (subseq (write-to-string num) 0 3)) k))\n(zerop (mod (parse-integer (subseq (write-to-string num) 1 4)) k))\n(zerop (mod (parse-integer (subseq (write-to-string num) 2 5)) k)))\ndo (push num results))\n(if (null results)\n'No\n(nreverse results))))\n\nCung cấp mô tả ngắn gọn bằng ngôn ngữ tự nhiên (docstring) cho mã Common Lisp bằng tiếng Việt, sử dụng tối đa 500 ký tự."
    },
    "instruction_bertscore": {
      "es": "0.9711352316583911",
      "arb": "0.9060988777784239",
      "sw": "0.9127128722061235",
      "tr": "0.8541028070437781",
      "vi": "0.9119165630085547"
    },
    "level": "",
    "test": "(defun test-divisible-five-digit-numbers ()\n(assert (equal (divisible-five-digit-numbers 15) '(22555 25555 28555 30000)))\n(assert (equal (divisible-five-digit-numbers 31) '(15589 18682))) ;; No such numbers exist\n(assert (equal (divisible-five-digit-numbers 999) 'No))) ;; No such numbers exist for a large divisor\n\n(test-divisible-five-digit-numbers)",
    "entry_point": "divisible-five-digit-numbers",
    "signature": "(defun divisible-five-digit-numbers (k)",
    "docstring": {
      "es": "Encuentra todos los números de cinco dígitos entre 10000 y 30000 donde tres subnúmeros (formados por dígitos consecutivos) son divisibles por 'k'.  \nCada subnúmero consta de tres dígitos consecutivos del número original.  \nLa función devuelve una lista de dichos números de cinco dígitos.  \nEjemplo:  \n(divisible-five-digit-numbers 15) Devuelve (22555 25555 28555 30000)  \n(divisible-five-digit-numbers 7) Devuelve una lista de números o 'No' si no existen tales números  ",
      "arb": "يجد جميع الأرقام المكونة من خمسة أرقام بين 10000 و 30000 حيث يمكن تقسيم ثلاثة أرقام فرعية (تتكون من أرقام متتالية) على 'k'. كل رقم فرعي يتكون من ثلاثة أرقام متتالية من الرقم الأصلي. تقوم الدالة بإرجاع قائمة من هذه الأرقام المكونة من خمسة أرقام. مثال: (divisible-five-digit-numbers 15) يعيد (22555 25555 28555 30000) (divisible-five-digit-numbers 7) يعيد قائمة من الأرقام أو 'لا' إذا لم تكن هناك أرقام من هذا القبيل",
      "sw": "Inapata namba zote za tarakimu tano kati ya 10000 na 30000 ambapo namba ndogo tatu (zilizoundwa na tarakimu mfululizo) zinagawanyika kwa 'k'. \nKila namba ndogo inajumuisha tarakimu tatu mfululizo kutoka kwenye namba ya awali. \nKazi inarudisha orodha ya namba za tarakimu tano kama hizo. \nMfano: \n(divisible-five-digit-numbers 15) Inarudisha (22555 25555 28555 30000) \n(divisible-five-digit-numbers 7) Inarudisha orodha ya namba au 'No' kama hakuna namba kama hizo zilizopo.",
      "tr": "10000 ile 30000 arasındaki tüm beş basamaklı sayıları bulur, burada üç alt sayı (ardışık rakamlarla oluşturulan) 'k' ile bölünebilir. Her alt sayı, orijinal sayıdan üç ardışık rakamdan oluşur. Fonksiyon, bu tür beş basamaklı sayıların bir listesini döndürür.\nÖrnek:\n(divisible-five-digit-numbers 15) (22555 25555 28555 30000) döndürür\n(divisible-five-digit-numbers 7) Uygun sayıların listesini veya böyle bir sayı yoksa 'No' döndürür",
      "vi": "Tìm tất cả các số có năm chữ số giữa 10000 và 30000 mà ba số con (được tạo thành bởi các chữ số liên tiếp) chia hết cho 'k'.  \nMỗi số con bao gồm ba chữ số liên tiếp từ số gốc.  \nHàm trả về một danh sách các số có năm chữ số như vậy.  \nVí dụ:  \n(divisible-five-digit-numbers 15) Trả về (22555 25555 28555 30000)  \n(divisible-five-digit-numbers 7) Trả về danh sách các số hoặc 'Không' nếu không tồn tại số nào như vậy  "
    },
    "docstring_bertscore": {
      "es": "0.9863000653592617",
      "arb": "0.9527690721063812",
      "sw": "0.9708126559195904",
      "tr": "0.9686287148801118",
      "vi": "0.9850238651611125"
    }
  },
  {
    "task_id": "Common Lisp/30",
    "prompt": {
      "es": "(defun count-digit-two (L R)\n;; Esta función cuenta las ocurrencias del dígito '2' en todos los enteros dentro de un rango dado [L, R].\n;; Tanto L como R son inclusivos.\n;; Itera a través de cada número en el rango y cuenta cuántas veces aparece '2' en cada número.\n;; Ejemplo:\n;; >>> count-digit-two 2 22\n;; 6\n;; >>> count-digit-two 10 25\n;; 9",
      "arb": "(defun count-digit-two (L R)\n;; تقوم هذه الدالة بعدّ مرات ظهور الرقم '2' في جميع الأعداد الصحيحة ضمن النطاق المعطى [L, R].\n;; كلا من L و R مشمولان.\n;; تقوم بالمرور عبر كل عدد في النطاق وتعدّ عدد مرات ظهور '2' في كل عدد.\n;; مثال:\n;; >>> count-digit-two 2 22\n;; 6\n;; >>> count-digit-two 10 25\n;; 9",
      "sw": "(defun count-digit-two (L R)\n;; Kazi ya kazi hii ni kuhesabu mara ngapi namba '2' inatokea katika namba zote ndani ya safu iliyotolewa [L, R].\n;; L na R zote zinajumuishwa.\n;; Inapitia kila namba katika safu na kuhesabu mara ngapi '2' inatokea katika kila namba.\n;; Mfano:\n;; >>> count-digit-two 2 22\n;; 6\n;; >>> count-digit-two 10 25\n;; 9",
      "tr": "(defun count-digit-two (L R)\n;; Bu fonksiyon, verilen [L, R] aralığındaki tüm tamsayılarda '2' rakamının kaç kez geçtiğini sayar.\n;; Hem L hem de R dahildir.\n;; Aralıktaki her sayıyı iteratif olarak kontrol eder ve her sayıda '2' rakamının kaç kez göründüğünü sayar.\n;; Örnek:\n;; >>> count-digit-two 2 22\n;; 6\n;; >>> count-digit-two 10 25\n;; 9",
      "vi": "(defun count-digit-two (L R)\n;; Hàm này đếm số lần xuất hiện của chữ số '2' trong tất cả các số nguyên trong một khoảng cho trước [L, R].\n;; Cả L và R đều được bao gồm.\n;; Nó lặp qua từng số trong khoảng và đếm số lần '2' xuất hiện trong mỗi số.\n;; Ví dụ:\n;; >>> count-digit-two 2 22\n;; 6\n;; >>> count-digit-two 10 25\n;; 9"
    },
    "prompt_bertscore": {
      "es": "1",
      "arb": "0.9829738009984514",
      "sw": "0.9557820963562994",
      "tr": "0.9568745634519913",
      "vi": "0.9740304680923556"
    },
    "canonical_solution": "(let ((count 0))\n(loop for i from L to R do\n(loop for char across (write-to-string i) do\n(when (char= char #\\2) (incf count))))\ncount))",
    "instruction": {
      "es": "(defun count-digit-two (L R)\n(let ((count 0))\n(loop for i from L to R do\n(loop for char across (write-to-string i) do\n(when (char= char #\\2) (incf count))))\ncount))\n\nProporcione una descripción concisa en lenguaje natural (docstring) del código Common Lisp en español utilizando un máximo de 500 caracteres.",
      "arb": "(defun count-digit-two (L R)\n(let ((count 0))\n(loop for i from L to R do\n(loop for char across (write-to-string i) do\n(when (char= char #\\2) (incf count))))\ncount))\n\nيرجى تقديم وصف موجز بلغة طبيعية (docstring) لشفرة Common Lisp باللغة العربية الفصحى، بحيث لا يتجاوز 500 حرف.",
      "sw": "(defun count-digit-two (L R)\n(let ((count 0))\n(loop for i from L to R do\n(loop for char across (write-to-string i) do\n(when (char= char #\\2) (incf count))))\ncount))\n\nToa maelezo mafupi ya lugha ya asili (docstring) ya msimbo wa Common Lisp kwa Kiswahili kwa kutumia herufi zisizozidi 500.",
      "tr": "(defun count-digit-two (L R)\n(let ((count 0))\n(loop for i from L to R do\n(loop for char across (write-to-string i) do\n(when (char= char #\\2) (incf count))))\ncount))\n\nAşağıdaki Common Lisp kodunun işlevini açıklayan kısa bir doğal dil açıklaması (docstring) sağlayın. Açıklama Türkçe olmalı ve en fazla 500 karakter kullanılmalıdır.",
      "vi": "(defun count-digit-two (L R)\n(let ((count 0))\n(loop for i from L to R do\n(loop for char across (write-to-string i) do\n(when (char= char #\\2) (incf count))))\ncount))\n\nCung cấp mô tả ngắn gọn bằng ngôn ngữ tự nhiên (docstring) cho mã Common Lisp bằng tiếng Việt, sử dụng tối đa 500 ký tự."
    },
    "instruction_bertscore": {
      "es": "0.9711352316583911",
      "arb": "0.8931430125450422",
      "sw": "0.9454739741021129",
      "tr": "0.8409377840191667",
      "vi": "0.9283341585226124"
    },
    "level": "",
    "test": "(defun test-count-digit-two ()\n(assert (equal (count-digit-two 2 22) 6))\n(assert (equal (count-digit-two 10 25) 8))\n(assert (equal (count-digit-two 1 100) 20))\n(assert (equal (count-digit-two 29 55) 4))\n(assert (equal (count-digit-two 200 250) 66)))\n\n(test-count-digit-two)",
    "entry_point": "count-digit-two",
    "signature": "(defun count-digit-two (L R)",
    "docstring": {
      "es": "Esta función cuenta las ocurrencias del dígito '2' en todos los enteros dentro de un rango dado [L, R].  \nTanto L como R son inclusivos.  \nItera a través de cada número en el rango y cuenta cuántas veces aparece '2' en cada número.  \nEjemplo:  \n>>> count-digit-two 2 22  \n6  \n>>> count-digit-two 10 25  \n9  ",
      "arb": "هذه الدالة تحسب عدد مرات ظهور الرقم '2' في جميع الأعداد الصحيحة ضمن نطاق معين [L, R].  \nكل من L و R مشمولان.  \nتقوم بالمرور عبر كل رقم في النطاق وتحسب عدد مرات ظهور '2' في كل رقم.  \nمثال:  \n>>> count-digit-two 2 22  \n6  \n>>> count-digit-two 10 25  \n9  ",
      "sw": "Kazi ya hii kazi ni kuhesabu mara ngapi tarakimu '2' inatokea katika namba zote ndani ya safu iliyotolewa [L, R].   \nZote L na R zinajumuishwa.  \nInapitia kila namba katika safu na kuhesabu mara ngapi '2' inatokea katika kila namba.  \nMfano:  \n>>> count-digit-two 2 22  \n6  \n>>> count-digit-two 10 25  \n9  ",
      "tr": "Bu fonksiyon, verilen [L, R] aralığındaki tüm tamsayılarda '2' rakamının kaç kez geçtiğini sayar.\nHem L hem de R dahildir.\nAralıktaki her sayıyı iteratif olarak kontrol eder ve her sayıda '2' rakamının kaç kez göründüğünü sayar.\nÖrnek:\n>>> count-digit-two 2 22\n6\n>>> count-digit-two 10 25\n9",
      "vi": "Hàm này đếm số lần xuất hiện của chữ số '2' trong tất cả các số nguyên trong phạm vi cho trước [L, R].  \nCả L và R đều được bao gồm.  \nNó lặp qua từng số trong phạm vi và đếm số lần '2' xuất hiện trong mỗi số.  \nVí dụ:  \n>>> count-digit-two 2 22  \n6  \n>>> count-digit-two 10 25  \n9  "
    },
    "docstring_bertscore": {
      "es": "0.9911861741023389",
      "arb": "0.9725103497862956",
      "sw": "0.8946210212103228",
      "tr": "0.9520301670889314",
      "vi": "0.9756475180243607"
    }
  },
  {
    "task_id": "Common Lisp/31",
    "prompt": {
      "es": "(defun represent-as-powers-of-two (n)\n;; Esta función toma un entero positivo 'n' y devuelve su representación como una suma de potencias de dos.\n;; Las potencias se expresan en un formato específico donde a^b se representa como a(b), y los términos se suman sin espacios.\n;; Específicamente, 2^0 se representa como 2()\n;; Ejemplo:\n;; >>> represent-as-powers-of-two(10)\n;; \"2+2(2()+2)\"\n;; >>> represent-as-powers-of-two(26)\n;; \"2+2(2()+2)+2(2(2))\"",
      "arb": "(defun represent-as-powers-of-two (n)\n;; تأخذ هذه الدالة عددًا صحيحًا موجبًا 'n' وتعيد تمثيله كمجموع لقوى العدد اثنين.\n;; يتم التعبير عن القوى بصيغة محددة حيث يتم تمثيل a^b كـ a(b)، ويتم جمع الحدود بدون مسافات.\n;; تحديدًا، يتم تمثيل 2^0 كـ 2()\n;; مثال:\n;; >>> represent-as-powers-of-two(10)\n;; \"2+2(2()+2)\"\n;; >>> represent-as-powers-of-two(26)\n;; \"2+2(2()+2)+2(2(2))\"",
      "sw": "(defun represent-as-powers-of-two (n)\n;; Kazi ya kazi hii ni kuchukua nambari nzima chanya 'n' na kurudisha uwakilishi wake kama jumla ya nguvu za mbili.\n;; Nguvu zinaonyeshwa katika muundo maalum ambapo a^b inawakilishwa kama a(b), na masharti yanaongezwa bila nafasi.\n;; Haswa, 2^0 inawakilishwa kama 2()\n;; Mfano:\n;; >>> represent-as-powers-of-two(10)\n;; \"2+2(2()+2)\"\n;; >>> represent-as-powers-of-two(26)\n;; \"2+2(2()+2)+2(2(2))\"",
      "tr": "(defun represent-as-powers-of-two (n)\n;; Bu fonksiyon pozitif bir tam sayı 'n' alır ve onu iki kuvvetlerinin toplamı olarak temsil eder.\n;; Kuvvetler, a^b'nin a(b) olarak temsil edildiği ve terimlerin boşluksuz toplandığı belirli bir formatta ifade edilir.\n;; Özellikle, 2^0, 2() olarak temsil edilir.\n;; Örnek:\n;; >>> represent-as-powers-of-two(10)\n;; \"2+2(2()+2)\"\n;; >>> represent-as-powers-of-two(26)\n;; \"2+2(2()+2)+2(2(2))\"",
      "vi": "(defun represent-as-powers-of-two (n)\n;; Hàm này nhận một số nguyên dương 'n' và trả về biểu diễn của nó dưới dạng tổng của các lũy thừa của hai. \n;; Các lũy thừa được biểu diễn trong một định dạng cụ thể, nơi a^b được biểu diễn dưới dạng a(b), và các hạng tử được cộng mà không có khoảng trắng.\n;; Cụ thể, 2^0 được biểu diễn dưới dạng 2()\n;; Ví dụ:\n;; >>> represent-as-powers-of-two(10)\n;; \"2+2(2()+2)\"\n;; >>> represent-as-powers-of-two(26)\n;; \"2+2(2()+2)+2(2(2))\""
    },
    "prompt_bertscore": {
      "es": "0.9970658320113527",
      "arb": "0.9811416343637857",
      "sw": "0.9666334727026163",
      "tr": "0.9800100370830299",
      "vi": "0.9868214701094783"
    },
    "canonical_solution": "(let ((result '()) (power 0))\n(loop while (> n 0)\ndo (progn\n(when (> (logand n 1) 0)\n(push (if (= power 1) \"2\" (format nil \"2(~a)\" (represent-as-powers-of-two power))) result))\n(setq power (+ power 1))\n(setq n (ash n -1))))\n(string-join (reverse result) \"+\")))\n(defun string-join (list separator)\n;; This function joins a list of strings with a given separator.\n(with-output-to-string (stream)\n(when list\n(write-string (first list) stream)\n(dolist (item (rest list))\n(write-string separator stream)\n(write-string item stream)))))",
    "instruction": {
      "es": "(defun represent-as-powers-of-two (n)\n(let ((result '()) (power 0))\n(loop while (> n 0)\ndo (progn\n(when (> (logand n 1) 0)\n(push (if (= power 1) \"2\" (format nil \"2(~a)\" (represent-as-powers-of-two power))) result))\n(setq power (+ power 1))\n(setq n (ash n -1))))\n(string-join (reverse result) \"+\")))\n(defun string-join (list separator)\n;; This function joins a list of strings with a given separator.\n(with-output-to-string (stream)\n(when list\n(write-string (first list) stream)\n(dolist (item (rest list))\n(write-string separator stream)\n(write-string item stream)))))\n\nProporcione una descripción concisa en lenguaje natural (docstring) del código Common Lisp en español utilizando un máximo de 500 caracteres.",
      "arb": "(defun represent-as-powers-of-two (n)\n(let ((result '()) (power 0))\n(loop while (> n 0)\ndo (progn\n(when (> (logand n 1) 0)\n(push (if (= power 1) \"2\" (format nil \"2(~a)\" (represent-as-powers-of-two power))) result))\n(setq power (+ power 1))\n(setq n (ash n -1))))\n(string-join (reverse result) \"+\")))\n(defun string-join (list separator)\n;; This function joins a list of strings with a given separator.\n(with-output-to-string (stream)\n(when list\n(write-string (first list) stream)\n(dolist (item (rest list))\n(write-string separator stream)\n(write-string item stream)))))\n\nيرجى تقديم وصف موجز بلغة طبيعية (docstring) لشفرة Common Lisp باللغة العربية الفصحى، بحيث لا يتجاوز 500 حرف.",
      "sw": "(defun represent-as-powers-of-two (n)\n(let ((result '()) (power 0))\n(loop while (> n 0)\ndo (progn\n(when (> (logand n 1) 0)\n(push (if (= power 1) \"2\" (format nil \"2(~a)\" (represent-as-powers-of-two power))) result))\n(setq power (+ power 1))\n(setq n (ash n -1))))\n(string-join (reverse result) \"+\")))\n(defun string-join (list separator)\n;; This function joins a list of strings with a given separator.\n(with-output-to-string (stream)\n(when list\n(write-string (first list) stream)\n(dolist (item (rest list))\n(write-string separator stream)\n(write-string item stream)))))\n\nToa maelezo mafupi ya lugha ya asili (docstring) ya msimbo wa Common Lisp kwa Kiswahili kwa kutumia herufi zisizozidi 500.",
      "tr": "(defun represent-as-powers-of-two (n)\n(let ((result '()) (power 0))\n(loop while (> n 0)\ndo (progn\n(when (> (logand n 1) 0)\n(push (if (= power 1) \"2\" (format nil \"2(~a)\" (represent-as-powers-of-two power))) result))\n(setq power (+ power 1))\n(setq n (ash n -1))))\n(string-join (reverse result) \"+\")))\n(defun string-join (list separator)\n;; This function joins a list of strings with a given separator.\n(with-output-to-string (stream)\n(when list\n(write-string (first list) stream)\n(dolist (item (rest list))\n(write-string separator stream)\n(write-string item stream)))))\n\nAşağıdaki Common Lisp kodunun işlevini açıklayan, en fazla 500 karakter uzunluğunda, özlü bir doğal dil açıklaması (docstring) sağlayın.",
      "vi": "(defun represent-as-powers-of-two (n)\n(let ((result '()) (power 0))\n(loop while (> n 0)\ndo (progn\n(when (> (logand n 1) 0)\n(push (if (= power 1) \"2\" (format nil \"2(~a)\" (represent-as-powers-of-two power))) result))\n(setq power (+ power 1))\n(setq n (ash n -1))))\n(string-join (reverse result) \"+\")))\n(defun string-join (list separator)\n;; This function joins a list of strings with a given separator.\n(with-output-to-string (stream)\n(when list\n(write-string (first list) stream)\n(dolist (item (rest list))\n(write-string separator stream)\n(write-string item stream)))))\n\nCung cấp mô tả ngắn gọn bằng ngôn ngữ tự nhiên (docstring) cho mã Common Lisp bằng tiếng Việt, sử dụng tối đa 500 ký tự."
    },
    "instruction_bertscore": {
      "es": "0.9711352316583911",
      "arb": "0.9060988777784239",
      "sw": "0.9127128722061235",
      "tr": "0.8605124108093929",
      "vi": "0.940954537042426"
    },
    "level": "",
    "test": "(defun test-represent-as-powers-of-two ()\n(assert (equal (represent-as-powers-of-two 10) \"2+2(2()+2)\"))\n(assert (equal (represent-as-powers-of-two 26) \"2+2(2()+2)+2(2(2))\"))\n(assert (equal (represent-as-powers-of-two 1) \"2()\"))\n(assert (equal (represent-as-powers-of-two 31) \"2()+2+2(2)+2(2()+2)+2(2(2))\"))\n(assert (equal (represent-as-powers-of-two 100) \"2(2)+2(2()+2(2))+2(2+2(2))\")))\n\n(test-represent-as-powers-of-two)",
    "entry_point": "represent-as-powers-of-two",
    "signature": "(defun represent-as-powers-of-two (n)",
    "docstring": {
      "es": "Esta función toma un entero positivo 'n' y devuelve su representación como una suma de potencias de dos. \nLas potencias se expresan en un formato específico donde a^b se representa como a(b), y los términos se suman sin espacios.\nEspecíficamente, 2^0 se representa como 2()\nEjemplo:\n>>> represent-as-powers-of-two(10)\n\"2+2(2()+2)\"\n>>> represent-as-powers-of-two(26)\n\"2+2(2()+2)+2(2(2))\"",
      "arb": "هذه الدالة تأخذ عددًا صحيحًا موجبًا 'n' وتعيد تمثيله كمجموع لقوى العدد اثنين. \nيتم التعبير عن القوى بصيغة محددة حيث يتم تمثيل a^b كـ a(b)، ويتم جمع الحدود بدون فراغات.\nتحديدًا، يتم تمثيل 2^0 كـ 2()\nمثال:\n>>> represent-as-powers-of-two(10)\n\"2+2(2()+2)\"\n>>> represent-as-powers-of-two(26)\n\"2+2(2()+2)+2(2(2))\"",
      "sw": "Kazi ya kazi hii ni kuchukua nambari nzima chanya 'n' na kurudisha uwakilishi wake kama jumla ya nguvu za mbili. \nNguvu zinaonyeshwa katika muundo maalum ambapo a^b inawakilishwa kama a(b), na masharti yanajumlishwa bila nafasi.\nHasa, 2^0 inawakilishwa kama 2()\nMfano:\n>>> represent-as-powers-of-two(10)\n\"2+2(2()+2)\"\n>>> represent-as-powers-of-two(26)\n\"2+2(2()+2)+2(2(2))\"",
      "tr": "Bu fonksiyon pozitif bir tamsayı 'n' alır ve bunu iki kuvvetlerinin toplamı olarak temsil eder. \nKuvvetler, a^b ifadesinin a(b) olarak temsil edildiği belirli bir formatta ifade edilir ve terimler boşluksuz olarak toplanır.\nÖzellikle, 2^0 ifadesi 2() olarak temsil edilir.\nÖrnek:\n>>> represent-as-powers-of-two(10)\n\"2+2(2()+2)\"\n>>> represent-as-powers-of-two(26)\n\"2+2(2()+2)+2(2(2))\"",
      "vi": "Hàm này nhận một số nguyên dương 'n' và trả về biểu diễn của nó dưới dạng tổng của các lũy thừa của hai. \nCác lũy thừa được biểu diễn theo định dạng cụ thể, trong đó a^b được biểu diễn dưới dạng a(b), và các hạng tử được cộng mà không có khoảng trắng.\nCụ thể, 2^0 được biểu diễn dưới dạng 2()\nVí dụ:\n>>> represent-as-powers-of-two(10)\n\"2+2(2()+2)\"\n>>> represent-as-powers-of-two(26)\n\"2+2(2()+2)+2(2(2))\""
    },
    "docstring_bertscore": {
      "es": "0.9965376738281808",
      "arb": "0.9805538870663034",
      "sw": "0.9679114605741949",
      "tr": "0.9655529234297866",
      "vi": "0.9848000087216863"
    }
  },
  {
    "task_id": "Common Lisp/32",
    "prompt": {
      "es": "(defun create-largest-number (numbers)\n;; Esta función toma una lista de enteros positivos y los reorganiza para formar el número más grande posible.\n;; Lo hace concatenando los enteros en un orden tal que su combinación dígito a dígito produzca el valor máximo.\n;; Ejemplo:\n;; >>> create-largest-number '(56 9 45)\n;; \"95645\"\n;; >>> create-largest-number '(5 50 56)\n;; \"56550\"",
      "arb": "(defun create-largest-number (numbers)\n;; تأخذ هذه الدالة قائمة من الأعداد الصحيحة الموجبة وتعيد ترتيبها لتشكيل أكبر عدد ممكن.\n;; تقوم بذلك عن طريق دمج الأعداد بترتيب يجعل مجموع الأرقام يعطي القيمة القصوى.\n;; مثال:\n;; >>> create-largest-number '(56 9 45)\n;; \"95645\"\n;; >>> create-largest-number '(5 50 56)\n;; \"56550\"",
      "sw": "(defun create-largest-number (numbers)\n;; Kazi ya kazi hii ni kuchukua orodha ya namba nzima chanya na kuzipanga upya ili kuunda namba kubwa zaidi inayowezekana.\n;; Inafanya hivi kwa kuunganisha namba katika mpangilio ambao mchanganyiko wa tarakimu zao unatoa thamani ya juu zaidi.\n;; Mfano:\n;; >>> create-largest-number '(56 9 45)\n;; \"95645\"\n;; >>> create-largest-number '(5 50 56)\n;; \"56550\"",
      "tr": "(defun create-largest-number (numbers)\n;; Bu fonksiyon, pozitif tam sayılardan oluşan bir liste alır ve onları en büyük olası sayıyı oluşturacak şekilde yeniden düzenler.\n;; Bunu, rakam bazında kombinasyonları maksimum değeri verecek şekilde tam sayıları birleştirerek yapar.\n;; Örnek:\n;; >>> create-largest-number '(56 9 45)\n;; \"95645\"\n;; >>> create-largest-number '(5 50 56)\n;; \"56550\"",
      "vi": "(defun create-largest-number (numbers)\n;; Hàm này nhận một danh sách các số nguyên dương và sắp xếp lại chúng để tạo thành số lớn nhất có thể.\n;; Nó thực hiện điều này bằng cách nối các số nguyên theo thứ tự sao cho sự kết hợp từng chữ số của chúng tạo ra giá trị lớn nhất.\n;; Ví dụ:\n;; >>> create-largest-number '(56 9 45)\n;; \"95645\"\n;; >>> create-largest-number '(5 50 56)\n;; \"56550\""
    },
    "prompt_bertscore": {
      "es": "0.9823481152981915",
      "arb": "0.9591540457047477",
      "sw": "0.9639243529356816",
      "tr": "0.9487736219918644",
      "vi": "0.9848947554134398"
    },
    "canonical_solution": "(let ((str-numbers (mapcar #'number-to-string numbers)))\n(setf str-numbers (sort str-numbers #'larger-when-concatenated))\n(reduce (lambda (acc x) (concatenate 'string acc x)) str-numbers :initial-value \"\")))\n\n(defun number-to-string (number)\n;; Converts a number to its string representation.\n(write-to-string number))\n\n(defun larger-when-concatenated (a b)\n;; Custom comparison function for sorting.\n;; Returns T if AB is greater than BA.\n(string> (concatenate 'string a b) (concatenate 'string b a)))",
    "instruction": {
      "es": "(defun create-largest-number (numbers)\n(let ((str-numbers (mapcar #'number-to-string numbers)))\n(setf str-numbers (sort str-numbers #'larger-when-concatenated))\n(reduce (lambda (acc x) (concatenate 'string acc x)) str-numbers :initial-value \"\")))\n\n(defun number-to-string (number)\n;; Converts a number to its string representation.\n(write-to-string number))\n\n(defun larger-when-concatenated (a b)\n;; Custom comparison function for sorting.\n;; Returns T if AB is greater than BA.\n(string> (concatenate 'string a b) (concatenate 'string b a)))\n\nProporcione una descripción concisa en lenguaje natural (docstring) del código Common Lisp en español utilizando un máximo de 500 caracteres.",
      "arb": "(defun create-largest-number (numbers)\n(let ((str-numbers (mapcar #'number-to-string numbers)))\n(setf str-numbers (sort str-numbers #'larger-when-concatenated))\n(reduce (lambda (acc x) (concatenate 'string acc x)) str-numbers :initial-value \"\")))\n\n(defun number-to-string (number)\n;; Converts a number to its string representation.\n(write-to-string number))\n\n(defun larger-when-concatenated (a b)\n;; Custom comparison function for sorting.\n;; Returns T if AB is greater than BA.\n(string> (concatenate 'string a b) (concatenate 'string b a)))\n\nيرجى تقديم وصف موجز بلغة طبيعية (docstring) لكود Common Lisp باللغة العربية الفصحى، بحيث لا يتجاوز 500 حرف.",
      "sw": "(defun create-largest-number (numbers)\n(let ((str-numbers (mapcar #'number-to-string numbers)))\n(setf str-numbers (sort str-numbers #'larger-when-concatenated))\n(reduce (lambda (acc x) (concatenate 'string acc x)) str-numbers :initial-value \"\")))\n\n(defun number-to-string (number)\n;; Converts a number to its string representation.\n(write-to-string number))\n\n(defun larger-when-concatenated (a b)\n;; Custom comparison function for sorting.\n;; Returns T if AB is greater than BA.\n(string> (concatenate 'string a b) (concatenate 'string b a)))\n\nToa maelezo mafupi ya lugha asilia (docstring) ya msimbo wa Common Lisp kwa Kiswahili kwa kutumia herufi zisizozidi 500.",
      "tr": "(defun create-largest-number (numbers)\n(let ((str-numbers (mapcar #'number-to-string numbers)))\n(setf str-numbers (sort str-numbers #'larger-when-concatenated))\n(reduce (lambda (acc x) (concatenate 'string acc x)) str-numbers :initial-value \"\")))\n\n(defun number-to-string (number)\n;; Converts a number to its string representation.\n(write-to-string number))\n\n(defun larger-when-concatenated (a b)\n;; Custom comparison function for sorting.\n;; Returns T if AB is greater than BA.\n(string> (concatenate 'string a b) (concatenate 'string b a)))\n\nAşağıdaki Common Lisp kodunun işlevini açıklayan, en fazla 500 karakter uzunluğunda bir doğal dil açıklaması (docstring) sağlayın.",
      "vi": "(defun create-largest-number (numbers)\n(let ((str-numbers (mapcar #'number-to-string numbers)))\n(setf str-numbers (sort str-numbers #'larger-when-concatenated))\n(reduce (lambda (acc x) (concatenate 'string acc x)) str-numbers :initial-value \"\")))\n\n(defun number-to-string (number)\n;; Converts a number to its string representation.\n(write-to-string number))\n\n(defun larger-when-concatenated (a b)\n;; Custom comparison function for sorting.\n;; Returns T if AB is greater than BA.\n(string> (concatenate 'string a b) (concatenate 'string b a)))\n\nCung cấp mô tả ngắn gọn bằng ngôn ngữ tự nhiên (docstring) cho mã Common Lisp bằng tiếng Việt với tối đa 500 ký tự."
    },
    "instruction_bertscore": {
      "es": "0.9711352316583911",
      "arb": "0.8931430125450422",
      "sw": "0.9454739741021129",
      "tr": "0.8405576054698659",
      "vi": "0.9055975346966918"
    },
    "level": "",
    "test": "(defun test-create-largest-number ()\n(assert (string= (create-largest-number '(56 9 45)) \"95645\"))\n(assert (string= (create-largest-number '(5 50 56)) \"56550\"))\n(assert (string= (create-largest-number '(3 34 302 50)) \"50343302\"))\n(assert (string= (create-largest-number '(10 2 23)) \"23210\"))\n(assert (string= (create-largest-number '(4 42 40 400)) \"44240400\")))\n\n(test-create-largest-number)",
    "entry_point": "create-largest-number",
    "signature": "(defun create-largest-number (numbers)",
    "docstring": {
      "es": "Esta función toma una lista de enteros positivos y los reorganiza para formar el número más grande posible. \nLo hace concatenando los enteros en un orden tal que su combinación dígito a dígito produzca el valor máximo.\nEjemplo:\n>>> create-largest-number '(56 9 45)\n\"95645\"\n>>> create-largest-number '(5 50 56)\n\"56550\"",
      "arb": "هذه الدالة تأخذ قائمة من الأعداد الصحيحة الموجبة وتعيد ترتيبها لتكوين أكبر عدد ممكن. \nتقوم بذلك عن طريق دمج الأعداد بترتيب بحيث ينتج عن دمج الأرقام أكبر قيمة ممكنة.\nمثال:\n>>> create-largest-number '(56 9 45)\n\"95645\"\n>>> create-largest-number '(5 50 56)\n\"56550\"",
      "sw": "Kazi ya kazi hii ni kuchukua orodha ya nambari za mzima chanya na kuzipanga upya ili kuunda nambari kubwa zaidi inayowezekana. \nInafanya hivi kwa kuunganisha nambari kwa mpangilio ambao mchanganyiko wa tarakimu zao unatoa thamani ya juu zaidi.\nMfano:\n>>> create-largest-number '(56 9 45)\n\"95645\"\n>>> create-largest-number '(5 50 56)\n\"56550\"",
      "tr": "Bu fonksiyon, pozitif tamsayılar listesini alır ve en büyük olası sayıyı oluşturacak şekilde yeniden düzenler. \nBunu, rakam bazında kombinasyonları maksimum değeri verecek şekilde tamsayıları birleştirerek yapar.\nÖrnek:\n>>> create-largest-number '(56 9 45)\n\"95645\"\n>>> create-largest-number '(5 50 56)\n\"56550\"",
      "vi": "Hàm này nhận một danh sách các số nguyên dương và sắp xếp lại chúng để tạo thành số lớn nhất có thể. Nó thực hiện điều này bằng cách nối các số nguyên theo thứ tự sao cho sự kết hợp từng chữ số của chúng tạo ra giá trị lớn nhất.\n\nVí dụ:\n>>> create-largest-number '(56 9 45)\n\"95645\"\n>>> create-largest-number '(5 50 56)\n\"56550\""
    },
    "docstring_bertscore": {
      "es": "0.9784426447462836",
      "arb": "0.9448945692806341",
      "sw": "0.9445674250430696",
      "tr": "0.9438914858564079",
      "vi": "0.9759319567300025"
    }
  },
  {
    "task_id": "Common Lisp/33",
    "prompt": {
      "es": "(defun add-numbers (a b)\n\"Suma dos números.\"\n;; Ejemplo:\n;; >>> add-numbers 1 2\n;; 3",
      "arb": "(defun add-numbers (a b)\n\"جمع رقمين معًا.\"\n;; مثال:\n;; >>> add-numbers 1 2\n;; 3",
      "sw": "(defun add-numbers (a b)\n\"Ongeza namba mbili pamoja.\"\n;; Mfano:\n;; >>> add-numbers 1 2\n;; 3",
      "tr": "(defun add-numbers (a b)\n\"İki sayıyı bir araya ekle.\"\n;; Örnek:\n;; >>> add-numbers 1 2\n;; 3",
      "vi": "(defun add-numbers (a b)\n\"Thêm hai số lại với nhau.\"\n;; Ví dụ:\n;; >>> add-numbers 1 2\n;; 3"
    },
    "prompt_bertscore": {
      "es": "0.9784589324375285",
      "arb": "1",
      "sw": "1",
      "tr": "1",
      "vi": "1"
    },
    "canonical_solution": "(+ a b))",
    "instruction": {
      "es": "(defun add-numbers (a b)\n(+ a b))\n\nProporcione una descripción concisa en lenguaje natural (docstring) del código Common Lisp en español utilizando un máximo de 500 caracteres.",
      "arb": "(defun add-numbers (a b)\n(+ a b))\n\nيرجى تقديم وصف موجز بلغة طبيعية (docstring) لشيفرة Common Lisp باللغة العربية الفصحى، بحيث لا يتجاوز 500 حرف.",
      "sw": "(defun add-numbers (a b)\n(+ a b))\n\nToa maelezo mafupi ya lugha asilia (docstring) ya msimbo wa Common Lisp kwa Kiswahili kwa kutumia herufi zisizozidi 500.",
      "tr": "(defun add-numbers (a b)\n(+ a b))\n\nAşağıdaki Common Lisp kodunun doğal dilde kısa bir açıklamasını (docstring) Türkçe olarak en fazla 500 karakter kullanarak sağlayın.",
      "vi": "(defun add-numbers (a b)\n(+ a b))\n\nCung cấp mô tả ngắn gọn bằng ngôn ngữ tự nhiên (docstring) cho mã Common Lisp bằng tiếng Việt, sử dụng tối đa 500 ký tự."
    },
    "instruction_bertscore": {
      "es": "0.9711352316583911",
      "arb": "0.8841158576181497",
      "sw": "0.9454739741021129",
      "tr": "0.847469346838737",
      "vi": "0.9119165630085547"
    },
    "level": "",
    "test": "(defun test_add()\n(assert (equal (add-numbers 1 2) 3))\n(assert (equal (add-numbers 20 10) 30))\n(assert (equal (add-numbers -1 -2) -3))\n)\n;; 运行测试\n(test_add)",
    "entry_point": "add-numbers",
    "signature": "(defun add-numbers (a b)",
    "docstring": {
      "es": "\"Sumar dos números juntos.\"\nEjemplo:\n>>> add-numbers 1 2\n3",
      "arb": "\"جمع رقمين معًا.\"\nمثال:\n>>> add-numbers 1 2\n3",
      "sw": "\"Ongeza namba mbili pamoja.\"  \nMfano:  \n>>> add-numbers 1 2  \n3",
      "tr": "\"İki sayıyı topla.\"\nÖrnek:\n>>> add-numbers 1 2\n3",
      "vi": "\"Thêm hai số lại với nhau.\"\nVí dụ:\n>>> add-numbers 1 2\n3"
    },
    "docstring_bertscore": {
      "es": "1",
      "arb": "1",
      "sw": "1",
      "tr": "0.9674897682752578",
      "vi": "1"
    }
  },
  {
    "task_id": "Common Lisp/34",
    "prompt": {
      "es": "(defun count-valid-sequences (n)\n;; Esta función calcula el número de secuencias válidas que se pueden formar a partir de un número entero positivo 'n'.\n;; Una secuencia válida es aquella que comienza con 'n' y puede tener números adicionales añadidos, cada uno no más de la mitad del último número en la secuencia.\n;; Ejemplo:\n;; >>> count-valid-sequences 6\n;; 6\n;; >>> count-valid-sequences 4\n;; 4",
      "arb": "(defun count-valid-sequences (n)\n;; هذه الدالة تحسب عدد التسلسلات الصحيحة التي يمكن تشكيلها من عدد صحيح موجب 'n'.\n;; التسلسل الصحيح هو الذي يبدأ بـ 'n' ويمكن إضافة أرقام إضافية إليه، بحيث لا يزيد كل رقم عن نصف الرقم الأخير في التسلسل.\n;; مثال:\n;; >>> count-valid-sequences 6\n;; 6\n;; >>> count-valid-sequences 4\n;; 4",
      "sw": "(defun count-valid-sequences (n)\n;; Kazi ya kazi hii ni kuhesabu idadi ya mfuatano halali ambao unaweza kuundwa kutoka kwa nambari chanya 'n' iliyotolewa.\n;; Mfuatano halali ni ule unaoanza na 'n' na unaweza kuwa na nambari za ziada zilizoongezwa, kila moja isiwe zaidi ya nusu ya nambari ya mwisho katika mfuatano.\n;; Mfano:\n;; >>> count-valid-sequences 6\n;; 6\n;; >>> count-valid-sequences 4\n;; 4",
      "tr": "(defun count-valid-sequences (n)\n;; Bu fonksiyon, verilen bir pozitif tam sayı 'n' ile oluşturulabilecek geçerli dizilerin sayısını hesaplar.\n;; Geçerli bir dizi, 'n' ile başlayan ve dizideki son sayının yarısından fazla olmayan ek sayılar eklenebilen bir dizidir.\n;; Örnek:\n;; >>> count-valid-sequences 6\n;; 6\n;; >>> count-valid-sequences 4\n;; 4",
      "vi": "(defun count-valid-sequences (n)\n;; Hàm này tính toán số lượng dãy hợp lệ có thể được tạo từ một số nguyên dương 'n' cho trước.\n;; Một dãy hợp lệ là dãy bắt đầu với 'n' và có thể có thêm các số được thêm vào, mỗi số không lớn hơn một nửa số cuối cùng trong dãy.\n;; Ví dụ:\n;; >>> count-valid-sequences 6\n;; 6\n;; >>> count-valid-sequences 4\n;; 4"
    },
    "prompt_bertscore": {
      "es": "0.9877858206094027",
      "arb": "0.9576090986010583",
      "sw": "0.9585384901539206",
      "tr": "0.9712595742769189",
      "vi": "0.9799798452651126"
    },
    "canonical_solution": "(if (= n 1) \n1 \n(1+ (reduce #'+ (mapcar #'count-valid-sequences (loop for i from 1 to (/ n 2) collect i))))))",
    "instruction": {
      "es": "(defun count-valid-sequences (n)\n(if (= n 1) \n1 \n(1+ (reduce #'+ (mapcar #'count-valid-sequences (loop for i from 1 to (/ n 2) collect i))))))\n\nProporcione una descripción concisa en lenguaje natural (docstring) del código Common Lisp en español utilizando un máximo de 500 caracteres.",
      "arb": "(defun count-valid-sequences (n)\n(if (= n 1) \n1 \n(1+ (reduce #'+ (mapcar #'count-valid-sequences (loop for i from 1 to (/ n 2) collect i))))))\n\nيرجى تقديم وصف موجز بلغة طبيعية (docstring) لشفرة Common Lisp باللغة العربية الفصحى، باستخدام ما لا يزيد عن 500 حرف.",
      "sw": "(defun count-valid-sequences (n)\n(if (= n 1) \n1 \n(1+ (reduce #'+ (mapcar #'count-valid-sequences (loop for i from 1 to (/ n 2) collect i))))))\n\nToa maelezo mafupi ya lugha ya asili (docstring) ya msimbo wa Common Lisp kwa Kiswahili kwa kutumia herufi zisizozidi 500.",
      "tr": "(defun count-valid-sequences (n)\n(if (= n 1) \n1 \n(1+ (reduce #'+ (mapcar #'count-valid-sequences (loop for i from 1 to (/ n 2) collect i))))))\n\nAşağıdaki Common Lisp kodunun işlevini açıklayan, en fazla 500 karakter uzunluğunda bir doğal dil açıklaması (docstring) sağlayın. Açıklama Türkçe olmalıdır.",
      "vi": "(defun count-valid-sequences (n)\n(if (= n 1) \n1 \n(1+ (reduce #'+ (mapcar #'count-valid-sequences (loop for i from 1 to (/ n 2) collect i))))))\n\nCung cấp mô tả ngắn gọn bằng ngôn ngữ tự nhiên (docstring) cho mã Common Lisp bằng tiếng Việt, sử dụng tối đa 500 ký tự."
    },
    "instruction_bertscore": {
      "es": "0.9711352316583911",
      "arb": "0.9204950119046894",
      "sw": "0.9454739741021129",
      "tr": "0.8389939871103593",
      "vi": "0.9283341585226124"
    },
    "level": "",
    "test": "(defun test-count-valid-sequences ()\n(assert (equal (count-valid-sequences 6) 6))\n(assert (equal (count-valid-sequences 4) 4))\n(assert (equal (count-valid-sequences 10) 14))\n(assert (equal (count-valid-sequences 2) 2))\n(assert (equal (count-valid-sequences 1) 1)))\n\n(test-count-valid-sequences)",
    "entry_point": "count-valid-sequences",
    "signature": "(defun count-valid-sequences (n)",
    "docstring": {
      "es": "Esta función calcula el número de secuencias válidas que se pueden formar a partir de un entero positivo 'n'.\nUna secuencia válida es aquella que comienza con 'n' y puede tener números adicionales añadidos, cada uno no más de la mitad del último número en la secuencia.\nEjemplo:\n>>> count-valid-sequences 6\n6\n>>> count-valid-sequences 4\n4",
      "arb": "هذه الدالة تحسب عدد التسلسلات الصحيحة التي يمكن تشكيلها من عدد صحيح موجب 'n' معطى. التسلسل الصحيح هو الذي يبدأ بـ 'n' ويمكن إضافة أرقام إضافية له، بحيث لا يزيد كل رقم عن نصف الرقم الأخير في التسلسل.\n\nمثال:\n>>> count-valid-sequences 6\n6\n>>> count-valid-sequences 4\n4",
      "sw": "Kazi ya kazi hii ni kuhesabu idadi ya mlolongo halali ambao unaweza kuundwa kutoka kwa nambari chanya 'n' iliyotolewa. Mlolongo halali ni ule unaoanza na 'n' na unaweza kuwa na nambari za ziada zilizoongezwa, kila moja isiwe zaidi ya nusu ya nambari ya mwisho katika mlolongo. Mfano:\n>>> count-valid-sequences 6\n6\n>>> count-valid-sequences 4\n4",
      "tr": "Bu fonksiyon, verilen pozitif bir tamsayı 'n' ile oluşturulabilecek geçerli dizilerin sayısını hesaplar.\nGeçerli bir dizi, 'n' ile başlayan ve dizideki son sayının yarısından fazla olmayan ek sayılar eklenebilen bir dizidir.\nÖrnek:\n>>> count-valid-sequences 6\n6\n>>> count-valid-sequences 4\n4",
      "vi": "Hàm này tính toán số lượng dãy hợp lệ có thể được tạo ra từ một số nguyên dương 'n' cho trước.  \nMột dãy hợp lệ là dãy bắt đầu với 'n' và có thể có thêm các số được nối vào, mỗi số không lớn hơn một nửa số cuối cùng trong dãy.  \nVí dụ:  \n>>> count-valid-sequences 6  \n6  \n>>> count-valid-sequences 4  \n4  "
    },
    "docstring_bertscore": {
      "es": "0.98681412078538",
      "arb": "0.9598742794663802",
      "sw": "0.9457073647998289",
      "tr": "0.9612154317991277",
      "vi": "0.9755255589704053"
    }
  },
  {
    "task_id": "Common Lisp/35",
    "prompt": {
      "es": "(defun construct-preorder (inorder postorder)\n;; Esta función reconstruye el recorrido en preorden de un árbol binario a partir de sus recorridos en inorder y postorder.\n;; Los nodos del árbol binario están representados por letras mayúsculas distintas.\n;; Se asume que el árbol no tiene más de 8 nodos.\n;; Ejemplo:\n;; >>> construct-preorder \"DBEAC\" \"DEBCA\"\n;; \"ABCDE\"\n;; >>> construct-preorder \"HGFEIDBA\" \"HGFIEDBA\"\n;; \"ABDEFGHI\"",
      "arb": "(defun construct-preorder (inorder postorder)\n;; تقوم هذه الدالة بإعادة بناء الترتيب السابق لزيارة شجرة ثنائية من ترتيبي الزيارة الداخلي والزيارة اللاحق.\n;; يتم تمثيل عقد الشجرة الثنائية بأحرف كبيرة مميزة.\n;; يُفترض أن الشجرة لا تحتوي على أكثر من 8 عقد.\n;; مثال:\n;; >>> construct-preorder \"DBEAC\" \"DEBCA\"\n;; \"ABCDE\"\n;; >>> construct-preorder \"HGFEIDBA\" \"HGFIEDBA\"\n;; \"ABDEFGHI\"",
      "sw": "(defun construct-preorder (inorder postorder)\n;; Kazi ya hii kazi ni kujenga upya mpangilio wa preorder wa mti wa binary kutoka kwa mpangilio wake wa inorder na postorder.\n;; Node za mti wa binary zinawakilishwa na herufi kubwa tofauti.\n;; Inadhaniwa kuwa mti hauna zaidi ya node 8.\n;; Mfano:\n;; >>> construct-preorder \"DBEAC\" \"DEBCA\"\n;; \"ABCDE\"\n;; >>> construct-preorder \"HGFEIDBA\" \"HGFIEDBA\"\n;; \"ABDEFGHI\"",
      "tr": "(defun construct-preorder (inorder postorder)\n;; Bu fonksiyon, bir ikili ağacın inorder ve postorder traversallarından preorder traversalını yeniden oluşturur.\n;; İkili ağacın düğümleri, farklı büyük harflerle temsil edilir.\n;; Ağacın 8'den fazla düğümü olmadığı varsayılır.\n;; Örnek:\n;; >>> construct-preorder \"DBEAC\" \"DEBCA\"\n;; \"ABCDE\"\n;; >>> construct-preorder \"HGFEIDBA\" \"HGFIEDBA\"\n;; \"ABDEFGHI\"",
      "vi": "(defun construct-preorder (inorder postorder)\n;; Hàm này tái tạo lại duyệt trước của một cây nhị phân từ duyệt giữa và duyệt sau của nó.\n;; Các nút của cây nhị phân được biểu diễn bằng các chữ cái viết hoa khác nhau.\n;; Giả sử rằng cây không có nhiều hơn 8 nút.\n;; Ví dụ:\n;; >>> construct-preorder \"DBEAC\" \"DEBCA\"\n;; \"ABCDE\"\n;; >>> construct-preorder \"HGFEIDBA\" \"HGFIEDBA\"\n;; \"ABDEFGHI\""
    },
    "prompt_bertscore": {
      "es": "0.999999801369619",
      "arb": "0.9916988391157899",
      "sw": "0.9626839062061187",
      "tr": "0.9912284823734994",
      "vi": "0.9855107082250291"
    },
    "canonical_solution": "(when (and inorder postorder (not (zerop (length postorder))))\n(let* ((root (char postorder (1- (length postorder))))\n(root-pos (position root inorder)))\n(concatenate 'string\n(string root)\n(construct-preorder (subseq inorder 0 root-pos)\n(subseq postorder 0 root-pos))\n(construct-preorder (subseq inorder (1+ root-pos))\n(subseq postorder root-pos (1- (length postorder))))))))",
    "instruction": {
      "es": "(defun construct-preorder (inorder postorder)\n(when (and inorder postorder (not (zerop (length postorder))))\n(let* ((root (char postorder (1- (length postorder))))\n(root-pos (position root inorder)))\n(concatenate 'string\n(string root)\n(construct-preorder (subseq inorder 0 root-pos)\n(subseq postorder 0 root-pos))\n(construct-preorder (subseq inorder (1+ root-pos))\n(subseq postorder root-pos (1- (length postorder))))))))\n\nProporcione una descripción concisa en lenguaje natural (docstring) del código Common Lisp en español utilizando un máximo de 500 caracteres.",
      "arb": "(defun construct-preorder (inorder postorder)\n(when (and inorder postorder (not (zerop (length postorder))))\n(let* ((root (char postorder (1- (length postorder))))\n(root-pos (position root inorder)))\n(concatenate 'string\n(string root)\n(construct-preorder (subseq inorder 0 root-pos)\n(subseq postorder 0 root-pos))\n(construct-preorder (subseq inorder (1+ root-pos))\n(subseq postorder root-pos (1- (length postorder))))))))\n\nيرجى تقديم وصف موجز بلغة طبيعية (docstring) لشفرة Common Lisp باللغة العربية الفصحى، بحيث لا يتجاوز 500 حرف.",
      "sw": "(defun construct-preorder (inorder postorder)\n(when (and inorder postorder (not (zerop (length postorder))))\n(let* ((root (char postorder (1- (length postorder))))\n(root-pos (position root inorder)))\n(concatenate 'string\n(string root)\n(construct-preorder (subseq inorder 0 root-pos)\n(subseq postorder 0 root-pos))\n(construct-preorder (subseq inorder (1+ root-pos))\n(subseq postorder root-pos (1- (length postorder))))))))\n\nToa maelezo mafupi ya lugha asilia (docstring) ya msimbo wa Common Lisp kwa Kiswahili kwa kutumia herufi zisizozidi 500.",
      "tr": "(defun construct-preorder (inorder postorder)\n(when (and inorder postorder (not (zerop (length postorder))))\n(let* ((root (char postorder (1- (length postorder))))\n(root-pos (position root inorder)))\n(concatenate 'string\n(string root)\n(construct-preorder (subseq inorder 0 root-pos)\n(subseq postorder 0 root-pos))\n(construct-preorder (subseq inorder (1+ root-pos))\n(subseq postorder root-pos (1- (length postorder))))))))\n\nAşağıdaki Common Lisp kodunun işlevini açıklayan, en fazla 500 karakter uzunluğunda bir doğal dil açıklaması (docstring) sağlayın.",
      "vi": "(defun construct-preorder (inorder postorder)\n(when (and inorder postorder (not (zerop (length postorder))))\n(let* ((root (char postorder (1- (length postorder))))\n(root-pos (position root inorder)))\n(concatenate 'string\n(string root)\n(construct-preorder (subseq inorder 0 root-pos)\n(subseq postorder 0 root-pos))\n(construct-preorder (subseq inorder (1+ root-pos))\n(subseq postorder root-pos (1- (length postorder))))))))\n\nCung cấp mô tả ngắn gọn bằng ngôn ngữ tự nhiên (docstring) cho mã Common Lisp bằng tiếng Việt, sử dụng tối đa 500 ký tự."
    },
    "instruction_bertscore": {
      "es": "0.9711352316583911",
      "arb": "0.8811860594978851",
      "sw": "0.9454739741021129",
      "tr": "0.8405576054698659",
      "vi": "0.9119165630085547"
    },
    "level": "",
    "test": "(defun test-construct-preorder ()\n(assert (string= (construct-preorder \"DBEAC\" \"DEBCA\") \"ABDEC\"))\n(assert (string= (construct-preorder \"HGFEIDBA\" \"HGFIEDBA\") \"ABDEFGHI\"))\n(assert (string= (construct-preorder \"BADC\" \"BDCA\") \"ABCD\"))\n(assert (string= (construct-preorder \"FBAEDC\" \"FBEADC\") \"CDABFE\"))\n(assert (string= (construct-preorder \"A\" \"A\") \"A\")))\n\n(test-construct-preorder)",
    "entry_point": "construct-preorder",
    "signature": "(defun construct-preorder (inorder postorder)",
    "docstring": {
      "es": "Esta función reconstruye el recorrido en preorden de un árbol binario a partir de sus recorridos en inorder y postorder.  \nLos nodos del árbol binario están representados por letras mayúsculas distintas.  \nSe asume que el árbol no tiene más de 8 nodos.  \nEjemplo:  \n>>> construct-preorder \"DBEAC\" \"DEBCA\"  \n\"ABCDE\"  \n>>> construct-preorder \"HGFEIDBA\" \"HGFIEDBA\"  \n\"ABDEFGHI\"  ",
      "arb": "هذه الدالة تعيد بناء الترتيب المسبق لاجتياز شجرة ثنائية من اجتيازها داخل الترتيب وبعد الترتيب.\nيتم تمثيل عقد الشجرة الثنائية بحروف كبيرة مميزة.\nيُفترض أن الشجرة لا تحتوي على أكثر من 8 عقد.\nمثال:\n>>> construct-preorder \"DBEAC\" \"DEBCA\"\n\"ABCDE\"\n>>> construct-preorder \"HGFEIDBA\" \"HGFIEDBA\"\n\"ABDEFGHI\"",
      "sw": "Kazi ya kazi hii ni kujenga upya mpangilio wa awali wa mti wa binary kutoka kwa mipangilio yake ya inorder na postorder. \nNodi za mti wa binary zinawakilishwa na herufi kubwa za kipekee. \nInadhaniwa kuwa mti hauna zaidi ya nodi 8. \nMfano:\n>>> construct-preorder \"DBEAC\" \"DEBCA\"\n\"ABCDE\"\n>>> construct-preorder \"HGFEIDBA\" \"HGFIEDBA\"\n\"ABDEFGHI\"",
      "tr": "Bu fonksiyon, bir ikili ağacın öncelik sırasını, sıralı ve son sıralı geçişlerinden yeniden oluşturur.  \nİkili ağacın düğümleri, farklı büyük harflerle temsil edilir.  \nAğacın 8'den fazla düğüme sahip olmadığı varsayılır.  \nÖrnek:  \n>>> construct-preorder \"DBEAC\" \"DEBCA\"  \n\"ABCDE\"  \n>>> construct-preorder \"HGFEIDBA\" \"HGFIEDBA\"  \n\"ABDEFGHI\"  ",
      "vi": "Hàm này tái tạo lại duyệt trước của một cây nhị phân từ duyệt giữa và duyệt sau của nó.  \nCác nút của cây nhị phân được biểu diễn bằng các chữ cái in hoa khác nhau.  \nGiả sử rằng cây không có nhiều hơn 8 nút.  \nVí dụ:  \n>>> construct-preorder \"DBEAC\" \"DEBCA\"  \n\"ABCDE\"  \n>>> construct-preorder \"HGFEIDBA\" \"HGFIEDBA\"  \n\"ABDEFGHI\"  "
    },
    "docstring_bertscore": {
      "es": "1",
      "arb": "0.993521074231404",
      "sw": "0.9468788867871726",
      "tr": "0.9901252892372315",
      "vi": "0.9846957277716429"
    }
  },
  {
    "task_id": "Common Lisp/36",
    "prompt": {
      "es": "(defun count-prime-sums (numbers k)\n;; Esta función cuenta el número de maneras de seleccionar 'k' enteros de una lista de 'n' enteros de tal manera que su suma sea un número primo.\n;; Considera todas las combinaciones posibles de 'k' enteros de la lista y verifica si su suma es prima.\n;; Ejemplo:\n;; >>> count-prime-sums '(1 2 3 4) 2\n;; 2 ; (1+2) y (3+4) son primos\n;; >>> count-prime-sums '(1 2 3 4 5 6) 3\n;; 1 ; Solo (1+2+5) es primo",
      "arb": "(defun count-prime-sums (numbers k)\n;; هذه الدالة تحسب عدد الطرق لاختيار 'k' أعداد صحيحة من قائمة تحتوي على 'n' أعداد صحيحة بحيث يكون مجموعها عددًا أوليًا.\n;; تأخذ في الاعتبار جميع التراكيب الممكنة من 'k' أعداد صحيحة من القائمة وتتحقق مما إذا كان مجموعها أوليًا.\n;; مثال:\n;; >>> count-prime-sums '(1 2 3 4) 2\n;; 2 ; (1+2) و (3+4) هما أعداد أولية\n;; >>> count-prime-sums '(1 2 3 4 5 6) 3\n;; 1 ; فقط (1+2+5) هو عدد أولي",
      "sw": "(defun count-prime-sums (numbers k)\n;; Kazi ya kazi hii ni kuhesabu idadi ya njia za kuchagua nambari 'k' kutoka kwenye orodha ya nambari 'n' ili jumla yao iwe nambari ya kwanza.\n;; Inazingatia mchanganyiko wote unaowezekana wa nambari 'k' kutoka kwenye orodha na kuangalia kama jumla yao ni ya kwanza.\n;; Mfano:\n;; >>> count-prime-sums '(1 2 3 4) 2\n;; 2 ; (1+2) na (3+4) ni ya kwanza\n;; >>> count-prime-sums '(1 2 3 4 5 6) 3\n;; 1 ; Ni (1+2+5) pekee ndiyo ya kwanza",
      "tr": "(defun count-prime-sums (numbers k)\n;; Bu fonksiyon, 'n' tamsayısından oluşan bir listeden 'k' tamsayı seçmenin toplamlarının asal sayı olduğu yolların sayısını sayar.\n;; Listedeki 'k' tamsayısının tüm olası kombinasyonlarını dikkate alır ve toplamlarının asal olup olmadığını kontrol eder.\n;; Örnek:\n;; >>> count-prime-sums '(1 2 3 4) 2\n;; 2 ; (1+2) ve (3+4) asal\n;; >>> count-prime-sums '(1 2 3 4 5 6) 3\n;; 1 ; Sadece (1+2+5) asal",
      "vi": "(defun count-prime-sums (numbers k)\n;; Hàm này đếm số cách chọn 'k' số nguyên từ một danh sách 'n' số nguyên sao cho tổng của chúng là một số nguyên tố.\n;; Nó xem xét tất cả các tổ hợp có thể của 'k' số nguyên từ danh sách và kiểm tra xem tổng của chúng có phải là số nguyên tố hay không.\n;; Ví dụ:\n;; >>> count-prime-sums '(1 2 3 4) 2\n;; 2 ; (1+2) và (3+4) là số nguyên tố\n;; >>> count-prime-sums '(1 2 3 4 5 6) 3\n;; 1 ; Chỉ có (1+2+5) là số nguyên tố"
    },
    "prompt_bertscore": {
      "es": "0.9950825076567192",
      "arb": "0.9836936374993219",
      "sw": "0.9622719467958523",
      "tr": "0.9906899954105137",
      "vi": "0.9859536539747369"
    },
    "canonical_solution": "(count t (mapcar (lambda (comb) (is-prime (reduce '+ comb)))\n(sum-combinations numbers k))))\n(defun is-prime (n)\n(cond ((<= n 1) nil)\n((= n 2) t)\n(t (loop for i from 2 to (isqrt n) never (zerop (mod n i))))))\n\n(defun sum-combinations (lst k)\n(if (= k 0)\n'(())\n(loop for i from 0 below (length lst)\nnconc (mapcar (lambda (x) (cons (nth i lst) x))\n(sum-combinations (subseq lst (1+ i)) (1- k))))))",
    "instruction": {
      "es": "(defun count-prime-sums (numbers k)\n(count t (mapcar (lambda (comb) (is-prime (reduce '+ comb)))\n(sum-combinations numbers k))))\n(defun is-prime (n)\n(cond ((<= n 1) nil)\n((= n 2) t)\n(t (loop for i from 2 to (isqrt n) never (zerop (mod n i))))))\n\n(defun sum-combinations (lst k)\n(if (= k 0)\n'(())\n(loop for i from 0 below (length lst)\nnconc (mapcar (lambda (x) (cons (nth i lst) x))\n(sum-combinations (subseq lst (1+ i)) (1- k))))))\n\nProporcione una descripción concisa en lenguaje natural (docstring) del código Common Lisp en español utilizando un máximo de 500 caracteres.",
      "arb": "(defun count-prime-sums (numbers k)\n(count t (mapcar (lambda (comb) (is-prime (reduce '+ comb)))\n(sum-combinations numbers k))))\n(defun is-prime (n)\n(cond ((<= n 1) nil)\n((= n 2) t)\n(t (loop for i from 2 to (isqrt n) never (zerop (mod n i))))))\n\n(defun sum-combinations (lst k)\n(if (= k 0)\n'(())\n(loop for i from 0 below (length lst)\nnconc (mapcar (lambda (x) (cons (nth i lst) x))\n(sum-combinations (subseq lst (1+ i)) (1- k))))))\n\nيرجى تقديم وصف موجز بلغة طبيعية (docstring) لشيفرة Common Lisp باللغة العربية الفصحى، بحيث لا يتجاوز 500 حرف.",
      "sw": "(defun count-prime-sums (numbers k)\n(count t (mapcar (lambda (comb) (is-prime (reduce '+ comb)))\n(sum-combinations numbers k))))\n(defun is-prime (n)\n(cond ((<= n 1) nil)\n((= n 2) t)\n(t (loop for i from 2 to (isqrt n) never (zerop (mod n i))))))\n\n(defun sum-combinations (lst k)\n(if (= k 0)\n'(())\n(loop for i from 0 below (length lst)\nnconc (mapcar (lambda (x) (cons (nth i lst) x))\n(sum-combinations (subseq lst (1+ i)) (1- k))))))\n\nToa maelezo mafupi ya lugha asilia (docstring) ya msimbo wa Common Lisp kwa Kiswahili kwa kutumia herufi zisizozidi 500.",
      "tr": "(defun count-prime-sums (numbers k)\n(count t (mapcar (lambda (comb) (is-prime (reduce '+ comb)))\n(sum-combinations numbers k))))\n(defun is-prime (n)\n(cond ((<= n 1) nil)\n((= n 2) t)\n(t (loop for i from 2 to (isqrt n) never (zerop (mod n i))))))\n\n(defun sum-combinations (lst k)\n(if (= k 0)\n'(())\n(loop for i from 0 below (length lst)\nnconc (mapcar (lambda (x) (cons (nth i lst) x))\n(sum-combinations (subseq lst (1+ i)) (1- k))))))\n\nAşağıdaki Common Lisp kodunun işlevini açıklayan, en fazla 500 karakterlik özlü bir doğal dil açıklaması (docstring) sağlayın.",
      "vi": "(defun count-prime-sums (numbers k)\n(count t (mapcar (lambda (comb) (is-prime (reduce '+ comb)))\n(sum-combinations numbers k))))\n(defun is-prime (n)\n(cond ((<= n 1) nil)\n((= n 2) t)\n(t (loop for i from 2 to (isqrt n) never (zerop (mod n i))))))\n\n(defun sum-combinations (lst k)\n(if (= k 0)\n'(())\n(loop for i from 0 below (length lst)\nnconc (mapcar (lambda (x) (cons (nth i lst) x))\n(sum-combinations (subseq lst (1+ i)) (1- k))))))\n\nCung cấp mô tả ngắn gọn bằng ngôn ngữ tự nhiên (docstring) cho mã Common Lisp bằng tiếng Việt, sử dụng tối đa 500 ký tự."
    },
    "instruction_bertscore": {
      "es": "0.9711352316583911",
      "arb": "0.9060988777784239",
      "sw": "0.9454739741021129",
      "tr": "0.8391211105542217",
      "vi": "0.9119165630085547"
    },
    "level": "",
    "test": "(defun test-count-prime-sums ()\n(assert (equal (count-prime-sums '(3 7 12 19) 3) 1))\n(assert (equal (count-prime-sums '(1 2 3 4) 2) 4))\n(assert (equal (count-prime-sums '(1 2 3 4 5 6) 3) 6))\n(assert (equal (count-prime-sums '(10 20 30 40) 2) 0))\n(assert (equal (count-prime-sums '(11 13 17 19 23 29) 3) 12))) \n\n(test-count-prime-sums)",
    "entry_point": "count-prime-sums",
    "signature": "(defun count-prime-sums (numbers k)",
    "docstring": {
      "es": "Esta función cuenta el número de maneras de seleccionar 'k' enteros de una lista de 'n' enteros de tal manera que su suma sea un número primo. Considera todas las combinaciones posibles de 'k' enteros de la lista y verifica si su suma es prima.\nEjemplo:\n>>> count-prime-sums '(1 2 3 4) 2\n2 ; (1+2) y (3+4) son primos\n>>> count-prime-sums '(1 2 3 4 5 6) 3\n1 ; Solo (1+2+5) es primo",
      "arb": "هذه الدالة تحسب عدد الطرق لاختيار 'k' من الأعداد الصحيحة من قائمة تحتوي على 'n' من الأعداد الصحيحة بحيث يكون مجموعها عددًا أوليًا. \nتأخذ في الاعتبار جميع التوليفات الممكنة من 'k' من الأعداد الصحيحة من القائمة وتتحقق مما إذا كان مجموعها عددًا أوليًا.\nمثال:\n>>> count-prime-sums '(1 2 3 4) 2\n2 ; (1+2) و (3+4) هما أعداد أولية\n>>> count-prime-sums '(1 2 3 4 5 6) 3\n1 ; فقط (1+2+5) هو عدد أولي",
      "sw": "Kazi ya kazi hii ni kuhesabu idadi ya njia za kuchagua nambari 'k' kutoka kwenye orodha ya nambari 'n' ili jumla yao iwe nambari ya kwanza.\nInazingatia mchanganyiko wote unaowezekana wa nambari 'k' kutoka kwenye orodha na kuangalia ikiwa jumla yao ni ya kwanza.\nMfano:\n>>> count-prime-sums '(1 2 3 4) 2\n2 ; (1+2) na (3+4) ni nambari za kwanza\n>>> count-prime-sums '(1 2 3 4 5 6) 3\n1 ; Ni (1+2+5) pekee ndiyo ya kwanza",
      "tr": "Bu fonksiyon, bir liste içindeki 'n' tamsayısından 'k' tamsayısını seçmenin toplamlarının asal sayı olacağı yolların sayısını sayar.\nListedeki 'k' tamsayısının tüm olası kombinasyonlarını dikkate alır ve toplamlarının asal olup olmadığını kontrol eder.\nÖrnek:\n>>> count-prime-sums '(1 2 3 4) 2\n2 ; (1+2) ve (3+4) asaldır\n>>> count-prime-sums '(1 2 3 4 5 6) 3\n1 ; Sadece (1+2+5) asaldır",
      "vi": "Hàm này đếm số cách chọn 'k' số nguyên từ danh sách 'n' số nguyên sao cho tổng của chúng là một số nguyên tố. Nó xem xét tất cả các tổ hợp có thể của 'k' số nguyên từ danh sách và kiểm tra xem tổng của chúng có phải là số nguyên tố không.\nVí dụ:\n>>> count-prime-sums '(1 2 3 4) 2\n2 ; (1+2) và (3+4) là số nguyên tố\n>>> count-prime-sums '(1 2 3 4 5 6) 3\n1 ; Chỉ có (1+2+5) là số nguyên tố"
    },
    "docstring_bertscore": {
      "es": "0.9953218572658663",
      "arb": "0.9741363380854472",
      "sw": "0.9563162134509022",
      "tr": "0.9858815511464212",
      "vi": "0.9841786928898091"
    }
  },
  {
    "task_id": "Common Lisp/37",
    "prompt": {
      "es": "(defun calculate-table-tennis-scores (record)\n;; Esta función toma una cadena de registros de partidos de tenis de mesa (compuesta por 'W', 'L' y 'E') \n;; y calcula las puntuaciones bajo los sistemas de 11 puntos y 21 puntos.\n;; 'W' indica un punto ganado por el jugador, 'L' indica un punto ganado por el oponente, y 'E' marca el final del registro.\n;; La función devuelve dos listas: la primera lista contiene las puntuaciones bajo el sistema de 11 puntos, \n;; y la segunda lista contiene las puntuaciones bajo el sistema de 21 puntos.\n;; Ejemplo:\n;; >>> calculate-table-tennis-scores \"WWLLWE\"\n;; ((\"2:2\") (\"2:2\"))\n;; >>> calculate-table-tennis-scores \"WWWWWWWWWWWWLWE\"\n;; ((\"11:0\" \"1:1\") (\"12:1\"))",
      "arb": "(defun calculate-table-tennis-scores (record)\n;; تأخذ هذه الدالة سلسلة من سجلات مباريات تنس الطاولة (تتكون من 'W'، 'L'، و 'E') \n;; وتحسب النقاط وفقًا لنظامي 11 نقطة و21 نقطة.\n;; 'W' تشير إلى نقطة فاز بها اللاعب، 'L' تشير إلى نقطة فاز بها الخصم، و 'E' تشير إلى نهاية السجل.\n;; تُرجع الدالة قائمتين: تحتوي القائمة الأولى على النقاط وفقًا لنظام 11 نقطة، \n;; وتحتوي القائمة الثانية على النقاط وفقًا لنظام 21 نقطة.\n;; مثال:\n;; >>> calculate-table-tennis-scores \"WWLLWE\"\n;; ((\"2:2\") (\"2:2\"))\n;; >>> calculate-table-tennis-scores \"WWWWWWWWWWWWLWE\"\n;; ((\"11:0\" \"1:1\") (\"12:1\"))",
      "sw": "(defun calculate-table-tennis-scores (record)\n;; Kazi ya kazi hii ni kuchukua rekodi ya mechi za tenisi ya meza (iliyoundwa na 'W', 'L', na 'E') \n;; na kuhesabu alama chini ya mifumo ya pointi 11 na pointi 21.\n;; 'W' inaonyesha pointi iliyoshindwa na mchezaji, 'L' inaonyesha pointi iliyoshindwa na mpinzani, na 'E' inaashiria mwisho wa rekodi.\n;; Kazi inarudisha orodha mbili: orodha ya kwanza ina alama chini ya mfumo wa pointi 11, \n;; na orodha ya pili ina alama chini ya mfumo wa pointi 21.\n;; Mfano:\n;; >>> calculate-table-tennis-scores \"WWLLWE\"\n;; ((\"2:2\") (\"2:2\"))\n;; >>> calculate-table-tennis-scores \"WWWWWWWWWWWWLWE\"\n;; ((\"11:0\" \"1:1\") (\"12:1\"))",
      "tr": "(defun calculate-table-tennis-scores (record)\n;; Bu fonksiyon, masa tenisi maç kayıtlarından oluşan bir dizeyi ('W', 'L' ve 'E' ile oluşturulmuş) alır\n;; ve 11 puanlık ve 21 puanlık sistemler altında puanları hesaplar.\n;; 'W' oyuncunun kazandığı bir puanı, 'L' rakibin kazandığı bir puanı ve 'E' kaydın sonunu belirtir.\n;; Fonksiyon iki liste döndürür: ilk liste 11 puanlık sistem altındaki puanları içerir,\n;; ve ikinci liste 21 puanlık sistem altındaki puanları içerir.\n;; Örnek:\n;; >>> calculate-table-tennis-scores \"WWLLWE\"\n;; ((\"2:2\") (\"2:2\"))\n;; >>> calculate-table-tennis-scores \"WWWWWWWWWWWWLWE\"\n;; ((\"11:0\" \"1:1\") (\"12:1\"))",
      "vi": "(defun calculate-table-tennis-scores (record)\n;; Hàm này nhận một chuỗi các bản ghi trận đấu bóng bàn (bao gồm 'W', 'L', và 'E') \n;; và tính toán điểm số theo hệ thống 11 điểm và 21 điểm.\n;; 'W' chỉ ra một điểm thắng bởi người chơi, 'L' chỉ ra một điểm thắng bởi đối thủ, và 'E' đánh dấu kết thúc bản ghi.\n;; Hàm trả về hai danh sách: danh sách đầu tiên chứa điểm số theo hệ thống 11 điểm, \n;; và danh sách thứ hai chứa điểm số theo hệ thống 21 điểm.\n;; Ví dụ:\n;; >>> calculate-table-tennis-scores \"WWLLWE\"\n;; ((\"2:2\") (\"2:2\"))\n;; >>> calculate-table-tennis-scores \"WWWWWWWWWWWWLWE\"\n;; ((\"11:0\" \"1:1\") (\"12:1\"))"
    },
    "prompt_bertscore": {
      "es": "0.9965795848385792",
      "arb": "0.9801349755927008",
      "sw": "0.9745770989009637",
      "tr": "0.9844373096459165",
      "vi": "0.9791873100447834"
    },
    "canonical_solution": "(let ((scores-11 '()) (scores-21 '()) (score-11 (cons 0 0)) (score-21 (cons 0 0)))\n(loop for char across record do\n(cond ((char= char #\\W) (incf (car score-11)) (incf (car score-21)))\n((char= char #\\L) (incf (cdr score-11)) (incf (cdr score-21)))\n((char= char #\\E)\n(progn\n(push (format nil \"~A:~A\" (car score-11) (cdr score-11)) scores-11)\n(push (format nil \"~A:~A\" (car score-21) (cdr score-21)) scores-21)\n(return))))\n(when (or (and (>= (car score-11) 11) (>= (abs (- (car score-11) (cdr score-11))) 2))\n(and (>= (cdr score-11) 11) (>= (abs (- (car score-11) (cdr score-11))) 2)))\n(push (format nil \"~A:~A\" (car score-11) (cdr score-11)) scores-11)\n(setf score-11 (cons 0 0)))\n(when (or (and (>= (car score-21) 21) (>= (abs (- (car score-21) (cdr score-21))) 2))\n(and (>= (cdr score-21) 21) (>= (abs (- (car score-21) (cdr score-21))) 2)))\n(push (format nil \"~A:~A\" (car score-21) (cdr score-21)) scores-21)\n(setf score-21 (cons 0 0))))\n(list (reverse scores-11) (reverse scores-21))))",
    "instruction": {
      "es": "(defun calculate-table-tennis-scores (record)\n(let ((scores-11 '()) (scores-21 '()) (score-11 (cons 0 0)) (score-21 (cons 0 0)))\n(loop for char across record do\n(cond ((char= char #\\W) (incf (car score-11)) (incf (car score-21)))\n((char= char #\\L) (incf (cdr score-11)) (incf (cdr score-21)))\n((char= char #\\E)\n(progn\n(push (format nil \"~A:~A\" (car score-11) (cdr score-11)) scores-11)\n(push (format nil \"~A:~A\" (car score-21) (cdr score-21)) scores-21)\n(return))))\n(when (or (and (>= (car score-11) 11) (>= (abs (- (car score-11) (cdr score-11))) 2))\n(and (>= (cdr score-11) 11) (>= (abs (- (car score-11) (cdr score-11))) 2)))\n(push (format nil \"~A:~A\" (car score-11) (cdr score-11)) scores-11)\n(setf score-11 (cons 0 0)))\n(when (or (and (>= (car score-21) 21) (>= (abs (- (car score-21) (cdr score-21))) 2))\n(and (>= (cdr score-21) 21) (>= (abs (- (car score-21) (cdr score-21))) 2)))\n(push (format nil \"~A:~A\" (car score-21) (cdr score-21)) scores-21)\n(setf score-21 (cons 0 0))))\n(list (reverse scores-11) (reverse scores-21))))\n\nProporcione una descripción concisa en lenguaje natural (docstring) del código Common Lisp en español utilizando como máximo 500 caracteres.",
      "arb": "(defun calculate-table-tennis-scores (record)\n(let ((scores-11 '()) (scores-21 '()) (score-11 (cons 0 0)) (score-21 (cons 0 0)))\n(loop for char across record do\n(cond ((char= char #\\W) (incf (car score-11)) (incf (car score-21)))\n((char= char #\\L) (incf (cdr score-11)) (incf (cdr score-21)))\n((char= char #\\E)\n(progn\n(push (format nil \"~A:~A\" (car score-11) (cdr score-11)) scores-11)\n(push (format nil \"~A:~A\" (car score-21) (cdr score-21)) scores-21)\n(return))))\n(when (or (and (>= (car score-11) 11) (>= (abs (- (car score-11) (cdr score-11))) 2))\n(and (>= (cdr score-11) 11) (>= (abs (- (car score-11) (cdr score-11))) 2)))\n(push (format nil \"~A:~A\" (car score-11) (cdr score-11)) scores-11)\n(setf score-11 (cons 0 0)))\n(when (or (and (>= (car score-21) 21) (>= (abs (- (car score-21) (cdr score-21))) 2))\n(and (>= (cdr score-21) 21) (>= (abs (- (car score-21) (cdr score-21))) 2)))\n(push (format nil \"~A:~A\" (car score-21) (cdr score-21)) scores-21)\n(setf score-21 (cons 0 0))))\n(list (reverse scores-11) (reverse scores-21))))\n\nيرجى تقديم وصف موجز بلغة طبيعية (docstring) لشفرة Common Lisp باللغة العربية الفصحى، بحيث لا يتجاوز 500 حرف.",
      "sw": "(defun calculate-table-tennis-scores (record)\n(let ((scores-11 '()) (scores-21 '()) (score-11 (cons 0 0)) (score-21 (cons 0 0)))\n(loop for char across record do\n(cond ((char= char #\\W) (incf (car score-11)) (incf (car score-21)))\n((char= char #\\L) (incf (cdr score-11)) (incf (cdr score-21)))\n((char= char #\\E)\n(progn\n(push (format nil \"~A:~A\" (car score-11) (cdr score-11)) scores-11)\n(push (format nil \"~A:~A\" (car score-21) (cdr score-21)) scores-21)\n(return))))\n(when (or (and (>= (car score-11) 11) (>= (abs (- (car score-11) (cdr score-11))) 2))\n(and (>= (cdr score-11) 11) (>= (abs (- (car score-11) (cdr score-11))) 2)))\n(push (format nil \"~A:~A\" (car score-11) (cdr score-11)) scores-11)\n(setf score-11 (cons 0 0)))\n(when (or (and (>= (car score-21) 21) (>= (abs (- (car score-21) (cdr score-21))) 2))\n(and (>= (cdr score-21) 21) (>= (abs (- (car score-21) (cdr score-21))) 2)))\n(push (format nil \"~A:~A\" (car score-21) (cdr score-21)) scores-21)\n(setf score-21 (cons 0 0))))\n(list (reverse scores-11) (reverse scores-21))))\n\nToa maelezo mafupi ya lugha ya asili (docstring) ya msimbo wa Common Lisp kwa Kiswahili kwa kutumia herufi zisizozidi 500.",
      "tr": "(defun calculate-table-tennis-scores (record)\n(let ((scores-11 '()) (scores-21 '()) (score-11 (cons 0 0)) (score-21 (cons 0 0)))\n(loop for char across record do\n(cond ((char= char #\\W) (incf (car score-11)) (incf (car score-21)))\n((char= char #\\L) (incf (cdr score-11)) (incf (cdr score-21)))\n((char= char #\\E)\n(progn\n(push (format nil \"~A:~A\" (car score-11) (cdr score-11)) scores-11)\n(push (format nil \"~A:~A\" (car score-21) (cdr score-21)) scores-21)\n(return))))\n(when (or (and (>= (car score-11) 11) (>= (abs (- (car score-11) (cdr score-11))) 2))\n(and (>= (cdr score-11) 11) (>= (abs (- (car score-11) (cdr score-11))) 2)))\n(push (format nil \"~A:~A\" (car score-11) (cdr score-11)) scores-11)\n(setf score-11 (cons 0 0)))\n(when (or (and (>= (car score-21) 21) (>= (abs (- (car score-21) (cdr score-21))) 2))\n(and (>= (cdr score-21) 21) (>= (abs (- (car score-21) (cdr score-21))) 2)))\n(push (format nil \"~A:~A\" (car score-21) (cdr score-21)) scores-21)\n(setf score-21 (cons 0 0))))\n(list (reverse scores-11) (reverse scores-21))))\n\nAşağıdaki Common Lisp kodunun işlevini açıklayan, en fazla 500 karakter uzunluğunda, özlü bir doğal dil açıklaması (docstring) sağlayın.",
      "vi": "(defun calculate-table-tennis-scores (record)\n(let ((scores-11 '()) (scores-21 '()) (score-11 (cons 0 0)) (score-21 (cons 0 0)))\n(loop for char across record do\n(cond ((char= char #\\W) (incf (car score-11)) (incf (car score-21)))\n((char= char #\\L) (incf (cdr score-11)) (incf (cdr score-21)))\n((char= char #\\E)\n(progn\n(push (format nil \"~A:~A\" (car score-11) (cdr score-11)) scores-11)\n(push (format nil \"~A:~A\" (car score-21) (cdr score-21)) scores-21)\n(return))))\n(when (or (and (>= (car score-11) 11) (>= (abs (- (car score-11) (cdr score-11))) 2))\n(and (>= (cdr score-11) 11) (>= (abs (- (car score-11) (cdr score-11))) 2)))\n(push (format nil \"~A:~A\" (car score-11) (cdr score-11)) scores-11)\n(setf score-11 (cons 0 0)))\n(when (or (and (>= (car score-21) 21) (>= (abs (- (car score-21) (cdr score-21))) 2))\n(and (>= (cdr score-21) 21) (>= (abs (- (car score-21) (cdr score-21))) 2)))\n(push (format nil \"~A:~A\" (car score-21) (cdr score-21)) scores-21)\n(setf score-21 (cons 0 0))))\n(list (reverse scores-11) (reverse scores-21))))\n\nCung cấp mô tả ngắn gọn bằng ngôn ngữ tự nhiên (docstring) cho mã Common Lisp bằng tiếng Việt, sử dụng tối đa 500 ký tự."
    },
    "instruction_bertscore": {
      "es": "0.9711352316583911",
      "arb": "0.9060988777784239",
      "sw": "0.9177628510135546",
      "tr": "0.8605124108093929",
      "vi": "0.9119165630085547"
    },
    "level": "",
    "test": "(defun test-calculate-table-tennis-scores ()\n(assert (equal (calculate-table-tennis-scores \"WWLLWE\") '((\"3:2\") (\"3:2\"))))\n(assert (equal (calculate-table-tennis-scores \"WWWWWWWWWWWWLWE\") '((\"11:0\" \"2:1\") (\"13:1\"))))\n(assert (equal (calculate-table-tennis-scores \"WLWLWLWLWLE\") '((\"5:5\") (\"5:5\"))))\n(assert (equal (calculate-table-tennis-scores \"LWE\") '((\"1:1\") (\"1:1\")))))\n\n(test-calculate-table-tennis-scores)",
    "entry_point": "calculate-table-tennis-scores",
    "signature": "(defun calculate-table-tennis-scores (record)",
    "docstring": {
      "es": "Esta función toma una cadena de registros de partidos de tenis de mesa (compuesta por 'W', 'L' y 'E') y calcula las puntuaciones bajo los sistemas de 11 puntos y 21 puntos. 'W' indica un punto ganado por el jugador, 'L' indica un punto ganado por el oponente, y 'E' marca el final del registro. La función devuelve dos listas: la primera lista contiene las puntuaciones bajo el sistema de 11 puntos, y la segunda lista contiene las puntuaciones bajo el sistema de 21 puntos. Ejemplo:\n>>> calculate-table-tennis-scores \"WWLLWE\"\n((\"2:2\") (\"2:2\"))\n>>> calculate-table-tennis-scores \"WWWWWWWWWWWWLWE\"\n((\"11:0\" \"1:1\") (\"12:1\"))",
      "arb": "هذه الدالة تأخذ سلسلة من سجلات مباريات تنس الطاولة (مكونة من 'W'، 'L'، و 'E') وتحسب النقاط وفقًا لنظامي 11 نقطة و21 نقطة. \n'W' تشير إلى نقطة فاز بها اللاعب، 'L' تشير إلى نقطة فاز بها الخصم، و 'E' تشير إلى نهاية السجل. \nتعيد الدالة قائمتين: تحتوي القائمة الأولى على النقاط وفقًا لنظام 11 نقطة، وتحتوي القائمة الثانية على النقاط وفقًا لنظام 21 نقطة.\nمثال:\n>>> calculate-table-tennis-scores \"WWLLWE\"\n((\"2:2\") (\"2:2\"))\n>>> calculate-table-tennis-scores \"WWWWWWWWWWWWLWE\"\n((\"11:0\" \"1:1\") (\"12:1\"))",
      "sw": "Kazi ya kazi hii ni kuchukua mfuatano wa rekodi za mechi za tenisi ya meza (zinazojumuisha 'W', 'L', na 'E') na kuhesabu alama chini ya mifumo ya pointi 11 na pointi 21. 'W' inaashiria pointi iliyoshindwa na mchezaji, 'L' inaashiria pointi iliyoshindwa na mpinzani, na 'E' inaashiria mwisho wa rekodi. Kazi hii inarudisha orodha mbili: orodha ya kwanza ina alama chini ya mfumo wa pointi 11, na orodha ya pili ina alama chini ya mfumo wa pointi 21. Mfano:\n>>> calculate-table-tennis-scores \"WWLLWE\"\n((\"2:2\") (\"2:2\"))\n>>> calculate-table-tennis-scores \"WWWWWWWWWWWWLWE\"\n((\"11:0\" \"1:1\") (\"12:1\"))",
      "tr": "Bu fonksiyon, masa tenisi maç kayıtlarından oluşan bir dizeyi ('W', 'L' ve 'E' ile) alır ve 11 puanlık ve 21 puanlık sistemler altında skorları hesaplar.\n'W', oyuncu tarafından kazanılan bir puanı, 'L' rakip tarafından kazanılan bir puanı ve 'E' kayıtların sonunu belirtir.\nFonksiyon iki liste döndürür: ilk liste 11 puanlık sistem altındaki skorları, ikinci liste ise 21 puanlık sistem altındaki skorları içerir.\nÖrnek:\n>>> calculate-table-tennis-scores \"WWLLWE\"\n((\"2:2\") (\"2:2\"))\n>>> calculate-table-tennis-scores \"WWWWWWWWWWWWLWE\"\n((\"11:0\" \"1:1\") (\"12:1\"))",
      "vi": "Hàm này nhận vào một chuỗi các bản ghi trận đấu bóng bàn (bao gồm 'W', 'L', và 'E') và tính toán điểm số theo hệ thống 11 điểm và 21 điểm. 'W' biểu thị một điểm thắng bởi người chơi, 'L' biểu thị một điểm thắng bởi đối thủ, và 'E' đánh dấu kết thúc của bản ghi. Hàm trả về hai danh sách: danh sách đầu tiên chứa điểm số theo hệ thống 11 điểm, và danh sách thứ hai chứa điểm số theo hệ thống 21 điểm. Ví dụ:\n>>> calculate-table-tennis-scores \"WWLLWE\"\n((\"2:2\") (\"2:2\"))\n>>> calculate-table-tennis-scores \"WWWWWWWWWWWWLWE\"\n((\"11:0\" \"1:1\") (\"12:1\"))"
    },
    "docstring_bertscore": {
      "es": "0.9951160761911142",
      "arb": "0.9759035525855146",
      "sw": "0.9684767626386201",
      "tr": "0.9770478622106566",
      "vi": "0.9754127369139775"
    }
  },
  {
    "task_id": "Common Lisp/38",
    "prompt": {
      "es": "(defun count-output-sequences (n)\n;; Esta función calcula el número total de diferentes secuencias de salida que se pueden obtener utilizando una pila\n;; con operaciones de push y pop en una secuencia de números del 1 al n.\n;; Las operaciones son:\n;; 1. Empujar el siguiente número de la secuencia de entrada en la pila.\n;; 2. Sacar el número superior de la pila y añadirlo a la secuencia de salida.\n;; Cuenta todas las posibles secuencias de estas operaciones que resultan en que todos los números sean movidos de la secuencia de entrada a la secuencia de salida.\n;; Ejemplo:\n;; >>> count-output-sequences 3\n;; 5\n;; >>> count-output-sequences 4\n;; 14",
      "arb": "(defun count-output-sequences (n)\n;; تقوم هذه الدالة بحساب العدد الإجمالي لمختلف تسلسلات الإخراج التي يمكن الحصول عليها باستخدام مكدس \n;; مع العمليات الدفع والسحب على تسلسل الأرقام من 1 إلى n.\n;; العمليات هي: \n;; 1. دفع الرقم التالي من تسلسل الإدخال إلى المكدس.\n;; 2. سحب الرقم العلوي من المكدس وإضافته إلى تسلسل الإخراج.\n;; تقوم بعد جميع التسلسلات الممكنة لهذه العمليات التي تؤدي إلى نقل جميع الأرقام من تسلسل الإدخال إلى تسلسل الإخراج.\n;; مثال:\n;; >>> count-output-sequences 3\n;; 5\n;; >>> count-output-sequences 4\n;; 14",
      "sw": "(defun count-output-sequences (n)\n;; Kazi ya hii kazi ni kuhesabu jumla ya idadi ya mlolongo tofauti wa matokeo ambayo yanaweza kupatikana kwa kutumia stack \n;; na operesheni za push na pop kwenye mlolongo wa namba kutoka 1 hadi n.\n;; Operesheni ni:\n;; 1. Push namba inayofuata kutoka kwenye mlolongo wa ingizo kwenye stack.\n;; 2. Pop namba ya juu kutoka kwenye stack na uiongeze kwenye mlolongo wa matokeo.\n;; Inahesabu mfuatano wote wa operesheni hizi ambazo zinasababisha namba zote kuhamishwa kutoka kwenye mlolongo wa ingizo hadi kwenye mlolongo wa matokeo.\n;; Mfano:\n;; >>> count-output-sequences 3\n;; 5\n;; >>> count-output-sequences 4\n;; 14",
      "tr": "(defun count-output-sequences (n)\n;; Bu fonksiyon, 1'den n'e kadar olan bir sayı dizisi üzerinde push ve pop işlemleri kullanılarak bir yığın ile elde edilebilecek farklı çıktı dizilerinin toplam sayısını hesaplar.\n;; İşlemler şunlardır:\n;; 1. Giriş dizisinden bir sonraki sayıyı yığına ekle (push).\n;; 2. Yığının en üstündeki sayıyı yığından çıkar (pop) ve çıktı dizisine ekle.\n;; Bu işlemlerin tüm sayıları giriş dizisinden çıktı dizisine taşınmasıyla sonuçlanan tüm olası dizilerini sayar.\n;; Örnek:\n;; >>> count-output-sequences 3\n;; 5\n;; >>> count-output-sequences 4\n;; 14",
      "vi": "(defun count-output-sequences (n)\n;; Hàm này tính tổng số lượng các dãy đầu ra khác nhau có thể thu được bằng cách sử dụng một ngăn xếp\n;; với các thao tác đẩy (push) và lấy ra (pop) trên một dãy số từ 1 đến n.\n;; Các thao tác là:\n;; 1. Đẩy số tiếp theo từ dãy đầu vào vào ngăn xếp.\n;; 2. Lấy số trên cùng từ ngăn xếp và thêm nó vào dãy đầu ra.\n;; Nó đếm tất cả các dãy có thể của các thao tác này mà kết quả là tất cả các số được chuyển từ dãy đầu vào sang dãy đầu ra.\n;; Ví dụ:\n;; >>> count-output-sequences 3\n;; 5\n;; >>> count-output-sequences 4\n;; 14"
    },
    "prompt_bertscore": {
      "es": "0.9897423298625964",
      "arb": "0.9810856205963339",
      "sw": "0.9656001974604729",
      "tr": "0.9479596346903835",
      "vi": "0.9860474075145853"
    },
    "canonical_solution": "(let ((dp (make-array (1+ n) :initial-element 0)))\n(setf (aref dp 0) 1)\n(loop for i from 1 to n do\n(loop for j from 0 to (1- i) do\n(incf (aref dp i) (* (aref dp j) (aref dp (1- (- i j)))))))\n(aref dp n)))",
    "instruction": {
      "es": "(defun count-output-sequences (n)\n(let ((dp (make-array (1+ n) :initial-element 0)))\n(setf (aref dp 0) 1)\n(loop for i from 1 to n do\n(loop for j from 0 to (1- i) do\n(incf (aref dp i) (* (aref dp j) (aref dp (1- (- i j)))))))\n(aref dp n)))\n\nProporcione una descripción concisa en lenguaje natural (docstring) del código Common Lisp en español utilizando como máximo 500 caracteres.",
      "arb": "(defun count-output-sequences (n)\n(let ((dp (make-array (1+ n) :initial-element 0)))\n(setf (aref dp 0) 1)\n(loop for i from 1 to n do\n(loop for j from 0 to (1- i) do\n(incf (aref dp i) (* (aref dp j) (aref dp (1- (- i j)))))))\n(aref dp n)))\n\nيرجى تقديم وصف موجز بلغة طبيعية (docstring) لشيفرة Common Lisp باللغة العربية الفصحى، بحيث لا يتجاوز 500 حرف.",
      "sw": "(defun count-output-sequences (n)\n(let ((dp (make-array (1+ n) :initial-element 0)))\n(setf (aref dp 0) 1)\n(loop for i from 1 to n do\n(loop for j from 0 to (1- i) do\n(incf (aref dp i) (* (aref dp j) (aref dp (1- (- i j)))))))\n(aref dp n)))\n\nToa maelezo mafupi ya lugha asilia (docstring) ya msimbo wa Common Lisp kwa Kiswahili kwa kutumia herufi zisizozidi 500.",
      "tr": "(defun count-output-sequences (n)\n(let ((dp (make-array (1+ n) :initial-element 0)))\n(setf (aref dp 0) 1)\n(loop for i from 1 to n do\n(loop for j from 0 to (1- i) do\n(incf (aref dp i) (* (aref dp j) (aref dp (1- (- i j)))))))\n(aref dp n)))\n\nAşağıdaki Common Lisp kodunun işlevini açıklayan kısa bir doğal dil açıklaması (docstring) sağlayın. Açıklama Türkçe olmalı ve en fazla 500 karakter kullanılmalıdır.",
      "vi": "(defun count-output-sequences (n)\n(let ((dp (make-array (1+ n) :initial-element 0)))\n(setf (aref dp 0) 1)\n(loop for i from 1 to n do\n(loop for j from 0 to (1- i) do\n(incf (aref dp i) (* (aref dp j) (aref dp (1- (- i j)))))))\n(aref dp n)))\n\nCung cấp mô tả ngắn gọn bằng ngôn ngữ tự nhiên (docstring) cho mã Common Lisp bằng tiếng Việt, sử dụng tối đa 500 ký tự."
    },
    "instruction_bertscore": {
      "es": "0.9711352316583911",
      "arb": "0.8841158576181497",
      "sw": "0.9454739741021129",
      "tr": "0.8635782707406664",
      "vi": "0.9119165630085547"
    },
    "level": "",
    "test": "(defun test-count-output-sequences ()\n(assert (equal (count-output-sequences 3) 5))\n(assert (equal (count-output-sequences 4) 14))\n(assert (equal (count-output-sequences 5) 42))\n(assert (equal (count-output-sequences 6) 132))\n(assert (equal (count-output-sequences 7) 429)))\n\n(test-count-output-sequences)",
    "entry_point": "count-output-sequences",
    "signature": "(defun count-output-sequences (n)",
    "docstring": {
      "es": "Esta función calcula el número total de diferentes secuencias de salida que se pueden obtener utilizando una pila con operaciones de push y pop en una secuencia de números del 1 al n.  \nLas operaciones son:  \n1. Empujar el siguiente número de la secuencia de entrada en la pila.  \n2. Sacar el número superior de la pila y añadirlo a la secuencia de salida.  \nCuenta todas las posibles secuencias de estas operaciones que resultan en que todos los números se muevan de la secuencia de entrada a la secuencia de salida.  \nEjemplo:  \n>>> count-output-sequences 3  \n5  \n>>> count-output-sequences 4  \n14  ",
      "arb": "هذه الدالة تحسب العدد الإجمالي لتسلسلات المخرجات المختلفة التي يمكن الحصول عليها باستخدام مكدس مع عمليات الدفع والسحب على تسلسل من الأرقام من 1 إلى n.  \nالعمليات هي:  \n1. دفع الرقم التالي من تسلسل الإدخال إلى المكدس.  \n2. سحب الرقم العلوي من المكدس وإضافته إلى تسلسل المخرجات.  \nإنها تحسب جميع التسلسلات الممكنة لهذه العمليات التي تؤدي إلى نقل جميع الأرقام من تسلسل الإدخال إلى تسلسل المخرجات.  \nمثال:  \n>>> count-output-sequences 3  \n5  \n>>> count-output-sequences 4  \n14  ",
      "sw": "Kazi ya kazi hii ni kuhesabu jumla ya idadi ya mfuatano tofauti wa matokeo yanayoweza kupatikana kwa kutumia stack na operesheni za kushinikiza (push) na kutoa (pop) kwenye mfuatano wa namba kutoka 1 hadi n. \nOperesheni ni:\n1. Kushinikiza namba inayofuata kutoka kwenye mfuatano wa ingizo kwenye stack.\n2. Kutoa namba ya juu kutoka kwenye stack na kuongeza kwenye mfuatano wa matokeo.\nInahesabu mfuatano wote unaowezekana wa operesheni hizi ambao husababisha namba zote kuhamishwa kutoka kwenye mfuatano wa ingizo kwenda kwenye mfuatano wa matokeo.\nMfano:\n>>> count-output-sequences 3\n5\n>>> count-output-sequences 4\n14",
      "tr": "Bu fonksiyon, 1'den n'e kadar olan bir sayı dizisi üzerinde yığın kullanarak elde edilebilecek farklı çıktı dizilerinin toplam sayısını hesaplar. \nİşlemler şunlardır:\n1. Giriş dizisinden bir sonraki sayıyı yığına ekleyin.\n2. Yığının en üstündeki sayıyı çıkarın ve çıktı dizisine ekleyin.\nBu işlemlerin tüm olası dizilerini sayar ve tüm sayıların giriş dizisinden çıktı dizisine taşınmasıyla sonuçlanır.\nÖrnek:\n>>> count-output-sequences 3\n5\n>>> count-output-sequences 4\n14",
      "vi": "Hàm này tính tổng số các dãy đầu ra khác nhau có thể thu được bằng cách sử dụng một ngăn xếp với các thao tác đẩy và bật trên một dãy số từ 1 đến n.  \nCác thao tác là:  \n1. Đẩy số tiếp theo từ dãy đầu vào vào ngăn xếp.  \n2. Bật số trên cùng từ ngăn xếp và thêm nó vào dãy đầu ra.  \nNó đếm tất cả các dãy có thể của các thao tác này mà kết quả là tất cả các số được chuyển từ dãy đầu vào sang dãy đầu ra.  \nVí dụ:  \n>>> count-output-sequences 3  \n5  \n>>> count-output-sequences 4  \n14  "
    },
    "docstring_bertscore": {
      "es": "0.9805080034482844",
      "arb": "0.9744587151938668",
      "sw": "0.9429011147765679",
      "tr": "0.9394656037061885",
      "vi": "0.9899071930788552"
    }
  },
  {
    "task_id": "Common Lisp/39",
    "prompt": {
      "es": "(defun max-herb-value (time-limit herb-info)\n;; Esta función calcula el valor total máximo de hierbas que se pueden recolectar dentro de un límite de tiempo dado.\n;; 'time-limit' es el tiempo total disponible para recolectar hierbas.\n;; 'herb-info' es una lista de pares, cada par contiene dos enteros: el tiempo requerido para recolectar una hierba y su valor.\n;; La función utiliza un enfoque de programación dinámica para determinar el valor máximo que se puede obtener.\n;; Ejemplo:\n;; >>> max-herb-value 70 '((71 100) (69 1) (1 2))\n;; 3\n;; >>> max-herb-value 10 '((5 5) (4 7) (3 4) (2 3))\n;; 14",
      "arb": "(defun max-herb-value (time-limit herb-info)\n;; هذه الدالة تحسب القيمة الإجمالية القصوى للأعشاب التي يمكن جمعها ضمن حد زمني معين.\n;; 'time-limit' هو إجمالي الوقت المتاح لجمع الأعشاب.\n;; 'herb-info' هو قائمة من الأزواج، كل زوج يحتوي على عددين صحيحين: الوقت المطلوب لجمع عشبة وقيمتها.\n;; تستخدم الدالة نهج البرمجة الديناميكية لتحديد القيمة القصوى التي يمكن الحصول عليها.\n;; مثال:\n;; >>> max-herb-value 70 '((71 100) (69 1) (1 2))\n;; 3\n;; >>> max-herb-value 10 '((5 5) (4 7) (3 4) (2 3))\n;; 14",
      "sw": "(defun max-herb-value (time-limit herb-info)\n;; Kazi ya hii ni kuhesabu thamani ya juu kabisa ya mimea ambayo inaweza kukusanywa ndani ya muda uliowekwa.\n;; 'time-limit' ni muda wote unaopatikana kwa ajili ya kukusanya mimea.\n;; 'herb-info' ni orodha ya jozi, kila jozi inayo namba mbili: muda unaohitajika kukusanya mmea na thamani yake.\n;; Kazi hii inatumia mbinu ya programu ya nguvu ili kuamua thamani ya juu inayoweza kupatikana.\n;; Mfano:\n;; >>> max-herb-value 70 '((71 100) (69 1) (1 2))\n;; 3\n;; >>> max-herb-value 10 '((5 5) (4 7) (3 4) (2 3))\n;; 14",
      "tr": "(defun max-herb-value (time-limit herb-info)\n;; Bu fonksiyon, belirli bir zaman sınırı içinde toplanabilecek otların maksimum toplam değerini hesaplar.\n;; 'time-limit', ot toplamak için mevcut toplam zamandır.\n;; 'herb-info', her biri iki tamsayı içeren çiftlerden oluşan bir listedir: bir otu toplamak için gereken zaman ve onun değeri.\n;; Fonksiyon, elde edilebilecek maksimum değeri belirlemek için dinamik programlama yaklaşımını kullanır.\n;; Örnek:\n;; >>> max-herb-value 70 '((71 100) (69 1) (1 2))\n;; 3\n;; >>> max-herb-value 10 '((5 5) (4 7) (3 4) (2 3))\n;; 14",
      "vi": "(defun max-herb-value (time-limit herb-info)\n;; Hàm này tính toán tổng giá trị lớn nhất của các loại thảo mộc có thể thu thập trong giới hạn thời gian cho trước.\n;; 'time-limit' là tổng thời gian có sẵn để thu thập thảo mộc.\n;; 'herb-info' là một danh sách các cặp, mỗi cặp chứa hai số nguyên: thời gian cần thiết để thu thập một loại thảo mộc và giá trị của nó.\n;; Hàm sử dụng phương pháp lập trình động để xác định giá trị lớn nhất có thể đạt được.\n;; Ví dụ:\n;; >>> max-herb-value 70 '((71 100) (69 1) (1 2))\n;; 3\n;; >>> max-herb-value 10 '((5 5) (4 7) (3 4) (2 3))\n;; 14"
    },
    "prompt_bertscore": {
      "es": "0.9979719838096338",
      "arb": "0.995565378113015",
      "sw": "0.9691125784883128",
      "tr": "0.9919447435275112",
      "vi": "0.9754909972841052"
    },
    "canonical_solution": "(let ((dp (make-array (1+ time-limit) :initial-element 0)))\n(loop for (time value) in herb-info do\n(loop for current-time from time-limit downto time do\n(setf (aref dp current-time) \n(max (aref dp current-time) \n(+ value (aref dp (- current-time time)))))))\n(aref dp time-limit)))",
    "instruction": {
      "es": "(defun max-herb-value (time-limit herb-info)\n(let ((dp (make-array (1+ time-limit) :initial-element 0)))\n(loop for (time value) in herb-info do\n(loop for current-time from time-limit downto time do\n(setf (aref dp current-time) \n(max (aref dp current-time) \n(+ value (aref dp (- current-time time)))))))\n(aref dp time-limit)))\n\nProporcione una descripción concisa en lenguaje natural (docstring) del código Common Lisp en español utilizando un máximo de 500 caracteres.",
      "arb": "(defun max-herb-value (time-limit herb-info)\n(let ((dp (make-array (1+ time-limit) :initial-element 0)))\n(loop for (time value) in herb-info do\n(loop for current-time from time-limit downto time do\n(setf (aref dp current-time) \n(max (aref dp current-time) \n(+ value (aref dp (- current-time time)))))))\n(aref dp time-limit)))\n\nيرجى تقديم وصف موجز بلغة طبيعية (docstring) لشفرة Common Lisp باللغة العربية الفصحى، بحيث لا يتجاوز 500 حرف.",
      "sw": "(defun max-herb-value (time-limit herb-info)\n(let ((dp (make-array (1+ time-limit) :initial-element 0)))\n(loop for (time value) in herb-info do\n(loop for current-time from time-limit downto time do\n(setf (aref dp current-time) \n(max (aref dp current-time) \n(+ value (aref dp (- current-time time)))))))\n(aref dp time-limit)))\n\nToa maelezo mafupi ya lugha ya asili (docstring) ya msimbo wa Common Lisp kwa Kiswahili kwa kutumia herufi zisizozidi 500.",
      "tr": "(defun max-herb-value (time-limit herb-info)\n(let ((dp (make-array (1+ time-limit) :initial-element 0)))\n(loop for (time value) in herb-info do\n(loop for current-time from time-limit downto time do\n(setf (aref dp current-time) \n(max (aref dp current-time) \n(+ value (aref dp (- current-time time)))))))\n(aref dp time-limit)))\n\nAşağıdaki Common Lisp kodunun işlevini açıklayan kısa bir doğal dil açıklaması (docstring) sağlayın. Açıklama Türkçe olmalı ve en fazla 500 karakter içermelidir.",
      "vi": "(defun max-herb-value (time-limit herb-info)\n(let ((dp (make-array (1+ time-limit) :initial-element 0)))\n(loop for (time value) in herb-info do\n(loop for current-time from time-limit downto time do\n(setf (aref dp current-time) \n(max (aref dp current-time) \n(+ value (aref dp (- current-time time)))))))\n(aref dp time-limit)))\n\nCung cấp mô tả ngắn gọn bằng ngôn ngữ tự nhiên (docstring) cho mã Common Lisp bằng tiếng Việt, sử dụng tối đa 500 ký tự."
    },
    "instruction_bertscore": {
      "es": "0.9711352316583911",
      "arb": "0.9060988777784239",
      "sw": "0.8914782913215888",
      "tr": "0.8595504438740409",
      "vi": "0.9119165630085547"
    },
    "level": "",
    "test": "(defun test-max-herb-value ()\n(assert (equal (max-herb-value 70 '((71 100) (69 1) (1 2))) 3))\n(assert (equal (max-herb-value 10 '((5 5) (4 7) (3 4) (2 3))) 14))\n(assert (equal (max-herb-value 15 '((5 10) (10 15) (20 25))) 25))\n(assert (equal (max-herb-value 100 '((50 60) (50 70))) 130))\n(assert (equal (max-herb-value 5 '((2 3) (2 4) (1 1))) 8)))\n\n(test-max-herb-value)",
    "entry_point": "max-herb-value",
    "signature": "(defun max-herb-value (time-limit herb-info)",
    "docstring": {
      "es": "Esta función calcula el valor total máximo de hierbas que se pueden recolectar dentro de un límite de tiempo dado.\n'time-limit' es el tiempo total disponible para recolectar hierbas.\n'herb-info' es una lista de pares, cada par contiene dos enteros: el tiempo requerido para recolectar una hierba y su valor.\nLa función utiliza un enfoque de programación dinámica para determinar el valor máximo que se puede obtener.\nEjemplo:\n>>> max-herb-value 70 '((71 100) (69 1) (1 2))\n3\n>>> max-herb-value 10 '((5 5) (4 7) (3 4) (2 3))\n14",
      "arb": "هذه الدالة تحسب القيمة الإجمالية القصوى للأعشاب التي يمكن جمعها ضمن حد زمني معين.\n'time-limit' هو إجمالي الوقت المتاح لجمع الأعشاب.\n'herb-info' هو قائمة من الأزواج، كل زوج يحتوي على عددين صحيحين: الوقت المطلوب لجمع عشبة وقيمتها.\nتستخدم الدالة نهج البرمجة الديناميكية لتحديد القيمة القصوى التي يمكن الحصول عليها.\nمثال:\n>>> max-herb-value 70 '((71 100) (69 1) (1 2))\n3\n>>> max-herb-value 10 '((5 5) (4 7) (3 4) (2 3))\n14",
      "sw": "Kazi hii inahesabu thamani ya juu kabisa ya mimea ya dawa inayoweza kukusanywa ndani ya kikomo cha muda kilichopewa.\n'time-limit' ni muda wote unaopatikana kwa ajili ya kukusanya mimea ya dawa.\n'herb-info' ni orodha ya jozi, kila jozi ina namba mbili: muda unaohitajika kukusanya mmea na thamani yake.\nKazi hii inatumia mbinu ya programu ya nguvu ili kubaini thamani ya juu inayoweza kupatikana.\nMfano:\n>>> max-herb-value 70 '((71 100) (69 1) (1 2))\n3\n>>> max-herb-value 10 '((5 5) (4 7) (3 4) (2 3))\n14",
      "tr": "Bu fonksiyon, belirli bir zaman sınırı içinde toplanabilecek maksimum toplam ot değerini hesaplar.\n'time-limit', ot toplamak için mevcut toplam zamandır.\n'herb-info', her biri iki tamsayı içeren çiftlerden oluşan bir listedir: bir otu toplamak için gereken zaman ve onun değeri.\nFonksiyon, elde edilebilecek maksimum değeri belirlemek için dinamik programlama yaklaşımını kullanır.\nÖrnek:\n>>> max-herb-value 70 '((71 100) (69 1) (1 2))\n3\n>>> max-herb-value 10 '((5 5) (4 7) (3 4) (2 3))\n14",
      "vi": "Hàm này tính toán giá trị tổng tối đa của các loại thảo mộc có thể thu thập được trong giới hạn thời gian cho trước.  \n'time-limit' là tổng thời gian có sẵn để thu thập thảo mộc.  \n'herb-info' là một danh sách các cặp, mỗi cặp chứa hai số nguyên: thời gian cần thiết để thu thập một loại thảo mộc và giá trị của nó.  \nHàm sử dụng phương pháp lập trình động để xác định giá trị tối đa có thể đạt được.  \nVí dụ:  \n>>> max-herb-value 70 '((71 100) (69 1) (1 2))  \n3  \n>>> max-herb-value 10 '((5 5) (4 7) (3 4) (2 3))  \n14  "
    },
    "docstring_bertscore": {
      "es": "0.9975596271386054",
      "arb": "0.9949096992252189",
      "sw": "0.9533304015631858",
      "tr": "0.9847376387820412",
      "vi": "0.9772530473942657"
    }
  },
  {
    "task_id": "Common Lisp/40",
    "prompt": {
      "es": "(defun min-box-space (box-capacity item-volumes)\n;; Esta función calcula el espacio mínimo restante en una caja después de empacar de manera óptima un conjunto dado de artículos.\n;; Cada artículo tiene un volumen específico, y la caja tiene una capacidad fija.\n;; La función devuelve el menor espacio posible restante en la caja.\n;; Ejemplo:\n;; >>> min-box-space 10 '(2 3 4)\n;; 1\n;; >>> min-box-space 15 '(5 5 6)\n;; 0",
      "arb": "(defun min-box-space (box-capacity item-volumes)\n;; تقوم هذه الدالة بحساب الحد الأدنى من المساحة المتبقية في صندوق بعد تعبئة مجموعة معينة من العناصر بشكل مثالي.\n;; كل عنصر له حجم محدد، والصندوق له سعة ثابتة.\n;; تعيد الدالة أصغر مساحة ممكنة متبقية في الصندوق.\n;; مثال:\n;; >>> min-box-space 10 '(2 3 4)\n;; 1\n;; >>> min-box-space 15 '(5 5 6)\n;; 0",
      "sw": "(defun min-box-space (box-capacity item-volumes)\n;; Kazi ya hii kazi ni kuhesabu nafasi ndogo zaidi inayobaki kwenye boksi baada ya kupakia seti fulani ya vitu kwa njia bora.\n;; Kila kitu kina ujazo maalum, na boksi lina uwezo uliowekwa.\n;; Kazi hii inarudisha nafasi ndogo zaidi inayoweza kubaki kwenye boksi.\n;; Mfano:\n;; >>> min-box-space 10 '(2 3 4)\n;; 1\n;; >>> min-box-space 15 '(5 5 6)\n;; 0",
      "tr": "(defun min-box-space (box-capacity item-volumes)\n;; Bu fonksiyon, belirli bir dizi öğeyi en uygun şekilde paketledikten sonra bir kutuda kalan minimum alanı hesaplar.\n;; Her bir öğenin belirli bir hacmi vardır ve kutunun sabit bir kapasitesi vardır.\n;; Fonksiyon, kutuda mümkün olan en küçük kalan alanı döndürür.\n;; Örnek:\n;; >>> min-box-space 10 '(2 3 4)\n;; 1\n;; >>> min-box-space 15 '(5 5 6)\n;; 0",
      "vi": "(defun min-box-space (box-capacity item-volumes)\n;; Hàm này tính toán không gian còn lại tối thiểu trong một hộp sau khi đóng gói tối ưu một tập hợp các vật phẩm đã cho.\n;; Mỗi vật phẩm có một thể tích cụ thể, và hộp có một dung tích cố định.\n;; Hàm trả về không gian còn lại nhỏ nhất có thể trong hộp.\n;; Ví dụ:\n;; >>> min-box-space 10 '(2 3 4)\n;; 1\n;; >>> min-box-space 15 '(5 5 6)\n;; 0"
    },
    "prompt_bertscore": {
      "es": "1",
      "arb": "0.9965146327039808",
      "sw": "0.9655261083283468",
      "tr": "1",
      "vi": "1"
    },
    "canonical_solution": "(let ((dp (make-array (1+ box-capacity) :initial-element 0)))\n(loop for item in item-volumes do\n(loop for v from box-capacity downto item do\n(setf (aref dp v) (max (aref dp v) (+ (aref dp (- v item)) item)))))\n(- box-capacity (reduce 'max dp))))",
    "instruction": {
      "es": "(defun min-box-space (box-capacity item-volumes)\n(let ((dp (make-array (1+ box-capacity) :initial-element 0)))\n(loop for item in item-volumes do\n(loop for v from box-capacity downto item do\n(setf (aref dp v) (max (aref dp v) (+ (aref dp (- v item)) item)))))\n(- box-capacity (reduce 'max dp))))\n\nProporcione una descripción concisa en lenguaje natural (docstring) del código Common Lisp en español utilizando un máximo de 500 caracteres.",
      "arb": "(defun min-box-space (box-capacity item-volumes)\n(let ((dp (make-array (1+ box-capacity) :initial-element 0)))\n(loop for item in item-volumes do\n(loop for v from box-capacity downto item do\n(setf (aref dp v) (max (aref dp v) (+ (aref dp (- v item)) item)))))\n(- box-capacity (reduce 'max dp))))\n\nيرجى تقديم وصف موجز بلغة طبيعية (docstring) لكود Common Lisp باللغة العربية الفصحى، بحيث لا يتجاوز 500 حرف.",
      "sw": "(defun min-box-space (box-capacity item-volumes)\n(let ((dp (make-array (1+ box-capacity) :initial-element 0)))\n(loop for item in item-volumes do\n(loop for v from box-capacity downto item do\n(setf (aref dp v) (max (aref dp v) (+ (aref dp (- v item)) item)))))\n(- box-capacity (reduce 'max dp))))\n\nToa maelezo mafupi ya lugha ya asili (docstring) ya msimbo wa Common Lisp kwa Kiswahili kwa kutumia herufi zisizozidi 500.",
      "tr": "(defun min-box-space (box-capacity item-volumes)\n(let ((dp (make-array (1+ box-capacity) :initial-element 0)))\n(loop for item in item-volumes do\n(loop for v from box-capacity downto item do\n(setf (aref dp v) (max (aref dp v) (+ (aref dp (- v item)) item)))))\n(- box-capacity (reduce 'max dp))))\n\nAşağıdaki Common Lisp kodunun işlevini açıklayan, en fazla 500 karakter uzunluğunda bir doğal dil açıklaması (docstring) sağlayın.",
      "vi": "(defun min-box-space (box-capacity item-volumes)\n(let ((dp (make-array (1+ box-capacity) :initial-element 0)))\n(loop for item in item-volumes do\n(loop for v from box-capacity downto item do\n(setf (aref dp v) (max (aref dp v) (+ (aref dp (- v item)) item)))))\n(- box-capacity (reduce 'max dp))))\n\nCung cấp mô tả ngắn gọn bằng ngôn ngữ tự nhiên (docstring) cho mã Common Lisp bằng tiếng Việt, sử dụng tối đa 500 ký tự."
    },
    "instruction_bertscore": {
      "es": "0.9711352316583911",
      "arb": "0.8931430125450422",
      "sw": "0.9127128722061235",
      "tr": "0.8405576054698659",
      "vi": "0.9283341585226124"
    },
    "level": "",
    "test": "(defun test-min-box-space ()\n(assert (equal (min-box-space 20 '(5 5 10 6)) 0))\n(assert (equal (min-box-space 25 '(7 8 5 10)) 0))\n(assert (equal (min-box-space 12 '(3 2 2 5)) 0))\n(assert (equal (min-box-space 30 '(10 10 12)) 8))\n(assert (equal (min-box-space 8 '(1 2 3 4)) 0))\n(assert (equal (min-box-space 18 '(2 5 6 8)) 2))\n(assert (equal (min-box-space 11 '(1 2 3)) 5)))\n\n(test-min-box-space)",
    "entry_point": "min-box-space",
    "signature": "(defun min-box-space (box-capacity item-volumes)",
    "docstring": {
      "es": "Esta función calcula el espacio mínimo restante en una caja después de empacar de manera óptima un conjunto dado de artículos.  \nCada artículo tiene un volumen específico, y la caja tiene una capacidad fija.  \nLa función devuelve el espacio restante más pequeño posible en la caja.  \nEjemplo:  \n>>> min-box-space 10 '(2 3 4)  \n1  \n>>> min-box-space 15 '(5 5 6)  \n0  ",
      "arb": "هذه الدالة تحسب الحد الأدنى من المساحة المتبقية في صندوق بعد تعبئة مجموعة معينة من العناصر بشكل مثالي. \nكل عنصر له حجم محدد، والصندوق له سعة ثابتة. \nتعيد الدالة أصغر مساحة متبقية ممكنة في الصندوق. \nمثال:\n>>> min-box-space 10 '(2 3 4)\n1\n>>> min-box-space 15 '(5 5 6)\n0",
      "sw": "Kazi ya hii kazi ni kuhesabu nafasi ndogo zaidi inayobaki kwenye sanduku baada ya kupakia kwa ufanisi seti fulani ya vitu. \nKila kitu kina ujazo maalum, na sanduku lina uwezo uliowekwa. \nKazi inarudisha nafasi ndogo zaidi inayoweza kubaki kwenye sanduku. \nMfano:\n>>> min-box-space 10 '(2 3 4)\n1\n>>> min-box-space 15 '(5 5 6)\n0",
      "tr": "Bu fonksiyon, belirli bir öğe kümesini en iyi şekilde paketledikten sonra bir kutuda kalan minimum alanı hesaplar.\nHer öğenin belirli bir hacmi vardır ve kutunun sabit bir kapasitesi vardır.\nFonksiyon, kutuda mümkün olan en küçük kalan alanı döndürür.\nÖrnek:\n>>> min-box-space 10 '(2 3 4)\n1\n>>> min-box-space 15 '(5 5 6)\n0",
      "vi": "Hàm này tính toán không gian còn lại tối thiểu trong một hộp sau khi đóng gói tối ưu một tập hợp các vật phẩm cho trước.  \nMỗi vật phẩm có một thể tích cụ thể, và hộp có một dung lượng cố định.  \nHàm trả về không gian còn lại nhỏ nhất có thể trong hộp.  \nVí dụ:  \n>>> min-box-space 10 '(2 3 4)  \n1  \n>>> min-box-space 15 '(5 5 6)  \n0  "
    },
    "docstring_bertscore": {
      "es": "1",
      "arb": "0.9732832205989024",
      "sw": "0.9607571915100802",
      "tr": "0.9984584296127882",
      "vi": "1"
    }
  },
  {
    "task_id": "Common Lisp/41",
    "prompt": {
      "es": "(defun calculate-expression (a b c)\n  ;; Calcula el valor de la expresión (a+b)*c para los enteros dados a, b y c.\n  ;; Devuelve el resultado del cálculo.\n  ;; Ejemplo:\n  ;; >>> (calculate-expression 1 2 3)\n  ;; 9\n  ;; >>> (calculate-expression -1 2 3)\n  ;; 3\n  ;; >>> (calculate-expression 0 0 0)\n  ;; 0",
      "arb": "(defun calculate-expression (a b c)\n  ;; يحسب قيمة التعبير (a+b)*c للأعداد الصحيحة المعطاة a و b و c.\n  ;; يعيد نتيجة الحساب.\n  ;; مثال:\n  ;; >>> (calculate-expression 1 2 3)\n  ;; 9\n  ;; >>> (calculate-expression -1 2 3)\n  ;; 3\n  ;; >>> (calculate-expression 0 0 0)\n  ;; 0",
      "sw": "(defun calculate-expression (a b c)\n  ;; Inahesabu thamani ya usemi (a+b)*c kwa namba kamili zilizotolewa a, b, na c.\n  ;; Inarejesha matokeo ya hesabu.\n  ;; Mfano:\n  ;; >>> (calculate-expression 1 2 3)\n  ;; 9\n  ;; >>> (calculate-expression -1 2 3)\n  ;; 3\n  ;; >>> (calculate-expression 0 0 0)\n  ;; 0",
      "tr": "(defun calculate-expression (a b c)\n  ;; Verilen tamsayılar a, b ve c için (a+b)*c ifadesinin değerini hesaplar.\n  ;; Hesaplamanın sonucunu döndürür.\n  ;; Örnek:\n  ;; >>> (calculate-expression 1 2 3)\n  ;; 9\n  ;; >>> (calculate-expression -1 2 3)\n  ;; 3\n  ;; >>> (calculate-expression 0 0 0)\n  ;; 0",
      "vi": "(defun calculate-expression (a b c)\n  ;; Tính giá trị của biểu thức (a+b)*c cho các số nguyên a, b, và c đã cho.\n  ;; Trả về kết quả của phép tính.\n  ;; Ví dụ:\n  ;; >>> (calculate-expression 1 2 3)\n  ;; 9\n  ;; >>> (calculate-expression -1 2 3)\n  ;; 3\n  ;; >>> (calculate-expression 0 0 0)\n  ;; 0"
    },
    "prompt_bertscore": {
      "es": "0.9886107325818405",
      "arb": "0.9886107325818405",
      "sw": "0.9886107325818405",
      "tr": "0.9886107325818405",
      "vi": "0.9860781952236457"
    },
    "canonical_solution": "  (* (+ a b) c))",
    "instruction": {
      "es": "(defun calculate-expression (a b c)\n  (* (+ a b) c))\n\nProporcione una descripción concisa en lenguaje natural (docstring) del código Common Lisp en español utilizando un máximo de 500 caracteres.",
      "arb": "(defun calculate-expression (a b c)\n  (* (+ a b) c))\n\nيرجى تقديم وصف موجز بلغة طبيعية (docstring) لشيفرة Common Lisp باللغة العربية الفصحى، بحيث لا يتجاوز 500 حرف.",
      "sw": "(defun calculate-expression (a b c)\n  (* (+ a b) c))\n\nToa maelezo mafupi ya lugha ya asili (docstring) ya msimbo wa Common Lisp kwa Kiswahili kwa kutumia herufi zisizozidi 500.",
      "tr": "(defun calculate-expression (a b c)\n  (* (+ a b) c))\n\nAşağıdaki Common Lisp kodunun doğal dilde kısa bir açıklamasını (docstring) en fazla 500 karakter kullanarak Türkçe olarak sağlayın.",
      "vi": "(defun calculate-expression (a b c)\n  (* (+ a b) c))\n\nCung cấp mô tả ngắn gọn bằng ngôn ngữ tự nhiên (docstring) cho mã Common Lisp bằng tiếng Việt, sử dụng tối đa 500 ký tự."
    },
    "instruction_bertscore": {
      "es": "0.9711352316583911",
      "arb": "0.8964802015768094",
      "sw": "0.9454739741021129",
      "tr": "0.85336231298328",
      "vi": "0.9119165630085547"
    },
    "level": "",
    "test": "(defun check-calculate-expression ()\n  (assert (= (calculate-expression 1 2 3) 9))\n  (assert (= (calculate-expression -1 2 3) 3))\n  (assert (= (calculate-expression 0 0 0) 0))\n  (assert (= (calculate-expression 100 -100 1) 0))\n  (assert (= (calculate-expression -5 -5 -5) 50))\n  (assert (= (calculate-expression 10 20 30) 900))\n  (assert (= (calculate-expression 0 10 -2) -20)))",
    "entry_point": "calculate-expression",
    "signature": "(defun calculate-expression (a b c)",
    "docstring": {
      "es": "   Calcula el valor de la expresión (a+b)*c para los enteros dados a, b y c.\n   Devuelve el resultado del cálculo.\n   Ejemplo:\n   >>> (calculate-expression 1 2 3)\n   9\n   >>> (calculate-expression -1 2 3)\n   3\n   >>> (calculate-expression 0 0 0)\n   0",
      "arb": "   يحسب قيمة التعبير (a+b)*c للأعداد الصحيحة المعطاة a، b، و c.\n   يعيد نتيجة الحساب.\n   مثال:\n   >>> (calculate-expression 1 2 3)\n   9\n   >>> (calculate-expression -1 2 3)\n   3\n   >>> (calculate-expression 0 0 0)\n   0",
      "sw": "   Inahesabu thamani ya usemi (a+b)*c kwa nambari kamili zilizotolewa a, b, na c.\n   Inarudisha matokeo ya hesabu.\n   Mfano:\n   >>> (calculate-expression 1 2 3)\n   9\n   >>> (calculate-expression -1 2 3)\n   3\n   >>> (calculate-expression 0 0 0)\n   0",
      "tr": "   Verilen tamsayılar a, b ve c için (a+b)*c ifadesinin değerini hesaplar.\n   Hesaplamanın sonucunu döndürür.\n   Örnek:\n   >>> (calculate-expression 1 2 3)\n   9\n   >>> (calculate-expression -1 2 3)\n   3\n   >>> (calculate-expression 0 0 0)\n   0",
      "vi": "Tính giá trị của biểu thức (a+b)*c cho các số nguyên a, b và c được cung cấp.  \nTrả về kết quả của phép tính.  \nVí dụ:  \n>>> (calculate-expression 1 2 3)  \n9  \n>>> (calculate-expression -1 2 3)  \n3  \n>>> (calculate-expression 0 0 0)  \n0  "
    },
    "docstring_bertscore": {
      "es": "0.9747000511068242",
      "arb": "0.9782003156814211",
      "sw": "0.9782003156814211",
      "tr": "0.9782003156814211",
      "vi": "0.9747000511068242"
    }
  },
  {
    "task_id": "Common Lisp/42",
    "prompt": {
      "es": "(defun char-to-ascii (char)\n  ;; Convierte un solo carácter visible (excluyendo el espacio) a su código ASCII.\n  ;; Entrada: Un carácter (no una cadena) que es visible y no un espacio.\n  ;; Salida: Un entero que representa el código ASCII del carácter de entrada.\n  ;; Ejemplo:\n  ;; >>> (char-to-ascii #\\A)\n  ;; 65\n  ;; >>> (char-to-ascii #\\!)\n  ;; 33",
      "arb": "(defun char-to-ascii (char)\n  ;; يحول حرفًا واحدًا مرئيًا (باستثناء المسافة) إلى رمز ASCII الخاص به.\n  ;; المدخل: حرف (وليس سلسلة) يكون مرئيًا وليس مسافة.\n  ;; المخرج: عدد صحيح يمثل رمز ASCII للحرف المدخل.\n  ;; مثال:\n  ;; >>> (char-to-ascii #\\A)\n  ;; 65\n  ;; >>> (char-to-ascii #\\!)\n  ;; 33",
      "sw": "(defun char-to-ascii (char)\n  ;; Hubadilisha herufi moja inayoonekana (isipokuwa nafasi) kuwa nambari yake ya ASCII.\n  ;; Ingizo: Herufi (sio kamba) ambayo inaonekana na si nafasi.\n  ;; Tokeo: Nambari nzima inayowakilisha nambari ya ASCII ya herufi ya ingizo.\n  ;; Mfano:\n  ;; >>> (char-to-ascii #\\A)\n  ;; 65\n  ;; >>> (char-to-ascii #\\!)\n  ;; 33",
      "tr": "(defun char-to-ascii (char)\n  ;; Tek bir görünen karakteri (boşluk hariç) ASCII koduna dönüştürür.\n  ;; Girdi: Görünen ve boşluk olmayan bir karakter (string değil).\n  ;; Çıktı: Girdi karakterinin ASCII kodunu temsil eden bir tamsayı.\n  ;; Örnek:\n  ;; >>> (char-to-ascii #\\A)\n  ;; 65\n  ;; >>> (char-to-ascii #\\!)\n  ;; 33",
      "vi": "(defun char-to-ascii (char)\n  ;; Chuyển đổi một ký tự có thể nhìn thấy (không bao gồm khoảng trắng) thành mã ASCII của nó.\n  ;; Đầu vào: Một ký tự (không phải chuỗi) có thể nhìn thấy và không phải là khoảng trắng.\n  ;; Đầu ra: Một số nguyên đại diện cho mã ASCII của ký tự đầu vào.\n  ;; Ví dụ:\n  ;; >>> (char-to-ascii #\\A)\n  ;; 65\n  ;; >>> (char-to-ascii #\\!)\n  ;; 33"
    },
    "prompt_bertscore": {
      "es": "1",
      "arb": "1",
      "sw": "0.9855190507010325",
      "tr": "0.970274566217367",
      "vi": "0.9670837677764225"
    },
    "canonical_solution": "  (char-code char))",
    "instruction": {
      "es": "defun char-to-ascii (char)\n  (char-code char))\n\nProporcione una descripción concisa en lenguaje natural (docstring) del código Common Lisp en español utilizando un máximo de 500 caracteres.",
      "arb": "defun char-to-ascii (char)\n  (char-code char))\n\nيرجى تقديم وصف موجز بلغة طبيعية (docstring) لشفرة Common Lisp باللغة العربية الفصحى، بحيث لا يتجاوز 500 حرف.",
      "sw": "defun char-to-ascii (char)\n  (char-code char))\n\nToa maelezo mafupi ya lugha asilia (docstring) ya msimbo wa Common Lisp kwa Kiswahili kwa kutumia herufi zisizozidi 500.",
      "tr": "defun char-to-ascii (char)\n  (char-code char))\n\nAşağıdaki Common Lisp kodunun işlevini açıklayan kısa bir doğal dil açıklaması (docstring) sağlayın. Açıklama Türkçe olmalı ve en fazla 500 karakter içermelidir.",
      "vi": "defun char-to-ascii (char)\n  (char-code char))\n\nCung cấp mô tả ngắn gọn bằng ngôn ngữ tự nhiên (docstring) cho mã Common Lisp bằng tiếng Việt, sử dụng tối đa 500 ký tự."
    },
    "instruction_bertscore": {
      "es": "0.9711352316583911",
      "arb": "0.9060988777784239",
      "sw": "0.9454739741021129",
      "tr": "0.8480944366478538",
      "vi": "0.9119165630085547"
    },
    "level": "",
    "test": "(defun check-char-to-ascii ()\n  (assert (= (char-to-ascii #\\A) 65))\n  (assert (= (char-to-ascii #\\!) 33))\n  (assert (= (char-to-ascii #\\~) 126))\n  (assert (= (char-to-ascii #\\0) 48))\n  (assert (= (char-to-ascii #\\Z) 90)))\n\n(check-char-to-ascii)",
    "entry_point": "char-to-ascii",
    "signature": "defun char-to-ascii (char)",
    "docstring": {
      "es": "Convierte un solo carácter visible (excluyendo el espacio) a su código ASCII.\nEntrada: Un carácter (no una cadena) que es visible y no es un espacio.\nSalida: Un entero que representa el código ASCII del carácter de entrada.\nEjemplo:\n>>> (char-to-ascii #\\A)\n65\n>>> (char-to-ascii #\\!)\n33",
      "arb": "يحول حرفًا مرئيًا واحدًا (باستثناء المسافة) إلى رمز ASCII الخاص به.\nالمدخلات: حرف (ليس سلسلة) يكون مرئيًا وليس مسافة.\nالمخرجات: عدد صحيح يمثل رمز ASCII للحرف المدخل.\nمثال:\n>>> (char-to-ascii #\\A)\n65\n>>> (char-to-ascii #\\!)\n33",
      "sw": "Inabadilisha herufi moja inayoonekana (isipokuwa nafasi) kuwa nambari yake ya ASCII.\nIngizo: Herufi (sio mfuatano wa herufi) ambayo inaonekana na sio nafasi.\nPato: Nambari kamili inayowakilisha nambari ya ASCII ya herufi iliyoingizwa.\nMfano:\n>>> (char-to-ascii #\\A)\n65\n>>> (char-to-ascii #\\!)\n33",
      "tr": "Tek bir görünür karakteri (boşluk hariç) ASCII koduna dönüştürür.\nGirdi: Görünür olan ve boşluk olmayan bir karakter (dize değil).\nÇıktı: Girdi karakterinin ASCII kodunu temsil eden bir tamsayı.\nÖrnek:\n>>> (char-to-ascii #\\A)\n65\n>>> (char-to-ascii #\\!)\n33",
      "vi": "Chuyển đổi một ký tự có thể nhìn thấy (không bao gồm khoảng trắng) thành mã ASCII của nó.  \nĐầu vào: Một ký tự (không phải chuỗi) có thể nhìn thấy và không phải là khoảng trắng.  \nĐầu ra: Một số nguyên đại diện cho mã ASCII của ký tự đầu vào.  \nVí dụ:  \n>>> (char-to-ascii #\\A)  \n65  \n>>> (char-to-ascii #\\!)  \n33  "
    },
    "docstring_bertscore": {
      "es": "0.9943418149658402",
      "arb": "1",
      "sw": "0.962321207130349",
      "tr": "0.9701969017383822",
      "vi": "0.9559783431727619"
    }
  },
  {
    "task_id": "Common Lisp/43",
    "prompt": {
      "es": "(defun ascii-to-char (code)\n  ;; Convierte un código ASCII en su carácter correspondiente.\n  ;; Entrada: Un entero que representa el código ASCII, garantizado para estar dentro del rango de caracteres visibles (<128 y >0).\n  ;; Salida: El carácter correspondiente al código ASCII.\n  ;; Ejemplo:\n  ;; >>> (ascii-to-char 65)\n  ;; #\\A\n  ;; >>> (ascii-to-char 33)\n  ;; #\\!",
      "arb": "(defun ascii-to-char (code)\n  ;; يحول كود ASCII إلى الحرف المقابل له.\n  ;; المدخل: عدد صحيح يمثل كود ASCII، مضمون أن يكون ضمن نطاق الأحرف المرئية (<128 و >0).\n  ;; المخرج: الحرف المقابل لكود ASCII.\n  ;; مثال:\n  ;; >>> (ascii-to-char 65)\n  ;; #\\A\n  ;; >>> (ascii-to-char 33)\n  ;; #\\!",
      "sw": "(defun ascii-to-char (code)\n  ;; Hubadilisha msimbo wa ASCII kuwa herufi inayolingana.\n  ;; Ingizo: Nambari kamili inayowakilisha msimbo wa ASCII, inahakikishwa kuwa ndani ya safu ya herufi zinazoonekana (<128 na >0).\n  ;; Tokeo: Herufi inayolingana na msimbo wa ASCII.\n  ;; Mfano:\n  ;; >>> (ascii-to-char 65)\n  ;; #\\A\n  ;; >>> (ascii-to-char 33)\n  ;; #\\!",
      "tr": "(defun ascii-to-char (code)\n  ;; Bir ASCII kodunu karşılık gelen karaktere dönüştürür.\n  ;; Girdi: Görünür karakterler aralığında olduğu garanti edilen bir tamsayı (128'den küçük ve 0'dan büyük).\n  ;; Çıktı: ASCII koduna karşılık gelen karakter.\n  ;; Örnek:\n  ;; >>> (ascii-to-char 65)\n  ;; #\\A\n  ;; >>> (ascii-to-char 33)\n  ;; #\\!",
      "vi": "(defun ascii-to-char (code)\n  ;; Chuyển đổi một mã ASCII thành ký tự tương ứng của nó.\n  ;; Đầu vào: Một số nguyên đại diện cho mã ASCII, đảm bảo nằm trong phạm vi các ký tự hiển thị (<128 và >0).\n  ;; Đầu ra: Ký tự tương ứng với mã ASCII.\n  ;; Ví dụ:\n  ;; >>> (ascii-to-char 65)\n  ;; #\\A\n  ;; >>> (ascii-to-char 33)\n  ;; #\\!"
    },
    "prompt_bertscore": {
      "es": "0.999038231695029",
      "arb": "0.9945841440307027",
      "sw": "0.9880956840038171",
      "tr": "0.9609874041216997",
      "vi": "0.9794214952640236"
    },
    "canonical_solution": "  (code-char code))",
    "instruction": {
      "es": "defun ascii-to-char (code)\n  (code-char code))\n\nProporcione una descripción concisa en lenguaje natural (docstring) del código Common Lisp en español utilizando un máximo de 500 caracteres.",
      "arb": "defun ascii-to-char (code)\n  (code-char code))\n\nيرجى تقديم وصف موجز بلغة طبيعية (docstring) لشيفرة Common Lisp باللغة العربية الفصحى، بحيث لا يتجاوز 500 حرف.",
      "sw": "defun ascii-to-char (code)\n  (code-char code))\n\nToa maelezo mafupi ya lugha ya asili (docstring) ya msimbo wa Common Lisp kwa Kiswahili kwa kutumia herufi zisizozidi 500.",
      "tr": "defun ascii-to-char (code)\n  (code-char code))\n\nAşağıdaki Common Lisp kodunun işlevini açıklayan kısa bir doğal dil açıklaması (docstring) sağlayın. Açıklama Türkçe olmalı ve en fazla 500 karakter kullanılmalıdır.",
      "vi": "defun ascii-to-char (code)\n  (code-char code))\n\nCung cấp mô tả ngắn gọn bằng ngôn ngữ tự nhiên (docstring) cho mã Common Lisp bằng tiếng Việt, sử dụng tối đa 500 ký tự."
    },
    "instruction_bertscore": {
      "es": "0.9711352316583911",
      "arb": "0.9060988777784239",
      "sw": "0.9127128722061235",
      "tr": "0.8529761755225482",
      "vi": "0.9119165630085547"
    },
    "level": "",
    "test": "(defun check-ascii-to-char ()\n  (assert (char= (ascii-to-char 65) #\\A))\n  (assert (char= (ascii-to-char 33) #\\!))\n  (assert (char= (ascii-to-char 126) #\\~))\n  (assert (char= (ascii-to-char 48) #\\0))\n  (assert (char= (ascii-to-char 90) #\\Z)))\n\n(check-ascii-to-char)",
    "entry_point": "ascii-to-char",
    "signature": "defun ascii-to-char (code)",
    "docstring": {
      "es": "Convierte un código ASCII a su carácter correspondiente.\nEntrada: Un entero que representa el código ASCII, garantizado para estar dentro del rango de caracteres visibles (<128 y >0).\nSalida: El carácter correspondiente al código ASCII.\nEjemplo:\n>>> (ascii-to-char 65)\n#\\A\n>>> (ascii-to-char 33)\n#\\!",
      "arb": "يحول كود ASCII إلى الحرف المقابل له.\nالمدخل: عدد صحيح يمثل كود ASCII، مضمون أن يكون ضمن نطاق الأحرف المرئية (<128 و >0).\nالمخرج: الحرف المقابل لكود ASCII.\nمثال:\n>>> (ascii-to-char 65)\n#\\A\n>>> (ascii-to-char 33)\n#\\!",
      "sw": "Inabadilisha msimbo wa ASCII kuwa herufi inayolingana nayo.  \nIngizo: Nambari nzima inayowakilisha msimbo wa ASCII, imehakikishwa kuwa ndani ya safu ya herufi zinazoonekana (<128 na >0).  \nPato: Herufi inayolingana na msimbo wa ASCII.  \nMfano:  \n>>> (ascii-to-char 65)  \n#\\A  \n>>> (ascii-to-char 33)  \n#\\!  ",
      "tr": "ASCII kodunu karşılık gelen karaktere dönüştürür.\nGirdi: Görünür karakterler aralığında olduğu garanti edilen bir tam sayı (128'den küçük ve 0'dan büyük).\nÇıktı: ASCII koduna karşılık gelen karakter.\nÖrnek:\n>>> (ascii-to-char 65)\n#\\A\n>>> (ascii-to-char 33)\n#\\!",
      "vi": "Chuyển đổi một mã ASCII thành ký tự tương ứng của nó.  \nĐầu vào: Một số nguyên đại diện cho mã ASCII, đảm bảo nằm trong phạm vi của các ký tự hiển thị (<128 và >0).  \nĐầu ra: Ký tự tương ứng với mã ASCII.  \nVí dụ:  \n>>> (ascii-to-char 65)  \n#\\A  \n>>> (ascii-to-char 33)  \n#\\!  "
    },
    "docstring_bertscore": {
      "es": "1",
      "arb": "0.9909648998578661",
      "sw": "0.9909648998578661",
      "tr": "0.9422925112890771",
      "vi": "0.9703977170536086"
    }
  },
  {
    "task_id": "Common Lisp/44",
    "prompt": {
      "es": "(defun reverse-three-digit (num)\n  ;; Invierte un número de tres dígitos.\n  ;; Entrada: Un entero de tres dígitos 'num'.\n  ;; Salida: El entero de tres dígitos en orden inverso. Los ceros a la izquierda se preservan en la salida.\n  ;; Ejemplo:\n  ;; >>> (reverse-three-digit 123)\n  ;; 321\n  ;; >>> (reverse-three-digit 100)\n  ;; 1 ;; Para Common Lisp, los ceros a la izquierda no se muestran típicamente en la salida de enteros.",
      "arb": "(defun reverse-three-digit (num)\n  ;; يعكس رقمًا مكونًا من ثلاثة أرقام.\n  ;; المدخل: عدد صحيح مكون من ثلاثة أرقام 'num'.\n  ;; المخرج: العدد الصحيح المكون من ثلاثة أرقام بترتيب عكسي. يتم الحفاظ على الأصفار البادئة في المخرج.\n  ;; مثال:\n  ;; >>> (reverse-three-digit 123)\n  ;; 321\n  ;; >>> (reverse-three-digit 100)\n  ;; 1 ;; بالنسبة لـ Common Lisp، الأصفار البادئة لا تُعرض عادةً في مخرجات الأعداد الصحيحة.",
      "sw": "(defun reverse-three-digit (num)\n  ;; Inarudisha namba ya tarakimu tatu.\n  ;; Ingizo: Namba ya tarakimu tatu 'num'.\n  ;; Tokeo: Namba ya tarakimu tatu katika mpangilio wa nyuma. Zeros zinazoongoza zinahifadhiwa katika toleo.\n  ;; Mfano:\n  ;; >>> (reverse-three-digit 123)\n  ;; 321\n  ;; >>> (reverse-three-digit 100)\n  ;; 1 ;; Kwa Common Lisp, zeros zinazoongoza hazionyeshwi kawaida katika toleo la namba kamili.",
      "tr": "(defun reverse-three-digit (num)\n  ;; Üç basamaklı bir sayıyı ters çevirir.\n  ;; Girdi: Üç basamaklı bir tamsayı 'num'.\n  ;; Çıktı: Üç basamaklı sayının ters çevrilmiş hali. Çıktıda baştaki sıfırlar korunur.\n  ;; Örnek:\n  ;; >>> (reverse-three-digit 123)\n  ;; 321\n  ;; >>> (reverse-three-digit 100)\n  ;; 1 ;; Common Lisp için, baştaki sıfırlar genellikle tamsayı çıktısında gösterilmez.",
      "vi": "(defun reverse-three-digit (num)\n  ;; Đảo ngược một số có ba chữ số.\n  ;; Đầu vào: Một số nguyên có ba chữ số 'num'.\n  ;; Đầu ra: Số nguyên có ba chữ số theo thứ tự ngược lại. Các số không đứng đầu được giữ nguyên trong đầu ra.\n  ;; Ví dụ:\n  ;; >>> (reverse-three-digit 123)\n  ;; 321\n  ;; >>> (reverse-three-digit 100)\n  ;; 1 ;; Đối với Common Lisp, các số không đứng đầu thường không được hiển thị trong đầu ra số nguyên."
    },
    "prompt_bertscore": {
      "es": "0.9969448661093023",
      "arb": "0.9951742748927573",
      "sw": "0.960613780374973",
      "tr": "0.9725363703662112",
      "vi": "0.9793458170888493"
    },
    "canonical_solution": "  (+ (* (mod num 10) 100)\n     (* (mod (floor num 10) 10) 10)\n     (floor num 100)))",
    "instruction": {
      "es": "(defun reverse-three-digit (num)\n  (+ (* (mod num 10) 100)\n     (* (mod (floor num 10) 10) 10)\n     (floor num 100)))\n\nProporcione una descripción concisa en lenguaje natural (docstring) del código Common Lisp en español utilizando un máximo de 500 caracteres.",
      "arb": "(defun reverse-three-digit (num)\n  (+ (* (mod num 10) 100)\n     (* (mod (floor num 10) 10) 10)\n     (floor num 100)))\n\nيرجى تقديم وصف موجز بلغة طبيعية (docstring) لشفرة Common Lisp باللغة العربية الفصحى، بحيث لا يتجاوز 500 حرف.",
      "sw": "(defun reverse-three-digit (num)\n  (+ (* (mod num 10) 100)\n     (* (mod (floor num 10) 10) 10)\n     (floor num 100)))\n\nToa maelezo mafupi ya lugha ya asili (docstring) ya msimbo wa Common Lisp kwa Kiswahili kwa kutumia herufi zisizozidi 500.",
      "tr": "(defun reverse-three-digit (num)\n  (+ (* (mod num 10) 100)\n     (* (mod (floor num 10) 10) 10)\n     (floor num 100)))\n\nAşağıdaki Common Lisp kodunun Türkçe olarak en fazla 500 karakter kullanarak kısa bir doğal dil açıklamasını (docstring) sağlayın.",
      "vi": "(defun reverse-three-digit (num)\n  (+ (* (mod num 10) 100)\n     (* (mod (floor num 10) 10) 10)\n     (floor num 100)))\n\nCung cấp mô tả ngắn gọn bằng ngôn ngữ tự nhiên (docstring) cho mã Common Lisp bằng tiếng Việt, sử dụng tối đa 500 ký tự."
    },
    "instruction_bertscore": {
      "es": "0.9711352316583911",
      "arb": "0.8931430125450422",
      "sw": "0.9177628510135546",
      "tr": "0.8880251021472974",
      "vi": "0.9283341585226124"
    },
    "level": "",
    "test": "(defun check-reverse-three-digit ()\n  (assert (= (reverse-three-digit 123) 321))\n  (assert (= (reverse-three-digit 100) 1)) ;; Note: Leading zeros are not displayed in integers.\n  (assert (= (reverse-three-digit 250) 52))\n  (assert (= (reverse-three-digit 999) 999))\n  (assert (= (reverse-three-digit 500) 5)))\n\n(check-reverse-three-digit)",
    "entry_point": "reverse-three-digit",
    "signature": "(defun reverse-three-digit (num)",
    "docstring": {
      "es": "Invierte un número de tres dígitos.  \nEntrada: Un entero de tres dígitos 'num'.  \nSalida: El entero de tres dígitos en orden inverso. Los ceros a la izquierda se preservan en la salida.  \nEjemplo:  \n>>> (reverse-three-digit 123)  \n321  \n>>> (reverse-three-digit 100)  \n1 ;; Para Common Lisp, los ceros a la izquierda no se muestran típicamente en la salida de enteros.",
      "arb": "يعكس رقمًا مكونًا من ثلاثة أرقام.\nالمدخلات: عدد صحيح مكون من ثلاثة أرقام 'num'.\nالمخرجات: العدد الصحيح المكون من ثلاثة أرقام بترتيب عكسي. يتم الحفاظ على الأصفار البادئة في المخرجات.\nمثال:\n>>> (reverse-three-digit 123)\n321\n>>> (reverse-three-digit 100)\n1 ;; في لغة Common Lisp، لا يتم عادةً عرض الأصفار البادئة في مخرجات الأعداد الصحيحة.",
      "sw": "Rejelea nambari ya tarakimu tatu.  \nIngizo: Nambari ya tarakimu tatu 'num'.  \nPato: Nambari ya tarakimu tatu katika mpangilio wa nyuma. Zeros zinazoongoza zinahifadhiwa katika pato.  \nMfano:  \n>>> (reverse-three-digit 123)  \n321  \n>>> (reverse-three-digit 100)  \n1 ;; Kwa Common Lisp, zeros zinazoongoza hazionyeshwi kawaida katika pato la nambari.",
      "tr": "Üç basamaklı bir sayıyı tersine çevirir.\nGirdi: Üç basamaklı bir tamsayı 'num'.\nÇıktı: Ters sırada üç basamaklı tamsayı. Baştaki sıfırlar çıktıda korunur.\nÖrnek:\n>>> (reverse-three-digit 123)\n321\n>>> (reverse-three-digit 100)\n1 ;; Common Lisp için, baştaki sıfırlar genellikle tamsayı çıktısında gösterilmez.",
      "vi": "Đảo ngược một số có ba chữ số.  \nĐầu vào: Một số nguyên có ba chữ số 'num'.  \nĐầu ra: Số nguyên có ba chữ số theo thứ tự ngược lại. Các số 0 ở đầu được giữ nguyên trong đầu ra.  \nVí dụ:  \n>>> (reverse-three-digit 123)  \n321  \n>>> (reverse-three-digit 100)  \n1 ;; Đối với Common Lisp, các số 0 ở đầu thường không được hiển thị trong đầu ra số nguyên."
    },
    "docstring_bertscore": {
      "es": "0.9733857138755163",
      "arb": "0.9956638987820083",
      "sw": "0.944592253840699",
      "tr": "0.986557887593845",
      "vi": "0.9775120614111351"
    }
  },
  {
    "task_id": "Common Lisp/45",
    "prompt": {
      "es": "(defun int-bool-int-conversion (int)\n  ;; Convierte un entero a un booleano y luego de nuevo a un entero.\n  ;; Entrada: Un entero dentro del rango de valores enteros.\n  ;; Salida: Un entero resultante de la conversión del entero inicial a un booleano y luego de nuevo a un entero.\n  ;; La salida es 1 para cualquier entero de entrada distinto de cero, y 0 para una entrada de 0.\n  ;; Ejemplo:\n  ;; >>> (int-bool-int-conversion 3)\n  ;; 1\n  ;; >>> (int-bool-int-conversion 0)\n  ;; 0\n  ;; >>> (int-bool-int-conversion -5)\n  ;; 1",
      "arb": "(defun int-bool-int-conversion (int)\n  ;; يحول عدد صحيح إلى قيمة منطقية ثم يعيده إلى عدد صحيح.\n  ;; المدخل: عدد صحيح ضمن نطاق القيم الصحيحة.\n  ;; المخرج: عدد صحيح ناتج عن تحويل العدد الصحيح الأولي إلى قيمة منطقية ثم يعاد إلى عدد صحيح.\n  ;; المخرج هو 1 لأي عدد صحيح غير صفري، و0 للمدخل الذي يساوي 0.\n  ;; مثال:\n  ;; >>> (int-bool-int-conversion 3)\n  ;; 1\n  ;; >>> (int-bool-int-conversion 0)\n  ;; 0\n  ;; >>> (int-bool-int-conversion -5)\n  ;; 1",
      "sw": "(defun int-bool-int-conversion (int)\n  ;; Inabadilisha nambari nzima kuwa boolean na kisha kurudi kwenye nambari nzima.\n  ;; Ingizo: Nambari nzima ndani ya upeo wa thamani za nambari nzima.\n  ;; Tokeo: Nambari nzima inayotokana na ubadilishaji wa nambari nzima ya awali kuwa boolean na kisha kurudi kwenye nambari nzima.\n  ;; Tokeo ni 1 kwa ingizo lolote lisilo la sifuri, na 0 kwa ingizo la 0.\n  ;; Mfano:\n  ;; >>> (int-bool-int-conversion 3)\n  ;; 1\n  ;; >>> (int-bool-int-conversion 0)\n  ;; 0\n  ;; >>> (int-bool-int-conversion -5)\n  ;; 1",
      "tr": "(defun int-bool-int-conversion (int)\n  ;; Bir tam sayıyı boolean'a ve ardından tekrar bir tam sayıya dönüştürür.\n  ;; Girdi: Tam sayı değerleri aralığında bir tam sayı.\n  ;; Çıktı: Başlangıçtaki tam sayının önce boolean'a, ardından tekrar tam sayıya dönüştürülmesiyle elde edilen bir tam sayı.\n  ;; Çıktı, sıfır olmayan herhangi bir giriş tam sayısı için 1, ve giriş 0 olduğunda 0'dır.\n  ;; Örnek:\n  ;; >>> (int-bool-int-conversion 3)\n  ;; 1\n  ;; >>> (int-bool-int-conversion 0)\n  ;; 0\n  ;; >>> (int-bool-int-conversion -5)\n  ;; 1",
      "vi": "(defun int-bool-int-conversion (int)\n  ;; Chuyển đổi một số nguyên thành một giá trị boolean và sau đó trở lại thành một số nguyên.\n  ;; Đầu vào: Một số nguyên trong phạm vi giá trị của số nguyên.\n  ;; Đầu ra: Một số nguyên kết quả từ việc chuyển đổi số nguyên ban đầu thành một giá trị boolean và sau đó trở lại thành một số nguyên.\n  ;; Đầu ra là 1 cho bất kỳ số nguyên đầu vào nào khác 0, và 0 cho đầu vào là 0.\n  ;; Ví dụ:\n  ;; >>> (int-bool-int-conversion 3)\n  ;; 1\n  ;; >>> (int-bool-int-conversion 0)\n  ;; 0\n  ;; >>> (int-bool-int-conversion -5)\n  ;; 1"
    },
    "prompt_bertscore": {
      "es": "0.9933323753694209",
      "arb": "0.9832113629341692",
      "sw": "0.9905144061536789",
      "tr": "0.9812306207744893",
      "vi": "0.9812870318027032"
    },
    "canonical_solution": "  (if (= int 0) 0 1))",
    "instruction": {
      "es": "(defun int-bool-int-conversion (int)\n  (if (= int 0) 0 1))\n\nProporcione una descripción concisa en lenguaje natural (docstring) del código Common Lisp en español utilizando un máximo de 500 caracteres.",
      "arb": "(defun int-bool-int-conversion (int)\n  (if (= int 0) 0 1))\n\nيرجى تقديم وصف موجز بلغة طبيعية (docstring) لشيفرة Common Lisp باللغة العربية الفصحى، بحيث لا يتجاوز 500 حرف.",
      "sw": "(defun int-bool-int-conversion (int)\n  (if (= int 0) 0 1))\n\nToa maelezo mafupi ya lugha ya asili (docstring) ya msimbo wa Common Lisp kwa Kiswahili kwa kutumia herufi zisizozidi 500.",
      "tr": "(defun int-bool-int-conversion (int)\n  (if (= int 0) 0 1))\n\nAşağıdaki Common Lisp kodunun işlevini açıklayan, en fazla 500 karakterlik kısa bir doğal dil açıklaması (docstring) sağlayın.",
      "vi": "(defun int-bool-int-conversion (int)\n  (if (= int 0) 0 1))\n\nCung cấp mô tả ngắn gọn bằng ngôn ngữ tự nhiên (docstring) cho mã Common Lisp bằng tiếng Việt, sử dụng tối đa 500 ký tự."
    },
    "instruction_bertscore": {
      "es": "0.9711352316583911",
      "arb": "0.8964802015768094",
      "sw": "0.8336007750045",
      "tr": "0.839942645810182",
      "vi": "0.9119165630085547"
    },
    "level": "",
    "test": "(defun check-int-bool-int-conversion ()\n  (assert (= (int-bool-int-conversion 3) 1))\n  (assert (= (int-bool-int-conversion 0) 0))\n  (assert (= (int-bool-int-conversion -5) 1))\n  (assert (= (int-bool-int-conversion 1) 1))\n  (assert (= (int-bool-int-conversion 100) 1)))\n\n(check-int-bool-int-conversion)",
    "entry_point": "int-bool-int-conversion",
    "signature": "(defun int-bool-int-conversion (int)",
    "docstring": {
      "es": "Convierte un entero a un booleano y luego de nuevo a un entero.  \nEntrada: Un entero dentro del rango de valores enteros.  \nSalida: Un entero resultante de la conversión del entero inicial a un booleano y luego de nuevo a un entero.  \nLa salida es 1 para cualquier entero de entrada distinto de cero, y 0 para una entrada de 0.  \nEjemplo:  \n>>> (int-bool-int-conversion 3)  \n1  \n>>> (int-bool-int-conversion 0)  \n0  \n>>> (int-bool-int-conversion -5)  \n1  ",
      "arb": "يقوم بتحويل عدد صحيح إلى قيمة منطقية ثم يعيده إلى عدد صحيح.\nالمدخل: عدد صحيح ضمن نطاق القيم الصحيحة.\nالمخرج: عدد صحيح ناتج عن تحويل العدد الصحيح الأولي إلى قيمة منطقية ثم إعادته إلى عدد صحيح.\nالناتج هو 1 لأي عدد صحيح غير صفري، و0 للمدخل الذي يساوي 0.\nمثال:\n>>> (int-bool-int-conversion 3)\n1\n>>> (int-bool-int-conversion 0)\n0\n>>> (int-bool-int-conversion -5)\n1",
      "sw": "Inabadilisha nambari kamili kuwa boolean na kisha kurudi kwenye nambari kamili.  \nIngizo: Nambari kamili ndani ya wigo wa thamani za nambari kamili.  \nPato: Nambari kamili inayotokana na ubadilishaji wa nambari kamili ya awali kuwa boolean na kisha kurudi kwenye nambari kamili.  \nPato ni 1 kwa ingizo lolote la nambari kamili isiyo sifuri, na 0 kwa ingizo la 0.  \nMfano:  \n>>> (int-bool-int-conversion 3)  \n1  \n>>> (int-bool-int-conversion 0)  \n0  \n>>> (int-bool-int-conversion -5)  \n1  ",
      "tr": " Bir tam sayıyı boolean'a ve ardından tekrar tam sayıya dönüştürür.\n Girdi: Tam sayı değerleri aralığında bir tam sayı.\n Çıktı: Başlangıçtaki tam sayının boolean'a ve ardından tekrar tam sayıya dönüştürülmesiyle elde edilen bir tam sayı.\n Çıktı, sıfır olmayan herhangi bir giriş tam sayısı için 1 ve 0 giriş için 0'dır.\n Örnek:\n >>> (int-bool-int-conversion 3)\n 1\n >>> (int-bool-int-conversion 0)\n 0\n >>> (int-bool-int-conversion -5)\n 1",
      "vi": "Chuyển đổi một số nguyên thành một giá trị boolean và sau đó trở lại thành một số nguyên.  \nĐầu vào: Một số nguyên trong phạm vi các giá trị số nguyên.  \nĐầu ra: Một số nguyên kết quả từ việc chuyển đổi số nguyên ban đầu thành một giá trị boolean và sau đó trở lại thành một số nguyên.  \nĐầu ra là 1 cho bất kỳ số nguyên đầu vào nào khác 0, và 0 cho đầu vào là 0.  \nVí dụ:  \n>>> (int-bool-int-conversion 3)  \n1  \n>>> (int-bool-int-conversion 0)  \n0  \n>>> (int-bool-int-conversion -5)  \n1  "
    },
    "docstring_bertscore": {
      "es": "0.9844206246939096",
      "arb": "0.9768424783966665",
      "sw": "0.9943869040623351",
      "tr": "0.9755295315780259",
      "vi": "0.9801389482003215"
    }
  },
  {
    "task_id": "Common Lisp/46",
    "prompt": {
      "es": "(defun nth-term-arithmetic-sequence (a1 a2 n)\n  ;; Calcula el enésimo término de una secuencia aritmética dados los dos primeros términos.\n  ;; Entrada: Tres enteros 'a1' y 'a2' que representan los dos primeros términos de la secuencia, y 'n' el número de término a encontrar.\n  ;; Salida: El valor del enésimo término en la secuencia aritmética.\n  ;; Ejemplo:\n  ;; >>> (nth-term-arithmetic-sequence 1 4 100)\n  ;; 298\n  ;; >>> (nth-term-arithmetic-sequence 2 5 10)\n  ;; 29",
      "arb": "(defun nth-term-arithmetic-sequence (a1 a2 n)\n  ;; يحسب الحد النوني لمتتالية حسابية معطاة الحدين الأولين.\n  ;; المدخلات: ثلاثة أعداد صحيحة 'a1' و 'a2' تمثل الحدين الأولين من المتتالية، و 'n' رقم الحد المراد إيجاده.\n  ;; المخرجات: قيمة الحد النوني في المتتالية الحسابية.\n  ;; مثال:\n  ;; >>> (nth-term-arithmetic-sequence 1 4 100)\n  ;; 298\n  ;; >>> (nth-term-arithmetic-sequence 2 5 10)\n  ;; 29",
      "sw": "(defun nth-term-arithmetic-sequence (a1 a2 n)\n  ;; Inahesabu neno la nth la mlolongo wa hesabu ukitolewa maneno mawili ya kwanza.\n  ;; Ingizo: Nambari tatu za mzima 'a1' na 'a2' zinazowakilisha maneno mawili ya kwanza ya mlolongo, na 'n' nambari ya neno la kupata.\n  ;; Tokeo: Thamani ya neno la nth katika mlolongo wa hesabu.\n  ;; Mfano:\n  ;; >>> (nth-term-arithmetic-sequence 1 4 100)\n  ;; 298\n  ;; >>> (nth-term-arithmetic-sequence 2 5 10)\n  ;; 29",
      "tr": "(defun nth-term-arithmetic-sequence (a1 a2 n)\n  ;; İlk iki terim verildiğinde bir aritmetik dizinin n'inci terimini hesaplar.\n  ;; Girdi: Dizinin ilk iki terimini temsil eden 'a1' ve 'a2' üç tam sayı ve bulunacak terim numarası 'n'.\n  ;; Çıktı: Aritmetik dizideki n'inci terimin değeri.\n  ;; Örnek:\n  ;; >>> (nth-term-arithmetic-sequence 1 4 100)\n  ;; 298\n  ;; >>> (nth-term-arithmetic-sequence 2 5 10)\n  ;; 29",
      "vi": "(defun nth-term-arithmetic-sequence (a1 a2 n)\n  ;; Tính toán số hạng thứ n của một dãy số học cho trước hai số hạng đầu tiên.\n  ;; Đầu vào: Ba số nguyên 'a1' và 'a2' đại diện cho hai số hạng đầu tiên của dãy, và 'n' là số thứ tự của số hạng cần tìm.\n  ;; Đầu ra: Giá trị của số hạng thứ n trong dãy số học.\n  ;; Ví dụ:\n  ;; >>> (nth-term-arithmetic-sequence 1 4 100)\n  ;; 298\n  ;; >>> (nth-term-arithmetic-sequence 2 5 10)\n  ;; 29"
    },
    "prompt_bertscore": {
      "es": "1",
      "arb": "0.9874584777414571",
      "sw": "0.9861123596491838",
      "tr": "0.9576124753175359",
      "vi": "0.9753324902400393"
    },
    "canonical_solution": "  (+ a1 (* (1- n) (- a2 a1))))",
    "instruction": {
      "es": "(defun nth-term-arithmetic-sequence (a1 a2 n)\n  (+ a1 (* (1- n) (- a2 a1))))\n\nProporcione una descripción concisa en lenguaje natural (docstring) del código Common Lisp en español utilizando como máximo 500 caracteres.",
      "arb": "(defun nth-term-arithmetic-sequence (a1 a2 n)\n  (+ a1 (* (1- n) (- a2 a1))))\n\nيرجى تقديم وصف موجز بلغة طبيعية (docstring) لشفرة Common Lisp باللغة العربية الفصحى، بحيث لا يتجاوز 500 حرف.",
      "sw": "(defun nth-term-arithmetic-sequence (a1 a2 n)\n  (+ a1 (* (1- n) (- a2 a1))))\n\nToa maelezo mafupi ya lugha ya asili (docstring) ya msimbo wa Common Lisp kwa Kiswahili kwa kutumia herufi zisizozidi 500.",
      "tr": "(defun nth-term-arithmetic-sequence (a1 a2 n)\n  (+ a1 (* (1- n) (- a2 a1))))\n\nAşağıdaki Common Lisp kodunun işlevini açıklayan, en fazla 500 karakter uzunluğunda bir doğal dil açıklaması (docstring) sağlayın.",
      "vi": "(defun nth-term-arithmetic-sequence (a1 a2 n)\n  (+ a1 (* (1- n) (- a2 a1))))\n\nCung cấp mô tả ngắn gọn bằng ngôn ngữ tự nhiên (docstring) cho mã Common Lisp bằng tiếng Việt, sử dụng tối đa 500 ký tự."
    },
    "instruction_bertscore": {
      "es": "0.9711352316583911",
      "arb": "0.9060988777784239",
      "sw": "0.9454739741021129",
      "tr": "0.833441274808529",
      "vi": "0.9283341585226124"
    },
    "level": "",
    "test": "(defun check-nth-term-arithmetic-sequence ()\n  (assert (= (nth-term-arithmetic-sequence 1 4 100) 298))\n  (assert (= (nth-term-arithmetic-sequence 2 5 10) 29))\n  (assert (= (nth-term-arithmetic-sequence 0 3 4) 9))\n  (assert (= (nth-term-arithmetic-sequence -3 1 5) 13))\n  (assert (= (nth-term-arithmetic-sequence 100 -100 50) -9700)))\n\n(check-nth-term-arithmetic-sequence)",
    "entry_point": "nth-term-arithmetic-sequence",
    "signature": "(defun nth-term-arithmetic-sequence (a1 a2 n)",
    "docstring": {
      "es": "Calcula el término n de una secuencia aritmética dados los dos primeros términos.  \nEntrada: Tres enteros 'a1' y 'a2' que representan los dos primeros términos de la secuencia, y 'n' el número del término a encontrar.  \nSalida: El valor del término n en la secuencia aritmética.  \nEjemplo:  \n>>> (nth-term-arithmetic-sequence 1 4 100)  \n298  \n>>> (nth-term-arithmetic-sequence 2 5 10)  \n29",
      "arb": "يحسب الحد النوني لمتتالية حسابية معطاة أول حدين منها.  \nالمدخلات: ثلاثة أعداد صحيحة 'a1' و 'a2' تمثل أول حدين في المتتالية، و 'n' رقم الحد المراد إيجاده.  \nالمخرجات: قيمة الحد النوني في المتتالية الحسابية.  \nمثال:  \n>>> (nth-term-arithmetic-sequence 1 4 100)  \n298  \n>>> (nth-term-arithmetic-sequence 2 5 10)  \n29  ",
      "sw": "Hesabu neno la nth la mlolongo wa hesabu ukizingatia maneno mawili ya kwanza.\nIngizo: Nambari tatu za mzima 'a1' na 'a2' zinazoashiria maneno mawili ya kwanza ya mlolongo, na 'n' nambari ya neno la kupata.\nPato: Thamani ya neno la nth katika mlolongo wa hesabu.\nMfano:\n>>> (nth-term-arithmetic-sequence 1 4 100)\n298\n>>> (nth-term-arithmetic-sequence 2 5 10)\n29",
      "tr": " nth terimini, ilk iki terim verildiğinde bir aritmetik dizinin hesaplar.\n Girdi: Dizinin ilk iki terimini temsil eden üç tam sayı 'a1' ve 'a2', ve bulunacak terim numarası 'n'.\n Çıktı: Aritmetik dizideki nth teriminin değeri.\n Örnek:\n >>> (nth-term-arithmetic-sequence 1 4 100)\n 298\n >>> (nth-term-arithmetic-sequence 2 5 10)\n 29",
      "vi": "Tính toán số hạng thứ n của một dãy số học cho trước hai số hạng đầu tiên.\nĐầu vào: Ba số nguyên 'a1' và 'a2' đại diện cho hai số hạng đầu tiên của dãy số, và 'n' là số thứ tự của số hạng cần tìm.\nĐầu ra: Giá trị của số hạng thứ n trong dãy số học.\nVí dụ:\n>>> (nth-term-arithmetic-sequence 1 4 100)\n298\n>>> (nth-term-arithmetic-sequence 2 5 10)\n29"
    },
    "docstring_bertscore": {
      "es": "0.9866927576225677",
      "arb": "0.969188058033106",
      "sw": "0.982851643314115",
      "tr": "0.9530125929535299",
      "vi": "0.9693509349455547"
    }
  },
  {
    "task_id": "Common Lisp/47",
    "prompt": {
      "es": "(defun multiply-a-b (a b)\n  ;; Multiplica dos enteros positivos A y B y devuelve el producto.\n  ;; Entrada: Dos enteros positivos 'a' y 'b', donde 1 <= a, b <= 50000.\n  ;; Salida: El producto de 'a' y 'b'.\n  ;; Ejemplo:\n  ;; >>> (multiply-a-b 3 4)\n  ;; 12\n  ;; >>> (multiply-a-b 36 18)\n  ;; 648",
      "arb": "(defun multiply-a-b (a b)\n  ;; يضرب عددين صحيحين موجبين A و B ويعيد الناتج.\n  ;; المدخلات: عددان صحيحان موجبان 'a' و 'b'، حيث 1 <= a, b <= 50000.\n  ;; المخرجات: ناتج ضرب 'a' و 'b'.\n  ;; مثال:\n  ;; >>> (multiply-a-b 3 4)\n  ;; 12\n  ;; >>> (multiply-a-b 36 18)\n  ;; 648",
      "sw": "(defun multiply-a-b (a b)\n  ;; Huzidisha nambari mbili nzima chanya A na B na kurudisha bidhaa.\n  ;; Ingizo: Nambari mbili nzima chanya 'a' na 'b', ambapo 1 <= a, b <= 50000.\n  ;; Tokeo: Bidhaa ya 'a' na 'b'.\n  ;; Mfano:\n  ;; >>> (multiply-a-b 3 4)\n  ;; 12\n  ;; >>> (multiply-a-b 36 18)\n  ;; 648",
      "tr": "(defun multiply-a-b (a b)\n  ;; İki pozitif tam sayı A ve B'yi çarpar ve çarpımı döndürür.\n  ;; Girdi: 1 <= a, b <= 50000 olan iki pozitif tam sayı 'a' ve 'b'.\n  ;; Çıktı: 'a' ve 'b'nin çarpımı.\n  ;; Örnek:\n  ;; >>> (multiply-a-b 3 4)\n  ;; 12\n  ;; >>> (multiply-a-b 36 18)\n  ;; 648",
      "vi": "(defun multiply-a-b (a b)\n  ;; Nhân hai số nguyên dương A và B và trả về tích.\n  ;; Đầu vào: Hai số nguyên dương 'a' và 'b', với 1 <= a, b <= 50000.\n  ;; Đầu ra: Tích của 'a' và 'b'.\n  ;; Ví dụ:\n  ;; >>> (multiply-a-b 3 4)\n  ;; 12\n  ;; >>> (multiply-a-b 36 18)\n  ;; 648"
    },
    "prompt_bertscore": {
      "es": "1",
      "arb": "0.9700435590842234",
      "sw": "0.9888594178188962",
      "tr": "0.9971119142597528",
      "vi": "0.9871249773316996"
    },
    "canonical_solution": "  (* a b))",
    "instruction": {
      "es": "(defun multiply-a-b (a b)\n  (* a b))\n\nProporcione una descripción concisa en lenguaje natural (docstring) del código Common Lisp en español utilizando un máximo de 500 caracteres.",
      "arb": "(defun multiply-a-b (a b)\n  (* a b))\n\nيرجى تقديم وصف موجز بلغة طبيعية (docstring) لشيفرة Common Lisp باللغة العربية الفصحى، بحيث لا يتجاوز 500 حرف.",
      "sw": "(defun multiply-a-b (a b)\n  (* a b))\n\nToa maelezo mafupi ya lugha ya asili (docstring) ya msimbo wa Common Lisp kwa Kiswahili kwa kutumia herufi zisizozidi 500.",
      "tr": "(defun multiply-a-b (a b)\n  (* a b))\n\nAşağıdaki Common Lisp kodunun işlevini açıklayan kısa bir doğal dil açıklaması (docstring) sağlayın. Açıklama en fazla 500 karakter olmalıdır.",
      "vi": "(defun multiply-a-b (a b)\n  (* a b))\n\nCung cấp mô tả ngắn gọn bằng ngôn ngữ tự nhiên (docstring) cho mã Common Lisp bằng tiếng Việt, sử dụng tối đa 500 ký tự."
    },
    "instruction_bertscore": {
      "es": "0.9711352316583911",
      "arb": "0.9060988777784239",
      "sw": "0.9177628510135546",
      "tr": "0.8329856167144349",
      "vi": "0.9119165630085547"
    },
    "level": "",
    "test": "(defun check-multiply-a-b ()\n  (assert (= (multiply-a-b 3 4) 12))\n  (assert (= (multiply-a-b 36 18) 648))\n  (assert (= (multiply-a-b 1 50000) 50000))\n  (assert (= (multiply-a-b 50000 50000) 2500000000))\n  (assert (= (multiply-a-b 123 456) 56088)))\n\n(check-multiply-a-b)",
    "entry_point": "multiply-a-b",
    "signature": "(defun multiply-a-b (a b)",
    "docstring": {
      "es": "Multiplica dos enteros positivos A y B y devuelve el producto.  \nEntrada: Dos enteros positivos 'a' y 'b', donde 1 <= a, b <= 50000.  \nSalida: El producto de 'a' y 'b'.  \nEjemplo:  \n>>> (multiply-a-b 3 4)  \n12  \n>>> (multiply-a-b 36 18)  \n648  ",
      "arb": "يضرب عددين صحيحين موجبين A و B ويعيد الناتج.\nالمدخلات: عددان صحيحان موجبان 'a' و 'b'، حيث 1 <= a, b <= 50000.\nالمخرجات: حاصل ضرب 'a' و 'b'.\nمثال:\n>>> (multiply-a-b 3 4)\n12\n>>> (multiply-a-b 36 18)\n648",
      "sw": "Huzidisha nambari mbili nzima chanya A na B na rudisha zao.\nIngizo: Nambari mbili nzima chanya 'a' na 'b', ambapo 1 <= a, b <= 50000.\nPato: Zao la 'a' na 'b'.\nMfano:\n>>> (multiply-a-b 3 4)\n12\n>>> (multiply-a-b 36 18)\n648",
      "tr": "İki pozitif tam sayı A ve B'yi çarpar ve çarpımı döndürür.\nGirdi: 1 <= a, b <= 50000 olan iki pozitif tam sayı 'a' ve 'b'.\nÇıktı: 'a' ve 'b'nin çarpımı.\nÖrnek:\n>>> (multiply-a-b 3 4)\n12\n>>> (multiply-a-b 36 18)\n648",
      "vi": "Nhân hai số nguyên dương A và B và trả về tích.\n\nĐầu vào: Hai số nguyên dương 'a' và 'b', với 1 <= a, b <= 50000.\n\nĐầu ra: Tích của 'a' và 'b'.\n\nVí dụ:\n>>> (multiply-a-b 3 4)\n12\n>>> (multiply-a-b 36 18)\n648"
    },
    "docstring_bertscore": {
      "es": "0.9874092174069605",
      "arb": "0.9805570651523999",
      "sw": "0.9874092174069605",
      "tr": "0.9969544003675921",
      "vi": "0.9825588621324696"
    }
  },
  {
    "task_id": "Common Lisp/48",
    "prompt": {
      "es": "(defun power-of-two (n)\n  ;; Calcula 2 elevado a la potencia de n, donde n es un entero no negativo.\n  ;; Entrada: Un entero no negativo 'n' (0 <= n < 31).\n  ;; Salida: Un entero que representa 2^n.\n  ;; Ejemplo:\n  ;; >>> (power-of-two 3)\n  ;; 8\n  ;; >>> (power-of-two 10)\n  ;; 1024",
      "arb": "(defun power-of-two (n)\n  ;; يحسب 2 مرفوعة إلى قوة n، حيث n هو عدد صحيح غير سالب.\n  ;; المدخل: عدد صحيح غير سالب 'n' (0 <= n < 31).\n  ;; المخرج: عدد صحيح يمثل 2^n.\n  ;; مثال:\n  ;; >>> (power-of-two 3)\n  ;; 8\n  ;; >>> (power-of-two 10)\n  ;; 1024",
      "sw": "(defun power-of-two (n)\n  ;; Inahesabu 2 iliyoinuliwa kwa nguvu ya n, ambapo n ni nambari kamili isiyo hasi.\n  ;; Ingizo: Nambari kamili isiyo hasi 'n' (0 <= n < 31).\n  ;; Tokeo: Nambari kamili inayowakilisha 2^n.\n  ;; Mfano:\n  ;; >>> (power-of-two 3)\n  ;; 8\n  ;; >>> (power-of-two 10)\n  ;; 1024",
      "tr": "(defun power-of-two (n)\n  ;; n'inci kuvvetine yükseltilmiş 2'yi hesaplar, burada n negatif olmayan bir tam sayıdır.\n  ;; Girdi: Negatif olmayan bir tam sayı 'n' (0 <= n < 31).\n  ;; Çıktı: 2^n'i temsil eden bir tam sayı.\n  ;; Örnek:\n  ;; >>> (power-of-two 3)\n  ;; 8\n  ;; >>> (power-of-two 10)\n  ;; 1024",
      "vi": "(defun power-of-two (n)\n  ;; Tính 2 lũy thừa n, trong đó n là một số nguyên không âm.\n  ;; Đầu vào: Một số nguyên không âm 'n' (0 <= n < 31).\n  ;; Đầu ra: Một số nguyên đại diện cho 2^n.\n  ;; Ví dụ:\n  ;; >>> (power-of-two 3)\n  ;; 8\n  ;; >>> (power-of-two 10)\n  ;; 1024"
    },
    "prompt_bertscore": {
      "es": "1",
      "arb": "1",
      "sw": "0.98529976276037",
      "tr": "1",
      "vi": "0.9976837711267522"
    },
    "canonical_solution": "  (expt 2 n))",
    "instruction": {
      "es": "(defun power-of-two (n)\n  (expt 2 n))\n\nProporcione una descripción concisa en lenguaje natural (docstring) del código Common Lisp en español utilizando como máximo 500 caracteres.",
      "arb": "(defun power-of-two (n)\n  (expt 2 n))\n\nيرجى تقديم وصف موجز بلغة طبيعية (docstring) لشفرة Common Lisp باللغة العربية الفصحى، بحيث لا يتجاوز 500 حرف.",
      "sw": "(defun power-of-two (n)\n  (expt 2 n))\n\nToa maelezo mafupi ya lugha ya asili (docstring) ya msimbo wa Common Lisp kwa Kiswahili kwa kutumia herufi zisizozidi 500.",
      "tr": "(defun power-of-two (n)\n  (expt 2 n))\n\nAşağıdaki Common Lisp kodunun işlevini açıklayan kısa bir doğal dil açıklaması (docstring) sağlayın. Açıklama Türkçe olmalı ve en fazla 500 karakter içermelidir.",
      "vi": "(defun power-of-two (n)\n  (expt 2 n))\n\nCung cấp mô tả ngắn gọn bằng ngôn ngữ tự nhiên (docstring) cho mã Common Lisp bằng tiếng Việt, sử dụng tối đa 500 ký tự."
    },
    "instruction_bertscore": {
      "es": "0.9711352316583911",
      "arb": "0.8841158576181497",
      "sw": "0.8914782913215888",
      "tr": "0.8595504438740409",
      "vi": "0.9227200694330423"
    },
    "level": "",
    "test": "(defun check-power-of-two ()\n  (assert (= (power-of-two 3) 8))\n  (assert (= (power-of-two 10) 1024))\n  (assert (= (power-of-two 0) 1))\n  (assert (= (power-of-two 5) 32))\n  (assert (= (power-of-two 15) 32768)))\n\n(check-power-of-two)",
    "entry_point": "power-of-two",
    "signature": "(defun power-of-two (n)",
    "docstring": {
      "es": " Calcula 2 elevado a la potencia de n, donde n es un entero no negativo.\n Entrada: Un entero no negativo 'n' (0 <= n < 31).\n Salida: Un entero que representa 2^n.\n Ejemplo:\n >>> (power-of-two 3)\n 8\n >>> (power-of-two 10)\n 1024",
      "arb": "يحسب 2 مرفوعًا إلى قوة n، حيث n هو عدد صحيح غير سالب.\nالمدخل: عدد صحيح غير سالب 'n' (0 <= n < 31).\nالمخرج: عدد صحيح يمثل 2^n.\nمثال:\n>>> (power-of-two 3)\n8\n>>> (power-of-two 10)\n1024",
      "sw": " Inakokotoa 2 iliyopandishwa kwa nguvu ya n, ambapo n ni nambari isiyo hasi.\n Ingizo: Nambari isiyo hasi 'n' (0 <= n < 31).\n Tokeo: Nambari inayowakilisha 2^n.\n Mfano:\n >>> (power-of-two 3)\n 8\n >>> (power-of-two 10)\n 1024",
      "tr": " n'in negatif olmayan bir tam sayı olduğu durumlarda 2'nin n'inci kuvvetini hesaplar.\n Girdi: Negatif olmayan bir tam sayı 'n' (0 <= n < 31).\n Çıktı: 2^n'i temsil eden bir tam sayı.\n Örnek:\n >>> (power-of-two 3)\n 8\n >>> (power-of-two 10)\n 1024",
      "vi": "Tính 2 lũy thừa n, trong đó n là một số nguyên không âm.  \nĐầu vào: Một số nguyên không âm 'n' (0 <= n < 31).  \nĐầu ra: Một số nguyên đại diện cho 2^n.  \nVí dụ:  \n>>> (power-of-two 3)  \n8  \n>>> (power-of-two 10)  \n1024  "
    },
    "docstring_bertscore": {
      "es": "1",
      "arb": "1",
      "sw": "0.9699696685824784",
      "tr": "0.935152742242778",
      "vi": "0.9843465355617835"
    }
  },
  {
    "task_id": "Common Lisp/49",
    "prompt": {
      "es": "(defun judge-sign (n)\n  ;; Determina si un entero N es positivo, negativo o cero.\n  ;; Entrada: Un entero 'N' (-10^9 <= N <= 10^9).\n  ;; Salida: Una cadena \"positive\" si N > 0, \"zero\" si N = 0, o \"negative\" si N < 0.\n  ;; Ejemplo:\n  ;; >>> (judge-sign 95)\n  ;; \"positive\"\n  ;; >>> (judge-sign 0)\n  ;; \"zero\"\n  ;; >>> (judge-sign -3)\n  ;; \"negative\"",
      "arb": "(defun judge-sign (n)\n  ;; يحدد ما إذا كان العدد الصحيح N موجبًا أو سالبًا أو صفرًا.\n  ;; المدخل: عدد صحيح 'N' (-10^9 <= N <= 10^9).\n  ;; المخرج: سلسلة نصية \"positive\" إذا كان N > 0، \"zero\" إذا كان N = 0، أو \"negative\" إذا كان N < 0.\n  ;; مثال:\n  ;; >>> (judge-sign 95)\n  ;; \"positive\"\n  ;; >>> (judge-sign 0)\n  ;; \"zero\"\n  ;; >>> (judge-sign -3)\n  ;; \"negative\"",
      "sw": "(defun judge-sign (n)\n  ;; Huamua ikiwa nambari nzima N ni chanya, hasi, au sifuri.\n  ;; Ingizo: Nambari nzima 'N' (-10^9 <= N <= 10^9).\n  ;; Tokeo: Mstari \"positive\" ikiwa N > 0, \"zero\" ikiwa N = 0, au \"negative\" ikiwa N < 0.\n  ;; Mfano:\n  ;; >>> (judge-sign 95)\n  ;; \"positive\"\n  ;; >>> (judge-sign 0)\n  ;; \"zero\"\n  ;; >>> (judge-sign -3)\n  ;; \"negative\"",
      "tr": "(defun judge-sign (n)\n  ;; Bir tam sayı N'nin pozitif, negatif veya sıfır olup olmadığını belirler.\n  ;; Girdi: Bir tam sayı 'N' (-10^9 <= N <= 10^9).\n  ;; Çıktı: N > 0 ise \"positive\", N = 0 ise \"zero\" veya N < 0 ise \"negative\" bir string.\n  ;; Örnek:\n  ;; >>> (judge-sign 95)\n  ;; \"positive\"\n  ;; >>> (judge-sign 0)\n  ;; \"zero\"\n  ;; >>> (judge-sign -3)\n  ;; \"negative\"",
      "vi": "(defun judge-sign (n)\n  ;; Xác định xem một số nguyên N là dương, âm hay bằng không.\n  ;; Đầu vào: Một số nguyên 'N' (-10^9 <= N <= 10^9).\n  ;; Đầu ra: Một chuỗi \"positive\" nếu N > 0, \"zero\" nếu N = 0, hoặc \"negative\" nếu N < 0.\n  ;; Ví dụ:\n  ;; >>> (judge-sign 95)\n  ;; \"positive\"\n  ;; >>> (judge-sign 0)\n  ;; \"zero\"\n  ;; >>> (judge-sign -3)\n  ;; \"negative\""
    },
    "prompt_bertscore": {
      "es": "1",
      "arb": "0.9870183128170839",
      "sw": "0.9900315356973831",
      "tr": "0.9994110609202316",
      "vi": "0.9935929784293387"
    },
    "canonical_solution": "  (cond ((> n 0) \"positive\")\n        ((< n 0) \"negative\")\n        (t \"zero\")))",
    "instruction": {
      "es": "(defun judge-sign (n)\n  (cond ((> n 0) \"positive\")\n        ((< n 0) \"negative\")\n        (t \"zero\")))\n\nProporcione una descripción concisa en lenguaje natural (docstring) del código Common Lisp en español utilizando como máximo 500 caracteres.",
      "arb": "(defun judge-sign (n)\n  (cond ((> n 0) \"positive\")\n        ((< n 0) \"negative\")\n        (t \"zero\")))\n\nيرجى تقديم وصف موجز بلغة طبيعية (docstring) لشفرة Common Lisp باللغة العربية الفصحى باستخدام ما لا يزيد عن 500 حرف.",
      "sw": "(defun judge-sign (n)\n  (cond ((> n 0) \"positive\")\n        ((< n 0) \"negative\")\n        (t \"zero\")))\n\nToa maelezo mafupi ya lugha ya asili (docstring) ya msimbo wa Common Lisp kwa Kiswahili kwa kutumia herufi zisizozidi 500.",
      "tr": "(defun judge-sign (n)\n  (cond ((> n 0) \"positive\")\n        ((< n 0) \"negative\")\n        (t \"zero\")))\n\nAşağıdaki Common Lisp kodunun işlevselliğini açıklayan, en fazla 500 karakter uzunluğunda, özlü bir doğal dil açıklaması (docstring) sağlayın.",
      "vi": "(defun judge-sign (n)\n  (cond ((> n 0) \"positive\")\n        ((< n 0) \"negative\")\n        (t \"zero\")))\n\nCung cấp mô tả ngắn gọn bằng ngôn ngữ tự nhiên (docstring) cho mã Common Lisp bằng tiếng Việt, sử dụng tối đa 500 ký tự."
    },
    "instruction_bertscore": {
      "es": "0.9711352316583911",
      "arb": "0.8950613847650772",
      "sw": "0.9127128722061235",
      "tr": "0.8628721397360873",
      "vi": "0.9119165630085547"
    },
    "level": "",
    "test": "(defun check-judge-sign ()\n  (assert (string= (judge-sign 95) \"positive\"))\n  (assert (string= (judge-sign 0) \"zero\"))\n  (assert (string= (judge-sign -3) \"negative\"))\n  (assert (string= (judge-sign 1) \"positive\"))\n  (assert (string= (judge-sign -1000000) \"negative\")))\n\n(check-judge-sign)",
    "entry_point": "judge-sign",
    "signature": "(defun judge-sign (n)",
    "docstring": {
      "es": "Determina si un entero N es positivo, negativo o cero.\nEntrada: Un entero 'N' (-10^9 <= N <= 10^9).\nSalida: Una cadena \"positive\" si N > 0, \"zero\" si N = 0, o \"negative\" si N < 0.\nEjemplo:\n>>> (judge-sign 95)\n\"positive\"\n>>> (judge-sign 0)\n\"zero\"\n>>> (judge-sign -3)\n\"negative\"",
      "arb": " يحدد ما إذا كان العدد الصحيح N موجبًا أو سالبًا أو صفرًا.\n المدخلات: عدد صحيح 'N' (-10^9 <= N <= 10^9).\n المخرجات: سلسلة نصية \"positive\" إذا كان N > 0، \"zero\" إذا كان N = 0، أو \"negative\" إذا كان N < 0.\n مثال:\n >>> (judge-sign 95)\n \"positive\"\n >>> (judge-sign 0)\n \"zero\"\n >>> (judge-sign -3)\n \"negative\"",
      "sw": "Determines if an integer N is positive, negative, or zero.  \nInaamua ikiwa nambari kamili N ni chanya, hasi, au sifuri.  \nInput: An integer 'N' (-10^9 <= N <= 10^9).  \nIngizo: Nambari kamili 'N' (-10^9 <= N <= 10^9).  \nOutput: A string \"positive\" if N > 0, \"zero\" if N = 0, or \"negative\" if N < 0.  \nPato: Mstari \"positive\" ikiwa N > 0, \"zero\" ikiwa N = 0, au \"negative\" ikiwa N < 0.  \nExample:  \nMfano:  \n>>> (judge-sign 95)  \n\"positive\"  \n>>> (judge-sign 0)  \n\"zero\"  \n>>> (judge-sign -3)  \n\"negative\"  ",
      "tr": "Belirtilen bir tam sayı N'nin pozitif, negatif veya sıfır olup olmadığını belirler.\n Girdi: Bir tam sayı 'N' (-10^9 <= N <= 10^9).\n Çıktı: N > 0 ise \"positive\", N = 0 ise \"zero\" veya N < 0 ise \"negative\" bir dize.\n Örnek:\n >>> (judge-sign 95)\n \"positive\"\n >>> (judge-sign 0)\n \"zero\"\n >>> (judge-sign -3)\n \"negative\"",
      "vi": "Xác định xem một số nguyên N là dương, âm hay bằng không.  \nĐầu vào: Một số nguyên 'N' (-10^9 <= N <= 10^9).  \nĐầu ra: Một chuỗi \"positive\" nếu N > 0, \"zero\" nếu N = 0, hoặc \"negative\" nếu N < 0.  \nVí dụ:  \n>>> (judge-sign 95)  \n\"positive\"  \n>>> (judge-sign 0)  \n\"zero\"  \n>>> (judge-sign -3)  \n\"negative\"  "
    },
    "docstring_bertscore": {
      "es": "1",
      "arb": "0.9883084171419054",
      "sw": "0.8866084702697565",
      "tr": "0.9948344183108067",
      "vi": "0.9922996960184205"
    }
  },
  {
    "task_id": "Common Lisp/50",
    "prompt": {
      "es": "(defun abs-value (n)\n  ;; Devuelve el valor absoluto de un entero n.\n  ;; Entrada: Un entero 'n', donde el valor absoluto de n no excede 10000.\n  ;; Salida: El valor absoluto de 'n'.\n  ;; Ejemplo:\n  ;; >>> (abs-value -3)\n  ;; 3\n  ;; >>> (abs-value 5)\n  ;; 5\n  ;; >>> (abs-value 0)\n  ;; 0",
      "arb": "(defun abs-value (n)\n  ;; يُخرج القيمة المطلقة لعدد صحيح n.\n  ;; المدخل: عدد صحيح 'n'، حيث لا تتجاوز القيمة المطلقة لـ n 10000.\n  ;; المخرج: القيمة المطلقة لـ 'n'.\n  ;; مثال:\n  ;; >>> (abs-value -3)\n  ;; 3\n  ;; >>> (abs-value 5)\n  ;; 5\n  ;; >>> (abs-value 0)\n  ;; 0",
      "sw": "(defun abs-value (n)\n  ;; Inatoa thamani kamili ya nambari nzima n.\n  ;; Ingizo: Nambari nzima 'n', ambapo thamani kamili ya n haizidi 10000.\n  ;; Tokeo: Thamani kamili ya 'n'.\n  ;; Mfano:\n  ;; >>> (abs-value -3)\n  ;; 3\n  ;; >>> (abs-value 5)\n  ;; 5\n  ;; >>> (abs-value 0)\n  ;; 0",
      "tr": "(defun abs-value (n)\n  ;; Bir tam sayının mutlak değerini çıktılar.\n  ;; Girdi: Mutlak değeri 10000'i aşmayan bir tam sayı 'n'.\n  ;; Çıktı: 'n' sayısının mutlak değeri.\n  ;; Örnek:\n  ;; >>> (abs-value -3)\n  ;; 3\n  ;; >>> (abs-value 5)\n  ;; 5\n  ;; >>> (abs-value 0)\n  ;; 0",
      "vi": "(defun abs-value (n)\n  ;; Xuất giá trị tuyệt đối của một số nguyên n.\n  ;; Đầu vào: Một số nguyên 'n', trong đó giá trị tuyệt đối của n không vượt quá 10000.\n  ;; Đầu ra: Giá trị tuyệt đối của 'n'.\n  ;; Ví dụ:\n  ;; >>> (abs-value -3)\n  ;; 3\n  ;; >>> (abs-value 5)\n  ;; 5\n  ;; >>> (abs-value 0)\n  ;; 0"
    },
    "prompt_bertscore": {
      "es": "0.9875673271902643",
      "arb": "0.999999801369619",
      "sw": "0.9692234142409303",
      "tr": "0.973076645002626",
      "vi": "0.9924876003588795"
    },
    "canonical_solution": "  (abs n))",
    "instruction": {
      "es": "(defun abs-value (n)\n  (abs n))\n\nProporcione una descripción concisa en lenguaje natural (docstring) del código Common Lisp en español utilizando un máximo de 500 caracteres.",
      "arb": "(defun abs-value (n)\n  (abs n))\n\nيرجى تقديم وصف موجز بلغة طبيعية (docstring) للكود المكتوب بلغة Common Lisp باللغة العربية الفصحى، بحيث لا يتجاوز 500 حرف.",
      "sw": "(defun abs-value (n)\n  (abs n))\n\nToa maelezo mafupi ya lugha ya asili (docstring) ya msimbo wa Common Lisp kwa Kiswahili kwa kutumia herufi zisizozidi 500.",
      "tr": "(defun abs-value (n)\n  (abs n))\n\nAşağıdaki Common Lisp kodunun doğal dilde kısa bir açıklamasını (docstring) Türkçe olarak en fazla 500 karakter kullanarak sağlayın.",
      "vi": "(defun abs-value (n)\n  (abs n))\n\nCung cấp mô tả ngắn gọn bằng ngôn ngữ tự nhiên (docstring) cho mã Common Lisp bằng tiếng Việt, sử dụng tối đa 500 ký tự."
    },
    "instruction_bertscore": {
      "es": "0.9711352316583911",
      "arb": "0.8798955579123015",
      "sw": "0.9177628510135546",
      "tr": "0.8431249031447419",
      "vi": "0.9283341585226124"
    },
    "level": "",
    "test": "(defun check-abs-value ()\n  (assert (= (abs-value -3) 3))\n  (assert (= (abs-value 5) 5))\n  (assert (= (abs-value 0) 0))\n  (assert (= (abs-value -10000) 10000))\n  (assert (= (abs-value 9999) 9999)))\n\n(check-abs-value)",
    "entry_point": "abs-value",
    "signature": "(defun abs-value (n)",
    "docstring": {
      "es": "Devuelve el valor absoluto de un entero n.  \nEntrada: Un entero 'n', donde el valor absoluto de n no excede 10000.  \nSalida: El valor absoluto de 'n'.  \nEjemplo:  \n>>> (abs-value -3)  \n3  \n>>> (abs-value 5)  \n5  \n>>> (abs-value 0)  \n0  ",
      "arb": "يُخرج القيمة المطلقة لعدد صحيح n.\nالمدخلات: عدد صحيح 'n'، حيث لا تتجاوز القيمة المطلقة لـ n 10000.\nالمخرجات: القيمة المطلقة لـ 'n'.\nمثال:\n>>> (abs-value -3)\n3\n>>> (abs-value 5)\n5\n>>> (abs-value 0)\n0",
      "sw": "Inatoa thamani kamili ya nambari nzima n.  \nIngizo: Nambari nzima 'n', ambapo thamani kamili ya n haizidi 10000.  \nPato: Thamani kamili ya 'n'.  \nMfano:  \n>>> (abs-value -3)  \n3  \n>>> (abs-value 5)  \n5  \n>>> (abs-value 0)  \n0  ",
      "tr": " Mutlak değeri bir tamsayı olan n'in çıktısını verir.\n Girdi: Mutlak değeri 10000'i aşmayan bir tamsayı 'n'.\n Çıktı: 'n'in mutlak değeri.\n Örnek:\n >>> (abs-value -3)\n 3\n >>> (abs-value 5)\n 5\n >>> (abs-value 0)\n 0",
      "vi": "Đầu ra là giá trị tuyệt đối của một số nguyên n.  \nĐầu vào: Một số nguyên 'n', trong đó giá trị tuyệt đối của n không vượt quá 10000.  \nĐầu ra: Giá trị tuyệt đối của 'n'.  \nVí dụ:  \n>>> (abs-value -3)  \n3  \n>>> (abs-value 5)  \n5  \n>>> (abs-value 0)  \n0  "
    },
    "docstring_bertscore": {
      "es": "0.985584201466012",
      "arb": "0.9857292016441674",
      "sw": "0.9645226276433586",
      "tr": "0.9516102624634236",
      "vi": "0.9893204389332783"
    }
  }
]