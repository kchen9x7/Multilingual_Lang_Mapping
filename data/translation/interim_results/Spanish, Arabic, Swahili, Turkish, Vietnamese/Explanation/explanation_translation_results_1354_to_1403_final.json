[
  {
    "task_id": "Python/1",
    "prompt": {
      "en": "from typing import List\n \ndef has_close_elements(numbers: List[float], threshold: float) -> bool:\n    \"\"\" Check if in given list of numbers, are any two numbers closer to each other than\n    given threshold.\n    >>> has_close_elements([1.0, 2.0, 3.0], 0.5)\n    False\n    >>> has_close_elements([1.0, 2.8, 3.0, 4.0, 5.0, 2.0], 0.3)\n    True\n    \"\"\"",
      "es": "from typing import List\n \ndef has_close_elements(numbers: List[float], threshold: float) -> bool:\n    \"\"\" Verifica si en la lista dada de números, hay dos números más cercanos entre sí que\n    el umbral dado.\n    >>> has_close_elements([1.0, 2.0, 3.0], 0.5)\n    False\n    >>> has_close_elements([1.0, 2.8, 3.0, 4.0, 5.0, 2.0], 0.3)\n    True\n    \"\"\"",
      "arb": "from typing import List\n \ndef has_close_elements(numbers: List[float], threshold: float) -> bool:\n    \"\"\" التحقق مما إذا كان في قائمة الأرقام المعطاة، يوجد أي رقمين أقرب إلى بعضهما من العتبة المعطاة.\n    >>> has_close_elements([1.0, 2.0, 3.0], 0.5)\n    False\n    >>> has_close_elements([1.0, 2.8, 3.0, 4.0, 5.0, 2.0], 0.3)\n    True\n    \"\"\"",
      "sw": "from typing import List\n \ndef has_close_elements(numbers: List[float], threshold: float) -> bool:\n    \"\"\" Angalia kama katika orodha iliyotolewa ya namba, kuna namba zozote mbili zilizo karibu zaidi kuliko\n    kizingiti kilichotolewa.\n    >>> has_close_elements([1.0, 2.0, 3.0], 0.5)\n    False\n    >>> has_close_elements([1.0, 2.8, 3.0, 4.0, 5.0, 2.0], 0.3)\n    True\n    \"\"\"",
      "tr": "from typing import List\n \ndef has_close_elements(numbers: List[float], threshold: float) -> bool:\n    \"\"\" Verilen sayı listesindeki herhangi iki sayının birbirine\n    verilen eşikten daha yakın olup olmadığını kontrol et.\n    >>> has_close_elements([1.0, 2.0, 3.0], 0.5)\n    False\n    >>> has_close_elements([1.0, 2.8, 3.0, 4.0, 5.0, 2.0], 0.3)\n    True\n    \"\"\"",
      "vi": "from typing import List\n \ndef has_close_elements(numbers: List[float], threshold: float) -> bool:\n    \"\"\" Kiểm tra xem trong danh sách số đã cho, có bất kỳ hai số nào gần nhau hơn\n    ngưỡng đã cho không.\n    >>> has_close_elements([1.0, 2.0, 3.0], 0.5)\n    False\n    >>> has_close_elements([1.0, 2.8, 3.0, 4.0, 5.0, 2.0], 0.3)\n    True\n    \"\"\""
    },
    "prompt_bertscore": {
      "es": "0.9804283526654893",
      "arb": "0.982049176574734",
      "sw": "0.9822364850240499",
      "tr": "0.97870106287201",
      "vi": "0.9822364850240499"
    },
    "canonical_solution": "    for idx, elem in enumerate(numbers):\n        for idx2, elem2 in enumerate(numbers):\n            if idx != idx2:\n                distance = abs(elem - elem2)\n                if distance < threshold:\n                    return True\n\n    return False",
    "instruction": {
      "en": "def has_close_elements(numbers: List[float], threshold: float) -> bool:\n    for idx, elem in enumerate(numbers):\n        for idx2, elem2 in enumerate(numbers):\n            if idx != idx2:\n                distance = abs(elem - elem2)\n                if distance < threshold:\n                    return True\n\n    return False\n\nProvide a concise natural language description (docstring) of the Python code in English using at most 500 characters.",
      "es": "def has_close_elements(numbers: List[float], threshold: float) -> bool:\n    for idx, elem in enumerate(numbers):\n        for idx2, elem2 in enumerate(numbers):\n            if idx != idx2:\n                distance = abs(elem - elem2)\n                if distance < threshold:\n                    return True\n\n    return False\n\nProporcione una descripción concisa en lenguaje natural (docstring) del código Python en español utilizando un máximo de 500 caracteres.",
      "arb": "def has_close_elements(numbers: List[float], threshold: float) -> bool:\n    for idx, elem in enumerate(numbers):\n        for idx2, elem2 in enumerate(numbers):\n            if idx != idx2:\n                distance = abs(elem - elem2)\n                if distance < threshold:\n                    return True\n\n    return False\n\nقدم وصفًا موجزًا بلغة طبيعية (docstring) للشفرة البرمجية بلغة بايثون باللغة العربية الفصحى باستخدام 500 حرف كحد أقصى.",
      "sw": "def has_close_elements(numbers: List[float], threshold: float) -> bool:\n    for idx, elem in enumerate(numbers):\n        for idx2, elem2 in enumerate(numbers):\n            if idx != idx2:\n                distance = abs(elem - elem2)\n                if distance < threshold:\n                    return True\n\n    return False\n\nToa maelezo mafupi kwa lugha ya asili (docstring) ya msimbo wa Python kwa Kiswahili kwa kutumia herufi zisizozidi 500.",
      "tr": "def has_close_elements(numbers: List[float], threshold: float) -> bool:\n    for idx, elem in enumerate(numbers):\n        for idx2, elem2 in enumerate(numbers):\n            if idx != idx2:\n                distance = abs(elem - elem2)\n                if distance < threshold:\n                    return True\n\n    return False\n\nVerilen Python kodunun işlevini açıklayan, en fazla 500 karakter uzunluğunda, özlü bir doğal dil açıklaması (docstring) sağlayın.",
      "vi": "def has_close_elements(numbers: List[float], threshold: float) -> bool:\n    for idx, elem in enumerate(numbers):\n        for idx2, elem2 in enumerate(numbers):\n            if idx != idx2:\n                distance = abs(elem - elem2)\n                if distance < threshold:\n                    return True\n\n    return False\n\nCung cấp mô tả ngắn gọn bằng ngôn ngữ tự nhiên (docstring) cho mã Python bằng tiếng Việt, sử dụng tối đa 500 ký tự."
    },
    "instruction_bertscore": {
      "es": "0.9687387561112052",
      "arb": "0.9438928762690751",
      "sw": "0.9135101745555976",
      "tr": "0.8508820154152974",
      "vi": "0.9081268939687901"
    },
    "level": "",
    "test": "def check(has_close_elements):\n    assert has_close_elements([1.0, 2.0, 3.9, 4.0, 5.0, 2.2], 0.3) == True\n    assert has_close_elements([1.0, 2.0, 3.9, 4.0, 5.0, 2.2], 0.05) == False\n    assert has_close_elements([1.0, 2.0, 5.9, 4.0, 5.0], 0.95) == True\n    assert has_close_elements([1.0, 2.0, 5.9, 4.0, 5.0], 0.8) == False\n    assert has_close_elements([1.0, 2.0, 3.0, 4.0, 5.0, 2.0], 0.1) == True\n    assert has_close_elements([1.1, 2.2, 3.1, 4.1, 5.1], 1.0) == True\n    assert has_close_elements([1.1, 2.2, 3.1, 4.1, 5.1], 0.5) == False\n \ncheck(has_close_elements)",
    "entry_point": "has_close_elements",
    "signature": "def has_close_elements(numbers: List[float], threshold: float) -> bool:",
    "docstring": {
      "en": "Check if in given list of numbers, are any two numbers closer to each other than\ngiven threshold.\n>>> has_close_elements([1.0, 2.0, 3.0], 0.5)\nFalse\n>>> has_close_elements([1.0, 2.8, 3.0, 4.0, 5.0, 2.0], 0.3)\nTrue",
      "es": "Verifica si en la lista dada de números, hay dos números más cercanos entre sí que el umbral dado.\n>>> has_close_elements([1.0, 2.0, 3.0], 0.5)\nFalse\n>>> has_close_elements([1.0, 2.8, 3.0, 4.0, 5.0, 2.0], 0.3)\nTrue",
      "arb": "التحقق مما إذا كان في قائمة الأرقام المعطاة، يوجد أي رقمين أقرب إلى بعضهما البعض من العتبة المحددة.\n>>> has_close_elements([1.0, 2.0, 3.0], 0.5)\nFalse\n>>> has_close_elements([1.0, 2.8, 3.0, 4.0, 5.0, 2.0], 0.3)\nTrue",
      "sw": "Angalia kama katika orodha iliyotolewa ya nambari, kuna nambari mbili zozote zilizo karibu zaidi kuliko kizingiti kilichotolewa.\n>>> has_close_elements([1.0, 2.0, 3.0], 0.5)\nFalse\n>>> has_close_elements([1.0, 2.8, 3.0, 4.0, 5.0, 2.0], 0.3)\nTrue",
      "tr": "Verilen sayı listesindeki herhangi iki sayının, verilen eşikten daha yakın olup olmadığını kontrol edin.\n>>> has_close_elements([1.0, 2.0, 3.0], 0.5)\nFalse\n>>> has_close_elements([1.0, 2.8, 3.0, 4.0, 5.0, 2.0], 0.3)\nTrue",
      "vi": "Kiểm tra xem trong danh sách các số đã cho, có bất kỳ hai số nào gần nhau hơn ngưỡng đã cho hay không.  \n>>> has_close_elements([1.0, 2.0, 3.0], 0.5)  \nFalse  \n>>> has_close_elements([1.0, 2.8, 3.0, 4.0, 5.0, 2.0], 0.3)  \nTrue  "
    },
    "docstring_bertscore": {
      "es": "0.9730839943267243",
      "arb": "0.9706269365133228",
      "sw": "0.9636691128960517",
      "tr": "0.9587311616235243",
      "vi": "0.9724235483097834"
    }
  },
  {
    "task_id": "Python/2",
    "prompt": {
      "en": "from typing import List\n \n \ndef separate_paren_groups(paren_string: str) -> List[str]:\n    \"\"\" Input to this function is a string containing multiple groups of nested parentheses. Your goal is to\n    separate those group into separate strings and return the list of those.\n    Separate groups are balanced (each open brace is properly closed) and not nested within each other\n    Ignore any spaces in the input string.\n    >>> separate_paren_groups('( ) (( )) (( )( ))')\n    ['()', '(())', '(()())']\n    \"\"\"",
      "es": "from typing import List\n \n \ndef separate_paren_groups(paren_string: str) -> List[str]:\n    \"\"\" La entrada de esta función es una cadena que contiene múltiples grupos de paréntesis anidados. Tu objetivo es\n    separar esos grupos en cadenas separadas y devolver la lista de estas.\n    Los grupos separados están balanceados (cada paréntesis abierto está correctamente cerrado) y no están anidados entre sí.\n    Ignora cualquier espacio en la cadena de entrada.\n    >>> separate_paren_groups('( ) (( )) (( )( ))')\n    ['()', '(())', '(()())']\n    \"\"\"",
      "arb": "from typing import List\n \n \ndef separate_paren_groups(paren_string: str) -> List[str]:\n    \"\"\" الإدخال لهذه الدالة هو سلسلة تحتوي على مجموعات متعددة من الأقواس المتداخلة. هدفك هو\n    فصل تلك المجموعات إلى سلاسل منفصلة وإرجاع قائمة بتلك السلاسل.\n    المجموعات المنفصلة متوازنة (كل قوس مفتوح مغلق بشكل صحيح) وليست متداخلة داخل بعضها البعض\n    تجاهل أي مسافات في سلسلة الإدخال.\n    >>> separate_paren_groups('( ) (( )) (( )( ))')\n    ['()', '(())', '(()())']\n    \"\"\"",
      "sw": "from typing import List\n \n \ndef separate_paren_groups(paren_string: str) -> List[str]:\n    \"\"\" Ingizo kwa kazi hii ni kamba inayo na makundi mengi ya mabano yaliyopachikwa. Lengo lako ni\n    kutenganisha makundi hayo katika kamba tofauti na kurudisha orodha ya hizo.\n    Makundi tofauti yamebalansishwa (kila kufungua brace imefungwa ipasavyo) na hayajapachikwa ndani ya kila mmoja\n    Puuzia nafasi zozote kwenye kamba ya ingizo.\n    >>> separate_paren_groups('( ) (( )) (( )( ))')\n    ['()', '(())', '(()())']\n    \"\"\"",
      "tr": "from typing import List\n \n \ndef separate_paren_groups(paren_string: str) -> List[str]:\n    \"\"\" Bu fonksiyona giriş, birden fazla iç içe parantez grubunu içeren bir dizedir. Amacınız bu grupları\n    ayrı dizelere ayırmak ve bunların listesini döndürmektir.\n    Ayrı gruplar dengelidir (her açık parantez düzgün bir şekilde kapatılmıştır) ve birbirlerinin içinde iç içe değildir.\n    Giriş dizesindeki boşlukları göz ardı edin.\n    >>> separate_paren_groups('( ) (( )) (( )( ))')\n    ['()', '(())', '(()())']\n    \"\"\"",
      "vi": "from typing import List\n \n \ndef separate_paren_groups(paren_string: str) -> List[str]:\n    \"\"\" Đầu vào của hàm này là một chuỗi chứa nhiều nhóm dấu ngoặc đơn lồng nhau. Mục tiêu của bạn là\n    tách những nhóm đó thành các chuỗi riêng biệt và trả về danh sách các chuỗi đó.\n    Các nhóm riêng biệt là cân bằng (mỗi dấu mở đều được đóng đúng cách) và không lồng vào nhau\n    Bỏ qua bất kỳ khoảng trắng nào trong chuỗi đầu vào.\n    >>> separate_paren_groups('( ) (( )) (( )( ))')\n    ['()', '(())', '(()())']\n    \"\"\""
    },
    "prompt_bertscore": {
      "es": "0.9525446197758117",
      "arb": "0.9462692901477765",
      "sw": "0.9502448772241898",
      "tr": "0.9356532908029859",
      "vi": "0.9400773852797759"
    },
    "canonical_solution": "    # Remove spaces from the input string\n    paren_string = paren_string.replace(\" \", \"\")\n    \n    # Initialize variables to store current group and stack to track parentheses\n    current_group = \"\"\n    stack = []\n    result = []\n    \n    # Iterate over each character in the input string\n    for char in paren_string:\n        # If it's an opening parenthesis, push to stack and add to current group\n        if char == \"(\":\n            stack.append(char)\n            current_group += char\n        # If it's a closing parenthesis, pop from stack and add to current group\n        elif char == \")\" and stack:\n            stack.pop()\n            current_group += char\n            # If stack is empty, it means we have a complete group\n            if not stack:\n                result.append(current_group)\n                current_group = \"\"  # Reset current group for the next one\n\n    return result",
    "instruction": {
      "en": "def separate_paren_groups(paren_string: str) -> List[str]:\n    # Remove spaces from the input string\n    paren_string = paren_string.replace(\" \", \"\")\n    \n    # Initialize variables to store current group and stack to track parentheses\n    current_group = \"\"\n    stack = []\n    result = []\n    \n    # Iterate over each character in the input string\n    for char in paren_string:\n        # If it's an opening parenthesis, push to stack and add to current group\n        if char == \"(\":\n            stack.append(char)\n            current_group += char\n        # If it's a closing parenthesis, pop from stack and add to current group\n        elif char == \")\" and stack:\n            stack.pop()\n            current_group += char\n            # If stack is empty, it means we have a complete group\n            if not stack:\n                result.append(current_group)\n                current_group = \"\"  # Reset current group for the next one\n\n    return result\n\nProvide a concise natural language description (docstring) of the Python code in English using at most 500 characters.",
      "es": "def separate_paren_groups(paren_string: str) -> List[str]:\n    # Remove spaces from the input string\n    paren_string = paren_string.replace(\" \", \"\")\n    \n    # Initialize variables to store current group and stack to track parentheses\n    current_group = \"\"\n    stack = []\n    result = []\n    \n    # Iterate over each character in the input string\n    for char in paren_string:\n        # If it's an opening parenthesis, push to stack and add to current group\n        if char == \"(\":\n            stack.append(char)\n            current_group += char\n        # If it's a closing parenthesis, pop from stack and add to current group\n        elif char == \")\" and stack:\n            stack.pop()\n            current_group += char\n            # If stack is empty, it means we have a complete group\n            if not stack:\n                result.append(current_group)\n                current_group = \"\"  # Reset current group for the next one\n\n    return result\n\nProporcione una descripción concisa en lenguaje natural (docstring) del código Python en español utilizando un máximo de 500 caracteres.",
      "arb": "def separate_paren_groups(paren_string: str) -> List[str]:\n    # Remove spaces from the input string\n    paren_string = paren_string.replace(\" \", \"\")\n    \n    # Initialize variables to store current group and stack to track parentheses\n    current_group = \"\"\n    stack = []\n    result = []\n    \n    # Iterate over each character in the input string\n    for char in paren_string:\n        # If it's an opening parenthesis, push to stack and add to current group\n        if char == \"(\":\n            stack.append(char)\n            current_group += char\n        # If it's a closing parenthesis, pop from stack and add to current group\n        elif char == \")\" and stack:\n            stack.pop()\n            current_group += char\n            # If stack is empty, it means we have a complete group\n            if not stack:\n                result.append(current_group)\n                current_group = \"\"  # Reset current group for the next one\n\n    return result\n\nيرجى تقديم وصف موجز بلغة طبيعية (docstring) للكود البرمجي بلغة بايثون باللغة العربية الفصحى، بحيث لا يتجاوز 500 حرف.",
      "sw": "def separate_paren_groups(paren_string: str) -> List[str]:\n    # Remove spaces from the input string\n    paren_string = paren_string.replace(\" \", \"\")\n    \n    # Initialize variables to store current group and stack to track parentheses\n    current_group = \"\"\n    stack = []\n    result = []\n    \n    # Iterate over each character in the input string\n    for char in paren_string:\n        # If it's an opening parenthesis, push to stack and add to current group\n        if char == \"(\":\n            stack.append(char)\n            current_group += char\n        # If it's a closing parenthesis, pop from stack and add to current group\n        elif char == \")\" and stack:\n            stack.pop()\n            current_group += char\n            # If stack is empty, it means we have a complete group\n            if not stack:\n                result.append(current_group)\n                current_group = \"\"  # Reset current group for the next one\n\n    return result\n\nToa maelezo mafupi ya lugha ya asili (docstring) ya msimbo wa Python kwa Kiswahili kwa kutumia herufi zisizozidi 500.",
      "tr": "def separate_paren_groups(paren_string: str) -> List[str]:\n    # Remove spaces from the input string\n    paren_string = paren_string.replace(\" \", \"\")\n    \n    # Initialize variables to store current group and stack to track parentheses\n    current_group = \"\"\n    stack = []\n    result = []\n    \n    # Iterate over each character in the input string\n    for char in paren_string:\n        # If it's an opening parenthesis, push to stack and add to current group\n        if char == \"(\":\n            stack.append(char)\n            current_group += char\n        # If it's a closing parenthesis, pop from stack and add to current group\n        elif char == \")\" and stack:\n            stack.pop()\n            current_group += char\n            # If stack is empty, it means we have a complete group\n            if not stack:\n                result.append(current_group)\n                current_group = \"\"  # Reset current group for the next one\n\n    return result\n\nVerilen Python kodunun işlevini açıklayan, en fazla 500 karakter uzunluğunda, özlü bir doğal dil açıklaması (docstring) sağlayın.",
      "vi": "def separate_paren_groups(paren_string: str) -> List[str]:\n    # Remove spaces from the input string\n    paren_string = paren_string.replace(\" \", \"\")\n    \n    # Initialize variables to store current group and stack to track parentheses\n    current_group = \"\"\n    stack = []\n    result = []\n    \n    # Iterate over each character in the input string\n    for char in paren_string:\n        # If it's an opening parenthesis, push to stack and add to current group\n        if char == \"(\":\n            stack.append(char)\n            current_group += char\n        # If it's a closing parenthesis, pop from stack and add to current group\n        elif char == \")\" and stack:\n            stack.pop()\n            current_group += char\n            # If stack is empty, it means we have a complete group\n            if not stack:\n                result.append(current_group)\n                current_group = \"\"  # Reset current group for the next one\n\n    return result\n\nCung cấp mô tả ngắn gọn bằng ngôn ngữ tự nhiên (docstring) cho mã Python bằng tiếng Việt, không quá 500 ký tự."
    },
    "instruction_bertscore": {
      "es": "0.9687387561112052",
      "arb": "0.906469919330197",
      "sw": "0.914896018724078",
      "tr": "0.8508820154152974",
      "vi": "0.9159938488400579"
    },
    "level": "",
    "test": "def check(separate_paren_groups):\n    assert separate_paren_groups('(()()) ((())) () ((())()())') == [\n    '(()())', '((()))', '()', '((())()())'\n    ]\n    assert separate_paren_groups('() (()) ((())) (((())))') == [\n    '()', '(())', '((()))', '(((())))'\n    ]\n    assert separate_paren_groups('(()(())((())))') == [\n    '(()(())((())))'\n    ]\n    assert separate_paren_groups('( ) (( )) (( )( ))') == ['()', '(())', '(()())']\n \ncheck(separate_paren_groups)",
    "entry_point": "separate_paren_groups",
    "signature": "def separate_paren_groups(paren_string: str) -> List[str]:",
    "docstring": {
      "en": "Input to this function is a string containing multiple groups of nested parentheses. Your goal is to\nseparate those group into separate strings and return the list of those.\nSeparate groups are balanced (each open brace is properly closed) and not nested within each other\nIgnore any spaces in the input string.\n>>> separate_paren_groups('( ) (( )) (( )( ))')\n['()', '(())', '(()())']",
      "es": "La entrada de esta función es una cadena que contiene múltiples grupos de paréntesis anidados. Tu objetivo es separar esos grupos en cadenas separadas y devolver la lista de estos. Los grupos separados están balanceados (cada paréntesis abierto está correctamente cerrado) y no están anidados entre sí. Ignora cualquier espacio en la cadena de entrada.\n>>> separate_paren_groups('( ) (( )) (( )( ))')\n['()', '(())', '(()())']",
      "arb": "مدخل هذه الدالة هو سلسلة تحتوي على مجموعات متعددة من الأقواس المتداخلة. هدفك هو فصل تلك المجموعات إلى سلاسل منفصلة وإرجاع قائمة بتلك السلاسل. المجموعات المنفصلة متوازنة (كل قوس مفتوح مغلق بشكل صحيح) وليست متداخلة داخل بعضها البعض. تجاهل أي مسافات في سلسلة المدخلات.\n>>> separate_paren_groups('( ) (( )) (( )( ))')\n['()', '(())', '(()())']",
      "sw": "Pembejeo kwa kazi hii ni kamba inayojumuisha vikundi vingi vya mabano yaliyopachikwa. Lengo lako ni\nkutenganisha vikundi hivyo kuwa kamba tofauti na kurudisha orodha ya hivyo.\nVikundi vilivyotenganishwa vina uwiano (kila mabano ya kufungua yanafungwa ipasavyo) na havijapachikwa ndani ya kila kimoja\nPuuza nafasi zozote kwenye kamba ya pembejeo.\n>>> separate_paren_groups('( ) (( )) (( )( ))')\n['()', '(())', '(()())']",
      "tr": "Bu fonksiyonun girdisi, birden fazla iç içe geçmiş parantez grubunu içeren bir stringdir. Amacınız, bu grupları ayrı stringlere ayırmak ve bunların listesini döndürmektir.\nAyrı gruplar dengelidir (her açık parantez düzgün bir şekilde kapatılmıştır) ve birbirlerinin içinde iç içe değildir.\nGirdi stringindeki boşlukları yok sayın.\n>>> separate_paren_groups('( ) (( )) (( )( ))')\n['()', '(())', '(()())']",
      "vi": "Đầu vào của hàm này là một chuỗi chứa nhiều nhóm dấu ngoặc đơn lồng nhau. Mục tiêu của bạn là tách các nhóm đó thành các chuỗi riêng biệt và trả về danh sách các chuỗi đó. Các nhóm riêng biệt là cân bằng (mỗi dấu ngoặc mở được đóng đúng cách) và không lồng nhau. Bỏ qua bất kỳ khoảng trắng nào trong chuỗi đầu vào.\n>>> separate_paren_groups('( ) (( )) (( )( ))')\n['()', '(())', '(()())']"
    },
    "docstring_bertscore": {
      "es": "0.9377772454673919",
      "arb": "0.9187210439716669",
      "sw": "0.915265868493565",
      "tr": "0.929437153028499",
      "vi": "0.919473455855027"
    }
  },
  {
    "task_id": "Python/3",
    "prompt": {
      "en": "def truncate_number(number: float) -> float:\n    \"\"\" Given a positive floating point number, it can be decomposed into\n    and integer part (largest integer smaller than given number) and decimals\n    (leftover part always smaller than 1).\n    \n    Return the decimal part of the number.\n    >>> truncate_number(3.5)\n    0.5\n    \"\"\"",
      "es": "def truncate_number(number: float) -> float:\n    \"\"\" Dado un número de punto flotante positivo, puede descomponerse en\n    una parte entera (el entero más grande menor que el número dado) y decimales\n    (parte restante siempre menor que 1).\n    \n    Devuelve la parte decimal del número.\n    >>> truncate_number(3.5)\n    0.5\n    \"\"\"",
      "arb": "def truncate_number(number: float) -> float:\n    \"\"\" بالنظر إلى رقم عشري موجب، يمكن تقسيمه إلى جزء صحيح (أكبر عدد صحيح أصغر من الرقم المعطى) \n    وعشري (الجزء المتبقي الذي يكون دائماً أصغر من 1).\n    \n    إرجاع الجزء العشري من الرقم.\n    >>> truncate_number(3.5)\n    0.5\n    \"\"\"",
      "sw": "def truncate_number(number: float) -> float:\n    \"\"\" Ukipewa namba chanya ya nukta, inaweza kugawanywa katika\n    sehemu ya namba kamili (namba kamili kubwa zaidi ndogo kuliko namba iliyotolewa) na desimali\n    (sehemu iliyobaki ambayo daima ni ndogo kuliko 1).\n    \n    Rudisha sehemu ya desimali ya namba.\n    >>> truncate_number(3.5)\n    0.5\n    \"\"\"",
      "tr": "def truncate_number(number: float) -> float:\n    \"\"\" Pozitif bir kayan nokta sayısı verildiğinde, bu sayı bir\n    tam sayı kısmına (verilen sayıdan küçük en büyük tam sayı) ve ondalık\n    kısma (her zaman 1'den küçük kalan kısım) ayrılabilir.\n    \n    Sayının ondalık kısmını döndür.\n    >>> truncate_number(3.5)\n    0.5\n    \"\"\"",
      "vi": "def truncate_number(number: float) -> float:\n    \"\"\" Cho một số thực dương, nó có thể được phân tách thành\n    phần nguyên (số nguyên lớn nhất nhỏ hơn số đã cho) và phần thập phân\n    (phần còn lại luôn nhỏ hơn 1).\n    \n    Trả về phần thập phân của số.\n    >>> truncate_number(3.5)\n    0.5\n    \"\"\""
    },
    "prompt_bertscore": {
      "es": "0.96295861202309",
      "arb": "0.9156001634248467",
      "sw": "0.9143078741658337",
      "tr": "0.9151337792901768",
      "vi": "0.9166705825482437"
    },
    "canonical_solution": "    return number % 1.0",
    "instruction": {
      "en": "def truncate_number(number: float) -> float:\n    return number % 1.0\n\nProvide a concise natural language description (docstring) of the Python code in English using at most 500 characters.",
      "es": "def truncate_number(number: float) -> float:\n    return number % 1.0\n\nProporcione una descripción concisa en lenguaje natural (docstring) del código Python en español utilizando un máximo de 500 caracteres.",
      "arb": "def truncate_number(number: float) -> float:\n    return number % 1.0\n\nقدم وصفًا موجزًا بلغة طبيعية (docstring) للكود البرمجي بلغة بايثون باللغة العربية الفصحى باستخدام 500 حرف كحد أقصى.",
      "sw": "def truncate_number(number: float) -> float:\n    return number % 1.0\n\nToa maelezo mafupi ya lugha asilia (docstring) ya msimbo wa Python kwa Kiswahili kwa kutumia herufi zisizozidi 500.",
      "tr": "def truncate_number(number: float) -> float:\n    return number % 1.0\n\nVerilen Python kodunun işlevini açıklayan, en fazla 500 karakter uzunluğunda, özlü bir doğal dil tanımı (docstring) sağlayın.",
      "vi": "def truncate_number(number: float) -> float:\n    return number % 1.0\n\nCung cấp mô tả ngắn gọn bằng ngôn ngữ tự nhiên (docstring) cho mã Python bằng tiếng Việt, sử dụng tối đa 500 ký tự."
    },
    "instruction_bertscore": {
      "es": "0.9687387561112052",
      "arb": "0.9226138021791886",
      "sw": "0.9426438884331277",
      "tr": "0.8508820154152974",
      "vi": "0.9403930089552404"
    },
    "level": "",
    "test": "def check(truncate_number):\n    assert truncate_number(3.5) == 0.5\n    assert abs(truncate_number(1.33) - 0.33) < 1e-6\n    assert abs(truncate_number(123.456) - 0.456) < 1e-6\n \ncheck(truncate_number)",
    "entry_point": "truncate_number",
    "signature": "def truncate_number(number: float) -> float:",
    "docstring": {
      "en": "Given a positive floating point number, it can be decomposed into\nand integer part (largest integer smaller than given number) and decimals\n(leftover part always smaller than 1).\n\nReturn the decimal part of the number.\n>>> truncate_number(3.5)\n0.5",
      "es": "Dado un número de punto flotante positivo, se puede descomponer en una parte entera (el entero más grande menor que el número dado) y decimales (la parte restante siempre menor que 1).\n\nDevuelve la parte decimal del número.\n>>> truncate_number(3.5)\n0.5",
      "arb": "بالنظر إلى رقم عشري موجب، يمكن تقسيمه إلى جزء صحيح (أكبر عدد صحيح أصغر من الرقم المعطى) وأجزاء عشرية (الجزء المتبقي دائمًا أصغر من 1).\n\nإرجاع الجزء العشري من الرقم.\n>>> truncate_number(3.5)\n0.5",
      "sw": "Kwa kuzingatia nambari chanya ya nukta ya kuelea, inaweza kugawanywa katika sehemu ya nambari kamili (nambari kamili kubwa zaidi ndogo kuliko nambari iliyotolewa) na desimali (sehemu iliyobaki ambayo kila mara ni ndogo kuliko 1).\n\nRudisha sehemu ya desimali ya nambari.\n>>> truncate_number(3.5)\n0.5",
      "tr": "Verilen pozitif bir kayan noktalı sayı, bir tamsayı kısmına (verilen sayıdan küçük en büyük tamsayı) ve ondalık kısımlara (her zaman 1'den küçük kalan kısım) ayrılabilir.\n\nSayının ondalık kısmını döndürün.\n>>> truncate_number(3.5)\n0.5",
      "vi": "Đưa ra một số thực dương, nó có thể được phân tách thành\nphần nguyên (số nguyên lớn nhất nhỏ hơn số đã cho) và phần thập phân\n(phần còn lại luôn nhỏ hơn 1).\n\nTrả về phần thập phân của số.\n>>> truncate_number(3.5)\n0.5"
    },
    "docstring_bertscore": {
      "es": "0.9550845064581048",
      "arb": "0.9073850094956247",
      "sw": "0.9070866666633104",
      "tr": "0.9212275607499462",
      "vi": "0.8986774508518173"
    }
  },
  {
    "task_id": "Python/4",
    "prompt": {
      "en": "from typing import List\n \n \ndef below_zero(operations: List[int]) -> bool:\n    \"\"\" You're given a list of deposit and withdrawal operations on a bank account that starts with\n    zero balance. Your task is to detect if at any point the balance of account fallls below zero, and\n    at that point function should return True. Otherwise it should return False.\n    >>> below_zero([1, 2, 3])\n    False\n    >>> below_zero([1, 2, -4, 5])\n    True\n    \"\"\"",
      "es": "from typing import List\n \n \ndef below_zero(operations: List[int]) -> bool:\n    \"\"\" Se te da una lista de operaciones de depósito y retiro en una cuenta bancaria que comienza con\n    saldo cero. Tu tarea es detectar si en algún momento el saldo de la cuenta cae por debajo de cero, y\n    en ese momento la función debe devolver True. De lo contrario, debe devolver False.\n    >>> below_zero([1, 2, 3])\n    False\n    >>> below_zero([1, 2, -4, 5])\n    True\n    \"\"\"",
      "arb": "from typing import List\n \n \ndef below_zero(operations: List[int]) -> bool:\n    \"\"\" لديك قائمة من عمليات الإيداع والسحب على حساب بنكي يبدأ برصيد صفر. مهمتك هي اكتشاف ما إذا كان في أي نقطة \n    ينخفض رصيد الحساب إلى ما دون الصفر، وعند هذه النقطة يجب أن تُرجع الدالة True. وإلا يجب أن تُرجع False.\n    >>> below_zero([1, 2, 3])\n    False\n    >>> below_zero([1, 2, -4, 5])\n    True\n    \"\"\"",
      "sw": "from typing import List\n \n \ndef below_zero(operations: List[int]) -> bool:\n    \"\"\" Umepewa orodha ya shughuli za kuweka na kutoa pesa kwenye akaunti ya benki ambayo huanza na\n    salio la sifuri. Kazi yako ni kugundua ikiwa wakati wowote salio la akaunti litashuka chini ya sifuri, na\n    wakati huo kazi inapaswa kurudisha True. Vinginevyo inapaswa kurudisha False.\n    >>> below_zero([1, 2, 3])\n    False\n    >>> below_zero([1, 2, -4, 5])\n    True\n    \"\"\"",
      "tr": "from typing import List\n \n \ndef below_zero(operations: List[int]) -> bool:\n    \"\"\" Sıfır bakiye ile başlayan bir banka hesabı üzerinde yapılan para yatırma ve çekme işlemlerinin\n    bir listesini veriliyor. Göreviniz, hesabın bakiyesinin herhangi bir noktada sıfırın altına düşüp düşmediğini\n    tespit etmektir ve bu durumda fonksiyon True döndürmelidir. Aksi takdirde False döndürmelidir.\n    >>> below_zero([1, 2, 3])\n    False\n    >>> below_zero([1, 2, -4, 5])\n    True\n    \"\"\"",
      "vi": "from typing import List\n \n \ndef below_zero(operations: List[int]) -> bool:\n    \"\"\" Bạn được cung cấp một danh sách các giao dịch nạp và rút tiền trên một tài khoản ngân hàng bắt đầu với\n    số dư bằng không. Nhiệm vụ của bạn là phát hiện xem tại bất kỳ thời điểm nào số dư của tài khoản có giảm xuống dưới không hay không, và\n    tại thời điểm đó hàm nên trả về True. Ngược lại, nó nên trả về False.\n    >>> below_zero([1, 2, 3])\n    False\n    >>> below_zero([1, 2, -4, 5])\n    True\n    \"\"\""
    },
    "prompt_bertscore": {
      "es": "0.9771632664620379",
      "arb": "0.9536897239224779",
      "sw": "0.9636959279974914",
      "tr": "0.9431708548340133",
      "vi": "0.9660083828934996"
    },
    "canonical_solution": "    balance = 0\n \n    for op in operations:\n        balance += op\n    if balance < 0:\n        return True\n \n    return False",
    "instruction": {
      "en": "def below_zero(operations: List[int]) -> bool:\n    balance = 0\n \n    for op in operations:\n        balance += op\n    if balance < 0:\n        return True\n \n    return False\n\nProvide a concise natural language description (docstring) of the Python code in English using at most 500 characters.",
      "es": "def below_zero(operations: List[int]) -> bool:\n    balance = 0\n \n    for op in operations:\n        balance += op\n    if balance < 0:\n        return True\n \n    return False\n\nProporcione una descripción concisa en lenguaje natural (docstring) del código Python en español utilizando un máximo de 500 caracteres.",
      "arb": "def below_zero(operations: List[int]) -> bool:\n    balance = 0\n \n    for op in operations:\n        balance += op\n    if balance < 0:\n        return True\n \n    return False\n\nيرجى تقديم وصف موجز بلغة طبيعية (docstring) للكود البرمجي بلغة بايثون باللغة العربية الفصحى، على ألا يتجاوز 500 حرف.",
      "sw": "def below_zero(operations: List[int]) -> bool:\n    balance = 0\n \n    for op in operations:\n        balance += op\n    if balance < 0:\n        return True\n \n    return False\n\nToa maelezo mafupi ya lugha ya asili (docstring) ya msimbo wa Python kwa Kiswahili kwa kutumia herufi zisizozidi 500.",
      "tr": "def below_zero(operations: List[int]) -> bool:\n    balance = 0\n \n    for op in operations:\n        balance += op\n    if balance < 0:\n        return True\n \n    return False\n\nAşağıdaki Python kodunun Türkçe olarak en fazla 500 karakter kullanarak kısa bir doğal dil açıklamasını (docstring) sağlayın.",
      "vi": "def below_zero(operations: List[int]) -> bool:\n    balance = 0\n \n    for op in operations:\n        balance += op\n    if balance < 0:\n        return True\n \n    return False\n\nCung cấp mô tả ngắn gọn bằng ngôn ngữ tự nhiên (docstring) cho mã Python bằng tiếng Việt, sử dụng tối đa 500 ký tự."
    },
    "instruction_bertscore": {
      "es": "0.9687387561112052",
      "arb": "0.906469919330197",
      "sw": "0.914896018724078",
      "tr": "0.887681471588107",
      "vi": "0.9256256346468206"
    },
    "level": "",
    "test": "def check(below_zero):\n    assert below_zero([]) == False\n    assert below_zero([1, 2, -3, 1, 2, -3]) == False\n    assert below_zero([1, 2, -4, 5, 6]) == False\n    assert below_zero([1, -1, 2, -2, 5, -5, 4, -4]) == False\n    assert below_zero([1, -1, 2, -2, 5, -5, 4, -5]) == True\n    assert below_zero([1, -2, 2, -2, 5, -5, 4, -4]) == True\n \ncheck(below_zero)",
    "entry_point": "below_zero",
    "signature": "def below_zero(operations: List[int]) -> bool:",
    "docstring": {
      "en": "You're given a list of deposit and withdrawal operations on a bank account that starts with\nzero balance. Your task is to detect if at any point the balance of account fallls below zero, and\nat that point function should return True. Otherwise it should return False.\n>>> below_zero([1, 2, 3])\nFalse\n>>> below_zero([1, 2, -4, 5])\nTrue",
      "es": "Se te da una lista de operaciones de depósito y retiro en una cuenta bancaria que comienza con un saldo cero. Tu tarea es detectar si en algún momento el saldo de la cuenta cae por debajo de cero, y en ese momento la función debería devolver True. De lo contrario, debería devolver False.\n>>> below_zero([1, 2, 3])\nFalse\n>>> below_zero([1, 2, -4, 5])\nTrue",
      "arb": "أنت مُعطى قائمة من عمليات الإيداع والسحب على حساب بنكي يبدأ برصيد صفري. مهمتك هي اكتشاف ما إذا كان في أي لحظة ينخفض رصيد الحساب إلى ما دون الصفر، وعند تلك النقطة يجب أن تُرجع الدالة True. وإلا، يجب أن تُرجع False.\n>>> below_zero([1, 2, 3])\nFalse\n>>> below_zero([1, 2, -4, 5])\nTrue",
      "sw": "Umepewa orodha ya shughuli za kuweka na kutoa pesa kwenye akaunti ya benki inayoanza na salio la sifuri. Kazi yako ni kugundua ikiwa wakati wowote salio la akaunti linashuka chini ya sifuri, na wakati huo kazi inapaswa kurudi True. Vinginevyo inapaswa kurudi False.\n>>> below_zero([1, 2, 3])\nFalse\n>>> below_zero([1, 2, -4, 5])\nTrue",
      "tr": "Verilen bir banka hesabı üzerinde sıfır bakiye ile başlayan para yatırma ve çekme işlemlerinin bir listesidir. Göreviniz, herhangi bir noktada hesabın bakiyesinin sıfırın altına düşüp düşmediğini tespit etmektir ve bu noktada fonksiyon True döndürmelidir. Aksi takdirde, False döndürmelidir.\n>>> below_zero([1, 2, 3])\nFalse\n>>> below_zero([1, 2, -4, 5])\nTrue",
      "vi": "Bạn được cung cấp một danh sách các giao dịch nạp và rút tiền trên một tài khoản ngân hàng bắt đầu với số dư bằng không. Nhiệm vụ của bạn là phát hiện xem tại bất kỳ thời điểm nào số dư của tài khoản có rơi xuống dưới không hay không, và tại thời điểm đó hàm nên trả về True. Nếu không, nó nên trả về False.\n>>> below_zero([1, 2, 3])\nFalse\n>>> below_zero([1, 2, -4, 5])\nTrue"
    },
    "docstring_bertscore": {
      "es": "0.972176849376538",
      "arb": "0.9601418345896342",
      "sw": "0.9474336614414031",
      "tr": "0.9273249175565741",
      "vi": "0.9607877805887596"
    }
  },
  {
    "task_id": "Python/5",
    "prompt": {
      "en": "from typing import List\n \ndef mean_absolute_deviation(numbers: List[float]) -> float:\n    \"\"\" For a given list of input numbers, calculate Mean Absolute Deviation\n    around the mean of this dataset.\n    Mean Absolute Deviation is the average absolute difference between each\n    element and a centerpoint (mean in this case):\n    MAD = average | x - x_mean |\n    >>> mean_absolute_deviation([1.0, 2.0, 3.0, 4.0])\n    1.0\n    \"\"\"",
      "es": "from typing import List\n \ndef mean_absolute_deviation(numbers: List[float]) -> float:\n    \"\"\" Para una lista dada de números de entrada, calcular la Desviación Media Absoluta\n    alrededor de la media de este conjunto de datos.\n    La Desviación Media Absoluta es la diferencia absoluta promedio entre cada\n    elemento y un punto central (media en este caso):\n    MAD = promedio | x - x_mean |\n    >>> mean_absolute_deviation([1.0, 2.0, 3.0, 4.0])\n    1.0\n    \"\"\"",
      "arb": "from typing import List\n \ndef mean_absolute_deviation(numbers: List[float]) -> float:\n    \"\"\" لحساب الانحراف المطلق المتوسط لقائمة معينة من الأرقام المدخلة\n    حول متوسط هذه المجموعة من البيانات.\n    الانحراف المطلق المتوسط هو متوسط الفرق المطلق بين كل عنصر ونقطة مركزية\n    (المتوسط في هذه الحالة):\n    MAD = average | x - x_mean |\n    >>> mean_absolute_deviation([1.0, 2.0, 3.0, 4.0])\n    1.0\n    \"\"\"",
      "sw": "from typing import List\n \ndef mean_absolute_deviation(numbers: List[float]) -> float:\n    \"\"\" Kwa orodha iliyotolewa ya namba za ingizo, hesabu Mkengeuko wa Wastani wa \n    Kiasi kuzunguka wastani wa seti hii ya data.\n    Mkengeuko wa Wastani wa Kiasi ni tofauti ya wastani ya kiasi kati ya kila \n    kipengele na kituo (wastani katika kesi hii):\n    MAD = wastani | x - x_mean |\n    >>> mean_absolute_deviation([1.0, 2.0, 3.0, 4.0])\n    1.0\n    \"\"\"",
      "tr": "from typing import List\n \ndef mean_absolute_deviation(numbers: List[float]) -> float:\n    \"\"\" Verilen bir sayı listesi için, bu veri kümesinin ortalaması etrafında\n    Ortalama Mutlak Sapma'yı hesaplayın.\n    Ortalama Mutlak Sapma, her bir eleman ile bir merkez noktası (bu durumda ortalama)\n    arasındaki ortalama mutlak farktır:\n    MAD = average | x - x_mean |\n    >>> mean_absolute_deviation([1.0, 2.0, 3.0, 4.0])\n    1.0\n    \"\"\"",
      "vi": "from typing import List\n \ndef mean_absolute_deviation(numbers: List[float]) -> float:\n    \"\"\" Đối với một danh sách các số đầu vào, tính Độ lệch tuyệt đối trung bình\n    xung quanh giá trị trung bình của tập dữ liệu này.\n    Độ lệch tuyệt đối trung bình là trung bình của sự khác biệt tuyệt đối giữa mỗi\n    phần tử và một điểm trung tâm (trong trường hợp này là giá trị trung bình):\n    MAD = trung bình | x - x_mean |\n    >>> mean_absolute_deviation([1.0, 2.0, 3.0, 4.0])\n    1.0\n    \"\"\""
    },
    "prompt_bertscore": {
      "es": "0.9853301532086683",
      "arb": "0.9441870478633878",
      "sw": "0.9755678672415656",
      "tr": "0.9479383812396127",
      "vi": "0.9462428723070989"
    },
    "canonical_solution": "    mean = sum(numbers) / len(numbers)\n    return sum(abs(x - mean) for x in numbers) / len(numbers)",
    "instruction": {
      "en": "def mean_absolute_deviation(numbers: List[float]) -> float:\n    mean = sum(numbers) / len(numbers)\n    return sum(abs(x - mean) for x in numbers) / len(numbers)\n\nProvide a concise natural language description (docstring) of the Python code in English using at most 500 characters.",
      "es": "def mean_absolute_deviation(numbers: List[float]) -> float:\n    mean = sum(numbers) / len(numbers)\n    return sum(abs(x - mean) for x in numbers) / len(numbers)\n\nProporcione una descripción concisa en lenguaje natural (docstring) del código Python en español utilizando un máximo de 500 caracteres.",
      "arb": "def mean_absolute_deviation(numbers: List[float]) -> float:\n    mean = sum(numbers) / len(numbers)\n    return sum(abs(x - mean) for x in numbers) / len(numbers)\n\nيرجى تقديم وصف موجز بلغة طبيعية (docstring) للشفرة البرمجية بلغة بايثون باللغة العربية الفصحى، بحيث لا يتجاوز 500 حرف.",
      "sw": "def mean_absolute_deviation(numbers: List[float]) -> float:\n    mean = sum(numbers) / len(numbers)\n    return sum(abs(x - mean) for x in numbers) / len(numbers)\n\nToa maelezo mafupi ya lugha ya asili (docstring) ya msimbo wa Python kwa Kiswahili kwa kutumia herufi zisizozidi 500.",
      "tr": "def mean_absolute_deviation(numbers: List[float]) -> float:\n    mean = sum(numbers) / len(numbers)\n    return sum(abs(x - mean) for x in numbers) / len(numbers)\n\nVerilen Python kodunun işlevini açıklayan, en fazla 500 karakter uzunluğunda, özlü bir doğal dil açıklaması (docstring) sağlayın.",
      "vi": "def mean_absolute_deviation(numbers: List[float]) -> float:\n    mean = sum(numbers) / len(numbers)\n    return sum(abs(x - mean) for x in numbers) / len(numbers)\n\nCung cấp mô tả ngắn gọn bằng ngôn ngữ tự nhiên (docstring) cho mã Python bằng tiếng Việt, sử dụng tối đa 500 ký tự."
    },
    "instruction_bertscore": {
      "es": "0.9687387561112052",
      "arb": "0.906469919330197",
      "sw": "0.914896018724078",
      "tr": "0.8444541376546273",
      "vi": "0.9403930089552404"
    },
    "level": "",
    "test": "def check(mean_absolute_deviation):\n    assert abs(mean_absolute_deviation([1.0, 2.0, 3.0]) - 2.0/3.0) < 1e-6\n    assert abs(mean_absolute_deviation([1.0, 2.0, 3.0, 4.0]) - 1.0) < 1e-6\n    assert abs(mean_absolute_deviation([1.0, 2.0, 3.0, 4.0, 5.0]) - 6.0/5.0) < 1e-6\n    \ncheck(mean_absolute_deviation)",
    "entry_point": "mean_absolute_deviation",
    "signature": "def mean_absolute_deviation(numbers: List[float]) -> float:",
    "docstring": {
      "en": "For a given list of input numbers, calculate Mean Absolute Deviation\naround the mean of this dataset.\nMean Absolute Deviation is the average absolute difference between each\nelement and a centerpoint (mean in this case):\nMAD = average | x - x_mean |\n>>> mean_absolute_deviation([1.0, 2.0, 3.0, 4.0])\n1.0",
      "es": "Para una lista dada de números de entrada, calcular la Desviación Absoluta Media alrededor de la media de este conjunto de datos.  \nLa Desviación Absoluta Media es la diferencia absoluta promedio entre cada elemento y un punto central (la media en este caso):  \nMAD = promedio | x - x_mean |  \n>>> mean_absolute_deviation([1.0, 2.0, 3.0, 4.0])  \n1.0",
      "arb": "لحساب الانحراف المطلق المتوسط لقائمة معينة من الأرقام المدخلة حول متوسط هذه المجموعة من البيانات.  \nالانحراف المطلق المتوسط هو متوسط الفرق المطلق بين كل عنصر ونقطة مركزية (المتوسط في هذه الحالة):  \nMAD = المتوسط | x - x_mean |  \n>>> mean_absolute_deviation([1.0, 2.0, 3.0, 4.0])  \n1.0",
      "sw": "Kwa orodha iliyotolewa ya nambari za pembejeo, hesabu Mkengeuko Wastani wa Kawaida\nkuhusu wastani wa seti hii ya data.\nMkengeuko Wastani wa Kawaida ni tofauti ya wastani ya kawaida kati ya kila\nkipengele na kituo (wastani katika kesi hii):\nMAD = wastani | x - x_mean |\n>>> mean_absolute_deviation([1.0, 2.0, 3.0, 4.0])\n1.0",
      "tr": "Verilen bir sayı listesi için, bu veri kümesinin ortalaması etrafında Ortalama Mutlak Sapma'yı hesaplayın.  \nOrtalama Mutlak Sapma, her bir eleman ile bir merkez noktası (bu durumda ortalama) arasındaki ortalama mutlak farktır:  \nMAD = ortalama | x - x_mean |  \n>>> mean_absolute_deviation([1.0, 2.0, 3.0, 4.0])  \n1.0  ",
      "vi": "Đối với một danh sách các số đầu vào đã cho, tính Độ lệch tuyệt đối trung bình xung quanh giá trị trung bình của tập dữ liệu này.  \nĐộ lệch tuyệt đối trung bình là trung bình của sự khác biệt tuyệt đối giữa mỗi phần tử và một điểm trung tâm (trong trường hợp này là trung bình):  \nMAD = trung bình | x - x_mean |  \n>>> mean_absolute_deviation([1.0, 2.0, 3.0, 4.0])  \n1.0"
    },
    "docstring_bertscore": {
      "es": "0.9659033074219321",
      "arb": "0.9191536609415608",
      "sw": "0.955961658220755",
      "tr": "0.9435166703273951",
      "vi": "0.9520835986614298"
    }
  },
  {
    "task_id": "Python/6",
    "prompt": {
      "en": "def add(a: int, b: int) -> int:\n    \"\"\"\n    Adds two integer numbers together.\n\n    Parameters:\n    a (int): The first number to be added.\n    b (int): The second number to be added.\n\n    Returns:\n    int: The sum of the two numbers.\n    \"\"\"",
      "es": "def add(a: int, b: int) -> int:\n    \"\"\"\n    Suma dos números enteros.\n\n    Parámetros:\n    a (int): El primer número a sumar.\n    b (int): El segundo número a sumar.\n\n    Devuelve:\n    int: La suma de los dos números.\n    \"\"\"",
      "arb": "def add(a: int, b: int) -> int:\n    \"\"\"\n    يجمع عددين صحيحين معًا.\n\n    المعاملات:\n    a (int): الرقم الأول الذي سيتم إضافته.\n    b (int): الرقم الثاني الذي سيتم إضافته.\n\n    يعيد:\n    int: مجموع الرقمين.\n    \"\"\"",
      "sw": "def add(a: int, b: int) -> int:\n    \"\"\"\n    Huongeza namba mbili za mzima pamoja.\n\n    Vigezo:\n    a (int): Namba ya kwanza ya kuongezwa.\n    b (int): Namba ya pili ya kuongezwa.\n\n    Inarejesha:\n    int: Jumla ya namba hizo mbili.\n    \"\"\"",
      "tr": "def add(a: int, b: int) -> int:\n    \"\"\"\n    İki tam sayıyı toplar.\n\n    Parametreler:\n    a (int): Toplanacak ilk sayı.\n    b (int): Toplanacak ikinci sayı.\n\n    Döndürür:\n    int: İki sayının toplamı.\n    \"\"\"",
      "vi": "def add(a: int, b: int) -> int:\n    \"\"\"\n    Cộng hai số nguyên lại với nhau.\n\n    Tham số:\n    a (int): Số thứ nhất để cộng.\n    b (int): Số thứ hai để cộng.\n\n    Trả về:\n    int: Tổng của hai số.\n    \"\"\""
    },
    "prompt_bertscore": {
      "es": "0.9671620281465502",
      "arb": "0.9878525604174304",
      "sw": "0.9875730874713143",
      "tr": "0.9827362390627338",
      "vi": "0.9729272749560879"
    },
    "canonical_solution": "    return a + b",
    "instruction": {
      "en": "def add(a: int, b: int) -> int:\n    return a + b\n\nProvide a concise natural language description (docstring) of the Python code in English using at most 500 characters.",
      "es": "def add(a: int, b: int) -> int:\n    return a + b\n\nProporciona una descripción concisa en lenguaje natural (docstring) del código Python en español usando como máximo 500 caracteres.",
      "arb": "def add(a: int, b: int) -> int:\n    return a + b\n\nيرجى تقديم وصف موجز بلغة طبيعية (docstring) للكود البرمجي بلغة بايثون باللغة العربية الفصحى باستخدام 500 حرف كحد أقصى.",
      "sw": "def add(a: int, b: int) -> int:\n    return a + b\n\nToa maelezo mafupi ya lugha ya asili (docstring) ya msimbo wa Python kwa Kiswahili kwa kutumia herufi zisizozidi 500.",
      "tr": "def add(a: int, b: int) -> int:\n    return a + b\n\nVerilen Python kodunun işlevini açıklayan, en fazla 500 karakter uzunluğunda özlü bir doğal dil açıklaması (docstring) sağlayın.",
      "vi": "def add(a: int, b: int) -> int:\n    return a + b\n\nCung cấp mô tả ngắn gọn bằng ngôn ngữ tự nhiên (docstring) cho mã Python bằng tiếng Việt với tối đa 500 ký tự."
    },
    "instruction_bertscore": {
      "es": "0.9687387561112052",
      "arb": "0.924699818440817",
      "sw": "0.914896018724078",
      "tr": "0.8508820154152974",
      "vi": "0.9016493586128613"
    },
    "level": "",
    "test": "# Test cases:\n# The following lines are not part of the function's implementation but are provided\n# for testing purposes.\n\n# Test case 1: Positive integers\nassert add(2, 3) == 5\n\n# Test case 2: A positive and a negative integer\nassert add(-1, 1) == 0\n\n# Test case 3: Two negative integers\nassert add(-4, -5) == -9\n\n# Test case 4: Zeroes\nassert add(0, 0) == 0\n\n# Test case 5: Large integers\nassert add(123456, 654321) == 777777\n\nprint(\"All test cases passed.\")",
    "entry_point": "add",
    "signature": "def add(a: int, b: int) -> int:",
    "docstring": {
      "en": "Adds two integer numbers together.\n\nParameters:\na (int): The first number to be added.\nb (int): The second number to be added.\n\nReturns:\nint: The sum of the two numbers.",
      "es": "Añade dos números enteros juntos.\n\nParámetros:\na (int): El primer número a sumar.\nb (int): El segundo número a sumar.\n\nDevuelve:\nint: La suma de los dos números.",
      "arb": "يجمع عددين صحيحين معًا.\n\nالمعلمات:\na (int): الرقم الأول الذي سيتم إضافته.\nb (int): الرقم الثاني الذي سيتم إضافته.\n\nالقيم المعادة:\nint: مجموع الرقمين.",
      "sw": "Huongeza namba mbili za mzima pamoja.\n\nVigezo:\na (int): Namba ya kwanza ya kuongezwa.\nb (int): Namba ya pili ya kuongezwa.\n\nInarejesha:\nint: Jumla ya namba hizo mbili.",
      "tr": "İki tam sayıyı toplar.\n\nParametreler:\na (int): Toplanacak ilk sayı.\nb (int): Toplanacak ikinci sayı.\n\nDöndürülenler:\nint: İki sayının toplamı.",
      "vi": "Cộng hai số nguyên với nhau.\n\nTham số:\na (int): Số thứ nhất cần cộng.\nb (int): Số thứ hai cần cộng.\n\nTrả về:\nint: Tổng của hai số."
    },
    "docstring_bertscore": {
      "es": "0.9584626133483652",
      "arb": "0.9933260191972277",
      "sw": "0.9933260191972277",
      "tr": "0.9807264968674227",
      "vi": "0.9584626133483652"
    }
  },
  {
    "task_id": "Python/7",
    "prompt": {
      "en": "def find_topmost_carpet(n, carpets, point) -> int:\n    \"\"\"\n    Finds the topmost carpet covering a given point on the coordinate plane.\n\n    Args:\n    n (int): The total number of carpets.\n    carpets (list of tuples): A list containing n tuples, each representing a carpet's information.\n                              Each tuple contains four integers (a, b, g, k) where (a, b) is the\n                              coordinates of the bottom-left corner of the carpet and (g, k) are\n                              the lengths of the carpet along the x and y axis respectively.\n    point (tuple): A tuple containing two integers (x, y), the coordinates of the point to check.\n\n    Returns:\n    int: The number of the topmost carpet covering the point (x, y), or -1 if no carpet covers it.\n\n    Examples:\n    >>> find_topmost_carpet(3, [(1, 0, 2, 3), (0, 2, 3, 3), (2, 1, 3, 3)], (2, 2))\n    3\n    >>> find_topmost_carpet(3, [(1, 0, 2, 3), (0, 2, 3, 3), (2, 1, 3, 3)], (4, 5))\n    -1\n    \"\"\"",
      "es": "def find_topmost_carpet(n, carpets, point) -> int:\n    \"\"\"\n    Encuentra la alfombra más alta que cubre un punto dado en el plano de coordenadas.\n\n    Argümanlar:\n    n (int): El número total de alfombras.\n    carpets (list of tuples): Una lista que contiene n tuplas, cada una representando la información de una alfombra.\n                              Cada tupla contiene cuatro enteros (a, b, g, k) donde (a, b) son las\n                              coordenadas de la esquina inferior izquierda de la alfombra y (g, k) son\n                              las longitudes de la alfombra a lo largo del eje x y y respectivamente.\n    point (tuple): Una tupla que contiene dos enteros (x, y), las coordenadas del punto a verificar.\n\n    Devuelve:\n    int: El número de la alfombra más alta que cubre el punto (x, y), o -1 si ninguna alfombra lo cubre.\n\n    Ejemplos:\n    >>> find_topmost_carpet(3, [(1, 0, 2, 3), (0, 2, 3, 3), (2, 1, 3, 3)], (2, 2))\n    3\n    >>> find_topmost_carpet(3, [(1, 0, 2, 3), (0, 2, 3, 3), (2, 1, 3, 3)], (4, 5))\n    -1\n    \"\"\"",
      "arb": "def find_topmost_carpet(n, carpets, point) -> int:\n    \"\"\"\n    يجد السجادة العلوية التي تغطي نقطة معينة على مستوى الإحداثيات.\n\n    يعيدالحجج:\n    n (int): العدد الإجمالي للسجاد.\n    carpets (list of tuples): قائمة تحتوي على n من الأزواج، كل منها يمثل معلومات السجادة.\n                              يحتوي كل زوج على أربعة أعداد صحيحة (a, b, g, k) حيث (a, b) هي\n                              إحداثيات الزاوية السفلية اليسرى للسجادة و (g, k) هي\n                              أطوال السجادة على المحور السيني والصادي على التوالي.\n    point (tuple): زوج يحتوي على عددين صحيحين (x, y)، إحداثيات النقطة المراد التحقق منها.\n\n    يعيد:\n    int: رقم السجادة العلوية التي تغطي النقطة (x, y)، أو -1 إذا لم تغطيها أي سجادة.\n\n    امثله:\n    >>> find_topmost_carpet(3, [(1, 0, 2, 3), (0, 2, 3, 3), (2, 1, 3, 3)], (2, 2))\n    3\n    >>> find_topmost_carpet(3, [(1, 0, 2, 3), (0, 2, 3, 3), (2, 1, 3, 3)], (4, 5))\n    -1\n    \"\"\"",
      "sw": "def find_topmost_carpet(n, carpets, point) -> int:\n    \"\"\"\n    Inapata zulia la juu zaidi linalofunika nukta fulani kwenye ndege ya kuratibu.\n\n    Hoja:\n    n (int): Jumla ya idadi ya mazulia.\n    carpets (list of tuples): Orodha inayojumuisha n tuples, kila moja ikiwakilisha taarifa ya zulia.\n                              Kila tuple ina integer nne (a, b, g, k) ambapo (a, b) ni\n                              kuratibu za kona ya chini-kushoto ya zulia na (g, k) ni\n                              urefu wa zulia kando ya mhimili wa x na y mtawalia.\n    point (tuple): Tuple inayojumuisha integer mbili (x, y), kuratibu za nukta ya kukagua.\n\n    Inarejesha:\n    int: Nambari ya zulia la juu zaidi linalofunika nukta (x, y), au -1 ikiwa hakuna zulia linaloifunika.\n\n    Mifano:\n    >>> find_topmost_carpet(3, [(1, 0, 2, 3), (0, 2, 3, 3), (2, 1, 3, 3)], (2, 2))\n    3\n    >>> find_topmost_carpet(3, [(1, 0, 2, 3), (0, 2, 3, 3), (2, 1, 3, 3)], (4, 5))\n    -1\n    \"\"\"",
      "tr": "def find_topmost_carpet(n, carpets, point) -> int:\n    \"\"\"\n    Koordinat düzleminde verilen bir noktayı kaplayan en üstteki halıyı bulur.\n\n    Argümanlar:\n    n (int): Toplam halı sayısı.\n    carpets (list of tuples): Her biri bir halının bilgisini temsil eden n adet demet içeren bir liste.\n                              Her demet dört tamsayı (a, b, g, k) içerir, burada (a, b) halının\n                              sol alt köşesinin koordinatlarıdır ve (g, k) halının x ve y ekseni\n                              boyunca olan uzunluklarıdır.\n    point (tuple): Kontrol edilecek noktanın koordinatlarını içeren iki tamsayıdan oluşan bir demet (x, y).\n\n    Döndürür:\n    int: Nokta (x, y) üzerindeki en üstteki halının numarası veya hiçbir halı kaplamıyorsa -1.\n\n    Örnekler:\n    >>> find_topmost_carpet(3, [(1, 0, 2, 3), (0, 2, 3, 3), (2, 1, 3, 3)], (2, 2))\n    3\n    >>> find_topmost_carpet(3, [(1, 0, 2, 3), (0, 2, 3, 3), (2, 1, 3, 3)], (4, 5))\n    -1\n    \"\"\"",
      "vi": "def find_topmost_carpet(n, carpets, point) -> int:\n    \"\"\"\n    Tìm tấm thảm trên cùng phủ lên một điểm cho trước trên mặt phẳng tọa độ.\n\n    Tham số:\n    n (int): Tổng số lượng thảm.\n    carpets (list of tuples): Một danh sách chứa n bộ giá trị, mỗi bộ đại diện cho thông tin của một tấm thảm.\n                              Mỗi bộ chứa bốn số nguyên (a, b, g, k) trong đó (a, b) là tọa độ của góc dưới bên trái\n                              của tấm thảm và (g, k) là chiều dài của tấm thảm theo trục x và y tương ứng.\n    point (tuple): Một bộ chứa hai số nguyên (x, y), tọa độ của điểm cần kiểm tra.\n\n    Trả về:\n    int: Số của tấm thảm trên cùng phủ lên điểm (x, y), hoặc -1 nếu không có tấm thảm nào phủ lên.\n\n    Ví dụ:\n    >>> find_topmost_carpet(3, [(1, 0, 2, 3), (0, 2, 3, 3), (2, 1, 3, 3)], (2, 2))\n    3\n    >>> find_topmost_carpet(3, [(1, 0, 2, 3), (0, 2, 3, 3), (2, 1, 3, 3)], (4, 5))\n    -1\n    \"\"\""
    },
    "prompt_bertscore": {
      "es": "0.9861937981054081",
      "arb": "0.9786827888769548",
      "sw": "0.9816513199215212",
      "tr": "0.977636404029663",
      "vi": "0.9794586391452771"
    },
    "canonical_solution": "    x, y = point\n    # Iterate through the carpets in reverse order, since the last one is on top\n    for i in range(n - 1, -1, -1):\n        a, b, g, k = carpets[i]\n        # Check if the point is within the carpet's boundaries\n        if a <= x <= a + g and b <= y <= b + k:\n            return i + 1  # Carpet numbers are 1-indexed\n    return -1  # If no carpet covers the point",
    "instruction": {
      "en": "def find_topmost_carpet(n, carpets, point) -> int:\n    x, y = point\n    # Iterate through the carpets in reverse order, since the last one is on top\n    for i in range(n - 1, -1, -1):\n        a, b, g, k = carpets[i]\n        # Check if the point is within the carpet's boundaries\n        if a <= x <= a + g and b <= y <= b + k:\n            return i + 1  # Carpet numbers are 1-indexed\n    return -1  # If no carpet covers the point\n\nProvide a concise natural language description (docstring) of the Python code in English using at most 500 characters.",
      "es": "def find_topmost_carpet(n, carpets, point) -> int:\n    x, y = point\n    # Iterate through the carpets in reverse order, since the last one is on top\n    for i in range(n - 1, -1, -1):\n        a, b, g, k = carpets[i]\n        # Check if the point is within the carpet's boundaries\n        if a <= x <= a + g and b <= y <= b + k:\n            return i + 1  # Carpet numbers are 1-indexed\n    return -1  # If no carpet covers the point\n\nProporcione una descripción concisa en lenguaje natural (docstring) del código Python en español utilizando un máximo de 500 caracteres.",
      "arb": "def find_topmost_carpet(n, carpets, point) -> int:\n    x, y = point\n    # Iterate through the carpets in reverse order, since the last one is on top\n    for i in range(n - 1, -1, -1):\n        a, b, g, k = carpets[i]\n        # Check if the point is within the carpet's boundaries\n        if a <= x <= a + g and b <= y <= b + k:\n            return i + 1  # Carpet numbers are 1-indexed\n    return -1  # If no carpet covers the point\n\nيرجى تقديم وصف موجز بلغة طبيعية (docstring) للكود البرمجي بلغة بايثون باللغة العربية الفصحى باستخدام 500 حرف كحد أقصى.",
      "sw": "def find_topmost_carpet(n, carpets, point) -> int:\n    x, y = point\n    # Iterate through the carpets in reverse order, since the last one is on top\n    for i in range(n - 1, -1, -1):\n        a, b, g, k = carpets[i]\n        # Check if the point is within the carpet's boundaries\n        if a <= x <= a + g and b <= y <= b + k:\n            return i + 1  # Carpet numbers are 1-indexed\n    return -1  # If no carpet covers the point\n\nToa maelezo mafupi ya lugha asilia (docstring) ya msimbo wa Python kwa Kiswahili kwa kutumia herufi zisizozidi 500.",
      "tr": "def find_topmost_carpet(n, carpets, point) -> int:\n    x, y = point\n    # Iterate through the carpets in reverse order, since the last one is on top\n    for i in range(n - 1, -1, -1):\n        a, b, g, k = carpets[i]\n        # Check if the point is within the carpet's boundaries\n        if a <= x <= a + g and b <= y <= b + k:\n            return i + 1  # Carpet numbers are 1-indexed\n    return -1  # If no carpet covers the point\n\nPython kodunun işlevini açıklayan kısa bir doğal dil açıklaması (docstring) sağlayın. Açıklama en fazla 500 karakter olmalıdır.",
      "vi": "def find_topmost_carpet(n, carpets, point) -> int:\n    x, y = point\n    # Iterate through the carpets in reverse order, since the last one is on top\n    for i in range(n - 1, -1, -1):\n        a, b, g, k = carpets[i]\n        # Check if the point is within the carpet's boundaries\n        if a <= x <= a + g and b <= y <= b + k:\n            return i + 1  # Carpet numbers are 1-indexed\n    return -1  # If no carpet covers the point\n\nCung cấp mô tả ngắn gọn bằng ngôn ngữ tự nhiên (docstring) cho mã Python bằng tiếng Việt, sử dụng tối đa 500 ký tự."
    },
    "instruction_bertscore": {
      "es": "0.9687387561112052",
      "arb": "0.924699818440817",
      "sw": "0.9426438884331277",
      "tr": "0.8386318839257327",
      "vi": "0.9256256346468206"
    },
    "level": "",
    "test": "def check_find_topmost_carpet():\n    # Test case 1: Point is on topmost carpet (carpet 3)\n    assert find_topmost_carpet(3, [(1, 0, 2, 3), (0, 2, 3, 3), (2, 1, 3, 3)], (2, 2)) == 3\n\n    # Test case 2: Point is not covered by any carpet\n    assert find_topmost_carpet(3, [(1, 0, 2, 3), (0, 2, 3, 3), (2, 1, 3, 3)], (4, 5)) == -1\n\n    # Test case 3: Point is on the edge of the carpet (carpet 1)\n    assert find_topmost_carpet(2, [(1, 1, 3, 3), (4, 4, 2, 2)], (4, 1)) == 1\n\n    # Test case 4: Point is at the corner of the carpet (carpet 2)\n    assert find_topmost_carpet(2, [(1, 1, 3, 3), (4, 4, 2, 2)], (6, 4)) == 2\n\n    # Test case 5: Multiple carpets cover the point, but the last one is on top (carpet 4)\n    assert find_topmost_carpet(4, [(0, 0, 5, 5), (1, 1, 5, 5), (2, 2, 5, 5), (3, 3, 5, 5)], (4, 4)) == 4\n\n    # Test case 6: No carpets at all, should return -1\n    assert find_topmost_carpet(0, [], (0, 0)) == -1\n\n    # Test case 8: Point is covered by the first carpet and no others (carpet 1)\n    assert find_topmost_carpet(3, [(0, 0, 2, 2), (2, 2, 2, 2), (4, 4, 2, 2)], (1, 1)) == 1\n\n    print(\"All test cases passed!\")\n\n\n# Run the test cases to ensure the function works as expected\ncheck_find_topmost_carpet()",
    "entry_point": "find_topmost_carpet",
    "signature": "def find_topmost_carpet(n, carpets, point) -> int:",
    "docstring": {
      "en": "Finds the topmost carpet covering a given point on the coordinate plane.\n\nArgs:\nn (int): The total number of carpets.\ncarpets (list of tuples): A list containing n tuples, each representing a carpet's information.\nEach tuple contains four integers (a, b, g, k) where (a, b) is the\ncoordinates of the bottom-left corner of the carpet and (g, k) are\nthe lengths of the carpet along the x and y axis respectively.\npoint (tuple): A tuple containing two integers (x, y), the coordinates of the point to check.\n\nReturns:\nint: The number of the topmost carpet covering the point (x, y), or -1 if no carpet covers it.\n\nExamples:\n>>> find_topmost_carpet(3, [(1, 0, 2, 3), (0, 2, 3, 3), (2, 1, 3, 3)], (2, 2))\n3\n>>> find_topmost_carpet(3, [(1, 0, 2, 3), (0, 2, 3, 3), (2, 1, 3, 3)], (4, 5))\n-1",
      "es": "Encuentra la alfombra más superior que cubre un punto dado en el plano de coordenadas.\n\nArgumentos:\nn (int): El número total de alfombras.\ncarpets (list of tuples): Una lista que contiene n tuplas, cada una representando la información de una alfombra.\nCada tupla contiene cuatro enteros (a, b, g, k) donde (a, b) son las\ncoordenadas de la esquina inferior izquierda de la alfombra y (g, k) son\nlas longitudes de la alfombra a lo largo del eje x y y respectivamente.\npoint (tuple): Una tupla que contiene dos enteros (x, y), las coordenadas del punto a verificar.\n\nDevuelve:\nint: El número de la alfombra más superior que cubre el punto (x, y), o -1 si ninguna alfombra lo cubre.\n\nEjemplos:\n>>> find_topmost_carpet(3, [(1, 0, 2, 3), (0, 2, 3, 3), (2, 1, 3, 3)], (2, 2))\n3\n>>> find_topmost_carpet(3, [(1, 0, 2, 3), (0, 2, 3, 3), (2, 1, 3, 3)], (4, 5))\n-1",
      "arb": "يجد السجادة العليا التي تغطي نقطة معينة على مستوى الإحداثيات.\n\nالمعطيات:\nn (int): العدد الإجمالي للسجاد.\ncarpets (list of tuples): قائمة تحتوي على n من الأزواج المرتبة، كل منها يمثل معلومات عن سجادة.\nكل زوج يحتوي على أربعة أعداد صحيحة (a, b, g, k) حيث (a, b) هي\nإحداثيات الزاوية السفلى اليسرى للسجادة و(g, k) هي\nأطوال السجادة على طول محور x و y على التوالي.\npoint (tuple): زوج مرتب يحتوي على عددين صحيحين (x, y)، إحداثيات النقطة المراد التحقق منها.\n\nالقيم المعادة:\nint: رقم السجادة العليا التي تغطي النقطة (x, y)، أو -1 إذا لم تغطيها أي سجادة.\n\nأمثلة:\n>>> find_topmost_carpet(3, [(1, 0, 2, 3), (0, 2, 3, 3), (2, 1, 3, 3)], (2, 2))\n3\n>>> find_topmost_carpet(3, [(1, 0, 2, 3), (0, 2, 3, 3), (2, 1, 3, 3)], (4, 5))\n-1",
      "sw": "Inapata zulia la juu zaidi linalofunika nukta fulani kwenye ndege ya kuratibu.\n\nHoja:\nn (int): Jumla ya idadi ya mazulia.\ncarpets (orodha ya jozi): Orodha inayo na jozi n, kila moja ikiwakilisha taarifa ya zulia.\nKila jozi ina namba nne za mzima (a, b, g, k) ambapo (a, b) ni\nkuratibu za kona ya chini-kushoto ya zulia na (g, k) ni\nurefu wa zulia kando ya mhimili x na y mtawalia.\npoint (jozi): Jozi inayo na namba mbili za mzima (x, y), kuratibu za nukta ya kukagua.\n\nInarejesha:\nint: Nambari ya zulia la juu zaidi linalofunika nukta (x, y), au -1 ikiwa hakuna zulia linalofunika.\n\nMifano:\n>>> find_topmost_carpet(3, [(1, 0, 2, 3), (0, 2, 3, 3), (2, 1, 3, 3)], (2, 2))\n3\n>>> find_topmost_carpet(3, [(1, 0, 2, 3), (0, 2, 3, 3), (2, 1, 3, 3)], (4, 5))\n-1",
      "tr": "Verilen bir noktayı koordinat düzleminde örten en üstteki halıyı bulur.\n\nArgümanlar:\nn (int): Toplam halı sayısı.\ncarpets (list of tuples): Her biri bir halının bilgilerini temsil eden n adet demet içeren bir liste.\nHer demet dört tamsayı (a, b, g, k) içerir, burada (a, b)\nhalının sol alt köşesinin koordinatlarıdır ve (g, k)\nhalının x ve y eksenleri boyunca olan uzunluklarıdır.\npoint (tuple): İki tamsayı (x, y) içeren bir demet, kontrol edilecek noktanın koordinatları.\n\nDöndürür:\nint: Nokta (x, y)'yi örten en üstteki halının numarası veya hiçbir halı örtmüyorsa -1.\n\nÖrnekler:\n>>> find_topmost_carpet(3, [(1, 0, 2, 3), (0, 2, 3, 3), (2, 1, 3, 3)], (2, 2))\n3\n>>> find_topmost_carpet(3, [(1, 0, 2, 3), (0, 2, 3, 3), (2, 1, 3, 3)], (4, 5))\n-1",
      "vi": "Tìm tấm thảm trên cùng phủ một điểm nhất định trên mặt phẳng tọa độ.\n\nTham số:\nn (int): Tổng số thảm.\ncarpets (list of tuples): Một danh sách chứa n bộ giá trị, mỗi bộ đại diện cho thông tin của một tấm thảm.\nMỗi bộ chứa bốn số nguyên (a, b, g, k) trong đó (a, b) là tọa độ của góc dưới bên trái của tấm thảm và (g, k) là\nchiều dài của tấm thảm theo trục x và y tương ứng.\npoint (tuple): Một bộ chứa hai số nguyên (x, y), tọa độ của điểm cần kiểm tra.\n\nTrả về:\nint: Số của tấm thảm trên cùng phủ điểm (x, y), hoặc -1 nếu không có tấm thảm nào phủ nó.\n\nVí dụ:\n>>> find_topmost_carpet(3, [(1, 0, 2, 3), (0, 2, 3, 3), (2, 1, 3, 3)], (2, 2))\n3\n>>> find_topmost_carpet(3, [(1, 0, 2, 3), (0, 2, 3, 3), (2, 1, 3, 3)], (4, 5))\n-1"
    },
    "docstring_bertscore": {
      "es": "0.9871037238809288",
      "arb": "0.9735831524742651",
      "sw": "0.9755088740183983",
      "tr": "0.987400279039814",
      "vi": "0.9801848318183406"
    }
  },
  {
    "task_id": "Python/8",
    "prompt": {
      "en": "from typing import List, Tuple\n\ndef max_value_on_paths(N: int, grid_values: List[Tuple[int, int, int]]) -> int:\n    \"\"\"\n    Calculate the maximum sum of values collected on two paths in an N x N grid.\n\n    This function utilizes dynamic programming to find two paths from the top-left corner to\n    the bottom-right corner of the grid which maximize the sum of the values collected. Each\n    value can be collected at most once, even if both paths pass through it.\n\n    Args:\n    - N (int): The size of the grid (N x N).\n    - grid_values (List[Tuple[int, int, int]]): A list of tuples where each tuple contains\n      the x-coordinate, y-coordinate, and value to be placed on the grid at that position.\n      The list is terminated by a tuple with all zeros.\n\n    Returns:\n    - int: The maximum sum of values collected on the two paths.\n\n    Examples:\n    >>> max_value_on_paths(2, [(1, 2, 1), (2, 1, 2), (0, 0, 0)])\n    3\n    >>> max_value_on_paths(8, [\n    ...     (2, 3, 13), (2, 6, 6), (3, 5, 7), (4, 4, 14),\n    ...     (5, 2, 21), (5, 6, 4), (6, 3, 15), (7, 2, 14),\n    ...     (0, 0, 0)])\n    67\n    \"\"\"",
      "es": "from typing import List, Tuple\n\ndef max_value_on_paths(N: int, grid_values: List[Tuple[int, int, int]]) -> int:\n    \"\"\"\n    Calcular la suma máxima de valores recogidos en dos caminos en una cuadrícula de N x N.\n\n    Esta función utiliza programación dinámica para encontrar dos caminos desde la esquina\n    superior izquierda hasta la esquina inferior derecha de la cuadrícula que maximizan la\n    suma de los valores recogidos. Cada valor puede ser recogido como máximo una vez, incluso\n    si ambos caminos pasan por él.\n\n    Argumentos:\n    - N (int): El tamaño de la cuadrícula (N x N).\n    - grid_values (List[Tuple[int, int, int]]): Una lista de tuplas donde cada tupla contiene\n      la coordenada x, la coordenada y, y el valor que se colocará en la cuadrícula en esa\n      posición. La lista termina con una tupla con todos ceros.\n\n    Devuelve:\n    - int: La suma máxima de valores recogidos en los dos caminos.\n\n    Ejemplos:\n    >>> max_value_on_paths(2, [(1, 2, 1), (2, 1, 2), (0, 0, 0)])\n    3\n    >>> max_value_on_paths(8, [\n    ...     (2, 3, 13), (2, 6, 6), (3, 5, 7), (4, 4, 14),\n    ...     (5, 2, 21), (5, 6, 4), (6, 3, 15), (7, 2, 14),\n    ...     (0, 0, 0)])\n    67\n    \"\"\"",
      "arb": "from typing import List, Tuple\n\ndef max_value_on_paths(N: int, grid_values: List[Tuple[int, int, int]]) -> int:\n    \"\"\"\n    حساب مجموع القيم الأقصى التي تم جمعها على مسارين في شبكة بحجم N x N.\n\n    تستخدم هذه الدالة البرمجة الديناميكية للعثور على مسارين من الزاوية العلوية اليسرى إلى\n    الزاوية السفلية اليمنى للشبكة والتي تزيد من مجموع القيم التي تم جمعها. يمكن جمع كل\n    قيمة مرة واحدة على الأكثر، حتى إذا مر كلا المسارين من خلالها.\n\n    يعيدالحجج:\n    - N (int): حجم الشبكة (N x N).\n    - grid_values (List[Tuple[int, int, int]]): قائمة من الأزواج حيث يحتوي كل زوج على\n      الإحداثي السيني، الإحداثي الصادي، والقيمة التي سيتم وضعها على الشبكة في ذلك الموقع.\n      تنتهي القائمة بزوج يحتوي على جميع الأصفار.\n\n    يعيد:\n    - int: مجموع القيم الأقصى التي تم جمعها على المسارين.\n\n    أمثلة:\n    >>> max_value_on_paths(2, [(1, 2, 1), (2, 1, 2), (0, 0, 0)])\n    3\n    >>> max_value_on_paths(8, [\n    ...     (2, 3, 13), (2, 6, 6), (3, 5, 7), (4, 4, 14),\n    ...     (5, 2, 21), (5, 6, 4), (6, 3, 15), (7, 2, 14),\n    ...     (0, 0, 0)])\n    67\n    \"\"\"",
      "sw": "from typing import List, Tuple\n\ndef max_value_on_paths(N: int, grid_values: List[Tuple[int, int, int]]) -> int:\n    \"\"\"\n    Kuhesabu jumla ya juu zaidi ya thamani zilizokusanywa kwenye njia mbili katika gridi ya N x N.\n\n    Kazi hii inatumia programu ya nguvu ili kupata njia mbili kutoka kona ya juu-kushoto hadi\n    kona ya chini-kulia ya gridi ambayo huongeza jumla ya thamani zilizokusanywa. Kila\n    thamani inaweza kukusanywa mara moja tu, hata kama njia zote mbili zinapita kupitia hiyo.\n\n    Hoja:\n    - N (int): Ukubwa wa gridi (N x N).\n    - grid_values (List[Tuple[int, int, int]]): Orodha ya jozi ambapo kila jozi ina\n      x-kiwiko, y-kiwiko, na thamani ya kuwekwa kwenye gridi katika nafasi hiyo.\n      Orodha inakamilishwa na jozi yenye sifuri zote.\n\n    Inarejesha:\n    - int: Jumla ya juu zaidi ya thamani zilizokusanywa kwenye njia mbili.\n\n    Mifano:\n    >>> max_value_on_paths(2, [(1, 2, 1), (2, 1, 2), (0, 0, 0)])\n    3\n    >>> max_value_on_paths(8, [\n    ...     (2, 3, 13), (2, 6, 6), (3, 5, 7), (4, 4, 14),\n    ...     (5, 2, 21), (5, 6, 4), (6, 3, 15), (7, 2, 14),\n    ...     (0, 0, 0)])\n    67\n    \"\"\"",
      "tr": "from typing import List, Tuple\n\ndef max_value_on_paths(N: int, grid_values: List[Tuple[int, int, int]]) -> int:\n    \"\"\"\n    N x N boyutundaki bir ızgarada iki yolda toplanan değerlerin maksimum toplamını hesaplayın.\n\n    Bu fonksiyon, dinamik programlama kullanarak ızgaranın sol üst köşesinden sağ alt köşesine\n    kadar olan iki yolu bulur ve toplanan değerlerin toplamını maksimize eder. Her bir değer,\n    her iki yol da üzerinden geçse bile en fazla bir kez toplanabilir.\n\n    Argümanlar:\n    - N (int): Izgara boyutu (N x N).\n    - grid_values (List[Tuple[int, int, int]]): Her bir demetin x-koordinatı, y-koordinatı ve\n      o konumda ızgaraya yerleştirilecek değeri içerdiği demetlerin listesi. Liste, tüm elemanları\n      sıfır olan bir demet ile sonlandırılır.\n\n    Döndürür:\n    - int: İki yolda toplanan değerlerin maksimum toplamı.\n\n    Örnekler:\n    >>> max_value_on_paths(2, [(1, 2, 1), (2, 1, 2), (0, 0, 0)])\n    3\n    >>> max_value_on_paths(8, [\n    ...     (2, 3, 13), (2, 6, 6), (3, 5, 7), (4, 4, 14),\n    ...     (5, 2, 21), (5, 6, 4), (6, 3, 15), (7, 2, 14),\n    ...     (0, 0, 0)])\n    67\n    \"\"\"",
      "vi": "from typing import List, Tuple\n\ndef max_value_on_paths(N: int, grid_values: List[Tuple[int, int, int]]) -> int:\n    \"\"\"\n    Tính tổng giá trị lớn nhất thu thập được trên hai đường đi trong lưới N x N.\n\n    Hàm này sử dụng lập trình động để tìm hai đường đi từ góc trên bên trái đến\n    góc dưới bên phải của lưới sao cho tối đa hóa tổng giá trị thu thập được. Mỗi\n    giá trị có thể được thu thập tối đa một lần, ngay cả khi cả hai đường đi qua nó.\n\n    Tham số:\n    - N (int): Kích thước của lưới (N x N).\n    - grid_values (List[Tuple[int, int, int]]): Một danh sách các bộ ba mà mỗi bộ ba chứa\n      tọa độ x, tọa độ y, và giá trị được đặt trên lưới tại vị trí đó.\n      Danh sách kết thúc bằng một bộ ba với tất cả các giá trị bằng không.\n\n    Trả về:\n    - int: Tổng giá trị lớn nhất thu thập được trên hai đường đi.\n\n    Ví dụ:\n    >>> max_value_on_paths(2, [(1, 2, 1), (2, 1, 2), (0, 0, 0)])\n    3\n    >>> max_value_on_paths(8, [\n    ...     (2, 3, 13), (2, 6, 6), (3, 5, 7), (4, 4, 14),\n    ...     (5, 2, 21), (5, 6, 4), (6, 3, 15), (7, 2, 14),\n    ...     (0, 0, 0)])\n    67\n    \"\"\""
    },
    "prompt_bertscore": {
      "es": "0.976765211178444",
      "arb": "0.9918519831395679",
      "sw": "0.9625826047117909",
      "tr": "0.9767070124768007",
      "vi": "0.9488348001492232"
    },
    "canonical_solution": "# Initialize a 4-dimensional DP array\n    # dp[x1][y1][x2][y2] will store the max sum until reaching points (x1, y1) and (x2, y2) on both paths\n    dp = [[[[0 for _ in range(N+1)] for _ in range(N+1)] for _ in range(N+1)] for _ in range(N+1)]\n    \n    # Fill in the grid with input values\n    grid = [[0 for _ in range(N+1)] for _ in range(N+1)]\n    for x, y, val in grid_values:\n        grid[x][y] = val\n    \n    # Dynamic programming to calculate maximum values\n    # Both persons start at (1,1) and end at (N,N)\n    for x1 in range(1, N+1):\n        for y1 in range(1, N+1):\n            for x2 in range(1, N+1):\n                for y2 in range(1, N+1):\n                    # The maximum value for the current cell is the maximum of the values from\n                    # the previous step plus the value in the current cell(s)\n                    dp[x1][y1][x2][y2] = max(\n                        dp[x1-1][y1][x2-1][y2],\n                        dp[x1-1][y1][x2][y2-1],\n                        dp[x1][y1-1][x2-1][y2],\n                        dp[x1][y1-1][x2][y2-1]\n                    ) + grid[x1][y1] + (grid[x2][y2] if (x1, y1) != (x2, y2) else 0)\n    \n    # The answer is in the cell dp[N][N][N][N]\n    return dp[N][N][N][N]",
    "instruction": {
      "en": "def max_value_on_paths(N: int, grid_values: List[Tuple[int, int, int]]) -> int:\n# Initialize a 4-dimensional DP array\n    # dp[x1][y1][x2][y2] will store the max sum until reaching points (x1, y1) and (x2, y2) on both paths\n    dp = [[[[0 for _ in range(N+1)] for _ in range(N+1)] for _ in range(N+1)] for _ in range(N+1)]\n    \n    # Fill in the grid with input values\n    grid = [[0 for _ in range(N+1)] for _ in range(N+1)]\n    for x, y, val in grid_values:\n        grid[x][y] = val\n    \n    # Dynamic programming to calculate maximum values\n    # Both persons start at (1,1) and end at (N,N)\n    for x1 in range(1, N+1):\n        for y1 in range(1, N+1):\n            for x2 in range(1, N+1):\n                for y2 in range(1, N+1):\n                    # The maximum value for the current cell is the maximum of the values from\n                    # the previous step plus the value in the current cell(s)\n                    dp[x1][y1][x2][y2] = max(\n                        dp[x1-1][y1][x2-1][y2],\n                        dp[x1-1][y1][x2][y2-1],\n                        dp[x1][y1-1][x2-1][y2],\n                        dp[x1][y1-1][x2][y2-1]\n                    ) + grid[x1][y1] + (grid[x2][y2] if (x1, y1) != (x2, y2) else 0)\n    \n    # The answer is in the cell dp[N][N][N][N]\n    return dp[N][N][N][N]\n\nProvide a concise natural language description (docstring) of the Python code in English using at most 500 characters.",
      "es": "def max_value_on_paths(N: int, grid_values: List[Tuple[int, int, int]]) -> int:\n# Initialize a 4-dimensional DP array\n    # dp[x1][y1][x2][y2] will store the max sum until reaching points (x1, y1) and (x2, y2) on both paths\n    dp = [[[[0 for _ in range(N+1)] for _ in range(N+1)] for _ in range(N+1)] for _ in range(N+1)]\n    \n    # Fill in the grid with input values\n    grid = [[0 for _ in range(N+1)] for _ in range(N+1)]\n    for x, y, val in grid_values:\n        grid[x][y] = val\n    \n    # Dynamic programming to calculate maximum values\n    # Both persons start at (1,1) and end at (N,N)\n    for x1 in range(1, N+1):\n        for y1 in range(1, N+1):\n            for x2 in range(1, N+1):\n                for y2 in range(1, N+1):\n                    # The maximum value for the current cell is the maximum of the values from\n                    # the previous step plus the value in the current cell(s)\n                    dp[x1][y1][x2][y2] = max(\n                        dp[x1-1][y1][x2-1][y2],\n                        dp[x1-1][y1][x2][y2-1],\n                        dp[x1][y1-1][x2-1][y2],\n                        dp[x1][y1-1][x2][y2-1]\n                    ) + grid[x1][y1] + (grid[x2][y2] if (x1, y1) != (x2, y2) else 0)\n    \n    # The answer is in the cell dp[N][N][N][N]\n    return dp[N][N][N][N]\n\nProporciona una descripción concisa en lenguaje natural (docstring) del código Python en español utilizando un máximo de 500 caracteres.",
      "arb": "def max_value_on_paths(N: int, grid_values: List[Tuple[int, int, int]]) -> int:\n# Initialize a 4-dimensional DP array\n    # dp[x1][y1][x2][y2] will store the max sum until reaching points (x1, y1) and (x2, y2) on both paths\n    dp = [[[[0 for _ in range(N+1)] for _ in range(N+1)] for _ in range(N+1)] for _ in range(N+1)]\n    \n    # Fill in the grid with input values\n    grid = [[0 for _ in range(N+1)] for _ in range(N+1)]\n    for x, y, val in grid_values:\n        grid[x][y] = val\n    \n    # Dynamic programming to calculate maximum values\n    # Both persons start at (1,1) and end at (N,N)\n    for x1 in range(1, N+1):\n        for y1 in range(1, N+1):\n            for x2 in range(1, N+1):\n                for y2 in range(1, N+1):\n                    # The maximum value for the current cell is the maximum of the values from\n                    # the previous step plus the value in the current cell(s)\n                    dp[x1][y1][x2][y2] = max(\n                        dp[x1-1][y1][x2-1][y2],\n                        dp[x1-1][y1][x2][y2-1],\n                        dp[x1][y1-1][x2-1][y2],\n                        dp[x1][y1-1][x2][y2-1]\n                    ) + grid[x1][y1] + (grid[x2][y2] if (x1, y1) != (x2, y2) else 0)\n    \n    # The answer is in the cell dp[N][N][N][N]\n    return dp[N][N][N][N]\n\nقدم وصفًا موجزًا بلغة طبيعية (docstring) للكود البرمجي بلغة بايثون باللغة العربية الفصحى باستخدام ما لا يزيد عن 500 حرف.",
      "sw": "def max_value_on_paths(N: int, grid_values: List[Tuple[int, int, int]]) -> int:\n# Initialize a 4-dimensional DP array\n    # dp[x1][y1][x2][y2] will store the max sum until reaching points (x1, y1) and (x2, y2) on both paths\n    dp = [[[[0 for _ in range(N+1)] for _ in range(N+1)] for _ in range(N+1)] for _ in range(N+1)]\n    \n    # Fill in the grid with input values\n    grid = [[0 for _ in range(N+1)] for _ in range(N+1)]\n    for x, y, val in grid_values:\n        grid[x][y] = val\n    \n    # Dynamic programming to calculate maximum values\n    # Both persons start at (1,1) and end at (N,N)\n    for x1 in range(1, N+1):\n        for y1 in range(1, N+1):\n            for x2 in range(1, N+1):\n                for y2 in range(1, N+1):\n                    # The maximum value for the current cell is the maximum of the values from\n                    # the previous step plus the value in the current cell(s)\n                    dp[x1][y1][x2][y2] = max(\n                        dp[x1-1][y1][x2-1][y2],\n                        dp[x1-1][y1][x2][y2-1],\n                        dp[x1][y1-1][x2-1][y2],\n                        dp[x1][y1-1][x2][y2-1]\n                    ) + grid[x1][y1] + (grid[x2][y2] if (x1, y1) != (x2, y2) else 0)\n    \n    # The answer is in the cell dp[N][N][N][N]\n    return dp[N][N][N][N]\n\nToa maelezo mafupi ya lugha ya asili (docstring) ya msimbo wa Python kwa Kiswahili kwa kutumia herufi zisizozidi 500.",
      "tr": "def max_value_on_paths(N: int, grid_values: List[Tuple[int, int, int]]) -> int:\n# Initialize a 4-dimensional DP array\n    # dp[x1][y1][x2][y2] will store the max sum until reaching points (x1, y1) and (x2, y2) on both paths\n    dp = [[[[0 for _ in range(N+1)] for _ in range(N+1)] for _ in range(N+1)] for _ in range(N+1)]\n    \n    # Fill in the grid with input values\n    grid = [[0 for _ in range(N+1)] for _ in range(N+1)]\n    for x, y, val in grid_values:\n        grid[x][y] = val\n    \n    # Dynamic programming to calculate maximum values\n    # Both persons start at (1,1) and end at (N,N)\n    for x1 in range(1, N+1):\n        for y1 in range(1, N+1):\n            for x2 in range(1, N+1):\n                for y2 in range(1, N+1):\n                    # The maximum value for the current cell is the maximum of the values from\n                    # the previous step plus the value in the current cell(s)\n                    dp[x1][y1][x2][y2] = max(\n                        dp[x1-1][y1][x2-1][y2],\n                        dp[x1-1][y1][x2][y2-1],\n                        dp[x1][y1-1][x2-1][y2],\n                        dp[x1][y1-1][x2][y2-1]\n                    ) + grid[x1][y1] + (grid[x2][y2] if (x1, y1) != (x2, y2) else 0)\n    \n    # The answer is in the cell dp[N][N][N][N]\n    return dp[N][N][N][N]\n\nVerilen Python kodunun işlevini açıklayan, en fazla 500 karakter uzunluğunda özlü bir doğal dil açıklaması (docstring) sağlayın.",
      "vi": "def max_value_on_paths(N: int, grid_values: List[Tuple[int, int, int]]) -> int:\n# Initialize a 4-dimensional DP array\n    # dp[x1][y1][x2][y2] will store the max sum until reaching points (x1, y1) and (x2, y2) on both paths\n    dp = [[[[0 for _ in range(N+1)] for _ in range(N+1)] for _ in range(N+1)] for _ in range(N+1)]\n    \n    # Fill in the grid with input values\n    grid = [[0 for _ in range(N+1)] for _ in range(N+1)]\n    for x, y, val in grid_values:\n        grid[x][y] = val\n    \n    # Dynamic programming to calculate maximum values\n    # Both persons start at (1,1) and end at (N,N)\n    for x1 in range(1, N+1):\n        for y1 in range(1, N+1):\n            for x2 in range(1, N+1):\n                for y2 in range(1, N+1):\n                    # The maximum value for the current cell is the maximum of the values from\n                    # the previous step plus the value in the current cell(s)\n                    dp[x1][y1][x2][y2] = max(\n                        dp[x1-1][y1][x2-1][y2],\n                        dp[x1-1][y1][x2][y2-1],\n                        dp[x1][y1-1][x2-1][y2],\n                        dp[x1][y1-1][x2][y2-1]\n                    ) + grid[x1][y1] + (grid[x2][y2] if (x1, y1) != (x2, y2) else 0)\n    \n    # The answer is in the cell dp[N][N][N][N]\n    return dp[N][N][N][N]\n\nCung cấp mô tả ngắn gọn bằng ngôn ngữ tự nhiên (docstring) cho mã Python bằng tiếng Việt với tối đa 500 ký tự."
    },
    "instruction_bertscore": {
      "es": "0.9687387561112052",
      "arb": "0.9140176751791418",
      "sw": "0.914896018724078",
      "tr": "0.8508820154152974",
      "vi": "0.9221422536546118"
    },
    "level": "",
    "test": "def test_max_value_on_paths():\n    # Test case 1: Small grid with clear path\n    assert max_value_on_paths(2, [(1, 2, 1), (2, 1, 2), (0, 0, 0)]) == 3\n    \n    # Test case 2: Example provided in the problem statement\n    assert max_value_on_paths(8, [\n        (2, 3, 13), (2, 6, 6), (3, 5, 7), (4, 4, 14),\n        (5, 2, 21), (5, 6, 4), (6, 3, 15), (7, 2, 14),\n        (0, 0, 0)]) == 67\n\n    print(\"All test cases passed!\")\n\n# Run the test cases\ntest_max_value_on_paths()",
    "entry_point": "max_value_on_paths",
    "signature": "def max_value_on_paths(N: int, grid_values: List[Tuple[int, int, int]]) -> int:",
    "docstring": {
      "en": "Calculate the maximum sum of values collected on two paths in an N x N grid.\n\nThis function utilizes dynamic programming to find two paths from the top-left corner to\nthe bottom-right corner of the grid which maximize the sum of the values collected. Each\nvalue can be collected at most once, even if both paths pass through it.\n\nArgs:\n- N (int): The size of the grid (N x N).\n- grid_values (List[Tuple[int, int, int]]): A list of tuples where each tuple contains\nthe x-coordinate, y-coordinate, and value to be placed on the grid at that position.\nThe list is terminated by a tuple with all zeros.\n\nReturns:\n- int: The maximum sum of values collected on the two paths.\n\nExamples:\n>>> max_value_on_paths(2, [(1, 2, 1), (2, 1, 2), (0, 0, 0)])\n3\n>>> max_value_on_paths(8, [\n...     (2, 3, 13), (2, 6, 6), (3, 5, 7), (4, 4, 14),\n...     (5, 2, 21), (5, 6, 4), (6, 3, 15), (7, 2, 14),\n...     (0, 0, 0)])\n67",
      "es": "Calcular la suma máxima de valores recogidos en dos caminos en una cuadrícula de N x N.\n\nEsta función utiliza programación dinámica para encontrar dos caminos desde la esquina superior izquierda hasta la esquina inferior derecha de la cuadrícula que maximizan la suma de los valores recogidos. Cada valor puede ser recogido como máximo una vez, incluso si ambos caminos pasan por él.\n\nArgumentos:\n- N (int): El tamaño de la cuadrícula (N x N).\n- grid_values (List[Tuple[int, int, int]]): Una lista de tuplas donde cada tupla contiene\nla coordenada x, la coordenada y, y el valor a colocar en la cuadrícula en esa posición.\nLa lista termina con una tupla con todos ceros.\n\nDevuelve:\n- int: La suma máxima de valores recogidos en los dos caminos.\n\nEjemplos:\n>>> max_value_on_paths(2, [(1, 2, 1), (2, 1, 2), (0, 0, 0)])\n3\n>>> max_value_on_paths(8, [\n...     (2, 3, 13), (2, 6, 6), (3, 5, 7), (4, 4, 14),\n...     (5, 2, 21), (5, 6, 4), (6, 3, 15), (7, 2, 14),\n...     (0, 0, 0)])\n67",
      "arb": "احسب الحد الأقصى لمجموع القيم المجمعة على مسارين في شبكة بحجم N x N.\n\nتستخدم هذه الدالة البرمجة الديناميكية لإيجاد مسارين من الزاوية العلوية اليسرى إلى\nالزاوية السفلية اليمنى من الشبكة والتي تزيد من مجموع القيم المجمعة. يمكن جمع كل\nقيمة مرة واحدة فقط، حتى إذا مر كلا المسارين من خلالها.\n\nالمعطيات:\n- N (int): حجم الشبكة (N x N).\n- grid_values (List[Tuple[int, int, int]]): قائمة من الأزواج حيث يحتوي كل زوج على\nالإحداثي السيني، الإحداثي الصادي، والقيمة التي سيتم وضعها على الشبكة في ذلك الموضع.\nتنتهي القائمة بزوج يحتوي على جميع الأصفار.\n\nالقيم المعادة:\n- int: الحد الأقصى لمجموع القيم المجمعة على المسارين.\n\nأمثلة:\n>>> max_value_on_paths(2, [(1, 2, 1), (2, 1, 2), (0, 0, 0)])\n3\n>>> max_value_on_paths(8, [\n...     (2, 3, 13), (2, 6, 6), (3, 5, 7), (4, 4, 14),\n...     (5, 2, 21), (5, 6, 4), (6, 3, 15), (7, 2, 14),\n...     (0, 0, 0)])\n67",
      "sw": "Hesabu jumla ya juu zaidi ya thamani zilizokusanywa kwenye njia mbili katika gridi ya N x N.\n\nKazi hii inatumia programu ya nguvu ili kupata njia mbili kutoka kona ya juu kushoto hadi\nkona ya chini kulia ya gridi ambayo huongeza jumla ya thamani zilizokusanywa. Kila\nthamani inaweza kukusanywa mara moja tu, hata kama njia zote mbili zinapita kupitia hapo.\n\nHoja:\n- N (int): Ukubwa wa gridi (N x N).\n- grid_values (List[Tuple[int, int, int]]): Orodha ya jozi ambapo kila jozi ina\nx-kiwianishi, y-kiwianishi, na thamani ya kuwekwa kwenye gridi katika nafasi hiyo.\nOrodha inamalizika na jozi yenye sifuri zote.\n\nInarejesha:\n- int: Jumla ya juu zaidi ya thamani zilizokusanywa kwenye njia mbili.\n\nMifano:\n>>> max_value_on_paths(2, [(1, 2, 1), (2, 1, 2), (0, 0, 0)])\n3\n>>> max_value_on_paths(8, [\n...     (2, 3, 13), (2, 6, 6), (3, 5, 7), (4, 4, 14),\n...     (5, 2, 21), (5, 6, 4), (6, 3, 15), (7, 2, 14),\n...     (0, 0, 0)])\n67",
      "tr": "N x N boyutundaki bir ızgarada iki yolda toplanan değerlerin maksimum toplamını hesaplayın.\n\nBu fonksiyon, dinamik programlama kullanarak ızgaranın sol üst köşesinden sağ alt köşesine\nkadar iki yol bulur ve toplanan değerlerin toplamını maksimize eder. Her bir değer en fazla bir kez toplanabilir, her iki yol da aynı yerden geçse bile.\n\nArgümanlar:\n- N (int): Izgaranın boyutu (N x N).\n- grid_values (List[Tuple[int, int, int]]): Her bir demetin, ızgaradaki bir konuma yerleştirilecek\nx-koordinatı, y-koordinatı ve değeri içerdiği demetlerin bir listesi.\nListe, tüm elemanları sıfır olan bir demet ile sonlandırılır.\n\nDöndürür:\n- int: İki yolda toplanan değerlerin maksimum toplamı.\n\nÖrnekler:\n>>> max_value_on_paths(2, [(1, 2, 1), (2, 1, 2), (0, 0, 0)])\n3\n>>> max_value_on_paths(8, [\n...     (2, 3, 13), (2, 6, 6), (3, 5, 7), (4, 4, 14),\n...     (5, 2, 21), (5, 6, 4), (6, 3, 15), (7, 2, 14),\n...     (0, 0, 0)])\n67",
      "vi": "Tính tổng giá trị lớn nhất thu thập được trên hai đường đi trong lưới N x N.\n\nHàm này sử dụng lập trình động để tìm hai đường đi từ góc trên bên trái đến góc dưới bên phải của lưới, nhằm tối đa hóa tổng giá trị thu thập được. Mỗi giá trị có thể được thu thập nhiều nhất một lần, ngay cả khi cả hai đường đi đều đi qua nó.\n\nTham số:\n- N (int): Kích thước của lưới (N x N).\n- grid_values (List[Tuple[int, int, int]]): Một danh sách các bộ ba, trong đó mỗi bộ ba chứa tọa độ x, tọa độ y, và giá trị sẽ được đặt trên lưới tại vị trí đó. Danh sách kết thúc bằng một bộ ba với tất cả các giá trị bằng không.\n\nTrả về:\n- int: Tổng giá trị lớn nhất thu thập được trên hai đường đi.\n\nVí dụ:\n>>> max_value_on_paths(2, [(1, 2, 1), (2, 1, 2), (0, 0, 0)])\n3\n>>> max_value_on_paths(8, [\n...     (2, 3, 13), (2, 6, 6), (3, 5, 7), (4, 4, 14),\n...     (5, 2, 21), (5, 6, 4), (6, 3, 15), (7, 2, 14),\n...     (0, 0, 0)])\n67"
    },
    "docstring_bertscore": {
      "es": "0.9766865535475542",
      "arb": "0.9809648533246645",
      "sw": "0.9604493144194761",
      "tr": "0.9735422346157718",
      "vi": "0.9430931903550287"
    }
  },
  {
    "task_id": "Python/9",
    "prompt": {
      "en": "from itertools import permutations\n\ndef find_number_combinations():\n    \"\"\"\n    Generate all unique combinations of three numbers, each formed from the digits 1 to 9 without repetition,\n    such that the second number is twice the first and the third is three times the first.\n\n    Returns:\n        list of tuples: A sorted list of tuples, where each tuple contains three integers representing the\n                        valid number combinations in ascending order based on the first number.\n\n    Example:\n        >>> find_number_combinations()\n        [(123, 246, 369), (124, 248, 372), ...]\n    \"\"\"",
      "es": "from itertools import permutations\n\ndef find_number_combinations():\n    \"\"\"\n    Genera todas las combinaciones únicas de tres números, cada uno formado por los dígitos del 1 al 9 sin repetición,\n    tal que el segundo número es el doble del primero y el tercero es el triple del primero.\n\n    Devuelve:\n        lista de tuplas: Una lista ordenada de tuplas, donde cada tupla contiene tres enteros que representan las\n                         combinaciones de números válidas en orden ascendente basado en el primer número.\n\n    Ejemplo:\n        >>> find_number_combinations()\n        [(123, 246, 369), (124, 248, 372), ...]\n    \"\"\"",
      "arb": "from itertools import permutations\n\ndef find_number_combinations():\n    \"\"\"\n    توليد جميع التوليفات الفريدة من ثلاثة أرقام، كل منها مكون من الأرقام من 1 إلى 9 دون تكرار،\n    بحيث يكون الرقم الثاني ضعف الأول والثالث ثلاثة أضعاف الأول.\n\n    يعيد:\n        list of tuples: قائمة مرتبة من المجموعات، حيث تحتوي كل مجموعة على ثلاثة أعداد صحيحة تمثل\n                        توليفات الأرقام الصحيحة بترتيب تصاعدي بناءً على الرقم الأول.\n\n    Example:\n        >>> find_number_combinations()\n        [(123, 246, 369), (124, 248, 372), ...]\n    \"\"\"",
      "sw": "from itertools import permutations\n\ndef find_number_combinations():\n    \"\"\"\n    Tengeneza mchanganyiko wote wa kipekee wa namba tatu, kila moja ikiwa imetengenezwa kutoka kwa tarakimu 1 hadi 9 bila kurudia,\n    kiasi kwamba namba ya pili ni mara mbili ya ya kwanza na ya tatu ni mara tatu ya ya kwanza.\n\n    Inarudisha:\n        orodha ya tuples: Orodha iliyopangwa ya tuples, ambapo kila tuple ina namba tatu za mzima zinazowakilisha\n                          mchanganyiko sahihi wa namba katika mpangilio wa kupanda kulingana na namba ya kwanza.\n\n    Mfano:\n        >>> find_number_combinations()\n        [(123, 246, 369), (124, 248, 372), ...]\n    \"\"\"",
      "tr": "from itertools import permutations\n\ndef find_number_combinations():\n    \"\"\"\n    1'den 9'a kadar olan rakamlardan tekrar etmeden oluşturulan üç sayının tüm benzersiz kombinasyonlarını üret,\n    öyle ki ikinci sayı birincinin iki katı ve üçüncü sayı birincinin üç katı olsun.\n\n    Döndürür:\n        list of tuples: Her bir tuple'ın üç tamsayı içerdiği ve geçerli sayı kombinasyonlarını birinci sayıya göre\n                        artan sırayla temsil ettiği sıralı bir tuple listesi.\n\n    Örnek:\n        >>> find_number_combinations()\n        [(123, 246, 369), (124, 248, 372), ...]\n    \"\"\"",
      "vi": "from itertools import permutations\n\ndef find_number_combinations():\n    \"\"\"\n    Tạo tất cả các tổ hợp duy nhất của ba số, mỗi số được tạo từ các chữ số từ 1 đến 9 mà không lặp lại,\n    sao cho số thứ hai gấp đôi số thứ nhất và số thứ ba gấp ba lần số thứ nhất.\n\n    Trả về:\n        list of tuples: Một danh sách đã sắp xếp của các bộ ba, trong đó mỗi bộ ba chứa ba số nguyên đại diện cho\n                        các tổ hợp số hợp lệ theo thứ tự tăng dần dựa trên số thứ nhất.\n\n    Ví dụ:\n        >>> find_number_combinations()\n        [(123, 246, 369), (124, 248, 372), ...]\n    \"\"\""
    },
    "prompt_bertscore": {
      "es": "0.9812296276225841",
      "arb": "0.9458303170056894",
      "sw": "0.9736765087533514",
      "tr": "0.9808226339718437",
      "vi": "0.9532980248110771"
    },
    "canonical_solution": "# Store the valid combinations\n    valid_combinations = []\n\n    # Generate all permutations of the numbers 1 through 9\n    for perm in permutations(range(1, 10)):\n        # Split the permutation into three numbers\n        num1 = perm[0] * 100 + perm[1] * 10 + perm[2]\n        num2 = perm[3] * 100 + perm[4] * 10 + perm[5]\n        num3 = perm[6] * 100 + perm[7] * 10 + perm[8]\n\n        # Check if the numbers form a 1:2:3 ratio\n        if num2 == 2 * num1 and num3 == 3 * num1:\n            valid_combinations.append((num1, num2, num3))\n\n    # Sort the valid combinations by the first number\n    valid_combinations.sort()\n\n    return valid_combinations\n\n# Print the valid combinations\nfor combination in find_number_combinations():\n    print(combination[0], combination[1], combination[2])",
    "instruction": {
      "en": "def find_number_combinations():\n# Store the valid combinations\n    valid_combinations = []\n\n    # Generate all permutations of the numbers 1 through 9\n    for perm in permutations(range(1, 10)):\n        # Split the permutation into three numbers\n        num1 = perm[0] * 100 + perm[1] * 10 + perm[2]\n        num2 = perm[3] * 100 + perm[4] * 10 + perm[5]\n        num3 = perm[6] * 100 + perm[7] * 10 + perm[8]\n\n        # Check if the numbers form a 1:2:3 ratio\n        if num2 == 2 * num1 and num3 == 3 * num1:\n            valid_combinations.append((num1, num2, num3))\n\n    # Sort the valid combinations by the first number\n    valid_combinations.sort()\n\n    return valid_combinations\n\n# Print the valid combinations\nfor combination in find_number_combinations():\n    print(combination[0], combination[1], combination[2])\n\nProvide a concise natural language description (docstring) of the Python code in English using at most 500 characters.",
      "es": "def find_number_combinations():\n# Store the valid combinations\n    valid_combinations = []\n\n    # Generate all permutations of the numbers 1 through 9\n    for perm in permutations(range(1, 10)):\n        # Split the permutation into three numbers\n        num1 = perm[0] * 100 + perm[1] * 10 + perm[2]\n        num2 = perm[3] * 100 + perm[4] * 10 + perm[5]\n        num3 = perm[6] * 100 + perm[7] * 10 + perm[8]\n\n        # Check if the numbers form a 1:2:3 ratio\n        if num2 == 2 * num1 and num3 == 3 * num1:\n            valid_combinations.append((num1, num2, num3))\n\n    # Sort the valid combinations by the first number\n    valid_combinations.sort()\n\n    return valid_combinations\n\n# Print the valid combinations\nfor combination in find_number_combinations():\n    print(combination[0], combination[1], combination[2])\n\nProporciona una descripción concisa en lenguaje natural (docstring) del código Python en español utilizando como máximo 500 caracteres.",
      "arb": "def find_number_combinations():\n# Store the valid combinations\n    valid_combinations = []\n\n    # Generate all permutations of the numbers 1 through 9\n    for perm in permutations(range(1, 10)):\n        # Split the permutation into three numbers\n        num1 = perm[0] * 100 + perm[1] * 10 + perm[2]\n        num2 = perm[3] * 100 + perm[4] * 10 + perm[5]\n        num3 = perm[6] * 100 + perm[7] * 10 + perm[8]\n\n        # Check if the numbers form a 1:2:3 ratio\n        if num2 == 2 * num1 and num3 == 3 * num1:\n            valid_combinations.append((num1, num2, num3))\n\n    # Sort the valid combinations by the first number\n    valid_combinations.sort()\n\n    return valid_combinations\n\n# Print the valid combinations\nfor combination in find_number_combinations():\n    print(combination[0], combination[1], combination[2])\n\nيرجى تقديم وصف موجز بلغة طبيعية (docstring) للشفرة البرمجية بلغة بايثون باللغة العربية الفصحى باستخدام 500 حرف كحد أقصى.",
      "sw": "def find_number_combinations():\n# Store the valid combinations\n    valid_combinations = []\n\n    # Generate all permutations of the numbers 1 through 9\n    for perm in permutations(range(1, 10)):\n        # Split the permutation into three numbers\n        num1 = perm[0] * 100 + perm[1] * 10 + perm[2]\n        num2 = perm[3] * 100 + perm[4] * 10 + perm[5]\n        num3 = perm[6] * 100 + perm[7] * 10 + perm[8]\n\n        # Check if the numbers form a 1:2:3 ratio\n        if num2 == 2 * num1 and num3 == 3 * num1:\n            valid_combinations.append((num1, num2, num3))\n\n    # Sort the valid combinations by the first number\n    valid_combinations.sort()\n\n    return valid_combinations\n\n# Print the valid combinations\nfor combination in find_number_combinations():\n    print(combination[0], combination[1], combination[2])\n\nToa maelezo mafupi ya lugha ya asili (docstring) ya msimbo wa Python kwa Kiswahili kwa kutumia herufi zisizozidi 500.",
      "tr": "def find_number_combinations():\n# Store the valid combinations\n    valid_combinations = []\n\n    # Generate all permutations of the numbers 1 through 9\n    for perm in permutations(range(1, 10)):\n        # Split the permutation into three numbers\n        num1 = perm[0] * 100 + perm[1] * 10 + perm[2]\n        num2 = perm[3] * 100 + perm[4] * 10 + perm[5]\n        num3 = perm[6] * 100 + perm[7] * 10 + perm[8]\n\n        # Check if the numbers form a 1:2:3 ratio\n        if num2 == 2 * num1 and num3 == 3 * num1:\n            valid_combinations.append((num1, num2, num3))\n\n    # Sort the valid combinations by the first number\n    valid_combinations.sort()\n\n    return valid_combinations\n\n# Print the valid combinations\nfor combination in find_number_combinations():\n    print(combination[0], combination[1], combination[2])\n\nAşağıdaki Python kodunun Türkçe olarak en fazla 500 karakter kullanarak özlü bir doğal dil açıklamasını (docstring) sağlayın.",
      "vi": "def find_number_combinations():\n# Store the valid combinations\n    valid_combinations = []\n\n    # Generate all permutations of the numbers 1 through 9\n    for perm in permutations(range(1, 10)):\n        # Split the permutation into three numbers\n        num1 = perm[0] * 100 + perm[1] * 10 + perm[2]\n        num2 = perm[3] * 100 + perm[4] * 10 + perm[5]\n        num3 = perm[6] * 100 + perm[7] * 10 + perm[8]\n\n        # Check if the numbers form a 1:2:3 ratio\n        if num2 == 2 * num1 and num3 == 3 * num1:\n            valid_combinations.append((num1, num2, num3))\n\n    # Sort the valid combinations by the first number\n    valid_combinations.sort()\n\n    return valid_combinations\n\n# Print the valid combinations\nfor combination in find_number_combinations():\n    print(combination[0], combination[1], combination[2])\n\nCung cấp mô tả ngắn gọn bằng ngôn ngữ tự nhiên (docstring) cho mã Python bằng tiếng Việt, sử dụng tối đa 500 ký tự."
    },
    "instruction_bertscore": {
      "es": "0.9687387561112052",
      "arb": "0.924699818440817",
      "sw": "0.914896018724078",
      "tr": "0.9083815381172768",
      "vi": "0.9069722555638342"
    },
    "level": "",
    "test": "def test_find_number_combinations():\n    # Call the function to get the combinations\n    combinations = find_number_combinations()\n\n    # Check that we have at least one valid combination\n    assert len(combinations) > 0, \"There should be at least one valid combination.\"\n\n    # Iterate over each combination to perform further checks\n    for combo in combinations:\n        # Each combination should have exactly three numbers\n        assert len(combo) == 3, \"Each combination should have three numbers.\"\n\n        # Check if numbers are 3-digit numbers\n        for num in combo:\n            assert 100 <= num <= 999, f\"Each number should be a 3-digit number, got {num}.\"\n\n        # Check the 1:2:3 ratio\n        assert combo[1] == 2 * combo[0] and combo[2] == 3 * combo[0], \"The numbers should be in a 1:2:3 ratio.\"\n\n    print(\"All test cases passed!\")",
    "entry_point": "find_number_combinations",
    "signature": "def find_number_combinations():",
    "docstring": {
      "en": "Generate all unique combinations of three numbers, each formed from the digits 1 to 9 without repetition,\nsuch that the second number is twice the first and the third is three times the first.\n\nReturns:\nlist of tuples: A sorted list of tuples, where each tuple contains three integers representing the\nvalid number combinations in ascending order based on the first number.\n\nExample:\n>>> find_number_combinations()\n[(123, 246, 369), (124, 248, 372), ...]",
      "es": "Generar todas las combinaciones únicas de tres números, cada uno formado por los dígitos del 1 al 9 sin repetición, de tal manera que el segundo número sea el doble del primero y el tercero sea el triple del primero.\n\nDevuelve:\nlista de tuplas: Una lista ordenada de tuplas, donde cada tupla contiene tres enteros que representan las combinaciones de números válidas en orden ascendente basado en el primer número.\n\nEjemplo:\n>>> find_number_combinations()\n[(123, 246, 369), (124, 248, 372), ...]",
      "arb": "توليد جميع التوليفات الفريدة من ثلاثة أرقام، كل منها يتكون من الأرقام من 1 إلى 9 بدون تكرار، بحيث يكون الرقم الثاني ضعف الأول والرقم الثالث ثلاثة أضعاف الأول.\n\nيعيد:\nقائمة من المجموعات: قائمة مرتبة من المجموعات، حيث تحتوي كل مجموعة على ثلاثة أعداد صحيحة تمثل التوليفات العددية الصالحة بترتيب تصاعدي بناءً على الرقم الأول.\n\nExample:\n>>> find_number_combinations()\n[(123, 246, 369), (124, 248, 372), ...]",
      "sw": "Tengeneza mchanganyiko wote wa kipekee wa namba tatu, kila moja ikiwa imetengenezwa kutoka kwa tarakimu 1 hadi 9 bila kurudia, \nambapo namba ya pili ni mara mbili ya ya kwanza na ya tatu ni mara tatu ya ya kwanza.\n\nRudisha:\norodha ya jozi: Orodha iliyopangwa ya jozi, ambapo kila jozi ina nambari tatu zinazoashiria \nmchanganyiko sahihi wa nambari kwa mpangilio wa kupanda kulingana na namba ya kwanza.\n\nMfano:\n>>> find_number_combinations()\n[(123, 246, 369), (124, 248, 372), ...]",
      "tr": "Üç sayının her birinin 1'den 9'a kadar olan rakamlardan tekrar etmeden oluştuğu tüm benzersiz kombinasyonları oluşturun,\nöyle ki ikinci sayı birincinin iki katı ve üçüncü sayı birincinin üç katı olsun.\n\nDöndürür:\nlist of tuples: Her bir demetin, birinci sayıya göre artan sırada geçerli sayı kombinasyonlarını temsil eden üç tam sayı içerdiği sıralı bir demet listesi.\n\nÖrnek:\n>>> find_number_combinations()\n[(123, 246, 369), (124, 248, 372), ...]",
      "vi": "Tạo tất cả các tổ hợp duy nhất của ba số, mỗi số được tạo từ các chữ số từ 1 đến 9 mà không lặp lại, sao cho số thứ hai gấp đôi số thứ nhất và số thứ ba gấp ba lần số thứ nhất.\n\nTrả về:\ndanh sách các bộ giá trị: Một danh sách đã được sắp xếp của các bộ giá trị, trong đó mỗi bộ chứa ba số nguyên đại diện cho các tổ hợp số hợp lệ theo thứ tự tăng dần dựa trên số thứ nhất.\n\nVí dụ:\n>>> find_number_combinations()\n[(123, 246, 369), (124, 248, 372), ...]"
    },
    "docstring_bertscore": {
      "es": "0.9806273803072864",
      "arb": "0.9350808380448433",
      "sw": "0.9504814460080023",
      "tr": "0.9549037528113631",
      "vi": "0.9688887220488865"
    }
  },
  {
    "task_id": "Python/10",
    "prompt": {
      "en": "def sum_of_factorials_optimized(n: int) -> int:\n    \"\"\"\n    Compute the cumulative sum of factorial values from 1 up to a specified integer n.\n\n    This function employs a more efficient method to calculate factorials by iteratively\n    multiplying the current number to the previous factorial result, thus avoiding redundant\n    calculations. It then accumulates the factorial of each number from 1 to n inclusively.\n\n    Args:\n    n (int): The upper limit of the range for which the factorial sum is to be calculated.\n             The value of n should be in the range of 1 to 50, inclusive.\n\n    Returns:\n    int: The sum of all factorial values from 1! to n!.\n\n    Examples:\n    >>> sum_of_factorials_optimized(3)\n    9\n    >>> sum_of_factorials_optimized(5)\n    153\n    >>> sum_of_factorials_optimized(6)\n    873\n    \"\"\"",
      "es": "def sum_of_factorials_optimized(n: int) -> int:\n    \"\"\"\n    Calcula la suma acumulativa de los valores factoriales desde 1 hasta un entero especificado n.\n\n    Esta función emplea un método más eficiente para calcular factoriales multiplicando\n    iterativamente el número actual por el resultado factorial anterior, evitando así cálculos\n    redundantes. Luego acumula el factorial de cada número desde 1 hasta n inclusive.\n\n    Argumentos:\n    n (int): El límite superior del rango para el cual se va a calcular la suma de factoriales.\n             El valor de n debe estar en el rango de 1 a 50, inclusive.\n\n    Devuelve:\n    int: La suma de todos los valores factoriales desde 1! hasta n!.\n\n    Ejemplos:\n    >>> sum_of_factorials_optimized(3)\n    9\n    >>> sum_of_factorials_optimized(5)\n    153\n    >>> sum_of_factorials_optimized(6)\n    873\n    \"\"\"",
      "arb": "def sum_of_factorials_optimized(n: int) -> int:\n    \"\"\"\n    حساب المجموع التراكمي لقيم المضروب من 1 حتى عدد صحيح محدد n.\n\n    تستخدم هذه الدالة طريقة أكثر كفاءة لحساب المضروبات عن طريق ضرب الرقم الحالي في نتيجة المضروب السابقة،\n    وبالتالي تجنب الحسابات المتكررة. ثم تجمع مضروب كل رقم من 1 إلى n بشكل شامل.\n\n    يعيدالحجج:\n    n (int): الحد الأعلى للنطاق الذي سيتم حساب مجموع المضروب له.\n             يجب أن تكون قيمة n في النطاق من 1 إلى 50، شاملًا.\n\n    يعيد:\n    int: مجموع جميع قيم المضروب من 1! إلى n!.\n\n    امثله:\n    >>> sum_of_factorials_optimized(3)\n    9\n    >>> sum_of_factorials_optimized(5)\n    153\n    >>> sum_of_factorials_optimized(6)\n    873\n    \"\"\"",
      "sw": "def sum_of_factorials_optimized(n: int) -> int:\n    \"\"\"\n    Hesabu jumla ya thamani za factorial kutoka 1 hadi n iliyobainishwa.\n\n    Kazi hii inatumia mbinu bora zaidi ya kuhesabu factorial kwa kuzidisha\n    namba ya sasa na matokeo ya factorial ya awali, hivyo kuepuka mahesabu\n    yasiyo ya lazima. Kisha inakusanya factorial ya kila namba kutoka 1 hadi n ikijumuisha.\n\n    Hoja:\n    n (int): Kikomo cha juu cha safu ambayo jumla ya factorial inapaswa kuhesabiwa.\n             Thamani ya n inapaswa kuwa katika safu ya 1 hadi 50, ikijumuisha.\n\n    Inarejesha:\n    int: Jumla ya thamani zote za factorial kutoka 1! hadi n!.\n\n    Mifano:\n    >>> sum_of_factorials_optimized(3)\n    9\n    >>> sum_of_factorials_optimized(5)\n    153\n    >>> sum_of_factorials_optimized(6)\n    873\n    \"\"\"",
      "tr": "def sum_of_factorials_optimized(n: int) -> int:\n    \"\"\"\n    1'den belirtilen bir tamsayı n'e kadar olan faktöriyel değerlerinin kümülatif toplamını hesaplayın.\n\n    Bu fonksiyon, faktöriyel hesaplamak için daha verimli bir yöntem kullanır ve\n    önceki faktöriyel sonucuna mevcut sayıyı iteratif olarak çarparak gereksiz\n    hesaplamalardan kaçınır. Daha sonra 1'den n'e kadar her sayının faktöriyelini toplar.\n\n    Argümanlar:\n    n (int): Faktöriyel toplamının hesaplanacağı aralığın üst sınırı.\n             n değeri 1 ile 50 arasında olmalıdır, her iki değer de dahil.\n\n    Döndürür:\n    int: 1!'den n!'e kadar olan tüm faktöriyel değerlerinin toplamı.\n\n    Örnekler:\n    >>> sum_of_factorials_optimized(3)\n    9\n    >>> sum_of_factorials_optimized(5)\n    153\n    >>> sum_of_factorials_optimized(6)\n    873\n    \"\"\"",
      "vi": "def sum_of_factorials_optimized(n: int) -> int:\n    \"\"\"\n    Tính tổng tích lũy của các giá trị giai thừa từ 1 đến một số nguyên n được chỉ định.\n\n    Hàm này sử dụng một phương pháp hiệu quả hơn để tính giai thừa bằng cách nhân \n    số hiện tại với kết quả giai thừa trước đó, do đó tránh được các tính toán dư thừa. \n    Sau đó, nó tích lũy giai thừa của mỗi số từ 1 đến n bao gồm cả n.\n\n    Tham số:\n    n (int): Giới hạn trên của phạm vi mà tổng giai thừa cần được tính toán.\n             Giá trị của n nên nằm trong khoảng từ 1 đến 50, bao gồm cả 1 và 50.\n\n    Trả về:\n    int: Tổng của tất cả các giá trị giai thừa từ 1! đến n!.\n\n    Ví dụ:\n    >>> sum_of_factorials_optimized(3)\n    9\n    >>> sum_of_factorials_optimized(5)\n    153\n    >>> sum_of_factorials_optimized(6)\n    873\n    \"\"\""
    },
    "prompt_bertscore": {
      "es": "0.9819709162046063",
      "arb": "0.9742495574026371",
      "sw": "0.9607704997456096",
      "tr": "0.9678030083861499",
      "vi": "0.960505328186928"
    },
    "canonical_solution": "    sum_factorials = 0\n    current_factorial = 1\n    for i in range(1, n + 1):\n        current_factorial *= i\n        sum_factorials += current_factorial\n    return sum_factorials",
    "instruction": {
      "en": "def sum_of_factorials_optimized(n: int) -> int:\n    sum_factorials = 0\n    current_factorial = 1\n    for i in range(1, n + 1):\n        current_factorial *= i\n        sum_factorials += current_factorial\n    return sum_factorials\n\nProvide a concise natural language description (docstring) of the Python code in English using at most 500 characters.",
      "es": "def sum_of_factorials_optimized(n: int) -> int:\n    sum_factorials = 0\n    current_factorial = 1\n    for i in range(1, n + 1):\n        current_factorial *= i\n        sum_factorials += current_factorial\n    return sum_factorials\n\nProporcione una descripción concisa en lenguaje natural (docstring) del código Python en español utilizando como máximo 500 caracteres.",
      "arb": "def sum_of_factorials_optimized(n: int) -> int:\n    sum_factorials = 0\n    current_factorial = 1\n    for i in range(1, n + 1):\n        current_factorial *= i\n        sum_factorials += current_factorial\n    return sum_factorials\n\nيرجى تقديم وصف موجز بلغة طبيعية (docstring) للشفرة البرمجية بلغة بايثون باللغة العربية الفصحى، بحيث لا يتجاوز 500 حرف.",
      "sw": "def sum_of_factorials_optimized(n: int) -> int:\n    sum_factorials = 0\n    current_factorial = 1\n    for i in range(1, n + 1):\n        current_factorial *= i\n        sum_factorials += current_factorial\n    return sum_factorials\n\nToa maelezo mafupi ya lugha ya asili (docstring) ya msimbo wa Python kwa Kiswahili kwa kutumia herufi zisizozidi 500.",
      "tr": "def sum_of_factorials_optimized(n: int) -> int:\n    sum_factorials = 0\n    current_factorial = 1\n    for i in range(1, n + 1):\n        current_factorial *= i\n        sum_factorials += current_factorial\n    return sum_factorials\n\nPython kodunun işlevini açıklayan kısa bir doğal dil açıklaması (docstring) sağlayın. Açıklama Türkçe olmalı ve en fazla 500 karakter kullanılmalıdır.",
      "vi": "def sum_of_factorials_optimized(n: int) -> int:\n    sum_factorials = 0\n    current_factorial = 1\n    for i in range(1, n + 1):\n        current_factorial *= i\n        sum_factorials += current_factorial\n    return sum_factorials\n\nCung cấp mô tả ngắn gọn bằng ngôn ngữ tự nhiên (docstring) cho mã Python bằng tiếng Việt với tối đa 500 ký tự."
    },
    "instruction_bertscore": {
      "es": "0.9687387561112052",
      "arb": "0.906469919330197",
      "sw": "0.914896018724078",
      "tr": "0.8760401422164142",
      "vi": "0.9016493586128613"
    },
    "level": "",
    "test": "def test_sum_of_factorials_optimized():\n    assert sum_of_factorials_optimized(1) == 1, \"Test case 1 failed: sum_of_factorials_optimized(1) should be 1.\"\n    assert sum_of_factorials_optimized(3) == 9, \"Test case 2 failed: sum_of_factorials_optimized(3) should be 9.\"\n    assert sum_of_factorials_optimized(4) == 33, \"Test case 3 failed: sum_of_factorials_optimized(4) should be 33.\"\n    assert sum_of_factorials_optimized(5) == 153, \"Test case 4 failed: sum_of_factorials_optimized(5) should be 153.\"\n    assert sum_of_factorials_optimized(6) == 873, \"Test case 5 failed: sum_of_factorials_optimized(6) should be 873.\"\n    assert sum_of_factorials_optimized(10) == 4037913, \"Test case 6 failed: sum_of_factorials_optimized(10) should be 4037913.\"\n    print(\"All test cases passed.\")\n\n# Call the test function to run the test cases\ntest_sum_of_factorials_optimized()",
    "entry_point": "sum_of_factorials_optimized",
    "signature": "def sum_of_factorials_optimized(n: int) -> int:",
    "docstring": {
      "en": "Compute the cumulative sum of factorial values from 1 up to a specified integer n.\n\nThis function employs a more efficient method to calculate factorials by iteratively\nmultiplying the current number to the previous factorial result, thus avoiding redundant\ncalculations. It then accumulates the factorial of each number from 1 to n inclusively.\n\nArgs:\nn (int): The upper limit of the range for which the factorial sum is to be calculated.\nThe value of n should be in the range of 1 to 50, inclusive.\n\nReturns:\nint: The sum of all factorial values from 1! to n!.\n\nExamples:\n>>> sum_of_factorials_optimized(3)\n9\n>>> sum_of_factorials_optimized(5)\n153\n>>> sum_of_factorials_optimized(6)\n873",
      "es": "Calcular la suma acumulativa de los valores factoriales desde 1 hasta un entero especificado n.\n\nEsta función emplea un método más eficiente para calcular factoriales multiplicando iterativamente\nel número actual por el resultado factorial anterior, evitando así cálculos redundantes. Luego acumula el factorial de cada número desde 1 hasta n inclusive.\n\nArgumentos:\nn (int): El límite superior del rango para el cual se va a calcular la suma de factoriales.\nEl valor de n debe estar en el rango de 1 a 50, inclusive.\n\nDevuelve:\nint: La suma de todos los valores factoriales desde 1! hasta n!.\n\nEjemplos:\n>>> sum_of_factorials_optimized(3)\n9\n>>> sum_of_factorials_optimized(5)\n153\n>>> sum_of_factorials_optimized(6)\n873",
      "arb": "احسب المجموع التراكمي لقيم المضاعفات من 1 حتى عدد صحيح محدد n.\n\nتستخدم هذه الدالة طريقة أكثر كفاءة لحساب المضاعفات عن طريق ضرب العدد الحالي في نتيجة المضاعف السابقة بشكل تكراري، مما يتجنب الحسابات الزائدة. ثم تجمع مضاعف كل عدد من 1 إلى n بشكل شامل.\n\nالمعطيات:\nn (int): الحد الأعلى للنطاق الذي سيتم حساب مجموع المضاعفات له. يجب أن تكون قيمة n في النطاق من 1 إلى 50، شاملًا.\n\nالقيم المعادة:\nint: مجموع جميع قيم المضاعفات من 1! إلى n!.\n\nأمثلة:\n>>> sum_of_factorials_optimized(3)\n9\n>>> sum_of_factorials_optimized(5)\n153\n>>> sum_of_factorials_optimized(6)\n873",
      "sw": "Hesabu jumla ya thamani za factorial kutoka 1 hadi n iliyobainishwa.\n\nKazi hii hutumia njia bora zaidi ya kuhesabu factorials kwa kuzidisha iteratively\nnambari ya sasa na matokeo ya factorial ya awali, hivyo kuepuka mahesabu ya mara kwa mara.\nKisha hujumlisha factorial ya kila nambari kutoka 1 hadi n kwa ujumla.\n\nHoja:\nn (int): Kikomo cha juu cha safu ambayo jumla ya factorial inapaswa kuhesabiwa.\nThamani ya n inapaswa kuwa katika safu ya 1 hadi 50, kwa ujumla.\n\nInarejesha:\nint: Jumla ya thamani zote za factorial kutoka 1! hadi n!.\n\nMifano:\n>>> sum_of_factorials_optimized(3)\n9\n>>> sum_of_factorials_optimized(5)\n153\n>>> sum_of_factorials_optimized(6)\n873",
      "tr": "1'den belirtilen bir tamsayı n'ye kadar olan faktöriyel değerlerinin kümülatif toplamını hesaplayın.\n\nBu fonksiyon, faktöriyel hesaplamalarını daha verimli bir yöntemle gerçekleştirir; önceki faktöriyel sonucuna mevcut sayıyı çarparak yinelemeli bir şekilde hesaplar ve böylece gereksiz hesaplamalardan kaçınılır. Daha sonra 1'den n'ye kadar olan her sayının faktöriyelini toplar.\n\nArgümanlar:\nn (int): Faktöriyel toplamının hesaplanacağı aralığın üst sınırı.\nn'nin değeri 1 ile 50 arasında, her iki değer de dahil olmak üzere, olmalıdır.\n\nDöndürür:\nint: 1!'den n!'ye kadar olan tüm faktöriyel değerlerinin toplamı.\n\nÖrnekler:\n>>> sum_of_factorials_optimized(3)\n9\n>>> sum_of_factorials_optimized(5)\n153\n>>> sum_of_factorials_optimized(6)\n873",
      "vi": "Tính tổng tích lũy của các giá trị giai thừa từ 1 đến một số nguyên n được chỉ định.\n\nHàm này sử dụng một phương pháp hiệu quả hơn để tính giai thừa bằng cách nhân liên tục số hiện tại với kết quả giai thừa trước đó, do đó tránh được các tính toán dư thừa. Sau đó, nó tích lũy giai thừa của mỗi số từ 1 đến n bao gồm cả n.\n\nTham số:\nn (int): Giới hạn trên của phạm vi mà tổng giai thừa sẽ được tính toán. Giá trị của n nên nằm trong khoảng từ 1 đến 50, bao gồm cả 1 và 50.\n\nTrả về:\nint: Tổng của tất cả các giá trị giai thừa từ 1! đến n!.\n\nVí dụ:\n>>> sum_of_factorials_optimized(3)\n9\n>>> sum_of_factorials_optimized(5)\n153\n>>> sum_of_factorials_optimized(6)\n873"
    },
    "docstring_bertscore": {
      "es": "0.9783486925760541",
      "arb": "0.9617731859090737",
      "sw": "0.9513881936974267",
      "tr": "0.9486512656771469",
      "vi": "0.9589782578175318"
    }
  },
  {
    "task_id": "Python/11",
    "prompt": {
      "en": "def cantor_numbering(N: int) -> str:\n    \"\"\"\n    Determines the numerator and denominator of the N-th term in the Cantor table.\n\n    Args:\n    - N (int): The position in the Cantor table to find the corresponding fraction for.\n\n    Returns:\n    - str: A string representation of the fraction at the N-th position in the Cantor table.\n    \"\"\"",
      "es": "def cantor_numbering(N: int) -> str:\n    \"\"\"\n    Determina el numerador y el denominador del término N-ésimo en la tabla de Cantor.\n\n    Argumentos:\n    - N (int): La posición en la tabla de Cantor para encontrar la fracción correspondiente.\n\n    Devuelve:\n    - str: Una representación en cadena de la fracción en la posición N-ésima en la tabla de Cantor.\n    \"\"\"",
      "arb": "def cantor_numbering(N: int) -> str:\n    \"\"\"\n    يحدد البسط والمقام للحد N في جدول كانتور.\n\n    يعيدالحجج:\n    - N (int): الموضع في جدول كانتور للعثور على الكسر المقابل له.\n\n    يعيد:\n    - str: تمثيل نصي للكسر في الموضع N في جدول كانتور.\n    \"\"\"",
      "sw": "def cantor_numbering(N: int) -> str:\n    \"\"\"\n    Huamua kigezo na kipatanishi cha neno la N katika jedwali la Cantor.\n\n    Hoja:\n    - N (int): Nafasi katika jedwali la Cantor ili kupata sehemu inayolingana nayo.\n\n    Inarejesha:\n    - str: Uwiano wa sehemu katika nafasi ya N katika jedwali la Cantor.\n    \"\"\"",
      "tr": "def cantor_numbering(N: int) -> str:\n    \"\"\"\n    Cantor tablosundaki N'inci terimin pay ve paydasını belirler.\n\n    Argümanlar:\n    - N (int): Cantor tablosundaki karşılık gelen kesiri bulmak için pozisyon.\n\n    Döndürür:\n    - str: Cantor tablosundaki N'inci pozisyondaki kesirin string gösterimi.\n    \"\"\"",
      "vi": "def cantor_numbering(N: int) -> str:\n    \"\"\"\n    Xác định tử số và mẫu số của số hạng thứ N trong bảng Cantor.\n\n    Tham số:\n    - N (int): Vị trí trong bảng Cantor để tìm phân số tương ứng.\n\n    Trả về:\n    - str: Một chuỗi biểu diễn phân số tại vị trí thứ N trong bảng Cantor.\n    \"\"\""
    },
    "prompt_bertscore": {
      "es": "0.9720099998564687",
      "arb": "0.9644628398986671",
      "sw": "0.9271904447886135",
      "tr": "0.9639386543231161",
      "vi": "0.9540875805756908"
    },
    "canonical_solution": "    # Determine the diagonal line (or the sum of indices) for the N-th term\n    line = 1\n    while N > line:\n        N -= line\n        line += 1\n\n    # Determine the position within the diagonal line\n    # If the line number is odd, we go up, otherwise we go down\n    if line % 2 == 0:\n        numerator = N\n        denominator = line - N + 1\n    else:\n        numerator = line - N + 1\n        denominator = N\n\n    return f\"{numerator}/{denominator}\"",
    "instruction": {
      "en": "def cantor_numbering(N: int) -> str:\n    # Determine the diagonal line (or the sum of indices) for the N-th term\n    line = 1\n    while N > line:\n        N -= line\n        line += 1\n\n    # Determine the position within the diagonal line\n    # If the line number is odd, we go up, otherwise we go down\n    if line % 2 == 0:\n        numerator = N\n        denominator = line - N + 1\n    else:\n        numerator = line - N + 1\n        denominator = N\n\n    return f\"{numerator}/{denominator}\"\n\nProvide a concise natural language description (docstring) of the Python code in English using at most 500 characters.",
      "es": "def cantor_numbering(N: int) -> str:\n    # Determine the diagonal line (or the sum of indices) for the N-th term\n    line = 1\n    while N > line:\n        N -= line\n        line += 1\n\n    # Determine the position within the diagonal line\n    # If the line number is odd, we go up, otherwise we go down\n    if line % 2 == 0:\n        numerator = N\n        denominator = line - N + 1\n    else:\n        numerator = line - N + 1\n        denominator = N\n\n    return f\"{numerator}/{denominator}\"\n\nProporciona una descripción concisa en lenguaje natural (docstring) del código Python en español utilizando como máximo 500 caracteres.",
      "arb": "def cantor_numbering(N: int) -> str:\n    # Determine the diagonal line (or the sum of indices) for the N-th term\n    line = 1\n    while N > line:\n        N -= line\n        line += 1\n\n    # Determine the position within the diagonal line\n    # If the line number is odd, we go up, otherwise we go down\n    if line % 2 == 0:\n        numerator = N\n        denominator = line - N + 1\n    else:\n        numerator = line - N + 1\n        denominator = N\n\n    return f\"{numerator}/{denominator}\"\n\nيرجى تقديم وصف موجز بلغة طبيعية (docstring) للكود البرمجي بلغة بايثون باللغة العربية الفصحى، بحيث لا يتجاوز 500 حرف.",
      "sw": "def cantor_numbering(N: int) -> str:\n    # Determine the diagonal line (or the sum of indices) for the N-th term\n    line = 1\n    while N > line:\n        N -= line\n        line += 1\n\n    # Determine the position within the diagonal line\n    # If the line number is odd, we go up, otherwise we go down\n    if line % 2 == 0:\n        numerator = N\n        denominator = line - N + 1\n    else:\n        numerator = line - N + 1\n        denominator = N\n\n    return f\"{numerator}/{denominator}\"\n\nToa maelezo mafupi ya lugha ya asili (docstring) ya msimbo wa Python kwa Kiswahili kwa kutumia herufi zisizozidi 500.",
      "tr": "def cantor_numbering(N: int) -> str:\n    # Determine the diagonal line (or the sum of indices) for the N-th term\n    line = 1\n    while N > line:\n        N -= line\n        line += 1\n\n    # Determine the position within the diagonal line\n    # If the line number is odd, we go up, otherwise we go down\n    if line % 2 == 0:\n        numerator = N\n        denominator = line - N + 1\n    else:\n        numerator = line - N + 1\n        denominator = N\n\n    return f\"{numerator}/{denominator}\"\n\nPython kodunun işlevselliğini açıklayan kısa bir doğal dil tanımı (docstring) sağlayın. Açıklama, en fazla 500 karakter kullanılarak Türkçe olarak yazılmalıdır.",
      "vi": "def cantor_numbering(N: int) -> str:\n    # Determine the diagonal line (or the sum of indices) for the N-th term\n    line = 1\n    while N > line:\n        N -= line\n        line += 1\n\n    # Determine the position within the diagonal line\n    # If the line number is odd, we go up, otherwise we go down\n    if line % 2 == 0:\n        numerator = N\n        denominator = line - N + 1\n    else:\n        numerator = line - N + 1\n        denominator = N\n\n    return f\"{numerator}/{denominator}\"\n\nCung cấp mô tả ngắn gọn bằng ngôn ngữ tự nhiên (docstring) cho mã Python bằng tiếng Việt, sử dụng tối đa 500 ký tự."
    },
    "instruction_bertscore": {
      "es": "0.9687387561112052",
      "arb": "0.906469919330197",
      "sw": "0.914896018724078",
      "tr": "0.8683191806752071",
      "vi": "0.9069722555638342"
    },
    "level": "",
    "test": "def test_cantor_numbering():\n    # Test case 1: N = 1, the first element, should be \"1/1\"\n    assert cantor_numbering(1)==\"1/1\"\n\n    # Test case 2: N = 2, the second element, should be \"1/2\"\n    assert cantor_numbering(2)==\"1/2\"\n\n    # Test case 3: N = 6, the sixth element, should be \"1/3\"\n    assert cantor_numbering(6)==\"1/3\"\n\n    # Corrected test case: N = 7, the seventh element, should be \"1/4\"\n    assert cantor_numbering(7) == \"1/4\"\n\n    # Additional test case: N = 8, the eighth element, should be \"2/3\"\n    assert cantor_numbering(8) == \"2/3\"\n\n\ntest_cantor_numbering()",
    "entry_point": "cantor_numbering",
    "signature": "def cantor_numbering(N: int) -> str:",
    "docstring": {
      "en": "Determines the numerator and denominator of the N-th term in the Cantor table.\n\nArgs:\n- N (int): The position in the Cantor table to find the corresponding fraction for.\n\nReturns:\n- str: A string representation of the fraction at the N-th position in the Cantor table.",
      "es": "Determina el numerador y el denominador del término N-ésimo en la tabla de Cantor.\n\nArgumentos:\n- N (int): La posición en la tabla de Cantor para encontrar la fracción correspondiente.\n\nDevuelve:\n- str: Una representación en cadena de la fracción en la posición N-ésima en la tabla de Cantor.",
      "arb": "يحدد البسط والمقام للحد N في جدول كانتور.\n\nالمعطيات:\n- N (int): الموضع في جدول كانتور للعثور على الكسر المقابل له.\n\nالقيم المعادة:\n- str: تمثيل نصي للكسر في الموضع N في جدول كانتور.",
      "sw": "Inabainisha numerator na denominator ya neno la N katika jedwali la Cantor.\n\nHoja:\n- N (int): Nafasi katika jedwali la Cantor kupata sehemu inayolingana.\n\nRudisha:\n- str: Uwakilishi wa kamba wa sehemu katika nafasi ya N katika jedwali la Cantor.",
      "tr": "N'inci terimin Cantor tablosundaki pay ve paydasını belirler.\n\nArgümanlar:\n- N (int): Cantor tablosundaki karşılık gelen kesiri bulmak için pozisyon.\n\nDöndürür:\n- str: Cantor tablosundaki N'inci pozisyondaki kesirin string gösterimi.",
      "vi": "Xác định tử số và mẫu số của số hạng thứ N trong bảng Cantor.\n\nTham số:\n- N (int): Vị trí trong bảng Cantor để tìm phân số tương ứng.\n\nTrả về:\n- str: Một chuỗi biểu diễn phân số tại vị trí thứ N trong bảng Cantor."
    },
    "docstring_bertscore": {
      "es": "0.9525487910138135",
      "arb": "0.9190271333888416",
      "sw": "0.8855326881260716",
      "tr": "0.9675126107690768",
      "vi": "0.9442543835625586"
    }
  },
  {
    "task_id": "Python/12",
    "prompt": {
      "en": "def max_product(num_str: str, N: int, K: int) -> int:\n    \"\"\"\n    Function name: max_product\n    Arguments:\n    num_str (str): A string representing the number string.\n    N (int): An integer representing the length of the number string.\n    K (int): An integer representing the number of multiplication signs to insert.\n    Return type: int (The function returns the maximum product that can be obtained by inserting Kmultiplication signs into the number string.)\n    \"\"\"",
      "es": "def max_product(num_str: str, N: int, K: int) -> int:\n    \"\"\"\n    Nombre de la función: max_product\n    Argumentos:\n    num_str (str): Una cadena que representa la cadena de números.\n    N (int): Un entero que representa la longitud de la cadena de números.\n    K (int): Un entero que representa el número de signos de multiplicación a insertar.\n    Tipo de retorno: int (La función devuelve el producto máximo que se puede obtener insertando K signos de multiplicación en la cadena de números.)\n    \"\"\"",
      "arb": "def max_product(num_str: str, N: int, K: int) -> int:\n    \"\"\"\n    اسم الدالة: max_product\n    الوسائط:\n    num_str (str): سلسلة تمثل سلسلة الأرقام.\n    N (int): عدد صحيح يمثل طول سلسلة الأرقام.\n    K (int): عدد صحيح يمثل عدد علامات الضرب التي سيتم إدراجها.\n    نوع القيمة المعادة: int (تعيد الدالة أكبر حاصل ضرب يمكن الحصول عليه بإدراج K علامات ضرب في سلسلة الأرقام.)\n    \"\"\"",
      "sw": "def max_product(num_str: str, N: int, K: int) -> int:\n    \"\"\"\n    Jina la kazi: max_product\n    Hoja:\n    num_str (str): Mfuatano wa herufi unaowakilisha mfuatano wa nambari.\n    N (int): Nambari nzima inayowakilisha urefu wa mfuatano wa nambari.\n    K (int): Nambari nzima inayowakilisha idadi ya alama za kuzidisha kuingiza.\n    Aina ya kurudi: int (Kazi inarudisha bidhaa kubwa zaidi inayoweza kupatikana kwa kuingiza alama za kuzidisha K katika mfuatano wa nambari.)\n    \"\"\"",
      "tr": "def max_product(num_str: str, N: int, K: int) -> int:\n    \"\"\"\n    Fonksiyon adı: max_product\n    Argümanlar:\n    num_str (str): Sayı dizgisini temsil eden bir dizgi.\n    N (int): Sayı dizgisinin uzunluğunu temsil eden bir tamsayı.\n    K (int): Eklenecek çarpma işareti sayısını temsil eden bir tamsayı.\n    Dönüş tipi: int (Fonksiyon, sayı dizgisine K çarpma işareti ekleyerek elde edilebilecek maksimum çarpımı döndürür.)\n    \"\"\"",
      "vi": "def max_product(num_str: str, N: int, K: int) -> int:\n    \"\"\"\n    Tên hàm: max_product\n    Tham số:\n    num_str (str): Một chuỗi đại diện cho chuỗi số.\n    N (int): Một số nguyên đại diện cho độ dài của chuỗi số.\n    K (int): Một số nguyên đại diện cho số dấu nhân cần chèn vào.\n    Kiểu trả về: int (Hàm trả về tích lớn nhất có thể đạt được bằng cách chèn K dấu nhân vào chuỗi số.)\n    \"\"\""
    },
    "prompt_bertscore": {
      "es": "0.9744233589860426",
      "arb": "0.9469845581498831",
      "sw": "0.9327123693813834",
      "tr": "0.9621205904455037",
      "vi": "0.9439933832418788"
    },
    "canonical_solution": "    # Convert the string to a list of integers for easier manipulation\n    digits = [int(num_str[i]) for i in range(N)]\n    # Initialize the dp table with 0 values\n    dp = [[0] * (K+1) for _ in range(N+1)]\n\n    # Base case: dp[i][0] = integer formed by the first i digits\n    for i in range(1, N+1):\n        dp[i][0] = dp[i-1][0] * 10 + digits[i-1]\n\n    # Fill the dp table\n    for i in range(1, N+1):\n        for k in range(1, min(i, K)+1):\n            for j in range(k, i+1): # Position to place the last multiplication sign\n                # Update dp[i][k] with the maximum product\n                dp[i][k] = max(dp[i][k], dp[j-1][k-1] * int(num_str[j-1:i]))\n\n    # Return the maximum product after using K multiplication signs\n    return dp[N][K]",
    "instruction": {
      "en": "def max_product(num_str: str, N: int, K: int) -> int:\n    # Convert the string to a list of integers for easier manipulation\n    digits = [int(num_str[i]) for i in range(N)]\n    # Initialize the dp table with 0 values\n    dp = [[0] * (K+1) for _ in range(N+1)]\n\n    # Base case: dp[i][0] = integer formed by the first i digits\n    for i in range(1, N+1):\n        dp[i][0] = dp[i-1][0] * 10 + digits[i-1]\n\n    # Fill the dp table\n    for i in range(1, N+1):\n        for k in range(1, min(i, K)+1):\n            for j in range(k, i+1): # Position to place the last multiplication sign\n                # Update dp[i][k] with the maximum product\n                dp[i][k] = max(dp[i][k], dp[j-1][k-1] * int(num_str[j-1:i]))\n\n    # Return the maximum product after using K multiplication signs\n    return dp[N][K]\n\nProvide a concise natural language description (docstring) of the Python code in English using at most 500 characters.",
      "es": "def max_product(num_str: str, N: int, K: int) -> int:\n    # Convert the string to a list of integers for easier manipulation\n    digits = [int(num_str[i]) for i in range(N)]\n    # Initialize the dp table with 0 values\n    dp = [[0] * (K+1) for _ in range(N+1)]\n\n    # Base case: dp[i][0] = integer formed by the first i digits\n    for i in range(1, N+1):\n        dp[i][0] = dp[i-1][0] * 10 + digits[i-1]\n\n    # Fill the dp table\n    for i in range(1, N+1):\n        for k in range(1, min(i, K)+1):\n            for j in range(k, i+1): # Position to place the last multiplication sign\n                # Update dp[i][k] with the maximum product\n                dp[i][k] = max(dp[i][k], dp[j-1][k-1] * int(num_str[j-1:i]))\n\n    # Return the maximum product after using K multiplication signs\n    return dp[N][K]\n\nProporciona una descripción concisa en lenguaje natural (docstring) del código Python en español utilizando como máximo 500 caracteres.",
      "arb": "def max_product(num_str: str, N: int, K: int) -> int:\n    # Convert the string to a list of integers for easier manipulation\n    digits = [int(num_str[i]) for i in range(N)]\n    # Initialize the dp table with 0 values\n    dp = [[0] * (K+1) for _ in range(N+1)]\n\n    # Base case: dp[i][0] = integer formed by the first i digits\n    for i in range(1, N+1):\n        dp[i][0] = dp[i-1][0] * 10 + digits[i-1]\n\n    # Fill the dp table\n    for i in range(1, N+1):\n        for k in range(1, min(i, K)+1):\n            for j in range(k, i+1): # Position to place the last multiplication sign\n                # Update dp[i][k] with the maximum product\n                dp[i][k] = max(dp[i][k], dp[j-1][k-1] * int(num_str[j-1:i]))\n\n    # Return the maximum product after using K multiplication signs\n    return dp[N][K]\n\nيرجى تقديم وصف موجز بلغة طبيعية (docstring) للكود البرمجي المكتوب بلغة بايثون باللغة العربية الفصحى، بحيث لا يتجاوز 500 حرف.",
      "sw": "def max_product(num_str: str, N: int, K: int) -> int:\n    # Convert the string to a list of integers for easier manipulation\n    digits = [int(num_str[i]) for i in range(N)]\n    # Initialize the dp table with 0 values\n    dp = [[0] * (K+1) for _ in range(N+1)]\n\n    # Base case: dp[i][0] = integer formed by the first i digits\n    for i in range(1, N+1):\n        dp[i][0] = dp[i-1][0] * 10 + digits[i-1]\n\n    # Fill the dp table\n    for i in range(1, N+1):\n        for k in range(1, min(i, K)+1):\n            for j in range(k, i+1): # Position to place the last multiplication sign\n                # Update dp[i][k] with the maximum product\n                dp[i][k] = max(dp[i][k], dp[j-1][k-1] * int(num_str[j-1:i]))\n\n    # Return the maximum product after using K multiplication signs\n    return dp[N][K]\n\nToa maelezo mafupi ya lugha ya asili (docstring) ya msimbo wa Python kwa Kiswahili kwa kutumia herufi zisizozidi 500.",
      "tr": "def max_product(num_str: str, N: int, K: int) -> int:\n    # Convert the string to a list of integers for easier manipulation\n    digits = [int(num_str[i]) for i in range(N)]\n    # Initialize the dp table with 0 values\n    dp = [[0] * (K+1) for _ in range(N+1)]\n\n    # Base case: dp[i][0] = integer formed by the first i digits\n    for i in range(1, N+1):\n        dp[i][0] = dp[i-1][0] * 10 + digits[i-1]\n\n    # Fill the dp table\n    for i in range(1, N+1):\n        for k in range(1, min(i, K)+1):\n            for j in range(k, i+1): # Position to place the last multiplication sign\n                # Update dp[i][k] with the maximum product\n                dp[i][k] = max(dp[i][k], dp[j-1][k-1] * int(num_str[j-1:i]))\n\n    # Return the maximum product after using K multiplication signs\n    return dp[N][K]\n\nVerilen Python kodunun işlevini açıklayan, en fazla 500 karakter uzunluğunda özlü bir doğal dil açıklaması (docstring) sağlayın.",
      "vi": "def max_product(num_str: str, N: int, K: int) -> int:\n    # Convert the string to a list of integers for easier manipulation\n    digits = [int(num_str[i]) for i in range(N)]\n    # Initialize the dp table with 0 values\n    dp = [[0] * (K+1) for _ in range(N+1)]\n\n    # Base case: dp[i][0] = integer formed by the first i digits\n    for i in range(1, N+1):\n        dp[i][0] = dp[i-1][0] * 10 + digits[i-1]\n\n    # Fill the dp table\n    for i in range(1, N+1):\n        for k in range(1, min(i, K)+1):\n            for j in range(k, i+1): # Position to place the last multiplication sign\n                # Update dp[i][k] with the maximum product\n                dp[i][k] = max(dp[i][k], dp[j-1][k-1] * int(num_str[j-1:i]))\n\n    # Return the maximum product after using K multiplication signs\n    return dp[N][K]\n\nCung cấp mô tả ngắn gọn bằng ngôn ngữ tự nhiên (docstring) cho mã Python bằng tiếng Việt, sử dụng tối đa 500 ký tự."
    },
    "instruction_bertscore": {
      "es": "0.9687387561112052",
      "arb": "0.906469919330197",
      "sw": "0.914896018724078",
      "tr": "0.8508820154152974",
      "vi": "0.9506606106116958"
    },
    "level": "",
    "test": "def test_max_product():\n    # Test case 1\n    num_str1 = \"123\"\n    N1 = 3\n    K1 = 1\n    expected_result1 = 36  # Corrected expected result: 1*23 = 23 or 12*3 = 36, max is 36\n    assert max_product(num_str1, N1,\n                       K1) == expected_result1, f\"Test case 1 failed. Expected {expected_result1}, got {max_product(num_str1, N1, K1)}\"\n\n    # Test case 2\n    num_str2 = \"1234\"\n    N2 = 4\n    K2 = 2\n    expected_result2 = 144  # Corrected expected result: 1*2*34 = 68 or 12*3*4 = 144, max is 144\n    assert max_product(num_str2, N2,\n                       K2) == expected_result2, f\"Test case 2 failed. Expected {expected_result2}, got {max_product(num_str2, N2, K2)}\"\n\n    # Test case 3\n    num_str3 = \"051\"\n    N3 = 3\n    K3 = 1\n    expected_result3 = 5  # 0*51 = 0 or 05*1 = 5, max is 5\n    assert max_product(num_str3, N3,\n                       K3) == expected_result3, f\"Test case 3 failed. Expected {expected_result3}, got {max_product(num_str3, N3, K3)}\"\n\n    # If no assertion is raised, all test cases passed\n    print(\"All test cases passed!\")\ntest_max_product()",
    "entry_point": "max_product",
    "signature": "def max_product(num_str: str, N: int, K: int) -> int:",
    "docstring": {
      "en": "Function name: max_product\n    Arguments:\n    num_str (str): A string representing the number string.\n    N (int): An integer representing the length of the number string.\n    K (int): An integer representing the number of multiplication signs to insert.\n    Return type: int (The function returns the maximum product that can be obtained by inserting Kmultiplication signs into the number string.)",
      "es": "Nombre de la función: max_product\n    Argumentos:\n    num_str (str): Una cadena que representa la cadena de números.\n    N (int): Un entero que representa la longitud de la cadena de números.\n    K (int): Un entero que representa el número de signos de multiplicación a insertar.\n    Tipo de retorno: int (La función devuelve el producto máximo que se puede obtener insertando K signos de multiplicación en la cadena de números.)",
      "arb": "اسم الدالة: max_product\n    الوسائط:\n    num_str (str): سلسلة تمثل سلسلة الأرقام.\n    N (int): عدد صحيح يمثل طول سلسلة الأرقام.\n    K (int): عدد صحيح يمثل عدد علامات الضرب التي يجب إدراجها.\n    نوع القيمة المعادة: int (تعيد الدالة أكبر حاصل ضرب يمكن الحصول عليه عن طريق إدراج K علامات ضرب في سلسلة الأرقام.)",
      "sw": "Jina la kazi: max_product\n    Hoja:\n    num_str (str): Kamba inayoashiria mfuatano wa namba.\n    N (int): Nambari kamili inayowakilisha urefu wa mfuatano wa namba.\n    K (int): Nambari kamili inayowakilisha idadi ya alama za kuzidisha za kuingiza.\n    Aina ya kurudi: int (Kazi inarudisha bidhaa kubwa zaidi inayoweza kupatikana kwa kuingiza alama za kuzidisha K kwenye mfuatano wa namba.)",
      "tr": "Fonksiyon adı: max_product\n    Argümanlar:\n    num_str (str): Sayı dizisini temsil eden bir dize.\n    N (int): Sayı dizisinin uzunluğunu temsil eden bir tamsayı.\n    K (int): Eklenecek çarpma işaretlerinin sayısını temsil eden bir tamsayı.\n    Dönüş tipi: int (Fonksiyon, sayı dizisine K çarpma işareti ekleyerek elde edilebilecek maksimum çarpımı döndürür.)",
      "vi": "Tên hàm: max_product\n    Tham số:\n    num_str (str): Một chuỗi đại diện cho chuỗi số.\n    N (int): Một số nguyên đại diện cho độ dài của chuỗi số.\n    K (int): Một số nguyên đại diện cho số dấu nhân cần chèn.\n    Kiểu trả về: int (Hàm trả về tích lớn nhất có thể đạt được bằng cách chèn K dấu nhân vào chuỗi số.)"
    },
    "docstring_bertscore": {
      "es": "0.9526665788297671",
      "arb": "0.9316069913109242",
      "sw": "0.9337422679070493",
      "tr": "0.9368623539323453",
      "vi": "0.9439790818544442"
    }
  },
  {
    "task_id": "Python/13",
    "prompt": {
      "en": "from typing import List\ndef calculate_scholarship(grades: List[int], leader: str, west: str, papers: int) -> int:\n    \"\"\"\n    Calculate the total scholarship amount for a student based on academic and extracurricular achievements.\n\n    The function uses a set of conditions to determine the total amount of scholarship money a student is entitled to.\n    Scholarships are awarded based on academic grades, leadership roles, regional background, and research contributions.\n\n    Parameters:\n    grades (list of int): A two-element list containing the student's academic grades [end of term average, class evaluation].\n    leader (str): A string ('Y' or 'N') indicating if the student is a class leader.\n    west (str): A string ('Y' or 'N') indicating if the student is from a western province.\n    papers (int): An integer representing the number of research papers published by the student.\n\n    Returns:\n    int: The total scholarship amount the student is eligible for.\n\n    Examples:\n    >>> calculate_scholarship([87, 82], 'Y', 'N', 0)\n    4850\n\n    >>> calculate_scholarship([88, 78], 'N', 'Y', 1)\n    9000\n\n    The first example calculates a scholarship for a student with an average grade of 87, an evaluation grade of 82,\n    who is a class leader ('Y'), not from the western province ('N'), and with no published papers (0). This student\n    would receive a total of 4850 units of currency.\n\n    In the second example, the student has an average grade of 88, an evaluation grade of 78, is not a class leader ('N'),\n    is from the western province ('Y'), and has published 1 paper. This student would receive a total of 9000 units of currency.\n    \"\"\"",
      "es": "from typing import List\ndef calculate_scholarship(grades: List[int], leader: str, west: str, papers: int) -> int:\n    \"\"\"\n    Calcular el monto total de la beca para un estudiante basado en logros académicos y extracurriculares.\n\n    La función utiliza un conjunto de condiciones para determinar el monto total de dinero de beca al que un estudiante tiene derecho.\n    Las becas se otorgan en función de las calificaciones académicas, roles de liderazgo, origen regional y contribuciones de investigación.\n\n    Parámetros:\n    grades (list of int): Una lista de dos elementos que contiene las calificaciones académicas del estudiante [promedio de fin de curso, evaluación de clase].\n    leader (str): Una cadena ('Y' o 'N') que indica si el estudiante es líder de clase.\n    west (str): Una cadena ('Y' o 'N') que indica si el estudiante es de una provincia occidental.\n    papers (int): Un entero que representa el número de artículos de investigación publicados por el estudiante.\n\n    Devuelve:\n    int: El monto total de la beca para el que el estudiante es elegible.\n\n    Ejemplos:\n    >>> calculate_scholarship([87, 82], 'Y', 'N', 0)\n    4850\n\n    >>> calculate_scholarship([88, 78], 'N', 'Y', 1)\n    9000\n\n    El primer ejemplo calcula una beca para un estudiante con una calificación promedio de 87, una calificación de evaluación de 82,\n    que es líder de clase ('Y'), no es de la provincia occidental ('N'), y sin artículos publicados (0). Este estudiante\n    recibiría un total de 4850 unidades de moneda.\n\n    En el segundo ejemplo, el estudiante tiene una calificación promedio de 88, una calificación de evaluación de 78, no es líder de clase ('N'),\n    es de la provincia occidental ('Y'), y ha publicado 1 artículo. Este estudiante recibiría un total de 9000 unidades de moneda.\n    \"\"\"",
      "arb": "from typing import List\ndef calculate_scholarship(grades: List[int], leader: str, west: str, papers: int) -> int:\n    \"\"\"\n    حساب إجمالي مبلغ المنحة الدراسية لطالب بناءً على الإنجازات الأكاديمية واللامنهجية.\n\n    تستخدم الدالة مجموعة من الشروط لتحديد إجمالي مبلغ المنحة الدراسية الذي يحق للطالب الحصول عليه.\n    تُمنح المنح الدراسية بناءً على الدرجات الأكاديمية، الأدوار القيادية، الخلفية الإقليمية، والمساهمات البحثية.\n\n    المعاملات:\n    grades (list of int): قائمة تحتوي على عنصرين تمثل الدرجات الأكاديمية للطالب [متوسط نهاية الفصل، تقييم الصف].\n    leader (str): سلسلة ('Y' أو 'N') تشير إلى ما إذا كان الطالب قائد الصف.\n    west (str): سلسلة ('Y' أو 'N') تشير إلى ما إذا كان الطالب من مقاطعة غربية.\n    papers (int): عدد صحيح يمثل عدد الأوراق البحثية المنشورة من قبل الطالب.\n\n    يعيد:\n    int: إجمالي مبلغ المنحة الدراسية الذي يحق للطالب الحصول عليه.\n\n    امثله:\n    >>> calculate_scholarship([87, 82], 'Y', 'N', 0)\n    4850\n\n    >>> calculate_scholarship([88, 78], 'N', 'Y', 1)\n    9000\n\n    المثال الأول يحسب منحة دراسية لطالب لديه متوسط درجات 87، ودرجة تقييم 82،\n    وهو قائد الصف ('Y')، وليس من المقاطعة الغربية ('N')، وليس لديه أوراق منشورة (0). سيحصل هذا الطالب\n    على إجمالي 4850 وحدة من العملة.\n\n    في المثال الثاني، الطالب لديه متوسط درجات 88، ودرجة تقييم 78، ليس قائد الصف ('N')،\n    وهو من المقاطعة الغربية ('Y')، ولديه ورقة بحثية منشورة واحدة. سيحصل هذا الطالب على إجمالي 9000 وحدة من العملة.\n    \"\"\"",
      "sw": "from typing import List\ndef calculate_scholarship(grades: List[int], leader: str, west: str, papers: int) -> int:\n    \"\"\"\n    Kuhesabu jumla ya kiasi cha udhamini kwa mwanafunzi kulingana na mafanikio ya kitaaluma na ya ziada.\n\n    Kazi hii inatumia seti ya masharti kuamua jumla ya kiasi cha pesa za udhamini ambacho mwanafunzi anastahili.\n    Udhamini hutolewa kulingana na alama za kitaaluma, majukumu ya uongozi, asili ya kikanda, na michango ya utafiti.\n\n    Vigezo:\n    grades (orodha ya int): Orodha ya vipengele viwili inayoonyesha alama za kitaaluma za mwanafunzi [mwisho wa wastani wa muhula, tathmini ya darasa].\n    leader (str): Neno ('Y' au 'N') linaloonyesha kama mwanafunzi ni kiongozi wa darasa.\n    west (str): Neno ('Y' au 'N') linaloonyesha kama mwanafunzi anatoka mkoa wa magharibi.\n    papers (int): Nambari inayoonyesha idadi ya makala za utafiti zilizochapishwa na mwanafunzi.\n\n    Inarejesha:\n    int: Jumla ya kiasi cha udhamini ambacho mwanafunzi anastahili.\n\n    Mifano:\n    >>> calculate_scholarship([87, 82], 'Y', 'N', 0)\n    4850\n\n    >>> calculate_scholarship([88, 78], 'N', 'Y', 1)\n    9000\n\n    Mfano wa kwanza unahesabu udhamini kwa mwanafunzi mwenye wastani wa alama 87, alama ya tathmini ya 82,\n    ambaye ni kiongozi wa darasa ('Y'), si kutoka mkoa wa magharibi ('N'), na hana makala zilizochapishwa (0). Mwanafunzi huyu\n    atapokea jumla ya vitengo 4850 vya sarafu.\n\n    Katika mfano wa pili, mwanafunzi ana wastani wa alama 88, alama ya tathmini ya 78, si kiongozi wa darasa ('N'),\n    anatoka mkoa wa magharibi ('Y'), na amechapisha makala 1. Mwanafunzi huyu atapokea jumla ya vitengo 9000 vya sarafu.\n    \"\"\"",
      "tr": "from typing import List\ndef calculate_scholarship(grades: List[int], leader: str, west: str, papers: int) -> int:\n    \"\"\"\n    Akademik ve ders dışı başarılar temelinde bir öğrenci için toplam burs miktarını hesaplayın.\n\n    Fonksiyon, bir öğrencinin hak kazandığı toplam burs miktarını belirlemek için bir dizi koşul kullanır.\n    Burslar, akademik notlar, liderlik rolleri, bölgesel geçmiş ve araştırma katkılarına göre verilir.\n\n    Parametreler:\n    grades (list of int): Öğrencinin akademik notlarını içeren iki elemanlı bir liste [dönem sonu ortalaması, sınıf değerlendirmesi].\n    leader (str): Öğrencinin sınıf lideri olup olmadığını belirten bir dize ('Y' veya 'N').\n    west (str): Öğrencinin batı bölgesinden olup olmadığını belirten bir dize ('Y' veya 'N').\n    papers (int): Öğrencinin yayımladığı araştırma makalelerinin sayısını temsil eden bir tamsayı.\n\n    Döndürür:\n    int: Öğrencinin hak kazandığı toplam burs miktarı.\n\n    Örnekler:\n    >>> calculate_scholarship([87, 82], 'Y', 'N', 0)\n    4850\n\n    >>> calculate_scholarship([88, 78], 'N', 'Y', 1)\n    9000\n\n    İlk örnek, ortalama notu 87, değerlendirme notu 82 olan, sınıf lideri ('Y'), batı bölgesinden olmayan ('N'),\n    ve yayımlanmış makalesi olmayan (0) bir öğrenci için burs hesaplar. Bu öğrenci toplamda 4850 birim para alacaktır.\n\n    İkinci örnekte, öğrenci ortalama notu 88, değerlendirme notu 78, sınıf lideri değil ('N'),\n    batı bölgesinden ('Y') ve 1 makale yayımlamış. Bu öğrenci toplamda 9000 birim para alacaktır.\n    \"\"\"",
      "vi": "from typing import List\ndef calculate_scholarship(grades: List[int], leader: str, west: str, papers: int) -> int:\n    \"\"\"\n    Tính tổng số tiền học bổng cho một sinh viên dựa trên thành tích học tập và hoạt động ngoại khóa.\n\n    Hàm này sử dụng một tập hợp các điều kiện để xác định tổng số tiền học bổng mà sinh viên được nhận.\n    Học bổng được trao dựa trên điểm học tập, vai trò lãnh đạo, xuất thân vùng miền, và đóng góp nghiên cứu.\n\n    Tham số:\n    grades (list of int): Một danh sách hai phần tử chứa điểm học tập của sinh viên [điểm trung bình cuối kỳ, đánh giá lớp].\n    leader (str): Một chuỗi ('Y' hoặc 'N') chỉ ra liệu sinh viên có phải là lớp trưởng hay không.\n    west (str): Một chuỗi ('Y' hoặc 'N') chỉ ra liệu sinh viên có xuất thân từ tỉnh miền Tây hay không.\n    papers (int): Một số nguyên biểu thị số lượng bài báo nghiên cứu đã được sinh viên công bố.\n\n    Trả về:\n    int: Tổng số tiền học bổng mà sinh viên đủ điều kiện nhận.\n\n    Ví dụ:\n    >>> calculate_scholarship([87, 82], 'Y', 'N', 0)\n    4850\n\n    >>> calculate_scholarship([88, 78], 'N', 'Y', 1)\n    9000\n\n    Ví dụ đầu tiên tính toán học bổng cho một sinh viên có điểm trung bình là 87, điểm đánh giá là 82,\n    là lớp trưởng ('Y'), không xuất thân từ tỉnh miền Tây ('N'), và không có bài báo nào được công bố (0). Sinh viên này\n    sẽ nhận được tổng cộng 4850 đơn vị tiền tệ.\n\n    Trong ví dụ thứ hai, sinh viên có điểm trung bình là 88, điểm đánh giá là 78, không phải là lớp trưởng ('N'),\n    xuất thân từ tỉnh miền Tây ('Y'), và đã công bố 1 bài báo. Sinh viên này sẽ nhận được tổng cộng 9000 đơn vị tiền tệ.\n    \"\"\""
    },
    "prompt_bertscore": {
      "es": "0.9881910265867139",
      "arb": "0.9816151691921728",
      "sw": "0.9621877275142935",
      "tr": "0.9641539696561578",
      "vi": "0.9696909901578864"
    },
    "canonical_solution": "    scholarship = 0\n    if grades[0] > 80 and papers >= 1:\n        scholarship += 8000\n    if grades[0] > 85 and grades[1] > 80:\n        scholarship += 4000\n    if grades[0] > 90:\n        scholarship += 2000\n    if grades[0] > 85 and west == 'Y':\n        scholarship += 1000\n    if grades[1] > 80 and leader == 'Y':\n        scholarship += 850\n    return scholarship",
    "instruction": {
      "en": "def calculate_scholarship(grades: List[int], leader: str, west: str, papers: int) -> int:\n    scholarship = 0\n    if grades[0] > 80 and papers >= 1:\n        scholarship += 8000\n    if grades[0] > 85 and grades[1] > 80:\n        scholarship += 4000\n    if grades[0] > 90:\n        scholarship += 2000\n    if grades[0] > 85 and west == 'Y':\n        scholarship += 1000\n    if grades[1] > 80 and leader == 'Y':\n        scholarship += 850\n    return scholarship\n\nProvide a concise natural language description (docstring) of the Python code in English using at most 500 characters.",
      "es": "def calculate_scholarship(grades: List[int], leader: str, west: str, papers: int) -> int:\n    scholarship = 0\n    if grades[0] > 80 and papers >= 1:\n        scholarship += 8000\n    if grades[0] > 85 and grades[1] > 80:\n        scholarship += 4000\n    if grades[0] > 90:\n        scholarship += 2000\n    if grades[0] > 85 and west == 'Y':\n        scholarship += 1000\n    if grades[1] > 80 and leader == 'Y':\n        scholarship += 850\n    return scholarship\n\nProporcione una descripción concisa en lenguaje natural (docstring) del código Python en español utilizando como máximo 500 caracteres.",
      "arb": "def calculate_scholarship(grades: List[int], leader: str, west: str, papers: int) -> int:\n    scholarship = 0\n    if grades[0] > 80 and papers >= 1:\n        scholarship += 8000\n    if grades[0] > 85 and grades[1] > 80:\n        scholarship += 4000\n    if grades[0] > 90:\n        scholarship += 2000\n    if grades[0] > 85 and west == 'Y':\n        scholarship += 1000\n    if grades[1] > 80 and leader == 'Y':\n        scholarship += 850\n    return scholarship\n\nيرجى تقديم وصف موجز بلغة طبيعية (docstring) للكود البرمجي بلغة بايثون باللغة العربية الفصحى، بحيث لا يتجاوز 500 حرف.",
      "sw": "def calculate_scholarship(grades: List[int], leader: str, west: str, papers: int) -> int:\n    scholarship = 0\n    if grades[0] > 80 and papers >= 1:\n        scholarship += 8000\n    if grades[0] > 85 and grades[1] > 80:\n        scholarship += 4000\n    if grades[0] > 90:\n        scholarship += 2000\n    if grades[0] > 85 and west == 'Y':\n        scholarship += 1000\n    if grades[1] > 80 and leader == 'Y':\n        scholarship += 850\n    return scholarship\n\nToa maelezo mafupi ya lugha ya asili (docstring) ya msimbo wa Python kwa Kiswahili kwa kutumia herufi zisizozidi 500.",
      "tr": "def calculate_scholarship(grades: List[int], leader: str, west: str, papers: int) -> int:\n    scholarship = 0\n    if grades[0] > 80 and papers >= 1:\n        scholarship += 8000\n    if grades[0] > 85 and grades[1] > 80:\n        scholarship += 4000\n    if grades[0] > 90:\n        scholarship += 2000\n    if grades[0] > 85 and west == 'Y':\n        scholarship += 1000\n    if grades[1] > 80 and leader == 'Y':\n        scholarship += 850\n    return scholarship\n\nPython kodunun işlevini açıklayan kısa bir doğal dil açıklaması (docstring) sağlayın. Açıklama, Türkçe olarak en fazla 500 karakter kullanılacak şekilde olmalıdır.",
      "vi": "def calculate_scholarship(grades: List[int], leader: str, west: str, papers: int) -> int:\n    scholarship = 0\n    if grades[0] > 80 and papers >= 1:\n        scholarship += 8000\n    if grades[0] > 85 and grades[1] > 80:\n        scholarship += 4000\n    if grades[0] > 90:\n        scholarship += 2000\n    if grades[0] > 85 and west == 'Y':\n        scholarship += 1000\n    if grades[1] > 80 and leader == 'Y':\n        scholarship += 850\n    return scholarship\n\nCung cấp mô tả ngắn gọn bằng ngôn ngữ tự nhiên (docstring) cho mã Python bằng tiếng Việt, sử dụng tối đa 500 ký tự."
    },
    "instruction_bertscore": {
      "es": "0.9687387561112052",
      "arb": "0.906469919330197",
      "sw": "0.914896018724078",
      "tr": "0.8633220375491314",
      "vi": "0.9256256346468206"
    },
    "level": "",
    "test": "def test_calculate_scholarship():\n    # Test case 1: Student meets multiple scholarship criteria\n    grades1 = [90, 85]  # Both grades are high\n    leader1 = 'Y'  # Is a leader\n    west1 = 'Y'  # Is from the West\n    papers1 = 2  # Has published papers\n    expected_scholarship1 = 13850  # Should receive multiple scholarships\n    assert calculate_scholarship(grades1, leader1, west1,\n                                 papers1) == expected_scholarship1, f\"Test case 1 failed. Expected {expected_scholarship1}, got {calculate_scholarship(grades1, leader1, west1, papers1)}\"\n\n    # Test case 2: Student meets one scholarship criteria\n    grades2 = [82, 70]  # Only the first grade is high enough\n    leader2 = 'N'  # Is not a leader\n    west2 = 'N'  # Is not from the West\n    papers2 = 1  # Has published papers\n    expected_scholarship2 = 8000  # Should receive scholarship for first grade and papers\n    assert calculate_scholarship(grades2, leader2, west2,\n                                 papers2) == expected_scholarship2, f\"Test case 2 failed. Expected {expected_scholarship2}, got {calculate_scholarship(grades2, leader2, west2, papers2)}\"\n\n    # Test case 3: Student does not meet any scholarship criteria\n    grades3 = [75, 75]  # Both grades are below the threshold\n    leader3 = 'N'  # Is not a leader\n    west3 = 'N'  # Is not from the West\n    papers3 = 0  # Has no published papers\n    expected_scholarship3 = 0  # Should not receive any scholarships\n    assert calculate_scholarship(grades3, leader3, west3,\n                                 papers3) == expected_scholarship3, f\"Test case 3 failed. Expected {expected_scholarship3}, got {calculate_scholarship(grades3, leader3, west3, papers3)}\"\n\n    # If no assertion is raised, all test cases passed\n    print(\"All test cases passed!\")\n\n\ntest_calculate_scholarship()",
    "entry_point": "calculate_scholarship",
    "signature": "def calculate_scholarship(grades: List[int], leader: str, west: str, papers: int) -> int:",
    "docstring": {
      "en": "Calculate the total scholarship amount for a student based on academic and extracurricular achievements.\n\nThe function uses a set of conditions to determine the total amount of scholarship money a student is entitled to.\nScholarships are awarded based on academic grades, leadership roles, regional background, and research contributions.\n\nParameters:\ngrades (list of int): A two-element list containing the student's academic grades [end of term average, class evaluation].\nleader (str): A string ('Y' or 'N') indicating if the student is a class leader.\nwest (str): A string ('Y' or 'N') indicating if the student is from a western province.\npapers (int): An integer representing the number of research papers published by the student.\n\nReturns:\nint: The total scholarship amount the student is eligible for.\n\nExamples:\n>>> calculate_scholarship([87, 82], 'Y', 'N', 0)\n4850\n\n>>> calculate_scholarship([88, 78], 'N', 'Y', 1)\n9000\n\nThe first example calculates a scholarship for a student with an average grade of 87, an evaluation grade of 82,\nwho is a class leader ('Y'), not from the western province ('N'), and with no published papers (0). This student\nwould receive a total of 4850 units of currency.\n\nIn the second example, the student has an average grade of 88, an evaluation grade of 78, is not a class leader ('N'),\nis from the western province ('Y'), and has published 1 paper. This student would receive a total of 9000 units of currency.",
      "es": "Calcular la cantidad total de beca para un estudiante basado en logros académicos y extracurriculares.\n\nLa función utiliza un conjunto de condiciones para determinar la cantidad total de dinero de beca a la que un estudiante tiene derecho.\nLas becas se otorgan en función de las calificaciones académicas, roles de liderazgo, origen regional y contribuciones a la investigación.\n\nParámetros:\ngrades (list of int): Una lista de dos elementos que contiene las calificaciones académicas del estudiante [promedio de fin de curso, evaluación de clase].\nleader (str): Una cadena ('Y' o 'N') que indica si el estudiante es líder de clase.\nwest (str): Una cadena ('Y' o 'N') que indica si el estudiante es de una provincia occidental.\npapers (int): Un entero que representa el número de artículos de investigación publicados por el estudiante.\n\nDevuelve:\nint: La cantidad total de beca para la que el estudiante es elegible.\n\nEjemplos:\n>>> calculate_scholarship([87, 82], 'Y', 'N', 0)\n4850\n\n>>> calculate_scholarship([88, 78], 'N', 'Y', 1)\n9000\n\nEl primer ejemplo calcula una beca para un estudiante con una calificación promedio de 87, una calificación de evaluación de 82,\nque es líder de clase ('Y'), no es de la provincia occidental ('N'), y sin artículos publicados (0). Este estudiante\nrecibiría un total de 4850 unidades de moneda.\n\nEn el segundo ejemplo, el estudiante tiene una calificación promedio de 88, una calificación de evaluación de 78, no es líder de clase ('N'),\nes de la provincia occidental ('Y'), y ha publicado 1 artículo. Este estudiante recibiría un total de 9000 unidades de moneda.",
      "arb": "حساب إجمالي مبلغ المنحة الدراسية لطالب بناءً على الإنجازات الأكاديمية واللامنهجية.\n\nتستخدم الدالة مجموعة من الشروط لتحديد إجمالي مبلغ المنحة الدراسية الذي يحق للطالب الحصول عليه. تُمنح المنح الدراسية بناءً على الدرجات الأكاديمية، الأدوار القيادية، الخلفية الإقليمية، والمساهمات البحثية.\n\nالمعلمات:\ngrades (list of int): قائمة تحتوي على عنصرين تحتوي على الدرجات الأكاديمية للطالب [متوسط نهاية الفصل، تقييم الصف].\nleader (str): سلسلة ('Y' أو 'N') تشير إلى ما إذا كان الطالب قائدًا للصف.\nwest (str): سلسلة ('Y' أو 'N') تشير إلى ما إذا كان الطالب من مقاطعة غربية.\npapers (int): عدد صحيح يمثل عدد الأبحاث المنشورة من قبل الطالب.\n\nالقيم المعادة:\nint: إجمالي مبلغ المنحة الدراسية الذي يحق للطالب الحصول عليه.\n\nأمثلة:\n>>> calculate_scholarship([87, 82], 'Y', 'N', 0)\n4850\n\n>>> calculate_scholarship([88, 78], 'N', 'Y', 1)\n9000\n\nالمثال الأول يحسب منحة دراسية لطالب لديه متوسط درجة 87، ودرجة تقييم 82، وهو قائد للصف ('Y')، وليس من المقاطعة الغربية ('N')، وليس لديه أبحاث منشورة (0). هذا الطالب سيحصل على إجمالي 4850 وحدة من العملة.\n\nفي المثال الثاني، الطالب لديه متوسط درجة 88، ودرجة تقييم 78، ليس قائدًا للصف ('N')، من المقاطعة الغربية ('Y')، ولديه بحث منشور واحد. هذا الطالب سيحصل على إجمالي 9000 وحدة من العملة.",
      "sw": "Hesabu jumla ya kiasi cha udhamini kwa mwanafunzi kulingana na mafanikio ya kitaaluma na ya ziada.\n\nKazi hii inatumia seti ya masharti kuamua jumla ya kiasi cha pesa za udhamini ambacho mwanafunzi anastahili.\nUdhamini hutolewa kulingana na alama za kitaaluma, nafasi za uongozi, asili ya kikanda, na michango ya utafiti.\n\nVigezo:\ngrades (list of int): Orodha ya vipengele viwili inayoonyesha alama za kitaaluma za mwanafunzi [wastani wa mwisho wa muhula, tathmini ya darasa].\nleader (str): Mfuatano wa herufi ('Y' au 'N') unaoonyesha kama mwanafunzi ni kiongozi wa darasa.\nwest (str): Mfuatano wa herufi ('Y' au 'N') unaoonyesha kama mwanafunzi anatoka mkoa wa magharibi.\npapers (int): Nambari inayoonyesha idadi ya makala za utafiti zilizochapishwa na mwanafunzi.\n\nRudisha:\nint: Jumla ya kiasi cha udhamini ambacho mwanafunzi anastahili.\n\nMifano:\n>>> calculate_scholarship([87, 82], 'Y', 'N', 0)\n4850\n\n>>> calculate_scholarship([88, 78], 'N', 'Y', 1)\n9000\n\nMfano wa kwanza unahesabu udhamini kwa mwanafunzi mwenye wastani wa alama 87, alama ya tathmini 82,\nambaye ni kiongozi wa darasa ('Y'), si kutoka mkoa wa magharibi ('N'), na hana makala zilizochapishwa (0). Mwanafunzi huyu\nangepokea jumla ya vitengo 4850 vya sarafu.\n\nKatika mfano wa pili, mwanafunzi ana wastani wa alama 88, alama ya tathmini 78, si kiongozi wa darasa ('N'),\nanatoka mkoa wa magharibi ('Y'), na amechapisha makala 1. Mwanafunzi huyu angepokea jumla ya vitengo 9000 vya sarafu.",
      "tr": "Bir öğrencinin akademik ve ders dışı başarılarına dayalı toplam burs miktarını hesaplayın.\n\nFonksiyon, bir öğrencinin hak kazandığı toplam burs miktarını belirlemek için bir dizi koşul kullanır.\nBurslar akademik notlar, liderlik rolleri, bölgesel geçmiş ve araştırma katkılarına göre verilir.\n\nParametreler:\ngrades (list of int): Öğrencinin akademik notlarını içeren iki elemanlı bir liste [dönem sonu ortalaması, sınıf değerlendirmesi].\nleader (str): Öğrencinin sınıf lideri olup olmadığını belirten bir dize ('Y' veya 'N').\nwest (str): Öğrencinin batı bölgesinden olup olmadığını belirten bir dize ('Y' veya 'N').\npapers (int): Öğrencinin yayımladığı araştırma makalelerinin sayısını temsil eden bir tamsayı.\n\nDöndürülenler:\nint: Öğrencinin hak kazandığı toplam burs miktarı.\n\nÖrnekler:\n>>> calculate_scholarship([87, 82], 'Y', 'N', 0)\n4850\n\n>>> calculate_scholarship([88, 78], 'N', 'Y', 1)\n9000\n\nİlk örnek, ortalama notu 87, değerlendirme notu 82 olan, sınıf lideri ('Y'), batı bölgesinden olmayan ('N') ve yayımlanmış makalesi olmayan (0) bir öğrenci için burs hesaplar. Bu öğrenci toplamda 4850 birim para alacaktır.\n\nİkinci örnekte, öğrenci ortalama notu 88, değerlendirme notu 78, sınıf lideri değil ('N'), batı bölgesinden ('Y') ve 1 makale yayımlamış. Bu öğrenci toplamda 9000 birim para alacaktır.",
      "vi": "Tính tổng số tiền học bổng cho một sinh viên dựa trên thành tích học tập và hoạt động ngoại khóa.\n\nHàm sử dụng một tập hợp các điều kiện để xác định tổng số tiền học bổng mà sinh viên được hưởng. Học bổng được trao dựa trên điểm số học tập, vai trò lãnh đạo, xuất thân vùng miền và đóng góp nghiên cứu.\n\nTham số:\ngrades (list of int): Một danh sách hai phần tử chứa điểm số học tập của sinh viên [trung bình cuối kỳ, đánh giá lớp].\nleader (str): Một chuỗi ('Y' hoặc 'N') chỉ ra nếu sinh viên là lớp trưởng.\nwest (str): Một chuỗi ('Y' hoặc 'N') chỉ ra nếu sinh viên đến từ một tỉnh miền Tây.\npapers (int): Một số nguyên đại diện cho số lượng bài báo nghiên cứu được sinh viên công bố.\n\nTrả về:\nint: Tổng số tiền học bổng mà sinh viên đủ điều kiện nhận.\n\nVí dụ:\n>>> calculate_scholarship([87, 82], 'Y', 'N', 0)\n4850\n\n>>> calculate_scholarship([88, 78], 'N', 'Y', 1)\n9000\n\nVí dụ đầu tiên tính toán học bổng cho một sinh viên có điểm trung bình là 87, điểm đánh giá là 82,\nlà lớp trưởng ('Y'), không đến từ tỉnh miền Tây ('N'), và không có bài báo công bố (0). Sinh viên này\nsẽ nhận được tổng cộng 4850 đơn vị tiền tệ.\n\nTrong ví dụ thứ hai, sinh viên có điểm trung bình là 88, điểm đánh giá là 78, không phải là lớp trưởng ('N'),\nđến từ tỉnh miền Tây ('Y'), và đã công bố 1 bài báo. Sinh viên này sẽ nhận được tổng cộng 9000 đơn vị tiền tệ."
    },
    "docstring_bertscore": {
      "es": "0.9895395282435597",
      "arb": "0.9701919359788564",
      "sw": "0.9514513581585957",
      "tr": "0.9698699561311989",
      "vi": "0.9711199371190514"
    }
  },
  {
    "task_id": "Python/14",
    "prompt": {
      "en": "def verify_isbn(isbn: str) -> str:\n    \"\"\"\n    Verify the correctness of a given ISBN number and correct it if necessary.\n\n    The function checks the provided ISBN number against the ISBN standard checksum calculation.\n    If the checksum is correct, the function returns \"Right\". If the checksum is incorrect,\n    the function returns the corrected ISBN number.\n\n    Args:\n    isbn: A string representing the ISBN number to be verified. The format should be 'x-xxx-xxxxx-x',\n          where 'x' is a digit, and the last 'x' could also be 'X' representing the checksum digit.\n\n    Returns:\n    A string that is either \"Right\" if the ISBN checksum is correct, or the corrected ISBN number\n    in the same format as the input if the checksum is incorrect.\n\n    Examples:\n    >>> verify_isbn(\"0-670-82162-4\")\n    'Right'\n    \n    >>> verify_isbn(\"0-670-82162-0\")\n    '0-670-82162-4'\n\n    The second example shows the correction of the ISBN number where the checksum digit is calculated\n    to be '4' instead of the provided '0', thus the corrected ISBN is returned.\n    \"\"\"\n    # Function implementation goes here.",
      "es": "def verify_isbn(isbn: str) -> str:\n    \"\"\"\n    Verificar la corrección de un número ISBN dado y corregirlo si es necesario.\n\n    La función verifica el número ISBN proporcionado contra el cálculo de suma de verificación estándar de ISBN.\n    Si la suma de verificación es correcta, la función devuelve \"Right\". Si la suma de verificación es incorrecta,\n    la función devuelve el número ISBN corregido.\n\n    Argumentos:\n    isbn: Una cadena que representa el número ISBN a verificar. El formato debe ser 'x-xxx-xxxxx-x',\n          donde 'x' es un dígito, y el último 'x' también podría ser 'X' representando el dígito de suma de verificación.\n\n    Devuelve:\n    Una cadena que es \"Right\" si la suma de verificación del ISBN es correcta, o el número ISBN corregido\n    en el mismo formato que la entrada si la suma de verificación es incorrecta.\n\n    Ejemplos:\n    >>> verify_isbn(\"0-670-82162-4\")\n    'Right'\n    \n    >>> verify_isbn(\"0-670-82162-0\")\n    '0-670-82162-4'\n\n    El segundo ejemplo muestra la corrección del número ISBN donde se calcula que el dígito de suma de verificación es '4'\n    en lugar del '0' proporcionado, por lo tanto, se devuelve el ISBN corregido.\n    \"\"\"\n    # La implementación de la función va aquí.",
      "arb": "def verify_isbn(isbn: str) -> str:\n    \"\"\"\n    التحقق من صحة رقم ISBN المعطى وتصحيحه إذا لزم الأمر.\n\n    تقوم الدالة بفحص رقم ISBN المقدم مقابل حساب التحقق القياسي لـ ISBN.\n    إذا كان حساب التحقق صحيحًا، تعيد الدالة \"Right\". إذا كان حساب التحقق غير صحيح،\n    تعيد الدالة رقم ISBN المصحح.\n\n    يعيدالحجج:\n    isbn: سلسلة تمثل رقم ISBN المراد التحقق منه. يجب أن يكون التنسيق 'x-xxx-xxxxx-x',\n          حيث 'x' هو رقم، و'X' يمكن أن تمثل رقم التحقق الأخير.\n\n    يعيد:\n    سلسلة تكون إما \"Right\" إذا كان حساب التحقق لـ ISBN صحيحًا، أو رقم ISBN المصحح\n    بنفس تنسيق الإدخال إذا كان حساب التحقق غير صحيح.\n\n    امثله:\n    >>> verify_isbn(\"0-670-82162-4\")\n    'Right'\n    \n    >>> verify_isbn(\"0-670-82162-0\")\n    '0-670-82162-4'\n\n    المثال الثاني يوضح تصحيح رقم ISBN حيث تم حساب رقم التحقق ليكون '4' بدلاً من '0' المقدم،\n    وبالتالي يتم إرجاع ISBN المصحح.\n    \"\"\"\n    # Function implementation goes here.",
      "sw": "def verify_isbn(isbn: str) -> str:\n    \"\"\"\n    Thibitisha usahihi wa nambari ya ISBN iliyotolewa na uirekebishe ikiwa ni lazima.\n\n    Kazi hii inakagua nambari ya ISBN iliyotolewa dhidi ya hesabu ya checksum ya kiwango cha ISBN.\n    Ikiwa checksum ni sahihi, kazi inarudisha \"Right\". Ikiwa checksum si sahihi,\n    kazi inarudisha nambari ya ISBN iliyorekebishwa.\n\n    Hoja:\n    isbn: Kamba inayowakilisha nambari ya ISBN inayopaswa kuthibitishwa. Muundo unapaswa kuwa 'x-xxx-xxxxx-x',\n          ambapo 'x' ni tarakimu, na 'x' ya mwisho inaweza pia kuwa 'X' inayowakilisha tarakimu ya checksum.\n\n    Inarejesha:\n    Kamba ambayo ni \"Right\" ikiwa checksum ya ISBN ni sahihi, au nambari ya ISBN iliyorekebishwa\n    katika muundo ule ule kama pembejeo ikiwa checksum si sahihi.\n\n    Mifano:\n    >>> verify_isbn(\"0-670-82162-4\")\n    'Right'\n    \n    >>> verify_isbn(\"0-670-82162-0\")\n    '0-670-82162-4'\n\n    Mfano wa pili unaonyesha marekebisho ya nambari ya ISBN ambapo tarakimu ya checksum inahesabiwa\n    kuwa '4' badala ya '0' iliyotolewa, hivyo nambari ya ISBN iliyorekebishwa inarudishwa.\n    \"\"\"\n    # Utekelezaji wa kazi unaenda hapa.",
      "tr": "def verify_isbn(isbn: str) -> str:\n    \"\"\"\n    Verilen ISBN numarasının doğruluğunu kontrol edin ve gerekirse düzeltin.\n\n    Fonksiyon, sağlanan ISBN numarasını ISBN standart kontrol toplamı hesaplamasına karşı kontrol eder.\n    Eğer kontrol toplamı doğruysa, fonksiyon \"Right\" döndürür. Eğer kontrol toplamı yanlışsa,\n    fonksiyon düzeltilmiş ISBN numarasını döndürür.\n\n    Argümanlar:\n    isbn: Doğrulanacak ISBN numarasını temsil eden bir string. Format 'x-xxx-xxxxx-x' şeklinde olmalıdır,\n          burada 'x' bir rakamdır ve son 'x' kontrol toplamı rakamını temsil eden 'X' de olabilir.\n\n    Döndürür:\n    Kontrol toplamı doğruysa \"Right\" olan bir string veya kontrol toplamı yanlışsa\n    girişle aynı formatta düzeltilmiş ISBN numarasını döndüren bir string.\n\n    Örnekler:\n    >>> verify_isbn(\"0-670-82162-4\")\n    'Right'\n    \n    >>> verify_isbn(\"0-670-82162-0\")\n    '0-670-82162-4'\n\n    İkinci örnek, kontrol toplamı rakamının sağlanan '0' yerine '4' olarak hesaplandığı\n    ISBN numarasının düzeltilmesini gösterir, bu nedenle düzeltilmiş ISBN döndürülür.\n    \"\"\"\n    # Fonksiyonun uygulanması burada yapılır.",
      "vi": "def verify_isbn(isbn: str) -> str:\n    \"\"\"\n    Xác minh tính đúng đắn của một số ISBN được cung cấp và sửa nó nếu cần thiết.\n\n    Hàm kiểm tra số ISBN được cung cấp theo tính toán tổng kiểm tra chuẩn của ISBN.\n    Nếu tổng kiểm tra đúng, hàm trả về \"Right\". Nếu tổng kiểm tra sai,\n    hàm trả về số ISBN đã được sửa.\n\n    Tham số:\n    isbn: Một chuỗi đại diện cho số ISBN cần được xác minh. Định dạng nên là 'x-xxx-xxxxx-x',\n          trong đó 'x' là một chữ số, và 'x' cuối cùng cũng có thể là 'X' đại diện cho chữ số tổng kiểm tra.\n\n    Trả về:\n    Một chuỗi là \"Right\" nếu tổng kiểm tra ISBN đúng, hoặc số ISBN đã được sửa\n    theo cùng định dạng như đầu vào nếu tổng kiểm tra sai.\n\n    Ví dụ:\n    >>> verify_isbn(\"0-670-82162-4\")\n    'Right'\n    \n    >>> verify_isbn(\"0-670-82162-0\")\n    '0-670-82162-4'\n\n    Ví dụ thứ hai cho thấy sự sửa chữa của số ISBN nơi chữ số tổng kiểm tra được tính\n    là '4' thay vì '0' được cung cấp, do đó số ISBN đã được sửa được trả về.\n    \"\"\"\n    # Triển khai hàm ở đây."
    },
    "prompt_bertscore": {
      "es": "0.9870230799462287",
      "arb": "0.9485749916108295",
      "sw": "0.9861381815987182",
      "tr": "0.9795190227811117",
      "vi": "0.9787320492114514"
    },
    "canonical_solution": "    # Remove the hyphens '-' and keep only the digits and possibly 'X'\n    isbn_digits = isbn.replace('-', '')\n\n    # Calculate the sum of products\n    total_sum = sum((i + 1) * int(digit) for i, digit in enumerate(isbn_digits[:-1]))\n    \n    # Compute the check digit\n    check_digit = total_sum % 11\n\n    # Check if the check digit is 'X'\n    if check_digit == 10:\n        check_digit = 'X'\n    else:\n        check_digit = str(check_digit)\n\n    # Compare with the last digit of the input ISBN\n    if check_digit == isbn_digits[-1]:\n        return \"Right\"\n    else:\n        # Return the corrected ISBN\n        return isbn[:-1] + check_digit",
    "instruction": {
      "en": "def verify_isbn(isbn: str) -> str:\n    # Remove the hyphens '-' and keep only the digits and possibly 'X'\n    isbn_digits = isbn.replace('-', '')\n\n    # Calculate the sum of products\n    total_sum = sum((i + 1) * int(digit) for i, digit in enumerate(isbn_digits[:-1]))\n    \n    # Compute the check digit\n    check_digit = total_sum % 11\n\n    # Check if the check digit is 'X'\n    if check_digit == 10:\n        check_digit = 'X'\n    else:\n        check_digit = str(check_digit)\n\n    # Compare with the last digit of the input ISBN\n    if check_digit == isbn_digits[-1]:\n        return \"Right\"\n    else:\n        # Return the corrected ISBN\n        return isbn[:-1] + check_digit\n\nProvide a concise natural language description (docstring) of the Python code in English using at most 500 characters.",
      "es": "def verify_isbn(isbn: str) -> str:\n    # Remove the hyphens '-' and keep only the digits and possibly 'X'\n    isbn_digits = isbn.replace('-', '')\n\n    # Calculate the sum of products\n    total_sum = sum((i + 1) * int(digit) for i, digit in enumerate(isbn_digits[:-1]))\n    \n    # Compute the check digit\n    check_digit = total_sum % 11\n\n    # Check if the check digit is 'X'\n    if check_digit == 10:\n        check_digit = 'X'\n    else:\n        check_digit = str(check_digit)\n\n    # Compare with the last digit of the input ISBN\n    if check_digit == isbn_digits[-1]:\n        return \"Right\"\n    else:\n        # Return the corrected ISBN\n        return isbn[:-1] + check_digit\n\nProporcione una descripción concisa en lenguaje natural (docstring) del código Python en español utilizando como máximo 500 caracteres.",
      "arb": "def verify_isbn(isbn: str) -> str:\n    # Remove the hyphens '-' and keep only the digits and possibly 'X'\n    isbn_digits = isbn.replace('-', '')\n\n    # Calculate the sum of products\n    total_sum = sum((i + 1) * int(digit) for i, digit in enumerate(isbn_digits[:-1]))\n    \n    # Compute the check digit\n    check_digit = total_sum % 11\n\n    # Check if the check digit is 'X'\n    if check_digit == 10:\n        check_digit = 'X'\n    else:\n        check_digit = str(check_digit)\n\n    # Compare with the last digit of the input ISBN\n    if check_digit == isbn_digits[-1]:\n        return \"Right\"\n    else:\n        # Return the corrected ISBN\n        return isbn[:-1] + check_digit\n\nيرجى تقديم وصف موجز بلغة طبيعية (docstring) للشفرة البرمجية بلغة بايثون باللغة العربية الفصحى، بحيث لا يتجاوز 500 حرف.",
      "sw": "def verify_isbn(isbn: str) -> str:\n    # Remove the hyphens '-' and keep only the digits and possibly 'X'\n    isbn_digits = isbn.replace('-', '')\n\n    # Calculate the sum of products\n    total_sum = sum((i + 1) * int(digit) for i, digit in enumerate(isbn_digits[:-1]))\n    \n    # Compute the check digit\n    check_digit = total_sum % 11\n\n    # Check if the check digit is 'X'\n    if check_digit == 10:\n        check_digit = 'X'\n    else:\n        check_digit = str(check_digit)\n\n    # Compare with the last digit of the input ISBN\n    if check_digit == isbn_digits[-1]:\n        return \"Right\"\n    else:\n        # Return the corrected ISBN\n        return isbn[:-1] + check_digit\n\nToa maelezo mafupi ya lugha ya asili (docstring) ya msimbo wa Python kwa Kiswahili kwa kutumia herufi zisizozidi 500.",
      "tr": "def verify_isbn(isbn: str) -> str:\n    # Remove the hyphens '-' and keep only the digits and possibly 'X'\n    isbn_digits = isbn.replace('-', '')\n\n    # Calculate the sum of products\n    total_sum = sum((i + 1) * int(digit) for i, digit in enumerate(isbn_digits[:-1]))\n    \n    # Compute the check digit\n    check_digit = total_sum % 11\n\n    # Check if the check digit is 'X'\n    if check_digit == 10:\n        check_digit = 'X'\n    else:\n        check_digit = str(check_digit)\n\n    # Compare with the last digit of the input ISBN\n    if check_digit == isbn_digits[-1]:\n        return \"Right\"\n    else:\n        # Return the corrected ISBN\n        return isbn[:-1] + check_digit\n\nVerilen Python kodunun işlevini açıklayan kısa bir doğal dil açıklaması (docstring) sağlayın. Açıklama Türkçe olmalı ve en fazla 500 karakter içermelidir.",
      "vi": "def verify_isbn(isbn: str) -> str:\n    # Remove the hyphens '-' and keep only the digits and possibly 'X'\n    isbn_digits = isbn.replace('-', '')\n\n    # Calculate the sum of products\n    total_sum = sum((i + 1) * int(digit) for i, digit in enumerate(isbn_digits[:-1]))\n    \n    # Compute the check digit\n    check_digit = total_sum % 11\n\n    # Check if the check digit is 'X'\n    if check_digit == 10:\n        check_digit = 'X'\n    else:\n        check_digit = str(check_digit)\n\n    # Compare with the last digit of the input ISBN\n    if check_digit == isbn_digits[-1]:\n        return \"Right\"\n    else:\n        # Return the corrected ISBN\n        return isbn[:-1] + check_digit\n\nCung cấp mô tả ngắn gọn bằng ngôn ngữ tự nhiên (docstring) cho mã Python bằng tiếng Việt, sử dụng tối đa 500 ký tự."
    },
    "instruction_bertscore": {
      "es": "0.9687387561112052",
      "arb": "0.906469919330197",
      "sw": "0.914896018724078",
      "tr": "0.8583967986209903",
      "vi": "0.9069722555638342"
    },
    "level": "",
    "test": "def test_verify_isbn():\n    # Test case 1: Correct ISBN number\n    assert verify_isbn(\"0-670-82162-4\") == \"Right\", \"Test case 1 failed\"\n\n    # Test case 2: Incorrect ISBN number with wrong checksum digit\n    assert verify_isbn(\"0-670-82162-0\") == \"0-670-82162-4\", \"Test case 2 failed\"\n\n    print(\"All test cases passed!\")\n\n# Run the test cases\ntest_verify_isbn()",
    "entry_point": "verify_isbn",
    "signature": "def verify_isbn(isbn: str) -> str:",
    "docstring": {
      "en": "Verify the correctness of a given ISBN number and correct it if necessary.\n\nThe function checks the provided ISBN number against the ISBN standard checksum calculation.\nIf the checksum is correct, the function returns \"Right\". If the checksum is incorrect,\nthe function returns the corrected ISBN number.\n\nArgs:\nisbn: A string representing the ISBN number to be verified. The format should be 'x-xxx-xxxxx-x',\nwhere 'x' is a digit, and the last 'x' could also be 'X' representing the checksum digit.\n\nReturns:\nA string that is either \"Right\" if the ISBN checksum is correct, or the corrected ISBN number\nin the same format as the input if the checksum is incorrect.\n\nExamples:\n>>> verify_isbn(\"0-670-82162-4\")\n'Right'\n\n>>> verify_isbn(\"0-670-82162-0\")\n'0-670-82162-4'\n\nThe second example shows the correction of the ISBN number where the checksum digit is calculated\nto be '4' instead of the provided '0', thus the corrected ISBN is returned.",
      "es": "Verificar la corrección de un número ISBN dado y corregirlo si es necesario.\n\nLa función verifica el número ISBN proporcionado contra el cálculo estándar del checksum del ISBN. Si el checksum es correcto, la función devuelve \"Right\". Si el checksum es incorrecto, la función devuelve el número ISBN corregido.\n\nArgumentos:\nisbn: Una cadena que representa el número ISBN a verificar. El formato debe ser 'x-xxx-xxxxx-x', donde 'x' es un dígito, y el último 'x' también podría ser 'X' representando el dígito del checksum.\n\nDevuelve:\nUna cadena que es \"Right\" si el checksum del ISBN es correcto, o el número ISBN corregido en el mismo formato que la entrada si el checksum es incorrecto.\n\nEjemplos:\n>>> verify_isbn(\"0-670-82162-4\")\n'Right'\n\n>>> verify_isbn(\"0-670-82162-0\")\n'0-670-82162-4'\n\nEl segundo ejemplo muestra la corrección del número ISBN donde se calcula que el dígito del checksum es '4' en lugar del '0' proporcionado, por lo tanto, se devuelve el ISBN corregido.",
      "arb": "التحقق من صحة رقم ISBN المعطى وتصحيحه إذا لزم الأمر.\n\nتتحقق الدالة من رقم ISBN المقدم وفقًا لحساب التحقق القياسي لـ ISBN. إذا كان التحقق صحيحًا، تُرجع الدالة \"Right\". إذا كان التحقق غير صحيح، تُرجع الدالة رقم ISBN المصحح.\n\nالمعطيات:\nisbn: سلسلة تمثل رقم ISBN المراد التحقق منه. يجب أن يكون التنسيق 'x-xxx-xxxxx-x'، حيث 'x' هو رقم، ويمكن أن يكون 'x' الأخير أيضًا 'X' لتمثيل رقم التحقق.\n\nالقيم المعادة:\nسلسلة إما \"Right\" إذا كان تحقق ISBN صحيحًا، أو رقم ISBN المصحح بنفس تنسيق الإدخال إذا كان التحقق غير صحيح.\n\nأمثلة:\n>>> verify_isbn(\"0-670-82162-4\")\n'Right'\n\n>>> verify_isbn(\"0-670-82162-0\")\n'0-670-82162-4'\n\nيظهر المثال الثاني تصحيح رقم ISBN حيث تم حساب رقم التحقق ليكون '4' بدلاً من '0' المقدم، وبالتالي يتم إرجاع ISBN المصحح.",
      "sw": "Thibitisha usahihi wa nambari ya ISBN iliyotolewa na uirekebishe ikiwa ni lazima.\n\nKazi hii inakagua nambari ya ISBN iliyotolewa dhidi ya hesabu ya kawaida ya checksum ya ISBN.\nIkiwa checksum ni sahihi, kazi inarudisha \"Right\". Ikiwa checksum si sahihi,\nkazi inarudisha nambari ya ISBN iliyorekebishwa.\n\nHoja:\nisbn: Kamba inayowakilisha nambari ya ISBN inayohitaji kuthibitishwa. Muundo unapaswa kuwa 'x-xxx-xxxxx-x',\nambapo 'x' ni tarakimu, na 'x' ya mwisho inaweza pia kuwa 'X' inayowakilisha tarakimu ya checksum.\n\nInarejesha:\nKamba ambayo ni \"Right\" ikiwa checksum ya ISBN ni sahihi, au nambari ya ISBN iliyorekebishwa\nkatika muundo sawa na ingizo ikiwa checksum si sahihi.\n\nMifano:\n>>> verify_isbn(\"0-670-82162-4\")\n'Right'\n\n>>> verify_isbn(\"0-670-82162-0\")\n'0-670-82162-4'\n\nMfano wa pili unaonyesha marekebisho ya nambari ya ISBN ambapo tarakimu ya checksum inahesabiwa\nkuwa '4' badala ya '0' iliyotolewa, hivyo nambari ya ISBN iliyorekebishwa inarudishwa.",
      "tr": "Verilen bir ISBN numarasının doğruluğunu kontrol edin ve gerekirse düzeltin.\n\nFonksiyon, sağlanan ISBN numarasını ISBN standart kontrol toplamı hesaplamasına karşı kontrol eder.\nEğer kontrol toplamı doğruysa, fonksiyon \"Right\" döndürür. Eğer kontrol toplamı yanlışsa,\nfonksiyon düzeltilmiş ISBN numarasını döndürür.\n\nArgümanlar:\nisbn: Doğrulanacak ISBN numarasını temsil eden bir string. Format 'x-xxx-xxxxx-x' şeklinde olmalıdır,\nburada 'x' bir rakamdır ve son 'x' kontrol toplamı rakamını temsil eden 'X' de olabilir.\n\nDöndürür:\nBir string döndürür, eğer ISBN kontrol toplamı doğruysa \"Right\", eğer kontrol toplamı yanlışsa\ngirdinin formatında düzeltilmiş ISBN numarası döndürülür.\n\nÖrnekler:\n>>> verify_isbn(\"0-670-82162-4\")\n'Right'\n\n>>> verify_isbn(\"0-670-82162-0\")\n'0-670-82162-4'\n\nİkinci örnek, kontrol toplamı rakamının sağlanan '0' yerine '4' olarak hesaplandığı ISBN numarasının düzeltilmesini gösterir, bu nedenle düzeltilmiş ISBN döndürülür.",
      "vi": "Xác minh tính chính xác của một số ISBN được cung cấp và sửa nó nếu cần thiết.\n\nHàm kiểm tra số ISBN được cung cấp theo tính toán tổng kiểm tra tiêu chuẩn ISBN. Nếu tổng kiểm tra đúng, hàm trả về \"Right\". Nếu tổng kiểm tra sai, hàm trả về số ISBN đã được sửa.\n\nTham số:\nisbn: Một chuỗi đại diện cho số ISBN cần được xác minh. Định dạng nên là 'x-xxx-xxxxx-x', trong đó 'x' là một chữ số, và 'x' cuối cùng cũng có thể là 'X' đại diện cho chữ số tổng kiểm tra.\n\nTrả về:\nMột chuỗi là \"Right\" nếu tổng kiểm tra ISBN đúng, hoặc số ISBN đã được sửa trong cùng định dạng như đầu vào nếu tổng kiểm tra sai.\n\nVí dụ:\n>>> verify_isbn(\"0-670-82162-4\")\n'Right'\n\n>>> verify_isbn(\"0-670-82162-0\")\n'0-670-82162-4'\n\nVí dụ thứ hai cho thấy sự sửa chữa của số ISBN nơi chữ số tổng kiểm tra được tính là '4' thay vì '0' được cung cấp, do đó số ISBN đã được sửa được trả về."
    },
    "docstring_bertscore": {
      "es": "0.9895536310006131",
      "arb": "0.9368979087705505",
      "sw": "0.9764577313486019",
      "tr": "0.9748603458243194",
      "vi": "0.9803371813205943"
    }
  },
  {
    "task_id": "Python/15",
    "prompt": {
      "en": "def optimize_seating(M: int, N: int, K: int, L: int, D: int, chatting_pairs: list) -> (str, str):\n    \"\"\"\n    Optimize the placement of aisles in a classroom to minimize the amount of chatting between students.\n\n    Args:\n    M (int): The number of rows in the classroom.\n    N (int): The number of columns in the classroom.\n    K (int): The number of horizontal aisles to add.\n    L (int): The number of vertical aisles to add.\n    D (int): The number of chatting pairs in the classroom.\n    chatting_pairs (list of tuples): A list of tuples, each containing the positions (Xi, Yi) and (Pi, Qi) of a chatting pair.\n\n    Returns:\n    (str, str): Two space-separated strings representing the optimal row and column indices for the aisles.\n\n    The function works by counting the number of chatting pairs that can be separated by adding an aisle in each possible position.\n    It then selects the most effective positions for aisles, aiming to separate as many chatting pairs as possible.\n\n    Examples:\n    - optimize_seating(4, 5, 1, 2, 3, [(4, 2, 4, 3), (2, 3, 3, 3), (2, 5, 2, 4)])\n    Returns: ('2', '2 4'), indicating that placing an aisle after row 2 and columns 2 and 4 would be optimal.\n\n    - optimize_seating(3, 3, 1, 1, 2, [(1, 2, 1, 3), (2, 1, 3, 1)])\n    Returns: ('2', '2'), indicating that placing an aisle after row 2 and column 2 would be optimal.\n    \"\"\"",
      "es": "def optimize_seating(M: int, N: int, K: int, L: int, D: int, chatting_pairs: list) -> (str, str):\n    \"\"\"\n    Optimizar la colocación de pasillos en un aula para minimizar la cantidad de conversaciones entre estudiantes.\n\n    Argumentos:\n    M (int): El número de filas en el aula.\n    N (int): El número de columnas en el aula.\n    K (int): El número de pasillos horizontales a añadir.\n    L (int): El número de pasillos verticales a añadir.\n    D (int): El número de pares que conversan en el aula.\n    chatting_pairs (list of tuples): Una lista de tuplas, cada una contiene las posiciones (Xi, Yi) y (Pi, Qi) de un par que conversa.\n\n    Devuelve:\n    (str, str): Dos cadenas separadas por espacios que representan los índices óptimos de filas y columnas para los pasillos.\n\n    La función funciona contando el número de pares que conversan que pueden ser separados añadiendo un pasillo en cada posición posible.\n    Luego selecciona las posiciones más efectivas para los pasillos, con el objetivo de separar la mayor cantidad posible de pares que conversan.\n\n    Ejemplos:\n    - optimize_seating(4, 5, 1, 2, 3, [(4, 2, 4, 3), (2, 3, 3, 3), (2, 5, 2, 4)])\n    Devuelve: ('2', '2 4'), indicando que colocar un pasillo después de la fila 2 y las columnas 2 y 4 sería óptimo.\n\n    - optimize_seating(3, 3, 1, 1, 2, [(1, 2, 1, 3), (2, 1, 3, 1)])\n    Devuelve: ('2', '2'), indicando que colocar un pasillo después de la fila 2 y la columna 2 sería óptimo.\n    \"\"\"",
      "arb": "def optimize_seating(M: int, N: int, K: int, L: int, D: int, chatting_pairs: list) -> (str, str):\n    \"\"\"\n    تحسين وضع الممرات في الفصل الدراسي لتقليل كمية الدردشة بين الطلاب.\n\n    يعيدالحجج:\n    M (int): عدد الصفوف في الفصل الدراسي.\n    N (int): عدد الأعمدة في الفصل الدراسي.\n    K (int): عدد الممرات الأفقية التي سيتم إضافتها.\n    L (int): عدد الممرات الرأسية التي سيتم إضافتها.\n    D (int): عدد أزواج الدردشة في الفصل الدراسي.\n    chatting_pairs (list of tuples): قائمة من الأزواج، كل منها يحتوي على المواقع (Xi, Yi) و (Pi, Qi) لزوج دردشة.\n\n    يعيد:\n    (str, str): سلسلتان مفصولتان بمسافة تمثلان مؤشرات الصفوف والأعمدة المثلى للممرات.\n\n    تعمل الدالة عن طريق حساب عدد أزواج الدردشة التي يمكن فصلها بإضافة ممر في كل موقع ممكن.\n    ثم تختار المواقع الأكثر فعالية للممرات، بهدف فصل أكبر عدد ممكن من أزواج الدردشة.\n\n    أمثلة:\n    - optimize_seating(4, 5, 1, 2, 3, [(4, 2, 4, 3), (2, 3, 3, 3), (2, 5, 2, 4)])\n    يعيد: ('2', '2 4'), مما يشير إلى أن وضع ممر بعد الصف 2 والأعمدة 2 و4 سيكون الأمثل.\n\n    - optimize_seating(3, 3, 1, 1, 2, [(1, 2, 1, 3), (2, 1, 3, 1)])\n    يعيد: ('2', '2'), مما يشير إلى أن وضع ممر بعد الصف 2 والعمود 2 سيكون الأمثل.\n    \"\"\"",
      "sw": "def optimize_seating(M: int, N: int, K: int, L: int, D: int, chatting_pairs: list) -> (str, str):\n    \"\"\"\n    Boresha uwekaji wa njia za kupita darasani ili kupunguza mazungumzo kati ya wanafunzi.\n\n    Hoja:\n    M (int): Idadi ya mistari katika darasa.\n    N (int): Idadi ya safu katika darasa.\n    K (int): Idadi ya njia za mlalo za kuongeza.\n    L (int): Idadi ya njia za wima za kuongeza.\n    D (int): Idadi ya wanandoa wanaozungumza katika darasa.\n    chatting_pairs (list of tuples): Orodha ya jozi, kila moja ikiwa na nafasi (Xi, Yi) na (Pi, Qi) ya wanandoa wanaozungumza.\n\n    Inarejesha:\n    (str, str): Kamba mbili zilizotenganishwa na nafasi zinazoonyesha mistari na safu bora kwa njia za kupita.\n\n    Kazi hii inafanya kazi kwa kuhesabu idadi ya wanandoa wanaozungumza ambao wanaweza kutenganishwa kwa kuongeza njia ya kupita katika kila nafasi inayowezekana.\n    Kisha inachagua nafasi bora zaidi za njia za kupita, ikilenga kutenganisha wanandoa wengi wanaozungumza iwezekanavyo.\n\n    Mifano:\n    - optimize_seating(4, 5, 1, 2, 3, [(4, 2, 4, 3), (2, 3, 3, 3), (2, 5, 2, 4)])\n    Inarejesha: ('2', '2 4'), ikionyesha kuwa kuweka njia ya kupita baada ya mstari wa 2 na safu ya 2 na 4 itakuwa bora.\n\n    - optimize_seating(3, 3, 1, 1, 2, [(1, 2, 1, 3), (2, 1, 3, 1)])\n    Inarejesha: ('2', '2'), ikionyesha kuwa kuweka njia ya kupita baada ya mstari wa 2 na safu ya 2 itakuwa bora.\n    \"\"\"",
      "tr": "def optimize_seating(M: int, N: int, K: int, L: int, D: int, chatting_pairs: list) -> (str, str):\n    \"\"\"\n    Bir sınıfta öğrenciler arasındaki sohbet miktarını en aza indirmek için koridorların yerleştirilmesini optimize edin.\n\n    Argümanlar:\n    M (int): Sınıftaki sıra sayısı.\n    N (int): Sınıftaki sütun sayısı.\n    K (int): Eklenmesi gereken yatay koridor sayısı.\n    L (int): Eklenmesi gereken dikey koridor sayısı.\n    D (int): Sınıftaki sohbet eden çiftlerin sayısı.\n    chatting_pairs (list of tuples): Her biri bir sohbet eden çiftin (Xi, Yi) ve (Pi, Qi) pozisyonlarını içeren bir demet listesi.\n\n    Döndürür:\n    (str, str): Koridorlar için en uygun sıra ve sütun indekslerini temsil eden iki boşlukla ayrılmış string.\n\n    Fonksiyon, her olası pozisyonda bir koridor ekleyerek ayrılabilecek sohbet eden çiftlerin sayısını sayarak çalışır.\n    Daha sonra, mümkün olduğunca çok sohbet eden çifti ayırmayı hedefleyerek koridorlar için en etkili pozisyonları seçer.\n\n    Örnekler:\n    - optimize_seating(4, 5, 1, 2, 3, [(4, 2, 4, 3), (2, 3, 3, 3), (2, 5, 2, 4)])\n    Döndürür: ('2', '2 4'), bu da sıra 2'den sonra ve sütunlar 2 ve 4'ten sonra bir koridor yerleştirmenin optimal olacağını belirtir.\n\n    - optimize_seating(3, 3, 1, 1, 2, [(1, 2, 1, 3), (2, 1, 3, 1)])\n    Döndürür: ('2', '2'), bu da sıra 2'den sonra ve sütun 2'den sonra bir koridor yerleştirmenin optimal olacağını belirtir.\n    \"\"\"",
      "vi": "def optimize_seating(M: int, N: int, K: int, L: int, D: int, chatting_pairs: list) -> (str, str):\n    \"\"\"\n    Tối ưu hóa việc bố trí lối đi trong lớp học để giảm thiểu số lượng học sinh nói chuyện với nhau.\n\n    Tham số:\n    M (int): Số hàng trong lớp học.\n    N (int): Số cột trong lớp học.\n    K (int): Số lối đi ngang cần thêm.\n    L (int): Số lối đi dọc cần thêm.\n    D (int): Số cặp học sinh nói chuyện trong lớp.\n    chatting_pairs (list of tuples): Danh sách các bộ giá trị, mỗi bộ chứa vị trí (Xi, Yi) và (Pi, Qi) của một cặp học sinh nói chuyện.\n\n    Trả về:\n    (str, str): Hai chuỗi cách nhau bởi dấu cách đại diện cho chỉ số hàng và cột tối ưu để đặt lối đi.\n\n    Hàm hoạt động bằng cách đếm số lượng cặp học sinh nói chuyện có thể bị ngăn cách bằng cách thêm một lối đi ở mỗi vị trí có thể.\n    Sau đó, nó chọn các vị trí hiệu quả nhất cho lối đi, nhằm mục đích ngăn cách càng nhiều cặp học sinh nói chuyện càng tốt.\n\n    Ví dụ:\n    - optimize_seating(4, 5, 1, 2, 3, [(4, 2, 4, 3), (2, 3, 3, 3), (2, 5, 2, 4)])\n    Trả về: ('2', '2 4'), cho thấy rằng đặt một lối đi sau hàng 2 và các cột 2 và 4 sẽ là tối ưu.\n\n    - optimize_seating(3, 3, 1, 1, 2, [(1, 2, 1, 3), (2, 1, 3, 1)])\n    Trả về: ('2', '2'), cho thấy rằng đặt một lối đi sau hàng 2 và cột 2 sẽ là tối ưu.\n    \"\"\""
    },
    "prompt_bertscore": {
      "es": "0.9714111292576485",
      "arb": "0.9677666590264205",
      "sw": "0.9617825215369823",
      "tr": "0.9824591496811901",
      "vi": "0.9549305679128028"
    },
    "canonical_solution": "# Initialize the counter lists\n    row_counter = [0] * (M - 1)\n    col_counter = [0] * (N - 1)\n\n    # Process the pairs and update the counters\n    for Xi, Yi, Pi, Qi in chatting_pairs:\n        if Xi == Pi:  # Same row, different columns\n            col_counter[min(Yi, Qi) - 1] += 1\n        elif Yi == Qi:  # Same column, different rows\n            row_counter[min(Xi, Pi) - 1] += 1\n\n    # Sort the rows and columns with their original indices\n    sorted_rows = sorted(range(M - 1), key=lambda i: row_counter[i], reverse=True)\n    sorted_cols = sorted(range(N - 1), key=lambda i: col_counter[i], reverse=True)\n\n    # Select the positions for aisles\n    aisle_rows = sorted(sorted_rows[:K])\n    aisle_cols = sorted(sorted_cols[:L])\n\n    # Return the results as space-separated strings\n    return ' '.join(str(row + 1) for row in aisle_rows), ' '.join(str(col + 1) for col in aisle_cols)",
    "instruction": {
      "en": "def optimize_seating(M: int, N: int, K: int, L: int, D: int, chatting_pairs: list) -> (str, str):\n# Initialize the counter lists\n    row_counter = [0] * (M - 1)\n    col_counter = [0] * (N - 1)\n\n    # Process the pairs and update the counters\n    for Xi, Yi, Pi, Qi in chatting_pairs:\n        if Xi == Pi:  # Same row, different columns\n            col_counter[min(Yi, Qi) - 1] += 1\n        elif Yi == Qi:  # Same column, different rows\n            row_counter[min(Xi, Pi) - 1] += 1\n\n    # Sort the rows and columns with their original indices\n    sorted_rows = sorted(range(M - 1), key=lambda i: row_counter[i], reverse=True)\n    sorted_cols = sorted(range(N - 1), key=lambda i: col_counter[i], reverse=True)\n\n    # Select the positions for aisles\n    aisle_rows = sorted(sorted_rows[:K])\n    aisle_cols = sorted(sorted_cols[:L])\n\n    # Return the results as space-separated strings\n    return ' '.join(str(row + 1) for row in aisle_rows), ' '.join(str(col + 1) for col in aisle_cols)\n\nProvide a concise natural language description (docstring) of the Python code in English using at most 500 characters.",
      "es": "def optimize_seating(M: int, N: int, K: int, L: int, D: int, chatting_pairs: list) -> (str, str):\n# Initialize the counter lists\n    row_counter = [0] * (M - 1)\n    col_counter = [0] * (N - 1)\n\n    # Process the pairs and update the counters\n    for Xi, Yi, Pi, Qi in chatting_pairs:\n        if Xi == Pi:  # Same row, different columns\n            col_counter[min(Yi, Qi) - 1] += 1\n        elif Yi == Qi:  # Same column, different rows\n            row_counter[min(Xi, Pi) - 1] += 1\n\n    # Sort the rows and columns with their original indices\n    sorted_rows = sorted(range(M - 1), key=lambda i: row_counter[i], reverse=True)\n    sorted_cols = sorted(range(N - 1), key=lambda i: col_counter[i], reverse=True)\n\n    # Select the positions for aisles\n    aisle_rows = sorted(sorted_rows[:K])\n    aisle_cols = sorted(sorted_cols[:L])\n\n    # Return the results as space-separated strings\n    return ' '.join(str(row + 1) for row in aisle_rows), ' '.join(str(col + 1) for col in aisle_cols)\n\nProporcione una descripción concisa en lenguaje natural (docstring) del código Python en español utilizando como máximo 500 caracteres.",
      "arb": "def optimize_seating(M: int, N: int, K: int, L: int, D: int, chatting_pairs: list) -> (str, str):\n# Initialize the counter lists\n    row_counter = [0] * (M - 1)\n    col_counter = [0] * (N - 1)\n\n    # Process the pairs and update the counters\n    for Xi, Yi, Pi, Qi in chatting_pairs:\n        if Xi == Pi:  # Same row, different columns\n            col_counter[min(Yi, Qi) - 1] += 1\n        elif Yi == Qi:  # Same column, different rows\n            row_counter[min(Xi, Pi) - 1] += 1\n\n    # Sort the rows and columns with their original indices\n    sorted_rows = sorted(range(M - 1), key=lambda i: row_counter[i], reverse=True)\n    sorted_cols = sorted(range(N - 1), key=lambda i: col_counter[i], reverse=True)\n\n    # Select the positions for aisles\n    aisle_rows = sorted(sorted_rows[:K])\n    aisle_cols = sorted(sorted_cols[:L])\n\n    # Return the results as space-separated strings\n    return ' '.join(str(row + 1) for row in aisle_rows), ' '.join(str(col + 1) for col in aisle_cols)\n\nيرجى تقديم وصف موجز بلغة طبيعية (docstring) للشفرة البرمجية بلغة بايثون باللغة العربية الفصحى، بحيث لا يتجاوز 500 حرف.",
      "sw": "def optimize_seating(M: int, N: int, K: int, L: int, D: int, chatting_pairs: list) -> (str, str):\n# Initialize the counter lists\n    row_counter = [0] * (M - 1)\n    col_counter = [0] * (N - 1)\n\n    # Process the pairs and update the counters\n    for Xi, Yi, Pi, Qi in chatting_pairs:\n        if Xi == Pi:  # Same row, different columns\n            col_counter[min(Yi, Qi) - 1] += 1\n        elif Yi == Qi:  # Same column, different rows\n            row_counter[min(Xi, Pi) - 1] += 1\n\n    # Sort the rows and columns with their original indices\n    sorted_rows = sorted(range(M - 1), key=lambda i: row_counter[i], reverse=True)\n    sorted_cols = sorted(range(N - 1), key=lambda i: col_counter[i], reverse=True)\n\n    # Select the positions for aisles\n    aisle_rows = sorted(sorted_rows[:K])\n    aisle_cols = sorted(sorted_cols[:L])\n\n    # Return the results as space-separated strings\n    return ' '.join(str(row + 1) for row in aisle_rows), ' '.join(str(col + 1) for col in aisle_cols)\n\nToa maelezo mafupi ya lugha asilia (docstring) ya msimbo wa Python kwa Kiswahili kwa kutumia herufi zisizozidi 500.",
      "tr": "def optimize_seating(M: int, N: int, K: int, L: int, D: int, chatting_pairs: list) -> (str, str):\n# Initialize the counter lists\n    row_counter = [0] * (M - 1)\n    col_counter = [0] * (N - 1)\n\n    # Process the pairs and update the counters\n    for Xi, Yi, Pi, Qi in chatting_pairs:\n        if Xi == Pi:  # Same row, different columns\n            col_counter[min(Yi, Qi) - 1] += 1\n        elif Yi == Qi:  # Same column, different rows\n            row_counter[min(Xi, Pi) - 1] += 1\n\n    # Sort the rows and columns with their original indices\n    sorted_rows = sorted(range(M - 1), key=lambda i: row_counter[i], reverse=True)\n    sorted_cols = sorted(range(N - 1), key=lambda i: col_counter[i], reverse=True)\n\n    # Select the positions for aisles\n    aisle_rows = sorted(sorted_rows[:K])\n    aisle_cols = sorted(sorted_cols[:L])\n\n    # Return the results as space-separated strings\n    return ' '.join(str(row + 1) for row in aisle_rows), ' '.join(str(col + 1) for col in aisle_cols)\n\nPython kodunun işlevini açıklayan kısa bir doğal dil açıklaması (docstring) sağlayın. Açıklama, en fazla 500 karakter kullanılarak Türkçe olarak yazılmalıdır.",
      "vi": "def optimize_seating(M: int, N: int, K: int, L: int, D: int, chatting_pairs: list) -> (str, str):\n# Initialize the counter lists\n    row_counter = [0] * (M - 1)\n    col_counter = [0] * (N - 1)\n\n    # Process the pairs and update the counters\n    for Xi, Yi, Pi, Qi in chatting_pairs:\n        if Xi == Pi:  # Same row, different columns\n            col_counter[min(Yi, Qi) - 1] += 1\n        elif Yi == Qi:  # Same column, different rows\n            row_counter[min(Xi, Pi) - 1] += 1\n\n    # Sort the rows and columns with their original indices\n    sorted_rows = sorted(range(M - 1), key=lambda i: row_counter[i], reverse=True)\n    sorted_cols = sorted(range(N - 1), key=lambda i: col_counter[i], reverse=True)\n\n    # Select the positions for aisles\n    aisle_rows = sorted(sorted_rows[:K])\n    aisle_cols = sorted(sorted_cols[:L])\n\n    # Return the results as space-separated strings\n    return ' '.join(str(row + 1) for row in aisle_rows), ' '.join(str(col + 1) for col in aisle_cols)\n\nCung cấp mô tả ngắn gọn bằng ngôn ngữ tự nhiên (docstring) cho mã Python bằng tiếng Việt, không quá 500 ký tự."
    },
    "instruction_bertscore": {
      "es": "0.9687387561112052",
      "arb": "0.906469919330197",
      "sw": "0.9426438884331277",
      "tr": "0.878612207020435",
      "vi": "0.905718500598742"
    },
    "level": "",
    "test": "def test_optimize_seating():\n    test_cases = [\n        # Test case 1 from the provided example\n        {\n            'M': 4, 'N': 5, 'K': 1, 'L': 2, 'D': 3,\n            'chatting_pairs': [(4, 2, 4, 3), (2, 3, 3, 3), (2, 5, 2, 4)],\n            'expected': ('2', '2 4')\n        },\n        # Corrected Test case 2\n        {\n            'M': 5, 'N': 6, 'K': 2, 'L': 3, 'D': 4,\n            'chatting_pairs': [(1, 1, 1, 2), (2, 2, 3, 2), (4, 5, 4, 6), (5, 1, 5, 2)],\n            'expected': ('1 2', '1 2 5')  # Corrected expected output\n        },\n        # Test case 3\n        {\n            'M': 3, 'N': 3, 'K': 1, 'L': 1, 'D': 2,\n            'chatting_pairs': [(1, 2, 1, 3), (2, 1, 3, 1)],\n            'expected': ('2', '2')\n        },\n    ]\n\n    for i, test in enumerate(test_cases, 1):\n        row_output, col_output = optimize_seating(\n            test['M'], test['N'], test['K'], test['L'], test['D'], test['chatting_pairs']\n        )\n        assert row_output == test['expected'][0], f\"Test case {i} failed: row_output {row_output} does not match expected {test['expected'][0]}\"\n        assert col_output == test['expected'][1], f\"Test case {i} failed: col_output {col_output} does not match expected {test['expected'][1]}\"\n        print(f\"Test case {i} passed.\")\n\n# Run the test function\ntest_optimize_seating()",
    "entry_point": "optimize_seating",
    "signature": "def optimize_seating(M: int, N: int, K: int, L: int, D: int, chatting_pairs: list) -> (str, str):",
    "docstring": {
      "en": "Optimize the placement of aisles in a classroom to minimize the amount of chatting between students.\n\nArgs:\nM (int): The number of rows in the classroom.\nN (int): The number of columns in the classroom.\nK (int): The number of horizontal aisles to add.\nL (int): The number of vertical aisles to add.\nD (int): The number of chatting pairs in the classroom.\nchatting_pairs (list of tuples): A list of tuples, each containing the positions (Xi, Yi) and (Pi, Qi) of a chatting pair.\n\nReturns:\n(str, str): Two space-separated strings representing the optimal row and column indices for the aisles.\n\nThe function works by counting the number of chatting pairs that can be separated by adding an aisle in each possible position.\nIt then selects the most effective positions for aisles, aiming to separate as many chatting pairs as possible.\n\nExamples:\n- optimize_seating(4, 5, 1, 2, 3, [(4, 2, 4, 3), (2, 3, 3, 3), (2, 5, 2, 4)])\nReturns: ('2', '2 4'), indicating that placing an aisle after row 2 and columns 2 and 4 would be optimal.\n\n- optimize_seating(3, 3, 1, 1, 2, [(1, 2, 1, 3), (2, 1, 3, 1)])\nReturns: ('2', '2'), indicating that placing an aisle after row 2 and column 2 would be optimal.",
      "es": "Optimizar la colocación de los pasillos en un aula para minimizar la cantidad de charlas entre estudiantes.\n\nArgumentos:\nM (int): El número de filas en el aula.\nN (int): El número de columnas en el aula.\nK (int): El número de pasillos horizontales a añadir.\nL (int): El número de pasillos verticales a añadir.\nD (int): El número de pares que charlan en el aula.\nchatting_pairs (list of tuples): Una lista de tuplas, cada una conteniendo las posiciones (Xi, Yi) y (Pi, Qi) de un par que charla.\n\nDevuelve:\n(str, str): Dos cadenas separadas por espacios que representan los índices óptimos de filas y columnas para los pasillos.\n\nLa función trabaja contando el número de pares que charlan y que pueden ser separados añadiendo un pasillo en cada posición posible.\nLuego selecciona las posiciones más efectivas para los pasillos, con el objetivo de separar la mayor cantidad de pares que charlan posible.\n\nEjemplos:\n- optimize_seating(4, 5, 1, 2, 3, [(4, 2, 4, 3), (2, 3, 3, 3), (2, 5, 2, 4)])\nDevuelve: ('2', '2 4'), indicando que colocar un pasillo después de la fila 2 y las columnas 2 y 4 sería óptimo.\n\n- optimize_seating(3, 3, 1, 1, 2, [(1, 2, 1, 3), (2, 1, 3, 1)])\nDevuelve: ('2', '2'), indicando que colocar un pasillo después de la fila 2 y la columna 2 sería óptimo.",
      "arb": "تحسين وضع الممرات في الفصل الدراسي لتقليل كمية الدردشة بين الطلاب.\n\nيعيدالحجج:\nM (int): عدد الصفوف في الفصل الدراسي.\nN (int): عدد الأعمدة في الفصل الدراسي.\nK (int): عدد الممرات الأفقية التي يجب إضافتها.\nL (int): عدد الممرات العمودية التي يجب إضافتها.\nD (int): عدد أزواج الدردشة في الفصل الدراسي.\nchatting_pairs (list of tuples): قائمة من الأزواج، كل منها يحتوي على المواقع (Xi, Yi) و (Pi, Qi) لزوج دردشة.\n\nيعيد:\n(str, str): سلسلتان مفصولتان بمسافة تمثلان مؤشرات الصفوف والأعمدة المثلى للممرات.\n\nتعمل الدالة عن طريق حساب عدد أزواج الدردشة التي يمكن فصلها بإضافة ممر في كل موضع ممكن.\nثم تختار المواضع الأكثر فعالية للممرات، بهدف فصل أكبر عدد ممكن من أزواج الدردشة.\n\nامثله:\n- optimize_seating(4, 5, 1, 2, 3, [(4, 2, 4, 3), (2, 3, 3, 3), (2, 5, 2, 4)])\nيعيد: ('2', '2 4')، مما يشير إلى أن وضع ممر بعد الصف 2 والأعمدة 2 و 4 سيكون الأمثل.\n\n- optimize_seating(3, 3, 1, 1, 2, [(1, 2, 1, 3), (2, 1, 3, 1)])\nيعيد: ('2', '2')، مما يشير إلى أن وضع ممر بعد الصف 2 والعمود 2 سيكون الأمثل.",
      "sw": "Optimize uwekaji wa njia za kupita darasani ili kupunguza mazungumzo kati ya wanafunzi.\n\nHoja:\nM (int): Idadi ya safu katika darasa.\nN (int): Idadi ya safu wima katika darasa.\nK (int): Idadi ya njia za kupita za usawa za kuongeza.\nL (int): Idadi ya njia za kupita za wima za kuongeza.\nD (int): Idadi ya jozi za wanaozungumza darasani.\nchatting_pairs (list of tuples): Orodha ya jozi, kila moja ikiwa na nafasi (Xi, Yi) na (Pi, Qi) ya jozi inayozungumza.\n\nInarejesha:\n(str, str): Mistari miwili iliyotenganishwa na nafasi inayoonyesha faharasa bora za safu na safu wima kwa ajili ya njia za kupita.\n\nKazi hii inafanya kazi kwa kuhesabu idadi ya jozi za wanaozungumza ambazo zinaweza kutenganishwa kwa kuongeza njia ya kupita katika kila nafasi inayowezekana. Kisha inachagua nafasi bora zaidi za njia za kupita, ikilenga kutenganisha jozi nyingi za wanaozungumza iwezekanavyo.\n\nMifano:\n- optimize_seating(4, 5, 1, 2, 3, [(4, 2, 4, 3), (2, 3, 3, 3), (2, 5, 2, 4)])\nInarejesha: ('2', '2 4'), ikionyesha kwamba kuweka njia ya kupita baada ya safu ya 2 na safu wima 2 na 4 itakuwa bora.\n\n- optimize_seating(3, 3, 1, 1, 2, [(1, 2, 1, 3), (2, 1, 3, 1)])\nInarejesha: ('2', '2'), ikionyesha kwamba kuweka njia ya kupita baada ya safu ya 2 na safu wima ya 2 itakuwa bora.",
      "tr": "Sınıfta koridorların yerleşimini optimize ederek öğrenciler arasındaki konuşma miktarını en aza indirin.\n\nArgümanlar:\nM (int): Sınıftaki sıra sayısı.\nN (int): Sınıftaki sütun sayısı.\nK (int): Eklenecek yatay koridor sayısı.\nL (int): Eklenecek dikey koridor sayısı.\nD (int): Sınıftaki konuşan çiftlerin sayısı.\nchatting_pairs (list of tuples): Her biri bir konuşan çiftin pozisyonlarını (Xi, Yi) ve (Pi, Qi) içeren bir demet listesi.\n\nDöndürür:\n(str, str): Koridorlar için en uygun sıra ve sütun indekslerini temsil eden iki boşlukla ayrılmış string.\n\nFonksiyon, her olası pozisyonda bir koridor ekleyerek ayrılabilecek konuşan çiftlerin sayısını sayarak çalışır.\nDaha sonra, mümkün olduğunca çok konuşan çifti ayırmayı hedefleyerek koridorlar için en etkili pozisyonları seçer.\n\nÖrnekler:\n- optimize_seating(4, 5, 1, 2, 3, [(4, 2, 4, 3), (2, 3, 3, 3), (2, 5, 2, 4)])\nDöndürür: ('2', '2 4'), bu, sıra 2'den sonra ve sütunlar 2 ve 4'ten sonra bir koridor yerleştirmenin optimal olacağını belirtir.\n\n- optimize_seating(3, 3, 1, 1, 2, [(1, 2, 1, 3), (2, 1, 3, 1)])\nDöndürür: ('2', '2'), bu, sıra 2'den sonra ve sütun 2'den sonra bir koridor yerleştirmenin optimal olacağını belirtir.",
      "vi": "Tối ưu hóa việc bố trí lối đi trong một lớp học để giảm thiểu lượng trò chuyện giữa các học sinh.\n\nTham số:\nM (int): Số hàng trong lớp học.\nN (int): Số cột trong lớp học.\nK (int): Số lối đi ngang cần thêm.\nL (int): Số lối đi dọc cần thêm.\nD (int): Số cặp trò chuyện trong lớp học.\nchatting_pairs (list of tuples): Một danh sách các bộ giá trị, mỗi bộ chứa vị trí (Xi, Yi) và (Pi, Qi) của một cặp trò chuyện.\n\nTrả về:\n(str, str): Hai chuỗi cách nhau bởi dấu cách đại diện cho chỉ số hàng và cột tối ưu cho các lối đi.\n\nHàm hoạt động bằng cách đếm số cặp trò chuyện có thể được tách ra bằng cách thêm một lối đi ở mỗi vị trí có thể.\nSau đó, nó chọn các vị trí hiệu quả nhất cho các lối đi, nhằm tách ra càng nhiều cặp trò chuyện càng tốt.\n\nVí dụ:\n- optimize_seating(4, 5, 1, 2, 3, [(4, 2, 4, 3), (2, 3, 3, 3), (2, 5, 2, 4)])\nTrả về: ('2', '2 4'), chỉ ra rằng việc đặt một lối đi sau hàng 2 và các cột 2 và 4 sẽ là tối ưu.\n\n- optimize_seating(3, 3, 1, 1, 2, [(1, 2, 1, 3), (2, 1, 3, 1)])\nTrả về: ('2', '2'), chỉ ra rằng việc đặt một lối đi sau hàng 2 và cột 2 sẽ là tối ưu."
    },
    "docstring_bertscore": {
      "es": "0.9896360626087426",
      "arb": "0.9661090884966843",
      "sw": "0.9477359768813381",
      "tr": "0.9610525548866792",
      "vi": "0.9382581296198774"
    }
  },
  {
    "task_id": "Python/16",
    "prompt": {
      "en": "def count_passing_ways(n: int, m: int) -> int:\n    \"\"\"\n    Counts the number of different ways to pass a ball among 'n' students arranged in a circle \n    such that after 'm' passes, the ball returns to the starting student.\n\n    The function uses dynamic programming to determine the number of passing sequences. Each student\n    can pass the ball either to the left neighbor or to the right neighbor.\n\n    Args:\n    n: The number of students standing in a circle.\n    m: The number of times the ball is passed.\n\n    Returns:\n    An integer representing the number of distinct passing ways that result in the ball\n    returning to the starting student after 'm' passes.\n\n    Cases:\n    Case 1:\n    For n = 3 students and m = 3 passes, the function should return 2.\n    There are two sequences: 1 -> 2 -> 3 -> 1 and 1 -> 3 -> 2 -> 1.\n\n    Case 2:\n    For n = 4 students and m = 2 passes, the function should return 2.\n    There are two sequences: 1 -> 2 -> 1 and 1 -> 4 -> 1.\n\n    Case 3:\n    For n = 5 students and m = 4 passes, the function should return 6.\n    The sequences include: 1 -> 2 -> 3 -> 4 -> 1, 1 -> 2 -> 1 -> 2 -> 1, \n    1 -> 4 -> 3 -> 2 -> 1, 1 -> 4 -> 5 -> 4 -> 1, 1 -> 2 -> 3 -> 2 -> 1,\n    and 1 -> 4 -> 5 -> 2 -> 1.\n    \"\"\"\n    # The code implementation would go here.",
      "es": "def count_passing_ways(n: int, m: int) -> int:\n    \"\"\"\n    Cuenta el número de diferentes maneras de pasar una pelota entre 'n' estudiantes dispuestos en un círculo\n    de tal manera que después de 'm' pases, la pelota regrese al estudiante inicial.\n\n    La función utiliza programación dinámica para determinar el número de secuencias de pases. Cada estudiante\n    puede pasar la pelota ya sea al vecino de la izquierda o al vecino de la derecha.\n\n    Argumentos:\n    n: El número de estudiantes de pie en un círculo.\n    m: El número de veces que se pasa la pelota.\n\n    Devuelve:\n    Un entero que representa el número de maneras distintas de pasar que resultan en que la pelota\n    regrese al estudiante inicial después de 'm' pases.\n\n    Casos:\n    Caso 1:\n    Para n = 3 estudiantes y m = 3 pases, la función debería devolver 2.\n    Hay dos secuencias: 1 -> 2 -> 3 -> 1 y 1 -> 3 -> 2 -> 1.\n\n    Caso 2:\n    Para n = 4 estudiantes y m = 2 pases, la función debería devolver 2.\n    Hay dos secuencias: 1 -> 2 -> 1 y 1 -> 4 -> 1.\n\n    Caso 3:\n    Para n = 5 estudiantes y m = 4 pases, la función debería devolver 6.\n    Las secuencias incluyen: 1 -> 2 -> 3 -> 4 -> 1, 1 -> 2 -> 1 -> 2 -> 1,\n    1 -> 4 -> 3 -> 2 -> 1, 1 -> 4 -> 5 -> 4 -> 1, 1 -> 2 -> 3 -> 2 -> 1,\n    y 1 -> 4 -> 5 -> 2 -> 1.\n    \"\"\"\n    # La implementación del código iría aquí.",
      "arb": "def count_passing_ways(n: int, m: int) -> int:\n    \"\"\"\n    يحسب عدد الطرق المختلفة لتمرير الكرة بين 'n' طلاب مرتبين في دائرة\n    بحيث بعد 'm' تمريرات، تعود الكرة إلى الطالب الذي بدأ التمرير.\n\n    تستخدم الدالة البرمجة الديناميكية لتحديد عدد تسلسلات التمرير. يمكن لكل طالب\n    تمرير الكرة إما إلى الجار الأيسر أو إلى الجار الأيمن.\n\n    يعيدالحجج:\n    n: عدد الطلاب الواقفين في دائرة.\n    m: عدد المرات التي يتم فيها تمرير الكرة.\n\n    يعيد:\n    عدد صحيح يمثل عدد طرق التمرير المميزة التي تؤدي إلى\n    عودة الكرة إلى الطالب الذي بدأ التمرير بعد 'm' تمريرات.\n\n    الحالات:\n    الحالة 1:\n    بالنسبة لـ n = 3 طلاب و m = 3 تمريرات، يجب أن تعيد الدالة 2.\n    هناك تسلسلان: 1 -> 2 -> 3 -> 1 و 1 -> 3 -> 2 -> 1.\n\n    الحالة 2:\n    بالنسبة لـ n = 4 طلاب و m = 2 تمريرات، يجب أن تعيد الدالة 2.\n    هناك تسلسلان: 1 -> 2 -> 1 و 1 -> 4 -> 1.\n\n    الحالة 3:\n    بالنسبة لـ n = 5 طلاب و m = 4 تمريرات، يجب أن تعيد الدالة 6.\n    تشمل التسلسلات: 1 -> 2 -> 3 -> 4 -> 1, 1 -> 2 -> 1 -> 2 -> 1,\n    1 -> 4 -> 3 -> 2 -> 1, 1 -> 4 -> 5 -> 4 -> 1, 1 -> 2 -> 3 -> 2 -> 1,\n    و 1 -> 4 -> 5 -> 2 -> 1.\n    \"\"\"\n    # سيتم وضع تنفيذ الكود هنا.",
      "sw": "def count_passing_ways(n: int, m: int) -> int:\n    \"\"\"\n    Inahesabu idadi ya njia tofauti za kupitisha mpira kati ya wanafunzi 'n' waliopangwa katika duara \n    kiasi kwamba baada ya kupitisha 'm', mpira unarudi kwa mwanafunzi wa kuanzia.\n\n    Kazi hii inatumia programu ya nguvu ili kubaini idadi ya mfuatano wa kupitisha. Kila mwanafunzi\n    anaweza kupitisha mpira kwa jirani wa kushoto au kwa jirani wa kulia.\n\n    Hoja:\n    n: Idadi ya wanafunzi waliokuwa wamesimama katika duara.\n    m: Idadi ya mara ambazo mpira unapita.\n\n    Inarejesha:\n    Namba kamili inayowakilisha idadi ya njia tofauti za kupitisha ambazo zinasababisha mpira\n    kurudi kwa mwanafunzi wa kuanzia baada ya kupitisha 'm'.\n\n    Kesi:\n    Kesi 1:\n    Kwa n = wanafunzi 3 na m = kupitisha 3, kazi inapaswa kurudisha 2.\n    Kuna mfuatano miwili: 1 -> 2 -> 3 -> 1 na 1 -> 3 -> 2 -> 1.\n\n    Kesi 2:\n    Kwa n = wanafunzi 4 na m = kupitisha 2, kazi inapaswa kurudisha 2.\n    Kuna mfuatano miwili: 1 -> 2 -> 1 na 1 -> 4 -> 1.\n\n    Kesi 3:\n    Kwa n = wanafunzi 5 na m = kupitisha 4, kazi inapaswa kurudisha 6.\n    Mfuatano unajumuisha: 1 -> 2 -> 3 -> 4 -> 1, 1 -> 2 -> 1 -> 2 -> 1, \n    1 -> 4 -> 3 -> 2 -> 1, 1 -> 4 -> 5 -> 4 -> 1, 1 -> 2 -> 3 -> 2 -> 1,\n    na 1 -> 4 -> 5 -> 2 -> 1.\n    \"\"\"\n    # Utekelezaji wa msimbo ungekuwa hapa.",
      "tr": "def count_passing_ways(n: int, m: int) -> int:\n    \"\"\"\n    'n' öğrencinin bir daire şeklinde dizildiği bir durumda, topun 'm' pas sonrasında\n    başlangıçtaki öğrenciye geri dönmesi için farklı pas verme yollarının sayısını sayar.\n\n    Fonksiyon, pas verme dizilerinin sayısını belirlemek için dinamik programlama kullanır.\n    Her öğrenci topu ya sol komşusuna ya da sağ komşusuna verebilir.\n\n    Argümanlar:\n    n: Bir dairede duran öğrenci sayısı.\n    m: Topun kaç kez paslandığı.\n\n    Döndürür:\n    'm' pas sonrasında topun başlangıçtaki öğrenciye geri dönmesiyle sonuçlanan\n    farklı pas verme yollarının sayısını temsil eden bir tamsayı.\n\n    Durumlar:\n    Durum 1:\n    n = 3 öğrenci ve m = 3 pas için, fonksiyon 2 döndürmelidir.\n    İki dizi vardır: 1 -> 2 -> 3 -> 1 ve 1 -> 3 -> 2 -> 1.\n\n    Durum 2:\n    n = 4 öğrenci ve m = 2 pas için, fonksiyon 2 döndürmelidir.\n    İki dizi vardır: 1 -> 2 -> 1 ve 1 -> 4 -> 1.\n\n    Durum 3:\n    n = 5 öğrenci ve m = 4 pas için, fonksiyon 6 döndürmelidir.\n    Diziler şunları içerir: 1 -> 2 -> 3 -> 4 -> 1, 1 -> 2 -> 1 -> 2 -> 1,\n    1 -> 4 -> 3 -> 2 -> 1, 1 -> 4 -> 5 -> 4 -> 1, 1 -> 2 -> 3 -> 2 -> 1,\n    ve 1 -> 4 -> 5 -> 2 -> 1.\n    \"\"\"\n    # Kod uygulaması burada yer alacaktır.",
      "vi": "def count_passing_ways(n: int, m: int) -> int:\n    \"\"\"\n    Đếm số cách khác nhau để chuyền bóng giữa 'n' học sinh được sắp xếp thành một vòng tròn \n    sao cho sau 'm' lần chuyền, bóng trở lại học sinh bắt đầu.\n\n    Hàm sử dụng lập trình động để xác định số lượng chuỗi chuyền bóng. Mỗi học sinh\n    có thể chuyền bóng cho người bên trái hoặc người bên phải.\n\n    Tham số:\n    n: Số lượng học sinh đứng thành vòng tròn.\n    m: Số lần bóng được chuyền.\n\n    Trả về:\n    Một số nguyên đại diện cho số cách chuyền bóng khác nhau mà kết quả là bóng\n    trở lại học sinh bắt đầu sau 'm' lần chuyền.\n\n    Các trường hợp:\n    Trường hợp 1:\n    Với n = 3 học sinh và m = 3 lần chuyền, hàm sẽ trả về 2.\n    Có hai chuỗi: 1 -> 2 -> 3 -> 1 và 1 -> 3 -> 2 -> 1.\n\n    Trường hợp 2:\n    Với n = 4 học sinh và m = 2 lần chuyền, hàm sẽ trả về 2.\n    Có hai chuỗi: 1 -> 2 -> 1 và 1 -> 4 -> 1.\n\n    Trường hợp 3:\n    Với n = 5 học sinh và m = 4 lần chuyền, hàm sẽ trả về 6.\n    Các chuỗi bao gồm: 1 -> 2 -> 3 -> 4 -> 1, 1 -> 2 -> 1 -> 2 -> 1, \n    1 -> 4 -> 3 -> 2 -> 1, 1 -> 4 -> 5 -> 4 -> 1, 1 -> 2 -> 3 -> 2 -> 1,\n    và 1 -> 4 -> 5 -> 2 -> 1.\n    \"\"\"\n    # Phần triển khai mã sẽ được đặt ở đây."
    },
    "prompt_bertscore": {
      "es": "0.9941008763136449",
      "arb": "0.9678973578171414",
      "sw": "0.9701875661104736",
      "tr": "0.9731477546790366",
      "vi": "0.9625367210937719"
    },
    "canonical_solution": "    # Initialize the DP table\n    dp = [[0] * n for _ in range(m + 1)]\n\n    # Base case\n    dp[0][0] = 1\n\n    # Fill the DP table\n    for i in range(1, m + 1):\n        for j in range(n):\n            # Calculate the number of ways to pass the ball to j-th student\n            dp[i][j] = dp[i - 1][(j - 1 + n) % n] + dp[i - 1][(j + 1) % n]\n\n    # Return the result\n    return dp[m][0]",
    "instruction": {
      "en": "def count_passing_ways(n: int, m: int) -> int:\n    # Initialize the DP table\n    dp = [[0] * n for _ in range(m + 1)]\n\n    # Base case\n    dp[0][0] = 1\n\n    # Fill the DP table\n    for i in range(1, m + 1):\n        for j in range(n):\n            # Calculate the number of ways to pass the ball to j-th student\n            dp[i][j] = dp[i - 1][(j - 1 + n) % n] + dp[i - 1][(j + 1) % n]\n\n    # Return the result\n    return dp[m][0]\n\nProvide a concise natural language description (docstring) of the Python code in English using at most 500 characters.",
      "es": "def count_passing_ways(n: int, m: int) -> int:\n    # Initialize the DP table\n    dp = [[0] * n for _ in range(m + 1)]\n\n    # Base case\n    dp[0][0] = 1\n\n    # Fill the DP table\n    for i in range(1, m + 1):\n        for j in range(n):\n            # Calculate the number of ways to pass the ball to j-th student\n            dp[i][j] = dp[i - 1][(j - 1 + n) % n] + dp[i - 1][(j + 1) % n]\n\n    # Return the result\n    return dp[m][0]\n\nProporcione una descripción concisa en lenguaje natural (docstring) del código Python en español utilizando como máximo 500 caracteres.",
      "arb": "def count_passing_ways(n: int, m: int) -> int:\n    # Initialize the DP table\n    dp = [[0] * n for _ in range(m + 1)]\n\n    # Base case\n    dp[0][0] = 1\n\n    # Fill the DP table\n    for i in range(1, m + 1):\n        for j in range(n):\n            # Calculate the number of ways to pass the ball to j-th student\n            dp[i][j] = dp[i - 1][(j - 1 + n) % n] + dp[i - 1][(j + 1) % n]\n\n    # Return the result\n    return dp[m][0]\n\nيرجى تقديم وصف موجز بلغة طبيعية (docstring) للكود البرمجي بلغة بايثون باللغة العربية الفصحى باستخدام 500 حرف كحد أقصى.",
      "sw": "def count_passing_ways(n: int, m: int) -> int:\n    # Initialize the DP table\n    dp = [[0] * n for _ in range(m + 1)]\n\n    # Base case\n    dp[0][0] = 1\n\n    # Fill the DP table\n    for i in range(1, m + 1):\n        for j in range(n):\n            # Calculate the number of ways to pass the ball to j-th student\n            dp[i][j] = dp[i - 1][(j - 1 + n) % n] + dp[i - 1][(j + 1) % n]\n\n    # Return the result\n    return dp[m][0]\n\nToa maelezo mafupi ya lugha ya asili (docstring) ya msimbo wa Python kwa Kiswahili kwa kutumia herufi zisizozidi 500.",
      "tr": "def count_passing_ways(n: int, m: int) -> int:\n    # Initialize the DP table\n    dp = [[0] * n for _ in range(m + 1)]\n\n    # Base case\n    dp[0][0] = 1\n\n    # Fill the DP table\n    for i in range(1, m + 1):\n        for j in range(n):\n            # Calculate the number of ways to pass the ball to j-th student\n            dp[i][j] = dp[i - 1][(j - 1 + n) % n] + dp[i - 1][(j + 1) % n]\n\n    # Return the result\n    return dp[m][0]\n\nVerilen Python kodunun işlevini açıklayan, en fazla 500 karakter uzunluğunda, özlü bir doğal dil açıklaması (docstring) sağlayın.",
      "vi": "def count_passing_ways(n: int, m: int) -> int:\n    # Initialize the DP table\n    dp = [[0] * n for _ in range(m + 1)]\n\n    # Base case\n    dp[0][0] = 1\n\n    # Fill the DP table\n    for i in range(1, m + 1):\n        for j in range(n):\n            # Calculate the number of ways to pass the ball to j-th student\n            dp[i][j] = dp[i - 1][(j - 1 + n) % n] + dp[i - 1][(j + 1) % n]\n\n    # Return the result\n    return dp[m][0]\n\nCung cấp mô tả ngắn gọn bằng ngôn ngữ tự nhiên (docstring) cho mã Python bằng tiếng Việt với tối đa 500 ký tự."
    },
    "instruction_bertscore": {
      "es": "0.9687387561112052",
      "arb": "0.924699818440817",
      "sw": "0.914896018724078",
      "tr": "0.8508820154152974",
      "vi": "0.9016493586128613"
    },
    "level": "",
    "test": "def test_count_passing_ways():\n    test_cases = [\n        # Test case 1: simple case\n        {\n            'n': 3,\n            'm': 1,\n            'expected': 0\n        },\n        # Test case 2: another simple case\n        {\n            'n': 4,\n            'm': 2,\n            'expected': 2\n        },\n        # Test case 3: larger number of students and passes\n        {\n            'n': 5,\n            'm': 3,\n            'expected': 0\n        },\n    ]\n\n    for i, test in enumerate(test_cases, 1):\n        result = count_passing_ways(test['n'], test['m'])\n        assert result == test['expected'], f\"Test case {i} failed: result {result} does not match expected {test['expected']}\"\n        print(f\"Test case {i} passed with result {result}.\")\n\n# Run the test function\ntest_count_passing_ways()",
    "entry_point": "count_passing_ways",
    "signature": "def count_passing_ways(n: int, m: int) -> int:",
    "docstring": {
      "en": "Counts the number of different ways to pass a ball among 'n' students arranged in a circle\nsuch that after 'm' passes, the ball returns to the starting student.\n\nThe function uses dynamic programming to determine the number of passing sequences. Each student\ncan pass the ball either to the left neighbor or to the right neighbor.\n\nArgs:\nn: The number of students standing in a circle.\nm: The number of times the ball is passed.\n\nReturns:\nAn integer representing the number of distinct passing ways that result in the ball\nreturning to the starting student after 'm' passes.\n\nCases:\nCase 1:\nFor n = 3 students and m = 3 passes, the function should return 2.\nThere are two sequences: 1 -> 2 -> 3 -> 1 and 1 -> 3 -> 2 -> 1.\n\nCase 2:\nFor n = 4 students and m = 2 passes, the function should return 2.\nThere are two sequences: 1 -> 2 -> 1 and 1 -> 4 -> 1.\n\nCase 3:\nFor n = 5 students and m = 4 passes, the function should return 6.\nThe sequences include: 1 -> 2 -> 3 -> 4 -> 1, 1 -> 2 -> 1 -> 2 -> 1,\n1 -> 4 -> 3 -> 2 -> 1, 1 -> 4 -> 5 -> 4 -> 1, 1 -> 2 -> 3 -> 2 -> 1,\nand 1 -> 4 -> 5 -> 2 -> 1.",
      "es": "Cuenta el número de diferentes maneras de pasar una pelota entre 'n' estudiantes dispuestos en un círculo de tal manera que después de 'm' pases, la pelota regrese al estudiante inicial.\n\nLa función utiliza programación dinámica para determinar el número de secuencias de pases. Cada estudiante puede pasar la pelota ya sea al vecino de la izquierda o al vecino de la derecha.\n\nArgumentos:\nn: El número de estudiantes parados en un círculo.\nm: El número de veces que se pasa la pelota.\n\nDevuelve:\nUn entero que representa el número de maneras distintas de pasar la pelota que resultan en que la pelota regrese al estudiante inicial después de 'm' pases.\n\nCases:\nCase 1:\nPara n = 3 estudiantes y m = 3 pases, la función debería devolver 2.\nHay dos secuencias: 1 -> 2 -> 3 -> 1 y 1 -> 3 -> 2 -> 1.\n\nCase 2:\nPara n = 4 estudiantes y m = 2 pases, la función debería devolver 2.\nHay dos secuencias: 1 -> 2 -> 1 y 1 -> 4 -> 1.\n\nCase 3:\nPara n = 5 estudiantes y m = 4 pases, la función debería devolver 6.\nLas secuencias incluyen: 1 -> 2 -> 3 -> 4 -> 1, 1 -> 2 -> 1 -> 2 -> 1,\n1 -> 4 -> 3 -> 2 -> 1, 1 -> 4 -> 5 -> 4 -> 1, 1 -> 2 -> 3 -> 2 -> 1,\ny 1 -> 4 -> 5 -> 2 -> 1.",
      "arb": "يحسب عدد الطرق المختلفة لتمرير الكرة بين 'n' طلاب مرتبين في دائرة بحيث بعد 'm' تمريرات، تعود الكرة إلى الطالب الذي بدأ التمرير.\n\nتستخدم الدالة البرمجة الديناميكية لتحديد عدد تسلسلات التمرير. يمكن لكل طالب تمرير الكرة إما إلى الجار الأيسر أو إلى الجار الأيمن.\n\nالمعطيات:\nn: عدد الطلاب الواقفين في دائرة.\nm: عدد المرات التي يتم فيها تمرير الكرة.\n\nالقيم المعادة:\nعدد صحيح يمثل عدد الطرق المختلفة للتمرير التي تؤدي إلى عودة الكرة إلى الطالب الذي بدأ التمرير بعد 'm' تمريرات.\n\nالحالات:\nالحالة 1:\nبالنسبة لعدد n = 3 طلاب و m = 3 تمريرات، يجب أن تعيد الدالة 2.\nهناك تسلسلان: 1 -> 2 -> 3 -> 1 و 1 -> 3 -> 2 -> 1.\n\nالحالة 2:\nبالنسبة لعدد n = 4 طلاب و m = 2 تمريرات، يجب أن تعيد الدالة 2.\nهناك تسلسلان: 1 -> 2 -> 1 و 1 -> 4 -> 1.\n\nالحالة 3:\nبالنسبة لعدد n = 5 طلاب و m = 4 تمريرات، يجب أن تعيد الدالة 6.\nتشمل التسلسلات: 1 -> 2 -> 3 -> 4 -> 1, 1 -> 2 -> 1 -> 2 -> 1,\n1 -> 4 -> 3 -> 2 -> 1, 1 -> 4 -> 5 -> 4 -> 1, 1 -> 2 -> 3 -> 2 -> 1,\nو 1 -> 4 -> 5 -> 2 -> 1.",
      "sw": "Hesabu idadi ya njia tofauti za kupitisha mpira kati ya wanafunzi 'n' waliopangwa katika mduara\nhivyo kwamba baada ya kupitisha 'm', mpira unarudi kwa mwanafunzi wa kuanzia.\n\nKazi hii inatumia programu ya nguvu kuamua idadi ya mfuatano wa kupitisha. Kila mwanafunzi\nanaweza kupitisha mpira ama kwa jirani wa kushoto au kwa jirani wa kulia.\n\nHoja:\nn: Idadi ya wanafunzi waliopo katika mduara.\nm: Idadi ya mara ambazo mpira unapita.\n\nInarejesha:\nNambari kamili inayowakilisha idadi ya njia tofauti za kupitisha ambazo zinasababisha mpira\nkurudi kwa mwanafunzi wa kuanzia baada ya kupitisha 'm'.\n\nCases:\nCase 1:\nKwa n = wanafunzi 3 na m = kupitisha 3, kazi inapaswa kurudisha 2.\nKuna mfuatano miwili: 1 -> 2 -> 3 -> 1 na 1 -> 3 -> 2 -> 1.\n\nCase 2:\nKwa n = wanafunzi 4 na m = kupitisha 2, kazi inapaswa kurudisha 2.\nKuna mfuatano miwili: 1 -> 2 -> 1 na 1 -> 4 -> 1.\n\nCase 3:\nKwa n = wanafunzi 5 na m = kupitisha 4, kazi inapaswa kurudisha 6.\nMfuatano unajumuisha: 1 -> 2 -> 3 -> 4 -> 1, 1 -> 2 -> 1 -> 2 -> 1,\n1 -> 4 -> 3 -> 2 -> 1, 1 -> 4 -> 5 -> 4 -> 1, 1 -> 2 -> 3 -> 2 -> 1,\nna 1 -> 4 -> 5 -> 2 -> 1.",
      "tr": "Farklı sayıda topu, bir daire içinde düzenlenmiş 'n' öğrenci arasında\nöyle bir şekilde geçirme yollarını sayar ki, 'm' paslaşmadan sonra top başlangıçtaki öğrenciye geri döner.\n\nFonksiyon, paslaşma dizilerinin sayısını belirlemek için dinamik programlama kullanır. Her öğrenci\ntopu ya sol komşusuna ya da sağ komşusuna geçirebilir.\n\nArgümanlar:\nn: Bir daire içinde duran öğrenci sayısı.\nm: Topun kaç kez paslandığı.\n\nDöndürür:\n'm' paslaşmadan sonra topun başlangıçtaki öğrenciye geri dönmesiyle sonuçlanan\nfarklı paslaşma yollarının sayısını temsil eden bir tamsayı.\n\nDurumlar:\nDurum 1:\nn = 3 öğrenci ve m = 3 pas için, fonksiyon 2 döndürmelidir.\nİki dizi vardır: 1 -> 2 -> 3 -> 1 ve 1 -> 3 -> 2 -> 1.\n\nDurum 2:\nn = 4 öğrenci ve m = 2 pas için, fonksiyon 2 döndürmelidir.\nİki dizi vardır: 1 -> 2 -> 1 ve 1 -> 4 -> 1.\n\nDurum 3:\nn = 5 öğrenci ve m = 4 pas için, fonksiyon 6 döndürmelidir.\nDiziler şunları içerir: 1 -> 2 -> 3 -> 4 -> 1, 1 -> 2 -> 1 -> 2 -> 1,\n1 -> 4 -> 3 -> 2 -> 1, 1 -> 4 -> 5 -> 4 -> 1, 1 -> 2 -> 3 -> 2 -> 1,\nve 1 -> 4 -> 5 -> 2 -> 1.",
      "vi": "Đếm số cách khác nhau để chuyền một quả bóng giữa 'n' học sinh được sắp xếp thành một vòng tròn\nsao cho sau 'm' lần chuyền, quả bóng trở về học sinh bắt đầu.\n\nHàm sử dụng lập trình động để xác định số lượng chuỗi chuyền bóng. Mỗi học sinh\ncó thể chuyền bóng cho người bên trái hoặc người bên phải.\n\nTham số:\nn: Số lượng học sinh đứng thành vòng tròn.\nm: Số lần quả bóng được chuyền.\n\nTrả về:\nMột số nguyên đại diện cho số cách chuyền khác nhau mà kết quả là quả bóng\ntrở về học sinh bắt đầu sau 'm' lần chuyền.\n\nCases:\nCase 1:\nVới n = 3 học sinh và m = 3 lần chuyền, hàm sẽ trả về 2.\nCó hai chuỗi: 1 -> 2 -> 3 -> 1 và 1 -> 3 -> 2 -> 1.\n\nCase 2:\nVới n = 4 học sinh và m = 2 lần chuyền, hàm sẽ trả về 2.\nCó hai chuỗi: 1 -> 2 -> 1 và 1 -> 4 -> 1.\n\nCase 3:\nVới n = 5 học sinh và m = 4 lần chuyền, hàm sẽ trả về 6.\nCác chuỗi bao gồm: 1 -> 2 -> 3 -> 4 -> 1, 1 -> 2 -> 1 -> 2 -> 1,\n1 -> 4 -> 3 -> 2 -> 1, 1 -> 4 -> 5 -> 4 -> 1, 1 -> 2 -> 3 -> 2 -> 1,\nvà 1 -> 4 -> 5 -> 2 -> 1."
    },
    "docstring_bertscore": {
      "es": "0.9854652218677721",
      "arb": "0.9640546544656404",
      "sw": "0.9866140999916778",
      "tr": "0.9756657920194158",
      "vi": "0.9774528695575867"
    }
  },
  {
    "task_id": "Python/17",
    "prompt": {
      "en": "from typing import List, Tuple\ndef process_random_numbers(numbers: List[int]) -> Tuple[int, List[int]]:\n    \"\"\"\n    Remove duplicate integers from the input list and return the sorted unique numbers.\n\n    The function first converts the input list of numbers into a set to remove any duplicates,\n    then sorts the resulting set of unique numbers. It returns a tuple containing the count\n    of unique numbers and a list of these unique numbers in ascending order.\n\n    Args:\n    numbers (List[int]): A list of integers, which may contain duplicates.\n\n    Returns:\n    Tuple[int, List[int]]: A tuple with two elements:\n        - An integer representing the count of unique numbers.\n        - A list of the unique numbers sorted in ascending order.\n\n    Examples:\n    >>> process_random_numbers([20, 40, 32, 67, 40, 20, 89, 300, 400, 15])\n    (8, [15, 20, 32, 40, 67, 89, 300, 400])\n\n    >>> process_random_numbers([5, 3, 5, 2, 1, 4, 1])\n    (5, [1, 2, 3, 4, 5])\n    \"\"\"",
      "es": "from typing import List, Tuple\ndef process_random_numbers(numbers: List[int]) -> Tuple[int, List[int]]:\n    \"\"\"\n    Elimina los enteros duplicados de la lista de entrada y devuelve los números únicos ordenados.\n\n    La función primero convierte la lista de números de entrada en un conjunto para eliminar cualquier duplicado,\n    luego ordena el conjunto resultante de números únicos. Devuelve una tupla que contiene el conteo\n    de números únicos y una lista de estos números únicos en orden ascendente.\n\n    Argumentos:\n    numbers (List[int]): Una lista de enteros, que puede contener duplicados.\n\n    Devuelve:\n    Tuple[int, List[int]]: Una tupla con dos elementos:\n        - Un entero que representa el conteo de números únicos.\n        - Una lista de los números únicos ordenados en orden ascendente.\n\n    Ejemplos:\n    >>> process_random_numbers([20, 40, 32, 67, 40, 20, 89, 300, 400, 15])\n    (8, [15, 20, 32, 40, 67, 89, 300, 400])\n\n    >>> process_random_numbers([5, 3, 5, 2, 1, 4, 1])\n    (5, [1, 2, 3, 4, 5])\n    \"\"\"",
      "arb": "from typing import List, Tuple\ndef process_random_numbers(numbers: List[int]) -> Tuple[int, List[int]]:\n    \"\"\"\n    إزالة الأعداد الصحيحة المكررة من قائمة الإدخال وإرجاع الأرقام الفريدة المرتبة.\n\n    تقوم الدالة أولاً بتحويل قائمة الأرقام المدخلة إلى مجموعة لإزالة أي تكرارات،\n    ثم تقوم بترتيب مجموعة الأرقام الفريدة الناتجة. تُرجع الدالة زوجًا يحتوي على عدد\n    الأرقام الفريدة وقائمة بهذه الأرقام الفريدة بترتيب تصاعدي.\n\n    يعيدالحجج:\n    numbers (List[int]): قائمة من الأعداد الصحيحة، والتي قد تحتوي على تكرارات.\n\n    يعيد:\n    Tuple[int, List[int]]: زوج يحتوي على عنصرين:\n        - عدد صحيح يمثل عدد الأرقام الفريدة.\n        - قائمة من الأرقام الفريدة مرتبة بترتيب تصاعدي.\n\n    امثله:\n    >>> process_random_numbers([20, 40, 32, 67, 40, 20, 89, 300, 400, 15])\n    (8, [15, 20, 32, 40, 67, 89, 300, 400])\n\n    >>> process_random_numbers([5, 3, 5, 2, 1, 4, 1])\n    (5, [1, 2, 3, 4, 5])\n    \"\"\"",
      "sw": "from typing import List, Tuple\ndef process_random_numbers(numbers: List[int]) -> Tuple[int, List[int]]:\n    \"\"\"\n    Ondoa namba za kurudiarudia kutoka kwenye orodha ya pembejeo na rudisha namba za kipekee zilizopangwa.\n\n    Kazi hii kwanza inabadilisha orodha ya pembejeo ya namba kuwa seti ili kuondoa nakala,\n    kisha inapanga seti inayotokana ya namba za kipekee. Inarudisha jozi inayoelezea idadi\n    ya namba za kipekee na orodha ya namba hizi za kipekee kwa mpangilio wa kupanda.\n\n    Hoja:\n    numbers (List[int]): Orodha ya namba za mzima, ambayo inaweza kuwa na nakala.\n\n    Inarejesha:\n    Tuple[int, List[int]]: Jozi yenye vipengele viwili:\n        - Namba ya mzima inayowakilisha idadi ya namba za kipekee.\n        - Orodha ya namba za kipekee zilizopangwa kwa mpangilio wa kupanda.\n\n    Mifano:\n    >>> process_random_numbers([20, 40, 32, 67, 40, 20, 89, 300, 400, 15])\n    (8, [15, 20, 32, 40, 67, 89, 300, 400])\n\n    >>> process_random_numbers([5, 3, 5, 2, 1, 4, 1])\n    (5, [1, 2, 3, 4, 5])\n    \"\"\"",
      "tr": "from typing import List, Tuple\ndef process_random_numbers(numbers: List[int]) -> Tuple[int, List[int]]:\n    \"\"\"\n    Girdi listesinden tekrar eden tamsayıları kaldır ve sıralanmış benzersiz sayıları döndür.\n\n    Fonksiyon, ilk olarak girdi listesindeki sayıları bir kümeye dönüştürerek tekrar edenleri kaldırır,\n    ardından benzersiz sayıların bulunduğu kümeyi sıralar. Benzersiz sayıların sayısını ve bu sayıların\n    artan sırayla listelendiği bir liste içeren bir demet döndürür.\n\n    Argümanlar:\n    numbers (List[int]): Tekrar edenleri içerebilecek bir tamsayı listesi.\n\n    Döndürür:\n    Tuple[int, List[int]]: İki elemanlı bir demet:\n        - Benzersiz sayıların sayısını temsil eden bir tamsayı.\n        - Benzersiz sayıların artan sırayla sıralandığı bir liste.\n\n    Örnekler:\n    >>> process_random_numbers([20, 40, 32, 67, 40, 20, 89, 300, 400, 15])\n    (8, [15, 20, 32, 40, 67, 89, 300, 400])\n\n    >>> process_random_numbers([5, 3, 5, 2, 1, 4, 1])\n    (5, [1, 2, 3, 4, 5])\n    \"\"\"",
      "vi": "from typing import List, Tuple\ndef process_random_numbers(numbers: List[int]) -> Tuple[int, List[int]]:\n    \"\"\"\n    Loại bỏ các số nguyên trùng lặp khỏi danh sách đầu vào và trả về các số duy nhất đã được sắp xếp.\n\n    Hàm này trước tiên chuyển đổi danh sách số đầu vào thành một tập hợp để loại bỏ bất kỳ số trùng lặp nào,\n    sau đó sắp xếp tập hợp các số duy nhất thu được. Nó trả về một bộ giá trị chứa số lượng\n    các số duy nhất và một danh sách các số duy nhất này theo thứ tự tăng dần.\n\n    Tham số:\n    numbers (List[int]): Một danh sách các số nguyên, có thể chứa các số trùng lặp.\n\n    Trả về:\n    Tuple[int, List[int]]: Một bộ giá trị với hai phần tử:\n        - Một số nguyên đại diện cho số lượng các số duy nhất.\n        - Một danh sách các số duy nhất được sắp xếp theo thứ tự tăng dần.\n\n    Ví dụ:\n    >>> process_random_numbers([20, 40, 32, 67, 40, 20, 89, 300, 400, 15])\n    (8, [15, 20, 32, 40, 67, 89, 300, 400])\n\n    >>> process_random_numbers([5, 3, 5, 2, 1, 4, 1])\n    (5, [1, 2, 3, 4, 5])\n    \"\"\""
    },
    "prompt_bertscore": {
      "es": "0.993782869073608",
      "arb": "0.9948836786453034",
      "sw": "0.9810309972415492",
      "tr": "0.9647504566904056",
      "vi": "0.9855216328959859"
    },
    "canonical_solution": "# Remove duplicates by converting the list to a set\n    unique_numbers = set(numbers)\n    \n    # Sort the unique numbers\n    sorted_numbers = sorted(unique_numbers)\n    \n    # Return the count and the sorted unique numbers\n    return len(sorted_numbers), sorted_numbers",
    "instruction": {
      "en": "def process_random_numbers(numbers: List[int]) -> Tuple[int, List[int]]:\n# Remove duplicates by converting the list to a set\n    unique_numbers = set(numbers)\n    \n    # Sort the unique numbers\n    sorted_numbers = sorted(unique_numbers)\n    \n    # Return the count and the sorted unique numbers\n    return len(sorted_numbers), sorted_numbers\n\nProvide a concise natural language description (docstring) of the Python code in English using at most 500 characters.",
      "es": "def process_random_numbers(numbers: List[int]) -> Tuple[int, List[int]]:\n# Remove duplicates by converting the list to a set\n    unique_numbers = set(numbers)\n    \n    # Sort the unique numbers\n    sorted_numbers = sorted(unique_numbers)\n    \n    # Return the count and the sorted unique numbers\n    return len(sorted_numbers), sorted_numbers\n\nProporcione una descripción concisa en lenguaje natural (docstring) del código Python en español utilizando como máximo 500 caracteres.",
      "arb": "def process_random_numbers(numbers: List[int]) -> Tuple[int, List[int]]:\n# Remove duplicates by converting the list to a set\n    unique_numbers = set(numbers)\n    \n    # Sort the unique numbers\n    sorted_numbers = sorted(unique_numbers)\n    \n    # Return the count and the sorted unique numbers\n    return len(sorted_numbers), sorted_numbers\n\nيرجى تقديم وصف موجز بلغة طبيعية (docstring) للكود البرمجي بلغة بايثون باللغة العربية الفصحى باستخدام 500 حرف كحد أقصى.",
      "sw": "def process_random_numbers(numbers: List[int]) -> Tuple[int, List[int]]:\n# Remove duplicates by converting the list to a set\n    unique_numbers = set(numbers)\n    \n    # Sort the unique numbers\n    sorted_numbers = sorted(unique_numbers)\n    \n    # Return the count and the sorted unique numbers\n    return len(sorted_numbers), sorted_numbers\n\nToa maelezo mafupi ya lugha ya asili (docstring) ya msimbo wa Python kwa Kiswahili kwa kutumia herufi zisizozidi 500.",
      "tr": "def process_random_numbers(numbers: List[int]) -> Tuple[int, List[int]]:\n# Remove duplicates by converting the list to a set\n    unique_numbers = set(numbers)\n    \n    # Sort the unique numbers\n    sorted_numbers = sorted(unique_numbers)\n    \n    # Return the count and the sorted unique numbers\n    return len(sorted_numbers), sorted_numbers\n\nPython kodunun işlevini açıklayan kısa bir doğal dil açıklaması (docstring) sağlayın. Açıklama Türkçe olmalı ve en fazla 500 karakter kullanılmalıdır.",
      "vi": "def process_random_numbers(numbers: List[int]) -> Tuple[int, List[int]]:\n# Remove duplicates by converting the list to a set\n    unique_numbers = set(numbers)\n    \n    # Sort the unique numbers\n    sorted_numbers = sorted(unique_numbers)\n    \n    # Return the count and the sorted unique numbers\n    return len(sorted_numbers), sorted_numbers\n\nCung cấp mô tả ngắn gọn bằng ngôn ngữ tự nhiên (docstring) cho mã Python bằng tiếng Việt, sử dụng tối đa 500 ký tự."
    },
    "instruction_bertscore": {
      "es": "0.9687387561112052",
      "arb": "0.924699818440817",
      "sw": "0.914896018724078",
      "tr": "0.8582579559846469",
      "vi": "0.9069722555638342"
    },
    "level": "",
    "test": "def test_process_random_numbers():\n    # Test case 1: Basic example with duplicates\n    assert process_random_numbers([20, 40, 32, 67, 40, 20, 89, 300, 400, 15]) == (8, [15, 20, 32, 40, 67, 89, 300, 400]), \"Test case 1 failed\"\n\n    # Test case 2: All elements are the same\n    assert process_random_numbers([1, 1, 1, 1]) == (1, [1]), \"Test case 2 failed\"\n\n    # Test case 3: No duplicates\n    assert process_random_numbers([3, 1, 4, 2]) == (4, [1, 2, 3, 4]), \"Test case 3 failed\"\n\n    # Test case 4: Random numbers with single element\n    assert process_random_numbers([42]) == (1, [42]), \"Test case 4 failed\"\n\n    # Test case 5: Empty list\n    assert process_random_numbers([]) == (0, []), \"Test case 5 failed\"\n\n    # Test case 6: Random numbers with negatives and zero\n    assert process_random_numbers([0, -1, -2, -1, 0, 3]) == (4, [-2, -1, 0, 3]), \"Test case 6 failed\"\n\n    # Test case 7: Large range of numbers\n    assert process_random_numbers(list(range(1000, 0, -1))) == (1000, list(range(1, 1001))), \"Test case 7 failed\"\n\n    print(\"All test cases passed!\")\n\n# Run the test function\ntest_process_random_numbers()",
    "entry_point": "process_random_numbers",
    "signature": "def process_random_numbers(numbers: List[int]) -> Tuple[int, List[int]]:",
    "docstring": {
      "en": "Remove duplicate integers from the input list and return the sorted unique numbers.\n\nThe function first converts the input list of numbers into a set to remove any duplicates,\nthen sorts the resulting set of unique numbers. It returns a tuple containing the count\nof unique numbers and a list of these unique numbers in ascending order.\n\nArgs:\nnumbers (List[int]): A list of integers, which may contain duplicates.\n\nReturns:\nTuple[int, List[int]]: A tuple with two elements:\n- An integer representing the count of unique numbers.\n- A list of the unique numbers sorted in ascending order.\n\nExamples:\n>>> process_random_numbers([20, 40, 32, 67, 40, 20, 89, 300, 400, 15])\n(8, [15, 20, 32, 40, 67, 89, 300, 400])\n\n>>> process_random_numbers([5, 3, 5, 2, 1, 4, 1])\n(5, [1, 2, 3, 4, 5])",
      "es": "Eliminar los enteros duplicados de la lista de entrada y devolver los números únicos ordenados.\n\nLa función primero convierte la lista de números de entrada en un conjunto para eliminar cualquier duplicado, luego ordena el conjunto resultante de números únicos. Devuelve una tupla que contiene el conteo de números únicos y una lista de estos números únicos en orden ascendente.\n\nArgumentos:\nnumbers (List[int]): Una lista de enteros, que puede contener duplicados.\n\nDevuelve:\nTuple[int, List[int]]: Una tupla con dos elementos:\n- Un entero que representa el conteo de números únicos.\n- Una lista de los números únicos ordenados en orden ascendente.\n\nEjemplos:\n>>> process_random_numbers([20, 40, 32, 67, 40, 20, 89, 300, 400, 15])\n(8, [15, 20, 32, 40, 67, 89, 300, 400])\n\n>>> process_random_numbers([5, 3, 5, 2, 1, 4, 1])\n(5, [1, 2, 3, 4, 5])",
      "arb": "إزالة الأعداد الصحيحة المكررة من قائمة المدخلات وإرجاع الأرقام الفريدة المرتبة.\n\nتقوم الدالة أولاً بتحويل قائمة الأرقام المدخلة إلى مجموعة لإزالة أي تكرارات، ثم تقوم بترتيب المجموعة الناتجة من الأرقام الفريدة. وتعيد دالة تحتوي على عدد الأرقام الفريدة وقائمة بهذه الأرقام الفريدة بترتيب تصاعدي.\n\nالمعطيات:\nnumbers (List[int]): قائمة من الأعداد الصحيحة، والتي قد تحتوي على تكرارات.\n\nالقيم المعادة:\nTuple[int, List[int]]: دالة تحتوي على عنصرين:\n- عدد صحيح يمثل عدد الأرقام الفريدة.\n- قائمة بالأرقام الفريدة مرتبة بترتيب تصاعدي.\n\nأمثلة:\n>>> process_random_numbers([20, 40, 32, 67, 40, 20, 89, 300, 400, 15])\n(8, [15, 20, 32, 40, 67, 89, 300, 400])\n\n>>> process_random_numbers([5, 3, 5, 2, 1, 4, 1])\n(5, [1, 2, 3, 4, 5])",
      "sw": "Ondoa namba za kurudiarudia kutoka kwenye orodha ya ingizo na rudisha namba za kipekee zilizopangwa.\n\nKazi hii kwanza inabadilisha orodha ya namba za ingizo kuwa seti ili kuondoa nakala zozote, kisha inapanga seti inayotokana na namba za kipekee. Inarudisha jozi inayojumuisha idadi ya namba za kipekee na orodha ya namba hizi za kipekee kwa mpangilio wa kupanda.\n\nHoja:\nnumbers (List[int]): Orodha ya namba za mzima, ambazo zinaweza kuwa na nakala.\n\nInarejesha:\nTuple[int, List[int]]: Jozi yenye vipengele viwili:\n- Namba ya mzima inayowakilisha idadi ya namba za kipekee.\n- Orodha ya namba za kipekee zilizopangwa kwa mpangilio wa kupanda.\n\nMifano:\n>>> process_random_numbers([20, 40, 32, 67, 40, 20, 89, 300, 400, 15])\n(8, [15, 20, 32, 40, 67, 89, 300, 400])\n\n>>> process_random_numbers([5, 3, 5, 2, 1, 4, 1])\n(5, [1, 2, 3, 4, 5])",
      "tr": "Girdi listesinden yinelenen tamsayıları kaldırın ve sıralanmış benzersiz sayıları döndürün.\n\nFonksiyon, önce girdi listesindeki sayıları bir kümeye dönüştürerek yinelenenleri kaldırır, ardından benzersiz sayıların bulunduğu kümeyi sıralar. Benzersiz sayıların sayısını ve bu benzersiz sayıların artan sırayla bulunduğu bir listeyi içeren bir demet döndürür.\n\nArgümanlar:\nnumbers (List[int]): Yinelenenleri içerebilecek bir tamsayı listesi.\n\nDöndürür:\nTuple[int, List[int]]: İki elemanlı bir demet:\n- Benzersiz sayıların sayısını temsil eden bir tamsayı.\n- Benzersiz sayıların artan sırayla sıralandığı bir liste.\n\nÖrnekler:\n>>> process_random_numbers([20, 40, 32, 67, 40, 20, 89, 300, 400, 15])\n(8, [15, 20, 32, 40, 67, 89, 300, 400])\n\n>>> process_random_numbers([5, 3, 5, 2, 1, 4, 1])\n(5, [1, 2, 3, 4, 5])",
      "vi": "Loại bỏ các số nguyên trùng lặp khỏi danh sách đầu vào và trả về các số duy nhất đã được sắp xếp.\n\nHàm này đầu tiên chuyển đổi danh sách số đầu vào thành một tập hợp để loại bỏ bất kỳ trùng lặp nào, sau đó sắp xếp tập hợp các số duy nhất kết quả. Nó trả về một bộ chứa số lượng các số duy nhất và một danh sách các số duy nhất này theo thứ tự tăng dần.\n\nTham số:\nnumbers (List[int]): Một danh sách các số nguyên, có thể chứa các phần tử trùng lặp.\n\nTrả về:\nTuple[int, List[int]]: Một bộ với hai phần tử:\n- Một số nguyên đại diện cho số lượng các số duy nhất.\n- Một danh sách các số duy nhất được sắp xếp theo thứ tự tăng dần.\n\nVí dụ:\n>>> process_random_numbers([20, 40, 32, 67, 40, 20, 89, 300, 400, 15])\n(8, [15, 20, 32, 40, 67, 89, 300, 400])\n\n>>> process_random_numbers([5, 3, 5, 2, 1, 4, 1])\n(5, [1, 2, 3, 4, 5])"
    },
    "docstring_bertscore": {
      "es": "0.9982901896800517",
      "arb": "0.9865330587962157",
      "sw": "0.9865056478036328",
      "tr": "0.9711084165569513",
      "vi": "0.9820378546430151"
    }
  },
  {
    "task_id": "Python/18",
    "prompt": {
      "en": "from typing import List, Tuple\ndef max_happiness(n: int, m: int, items: List[Tuple[int, int]]) -> int:\n    \"\"\"\n    Calculates the maximum total importance value of items that can be bought within a given budget.\n    \n    This function solves a variant of the 0-1 knapsack problem where each item has a price and an \n    associated importance value. The goal is to maximize the sum of the importance values of a \n    selection of items without the total price exceeding the budget.\n    \n    Args:\n    n (int): The total budget available for purchasing items.\n    m (int): The number of different items to choose from.\n    items (List[Tuple[int, int]]): A list of tuples, where each tuple contains two integers:\n        - The first integer represents the price of the item.\n        - The second integer represents the importance value of the item.\n    \n    Returns:\n    int: The maximum total importance value that can be achieved without exceeding the budget.\n    \n    Examples:\n    >>> max_happiness(1000, 5, [(800, 2), (400, 5), (300, 5), (400, 3), (200, 2)])\n    3900\n    \n    >>> max_happiness(50, 3, [(10, 1), (20, 2), (30, 3)])\n    80\n    \n    The first example represents a budget of 1000 units with 5 items to choose from. The function \n    returns 3900, which is the maximum importance value sum achievable within the budget.\n    \n    The second example has a smaller budget of 50 units and 3 items. The function returns 80, \n    which is the maximum sum of importance values for the chosen items within the budget.\n    \"\"\"",
      "es": "from typing import List, Tuple\ndef max_happiness(n: int, m: int, items: List[Tuple[int, int]]) -> int:\n    \"\"\"\n    Calcula el valor máximo total de importancia de los artículos que se pueden comprar dentro de un presupuesto dado.\n    \n    Esta función resuelve una variante del problema de la mochila 0-1 donde cada artículo tiene un precio y un \n    valor de importancia asociado. El objetivo es maximizar la suma de los valores de importancia de una \n    selección de artículos sin que el precio total exceda el presupuesto.\n    \n    Argumentos:\n    n (int): El presupuesto total disponible para la compra de artículos.\n    m (int): El número de diferentes artículos para elegir.\n    items (List[Tuple[int, int]]): Una lista de tuplas, donde cada tupla contiene dos enteros:\n        - El primer entero representa el precio del artículo.\n        - El segundo entero representa el valor de importancia del artículo.\n    \n    Devuelve:\n    int: El valor máximo total de importancia que se puede lograr sin exceder el presupuesto.\n    \n    Ejemplos:\n    >>> max_happiness(1000, 5, [(800, 2), (400, 5), (300, 5), (400, 3), (200, 2)])\n    3900\n    \n    >>> max_happiness(50, 3, [(10, 1), (20, 2), (30, 3)])\n    80\n    \n    El primer ejemplo representa un presupuesto de 1000 unidades con 5 artículos para elegir. La función \n    devuelve 3900, que es la suma máxima de valores de importancia alcanzable dentro del presupuesto.\n    \n    El segundo ejemplo tiene un presupuesto más pequeño de 50 unidades y 3 artículos. La función devuelve 80, \n    que es la suma máxima de valores de importancia para los artículos elegidos dentro del presupuesto.\n    \"\"\"",
      "arb": "from typing import List, Tuple\ndef max_happiness(n: int, m: int, items: List[Tuple[int, int]]) -> int:\n    \"\"\"\n    يحسب أقصى قيمة إجمالية للأهمية يمكن تحقيقها من العناصر التي يمكن شراؤها ضمن ميزانية معينة.\n    \n    تحل هذه الدالة نوعًا من مشكلة حقيبة الظهر 0-1 حيث أن لكل عنصر سعر وقيمة أهمية مرتبطة به. \n    الهدف هو تعظيم مجموع قيم الأهمية لمجموعة من العناصر دون أن يتجاوز السعر الإجمالي الميزانية.\n    \n    يعيدالحجج:\n    n (int): الميزانية الإجمالية المتاحة لشراء العناصر.\n    m (int): عدد العناصر المختلفة للاختيار من بينها.\n    items (List[Tuple[int, int]]): قائمة من الأزواج، حيث يحتوي كل زوج على عددين صحيحين:\n        - العدد الأول يمثل سعر العنصر.\n        - العدد الثاني يمثل قيمة الأهمية للعنصر.\n    \n    يعيد:\n    int: أقصى قيمة إجمالية للأهمية يمكن تحقيقها دون تجاوز الميزانية.\n    \n    أمثلة:\n    >>> max_happiness(1000, 5, [(800, 2), (400, 5), (300, 5), (400, 3), (200, 2)])\n    3900\n    \n    >>> max_happiness(50, 3, [(10, 1), (20, 2), (30, 3)])\n    80\n    \n    المثال الأول يمثل ميزانية قدرها 1000 وحدة مع 5 عناصر للاختيار منها. تعيد الدالة 3900، \n    وهو مجموع قيمة الأهمية القصوى الممكن تحقيقها ضمن الميزانية.\n    \n    المثال الثاني لديه ميزانية أصغر قدرها 50 وحدة و3 عناصر. تعيد الدالة 80، \n    وهو مجموع قيمة الأهمية القصوى للعناصر المختارة ضمن الميزانية.\n    \"\"\"",
      "sw": "from typing import List, Tuple\ndef max_happiness(n: int, m: int, items: List[Tuple[int, int]]) -> int:\n    \"\"\"\n    Inahesabu thamani ya juu kabisa ya umuhimu wa jumla wa vitu vinavyoweza kununuliwa ndani ya bajeti iliyotolewa.\n    \n    Kazi hii inatatua aina ya tatizo la 0-1 knapsack ambapo kila kipengee kina bei na thamani ya umuhimu \n    inayohusishwa. Lengo ni kuongeza jumla ya thamani za umuhimu za uteuzi wa vitu bila bei ya jumla \n    kuzidi bajeti.\n    \n    Hoja:\n    n (int): Bajeti ya jumla inayopatikana kwa ajili ya kununua vitu.\n    m (int): Idadi ya vitu tofauti vya kuchagua.\n    items (List[Tuple[int, int]]): Orodha ya jozi, ambapo kila jozi ina nambari mbili:\n        - Nambari ya kwanza inawakilisha bei ya kipengee.\n        - Nambari ya pili inawakilisha thamani ya umuhimu wa kipengee.\n    \n    Inarejesha:\n    int: Thamani ya juu kabisa ya umuhimu inayoweza kupatikana bila kuzidi bajeti.\n    \n    Mifano:\n    >>> max_happiness(1000, 5, [(800, 2), (400, 5), (300, 5), (400, 3), (200, 2)])\n    3900\n    \n    >>> max_happiness(50, 3, [(10, 1), (20, 2), (30, 3)])\n    80\n    \n    Mfano wa kwanza unawakilisha bajeti ya vitengo 1000 na vitu 5 vya kuchagua. Kazi \n    inarudisha 3900, ambayo ni jumla ya juu kabisa ya thamani ya umuhimu inayoweza kupatikana ndani ya bajeti.\n    \n    Mfano wa pili una bajeti ndogo ya vitengo 50 na vitu 3. Kazi inarudisha 80, \n    ambayo ni jumla ya juu kabisa ya thamani za umuhimu kwa vitu vilivyochaguliwa ndani ya bajeti.\n    \"\"\"",
      "tr": "from typing import List, Tuple\ndef max_happiness(n: int, m: int, items: List[Tuple[int, int]]) -> int:\n    \"\"\"\n    Belirli bir bütçe dahilinde satın alınabilecek eşyaların maksimum toplam önem değerini hesaplar.\n    \n    Bu fonksiyon, her bir öğenin bir fiyatı ve ilişkili bir önem değeri olduğu 0-1 sırt çantası probleminin \n    bir varyantını çözer. Amaç, toplam fiyat bütçeyi aşmadan, bir öğe seçiminin önem değerlerinin toplamını \n    maksimize etmektir.\n    \n    Argümanlar:\n    n (int): Eşyaları satın almak için mevcut toplam bütçe.\n    m (int): Seçilecek farklı eşya sayısı.\n    items (List[Tuple[int, int]]): Her bir demetin iki tamsayı içerdiği demetlerin listesi:\n        - İlk tamsayı, eşyanın fiyatını temsil eder.\n        - İkinci tamsayı, eşyanın önem değerini temsil eder.\n    \n    Döndürür:\n    int: Bütçeyi aşmadan elde edilebilecek maksimum toplam önem değeri.\n    \n    Örnekler:\n    >>> max_happiness(1000, 5, [(800, 2), (400, 5), (300, 5), (400, 3), (200, 2)])\n    3900\n    \n    >>> max_happiness(50, 3, [(10, 1), (20, 2), (30, 3)])\n    80\n    \n    İlk örnek, 5 eşya ile 1000 birimlik bir bütçeyi temsil eder. Fonksiyon, bütçe dahilinde \n    elde edilebilecek maksimum önem değeri toplamı olan 3900'ü döndürür.\n    \n    İkinci örnek, 50 birimlik daha küçük bir bütçeye ve 3 eşyaya sahiptir. Fonksiyon, bütçe dahilinde \n    seçilen eşyaların önem değerlerinin maksimum toplamı olan 80'i döndürür.\n    \"\"\"",
      "vi": "from typing import List, Tuple\ndef max_happiness(n: int, m: int, items: List[Tuple[int, int]]) -> int:\n    \"\"\"\n    Tính toán tổng giá trị quan trọng tối đa của các mặt hàng có thể mua trong một ngân sách cho trước.\n    \n    Hàm này giải quyết một biến thể của bài toán cái túi 0-1, trong đó mỗi mặt hàng có một giá và một \n    giá trị quan trọng liên quan. Mục tiêu là tối đa hóa tổng giá trị quan trọng của một \n    lựa chọn các mặt hàng mà không để tổng giá vượt quá ngân sách.\n    \n    Tham số:\n    n (int): Tổng ngân sách có sẵn để mua các mặt hàng.\n    m (int): Số lượng các mặt hàng khác nhau để lựa chọn.\n    items (List[Tuple[int, int]]): Một danh sách các bộ giá trị, trong đó mỗi bộ chứa hai số nguyên:\n        - Số nguyên đầu tiên đại diện cho giá của mặt hàng.\n        - Số nguyên thứ hai đại diện cho giá trị quan trọng của mặt hàng.\n    \n    Trả về:\n    int: Tổng giá trị quan trọng tối đa có thể đạt được mà không vượt quá ngân sách.\n    \n    Ví dụ:\n    >>> max_happiness(1000, 5, [(800, 2), (400, 5), (300, 5), (400, 3), (200, 2)])\n    3900\n    \n    >>> max_happiness(50, 3, [(10, 1), (20, 2), (30, 3)])\n    80\n    \n    Ví dụ đầu tiên đại diện cho một ngân sách 1000 đơn vị với 5 mặt hàng để lựa chọn. Hàm \n    trả về 3900, là tổng giá trị quan trọng tối đa có thể đạt được trong ngân sách.\n    \n    Ví dụ thứ hai có ngân sách nhỏ hơn là 50 đơn vị và 3 mặt hàng. Hàm trả về 80, \n    là tổng giá trị quan trọng tối đa cho các mặt hàng được chọn trong ngân sách.\n    \"\"\""
    },
    "prompt_bertscore": {
      "es": "0.9902422825316611",
      "arb": "0.9683204405287457",
      "sw": "0.9584479147001687",
      "tr": "0.96925598962342",
      "vi": "0.9718677805036477"
    },
    "canonical_solution": "# Initialize a list to store the maximum value for each budget up to n\n    dp = [0] * (n + 1)\n    \n    # Loop over each item\n    for i in range(m):\n        price, importance = items[i]\n        # Loop over the possible budgets from n to price\n        for j in range(n, price - 1, -1):\n            # Update the dp array if the current item can be added\n            dp[j] = max(dp[j], dp[j - price] + price * importance)\n    \n    # The maximum value is stored in dp[n]\n    return dp[n]",
    "instruction": {
      "en": "def max_happiness(n: int, m: int, items: List[Tuple[int, int]]) -> int:\n# Initialize a list to store the maximum value for each budget up to n\n    dp = [0] * (n + 1)\n    \n    # Loop over each item\n    for i in range(m):\n        price, importance = items[i]\n        # Loop over the possible budgets from n to price\n        for j in range(n, price - 1, -1):\n            # Update the dp array if the current item can be added\n            dp[j] = max(dp[j], dp[j - price] + price * importance)\n    \n    # The maximum value is stored in dp[n]\n    return dp[n]\n\nProvide a concise natural language description (docstring) of the Python code in English using at most 500 characters.",
      "es": "def max_happiness(n: int, m: int, items: List[Tuple[int, int]]) -> int:\n# Initialize a list to store the maximum value for each budget up to n\n    dp = [0] * (n + 1)\n    \n    # Loop over each item\n    for i in range(m):\n        price, importance = items[i]\n        # Loop over the possible budgets from n to price\n        for j in range(n, price - 1, -1):\n            # Update the dp array if the current item can be added\n            dp[j] = max(dp[j], dp[j - price] + price * importance)\n    \n    # The maximum value is stored in dp[n]\n    return dp[n]\n\nProporcione una descripción concisa en lenguaje natural (docstring) del código Python en español utilizando como máximo 500 caracteres.",
      "arb": "def max_happiness(n: int, m: int, items: List[Tuple[int, int]]) -> int:\n# Initialize a list to store the maximum value for each budget up to n\n    dp = [0] * (n + 1)\n    \n    # Loop over each item\n    for i in range(m):\n        price, importance = items[i]\n        # Loop over the possible budgets from n to price\n        for j in range(n, price - 1, -1):\n            # Update the dp array if the current item can be added\n            dp[j] = max(dp[j], dp[j - price] + price * importance)\n    \n    # The maximum value is stored in dp[n]\n    return dp[n]\n\nقدم وصفًا موجزًا بلغة طبيعية (docstring) للكود البرمجي بلغة بايثون باللغة العربية الفصحى باستخدام 500 حرف كحد أقصى.",
      "sw": "def max_happiness(n: int, m: int, items: List[Tuple[int, int]]) -> int:\n# Initialize a list to store the maximum value for each budget up to n\n    dp = [0] * (n + 1)\n    \n    # Loop over each item\n    for i in range(m):\n        price, importance = items[i]\n        # Loop over the possible budgets from n to price\n        for j in range(n, price - 1, -1):\n            # Update the dp array if the current item can be added\n            dp[j] = max(dp[j], dp[j - price] + price * importance)\n    \n    # The maximum value is stored in dp[n]\n    return dp[n]\n\nToa maelezo mafupi ya lugha asilia (docstring) ya msimbo wa Python kwa Kiswahili kwa kutumia herufi zisizozidi 500.",
      "tr": "def max_happiness(n: int, m: int, items: List[Tuple[int, int]]) -> int:\n# Initialize a list to store the maximum value for each budget up to n\n    dp = [0] * (n + 1)\n    \n    # Loop over each item\n    for i in range(m):\n        price, importance = items[i]\n        # Loop over the possible budgets from n to price\n        for j in range(n, price - 1, -1):\n            # Update the dp array if the current item can be added\n            dp[j] = max(dp[j], dp[j - price] + price * importance)\n    \n    # The maximum value is stored in dp[n]\n    return dp[n]\n\nPython kodunun işlevini açıklayan kısa bir doğal dil açıklaması (docstring) sağlayın. Açıklama, en fazla 500 karakter kullanılarak Türkçe olarak yazılmalıdır.",
      "vi": "def max_happiness(n: int, m: int, items: List[Tuple[int, int]]) -> int:\n# Initialize a list to store the maximum value for each budget up to n\n    dp = [0] * (n + 1)\n    \n    # Loop over each item\n    for i in range(m):\n        price, importance = items[i]\n        # Loop over the possible budgets from n to price\n        for j in range(n, price - 1, -1):\n            # Update the dp array if the current item can be added\n            dp[j] = max(dp[j], dp[j - price] + price * importance)\n    \n    # The maximum value is stored in dp[n]\n    return dp[n]\n\nCung cấp mô tả ngắn gọn bằng ngôn ngữ tự nhiên (docstring) cho mã Python bằng tiếng Việt, sử dụng tối đa 500 ký tự."
    },
    "instruction_bertscore": {
      "es": "0.9687387561112052",
      "arb": "0.9273282942730516",
      "sw": "0.9426438884331277",
      "tr": "0.878612207020435",
      "vi": "0.9256256346468206"
    },
    "level": "",
    "test": "def test_max_happiness():\n    # Test case 1: Sample provided in the problem\n    assert max_happiness(1000, 5, [(800, 2), (400, 5), (300, 5), (400, 3), (200, 2)]) == 3900, \"Test case 1 failed\"\n\n    # Test case 2: Small budget with one item\n    assert max_happiness(50, 1, [(60, 3)]) == 0, \"Test case 2 failed\"\n\n    # Test case 4: Exact budget\n    assert max_happiness(100, 2, [(50, 2), (50, 3)]) == 250, \"Test case 4 failed\"\n\n    # Test case 5: No items\n    assert max_happiness(100, 0, []) == 0, \"Test case 5 failed\"\n\n    # Test case 6: All items exceed the budget\n    assert max_happiness(10, 3, [(20, 1), (30, 2), (40, 3)]) == 0, \"Test case 6 failed\"\n\n    # Test case 7: Multiple items with the same price and importance\n    assert max_happiness(100, 4, [(25, 2), (25, 2), (25, 2), (25, 2)]) == 200, \"Test case 7 failed\"\n\n    # Test case 8: Large number of items\n    assert max_happiness(1000, 10, [(100, i) for i in range(1, 11)]) == 5500, \"Test case 8 failed\"\n\n    print(\"All test cases passed!\")\n\n# Run the test function\ntest_max_happiness()",
    "entry_point": "max_happiness",
    "signature": "def max_happiness(n: int, m: int, items: List[Tuple[int, int]]) -> int:",
    "docstring": {
      "en": "Calculates the maximum total importance value of items that can be bought within a given budget.\n\nThis function solves a variant of the 0-1 knapsack problem where each item has a price and an\nassociated importance value. The goal is to maximize the sum of the importance values of a\nselection of items without the total price exceeding the budget.\n\nArgs:\nn (int): The total budget available for purchasing items.\nm (int): The number of different items to choose from.\nitems (List[Tuple[int, int]]): A list of tuples, where each tuple contains two integers:\n- The first integer represents the price of the item.\n- The second integer represents the importance value of the item.\n\nReturns:\nint: The maximum total importance value that can be achieved without exceeding the budget.\n\nExamples:\n>>> max_happiness(1000, 5, [(800, 2), (400, 5), (300, 5), (400, 3), (200, 2)])\n3900\n\n>>> max_happiness(50, 3, [(10, 1), (20, 2), (30, 3)])\n80\n\nThe first example represents a budget of 1000 units with 5 items to choose from. The function\nreturns 3900, which is the maximum importance value sum achievable within the budget.\n\nThe second example has a smaller budget of 50 units and 3 items. The function returns 80,\nwhich is the maximum sum of importance values for the chosen items within the budget.",
      "es": "Calcula el valor máximo total de importancia de los artículos que se pueden comprar dentro de un presupuesto dado.\n\nEsta función resuelve una variante del problema de la mochila 0-1 donde cada artículo tiene un precio y un valor de importancia asociado. El objetivo es maximizar la suma de los valores de importancia de una selección de artículos sin que el precio total exceda el presupuesto.\n\nArgumentos:\nn (int): El presupuesto total disponible para la compra de artículos.\nm (int): El número de diferentes artículos para elegir.\nitems (List[Tuple[int, int]]): Una lista de tuplas, donde cada tupla contiene dos enteros:\n- El primer entero representa el precio del artículo.\n- El segundo entero representa el valor de importancia del artículo.\n\nDevuelve:\nint: El valor máximo total de importancia que se puede lograr sin exceder el presupuesto.\n\nEjemplos:\n>>> max_happiness(1000, 5, [(800, 2), (400, 5), (300, 5), (400, 3), (200, 2)])\n3900\n\n>>> max_happiness(50, 3, [(10, 1), (20, 2), (30, 3)])\n80\n\nEl primer ejemplo representa un presupuesto de 1000 unidades con 5 artículos para elegir. La función devuelve 3900, que es la suma máxima de valores de importancia alcanzable dentro del presupuesto.\n\nEl segundo ejemplo tiene un presupuesto más pequeño de 50 unidades y 3 artículos. La función devuelve 80, que es la suma máxima de valores de importancia para los artículos elegidos dentro del presupuesto.",
      "arb": "يحسب القيمة القصوى لإجمالي الأهمية للعناصر التي يمكن شراؤها ضمن ميزانية معينة.\n\nتحل هذه الدالة نوعًا من مشكلة الحقيبة 0-1 حيث أن لكل عنصر سعر وقيمة أهمية مرتبطة به. الهدف هو تعظيم مجموع قيم الأهمية لمجموعة مختارة من العناصر دون أن يتجاوز السعر الإجمالي الميزانية.\n\nالمعطيات:\nn (int): الميزانية الإجمالية المتاحة لشراء العناصر.\nm (int): عدد العناصر المختلفة للاختيار من بينها.\nitems (List[Tuple[int, int]]): قائمة من الأزواج، حيث يحتوي كل زوج على عددين صحيحين:\n- العدد الأول يمثل سعر العنصر.\n- العدد الثاني يمثل قيمة الأهمية للعنصر.\n\nالقيم المعادة:\nint: القيمة القصوى لإجمالي الأهمية التي يمكن تحقيقها دون تجاوز الميزانية.\n\nأمثلة:\n>>> max_happiness(1000, 5, [(800, 2), (400, 5), (300, 5), (400, 3), (200, 2)])\n3900\n\n>>> max_happiness(50, 3, [(10, 1), (20, 2), (30, 3)])\n80\n\nيمثل المثال الأول ميزانية قدرها 1000 وحدة مع 5 عناصر للاختيار من بينها. تعيد الدالة 3900، وهي مجموع قيمة الأهمية القصوى التي يمكن تحقيقها ضمن الميزانية.\n\nالمثال الثاني لديه ميزانية أصغر قدرها 50 وحدة و3 عناصر. تعيد الدالة 80، وهي مجموع قيمة الأهمية القصوى للعناصر المختارة ضمن الميزانية.",
      "sw": "Inakokotoa thamani ya juu kabisa ya umuhimu wa jumla wa vitu vinavyoweza kununuliwa ndani ya bajeti iliyotolewa.\n\nKazi hii inatatua aina ya tatizo la 0-1 knapsack ambapo kila kipengee kina bei na thamani ya umuhimu inayohusiana. Lengo ni kuongeza jumla ya thamani za umuhimu wa uteuzi wa vitu bila bei ya jumla kuzidi bajeti.\n\nHoja:\nn (int): Bajeti ya jumla inayopatikana kwa ajili ya kununua vitu.\nm (int): Idadi ya vitu tofauti vya kuchagua.\nitems (List[Tuple[int, int]]): Orodha ya jozi, ambapo kila jozi ina nambari mbili:\n- Nambari ya kwanza inawakilisha bei ya kipengee.\n- Nambari ya pili inawakilisha thamani ya umuhimu wa kipengee.\n\nInarejesha:\nint: Thamani ya juu kabisa ya umuhimu wa jumla inayoweza kupatikana bila kuzidi bajeti.\n\nMifano:\n>>> max_happiness(1000, 5, [(800, 2), (400, 5), (300, 5), (400, 3), (200, 2)])\n3900\n\n>>> max_happiness(50, 3, [(10, 1), (20, 2), (30, 3)])\n80\n\nMfano wa kwanza unawakilisha bajeti ya vitengo 1000 na vitu 5 vya kuchagua. Kazi inarudisha 3900, ambayo ni jumla ya juu kabisa ya thamani za umuhimu inayoweza kupatikana ndani ya bajeti.\n\nMfano wa pili una bajeti ndogo ya vitengo 50 na vitu 3. Kazi inarudisha 80, ambayo ni jumla ya juu kabisa ya thamani za umuhimu kwa vitu vilivyochaguliwa ndani ya bajeti.",
      "tr": "Eşyaların belirli bir bütçe dahilinde satın alınabileceği maksimum toplam önem değerini hesaplar.\n\nBu fonksiyon, her bir öğenin bir fiyatı ve ilişkili bir önem değeri olan 0-1 knapsack probleminin bir varyantını çözer. Amaç, toplam fiyat bütçeyi aşmadan, seçilen öğelerin önem değerlerinin toplamını maksimize etmektir.\n\nArgümanlar:\nn (int): Eşyaları satın almak için mevcut toplam bütçe.\nm (int): Seçilebilecek farklı eşya sayısı.\nitems (List[Tuple[int, int]]): Her bir demetin iki tam sayı içerdiği demetlerin listesi:\n- İlk tam sayı, eşyanın fiyatını temsil eder.\n- İkinci tam sayı, eşyanın önem değerini temsil eder.\n\nDöndürür:\nint: Bütçeyi aşmadan elde edilebilecek maksimum toplam önem değeri.\n\nÖrnekler:\n>>> max_happiness(1000, 5, [(800, 2), (400, 5), (300, 5), (400, 3), (200, 2)])\n3900\n\n>>> max_happiness(50, 3, [(10, 1), (20, 2), (30, 3)])\n80\n\nİlk örnek, 1000 birimlik bir bütçeyi ve seçilebilecek 5 öğeyi temsil eder. Fonksiyon, bütçe dahilinde elde edilebilecek maksimum önem değeri toplamı olan 3900'ü döndürür.\n\nİkinci örnek, 50 birimlik daha küçük bir bütçe ve 3 öğe içerir. Fonksiyon, bütçe dahilinde seçilen öğeler için maksimum önem değerleri toplamı olan 80'i döndürür.",
      "vi": "Tính tổng giá trị quan trọng tối đa của các mặt hàng có thể mua trong một ngân sách cho trước.\n\nHàm này giải quyết một biến thể của bài toán ba lô 0-1, trong đó mỗi mặt hàng có một giá và một giá trị quan trọng liên quan. Mục tiêu là tối đa hóa tổng giá trị quan trọng của một lựa chọn các mặt hàng mà không để tổng giá vượt quá ngân sách.\n\nTham số:\nn (int): Tổng ngân sách có sẵn để mua các mặt hàng.\nm (int): Số lượng mặt hàng khác nhau để lựa chọn.\nitems (List[Tuple[int, int]]): Một danh sách các bộ giá trị, trong đó mỗi bộ chứa hai số nguyên:\n- Số nguyên đầu tiên đại diện cho giá của mặt hàng.\n- Số nguyên thứ hai đại diện cho giá trị quan trọng của mặt hàng.\n\nTrả về:\nint: Tổng giá trị quan trọng tối đa có thể đạt được mà không vượt quá ngân sách.\n\nVí dụ:\n>>> max_happiness(1000, 5, [(800, 2), (400, 5), (300, 5), (400, 3), (200, 2)])\n3900\n\n>>> max_happiness(50, 3, [(10, 1), (20, 2), (30, 3)])\n80\n\nVí dụ đầu tiên đại diện cho một ngân sách 1000 đơn vị với 5 mặt hàng để lựa chọn. Hàm trả về 3900, là tổng giá trị quan trọng tối đa có thể đạt được trong ngân sách.\n\nVí dụ thứ hai có ngân sách nhỏ hơn là 50 đơn vị và 3 mặt hàng. Hàm trả về 80, là tổng giá trị quan trọng tối đa cho các mặt hàng được chọn trong ngân sách."
    },
    "docstring_bertscore": {
      "es": "0.9918408598382299",
      "arb": "0.9624890498023234",
      "sw": "0.9536418540006485",
      "tr": "0.9516982557222221",
      "vi": "0.9686630779360309"
    }
  },
  {
    "task_id": "Python/19",
    "prompt": {
      "en": "\ndef max_energy(beads):\n    \"\"\"\n    Calculate the maximum energy that can be released by merging beads on a necklace.\n\n    The function takes a list of integers representing the energy beads on a necklace, where\n    each bead has a head and a tail value. The head value of each bead must match the tail\n    value of the next bead in the sequence. The necklace is circular, and merging two adjacent\n    beads releases energy equal to the product of the head value of the first bead, the matching\n    value, and the tail value of the second bead.\n\n    To find the maximum energy release, the function considers all possible orders of merging beads\n    and uses dynamic programming to compute the maximum energy obtainable.\n\n    Args:\n        beads: A list of integers where each integer represents the head value of a bead and\n               the tail value of the previous bead. The tail value of the last bead is assumed\n               to match the head value of the first bead due to the circular nature of the necklace.\n\n    Returns:\n        An integer representing the maximum energy that can be obtained by optimally merging all beads.\n\n    Examples:\n        >>> max_energy([2, 3, 5, 10])\n        710\n        This sequence represents beads with values (2,3), (3,5), (5,10), (10,2). The maximum energy\n        released by merging them in the optimal order is 710.\n\n        >>> max_energy([1, 2, 3, 4])\n        48\n        This sequence represents beads with values (1,2), (2,3), (3,4), (4,1). The maximum energy\n        released by merging them in the optimal order is 48.\n    \"\"\"",
      "es": "def max_energy(beads):\n    \"\"\"\n    Calcula la energía máxima que se puede liberar al fusionar cuentas en un collar.\n\n    La función toma una lista de enteros que representan las cuentas de energía en un collar, donde\n    cada cuenta tiene un valor de cabeza y un valor de cola. El valor de cabeza de cada cuenta debe coincidir\n    con el valor de cola de la siguiente cuenta en la secuencia. El collar es circular, y fusionar dos cuentas adyacentes\n    libera energía igual al producto del valor de cabeza de la primera cuenta, el valor coincidente,\n    y el valor de cola de la segunda cuenta.\n\n    Para encontrar la liberación máxima de energía, la función considera todos los posibles órdenes de fusión de cuentas\n    y utiliza programación dinámica para calcular la energía máxima obtenible.\n\n    Argumentos:\n        beads: Una lista de enteros donde cada entero representa el valor de cabeza de una cuenta y\n               el valor de cola de la cuenta anterior. Se asume que el valor de cola de la última cuenta\n               coincide con el valor de cabeza de la primera cuenta debido a la naturaleza circular del collar.\n\n    Devuelve:\n        Un entero que representa la energía máxima que se puede obtener fusionando todas las cuentas de manera óptima.\n\n    Ejemplos:\n        >>> max_energy([2, 3, 5, 10])\n        710\n        Esta secuencia representa cuentas con valores (2,3), (3,5), (5,10), (10,2). La energía máxima\n        liberada al fusionarlas en el orden óptimo es 710.\n\n        >>> max_energy([1, 2, 3, 4])\n        48\n        Esta secuencia representa cuentas con valores (1,2), (2,3), (3,4), (4,1). La energía máxima\n        liberada al fusionarlas en el orden óptimo es 48.\n    \"\"\"",
      "arb": "def max_energy(beads):\n    \"\"\"\n    حساب الطاقة القصوى التي يمكن إطلاقها عن طريق دمج الخرزات في قلادة.\n\n    تأخذ الدالة قائمة من الأعداد الصحيحة التي تمثل خرزات الطاقة في قلادة، حيث\n    يحتوي كل خرزة على قيمة رأس وقيمة ذيل. يجب أن تتطابق قيمة الرأس لكل خرزة مع قيمة الذيل\n    للخرزة التالية في التسلسل. القلادة دائرية، ودمج خرزتين متجاورتين يطلق طاقة تساوي حاصل ضرب قيمة الرأس للخرزة الأولى،\n    والقيمة المطابقة، وقيمة الذيل للخرزة الثانية.\n\n    لإيجاد إطلاق الطاقة الأقصى، تأخذ الدالة في الاعتبار جميع أوامر دمج الخرزات الممكنة\n    وتستخدم البرمجة الديناميكية لحساب الطاقة القصوى الممكن الحصول عليها.\n\n    يعيدالحجج:\n        beads: قائمة من الأعداد الصحيحة حيث يمثل كل عدد صحيح قيمة الرأس لخرزة و\n               قيمة الذيل للخرزة السابقة. يُفترض أن قيمة الذيل للخرزة الأخيرة تتطابق\n               مع قيمة الرأس للخرزة الأولى بسبب الطبيعة الدائرية للقلادة.\n\n    يعيد:\n        عدد صحيح يمثل الطاقة القصوى التي يمكن الحصول عليها عن طريق دمج جميع الخرزات بشكل مثالي.\n\n    أمثلة:\n        >>> max_energy([2, 3, 5, 10])\n        710\n        تمثل هذه السلسلة خرزات بالقيم (2,3)، (3,5)، (5,10)، (10,2). الطاقة القصوى\n        التي يتم إطلاقها عن طريق دمجها بالترتيب الأمثل هي 710.\n\n        >>> max_energy([1, 2, 3, 4])\n        48\n        تمثل هذه السلسلة خرزات بالقيم (1,2)، (2,3)، (3,4)، (4,1). الطاقة القصوى\n        التي يتم إطلاقها عن طريق دمجها بالترتيب الأمثل هي 48.\n    \"\"\"",
      "sw": "def max_energy(beads):\n    \"\"\"\n    Kuhesabu nishati ya juu zaidi inayoweza kutolewa kwa kuunganisha shanga kwenye mkufu.\n\n    Kazi inachukua orodha ya nambari za mzima zinazoashiria shanga za nishati kwenye mkufu, ambapo\n    kila shanga ina thamani ya kichwa na mkia. Thamani ya kichwa ya kila shanga lazima ilingane na thamani ya mkia\n    wa shanga inayofuata katika mlolongo. Mkufu ni wa mviringo, na kuunganisha shanga mbili zilizo karibu\n    hutolewa nishati sawa na bidhaa ya thamani ya kichwa ya shanga ya kwanza, thamani inayolingana,\n    na thamani ya mkia wa shanga ya pili.\n\n    Ili kupata nishati ya juu zaidi inayotolewa, kazi inazingatia maagizo yote yanayowezekana ya kuunganisha shanga\n    na hutumia programu ya nguvu kuhesabu nishati ya juu inayoweza kupatikana.\n\n    Hoja:\n        beads: Orodha ya nambari za mzima ambapo kila nambari inawakilisha thamani ya kichwa ya shanga na\n               thamani ya mkia wa shanga iliyotangulia. Thamani ya mkia wa shanga ya mwisho inadhaniwa\n               kulingana na thamani ya kichwa ya shanga ya kwanza kutokana na asili ya mviringo ya mkufu.\n\n    Inarejesha:\n        Nambari ya mzima inayowakilisha nishati ya juu zaidi inayoweza kupatikana kwa kuunganisha shanga zote kwa njia bora.\n\n    Mifano:\n        >>> max_energy([2, 3, 5, 10])\n        710\n        Mlolongo huu unawakilisha shanga zenye thamani (2,3), (3,5), (5,10), (10,2). Nishati ya juu zaidi\n        inayotolewa kwa kuziunganisha kwa mpangilio bora ni 710.\n\n        >>> max_energy([1, 2, 3, 4])\n        48\n        Mlolongo huu unawakilisha shanga zenye thamani (1,2), (2,3), (3,4), (4,1). Nishati ya juu zaidi\n        inayotolewa kwa kuziunganisha kwa mpangilio bora ni 48.\n    \"\"\"",
      "tr": "def max_energy(beads):\n    \"\"\"\n    Bir kolyedeki boncukları birleştirerek açığa çıkabilecek maksimum enerjiyi hesaplayın.\n\n    Fonksiyon, bir kolyede enerji boncuklarını temsil eden bir tamsayı listesi alır, burada\n    her boncuğun bir baş ve bir kuyruk değeri vardır. Her boncuğun baş değeri, dizideki bir sonraki\n    boncuğun kuyruk değeriyle eşleşmelidir. Kolyenin yapısı daireseldir ve iki bitişik boncuğun\n    birleştirilmesi, ilk boncuğun baş değeri, eşleşen değer ve ikinci boncuğun kuyruk değerinin\n    çarpımına eşit enerji açığa çıkarır.\n\n    Maksimum enerji açığa çıkışını bulmak için, fonksiyon boncukları birleştirmenin tüm olası\n    sıralarını dikkate alır ve dinamik programlama kullanarak elde edilebilecek maksimum enerjiyi\n    hesaplar.\n\n    Argümanlar:\n        beads: Her tamsayının bir boncuğun baş değerini ve önceki boncuğun kuyruk değerini\n               temsil ettiği bir tamsayı listesi. Kolyenin dairesel yapısından dolayı son\n               boncuğun kuyruk değerinin ilk boncuğun baş değeriyle eşleştiği varsayılır.\n\n    Döndürür:\n        Tüm boncukları optimal bir şekilde birleştirerek elde edilebilecek maksimum enerjiyi\n        temsil eden bir tamsayı.\n\n    Örnekler:\n        >>> max_energy([2, 3, 5, 10])\n        710\n        Bu dizi, (2,3), (3,5), (5,10), (10,2) değerlerine sahip boncukları temsil eder. Onları\n        optimal sırayla birleştirerek açığa çıkan maksimum enerji 710'dur.\n\n        >>> max_energy([1, 2, 3, 4])\n        48\n        Bu dizi, (1,2), (2,3), (3,4), (4,1) değerlerine sahip boncukları temsil eder. Onları\n        optimal sırayla birleştirerek açığa çıkan maksimum enerji 48'dir.\n    \"\"\"",
      "vi": "def max_energy(beads):\n    \"\"\"\n    Tính toán năng lượng tối đa có thể được giải phóng bằng cách hợp nhất các hạt trên một vòng cổ.\n\n    Hàm nhận một danh sách các số nguyên đại diện cho năng lượng của các hạt trên một vòng cổ, \n    trong đó mỗi hạt có một giá trị đầu và một giá trị đuôi. Giá trị đầu của mỗi hạt phải khớp \n    với giá trị đuôi của hạt tiếp theo trong chuỗi. Vòng cổ là hình tròn, và việc hợp nhất hai hạt \n    liền kề giải phóng năng lượng bằng tích của giá trị đầu của hạt thứ nhất, giá trị khớp, và \n    giá trị đuôi của hạt thứ hai.\n\n    Để tìm năng lượng giải phóng tối đa, hàm xem xét tất cả các thứ tự hợp nhất hạt có thể có và \n    sử dụng lập trình động để tính toán năng lượng tối đa có thể đạt được.\n\n    Tham số:\n        beads: Một danh sách các số nguyên trong đó mỗi số nguyên đại diện cho giá trị đầu của \n               một hạt và giá trị đuôi của hạt trước đó. Giá trị đuôi của hạt cuối cùng được giả \n               định là khớp với giá trị đầu của hạt đầu tiên do tính chất hình tròn của vòng cổ.\n\n    Trả về:\n        Một số nguyên đại diện cho năng lượng tối đa có thể đạt được bằng cách hợp nhất tối ưu \n        tất cả các hạt.\n\n    Ví dụ:\n        >>> max_energy([2, 3, 5, 10])\n        710\n        Dãy này đại diện cho các hạt có giá trị (2,3), (3,5), (5,10), (10,2). Năng lượng tối đa \n        được giải phóng bằng cách hợp nhất chúng theo thứ tự tối ưu là 710.\n\n        >>> max_energy([1, 2, 3, 4])\n        48\n        Dãy này đại diện cho các hạt có giá trị (1,2), (2,3), (3,4), (4,1). Năng lượng tối đa \n        được giải phóng bằng cách hợp nhất chúng theo thứ tự tối ưu là 48.\n    \"\"\""
    },
    "prompt_bertscore": {
      "es": "0.985316844973139",
      "arb": "0.9845068302792788",
      "sw": "0.9691391949593715",
      "tr": "0.955432308255297",
      "vi": "0.9707457174811817"
    },
    "canonical_solution": "    n = len(beads)\n    # Duplicate the sequence to account for the circular nature of the necklace\n    beads *= 2\n    # Initialize the DP table\n    # dp[i][j] will store the maximum energy obtainable from the subsequence beads[i] to beads[j]\n    dp = [[0] * (2 * n) for _ in range(2 * n)]\n    \n    # Fill the DP table\n    for length in range(2, n+1):  # length of the subsequence\n        for i in range(1, 2 * n - length + 1):\n            j = i + length - 1\n            for k in range(i, j):\n                # Calculate the energy\n                energy = beads[i-1] * beads[k] * beads[j]\n                # Choose the maximum energy\n                dp[i][j] = max(dp[i][j], dp[i][k] + dp[k+1][j] + energy)\n\n    # Find the maximum energy for all possible starting points\n    return max(dp[i][i+n-1] for i in range(1, n+1))",
    "instruction": {
      "en": "def max_energy(beads):\n    n = len(beads)\n    # Duplicate the sequence to account for the circular nature of the necklace\n    beads *= 2\n    # Initialize the DP table\n    # dp[i][j] will store the maximum energy obtainable from the subsequence beads[i] to beads[j]\n    dp = [[0] * (2 * n) for _ in range(2 * n)]\n    \n    # Fill the DP table\n    for length in range(2, n+1):  # length of the subsequence\n        for i in range(1, 2 * n - length + 1):\n            j = i + length - 1\n            for k in range(i, j):\n                # Calculate the energy\n                energy = beads[i-1] * beads[k] * beads[j]\n                # Choose the maximum energy\n                dp[i][j] = max(dp[i][j], dp[i][k] + dp[k+1][j] + energy)\n\n    # Find the maximum energy for all possible starting points\n    return max(dp[i][i+n-1] for i in range(1, n+1))\n\nProvide a concise natural language description (docstring) of the Python code in English using at most 500 characters.",
      "es": "def max_energy(beads):\n    n = len(beads)\n    # Duplicate the sequence to account for the circular nature of the necklace\n    beads *= 2\n    # Initialize the DP table\n    # dp[i][j] will store the maximum energy obtainable from the subsequence beads[i] to beads[j]\n    dp = [[0] * (2 * n) for _ in range(2 * n)]\n    \n    # Fill the DP table\n    for length in range(2, n+1):  # length of the subsequence\n        for i in range(1, 2 * n - length + 1):\n            j = i + length - 1\n            for k in range(i, j):\n                # Calculate the energy\n                energy = beads[i-1] * beads[k] * beads[j]\n                # Choose the maximum energy\n                dp[i][j] = max(dp[i][j], dp[i][k] + dp[k+1][j] + energy)\n\n    # Find the maximum energy for all possible starting points\n    return max(dp[i][i+n-1] for i in range(1, n+1))\n\nProporcione una descripción concisa en lenguaje natural (docstring) del código Python en español utilizando como máximo 500 caracteres.",
      "arb": "def max_energy(beads):\n    n = len(beads)\n    # Duplicate the sequence to account for the circular nature of the necklace\n    beads *= 2\n    # Initialize the DP table\n    # dp[i][j] will store the maximum energy obtainable from the subsequence beads[i] to beads[j]\n    dp = [[0] * (2 * n) for _ in range(2 * n)]\n    \n    # Fill the DP table\n    for length in range(2, n+1):  # length of the subsequence\n        for i in range(1, 2 * n - length + 1):\n            j = i + length - 1\n            for k in range(i, j):\n                # Calculate the energy\n                energy = beads[i-1] * beads[k] * beads[j]\n                # Choose the maximum energy\n                dp[i][j] = max(dp[i][j], dp[i][k] + dp[k+1][j] + energy)\n\n    # Find the maximum energy for all possible starting points\n    return max(dp[i][i+n-1] for i in range(1, n+1))\n\nقدم وصفًا موجزًا بلغة طبيعية (docstring) لشيفرة Python باللغة العربية الفصحى باستخدام 500 حرف كحد أقصى.",
      "sw": "def max_energy(beads):\n    n = len(beads)\n    # Duplicate the sequence to account for the circular nature of the necklace\n    beads *= 2\n    # Initialize the DP table\n    # dp[i][j] will store the maximum energy obtainable from the subsequence beads[i] to beads[j]\n    dp = [[0] * (2 * n) for _ in range(2 * n)]\n    \n    # Fill the DP table\n    for length in range(2, n+1):  # length of the subsequence\n        for i in range(1, 2 * n - length + 1):\n            j = i + length - 1\n            for k in range(i, j):\n                # Calculate the energy\n                energy = beads[i-1] * beads[k] * beads[j]\n                # Choose the maximum energy\n                dp[i][j] = max(dp[i][j], dp[i][k] + dp[k+1][j] + energy)\n\n    # Find the maximum energy for all possible starting points\n    return max(dp[i][i+n-1] for i in range(1, n+1))\n\nToa maelezo mafupi ya lugha asilia (docstring) ya msimbo wa Python kwa Kiswahili kwa kutumia herufi zisizozidi 500.",
      "tr": "def max_energy(beads):\n    n = len(beads)\n    # Duplicate the sequence to account for the circular nature of the necklace\n    beads *= 2\n    # Initialize the DP table\n    # dp[i][j] will store the maximum energy obtainable from the subsequence beads[i] to beads[j]\n    dp = [[0] * (2 * n) for _ in range(2 * n)]\n    \n    # Fill the DP table\n    for length in range(2, n+1):  # length of the subsequence\n        for i in range(1, 2 * n - length + 1):\n            j = i + length - 1\n            for k in range(i, j):\n                # Calculate the energy\n                energy = beads[i-1] * beads[k] * beads[j]\n                # Choose the maximum energy\n                dp[i][j] = max(dp[i][j], dp[i][k] + dp[k+1][j] + energy)\n\n    # Find the maximum energy for all possible starting points\n    return max(dp[i][i+n-1] for i in range(1, n+1))\n\nPython kodunun işlevini açıklayan kısa bir doğal dil açıklaması (docstring) sağlayın. Açıklama, Türkçe olarak en fazla 500 karakter kullanılarak yazılmalıdır.",
      "vi": "def max_energy(beads):\n    n = len(beads)\n    # Duplicate the sequence to account for the circular nature of the necklace\n    beads *= 2\n    # Initialize the DP table\n    # dp[i][j] will store the maximum energy obtainable from the subsequence beads[i] to beads[j]\n    dp = [[0] * (2 * n) for _ in range(2 * n)]\n    \n    # Fill the DP table\n    for length in range(2, n+1):  # length of the subsequence\n        for i in range(1, 2 * n - length + 1):\n            j = i + length - 1\n            for k in range(i, j):\n                # Calculate the energy\n                energy = beads[i-1] * beads[k] * beads[j]\n                # Choose the maximum energy\n                dp[i][j] = max(dp[i][j], dp[i][k] + dp[k+1][j] + energy)\n\n    # Find the maximum energy for all possible starting points\n    return max(dp[i][i+n-1] for i in range(1, n+1))\n\nCung cấp mô tả ngắn gọn bằng ngôn ngữ tự nhiên (docstring) cho mã Python bằng tiếng Việt, sử dụng tối đa 500 ký tự."
    },
    "instruction_bertscore": {
      "es": "0.9687387561112052",
      "arb": "0.9091867856819922",
      "sw": "0.9426438884331277",
      "tr": "0.8685984549909421",
      "vi": "0.9069722555638342"
    },
    "level": "",
    "test": "def test_max_energy():\n    assert max_energy([2, 3, 5, 10]) == 710, \"Testcase 1 failed\"\n    assert max_energy([1, 2, 3, 4]) == 80, \"Testcase 2 failed\"\n    assert max_energy([4, 4, 4, 4]) == 192, \"Testcase 3 failed\"\n    assert max_energy([30, 40, 50, 60]) == 372000, \"Testcase 4 failed\"\n    print(\"All testcases passed\")\n\n# Call the test function\ntest_max_energy()",
    "entry_point": "max_energy",
    "signature": "def max_energy(beads):",
    "docstring": {
      "en": "Calculate the maximum energy that can be released by merging beads on a necklace.\n\nThe function takes a list of integers representing the energy beads on a necklace, where\neach bead has a head and a tail value. The head value of each bead must match the tail\nvalue of the next bead in the sequence. The necklace is circular, and merging two adjacent\nbeads releases energy equal to the product of the head value of the first bead, the matching\nvalue, and the tail value of the second bead.\n\nTo find the maximum energy release, the function considers all possible orders of merging beads\nand uses dynamic programming to compute the maximum energy obtainable.\n\nArgs:\nbeads: A list of integers where each integer represents the head value of a bead and\nthe tail value of the previous bead. The tail value of the last bead is assumed\nto match the head value of the first bead due to the circular nature of the necklace.\n\nReturns:\nAn integer representing the maximum energy that can be obtained by optimally merging all beads.\n\nExamples:\n>>> max_energy([2, 3, 5, 10])\n710\nThis sequence represents beads with values (2,3), (3,5), (5,10), (10,2). The maximum energy\nreleased by merging them in the optimal order is 710.\n\n>>> max_energy([1, 2, 3, 4])\n48\nThis sequence represents beads with values (1,2), (2,3), (3,4), (4,1). The maximum energy\nreleased by merging them in the optimal order is 48.",
      "es": "Calcular la energía máxima que se puede liberar al fusionar cuentas en un collar.\n\nLa función toma una lista de enteros que representan las cuentas de energía en un collar, donde\ncada cuenta tiene un valor de cabeza y un valor de cola. El valor de cabeza de cada cuenta debe coincidir con el valor de cola de la siguiente cuenta en la secuencia. El collar es circular, y fusionar dos cuentas adyacentes libera energía igual al producto del valor de cabeza de la primera cuenta, el valor coincidente y el valor de cola de la segunda cuenta.\n\nPara encontrar la liberación máxima de energía, la función considera todos los órdenes posibles de fusión de cuentas y utiliza programación dinámica para calcular la energía máxima obtenible.\n\nArgumentos:\nbeads: Una lista de enteros donde cada entero representa el valor de cabeza de una cuenta y\nel valor de cola de la cuenta anterior. Se supone que el valor de cola de la última cuenta coincide\ncon el valor de cabeza de la primera cuenta debido a la naturaleza circular del collar.\n\nDevuelve:\nUn entero que representa la energía máxima que se puede obtener al fusionar óptimamente todas las cuentas.\n\nEjemplos:\n>>> max_energy([2, 3, 5, 10])\n710\nEsta secuencia representa cuentas con valores (2,3), (3,5), (5,10), (10,2). La energía máxima\nliberada al fusionarlas en el orden óptimo es 710.\n\n>>> max_energy([1, 2, 3, 4])\n48\nEsta secuencia representa cuentas con valores (1,2), (2,3), (3,4), (4,1). La energía máxima\nliberada al fusionarlas en el orden óptimo es 48.",
      "arb": "حساب الحد الأقصى للطاقة التي يمكن إطلاقها عن طريق دمج الخرزات في عقد.\n\nتأخذ الدالة قائمة من الأعداد الصحيحة التي تمثل خرزات الطاقة على العقد، حيث\nكل خرزة لها قيمة رأس وقيمة ذيل. يجب أن تتطابق قيمة الرأس لكل خرزة مع قيمة الذيل\nللخرزة التالية في التسلسل. العقد دائري، ودمج خرزتين متجاورتين يطلق طاقة تساوي حاصل ضرب قيمة الرأس للخرزة الأولى، والقيمة المطابقة، وقيمة الذيل للخرزة الثانية.\n\nلإيجاد الحد الأقصى لإطلاق الطاقة، تأخذ الدالة في الاعتبار جميع أوامر دمج الخرزات الممكنة\nوتستخدم البرمجة الديناميكية لحساب الحد الأقصى للطاقة الممكن الحصول عليها.\n\nالمعطيات:\nbeads: قائمة من الأعداد الصحيحة حيث يمثل كل عدد صحيح قيمة الرأس لخرزة و\nقيمة الذيل للخرزة السابقة. يُفترض أن تتطابق قيمة الذيل للخرزة الأخيرة\nمع قيمة الرأس للخرزة الأولى بسبب الطبيعة الدائرية للعقد.\n\nالقيم المعادة:\nعدد صحيح يمثل الحد الأقصى للطاقة التي يمكن الحصول عليها عن طريق دمج جميع الخرزات بشكل مثالي.\n\nأمثلة:\n>>> max_energy([2, 3, 5, 10])\n710\nيمثل هذا التسلسل خرزات بقيم (2,3)، (3,5)، (5,10)، (10,2). الحد الأقصى للطاقة\nالتي يتم إطلاقها عن طريق دمجها بالترتيب الأمثل هو 710.\n\n>>> max_energy([1, 2, 3, 4])\n48\nيمثل هذا التسلسل خرزات بقيم (1,2)، (2,3)، (3,4)، (4,1). الحد الأقصى للطاقة\nالتي يتم إطلاقها عن طريق دمجها بالترتيب الأمثل هو 48.",
      "sw": "Hesabu nishati ya juu inayoweza kutolewa kwa kuunganisha shanga kwenye mkufu.\n\nKazi hii inachukua orodha ya nambari za mzima zinazowakilisha shanga za nishati kwenye mkufu, ambapo\nkila shanga ina thamani ya kichwa na mkia. Thamani ya kichwa ya kila shanga lazima ilingane na thamani ya mkia\nya shanga inayofuata katika mlolongo. Mkufu ni wa mviringo, na kuunganisha shanga mbili zilizo karibu\nhutoa nishati sawa na bidhaa ya thamani ya kichwa ya shanga ya kwanza, thamani inayolingana, na thamani ya mkia ya shanga ya pili.\n\nIli kupata utoaji wa nishati ya juu, kazi inazingatia mpangilio wote unaowezekana wa kuunganisha shanga\nna hutumia programu ya nguvu kuhesabu nishati ya juu inayoweza kupatikana.\n\nHoja:\nbeads: Orodha ya nambari za mzima ambapo kila nambari inawakilisha thamani ya kichwa ya shanga na\nthamani ya mkia ya shanga iliyotangulia. Thamani ya mkia ya shanga ya mwisho inachukuliwa\nkulingana na thamani ya kichwa ya shanga ya kwanza kutokana na asili ya mviringo ya mkufu.\n\nInarejesha:\nNambari ya mzima inayowakilisha nishati ya juu inayoweza kupatikana kwa kuunganisha shanga zote kwa njia bora.\n\nMifano:\n>>> max_energy([2, 3, 5, 10])\n710\nMlolongo huu unawakilisha shanga zenye thamani (2,3), (3,5), (5,10), (10,2). Nishati ya juu\ninayotolewa kwa kuziunganisha kwa mpangilio bora ni 710.\n\n>>> max_energy([1, 2, 3, 4])\n48\nMlolongo huu unawakilisha shanga zenye thamani (1,2), (2,3), (3,4), (4,1). Nishati ya juu\ninayotolewa kwa kuziunganisha kwa mpangilio bora ni 48.",
      "tr": "Boncukları bir kolyede birleştirerek serbest bırakılabilecek maksimum enerjiyi hesaplayın.\n\nFonksiyon, bir kolyedeki enerji boncuklarını temsil eden bir tamsayı listesini alır, burada\nher boncuğun bir baş ve bir kuyruk değeri vardır. Her boncuğun baş değeri, dizideki bir sonraki\nboncuğun kuyruk değeriyle eşleşmelidir. Kolyenin yapısı daireseldir ve iki bitişik boncuğun\nbirleştirilmesi, ilk boncuğun baş değeri, eşleşen değer ve ikinci boncuğun kuyruk değerinin\nçarpımına eşit enerji serbest bırakır.\n\nMaksimum enerji salınımını bulmak için, fonksiyon boncukları birleştirmenin tüm olası sıralarını\ndüşünür ve elde edilebilecek maksimum enerjiyi hesaplamak için dinamik programlama kullanır.\n\nArgümanlar:\nbeads: Her tamsayının bir boncuğun baş değerini ve\nönceki boncuğun kuyruk değerini temsil ettiği bir tamsayı listesi. Kolye yapısının\ndairesel doğası nedeniyle son boncuğun kuyruk değerinin ilk boncuğun baş değeriyle eşleştiği varsayılır.\n\nDöndürür:\nTüm boncukları optimal bir şekilde birleştirerek elde edilebilecek maksimum enerjiyi temsil eden bir tamsayı.\n\nÖrnekler:\n>>> max_energy([2, 3, 5, 10])\n710\nBu dizi, değerleri (2,3), (3,5), (5,10), (10,2) olan boncukları temsil eder. Bunları optimal sırayla\nbirleştirerek serbest bırakılan maksimum enerji 710'dur.\n\n>>> max_energy([1, 2, 3, 4])\n48\nBu dizi, değerleri (1,2), (2,3), (3,4), (4,1) olan boncukları temsil eder. Bunları optimal sırayla\nbirleştirerek serbest bırakılan maksimum enerji 48'dir.",
      "vi": "Tính toán năng lượng tối đa có thể được giải phóng bằng cách hợp nhất các hạt trên một chuỗi hạt.\n\nHàm nhận vào một danh sách các số nguyên đại diện cho các hạt năng lượng trên một chuỗi hạt, trong đó\nmỗi hạt có một giá trị đầu và một giá trị đuôi. Giá trị đầu của mỗi hạt phải khớp với giá trị đuôi\ncủa hạt tiếp theo trong chuỗi. Chuỗi hạt là vòng tròn, và việc hợp nhất hai hạt liền kề\ngiải phóng năng lượng bằng tích của giá trị đầu của hạt thứ nhất, giá trị khớp, và giá trị đuôi của hạt thứ hai.\n\nĐể tìm năng lượng giải phóng tối đa, hàm xem xét tất cả các thứ tự hợp nhất hạt có thể có\nvà sử dụng lập trình động để tính toán năng lượng tối đa có thể đạt được.\n\nTham số:\nbeads: Một danh sách các số nguyên trong đó mỗi số nguyên đại diện cho giá trị đầu của một hạt và\ngiá trị đuôi của hạt trước đó. Giá trị đuôi của hạt cuối cùng được giả định\nkhớp với giá trị đầu của hạt đầu tiên do tính chất vòng tròn của chuỗi hạt.\n\nTrả về:\nMột số nguyên đại diện cho năng lượng tối đa có thể đạt được bằng cách hợp nhất tối ưu tất cả các hạt.\n\nVí dụ:\n>>> max_energy([2, 3, 5, 10])\n710\nChuỗi này đại diện cho các hạt có giá trị (2,3), (3,5), (5,10), (10,2). Năng lượng tối đa\nđược giải phóng bằng cách hợp nhất chúng theo thứ tự tối ưu là 710.\n\n>>> max_energy([1, 2, 3, 4])\n48\nChuỗi này đại diện cho các hạt có giá trị (1,2), (2,3), (3,4), (4,1). Năng lượng tối đa\nđược giải phóng bằng cách hợp nhất chúng theo thứ tự tối ưu là 48."
    },
    "docstring_bertscore": {
      "es": "0.9881183278672551",
      "arb": "0.983495404379049",
      "sw": "0.965902711530789",
      "tr": "0.9531293876175785",
      "vi": "0.9468651812908812"
    }
  },
  {
    "task_id": "Python/20",
    "prompt": {
      "en": "from typing import List \ndef polynomial_to_string(n: int, coeffs: List[int]) -> str:\n    \"\"\"\n    Converts a list of polynomial coefficients into a formatted string representation.\n\n    The function takes in the highest degree `n` of the polynomial and a list of coefficients `coeffs`,\n    which are ordered from the highest degree term to the constant term. It returns a string that\n    represents the polynomial with the following rules:\n    - Terms with a coefficient of zero are omitted.\n    - The sign of each term is determined (+ for positive, - for negative), with no leading '+' for the first term.\n    - The absolute value of the coefficient is shown unless it's 1 and the term includes the variable `x`.\n    - The variable part is formatted based on its degree; `x^degree` for degree > 1, `x` for degree 1, and\n      nothing for degree 0 (constant term).\n    - Terms are joined without additional spaces, starting with the highest degree term.\n\n    Args:\n        n (int): The highest degree of the polynomial.\n        coeffs (List[int]): A list of coefficients, starting with the coefficient of the highest degree term.\n\n    Returns:\n        str: The string representation of the polynomial.\n\n    Examples:\n        >>> polynomial_to_string(5, [100, -1, 1, -3, 0, 10])\n        '100x^5-x^4+x^3-3x^2+10'\n\n        >>> polynomial_to_string(3, [-50, 0, 0, 1])\n        '-50x^3+1'\n    \"\"\"",
      "es": "from typing import List \ndef polynomial_to_string(n: int, coeffs: List[int]) -> str:\n    \"\"\"\n    Convierte una lista de coeficientes de un polinomio en una representación de cadena formateada.\n\n    La función recibe el grado más alto `n` del polinomio y una lista de coeficientes `coeffs`,\n    que están ordenados desde el término de mayor grado hasta el término constante. Devuelve una cadena que\n    representa el polinomio con las siguientes reglas:\n    - Se omiten los términos con un coeficiente de cero.\n    - El signo de cada término se determina (+ para positivo, - para negativo), sin un '+' inicial para el primer término.\n    - Se muestra el valor absoluto del coeficiente a menos que sea 1 y el término incluya la variable `x`.\n    - La parte variable se formatea según su grado; `x^grado` para grado > 1, `x` para grado 1, y\n      nada para grado 0 (término constante).\n    - Los términos se unen sin espacios adicionales, comenzando con el término de mayor grado.\n\n    Argumentos:\n        n (int): El grado más alto del polinomio.\n        coeffs (List[int]): Una lista de coeficientes, comenzando con el coeficiente del término de mayor grado.\n\n    Devuelve:\n        str: La representación en cadena del polinomio.\n\n    Ejemplos:\n        >>> polynomial_to_string(5, [100, -1, 1, -3, 0, 10])\n        '100x^5-x^4+x^3-3x^2+10'\n\n        >>> polynomial_to_string(3, [-50, 0, 0, 1])\n        '-50x^3+1'\n    \"\"\"",
      "arb": "from typing import List \ndef polynomial_to_string(n: int, coeffs: List[int]) -> str:\n    \"\"\"\n    يحول قائمة من معاملات متعددة الحدود إلى تمثيل سلسلة منسق.\n\n    تأخذ الدالة أعلى درجة `n` لمتعددة الحدود وقائمة من المعاملات `coeffs`,\n    التي تكون مرتبة من الحد ذو الدرجة الأعلى إلى الحد الثابت. تعيد سلسلة\n    تمثل متعددة الحدود بالقواعد التالية:\n    - يتم حذف الحدود ذات المعامل الصفري.\n    - يتم تحديد إشارة كل حد (+ للإيجابي، - للسلبي)، بدون '+' في البداية للحد الأول.\n    - يتم عرض القيمة المطلقة للمعامل إلا إذا كانت 1 والحد يتضمن المتغير `x`.\n    - يتم تنسيق الجزء المتغير بناءً على درجته؛ `x^degree` للدرجة > 1، `x` للدرجة 1، ولا شيء للدرجة 0 (الحد الثابت).\n    - يتم ربط الحدود بدون مسافات إضافية، بدءًا من الحد ذو الدرجة الأعلى.\n\n    يعيدالحجج:\n        n (int): أعلى درجة لمتعددة الحدود.\n        coeffs (List[int]): قائمة بالمعاملات، بدءًا من معامل الحد ذو الدرجة الأعلى.\n\n    يعيد:\n        str: تمثيل السلسلة لمتعددة الحدود.\n\n    أمثلة:\n        >>> polynomial_to_string(5, [100, -1, 1, -3, 0, 10])\n        '100x^5-x^4+x^3-3x^2+10'\n\n        >>> polynomial_to_string(3, [-50, 0, 0, 1])\n        '-50x^3+1'\n    \"\"\"",
      "sw": "from typing import List \ndef polynomial_to_string(n: int, coeffs: List[int]) -> str:\n    \"\"\"\n    Hubadilisha orodha ya vigezo vya polinomu kuwa mwakilishi wa maandishi uliopangwa.\n\n    Kazi inachukua kiwango cha juu `n` cha polinomu na orodha ya vigezo `coeffs`,\n    ambavyo vimepangwa kutoka kwa kiwango cha juu cha neno hadi neno la mara kwa mara. Inarudisha kamba ambayo\n    inawakilisha polinomu kwa sheria zifuatazo:\n    - Maneno yenye kigezo cha sifuri hayajumuishwi.\n    - Alama ya kila neno imedhamiriwa (+ kwa chanya, - kwa hasi), bila '+' inayoongoza kwa neno la kwanza.\n    - Thamani kamili ya kigezo inaonyeshwa isipokuwa ni 1 na neno linajumuisha kigezo `x`.\n    - Sehemu ya kigezo imepangwa kulingana na kiwango chake; `x^degree` kwa degree > 1, `x` kwa degree 1, na\n      hakuna kitu kwa degree 0 (neno la mara kwa mara).\n    - Maneno yanaunganishwa bila nafasi za ziada, kuanzia na neno la kiwango cha juu zaidi.\n\n    Hoja:\n        n (int): Kiwango cha juu cha polinomu.\n        coeffs (List[int]): Orodha ya vigezo, kuanzia na kigezo cha neno la kiwango cha juu zaidi.\n\n    Inarejesha:\n        str: Mwakilishi wa maandishi wa polinomu.\n\n    Mifano:\n        >>> polynomial_to_string(5, [100, -1, 1, -3, 0, 10])\n        '100x^5-x^4+x^3-3x^2+10'\n\n        >>> polynomial_to_string(3, [-50, 0, 0, 1])\n        '-50x^3+1'\n    \"\"\"",
      "tr": "from typing import List \ndef polynomial_to_string(n: int, coeffs: List[int]) -> str:\n    \"\"\"\n    Bir polinom katsayıları listesini biçimlendirilmiş bir string gösterimine dönüştürür.\n\n    Fonksiyon, polinomun en yüksek derecesi `n` ve en yüksek dereceli terimden sabit terime kadar sıralanmış\n    bir katsayılar listesi `coeffs` alır. Aşağıdaki kurallarla polinomu temsil eden bir string döndürür:\n    - Katsayısı sıfır olan terimler atlanır.\n    - Her terimin işareti belirlenir (+ pozitif için, - negatif için), ilk terim için başta '+' yoktur.\n    - Katsayının mutlak değeri gösterilir, ancak katsayı 1 ise ve terim `x` değişkenini içeriyorsa gösterilmez.\n    - Değişken kısmı derecesine göre biçimlendirilir; derece > 1 için `x^degree`, derece 1 için `x` ve\n      derece 0 (sabit terim) için hiçbir şey.\n    - Terimler ek boşluk olmadan birleştirilir, en yüksek dereceli terimle başlar.\n\n    Argümanlar:\n        n (int): Polinomun en yüksek derecesi.\n        coeffs (List[int]): En yüksek dereceli terimin katsayısı ile başlayan bir katsayılar listesi.\n\n    Döndürür:\n        str: Polinomun string gösterimi.\n\n    Örnekler:\n        >>> polynomial_to_string(5, [100, -1, 1, -3, 0, 10])\n        '100x^5-x^4+x^3-3x^2+10'\n\n        >>> polynomial_to_string(3, [-50, 0, 0, 1])\n        '-50x^3+1'\n    \"\"\"",
      "vi": "from typing import List \ndef polynomial_to_string(n: int, coeffs: List[int]) -> str:\n    \"\"\"\n    Chuyển đổi một danh sách các hệ số đa thức thành một chuỗi định dạng biểu diễn.\n\n    Hàm nhận vào bậc cao nhất `n` của đa thức và một danh sách các hệ số `coeffs`,\n    được sắp xếp từ hạng tử có bậc cao nhất đến hạng tử hằng số. Nó trả về một chuỗi\n    biểu diễn đa thức với các quy tắc sau:\n    - Các hạng tử có hệ số bằng không sẽ bị bỏ qua.\n    - Dấu của mỗi hạng tử được xác định (+ cho dương, - cho âm), không có dấu '+' dẫn đầu cho hạng tử đầu tiên.\n    - Giá trị tuyệt đối của hệ số được hiển thị trừ khi nó là 1 và hạng tử bao gồm biến `x`.\n    - Phần biến được định dạng dựa trên bậc của nó; `x^degree` cho bậc > 1, `x` cho bậc 1, và\n      không có gì cho bậc 0 (hạng tử hằng số).\n    - Các hạng tử được nối với nhau mà không có khoảng trắng bổ sung, bắt đầu với hạng tử có bậc cao nhất.\n\n    Tham số:\n        n (int): Bậc cao nhất của đa thức.\n        coeffs (List[int]): Một danh sách các hệ số, bắt đầu với hệ số của hạng tử có bậc cao nhất.\n\n    Trả về:\n        str: Chuỗi biểu diễn của đa thức.\n\n    Ví dụ:\n        >>> polynomial_to_string(5, [100, -1, 1, -3, 0, 10])\n        '100x^5-x^4+x^3-3x^2+10'\n\n        >>> polynomial_to_string(3, [-50, 0, 0, 1])\n        '-50x^3+1'\n    \"\"\""
    },
    "prompt_bertscore": {
      "es": "0.9922144835849566",
      "arb": "0.9859870238787507",
      "sw": "0.9894133979516025",
      "tr": "0.9623555701862679",
      "vi": "0.975375990293486"
    },
    "canonical_solution": "    result = []\n\n    for i in range(n + 1):\n        coeff = coeffs[i]\n        degree = n - i\n\n        # Skip coefficients that are zero\n        if coeff == 0:\n            continue\n\n        # Handle the sign (+/-) of the coefficient\n        sign = '-' if coeff < 0 else '+'\n        if i == 0:  # First term does not need a leading '+'\n            sign = '-' if coeff < 0 else ''\n        \n        # Handle the absolute value of the coefficient\n        abs_coeff = abs(coeff)\n        if abs_coeff == 1 and degree != 0:  # Omit the '1' for x terms\n            abs_coeff_str = ''\n        else:\n            abs_coeff_str = str(abs_coeff)\n        \n        # Handle the variable part\n        if degree == 0:\n            term = abs_coeff_str\n        elif degree == 1:\n            term = f\"{abs_coeff_str}x\"\n        else:\n            term = f\"{abs_coeff_str}x^{degree}\"\n\n        # Combine sign and term and append to result\n        result.append(f\"{sign}{term}\")\n\n    # Join all the terms and return the polynomial string\n    return ''.join(result)",
    "instruction": {
      "en": "def polynomial_to_string(n: int, coeffs: List[int]) -> str:\n    result = []\n\n    for i in range(n + 1):\n        coeff = coeffs[i]\n        degree = n - i\n\n        # Skip coefficients that are zero\n        if coeff == 0:\n            continue\n\n        # Handle the sign (+/-) of the coefficient\n        sign = '-' if coeff < 0 else '+'\n        if i == 0:  # First term does not need a leading '+'\n            sign = '-' if coeff < 0 else ''\n        \n        # Handle the absolute value of the coefficient\n        abs_coeff = abs(coeff)\n        if abs_coeff == 1 and degree != 0:  # Omit the '1' for x terms\n            abs_coeff_str = ''\n        else:\n            abs_coeff_str = str(abs_coeff)\n        \n        # Handle the variable part\n        if degree == 0:\n            term = abs_coeff_str\n        elif degree == 1:\n            term = f\"{abs_coeff_str}x\"\n        else:\n            term = f\"{abs_coeff_str}x^{degree}\"\n\n        # Combine sign and term and append to result\n        result.append(f\"{sign}{term}\")\n\n    # Join all the terms and return the polynomial string\n    return ''.join(result)\n\nProvide a concise natural language description (docstring) of the Python code in English using at most 500 characters.",
      "es": "def polynomial_to_string(n: int, coeffs: List[int]) -> str:\n    result = []\n\n    for i in range(n + 1):\n        coeff = coeffs[i]\n        degree = n - i\n\n        # Skip coefficients that are zero\n        if coeff == 0:\n            continue\n\n        # Handle the sign (+/-) of the coefficient\n        sign = '-' if coeff < 0 else '+'\n        if i == 0:  # First term does not need a leading '+'\n            sign = '-' if coeff < 0 else ''\n        \n        # Handle the absolute value of the coefficient\n        abs_coeff = abs(coeff)\n        if abs_coeff == 1 and degree != 0:  # Omit the '1' for x terms\n            abs_coeff_str = ''\n        else:\n            abs_coeff_str = str(abs_coeff)\n        \n        # Handle the variable part\n        if degree == 0:\n            term = abs_coeff_str\n        elif degree == 1:\n            term = f\"{abs_coeff_str}x\"\n        else:\n            term = f\"{abs_coeff_str}x^{degree}\"\n\n        # Combine sign and term and append to result\n        result.append(f\"{sign}{term}\")\n\n    # Join all the terms and return the polynomial string\n    return ''.join(result)\n\nProporcione una descripción concisa en lenguaje natural (docstring) del código Python en español utilizando como máximo 500 caracteres.",
      "arb": "def polynomial_to_string(n: int, coeffs: List[int]) -> str:\n    result = []\n\n    for i in range(n + 1):\n        coeff = coeffs[i]\n        degree = n - i\n\n        # Skip coefficients that are zero\n        if coeff == 0:\n            continue\n\n        # Handle the sign (+/-) of the coefficient\n        sign = '-' if coeff < 0 else '+'\n        if i == 0:  # First term does not need a leading '+'\n            sign = '-' if coeff < 0 else ''\n        \n        # Handle the absolute value of the coefficient\n        abs_coeff = abs(coeff)\n        if abs_coeff == 1 and degree != 0:  # Omit the '1' for x terms\n            abs_coeff_str = ''\n        else:\n            abs_coeff_str = str(abs_coeff)\n        \n        # Handle the variable part\n        if degree == 0:\n            term = abs_coeff_str\n        elif degree == 1:\n            term = f\"{abs_coeff_str}x\"\n        else:\n            term = f\"{abs_coeff_str}x^{degree}\"\n\n        # Combine sign and term and append to result\n        result.append(f\"{sign}{term}\")\n\n    # Join all the terms and return the polynomial string\n    return ''.join(result)\n\nيرجى تقديم وصف موجز بلغة طبيعية (docstring) للكود البرمجي بلغة بايثون باللغة العربية الفصحى، بحيث لا يتجاوز 500 حرف.",
      "sw": "def polynomial_to_string(n: int, coeffs: List[int]) -> str:\n    result = []\n\n    for i in range(n + 1):\n        coeff = coeffs[i]\n        degree = n - i\n\n        # Skip coefficients that are zero\n        if coeff == 0:\n            continue\n\n        # Handle the sign (+/-) of the coefficient\n        sign = '-' if coeff < 0 else '+'\n        if i == 0:  # First term does not need a leading '+'\n            sign = '-' if coeff < 0 else ''\n        \n        # Handle the absolute value of the coefficient\n        abs_coeff = abs(coeff)\n        if abs_coeff == 1 and degree != 0:  # Omit the '1' for x terms\n            abs_coeff_str = ''\n        else:\n            abs_coeff_str = str(abs_coeff)\n        \n        # Handle the variable part\n        if degree == 0:\n            term = abs_coeff_str\n        elif degree == 1:\n            term = f\"{abs_coeff_str}x\"\n        else:\n            term = f\"{abs_coeff_str}x^{degree}\"\n\n        # Combine sign and term and append to result\n        result.append(f\"{sign}{term}\")\n\n    # Join all the terms and return the polynomial string\n    return ''.join(result)\n\nToa maelezo mafupi ya lugha ya asili (docstring) ya msimbo wa Python kwa Kiswahili kwa kutumia herufi zisizozidi 500.",
      "tr": "def polynomial_to_string(n: int, coeffs: List[int]) -> str:\n    result = []\n\n    for i in range(n + 1):\n        coeff = coeffs[i]\n        degree = n - i\n\n        # Skip coefficients that are zero\n        if coeff == 0:\n            continue\n\n        # Handle the sign (+/-) of the coefficient\n        sign = '-' if coeff < 0 else '+'\n        if i == 0:  # First term does not need a leading '+'\n            sign = '-' if coeff < 0 else ''\n        \n        # Handle the absolute value of the coefficient\n        abs_coeff = abs(coeff)\n        if abs_coeff == 1 and degree != 0:  # Omit the '1' for x terms\n            abs_coeff_str = ''\n        else:\n            abs_coeff_str = str(abs_coeff)\n        \n        # Handle the variable part\n        if degree == 0:\n            term = abs_coeff_str\n        elif degree == 1:\n            term = f\"{abs_coeff_str}x\"\n        else:\n            term = f\"{abs_coeff_str}x^{degree}\"\n\n        # Combine sign and term and append to result\n        result.append(f\"{sign}{term}\")\n\n    # Join all the terms and return the polynomial string\n    return ''.join(result)\n\nVerilen Python kodunun işlevini açıklayan, en fazla 500 karakter uzunluğunda, özlü bir doğal dil açıklaması (docstring) sağlayın.",
      "vi": "def polynomial_to_string(n: int, coeffs: List[int]) -> str:\n    result = []\n\n    for i in range(n + 1):\n        coeff = coeffs[i]\n        degree = n - i\n\n        # Skip coefficients that are zero\n        if coeff == 0:\n            continue\n\n        # Handle the sign (+/-) of the coefficient\n        sign = '-' if coeff < 0 else '+'\n        if i == 0:  # First term does not need a leading '+'\n            sign = '-' if coeff < 0 else ''\n        \n        # Handle the absolute value of the coefficient\n        abs_coeff = abs(coeff)\n        if abs_coeff == 1 and degree != 0:  # Omit the '1' for x terms\n            abs_coeff_str = ''\n        else:\n            abs_coeff_str = str(abs_coeff)\n        \n        # Handle the variable part\n        if degree == 0:\n            term = abs_coeff_str\n        elif degree == 1:\n            term = f\"{abs_coeff_str}x\"\n        else:\n            term = f\"{abs_coeff_str}x^{degree}\"\n\n        # Combine sign and term and append to result\n        result.append(f\"{sign}{term}\")\n\n    # Join all the terms and return the polynomial string\n    return ''.join(result)\n\nCung cấp mô tả ngắn gọn bằng ngôn ngữ tự nhiên (docstring) cho mã Python bằng tiếng Việt, sử dụng tối đa 500 ký tự."
    },
    "instruction_bertscore": {
      "es": "0.9687387561112052",
      "arb": "0.906469919330197",
      "sw": "0.914896018724078",
      "tr": "0.8508820154152974",
      "vi": "0.9069722555638342"
    },
    "level": "",
    "test": "def test_polynomial_to_string():\n    test_cases = [\n        (4, [3, -2, 0, 1, -5], \"3x^4-2x^3+x-5\"),\n        (2, [0, 4, -1], \"+4x-1\"),\n        (0, [7], \"7\"),\n        (3, [1, -1, 0, 1], \"x^3-x^2+1\"),\n    ]\n\n    for i, (n, coeffs, expected) in enumerate(test_cases):\n        result = polynomial_to_string(n, coeffs)\n\n        assert result == expected, f\"Test case {i + 1} failed: expected {expected}, got {result}\"\n        print(f\"Test case {i + 1} passed: expected {expected}, got {result}\")\n\n\ntest_polynomial_to_string()",
    "entry_point": "polynomial_to_string",
    "signature": "def polynomial_to_string(n: int, coeffs: List[int]) -> str:",
    "docstring": {
      "en": "Converts a list of polynomial coefficients into a formatted string representation.\n\nThe function takes in the highest degree `n` of the polynomial and a list of coefficients `coeffs`,\nwhich are ordered from the highest degree term to the constant term. It returns a string that\nrepresents the polynomial with the following rules:\n- Terms with a coefficient of zero are omitted.\n- The sign of each term is determined (+ for positive, - for negative), with no leading '+' for the first term.\n- The absolute value of the coefficient is shown unless it's 1 and the term includes the variable `x`.\n- The variable part is formatted based on its degree; `x^degree` for degree > 1, `x` for degree 1, and\nnothing for degree 0 (constant term).\n- Terms are joined without additional spaces, starting with the highest degree term.\n\nArgs:\nn (int): The highest degree of the polynomial.\ncoeffs (List[int]): A list of coefficients, starting with the coefficient of the highest degree term.\n\nReturns:\nstr: The string representation of the polynomial.\n\nExamples:\n>>> polynomial_to_string(5, [100, -1, 1, -3, 0, 10])\n'100x^5-x^4+x^3-3x^2+10'\n\n>>> polynomial_to_string(3, [-50, 0, 0, 1])\n'-50x^3+1'",
      "es": "Convierte una lista de coeficientes de un polinomio en una representación de cadena formateada.\n\nLa función toma el grado más alto `n` del polinomio y una lista de coeficientes `coeffs`,\nque están ordenados desde el término de mayor grado hasta el término constante. Devuelve una cadena que\nrepresenta el polinomio con las siguientes reglas:\n- Se omiten los términos con un coeficiente de cero.\n- El signo de cada término se determina (+ para positivo, - para negativo), sin un '+' inicial para el primer término.\n- Se muestra el valor absoluto del coeficiente a menos que sea 1 y el término incluya la variable `x`.\n- La parte variable se formatea según su grado; `x^degree` para grado > 1, `x` para grado 1, y\nnada para grado 0 (término constante).\n- Los términos se unen sin espacios adicionales, comenzando con el término de mayor grado.\n\nArgumentos:\nn (int): El grado más alto del polinomio.\ncoeffs (List[int]): Una lista de coeficientes, comenzando con el coeficiente del término de mayor grado.\n\nDevuelve:\nstr: La representación en cadena del polinomio.\n\nEjemplos:\n>>> polynomial_to_string(5, [100, -1, 1, -3, 0, 10])\n'100x^5-x^4+x^3-3x^2+10'\n\n>>> polynomial_to_string(3, [-50, 0, 0, 1])\n'-50x^3+1'",
      "arb": "يقوم بتحويل قائمة من معاملات متعددة الحدود إلى تمثيل سلسلة نصية منسقة.\n\nتأخذ الدالة الدرجة الأعلى `n` لمتعددة الحدود وقائمة من المعاملات `coeffs`،\nالتي تكون مرتبة من الحد ذو الدرجة الأعلى إلى الحد الثابت. تُرجع سلسلة نصية\nتمثل متعددة الحدود بالقواعد التالية:\n- يتم حذف الحدود التي معاملها يساوي صفر.\n- يتم تحديد إشارة كل حد (+ للموجب، - للسالب)، بدون '+' في البداية للحد الأول.\n- يتم عرض القيمة المطلقة للمعامل إلا إذا كانت 1 والحد يشمل المتغير `x`.\n- يتم تنسيق الجزء المتغير بناءً على درجته؛ `x^degree` للدرجة > 1، `x` للدرجة 1، ولا شيء للدرجة 0 (الحد الثابت).\n- يتم ربط الحدود بدون مسافات إضافية، بدءًا من الحد ذو الدرجة الأعلى.\n\nالمعطيات:\nn (int): الدرجة الأعلى لمتعددة الحدود.\ncoeffs (List[int]): قائمة من المعاملات، تبدأ بمعامل الحد ذو الدرجة الأعلى.\n\nالقيم المعادة:\nstr: تمثيل سلسلة نصية لمتعددة الحدود.\n\nأمثلة:\n>>> polynomial_to_string(5, [100, -1, 1, -3, 0, 10])\n'100x^5-x^4+x^3-3x^2+10'\n\n>>> polynomial_to_string(3, [-50, 0, 0, 1])\n'-50x^3+1'",
      "sw": "Inabadilisha orodha ya vigezo vya polinomu kuwa mwakilishi wa maandishi uliopangwa.\n\nKazi inachukua kiwango cha juu `n` cha polinomu na orodha ya vigezo `coeffs`,\nambavyo vimepangwa kutoka kwa neno la kiwango cha juu hadi neno la mara kwa mara. Inarudisha kamba ambayo\ninaonyesha polinomu kwa sheria zifuatazo:\n- Maneno yenye kigezo cha sifuri hayatajwi.\n- Alama ya kila neno inaamuliwa (+ kwa chanya, - kwa hasi), bila '+' inayoongoza kwa neno la kwanza.\n- Thamani kamili ya kigezo inaonyeshwa isipokuwa ni 1 na neno linajumuisha kigezo `x`.\n- Sehemu ya kigezo imepangwa kulingana na kiwango chake; `x^degree` kwa kiwango > 1, `x` kwa kiwango 1, na\nhakuna kwa kiwango 0 (neno la mara kwa mara).\n- Maneno yanaunganishwa bila nafasi za ziada, kuanzia na neno la kiwango cha juu zaidi.\n\nHoja:\nn (int): Kiwango cha juu cha polinomu.\ncoeffs (List[int]): Orodha ya vigezo, kuanzia na kigezo cha neno la kiwango cha juu zaidi.\n\nInarudisha:\nstr: Mwakilishi wa kamba wa polinomu.\n\nMifano:\n>>> polynomial_to_string(5, [100, -1, 1, -3, 0, 10])\n'100x^5-x^4+x^3-3x^2+10'\n\n>>> polynomial_to_string(3, [-50, 0, 0, 1])\n'-50x^3+1'",
      "tr": "Bir liste halinde verilen polinom katsayılarını biçimlendirilmiş bir string gösterimine dönüştürür.\n\nFonksiyon, polinomun en yüksek derecesi `n` ve en yüksek dereceli terimden sabit terime kadar sıralanmış bir katsayılar listesi `coeffs` alır. Aşağıdaki kurallarla polinomu temsil eden bir string döndürür:\n- Katsayısı sıfır olan terimler atlanır.\n- Her terimin işareti belirlenir (pozitif için +, negatif için -), ilk terim için başta '+' yoktur.\n- Katsayının mutlak değeri gösterilir, ancak katsayı 1 ise ve terim `x` değişkenini içeriyorsa gösterilmez.\n- Değişken kısmı derecesine göre biçimlendirilir; derece > 1 için `x^degree`, derece 1 için `x` ve derece 0 için (sabit terim) hiçbir şey.\n- Terimler, en yüksek dereceli terimden başlayarak ek boşluk olmadan birleştirilir.\n\nArgümanlar:\nn (int): Polinomun en yüksek derecesi.\ncoeffs (List[int]): En yüksek dereceli terimin katsayısından başlayarak bir katsayılar listesi.\n\nDöndürür:\nstr: Polinomun string gösterimi.\n\nÖrnekler:\n>>> polynomial_to_string(5, [100, -1, 1, -3, 0, 10])\n'100x^5-x^4+x^3-3x^2+10'\n\n>>> polynomial_to_string(3, [-50, 0, 0, 1])\n'-50x^3+1'",
      "vi": "Chuyển đổi một danh sách các hệ số đa thức thành một chuỗi định dạng.\n\nHàm nhận vào bậc cao nhất `n` của đa thức và một danh sách các hệ số `coeffs`, được sắp xếp từ hạng tử bậc cao nhất đến hạng tử hằng số. Nó trả về một chuỗi đại diện cho đa thức với các quy tắc sau:\n- Các hạng tử có hệ số bằng không sẽ bị bỏ qua.\n- Dấu của mỗi hạng tử được xác định (+ cho dương, - cho âm), không có dấu '+' dẫn đầu cho hạng tử đầu tiên.\n- Giá trị tuyệt đối của hệ số được hiển thị trừ khi nó là 1 và hạng tử bao gồm biến `x`.\n- Phần biến được định dạng dựa trên bậc của nó; `x^degree` cho bậc > 1, `x` cho bậc 1, và không có gì cho bậc 0 (hạng tử hằng số).\n- Các hạng tử được nối liền mà không có khoảng trắng bổ sung, bắt đầu với hạng tử bậc cao nhất.\n\nTham số:\nn (int): Bậc cao nhất của đa thức.\ncoeffs (List[int]): Một danh sách các hệ số, bắt đầu với hệ số của hạng tử bậc cao nhất.\n\nTrả về:\nstr: Chuỗi đại diện cho đa thức.\n\nVí dụ:\n>>> polynomial_to_string(5, [100, -1, 1, -3, 0, 10])\n'100x^5-x^4+x^3-3x^2+10'\n\n>>> polynomial_to_string(3, [-50, 0, 0, 1])\n'-50x^3+1'"
    },
    "docstring_bertscore": {
      "es": "0.9918619146586196",
      "arb": "0.9786819943554306",
      "sw": "0.979355947238282",
      "tr": "0.9532656480589684",
      "vi": "0.9683919474659183"
    }
  },
  {
    "task_id": "Python/21",
    "prompt": {
      "en": "from typing import List, Tuple\ndef select_volunteers(n: int, m: int, applicants: List[Tuple[int, int]]) -> Tuple[int, List[Tuple[int, int]]]:\n    \"\"\"\n    Selects and determines the interview score cutoff and the list of applicants who qualify for the interview process.\n    \n    The function sorts the applicants based on their test scores in descending order. If multiple applicants have the same score,\n    they are then sorted by their registration number in ascending order. The interview score cutoff is calculated based on 150%\n    of the planned number of recruits, rounded down. All applicants with scores equal to or higher than the cutoff are considered\n    qualified for the interview.\n    \n    Args:\n    - n (int): The total number of applicants.\n    - m (int): The planned number of volunteers to be recruited.\n    - applicants (List[Tuple[int, int]]): A list of tuples where each tuple contains the registration number and test score of an applicant.\n    \n    Returns:\n    - Tuple[int, List[Tuple[int, int]]]: A tuple containing the interview score cutoff and a list of tuples, each of which includes\n      the registration number and test score of qualified applicants.\n    \n    Examples:\n    >>> select_volunteers(6, 3, [(1000, 90), (3239, 88), (2390, 95), (7231, 84), (1005, 95), (1001, 88)])\n    (88, [(1005, 95), (2390, 95), (1000, 90), (1001, 88), (3239, 88)])\n    \n    This means that the interview score cutoff is 88, and there are 5 applicants who qualify for the interview, with scores of 95, 95,\n    90, 88, and 88, and their respective registration numbers are listed alongside their scores.\n    \"\"\"",
      "es": "from typing import List, Tuple\ndef select_volunteers(n: int, m: int, applicants: List[Tuple[int, int]]) -> Tuple[int, List[Tuple[int, int]]]:\n    \"\"\"\n    Selecciona y determina el puntaje de corte para la entrevista y la lista de solicitantes que califican para el proceso de entrevista.\n    \n    La función ordena a los solicitantes en base a sus puntajes de prueba en orden descendente. Si varios solicitantes tienen el mismo puntaje,\n    se ordenan luego por su número de registro en orden ascendente. El puntaje de corte para la entrevista se calcula en base al 150%\n    del número planeado de reclutas, redondeado hacia abajo. Todos los solicitantes con puntajes iguales o superiores al corte se consideran\n    calificados para la entrevista.\n    \n    Argumentos:\n    - n (int): El número total de solicitantes.\n    - m (int): El número planeado de voluntarios a reclutar.\n    - applicants (List[Tuple[int, int]]): Una lista de tuplas donde cada tupla contiene el número de registro y el puntaje de prueba de un solicitante.\n    \n    Devuelve:\n    - Tuple[int, List[Tuple[int, int]]]: Una tupla que contiene el puntaje de corte para la entrevista y una lista de tuplas, cada una de las cuales incluye\n      el número de registro y el puntaje de prueba de los solicitantes calificados.\n    \n    Ejemplos:\n    >>> select_volunteers(6, 3, [(1000, 90), (3239, 88), (2390, 95), (7231, 84), (1005, 95), (1001, 88)])\n    (88, [(1005, 95), (2390, 95), (1000, 90), (1001, 88), (3239, 88)])\n    \n    Esto significa que el puntaje de corte para la entrevista es 88, y hay 5 solicitantes que califican para la entrevista, con puntajes de 95, 95,\n    90, 88, y 88, y sus respectivos números de registro se enumeran junto a sus puntajes.\n    \"\"\"",
      "arb": "from typing import List, Tuple\ndef select_volunteers(n: int, m: int, applicants: List[Tuple[int, int]]) -> Tuple[int, List[Tuple[int, int]]]:\n    \"\"\"\n    يختار ويحدد درجة المقابلة والحد الأدنى لقائمة المتقدمين الذين يتأهلون لعملية المقابلة.\n    \n    تقوم الدالة بترتيب المتقدمين بناءً على درجاتهم في الاختبار بترتيب تنازلي. إذا كان هناك عدة متقدمين لديهم نفس الدرجة،\n    يتم ترتيبهم بعد ذلك حسب رقم التسجيل بترتيب تصاعدي. يتم حساب درجة المقابلة بناءً على 150%\n    من العدد المخطط للمتطوعين، ويتم تقريبها إلى الأسفل. جميع المتقدمين الذين لديهم درجات تساوي أو أعلى من الحد الأدنى يعتبرون\n    مؤهلين للمقابلة.\n    \n    يعيدالحجج:\n    - n (int): العدد الإجمالي للمتقدمين.\n    - m (int): العدد المخطط للمتطوعين الذين سيتم تجنيدهم.\n    - applicants (List[Tuple[int, int]]): قائمة من الأزواج حيث يحتوي كل زوج على رقم التسجيل ودرجة الاختبار للمتقدم.\n    \n    يعيد:\n    - Tuple[int, List[Tuple[int, int]]]: زوج يحتوي على درجة المقابلة وقائمة من الأزواج، يحتوي كل منها على\n      رقم التسجيل ودرجة الاختبار للمتقدمين المؤهلين.\n    \n    أمثلة:\n    >>> select_volunteers(6, 3, [(1000, 90), (3239, 88), (2390, 95), (7231, 84), (1005, 95), (1001, 88)])\n    (88, [(1005, 95), (2390, 95), (1000, 90), (1001, 88), (3239, 88)])\n    \n    هذا يعني أن درجة المقابلة هي 88، وهناك 5 متقدمين يتأهلون للمقابلة، بدرجات 95، 95،\n    90، 88، و88، وأرقام تسجيلهم مذكورة بجانب درجاتهم.\n    \"\"\"",
      "sw": "from typing import List, Tuple\ndef select_volunteers(n: int, m: int, applicants: List[Tuple[int, int]]) -> Tuple[int, List[Tuple[int, int]]]:\n    \"\"\"\n    Huchagua na kuamua alama ya mahojiano na orodha ya waombaji wanaostahili kwa mchakato wa mahojiano.\n    \n    Kazi hii hupanga waombaji kulingana na alama zao za mtihani kwa mpangilio wa kushuka. Ikiwa waombaji kadhaa wana alama sawa,\n    basi hupangwa kulingana na namba zao za usajili kwa mpangilio wa kupanda. Alama ya mahojiano huhesabiwa kulingana na 150%\n    ya idadi iliyopangwa ya walioajiriwa, ikipunguzwa chini. Waombaji wote wenye alama sawa au juu kuliko alama ya mahojiano wanachukuliwa\n    kuwa wanastahili kwa mahojiano.\n    \n    Hoja:\n    - n (int): Jumla ya idadi ya waombaji.\n    - m (int): Idadi iliyopangwa ya watu wa kujitolea watakaoajiriwa.\n    - applicants (List[Tuple[int, int]]): Orodha ya jozi ambapo kila jozi ina namba ya usajili na alama ya mtihani ya mwombaji.\n    \n    Inarejesha:\n    - Tuple[int, List[Tuple[int, int]]]: Jozi inayojumuisha alama ya mahojiano na orodha ya jozi, kila moja ikiwa na\n      namba ya usajili na alama ya mtihani ya waombaji waliostahili.\n    \n    Mifano:\n    >>> select_volunteers(6, 3, [(1000, 90), (3239, 88), (2390, 95), (7231, 84), (1005, 95), (1001, 88)])\n    (88, [(1005, 95), (2390, 95), (1000, 90), (1001, 88), (3239, 88)])\n    \n    Hii inamaanisha kuwa alama ya mahojiano ni 88, na kuna waombaji 5 wanaostahili kwa mahojiano, wakiwa na alama za 95, 95,\n    90, 88, na 88, na namba zao za usajili zimeorodheshwa pamoja na alama zao.\n    \"\"\"",
      "tr": "def select_volunteers(n: int, m: int, applicants: List[Tuple[int, int]]) -> Tuple[int, List[Tuple[int, int]]]:\n    \"\"\"\n    Mülakat puanı barajını ve mülakat sürecine hak kazanan başvuru sahiplerinin listesini seçer ve belirler.\n    \n    Fonksiyon, başvuru sahiplerini test puanlarına göre azalan sırayla sıralar. Birden fazla başvuru sahibi aynı puana sahipse,\n    kayıt numaralarına göre artan sırayla sıralanırlar. Mülakat puanı barajı, planlanan işe alınacak gönüllü sayısının %150'si\n    üzerinden hesaplanır ve aşağı yuvarlanır. Baraj puanına eşit veya daha yüksek puan alan tüm başvuru sahipleri mülakata hak kazanmış\n    kabul edilir.\n    \n    Argümanlar:\n    - n (int): Toplam başvuru sayısı.\n    - m (int): Planlanan işe alınacak gönüllü sayısı.\n    - applicants (List[Tuple[int, int]]): Her bir demetin bir başvuru sahibinin kayıt numarasını ve test puanını içerdiği demetlerin listesi.\n    \n    Dönüş Değeri:\n    - Tuple[int, List[Tuple[int, int]]]: Mülakat puanı barajını ve her birinin kayıt numarası ve test puanını içeren,\n      mülakata hak kazanan başvuru sahiplerinin demetlerinden oluşan bir liste içeren bir demet.\n    \n    Örnekler:\n    >>> select_volunteers(6, 3, [(1000, 90), (3239, 88), (2390, 95), (7231, 84), (1005, 95), (1001, 88)])\n    (88, [(1005, 95), (2390, 95), (1000, 90), (1001, 88), (3239, 88)])\n    \n    Bu, mülakat puanı barajının 88 olduğunu ve mülakata hak kazanan 5 başvuru sahibinin 95, 95, 90, 88 ve 88 puanlarına sahip olduğunu,\n    ve ilgili kayıt numaralarının puanlarıyla birlikte listelendiğini ifade eder.\n    \"\"\"",
      "vi": "from typing import List, Tuple\ndef select_volunteers(n: int, m: int, applicants: List[Tuple[int, int]]) -> Tuple[int, List[Tuple[int, int]]]:\n    \"\"\"\n    Lựa chọn và xác định điểm phỏng vấn tối thiểu và danh sách các ứng viên đủ điều kiện cho quá trình phỏng vấn.\n    \n    Hàm này sắp xếp các ứng viên dựa trên điểm kiểm tra của họ theo thứ tự giảm dần. Nếu nhiều ứng viên có cùng điểm số,\n    họ sẽ được sắp xếp theo số đăng ký theo thứ tự tăng dần. Điểm phỏng vấn tối thiểu được tính dựa trên 150%\n    của số lượng tuyển dụng dự kiến, làm tròn xuống. Tất cả các ứng viên có điểm số bằng hoặc cao hơn điểm tối thiểu được coi là\n    đủ điều kiện cho phỏng vấn.\n    \n    Tham số:\n    - n (int): Tổng số lượng ứng viên.\n    - m (int): Số lượng tình nguyện viên dự kiến sẽ được tuyển dụng.\n    - applicants (List[Tuple[int, int]]): Một danh sách các bộ giá trị, trong đó mỗi bộ chứa số đăng ký và điểm kiểm tra của một ứng viên.\n    \n    Trả về:\n    - Tuple[int, List[Tuple[int, int]]]: Một bộ giá trị chứa điểm phỏng vấn tối thiểu và danh sách các bộ giá trị, mỗi bộ bao gồm\n      số đăng ký và điểm kiểm tra của các ứng viên đủ điều kiện.\n    \n    Ví dụ:\n    >>> select_volunteers(6, 3, [(1000, 90), (3239, 88), (2390, 95), (7231, 84), (1005, 95), (1001, 88)])\n    (88, [(1005, 95), (2390, 95), (1000, 90), (1001, 88), (3239, 88)])\n    \n    Điều này có nghĩa là điểm phỏng vấn tối thiểu là 88, và có 5 ứng viên đủ điều kiện cho phỏng vấn, với điểm số là 95, 95,\n    90, 88, và 88, và số đăng ký của họ được liệt kê cùng với điểm số của họ.\n    \"\"\""
    },
    "prompt_bertscore": {
      "es": "0.9790145016132831",
      "arb": "0.9633967906436529",
      "sw": "0.9632513932047353",
      "tr": "0.9374266628448654",
      "vi": "0.9505140213904921"
    },
    "canonical_solution": "    # Sort applicants by score in descending order; if scores are the same, sort by registration number in ascending order\n    sorted_applicants = sorted(applicants, key=lambda x: (-x[1], x[0]))\n    \n    # Calculate the interview score cutoff\n    interview_line_index = int(m * 1.5) - 1\n    interview_line_score = sorted_applicants[interview_line_index][1]\n    \n    # Determine the actual applicants who will be interviewed\n    final_applicants = [applicant for applicant in sorted_applicants if applicant[1] >= interview_line_score]\n    \n    # Return the interview score cutoff and the information of the applicants entering the interview\n    return interview_line_score, final_applicants",
    "instruction": {
      "en": "def select_volunteers(n: int, m: int, applicants: List[Tuple[int, int]]) -> Tuple[int, List[Tuple[int, int]]]:\n    # Sort applicants by score in descending order; if scores are the same, sort by registration number in ascending order\n    sorted_applicants = sorted(applicants, key=lambda x: (-x[1], x[0]))\n    \n    # Calculate the interview score cutoff\n    interview_line_index = int(m * 1.5) - 1\n    interview_line_score = sorted_applicants[interview_line_index][1]\n    \n    # Determine the actual applicants who will be interviewed\n    final_applicants = [applicant for applicant in sorted_applicants if applicant[1] >= interview_line_score]\n    \n    # Return the interview score cutoff and the information of the applicants entering the interview\n    return interview_line_score, final_applicants\n\nProvide a concise natural language description (docstring) of the Python code in English using at most 500 characters.",
      "es": "def select_volunteers(n: int, m: int, applicants: List[Tuple[int, int]]) -> Tuple[int, List[Tuple[int, int]]]:\n    # Sort applicants by score in descending order; if scores are the same, sort by registration number in ascending order\n    sorted_applicants = sorted(applicants, key=lambda x: (-x[1], x[0]))\n    \n    # Calculate the interview score cutoff\n    interview_line_index = int(m * 1.5) - 1\n    interview_line_score = sorted_applicants[interview_line_index][1]\n    \n    # Determine the actual applicants who will be interviewed\n    final_applicants = [applicant for applicant in sorted_applicants if applicant[1] >= interview_line_score]\n    \n    # Return the interview score cutoff and the information of the applicants entering the interview\n    return interview_line_score, final_applicants\n\nProporcione una descripción concisa en lenguaje natural (docstring) del código Python en español utilizando como máximo 500 caracteres.",
      "arb": "def select_volunteers(n: int, m: int, applicants: List[Tuple[int, int]]) -> Tuple[int, List[Tuple[int, int]]]:\n    # Sort applicants by score in descending order; if scores are the same, sort by registration number in ascending order\n    sorted_applicants = sorted(applicants, key=lambda x: (-x[1], x[0]))\n    \n    # Calculate the interview score cutoff\n    interview_line_index = int(m * 1.5) - 1\n    interview_line_score = sorted_applicants[interview_line_index][1]\n    \n    # Determine the actual applicants who will be interviewed\n    final_applicants = [applicant for applicant in sorted_applicants if applicant[1] >= interview_line_score]\n    \n    # Return the interview score cutoff and the information of the applicants entering the interview\n    return interview_line_score, final_applicants\n\nيرجى تقديم وصف موجز بلغة طبيعية (docstring) للكود البرمجي بلغة بايثون باللغة العربية الفصحى باستخدام 500 حرف كحد أقصى.",
      "sw": "def select_volunteers(n: int, m: int, applicants: List[Tuple[int, int]]) -> Tuple[int, List[Tuple[int, int]]]:\n    # Sort applicants by score in descending order; if scores are the same, sort by registration number in ascending order\n    sorted_applicants = sorted(applicants, key=lambda x: (-x[1], x[0]))\n    \n    # Calculate the interview score cutoff\n    interview_line_index = int(m * 1.5) - 1\n    interview_line_score = sorted_applicants[interview_line_index][1]\n    \n    # Determine the actual applicants who will be interviewed\n    final_applicants = [applicant for applicant in sorted_applicants if applicant[1] >= interview_line_score]\n    \n    # Return the interview score cutoff and the information of the applicants entering the interview\n    return interview_line_score, final_applicants\n\nToa maelezo mafupi ya lugha ya asili (docstring) ya msimbo wa Python kwa Kiswahili kwa kutumia herufi zisizozidi 500.",
      "tr": "def select_volunteers(n: int, m: int, applicants: List[Tuple[int, int]]) -> Tuple[int, List[Tuple[int, int]]]:\n    # Sort applicants by score in descending order; if scores are the same, sort by registration number in ascending order\n    sorted_applicants = sorted(applicants, key=lambda x: (-x[1], x[0]))\n    \n    # Calculate the interview score cutoff\n    interview_line_index = int(m * 1.5) - 1\n    interview_line_score = sorted_applicants[interview_line_index][1]\n    \n    # Determine the actual applicants who will be interviewed\n    final_applicants = [applicant for applicant in sorted_applicants if applicant[1] >= interview_line_score]\n    \n    # Return the interview score cutoff and the information of the applicants entering the interview\n    return interview_line_score, final_applicants\n\nVerilen Python kodunun işlevini açıklayan, en fazla 500 karakter uzunluğunda özlü bir doğal dil tanımı (docstring) sağlayın.",
      "vi": "def select_volunteers(n: int, m: int, applicants: List[Tuple[int, int]]) -> Tuple[int, List[Tuple[int, int]]]:\n    # Sort applicants by score in descending order; if scores are the same, sort by registration number in ascending order\n    sorted_applicants = sorted(applicants, key=lambda x: (-x[1], x[0]))\n    \n    # Calculate the interview score cutoff\n    interview_line_index = int(m * 1.5) - 1\n    interview_line_score = sorted_applicants[interview_line_index][1]\n    \n    # Determine the actual applicants who will be interviewed\n    final_applicants = [applicant for applicant in sorted_applicants if applicant[1] >= interview_line_score]\n    \n    # Return the interview score cutoff and the information of the applicants entering the interview\n    return interview_line_score, final_applicants\n\nCung cấp mô tả ngắn gọn bằng ngôn ngữ tự nhiên (docstring) cho mã Python bằng tiếng Việt, sử dụng tối đa 500 ký tự."
    },
    "instruction_bertscore": {
      "es": "0.9687387561112052",
      "arb": "0.924699818440817",
      "sw": "0.914896018724078",
      "tr": "0.8508820154152974",
      "vi": "0.9256256346468206"
    },
    "level": "",
    "test": "def test_select_volunteers():\n    # Define test cases\n    test_cases = [\n        (6, 3, [(1000, 90), (3239, 88), (2390, 95), (7231, 84), (1005, 95), (1001, 88)],\n         (88, [(1005, 95), (2390, 95), (1000, 90), (1001, 88), (3239, 88)])),\n        (5, 3, [(2000, 70), (2001, 80), (2002, 90), (2003, 85), (2004, 90)],\n         (80, [(2002, 90), (2004, 90), (2003, 85), (2001, 80)])),\n        (8, 4, [(1234, 60), (2345, 75), (3456, 85), (4567, 85), (5678, 90), (6789, 100), (7890, 65), (8901, 70)],\n         (70, [(6789, 100), (5678, 90), (3456, 85), (4567, 85), (2345, 75), (8901, 70)])),\n    ]\n\n    # Run test cases\n    for i, (n, m, applicants, expected) in enumerate(test_cases):\n        interview_line_score, final_applicants = select_volunteers(n, m, applicants)\n        assert (interview_line_score, final_applicants) == expected, f\"Test case {i + 1} failed\"\n        print(f\"Test case {i + 1} passed\")\n\n# Run the test function\ntest_select_volunteers()",
    "entry_point": "select_volunteers",
    "signature": "def select_volunteers(n: int, m: int, applicants: List[Tuple[int, int]]) -> Tuple[int, List[Tuple[int, int]]]:",
    "docstring": {
      "en": "Selects and determines the interview score cutoff and the list of applicants who qualify for the interview process.\n\nThe function sorts the applicants based on their test scores in descending order. If multiple applicants have the same score,\nthey are then sorted by their registration number in ascending order. The interview score cutoff is calculated based on 150%\nof the planned number of recruits, rounded down. All applicants with scores equal to or higher than the cutoff are considered\nqualified for the interview.\n\nArgs:\n- n (int): The total number of applicants.\n- m (int): The planned number of volunteers to be recruited.\n- applicants (List[Tuple[int, int]]): A list of tuples where each tuple contains the registration number and test score of an applicant.\n\nReturns:\n- Tuple[int, List[Tuple[int, int]]]: A tuple containing the interview score cutoff and a list of tuples, each of which includes\nthe registration number and test score of qualified applicants.\n\nExamples:\n>>> select_volunteers(6, 3, [(1000, 90), (3239, 88), (2390, 95), (7231, 84), (1005, 95), (1001, 88)])\n(88, [(1005, 95), (2390, 95), (1000, 90), (1001, 88), (3239, 88)])\n\nThis means that the interview score cutoff is 88, and there are 5 applicants who qualify for the interview, with scores of 95, 95,\n90, 88, and 88, and their respective registration numbers are listed alongside their scores.",
      "es": "Selecciona y determina el puntaje de corte para la entrevista y la lista de solicitantes que califican para el proceso de entrevista.\n\nLa función ordena a los solicitantes en función de sus puntajes de prueba en orden descendente. Si varios solicitantes tienen el mismo puntaje, luego se ordenan por su número de registro en orden ascendente. El puntaje de corte para la entrevista se calcula en base al 150% del número planeado de reclutas, redondeado hacia abajo. Todos los solicitantes con puntajes iguales o superiores al corte se consideran calificados para la entrevista.\n\nArgumentos:\n- n (int): El número total de solicitantes.\n- m (int): El número planeado de voluntarios a reclutar.\n- applicants (List[Tuple[int, int]]): Una lista de tuplas donde cada tupla contiene el número de registro y el puntaje de prueba de un solicitante.\n\nDevuelve:\n- Tuple[int, List[Tuple[int, int]]]: Una tupla que contiene el puntaje de corte para la entrevista y una lista de tuplas, cada una de las cuales incluye el número de registro y el puntaje de prueba de los solicitantes calificados.\n\nEjemplos:\n>>> select_volunteers(6, 3, [(1000, 90), (3239, 88), (2390, 95), (7231, 84), (1005, 95), (1001, 88)])\n(88, [(1005, 95), (2390, 95), (1000, 90), (1001, 88), (3239, 88)])\n\nEsto significa que el puntaje de corte para la entrevista es 88, y hay 5 solicitantes que califican para la entrevista, con puntajes de 95, 95, 90, 88 y 88, y sus respectivos números de registro se enumeran junto a sus puntajes.",
      "arb": "يحدد ويحدد حد درجة المقابلة وقائمة المتقدمين الذين يتأهلون لعملية المقابلة.\n\nتقوم الدالة بترتيب المتقدمين بناءً على درجات اختبارهم بترتيب تنازلي. إذا كان هناك عدة متقدمين لديهم نفس الدرجة، يتم ترتيبهم بعد ذلك حسب رقم التسجيل بترتيب تصاعدي. يتم حساب حد درجة المقابلة بناءً على 150% من العدد المخطط للمتطوعين، مع التقريب للأسفل. جميع المتقدمين الذين لديهم درجات مساوية أو أعلى من الحد يعتبرون مؤهلين للمقابلة.\n\nالمعطيات:\n- n (int): العدد الإجمالي للمتقدمين.\n- m (int): العدد المخطط للمتطوعين ليتم تجنيدهم.\n- applicants (List[Tuple[int, int]]): قائمة من الأزواج حيث يحتوي كل زوج على رقم التسجيل ودرجة الاختبار لمتقدم.\n\nالقيم المعادة:\n- Tuple[int, List[Tuple[int, int]]]: زوج يحتوي على حد درجة المقابلة وقائمة من الأزواج، كل منها يتضمن رقم التسجيل ودرجة الاختبار للمتقدمين المؤهلين.\n\nأمثلة:\n>>> select_volunteers(6, 3, [(1000, 90), (3239, 88), (2390, 95), (7231, 84), (1005, 95), (1001, 88)])\n(88, [(1005, 95), (2390, 95), (1000, 90), (1001, 88), (3239, 88)])\n\nهذا يعني أن حد درجة المقابلة هو 88، وهناك 5 متقدمين يتأهلون للمقابلة، بدرجات 95، 95، 90، 88، و88، وأرقام تسجيلهم مذكورة بجانب درجاتهم.",
      "sw": "Huchagua na kuamua kiwango cha alama za mahojiano na orodha ya waombaji wanaostahili mchakato wa mahojiano.\n\nKazi hii hupanga waombaji kulingana na alama zao za mtihani kwa mpangilio wa kushuka. Ikiwa waombaji kadhaa wana alama sawa, basi wanapangwa kulingana na nambari zao za usajili kwa mpangilio wa kupanda. Kiwango cha alama za mahojiano huhesabiwa kulingana na 150% ya idadi iliyopangwa ya wanaojitolea, ikipunguzwa chini. Waombaji wote wenye alama sawa au zaidi ya kiwango hicho wanachukuliwa kuwa wanastahili mahojiano.\n\nHoja:\n- n (int): Jumla ya idadi ya waombaji.\n- m (int): Idadi iliyopangwa ya wanaojitolea watakaoajiriwa.\n- applicants (List[Tuple[int, int]]): Orodha ya jozi ambapo kila jozi ina nambari ya usajili na alama ya mtihani ya mwombaji.\n\nInarejesha:\n- Tuple[int, List[Tuple[int, int]]]: Jozi inayojumuisha kiwango cha alama za mahojiano na orodha ya jozi, kila moja ikiwa na nambari ya usajili na alama ya mtihani ya waombaji waliostahili.\n\nMifano:\n>>> select_volunteers(6, 3, [(1000, 90), (3239, 88), (2390, 95), (7231, 84), (1005, 95), (1001, 88)])\n(88, [(1005, 95), (2390, 95), (1000, 90), (1001, 88), (3239, 88)])\n\nHii inamaanisha kuwa kiwango cha alama za mahojiano ni 88, na kuna waombaji 5 wanaostahili mahojiano, wakiwa na alama za 95, 95, 90, 88, na 88, na nambari zao za usajili zimetajwa pamoja na alama zao.",
      "tr": "Mülakat puanı barajını ve mülakat sürecine hak kazanan başvuru sahiplerinin listesini seçer ve belirler.\n\nFonksiyon, başvuru sahiplerini test puanlarına göre azalan sırayla sıralar. Birden fazla başvuru sahibinin aynı puana sahip olması durumunda, kayıt numaralarına göre artan sırayla sıralanırlar. Mülakat puanı barajı, planlanan işe alınacak gönüllü sayısının %150'si temel alınarak hesaplanır ve aşağı yuvarlanır. Baraj puanına eşit veya daha yüksek puana sahip tüm başvuru sahipleri mülakata hak kazanmış kabul edilir.\n\nArgümanlar:\n- n (int): Toplam başvuru sayısı.\n- m (int): Planlanan işe alınacak gönüllü sayısı.\n- applicants (List[Tuple[int, int]]): Her bir demetin bir başvuru sahibinin kayıt numarası ve test puanını içerdiği demetlerin listesi.\n\nDöndürür:\n- Tuple[int, List[Tuple[int, int]]]: Mülakat puanı barajını ve her birinin kayıt numarası ve test puanını içeren, mülakata hak kazanan başvuru sahiplerinin demetlerinden oluşan bir liste içeren bir demet.\n\nÖrnekler:\n>>> select_volunteers(6, 3, [(1000, 90), (3239, 88), (2390, 95), (7231, 84), (1005, 95), (1001, 88)])\n(88, [(1005, 95), (2390, 95), (1000, 90), (1001, 88), (3239, 88)])\n\nBu, mülakat puanı barajının 88 olduğunu ve 95, 95, 90, 88 ve 88 puanlarına sahip 5 başvuru sahibinin mülakata hak kazandığını, ve puanlarının yanında kayıt numaralarının listelendiğini ifade eder.",
      "vi": "Chọn và xác định điểm phỏng vấn ngưỡng và danh sách ứng viên đủ điều kiện cho quá trình phỏng vấn.\n\nHàm sắp xếp các ứng viên dựa trên điểm kiểm tra của họ theo thứ tự giảm dần. Nếu nhiều ứng viên có cùng điểm số,\nhọ sẽ được sắp xếp theo số đăng ký theo thứ tự tăng dần. Điểm phỏng vấn ngưỡng được tính dựa trên 150%\nsố lượng tuyển dụng dự kiến, làm tròn xuống. Tất cả các ứng viên có điểm số bằng hoặc cao hơn ngưỡng được coi là\nđủ điều kiện cho phỏng vấn.\n\nTham số:\n- n (int): Tổng số ứng viên.\n- m (int): Số lượng tình nguyện viên dự kiến sẽ được tuyển dụng.\n- applicants (List[Tuple[int, int]]): Một danh sách các bộ giá trị, mỗi bộ chứa số đăng ký và điểm kiểm tra của một ứng viên.\n\nTrả về:\n- Tuple[int, List[Tuple[int, int]]]: Một bộ giá trị chứa điểm phỏng vấn ngưỡng và danh sách các bộ giá trị, mỗi bộ bao gồm\nsố đăng ký và điểm kiểm tra của các ứng viên đủ điều kiện.\n\nVí dụ:\n>>> select_volunteers(6, 3, [(1000, 90), (3239, 88), (2390, 95), (7231, 84), (1005, 95), (1001, 88)])\n(88, [(1005, 95), (2390, 95), (1000, 90), (1001, 88), (3239, 88)])\n\nĐiều này có nghĩa là điểm phỏng vấn ngưỡng là 88, và có 5 ứng viên đủ điều kiện cho phỏng vấn, với điểm số là 95, 95,\n90, 88, và 88, và số đăng ký tương ứng của họ được liệt kê cùng với điểm số của họ."
    },
    "docstring_bertscore": {
      "es": "0.9734458988809699",
      "arb": "0.960465204849959",
      "sw": "0.939804268505853",
      "tr": "0.9444575824423573",
      "vi": "0.9448649733538599"
    }
  },
  {
    "task_id": "Python/22",
    "prompt": {
      "en": "def decode(encoded: str, original: str, message: str) -> str:\n    \"\"\"\n    Decodes an encrypted message using a cipher derived from a known encoded-original pair.\n    \n    The function builds a mapping from encoded letters to their original letters and uses this\n    mapping to decode a given encrypted message. If a contradiction is found during mapping\n    construction, or not all letters are represented in the mapping, the function returns \"Failed\".\n    \n    Args:\n    encoded (str): A string representing the encoded information.\n    original (str): A string representing the original information corresponding to the encoded string.\n    message (str): A string representing the encrypted message to be decoded.\n    \n    Returns:\n    str: The decoded message if successful, or \"Failed\" if the decoding is not possible.\n    \n    Examples:\n    >>> decode(\"AA\", \"AB\", \"EOWIE\")\n    'Failed'\n    \n    >>> decode(\"QWERTYUIOPLKJHGFDSAZXCVBN\", \"ABCDEFGHIJKLMNOPQRSTUVWXY\", \"DSLIEWO\")\n    'Failed'\n    \n    >>> decode(\"MSRTZCJKPFLQYVAWBINXUEDGHOOILSMIJFRCOPPQCEUNYDUMPP\", \"YIZSDWAHLNOVFUCERKJXQMGTBPPKOIYKANZWPLLVWMQJFGQYLL\", \"FLSO\")\n    'NOIP'\n    \"\"\"",
      "es": "def decode(encoded: str, original: str, message: str) -> str:\n    \"\"\"\n    Decodifica un mensaje encriptado utilizando un cifrado derivado de un par conocido de codificado-original.\n    \n    La función construye un mapeo de letras codificadas a sus letras originales y utiliza este\n    mapeo para decodificar un mensaje encriptado dado. Si se encuentra una contradicción durante la construcción del mapeo, o no todas las letras están representadas en el mapeo, la función devuelve \"Failed\".\n    \n    Argumentos:\n    encoded (str): Una cadena que representa la información codificada.\n    original (str): Una cadena que representa la información original correspondiente a la cadena codificada.\n    message (str): Una cadena que representa el mensaje encriptado a decodificar.\n    \n    Devuelve:\n    str: El mensaje decodificado si tiene éxito, o \"Failed\" si la decodificación no es posible.\n    \n    Ejemplos:\n    >>> decode(\"AA\", \"AB\", \"EOWIE\")\n    'Failed'\n    \n    >>> decode(\"QWERTYUIOPLKJHGFDSAZXCVBN\", \"ABCDEFGHIJKLMNOPQRSTUVWXY\", \"DSLIEWO\")\n    'Failed'\n    \n    >>> decode(\"MSRTZCJKPFLQYVAWBINXUEDGHOOILSMIJFRCOPPQCEUNYDUMPP\", \"YIZSDWAHLNOVFUCERKJXQMGTBPPKOIYKANZWPLLVWMQJFGQYLL\", \"FLSO\")\n    'NOIP'\n    \"\"\"",
      "arb": "def decode(encoded: str, original: str, message: str) -> str:\n    \"\"\"\n    يفك تشفير رسالة مشفرة باستخدام شيفرة مشتقة من زوج معروف من المشفر-الأصلي.\n    \n    تبني الدالة خريطة من الحروف المشفرة إلى حروفها الأصلية وتستخدم هذه الخريطة\n    لفك تشفير رسالة مشفرة معينة. إذا تم العثور على تناقض أثناء بناء الخريطة،\n    أو لم تكن جميع الحروف ممثلة في الخريطة، فإن الدالة تعيد \"Failed\".\n    \n    يعيدالحجج:\n    encoded (str): سلسلة تمثل المعلومات المشفرة.\n    original (str): سلسلة تمثل المعلومات الأصلية المقابلة للسلسلة المشفرة.\n    message (str): سلسلة تمثل الرسالة المشفرة التي يجب فك تشفيرها.\n    \n    يعيد:\n    str: الرسالة المفكوكة إذا كانت ناجحة، أو \"Failed\" إذا لم يكن فك التشفير ممكنًا.\n    \n    أمثلة:\n    >>> decode(\"AA\", \"AB\", \"EOWIE\")\n    'Failed'\n    \n    >>> decode(\"QWERTYUIOPLKJHGFDSAZXCVBN\", \"ABCDEFGHIJKLMNOPQRSTUVWXY\", \"DSLIEWO\")\n    'Failed'\n    \n    >>> decode(\"MSRTZCJKPFLQYVAWBINXUEDGHOOILSMIJFRCOPPQCEUNYDUMPP\", \"YIZSDWAHLNOVFUCERKJXQMGTBPPKOIYKANZWPLLVWMQJFGQYLL\", \"FLSO\")\n    'NOIP'\n    \"\"\"",
      "sw": "def decode(encoded: str, original: str, message: str) -> str:\n    \"\"\"\n    Hufungua ujumbe uliofichwa kwa kutumia msimbo uliotokana na jozi inayojulikana ya encoded-original.\n    \n    Kazi hii inajenga ramani kutoka kwa herufi zilizofichwa hadi herufi zao za awali na kutumia ramani hii\n    kufungua ujumbe uliofichwa uliotolewa. Ikiwa upinzani utapatikana wakati wa ujenzi wa ramani,\n    au ikiwa si herufi zote zinawakilishwa katika ramani, kazi hii inarejesha \"Failed\".\n    \n    Hoja:\n    encoded (str): Kamba inayowakilisha taarifa iliyofichwa.\n    original (str): Kamba inayowakilisha taarifa ya awali inayolingana na kamba iliyofichwa.\n    message (str): Kamba inayowakilisha ujumbe uliofichwa ambao unapaswa kufunguliwa.\n    \n    Inarejesha:\n    str: Ujumbe uliofunguliwa ikiwa umefanikiwa, au \"Failed\" ikiwa kufungua hakuezekani.\n    \n    Mifano:\n    >>> decode(\"AA\", \"AB\", \"EOWIE\")\n    'Failed'\n    \n    >>> decode(\"QWERTYUIOPLKJHGFDSAZXCVBN\", \"ABCDEFGHIJKLMNOPQRSTUVWXY\", \"DSLIEWO\")\n    'Failed'\n    \n    >>> decode(\"MSRTZCJKPFLQYVAWBINXUEDGHOOILSMIJFRCOPPQCEUNYDUMPP\", \"YIZSDWAHLNOVFUCERKJXQMGTBPPKOIYKANZWPLLVWMQJFGQYLL\", \"FLSO\")\n    'NOIP'\n    \"\"\"",
      "tr": "def decode(encoded: str, original: str, message: str) -> str:\n    \"\"\"\n    Bilinen bir kodlanmış-orijinal çiftinden türetilmiş bir şifre kullanarak şifrelenmiş bir mesajı çözer.\n    \n    Fonksiyon, kodlanmış harflerden orijinal harflere bir eşleme oluşturur ve bu\n    eşlemeyi verilen şifreli mesajı çözmek için kullanır. Eşleme oluşturma sırasında bir çelişki bulunursa\n    veya tüm harfler eşlemede temsil edilmezse, fonksiyon \"Failed\" döndürür.\n    \n    Argümanlar:\n    encoded (str): Kodlanmış bilgiyi temsil eden bir dize.\n    original (str): Kodlanmış dizeye karşılık gelen orijinal bilgiyi temsil eden bir dize.\n    message (str): Çözülecek şifreli mesajı temsil eden bir dize.\n    \n    Döndürür:\n    str: Başarılıysa çözülen mesaj veya çözme mümkün değilse \"Failed\".\n    \n    Örnekler:\n    >>> decode(\"AA\", \"AB\", \"EOWIE\")\n    'Failed'\n    \n    >>> decode(\"QWERTYUIOPLKJHGFDSAZXCVBN\", \"ABCDEFGHIJKLMNOPQRSTUVWXY\", \"DSLIEWO\")\n    'Failed'\n    \n    >>> decode(\"MSRTZCJKPFLQYVAWBINXUEDGHOOILSMIJFRCOPPQCEUNYDUMPP\", \"YIZSDWAHLNOVFUCERKJXQMGTBPPKOIYKANZWPLLVWMQJFGQYLL\", \"FLSO\")\n    'NOIP'\n    \"\"\"",
      "vi": "def decode(encoded: str, original: str, message: str) -> str:\n    \"\"\"\n    Giải mã một thông điệp được mã hóa bằng cách sử dụng một mật mã được tạo ra từ một cặp mã hóa-gốc đã biết.\n    \n    Hàm này xây dựng một ánh xạ từ các chữ cái mã hóa đến các chữ cái gốc của chúng và sử dụng ánh xạ này\n    để giải mã một thông điệp đã được mã hóa. Nếu tìm thấy một mâu thuẫn trong quá trình xây dựng ánh xạ,\n    hoặc không phải tất cả các chữ cái đều được đại diện trong ánh xạ, hàm sẽ trả về \"Failed\".\n    \n    Tham số:\n    encoded (str): Một chuỗi đại diện cho thông tin đã được mã hóa.\n    original (str): Một chuỗi đại diện cho thông tin gốc tương ứng với chuỗi đã mã hóa.\n    message (str): Một chuỗi đại diện cho thông điệp đã được mã hóa cần giải mã.\n    \n    Trả về:\n    str: Thông điệp đã được giải mã nếu thành công, hoặc \"Failed\" nếu không thể giải mã.\n    \n    Ví dụ:\n    >>> decode(\"AA\", \"AB\", \"EOWIE\")\n    'Failed'\n    \n    >>> decode(\"QWERTYUIOPLKJHGFDSAZXCVBN\", \"ABCDEFGHIJKLMNOPQRSTUVWXY\", \"DSLIEWO\")\n    'Failed'\n    \n    >>> decode(\"MSRTZCJKPFLQYVAWBINXUEDGHOOILSMIJFRCOPPQCEUNYDUMPP\", \"YIZSDWAHLNOVFUCERKJXQMGTBPPKOIYKANZWPLLVWMQJFGQYLL\", \"FLSO\")\n    'NOIP'\n    \"\"\""
    },
    "prompt_bertscore": {
      "es": "0.9931544025480136",
      "arb": "0.9672202268481934",
      "sw": "0.9680367963446279",
      "tr": "0.9874606626756486",
      "vi": "0.9706952653643988"
    },
    "canonical_solution": "    # Initialize a mapping dictionary to store the relationship between letters and their corresponding code letters\n    mapping = {}\n    reverse_mapping = {}\n    \n    # Build the mapping based on the encoded information and the original information\n    for e, o in zip(encoded, original):\n        if e in mapping and mapping[e] != o:\n            # A contradiction is found, output \"Failed\"\n            return \"Failed\"\n        if o in reverse_mapping and reverse_mapping[o] != e:\n            # A contradiction is found, output \"Failed\"\n            return \"Failed\"\n        mapping[e] = o\n        reverse_mapping[o] = e\n    \n    # Check if all letters have a corresponding code letter\n    if len(reverse_mapping) < 26:\n        # Some letters do not have a corresponding code letter, output \"Failed\"\n        return \"Failed\"\n    \n    # Use the mapping to translate the encrypted message from the telegram\n    decoded_message = \"\"\n    for char in message:\n        if char not in mapping:\n            # A character cannot be translated, output \"Failed\"\n            return \"Failed\"\n        decoded_message += mapping[char]\n    \n    return decoded_message",
    "instruction": {
      "en": "def decode(encoded: str, original: str, message: str) -> str:\n    # Initialize a mapping dictionary to store the relationship between letters and their corresponding code letters\n    mapping = {}\n    reverse_mapping = {}\n    \n    # Build the mapping based on the encoded information and the original information\n    for e, o in zip(encoded, original):\n        if e in mapping and mapping[e] != o:\n            # A contradiction is found, output \"Failed\"\n            return \"Failed\"\n        if o in reverse_mapping and reverse_mapping[o] != e:\n            # A contradiction is found, output \"Failed\"\n            return \"Failed\"\n        mapping[e] = o\n        reverse_mapping[o] = e\n    \n    # Check if all letters have a corresponding code letter\n    if len(reverse_mapping) < 26:\n        # Some letters do not have a corresponding code letter, output \"Failed\"\n        return \"Failed\"\n    \n    # Use the mapping to translate the encrypted message from the telegram\n    decoded_message = \"\"\n    for char in message:\n        if char not in mapping:\n            # A character cannot be translated, output \"Failed\"\n            return \"Failed\"\n        decoded_message += mapping[char]\n    \n    return decoded_message\n\nProvide a concise natural language description (docstring) of the Python code in English using at most 500 characters.",
      "es": "def decode(encoded: str, original: str, message: str) -> str:\n    # Initialize a mapping dictionary to store the relationship between letters and their corresponding code letters\n    mapping = {}\n    reverse_mapping = {}\n    \n    # Build the mapping based on the encoded information and the original information\n    for e, o in zip(encoded, original):\n        if e in mapping and mapping[e] != o:\n            # A contradiction is found, output \"Failed\"\n            return \"Failed\"\n        if o in reverse_mapping and reverse_mapping[o] != e:\n            # A contradiction is found, output \"Failed\"\n            return \"Failed\"\n        mapping[e] = o\n        reverse_mapping[o] = e\n    \n    # Check if all letters have a corresponding code letter\n    if len(reverse_mapping) < 26:\n        # Some letters do not have a corresponding code letter, output \"Failed\"\n        return \"Failed\"\n    \n    # Use the mapping to translate the encrypted message from the telegram\n    decoded_message = \"\"\n    for char in message:\n        if char not in mapping:\n            # A character cannot be translated, output \"Failed\"\n            return \"Failed\"\n        decoded_message += mapping[char]\n    \n    return decoded_message\n\nProporcione una descripción concisa en lenguaje natural (docstring) del código Python en español utilizando como máximo 500 caracteres.",
      "arb": "def decode(encoded: str, original: str, message: str) -> str:\n    # Initialize a mapping dictionary to store the relationship between letters and their corresponding code letters\n    mapping = {}\n    reverse_mapping = {}\n    \n    # Build the mapping based on the encoded information and the original information\n    for e, o in zip(encoded, original):\n        if e in mapping and mapping[e] != o:\n            # A contradiction is found, output \"Failed\"\n            return \"Failed\"\n        if o in reverse_mapping and reverse_mapping[o] != e:\n            # A contradiction is found, output \"Failed\"\n            return \"Failed\"\n        mapping[e] = o\n        reverse_mapping[o] = e\n    \n    # Check if all letters have a corresponding code letter\n    if len(reverse_mapping) < 26:\n        # Some letters do not have a corresponding code letter, output \"Failed\"\n        return \"Failed\"\n    \n    # Use the mapping to translate the encrypted message from the telegram\n    decoded_message = \"\"\n    for char in message:\n        if char not in mapping:\n            # A character cannot be translated, output \"Failed\"\n            return \"Failed\"\n        decoded_message += mapping[char]\n    \n    return decoded_message\n\nيرجى تقديم وصف موجز بلغة طبيعية (docstring) للشفرة البرمجية بلغة بايثون باللغة العربية الفصحى باستخدام 500 حرف كحد أقصى.",
      "sw": "def decode(encoded: str, original: str, message: str) -> str:\n    # Initialize a mapping dictionary to store the relationship between letters and their corresponding code letters\n    mapping = {}\n    reverse_mapping = {}\n    \n    # Build the mapping based on the encoded information and the original information\n    for e, o in zip(encoded, original):\n        if e in mapping and mapping[e] != o:\n            # A contradiction is found, output \"Failed\"\n            return \"Failed\"\n        if o in reverse_mapping and reverse_mapping[o] != e:\n            # A contradiction is found, output \"Failed\"\n            return \"Failed\"\n        mapping[e] = o\n        reverse_mapping[o] = e\n    \n    # Check if all letters have a corresponding code letter\n    if len(reverse_mapping) < 26:\n        # Some letters do not have a corresponding code letter, output \"Failed\"\n        return \"Failed\"\n    \n    # Use the mapping to translate the encrypted message from the telegram\n    decoded_message = \"\"\n    for char in message:\n        if char not in mapping:\n            # A character cannot be translated, output \"Failed\"\n            return \"Failed\"\n        decoded_message += mapping[char]\n    \n    return decoded_message\n\nToa maelezo mafupi ya lugha asilia (docstring) ya msimbo wa Python kwa Kiswahili kwa kutumia herufi zisizozidi 500.",
      "tr": "def decode(encoded: str, original: str, message: str) -> str:\n    # Initialize a mapping dictionary to store the relationship between letters and their corresponding code letters\n    mapping = {}\n    reverse_mapping = {}\n    \n    # Build the mapping based on the encoded information and the original information\n    for e, o in zip(encoded, original):\n        if e in mapping and mapping[e] != o:\n            # A contradiction is found, output \"Failed\"\n            return \"Failed\"\n        if o in reverse_mapping and reverse_mapping[o] != e:\n            # A contradiction is found, output \"Failed\"\n            return \"Failed\"\n        mapping[e] = o\n        reverse_mapping[o] = e\n    \n    # Check if all letters have a corresponding code letter\n    if len(reverse_mapping) < 26:\n        # Some letters do not have a corresponding code letter, output \"Failed\"\n        return \"Failed\"\n    \n    # Use the mapping to translate the encrypted message from the telegram\n    decoded_message = \"\"\n    for char in message:\n        if char not in mapping:\n            # A character cannot be translated, output \"Failed\"\n            return \"Failed\"\n        decoded_message += mapping[char]\n    \n    return decoded_message\n\nPython kodunun işlevini açıklayan kısa bir doğal dil tanımı (docstring) sağlayın. Açıklama, en fazla 500 karakter kullanılarak Türkçe olarak yazılmalıdır.",
      "vi": "def decode(encoded: str, original: str, message: str) -> str:\n    # Initialize a mapping dictionary to store the relationship between letters and their corresponding code letters\n    mapping = {}\n    reverse_mapping = {}\n    \n    # Build the mapping based on the encoded information and the original information\n    for e, o in zip(encoded, original):\n        if e in mapping and mapping[e] != o:\n            # A contradiction is found, output \"Failed\"\n            return \"Failed\"\n        if o in reverse_mapping and reverse_mapping[o] != e:\n            # A contradiction is found, output \"Failed\"\n            return \"Failed\"\n        mapping[e] = o\n        reverse_mapping[o] = e\n    \n    # Check if all letters have a corresponding code letter\n    if len(reverse_mapping) < 26:\n        # Some letters do not have a corresponding code letter, output \"Failed\"\n        return \"Failed\"\n    \n    # Use the mapping to translate the encrypted message from the telegram\n    decoded_message = \"\"\n    for char in message:\n        if char not in mapping:\n            # A character cannot be translated, output \"Failed\"\n            return \"Failed\"\n        decoded_message += mapping[char]\n    \n    return decoded_message\n\nCung cấp mô tả ngắn gọn bằng ngôn ngữ tự nhiên (docstring) cho mã Python bằng tiếng Việt, không quá 500 ký tự."
    },
    "instruction_bertscore": {
      "es": "0.9687387561112052",
      "arb": "0.9310367234869731",
      "sw": "0.9426438884331277",
      "tr": "0.878612207020435",
      "vi": "0.9159938488400579"
    },
    "level": "",
    "test": "def test_decode():\n    # Test case 1: Contradiction in mapping\n    assert decode(\"AA\", \"AB\", \"EOWIE\") == \"Failed\", \"Test case 1 failed\"\n\n    # Test case 2: Not all letters are represented\n    assert decode(\"QWERTYUIOPLKJHGFDSAZXCVBN\", \"ABCDEFGHIJKLMNOPQRSTUVWXY\", \"DSLIEWO\") == \"Failed\", \"Test case 2 failed\"\n\n    # Test case 3: Successful decoding\n    assert decode(\"MSRTZCJKPFLQYVAWBINXUEDGHOOILSMIJFRCOPPQCEUNYDUMPP\", \"YIZSDWAHLNOVFUCERKJXQMGTBPPKOIYKANZWPLLVWMQJFGQYLL\", \"FLSO\") == \"NOIP\", \"Test case 3 failed\"\n    \n    # Test case 4: Character in message not in mapping\n    assert decode(\"ABCDEFGHIJKLM\", \"NOPQRSTUVWXYZ\", \"UVWXYZ\") == \"Failed\", \"Test case 4 failed\"\n\n    # Test case 5: Empty strings\n    assert decode(\"\", \"\", \"\") == \"Failed\", \"Test case 5 failed\"\n\n    print(\"All test cases passed!\")\n\n# Call the test function to run the test cases\ntest_decode()",
    "entry_point": "decode",
    "signature": "def decode(encoded: str, original: str, message: str) -> str:",
    "docstring": {
      "en": "Decodes an encrypted message using a cipher derived from a known encoded-original pair.\n\nThe function builds a mapping from encoded letters to their original letters and uses this\nmapping to decode a given encrypted message. If a contradiction is found during mapping\nconstruction, or not all letters are represented in the mapping, the function returns \"Failed\".\n\nArgs:\nencoded (str): A string representing the encoded information.\noriginal (str): A string representing the original information corresponding to the encoded string.\nmessage (str): A string representing the encrypted message to be decoded.\n\nReturns:\nstr: The decoded message if successful, or \"Failed\" if the decoding is not possible.\n\nExamples:\n>>> decode(\"AA\", \"AB\", \"EOWIE\")\n'Failed'\n\n>>> decode(\"QWERTYUIOPLKJHGFDSAZXCVBN\", \"ABCDEFGHIJKLMNOPQRSTUVWXY\", \"DSLIEWO\")\n'Failed'\n\n>>> decode(\"MSRTZCJKPFLQYVAWBINXUEDGHOOILSMIJFRCOPPQCEUNYDUMPP\", \"YIZSDWAHLNOVFUCERKJXQMGTBPPKOIYKANZWPLLVWMQJFGQYLL\", \"FLSO\")\n'NOIP'",
      "es": "Decodifica un mensaje encriptado usando un cifrado derivado de un par conocido codificado-original.\n\nLa función construye un mapeo de letras codificadas a sus letras originales y utiliza este\nmapeo para decodificar un mensaje encriptado dado. Si se encuentra una contradicción durante la construcción del mapeo, o no todas las letras están representadas en el mapeo, la función devuelve \"Failed\".\n\nArgumentos:\nencoded (str): Una cadena que representa la información codificada.\noriginal (str): Una cadena que representa la información original correspondiente a la cadena codificada.\nmessage (str): Una cadena que representa el mensaje encriptado que se va a decodificar.\n\nDevuelve:\nstr: El mensaje decodificado si tiene éxito, o \"Failed\" si la decodificación no es posible.\n\nEjemplos:\n>>> decode(\"AA\", \"AB\", \"EOWIE\")\n'Failed'\n\n>>> decode(\"QWERTYUIOPLKJHGFDSAZXCVBN\", \"ABCDEFGHIJKLMNOPQRSTUVWXY\", \"DSLIEWO\")\n'Failed'\n\n>>> decode(\"MSRTZCJKPFLQYVAWBINXUEDGHOOILSMIJFRCOPPQCEUNYDUMPP\", \"YIZSDWAHLNOVFUCERKJXQMGTBPPKOIYKANZWPLLVWMQJFGQYLL\", \"FLSO\")\n'NOIP'",
      "arb": "يفك تشفير رسالة مشفرة باستخدام شفرة مستمدة من زوج معروف من الشفرة الأصلية.\n\nتبني الدالة خريطة من الحروف المشفرة إلى حروفها الأصلية وتستخدم هذه الخريطة لفك تشفير رسالة مشفرة معينة. إذا تم العثور على تناقض أثناء بناء الخريطة، أو لم يتم تمثيل جميع الحروف في الخريطة، فإن الدالة تعيد \"فشل\".\n\nالمعطيات:\nencoded (str): سلسلة تمثل المعلومات المشفرة.\noriginal (str): سلسلة تمثل المعلومات الأصلية المقابلة للسلسلة المشفرة.\nmessage (str): سلسلة تمثل الرسالة المشفرة المراد فك تشفيرها.\n\nالقيم المعادة:\nstr: الرسالة المفككة إذا كانت ناجحة، أو \"فشل\" إذا لم يكن فك التشفير ممكنًا.\n\nأمثلة:\n>>> decode(\"AA\", \"AB\", \"EOWIE\")\n'Failed'\n\n>>> decode(\"QWERTYUIOPLKJHGFDSAZXCVBN\", \"ABCDEFGHIJKLMNOPQRSTUVWXY\", \"DSLIEWO\")\n'Failed'\n\n>>> decode(\"MSRTZCJKPFLQYVAWBINXUEDGHOOILSMIJFRCOPPQCEUNYDUMPP\", \"YIZSDWAHLNOVFUCERKJXQMGTBPPKOIYKANZWPLLVWMQJFGQYLL\", \"FLSO\")\n'NOIP'",
      "sw": "Husimbua ujumbe uliofichwa kwa kutumia msimbo uliotokana na jozi inayojulikana ya iliyosimbwa-asili.\n\nKazi hii hujenga ramani kutoka kwa herufi zilizofichwa hadi kwa herufi zao asili na hutumia ramani hii kusimbua ujumbe uliofichwa uliotolewa. Ikiwa upinzani utapatikana wakati wa ujenzi wa ramani, au ikiwa si herufi zote zinawakilishwa katika ramani, kazi hii itarudisha \"Imeshindikana\".\n\nHoja:\nencoded (str): Kamba inayowakilisha taarifa iliyosimbwa.\noriginal (str): Kamba inayowakilisha taarifa asili inayolingana na kamba iliyosimbwa.\nmessage (str): Kamba inayowakilisha ujumbe uliofichwa unaotakiwa kusimbuliwa.\n\nInarejesha:\nstr: Ujumbe uliosimbuliwa ikiwa umefanikiwa, au \"Imeshindikana\" ikiwa usimbuaji hauwezekani.\n\nMifano:\n>>> decode(\"AA\", \"AB\", \"EOWIE\")\n'Failed'\n\n>>> decode(\"QWERTYUIOPLKJHGFDSAZXCVBN\", \"ABCDEFGHIJKLMNOPQRSTUVWXY\", \"DSLIEWO\")\n'Failed'\n\n>>> decode(\"MSRTZCJKPFLQYVAWBINXUEDGHOOILSMIJFRCOPPQCEUNYDUMPP\", \"YIZSDWAHLNOVFUCERKJXQMGTBPPKOIYKANZWPLLVWMQJFGQYLL\", \"FLSO\")\n'NOIP'",
      "tr": "Şifreli bir mesajı, bilinen bir kodlanmış-orijinal çiftinden türetilen bir şifre kullanarak çözer.\n\nFonksiyon, kodlanmış harflerden orijinal harflere bir eşleme oluşturur ve bu eşlemeyi verilen şifreli mesajı çözmek için kullanır. Eşleme oluşturma sırasında bir çelişki bulunursa veya tüm harfler eşlemede temsil edilmezse, fonksiyon \"Başarısız\" döner.\n\nArgümanlar:\nencoded (str): Kodlanmış bilgiyi temsil eden bir dize.\noriginal (str): Kodlanmış dizeye karşılık gelen orijinal bilgiyi temsil eden bir dize.\nmessage (str): Çözülecek şifreli mesajı temsil eden bir dize.\n\nDöndürür:\nstr: Başarılıysa çözülen mesaj veya çözme mümkün değilse \"Başarısız\".\n\nÖrnekler:\n>>> decode(\"AA\", \"AB\", \"EOWIE\")\n'Failed'\n\n>>> decode(\"QWERTYUIOPLKJHGFDSAZXCVBN\", \"ABCDEFGHIJKLMNOPQRSTUVWXY\", \"DSLIEWO\")\n'Failed'\n\n>>> decode(\"MSRTZCJKPFLQYVAWBINXUEDGHOOILSMIJFRCOPPQCEUNYDUMPP\", \"YIZSDWAHLNOVFUCERKJXQMGTBPPKOIYKANZWPLLVWMQJFGQYLL\", \"FLSO\")\n'NOIP'",
      "vi": "Giải mã một thông điệp đã được mã hóa bằng một mật mã được tạo ra từ một cặp mã hóa-gốc đã biết.\n\nHàm này xây dựng một ánh xạ từ các chữ cái đã mã hóa đến các chữ cái gốc của chúng và sử dụng ánh xạ này để giải mã một thông điệp đã mã hóa cho trước. Nếu một mâu thuẫn được tìm thấy trong quá trình xây dựng ánh xạ, hoặc không phải tất cả các chữ cái đều được đại diện trong ánh xạ, hàm sẽ trả về \"Failed\".\n\nTham số:\nencoded (str): Một chuỗi đại diện cho thông tin đã mã hóa.\noriginal (str): Một chuỗi đại diện cho thông tin gốc tương ứng với chuỗi đã mã hóa.\nmessage (str): Một chuỗi đại diện cho thông điệp đã mã hóa cần được giải mã.\n\nTrả về:\nstr: Thông điệp đã giải mã nếu thành công, hoặc \"Failed\" nếu không thể giải mã.\n\nVí dụ:\n>>> decode(\"AA\", \"AB\", \"EOWIE\")\n'Failed'\n\n>>> decode(\"QWERTYUIOPLKJHGFDSAZXCVBN\", \"ABCDEFGHIJKLMNOPQRSTUVWXY\", \"DSLIEWO\")\n'Failed'\n\n>>> decode(\"MSRTZCJKPFLQYVAWBINXUEDGHOOILSMIJFRCOPPQCEUNYDUMPP\", \"YIZSDWAHLNOVFUCERKJXQMGTBPPKOIYKANZWPLLVWMQJFGQYLL\", \"FLSO\")\n'NOIP'"
    },
    "docstring_bertscore": {
      "es": "0.9881437525560275",
      "arb": "0.9729264804345638",
      "sw": "0.9647333744776366",
      "tr": "0.9722773563493416",
      "vi": "0.9699885384686767"
    }
  },
  {
    "task_id": "Python/23",
    "prompt": {
      "en": "def largest_prime_factor(n: int) -> int:\n    \"\"\"\n    Find the largest prime factor of a given positive integer.\n    \n    The integer is assumed to be the product of exactly two distinct prime numbers. \n    The function iterates through potential factors starting from the smallest prime (2) \n    and checks if they are a factor of 'n'. If a factor is found, the function returns \n    the division of 'n' by this factor, which is the larger prime factor. If no factors \n    are found up to the square root of 'n', then 'n' itself is a prime number and is \n    returned as the largest prime factor.\n    \n    Args:\n    n (int): The positive integer to factorize, which is the product of two distinct primes.\n    \n    Returns:\n    int: The larger of the two prime factors of 'n'.\n    \n    Examples:\n    >>> largest_prime_factor(21)\n    7\n    >>> largest_prime_factor(15)\n    5\n    >>> largest_prime_factor(29)\n    29\n    \"\"\"\n   ",
      "es": "def largest_prime_factor(n: int) -> int:\n    \"\"\"\n    Encuentra el mayor factor primo de un número entero positivo dado.\n    \n    Se asume que el entero es el producto de exactamente dos números primos distintos. \n    La función itera a través de posibles factores comenzando desde el menor primo (2) \n    y verifica si son un factor de 'n'. Si se encuentra un factor, la función devuelve \n    la división de 'n' por este factor, que es el mayor factor primo. Si no se encuentran \n    factores hasta la raíz cuadrada de 'n', entonces 'n' en sí mismo es un número primo \n    y se devuelve como el mayor factor primo.\n    \n    Argumentos:\n    n (int): El número entero positivo a factorizar, que es el producto de dos primos distintos.\n    \n    Devuelve:\n    int: El mayor de los dos factores primos de 'n'.\n    \n    Ejemplos:\n    >>> largest_prime_factor(21)\n    7\n    >>> largest_prime_factor(15)\n    5\n    >>> largest_prime_factor(29)\n    29\n    \"\"\"\n   ",
      "arb": "```python\ndef largest_prime_factor(n: int) -> int:\n    \"\"\"\n    إيجاد أكبر عامل أولي لعدد صحيح موجب معين.\n    \n    يُفترض أن العدد الصحيح هو ناتج ضرب عددين أوليين متميزين بالضبط.\n    تقوم الدالة بتكرار العوامل المحتملة بدءًا من أصغر عدد أولي (2)\n    وتتحقق مما إذا كانت عاملاً لـ 'n'. إذا تم العثور على عامل، تُعيد الدالة\n    قسمة 'n' على هذا العامل، وهو العامل الأولي الأكبر. إذا لم يتم العثور على عوامل\n    حتى الجذر التربيعي لـ 'n'، فإن 'n' نفسه هو عدد أولي ويتم\n    إعادته كأكبر عامل أولي.\n    \n    يعيدالحجج:\n    n (int): العدد الصحيح الموجب للتفكيك، وهو ناتج ضرب عددين أوليين متميزين.\n    \n    يعيد:\n    int: الأكبر بين العاملين الأوليين لـ 'n'.\n    \n    امثله:\n    >>> largest_prime_factor(21)\n    7\n    >>> largest_prime_factor(15)\n    5\n    >>> largest_prime_factor(29)\n    29\n    \"\"\"\n```",
      "sw": "def largest_prime_factor(n: int) -> int:\n    \"\"\"\n    Pata kigezo kikubwa zaidi cha nambari ya kwanza ya nambari chanya iliyotolewa.\n    \n    Nambari inadhaniwa kuwa ni zao la nambari mbili tofauti za kwanza. \n    Kazi inazunguka kupitia vigezo vinavyowezekana kuanzia na nambari ya kwanza ndogo zaidi (2) \n    na hukagua kama ni kigezo cha 'n'. Ikiwa kigezo kinapatikana, kazi inarudisha \n    mgawanyiko wa 'n' kwa kigezo hiki, ambacho ni kigezo kikubwa zaidi cha kwanza. Ikiwa hakuna vigezo \n    vinavyopatikana hadi mzizi wa mraba wa 'n', basi 'n' yenyewe ni nambari ya kwanza na \n    inarudishwa kama kigezo kikubwa zaidi cha kwanza.\n    \n    Hoja:\n    n (int): Nambari chanya ya kufanyia ufafanuzi, ambayo ni zao la nambari mbili tofauti za kwanza.\n    \n    Inarejesha:\n    int: Kigezo kikubwa zaidi kati ya viwili vya kwanza vya 'n'.\n    \n    Mifano:\n    >>> largest_prime_factor(21)\n    7\n    >>> largest_prime_factor(15)\n    5\n    >>> largest_prime_factor(29)\n    29\n    \"\"\"\n   ",
      "tr": "```python\ndef largest_prime_factor(n: int) -> int:\n    \"\"\"\n    Verilen pozitif bir tamsayının en büyük asal çarpanını bulun.\n    \n    Tamsayının, tam olarak iki farklı asal sayının çarpımı olduğu varsayılır. \n    Fonksiyon, en küçük asal sayıdan (2) başlayarak potansiyel çarpanlar üzerinden \n    iterasyon yapar ve bunların 'n'nin bir çarpanı olup olmadığını kontrol eder. \n    Bir çarpan bulunursa, fonksiyon bu çarpan ile 'n'nin bölünmesini döndürür, \n    bu da daha büyük asal çarpandır. 'n'nin kareköküne kadar hiçbir çarpan \n    bulunamazsa, o zaman 'n' kendisi bir asal sayıdır ve en büyük asal çarpan \n    olarak döndürülür.\n    \n    Argümanlar:\n    n (int): İki farklı asalın çarpımı olan pozitif tamsayı.\n    \n    Döndürür:\n    int: 'n'nin iki asal çarpanından daha büyüğü.\n    \n    Örnekler:\n    >>> largest_prime_factor(21)\n    7\n    >>> largest_prime_factor(15)\n    5\n    >>> largest_prime_factor(29)\n    29\n    \"\"\"\n```",
      "vi": "def largest_prime_factor(n: int) -> int:\n    \"\"\"\n    Tìm ước số nguyên tố lớn nhất của một số nguyên dương cho trước.\n    \n    Số nguyên được giả định là tích của chính xác hai số nguyên tố khác nhau.\n    Hàm lặp qua các ước số tiềm năng bắt đầu từ số nguyên tố nhỏ nhất (2)\n    và kiểm tra nếu chúng là một ước số của 'n'. Nếu tìm thấy một ước số, hàm sẽ trả về\n    phép chia của 'n' cho ước số này, đó là ước số nguyên tố lớn hơn. Nếu không tìm thấy\n    ước số nào cho đến căn bậc hai của 'n', thì 'n' tự nó là một số nguyên tố và được\n    trả về như là ước số nguyên tố lớn nhất.\n    \n    Tham số:\n    n (int): Số nguyên dương cần phân tích, là tích của hai số nguyên tố khác nhau.\n    \n    Trả về:\n    int: Số nguyên tố lớn hơn trong hai ước số nguyên tố của 'n'.\n    \n    Ví dụ:\n    >>> largest_prime_factor(21)\n    7\n    >>> largest_prime_factor(15)\n    5\n    >>> largest_prime_factor(29)\n    29\n    \"\"\"\n   "
    },
    "prompt_bertscore": {
      "es": "0.9889797878298033",
      "arb": "0.9586741547041674",
      "sw": "0.971253813995869",
      "tr": "0.9632359000350146",
      "vi": "0.9455236316973715"
    },
    "canonical_solution": "    # Starting from the smallest prime number\n    factor = 2\n    last_factor = 1\n    while factor * factor <= n:\n        if n % factor == 0:\n            last_factor = factor\n            while n % factor == 0:\n                n //= factor\n        factor += 1\n    # If n is greater than 1, then it is a prime number\n    if n > 1:\n        last_factor = n\n    return last_factor",
    "instruction": {
      "en": "def largest_prime_factor(n: int) -> int:\n    # Starting from the smallest prime number\n    factor = 2\n    last_factor = 1\n    while factor * factor <= n:\n        if n % factor == 0:\n            last_factor = factor\n            while n % factor == 0:\n                n //= factor\n        factor += 1\n    # If n is greater than 1, then it is a prime number\n    if n > 1:\n        last_factor = n\n    return last_factor\n\nProvide a concise natural language description (docstring) of the Python code in English using at most 500 characters.",
      "es": "def largest_prime_factor(n: int) -> int:\n    # Starting from the smallest prime number\n    factor = 2\n    last_factor = 1\n    while factor * factor <= n:\n        if n % factor == 0:\n            last_factor = factor\n            while n % factor == 0:\n                n //= factor\n        factor += 1\n    # If n is greater than 1, then it is a prime number\n    if n > 1:\n        last_factor = n\n    return last_factor\n\nProporcione una descripción concisa en lenguaje natural (docstring) del código Python en español utilizando como máximo 500 caracteres.",
      "arb": "def largest_prime_factor(n: int) -> int:\n    # Starting from the smallest prime number\n    factor = 2\n    last_factor = 1\n    while factor * factor <= n:\n        if n % factor == 0:\n            last_factor = factor\n            while n % factor == 0:\n                n //= factor\n        factor += 1\n    # If n is greater than 1, then it is a prime number\n    if n > 1:\n        last_factor = n\n    return last_factor\n\nيرجى تقديم وصف موجز بلغة طبيعية (docstring) للكود البرمجي بلغة بايثون باللغة العربية الفصحى، بحيث لا يتجاوز 500 حرف.",
      "sw": "def largest_prime_factor(n: int) -> int:\n    # Starting from the smallest prime number\n    factor = 2\n    last_factor = 1\n    while factor * factor <= n:\n        if n % factor == 0:\n            last_factor = factor\n            while n % factor == 0:\n                n //= factor\n        factor += 1\n    # If n is greater than 1, then it is a prime number\n    if n > 1:\n        last_factor = n\n    return last_factor\n\nToa maelezo mafupi ya lugha ya asili (docstring) ya msimbo wa Python kwa Kiswahili kwa kutumia herufi zisizozidi 500.",
      "tr": "def largest_prime_factor(n: int) -> int:\n    # Starting from the smallest prime number\n    factor = 2\n    last_factor = 1\n    while factor * factor <= n:\n        if n % factor == 0:\n            last_factor = factor\n            while n % factor == 0:\n                n //= factor\n        factor += 1\n    # If n is greater than 1, then it is a prime number\n    if n > 1:\n        last_factor = n\n    return last_factor\n\nVerilen Python kodunun işlevini açıklayan, en fazla 500 karakter uzunluğunda özlü bir doğal dil açıklaması (docstring) sağlayın.",
      "vi": "def largest_prime_factor(n: int) -> int:\n    # Starting from the smallest prime number\n    factor = 2\n    last_factor = 1\n    while factor * factor <= n:\n        if n % factor == 0:\n            last_factor = factor\n            while n % factor == 0:\n                n //= factor\n        factor += 1\n    # If n is greater than 1, then it is a prime number\n    if n > 1:\n        last_factor = n\n    return last_factor\n\nCung cấp mô tả ngắn gọn bằng ngôn ngữ tự nhiên (docstring) cho mã Python bằng tiếng Việt, sử dụng tối đa 500 ký tự."
    },
    "instruction_bertscore": {
      "es": "0.9687387561112052",
      "arb": "0.906469919330197",
      "sw": "0.914896018724078",
      "tr": "0.8475623058570613",
      "vi": "0.9256256346468206"
    },
    "level": "",
    "test": "def test_largest_prime_factor():\n    test_cases = [\n        # Test case 1: composite number\n        {\n            'n': 35,  # 5 * 7\n            'expected': 7\n        },\n        # Test case 2: prime number itself\n        {\n            'n': 29,\n            'expected': 29\n        },\n        # Test case 3: composite number with a square of a prime\n        {\n            'n': 49,  # 7 * 7\n            'expected': 7\n        },\n        # Test case 4: large composite number\n        {\n            'n': 2 * 2 * 3 * 3 * 7 * 11,  # prime factors are 2, 3, 7, 11\n            'expected': 11\n        },\n    ]\n\n    for i, test in enumerate(test_cases, 1):\n        result = largest_prime_factor(test['n'])\n        assert result == test['expected'], f\"Test case {i} failed: result {result} does not match expected {test['expected']}\"\n        print(f\"Test case {i} passed with result {result}.\")\n\n# Run the test function\ntest_largest_prime_factor()",
    "entry_point": "largest_prime_factor",
    "signature": "def largest_prime_factor(n: int) -> int:",
    "docstring": {
      "en": "Find the largest prime factor of a given positive integer.\n\nThe integer is assumed to be the product of exactly two distinct prime numbers.\nThe function iterates through potential factors starting from the smallest prime (2)\nand checks if they are a factor of 'n'. If a factor is found, the function returns\nthe division of 'n' by this factor, which is the larger prime factor. If no factors\nare found up to the square root of 'n', then 'n' itself is a prime number and is\nreturned as the largest prime factor.\n\nArgs:\nn (int): The positive integer to factorize, which is the product of two distinct primes.\n\nReturns:\nint: The larger of the two prime factors of 'n'.\n\nExamples:\n>>> largest_prime_factor(21)\n7\n>>> largest_prime_factor(15)\n5\n>>> largest_prime_factor(29)\n29",
      "es": "Encuentra el mayor factor primo de un entero positivo dado.\n\nSe asume que el entero es el producto de exactamente dos números primos distintos. La función itera a través de posibles factores comenzando desde el primo más pequeño (2) y verifica si son un factor de 'n'. Si se encuentra un factor, la función devuelve la división de 'n' por este factor, que es el mayor factor primo. Si no se encuentran factores hasta la raíz cuadrada de 'n', entonces 'n' en sí mismo es un número primo y se devuelve como el mayor factor primo.\n\nArgumentos:\nn (int): El entero positivo a factorizar, que es el producto de dos primos distintos.\n\nDevuelve:\nint: El mayor de los dos factores primos de 'n'.\n\nEjemplos:\n>>> largest_prime_factor(21)\n7\n>>> largest_prime_factor(15)\n5\n>>> largest_prime_factor(29)\n29",
      "arb": "البحث عن أكبر عامل أولي لعدد صحيح موجب معين.\n\nيفترض أن العدد الصحيح هو ناتج ضرب عددين أوليين مختلفين تمامًا.\nتقوم الدالة بالتكرار عبر العوامل المحتملة بدءًا من أصغر عدد أولي (2)\nوتتحقق مما إذا كانت عاملاً لـ 'n'. إذا تم العثور على عامل، تقوم الدالة بإرجاع\nقسمة 'n' على هذا العامل، وهو العامل الأولي الأكبر. إذا لم يتم العثور على عوامل\nحتى الجذر التربيعي لـ 'n'، فإن 'n' نفسه هو عدد أولي ويتم إرجاعه كأكبر عامل أولي.\n\nالمعاملات:\nn (int): العدد الصحيح الموجب لتفكيكه، وهو ناتج ضرب عددين أوليين مختلفين.\n\nالقيم المعادة:\nint: الأكبر بين العاملين الأوليين لـ 'n'.\n\nأمثلة:\n>>> largest_prime_factor(21)\n7\n>>> largest_prime_factor(15)\n5\n>>> largest_prime_factor(29)\n29",
      "sw": "Pata kigezo kikubwa zaidi cha nambari ya kwanza ya nambari chanya iliyotolewa.\n\nNambari hiyo inadhaniwa kuwa ni zao la nambari mbili tofauti za msingi.\nKazi hii inarudia kupitia sababu zinazowezekana kuanzia na nambari ndogo zaidi ya msingi (2)\nna inakagua kama ni sababu ya 'n'. Ikiwa sababu inapatikana, kazi inarejesha\nmgawanyiko wa 'n' na sababu hii, ambayo ni sababu kubwa zaidi ya msingi. Ikiwa hakuna sababu\nzinazopatikana hadi mzizi wa mraba wa 'n', basi 'n' yenyewe ni nambari ya msingi na\ninarejeshwa kama sababu kubwa zaidi ya msingi.\n\nHoja:\nn (int): Nambari chanya ya kufanyia sababu, ambayo ni zao la nambari mbili tofauti za msingi.\n\nInarejesha:\nint: Moja ya sababu kubwa zaidi kati ya mbili za msingi za 'n'.\n\nMifano:\n>>> largest_prime_factor(21)\n7\n>>> largest_prime_factor(15)\n5\n>>> largest_prime_factor(29)\n29",
      "tr": "Verilen pozitif bir tam sayının en büyük asal çarpanını bulun.\n\nTam sayının, tam olarak iki farklı asal sayının çarpımı olduğu varsayılmaktadır.\nFonksiyon, en küçük asal sayıdan (2) başlayarak potansiyel çarpanlar arasında iterasyon yapar\nve bunların 'n' sayısının bir çarpanı olup olmadığını kontrol eder. Bir çarpan bulunursa, fonksiyon\n'n' sayısının bu çarpana bölünmesini döndürür, bu da daha büyük asal çarpandır. Eğer 'n' sayısının\nkareköküne kadar hiçbir çarpan bulunamazsa, o zaman 'n' sayısının kendisi bir asal sayıdır ve\nen büyük asal çarpan olarak döndürülür.\n\nArgümanlar:\nn (int): İki farklı asalın çarpımı olan ve çarpanlarına ayrılacak pozitif tam sayı.\n\nDöndürür:\nint: 'n' sayısının iki asal çarpanından daha büyüğü.\n\nÖrnekler:\n>>> largest_prime_factor(21)\n7\n>>> largest_prime_factor(15)\n5\n>>> largest_prime_factor(29)\n29",
      "vi": "Tìm ước số nguyên tố lớn nhất của một số nguyên dương cho trước.\n\nSố nguyên được giả định là tích của chính xác hai số nguyên tố khác nhau. Hàm này lặp qua các ước số tiềm năng bắt đầu từ số nguyên tố nhỏ nhất (2) và kiểm tra xem chúng có phải là ước số của 'n' hay không. Nếu tìm thấy một ước số, hàm trả về phép chia của 'n' cho ước số này, đó là ước số nguyên tố lớn hơn. Nếu không tìm thấy ước số nào cho đến căn bậc hai của 'n', thì bản thân 'n' là một số nguyên tố và được trả về như ước số nguyên tố lớn nhất.\n\nTham số:\nn (int): Số nguyên dương cần phân tích, là tích của hai số nguyên tố khác nhau.\n\nTrả về:\nint: Số lớn hơn trong hai ước số nguyên tố của 'n'.\n\nVí dụ:\n>>> largest_prime_factor(21)\n7\n>>> largest_prime_factor(15)\n5\n>>> largest_prime_factor(29)\n29"
    },
    "docstring_bertscore": {
      "es": "0.9920581614750821",
      "arb": "0.9648954568685612",
      "sw": "0.9644666138759068",
      "tr": "0.9659913006807306",
      "vi": "0.9432622248092893"
    }
  },
  {
    "task_id": "Python/24",
    "prompt": {
      "en": "def count_partitions(n: int, k: int, x: int) -> int:\n    \"\"\"\n    Count the number of ways to partition an integer n into k parts,\n    where each part is at least x and order of parts does not matter.\n\n    Parameters:\n    n (int): The integer to be partitioned.\n    k (int): The number of parts to divide n into.\n    x (int): The minimum value for each part.\n\n    Returns:\n    int: The number of distinct partitioning ways.\n\n    Examples:\n    - count_partitions(7, 3, 1) will return 4, because there are four ways to partition \n      the number 7 into 3 parts with each part being at least 1: [1,1,5], [1,2,4], \n      [1,3,3], [2,2,3].\n    - count_partitions(6, 2, 1) will return 3, because there are three ways to partition \n      the number 6 into 2 parts with each part being at least 1: [1,5], [2,4], [3,3].\n    \"\"\"",
      "es": "def count_partitions(n: int, k: int, x: int) -> int:\n    \"\"\"\n    Cuenta el número de formas de particionar un entero n en k partes,\n    donde cada parte es al menos x y el orden de las partes no importa.\n\n    Parámetros:\n    n (int): El entero a ser particionado.\n    k (int): El número de partes en las que dividir n.\n    x (int): El valor mínimo para cada parte.\n\n    Devuelve:\n    int: El número de formas distintas de particionar.\n\n    Ejemplos:\n    - count_partitions(7, 3, 1) devolverá 4, porque hay cuatro formas de particionar \n      el número 7 en 3 partes con cada parte siendo al menos 1: [1,1,5], [1,2,4], \n      [1,3,3], [2,2,3].\n    - count_partitions(6, 2, 1) devolverá 3, porque hay tres formas de particionar \n      el número 6 en 2 partes con cada parte siendo al menos 1: [1,5], [2,4], [3,3].\n    \"\"\"",
      "arb": "def count_partitions(n: int, k: int, x: int) -> int:\n    \"\"\"\n    احسب عدد الطرق لتقسيم عدد صحيح n إلى k أجزاء،\n    حيث أن كل جزء لا يقل عن x وترتيب الأجزاء لا يهم.\n\n    المعلمات:\n    n (int): العدد الصحيح الذي سيتم تقسيمه.\n    k (int): عدد الأجزاء لتقسيم n إليها.\n    x (int): القيمة الدنيا لكل جزء.\n\n    العوائد:\n    int: عدد طرق التقسيم المميزة.\n\n    أمثلة:\n    - count_partitions(7, 3, 1) سيعيد 4، لأنه هناك أربع طرق لتقسيم \n      العدد 7 إلى 3 أجزاء بحيث يكون كل جزء على الأقل 1: [1,1,5], [1,2,4], \n      [1,3,3], [2,2,3].\n    - count_partitions(6, 2, 1) سيعيد 3، لأنه هناك ثلاث طرق لتقسيم \n      العدد 6 إلى 2 أجزاء بحيث يكون كل جزء على الأقل 1: [1,5], [2,4], [3,3].\n    \"\"\"",
      "sw": "def count_partitions(n: int, k: int, x: int) -> int:\n    \"\"\"\n    Hesabu idadi ya njia za kugawa nambari n katika sehemu k,\n    ambapo kila sehemu ni angalau x na mpangilio wa sehemu haujalishi.\n\n    Vigezo:\n    n (int): Nambari ya kugawanywa.\n    k (int): Idadi ya sehemu za kugawa n.\n    x (int): Thamani ya chini kwa kila sehemu.\n\n    Inarejesha:\n    int: Idadi ya njia tofauti za kugawa.\n\n    Mifano:\n    - count_partitions(7, 3, 1) itarejesha 4, kwa sababu kuna njia nne za kugawa \n      nambari 7 katika sehemu 3 na kila sehemu ikiwa angalau 1: [1,1,5], [1,2,4], \n      [1,3,3], [2,2,3].\n    - count_partitions(6, 2, 1) itarejesha 3, kwa sababu kuna njia tatu za kugawa \n      nambari 6 katika sehemu 2 na kila sehemu ikiwa angalau 1: [1,5], [2,4], [3,3].\n    \"\"\"",
      "tr": "def count_partitions(n: int, k: int, x: int) -> int:\n    \"\"\"\n    Bir tamsayı n'yi k parçaya ayırmanın yollarını sayar,\n    burada her bir parça en az x'tir ve parçaların sırası önemli değildir.\n\n    Parametreler:\n    n (int): Parçalanacak tamsayı.\n    k (int): n'yi bölmek için parça sayısı.\n    x (int): Her bir parça için minimum değer.\n\n    Döndürür:\n    int: Farklı bölme yollarının sayısı.\n\n    Örnekler:\n    - count_partitions(7, 3, 1) 4 döndürecektir, çünkü 7 sayısını 3 parçaya \n      ayırmanın dört yolu vardır ve her parça en az 1'dir: [1,1,5], [1,2,4], \n      [1,3,3], [2,2,3].\n    - count_partitions(6, 2, 1) 3 döndürecektir, çünkü 6 sayısını 2 parçaya \n      ayırmanın üç yolu vardır ve her parça en az 1'dir: [1,5], [2,4], [3,3].\n    \"\"\"",
      "vi": "def count_partitions(n: int, k: int, x: int) -> int:\n    \"\"\"\n    Đếm số cách để phân hoạch một số nguyên n thành k phần,\n    trong đó mỗi phần ít nhất là x và thứ tự của các phần không quan trọng.\n\n    Tham số:\n    n (int): Số nguyên cần được phân hoạch.\n    k (int): Số phần để chia n.\n    x (int): Giá trị tối thiểu cho mỗi phần.\n\n    Trả về:\n    int: Số cách phân hoạch khác biệt.\n\n    Ví dụ:\n    - count_partitions(7, 3, 1) sẽ trả về 4, vì có bốn cách để phân hoạch \n      số 7 thành 3 phần với mỗi phần ít nhất là 1: [1,1,5], [1,2,4], \n      [1,3,3], [2,2,3].\n    - count_partitions(6, 2, 1) sẽ trả về 3, vì có ba cách để phân hoạch \n      số 6 thành 2 phần với mỗi phần ít nhất là 1: [1,5], [2,4], [3,3].\n    \"\"\""
    },
    "prompt_bertscore": {
      "es": "0.9856088316332603",
      "arb": "0.9773543488885934",
      "sw": "0.9745047974422669",
      "tr": "0.9740699955381815",
      "vi": "0.9873855803916174"
    },
    "canonical_solution": "    if k == 1:\n        if n >= x:\n            return 1\n        else:\n            return 0\n    count = 0\n    for i in range(x, n // k + 1):\n        count += count_partitions(n - i, k - 1, i)\n    return count",
    "instruction": {
      "en": "def count_partitions(n: int, k: int, x: int) -> int:\n    if k == 1:\n        if n >= x:\n            return 1\n        else:\n            return 0\n    count = 0\n    for i in range(x, n // k + 1):\n        count += count_partitions(n - i, k - 1, i)\n    return count\n\nProvide a concise natural language description (docstring) of the Python code in English using at most 500 characters.",
      "es": "def count_partitions(n: int, k: int, x: int) -> int:\n    if k == 1:\n        if n >= x:\n            return 1\n        else:\n            return 0\n    count = 0\n    for i in range(x, n // k + 1):\n        count += count_partitions(n - i, k - 1, i)\n    return count\n\nProporciona una descripción concisa en lenguaje natural (docstring) del código Python en español utilizando un máximo de 500 caracteres.",
      "arb": "def count_partitions(n: int, k: int, x: int) -> int:\n    if k == 1:\n        if n >= x:\n            return 1\n        else:\n            return 0\n    count = 0\n    for i in range(x, n // k + 1):\n        count += count_partitions(n - i, k - 1, i)\n    return count\n\nيرجى تقديم وصف موجز بلغة طبيعية (docstring) للشفرة البرمجية بلغة بايثون باللغة العربية الفصحى، بحيث لا يتجاوز 500 حرف.",
      "sw": "def count_partitions(n: int, k: int, x: int) -> int:\n    if k == 1:\n        if n >= x:\n            return 1\n        else:\n            return 0\n    count = 0\n    for i in range(x, n // k + 1):\n        count += count_partitions(n - i, k - 1, i)\n    return count\n\nToa maelezo mafupi ya lugha ya asili (docstring) ya msimbo wa Python kwa Kiswahili kwa kutumia herufi zisizozidi 500.",
      "tr": "def count_partitions(n: int, k: int, x: int) -> int:\n    if k == 1:\n        if n >= x:\n            return 1\n        else:\n            return 0\n    count = 0\n    for i in range(x, n // k + 1):\n        count += count_partitions(n - i, k - 1, i)\n    return count\n\nVerilen Python kodunun işlevini açıklayan, en fazla 500 karakter uzunluğunda özlü bir doğal dil açıklaması (docstring) sağlayın.",
      "vi": "def count_partitions(n: int, k: int, x: int) -> int:\n    if k == 1:\n        if n >= x:\n            return 1\n        else:\n            return 0\n    count = 0\n    for i in range(x, n // k + 1):\n        count += count_partitions(n - i, k - 1, i)\n    return count\n\nCung cấp mô tả ngắn gọn bằng ngôn ngữ tự nhiên (docstring) cho mã Python bằng tiếng Việt, không quá 500 ký tự."
    },
    "instruction_bertscore": {
      "es": "0.946669927626324",
      "arb": "0.906469919330197",
      "sw": "0.914896018724078",
      "tr": "0.8508820154152974",
      "vi": "0.9207613752456573"
    },
    "level": "",
    "test": "def test_count_partitions():\n    # Test case 1: Simple case\n    result = count_partitions(7, 3, 1)\n    assert result == 4, f\"Expected 4, got {result}\"\n\n    # Test case 2: Another simple case\n    result = count_partitions(6, 2, 1)\n    assert result == 3, f\"Expected 3, got {result}\"\n\n    # Test case 3: Partitioning into a larger number of parts\n    result = count_partitions(8, 4, 1)\n    assert result == 5, f\"Expected 5, got {result}\"\n\n    print(\"All test cases passed successfully!\")\n\n\n# Call the test function to run the test cases\ntest_count_partitions()",
    "entry_point": "count_partitions",
    "signature": "def count_partitions(n: int, k: int, x: int) -> int:",
    "docstring": {
      "en": "Count the number of ways to partition an integer n into k parts,\nwhere each part is at least x and order of parts does not matter.\n\nParameters:\nn (int): The integer to be partitioned.\nk (int): The number of parts to divide n into.\nx (int): The minimum value for each part.\n\nReturns:\nint: The number of distinct partitioning ways.\n\nExamples:\n- count_partitions(7, 3, 1) will return 4, because there are four ways to partition\nthe number 7 into 3 parts with each part being at least 1: [1,1,5], [1,2,4],\n[1,3,3], [2,2,3].\n- count_partitions(6, 2, 1) will return 3, because there are three ways to partition\nthe number 6 into 2 parts with each part being at least 1: [1,5], [2,4], [3,3].",
      "es": "Contar el número de formas de particionar un entero n en k partes, donde cada parte es al menos x y el orden de las partes no importa.\n\nParámetros:\nn (int): El entero a ser particionado.\nk (int): El número de partes en las que dividir n.\nx (int): El valor mínimo para cada parte.\n\nDevuelve:\nint: El número de formas distintas de particionar.\n\nEjemplos:\n- count_partitions(7, 3, 1) devolverá 4, porque hay cuatro formas de particionar el número 7 en 3 partes con cada parte siendo al menos 1: [1,1,5], [1,2,4], [1,3,3], [2,2,3].\n- count_partitions(6, 2, 1) devolverá 3, porque hay tres formas de particionar el número 6 en 2 partes con cada parte siendo al menos 1: [1,5], [2,4], [3,3].",
      "arb": "احسب عدد الطرق لتقسيم عدد صحيح n إلى k أجزاء، حيث يكون كل جزء على الأقل x ولا يهم ترتيب الأجزاء.\n\nالمعطيات:\nn (int): العدد الصحيح المراد تقسيمه.\nk (int): عدد الأجزاء لتقسيم n إليها.\nx (int): القيمة الدنيا لكل جزء.\n\nالقيم المعادة:\nint: عدد طرق التقسيم المميزة.\n\nأمثلة:\n- count_partitions(7, 3, 1) ستعيد 4، لأن هناك أربع طرق لتقسيم العدد 7 إلى 3 أجزاء بحيث يكون كل جزء على الأقل 1: [1,1,5], [1,2,4], [1,3,3], [2,2,3].\n- count_partitions(6, 2, 1) ستعيد 3، لأن هناك ثلاث طرق لتقسيم العدد 6 إلى 2 أجزاء بحيث يكون كل جزء على الأقل 1: [1,5], [2,4], [3,3].",
      "sw": "Hesabu idadi ya njia za kugawanya nambari n katika sehemu k,\nambapo kila sehemu ni angalau x na mpangilio wa sehemu haujalishi.\n\nVigezo:\nn (int): Nambari ya kugawanywa.\nk (int): Idadi ya sehemu za kugawa n.\nx (int): Thamani ya chini kwa kila sehemu.\n\nRudisha:\nint: Idadi ya njia tofauti za kugawanya.\n\nMifano:\n- count_partitions(7, 3, 1) itarudisha 4, kwa sababu kuna njia nne za kugawanya\nnambari 7 katika sehemu 3 na kila sehemu ikiwa angalau 1: [1,1,5], [1,2,4],\n[1,3,3], [2,2,3].\n- count_partitions(6, 2, 1) itarudisha 3, kwa sababu kuna njia tatu za kugawanya\nnambari 6 katika sehemu 2 na kila sehemu ikiwa angalau 1: [1,5], [2,4], [3,3].",
      "tr": "Bir tamsayı n'yi k parçaya ayırmanın yollarını sayın,\nher bir parça en az x olacak şekilde ve parçaların sırası önemli değildir.\n\nParametreler:\nn (int): Parçalanacak tamsayı.\nk (int): n'yi bölmek için parça sayısı.\nx (int): Her bir parça için minimum değer.\n\nDöndürür:\nint: Farklı bölme yollarının sayısı.\n\nÖrnekler:\n- count_partitions(7, 3, 1) 4 döndürecektir, çünkü\nher bir parça en az 1 olacak şekilde 7 sayısını 3 parçaya ayırmanın dört yolu vardır: [1,1,5], [1,2,4],\n[1,3,3], [2,2,3].\n- count_partitions(6, 2, 1) 3 döndürecektir, çünkü\nher bir parça en az 1 olacak şekilde 6 sayısını 2 parçaya ayırmanın üç yolu vardır: [1,5], [2,4], [3,3].",
      "vi": "Đếm số cách để phân hoạch một số nguyên n thành k phần,\ntrong đó mỗi phần ít nhất là x và thứ tự của các phần không quan trọng.\n\nTham số:\nn (int): Số nguyên cần được phân hoạch.\nk (int): Số phần để chia n thành.\nx (int): Giá trị tối thiểu cho mỗi phần.\n\nTrả về:\nint: Số cách phân hoạch khác biệt.\n\nVí dụ:\n- count_partitions(7, 3, 1) sẽ trả về 4, vì có bốn cách để phân hoạch\nsố 7 thành 3 phần với mỗi phần ít nhất là 1: [1,1,5], [1,2,4],\n[1,3,3], [2,2,3].\n- count_partitions(6, 2, 1) sẽ trả về 3, vì có ba cách để phân hoạch\nsố 6 thành 2 phần với mỗi phần ít nhất là 1: [1,5], [2,4], [3,3]."
    },
    "docstring_bertscore": {
      "es": "0.9837105210817099",
      "arb": "0.9829755886718807",
      "sw": "0.979076871552928",
      "tr": "0.9781812471648417",
      "vi": "0.9870514840907166"
    }
  },
  {
    "task_id": "Python/25",
    "prompt": {
      "en": "def count_sequences(n: int, last: int, memo: dict) -> int:\n    \"\"\"\n    Calculate the number of valid sequences that can be formed according to specific rules.\n    \n    Each sequence starts with a given number 'n', and a new number can be appended to the sequence\n    if it is a positive integer and not greater than half the last number in the sequence. This\n    function uses memoization to store previously calculated results to optimize performance.\n    \n    Args:\n        n (int): The starting number of the sequence.\n        last (int): The last number in the current sequence.\n        memo (dict): A dictionary used for memoization, storing the number of valid sequences\n                     for each 'last' value encountered.\n    \n    Returns:\n        int: The total number of valid sequences that can be formed starting with 'n'.\n    \n    Examples:\n        # Only one sequence can be formed starting with 1: [1]\n        >>> count_sequences(1, 1, {})\n        1\n        \n        # Six sequences can be formed starting with 6:\n        # [6], [6, 1], [6, 2], [6, 3], [6, 2, 1], [6, 3, 1]\n        >>> count_sequences(6, 6, {})\n        6\n        \n        # More complex example with memoization dictionary passed\n        # You would typically not pass this dictionary manually,\n        # it's used internally by the function for optimization.\n        >>> memo = {}\n        >>> count_sequences(10, 10, memo)\n        42  # This is an assumed value for the example; the actual result may differ.\n    \"\"\"\n    # Function implementation is here...",
      "es": "def count_sequences(n: int, last: int, memo: dict) -> int:\n    \"\"\"\n    Calcular el número de secuencias válidas que se pueden formar según reglas específicas.\n    \n    Cada secuencia comienza con un número dado 'n', y se puede agregar un nuevo número a la secuencia\n    si es un entero positivo y no es mayor que la mitad del último número en la secuencia. Esta\n    función utiliza memoización para almacenar resultados previamente calculados y optimizar el rendimiento.\n    \n    Argumentos:\n        n (int): El número inicial de la secuencia.\n        last (int): El último número en la secuencia actual.\n        memo (dict): Un diccionario utilizado para la memoización, almacenando el número de secuencias válidas\n                     para cada valor 'last' encontrado.\n    \n    Devuelve:\n        int: El número total de secuencias válidas que se pueden formar comenzando con 'n'.\n    \n    Ejemplos:\n        # Solo se puede formar una secuencia comenzando con 1: [1]\n        >>> count_sequences(1, 1, {})\n        1\n        \n        # Se pueden formar seis secuencias comenzando con 6:\n        # [6], [6, 1], [6, 2], [6, 3], [6, 2, 1], [6, 3, 1]\n        >>> count_sequences(6, 6, {})\n        6\n        \n        # Ejemplo más complejo con diccionario de memoización pasado\n        # Normalmente no pasarías este diccionario manualmente,\n        # se utiliza internamente por la función para optimización.\n        >>> memo = {}\n        >>> count_sequences(10, 10, memo)\n        42  # Este es un valor asumido para el ejemplo; el resultado real puede diferir.\n    \"\"\"\n    # Function implementation is here...",
      "arb": "def count_sequences(n: int, last: int, memo: dict) -> int:\n    \"\"\"\n    حساب عدد التسلسلات الصالحة التي يمكن تشكيلها وفقًا لقواعد محددة.\n    \n    يبدأ كل تسلسل برقم معين 'n'، ويمكن إضافة رقم جديد إلى التسلسل\n    إذا كان عددًا صحيحًا موجبًا ولا يزيد عن نصف الرقم الأخير في التسلسل. \n    تستخدم هذه الدالة التخزين المؤقت لحفظ النتائج المحسوبة سابقًا لتحسين الأداء.\n    \n    يعيدالحجج:\n        n (int): الرقم الابتدائي للتسلسل.\n        last (int): الرقم الأخير في التسلسل الحالي.\n        memo (dict): قاموس يستخدم للتخزين المؤقت، يخزن عدد التسلسلات الصالحة\n                     لكل قيمة 'last' تم مواجهتها.\n    \n    يعيد:\n        int: إجمالي عدد التسلسلات الصالحة التي يمكن تشكيلها بدءًا من 'n'.\n    \n    أمثلة:\n        # يمكن تشكيل تسلسل واحد فقط يبدأ بـ 1: [1]\n        >>> count_sequences(1, 1, {})\n        1\n        \n        # يمكن تشكيل ستة تسلسلات تبدأ بـ 6:\n        # [6], [6, 1], [6, 2], [6, 3], [6, 2, 1], [6, 3, 1]\n        >>> count_sequences(6, 6, {})\n        6\n        \n        # مثال أكثر تعقيدًا مع قاموس التخزين المؤقت الممرر\n        # عادةً لن تقوم بتمرير هذا القاموس يدويًا،\n        # يتم استخدامه داخليًا بواسطة الدالة للتحسين.\n        >>> memo = {}\n        >>> count_sequences(10, 10, memo)\n        42  # هذه قيمة مفترضة للمثال؛ قد يختلف النتيجة الفعلية.\n    \"\"\"\n    # Function implementation is here...",
      "sw": "def count_sequences(n: int, last: int, memo: dict) -> int:\n    \"\"\"\n    Hesabu idadi ya mlolongo halali ambao unaweza kuundwa kulingana na sheria maalum.\n    \n    Kila mlolongo huanza na nambari fulani 'n', na nambari mpya inaweza kuongezwa kwenye mlolongo\n    ikiwa ni nambari nzima chanya na haizidi nusu ya nambari ya mwisho katika mlolongo. \n    Kazi hii hutumia memoization kuhifadhi matokeo yaliyokokotolewa awali ili kuboresha utendaji.\n\n    Hoja:\n        n (int): Nambari ya kuanzia ya mlolongo.\n        last (int): Nambari ya mwisho katika mlolongo wa sasa.\n        memo (dict): Kamusi inayotumika kwa memoization, ikihifadhi idadi ya mlolongo halali\n                     kwa kila thamani ya 'last' iliyokutana nayo.\n    \n    Inarejesha:\n        int: Jumla ya idadi ya mlolongo halali ambao unaweza kuundwa kuanzia na 'n'.\n    \n    Mifano:\n        # Mlolongo mmoja tu unaweza kuundwa kuanzia na 1: [1]\n        >>> count_sequences(1, 1, {})\n        1\n        \n        # Mlolongo sita unaweza kuundwa kuanzia na 6:\n        # [6], [6, 1], [6, 2], [6, 3], [6, 2, 1], [6, 3, 1]\n        >>> count_sequences(6, 6, {})\n        6\n        \n        # Mfano mgumu zaidi na kamusi ya memoization iliyopitishwa\n        # Kwa kawaida usingepitisha kamusi hii mwenyewe,\n        # inatumika ndani ya kazi kwa ajili ya kuboresha utendaji.\n        >>> memo = {}\n        >>> count_sequences(10, 10, memo)\n        42  # Hii ni thamani iliyodhaniwa kwa mfano; matokeo halisi yanaweza kutofautiana.\n    \"\"\"\n    # Utekelezaji wa kazi uko hapa...",
      "tr": "def count_sequences(n: int, last: int, memo: dict) -> int:\n    \"\"\"\n    Belirli kurallara göre oluşturulabilecek geçerli dizilerin sayısını hesaplayın.\n    \n    Her dizi verilen bir sayı 'n' ile başlar ve dizinin son sayısının yarısından büyük olmayan\n    pozitif bir tamsayı ise diziye yeni bir sayı eklenebilir. Bu fonksiyon, performansı\n    optimize etmek için daha önce hesaplanmış sonuçları saklamak amacıyla memoization kullanır.\n    \n    Argümanlar:\n        n (int): Dizinin başlangıç sayısı.\n        last (int): Mevcut dizideki son sayı.\n        memo (dict): Her karşılaşılan 'last' değeri için geçerli dizilerin sayısını saklayan,\n                     memoization için kullanılan bir sözlük.\n    \n    Döndürür:\n        int: 'n' ile başlayan oluşturulabilecek geçerli dizilerin toplam sayısı.\n    \n    Örnekler:\n        # Sadece 1 ile başlayan bir dizi oluşturulabilir: [1]\n        >>> count_sequences(1, 1, {})\n        1\n        \n        # 6 ile başlayan altı dizi oluşturulabilir:\n        # [6], [6, 1], [6, 2], [6, 3], [6, 2, 1], [6, 3, 1]\n        >>> count_sequences(6, 6, {})\n        6\n        \n        # Memoization sözlüğü ile daha karmaşık bir örnek\n        # Bu sözlüğü genellikle manuel olarak geçmezsiniz,\n        # fonksiyon tarafından optimizasyon için dahili olarak kullanılır.\n        >>> memo = {}\n        >>> count_sequences(10, 10, memo)\n        42  # Bu, örnek için varsayılan bir değerdir; gerçek sonuç farklı olabilir.\n    \"\"\"\n    # Function implementation is here...",
      "vi": "def count_sequences(n: int, last: int, memo: dict) -> int:\n    \"\"\"\n    Tính toán số lượng dãy hợp lệ có thể được tạo ra theo các quy tắc cụ thể.\n    \n    Mỗi dãy bắt đầu với một số cho trước 'n', và một số mới có thể được thêm vào dãy\n    nếu nó là số nguyên dương và không lớn hơn một nửa số cuối cùng trong dãy. Hàm này\n    sử dụng ghi nhớ để lưu trữ các kết quả đã tính trước đó nhằm tối ưu hóa hiệu suất.\n    \n    Tham số:\n        n (int): Số bắt đầu của dãy.\n        last (int): Số cuối cùng trong dãy hiện tại.\n        memo (dict): Một từ điển được sử dụng cho ghi nhớ, lưu trữ số lượng dãy hợp lệ\n                     cho mỗi giá trị 'last' đã gặp.\n    \n    Trả về:\n        int: Tổng số dãy hợp lệ có thể được tạo ra bắt đầu với 'n'.\n    \n    Ví dụ:\n        # Chỉ có một dãy có thể được tạo ra bắt đầu với 1: [1]\n        >>> count_sequences(1, 1, {})\n        1\n        \n        # Sáu dãy có thể được tạo ra bắt đầu với 6:\n        # [6], [6, 1], [6, 2], [6, 3], [6, 2, 1], [6, 3, 1]\n        >>> count_sequences(6, 6, {})\n        6\n        \n        # Ví dụ phức tạp hơn với từ điển ghi nhớ được truyền vào\n        # Bạn thường không truyền từ điển này thủ công,\n        # nó được sử dụng nội bộ bởi hàm để tối ưu hóa.\n        >>> memo = {}\n        >>> count_sequences(10, 10, memo)\n        42  # Đây là giá trị giả định cho ví dụ; kết quả thực tế có thể khác.\n    \"\"\"\n    # Function implementation is here..."
    },
    "prompt_bertscore": {
      "es": "0.9908421462823864",
      "arb": "0.9838346650698566",
      "sw": "0.9709342177127838",
      "tr": "0.9775303354061904",
      "vi": "0.9795603379003669"
    },
    "canonical_solution": "    if last in memo:\n        return memo[last]  # Return the precomputed result\n\n    count = 1  # Count the current sequence\n    for next_num in range(1, last // 2 + 1):  # Try appending all possible numbers\n        count += count_sequences(n, next_num, memo)\n\n    memo[last] = count  # Store the computed result in the memo dictionary\n    return count",
    "instruction": {
      "en": "def count_sequences(n: int, last: int, memo: dict) -> int:\n    if last in memo:\n        return memo[last]  # Return the precomputed result\n\n    count = 1  # Count the current sequence\n    for next_num in range(1, last // 2 + 1):  # Try appending all possible numbers\n        count += count_sequences(n, next_num, memo)\n\n    memo[last] = count  # Store the computed result in the memo dictionary\n    return count\n\nProvide a concise natural language description (docstring) of the Python code in English using at most 500 characters.",
      "es": "def count_sequences(n: int, last: int, memo: dict) -> int:\n    if last in memo:\n        return memo[last]  # Return the precomputed result\n\n    count = 1  # Count the current sequence\n    for next_num in range(1, last // 2 + 1):  # Try appending all possible numbers\n        count += count_sequences(n, next_num, memo)\n\n    memo[last] = count  # Store the computed result in the memo dictionary\n    return count\n\nProporciona una descripción concisa en lenguaje natural (docstring) del código Python en español utilizando como máximo 500 caracteres.",
      "arb": "def count_sequences(n: int, last: int, memo: dict) -> int:\n    if last in memo:\n        return memo[last]  # Return the precomputed result\n\n    count = 1  # Count the current sequence\n    for next_num in range(1, last // 2 + 1):  # Try appending all possible numbers\n        count += count_sequences(n, next_num, memo)\n\n    memo[last] = count  # Store the computed result in the memo dictionary\n    return count\n\nيرجى تقديم وصف موجز بلغة طبيعية (docstring) للكود البرمجي المكتوب بلغة بايثون باللغة العربية الفصحى، بحيث لا يتجاوز 500 حرف.",
      "sw": "def count_sequences(n: int, last: int, memo: dict) -> int:\n    if last in memo:\n        return memo[last]  # Return the precomputed result\n\n    count = 1  # Count the current sequence\n    for next_num in range(1, last // 2 + 1):  # Try appending all possible numbers\n        count += count_sequences(n, next_num, memo)\n\n    memo[last] = count  # Store the computed result in the memo dictionary\n    return count\n\nToa maelezo mafupi ya lugha ya asili (docstring) ya msimbo wa Python kwa Kiswahili kwa kutumia herufi zisizozidi 500.",
      "tr": "def count_sequences(n: int, last: int, memo: dict) -> int:\n    if last in memo:\n        return memo[last]  # Return the precomputed result\n\n    count = 1  # Count the current sequence\n    for next_num in range(1, last // 2 + 1):  # Try appending all possible numbers\n        count += count_sequences(n, next_num, memo)\n\n    memo[last] = count  # Store the computed result in the memo dictionary\n    return count\n\nVerilen Python kodunun işlevini açıklayan kısa bir doğal dil tanımı (docstring) oluşturun. Açıklama, en fazla 500 karakter kullanılarak Türkçe olarak yazılmalıdır.",
      "vi": "def count_sequences(n: int, last: int, memo: dict) -> int:\n    if last in memo:\n        return memo[last]  # Return the precomputed result\n\n    count = 1  # Count the current sequence\n    for next_num in range(1, last // 2 + 1):  # Try appending all possible numbers\n        count += count_sequences(n, next_num, memo)\n\n    memo[last] = count  # Store the computed result in the memo dictionary\n    return count\n\nCung cấp mô tả ngắn gọn bằng ngôn ngữ tự nhiên (docstring) cho mã Python bằng tiếng Việt, sử dụng tối đa 500 ký tự."
    },
    "instruction_bertscore": {
      "es": "0.9687387561112052",
      "arb": "0.9141696274206335",
      "sw": "0.914896018724078",
      "tr": "0.8606063629796223",
      "vi": "0.9256256346468206"
    },
    "level": "",
    "test": "def test_count_sequences():\n    test_cases = [\n        (6, 6),\n        (1, 1),\n        (10, 14)\n    ]\n\n    for i, (n, expected) in enumerate(test_cases):\n        memo = {}\n        result = count_sequences(n, n, memo)\n        assert result == expected, f\"Test case {i+1} failed: expected {expected}, got {result}\"\n        print(f\"Test case {i+1} passed: n = {n}, expected = {expected}, got = {result}\")\n\n# Call the test function\ntest_count_sequences()",
    "entry_point": "count_sequences",
    "signature": "def count_sequences(n: int, last: int, memo: dict) -> int:",
    "docstring": {
      "en": "Calculate the number of valid sequences that can be formed according to specific rules.\n\nEach sequence starts with a given number 'n', and a new number can be appended to the sequence\nif it is a positive integer and not greater than half the last number in the sequence. This\nfunction uses memoization to store previously calculated results to optimize performance.\n\nArgs:\nn (int): The starting number of the sequence.\nlast (int): The last number in the current sequence.\nmemo (dict): A dictionary used for memoization, storing the number of valid sequences\nfor each 'last' value encountered.\n\nReturns:\nint: The total number of valid sequences that can be formed starting with 'n'.\n\nExamples:\nOnly one sequence can be formed starting with 1: [1]\n>>> count_sequences(1, 1, {})\n1\n\nSix sequences can be formed starting with 6:\n[6], [6, 1], [6, 2], [6, 3], [6, 2, 1], [6, 3, 1]\n>>> count_sequences(6, 6, {})\n6\n\nMore complex example with memoization dictionary passed\nYou would typically not pass this dictionary manually,\nit's used internally by the function for optimization.\n>>> memo = {}\n>>> count_sequences(10, 10, memo)\n42  # This is an assumed value for the example; the actual result may differ.",
      "es": "Calcular el número de secuencias válidas que se pueden formar según reglas específicas.\n\nCada secuencia comienza con un número dado 'n', y se puede agregar un nuevo número a la secuencia\nsi es un entero positivo y no es mayor que la mitad del último número en la secuencia. Esta\nfunción utiliza memoización para almacenar resultados calculados previamente y optimizar el rendimiento.\n\nArgumentos:\nn (int): El número inicial de la secuencia.\nlast (int): El último número en la secuencia actual.\nmemo (dict): Un diccionario utilizado para la memoización, que almacena el número de secuencias válidas\npara cada valor 'last' encontrado.\n\nDevuelve:\nint: El número total de secuencias válidas que se pueden formar comenzando con 'n'.\n\nEjemplos:\nSolo se puede formar una secuencia comenzando con 1: [1]\n>>> count_sequences(1, 1, {})\n1\n\nSe pueden formar seis secuencias comenzando con 6:\n[6], [6, 1], [6, 2], [6, 3], [6, 2, 1], [6, 3, 1]\n>>> count_sequences(6, 6, {})\n6\n\nEjemplo más complejo con diccionario de memoización pasado\nTípicamente no pasarías este diccionario manualmente,\nse utiliza internamente por la función para optimización.\n>>> memo = {}\n>>> count_sequences(10, 10, memo)\n42  # Este es un valor asumido para el ejemplo; el resultado real puede diferir.",
      "arb": "احسب عدد التسلسلات الصالحة التي يمكن تشكيلها وفقًا لقواعد محددة.\n\nكل تسلسل يبدأ برقم معين 'n'، ويمكن إضافة رقم جديد إلى التسلسل\nإذا كان عددًا صحيحًا موجبًا ولا يزيد عن نصف الرقم الأخير في التسلسل. هذه\nالدالة تستخدم التخزين المؤقت لتخزين النتائج المحسوبة مسبقًا لتحسين الأداء.\n\nيعيدالحجج:\nn (int): الرقم الذي يبدأ به التسلسل.\nlast (int): الرقم الأخير في التسلسل الحالي.\nmemo (dict): قاموس يُستخدم للتخزين المؤقت، حيث يتم تخزين عدد التسلسلات الصالحة\nلكل قيمة 'last' تم مواجهتها.\n\nيعيد:\nint: العدد الإجمالي للتسلسلات الصالحة التي يمكن تشكيلها بدءًا بـ 'n'.\n\nامثله:\nيمكن تشكيل تسلسل واحد فقط يبدأ بـ 1: [1]\n>>> count_sequences(1, 1, {})\n1\n\nيمكن تشكيل ستة تسلسلات تبدأ بـ 6:\n[6], [6, 1], [6, 2], [6, 3], [6, 2, 1], [6, 3, 1]\n>>> count_sequences(6, 6, {})\n6\n\nمثال أكثر تعقيدًا مع قاموس التخزين المؤقت الممرر\nعادةً لن تقوم بتمرير هذا القاموس يدويًا،\nيُستخدم داخليًا بواسطة الدالة للتحسين.\n>>> memo = {}\n>>> count_sequences(10, 10, memo)\n42  # هذه قيمة مفترضة للمثال؛ قد تختلف النتيجة الفعلية.",
      "sw": "Hesabu idadi ya mlolongo halali ambao unaweza kuundwa kulingana na sheria maalum.\n\nKila mlolongo huanza na nambari iliyotolewa 'n', na nambari mpya inaweza kuongezwa kwenye mlolongo\nikiwa ni nambari nzima chanya na haizidi nusu ya nambari ya mwisho katika mlolongo. Hii\nkazi hutumia memoization kuhifadhi matokeo yaliyokokotolewa hapo awali ili kuboresha utendaji.\n\nHoja:\nn (int): Nambari ya kuanzia ya mlolongo.\nlast (int): Nambari ya mwisho katika mlolongo wa sasa.\nmemo (dict): Kamusi inayotumika kwa memoization, kuhifadhi idadi ya milolongo halali\nkwa kila thamani ya 'last' iliyokutana nayo.\n\nInarejesha:\nint: Jumla ya idadi ya milolongo halali inayoweza kuundwa kuanzia na 'n'.\n\nMifano:\nMlolongo mmoja tu unaweza kuundwa kuanzia na 1: [1]\n>>> count_sequences(1, 1, {})\n1\n\nMilolongo sita inaweza kuundwa kuanzia na 6:\n[6], [6, 1], [6, 2], [6, 3], [6, 2, 1], [6, 3, 1]\n>>> count_sequences(6, 6, {})\n6\n\nMfano mgumu zaidi na kamusi ya memoization iliyopitishwa\nKwa kawaida usingepitisha kamusi hii mwenyewe,\ninatumika ndani na kazi kwa ajili ya uboreshaji.\n>>> memo = {}\n>>> count_sequences(10, 10, memo)\n42  # Hii ni thamani iliyodhaniwa kwa mfano; matokeo halisi yanaweza kutofautiana.",
      "tr": "Geçerli dizilerin belirli kurallara göre oluşturulabileceği sayıyı hesaplayın.\n\nHer dizi verilen bir sayı 'n' ile başlar ve dizinin son sayısının yarısından büyük olmayan pozitif bir tamsayı ise diziye yeni bir sayı eklenebilir. Bu fonksiyon, performansı optimize etmek için daha önce hesaplanmış sonuçları saklamak amacıyla memoizasyon kullanır.\n\nArgümanlar:\nn (int): Dizinin başlangıç sayısı.\nlast (int): Mevcut dizideki son sayı.\nmemo (dict): Her karşılaşılan 'last' değeri için geçerli dizilerin sayısını saklayan, memoizasyon için kullanılan bir sözlük.\n\nDöndürür:\nint: 'n' ile başlayan oluşturulabilecek toplam geçerli dizi sayısı.\n\nÖrnekler:\n1 ile başlayan sadece bir dizi oluşturulabilir: [1]\n>>> count_sequences(1, 1, {})\n1\n\n6 ile başlayan altı dizi oluşturulabilir:\n[6], [6, 1], [6, 2], [6, 3], [6, 2, 1], [6, 3, 1]\n>>> count_sequences(6, 6, {})\n6\n\nMemoizasyon sözlüğü ile daha karmaşık bir örnek\nBu sözlüğü manuel olarak geçmezsiniz,\nfonksiyon tarafından optimizasyon için dahili olarak kullanılır.\n>>> memo = {}\n>>> count_sequences(10, 10, memo)\n42  # Bu, örnek için varsayılan bir değerdir; gerçek sonuç farklı olabilir.",
      "vi": "Tính toán số lượng dãy hợp lệ có thể được tạo ra theo các quy tắc cụ thể.\n\nMỗi dãy bắt đầu với một số 'n' cho trước, và một số mới có thể được thêm vào dãy\nnếu nó là một số nguyên dương và không lớn hơn một nửa số cuối cùng trong dãy. Hàm này sử dụng ghi nhớ để lưu trữ các kết quả đã tính toán trước đó nhằm tối ưu hóa hiệu suất.\n\nTham số:\nn (int): Số bắt đầu của dãy.\nlast (int): Số cuối cùng trong dãy hiện tại.\nmemo (dict): Một từ điển được sử dụng cho ghi nhớ, lưu trữ số lượng dãy hợp lệ\ncho mỗi giá trị 'last' đã gặp.\n\nTrả về:\nint: Tổng số dãy hợp lệ có thể được tạo ra bắt đầu với 'n'.\n\nVí dụ:\nChỉ có một dãy có thể được tạo ra bắt đầu với 1: [1]\n>>> count_sequences(1, 1, {})\n1\n\nSáu dãy có thể được tạo ra bắt đầu với 6:\n[6], [6, 1], [6, 2], [6, 3], [6, 2, 1], [6, 3, 1]\n>>> count_sequences(6, 6, {})\n6\n\nVí dụ phức tạp hơn với từ điển ghi nhớ được truyền vào\nBạn thường sẽ không truyền từ điển này thủ công,\nnó được sử dụng nội bộ bởi hàm để tối ưu hóa.\n>>> memo = {}\n>>> count_sequences(10, 10, memo)\n42  # Đây là một giá trị giả định cho ví dụ; kết quả thực tế có thể khác."
    },
    "docstring_bertscore": {
      "es": "0.9854018587762219",
      "arb": "0.9595509092060553",
      "sw": "0.9750855926764129",
      "tr": "0.9667617879287649",
      "vi": "0.9745208865031307"
    }
  },
  {
    "task_id": "Python/26",
    "prompt": {
      "en": "from math import gcd\ndef count_coprime_pairs(x0: int, y0: int) -> int:\n    \"\"\"\n    Counts the number of pairs of positive integers (P, Q) such that P and Q have x0 as their greatest common divisor (GCD)\n    and y0 as their least common multiple (LCM).\n\n    Args:\n    x0 (int): The GCD that each pair (P, Q) must have.\n    y0 (int): The LCM that each pair (P, Q) must have.\n\n    Returns:\n    int: The count of all possible pairs (P, Q) that meet the specified criteria.\n\n    The function iterates through all possible factors 'a' of the quotient 'y0 / x0'. For each factor 'a',\n    it calculates the corresponding factor 'b' such that 'a * b = y0 / x0'. It then checks if 'a' and 'b'\n    are co-prime (their GCD is 1) because P and Q can only be multiples of 'x0' by co-prime factors to maintain\n    the GCD as 'x0'. If 'a' and 'b' are co-prime, the count is incremented by 1 if 'a' is the same as 'b',\n    else by 2 to account for both (P, Q) and (Q, P) pairs.\n\n    Example Cases:\n\n    Case 1: count_coprime_pairs(3, 60)\n    Explanation: The function would return 4, since the valid pairs are (3, 60), (15, 12), (12, 15), and (60, 3).\n\n    Case 2: count_coprime_pairs(2, 50)\n    Explanation: The function would return 0, as 50 is not a multiple of 2, so there are no valid pairs (P, Q).\n\n    Case 3: count_coprime_pairs(6, 180)\n    Explanation: The function would return 8, the valid pairs are (6, 180), (30, 36), (18, 60), (42, 30),\n    (60, 18), (36, 30), (180, 6), and the counts for other arrangements of these numbers.\n\n    Note:\n    For the function to work correctly, the input y0 must be a multiple of x0. If not, the function returns 0, \n    indicating no valid pairs exist under the given constraints.\n    \"\"\"",
      "es": "from math import gcd\ndef count_coprime_pairs(x0: int, y0: int) -> int:\n    \"\"\"\n    Cuenta el número de pares de enteros positivos (P, Q) tales que P y Q tienen x0 como su máximo común divisor (GCD)\n    y y0 como su mínimo común múltiplo (LCM).\n\n    Argumentos:\n    x0 (int): El GCD que cada par (P, Q) debe tener.\n    y0 (int): El LCM que cada par (P, Q) debe tener.\n\n    Devuelve:\n    int: La cuenta de todos los pares posibles (P, Q) que cumplen con los criterios especificados.\n\n    La función itera a través de todos los posibles factores 'a' del cociente 'y0 / x0'. Para cada factor 'a',\n    calcula el factor correspondiente 'b' tal que 'a * b = y0 / x0'. Luego verifica si 'a' y 'b'\n    son coprimos (su GCD es 1) porque P y Q solo pueden ser múltiplos de 'x0' por factores coprimos para mantener\n    el GCD como 'x0'. Si 'a' y 'b' son coprimos, la cuenta se incrementa en 1 si 'a' es igual a 'b',\n    de lo contrario en 2 para contabilizar ambos pares (P, Q) y (Q, P).\n\n    Casos de Ejemplo:\n\n    Caso 1: count_coprime_pairs(3, 60)\n    Explicación: La función devolvería 4, ya que los pares válidos son (3, 60), (15, 12), (12, 15), y (60, 3).\n\n    Caso 2: count_coprime_pairs(2, 50)\n    Explicación: La función devolvería 0, ya que 50 no es un múltiplo de 2, por lo que no hay pares válidos (P, Q).\n\n    Caso 3: count_coprime_pairs(6, 180)\n    Explicación: La función devolvería 8, los pares válidos son (6, 180), (30, 36), (18, 60), (42, 30),\n    (60, 18), (36, 30), (180, 6), y las cuentas para otras disposiciones de estos números.\n\n    Nota:\n    Para que la función funcione correctamente, la entrada y0 debe ser un múltiplo de x0. Si no, la función devuelve 0,\n    indicando que no existen pares válidos bajo las restricciones dadas.\n    \"\"\"",
      "arb": "from math import gcd\ndef count_coprime_pairs(x0: int, y0: int) -> int:\n    \"\"\"\n    يحسب عدد أزواج الأعداد الصحيحة الموجبة (P, Q) بحيث يكون P و Q لهما x0 كأكبر قاسم مشترك (GCD)\n    و y0 كأصغر مضاعف مشترك (LCM).\n\n    يعيدالحجج:\n    x0 (int): القاسم المشترك الأكبر الذي يجب أن يكون لكل زوج (P, Q).\n    y0 (int): المضاعف المشترك الأصغر الذي يجب أن يكون لكل زوج (P, Q).\n\n    يعيد:\n    int: عدد جميع الأزواج الممكنة (P, Q) التي تفي بالمعايير المحددة.\n\n    تقوم الدالة بالمرور عبر جميع العوامل الممكنة 'a' للناتج 'y0 / x0'. لكل عامل 'a',\n    تحسب العامل المقابل 'b' بحيث 'a * b = y0 / x0'. ثم تتحقق مما إذا كان 'a' و 'b'\n    متوافقين (القاسم المشترك الأكبر لهما هو 1) لأن P و Q يمكن أن يكونا فقط مضاعفات لـ 'x0' بعوامل متوافقة للحفاظ\n    على القاسم المشترك الأكبر كـ 'x0'. إذا كان 'a' و 'b' متوافقين، يتم زيادة العداد بمقدار 1 إذا كان 'a' هو نفسه 'b',\n    وإلا بمقدار 2 لحساب كلا الزوجين (P, Q) و (Q, P).\n\n    أمثلة الحالات:\n\n    الحالة 1: count_coprime_pairs(3, 60)\n    التوضيح: ستعيد الدالة 4، حيث أن الأزواج الصالحة هي (3, 60)، (15, 12)، (12, 15)، و (60, 3).\n\n    الحالة 2: count_coprime_pairs(2, 50)\n    التوضيح: ستعيد الدالة 0، حيث أن 50 ليس مضاعفًا لـ 2، لذلك لا توجد أزواج صالحة (P, Q).\n\n    الحالة 3: count_coprime_pairs(6, 180)\n    التوضيح: ستعيد الدالة 8، الأزواج الصالحة هي (6, 180)، (30, 36)، (18, 60)، (42, 30)،\n    (60, 18)، (36, 30)، (180, 6)، والحسابات لترتيبات أخرى لهذه الأرقام.\n\n    ملاحظة:\n    لكي تعمل الدالة بشكل صحيح، يجب أن يكون المدخل y0 مضاعفًا لـ x0. إذا لم يكن كذلك، تعيد الدالة 0،\n    مما يشير إلى عدم وجود أزواج صالحة تحت القيود المعطاة.\n    \"\"\"",
      "sw": "from math import gcd\ndef count_coprime_pairs(x0: int, y0: int) -> int:\n    \"\"\"\n    Inahesabu idadi ya jozi za namba nzima chanya (P, Q) ambapo P na Q zina x0 kama kigezo chao kikuu cha mgawanyiko (GCD)\n    na y0 kama kigezo chao kidogo cha pamoja (LCM).\n\n    Hoja:\n    x0 (int): GCD ambayo kila jozi (P, Q) lazima iwe nayo.\n    y0 (int): LCM ambayo kila jozi (P, Q) lazima iwe nayo.\n\n    Inarejesha:\n    int: Idadi ya jozi zote zinazowezekana (P, Q) zinazokidhi vigezo vilivyobainishwa.\n\n    Kazi hii inarudia kupitia vigezo vyote vinavyowezekana 'a' vya sehemu 'y0 / x0'. Kwa kila kigezo 'a',\n    inahesabu kigezo kinacholingana 'b' ambapo 'a * b = y0 / x0'. Kisha inakagua kama 'a' na 'b'\n    ni huru (GCD yao ni 1) kwa sababu P na Q zinaweza kuwa tu na vigezo vya 'x0' kwa vigezo huru ili kudumisha\n    GCD kama 'x0'. Ikiwa 'a' na 'b' ni huru, hesabu inaongezwa kwa 1 ikiwa 'a' ni sawa na 'b',\n    vinginevyo kwa 2 ili kuhesabu jozi zote mbili (P, Q) na (Q, P).\n\n    Mifano ya Kesi:\n\n    Kesi 1: count_coprime_pairs(3, 60)\n    Maelezo: Kazi itarudisha 4, kwa kuwa jozi halali ni (3, 60), (15, 12), (12, 15), na (60, 3).\n\n    Kesi 2: count_coprime_pairs(2, 50)\n    Maelezo: Kazi itarudisha 0, kwa kuwa 50 si kigezo cha 2, hivyo hakuna jozi halali (P, Q).\n\n    Kesi 3: count_coprime_pairs(6, 180)\n    Maelezo: Kazi itarudisha 8, jozi halali ni (6, 180), (30, 36), (18, 60), (42, 30),\n    (60, 18), (36, 30), (180, 6), na hesabu za mipangilio mingine ya namba hizi.\n\n    Kumbuka:\n    Ili kazi ifanye kazi kwa usahihi, kipengele cha y0 lazima kiwe kigezo cha x0. Ikiwa sivyo, kazi inarudisha 0,\n    ikionyesha hakuna jozi halali zilizopo chini ya vikwazo vilivyotolewa.\n    \"\"\"",
      "tr": "from math import gcd\ndef count_coprime_pairs(x0: int, y0: int) -> int:\n    \"\"\"\n    x0'ı en büyük ortak bölen (GCD) ve y0'ı en küçük ortak kat (LCM) olarak alan pozitif tam sayı çiftlerinin (P, Q) sayısını sayar.\n\n    Argümanlar:\n    x0 (int): Her çiftin (P, Q) sahip olması gereken GCD.\n    y0 (int): Her çiftin (P, Q) sahip olması gereken LCM.\n\n    Döndürür:\n    int: Belirtilen kriterleri karşılayan tüm olası çiftlerin (P, Q) sayısı.\n\n    Fonksiyon, 'y0 / x0' bölümünün tüm olası 'a' çarpanları üzerinden iterasyon yapar. Her 'a' çarpanı için,\n    'a * b = y0 / x0' olacak şekilde karşılık gelen 'b' çarpanını hesaplar. Daha sonra 'a' ve 'b' çarpanlarının\n    aralarında asal olup olmadığını kontrol eder (GCD'leri 1 ise) çünkü P ve Q sadece 'x0' çarpanları ile\n    aralarında asal çarpanlar olarak çarpılabilir, böylece GCD 'x0' olarak kalır. Eğer 'a' ve 'b' aralarında asal ise,\n    eğer 'a' 'b' ile aynıysa sayım 1 artırılır, aksi takdirde hem (P, Q) hem de (Q, P) çiftlerini hesaba katmak için 2 artırılır.\n\n    Örnek Durumlar:\n\n    Durum 1: count_coprime_pairs(3, 60)\n    Açıklama: Fonksiyon 4 döndürecektir, çünkü geçerli çiftler (3, 60), (15, 12), (12, 15) ve (60, 3) olacaktır.\n\n    Durum 2: count_coprime_pairs(2, 50)\n    Açıklama: Fonksiyon 0 döndürecektir, çünkü 50, 2'nin bir katı değildir, bu yüzden geçerli çiftler (P, Q) yoktur.\n\n    Durum 3: count_coprime_pairs(6, 180)\n    Açıklama: Fonksiyon 8 döndürecektir, geçerli çiftler (6, 180), (30, 36), (18, 60), (42, 30),\n    (60, 18), (36, 30), (180, 6) ve bu sayıların diğer düzenlemeleri için sayımlar olacaktır.\n\n    Not:\n    Fonksiyonun doğru çalışabilmesi için, giriş y0, x0'ın bir katı olmalıdır. Aksi takdirde, fonksiyon 0 döndürür,\n    bu da verilen kısıtlar altında geçerli çiftlerin olmadığını gösterir.\n    \"\"\"",
      "vi": "from math import gcd\ndef count_coprime_pairs(x0: int, y0: int) -> int:\n    \"\"\"\n    Đếm số cặp số nguyên dương (P, Q) sao cho P và Q có x0 là ước chung lớn nhất (GCD)\n    và y0 là bội chung nhỏ nhất (LCM).\n\n    Tham số:\n    x0 (int): GCD mà mỗi cặp (P, Q) phải có.\n    y0 (int): LCM mà mỗi cặp (P, Q) phải có.\n\n    Trả về:\n    int: Số lượng tất cả các cặp (P, Q) có thể đáp ứng tiêu chí đã chỉ định.\n\n    Hàm duyệt qua tất cả các ước số có thể 'a' của thương 'y0 / x0'. Đối với mỗi ước số 'a',\n    nó tính toán ước số tương ứng 'b' sao cho 'a * b = y0 / x0'. Sau đó, nó kiểm tra xem 'a' và 'b'\n    có phải là các số nguyên tố cùng nhau (GCD của chúng là 1) vì P và Q chỉ có thể là bội số của 'x0' \n    bởi các ước số nguyên tố cùng nhau để duy trì GCD là 'x0'. Nếu 'a' và 'b' là các số nguyên tố cùng nhau, \n    số đếm được tăng thêm 1 nếu 'a' giống 'b', nếu không thì tăng thêm 2 để tính cả cặp (P, Q) và (Q, P).\n\n    Ví dụ:\n\n    Trường hợp 1: count_coprime_pairs(3, 60)\n    Giải thích: Hàm sẽ trả về 4, vì các cặp hợp lệ là (3, 60), (15, 12), (12, 15), và (60, 3).\n\n    Trường hợp 2: count_coprime_pairs(2, 50)\n    Giải thích: Hàm sẽ trả về 0, vì 50 không phải là bội số của 2, nên không có cặp hợp lệ (P, Q).\n\n    Trường hợp 3: count_coprime_pairs(6, 180)\n    Giải thích: Hàm sẽ trả về 8, các cặp hợp lệ là (6, 180), (30, 36), (18, 60), (42, 30),\n    (60, 18), (36, 30), (180, 6), và số đếm cho các sắp xếp khác của các số này.\n\n    Lưu ý:\n    Để hàm hoạt động chính xác, đầu vào y0 phải là bội số của x0. Nếu không, hàm trả về 0,\n    chỉ ra rằng không có cặp hợp lệ nào tồn tại dưới các điều kiện đã cho.\n    \"\"\""
    },
    "prompt_bertscore": {
      "es": "0.9830701367332534",
      "arb": "0.9550290885817961",
      "sw": "0.9452213162574364",
      "tr": "0.9513224470413041",
      "vi": "0.9532847165755477"
    },
    "canonical_solution": "    if y0 % x0 != 0:\n        return 0  # If y0 is not a multiple of x0, there are no valid pairs.\n\n    product = y0 // x0\n    count = 0\n    \n    # Iterate through all factors of product.\n    for a in range(1, int(product**0.5) + 1):\n        if product % a == 0:\n            b = product // a\n            # Check if a and b are co-prime.\n            if gcd(a, b) == 1:\n                count += 1 if a == b else 2  # If a and b are different, we have two pairs (P, Q) and (Q, P).\n    \n    return count",
    "instruction": {
      "en": "def count_coprime_pairs(x0: int, y0: int) -> int:\n    if y0 % x0 != 0:\n        return 0  # If y0 is not a multiple of x0, there are no valid pairs.\n\n    product = y0 // x0\n    count = 0\n    \n    # Iterate through all factors of product.\n    for a in range(1, int(product**0.5) + 1):\n        if product % a == 0:\n            b = product // a\n            # Check if a and b are co-prime.\n            if gcd(a, b) == 1:\n                count += 1 if a == b else 2  # If a and b are different, we have two pairs (P, Q) and (Q, P).\n    \n    return count\n\nProvide a concise natural language description (docstring) of the Python code in English using at most 500 characters.",
      "es": "def count_coprime_pairs(x0: int, y0: int) -> int:\n    if y0 % x0 != 0:\n        return 0  # If y0 is not a multiple of x0, there are no valid pairs.\n\n    product = y0 // x0\n    count = 0\n    \n    # Iterate through all factors of product.\n    for a in range(1, int(product**0.5) + 1):\n        if product % a == 0:\n            b = product // a\n            # Check if a and b are co-prime.\n            if gcd(a, b) == 1:\n                count += 1 if a == b else 2  # If a and b are different, we have two pairs (P, Q) and (Q, P).\n    \n    return count\n\nProporcione una descripción concisa en lenguaje natural (docstring) del código Python en español utilizando como máximo 500 caracteres.",
      "arb": "def count_coprime_pairs(x0: int, y0: int) -> int:\n    if y0 % x0 != 0:\n        return 0  # If y0 is not a multiple of x0, there are no valid pairs.\n\n    product = y0 // x0\n    count = 0\n    \n    # Iterate through all factors of product.\n    for a in range(1, int(product**0.5) + 1):\n        if product % a == 0:\n            b = product // a\n            # Check if a and b are co-prime.\n            if gcd(a, b) == 1:\n                count += 1 if a == b else 2  # If a and b are different, we have two pairs (P, Q) and (Q, P).\n    \n    return count\n\nيرجى تقديم وصف موجز بلغة طبيعية (docstring) للشفرة البرمجية بلغة بايثون باللغة العربية الفصحى، بحيث لا يتجاوز 500 حرف.",
      "sw": "def count_coprime_pairs(x0: int, y0: int) -> int:\n    if y0 % x0 != 0:\n        return 0  # If y0 is not a multiple of x0, there are no valid pairs.\n\n    product = y0 // x0\n    count = 0\n    \n    # Iterate through all factors of product.\n    for a in range(1, int(product**0.5) + 1):\n        if product % a == 0:\n            b = product // a\n            # Check if a and b are co-prime.\n            if gcd(a, b) == 1:\n                count += 1 if a == b else 2  # If a and b are different, we have two pairs (P, Q) and (Q, P).\n    \n    return count\n\nToa maelezo mafupi ya lugha ya asili (docstring) ya msimbo wa Python kwa Kiswahili kwa kutumia herufi zisizozidi 500.",
      "tr": "def count_coprime_pairs(x0: int, y0: int) -> int:\n    if y0 % x0 != 0:\n        return 0  # If y0 is not a multiple of x0, there are no valid pairs.\n\n    product = y0 // x0\n    count = 0\n    \n    # Iterate through all factors of product.\n    for a in range(1, int(product**0.5) + 1):\n        if product % a == 0:\n            b = product // a\n            # Check if a and b are co-prime.\n            if gcd(a, b) == 1:\n                count += 1 if a == b else 2  # If a and b are different, we have two pairs (P, Q) and (Q, P).\n    \n    return count\n\nPython kodunun işlevselliğini açıklayan kısa bir doğal dil açıklaması (docstring) sağlayın. Açıklama Türkçe olmalı ve en fazla 500 karakter kullanılmalıdır.",
      "vi": "def count_coprime_pairs(x0: int, y0: int) -> int:\n    if y0 % x0 != 0:\n        return 0  # If y0 is not a multiple of x0, there are no valid pairs.\n\n    product = y0 // x0\n    count = 0\n    \n    # Iterate through all factors of product.\n    for a in range(1, int(product**0.5) + 1):\n        if product % a == 0:\n            b = product // a\n            # Check if a and b are co-prime.\n            if gcd(a, b) == 1:\n                count += 1 if a == b else 2  # If a and b are different, we have two pairs (P, Q) and (Q, P).\n    \n    return count\n\nCung cấp mô tả ngắn gọn bằng ngôn ngữ tự nhiên (docstring) cho mã Python bằng tiếng Việt, không quá 500 ký tự."
    },
    "instruction_bertscore": {
      "es": "0.9687387561112052",
      "arb": "0.906469919330197",
      "sw": "0.914896018724078",
      "tr": "0.8631802154570725",
      "vi": "0.905718500598742"
    },
    "level": "",
    "test": "def test_count_coprime_pairs():\n    test_cases = [\n        (3, 60, 4),   # The example from the problem statement\n        (2, 50, 2), \n        (6, 180, 8),  # 180/6 = 30, factors are (1, 30), (2, 15), (3, 10), (5, 6), (6, 5), (10, 3), (15, 2), (30, 1)\n    ]\n\n    for i, (x0, y0, expected) in enumerate(test_cases):\n        result = count_coprime_pairs(x0, y0)\n        assert result == expected, f\"Test case {i+1} failed: expected {expected}, got {result}\"\n        print(f\"Test case {i+1} passed: x0 = {x0}, y0 = {y0}, expected = {expected}, got = {result}\")\n\n# Call the test function\ntest_count_coprime_pairs()",
    "entry_point": "count_coprime_pairs",
    "signature": "def count_coprime_pairs(x0: int, y0: int) -> int:",
    "docstring": {
      "en": "Counts the number of pairs of positive integers (P, Q) such that P and Q have x0 as their greatest common divisor (GCD)\nand y0 as their least common multiple (LCM).\n\nArgs:\nx0 (int): The GCD that each pair (P, Q) must have.\ny0 (int): The LCM that each pair (P, Q) must have.\n\nReturns:\nint: The count of all possible pairs (P, Q) that meet the specified criteria.\n\nThe function iterates through all possible factors 'a' of the quotient 'y0 / x0'. For each factor 'a',\nit calculates the corresponding factor 'b' such that 'a * b = y0 / x0'. It then checks if 'a' and 'b'\nare co-prime (their GCD is 1) because P and Q can only be multiples of 'x0' by co-prime factors to maintain\nthe GCD as 'x0'. If 'a' and 'b' are co-prime, the count is incremented by 1 if 'a' is the same as 'b',\nelse by 2 to account for both (P, Q) and (Q, P) pairs.\n\nExample Cases:\n\nCase 1: count_coprime_pairs(3, 60)\nExplanation: The function would return 4, since the valid pairs are (3, 60), (15, 12), (12, 15), and (60, 3).\n\nCase 2: count_coprime_pairs(2, 50)\nExplanation: The function would return 0, as 50 is not a multiple of 2, so there are no valid pairs (P, Q).\n\nCase 3: count_coprime_pairs(6, 180)\nExplanation: The function would return 8, the valid pairs are (6, 180), (30, 36), (18, 60), (42, 30),\n(60, 18), (36, 30), (180, 6), and the counts for other arrangements of these numbers.\n\nNote:\nFor the function to work correctly, the input y0 must be a multiple of x0. If not, the function returns 0,\nindicating no valid pairs exist under the given constraints.",
      "es": "Cuenta el número de pares de enteros positivos (P, Q) tales que P y Q tienen x0 como su máximo común divisor (MCD) y y0 como su mínimo común múltiplo (mcm).\n\nArgumentos:\nx0 (int): El MCD que cada par (P, Q) debe tener.\ny0 (int): El mcm que cada par (P, Q) debe tener.\n\nDevuelve:\nint: La cuenta de todos los pares posibles (P, Q) que cumplen con los criterios especificados.\n\nLa función itera a través de todos los posibles factores 'a' del cociente 'y0 / x0'. Para cada factor 'a', calcula el factor correspondiente 'b' tal que 'a * b = y0 / x0'. Luego verifica si 'a' y 'b' son coprimos (su MCD es 1) porque P y Q solo pueden ser múltiplos de 'x0' por factores coprimos para mantener el MCD como 'x0'. Si 'a' y 'b' son coprimos, la cuenta se incrementa en 1 si 'a' es igual a 'b', de lo contrario en 2 para contar ambos pares (P, Q) y (Q, P).\n\nCasos de Ejemplo:\n\nCaso 1: count_coprime_pairs(3, 60) Explicación: La función devolvería 4, ya que los pares válidos son (3, 60), (15, 12), (12, 15), y (60, 3).\n\nCaso 2: count_coprime_pairs(2, 50) Explicación: La función devolvería 0, ya que 50 no es múltiplo de 2, por lo que no hay pares válidos (P, Q).\n\nCaso 3: count_coprime_pairs(6, 180) Explicación: La función devolvería 8, los pares válidos son (6, 180), (30, 36), (18, 60), (42, 30), (60, 18), (36, 30), (180, 6), y las cuentas para otras disposiciones de estos números.\n\nNota: Para que la función funcione correctamente, la entrada y0 debe ser un múltiplo de x0. Si no, la función devuelve 0, indicando que no existen pares válidos bajo las restricciones dadas.",
      "arb": "يحسب عدد أزواج الأعداد الصحيحة الموجبة (P, Q) بحيث يكون P و Q لهما x0 كأكبر قاسم مشترك (GCD) و y0 كأصغر مضاعف مشترك (LCM).\n\nيعيدالحجج:\nx0 (int): القاسم المشترك الأكبر الذي يجب أن يكون لكل زوج (P, Q).\ny0 (int): المضاعف المشترك الأصغر الذي يجب أن يكون لكل زوج (P, Q).\n\nيعيد:\nint: عدد جميع الأزواج الممكنة (P, Q) التي تفي بالمعايير المحددة.\n\nتقوم الدالة بالتكرار عبر جميع العوامل الممكنة 'a' للناتج 'y0 / x0'. لكل عامل 'a'،\nتحسب العامل المقابل 'b' بحيث يكون 'a * b = y0 / x0'. ثم تتحقق مما إذا كان 'a' و 'b'\nمتباينين (القاسم المشترك الأكبر لهما هو 1) لأن P و Q يمكن أن يكونا فقط مضاعفات 'x0' بعوامل متباينة للحفاظ\nعلى القاسم المشترك الأكبر كـ 'x0'. إذا كان 'a' و 'b' متباينين، يتم زيادة العداد بمقدار 1 إذا كان 'a' هو نفسه 'b',\nوإلا بمقدار 2 لحساب كلا الزوجين (P, Q) و (Q, P).\n\nحالات المثال:\n\nالحالة 1: count_coprime_pairs(3, 60)\nالتفسير: ستعيد الدالة 4، حيث أن الأزواج الصالحة هي (3, 60)، (15, 12)، (12, 15)، و (60, 3).\n\nالحالة 2: count_coprime_pairs(2, 50)\nالتفسير: ستعيد الدالة 0، حيث أن 50 ليس مضاعفًا لـ 2، لذلك لا توجد أزواج صالحة (P, Q).\n\nالحالة 3: count_coprime_pairs(6, 180)\nالتفسير: ستعيد الدالة 8، الأزواج الصالحة هي (6, 180)، (30, 36)، (18, 60)، (42, 30)،\n(60, 18)، (36, 30)، (180, 6)، والحسابات لترتيبات أخرى لهذه الأرقام.\n\nملاحظة:\nلكي تعمل الدالة بشكل صحيح، يجب أن يكون المدخل y0 مضاعفًا لـ x0. إذا لم يكن كذلك، فإن الدالة تعيد 0،\nمما يشير إلى عدم وجود أزواج صالحة تحت القيود المعطاة.",
      "sw": "Hesabu idadi ya jozi za nambari nzima chanya (P, Q) ambapo P na Q wana x0 kama mgawanyiko wao mkubwa zaidi (GCD) na y0 kama kichelezo chao kidogo zaidi (LCM).\n\nHoja:\nx0 (int): GCD ambayo kila jozi (P, Q) lazima iwe nayo.\ny0 (int): LCM ambayo kila jozi (P, Q) lazima iwe nayo.\n\nInarejesha:\nint: Hesabu ya jozi zote zinazowezekana (P, Q) zinazokidhi vigezo vilivyobainishwa.\n\nKazi inarudia kupitia vipengele vyote vinavyowezekana 'a' vya sehemu 'y0 / x0'. Kwa kila kipengele 'a', inahesabu kipengele kinacholingana 'b' kama 'a * b = y0 / x0'. Kisha inakagua kama 'a' na 'b' ni co-prime (GCD yao ni 1) kwa sababu P na Q zinaweza kuwa tu vipande vya 'x0' kwa vipengele vya co-prime ili kudumisha GCD kama 'x0'. Ikiwa 'a' na 'b' ni co-prime, hesabu inaongezwa kwa 1 ikiwa 'a' ni sawa na 'b', vinginevyo kwa 2 ili kuzingatia jozi zote mbili (P, Q) na (Q, P).\n\nMfano wa Kesi:\n\nKesi 1: count_coprime_pairs(3, 60)\nMaelezo: Kazi itarudisha 4, kwa kuwa jozi halali ni (3, 60), (15, 12), (12, 15), na (60, 3).\n\nKesi 2: count_coprime_pairs(2, 50)\nMaelezo: Kazi itarudisha 0, kwa kuwa 50 si kipande cha 2, hivyo hakuna jozi halali (P, Q).\n\nKesi 3: count_coprime_pairs(6, 180)\nMaelezo: Kazi itarudisha 8, jozi halali ni (6, 180), (30, 36), (18, 60), (42, 30), (60, 18), (36, 30), (180, 6), na hesabu za mipangilio mingine ya nambari hizi.\n\nKumbuka:\nIli kazi ifanye kazi kwa usahihi, ingizo y0 lazima liwe kipande cha x0. Ikiwa sivyo, kazi inarudisha 0, ikionyesha hakuna jozi halali zilizopo chini ya vikwazo vilivyotolewa.",
      "tr": "Pozitif tam sayı çiftlerinin (P, Q) sayısını sayar, öyle ki P ve Q'nun en büyük ortak böleni (GCD) x0 ve en küçük ortak katı (LCM) y0'dır.\n\nArgümanlar:\nx0 (int): Her çiftin (P, Q) sahip olması gereken GCD.\ny0 (int): Her çiftin (P, Q) sahip olması gereken LCM.\n\nDöndürür:\nint: Belirtilen kriterleri karşılayan tüm olası çiftlerin (P, Q) sayısı.\n\nFonksiyon, 'y0 / x0' bölümünün tüm olası çarpanları 'a' üzerinden iterasyon yapar. Her çarpan 'a' için,\n'a * b = y0 / x0' olacak şekilde karşılık gelen çarpan 'b'yi hesaplar. Daha sonra 'a' ve 'b'nin\nortak asal olup olmadığını (GCD'leri 1 ise) kontrol eder çünkü P ve Q, GCD'yi 'x0' olarak korumak için\nsadece asal çarpanlarla 'x0'ün katları olabilir. Eğer 'a' ve 'b' ortak asal ise, 'a' ve 'b' aynıysa\nsayı 1 artırılır, aksi takdirde hem (P, Q) hem de (Q, P) çiftlerini hesaba katmak için 2 artırılır.\n\nÖrnek Durumlar:\n\nDurum 1: count_coprime_pairs(3, 60)\nAçıklama: Fonksiyon 4 döndürecektir, çünkü geçerli çiftler (3, 60), (15, 12), (12, 15) ve (60, 3)'tür.\n\nDurum 2: count_coprime_pairs(2, 50)\nAçıklama: Fonksiyon 0 döndürecektir, çünkü 50, 2'nin katı değildir, bu yüzden geçerli çiftler (P, Q) yoktur.\n\nDurum 3: count_coprime_pairs(6, 180)\nAçıklama: Fonksiyon 8 döndürecektir, geçerli çiftler (6, 180), (30, 36), (18, 60), (42, 30),\n(60, 18), (36, 30), (180, 6) ve bu sayıların diğer düzenlemeleri için sayılar.\n\nNot:\nFonksiyonun doğru çalışabilmesi için, giriş y0, x0'ın bir katı olmalıdır. Aksi takdirde, fonksiyon 0 döndürür,\nbu da verilen kısıtlar altında geçerli çiftlerin olmadığını belirtir.",
      "vi": "Đếm số cặp số nguyên dương (P, Q) sao cho P và Q có x0 là ước chung lớn nhất (GCD) của chúng\nvà y0 là bội chung nhỏ nhất (LCM) của chúng.\n\nTham số:\nx0 (int): GCD mà mỗi cặp (P, Q) phải có.\ny0 (int): LCM mà mỗi cặp (P, Q) phải có.\n\nTrả về:\nint: Số lượng tất cả các cặp (P, Q) có thể đáp ứng tiêu chí đã chỉ định.\n\nHàm lặp qua tất cả các ước số có thể 'a' của thương số 'y0 / x0'. Đối với mỗi ước số 'a',\nnó tính toán ước số tương ứng 'b' sao cho 'a * b = y0 / x0'. Sau đó, nó kiểm tra nếu 'a' và 'b'\nlà số nguyên tố cùng nhau (GCD của chúng là 1) vì P và Q chỉ có thể là bội số của 'x0' bởi các ước số nguyên tố cùng nhau để duy trì\nGCD là 'x0'. Nếu 'a' và 'b' là số nguyên tố cùng nhau, số đếm được tăng lên 1 nếu 'a' giống như 'b',\nnếu không thì tăng lên 2 để tính cho cả cặp (P, Q) và (Q, P).\n\nVí dụ các trường hợp:\n\nTrường hợp 1: count_coprime_pairs(3, 60)\nGiải thích: Hàm sẽ trả về 4, vì các cặp hợp lệ là (3, 60), (15, 12), (12, 15), và (60, 3).\n\nTrường hợp 2: count_coprime_pairs(2, 50)\nGiải thích: Hàm sẽ trả về 0, vì 50 không phải là bội số của 2, do đó không có cặp hợp lệ (P, Q).\n\nTrường hợp 3: count_coprime_pairs(6, 180)\nGiải thích: Hàm sẽ trả về 8, các cặp hợp lệ là (6, 180), (30, 36), (18, 60), (42, 30),\n(60, 18), (36, 30), (180, 6), và số đếm cho các sắp xếp khác của các số này.\n\nLưu ý:\nĐể hàm hoạt động chính xác, đầu vào y0 phải là bội số của x0. Nếu không, hàm trả về 0,\ncho biết không có cặp hợp lệ nào tồn tại dưới các ràng buộc đã cho."
    },
    "docstring_bertscore": {
      "es": "0.9776872534072079",
      "arb": "0.9513145018260627",
      "sw": "0.9692267909574078",
      "tr": "0.959457354296588",
      "vi": "0.962321207130349"
    }
  },
  {
    "task_id": "Python/27",
    "prompt": {
      "en": "def preorder_traversal(inorder: str, postorder: str) -> str:\n    \"\"\"\n    Reconstructs the binary tree from its inorder and postorder traversals and\n    returns the preorder traversal as a string.\n\n    Args:\n    inorder (str): The inorder traversal of the binary tree.\n    postorder (str): The postorder traversal of the binary tree.\n\n    Returns:\n    str: The preorder traversal of the binary tree.\n\n    Cases:\n    - If both inorder and postorder traversals are empty, returns an empty string.\n    - If the tree consists of a single node, returns a string with that single node.\n    - For a larger tree, recursively finds the root from the postorder traversal,\n      splits the inorder traversal into left and right subtrees, and constructs\n      the preorder traversal by visiting the root followed by the left and right\n      subtrees.\n\n    Example:\n    - Given inorder traversal 'BADC' and postorder traversal 'BDCA', the function\n      will return the preorder traversal 'ABCD'.\n    - Given inorder traversal 'DBGEACF' and postorder traversal 'DGEBFCA', the function\n      will return the preorder traversal 'ABDEGCF'.\n    - Given a tree with a single node represented by the inorder and postorder traversal 'A',\n      the function will return 'A'.\n    \"\"\"",
      "es": "def preorder_traversal(inorder: str, postorder: str) -> str:\n    \"\"\"\n    Reconstruye el árbol binario a partir de sus recorridos inorder y postorder y\n    devuelve el recorrido preorder como una cadena.\n\n    Argumentos:\n    inorder (str): El recorrido inorder del árbol binario.\n    postorder (str): El recorrido postorder del árbol binario.\n\n    Devuelve:\n    str: El recorrido preorder del árbol binario.\n\n    Casos:\n    - Si ambos recorridos inorder y postorder están vacíos, devuelve una cadena vacía.\n    - Si el árbol consiste en un solo nodo, devuelve una cadena con ese único nodo.\n    - Para un árbol más grande, encuentra recursivamente la raíz a partir del recorrido postorder,\n      divide el recorrido inorder en subárboles izquierdo y derecho, y construye\n      el recorrido preorder visitando la raíz seguida de los subárboles izquierdo y derecho.\n\n    Ejemplo:\n    - Dado el recorrido inorder 'BADC' y el recorrido postorder 'BDCA', la función\n      devolverá el recorrido preorder 'ABCD'.\n    - Dado el recorrido inorder 'DBGEACF' y el recorrido postorder 'DGEBFCA', la función\n      devolverá el recorrido preorder 'ABDEGCF'.\n    - Dado un árbol con un solo nodo representado por el recorrido inorder y postorder 'A',\n      la función devolverá 'A'.\n    \"\"\"",
      "arb": "def preorder_traversal(inorder: str, postorder: str) -> str:\n    \"\"\"\n    يعيد بناء الشجرة الثنائية من ترتيباتها الوسطى وبعد الترتيب\n    ويعيد ترتيب ما قبل الترتيب كسلسلة نصية.\n\n    يعيدالحجج:\n    inorder (str): الترتيب الوسطي للشجرة الثنائية.\n    postorder (str): الترتيب بعدي للشجرة الثنائية.\n\n    يعيد:\n    str: الترتيب القبلي للشجرة الثنائية.\n\n    حالات:\n    - إذا كانت ترتيبات الوسط وبعد الترتيب فارغة، يعيد سلسلة نصية فارغة.\n    - إذا كانت الشجرة تتكون من عقدة واحدة، يعيد سلسلة تحتوي على تلك العقدة الوحيدة.\n    - بالنسبة لشجرة أكبر، يجد الجذر بشكل متكرر من ترتيب ما بعد الترتيب،\n      يقسم ترتيب الوسط إلى أشجار فرعية يسارية ويمينية، ويبني\n      الترتيب القبلي بزيارة الجذر يليه الأشجار الفرعية اليسارية واليمينية.\n\n    مثال:\n    - بالنظر إلى الترتيب الوسطي 'BADC' والترتيب بعدي 'BDCA'، ستعيد الدالة\n      الترتيب القبلي 'ABCD'.\n    - بالنظر إلى الترتيب الوسطي 'DBGEACF' والترتيب بعدي 'DGEBFCA'، ستعيد الدالة\n      الترتيب القبلي 'ABDEGCF'.\n    - بالنظر إلى شجرة تحتوي على عقدة واحدة ممثلة بالترتيب الوسطي والترتيب بعدي 'A',\n      ستعيد الدالة 'A'.\n    \"\"\"",
      "sw": "def preorder_traversal(inorder: str, postorder: str) -> str:\n    \"\"\"\n    Inajenga upya mti wa binary kutoka kwa mfuatano wake wa inorder na postorder na\n    inarudisha mfuatano wa preorder kama kamba.\n\n    Hoja:\n    inorder (str): Mfuatano wa inorder wa mti wa binary.\n    postorder (str): Mfuatano wa postorder wa mti wa binary.\n\n    Inarejesha:\n    str: Mfuatano wa preorder wa mti wa binary.\n\n    Matukio:\n    - Ikiwa mfuatano wa inorder na postorder ni tupu, inarudisha kamba tupu.\n    - Ikiwa mti unajumuisha nodi moja tu, inarudisha kamba yenye nodi hiyo moja.\n    - Kwa mti mkubwa, hupata mizizi kwa kurudia kutoka kwa mfuatano wa postorder,\n      hugawanya mfuatano wa inorder katika miti midogo ya kushoto na kulia, na hujenga\n      mfuatano wa preorder kwa kutembelea mizizi ikifuatiwa na miti midogo ya kushoto na kulia.\n\n    Mfano:\n    - Ukipewa mfuatano wa inorder 'BADC' na mfuatano wa postorder 'BDCA', kazi\n      itarudisha mfuatano wa preorder 'ABCD'.\n    - Ukipewa mfuatano wa inorder 'DBGEACF' na mfuatano wa postorder 'DGEBFCA', kazi\n      itarudisha mfuatano wa preorder 'ABDEGCF'.\n    - Ukipewa mti wenye nodi moja inayowakilishwa na mfuatano wa inorder na postorder 'A',\n      kazi itarudisha 'A'.\n    \"\"\"",
      "tr": "def preorder_traversal(inorder: str, postorder: str) -> str:\n    \"\"\"\n    İkili ağacı inorder ve postorder sıralamalarından yeniden oluşturur ve\n    preorder sıralamasını bir dize olarak döndürür.\n\n    Argümanlar:\n    inorder (str): İkili ağacın inorder sıralaması.\n    postorder (str): İkili ağacın postorder sıralaması.\n\n    Döndürür:\n    str: İkili ağacın preorder sıralaması.\n\n    Durumlar:\n    - Eğer hem inorder hem de postorder sıralamaları boşsa, boş bir dize döndürür.\n    - Eğer ağaç tek bir düğümden oluşuyorsa, o tek düğümle bir dize döndürür.\n    - Daha büyük bir ağaç için, postorder sıralamasından kökü bulur,\n      inorder sıralamasını sol ve sağ alt ağaçlara böler ve\n      kökü ziyaret ederek, ardından sol ve sağ alt ağaçları ziyaret ederek\n      preorder sıralamasını oluşturur.\n\n    Örnek:\n    - 'BADC' inorder sıralaması ve 'BDCA' postorder sıralaması verildiğinde, fonksiyon\n      'ABCD' preorder sıralamasını döndürecektir.\n    - 'DBGEACF' inorder sıralaması ve 'DGEBFCA' postorder sıralaması verildiğinde, fonksiyon\n      'ABDEGCF' preorder sıralamasını döndürecektir.\n    - 'A' inorder ve postorder sıralaması ile temsil edilen tek bir düğümden oluşan bir ağaç verildiğinde,\n      fonksiyon 'A' döndürecektir.\n    \"\"\"",
      "vi": "def preorder_traversal(inorder: str, postorder: str) -> str:\n    \"\"\"\n    Tái cấu trúc cây nhị phân từ các duyệt inorder và postorder của nó và\n    trả về duyệt preorder dưới dạng một chuỗi.\n\n    Tham số:\n    inorder (str): Duyệt inorder của cây nhị phân.\n    postorder (str): Duyệt postorder của cây nhị phân.\n\n    Trả về:\n    str: Duyệt preorder của cây nhị phân.\n\n    Trường hợp:\n    - Nếu cả hai duyệt inorder và postorder đều trống, trả về một chuỗi trống.\n    - Nếu cây bao gồm một nút duy nhất, trả về một chuỗi với nút duy nhất đó.\n    - Đối với một cây lớn hơn, đệ quy tìm gốc từ duyệt postorder,\n      chia duyệt inorder thành các cây con trái và phải, và xây dựng\n      duyệt preorder bằng cách thăm gốc theo sau bởi các cây con trái và phải.\n\n    Ví dụ:\n    - Cho duyệt inorder 'BADC' và duyệt postorder 'BDCA', hàm sẽ\n      trả về duyệt preorder 'ABCD'.\n    - Cho duyệt inorder 'DBGEACF' và duyệt postorder 'DGEBFCA', hàm sẽ\n      trả về duyệt preorder 'ABDEGCF'.\n    - Cho một cây với một nút duy nhất được biểu diễn bởi duyệt inorder và postorder 'A',\n      hàm sẽ trả về 'A'.\n    \"\"\""
    },
    "prompt_bertscore": {
      "es": "0.9902110975618387",
      "arb": "0.9166971990193024",
      "sw": "0.9064895837379194",
      "tr": "0.9377587728419557",
      "vi": "0.9748090991860123"
    },
    "canonical_solution": "    # Base case: if the traversals are empty, return an empty string\n    if not inorder or not postorder:\n        return \"\"\n    \n    # The root is always the last element in postorder traversal\n    root = postorder[-1]\n    \n    # Index of root in inorder traversal\n    root_index = inorder.index(root)\n    \n    # Recursively find the preorder traversal\n    # Left subtree: from start to root_index in inorder, and the corresponding elements in postorder\n    # Right subtree: from root_index + 1 to end in inorder, and the corresponding elements in postorder\n    # Note: The corresponding elements in postorder are found by excluding the last element (root) and adjusting the length\n    left_preorder = preorder_traversal(inorder[:root_index], postorder[:root_index])\n    right_preorder = preorder_traversal(inorder[root_index+1:], postorder[root_index:-1])\n    \n    # Construct the preorder traversal: root + left subtree + right subtree\n    return root + left_preorder + right_preorder",
    "instruction": {
      "en": "def preorder_traversal(inorder: str, postorder: str) -> str:\n    # Base case: if the traversals are empty, return an empty string\n    if not inorder or not postorder:\n        return \"\"\n    \n    # The root is always the last element in postorder traversal\n    root = postorder[-1]\n    \n    # Index of root in inorder traversal\n    root_index = inorder.index(root)\n    \n    # Recursively find the preorder traversal\n    # Left subtree: from start to root_index in inorder, and the corresponding elements in postorder\n    # Right subtree: from root_index + 1 to end in inorder, and the corresponding elements in postorder\n    # Note: The corresponding elements in postorder are found by excluding the last element (root) and adjusting the length\n    left_preorder = preorder_traversal(inorder[:root_index], postorder[:root_index])\n    right_preorder = preorder_traversal(inorder[root_index+1:], postorder[root_index:-1])\n    \n    # Construct the preorder traversal: root + left subtree + right subtree\n    return root + left_preorder + right_preorder\n\nProvide a concise natural language description (docstring) of the Python code in English using at most 500 characters.",
      "es": "def preorder_traversal(inorder: str, postorder: str) -> str:\n    # Base case: if the traversals are empty, return an empty string\n    if not inorder or not postorder:\n        return \"\"\n    \n    # The root is always the last element in postorder traversal\n    root = postorder[-1]\n    \n    # Index of root in inorder traversal\n    root_index = inorder.index(root)\n    \n    # Recursively find the preorder traversal\n    # Left subtree: from start to root_index in inorder, and the corresponding elements in postorder\n    # Right subtree: from root_index + 1 to end in inorder, and the corresponding elements in postorder\n    # Note: The corresponding elements in postorder are found by excluding the last element (root) and adjusting the length\n    left_preorder = preorder_traversal(inorder[:root_index], postorder[:root_index])\n    right_preorder = preorder_traversal(inorder[root_index+1:], postorder[root_index:-1])\n    \n    # Construct the preorder traversal: root + left subtree + right subtree\n    return root + left_preorder + right_preorder\n\nProporciona una descripción concisa en lenguaje natural (docstring) del código Python en español utilizando como máximo 500 caracteres.",
      "arb": "def preorder_traversal(inorder: str, postorder: str) -> str:\n    # Base case: if the traversals are empty, return an empty string\n    if not inorder or not postorder:\n        return \"\"\n    \n    # The root is always the last element in postorder traversal\n    root = postorder[-1]\n    \n    # Index of root in inorder traversal\n    root_index = inorder.index(root)\n    \n    # Recursively find the preorder traversal\n    # Left subtree: from start to root_index in inorder, and the corresponding elements in postorder\n    # Right subtree: from root_index + 1 to end in inorder, and the corresponding elements in postorder\n    # Note: The corresponding elements in postorder are found by excluding the last element (root) and adjusting the length\n    left_preorder = preorder_traversal(inorder[:root_index], postorder[:root_index])\n    right_preorder = preorder_traversal(inorder[root_index+1:], postorder[root_index:-1])\n    \n    # Construct the preorder traversal: root + left subtree + right subtree\n    return root + left_preorder + right_preorder\n\nيرجى تقديم وصف موجز بلغة طبيعية (docstring) للشفرة البرمجية بلغة بايثون باللغة العربية الفصحى باستخدام 500 حرف كحد أقصى.",
      "sw": "def preorder_traversal(inorder: str, postorder: str) -> str:\n    # Base case: if the traversals are empty, return an empty string\n    if not inorder or not postorder:\n        return \"\"\n    \n    # The root is always the last element in postorder traversal\n    root = postorder[-1]\n    \n    # Index of root in inorder traversal\n    root_index = inorder.index(root)\n    \n    # Recursively find the preorder traversal\n    # Left subtree: from start to root_index in inorder, and the corresponding elements in postorder\n    # Right subtree: from root_index + 1 to end in inorder, and the corresponding elements in postorder\n    # Note: The corresponding elements in postorder are found by excluding the last element (root) and adjusting the length\n    left_preorder = preorder_traversal(inorder[:root_index], postorder[:root_index])\n    right_preorder = preorder_traversal(inorder[root_index+1:], postorder[root_index:-1])\n    \n    # Construct the preorder traversal: root + left subtree + right subtree\n    return root + left_preorder + right_preorder\n\nToa maelezo mafupi ya lugha asilia (docstring) ya msimbo wa Python kwa Kiswahili kwa kutumia herufi zisizozidi 500.",
      "tr": "def preorder_traversal(inorder: str, postorder: str) -> str:\n    # Base case: if the traversals are empty, return an empty string\n    if not inorder or not postorder:\n        return \"\"\n    \n    # The root is always the last element in postorder traversal\n    root = postorder[-1]\n    \n    # Index of root in inorder traversal\n    root_index = inorder.index(root)\n    \n    # Recursively find the preorder traversal\n    # Left subtree: from start to root_index in inorder, and the corresponding elements in postorder\n    # Right subtree: from root_index + 1 to end in inorder, and the corresponding elements in postorder\n    # Note: The corresponding elements in postorder are found by excluding the last element (root) and adjusting the length\n    left_preorder = preorder_traversal(inorder[:root_index], postorder[:root_index])\n    right_preorder = preorder_traversal(inorder[root_index+1:], postorder[root_index:-1])\n    \n    # Construct the preorder traversal: root + left subtree + right subtree\n    return root + left_preorder + right_preorder\n\nVerilen Python kodunun işlevini açıklayan, en fazla 500 karakter uzunluğunda özlü bir doğal dil açıklaması (docstring) sağlayın.",
      "vi": "def preorder_traversal(inorder: str, postorder: str) -> str:\n    # Base case: if the traversals are empty, return an empty string\n    if not inorder or not postorder:\n        return \"\"\n    \n    # The root is always the last element in postorder traversal\n    root = postorder[-1]\n    \n    # Index of root in inorder traversal\n    root_index = inorder.index(root)\n    \n    # Recursively find the preorder traversal\n    # Left subtree: from start to root_index in inorder, and the corresponding elements in postorder\n    # Right subtree: from root_index + 1 to end in inorder, and the corresponding elements in postorder\n    # Note: The corresponding elements in postorder are found by excluding the last element (root) and adjusting the length\n    left_preorder = preorder_traversal(inorder[:root_index], postorder[:root_index])\n    right_preorder = preorder_traversal(inorder[root_index+1:], postorder[root_index:-1])\n    \n    # Construct the preorder traversal: root + left subtree + right subtree\n    return root + left_preorder + right_preorder\n\nCung cấp mô tả ngắn gọn bằng ngôn ngữ tự nhiên (docstring) cho mã Python bằng tiếng Việt, sử dụng tối đa 500 ký tự."
    },
    "instruction_bertscore": {
      "es": "0.9687387561112052",
      "arb": "0.924699818440817",
      "sw": "0.9426438884331277",
      "tr": "0.8508820154152974",
      "vi": "0.9256256346468206"
    },
    "level": "",
    "test": "def test_preorder_traversal():\n    # Test case 1\n    inorder1 = \"BADC\"\n    postorder1 = \"BDCA\"\n    expected_preorder1 = \"ABCD\"\n    assert preorder_traversal(inorder1, postorder1) == expected_preorder1\n    print(f\"Test case 1 passed. Preorder: {preorder_traversal(inorder1, postorder1)}\")\n\n    # Test case 2\n    inorder2 = \"DBGEACF\"\n    postorder2 = \"DGEBFCA\"\n    expected_preorder2 = \"ABDEGCF\"\n    assert preorder_traversal(inorder2, postorder2) == expected_preorder2\n    print(f\"Test case 2 passed. Preorder: {preorder_traversal(inorder2, postorder2)}\")\n\n    # Test case 3\n    inorder3 = \"A\"\n    postorder3 = \"A\"\n    expected_preorder3 = \"A\"\n    assert preorder_traversal(inorder3, postorder3) == expected_preorder3\n    print(f\"Test case 3 passed. Preorder: {preorder_traversal(inorder3, postorder3)}\")\n\n# Run the test function\ntest_preorder_traversal()",
    "entry_point": "preorder_traversal",
    "signature": "def preorder_traversal(inorder: str, postorder: str) -> str:",
    "docstring": {
      "en": "Reconstructs the binary tree from its inorder and postorder traversals and\nreturns the preorder traversal as a string.\n\nArgs:\ninorder (str): The inorder traversal of the binary tree.\npostorder (str): The postorder traversal of the binary tree.\n\nReturns:\nstr: The preorder traversal of the binary tree.\n\nCases:\n- If both inorder and postorder traversals are empty, returns an empty string.\n- If the tree consists of a single node, returns a string with that single node.\n- For a larger tree, recursively finds the root from the postorder traversal,\nsplits the inorder traversal into left and right subtrees, and constructs\nthe preorder traversal by visiting the root followed by the left and right\nsubtrees.\n\nExample:\n- Given inorder traversal 'BADC' and postorder traversal 'BDCA', the function\nwill return the preorder traversal 'ABCD'.\n- Given inorder traversal 'DBGEACF' and postorder traversal 'DGEBFCA', the function\nwill return the preorder traversal 'ABDEGCF'.\n- Given a tree with a single node represented by the inorder and postorder traversal 'A',\nthe function will return 'A'.",
      "es": "Reconstruye el árbol binario a partir de sus recorridos inorder y postorder y\ndevuelve el recorrido preorder como una cadena.\n\nArgumentos:\ninorder (str): El recorrido inorder del árbol binario.\npostorder (str): El recorrido postorder del árbol binario.\n\nDevuelve:\nstr: El recorrido preorder del árbol binario.\n\nCasos:\n- Si ambos recorridos inorder y postorder están vacíos, devuelve una cadena vacía.\n- Si el árbol consta de un solo nodo, devuelve una cadena con ese único nodo.\n- Para un árbol más grande, encuentra recursivamente la raíz a partir del recorrido postorder,\ndivide el recorrido inorder en subárboles izquierdo y derecho, y construye\nel recorrido preorder visitando la raíz seguida por los subárboles izquierdo y derecho.\n\nEjemplo:\n- Dado el recorrido inorder 'BADC' y el recorrido postorder 'BDCA', la función\ndevolverá el recorrido preorder 'ABCD'.\n- Dado el recorrido inorder 'DBGEACF' y el recorrido postorder 'DGEBFCA', la función\ndevolverá el recorrido preorder 'ABDEGCF'.\n- Dado un árbol con un solo nodo representado por el recorrido inorder y postorder 'A',\nla función devolverá 'A'.",
      "arb": "يعيد بناء الشجرة الثنائية من ترتيبها الوسطي وترتيبها اللاحق ويعيد ترتيبها القبلي كسلسلة نصية.\n\nالمعطيات:\ninorder (str): الترتيب الوسطي للشجرة الثنائية.\npostorder (str): الترتيب اللاحق للشجرة الثنائية.\n\nالقيم المعادة:\nstr: الترتيب القبلي للشجرة الثنائية.\n\nالحالات:\n- إذا كانت كل من الترتيبات الوسطية واللاحقة فارغة، يعيد سلسلة نصية فارغة.\n- إذا كانت الشجرة تتكون من عقدة واحدة، يعيد سلسلة نصية تحتوي على تلك العقدة الوحيدة.\n- بالنسبة لشجرة أكبر، يجد الجذر بشكل متكرر من الترتيب اللاحق، ويقسم الترتيب الوسطي إلى أشجار فرعية يسرى ويمنى، ويقوم ببناء الترتيب القبلي بزيارة الجذر متبوعًا بالأشجار الفرعية اليسرى واليمنى.\n\nمثال:\n- بالنظر إلى الترتيب الوسطي 'BADC' والترتيب اللاحق 'BDCA'، ستعيد الدالة الترتيب القبلي 'ABCD'.\n- بالنظر إلى الترتيب الوسطي 'DBGEACF' والترتيب اللاحق 'DGEBFCA'، ستعيد الدالة الترتيب القبلي 'ABDEGCF'.\n- بالنظر إلى شجرة تحتوي على عقدة واحدة ممثلة بالترتيب الوسطي والترتيب اللاحق 'A'، ستعيد الدالة 'A'.",
      "sw": "Inajenga upya mti wa binary kutoka kwa mfuatano wake wa inorder na postorder na\ninarudisha mfuatano wa preorder kama kamba.\n\nHoja:\ninorder (str): Mfuatano wa inorder wa mti wa binary.\npostorder (str): Mfuatano wa postorder wa mti wa binary.\n\nInarejesha:\nstr: Mfuatano wa preorder wa mti wa binary.\n\nMatukio:\n- Ikiwa mfuatano wa inorder na postorder ni tupu, inarudisha kamba tupu.\n- Ikiwa mti unajumuisha nodi moja, inarudisha kamba yenye nodi hiyo moja.\n- Kwa mti mkubwa, hupata mzizi kutoka kwa mfuatano wa postorder,\nhugawanya mfuatano wa inorder katika miti midogo ya kushoto na kulia, na huunda\nmfuatano wa preorder kwa kutembelea mzizi ikifuatiwa na miti midogo ya kushoto na kulia.\n\nMfano:\n- Ukipewa mfuatano wa inorder 'BADC' na mfuatano wa postorder 'BDCA', kazi\nitarudisha mfuatano wa preorder 'ABCD'.\n- Ukipewa mfuatano wa inorder 'DBGEACF' na mfuatano wa postorder 'DGEBFCA', kazi\nitarudisha mfuatano wa preorder 'ABDEGCF'.\n- Ukipewa mti wenye nodi moja inayowakilishwa na mfuatano wa inorder na postorder 'A',\nkazi itarudisha 'A'.",
      "tr": "İkili ağacı inorder ve postorder geçişlerinden yeniden oluşturur ve\npreorder geçişini bir string olarak döndürür.\n\nArgümanlar:\ninorder (str): İkili ağacın inorder geçişi.\npostorder (str): İkili ağacın postorder geçişi.\n\nDöndürür:\nstr: İkili ağacın preorder geçişi.\n\nDurumlar:\n- Eğer hem inorder hem de postorder geçişleri boşsa, boş bir string döndürür.\n- Eğer ağaç tek bir düğümden oluşuyorsa, o tek düğümle bir string döndürür.\n- Daha büyük bir ağaç için, postorder geçişinden kökü özyinelemeli olarak bulur,\ninorder geçişini sol ve sağ alt ağaçlara böler ve\nkökü, ardından sol ve sağ alt ağaçları ziyaret ederek preorder geçişini oluşturur.\n\nÖrnek:\n- 'BADC' inorder geçişi ve 'BDCA' postorder geçişi verildiğinde, fonksiyon\npreorder geçişi olarak 'ABCD' döndürecektir.\n- 'DBGEACF' inorder geçişi ve 'DGEBFCA' postorder geçişi verildiğinde, fonksiyon\npreorder geçişi olarak 'ABDEGCF' döndürecektir.\n- 'A' inorder ve postorder geçişi ile temsil edilen tek bir düğümlü bir ağaç verildiğinde,\nfonksiyon 'A' döndürecektir.",
      "vi": "Tái tạo cây nhị phân từ các duyệt cây inorder và postorder của nó và trả về duyệt cây preorder dưới dạng chuỗi.\n\nTham số:\ninorder (str): Duyệt cây inorder của cây nhị phân.\npostorder (str): Duyệt cây postorder của cây nhị phân.\n\nTrả về:\nstr: Duyệt cây preorder của cây nhị phân.\n\nTrường hợp:\n- Nếu cả hai duyệt cây inorder và postorder đều rỗng, trả về một chuỗi rỗng.\n- Nếu cây bao gồm một nút duy nhất, trả về một chuỗi với nút duy nhất đó.\n- Đối với một cây lớn hơn, đệ quy tìm gốc từ duyệt cây postorder,\nchia duyệt cây inorder thành cây con trái và phải, và xây dựng\nduyệt cây preorder bằng cách thăm gốc tiếp theo là cây con trái và phải.\n\nVí dụ:\n- Cho duyệt cây inorder 'BADC' và duyệt cây postorder 'BDCA', hàm sẽ trả về duyệt cây preorder 'ABCD'.\n- Cho duyệt cây inorder 'DBGEACF' và duyệt cây postorder 'DGEBFCA', hàm sẽ trả về duyệt cây preorder 'ABDEGCF'.\n- Cho một cây với một nút duy nhất được biểu diễn bởi duyệt cây inorder và postorder 'A', hàm sẽ trả về 'A'."
    },
    "docstring_bertscore": {
      "es": "0.9853760368266874",
      "arb": "0.9486848342115418",
      "sw": "0.9021048180765743",
      "tr": "0.9424216210367498",
      "vi": "0.9741162764169626"
    }
  },
  {
    "task_id": "Python/28",
    "prompt": {
      "en": "from collections import deque\nfrom typing import Union\n\ndef string_transformation(A: str, B: str, rules: list) -> Union[int, str]:\n    \"\"\"\n    Perform string transformation from A to B using a set of transformation rules.\n\n    This function takes an initial string A and a target string B, along with a list\n    of transformation rules, and attempts to transform A into B using the rules.\n    A Breadth-First Search (BFS) algorithm is used to explore the possible transformations\n    up to a maximum of 10 steps. If A can be transformed into B within 10 steps, the function\n    returns the minimum number of steps required. If it's not possible, the function returns\n    \"NO ANSWER!\".\n\n    Parameters:\n    A (str): The initial string to be transformed.\n    B (str): The target string to be achieved.\n    rules (list of tuples): A list of transformation rules, where each rule is a tuple\n                            containing the source substring (to be replaced) and the\n                            target substring (to replace with).\n\n    Returns:\n    Union[int, str]: The minimum number of transformation steps if possible, otherwise \"NO ANSWER!\".\n\n    Examples:\n    Case 1:\n    A = \"abcd\", B = \"xyz\", rules = [(\"abc\", \"xu\"), (\"ud\", \"y\"), (\"y\", \"yz\")]\n    string_transformation(A, B, rules) should return 3.\n\n    Case 2:\n    A = \"aaa\", B = \"bbbb\", rules = [(\"a\", \"b\"), (\"aa\", \"bb\"), (\"aaa\", \"bbb\")]\n    string_transformation(A, B, rules) should return \"NO ANSWER!\" because transformation\n    is not possible within 10 steps.\n\n    Case 3:\n    A = \"abc\", B = \"xyz\", rules = [(\"a\", \"x\"), (\"b\", \"y\"), (\"c\", \"z\")]\n    string_transformation(A, B, rules) should return 3, as each character is replaced\n    individually.\n    \"\"\"",
      "es": "from collections import deque\nfrom typing import Union\n\ndef string_transformation(A: str, B: str, rules: list) -> Union[int, str]:\n    \"\"\"\n    Realiza la transformación de cadena de A a B utilizando un conjunto de reglas de transformación.\n\n    Esta función toma una cadena inicial A y una cadena objetivo B, junto con una lista\n    de reglas de transformación, e intenta transformar A en B usando las reglas.\n    Se utiliza un algoritmo de Búsqueda en Anchura (BFS) para explorar las posibles transformaciones\n    hasta un máximo de 10 pasos. Si A puede transformarse en B dentro de 10 pasos, la función\n    devuelve el número mínimo de pasos requeridos. Si no es posible, la función devuelve\n    \"NO ANSWER!\".\n\n    Parámetros:\n    A (str): La cadena inicial a transformar.\n    B (str): La cadena objetivo a alcanzar.\n    rules (list of tuples): Una lista de reglas de transformación, donde cada regla es una tupla\n                            que contiene la subcadena fuente (a ser reemplazada) y la\n                            subcadena objetivo (para reemplazar con).\n\n    Retorna:\n    Union[int, str]: El número mínimo de pasos de transformación si es posible, de lo contrario \"NO ANSWER!\".\n\n    Ejemplos:\n    Caso 1:\n    A = \"abcd\", B = \"xyz\", rules = [(\"abc\", \"xu\"), (\"ud\", \"y\"), (\"y\", \"yz\")]\n    string_transformation(A, B, rules) debería devolver 3.\n\n    Caso 2:\n    A = \"aaa\", B = \"bbbb\", rules = [(\"a\", \"b\"), (\"aa\", \"bb\"), (\"aaa\", \"bbb\")]\n    string_transformation(A, B, rules) debería devolver \"NO ANSWER!\" porque la transformación\n    no es posible dentro de 10 pasos.\n\n    Caso 3:\n    A = \"abc\", B = \"xyz\", rules = [(\"a\", \"x\"), (\"b\", \"y\"), (\"c\", \"z\")]\n    string_transformation(A, B, rules) debería devolver 3, ya que cada carácter se reemplaza\n    individualmente.\n    \"\"\"",
      "arb": "from collections import deque\nfrom typing import Union\n\ndef string_transformation(A: str, B: str, rules: list) -> Union[int, str]:\n    \"\"\"\n    تنفيذ تحويل سلسلة من A إلى B باستخدام مجموعة من قواعد التحويل.\n\n    تأخذ هذه الدالة سلسلة ابتدائية A وسلسلة هدف B، مع قائمة من قواعد التحويل،\n    وتحاول تحويل A إلى B باستخدام القواعد. يتم استخدام خوارزمية البحث بعرض أول\n    (BFS) لاستكشاف التحويلات الممكنة حتى حد أقصى 10 خطوات. إذا كان بالإمكان\n    تحويل A إلى B في غضون 10 خطوات، تُرجع الدالة الحد الأدنى لعدد الخطوات المطلوبة.\n    إذا لم يكن ذلك ممكنًا، تُرجع الدالة \"NO ANSWER!\".\n\n    المعلمات:\n    A (str): السلسلة الابتدائية التي سيتم تحويلها.\n    B (str): السلسلة الهدف التي يجب تحقيقها.\n    rules (list of tuples): قائمة بقواعد التحويل، حيث كل قاعدة هي زوج يحتوي\n                            على السلسلة الفرعية المصدر (التي سيتم استبدالها)\n                            والسلسلة الفرعية الهدف (التي سيتم الاستبدال بها).\n\n    العوائد:\n    Union[int, str]: الحد الأدنى لعدد خطوات التحويل إذا كان ممكنًا، وإلا \"NO ANSWER!\".\n\n    أمثلة:\n    الحالة 1:\n    A = \"abcd\", B = \"xyz\", rules = [(\"abc\", \"xu\"), (\"ud\", \"y\"), (\"y\", \"yz\")]\n    string_transformation(A, B, rules) يجب أن تُرجع 3.\n\n    الحالة 2:\n    A = \"aaa\", B = \"bbbb\", rules = [(\"a\", \"b\"), (\"aa\", \"bb\"), (\"aaa\", \"bbb\")]\n    string_transformation(A, B, rules) يجب أن تُرجع \"NO ANSWER!\" لأن التحويل\n    غير ممكن في غضون 10 خطوات.\n\n    الحالة 3:\n    A = \"abc\", B = \"xyz\", rules = [(\"a\", \"x\"), (\"b\", \"y\"), (\"c\", \"z\")]\n    string_transformation(A, B, rules) يجب أن تُرجع 3، حيث يتم استبدال كل حرف\n    على حدة.\n    \"\"\"",
      "sw": "from collections import deque\nfrom typing import Union\n\ndef string_transformation(A: str, B: str, rules: list) -> Union[int, str]:\n    \"\"\"\n    Fanya mabadiliko ya kamba kutoka A hadi B kwa kutumia seti ya sheria za mabadiliko.\n\n    Kazi hii inachukua kamba ya awali A na kamba lengwa B, pamoja na orodha\n    ya sheria za mabadiliko, na inajaribu kubadilisha A kuwa B kwa kutumia sheria hizo.\n    Algorithimu ya Utafutaji wa Upana Kwanza (BFS) inatumika kuchunguza mabadiliko yanayowezekana\n    hadi kiwango cha juu cha hatua 10. Ikiwa A inaweza kubadilishwa kuwa B ndani ya hatua 10,\n    kazi inarejesha idadi ndogo ya hatua zinazohitajika. Ikiwa haiwezekani, kazi inarejesha\n    \"NO ANSWER!\".\n\n    Vigezo:\n    A (str): Kamba ya awali inayopaswa kubadilishwa.\n    B (str): Kamba lengwa inayopaswa kufikiwa.\n    rules (orodha ya jozi): Orodha ya sheria za mabadiliko, ambapo kila sheria ni jozi\n                            inayojumuisha sehemu ya kamba ya chanzo (inayopaswa kubadilishwa) na\n                            sehemu ya kamba lengwa (ya kubadilisha nayo).\n\n    Inarejesha:\n    Union[int, str]: Idadi ndogo ya hatua za mabadiliko ikiwa inawezekana, vinginevyo \"NO ANSWER!\".\n\n    Mifano:\n    Kesi 1:\n    A = \"abcd\", B = \"xyz\", rules = [(\"abc\", \"xu\"), (\"ud\", \"y\"), (\"y\", \"yz\")]\n    string_transformation(A, B, rules) inapaswa kurejesha 3.\n\n    Kesi 2:\n    A = \"aaa\", B = \"bbbb\", rules = [(\"a\", \"b\"), (\"aa\", \"bb\"), (\"aaa\", \"bbb\")]\n    string_transformation(A, B, rules) inapaswa kurejesha \"NO ANSWER!\" kwa sababu mabadiliko\n    hayawezekani ndani ya hatua 10.\n\n    Kesi 3:\n    A = \"abc\", B = \"xyz\", rules = [(\"a\", \"x\"), (\"b\", \"y\"), (\"c\", \"z\")]\n    string_transformation(A, B, rules) inapaswa kurejesha 3, kwani kila herufi inabadilishwa\n    kibinafsi.\n    \"\"\"",
      "tr": "from collections import deque\nfrom typing import Union\n\ndef string_transformation(A: str, B: str, rules: list) -> Union[int, str]:\n    \"\"\"\n    A'yı B'ye bir dizi dönüşüm kuralı kullanarak dönüştürme işlemi yapar.\n\n    Bu fonksiyon, başlangıç dizgesi A ve hedef dizgesi B'yi, dönüşüm kuralları listesiyle birlikte alır\n    ve A'yı B'ye kuralları kullanarak dönüştürmeye çalışır. Olası dönüşümleri keşfetmek için\n    10 adımın maksimumuna kadar bir Genişlik Öncelikli Arama (BFS) algoritması kullanılır. \n    Eğer A, B'ye 10 adım içinde dönüştürülebilirse, fonksiyon gereken minimum adım sayısını döndürür. \n    Eğer mümkün değilse, fonksiyon \"NO ANSWER!\" döndürür.\n\n    Parametreler:\n    A (str): Dönüştürülecek başlangıç dizgesi.\n    B (str): Elde edilmesi gereken hedef dizgesi.\n    rules (list of tuples): Her kuralın kaynak alt dizgeyi (değiştirilecek) ve\n                            hedef alt dizgeyi (değiştirilecek olan) içeren bir liste.\n\n    Döndürür:\n    Union[int, str]: Mümkünse minimum dönüşüm adım sayısı, aksi takdirde \"NO ANSWER!\".\n\n    Örnekler:\n    Durum 1:\n    A = \"abcd\", B = \"xyz\", rules = [(\"abc\", \"xu\"), (\"ud\", \"y\"), (\"y\", \"yz\")]\n    string_transformation(A, B, rules) 3 döndürmelidir.\n\n    Durum 2:\n    A = \"aaa\", B = \"bbbb\", rules = [(\"a\", \"b\"), (\"aa\", \"bb\"), (\"aaa\", \"bbb\")]\n    string_transformation(A, B, rules) \"NO ANSWER!\" döndürmelidir çünkü dönüşüm\n    10 adım içinde mümkün değildir.\n\n    Durum 3:\n    A = \"abc\", B = \"xyz\", rules = [(\"a\", \"x\"), (\"b\", \"y\"), (\"c\", \"z\")]\n    string_transformation(A, B, rules) 3 döndürmelidir, çünkü her karakter\n    ayrı ayrı değiştirilir.\n    \"\"\"",
      "vi": "from collections import deque\nfrom typing import Union\n\ndef string_transformation(A: str, B: str, rules: list) -> Union[int, str]:\n    \"\"\"\n    Thực hiện chuyển đổi chuỗi từ A sang B bằng cách sử dụng một tập hợp các quy tắc chuyển đổi.\n\n    Hàm này nhận một chuỗi ban đầu A và một chuỗi mục tiêu B, cùng với một danh sách\n    các quy tắc chuyển đổi, và cố gắng chuyển đổi A thành B bằng cách sử dụng các quy tắc.\n    Thuật toán Tìm kiếm theo chiều rộng (BFS) được sử dụng để khám phá các chuyển đổi có thể\n    lên đến tối đa 10 bước. Nếu A có thể được chuyển đổi thành B trong vòng 10 bước, hàm sẽ\n    trả về số bước tối thiểu cần thiết. Nếu không thể, hàm sẽ trả về \"NO ANSWER!\".\n\n    Tham số:\n    A (str): Chuỗi ban đầu cần được chuyển đổi.\n    B (str): Chuỗi mục tiêu cần đạt được.\n    rules (list of tuples): Danh sách các quy tắc chuyển đổi, trong đó mỗi quy tắc là một tuple\n                            chứa chuỗi con nguồn (để được thay thế) và chuỗi con đích (để thay thế).\n\n    Trả về:\n    Union[int, str]: Số bước chuyển đổi tối thiểu nếu có thể, nếu không thì \"NO ANSWER!\".\n\n    Ví dụ:\n    Trường hợp 1:\n    A = \"abcd\", B = \"xyz\", rules = [(\"abc\", \"xu\"), (\"ud\", \"y\"), (\"y\", \"yz\")]\n    string_transformation(A, B, rules) nên trả về 3.\n\n    Trường hợp 2:\n    A = \"aaa\", B = \"bbbb\", rules = [(\"a\", \"b\"), (\"aa\", \"bb\"), (\"aaa\", \"bbb\")]\n    string_transformation(A, B, rules) nên trả về \"NO ANSWER!\" vì chuyển đổi\n    không thể thực hiện trong vòng 10 bước.\n\n    Trường hợp 3:\n    A = \"abc\", B = \"xyz\", rules = [(\"a\", \"x\"), (\"b\", \"y\"), (\"c\", \"z\")]\n    string_transformation(A, B, rules) nên trả về 3, vì mỗi ký tự được thay thế\n    riêng lẻ.\n    \"\"\""
    },
    "prompt_bertscore": {
      "es": "0.9875321696128211",
      "arb": "0.9846770565158256",
      "sw": "0.9899884329046985",
      "tr": "0.9743012013017062",
      "vi": "0.9914688251345516"
    },
    "canonical_solution": "\n    queue = deque([(A, 0)])  # Each element in the queue is a tuple (current_string, steps_taken)\n    visited = set([A])  # Keep track of visited strings to avoid loops\n\n    # Perform BFS\n    while queue:\n        current, steps = queue.popleft()\n        if current == B:\n            return steps  # Found the target string\n        if steps == 10:\n            continue  # Stop if already taken 10 steps\n        for source, target in rules:\n            index = current.find(source)\n            while index != -1:\n                # Apply the transformation\n                next_string = current[:index] + target + current[index + len(source):]\n                if next_string not in visited:\n                    visited.add(next_string)\n                    queue.append((next_string, steps + 1))\n                index = current.find(source, index + 1)\n    return \"NO ANSWER!\"",
    "instruction": {
      "en": "def string_transformation(A: str, B: str, rules: list) -> Union[int, str]:\n\n    queue = deque([(A, 0)])  # Each element in the queue is a tuple (current_string, steps_taken)\n    visited = set([A])  # Keep track of visited strings to avoid loops\n\n    # Perform BFS\n    while queue:\n        current, steps = queue.popleft()\n        if current == B:\n            return steps  # Found the target string\n        if steps == 10:\n            continue  # Stop if already taken 10 steps\n        for source, target in rules:\n            index = current.find(source)\n            while index != -1:\n                # Apply the transformation\n                next_string = current[:index] + target + current[index + len(source):]\n                if next_string not in visited:\n                    visited.add(next_string)\n                    queue.append((next_string, steps + 1))\n                index = current.find(source, index + 1)\n    return \"NO ANSWER!\"\n\nProvide a concise natural language description (docstring) of the Python code in English using at most 500 characters.",
      "es": "def string_transformation(A: str, B: str, rules: list) -> Union[int, str]:\n\n    queue = deque([(A, 0)])  # Each element in the queue is a tuple (current_string, steps_taken)\n    visited = set([A])  # Keep track of visited strings to avoid loops\n\n    # Perform BFS\n    while queue:\n        current, steps = queue.popleft()\n        if current == B:\n            return steps  # Found the target string\n        if steps == 10:\n            continue  # Stop if already taken 10 steps\n        for source, target in rules:\n            index = current.find(source)\n            while index != -1:\n                # Apply the transformation\n                next_string = current[:index] + target + current[index + len(source):]\n                if next_string not in visited:\n                    visited.add(next_string)\n                    queue.append((next_string, steps + 1))\n                index = current.find(source, index + 1)\n    return \"NO ANSWER!\"\n\nProporcione una descripción concisa en lenguaje natural (docstring) del código Python en español utilizando un máximo de 500 caracteres.",
      "arb": "def string_transformation(A: str, B: str, rules: list) -> Union[int, str]:\n\n    queue = deque([(A, 0)])  # Each element in the queue is a tuple (current_string, steps_taken)\n    visited = set([A])  # Keep track of visited strings to avoid loops\n\n    # Perform BFS\n    while queue:\n        current, steps = queue.popleft()\n        if current == B:\n            return steps  # Found the target string\n        if steps == 10:\n            continue  # Stop if already taken 10 steps\n        for source, target in rules:\n            index = current.find(source)\n            while index != -1:\n                # Apply the transformation\n                next_string = current[:index] + target + current[index + len(source):]\n                if next_string not in visited:\n                    visited.add(next_string)\n                    queue.append((next_string, steps + 1))\n                index = current.find(source, index + 1)\n    return \"NO ANSWER!\"\n\nيرجى تقديم وصف موجز بلغة طبيعية (docstring) للشفرة البرمجية بلغة بايثون باللغة العربية الفصحى، على ألا يتجاوز 500 حرف.",
      "sw": "def string_transformation(A: str, B: str, rules: list) -> Union[int, str]:\n\n    queue = deque([(A, 0)])  # Each element in the queue is a tuple (current_string, steps_taken)\n    visited = set([A])  # Keep track of visited strings to avoid loops\n\n    # Perform BFS\n    while queue:\n        current, steps = queue.popleft()\n        if current == B:\n            return steps  # Found the target string\n        if steps == 10:\n            continue  # Stop if already taken 10 steps\n        for source, target in rules:\n            index = current.find(source)\n            while index != -1:\n                # Apply the transformation\n                next_string = current[:index] + target + current[index + len(source):]\n                if next_string not in visited:\n                    visited.add(next_string)\n                    queue.append((next_string, steps + 1))\n                index = current.find(source, index + 1)\n    return \"NO ANSWER!\"\n\nToa maelezo mafupi ya lugha ya asili (docstring) ya msimbo wa Python kwa Kiswahili kwa kutumia herufi zisizozidi 500.",
      "tr": "def string_transformation(A: str, B: str, rules: list) -> Union[int, str]:\n\n    queue = deque([(A, 0)])  # Each element in the queue is a tuple (current_string, steps_taken)\n    visited = set([A])  # Keep track of visited strings to avoid loops\n\n    # Perform BFS\n    while queue:\n        current, steps = queue.popleft()\n        if current == B:\n            return steps  # Found the target string\n        if steps == 10:\n            continue  # Stop if already taken 10 steps\n        for source, target in rules:\n            index = current.find(source)\n            while index != -1:\n                # Apply the transformation\n                next_string = current[:index] + target + current[index + len(source):]\n                if next_string not in visited:\n                    visited.add(next_string)\n                    queue.append((next_string, steps + 1))\n                index = current.find(source, index + 1)\n    return \"NO ANSWER!\"\n\nVerilen Python kodunun işlevini açıklayan, en fazla 500 karakter uzunluğunda özlü bir doğal dil açıklaması (docstring) sağlayın.",
      "vi": "def string_transformation(A: str, B: str, rules: list) -> Union[int, str]:\n\n    queue = deque([(A, 0)])  # Each element in the queue is a tuple (current_string, steps_taken)\n    visited = set([A])  # Keep track of visited strings to avoid loops\n\n    # Perform BFS\n    while queue:\n        current, steps = queue.popleft()\n        if current == B:\n            return steps  # Found the target string\n        if steps == 10:\n            continue  # Stop if already taken 10 steps\n        for source, target in rules:\n            index = current.find(source)\n            while index != -1:\n                # Apply the transformation\n                next_string = current[:index] + target + current[index + len(source):]\n                if next_string not in visited:\n                    visited.add(next_string)\n                    queue.append((next_string, steps + 1))\n                index = current.find(source, index + 1)\n    return \"NO ANSWER!\"\n\nCung cấp mô tả ngắn gọn bằng ngôn ngữ tự nhiên (docstring) cho mã Python bằng tiếng Việt, sử dụng tối đa 500 ký tự."
    },
    "instruction_bertscore": {
      "es": "0.9687387561112052",
      "arb": "0.906469919330197",
      "sw": "0.914896018724078",
      "tr": "0.8508820154152974",
      "vi": "0.9256256346468206"
    },
    "level": "",
    "test": "def test_string_transformation():\n    # Test case 1\n    A1 = \"abcd\"\n    B1 = \"xyz\"\n    rules1 = [(\"abc\", \"xu\"), (\"ud\", \"y\"), (\"y\", \"yz\")]\n    expected_result1 = 3\n    assert string_transformation(A1, B1, rules1) == expected_result1, \"Test case 1 failed\"\n\n    # Test case 2\n    A2 = \"aaa\"\n    B2 = \"bbbb\"\n    rules2 = [(\"a\", \"b\"), (\"aa\", \"bb\"), (\"aaa\", \"bbb\")]\n    expected_result2 = \"NO ANSWER!\"\n    assert string_transformation(A2, B2, rules2) == expected_result2, \"Test case 2 failed\"\n\n    # Test case 3\n    A3 = \"hello\"\n    B3 = \"world\"\n    rules3 = [(\"h\", \"w\"), (\"e\", \"o\"), (\"l\", \"r\"), (\"lol\", \"ldr\")]\n    expected_result3 = \"NO ANSWER!\"\n    assert string_transformation(A3, B3, rules3) == expected_result3, \"Test case 3 failed\"\n\n    print(\"All test cases passed!\")\n\n# Run the test function\ntest_string_transformation()",
    "entry_point": "string_transformation",
    "signature": "def string_transformation(A: str, B: str, rules: list) -> Union[int, str]:",
    "docstring": {
      "en": "Perform string transformation from A to B using a set of transformation rules.\n\nThis function takes an initial string A and a target string B, along with a list\nof transformation rules, and attempts to transform A into B using the rules.\nA Breadth-First Search (BFS) algorithm is used to explore the possible transformations\nup to a maximum of 10 steps. If A can be transformed into B within 10 steps, the function\nreturns the minimum number of steps required. If it's not possible, the function returns\n\"NO ANSWER!\".\n\nParameters:\nA (str): The initial string to be transformed.\nB (str): The target string to be achieved.\nrules (list of tuples): A list of transformation rules, where each rule is a tuple\ncontaining the source substring (to be replaced) and the\ntarget substring (to replace with).\n\nReturns:\nUnion[int, str]: The minimum number of transformation steps if possible, otherwise \"NO ANSWER!\".\n\nExamples:\nCase 1:\nA = \"abcd\", B = \"xyz\", rules = [(\"abc\", \"xu\"), (\"ud\", \"y\"), (\"y\", \"yz\")]\nstring_transformation(A, B, rules) should return 3.\n\nCase 2:\nA = \"aaa\", B = \"bbbb\", rules = [(\"a\", \"b\"), (\"aa\", \"bb\"), (\"aaa\", \"bbb\")]\nstring_transformation(A, B, rules) should return \"NO ANSWER!\" because transformation\nis not possible within 10 steps.\n\nCase 3:\nA = \"abc\", B = \"xyz\", rules = [(\"a\", \"x\"), (\"b\", \"y\"), (\"c\", \"z\")]\nstring_transformation(A, B, rules) should return 3, as each character is replaced\nindividually.",
      "es": "Realizar la transformación de cadena de A a B utilizando un conjunto de reglas de transformación.\n\nEsta función toma una cadena inicial A y una cadena objetivo B, junto con una lista\nde reglas de transformación, e intenta transformar A en B usando las reglas.\nSe utiliza un algoritmo de Búsqueda en Anchura (BFS) para explorar las posibles transformaciones\nhasta un máximo de 10 pasos. Si A puede transformarse en B dentro de 10 pasos, la función\ndevuelve el número mínimo de pasos requeridos. Si no es posible, la función devuelve\n\"¡SIN RESPUESTA!\".\n\nParámetros:\nA (str): La cadena inicial a transformar.\nB (str): La cadena objetivo a lograr.\nrules (list of tuples): Una lista de reglas de transformación, donde cada regla es una tupla\nque contiene la subcadena fuente (a ser reemplazada) y la\nsubcadena objetivo (con la que se reemplaza).\n\nDevuelve:\nUnion[int, str]: El número mínimo de pasos de transformación si es posible, de lo contrario \"¡SIN RESPUESTA!\".\n\nEjemplos:\nCaso 1:\nA = \"abcd\", B = \"xyz\", rules = [(\"abc\", \"xu\"), (\"ud\", \"y\"), (\"y\", \"yz\")]\nstring_transformation(A, B, rules) debería devolver 3.\n\nCaso 2:\nA = \"aaa\", B = \"bbbb\", rules = [(\"a\", \"b\"), (\"aa\", \"bb\"), (\"aaa\", \"bbb\")]\nstring_transformation(A, B, rules) debería devolver \"¡SIN RESPUESTA!\" porque la transformación\nno es posible dentro de 10 pasos.\n\nCaso 3:\nA = \"abc\", B = \"xyz\", rules = [(\"a\", \"x\"), (\"b\", \"y\"), (\"c\", \"z\")]\nstring_transformation(A, B, rules) debería devolver 3, ya que cada carácter se reemplaza\nindividualmente.",
      "arb": "إجراء تحويل سلسلة من A إلى B باستخدام مجموعة من قواعد التحويل.\n\nتأخذ هذه الدالة سلسلة ابتدائية A وسلسلة مستهدفة B، بالإضافة إلى قائمة\nمن قواعد التحويل، وتحاول تحويل A إلى B باستخدام القواعد.\nيتم استخدام خوارزمية البحث بعرض أول (BFS) لاستكشاف التحويلات الممكنة\nحتى حد أقصى من 10 خطوات. إذا كان بالإمكان تحويل A إلى B في غضون 10 خطوات، فإن الدالة\nتعيد الحد الأدنى لعدد الخطوات المطلوبة. إذا لم يكن ذلك ممكنًا، فإن الدالة تعيد\n\"لا يوجد جواب!\".\n\nالمعلمات:\nA (str): السلسلة الابتدائية المراد تحويلها.\nB (str): السلسلة المستهدفة المراد تحقيقها.\nrules (list of tuples): قائمة بقواعد التحويل، حيث تكون كل قاعدة عبارة عن زوج\nيحتوي على الجزء الفرعي المصدر (الذي سيتم استبداله) و\nالجزء الفرعي الهدف (الذي سيتم الاستبدال به).\n\nالقيم المعادة:\nUnion[int, str]: الحد الأدنى لعدد خطوات التحويل إذا كان ذلك ممكنًا، وإلا \"لا يوجد جواب!\".\n\nأمثلة:\nالحالة 1:\nA = \"abcd\", B = \"xyz\", rules = [(\"abc\", \"xu\"), (\"ud\", \"y\"), (\"y\", \"yz\")]\nstring_transformation(A, B, rules) يجب أن تعيد 3.\n\nالحالة 2:\nA = \"aaa\", B = \"bbbb\", rules = [(\"a\", \"b\"), (\"aa\", \"bb\"), (\"aaa\", \"bbb\")]\nstring_transformation(A, B, rules) يجب أن تعيد \"لا يوجد جواب!\" لأن التحويل\nغير ممكن في غضون 10 خطوات.\n\nالحالة 3:\nA = \"abc\", B = \"xyz\", rules = [(\"a\", \"x\"), (\"b\", \"y\"), (\"c\", \"z\")]\nstring_transformation(A, B, rules) يجب أن تعيد 3، حيث يتم استبدال كل حرف\nبشكل فردي.",
      "sw": "Fanya mabadiliko ya kamba kutoka A hadi B kwa kutumia seti ya sheria za mabadiliko.\n\nKazi hii inachukua kamba ya awali A na kamba lengwa B, pamoja na orodha\nya sheria za mabadiliko, na inajaribu kubadilisha A kuwa B kwa kutumia sheria hizo.\nAlgoriti ya Utafutaji wa Upana Kwanza (BFS) inatumika kuchunguza mabadiliko yanayowezekana\nhadi hatua 10 za juu zaidi. Ikiwa A inaweza kubadilishwa kuwa B ndani ya hatua 10, kazi\ninarudisha idadi ndogo ya hatua zinazohitajika. Ikiwa haiwezekani, kazi inarudisha\n\"HAKUNA JIBU!\".\n\nVigezo:\nA (str): Kamba ya awali inayopaswa kubadilishwa.\nB (str): Kamba lengwa inayopaswa kufikiwa.\nrules (orodha ya jozi): Orodha ya sheria za mabadiliko, ambapo kila sheria ni jozi\ninayojumuisha sehemu ndogo ya chanzo (inayopaswa kubadilishwa) na\nsehemu ndogo ya lengwa (ya kubadilisha nayo).\n\nInarudisha:\nMuungano[int, str]: Idadi ndogo ya hatua za mabadiliko ikiwa inawezekana, vinginevyo \"HAKUNA JIBU!\".\n\nMifano:\nKesi ya 1:\nA = \"abcd\", B = \"xyz\", rules = [(\"abc\", \"xu\"), (\"ud\", \"y\"), (\"y\", \"yz\")]\nstring_transformation(A, B, rules) inapaswa kurudisha 3.\n\nKesi ya 2:\nA = \"aaa\", B = \"bbbb\", rules = [(\"a\", \"b\"), (\"aa\", \"bb\"), (\"aaa\", \"bbb\")]\nstring_transformation(A, B, rules) inapaswa kurudisha \"HAKUNA JIBU!\" kwa sababu mabadiliko\nhayanawezekana ndani ya hatua 10.\n\nKesi ya 3:\nA = \"abc\", B = \"xyz\", rules = [(\"a\", \"x\"), (\"b\", \"y\"), (\"c\", \"z\")]\nstring_transformation(A, B, rules) inapaswa kurudisha 3, kwani kila herufi inabadilishwa\nindividually.",
      "tr": "A'yı B'ye bir dizi dönüşüm kuralı kullanarak dönüştürme işlemi yapar.\n\nBu fonksiyon, başlangıç ​​dizesi A ve hedef dize B'yi, dönüşüm kuralları listesiyle birlikte alır ve A'yı B'ye dönüştürmeye çalışır. Olası dönüşümleri keşfetmek için Genişlik Öncelikli Arama (BFS) algoritması kullanılır ve maksimum 10 adıma kadar araştırılır. Eğer A, 10 adım içinde B'ye dönüştürülebilirse, fonksiyon gereken minimum adım sayısını döndürür. Eğer mümkün değilse, fonksiyon \"NO ANSWER!\" döndürür.\n\nParametreler:\nA (str): Dönüştürülecek başlangıç ​​dizesi.\nB (str): Elde edilmesi gereken hedef dize.\nrules (list of tuples): Her kuralın, kaynak alt dize (değiştirilecek) ve hedef alt dizeyi (yerine konulacak) içeren bir demet olduğu dönüşüm kuralları listesi.\n\nDöndürür:\nUnion[int, str]: Mümkünse dönüşüm adımlarının minimum sayısı, aksi takdirde \"NO ANSWER!\".\n\nÖrnekler:\nDurum 1:\nA = \"abcd\", B = \"xyz\", rules = [(\"abc\", \"xu\"), (\"ud\", \"y\"), (\"y\", \"yz\")]\nstring_transformation(A, B, rules) 3 döndürmelidir.\n\nDurum 2:\nA = \"aaa\", B = \"bbbb\", rules = [(\"a\", \"b\"), (\"aa\", \"bb\"), (\"aaa\", \"bbb\")]\nstring_transformation(A, B, rules) 10 adım içinde dönüşüm mümkün olmadığından \"NO ANSWER!\" döndürmelidir.\n\nDurum 3:\nA = \"abc\", B = \"xyz\", rules = [(\"a\", \"x\"), (\"b\", \"y\"), (\"c\", \"z\")]\nstring_transformation(A, B, rules) her karakter ayrı ayrı değiştirildiği için 3 döndürmelidir.",
      "vi": "Thực hiện chuyển đổi chuỗi từ A sang B bằng cách sử dụng một tập hợp các quy tắc chuyển đổi.\n\nHàm này nhận một chuỗi ban đầu A và một chuỗi đích B, cùng với một danh sách\ncác quy tắc chuyển đổi, và cố gắng chuyển đổi A thành B bằng cách sử dụng các quy tắc.\nThuật toán Tìm kiếm theo chiều rộng (BFS) được sử dụng để khám phá các chuyển đổi có thể\ntối đa là 10 bước. Nếu A có thể được chuyển đổi thành B trong vòng 10 bước, hàm\ntrả về số bước tối thiểu cần thiết. Nếu không thể, hàm trả về\n\"NO ANSWER!\".\n\nTham số:\nA (str): Chuỗi ban đầu cần được chuyển đổi.\nB (str): Chuỗi đích cần đạt được.\nrules (list of tuples): Một danh sách các quy tắc chuyển đổi, trong đó mỗi quy tắc là một bộ\nchứa chuỗi con nguồn (để thay thế) và\nchuỗi con đích (để thay thế bằng).\n\nTrả về:\nUnion[int, str]: Số bước chuyển đổi tối thiểu nếu có thể, nếu không thì \"NO ANSWER!\".\n\nVí dụ:\nTrường hợp 1:\nA = \"abcd\", B = \"xyz\", rules = [(\"abc\", \"xu\"), (\"ud\", \"y\"), (\"y\", \"yz\")]\nstring_transformation(A, B, rules) sẽ trả về 3.\n\nTrường hợp 2:\nA = \"aaa\", B = \"bbbb\", rules = [(\"a\", \"b\"), (\"aa\", \"bb\"), (\"aaa\", \"bbb\")]\nstring_transformation(A, B, rules) sẽ trả về \"NO ANSWER!\" vì chuyển đổi\nkhông thể thực hiện trong vòng 10 bước.\n\nTrường hợp 3:\nA = \"abc\", B = \"xyz\", rules = [(\"a\", \"x\"), (\"b\", \"y\"), (\"c\", \"z\")]\nstring_transformation(A, B, rules) sẽ trả về 3, vì mỗi ký tự được thay thế\nriêng lẻ."
    },
    "docstring_bertscore": {
      "es": "0.9880168277425462",
      "arb": "0.9676987274361065",
      "sw": "0.984355275298549",
      "tr": "0.9761387309566599",
      "vi": "0.9839341788907552"
    }
  },
  {
    "task_id": "Python/29",
    "prompt": {
      "en": "def find_min_n_greater_than_k(k: int) -> int:\n    \"\"\"\n    Calculate the smallest positive integer n such that the sum of the harmonic series\n    up to 1/n is greater than a given positive integer k.\n\n    The harmonic series is defined as S_n = 1 + 1/2 + 1/3 + ... + 1/n.\n\n    Args:\n    - k (int): A positive integer representing the threshold value the harmonic series sum must exceed.\n\n    Returns:\n    - int: The smallest integer n for which the harmonic series sum S_n exceeds the threshold k.\n\n    Examples:\n    >>> find_min_n_greater_than_k(1)\n    2\n    The sum S_2 = 1 + 1/2 = 1.5, which is greater than 1.\n\n    >>> find_min_n_greater_than_k(3)\n    11\n    The sum S_10 = 1 + 1/2 + 1/3 + ... + 1/10 is less than or equal to 3, but the sum S_11 exceeds 3.\n    \"\"\"",
      "es": "def find_min_n_greater_than_k(k: int) -> int:\n    \"\"\"\n    Calcula el entero positivo más pequeño n tal que la suma de la serie armónica\n    hasta 1/n es mayor que un entero positivo dado k.\n\n    La serie armónica se define como S_n = 1 + 1/2 + 1/3 + ... + 1/n.\n\n    Argumentos:\n    - k (int): Un entero positivo que representa el valor umbral que la suma de la serie armónica debe exceder.\n\n    Devuelve:\n    - int: El entero más pequeño n para el cual la suma de la serie armónica S_n excede el umbral k.\n\n    Ejemplos:\n    >>> find_min_n_greater_than_k(1)\n    2\n    La suma S_2 = 1 + 1/2 = 1.5, que es mayor que 1.\n\n    >>> find_min_n_greater_than_k(3)\n    11\n    La suma S_10 = 1 + 1/2 + 1/3 + ... + 1/10 es menor o igual a 3, pero la suma S_11 excede 3.\n    \"\"\"",
      "arb": "def find_min_n_greater_than_k(k: int) -> int:\n    \"\"\"\n    حساب أصغر عدد صحيح موجب n بحيث يكون مجموع السلسلة التوافقية\n    حتى 1/n أكبر من عدد صحيح موجب معين k.\n\n    تُعرّف السلسلة التوافقية كالتالي S_n = 1 + 1/2 + 1/3 + ... + 1/n.\n\n    يعيدالحجج:\n    - k (int): عدد صحيح موجب يمثل قيمة العتبة التي يجب أن يتجاوزها مجموع السلسلة التوافقية.\n\n    يعيد:\n    - int: أصغر عدد صحيح n حيث يتجاوز مجموع السلسلة التوافقية S_n العتبة k.\n\n    أمثلة:\n    >>> find_min_n_greater_than_k(1)\n    2\n    المجموع S_2 = 1 + 1/2 = 1.5، وهو أكبر من 1.\n\n    >>> find_min_n_greater_than_k(3)\n    11\n    المجموع S_10 = 1 + 1/2 + 1/3 + ... + 1/10 أقل من أو يساوي 3، لكن المجموع S_11 يتجاوز 3.\n    \"\"\"",
      "sw": "def find_min_n_greater_than_k(k: int) -> int:\n    \"\"\"\n    Hesabu namba ndogo kabisa chanya n kiasi kwamba jumla ya mfululizo wa harmonic\n    hadi 1/n ni kubwa kuliko namba chanya iliyotolewa k.\n\n    Mfululizo wa harmonic unafafanuliwa kama S_n = 1 + 1/2 + 1/3 + ... + 1/n.\n\n    Hoja:\n    - k (int): Namba chanya inayowakilisha thamani ya kizingiti ambacho jumla ya mfululizo wa harmonic lazima izidi.\n\n    Inarejesha:\n    - int: Namba ndogo kabisa n ambayo jumla ya mfululizo wa harmonic S_n inazidi kizingiti k.\n\n    Mifano:\n    >>> find_min_n_greater_than_k(1)\n    2\n    Jumla S_2 = 1 + 1/2 = 1.5, ambayo ni kubwa kuliko 1.\n\n    >>> find_min_n_greater_than_k(3)\n    11\n    Jumla S_10 = 1 + 1/2 + 1/3 + ... + 1/10 ni ndogo au sawa na 3, lakini jumla S_11 inazidi 3.\n    \"\"\"",
      "tr": "def find_min_n_greater_than_k(k: int) -> int:\n    \"\"\"\n    Harmonik serinin toplamının 1/n'ye kadar olan kısmının\n    verilen pozitif bir tamsayı k'dan büyük olması için en küçük pozitif tamsayı n'yi hesaplayın.\n\n    Harmonik seri S_n = 1 + 1/2 + 1/3 + ... + 1/n olarak tanımlanır.\n\n    Argümanlar:\n    - k (int): Harmonik seri toplamının aşması gereken eşik değerini temsil eden pozitif bir tamsayı.\n\n    Dönüş:\n    - int: Harmonik seri toplamı S_n'nin eşik k değerini aştığı en küçük tamsayı n.\n\n    Örnekler:\n    >>> find_min_n_greater_than_k(1)\n    2\n    Toplam S_2 = 1 + 1/2 = 1.5, bu 1'den büyüktür.\n\n    >>> find_min_n_greater_than_k(3)\n    11\n    Toplam S_10 = 1 + 1/2 + 1/3 + ... + 1/10, 3'ten küçük veya eşittir, ancak toplam S_11, 3'ü aşar.\n    \"\"\"",
      "vi": "def find_min_n_greater_than_k(k: int) -> int:\n    \"\"\"\n    Tính toán số nguyên dương nhỏ nhất n sao cho tổng của chuỗi điều hòa\n    lên đến 1/n lớn hơn một số nguyên dương cho trước k.\n\n    Chuỗi điều hòa được định nghĩa là S_n = 1 + 1/2 + 1/3 + ... + 1/n.\n\n    Tham số:\n    - k (int): Một số nguyên dương đại diện cho giá trị ngưỡng mà tổng chuỗi điều hòa phải vượt qua.\n\n    Trả về:\n    - int: Số nguyên nhỏ nhất n sao cho tổng chuỗi điều hòa S_n vượt qua ngưỡng k.\n\n    Ví dụ:\n    >>> find_min_n_greater_than_k(1)\n    2\n    Tổng S_2 = 1 + 1/2 = 1.5, lớn hơn 1.\n\n    >>> find_min_n_greater_than_k(3)\n    11\n    Tổng S_10 = 1 + 1/2 + 1/3 + ... + 1/10 nhỏ hơn hoặc bằng 3, nhưng tổng S_11 vượt qua 3.\n    \"\"\""
    },
    "prompt_bertscore": {
      "es": "0.9815817992881589",
      "arb": "0.9776554725462423",
      "sw": "0.9732232342238298",
      "tr": "0.9905243376727306",
      "vi": "0.9850222761180643"
    },
    "canonical_solution": "# Initialize variables\n    n = 1\n    S_n = 0\n\n# Calculate the minimum n for which S_n > k\n    while S_n <= k:\n        S_n += 1 / n\n        n += 1\n\n\n    return n - 1",
    "instruction": {
      "en": "def find_min_n_greater_than_k(k: int) -> int:\n# Initialize variables\n    n = 1\n    S_n = 0\n\n# Calculate the minimum n for which S_n > k\n    while S_n <= k:\n        S_n += 1 / n\n        n += 1\n\n\n    return n - 1\n\nProvide a concise natural language description (docstring) of the Python code in English using at most 500 characters.",
      "es": "def find_min_n_greater_than_k(k: int) -> int:\n# Initialize variables\n    n = 1\n    S_n = 0\n\n# Calculate the minimum n for which S_n > k\n    while S_n <= k:\n        S_n += 1 / n\n        n += 1\n\n\n    return n - 1\n\nProporcione una descripción concisa en lenguaje natural (docstring) del código Python en español utilizando como máximo 500 caracteres.",
      "arb": "def find_min_n_greater_than_k(k: int) -> int:\n# Initialize variables\n    n = 1\n    S_n = 0\n\n# Calculate the minimum n for which S_n > k\n    while S_n <= k:\n        S_n += 1 / n\n        n += 1\n\n\n    return n - 1\n\nيرجى تقديم وصف موجز بلغة طبيعية (docstring) للشفرة البرمجية بلغة بايثون باللغة العربية الفصحى، بحيث لا يتجاوز 500 حرف.",
      "sw": "def find_min_n_greater_than_k(k: int) -> int:\n# Initialize variables\n    n = 1\n    S_n = 0\n\n# Calculate the minimum n for which S_n > k\n    while S_n <= k:\n        S_n += 1 / n\n        n += 1\n\n\n    return n - 1\n\nToa maelezo mafupi ya lugha ya asili (docstring) ya msimbo wa Python kwa Kiswahili kwa kutumia herufi zisizozidi 500.",
      "tr": "def find_min_n_greater_than_k(k: int) -> int:\n# Initialize variables\n    n = 1\n    S_n = 0\n\n# Calculate the minimum n for which S_n > k\n    while S_n <= k:\n        S_n += 1 / n\n        n += 1\n\n\n    return n - 1\n\nVerilen Python kodunun işlevini açıklayan, en fazla 500 karakter uzunluğunda özlü bir doğal dil açıklaması (docstring) sağlayın.",
      "vi": "def find_min_n_greater_than_k(k: int) -> int:\n# Initialize variables\n    n = 1\n    S_n = 0\n\n# Calculate the minimum n for which S_n > k\n    while S_n <= k:\n        S_n += 1 / n\n        n += 1\n\n\n    return n - 1\n\nCung cấp mô tả ngắn gọn bằng ngôn ngữ tự nhiên (docstring) cho mã Python bằng tiếng Việt, sử dụng tối đa 500 ký tự."
    },
    "instruction_bertscore": {
      "es": "0.9687387561112052",
      "arb": "0.906469919330197",
      "sw": "0.914896018724078",
      "tr": "0.8508820154152974",
      "vi": "0.9069722555638342"
    },
    "level": "",
    "test": "def test_find_min_n_greater_than_k():\n    # Test case 1: k = 1, expected result is 2\n\n    assert find_min_n_greater_than_k(1) == 2, \"Test case 1 failed.\"\n\n    # Test case 2: k = 3, expected result is 11\n    assert find_min_n_greater_than_k(3) == 11, \"Test case 2 failed.\"\n    # Test case 3: k = 5, expected result is 83\n    assert find_min_n_greater_than_k(5) == 83, \"Test case 3 failed.\"\n\n    print(\"All test cases passed.\")\n\n\n# Run the test function\ntest_find_min_n_greater_than_k()",
    "entry_point": "find_min_n_greater_than_k",
    "signature": "def find_min_n_greater_than_k(k: int) -> int:",
    "docstring": {
      "en": "Calculate the smallest positive integer n such that the sum of the harmonic series\nup to 1/n is greater than a given positive integer k.\n\nThe harmonic series is defined as S_n = 1 + 1/2 + 1/3 + ... + 1/n.\n\nArgs:\n- k (int): A positive integer representing the threshold value the harmonic series sum must exceed.\n\nReturns:\n- int: The smallest integer n for which the harmonic series sum S_n exceeds the threshold k.\n\nExamples:\n>>> find_min_n_greater_than_k(1)\n2\nThe sum S_2 = 1 + 1/2 = 1.5, which is greater than 1.\n\n>>> find_min_n_greater_than_k(3)\n11\nThe sum S_10 = 1 + 1/2 + 1/3 + ... + 1/10 is less than or equal to 3, but the sum S_11 exceeds 3.",
      "es": "Calcular el entero positivo más pequeño n tal que la suma de la serie armónica\nhasta 1/n sea mayor que un entero positivo dado k.\n\nLa serie armónica se define como S_n = 1 + 1/2 + 1/3 + ... + 1/n.\n\nArgumentos:\n- k (int): Un entero positivo que representa el valor umbral que la suma de la serie armónica debe exceder.\n\nDevuelve:\n- int: El entero más pequeño n para el cual la suma de la serie armónica S_n excede el umbral k.\n\nEjemplos:\n>>> find_min_n_greater_than_k(1)\n2\nLa suma S_2 = 1 + 1/2 = 1.5, que es mayor que 1.\n\n>>> find_min_n_greater_than_k(3)\n11\nLa suma S_10 = 1 + 1/2 + 1/3 + ... + 1/10 es menor o igual a 3, pero la suma S_11 excede 3.",
      "arb": "احسب أصغر عدد صحيح موجب n بحيث يكون مجموع السلسلة التوافقية حتى 1/n أكبر من عدد صحيح موجب معين k.\n\nالسلسلة التوافقية تُعرّف كالتالي S_n = 1 + 1/2 + 1/3 + ... + 1/n.\n\nالمعطيات:\n- k (int): عدد صحيح موجب يمثل قيمة العتبة التي يجب أن يتجاوزها مجموع السلسلة التوافقية.\n\nالقيم المعادة:\n- int: أصغر عدد صحيح n حيث يتجاوز مجموع السلسلة التوافقية S_n العتبة k.\n\nأمثلة:\n>>> find_min_n_greater_than_k(1)\n2\nالمجموع S_2 = 1 + 1/2 = 1.5، وهو أكبر من 1.\n\n>>> find_min_n_greater_than_k(3)\n11\nالمجموع S_10 = 1 + 1/2 + 1/3 + ... + 1/10 أقل من أو يساوي 3، لكن المجموع S_11 يتجاوز 3.",
      "sw": "Hesabu namba ndogo kabisa chanya n kiasi kwamba jumla ya mfululizo wa harmonic\n    hadi 1/n ni kubwa kuliko namba chanya iliyotolewa k.\n\nMfululizo wa harmonic unafafanuliwa kama S_n = 1 + 1/2 + 1/3 + ... + 1/n.\n\nHoja:\n- k (int): Nambari nzima chanya inayowakilisha thamani ya kizingiti ambacho jumla ya mfululizo wa harmonic lazima izidi.\n\nInarejesha:\n- int: Nambari ndogo zaidi n ambayo jumla ya mfululizo wa harmonic S_n inazidi kizingiti k.\n\nMifano:\n>>> find_min_n_greater_than_k(1)\n2\nJumla S_2 = 1 + 1/2 = 1.5, ambayo ni kubwa kuliko 1.\n\n>>> find_min_n_greater_than_k(3)\n11\nJumla S_10 = 1 + 1/2 + 1/3 + ... + 1/10 ni ndogo au sawa na 3, lakini jumla S_11 inazidi 3.",
      "tr": "Harmonik serinin 1/n'ye kadar olan toplamının verilen pozitif bir tamsayı k'dan büyük olduğu en küçük pozitif tamsayı n'yi hesaplayın.\n\nHarmonik seri S_n = 1 + 1/2 + 1/3 + ... + 1/n olarak tanımlanır.\n\nArgümanlar:\n- k (int): Harmonik seri toplamının aşması gereken eşik değerini temsil eden pozitif bir tamsayı.\n\nDöndürür:\n- int: Harmonik seri toplamı S_n'nin eşik k değerini aştığı en küçük tamsayı n.\n\nÖrnekler:\n>>> find_min_n_greater_than_k(1)\n2\nToplam S_2 = 1 + 1/2 = 1.5, bu 1'den büyüktür.\n\n>>> find_min_n_greater_than_k(3)\n11\nToplam S_10 = 1 + 1/2 + 1/3 + ... + 1/10, 3'ten küçük veya eşittir, ancak toplam S_11, 3'ü aşar.",
      "vi": "Tính số nguyên dương nhỏ nhất n sao cho tổng của chuỗi điều hòa\ntới 1/n lớn hơn một số nguyên dương cho trước k.\n\nChuỗi điều hòa được định nghĩa là S_n = 1 + 1/2 + 1/3 + ... + 1/n.\n\nTham số:\n- k (int): Một số nguyên dương đại diện cho giá trị ngưỡng mà tổng chuỗi điều hòa phải vượt qua.\n\nTrả về:\n- int: Số nguyên nhỏ nhất n sao cho tổng chuỗi điều hòa S_n vượt quá ngưỡng k.\n\nVí dụ:\n>>> find_min_n_greater_than_k(1)\n2\nTổng S_2 = 1 + 1/2 = 1.5, lớn hơn 1.\n\n>>> find_min_n_greater_than_k(3)\n11\nTổng S_10 = 1 + 1/2 + 1/3 + ... + 1/10 nhỏ hơn hoặc bằng 3, nhưng tổng S_11 vượt quá 3."
    },
    "docstring_bertscore": {
      "es": "0.9822102658137534",
      "arb": "0.9660878350459136",
      "sw": "0.9803773046575633",
      "tr": "0.992131456085684",
      "vi": "0.9676075560912115"
    }
  },
  {
    "task_id": "Python/30",
    "prompt": {
      "en": "def is_prime(num: int) -> bool:\n    \"\"\"\n    Determine whether a given integer is a prime number.\n\n    A prime number is a natural number greater than 1 that has no positive divisors other than 1 and itself. The function checks for primality by eliminating non-prime numbers using several tests. First, it handles edge cases for numbers less than or equal to 1, which are not prime, and small numbers (2 and 3) which are prime. It then checks for divisibility by 2 and 3. For larger numbers, it uses a 6k +/- 1 optimization to test for factors up to the square root of the number.\n\n    Args:\n    num (int): The integer to check for primality.\n\n    Returns:\n    bool: True if `num` is a prime number, False otherwise.\n\n    Cases:\n    - For num = 2 or num = 3, the function should return True, since both are prime numbers.\n    - For num = 1 or num = 0, the function should return False, as neither is considered prime.\n    - For num = 15, which is divisible by 3 and 5, the function should return False.\n    - For num = 29, which has no divisors other than 1 and itself, the function should return True.\n    \"\"\"\n    if num <= 1:\n        return False\n    if num <= 3:\n        return True\n    if num % 2 == 0 or num % 3 == 0:\n        return False\n    i = 5\n    while i * i <= num:\n        if num % i == 0 or num % (i + 2) == 0:\n            return False\n        i += 6\n    return True",
      "es": "def is_prime(num: int) -> bool:\n    \"\"\"\n    Determinar si un número entero dado es un número primo.\n\n    Un número primo es un número natural mayor que 1 que no tiene divisores positivos aparte de 1 y él mismo. La función verifica la primalidad eliminando números no primos mediante varias pruebas. Primero, maneja casos especiales para números menores o iguales a 1, que no son primos, y números pequeños (2 y 3) que son primos. Luego verifica la divisibilidad por 2 y 3. Para números más grandes, utiliza una optimización 6k +/- 1 para probar factores hasta la raíz cuadrada del número.\n\n    Argumentos:\n    num (int): El entero para verificar la primalidad.\n\n    Devuelve:\n    bool: True si `num` es un número primo, False en caso contrario.\n\n    Casos:\n    - Para num = 2 o num = 3, la función debería devolver True, ya que ambos son números primos.\n    - Para num = 1 o num = 0, la función debería devolver False, ya que ninguno se considera primo.\n    - Para num = 15, que es divisible por 3 y 5, la función debería devolver False.\n    - Para num = 29, que no tiene divisores aparte de 1 y él mismo, la función debería devolver True.\n    \"\"\"\n    if num <= 1:\n        return False\n    if num <= 3:\n        return True\n    if num % 2 == 0 or num % 3 == 0:\n        return False\n    i = 5\n    while i * i <= num:\n        if num % i == 0 or num % (i + 2) == 0:\n            return False\n        i += 6\n    return True",
      "arb": "def is_prime(num: int) -> bool:\n    \"\"\"\n    تحديد ما إذا كان العدد الصحيح المعطى هو عدد أولي.\n\n    العدد الأولي هو عدد طبيعي أكبر من 1 وليس له قواسم موجبة أخرى غير 1 ونفسه. تقوم الدالة بالتحقق من الأولية عن طريق استبعاد الأعداد غير الأولية باستخدام عدة اختبارات. أولاً، تتعامل مع الحالات الخاصة للأعداد الأقل من أو تساوي 1، والتي ليست أولية، والأعداد الصغيرة (2 و3) التي هي أولية. ثم تتحقق من القابلية للقسمة على 2 و3. بالنسبة للأعداد الأكبر، تستخدم تحسين 6k +/- 1 لاختبار العوامل حتى الجذر التربيعي للعدد.\n\n    يعيدالحجج:\n    num (int): العدد الصحيح للتحقق من أوليته.\n\n    يعيد:\n    bool: True إذا كان `num` عددًا أوليًا، False خلاف ذلك.\n\n    حالات:\n    - بالنسبة لـ num = 2 أو num = 3، يجب أن تعيد الدالة True، لأن كلاهما عددان أوليان.\n    - بالنسبة لـ num = 1 أو num = 0، يجب أن تعيد الدالة False، حيث لا يعتبر أي منهما أوليًا.\n    - بالنسبة لـ num = 15، الذي يقبل القسمة على 3 و5، يجب أن تعيد الدالة False.\n    - بالنسبة لـ num = 29، الذي ليس له قواسم غير 1 ونفسه، يجب أن تعيد الدالة True.\n    \"\"\"\n    if num <= 1:\n        return False\n    if num <= 3:\n        return True\n    if num % 2 == 0 or num % 3 == 0:\n        return False\n    i = 5\n    while i * i <= num:\n        if num % i == 0 or num % (i + 2) == 0:\n            return False\n        i += 6\n    return True",
      "sw": "def is_prime(num: int) -> bool:\n    \"\"\"\n    Kuamua kama nambari kamili iliyotolewa ni nambari ya kwanza.\n\n    Nambari ya kwanza ni nambari asilia iliyo kubwa kuliko 1 ambayo haina wagawanyaji chanya isipokuwa 1 na yenyewe. Kazi hii inakagua kama ni ya kwanza kwa kuondoa nambari zisizo za kwanza kwa kutumia vipimo kadhaa. Kwanza, inashughulikia kesi maalum kwa nambari ndogo au sawa na 1, ambazo si za kwanza, na nambari ndogo (2 na 3) ambazo ni za kwanza. Kisha inakagua ugawanyiko kwa 2 na 3. Kwa nambari kubwa zaidi, inatumia uboreshaji wa 6k +/- 1 ili kupima vipengele hadi mzizi wa mraba wa nambari.\n\n    Hoja:\n    num (int): Nambari kamili ya kukagua kama ni ya kwanza.\n\n    Inarejesha:\n    bool: Kweli ikiwa `num` ni nambari ya kwanza, Si kweli vinginevyo.\n\n    Kesi:\n    - Kwa num = 2 au num = 3, kazi inapaswa kurudisha Kweli, kwani zote mbili ni nambari za kwanza.\n    - Kwa num = 1 au num = 0, kazi inapaswa kurudisha Si kweli, kwani hakuna inayozingatiwa kuwa ya kwanza.\n    - Kwa num = 15, ambayo inagawanyika kwa 3 na 5, kazi inapaswa kurudisha Si kweli.\n    - Kwa num = 29, ambayo haina wagawanyaji isipokuwa 1 na yenyewe, kazi inapaswa kurudisha Kweli.\n    \"\"\"\n    if num <= 1:\n        return False\n    if num <= 3:\n        return True\n    if num % 2 == 0 or num % 3 == 0:\n        return False\n    i = 5\n    while i * i <= num:\n        if num % i == 0 or num % (i + 2) == 0:\n            return False\n        i += 6\n    return True",
      "tr": "def is_prime(num: int) -> bool:\n    \"\"\"\n    Verilen bir tam sayının asal sayı olup olmadığını belirleyin.\n\n    Asal sayı, 1'den büyük ve kendisi dışında pozitif böleni olmayan doğal sayıdır. Fonksiyon, asal olmayan sayıları birkaç test kullanarak elemek suretiyle asal olup olmadığını kontrol eder. İlk olarak, asal olmayan 1 veya daha küçük sayılar ve asal olan küçük sayılar (2 ve 3) için özel durumları ele alır. Daha sonra 2 ve 3 ile bölünebilirliği kontrol eder. Daha büyük sayılar için, sayının kareköküne kadar olan faktörleri test etmek için 6k +/- 1 optimizasyonunu kullanır.\n\n    Argümanlar:\n    num (int): Asallığı kontrol edilecek tam sayı.\n\n    Dönüş:\n    bool: `num` asal bir sayı ise True, aksi takdirde False.\n\n    Durumlar:\n    - num = 2 veya num = 3 için, fonksiyon True döndürmelidir, çünkü her ikisi de asal sayıdır.\n    - num = 1 veya num = 0 için, fonksiyon False döndürmelidir, çünkü hiçbiri asal kabul edilmez.\n    - num = 15 için, 3 ve 5 ile bölünebilir olduğundan, fonksiyon False döndürmelidir.\n    - num = 29 için, kendisi ve 1 dışında böleni olmadığından, fonksiyon True döndürmelidir.\n    \"\"\"\n    if num <= 1:\n        return False\n    if num <= 3:\n        return True\n    if num % 2 == 0 or num % 3 == 0:\n        return False\n    i = 5\n    while i * i <= num:\n        if num % i == 0 or num % (i + 2) == 0:\n            return False\n        i += 6\n    return True",
      "vi": "def is_prime(num: int) -> bool:\n    \"\"\"\n    Xác định xem một số nguyên đã cho có phải là số nguyên tố hay không.\n\n    Một số nguyên tố là một số tự nhiên lớn hơn 1 không có ước số dương nào khác ngoài 1 và chính nó. Hàm kiểm tra tính nguyên tố bằng cách loại trừ các số không phải nguyên tố bằng một số phép thử. Đầu tiên, nó xử lý các trường hợp đặc biệt cho các số nhỏ hơn hoặc bằng 1, không phải là số nguyên tố, và các số nhỏ (2 và 3) là số nguyên tố. Sau đó, nó kiểm tra tính chia hết cho 2 và 3. Đối với các số lớn hơn, nó sử dụng tối ưu hóa 6k +/- 1 để kiểm tra các ước số lên đến căn bậc hai của số đó.\n\n    Tham số:\n    num (int): Số nguyên cần kiểm tra tính nguyên tố.\n\n    Trả về:\n    bool: True nếu `num` là số nguyên tố, False nếu không phải.\n\n    Trường hợp:\n    - Đối với num = 2 hoặc num = 3, hàm sẽ trả về True, vì cả hai đều là số nguyên tố.\n    - Đối với num = 1 hoặc num = 0, hàm sẽ trả về False, vì không được coi là số nguyên tố.\n    - Đối với num = 15, chia hết cho 3 và 5, hàm sẽ trả về False.\n    - Đối với num = 29, không có ước số nào ngoài 1 và chính nó, hàm sẽ trả về True.\n    \"\"\"\n    if num <= 1:\n        return False\n    if num <= 3:\n        return True\n    if num % 2 == 0 or num % 3 == 0:\n        return False\n    i = 5\n    while i * i <= num:\n        if num % i == 0 or num % (i + 2) == 0:\n            return False\n        i += 6\n    return True"
    },
    "prompt_bertscore": {
      "es": "0.9892898498545988",
      "arb": "0.9883161637267658",
      "sw": "0.9884097186362333",
      "tr": "0.9543527521343723",
      "vi": "0.9751739831959735"
    },
    "canonical_solution": "    \"\"\"Check if a number is a prime.\"\"\"\n    if num <= 1:\n        return False\n    if num <= 3:\n        return True\n    if num % 2 == 0 or num % 3 == 0:\n        return False\n    i = 5\n    while i * i <= num:\n        if num % i == 0 or num % (i + 2) == 0:\n            return False\n        i += 6\n    return True",
    "instruction": {
      "en": "def is_prime(num: int) -> bool:\n    \"\"\"Check if a number is a prime.\"\"\"\n    if num <= 1:\n        return False\n    if num <= 3:\n        return True\n    if num % 2 == 0 or num % 3 == 0:\n        return False\n    i = 5\n    while i * i <= num:\n        if num % i == 0 or num % (i + 2) == 0:\n            return False\n        i += 6\n    return True\n\nProvide a concise natural language description (docstring) of the Python code in English using at most 500 characters.",
      "es": "def is_prime(num: int) -> bool:\n    \"\"\"Check if a number is a prime.\"\"\"\n    if num <= 1:\n        return False\n    if num <= 3:\n        return True\n    if num % 2 == 0 or num % 3 == 0:\n        return False\n    i = 5\n    while i * i <= num:\n        if num % i == 0 or num % (i + 2) == 0:\n            return False\n        i += 6\n    return True\n\nProporcione una descripción concisa en lenguaje natural (docstring) del código Python en español utilizando como máximo 500 caracteres.",
      "arb": "def is_prime(num: int) -> bool:\n    \"\"\"Check if a number is a prime.\"\"\"\n    if num <= 1:\n        return False\n    if num <= 3:\n        return True\n    if num % 2 == 0 or num % 3 == 0:\n        return False\n    i = 5\n    while i * i <= num:\n        if num % i == 0 or num % (i + 2) == 0:\n            return False\n        i += 6\n    return True\n\nيرجى تقديم وصف موجز بلغة طبيعية (docstring) للكود البرمجي بلغة بايثون باللغة العربية الفصحى، بحيث لا يتجاوز 500 حرف.",
      "sw": "def is_prime(num: int) -> bool:\n    \"\"\"Check if a number is a prime.\"\"\"\n    if num <= 1:\n        return False\n    if num <= 3:\n        return True\n    if num % 2 == 0 or num % 3 == 0:\n        return False\n    i = 5\n    while i * i <= num:\n        if num % i == 0 or num % (i + 2) == 0:\n            return False\n        i += 6\n    return True\n\nToa maelezo mafupi ya lugha ya asili (docstring) ya msimbo wa Python kwa Kiswahili kwa kutumia herufi zisizozidi 500.",
      "tr": "def is_prime(num: int) -> bool:\n    \"\"\"Check if a number is a prime.\"\"\"\n    if num <= 1:\n        return False\n    if num <= 3:\n        return True\n    if num % 2 == 0 or num % 3 == 0:\n        return False\n    i = 5\n    while i * i <= num:\n        if num % i == 0 or num % (i + 2) == 0:\n            return False\n        i += 6\n    return True\n\nVerilen Python kodunun işlevini açıklayan, en fazla 500 karakter uzunluğunda özlü bir doğal dil açıklaması (docstring) sağlayın.",
      "vi": "def is_prime(num: int) -> bool:\n    \"\"\"Check if a number is a prime.\"\"\"\n    if num <= 1:\n        return False\n    if num <= 3:\n        return True\n    if num % 2 == 0 or num % 3 == 0:\n        return False\n    i = 5\n    while i * i <= num:\n        if num % i == 0 or num % (i + 2) == 0:\n            return False\n        i += 6\n    return True\n\nCung cấp mô tả ngắn gọn bằng ngôn ngữ tự nhiên (docstring) cho mã Python bằng tiếng Việt, sử dụng tối đa 500 ký tự."
    },
    "instruction_bertscore": {
      "es": "0.9687387561112052",
      "arb": "0.906469919330197",
      "sw": "0.914896018724078",
      "tr": "0.8508820154152974",
      "vi": "0.9256256346468206"
    },
    "level": "",
    "test": "def test_is_prime():\n    # Test case 1: Test a prime number\n    prime_number = 29\n    assert is_prime(prime_number) == True, f\"Test case 1 failed: {prime_number} is a prime number.\"\n\n    # Test case 2: Test a non-prime number\n    non_prime_number = 21  # 21 = 3 * 7, so it's not prime\n    assert is_prime(non_prime_number) == False, f\"Test case 2 failed: {non_prime_number} is not a prime number.\"\n\n    # Test case 3: Test a number less than 2 (should not be prime)\n    less_than_two = 1\n    assert is_prime(less_than_two) == False, f\"Test case 3 failed: {less_than_two} is not a prime number.\"\n\n    # Test case 4: Test another prime number\n    another_prime_number = 97\n    assert is_prime(another_prime_number) == True, f\"Test case 4 failed: {another_prime_number} is a prime number.\"\n\n    # Test case 5: Test zero (should not be prime)\n    zero = 0\n    assert is_prime(zero) == False, f\"Test case 5 failed: {zero} is not a prime number.\"\n\n    print(\"All test cases passed.\")\n\n# Run the test function\ntest_is_prime()",
    "entry_point": "is_prime",
    "signature": "def is_prime(num: int) -> bool:",
    "docstring": {
      "en": "Determine whether a given integer is a prime number.\n\nA prime number is a natural number greater than 1 that has no positive divisors other than 1 and itself. The function checks for primality by eliminating non-prime numbers using several tests. First, it handles edge cases for numbers less than or equal to 1, which are not prime, and small numbers (2 and 3) which are prime. It then checks for divisibility by 2 and 3. For larger numbers, it uses a 6k +/- 1 optimization to test for factors up to the square root of the number.\n\nArgs:\nnum (int): The integer to check for primality.\n\nReturns:\nbool: True if `num` is a prime number, False otherwise.\n\nCases:\n- For num = 2 or num = 3, the function should return True, since both are prime numbers.\n- For num = 1 or num = 0, the function should return False, as neither is considered prime.\n- For num = 15, which is divisible by 3 and 5, the function should return False.\n- For num = 29, which has no divisors other than 1 and itself, the function should return True.",
      "es": "Determinar si un número entero dado es un número primo.\n\nUn número primo es un número natural mayor que 1 que no tiene divisores positivos aparte de 1 y sí mismo. La función verifica la primalidad eliminando números no primos utilizando varias pruebas. Primero, maneja casos especiales para números menores o iguales a 1, que no son primos, y números pequeños (2 y 3) que son primos. Luego verifica la divisibilidad por 2 y 3. Para números más grandes, utiliza una optimización de 6k +/- 1 para probar factores hasta la raíz cuadrada del número.\n\nArgumentos:\nnum (int): El entero a verificar para primalidad.\n\nDevuelve:\nbool: True si `num` es un número primo, False en caso contrario.\n\nCases:\n- Para num = 2 o num = 3, la función debería devolver True, ya que ambos son números primos.\n- Para num = 1 o num = 0, la función debería devolver False, ya que ninguno se considera primo.\n- Para num = 15, que es divisible por 3 y 5, la función debería devolver False.\n- Para num = 29, que no tiene divisores aparte de 1 y sí mismo, la función debería devolver True.",
      "arb": "تحديد ما إذا كان العدد الصحيح المعطى هو عدد أولي.\n\nالعدد الأولي هو عدد طبيعي أكبر من 1 وليس له قواسم موجبة أخرى غير 1 ونفسه. تقوم الدالة بالتحقق من الأولية عن طريق استبعاد الأعداد غير الأولية باستخدام عدة اختبارات. أولاً، تتعامل مع الحالات الخاصة للأعداد الأقل من أو تساوي 1، والتي ليست أولية، والأعداد الصغيرة (2 و3) التي هي أولية. ثم تتحقق من القابلية للقسمة على 2 و3. بالنسبة للأعداد الأكبر، تستخدم تحسين 6k +/- 1 لاختبار العوامل حتى الجذر التربيعي للعدد.\n\nالمعاملات:\nnum (int): العدد الصحيح للتحقق من أوليته.\n\nالقيم المعادة:\nbool: True إذا كان `num` عددًا أوليًا، False خلاف ذلك.\n\nالحالات:\n- بالنسبة لـ num = 2 أو num = 3، يجب أن تعيد الدالة True، حيث أن كلاهما عددان أوليان.\n- بالنسبة لـ num = 1 أو num = 0، يجب أن تعيد الدالة False، حيث لا يُعتبر أي منهما أوليًا.\n- بالنسبة لـ num = 15، الذي يقبل القسمة على 3 و5، يجب أن تعيد الدالة False.\n- بالنسبة لـ num = 29، الذي ليس له قواسم غير 1 ونفسه، يجب أن تعيد الدالة True.",
      "sw": "Kuamua kama nambari kamili iliyotolewa ni nambari ya kwanza.\n\nNambari ya kwanza ni nambari asilia kubwa kuliko 1 ambayo haina wagawanyaji chanya isipokuwa 1 na yenyewe. Kazi hii inakagua ikiwa ni ya kwanza kwa kuondoa nambari zisizo za kwanza kwa kutumia vipimo kadhaa. Kwanza, inashughulikia kesi maalum za nambari ndogo au sawa na 1, ambazo si za kwanza, na nambari ndogo (2 na 3) ambazo ni za kwanza. Kisha inakagua ugawanyiko kwa 2 na 3. Kwa nambari kubwa, inatumia mbinu ya 6k +/- 1 kupima vipengele hadi mzizi wa mraba wa nambari.\n\nHoja:\nnum (int): Nambari ya kuangalia ikiwa ni ya kwanza.\n\nInarejesha:\nbool: True ikiwa `num` ni nambari ya kwanza, False vinginevyo.\n\nCases:\n- Kwa num = 2 au num = 3, kazi inapaswa kurudisha True, kwa kuwa zote mbili ni nambari za kwanza.\n- Kwa num = 1 au num = 0, kazi inapaswa kurudisha False, kwa kuwa hakuna inayozingatiwa kuwa ya kwanza.\n- Kwa num = 15, ambayo inagawanyika kwa 3 na 5, kazi inapaswa kurudisha False.\n- Kwa num = 29, ambayo haina wagawanyaji isipokuwa 1 na yenyewe, kazi inapaswa kurudisha True.",
      "tr": "Belirtilen bir tam sayının asal sayı olup olmadığını belirleyin.\n\nAsal sayı, 1'den büyük ve 1 ile kendisi dışında pozitif böleni olmayan doğal sayıdır. Fonksiyon, asal olmayan sayıları birkaç test kullanarak eleyerek asal olup olmadığını kontrol eder. İlk olarak, asal olmayan 1 veya daha küçük sayılar ve asal olan küçük sayılar (2 ve 3) için özel durumları ele alır. Daha sonra 2 ve 3'e bölünebilirliği kontrol eder. Daha büyük sayılar için, sayının kareköküne kadar olan faktörleri test etmek için 6k +/- 1 optimizasyonunu kullanır.\n\nArgümanlar:\nnum (int): Asallığı kontrol edilecek tam sayı.\n\nDöndürür:\nbool: `num` bir asal sayı ise True, aksi takdirde False.\n\nDurumlar:\n- num = 2 veya num = 3 için, fonksiyon True döndürmelidir, çünkü her ikisi de asal sayıdır.\n- num = 1 veya num = 0 için, fonksiyon False döndürmelidir, çünkü hiçbiri asal kabul edilmez.\n- num = 15 için, 3 ve 5'e bölünebildiğinden, fonksiyon False döndürmelidir.\n- num = 29 için, 1 ve kendisi dışında böleni olmadığından, fonksiyon True döndürmelidir.",
      "vi": "Xác định xem một số nguyên cho trước có phải là số nguyên tố hay không.\n\nMột số nguyên tố là một số tự nhiên lớn hơn 1 không có ước số dương nào khác ngoài 1 và chính nó. Hàm kiểm tra tính nguyên tố bằng cách loại bỏ các số không phải nguyên tố thông qua một số phép thử. Đầu tiên, nó xử lý các trường hợp đặc biệt cho các số nhỏ hơn hoặc bằng 1, không phải là số nguyên tố, và các số nhỏ (2 và 3) là số nguyên tố. Sau đó, nó kiểm tra tính chia hết cho 2 và 3. Đối với các số lớn hơn, nó sử dụng tối ưu hóa 6k +/- 1 để kiểm tra các ước số lên đến căn bậc hai của số đó.\n\nTham số:\nnum (int): Số nguyên để kiểm tra tính nguyên tố.\n\nTrả về:\nbool: True nếu `num` là một số nguyên tố, False nếu không.\n\nCases:\n- Đối với num = 2 hoặc num = 3, hàm sẽ trả về True, vì cả hai đều là số nguyên tố.\n- Đối với num = 1 hoặc num = 0, hàm sẽ trả về False, vì cả hai đều không được coi là số nguyên tố.\n- Đối với num = 15, chia hết cho 3 và 5, hàm sẽ trả về False.\n- Đối với num = 29, không có ước số nào ngoài 1 và chính nó, hàm sẽ trả về True."
    },
    "docstring_bertscore": {
      "es": "0.9885437941434317",
      "arb": "0.980101804319068",
      "sw": "0.9829928695150308",
      "tr": "0.9653318478156948",
      "vi": "0.9696576202538726"
    }
  },
  {
    "task_id": "Python/31",
    "prompt": {
      "en": "from collections import deque\ndef generate_numbers(n, rules) -> int:\n    \"\"\"\n    Generate all unique numbers from the given number by applying transformation rules.\n\n    Each rule allows a single digit to be transformed into another. A breadth-first search\n    (BFS) is used to explore all possible transformations. The function returns the count\n    of unique numbers that can be generated from the original number, including the number itself.\n\n    Args:\n    - n (int): The original integer number to transform.\n    - rules (list of tuples): A list of transformation rules, where each rule is represented\n                              as a tuple (x, y) indicating that digit x can be transformed into y.\n\n    Returns:\n    - int: The total count of unique numbers that can be generated.\n\n    Cases:\n    - Case 1: n = 234, rules = [(2, 5), (3, 6)]\n              This case should return 4 because the following unique numbers can be generated:\n              234 (original), 534 (2 -> 5), 264 (3 -> 6), and 564 (2 -> 5, 3 -> 6).\n\n    - Case 2: n = 100, rules = [(1, 9)]\n              This case should return 2 because the following unique numbers can be generated:\n              100 (original) and 900 (1 -> 9).\n\n    - Case 3: n = 8, rules = [(8, 3), (8, 5)]\n              This case should return 3 because the following unique numbers can be generated:\n              8 (original), 3 (8 -> 3), and 5 (8 -> 5).\n    \"\"\"",
      "es": "from collections import deque\ndef generate_numbers(n, rules) -> int:\n    \"\"\"\n    Genera todos los números únicos a partir del número dado aplicando reglas de transformación.\n\n    Cada regla permite transformar un solo dígito en otro. Se utiliza una búsqueda en anchura\n    (BFS) para explorar todas las posibles transformaciones. La función devuelve el conteo\n    de números únicos que se pueden generar a partir del número original, incluyendo el número mismo.\n\n    Argumentos:\n    - n (int): El número entero original a transformar.\n    - rules (list of tuples): Una lista de reglas de transformación, donde cada regla se representa\n                              como una tupla (x, y) indicando que el dígito x puede transformarse en y.\n\n    Devuelve:\n    - int: El conteo total de números únicos que se pueden generar.\n\n    Casos:\n    - Caso 1: n = 234, rules = [(2, 5), (3, 6)]\n              Este caso debería devolver 4 porque se pueden generar los siguientes números únicos:\n              234 (original), 534 (2 -> 5), 264 (3 -> 6), y 564 (2 -> 5, 3 -> 6).\n\n    - Caso 2: n = 100, rules = [(1, 9)]\n              Este caso debería devolver 2 porque se pueden generar los siguientes números únicos:\n              100 (original) y 900 (1 -> 9).\n\n    - Caso 3: n = 8, rules = [(8, 3), (8, 5)]\n              Este caso debería devolver 3 porque se pueden generar los siguientes números únicos:\n              8 (original), 3 (8 -> 3), y 5 (8 -> 5).\n    \"\"\"",
      "arb": "from collections import deque\ndef generate_numbers(n, rules) -> int:\n    \"\"\"\n    توليد جميع الأرقام الفريدة من الرقم المعطى عن طريق تطبيق قواعد التحويل.\n\n    كل قاعدة تسمح بتحويل رقم واحد إلى آخر. يتم استخدام البحث بعرض أول (BFS)\n    لاستكشاف جميع التحويلات الممكنة. تُرجع الدالة عدد الأرقام الفريدة التي يمكن توليدها\n    من الرقم الأصلي، بما في ذلك الرقم نفسه.\n\n    يعيدالحجج:\n    - n (int): الرقم الصحيح الأصلي للتحويل.\n    - rules (list of tuples): قائمة بقواعد التحويل، حيث يتم تمثيل كل قاعدة\n                              كزوج (x, y) يشير إلى أن الرقم x يمكن تحويله إلى y.\n\n    يعيد:\n    - int: العدد الإجمالي للأرقام الفريدة التي يمكن توليدها.\n\n    حالات:\n    - الحالة 1: n = 234, rules = [(2, 5), (3, 6)]\n              يجب أن تُرجع هذه الحالة 4 لأن الأرقام الفريدة التالية يمكن توليدها:\n              234 (الأصلي), 534 (2 -> 5), 264 (3 -> 6), و 564 (2 -> 5, 3 -> 6).\n\n    - الحالة 2: n = 100, rules = [(1, 9)]\n              يجب أن تُرجع هذه الحالة 2 لأن الأرقام الفريدة التالية يمكن توليدها:\n              100 (الأصلي) و 900 (1 -> 9).\n\n    - الحالة 3: n = 8, rules = [(8, 3), (8, 5)]\n              يجب أن تُرجع هذه الحالة 3 لأن الأرقام الفريدة التالية يمكن توليدها:\n              8 (الأصلي), 3 (8 -> 3), و 5 (8 -> 5).\n    \"\"\"",
      "sw": "from collections import deque\ndef generate_numbers(n, rules) -> int:\n    \"\"\"\n    Tengeneza namba zote za kipekee kutoka kwa namba iliyotolewa kwa kutumia sheria za mabadiliko.\n\n    Kila sheria inaruhusu tarakimu moja kubadilishwa kuwa nyingine. Utafutaji wa upana kwanza\n    (BFS) unatumika kuchunguza mabadiliko yote yanayowezekana. Kazi inarudisha idadi\n    ya namba za kipekee ambazo zinaweza kutengenezwa kutoka kwa namba ya asili, ikiwa ni pamoja na namba yenyewe.\n\n    Hoja:\n    - n (int): Namba ya asili ya integer kubadilisha.\n    - rules (orodha ya jozi): Orodha ya sheria za mabadiliko, ambapo kila sheria inawakilishwa\n                              kama jozi (x, y) ikionyesha kwamba tarakimu x inaweza kubadilishwa kuwa y.\n\n    Inarudi:\n    - int: Jumla ya idadi ya namba za kipekee ambazo zinaweza kutengenezwa.\n\n    Matukio:\n    - Tukio 1: n = 234, rules = [(2, 5), (3, 6)]\n              Tukio hili linapaswa kurudisha 4 kwa sababu namba zifuatazo za kipekee zinaweza kutengenezwa:\n              234 (asili), 534 (2 -> 5), 264 (3 -> 6), na 564 (2 -> 5, 3 -> 6).\n\n    - Tukio 2: n = 100, rules = [(1, 9)]\n              Tukio hili linapaswa kurudisha 2 kwa sababu namba zifuatazo za kipekee zinaweza kutengenezwa:\n              100 (asili) na 900 (1 -> 9).\n\n    - Tukio 3: n = 8, rules = [(8, 3), (8, 5)]\n              Tukio hili linapaswa kurudisha 3 kwa sababu namba zifuatazo za kipekee zinaweza kutengenezwa:\n              8 (asili), 3 (8 -> 3), na 5 (8 -> 5).\n    \"\"\"",
      "tr": "from collections import deque\ndef generate_numbers(n, rules) -> int:\n    \"\"\"\n    Verilen sayıyı dönüştürme kurallarını uygulayarak tüm benzersiz sayıları oluştur.\n\n    Her kural, tek bir rakamın başka bir rakama dönüştürülmesine izin verir. Tüm olası\n    dönüşümleri keşfetmek için genişlik öncelikli arama (BFS) kullanılır. Fonksiyon, orijinal\n    sayı da dahil olmak üzere, orijinal sayıdan üretilebilecek benzersiz sayıların sayısını döndürür.\n\n    Argümanlar:\n    - n (int): Dönüştürülecek orijinal tamsayı.\n    - rules (list of tuples): Her bir kuralın bir (x, y) ikilisi olarak temsil edildiği dönüşüm\n                              kurallarının listesi, burada x rakamının y'ye dönüştürülebileceği belirtilir.\n\n    Döndürür:\n    - int: Üretilebilecek toplam benzersiz sayıların sayısı.\n\n    Durumlar:\n    - Durum 1: n = 234, rules = [(2, 5), (3, 6)]\n              Bu durum 4 döndürmelidir çünkü aşağıdaki benzersiz sayılar üretilebilir:\n              234 (orijinal), 534 (2 -> 5), 264 (3 -> 6) ve 564 (2 -> 5, 3 -> 6).\n\n    - Durum 2: n = 100, rules = [(1, 9)]\n              Bu durum 2 döndürmelidir çünkü aşağıdaki benzersiz sayılar üretilebilir:\n              100 (orijinal) ve 900 (1 -> 9).\n\n    - Durum 3: n = 8, rules = [(8, 3), (8, 5)]\n              Bu durum 3 döndürmelidir çünkü aşağıdaki benzersiz sayılar üretilebilir:\n              8 (orijinal), 3 (8 -> 3) ve 5 (8 -> 5).\n    \"\"\"",
      "vi": "from collections import deque\ndef generate_numbers(n, rules) -> int:\n    \"\"\"\n    Tạo tất cả các số duy nhất từ số đã cho bằng cách áp dụng các quy tắc biến đổi.\n\n    Mỗi quy tắc cho phép một chữ số được biến đổi thành chữ số khác. Tìm kiếm theo chiều rộng\n    (BFS) được sử dụng để khám phá tất cả các biến đổi có thể. Hàm trả về số lượng\n    các số duy nhất có thể được tạo ra từ số gốc, bao gồm cả số đó.\n\n    Tham số:\n    - n (int): Số nguyên ban đầu để biến đổi.\n    - rules (list of tuples): Danh sách các quy tắc biến đổi, trong đó mỗi quy tắc được biểu diễn\n                              dưới dạng một bộ (x, y) cho biết chữ số x có thể được biến đổi thành y.\n\n    Trả về:\n    - int: Tổng số các số duy nhất có thể được tạo ra.\n\n    Trường hợp:\n    - Trường hợp 1: n = 234, rules = [(2, 5), (3, 6)]\n              Trường hợp này nên trả về 4 vì các số duy nhất sau có thể được tạo ra:\n              234 (gốc), 534 (2 -> 5), 264 (3 -> 6), và 564 (2 -> 5, 3 -> 6).\n\n    - Trường hợp 2: n = 100, rules = [(1, 9)]\n              Trường hợp này nên trả về 2 vì các số duy nhất sau có thể được tạo ra:\n              100 (gốc) và 900 (1 -> 9).\n\n    - Trường hợp 3: n = 8, rules = [(8, 3), (8, 5)]\n              Trường hợp này nên trả về 3 vì các số duy nhất sau có thể được tạo ra:\n              8 (gốc), 3 (8 -> 3), và 5 (8 -> 5).\n    \"\"\""
    },
    "prompt_bertscore": {
      "es": "0.9935333893150282",
      "arb": "0.9733360562802577",
      "sw": "0.9558565827491875",
      "tr": "0.9727191103167633",
      "vi": "0.9806891543557882"
    },
    "canonical_solution": "    # Convert the input number n to a string for easier manipulation\n    str_n = str(n)\n    # Create a set to store all unique numbers generated\n    unique_numbers = {str_n}\n    # Use a queue to perform BFS on all possible transformations\n    queue = deque([str_n])\n    \n    while queue:\n        current = queue.popleft()\n        # Loop through each digit in the current number\n        for i in range(len(current)):\n            # Apply each rule to the digit if applicable\n            for x, y in rules:\n                if current[i] == str(x):\n                    # Generate the new number after transformation\n                    new_number = current[:i] + str(y) + current[i+1:]\n                    # If this number hasn't been seen before, add it to the set and queue\n                    if new_number not in unique_numbers:\n                        unique_numbers.add(new_number)\n                        queue.append(new_number)\n    \n    # Return the count of unique numbers generated\n    return len(unique_numbers)",
    "instruction": {
      "en": "def generate_numbers(n, rules) -> int:\n    # Convert the input number n to a string for easier manipulation\n    str_n = str(n)\n    # Create a set to store all unique numbers generated\n    unique_numbers = {str_n}\n    # Use a queue to perform BFS on all possible transformations\n    queue = deque([str_n])\n    \n    while queue:\n        current = queue.popleft()\n        # Loop through each digit in the current number\n        for i in range(len(current)):\n            # Apply each rule to the digit if applicable\n            for x, y in rules:\n                if current[i] == str(x):\n                    # Generate the new number after transformation\n                    new_number = current[:i] + str(y) + current[i+1:]\n                    # If this number hasn't been seen before, add it to the set and queue\n                    if new_number not in unique_numbers:\n                        unique_numbers.add(new_number)\n                        queue.append(new_number)\n    \n    # Return the count of unique numbers generated\n    return len(unique_numbers)\n\nProvide a concise natural language description (docstring) of the Python code in English using at most 500 characters.",
      "es": "def generate_numbers(n, rules) -> int:\n    # Convert the input number n to a string for easier manipulation\n    str_n = str(n)\n    # Create a set to store all unique numbers generated\n    unique_numbers = {str_n}\n    # Use a queue to perform BFS on all possible transformations\n    queue = deque([str_n])\n    \n    while queue:\n        current = queue.popleft()\n        # Loop through each digit in the current number\n        for i in range(len(current)):\n            # Apply each rule to the digit if applicable\n            for x, y in rules:\n                if current[i] == str(x):\n                    # Generate the new number after transformation\n                    new_number = current[:i] + str(y) + current[i+1:]\n                    # If this number hasn't been seen before, add it to the set and queue\n                    if new_number not in unique_numbers:\n                        unique_numbers.add(new_number)\n                        queue.append(new_number)\n    \n    # Return the count of unique numbers generated\n    return len(unique_numbers)\n\nProporcione una descripción concisa en lenguaje natural (docstring) del código Python en español utilizando como máximo 500 caracteres.",
      "arb": "def generate_numbers(n, rules) -> int:\n    # Convert the input number n to a string for easier manipulation\n    str_n = str(n)\n    # Create a set to store all unique numbers generated\n    unique_numbers = {str_n}\n    # Use a queue to perform BFS on all possible transformations\n    queue = deque([str_n])\n    \n    while queue:\n        current = queue.popleft()\n        # Loop through each digit in the current number\n        for i in range(len(current)):\n            # Apply each rule to the digit if applicable\n            for x, y in rules:\n                if current[i] == str(x):\n                    # Generate the new number after transformation\n                    new_number = current[:i] + str(y) + current[i+1:]\n                    # If this number hasn't been seen before, add it to the set and queue\n                    if new_number not in unique_numbers:\n                        unique_numbers.add(new_number)\n                        queue.append(new_number)\n    \n    # Return the count of unique numbers generated\n    return len(unique_numbers)\n\nيرجى تقديم وصف موجز بلغة طبيعية (docstring) للكود البرمجي بلغة بايثون باللغة العربية الفصحى، بحيث لا يتجاوز 500 حرف.",
      "sw": "def generate_numbers(n, rules) -> int:\n    # Convert the input number n to a string for easier manipulation\n    str_n = str(n)\n    # Create a set to store all unique numbers generated\n    unique_numbers = {str_n}\n    # Use a queue to perform BFS on all possible transformations\n    queue = deque([str_n])\n    \n    while queue:\n        current = queue.popleft()\n        # Loop through each digit in the current number\n        for i in range(len(current)):\n            # Apply each rule to the digit if applicable\n            for x, y in rules:\n                if current[i] == str(x):\n                    # Generate the new number after transformation\n                    new_number = current[:i] + str(y) + current[i+1:]\n                    # If this number hasn't been seen before, add it to the set and queue\n                    if new_number not in unique_numbers:\n                        unique_numbers.add(new_number)\n                        queue.append(new_number)\n    \n    # Return the count of unique numbers generated\n    return len(unique_numbers)\n\nToa maelezo mafupi ya lugha ya asili (docstring) ya msimbo wa Python kwa Kiswahili kwa kutumia herufi zisizozidi 500.",
      "tr": "def generate_numbers(n, rules) -> int:\n    # Convert the input number n to a string for easier manipulation\n    str_n = str(n)\n    # Create a set to store all unique numbers generated\n    unique_numbers = {str_n}\n    # Use a queue to perform BFS on all possible transformations\n    queue = deque([str_n])\n    \n    while queue:\n        current = queue.popleft()\n        # Loop through each digit in the current number\n        for i in range(len(current)):\n            # Apply each rule to the digit if applicable\n            for x, y in rules:\n                if current[i] == str(x):\n                    # Generate the new number after transformation\n                    new_number = current[:i] + str(y) + current[i+1:]\n                    # If this number hasn't been seen before, add it to the set and queue\n                    if new_number not in unique_numbers:\n                        unique_numbers.add(new_number)\n                        queue.append(new_number)\n    \n    # Return the count of unique numbers generated\n    return len(unique_numbers)\n\nVerilen Python kodunun işlevini açıklayan, en fazla 500 karakter uzunluğunda özlü bir doğal dil açıklaması (docstring) sağlayın.",
      "vi": "def generate_numbers(n, rules) -> int:\n    # Convert the input number n to a string for easier manipulation\n    str_n = str(n)\n    # Create a set to store all unique numbers generated\n    unique_numbers = {str_n}\n    # Use a queue to perform BFS on all possible transformations\n    queue = deque([str_n])\n    \n    while queue:\n        current = queue.popleft()\n        # Loop through each digit in the current number\n        for i in range(len(current)):\n            # Apply each rule to the digit if applicable\n            for x, y in rules:\n                if current[i] == str(x):\n                    # Generate the new number after transformation\n                    new_number = current[:i] + str(y) + current[i+1:]\n                    # If this number hasn't been seen before, add it to the set and queue\n                    if new_number not in unique_numbers:\n                        unique_numbers.add(new_number)\n                        queue.append(new_number)\n    \n    # Return the count of unique numbers generated\n    return len(unique_numbers)\n\nCung cấp mô tả ngắn gọn bằng ngôn ngữ tự nhiên (docstring) cho mã Python bằng tiếng Việt, sử dụng tối đa 500 ký tự."
    },
    "instruction_bertscore": {
      "es": "0.9687387561112052",
      "arb": "0.906469919330197",
      "sw": "0.914896018724078",
      "tr": "0.8508820154152974",
      "vi": "0.9506606106116958"
    },
    "level": "",
    "test": "def test_generate_numbers():\n    # Test case 1\n    n1, k1 = 234, 2\n    rules1 = [(2, 5), (3, 6)]\n    assert generate_numbers(n1, rules1) == 4, \"Test case 1 failed\"\n\n    # Test case 2\n    n2, k2 = 123, 3\n    rules2 = [(1, 9), (2, 8), (3, 7)]\n    assert generate_numbers(n2, rules2) == 8, \"Test case 2 failed\"\n\n    # Test case 3\n    n3, k3 = 999, 1\n    rules3 = [(9, 1)]\n    assert generate_numbers(n3, rules3) == 8, \"Test case 3 failed\"\n\n    print(\"All test cases passed!\")\n\n# Call the test function\ntest_generate_numbers()",
    "entry_point": "generate_numbers",
    "signature": "def generate_numbers(n, rules) -> int:",
    "docstring": {
      "en": "Generate all unique numbers from the given number by applying transformation rules.\n\nEach rule allows a single digit to be transformed into another. A breadth-first search\n(BFS) is used to explore all possible transformations. The function returns the count\nof unique numbers that can be generated from the original number, including the number itself.\n\nArgs:\n- n (int): The original integer number to transform.\n- rules (list of tuples): A list of transformation rules, where each rule is represented\nas a tuple (x, y) indicating that digit x can be transformed into y.\n\nReturns:\n- int: The total count of unique numbers that can be generated.\n\nCases:\n- Case 1: n = 234, rules = [(2, 5), (3, 6)]\nThis case should return 4 because the following unique numbers can be generated:\n234 (original), 534 (2 -> 5), 264 (3 -> 6), and 564 (2 -> 5, 3 -> 6).\n\n- Case 2: n = 100, rules = [(1, 9)]\nThis case should return 2 because the following unique numbers can be generated:\n100 (original) and 900 (1 -> 9).\n\n- Case 3: n = 8, rules = [(8, 3), (8, 5)]\nThis case should return 3 because the following unique numbers can be generated:\n8 (original), 3 (8 -> 3), and 5 (8 -> 5).",
      "es": "Generar todos los números únicos a partir del número dado aplicando reglas de transformación.\n\nCada regla permite que un solo dígito se transforme en otro. Se utiliza una búsqueda en amplitud\n(BFS) para explorar todas las posibles transformaciones. La función devuelve el conteo\nde números únicos que se pueden generar a partir del número original, incluido el número en sí.\n\nArgumentos:\n- n (int): El número entero original a transformar.\n- rules (list of tuples): Una lista de reglas de transformación, donde cada regla se representa\ncomo una tupla (x, y) indicando que el dígito x puede transformarse en y.\n\nDevuelve:\n- int: El conteo total de números únicos que se pueden generar.\n\nCases:\n- Case 1: n = 234, rules = [(2, 5), (3, 6)]\nEste caso debería devolver 4 porque se pueden generar los siguientes números únicos:\n234 (original), 534 (2 -> 5), 264 (3 -> 6), y 564 (2 -> 5, 3 -> 6).\n\n- Case 2: n = 100, rules = [(1, 9)]\nEste caso debería devolver 2 porque se pueden generar los siguientes números únicos:\n100 (original) y 900 (1 -> 9).\n\n- Case 3: n = 8, rules = [(8, 3), (8, 5)]\nEste caso debería devolver 3 porque se pueden generar los siguientes números únicos:\n8 (original), 3 (8 -> 3), y 5 (8 -> 5).",
      "arb": "توليد جميع الأرقام الفريدة من الرقم المعطى عن طريق تطبيق قواعد التحويل.\n\nتسمح كل قاعدة بتحويل رقم واحد إلى آخر. يتم استخدام البحث بعرض أول (BFS) لاستكشاف جميع التحويلات الممكنة. تقوم الدالة بإرجاع عدد الأرقام الفريدة التي يمكن توليدها من الرقم الأصلي، بما في ذلك الرقم نفسه.\n\nالمعطيات:\n- n (int): الرقم الصحيح الأصلي للتحويل.\n- rules (list of tuples): قائمة بقواعد التحويل، حيث يتم تمثيل كل قاعدة كزوج (x, y) يشير إلى أن الرقم x يمكن تحويله إلى y.\n\nالقيم المعادة:\n- int: العدد الإجمالي للأرقام الفريدة التي يمكن توليدها.\n\nالحالات:\n- الحالة 1: n = 234, rules = [(2, 5), (3, 6)]\nيجب أن تعيد هذه الحالة 4 لأن الأرقام الفريدة التالية يمكن توليدها:\n234 (الأصلي)، 534 (2 -> 5)، 264 (3 -> 6)، و 564 (2 -> 5, 3 -> 6).\n\n- الحالة 2: n = 100, rules = [(1, 9)]\nيجب أن تعيد هذه الحالة 2 لأن الأرقام الفريدة التالية يمكن توليدها:\n100 (الأصلي) و 900 (1 -> 9).\n\n- الحالة 3: n = 8, rules = [(8, 3), (8, 5)]\nيجب أن تعيد هذه الحالة 3 لأن الأرقام الفريدة التالية يمكن توليدها:\n8 (الأصلي)، 3 (8 -> 3)، و 5 (8 -> 5).",
      "sw": "Tengeneza namba zote za kipekee kutoka kwa namba iliyotolewa kwa kutumia sheria za mabadiliko.\n\nKila kanuni inaruhusu tarakimu moja kubadilishwa kuwa nyingine. Utafutaji wa upana-kwanza (BFS) unatumika kuchunguza mabadiliko yote yanayowezekana. Kazi inarudisha idadi ya nambari za kipekee ambazo zinaweza kuzalishwa kutoka kwa nambari ya asili, ikiwa ni pamoja na nambari yenyewe.\n\nHoja:\n- n (int): Nambari ya awali ya nambari nzima kubadilisha.\n- rules (list of tuples): Orodha ya kanuni za mabadiliko, ambapo kila kanuni inawakilishwa\nkama jozi (x, y) ikionyesha kwamba tarakimu x inaweza kubadilishwa kuwa y.\n\nInarejesha:\n- int: Jumla ya idadi ya nambari za kipekee ambazo zinaweza kuzalishwa.\n\nCases:\n- Case 1: n = 234, rules = [(2, 5), (3, 6)]\nKesi hii inapaswa kurudisha 4 kwa sababu nambari zifuatazo za kipekee zinaweza kuzalishwa:\n234 (asili), 534 (2 -> 5), 264 (3 -> 6), na 564 (2 -> 5, 3 -> 6).\n\n- Case 2: n = 100, rules = [(1, 9)]\nKesi hii inapaswa kurudisha 2 kwa sababu nambari zifuatazo za kipekee zinaweza kuzalishwa:\n100 (asili) na 900 (1 -> 9).\n\n- Case 3: n = 8, rules = [(8, 3), (8, 5)]\nKesi hii inapaswa kurudisha 3 kwa sababu nambari zifuatazo za kipekee zinaweza kuzalishwa:\n8 (asili), 3 (8 -> 3), na 5 (8 -> 5).",
      "tr": "Verilen sayıdan dönüşüm kurallarını uygulayarak tüm benzersiz sayıları oluşturun.\n\nHer kural, tek bir rakamın başka bir rakama dönüştürülmesine izin verir. Tüm olası dönüşümleri keşfetmek için genişlik öncelikli arama (BFS) kullanılır. Fonksiyon, orijinal sayı da dahil olmak üzere, orijinal sayıdan üretilebilecek benzersiz sayıların sayısını döndürür.\n\nArgümanlar:\n- n (int): Dönüştürülecek orijinal tam sayı.\n- rules (list of tuples): Her kuralın, x rakamının y'ye dönüştürülebileceğini belirten bir demet (x, y) olarak temsil edildiği dönüşüm kuralları listesi.\n\nDöndürür:\n- int: Üretilebilecek benzersiz sayıların toplam sayısı.\n\nDurumlar:\n- Durum 1: n = 234, rules = [(2, 5), (3, 6)]\nBu durum 4 döndürmelidir çünkü aşağıdaki benzersiz sayılar üretilebilir:\n234 (orijinal), 534 (2 -> 5), 264 (3 -> 6) ve 564 (2 -> 5, 3 -> 6).\n\n- Durum 2: n = 100, rules = [(1, 9)]\nBu durum 2 döndürmelidir çünkü aşağıdaki benzersiz sayılar üretilebilir:\n100 (orijinal) ve 900 (1 -> 9).\n\n- Durum 3: n = 8, rules = [(8, 3), (8, 5)]\nBu durum 3 döndürmelidir çünkü aşağıdaki benzersiz sayılar üretilebilir:\n8 (orijinal), 3 (8 -> 3) ve 5 (8 -> 5).",
      "vi": "Tạo tất cả các số duy nhất từ số đã cho bằng cách áp dụng các quy tắc biến đổi.\n\nMỗi quy tắc cho phép một chữ số được biến đổi thành chữ số khác. Tìm kiếm theo chiều rộng (BFS) được sử dụng để khám phá tất cả các biến đổi có thể. Hàm trả về số lượng các số duy nhất có thể được tạo ra từ số gốc, bao gồm cả số đó.\n\nTham số:\n- n (int): Số nguyên gốc để biến đổi.\n- rules (list of tuples): Danh sách các quy tắc biến đổi, trong đó mỗi quy tắc được biểu diễn\nnhư một bộ (x, y) chỉ ra rằng chữ số x có thể được biến đổi thành y.\n\nTrả về:\n- int: Tổng số các số duy nhất có thể được tạo ra.\n\nCases:\n- Case 1: n = 234, rules = [(2, 5), (3, 6)]\nTrường hợp này nên trả về 4 vì các số duy nhất sau có thể được tạo ra:\n234 (gốc), 534 (2 -> 5), 264 (3 -> 6), và 564 (2 -> 5, 3 -> 6).\n\n- Case 2: n = 100, rules = [(1, 9)]\nTrường hợp này nên trả về 2 vì các số duy nhất sau có thể được tạo ra:\n100 (gốc) và 900 (1 -> 9).\n\n- Case 3: n = 8, rules = [(8, 3), (8, 5)]\nTrường hợp này nên trả về 3 vì các số duy nhất sau có thể được tạo ra:\n8 (gốc), 3 (8 -> 3), và 5 (8 -> 5)."
    },
    "docstring_bertscore": {
      "es": "0.9999996027392379",
      "arb": "0.9686457970928808",
      "sw": "0.9808170723211747",
      "tr": "0.9858054757104848",
      "vi": "0.972574904660132"
    }
  },
  {
    "task_id": "Python/32",
    "prompt": {
      "en": "def check_scenario(scenario: str, liar_count: set, statements: dict, days_of_week: set) -> bool:\n    \"\"\"\n    Evaluates the consistency of a scenario where one participant is the criminal based on the given statements.\n\n    This function takes a potential criminal's name (scenario) and a set of liars (liar_count) and checks if\n    the statements made by all participants are consistent with this scenario, disregarding any statements\n    about the day of the week.\n\n    Parameters:\n    - scenario (str): The name of the participant being tested as the potential criminal.\n    - liar_count (set): A set of names of participants who are assumed to be liars.\n    - statements (dict): A dictionary mapping participant names to lists of their respective statements.\n    - days_of_week (set): A set of strings representing the days of the week.\n\n    Returns:\n    - bool: True if the scenario is consistent with the statements, False otherwise.\n\n    Test Cases:\n    - Given a scenario where \"ALICE\" is the criminal, and \"BOB\" and \"CHARLIE\" are liars, the function should return\n      True if \"ALICE\" says \"I am guilty.\", \"BOB\" says \"ALICE is not guilty.\", and \"CHARLIE\" makes no relevant statements.\n\n    - Given a scenario where \"ALICE\" is the criminal, and \"BOB\" and \"CHARLIE\" are liars, the function should return\n      False if \"ALICE\" says \"I am not guilty.\", \"BOB\" says \"ALICE is guilty.\", which contradicts the scenario.\n\n    - Given a scenario where \"ALICE\" is the criminal, and \"BOB\" and \"CHARLIE\" are liars, the function should return\n      True if \"ALICE\" says \"I am guilty.\", \"BOB\" says \"Today is MONDAY\", and \"CHARLIE\" says \"ALICE is guilty.\",\n      since statements about the day of the week are ignored.\n    \"\"\"\n    # Function implementation...",
      "es": "def check_scenario(scenario: str, liar_count: set, statements: dict, days_of_week: set) -> bool:\n    \"\"\"\n    Evalúa la consistencia de un escenario donde un participante es el criminal basado en las declaraciones dadas.\n\n    Esta función toma el nombre de un posible criminal (scenario) y un conjunto de mentirosos (liar_count) y verifica si\n    las declaraciones hechas por todos los participantes son consistentes con este escenario, ignorando cualquier declaración\n    sobre el día de la semana.\n\n    Parámetros:\n    - scenario (str): El nombre del participante que se está probando como el posible criminal.\n    - liar_count (set): Un conjunto de nombres de participantes que se asumen como mentirosos.\n    - statements (dict): Un diccionario que mapea nombres de participantes a listas de sus respectivas declaraciones.\n    - days_of_week (set): Un conjunto de cadenas que representan los días de la semana.\n\n    Retorna:\n    - bool: True si el escenario es consistente con las declaraciones, False en caso contrario.\n\n    Casos de Prueba:\n    - Dado un escenario donde \"ALICE\" es el criminal, y \"BOB\" y \"CHARLIE\" son mentirosos, la función debería retornar\n      True si \"ALICE\" dice \"I am guilty.\", \"BOB\" dice \"ALICE is not guilty.\", y \"CHARLIE\" no hace declaraciones relevantes.\n\n    - Dado un escenario donde \"ALICE\" es el criminal, y \"BOB\" y \"CHARLIE\" son mentirosos, la función debería retornar\n      False si \"ALICE\" dice \"I am not guilty.\", \"BOB\" dice \"ALICE is guilty.\", lo cual contradice el escenario.\n\n    - Dado un escenario donde \"ALICE\" es el criminal, y \"BOB\" y \"CHARLIE\" son mentirosos, la función debería retornar\n      True si \"ALICE\" dice \"I am guilty.\", \"BOB\" dice \"Today is MONDAY\", y \"CHARLIE\" dice \"ALICE is guilty.\",\n      ya que las declaraciones sobre el día de la semana se ignoran.\n    \"\"\"\n    # Implementación de la función...",
      "arb": "def check_scenario(scenario: str, liar_count: set, statements: dict, days_of_week: set) -> bool:\n    \"\"\"\n    يقيم اتساق سيناريو حيث يكون أحد المشاركين هو المجرم بناءً على التصريحات المعطاة.\n\n    تأخذ هذه الدالة اسم المجرم المحتمل (scenario) ومجموعة من الكاذبين (liar_count) وتتحقق مما إذا كانت\n    التصريحات التي أدلى بها جميع المشاركين متسقة مع هذا السيناريو، متجاهلة أي تصريحات\n    حول يوم الأسبوع.\n\n    المعاملات:\n    - scenario (str): اسم المشارك الذي يتم اختباره كمجرم محتمل.\n    - liar_count (set): مجموعة من أسماء المشاركين الذين يُفترض أنهم كاذبون.\n    - statements (dict): قاموس يربط أسماء المشاركين بقوائم تصريحاتهم الخاصة.\n    - days_of_week (set): مجموعة من السلاسل النصية التي تمثل أيام الأسبوع.\n\n    يعيد:\n    - bool: True إذا كان السيناريو متسقًا مع التصريحات، False خلاف ذلك.\n\n    حالات الاختبار:\n    - بالنظر إلى سيناريو حيث \"ALICE\" هي المجرمة، و \"BOB\" و \"CHARLIE\" هما الكاذبان، يجب أن تعيد الدالة\n      True إذا قالت \"ALICE\" \"I am guilty.\"، وقال \"BOB\" \"ALICE is not guilty.\"، ولم يقدم \"CHARLIE\" أي تصريحات ذات صلة.\n\n    - بالنظر إلى سيناريو حيث \"ALICE\" هي المجرمة، و \"BOB\" و \"CHARLIE\" هما الكاذبان، يجب أن تعيد الدالة\n      False إذا قالت \"ALICE\" \"I am not guilty.\"، وقال \"BOB\" \"ALICE is guilty.\"، مما يتناقض مع السيناريو.\n\n    - بالنظر إلى سيناريو حيث \"ALICE\" هي المجرمة، و \"BOB\" و \"CHARLIE\" هما الكاذبان، يجب أن تعيد الدالة\n      True إذا قالت \"ALICE\" \"I am guilty.\"، وقال \"BOB\" \"Today is MONDAY\"، وقال \"CHARLIE\" \"ALICE is guilty.\"،\n      حيث يتم تجاهل التصريحات حول يوم الأسبوع.\n    \"\"\"\n    # Function implementation...",
      "sw": "def check_scenario(scenario: str, liar_count: set, statements: dict, days_of_week: set) -> bool:\n    \"\"\"\n    Inatathmini uthabiti wa hali ambapo mshiriki mmoja ni mhalifu kulingana na kauli zilizotolewa.\n\n    Kazi hii inachukua jina la mhalifu anayewezekana (scenario) na seti ya waongo (liar_count) na inakagua\n    kama kauli zilizotolewa na washiriki wote zinakubaliana na hali hii, bila kujali kauli zozote kuhusu siku ya wiki.\n\n    Vigezo:\n    - scenario (str): Jina la mshiriki anayepimwa kama mhalifu anayewezekana.\n    - liar_count (set): Seti ya majina ya washiriki wanaodhaniwa kuwa waongo.\n    - statements (dict): Kamusi inayochanganua majina ya washiriki na orodha za kauli zao husika.\n    - days_of_week (set): Seti ya misururu inayowakilisha siku za wiki.\n\n    Inarudisha:\n    - bool: Kweli ikiwa hali inakubaliana na kauli, Si kweli vinginevyo.\n\n    Visa vya Majaribio:\n    - Ikitolewa hali ambapo \"ALICE\" ni mhalifu, na \"BOB\" na \"CHARLIE\" ni waongo, kazi inapaswa kurudisha\n      Kweli ikiwa \"ALICE\" anasema \"I am guilty.\", \"BOB\" anasema \"ALICE is not guilty.\", na \"CHARLIE\" hafanyi kauli zozote husika.\n\n    - Ikitolewa hali ambapo \"ALICE\" ni mhalifu, na \"BOB\" na \"CHARLIE\" ni waongo, kazi inapaswa kurudisha\n      Si kweli ikiwa \"ALICE\" anasema \"I am not guilty.\", \"BOB\" anasema \"ALICE is guilty.\", ambayo inapingana na hali hiyo.\n\n    - Ikitolewa hali ambapo \"ALICE\" ni mhalifu, na \"BOB\" na \"CHARLIE\" ni waongo, kazi inapaswa kurudisha\n      Kweli ikiwa \"ALICE\" anasema \"I am guilty.\", \"BOB\" anasema \"Today is MONDAY\", na \"CHARLIE\" anasema \"ALICE is guilty.\",\n      kwa kuwa kauli kuhusu siku ya wiki zinapuuzwa.\n    \"\"\"\n    # Function implementation...",
      "tr": "def check_scenario(scenario: str, liar_count: set, statements: dict, days_of_week: set) -> bool:\n    \"\"\"\n    Verilen ifadeler temelinde bir katılımcının suçlu olduğu bir senaryonun tutarlılığını değerlendirir.\n\n    Bu fonksiyon, potansiyel suçlunun adını (senaryo) ve yalancıların bir kümesini (liar_count) alır ve\n    haftanın günü hakkındaki ifadeleri göz ardı ederek, tüm katılımcıların yaptığı ifadelerin bu senaryoyla\n    tutarlı olup olmadığını kontrol eder.\n\n    Parametreler:\n    - scenario (str): Potansiyel suçlu olarak test edilen katılımcının adı.\n    - liar_count (set): Yalancı olduğu varsayılan katılımcıların adlarının bulunduğu bir küme.\n    - statements (dict): Katılımcı adlarını, onların ilgili ifadelerinin listelerine eşleyen bir sözlük.\n    - days_of_week (set): Haftanın günlerini temsil eden stringlerin bulunduğu bir küme.\n\n    Döndürür:\n    - bool: Senaryo ifadelerle tutarlıysa True, aksi takdirde False.\n\n    Test Durumları:\n    - \"ALICE\" suçlu olduğu bir senaryo verildiğinde ve \"BOB\" ve \"CHARLIE\" yalancı olduğunda, fonksiyon\n      \"ALICE\" \"Ben suçluyum.\" derse, \"BOB\" \"ALICE suçlu değil.\" derse ve \"CHARLIE\" ilgili bir ifade yapmazsa\n      True döndürmelidir.\n\n    - \"ALICE\" suçlu olduğu bir senaryo verildiğinde ve \"BOB\" ve \"CHARLIE\" yalancı olduğunda, fonksiyon\n      \"ALICE\" \"Ben suçlu değilim.\" derse, \"BOB\" \"ALICE suçlu.\" derse, bu senaryoyla çeliştiği için\n      False döndürmelidir.\n\n    - \"ALICE\" suçlu olduğu bir senaryo verildiğinde ve \"BOB\" ve \"CHARLIE\" yalancı olduğunda, fonksiyon\n      \"ALICE\" \"Ben suçluyum.\" derse, \"BOB\" \"Bugün PAZARTESİ\" derse ve \"CHARLIE\" \"ALICE suçlu.\" derse,\n      haftanın günü hakkındaki ifadeler göz ardı edildiği için True döndürmelidir.\n    \"\"\"\n    # Function implementation...",
      "vi": "def check_scenario(scenario: str, liar_count: set, statements: dict, days_of_week: set) -> bool:\n    \"\"\"\n    Đánh giá tính nhất quán của một kịch bản nơi một người tham gia là tội phạm dựa trên các tuyên bố đã cho.\n\n    Hàm này nhận tên của một người có thể là tội phạm (scenario) và một tập hợp những người nói dối (liar_count) và kiểm tra xem\n    các tuyên bố được đưa ra bởi tất cả những người tham gia có nhất quán với kịch bản này không, bỏ qua bất kỳ tuyên bố nào\n    về ngày trong tuần.\n\n    Tham số:\n    - scenario (str): Tên của người tham gia đang được kiểm tra như là tội phạm tiềm năng.\n    - liar_count (set): Một tập hợp tên của những người tham gia được cho là nói dối.\n    - statements (dict): Một từ điển ánh xạ tên người tham gia tới danh sách các tuyên bố tương ứng của họ.\n    - days_of_week (set): Một tập hợp các chuỗi đại diện cho các ngày trong tuần.\n\n    Trả về:\n    - bool: True nếu kịch bản nhất quán với các tuyên bố, False nếu không.\n\n    Các trường hợp kiểm tra:\n    - Với một kịch bản nơi \"ALICE\" là tội phạm, và \"BOB\" và \"CHARLIE\" là những người nói dối, hàm nên trả về\n      True nếu \"ALICE\" nói \"I am guilty.\", \"BOB\" nói \"ALICE is not guilty.\", và \"CHARLIE\" không đưa ra tuyên bố liên quan nào.\n\n    - Với một kịch bản nơi \"ALICE\" là tội phạm, và \"BOB\" và \"CHARLIE\" là những người nói dối, hàm nên trả về\n      False nếu \"ALICE\" nói \"I am not guilty.\", \"BOB\" nói \"ALICE is guilty.\", điều này mâu thuẫn với kịch bản.\n\n    - Với một kịch bản nơi \"ALICE\" là tội phạm, và \"BOB\" và \"CHARLIE\" là những người nói dối, hàm nên trả về\n      True nếu \"ALICE\" nói \"I am guilty.\", \"BOB\" nói \"Today is MONDAY\", và \"CHARLIE\" nói \"ALICE is guilty.\",\n      vì các tuyên bố về ngày trong tuần bị bỏ qua.\n    \"\"\"\n    # Function implementation..."
    },
    "prompt_bertscore": {
      "es": "0.9903457689601803",
      "arb": "0.9723041714507814",
      "sw": "0.9692653252513287",
      "tr": "0.9637126129494984",
      "vi": "0.9632343109919663"
    },
    "canonical_solution": "    for name, stmts in statements.items():\n        for stmt in stmts:\n            if stmt in days_of_week:\n                continue  # Ignoring statements about the day of the week\n            if \"I am guilty.\" == stmt:\n                if (name != scenario) != (name in liar_count):\n                    return False\n            elif \"I am not guilty.\" == stmt:\n                if (name == scenario) != (name in liar_count):\n                    return False\n            elif \" is guilty.\" in stmt:\n                other = stmt.replace(\" is guilty.\", \"\")\n                if (other != scenario) != (name in liar_count):\n                    return False\n            elif \" is not guilty.\" in stmt:\n                other = stmt.replace(\" is not guilty.\", \"\")\n                if (other == scenario) != (name in liar_count):\n                    return False\n    return True",
    "instruction": {
      "en": "def check_scenario(scenario: str, liar_count: set, statements: dict, days_of_week: set) -> bool:\n    for name, stmts in statements.items():\n        for stmt in stmts:\n            if stmt in days_of_week:\n                continue  # Ignoring statements about the day of the week\n            if \"I am guilty.\" == stmt:\n                if (name != scenario) != (name in liar_count):\n                    return False\n            elif \"I am not guilty.\" == stmt:\n                if (name == scenario) != (name in liar_count):\n                    return False\n            elif \" is guilty.\" in stmt:\n                other = stmt.replace(\" is guilty.\", \"\")\n                if (other != scenario) != (name in liar_count):\n                    return False\n            elif \" is not guilty.\" in stmt:\n                other = stmt.replace(\" is not guilty.\", \"\")\n                if (other == scenario) != (name in liar_count):\n                    return False\n    return True\n\nProvide a concise natural language description (docstring) of the Python code in English using at most 500 characters.",
      "es": "def check_scenario(scenario: str, liar_count: set, statements: dict, days_of_week: set) -> bool:\n    for name, stmts in statements.items():\n        for stmt in stmts:\n            if stmt in days_of_week:\n                continue  # Ignoring statements about the day of the week\n            if \"I am guilty.\" == stmt:\n                if (name != scenario) != (name in liar_count):\n                    return False\n            elif \"I am not guilty.\" == stmt:\n                if (name == scenario) != (name in liar_count):\n                    return False\n            elif \" is guilty.\" in stmt:\n                other = stmt.replace(\" is guilty.\", \"\")\n                if (other != scenario) != (name in liar_count):\n                    return False\n            elif \" is not guilty.\" in stmt:\n                other = stmt.replace(\" is not guilty.\", \"\")\n                if (other == scenario) != (name in liar_count):\n                    return False\n    return True\n\nProporciona una descripción concisa en lenguaje natural (docstring) del código Python en español utilizando como máximo 500 caracteres.",
      "arb": "def check_scenario(scenario: str, liar_count: set, statements: dict, days_of_week: set) -> bool:\n    for name, stmts in statements.items():\n        for stmt in stmts:\n            if stmt in days_of_week:\n                continue  # Ignoring statements about the day of the week\n            if \"I am guilty.\" == stmt:\n                if (name != scenario) != (name in liar_count):\n                    return False\n            elif \"I am not guilty.\" == stmt:\n                if (name == scenario) != (name in liar_count):\n                    return False\n            elif \" is guilty.\" in stmt:\n                other = stmt.replace(\" is guilty.\", \"\")\n                if (other != scenario) != (name in liar_count):\n                    return False\n            elif \" is not guilty.\" in stmt:\n                other = stmt.replace(\" is not guilty.\", \"\")\n                if (other == scenario) != (name in liar_count):\n                    return False\n    return True\n\nيرجى تقديم وصف موجز بلغة طبيعية (docstring) للشفرة البرمجية بلغة بايثون باللغة العربية الفصحى، بحيث لا يتجاوز 500 حرف.",
      "sw": "def check_scenario(scenario: str, liar_count: set, statements: dict, days_of_week: set) -> bool:\n    for name, stmts in statements.items():\n        for stmt in stmts:\n            if stmt in days_of_week:\n                continue  # Ignoring statements about the day of the week\n            if \"I am guilty.\" == stmt:\n                if (name != scenario) != (name in liar_count):\n                    return False\n            elif \"I am not guilty.\" == stmt:\n                if (name == scenario) != (name in liar_count):\n                    return False\n            elif \" is guilty.\" in stmt:\n                other = stmt.replace(\" is guilty.\", \"\")\n                if (other != scenario) != (name in liar_count):\n                    return False\n            elif \" is not guilty.\" in stmt:\n                other = stmt.replace(\" is not guilty.\", \"\")\n                if (other == scenario) != (name in liar_count):\n                    return False\n    return True\n\nToa maelezo mafupi ya lugha ya asili (docstring) ya msimbo wa Python kwa Kiswahili kwa kutumia herufi zisizozidi 500.",
      "tr": "def check_scenario(scenario: str, liar_count: set, statements: dict, days_of_week: set) -> bool:\n    for name, stmts in statements.items():\n        for stmt in stmts:\n            if stmt in days_of_week:\n                continue  # Ignoring statements about the day of the week\n            if \"I am guilty.\" == stmt:\n                if (name != scenario) != (name in liar_count):\n                    return False\n            elif \"I am not guilty.\" == stmt:\n                if (name == scenario) != (name in liar_count):\n                    return False\n            elif \" is guilty.\" in stmt:\n                other = stmt.replace(\" is guilty.\", \"\")\n                if (other != scenario) != (name in liar_count):\n                    return False\n            elif \" is not guilty.\" in stmt:\n                other = stmt.replace(\" is not guilty.\", \"\")\n                if (other == scenario) != (name in liar_count):\n                    return False\n    return True\n\nPython kodunun işlevini açıklayan, en fazla 500 karakter uzunluğunda, özlü bir doğal dil açıklaması (docstring) sağlayın.",
      "vi": "def check_scenario(scenario: str, liar_count: set, statements: dict, days_of_week: set) -> bool:\n    for name, stmts in statements.items():\n        for stmt in stmts:\n            if stmt in days_of_week:\n                continue  # Ignoring statements about the day of the week\n            if \"I am guilty.\" == stmt:\n                if (name != scenario) != (name in liar_count):\n                    return False\n            elif \"I am not guilty.\" == stmt:\n                if (name == scenario) != (name in liar_count):\n                    return False\n            elif \" is guilty.\" in stmt:\n                other = stmt.replace(\" is guilty.\", \"\")\n                if (other != scenario) != (name in liar_count):\n                    return False\n            elif \" is not guilty.\" in stmt:\n                other = stmt.replace(\" is not guilty.\", \"\")\n                if (other == scenario) != (name in liar_count):\n                    return False\n    return True\n\nCung cấp mô tả ngắn gọn bằng ngôn ngữ tự nhiên (docstring) cho mã Python bằng tiếng Việt, sử dụng tối đa 500 ký tự."
    },
    "instruction_bertscore": {
      "es": "0.9687387561112052",
      "arb": "0.906469919330197",
      "sw": "0.9095743135553913",
      "tr": "0.8708032522204294",
      "vi": "0.9256256346468206"
    },
    "level": "",
    "test": "def test_check_scenario():\n    # Define a set of days of the week for the test cases\n    days_of_week = set([\"MONDAY\", \"TUESDAY\", \"WEDNESDAY\", \"THURSDAY\", \"FRIDAY\", \"SATURDAY\", \"SUNDAY\"])\n\n    # Test case 1: Simple case where the scenario is correct\n    statements_test1 = {\n        \"ALICE\": [\"I am not guilty.\", \"BOB is guilty.\"],\n        \"BOB\": [\"ALICE is not guilty.\", \"Today is MONDAY\"],\n        \"CHARLIE\": [\"I am guilty.\"]\n    }\n    scenario_test1 = \"CHARLIE\"\n    liar_count_test1 = {\"ALICE\", \"BOB\"}\n    assert check_scenario(scenario_test1, liar_count_test1, statements_test1, days_of_week) == False, \"Test case 1 failed\"\n\n    # Test case 2: Scenario with contradictory statements\n    statements_test2 = {\n        \"ALICE\": [\"I am guilty.\"],\n        \"BOB\": [\"I am not guilty.\", \"ALICE is guilty.\"],\n        \"CHARLIE\": [\"I am not guilty.\", \"Today is TUESDAY\"]\n    }\n    scenario_test2 = \"ALICE\"\n    liar_count_test2 = {\"BOB\", \"CHARLIE\"}\n    assert check_scenario(scenario_test2, liar_count_test2, statements_test2, days_of_week) == False, \"Test case 2 failed\"\n\n    # Test case 3: Scenario where the statements are ambiguous\n    statements_test3 = {\n        \"ALICE\": [\"I am not guilty.\", \"Today is WEDNESDAY\"],\n        \"BOB\": [\"I am not guilty.\", \"CHARLIE is guilty.\"],\n        \"CHARLIE\": [\"BOB is not guilty.\"]\n    }\n    scenario_test3 = \"BOB\"\n    liar_count_test3 = {\"ALICE\", \"CHARLIE\"}\n    assert check_scenario(scenario_test3, liar_count_test3, statements_test3, days_of_week) == False, \"Test case 3 failed\"\n\n    print(\"All test cases passed.\")\n\n# Run the test function\ntest_check_scenario()",
    "entry_point": "check_scenario",
    "signature": "def check_scenario(scenario: str, liar_count: set, statements: dict, days_of_week: set) -> bool:",
    "docstring": {
      "en": "Evaluates the consistency of a scenario where one participant is the criminal based on the given statements.\n\nThis function takes a potential criminal's name (scenario) and a set of liars (liar_count) and checks if\nthe statements made by all participants are consistent with this scenario, disregarding any statements\nabout the day of the week.\n\nParameters:\n- scenario (str): The name of the participant being tested as the potential criminal.\n- liar_count (set): A set of names of participants who are assumed to be liars.\n- statements (dict): A dictionary mapping participant names to lists of their respective statements.\n- days_of_week (set): A set of strings representing the days of the week.\n\nReturns:\n- bool: True if the scenario is consistent with the statements, False otherwise.\n\nTest Cases:\n- Given a scenario where \"ALICE\" is the criminal, and \"BOB\" and \"CHARLIE\" are liars, the function should return\nTrue if \"ALICE\" says \"I am guilty.\", \"BOB\" says \"ALICE is not guilty.\", and \"CHARLIE\" makes no relevant statements.\n\n- Given a scenario where \"ALICE\" is the criminal, and \"BOB\" and \"CHARLIE\" are liars, the function should return\nFalse if \"ALICE\" says \"I am not guilty.\", \"BOB\" says \"ALICE is guilty.\", which contradicts the scenario.\n\n- Given a scenario where \"ALICE\" is the criminal, and \"BOB\" and \"CHARLIE\" are liars, the function should return\nTrue if \"ALICE\" says \"I am guilty.\", \"BOB\" says \"Today is MONDAY\", and \"CHARLIE\" says \"ALICE is guilty.\",\nsince statements about the day of the week are ignored.",
      "es": "Evalúa la consistencia de un escenario donde un participante es el criminal basado en las declaraciones dadas.\n\nEsta función toma el nombre de un posible criminal (scenario) y un conjunto de mentirosos (liar_count) y verifica si\nlas declaraciones hechas por todos los participantes son consistentes con este escenario, ignorando cualquier declaración\nsobre el día de la semana.\n\nParámetros:\n- scenario (str): El nombre del participante que se está probando como el posible criminal.\n- liar_count (set): Un conjunto de nombres de participantes que se asumen como mentirosos.\n- statements (dict): Un diccionario que mapea nombres de participantes a listas de sus respectivas declaraciones.\n- days_of_week (set): Un conjunto de cadenas que representan los días de la semana.\n\nDevuelve:\n- bool: True si el escenario es consistente con las declaraciones, False en caso contrario.\n\nCasos de Prueba:\n- Dado un escenario donde \"ALICE\" es el criminal, y \"BOB\" y \"CHARLIE\" son mentirosos, la función debería devolver\nTrue si \"ALICE\" dice \"I am guilty.\", \"BOB\" dice \"ALICE is not guilty.\", y \"CHARLIE\" no hace declaraciones relevantes.\n\n- Dado un escenario donde \"ALICE\" es el criminal, y \"BOB\" y \"CHARLIE\" son mentirosos, la función debería devolver\nFalse si \"ALICE\" dice \"I am not guilty.\", \"BOB\" dice \"ALICE is guilty.\", lo cual contradice el escenario.\n\n- Dado un escenario donde \"ALICE\" es el criminal, y \"BOB\" y \"CHARLIE\" son mentirosos, la función debería devolver\nTrue si \"ALICE\" dice \"I am guilty.\", \"BOB\" dice \"Today is MONDAY\", y \"CHARLIE\" dice \"ALICE is guilty.\",\nya que las declaraciones sobre el día de la semana son ignoradas.",
      "arb": "يقيم اتساق سيناريو حيث يكون أحد المشاركين هو المجرم بناءً على البيانات المقدمة.\n\nتأخذ هذه الدالة اسم المجرم المحتمل (scenario) ومجموعة من الكاذبين (liar_count) وتتحقق مما إذا كانت\nالبيانات التي أدلى بها جميع المشاركين متسقة مع هذا السيناريو، متجاهلة أي بيانات\nحول يوم الأسبوع.\n\nالمعلمات:\n- scenario (str): اسم المشارك الذي يتم اختباره كمجرم محتمل.\n- liar_count (set): مجموعة من أسماء المشاركين الذين يُفترض أنهم كاذبون.\n- statements (dict): قاموس يربط أسماء المشاركين بقوائم بياناتهم الخاصة.\n- days_of_week (set): مجموعة من السلاسل النصية التي تمثل أيام الأسبوع.\n\nالقيم المعادة:\n- bool: True إذا كان السيناريو متسقًا مع البيانات، False خلاف ذلك.\n\nحالات الاختبار:\n- بالنظر إلى سيناريو حيث \"ALICE\" هي المجرمة، و\"BOB\" و\"CHARLIE\" هما الكاذبان، يجب أن تعيد الدالة\nTrue إذا قالت \"ALICE\" \"I am guilty.\"، وقال \"BOB\" \"ALICE is not guilty.\"، ولم يقم \"CHARLIE\" بأي بيانات ذات صلة.\n\n- بالنظر إلى سيناريو حيث \"ALICE\" هي المجرمة، و\"BOB\" و\"CHARLIE\" هما الكاذبان، يجب أن تعيد الدالة\nFalse إذا قالت \"ALICE\" \"I am not guilty.\"، وقال \"BOB\" \"ALICE is guilty.\"، مما يتناقض مع السيناريو.\n\n- بالنظر إلى سيناريو حيث \"ALICE\" هي المجرمة، و\"BOB\" و\"CHARLIE\" هما الكاذبان، يجب أن تعيد الدالة\nTrue إذا قالت \"ALICE\" \"I am guilty.\"، وقال \"BOB\" \"Today is MONDAY\"، وقال \"CHARLIE\" \"ALICE is guilty.\"،\nحيث يتم تجاهل البيانات حول يوم الأسبوع.",
      "sw": "Inatathmini uthabiti wa tukio ambapo mshiriki mmoja ni mhalifu kulingana na taarifa zilizotolewa.\n\nKazi hii inachukua jina la mhalifu anayewezekana (scenario) na seti ya waongo (liar_count) na inakagua kama\ntaarifa zilizotolewa na washiriki wote zinakubaliana na tukio hili, bila kujali taarifa zozote\nkuhusu siku ya wiki.\n\nVigezo:\n- scenario (str): Jina la mshiriki anayepimwa kama mhalifu anayewezekana.\n- liar_count (set): Seti ya majina ya washiriki wanaodhaniwa kuwa waongo.\n- statements (dict): Kamusi inayochanganua majina ya washiriki na orodha za taarifa zao husika.\n- days_of_week (set): Seti ya mistari inayowakilisha siku za wiki.\n\nInarejesha:\n- bool: Kweli ikiwa tukio linakubaliana na taarifa, Si kweli vinginevyo.\n\nMifano ya Majaribio:\n- Ikitolewa tukio ambapo \"ALICE\" ni mhalifu, na \"BOB\" na \"CHARLIE\" ni waongo, kazi inapaswa kurejesha\nKweli ikiwa \"ALICE\" anasema \"I am guilty.\", \"BOB\" anasema \"ALICE is not guilty.\", na \"CHARLIE\" hafanyi taarifa yoyote husika.\n\n- Ikitolewa tukio ambapo \"ALICE\" ni mhalifu, na \"BOB\" na \"CHARLIE\" ni waongo, kazi inapaswa kurejesha\nSi kweli ikiwa \"ALICE\" anasema \"I am not guilty.\", \"BOB\" anasema \"ALICE is guilty.\", ambayo inapingana na tukio.\n\n- Ikitolewa tukio ambapo \"ALICE\" ni mhalifu, na \"BOB\" na \"CHARLIE\" ni waongo, kazi inapaswa kurejesha\nKweli ikiwa \"ALICE\" anasema \"I am guilty.\", \"BOB\" anasema \"Today is MONDAY\", na \"CHARLIE\" anasema \"ALICE is guilty.\",\nkwa kuwa taarifa kuhusu siku ya wiki zinapuuzwa.",
      "tr": "Bir senaryonun tutarlılığını, bir katılımcının suçlu olduğu varsayımına dayanarak değerlendirir.\n\nBu fonksiyon, potansiyel suçlunun adını (senaryo) ve bir grup yalancıyı (yalancı_sayısı) alır ve tüm katılımcıların yaptığı açıklamaların bu senaryo ile tutarlı olup olmadığını kontrol eder, haftanın günü hakkındaki açıklamaları dikkate almaz.\n\nParametreler:\n- scenario (str): Potansiyel suçlu olarak test edilen katılımcının adı.\n- liar_count (set): Yalancı olduğu varsayılan katılımcıların adlarını içeren bir küme.\n- statements (dict): Katılımcı adlarını, onların ilgili açıklamalarının listelerine eşleyen bir sözlük.\n- days_of_week (set): Haftanın günlerini temsil eden stringlerden oluşan bir küme.\n\nDöndürür:\n- bool: Senaryo açıklamalarla tutarlıysa True, aksi takdirde False.\n\nTest Durumları:\n- \"ALICE\" suçlu olduğu bir senaryo ve \"BOB\" ile \"CHARLIE\" yalancı olduğu durumda, fonksiyon \"ALICE\" \"Ben suçluyum.\" derse, \"BOB\" \"ALICE suçlu değil.\" derse ve \"CHARLIE\" ilgili bir açıklama yapmazsa True döndürmelidir.\n\n- \"ALICE\" suçlu olduğu bir senaryo ve \"BOB\" ile \"CHARLIE\" yalancı olduğu durumda, fonksiyon \"ALICE\" \"Ben suçlu değilim.\" derse, \"BOB\" \"ALICE suçlu.\" derse, bu senaryoyla çeliştiği için False döndürmelidir.\n\n- \"ALICE\" suçlu olduğu bir senaryo ve \"BOB\" ile \"CHARLIE\" yalancı olduğu durumda, fonksiyon \"ALICE\" \"Ben suçluyum.\" derse, \"BOB\" \"Bugün PAZARTESİ\" derse ve \"CHARLIE\" \"ALICE suçlu.\" derse, haftanın günü hakkındaki açıklamalar göz ardı edildiği için True döndürmelidir.",
      "vi": "Đánh giá tính nhất quán của một kịch bản nơi một người tham gia là tội phạm dựa trên các tuyên bố đã cho.\n\nHàm này nhận tên của một tội phạm tiềm năng (scenario) và một tập hợp những người nói dối (liar_count) và kiểm tra xem\ncác tuyên bố được thực hiện bởi tất cả những người tham gia có nhất quán với kịch bản này không, bỏ qua bất kỳ tuyên bố nào\nvề ngày trong tuần.\n\nTham số:\n- scenario (str): Tên của người tham gia được kiểm tra như là tội phạm tiềm năng.\n- liar_count (set): Một tập hợp tên của những người tham gia được cho là nói dối.\n- statements (dict): Một từ điển ánh xạ tên người tham gia tới danh sách các tuyên bố tương ứng của họ.\n- days_of_week (set): Một tập hợp các chuỗi đại diện cho các ngày trong tuần.\n\nTrả về:\n- bool: True nếu kịch bản nhất quán với các tuyên bố, False nếu không.\n\nCác trường hợp kiểm tra:\n- Cho một kịch bản nơi \"ALICE\" là tội phạm, và \"BOB\" và \"CHARLIE\" là những người nói dối, hàm nên trả về\nTrue nếu \"ALICE\" nói \"I am guilty.\", \"BOB\" nói \"ALICE is not guilty.\", và \"CHARLIE\" không đưa ra tuyên bố nào liên quan.\n\n- Cho một kịch bản nơi \"ALICE\" là tội phạm, và \"BOB\" và \"CHARLIE\" là những người nói dối, hàm nên trả về\nFalse nếu \"ALICE\" nói \"I am not guilty.\", \"BOB\" nói \"ALICE is guilty.\", điều này mâu thuẫn với kịch bản.\n\n- Cho một kịch bản nơi \"ALICE\" là tội phạm, và \"BOB\" và \"CHARLIE\" là những người nói dối, hàm nên trả về\nTrue nếu \"ALICE\" nói \"I am guilty.\", \"BOB\" nói \"Today is MONDAY\", và \"CHARLIE\" nói \"ALICE is guilty.\",\nvì các tuyên bố về ngày trong tuần bị bỏ qua."
    },
    "docstring_bertscore": {
      "es": "0.987747882206625",
      "arb": "0.9662884517307587",
      "sw": "0.9668905004156755",
      "tr": "0.956093350163381",
      "vi": "0.9815619362500555"
    }
  },
  {
    "task_id": "Python/33",
    "prompt": {
      "en": "def calculate_score(system: int, points: str) -> list:\n    \"\"\"\n    Calculate the score of a series of ping-pong games based on the provided scoring system.\n\n    This function takes in the desired scoring system (either 11 or 21 points) and a string \n    representing the sequence of points won by the player ('W') and the opponent ('L'). \n    The function processes the string and returns a list of game scores formatted as \"player_score:opponent_score\".\n\n    The game is considered finished when one player reaches the system's required number of points \n    (11 or 21) with at least a 2-point lead. If the sequence of points ends in the middle of a game, \n    that game's current score is also included in the output.\n\n    Args:\n    - system (int): The number of points required to win a game (either 11 or 21).\n    - points (str): A string of 'W' and 'L' characters denoting points won by the player and opponent.\n\n    Returns:\n    - list: A list of strings representing the score of each game.\n\n    Cases:\n    - If points = \"WWWWWWWWWWL\", it represents one complete game with the player winning 10-1 under both systems.\n      calculate_score(11, points) -> [\"10:1\"]\n      calculate_score(21, points) -> [\"10:1\"]\n\n    - If points = \"WWLWWLWWLWWLWE\", it represents two complete games and one in-progress game under the 11-point system,\n      with scores 2-1, 2-1, and 1-1 respectively. Under the 21-point system, it represents a single game with a score of 6-3.\n      calculate_score(11, points) -> [\"2:1\", \"2:1\", \"1:1\"]\n      calculate_score(21, points) -> [\"6:3\"]\n\n    - If points = \"WWLWLWLWLWLLWLWLWLWLWWLWWLWWLWLE\", it represents multiple games under both systems, with the last game unfinished.\n      The 11-point system has scores 4-6, 5-5, and 1-0, while the 21-point system has scores 13-16 and 2-1.\n      calculate_score(11, points) -> [\"4:6\", \"5:5\", \"1:0\"]\n      calculate_score(21, points) -> [\"13:16\", \"2:1\"]\n    \"\"\"",
      "es": "def calculate_score(system: int, points: str) -> list:\n    \"\"\"\n    Calcular el puntaje de una serie de juegos de ping-pong basado en el sistema de puntuación proporcionado.\n\n    Esta función toma el sistema de puntuación deseado (ya sea 11 o 21 puntos) y una cadena \n    que representa la secuencia de puntos ganados por el jugador ('W') y el oponente ('L'). \n    La función procesa la cadena y devuelve una lista de puntajes de juegos formateados como \"player_score:opponent_score\".\n\n    El juego se considera terminado cuando un jugador alcanza el número de puntos requerido por el sistema \n    (11 o 21) con al menos una ventaja de 2 puntos. Si la secuencia de puntos termina en medio de un juego, \n    el puntaje actual de ese juego también se incluye en la salida.\n\n    Argumentos:\n    - system (int): El número de puntos requeridos para ganar un juego (ya sea 11 o 21).\n    - points (str): Una cadena de caracteres 'W' y 'L' que denotan puntos ganados por el jugador y el oponente.\n\n    Devuelve:\n    - list: Una lista de cadenas que representan el puntaje de cada juego.\n\n    Casos:\n    - Si points = \"WWWWWWWWWWL\", representa un juego completo con el jugador ganando 10-1 bajo ambos sistemas.\n      calculate_score(11, points) -> [\"10:1\"]\n      calculate_score(21, points) -> [\"10:1\"]\n\n    - Si points = \"WWLWWLWWLWWLWE\", representa dos juegos completos y uno en progreso bajo el sistema de 11 puntos,\n      con puntajes 2-1, 2-1, y 1-1 respectivamente. Bajo el sistema de 21 puntos, representa un solo juego con un puntaje de 6-3.\n      calculate_score(11, points) -> [\"2:1\", \"2:1\", \"1:1\"]\n      calculate_score(21, points) -> [\"6:3\"]\n\n    - Si points = \"WWLWLWLWLWLLWLWLWLWLWWLWWLWWLWLE\", representa múltiples juegos bajo ambos sistemas, con el último juego sin terminar.\n      El sistema de 11 puntos tiene puntajes 4-6, 5-5, y 1-0, mientras que el sistema de 21 puntos tiene puntajes 13-16 y 2-1.\n      calculate_score(11, points) -> [\"4:6\", \"5:5\", \"1:0\"]\n      calculate_score(21, points) -> [\"13:16\", \"2:1\"]\n    \"\"\"",
      "arb": "def calculate_score(system: int, points: str) -> list:\n    \"\"\"\n    حساب النتيجة لسلسلة من مباريات كرة الطاولة بناءً على نظام التسجيل المقدم.\n\n    تأخذ هذه الدالة نظام التسجيل المطلوب (إما 11 أو 21 نقطة) وسلسلة تمثل تسلسل النقاط التي فاز بها اللاعب ('W') والخصم ('L').\n    تقوم الدالة بمعالجة السلسلة وتعيد قائمة بنتائج المباريات بصيغة \"player_score:opponent_score\".\n\n    تعتبر اللعبة منتهية عندما يصل أحد اللاعبين إلى العدد المطلوب من النقاط في النظام (11 أو 21) مع تقدم لا يقل عن نقطتين. \n    إذا انتهى تسلسل النقاط في منتصف اللعبة، يتم تضمين النتيجة الحالية لتلك اللعبة أيضًا في الناتج.\n\n    يعيدالحجج:\n    - system (int): عدد النقاط المطلوبة للفوز في اللعبة (إما 11 أو 21).\n    - points (str): سلسلة من الأحرف 'W' و 'L' تشير إلى النقاط التي فاز بها اللاعب والخصم.\n\n    يعيد:\n    - list: قائمة من السلاسل تمثل نتيجة كل لعبة.\n\n    حالات:\n    - إذا كانت النقاط = \"WWWWWWWWWWL\"، فإنها تمثل لعبة كاملة واحدة بفوز اللاعب 10-1 تحت كلا النظامين.\n      calculate_score(11, points) -> [\"10:1\"]\n      calculate_score(21, points) -> [\"10:1\"]\n\n    - إذا كانت النقاط = \"WWLWWLWWLWWLWE\"، فإنها تمثل لعبتين كاملتين وواحدة في طور التقدم تحت نظام 11 نقطة،\n      مع النتائج 2-1، 2-1، و 1-1 على التوالي. تحت نظام 21 نقطة، تمثل لعبة واحدة بنتيجة 6-3.\n      calculate_score(11, points) -> [\"2:1\", \"2:1\", \"1:1\"]\n      calculate_score(21, points) -> [\"6:3\"]\n\n    - إذا كانت النقاط = \"WWLWLWLWLWLLWLWLWLWLWWLWWLWWLWLE\"، فإنها تمثل عدة مباريات تحت كلا النظامين، مع انتهاء اللعبة الأخيرة غير مكتملة.\n      نظام 11 نقطة لديه نتائج 4-6، 5-5، و 1-0، بينما نظام 21 نقطة لديه نتائج 13-16 و 2-1.\n      calculate_score(11, points) -> [\"4:6\", \"5:5\", \"1:0\"]\n      calculate_score(21, points) -> [\"13:16\", \"2:1\"]\n    \"\"\"",
      "sw": "def calculate_score(system: int, points: str) -> list:\n    \"\"\"\n    Hesabu alama ya mfululizo wa michezo ya ping-pong kulingana na mfumo wa alama uliotolewa.\n\n    Kazi hii inachukua mfumo wa alama unaotakiwa (ama pointi 11 au 21) na kamba \n    inayowakilisha mfululizo wa pointi zilizoshindwa na mchezaji ('W') na mpinzani ('L'). \n    Kazi hii inachakata kamba na kurudisha orodha ya alama za mchezo zilizopangwa kama \"alama_ya_mchezaji:alama_ya_mpinzani\".\n\n    Mchezo unachukuliwa kuwa umemalizika wakati mchezaji mmoja anafikia idadi ya pointi inayotakiwa na mfumo \n    (11 au 21) akiwa na uongozi wa angalau pointi 2. Ikiwa mfululizo wa pointi unamalizika katikati ya mchezo, \n    alama ya sasa ya mchezo huo pia inajumuishwa katika matokeo.\n\n    Hoja:\n    - system (int): Idadi ya pointi zinazohitajika kushinda mchezo (ama 11 au 21).\n    - points (str): Kamba ya herufi 'W' na 'L' inayoonyesha pointi zilizoshindwa na mchezaji na mpinzani.\n\n    Inarejesha:\n    - list: Orodha ya kamba zinazowakilisha alama za kila mchezo.\n\n    Matukio:\n    - Ikiwa points = \"WWWWWWWWWWL\", inawakilisha mchezo mmoja kamili na mchezaji akishinda 10-1 chini ya mifumo yote miwili.\n      calculate_score(11, points) -> [\"10:1\"]\n      calculate_score(21, points) -> [\"10:1\"]\n\n    - Ikiwa points = \"WWLWWLWWLWWLWE\", inawakilisha michezo miwili kamili na mmoja unaoendelea chini ya mfumo wa pointi 11,\n      na alama 2-1, 2-1, na 1-1 mtawalia. Chini ya mfumo wa pointi 21, inawakilisha mchezo mmoja na alama ya 6-3.\n      calculate_score(11, points) -> [\"2:1\", \"2:1\", \"1:1\"]\n      calculate_score(21, points) -> [\"6:3\"]\n\n    - Ikiwa points = \"WWLWLWLWLWLLWLWLWLWLWWLWWLWWLWLE\", inawakilisha michezo mingi chini ya mifumo yote miwili, na mchezo wa mwisho haujakamilika.\n      Mfumo wa pointi 11 una alama 4-6, 5-5, na 1-0, wakati mfumo wa pointi 21 una alama 13-16 na 2-1.\n      calculate_score(11, points) -> [\"4:6\", \"5:5\", \"1:0\"]\n      calculate_score(21, points) -> [\"13:16\", \"2:1\"]\n    \"\"\"",
      "tr": "def calculate_score(system: int, points: str) -> list:\n    \"\"\"\n    Sağlanan puanlama sistemine göre bir dizi masa tenisi oyununun skorunu hesaplayın.\n\n    Bu fonksiyon, istenen puanlama sistemini (ya 11 ya da 21 puan) ve oyuncu ('W') ve rakip ('L') tarafından kazanılan \n    puanların dizisini temsil eden bir dize alır. Fonksiyon diziyi işler ve \"oyuncu_skoru:rakip_skoru\" formatında \n    oyun skorlarının bir listesini döndürür.\n\n    Bir oyuncu, sistemin gerektirdiği puan sayısına (11 veya 21) en az 2 puan farkla ulaştığında oyun tamamlanmış sayılır. \n    Eğer puan dizisi bir oyunun ortasında biterse, o oyunun mevcut skoru da çıktıya dahil edilir.\n\n    Argümanlar:\n    - system (int): Bir oyunu kazanmak için gereken puan sayısı (ya 11 ya da 21).\n    - points (str): Oyuncu ve rakip tarafından kazanılan puanları belirten 'W' ve 'L' karakterlerinden oluşan bir dize.\n\n    Döndürür:\n    - list: Her oyunun skorunu temsil eden dizelerin bir listesi.\n\n    Durumlar:\n    - Eğer points = \"WWWWWWWWWWL\" ise, bu, her iki sistemde de oyuncunun 10-1 kazandığı bir tam oyunu temsil eder.\n      calculate_score(11, points) -> [\"10:1\"]\n      calculate_score(21, points) -> [\"10:1\"]\n\n    - Eğer points = \"WWLWWLWWLWWLWE\" ise, bu, 11 puanlık sistemde iki tam oyun ve bir devam eden oyunu temsil eder,\n      sırasıyla 2-1, 2-1 ve 1-1 skorlarıyla. 21 puanlık sistemde ise, 6-3 skorlu tek bir oyunu temsil eder.\n      calculate_score(11, points) -> [\"2:1\", \"2:1\", \"1:1\"]\n      calculate_score(21, points) -> [\"6:3\"]\n\n    - Eğer points = \"WWLWLWLWLWLLWLWLWLWLWWLWWLWWLWLE\" ise, bu, her iki sistemde de birden fazla oyunu temsil eder, son oyun tamamlanmamıştır.\n      11 puanlık sistemde skorlar 4-6, 5-5 ve 1-0 iken, 21 puanlık sistemde skorlar 13-16 ve 2-1'dir.\n      calculate_score(11, points) -> [\"4:6\", \"5:5\", \"1:0\"]\n      calculate_score(21, points) -> [\"13:16\", \"2:1\"]\n    \"\"\"",
      "vi": "def calculate_score(system: int, points: str) -> list:\n    \"\"\"\n    Tính điểm của một loạt các trận đấu bóng bàn dựa trên hệ thống tính điểm được cung cấp.\n\n    Hàm này nhận vào hệ thống tính điểm mong muốn (hoặc 11 hoặc 21 điểm) và một chuỗi \n    đại diện cho chuỗi điểm mà người chơi ('W') và đối thủ ('L') giành được. \n    Hàm xử lý chuỗi và trả về một danh sách các điểm số của trận đấu được định dạng dưới dạng \"player_score:opponent_score\".\n\n    Trận đấu được coi là kết thúc khi một người chơi đạt đến số điểm yêu cầu của hệ thống \n    (11 hoặc 21) với ít nhất 2 điểm dẫn trước. Nếu chuỗi điểm kết thúc giữa chừng một trận đấu, \n    điểm số hiện tại của trận đấu đó cũng được bao gồm trong đầu ra.\n\n    Tham số:\n    - system (int): Số điểm cần thiết để thắng một trận đấu (hoặc 11 hoặc 21).\n    - points (str): Một chuỗi các ký tự 'W' và 'L' biểu thị điểm mà người chơi và đối thủ giành được.\n\n    Trả về:\n    - list: Một danh sách các chuỗi đại diện cho điểm số của mỗi trận đấu.\n\n    Trường hợp:\n    - Nếu points = \"WWWWWWWWWWL\", nó đại diện cho một trận đấu hoàn chỉnh với người chơi thắng 10-1 dưới cả hai hệ thống.\n      calculate_score(11, points) -> [\"10:1\"]\n      calculate_score(21, points) -> [\"10:1\"]\n\n    - Nếu points = \"WWLWWLWWLWWLWE\", nó đại diện cho hai trận đấu hoàn chỉnh và một trận đấu đang diễn ra dưới hệ thống 11 điểm,\n      với điểm số lần lượt là 2-1, 2-1, và 1-1. Dưới hệ thống 21 điểm, nó đại diện cho một trận đấu với điểm số 6-3.\n      calculate_score(11, points) -> [\"2:1\", \"2:1\", \"1:1\"]\n      calculate_score(21, points) -> [\"6:3\"]\n\n    - Nếu points = \"WWLWLWLWLWLLWLWLWLWLWWLWWLWWLWLE\", nó đại diện cho nhiều trận đấu dưới cả hai hệ thống, với trận đấu cuối chưa hoàn thành.\n      Hệ thống 11 điểm có điểm số 4-6, 5-5, và 1-0, trong khi hệ thống 21 điểm có điểm số 13-16 và 2-1.\n      calculate_score(11, points) -> [\"4:6\", \"5:5\", \"1:0\"]\n      calculate_score(21, points) -> [\"13:16\", \"2:1\"]\n    \"\"\""
    },
    "prompt_bertscore": {
      "es": "0.9907019132333759",
      "arb": "0.9759760526745923",
      "sw": "0.981809231074444",
      "tr": "0.9612672743285778",
      "vi": "0.9658385539177148"
    },
    "canonical_solution": "    match_scores = []\n    score_a, score_b = 0, 0\n\n    for point in points:\n        if point == 'W':\n            score_a += 1\n        elif point == 'L':\n            score_b += 1\n\n        # Check if a game is finished under the current system\n        if (score_a >= system or score_b >= system) and abs(score_a - score_b) >= 2:\n            match_scores.append(f\"{score_a}:{score_b}\")\n            score_a, score_b = 0, 0\n\n    # Include the last game if it's not finished when input ends\n    if score_a != 0 or score_b != 0:\n        match_scores.append(f\"{score_a}:{score_b}\")\n    return match_scores",
    "instruction": {
      "en": "def calculate_score(system: int, points: str) -> list:\n    match_scores = []\n    score_a, score_b = 0, 0\n\n    for point in points:\n        if point == 'W':\n            score_a += 1\n        elif point == 'L':\n            score_b += 1\n\n        # Check if a game is finished under the current system\n        if (score_a >= system or score_b >= system) and abs(score_a - score_b) >= 2:\n            match_scores.append(f\"{score_a}:{score_b}\")\n            score_a, score_b = 0, 0\n\n    # Include the last game if it's not finished when input ends\n    if score_a != 0 or score_b != 0:\n        match_scores.append(f\"{score_a}:{score_b}\")\n    return match_scores\n\nProvide a concise natural language description (docstring) of the Python code in English using at most 500 characters.",
      "es": "def calculate_score(system: int, points: str) -> list:\n    match_scores = []\n    score_a, score_b = 0, 0\n\n    for point in points:\n        if point == 'W':\n            score_a += 1\n        elif point == 'L':\n            score_b += 1\n\n        # Check if a game is finished under the current system\n        if (score_a >= system or score_b >= system) and abs(score_a - score_b) >= 2:\n            match_scores.append(f\"{score_a}:{score_b}\")\n            score_a, score_b = 0, 0\n\n    # Include the last game if it's not finished when input ends\n    if score_a != 0 or score_b != 0:\n        match_scores.append(f\"{score_a}:{score_b}\")\n    return match_scores\n\nProporcione una descripción concisa en lenguaje natural (docstring) del código Python en español utilizando un máximo de 500 caracteres.",
      "arb": "def calculate_score(system: int, points: str) -> list:\n    match_scores = []\n    score_a, score_b = 0, 0\n\n    for point in points:\n        if point == 'W':\n            score_a += 1\n        elif point == 'L':\n            score_b += 1\n\n        # Check if a game is finished under the current system\n        if (score_a >= system or score_b >= system) and abs(score_a - score_b) >= 2:\n            match_scores.append(f\"{score_a}:{score_b}\")\n            score_a, score_b = 0, 0\n\n    # Include the last game if it's not finished when input ends\n    if score_a != 0 or score_b != 0:\n        match_scores.append(f\"{score_a}:{score_b}\")\n    return match_scores\n\nقدم وصفًا موجزًا بلغة طبيعية (docstring) للكود البرمجي بلغة بايثون باللغة العربية الفصحى باستخدام 500 حرف كحد أقصى.",
      "sw": "def calculate_score(system: int, points: str) -> list:\n    match_scores = []\n    score_a, score_b = 0, 0\n\n    for point in points:\n        if point == 'W':\n            score_a += 1\n        elif point == 'L':\n            score_b += 1\n\n        # Check if a game is finished under the current system\n        if (score_a >= system or score_b >= system) and abs(score_a - score_b) >= 2:\n            match_scores.append(f\"{score_a}:{score_b}\")\n            score_a, score_b = 0, 0\n\n    # Include the last game if it's not finished when input ends\n    if score_a != 0 or score_b != 0:\n        match_scores.append(f\"{score_a}:{score_b}\")\n    return match_scores\n\nToa maelezo mafupi ya lugha asilia (docstring) ya msimbo wa Python kwa Kiswahili kwa kutumia herufi zisizozidi 500.",
      "tr": "def calculate_score(system: int, points: str) -> list:\n    match_scores = []\n    score_a, score_b = 0, 0\n\n    for point in points:\n        if point == 'W':\n            score_a += 1\n        elif point == 'L':\n            score_b += 1\n\n        # Check if a game is finished under the current system\n        if (score_a >= system or score_b >= system) and abs(score_a - score_b) >= 2:\n            match_scores.append(f\"{score_a}:{score_b}\")\n            score_a, score_b = 0, 0\n\n    # Include the last game if it's not finished when input ends\n    if score_a != 0 or score_b != 0:\n        match_scores.append(f\"{score_a}:{score_b}\")\n    return match_scores\n\nVerilen Python kodunun işlevini açıklayan kısa bir doğal dil açıklaması (docstring) sağlayın. Açıklama Türkçe olmalı ve en fazla 500 karakter içermelidir.",
      "vi": "def calculate_score(system: int, points: str) -> list:\n    match_scores = []\n    score_a, score_b = 0, 0\n\n    for point in points:\n        if point == 'W':\n            score_a += 1\n        elif point == 'L':\n            score_b += 1\n\n        # Check if a game is finished under the current system\n        if (score_a >= system or score_b >= system) and abs(score_a - score_b) >= 2:\n            match_scores.append(f\"{score_a}:{score_b}\")\n            score_a, score_b = 0, 0\n\n    # Include the last game if it's not finished when input ends\n    if score_a != 0 or score_b != 0:\n        match_scores.append(f\"{score_a}:{score_b}\")\n    return match_scores\n\nCung cấp mô tả ngắn gọn bằng ngôn ngữ tự nhiên (docstring) cho mã Python bằng tiếng Việt, sử dụng tối đa 500 ký tự."
    },
    "instruction_bertscore": {
      "es": "0.9687387561112052",
      "arb": "0.9379774648914752",
      "sw": "0.9426438884331277",
      "tr": "0.8583967986209903",
      "vi": "0.9069722555638342"
    },
    "level": "",
    "test": "def test_calculate_score():\n    # Test case 1: A single game in both systems, with a clear winner.\n    points = \"WWWWWWWWWWL\"\n    expected_11 = [\"10:1\"]\n    expected_21 = [\"10:1\"]\n    assert calculate_score(11, points) == expected_11, \"Test case 1 (11-point) failed\"\n    assert calculate_score(21, points) == expected_21, \"Test case 1 (21-point) failed\"\n\n    # Test case 2: Multiple games, some completed and one in progress.\n    points = \"WWLWWLWWLWWLWE\"\n    expected_11 = [\"9:4\"]\n    expected_21 = [\"9:4\"]\n    assert calculate_score(11, points) == expected_11, \"Test case 2 (11-point) failed\"\n    assert calculate_score(21, points) == expected_21, \"Test case 2 (21-point) failed\"\n\n    # Test case 3: A longer sequence with many games and a final unfinished game.\n    points = \"WWLWLWLWLWLLWLWLWLWLWWLWWLWWLWLE\"\n    expected_11 = ['12:10', '5:4']\n    expected_21 = ['17:14']\n    assert calculate_score(11, points) == expected_11, \"Test case 3 (11-point) failed\"\n    assert calculate_score(21, points) == expected_21, \"Test case 3 (21-point) failed\"\n\n    print(\"All test cases passed!\")\n\n# Run the test function\ntest_calculate_score()",
    "entry_point": "calculate_score",
    "signature": "def calculate_score(system: int, points: str) -> list:",
    "docstring": {
      "en": "Calculate the score of a series of ping-pong games based on the provided scoring system.\n\nThis function takes in the desired scoring system (either 11 or 21 points) and a string\nrepresenting the sequence of points won by the player ('W') and the opponent ('L').\nThe function processes the string and returns a list of game scores formatted as \"player_score:opponent_score\".\n\nThe game is considered finished when one player reaches the system's required number of points\n(11 or 21) with at least a 2-point lead. If the sequence of points ends in the middle of a game,\nthat game's current score is also included in the output.\n\nArgs:\n- system (int): The number of points required to win a game (either 11 or 21).\n- points (str): A string of 'W' and 'L' characters denoting points won by the player and opponent.\n\nReturns:\n- list: A list of strings representing the score of each game.\n\nCases:\n- If points = \"WWWWWWWWWWL\", it represents one complete game with the player winning 10-1 under both systems.\ncalculate_score(11, points) -> [\"10:1\"]\ncalculate_score(21, points) -> [\"10:1\"]\n\n- If points = \"WWLWWLWWLWWLWE\", it represents two complete games and one in-progress game under the 11-point system,\nwith scores 2-1, 2-1, and 1-1 respectively. Under the 21-point system, it represents a single game with a score of 6-3.\ncalculate_score(11, points) -> [\"2:1\", \"2:1\", \"1:1\"]\ncalculate_score(21, points) -> [\"6:3\"]\n\n- If points = \"WWLWLWLWLWLLWLWLWLWLWWLWWLWWLWLE\", it represents multiple games under both systems, with the last game unfinished.\nThe 11-point system has scores 4-6, 5-5, and 1-0, while the 21-point system has scores 13-16 and 2-1.\ncalculate_score(11, points) -> [\"4:6\", \"5:5\", \"1:0\"]\ncalculate_score(21, points) -> [\"13:16\", \"2:1\"]",
      "es": "Calcular la puntuación de una serie de juegos de ping-pong según el sistema de puntuación proporcionado.\n\nEsta función toma el sistema de puntuación deseado (ya sea 11 o 21 puntos) y una cadena\nque representa la secuencia de puntos ganados por el jugador ('W') y el oponente ('L').\nLa función procesa la cadena y devuelve una lista de puntuaciones de juegos formateadas como \"puntuación_jugador:puntuación_oponente\".\n\nEl juego se considera terminado cuando un jugador alcanza el número de puntos requerido por el sistema\n(11 o 21) con al menos una ventaja de 2 puntos. Si la secuencia de puntos termina en medio de un juego,\nla puntuación actual de ese juego también se incluye en la salida.\n\nArgumentos:\n- system (int): El número de puntos requeridos para ganar un juego (ya sea 11 o 21).\n- points (str): Una cadena de caracteres 'W' y 'L' que denotan puntos ganados por el jugador y el oponente.\n\nDevuelve:\n- list: Una lista de cadenas que representan la puntuación de cada juego.\n\nCasos:\n- Si points = \"WWWWWWWWWWL\", representa un juego completo con el jugador ganando 10-1 bajo ambos sistemas.\ncalculate_score(11, points) -> [\"10:1\"]\ncalculate_score(21, points) -> [\"10:1\"]\n\n- Si points = \"WWLWWLWWLWWLWE\", representa dos juegos completos y uno en progreso bajo el sistema de 11 puntos,\ncon puntuaciones de 2-1, 2-1 y 1-1 respectivamente. Bajo el sistema de 21 puntos, representa un solo juego con una puntuación de 6-3.\ncalculate_score(11, points) -> [\"2:1\", \"2:1\", \"1:1\"]\ncalculate_score(21, points) -> [\"6:3\"]\n\n- Si points = \"WWLWLWLWLWLLWLWLWLWLWWLWWLWWLWLE\", representa múltiples juegos bajo ambos sistemas, con el último juego sin terminar.\nEl sistema de 11 puntos tiene puntuaciones de 4-6, 5-5 y 1-0, mientras que el sistema de 21 puntos tiene puntuaciones de 13-16 y 2-1.\ncalculate_score(11, points) -> [\"4:6\", \"5:5\", \"1:0\"]\ncalculate_score(21, points) -> [\"13:16\", \"2:1\"]",
      "arb": "احسب النتيجة لسلسلة من مباريات كرة الطاولة بناءً على نظام التسجيل المقدم.\n\nتأخذ هذه الدالة نظام التسجيل المطلوب (إما 11 أو 21 نقطة) وسلسلة تمثل تسلسل النقاط التي فاز بها اللاعب ('W') والمنافس ('L'). تقوم الدالة بمعالجة السلسلة وتعيد قائمة بنتائج المباريات بتنسيق \"player_score:opponent_score\".\n\nتعتبر اللعبة منتهية عندما يصل أحد اللاعبين إلى العدد المطلوب من النقاط في النظام (11 أو 21) مع تقدم لا يقل عن نقطتين. إذا انتهى تسلسل النقاط في منتصف اللعبة، يتم تضمين النتيجة الحالية لتلك اللعبة في النتيجة النهائية.\n\nيعيدالحجج:\n- system (int): عدد النقاط المطلوبة للفوز في اللعبة (إما 11 أو 21).\n- points (str): سلسلة من الأحرف 'W' و 'L' تشير إلى النقاط التي فاز بها اللاعب والمنافس.\n\nيعيد:\n- list: قائمة من السلاسل النصية التي تمثل نتيجة كل لعبة.\n\nCases:\n- إذا كانت النقاط = \"WWWWWWWWWWL\"، فإنها تمثل لعبة كاملة واحدة بفوز اللاعب 10-1 في كلا النظامين.\ncalculate_score(11, points) -> [\"10:1\"]\ncalculate_score(21, points) -> [\"10:1\"]\n\n- إذا كانت النقاط = \"WWLWWLWWLWWLWE\"، فإنها تمثل لعبتين كاملتين ولعبة واحدة قيد التقدم تحت نظام 11 نقطة، مع النتائج 2-1، 2-1، و 1-1 على التوالي. تحت نظام 21 نقطة، تمثل لعبة واحدة بنتيجة 6-3.\ncalculate_score(11, points) -> [\"2:1\", \"2:1\", \"1:1\"]\ncalculate_score(21, points) -> [\"6:3\"]\n\n- إذا كانت النقاط = \"WWLWLWLWLWLLWLWLWLWLWWLWWLWWLWLE\"، فإنها تمثل عدة مباريات تحت كلا النظامين، مع انتهاء اللعبة الأخيرة غير مكتملة. نظام 11 نقطة لديه نتائج 4-6، 5-5، و 1-0، بينما نظام 21 نقطة لديه نتائج 13-16 و 2-1.\ncalculate_score(11, points) -> [\"4:6\", \"5:5\", \"1:0\"]\ncalculate_score(21, points) -> [\"13:16\", \"2:1\"]",
      "sw": "Hesabu alama za mfululizo wa michezo ya ping-pong kulingana na mfumo wa alama uliotolewa.\n\nKazi hii inachukua mfumo wa alama unaotakiwa (ama pointi 11 au 21) na kamba\ninayowakilisha mfululizo wa pointi zilizoshindwa na mchezaji ('W') na mpinzani ('L').\nKazi hii inachakata kamba na kurudisha orodha ya alama za mchezo zilizopangwa kama \"alama_ya_mchezaji:alama_ya_mpinzani\".\n\nMchezo unachukuliwa kuwa umemalizika wakati mchezaji mmoja anafikia idadi ya pointi inayohitajika na mfumo\n(11 au 21) akiwa na uongozi wa angalau pointi 2. Ikiwa mfululizo wa pointi unamalizika katikati ya mchezo,\nalama ya sasa ya mchezo huo pia inajumuishwa kwenye matokeo.\n\nHoja:\n- system (int): Idadi ya pointi zinazohitajika kushinda mchezo (ama 11 au 21).\n- points (str): Kamba ya herufi 'W' na 'L' zinazowakilisha pointi zilizoshindwa na mchezaji na mpinzani.\n\nInarejesha:\n- list: Orodha ya kamba zinazowakilisha alama za kila mchezo.\n\nCases:\n- Ikiwa points = \"WWWWWWWWWWL\", inawakilisha mchezo mmoja kamili na mchezaji akishinda 10-1 chini ya mifumo yote miwili.\ncalculate_score(11, points) -> [\"10:1\"]\ncalculate_score(21, points) -> [\"10:1\"]\n\n- Ikiwa points = \"WWLWWLWWLWWLWE\", inawakilisha michezo miwili kamili na mmoja unaoendelea chini ya mfumo wa pointi 11,\nna alama 2-1, 2-1, na 1-1 mtawalia. Chini ya mfumo wa pointi 21, inawakilisha mchezo mmoja na alama ya 6-3.\ncalculate_score(11, points) -> [\"2:1\", \"2:1\", \"1:1\"]\ncalculate_score(21, points) -> [\"6:3\"]\n\n- Ikiwa points = \"WWLWLWLWLWLLWLWLWLWLWWLWWLWWLWLE\", inawakilisha michezo mingi chini ya mifumo yote miwili, na mchezo wa mwisho haujakamilika.\nMfumo wa pointi 11 una alama 4-6, 5-5, na 1-0, wakati mfumo wa pointi 21 una alama 13-16 na 2-1.\ncalculate_score(11, points) -> [\"4:6\", \"5:5\", \"1:0\"]\ncalculate_score(21, points) -> [\"13:16\", \"2:1\"]",
      "tr": "Bir dizi masa tenisi oyununun puanını verilen puanlama sistemine göre hesaplayın.\n\nBu fonksiyon, istenen puanlama sistemini (ya 11 ya da 21 puan) ve oyuncunun ('W') ve rakibin ('L') kazandığı puanların dizisini temsil eden bir dizeyi alır. Fonksiyon, diziyi işler ve \"oyuncu_puanı:rakip_puanı\" formatında oyun puanlarının bir listesini döndürür.\n\nBir oyuncu, sistemin gerektirdiği puan sayısına (11 veya 21) en az 2 puan farkla ulaştığında oyun bitmiş sayılır. Eğer puan dizisi bir oyunun ortasında sona ererse, o oyunun mevcut puanı da çıktıya dahil edilir.\n\nArgümanlar:\n- system (int): Bir oyunu kazanmak için gereken puan sayısı (ya 11 ya da 21).\n- points (str): Oyuncu ve rakibin kazandığı puanları belirten 'W' ve 'L' karakterlerinden oluşan bir dize.\n\nDöndürür:\n- list: Her oyunun puanını temsil eden dizelerin bir listesi.\n\nDurumlar:\n- Eğer points = \"WWWWWWWWWWL\" ise, bu, her iki sistemde de oyuncunun 10-1 kazandığı bir tam oyunu temsil eder.\ncalculate_score(11, points) -> [\"10:1\"]\ncalculate_score(21, points) -> [\"10:1\"]\n\n- Eğer points = \"WWLWWLWWLWWLWE\" ise, bu, 11 puanlık sistemde iki tam oyun ve bir devam eden oyunu, sırasıyla 2-1, 2-1 ve 1-1 puanlarıyla temsil eder. 21 puanlık sistemde ise, 6-3 puanıyla tek bir oyunu temsil eder.\ncalculate_score(11, points) -> [\"2:1\", \"2:1\", \"1:1\"]\ncalculate_score(21, points) -> [\"6:3\"]\n\n- Eğer points = \"WWLWLWLWLWLLWLWLWLWLWWLWWLWWLWLE\" ise, bu, her iki sistemde de birden fazla oyunu ve son oyunun tamamlanmamış olduğunu temsil eder. 11 puanlık sistemde puanlar 4-6, 5-5 ve 1-0 iken, 21 puanlık sistemde puanlar 13-16 ve 2-1'dir.\ncalculate_score(11, points) -> [\"4:6\", \"5:5\", \"1:0\"]\ncalculate_score(21, points) -> [\"13:16\", \"2:1\"]",
      "vi": "Tính điểm của một loạt các trò chơi bóng bàn dựa trên hệ thống tính điểm được cung cấp.\n\nHàm này nhận vào hệ thống tính điểm mong muốn (hoặc 11 hoặc 21 điểm) và một chuỗi\nđại diện cho chuỗi điểm mà người chơi ('W') và đối thủ ('L') giành được.\nHàm xử lý chuỗi và trả về một danh sách các điểm số trò chơi được định dạng dưới dạng \"điểm_người_chơi:điểm_đối_thủ\".\n\nTrò chơi được coi là kết thúc khi một người chơi đạt đến số điểm yêu cầu của hệ thống\n(11 hoặc 21) với ít nhất cách biệt 2 điểm. Nếu chuỗi điểm kết thúc giữa chừng một trò chơi,\nđiểm số hiện tại của trò chơi đó cũng được bao gồm trong đầu ra.\n\nTham số:\n- system (int): Số điểm cần thiết để thắng một trò chơi (hoặc 11 hoặc 21).\n- points (str): Một chuỗi các ký tự 'W' và 'L' biểu thị điểm mà người chơi và đối thủ giành được.\n\nTrả về:\n- list: Một danh sách các chuỗi đại diện cho điểm số của mỗi trò chơi.\n\nTrường hợp:\n- Nếu points = \"WWWWWWWWWWL\", nó đại diện cho một trò chơi hoàn chỉnh với người chơi thắng 10-1 dưới cả hai hệ thống.\ncalculate_score(11, points) -> [\"10:1\"]\ncalculate_score(21, points) -> [\"10:1\"]\n\n- Nếu points = \"WWLWWLWWLWWLWE\", nó đại diện cho hai trò chơi hoàn chỉnh và một trò chơi đang diễn ra dưới hệ thống 11 điểm,\nvới điểm số lần lượt là 2-1, 2-1, và 1-1. Dưới hệ thống 21 điểm, nó đại diện cho một trò chơi với điểm số 6-3.\ncalculate_score(11, points) -> [\"2:1\", \"2:1\", \"1:1\"]\ncalculate_score(21, points) -> [\"6:3\"]\n\n- Nếu points = \"WWLWLWLWLWLLWLWLWLWLWWLWWLWWLWLE\", nó đại diện cho nhiều trò chơi dưới cả hai hệ thống, với trò chơi cuối cùng chưa hoàn thành.\nHệ thống 11 điểm có điểm số 4-6, 5-5, và 1-0, trong khi hệ thống 21 điểm có điểm số 13-16 và 2-1.\ncalculate_score(11, points) -> [\"4:6\", \"5:5\", \"1:0\"]\ncalculate_score(21, points) -> [\"13:16\", \"2:1\"]"
    },
    "docstring_bertscore": {
      "es": "0.9855623521240982",
      "arb": "0.9676149054153098",
      "sw": "0.9784595283286716",
      "tr": "0.9623847688522801",
      "vi": "0.9770744786817153"
    }
  },
  {
    "task_id": "Python/34",
    "prompt": {
      "en": "def catalan_number(n: int) -> int:\n    \"\"\"\n    Calculate the nth Catalan number.\n\n    The function computes the nth Catalan number using dynamic programming. Catalan numbers are a sequence of natural \n    numbers that have many applications in combinatorial mathematics, including the counting of certain types of lattice paths, \n    the number of expressions containing n pairs of parentheses which are correctly matched, the number of different ways n+1 \n    factors can be completely parenthesized, and more.\n\n    Args:\n    - n (int): The position in the Catalan number sequence to compute (must be non-negative).\n\n    Returns:\n    - int: The nth Catalan number.\n\n    Cases:\n    - For n=0, the function should return 1, since C(0) = 1.\n      catalan_number(0) -> 1\n\n    - For n=3, the function should return 5, since C(3) = 5.\n      catalan_number(3) -> 5\n\n    - For n=5, the function should return 42, since C(5) = 42.\n      catalan_number(5) -> 42\n\n    Note:\n    The computation is based on the recursive formula:\n    C(n) = C(0)C(n-1) + C(1)C(n-2) + ... + C(n-1)C(0)\n    where C(0) is 1.\n    \"\"\"",
      "es": "def catalan_number(n: int) -> int:\n    \"\"\"\n    Calcular el enésimo número de Catalan.\n\n    La función calcula el enésimo número de Catalan utilizando programación dinámica. Los números de Catalan son una secuencia de números \n    naturales que tienen muchas aplicaciones en matemáticas combinatorias, incluyendo el conteo de ciertos tipos de caminos en una cuadrícula, \n    el número de expresiones que contienen n pares de paréntesis correctamente emparejados, el número de formas diferentes en que n+1 \n    factores pueden ser completamente parentizados, y más.\n\n    Argumentos:\n    - n (int): La posición en la secuencia de números de Catalan a calcular (debe ser no negativa).\n\n    Devuelve:\n    - int: El enésimo número de Catalan.\n\n    Casos:\n    - Para n=0, la función debe devolver 1, ya que C(0) = 1.\n      catalan_number(0) -> 1\n\n    - Para n=3, la función debe devolver 5, ya que C(3) = 5.\n      catalan_number(3) -> 5\n\n    - Para n=5, la función debe devolver 42, ya que C(5) = 42.\n      catalan_number(5) -> 42\n\n    Nota:\n    El cálculo se basa en la fórmula recursiva:\n    C(n) = C(0)C(n-1) + C(1)C(n-2) + ... + C(n-1)C(0)\n    donde C(0) es 1.\n    \"\"\"",
      "arb": "def catalan_number(n: int) -> int:\n    \"\"\"\n    حساب العدد النوني من كاتالان.\n\n    تقوم الدالة بحساب العدد النوني من كاتالان باستخدام البرمجة الديناميكية. أعداد كاتالان هي سلسلة من الأعداد الطبيعية \n    التي لها العديد من التطبيقات في الرياضيات التوافقية، بما في ذلك عد أنواع معينة من مسارات الشبكة، \n    عدد التعبيرات التي تحتوي على n من الأزواج من الأقواس المتطابقة بشكل صحيح، عدد الطرق المختلفة التي يمكن بها \n    تحويط n+1 من العوامل بالكامل، وأكثر من ذلك.\n\n    يعيدالحجج:\n    - n (int): الموضع في تسلسل أعداد كاتالان للحساب (يجب أن يكون غير سالب).\n\n    يعيد:\n    - int: العدد النوني من كاتالان.\n\n    حالات:\n    - بالنسبة لـ n=0، يجب أن تعيد الدالة 1، لأن C(0) = 1.\n      catalan_number(0) -> 1\n\n    - بالنسبة لـ n=3، يجب أن تعيد الدالة 5، لأن C(3) = 5.\n      catalan_number(3) -> 5\n\n    - بالنسبة لـ n=5، يجب أن تعيد الدالة 42، لأن C(5) = 42.\n      catalan_number(5) -> 42\n\n    ملاحظة:\n    يعتمد الحساب على الصيغة التكرارية:\n    C(n) = C(0)C(n-1) + C(1)C(n-2) + ... + C(n-1)C(0)\n    حيث C(0) هو 1.\n    \"\"\"",
      "sw": "def catalan_number(n: int) -> int:\n    \"\"\"\n    Kuhesabu nambari ya Catalan ya n.\n\n    Kazi hii inahesabu nambari ya Catalan ya n kwa kutumia programu ya nguvu. Nambari za Catalan ni mlolongo wa nambari \n    asilia ambazo zina matumizi mengi katika hisabati ya mchanganyiko, ikiwa ni pamoja na kuhesabu aina fulani za njia za \n    gridi, idadi ya maneno yanayojumuisha jozi n za mabano ambayo yameunganishwa kwa usahihi, idadi ya njia tofauti ambazo \n    vipengele n+1 vinaweza kuwekwa mabano kabisa, na zaidi.\n\n    Hoja:\n    - n (int): Nafasi katika mlolongo wa nambari za Catalan ya kuhesabu (lazima iwe isiyo hasi).\n\n    Inarejesha:\n    - int: Nambari ya Catalan ya n.\n\n    Matukio:\n    - Kwa n=0, kazi inapaswa kurudisha 1, kwa kuwa C(0) = 1.\n      catalan_number(0) -> 1\n\n    - Kwa n=3, kazi inapaswa kurudisha 5, kwa kuwa C(3) = 5.\n      catalan_number(3) -> 5\n\n    - Kwa n=5, kazi inapaswa kurudisha 42, kwa kuwa C(5) = 42.\n      catalan_number(5) -> 42\n\n    Kumbuka:\n    Hesabu inategemea fomula ya kurudiarudia:\n    C(n) = C(0)C(n-1) + C(1)C(n-2) + ... + C(n-1)C(0)\n    ambapo C(0) ni 1.\n    \"\"\"",
      "tr": "def catalan_number(n: int) -> int:\n    \"\"\"\n    n. Catalan sayısını hesapla.\n\n    Fonksiyon, dinamik programlama kullanarak n. Catalan sayısını hesaplar. Catalan sayıları, kombinatoryal matematikte birçok \n    uygulamaya sahip doğal sayıların bir dizisidir; belirli türdeki kafes yollarının sayılması, n çift parantez içeren ve doğru \n    eşleşmiş ifadelerin sayısı, n+1 faktörün tamamen parantezlenebileceği farklı yolların sayısı ve daha fazlası dahil.\n\n    Argümanlar:\n    - n (int): Hesaplanacak Catalan sayısı dizisindeki pozisyon (negatif olmamalıdır).\n\n    Dönüş:\n    - int: n. Catalan sayısı.\n\n    Durumlar:\n    - n=0 için, fonksiyon 1 döndürmelidir, çünkü C(0) = 1.\n      catalan_number(0) -> 1\n\n    - n=3 için, fonksiyon 5 döndürmelidir, çünkü C(3) = 5.\n      catalan_number(3) -> 5\n\n    - n=5 için, fonksiyon 42 döndürmelidir, çünkü C(5) = 42.\n      catalan_number(5) -> 42\n\n    Not:\n    Hesaplama, aşağıdaki özyinelemeli formüle dayanır:\n    C(n) = C(0)C(n-1) + C(1)C(n-2) + ... + C(n-1)C(0)\n    burada C(0) 1'dir.\n    \"\"\"",
      "vi": "def catalan_number(n: int) -> int:\n    \"\"\"\n    Tính số Catalan thứ n.\n\n    Hàm này tính số Catalan thứ n sử dụng lập trình động. Các số Catalan là một dãy số tự nhiên có nhiều ứng dụng \n    trong toán học tổ hợp, bao gồm việc đếm số lượng các loại đường đi trên lưới nhất định, số lượng biểu thức chứa n cặp \n    dấu ngoặc được ghép đúng, số cách khác nhau mà n+1 thừa số có thể được ngoặc hoàn toàn, và nhiều hơn nữa.\n\n    Tham số:\n    - n (int): Vị trí trong dãy số Catalan cần tính (phải là số không âm).\n\n    Trả về:\n    - int: Số Catalan thứ n.\n\n    Trường hợp:\n    - Với n=0, hàm nên trả về 1, vì C(0) = 1.\n      catalan_number(0) -> 1\n\n    - Với n=3, hàm nên trả về 5, vì C(3) = 5.\n      catalan_number(3) -> 5\n\n    - Với n=5, hàm nên trả về 42, vì C(5) = 42.\n      catalan_number(5) -> 42\n\n    Lưu ý:\n    Việc tính toán dựa trên công thức đệ quy:\n    C(n) = C(0)C(n-1) + C(1)C(n-2) + ... + C(n-1)C(0)\n    trong đó C(0) là 1.\n    \"\"\""
    },
    "prompt_bertscore": {
      "es": "0.9827445815387372",
      "arb": "0.9728025350767979",
      "sw": "0.958711695846183",
      "tr": "0.9705852241333055",
      "vi": "0.9674266038140887"
    },
    "canonical_solution": "    # Initialize an array to store the intermediate catalan numbers\n    catalan = [0] * (n + 1)\n    catalan[0] = 1  # Base case\n\n    # Calculate catalan numbers using the recursive formula\n    for i in range(1, n + 1):\n        for j in range(i):\n            catalan[i] += catalan[j] * catalan[i - j - 1]\n\n    return catalan[n]",
    "instruction": {
      "en": "def catalan_number(n: int) -> int:\n    # Initialize an array to store the intermediate catalan numbers\n    catalan = [0] * (n + 1)\n    catalan[0] = 1  # Base case\n\n    # Calculate catalan numbers using the recursive formula\n    for i in range(1, n + 1):\n        for j in range(i):\n            catalan[i] += catalan[j] * catalan[i - j - 1]\n\n    return catalan[n]\n\nProvide a concise natural language description (docstring) of the Python code in English using at most 500 characters.",
      "es": "def catalan_number(n: int) -> int:\n    # Initialize an array to store the intermediate catalan numbers\n    catalan = [0] * (n + 1)\n    catalan[0] = 1  # Base case\n\n    # Calculate catalan numbers using the recursive formula\n    for i in range(1, n + 1):\n        for j in range(i):\n            catalan[i] += catalan[j] * catalan[i - j - 1]\n\n    return catalan[n]\n\nProporciona una descripción concisa en lenguaje natural (docstring) del código Python en español utilizando como máximo 500 caracteres.",
      "arb": "def catalan_number(n: int) -> int:\n    # Initialize an array to store the intermediate catalan numbers\n    catalan = [0] * (n + 1)\n    catalan[0] = 1  # Base case\n\n    # Calculate catalan numbers using the recursive formula\n    for i in range(1, n + 1):\n        for j in range(i):\n            catalan[i] += catalan[j] * catalan[i - j - 1]\n\n    return catalan[n]\n\nيرجى تقديم وصف موجز بلغة طبيعية (docstring) للشفرة البرمجية بلغة بايثون باللغة العربية الفصحى باستخدام 500 حرف كحد أقصى.",
      "sw": "def catalan_number(n: int) -> int:\n    # Initialize an array to store the intermediate catalan numbers\n    catalan = [0] * (n + 1)\n    catalan[0] = 1  # Base case\n\n    # Calculate catalan numbers using the recursive formula\n    for i in range(1, n + 1):\n        for j in range(i):\n            catalan[i] += catalan[j] * catalan[i - j - 1]\n\n    return catalan[n]\n\nToa maelezo mafupi ya lugha asilia (docstring) ya msimbo wa Python kwa Kiswahili kwa kutumia herufi zisizozidi 500.",
      "tr": "def catalan_number(n: int) -> int:\n    # Initialize an array to store the intermediate catalan numbers\n    catalan = [0] * (n + 1)\n    catalan[0] = 1  # Base case\n\n    # Calculate catalan numbers using the recursive formula\n    for i in range(1, n + 1):\n        for j in range(i):\n            catalan[i] += catalan[j] * catalan[i - j - 1]\n\n    return catalan[n]\n\nVerilen Python kodunun işlevini açıklayan, en fazla 500 karakter uzunluğunda özlü bir doğal dil açıklaması (docstring) sağlayın.",
      "vi": "def catalan_number(n: int) -> int:\n    # Initialize an array to store the intermediate catalan numbers\n    catalan = [0] * (n + 1)\n    catalan[0] = 1  # Base case\n\n    # Calculate catalan numbers using the recursive formula\n    for i in range(1, n + 1):\n        for j in range(i):\n            catalan[i] += catalan[j] * catalan[i - j - 1]\n\n    return catalan[n]\n\nCung cấp mô tả ngắn gọn bằng ngôn ngữ tự nhiên (docstring) cho mã Python bằng tiếng Việt, sử dụng tối đa 500 ký tự."
    },
    "instruction_bertscore": {
      "es": "0.9687387561112052",
      "arb": "0.924699818440817",
      "sw": "0.9426438884331277",
      "tr": "0.8406654617667679",
      "vi": "0.9069722555638342"
    },
    "level": "",
    "test": "def test_catalan_number():\n    # Test case 1: The first Catalan number (base case)\n    n1 = 0\n    expected_output1 = 1\n    assert catalan_number(n1) == expected_output1, f\"Test case 1 failed: expected {expected_output1}, got {catalan_number(n1)}\"\n\n    # Test case 2: The third Catalan number\n    n2 = 3\n    expected_output2 = 5\n    assert catalan_number(n2) == expected_output2, f\"Test case 2 failed: expected {expected_output2}, got {catalan_number(n2)}\"\n\n    # Test case 3: The fifth Catalan number\n    n3 = 5\n    expected_output3 = 42\n    assert catalan_number(n3) == expected_output3, f\"Test case 3 failed: expected {expected_output3}, got {catalan_number(n3)}\"\n\n    print(\"All test cases passed!\")\n\n# Run the test function\ntest_catalan_number()",
    "entry_point": "catalan_number",
    "signature": "def catalan_number(n: int) -> int:",
    "docstring": {
      "en": "Calculate the nth Catalan number.\n\nThe function computes the nth Catalan number using dynamic programming. Catalan numbers are a sequence of natural\nnumbers that have many applications in combinatorial mathematics, including the counting of certain types of lattice paths,\nthe number of expressions containing n pairs of parentheses which are correctly matched, the number of different ways n+1\nfactors can be completely parenthesized, and more.\n\nArgs:\n- n (int): The position in the Catalan number sequence to compute (must be non-negative).\n\nReturns:\n- int: The nth Catalan number.\n\nCases:\n- For n=0, the function should return 1, since C(0) = 1.\ncatalan_number(0) -> 1\n\n- For n=3, the function should return 5, since C(3) = 5.\ncatalan_number(3) -> 5\n\n- For n=5, the function should return 42, since C(5) = 42.\ncatalan_number(5) -> 42\n\nNote:\nThe computation is based on the recursive formula:\nC(n) = C(0)C(n-1) + C(1)C(n-2) + ... + C(n-1)C(0)\nwhere C(0) is 1.",
      "es": "Calcular el enésimo número de Catalan.\n\nLa función calcula el enésimo número de Catalan utilizando programación dinámica. Los números de Catalan son una secuencia de números naturales que tienen muchas aplicaciones en matemáticas combinatorias, incluyendo el conteo de ciertos tipos de caminos en una cuadrícula, el número de expresiones que contienen n pares de paréntesis que están correctamente emparejados, el número de diferentes maneras en que n+1 factores pueden ser completamente parentetizados, y más.\n\nArgumentos:\n- n (int): La posición en la secuencia de números de Catalan a calcular (debe ser no negativa).\n\nDevuelve:\n- int: El enésimo número de Catalan.\n\nCasos:\n- Para n=0, la función debe devolver 1, ya que C(0) = 1.\ncatalan_number(0) -> 1\n\n- Para n=3, la función debe devolver 5, ya que C(3) = 5.\ncatalan_number(3) -> 5\n\n- Para n=5, la función debe devolver 42, ya que C(5) = 42.\ncatalan_number(5) -> 42\n\nNota:\nEl cálculo se basa en la fórmula recursiva:\nC(n) = C(0)C(n-1) + C(1)C(n-2) + ... + C(n-1)C(0)\ndonde C(0) es 1.",
      "arb": "حساب العدد النوني من كاتالان.\n\nتقوم الدالة بحساب العدد النوني من كاتالان باستخدام البرمجة الديناميكية. أعداد كاتالان هي سلسلة من الأعداد الطبيعية التي لها العديد من التطبيقات في الرياضيات التوافقية، بما في ذلك عد أنواع معينة من مسارات الشبكة، عدد التعبيرات التي تحتوي على n من الأزواج من الأقواس التي تتطابق بشكل صحيح، عدد الطرق المختلفة التي يمكن بها وضع الأقواس بشكل كامل لعوامل n+1، وأكثر.\n\nالمعطيات:\n- n (int): الموضع في سلسلة أعداد كاتالان الذي سيتم حسابه (يجب أن يكون غير سالب).\n\nالقيم المعادة:\n- int: العدد النوني من كاتالان.\n\nالحالات:\n- بالنسبة لـ n=0، يجب أن تعيد الدالة 1، حيث أن C(0) = 1.\ncatalan_number(0) -> 1\n\n- بالنسبة لـ n=3، يجب أن تعيد الدالة 5، حيث أن C(3) = 5.\ncatalan_number(3) -> 5\n\n- بالنسبة لـ n=5، يجب أن تعيد الدالة 42، حيث أن C(5) = 42.\ncatalan_number(5) -> 42\n\nملاحظة:\nيعتمد الحساب على الصيغة التكرارية:\nC(n) = C(0)C(n-1) + C(1)C(n-2) + ... + C(n-1)C(0)\nحيث أن C(0) هو 1.",
      "sw": "Kuhesabu nambari ya Catalan ya n.\n\nKazi ya kifanyiko ni kuhesabu nambari ya Catalan ya nth kwa kutumia programu ya nguvu. Nambari za Catalan ni mlolongo wa nambari za asili ambazo zina matumizi mengi katika hesabu za mchanganyiko, ikijumuisha kuhesabu aina fulani za njia za lattice, idadi ya maneno yenye jozi n za mabano ambayo yamefananishwa vizuri, idadi ya njia tofauti ambazo n+1 sababu zinaweza kuwekwa mabano kikamilifu, na zaidi.\n\nHoja:\n- n (int): Nafasi katika mlolongo wa nambari za Catalan ya kuhesabu (lazima isiwe hasi).\n\nInarejesha:\n- int: Nambari ya Catalan ya nth.\n\nCases:\n- Kwa n=0, kazi inapaswa kurudisha 1, kwa kuwa C(0) = 1.\ncatalan_number(0) -> 1\n\n- Kwa n=3, kazi inapaswa kurudisha 5, kwa kuwa C(3) = 5.\ncatalan_number(3) -> 5\n\n- Kwa n=5, kazi inapaswa kurudisha 42, kwa kuwa C(5) = 42.\ncatalan_number(5) -> 42\n\nNote:\nHesabu inategemea fomula ya kurudiwa:\nC(n) = C(0)C(n-1) + C(1)C(n-2) + ... + C(n-1)C(0)\nambapo C(0) ni 1.",
      "tr": "nth Catalan sayısını hesaplayın.\n\nFonksiyon, dinamik programlama kullanarak nth Catalan sayısını hesaplar. Catalan sayıları, kombinatoryal matematikte birçok uygulamaya sahip doğal sayıların bir dizisidir. Bu uygulamalar arasında belirli türdeki kafes yollarının sayılması, n çift parantez içeren ve doğru eşleşmiş ifadelerin sayısı, n+1 faktörün tamamen parantezlenebileceği farklı yolların sayısı ve daha fazlası bulunmaktadır.\n\nArgümanlar:\n- n (int): Hesaplanacak Catalan sayısı dizisindeki konum (negatif olmamalıdır).\n\nDöndürür:\n- int: nth Catalan sayısı.\n\nDurumlar:\n- n=0 için, fonksiyon 1 döndürmelidir, çünkü C(0) = 1.\ncatalan_number(0) -> 1\n\n- n=3 için, fonksiyon 5 döndürmelidir, çünkü C(3) = 5.\ncatalan_number(3) -> 5\n\n- n=5 için, fonksiyon 42 döndürmelidir, çünkü C(5) = 42.\ncatalan_number(5) -> 42\n\nNot:\nHesaplama, aşağıdaki özyinelemeli formüle dayanmaktadır:\nC(n) = C(0)C(n-1) + C(1)C(n-2) + ... + C(n-1)C(0)\nburada C(0) 1'dir.",
      "vi": "Tính số Catalan thứ n.\n\nHàm này tính số Catalan thứ n bằng cách sử dụng lập trình động. Các số Catalan là một dãy số tự nhiên có nhiều ứng dụng trong toán học tổ hợp, bao gồm việc đếm các loại đường đi trên lưới nhất định, số lượng biểu thức chứa n cặp dấu ngoặc được ghép đúng, số cách khác nhau mà n+1 yếu tố có thể được đặt dấu ngoặc hoàn toàn, và nhiều ứng dụng khác.\n\nTham số:\n- n (int): Vị trí trong dãy số Catalan cần tính (phải là số không âm).\n\nTrả về:\n- int: Số Catalan thứ n.\n\nCases:\n- Với n=0, hàm nên trả về 1, vì C(0) = 1.\ncatalan_number(0) -> 1\n\n- Với n=3, hàm nên trả về 5, vì C(3) = 5.\ncatalan_number(3) -> 5\n\n- Với n=5, hàm nên trả về 42, vì C(5) = 42.\ncatalan_number(5) -> 42\n\nNote:\nViệc tính toán dựa trên công thức đệ quy:\nC(n) = C(0)C(n-1) + C(1)C(n-2) + ... + C(n-1)C(0)\ntrong đó C(0) là 1."
    },
    "docstring_bertscore": {
      "es": "0.9861558597026303",
      "arb": "0.9592607102193634",
      "sw": "0.9867281138303918",
      "tr": "0.9811193877611097",
      "vi": "0.9757134633108642"
    }
  },
  {
    "task_id": "Python/35",
    "prompt": {
      "en": "from typing import List\ndef count_apples_reachable(apple_heights: List[int], tao_reach: int) -> int:\n    \"\"\"\n    Calculate the number of apples that Tao Tao can reach.\n\n    Args:\n    apple_heights (List[int]): The heights of apples from the ground (in centimeters).\n    tao_reach (int): The maximum height Tao Tao can reach with her hand stretched upwards (in centimeters).\n\n    Returns:\n    int: The number of apples Tao Tao can reach with or without standing on a 30cm stool.\n\n    This function iterates over the list of apple heights and counts how many of them are within Tao Tao's reach,\n    considering an additional 30cm that the stool provides.\n\n    Example cases:\n    1. Tao Tao can reach apples at 120cm without a stool, and all apples are at 150cm or below.\n       count_apples_reachable([100, 120, 130, 140, 150, 150, 140, 130, 120, 110], 120) -> returns 10\n\n    2. Tao Tao can reach apples at 100cm without a stool, and all apples are above 130cm.\n       count_apples_reachable([200, 190, 180, 170, 160, 150, 140, 135, 130, 131], 100) -> returns 0\n\n    3. Tao Tao can reach apples at 110cm without a stool, and some apples are at various heights.\n       count_apples_reachable([100, 200, 150, 140, 129, 134, 167, 198, 200, 111], 110) -> returns 5\n    \"\"\"",
      "es": "from typing import List\ndef count_apples_reachable(apple_heights: List[int], tao_reach: int) -> int:\n    \"\"\"\n    Calcular la cantidad de manzanas que Tao Tao puede alcanzar.\n\n    Argumentos:\n    apple_heights (List[int]): Las alturas de las manzanas desde el suelo (en centímetros).\n    tao_reach (int): La altura máxima que Tao Tao puede alcanzar con su mano extendida hacia arriba (en centímetros).\n\n    Devuelve:\n    int: El número de manzanas que Tao Tao puede alcanzar con o sin pararse en un taburete de 30 cm.\n\n    Esta función itera sobre la lista de alturas de manzanas y cuenta cuántas de ellas están al alcance de Tao Tao,\n    considerando un adicional de 30 cm que proporciona el taburete.\n\n    Casos de ejemplo:\n    1. Tao Tao puede alcanzar manzanas a 120 cm sin un taburete, y todas las manzanas están a 150 cm o menos.\n       count_apples_reachable([100, 120, 130, 140, 150, 150, 140, 130, 120, 110], 120) -> Devuelve 10\n\n    2. Tao Tao puede alcanzar manzanas a 100 cm sin un taburete, y todas las manzanas están por encima de 130 cm.\n       count_apples_reachable([200, 190, 180, 170, 160, 150, 140, 135, 130, 131], 100) -> Devuelve 0\n\n    3. Tao Tao puede alcanzar manzanas a 110 cm sin un taburete, y algunas manzanas están a varias alturas.\n       count_apples_reachable([100, 200, 150, 140, 129, 134, 167, 198, 200, 111], 110) -> Devuelve 5\n    \"\"\"",
      "arb": "from typing import List\ndef count_apples_reachable(apple_heights: List[int], tao_reach: int) -> int:\n    \"\"\"\n    حساب عدد التفاح الذي يمكن لتاو تاو الوصول إليه.\n\n    يعيدالحجج:\n    apple_heights (List[int]): ارتفاعات التفاح من الأرض (بالسنتيمترات).\n    tao_reach (int): أقصى ارتفاع يمكن لتاو تاو الوصول إليه بيدها ممدودة للأعلى (بالسنتيمترات).\n\n    يعيد:\n    int: عدد التفاح الذي يمكن لتاو تاو الوصول إليه مع أو بدون الوقوف على كرسي بارتفاع 30 سم.\n\n    تقوم هذه الدالة بتكرار قائمة ارتفاعات التفاح وتعد كم منها ضمن نطاق وصول تاو تاو،\n    مع الأخذ في الاعتبار إضافة 30 سم التي يوفرها الكرسي.\n\n    حالات المثال:\n    1. يمكن لتاو تاو الوصول إلى التفاح على ارتفاع 120 سم بدون كرسي، وجميع التفاح على ارتفاع 150 سم أو أقل.\n       count_apples_reachable([100, 120, 130, 140, 150, 150, 140, 130, 120, 110], 120) -> يعيد 10\n\n    2. يمكن لتاو تاو الوصول إلى التفاح على ارتفاع 100 سم بدون كرسي، وجميع التفاح على ارتفاع أكثر من 130 سم.\n       count_apples_reachable([200, 190, 180, 170, 160, 150, 140, 135, 130, 131], 100) -> يعيد 0\n\n    3. يمكن لتاو تاو الوصول إلى التفاح على ارتفاع 110 سم بدون كرسي، وبعض التفاح على ارتفاعات مختلفة.\n       count_apples_reachable([100, 200, 150, 140, 129, 134, 167, 198, 200, 111], 110) -> يعيد 5\n    \"\"\"",
      "sw": "from typing import List\ndef count_apples_reachable(apple_heights: List[int], tao_reach: int) -> int:\n    \"\"\"\n    Kuhesabu idadi ya maapulo ambayo Tao Tao anaweza kuyafikia.\n\n    Hoja:\n    apple_heights (List[int]): Urefu wa maapulo kutoka ardhini (katika sentimita).\n    tao_reach (int): Urefu wa juu zaidi ambao Tao Tao anaweza kufikia kwa mkono wake ukiwa umenyooka juu (katika sentimita).\n\n    Inarejesha:\n    int: Idadi ya maapulo ambayo Tao Tao anaweza kuyafikia akiwa amesimama au bila kusimama kwenye kigoda cha 30cm.\n\n    Kazi hii inazunguka kwenye orodha ya urefu wa maapulo na kuhesabu ni mangapi kati yao yako ndani ya urefu ambao Tao Tao anaweza kufikia,\n    ikizingatia nyongeza ya 30cm ambayo kigoda kinatoa.\n\n    Mifano ya kesi:\n    1. Tao Tao anaweza kufikia maapulo kwenye 120cm bila kigoda, na maapulo yote yako kwenye 150cm au chini.\n       count_apples_reachable([100, 120, 130, 140, 150, 150, 140, 130, 120, 110], 120) -> Inarejesha 10\n\n    2. Tao Tao anaweza kufikia maapulo kwenye 100cm bila kigoda, na maapulo yote yako juu ya 130cm.\n       count_apples_reachable([200, 190, 180, 170, 160, 150, 140, 135, 130, 131], 100) -> Inarejesha 0\n\n    3. Tao Tao anaweza kufikia maapulo kwenye 110cm bila kigoda, na baadhi ya maapulo yako kwenye urefu mbalimbali.\n       count_apples_reachable([100, 200, 150, 140, 129, 134, 167, 198, 200, 111], 110) -> Inarejesha 5\n    \"\"\"",
      "tr": "from typing import List\ndef count_apples_reachable(apple_heights: List[int], tao_reach: int) -> int:\n    \"\"\"\n    Tao Tao'nun ulaşabileceği elma sayısını hesaplayın.\n\n    Argümanlar:\n    apple_heights (List[int]): Elmaların yerden yükseklikleri (santimetre cinsinden).\n    tao_reach (int): Tao Tao'nun elini yukarı doğru uzatarak ulaşabileceği maksimum yükseklik (santimetre cinsinden).\n\n    Döndürür:\n    int: Tao Tao'nun 30cm'lik bir tabureye çıkıp çıkmadan ulaşabileceği elma sayısı.\n\n    Bu fonksiyon, elma yükseklikleri listesini dolaşır ve bunlardan kaç tanesinin Tao Tao'nun erişebileceği mesafede olduğunu,\n    taburenin sağladığı ek 30cm'yi dikkate alarak sayar.\n\n    Örnek durumlar:\n    1. Tao Tao, taburesiz 120cm'deki elmalara ulaşabilir ve tüm elmalar 150cm veya altında.\n       count_apples_reachable([100, 120, 130, 140, 150, 150, 140, 130, 120, 110], 120) -> 10 döndürür\n\n    2. Tao Tao, taburesiz 100cm'deki elmalara ulaşabilir ve tüm elmalar 130cm'nin üzerinde.\n       count_apples_reachable([200, 190, 180, 170, 160, 150, 140, 135, 130, 131], 100) -> 0 döndürür\n\n    3. Tao Tao, taburesiz 110cm'deki elmalara ulaşabilir ve bazı elmalar çeşitli yüksekliklerde.\n       count_apples_reachable([100, 200, 150, 140, 129, 134, 167, 198, 200, 111], 110) -> 5 döndürür\n    \"\"\"",
      "vi": "from typing import List\ndef count_apples_reachable(apple_heights: List[int], tao_reach: int) -> int:\n    \"\"\"\n    Tính số lượng táo mà Tao Tao có thể với tới.\n\n    Tham số:\n    apple_heights (List[int]): Chiều cao của các quả táo tính từ mặt đất (tính bằng cm).\n    tao_reach (int): Chiều cao tối đa mà Tao Tao có thể với tới khi giơ tay lên (tính bằng cm).\n\n    Trả về:\n    int: Số lượng táo mà Tao Tao có thể với tới có hoặc không đứng trên ghế đẩu cao 30cm.\n\n    Hàm này duyệt qua danh sách chiều cao của các quả táo và đếm xem có bao nhiêu quả nằm trong tầm với của Tao Tao,\n    bao gồm thêm 30cm mà ghế đẩu cung cấp.\n\n    Ví dụ:\n    1. Tao Tao có thể với tới các quả táo ở độ cao 120cm mà không cần ghế đẩu, và tất cả các quả táo đều ở độ cao 150cm hoặc thấp hơn.\n       count_apples_reachable([100, 120, 130, 140, 150, 150, 140, 130, 120, 110], 120) -> trả về 10\n\n    2. Tao Tao có thể với tới các quả táo ở độ cao 100cm mà không cần ghế đẩu, và tất cả các quả táo đều trên 130cm.\n       count_apples_reachable([200, 190, 180, 170, 160, 150, 140, 135, 130, 131], 100) -> trả về 0\n\n    3. Tao Tao có thể với tới các quả táo ở độ cao 110cm mà không cần ghế đẩu, và một số quả táo ở các độ cao khác nhau.\n       count_apples_reachable([100, 200, 150, 140, 129, 134, 167, 198, 200, 111], 110) -> trả về 5\n    \"\"\""
    },
    "prompt_bertscore": {
      "es": "0.9833988700138662",
      "arb": "0.9555495001801075",
      "sw": "0.9673058365424195",
      "tr": "0.9725999320881423",
      "vi": "0.9596444641155228"
    },
    "canonical_solution": "    stool_height = 30\n    total_reach = tao_reach + stool_height\n    reachable_apples = 0\n\n    for height in apple_heights:\n        if height <= total_reach:\n            reachable_apples += 1\n\n    return reachable_apples",
    "instruction": {
      "en": "def count_apples_reachable(apple_heights: List[int], tao_reach: int) -> int:\n    stool_height = 30\n    total_reach = tao_reach + stool_height\n    reachable_apples = 0\n\n    for height in apple_heights:\n        if height <= total_reach:\n            reachable_apples += 1\n\n    return reachable_apples\n\nProvide a concise natural language description (docstring) of the Python code in English using at most 500 characters.",
      "es": "def count_apples_reachable(apple_heights: List[int], tao_reach: int) -> int:\n    stool_height = 30\n    total_reach = tao_reach + stool_height\n    reachable_apples = 0\n\n    for height in apple_heights:\n        if height <= total_reach:\n            reachable_apples += 1\n\n    return reachable_apples\n\nProporcione una descripción concisa en lenguaje natural (docstring) del código Python en español utilizando como máximo 500 caracteres.",
      "arb": "def count_apples_reachable(apple_heights: List[int], tao_reach: int) -> int:\n    stool_height = 30\n    total_reach = tao_reach + stool_height\n    reachable_apples = 0\n\n    for height in apple_heights:\n        if height <= total_reach:\n            reachable_apples += 1\n\n    return reachable_apples\n\nيرجى تقديم وصف موجز بلغة طبيعية (docstring) للكود البرمجي بلغة بايثون باللغة العربية الفصحى باستخدام 500 حرف كحد أقصى.",
      "sw": "def count_apples_reachable(apple_heights: List[int], tao_reach: int) -> int:\n    stool_height = 30\n    total_reach = tao_reach + stool_height\n    reachable_apples = 0\n\n    for height in apple_heights:\n        if height <= total_reach:\n            reachable_apples += 1\n\n    return reachable_apples\n\nToa maelezo mafupi ya lugha ya asili (docstring) ya msimbo wa Python kwa Kiswahili kwa kutumia herufi zisizozidi 500.",
      "tr": "def count_apples_reachable(apple_heights: List[int], tao_reach: int) -> int:\n    stool_height = 30\n    total_reach = tao_reach + stool_height\n    reachable_apples = 0\n\n    for height in apple_heights:\n        if height <= total_reach:\n            reachable_apples += 1\n\n    return reachable_apples\n\nPython kodunun işlevini açıklayan en fazla 500 karakterlik kısa bir doğal dil açıklaması (docstring) sağlayın.",
      "vi": "def count_apples_reachable(apple_heights: List[int], tao_reach: int) -> int:\n    stool_height = 30\n    total_reach = tao_reach + stool_height\n    reachable_apples = 0\n\n    for height in apple_heights:\n        if height <= total_reach:\n            reachable_apples += 1\n\n    return reachable_apples\n\nCung cấp mô tả ngắn gọn bằng ngôn ngữ tự nhiên (docstring) cho mã Python bằng tiếng Việt, sử dụng tối đa 500 ký tự."
    },
    "instruction_bertscore": {
      "es": "0.9687387561112052",
      "arb": "0.924699818440817",
      "sw": "0.914896018724078",
      "tr": "0.8660438696604524",
      "vi": "0.9256256346468206"
    },
    "level": "",
    "test": "import unittest\n\nclass TestTaoTaoApplePicking(unittest.TestCase):\n    def test_count_apples_reachable(self):\n        # Test case 1: Tao Tao can reach all apples\n        apples_1 = [100, 105, 110, 115, 120, 125, 130, 135, 140, 145]\n        tao_reach_1 = 120\n        self.assertEqual(count_apples_reachable(apples_1, tao_reach_1), 10)\n\n        # Test case 2: Tao Tao can't reach any apples\n        apples_2 = [200, 200, 200, 200, 200, 200, 200, 200, 200, 200]\n        tao_reach_2 = 100\n        self.assertEqual(count_apples_reachable(apples_2, tao_reach_2), 0)\n\n        # Test case 3: Tao Tao can reach some of the apples\n        apples_3 = [160, 150, 140, 170, 180, 190, 160, 150, 145, 155]\n        tao_reach_3 = 115\n        self.assertEqual(count_apples_reachable(apples_3, tao_reach_3), 2)\n\n# To run the tests\nif __name__ == '__main__':\n    unittest.main()",
    "entry_point": "count_apples_reachable",
    "signature": "def count_apples_reachable(apple_heights: List[int], tao_reach: int) -> int:",
    "docstring": {
      "en": "Calculate the number of apples that Tao Tao can reach.\n\nArgs:\napple_heights (List[int]): The heights of apples from the ground (in centimeters).\ntao_reach (int): The maximum height Tao Tao can reach with her hand stretched upwards (in centimeters).\n\nReturns:\nint: The number of apples Tao Tao can reach with or without standing on a 30cm stool.\n\nThis function iterates over the list of apple heights and counts how many of them are within Tao Tao's reach,\nconsidering an additional 30cm that the stool provides.\n\nExample cases:\n1. Tao Tao can reach apples at 120cm without a stool, and all apples are at 150cm or below.\ncount_apples_reachable([100, 120, 130, 140, 150, 150, 140, 130, 120, 110], 120) -> returns 10\n\n2. Tao Tao can reach apples at 100cm without a stool, and all apples are above 130cm.\ncount_apples_reachable([200, 190, 180, 170, 160, 150, 140, 135, 130, 131], 100) -> returns 0\n\n3. Tao Tao can reach apples at 110cm without a stool, and some apples are at various heights.\ncount_apples_reachable([100, 200, 150, 140, 129, 134, 167, 198, 200, 111], 110) -> returns 5",
      "es": "Calcular el número de manzanas que Tao Tao puede alcanzar.\n\nArgumentos:\napple_heights (List[int]): Las alturas de las manzanas desde el suelo (en centímetros).\ntao_reach (int): La altura máxima que Tao Tao puede alcanzar con su mano estirada hacia arriba (en centímetros).\n\nDevuelve:\nint: El número de manzanas que Tao Tao puede alcanzar con o sin pararse en un taburete de 30 cm.\n\nEsta función itera sobre la lista de alturas de manzanas y cuenta cuántas de ellas están al alcance de Tao Tao,\nconsiderando un adicional de 30 cm que proporciona el taburete.\n\nCasos de ejemplo:\n1. Tao Tao puede alcanzar manzanas a 120 cm sin un taburete, y todas las manzanas están a 150 cm o menos.\ncount_apples_reachable([100, 120, 130, 140, 150, 150, 140, 130, 120, 110], 120) -> Devuelve 10\n\n2. Tao Tao puede alcanzar manzanas a 100 cm sin un taburete, y todas las manzanas están por encima de 130 cm.\ncount_apples_reachable([200, 190, 180, 170, 160, 150, 140, 135, 130, 131], 100) -> Devuelve 0\n\n3. Tao Tao puede alcanzar manzanas a 110 cm sin un taburete, y algunas manzanas están a varias alturas.\ncount_apples_reachable([100, 200, 150, 140, 129, 134, 167, 198, 200, 111], 110) -> Devuelve 5",
      "arb": "احسب عدد التفاح الذي يمكن لـ Tao Tao الوصول إليه.\n\nيعيدالحجج:\napple_heights (List[int]): ارتفاعات التفاح من الأرض (بالسنتيمترات).\ntao_reach (int): أقصى ارتفاع يمكن لـ Tao Tao الوصول إليه بيدها ممدودة إلى الأعلى (بالسنتيمترات).\n\nيعيد:\nint: عدد التفاح الذي يمكن لـ Tao Tao الوصول إليه مع أو بدون الوقوف على كرسي بارتفاع 30 سم.\n\nتقوم هذه الدالة بتكرار قائمة ارتفاعات التفاح وتحصي عدد التفاح الذي يقع ضمن نطاق وصول Tao Tao، مع الأخذ في الاعتبار 30 سم إضافية يوفرها الكرسي.\n\nأمثلة الحالات:\n1. يمكن لـ Tao Tao الوصول إلى التفاح على ارتفاع 120 سم بدون كرسي، وجميع التفاح على ارتفاع 150 سم أو أقل.\ncount_apples_reachable([100, 120, 130, 140, 150, 150, 140, 130, 120, 110], 120) -> يعيد 10\n\n2. يمكن لـ Tao Tao الوصول إلى التفاح على ارتفاع 100 سم بدون كرسي، وجميع التفاح فوق 130 سم.\ncount_apples_reachable([200, 190, 180, 170, 160, 150, 140, 135, 130, 131], 100) -> يعيد 0\n\n3. يمكن لـ Tao Tao الوصول إلى التفاح على ارتفاع 110 سم بدون كرسي، وبعض التفاح على ارتفاعات مختلفة.\ncount_apples_reachable([100, 200, 150, 140, 129, 134, 167, 198, 200, 111], 110) -> يعيد 5",
      "sw": "Hesabu idadi ya maapulo ambayo Tao Tao anaweza kufikia.\n\nHoja:\napple_heights (List[int]): Urefu wa maapulo kutoka ardhini (katika sentimita).\ntao_reach (int): Urefu wa juu zaidi ambao Tao Tao anaweza kufikia kwa mkono wake ulionyoshwa juu (katika sentimita).\n\nInarejesha:\nint: Idadi ya maapulo ambayo Tao Tao anaweza kufikia akiwa amesimama au bila kusimama kwenye kigoda cha 30cm.\n\nKazi hii inazunguka orodha ya urefu wa maapulo na kuhesabu ni mangapi kati yao yako ndani ya uwezo wa kufikiwa na Tao Tao,\nikizingatia ongezeko la 30cm ambalo kigoda kinatoa.\n\nMifano ya kesi:\n1. Tao Tao anaweza kufikia maapulo kwenye 120cm bila kigoda, na maapulo yote yako kwenye 150cm au chini.\ncount_apples_reachable([100, 120, 130, 140, 150, 150, 140, 130, 120, 110], 120) -> Inarejesha 10\n\n2. Tao Tao anaweza kufikia maapulo kwenye 100cm bila kigoda, na maapulo yote yako juu ya 130cm.\ncount_apples_reachable([200, 190, 180, 170, 160, 150, 140, 135, 130, 131], 100) -> Inarejesha 0\n\n3. Tao Tao anaweza kufikia maapulo kwenye 110cm bila kigoda, na baadhi ya maapulo yako kwenye urefu mbalimbali.\ncount_apples_reachable([100, 200, 150, 140, 129, 134, 167, 198, 200, 111], 110) -> Inarejesha 5",
      "tr": "Tao Tao'nun ulaşabileceği elma sayısını hesaplayın.\n\nArgümanlar:\napple_heights (List[int]): Elmaların yerden yüksekliği (santimetre cinsinden).\ntao_reach (int): Tao Tao'nun elini yukarı doğru uzatarak ulaşabileceği maksimum yükseklik (santimetre cinsinden).\n\nDöndürür:\nint: Tao Tao'nun 30cm tabureye çıkmadan veya çıkarak ulaşabileceği elma sayısı.\n\nBu fonksiyon, elma yükseklikleri listesini iteratif olarak dolaşır ve bunlardan kaç tanesinin Tao Tao'nun ulaşabileceği mesafede olduğunu sayar,\ntaburenin sağladığı ek 30cm'yi dikkate alarak.\n\nÖrnek vakalar:\n1. Tao Tao, taburesiz 120cm'deki elmalara ulaşabilir ve tüm elmalar 150cm veya altında.\ncount_apples_reachable([100, 120, 130, 140, 150, 150, 140, 130, 120, 110], 120) -> 10 döndürür\n\n2. Tao Tao, taburesiz 100cm'deki elmalara ulaşabilir ve tüm elmalar 130cm'nin üzerinde.\ncount_apples_reachable([200, 190, 180, 170, 160, 150, 140, 135, 130, 131], 100) -> 0 döndürür\n\n3. Tao Tao, taburesiz 110cm'deki elmalara ulaşabilir ve bazı elmalar çeşitli yüksekliklerde.\ncount_apples_reachable([100, 200, 150, 140, 129, 134, 167, 198, 200, 111], 110) -> 5 döndürür",
      "vi": "Tính số lượng táo mà Tao Tao có thể với tới.\n\nTham số:\napple_heights (List[int]): Chiều cao của những quả táo tính từ mặt đất (đơn vị: cm).\ntao_reach (int): Chiều cao tối đa mà Tao Tao có thể với tới khi duỗi tay lên (đơn vị: cm).\n\nTrả về:\nint: Số lượng táo mà Tao Tao có thể với tới có hoặc không có đứng trên ghế đẩu cao 30cm.\n\nHàm này duyệt qua danh sách chiều cao của các quả táo và đếm xem có bao nhiêu quả nằm trong tầm với của Tao Tao,\nxét thêm 30cm mà ghế đẩu cung cấp.\n\nCác trường hợp ví dụ:\n1. Tao Tao có thể với tới những quả táo ở độ cao 120cm mà không cần ghế đẩu, và tất cả các quả táo đều ở độ cao 150cm hoặc thấp hơn.\ncount_apples_reachable([100, 120, 130, 140, 150, 150, 140, 130, 120, 110], 120) -> trả về 10\n\n2. Tao Tao có thể với tới những quả táo ở độ cao 100cm mà không cần ghế đẩu, và tất cả các quả táo đều ở trên 130cm.\ncount_apples_reachable([200, 190, 180, 170, 160, 150, 140, 135, 130, 131], 100) -> trả về 0\n\n3. Tao Tao có thể với tới những quả táo ở độ cao 110cm mà không cần ghế đẩu, và một số quả táo ở các độ cao khác nhau.\ncount_apples_reachable([100, 200, 150, 140, 129, 134, 167, 198, 200, 111], 110) -> trả về 5"
    },
    "docstring_bertscore": {
      "es": "0.982902691322041",
      "arb": "0.9488357933011283",
      "sw": "0.9764706423233692",
      "tr": "0.9784068912776973",
      "vi": "0.9563448162257713"
    }
  },
  {
    "task_id": "Python/36",
    "prompt": {
      "en": "from typing import List, Tuple\ndef remaining_trees_after_clearing(l: int, areas: List[Tuple[int, int]]) -> int:\n    \"\"\"\n    Calculate the number of remaining trees along a road after specific areas have been cleared.\n\n    The road is represented as a straight line of length 'l' and is initially filled with trees.\n    Each area scheduled for clearing is specified as a pair of integers (start, end), representing\n    the inclusive range along the road where the trees will be removed.\n\n    Args:\n    - l (int): The length of the road.\n    - areas (List[Tuple[int, int]]): A list of tuples where each tuple represents a cleared area on the road.\n    \n    Returns:\n    - int: The total number of trees remaining along the road after the specified areas have been cleared.\n    \n    Examples:\n    - remaining_trees_after_clearing(10, [(2, 5), (7, 9)]) will return 5, as trees from positions 2 to 5\n      and 7 to 9 are cleared, leaving trees at positions 0, 1, 6, and 10.\n    \n    - remaining_trees_after_clearing(6, [(1, 3), (4, 4)]) will return 3, as trees from positions 1 to 3\n      and at position 4 are cleared, leaving trees at positions 0, 5, and 6.\n    \n    - remaining_trees_after_clearing(100, [(10, 90)]) will return 20, as trees from positions 10 to 90\n      are cleared, leaving trees at positions 0 to 9 and 91 to 100.\n    \"\"\"",
      "es": "from typing import List, Tuple\ndef remaining_trees_after_clearing(l: int, areas: List[Tuple[int, int]]) -> int:\n    \"\"\"\n    Calcular el número de árboles restantes a lo largo de una carretera después de que se hayan despejado áreas específicas.\n\n    La carretera se representa como una línea recta de longitud 'l' y está inicialmente llena de árboles.\n    Cada área programada para despejarse se especifica como un par de enteros (inicio, fin), que representa\n    el rango inclusivo a lo largo de la carretera donde se eliminarán los árboles.\n\n    Argumentos:\n    - l (int): La longitud de la carretera.\n    - areas (List[Tuple[int, int]]): Una lista de tuplas donde cada tupla representa un área despejada en la carretera.\n    \n    Devuelve:\n    - int: El número total de árboles restantes a lo largo de la carretera después de que se hayan despejado las áreas especificadas.\n    \n    Ejemplos:\n    - remaining_trees_after_clearing(10, [(2, 5), (7, 9)]) devolverá 5, ya que los árboles desde las posiciones 2 a 5\n      y de 7 a 9 se despejan, dejando árboles en las posiciones 0, 1, 6 y 10.\n    \n    - remaining_trees_after_clearing(6, [(1, 3), (4, 4)]) devolverá 3, ya que los árboles desde las posiciones 1 a 3\n      y en la posición 4 se despejan, dejando árboles en las posiciones 0, 5 y 6.\n    \n    - remaining_trees_after_clearing(100, [(10, 90)]) devolverá 20, ya que los árboles desde las posiciones 10 a 90\n      se despejan, dejando árboles en las posiciones 0 a 9 y 91 a 100.\n    \"\"\"",
      "arb": "from typing import List, Tuple\ndef remaining_trees_after_clearing(l: int, areas: List[Tuple[int, int]]) -> int:\n    \"\"\"\n    حساب عدد الأشجار المتبقية على طول الطريق بعد إزالة مناطق محددة.\n\n    يتم تمثيل الطريق كخط مستقيم بطول 'l' ومليء بالأشجار في البداية.\n    يتم تحديد كل منطقة مجدولة للإزالة كزوج من الأعداد الصحيحة (البداية، النهاية)،\n    ويمثل النطاق الشامل على طول الطريق حيث سيتم إزالة الأشجار.\n\n    يعيدالحجج:\n    - l (int): طول الطريق.\n    - areas (List[Tuple[int, int]]): قائمة من الأزواج حيث يمثل كل زوج منطقة تمت إزالتها على الطريق.\n    \n    يعيد:\n    - int: العدد الإجمالي للأشجار المتبقية على طول الطريق بعد إزالة المناطق المحددة.\n    \n    أمثلة:\n    - remaining_trees_after_clearing(10, [(2, 5), (7, 9)]) سيعيد 5، حيث يتم إزالة الأشجار من المواقع 2 إلى 5\n      و7 إلى 9، تاركًا الأشجار في المواقع 0، 1، 6، و10.\n    \n    - remaining_trees_after_clearing(6, [(1, 3), (4, 4)]) سيعيد 3، حيث يتم إزالة الأشجار من المواقع 1 إلى 3\n      وفي الموقع 4، تاركًا الأشجار في المواقع 0، 5، و6.\n    \n    - remaining_trees_after_clearing(100, [(10, 90)]) سيعيد 20، حيث يتم إزالة الأشجار من المواقع 10 إلى 90\n      تاركًا الأشجار في المواقع 0 إلى 9 و91 إلى 100.\n    \"\"\"",
      "sw": "from typing import List, Tuple\ndef remaining_trees_after_clearing(l: int, areas: List[Tuple[int, int]]) -> int:\n    \"\"\"\n    Kuhesabu idadi ya miti iliyobaki kando ya barabara baada ya maeneo maalum kusafishwa.\n\n    Barabara inawakilishwa kama mstari wa moja kwa moja wa urefu 'l' na awali imejaa miti.\n    Kila eneo lililopangwa kusafishwa limeainishwa kama jozi ya nambari (mwanzo, mwisho), inayowakilisha\n    safu ya pamoja kando ya barabara ambapo miti itaondolewa.\n\n    Hoja:\n    - l (int): Urefu wa barabara.\n    - areas (List[Tuple[int, int]]): Orodha ya jozi ambapo kila jozi inawakilisha eneo lililosafishwa kwenye barabara.\n    \n    Inarejesha:\n    - int: Jumla ya idadi ya miti iliyobaki kando ya barabara baada ya maeneo maalum kusafishwa.\n    \n    Mifano:\n    - remaining_trees_after_clearing(10, [(2, 5), (7, 9)]) itarudisha 5, kwani miti kutoka nafasi 2 hadi 5\n      na 7 hadi 9 imesafishwa, ikiacha miti katika nafasi 0, 1, 6, na 10.\n    \n    - remaining_trees_after_clearing(6, [(1, 3), (4, 4)]) itarudisha 3, kwani miti kutoka nafasi 1 hadi 3\n      na katika nafasi 4 imesafishwa, ikiacha miti katika nafasi 0, 5, na 6.\n    \n    - remaining_trees_after_clearing(100, [(10, 90)]) itarudisha 20, kwani miti kutoka nafasi 10 hadi 90\n      imesafishwa, ikiacha miti katika nafasi 0 hadi 9 na 91 hadi 100.\n    \"\"\"",
      "tr": "from typing import List, Tuple\ndef remaining_trees_after_clearing(l: int, areas: List[Tuple[int, int]]) -> int:\n    \"\"\"\n    Belirli alanlar temizlendikten sonra yol boyunca kalan ağaçların sayısını hesaplayın.\n\n    Yol, uzunluğu 'l' olan düz bir çizgi olarak temsil edilir ve başlangıçta ağaçlarla doludur.\n    Temizlenmesi planlanan her alan, yol boyunca ağaçların kaldırılacağı kapsayıcı aralığı temsil eden\n    bir çift tam sayı (başlangıç, bitiş) olarak belirtilir.\n\n    Argümanlar:\n    - l (int): Yolun uzunluğu.\n    - areas (List[Tuple[int, int]]): Her bir çiftin yoldaki temizlenmiş bir alanı temsil ettiği bir demet listesi.\n    \n    Döndürür:\n    - int: Belirtilen alanlar temizlendikten sonra yol boyunca kalan toplam ağaç sayısı.\n    \n    Örnekler:\n    - remaining_trees_after_clearing(10, [(2, 5), (7, 9)]) 5 döndürecektir, çünkü 2 ile 5 arasındaki\n      ve 7 ile 9 arasındaki pozisyonlardaki ağaçlar temizlenir, 0, 1, 6 ve 10 pozisyonlarında ağaçlar kalır.\n    \n    - remaining_trees_after_clearing(6, [(1, 3), (4, 4)]) 3 döndürecektir, çünkü 1 ile 3 arasındaki\n      ve 4 pozisyonundaki ağaçlar temizlenir, 0, 5 ve 6 pozisyonlarında ağaçlar kalır.\n    \n    - remaining_trees_after_clearing(100, [(10, 90)]) 20 döndürecektir, çünkü 10 ile 90 arasındaki\n      pozisyonlardaki ağaçlar temizlenir, 0 ile 9 ve 91 ile 100 arasındaki pozisyonlarda ağaçlar kalır.\n    \"\"\"",
      "vi": "from typing import List, Tuple\ndef remaining_trees_after_clearing(l: int, areas: List[Tuple[int, int]]) -> int:\n    \"\"\"\n    Tính số lượng cây còn lại dọc theo một con đường sau khi các khu vực cụ thể đã được dọn dẹp.\n\n    Con đường được biểu diễn như một đường thẳng có độ dài 'l' và ban đầu được lấp đầy bằng cây.\n    Mỗi khu vực dự kiến dọn dẹp được chỉ định như một cặp số nguyên (bắt đầu, kết thúc), đại diện cho\n    phạm vi bao gồm dọc theo con đường nơi cây sẽ bị loại bỏ.\n\n    Tham số:\n    - l (int): Độ dài của con đường.\n    - areas (List[Tuple[int, int]]): Một danh sách các cặp số nguyên, mỗi cặp đại diện cho một khu vực đã dọn dẹp trên con đường.\n    \n    Trả về:\n    - int: Tổng số cây còn lại dọc theo con đường sau khi các khu vực đã được dọn dẹp.\n    \n    Ví dụ:\n    - remaining_trees_after_clearing(10, [(2, 5), (7, 9)]) sẽ trả về 5, vì cây từ vị trí 2 đến 5\n      và 7 đến 9 bị dọn dẹp, để lại cây ở vị trí 0, 1, 6, và 10.\n    \n    - remaining_trees_after_clearing(6, [(1, 3), (4, 4)]) sẽ trả về 3, vì cây từ vị trí 1 đến 3\n      và tại vị trí 4 bị dọn dẹp, để lại cây ở vị trí 0, 5, và 6.\n    \n    - remaining_trees_after_clearing(100, [(10, 90)]) sẽ trả về 20, vì cây từ vị trí 10 đến 90\n      bị dọn dẹp, để lại cây ở vị trí 0 đến 9 và 91 đến 100.\n    \"\"\""
    },
    "prompt_bertscore": {
      "es": "0.9882249923818708",
      "arb": "0.9517896256974981",
      "sw": "0.9646517373910313",
      "tr": "0.9626127965297082",
      "vi": "0.9643148602647962"
    },
    "canonical_solution": "    # Initialize the road with trees (True means a tree is present)\n    road_with_trees = [True] * (l + 1)  # +1 because we include both ends\n\n    # Iterate over each area and remove trees\n    for u, v in areas:\n        for i in range(u, v + 1):  # +1 because we include the tree at point v\n            road_with_trees[i] = False\n\n    # Count the remaining trees\n    remaining_trees = sum(road_with_trees)\n    return remaining_trees",
    "instruction": {
      "en": "def remaining_trees_after_clearing(l: int, areas: List[Tuple[int, int]]) -> int:\n    # Initialize the road with trees (True means a tree is present)\n    road_with_trees = [True] * (l + 1)  # +1 because we include both ends\n\n    # Iterate over each area and remove trees\n    for u, v in areas:\n        for i in range(u, v + 1):  # +1 because we include the tree at point v\n            road_with_trees[i] = False\n\n    # Count the remaining trees\n    remaining_trees = sum(road_with_trees)\n    return remaining_trees\n\nProvide a concise natural language description (docstring) of the Python code in English using at most 500 characters.",
      "es": "def remaining_trees_after_clearing(l: int, areas: List[Tuple[int, int]]) -> int:\n    # Initialize the road with trees (True means a tree is present)\n    road_with_trees = [True] * (l + 1)  # +1 because we include both ends\n\n    # Iterate over each area and remove trees\n    for u, v in areas:\n        for i in range(u, v + 1):  # +1 because we include the tree at point v\n            road_with_trees[i] = False\n\n    # Count the remaining trees\n    remaining_trees = sum(road_with_trees)\n    return remaining_trees\n\nProporcione una descripción concisa en lenguaje natural (docstring) del código Python en español utilizando como máximo 500 caracteres.",
      "arb": "def remaining_trees_after_clearing(l: int, areas: List[Tuple[int, int]]) -> int:\n    # Initialize the road with trees (True means a tree is present)\n    road_with_trees = [True] * (l + 1)  # +1 because we include both ends\n\n    # Iterate over each area and remove trees\n    for u, v in areas:\n        for i in range(u, v + 1):  # +1 because we include the tree at point v\n            road_with_trees[i] = False\n\n    # Count the remaining trees\n    remaining_trees = sum(road_with_trees)\n    return remaining_trees\n\nيرجى تقديم وصف موجز بلغة طبيعية (docstring) للشفرة البرمجية بلغة بايثون باللغة العربية الفصحى باستخدام 500 حرف كحد أقصى.",
      "sw": "def remaining_trees_after_clearing(l: int, areas: List[Tuple[int, int]]) -> int:\n    # Initialize the road with trees (True means a tree is present)\n    road_with_trees = [True] * (l + 1)  # +1 because we include both ends\n\n    # Iterate over each area and remove trees\n    for u, v in areas:\n        for i in range(u, v + 1):  # +1 because we include the tree at point v\n            road_with_trees[i] = False\n\n    # Count the remaining trees\n    remaining_trees = sum(road_with_trees)\n    return remaining_trees\n\nToa maelezo mafupi ya lugha asilia (docstring) ya msimbo wa Python kwa Kiswahili kwa kutumia herufi zisizozidi 500.",
      "tr": "def remaining_trees_after_clearing(l: int, areas: List[Tuple[int, int]]) -> int:\n    # Initialize the road with trees (True means a tree is present)\n    road_with_trees = [True] * (l + 1)  # +1 because we include both ends\n\n    # Iterate over each area and remove trees\n    for u, v in areas:\n        for i in range(u, v + 1):  # +1 because we include the tree at point v\n            road_with_trees[i] = False\n\n    # Count the remaining trees\n    remaining_trees = sum(road_with_trees)\n    return remaining_trees\n\nVerilen Python kodunun işlevini açıklayan, en fazla 500 karakter uzunluğunda, özlü bir doğal dil açıklaması (docstring) sağlayın.",
      "vi": "def remaining_trees_after_clearing(l: int, areas: List[Tuple[int, int]]) -> int:\n    # Initialize the road with trees (True means a tree is present)\n    road_with_trees = [True] * (l + 1)  # +1 because we include both ends\n\n    # Iterate over each area and remove trees\n    for u, v in areas:\n        for i in range(u, v + 1):  # +1 because we include the tree at point v\n            road_with_trees[i] = False\n\n    # Count the remaining trees\n    remaining_trees = sum(road_with_trees)\n    return remaining_trees\n\nCung cấp mô tả ngắn gọn bằng ngôn ngữ tự nhiên (docstring) cho mã Python bằng tiếng Việt, sử dụng tối đa 500 ký tự."
    },
    "instruction_bertscore": {
      "es": "0.9687387561112052",
      "arb": "0.924699818440817",
      "sw": "0.9426438884331277",
      "tr": "0.8508820154152974",
      "vi": "0.9256256346468206"
    },
    "level": "",
    "test": "def test_remaining_trees_after_clearing():\n    test_cases = [\n        (500, [(150, 300), (100, 200), (470, 471)], 298),\n        (1000, [(0, 100), (200, 300), (400, 500), (600, 700), (800, 900)], 496),\n        (10, [(3, 4), (7, 9)], 6),\n    ]\n\n    for i, (l, areas, expected) in enumerate(test_cases, 1):\n        result = remaining_trees_after_clearing(l, areas)\n        assert result == expected, f\"Test case {i} failed: expected {expected}, got {result}\"\n        print(f\"Test case {i} passed.\")\n\n\ntest_remaining_trees_after_clearing()",
    "entry_point": "remaining_trees_after_clearing",
    "signature": "def remaining_trees_after_clearing(l: int, areas: List[Tuple[int, int]]) -> int:",
    "docstring": {
      "en": "Calculate the number of remaining trees along a road after specific areas have been cleared.\n\nThe road is represented as a straight line of length 'l' and is initially filled with trees.\nEach area scheduled for clearing is specified as a pair of integers (start, end), representing\nthe inclusive range along the road where the trees will be removed.\n\nArgs:\n- l (int): The length of the road.\n- areas (List[Tuple[int, int]]): A list of tuples where each tuple represents a cleared area on the road.\n\nReturns:\n- int: The total number of trees remaining along the road after the specified areas have been cleared.\n\nExamples:\n- remaining_trees_after_clearing(10, [(2, 5), (7, 9)]) will return 5, as trees from positions 2 to 5\nand 7 to 9 are cleared, leaving trees at positions 0, 1, 6, and 10.\n\n- remaining_trees_after_clearing(6, [(1, 3), (4, 4)]) will return 3, as trees from positions 1 to 3\nand at position 4 are cleared, leaving trees at positions 0, 5, and 6.\n\n- remaining_trees_after_clearing(100, [(10, 90)]) will return 20, as trees from positions 10 to 90\nare cleared, leaving trees at positions 0 to 9 and 91 to 100.",
      "es": "Calcular el número de árboles restantes a lo largo de una carretera después de que se hayan despejado áreas específicas.\n\nLa carretera se representa como una línea recta de longitud 'l' y está inicialmente llena de árboles.\nCada área programada para despejarse se especifica como un par de enteros (inicio, fin), que representa\nel rango inclusivo a lo largo de la carretera donde se eliminarán los árboles.\n\nArgumentos:\n- l (int): La longitud de la carretera.\n- areas (List[Tuple[int, int]]): Una lista de tuplas donde cada tupla representa un área despejada en la carretera.\n\nDevuelve:\n- int: El número total de árboles restantes a lo largo de la carretera después de que las áreas especificadas hayan sido despejadas.\n\nEjemplos:\n- remaining_trees_after_clearing(10, [(2, 5), (7, 9)]) devolverá 5, ya que los árboles de las posiciones 2 a 5\ny 7 a 9 son despejados, dejando árboles en las posiciones 0, 1, 6, y 10.\n\n- remaining_trees_after_clearing(6, [(1, 3), (4, 4)]) devolverá 3, ya que los árboles de las posiciones 1 a 3\ny en la posición 4 son despejados, dejando árboles en las posiciones 0, 5, y 6.\n\n- remaining_trees_after_clearing(100, [(10, 90)]) devolverá 20, ya que los árboles de las posiciones 10 a 90\nson despejados, dejando árboles en las posiciones 0 a 9 y 91 a 100.",
      "arb": "حساب عدد الأشجار المتبقية على طول الطريق بعد إزالة مناطق محددة.\n\nيتم تمثيل الطريق كخط مستقيم بطول 'l' وممتلئ بالأشجار في البداية. يتم تحديد كل منطقة مجدولة للإزالة كزوج من الأعداد الصحيحة (البداية، النهاية)، والتي تمثل النطاق الشامل على طول الطريق حيث سيتم إزالة الأشجار.\n\nالمعطيات:\n- l (int): طول الطريق.\n- areas (List[Tuple[int, int]]): قائمة من الأزواج حيث يمثل كل زوج منطقة تمت إزالتها على الطريق.\n\nالقيم المعادة:\n- int: العدد الإجمالي للأشجار المتبقية على طول الطريق بعد إزالة المناطق المحددة.\n\nأمثلة:\n- remaining_trees_after_clearing(10, [(2, 5), (7, 9)]) سيعيد 5، حيث يتم إزالة الأشجار من المواقع 2 إلى 5 ومن 7 إلى 9، تاركًا الأشجار في المواقع 0، 1، 6، و10.\n\n- remaining_trees_after_clearing(6, [(1, 3), (4, 4)]) سيعيد 3، حيث يتم إزالة الأشجار من المواقع 1 إلى 3 وفي الموقع 4، تاركًا الأشجار في المواقع 0، 5، و6.\n\n- remaining_trees_after_clearing(100, [(10, 90)]) سيعيد 20، حيث يتم إزالة الأشجار من المواقع 10 إلى 90، تاركًا الأشجار في المواقع من 0 إلى 9 ومن 91 إلى 100.",
      "sw": "Kuhesabu idadi ya miti iliyobaki kando ya barabara baada ya maeneo maalum kusafishwa.\n\nBarabara inawakilishwa kama mstari wa moja kwa moja wa urefu 'l' na awali imejaa miti. Kila eneo lililopangwa kwa ajili ya kusafishwa linaelezwa kama jozi ya nambari (mwanzo, mwisho), inayowakilisha safu inayojumuisha kando ya barabara ambapo miti itaondolewa.\n\nHoja:\n- l (int): Urefu wa barabara.\n- areas (List[Tuple[int, int]]): Orodha ya jozi ambapo kila jozi inawakilisha eneo lililosafishwa kwenye barabara.\n\nInarejesha:\n- int: Jumla ya idadi ya miti iliyobaki kando ya barabara baada ya maeneo maalum kusafishwa.\n\nMifano:\n- remaining_trees_after_clearing(10, [(2, 5), (7, 9)]) itarudisha 5, kwani miti kutoka nafasi 2 hadi 5 na 7 hadi 9 imeondolewa, ikiacha miti katika nafasi 0, 1, 6, na 10.\n\n- remaining_trees_after_clearing(6, [(1, 3), (4, 4)]) itarudisha 3, kwani miti kutoka nafasi 1 hadi 3 na katika nafasi 4 imeondolewa, ikiacha miti katika nafasi 0, 5, na 6.\n\n- remaining_trees_after_clearing(100, [(10, 90)]) itarudisha 20, kwani miti kutoka nafasi 10 hadi 90 imeondolewa, ikiacha miti katika nafasi 0 hadi 9 na 91 hadi 100.",
      "tr": "Yol boyunca belirli alanlar temizlendikten sonra kalan ağaçların sayısını hesaplayın.\n\nYol, uzunluğu 'l' olan düz bir çizgi olarak temsil edilir ve başlangıçta ağaçlarla doludur.\nTemizlenmesi planlanan her alan, yol boyunca ağaçların kaldırılacağı kapsayıcı aralığı temsil eden\nbir çift tam sayı (başlangıç, bitiş) olarak belirtilir.\n\nArgümanlar:\n- l (int): Yolun uzunluğu.\n- areas (List[Tuple[int, int]]): Her bir demetin yoldaki temizlenmiş bir alanı temsil ettiği demetlerin listesi.\n\nDöndürür:\n- int: Belirtilen alanlar temizlendikten sonra yol boyunca kalan toplam ağaç sayısı.\n\nÖrnekler:\n- remaining_trees_after_clearing(10, [(2, 5), (7, 9)]) 5 döndürecektir, çünkü 2'den 5'e ve 7'den 9'a kadar olan\npozisyonlardaki ağaçlar temizlenir, 0, 1, 6 ve 10 pozisyonlarında ağaçlar kalır.\n\n- remaining_trees_after_clearing(6, [(1, 3), (4, 4)]) 3 döndürecektir, çünkü 1'den 3'e kadar olan pozisyonlardaki\nve 4 pozisyonundaki ağaçlar temizlenir, 0, 5 ve 6 pozisyonlarında ağaçlar kalır.\n\n- remaining_trees_after_clearing(100, [(10, 90)]) 20 döndürecektir, çünkü 10'dan 90'a kadar olan pozisyonlardaki\nağaçlar temizlenir, 0'dan 9'a ve 91'den 100'e kadar olan pozisyonlarda ağaçlar kalır.",
      "vi": "Tính số lượng cây còn lại dọc theo một con đường sau khi các khu vực cụ thể đã được dọn sạch.\n\nCon đường được biểu diễn như một đường thẳng có độ dài 'l' và ban đầu được lấp đầy bởi cây.\nMỗi khu vực dự kiến dọn sạch được chỉ định như một cặp số nguyên (bắt đầu, kết thúc), đại diện cho\nphạm vi bao gồm dọc theo con đường nơi cây sẽ bị loại bỏ.\n\nTham số:\n- l (int): Độ dài của con đường.\n- areas (List[Tuple[int, int]]): Một danh sách các bộ giá trị, trong đó mỗi bộ giá trị đại diện cho một khu vực đã được dọn sạch trên con đường.\n\nTrả về:\n- int: Tổng số cây còn lại dọc theo con đường sau khi các khu vực đã được dọn sạch.\n\nVí dụ:\n- remaining_trees_after_clearing(10, [(2, 5), (7, 9)]) sẽ trả về 5, vì cây từ vị trí 2 đến 5\nvà 7 đến 9 bị dọn sạch, để lại cây ở vị trí 0, 1, 6, và 10.\n\n- remaining_trees_after_clearing(6, [(1, 3), (4, 4)]) sẽ trả về 3, vì cây từ vị trí 1 đến 3\nvà tại vị trí 4 bị dọn sạch, để lại cây ở vị trí 0, 5, và 6.\n\n- remaining_trees_after_clearing(100, [(10, 90)]) sẽ trả về 20, vì cây từ vị trí 10 đến 90\nbị dọn sạch, để lại cây ở vị trí 0 đến 9 và 91 đến 100."
    },
    "docstring_bertscore": {
      "es": "0.9834411782850265",
      "arb": "0.9363349902706977",
      "sw": "0.9653536971576085",
      "tr": "0.9794026253778252",
      "vi": "0.9775100751073248"
    }
  },
  {
    "task_id": "Python/37",
    "prompt": {
      "en": "from typing import List, Tuple \ndef max_herb_value(T: int, M: int, herbs: List[Tuple[int, int]]) -> int:\n    \"\"\"\n    Calculate the maximum total value of herbs that can be picked within a given time limit.\n\n    This function solves a variation of the 0/1 knapsack problem where the goal is to maximize\n    the total value of herbs picked without exceeding the time limit. Each herb can be picked\n    at most once and has an associated time cost and value.\n\n    Args:\n    - T (int): The total time available for picking herbs.\n    - M (int): The number of different herbs in the cave.\n    - herbs (List[Tuple[int, int]]): A list of tuples, where each tuple contains two integers\n      representing the time required to pick the herb and the herb's value, respectively.\n\n    Returns:\n    - int: The maximum total value of herbs that can be picked within the time limit.\n\n    Examples:\n    - max_herb_value(70, 3, [(71, 100), (69, 1), (1, 2)]) -> 3\n      In this scenario, only the herb that takes 1 unit of time for a value of 2 can be picked due\n      to the time constraint, leading to a maximum value of 3.\n\n    - max_herb_value(10, 4, [(1, 10), (2, 15), (3, 20), (4, 30)]) -> 50\n      Here, the best strategy is to pick herbs with times 1, 2, and 3, leading to a maximum value of 10 + 15 + 20 = 50.\n\n    - max_herb_value(5, 3, [(5, 10), (4, 7), (6, 12)]) -> 10\n      With a time limit of 5, only the first herb can be picked, providing a value of 10.\n    \"\"\"",
      "es": "from typing import List, Tuple \ndef max_herb_value(T: int, M: int, herbs: List[Tuple[int, int]]) -> int:\n    \"\"\"\n    Calcular el valor total máximo de hierbas que se pueden recoger dentro de un límite de tiempo dado.\n\n    Esta función resuelve una variación del problema de la mochila 0/1 donde el objetivo es maximizar\n    el valor total de las hierbas recogidas sin exceder el límite de tiempo. Cada hierba se puede recoger\n    como máximo una vez y tiene un costo de tiempo y un valor asociados.\n\n    Argumentos:\n    - T (int): El tiempo total disponible para recoger hierbas.\n    - M (int): El número de diferentes hierbas en la cueva.\n    - herbs (List[Tuple[int, int]]): Una lista de tuplas, donde cada tupla contiene dos enteros\n      que representan el tiempo requerido para recoger la hierba y el valor de la hierba, respectivamente.\n\n    Devuelve:\n    - int: El valor total máximo de hierbas que se pueden recoger dentro del límite de tiempo.\n\n    Ejemplos:\n    - max_herb_value(70, 3, [(71, 100), (69, 1), (1, 2)]) -> 3\n      En este escenario, solo se puede recoger la hierba que toma 1 unidad de tiempo por un valor de 2\n      debido a la restricción de tiempo, lo que lleva a un valor máximo de 3.\n\n    - max_herb_value(10, 4, [(1, 10), (2, 15), (3, 20), (4, 30)]) -> 50\n      Aquí, la mejor estrategia es recoger las hierbas con tiempos 1, 2 y 3, lo que lleva a un valor máximo de 10 + 15 + 20 = 50.\n\n    - max_herb_value(5, 3, [(5, 10), (4, 7), (6, 12)]) -> 10\n      Con un límite de tiempo de 5, solo se puede recoger la primera hierba, proporcionando un valor de 10.\n    \"\"\"",
      "arb": "from typing import List, Tuple \ndef max_herb_value(T: int, M: int, herbs: List[Tuple[int, int]]) -> int:\n    \"\"\"\n    حساب القيمة الإجمالية القصوى للأعشاب التي يمكن جمعها ضمن حد زمني معين.\n\n    تحل هذه الدالة نوعًا من مشكلة الحقيبة 0/1 حيث يكون الهدف هو تعظيم\n    القيمة الإجمالية للأعشاب المجمعة دون تجاوز الحد الزمني. يمكن جمع كل عشب\n    مرة واحدة فقط وله تكلفة زمنية وقيمة مرتبطة به.\n\n    يعيدالحجج:\n    - T (int): إجمالي الوقت المتاح لجمع الأعشاب.\n    - M (int): عدد أنواع الأعشاب المختلفة في الكهف.\n    - herbs (List[Tuple[int, int]]): قائمة من الأزواج، حيث يحتوي كل زوج على عددين صحيحين\n      يمثلان الوقت المطلوب لجمع العشب وقيمة العشب، على التوالي.\n\n    يعيد:\n    - int: القيمة الإجمالية القصوى للأعشاب التي يمكن جمعها ضمن الحد الزمني.\n\n    أمثلة:\n    - max_herb_value(70, 3, [(71, 100), (69, 1), (1, 2)]) -> 3\n      في هذا السيناريو، يمكن جمع العشب الذي يستغرق 1 وحدة زمنية فقط بقيمة 2\n      بسبب قيود الوقت، مما يؤدي إلى قيمة قصوى قدرها 3.\n\n    - max_herb_value(10, 4, [(1, 10), (2, 15), (3, 20), (4, 30)]) -> 50\n      هنا، أفضل استراتيجية هي جمع الأعشاب ذات الأوقات 1، 2، و3، مما يؤدي إلى قيمة قصوى قدرها 10 + 15 + 20 = 50.\n\n    - max_herb_value(5, 3, [(5, 10), (4, 7), (6, 12)]) -> 10\n      مع حد زمني قدره 5، يمكن جمع العشب الأول فقط، مما يوفر قيمة قدرها 10.\n    \"\"\"",
      "sw": "from typing import List, Tuple \ndef max_herb_value(T: int, M: int, herbs: List[Tuple[int, int]]) -> int:\n    \"\"\"\n    Hesabu thamani ya juu kabisa ya mimea ya dawa inayoweza kuchukuliwa ndani ya kikomo cha muda kilichopewa.\n\n    Kazi hii inatatua tofauti ya tatizo la 0/1 knapsack ambapo lengo ni kuongeza\n    thamani ya jumla ya mimea ya dawa iliyochukuliwa bila kuzidi kikomo cha muda. Kila mmea wa dawa unaweza kuchukuliwa\n    mara moja tu na una gharama ya muda na thamani inayohusiana.\n\n    Hoja:\n    - T (int): Jumla ya muda unaopatikana kwa kuchukua mimea ya dawa.\n    - M (int): Idadi ya mimea ya dawa tofauti kwenye pango.\n    - herbs (List[Tuple[int, int]]): Orodha ya jozi, ambapo kila jozi ina nambari mbili\n      zinazowakilisha muda unaohitajika kuchukua mmea wa dawa na thamani ya mmea wa dawa, mtawalia.\n\n    Inarudisha:\n    - int: Thamani ya juu kabisa ya mimea ya dawa inayoweza kuchukuliwa ndani ya kikomo cha muda.\n\n    Mifano:\n    - max_herb_value(70, 3, [(71, 100), (69, 1), (1, 2)]) -> 3\n      Katika hali hii, ni mmea wa dawa tu unaochukua kitengo 1 cha muda kwa thamani ya 2 unaweza kuchukuliwa kwa\n      sababu ya kikomo cha muda, na kusababisha thamani ya juu ya 3.\n\n    - max_herb_value(10, 4, [(1, 10), (2, 15), (3, 20), (4, 30)]) -> 50\n      Hapa, mkakati bora ni kuchukua mimea ya dawa yenye muda 1, 2, na 3, na kusababisha thamani ya juu ya 10 + 15 + 20 = 50.\n\n    - max_herb_value(5, 3, [(5, 10), (4, 7), (6, 12)]) -> 10\n      Kwa kikomo cha muda cha 5, ni mmea wa kwanza tu unaweza kuchukuliwa, ukitoa thamani ya 10.\n    \"\"\"",
      "tr": "from typing import List, Tuple \ndef max_herb_value(T: int, M: int, herbs: List[Tuple[int, int]]) -> int:\n    \"\"\"\n    Belirli bir zaman sınırı içinde toplanabilecek otların maksimum toplam değerini hesaplayın.\n\n    Bu fonksiyon, zaman sınırını aşmadan toplanan otların toplam değerini maksimize etmeyi amaçlayan\n    0/1 sırt çantası probleminin bir varyasyonunu çözer. Her ot en fazla bir kez toplanabilir ve\n    her birinin bir zaman maliyeti ve değeri vardır.\n\n    Argümanlar:\n    - T (int): Ot toplamak için mevcut toplam zaman.\n    - M (int): Mağaradaki farklı otların sayısı.\n    - herbs (List[Tuple[int, int]]): Her bir demetin, sırasıyla otu toplamak için gereken zamanı ve\n      otun değerini temsil eden iki tam sayı içeren bir demet listesi.\n\n    Döndürür:\n    - int: Zaman sınırı içinde toplanabilecek otların maksimum toplam değeri.\n\n    Örnekler:\n    - max_herb_value(70, 3, [(71, 100), (69, 1), (1, 2)]) -> 3\n      Bu senaryoda, zaman kısıtlaması nedeniyle yalnızca 1 birim zaman alan ve değeri 2 olan ot\n      toplanabilir, bu da maksimum 3 değerine yol açar.\n\n    - max_herb_value(10, 4, [(1, 10), (2, 15), (3, 20), (4, 30)]) -> 50\n      Burada en iyi strateji, 1, 2 ve 3 zamanlı otları toplamaktır, bu da 10 + 15 + 20 = 50 maksimum\n      değerine yol açar.\n\n    - max_herb_value(5, 3, [(5, 10), (4, 7), (6, 12)]) -> 10\n      5 zaman sınırı ile yalnızca ilk ot toplanabilir ve bu da 10 değer sağlar.\n    \"\"\"",
      "vi": "from typing import List, Tuple \ndef max_herb_value(T: int, M: int, herbs: List[Tuple[int, int]]) -> int:\n    \"\"\"\n    Tính toán giá trị tối đa của các loại thảo mộc có thể hái được trong giới hạn thời gian cho phép.\n\n    Hàm này giải quyết một biến thể của bài toán ba lô 0/1, trong đó mục tiêu là tối đa hóa\n    tổng giá trị của các loại thảo mộc hái được mà không vượt quá giới hạn thời gian. Mỗi loại thảo mộc có thể được hái\n    nhiều nhất một lần và có chi phí thời gian và giá trị tương ứng.\n\n    Tham số:\n    - T (int): Tổng thời gian có sẵn để hái thảo mộc.\n    - M (int): Số lượng loại thảo mộc khác nhau trong hang động.\n    - herbs (List[Tuple[int, int]]): Một danh sách các bộ giá trị, trong đó mỗi bộ chứa hai số nguyên\n      đại diện cho thời gian cần thiết để hái thảo mộc và giá trị của thảo mộc đó, tương ứng.\n\n    Trả về:\n    - int: Giá trị tối đa của các loại thảo mộc có thể hái được trong giới hạn thời gian.\n\n    Ví dụ:\n    - max_herb_value(70, 3, [(71, 100), (69, 1), (1, 2)]) -> 3\n      Trong trường hợp này, chỉ có loại thảo mộc mất 1 đơn vị thời gian với giá trị 2 có thể được hái\n      do giới hạn thời gian, dẫn đến giá trị tối đa là 3.\n\n    - max_herb_value(10, 4, [(1, 10), (2, 15), (3, 20), (4, 30)]) -> 50\n      Ở đây, chiến lược tốt nhất là hái các loại thảo mộc với thời gian 1, 2 và 3, dẫn đến giá trị tối đa là 10 + 15 + 20 = 50.\n\n    - max_herb_value(5, 3, [(5, 10), (4, 7), (6, 12)]) -> 10\n      Với giới hạn thời gian là 5, chỉ có loại thảo mộc đầu tiên có thể được hái, cung cấp giá trị là 10.\n    \"\"\""
    },
    "prompt_bertscore": {
      "es": "0.9818136009428267",
      "arb": "0.9592027101481012",
      "sw": "0.9595848750012124",
      "tr": "0.9604638144372917",
      "vi": "0.9672702817042143"
    },
    "canonical_solution": "    dp = [[0 for _ in range(T + 1)] for _ in range(M + 1)]\n\n    for i in range(1, M + 1):\n        for j in range(1, T + 1):\n            time, value = herbs[i - 1]\n            if j >= time:\n                # We can choose to pick this herb or not\n                dp[i][j] = max(dp[i - 1][j], dp[i - 1][j - time] + value)\n            else:\n                # We cannot pick this herb due to time constraint\n                dp[i][j] = dp[i - 1][j]\n\n    return dp[M][T]",
    "instruction": {
      "en": "def max_herb_value(T: int, M: int, herbs: List[Tuple[int, int]]) -> int:\n    dp = [[0 for _ in range(T + 1)] for _ in range(M + 1)]\n\n    for i in range(1, M + 1):\n        for j in range(1, T + 1):\n            time, value = herbs[i - 1]\n            if j >= time:\n                # We can choose to pick this herb or not\n                dp[i][j] = max(dp[i - 1][j], dp[i - 1][j - time] + value)\n            else:\n                # We cannot pick this herb due to time constraint\n                dp[i][j] = dp[i - 1][j]\n\n    return dp[M][T]\n\nProvide a concise natural language description (docstring) of the Python code in English using at most 500 characters.",
      "es": "def max_herb_value(T: int, M: int, herbs: List[Tuple[int, int]]) -> int:\n    dp = [[0 for _ in range(T + 1)] for _ in range(M + 1)]\n\n    for i in range(1, M + 1):\n        for j in range(1, T + 1):\n            time, value = herbs[i - 1]\n            if j >= time:\n                # We can choose to pick this herb or not\n                dp[i][j] = max(dp[i - 1][j], dp[i - 1][j - time] + value)\n            else:\n                # We cannot pick this herb due to time constraint\n                dp[i][j] = dp[i - 1][j]\n\n    return dp[M][T]\n\nProporcione una descripción concisa en lenguaje natural (docstring) del código Python en español utilizando un máximo de 500 caracteres.",
      "arb": "def max_herb_value(T: int, M: int, herbs: List[Tuple[int, int]]) -> int:\n    dp = [[0 for _ in range(T + 1)] for _ in range(M + 1)]\n\n    for i in range(1, M + 1):\n        for j in range(1, T + 1):\n            time, value = herbs[i - 1]\n            if j >= time:\n                # We can choose to pick this herb or not\n                dp[i][j] = max(dp[i - 1][j], dp[i - 1][j - time] + value)\n            else:\n                # We cannot pick this herb due to time constraint\n                dp[i][j] = dp[i - 1][j]\n\n    return dp[M][T]\n\nيرجى تقديم وصف موجز بلغة طبيعية (docstring) للكود البرمجي بلغة بايثون باللغة العربية الفصحى، بحيث لا يتجاوز 500 حرف.",
      "sw": "def max_herb_value(T: int, M: int, herbs: List[Tuple[int, int]]) -> int:\n    dp = [[0 for _ in range(T + 1)] for _ in range(M + 1)]\n\n    for i in range(1, M + 1):\n        for j in range(1, T + 1):\n            time, value = herbs[i - 1]\n            if j >= time:\n                # We can choose to pick this herb or not\n                dp[i][j] = max(dp[i - 1][j], dp[i - 1][j - time] + value)\n            else:\n                # We cannot pick this herb due to time constraint\n                dp[i][j] = dp[i - 1][j]\n\n    return dp[M][T]\n\nToa maelezo mafupi ya lugha ya asili (docstring) ya msimbo wa Python kwa Kiswahili kwa kutumia herufi zisizozidi 500.",
      "tr": "def max_herb_value(T: int, M: int, herbs: List[Tuple[int, int]]) -> int:\n    dp = [[0 for _ in range(T + 1)] for _ in range(M + 1)]\n\n    for i in range(1, M + 1):\n        for j in range(1, T + 1):\n            time, value = herbs[i - 1]\n            if j >= time:\n                # We can choose to pick this herb or not\n                dp[i][j] = max(dp[i - 1][j], dp[i - 1][j - time] + value)\n            else:\n                # We cannot pick this herb due to time constraint\n                dp[i][j] = dp[i - 1][j]\n\n    return dp[M][T]\n\nVerilen Python kodunun işlevselliğini açıklayan, en fazla 500 karakter uzunluğunda özlü bir doğal dil açıklaması (docstring) sağlayın.",
      "vi": "def max_herb_value(T: int, M: int, herbs: List[Tuple[int, int]]) -> int:\n    dp = [[0 for _ in range(T + 1)] for _ in range(M + 1)]\n\n    for i in range(1, M + 1):\n        for j in range(1, T + 1):\n            time, value = herbs[i - 1]\n            if j >= time:\n                # We can choose to pick this herb or not\n                dp[i][j] = max(dp[i - 1][j], dp[i - 1][j - time] + value)\n            else:\n                # We cannot pick this herb due to time constraint\n                dp[i][j] = dp[i - 1][j]\n\n    return dp[M][T]\n\nCung cấp mô tả ngắn gọn bằng ngôn ngữ tự nhiên (docstring) cho mã Python bằng tiếng Việt, sử dụng tối đa 500 ký tự."
    },
    "instruction_bertscore": {
      "es": "0.9687387561112052",
      "arb": "0.9141696274206335",
      "sw": "0.914896018724078",
      "tr": "0.8520511538380687",
      "vi": "0.9403930089552404"
    },
    "level": "",
    "test": "def test_max_herb_value():\n    # Test case 1: Given example in the problem statement\n    T1, M1 = 70, 3\n    herbs1 = [(71, 100), (69, 1), (1, 2)]\n    expected1 = 3\n    assert max_herb_value(T1, M1,\n                          herbs1) == expected1, f\"Test case 1 failed: expected {expected1}, got {max_herb_value(T1, M1, herbs1)}\"\n\n    # Test case 2: Multiple herbs can be picked within the time limit\n    T2, M2 = 10, 4\n    herbs2 = [(1, 10), (2, 15), (3, 20), (4, 30)]\n    expected2 = 75  # We can pick herbs with time 1, 2 and 3 to get maximum value 10 + 15 + 20\n    assert max_herb_value(T2, M2,\n                          herbs2) == expected2, f\"Test case 2 failed: expected {expected2}, got {max_herb_value(T2, M2, herbs2)}\"\n\n    # Test case 3: Only one herb can be picked due to time constraint\n    T3, M3 = 5, 3\n    herbs3 = [(5, 10), (4, 7), (6, 12)]\n    expected3 = 10  # We can only pick the first herb\n    assert max_herb_value(T3, M3,\n                          herbs3) == expected3, f\"Test case 3 failed: expected {expected3}, got {max_herb_value(T3, M3, herbs3)}\"\n\n    # If all tests pass, print this:\n    print(\"All test cases passed!\")\ntest_max_herb_value()",
    "entry_point": "max_herb_value",
    "signature": "def max_herb_value(T: int, M: int, herbs: List[Tuple[int, int]]) -> int:",
    "docstring": {
      "en": "Calculate the maximum total value of herbs that can be picked within a given time limit.\n\nThis function solves a variation of the 0/1 knapsack problem where the goal is to maximize\nthe total value of herbs picked without exceeding the time limit. Each herb can be picked\nat most once and has an associated time cost and value.\n\nArgs:\n- T (int): The total time available for picking herbs.\n- M (int): The number of different herbs in the cave.\n- herbs (List[Tuple[int, int]]): A list of tuples, where each tuple contains two integers\nrepresenting the time required to pick the herb and the herb's value, respectively.\n\nReturns:\n- int: The maximum total value of herbs that can be picked within the time limit.\n\nExamples:\n- max_herb_value(70, 3, [(71, 100), (69, 1), (1, 2)]) -> 3\nIn this scenario, only the herb that takes 1 unit of time for a value of 2 can be picked due\nto the time constraint, leading to a maximum value of 3.\n\n- max_herb_value(10, 4, [(1, 10), (2, 15), (3, 20), (4, 30)]) -> 50\nHere, the best strategy is to pick herbs with times 1, 2, and 3, leading to a maximum value of 10 + 15 + 20 = 50.\n\n- max_herb_value(5, 3, [(5, 10), (4, 7), (6, 12)]) -> 10\nWith a time limit of 5, only the first herb can be picked, providing a value of 10.",
      "es": "Calcular el valor total máximo de hierbas que se pueden recoger dentro de un límite de tiempo dado.\n\nEsta función resuelve una variación del problema de la mochila 0/1 donde el objetivo es maximizar\nel valor total de las hierbas recogidas sin exceder el límite de tiempo. Cada hierba se puede recoger\ncomo máximo una vez y tiene un costo de tiempo y un valor asociados.\n\nArgumentos:\n- T (int): El tiempo total disponible para recoger hierbas.\n- M (int): El número de diferentes hierbas en la cueva.\n- herbs (List[Tuple[int, int]]): Una lista de tuplas, donde cada tupla contiene dos enteros\nque representan el tiempo requerido para recoger la hierba y el valor de la hierba, respectivamente.\n\nDevuelve:\n- int: El valor total máximo de hierbas que se pueden recoger dentro del límite de tiempo.\n\nEjemplos:\n- max_herb_value(70, 3, [(71, 100), (69, 1), (1, 2)]) -> 3\nEn este escenario, solo se puede recoger la hierba que toma 1 unidad de tiempo por un valor de 2 debido\na la restricción de tiempo, lo que lleva a un valor máximo de 3.\n\n- max_herb_value(10, 4, [(1, 10), (2, 15), (3, 20), (4, 30)]) -> 50\nAquí, la mejor estrategia es recoger hierbas con tiempos 1, 2 y 3, lo que lleva a un valor máximo de 10 + 15 + 20 = 50.\n\n- max_herb_value(5, 3, [(5, 10), (4, 7), (6, 12)]) -> 10\nCon un límite de tiempo de 5, solo se puede recoger la primera hierba, proporcionando un valor de 10.",
      "arb": "حساب القيمة الإجمالية القصوى للأعشاب التي يمكن جمعها ضمن حد زمني معين.\n\nتحل هذه الدالة نوعًا من مشكلة حقيبة الظهر 0/1 حيث يكون الهدف هو تعظيم القيمة الإجمالية للأعشاب المجمعة دون تجاوز الحد الزمني. يمكن جمع كل عشبة مرة واحدة على الأكثر ولها تكلفة زمنية وقيمة مرتبطة بها.\n\nيعيدالحجج:\n- T (int): الوقت الإجمالي المتاح لجمع الأعشاب.\n- M (int): عدد الأعشاب المختلفة في الكهف.\n- herbs (List[Tuple[int, int]]): قائمة من الأزواج، حيث يحتوي كل زوج على عددين صحيحين يمثلان الوقت المطلوب لجمع العشبة وقيمة العشبة، على التوالي.\n\nيعيد:\n- int: القيمة الإجمالية القصوى للأعشاب التي يمكن جمعها ضمن الحد الزمني.\n\nامثله:\n- max_herb_value(70, 3, [(71, 100), (69, 1), (1, 2)]) -> 3\nفي هذا السيناريو، يمكن جمع العشبة التي تستغرق وحدة زمنية واحدة فقط بقيمة 2 بسبب القيد الزمني، مما يؤدي إلى قيمة قصوى تبلغ 3.\n\n- max_herb_value(10, 4, [(1, 10), (2, 15), (3, 20), (4, 30)]) -> 50\nهنا، أفضل استراتيجية هي جمع الأعشاب ذات الأوقات 1 و2 و3، مما يؤدي إلى قيمة قصوى تبلغ 10 + 15 + 20 = 50.\n\n- max_herb_value(5, 3, [(5, 10), (4, 7), (6, 12)]) -> 10\nمع حد زمني يبلغ 5، يمكن جمع العشبة الأولى فقط، مما يوفر قيمة تبلغ 10.",
      "sw": "Hesabu thamani ya juu kabisa ya mimea ambayo inaweza kuchumwa ndani ya kikomo cha muda kilichopewa.\n\nKazi hii inatatua tofauti ya tatizo la 0/1 knapsack ambapo lengo ni kuongeza\nthamani ya jumla ya mimea iliyochumwa bila kuzidi kikomo cha muda. Kila mmea unaweza kuchumwa\nmara moja tu na una gharama ya muda na thamani inayohusiana.\n\nHoja:\n- T (int): Jumla ya muda unaopatikana kwa kuchuma mimea.\n- M (int): Idadi ya mimea tofauti kwenye pango.\n- herbs (List[Tuple[int, int]]): Orodha ya jozi, ambapo kila jozi ina namba mbili\nzinazoonyesha muda unaohitajika kuchuma mmea na thamani ya mmea, mtawalia.\n\nInarejesha:\n- int: Thamani ya juu kabisa ya mimea ambayo inaweza kuchumwa ndani ya kikomo cha muda.\n\nMifano:\n- max_herb_value(70, 3, [(71, 100), (69, 1), (1, 2)]) -> 3\nKatika hali hii, mmea pekee unaochukua muda wa kitengo 1 kwa thamani ya 2 unaweza kuchumwa kwa sababu\nya kizuizi cha muda, na kusababisha thamani ya juu kabisa ya 3.\n\n- max_herb_value(10, 4, [(1, 10), (2, 15), (3, 20), (4, 30)]) -> 50\nHapa, mkakati bora ni kuchuma mimea yenye muda 1, 2, na 3, na kusababisha thamani ya juu kabisa ya 10 + 15 + 20 = 50.\n\n- max_herb_value(5, 3, [(5, 10), (4, 7), (6, 12)]) -> 10\nKwa kikomo cha muda cha 5, mmea wa kwanza tu unaweza kuchumwa, ukitoa thamani ya 10.",
      "tr": "Belirli bir zaman sınırı içinde toplanabilecek otların maksimum toplam değerini hesaplayın.\n\nBu fonksiyon, zaman sınırını aşmadan toplanan otların toplam değerini maksimize etmeyi amaçlayan 0/1 sırt çantası probleminin bir varyasyonunu çözer. Her ot en fazla bir kez toplanabilir ve bir zaman maliyeti ve değeri ile ilişkilidir.\n\nArgümanlar:\n- T (int): Ot toplamak için mevcut toplam zaman.\n- M (int): Mağaradaki farklı otların sayısı.\n- herbs (List[Tuple[int, int]]): Her bir demetin otu toplamak için gereken zamanı ve otun değerini temsil eden iki tam sayı içeren demetlerden oluşan bir liste.\n\nDöndürür:\n- int: Zaman sınırı içinde toplanabilecek otların maksimum toplam değeri.\n\nÖrnekler:\n- max_herb_value(70, 3, [(71, 100), (69, 1), (1, 2)]) -> 3\nBu senaryoda, zaman kısıtlaması nedeniyle yalnızca 2 değerinde ve 1 birim zaman alan ot toplanabilir, bu da maksimum 3 değerine yol açar.\n\n- max_herb_value(10, 4, [(1, 10), (2, 15), (3, 20), (4, 30)]) -> 50\nBurada, en iyi strateji 1, 2 ve 3 zamanlı otları toplamaktır, bu da 10 + 15 + 20 = 50 maksimum değerine yol açar.\n\n- max_herb_value(5, 3, [(5, 10), (4, 7), (6, 12)]) -> 10\n5 zaman sınırı ile yalnızca ilk ot toplanabilir ve bu 10 değer sağlar.",
      "vi": "Tính tổng giá trị tối đa của các loại thảo mộc có thể được hái trong giới hạn thời gian cho phép.\n\nHàm này giải quyết một biến thể của bài toán cái túi 0/1, trong đó mục tiêu là tối đa hóa\ntổng giá trị của các loại thảo mộc được hái mà không vượt quá giới hạn thời gian. Mỗi loại thảo mộc có thể được hái\ntối đa một lần và có một chi phí thời gian và giá trị tương ứng.\n\nTham số:\n- T (int): Tổng thời gian có sẵn để hái thảo mộc.\n- M (int): Số lượng các loại thảo mộc khác nhau trong hang động.\n- herbs (List[Tuple[int, int]]): Một danh sách các bộ đôi, trong đó mỗi bộ đôi chứa hai số nguyên\nđại diện cho thời gian cần thiết để hái thảo mộc và giá trị của thảo mộc đó, tương ứng.\n\nTrả về:\n- int: Tổng giá trị tối đa của các loại thảo mộc có thể được hái trong giới hạn thời gian.\n\nVí dụ:\n- max_herb_value(70, 3, [(71, 100), (69, 1), (1, 2)]) -> 3\nTrong trường hợp này, chỉ có loại thảo mộc cần 1 đơn vị thời gian với giá trị 2 có thể được hái do\ngiới hạn thời gian, dẫn đến giá trị tối đa là 3.\n\n- max_herb_value(10, 4, [(1, 10), (2, 15), (3, 20), (4, 30)]) -> 50\nỞ đây, chiến lược tốt nhất là hái các loại thảo mộc với thời gian 1, 2 và 3, dẫn đến giá trị tối đa là 10 + 15 + 20 = 50.\n\n- max_herb_value(5, 3, [(5, 10), (4, 7), (6, 12)]) -> 10\nVới giới hạn thời gian là 5, chỉ có loại thảo mộc đầu tiên có thể được hái, cung cấp giá trị là 10."
    },
    "docstring_bertscore": {
      "es": "0.9820608957672151",
      "arb": "0.9686597012195532",
      "sw": "0.9519413793086088",
      "tr": "0.9618013914231807",
      "vi": "0.9616273912093941"
    }
  },
  {
    "task_id": "Python/38",
    "prompt": {
      "en": "from typing import List\ndef min_remaining_space(V: int, n: int, volumes: List[int]) -> int:\n    \"\"\"\n    Calculate the minimum remaining space in a box after trying to fit a number of items with given volumes.\n    \n    This function uses a dynamic programming approach to determine the maximum volume that can be occupied\n    in the box by any subset of the given items. It then returns the difference between the box's total capacity\n    and this maximum occupied volume, which is the minimum remaining space.\n\n    Args:\n    - V (int): The total capacity of the box.\n    - n (int): The number of items to consider for packing into the box.\n    - volumes (List[int]): A list of the volumes of the n items.\n\n    Returns:\n    - int: The minimum remaining space in the box after fitting the items.\n\n    Examples:\n    - min_remaining_space(24, 6, [8, 3, 12, 7, 9, 7]) -> 0\n      All items can be fit into the box without any remaining space.\n\n    - min_remaining_space(10, 4, [3, 5, 3, 2]) -> 2\n      An optimal way to fit the items could be taking items with volumes 3, 5, and 3, which leaves 2 units of space.\n\n    - min_remaining_space(5, 3, [6, 7, 8]) -> 5\n      Since all items have a volume greater than the box capacity, none can be fit and the entire box capacity remains.\n    \"\"\"",
      "es": "from typing import List\ndef min_remaining_space(V: int, n: int, volumes: List[int]) -> int:\n    \"\"\"\n    Calcula el espacio mínimo restante en una caja después de intentar encajar un número de artículos con volúmenes dados.\n    \n    Esta función utiliza un enfoque de programación dinámica para determinar el volumen máximo que puede ser ocupado\n    en la caja por cualquier subconjunto de los artículos dados. Luego devuelve la diferencia entre la capacidad total de la caja\n    y este volumen máximo ocupado, que es el espacio mínimo restante.\n\n    Argumentos:\n    - V (int): La capacidad total de la caja.\n    - n (int): El número de artículos a considerar para empacar en la caja.\n    - volumes (List[int]): Una lista de los volúmenes de los n artículos.\n\n    Devuelve:\n    - int: El espacio mínimo restante en la caja después de encajar los artículos.\n\n    Ejemplos:\n    - min_remaining_space(24, 6, [8, 3, 12, 7, 9, 7]) -> 0\n      Todos los artículos pueden ser encajados en la caja sin ningún espacio restante.\n\n    - min_remaining_space(10, 4, [3, 5, 3, 2]) -> 2\n      Una forma óptima de encajar los artículos podría ser tomando artículos con volúmenes 3, 5 y 3, lo que deja 2 unidades de espacio.\n\n    - min_remaining_space(5, 3, [6, 7, 8]) -> 5\n      Dado que todos los artículos tienen un volumen mayor que la capacidad de la caja, ninguno puede ser encajado y la capacidad total de la caja permanece.\n    \"\"\"",
      "arb": "from typing import List\ndef min_remaining_space(V: int, n: int, volumes: List[int]) -> int:\n    \"\"\"\n    حساب الحد الأدنى من المساحة المتبقية في صندوق بعد محاولة وضع عدد من العناصر ذات الأحجام المعطاة.\n\n    تستخدم هذه الدالة نهج البرمجة الديناميكية لتحديد الحد الأقصى للحجم الذي يمكن أن يشغله\n    في الصندوق بواسطة أي مجموعة فرعية من العناصر المعطاة. ثم تعيد الفرق بين السعة الإجمالية للصندوق\n    وهذا الحجم المشغول الأقصى، وهو الحد الأدنى من المساحة المتبقية.\n\n    يعيدالحجج:\n    - V (int): السعة الإجمالية للصندوق.\n    - n (int): عدد العناصر المراد النظر فيها للتعبئة في الصندوق.\n    - volumes (List[int]): قائمة بأحجام العناصر n.\n\n    يعيد:\n    - int: الحد الأدنى من المساحة المتبقية في الصندوق بعد وضع العناصر.\n\n    أمثلة:\n    - min_remaining_space(24, 6, [8, 3, 12, 7, 9, 7]) -> 0\n      يمكن وضع جميع العناصر في الصندوق دون أي مساحة متبقية.\n\n    - min_remaining_space(10, 4, [3, 5, 3, 2]) -> 2\n      طريقة مثلى لوضع العناصر يمكن أن تكون بأخذ العناصر ذات الأحجام 3، 5، و3، مما يترك 2 وحدة من المساحة.\n\n    - min_remaining_space(5, 3, [6, 7, 8]) -> 5\n      نظرًا لأن جميع العناصر لها حجم أكبر من سعة الصندوق، لا يمكن وضع أي منها وتبقى السعة الكاملة للصندوق.\n    \"\"\"",
      "sw": "from typing import List\ndef min_remaining_space(V: int, n: int, volumes: List[int]) -> int:\n    \"\"\"\n    Kuhesabu nafasi ndogo inayobaki kwenye sanduku baada ya kujaribu kutoshea idadi ya vitu vilivyo na ujazo uliotolewa.\n    \n    Kazi hii inatumia mbinu ya programu ya nguvu ili kubaini ujazo wa juu zaidi ambao unaweza kuchukuliwa\n    kwenye sanduku na seti yoyote ndogo ya vitu vilivyotolewa. Kisha inarudisha tofauti kati ya uwezo wa jumla wa sanduku\n    na huu ujazo wa juu uliotwaliwa, ambayo ni nafasi ndogo inayobaki.\n\n    Hoja:\n    - V (int): Uwezo wa jumla wa sanduku.\n    - n (int): Idadi ya vitu vya kuzingatia kwa kufunga kwenye sanduku.\n    - volumes (List[int]): Orodha ya ujazo wa vitu n.\n\n    Inarejesha:\n    - int: Nafasi ndogo inayobaki kwenye sanduku baada ya kutoshea vitu.\n\n    Mifano:\n    - min_remaining_space(24, 6, [8, 3, 12, 7, 9, 7]) -> 0\n      Vitu vyote vinaweza kutoshea kwenye sanduku bila nafasi yoyote inayobaki.\n\n    - min_remaining_space(10, 4, [3, 5, 3, 2]) -> 2\n      Njia bora ya kutoshea vitu inaweza kuwa kuchukua vitu vyenye ujazo 3, 5, na 3, ambayo inaacha nafasi ya vitengo 2.\n\n    - min_remaining_space(5, 3, [6, 7, 8]) -> 5\n      Kwa kuwa vitu vyote vina ujazo mkubwa kuliko uwezo wa sanduku, hakuna kinachoweza kutoshea na uwezo wote wa sanduku unabaki.\n    \"\"\"",
      "tr": "from typing import List\ndef min_remaining_space(V: int, n: int, volumes: List[int]) -> int:\n    \"\"\"\n    Belirli hacimlere sahip bir dizi öğeyi yerleştirmeye çalıştıktan sonra bir kutuda kalan minimum alanı hesaplayın.\n    \n    Bu fonksiyon, verilen öğelerin herhangi bir alt kümesi tarafından kutuda işgal edilebilecek maksimum hacmi belirlemek için dinamik programlama yaklaşımı kullanır.\n    Daha sonra kutunun toplam kapasitesi ile bu maksimum işgal edilen hacim arasındaki farkı döndürür, bu da kalan minimum alandır.\n\n    Argümanlar:\n    - V (int): Kutunun toplam kapasitesi.\n    - n (int): Kutunun içine yerleştirilmesi düşünülen öğe sayısı.\n    - volumes (List[int]): n öğesinin hacimlerinin bir listesi.\n\n    Döndürür:\n    - int: Öğeleri yerleştirdikten sonra kutuda kalan minimum alan.\n\n    Örnekler:\n    - min_remaining_space(24, 6, [8, 3, 12, 7, 9, 7]) -> 0\n      Tüm öğeler, hiç boş alan kalmadan kutuya sığdırılabilir.\n\n    - min_remaining_space(10, 4, [3, 5, 3, 2]) -> 2\n      Öğeleri yerleştirmenin optimal bir yolu, hacimleri 3, 5 ve 3 olan öğeleri almak olabilir, bu da 2 birim alan bırakır.\n\n    - min_remaining_space(5, 3, [6, 7, 8]) -> 5\n      Tüm öğelerin hacmi kutu kapasitesinden büyük olduğundan, hiçbiri sığdırılamaz ve tüm kutu kapasitesi kalır.\n    \"\"\"",
      "vi": "from typing import List\ndef min_remaining_space(V: int, n: int, volumes: List[int]) -> int:\n    \"\"\"\n    Tính toán không gian còn lại tối thiểu trong một hộp sau khi cố gắng đặt một số lượng đồ vật với các thể tích cho trước.\n\n    Hàm này sử dụng phương pháp lập trình động để xác định thể tích tối đa có thể được chiếm trong hộp\n    bởi bất kỳ tập hợp con nào của các đồ vật đã cho. Sau đó, nó trả về sự khác biệt giữa tổng dung tích của hộp\n    và thể tích tối đa đã chiếm, đó là không gian còn lại tối thiểu.\n\n    Tham số:\n    - V (int): Tổng dung tích của hộp.\n    - n (int): Số lượng đồ vật cần xem xét để đóng gói vào hộp.\n    - volumes (List[int]): Danh sách thể tích của n đồ vật.\n\n    Trả về:\n    - int: Không gian còn lại tối thiểu trong hộp sau khi đặt các đồ vật.\n\n    Ví dụ:\n    - min_remaining_space(24, 6, [8, 3, 12, 7, 9, 7]) -> 0\n      Tất cả các đồ vật có thể được đặt vào hộp mà không còn không gian thừa.\n\n    - min_remaining_space(10, 4, [3, 5, 3, 2]) -> 2\n      Một cách tối ưu để đặt các đồ vật có thể là lấy các đồ vật có thể tích 3, 5, và 3, để lại 2 đơn vị không gian.\n\n    - min_remaining_space(5, 3, [6, 7, 8]) -> 5\n      Vì tất cả các đồ vật đều có thể tích lớn hơn dung tích hộp, không thể đặt được và toàn bộ dung tích hộp vẫn còn.\n    \"\"\""
    },
    "prompt_bertscore": {
      "es": "0.9894449801821871",
      "arb": "0.9703945389675119",
      "sw": "0.9574341052353665",
      "tr": "0.963676263589769",
      "vi": "0.9600292111635874"
    },
    "canonical_solution": "    # Create a list to store the maximum volume that can be filled for each capacity\n    dp = [0] * (V + 1)\n\n    # Loop through each item\n    for i in range(n):\n        # Loop through the capacities from V to the volume of the current item\n        for j in range(V, volumes[i] - 1, -1):\n            # Update the dp list by considering whether to take the current item\n            dp[j] = max(dp[j], dp[j - volumes[i]] + volumes[i])\n\n    # The box's remaining space is the total capacity minus the maximum filled volume\n    return V - dp[V]",
    "instruction": {
      "en": "def min_remaining_space(V: int, n: int, volumes: List[int]) -> int:\n    # Create a list to store the maximum volume that can be filled for each capacity\n    dp = [0] * (V + 1)\n\n    # Loop through each item\n    for i in range(n):\n        # Loop through the capacities from V to the volume of the current item\n        for j in range(V, volumes[i] - 1, -1):\n            # Update the dp list by considering whether to take the current item\n            dp[j] = max(dp[j], dp[j - volumes[i]] + volumes[i])\n\n    # The box's remaining space is the total capacity minus the maximum filled volume\n    return V - dp[V]\n\nProvide a concise natural language description (docstring) of the Python code in English using at most 500 characters.",
      "es": "def min_remaining_space(V: int, n: int, volumes: List[int]) -> int:\n    # Create a list to store the maximum volume that can be filled for each capacity\n    dp = [0] * (V + 1)\n\n    # Loop through each item\n    for i in range(n):\n        # Loop through the capacities from V to the volume of the current item\n        for j in range(V, volumes[i] - 1, -1):\n            # Update the dp list by considering whether to take the current item\n            dp[j] = max(dp[j], dp[j - volumes[i]] + volumes[i])\n\n    # The box's remaining space is the total capacity minus the maximum filled volume\n    return V - dp[V]\n\nProporcione una descripción concisa en lenguaje natural (docstring) del código Python en español utilizando como máximo 500 caracteres.",
      "arb": "def min_remaining_space(V: int, n: int, volumes: List[int]) -> int:\n    # Create a list to store the maximum volume that can be filled for each capacity\n    dp = [0] * (V + 1)\n\n    # Loop through each item\n    for i in range(n):\n        # Loop through the capacities from V to the volume of the current item\n        for j in range(V, volumes[i] - 1, -1):\n            # Update the dp list by considering whether to take the current item\n            dp[j] = max(dp[j], dp[j - volumes[i]] + volumes[i])\n\n    # The box's remaining space is the total capacity minus the maximum filled volume\n    return V - dp[V]\n\nيرجى تقديم وصف موجز بلغة طبيعية (docstring) للشفرة البرمجية بلغة بايثون باللغة العربية الفصحى باستخدام 500 حرف كحد أقصى.",
      "sw": "def min_remaining_space(V: int, n: int, volumes: List[int]) -> int:\n    # Create a list to store the maximum volume that can be filled for each capacity\n    dp = [0] * (V + 1)\n\n    # Loop through each item\n    for i in range(n):\n        # Loop through the capacities from V to the volume of the current item\n        for j in range(V, volumes[i] - 1, -1):\n            # Update the dp list by considering whether to take the current item\n            dp[j] = max(dp[j], dp[j - volumes[i]] + volumes[i])\n\n    # The box's remaining space is the total capacity minus the maximum filled volume\n    return V - dp[V]\n\nToa maelezo mafupi ya lugha ya asili (docstring) ya msimbo wa Python kwa Kiswahili kwa kutumia herufi zisizozidi 500.",
      "tr": "def min_remaining_space(V: int, n: int, volumes: List[int]) -> int:\n    # Create a list to store the maximum volume that can be filled for each capacity\n    dp = [0] * (V + 1)\n\n    # Loop through each item\n    for i in range(n):\n        # Loop through the capacities from V to the volume of the current item\n        for j in range(V, volumes[i] - 1, -1):\n            # Update the dp list by considering whether to take the current item\n            dp[j] = max(dp[j], dp[j - volumes[i]] + volumes[i])\n\n    # The box's remaining space is the total capacity minus the maximum filled volume\n    return V - dp[V]\n\nVerilen Python kodunun işlevini açıklayan, en fazla 500 karakter uzunluğunda özlü bir doğal dil tanımı (docstring) sağlayın.",
      "vi": "def min_remaining_space(V: int, n: int, volumes: List[int]) -> int:\n    # Create a list to store the maximum volume that can be filled for each capacity\n    dp = [0] * (V + 1)\n\n    # Loop through each item\n    for i in range(n):\n        # Loop through the capacities from V to the volume of the current item\n        for j in range(V, volumes[i] - 1, -1):\n            # Update the dp list by considering whether to take the current item\n            dp[j] = max(dp[j], dp[j - volumes[i]] + volumes[i])\n\n    # The box's remaining space is the total capacity minus the maximum filled volume\n    return V - dp[V]\n\nCung cấp mô tả ngắn gọn bằng ngôn ngữ tự nhiên (docstring) cho mã Python bằng tiếng Việt, không quá 500 ký tự."
    },
    "instruction_bertscore": {
      "es": "0.9687387561112052",
      "arb": "0.924699818440817",
      "sw": "0.914896018724078",
      "tr": "0.8508820154152974",
      "vi": "0.905718500598742"
    },
    "level": "",
    "test": "def test_min_remaining_space():\n    # Test case 1: Sample provided in the problem statement where all items can fit perfectly\n    V1, n1 = 24, 6\n    volumes1 = [8, 3, 12, 7, 9, 7]\n    expected1 = 0\n    assert min_remaining_space(V1, n1,\n                               volumes1) == expected1, f\"Test case 1 failed: expected {expected1}, got {min_remaining_space(V1, n1, volumes1)}\"\n\n    # Test case 2: Some space is expected to remain in the box\n    V2, n2 = 10, 4\n    volumes2 = [3, 5, 3, 2]\n    expected2 = 0  # Possible packing: 3, 5, and 3, leaves 2 units of space\n    assert min_remaining_space(V2, n2,\n                               volumes2) == expected2, f\"Test case 2 failed: expected {expected2}, got {min_remaining_space(V2, n2, volumes2)}\"\n\n    # Test case 3: No items can fit due to the items being larger than the box capacity\n    V3, n3 = 5, 3\n    volumes3 = [6, 7, 8]\n    expected3 = 5  # No items fit, so all 5 units of space remain\n    assert min_remaining_space(V3, n3,\n                               volumes3) == expected3, f\"Test case 3 failed: expected {expected3}, got {min_remaining_space(V3, n3, volumes3)}\"\n\n    # If all tests pass, print this:\n    print(\"All test cases passed!\")\n\n\n# Run the test function\ntest_min_remaining_space()",
    "entry_point": "min_remaining_space",
    "signature": "def min_remaining_space(V: int, n: int, volumes: List[int]) -> int:",
    "docstring": {
      "en": "Calculate the minimum remaining space in a box after trying to fit a number of items with given volumes.\n\nThis function uses a dynamic programming approach to determine the maximum volume that can be occupied\nin the box by any subset of the given items. It then returns the difference between the box's total capacity\nand this maximum occupied volume, which is the minimum remaining space.\n\nArgs:\n- V (int): The total capacity of the box.\n- n (int): The number of items to consider for packing into the box.\n- volumes (List[int]): A list of the volumes of the n items.\n\nReturns:\n- int: The minimum remaining space in the box after fitting the items.\n\nExamples:\n- min_remaining_space(24, 6, [8, 3, 12, 7, 9, 7]) -> 0\nAll items can be fit into the box without any remaining space.\n\n- min_remaining_space(10, 4, [3, 5, 3, 2]) -> 2\nAn optimal way to fit the items could be taking items with volumes 3, 5, and 3, which leaves 2 units of space.\n\n- min_remaining_space(5, 3, [6, 7, 8]) -> 5\nSince all items have a volume greater than the box capacity, none can be fit and the entire box capacity remains.",
      "es": "Calcular el espacio mínimo restante en una caja después de intentar encajar un número de artículos con volúmenes dados.\n\nEsta función utiliza un enfoque de programación dinámica para determinar el volumen máximo que puede ser ocupado\nen la caja por cualquier subconjunto de los artículos dados. Luego devuelve la diferencia entre la capacidad total de la caja\ny este volumen máximo ocupado, que es el espacio mínimo restante.\n\nArgumentos:\n- V (int): La capacidad total de la caja.\n- n (int): El número de artículos a considerar para empacar en la caja.\n- volumes (List[int]): Una lista de los volúmenes de los n artículos.\n\nDevuelve:\n- int: El espacio mínimo restante en la caja después de encajar los artículos.\n\nEjemplos:\n- min_remaining_space(24, 6, [8, 3, 12, 7, 9, 7]) -> 0\nTodos los artículos pueden encajar en la caja sin ningún espacio restante.\n\n- min_remaining_space(10, 4, [3, 5, 3, 2]) -> 2\nUna forma óptima de encajar los artículos podría ser tomando artículos con volúmenes 3, 5 y 3, lo que deja 2 unidades de espacio.\n\n- min_remaining_space(5, 3, [6, 7, 8]) -> 5\nDado que todos los artículos tienen un volumen mayor que la capacidad de la caja, ninguno puede encajar y toda la capacidad de la caja permanece.",
      "arb": "حساب الحد الأدنى للمساحة المتبقية في صندوق بعد محاولة وضع عدد من العناصر ذات الأحجام المعطاة.\n\nتستخدم هذه الدالة نهج البرمجة الديناميكية لتحديد الحد الأقصى للحجم الذي يمكن أن يشغله في الصندوق أي مجموعة فرعية من العناصر المعطاة. ثم تعيد الفرق بين السعة الإجمالية للصندوق وهذا الحجم المشغول الأقصى، وهو الحد الأدنى للمساحة المتبقية.\n\nيعيدالحجج:\n- V (int): السعة الإجمالية للصندوق.\n- n (int): عدد العناصر التي يجب النظر فيها للتعبئة في الصندوق.\n- volumes (List[int]): قائمة بأحجام العناصر n.\n\nيعيد:\n- int: الحد الأدنى للمساحة المتبقية في الصندوق بعد وضع العناصر.\n\nامثله:\n- min_remaining_space(24, 6, [8, 3, 12, 7, 9, 7]) -> 0\nيمكن وضع جميع العناصر في الصندوق دون أي مساحة متبقية.\n\n- min_remaining_space(10, 4, [3, 5, 3, 2]) -> 2\nطريقة مثلى لوضع العناصر يمكن أن تكون بأخذ العناصر ذات الأحجام 3، 5، و3، مما يترك 2 وحدة من المساحة.\n\n- min_remaining_space(5, 3, [6, 7, 8]) -> 5\nنظرًا لأن جميع العناصر لها حجم أكبر من سعة الصندوق، لا يمكن وضع أي منها وتبقى السعة الكاملة للصندوق.",
      "sw": "Kuhesabu nafasi ndogo inayobaki kwenye sanduku baada ya kujaribu kutoshea idadi ya vitu vilivyo na ujazo uliotolewa.\n\nKazi hii hutumia mbinu ya programu ya nguvu ili kubaini ujazo wa juu zaidi ambao unaweza kujazwa\nkatika sanduku na sehemu yoyote ya vitu vilivyotolewa. Kisha inarejesha tofauti kati ya uwezo wa jumla wa sanduku\nna huu ujazo wa juu zaidi uliyojazwa, ambao ndio nafasi ndogo zaidi inayobaki.\n\nHoja:\n- V (int): Uwezo wa jumla wa sanduku.\n- n (int): Idadi ya vitu vya kuzingatia kwa kufunga kwenye sanduku.\n- volumes (List[int]): Orodha ya ujazo wa vitu n.\n\nInarejesha:\n- int: Nafasi ndogo zaidi inayobaki kwenye sanduku baada ya kufunga vitu.\n\nMifano:\n- min_remaining_space(24, 6, [8, 3, 12, 7, 9, 7]) -> 0\nVitu vyote vinaweza kujazwa kwenye sanduku bila nafasi yoyote inayobaki.\n\n- min_remaining_space(10, 4, [3, 5, 3, 2]) -> 2\nNjia bora ya kufunga vitu inaweza kuwa kuchukua vitu vyenye ujazo 3, 5, na 3, ambayo inaacha nafasi ya vitengo 2.\n\n- min_remaining_space(5, 3, [6, 7, 8]) -> 5\nKwa kuwa vitu vyote vina ujazo mkubwa kuliko uwezo wa sanduku, hakuna kinachoweza kujazwa na uwezo wote wa sanduku unabaki.",
      "tr": "Kutudaki minimum kalan alanı, verilen hacimlere sahip bir dizi öğeyi sığdırmaya çalıştıktan sonra hesaplayın.\n\nBu fonksiyon, verilen öğelerin herhangi bir alt kümesi tarafından kutuda işgal edilebilecek maksimum hacmi belirlemek için dinamik programlama yaklaşımı kullanır. Daha sonra kutunun toplam kapasitesi ile bu maksimum işgal edilen hacim arasındaki farkı döndürür, bu da minimum kalan alandır.\n\nArgümanlar:\n- V (int): Kutunun toplam kapasitesi.\n- n (int): Kutunun içine yerleştirilmesi düşünülen öğe sayısı.\n- volumes (List[int]): n öğesinin hacimlerinin listesi.\n\nDöndürür:\n- int: Öğeleri yerleştirdikten sonra kutuda kalan minimum alan.\n\nÖrnekler:\n- min_remaining_space(24, 6, [8, 3, 12, 7, 9, 7]) -> 0\nTüm öğeler kutuya herhangi bir boş alan kalmadan sığdırılabilir.\n\n- min_remaining_space(10, 4, [3, 5, 3, 2]) -> 2\nÖğeleri sığdırmanın optimal bir yolu, hacimleri 3, 5 ve 3 olan öğeleri almak olabilir, bu da 2 birim alan bırakır.\n\n- min_remaining_space(5, 3, [6, 7, 8]) -> 5\nTüm öğelerin hacmi kutu kapasitesinden büyük olduğundan, hiçbiri sığdırılamaz ve kutunun tüm kapasitesi kalır.",
      "vi": "Tính toán không gian còn lại tối thiểu trong một hộp sau khi cố gắng đặt một số lượng vật phẩm với các thể tích cho trước.\n\nHàm này sử dụng phương pháp lập trình động để xác định thể tích tối đa có thể được chiếm trong hộp bởi bất kỳ tập hợp con nào của các vật phẩm đã cho. Sau đó, nó trả về sự khác biệt giữa tổng dung tích của hộp và thể tích chiếm tối đa này, đó là không gian còn lại tối thiểu.\n\nTham số:\n- V (int): Tổng dung tích của hộp.\n- n (int): Số lượng vật phẩm cần xem xét để đóng gói vào hộp.\n- volumes (List[int]): Danh sách các thể tích của n vật phẩm.\n\nTrả về:\n- int: Không gian còn lại tối thiểu trong hộp sau khi đặt các vật phẩm.\n\nVí dụ:\n- min_remaining_space(24, 6, [8, 3, 12, 7, 9, 7]) -> 0\nTất cả các vật phẩm có thể được đặt vào hộp mà không còn không gian thừa.\n\n- min_remaining_space(10, 4, [3, 5, 3, 2]) -> 2\nMột cách tối ưu để đặt các vật phẩm có thể là lấy các vật phẩm có thể tích 3, 5 và 3, để lại 2 đơn vị không gian.\n\n- min_remaining_space(5, 3, [6, 7, 8]) -> 5\nVì tất cả các vật phẩm có thể tích lớn hơn dung tích hộp, không vật phẩm nào có thể được đặt và toàn bộ dung tích hộp vẫn còn."
    },
    "docstring_bertscore": {
      "es": "0.988556705118199",
      "arb": "0.9600949578197099",
      "sw": "0.9603585403353432",
      "tr": "0.9609631712152135",
      "vi": "0.9637322773572208"
    }
  },
  {
    "task_id": "Python/39",
    "prompt": {
      "en": "def calculate_arrangements(n, m, a) -> int:\n    \"\"\"\n    Compute the number of ways to arrange m pots of flowers using up to n types,\n    where the ith type can have at most a[i] pots, and the arrangement must be in\n    increasing order of flower types.\n\n    Args:\n    - n (int): The number of flower types available.\n    - m (int): The total number of flower pots to arrange.\n    - a (list of int): A list where a[i] is the maximum number of pots for the ith type of flower.\n\n    Returns:\n    - int: The number of distinct arrangements modulo (10^6 + 7).\n\n    Examples:\n    - calculate_arrangements(2, 4, [3, 2]) returns 2.\n      There are two possible arrangements for 4 pots using two types of flowers with\n      at most 3 of the first type and 2 of the second type: [1, 1, 2, 2] and [1, 2, 2, 2].\n\n    - calculate_arrangements(3, 3, [1, 2, 3]) returns 6.\n      There are six ways to arrange 3 pots using three types of flowers when the\n      maximum pots are 1, 2, and 3 for the first, second, and third types respectively.\n    \"\"\"",
      "es": "def calculate_arrangements(n, m, a) -> int:\n    \"\"\"\n    Calcular el número de formas de arreglar m macetas de flores usando hasta n tipos,\n    donde el i-ésimo tipo puede tener como máximo a[i] macetas, y el arreglo debe estar en\n    orden creciente de tipos de flores.\n\n    Argumentos:\n    - n (int): El número de tipos de flores disponibles.\n    - m (int): El número total de macetas de flores a arreglar.\n    - a (list of int): Una lista donde a[i] es el número máximo de macetas para el i-ésimo tipo de flor.\n\n    Devuelve:\n    - int: El número de arreglos distintos módulo (10^6 + 7).\n\n    Ejemplos:\n    - calculate_arrangements(2, 4, [3, 2]) devuelve 2.\n      Hay dos arreglos posibles para 4 macetas usando dos tipos de flores con\n      como máximo 3 del primer tipo y 2 del segundo tipo: [1, 1, 2, 2] y [1, 2, 2, 2].\n\n    - calculate_arrangements(3, 3, [1, 2, 3]) devuelve 6.\n      Hay seis formas de arreglar 3 macetas usando tres tipos de flores cuando el\n      máximo de macetas es 1, 2 y 3 para el primer, segundo y tercer tipo respectivamente.\n    \"\"\"",
      "arb": "def calculate_arrangements(n, m, a) -> int:\n    \"\"\"\n    حساب عدد الطرق لترتيب m من الأواني الزهرية باستخدام ما يصل إلى n نوعًا،\n    حيث يمكن أن يحتوي النوع i على ما لا يزيد عن a[i] من الأواني، ويجب أن يكون الترتيب\n    بترتيب تصاعدي لأنواع الأزهار.\n\n    يعيدالحجج:\n    - n (int): عدد أنواع الأزهار المتاحة.\n    - m (int): العدد الإجمالي للأواني الزهرية لترتيبها.\n    - a (list of int): قائمة حيث a[i] هو الحد الأقصى لعدد الأواني لنوع الزهرة i.\n\n    يعيد:\n    - int: عدد الترتيبات المميزة موديولو (10^6 + 7).\n\n    أمثلة:\n    - calculate_arrangements(2, 4, [3, 2]) يعيد 2.\n      هناك ترتيبين ممكنين لـ 4 أواني باستخدام نوعين من الأزهار مع\n      ما لا يزيد عن 3 من النوع الأول و2 من النوع الثاني: [1, 1, 2, 2] و[1, 2, 2, 2].\n\n    - calculate_arrangements(3, 3, [1, 2, 3]) يعيد 6.\n      هناك ست طرق لترتيب 3 أواني باستخدام ثلاثة أنواع من الأزهار عندما يكون\n      الحد الأقصى للأواني هو 1، 2، و3 للنوع الأول، الثاني، والثالث على التوالي.\n    \"\"\"",
      "sw": "def calculate_arrangements(n, m, a) -> int:\n    \"\"\"\n    Hesabu idadi ya njia za kupanga sufuria za maua m kwa kutumia aina hadi n,\n    ambapo aina ya ith inaweza kuwa na sufuria zisizozidi a[i], na mpangilio lazima uwe katika\n    mpangilio wa kuongezeka wa aina za maua.\n\n    Hoja:\n    - n (int): Idadi ya aina za maua zinazopatikana.\n    - m (int): Jumla ya idadi ya sufuria za maua za kupanga.\n    - a (list of int): Orodha ambapo a[i] ni idadi ya juu zaidi ya sufuria kwa aina ya ith ya maua.\n\n    Inarejesha:\n    - int: Idadi ya mipangilio tofauti modulo (10^6 + 7).\n\n    Mifano:\n    - calculate_arrangements(2, 4, [3, 2]) inarudisha 2.\n      Kuna mipangilio miwili inayowezekana kwa sufuria 4 kwa kutumia aina mbili za maua na\n      angalau 3 za aina ya kwanza na 2 za aina ya pili: [1, 1, 2, 2] na [1, 2, 2, 2].\n\n    - calculate_arrangements(3, 3, [1, 2, 3]) inarudisha 6.\n      Kuna njia sita za kupanga sufuria 3 kwa kutumia aina tatu za maua wakati\n      sufuria za juu zaidi ni 1, 2, na 3 kwa aina ya kwanza, ya pili, na ya tatu mtawalia.\n    \"\"\"",
      "tr": "def calculate_arrangements(n, m, a) -> int:\n    \"\"\"\n    En fazla n türü kullanarak m çiçek saksısını düzenlemenin yollarını hesaplayın,\n    burada i. tür en fazla a[i] saksıya sahip olabilir ve düzenleme\n    çiçek türlerinin artan sırasına göre olmalıdır.\n\n    Argümanlar:\n    - n (int): Mevcut çiçek türlerinin sayısı.\n    - m (int): Düzenlenecek toplam çiçek saksısı sayısı.\n    - a (list of int): a[i], i. çiçek türü için maksimum saksı sayısını belirten bir liste.\n\n    Döndürür:\n    - int: Farklı düzenlemelerin sayısı mod (10^6 + 7).\n\n    Örnekler:\n    - calculate_arrangements(2, 4, [3, 2]) 2 döndürür.\n      İki tür çiçek kullanarak 4 saksı için iki olası düzenleme vardır,\n      ilk türden en fazla 3 ve ikinci türden en fazla 2: [1, 1, 2, 2] ve [1, 2, 2, 2].\n\n    - calculate_arrangements(3, 3, [1, 2, 3]) 6 döndürür.\n      Maksimum saksı sayıları sırasıyla birinci, ikinci ve üçüncü türler için 1, 2 ve 3 olduğunda,\n      üç tür çiçek kullanarak 3 saksı düzenlemenin altı yolu vardır.\n    \"\"\"",
      "vi": "def calculate_arrangements(n, m, a) -> int:\n    \"\"\"\n    Tính số cách sắp xếp m chậu hoa sử dụng tối đa n loại,\n    trong đó loại thứ i có thể có tối đa a[i] chậu, và cách sắp xếp phải theo\n    thứ tự tăng dần của các loại hoa.\n\n    Tham số:\n    - n (int): Số loại hoa có sẵn.\n    - m (int): Tổng số chậu hoa cần sắp xếp.\n    - a (list of int): Danh sách mà a[i] là số chậu tối đa cho loại hoa thứ i.\n\n    Trả về:\n    - int: Số cách sắp xếp khác nhau theo modulo (10^6 + 7).\n\n    Ví dụ:\n    - calculate_arrangements(2, 4, [3, 2]) trả về 2.\n      Có hai cách sắp xếp 4 chậu sử dụng hai loại hoa với\n      tối đa 3 của loại thứ nhất và 2 của loại thứ hai: [1, 1, 2, 2] và [1, 2, 2, 2].\n\n    - calculate_arrangements(3, 3, [1, 2, 3]) trả về 6.\n      Có sáu cách để sắp xếp 3 chậu sử dụng ba loại hoa khi\n      số chậu tối đa là 1, 2, và 3 cho loại thứ nhất, thứ hai, và thứ ba tương ứng.\n    \"\"\""
    },
    "prompt_bertscore": {
      "es": "0.9834439591103611",
      "arb": "0.9298886398845914",
      "sw": "0.9702096140827685",
      "tr": "0.9394981790886783",
      "vi": "0.9487984507894938"
    },
    "canonical_solution": "    MOD = 10 ** 6 + 7\n\n    # Initialize the dp array\n    dp = [[0] * (m + 1) for _ in range(n + 1)]\n    dp[0][0] = 1  # Base case\n\n    # Fill the dp array\n    for i in range(1, n + 1):\n        for j in range(m + 1):\n            # Calculate the number of ways for each state\n            for k in range(min(j, a[i - 1]) + 1):\n                dp[i][j] += dp[i - 1][j - k]\n                dp[i][j] %= MOD\n\n    # Output the result\n    return dp[n][m]",
    "instruction": {
      "en": "def calculate_arrangements(n, m, a) -> int:\n    MOD = 10 ** 6 + 7\n\n    # Initialize the dp array\n    dp = [[0] * (m + 1) for _ in range(n + 1)]\n    dp[0][0] = 1  # Base case\n\n    # Fill the dp array\n    for i in range(1, n + 1):\n        for j in range(m + 1):\n            # Calculate the number of ways for each state\n            for k in range(min(j, a[i - 1]) + 1):\n                dp[i][j] += dp[i - 1][j - k]\n                dp[i][j] %= MOD\n\n    # Output the result\n    return dp[n][m]\n\nProvide a concise natural language description (docstring) of the Python code in English using at most 500 characters.",
      "es": "def calculate_arrangements(n, m, a) -> int:\n    MOD = 10 ** 6 + 7\n\n    # Initialize the dp array\n    dp = [[0] * (m + 1) for _ in range(n + 1)]\n    dp[0][0] = 1  # Base case\n\n    # Fill the dp array\n    for i in range(1, n + 1):\n        for j in range(m + 1):\n            # Calculate the number of ways for each state\n            for k in range(min(j, a[i - 1]) + 1):\n                dp[i][j] += dp[i - 1][j - k]\n                dp[i][j] %= MOD\n\n    # Output the result\n    return dp[n][m]\n\nProporciona una descripción concisa en lenguaje natural (docstring) del código Python en español utilizando como máximo 500 caracteres.",
      "arb": "def calculate_arrangements(n, m, a) -> int:\n    MOD = 10 ** 6 + 7\n\n    # Initialize the dp array\n    dp = [[0] * (m + 1) for _ in range(n + 1)]\n    dp[0][0] = 1  # Base case\n\n    # Fill the dp array\n    for i in range(1, n + 1):\n        for j in range(m + 1):\n            # Calculate the number of ways for each state\n            for k in range(min(j, a[i - 1]) + 1):\n                dp[i][j] += dp[i - 1][j - k]\n                dp[i][j] %= MOD\n\n    # Output the result\n    return dp[n][m]\n\nيرجى تقديم وصف موجز بلغة طبيعية (docstring) للشفرة البرمجية بلغة بايثون باللغة العربية الفصحى باستخدام 500 حرف كحد أقصى.",
      "sw": "def calculate_arrangements(n, m, a) -> int:\n    MOD = 10 ** 6 + 7\n\n    # Initialize the dp array\n    dp = [[0] * (m + 1) for _ in range(n + 1)]\n    dp[0][0] = 1  # Base case\n\n    # Fill the dp array\n    for i in range(1, n + 1):\n        for j in range(m + 1):\n            # Calculate the number of ways for each state\n            for k in range(min(j, a[i - 1]) + 1):\n                dp[i][j] += dp[i - 1][j - k]\n                dp[i][j] %= MOD\n\n    # Output the result\n    return dp[n][m]\n\nToa maelezo mafupi ya lugha asilia (docstring) ya msimbo wa Python kwa Kiswahili kwa kutumia herufi zisizozidi 500.",
      "tr": "def calculate_arrangements(n, m, a) -> int:\n    MOD = 10 ** 6 + 7\n\n    # Initialize the dp array\n    dp = [[0] * (m + 1) for _ in range(n + 1)]\n    dp[0][0] = 1  # Base case\n\n    # Fill the dp array\n    for i in range(1, n + 1):\n        for j in range(m + 1):\n            # Calculate the number of ways for each state\n            for k in range(min(j, a[i - 1]) + 1):\n                dp[i][j] += dp[i - 1][j - k]\n                dp[i][j] %= MOD\n\n    # Output the result\n    return dp[n][m]\n\nVerilen Python kodunun işlevini açıklayan, en fazla 500 karakter uzunluğunda özlü bir doğal dil açıklaması (docstring) sağlayın.",
      "vi": "def calculate_arrangements(n, m, a) -> int:\n    MOD = 10 ** 6 + 7\n\n    # Initialize the dp array\n    dp = [[0] * (m + 1) for _ in range(n + 1)]\n    dp[0][0] = 1  # Base case\n\n    # Fill the dp array\n    for i in range(1, n + 1):\n        for j in range(m + 1):\n            # Calculate the number of ways for each state\n            for k in range(min(j, a[i - 1]) + 1):\n                dp[i][j] += dp[i - 1][j - k]\n                dp[i][j] %= MOD\n\n    # Output the result\n    return dp[n][m]\n\nCung cấp mô tả ngắn gọn bằng ngôn ngữ tự nhiên (docstring) cho mã Python bằng tiếng Việt, sử dụng tối đa 500 ký tự."
    },
    "instruction_bertscore": {
      "es": "0.9687387561112052",
      "arb": "0.924699818440817",
      "sw": "0.9426438884331277",
      "tr": "0.8406654617667679",
      "vi": "0.9069722555638342"
    },
    "level": "",
    "test": "def test_calculate_arrangements():\n    # Helper function to compare expected and actual results\n    def assert_equal(actual, expected, message):\n        assert actual == expected, message\n\n    # Test Case 1\n    n, m, a = 2, 4, [3, 2]\n    expected = 2\n    assert_equal(calculate_arrangements(n, m, a), expected, f\"Test Case 1 failed: expected {expected}, got {calculate_arrangements(n, m, a)}\")\n\n    # Test Case 2\n    n, m, a = 3, 3, [1, 2, 3]\n    expected = 6\n    assert_equal(calculate_arrangements(n, m, a), expected, f\"Test Case 2 failed: expected {expected}, got {calculate_arrangements(n, m, a)}\")\n\n    # Test Case 3\n    n, m, a = 1, 5, [5]\n    expected = 1\n    assert_equal(calculate_arrangements(n, m, a), expected, f\"Test Case 3 failed: expected {expected}, got {calculate_arrangements(n, m, a)}\")\n\n    print(\"All tests passed!\")\n\nif __name__ == \"__main__\":\n    test_calculate_arrangements()",
    "entry_point": "calculate_arrangements",
    "signature": "def calculate_arrangements(n, m, a) -> int:",
    "docstring": {
      "en": "Compute the number of ways to arrange m pots of flowers using up to n types,\nwhere the ith type can have at most a[i] pots, and the arrangement must be in\nincreasing order of flower types.\n\nArgs:\n- n (int): The number of flower types available.\n- m (int): The total number of flower pots to arrange.\n- a (list of int): A list where a[i] is the maximum number of pots for the ith type of flower.\n\nReturns:\n- int: The number of distinct arrangements modulo (10^6 + 7).\n\nExamples:\n- calculate_arrangements(2, 4, [3, 2]) returns 2.\nThere are two possible arrangements for 4 pots using two types of flowers with\nat most 3 of the first type and 2 of the second type: [1, 1, 2, 2] and [1, 2, 2, 2].\n\n- calculate_arrangements(3, 3, [1, 2, 3]) returns 6.\nThere are six ways to arrange 3 pots using three types of flowers when the\nmaximum pots are 1, 2, and 3 for the first, second, and third types respectively.",
      "es": "Calcular el número de formas de organizar m macetas de flores usando hasta n tipos,\ndonde el tipo i puede tener como máximo a[i] macetas, y la disposición debe ser en\norden creciente de tipos de flores.\n\nArgumentos:\n- n (int): El número de tipos de flores disponibles.\n- m (int): El número total de macetas de flores a organizar.\n- a (list of int): Una lista donde a[i] es el número máximo de macetas para el tipo i de flor.\n\nDevuelve:\n- int: El número de disposiciones distintas módulo (10^6 + 7).\n\nEjemplos:\n- calculate_arrangements(2, 4, [3, 2]) devuelve 2.\nHay dos disposiciones posibles para 4 macetas usando dos tipos de flores con\ncomo máximo 3 del primer tipo y 2 del segundo tipo: [1, 1, 2, 2] y [1, 2, 2, 2].\n\n- calculate_arrangements(3, 3, [1, 2, 3]) devuelve 6.\nHay seis formas de organizar 3 macetas usando tres tipos de flores cuando las\nmacetas máximas son 1, 2 y 3 para el primer, segundo y tercer tipo respectivamente.",
      "arb": "احسب عدد الطرق لترتيب m من أواني الزهور باستخدام ما يصل إلى n نوعًا، حيث يمكن أن يحتوي النوع i على a[i] من الأواني كحد أقصى، ويجب أن يكون الترتيب بترتيب تصاعدي لأنواع الزهور.\n\nيعيدالحجج:\n- n (int): عدد أنواع الزهور المتاحة.\n- m (int): العدد الإجمالي لأواني الزهور لترتيبها.\n- a (list of int): قائمة حيث a[i] هو الحد الأقصى لعدد الأواني لنوع الزهور i.\n\nيعيد:\n- int: عدد الترتيبات المميزة مودولو (10^6 + 7).\n\nامثله:\n- calculate_arrangements(2, 4, [3, 2]) يعيد 2.\nهناك ترتيبين ممكنين لـ 4 أواني باستخدام نوعين من الزهور مع ما يصل إلى 3 من النوع الأول و2 من النوع الثاني: [1, 1, 2, 2] و [1, 2, 2, 2].\n\n- calculate_arrangements(3, 3, [1, 2, 3]) يعيد 6.\nهناك ست طرق لترتيب 3 أواني باستخدام ثلاثة أنواع من الزهور عندما تكون الأواني القصوى 1، 2، و3 للنوع الأول، الثاني، والثالث على التوالي.",
      "sw": "Hesabu idadi ya njia za kupanga sufuria za maua m kwa kutumia hadi aina n, ambapo aina ya ith inaweza kuwa na sufuria a[i] kwa zaidi, na mpangilio lazima uwe katika mpangilio wa kuongezeka wa aina za maua.\n\nHoja:\n- n (int): Idadi ya aina za maua zinazopatikana.\n- m (int): Jumla ya idadi ya sufuria za maua za kupanga.\n- a (orodha ya int): Orodha ambapo a[i] ni idadi ya juu ya sufuria kwa aina ya ith ya maua.\n\nInarejesha:\n- int: Idadi ya mipangilio tofauti modulo (10^6 + 7).\n\nMifano:\n- calculate_arrangements(2, 4, [3, 2]) inarudisha 2.\nKuna mipangilio miwili inayowezekana kwa sufuria 4 kwa kutumia aina mbili za maua na\nzaidi ya 3 za aina ya kwanza na 2 za aina ya pili: [1, 1, 2, 2] na [1, 2, 2, 2].\n\n- calculate_arrangements(3, 3, [1, 2, 3]) inarudisha 6.\nKuna njia sita za kupanga sufuria 3 kwa kutumia aina tatu za maua wakati\nsufuria za juu ni 1, 2, na 3 kwa aina ya kwanza, ya pili, na ya tatu mtawalia.",
      "tr": "m çiçek saksısını, her biri en fazla a[i] saksısına sahip olabilecek n türünü kullanarak düzenlemenin yollarını hesaplayın ve düzenleme çiçek türlerinin artan sırasına göre olmalıdır.\n\nArgümanlar:\n- n (int): Mevcut çiçek türlerinin sayısı.\n- m (int): Düzenlenecek toplam çiçek saksısı sayısı.\n- a (list of int): a[i]'nin i. çiçek türü için maksimum saksı sayısı olduğu bir liste.\n\nDöndürür:\n- int: Farklı düzenlemelerin sayısı mod (10^6 + 7).\n\nÖrnekler:\n- calculate_arrangements(2, 4, [3, 2]) 2 döndürür.\nİlk türden en fazla 3 ve ikinci türden en fazla 2 olmak üzere iki tür çiçek kullanarak 4 saksı için iki olası düzenleme vardır: [1, 1, 2, 2] ve [1, 2, 2, 2].\n\n- calculate_arrangements(3, 3, [1, 2, 3]) 6 döndürür.\nİlk, ikinci ve üçüncü türler için maksimum saksılar sırasıyla 1, 2 ve 3 olduğunda, üç tür çiçek kullanarak 3 saksıyı düzenlemenin altı yolu vardır.",
      "vi": "Tính số cách sắp xếp m chậu hoa sử dụng tối đa n loại,\ntrong đó loại thứ i có thể có tối đa a[i] chậu, và sắp xếp phải theo thứ tự tăng dần của các loại hoa.\n\nTham số:\n- n (int): Số loại hoa có sẵn.\n- m (int): Tổng số chậu hoa cần sắp xếp.\n- a (list of int): Danh sách mà a[i] là số chậu tối đa cho loại hoa thứ i.\n\nTrả về:\n- int: Số lượng sắp xếp khác nhau theo modulo (10^6 + 7).\n\nVí dụ:\n- calculate_arrangements(2, 4, [3, 2]) trả về 2.\nCó hai cách sắp xếp 4 chậu sử dụng hai loại hoa với tối đa 3 của loại thứ nhất và 2 của loại thứ hai: [1, 1, 2, 2] và [1, 2, 2, 2].\n\n- calculate_arrangements(3, 3, [1, 2, 3]) trả về 6.\nCó sáu cách để sắp xếp 3 chậu sử dụng ba loại hoa khi số chậu tối đa là 1, 2, và 3 cho loại thứ nhất, thứ hai, và thứ ba tương ứng."
    },
    "docstring_bertscore": {
      "es": "0.9663899518554676",
      "arb": "0.9523557222834476",
      "sw": "0.9643565726448134",
      "tr": "0.9448737130906254",
      "vi": "0.9456892894351546"
    }
  },
  {
    "task_id": "Python/40",
    "prompt": {
      "en": "def vigenere_decrypt(key: str, ciphertext: str) -> str:\n    \"\"\"\n    Decrypts a ciphertext encrypted with the Vigenère cipher using the provided key.\n    \n    The Vigenère cipher is a method of encrypting alphabetic text by using a series of\n    Caesar ciphers based on the letters of a keyword. This function reverses the process\n    to recover the original plaintext from the ciphertext.\n\n    Args:\n        key (str): The encryption key used to encrypt the original plaintext.\n                   This key should consist only of alphabetic characters.\n        ciphertext (str): The encrypted text that needs to be decrypted.\n                          The ciphertext should consist only of alphabetic characters.\n\n    Returns:\n        str: The decrypted plaintext corresponding to the input ciphertext.\n\n    Examples:\n        >>> vigenere_decrypt(\"CompleteVictory\", \"Yvqgpxaimmklongnzfwpvxmniytm\")\n        'Wherethereisawillthereisaway'\n\n        >>> vigenere_decrypt(\"ABC\", \"DEF\")\n        'DCB'\n\n        >>> vigenere_decrypt(\"xyz\", \"abc\")\n        'xyz'\n        \n        >>> vigenere_decrypt(\"MiXeD\", \"JpOeR\")\n        'Hello'\n        \n        >>> vigenere_decrypt(\"short\", \"PqrsPqrsPq\")\n        'LongLongLo'\n    \"\"\"\n    # Function implementation as provided",
      "es": "def vigenere_decrypt(key: str, ciphertext: str) -> str:\n    \"\"\"\n    Descifra un texto cifrado con el cifrado de Vigenère utilizando la clave proporcionada.\n    \n    El cifrado de Vigenère es un método de cifrado de texto alfabético mediante el uso de una serie de\n    cifrados César basados en las letras de una palabra clave. Esta función invierte el proceso\n    para recuperar el texto original a partir del texto cifrado.\n\n    Argumentos:\n        key (str): La clave de cifrado utilizada para cifrar el texto original.\n                   Esta clave debe consistir únicamente en caracteres alfabéticos.\n        ciphertext (str): El texto cifrado que necesita ser descifrado.\n                          El texto cifrado debe consistir únicamente en caracteres alfabéticos.\n\n    Devuelve:\n        str: El texto descifrado correspondiente al texto cifrado de entrada.\n\n    Ejemplos:\n        >>> vigenere_decrypt(\"CompleteVictory\", \"Yvqgpxaimmklongnzfwpvxmniytm\")\n        'Wherethereisawillthereisaway'\n\n        >>> vigenere_decrypt(\"ABC\", \"DEF\")\n        'DCB'\n\n        >>> vigenere_decrypt(\"xyz\", \"abc\")\n        'xyz'\n        \n        >>> vigenere_decrypt(\"MiXeD\", \"JpOeR\")\n        'Hello'\n        \n        >>> vigenere_decrypt(\"short\", \"PqrsPqrsPq\")\n        'LongLongLo'\n    \"\"\"\n    # Implementación de la función según lo proporcionado",
      "arb": "def vigenere_decrypt(key: str, ciphertext: str) -> str:\n    \"\"\"\n    يفك تشفير النص المشفر باستخدام شفرة فيجنير باستخدام المفتاح المقدم.\n    \n    شفرة فيجنير هي طريقة لتشفير النصوص الأبجدية باستخدام سلسلة من شفرات قيصر\n    بناءً على حروف كلمة مفتاحية. تقوم هذه الدالة بعكس العملية لاستعادة النص الأصلي\n    من النص المشفر.\n\n    يعيدالحجج:\n        key (str): مفتاح التشفير المستخدم لتشفير النص الأصلي.\n                   يجب أن يتكون هذا المفتاح من حروف أبجدية فقط.\n        ciphertext (str): النص المشفر الذي يحتاج إلى فك تشفير.\n                          يجب أن يتكون النص المشفر من حروف أبجدية فقط.\n\n    يعيد:\n        str: النص الأصلي المفكوك تشفيره والمطابق للنص المشفر المدخل.\n\n    امثله:\n        >>> vigenere_decrypt(\"CompleteVictory\", \"Yvqgpxaimmklongnzfwpvxmniytm\")\n        'Wherethereisawillthereisaway'\n\n        >>> vigenere_decrypt(\"ABC\", \"DEF\")\n        'DCB'\n\n        >>> vigenere_decrypt(\"xyz\", \"abc\")\n        'xyz'\n        \n        >>> vigenere_decrypt(\"MiXeD\", \"JpOeR\")\n        'Hello'\n        \n        >>> vigenere_decrypt(\"short\", \"PqrsPqrsPq\")\n        'LongLongLo'\n    \"\"\"\n    # تنفيذ الدالة كما هو مقدم",
      "sw": "def vigenere_decrypt(key: str, ciphertext: str) -> str:\n    \"\"\"\n    Kufungua maandishi ya siri yaliyosimbwa na Vigenère cipher kwa kutumia ufunguo uliotolewa.\n    \n    Vigenère cipher ni mbinu ya kusimba maandishi ya alfabeti kwa kutumia mfululizo wa\n    Caesar ciphers kulingana na herufi za neno kuu. Kazi hii inarudisha mchakato\n    ili kurejesha maandishi asilia kutoka kwa maandishi ya siri.\n\n    Hoja:\n        key (str): Ufunguo wa usimbaji uliotumika kusimba maandishi asilia.\n                   Ufunguo huu unapaswa kuwa na herufi za alfabeti pekee.\n        ciphertext (str): Maandishi ya siri yanayohitaji kufunguliwa.\n                          Maandishi ya siri yanapaswa kuwa na herufi za alfabeti pekee.\n\n    Inarejesha:\n        str: Maandishi asilia yaliyofunguliwa yanayolingana na maandishi ya siri yaliyoingizwa.\n\n    Mifano:\n        >>> vigenere_decrypt(\"CompleteVictory\", \"Yvqgpxaimmklongnzfwpvxmniytm\")\n        'Wherethereisawillthereisaway'\n\n        >>> vigenere_decrypt(\"ABC\", \"DEF\")\n        'DCB'\n\n        >>> vigenere_decrypt(\"xyz\", \"abc\")\n        'xyz'\n        \n        >>> vigenere_decrypt(\"MiXeD\", \"JpOeR\")\n        'Hello'\n        \n        >>> vigenere_decrypt(\"short\", \"PqrsPqrsPq\")\n        'LongLongLo'\n    \"\"\"\n    # Utekelezaji wa kazi kama ilivyotolewa",
      "tr": "def vigenere_decrypt(key: str, ciphertext: str) -> str:\n    \"\"\"\n    Sağlanan anahtarı kullanarak Vigenère şifreleme yöntemiyle şifrelenmiş bir şifreli metni çözer.\n    \n    Vigenère şifresi, alfabetik metni bir anahtar kelimenin harflerine dayanan bir dizi\n    Sezar şifresi kullanarak şifreleme yöntemidir. Bu fonksiyon, şifreli metinden orijinal\n    düz metni geri kazanmak için süreci tersine çevirir.\n\n    Argümanlar:\n        key (str): Orijinal düz metni şifrelemek için kullanılan şifreleme anahtarı.\n                   Bu anahtar yalnızca alfabetik karakterlerden oluşmalıdır.\n        ciphertext (str): Çözülmesi gereken şifreli metin.\n                          Şifreli metin yalnızca alfabetik karakterlerden oluşmalıdır.\n\n    Döndürür:\n        str: Girdi olarak verilen şifreli metne karşılık gelen çözülen düz metin.\n\n    Örnekler:\n        >>> vigenere_decrypt(\"CompleteVictory\", \"Yvqgpxaimmklongnzfwpvxmniytm\")\n        'Wherethereisawillthereisaway'\n\n        >>> vigenere_decrypt(\"ABC\", \"DEF\")\n        'DCB'\n\n        >>> vigenere_decrypt(\"xyz\", \"abc\")\n        'xyz'\n        \n        >>> vigenere_decrypt(\"MiXeD\", \"JpOeR\")\n        'Hello'\n        \n        >>> vigenere_decrypt(\"short\", \"PqrsPqrsPq\")\n        'LongLongLo'\n    \"\"\"\n    # Sağlanan fonksiyonun uygulanması",
      "vi": "def vigenere_decrypt(key: str, ciphertext: str) -> str:\n    \"\"\"\n    Giải mã một văn bản mã hóa bằng mật mã Vigenère sử dụng khóa được cung cấp.\n    \n    Mật mã Vigenère là một phương pháp mã hóa văn bản chữ cái bằng cách sử dụng một loạt\n    các mật mã Caesar dựa trên các chữ cái của một từ khóa. Hàm này đảo ngược quá trình\n    để khôi phục văn bản gốc từ văn bản mã hóa.\n\n    Tham số:\n        key (str): Khóa mã hóa được sử dụng để mã hóa văn bản gốc.\n                   Khóa này chỉ nên bao gồm các ký tự chữ cái.\n        ciphertext (str): Văn bản đã được mã hóa cần được giải mã.\n                          Văn bản mã hóa chỉ nên bao gồm các ký tự chữ cái.\n\n    Trả về:\n        str: Văn bản gốc đã được giải mã tương ứng với văn bản mã hóa đầu vào.\n\n    Ví dụ:\n        >>> vigenere_decrypt(\"CompleteVictory\", \"Yvqgpxaimmklongnzfwpvxmniytm\")\n        'Wherethereisawillthereisaway'\n\n        >>> vigenere_decrypt(\"ABC\", \"DEF\")\n        'DCB'\n\n        >>> vigenere_decrypt(\"xyz\", \"abc\")\n        'xyz'\n        \n        >>> vigenere_decrypt(\"MiXeD\", \"JpOeR\")\n        'Hello'\n        \n        >>> vigenere_decrypt(\"short\", \"PqrsPqrsPq\")\n        'LongLongLo'\n    \"\"\"\n    # Triển khai hàm như đã cung cấp"
    },
    "prompt_bertscore": {
      "es": "0.9731400080941762",
      "arb": "0.9706690461541022",
      "sw": "0.9627278035203274",
      "tr": "0.9788939329719949",
      "vi": "0.9611447193834793"
    },
    "canonical_solution": "    # Convert the key to uppercase for simplicity\n    key = key.upper()\n    key_length = len(key)\n    \n    # Define the alphabet\n    alphabet = 'ABCDEFGHIJKLMNOPQRSTUVWXYZ'\n    \n    # Initialize the plaintext result\n    plaintext = []\n    \n    # Decryption process\n    for i, char in enumerate(ciphertext):\n        if char.isalpha():  # Check if the character is an alphabet\n            # Find the position of the char and key[i] in the alphabet\n            char_index = alphabet.index(char.upper())\n            key_index = alphabet.index(key[i % key_length])\n            \n            # Decrypt the character and preserve the case\n            decrypted_char = alphabet[(char_index - key_index) % 26]\n            if char.islower():\n                decrypted_char = decrypted_char.lower()\n            \n            plaintext.append(decrypted_char)\n        else:\n            plaintext.append(char)\n    \n    # Join the decrypted characters into a single string\n    return ''.join(plaintext)",
    "instruction": {
      "en": "def vigenere_decrypt(key: str, ciphertext: str) -> str:\n    # Convert the key to uppercase for simplicity\n    key = key.upper()\n    key_length = len(key)\n    \n    # Define the alphabet\n    alphabet = 'ABCDEFGHIJKLMNOPQRSTUVWXYZ'\n    \n    # Initialize the plaintext result\n    plaintext = []\n    \n    # Decryption process\n    for i, char in enumerate(ciphertext):\n        if char.isalpha():  # Check if the character is an alphabet\n            # Find the position of the char and key[i] in the alphabet\n            char_index = alphabet.index(char.upper())\n            key_index = alphabet.index(key[i % key_length])\n            \n            # Decrypt the character and preserve the case\n            decrypted_char = alphabet[(char_index - key_index) % 26]\n            if char.islower():\n                decrypted_char = decrypted_char.lower()\n            \n            plaintext.append(decrypted_char)\n        else:\n            plaintext.append(char)\n    \n    # Join the decrypted characters into a single string\n    return ''.join(plaintext)\n\nProvide a concise natural language description (docstring) of the Python code in English using at most 500 characters.",
      "es": "def vigenere_decrypt(key: str, ciphertext: str) -> str:\n    # Convert the key to uppercase for simplicity\n    key = key.upper()\n    key_length = len(key)\n    \n    # Define the alphabet\n    alphabet = 'ABCDEFGHIJKLMNOPQRSTUVWXYZ'\n    \n    # Initialize the plaintext result\n    plaintext = []\n    \n    # Decryption process\n    for i, char in enumerate(ciphertext):\n        if char.isalpha():  # Check if the character is an alphabet\n            # Find the position of the char and key[i] in the alphabet\n            char_index = alphabet.index(char.upper())\n            key_index = alphabet.index(key[i % key_length])\n            \n            # Decrypt the character and preserve the case\n            decrypted_char = alphabet[(char_index - key_index) % 26]\n            if char.islower():\n                decrypted_char = decrypted_char.lower()\n            \n            plaintext.append(decrypted_char)\n        else:\n            plaintext.append(char)\n    \n    # Join the decrypted characters into a single string\n    return ''.join(plaintext)\n\nProporcione una descripción concisa en lenguaje natural (docstring) del código Python en español utilizando un máximo de 500 caracteres.",
      "arb": "def vigenere_decrypt(key: str, ciphertext: str) -> str:\n    # Convert the key to uppercase for simplicity\n    key = key.upper()\n    key_length = len(key)\n    \n    # Define the alphabet\n    alphabet = 'ABCDEFGHIJKLMNOPQRSTUVWXYZ'\n    \n    # Initialize the plaintext result\n    plaintext = []\n    \n    # Decryption process\n    for i, char in enumerate(ciphertext):\n        if char.isalpha():  # Check if the character is an alphabet\n            # Find the position of the char and key[i] in the alphabet\n            char_index = alphabet.index(char.upper())\n            key_index = alphabet.index(key[i % key_length])\n            \n            # Decrypt the character and preserve the case\n            decrypted_char = alphabet[(char_index - key_index) % 26]\n            if char.islower():\n                decrypted_char = decrypted_char.lower()\n            \n            plaintext.append(decrypted_char)\n        else:\n            plaintext.append(char)\n    \n    # Join the decrypted characters into a single string\n    return ''.join(plaintext)\n\nيرجى تقديم وصف موجز بلغة طبيعية (docstring) للكود البرمجي المكتوب بلغة بايثون باللغة العربية الفصحى، بحيث لا يتجاوز 500 حرف.",
      "sw": "def vigenere_decrypt(key: str, ciphertext: str) -> str:\n    # Convert the key to uppercase for simplicity\n    key = key.upper()\n    key_length = len(key)\n    \n    # Define the alphabet\n    alphabet = 'ABCDEFGHIJKLMNOPQRSTUVWXYZ'\n    \n    # Initialize the plaintext result\n    plaintext = []\n    \n    # Decryption process\n    for i, char in enumerate(ciphertext):\n        if char.isalpha():  # Check if the character is an alphabet\n            # Find the position of the char and key[i] in the alphabet\n            char_index = alphabet.index(char.upper())\n            key_index = alphabet.index(key[i % key_length])\n            \n            # Decrypt the character and preserve the case\n            decrypted_char = alphabet[(char_index - key_index) % 26]\n            if char.islower():\n                decrypted_char = decrypted_char.lower()\n            \n            plaintext.append(decrypted_char)\n        else:\n            plaintext.append(char)\n    \n    # Join the decrypted characters into a single string\n    return ''.join(plaintext)\n\nToa maelezo mafupi ya lugha ya asili (docstring) ya msimbo wa Python kwa Kiswahili kwa kutumia herufi zisizozidi 500.",
      "tr": "def vigenere_decrypt(key: str, ciphertext: str) -> str:\n    # Convert the key to uppercase for simplicity\n    key = key.upper()\n    key_length = len(key)\n    \n    # Define the alphabet\n    alphabet = 'ABCDEFGHIJKLMNOPQRSTUVWXYZ'\n    \n    # Initialize the plaintext result\n    plaintext = []\n    \n    # Decryption process\n    for i, char in enumerate(ciphertext):\n        if char.isalpha():  # Check if the character is an alphabet\n            # Find the position of the char and key[i] in the alphabet\n            char_index = alphabet.index(char.upper())\n            key_index = alphabet.index(key[i % key_length])\n            \n            # Decrypt the character and preserve the case\n            decrypted_char = alphabet[(char_index - key_index) % 26]\n            if char.islower():\n                decrypted_char = decrypted_char.lower()\n            \n            plaintext.append(decrypted_char)\n        else:\n            plaintext.append(char)\n    \n    # Join the decrypted characters into a single string\n    return ''.join(plaintext)\n\nPython kodunun işlevini açıklayan kısa bir doğal dil açıklaması (docstring) sağlayın. Açıklama, en fazla 500 karakter kullanılarak Türkçe olarak yazılmalıdır.",
      "vi": "def vigenere_decrypt(key: str, ciphertext: str) -> str:\n    # Convert the key to uppercase for simplicity\n    key = key.upper()\n    key_length = len(key)\n    \n    # Define the alphabet\n    alphabet = 'ABCDEFGHIJKLMNOPQRSTUVWXYZ'\n    \n    # Initialize the plaintext result\n    plaintext = []\n    \n    # Decryption process\n    for i, char in enumerate(ciphertext):\n        if char.isalpha():  # Check if the character is an alphabet\n            # Find the position of the char and key[i] in the alphabet\n            char_index = alphabet.index(char.upper())\n            key_index = alphabet.index(key[i % key_length])\n            \n            # Decrypt the character and preserve the case\n            decrypted_char = alphabet[(char_index - key_index) % 26]\n            if char.islower():\n                decrypted_char = decrypted_char.lower()\n            \n            plaintext.append(decrypted_char)\n        else:\n            plaintext.append(char)\n    \n    # Join the decrypted characters into a single string\n    return ''.join(plaintext)\n\nCung cấp mô tả ngắn gọn bằng ngôn ngữ tự nhiên (docstring) cho mã Python bằng tiếng Việt, không quá 500 ký tự."
    },
    "instruction_bertscore": {
      "es": "0.9687387561112052",
      "arb": "0.9141696274206335",
      "sw": "0.914896018724078",
      "tr": "0.878612207020435",
      "vi": "0.905718500598742"
    },
    "level": "",
    "test": "def test_vigenere_decrypt():\n    # Test case 1: Example provided in the problem statement\n    key1 = \"CompleteVictory\"\n    ciphertext1 = \"Yvqgpxaimmklongnzfwpvxmniytm\"\n    expected_plaintext1 = \"Wherethereisawillthereisaway\"\n    assert vigenere_decrypt(key1, ciphertext1) == expected_plaintext1, \"Test case 1 failed\"\n\n    # Test case 2: All uppercase characters\n    key2 = \"ABC\"\n    ciphertext2 = \"DEF\"\n    expected_plaintext2 = \"DDD\"\n    assert vigenere_decrypt(key2, ciphertext2) == expected_plaintext2, \"Test case 2 failed\"\n\n    # Test case 3: All lowercase characters\n    key3 = \"xyz\"\n    ciphertext3 = \"abc\"\n    expected_plaintext3 = \"ddd\"\n    assert vigenere_decrypt(key3, ciphertext3) == expected_plaintext3, \"Test case 3 failed\"\n\n    # Test case 4: Mixed case characters\n    key4 = \"MiXeD\"\n    ciphertext4 = \"JpOeR\"\n    expected_plaintext4 = \"XhRaO\"\n    assert vigenere_decrypt(key4, ciphertext4) == expected_plaintext4, \"Test case 4 failed\"\n\n    # Test case 5: Key shorter than ciphertext\n    key5 = \"short\"\n    ciphertext5 = \"PqrsPqrsPq\"\n    expected_plaintext5 = \"XjdbWykeYx\"\n    assert vigenere_decrypt(key5, ciphertext5) == expected_plaintext5, \"Test case 5 failed\"\n\n    print(\"All test cases passed!\")\n\n# Run the test function\ntest_vigenere_decrypt()",
    "entry_point": "vigenere_decrypt",
    "signature": "def vigenere_decrypt(key: str, ciphertext: str) -> str:",
    "docstring": {
      "en": "Decrypts a ciphertext encrypted with the Vigenère cipher using the provided key.\n\nThe Vigenère cipher is a method of encrypting alphabetic text by using a series of\nCaesar ciphers based on the letters of a keyword. This function reverses the process\nto recover the original plaintext from the ciphertext.\n\nArgs:\nkey (str): The encryption key used to encrypt the original plaintext.\nThis key should consist only of alphabetic characters.\nciphertext (str): The encrypted text that needs to be decrypted.\nThe ciphertext should consist only of alphabetic characters.\n\nReturns:\nstr: The decrypted plaintext corresponding to the input ciphertext.\n\nExamples:\n>>> vigenere_decrypt(\"CompleteVictory\", \"Yvqgpxaimmklongnzfwpvxmniytm\")\n'Wherethereisawillthereisaway'\n\n>>> vigenere_decrypt(\"ABC\", \"DEF\")\n'DCB'\n\n>>> vigenere_decrypt(\"xyz\", \"abc\")\n'xyz'\n\n>>> vigenere_decrypt(\"MiXeD\", \"JpOeR\")\n'Hello'\n\n>>> vigenere_decrypt(\"short\", \"PqrsPqrsPq\")\n'LongLongLo'",
      "es": "Desencripta un texto cifrado con el cifrado de Vigenère usando la clave proporcionada.\n\nEl cifrado de Vigenère es un método de cifrado de texto alfabético utilizando una serie de cifrados César basados en las letras de una palabra clave. Esta función invierte el proceso para recuperar el texto plano original del texto cifrado.\n\nArgumentos:\nkey (str): La clave de cifrado utilizada para cifrar el texto plano original.\nEsta clave debe consistir solo en caracteres alfabéticos.\nciphertext (str): El texto cifrado que necesita ser desencriptado.\nEl texto cifrado debe consistir solo en caracteres alfabéticos.\n\nDevuelve:\nstr: El texto plano desencriptado correspondiente al texto cifrado de entrada.\n\nEjemplos:\n>>> vigenere_decrypt(\"CompleteVictory\", \"Yvqgpxaimmklongnzfwpvxmniytm\")\n'Wherethereisawillthereisaway'\n\n>>> vigenere_decrypt(\"ABC\", \"DEF\")\n'DCB'\n\n>>> vigenere_decrypt(\"xyz\", \"abc\")\n'xyz'\n\n>>> vigenere_decrypt(\"MiXeD\", \"JpOeR\")\n'Hello'\n\n>>> vigenere_decrypt(\"short\", \"PqrsPqrsPq\")\n'LongLongLo'",
      "arb": "يفك تشفير النص المشفر باستخدام شفرة فيجينير باستخدام المفتاح المقدم.\n\nشفرة فيجينير هي طريقة لتشفير النصوص الأبجدية باستخدام سلسلة من شفرات قيصر بناءً على حروف كلمة مفتاحية. تقوم هذه الدالة بعكس العملية لاستعادة النص الأصلي من النص المشفر.\n\nالمعاملات:\nkey (str): مفتاح التشفير المستخدم لتشفير النص الأصلي.\nيجب أن يتكون هذا المفتاح من حروف أبجدية فقط.\nciphertext (str): النص المشفر الذي يحتاج إلى فك التشفير.\nيجب أن يتكون النص المشفر من حروف أبجدية فقط.\n\nالقيم المعادة:\nstr: النص المفكوك الذي يتوافق مع النص المشفر المدخل.\n\nأمثلة:\n>>> vigenere_decrypt(\"CompleteVictory\", \"Yvqgpxaimmklongnzfwpvxmniytm\")\n'Wherethereisawillthereisaway'\n\n>>> vigenere_decrypt(\"ABC\", \"DEF\")\n'DCB'\n\n>>> vigenere_decrypt(\"xyz\", \"abc\")\n'xyz'\n\n>>> vigenere_decrypt(\"MiXeD\", \"JpOeR\")\n'Hello'\n\n>>> vigenere_decrypt(\"short\", \"PqrsPqrsPq\")\n'LongLongLo'",
      "sw": "Kufungua maandishi ya siri yaliyosimbwa na Vigenère cipher kwa kutumia ufunguo uliotolewa.\n\nVigenère cipher ni mbinu ya kusimba maandishi ya alfabeti kwa kutumia mfululizo wa\nCaesar ciphers kulingana na herufi za neno kuu. Kazi hii inarudisha mchakato\nili kurejesha maandishi asilia kutoka kwenye ciphertext.\n\nHoja:\nkey (str): Ufunguo wa usimbaji uliotumika kusimba maandishi asilia.\nUfunguo huu unapaswa kuwa na herufi za alfabeti pekee.\nciphertext (str): Maandishi yaliyosimbwa ambayo yanahitaji kufumbuliwa.\nCiphertext inapaswa kuwa na herufi za alfabeti pekee.\n\nInarejesha:\nstr: Maandishi asilia yaliyofumbuliwa yanayolingana na ciphertext iliyoingizwa.\n\nMifano:\n>>> vigenere_decrypt(\"CompleteVictory\", \"Yvqgpxaimmklongnzfwpvxmniytm\")\n'Wherethereisawillthereisaway'\n\n>>> vigenere_decrypt(\"ABC\", \"DEF\")\n'DCB'\n\n>>> vigenere_decrypt(\"xyz\", \"abc\")\n'xyz'\n\n>>> vigenere_decrypt(\"MiXeD\", \"JpOeR\")\n'Hello'\n\n>>> vigenere_decrypt(\"short\", \"PqrsPqrsPq\")\n'LongLongLo'",
      "tr": "Bir şifreleme anahtarı kullanılarak Vigenère şifresiyle şifrelenmiş bir şifreli metni çözer.\n\nVigenère şifresi, alfabetik metni bir anahtar kelimenin harflerine dayanan bir dizi Sezar şifresi kullanarak şifreleme yöntemidir. Bu fonksiyon, şifreli metinden orijinal düz metni geri kazanmak için süreci tersine çevirir.\n\nArgümanlar:\nkey (str): Orijinal düz metni şifrelemek için kullanılan şifreleme anahtarı.\nBu anahtar yalnızca alfabetik karakterlerden oluşmalıdır.\nciphertext (str): Çözülmesi gereken şifreli metin.\nŞifreli metin yalnızca alfabetik karakterlerden oluşmalıdır.\n\nDöndürür:\nstr: Girdi şifreli metnine karşılık gelen çözülmüş düz metin.\n\nÖrnekler:\n>>> vigenere_decrypt(\"CompleteVictory\", \"Yvqgpxaimmklongnzfwpvxmniytm\")\n'Wherethereisawillthereisaway'\n\n>>> vigenere_decrypt(\"ABC\", \"DEF\")\n'DCB'\n\n>>> vigenere_decrypt(\"xyz\", \"abc\")\n'xyz'\n\n>>> vigenere_decrypt(\"MiXeD\", \"JpOeR\")\n'Hello'\n\n>>> vigenere_decrypt(\"short\", \"PqrsPqrsPq\")\n'LongLongLo'",
      "vi": "Giải mã một bản mã đã được mã hóa bằng mật mã Vigenère sử dụng khóa được cung cấp.\n\nMật mã Vigenère là một phương pháp mã hóa văn bản chữ cái bằng cách sử dụng một loạt các\nmật mã Caesar dựa trên các chữ cái của một từ khóa. Hàm này đảo ngược quá trình\nđể khôi phục văn bản gốc từ bản mã.\n\nTham số:\nkey (str): Khóa mã hóa được sử dụng để mã hóa văn bản gốc.\nKhóa này chỉ nên bao gồm các ký tự chữ cái.\nciphertext (str): Văn bản đã được mã hóa cần được giải mã.\nBản mã chỉ nên bao gồm các ký tự chữ cái.\n\nTrả về:\nstr: Văn bản gốc đã được giải mã tương ứng với bản mã đầu vào.\n\nVí dụ:\n>>> vigenere_decrypt(\"CompleteVictory\", \"Yvqgpxaimmklongnzfwpvxmniytm\")\n'Wherethereisawillthereisaway'\n\n>>> vigenere_decrypt(\"ABC\", \"DEF\")\n'DCB'\n\n>>> vigenere_decrypt(\"xyz\", \"abc\")\n'xyz'\n\n>>> vigenere_decrypt(\"MiXeD\", \"JpOeR\")\n'Hello'\n\n>>> vigenere_decrypt(\"short\", \"PqrsPqrsPq\")\n'LongLongLo'"
    },
    "docstring_bertscore": {
      "es": "0.9843024396171938",
      "arb": "0.9558603567264271",
      "sw": "0.9757853675087989",
      "tr": "0.9899522821753501",
      "vi": "0.9706418337919004"
    }
  },
  {
    "task_id": "Python/41",
    "prompt": {
      "en": "def mod_inverse(a, b):\n    \"\"\"\n    Calculate the modular multiplicative inverse of `a` modulo `b`.\n    \n    This function finds an integer `x` such that (a * x) % b == 1, provided that\n    `a` and `b` are coprime (i.e., gcd(a, b) == 1). It uses the Extended Euclidean\n    Algorithm to compute the inverse. If `a` and `b` are not coprime, the modular\n    inverse does not exist, and the function returns `None`.\n    \n    Args:\n      a (int): The integer whose modular inverse is to be found.\n      b (int): The modulus with respect to which the inverse is sought.\n    \n    Returns:\n      int: The modular inverse of `a` modulo `b` if it exists, otherwise `None`.\n    \n    Examples:\n      >>> mod_inverse(3, 10)\n      7\n      # Explanation: (3 * 7) % 10 == 1\n\n      >>> mod_inverse(17, 3120)\n      2753\n      # Explanation: (17 * 2753) % 3120 == 1\n\n      >>> mod_inverse(42, 2017)\n      None\n      # Explanation: gcd(42, 2017) != 1, so no inverse exists\n    \"\"\"",
      "es": "def mod_inverse(a, b):\n    \"\"\"\n    Calcular el inverso multiplicativo modular de `a` módulo `b`.\n    \n    Esta función encuentra un entero `x` tal que (a * x) % b == 1, siempre que\n    `a` y `b` sean coprimos (es decir, gcd(a, b) == 1). Utiliza el Algoritmo\n    Euclidiano Extendido para calcular el inverso. Si `a` y `b` no son coprimos,\n    el inverso modular no existe, y la función devuelve `None`.\n    \n    Argumentos:\n      a (int): El entero cuyo inverso modular se va a encontrar.\n      b (int): El módulo con respecto al cual se busca el inverso.\n    \n    Devuelve:\n      int: El inverso modular de `a` módulo `b` si existe, de lo contrario `None`.\n    \n    Ejemplos:\n      >>> mod_inverse(3, 10)\n      7\n      # Explicación: (3 * 7) % 10 == 1\n\n      >>> mod_inverse(17, 3120)\n      2753\n      # Explicación: (17 * 2753) % 3120 == 1\n\n      >>> mod_inverse(42, 2017)\n      None\n      # Explicación: gcd(42, 2017) != 1, por lo que no existe inverso\n    \"\"\"",
      "arb": "def mod_inverse(a, b):\n    \"\"\"\n    حساب المعكوس الضربي المعياري لـ `a` بالنسبة إلى `b`.\n    \n    تقوم هذه الدالة بإيجاد عدد صحيح `x` بحيث يكون (a * x) % b == 1، بشرط أن\n    يكون `a` و `b` متباينين (أي أن gcd(a, b) == 1). تستخدم خوارزمية إقليدس الموسعة\n    لحساب المعكوس. إذا لم يكن `a` و `b` متباينين، فإن المعكوس المعياري لا يوجد،\n    وتعيد الدالة `None`.\n    \n    يعيدالحجج:\n      a (int): العدد الصحيح الذي يراد إيجاد معكوسه المعياري.\n      b (int): المودولوس الذي يُبحث بالنسبة له عن المعكوس.\n    \n    يعيد:\n      int: المعكوس المعياري لـ `a` بالنسبة إلى `b` إذا كان موجودًا، وإلا `None`.\n    \n    امثله:\n      >>> mod_inverse(3, 10)\n      7\n      # الشرح: (3 * 7) % 10 == 1\n\n      >>> mod_inverse(17, 3120)\n      2753\n      # الشرح: (17 * 2753) % 3120 == 1\n\n      >>> mod_inverse(42, 2017)\n      None\n      # الشرح: gcd(42, 2017) != 1، لذا لا يوجد معكوس\n    \"\"\"",
      "sw": "def mod_inverse(a, b):\n    \"\"\"\n    Kuhesabu kinyume cha kuzidisha cha moduli cha `a` modulo `b`.\n    \n    Kazi hii inapata nambari kamili `x` kama kwamba (a * x) % b == 1, mradi tu\n    `a` na `b` ni nambari zisizo na mgawanyiko (yaani, gcd(a, b) == 1). Inatumia\n    Algorithimu ya Euclidean Iliyopanuliwa kuhesabu kinyume. Ikiwa `a` na `b` si\n    nambari zisizo na mgawanyiko, kinyume cha moduli hakipo, na kazi inarudisha `None`.\n    \n    Hoja:\n      a (int): Nambari kamili ambayo kinyume cha moduli kinapaswa kupatikana.\n      b (int): Moduli ambayo kinyume kinatafutwa.\n    \n    Inarejesha:\n      int: Kinyume cha moduli cha `a` modulo `b` kama kipo, vinginevyo `None`.\n    \n    Mifano:\n      >>> mod_inverse(3, 10)\n      7\n      # Maelezo: (3 * 7) % 10 == 1\n\n      >>> mod_inverse(17, 3120)\n      2753\n      # Maelezo: (17 * 2753) % 3120 == 1\n\n      >>> mod_inverse(42, 2017)\n      None\n      # Maelezo: gcd(42, 2017) != 1, kwa hivyo hakuna kinyume kinachokuwepo\n    \"\"\"",
      "tr": "def mod_inverse(a, b):\n    \"\"\"\n    `a` sayısının `b` modülüne göre modular çarpımsal tersini hesapla.\n    \n    Bu fonksiyon, (a * x) % b == 1 olacak şekilde bir tamsayı `x` bulur, \n    bu, `a` ve `b` aralarında asal olduğunda mümkündür (yani, gcd(a, b) == 1). \n    Tersi hesaplamak için Genişletilmiş Öklid Algoritması'nı kullanır. \n    Eğer `a` ve `b` aralarında asal değilse, modular ters mevcut değildir \n    ve fonksiyon `None` döner.\n    \n    Argümanlar:\n      a (int): Modular tersi bulunacak tamsayı.\n      b (int): Tersinin arandığı modül.\n    \n    Döndürür:\n      int: `a` sayısının `b` modülüne göre modular tersi varsa, aksi takdirde `None`.\n    \n    Örnekler:\n      >>> mod_inverse(3, 10)\n      7\n      # Açıklama: (3 * 7) % 10 == 1\n\n      >>> mod_inverse(17, 3120)\n      2753\n      # Açıklama: (17 * 2753) % 3120 == 1\n\n      >>> mod_inverse(42, 2017)\n      None\n      # Açıklama: gcd(42, 2017) != 1, bu yüzden ters mevcut değil\n    \"\"\"",
      "vi": "def mod_inverse(a, b):\n    \"\"\"\n    Tính toán nghịch đảo nhân theo modulo của `a` modulo `b`.\n    \n    Hàm này tìm một số nguyên `x` sao cho (a * x) % b == 1, với điều kiện\n    `a` và `b` là hai số nguyên tố cùng nhau (tức là, gcd(a, b) == 1). Nó sử dụng\n    Thuật toán Euclid mở rộng để tính toán nghịch đảo. Nếu `a` và `b` không phải\n    là hai số nguyên tố cùng nhau, nghịch đảo theo modulo không tồn tại và hàm sẽ trả về `None`.\n    \n    Tham số:\n      a (int): Số nguyên cần tìm nghịch đảo theo modulo.\n      b (int): Modulus theo đó cần tìm nghịch đảo.\n    \n    Trả về:\n      int: Nghịch đảo theo modulo của `a` modulo `b` nếu tồn tại, ngược lại trả về `None`.\n    \n    Ví dụ:\n      >>> mod_inverse(3, 10)\n      7\n      # Giải thích: (3 * 7) % 10 == 1\n\n      >>> mod_inverse(17, 3120)\n      2753\n      # Giải thích: (17 * 2753) % 3120 == 1\n\n      >>> mod_inverse(42, 2017)\n      None\n      # Giải thích: gcd(42, 2017) != 1, do đó không tồn tại nghịch đảo\n    \"\"\""
    },
    "prompt_bertscore": {
      "es": "0.9991560195109828",
      "arb": "0.981758183066518",
      "sw": "0.9843173368957714",
      "tr": "0.9747695717401864",
      "vi": "0.9745447221488549"
    },
    "canonical_solution": "    def extended_gcd(a, b):\n        if a == 0:\n            return b, 0, 1\n        gcd, x1, y1 = extended_gcd(b % a, a)\n        x = y1 - (b // a) * x1\n        y = x1\n        return gcd, x, y\n    gcd, x, _ = extended_gcd(a, b)\n    if gcd != 1:\n        # Modular inverse does not exist since a and b are not coprime\n        return None\n    else:\n        # Make sure the result is positive\n        return x % b",
    "instruction": {
      "en": "def mod_inverse(a, b):\n    def extended_gcd(a, b):\n        if a == 0:\n            return b, 0, 1\n        gcd, x1, y1 = extended_gcd(b % a, a)\n        x = y1 - (b // a) * x1\n        y = x1\n        return gcd, x, y\n    gcd, x, _ = extended_gcd(a, b)\n    if gcd != 1:\n        # Modular inverse does not exist since a and b are not coprime\n        return None\n    else:\n        # Make sure the result is positive\n        return x % b\n\nProvide a concise natural language description (docstring) of the Python code in English using at most 500 characters.",
      "es": "def mod_inverse(a, b):\n    def extended_gcd(a, b):\n        if a == 0:\n            return b, 0, 1\n        gcd, x1, y1 = extended_gcd(b % a, a)\n        x = y1 - (b // a) * x1\n        y = x1\n        return gcd, x, y\n    gcd, x, _ = extended_gcd(a, b)\n    if gcd != 1:\n        # Modular inverse does not exist since a and b are not coprime\n        return None\n    else:\n        # Make sure the result is positive\n        return x % b\n\nProporciona una descripción concisa en lenguaje natural (docstring) del código Python en español utilizando como máximo 500 caracteres.",
      "arb": "def mod_inverse(a, b):\n    def extended_gcd(a, b):\n        if a == 0:\n            return b, 0, 1\n        gcd, x1, y1 = extended_gcd(b % a, a)\n        x = y1 - (b // a) * x1\n        y = x1\n        return gcd, x, y\n    gcd, x, _ = extended_gcd(a, b)\n    if gcd != 1:\n        # Modular inverse does not exist since a and b are not coprime\n        return None\n    else:\n        # Make sure the result is positive\n        return x % b\n\nقدم وصفًا موجزًا بلغة طبيعية (docstring) للشفرة البرمجية بلغة بايثون باللغة العربية الفصحى باستخدام 500 حرف كحد أقصى.",
      "sw": "def mod_inverse(a, b):\n    def extended_gcd(a, b):\n        if a == 0:\n            return b, 0, 1\n        gcd, x1, y1 = extended_gcd(b % a, a)\n        x = y1 - (b // a) * x1\n        y = x1\n        return gcd, x, y\n    gcd, x, _ = extended_gcd(a, b)\n    if gcd != 1:\n        # Modular inverse does not exist since a and b are not coprime\n        return None\n    else:\n        # Make sure the result is positive\n        return x % b\n\nToa maelezo mafupi ya lugha ya asili (docstring) ya msimbo wa Python kwa Kiswahili kwa kutumia herufi zisizozidi 500.",
      "tr": "def mod_inverse(a, b):\n    def extended_gcd(a, b):\n        if a == 0:\n            return b, 0, 1\n        gcd, x1, y1 = extended_gcd(b % a, a)\n        x = y1 - (b // a) * x1\n        y = x1\n        return gcd, x, y\n    gcd, x, _ = extended_gcd(a, b)\n    if gcd != 1:\n        # Modular inverse does not exist since a and b are not coprime\n        return None\n    else:\n        # Make sure the result is positive\n        return x % b\n\nVerilen Python kodunun işlevini açıklayan, en fazla 500 karakter uzunluğunda özlü bir doğal dil açıklaması (docstring) sağlayın.",
      "vi": "def mod_inverse(a, b):\n    def extended_gcd(a, b):\n        if a == 0:\n            return b, 0, 1\n        gcd, x1, y1 = extended_gcd(b % a, a)\n        x = y1 - (b // a) * x1\n        y = x1\n        return gcd, x, y\n    gcd, x, _ = extended_gcd(a, b)\n    if gcd != 1:\n        # Modular inverse does not exist since a and b are not coprime\n        return None\n    else:\n        # Make sure the result is positive\n        return x % b\n\nCung cấp mô tả ngắn gọn bằng ngôn ngữ tự nhiên (docstring) cho mã Python bằng tiếng Việt, sử dụng tối đa 500 ký tự."
    },
    "instruction_bertscore": {
      "es": "0.9687387561112052",
      "arb": "0.9438928762690751",
      "sw": "0.914896018724078",
      "tr": "0.8508820154152974",
      "vi": "0.9069722555638342"
    },
    "level": "",
    "test": "def test_mod_inverse():\n    test_cases = [\n        (3, 10),  # Test case 1: gcd(3, 10) = 1, inverse should be 7\n        (17, 3120),  # Test case 2: gcd(17, 3120) = 1, inverse should be 2753\n        (42, 2017),  # Test case 3: gcd(42, 2017) = 1, inverse should be 1969\n    ]\n    expected_results = [\n        7,  # Expected result for test case 1\n        2753,  # Expected result for test case 2\n        1969,  # Expected result for test case 3\n    ]\n\n    for i, (a, b) in enumerate(test_cases):\n        actual_result = mod_inverse(a, b)\n        expected_result = expected_results[i]\n        assert actual_result == expected_result, f\"Test case {i+1} failed: expected {expected_result}, got {actual_result}\"\n        print(f\"Test case {i+1} passed: a={a}, b={b}, x0={actual_result}\")\n\n# Run the test function\ntest_mod_inverse()",
    "entry_point": "mod_inverse",
    "signature": "def mod_inverse(a, b):",
    "docstring": {
      "en": "Calculate the modular multiplicative inverse of `a` modulo `b`.\n\nThis function finds an integer `x` such that (a * x) % b == 1, provided that\n`a` and `b` are coprime (i.e., gcd(a, b) == 1). It uses the Extended Euclidean\nAlgorithm to compute the inverse. If `a` and `b` are not coprime, the modular\ninverse does not exist, and the function returns `None`.\n\nArgs:\na (int): The integer whose modular inverse is to be found.\nb (int): The modulus with respect to which the inverse is sought.\n\nReturns:\nint: The modular inverse of `a` modulo `b` if it exists, otherwise `None`.\n\nExamples:\n>>> mod_inverse(3, 10)\n7\nExplanation: (3 * 7) % 10 == 1\n\n>>> mod_inverse(17, 3120)\n2753\nExplanation: (17 * 2753) % 3120 == 1\n\n>>> mod_inverse(42, 2017)\nNone\nExplanation: gcd(42, 2017) != 1, so no inverse exists",
      "es": "Calcular el inverso multiplicativo modular de `a` módulo `b`.\n\nEsta función encuentra un entero `x` tal que (a * x) % b == 1, siempre que\n`a` y `b` sean coprimos (es decir, gcd(a, b) == 1). Utiliza el Algoritmo\nEuclidiano Extendido para calcular el inverso. Si `a` y `b` no son coprimos, el\ninverso modular no existe, y la función devuelve `None`.\n\nArgumentos:\na (int): El entero cuyo inverso modular se va a encontrar.\nb (int): El módulo con respecto al cual se busca el inverso.\n\nDevuelve:\nint: El inverso modular de `a` módulo `b` si existe, de lo contrario `None`.\n\nEjemplos:\n>>> mod_inverse(3, 10)\n7\nExplicación: (3 * 7) % 10 == 1\n\n>>> mod_inverse(17, 3120)\n2753\nExplicación: (17 * 2753) % 3120 == 1\n\n>>> mod_inverse(42, 2017)\nNone\nExplicación: gcd(42, 2017) != 1, por lo que no existe un inverso",
      "arb": "احسب المعكوس الضربي المعياري لـ `a` بالنسبة لـ `b`.\n\nتجد هذه الدالة عددًا صحيحًا `x` بحيث أن (a * x) % b == 1، بشرط أن\n`a` و `b` أوليان (أي، gcd(a, b) == 1). تستخدم خوارزمية إقليدس الموسعة\nلحساب المعكوس. إذا لم يكن `a` و `b` أوليان، فإن المعكوس المعياري لا يوجد، وتعيد الدالة `None`.\n\nالأوساط:\na (int): العدد الصحيح الذي يجب إيجاد معكوسه المعياري.\nb (int): المعيار الذي يُبحث عن المعكوس بالنسبة له.\n\nالقيم المعادة:\nint: المعكوس المعياري لـ `a` بالنسبة لـ `b` إذا كان موجودًا، وإلا `None`.\n\nأمثلة:\n>>> mod_inverse(3, 10)\n7\nالتوضيح: (3 * 7) % 10 == 1\n\n>>> mod_inverse(17, 3120)\n2753\nالتوضيح: (17 * 2753) % 3120 == 1\n\n>>> mod_inverse(42, 2017)\nNone\nالتوضيح: gcd(42, 2017) != 1، لذا لا يوجد معكوس",
      "sw": "Kuhesabu kinyume cha kuzidisha cha moduli cha `a` modulo `b`.\n\nKazi hii inapata nambari kamili `x` kama kwamba (a * x) % b == 1, mradi tu\n`a` na `b` ni coprime (yaani, gcd(a, b) == 1). Inatumia Algorithm ya Euclidean\nIliyopanuliwa ili kuhesabu kinyume. Ikiwa `a` na `b` si coprime, kinyume cha modular hakipo, na kazi inarudisha `None`.\n\nHoja:\na (int): Nambari kamili ambayo kinyume chake cha modular kinapaswa kupatikana.\nb (int): Modulus ambayo kinyume kinatafutwa.\n\nInarejesha:\nint: Kinyume cha modular cha `a` modulo `b` ikiwa kipo, vinginevyo `None`.\n\nMifano:\n>>> mod_inverse(3, 10)\n7\nMaelezo: (3 * 7) % 10 == 1\n\n>>> mod_inverse(17, 3120)\n2753\nMaelezo: (17 * 2753) % 3120 == 1\n\n>>> mod_inverse(42, 2017)\nNone\nMaelezo: gcd(42, 2017) != 1, kwa hivyo hakuna kinyume kinachokuwepo",
      "tr": "`a` sayısının `b` modülüne göre modüler çarpımsal tersini hesaplayın.\n\nBu fonksiyon, (a * x) % b == 1 olacak şekilde bir tamsayı `x` bulur, bu durumda\n`a` ve `b` aralarında asal olmalıdır (yani, gcd(a, b) == 1). Tersi hesaplamak için\nGenişletilmiş Öklid Algoritması'nı kullanır. Eğer `a` ve `b` aralarında asal değilse,\nmodüler ters mevcut değildir ve fonksiyon `None` döndürür.\n\nArgümanlar:\na (int): Modüler tersi bulunacak tamsayı.\nb (int): Tersinin arandığı modül.\n\nDöndürür:\nint: Eğer mevcutsa `a`'nın `b` modülüne göre modüler tersi, aksi takdirde `None`.\n\nÖrnekler:\n>>> mod_inverse(3, 10)\n7\nAçıklama: (3 * 7) % 10 == 1\n\n>>> mod_inverse(17, 3120)\n2753\nAçıklama: (17 * 2753) % 3120 == 1\n\n>>> mod_inverse(42, 2017)\nNone\nAçıklama: gcd(42, 2017) != 1, bu yüzden ters mevcut değil",
      "vi": "Tính nghịch đảo nhân theo modulo của `a` modulo `b`.\n\nHàm này tìm một số nguyên `x` sao cho (a * x) % b == 1, với điều kiện\n`a` và `b` là nguyên tố cùng nhau (tức là, gcd(a, b) == 1). Nó sử dụng\nThuật toán Euclid mở rộng để tính nghịch đảo. Nếu `a` và `b` không phải là nguyên tố cùng nhau, nghịch đảo theo modulo không tồn tại, và hàm trả về `None`.\n\nTham số:\na (int): Số nguyên cần tìm nghịch đảo theo modulo.\nb (int): Modulo mà nghịch đảo được tìm kiếm.\n\nTrả về:\nint: Nghịch đảo theo modulo của `a` modulo `b` nếu tồn tại, ngược lại `None`.\n\nVí dụ:\n>>> mod_inverse(3, 10)\n7\nGiải thích: (3 * 7) % 10 == 1\n\n>>> mod_inverse(17, 3120)\n2753\nGiải thích: (17 * 2753) % 3120 == 1\n\n>>> mod_inverse(42, 2017)\nNone\nGiải thích: gcd(42, 2017) != 1, vì vậy không có nghịch đảo nào tồn tại"
    },
    "docstring_bertscore": {
      "es": "0.9986802997484042",
      "arb": "0.9773426296961124",
      "sw": "0.989626528350453",
      "tr": "0.9603396704491449",
      "vi": "0.9710375055109219"
    }
  },
  {
    "task_id": "Python/42",
    "prompt": {
      "en": "def find_most_unhappy_day(schedule) -> int:\n    \"\"\"\n    Calculate the day of the week when Jinjin is most unhappy based on her schedule.\n    \n    Jinjin is unhappy if the total hours spent in school and extra classes exceed 8 hours in a day. \n    The function finds the day when her unhappiness is the greatest, which is the day when the total\n    hours are the farthest above the threshold. If there are multiple days with the same level of \n    maximum unhappiness, the earliest day is returned. If Jinjin is not unhappy on any day, the \n    function returns 0.\n    \n    Args:\n        schedule (list[tuple[int, int]]): A list of 7 tuples, where each tuple represents the \n                                           number of hours spent at school and in extra classes\n                                           for each day of the week, respectively.\n                                           \n    Returns:\n        int: The day of the week when Jinjin is most unhappy (1-7 for Monday to Sunday) or 0 \n             if she is never unhappy.\n    \n    Cases:\n        - If Jinjin has the following schedule [(5, 3), (6, 2), (7, 2), (5, 3), (5, 4), (0, 4), (0, 6)],\n          she is most unhappy on Wednesday (day 3), so the function will return 3.\n        - If her schedule is [(4, 3), (4, 3), (4, 3), (4, 3), (4, 3), (0, 3), (0, 2)], Jinjin is never\n          unhappy, and the function will return 0.\n        - For a schedule [(6, 3), (6, 2), (6, 2), (6, 3), (6, 2), (0, 3), (0, 2)], Jinjin is equally \n          unhappy on Monday and Thursday, but since Monday comes first, the function returns 1.\n    \"\"\"",
      "es": "def find_most_unhappy_day(schedule) -> int:\n    \"\"\"\n    Calcula el día de la semana en que Jinjin está más infeliz según su horario.\n    \n    Jinjin está infeliz si el total de horas pasadas en la escuela y clases extra excede 8 horas en un día.\n    La función encuentra el día cuando su infelicidad es mayor, que es el día cuando el total\n    de horas está más por encima del umbral. Si hay múltiples días con el mismo nivel de\n    máxima infelicidad, se devuelve el primer día. Si Jinjin no está infeliz en ningún día, la\n    función devuelve 0.\n    \n    Argumentos:\n        schedule (list[tuple[int, int]]): Una lista de 7 tuplas, donde cada tupla representa el\n                                           número de horas pasadas en la escuela y en clases extra\n                                           para cada día de la semana, respectivamente.\n                                           \n    Devuelve:\n        int: El día de la semana en que Jinjin está más infeliz (1-7 para lunes a domingo) o 0\n             si nunca está infeliz.\n    \n    Casos:\n        - Si Jinjin tiene el siguiente horario [(5, 3), (6, 2), (7, 2), (5, 3), (5, 4), (0, 4), (0, 6)],\n          está más infeliz el miércoles (día 3), por lo que la función devolverá 3.\n        - Si su horario es [(4, 3), (4, 3), (4, 3), (4, 3), (4, 3), (0, 3), (0, 2)], Jinjin nunca está\n          infeliz, y la función devolverá 0.\n        - Para un horario [(6, 3), (6, 2), (6, 2), (6, 3), (6, 2), (0, 3), (0, 2)], Jinjin está igualmente\n          infeliz el lunes y el jueves, pero como el lunes viene primero, la función devuelve 1.\n    \"\"\"",
      "arb": "```python\ndef find_most_unhappy_day(schedule) -> int:\n    \"\"\"\n    حساب اليوم من الأسبوع الذي تكون فيه جينجين الأكثر تعاسة بناءً على جدولها.\n\n    تكون جينجين غير سعيدة إذا تجاوز إجمالي الساعات التي تقضيها في المدرسة والدروس الإضافية 8 ساعات في اليوم.\n    تقوم الدالة بالعثور على اليوم الذي تكون فيه تعاستها أكبر، وهو اليوم الذي تكون فيه الساعات الإجمالية\n    أبعد ما يكون عن الحد الأدنى. إذا كان هناك عدة أيام بنفس مستوى التعاسة القصوى، يتم إرجاع اليوم الأول.\n    إذا لم تكن جينجين غير سعيدة في أي يوم، فإن الدالة ترجع 0.\n\n    يعيدالحجج:\n        schedule (list[tuple[int, int]]): قائمة تحتوي على 7 مجموعات، حيث تمثل كل مجموعة\n                                           عدد الساعات التي تقضيها في المدرسة والدروس الإضافية\n                                           لكل يوم من أيام الأسبوع، على التوالي.\n                                           \n    يعيد:\n        int: اليوم من الأسبوع الذي تكون فيه جينجين الأكثر تعاسة (1-7 من الاثنين إلى الأحد) أو 0\n             إذا لم تكن غير سعيدة أبدًا.\n\n    حالات:\n        - إذا كان لجينجين الجدول التالي [(5, 3), (6, 2), (7, 2), (5, 3), (5, 4), (0, 4), (0, 6)],\n          فإنها تكون الأكثر تعاسة يوم الأربعاء (اليوم 3)، لذا ستعيد الدالة 3.\n        - إذا كان جدولها هو [(4, 3), (4, 3), (4, 3), (4, 3), (4, 3), (0, 3), (0, 2)]، فإن جينجين ليست\n          غير سعيدة أبدًا، وستعيد الدالة 0.\n        - لجدول [(6, 3), (6, 2), (6, 2), (6, 3), (6, 2), (0, 3), (0, 2)]، فإن جينجين تكون غير\n          سعيدة بالتساوي يوم الاثنين والخميس، ولكن بما أن الاثنين يأتي أولاً، فإن الدالة تعيد 1.\n    \"\"\"\n```",
      "sw": "def find_most_unhappy_day(schedule) -> int:\n    \"\"\"\n    Kuhesabu siku ya wiki ambapo Jinjin hana furaha zaidi kulingana na ratiba yake.\n    \n    Jinjin hana furaha ikiwa jumla ya masaa yaliyotumika shuleni na madarasa ya ziada yanazidi masaa 8 kwa siku. \n    Kazi hii inapata siku ambapo kutoridhika kwake ni kubwa zaidi, ambayo ni siku ambapo jumla ya masaa \n    yanazidi kiwango. Ikiwa kuna siku nyingi zenye kiwango sawa cha kutoridhika, siku ya mapema zaidi \n    inarudishwa. Ikiwa Jinjin hana huzuni siku yoyote, kazi inarudisha 0.\n    \n    Hoja:\n        schedule (list[tuple[int, int]]): Orodha ya jozi 7, ambapo kila jozi inawakilisha \n                                           idadi ya masaa yaliyotumika shuleni na kwenye madarasa ya ziada\n                                           kwa kila siku ya wiki, mtawalia.\n                                           \n    Inarejesha:\n        int: Siku ya wiki ambapo Jinjin hana furaha zaidi (1-7 kwa Jumatatu hadi Jumapili) au 0 \n             ikiwa hana huzuni kamwe.\n    \n    Mifano:\n        - Ikiwa Jinjin ana ratiba ifuatayo [(5, 3), (6, 2), (7, 2), (5, 3), (5, 4), (0, 4), (0, 6)],\n          hana furaha zaidi siku ya Jumatano (siku ya 3), hivyo kazi itarudisha 3.\n        - Ikiwa ratiba yake ni [(4, 3), (4, 3), (4, 3), (4, 3), (4, 3), (0, 3), (0, 2)], Jinjin hana huzuni kamwe,\n          na kazi itarudisha 0.\n        - Kwa ratiba [(6, 3), (6, 2), (6, 2), (6, 3), (6, 2), (0, 3), (0, 2)], Jinjin hana furaha sawa \n          siku ya Jumatatu na Alhamisi, lakini kwa kuwa Jumatatu inakuja kwanza, kazi inarudisha 1.\n    \"\"\"",
      "tr": "def find_most_unhappy_day(schedule) -> int:\n    \"\"\"\n    Jinjin'in programına göre en mutsuz olduğu haftanın gününü hesapla.\n    \n    Jinjin, bir günde okulda ve ekstra derslerde geçirilen toplam saatler 8 saati aşarsa mutsuz olur.\n    Fonksiyon, mutsuzluğunun en fazla olduğu günü bulur, bu da toplam saatlerin eşik değerin en çok\n    üzerinde olduğu gündür. Eğer birden fazla gün aynı seviyede maksimum mutsuzluk içeriyorsa, \n    en erken gün döndürülür. Eğer Jinjin herhangi bir gün mutsuz değilse, fonksiyon 0 döndürür.\n    \n    Argümanlar:\n        schedule (list[tuple[int, int]]): Her bir gün için okulda ve ekstra derslerde geçirilen \n                                           saat sayısını temsil eden 7 demetlik bir liste.\n                                           \n    Inarejesha:\n        int: Jinjin'in en mutsuz olduğu haftanın günü (Pazartesi'den Pazar'a 1-7) veya hiç mutsuz \n             değilse 0.\n    \n    Durumlar:\n        - Eğer Jinjin'in programı [(5, 3), (6, 2), (7, 2), (5, 3), (5, 4), (0, 4), (0, 6)] ise,\n          Çarşamba günü (gün 3) en mutsuz olduğu gündür, bu yüzden fonksiyon 3 döndürecektir.\n        - Eğer programı [(4, 3), (4, 3), (4, 3), (4, 3), (4, 3), (0, 3), (0, 2)] ise, Jinjin hiç\n          mutsuz değildir ve fonksiyon 0 döndürecektir.\n        - [(6, 3), (6, 2), (6, 2), (6, 3), (6, 2), (0, 3), (0, 2)] programı için, Jinjin Pazartesi \n          ve Perşembe günleri eşit derecede mutsuzdur, ancak Pazartesi önce geldiği için fonksiyon 1 \n          döndürecektir.\n    \"\"\"",
      "vi": "def find_most_unhappy_day(schedule) -> int:\n    \"\"\"\n    Tính toán ngày trong tuần khi Jinjin cảm thấy không vui nhất dựa trên lịch trình của cô ấy.\n    \n    Jinjin cảm thấy không vui nếu tổng số giờ ở trường và lớp học thêm vượt quá 8 giờ trong một ngày.\n    Hàm này tìm ngày mà sự không vui của cô ấy là lớn nhất, tức là ngày mà tổng số giờ vượt quá ngưỡng\n    nhiều nhất. Nếu có nhiều ngày có mức độ không vui tối đa giống nhau, ngày sớm nhất sẽ được trả về.\n    Nếu Jinjin không cảm thấy không vui vào bất kỳ ngày nào, hàm sẽ trả về 0.\n    \n    Tham số:\n        schedule (list[tuple[int, int]]): Một danh sách gồm 7 bộ giá trị, mỗi bộ giá trị đại diện cho\n                                           số giờ ở trường và lớp học thêm cho mỗi ngày trong tuần.\n                                           \n    Trả về:\n        int: Ngày trong tuần khi Jinjin cảm thấy không vui nhất (1-7 cho Thứ Hai đến Chủ Nhật) hoặc 0\n             nếu cô ấy không bao giờ cảm thấy không vui.\n    \n    Trường hợp:\n        - Nếu Jinjin có lịch trình sau [(5, 3), (6, 2), (7, 2), (5, 3), (5, 4), (0, 4), (0, 6)],\n          cô ấy cảm thấy không vui nhất vào Thứ Tư (ngày 3), vì vậy hàm sẽ trả về 3.\n        - Nếu lịch trình của cô ấy là [(4, 3), (4, 3), (4, 3), (4, 3), (4, 3), (0, 3), (0, 2)], Jinjin\n          không bao giờ cảm thấy không vui, và hàm sẽ trả về 0.\n        - Với lịch trình [(6, 3), (6, 2), (6, 2), (6, 3), (6, 2), (0, 3), (0, 2)], Jinjin cảm thấy không\n          vui như nhau vào Thứ Hai và Thứ Năm, nhưng vì Thứ Hai đến trước, hàm sẽ trả về 1.\n    \"\"\""
    },
    "prompt_bertscore": {
      "es": "0.9837407128996272",
      "arb": "0.9648271280174852",
      "sw": "0.9716141295070662",
      "tr": "0.9566129672401683",
      "vi": "0.9623815907661836"
    },
    "canonical_solution": "    DAYS_OF_WEEK = 7\n    UNHAPPINESS_THRESHOLD = 8\n\n    most_unhappy_day = 0\n    max_unhappiness = 0\n\n    for day in range(1, DAYS_OF_WEEK + 1):\n        school_hours, extra_class_hours = schedule[day - 1]\n        total_hours = school_hours + extra_class_hours\n        unhappiness = total_hours - UNHAPPINESS_THRESHOLD\n\n        if unhappiness > max_unhappiness:\n            max_unhappiness = unhappiness\n            most_unhappy_day = day\n\n    return most_unhappy_day",
    "instruction": {
      "en": "def find_most_unhappy_day(schedule) -> int:\n    DAYS_OF_WEEK = 7\n    UNHAPPINESS_THRESHOLD = 8\n\n    most_unhappy_day = 0\n    max_unhappiness = 0\n\n    for day in range(1, DAYS_OF_WEEK + 1):\n        school_hours, extra_class_hours = schedule[day - 1]\n        total_hours = school_hours + extra_class_hours\n        unhappiness = total_hours - UNHAPPINESS_THRESHOLD\n\n        if unhappiness > max_unhappiness:\n            max_unhappiness = unhappiness\n            most_unhappy_day = day\n\n    return most_unhappy_day\n\nProvide a concise natural language description (docstring) of the Python code in English using at most 500 characters.",
      "es": "def find_most_unhappy_day(schedule) -> int:\n    DAYS_OF_WEEK = 7\n    UNHAPPINESS_THRESHOLD = 8\n\n    most_unhappy_day = 0\n    max_unhappiness = 0\n\n    for day in range(1, DAYS_OF_WEEK + 1):\n        school_hours, extra_class_hours = schedule[day - 1]\n        total_hours = school_hours + extra_class_hours\n        unhappiness = total_hours - UNHAPPINESS_THRESHOLD\n\n        if unhappiness > max_unhappiness:\n            max_unhappiness = unhappiness\n            most_unhappy_day = day\n\n    return most_unhappy_day\n\nProporcione una descripción concisa en lenguaje natural (docstring) del código Python en español utilizando un máximo de 500 caracteres.",
      "arb": "def find_most_unhappy_day(schedule) -> int:\n    DAYS_OF_WEEK = 7\n    UNHAPPINESS_THRESHOLD = 8\n\n    most_unhappy_day = 0\n    max_unhappiness = 0\n\n    for day in range(1, DAYS_OF_WEEK + 1):\n        school_hours, extra_class_hours = schedule[day - 1]\n        total_hours = school_hours + extra_class_hours\n        unhappiness = total_hours - UNHAPPINESS_THRESHOLD\n\n        if unhappiness > max_unhappiness:\n            max_unhappiness = unhappiness\n            most_unhappy_day = day\n\n    return most_unhappy_day\n\nيرجى تقديم وصف موجز بلغة طبيعية (docstring) للكود البرمجي بلغة بايثون باللغة العربية الفصحى، بحيث لا يتجاوز 500 حرف.",
      "sw": "def find_most_unhappy_day(schedule) -> int:\n    DAYS_OF_WEEK = 7\n    UNHAPPINESS_THRESHOLD = 8\n\n    most_unhappy_day = 0\n    max_unhappiness = 0\n\n    for day in range(1, DAYS_OF_WEEK + 1):\n        school_hours, extra_class_hours = schedule[day - 1]\n        total_hours = school_hours + extra_class_hours\n        unhappiness = total_hours - UNHAPPINESS_THRESHOLD\n\n        if unhappiness > max_unhappiness:\n            max_unhappiness = unhappiness\n            most_unhappy_day = day\n\n    return most_unhappy_day\n\nToa maelezo mafupi ya lugha ya asili (docstring) ya msimbo wa Python kwa Kiswahili kwa kutumia herufi zisizozidi 500.",
      "tr": "def find_most_unhappy_day(schedule) -> int:\n    DAYS_OF_WEEK = 7\n    UNHAPPINESS_THRESHOLD = 8\n\n    most_unhappy_day = 0\n    max_unhappiness = 0\n\n    for day in range(1, DAYS_OF_WEEK + 1):\n        school_hours, extra_class_hours = schedule[day - 1]\n        total_hours = school_hours + extra_class_hours\n        unhappiness = total_hours - UNHAPPINESS_THRESHOLD\n\n        if unhappiness > max_unhappiness:\n            max_unhappiness = unhappiness\n            most_unhappy_day = day\n\n    return most_unhappy_day\n\nVerilen Python kodunun işlevini açıklayan kısa bir doğal dil açıklaması (docstring) sağlayın. Açıklama, en fazla 500 karakter kullanarak Türkçe olmalıdır.",
      "vi": "def find_most_unhappy_day(schedule) -> int:\n    DAYS_OF_WEEK = 7\n    UNHAPPINESS_THRESHOLD = 8\n\n    most_unhappy_day = 0\n    max_unhappiness = 0\n\n    for day in range(1, DAYS_OF_WEEK + 1):\n        school_hours, extra_class_hours = schedule[day - 1]\n        total_hours = school_hours + extra_class_hours\n        unhappiness = total_hours - UNHAPPINESS_THRESHOLD\n\n        if unhappiness > max_unhappiness:\n            max_unhappiness = unhappiness\n            most_unhappy_day = day\n\n    return most_unhappy_day\n\nCung cấp mô tả ngắn gọn bằng ngôn ngữ tự nhiên (docstring) cho mã Python bằng tiếng Việt, không quá 500 ký tự."
    },
    "instruction_bertscore": {
      "es": "0.9687387561112052",
      "arb": "0.9141696274206335",
      "sw": "0.914896018724078",
      "tr": "0.8712324924738458",
      "vi": "0.905718500598742"
    },
    "level": "",
    "test": "def test_find_most_unhappy_day():\n    # Test case 1: Provided example where Jinjin is most unhappy on Wednesday\n    schedule1 = [\n        (5, 3),\n        (6, 2),\n        (7, 2),\n        (5, 3),\n        (5, 4),\n        (0, 4),\n        (0, 6)\n    ]\n    assert find_most_unhappy_day(schedule1) == 3, \"Test case 1 failed\"\n\n    # Test case 2: Jinjin is never unhappy\n    schedule2 = [\n        (4, 3),\n        (4, 3),\n        (4, 3),\n        (4, 3),\n        (4, 3),\n        (0, 3),\n        (0, 2)\n    ]\n    assert find_most_unhappy_day(schedule2) == 0, \"Test case 2 failed\"\n\n    # Test case 3: Jinjin is most unhappy on Monday and Thursday, but Monday should be returned\n    schedule3 = [\n        (6, 3),\n        (6, 2),\n        (6, 2),\n        (6, 3),\n        (6, 2),\n        (0, 3),\n        (0, 2)\n    ]\n    assert find_most_unhappy_day(schedule3) == 1, \"Test case 3 failed\"\n\n    print(\"All test cases passed.\")\n\n# Run the test function\ntest_find_most_unhappy_day()",
    "entry_point": "find_most_unhappy_day",
    "signature": "def find_most_unhappy_day(schedule) -> int:",
    "docstring": {
      "en": "Calculate the day of the week when Jinjin is most unhappy based on her schedule.\n\nJinjin is unhappy if the total hours spent in school and extra classes exceed 8 hours in a day.\nThe function finds the day when her unhappiness is the greatest, which is the day when the total\nhours are the farthest above the threshold. If there are multiple days with the same level of\nmaximum unhappiness, the earliest day is returned. If Jinjin is not unhappy on any day, the\nfunction returns 0.\n\nArgs:\nschedule (list[tuple[int, int]]): A list of 7 tuples, where each tuple represents the\nnumber of hours spent at school and in extra classes\nfor each day of the week, respectively.\n\nReturns:\nint: The day of the week when Jinjin is most unhappy (1-7 for Monday to Sunday) or 0\nif she is never unhappy.\n\nCases:\n- If Jinjin has the following schedule [(5, 3), (6, 2), (7, 2), (5, 3), (5, 4), (0, 4), (0, 6)],\nshe is most unhappy on Wednesday (day 3), so the function will return 3.\n- If her schedule is [(4, 3), (4, 3), (4, 3), (4, 3), (4, 3), (0, 3), (0, 2)], Jinjin is never\nunhappy, and the function will return 0.\n- For a schedule [(6, 3), (6, 2), (6, 2), (6, 3), (6, 2), (0, 3), (0, 2)], Jinjin is equally\nunhappy on Monday and Thursday, but since Monday comes first, the function returns 1.",
      "es": "Calcular el día de la semana cuando Jinjin está más infeliz según su horario.\n\nJinjin está infeliz si el total de horas pasadas en la escuela y clases extra excede 8 horas en un día. La función encuentra el día cuando su infelicidad es mayor, que es el día cuando el total de horas está más por encima del umbral. Si hay múltiples días con el mismo nivel de máxima infelicidad, se devuelve el primer día. Si Jinjin no está infeliz en ningún día, la función devuelve 0.\n\nArgumentos:\nschedule (list[tuple[int, int]]): Una lista de 7 tuplas, donde cada tupla representa el\nnúmero de horas pasadas en la escuela y en clases extra\npara cada día de la semana, respectivamente.\n\nDevuelve:\nint: El día de la semana cuando Jinjin está más infeliz (1-7 para lunes a domingo) o 0\nsi nunca está infeliz.\n\nCases:\n- Si Jinjin tiene el siguiente horario [(5, 3), (6, 2), (7, 2), (5, 3), (5, 4), (0, 4), (0, 6)],\nestá más infeliz el miércoles (día 3), por lo que la función devolverá 3.\n- Si su horario es [(4, 3), (4, 3), (4, 3), (4, 3), (4, 3), (0, 3), (0, 2)], Jinjin nunca está\ninfeliz, y la función devolverá 0.\n- Para un horario [(6, 3), (6, 2), (6, 2), (6, 3), (6, 2), (0, 3), (0, 2)], Jinjin está igualmente\ninfeliz el lunes y el jueves, pero como el lunes viene primero, la función devuelve 1.",
      "arb": "احسب اليوم من الأسبوع الذي تكون فيه جينجين الأكثر تعاسة بناءً على جدولها.\n\nجينجين تكون غير سعيدة إذا تجاوز إجمالي الساعات التي تقضيها في المدرسة والدروس الإضافية 8 ساعات في اليوم. تقوم الدالة بالعثور على اليوم الذي تكون فيه تعاستها هي الأكبر، وهو اليوم الذي يكون فيه إجمالي الساعات هو الأبعد عن الحد الأدنى. إذا كان هناك عدة أيام بنفس مستوى التعاسة القصوى، يتم إرجاع اليوم الأسبق. إذا لم تكن جينجين غير سعيدة في أي يوم، تُرجع الدالة 0.\n\nيعيدالحجج:\nschedule (list[tuple[int, int]]): قائمة من 7 مجموعات، حيث تمثل كل مجموعة عدد الساعات التي تقضيها في المدرسة وفي الدروس الإضافية لكل يوم من أيام الأسبوع، على التوالي.\n\nيعيد:\nint: اليوم من الأسبوع الذي تكون فيه جينجين الأكثر تعاسة (1-7 من الاثنين إلى الأحد) أو 0 إذا لم تكن غير سعيدة أبدًا.\n\nCases:\n- إذا كان لدى جينجين الجدول الزمني التالي [(5, 3), (6, 2), (7, 2), (5, 3), (5, 4), (0, 4), (0, 6)]، فهي تكون الأكثر تعاسة في يوم الأربعاء (اليوم 3)، لذا ستعيد الدالة 3.\n- إذا كان جدولها [(4, 3), (4, 3), (4, 3), (4, 3), (4, 3), (0, 3), (0, 2)]، فإن جينجين ليست غير سعيدة أبدًا، وستعيد الدالة 0.\n- بالنسبة لجدول [(6, 3), (6, 2), (6, 2), (6, 3), (6, 2), (0, 3), (0, 2)]، فإن جينجين تكون غير سعيدة بالتساوي في يوم الاثنين والخميس، ولكن بما أن يوم الاثنين يأتي أولاً، فإن الدالة تعيد 1.",
      "sw": "Hesabu siku ya wiki ambayo Jinjin ana huzuni zaidi kulingana na ratiba yake.\n\nJinjin ana huzuni ikiwa jumla ya masaa yaliyotumika shuleni na madarasa ya ziada yanazidi masaa 8 kwa siku. Kazi hii inapata siku ambayo huzuni yake ni kubwa zaidi, ambayo ni siku ambapo jumla ya masaa ni mengi zaidi juu ya kizingiti. Ikiwa kuna siku nyingi zenye kiwango sawa cha huzuni kubwa, siku ya mapema zaidi inarejeshwa. Ikiwa Jinjin hana huzuni siku yoyote, kazi inarejesha 0.\n\nHoja:\nschedule (list[tuple[int, int]]): Orodha ya jozi 7, ambapo kila jozi inawakilisha\nidadi ya masaa yaliyotumika shuleni na katika madarasa ya ziada\nkwa kila siku ya wiki, mtawalia.\n\nInarejesha:\nint: Siku ya wiki ambayo Jinjin ana huzuni zaidi (1-7 kwa Jumatatu hadi Jumapili) au 0\nikiwa hana huzuni kamwe.\n\nCases:\n- Ikiwa Jinjin ana ratiba ifuatayo [(5, 3), (6, 2), (7, 2), (5, 3), (5, 4), (0, 4), (0, 6)],\nana huzuni zaidi siku ya Jumatano (siku ya 3), hivyo kazi itarejesha 3.\n- Ikiwa ratiba yake ni [(4, 3), (4, 3), (4, 3), (4, 3), (4, 3), (0, 3), (0, 2)], Jinjin hana\nhuzuni kamwe, na kazi itarejesha 0.\n- Kwa ratiba [(6, 3), (6, 2), (6, 2), (6, 3), (6, 2), (0, 3), (0, 2)], Jinjin ana huzuni sawa\nsiku ya Jumatatu na Alhamisi, lakini kwa kuwa Jumatatu inakuja kwanza, kazi inarejesha 1.",
      "tr": "Jinjin'in programına göre en mutsuz olduğu haftanın gününü hesaplayın.\n\nJinjin, bir gün içinde okulda ve ek derslerde geçirilen toplam saatler 8 saati aşarsa mutsuz olur. Fonksiyon, mutsuzluğunun en fazla olduğu günü bulur; bu, toplam saatlerin eşik değerin en çok üzerinde olduğu gündür. Eğer aynı seviyede maksimum mutsuzluk olan birden fazla gün varsa, en erken gün döndürülür. Jinjin hiçbir gün mutsuz değilse, fonksiyon 0 döndürür.\n\nArgümanlar:\nschedule (list[tuple[int, int]]): Her bir demetin haftanın her günü için okulda ve ek derslerde geçirilen saatleri temsil ettiği 7 demetlik bir liste.\n\nDöndürür:\nint: Jinjin'in en mutsuz olduğu haftanın günü (Pazartesi için 1, Pazar için 7) veya hiç mutsuz değilse 0.\n\nCases:\n- Eğer Jinjin'in programı [(5, 3), (6, 2), (7, 2), (5, 3), (5, 4), (0, 4), (0, 6)] şeklindeyse, Çarşamba günü (gün 3) en mutsuz olduğu gündür, bu yüzden fonksiyon 3 döndürecektir.\n- Eğer programı [(4, 3), (4, 3), (4, 3), (4, 3), (4, 3), (0, 3), (0, 2)] şeklindeyse, Jinjin hiçbir zaman mutsuz değildir ve fonksiyon 0 döndürecektir.\n- [(6, 3), (6, 2), (6, 2), (6, 3), (6, 2), (0, 3), (0, 2)] programı için, Jinjin Pazartesi ve Perşembe günleri eşit derecede mutsuzdur, ancak Pazartesi ilk geldiği için fonksiyon 1 döndürecektir.",
      "vi": "Tính toán ngày trong tuần khi Jinjin cảm thấy không vui nhất dựa trên lịch trình của cô ấy.\n\nJinjin cảm thấy không vui nếu tổng số giờ dành cho trường học và các lớp học thêm vượt quá 8 giờ trong một ngày. Hàm này tìm ngày mà sự không vui của cô ấy là lớn nhất, đó là ngày mà tổng số giờ vượt ngưỡng nhiều nhất. Nếu có nhiều ngày có mức độ không vui tối đa giống nhau, ngày sớm nhất sẽ được trả về. Nếu Jinjin không cảm thấy không vui vào bất kỳ ngày nào, hàm sẽ trả về 0.\n\nTham số:\nschedule (list[tuple[int, int]]): Một danh sách gồm 7 bộ giá trị, trong đó mỗi bộ giá trị đại diện cho\nsố giờ dành cho trường học và các lớp học thêm\ncho mỗi ngày trong tuần, tương ứng.\n\nTrả về:\nint: Ngày trong tuần khi Jinjin cảm thấy không vui nhất (1-7 cho Thứ Hai đến Chủ Nhật) hoặc 0\nnếu cô ấy không bao giờ cảm thấy không vui.\n\nCases:\n- Nếu Jinjin có lịch trình sau [(5, 3), (6, 2), (7, 2), (5, 3), (5, 4), (0, 4), (0, 6)],\ncô ấy cảm thấy không vui nhất vào Thứ Tư (ngày 3), vì vậy hàm sẽ trả về 3.\n- Nếu lịch trình của cô ấy là [(4, 3), (4, 3), (4, 3), (4, 3), (4, 3), (0, 3), (0, 2)], Jinjin không bao giờ\ncảm thấy không vui, và hàm sẽ trả về 0.\n- Đối với lịch trình [(6, 3), (6, 2), (6, 2), (6, 3), (6, 2), (0, 3), (0, 2)], Jinjin cảm thấy không vui\nnhư nhau vào Thứ Hai và Thứ Năm, nhưng vì Thứ Hai đến trước, hàm sẽ trả về 1."
    },
    "docstring_bertscore": {
      "es": "0.9845229193401426",
      "arb": "0.9793950774233459",
      "sw": "0.9598013821165403",
      "tr": "0.9505255419525921",
      "vi": "0.9687610027138811"
    }
  },
  {
    "task_id": "Python/43",
    "prompt": {
      "en": "from itertools import permutations\ndef next_permutation(perm: list) -> bool:\n    \"\"\"\n    Transforms the input permutation to the next permutation in lexicographic order.\n    \n    The function finds the first number from the end that is smaller than the number following it \n    and swaps it with the smallest number that is larger and comes after it. Then it reverses the \n    order of numbers after the original first smaller number. If the input is the last permutation \n    (in descending order), the function returns False, indicating no next permutation is possible.\n    \n    Args:\n    perm (list): A list of integers representing the current permutation.\n    \n    Returns:\n    bool: True if the permutation was successfully transformed, False if it was the last permutation.\n    \n    Examples:\n    >>> next_permutation([1, 2, 3])\n    True\n    >>> [1, 2, 3]\n    [1, 3, 2]\n    \n    >>> next_permutation([3, 2, 1])\n    False\n    >>> [3, 2, 1]\n    [3, 2, 1]\n    \n    >>> next_permutation([1, 3, 2])\n    True\n    >>> [1, 3, 2]\n    [2, 1, 3]\n    \"\"\"",
      "es": "from itertools import permutations\ndef next_permutation(perm: list) -> bool:\n    \"\"\"\n    Transforma la permutación de entrada en la siguiente permutación en orden lexicográfico.\n    \n    La función encuentra el primer número desde el final que es más pequeño que el número que le sigue \n    y lo intercambia con el número más pequeño que es mayor y viene después de él. Luego invierte el \n    orden de los números después del primer número más pequeño original. Si la entrada es la última permutación \n    (en orden descendente), la función devuelve False, indicando que no es posible una siguiente permutación.\n    \n    Argumentos:\n    perm (list): Una lista de enteros que representa la permutación actual.\n    \n    Devuelve:\n    bool: True si la permutación fue transformada con éxito, False si era la última permutación.\n    \n    Ejemplos:\n    >>> next_permutation([1, 2, 3])\n    True\n    >>> [1, 2, 3]\n    [1, 3, 2]\n    \n    >>> next_permutation([3, 2, 1])\n    False\n    >>> [3, 2, 1]\n    [3, 2, 1]\n    \n    >>> next_permutation([1, 3, 2])\n    True\n    >>> [1, 3, 2]\n    [2, 1, 3]\n    \"\"\"",
      "arb": "from itertools import permutations\ndef next_permutation(perm: list) -> bool:\n    \"\"\"\n    يحول ترتيب الإدخال إلى الترتيب التالي في الترتيب المعجمي.\n    \n    تجد الدالة أول رقم من النهاية يكون أصغر من الرقم الذي يليه \n    وتقوم بتبديله مع أصغر رقم يكون أكبر ويأتي بعده. ثم تعكس \n    ترتيب الأرقام بعد الرقم الأصغر الأصلي. إذا كان الإدخال هو الترتيب الأخير \n    (في ترتيب تنازلي)، فإن الدالة تعيد False، مما يشير إلى عدم إمكانية وجود ترتيب تالي.\n    \n    يعيدالحجج:\n    perm (list): قائمة من الأعداد الصحيحة تمثل الترتيب الحالي.\n    \n    يعيد:\n    bool: True إذا تم تحويل الترتيب بنجاح، False إذا كان الترتيب الأخير.\n    \n    أمثلة:\n    >>> next_permutation([1, 2, 3])\n    True\n    >>> [1, 2, 3]\n    [1, 3, 2]\n    \n    >>> next_permutation([3, 2, 1])\n    False\n    >>> [3, 2, 1]\n    [3, 2, 1]\n    \n    >>> next_permutation([1, 3, 2])\n    True\n    >>> [1, 3, 2]\n    [2, 1, 3]\n    \"\"\"",
      "sw": "from itertools import permutations\ndef next_permutation(perm: list) -> bool:\n    \"\"\"\n    Hubadilisha mpangilio wa pembejeo kuwa mpangilio unaofuata katika mpangilio wa lexicographic.\n    \n    Kazi hii inapata namba ya kwanza kutoka mwisho ambayo ni ndogo kuliko namba inayofuata \n    na kubadilisha na namba ndogo zaidi ambayo ni kubwa na inakuja baada yake. Kisha inageuza \n    mpangilio wa namba baada ya namba ya kwanza ndogo ya awali. Ikiwa pembejeo ni mpangilio wa mwisho \n    (katika mpangilio wa kushuka), kazi inarudisha False, ikionyesha hakuna mpangilio unaofuata unaowezekana.\n    \n    Hoja:\n    perm (list): Orodha ya namba nzima inayowakilisha mpangilio wa sasa.\n    \n    Inarejesha:\n    bool: True ikiwa mpangilio umebadilishwa kwa mafanikio, False ikiwa ulikuwa mpangilio wa mwisho.\n    \n    Mifano:\n    >>> next_permutation([1, 2, 3])\n    True\n    >>> [1, 2, 3]\n    [1, 3, 2]\n    \n    >>> next_permutation([3, 2, 1])\n    False\n    >>> [3, 2, 1]\n    [3, 2, 1]\n    \n    >>> next_permutation([1, 3, 2])\n    True\n    >>> [1, 3, 2]\n    [2, 1, 3]\n    \"\"\"",
      "tr": "from itertools import permutations\ndef next_permutation(perm: list) -> bool:\n    \"\"\"\n    Girdi olarak verilen permütasyonu sözlük sırasındaki bir sonraki permütasyona dönüştürür.\n    \n    Fonksiyon, sondan başlayarak kendisinden sonra gelen sayıdan daha küçük olan ilk sayıyı bulur \n    ve bunu, kendisinden sonra gelen ve daha büyük olan en küçük sayıyla değiştirir. Ardından, \n    orijinal olarak ilk daha küçük sayıdan sonraki sayıların sırasını tersine çevirir. Eğer girdi \n    son permütasyon ise (azalan sırada), fonksiyon False döndürür, bu da bir sonraki permütasyonun \n    mümkün olmadığını belirtir.\n    \n    Argümanlar:\n    perm (list): Mevcut permütasyonu temsil eden bir tamsayı listesi.\n    \n    Döndürür:\n    bool: Permütasyon başarıyla dönüştürüldüyse True, son permütasyon ise False döner.\n    \n    Örnekler:\n    >>> next_permutation([1, 2, 3])\n    True\n    >>> [1, 2, 3]\n    [1, 3, 2]\n    \n    >>> next_permutation([3, 2, 1])\n    False\n    >>> [3, 2, 1]\n    [3, 2, 1]\n    \n    >>> next_permutation([1, 3, 2])\n    True\n    >>> [1, 3, 2]\n    [2, 1, 3]\n    \"\"\"",
      "vi": "from itertools import permutations\ndef next_permutation(perm: list) -> bool:\n    \"\"\"\n    Chuyển đổi hoán vị đầu vào thành hoán vị tiếp theo theo thứ tự từ điển.\n    \n    Hàm tìm số đầu tiên từ cuối mà nhỏ hơn số theo sau nó và hoán đổi nó với số nhỏ nhất \n    mà lớn hơn và xuất hiện sau nó. Sau đó, nó đảo ngược thứ tự của các số sau số nhỏ hơn \n    ban đầu. Nếu đầu vào là hoán vị cuối cùng (theo thứ tự giảm dần), hàm trả về False, \n    chỉ ra rằng không có hoán vị tiếp theo nào khả thi.\n    \n    Tham số:\n    perm (list): Một danh sách các số nguyên đại diện cho hoán vị hiện tại.\n    \n    Trả về:\n    bool: True nếu hoán vị đã được chuyển đổi thành công, False nếu đó là hoán vị cuối cùng.\n    \n    Ví dụ:\n    >>> next_permutation([1, 2, 3])\n    True\n    >>> [1, 2, 3]\n    [1, 3, 2]\n    \n    >>> next_permutation([3, 2, 1])\n    False\n    >>> [3, 2, 1]\n    [3, 2, 1]\n    \n    >>> next_permutation([1, 3, 2])\n    True\n    >>> [1, 3, 2]\n    [2, 1, 3]\n    \"\"\""
    },
    "prompt_bertscore": {
      "es": "0.9876195669804765",
      "arb": "0.9939556775051084",
      "sw": "0.9486907931229729",
      "tr": "0.9785401722633718",
      "vi": "0.9833198151222142"
    },
    "canonical_solution": "    # Find the first (smaller) number from the end which is smaller than the number after it\n    i = len(perm) - 2\n    while i >= 0 and perm[i] >= perm[i + 1]:\n        i -= 1\n    \n    # If no such number exists, this is the last permutation\n    if i == -1:\n        return False\n    \n    # Find the first (larger) number from the end which is larger than the (smaller) number found above\n    j = len(perm) - 1\n    while perm[j] <= perm[i]:\n        j -= 1\n    \n    # Swap these two numbers\n    perm[i], perm[j] = perm[j], perm[i]\n    \n    # Reverse all the numbers after the smaller number\n    perm[i + 1:] = reversed(perm[i + 1:])\n    \n    return True",
    "instruction": {
      "en": "def next_permutation(perm: list) -> bool:\n    # Find the first (smaller) number from the end which is smaller than the number after it\n    i = len(perm) - 2\n    while i >= 0 and perm[i] >= perm[i + 1]:\n        i -= 1\n    \n    # If no such number exists, this is the last permutation\n    if i == -1:\n        return False\n    \n    # Find the first (larger) number from the end which is larger than the (smaller) number found above\n    j = len(perm) - 1\n    while perm[j] <= perm[i]:\n        j -= 1\n    \n    # Swap these two numbers\n    perm[i], perm[j] = perm[j], perm[i]\n    \n    # Reverse all the numbers after the smaller number\n    perm[i + 1:] = reversed(perm[i + 1:])\n    \n    return True\n\nProvide a concise natural language description (docstring) of the Python code in English using at most 500 characters.",
      "es": "def next_permutation(perm: list) -> bool:\n    # Find the first (smaller) number from the end which is smaller than the number after it\n    i = len(perm) - 2\n    while i >= 0 and perm[i] >= perm[i + 1]:\n        i -= 1\n    \n    # If no such number exists, this is the last permutation\n    if i == -1:\n        return False\n    \n    # Find the first (larger) number from the end which is larger than the (smaller) number found above\n    j = len(perm) - 1\n    while perm[j] <= perm[i]:\n        j -= 1\n    \n    # Swap these two numbers\n    perm[i], perm[j] = perm[j], perm[i]\n    \n    # Reverse all the numbers after the smaller number\n    perm[i + 1:] = reversed(perm[i + 1:])\n    \n    return True\n\nProporcione una descripción concisa en lenguaje natural (docstring) del código Python en español utilizando un máximo de 500 caracteres.",
      "arb": "def next_permutation(perm: list) -> bool:\n    # Find the first (smaller) number from the end which is smaller than the number after it\n    i = len(perm) - 2\n    while i >= 0 and perm[i] >= perm[i + 1]:\n        i -= 1\n    \n    # If no such number exists, this is the last permutation\n    if i == -1:\n        return False\n    \n    # Find the first (larger) number from the end which is larger than the (smaller) number found above\n    j = len(perm) - 1\n    while perm[j] <= perm[i]:\n        j -= 1\n    \n    # Swap these two numbers\n    perm[i], perm[j] = perm[j], perm[i]\n    \n    # Reverse all the numbers after the smaller number\n    perm[i + 1:] = reversed(perm[i + 1:])\n    \n    return True\n\nيرجى تقديم وصف موجز بلغة طبيعية (docstring) لشيفرة Python باللغة العربية الفصحى باستخدام 500 حرف كحد أقصى.",
      "sw": "def next_permutation(perm: list) -> bool:\n    # Find the first (smaller) number from the end which is smaller than the number after it\n    i = len(perm) - 2\n    while i >= 0 and perm[i] >= perm[i + 1]:\n        i -= 1\n    \n    # If no such number exists, this is the last permutation\n    if i == -1:\n        return False\n    \n    # Find the first (larger) number from the end which is larger than the (smaller) number found above\n    j = len(perm) - 1\n    while perm[j] <= perm[i]:\n        j -= 1\n    \n    # Swap these two numbers\n    perm[i], perm[j] = perm[j], perm[i]\n    \n    # Reverse all the numbers after the smaller number\n    perm[i + 1:] = reversed(perm[i + 1:])\n    \n    return True\n\nToa maelezo mafupi ya lugha ya asili (docstring) ya msimbo wa Python kwa Kiswahili kwa kutumia herufi zisizozidi 500.",
      "tr": "def next_permutation(perm: list) -> bool:\n    # Find the first (smaller) number from the end which is smaller than the number after it\n    i = len(perm) - 2\n    while i >= 0 and perm[i] >= perm[i + 1]:\n        i -= 1\n    \n    # If no such number exists, this is the last permutation\n    if i == -1:\n        return False\n    \n    # Find the first (larger) number from the end which is larger than the (smaller) number found above\n    j = len(perm) - 1\n    while perm[j] <= perm[i]:\n        j -= 1\n    \n    # Swap these two numbers\n    perm[i], perm[j] = perm[j], perm[i]\n    \n    # Reverse all the numbers after the smaller number\n    perm[i + 1:] = reversed(perm[i + 1:])\n    \n    return True\n\nPython kodunun işlevini açıklayan kısa bir doğal dil tanımı (docstring) sağlayın. Açıklama Türkçe olmalı ve en fazla 500 karakter kullanılmalıdır.",
      "vi": "def next_permutation(perm: list) -> bool:\n    # Find the first (smaller) number from the end which is smaller than the number after it\n    i = len(perm) - 2\n    while i >= 0 and perm[i] >= perm[i + 1]:\n        i -= 1\n    \n    # If no such number exists, this is the last permutation\n    if i == -1:\n        return False\n    \n    # Find the first (larger) number from the end which is larger than the (smaller) number found above\n    j = len(perm) - 1\n    while perm[j] <= perm[i]:\n        j -= 1\n    \n    # Swap these two numbers\n    perm[i], perm[j] = perm[j], perm[i]\n    \n    # Reverse all the numbers after the smaller number\n    perm[i + 1:] = reversed(perm[i + 1:])\n    \n    return True\n\nCung cấp mô tả ngắn gọn bằng ngôn ngữ tự nhiên (docstring) cho mã Python bằng tiếng Việt, sử dụng tối đa 500 ký tự."
    },
    "instruction_bertscore": {
      "es": "0.9687387561112052",
      "arb": "0.9156563758226796",
      "sw": "0.914896018724078",
      "tr": "0.8760401422164142",
      "vi": "0.9403930089552404"
    },
    "level": "",
    "test": "def test_next_permutation():\n    # Test case 1: ordinary case\n    perm1 = [1, 2, 3]\n    assert next_permutation(perm1) == True, \"Test case 1 failed: next_permutation([1, 2, 3]) should return True\"\n    assert perm1 == [1, 3, 2], \"Test case 1 failed: perm1 should be [1, 3, 2]\"\n    \n    # Test case 2: last permutation, should return False\n    perm2 = [3, 2, 1]\n    assert next_permutation(perm2) == False, \"Test case 2 failed: next_permutation([3, 2, 1]) should return False\"\n    assert perm2 == [3, 2, 1], \"Test case 2 failed: perm2 should be [3, 2, 1] (unchanged)\"\n    \n    # Test case 3: permutation with repeated elements\n    perm3 = [1, 5, 1]\n    assert next_permutation(perm3) == True, \"Test case 3 failed: next_permutation([1, 5, 1]) should return True\"\n    assert perm3 == [5, 1, 1], \"Test case 3 failed: perm3 should be [5, 1, 1]\"\n\n    # Test case 4: permutation with all elements equal\n    perm4 = [1, 1, 1]\n    assert next_permutation(perm4) == False, \"Test case 4 failed: next_permutation([1, 1, 1]) should return False\"\n    assert perm4 == [1, 1, 1], \"Test case 4 failed: perm4 should be [1, 1, 1] (unchanged)\"\n    \n    # Test case 5: permutation with only one element\n    perm5 = [42]\n    assert next_permutation(perm5) == False, \"Test case 5 failed: next_permutation([42]) should return False\"\n    assert perm5 == [42], \"Test case 5 failed: perm5 should be [42] (unchanged)\"\n    \n    print(\"All test cases passed.\")\n\n# Run the test function\ntest_next_permutation()",
    "entry_point": "next_permutation",
    "signature": "def next_permutation(perm: list) -> bool:",
    "docstring": {
      "en": "Transforms the input permutation to the next permutation in lexicographic order.\n\nThe function finds the first number from the end that is smaller than the number following it\nand swaps it with the smallest number that is larger and comes after it. Then it reverses the\norder of numbers after the original first smaller number. If the input is the last permutation\n(in descending order), the function returns False, indicating no next permutation is possible.\n\nArgs:\nperm (list): A list of integers representing the current permutation.\n\nReturns:\nbool: True if the permutation was successfully transformed, False if it was the last permutation.\n\nExamples:\n>>> next_permutation([1, 2, 3])\nTrue\n>>> [1, 2, 3]\n[1, 3, 2]\n\n>>> next_permutation([3, 2, 1])\nFalse\n>>> [3, 2, 1]\n[3, 2, 1]\n\n>>> next_permutation([1, 3, 2])\nTrue\n>>> [1, 3, 2]\n[2, 1, 3]",
      "es": "Transforma la permutación de entrada a la siguiente permutación en orden lexicográfico.\n\nLa función encuentra el primer número desde el final que es más pequeño que el número que lo sigue y lo intercambia con el número más pequeño que es mayor y viene después de él. Luego invierte el orden de los números después del primer número más pequeño original. Si la entrada es la última permutación (en orden descendente), la función devuelve False, indicando que no es posible una siguiente permutación.\n\nArgumentos:\nperm (list): Una lista de enteros que representa la permutación actual.\n\nDevuelve:\nbool: True si la permutación fue transformada exitosamente, False si era la última permutación.\n\nEjemplos:\n>>> next_permutation([1, 2, 3])\nTrue\n>>> [1, 2, 3]\n[1, 3, 2]\n\n>>> next_permutation([3, 2, 1])\nFalse\n>>> [3, 2, 1]\n[3, 2, 1]\n\n>>> next_permutation([1, 3, 2])\nTrue\n>>> [1, 3, 2]\n[2, 1, 3]",
      "arb": "يحوّل ترتيب الإدخال إلى الترتيب التالي في الترتيب المعجمي.\n\nتجد الدالة أول رقم من النهاية يكون أصغر من الرقم الذي يليه وتستبدله بأصغر رقم يكون أكبر ويأتي بعده. ثم تعكس ترتيب الأرقام بعد الرقم الأصغر الأصلي. إذا كان الإدخال هو الترتيب الأخير (بترتيب تنازلي)، فإن الدالة تعيد False، مما يشير إلى عدم إمكانية وجود ترتيب تالي.\n\nالمعطيات:\nperm (list): قائمة من الأعداد الصحيحة تمثل الترتيب الحالي.\n\nالقيم المعادة:\nbool: True إذا تم تحويل الترتيب بنجاح، False إذا كان الترتيب هو الأخير.\n\nأمثلة:\n>>> next_permutation([1, 2, 3])\nTrue\n>>> [1, 2, 3]\n[1, 3, 2]\n\n>>> next_permutation([3, 2, 1])\nFalse\n>>> [3, 2, 1]\n[3, 2, 1]\n\n>>> next_permutation([1, 3, 2])\nTrue\n>>> [1, 3, 2]\n[2, 1, 3]",
      "sw": "Hubadilisha mpangilio wa pembejeo kuwa mpangilio unaofuata katika mpangilio wa lexicographic.\n\nKazi hii inapata nambari ya kwanza kutoka mwisho ambayo ni ndogo kuliko nambari inayofuata\nna inabadilisha na nambari ndogo zaidi ambayo ni kubwa na inakuja baada yake. Kisha inageuza\nmpangilio wa nambari baada ya nambari ya kwanza ndogo ya awali. Ikiwa pembejeo ni mpangilio wa mwisho\n(katika mpangilio wa kushuka), kazi inarudisha False, ikiashiria hakuna mpangilio unaofuata unaowezekana.\n\nHoja:\nperm (list): Orodha ya nambari za mzima zinazowakilisha mpangilio wa sasa.\n\nInarejesha:\nbool: True ikiwa mpangilio umebadilishwa kwa mafanikio, False ikiwa ulikuwa mpangilio wa mwisho.\n\nMifano:\n>>> next_permutation([1, 2, 3])\nTrue\n>>> [1, 2, 3]\n[1, 3, 2]\n\n>>> next_permutation([3, 2, 1])\nFalse\n>>> [3, 2, 1]\n[3, 2, 1]\n\n>>> next_permutation([1, 3, 2])\nTrue\n>>> [1, 3, 2]\n[2, 1, 3]",
      "tr": "Girdi permütasyonunu sözlükbilimsel sırada bir sonraki permütasyona dönüştürür.\n\nFonksiyon, sondan başlayarak kendisinden sonra gelen sayıdan daha küçük olan ilk sayıyı bulur ve bunu, kendisinden sonra gelen en küçük ve daha büyük sayı ile değiştirir. Daha sonra, orijinal ilk küçük sayıdan sonraki sayıların sırasını tersine çevirir. Eğer girdi, son permütasyon ise (azalan sırada), fonksiyon bir sonraki permütasyonun mümkün olmadığını belirten False değerini döndürür.\n\nArgümanlar:\nperm (list): Mevcut permütasyonu temsil eden bir tamsayı listesi.\n\nDöndürür:\nbool: Permütasyon başarıyla dönüştürüldüyse True, son permütasyon ise False.\n\nÖrnekler:\n>>> next_permutation([1, 2, 3])\nTrue\n>>> [1, 2, 3]\n[1, 3, 2]\n\n>>> next_permutation([3, 2, 1])\nFalse\n>>> [3, 2, 1]\n[3, 2, 1]\n\n>>> next_permutation([1, 3, 2])\nTrue\n>>> [1, 3, 2]\n[2, 1, 3]",
      "vi": "Chuyển đổi hoán vị đầu vào thành hoán vị tiếp theo theo thứ tự từ điển.\n\nHàm tìm số đầu tiên từ cuối mà nhỏ hơn số theo sau nó và hoán đổi nó với số nhỏ nhất mà lớn hơn và xuất hiện sau nó. Sau đó, nó đảo ngược thứ tự các số sau số nhỏ hơn đầu tiên ban đầu. Nếu đầu vào là hoán vị cuối cùng (theo thứ tự giảm dần), hàm trả về False, cho biết không có hoán vị tiếp theo nào khả thi.\n\nTham số:\nperm (list): Một danh sách các số nguyên đại diện cho hoán vị hiện tại.\n\nTrả về:\nbool: True nếu hoán vị đã được chuyển đổi thành công, False nếu đó là hoán vị cuối cùng.\n\nVí dụ:\n>>> next_permutation([1, 2, 3])\nTrue\n>>> [1, 2, 3]\n[1, 3, 2]\n\n>>> next_permutation([3, 2, 1])\nFalse\n>>> [3, 2, 1]\n[3, 2, 1]\n\n>>> next_permutation([1, 3, 2])\nTrue\n>>> [1, 3, 2]\n[2, 1, 3]"
    },
    "docstring_bertscore": {
      "es": "0.9774467120157747",
      "arb": "0.9450562544107964",
      "sw": "0.9418054695947795",
      "tr": "0.9808832162380593",
      "vi": "0.9714681361770056"
    }
  },
  {
    "task_id": "Python/44",
    "prompt": {
      "en": "from typing import List\ndef jinjin_savings_plan(budgets: List[int]) -> int:\n    \"\"\"\n    Calculates the total amount of money Jinjin will have by the end of the year\n    after following her savings plan with her mother. Each month, she can save\n    multiples of 100 from her pocket money (300 per month) if she predicts having\n    at least 100 units remaining after expenses. The saved money will gain 20%\n    interest at the end of the year.\n\n    Parameters:\n    budgets (List[int]): A list of 12 integers representing Jinjin's monthly budget.\n\n    Returns:\n    int: The total amount of money Jinjin will have at the end of the year after interest.\n         If Jinjin runs out of money in any given month, returns the negative value of\n         that month (-X, where X is the month number).\n\n    Examples:\n    >>> jinjin_savings_plan([290, 230, 280, 200, 300, 170, 340, 50, 90, 80, 200, 60])\n    -7  # Jinjin runs out of money in July (the 7th month)\n    \n    >>> jinjin_savings_plan([290, 230, 280, 200, 300, 170, 330, 50, 90, 80, 200, 60])\n    1580  # Jinjin has 1580 units of currency by the end of the year\n    \"\"\"",
      "es": "from typing import List\ndef jinjin_savings_plan(budgets: List[int]) -> int:\n    \"\"\"\n    Calcula la cantidad total de dinero que Jinjin tendrá al final del año\n    después de seguir su plan de ahorros con su madre. Cada mes, puede ahorrar\n    múltiplos de 100 de su dinero de bolsillo (300 por mes) si predice tener\n    al menos 100 unidades restantes después de los gastos. El dinero ahorrado ganará un 20%\n    de interés al final del año.\n\n    Parámetros:\n    budgets (List[int]): Una lista de 12 enteros que representan el presupuesto mensual de Jinjin.\n\n    Devuelve:\n    int: La cantidad total de dinero que Jinjin tendrá al final del año después de los intereses.\n         Si Jinjin se queda sin dinero en cualquier mes, devuelve el valor negativo de\n         ese mes (-X, donde X es el número del mes).\n\n    Ejemplos:\n    >>> jinjin_savings_plan([290, 230, 280, 200, 300, 170, 340, 50, 90, 80, 200, 60])\n    -7  # Jinjin se queda sin dinero en julio (el 7º mes)\n    \n    >>> jinjin_savings_plan([290, 230, 280, 200, 300, 170, 330, 50, 90, 80, 200, 60])\n    1580  # Jinjin tiene 1580 unidades de moneda al final del año\n    \"\"\"",
      "arb": "from typing import List\ndef jinjin_savings_plan(budgets: List[int]) -> int:\n    \"\"\"\n    يحسب إجمالي المبلغ الذي ستحصل عليه جينجين بحلول نهاية العام\n    بعد اتباع خطة التوفير مع والدتها. كل شهر، يمكنها توفير\n    مضاعفات 100 من مصروفها الشهري (300 شهريًا) إذا توقعت أن يكون لديها\n    على الأقل 100 وحدة متبقية بعد النفقات. سيتم كسب المال المدخر فائدة بنسبة 20%\n    في نهاية العام.\n\n    المعلمات:\n    budgets (List[int]): قائمة تحتوي على 12 عددًا صحيحًا تمثل ميزانية جينجين الشهرية.\n\n    العوائد:\n    int: إجمالي المبلغ الذي ستحصل عليه جينجين في نهاية العام بعد الفائدة.\n         إذا نفدت أموال جينجين في أي شهر معين، يتم إرجاع القيمة السالبة\n         لذلك الشهر (-X، حيث X هو رقم الشهر).\n\n    أمثلة:\n    >>> jinjin_savings_plan([290, 230, 280, 200, 300, 170, 340, 50, 90, 80, 200, 60])\n    -7  # نفدت أموال جينجين في يوليو (الشهر السابع)\n    \n    >>> jinjin_savings_plan([290, 230, 280, 200, 300, 170, 330, 50, 90, 80, 200, 60])\n    1580  # جينجين لديها 1580 وحدة من العملة بحلول نهاية العام\n    \"\"\"",
      "sw": "from typing import List\ndef jinjin_savings_plan(budgets: List[int]) -> int:\n    \"\"\"\n    Inahesabu jumla ya pesa ambazo Jinjin atakuwa nazo mwishoni mwa mwaka\n    baada ya kufuata mpango wake wa akiba na mama yake. Kila mwezi, anaweza kuweka\n    akiba ya mara 100 kutoka kwenye pesa zake za mfukoni (300 kwa mwezi) ikiwa anatarajia kubaki\n    na angalau vitengo 100 baada ya matumizi. Pesa zilizowekwa akiba zitapata riba ya 20%\n    mwishoni mwa mwaka.\n\n    Vigezo:\n    budgets (List[int]): Orodha ya namba 12 zinazowakilisha bajeti ya kila mwezi ya Jinjin.\n\n    Inarudisha:\n    int: Jumla ya pesa ambazo Jinjin atakuwa nazo mwishoni mwa mwaka baada ya riba.\n         Ikiwa Jinjin anaishiwa na pesa katika mwezi wowote, inarudisha thamani hasi ya\n         mwezi huo (-X, ambapo X ni namba ya mwezi).\n\n    Mifano:\n    >>> jinjin_savings_plan([290, 230, 280, 200, 300, 170, 340, 50, 90, 80, 200, 60])\n    -7  # Jinjin anaishiwa na pesa mwezi wa Julai (mwezi wa 7)\n    \n    >>> jinjin_savings_plan([290, 230, 280, 200, 300, 170, 330, 50, 90, 80, 200, 60])\n    1580  # Jinjin ana vitengo 1580 vya sarafu mwishoni mwa mwaka\n    \"\"\"",
      "tr": "from typing import List\ndef jinjin_savings_plan(budgets: List[int]) -> int:\n    \"\"\"\n    Jinjin'in annesiyle birlikte tasarruf planını takip ettikten sonra yıl sonunda\n    sahip olacağı toplam para miktarını hesaplar. Her ay, harcamalardan sonra en az\n    100 birim kalacağını tahmin ederse, cep harçlığından (ayda 300) 100'ün katları\n    kadar tasarruf edebilir. Biriktirilen para yıl sonunda %20 faiz kazanacaktır.\n\n    Parametreler:\n    budgets (List[int]): Jinjin'in aylık bütçesini temsil eden 12 tam sayıdan oluşan bir liste.\n\n    Dönüş:\n    int: Jinjin'in yıl sonunda faizle birlikte sahip olacağı toplam para miktarı.\n         Eğer Jinjin herhangi bir ayda parası biterse, o ayın negatif değeri döner (-X, burada X ay numarasıdır).\n\n    Örnekler:\n    >>> jinjin_savings_plan([290, 230, 280, 200, 300, 170, 340, 50, 90, 80, 200, 60])\n    -7  # Jinjin Temmuz ayında (7. ay) parası bitiyor\n    \n    >>> jinjin_savings_plan([290, 230, 280, 200, 300, 170, 330, 50, 90, 80, 200, 60])\n    1580  # Jinjin yıl sonunda 1580 birim para birimine sahip oluyor\n    \"\"\"",
      "vi": "from typing import List\ndef jinjin_savings_plan(budgets: List[int]) -> int:\n    \"\"\"\n    Tính tổng số tiền mà Jinjin sẽ có vào cuối năm\n    sau khi thực hiện kế hoạch tiết kiệm với mẹ của cô ấy. Mỗi tháng, cô ấy có thể tiết kiệm\n    bội số của 100 từ tiền tiêu vặt của mình (300 mỗi tháng) nếu cô ấy dự đoán còn lại\n    ít nhất 100 đơn vị sau khi chi tiêu. Số tiền tiết kiệm sẽ được hưởng lãi suất 20%\n    vào cuối năm.\n\n    Tham số:\n    budgets (List[int]): Danh sách gồm 12 số nguyên đại diện cho ngân sách hàng tháng của Jinjin.\n\n    Trả về:\n    int: Tổng số tiền mà Jinjin sẽ có vào cuối năm sau khi tính lãi.\n         Nếu Jinjin hết tiền trong bất kỳ tháng nào, trả về giá trị âm của\n         tháng đó (-X, trong đó X là số tháng).\n\n    Ví dụ:\n    >>> jinjin_savings_plan([290, 230, 280, 200, 300, 170, 340, 50, 90, 80, 200, 60])\n    -7  # Jinjin hết tiền vào tháng 7 (tháng thứ 7)\n    \n    >>> jinjin_savings_plan([290, 230, 280, 200, 300, 170, 330, 50, 90, 80, 200, 60])\n    1580  # Jinjin có 1580 đơn vị tiền tệ vào cuối năm\n    \"\"\""
    },
    "prompt_bertscore": {
      "es": "0.990896372376409",
      "arb": "0.9702511278324047",
      "sw": "0.9735760017805478",
      "tr": "0.9708400669121733",
      "vi": "0.9726525691391166"
    },
    "canonical_solution": "    money_in_hand = 0\n    money_saved = 0\n    \n    for month, budget in enumerate(budgets, start=1):\n        money_in_hand += 300  # Jinjin receives 300 from her mother\n        if money_in_hand < budget:\n            return -month  # Not enough money for the month's budget\n        \n        money_in_hand -= budget  # Pay the month's expenses\n        # Save the whole hundreds with mom and keep the rest\n        hundreds = money_in_hand // 100 * 100\n        money_saved += hundreds\n        money_in_hand -= hundreds\n    \n    # Calculate the total amount after receiving the 20% interest from mom\n    total_money = money_in_hand + int(money_saved * 1.2)\n    return total_money",
    "instruction": {
      "en": "def jinjin_savings_plan(budgets: List[int]) -> int:\n    money_in_hand = 0\n    money_saved = 0\n    \n    for month, budget in enumerate(budgets, start=1):\n        money_in_hand += 300  # Jinjin receives 300 from her mother\n        if money_in_hand < budget:\n            return -month  # Not enough money for the month's budget\n        \n        money_in_hand -= budget  # Pay the month's expenses\n        # Save the whole hundreds with mom and keep the rest\n        hundreds = money_in_hand // 100 * 100\n        money_saved += hundreds\n        money_in_hand -= hundreds\n    \n    # Calculate the total amount after receiving the 20% interest from mom\n    total_money = money_in_hand + int(money_saved * 1.2)\n    return total_money\n\nProvide a concise natural language description (docstring) of the Python code in English using at most 500 characters.",
      "es": "def jinjin_savings_plan(budgets: List[int]) -> int:\n    money_in_hand = 0\n    money_saved = 0\n    \n    for month, budget in enumerate(budgets, start=1):\n        money_in_hand += 300  # Jinjin receives 300 from her mother\n        if money_in_hand < budget:\n            return -month  # Not enough money for the month's budget\n        \n        money_in_hand -= budget  # Pay the month's expenses\n        # Save the whole hundreds with mom and keep the rest\n        hundreds = money_in_hand // 100 * 100\n        money_saved += hundreds\n        money_in_hand -= hundreds\n    \n    # Calculate the total amount after receiving the 20% interest from mom\n    total_money = money_in_hand + int(money_saved * 1.2)\n    return total_money\n\nProporcione una descripción concisa en lenguaje natural (docstring) del código Python en español utilizando un máximo de 500 caracteres.",
      "arb": "def jinjin_savings_plan(budgets: List[int]) -> int:\n    money_in_hand = 0\n    money_saved = 0\n    \n    for month, budget in enumerate(budgets, start=1):\n        money_in_hand += 300  # Jinjin receives 300 from her mother\n        if money_in_hand < budget:\n            return -month  # Not enough money for the month's budget\n        \n        money_in_hand -= budget  # Pay the month's expenses\n        # Save the whole hundreds with mom and keep the rest\n        hundreds = money_in_hand // 100 * 100\n        money_saved += hundreds\n        money_in_hand -= hundreds\n    \n    # Calculate the total amount after receiving the 20% interest from mom\n    total_money = money_in_hand + int(money_saved * 1.2)\n    return total_money\n\nيرجى تقديم وصف موجز بلغة طبيعية (docstring) للكود البرمجي بلغة بايثون باللغة العربية الفصحى باستخدام 500 حرف كحد أقصى.",
      "sw": "def jinjin_savings_plan(budgets: List[int]) -> int:\n    money_in_hand = 0\n    money_saved = 0\n    \n    for month, budget in enumerate(budgets, start=1):\n        money_in_hand += 300  # Jinjin receives 300 from her mother\n        if money_in_hand < budget:\n            return -month  # Not enough money for the month's budget\n        \n        money_in_hand -= budget  # Pay the month's expenses\n        # Save the whole hundreds with mom and keep the rest\n        hundreds = money_in_hand // 100 * 100\n        money_saved += hundreds\n        money_in_hand -= hundreds\n    \n    # Calculate the total amount after receiving the 20% interest from mom\n    total_money = money_in_hand + int(money_saved * 1.2)\n    return total_money\n\nToa maelezo mafupi ya lugha asilia (docstring) ya msimbo wa Python kwa Kiswahili kwa kutumia herufi zisizozidi 500.",
      "tr": "def jinjin_savings_plan(budgets: List[int]) -> int:\n    money_in_hand = 0\n    money_saved = 0\n    \n    for month, budget in enumerate(budgets, start=1):\n        money_in_hand += 300  # Jinjin receives 300 from her mother\n        if money_in_hand < budget:\n            return -month  # Not enough money for the month's budget\n        \n        money_in_hand -= budget  # Pay the month's expenses\n        # Save the whole hundreds with mom and keep the rest\n        hundreds = money_in_hand // 100 * 100\n        money_saved += hundreds\n        money_in_hand -= hundreds\n    \n    # Calculate the total amount after receiving the 20% interest from mom\n    total_money = money_in_hand + int(money_saved * 1.2)\n    return total_money\n\nVerilen Python kodunun işlevini açıklayan, en fazla 500 karakter uzunluğunda, özlü bir doğal dil açıklaması (docstring) sağlayın.",
      "vi": "def jinjin_savings_plan(budgets: List[int]) -> int:\n    money_in_hand = 0\n    money_saved = 0\n    \n    for month, budget in enumerate(budgets, start=1):\n        money_in_hand += 300  # Jinjin receives 300 from her mother\n        if money_in_hand < budget:\n            return -month  # Not enough money for the month's budget\n        \n        money_in_hand -= budget  # Pay the month's expenses\n        # Save the whole hundreds with mom and keep the rest\n        hundreds = money_in_hand // 100 * 100\n        money_saved += hundreds\n        money_in_hand -= hundreds\n    \n    # Calculate the total amount after receiving the 20% interest from mom\n    total_money = money_in_hand + int(money_saved * 1.2)\n    return total_money\n\nCung cấp mô tả ngắn gọn bằng ngôn ngữ tự nhiên (docstring) cho mã Python bằng tiếng Việt, không quá 500 ký tự."
    },
    "instruction_bertscore": {
      "es": "0.9687387561112052",
      "arb": "0.924699818440817",
      "sw": "0.9426438884331277",
      "tr": "0.8508820154152974",
      "vi": "0.905718500598742"
    },
    "level": "",
    "test": "def test_jinjin_savings_plan():\n    # Test case 1: Jinjin runs out of money in July (the 7th month)\n    budgets1 = [290, 230, 280, 200, 300, 170, 340, 50, 90, 80, 200, 60]\n    assert jinjin_savings_plan(budgets1) == -7, \"Test case 1 failed\"\n\n    # Test case 2: Jinjin has 1580 units of currency by the end of the year\n    budgets2 = [290, 230, 280, 200, 300, 170, 330, 50, 90, 80, 200, 60]\n    assert jinjin_savings_plan(budgets2) == 1580, \"Test case 2 failed\"\n\n    # Test case 3: Jinjin manages her budget perfectly and has a specific amount by the end\n    budgets3 = [300, 300, 300, 300, 300, 300, 300, 300, 300, 300, 300, 300]\n    assert jinjin_savings_plan(budgets3) == 0, \"Test case 3 failed\"\n\n    # Test case 4: Jinjin does not need to save any money and spends exactly the amount she receives\n    budgets4 = [300, 290, 280, 270, 260, 250, 240, 230, 220, 210, 200, 190]\n    assert jinjin_savings_plan(budgets4) == 780, \"Test case 4 failed\"\n\n    # Test case 5: Jinjin runs out of money in the first month\n    budgets5 = [350, 200, 200, 200, 200, 200, 200, 200, 200, 200, 200, 200]\n    assert jinjin_savings_plan(budgets5) == -1, \"Test case 5 failed\"\n\n    print(\"All test cases passed.\")\n\n\n# Run the test function\ntest_jinjin_savings_plan()",
    "entry_point": "jinjin_savings_plan",
    "signature": "def jinjin_savings_plan(budgets: List[int]) -> int:",
    "docstring": {
      "en": "Calculates the total amount of money Jinjin will have by the end of the year\nafter following her savings plan with her mother. Each month, she can save\nmultiples of 100 from her pocket money (300 per month) if she predicts having\nat least 100 units remaining after expenses. The saved money will gain 20%\ninterest at the end of the year.\n\nParameters:\nbudgets (List[int]): A list of 12 integers representing Jinjin's monthly budget.\n\nReturns:\nint: The total amount of money Jinjin will have at the end of the year after interest.\nIf Jinjin runs out of money in any given month, returns the negative value of\nthat month (-X, where X is the month number).\n\nExamples:\n>>> jinjin_savings_plan([290, 230, 280, 200, 300, 170, 340, 50, 90, 80, 200, 60])\n-7  # Jinjin runs out of money in July (the 7th month)\n\n>>> jinjin_savings_plan([290, 230, 280, 200, 300, 170, 330, 50, 90, 80, 200, 60])\n1580  # Jinjin has 1580 units of currency by the end of the year",
      "es": "Calcula la cantidad total de dinero que Jinjin tendrá al final del año después de seguir su plan de ahorro con su madre. Cada mes, puede ahorrar múltiplos de 100 de su dinero de bolsillo (300 por mes) si predice tener al menos 100 unidades restantes después de los gastos. El dinero ahorrado ganará un 20% de interés al final del año.\n\nParámetros:\nbudgets (List[int]): Una lista de 12 enteros que representa el presupuesto mensual de Jinjin.\n\nDevuelve:\nint: La cantidad total de dinero que Jinjin tendrá al final del año después de los intereses. Si Jinjin se queda sin dinero en cualquier mes, devuelve el valor negativo de ese mes (-X, donde X es el número del mes).\n\nEjemplos:\n>>> jinjin_savings_plan([290, 230, 280, 200, 300, 170, 340, 50, 90, 80, 200, 60])\n-7  # Jinjin se queda sin dinero en julio (el 7º mes)\n\n>>> jinjin_savings_plan([290, 230, 280, 200, 300, 170, 330, 50, 90, 80, 200, 60])\n1580  # Jinjin tiene 1580 unidades de moneda al final del año",
      "arb": "يحسب إجمالي المبلغ الذي ستحصل عليه جينجين بنهاية العام بعد اتباع خطة التوفير مع والدتها. في كل شهر، يمكنها توفير مضاعفات 100 من مصروفها الشخصي (300 شهريًا) إذا توقعت بقاء ما لا يقل عن 100 وحدة بعد النفقات. ستكسب الأموال المدخرة فائدة بنسبة 20% في نهاية العام.\n\nالمعطيات:\nbudgets (List[int]): قائمة مكونة من 12 عددًا صحيحًا تمثل الميزانية الشهرية لجينجين.\n\nالقيم المعادة:\nint: إجمالي المبلغ الذي ستحصل عليه جينجين في نهاية العام بعد الفائدة. إذا نفدت أموال جينجين في أي شهر، يتم إرجاع القيمة السالبة لذلك الشهر (-X، حيث X هو رقم الشهر).\n\nأمثلة:\n>>> jinjin_savings_plan([290, 230, 280, 200, 300, 170, 340, 50, 90, 80, 200, 60])\n-7  # نفدت أموال جينجين في يوليو (الشهر السابع)\n\n>>> jinjin_savings_plan([290, 230, 280, 200, 300, 170, 330, 50, 90, 80, 200, 60])\n1580  # تمتلك جينجين 1580 وحدة نقدية بنهاية العام",
      "sw": "Hesabu jumla ya pesa ambazo Jinjin atakuwa nazo mwishoni mwa mwaka baada ya kufuata mpango wake wa akiba na mama yake. Kila mwezi, anaweza kuweka akiba ya mara 100 kutoka kwa pesa zake za mfukoni (300 kwa mwezi) ikiwa anatarajia kubaki na angalau vitengo 100 baada ya matumizi. Pesa zilizowekwa akiba zitapata riba ya 20% mwishoni mwa mwaka.\n\nVigezo:\nbudgets (List[int]): Orodha ya namba 12 zinazowakilisha bajeti ya kila mwezi ya Jinjin.\n\nInarejesha:\nint: Jumla ya pesa ambazo Jinjin atakuwa nazo mwishoni mwa mwaka baada ya riba. Ikiwa Jinjin atamaliza pesa katika mwezi wowote, inarejesha thamani hasi ya mwezi huo (-X, ambapo X ni namba ya mwezi).\n\nMifano:\n>>> jinjin_savings_plan([290, 230, 280, 200, 300, 170, 340, 50, 90, 80, 200, 60])\n-7  # Jinjin anakosa pesa mwezi wa Julai (mwezi wa 7)\n\n>>> jinjin_savings_plan([290, 230, 280, 200, 300, 170, 330, 50, 90, 80, 200, 60])\n1580  # Jinjin ana vitengo 1580 vya fedha mwishoni mwa mwaka",
      "tr": "Yıl sonunda Jinjin'in annesiyle yaptığı tasarruf planını takip ettikten sonra sahip olacağı toplam para miktarını hesaplar. Her ay, masraflardan sonra en az 100 birim kalacağını tahmin ederse, cep harçlığından (ayda 300) 100'ün katları kadar tasarruf edebilir. Biriktirilen para yıl sonunda %20 faiz kazanacaktır.\n\nParametreler:\nbudgets (List[int]): Jinjin'in aylık bütçesini temsil eden 12 tam sayıdan oluşan bir liste.\n\nDöndürülen:\nint: Jinjin'in yıl sonunda faiziyle birlikte sahip olacağı toplam para miktarı.\nEğer Jinjin herhangi bir ayda parasız kalırsa, o ayın negatif değerini döndürür (-X, burada X ay numarasıdır).\n\nÖrnekler:\n>>> jinjin_savings_plan([290, 230, 280, 200, 300, 170, 340, 50, 90, 80, 200, 60])\n-7  # Jinjin Temmuz ayında (7. ay) parasız kalıyor\n\n>>> jinjin_savings_plan([290, 230, 280, 200, 300, 170, 330, 50, 90, 80, 200, 60])\n1580  # Jinjin yıl sonunda 1580 birim para birimine sahip",
      "vi": "Tính tổng số tiền mà Jinjin sẽ có vào cuối năm sau khi thực hiện kế hoạch tiết kiệm với mẹ của cô ấy. Mỗi tháng, cô ấy có thể tiết kiệm bội số của 100 từ tiền tiêu vặt của mình (300 mỗi tháng) nếu cô ấy dự đoán còn ít nhất 100 đơn vị sau khi chi tiêu. Số tiền tiết kiệm sẽ nhận được lãi suất 20% vào cuối năm.\n\nTham số:\nbudgets (List[int]): Một danh sách gồm 12 số nguyên đại diện cho ngân sách hàng tháng của Jinjin.\n\nTrả về:\nint: Tổng số tiền mà Jinjin sẽ có vào cuối năm sau khi tính lãi. Nếu Jinjin hết tiền trong bất kỳ tháng nào, trả về giá trị âm của tháng đó (-X, trong đó X là số tháng).\n\nVí dụ:\n>>> jinjin_savings_plan([290, 230, 280, 200, 300, 170, 340, 50, 90, 80, 200, 60])\n-7  # Jinjin hết tiền vào tháng 7 (tháng thứ 7)\n\n>>> jinjin_savings_plan([290, 230, 280, 200, 300, 170, 330, 50, 90, 80, 200, 60])\n1580  # Jinjin có 1580 đơn vị tiền tệ vào cuối năm"
    },
    "docstring_bertscore": {
      "es": "0.9893039526116523",
      "arb": "0.9628823379567725",
      "sw": "0.9693783459381375",
      "tr": "0.9626431869780065",
      "vi": "0.9630527628237004"
    }
  },
  {
    "task_id": "Python/45",
    "prompt": {
      "en": "import heapq\nfrom typing import List \n\ndef minimum_cost_to_merge_fruits(fruit_counts: List[int]) -> int:\n    \"\"\"\n    Calculates the minimum total cost to merge multiple heaps of fruits into a single heap.\n    The cost of merging two heaps is equal to the sum of their weights. The function utilizes\n    a greedy algorithm with a min-heap (priority queue) to ensure the smallest heaps are merged first,\n    minimizing the total cost.\n\n    Parameters:\n    fruit_counts (List[int]): A list of integers representing the counts of each type of fruit.\n\n    Returns:\n    int: The minimum total cost required to merge all heaps of fruits.\n\n    Examples:\n    >>> minimum_cost_to_merge_fruits([1, 2, 9])\n    15  # Merging (1+2) with a cost of 3, and then (3+9) with a cost of 12, gives a total cost of 15.\n\n    >>> minimum_cost_to_merge_fruits([5, 5])\n    10  # Merging (5+5) with a total cost of 10.\n\n    >>> minimum_cost_to_merge_fruits([10, 20, 30, 40, 50])\n    300 # One optimal way is merging 10+20 (cost 30), then merging 30+30 (cost 60),\n        # followed by 40+50 (cost 90), and finally merging the two remaining heaps 60+90 (cost 150).\n        # Total cost is 30+60+90+150 = 300.\n    \"\"\"",
      "es": "import heapq\nfrom typing import List \n\ndef minimum_cost_to_merge_fruits(fruit_counts: List[int]) -> int:\n    \"\"\"\n    Calcula el costo total mínimo para fusionar múltiples montones de frutas en un solo montón.\n    El costo de fusionar dos montones es igual a la suma de sus pesos. La función utiliza\n    un algoritmo codicioso con un montón mínimo (cola de prioridad) para asegurar que los montones más pequeños se fusionen primero,\n    minimizando el costo total.\n\n    Parámetros:\n    fruit_counts (List[int]): Una lista de enteros que representa las cantidades de cada tipo de fruta.\n\n    Devuelve:\n    int: El costo total mínimo requerido para fusionar todos los montones de frutas.\n\n    Ejemplos:\n    >>> minimum_cost_to_merge_fruits([1, 2, 9])\n    15  # Fusionar (1+2) con un costo de 3, y luego (3+9) con un costo de 12, da un costo total de 15.\n\n    >>> minimum_cost_to_merge_fruits([5, 5])\n    10  # Fusionar (5+5) con un costo total de 10.\n\n    >>> minimum_cost_to_merge_fruits([10, 20, 30, 40, 50])\n    300 # Una forma óptima es fusionar 10+20 (costo 30), luego fusionar 30+30 (costo 60),\n        # seguido de 40+50 (costo 90), y finalmente fusionar los dos montones restantes 60+90 (costo 150).\n        # El costo total es 30+60+90+150 = 300.\n    \"\"\"",
      "arb": "import heapq\nfrom typing import List \n\ndef minimum_cost_to_merge_fruits(fruit_counts: List[int]) -> int:\n    \"\"\"\n    يحسب الحد الأدنى للتكلفة الإجمالية لدمج أكوام متعددة من الفواكه في كومة واحدة.\n    تكلفة دمج كومتين تساوي مجموع أوزانهما. تستخدم الدالة خوارزمية جشعة مع كومة ذات أولوية (طابور ذو أولوية)\n    لضمان دمج أصغر الأكوام أولاً، مما يقلل من التكلفة الإجمالية.\n\n    المعاملات:\n    fruit_counts (List[int]): قائمة من الأعداد الصحيحة تمثل عدد كل نوع من الفاكهة.\n\n    العوائد:\n    int: الحد الأدنى للتكلفة الإجمالية المطلوبة لدمج جميع أكوام الفواكه.\n\n    أمثلة:\n    >>> minimum_cost_to_merge_fruits([1, 2, 9])\n    15  # دمج (1+2) بتكلفة 3، ثم (3+9) بتكلفة 12، يعطي تكلفة إجمالية قدرها 15.\n\n    >>> minimum_cost_to_merge_fruits([5, 5])\n    10  # دمج (5+5) بتكلفة إجمالية قدرها 10.\n\n    >>> minimum_cost_to_merge_fruits([10, 20, 30, 40, 50])\n    300 # إحدى الطرق المثلى هي دمج 10+20 (بتكلفة 30)، ثم دمج 30+30 (بتكلفة 60)،\n        # يليها دمج 40+50 (بتكلفة 90)، وأخيراً دمج الكومتين المتبقيتين 60+90 (بتكلفة 150).\n        # التكلفة الإجمالية هي 30+60+90+150 = 300.\n    \"\"\"",
      "sw": "import heapq\nfrom typing import List \n\ndef minimum_cost_to_merge_fruits(fruit_counts: List[int]) -> int:\n    \"\"\"\n    Inakokotoa gharama ndogo kabisa ya jumla ya kuunganisha marundo mengi ya matunda kuwa rundo moja.\n    Gharama ya kuunganisha marundo mawili ni sawa na jumla ya uzito wao. Kazi hii inatumia\n    algorithimu ya pupa na min-heap (foleni ya kipaumbele) kuhakikisha marundo madogo yanaunganishwa kwanza,\n    kupunguza gharama ya jumla.\n\n    Vigezo:\n    fruit_counts (List[int]): Orodha ya namba zinazowakilisha idadi ya kila aina ya matunda.\n\n    Inarudisha:\n    int: Gharama ndogo kabisa ya jumla inayohitajika kuunganisha marundo yote ya matunda.\n\n    Mifano:\n    >>> minimum_cost_to_merge_fruits([1, 2, 9])\n    15  # Kuunganisha (1+2) kwa gharama ya 3, na kisha (3+9) kwa gharama ya 12, inatoa gharama ya jumla ya 15.\n\n    >>> minimum_cost_to_merge_fruits([5, 5])\n    10  # Kuunganisha (5+5) kwa gharama ya jumla ya 10.\n\n    >>> minimum_cost_to_merge_fruits([10, 20, 30, 40, 50])\n    300 # Njia moja bora ni kuunganisha 10+20 (gharama 30), kisha kuunganisha 30+30 (gharama 60),\n        # ikifuatiwa na 40+50 (gharama 90), na hatimaye kuunganisha marundo mawili yaliyobaki 60+90 (gharama 150).\n        # Gharama ya jumla ni 30+60+90+150 = 300.\n    \"\"\"",
      "tr": "import heapq\nfrom typing import List \n\ndef minimum_cost_to_merge_fruits(fruit_counts: List[int]) -> int:\n    \"\"\"\n    Birden fazla meyve yığınını tek bir yığın halinde birleştirmek için minimum toplam maliyeti hesaplar.\n    İki yığını birleştirmenin maliyeti, ağırlıklarının toplamına eşittir. Fonksiyon, en küçük yığınların\n    önce birleştirilmesini sağlamak için bir min-heap (öncelik kuyruğu) ile açgözlü bir algoritma kullanır,\n    böylece toplam maliyet en aza indirilir.\n\n    Parametreler:\n    fruit_counts (List[int]): Her bir meyve türünün sayısını temsil eden bir tamsayı listesi.\n\n    Döndürür:\n    int: Tüm meyve yığınlarını birleştirmek için gereken minimum toplam maliyet.\n\n    Örnekler:\n    >>> minimum_cost_to_merge_fruits([1, 2, 9])\n    15  # (1+2) yığınını 3 maliyetle birleştirip, ardından (3+9) yığınını 12 maliyetle birleştirerek toplamda 15 maliyet elde edilir.\n\n    >>> minimum_cost_to_merge_fruits([5, 5])\n    10  # (5+5) yığınını toplam 10 maliyetle birleştirir.\n\n    >>> minimum_cost_to_merge_fruits([10, 20, 30, 40, 50])\n    300 # Bir optimal yol, 10+20'yi (maliyet 30) birleştirmek, ardından 30+30'u (maliyet 60) birleştirmek,\n        # sonra 40+50'yi (maliyet 90) ve son olarak kalan iki yığını 60+90'ı (maliyet 150) birleştirmektir.\n        # Toplam maliyet 30+60+90+150 = 300'dür.\n    \"\"\"",
      "vi": "import heapq\nfrom typing import List \n\ndef minimum_cost_to_merge_fruits(fruit_counts: List[int]) -> int:\n    \"\"\"\n    Tính toán tổng chi phí tối thiểu để gộp nhiều đống trái cây thành một đống duy nhất.\n    Chi phí gộp hai đống bằng tổng trọng lượng của chúng. Hàm sử dụng\n    thuật toán tham lam với một heap nhỏ nhất (hàng đợi ưu tiên) để đảm bảo các đống nhỏ nhất được gộp trước,\n    giảm thiểu tổng chi phí.\n\n    Tham số:\n    fruit_counts (List[int]): Một danh sách các số nguyên đại diện cho số lượng của mỗi loại trái cây.\n\n    Trả về:\n    int: Tổng chi phí tối thiểu cần thiết để gộp tất cả các đống trái cây.\n\n    Ví dụ:\n    >>> minimum_cost_to_merge_fruits([1, 2, 9])\n    15  # Gộp (1+2) với chi phí 3, sau đó (3+9) với chi phí 12, tổng chi phí là 15.\n\n    >>> minimum_cost_to_merge_fruits([5, 5])\n    10  # Gộp (5+5) với tổng chi phí 10.\n\n    >>> minimum_cost_to_merge_fruits([10, 20, 30, 40, 50])\n    300 # Một cách tối ưu là gộp 10+20 (chi phí 30), sau đó gộp 30+30 (chi phí 60),\n        # tiếp theo là gộp 40+50 (chi phí 90), và cuối cùng gộp hai đống còn lại 60+90 (chi phí 150).\n        # Tổng chi phí là 30+60+90+150 = 300.\n    \"\"\""
    },
    "prompt_bertscore": {
      "es": "0.9613437470252763",
      "arb": "0.95236962641012",
      "sw": "0.956115596766057",
      "tr": "0.9561682338170312",
      "vi": "0.9510991864930208"
    },
    "canonical_solution": "    # Initialize a min-heap with the fruit counts.\n    heapq.heapify(fruit_counts)\n    \n    total_cost = 0\n    \n    # Keep merging until there is only one heap left.\n    while len(fruit_counts) > 1:\n        # Pop the two smallest heaps.\n        first = heapq.heappop(fruit_counts)\n        second = heapq.heappop(fruit_counts)\n        \n        # The cost is the sum of the two smallest heaps.\n        cost = first + second\n        total_cost += cost\n        \n        # Push the new heap back into the min-heap.\n        heapq.heappush(fruit_counts, cost)\n    \n    return total_cost",
    "instruction": {
      "en": "def minimum_cost_to_merge_fruits(fruit_counts: List[int]) -> int:\n    # Initialize a min-heap with the fruit counts.\n    heapq.heapify(fruit_counts)\n    \n    total_cost = 0\n    \n    # Keep merging until there is only one heap left.\n    while len(fruit_counts) > 1:\n        # Pop the two smallest heaps.\n        first = heapq.heappop(fruit_counts)\n        second = heapq.heappop(fruit_counts)\n        \n        # The cost is the sum of the two smallest heaps.\n        cost = first + second\n        total_cost += cost\n        \n        # Push the new heap back into the min-heap.\n        heapq.heappush(fruit_counts, cost)\n    \n    return total_cost\n\nProvide a concise natural language description (docstring) of the Python code in English using at most 500 characters.",
      "es": "def minimum_cost_to_merge_fruits(fruit_counts: List[int]) -> int:\n    # Initialize a min-heap with the fruit counts.\n    heapq.heapify(fruit_counts)\n    \n    total_cost = 0\n    \n    # Keep merging until there is only one heap left.\n    while len(fruit_counts) > 1:\n        # Pop the two smallest heaps.\n        first = heapq.heappop(fruit_counts)\n        second = heapq.heappop(fruit_counts)\n        \n        # The cost is the sum of the two smallest heaps.\n        cost = first + second\n        total_cost += cost\n        \n        # Push the new heap back into the min-heap.\n        heapq.heappush(fruit_counts, cost)\n    \n    return total_cost\n\nProporcione una descripción concisa en lenguaje natural (docstring) del código Python en español utilizando como máximo 500 caracteres.",
      "arb": "def minimum_cost_to_merge_fruits(fruit_counts: List[int]) -> int:\n    # Initialize a min-heap with the fruit counts.\n    heapq.heapify(fruit_counts)\n    \n    total_cost = 0\n    \n    # Keep merging until there is only one heap left.\n    while len(fruit_counts) > 1:\n        # Pop the two smallest heaps.\n        first = heapq.heappop(fruit_counts)\n        second = heapq.heappop(fruit_counts)\n        \n        # The cost is the sum of the two smallest heaps.\n        cost = first + second\n        total_cost += cost\n        \n        # Push the new heap back into the min-heap.\n        heapq.heappush(fruit_counts, cost)\n    \n    return total_cost\n\nيرجى تقديم وصف موجز بلغة طبيعية (docstring) للشفرة البرمجية بلغة بايثون باللغة العربية الفصحى، باستخدام 500 حرف كحد أقصى.",
      "sw": "def minimum_cost_to_merge_fruits(fruit_counts: List[int]) -> int:\n    # Initialize a min-heap with the fruit counts.\n    heapq.heapify(fruit_counts)\n    \n    total_cost = 0\n    \n    # Keep merging until there is only one heap left.\n    while len(fruit_counts) > 1:\n        # Pop the two smallest heaps.\n        first = heapq.heappop(fruit_counts)\n        second = heapq.heappop(fruit_counts)\n        \n        # The cost is the sum of the two smallest heaps.\n        cost = first + second\n        total_cost += cost\n        \n        # Push the new heap back into the min-heap.\n        heapq.heappush(fruit_counts, cost)\n    \n    return total_cost\n\nToa maelezo mafupi ya lugha asilia (docstring) ya msimbo wa Python kwa Kiswahili kwa kutumia herufi zisizozidi 500.",
      "tr": "def minimum_cost_to_merge_fruits(fruit_counts: List[int]) -> int:\n    # Initialize a min-heap with the fruit counts.\n    heapq.heapify(fruit_counts)\n    \n    total_cost = 0\n    \n    # Keep merging until there is only one heap left.\n    while len(fruit_counts) > 1:\n        # Pop the two smallest heaps.\n        first = heapq.heappop(fruit_counts)\n        second = heapq.heappop(fruit_counts)\n        \n        # The cost is the sum of the two smallest heaps.\n        cost = first + second\n        total_cost += cost\n        \n        # Push the new heap back into the min-heap.\n        heapq.heappush(fruit_counts, cost)\n    \n    return total_cost\n\nVerilen Python kodunun işlevini açıklayan, en fazla 500 karakter uzunluğunda özlü bir doğal dil açıklaması (docstring) sağlayın.",
      "vi": "def minimum_cost_to_merge_fruits(fruit_counts: List[int]) -> int:\n    # Initialize a min-heap with the fruit counts.\n    heapq.heapify(fruit_counts)\n    \n    total_cost = 0\n    \n    # Keep merging until there is only one heap left.\n    while len(fruit_counts) > 1:\n        # Pop the two smallest heaps.\n        first = heapq.heappop(fruit_counts)\n        second = heapq.heappop(fruit_counts)\n        \n        # The cost is the sum of the two smallest heaps.\n        cost = first + second\n        total_cost += cost\n        \n        # Push the new heap back into the min-heap.\n        heapq.heappush(fruit_counts, cost)\n    \n    return total_cost\n\nCung cấp mô tả ngắn gọn bằng ngôn ngữ tự nhiên (docstring) cho mã Python bằng tiếng Việt, không quá 500 ký tự."
    },
    "instruction_bertscore": {
      "es": "0.9687387561112052",
      "arb": "0.924699818440817",
      "sw": "0.9426438884331277",
      "tr": "0.8508820154152974",
      "vi": "0.9159938488400579"
    },
    "level": "",
    "test": "def test_minimum_cost_to_merge_fruits():\n    # Test case 1: As provided in the problem statement example\n    fruits1 = [1, 2, 9]\n    assert minimum_cost_to_merge_fruits(fruits1) == 15, \"Test case 1 failed\"\n\n    # Test case 2: Simple case with only two types of fruits\n    fruits2 = [5, 5]\n    assert minimum_cost_to_merge_fruits(fruits2) == 10, \"Test case 2 failed\"\n\n    # Test case 3: More complex case with multiple types of fruits\n    fruits3 = [10, 20, 30, 40, 50]\n    assert minimum_cost_to_merge_fruits(fruits3) == 330, \"Test case 3 failed\"\n\n    # Test case 4: Case with fruits having the same count\n    fruits4 = [3, 3, 3, 3]\n    assert minimum_cost_to_merge_fruits(fruits4) == 24, \"Test case 4 failed\"\n\n    # Test case 5: Case with a single type of fruit\n    fruits5 = [7]\n    assert minimum_cost_to_merge_fruits(fruits5) == 0, \"Test case 5 failed\"\n\n    print(\"All test cases passed.\")\n\n# Run the test function\ntest_minimum_cost_to_merge_fruits()",
    "entry_point": "minimum_cost_to_merge_fruits",
    "signature": "def minimum_cost_to_merge_fruits(fruit_counts: List[int]) -> int:",
    "docstring": {
      "en": "Calculates the minimum total cost to merge multiple heaps of fruits into a single heap.\nThe cost of merging two heaps is equal to the sum of their weights. The function utilizes\na greedy algorithm with a min-heap (priority queue) to ensure the smallest heaps are merged first,\nminimizing the total cost.\n\nParameters:\nfruit_counts (List[int]): A list of integers representing the counts of each type of fruit.\n\nReturns:\nint: The minimum total cost required to merge all heaps of fruits.\n\nExamples:\n>>> minimum_cost_to_merge_fruits([1, 2, 9])\n15  # Merging (1+2) with a cost of 3, and then (3+9) with a cost of 12, gives a total cost of 15.\n\n>>> minimum_cost_to_merge_fruits([5, 5])\n10  # Merging (5+5) with a total cost of 10.\n\n>>> minimum_cost_to_merge_fruits([10, 20, 30, 40, 50])\n300 # One optimal way is merging 10+20 (cost 30), then merging 30+30 (cost 60),\nfollowed by 40+50 (cost 90), and finally merging the two remaining heaps 60+90 (cost 150).\nTotal cost is 30+60+90+150 = 300.",
      "es": "Calcula el costo total mínimo para fusionar múltiples montones de frutas en un solo montón. El costo de fusionar dos montones es igual a la suma de sus pesos. La función utiliza un algoritmo codicioso con un montón mínimo (cola de prioridad) para asegurar que los montones más pequeños se fusionen primero, minimizando el costo total.\n\nParámetros:\nfruit_counts (List[int]): Una lista de enteros que representa las cantidades de cada tipo de fruta.\n\nDevuelve:\nint: El costo total mínimo requerido para fusionar todos los montones de frutas.\n\nEjemplos:\n>>> minimum_cost_to_merge_fruits([1, 2, 9])\n15  # Fusionar (1+2) con un costo de 3, y luego (3+9) con un costo de 12, da un costo total de 15.\n\n>>> minimum_cost_to_merge_fruits([5, 5])\n10  # Fusionar (5+5) con un costo total de 10.\n\n>>> minimum_cost_to_merge_fruits([10, 20, 30, 40, 50])\n300 # Una forma óptima es fusionar 10+20 (costo 30), luego fusionar 30+30 (costo 60),\nseguido de 40+50 (costo 90), y finalmente fusionar los dos montones restantes 60+90 (costo 150).\nEl costo total es 30+60+90+150 = 300.",
      "arb": "يحسب الحد الأدنى للتكلفة الإجمالية لدمج أكوام متعددة من الفواكه في كومة واحدة.\nتكلفة دمج كومتين تساوي مجموع أوزانهما. تستخدم الدالة خوارزمية جشعة مع كومة ذات أولوية (طابور الأولوية) لضمان دمج أصغر الأكوام أولاً، مما يقلل التكلفة الإجمالية.\n\nالمعلمات:\nfruit_counts (List[int]): قائمة من الأعداد الصحيحة تمثل عدد كل نوع من الفاكهة.\n\nالقيم المعادة:\nint: الحد الأدنى للتكلفة الإجمالية المطلوبة لدمج جميع أكوام الفواكه.\n\nأمثلة:\n>>> minimum_cost_to_merge_fruits([1, 2, 9])\n15  # دمج (1+2) بتكلفة 3، ثم (3+9) بتكلفة 12، يعطي تكلفة إجمالية 15.\n\n>>> minimum_cost_to_merge_fruits([5, 5])\n10  # دمج (5+5) بتكلفة إجمالية 10.\n\n>>> minimum_cost_to_merge_fruits([10, 20, 30, 40, 50])\n300 # إحدى الطرق المثلى هي دمج 10+20 (بتكلفة 30)، ثم دمج 30+30 (بتكلفة 60)،\nثم دمج 40+50 (بتكلفة 90)، وأخيراً دمج الكومتين المتبقيتين 60+90 (بتكلفة 150).\nالتكلفة الإجمالية هي 30+60+90+150 = 300.",
      "sw": "Hesabu gharama ndogo kabisa ya kuunganisha marundo mengi ya matunda kuwa rundo moja. Gharama ya kuunganisha marundo mawili ni sawa na jumla ya uzito wao. Kazi hii inatumia algoriti ya pupa na min-rundo (foleni ya kipaumbele) kuhakikisha marundo madogo zaidi yanaunganishwa kwanza, kupunguza gharama ya jumla.\n\nVigezo:\nfruit_counts (List[int]): Orodha ya namba inayoonyesha idadi ya kila aina ya tunda.\n\nRudisha:\nint: Gharama ndogo kabisa inayohitajika kuunganisha marundo yote ya matunda.\n\nMifano:\n>>> minimum_cost_to_merge_fruits([1, 2, 9])\n15  # Kuunganisha (1+2) kwa gharama ya 3, na kisha (3+9) kwa gharama ya 12, inatoa gharama ya jumla ya 15.\n\n>>> minimum_cost_to_merge_fruits([5, 5])\n10  # Kuunganisha (5+5) kwa gharama ya jumla ya 10.\n\n>>> minimum_cost_to_merge_fruits([10, 20, 30, 40, 50])\n300 # Njia moja bora ni kuunganisha 10+20 (gharama 30), kisha kuunganisha 30+30 (gharama 60),\nikifuatiwa na 40+50 (gharama 90), na hatimaye kuunganisha marundo mawili yaliyobaki 60+90 (gharama 150).\nGharama ya jumla ni 30+60+90+150 = 300.",
      "tr": "Birden fazla meyve yığınını tek bir yığın halinde birleştirmek için minimum toplam maliyeti hesaplar.\nİki yığını birleştirmenin maliyeti, ağırlıklarının toplamına eşittir. Fonksiyon, toplam maliyeti en aza indirmek için\nen küçük yığınların önce birleştirilmesini sağlamak amacıyla min-yığın (öncelik kuyruğu) ile açgözlü bir algoritma kullanır.\n\nParametreler:\nfruit_counts (List[int]): Her tür meyvenin sayısını temsil eden bir tamsayı listesi.\n\nDöndürülen:\nint: Tüm meyve yığınlarını birleştirmek için gereken minimum toplam maliyet.\n\nÖrnekler:\n>>> minimum_cost_to_merge_fruits([1, 2, 9])\n15  # (1+2) yığınını 3 maliyetle birleştirmek ve ardından (3+9) yığınını 12 maliyetle birleştirmek, toplamda 15 maliyet verir.\n\n>>> minimum_cost_to_merge_fruits([5, 5])\n10  # (5+5) yığınını toplam 10 maliyetle birleştirmek.\n\n>>> minimum_cost_to_merge_fruits([10, 20, 30, 40, 50])\n300 # Bir optimal yol, 10+20'yi (maliyet 30) birleştirmek, ardından 30+30'u (maliyet 60) birleştirmek,\n40+50'yi (maliyet 90) birleştirmek ve son olarak kalan iki yığını 60+90 (maliyet 150) birleştirmektir.\nToplam maliyet 30+60+90+150 = 300.",
      "vi": "Tính toán tổng chi phí tối thiểu để gộp nhiều đống trái cây thành một đống duy nhất. Chi phí gộp hai đống bằng tổng trọng lượng của chúng. Hàm sử dụng một thuật toán tham lam với một đống tối thiểu (hàng đợi ưu tiên) để đảm bảo các đống nhỏ nhất được gộp trước, giảm thiểu tổng chi phí.\n\nTham số:\nfruit_counts (List[int]): Một danh sách các số nguyên đại diện cho số lượng của mỗi loại trái cây.\n\nTrả về:\nint: Tổng chi phí tối thiểu cần thiết để gộp tất cả các đống trái cây.\n\nVí dụ:\n>>> minimum_cost_to_merge_fruits([1, 2, 9])\n15  # Gộp (1+2) với chi phí 3, và sau đó (3+9) với chi phí 12, cho tổng chi phí là 15.\n\n>>> minimum_cost_to_merge_fruits([5, 5])\n10  # Gộp (5+5) với tổng chi phí là 10.\n\n>>> minimum_cost_to_merge_fruits([10, 20, 30, 40, 50])\n300 # Một cách tối ưu là gộp 10+20 (chi phí 30), sau đó gộp 30+30 (chi phí 60),\ntiếp theo là 40+50 (chi phí 90), và cuối cùng gộp hai đống còn lại 60+90 (chi phí 150).\nTổng chi phí là 30+60+90+150 = 300."
    },
    "docstring_bertscore": {
      "es": "0.9672422748204883",
      "arb": "0.9439991435229288",
      "sw": "0.9440940888450635",
      "tr": "0.9594130597216172",
      "vi": "0.9511977071620141"
    }
  },
  {
    "task_id": "Python/46",
    "prompt": {
      "en": "def minimum_students_to_leave(heights):\n    \"\"\"\n    Calculate the minimum number of students that need to leave to form a choir formation.\n    A choir formation is defined such that for some position 'i', the heights of students\n    increase from the start to 'i' and decrease from 'i' to the end of the formation.\n\n    Args:\n    heights (List[int]): A list of student heights.\n\n    Returns:\n    int: The minimum number of students that need to leave.\n    \"\"\"",
      "es": "def minimum_students_to_leave(heights):\n    \"\"\"\n    Calcular el número mínimo de estudiantes que deben salir para formar una formación de coro.\n    Se define una formación de coro tal que para alguna posición 'i', las alturas de los estudiantes\n    aumentan desde el inicio hasta 'i' y disminuyen desde 'i' hasta el final de la formación.\n\n    Argumentos:\n    heights (List[int]): Una lista de alturas de estudiantes.\n\n    Devuelve:\n    int: El número mínimo de estudiantes que deben salir.\n    \"\"\"",
      "arb": "def minimum_students_to_leave(heights):\n    \"\"\"\n    حساب الحد الأدنى لعدد الطلاب الذين يحتاجون إلى المغادرة لتشكيل جوقة.\n    يتم تعريف تشكيل الجوقة بحيث أنه بالنسبة لموقع معين 'i'، تزداد أطوال الطلاب\n    من البداية إلى 'i' وتتناقص من 'i' إلى نهاية التشكيل.\n\n    يعيدالحجج:\n    heights (List[int]): قائمة بأطوال الطلاب.\n\n    يعيد:\n    int: الحد الأدنى لعدد الطلاب الذين يحتاجون إلى المغادرة.\n    \"\"\"",
      "sw": "def minimum_students_to_leave(heights):\n    \"\"\"\n    Hesabu idadi ndogo ya wanafunzi wanaohitajika kuondoka ili kuunda safu ya kwaya.\n    Safu ya kwaya inafafanuliwa kwamba kwa nafasi fulani 'i', urefu wa wanafunzi\n    unaongezeka kutoka mwanzo hadi 'i' na kupungua kutoka 'i' hadi mwisho wa safu.\n\n    Hoja:\n    heights (List[int]): Orodha ya urefu wa wanafunzi.\n\n    Inarejesha:\n    int: Idadi ndogo ya wanafunzi wanaohitajika kuondoka.\n    \"\"\"",
      "tr": "def minimum_students_to_leave(heights):\n    \"\"\"\n    Bir koro formasyonu oluşturmak için ayrılması gereken minimum öğrenci sayısını hesaplayın.\n    Bir koro formasyonu, 'i' pozisyonu için, öğrencilerin boylarının başlangıçtan 'i'ye kadar arttığı\n    ve 'i'den formasyonun sonuna kadar azaldığı şekilde tanımlanır.\n\n    Argümanlar:\n    heights (List[int]): Öğrenci boylarının listesi.\n\n    Döndürür:\n    int: Ayrılması gereken minimum öğrenci sayısı.\n    \"\"\"",
      "vi": "def minimum_students_to_leave(heights):\n    \"\"\"\n    Tính toán số lượng học sinh tối thiểu cần rời đi để tạo thành đội hình hợp xướng.\n    Một đội hình hợp xướng được định nghĩa sao cho tại một vị trí 'i', chiều cao của học sinh\n    tăng dần từ đầu đến 'i' và giảm dần từ 'i' đến cuối đội hình.\n\n    Tham số:\n    heights (List[int]): Một danh sách chiều cao của học sinh.\n\n    Trả về:\n    int: Số lượng học sinh tối thiểu cần rời đi.\n    \"\"\""
    },
    "prompt_bertscore": {
      "es": "0.9910767287623887",
      "arb": "0.9815871623084469",
      "sw": "0.9433535947845654",
      "tr": "0.9781174868125295",
      "vi": "0.9788700973262706"
    },
    "canonical_solution": "    n = len(heights)\n    \n    # Compute the length of the longest increasing subsequence (LIS) for each position\n    lis = [1] * n\n    for i in range(n):\n        for j in range(i):\n            if heights[i] > heights[j]:\n                lis[i] = max(lis[i], lis[j] + 1)\n\n    # Compute the length of the longest decreasing subsequence (LDS) for each position\n    lds = [1] * n\n    for i in range(n - 1, -1, -1):\n        for j in range(n - 1, i, -1):\n            if heights[i] > heights[j]:\n                lds[i] = max(lds[i], lds[j] + 1)\n\n    # Find the maximum choir formation length by summing LIS and LDS for each position\n    # and subtracting 1 to not count the peak student height twice\n    max_choir_length = max(lis[i] + lds[i] - 1 for i in range(n))\n    \n    # Calculate the minimum number of students to leave\n    return n - max_choir_length",
    "instruction": {
      "en": "def minimum_students_to_leave(heights):\n    n = len(heights)\n    \n    # Compute the length of the longest increasing subsequence (LIS) for each position\n    lis = [1] * n\n    for i in range(n):\n        for j in range(i):\n            if heights[i] > heights[j]:\n                lis[i] = max(lis[i], lis[j] + 1)\n\n    # Compute the length of the longest decreasing subsequence (LDS) for each position\n    lds = [1] * n\n    for i in range(n - 1, -1, -1):\n        for j in range(n - 1, i, -1):\n            if heights[i] > heights[j]:\n                lds[i] = max(lds[i], lds[j] + 1)\n\n    # Find the maximum choir formation length by summing LIS and LDS for each position\n    # and subtracting 1 to not count the peak student height twice\n    max_choir_length = max(lis[i] + lds[i] - 1 for i in range(n))\n    \n    # Calculate the minimum number of students to leave\n    return n - max_choir_length\n\nProvide a concise natural language description (docstring) of the Python code in English using at most 500 characters.",
      "es": "def minimum_students_to_leave(heights):\n    n = len(heights)\n    \n    # Compute the length of the longest increasing subsequence (LIS) for each position\n    lis = [1] * n\n    for i in range(n):\n        for j in range(i):\n            if heights[i] > heights[j]:\n                lis[i] = max(lis[i], lis[j] + 1)\n\n    # Compute the length of the longest decreasing subsequence (LDS) for each position\n    lds = [1] * n\n    for i in range(n - 1, -1, -1):\n        for j in range(n - 1, i, -1):\n            if heights[i] > heights[j]:\n                lds[i] = max(lds[i], lds[j] + 1)\n\n    # Find the maximum choir formation length by summing LIS and LDS for each position\n    # and subtracting 1 to not count the peak student height twice\n    max_choir_length = max(lis[i] + lds[i] - 1 for i in range(n))\n    \n    # Calculate the minimum number of students to leave\n    return n - max_choir_length\n\nProporcione una descripción concisa en lenguaje natural (docstring) del código Python en español usando un máximo de 500 caracteres.",
      "arb": "def minimum_students_to_leave(heights):\n    n = len(heights)\n    \n    # Compute the length of the longest increasing subsequence (LIS) for each position\n    lis = [1] * n\n    for i in range(n):\n        for j in range(i):\n            if heights[i] > heights[j]:\n                lis[i] = max(lis[i], lis[j] + 1)\n\n    # Compute the length of the longest decreasing subsequence (LDS) for each position\n    lds = [1] * n\n    for i in range(n - 1, -1, -1):\n        for j in range(n - 1, i, -1):\n            if heights[i] > heights[j]:\n                lds[i] = max(lds[i], lds[j] + 1)\n\n    # Find the maximum choir formation length by summing LIS and LDS for each position\n    # and subtracting 1 to not count the peak student height twice\n    max_choir_length = max(lis[i] + lds[i] - 1 for i in range(n))\n    \n    # Calculate the minimum number of students to leave\n    return n - max_choir_length\n\nيرجى تقديم وصف موجز بلغة طبيعية (docstring) للكود البرمجي بلغة بايثون باللغة العربية الفصحى، بحيث لا يتجاوز 500 حرف.",
      "sw": "def minimum_students_to_leave(heights):\n    n = len(heights)\n    \n    # Compute the length of the longest increasing subsequence (LIS) for each position\n    lis = [1] * n\n    for i in range(n):\n        for j in range(i):\n            if heights[i] > heights[j]:\n                lis[i] = max(lis[i], lis[j] + 1)\n\n    # Compute the length of the longest decreasing subsequence (LDS) for each position\n    lds = [1] * n\n    for i in range(n - 1, -1, -1):\n        for j in range(n - 1, i, -1):\n            if heights[i] > heights[j]:\n                lds[i] = max(lds[i], lds[j] + 1)\n\n    # Find the maximum choir formation length by summing LIS and LDS for each position\n    # and subtracting 1 to not count the peak student height twice\n    max_choir_length = max(lis[i] + lds[i] - 1 for i in range(n))\n    \n    # Calculate the minimum number of students to leave\n    return n - max_choir_length\n\nToa maelezo mafupi ya lugha asilia (docstring) ya msimbo wa Python kwa Kiswahili kwa kutumia herufi zisizozidi 500.",
      "tr": "def minimum_students_to_leave(heights):\n    n = len(heights)\n    \n    # Compute the length of the longest increasing subsequence (LIS) for each position\n    lis = [1] * n\n    for i in range(n):\n        for j in range(i):\n            if heights[i] > heights[j]:\n                lis[i] = max(lis[i], lis[j] + 1)\n\n    # Compute the length of the longest decreasing subsequence (LDS) for each position\n    lds = [1] * n\n    for i in range(n - 1, -1, -1):\n        for j in range(n - 1, i, -1):\n            if heights[i] > heights[j]:\n                lds[i] = max(lds[i], lds[j] + 1)\n\n    # Find the maximum choir formation length by summing LIS and LDS for each position\n    # and subtracting 1 to not count the peak student height twice\n    max_choir_length = max(lis[i] + lds[i] - 1 for i in range(n))\n    \n    # Calculate the minimum number of students to leave\n    return n - max_choir_length\n\nPython kodunun işlevini açıklayan kısa bir doğal dil açıklaması (docstring) sağlayın. Açıklama, Türkçe olarak en fazla 500 karakter kullanılarak yazılmalıdır.",
      "vi": "def minimum_students_to_leave(heights):\n    n = len(heights)\n    \n    # Compute the length of the longest increasing subsequence (LIS) for each position\n    lis = [1] * n\n    for i in range(n):\n        for j in range(i):\n            if heights[i] > heights[j]:\n                lis[i] = max(lis[i], lis[j] + 1)\n\n    # Compute the length of the longest decreasing subsequence (LDS) for each position\n    lds = [1] * n\n    for i in range(n - 1, -1, -1):\n        for j in range(n - 1, i, -1):\n            if heights[i] > heights[j]:\n                lds[i] = max(lds[i], lds[j] + 1)\n\n    # Find the maximum choir formation length by summing LIS and LDS for each position\n    # and subtracting 1 to not count the peak student height twice\n    max_choir_length = max(lis[i] + lds[i] - 1 for i in range(n))\n    \n    # Calculate the minimum number of students to leave\n    return n - max_choir_length\n\nCung cấp mô tả ngắn gọn bằng ngôn ngữ tự nhiên (docstring) cho mã Python bằng tiếng Việt, không quá 500 ký tự."
    },
    "instruction_bertscore": {
      "es": "0.9687387561112052",
      "arb": "0.906469919330197",
      "sw": "0.9426438884331277",
      "tr": "0.878612207020435",
      "vi": "0.9159938488400579"
    },
    "level": "",
    "test": "def test_minimum_students_to_leave():\n    # Test case 1: Provided example\n    assert minimum_students_to_leave([186, 186, 150, 200, 160, 130, 197, 220]) == 4, \"Test case 1 failed\"\n\n    # Test case 2: All students have the same height\n    assert minimum_students_to_leave([150, 150, 150, 150, 150]) == 4, \"Test case 2 failed\"\n\n    # Test case 3: Students are already in a choir formation\n    assert minimum_students_to_leave([130, 150, 170, 190, 170, 150, 130]) == 0, \"Test case 3 failed\"\n\n    # Test case 4: Students are in strictly increasing order\n    assert minimum_students_to_leave([130, 135, 140, 145, 150, 155]) == 0, \"Test case 4 failed\"\n\n    # Test case 5: Students are in strictly decreasing order\n    assert minimum_students_to_leave([155, 150, 145, 140, 135, 130]) == 0, \"Test case 5 failed\"\n\n    # Test case 6: Optimal choir formation is not including the first or last student\n    assert minimum_students_to_leave([200, 180, 190, 170, 210, 160, 220]) == 3, \"Test case 6 failed\"\n\n    print(\"All test cases passed!\")\n\n# Run the test function\ntest_minimum_students_to_leave()",
    "entry_point": "minimum_students_to_leave",
    "signature": "def minimum_students_to_leave(heights):",
    "docstring": {
      "en": "Calculate the minimum number of students that need to leave to form a choir formation.\nA choir formation is defined such that for some position 'i', the heights of students\nincrease from the start to 'i' and decrease from 'i' to the end of the formation.\n\nArgs:\nheights (List[int]): A list of student heights.\n\nReturns:\nint: The minimum number of students that need to leave.",
      "es": "Calcular el número mínimo de estudiantes que necesitan salir para formar una formación de coro. \nUna formación de coro se define de tal manera que para alguna posición 'i', las alturas de los estudiantes \naumentan desde el inicio hasta 'i' y disminuyen desde 'i' hasta el final de la formación.\n\nArgumentos:\nheights (List[int]): Una lista de alturas de estudiantes.\n\nDevuelve:\nint: El número mínimo de estudiantes que necesitan salir.",
      "arb": "احسب الحد الأدنى لعدد الطلاب الذين يحتاجون إلى المغادرة لتشكيل تكوين جوقة. يتم تعريف تكوين الجوقة بحيث أنه بالنسبة لموضع ما 'i'، تزداد أطوال الطلاب من البداية إلى 'i' وتتناقص من 'i' إلى نهاية التكوين.\n\nالمعطيات:\nheights (List[int]): قائمة بأطوال الطلاب.\n\nالإرجاع:\nint: الحد الأدنى لعدد الطلاب الذين يحتاجون إلى المغادرة.",
      "sw": "Hesabu idadi ndogo ya wanafunzi wanaohitajika kuondoka ili kuunda muundo wa kwaya. \nMuundo wa kwaya unafafanuliwa kwamba kwa nafasi fulani 'i', urefu wa wanafunzi \nunaongezeka kutoka mwanzo hadi 'i' na kupungua kutoka 'i' hadi mwisho wa muundo.\n\nHoja:\nheights (List[int]): Orodha ya urefu wa wanafunzi.\n\nInarejesha:\nint: Idadi ndogo ya wanafunzi wanaohitajika kuondoka.",
      "tr": "Öğrencilerin koroya katılımı için ayrılması gereken minimum öğrenci sayısını hesaplayın. Bir koro formasyonu, bazı 'i' pozisyonları için, öğrencilerin boylarının başlangıçtan 'i'ye kadar arttığı ve 'i'den formasyonun sonuna kadar azaldığı şekilde tanımlanır.\n\nArgümanlar:\nheights (List[int]): Öğrenci boylarının listesi.\n\nDöndürür:\nint: Ayrılması gereken minimum öğrenci sayısı.",
      "vi": "Tính toán số lượng học sinh tối thiểu cần rời đi để tạo thành một đội hợp xướng. \nMột đội hợp xướng được định nghĩa sao cho với một vị trí 'i' nào đó, chiều cao của học sinh \ntăng dần từ đầu đến 'i' và giảm dần từ 'i' đến cuối của đội hình.\n\nTham số:\nheights (List[int]): Một danh sách chiều cao của học sinh.\n\nTrả về:\nint: Số lượng học sinh tối thiểu cần rời đi."
    },
    "docstring_bertscore": {
      "es": "0.9823322248677088",
      "arb": "0.9692091128534958",
      "sw": "0.9428625804826472",
      "tr": "0.9332699248609483",
      "vi": "0.9654283821808777"
    }
  },
  {
    "task_id": "Python/47",
    "prompt": {
      "en": "def sort_students(student_scores):\n    \"\"\"\n    Sorts a list of students based on their scores. The students are sorted primarily by their total score (descending),\n    then by their Chinese score (descending), and finally by their student number (ascending) in case of a tie.\n    \n    Args:\n    student_scores (list): A list of tuples, where each tuple consists of (student_number, total_score, Chinese_score).\n    \n    Returns:\n    list: A list of tuples sorted according to the above rules.\n    \n    Examples:\n    >>> sort_students([(1, 237, 90), (2, 244, 87), (3, 258, 78), (4, 264, 88), (5, 215, 67), (6, 265, 78)])\n    [(6, 265, 78), (4, 264, 88), (3, 258, 78), (2, 244, 87), (1, 237, 90), (5, 215, 67)]\n    \n    >>> sort_students([(1, 300, 100), (2, 300, 99), (3, 299, 98), (4, 298, 97), (5, 297, 96)])\n    [(1, 300, 100), (2, 300, 99), (3, 299, 98), (4, 298, 97), (5, 297, 96)]\n    \n    In the first example, the student with the highest total score is number 6. Students number 4 and 3 follow,\n    with descending total scores. Student number 1 has a lower total score than student number 2, but a higher Chinese score,\n    so student number 1 is placed after student number 2 in the sorted list.\n    \n    In the second example, students number 1 and 2 have the same total score, but student number 1 has a higher Chinese score,\n    so they are placed first. The rest are sorted by their descending total scores.\n    \"\"\"",
      "es": "def sort_students(student_scores):\n    \"\"\"\n    Ordena una lista de estudiantes según sus puntajes. Los estudiantes se ordenan principalmente por su puntaje total (descendente),\n    luego por su puntaje en Chino (descendente), y finalmente por su número de estudiante (ascendente) en caso de empate.\n    \n    Argumentos:\n    student_scores (list): Una lista de tuplas, donde cada tupla consiste en (número_estudiante, puntaje_total, puntaje_Chino).\n    \n    Devuelve:\n    list: Una lista de tuplas ordenadas según las reglas anteriores.\n    \n    Ejemplos:\n    >>> sort_students([(1, 237, 90), (2, 244, 87), (3, 258, 78), (4, 264, 88), (5, 215, 67), (6, 265, 78)])\n    [(6, 265, 78), (4, 264, 88), (3, 258, 78), (2, 244, 87), (1, 237, 90), (5, 215, 67)]\n    \n    >>> sort_students([(1, 300, 100), (2, 300, 99), (3, 299, 98), (4, 298, 97), (5, 297, 96)])\n    [(1, 300, 100), (2, 300, 99), (3, 299, 98), (4, 298, 97), (5, 297, 96)]\n    \n    En el primer ejemplo, el estudiante con el puntaje total más alto es el número 6. Los estudiantes número 4 y 3 siguen,\n    con puntajes totales descendentes. El estudiante número 1 tiene un puntaje total más bajo que el estudiante número 2, pero un puntaje en Chino más alto,\n    por lo que el estudiante número 1 se coloca después del estudiante número 2 en la lista ordenada.\n    \n    En el segundo ejemplo, los estudiantes número 1 y 2 tienen el mismo puntaje total, pero el estudiante número 1 tiene un puntaje en Chino más alto,\n    por lo que se colocan primero. El resto se ordena por sus puntajes totales descendentes.\n    \"\"\"",
      "arb": "def sort_students(student_scores):\n    \"\"\"\n    يقوم بفرز قائمة الطلاب بناءً على درجاتهم. يتم فرز الطلاب بشكل أساسي حسب مجموع درجاتهم (تنازليًا)،\n    ثم حسب درجة اللغة الصينية (تنازليًا)، وأخيرًا حسب رقم الطالب (تصاعديًا) في حالة التعادل.\n    \n    يعيدالحجج:\n    student_scores (list): قائمة من المجموعات، حيث تتكون كل مجموعة من (رقم الطالب، مجموع الدرجات، درجة اللغة الصينية).\n    \n    يعيد:\n    list: قائمة من المجموعات مرتبة وفقًا للقواعد المذكورة أعلاه.\n    \n    امثله:\n    >>> sort_students([(1, 237, 90), (2, 244, 87), (3, 258, 78), (4, 264, 88), (5, 215, 67), (6, 265, 78)])\n    [(6, 265, 78), (4, 264, 88), (3, 258, 78), (2, 244, 87), (1, 237, 90), (5, 215, 67)]\n    \n    >>> sort_students([(1, 300, 100), (2, 300, 99), (3, 299, 98), (4, 298, 97), (5, 297, 96)])\n    [(1, 300, 100), (2, 300, 99), (3, 299, 98), (4, 298, 97), (5, 297, 96)]\n    \n    في المثال الأول، الطالب الذي لديه أعلى مجموع درجات هو رقم 6. يتبعه الطلاب رقم 4 و3،\n    مع مجموع درجات تنازلي. الطالب رقم 1 لديه مجموع درجات أقل من الطالب رقم 2، لكن درجة اللغة الصينية أعلى،\n    لذا يتم وضع الطالب رقم 1 بعد الطالب رقم 2 في القائمة المرتبة.\n    \n    في المثال الثاني، الطلاب رقم 1 و2 لديهم نفس مجموع الدرجات، لكن الطالب رقم 1 لديه درجة لغة صينية أعلى،\n    لذا يتم وضعهم أولاً. الباقي يتم ترتيبه حسب مجموع درجاتهم التنازلي.\n    \"\"\"",
      "sw": "def sort_students(student_scores):\n    \"\"\"\n    Hupanga orodha ya wanafunzi kulingana na alama zao. Wanafunzi wanapangwa kimsingi kwa alama zao za jumla (kutoka juu kwenda chini),\n    kisha kwa alama zao za Kichina (kutoka juu kwenda chini), na hatimaye kwa nambari yao ya mwanafunzi (kutoka chini kwenda juu) ikiwa kuna sare.\n    \n    Hoja:\n    student_scores (list): Orodha ya jozi, ambapo kila jozi inajumuisha (nambari_ya_mwanafunzi, alama_ya_jumla, alama_ya_Kichina).\n    \n    Inarejesha:\n    list: Orodha ya jozi zilizopangwa kulingana na sheria zilizo hapo juu.\n    \n    Mifano:\n    >>> sort_students([(1, 237, 90), (2, 244, 87), (3, 258, 78), (4, 264, 88), (5, 215, 67), (6, 265, 78)])\n    [(6, 265, 78), (4, 264, 88), (3, 258, 78), (2, 244, 87), (1, 237, 90), (5, 215, 67)]\n    \n    >>> sort_students([(1, 300, 100), (2, 300, 99), (3, 299, 98), (4, 298, 97), (5, 297, 96)])\n    [(1, 300, 100), (2, 300, 99), (3, 299, 98), (4, 298, 97), (5, 297, 96)]\n    \n    Katika mfano wa kwanza, mwanafunzi mwenye alama ya juu zaidi ya jumla ni nambari 6. Wanafunzi nambari 4 na 3 wanafuata,\n    na alama za jumla zinazoshuka. Mwanafunzi nambari 1 ana alama ya jumla ya chini kuliko mwanafunzi nambari 2, lakini ana alama ya juu ya Kichina,\n    hivyo mwanafunzi nambari 1 amewekwa baada ya mwanafunzi nambari 2 katika orodha iliyopangwa.\n    \n    Katika mfano wa pili, wanafunzi nambari 1 na 2 wana alama sawa ya jumla, lakini mwanafunzi nambari 1 ana alama ya juu ya Kichina,\n    hivyo wamewekwa kwanza. Wengine wanapangwa kwa alama zao za jumla zinazoshuka.\n    \"\"\"",
      "tr": "def sort_students(student_scores):\n    \"\"\"\n    Öğrencileri puanlarına göre sıralar. Öğrenciler öncelikle toplam puanlarına göre (azalan),\n    ardından Çince puanlarına göre (azalan) ve son olarak eşitlik durumunda öğrenci numarasına göre (artan) sıralanır.\n    \n    Argümanlar:\n    student_scores (list): Her bir demetin (öğrenci_numarası, toplam_puan, Çince_puanı) içerdiği demetlerden oluşan bir liste.\n    \n    Döndürür:\n    list: Yukarıdaki kurallara göre sıralanmış demetlerden oluşan bir liste.\n    \n    Örnekler:\n    >>> sort_students([(1, 237, 90), (2, 244, 87), (3, 258, 78), (4, 264, 88), (5, 215, 67), (6, 265, 78)])\n    [(6, 265, 78), (4, 264, 88), (3, 258, 78), (2, 244, 87), (1, 237, 90), (5, 215, 67)]\n    \n    >>> sort_students([(1, 300, 100), (2, 300, 99), (3, 299, 98), (4, 298, 97), (5, 297, 96)])\n    [(1, 300, 100), (2, 300, 99), (3, 299, 98), (4, 298, 97), (5, 297, 96)]\n    \n    İlk örnekte, en yüksek toplam puana sahip öğrenci numarası 6'dır. Öğrenci numarası 4 ve 3,\n    azalan toplam puanlarla takip eder. Öğrenci numarası 1, öğrenci numarası 2'den daha düşük toplam puana sahiptir,\n    ancak daha yüksek bir Çince puanına sahiptir, bu yüzden sıralı listede öğrenci numarası 2'den sonra yer alır.\n    \n    İkinci örnekte, öğrenci numarası 1 ve 2 aynı toplam puana sahiptir, ancak öğrenci numarası 1 daha yüksek bir Çince puanına sahiptir,\n    bu yüzden ilk sırada yer alırlar. Geri kalanlar azalan toplam puanlarına göre sıralanmıştır.\n    \"\"\"",
      "vi": "def sort_students(student_scores):\n    \"\"\"\n    Sắp xếp danh sách học sinh dựa trên điểm số của họ. Các học sinh được sắp xếp chủ yếu theo tổng điểm (giảm dần),\n    sau đó theo điểm tiếng Trung (giảm dần), và cuối cùng theo số thứ tự học sinh (tăng dần) trong trường hợp điểm bằng nhau.\n    \n    Tham số:\n    student_scores (list): Một danh sách các bộ giá trị, trong đó mỗi bộ gồm (số thứ tự học sinh, tổng điểm, điểm tiếng Trung).\n    \n    Trả về:\n    list: Một danh sách các bộ giá trị được sắp xếp theo các quy tắc trên.\n    \n    Ví dụ:\n    >>> sort_students([(1, 237, 90), (2, 244, 87), (3, 258, 78), (4, 264, 88), (5, 215, 67), (6, 265, 78)])\n    [(6, 265, 78), (4, 264, 88), (3, 258, 78), (2, 244, 87), (1, 237, 90), (5, 215, 67)]\n    \n    >>> sort_students([(1, 300, 100), (2, 300, 99), (3, 299, 98), (4, 298, 97), (5, 297, 96)])\n    [(1, 300, 100), (2, 300, 99), (3, 299, 98), (4, 298, 97), (5, 297, 96)]\n    \n    Trong ví dụ đầu tiên, học sinh có tổng điểm cao nhất là số 6. Học sinh số 4 và 3 theo sau,\n    với tổng điểm giảm dần. Học sinh số 1 có tổng điểm thấp hơn học sinh số 2, nhưng có điểm tiếng Trung cao hơn,\n    vì vậy học sinh số 1 được xếp sau học sinh số 2 trong danh sách đã sắp xếp.\n    \n    Trong ví dụ thứ hai, học sinh số 1 và 2 có cùng tổng điểm, nhưng học sinh số 1 có điểm tiếng Trung cao hơn,\n    vì vậy họ được xếp trước. Các học sinh còn lại được sắp xếp theo tổng điểm giảm dần.\n    \"\"\""
    },
    "prompt_bertscore": {
      "es": "0.9966155369375466",
      "arb": "0.9722719933290538",
      "sw": "0.9648199773237679",
      "tr": "0.971351341512957",
      "vi": "0.9743748931730701"
    },
    "canonical_solution": "    # Sort the students by the rules: total score, Chinese score, student number\n    sorted_students = sorted(student_scores, key=lambda x: (-x[1], -x[2], x[0]))\n    return sorted_students",
    "instruction": {
      "en": "def sort_students(student_scores):\n    # Sort the students by the rules: total score, Chinese score, student number\n    sorted_students = sorted(student_scores, key=lambda x: (-x[1], -x[2], x[0]))\n    return sorted_students\n\nProvide a concise natural language description (docstring) of the Python code in English using at most 500 characters.",
      "es": "def sort_students(student_scores):\n    # Sort the students by the rules: total score, Chinese score, student number\n    sorted_students = sorted(student_scores, key=lambda x: (-x[1], -x[2], x[0]))\n    return sorted_students\n\nProporcione una descripción concisa en lenguaje natural (docstring) del código Python en español utilizando un máximo de 500 caracteres.",
      "arb": "def sort_students(student_scores):\n    # Sort the students by the rules: total score, Chinese score, student number\n    sorted_students = sorted(student_scores, key=lambda x: (-x[1], -x[2], x[0]))\n    return sorted_students\n\nيرجى تقديم وصف موجز بلغة طبيعية (docstring) للكود البرمجي المكتوب بلغة بايثون باللغة العربية الفصحى، بحيث لا يتجاوز 500 حرف.",
      "sw": "def sort_students(student_scores):\n    # Sort the students by the rules: total score, Chinese score, student number\n    sorted_students = sorted(student_scores, key=lambda x: (-x[1], -x[2], x[0]))\n    return sorted_students\n\nToa maelezo mafupi ya lugha asilia (docstring) ya msimbo wa Python kwa Kiswahili kwa kutumia herufi zisizozidi 500.",
      "tr": "def sort_students(student_scores):\n    # Sort the students by the rules: total score, Chinese score, student number\n    sorted_students = sorted(student_scores, key=lambda x: (-x[1], -x[2], x[0]))\n    return sorted_students\n\nPython kodunun işlevini açıklayan kısa bir doğal dil açıklaması (docstring) sağlayın. Açıklama Türkçe olmalı ve en fazla 500 karakter kullanılmalıdır.",
      "vi": "def sort_students(student_scores):\n    # Sort the students by the rules: total score, Chinese score, student number\n    sorted_students = sorted(student_scores, key=lambda x: (-x[1], -x[2], x[0]))\n    return sorted_students\n\nCung cấp mô tả ngắn gọn bằng ngôn ngữ tự nhiên (docstring) cho mã Python bằng tiếng Việt, không quá 500 ký tự."
    },
    "instruction_bertscore": {
      "es": "0.9687387561112052",
      "arb": "0.906469919330197",
      "sw": "0.9426438884331277",
      "tr": "0.8760401422164142",
      "vi": "0.9159938488400579"
    },
    "level": "",
    "test": "def test_sort_students():\n    # Test case 1\n    input_scores = [(1, 237, 90), (2, 244, 87), (3, 258, 78), (4, 264, 88), (5, 215, 67), (6, 265, 78)]\n    expected_output = [(6, 265, 78), (4, 264, 88), (3, 258, 78), (2, 244, 87), (1, 237, 90), (5, 215, 67)]\n    assert sort_students(input_scores) == expected_output, \"Test case 1 failed\"\n\n    # Test case 2\n    input_scores = [(1, 258, 80), (2, 264, 88), (3, 258, 90), (4, 244, 87), (5, 258, 78), (6, 264, 88), (7, 220, 67), (8, 265, 78)]\n    expected_output = [(8, 265, 78), (2, 264, 88), (6, 264, 88), (3, 258, 90), (1, 258, 80), (5, 258, 78), (4, 244, 87), (7, 220, 67)]\n    assert sort_students(input_scores) == expected_output, \"Test case 2 failed\"\n\n    # Test case 3\n    input_scores = [(1, 300, 100), (2, 300, 100), (3, 299, 99), (4, 298, 98), (5, 297, 97)]\n    expected_output = [(1, 300, 100), (2, 300, 100), (3, 299, 99), (4, 298, 98), (5, 297, 97)]\n    assert sort_students(input_scores) == expected_output, \"Test case 3 failed\"\n\n    print(\"All test cases passed!\")\n\n# Run the test function\ntest_sort_students()",
    "entry_point": "sort_students",
    "signature": "def sort_students(student_scores):",
    "docstring": {
      "en": "Sorts a list of students based on their scores. The students are sorted primarily by their total score (descending),\nthen by their Chinese score (descending), and finally by their student number (ascending) in case of a tie.\n\nArgs:\nstudent_scores (list): A list of tuples, where each tuple consists of (student_number, total_score, Chinese_score).\n\nReturns:\nlist: A list of tuples sorted according to the above rules.\n\nExamples:\n>>> sort_students([(1, 237, 90), (2, 244, 87), (3, 258, 78), (4, 264, 88), (5, 215, 67), (6, 265, 78)])\n[(6, 265, 78), (4, 264, 88), (3, 258, 78), (2, 244, 87), (1, 237, 90), (5, 215, 67)]\n\n>>> sort_students([(1, 300, 100), (2, 300, 99), (3, 299, 98), (4, 298, 97), (5, 297, 96)])\n[(1, 300, 100), (2, 300, 99), (3, 299, 98), (4, 298, 97), (5, 297, 96)]\n\nIn the first example, the student with the highest total score is number 6. Students number 4 and 3 follow,\nwith descending total scores. Student number 1 has a lower total score than student number 2, but a higher Chinese score,\nso student number 1 is placed after student number 2 in the sorted list.\n\nIn the second example, students number 1 and 2 have the same total score, but student number 1 has a higher Chinese score,\nso they are placed first. The rest are sorted by their descending total scores.",
      "es": "Ordena una lista de estudiantes según sus puntajes. Los estudiantes se ordenan principalmente por su puntaje total (descendente), luego por su puntaje en Chino (descendente), y finalmente por su número de estudiante (ascendente) en caso de empate.\n\nArgumentos:\nstudent_scores (list): Una lista de tuplas, donde cada tupla consiste en (número_de_estudiante, puntaje_total, puntaje_Chino).\n\nDevuelve:\nlist: Una lista de tuplas ordenadas de acuerdo con las reglas anteriores.\n\nEjemplos:\n>>> sort_students([(1, 237, 90), (2, 244, 87), (3, 258, 78), (4, 264, 88), (5, 215, 67), (6, 265, 78)])\n[(6, 265, 78), (4, 264, 88), (3, 258, 78), (2, 244, 87), (1, 237, 90), (5, 215, 67)]\n\n>>> sort_students([(1, 300, 100), (2, 300, 99), (3, 299, 98), (4, 298, 97), (5, 297, 96)])\n[(1, 300, 100), (2, 300, 99), (3, 299, 98), (4, 298, 97), (5, 297, 96)]\n\nEn el primer ejemplo, el estudiante con el puntaje total más alto es el número 6. Los estudiantes número 4 y 3 siguen, con puntajes totales descendentes. El estudiante número 1 tiene un puntaje total más bajo que el estudiante número 2, pero un puntaje en Chino más alto, por lo que el estudiante número 1 se coloca después del estudiante número 2 en la lista ordenada.\n\nEn el segundo ejemplo, los estudiantes número 1 y 2 tienen el mismo puntaje total, pero el estudiante número 1 tiene un puntaje en Chino más alto, por lo que se colocan primero. El resto se ordena por sus puntajes totales descendentes.",
      "arb": "يقوم بترتيب قائمة الطلاب بناءً على درجاتهم. يتم ترتيب الطلاب بشكل أساسي حسب مجموع درجاتهم (تنازليًا)، ثم حسب درجاتهم في اللغة الصينية (تنازليًا)، وأخيرًا حسب رقم الطالب (تصاعديًا) في حالة التعادل.\n\nالمعاملات:\nstudent_scores (list): قائمة من الأزواج، حيث يتكون كل زوج من (رقم الطالب، مجموع الدرجات، درجة اللغة الصينية).\n\nالقيم المعادة:\nlist: قائمة من الأزواج مرتبة وفقًا للقواعد المذكورة أعلاه.\n\nأمثلة:\n>>> sort_students([(1, 237, 90), (2, 244, 87), (3, 258, 78), (4, 264, 88), (5, 215, 67), (6, 265, 78)])\n[(6, 265, 78), (4, 264, 88), (3, 258, 78), (2, 244, 87), (1, 237, 90), (5, 215, 67)]\n\n>>> sort_students([(1, 300, 100), (2, 300, 99), (3, 299, 98), (4, 298, 97), (5, 297, 96)])\n[(1, 300, 100), (2, 300, 99), (3, 299, 98), (4, 298, 97), (5, 297, 96)]\n\nفي المثال الأول، الطالب الذي لديه أعلى مجموع درجات هو رقم 6. يتبعه الطلاب رقم 4 و3، مع مجموع درجات تنازلي. الطالب رقم 1 لديه مجموع درجات أقل من الطالب رقم 2، ولكن درجة أعلى في اللغة الصينية، لذلك يتم وضع الطالب رقم 1 بعد الطالب رقم 2 في القائمة المرتبة.\n\nفي المثال الثاني، الطلاب رقم 1 و2 لديهم نفس مجموع الدرجات، ولكن الطالب رقم 1 لديه درجة أعلى في اللغة الصينية، لذلك يتم وضعهم أولاً. الباقي يتم ترتيبهم حسب مجموع درجاتهم التنازلي.",
      "sw": "Hupanga orodha ya wanafunzi kulingana na alama zao. Wanafunzi wanapangwa kimsingi kwa alama zao za jumla (kutoka juu kwenda chini), kisha kwa alama zao za Kichina (kutoka juu kwenda chini), na hatimaye kwa nambari zao za mwanafunzi (kutoka chini kwenda juu) ikiwa kuna sare.\n\nHoja:\nstudent_scores (list): Orodha ya jozi, ambapo kila jozi inajumuisha (nambari ya mwanafunzi, alama ya jumla, alama ya Kichina).\n\nInarejesha:\nlist: Orodha ya jozi zilizopangwa kulingana na sheria zilizo hapo juu.\n\nMifano:\n>>> sort_students([(1, 237, 90), (2, 244, 87), (3, 258, 78), (4, 264, 88), (5, 215, 67), (6, 265, 78)])\n[(6, 265, 78), (4, 264, 88), (3, 258, 78), (2, 244, 87), (1, 237, 90), (5, 215, 67)]\n\n>>> sort_students([(1, 300, 100), (2, 300, 99), (3, 299, 98), (4, 298, 97), (5, 297, 96)])\n[(1, 300, 100), (2, 300, 99), (3, 299, 98), (4, 298, 97), (5, 297, 96)]\n\nKatika mfano wa kwanza, mwanafunzi mwenye alama ya juu kabisa ya jumla ni nambari 6. Wanafunzi nambari 4 na 3 wanafuata, na alama za jumla zinazopungua. Mwanafunzi nambari 1 ana alama ya jumla ya chini kuliko mwanafunzi nambari 2, lakini ana alama ya juu ya Kichina, hivyo mwanafunzi nambari 1 amewekwa baada ya mwanafunzi nambari 2 katika orodha iliyopangwa.\n\nKatika mfano wa pili, wanafunzi nambari 1 na 2 wana alama sawa ya jumla, lakini mwanafunzi nambari 1 ana alama ya juu ya Kichina, hivyo wamewekwa kwanza. Wengine wanapangwa kwa alama zao za jumla zinazopungua.",
      "tr": "Öğrencilerin puanlarına göre bir listeyi sıralar. Öğrenciler öncelikle toplam puanlarına göre (azalan), ardından Çince puanlarına göre (azalan) ve son olarak eşitlik durumunda öğrenci numaralarına göre (artan) sıralanır.\n\nArgümanlar:\nstudent_scores (list): Her bir demetin (öğrenci_numarası, toplam_puan, Çince_puan) içerdiği demetlerin bir listesi.\n\nDöndürür:\nlist: Yukarıdaki kurallara göre sıralanmış demetlerin bir listesi.\n\nÖrnekler:\n>>> sort_students([(1, 237, 90), (2, 244, 87), (3, 258, 78), (4, 264, 88), (5, 215, 67), (6, 265, 78)])\n[(6, 265, 78), (4, 264, 88), (3, 258, 78), (2, 244, 87), (1, 237, 90), (5, 215, 67)]\n\n>>> sort_students([(1, 300, 100), (2, 300, 99), (3, 299, 98), (4, 298, 97), (5, 297, 96)])\n[(1, 300, 100), (2, 300, 99), (3, 299, 98), (4, 298, 97), (5, 297, 96)]\n\nİlk örnekte, en yüksek toplam puana sahip öğrenci numarası 6'dır. Öğrenci numaraları 4 ve 3, azalan toplam puanlarla takip eder. Öğrenci numarası 1, öğrenci numarası 2'den daha düşük bir toplam puana sahiptir, ancak daha yüksek bir Çince puana sahiptir, bu nedenle sıralı listede öğrenci numarası 2'nin ardından yer alır.\n\nİkinci örnekte, öğrenci numaraları 1 ve 2 aynı toplam puana sahiptir, ancak öğrenci numarası 1 daha yüksek bir Çince puana sahiptir, bu nedenle ilk sırada yer alırlar. Geri kalanlar, azalan toplam puanlarına göre sıralanır.",
      "vi": "Sắp xếp danh sách sinh viên dựa trên điểm số của họ. Sinh viên được sắp xếp chủ yếu theo tổng điểm (giảm dần), sau đó theo điểm tiếng Trung (giảm dần), và cuối cùng theo số hiệu sinh viên (tăng dần) trong trường hợp hòa.\n\nTham số:\nstudent_scores (list): Một danh sách các bộ giá trị, trong đó mỗi bộ giá trị bao gồm (số hiệu sinh viên, tổng điểm, điểm tiếng Trung).\n\nTrả về:\nlist: Một danh sách các bộ giá trị được sắp xếp theo các quy tắc trên.\n\nVí dụ:\n>>> sort_students([(1, 237, 90), (2, 244, 87), (3, 258, 78), (4, 264, 88), (5, 215, 67), (6, 265, 78)])\n[(6, 265, 78), (4, 264, 88), (3, 258, 78), (2, 244, 87), (1, 237, 90), (5, 215, 67)]\n\n>>> sort_students([(1, 300, 100), (2, 300, 99), (3, 299, 98), (4, 298, 97), (5, 297, 96)])\n[(1, 300, 100), (2, 300, 99), (3, 299, 98), (4, 298, 97), (5, 297, 96)]\n\nTrong ví dụ đầu tiên, sinh viên có tổng điểm cao nhất là số 6. Sinh viên số 4 và 3 theo sau, với tổng điểm giảm dần. Sinh viên số 1 có tổng điểm thấp hơn sinh viên số 2, nhưng điểm tiếng Trung cao hơn, vì vậy sinh viên số 1 được xếp sau sinh viên số 2 trong danh sách đã sắp xếp.\n\nTrong ví dụ thứ hai, sinh viên số 1 và 2 có cùng tổng điểm, nhưng sinh viên số 1 có điểm tiếng Trung cao hơn, vì vậy họ được xếp đầu tiên. Những người còn lại được sắp xếp theo tổng điểm giảm dần của họ."
    },
    "docstring_bertscore": {
      "es": "0.9909607286198643",
      "arb": "0.9715378554407488",
      "sw": "0.9690418660726644",
      "tr": "0.9783461103811006",
      "vi": "0.9735918922110306"
    }
  },
  {
    "task_id": "Python/48",
    "prompt": {
      "en": "def min_groups(w, n, prices):\n    \"\"\"\n    Determines the minimum number of groups needed to distribute souvenirs with a constraint on the group's total price.\n    \n    The souvenirs are grouped in pairs such that the total price of each group does not exceed the limit `w`. \n    The function aims to minimize the number of groups created under this constraint.\n    \n    Args:\n    w (int): The maximum allowed sum of prices for any group of souvenirs.\n    n (int): The total number of souvenirs.\n    prices (list): A list of integers representing the price of each souvenir.\n    \n    Returns:\n    int: The minimum number of groups required to distribute all souvenirs.\n\n    Examples:\n    \n    Case 1:\n    A limit of 100 and 9 souvenirs with prices [90, 20, 20, 30, 50, 60, 70, 80, 90].\n    The minimum number of groups is 6.\n    >>> min_groups(100, 9, [90, 20, 20, 30, 50, 60, 70, 80, 90])\n    6\n    \n    Case 2:\n    A limit of 200 and 5 souvenirs with prices [80, 120, 60, 40, 100].\n    The minimum number of groups is 3.\n    >>> min_groups(200, 5, [80, 120, 60, 40, 100])\n    3\n    \n    Case 3:\n    A limit of 80 and 4 souvenirs with prices [30, 30, 20, 10].\n    Since each pair's total price does not exceed the limit, the minimum number of groups is 2.\n    >>> min_groups(80, 4, [30, 30, 20, 10])\n    2\n    \"\"\"",
      "es": "def min_groups(w, n, prices):\n    \"\"\"\n    Determina el número mínimo de grupos necesarios para distribuir los souvenirs con una restricción en el precio total del grupo.\n    \n    Los souvenirs se agrupan en pares de manera que el precio total de cada grupo no exceda el límite `w`. \n    La función busca minimizar el número de grupos creados bajo esta restricción.\n    \n    Argumentos:\n    w (int): La suma máxima permitida de precios para cualquier grupo de souvenirs.\n    n (int): El número total de souvenirs.\n    prices (list): Una lista de enteros que representa el precio de cada souvenir.\n    \n    Devuelve:\n    int: El número mínimo de grupos necesarios para distribuir todos los souvenirs.\n\n    Ejemplos:\n    \n    Caso 1:\n    Un límite de 100 y 9 souvenirs con precios [90, 20, 20, 30, 50, 60, 70, 80, 90].\n    El número mínimo de grupos es 6.\n    >>> min_groups(100, 9, [90, 20, 20, 30, 50, 60, 70, 80, 90])\n    6\n    \n    Caso 2:\n    Un límite de 200 y 5 souvenirs con precios [80, 120, 60, 40, 100].\n    El número mínimo de grupos es 3.\n    >>> min_groups(200, 5, [80, 120, 60, 40, 100])\n    3\n    \n    Caso 3:\n    Un límite de 80 y 4 souvenirs con precios [30, 30, 20, 10].\n    Dado que el precio total de cada par no excede el límite, el número mínimo de grupos es 2.\n    >>> min_groups(80, 4, [30, 30, 20, 10])\n    2\n    \"\"\"",
      "arb": "def min_groups(w, n, prices):\n    \"\"\"\n    يحدد الحد الأدنى لعدد المجموعات اللازمة لتوزيع التذكارات مع وجود قيد على السعر الإجمالي للمجموعة.\n\n    يتم تجميع التذكارات في أزواج بحيث لا يتجاوز السعر الإجمالي لكل مجموعة الحد `w`.\n    تهدف الدالة إلى تقليل عدد المجموعات التي تم إنشاؤها تحت هذا القيد.\n\n    يعيدالحجج:\n    w (int): الحد الأقصى المسموح به لمجموع أسعار أي مجموعة من التذكارات.\n    n (int): العدد الإجمالي للتذكارات.\n    prices (list): قائمة من الأعداد الصحيحة تمثل سعر كل تذكار.\n\n    يعيد:\n    int: الحد الأدنى لعدد المجموعات المطلوبة لتوزيع جميع التذكارات.\n\n    أمثلة:\n\n    الحالة 1:\n    حد 100 و 9 تذكارات بأسعار [90, 20, 20, 30, 50, 60, 70, 80, 90].\n    الحد الأدنى لعدد المجموعات هو 6.\n    >>> min_groups(100, 9, [90, 20, 20, 30, 50, 60, 70, 80, 90])\n    6\n\n    الحالة 2:\n    حد 200 و 5 تذكارات بأسعار [80, 120, 60, 40, 100].\n    الحد الأدنى لعدد المجموعات هو 3.\n    >>> min_groups(200, 5, [80, 120, 60, 40, 100])\n    3\n\n    الحالة 3:\n    حد 80 و 4 تذكارات بأسعار [30, 30, 20, 10].\n    بما أن السعر الإجمالي لكل زوج لا يتجاوز الحد، فإن الحد الأدنى لعدد المجموعات هو 2.\n    >>> min_groups(80, 4, [30, 30, 20, 10])\n    2\n    \"\"\"",
      "sw": "def min_groups(w, n, prices):\n    \"\"\"\n    Huamua idadi ndogo ya vikundi vinavyohitajika kugawa zawadi kwa kizuizi cha jumla ya bei ya kikundi.\n    \n    Zawadi zimepangwa katika jozi ili jumla ya bei ya kila kikundi isizidi kikomo `w`. \n    Kazi hii inalenga kupunguza idadi ya vikundi vilivyoundwa chini ya kizuizi hiki.\n    \n    Hoja:\n    w (int): Jumla ya juu inayoruhusiwa ya bei kwa kikundi chochote cha zawadi.\n    n (int): Jumla ya zawadi.\n    prices (list): Orodha ya namba za mzima zinazoonyesha bei ya kila zawadi.\n    \n    Inarejesha:\n    int: Idadi ndogo ya vikundi vinavyohitajika kugawa zawadi zote.\n\n    Mifano:\n    \n    Kesi 1:\n    Kikomo cha 100 na zawadi 9 zenye bei [90, 20, 20, 30, 50, 60, 70, 80, 90].\n    Idadi ndogo ya vikundi ni 6.\n    >>> min_groups(100, 9, [90, 20, 20, 30, 50, 60, 70, 80, 90])\n    6\n    \n    Kesi 2:\n    Kikomo cha 200 na zawadi 5 zenye bei [80, 120, 60, 40, 100].\n    Idadi ndogo ya vikundi ni 3.\n    >>> min_groups(200, 5, [80, 120, 60, 40, 100])\n    3\n    \n    Kesi 3:\n    Kikomo cha 80 na zawadi 4 zenye bei [30, 30, 20, 10].\n    Kwa kuwa jumla ya bei ya kila jozi haizidi kikomo, idadi ndogo ya vikundi ni 2.\n    >>> min_groups(80, 4, [30, 30, 20, 10])\n    2\n    \"\"\"",
      "tr": "def min_groups(w, n, prices):\n    \"\"\"\n    Bir grubun toplam fiyatı üzerinde bir kısıtlama ile hediyelik eşyaları dağıtmak için gereken minimum grup sayısını belirler.\n    \n    Hediyelik eşyalar, her grubun toplam fiyatı `w` limitini aşmayacak şekilde çiftler halinde gruplanır.\n    Fonksiyon, bu kısıtlama altında oluşturulan grup sayısını en aza indirmeyi amaçlar.\n    \n    Argümanlar:\n    w (int): Herhangi bir hediyelik eşya grubunun izin verilen maksimum fiyat toplamı.\n    n (int): Toplam hediyelik eşya sayısı.\n    prices (list): Her hediyelik eşyanın fiyatını temsil eden bir tamsayı listesi.\n    \n    Döndürür:\n    int: Tüm hediyelik eşyaları dağıtmak için gereken minimum grup sayısı.\n\n    Örnekler:\n    \n    Durum 1:\n    100 limiti ve fiyatları [90, 20, 20, 30, 50, 60, 70, 80, 90] olan 9 hediyelik eşya.\n    Minimum grup sayısı 6'dır.\n    >>> min_groups(100, 9, [90, 20, 20, 30, 50, 60, 70, 80, 90])\n    6\n    \n    Durum 2:\n    200 limiti ve fiyatları [80, 120, 60, 40, 100] olan 5 hediyelik eşya.\n    Minimum grup sayısı 3'tür.\n    >>> min_groups(200, 5, [80, 120, 60, 40, 100])\n    3\n    \n    Durum 3:\n    80 limiti ve fiyatları [30, 30, 20, 10] olan 4 hediyelik eşya.\n    Her çiftin toplam fiyatı limiti aşmadığından, minimum grup sayısı 2'dir.\n    >>> min_groups(80, 4, [30, 30, 20, 10])\n    2\n    \"\"\"",
      "vi": "def min_groups(w, n, prices):\n    \"\"\"\n    Xác định số nhóm tối thiểu cần thiết để phân phối quà lưu niệm với một giới hạn về tổng giá của nhóm.\n    \n    Các quà lưu niệm được nhóm thành cặp sao cho tổng giá của mỗi nhóm không vượt quá giới hạn `w`. \n    Hàm này nhằm mục đích giảm thiểu số lượng nhóm được tạo ra dưới giới hạn này.\n    \n    Tham số:\n    w (int): Tổng giá tối đa được phép cho bất kỳ nhóm quà lưu niệm nào.\n    n (int): Tổng số quà lưu niệm.\n    prices (list): Một danh sách các số nguyên đại diện cho giá của mỗi quà lưu niệm.\n    \n    Trả về:\n    int: Số lượng nhóm tối thiểu cần thiết để phân phối tất cả quà lưu niệm.\n\n    Ví dụ:\n    \n    Trường hợp 1:\n    Giới hạn là 100 và 9 quà lưu niệm với giá [90, 20, 20, 30, 50, 60, 70, 80, 90].\n    Số lượng nhóm tối thiểu là 6.\n    >>> min_groups(100, 9, [90, 20, 20, 30, 50, 60, 70, 80, 90])\n    6\n    \n    Trường hợp 2:\n    Giới hạn là 200 và 5 quà lưu niệm với giá [80, 120, 60, 40, 100].\n    Số lượng nhóm tối thiểu là 3.\n    >>> min_groups(200, 5, [80, 120, 60, 40, 100])\n    3\n    \n    Trường hợp 3:\n    Giới hạn là 80 và 4 quà lưu niệm với giá [30, 30, 20, 10].\n    Vì tổng giá của mỗi cặp không vượt quá giới hạn, số lượng nhóm tối thiểu là 2.\n    >>> min_groups(80, 4, [30, 30, 20, 10])\n    2\n    \"\"\""
    },
    "prompt_bertscore": {
      "es": "0.9810742986646148",
      "arb": "0.9801210714660283",
      "sw": "0.93580762660905",
      "tr": "0.9576845781458515",
      "vi": "0.9652394846885135"
    },
    "canonical_solution": "    prices.sort()  # Sort the prices in ascending order\n    groups = 0\n    left = 0  # Pointer to the cheapest souvenir\n    right = n - 1  # Pointer to the most expensive souvenir\n\n    while left <= right:\n        if prices[left] + prices[right] <= w:\n            # If the cheapest and the most expensive can be paired, do so\n            left += 1\n        # Whether paired or not, the most expensive souvenir forms a group\n        right -= 1\n        groups += 1\n\n    return groups",
    "instruction": {
      "en": "def min_groups(w, n, prices):\n    prices.sort()  # Sort the prices in ascending order\n    groups = 0\n    left = 0  # Pointer to the cheapest souvenir\n    right = n - 1  # Pointer to the most expensive souvenir\n\n    while left <= right:\n        if prices[left] + prices[right] <= w:\n            # If the cheapest and the most expensive can be paired, do so\n            left += 1\n        # Whether paired or not, the most expensive souvenir forms a group\n        right -= 1\n        groups += 1\n\n    return groups\n\nProvide a concise natural language description (docstring) of the Python code in English using at most 500 characters.",
      "es": "def min_groups(w, n, prices):\n    prices.sort()  # Sort the prices in ascending order\n    groups = 0\n    left = 0  # Pointer to the cheapest souvenir\n    right = n - 1  # Pointer to the most expensive souvenir\n\n    while left <= right:\n        if prices[left] + prices[right] <= w:\n            # If the cheapest and the most expensive can be paired, do so\n            left += 1\n        # Whether paired or not, the most expensive souvenir forms a group\n        right -= 1\n        groups += 1\n\n    return groups\n\nProporcione una descripción concisa en lenguaje natural (docstring) del código Python en español utilizando un máximo de 500 caracteres.",
      "arb": "def min_groups(w, n, prices):\n    prices.sort()  # Sort the prices in ascending order\n    groups = 0\n    left = 0  # Pointer to the cheapest souvenir\n    right = n - 1  # Pointer to the most expensive souvenir\n\n    while left <= right:\n        if prices[left] + prices[right] <= w:\n            # If the cheapest and the most expensive can be paired, do so\n            left += 1\n        # Whether paired or not, the most expensive souvenir forms a group\n        right -= 1\n        groups += 1\n\n    return groups\n\nقم بتقديم وصف موجز بلغة طبيعية (docstring) للشفرة البرمجية بلغة بايثون باللغة العربية الفصحى باستخدام 500 حرف كحد أقصى.",
      "sw": "def min_groups(w, n, prices):\n    prices.sort()  # Sort the prices in ascending order\n    groups = 0\n    left = 0  # Pointer to the cheapest souvenir\n    right = n - 1  # Pointer to the most expensive souvenir\n\n    while left <= right:\n        if prices[left] + prices[right] <= w:\n            # If the cheapest and the most expensive can be paired, do so\n            left += 1\n        # Whether paired or not, the most expensive souvenir forms a group\n        right -= 1\n        groups += 1\n\n    return groups\n\nToa maelezo mafupi ya lugha ya asili (docstring) ya msimbo wa Python kwa Kiswahili kwa kutumia herufi zisizozidi 500.",
      "tr": "def min_groups(w, n, prices):\n    prices.sort()  # Sort the prices in ascending order\n    groups = 0\n    left = 0  # Pointer to the cheapest souvenir\n    right = n - 1  # Pointer to the most expensive souvenir\n\n    while left <= right:\n        if prices[left] + prices[right] <= w:\n            # If the cheapest and the most expensive can be paired, do so\n            left += 1\n        # Whether paired or not, the most expensive souvenir forms a group\n        right -= 1\n        groups += 1\n\n    return groups\n\nVerilen Python kodunun işlevini açıklayan, en fazla 500 karakter uzunluğunda özlü bir doğal dil açıklaması (docstring) sağlayın.",
      "vi": "def min_groups(w, n, prices):\n    prices.sort()  # Sort the prices in ascending order\n    groups = 0\n    left = 0  # Pointer to the cheapest souvenir\n    right = n - 1  # Pointer to the most expensive souvenir\n\n    while left <= right:\n        if prices[left] + prices[right] <= w:\n            # If the cheapest and the most expensive can be paired, do so\n            left += 1\n        # Whether paired or not, the most expensive souvenir forms a group\n        right -= 1\n        groups += 1\n\n    return groups\n\nCung cấp mô tả ngắn gọn bằng ngôn ngữ tự nhiên (docstring) cho mã Python bằng tiếng Việt, sử dụng tối đa 500 ký tự."
    },
    "instruction_bertscore": {
      "es": "0.9687387561112052",
      "arb": "0.9379774648914752",
      "sw": "0.914896018724078",
      "tr": "0.8406654617667679",
      "vi": "0.9069722555638342"
    },
    "level": "",
    "test": "def test_min_groups():\n    # Test case 1\n    w1 = 100\n    n1 = 9\n    prices1 = [90, 20, 20, 30, 50, 60, 70, 80, 90]\n    expected_output1 = 6\n    assert min_groups(w1, n1, prices1) == expected_output1, \"Test case 1 failed\"\n\n    # Test case 2\n    w2 = 200\n    n2 = 5\n    prices2 = [80, 120, 60, 40, 100]\n    expected_output2 = 3\n    assert min_groups(w2, n2, prices2) == expected_output2, \"Test case 2 failed\"\n\n    # Test case 3\n    w3 = 80\n    n3 = 4\n    prices3 = [30, 30, 20, 10]\n    expected_output3 = 2\n    assert min_groups(w3, n3, prices3) == expected_output3, \"Test case 3 failed\"\n\n    print(\"All test cases passed!\")\n\n# Run the test function\ntest_min_groups()",
    "entry_point": "min_groups",
    "signature": "def min_groups(w, n, prices):",
    "docstring": {
      "en": "Determines the minimum number of groups needed to distribute souvenirs with a constraint on the group's total price.\n\nThe souvenirs are grouped in pairs such that the total price of each group does not exceed the limit `w`.\nThe function aims to minimize the number of groups created under this constraint.\n\nArgs:\nw (int): The maximum allowed sum of prices for any group of souvenirs.\nn (int): The total number of souvenirs.\nprices (list): A list of integers representing the price of each souvenir.\n\nReturns:\nint: The minimum number of groups required to distribute all souvenirs.\n\nExamples:\n\nCase 1:\nA limit of 100 and 9 souvenirs with prices [90, 20, 20, 30, 50, 60, 70, 80, 90].\nThe minimum number of groups is 6.\n>>> min_groups(100, 9, [90, 20, 20, 30, 50, 60, 70, 80, 90])\n6\n\nCase 2:\nA limit of 200 and 5 souvenirs with prices [80, 120, 60, 40, 100].\nThe minimum number of groups is 3.\n>>> min_groups(200, 5, [80, 120, 60, 40, 100])\n3\n\nCase 3:\nA limit of 80 and 4 souvenirs with prices [30, 30, 20, 10].\nSince each pair's total price does not exceed the limit, the minimum number of groups is 2.\n>>> min_groups(80, 4, [30, 30, 20, 10])\n2",
      "es": "Determina el número mínimo de grupos necesarios para distribuir souvenirs con una restricción en el precio total del grupo.\n\nLos souvenirs se agrupan en pares de manera que el precio total de cada grupo no exceda el límite `w`. La función tiene como objetivo minimizar el número de grupos creados bajo esta restricción.\n\nArgumentos:\nw (int): La suma máxima permitida de precios para cualquier grupo de souvenirs.\nn (int): El número total de souvenirs.\nprices (list): Una lista de enteros que representa el precio de cada souvenir.\n\nDevuelve:\nint: El número mínimo de grupos necesarios para distribuir todos los souvenirs.\n\nEjemplos:\n\nCaso 1:\nUn límite de 100 y 9 souvenirs con precios [90, 20, 20, 30, 50, 60, 70, 80, 90]. El número mínimo de grupos es 6.\n>>> min_groups(100, 9, [90, 20, 20, 30, 50, 60, 70, 80, 90])\n6\n\nCaso 2:\nUn límite de 200 y 5 souvenirs con precios [80, 120, 60, 40, 100]. El número mínimo de grupos es 3.\n>>> min_groups(200, 5, [80, 120, 60, 40, 100])\n3\n\nCaso 3:\nUn límite de 80 y 4 souvenirs con precios [30, 30, 20, 10]. Dado que el precio total de cada par no excede el límite, el número mínimo de grupos es 2.\n>>> min_groups(80, 4, [30, 30, 20, 10])\n2",
      "arb": "يحدد الحد الأدنى لعدد المجموعات اللازمة لتوزيع التذكارات مع وجود قيد على السعر الإجمالي للمجموعة.\n\nيتم تجميع التذكارات في أزواج بحيث لا يتجاوز السعر الإجمالي لكل مجموعة الحد `w`.\nتهدف الدالة إلى تقليل عدد المجموعات التي تم إنشاؤها تحت هذا القيد.\n\nيعيدالحجج:\nw (int): الحد الأقصى المسموح به لمجموع أسعار أي مجموعة من التذكارات.\nn (int): العدد الإجمالي للتذكارات.\nprices (list): قائمة من الأعداد الصحيحة تمثل سعر كل تذكار.\n\nيعيد:\nint: الحد الأدنى لعدد المجموعات المطلوبة لتوزيع جميع التذكارات.\n\nامثله:\n\nالحالة 1:\nحد 100 و 9 تذكارات بأسعار [90, 20, 20, 30, 50, 60, 70, 80, 90].\nالحد الأدنى لعدد المجموعات هو 6.\n>>> min_groups(100, 9, [90, 20, 20, 30, 50, 60, 70, 80, 90])\n6\n\nالحالة 2:\nحد 200 و 5 تذكارات بأسعار [80, 120, 60, 40, 100].\nالحد الأدنى لعدد المجموعات هو 3.\n>>> min_groups(200, 5, [80, 120, 60, 40, 100])\n3\n\nالحالة 3:\nحد 80 و 4 تذكارات بأسعار [30, 30, 20, 10].\nبما أن السعر الإجمالي لكل زوج لا يتجاوز الحد، فإن الحد الأدنى لعدد المجموعات هو 2.\n>>> min_groups(80, 4, [30, 30, 20, 10])\n2",
      "sw": "Inabainisha idadi ndogo ya vikundi vinavyohitajika kusambaza zawadi zikiwa na kizuizi kwenye jumla ya bei ya kikundi.\n\nZawadi zimepangwa katika jozi ili jumla ya bei ya kila kikundi isizidi kikomo `w`. \nKazi inalenga kupunguza idadi ya vikundi vilivyoundwa chini ya kizuizi hiki.\n\nHoja:\nw (int): Jumla ya juu inayoruhusiwa ya bei kwa kikundi chochote cha zawadi.\nn (int): Jumla ya idadi ya zawadi.\nprices (list): Orodha ya namba nzima inayoonyesha bei ya kila zawadi.\n\nInarejesha:\nint: Idadi ndogo ya vikundi vinavyohitajika kusambaza zawadi zote.\n\nMifano:\n\nKesi 1:\nKikomo cha 100 na zawadi 9 zenye bei [90, 20, 20, 30, 50, 60, 70, 80, 90].\nIdadi ndogo ya vikundi ni 6.\n>>> min_groups(100, 9, [90, 20, 20, 30, 50, 60, 70, 80, 90])\n6\n\nKesi 2:\nKikomo cha 200 na zawadi 5 zenye bei [80, 120, 60, 40, 100].\nIdadi ndogo ya vikundi ni 3.\n>>> min_groups(200, 5, [80, 120, 60, 40, 100])\n3\n\nKesi 3:\nKikomo cha 80 na zawadi 4 zenye bei [30, 30, 20, 10].\nKwa kuwa jumla ya bei ya kila jozi haizidi kikomo, idadi ndogo ya vikundi ni 2.\n>>> min_groups(80, 4, [30, 30, 20, 10])\n2",
      "tr": "Hatıra eşyalarını, grubun toplam fiyatı üzerinde bir kısıtlama ile dağıtmak için gereken minimum grup sayısını belirler.\n\nHatıra eşyaları, her grubun toplam fiyatı `w` limitini aşmayacak şekilde çiftler halinde gruplanır. Fonksiyon, bu kısıtlama altında oluşturulan grup sayısını en aza indirmeyi amaçlar.\n\nArgümanlar:\nw (int): Herhangi bir hatıra grubu için izin verilen maksimum fiyat toplamı.\nn (int): Toplam hatıra sayısı.\nprices (list): Her bir hatıranın fiyatını temsil eden tamsayıların listesi.\n\nDöndürür:\nint: Tüm hatıraları dağıtmak için gereken minimum grup sayısı.\n\nÖrnekler:\n\nDurum 1:\n100 limiti ve fiyatları [90, 20, 20, 30, 50, 60, 70, 80, 90] olan 9 hatıra.\nMinimum grup sayısı 6'dır.\n>>> min_groups(100, 9, [90, 20, 20, 30, 50, 60, 70, 80, 90])\n6\n\nDurum 2:\n200 limiti ve fiyatları [80, 120, 60, 40, 100] olan 5 hatıra.\nMinimum grup sayısı 3'tür.\n>>> min_groups(200, 5, [80, 120, 60, 40, 100])\n3\n\nDurum 3:\n80 limiti ve fiyatları [30, 30, 20, 10] olan 4 hatıra.\nHer çiftin toplam fiyatı limiti aşmadığından, minimum grup sayısı 2'dir.\n>>> min_groups(80, 4, [30, 30, 20, 10])\n2",
      "vi": "Xác định số lượng nhóm tối thiểu cần thiết để phân phối quà lưu niệm với một giới hạn về tổng giá của nhóm.\n\nCác quà lưu niệm được nhóm thành cặp sao cho tổng giá của mỗi nhóm không vượt quá giới hạn `w`. Hàm này nhằm mục đích giảm thiểu số lượng nhóm được tạo ra dưới giới hạn này.\n\nTham số:\nw (int): Tổng giá tối đa được phép cho bất kỳ nhóm quà lưu niệm nào.\nn (int): Tổng số quà lưu niệm.\nprices (list): Một danh sách các số nguyên đại diện cho giá của mỗi quà lưu niệm.\n\nTrả về:\nint: Số lượng nhóm tối thiểu cần thiết để phân phối tất cả quà lưu niệm.\n\nVí dụ:\n\nTrường hợp 1:\nGiới hạn là 100 và 9 quà lưu niệm với giá [90, 20, 20, 30, 50, 60, 70, 80, 90].\nSố lượng nhóm tối thiểu là 6.\n>>> min_groups(100, 9, [90, 20, 20, 30, 50, 60, 70, 80, 90])\n6\n\nTrường hợp 2:\nGiới hạn là 200 và 5 quà lưu niệm với giá [80, 120, 60, 40, 100].\nSố lượng nhóm tối thiểu là 3.\n>>> min_groups(200, 5, [80, 120, 60, 40, 100])\n3\n\nTrường hợp 3:\nGiới hạn là 80 và 4 quà lưu niệm với giá [30, 30, 20, 10].\nVì tổng giá của mỗi cặp không vượt quá giới hạn, số lượng nhóm tối thiểu là 2.\n>>> min_groups(80, 4, [30, 30, 20, 10])\n2"
    },
    "docstring_bertscore": {
      "es": "0.9872397856919377",
      "arb": "0.9821415397019153",
      "sw": "0.9447340759327579",
      "tr": "0.9654863822521399",
      "vi": "0.9720235067223791"
    }
  },
  {
    "task_id": "Python/49",
    "prompt": {
      "en": "def hanoi_double_iterative(n: int) -> int:\n    \"\"\"\n    Calculate the minimum number of moves required to solve the double-disc Hanoi Towers problem for n pairs of discs.\n    \n    This function implements an iterative algorithm to determine the minimum number of moves necessary to transfer\n    2n discs from the A pole to the C pole in a double-disc Hanoi Towers setup, following the rules that only one disc \n    can be moved at a time and no disc may be placed on top of a smaller disc. The function uses a known recursive relation \n    and iteratively computes the total number of moves for n pairs of discs.\n    \n    Args:\n    n (int): The number of disc pairs (each of two identical discs) on the A pole.\n\n    Returns:\n    int: The minimum number of moves required to transfer all the discs from the A pole to the C pole.\n\n    Cases:\n    - For n=1, the function should return 2, since there are two identical discs that can be moved in two moves.\n    - For n=2, the function should return 6, as it takes 2 moves for the first pair and then 4 more moves for the second pair.\n    - For n=3, the function should return 14, which is the result of the iterative process: 2 moves for the first pair, \n      4 more for the second, and then 8 additional moves for the third pair.\n    \"\"\"\n    moves = 2\n    for i in range(2, n + 1):\n        moves = 2 * moves + 2\n    return moves",
      "es": "def hanoi_double_iterative(n: int) -> int:\n    \"\"\"\n    Calcula el número mínimo de movimientos necesarios para resolver el problema de las Torres de Hanoi de doble disco para n pares de discos.\n    \n    Esta función implementa un algoritmo iterativo para determinar el número mínimo de movimientos necesarios para transferir\n    2n discos del poste A al poste C en una configuración de Torres de Hanoi de doble disco, siguiendo las reglas de que solo un disco \n    puede moverse a la vez y ningún disco puede colocarse sobre un disco más pequeño. La función utiliza una relación recursiva conocida \n    y calcula iterativamente el número total de movimientos para n pares de discos.\n    \n    Argumentos:\n    n (int): El número de pares de discos (cada uno de dos discos idénticos) en el poste A.\n\n    Devuelve:\n    int: El número mínimo de movimientos necesarios para transferir todos los discos del poste A al poste C.\n\n    Casos:\n    - Para n=1, la función debe devolver 2, ya que hay dos discos idénticos que pueden moverse en dos movimientos.\n    - Para n=2, la función debe devolver 6, ya que se necesitan 2 movimientos para el primer par y luego 4 movimientos más para el segundo par.\n    - Para n=3, la función debe devolver 14, que es el resultado del proceso iterativo: 2 movimientos para el primer par, \n      4 más para el segundo, y luego 8 movimientos adicionales para el tercer par.\n    \"\"\"\n    moves = 2\n    for i in range(2, n + 1):\n        moves = 2 * moves + 2\n    return moves",
      "arb": "def hanoi_double_iterative(n: int) -> int:\n    \"\"\"\n    حساب الحد الأدنى لعدد الحركات المطلوبة لحل مشكلة أبراج هانوي ذات الأقراص المزدوجة لعدد n من أزواج الأقراص.\n    \n    تقوم هذه الدالة بتطبيق خوارزمية تكرارية لتحديد الحد الأدنى لعدد الحركات اللازمة لنقل 2n قرصًا من العمود A إلى العمود C\n    في إعداد أبراج هانوي ذات الأقراص المزدوجة، مع اتباع القواعد التي تنص على أنه لا يمكن نقل سوى قرص واحد في كل مرة\n    ولا يجوز وضع قرص فوق قرص أصغر منه. تستخدم الدالة علاقة تكرارية معروفة وتحسب بشكل تكراري العدد الإجمالي للحركات\n    لعدد n من أزواج الأقراص.\n    \n    يعيدالحجج:\n    n (int): عدد أزواج الأقراص (كل زوج يتكون من قرصين متطابقين) على العمود A.\n\n    يعيد:\n    int: الحد الأدنى لعدد الحركات المطلوبة لنقل جميع الأقراص من العمود A إلى العمود C.\n\n    حالات:\n    - بالنسبة لـ n=1، يجب أن تعيد الدالة 2، حيث يوجد قرصان متطابقان يمكن نقلهما في حركتين.\n    - بالنسبة لـ n=2، يجب أن تعيد الدالة 6، حيث يتطلب الأمر حركتين للزوج الأول ثم 4 حركات إضافية للزوج الثاني.\n    - بالنسبة لـ n=3، يجب أن تعيد الدالة 14، وهو نتيجة العملية التكرارية: حركتان للزوج الأول، \n      4 حركات إضافية للزوج الثاني، ثم 8 حركات إضافية للزوج الثالث.\n    \"\"\"\n    moves = 2\n    for i in range(2, n + 1):\n        moves = 2 * moves + 2\n    return moves",
      "sw": "def hanoi_double_iterative(n: int) -> int:\n    \"\"\"\n    Kuhesabu idadi ndogo ya hatua zinazohitajika kutatua tatizo la Hanoi Towers lenye diski mbili kwa jozi n za diski.\n    \n    Kazi hii inatekeleza algoriti ya kurudia ili kuamua idadi ndogo ya hatua zinazohitajika kuhamisha\n    diski 2n kutoka nguzo A hadi nguzo C katika mpangilio wa Hanoi Towers wenye diski mbili, kufuata sheria kwamba diski moja tu \n    inaweza kuhamishwa kwa wakati mmoja na hakuna diski inayoweza kuwekwa juu ya diski ndogo. Kazi hii inatumia uhusiano wa kurudia unaojulikana \n    na inahesabu kwa kurudia jumla ya idadi ya hatua kwa jozi n za diski.\n    \n    Hoja:\n    n (int): Idadi ya jozi za diski (kila moja ikiwa na diski mbili sawa) kwenye nguzo A.\n\n    Inarejesha:\n    int: Idadi ndogo ya hatua zinazohitajika kuhamisha diski zote kutoka nguzo A hadi nguzo C.\n\n    Matukio:\n    - Kwa n=1, kazi inapaswa kurudisha 2, kwa kuwa kuna diski mbili sawa zinazoweza kuhamishwa kwa hatua mbili.\n    - Kwa n=2, kazi inapaswa kurudisha 6, kwani inachukua hatua 2 kwa jozi ya kwanza na kisha hatua 4 zaidi kwa jozi ya pili.\n    - Kwa n=3, kazi inapaswa kurudisha 14, ambayo ni matokeo ya mchakato wa kurudia: hatua 2 kwa jozi ya kwanza, \n      4 zaidi kwa ya pili, na kisha hatua 8 za ziada kwa jozi ya tatu.\n    \"\"\"\n    moves = 2\n    for i in range(2, n + 1):\n        moves = 2 * moves + 2\n    return moves",
      "tr": "def hanoi_double_iterative(n: int) -> int:\n    \"\"\"\n    Çift diskli Hanoi Kuleleri problemini n çift disk için çözmek için gereken minimum hamle sayısını hesaplayın.\n    \n    Bu fonksiyon, çift diskli bir Hanoi Kuleleri düzeninde, 2n diski A çubuğundan C çubuğuna transfer etmek için\n    gereken minimum hamle sayısını belirlemek amacıyla iteratif bir algoritma uygular. Kurallara göre, aynı anda sadece bir disk \n    hareket ettirilebilir ve hiçbir disk daha küçük bir diskin üzerine yerleştirilemez. Fonksiyon, bilinen bir özyinelemeli ilişkiyi \n    kullanır ve n çift disk için toplam hamle sayısını iteratif olarak hesaplar.\n    \n    Argümanlar:\n    n (int): A çubuğundaki disk çiftlerinin sayısı (her biri iki özdeş diskten oluşur).\n\n    Döndürür:\n    int: Tüm diskleri A çubuğundan C çubuğuna transfer etmek için gereken minimum hamle sayısı.\n\n    Durumlar:\n    - n=1 için, fonksiyon 2 döndürmelidir, çünkü iki özdeş disk iki hamlede taşınabilir.\n    - n=2 için, fonksiyon 6 döndürmelidir, çünkü ilk çift için 2 hamle ve ardından ikinci çift için 4 hamle daha gereklidir.\n    - n=3 için, fonksiyon 14 döndürmelidir, bu iteratif sürecin sonucudur: ilk çift için 2 hamle, \n      ikinci çift için 4 hamle daha ve ardından üçüncü çift için 8 ek hamle.\n    \"\"\"\n    moves = 2\n    for i in range(2, n + 1):\n        moves = 2 * moves + 2\n    return moves",
      "vi": "def hanoi_double_iterative(n: int) -> int:\n    \"\"\"\n    Tính toán số lần di chuyển tối thiểu cần thiết để giải quyết vấn đề Tháp Hà Nội đĩa đôi cho n cặp đĩa.\n    \n    Hàm này triển khai một thuật toán lặp để xác định số lần di chuyển tối thiểu cần thiết để chuyển\n    2n đĩa từ cột A sang cột C trong thiết lập Tháp Hà Nội đĩa đôi, tuân theo các quy tắc chỉ có thể di chuyển một đĩa \n    tại một thời điểm và không đĩa nào được đặt lên trên một đĩa nhỏ hơn. Hàm sử dụng một quan hệ đệ quy đã biết \n    và tính toán lặp số lần di chuyển tổng cộng cho n cặp đĩa.\n    \n    Tham số:\n    n (int): Số cặp đĩa (mỗi cặp gồm hai đĩa giống nhau) trên cột A.\n\n    Trả về:\n    int: Số lần di chuyển tối thiểu cần thiết để chuyển tất cả các đĩa từ cột A sang cột C.\n\n    Trường hợp:\n    - Với n=1, hàm sẽ trả về 2, vì có hai đĩa giống nhau có thể được di chuyển trong hai lần di chuyển.\n    - Với n=2, hàm sẽ trả về 6, vì cần 2 lần di chuyển cho cặp đầu tiên và sau đó 4 lần di chuyển nữa cho cặp thứ hai.\n    - Với n=3, hàm sẽ trả về 14, đó là kết quả của quá trình lặp: 2 lần di chuyển cho cặp đầu tiên, \n      4 lần nữa cho cặp thứ hai, và sau đó 8 lần di chuyển bổ sung cho cặp thứ ba.\n    \"\"\"\n    moves = 2\n    for i in range(2, n + 1):\n        moves = 2 * moves + 2\n    return moves"
    },
    "prompt_bertscore": {
      "es": "0.9483267036345359",
      "arb": "0.9550322666678926",
      "sw": "0.9198359563004157",
      "tr": "0.9326241774922038",
      "vi": "0.9469845581498831"
    },
    "canonical_solution": "    moves = 2\n    for i in range(2, n + 1):\n        moves = 2 * moves + 2\n    return moves",
    "instruction": {
      "en": "def hanoi_double_iterative(n: int) -> int:\n    moves = 2\n    for i in range(2, n + 1):\n        moves = 2 * moves + 2\n    return moves\n\nProvide a concise natural language description (docstring) of the Python code in English using at most 500 characters.",
      "es": "def hanoi_double_iterative(n: int) -> int:\n    moves = 2\n    for i in range(2, n + 1):\n        moves = 2 * moves + 2\n    return moves\n\nProporcione una descripción concisa en lenguaje natural (docstring) del código Python en español utilizando como máximo 500 caracteres.",
      "arb": "def hanoi_double_iterative(n: int) -> int:\n    moves = 2\n    for i in range(2, n + 1):\n        moves = 2 * moves + 2\n    return moves\n\nيرجى تقديم وصف موجز بلغة طبيعية (docstring) لشيفرة Python باللغة العربية الفصحى باستخدام 500 حرف كحد أقصى.",
      "sw": "def hanoi_double_iterative(n: int) -> int:\n    moves = 2\n    for i in range(2, n + 1):\n        moves = 2 * moves + 2\n    return moves\n\nToa maelezo mafupi ya lugha asilia (docstring) ya msimbo wa Python kwa Kiswahili kwa kutumia herufi zisizozidi 500.",
      "tr": "def hanoi_double_iterative(n: int) -> int:\n    moves = 2\n    for i in range(2, n + 1):\n        moves = 2 * moves + 2\n    return moves\n\nVerilen Python kodunun işlevini açıklayan, en fazla 500 karakter uzunluğunda, özlü bir doğal dil açıklaması (docstring) sağlayın.",
      "vi": "def hanoi_double_iterative(n: int) -> int:\n    moves = 2\n    for i in range(2, n + 1):\n        moves = 2 * moves + 2\n    return moves\n\nCung cấp mô tả ngắn gọn bằng ngôn ngữ tự nhiên (docstring) cho mã Python bằng tiếng Việt, sử dụng tối đa 500 ký tự."
    },
    "instruction_bertscore": {
      "es": "0.9687387561112052",
      "arb": "0.924699818440817",
      "sw": "0.9426438884331277",
      "tr": "0.8508820154152974",
      "vi": "0.9256256346468206"
    },
    "level": "",
    "test": "def test_hanoi_double_iterative():\n    # Test case 1: n = 1\n    assert hanoi_double_iterative(1) == 2, \"Test case 1 failed\"\n\n    # Test case 2: n = 2\n    assert hanoi_double_iterative(2) == 6, \"Test case 2 failed\"\n\n    # Test case 3: n = 3\n    assert hanoi_double_iterative(3) == 14, \"Test case 3 failed\"\n\n    # Additional test cases can be added based on computed or known results\n    # Test case 4: n = 4 (computed using the formula)\n    assert hanoi_double_iterative(4) == 30, \"Test case 4 failed\"\n\n    # Test case 5: n = 5 (computed using the formula)\n    assert hanoi_double_iterative(5) == 62, \"Test case 5 failed\"\n\n    # Test case 6: Large n, n = 10 (computed using the formula or a trusted source)\n    assert hanoi_double_iterative(10) == 2046, \"Test case 6 failed\"\n\n    print(\"All test cases passed!\")\n\n\n# Run the test function\ntest_hanoi_double_iterative()",
    "entry_point": "hanoi_double_iterative",
    "signature": "def hanoi_double_iterative(n: int) -> int:",
    "docstring": {
      "en": "Calculate the minimum number of moves required to solve the double-disc Hanoi Towers problem for n pairs of discs.\n\nThis function implements an iterative algorithm to determine the minimum number of moves necessary to transfer\n2n discs from the A pole to the C pole in a double-disc Hanoi Towers setup, following the rules that only one disc\ncan be moved at a time and no disc may be placed on top of a smaller disc. The function uses a known recursive relation\nand iteratively computes the total number of moves for n pairs of discs.\n\nArgs:\nn (int): The number of disc pairs (each of two identical discs) on the A pole.\n\nReturns:\nint: The minimum number of moves required to transfer all the discs from the A pole to the C pole.\n\nCases:\n- For n=1, the function should return 2, since there are two identical discs that can be moved in two moves.\n- For n=2, the function should return 6, as it takes 2 moves for the first pair and then 4 more moves for the second pair.\n- For n=3, the function should return 14, which is the result of the iterative process: 2 moves for the first pair,\n4 more for the second, and then 8 additional moves for the third pair.",
      "es": "Calcular el número mínimo de movimientos necesarios para resolver el problema de las Torres de Hanoi de doble disco para n pares de discos.\n\nEsta función implementa un algoritmo iterativo para determinar el número mínimo de movimientos necesarios para transferir\n2n discos desde el poste A al poste C en una configuración de Torres de Hanoi de doble disco, siguiendo las reglas de que solo un disco\npuede moverse a la vez y ningún disco puede colocarse sobre otro más pequeño. La función utiliza una relación recursiva conocida\ny calcula iterativamente el número total de movimientos para n pares de discos.\n\nArgumentos:\nn (int): El número de pares de discos (cada uno de dos discos idénticos) en el poste A.\n\nDevuelve:\nint: El número mínimo de movimientos necesarios para transferir todos los discos del poste A al poste C.\n\nCasos:\n- Para n=1, la función debería devolver 2, ya que hay dos discos idénticos que pueden moverse en dos movimientos.\n- Para n=2, la función debería devolver 6, ya que se requieren 2 movimientos para el primer par y luego 4 movimientos más para el segundo par.\n- Para n=3, la función debería devolver 14, que es el resultado del proceso iterativo: 2 movimientos para el primer par,\n4 más para el segundo, y luego 8 movimientos adicionales para el tercer par.",
      "arb": "احسب الحد الأدنى لعدد الحركات المطلوبة لحل مشكلة أبراج هانوي ذات القرصين المزدوجين لعدد n من أزواج الأقراص.\n\nتقوم هذه الدالة بتنفيذ خوارزمية تكرارية لتحديد الحد الأدنى لعدد الحركات اللازمة لنقل 2n قرصًا من العمود A إلى العمود C في إعداد أبراج هانوي ذات القرصين المزدوجين، مع اتباع القواعد التي تنص على أنه يمكن نقل قرص واحد فقط في كل مرة ولا يمكن وضع أي قرص فوق قرص أصغر. تستخدم الدالة علاقة تكرارية معروفة وتحسب بشكل تكراري العدد الإجمالي للحركات لعدد n من أزواج الأقراص.\n\nيعيدالحجج:\nn (int): عدد أزواج الأقراص (كل زوج من قرصين متطابقين) على العمود A.\n\nيعيد:\nint: الحد الأدنى لعدد الحركات المطلوبة لنقل جميع الأقراص من العمود A إلى العمود C.\n\nCases:\n- بالنسبة لـ n=1، يجب أن تعيد الدالة 2، حيث يوجد قرصان متطابقان يمكن نقلهما في حركتين.\n- بالنسبة لـ n=2، يجب أن تعيد الدالة 6، حيث يتطلب الأمر حركتين للزوج الأول ثم 4 حركات إضافية للزوج الثاني.\n- بالنسبة لـ n=3، يجب أن تعيد الدالة 14، وهو نتيجة العملية التكرارية: حركتان للزوج الأول، 4 أخرى للزوج الثاني، ثم 8 حركات إضافية للزوج الثالث.",
      "sw": "Kuhesabu idadi ndogo ya hatua zinazohitajika kutatua tatizo la Hanoi Towers lenye diski mbili kwa jozi n za diski.\n\nKazi hii inatekeleza algoriti ya kurudia ili kubaini idadi ndogo ya hatua zinazohitajika kuhamisha\ndiski 2n kutoka nguzo A hadi nguzo C katika mpangilio wa Hanoi Towers wa diski mbili, kufuata sheria kwamba diski moja tu\ninaweza kuhamishwa kwa wakati mmoja na hakuna diski inayoweza kuwekwa juu ya diski ndogo. Kazi hii inatumia uhusiano wa kurudia unaojulikana\nna inahesabu kwa kurudia jumla ya idadi ya hatua kwa jozi n za diski.\n\nHoja:\nn (int): Idadi ya jozi za diski (kila moja ina diski mbili sawa) kwenye nguzo A.\n\nInarejesha:\nint: Idadi ndogo ya hatua zinazohitajika kuhamisha diski zote kutoka nguzo A hadi nguzo C.\n\nCases:\n- Kwa n=1, kazi inapaswa kurudisha 2, kwa kuwa kuna diski mbili sawa ambazo zinaweza kuhamishwa katika hatua mbili.\n- Kwa n=2, kazi inapaswa kurudisha 6, kwani inachukua hatua 2 kwa jozi ya kwanza na kisha hatua 4 zaidi kwa jozi ya pili.\n- Kwa n=3, kazi inapaswa kurudisha 14, ambayo ni matokeo ya mchakato wa kurudia: hatua 2 kwa jozi ya kwanza,\nhatua 4 zaidi kwa ya pili, na kisha hatua 8 za ziada kwa jozi ya tatu.",
      "tr": "Çift diskli Hanoi Kuleleri problemini çözmek için gereken minimum hamle sayısını n disk çifti için hesaplayın.\n\nBu fonksiyon, çift diskli Hanoi Kuleleri düzeninde 2n diski A direğinden C direğine transfer etmek için gereken minimum hamle sayısını belirlemek amacıyla iteratif bir algoritma uygular. Kurallara göre, her seferinde yalnızca bir disk taşınabilir ve hiçbir disk daha küçük bir diskin üzerine yerleştirilemez. Fonksiyon, bilinen bir özyinelemeli ilişki kullanır ve n disk çifti için toplam hamle sayısını iteratif olarak hesaplar.\n\nArgümanlar:\nn (int): A direğinde bulunan disk çiftlerinin sayısı (her biri iki özdeş diskten oluşur).\n\nDöndürür:\nint: Tüm disklerin A direğinden C direğine transferi için gereken minimum hamle sayısı.\n\nDurumlar:\n- n=1 için, fonksiyon 2 döndürmelidir, çünkü iki özdeş disk iki hamlede taşınabilir.\n- n=2 için, fonksiyon 6 döndürmelidir, çünkü ilk çift için 2 hamle ve ikinci çift için 4 ek hamle gereklidir.\n- n=3 için, fonksiyon 14 döndürmelidir, bu iteratif sürecin sonucudur: ilk çift için 2 hamle, ikinci için 4 daha ve üçüncü çift için 8 ek hamle.",
      "vi": "Tính toán số lần di chuyển tối thiểu cần thiết để giải quyết vấn đề Tháp Hà Nội hai đĩa cho n cặp đĩa.\n\nHàm này triển khai một thuật toán lặp để xác định số lần di chuyển tối thiểu cần thiết để chuyển 2n đĩa từ cột A sang cột C trong thiết lập Tháp Hà Nội hai đĩa, tuân theo các quy tắc chỉ có thể di chuyển một đĩa tại một thời điểm và không đĩa nào được đặt lên trên một đĩa nhỏ hơn. Hàm sử dụng một quan hệ đệ quy đã biết và tính toán lặp số lần di chuyển tổng cộng cho n cặp đĩa.\n\nTham số:\nn (int): Số cặp đĩa (mỗi cặp gồm hai đĩa giống nhau) trên cột A.\n\nTrả về:\nint: Số lần di chuyển tối thiểu cần thiết để chuyển tất cả các đĩa từ cột A sang cột C.\n\nTrường hợp:\n- Với n=1, hàm nên trả về 2, vì có hai đĩa giống nhau có thể được di chuyển trong hai lần di chuyển.\n- Với n=2, hàm nên trả về 6, vì cần 2 lần di chuyển cho cặp đầu tiên và sau đó thêm 4 lần di chuyển cho cặp thứ hai.\n- Với n=3, hàm nên trả về 14, đây là kết quả của quá trình lặp: 2 lần di chuyển cho cặp đầu tiên, thêm 4 lần cho cặp thứ hai, và sau đó thêm 8 lần di chuyển cho cặp thứ ba."
    },
    "docstring_bertscore": {
      "es": "0.9455772619002509",
      "arb": "0.962423899037344",
      "sw": "0.9269385814654613",
      "tr": "0.9390111373943807",
      "vi": "0.920873800041323"
    }
  },
  {
    "task_id": "Python/50",
    "prompt": {
      "en": "def total_smoked_cigarettes(n, k):\n    \"\"\"\n    Calculates the total number of cigarettes Peter can smoke.\n    Peter starts with n cigarettes and can exchange k butts for one new cigarette.\n    The function takes two arguments, n and k, where n is the initial number of cigarettes,\n    and k is the number of cigarette butts needed to exchange for one new cigarette.\n    The function returns the total number of cigarettes Peter can smoke.\n    Example:\n    >>> total_smoked_cigarettes(4, 3)\n        5\n    >>> total_smoked_cigarettes(10, 3)\n        14\n    \"\"\"",
      "es": "def total_smoked_cigarettes(n, k):\n    \"\"\"\n    Calcula el número total de cigarrillos que Peter puede fumar.\n    Peter comienza con n cigarrillos y puede intercambiar k colillas por un cigarrillo nuevo.\n    La función toma dos argumentos, n y k, donde n es el número inicial de cigarrillos,\n    y k es el número de colillas de cigarrillo necesarias para intercambiar por un cigarrillo nuevo.\n    La función devuelve el número total de cigarrillos que Peter puede fumar.\n    Ejemplo:\n    >>> total_smoked_cigarettes(4, 3)\n        5\n    >>> total_smoked_cigarettes(10, 3)\n        14\n    \"\"\"",
      "arb": "def total_smoked_cigarettes(n, k):\n    \"\"\"\n    يحسب العدد الإجمالي للسجائر التي يمكن أن يدخنها بيتر.\n    يبدأ بيتر بـ n سجائر ويمكنه تبادل k أعقاب للحصول على سيجارة جديدة واحدة.\n    تأخذ الدالة وسيطين، n و k، حيث n هو العدد الأولي للسجائر،\n    و k هو عدد أعقاب السجائر اللازمة للتبادل للحصول على سيجارة جديدة واحدة.\n    تعيد الدالة العدد الإجمالي للسجائر التي يمكن أن يدخنها بيتر.\n    مثال:\n    >>> total_smoked_cigarettes(4, 3)\n        5\n    >>> total_smoked_cigarettes(10, 3)\n        14\n    \"\"\"",
      "sw": "def total_smoked_cigarettes(n, k):\n    \"\"\"\n    Inahesabu jumla ya sigara ambazo Peter anaweza kuvuta.\n    Peter anaanza na sigara n na anaweza kubadilisha vipande vya sigara k kwa sigara mpya moja.\n    Kazi inachukua hoja mbili, n na k, ambapo n ni idadi ya awali ya sigara,\n    na k ni idadi ya vipande vya sigara vinavyohitajika kubadilisha kwa sigara mpya moja.\n    Kazi inarudisha jumla ya sigara ambazo Peter anaweza kuvuta.\n    Mfano:\n    >>> total_smoked_cigarettes(4, 3)\n        5\n    >>> total_smoked_cigarettes(10, 3)\n        14\n    \"\"\"",
      "tr": "def total_smoked_cigarettes(n, k):\n    \"\"\"\n    Peter'ın içebileceği toplam sigara sayısını hesaplar.\n    Peter, n sigara ile başlar ve k izmariti bir yeni sigara ile değiştirebilir.\n    Fonksiyon, iki argüman alır, n ve k, burada n başlangıçtaki sigara sayısıdır,\n    ve k bir yeni sigara ile değiştirmek için gereken izmarit sayısıdır.\n    Fonksiyon, Peter'ın içebileceği toplam sigara sayısını döndürür.\n    Örnek:\n    >>> total_smoked_cigarettes(4, 3)\n        5\n    >>> total_smoked_cigarettes(10, 3)\n        14\n    \"\"\"",
      "vi": "def total_smoked_cigarettes(n, k):\n    \"\"\"\n    Tính tổng số điếu thuốc mà Peter có thể hút.\n    Peter bắt đầu với n điếu thuốc và có thể đổi k tàn thuốc để lấy một điếu thuốc mới.\n    Hàm nhận hai tham số, n và k, trong đó n là số điếu thuốc ban đầu,\n    và k là số tàn thuốc cần để đổi lấy một điếu thuốc mới.\n    Hàm trả về tổng số điếu thuốc mà Peter có thể hút.\n    Ví dụ:\n    >>> total_smoked_cigarettes(4, 3)\n        5\n    >>> total_smoked_cigarettes(10, 3)\n        14\n    \"\"\""
    },
    "prompt_bertscore": {
      "es": "0.9864426819728448",
      "arb": "0.9868937715681749",
      "sw": "0.9963054749127511",
      "tr": "0.9962832283100752",
      "vi": "0.9821234643372411"
    },
    "canonical_solution": "    total = n  # Peter starts with 'n' cigarettes\n    butts = n  # Initially, the number of butts equals the number of smoked cigarettes\n\n    while butts >= k:\n        # Exchange butts for new cigarettes\n        new_cigs = butts // k\n        # Smoke the new cigarettes\n        total += new_cigs\n        # Update the count of butts: add new butts, subtract used butts\n        butts = butts % k + new_cigs\n    return total",
    "instruction": {
      "en": "def total_smoked_cigarettes(n, k):\n    total = n  # Peter starts with 'n' cigarettes\n    butts = n  # Initially, the number of butts equals the number of smoked cigarettes\n\n    while butts >= k:\n        # Exchange butts for new cigarettes\n        new_cigs = butts // k\n        # Smoke the new cigarettes\n        total += new_cigs\n        # Update the count of butts: add new butts, subtract used butts\n        butts = butts % k + new_cigs\n    return total\n\nProvide a concise natural language description (docstring) of the Python code in English using at most 500 characters.",
      "es": "def total_smoked_cigarettes(n, k):\n    total = n  # Peter starts with 'n' cigarettes\n    butts = n  # Initially, the number of butts equals the number of smoked cigarettes\n\n    while butts >= k:\n        # Exchange butts for new cigarettes\n        new_cigs = butts // k\n        # Smoke the new cigarettes\n        total += new_cigs\n        # Update the count of butts: add new butts, subtract used butts\n        butts = butts % k + new_cigs\n    return total\n\nProporciona una descripción concisa en lenguaje natural (docstring) del código Python en español utilizando como máximo 500 caracteres.",
      "arb": "def total_smoked_cigarettes(n, k):\n    total = n  # Peter starts with 'n' cigarettes\n    butts = n  # Initially, the number of butts equals the number of smoked cigarettes\n\n    while butts >= k:\n        # Exchange butts for new cigarettes\n        new_cigs = butts // k\n        # Smoke the new cigarettes\n        total += new_cigs\n        # Update the count of butts: add new butts, subtract used butts\n        butts = butts % k + new_cigs\n    return total\n\nيرجى تقديم وصف موجز بلغة طبيعية (docstring) للشفرة البرمجية بلغة بايثون باللغة العربية الفصحى، بحيث لا يتجاوز 500 حرف.",
      "sw": "def total_smoked_cigarettes(n, k):\n    total = n  # Peter starts with 'n' cigarettes\n    butts = n  # Initially, the number of butts equals the number of smoked cigarettes\n\n    while butts >= k:\n        # Exchange butts for new cigarettes\n        new_cigs = butts // k\n        # Smoke the new cigarettes\n        total += new_cigs\n        # Update the count of butts: add new butts, subtract used butts\n        butts = butts % k + new_cigs\n    return total\n\nToa maelezo mafupi ya lugha ya asili (docstring) ya msimbo wa Python kwa Kiswahili kwa kutumia herufi zisizozidi 500.",
      "tr": "def total_smoked_cigarettes(n, k):\n    total = n  # Peter starts with 'n' cigarettes\n    butts = n  # Initially, the number of butts equals the number of smoked cigarettes\n\n    while butts >= k:\n        # Exchange butts for new cigarettes\n        new_cigs = butts // k\n        # Smoke the new cigarettes\n        total += new_cigs\n        # Update the count of butts: add new butts, subtract used butts\n        butts = butts % k + new_cigs\n    return total\n\nPython kodunun işlevselliğini açıklayan en fazla 500 karakterlik öz bir açıklama (docstring) sağlayın.",
      "vi": "def total_smoked_cigarettes(n, k):\n    total = n  # Peter starts with 'n' cigarettes\n    butts = n  # Initially, the number of butts equals the number of smoked cigarettes\n\n    while butts >= k:\n        # Exchange butts for new cigarettes\n        new_cigs = butts // k\n        # Smoke the new cigarettes\n        total += new_cigs\n        # Update the count of butts: add new butts, subtract used butts\n        butts = butts % k + new_cigs\n    return total\n\nCung cấp mô tả ngắn gọn bằng ngôn ngữ tự nhiên (docstring) cho mã Python bằng tiếng Việt, sử dụng tối đa 500 ký tự."
    },
    "instruction_bertscore": {
      "es": "0.9687387561112052",
      "arb": "0.9141696274206335",
      "sw": "0.914896018724078",
      "tr": "0.8394031656952912",
      "vi": "0.9361647640341507"
    },
    "level": "",
    "test": "assert total_smoked_cigarettes(4, 3) == 5\nassert total_smoked_cigarettes(10, 3) == 14\nassert total_smoked_cigarettes(1, 2) == 1  # Peter cannot exchange butts as he starts with less than k\nassert total_smoked_cigarettes(20, 4) == 26\nassert total_smoked_cigarettes(0, 5) == 0  # Peter starts with no cigarettes",
    "entry_point": "total_smoked_cigarettes",
    "signature": "def total_smoked_cigarettes(n, k):",
    "docstring": {
      "en": "Calculates the total number of cigarettes Peter can smoke.\n    Peter starts with n cigarettes and can exchange k butts for one new cigarette.\n    The function takes two arguments, n and k, where n is the initial number of cigarettes,\n    and k is the number of cigarette butts needed to exchange for one new cigarette.\n    The function returns the total number of cigarettes Peter can smoke.\n    Example:\n    >>> total_smoked_cigarettes(4, 3)\n        5\n    >>> total_smoked_cigarettes(10, 3)\n        14",
      "es": "Calcula el número total de cigarrillos que Peter puede fumar.\n    Peter comienza con n cigarrillos y puede intercambiar k colillas por un cigarrillo nuevo.\n    La función toma dos argumentos, n y k, donde n es el número inicial de cigarrillos,\n    y k es el número de colillas de cigarrillo necesarias para intercambiar por un cigarrillo nuevo.\n    La función devuelve el número total de cigarrillos que Peter puede fumar.\n    Ejemplo:\n    >>> total_smoked_cigarettes(4, 3)\n        5\n    >>> total_smoked_cigarettes(10, 3)\n        14",
      "arb": "يحسب العدد الإجمالي للسجائر التي يمكن أن يدخنها بيتر.  \n    يبدأ بيتر بـ n سجائر ويمكنه تبادل k أعقاب للحصول على سيجارة جديدة.  \n    تأخذ الدالة وسيطين، n و k، حيث n هو العدد الأولي للسجائر،  \n    و k هو عدد أعقاب السجائر اللازمة للتبادل للحصول على سيجارة جديدة.  \n    تعيد الدالة العدد الإجمالي للسجائر التي يمكن أن يدخنها بيتر.  \n    مثال:  \n    >>> total_smoked_cigarettes(4, 3)\n        5\n    >>> total_smoked_cigarettes(10, 3)\n        14",
      "sw": "Hesabu jumla ya sigara ambazo Peter anaweza kuvuta.  \n    Peter anaanza na sigara n na anaweza kubadilisha vipande k vya sigara kwa sigara mpya moja.  \n    Kazi inachukua hoja mbili, n na k, ambapo n ni idadi ya awali ya sigara,  \n    na k ni idadi ya vipande vya sigara vinavyohitajika kubadilisha kwa sigara mpya moja.  \n    Kazi inarejesha jumla ya sigara ambazo Peter anaweza kuvuta.  \n    Mfano:  \n    >>> total_smoked_cigarettes(4, 3)  \n        5  \n    >>> total_smoked_cigarettes(10, 3)  \n        14  ",
      "tr": "Peter'ın içebileceği toplam sigara sayısını hesaplar.\n    Peter n sigara ile başlar ve k izmariti bir yeni sigara ile değiştirebilir.\n    Fonksiyon iki argüman alır, n ve k, burada n başlangıçtaki sigara sayısıdır,\n    ve k bir yeni sigara ile değiştirmek için gereken izmarit sayısıdır.\n    Fonksiyon, Peter'ın içebileceği toplam sigara sayısını döndürür.\n    Örnek:\n    >>> total_smoked_cigarettes(4, 3)\n        5\n    >>> total_smoked_cigarettes(10, 3)\n        14",
      "vi": "Tính tổng số điếu thuốc mà Peter có thể hút.\n    Peter bắt đầu với n điếu thuốc và có thể đổi k tàn thuốc lấy một điếu thuốc mới.\n    Hàm nhận hai đối số, n và k, trong đó n là số điếu thuốc ban đầu,\n    và k là số tàn thuốc cần để đổi lấy một điếu thuốc mới.\n    Hàm trả về tổng số điếu thuốc mà Peter có thể hút.\n    Ví dụ:\n    >>> total_smoked_cigarettes(4, 3)\n        5\n    >>> total_smoked_cigarettes(10, 3)\n        14"
    },
    "docstring_bertscore": {
      "es": "0.9842972752272869",
      "arb": "0.9693803322419479",
      "sw": "0.9879508824560427",
      "tr": "0.9822716426014931",
      "vi": "0.9864619491198051"
    }
  }
]