[
  {
    "task_id": "Swift/1",
    "prompt": {
      "en": "import Foundation\n\nfunc hasCloseElements(_ numbers: [Double], _ threshold: Double) -> Bool {\n/**\nCheck if in the given array of numbers, any two numbers are closer to each other than\nthe given threshold.\n>>> has_close_elements([1.0, 2.0, 3.0], 0.5)\nFalse\n>>> has_close_elements([1.0, 2.8, 3.0, 4.0, 5.0, 2.0], 0.3)\nTrue\n*/",
      "es": "import Foundation\n\nfunc hasCloseElements(_ numbers: [Double], _ threshold: Double) -> Bool {\n/**\nVerifica si en el array dado de números, hay dos números que están más cerca uno del otro que\nel umbral dado.\n>>> has_close_elements([1.0, 2.0, 3.0], 0.5)\nFalse\n>>> has_close_elements([1.0, 2.8, 3.0, 4.0, 5.0, 2.0], 0.3)\nTrue\n*/",
      "arb": "import Foundation\n\nfunc hasCloseElements(_ numbers: [Double], _ threshold: Double) -> Bool {\n/**\nتحقق مما إذا كان في المصفوفة المعطاة من الأرقام، أي رقمين أقرب إلى بعضهما البعض من\nالحد المعطى.\n>>> has_close_elements([1.0, 2.0, 3.0], 0.5)\nFalse\n>>> has_close_elements([1.0, 2.8, 3.0, 4.0, 5.0, 2.0], 0.3)\nTrue\n*/",
      "sw": "import Foundation\n\nfunc hasCloseElements(_ numbers: [Double], _ threshold: Double) -> Bool {\n/**\nAngalia kama katika safu iliyotolewa ya namba, kuna namba zozote mbili ambazo ziko karibu zaidi kuliko\nkizingiti kilichotolewa.\n>>> has_close_elements([1.0, 2.0, 3.0], 0.5)\nFalse\n>>> has_close_elements([1.0, 2.8, 3.0, 4.0, 5.0, 2.0], 0.3)\nTrue\n*/",
      "tr": "import Foundation\n\nfunc hasCloseElements(_ numbers: [Double], _ threshold: Double) -> Bool {\n/**\nVerilen sayı dizisinde, herhangi iki sayının birbirine verilen eşikten daha yakın olup olmadığını kontrol edin.\n>>> has_close_elements([1.0, 2.0, 3.0], 0.5)\nFalse\n>>> has_close_elements([1.0, 2.8, 3.0, 4.0, 5.0, 2.0], 0.3)\nTrue\n*/",
      "vi": "import Foundation\n\nfunc hasCloseElements(_ numbers: [Double], _ threshold: Double) -> Bool {\n/**\nKiểm tra xem trong mảng số đã cho, có bất kỳ hai số nào gần nhau hơn ngưỡng đã cho hay không.\n>>> has_close_elements([1.0, 2.0, 3.0], 0.5)\nFalse\n>>> has_close_elements([1.0, 2.8, 3.0, 4.0, 5.0, 2.0], 0.3)\nTrue\n*/"
    },
    "prompt_bertscore": {
      "es": "0.9832638013547624",
      "arb": "0.999999801369619",
      "sw": "0.9813162304687153",
      "tr": "0.9805548802182086",
      "vi": "0.9850560432828401"
    },
    "canonical_solution": "for i in 0..<numbers.count {\nfor j in 0..<numbers.count {\nif i != j {\nlet distance = abs(numbers[i] - numbers[j])\nif distance < threshold {\nreturn true\n}\n}\n}\n}\nreturn false\n}",
    "instruction": {
      "en": "func hasCloseElements(_ numbers: [Double], _ threshold: Double) -> Bool {\nfor i in 0..<numbers.count {\nfor j in 0..<numbers.count {\nif i != j {\nlet distance = abs(numbers[i] - numbers[j])\nif distance < threshold {\nreturn true\n}\n}\n}\n}\nreturn false\n}\n\nProvide a concise natural language description (docstring) of the Swift code in English using at most 500 characters.",
      "es": "func hasCloseElements(_ numbers: [Double], _ threshold: Double) -> Bool {\nfor i in 0..<numbers.count {\nfor j in 0..<numbers.count {\nif i != j {\nlet distance = abs(numbers[i] - numbers[j])\nif distance < threshold {\nreturn true\n}\n}\n}\n}\nreturn false\n}\n\nProporcione una descripción concisa en lenguaje natural (docstring) del código Swift en español utilizando como máximo 500 caracteres.",
      "arb": "func hasCloseElements(_ numbers: [Double], _ threshold: Double) -> Bool {\nfor i in 0..<numbers.count {\nfor j in 0..<numbers.count {\nif i != j {\nlet distance = abs(numbers[i] - numbers[j])\nif distance < threshold {\nreturn true\n}\n}\n}\n}\nreturn false\n}\n\nقدم وصفًا موجزًا بلغة طبيعية (docstring) لكود Swift باللغة العربية الفصحى باستخدام 500 حرف كحد أقصى.",
      "sw": "func hasCloseElements(_ numbers: [Double], _ threshold: Double) -> Bool {\nfor i in 0..<numbers.count {\nfor j in 0..<numbers.count {\nif i != j {\nlet distance = abs(numbers[i] - numbers[j])\nif distance < threshold {\nreturn true\n}\n}\n}\n}\nreturn false\n}\n\nToa maelezo mafupi ya lugha ya asili (docstring) ya msimbo wa Swift kwa Kiswahili kwa kutumia herufi zisizozidi 500.",
      "tr": "func hasCloseElements(_ numbers: [Double], _ threshold: Double) -> Bool {\nfor i in 0..<numbers.count {\nfor j in 0..<numbers.count {\nif i != j {\nlet distance = abs(numbers[i] - numbers[j])\nif distance < threshold {\nreturn true\n}\n}\n}\n}\nreturn false\n}\n\nSwift kodunun Türkçe açıklamasını en fazla 500 karakter kullanarak doğal dilde özlü bir şekilde sağlayın.",
      "vi": "func hasCloseElements(_ numbers: [Double], _ threshold: Double) -> Bool {\nfor i in 0..<numbers.count {\nfor j in 0..<numbers.count {\nif i != j {\nlet distance = abs(numbers[i] - numbers[j])\nif distance < threshold {\nreturn true\n}\n}\n}\n}\nreturn false\n}\n\nCung cấp mô tả ngắn gọn bằng ngôn ngữ tự nhiên (docstring) cho mã Swift bằng tiếng Việt, sử dụng tối đa 500 ký tự."
    },
    "instruction_bertscore": {
      "es": "0.9676013985493994",
      "arb": "0.9274768697980658",
      "sw": "0.942496901951162",
      "tr": "0.842118443004038",
      "vi": "0.9054771646857847"
    },
    "level": "",
    "test": "func check(_ hasCloseElements: ([Double], Double) -> Bool) {\nassert(hasCloseElements([1.0, 2.0, 3.9, 4.0, 5.0, 2.2], 0.3) == true)\nassert(hasCloseElements([1.0, 2.0, 3.9, 4.0, 5.0, 2.2], 0.05) == false)\nassert(hasCloseElements([1.0, 2.0, 5.9, 4.0, 5.0], 0.95) == true)\nassert(hasCloseElements([1.0, 2.0, 5.9, 4.0, 5.0], 0.8) == false)\nassert(hasCloseElements([1.0, 2.0, 3.0, 4.0, 5.0, 2.0], 0.1) == true)\nassert(hasCloseElements([1.1, 2.2, 3.1, 4.1, 5.1], 1.0) == true)\nassert(hasCloseElements([1.1, 2.2, 3.1, 4.1, 5.1], 0.5) == false)\n}\n\ncheck(hasCloseElements)",
    "entry_point": "hasCloseElements",
    "signature": "func hasCloseElements(_ numbers: [Double], _ threshold: Double) -> Bool {",
    "docstring": {
      "en": "\nCheck if in the given array of numbers, any two numbers are closer to each other than\nthe given threshold.\n>>> has_close_elements([1.0, 2.0, 3.0], 0.5)\nFalse\n>>> has_close_elements([1.0, 2.8, 3.0, 4.0, 5.0, 2.0], 0.3)\nTrue\n",
      "es": "Verifica si en el arreglo dado de números, hay dos números que estén más cerca uno del otro que el umbral dado.\n>>> has_close_elements([1.0, 2.0, 3.0], 0.5)\nFalse\n>>> has_close_elements([1.0, 2.8, 3.0, 4.0, 5.0, 2.0], 0.3)\nTrue",
      "arb": "تحقق مما إذا كان في المصفوفة المعطاة من الأرقام، أي رقمين أقرب إلى بعضهما البعض من العتبة المحددة.\n>>> has_close_elements([1.0, 2.0, 3.0], 0.5)\nFalse\n>>> has_close_elements([1.0, 2.8, 3.0, 4.0, 5.0, 2.0], 0.3)\nTrue",
      "sw": "Angalia kama katika safu iliyopewa ya namba, namba yoyote mbili ziko karibu zaidi na kila moja kuliko kizingiti kilichopewa.\n>>> has_close_elements([1.0, 2.0, 3.0], 0.5)\nFalse\n>>> has_close_elements([1.0, 2.8, 3.0, 4.0, 5.0, 2.0], 0.3)\nTrue",
      "tr": "Verilen sayı dizisinde, herhangi iki sayının birbirine verilen eşikten daha yakın olup olmadığını kontrol edin.\n>>> has_close_elements([1.0, 2.0, 3.0], 0.5)\nFalse\n>>> has_close_elements([1.0, 2.8, 3.0, 4.0, 5.0, 2.0], 0.3)\nTrue",
      "vi": "Kiểm tra xem trong mảng số đã cho, có bất kỳ hai số nào gần nhau hơn ngưỡng đã cho hay không.  \n>>> has_close_elements([1.0, 2.0, 3.0], 0.5)  \nFalse  \n>>> has_close_elements([1.0, 2.8, 3.0, 4.0, 5.0, 2.0], 0.3)  \nTrue  "
    },
    "docstring_bertscore": {
      "es": "0.9806885584646451",
      "arb": "0.9948238909006119",
      "sw": "1",
      "tr": "0.9667558290173339",
      "vi": "0.9827753692477976"
    }
  },
  {
    "task_id": "Swift/2",
    "prompt": {
      "en": "import Foundation\n\nfunc firstPalindrome(_ words: [String]) -> String {\n/**\nFinds and returns the first palindrome string in the given array of words.\nIf no palindrome string is found, returns an empty string \"\".\n>>> firstPalindrome([\"apple\", \"banana\", \"civic\"])\n\"civic\"\n>>> firstPalindrome([\"abc\", \"car\", \"ada\", \"racecar\"])\n\"ada\"\n>>> firstPalindrome([\"hello\", \"world\"])\n\"\"\n*/",
      "es": "import Foundation\n\nfunc firstPalindrome(_ words: [String]) -> String {\n/**\nEncuentra y devuelve la primera cadena palíndroma en el arreglo dado de palabras.\nSi no se encuentra ninguna cadena palíndroma, devuelve una cadena vacía \"\".\n>>> firstPalindrome([\"apple\", \"banana\", \"civic\"])\n\"civic\"\n>>> firstPalindrome([\"abc\", \"car\", \"ada\", \"racecar\"])\n\"ada\"\n>>> firstPalindrome([\"hello\", \"world\"])\n\"\"\n*/",
      "arb": "import Foundation\n\nfunc firstPalindrome(_ words: [String]) -> String {\n/**\nيعثر ويعيد أول سلسلة نصية متطابقة في المصفوفة المعطاة من الكلمات.\nإذا لم يتم العثور على سلسلة نصية متطابقة، يعيد سلسلة فارغة \"\".\n>>> firstPalindrome([\"apple\", \"banana\", \"civic\"])\n\"civic\"\n>>> firstPalindrome([\"abc\", \"car\", \"ada\", \"racecar\"])\n\"ada\"\n>>> firstPalindrome([\"hello\", \"world\"])\n\"\"\n*/",
      "sw": "import Foundation\n\nfunc firstPalindrome(_ words: [String]) -> String {\n/**\nInapata na kurudisha neno la kwanza lenye palindrome katika safu iliyotolewa ya maneno.\nKama hakuna neno lenye palindrome linapatikana, inarudisha kamba tupu \"\".\n>>> firstPalindrome([\"apple\", \"banana\", \"civic\"])\n\"civic\"\n>>> firstPalindrome([\"abc\", \"car\", \"ada\", \"racecar\"])\n\"ada\"\n>>> firstPalindrome([\"hello\", \"world\"])\n\"\"\n*/",
      "tr": "import Foundation\n\nfunc firstPalindrome(_ words: [String]) -> String {\n/**\nVerilen kelime dizisinde ilk palindromik kelimeyi bulur ve döndürür.\nEğer palindromik bir kelime bulunamazsa, boş bir string \"\" döndürür.\n>>> firstPalindrome([\"apple\", \"banana\", \"civic\"])\n\"civic\"\n>>> firstPalindrome([\"abc\", \"car\", \"ada\", \"racecar\"])\n\"ada\"\n>>> firstPalindrome([\"hello\", \"world\"])\n\"\"\n*/",
      "vi": "import Foundation\n\nfunc firstPalindrome(_ words: [String]) -> String {\n/**\nTìm và trả về chuỗi palindrome đầu tiên trong mảng từ đã cho.\nNếu không tìm thấy chuỗi palindrome nào, trả về chuỗi rỗng \"\".\n>>> firstPalindrome([\"apple\", \"banana\", \"civic\"])\n\"civic\"\n>>> firstPalindrome([\"abc\", \"car\", \"ada\", \"racecar\"])\n\"ada\"\n>>> firstPalindrome([\"hello\", \"world\"])\n\"\"\n*/"
    },
    "prompt_bertscore": {
      "es": "0.9855067356174083",
      "arb": "0.9791140154341815",
      "sw": "0.9888953699178635",
      "tr": "0.9703691142787395",
      "vi": "0.9933591904708606"
    },
    "canonical_solution": "for word in words {\nif word == String(word.reversed()) {\nreturn word\n}\n}\nreturn \"\"\n}",
    "instruction": {
      "en": "func firstPalindrome(_ words: [String]) -> String {\nfor word in words {\nif word == String(word.reversed()) {\nreturn word\n}\n}\nreturn \"\"\n}\n\nProvide a concise natural language description (docstring) of the Swift code in English using at most 500 characters.",
      "es": "func firstPalindrome(_ words: [String]) -> String {\nfor word in words {\nif word == String(word.reversed()) {\nreturn word\n}\n}\nreturn \"\"\n}\n\nProporcione una descripción concisa en lenguaje natural (docstring) del código Swift en español utilizando como máximo 500 caracteres.",
      "arb": "func firstPalindrome(_ words: [String]) -> String {\nfor word in words {\nif word == String(word.reversed()) {\nreturn word\n}\n}\nreturn \"\"\n}\n\nقدم وصفًا موجزًا بلغة طبيعية (docstring) لكود Swift باللغة العربية الفصحى باستخدام 500 حرف كحد أقصى.",
      "sw": "func firstPalindrome(_ words: [String]) -> String {\nfor word in words {\nif word == String(word.reversed()) {\nreturn word\n}\n}\nreturn \"\"\n}\n\nToa maelezo mafupi ya lugha ya asili (docstring) ya msimbo wa Swift kwa Kiswahili kwa kutumia herufi zisizozidi 500.",
      "tr": "func firstPalindrome(_ words: [String]) -> String {\nfor word in words {\nif word == String(word.reversed()) {\nreturn word\n}\n}\nreturn \"\"\n}\n\nSwift kodunun işlevini açıklayan, en fazla 500 karakterlik öz bir doğal dil açıklaması (docstring) sağlayın.",
      "vi": "func firstPalindrome(_ words: [String]) -> String {\nfor word in words {\nif word == String(word.reversed()) {\nreturn word\n}\n}\nreturn \"\"\n}\n\nCung cấp mô tả ngắn gọn bằng ngôn ngữ tự nhiên (docstring) cho mã Swift bằng tiếng Việt, sử dụng tối đa 500 ký tự."
    },
    "instruction_bertscore": {
      "es": "0.9676013985493994",
      "arb": "0.911639473627011",
      "sw": "0.9148419912604365",
      "tr": "0.8847876255668097",
      "vi": "0.9054771646857847"
    },
    "level": "",
    "test": "func checkFirstPalindrome(_ firstPalindrome: ([String]) -> String) {\nassert(firstPalindrome([\"apple\", \"banana\", \"civic\"]) == \"civic\", \"Test failed: Expected 'civic'\")\nassert(firstPalindrome([\"abc\", \"car\", \"ada\", \"racecar\"]) == \"ada\", \"Test failed: Expected 'ada'\")\nassert(firstPalindrome([\"hello\", \"world\"]) == \"\", \"Test failed: Expected an empty string\")\nassert(firstPalindrome([\"radar\", \"rotor\", \"level\"]) == \"radar\", \"Test failed: Expected 'radar'\")\nassert(firstPalindrome([\"not\", \"a\", \"single\", \"palindrome\"]) == \"a\", \"Test failed: Expected an empty string\")\nassert(firstPalindrome([\"A\", \"B\", \"C\", \"D\"]) == \"A\", \"Test failed: Expected 'A'\")\nassert(firstPalindrome([\"noon\", \"evening\", \"morning\"]) == \"noon\", \"Test failed: Expected 'noon'\")\n}\n\n\ncheckFirstPalindrome(firstPalindrome)",
    "entry_point": "firstPalindrome",
    "signature": "func firstPalindrome(_ words: [String]) -> String {",
    "docstring": {
      "en": "\nFinds and returns the first palindrome string in the given array of words.\nIf no palindrome string is found, returns an empty string \"\".\n>>> firstPalindrome([\"apple\", \"banana\", \"civic\"])\n\"civic\"\n>>> firstPalindrome([\"abc\", \"car\", \"ada\", \"racecar\"])\n\"ada\"\n>>> firstPalindrome([\"hello\", \"world\"])\n\"\"\n",
      "es": "Encuentra y devuelve la primera cadena de palíndromo en el arreglo dado de palabras.\nSi no se encuentra ninguna cadena de palíndromo, devuelve una cadena vacía \"\".\n>>> firstPalindrome([\"apple\", \"banana\", \"civic\"])\n\"civic\"\n>>> firstPalindrome([\"abc\", \"car\", \"ada\", \"racecar\"])\n\"ada\"\n>>> firstPalindrome([\"hello\", \"world\"])\n\"\"",
      "arb": "يعثر ويعيد أول سلسلة نصية متناظرة في مصفوفة الكلمات المعطاة. إذا لم يتم العثور على سلسلة نصية متناظرة، يعيد سلسلة نصية فارغة \"\".\n>>> firstPalindrome([\"apple\", \"banana\", \"civic\"])\n\"civic\"\n>>> firstPalindrome([\"abc\", \"car\", \"ada\", \"racecar\"])\n\"ada\"\n>>> firstPalindrome([\"hello\", \"world\"])\n\"\"",
      "sw": "Inapata na kurudisha neno la kwanza ambalo ni palindrome katika safu iliyotolewa ya maneno. Ikiwa hakuna neno la palindrome lililopatikana, inarudisha kamba tupu \"\".\n>>> firstPalindrome([\"apple\", \"banana\", \"civic\"])\n\"civic\"\n>>> firstPalindrome([\"abc\", \"car\", \"ada\", \"racecar\"])\n\"ada\"\n>>> firstPalindrome([\"hello\", \"world\"])\n\"\"",
      "tr": "Verilen kelime dizisinde ilk palindromik kelimeyi bulur ve döndürür.\nEğer palindromik bir kelime bulunamazsa, boş bir dize \"\" döndürür.\n>>> firstPalindrome([\"apple\", \"banana\", \"civic\"])\n\"civic\"\n>>> firstPalindrome([\"abc\", \"car\", \"ada\", \"racecar\"])\n\"ada\"\n>>> firstPalindrome([\"hello\", \"world\"])\n\"\"",
      "vi": "Tìm và trả về chuỗi palindrome đầu tiên trong mảng từ đã cho. Nếu không tìm thấy chuỗi palindrome nào, trả về một chuỗi rỗng \"\".\n>>> firstPalindrome([\"apple\", \"banana\", \"civic\"])\n\"civic\"\n>>> firstPalindrome([\"abc\", \"car\", \"ada\", \"racecar\"])\n\"ada\"\n>>> firstPalindrome([\"hello\", \"world\"])\n\"\""
    },
    "docstring_bertscore": {
      "es": "0.9892757470975454",
      "arb": "0.9848063648938793",
      "sw": "0.963107584808866",
      "tr": "0.9627683241180585",
      "vi": "0.9892757470975454"
    }
  },
  {
    "task_id": "Swift/3",
    "prompt": {
      "en": "import Foundation\n\nfunc maxWordCount(_ sentences: [String]) -> Int {\n/**\nReturns the maximum number of words found in any single sentence within the given array of sentences.\nA sentence is composed of words separated by a single space, and there are no leading or trailing spaces.\n>>> maxWordCount([\"Hello world\", \"Swift is amazing\"])\n3\n>>> maxWordCount([\"The quick brown fox\", \"jumps over the lazy dog\"])\n5\n*/",
      "es": "import Foundation\n\nfunc maxWordCount(_ sentences: [String]) -> Int {\n/**\nDevuelve el número máximo de palabras encontradas en cualquier oración dentro del array dado de oraciones.\nUna oración está compuesta por palabras separadas por un solo espacio, y no hay espacios al principio o al final.\n>>> maxWordCount([\"Hello world\", \"Swift is amazing\"])\n3\n>>> maxWordCount([\"The quick brown fox\", \"jumps over the lazy dog\"])\n5\n*/",
      "arb": "import Foundation\n\nfunc maxWordCount(_ sentences: [String]) -> Int {\n/**\nيعيد العدد الأقصى من الكلمات الموجودة في أي جملة واحدة داخل مصفوفة الجمل المعطاة.\nتتكون الجملة من كلمات مفصولة بمسافة واحدة، ولا توجد مسافات في البداية أو النهاية.\n>>> maxWordCount([\"Hello world\", \"Swift is amazing\"])\n3\n>>> maxWordCount([\"The quick brown fox\", \"jumps over the lazy dog\"])\n5\n*/",
      "sw": "import Foundation\n\nfunc maxWordCount(_ sentences: [String]) -> Int {\n/**\nInarudisha idadi kubwa zaidi ya maneno yaliyopatikana katika sentensi yoyote moja ndani ya safu iliyotolewa ya sentensi.\nSentensi inaundwa na maneno yaliyotenganishwa na nafasi moja, na hakuna nafasi mwanzoni au mwishoni.\n>>> maxWordCount([\"Hello world\", \"Swift is amazing\"])\n3\n>>> maxWordCount([\"The quick brown fox\", \"jumps over the lazy dog\"])\n5\n*/",
      "tr": "import Foundation\n\nfunc maxWordCount(_ sentences: [String]) -> Int {\n/**\nVerilen cümleler dizisindeki herhangi bir tek cümlede bulunan maksimum kelime sayısını döndürür.\nBir cümle, tek bir boşlukla ayrılmış kelimelerden oluşur ve başta veya sonda boşluk yoktur.\n>>> maxWordCount([\"Hello world\", \"Swift is amazing\"])\n3\n>>> maxWordCount([\"The quick brown fox\", \"jumps over the lazy dog\"])\n5\n*/",
      "vi": "import Foundation\n\nfunc maxWordCount(_ sentences: [String]) -> Int {\n/**\nTrả về số lượng từ tối đa được tìm thấy trong bất kỳ câu nào trong mảng các câu đã cho.\nMột câu được tạo thành từ các từ cách nhau bằng một khoảng trắng duy nhất, và không có khoảng trắng thừa ở đầu hoặc cuối.\n>>> maxWordCount([\"Hello world\", \"Swift is amazing\"])\n3\n>>> maxWordCount([\"The quick brown fox\", \"jumps over the lazy dog\"])\n5\n*/"
    },
    "prompt_bertscore": {
      "es": "0.9744305096797599",
      "arb": "0.9687939753571329",
      "sw": "0.9852902285020804",
      "tr": "0.9840199872153622",
      "vi": "0.9795069063278685"
    },
    "canonical_solution": "var maxCount = 0\nfor sentence in sentences {\nlet wordCount = sentence.split(separator: \" \").count\nmaxCount = max(maxCount, wordCount)\n}\nreturn maxCount\n}",
    "instruction": {
      "en": "func maxWordCount(_ sentences: [String]) -> Int {\nvar maxCount = 0\nfor sentence in sentences {\nlet wordCount = sentence.split(separator: \" \").count\nmaxCount = max(maxCount, wordCount)\n}\nreturn maxCount\n}\n\nProvide a concise natural language description (docstring) of the Swift code in English using at most 500 characters.",
      "es": "func maxWordCount(_ sentences: [String]) -> Int {\nvar maxCount = 0\nfor sentence in sentences {\nlet wordCount = sentence.split(separator: \" \").count\nmaxCount = max(maxCount, wordCount)\n}\nreturn maxCount\n}\n\nProporcione una descripción concisa en lenguaje natural (docstring) del código Swift en español utilizando como máximo 500 caracteres.",
      "arb": "func maxWordCount(_ sentences: [String]) -> Int {\nvar maxCount = 0\nfor sentence in sentences {\nlet wordCount = sentence.split(separator: \" \").count\nmaxCount = max(maxCount, wordCount)\n}\nreturn maxCount\n}\n\nقدم وصفًا موجزًا بلغة طبيعية (docstring) لكود Swift باللغة العربية الفصحى باستخدام ما لا يزيد عن 500 حرف.",
      "sw": "func maxWordCount(_ sentences: [String]) -> Int {\nvar maxCount = 0\nfor sentence in sentences {\nlet wordCount = sentence.split(separator: \" \").count\nmaxCount = max(maxCount, wordCount)\n}\nreturn maxCount\n}\n\nToa maelezo mafupi ya lugha asilia (docstring) ya msimbo wa Swift kwa Kiswahili kwa kutumia herufi zisizozidi 500.",
      "tr": "func maxWordCount(_ sentences: [String]) -> Int {\nvar maxCount = 0\nfor sentence in sentences {\nlet wordCount = sentence.split(separator: \" \").count\nmaxCount = max(maxCount, wordCount)\n}\nreturn maxCount\n}\n\nSwift kodunun Türkçe olarak en fazla 500 karakter kullanarak kısa bir doğal dil açıklamasını (docstring) sağlayın.",
      "vi": "func maxWordCount(_ sentences: [String]) -> Int {\nvar maxCount = 0\nfor sentence in sentences {\nlet wordCount = sentence.split(separator: \" \").count\nmaxCount = max(maxCount, wordCount)\n}\nreturn maxCount\n}\n\nCung cấp mô tả ngắn gọn bằng ngôn ngữ tự nhiên (docstring) cho mã Swift bằng tiếng Việt, sử dụng tối đa 500 ký tự."
    },
    "instruction_bertscore": {
      "es": "0.9676013985493994",
      "arb": "0.8880608556158835",
      "sw": "0.942496901951162",
      "tr": "0.9399917755855499",
      "vi": "0.9054771646857847"
    },
    "level": "",
    "test": "func checkMaxWordCount(_ maxWordCount: ([String]) -> Int) {\nassert(maxWordCount([\"Hello world\", \"Swift is amazing\"]) == 3)\nassert(maxWordCount([\"The quick brown fox\", \"jumps over the lazy dog\"]) == 5)\nassert(maxWordCount([\"single\"]) == 1)\nassert(maxWordCount([\"\", \"one two\", \"one two three\"]) == 3)\nassert(maxWordCount([\"This is a test sentence\", \"This is another\"]) == 5)\nassert(maxWordCount([\"Sentence with five words\", \"Shorter one\"]) == 4)\n}\n\ncheckMaxWordCount(maxWordCount)",
    "entry_point": "maxWordCount",
    "signature": "func maxWordCount(_ sentences: [String]) -> Int {",
    "docstring": {
      "en": "\nReturns the maximum number of words found in any single sentence within the given array of sentences.\nA sentence is composed of words separated by a single space, and there are no leading or trailing spaces.\n>>> maxWordCount([\"Hello world\", \"Swift is amazing\"])\n3\n>>> maxWordCount([\"The quick brown fox\", \"jumps over the lazy dog\"])\n5\n",
      "es": "Devuelve el número máximo de palabras encontradas en cualquier oración individual dentro del arreglo dado de oraciones.  \nUna oración está compuesta por palabras separadas por un solo espacio, y no hay espacios al principio ni al final.  \n>>> maxWordCount([\"Hello world\", \"Swift is amazing\"])  \n3  \n>>> maxWordCount([\"The quick brown fox\", \"jumps over the lazy dog\"])  \n5  ",
      "arb": "يعيد العدد الأقصى من الكلمات الموجودة في أي جملة واحدة داخل مصفوفة الجمل المعطاة.  \nالجملة تتكون من كلمات مفصولة بمسافة واحدة، ولا توجد مسافات في البداية أو النهاية.\n>>> maxWordCount([\"Hello world\", \"Swift is amazing\"])\n3\n>>> maxWordCount([\"The quick brown fox\", \"jumps over the lazy dog\"])\n5",
      "sw": "Inarudisha idadi kubwa zaidi ya maneno yaliyopatikana katika sentensi yoyote moja ndani ya safu iliyotolewa ya sentensi. Sentensi inaundwa na maneno yanayotenganishwa na nafasi moja, na hakuna nafasi za mwanzo au mwisho.\n>>> maxWordCount([\"Hello world\", \"Swift is amazing\"])\n3\n>>> maxWordCount([\"The quick brown fox\", \"jumps over the lazy dog\"])\n5",
      "tr": "Verilen cümleler dizisindeki herhangi bir tek cümlede bulunan maksimum kelime sayısını döndürür.  \nBir cümle, tek bir boşlukla ayrılmış kelimelerden oluşur ve başında veya sonunda boşluk yoktur.  \n>>> maxWordCount([\"Hello world\", \"Swift is amazing\"])  \n3  \n>>> maxWordCount([\"The quick brown fox\", \"jumps over the lazy dog\"])  \n5  ",
      "vi": "Trả về số lượng từ tối đa được tìm thấy trong bất kỳ câu nào trong mảng câu đã cho.  \nMột câu được tạo thành từ các từ được phân tách bằng một khoảng trắng duy nhất, và không có khoảng trắng ở đầu hoặc cuối.  \n>>> maxWordCount([\"Hello world\", \"Swift is amazing\"])  \n3  \n>>> maxWordCount([\"The quick brown fox\", \"jumps over the lazy dog\"])  \n5  "
    },
    "docstring_bertscore": {
      "es": "0.970855361451513",
      "arb": "0.9645053468002086",
      "sw": "0.977989568847143",
      "tr": "0.9537961898067125",
      "vi": "0.9794804884871908"
    }
  },
  {
    "task_id": "Swift/4",
    "prompt": {
      "en": "import Foundation\n\nfunc isValidMatrix(_ matrix: [[Int]]) -> Bool {\n/**\nChecks if the given `n x n` matrix is a valid matrix. A matrix is valid if each row and \ncolumn contains all integers from 1 to n.\n>>> isValidMatrix([[1,2,3],[3,1,2],[2,3,1]])\nTrue\n>>> isValidMatrix([[1,2,3],[3,2,1],[1,2,3]])\nFalse\n*/",
      "es": "import Foundation\n\nfunc isValidMatrix(_ matrix: [[Int]]) -> Bool {\n/**\nVerifica si la `n x n` matriz dada es una matriz válida. Una matriz es válida si cada fila y \ncolumna contiene todos los enteros del 1 al n.\n>>> isValidMatrix([[1,2,3],[3,1,2],[2,3,1]])\nTrue\n>>> isValidMatrix([[1,2,3],[3,2,1],[1,2,3]])\nFalse\n*/",
      "arb": "import Foundation\n\nfunc isValidMatrix(_ matrix: [[Int]]) -> Bool {\n/**\nيتحقق مما إذا كانت المصفوفة `n x n` المعطاة مصفوفة صالحة. تكون المصفوفة صالحة إذا كانت كل صف وعمود يحتويان على جميع الأعداد الصحيحة من 1 إلى n.\n>>> isValidMatrix([[1,2,3],[3,1,2],[2,3,1]])\nTrue\n>>> isValidMatrix([[1,2,3],[3,2,1],[1,2,3]])\nFalse\n*/",
      "sw": "import Foundation\n\nfunc isValidMatrix(_ matrix: [[Int]]) -> Bool {\n/**\nHukagua kama `n x n` matrix iliyotolewa ni matrix halali. Matrix ni halali ikiwa kila safu na \nsafu wima ina namba zote kutoka 1 hadi n.\n>>> isValidMatrix([[1,2,3],[3,1,2],[2,3,1]])\nTrue\n>>> isValidMatrix([[1,2,3],[3,2,1],[1,2,3]])\nFalse\n*/",
      "tr": "import Foundation\n\nfunc isValidMatrix(_ matrix: [[Int]]) -> Bool {\n/**\nVerilen `n x n` matrisin geçerli bir matris olup olmadığını kontrol eder. Bir matris, her satır ve sütun 1'den n'e kadar tüm tamsayıları içeriyorsa geçerlidir.\n>>> isValidMatrix([[1,2,3],[3,1,2],[2,3,1]])\nTrue\n>>> isValidMatrix([[1,2,3],[3,2,1],[1,2,3]])\nFalse\n*/",
      "vi": "import Foundation\n\nfunc isValidMatrix(_ matrix: [[Int]]) -> Bool {\n/**\nKiểm tra xem ma trận `n x n` được cho có phải là ma trận hợp lệ hay không. Một ma trận là hợp lệ nếu mỗi hàng và cột chứa tất cả các số nguyên từ 1 đến n.\n>>> isValidMatrix([[1,2,3],[3,1,2],[2,3,1]])\nTrue\n>>> isValidMatrix([[1,2,3],[3,2,1],[1,2,3]])\nFalse\n*/"
    },
    "prompt_bertscore": {
      "es": "1",
      "arb": "0.998503121448521",
      "sw": "0.9948272676170894",
      "tr": "0.998503121448521",
      "vi": "0.9969788319044594"
    },
    "canonical_solution": "let n = matrix.count\nfor i in 0..<n {\nvar rowSet = Set<Int>()\nvar colSet = Set<Int>()\nfor j in 0..<n {\nrowSet.insert(matrix[i][j])\ncolSet.insert(matrix[j][i])\n}\nif rowSet.count != n || colSet.count != n || rowSet.max()! > n || colSet.max()! > n {\nreturn false\n}\n}\nreturn true\n}",
    "instruction": {
      "en": "func isValidMatrix(_ matrix: [[Int]]) -> Bool {\nlet n = matrix.count\nfor i in 0..<n {\nvar rowSet = Set<Int>()\nvar colSet = Set<Int>()\nfor j in 0..<n {\nrowSet.insert(matrix[i][j])\ncolSet.insert(matrix[j][i])\n}\nif rowSet.count != n || colSet.count != n || rowSet.max()! > n || colSet.max()! > n {\nreturn false\n}\n}\nreturn true\n}\n\nProvide a concise natural language description (docstring) of the Swift code in English using at most 500 characters.",
      "es": "func isValidMatrix(_ matrix: [[Int]]) -> Bool {\nlet n = matrix.count\nfor i in 0..<n {\nvar rowSet = Set<Int>()\nvar colSet = Set<Int>()\nfor j in 0..<n {\nrowSet.insert(matrix[i][j])\ncolSet.insert(matrix[j][i])\n}\nif rowSet.count != n || colSet.count != n || rowSet.max()! > n || colSet.max()! > n {\nreturn false\n}\n}\nreturn true\n}\n\nProporcione una descripción concisa en lenguaje natural (docstring) del código Swift en español utilizando como máximo 500 caracteres.",
      "arb": "func isValidMatrix(_ matrix: [[Int]]) -> Bool {\nlet n = matrix.count\nfor i in 0..<n {\nvar rowSet = Set<Int>()\nvar colSet = Set<Int>()\nfor j in 0..<n {\nrowSet.insert(matrix[i][j])\ncolSet.insert(matrix[j][i])\n}\nif rowSet.count != n || colSet.count != n || rowSet.max()! > n || colSet.max()! > n {\nreturn false\n}\n}\nreturn true\n}\n\nقدم وصفًا موجزًا بلغة طبيعية (docstring) لكود Swift باللغة العربية الفصحى باستخدام ما لا يزيد عن 500 حرف.",
      "sw": "func isValidMatrix(_ matrix: [[Int]]) -> Bool {\nlet n = matrix.count\nfor i in 0..<n {\nvar rowSet = Set<Int>()\nvar colSet = Set<Int>()\nfor j in 0..<n {\nrowSet.insert(matrix[i][j])\ncolSet.insert(matrix[j][i])\n}\nif rowSet.count != n || colSet.count != n || rowSet.max()! > n || colSet.max()! > n {\nreturn false\n}\n}\nreturn true\n}\n\nToa maelezo mafupi ya lugha asilia (docstring) ya msimbo wa Swift kwa Kiswahili kwa kutumia herufi zisizozidi 500.",
      "tr": "func isValidMatrix(_ matrix: [[Int]]) -> Bool {\nlet n = matrix.count\nfor i in 0..<n {\nvar rowSet = Set<Int>()\nvar colSet = Set<Int>()\nfor j in 0..<n {\nrowSet.insert(matrix[i][j])\ncolSet.insert(matrix[j][i])\n}\nif rowSet.count != n || colSet.count != n || rowSet.max()! > n || colSet.max()! > n {\nreturn false\n}\n}\nreturn true\n}\n\nSwift kodunun işlevselliğini açıklayan kısa bir doğal dil açıklaması (docstring) sağlayın. Açıklama Türkçe olmalı ve en fazla 500 karakter kullanılmalıdır.",
      "vi": "func isValidMatrix(_ matrix: [[Int]]) -> Bool {\nlet n = matrix.count\nfor i in 0..<n {\nvar rowSet = Set<Int>()\nvar colSet = Set<Int>()\nfor j in 0..<n {\nrowSet.insert(matrix[i][j])\ncolSet.insert(matrix[j][i])\n}\nif rowSet.count != n || colSet.count != n || rowSet.max()! > n || colSet.max()! > n {\nreturn false\n}\n}\nreturn true\n}\n\nCung cấp mô tả ngắn gọn bằng ngôn ngữ tự nhiên (docstring) cho mã Swift bằng tiếng Việt, sử dụng tối đa 500 ký tự."
    },
    "instruction_bertscore": {
      "es": "0.9676013985493994",
      "arb": "0.8880608556158835",
      "sw": "0.942496901951162",
      "tr": "0.8812168472069455",
      "vi": "0.9054771646857847"
    },
    "level": "",
    "test": "func checkIsValidMatrix(_ isValidMatrix: ([[Int]]) -> Bool) {\nassert(isValidMatrix([[1,2,3],[3,1,2],[2,3,1]]) == true)\nassert(isValidMatrix([[1,2,3],[3,2,1],[1,2,3]]) == false)\nassert(isValidMatrix([[1]]) == true)\nassert(isValidMatrix([[1,2],[2,1]]) == true)\nassert(isValidMatrix([[1,2],[1,2]]) == false)\nassert(isValidMatrix([[1,2,3,4],[2,3,4,1],[3,4,1,2],[4,1,2,3]]) == true)\nassert(isValidMatrix([[4,3,2,1],[3,2,1,4],[2,1,4,3],[1,4,3,2]]) == true)\nassert(isValidMatrix([[1,2,3],[3,1,2],[3,2,1]]) == false)\n}\n\ncheckIsValidMatrix(isValidMatrix)",
    "entry_point": "isValidMatrix",
    "signature": "func isValidMatrix(_ matrix: [[Int]]) -> Bool {",
    "docstring": {
      "en": "\nChecks if the given `n x n` matrix is a valid matrix. A matrix is valid if each row and \ncolumn contains all integers from 1 to n.\n>>> isValidMatrix([[1,2,3],[3,1,2],[2,3,1]])\nTrue\n>>> isValidMatrix([[1,2,3],[3,2,1],[1,2,3]])\nFalse\n",
      "es": "Verifica si la matriz `n x n` dada es una matriz válida. Una matriz es válida si cada fila y columna contiene todos los enteros del 1 al n.\n>>> isValidMatrix([[1,2,3],[3,1,2],[2,3,1]])\nTrue\n>>> isValidMatrix([[1,2,3],[3,2,1],[1,2,3]])\nFalse",
      "arb": "يتحقق مما إذا كانت المصفوفة `n x n` المعطاة مصفوفة صالحة. تكون المصفوفة صالحة إذا كانت كل صف وعمود تحتوي على جميع الأعداد الصحيحة من 1 إلى n.\n>>> isValidMatrix([[1,2,3],[3,1,2],[2,3,1]])\nTrue\n>>> isValidMatrix([[1,2,3],[3,2,1],[1,2,3]])\nFalse",
      "sw": "Hukagua kama matriki ya `n x n` iliyotolewa ni matriki halali. Matiriki ni halali ikiwa kila safu na kila safu wima ina namba zote kutoka 1 hadi n.\n>>> isValidMatrix([[1,2,3],[3,1,2],[2,3,1]])\nTrue\n>>> isValidMatrix([[1,2,3],[3,2,1],[1,2,3]])\nFalse",
      "tr": "Verilen `n x n` matrisinin geçerli bir matris olup olmadığını kontrol eder. Bir matris, her satır ve sütun 1'den n'e kadar tüm tamsayıları içeriyorsa geçerlidir.\n>>> isValidMatrix([[1,2,3],[3,1,2],[2,3,1]])\nTrue\n>>> isValidMatrix([[1,2,3],[3,2,1],[1,2,3]])\nFalse",
      "vi": "Kiểm tra xem ma trận `n x n` được cho có phải là ma trận hợp lệ hay không. Một ma trận là hợp lệ nếu mỗi hàng và cột chứa tất cả các số nguyên từ 1 đến n.\n>>> isValidMatrix([[1,2,3],[3,1,2],[2,3,1]])\nTrue\n>>> isValidMatrix([[1,2,3],[3,2,1],[1,2,3]])\nFalse"
    },
    "docstring_bertscore": {
      "es": "0.9893871787413059",
      "arb": "1",
      "sw": "0.9813494017423482",
      "tr": "0.9895516446968028",
      "vi": "0.9895516446968028"
    }
  },
  {
    "task_id": "Swift/5",
    "prompt": {
      "en": "import Foundation\n\nfunc minCostToBuyCandies(_ costs: [Int]) -> Int {\n/**\nCalculates the minimum total cost to acquire all candies under a promotion where\nbuying two candies gets one free candy (with its price less than or equal to the lesser of the two bought).\n>>> minCostToBuyCandies([1, 2, 3, 4])\n8 // Buy candies costing 4 and 3, get 2 for free; pay for 1.\n>>> minCostToBuyCandies([1, 2])\n3 // Buy both candies, no free candies available.\n*/",
      "es": "import Foundation\n\nfunc minCostToBuyCandies(_ costs: [Int]) -> Int {\n/**\nCalcula el costo total mínimo para adquirir todos los dulces bajo una promoción donde\ncomprar dos dulces te da un dulce gratis (con su precio menor o igual al menor de los dos comprados).\n>>> minCostToBuyCandies([1, 2, 3, 4])\n8 // Compra dulces que cuestan 4 y 3, obtén 2 gratis; paga por 1.\n>>> minCostToBuyCandies([1, 2])\n3 // Compra ambos dulces, no hay dulces gratis disponibles.\n*/",
      "arb": "import Foundation\n\nfunc minCostToBuyCandies(_ costs: [Int]) -> Int {\n/**\nيحسب الحد الأدنى للتكلفة الإجمالية للحصول على جميع الحلوى تحت عرض ترويجي حيث\nشراء حبتين من الحلوى يمنحك حبة حلوى مجانية (بسعر أقل من أو يساوي الأقل بين الاثنين المشتريين).\n>>> minCostToBuyCandies([1, 2, 3, 4])\n8 // شراء الحلوى التي تكلف 4 و 3، الحصول على 2 مجانًا؛ الدفع مقابل 1.\n>>> minCostToBuyCandies([1, 2])\n3 // شراء كلا الحلوى، لا توجد حلوى مجانية متاحة.\n*/",
      "sw": "import Foundation\n\nfunc minCostToBuyCandies(_ costs: [Int]) -> Int {\n/**\nInahesabu gharama ndogo kabisa ya jumla ya kununua pipi zote chini ya ofa ambapo\nkununua pipi mbili unapata pipi moja bure (ambayo bei yake ni ndogo au sawa na ile ya chini kati ya zile mbili ulizonunua).\n>>> minCostToBuyCandies([1, 2, 3, 4])\n8 // Nunua pipi zinazogharimu 4 na 3, pata 2 bure; lipa kwa 1.\n>>> minCostToBuyCandies([1, 2])\n3 // Nunua pipi zote mbili, hakuna pipi za bure zinazopatikana.\n*/",
      "tr": "import Foundation\n\nfunc minCostToBuyCandies(_ costs: [Int]) -> Int {\n/**\nTüm şekerleri satın almak için, iki şeker alındığında bir şekerin bedava olduğu (bedava olan şekerin fiyatı alınan iki şekerden daha düşük veya eşit olmalıdır) bir promosyon altında minimum toplam maliyeti hesaplar.\n>>> minCostToBuyCandies([1, 2, 3, 4])\n8 // 4 ve 3 maliyetli şekerleri satın al, 2 bedava; 1 için ödeme yap.\n>>> minCostToBuyCandies([1, 2])\n3 // Her iki şekeri de satın al, bedava şeker yok.\n*/",
      "vi": "import Foundation\n\nfunc minCostToBuyCandies(_ costs: [Int]) -> Int {\n/**\nTính toán tổng chi phí tối thiểu để mua tất cả kẹo theo chương trình khuyến mãi\nmua hai kẹo được tặng một kẹo miễn phí (với giá của kẹo miễn phí nhỏ hơn hoặc bằng giá của kẹo rẻ hơn trong hai kẹo đã mua).\n>>> minCostToBuyCandies([1, 2, 3, 4])\n8 // Mua kẹo giá 4 và 3, được tặng kẹo giá 2 miễn phí; trả tiền cho kẹo giá 1.\n>>> minCostToBuyCandies([1, 2])\n3 // Mua cả hai kẹo, không có kẹo miễn phí.\n*/"
    },
    "prompt_bertscore": {
      "es": "0.982772191161701",
      "arb": "0.9728188227680428",
      "sw": "0.9665484588995334",
      "tr": "0.9186235164545787",
      "vi": "0.9141962438916921"
    },
    "canonical_solution": "let sortedCosts = costs.sorted(by: >)\nvar totalCost = 0\nfor i in 0..<sortedCosts.count {\n// Pay for every candy, except every third one\nif (i % 3) != 2 {\ntotalCost += sortedCosts[i]\n}\n}\nreturn totalCost\n}",
    "instruction": {
      "en": "func minCostToBuyCandies(_ costs: [Int]) -> Int {\nlet sortedCosts = costs.sorted(by: >)\nvar totalCost = 0\nfor i in 0..<sortedCosts.count {\n// Pay for every candy, except every third one\nif (i % 3) != 2 {\ntotalCost += sortedCosts[i]\n}\n}\nreturn totalCost\n}\n\nProvide a concise natural language description (docstring) of the Swift code in English using at most 500 characters.",
      "es": "func minCostToBuyCandies(_ costs: [Int]) -> Int {\nlet sortedCosts = costs.sorted(by: >)\nvar totalCost = 0\nfor i in 0..<sortedCosts.count {\n// Pay for every candy, except every third one\nif (i % 3) != 2 {\ntotalCost += sortedCosts[i]\n}\n}\nreturn totalCost\n}\n\nProporcione una descripción concisa en lenguaje natural (docstring) del código Swift en español utilizando un máximo de 500 caracteres.",
      "arb": "func minCostToBuyCandies(_ costs: [Int]) -> Int {\nlet sortedCosts = costs.sorted(by: >)\nvar totalCost = 0\nfor i in 0..<sortedCosts.count {\n// Pay for every candy, except every third one\nif (i % 3) != 2 {\ntotalCost += sortedCosts[i]\n}\n}\nreturn totalCost\n}\n\nقدم وصفًا موجزًا بلغة طبيعية (docstring) لكود Swift باللغة العربية الفصحى باستخدام 500 حرف على الأكثر.",
      "sw": "func minCostToBuyCandies(_ costs: [Int]) -> Int {\nlet sortedCosts = costs.sorted(by: >)\nvar totalCost = 0\nfor i in 0..<sortedCosts.count {\n// Pay for every candy, except every third one\nif (i % 3) != 2 {\ntotalCost += sortedCosts[i]\n}\n}\nreturn totalCost\n}\n\nToa maelezo mafupi ya lugha ya asili (docstring) ya msimbo wa Swift kwa Kiswahili kwa kutumia herufi zisizozidi 500.",
      "tr": "func minCostToBuyCandies(_ costs: [Int]) -> Int {\nlet sortedCosts = costs.sorted(by: >)\nvar totalCost = 0\nfor i in 0..<sortedCosts.count {\n// Pay for every candy, except every third one\nif (i % 3) != 2 {\ntotalCost += sortedCosts[i]\n}\n}\nreturn totalCost\n}\n\nSwift kodunun işlevini açıklayan kısa bir doğal dil açıklaması (docstring) sağlayın. Açıklama, en fazla 500 karakter kullanılarak Türkçe olarak yazılmalıdır.",
      "vi": "func minCostToBuyCandies(_ costs: [Int]) -> Int {\nlet sortedCosts = costs.sorted(by: >)\nvar totalCost = 0\nfor i in 0..<sortedCosts.count {\n// Pay for every candy, except every third one\nif (i % 3) != 2 {\ntotalCost += sortedCosts[i]\n}\n}\nreturn totalCost\n}\n\nCung cấp mô tả ngắn gọn bằng ngôn ngữ tự nhiên (docstring) cho mã Swift bằng tiếng Việt với tối đa 500 ký tự."
    },
    "instruction_bertscore": {
      "es": "0.9676013985493994",
      "arb": "0.8880608556158835",
      "sw": "0.9148419912604365",
      "tr": "0.8816689299541809",
      "vi": "0.8999953634299838"
    },
    "level": "",
    "test": "func checkMinCostToBuyCandies(_ minCostToBuyCandies: ([Int]) -> Int) {\nassert(minCostToBuyCandies([1, 2, 3, 4]) == 8)\nassert(minCostToBuyCandies([1, 2]) == 3)\nassert(minCostToBuyCandies([1, 6, 3, 5, 2, 4]) == 16)\nassert(minCostToBuyCandies([5, 5, 5, 5, 5, 5]) == 20)\nassert(minCostToBuyCandies([7, 1, 2, 9, 6, 4]) == 22)\nassert(minCostToBuyCandies([1]) == 1)\nassert(minCostToBuyCandies([]) == 0)\n}\n\ncheckMinCostToBuyCandies(minCostToBuyCandies)",
    "entry_point": "minCostToBuyCandies",
    "signature": "func minCostToBuyCandies(_ costs: [Int]) -> Int {",
    "docstring": {
      "en": "\nCalculates the minimum total cost to acquire all candies under a promotion where\nbuying two candies gets one free candy (with its price less than or equal to the lesser of the two bought).\n>>> minCostToBuyCandies([1, 2, 3, 4])\n8 // Buy candies costing 4 and 3, get 2 for free; pay for 1.\n>>> minCostToBuyCandies([1, 2])\n3 // Buy both candies, no free candies available.\n",
      "es": "Calcula el costo total mínimo para adquirir todos los dulces bajo una promoción donde\ncomprar dos dulces te da un dulce gratis (con su precio menor o igual al menor de los dos comprados).\n>>> minCostToBuyCandies([1, 2, 3, 4])\n8 // Comprar dulces que cuestan 4 y 3, obtener 2 gratis; pagar por 1.\n>>> minCostToBuyCandies([1, 2])\n3 // Comprar ambos dulces, no hay dulces gratis disponibles.",
      "arb": "يحسب الحد الأدنى للتكلفة الإجمالية للحصول على جميع الحلوى تحت عرض ترويجي حيث شراء حبتين من الحلوى يمنح حبة مجانية (بسعر أقل من أو يساوي الأقل من الحبتين المشتراتين).\n>>> minCostToBuyCandies([1, 2, 3, 4])\n8 // شراء الحلوى التي تكلف 4 و3، الحصول على 2 مجانًا؛ الدفع مقابل 1.\n>>> minCostToBuyCandies([1, 2])\n3 // شراء كلا الحبتين، لا توجد حلوى مجانية متاحة.",
      "sw": "Hesabu gharama ndogo kabisa ya kupata pipi zote chini ya ofa ambapo kununua pipi mbili unapata pipi moja bure (ikiwa na bei ndogo au sawa na ile ya chini kati ya zile mbili ulizonunua).\n>>> minCostToBuyCandies([1, 2, 3, 4])\n8 // Nunua pipi zinazogharimu 4 na 3, pata 2 bure; lipa kwa 1.\n>>> minCostToBuyCandies([1, 2])\n3 // Nunua pipi zote mbili, hakuna pipi za bure zinazopatikana.",
      "tr": "Tüm şekerleri bir promosyon kapsamında satın almak için minimum toplam maliyeti hesaplar; iki şeker alındığında bir şeker bedava (fiyatı, satın alınan iki şekerden daha ucuz veya eşit olanın fiyatına eşit veya daha düşük olan).\n\n>>> minCostToBuyCandies([1, 2, 3, 4])\n8 // 4 ve 3 maliyetli şekerleri satın alın, 2 bedava; 1 için ödeme yapın.\n>>> minCostToBuyCandies([1, 2])\n3 // Her iki şekeri de satın alın, bedava şeker yok.",
      "vi": "Tính toán tổng chi phí tối thiểu để mua tất cả kẹo theo chương trình khuyến mãi mà khi mua hai viên kẹo sẽ được tặng một viên miễn phí (với giá nhỏ hơn hoặc bằng giá của viên rẻ hơn trong hai viên đã mua).\n>>> minCostToBuyCandies([1, 2, 3, 4])\n8 // Mua kẹo giá 4 và 3, được tặng 2 miễn phí; trả tiền cho 1.\n>>> minCostToBuyCandies([1, 2])\n3 // Mua cả hai viên kẹo, không có kẹo miễn phí."
    },
    "docstring_bertscore": {
      "es": "0.9781558224760692",
      "arb": "0.9669177127778773",
      "sw": "0.9578802290711709",
      "tr": "0.9346893375638236",
      "vi": "0.9385914313992539"
    }
  },
  {
    "task_id": "Swift/6",
    "prompt": {
      "en": "import Foundation\n\nfunc countElementsWithStrictBounds(_ nums: [Int]) -> Int {\n/**\nCounts the number of elements in the array that have at least one strictly smaller and \none strictly larger element.\n>>> countElementsWithStrictBounds([2, 1, 3])\n1 // Only the element '2' has both a smaller (1) and a larger (3) element.\n>>> countElementsWithStrictBounds([1, 2, 3])\n1 // Only the element '2' has both a smaller (1) and a larger (3) element.\n>>> countElementsWithStrictBounds([1, 1, 1])\n0 // There are no elements with both a smaller and a larger element.\n*/",
      "es": "import Foundation\n\nfunc countElementsWithStrictBounds(_ nums: [Int]) -> Int {\n/**\nCuenta el número de elementos en el arreglo que tienen al menos un elemento estrictamente menor y \nun elemento estrictamente mayor.\n>>> countElementsWithStrictBounds([2, 1, 3])\n1 // Solo el elemento '2' tiene tanto un elemento menor (1) como un elemento mayor (3).\n>>> countElementsWithStrictBounds([1, 2, 3])\n1 // Solo el elemento '2' tiene tanto un elemento menor (1) como un elemento mayor (3).\n>>> countElementsWithStrictBounds([1, 1, 1])\n0 // No hay elementos con tanto un elemento menor como un elemento mayor.\n*/",
      "arb": "import Foundation\n\nfunc countElementsWithStrictBounds(_ nums: [Int]) -> Int {\n/**\nيحسب عدد العناصر في المصفوفة التي لديها على الأقل عنصر واحد أصغر بشكل صارم وعنصر واحد أكبر بشكل صارم.\n>>> countElementsWithStrictBounds([2, 1, 3])\n1 // فقط العنصر '2' لديه عنصر أصغر (1) وعنصر أكبر (3).\n>>> countElementsWithStrictBounds([1, 2, 3])\n1 // فقط العنصر '2' لديه عنصر أصغر (1) وعنصر أكبر (3).\n>>> countElementsWithStrictBounds([1, 1, 1])\n0 // لا توجد عناصر لديها عنصر أصغر وعنصر أكبر.\n*/",
      "sw": "import Foundation\n\nfunc countElementsWithStrictBounds(_ nums: [Int]) -> Int {\n/**\nInahesabu idadi ya vipengele katika safu ambayo ina angalau moja ndogo kabisa na \nmoja kubwa kabisa.\n>>> countElementsWithStrictBounds([2, 1, 3])\n1 // Ni kipengele '2' pekee kina kipengele kidogo (1) na kikubwa (3).\n>>> countElementsWithStrictBounds([1, 2, 3])\n1 // Ni kipengele '2' pekee kina kipengele kidogo (1) na kikubwa (3).\n>>> countElementsWithStrictBounds([1, 1, 1])\n0 // Hakuna vipengele vyenye kipengele kidogo na kikubwa.\n*/",
      "tr": "import Foundation\n\nfunc countElementsWithStrictBounds(_ nums: [Int]) -> Int {\n/**\nDizide en az bir tane kesinlikle daha küçük ve bir tane kesinlikle daha büyük elemana sahip olan elemanların sayısını sayar.\n>>> countElementsWithStrictBounds([2, 1, 3])\n1 // Sadece '2' elemanı hem daha küçük (1) hem de daha büyük (3) bir elemana sahiptir.\n>>> countElementsWithStrictBounds([1, 2, 3])\n1 // Sadece '2' elemanı hem daha küçük (1) hem de daha büyük (3) bir elemana sahiptir.\n>>> countElementsWithStrictBounds([1, 1, 1])\n0 // Hem daha küçük hem de daha büyük bir elemana sahip olan hiçbir eleman yoktur.\n*/",
      "vi": "import Foundation\n\nfunc countElementsWithStrictBounds(_ nums: [Int]) -> Int {\n/**\nĐếm số lượng phần tử trong mảng có ít nhất một phần tử nhỏ hơn và \nmột phần tử lớn hơn.\n>>> countElementsWithStrictBounds([2, 1, 3])\n1 // Chỉ có phần tử '2' có cả phần tử nhỏ hơn (1) và lớn hơn (3).\n>>> countElementsWithStrictBounds([1, 2, 3])\n1 // Chỉ có phần tử '2' có cả phần tử nhỏ hơn (1) và lớn hơn (3).\n>>> countElementsWithStrictBounds([1, 1, 1])\n0 // Không có phần tử nào có cả phần tử nhỏ hơn và lớn hơn.\n*/"
    },
    "prompt_bertscore": {
      "es": "0.9753525519085239",
      "arb": "0.9581892979440612",
      "sw": "0.9649071760610421",
      "tr": "0.994830247072805",
      "vi": "0.9661712598059482"
    },
    "canonical_solution": "guard let minElement = nums.min(), let maxElement = nums.max() else {\nreturn 0\n}\n\nreturn nums.filter { $0 > minElement && $0 < maxElement }.count\n}",
    "instruction": {
      "en": "func countElementsWithStrictBounds(_ nums: [Int]) -> Int {\nguard let minElement = nums.min(), let maxElement = nums.max() else {\nreturn 0\n}\n\nreturn nums.filter { $0 > minElement && $0 < maxElement }.count\n}\n\nProvide a concise natural language description (docstring) of the Swift code in English using at most 500 characters.",
      "es": "func countElementsWithStrictBounds(_ nums: [Int]) -> Int {\nguard let minElement = nums.min(), let maxElement = nums.max() else {\nreturn 0\n}\n\nreturn nums.filter { $0 > minElement && $0 < maxElement }.count\n}\n\nProporcione una descripción concisa en lenguaje natural (docstring) del código Swift en español utilizando un máximo de 500 caracteres.",
      "arb": "func countElementsWithStrictBounds(_ nums: [Int]) -> Int {\nguard let minElement = nums.min(), let maxElement = nums.max() else {\nreturn 0\n}\n\nreturn nums.filter { $0 > minElement && $0 < maxElement }.count\n}\n\nقدم وصفًا موجزًا بلغة طبيعية (docstring) لكود Swift باللغة العربية الفصحى باستخدام 500 حرف كحد أقصى.",
      "sw": "func countElementsWithStrictBounds(_ nums: [Int]) -> Int {\nguard let minElement = nums.min(), let maxElement = nums.max() else {\nreturn 0\n}\n\nreturn nums.filter { $0 > minElement && $0 < maxElement }.count\n}\n\nToa maelezo mafupi ya lugha asilia (docstring) ya msimbo wa Swift kwa Kiswahili kwa kutumia herufi zisizozidi 500.",
      "tr": "func countElementsWithStrictBounds(_ nums: [Int]) -> Int {\nguard let minElement = nums.min(), let maxElement = nums.max() else {\nreturn 0\n}\n\nreturn nums.filter { $0 > minElement && $0 < maxElement }.count\n}\n\nSwift kodunun Türkçe olarak en fazla 500 karakter kullanarak doğal dilde kısa bir açıklamasını (docstring) sağlayın.",
      "vi": "func countElementsWithStrictBounds(_ nums: [Int]) -> Int {\nguard let minElement = nums.min(), let maxElement = nums.max() else {\nreturn 0\n}\n\nreturn nums.filter { $0 > minElement && $0 < maxElement }.count\n}\n\nCung cấp mô tả ngắn gọn bằng ngôn ngữ tự nhiên (docstring) cho mã Swift bằng tiếng Việt, sử dụng tối đa 500 ký tự."
    },
    "instruction_bertscore": {
      "es": "0.9676013985493994",
      "arb": "0.9144786962935237",
      "sw": "0.933792521393451",
      "tr": "0.8910085304704414",
      "vi": "0.9054771646857847"
    },
    "level": "",
    "test": "func checkCountElementsWithStrictBounds(_ countElementsWithStrictBounds: ([Int]) -> Int) {\nassert(countElementsWithStrictBounds([2, 1, 3]) == 1)\nassert(countElementsWithStrictBounds([1, 2, 3]) == 1)\nassert(countElementsWithStrictBounds([1, 1, 1]) == 0)\nassert(countElementsWithStrictBounds([3, 3, 5, 2, 2, 7, 4]) == 4)\nassert(countElementsWithStrictBounds([10, 5, 9, 1, 7, 6, 8]) == 5)\nassert(countElementsWithStrictBounds([-2, -1, 0, 1, 2]) == 3)\nassert(countElementsWithStrictBounds([]) == 0)\n}\n\ncheckCountElementsWithStrictBounds(countElementsWithStrictBounds)",
    "entry_point": "countElementsWithStrictBounds",
    "signature": "func countElementsWithStrictBounds(_ nums: [Int]) -> Int {",
    "docstring": {
      "en": "\nCounts the number of elements in the array that have at least one strictly smaller and \none strictly larger element.\n>>> countElementsWithStrictBounds([2, 1, 3])\n1 // Only the element '2' has both a smaller (1) and a larger (3) element.\n>>> countElementsWithStrictBounds([1, 2, 3])\n1 // Only the element '2' has both a smaller (1) and a larger (3) element.\n>>> countElementsWithStrictBounds([1, 1, 1])\n0 // There are no elements with both a smaller and a larger element.\n",
      "es": "Cuenta el número de elementos en el arreglo que tienen al menos un elemento estrictamente menor y uno estrictamente mayor.\n>>> countElementsWithStrictBounds([2, 1, 3])\n1 // Solo el elemento '2' tiene tanto un elemento menor (1) como un elemento mayor (3).\n>>> countElementsWithStrictBounds([1, 2, 3])\n1 // Solo el elemento '2' tiene tanto un elemento menor (1) como un elemento mayor (3).\n>>> countElementsWithStrictBounds([1, 1, 1])\n0 // No hay elementos con tanto un elemento menor como uno mayor.",
      "arb": "يحسب عدد العناصر في المصفوفة التي لديها على الأقل عنصر واحد أصغر بشكل صارم وعنصر واحد أكبر بشكل صارم.\n>>> countElementsWithStrictBounds([2, 1, 3])\n1 // فقط العنصر '2' لديه عنصر أصغر (1) وعنصر أكبر (3).\n>>> countElementsWithStrictBounds([1, 2, 3])\n1 // فقط العنصر '2' لديه عنصر أصغر (1) وعنصر أكبر (3).\n>>> countElementsWithStrictBounds([1, 1, 1])\n0 // لا توجد عناصر لديها عنصر أصغر وعنصر أكبر.",
      "sw": "Hesabu idadi ya vipengele katika safu ambayo ina angalau moja ndogo kabisa na moja kubwa kabisa.\n>>> countElementsWithStrictBounds([2, 1, 3])\n1 // Ni kipengele '2' pekee kina kipengele kidogo (1) na kikubwa (3).\n>>> countElementsWithStrictBounds([1, 2, 3])\n1 // Ni kipengele '2' pekee kina kipengele kidogo (1) na kikubwa (3).\n>>> countElementsWithStrictBounds([1, 1, 1])\n0 // Hakuna vipengele vyenye kipengele kidogo na kikubwa.",
      "tr": "Dizide en az bir tane kesinlikle daha küçük ve bir tane kesinlikle daha büyük elemana sahip olan elemanların sayısını sayar.\n>>> countElementsWithStrictBounds([2, 1, 3])\n1 // Sadece '2' elemanının hem daha küçük (1) hem de daha büyük (3) bir elemanı vardır.\n>>> countElementsWithStrictBounds([1, 2, 3])\n1 // Sadece '2' elemanının hem daha küçük (1) hem de daha büyük (3) bir elemanı vardır.\n>>> countElementsWithStrictBounds([1, 1, 1])\n0 // Hem daha küçük hem de daha büyük bir elemana sahip olan hiçbir eleman yoktur.",
      "vi": "Đếm số lượng phần tử trong mảng mà có ít nhất một phần tử nhỏ hơn nghiêm ngặt và một phần tử lớn hơn nghiêm ngặt.\n>>> countElementsWithStrictBounds([2, 1, 3])\n1 // Chỉ có phần tử '2' có cả phần tử nhỏ hơn (1) và phần tử lớn hơn (3).\n>>> countElementsWithStrictBounds([1, 2, 3])\n1 // Chỉ có phần tử '2' có cả phần tử nhỏ hơn (1) và phần tử lớn hơn (3).\n>>> countElementsWithStrictBounds([1, 1, 1])\n0 // Không có phần tử nào có cả phần tử nhỏ hơn và lớn hơn."
    },
    "docstring_bertscore": {
      "es": "0.9716955679632905",
      "arb": "0.954721211491192",
      "sw": "0.9539537036988732",
      "tr": "0.9854713794095842",
      "vi": "0.9707844504054834"
    }
  },
  {
    "task_id": "Swift/7",
    "prompt": {
      "en": "import Foundation\n\nfunc findFinalValue(_ nums: [Int], _ original: Int) -> Int {\n/**\nContinuously doubles the value of 'original' if it is found in the array 'nums'.\nReturns the final value of 'original' after repeating this process.\n>>> findFinalValue([5, 3, 6, 1, 12], 3)\n24 // 3 is found, becomes 6; 6 is found, becomes 12; 12 is found, becomes 24; 24 not found.\n>>> findFinalValue([2, 7, 9], 4)\n4 // 4 is not found, original remains 4.\n*/",
      "es": "import Foundation\n\nfunc findFinalValue(_ nums: [Int], _ original: Int) -> Int {\n/**\nDuplica continuamente el valor de 'original' si se encuentra en el array 'nums'.\nDevuelve el valor final de 'original' después de repetir este proceso.\n>>> findFinalValue([5, 3, 6, 1, 12], 3)\n24 // 3 se encuentra, se convierte en 6; 6 se encuentra, se convierte en 12; 12 se encuentra, se convierte en 24; 24 no se encuentra.\n>>> findFinalValue([2, 7, 9], 4)\n4 // 4 no se encuentra, original permanece 4.\n*/",
      "arb": "import Foundation\n\nfunc findFinalValue(_ nums: [Int], _ original: Int) -> Int {\n/**\nيقوم بمضاعفة قيمة 'original' باستمرار إذا تم العثور عليها في المصفوفة 'nums'.\nيعيد القيمة النهائية لـ 'original' بعد تكرار هذه العملية.\n>>> findFinalValue([5, 3, 6, 1, 12], 3)\n24 // تم العثور على 3، تصبح 6؛ تم العثور على 6، تصبح 12؛ تم العثور على 12، تصبح 24؛ 24 لم يتم العثور عليها.\n>>> findFinalValue([2, 7, 9], 4)\n4 // 4 لم يتم العثور عليها، تبقى original كما هي 4.\n*/",
      "sw": "import Foundation\n\nfunc findFinalValue(_ nums: [Int], _ original: Int) -> Int {\n/**\nInazidisha mara mbili thamani ya 'original' endapo inapatikana katika orodha 'nums'.\nInarudisha thamani ya mwisho ya 'original' baada ya kurudia mchakato huu.\n>>> findFinalValue([5, 3, 6, 1, 12], 3)\n24 // 3 inapatikana, inakuwa 6; 6 inapatikana, inakuwa 12; 12 inapatikana, inakuwa 24; 24 haipatikani.\n>>> findFinalValue([2, 7, 9], 4)\n4 // 4 haipatikani, original inabaki 4.\n*/",
      "tr": "import Foundation\n\nfunc findFinalValue(_ nums: [Int], _ original: Int) -> Int {\n/**\n'original' değerini 'nums' dizisinde bulundukça sürekli iki katına çıkarır.\nBu işlemi tekrarladıktan sonra 'original' değerinin son halini döndürür.\n>>> findFinalValue([5, 3, 6, 1, 12], 3)\n24 // 3 bulundu, 6 oldu; 6 bulundu, 12 oldu; 12 bulundu, 24 oldu; 24 bulunamadı.\n>>> findFinalValue([2, 7, 9], 4)\n4 // 4 bulunamadı, original 4 olarak kalır.\n*/",
      "vi": "import Foundation\n\nfunc findFinalValue(_ nums: [Int], _ original: Int) -> Int {\n/**\nLiên tục nhân đôi giá trị của 'original' nếu nó được tìm thấy trong mảng 'nums'.\nTrả về giá trị cuối cùng của 'original' sau khi lặp lại quá trình này.\n>>> findFinalValue([5, 3, 6, 1, 12], 3)\n24 // 3 được tìm thấy, trở thành 6; 6 được tìm thấy, trở thành 12; 12 được tìm thấy, trở thành 24; 24 không được tìm thấy.\n>>> findFinalValue([2, 7, 9], 4)\n4 // 4 không được tìm thấy, original vẫn là 4.\n*/"
    },
    "prompt_bertscore": {
      "es": "0.9982113334187809",
      "arb": "0.9955733233282564",
      "sw": "0.9842353025484041",
      "tr": "0.9444742673943642",
      "vi": "0.996322159864758"
    },
    "canonical_solution": "var current = original\nlet numSet = Set(nums) // Convert to set for O(1) lookup\nwhile numSet.contains(current) {\ncurrent *= 2\n}\nreturn current\n}",
    "instruction": {
      "en": "func findFinalValue(_ nums: [Int], _ original: Int) -> Int {\nvar current = original\nlet numSet = Set(nums) // Convert to set for O(1) lookup\nwhile numSet.contains(current) {\ncurrent *= 2\n}\nreturn current\n}\n\nProvide a concise natural language description (docstring) of the Swift code in English using at most 500 characters.",
      "es": "func findFinalValue(_ nums: [Int], _ original: Int) -> Int {\nvar current = original\nlet numSet = Set(nums) // Convert to set for O(1) lookup\nwhile numSet.contains(current) {\ncurrent *= 2\n}\nreturn current\n}\n\nProporcione una descripción concisa en lenguaje natural (docstring) del código Swift en español utilizando un máximo de 500 caracteres.",
      "arb": "func findFinalValue(_ nums: [Int], _ original: Int) -> Int {\nvar current = original\nlet numSet = Set(nums) // Convert to set for O(1) lookup\nwhile numSet.contains(current) {\ncurrent *= 2\n}\nreturn current\n}\n\nقدم وصفًا موجزًا بلغة طبيعية (docstring) للكود المكتوب بلغة Swift باللغة العربية الفصحى باستخدام ما لا يزيد عن 500 حرف.",
      "sw": "func findFinalValue(_ nums: [Int], _ original: Int) -> Int {\nvar current = original\nlet numSet = Set(nums) // Convert to set for O(1) lookup\nwhile numSet.contains(current) {\ncurrent *= 2\n}\nreturn current\n}\n\nToa maelezo mafupi ya lugha asilia (docstring) ya msimbo wa Swift kwa Kiswahili kwa kutumia herufi zisizozidi 500.",
      "tr": "func findFinalValue(_ nums: [Int], _ original: Int) -> Int {\nvar current = original\nlet numSet = Set(nums) // Convert to set for O(1) lookup\nwhile numSet.contains(current) {\ncurrent *= 2\n}\nreturn current\n}\n\nSwift kodunun işlevini açıklayan, en fazla 500 karakterlik özlü bir doğal dil açıklaması (docstring) sağlayın.",
      "vi": "func findFinalValue(_ nums: [Int], _ original: Int) -> Int {\nvar current = original\nlet numSet = Set(nums) // Convert to set for O(1) lookup\nwhile numSet.contains(current) {\ncurrent *= 2\n}\nreturn current\n}\n\nCung cấp mô tả ngắn gọn bằng ngôn ngữ tự nhiên (docstring) cho mã Swift bằng tiếng Việt, sử dụng tối đa 500 ký tự."
    },
    "instruction_bertscore": {
      "es": "0.9676013985493994",
      "arb": "0.8979057718214968",
      "sw": "0.942496901951162",
      "tr": "0.8847876255668097",
      "vi": "0.9256006072188102"
    },
    "level": "",
    "test": "func checkFindFinalValue(_ findFinalValue: ([Int], Int) -> Int) {\nassert(findFinalValue([5, 3, 6, 1, 12], 3) == 24)\nassert(findFinalValue([2, 7, 9], 4) == 4)\nassert(findFinalValue([1, 2, 4, 8, 16], 1) == 32)\nassert(findFinalValue([10, 20, 30, 40], 10) == 80)\nassert(findFinalValue([5, 10, 20, 40], 2) == 2)\nassert(findFinalValue([], 1) == 1)\nassert(findFinalValue([100, 200, 300], 100) == 400)\n}\n\ncheckFindFinalValue(findFinalValue)",
    "entry_point": "findFinalValue",
    "signature": "func findFinalValue(_ nums: [Int], _ original: Int) -> Int {",
    "docstring": {
      "en": "\nContinuously doubles the value of 'original' if it is found in the array 'nums'.\nReturns the final value of 'original' after repeating this process.\n>>> findFinalValue([5, 3, 6, 1, 12], 3)\n24 // 3 is found, becomes 6; 6 is found, becomes 12; 12 is found, becomes 24; 24 not found.\n>>> findFinalValue([2, 7, 9], 4)\n4 // 4 is not found, original remains 4.\n",
      "es": "Duplica continuamente el valor de 'original' si se encuentra en el array 'nums'.\nDevuelve el valor final de 'original' después de repetir este proceso.\n>>> findFinalValue([5, 3, 6, 1, 12], 3)\n24 // 3 se encuentra, se convierte en 6; 6 se encuentra, se convierte en 12; 12 se encuentra, se convierte en 24; 24 no se encuentra.\n>>> findFinalValue([2, 7, 9], 4)\n4 // 4 no se encuentra, original permanece 4.",
      "arb": "يضاعف باستمرار قيمة 'original' إذا تم العثور عليها في المصفوفة 'nums'.\nيعيد القيمة النهائية لـ 'original' بعد تكرار هذه العملية.\n>>> findFinalValue([5, 3, 6, 1, 12], 3)\n24 // تم العثور على 3، تصبح 6؛ تم العثور على 6، تصبح 12؛ تم العثور على 12، تصبح 24؛ 24 لم يتم العثور عليها.\n>>> findFinalValue([2, 7, 9], 4)\n4 // 4 لم يتم العثور عليها، تبقى original كما هي 4.",
      "sw": "Inaendelea kuliongeza mara mbili thamani ya 'original' ikiwa inapatikana katika safu 'nums'. Inarudisha thamani ya mwisho ya 'original' baada ya kurudia mchakato huu.\n>>> findFinalValue([5, 3, 6, 1, 12], 3)\n24 // 3 inapatikana, inakuwa 6; 6 inapatikana, inakuwa 12; 12 inapatikana, inakuwa 24; 24 haipatikani.\n>>> findFinalValue([2, 7, 9], 4)\n4 // 4 haipatikani, original inabaki 4.",
      "tr": "'original' değerini, 'nums' dizisinde bulunursa sürekli olarak iki katına çıkarır. Bu işlemi tekrarladıktan sonra 'original' değerinin son halini döndürür.\n>>> findFinalValue([5, 3, 6, 1, 12], 3)\n24 // 3 bulunur, 6 olur; 6 bulunur, 12 olur; 12 bulunur, 24 olur; 24 bulunmaz.\n>>> findFinalValue([2, 7, 9], 4)\n4 // 4 bulunmaz, original 4 olarak kalır.",
      "vi": "Liên tục nhân đôi giá trị của 'original' nếu nó được tìm thấy trong mảng 'nums'.  \nTrả về giá trị cuối cùng của 'original' sau khi lặp lại quá trình này.\n>>> findFinalValue([5, 3, 6, 1, 12], 3)\n24 // 3 được tìm thấy, trở thành 6; 6 được tìm thấy, trở thành 12; 12 được tìm thấy, trở thành 24; 24 không được tìm thấy.\n>>> findFinalValue([2, 7, 9], 4)\n4 // 4 không được tìm thấy, original vẫn là 4."
    },
    "docstring_bertscore": {
      "es": "0.9930783271120772",
      "arb": "0.9775770135457336",
      "sw": "0.9750228254760059",
      "tr": "0.9454970152263129",
      "vi": "0.9930783271120772"
    }
  },
  {
    "task_id": "Swift/8",
    "prompt": {
      "en": "import Foundation\n\nfunc reorderArray(_ nums: [Int]) -> [Int] {\n/**\nReorders the array 'nums' by sorting odd indices in non-increasing order and even indices in non-decreasing order.\n>>> reorderArray([4, 1, 2, 3])\n[2, 3, 4, 1] // Even indices (0, 2) sorted as [2, 4], odd indices (1, 3) sorted as [3, 1].\n>>> reorderArray([6, 5, 4, 3, 2, 1])\n[2, 5, 4, 3, 6, 1]\n*/",
      "es": "import Foundation\n\nfunc reorderArray(_ nums: [Int]) -> [Int] {\n/**\nReordena el array 'nums' ordenando los índices impares en orden no creciente y los índices pares en orden no decreciente.\n>>> reorderArray([4, 1, 2, 3])\n[2, 3, 4, 1] // Índices pares (0, 2) ordenados como [2, 4], índices impares (1, 3) ordenados como [3, 1].\n>>> reorderArray([6, 5, 4, 3, 2, 1])\n[2, 5, 4, 3, 6, 1]\n*/",
      "arb": "import Foundation\n\nfunc reorderArray(_ nums: [Int]) -> [Int] {\n/**\nيعيد ترتيب المصفوفة 'nums' عن طريق فرز الفهارس الفردية بترتيب غير متزايد والفهارس الزوجية بترتيب غير تناقصي.\n>>> reorderArray([4, 1, 2, 3])\n[2, 3, 4, 1] // الفهارس الزوجية (0, 2) مرتبة كـ [2, 4]، الفهارس الفردية (1, 3) مرتبة كـ [3, 1].\n>>> reorderArray([6, 5, 4, 3, 2, 1])\n[2, 5, 4, 3, 6, 1]\n*/",
      "sw": "import Foundation\n\nfunc reorderArray(_ nums: [Int]) -> [Int] {\n/**\nHupanga upya orodha 'nums' kwa kupanga fahirisi za nambari zisizo za kawaida kwa mpangilio usiopungua na fahirisi za nambari za kawaida kwa mpangilio usiopungua.\n>>> reorderArray([4, 1, 2, 3])\n[2, 3, 4, 1] // Fahirisi za kawaida (0, 2) zimepangwa kama [2, 4], fahirisi zisizo za kawaida (1, 3) zimepangwa kama [3, 1].\n>>> reorderArray([6, 5, 4, 3, 2, 1])\n[2, 5, 4, 3, 6, 1]\n*/",
      "tr": "import Foundation\n\nfunc reorderArray(_ nums: [Int]) -> [Int] {\n/**\n'nums' dizisini, tek indeksleri azalan sırayla ve çift indeksleri artan sırayla sıralayarak yeniden düzenler.\n>>> reorderArray([4, 1, 2, 3])\n[2, 3, 4, 1] // Çift indeksler (0, 2) [2, 4] olarak sıralanır, tek indeksler (1, 3) [3, 1] olarak sıralanır.\n>>> reorderArray([6, 5, 4, 3, 2, 1])\n[2, 5, 4, 3, 6, 1]\n*/",
      "vi": "import Foundation\n\nfunc reorderArray(_ nums: [Int]) -> [Int] {\n/**\nSắp xếp lại mảng 'nums' bằng cách sắp xếp các chỉ số lẻ theo thứ tự không tăng và các chỉ số chẵn theo thứ tự không giảm.\n>>> reorderArray([4, 1, 2, 3])\n[2, 3, 4, 1] // Các chỉ số chẵn (0, 2) được sắp xếp thành [2, 4], các chỉ số lẻ (1, 3) được sắp xếp thành [3, 1].\n>>> reorderArray([6, 5, 4, 3, 2, 1])\n[2, 5, 4, 3, 6, 1]\n*/"
    },
    "prompt_bertscore": {
      "es": "0.9899256657042915",
      "arb": "0.9831926916783519",
      "sw": "0.9601213756603876",
      "tr": "0.9505086583702042",
      "vi": "0.9678959674044741"
    },
    "canonical_solution": "var evens = nums.enumerated().filter { $0.offset % 2 == 0 }.map { $0.element }.sorted(by: <)\nvar odds = nums.enumerated().filter { $0.offset % 2 != 0 }.map { $0.element }.sorted(by: >)\n\nvar result = [Int]()\nfor i in 0..<nums.count {\nresult.append(i % 2 == 0 ? evens.removeFirst() : odds.removeFirst())\n}\nreturn result\n}",
    "instruction": {
      "en": "func reorderArray(_ nums: [Int]) -> [Int] {\nvar evens = nums.enumerated().filter { $0.offset % 2 == 0 }.map { $0.element }.sorted(by: <)\nvar odds = nums.enumerated().filter { $0.offset % 2 != 0 }.map { $0.element }.sorted(by: >)\n\nvar result = [Int]()\nfor i in 0..<nums.count {\nresult.append(i % 2 == 0 ? evens.removeFirst() : odds.removeFirst())\n}\nreturn result\n}\n\nProvide a concise natural language description (docstring) of the Swift code in English using at most 500 characters.",
      "es": "func reorderArray(_ nums: [Int]) -> [Int] {\nvar evens = nums.enumerated().filter { $0.offset % 2 == 0 }.map { $0.element }.sorted(by: <)\nvar odds = nums.enumerated().filter { $0.offset % 2 != 0 }.map { $0.element }.sorted(by: >)\n\nvar result = [Int]()\nfor i in 0..<nums.count {\nresult.append(i % 2 == 0 ? evens.removeFirst() : odds.removeFirst())\n}\nreturn result\n}\n\nProporcione una descripción concisa en lenguaje natural (docstring) del código Swift en español utilizando como máximo 500 caracteres.",
      "arb": "func reorderArray(_ nums: [Int]) -> [Int] {\nvar evens = nums.enumerated().filter { $0.offset % 2 == 0 }.map { $0.element }.sorted(by: <)\nvar odds = nums.enumerated().filter { $0.offset % 2 != 0 }.map { $0.element }.sorted(by: >)\n\nvar result = [Int]()\nfor i in 0..<nums.count {\nresult.append(i % 2 == 0 ? evens.removeFirst() : odds.removeFirst())\n}\nreturn result\n}\n\nقدم وصفًا موجزًا بلغة طبيعية (docstring) لكود Swift باللغة العربية الفصحى باستخدام 500 حرف كحد أقصى.",
      "sw": "func reorderArray(_ nums: [Int]) -> [Int] {\nvar evens = nums.enumerated().filter { $0.offset % 2 == 0 }.map { $0.element }.sorted(by: <)\nvar odds = nums.enumerated().filter { $0.offset % 2 != 0 }.map { $0.element }.sorted(by: >)\n\nvar result = [Int]()\nfor i in 0..<nums.count {\nresult.append(i % 2 == 0 ? evens.removeFirst() : odds.removeFirst())\n}\nreturn result\n}\n\nToa maelezo mafupi ya lugha ya asili (docstring) ya msimbo wa Swift kwa Kiswahili kwa kutumia herufi zisizozidi 500.",
      "tr": "func reorderArray(_ nums: [Int]) -> [Int] {\nvar evens = nums.enumerated().filter { $0.offset % 2 == 0 }.map { $0.element }.sorted(by: <)\nvar odds = nums.enumerated().filter { $0.offset % 2 != 0 }.map { $0.element }.sorted(by: >)\n\nvar result = [Int]()\nfor i in 0..<nums.count {\nresult.append(i % 2 == 0 ? evens.removeFirst() : odds.removeFirst())\n}\nreturn result\n}\n\nSwift kodunun Türkçe açıklamasını en fazla 500 karakter kullanarak doğal dilde kısa bir şekilde sağlayın.",
      "vi": "func reorderArray(_ nums: [Int]) -> [Int] {\nvar evens = nums.enumerated().filter { $0.offset % 2 == 0 }.map { $0.element }.sorted(by: <)\nvar odds = nums.enumerated().filter { $0.offset % 2 != 0 }.map { $0.element }.sorted(by: >)\n\nvar result = [Int]()\nfor i in 0..<nums.count {\nresult.append(i % 2 == 0 ? evens.removeFirst() : odds.removeFirst())\n}\nreturn result\n}\n\nCung cấp mô tả ngắn gọn bằng ngôn ngữ tự nhiên (docstring) cho mã Swift bằng tiếng Việt, sử dụng tối đa 500 ký tự."
    },
    "instruction_bertscore": {
      "es": "0.9676013985493994",
      "arb": "0.9144786962935237",
      "sw": "0.9096853479383898",
      "tr": "0.842715525929429",
      "vi": "0.9256006072188102"
    },
    "level": "",
    "test": "func checkReorderArray(_ reorderArray: ([Int]) -> [Int]) {\nassert(reorderArray([4, 1, 2, 3]) == [2, 3, 4, 1])\nassert(reorderArray([6, 5, 4, 3, 2, 1]) == [2, 5, 4, 3, 6, 1])\nassert(reorderArray([1, 2, 3, 4, 5, 6]) == [1, 6, 3, 4, 5, 2])\nassert(reorderArray([10, 9, 8, 7, 6, 5, 4, 3, 2, 1]) == [2, 9, 4, 7, 6, 5, 8, 3, 10, 1])\nassert(reorderArray([1]) == [1])\nassert(reorderArray([1, 2]) == [1, 2])\nassert(reorderArray([]) == [])\n}\n\ncheckReorderArray(reorderArray)",
    "entry_point": "reorderArray",
    "signature": "func reorderArray(_ nums: [Int]) -> [Int] {",
    "docstring": {
      "en": "\nReorders the array 'nums' by sorting odd indices in non-increasing order and even indices in non-decreasing order.\n>>> reorderArray([4, 1, 2, 3])\n[2, 3, 4, 1] // Even indices (0, 2) sorted as [2, 4], odd indices (1, 3) sorted as [3, 1].\n>>> reorderArray([6, 5, 4, 3, 2, 1])\n[2, 5, 4, 3, 6, 1]\n",
      "es": "Reordena el array 'nums' ordenando los índices impares en orden no creciente y los índices pares en orden no decreciente.\n>>> reorderArray([4, 1, 2, 3])\n[2, 3, 4, 1] // Índices pares (0, 2) ordenados como [2, 4], índices impares (1, 3) ordenados como [3, 1].\n>>> reorderArray([6, 5, 4, 3, 2, 1])\n[2, 5, 4, 3, 6, 1]",
      "arb": "يعيد ترتيب المصفوفة 'nums' عن طريق فرز الفهارس الفردية بترتيب غير متزايد والفهارس الزوجية بترتيب غير تناقصي.\n>>> reorderArray([4, 1, 2, 3])\n[2, 3, 4, 1] // الفهارس الزوجية (0, 2) مرتبة كـ [2, 4]، الفهارس الفردية (1, 3) مرتبة كـ [3, 1].\n>>> reorderArray([6, 5, 4, 3, 2, 1])\n[2, 5, 4, 3, 6, 1]",
      "sw": "Inapangilia upya safu 'nums' kwa kupanga fahirisi za nambari zisizo za kawaida kwa mpangilio wa kushuka na fahirisi za nambari za kawaida kwa mpangilio wa kupanda.\n>>> reorderArray([4, 1, 2, 3])\n[2, 3, 4, 1] // Fahirisi za kawaida (0, 2) zimepangwa kama [2, 4], fahirisi zisizo za kawaida (1, 3) zimepangwa kama [3, 1].\n>>> reorderArray([6, 5, 4, 3, 2, 1])\n[2, 5, 4, 3, 6, 1]",
      "tr": "Diziyi 'nums', tek indeksleri azalmayan sırada ve çift indeksleri artmayan sırada sıralayarak yeniden düzenler.\n>>> reorderArray([4, 1, 2, 3])\n[2, 3, 4, 1] // Çift indeksler (0, 2) [2, 4] olarak sıralandı, tek indeksler (1, 3) [3, 1] olarak sıralandı.\n>>> reorderArray([6, 5, 4, 3, 2, 1])\n[2, 5, 4, 3, 6, 1]",
      "vi": "Sắp xếp lại mảng 'nums' bằng cách sắp xếp các chỉ số lẻ theo thứ tự không tăng và các chỉ số chẵn theo thứ tự không giảm.\n>>> reorderArray([4, 1, 2, 3])\n[2, 3, 4, 1] // Các chỉ số chẵn (0, 2) được sắp xếp thành [2, 4], các chỉ số lẻ (1, 3) được sắp xếp thành [3, 1].\n>>> reorderArray([6, 5, 4, 3, 2, 1])\n[2, 5, 4, 3, 6, 1]"
    },
    "docstring_bertscore": {
      "es": "0.9846132961635135",
      "arb": "0.9726638910708356",
      "sw": "0.9467541469078827",
      "tr": "0.9563559395271092",
      "vi": "0.9540724846667321"
    }
  },
  {
    "task_id": "Swift/9",
    "prompt": {
      "en": "import Foundation\n\nfunc countDivisiblePairs(_ nums: [Int], _ k: Int) -> Int {\n/**\nCounts the number of pairs (i, j) in the array 'nums' where nums[i] == nums[j] and (i * j) is divisible by 'k'.\nConditions: 0 <= i < j < n\n>>> countDivisiblePairs([1, 2, 3, 1, 2, 3], 3)\n1 // The pairs (0, 3)satisfy the conditions.\n>>> countDivisiblePairs([1, 1, 1, 1], 1)\n6 // All pairs satisfy the conditions since every (i * j) is divisible by 1.\n*/",
      "es": "import Foundation\n\nfunc countDivisiblePairs(_ nums: [Int], _ k: Int) -> Int {\n/**\nCuenta el número de pares (i, j) en el array 'nums' donde nums[i] == nums[j] y (i * j) es divisible por 'k'.\nCondiciones: 0 <= i < j < n\n>>> countDivisiblePairs([1, 2, 3, 1, 2, 3], 3)\n1 // Los pares (0, 3) satisfacen las condiciones.\n>>> countDivisiblePairs([1, 1, 1, 1], 1)\n6 // Todos los pares satisfacen las condiciones ya que cada (i * j) es divisible por 1.\n*/",
      "arb": "import Foundation\n\nfunc countDivisiblePairs(_ nums: [Int], _ k: Int) -> Int {\n/**\nيحسب عدد الأزواج (i, j) في المصفوفة 'nums' حيث nums[i] == nums[j] و (i * j) قابل للقسمة على 'k'.\nالشروط: 0 <= i < j < n\n>>> countDivisiblePairs([1, 2, 3, 1, 2, 3], 3)\n1 // الأزواج (0, 3) تفي بالشروط.\n>>> countDivisiblePairs([1, 1, 1, 1], 1)\n6 // جميع الأزواج تفي بالشروط لأن كل (i * j) قابل للقسمة على 1.\n*/",
      "sw": "import Foundation\n\nfunc countDivisiblePairs(_ nums: [Int], _ k: Int) -> Int {\n/**\nInahesabu idadi ya jozi (i, j) katika safu 'nums' ambapo nums[i] == nums[j] na (i * j) inagawanyika kwa 'k'.\nMasharti: 0 <= i < j < n\n>>> countDivisiblePairs([1, 2, 3, 1, 2, 3], 3)\n1 // Jozi (0, 3) inakidhi masharti.\n>>> countDivisiblePairs([1, 1, 1, 1], 1)\n6 // Jozi zote zinakidhi masharti kwa kuwa kila (i * j) inagawanyika kwa 1.\n*/",
      "tr": "import Foundation\n\nfunc countDivisiblePairs(_ nums: [Int], _ k: Int) -> Int {\n/**\nDizideki 'nums' dizisinde nums[i] == nums[j] ve (i * j) 'k' ile bölünebilir olduğunda çiftlerin (i, j) sayısını sayar.\nKoşullar: 0 <= i < j < n\n>>> countDivisiblePairs([1, 2, 3, 1, 2, 3], 3)\n1 // Çiftler (0, 3) koşulları sağlar.\n>>> countDivisiblePairs([1, 1, 1, 1], 1)\n6 // Tüm çiftler koşulları sağlar çünkü her (i * j) 1 ile bölünebilir.\n*/",
      "vi": "import Foundation\n\nfunc countDivisiblePairs(_ nums: [Int], _ k: Int) -> Int {\n/**\nĐếm số cặp (i, j) trong mảng 'nums' sao cho nums[i] == nums[j] và (i * j) chia hết cho 'k'.\nĐiều kiện: 0 <= i < j < n\n>>> countDivisiblePairs([1, 2, 3, 1, 2, 3], 3)\n1 // Các cặp (0, 3) thỏa mãn điều kiện.\n>>> countDivisiblePairs([1, 1, 1, 1], 1)\n6 // Tất cả các cặp thỏa mãn điều kiện vì mọi (i * j) đều chia hết cho 1.\n*/"
    },
    "prompt_bertscore": {
      "es": "0.9879800811220548",
      "arb": "0.9812993468863274",
      "sw": "0.9840001241772587",
      "tr": "0.9876751834871662",
      "vi": "0.9809010929723524"
    },
    "canonical_solution": "var count = 0\nlet n = nums.count\nfor i in 0..<n {\nfor j in (i + 1)..<n {\nif nums[i] == nums[j] && (i * j) % k == 0 {\ncount += 1\n}\n}\n}\nreturn count\n}",
    "instruction": {
      "en": "func countDivisiblePairs(_ nums: [Int], _ k: Int) -> Int {\nvar count = 0\nlet n = nums.count\nfor i in 0..<n {\nfor j in (i + 1)..<n {\nif nums[i] == nums[j] && (i * j) % k == 0 {\ncount += 1\n}\n}\n}\nreturn count\n}\n\nProvide a concise natural language description (docstring) of the Swift code in English using at most 500 characters.",
      "es": "func countDivisiblePairs(_ nums: [Int], _ k: Int) -> Int {\nvar count = 0\nlet n = nums.count\nfor i in 0..<n {\nfor j in (i + 1)..<n {\nif nums[i] == nums[j] && (i * j) % k == 0 {\ncount += 1\n}\n}\n}\nreturn count\n}\n\nProporciona una descripción concisa en lenguaje natural (docstring) del código Swift en español utilizando como máximo 500 caracteres.",
      "arb": "func countDivisiblePairs(_ nums: [Int], _ k: Int) -> Int {\nvar count = 0\nlet n = nums.count\nfor i in 0..<n {\nfor j in (i + 1)..<n {\nif nums[i] == nums[j] && (i * j) % k == 0 {\ncount += 1\n}\n}\n}\nreturn count\n}\n\nقدم وصفًا موجزًا بلغة طبيعية (docstring) لكود Swift باللغة العربية الفصحى باستخدام 500 حرف كحد أقصى.",
      "sw": "func countDivisiblePairs(_ nums: [Int], _ k: Int) -> Int {\nvar count = 0\nlet n = nums.count\nfor i in 0..<n {\nfor j in (i + 1)..<n {\nif nums[i] == nums[j] && (i * j) % k == 0 {\ncount += 1\n}\n}\n}\nreturn count\n}\n\nToa maelezo mafupi ya lugha ya asili (docstring) ya msimbo wa Swift kwa Kiswahili kwa kutumia herufi zisizozidi 500.",
      "tr": "func countDivisiblePairs(_ nums: [Int], _ k: Int) -> Int {\nvar count = 0\nlet n = nums.count\nfor i in 0..<n {\nfor j in (i + 1)..<n {\nif nums[i] == nums[j] && (i * j) % k == 0 {\ncount += 1\n}\n}\n}\nreturn count\n}\n\nSwift kodunun işlevselliğini açıklayan, en fazla 500 karakter uzunluğunda özlü bir doğal dil açıklaması (docstring) sağlayın.",
      "vi": "func countDivisiblePairs(_ nums: [Int], _ k: Int) -> Int {\nvar count = 0\nlet n = nums.count\nfor i in 0..<n {\nfor j in (i + 1)..<n {\nif nums[i] == nums[j] && (i * j) % k == 0 {\ncount += 1\n}\n}\n}\nreturn count\n}\n\nCung cấp mô tả ngắn gọn bằng ngôn ngữ tự nhiên (docstring) cho mã Swift bằng tiếng Việt, sử dụng tối đa 500 ký tự."
    },
    "instruction_bertscore": {
      "es": "0.9676013985493994",
      "arb": "0.9202294430852458",
      "sw": "0.9148419912604365",
      "tr": "0.8731472893470221",
      "vi": "0.9256006072188102"
    },
    "level": "",
    "test": "func checkCountDivisiblePairs(_ countDivisiblePairs: ([Int], Int) -> Int) {\nassert(countDivisiblePairs([1, 2, 3, 1, 2, 3], 3) == 1)\nassert(countDivisiblePairs([1, 1, 1, 1], 1) == 6)\nassert(countDivisiblePairs([1, 2, 3, 4, 5, 6], 7) == 0)\nassert(countDivisiblePairs([1, 2, 2, 1, 2], 2) == 4)\nassert(countDivisiblePairs([4, 4, 4, 4], 4) == 3)\nassert(countDivisiblePairs([], 5) == 0)\nassert(countDivisiblePairs([2, 2, 2, 2, 2], 3) == 7 )\n}\n\ncheckCountDivisiblePairs(countDivisiblePairs)",
    "entry_point": "countDivisiblePairs",
    "signature": "func countDivisiblePairs(_ nums: [Int], _ k: Int) -> Int {",
    "docstring": {
      "en": "\nCounts the number of pairs (i, j) in the array 'nums' where nums[i] == nums[j] and (i * j) is divisible by 'k'.\nConditions: 0 <= i < j < n\n>>> countDivisiblePairs([1, 2, 3, 1, 2, 3], 3)\n1 // The pairs (0, 3)satisfy the conditions.\n>>> countDivisiblePairs([1, 1, 1, 1], 1)\n6 // All pairs satisfy the conditions since every (i * j) is divisible by 1.\n",
      "es": "Cuenta el número de pares (i, j) en el array 'nums' donde nums[i] == nums[j] y (i * j) es divisible por 'k'.\nCondiciones: 0 <= i < j < n\n>>> countDivisiblePairs([1, 2, 3, 1, 2, 3], 3)\n1 // Los pares (0, 3) satisfacen las condiciones.\n>>> countDivisiblePairs([1, 1, 1, 1], 1)\n6 // Todos los pares satisfacen las condiciones ya que cada (i * j) es divisible por 1.",
      "arb": "يحسب عدد الأزواج (i, j) في المصفوفة 'nums' حيث nums[i] == nums[j] و (i * j) قابل للقسمة على 'k'.\nالشروط: 0 <= i < j < n\n>>> countDivisiblePairs([1, 2, 3, 1, 2, 3], 3)\n1 // الأزواج (0, 3) تحقق الشروط.\n>>> countDivisiblePairs([1, 1, 1, 1], 1)\n6 // جميع الأزواج تحقق الشروط لأن كل (i * j) قابل للقسمة على 1.",
      "sw": "Hesabu idadi ya jozi (i, j) katika safu 'nums' ambapo nums[i] == nums[j] na (i * j) inagawanyika kwa 'k'.\nMasharti: 0 <= i < j < n\n>>> countDivisiblePairs([1, 2, 3, 1, 2, 3], 3)\n1 // Jozi (0, 3) inakidhi masharti.\n>>> countDivisiblePairs([1, 1, 1, 1], 1)\n6 // Jozi zote zinakidhi masharti kwa kuwa kila (i * j) inagawanyika kwa 1.",
      "tr": "'nums' dizisinde nums[i] == nums[j] ve (i * j) 'k' ile bölünebilir olduğunda (i, j) çiftlerinin sayısını sayar.\nKoşullar: 0 <= i < j < n\n>>> countDivisiblePairs([1, 2, 3, 1, 2, 3], 3)\n1 // (0, 3) çiftleri koşulları sağlar.\n>>> countDivisiblePairs([1, 1, 1, 1], 1)\n6 // Tüm çiftler koşulları sağlar çünkü her (i * j) 1 ile bölünebilir.",
      "vi": "Đếm số cặp (i, j) trong mảng 'nums' sao cho nums[i] == nums[j] và (i * j) chia hết cho 'k'.\nĐiều kiện: 0 <= i < j < n\n>>> countDivisiblePairs([1, 2, 3, 1, 2, 3], 3)\n1 // Các cặp (0, 3) thỏa mãn các điều kiện.\n>>> countDivisiblePairs([1, 1, 1, 1], 1)\n6 // Tất cả các cặp đều thỏa mãn các điều kiện vì mọi (i * j) đều chia hết cho 1."
    },
    "docstring_bertscore": {
      "es": "0.9793549540863768",
      "arb": "0.9730804189798657",
      "sw": "0.9772308007915897",
      "tr": "0.9549448693002374",
      "vi": "0.9796759407821292"
    }
  },
  {
    "task_id": "Swift/10",
    "prompt": {
      "en": "import Foundation\n\nfunc countPrefixStrings(_ words: [String], _ pref: String) -> Int {\n/**\nCounts the number of strings in the array 'words' that start with the prefix 'pref'.\n>>> countPrefixStrings([\"apple\", \"app\", \"application\", \"orange\"], \"app\")\n3 // \"apple\", \"app\", and \"application\" start with \"app\".\n>>> countPrefixStrings([\"hello\", \"world\"], \"he\")\n1 // Only \"hello\" starts with \"he\".\n*/",
      "es": "import Foundation\n\nfunc countPrefixStrings(_ words: [String], _ pref: String) -> Int {\n/**\nCuenta el número de cadenas en el arreglo 'words' que comienzan con el prefijo 'pref'.\n>>> countPrefixStrings([\"apple\", \"app\", \"application\", \"orange\"], \"app\")\n3 // \"apple\", \"app\" y \"application\" comienzan con \"app\".\n>>> countPrefixStrings([\"hello\", \"world\"], \"he\")\n1 // Solo \"hello\" comienza con \"he\".\n*/",
      "arb": "import Foundation\n\nfunc countPrefixStrings(_ words: [String], _ pref: String) -> Int {\n/**\nيحسب عدد السلاسل النصية في المصفوفة 'words' التي تبدأ بالمقطع 'pref'.\n>>> countPrefixStrings([\"apple\", \"app\", \"application\", \"orange\"], \"app\")\n3 // \"apple\"، \"app\"، و \"application\" تبدأ بـ \"app\".\n>>> countPrefixStrings([\"hello\", \"world\"], \"he\")\n1 // فقط \"hello\" تبدأ بـ \"he\".\n*/",
      "sw": "import Foundation\n\nfunc countPrefixStrings(_ words: [String], _ pref: String) -> Int {\n/**\nInahesabu idadi ya misururu katika safu 'words' inayooanza na kiambishi awali 'pref'.\n>>> countPrefixStrings([\"apple\", \"app\", \"application\", \"orange\"], \"app\")\n3 // \"apple\", \"app\", na \"application\" zinaanza na \"app\".\n>>> countPrefixStrings([\"hello\", \"world\"], \"he\")\n1 // Ni \"hello\" pekee inayoanza na \"he\".\n*/",
      "tr": "import Foundation\n\nfunc countPrefixStrings(_ words: [String], _ pref: String) -> Int {\n/**\nDizideki 'words' içinde 'pref' öneki ile başlayan kaç tane string olduğunu sayar.\n>>> countPrefixStrings([\"apple\", \"app\", \"application\", \"orange\"], \"app\")\n3 // \"apple\", \"app\" ve \"application\" \"app\" ile başlar.\n>>> countPrefixStrings([\"hello\", \"world\"], \"he\")\n1 // Sadece \"hello\" \"he\" ile başlar.\n*/",
      "vi": "import Foundation\n\nfunc countPrefixStrings(_ words: [String], _ pref: String) -> Int {\n/**\nĐếm số lượng chuỗi trong mảng 'words' bắt đầu với tiền tố 'pref'.\n>>> countPrefixStrings([\"apple\", \"app\", \"application\", \"orange\"], \"app\")\n3 // \"apple\", \"app\", và \"application\" bắt đầu với \"app\".\n>>> countPrefixStrings([\"hello\", \"world\"], \"he\")\n1 // Chỉ có \"hello\" bắt đầu với \"he\".\n*/"
    },
    "prompt_bertscore": {
      "es": "0.9969603592790232",
      "arb": "0.9928926077058097",
      "sw": "0.999999801369619",
      "tr": "0.9863977915067309",
      "vi": "0.9950469528185141"
    },
    "canonical_solution": "return words.filter { $0.hasPrefix(pref) }.count\n}",
    "instruction": {
      "en": "func countPrefixStrings(_ words: [String], _ pref: String) -> Int {\nreturn words.filter { $0.hasPrefix(pref) }.count\n}\n\nProvide a concise natural language description (docstring) of the Swift code in English using at most 500 characters.",
      "es": "func countPrefixStrings(_ words: [String], _ pref: String) -> Int {\nreturn words.filter { $0.hasPrefix(pref) }.count\n}\n\nProporcione una descripción concisa en lenguaje natural (docstring) del código Swift en español utilizando un máximo de 500 caracteres.",
      "arb": "func countPrefixStrings(_ words: [String], _ pref: String) -> Int {\nreturn words.filter { $0.hasPrefix(pref) }.count\n}\n\nقدم وصفًا موجزًا بلغة طبيعية (docstring) لكود Swift باللغة العربية الفصحى باستخدام ما لا يزيد عن 500 حرف.",
      "sw": "func countPrefixStrings(_ words: [String], _ pref: String) -> Int {\nreturn words.filter { $0.hasPrefix(pref) }.count\n}\n\nToa maelezo mafupi ya lugha asilia (docstring) ya msimbo wa Swift kwa Kiswahili kwa kutumia herufi zisizozidi 500.",
      "tr": "func countPrefixStrings(_ words: [String], _ pref: String) -> Int {\nreturn words.filter { $0.hasPrefix(pref) }.count\n}\n\nSwift kodunun Türkçe dilinde en fazla 500 karakter kullanarak kısa bir doğal dil açıklamasını (docstring) sağlayın.",
      "vi": "func countPrefixStrings(_ words: [String], _ pref: String) -> Int {\nreturn words.filter { $0.hasPrefix(pref) }.count\n}\n\nCung cấp mô tả ngắn gọn bằng ngôn ngữ tự nhiên (docstring) cho mã Swift bằng tiếng Việt, sử dụng tối đa 500 ký tự."
    },
    "instruction_bertscore": {
      "es": "0.9676013985493994",
      "arb": "0.8880608556158835",
      "sw": "0.942496901951162",
      "tr": "0.9225164732924815",
      "vi": "0.9394594461643764"
    },
    "level": "",
    "test": "func checkCountPrefixStrings(_ countPrefixStrings: ([String], String) -> Int) {\nassert(countPrefixStrings([\"apple\", \"app\", \"application\", \"orange\"], \"app\") == 3)\nassert(countPrefixStrings([\"hello\", \"world\"], \"he\") == 1)\nassert(countPrefixStrings([\"python\", \"php\", \"perl\", \"java\"], \"p\") == 3)\nassert(countPrefixStrings([\"swift\", \"scala\"], \"s\") == 2)\nassert(countPrefixStrings([\"go\", \"rust\", \"ruby\"], \"c\") == 0)\nassert(countPrefixStrings([], \"test\") == 0)\nassert(countPrefixStrings([\"prefix\", \"preference\", \"preliminary\"], \"pre\") == 3)\n}\n\ncheckCountPrefixStrings(countPrefixStrings)",
    "entry_point": "countPrefixStrings",
    "signature": "func countPrefixStrings(_ words: [String], _ pref: String) -> Int {",
    "docstring": {
      "en": "\nCounts the number of strings in the array 'words' that start with the prefix 'pref'.\n>>> countPrefixStrings([\"apple\", \"app\", \"application\", \"orange\"], \"app\")\n3 // \"apple\", \"app\", and \"application\" start with \"app\".\n>>> countPrefixStrings([\"hello\", \"world\"], \"he\")\n1 // Only \"hello\" starts with \"he\".\n",
      "es": "Cuenta el número de cadenas en el arreglo 'words' que comienzan con el prefijo 'pref'.\n>>> countPrefixStrings([\"apple\", \"app\", \"application\", \"orange\"], \"app\")\n3 // \"apple\", \"app\" y \"application\" comienzan con \"app\".\n>>> countPrefixStrings([\"hello\", \"world\"], \"he\")\n1 // Solo \"hello\" comienza con \"he\".",
      "arb": "يحسب عدد السلاسل النصية في المصفوفة 'words' التي تبدأ بالمقطع 'pref'.\n>>> countPrefixStrings([\"apple\", \"app\", \"application\", \"orange\"], \"app\")\n3 // \"apple\"، \"app\"، و\"application\" تبدأ بـ \"app\".\n>>> countPrefixStrings([\"hello\", \"world\"], \"he\")\n1 // فقط \"hello\" تبدأ بـ \"he\".",
      "sw": "Hesabu idadi ya mistari katika safu 'words' ambayo inaanza na kiambishi awali 'pref'.\n>>> countPrefixStrings([\"apple\", \"app\", \"application\", \"orange\"], \"app\")\n3 // \"apple\", \"app\", na \"application\" zinaanza na \"app\".\n>>> countPrefixStrings([\"hello\", \"world\"], \"he\")\n1 // Ni \"hello\" pekee inayoweza kuanza na \"he\".",
      "tr": "Dizi 'words' içindeki, 'pref' önekiyle başlayan dizgilerin sayısını sayar.\n>>> countPrefixStrings([\"apple\", \"app\", \"application\", \"orange\"], \"app\")\n3 // \"apple\", \"app\" ve \"application\" \"app\" ile başlar.\n>>> countPrefixStrings([\"hello\", \"world\"], \"he\")\n1 // Sadece \"hello\" \"he\" ile başlar.",
      "vi": "Đếm số lượng chuỗi trong mảng 'words' bắt đầu với tiền tố 'pref'.\n>>> countPrefixStrings([\"apple\", \"app\", \"application\", \"orange\"], \"app\")\n3 // \"apple\", \"app\", và \"application\" bắt đầu với \"app\".\n>>> countPrefixStrings([\"hello\", \"world\"], \"he\")\n1 // Chỉ \"hello\" bắt đầu với \"he\"."
    },
    "docstring_bertscore": {
      "es": "0.9926357786231316",
      "arb": "0.9889732330272292",
      "sw": "0.9719063147975685",
      "tr": "0.999999801369619",
      "vi": "0.9926357786231316"
    }
  },
  {
    "task_id": "Swift/11",
    "prompt": {
      "en": "import Foundation\n\nfunc removeAnagramWords(_ words: [String]) -> [String] {\n/**\nRepeatedly removes an element from 'words' at index 'i' if 'words[i]' and 'words[i - 1]' are anagrams,\nuntil no such pairs are left. Returns the modified 'words' array.\n>>> removeAnagramWords([\"ab\", \"ba\", \"cd\", \"dc\", \"e\"])\n[\"ab\", \"cd\", \"e\"] // \"ba\" and \"dc\" are removed as they are anagrams of their previous elements.\n>>> removeAnagramWords([\"abc\", \"cba\", \"bac\", \"acb\"])\n[\"abc\"] // Sequential removal of anagrams results in [\"abc\", \"bac\"], then [\"abc\"].\n*/",
      "es": "import Foundation\n\nfunc removeAnagramWords(_ words: [String]) -> [String] {\n/**\nElimina repetidamente un elemento de 'words' en el índice 'i' si 'words[i]' y 'words[i - 1]' son anagramas,\nhasta que no queden tales pares. Devuelve el array 'words' modificado.\n>>> removeAnagramWords([\"ab\", \"ba\", \"cd\", \"dc\", \"e\"])\n[\"ab\", \"cd\", \"e\"] // \"ba\" y \"dc\" se eliminan ya que son anagramas de sus elementos anteriores.\n>>> removeAnagramWords([\"abc\", \"cba\", \"bac\", \"acb\"])\n[\"abc\"] // La eliminación secuencial de anagramas resulta en [\"abc\", \"bac\"], luego [\"abc\"].\n*/",
      "arb": "import Foundation\n\nfunc removeAnagramWords(_ words: [String]) -> [String] {\n/**\nيزيل بشكل متكرر عنصراً من 'words' عند الفهرس 'i' إذا كانت 'words[i]' و 'words[i - 1]' متشابهتين،\nحتى لا تبقى مثل هذه الأزواج. يعيد مصفوفة 'words' المعدلة.\n>>> removeAnagramWords([\"ab\", \"ba\", \"cd\", \"dc\", \"e\"])\n[\"ab\", \"cd\", \"e\"] // \"ba\" و \"dc\" تمت إزالتهما لأنهما متشابهتان مع العناصر السابقة لهما.\n>>> removeAnagramWords([\"abc\", \"cba\", \"bac\", \"acb\"])\n[\"abc\"] // الإزالة المتتالية للكلمات المتشابهة تؤدي إلى [\"abc\", \"bac\"]، ثم [\"abc\"].\n*/",
      "sw": "import Foundation\n\nfunc removeAnagramWords(_ words: [String]) -> [String] {\n/**\nHuondoa mara kwa mara kipengele kutoka 'words' katika index 'i' ikiwa 'words[i]' na 'words[i - 1]' ni anagramu,\nmpaka hakuna jozi kama hizo zinabaki. Inarudisha safu iliyobadilishwa ya 'words'.\n>>> removeAnagramWords([\"ab\", \"ba\", \"cd\", \"dc\", \"e\"])\n[\"ab\", \"cd\", \"e\"] // \"ba\" na \"dc\" zinaondolewa kwa kuwa ni anagramu za vipengele vyao vya awali.\n>>> removeAnagramWords([\"abc\", \"cba\", \"bac\", \"acb\"])\n[\"abc\"] // Kuondolewa kwa mfululizo kwa anagramu kunasababisha [\"abc\", \"bac\"], kisha [\"abc\"].\n*/",
      "tr": "import Foundation\n\nfunc removeAnagramWords(_ words: [String]) -> [String] {\n/**\n'words' dizisinden, 'words[i]' ve 'words[i - 1]' anagram ise 'i' indeksindeki elemanı tekrar tekrar kaldırır,\nböyle bir çift kalmayana kadar. Değiştirilmiş 'words' dizisini döndürür.\n>>> removeAnagramWords([\"ab\", \"ba\", \"cd\", \"dc\", \"e\"])\n[\"ab\", \"cd\", \"e\"] // \"ba\" ve \"dc\" önceki elemanlarının anagramı olduğu için kaldırılır.\n>>> removeAnagramWords([\"abc\", \"cba\", \"bac\", \"acb\"])\n[\"abc\"] // Anagramların ardışık olarak kaldırılması [\"abc\", \"bac\"], ardından [\"abc\"] ile sonuçlanır.\n*/",
      "vi": "import Foundation\n\nfunc removeAnagramWords(_ words: [String]) -> [String] {\n/**\nLiên tục loại bỏ một phần tử khỏi 'words' tại chỉ số 'i' nếu 'words[i]' và 'words[i - 1]' là các từ đảo chữ cái của nhau,\ncho đến khi không còn cặp nào như vậy. Trả về mảng 'words' đã được sửa đổi.\n>>> removeAnagramWords([\"ab\", \"ba\", \"cd\", \"dc\", \"e\"])\n[\"ab\", \"cd\", \"e\"] // \"ba\" và \"dc\" bị loại bỏ vì chúng là các từ đảo chữ cái của các phần tử trước đó.\n>>> removeAnagramWords([\"abc\", \"cba\", \"bac\", \"acb\"])\n[\"abc\"] // Loại bỏ liên tiếp các từ đảo chữ cái dẫn đến [\"abc\", \"bac\"], sau đó [\"abc\"].\n*/"
    },
    "prompt_bertscore": {
      "es": "0.9919509010693233",
      "arb": "0.9492139855466187",
      "sw": "0.9905922692630446",
      "tr": "0.9764015189507691",
      "vi": "0.9724094455527299"
    },
    "canonical_solution": "var result = words\nvar i = 1\nwhile i < result.count {\nif isAnagram(result[i], result[i - 1]) {\nresult.remove(at: i)\n} else {\ni += 1\n}\n}\nreturn result\n}\n\nfunc isAnagram(_ word1: String, _ word2: String) -> Bool {\nreturn word1.sorted() == word2.sorted()\n}",
    "instruction": {
      "en": "func removeAnagramWords(_ words: [String]) -> [String] {\nvar result = words\nvar i = 1\nwhile i < result.count {\nif isAnagram(result[i], result[i - 1]) {\nresult.remove(at: i)\n} else {\ni += 1\n}\n}\nreturn result\n}\n\nfunc isAnagram(_ word1: String, _ word2: String) -> Bool {\nreturn word1.sorted() == word2.sorted()\n}\n\nProvide a concise natural language description (docstring) of the Swift code in English using at most 500 characters.",
      "es": "func removeAnagramWords(_ words: [String]) -> [String] {\nvar result = words\nvar i = 1\nwhile i < result.count {\nif isAnagram(result[i], result[i - 1]) {\nresult.remove(at: i)\n} else {\ni += 1\n}\n}\nreturn result\n}\n\nfunc isAnagram(_ word1: String, _ word2: String) -> Bool {\nreturn word1.sorted() == word2.sorted()\n}\n\nProporcione una descripción concisa en lenguaje natural (docstring) del código Swift en español utilizando como máximo 500 caracteres.",
      "arb": "func removeAnagramWords(_ words: [String]) -> [String] {\nvar result = words\nvar i = 1\nwhile i < result.count {\nif isAnagram(result[i], result[i - 1]) {\nresult.remove(at: i)\n} else {\ni += 1\n}\n}\nreturn result\n}\n\nfunc isAnagram(_ word1: String, _ word2: String) -> Bool {\nreturn word1.sorted() == word2.sorted()\n}\n\nقدم وصفًا موجزًا بلغة طبيعية (docstring) لكود Swift باللغة العربية الفصحى باستخدام ما لا يزيد عن 500 حرف.",
      "sw": "func removeAnagramWords(_ words: [String]) -> [String] {\nvar result = words\nvar i = 1\nwhile i < result.count {\nif isAnagram(result[i], result[i - 1]) {\nresult.remove(at: i)\n} else {\ni += 1\n}\n}\nreturn result\n}\n\nfunc isAnagram(_ word1: String, _ word2: String) -> Bool {\nreturn word1.sorted() == word2.sorted()\n}\n\nToa maelezo mafupi ya lugha asilia (docstring) ya msimbo wa Swift kwa Kiswahili kwa kutumia herufi zisizozidi 500.",
      "tr": "func removeAnagramWords(_ words: [String]) -> [String] {\nvar result = words\nvar i = 1\nwhile i < result.count {\nif isAnagram(result[i], result[i - 1]) {\nresult.remove(at: i)\n} else {\ni += 1\n}\n}\nreturn result\n}\n\nfunc isAnagram(_ word1: String, _ word2: String) -> Bool {\nreturn word1.sorted() == word2.sorted()\n}\n\nSwift kodunun işlevselliğini açıklayan, en fazla 500 karakter uzunluğunda özlü bir doğal dil açıklaması (docstring) sağlayın.",
      "vi": "func removeAnagramWords(_ words: [String]) -> [String] {\nvar result = words\nvar i = 1\nwhile i < result.count {\nif isAnagram(result[i], result[i - 1]) {\nresult.remove(at: i)\n} else {\ni += 1\n}\n}\nreturn result\n}\n\nfunc isAnagram(_ word1: String, _ word2: String) -> Bool {\nreturn word1.sorted() == word2.sorted()\n}\n\nCung cấp mô tả ngắn gọn bằng ngôn ngữ tự nhiên (docstring) cho mã Swift bằng tiếng Việt với tối đa 500 ký tự."
    },
    "instruction_bertscore": {
      "es": "0.9676013985493994",
      "arb": "0.8880608556158835",
      "sw": "0.942496901951162",
      "tr": "0.8731472893470221",
      "vi": "0.8999953634299838"
    },
    "level": "",
    "test": "func checkRemoveAnagramWords(_ removeAnagramWords: ([String]) -> [String]) {\nassert(removeAnagramWords([\"ab\", \"ba\", \"cd\", \"dc\", \"e\"]) == [\"ab\", \"cd\", \"e\"])\nassert(removeAnagramWords([\"abc\", \"cba\", \"bac\", \"acb\"]) == [\"abc\"])\nassert(removeAnagramWords([\"word\", \"drow\", \"hello\", \"world\"]) == [\"word\", \"hello\",\"world\"])\nassert(removeAnagramWords([\"a\", \"b\", \"c\", \"d\"]) == [\"a\", \"b\", \"c\", \"d\"])\nassert(removeAnagramWords([\"zzz\", \"zzz\", \"zzz\"]) == [\"zzz\"])\nassert(removeAnagramWords([\"abcd\", \"dbca\", \"dcba\"]) == [\"abcd\"])\n}\n\ncheckRemoveAnagramWords(removeAnagramWords)",
    "entry_point": "removeAnagramWords",
    "signature": "func removeAnagramWords(_ words: [String]) -> [String] {",
    "docstring": {
      "en": "\nRepeatedly removes an element from 'words' at index 'i' if 'words[i]' and 'words[i - 1]' are anagrams,\nuntil no such pairs are left. Returns the modified 'words' array.\n>>> removeAnagramWords([\"ab\", \"ba\", \"cd\", \"dc\", \"e\"])\n[\"ab\", \"cd\", \"e\"] // \"ba\" and \"dc\" are removed as they are anagrams of their previous elements.\n>>> removeAnagramWords([\"abc\", \"cba\", \"bac\", \"acb\"])\n[\"abc\"] // Sequential removal of anagrams results in [\"abc\", \"bac\"], then [\"abc\"].\n",
      "es": "Elimina repetidamente un elemento de 'words' en el índice 'i' si 'words[i]' y 'words[i - 1]' son anagramas, hasta que no queden tales pares. Devuelve el array 'words' modificado.\n>>> removeAnagramWords([\"ab\", \"ba\", \"cd\", \"dc\", \"e\"])\n[\"ab\", \"cd\", \"e\"] // \"ba\" y \"dc\" se eliminan ya que son anagramas de sus elementos anteriores.\n>>> removeAnagramWords([\"abc\", \"cba\", \"bac\", \"acb\"])\n[\"abc\"] // La eliminación secuencial de anagramas resulta en [\"abc\", \"bac\"], luego [\"abc\"].",
      "arb": "يزيل بشكل متكرر عنصرًا من 'words' عند الفهرس 'i' إذا كانت 'words[i]' و 'words[i - 1]' متشابهتين، حتى لا تبقى مثل هذه الأزواج. يعيد مصفوفة 'words' المعدلة.\n>>> removeAnagramWords([\"ab\", \"ba\", \"cd\", \"dc\", \"e\"])\n[\"ab\", \"cd\", \"e\"] // تمت إزالة \"ba\" و \"dc\" لأنهما متشابهان مع العناصر السابقة لهما.\n>>> removeAnagramWords([\"abc\", \"cba\", \"bac\", \"acb\"])\n[\"abc\"] // يؤدي الإزالة المتسلسلة للمتشابهات إلى [\"abc\", \"bac\"]، ثم [\"abc\"].",
      "sw": "Huondoa mara kwa mara kipengele kutoka 'words' katika faharasa 'i' ikiwa 'words[i]' na 'words[i - 1]' ni anagramu, hadi hakuna jozi kama hizo zilizobaki. Inarudisha safu iliyobadilishwa ya 'words'.\n>>> removeAnagramWords([\"ab\", \"ba\", \"cd\", \"dc\", \"e\"])\n[\"ab\", \"cd\", \"e\"] // \"ba\" na \"dc\" zimeondolewa kwa kuwa ni anagramu za vipengele vyao vya awali.\n>>> removeAnagramWords([\"abc\", \"cba\", \"bac\", \"acb\"])\n[\"abc\"] // Kuondolewa kwa mfululizo wa anagramu kunasababisha [\"abc\", \"bac\"], kisha [\"abc\"].",
      "tr": "Belirtilen 'words[i]' ve 'words[i - 1]' öğeleri anagram olduğunda, 'words' listesinden 'i' indeksindeki öğeyi tekrar tekrar kaldırır, bu işlem böyle çiftler kalmayana kadar devam eder. Değiştirilmiş 'words' dizisini döndürür.\n>>> removeAnagramWords([\"ab\", \"ba\", \"cd\", \"dc\", \"e\"])\n[\"ab\", \"cd\", \"e\"] // \"ba\" ve \"dc\" önceki öğelerinin anagramı oldukları için kaldırılır.\n>>> removeAnagramWords([\"abc\", \"cba\", \"bac\", \"acb\"])\n[\"abc\"] // Anagramların ardışık olarak kaldırılması [\"abc\", \"bac\"], ardından [\"abc\"] sonucunu verir.",
      "vi": "Liên tục loại bỏ một phần tử từ 'words' tại chỉ số 'i' nếu 'words[i]' và 'words[i - 1]' là các từ đồng âm, cho đến khi không còn cặp nào như vậy. Trả về mảng 'words' đã được chỉnh sửa.\n>>> removeAnagramWords([\"ab\", \"ba\", \"cd\", \"dc\", \"e\"])\n[\"ab\", \"cd\", \"e\"] // \"ba\" và \"dc\" bị loại bỏ vì chúng là các từ đồng âm của các phần tử trước đó.\n>>> removeAnagramWords([\"abc\", \"cba\", \"bac\", \"acb\"])\n[\"abc\"] // Loại bỏ tuần tự các từ đồng âm dẫn đến [\"abc\", \"bac\"], sau đó [\"abc\"]."
    },
    "docstring_bertscore": {
      "es": "0.9879367796989892",
      "arb": "0.9586485313850138",
      "sw": "0.9683210364198888",
      "tr": "0.9319436698067783",
      "vi": "0.968293824057687"
    }
  },
  {
    "task_id": "Swift/12",
    "prompt": {
      "en": "import Foundation\n\nfunc mostFrequentTargetAfterKey(_ nums: [Int], _ key: Int) -> Int {\n/**\nFinds the integer 'target' that most frequently appears immediately after the specified 'key' in the array 'nums'.\n>>> mostFrequentTargetAfterKey([1, 2, 1, 2, 3, 1, 2, 3], 1)\n2 // The number 2 appears twice after 1, more frequently than any other number.\n>>> mostFrequentTargetAfterKey([1, 1, 1, 2, 2, 2, 1, 3, 3], 1)\n1 // The number 1 appears once after 1, which is the most frequent.\n*/",
      "es": "import Foundation\n\nfunc mostFrequentTargetAfterKey(_ nums: [Int], _ key: Int) -> Int {\n/**\nEncuentra el entero 'target' que aparece con mayor frecuencia inmediatamente después del 'key' especificado en el array 'nums'.\n>>> mostFrequentTargetAfterKey([1, 2, 1, 2, 3, 1, 2, 3], 1)\n2 // El número 2 aparece dos veces después de 1, más frecuentemente que cualquier otro número.\n>>> mostFrequentTargetAfterKey([1, 1, 1, 2, 2, 2, 1, 3, 3], 1)\n1 // El número 1 aparece una vez después de 1, que es el más frecuente.\n*/",
      "arb": "import Foundation\n\nfunc mostFrequentTargetAfterKey(_ nums: [Int], _ key: Int) -> Int {\n/**\nيعثر على العدد الصحيح 'target' الذي يظهر بشكل متكرر مباشرة بعد 'key' المحدد في المصفوفة 'nums'.\n>>> mostFrequentTargetAfterKey([1, 2, 1, 2, 3, 1, 2, 3], 1)\n2 // يظهر الرقم 2 مرتين بعد 1، بشكل أكثر تكرارًا من أي رقم آخر.\n>>> mostFrequentTargetAfterKey([1, 1, 1, 2, 2, 2, 1, 3, 3], 1)\n1 // يظهر الرقم 1 مرة واحدة بعد 1، وهو الأكثر تكرارًا.\n*/",
      "sw": "import Foundation\n\nfunc mostFrequentTargetAfterKey(_ nums: [Int], _ key: Int) -> Int {\n/**\nInapata nambari 'target' ambayo inaonekana mara nyingi mara moja baada ya 'key' maalum katika safu 'nums'.\n>>> mostFrequentTargetAfterKey([1, 2, 1, 2, 3, 1, 2, 3], 1)\n2 // Nambari 2 inaonekana mara mbili baada ya 1, mara nyingi zaidi kuliko nambari nyingine yoyote.\n>>> mostFrequentTargetAfterKey([1, 1, 1, 2, 2, 2, 1, 3, 3], 1)\n1 // Nambari 1 inaonekana mara moja baada ya 1, ambayo ndiyo mara nyingi zaidi.\n*/",
      "tr": "import Foundation\n\nfunc mostFrequentTargetAfterKey(_ nums: [Int], _ key: Int) -> Int {\n/**\nDizideki 'key'den hemen sonra en sık görünen 'target' tamsayısını bulur.\n>>> mostFrequentTargetAfterKey([1, 2, 1, 2, 3, 1, 2, 3], 1)\n2 // 2 sayısı 1'den sonra iki kez görünür, diğer sayılardan daha sık.\n>>> mostFrequentTargetAfterKey([1, 1, 1, 2, 2, 2, 1, 3, 3], 1)\n1 // 1 sayısı 1'den sonra bir kez görünür, bu en sık olanıdır.\n*/",
      "vi": "import Foundation\n\nfunc mostFrequentTargetAfterKey(_ nums: [Int], _ key: Int) -> Int {\n/**\nTìm số nguyên 'target' xuất hiện thường xuyên nhất ngay sau 'key' được chỉ định trong mảng 'nums'.\n>>> mostFrequentTargetAfterKey([1, 2, 1, 2, 3, 1, 2, 3], 1)\n2 // Số 2 xuất hiện hai lần sau 1, thường xuyên hơn bất kỳ số nào khác.\n>>> mostFrequentTargetAfterKey([1, 1, 1, 2, 2, 2, 1, 3, 3], 1)\n1 // Số 1 xuất hiện một lần sau 1, đây là số xuất hiện nhiều nhất.\n*/"
    },
    "prompt_bertscore": {
      "es": "0.9992896977574193",
      "arb": "0.9936166154446818",
      "sw": "0.9801804619499578",
      "tr": "0.9611212809985172",
      "vi": "0.9871466280432324"
    },
    "canonical_solution": "var frequencyMap = [Int: Int]()\nvar maxCount = 0\nvar mostFrequentTarget = nums[0]\n\nfor i in 0..<nums.count - 1 {\nif nums[i] == key {\nlet target = nums[i + 1]\nfrequencyMap[target, default: 0] += 1\nif frequencyMap[target]! > maxCount {\nmaxCount = frequencyMap[target]!\nmostFrequentTarget = target\n}\n}\n}\nreturn mostFrequentTarget\n}",
    "instruction": {
      "en": "func mostFrequentTargetAfterKey(_ nums: [Int], _ key: Int) -> Int {\nvar frequencyMap = [Int: Int]()\nvar maxCount = 0\nvar mostFrequentTarget = nums[0]\n\nfor i in 0..<nums.count - 1 {\nif nums[i] == key {\nlet target = nums[i + 1]\nfrequencyMap[target, default: 0] += 1\nif frequencyMap[target]! > maxCount {\nmaxCount = frequencyMap[target]!\nmostFrequentTarget = target\n}\n}\n}\nreturn mostFrequentTarget\n}\n\nProvide a concise natural language description (docstring) of the Swift code in English using at most 500 characters.",
      "es": "func mostFrequentTargetAfterKey(_ nums: [Int], _ key: Int) -> Int {\nvar frequencyMap = [Int: Int]()\nvar maxCount = 0\nvar mostFrequentTarget = nums[0]\n\nfor i in 0..<nums.count - 1 {\nif nums[i] == key {\nlet target = nums[i + 1]\nfrequencyMap[target, default: 0] += 1\nif frequencyMap[target]! > maxCount {\nmaxCount = frequencyMap[target]!\nmostFrequentTarget = target\n}\n}\n}\nreturn mostFrequentTarget\n}\n\nProporcione una descripción concisa en lenguaje natural (docstring) del código Swift en español utilizando un máximo de 500 caracteres.",
      "arb": "func mostFrequentTargetAfterKey(_ nums: [Int], _ key: Int) -> Int {\nvar frequencyMap = [Int: Int]()\nvar maxCount = 0\nvar mostFrequentTarget = nums[0]\n\nfor i in 0..<nums.count - 1 {\nif nums[i] == key {\nlet target = nums[i + 1]\nfrequencyMap[target, default: 0] += 1\nif frequencyMap[target]! > maxCount {\nmaxCount = frequencyMap[target]!\nmostFrequentTarget = target\n}\n}\n}\nreturn mostFrequentTarget\n}\n\nقدم وصفًا موجزًا بلغة طبيعية (docstring) لكود Swift باللغة العربية الفصحى باستخدام ما لا يزيد عن 500 حرف.",
      "sw": "func mostFrequentTargetAfterKey(_ nums: [Int], _ key: Int) -> Int {\nvar frequencyMap = [Int: Int]()\nvar maxCount = 0\nvar mostFrequentTarget = nums[0]\n\nfor i in 0..<nums.count - 1 {\nif nums[i] == key {\nlet target = nums[i + 1]\nfrequencyMap[target, default: 0] += 1\nif frequencyMap[target]! > maxCount {\nmaxCount = frequencyMap[target]!\nmostFrequentTarget = target\n}\n}\n}\nreturn mostFrequentTarget\n}\n\nToa maelezo mafupi ya lugha asilia (docstring) ya msimbo wa Swift kwa Kiswahili kwa kutumia herufi zisizozidi 500.",
      "tr": "func mostFrequentTargetAfterKey(_ nums: [Int], _ key: Int) -> Int {\nvar frequencyMap = [Int: Int]()\nvar maxCount = 0\nvar mostFrequentTarget = nums[0]\n\nfor i in 0..<nums.count - 1 {\nif nums[i] == key {\nlet target = nums[i + 1]\nfrequencyMap[target, default: 0] += 1\nif frequencyMap[target]! > maxCount {\nmaxCount = frequencyMap[target]!\nmostFrequentTarget = target\n}\n}\n}\nreturn mostFrequentTarget\n}\n\nSwift kodunun işlevini açıklayan kısa bir doğal dil açıklaması (docstring) sağlayın. Açıklama, Türkçe olarak en fazla 500 karakter kullanılarak yazılmalıdır.",
      "vi": "func mostFrequentTargetAfterKey(_ nums: [Int], _ key: Int) -> Int {\nvar frequencyMap = [Int: Int]()\nvar maxCount = 0\nvar mostFrequentTarget = nums[0]\n\nfor i in 0..<nums.count - 1 {\nif nums[i] == key {\nlet target = nums[i + 1]\nfrequencyMap[target, default: 0] += 1\nif frequencyMap[target]! > maxCount {\nmaxCount = frequencyMap[target]!\nmostFrequentTarget = target\n}\n}\n}\nreturn mostFrequentTarget\n}\n\nCung cấp mô tả ngắn gọn bằng ngôn ngữ tự nhiên (docstring) cho mã Swift bằng tiếng Việt với tối đa 500 ký tự."
    },
    "instruction_bertscore": {
      "es": "0.9676013985493994",
      "arb": "0.8880608556158835",
      "sw": "0.942496901951162",
      "tr": "0.8714851503185221",
      "vi": "0.8999953634299838"
    },
    "level": "",
    "test": "func checkMostFrequentTargetAfterKey(_ mostFrequentTargetAfterKey: ([Int], Int) -> Int) {\nassert(mostFrequentTargetAfterKey([1, 2, 1, 2, 3, 1, 2, 3], 1) == 2)\nassert(mostFrequentTargetAfterKey([1, 1, 1, 2, 2, 2, 1, 3, 3], 1) == 1)\nassert(mostFrequentTargetAfterKey([1, 2, 3, 1, 2, 3, 1, 2], 2) == 3)\nassert(mostFrequentTargetAfterKey([7, 7, 7, 8, 8, 9, 7, 9, 9], 7) == 7)\nassert(mostFrequentTargetAfterKey([1], 1) == 1)\nassert(mostFrequentTargetAfterKey([2, 2, 2, 2, 2, 3], 2) == 2)\n}\n\ncheckMostFrequentTargetAfterKey(mostFrequentTargetAfterKey)",
    "entry_point": "mostFrequentTargetAfterKey",
    "signature": "func mostFrequentTargetAfterKey(_ nums: [Int], _ key: Int) -> Int {",
    "docstring": {
      "en": "\nFinds the integer 'target' that most frequently appears immediately after the specified 'key' in the array 'nums'.\n>>> mostFrequentTargetAfterKey([1, 2, 1, 2, 3, 1, 2, 3], 1)\n2 // The number 2 appears twice after 1, more frequently than any other number.\n>>> mostFrequentTargetAfterKey([1, 1, 1, 2, 2, 2, 1, 3, 3], 1)\n1 // The number 1 appears once after 1, which is the most frequent.\n",
      "es": "Encuentra el entero 'target' que aparece con mayor frecuencia inmediatamente después del 'key' especificado en el array 'nums'.\n>>> mostFrequentTargetAfterKey([1, 2, 1, 2, 3, 1, 2, 3], 1)\n2 // El número 2 aparece dos veces después del 1, más frecuentemente que cualquier otro número.\n>>> mostFrequentTargetAfterKey([1, 1, 1, 2, 2, 2, 1, 3, 3], 1)\n1 // El número 1 aparece una vez después del 1, que es el más frecuente.",
      "arb": "يعثر على العدد الصحيح 'target' الذي يظهر بشكل متكرر مباشرة بعد 'key' المحدد في المصفوفة 'nums'.\n>>> mostFrequentTargetAfterKey([1, 2, 1, 2, 3, 1, 2, 3], 1)\n2 // يظهر الرقم 2 مرتين بعد 1، بشكل أكثر تكرارًا من أي رقم آخر.\n>>> mostFrequentTargetAfterKey([1, 1, 1, 2, 2, 2, 1, 3, 3], 1)\n1 // يظهر الرقم 1 مرة واحدة بعد 1، وهو الأكثر تكرارًا.",
      "sw": "Inapata nambari kamili 'target' inayojitokeza mara nyingi zaidi mara baada ya 'key' maalum katika safu 'nums'.\n>>> mostFrequentTargetAfterKey([1, 2, 1, 2, 3, 1, 2, 3], 1)\n2 // Nambari 2 inaonekana mara mbili baada ya 1, mara nyingi zaidi kuliko nambari nyingine yoyote.\n>>> mostFrequentTargetAfterKey([1, 1, 1, 2, 2, 2, 1, 3, 3], 1)\n1 // Nambari 1 inaonekana mara moja baada ya 1, ambayo ndiyo mara nyingi zaidi.",
      "tr": "Belirtilen 'key' değerinden hemen sonra dizide en sık görünen tamsayı 'target'ı bulur.\n>>> mostFrequentTargetAfterKey([1, 2, 1, 2, 3, 1, 2, 3], 1)\n2 // 2 sayısı, 1'den sonra iki kez görünür, diğer sayılardan daha sık.\n>>> mostFrequentTargetAfterKey([1, 1, 1, 2, 2, 2, 1, 3, 3], 1)\n1 // 1 sayısı, 1'den sonra bir kez görünür ve bu en sık olanıdır.",
      "vi": "Tìm số nguyên 'target' xuất hiện thường xuyên nhất ngay sau 'key' được chỉ định trong mảng 'nums'.\n>>> mostFrequentTargetAfterKey([1, 2, 1, 2, 3, 1, 2, 3], 1)\n2 // Số 2 xuất hiện hai lần sau 1, thường xuyên hơn bất kỳ số nào khác.\n>>> mostFrequentTargetAfterKey([1, 1, 1, 2, 2, 2, 1, 3, 3], 1)\n1 // Số 1 xuất hiện một lần sau 1, đây là số xuất hiện thường xuyên nhất."
    },
    "docstring_bertscore": {
      "es": "0.9920345244597389",
      "arb": "0.9978001685300386",
      "sw": "0.9929136625261993",
      "tr": "0.9457457004633686",
      "vi": "0.9796987832759482"
    }
  },
  {
    "task_id": "Swift/13",
    "prompt": {
      "en": "import Foundation\n\nfunc kCloseNeighbors(_ nums: [Int], _ key: Int, _ k: Int) -> [Int] {\n/**\nReturns a sorted list of all K close neighbor indices in the array 'nums'.\nA K close neighbor index i satisfies at least one index j such that |i - j| <= k and nums[j] == key.\n>>> kCloseNeighbors([1, 2, 3, 2, 4, 2, 5], 2, 2)\n[0, 1, 2, 3, 4, 5, 6] // Each index is within 2 steps of a '2'.\n>>> kCloseNeighbors([1, 2, 3, 4, 5], 3, 1)\n[1, 2, 3] // Indices 1, 2, 3 are within 1 step of a '3'.\n*/",
      "es": "import Foundation\n\nfunc kCloseNeighbors(_ nums: [Int], _ key: Int, _ k: Int) -> [Int] {\n/**\nDevuelve una lista ordenada de todos los índices de vecinos cercanos K en el array 'nums'.\nUn índice i de vecino cercano K satisface al menos un índice j tal que |i - j| <= k y nums[j] == key.\n>>> kCloseNeighbors([1, 2, 3, 2, 4, 2, 5], 2, 2)\n[0, 1, 2, 3, 4, 5, 6] // Cada índice está a 2 pasos de un '2'.\n>>> kCloseNeighbors([1, 2, 3, 4, 5], 3, 1)\n[1, 2, 3] // Los índices 1, 2, 3 están a 1 paso de un '3'.\n*/",
      "arb": "import Foundation\n\nfunc kCloseNeighbors(_ nums: [Int], _ key: Int, _ k: Int) -> [Int] {\n/**\nتعيد قائمة مرتبة لجميع مؤشرات الجيران القريبة K في المصفوفة 'nums'.\nمؤشر الجار القريب K i يحقق على الأقل مؤشر واحد j بحيث |i - j| <= k و nums[j] == key.\n>>> kCloseNeighbors([1, 2, 3, 2, 4, 2, 5], 2, 2)\n[0, 1, 2, 3, 4, 5, 6] // كل مؤشر يقع ضمن خطوتين من '2'.\n>>> kCloseNeighbors([1, 2, 3, 4, 5], 3, 1)\n[1, 2, 3] // المؤشرات 1، 2، 3 تقع ضمن خطوة واحدة من '3'.\n*/",
      "sw": "import Foundation\n\nfunc kCloseNeighbors(_ nums: [Int], _ key: Int, _ k: Int) -> [Int] {\n/**\nInarudisha orodha iliyopangwa ya faharasa zote za majirani wa karibu K katika safu 'nums'.\nFaharasa ya jirani wa karibu K i inakidhi angalau faharasa moja j kama |i - j| <= k na nums[j] == key.\n>>> kCloseNeighbors([1, 2, 3, 2, 4, 2, 5], 2, 2)\n[0, 1, 2, 3, 4, 5, 6] // Kila faharasa iko ndani ya hatua 2 za '2'.\n>>> kCloseNeighbors([1, 2, 3, 4, 5], 3, 1)\n[1, 2, 3] // Faharasa 1, 2, 3 ziko ndani ya hatua 1 ya '3'.\n*/",
      "tr": "import Foundation\n\nfunc kCloseNeighbors(_ nums: [Int], _ key: Int, _ k: Int) -> [Int] {\n/**\nDizideki tüm K yakın komşu indekslerinin sıralı bir listesini döndürür.\nBir K yakın komşu indeksi i, |i - j| <= k ve nums[j] == key olan en az bir j indeksi sağlar.\n>>> kCloseNeighbors([1, 2, 3, 2, 4, 2, 5], 2, 2)\n[0, 1, 2, 3, 4, 5, 6] // Her bir indeks '2'ye 2 adım mesafededir.\n>>> kCloseNeighbors([1, 2, 3, 4, 5], 3, 1)\n[1, 2, 3] // İndeksler 1, 2, 3 '3'e 1 adım mesafededir.\n*/",
      "vi": "import Foundation\n\nfunc kCloseNeighbors(_ nums: [Int], _ key: Int, _ k: Int) -> [Int] {\n/**\nTrả về danh sách đã sắp xếp của tất cả các chỉ số hàng xóm gần K trong mảng 'nums'.\nMột chỉ số hàng xóm gần K i thỏa mãn ít nhất một chỉ số j sao cho |i - j| <= k và nums[j] == key.\n>>> kCloseNeighbors([1, 2, 3, 2, 4, 2, 5], 2, 2)\n[0, 1, 2, 3, 4, 5, 6] // Mỗi chỉ số nằm trong 2 bước của một '2'.\n>>> kCloseNeighbors([1, 2, 3, 4, 5], 3, 1)\n[1, 2, 3] // Các chỉ số 1, 2, 3 nằm trong 1 bước của một '3'.\n*/"
    },
    "prompt_bertscore": {
      "es": "0.9857373454897899",
      "arb": "0.9740662215609419",
      "sw": "0.976588827400085",
      "tr": "0.9538980871921835",
      "vi": "0.9630487902160797"
    },
    "canonical_solution": "var neighbors = Set<Int>()\n\nfor (i, num) in nums.enumerated() {\nif num == key {\nlet lowerBound = max(0, i - k)\nlet upperBound = min(nums.count - 1, i + k)\nfor j in lowerBound...upperBound {\nneighbors.insert(j)\n}\n}\n}\n\nreturn neighbors.sorted()\n}",
    "instruction": {
      "en": "func kCloseNeighbors(_ nums: [Int], _ key: Int, _ k: Int) -> [Int] {\nvar neighbors = Set<Int>()\n\nfor (i, num) in nums.enumerated() {\nif num == key {\nlet lowerBound = max(0, i - k)\nlet upperBound = min(nums.count - 1, i + k)\nfor j in lowerBound...upperBound {\nneighbors.insert(j)\n}\n}\n}\n\nreturn neighbors.sorted()\n}\n\nProvide a concise natural language description (docstring) of the Swift code in English using at most 500 characters.",
      "es": "func kCloseNeighbors(_ nums: [Int], _ key: Int, _ k: Int) -> [Int] {\nvar neighbors = Set<Int>()\n\nfor (i, num) in nums.enumerated() {\nif num == key {\nlet lowerBound = max(0, i - k)\nlet upperBound = min(nums.count - 1, i + k)\nfor j in lowerBound...upperBound {\nneighbors.insert(j)\n}\n}\n}\n\nreturn neighbors.sorted()\n}\n\nProporcione una descripción concisa en lenguaje natural (docstring) del código Swift en español utilizando como máximo 500 caracteres.",
      "arb": "func kCloseNeighbors(_ nums: [Int], _ key: Int, _ k: Int) -> [Int] {\nvar neighbors = Set<Int>()\n\nfor (i, num) in nums.enumerated() {\nif num == key {\nlet lowerBound = max(0, i - k)\nlet upperBound = min(nums.count - 1, i + k)\nfor j in lowerBound...upperBound {\nneighbors.insert(j)\n}\n}\n}\n\nreturn neighbors.sorted()\n}\n\nقدم وصفًا موجزًا بلغة طبيعية (docstring) لكود Swift باللغة العربية الفصحى باستخدام 500 حرف كحد أقصى.",
      "sw": "func kCloseNeighbors(_ nums: [Int], _ key: Int, _ k: Int) -> [Int] {\nvar neighbors = Set<Int>()\n\nfor (i, num) in nums.enumerated() {\nif num == key {\nlet lowerBound = max(0, i - k)\nlet upperBound = min(nums.count - 1, i + k)\nfor j in lowerBound...upperBound {\nneighbors.insert(j)\n}\n}\n}\n\nreturn neighbors.sorted()\n}\n\nToa maelezo mafupi ya lugha ya asili (docstring) ya msimbo wa Swift kwa Kiswahili kwa kutumia herufi zisizozidi 500.",
      "tr": "func kCloseNeighbors(_ nums: [Int], _ key: Int, _ k: Int) -> [Int] {\nvar neighbors = Set<Int>()\n\nfor (i, num) in nums.enumerated() {\nif num == key {\nlet lowerBound = max(0, i - k)\nlet upperBound = min(nums.count - 1, i + k)\nfor j in lowerBound...upperBound {\nneighbors.insert(j)\n}\n}\n}\n\nreturn neighbors.sorted()\n}\n\nSwift kodunun işlevini açıklayan kısa bir doğal dil açıklaması (docstring) sağlayın. Açıklama, en fazla 500 karakter kullanılarak Türkçe olarak yazılmalıdır.",
      "vi": "func kCloseNeighbors(_ nums: [Int], _ key: Int, _ k: Int) -> [Int] {\nvar neighbors = Set<Int>()\n\nfor (i, num) in nums.enumerated() {\nif num == key {\nlet lowerBound = max(0, i - k)\nlet upperBound = min(nums.count - 1, i + k)\nfor j in lowerBound...upperBound {\nneighbors.insert(j)\n}\n}\n}\n\nreturn neighbors.sorted()\n}\n\nCung cấp mô tả ngắn gọn bằng ngôn ngữ tự nhiên (docstring) cho mã Swift bằng tiếng Việt, sử dụng tối đa 500 ký tự."
    },
    "instruction_bertscore": {
      "es": "0.9676013985493994",
      "arb": "0.8879933212863317",
      "sw": "0.942496901951162",
      "tr": "0.8816689299541809",
      "vi": "0.9054771646857847"
    },
    "level": "",
    "test": "func checkKCloseNeighbors(_ kCloseNeighbors: ([Int], Int, Int) -> [Int]) {\nassert(kCloseNeighbors([1, 2, 3, 2, 4, 2, 5], 2, 2) == [0, 1, 2, 3, 4, 5, 6])\nassert(kCloseNeighbors([1, 2, 3, 4, 5], 3, 1) == [1, 2, 3])\nassert(kCloseNeighbors([1, 1, 1, 1, 1], 1, 0) == [0, 1, 2, 3, 4])\nassert(kCloseNeighbors([5, 4, 3, 2, 1], 3, 2) == [0,1, 2, 3, 4])\nassert(kCloseNeighbors([7, 7, 7, 7, 7], 7, 3) == [0, 1, 2, 3, 4])\nassert(kCloseNeighbors([], 1, 1) == [])\nassert(kCloseNeighbors([1, 2, 3, 4, 5, 6], 4, 1) == [2, 3, 4])\n}\n\ncheckKCloseNeighbors(kCloseNeighbors)",
    "entry_point": "kCloseNeighbors",
    "signature": "func kCloseNeighbors(_ nums: [Int], _ key: Int, _ k: Int) -> [Int] {",
    "docstring": {
      "en": "\nReturns a sorted list of all K close neighbor indices in the array 'nums'.\nA K close neighbor index i satisfies at least one index j such that |i - j| <= k and nums[j] == key.\n>>> kCloseNeighbors([1, 2, 3, 2, 4, 2, 5], 2, 2)\n[0, 1, 2, 3, 4, 5, 6] // Each index is within 2 steps of a '2'.\n>>> kCloseNeighbors([1, 2, 3, 4, 5], 3, 1)\n[1, 2, 3] // Indices 1, 2, 3 are within 1 step of a '3'.\n",
      "es": "Devuelve una lista ordenada de todos los índices de vecinos cercanos K en el array 'nums'.  \nUn índice i de vecino cercano K satisface al menos un índice j tal que |i - j| <= k y nums[j] == key.  \n>>> kCloseNeighbors([1, 2, 3, 2, 4, 2, 5], 2, 2)  \n[0, 1, 2, 3, 4, 5, 6] // Cada índice está a 2 pasos de un '2'.  \n>>> kCloseNeighbors([1, 2, 3, 4, 5], 3, 1)  \n[1, 2, 3] // Los índices 1, 2, 3 están a 1 paso de un '3'.  ",
      "arb": "يعيد قائمة مرتبة لجميع مؤشرات الجيران القريبة K في المصفوفة 'nums'. \nمؤشر الجار القريب K i يحقق على الأقل مؤشر واحد j بحيث أن |i - j| <= k و nums[j] == key.\n>>> kCloseNeighbors([1, 2, 3, 2, 4, 2, 5], 2, 2)\n[0, 1, 2, 3, 4, 5, 6] // كل مؤشر يكون ضمن خطوتين من '2'.\n>>> kCloseNeighbors([1, 2, 3, 4, 5], 3, 1)\n[1, 2, 3] // المؤشرات 1، 2، 3 تكون ضمن خطوة واحدة من '3'.",
      "sw": "Inarudisha orodha iliyopangwa ya faharasa zote za majirani wa karibu K katika safu 'nums'.\nFaharasa ya jirani wa karibu K i inakidhi angalau faharasa moja j kama |i - j| <= k na nums[j] == key.\n>>> kCloseNeighbors([1, 2, 3, 2, 4, 2, 5], 2, 2)\n[0, 1, 2, 3, 4, 5, 6] // Kila faharasa iko ndani ya hatua 2 za '2'.\n>>> kCloseNeighbors([1, 2, 3, 4, 5], 3, 1)\n[1, 2, 3] // Faharasa 1, 2, 3 ziko ndani ya hatua 1 ya '3'.",
      "tr": "'nums' dizisindeki tüm K yakın komşu indislerinin sıralı bir listesini döndürür. Bir K yakın komşu indisi i, |i - j| <= k ve nums[j] == key olacak şekilde en az bir j indisini sağlar.\n>>> kCloseNeighbors([1, 2, 3, 2, 4, 2, 5], 2, 2)\n[0, 1, 2, 3, 4, 5, 6] // Her bir indis bir '2'ye 2 adım mesafededir.\n>>> kCloseNeighbors([1, 2, 3, 4, 5], 3, 1)\n[1, 2, 3] // İndisler 1, 2, 3 bir '3'e 1 adım mesafededir.",
      "vi": "Trả về một danh sách đã sắp xếp của tất cả các chỉ số lân cận K gần trong mảng 'nums'.\nMột chỉ số lân cận K gần i thỏa mãn ít nhất một chỉ số j sao cho |i - j| <= k và nums[j] == key.\n>>> kCloseNeighbors([1, 2, 3, 2, 4, 2, 5], 2, 2)\n[0, 1, 2, 3, 4, 5, 6] // Mỗi chỉ số nằm trong 2 bước của một '2'.\n>>> kCloseNeighbors([1, 2, 3, 4, 5], 3, 1)\n[1, 2, 3] // Các chỉ số 1, 2, 3 nằm trong 1 bước của một '3'."
    },
    "docstring_bertscore": {
      "es": "0.990326899073982",
      "arb": "0.9568568853480792",
      "sw": "0.9561811447917985",
      "tr": "0.9845946249076961",
      "vi": "0.9724295072212145"
    }
  },
  {
    "task_id": "Swift/14",
    "prompt": {
      "en": "import Foundation\n\nfunc canFormPairs(_ nums: [Int]) -> Bool {\n/**\nDetermines whether the array 'nums' can be divided into pairs such that each pair consists of equal elements.\nEach element must belong to exactly one pair.\n>>> canFormPairs([1, 2, 2, 1])\nTrue // Can be divided into pairs (1,1) and (2,2).\n>>> canFormPairs([1, 2, 3, 4, 5, 6])\nFalse // Cannot form pairs with equal elements.\n*/",
      "es": "import Foundation\n\nfunc canFormPairs(_ nums: [Int]) -> Bool {\n/**\nDetermina si el arreglo 'nums' se puede dividir en pares de manera que cada par consista en elementos iguales.\nCada elemento debe pertenecer exactamente a un par.\n>>> canFormPairs([1, 2, 2, 1])\nTrue // Se puede dividir en pares (1,1) y (2,2).\n>>> canFormPairs([1, 2, 3, 4, 5, 6])\nFalse // No se pueden formar pares con elementos iguales.\n*/",
      "arb": "import Foundation\n\nfunc canFormPairs(_ nums: [Int]) -> Bool {\n/**\nيحدد ما إذا كان يمكن تقسيم المصفوفة 'nums' إلى أزواج بحيث يتكون كل زوج من عناصر متساوية.\nيجب أن ينتمي كل عنصر إلى زوج واحد فقط.\n>>> canFormPairs([1, 2, 2, 1])\nTrue // يمكن تقسيمها إلى أزواج (1,1) و (2,2).\n>>> canFormPairs([1, 2, 3, 4, 5, 6])\nFalse // لا يمكن تشكيل أزواج بعناصر متساوية.\n*/",
      "sw": "import Foundation\n\nfunc canFormPairs(_ nums: [Int]) -> Bool {\n/**\nInabainisha kama safu 'nums' inaweza kugawanywa katika jozi ambapo kila jozi inajumuisha vipengele vilivyo sawa.\nKila kipengele lazima kiwe katika jozi moja tu.\n>>> canFormPairs([1, 2, 2, 1])\nTrue // Inaweza kugawanywa katika jozi (1,1) na (2,2).\n>>> canFormPairs([1, 2, 3, 4, 5, 6])\nFalse // Haiwezi kuunda jozi zenye vipengele vilivyo sawa.\n*/",
      "tr": "import Foundation\n\nfunc canFormPairs(_ nums: [Int]) -> Bool {\n/**\nDizinin 'nums' içindeki elemanların eşit elemanlardan oluşan çiftlere bölünüp bölünemeyeceğini belirler.\nHer eleman tam olarak bir çifte ait olmalıdır.\n>>> canFormPairs([1, 2, 2, 1])\nTrue // (1,1) ve (2,2) çiftlerine bölünebilir.\n>>> canFormPairs([1, 2, 3, 4, 5, 6])\nFalse // Eşit elemanlarla çiftler oluşturulamaz.\n*/",
      "vi": "import Foundation\n\nfunc canFormPairs(_ nums: [Int]) -> Bool {\n/**\nXác định xem mảng 'nums' có thể được chia thành các cặp sao cho mỗi cặp bao gồm các phần tử bằng nhau hay không.\nMỗi phần tử phải thuộc về chính xác một cặp.\n>>> canFormPairs([1, 2, 2, 1])\nTrue // Có thể chia thành các cặp (1,1) và (2,2).\n>>> canFormPairs([1, 2, 3, 4, 5, 6])\nFalse // Không thể tạo thành các cặp với các phần tử bằng nhau.\n*/"
    },
    "prompt_bertscore": {
      "es": "0.9992130264303398",
      "arb": "1",
      "sw": "0.9810915795077648",
      "tr": "0.9749825035086558",
      "vi": "0.9932062450774637"
    },
    "canonical_solution": "var countMap = [Int: Int]()\n\nfor num in nums {\ncountMap[num, default: 0] += 1\n}\n\nfor (_, count) in countMap {\nif count % 2 != 0 {\nreturn false\n}\n}\n\nreturn true\n}",
    "instruction": {
      "en": "func canFormPairs(_ nums: [Int]) -> Bool {\nvar countMap = [Int: Int]()\n\nfor num in nums {\ncountMap[num, default: 0] += 1\n}\n\nfor (_, count) in countMap {\nif count % 2 != 0 {\nreturn false\n}\n}\n\nreturn true\n}\n\nProvide a concise natural language description (docstring) of the Swift code in English using at most 500 characters.",
      "es": "func canFormPairs(_ nums: [Int]) -> Bool {\nvar countMap = [Int: Int]()\n\nfor num in nums {\ncountMap[num, default: 0] += 1\n}\n\nfor (_, count) in countMap {\nif count % 2 != 0 {\nreturn false\n}\n}\n\nreturn true\n}\n\nProporcione una descripción concisa en lenguaje natural (docstring) del código Swift en español utilizando un máximo de 500 caracteres.",
      "arb": "func canFormPairs(_ nums: [Int]) -> Bool {\nvar countMap = [Int: Int]()\n\nfor num in nums {\ncountMap[num, default: 0] += 1\n}\n\nfor (_, count) in countMap {\nif count % 2 != 0 {\nreturn false\n}\n}\n\nreturn true\n}\n\nقدم وصفًا موجزًا بلغة طبيعية (docstring) لكود Swift باللغة العربية الفصحى باستخدام 500 حرف كحد أقصى.",
      "sw": "func canFormPairs(_ nums: [Int]) -> Bool {\nvar countMap = [Int: Int]()\n\nfor num in nums {\ncountMap[num, default: 0] += 1\n}\n\nfor (_, count) in countMap {\nif count % 2 != 0 {\nreturn false\n}\n}\n\nreturn true\n}\n\nToa maelezo mafupi ya lugha ya asili (docstring) ya msimbo wa Swift kwa Kiswahili kwa kutumia herufi zisizozidi 500.",
      "tr": "func canFormPairs(_ nums: [Int]) -> Bool {\nvar countMap = [Int: Int]()\n\nfor num in nums {\ncountMap[num, default: 0] += 1\n}\n\nfor (_, count) in countMap {\nif count % 2 != 0 {\nreturn false\n}\n}\n\nreturn true\n}\n\nSwift kodunun işlevselliğini açıklayan en fazla 500 karakterlik özlü bir doğal dil tanımı (docstring) sağlayın.",
      "vi": "func canFormPairs(_ nums: [Int]) -> Bool {\nvar countMap = [Int: Int]()\n\nfor num in nums {\ncountMap[num, default: 0] += 1\n}\n\nfor (_, count) in countMap {\nif count % 2 != 0 {\nreturn false\n}\n}\n\nreturn true\n}\n\nCung cấp mô tả ngắn gọn bằng ngôn ngữ tự nhiên (docstring) cho mã Swift bằng tiếng Việt với tối đa 500 ký tự."
    },
    "instruction_bertscore": {
      "es": "0.9676013985493994",
      "arb": "0.9144786962935237",
      "sw": "0.9096853479383898",
      "tr": "0.8847687556806113",
      "vi": "0.9219021095239406"
    },
    "level": "",
    "test": "func checkCanFormPairs(_ canFormPairs: ([Int]) -> Bool) {\nassert(canFormPairs([1, 2, 2, 1]) == true)\nassert(canFormPairs([1, 2, 3, 4, 5, 6]) == false)\nassert(canFormPairs([3, 3, 3, 3, 3, 3]) == true)\nassert(canFormPairs([0, 0]) == true)\nassert(canFormPairs([1, 1, 2, 2, 2, 2, 3, 3]) == true)\nassert(canFormPairs([1, 2, 3, 4, 4, 3, 2, 1, 5]) == false)\nassert(canFormPairs([]) == true)\n}\n\ncheckCanFormPairs(canFormPairs)",
    "entry_point": "canFormPairs",
    "signature": "func canFormPairs(_ nums: [Int]) -> Bool {",
    "docstring": {
      "en": "\nDetermines whether the array 'nums' can be divided into pairs such that each pair consists of equal elements.\nEach element must belong to exactly one pair.\n>>> canFormPairs([1, 2, 2, 1])\nTrue // Can be divided into pairs (1,1) and (2,2).\n>>> canFormPairs([1, 2, 3, 4, 5, 6])\nFalse // Cannot form pairs with equal elements.\n",
      "es": "Determina si el array 'nums' se puede dividir en pares de manera que cada par consista en elementos iguales.  \nCada elemento debe pertenecer a exactamente un par.  \n>>> canFormPairs([1, 2, 2, 1])  \nTrue // Se puede dividir en pares (1,1) y (2,2).  \n>>> canFormPairs([1, 2, 3, 4, 5, 6])  \nFalse // No se pueden formar pares con elementos iguales.  ",
      "arb": "يحدد ما إذا كان يمكن تقسيم المصفوفة 'nums' إلى أزواج بحيث يتكون كل زوج من عناصر متساوية.\nيجب أن ينتمي كل عنصر إلى زوج واحد فقط.\n>>> canFormPairs([1, 2, 2, 1])\nTrue // يمكن تقسيمها إلى أزواج (1,1) و (2,2).\n>>> canFormPairs([1, 2, 3, 4, 5, 6])\nFalse // لا يمكن تشكيل أزواج بعناصر متساوية.",
      "sw": "Inabainisha kama safu 'nums' inaweza kugawanywa katika jozi ambapo kila jozi inajumuisha vipengele sawa. \nKila kipengele lazima kiwe katika jozi moja tu. \n>>> canFormPairs([1, 2, 2, 1])\nTrue // Inaweza kugawanywa katika jozi (1,1) na (2,2).\n>>> canFormPairs([1, 2, 3, 4, 5, 6])\nFalse // Haiwezi kuunda jozi na vipengele sawa.",
      "tr": "Dizinin 'nums', her biri eşit elemanlardan oluşan çiftlere bölünüp bölünemeyeceğini belirler.\nHer eleman tam olarak bir çifte ait olmalıdır.\n>>> canFormPairs([1, 2, 2, 1])\nTrue // Çiftlere (1,1) ve (2,2) olarak bölünebilir.\n>>> canFormPairs([1, 2, 3, 4, 5, 6])\nFalse // Eşit elemanlarla çiftler oluşturulamaz.",
      "vi": "Xác định xem mảng 'nums' có thể được chia thành các cặp sao cho mỗi cặp bao gồm các phần tử bằng nhau hay không.  \nMỗi phần tử phải thuộc về chính xác một cặp.  \n>>> canFormPairs([1, 2, 2, 1])  \nTrue // Có thể được chia thành các cặp (1,1) và (2,2).  \n>>> canFormPairs([1, 2, 3, 4, 5, 6])  \nFalse // Không thể tạo cặp với các phần tử bằng nhau.  "
    },
    "docstring_bertscore": {
      "es": "0.9885519379890543",
      "arb": "0.9830782805788758",
      "sw": "0.9844980905425131",
      "tr": "0.9626449746514358",
      "vi": "0.9893375211460472"
    }
  },
  {
    "task_id": "Swift/15",
    "prompt": {
      "en": "import Foundation\n\nfunc findUniqueElements(nums1: [Int], nums2: [Int]) -> [[Int]] {\n/**\nReturns two lists: one with unique integers in 'nums1' not in 'nums2', and another with unique integers in 'nums2' not in 'nums1'.\nThe integers in each list are returned in ascending order.\n>>> findUniqueElements(nums1: [1, 2, 3], nums2: [2, 3, 4])\n[[1], [4]] // 1 is unique to nums1, 4 is unique to nums2.\n>>> findUniqueElements(nums1: [1, 1, 2, 3], nums2: [3, 4, 4, 5])\n[[1, 2], [4, 5]] // 1, 2 are unique to nums1; 4, 5 are unique to nums2.\n*/",
      "es": "import Foundation\n\nfunc findUniqueElements(nums1: [Int], nums2: [Int]) -> [[Int]] {\n/**\nDevuelve dos listas: una con enteros únicos en 'nums1' que no están en 'nums2', y otra con enteros únicos en 'nums2' que no están en 'nums1'.\nLos enteros en cada lista se devuelven en orden ascendente.\n>>> findUniqueElements(nums1: [1, 2, 3], nums2: [2, 3, 4])\n[[1], [4]] // 1 es único en nums1, 4 es único en nums2.\n>>> findUniqueElements(nums1: [1, 1, 2, 3], nums2: [3, 4, 4, 5])\n[[1, 2], [4, 5]] // 1, 2 son únicos en nums1; 4, 5 son únicos en nums2.\n*/",
      "arb": "import Foundation\n\nfunc findUniqueElements(nums1: [Int], nums2: [Int]) -> [[Int]] {\n/**\nيعيد قائمتين: واحدة تحتوي على الأعداد الصحيحة الفريدة في 'nums1' غير الموجودة في 'nums2'، وأخرى تحتوي على الأعداد الصحيحة الفريدة في 'nums2' غير الموجودة في 'nums1'.\nيتم إرجاع الأعداد الصحيحة في كل قائمة بترتيب تصاعدي.\n>>> findUniqueElements(nums1: [1, 2, 3], nums2: [2, 3, 4])\n[[1], [4]] // 1 فريدة لـ nums1، 4 فريدة لـ nums2.\n>>> findUniqueElements(nums1: [1, 1, 2, 3], nums2: [3, 4, 4, 5])\n[[1, 2], [4, 5]] // 1، 2 فريدة لـ nums1؛ 4، 5 فريدة لـ nums2.\n*/",
      "sw": "import Foundation\n\nfunc findUniqueElements(nums1: [Int], nums2: [Int]) -> [[Int]] {\n/**\nInarudisha orodha mbili: moja yenye namba za kipekee katika 'nums1' ambazo hazipo katika 'nums2', na nyingine yenye namba za kipekee katika 'nums2' ambazo hazipo katika 'nums1'.\nNamba katika kila orodha zinarudishwa katika mpangilio wa kupanda.\n>>> findUniqueElements(nums1: [1, 2, 3], nums2: [2, 3, 4])\n[[1], [4]] // 1 ni ya kipekee kwa nums1, 4 ni ya kipekee kwa nums2.\n>>> findUniqueElements(nums1: [1, 1, 2, 3], nums2: [3, 4, 4, 5])\n[[1, 2], [4, 5]] // 1, 2 ni za kipekee kwa nums1; 4, 5 ni za kipekee kwa nums2.\n*/",
      "tr": "import Foundation\n\nfunc findUniqueElements(nums1: [Int], nums2: [Int]) -> [[Int]] {\n/**\n'nums1' içinde olup 'nums2' içinde olmayan benzersiz tamsayılarla bir liste ve 'nums2' içinde olup 'nums1' içinde olmayan benzersiz tamsayılarla başka bir liste döndürür.\nHer listedeki tamsayılar artan sırayla döndürülür.\n>>> findUniqueElements(nums1: [1, 2, 3], nums2: [2, 3, 4])\n[[1], [4]] // 1 nums1'e özgüdür, 4 nums2'ye özgüdür.\n>>> findUniqueElements(nums1: [1, 1, 2, 3], nums2: [3, 4, 4, 5])\n[[1, 2], [4, 5]] // 1, 2 nums1'e özgüdür; 4, 5 nums2'ye özgüdür.\n*/",
      "vi": "import Foundation\n\nfunc findUniqueElements(nums1: [Int], nums2: [Int]) -> [[Int]] {\n/**\nTrả về hai danh sách: một danh sách với các số nguyên duy nhất trong 'nums1' không có trong 'nums2', và một danh sách khác với các số nguyên duy nhất trong 'nums2' không có trong 'nums1'.\nCác số nguyên trong mỗi danh sách được trả về theo thứ tự tăng dần.\n>>> findUniqueElements(nums1: [1, 2, 3], nums2: [2, 3, 4])\n[[1], [4]] // 1 là duy nhất trong nums1, 4 là duy nhất trong nums2.\n>>> findUniqueElements(nums1: [1, 1, 2, 3], nums2: [3, 4, 4, 5])\n[[1, 2], [4, 5]] // 1, 2 là duy nhất trong nums1; 4, 5 là duy nhất trong nums2.\n*/"
    },
    "prompt_bertscore": {
      "es": "0.9777792192736271",
      "arb": "0.9789100220328587",
      "sw": "0.9771555198771775",
      "tr": "0.9708041148132059",
      "vi": "0.976492293034902"
    },
    "canonical_solution": "let set1 = Set(nums1)\nlet set2 = Set(nums2)\n\nlet uniqueToNums1 = Array(set1.subtracting(set2)).sorted()\nlet uniqueToNums2 = Array(set2.subtracting(set1)).sorted()\n\nreturn [uniqueToNums1, uniqueToNums2]\n}",
    "instruction": {
      "en": "func findUniqueElements(nums1: [Int], nums2: [Int]) -> [[Int]] {\nlet set1 = Set(nums1)\nlet set2 = Set(nums2)\n\nlet uniqueToNums1 = Array(set1.subtracting(set2)).sorted()\nlet uniqueToNums2 = Array(set2.subtracting(set1)).sorted()\n\nreturn [uniqueToNums1, uniqueToNums2]\n}\n\nProvide a concise natural language description (docstring) of the Swift code in English using at most 500 characters.",
      "es": "func findUniqueElements(nums1: [Int], nums2: [Int]) -> [[Int]] {\nlet set1 = Set(nums1)\nlet set2 = Set(nums2)\n\nlet uniqueToNums1 = Array(set1.subtracting(set2)).sorted()\nlet uniqueToNums2 = Array(set2.subtracting(set1)).sorted()\n\nreturn [uniqueToNums1, uniqueToNums2]\n}\n\nProporcione una descripción concisa en lenguaje natural (docstring) del código Swift en español utilizando como máximo 500 caracteres.",
      "arb": "func findUniqueElements(nums1: [Int], nums2: [Int]) -> [[Int]] {\nlet set1 = Set(nums1)\nlet set2 = Set(nums2)\n\nlet uniqueToNums1 = Array(set1.subtracting(set2)).sorted()\nlet uniqueToNums2 = Array(set2.subtracting(set1)).sorted()\n\nreturn [uniqueToNums1, uniqueToNums2]\n}\n\nتقديم وصف موجز بلغة طبيعية (docstring) للكود المكتوب بلغة Swift باللغة العربية الفصحى باستخدام ما لا يزيد عن 500 حرف.",
      "sw": "func findUniqueElements(nums1: [Int], nums2: [Int]) -> [[Int]] {\nlet set1 = Set(nums1)\nlet set2 = Set(nums2)\n\nlet uniqueToNums1 = Array(set1.subtracting(set2)).sorted()\nlet uniqueToNums2 = Array(set2.subtracting(set1)).sorted()\n\nreturn [uniqueToNums1, uniqueToNums2]\n}\n\nToa maelezo mafupi ya lugha ya asili (docstring) ya msimbo wa Swift kwa Kiswahili kwa kutumia herufi zisizozidi 500.",
      "tr": "func findUniqueElements(nums1: [Int], nums2: [Int]) -> [[Int]] {\nlet set1 = Set(nums1)\nlet set2 = Set(nums2)\n\nlet uniqueToNums1 = Array(set1.subtracting(set2)).sorted()\nlet uniqueToNums2 = Array(set2.subtracting(set1)).sorted()\n\nreturn [uniqueToNums1, uniqueToNums2]\n}\n\nSwift kodunun işlevini açıklayan kısa bir doğal dil açıklaması (docstring) sağlayın. Açıklama Türkçe olmalı ve en fazla 500 karakter kullanılmalıdır.",
      "vi": "func findUniqueElements(nums1: [Int], nums2: [Int]) -> [[Int]] {\nlet set1 = Set(nums1)\nlet set2 = Set(nums2)\n\nlet uniqueToNums1 = Array(set1.subtracting(set2)).sorted()\nlet uniqueToNums2 = Array(set2.subtracting(set1)).sorted()\n\nreturn [uniqueToNums1, uniqueToNums2]\n}\n\nCung cấp mô tả ngắn gọn bằng ngôn ngữ tự nhiên (docstring) cho mã Swift bằng tiếng Việt, sử dụng tối đa 500 ký tự."
    },
    "instruction_bertscore": {
      "es": "0.9676013985493994",
      "arb": "0.8916564627733772",
      "sw": "0.9148419912604365",
      "tr": "0.8653939510537063",
      "vi": "0.9054771646857847"
    },
    "level": "",
    "test": "func checkFindUniqueElements(_ findUniqueElements: ([Int], [Int]) -> [[Int]]) {\nassert(findUniqueElements([1, 2, 3], [2, 3, 4]) == [[1], [4]])\nassert(findUniqueElements( [1, 1, 2, 3], [3, 4, 4, 5]) == [[1, 2], [4, 5]])\nassert(findUniqueElements( [1, 2, 2], [1, 1, 1]) == [[2], []])\nassert(findUniqueElements( [], [1, 2, 3]) == [[], [1, 2, 3]])\nassert(findUniqueElements( [4, 5, 6], [4, 5, 6]) == [[], []])\nassert(findUniqueElements( [10], [10, 20]) == [[], [20]])\n}\n\ncheckFindUniqueElements(findUniqueElements)",
    "entry_point": "findUniqueElements",
    "signature": "func findUniqueElements(nums1: [Int], nums2: [Int]) -> [[Int]] {",
    "docstring": {
      "en": "\nReturns two lists: one with unique integers in 'nums1' not in 'nums2', and another with unique integers in 'nums2' not in 'nums1'.\nThe integers in each list are returned in ascending order.\n>>> findUniqueElements(nums1: [1, 2, 3], nums2: [2, 3, 4])\n[[1], [4]] // 1 is unique to nums1, 4 is unique to nums2.\n>>> findUniqueElements(nums1: [1, 1, 2, 3], nums2: [3, 4, 4, 5])\n[[1, 2], [4, 5]] // 1, 2 are unique to nums1; 4, 5 are unique to nums2.\n",
      "es": "Devuelve dos listas: una con enteros únicos en 'nums1' que no están en 'nums2', y otra con enteros únicos en 'nums2' que no están en 'nums1'.  \nLos enteros en cada lista se devuelven en orden ascendente.  \n>>> findUniqueElements(nums1: [1, 2, 3], nums2: [2, 3, 4])  \n[[1], [4]] // 1 es único en nums1, 4 es único en nums2.  \n>>> findUniqueElements(nums1: [1, 1, 2, 3], nums2: [3, 4, 4, 5])  \n[[1, 2], [4, 5]] // 1, 2 son únicos en nums1; 4, 5 son únicos en nums2.  ",
      "arb": "يعيد قائمتين: واحدة تحتوي على الأعداد الصحيحة الفريدة في 'nums1' غير الموجودة في 'nums2'، والأخرى تحتوي على الأعداد الصحيحة الفريدة في 'nums2' غير الموجودة في 'nums1'. يتم إرجاع الأعداد الصحيحة في كل قائمة بترتيب تصاعدي.\n>>> findUniqueElements(nums1: [1, 2, 3], nums2: [2, 3, 4])\n[[1], [4]] // 1 فريد لـ nums1، 4 فريد لـ nums2.\n>>> findUniqueElements(nums1: [1, 1, 2, 3], nums2: [3, 4, 4, 5])\n[[1, 2], [4, 5]] // 1، 2 فريدان لـ nums1؛ 4، 5 فريدان لـ nums2.",
      "sw": "Rudisha orodha mbili: moja yenye nambari za kipekee katika 'nums1' ambazo hazipo katika 'nums2', na nyingine yenye nambari za kipekee katika 'nums2' ambazo hazipo katika 'nums1'. Nambari katika kila orodha zinarudishwa kwa mpangilio wa kupanda.\n>>> findUniqueElements(nums1: [1, 2, 3], nums2: [2, 3, 4])\n[[1], [4]] // 1 ni ya kipekee kwa nums1, 4 ni ya kipekee kwa nums2.\n>>> findUniqueElements(nums1: [1, 1, 2, 3], nums2: [3, 4, 4, 5])\n[[1, 2], [4, 5]] // 1, 2 ni za kipekee kwa nums1; 4, 5 ni za kipekee kwa nums2.",
      "tr": "'nums1' içinde olup 'nums2' içinde olmayan benzersiz tamsayılarla bir liste ve 'nums2' içinde olup 'nums1' içinde olmayan benzersiz tamsayılarla başka bir liste döndürür.\nHer listedeki tamsayılar artan sırayla döndürülür.\n>>> findUniqueElements(nums1: [1, 2, 3], nums2: [2, 3, 4])\n[[1], [4]] // 1 nums1'e özgüdür, 4 nums2'ye özgüdür.\n>>> findUniqueElements(nums1: [1, 1, 2, 3], nums2: [3, 4, 4, 5])\n[[1, 2], [4, 5]] // 1, 2 nums1'e özgüdür; 4, 5 nums2'ye özgüdür.",
      "vi": "Trả về hai danh sách: một danh sách với các số nguyên duy nhất trong 'nums1' không có trong 'nums2', và một danh sách khác với các số nguyên duy nhất trong 'nums2' không có trong 'nums1'.  \nCác số nguyên trong mỗi danh sách được trả về theo thứ tự tăng dần.\n>>> findUniqueElements(nums1: [1, 2, 3], nums2: [2, 3, 4])\n[[1], [4]] // 1 là duy nhất trong nums1, 4 là duy nhất trong nums2.\n>>> findUniqueElements(nums1: [1, 1, 2, 3], nums2: [3, 4, 4, 5])\n[[1, 2], [4, 5]] // 1, 2 là duy nhất trong nums1; 4, 5 là duy nhất trong nums2."
    },
    "docstring_bertscore": {
      "es": "0.9747099826258759",
      "arb": "0.9736465155658152",
      "sw": "0.9713573004243881",
      "tr": "0.9661376912715532",
      "vi": "0.971550369154754"
    }
  },
  {
    "task_id": "Swift/16",
    "prompt": {
      "en": "import Foundation\n\nfunc closestToZero(_ nums: [Int]) -> Int {\n/**\nReturns the number in the array 'nums' that is closest to zero.\nIf there are multiple such numbers, returns the largest one.\n>>> closestToZero([2, -1, 1])\n1 // 1 and -1 are equally close to zero, but 1 is larger.\n>>> closestToZero([-3, -2, -1])\n-1 // -1 is closest to zero.\n*/",
      "es": "import Foundation\n\nfunc closestToZero(_ nums: [Int]) -> Int {\n/**\nDevuelve el número en el arreglo 'nums' que está más cercano a cero.\nSi hay múltiples números así, devuelve el más grande.\n>>> closestToZero([2, -1, 1])\n1 // 1 y -1 están igualmente cerca de cero, pero 1 es más grande.\n>>> closestToZero([-3, -2, -1])\n-1 // -1 es el más cercano a cero.\n*/",
      "arb": "import Foundation\n\nfunc closestToZero(_ nums: [Int]) -> Int {\n/**\nيعيد الرقم في المصفوفة 'nums' الذي يكون الأقرب إلى الصفر.\nإذا كان هناك عدة أرقام كذلك، يعيد الأكبر منها.\n>>> closestToZero([2, -1, 1])\n1 // 1 و -1 متساويان في القرب من الصفر، لكن 1 أكبر.\n>>> closestToZero([-3, -2, -1])\n-1 // -1 هو الأقرب إلى الصفر.\n*/",
      "sw": "import Foundation\n\nfunc closestToZero(_ nums: [Int]) -> Int {\n/**\nInarudisha nambari katika safu 'nums' ambayo iko karibu zaidi na sifuri.\nIkiwa kuna nambari nyingi kama hizo, inarudisha ile kubwa zaidi.\n>>> closestToZero([2, -1, 1])\n1 // 1 na -1 ziko karibu sawa na sifuri, lakini 1 ni kubwa zaidi.\n>>> closestToZero([-3, -2, -1])\n-1 // -1 iko karibu zaidi na sifuri.\n*/",
      "tr": "import Foundation\n\nfunc closestToZero(_ nums: [Int]) -> Int {\n/**\n'nums' dizisindeki sıfıra en yakın sayıyı döndürür.\nEğer birden fazla böyle sayı varsa, en büyüğünü döndürür.\n>>> closestToZero([2, -1, 1])\n1 // 1 ve -1 sıfıra eşit derecede yakın, ancak 1 daha büyük.\n>>> closestToZero([-3, -2, -1])\n-1 // -1 sıfıra en yakın.\n*/",
      "vi": "import Foundation\n\nfunc closestToZero(_ nums: [Int]) -> Int {\n/**\nTrả về số trong mảng 'nums' gần với số không nhất.\nNếu có nhiều số như vậy, trả về số lớn nhất.\n>>> closestToZero([2, -1, 1])\n1 // 1 và -1 đều gần với số không, nhưng 1 lớn hơn.\n>>> closestToZero([-3, -2, -1])\n-1 // -1 gần với số không nhất.\n*/"
    },
    "prompt_bertscore": {
      "es": "0.9899379807879156",
      "arb": "0.9954261382159096",
      "sw": "0.9917647844022935",
      "tr": "0.985385372454596",
      "vi": "0.9797397011344414"
    },
    "canonical_solution": "guard !nums.isEmpty else { return 0 }\n\nvar closestNumber = nums[0]\nfor num in nums {\nif abs(num) < abs(closestNumber) || (abs(num) == abs(closestNumber) && num > closestNumber) {\nclosestNumber = num\n}\n}\nreturn closestNumber\n}",
    "instruction": {
      "en": "func closestToZero(_ nums: [Int]) -> Int {\nguard !nums.isEmpty else { return 0 }\n\nvar closestNumber = nums[0]\nfor num in nums {\nif abs(num) < abs(closestNumber) || (abs(num) == abs(closestNumber) && num > closestNumber) {\nclosestNumber = num\n}\n}\nreturn closestNumber\n}\n\nProvide a concise natural language description (docstring) of the Swift code in English using at most 500 characters.",
      "es": "func closestToZero(_ nums: [Int]) -> Int {\nguard !nums.isEmpty else { return 0 }\n\nvar closestNumber = nums[0]\nfor num in nums {\nif abs(num) < abs(closestNumber) || (abs(num) == abs(closestNumber) && num > closestNumber) {\nclosestNumber = num\n}\n}\nreturn closestNumber\n}\n\nProporcione una descripción concisa en lenguaje natural (docstring) del código Swift en español utilizando un máximo de 500 caracteres.",
      "arb": "func closestToZero(_ nums: [Int]) -> Int {\nguard !nums.isEmpty else { return 0 }\n\nvar closestNumber = nums[0]\nfor num in nums {\nif abs(num) < abs(closestNumber) || (abs(num) == abs(closestNumber) && num > closestNumber) {\nclosestNumber = num\n}\n}\nreturn closestNumber\n}\n\nقدم وصفًا موجزًا بلغة طبيعية (docstring) لكود Swift باللغة العربية الفصحى باستخدام 500 حرف كحد أقصى.",
      "sw": "func closestToZero(_ nums: [Int]) -> Int {\nguard !nums.isEmpty else { return 0 }\n\nvar closestNumber = nums[0]\nfor num in nums {\nif abs(num) < abs(closestNumber) || (abs(num) == abs(closestNumber) && num > closestNumber) {\nclosestNumber = num\n}\n}\nreturn closestNumber\n}\n\nToa maelezo mafupi ya lugha asilia (docstring) ya msimbo wa Swift kwa Kiswahili kwa kutumia herufi zisizozidi 500.",
      "tr": "func closestToZero(_ nums: [Int]) -> Int {\nguard !nums.isEmpty else { return 0 }\n\nvar closestNumber = nums[0]\nfor num in nums {\nif abs(num) < abs(closestNumber) || (abs(num) == abs(closestNumber) && num > closestNumber) {\nclosestNumber = num\n}\n}\nreturn closestNumber\n}\n\nSwift kodunun Türkçe dilinde en fazla 500 karakter kullanarak kısa bir doğal dil açıklamasını (docstring) sağlayın.",
      "vi": "func closestToZero(_ nums: [Int]) -> Int {\nguard !nums.isEmpty else { return 0 }\n\nvar closestNumber = nums[0]\nfor num in nums {\nif abs(num) < abs(closestNumber) || (abs(num) == abs(closestNumber) && num > closestNumber) {\nclosestNumber = num\n}\n}\nreturn closestNumber\n}\n\nCung cấp mô tả ngắn gọn bằng ngôn ngữ tự nhiên (docstring) cho mã Swift bằng tiếng Việt, sử dụng tối đa 500 ký tự."
    },
    "instruction_bertscore": {
      "es": "0.9676013985493994",
      "arb": "0.9017943587910168",
      "sw": "0.942496901951162",
      "tr": "0.9225164732924815",
      "vi": "0.9054771646857847"
    },
    "level": "",
    "test": "func checkClosestToZero(_ closestToZero: ([Int]) -> Int) {\nassert(closestToZero([2, -1, 1]) == 1)\nassert(closestToZero([-3, -2, -1]) == -1)\nassert(closestToZero([0, 10, 20]) == 0)\nassert(closestToZero([5, 6, 7]) == 5)\nassert(closestToZero([-5, 5]) == 5)\nassert(closestToZero([-10, -5, 0, 5, 10]) == 0)\nassert(closestToZero([]) == 0)\n}\n\ncheckClosestToZero(closestToZero)",
    "entry_point": "closestToZero",
    "signature": "func closestToZero(_ nums: [Int]) -> Int {",
    "docstring": {
      "en": "\nReturns the number in the array 'nums' that is closest to zero.\nIf there are multiple such numbers, returns the largest one.\n>>> closestToZero([2, -1, 1])\n1 // 1 and -1 are equally close to zero, but 1 is larger.\n>>> closestToZero([-3, -2, -1])\n-1 // -1 is closest to zero.\n",
      "es": "Devuelve el número en el array 'nums' que está más cercano a cero.  \nSi hay múltiples números así, devuelve el más grande.  \n>>> closestToZero([2, -1, 1])  \n1 // 1 y -1 están igualmente cerca de cero, pero 1 es más grande.  \n>>> closestToZero([-3, -2, -1])  \n-1 // -1 está más cercano a cero.  ",
      "arb": "يعيد الرقم في المصفوفة 'nums' الذي يكون الأقرب إلى الصفر. إذا كان هناك عدة أرقام من هذا النوع، يعيد الأكبر منها.\n>>> closestToZero([2, -1, 1])\n1 // 1 و -1 متساويان في القرب من الصفر، لكن 1 أكبر.\n>>> closestToZero([-3, -2, -1])\n-1 // -1 هو الأقرب إلى الصفر.",
      "sw": "Inarejesha nambari katika safu 'nums' ambayo iko karibu zaidi na sifuri. Ikiwa kuna nambari nyingi kama hizo, inarejesha kubwa zaidi.  \n>>> closestToZero([2, -1, 1])  \n1 // 1 na -1 ziko karibu sawa na sifuri, lakini 1 ni kubwa zaidi.  \n>>> closestToZero([-3, -2, -1])  \n-1 // -1 iko karibu zaidi na sifuri.  ",
      "tr": "Dizideki 'nums' içinde sıfıra en yakın olan sayıyı döndürür.\nEğer birden fazla böyle sayı varsa, en büyüğünü döndürür.\n>>> closestToZero([2, -1, 1])\n1 // 1 ve -1 sıfıra eşit derecede yakın, ancak 1 daha büyüktür.\n>>> closestToZero([-3, -2, -1])\n-1 // -1 sıfıra en yakın olanıdır.",
      "vi": "Trả về số trong mảng 'nums' gần với số không nhất.  \nNếu có nhiều số như vậy, trả về số lớn nhất.  \n>>> closestToZero([2, -1, 1])  \n1 // 1 và -1 đều gần với số không như nhau, nhưng 1 lớn hơn.  \n>>> closestToZero([-3, -2, -1])  \n-1 // -1 là gần với số không nhất.  "
    },
    "docstring_bertscore": {
      "es": "0.9979918468477372",
      "arb": "0.9955945767790272",
      "sw": "0.9888224725680237",
      "tr": "0.9658109442947509",
      "vi": "0.9768307592041855"
    }
  },
  {
    "task_id": "Swift/17",
    "prompt": {
      "en": "import Foundation\n\nfunc commonElementsInAllArrays(_ nums: [[Int]]) -> [Int] {\n/**\nReturns an array of elements that appear in all arrays within the two-dimensional array 'nums'.\nEach array in 'nums' consists of distinct positive integers.\n>>> commonElementsInAllArrays([[1, 2, 3], [2, 3, 4], [3, 4, 5]])\n[3] // Only '3' appears in all arrays.\n>>> commonElementsInAllArrays([[1, 2], [2, 3, 4], [1, 2, 3]])\n[2] // Only '2' appears in all arrays.\n*/",
      "es": "import Foundation\n\nfunc commonElementsInAllArrays(_ nums: [[Int]]) -> [Int] {\n/**\nDevuelve un arreglo de elementos que aparecen en todos los arreglos dentro del arreglo bidimensional 'nums'.\nCada arreglo en 'nums' consiste en enteros positivos distintos.\n>>> commonElementsInAllArrays([[1, 2, 3], [2, 3, 4], [3, 4, 5]])\n[3] // Solo '3' aparece en todos los arreglos.\n>>> commonElementsInAllArrays([[1, 2], [2, 3, 4], [1, 2, 3]])\n[2] // Solo '2' aparece en todos los arreglos.\n*/",
      "arb": "import Foundation\n\nfunc commonElementsInAllArrays(_ nums: [[Int]]) -> [Int] {\n/**\nيعيد مصفوفة من العناصر التي تظهر في جميع المصفوفات داخل المصفوفة الثنائية الأبعاد 'nums'.\nكل مصفوفة في 'nums' تتكون من أعداد صحيحة موجبة ومتميزة.\n>>> commonElementsInAllArrays([[1, 2, 3], [2, 3, 4], [3, 4, 5]])\n[3] // يظهر فقط '3' في جميع المصفوفات.\n>>> commonElementsInAllArrays([[1, 2], [2, 3, 4], [1, 2, 3]])\n[2] // يظهر فقط '2' في جميع المصفوفات.\n*/",
      "sw": "import Foundation\n\nfunc commonElementsInAllArrays(_ nums: [[Int]]) -> [Int] {\n/**\nInarudisha safu ya vipengele vinavyoonekana katika safu zote ndani ya safu mbili-dimensionali 'nums'.\nKila safu katika 'nums' ina nambari za kipekee zisizo hasi.\n>>> commonElementsInAllArrays([[1, 2, 3], [2, 3, 4], [3, 4, 5]])\n[3] // Ni '3' pekee inayojitokeza katika safu zote.\n>>> commonElementsInAllArrays([[1, 2], [2, 3, 4], [1, 2, 3]])\n[2] // Ni '2' pekee inayojitokeza katika safu zote.\n*/",
      "tr": "import Foundation\n\nfunc commonElementsInAllArrays(_ nums: [[Int]]) -> [Int] {\n/**\n'nums' içindeki iki boyutlu dizideki tüm dizilerde görünen elemanları içeren bir dizi döndürür.\n'nums' içindeki her dizi, farklı pozitif tamsayılardan oluşur.\n>>> commonElementsInAllArrays([[1, 2, 3], [2, 3, 4], [3, 4, 5]])\n[3] // Sadece '3' tüm dizilerde görünür.\n>>> commonElementsInAllArrays([[1, 2], [2, 3, 4], [1, 2, 3]])\n[2] // Sadece '2' tüm dizilerde görünür.\n*/",
      "vi": "import Foundation\n\nfunc commonElementsInAllArrays(_ nums: [[Int]]) -> [Int] {\n/**\nTrả về một mảng các phần tử xuất hiện trong tất cả các mảng trong mảng hai chiều 'nums'.\nMỗi mảng trong 'nums' bao gồm các số nguyên dương khác nhau.\n>>> commonElementsInAllArrays([[1, 2, 3], [2, 3, 4], [3, 4, 5]])\n[3] // Chỉ có '3' xuất hiện trong tất cả các mảng.\n>>> commonElementsInAllArrays([[1, 2], [2, 3, 4], [1, 2, 3]])\n[2] // Chỉ có '2' xuất hiện trong tất cả các mảng.\n*/"
    },
    "prompt_bertscore": {
      "es": "0.9901866660249713",
      "arb": "0.9945622946887889",
      "sw": "0.9854743588652997",
      "tr": "0.9901117823713212",
      "vi": "0.9976317299669211"
    },
    "canonical_solution": "guard let first = nums.first else { return [] }\nvar common = Set(first)\n\nfor array in nums.dropFirst() {\ncommon = common.intersection(Set(array))\n}\n\nreturn Array(common).sorted()\n}",
    "instruction": {
      "en": "func commonElementsInAllArrays(_ nums: [[Int]]) -> [Int] {\nguard let first = nums.first else { return [] }\nvar common = Set(first)\n\nfor array in nums.dropFirst() {\ncommon = common.intersection(Set(array))\n}\n\nreturn Array(common).sorted()\n}\n\nProvide a concise natural language description (docstring) of the Swift code in English using at most 500 characters.",
      "es": "func commonElementsInAllArrays(_ nums: [[Int]]) -> [Int] {\nguard let first = nums.first else { return [] }\nvar common = Set(first)\n\nfor array in nums.dropFirst() {\ncommon = common.intersection(Set(array))\n}\n\nreturn Array(common).sorted()\n}\n\nProporcione una descripción concisa en lenguaje natural (docstring) del código Swift en español utilizando como máximo 500 caracteres.",
      "arb": "func commonElementsInAllArrays(_ nums: [[Int]]) -> [Int] {\nguard let first = nums.first else { return [] }\nvar common = Set(first)\n\nfor array in nums.dropFirst() {\ncommon = common.intersection(Set(array))\n}\n\nreturn Array(common).sorted()\n}\n\nقدم وصفًا موجزًا بلغة طبيعية (docstring) لكود Swift باللغة العربية الفصحى باستخدام ما لا يزيد عن 500 حرف.",
      "sw": "func commonElementsInAllArrays(_ nums: [[Int]]) -> [Int] {\nguard let first = nums.first else { return [] }\nvar common = Set(first)\n\nfor array in nums.dropFirst() {\ncommon = common.intersection(Set(array))\n}\n\nreturn Array(common).sorted()\n}\n\nToa maelezo mafupi ya lugha ya asili (docstring) ya msimbo wa Swift kwa Kiswahili kwa kutumia herufi zisizozidi 500.",
      "tr": "func commonElementsInAllArrays(_ nums: [[Int]]) -> [Int] {\nguard let first = nums.first else { return [] }\nvar common = Set(first)\n\nfor array in nums.dropFirst() {\ncommon = common.intersection(Set(array))\n}\n\nreturn Array(common).sorted()\n}\n\nSwift kodunun işlevini açıklayan kısa bir doğal dil tanımı (docstring) sağlayın. Açıklama, en fazla 500 karakter kullanılarak Türkçe olarak yazılmalıdır.",
      "vi": "func commonElementsInAllArrays(_ nums: [[Int]]) -> [Int] {\nguard let first = nums.first else { return [] }\nvar common = Set(first)\n\nfor array in nums.dropFirst() {\ncommon = common.intersection(Set(array))\n}\n\nreturn Array(common).sorted()\n}\n\nCung cấp mô tả ngắn gọn bằng ngôn ngữ tự nhiên (docstring) cho mã Swift bằng tiếng Việt, sử dụng tối đa 500 ký tự."
    },
    "instruction_bertscore": {
      "es": "0.9676013985493994",
      "arb": "0.8880608556158835",
      "sw": "0.9148419912604365",
      "tr": "0.8816689299541809",
      "vi": "0.9054771646857847"
    },
    "level": "",
    "test": "func checkCommonElementsInAllArrays(_ commonElementsInAllArrays: ([[Int]]) -> [Int]) {\nassert(commonElementsInAllArrays([[1, 2, 3], [2, 3, 4], [3, 4, 5]]) == [3])\nassert(commonElementsInAllArrays([[1, 2], [2, 3, 4], [1, 2, 3]]) == [2])\nassert(commonElementsInAllArrays([[1, 2, 3], [4, 5, 6], [7, 8, 9]]) == [])\nassert(commonElementsInAllArrays([[10, 20], [20, 30], [20, 40]]) == [20])\nassert(commonElementsInAllArrays([[1]]) == [1])\nassert(commonElementsInAllArrays([]) == [])\nassert(commonElementsInAllArrays([[1, 2, 3, 4], [2, 3, 4, 5], [3, 4, 5, 6], [4, 5, 6, 7]]) == [4])\n}\n\ncheckCommonElementsInAllArrays(commonElementsInAllArrays)",
    "entry_point": "commonElementsInAllArrays",
    "signature": "func commonElementsInAllArrays(_ nums: [[Int]]) -> [Int] {",
    "docstring": {
      "en": "\nReturns an array of elements that appear in all arrays within the two-dimensional array 'nums'.\nEach array in 'nums' consists of distinct positive integers.\n>>> commonElementsInAllArrays([[1, 2, 3], [2, 3, 4], [3, 4, 5]])\n[3] // Only '3' appears in all arrays.\n>>> commonElementsInAllArrays([[1, 2], [2, 3, 4], [1, 2, 3]])\n[2] // Only '2' appears in all arrays.\n",
      "es": "Devuelve un arreglo de elementos que aparecen en todos los arreglos dentro del arreglo bidimensional 'nums'.  \nCada arreglo en 'nums' consiste en enteros positivos distintos.  \n>>> commonElementsInAllArrays([[1, 2, 3], [2, 3, 4], [3, 4, 5]])  \n[3] // Solo '3' aparece en todos los arreglos.  \n>>> commonElementsInAllArrays([[1, 2], [2, 3, 4], [1, 2, 3]])  \n[2] // Solo '2' aparece en todos los arreglos.  ",
      "arb": "يعيد مصفوفة من العناصر التي تظهر في جميع المصفوفات داخل المصفوفة ثنائية الأبعاد 'nums'.\nتتكون كل مصفوفة في 'nums' من أعداد صحيحة موجبة ومميزة.\n>>> commonElementsInAllArrays([[1, 2, 3], [2, 3, 4], [3, 4, 5]])\n[3] // يظهر فقط '3' في جميع المصفوفات.\n>>> commonElementsInAllArrays([[1, 2], [2, 3, 4], [1, 2, 3]])\n[2] // يظهر فقط '2' في جميع المصفوفات.",
      "sw": "Inarudisha safu ya vipengele vinavyoonekana katika safu zote ndani ya safu mbili-dimensional 'nums'.\nKila safu katika 'nums' ina nambari za kipekee zisizo hasi.\n>>> commonElementsInAllArrays([[1, 2, 3], [2, 3, 4], [3, 4, 5]])\n[3] // Ni '3' pekee inayoonekana katika safu zote.\n>>> commonElementsInAllArrays([[1, 2], [2, 3, 4], [1, 2, 3]])\n[2] // Ni '2' pekee inayoonekana katika safu zote.",
      "tr": "'nums' iki boyutlu dizisindeki tüm dizilerde görünen elemanların bir dizisini döndürür.  \n'nums' içindeki her dizi, farklı pozitif tam sayılardan oluşur.  \n>>> commonElementsInAllArrays([[1, 2, 3], [2, 3, 4], [3, 4, 5]])  \n[3] // Sadece '3' tüm dizilerde görünür.  \n>>> commonElementsInAllArrays([[1, 2], [2, 3, 4], [1, 2, 3]])  \n[2] // Sadece '2' tüm dizilerde görünür.  ",
      "vi": "Trả về một mảng các phần tử xuất hiện trong tất cả các mảng trong mảng hai chiều 'nums'. Mỗi mảng trong 'nums' bao gồm các số nguyên dương khác biệt.\n>>> commonElementsInAllArrays([[1, 2, 3], [2, 3, 4], [3, 4, 5]])\n[3] // Chỉ có '3' xuất hiện trong tất cả các mảng.\n>>> commonElementsInAllArrays([[1, 2], [2, 3, 4], [1, 2, 3]])\n[2] // Chỉ có '2' xuất hiện trong tất cả các mảng."
    },
    "docstring_bertscore": {
      "es": "0.999999801369619",
      "arb": "0.9948364046146171",
      "sw": "0.9830943696397396",
      "tr": "0.9731366313776986",
      "vi": "0.9999805342226585"
    }
  },
  {
    "task_id": "Swift/18",
    "prompt": {
      "en": "import Foundation\n\nfunc performAlgorithmOnNums(_ nums: [Int]) -> Int {\n/**\nPerforms the specified algorithm on the array 'nums' until only one number is left.\nThe length of 'nums' is a power of 2. For even indices, take the minimum of pairs; for odd indices, take the maximum.\n>>> performAlgorithmOnNums([1, 3, 5, 2, 4, 6, 7, 8])\n1 // Final number after repeatedly applying the algorithm.\n>>> performAlgorithmOnNums([10, 100, 30, 20])\n10 // Final number after applying the algorithm.\n*/",
      "es": "import Foundation\n\nfunc performAlgorithmOnNums(_ nums: [Int]) -> Int {\n/**\nRealiza el algoritmo especificado en el arreglo 'nums' hasta que solo quede un número.\nLa longitud de 'nums' es una potencia de 2. Para índices pares, toma el mínimo de los pares; para índices impares, toma el máximo.\n>>> performAlgorithmOnNums([1, 3, 5, 2, 4, 6, 7, 8])\n1 // Número final después de aplicar repetidamente el algoritmo.\n>>> performAlgorithmOnNums([10, 100, 30, 20])\n10 // Número final después de aplicar el algoritmo.\n*/",
      "arb": "import Foundation\n\nfunc performAlgorithmOnNums(_ nums: [Int]) -> Int {\n/**\nتنفذ الخوارزمية المحددة على المصفوفة 'nums' حتى يتبقى رقم واحد فقط.\nطول 'nums' هو قوة العدد 2. بالنسبة للفهارس الزوجية، يتم أخذ الحد الأدنى من الأزواج؛ بالنسبة للفهارس الفردية، يتم أخذ الحد الأقصى.\n>>> performAlgorithmOnNums([1, 3, 5, 2, 4, 6, 7, 8])\n1 // الرقم النهائي بعد تطبيق الخوارزمية بشكل متكرر.\n>>> performAlgorithmOnNums([10, 100, 30, 20])\n10 // الرقم النهائي بعد تطبيق الخوارزمية.\n*/",
      "sw": "import Foundation\n\nfunc performAlgorithmOnNums(_ nums: [Int]) -> Int {\n/**\nInafanya algoriti maalum kwenye safu 'nums' hadi nambari moja tu ibaki.\nUrefu wa 'nums' ni nguvu ya 2. Kwa faharasa za jozi, chukua kiwango cha chini cha jozi; kwa faharasa zisizo za jozi, chukua kiwango cha juu.\n>>> performAlgorithmOnNums([1, 3, 5, 2, 4, 6, 7, 8])\n1 // Nambari ya mwisho baada ya kutumia algoriti mara kwa mara.\n>>> performAlgorithmOnNums([10, 100, 30, 20])\n10 // Nambari ya mwisho baada ya kutumia algoriti.\n*/",
      "tr": "import Foundation\n\nfunc performAlgorithmOnNums(_ nums: [Int]) -> Int {\n/**\n'nums' dizisi üzerinde belirtilen algoritmayı yalnızca bir sayı kalana kadar uygular.\n'nums' uzunluğu 2'nin bir kuvvetidir. Çift indeksler için çiftlerin minimumunu alın; tek indeksler için maksimumunu alın.\n>>> performAlgorithmOnNums([1, 3, 5, 2, 4, 6, 7, 8])\n1 // Algoritmayı tekrar tekrar uyguladıktan sonra kalan son sayı.\n>>> performAlgorithmOnNums([10, 100, 30, 20])\n10 // Algoritmayı uyguladıktan sonra kalan son sayı.\n*/",
      "vi": "import Foundation\n\nfunc performAlgorithmOnNums(_ nums: [Int]) -> Int {\n/**\nThực hiện thuật toán được chỉ định trên mảng 'nums' cho đến khi chỉ còn lại một số.\nĐộ dài của 'nums' là lũy thừa của 2. Đối với các chỉ số chẵn, lấy giá trị nhỏ nhất của các cặp; đối với các chỉ số lẻ, lấy giá trị lớn nhất.\n>>> performAlgorithmOnNums([1, 3, 5, 2, 4, 6, 7, 8])\n1 // Số cuối cùng sau khi áp dụng thuật toán nhiều lần.\n>>> performAlgorithmOnNums([10, 100, 30, 20])\n10 // Số cuối cùng sau khi áp dụng thuật toán.\n*/"
    },
    "prompt_bertscore": {
      "es": "0.9943328765986936",
      "arb": "0.9673336447957643",
      "sw": "0.9772599994576019",
      "tr": "0.9542409232298497",
      "vi": "0.9715871157752455"
    },
    "canonical_solution": "var currentNums = nums\n\nwhile currentNums.count > 1 {\nvar newNums = [Int]()\nfor i in 0..<currentNums.count / 2 {\nif i % 2 == 0 {\nnewNums.append(min(currentNums[2 * i], currentNums[2 * i + 1]))\n} else {\nnewNums.append(max(currentNums[2 * i], currentNums[2 * i + 1]))\n}\n}\ncurrentNums = newNums\n}\n\nreturn currentNums[0]\n}",
    "instruction": {
      "en": "func performAlgorithmOnNums(_ nums: [Int]) -> Int {\nvar currentNums = nums\n\nwhile currentNums.count > 1 {\nvar newNums = [Int]()\nfor i in 0..<currentNums.count / 2 {\nif i % 2 == 0 {\nnewNums.append(min(currentNums[2 * i], currentNums[2 * i + 1]))\n} else {\nnewNums.append(max(currentNums[2 * i], currentNums[2 * i + 1]))\n}\n}\ncurrentNums = newNums\n}\n\nreturn currentNums[0]\n}\n\nProvide a concise natural language description (docstring) of the Swift code in English using at most 500 characters.",
      "es": "func performAlgorithmOnNums(_ nums: [Int]) -> Int {\nvar currentNums = nums\n\nwhile currentNums.count > 1 {\nvar newNums = [Int]()\nfor i in 0..<currentNums.count / 2 {\nif i % 2 == 0 {\nnewNums.append(min(currentNums[2 * i], currentNums[2 * i + 1]))\n} else {\nnewNums.append(max(currentNums[2 * i], currentNums[2 * i + 1]))\n}\n}\ncurrentNums = newNums\n}\n\nreturn currentNums[0]\n}\n\nProporcione una descripción concisa en lenguaje natural (docstring) del código Swift en español utilizando como máximo 500 caracteres.",
      "arb": "func performAlgorithmOnNums(_ nums: [Int]) -> Int {\nvar currentNums = nums\n\nwhile currentNums.count > 1 {\nvar newNums = [Int]()\nfor i in 0..<currentNums.count / 2 {\nif i % 2 == 0 {\nnewNums.append(min(currentNums[2 * i], currentNums[2 * i + 1]))\n} else {\nnewNums.append(max(currentNums[2 * i], currentNums[2 * i + 1]))\n}\n}\ncurrentNums = newNums\n}\n\nreturn currentNums[0]\n}\n\nقدم وصفًا موجزًا بلغة طبيعية (docstring) لشيفرة Swift باللغة العربية الفصحى باستخدام ما لا يزيد عن 500 حرف.",
      "sw": "func performAlgorithmOnNums(_ nums: [Int]) -> Int {\nvar currentNums = nums\n\nwhile currentNums.count > 1 {\nvar newNums = [Int]()\nfor i in 0..<currentNums.count / 2 {\nif i % 2 == 0 {\nnewNums.append(min(currentNums[2 * i], currentNums[2 * i + 1]))\n} else {\nnewNums.append(max(currentNums[2 * i], currentNums[2 * i + 1]))\n}\n}\ncurrentNums = newNums\n}\n\nreturn currentNums[0]\n}\n\nToa maelezo mafupi ya lugha ya asili (docstring) ya msimbo wa Swift kwa Kiswahili kwa kutumia herufi zisizozidi 500.",
      "tr": "func performAlgorithmOnNums(_ nums: [Int]) -> Int {\nvar currentNums = nums\n\nwhile currentNums.count > 1 {\nvar newNums = [Int]()\nfor i in 0..<currentNums.count / 2 {\nif i % 2 == 0 {\nnewNums.append(min(currentNums[2 * i], currentNums[2 * i + 1]))\n} else {\nnewNums.append(max(currentNums[2 * i], currentNums[2 * i + 1]))\n}\n}\ncurrentNums = newNums\n}\n\nreturn currentNums[0]\n}\n\nSwift kodunun işlevselliğini açıklayan en fazla 500 karakterlik öz bir açıklama (docstring) sağlayın.",
      "vi": "func performAlgorithmOnNums(_ nums: [Int]) -> Int {\nvar currentNums = nums\n\nwhile currentNums.count > 1 {\nvar newNums = [Int]()\nfor i in 0..<currentNums.count / 2 {\nif i % 2 == 0 {\nnewNums.append(min(currentNums[2 * i], currentNums[2 * i + 1]))\n} else {\nnewNums.append(max(currentNums[2 * i], currentNums[2 * i + 1]))\n}\n}\ncurrentNums = newNums\n}\n\nreturn currentNums[0]\n}\n\nCung cấp mô tả ngắn gọn bằng ngôn ngữ tự nhiên (docstring) cho mã Swift bằng tiếng Việt với tối đa 500 ký tự."
    },
    "instruction_bertscore": {
      "es": "0.9676013985493994",
      "arb": "0.8880608556158835",
      "sw": "0.942496901951162",
      "tr": "0.8428509918492948",
      "vi": "0.8999953634299838"
    },
    "level": "",
    "test": "func checkPerformAlgorithmOnNums(_ performAlgorithmOnNums: ([Int]) -> Int) {\nassert(performAlgorithmOnNums([1, 3, 5, 2, 4, 6, 7, 8]) == 1)\nassert(performAlgorithmOnNums([10, 100, 30, 20]) == 10)\nassert(performAlgorithmOnNums([2, 4]) == 2)\nassert(performAlgorithmOnNums([7]) == 7)\n}\n\ncheckPerformAlgorithmOnNums(performAlgorithmOnNums)",
    "entry_point": "performAlgorithmOnNums",
    "signature": "func performAlgorithmOnNums(_ nums: [Int]) -> Int {",
    "docstring": {
      "en": "\nPerforms the specified algorithm on the array 'nums' until only one number is left.\nThe length of 'nums' is a power of 2. For even indices, take the minimum of pairs; for odd indices, take the maximum.\n>>> performAlgorithmOnNums([1, 3, 5, 2, 4, 6, 7, 8])\n1 // Final number after repeatedly applying the algorithm.\n>>> performAlgorithmOnNums([10, 100, 30, 20])\n10 // Final number after applying the algorithm.\n",
      "es": "Realiza el algoritmo especificado en el arreglo 'nums' hasta que solo quede un número.\nLa longitud de 'nums' es una potencia de 2. Para índices pares, toma el mínimo de los pares; para índices impares, toma el máximo.\n>>> performAlgorithmOnNums([1, 3, 5, 2, 4, 6, 7, 8])\n1 // Número final después de aplicar repetidamente el algoritmo.\n>>> performAlgorithmOnNums([10, 100, 30, 20])\n10 // Número final después de aplicar el algoritmo.",
      "arb": "ينفذ الخوارزمية المحددة على المصفوفة 'nums' حتى يتبقى رقم واحد فقط. طول 'nums' هو قوة للعدد 2. بالنسبة للفهارس الزوجية، خذ الحد الأدنى من الأزواج؛ بالنسبة للفهارس الفردية، خذ الحد الأقصى.\n>>> performAlgorithmOnNums([1, 3, 5, 2, 4, 6, 7, 8])\n1 // الرقم النهائي بعد تطبيق الخوارزمية بشكل متكرر.\n>>> performAlgorithmOnNums([10, 100, 30, 20])\n10 // الرقم النهائي بعد تطبيق الخوارزمية.",
      "sw": "Inafanya algoriti maalum kwenye safu 'nums' hadi nambari moja tu ibaki.\nUrefu wa 'nums' ni nguvu ya 2. Kwa faharasa za jozi, chukua ndogo ya jozi; kwa faharasa za witiri, chukua kubwa ya jozi.\n>>> performAlgorithmOnNums([1, 3, 5, 2, 4, 6, 7, 8])\n1 // Nambari ya mwisho baada ya kutumia algoriti mara kwa mara.\n>>> performAlgorithmOnNums([10, 100, 30, 20])\n10 // Nambari ya mwisho baada ya kutumia algoriti.",
      "tr": "Belirtilen algoritmayı 'nums' dizisi üzerinde yalnızca bir sayı kalana kadar uygular.\n'nums' uzunluğu 2'nin bir kuvvetidir. Çift indeksler için çiftlerin minimumunu alın; tek indeksler için maksimumunu alın.\n>>> performAlgorithmOnNums([1, 3, 5, 2, 4, 6, 7, 8])\n1 // Algoritmayı tekrar tekrar uyguladıktan sonra kalan son sayı.\n>>> performAlgorithmOnNums([10, 100, 30, 20])\n10 // Algoritmayı uyguladıktan sonra kalan son sayı.",
      "vi": "Thực hiện thuật toán được chỉ định trên mảng 'nums' cho đến khi chỉ còn lại một số duy nhất. Độ dài của 'nums' là một lũy thừa của 2. Đối với các chỉ số chẵn, lấy giá trị nhỏ nhất của các cặp; đối với các chỉ số lẻ, lấy giá trị lớn nhất.\n>>> performAlgorithmOnNums([1, 3, 5, 2, 4, 6, 7, 8])\n1 // Số cuối cùng sau khi áp dụng thuật toán lặp đi lặp lại.\n>>> performAlgorithmOnNums([10, 100, 30, 20])\n10 // Số cuối cùng sau khi áp dụng thuật toán."
    },
    "docstring_bertscore": {
      "es": "0.989381418460256",
      "arb": "0.9771511500087947",
      "sw": "0.9438169994635198",
      "tr": "0.9426154842886397",
      "vi": "0.9618337681752893"
    }
  },
  {
    "task_id": "Swift/19",
    "prompt": {
      "en": "import Foundation\n\nfunc countPrefixes(_ words: [String], _ s: String) -> Int {\n/**\nCounts the number of strings in 'words' that are prefixes of the string 's'.\n>>> countPrefixes([\"a\", \"b\", \"c\", \"ab\"], \"abc\")\n3 // \"a\", \"ab\", and \"abc\" are prefixes of \"abc\".\n>>> countPrefixes([\"hello\", \"hell\", \"heaven\", \"goodbye\"], \"hello\")\n2 // \"hello\" and \"hell\" are prefixes of \"hello\".\n*/",
      "es": "import Foundation\n\nfunc countPrefixes(_ words: [String], _ s: String) -> Int {\n/**\nCuenta el número de cadenas en 'words' que son prefijos de la cadena 's'.\n>>> countPrefixes([\"a\", \"b\", \"c\", \"ab\"], \"abc\")\n3 // \"a\", \"ab\", y \"abc\" son prefijos de \"abc\".\n>>> countPrefixes([\"hello\", \"hell\", \"heaven\", \"goodbye\"], \"hello\")\n2 // \"hello\" y \"hell\" son prefijos de \"hello\".\n*/",
      "arb": "import Foundation\n\nfunc countPrefixes(_ words: [String], _ s: String) -> Int {\n/**\nيحسب عدد السلاسل في 'words' التي هي بادئات للسلسلة 's'.\n>>> countPrefixes([\"a\", \"b\", \"c\", \"ab\"], \"abc\")\n3 // \"a\"، \"ab\"، و\"abc\" هي بادئات لـ \"abc\".\n>>> countPrefixes([\"hello\", \"hell\", \"heaven\", \"goodbye\"], \"hello\")\n2 // \"hello\" و\"hell\" هما بادئات لـ \"hello\".\n*/",
      "sw": "import Foundation\n\nfunc countPrefixes(_ words: [String], _ s: String) -> Int {\n/**\nInahesabu idadi ya maneno katika 'words' ambayo ni viambishi awali vya neno 's'.\n>>> countPrefixes([\"a\", \"b\", \"c\", \"ab\"], \"abc\")\n3 // \"a\", \"ab\", na \"abc\" ni viambishi awali vya \"abc\".\n>>> countPrefixes([\"hello\", \"hell\", \"heaven\", \"goodbye\"], \"hello\")\n2 // \"hello\" na \"hell\" ni viambishi awali vya \"hello\".\n*/",
      "tr": "import Foundation\n\nfunc countPrefixes(_ words: [String], _ s: String) -> Int {\n/**\n'words' içindeki kaç dizginin 's' dizgisinin ön eki olduğunu sayar.\n>>> countPrefixes([\"a\", \"b\", \"c\", \"ab\"], \"abc\")\n3 // \"a\", \"ab\" ve \"abc\", \"abc\"nin ön ekleridir.\n>>> countPrefixes([\"hello\", \"hell\", \"heaven\", \"goodbye\"], \"hello\")\n2 // \"hello\" ve \"hell\", \"hello\"nun ön ekleridir.\n*/",
      "vi": "import Foundation\n\nfunc countPrefixes(_ words: [String], _ s: String) -> Int {\n/**\nĐếm số lượng chuỗi trong 'words' là tiền tố của chuỗi 's'.\n>>> countPrefixes([\"a\", \"b\", \"c\", \"ab\"], \"abc\")\n3 // \"a\", \"ab\", và \"abc\" là tiền tố của \"abc\".\n>>> countPrefixes([\"hello\", \"hell\", \"heaven\", \"goodbye\"], \"hello\")\n2 // \"hello\" và \"hell\" là tiền tố của \"hello\".\n*/"
    },
    "prompt_bertscore": {
      "es": "0.9999996027392379",
      "arb": "0.9938978760642272",
      "sw": "0.9881366018623102",
      "tr": "0.9848399334282743",
      "vi": "0.9937804855090355"
    },
    "canonical_solution": "return words.filter { s.hasPrefix($0) }.count\n}",
    "instruction": {
      "en": "func countPrefixes(_ words: [String], _ s: String) -> Int {\nreturn words.filter { s.hasPrefix($0) }.count\n}\n\nProvide a concise natural language description (docstring) of the Swift code in English using at most 500 characters.",
      "es": "func countPrefixes(_ words: [String], _ s: String) -> Int {\nreturn words.filter { s.hasPrefix($0) }.count\n}\n\nProporcione una descripción concisa en lenguaje natural (docstring) del código Swift en español utilizando un máximo de 500 caracteres.",
      "arb": "func countPrefixes(_ words: [String], _ s: String) -> Int {\nreturn words.filter { s.hasPrefix($0) }.count\n}\n\nقدم وصفًا موجزًا بلغة طبيعية (docstring) لكود Swift باللغة العربية الفصحى باستخدام 500 حرف كحد أقصى.",
      "sw": "func countPrefixes(_ words: [String], _ s: String) -> Int {\nreturn words.filter { s.hasPrefix($0) }.count\n}\n\nToa maelezo mafupi ya lugha ya asili (docstring) ya msimbo wa Swift kwa Kiswahili kwa kutumia herufi zisizozidi 500.",
      "tr": "func countPrefixes(_ words: [String], _ s: String) -> Int {\nreturn words.filter { s.hasPrefix($0) }.count\n}\n\nSwift kodunun işlevini açıklayan, en fazla 500 karakter uzunluğunda özlü bir doğal dil açıklaması (docstring) sağlayın.",
      "vi": "func countPrefixes(_ words: [String], _ s: String) -> Int {\nreturn words.filter { s.hasPrefix($0) }.count\n}\n\nCung cấp mô tả ngắn gọn bằng ngôn ngữ tự nhiên (docstring) cho mã Swift bằng tiếng Việt, sử dụng tối đa 500 ký tự."
    },
    "instruction_bertscore": {
      "es": "0.9676013985493994",
      "arb": "0.9017943587910168",
      "sw": "0.942496901951162",
      "tr": "0.8726078092321313",
      "vi": "0.9054771646857847"
    },
    "level": "",
    "test": "func checkCountPrefixes(_ countPrefixes: ([String], String) -> Int) {\nassert(countPrefixes([\"a\", \"b\", \"c\", \"ab\"], \"abc\") == 2)\nassert(countPrefixes([\"hello\", \"hell\", \"heaven\", \"goodbye\"], \"hello\") == 2)\nassert(countPrefixes([\"app\", \"apple\", \"apricot\", \"ap\"], \"apple\") == 3)\nassert(countPrefixes([\"blue\", \"blues\", \"blueberry\"], \"blue\") == 1)\nassert(countPrefixes([\"no\", \"match\"], \"yes\") == 0)\nassert(countPrefixes([], \"empty\") == 0)\nassert(countPrefixes([\"full\", \"fullest\", \"ful\"], \"fullest\") == 3)\n}\n\ncheckCountPrefixes(countPrefixes)",
    "entry_point": "countPrefixes",
    "signature": "func countPrefixes(_ words: [String], _ s: String) -> Int {",
    "docstring": {
      "en": "\nCounts the number of strings in 'words' that are prefixes of the string 's'.\n>>> countPrefixes([\"a\", \"b\", \"c\", \"ab\"], \"abc\")\n3 // \"a\", \"ab\", and \"abc\" are prefixes of \"abc\".\n>>> countPrefixes([\"hello\", \"hell\", \"heaven\", \"goodbye\"], \"hello\")\n2 // \"hello\" and \"hell\" are prefixes of \"hello\".\n",
      "es": "Cuenta el número de cadenas en 'words' que son prefijos de la cadena 's'.\n>>> countPrefixes([\"a\", \"b\", \"c\", \"ab\"], \"abc\")\n3 // \"a\", \"ab\" y \"abc\" son prefijos de \"abc\".\n>>> countPrefixes([\"hello\", \"hell\", \"heaven\", \"goodbye\"], \"hello\")\n2 // \"hello\" y \"hell\" son prefijos de \"hello\".",
      "arb": "يحسب عدد السلاسل النصية في 'words' التي هي بادئات للسلسلة النصية 's'.\n>>> countPrefixes([\"a\", \"b\", \"c\", \"ab\"], \"abc\")\n3 // \"a\"، \"ab\"، و\"abc\" هي بادئات لـ\"abc\".\n>>> countPrefixes([\"hello\", \"hell\", \"heaven\", \"goodbye\"], \"hello\")\n2 // \"hello\" و\"hell\" هما بادئات لـ\"hello\".",
      "sw": "Inahesabu idadi ya mistari katika 'words' ambayo ni viambishi awali vya kamba 's'.\n>>> countPrefixes([\"a\", \"b\", \"c\", \"ab\"], \"abc\")\n3 // \"a\", \"ab\", na \"abc\" ni viambishi awali vya \"abc\".\n>>> countPrefixes([\"hello\", \"hell\", \"heaven\", \"goodbye\"], \"hello\")\n2 // \"hello\" na \"hell\" ni viambishi awali vya \"hello\".",
      "tr": "'words' içindeki dizgilerin 's' dizgisinin önekleri olanların sayısını sayar.\n>>> countPrefixes([\"a\", \"b\", \"c\", \"ab\"], \"abc\")\n3 // \"a\", \"ab\" ve \"abc\", \"abc\"nin önekleridir.\n>>> countPrefixes([\"hello\", \"hell\", \"heaven\", \"goodbye\"], \"hello\")\n2 // \"hello\" ve \"hell\", \"hello\"nun önekleridir.",
      "vi": "Đếm số lượng chuỗi trong 'words' là tiền tố của chuỗi 's'.\n>>> countPrefixes([\"a\", \"b\", \"c\", \"ab\"], \"abc\")\n3 // \"a\", \"ab\", và \"abc\" là tiền tố của \"abc\".\n>>> countPrefixes([\"hello\", \"hell\", \"heaven\", \"goodbye\"], \"hello\")\n2 // \"hello\" và \"hell\" là tiền tố của \"hello\"."
    },
    "docstring_bertscore": {
      "es": "0.9853369066416235",
      "arb": "0.9877862178701647",
      "sw": "0.9924776688398278",
      "tr": "1",
      "vi": "0.9889259589965429"
    }
  },
  {
    "task_id": "Swift/20",
    "prompt": {
      "en": "import Foundation\n\nfunc twoSum(_ nums: [Int], _ target: Int) -> [Int] {\n/**\nFinds two numbers in 'nums' whose sum equals 'target', and returns their indices.\nAssumes that each input has exactly one solution, and the same element cannot be used twice.\n>>> twoSum([2, 7, 11, 15], 9)\n[0, 1] // nums[0] + nums[1] == 9\n>>> twoSum([3, 2, 4], 6)\n[1, 2] // nums[1] + nums[2] == 6\n*/",
      "es": "import Foundation\n\nfunc twoSum(_ nums: [Int], _ target: Int) -> [Int] {\n/**\nEncuentra dos números en 'nums' cuya suma es igual a 'target', y devuelve sus índices.\nSupone que cada entrada tiene exactamente una solución, y el mismo elemento no puede usarse dos veces.\n>>> twoSum([2, 7, 11, 15], 9)\n[0, 1] // nums[0] + nums[1] == 9\n>>> twoSum([3, 2, 4], 6)\n[1, 2] // nums[1] + nums[2] == 6\n*/",
      "arb": "import Foundation\n\nfunc twoSum(_ nums: [Int], _ target: Int) -> [Int] {\n/**\nيعثر على رقمين في 'nums' يكون مجموعهما مساويًا لـ 'target'، ويعيد مؤشراتهما.\nيفترض أن كل إدخال له حل واحد بالضبط، ولا يمكن استخدام نفس العنصر مرتين.\n>>> twoSum([2, 7, 11, 15], 9)\n[0, 1] // nums[0] + nums[1] == 9\n>>> twoSum([3, 2, 4], 6)\n[1, 2] // nums[1] + nums[2] == 6\n*/",
      "sw": "import Foundation\n\nfunc twoSum(_ nums: [Int], _ target: Int) -> [Int] {\n/**\nInapata namba mbili katika 'nums' ambazo jumla yake ni sawa na 'target', na inarejesha faharasa zao.\nInadhani kwamba kila ingizo lina suluhisho moja tu, na kipengele kile kile hakiwezi kutumika mara mbili.\n>>> twoSum([2, 7, 11, 15], 9)\n[0, 1] // nums[0] + nums[1] == 9\n>>> twoSum([3, 2, 4], 6)\n[1, 2] // nums[1] + nums[2] == 6\n*/",
      "tr": "import Foundation\n\nfunc twoSum(_ nums: [Int], _ target: Int) -> [Int] {\n/**\n'nums' içinde toplamı 'target' olan iki sayıyı bulur ve bunların indekslerini döndürür.\nHer girdinin tam olarak bir çözümü olduğunu varsayar ve aynı eleman iki kez kullanılamaz.\n>>> twoSum([2, 7, 11, 15], 9)\n[0, 1] // nums[0] + nums[1] == 9\n>>> twoSum([3, 2, 4], 6)\n[1, 2] // nums[1] + nums[2] == 6\n*/",
      "vi": "import Foundation\n\nfunc twoSum(_ nums: [Int], _ target: Int) -> [Int] {\n/**\nTìm hai số trong 'nums' có tổng bằng 'target', và trả về chỉ số của chúng.\nGiả sử rằng mỗi đầu vào có chính xác một giải pháp, và không thể sử dụng cùng một phần tử hai lần.\n>>> twoSum([2, 7, 11, 15], 9)\n[0, 1] // nums[0] + nums[1] == 9\n>>> twoSum([3, 2, 4], 6)\n[1, 2] // nums[1] + nums[2] == 6\n*/"
    },
    "prompt_bertscore": {
      "es": "0.9908925983991693",
      "arb": "0.9823483139285726",
      "sw": "0.9908925983991693",
      "tr": "0.9905400294728324",
      "vi": "0.9933810398127744"
    },
    "canonical_solution": "var numToIndex = [Int: Int]()\n\nfor (i, num) in nums.enumerated() {\nif let foundIndex = numToIndex[target - num] {\nreturn [foundIndex, i].sorted()\n}\nnumToIndex[num] = i\n}\n\nreturn []\n}",
    "instruction": {
      "en": "func twoSum(_ nums: [Int], _ target: Int) -> [Int] {\nvar numToIndex = [Int: Int]()\n\nfor (i, num) in nums.enumerated() {\nif let foundIndex = numToIndex[target - num] {\nreturn [foundIndex, i].sorted()\n}\nnumToIndex[num] = i\n}\n\nreturn []\n}\n\nProvide a concise natural language description (docstring) of the Swift code in English using at most 500 characters.",
      "es": "func twoSum(_ nums: [Int], _ target: Int) -> [Int] {\nvar numToIndex = [Int: Int]()\n\nfor (i, num) in nums.enumerated() {\nif let foundIndex = numToIndex[target - num] {\nreturn [foundIndex, i].sorted()\n}\nnumToIndex[num] = i\n}\n\nreturn []\n}\n\nProporcione una descripción concisa en lenguaje natural (docstring) del código Swift en español utilizando como máximo 500 caracteres.",
      "arb": "func twoSum(_ nums: [Int], _ target: Int) -> [Int] {\nvar numToIndex = [Int: Int]()\n\nfor (i, num) in nums.enumerated() {\nif let foundIndex = numToIndex[target - num] {\nreturn [foundIndex, i].sorted()\n}\nnumToIndex[num] = i\n}\n\nreturn []\n}\n\nقدم وصفًا موجزًا بلغة طبيعية (docstring) لكود Swift باللغة العربية الفصحى باستخدام 500 حرف كحد أقصى.",
      "sw": "func twoSum(_ nums: [Int], _ target: Int) -> [Int] {\nvar numToIndex = [Int: Int]()\n\nfor (i, num) in nums.enumerated() {\nif let foundIndex = numToIndex[target - num] {\nreturn [foundIndex, i].sorted()\n}\nnumToIndex[num] = i\n}\n\nreturn []\n}\n\nToa maelezo mafupi ya lugha ya asili (docstring) ya msimbo wa Swift kwa Kiswahili kwa kutumia herufi zisizozidi 500.",
      "tr": "func twoSum(_ nums: [Int], _ target: Int) -> [Int] {\nvar numToIndex = [Int: Int]()\n\nfor (i, num) in nums.enumerated() {\nif let foundIndex = numToIndex[target - num] {\nreturn [foundIndex, i].sorted()\n}\nnumToIndex[num] = i\n}\n\nreturn []\n}\n\nSwift kodunun işlevini açıklayan kısa bir doğal dil açıklaması (docstring) sağlayın. Açıklama, en fazla 500 karakter kullanılarak Türkçe olarak yazılmalıdır.",
      "vi": "func twoSum(_ nums: [Int], _ target: Int) -> [Int] {\nvar numToIndex = [Int: Int]()\n\nfor (i, num) in nums.enumerated() {\nif let foundIndex = numToIndex[target - num] {\nreturn [foundIndex, i].sorted()\n}\nnumToIndex[num] = i\n}\n\nreturn []\n}\n\nCung cấp mô tả ngắn gọn bằng ngôn ngữ tự nhiên (docstring) cho mã Swift bằng tiếng Việt, sử dụng tối đa 500 ký tự."
    },
    "instruction_bertscore": {
      "es": "0.9676013985493994",
      "arb": "0.9202294430852458",
      "sw": "0.942496901951162",
      "tr": "0.8714851503185221",
      "vi": "0.9054771646857847"
    },
    "level": "",
    "test": "func checkTwoSum(_ twoSum: ([Int], Int) -> [Int]) {\nassert(twoSum([2, 7, 11, 15], 9) == [0, 1])\nassert(twoSum([3, 2, 4], 6) == [1, 2])\nassert(twoSum([3, 3], 6) == [0, 1])\nassert(twoSum([1, 5, 4, 7], 8) == [0, 3])\nassert(twoSum([1, 2, 3, 4], 7) == [2, 3])\nassert(twoSum([4, 4], 8) == [0, 1])\nassert(twoSum([-1, -2, -3, -4, -5], -8) == [2, 4])\n}\n\ncheckTwoSum(twoSum)",
    "entry_point": "twoSum",
    "signature": "func twoSum(_ nums: [Int], _ target: Int) -> [Int] {",
    "docstring": {
      "en": "\nFinds two numbers in 'nums' whose sum equals 'target', and returns their indices.\nAssumes that each input has exactly one solution, and the same element cannot be used twice.\n>>> twoSum([2, 7, 11, 15], 9)\n[0, 1] // nums[0] + nums[1] == 9\n>>> twoSum([3, 2, 4], 6)\n[1, 2] // nums[1] + nums[2] == 6\n",
      "es": "Encuentra dos números en 'nums' cuya suma es igual a 'target', y devuelve sus índices.\nSupone que cada entrada tiene exactamente una solución, y el mismo elemento no puede usarse dos veces.\n>>> twoSum([2, 7, 11, 15], 9)\n[0, 1] // nums[0] + nums[1] == 9\n>>> twoSum([3, 2, 4], 6)\n[1, 2] // nums[1] + nums[2] == 6",
      "arb": "يعثر على رقمين في 'nums' يكون مجموعهما مساويًا لـ 'target' ويعيد مؤشراتهما. \nيفترض أن كل إدخال له حل واحد فقط، ولا يمكن استخدام نفس العنصر مرتين.\n>>> twoSum([2, 7, 11, 15], 9)\n[0, 1] // nums[0] + nums[1] == 9\n>>> twoSum([3, 2, 4], 6)\n[1, 2] // nums[1] + nums[2] == 6",
      "sw": "Inapata nambari mbili katika 'nums' ambazo jumla yake ni sawa na 'target', na inarejesha faharasa zao. Inadhani kwamba kila ingizo lina suluhisho moja tu, na kipengele sawa hakiwezi kutumika mara mbili.\n>>> twoSum([2, 7, 11, 15], 9)\n[0, 1] // nums[0] + nums[1] == 9\n>>> twoSum([3, 2, 4], 6)\n[1, 2] // nums[1] + nums[2] == 6",
      "tr": "'nums' içinde toplamı 'target' olan iki sayıyı bulur ve bunların indekslerini döndürür.\nHer girdinin tam olarak bir çözümü olduğu ve aynı elemanın iki kez kullanılamayacağı varsayılır.\n>>> twoSum([2, 7, 11, 15], 9)\n[0, 1] // nums[0] + nums[1] == 9\n>>> twoSum([3, 2, 4], 6)\n[1, 2] // nums[1] + nums[2] == 6",
      "vi": "Tìm hai số trong 'nums' có tổng bằng 'target', và trả về chỉ số của chúng. Giả định rằng mỗi đầu vào có chính xác một giải pháp, và cùng một phần tử không thể được sử dụng hai lần.\n>>> twoSum([2, 7, 11, 15], 9)\n[0, 1] // nums[0] + nums[1] == 9\n>>> twoSum([3, 2, 4], 6)\n[1, 2] // nums[1] + nums[2] == 6"
    },
    "docstring_bertscore": {
      "es": "0.9829779722364532",
      "arb": "0.9711890604916515",
      "sw": "0.9792800704327267",
      "tr": "0.966187348866812",
      "vi": "0.9875452792179694"
    }
  },
  {
    "task_id": "Swift/21",
    "prompt": {
      "en": "import Foundation\n\nfunc findFourthVertex(_ vertex1: (Int, Int), _ vertex2: (Int, Int), _ vertex3: (Int, Int)) -> (Int, Int) {\n/**\nDetermines the coordinates of the fourth vertex of a rectangle when given the coordinates of three vertices.\nThe rectangle's sides are assumed to be parallel to the coordinate axes.\n\n- Parameters:\n- vertex1: A tuple representing the coordinates of the first vertex.\n- vertex2: A tuple representing the coordinates of the second vertex.\n- vertex3: A tuple representing the coordinates of the third vertex.\n\n- Returns: A tuple representing the coordinates of the fourth vertex.\n\nExample usage:\n>>> findFourthVertex((5, 5), (5, 7), (7, 5))\n(7, 7)\n\n>>> findFourthVertex((2, 3), (2, 5), (4, 5))\n(4, 3)\n*/",
      "es": "import Foundation\n\nfunc findFourthVertex(_ vertex1: (Int, Int), _ vertex2: (Int, Int), _ vertex3: (Int, Int)) -> (Int, Int) {\n/**\nDetermina las coordenadas del cuarto vértice de un rectángulo cuando se dan las coordenadas de tres vértices.\nSe asume que los lados del rectángulo son paralelos a los ejes de coordenadas.\n\n- Parámetros:\n- vertex1: Una tupla que representa las coordenadas del primer vértice.\n- vertex2: Una tupla que representa las coordenadas del segundo vértice.\n- vertex3: Una tupla que representa las coordenadas del tercer vértice.\n\n- Retorna: Una tupla que representa las coordenadas del cuarto vértice.\n\nEjemplo de uso:\n>>> findFourthVertex((5, 5), (5, 7), (7, 5))\n(7, 7)\n\n>>> findFourthVertex((2, 3), (2, 5), (4, 5))\n(4, 3)\n*/",
      "arb": "import Foundation\n\nfunc findFourthVertex(_ vertex1: (Int, Int), _ vertex2: (Int, Int), _ vertex3: (Int, Int)) -> (Int, Int) {\n/**\nيحدد إحداثيات الرأس الرابع لمستطيل عند إعطاء إحداثيات ثلاثة رؤوس.\nيُفترض أن تكون جوانب المستطيل موازية لمحاور الإحداثيات.\n\n- Parameters:\n- vertex1: زوج يمثل إحداثيات الرأس الأول.\n- vertex2: زوج يمثل إحداثيات الرأس الثاني.\n- vertex3: زوج يمثل إحداثيات الرأس الثالث.\n\n- Returns: زوج يمثل إحداثيات الرأس الرابع.\n\nمثال على الاستخدام:\n>>> findFourthVertex((5, 5), (5, 7), (7, 5))\n(7, 7)\n\n>>> findFourthVertex((2, 3), (2, 5), (4, 5))\n(4, 3)\n*/",
      "sw": "import Foundation\n\nfunc findFourthVertex(_ vertex1: (Int, Int), _ vertex2: (Int, Int), _ vertex3: (Int, Int)) -> (Int, Int) {\n/**\nHuamua kuratibu za kilele cha nne cha mstatili unapopewa kuratibu za vilele vitatu.\nUpande wa mstatili unadhaniwa kuwa sambamba na mhimili wa kuratibu.\n\n- Vigezo:\n- vertex1: Jozi inayoashiria kuratibu za kilele cha kwanza.\n- vertex2: Jozi inayoashiria kuratibu za kilele cha pili.\n- vertex3: Jozi inayoashiria kuratibu za kilele cha tatu.\n\n- Inarudisha: Jozi inayoashiria kuratibu za kilele cha nne.\n\nMfano wa matumizi:\n>>> findFourthVertex((5, 5), (5, 7), (7, 5))\n(7, 7)\n\n>>> findFourthVertex((2, 3), (2, 5), (4, 5))\n(4, 3)\n*/",
      "tr": "import Foundation\n\nfunc findFourthVertex(_ vertex1: (Int, Int), _ vertex2: (Int, Int), _ vertex3: (Int, Int)) -> (Int, Int) {\n/**\nÜç köşenin koordinatları verildiğinde bir dikdörtgenin dördüncü köşesinin koordinatlarını belirler.\nDikdörtgenin kenarlarının koordinat eksenlerine paralel olduğu varsayılır.\n\n- Parametreler:\n- vertex1: İlk köşenin koordinatlarını temsil eden bir demet.\n- vertex2: İkinci köşenin koordinatlarını temsil eden bir demet.\n- vertex3: Üçüncü köşenin koordinatlarını temsil eden bir demet.\n\n- Döndürür: Dördüncü köşenin koordinatlarını temsil eden bir demet.\n\nÖrnek kullanım:\n>>> findFourthVertex((5, 5), (5, 7), (7, 5))\n(7, 7)\n\n>>> findFourthVertex((2, 3), (2, 5), (4, 5))\n(4, 3)\n*/",
      "vi": "import Foundation\n\nfunc findFourthVertex(_ vertex1: (Int, Int), _ vertex2: (Int, Int), _ vertex3: (Int, Int)) -> (Int, Int) {\n/**\nXác định tọa độ của đỉnh thứ tư của một hình chữ nhật khi biết tọa độ của ba đỉnh.\nCác cạnh của hình chữ nhật được giả định là song song với các trục tọa độ.\n\n- Tham số:\n- vertex1: Một bộ giá trị đại diện cho tọa độ của đỉnh thứ nhất.\n- vertex2: Một bộ giá trị đại diện cho tọa độ của đỉnh thứ hai.\n- vertex3: Một bộ giá trị đại diện cho tọa độ của đỉnh thứ ba.\n\n- Trả về: Một bộ giá trị đại diện cho tọa độ của đỉnh thứ tư.\n\nVí dụ sử dụng:\n>>> findFourthVertex((5, 5), (5, 7), (7, 5))\n(7, 7)\n\n>>> findFourthVertex((2, 3), (2, 5), (4, 5))\n(4, 3)\n*/"
    },
    "prompt_bertscore": {
      "es": "0.9780964319921398",
      "arb": "0.9709830807865184",
      "sw": "0.9796366119666843",
      "tr": "0.9891418702207279",
      "vi": "0.9902228167543197"
    },
    "canonical_solution": "var xCoords = [vertex1.0, vertex2.0, vertex3.0]\nvar yCoords = [vertex1.1, vertex2.1, vertex3.1]\n\nlet uniqueXCoords = Set(xCoords)\nlet uniqueYCoords = Set(yCoords)\n\nvar fourthX = 0 // Initializing with a default value\nvar fourthY = 0 // Initializing with a default value\n\nfor x in uniqueXCoords {\nif xCoords.filter({ $0 == x }).count == 1 {\nfourthX = x\nbreak\n}\n}\n\nfor y in uniqueYCoords {\nif yCoords.filter({ $0 == y }).count == 1 {\nfourthY = y\nbreak\n}\n}\n\nreturn (fourthX, fourthY)\n}",
    "instruction": {
      "en": "func findFourthVertex(_ vertex1: (Int, Int), _ vertex2: (Int, Int), _ vertex3: (Int, Int)) -> (Int, Int) {\nvar xCoords = [vertex1.0, vertex2.0, vertex3.0]\nvar yCoords = [vertex1.1, vertex2.1, vertex3.1]\n\nlet uniqueXCoords = Set(xCoords)\nlet uniqueYCoords = Set(yCoords)\n\nvar fourthX = 0 // Initializing with a default value\nvar fourthY = 0 // Initializing with a default value\n\nfor x in uniqueXCoords {\nif xCoords.filter({ $0 == x }).count == 1 {\nfourthX = x\nbreak\n}\n}\n\nfor y in uniqueYCoords {\nif yCoords.filter({ $0 == y }).count == 1 {\nfourthY = y\nbreak\n}\n}\n\nreturn (fourthX, fourthY)\n}\n\nProvide a concise natural language description (docstring) of the Swift code in English using at most 500 characters.",
      "es": "func findFourthVertex(_ vertex1: (Int, Int), _ vertex2: (Int, Int), _ vertex3: (Int, Int)) -> (Int, Int) {\nvar xCoords = [vertex1.0, vertex2.0, vertex3.0]\nvar yCoords = [vertex1.1, vertex2.1, vertex3.1]\n\nlet uniqueXCoords = Set(xCoords)\nlet uniqueYCoords = Set(yCoords)\n\nvar fourthX = 0 // Initializing with a default value\nvar fourthY = 0 // Initializing with a default value\n\nfor x in uniqueXCoords {\nif xCoords.filter({ $0 == x }).count == 1 {\nfourthX = x\nbreak\n}\n}\n\nfor y in uniqueYCoords {\nif yCoords.filter({ $0 == y }).count == 1 {\nfourthY = y\nbreak\n}\n}\n\nreturn (fourthX, fourthY)\n}\n\nProporcione una descripción concisa en lenguaje natural (docstring) del código Swift en español utilizando como máximo 500 caracteres.",
      "arb": "func findFourthVertex(_ vertex1: (Int, Int), _ vertex2: (Int, Int), _ vertex3: (Int, Int)) -> (Int, Int) {\nvar xCoords = [vertex1.0, vertex2.0, vertex3.0]\nvar yCoords = [vertex1.1, vertex2.1, vertex3.1]\n\nlet uniqueXCoords = Set(xCoords)\nlet uniqueYCoords = Set(yCoords)\n\nvar fourthX = 0 // Initializing with a default value\nvar fourthY = 0 // Initializing with a default value\n\nfor x in uniqueXCoords {\nif xCoords.filter({ $0 == x }).count == 1 {\nfourthX = x\nbreak\n}\n}\n\nfor y in uniqueYCoords {\nif yCoords.filter({ $0 == y }).count == 1 {\nfourthY = y\nbreak\n}\n}\n\nreturn (fourthX, fourthY)\n}\n\nقم بتوفير وصف موجز بلغة طبيعية (docstring) للكود المكتوب بلغة Swift باللغة العربية الفصحى باستخدام 500 حرف كحد أقصى.",
      "sw": "func findFourthVertex(_ vertex1: (Int, Int), _ vertex2: (Int, Int), _ vertex3: (Int, Int)) -> (Int, Int) {\nvar xCoords = [vertex1.0, vertex2.0, vertex3.0]\nvar yCoords = [vertex1.1, vertex2.1, vertex3.1]\n\nlet uniqueXCoords = Set(xCoords)\nlet uniqueYCoords = Set(yCoords)\n\nvar fourthX = 0 // Initializing with a default value\nvar fourthY = 0 // Initializing with a default value\n\nfor x in uniqueXCoords {\nif xCoords.filter({ $0 == x }).count == 1 {\nfourthX = x\nbreak\n}\n}\n\nfor y in uniqueYCoords {\nif yCoords.filter({ $0 == y }).count == 1 {\nfourthY = y\nbreak\n}\n}\n\nreturn (fourthX, fourthY)\n}\n\nToa maelezo mafupi ya lugha ya asili (docstring) ya msimbo wa Swift kwa Kiswahili kwa kutumia herufi zisizozidi 500.",
      "tr": "func findFourthVertex(_ vertex1: (Int, Int), _ vertex2: (Int, Int), _ vertex3: (Int, Int)) -> (Int, Int) {\nvar xCoords = [vertex1.0, vertex2.0, vertex3.0]\nvar yCoords = [vertex1.1, vertex2.1, vertex3.1]\n\nlet uniqueXCoords = Set(xCoords)\nlet uniqueYCoords = Set(yCoords)\n\nvar fourthX = 0 // Initializing with a default value\nvar fourthY = 0 // Initializing with a default value\n\nfor x in uniqueXCoords {\nif xCoords.filter({ $0 == x }).count == 1 {\nfourthX = x\nbreak\n}\n}\n\nfor y in uniqueYCoords {\nif yCoords.filter({ $0 == y }).count == 1 {\nfourthY = y\nbreak\n}\n}\n\nreturn (fourthX, fourthY)\n}\n\nSwift kodunun işlevini açıklayan kısa bir doğal dil açıklaması (docstring) sağlayın. Açıklama, en fazla 500 karakter kullanılarak Türkçe olarak yazılmalıdır.",
      "vi": "func findFourthVertex(_ vertex1: (Int, Int), _ vertex2: (Int, Int), _ vertex3: (Int, Int)) -> (Int, Int) {\nvar xCoords = [vertex1.0, vertex2.0, vertex3.0]\nvar yCoords = [vertex1.1, vertex2.1, vertex3.1]\n\nlet uniqueXCoords = Set(xCoords)\nlet uniqueYCoords = Set(yCoords)\n\nvar fourthX = 0 // Initializing with a default value\nvar fourthY = 0 // Initializing with a default value\n\nfor x in uniqueXCoords {\nif xCoords.filter({ $0 == x }).count == 1 {\nfourthX = x\nbreak\n}\n}\n\nfor y in uniqueYCoords {\nif yCoords.filter({ $0 == y }).count == 1 {\nfourthY = y\nbreak\n}\n}\n\nreturn (fourthX, fourthY)\n}\n\nCung cấp mô tả ngắn gọn bằng ngôn ngữ tự nhiên (docstring) cho mã Swift bằng tiếng Việt, sử dụng tối đa 500 ký tự."
    },
    "instruction_bertscore": {
      "es": "0.9676013985493994",
      "arb": "0.9006313779100575",
      "sw": "0.942496901951162",
      "tr": "0.8816689299541809",
      "vi": "0.9054771646857847"
    },
    "level": "",
    "test": "func check(_ findFourthVertex: ((Int, Int), (Int, Int), (Int, Int)) -> (Int, Int)) {\nassert(findFourthVertex((5, 5), (5, 7), (7, 5)) == (7, 7))\nassert(findFourthVertex((2, 3), (2, 5), (4, 5)) == (4, 3))\nassert(findFourthVertex((10, 10), (10, 20), (20, 10)) == (20, 20))\nassert(findFourthVertex((15, 15), (10, 15), (10, 10)) == (15, 10))\nassert(findFourthVertex((3, 4), (5, 4), (3, 2)) == (5, 2))\nassert(findFourthVertex((8, 9), (8, 12), (11, 12)) == (11, 9))\n}\n\ncheck(findFourthVertex)",
    "entry_point": "findFourthVertex",
    "signature": "func findFourthVertex(_ vertex1: (Int, Int), _ vertex2: (Int, Int), _ vertex3: (Int, Int)) -> (Int, Int) {",
    "docstring": {
      "en": "\nDetermines the coordinates of the fourth vertex of a rectangle when given the coordinates of three vertices.\nThe rectangle's sides are assumed to be parallel to the coordinate axes.\n\n- Parameters:\n- vertex1: A tuple representing the coordinates of the first vertex.\n- vertex2: A tuple representing the coordinates of the second vertex.\n- vertex3: A tuple representing the coordinates of the third vertex.\n\n- Returns: A tuple representing the coordinates of the fourth vertex.\n\nExample usage:\n>>> findFourthVertex((5, 5), (5, 7), (7, 5))\n(7, 7)\n\n>>> findFourthVertex((2, 3), (2, 5), (4, 5))\n(4, 3)\n",
      "es": "Determina las coordenadas del cuarto vértice de un rectángulo cuando se dan las coordenadas de tres vértices. Se asume que los lados del rectángulo son paralelos a los ejes de coordenadas.\n\n- Parámetros:\n- vertex1: Una tupla que representa las coordenadas del primer vértice.\n- vertex2: Una tupla que representa las coordenadas del segundo vértice.\n- vertex3: Una tupla que representa las coordenadas del tercer vértice.\n\n- Retorna: Una tupla que representa las coordenadas del cuarto vértice.\n\nEjemplo de uso:\n>>> findFourthVertex((5, 5), (5, 7), (7, 5))\n(7, 7)\n\n>>> findFourthVertex((2, 3), (2, 5), (4, 5))\n(4, 3)",
      "arb": "يحدد إحداثيات الرأس الرابع لمستطيل عند إعطاء إحداثيات ثلاثة رؤوس.\nمن المفترض أن تكون جوانب المستطيل موازية لمحاور الإحداثيات.\n\n- المعاملات:\n- vertex1: زوج يمثل إحداثيات الرأس الأول.\n- vertex2: زوج يمثل إحداثيات الرأس الثاني.\n- vertex3: زوج يمثل إحداثيات الرأس الثالث.\n\n- يعيد: زوج يمثل إحداثيات الرأس الرابع.\n\nمثال على الاستخدام:\n>>> findFourthVertex((5, 5), (5, 7), (7, 5))\n(7, 7)\n\n>>> findFourthVertex((2, 3), (2, 5), (4, 5))\n(4, 3)",
      "sw": "Inabainisha kuratibu za kipeo cha nne cha mstatili unapopewa kuratibu za vilele vitatu.\nUpande wa mstatili unadhaniwa kuwa sambamba na mhimili wa kuratibu.\n\n- Vigezo:\n- vertex1: Jozi inayowakilisha kuratibu za kipeo cha kwanza.\n- vertex2: Jozi inayowakilisha kuratibu za kipeo cha pili.\n- vertex3: Jozi inayowakilisha kuratibu za kipeo cha tatu.\n\n- Inarejesha: Jozi inayowakilisha kuratibu za kipeo cha nne.\n\nMfano wa matumizi:\n>>> findFourthVertex((5, 5), (5, 7), (7, 5))\n(7, 7)\n\n>>> findFourthVertex((2, 3), (2, 5), (4, 5))\n(4, 3)",
      "tr": "Dikdörtgenin üç köşesinin koordinatları verildiğinde, dördüncü köşenin koordinatlarını belirler. Dikdörtgenin kenarlarının koordinat eksenlerine paralel olduğu varsayılır.\n\n- Parametreler:\n- vertex1: İlk köşenin koordinatlarını temsil eden bir demet.\n- vertex2: İkinci köşenin koordinatlarını temsil eden bir demet.\n- vertex3: Üçüncü köşenin koordinatlarını temsil eden bir demet.\n\n- Döndürür: Dördüncü köşenin koordinatlarını temsil eden bir demet.\n\nÖrnek kullanım:\n>>> findFourthVertex((5, 5), (5, 7), (7, 5))\n(7, 7)\n\n>>> findFourthVertex((2, 3), (2, 5), (4, 5))\n(4, 3)",
      "vi": "Xác định tọa độ của đỉnh thứ tư của một hình chữ nhật khi biết tọa độ của ba đỉnh.\nCác cạnh của hình chữ nhật được giả định là song song với các trục tọa độ.\n\n- Tham số:\n- vertex1: Một bộ đại diện cho tọa độ của đỉnh thứ nhất.\n- vertex2: Một bộ đại diện cho tọa độ của đỉnh thứ hai.\n- vertex3: Một bộ đại diện cho tọa độ của đỉnh thứ ba.\n\n- Trả về: Một bộ đại diện cho tọa độ của đỉnh thứ tư.\n\nVí dụ sử dụng:\n>>> findFourthVertex((5, 5), (5, 7), (7, 5))\n(7, 7)\n\n>>> findFourthVertex((2, 3), (2, 5), (4, 5))\n(4, 3)"
    },
    "docstring_bertscore": {
      "es": "0.9825594580236127",
      "arb": "0.9611747125710156",
      "sw": "0.9687890095976069",
      "tr": "0.9729578640347673",
      "vi": "0.9820861218256065"
    }
  },
  {
    "task_id": "Swift/22",
    "prompt": {
      "en": "import Foundation\n\nfunc adjustChessPieces(_ counts: [Int]) -> [Int] {\n/**\nThis function calculates the number of chess pieces that need to be added or removed to complete a standard chess set. A complete set consists of 1 King, 1 Queen, 2 Rooks, 2 Bishops, 2 Knights, and 8 Pawns.\n\nThe input is an array of six integers representing the count of each piece in the order: King, Queen, Rook, Bishop, Knight, Pawn. Each number is between 0 and 10 inclusive.\n\nThe function returns an array of six integers indicating how many pieces of each type need to be added (positive number) or removed (negative number) to complete the set.\n\nExample:\n>>> adjustChessPieces([1, 1, 2, 2, 2, 8])\n[0, 0, 0, 0, 0, 0] // The set is already complete\n\n>>> adjustChessPieces([0, 2, 1, 2, 2, 5])\n[1, -1, 1, 0, 0, 3] // Add 1 King, remove 1 Queen, add 1 Rook, add 3 Pawns\n*/",
      "es": "import Foundation\n\nfunc adjustChessPieces(_ counts: [Int]) -> [Int] {\n/**\nEsta función calcula el número de piezas de ajedrez que necesitan ser añadidas o removidas para completar un juego de ajedrez estándar. Un juego completo consiste en 1 Rey, 1 Reina, 2 Torres, 2 Alfiles, 2 Caballos y 8 Peones.\n\nLa entrada es un arreglo de seis enteros que representa la cantidad de cada pieza en el orden: Rey, Reina, Torre, Alfil, Caballo, Peón. Cada número está entre 0 y 10 inclusive.\n\nLa función devuelve un arreglo de seis enteros que indica cuántas piezas de cada tipo necesitan ser añadidas (número positivo) o removidas (número negativo) para completar el juego.\n\nEjemplo:\n>>> adjustChessPieces([1, 1, 2, 2, 2, 8])\n[0, 0, 0, 0, 0, 0] // El juego ya está completo\n\n>>> adjustChessPieces([0, 2, 1, 2, 2, 5])\n[1, -1, 1, 0, 0, 3] // Añadir 1 Rey, remover 1 Reina, añadir 1 Torre, añadir 3 Peones\n*/",
      "arb": "import Foundation\n\nfunc adjustChessPieces(_ counts: [Int]) -> [Int] {\n/**\nهذه الدالة تحسب عدد قطع الشطرنج التي يجب إضافتها أو إزالتها لإكمال مجموعة شطرنج قياسية. تتكون المجموعة الكاملة من 1 ملك، 1 ملكة، 2 قلعة، 2 فيل، 2 حصان، و8 جنود.\n\nالمدخل هو مصفوفة تحتوي على ستة أعداد صحيحة تمثل عدد كل قطعة بالترتيب: ملك، ملكة، قلعة، فيل، حصان، جندي. كل عدد يكون بين 0 و10 شامل.\n\nتعيد الدالة مصفوفة من ستة أعداد صحيحة تشير إلى عدد القطع من كل نوع التي يجب إضافتها (عدد موجب) أو إزالتها (عدد سالب) لإكمال المجموعة.\n\nمثال:\n>>> adjustChessPieces([1, 1, 2, 2, 2, 8])\n[0, 0, 0, 0, 0, 0] // المجموعة مكتملة بالفعل\n\n>>> adjustChessPieces([0, 2, 1, 2, 2, 5])\n[1, -1, 1, 0, 0, 3] // إضافة 1 ملك، إزالة 1 ملكة، إضافة 1 قلعة، إضافة 3 جنود\n*/",
      "sw": "import Foundation\n\nfunc adjustChessPieces(_ counts: [Int]) -> [Int] {\n/**\nKazi ya hii kazi ni kuhesabu idadi ya vipande vya mchezo wa chess vinavyohitajika kuongezwa au kuondolewa ili kukamilisha seti ya kawaida ya chess. Seti kamili ina vipande 1 Mfalme, 1 Malkia, 2 Ngome, 2 Askofu, 2 Farasi, na 8 Punda.\n\nIngizo ni safu ya nambari sita zinazoashiria idadi ya kila kipande kwa mpangilio: Mfalme, Malkia, Ngome, Askofu, Farasi, Punda. Kila nambari iko kati ya 0 na 10 ikijumuishwa.\n\nKazi inarudisha safu ya nambari sita zinazoashiria ni vipande vingapi vya kila aina vinavyohitajika kuongezwa (nambari chanya) au kuondolewa (nambari hasi) ili kukamilisha seti.\n\nMfano:\n>>> adjustChessPieces([1, 1, 2, 2, 2, 8])\n[0, 0, 0, 0, 0, 0] // Seti tayari imekamilika\n\n>>> adjustChessPieces([0, 2, 1, 2, 2, 5])\n[1, -1, 1, 0, 0, 3] // Ongeza 1 Mfalme, ondoa 1 Malkia, ongeza 1 Ngome, ongeza 3 Punda\n*/",
      "tr": "import Foundation\n\nfunc adjustChessPieces(_ counts: [Int]) -> [Int] {\n/**\nBu fonksiyon, standart bir satranç setini tamamlamak için eklenmesi veya çıkarılması gereken satranç taşlarının sayısını hesaplar. Tam bir set, 1 Şah, 1 Vezir, 2 Kale, 2 Fil, 2 At ve 8 Piyon içerir.\n\nGirdi, Kral, Vezir, Kale, Fil, At, Piyon sırasıyla her bir taşın sayısını temsil eden altı tam sayıdan oluşan bir dizidir. Her sayı 0 ile 10 arasında (dahil) olabilir.\n\nFonksiyon, seti tamamlamak için her türden kaç taşın eklenmesi (pozitif sayı) veya çıkarılması (negatif sayı) gerektiğini belirten altı tam sayıdan oluşan bir dizi döndürür.\n\nÖrnek:\n>>> adjustChessPieces([1, 1, 2, 2, 2, 8])\n[0, 0, 0, 0, 0, 0] // Set zaten tamamlanmış\n\n>>> adjustChessPieces([0, 2, 1, 2, 2, 5])\n[1, -1, 1, 0, 0, 3] // 1 Şah ekle, 1 Vezir çıkar, 1 Kale ekle, 3 Piyon ekle\n*/",
      "vi": "import Foundation\n\nfunc adjustChessPieces(_ counts: [Int]) -> [Int] {\n/**\nHàm này tính toán số lượng quân cờ cần được thêm vào hoặc loại bỏ để hoàn thiện một bộ cờ tiêu chuẩn. Một bộ cờ hoàn chỉnh bao gồm 1 Vua, 1 Hậu, 2 Xe, 2 Tượng, 2 Mã, và 8 Tốt.\n\nĐầu vào là một mảng gồm sáu số nguyên đại diện cho số lượng của mỗi loại quân cờ theo thứ tự: Vua, Hậu, Xe, Tượng, Mã, Tốt. Mỗi số nằm trong khoảng từ 0 đến 10 bao gồm cả hai.\n\nHàm trả về một mảng gồm sáu số nguyên chỉ ra số lượng quân cờ của mỗi loại cần được thêm vào (số dương) hoặc loại bỏ (số âm) để hoàn thiện bộ cờ.\n\nVí dụ:\n>>> adjustChessPieces([1, 1, 2, 2, 2, 8])\n[0, 0, 0, 0, 0, 0] // Bộ cờ đã hoàn chỉnh\n\n>>> adjustChessPieces([0, 2, 1, 2, 2, 5])\n[1, -1, 1, 0, 0, 3] // Thêm 1 Vua, loại bỏ 1 Hậu, thêm 1 Xe, thêm 3 Tốt\n*/"
    },
    "prompt_bertscore": {
      "es": "0.997438065345412",
      "arb": "0.961672281675508",
      "sw": "0.9753404354552807",
      "tr": "0.9843163437438662",
      "vi": "0.9755436343350794"
    },
    "canonical_solution": "let idealCounts = [1, 1, 2, 2, 2, 8] // Ideal counts for King, Queen, Rook, Bishop, Knight, Pawn\nvar adjustments = [Int]()\n\nfor (index, count) in counts.enumerated() {\nadjustments.append(idealCounts[index] - count)\n}\n\nreturn adjustments\n}",
    "instruction": {
      "en": "func adjustChessPieces(_ counts: [Int]) -> [Int] {\nlet idealCounts = [1, 1, 2, 2, 2, 8] // Ideal counts for King, Queen, Rook, Bishop, Knight, Pawn\nvar adjustments = [Int]()\n\nfor (index, count) in counts.enumerated() {\nadjustments.append(idealCounts[index] - count)\n}\n\nreturn adjustments\n}\n\nProvide a concise natural language description (docstring) of the Swift code in English using at most 500 characters.",
      "es": "func adjustChessPieces(_ counts: [Int]) -> [Int] {\nlet idealCounts = [1, 1, 2, 2, 2, 8] // Ideal counts for King, Queen, Rook, Bishop, Knight, Pawn\nvar adjustments = [Int]()\n\nfor (index, count) in counts.enumerated() {\nadjustments.append(idealCounts[index] - count)\n}\n\nreturn adjustments\n}\n\nProporcione una descripción concisa en lenguaje natural (docstring) del código Swift en español utilizando como máximo 500 caracteres.",
      "arb": "func adjustChessPieces(_ counts: [Int]) -> [Int] {\nlet idealCounts = [1, 1, 2, 2, 2, 8] // Ideal counts for King, Queen, Rook, Bishop, Knight, Pawn\nvar adjustments = [Int]()\n\nfor (index, count) in counts.enumerated() {\nadjustments.append(idealCounts[index] - count)\n}\n\nreturn adjustments\n}\n\nقدم وصفًا موجزًا بلغة طبيعية (docstring) لشفرة Swift باللغة العربية الفصحى باستخدام 500 حرف كحد أقصى.",
      "sw": "func adjustChessPieces(_ counts: [Int]) -> [Int] {\nlet idealCounts = [1, 1, 2, 2, 2, 8] // Ideal counts for King, Queen, Rook, Bishop, Knight, Pawn\nvar adjustments = [Int]()\n\nfor (index, count) in counts.enumerated() {\nadjustments.append(idealCounts[index] - count)\n}\n\nreturn adjustments\n}\n\nToa maelezo mafupi ya lugha asilia (docstring) ya msimbo wa Swift kwa Kiswahili kwa kutumia herufi zisizozidi 500.",
      "tr": "func adjustChessPieces(_ counts: [Int]) -> [Int] {\nlet idealCounts = [1, 1, 2, 2, 2, 8] // Ideal counts for King, Queen, Rook, Bishop, Knight, Pawn\nvar adjustments = [Int]()\n\nfor (index, count) in counts.enumerated() {\nadjustments.append(idealCounts[index] - count)\n}\n\nreturn adjustments\n}\n\nSwift kodunun işlevselliğini açıklayan kısa bir doğal dil açıklaması (docstring) sağlayın. Açıklama, en fazla 500 karakter kullanarak Türkçe olmalıdır.",
      "vi": "func adjustChessPieces(_ counts: [Int]) -> [Int] {\nlet idealCounts = [1, 1, 2, 2, 2, 8] // Ideal counts for King, Queen, Rook, Bishop, Knight, Pawn\nvar adjustments = [Int]()\n\nfor (index, count) in counts.enumerated() {\nadjustments.append(idealCounts[index] - count)\n}\n\nreturn adjustments\n}\n\nCung cấp mô tả ngắn gọn bằng ngôn ngữ tự nhiên (docstring) cho mã Swift bằng tiếng Việt, sử dụng tối đa 500 ký tự."
    },
    "instruction_bertscore": {
      "es": "0.9676013985493994",
      "arb": "0.9202294430852458",
      "sw": "0.942496901951162",
      "tr": "0.8765337387132859",
      "vi": "0.9256006072188102"
    },
    "level": "",
    "test": "func testAdjustChessPieces() {\nassert(adjustChessPieces([1, 1, 2, 2, 2, 8]) == [0, 0, 0, 0, 0, 0], \"Test Case 1 Failed\")\nassert(adjustChessPieces([0, 2, 1, 2, 2, 5]) == [1, -1, 1, 0, 0, 3], \"Test Case 2 Failed\")\nassert(adjustChessPieces([1, 0, 2, 1, 3, 8]) == [0, 1, 0, 1, -1, 0], \"Test Case 3 Failed\")\nassert(adjustChessPieces([0, 1, 0, 0, 0, 0]) == [1, 0, 2, 2, 2, 8], \"Test Case 4 Failed\")\nassert(adjustChessPieces([2, 2, 3, 3, 3, 10]) == [-1, -1, -1, -1, -1, -2], \"Test Case 5 Failed\")\n}\n\ntestAdjustChessPieces()",
    "entry_point": "adjustChessPieces",
    "signature": "func adjustChessPieces(_ counts: [Int]) -> [Int] {",
    "docstring": {
      "en": "\nThis function calculates the number of chess pieces that need to be added or removed to complete a standard chess set. A complete set consists of 1 King, 1 Queen, 2 Rooks, 2 Bishops, 2 Knights, and 8 Pawns.\n\nThe input is an array of six integers representing the count of each piece in the order: King, Queen, Rook, Bishop, Knight, Pawn. Each number is between 0 and 10 inclusive.\n\nThe function returns an array of six integers indicating how many pieces of each type need to be added (positive number) or removed (negative number) to complete the set.\n\nExample:\n>>> adjustChessPieces([1, 1, 2, 2, 2, 8])\n[0, 0, 0, 0, 0, 0] // The set is already complete\n\n>>> adjustChessPieces([0, 2, 1, 2, 2, 5])\n[1, -1, 1, 0, 0, 3] // Add 1 King, remove 1 Queen, add 1 Rook, add 3 Pawns\n",
      "es": "Esta función calcula el número de piezas de ajedrez que necesitan ser añadidas o removidas para completar un conjunto estándar de ajedrez. Un conjunto completo consta de 1 Rey, 1 Reina, 2 Torres, 2 Alfiles, 2 Caballos y 8 Peones.\n\nLa entrada es un arreglo de seis enteros que representa la cantidad de cada pieza en el orden: Rey, Reina, Torre, Alfil, Caballo, Peón. Cada número está entre 0 y 10 inclusive.\n\nLa función devuelve un arreglo de seis enteros que indica cuántas piezas de cada tipo necesitan ser añadidas (número positivo) o removidas (número negativo) para completar el conjunto.\n\nEjemplo:\n>>> adjustChessPieces([1, 1, 2, 2, 2, 8])\n[0, 0, 0, 0, 0, 0] // El conjunto ya está completo\n\n>>> adjustChessPieces([0, 2, 1, 2, 2, 5])\n[1, -1, 1, 0, 0, 3] // Añadir 1 Rey, remover 1 Reina, añadir 1 Torre, añadir 3 Peones",
      "arb": "هذه الدالة تحسب عدد قطع الشطرنج التي تحتاج إلى إضافتها أو إزالتها لإكمال مجموعة شطرنج قياسية. تتكون المجموعة الكاملة من 1 ملك، 1 ملكة، 2 قلعة، 2 فيل، 2 حصان، و8 جنود.\n\nالإدخال هو مصفوفة تحتوي على ستة أعداد صحيحة تمثل عدد كل قطعة بالترتيب: ملك، ملكة، قلعة، فيل، حصان، جندي. كل رقم يتراوح بين 0 و10 شاملًا.\n\nالدالة تعيد مصفوفة تحتوي على ستة أعداد صحيحة تشير إلى عدد القطع من كل نوع التي تحتاج إلى إضافتها (عدد موجب) أو إزالتها (عدد سالب) لإكمال المجموعة.\n\nمثال:\n>>> adjustChessPieces([1, 1, 2, 2, 2, 8])\n[0, 0, 0, 0, 0, 0] // المجموعة مكتملة بالفعل\n\n>>> adjustChessPieces([0, 2, 1, 2, 2, 5])\n[1, -1, 1, 0, 0, 3] // أضف 1 ملك، أزل 1 ملكة، أضف 1 قلعة، أضف 3 جنود",
      "sw": "Kazi hii inahesabu idadi ya vipande vya chess vinavyohitajika kuongezwa au kuondolewa ili kukamilisha seti ya kawaida ya chess. Seti kamili inajumuisha Mfalme 1, Malkia 1, Majumba 2, Maaskofu 2, Farasi 2, na Piyade 8.\n\nIngizo ni safu ya nambari sita za integer zinazowakilisha idadi ya kila kipande kwa mpangilio: Mfalme, Malkia, Jumba, Askofu, Farasi, Piyade. Kila nambari iko kati ya 0 na 10 ikijumuisha.\n\nKazi inarudisha safu ya nambari sita za integer ikionyesha ni vipande vingapi vya kila aina vinavyohitajika kuongezwa (nambari chanya) au kuondolewa (nambari hasi) ili kukamilisha seti.\n\nMfano:\n>>> adjustChessPieces([1, 1, 2, 2, 2, 8])\n[0, 0, 0, 0, 0, 0] // Seti tayari imekamilika\n\n>>> adjustChessPieces([0, 2, 1, 2, 2, 5])\n[1, -1, 1, 0, 0, 3] // Ongeza Mfalme 1, ondoa Malkia 1, ongeza Jumba 1, ongeza Piyade 3",
      "tr": "Bu fonksiyon, standart bir satranç takımını tamamlamak için eklenmesi veya çıkarılması gereken satranç taşlarının sayısını hesaplar. Tam bir set, 1 Şah, 1 Vezir, 2 Kale, 2 Fil, 2 At ve 8 Piyon içerir.\n\nGirdi, Şah, Vezir, Kale, Fil, At, Piyon sırasıyla her bir taşın sayısını temsil eden altı tam sayıdan oluşan bir dizidir. Her sayı 0 ile 10 arasında (dahil) olabilir.\n\nFonksiyon, seti tamamlamak için her türden kaç taşın eklenmesi (pozitif sayı) veya çıkarılması (negatif sayı) gerektiğini belirten altı tam sayıdan oluşan bir dizi döndürür.\n\nÖrnek:\n>>> adjustChessPieces([1, 1, 2, 2, 2, 8])\n[0, 0, 0, 0, 0, 0] // Set zaten tamamlanmış\n\n>>> adjustChessPieces([0, 2, 1, 2, 2, 5])\n[1, -1, 1, 0, 0, 3] // 1 Şah ekle, 1 Vezir çıkar, 1 Kale ekle, 3 Piyon ekle",
      "vi": "Hàm này tính toán số lượng quân cờ cần thêm vào hoặc bớt đi để hoàn thành một bộ cờ tiêu chuẩn. Một bộ hoàn chỉnh bao gồm 1 Vua, 1 Hậu, 2 Xe, 2 Tượng, 2 Mã, và 8 Tốt.\n\nĐầu vào là một mảng gồm sáu số nguyên đại diện cho số lượng của mỗi quân cờ theo thứ tự: Vua, Hậu, Xe, Tượng, Mã, Tốt. Mỗi số nằm trong khoảng từ 0 đến 10 bao gồm cả hai đầu.\n\nHàm trả về một mảng gồm sáu số nguyên chỉ ra số lượng quân cờ của mỗi loại cần thêm vào (số dương) hoặc bớt đi (số âm) để hoàn thành bộ cờ.\n\nVí dụ:\n>>> adjustChessPieces([1, 1, 2, 2, 2, 8])\n[0, 0, 0, 0, 0, 0] // Bộ cờ đã hoàn chỉnh\n\n>>> adjustChessPieces([0, 2, 1, 2, 2, 5])\n[1, -1, 1, 0, 0, 3] // Thêm 1 Vua, bớt 1 Hậu, thêm 1 Xe, thêm 3 Tốt"
    },
    "docstring_bertscore": {
      "es": "0.9970270990870508",
      "arb": "0.9532151959421855",
      "sw": "0.9920819971208062",
      "tr": "0.9822921015307398",
      "vi": "0.9754578260104724"
    }
  },
  {
    "task_id": "Swift/23",
    "prompt": {
      "en": "import Foundation\nfunc maxChessboardSlices(_ n: Int) -> Int {\n/**\nCalculates the maximum number of pieces a rectangular chessboard can be divided into with 'n' straight cuts, \nwhere all cuts are parallel to the sides of the rectangle.\n\nThe formula for calculating the maximum number of pieces is (n^2 + n + 2)/2.\n\n- Parameters:\n- n: The number of cuts to be made on the chessboard.\n- Returns: The maximum number of pieces the chessboard can be divided into.\n\nExamples:\n>>> maxChessboardSlices(2)\n4\n>>> maxChessboardSlices(4)\n9\n*/",
      "es": "import Foundation\nfunc maxChessboardSlices(_ n: Int) -> Int {\n/**\nCalcula el número máximo de piezas en las que se puede dividir un tablero de ajedrez rectangular con 'n' cortes rectos,\ndonde todos los cortes son paralelos a los lados del rectángulo.\n\nLa fórmula para calcular el número máximo de piezas es (n^2 + n + 2)/2.\n\n- Parámetros:\n- n: El número de cortes que se realizarán en el tablero de ajedrez.\n- Devuelve: El número máximo de piezas en las que se puede dividir el tablero de ajedrez.\n\nEjemplos:\n>>> maxChessboardSlices(2)\n4\n>>> maxChessboardSlices(4)\n9\n*/",
      "arb": "import Foundation\nfunc maxChessboardSlices(_ n: Int) -> Int {\n/**\nتحسب الحد الأقصى لعدد القطع التي يمكن تقسيم لوحة شطرنج مستطيلة إليها باستخدام 'n' من القطوع المستقيمة،\nحيث تكون جميع القطوع موازية لجوانب المستطيل.\n\nالصيغة لحساب الحد الأقصى لعدد القطع هي (n^2 + n + 2)/2.\n\n- المعلمات:\n- n: عدد القطوع التي سيتم إجراؤها على لوحة الشطرنج.\n- العوائد: الحد الأقصى لعدد القطع التي يمكن تقسيم لوحة الشطرنج إليها.\n\nأمثلة:\n>>> maxChessboardSlices(2)\n4\n>>> maxChessboardSlices(4)\n9\n*/",
      "sw": "import Foundation\nfunc maxChessboardSlices(_ n: Int) -> Int {\n/**\nInahesabu idadi kubwa zaidi ya vipande ambavyo ubao wa chess wa mstatili unaweza kugawanywa kwa 'n' vipande vya moja kwa moja, \nambapo vipande vyote ni sambamba na pande za mstatili.\n\nKanuni ya kuhesabu idadi kubwa zaidi ya vipande ni (n^2 + n + 2)/2.\n\n- Vigezo:\n- n: Idadi ya vipande vitakavyofanywa kwenye ubao wa chess.\n- Inarudisha: Idadi kubwa zaidi ya vipande ambavyo ubao wa chess unaweza kugawanywa.\n\nMifano:\n>>> maxChessboardSlices(2)\n4\n>>> maxChessboardSlices(4)\n9\n*/",
      "tr": "import Foundation\nfunc maxChessboardSlices(_ n: Int) -> Int {\n/**\nDikdörtgen bir satranç tahtasının, tüm kesimlerin dikdörtgenin kenarlarına paralel olduğu 'n' düz kesimle kaç parçaya bölünebileceğini hesaplar.\n\nMaksimum parça sayısını hesaplamak için formül (n^2 + n + 2)/2'dir.\n\n- Parametreler:\n- n: Satranç tahtasında yapılacak kesim sayısı.\n- Döndürür: Satranç tahtasının bölünebileceği maksimum parça sayısı.\n\nÖrnekler:\n>>> maxChessboardSlices(2)\n4\n>>> maxChessboardSlices(4)\n9\n*/",
      "vi": "import Foundation\nfunc maxChessboardSlices(_ n: Int) -> Int {\n/**\nTính toán số lượng mảnh tối đa mà một bàn cờ hình chữ nhật có thể được chia thành với 'n' đường cắt thẳng,\ntrong đó tất cả các đường cắt đều song song với các cạnh của hình chữ nhật.\n\nCông thức để tính số lượng mảnh tối đa là (n^2 + n + 2)/2.\n\n- Tham số:\n- n: Số lượng đường cắt sẽ được thực hiện trên bàn cờ.\n- Trả về: Số lượng mảnh tối đa mà bàn cờ có thể được chia thành.\n\nVí dụ:\n>>> maxChessboardSlices(2)\n4\n>>> maxChessboardSlices(4)\n9\n*/"
    },
    "prompt_bertscore": {
      "es": "0.9857272153403571",
      "arb": "0.9957574536914758",
      "sw": "0.9649884158868854",
      "tr": "0.98836304049669",
      "vi": "0.9804303389692998"
    },
    "canonical_solution": "if n == 0 { return 1 }\n\nreturn (n/2+1)*(n-n/2+1)\n}",
    "instruction": {
      "en": "func maxChessboardSlices(_ n: Int) -> Int {\nif n == 0 { return 1 }\n\nreturn (n/2+1)*(n-n/2+1)\n}\n\nProvide a concise natural language description (docstring) of the Swift code in English using at most 500 characters.",
      "es": "func maxChessboardSlices(_ n: Int) -> Int {\nif n == 0 { return 1 }\n\nreturn (n/2+1)*(n-n/2+1)\n}\n\nProporcione una descripción concisa en lenguaje natural (docstring) del código Swift en español utilizando un máximo de 500 caracteres.",
      "arb": "func maxChessboardSlices(_ n: Int) -> Int {\nif n == 0 { return 1 }\n\nreturn (n/2+1)*(n-n/2+1)\n}\n\nيرجى تقديم وصف موجز بلغة طبيعية (docstring) لشفرة Swift باللغة العربية الفصحى باستخدام ما لا يزيد عن 500 حرف.",
      "sw": "func maxChessboardSlices(_ n: Int) -> Int {\nif n == 0 { return 1 }\n\nreturn (n/2+1)*(n-n/2+1)\n}\n\nToa maelezo mafupi ya lugha ya asili (docstring) ya msimbo wa Swift kwa Kiswahili kwa kutumia herufi zisizozidi 500.",
      "tr": "func maxChessboardSlices(_ n: Int) -> Int {\nif n == 0 { return 1 }\n\nreturn (n/2+1)*(n-n/2+1)\n}\n\nSwift kodunun işlevini açıklayan kısa bir doğal dil açıklaması (docstring) sağlayın. Açıklama, en fazla 500 karakter kullanılarak Türkçe yazılmalıdır.",
      "vi": "func maxChessboardSlices(_ n: Int) -> Int {\nif n == 0 { return 1 }\n\nreturn (n/2+1)*(n-n/2+1)\n}\n\nCung cấp mô tả ngắn gọn bằng ngôn ngữ tự nhiên (docstring) cho mã Swift bằng tiếng Việt, không quá 500 ký tự."
    },
    "instruction_bertscore": {
      "es": "0.9676013985493994",
      "arb": "0.9160987256812443",
      "sw": "0.942496901951162",
      "tr": "0.8816689299541809",
      "vi": "0.9059383844305476"
    },
    "level": "",
    "test": "func testMaxChessboardSlices() {\nassert(maxChessboardSlices(0) == 1)\nassert(maxChessboardSlices(2) == 4)\nassert(maxChessboardSlices(4) == 9)\nassert(maxChessboardSlices(5) == 12)\nassert(maxChessboardSlices(6) == 16)\nassert(maxChessboardSlices(7) == 20)\n}\n\ntestMaxChessboardSlices()",
    "entry_point": "maxChessboardSlices",
    "signature": "func maxChessboardSlices(_ n: Int) -> Int {",
    "docstring": {
      "en": "\nCalculates the maximum number of pieces a rectangular chessboard can be divided into with 'n' straight cuts, \nwhere all cuts are parallel to the sides of the rectangle.\n\nThe formula for calculating the maximum number of pieces is (n^2 + n + 2)/2.\n\n- Parameters:\n- n: The number of cuts to be made on the chessboard.\n- Returns: The maximum number of pieces the chessboard can be divided into.\n\nExamples:\n>>> maxChessboardSlices(2)\n4\n>>> maxChessboardSlices(4)\n9\n",
      "es": "Calcula el número máximo de piezas en las que se puede dividir un tablero de ajedrez rectangular con 'n' cortes rectos, donde todos los cortes son paralelos a los lados del rectángulo.\n\nLa fórmula para calcular el número máximo de piezas es (n^2 + n + 2)/2.\n\n- Parámetros:\n- n: El número de cortes que se realizarán en el tablero de ajedrez.\n- Devuelve: El número máximo de piezas en las que se puede dividir el tablero de ajedrez.\n\nEjemplos:\n>>> maxChessboardSlices(2)\n4\n>>> maxChessboardSlices(4)\n9",
      "arb": "يحسب الحد الأقصى لعدد القطع التي يمكن تقسيم لوح شطرنج مستطيل إليها باستخدام 'n' من القطوع المستقيمة، حيث تكون جميع القطوع موازية لجوانب المستطيل.\n\nالصيغة لحساب الحد الأقصى لعدد القطع هي (n^2 + n + 2)/2.\n\n- المعلمات:\n- n: عدد القطوع التي سيتم إجراؤها على لوح الشطرنج.\n- العوائد: الحد الأقصى لعدد القطع التي يمكن تقسيم لوح الشطرنج إليها.\n\nأمثلة:\n>>> maxChessboardSlices(2)\n4\n>>> maxChessboardSlices(4)\n9",
      "sw": "Hesabu idadi kubwa zaidi ya vipande ambavyo ubao wa chess wa mstatili unaweza kugawanywa kwa kutumia 'n' vipande vya moja kwa moja, ambapo vipande vyote ni sambamba na pande za mstatili.\n\nFomula ya kuhesabu idadi kubwa zaidi ya vipande ni (n^2 + n + 2)/2.\n\n- Vigezo:\n- n: Idadi ya vipande vitakavyofanywa kwenye ubao wa chess.\n- Inarejesha: Idadi kubwa zaidi ya vipande ambavyo ubao wa chess unaweza kugawanywa.\n\nMifano:\n>>> maxChessboardSlices(2)\n4\n>>> maxChessboardSlices(4)\n9",
      "tr": "Dikdörtgen bir satranç tahtasının, tüm kesimlerin dikdörtgenin kenarlarına paralel olduğu 'n' düz kesimle en fazla kaç parçaya bölünebileceğini hesaplar.\n\nMaksimum parça sayısını hesaplama formülü (n^2 + n + 2)/2'dir.\n\n- Parametreler:\n- n: Satranç tahtasında yapılacak kesim sayısı.\n- Döndürür: Satranç tahtasının bölünebileceği maksimum parça sayısı.\n\nÖrnekler:\n>>> maxChessboardSlices(2)\n4\n>>> maxChessboardSlices(4)\n9",
      "vi": "Tính toán số lượng tối đa các mảnh mà một bàn cờ hình chữ nhật có thể được chia thành với 'n' đường cắt thẳng, \ntrong đó tất cả các đường cắt đều song song với các cạnh của hình chữ nhật.\n\nCông thức để tính số lượng tối đa các mảnh là (n^2 + n + 2)/2.\n\n- Tham số:\n- n: Số lượng đường cắt sẽ được thực hiện trên bàn cờ.\n- Trả về: Số lượng tối đa các mảnh mà bàn cờ có thể được chia thành.\n\nVí dụ:\n>>> maxChessboardSlices(2)\n4\n>>> maxChessboardSlices(4)\n9"
    },
    "docstring_bertscore": {
      "es": "0.9847680292303396",
      "arb": "0.9954787752668839",
      "sw": "0.9831070819841259",
      "tr": "0.995206055753723",
      "vi": "0.9904673307533737"
    }
  },
  {
    "task_id": "Swift/24",
    "prompt": {
      "en": "import Foundation\n\nfunc findSmallestWordInMatrix(_ matrix: [[Character]]) -> String {\n/**\nFinds the lexicographically smallest word in a given matrix of characters. \nThe matrix consists of lowercase letters and '#'. A word is defined as a sequence \nof letters either horizontally from left to right or vertically from top to bottom, \nwithout crossing '#'. The word must be at least 2 characters long and be bounded by '#' \nor the edge of the matrix on both ends.\n\nExample:\n>>> findSmallestWordInMatrix([[\"a\", \"b\", \"c\"], [\"#\", \"d\", \"#\"], [\"e\", \"f\", \"g\"]])\n\"abc\"\n*/",
      "es": "import Foundation\n\nfunc findSmallestWordInMatrix(_ matrix: [[Character]]) -> String {\n/**\nEncuentra la palabra lexicográficamente más pequeña en una matriz dada de caracteres. \nLa matriz consiste en letras minúsculas y '#'. Una palabra se define como una secuencia \nde letras ya sea horizontalmente de izquierda a derecha o verticalmente de arriba a abajo, \nsin cruzar '#'. La palabra debe tener al menos 2 caracteres de largo y estar delimitada por '#' \no el borde de la matriz en ambos extremos.\n\nEjemplo:\n>>> findSmallestWordInMatrix([[\"a\", \"b\", \"c\"], [\"#\", \"d\", \"#\"], [\"e\", \"f\", \"g\"]])\n\"abc\"\n*/",
      "arb": "import Foundation\n\nfunc findSmallestWordInMatrix(_ matrix: [[Character]]) -> String {\n/**\nيجد أصغر كلمة ترتيبًا معجميًا في مصفوفة معينة من الأحرف.\nتتكون المصفوفة من أحرف صغيرة و'#'. تُعرف الكلمة على أنها تسلسل من الأحرف إما أفقيًا من اليسار إلى اليمين أو عموديًا من الأعلى إلى الأسفل، دون عبور '#'. يجب أن تكون الكلمة مكونة من حرفين على الأقل وأن تكون محاطة بـ '#' أو حافة المصفوفة في كلا الطرفين.\n\nمثال:\n>>> findSmallestWordInMatrix([[\"a\", \"b\", \"c\"], [\"#\", \"d\", \"#\"], [\"e\", \"f\", \"g\"]])\n\"abc\"\n*/",
      "sw": "import Foundation\n\nfunc findSmallestWordInMatrix(_ matrix: [[Character]]) -> String {\n/**\nInapata neno dogo zaidi kwa mpangilio wa alfabeti katika matriki iliyotolewa ya herufi. \nMatriki inajumuisha herufi ndogo na '#'. Neno linafafanuliwa kama mlolongo \nwa herufi ama kwa usawa kutoka kushoto kwenda kulia au kwa wima kutoka juu kwenda chini, \nbila kuvuka '#'. Neno lazima liwe na urefu wa angalau herufi 2 na liwe limezungukwa na '#' \nau kingo za matriki pande zote mbili.\n\nMfano:\n>>> findSmallestWordInMatrix([[\"a\", \"b\", \"c\"], [\"#\", \"d\", \"#\"], [\"e\", \"f\", \"g\"]])\n\"abc\"\n*/",
      "tr": "import Foundation\n\nfunc findSmallestWordInMatrix(_ matrix: [[Character]]) -> String {\n/**\nVerilen bir karakter matrisinde sözlük sırasına göre en küçük kelimeyi bulur. \nMatris, küçük harfler ve '#' karakterinden oluşur. Bir kelime, soldan sağa yatay \nveya yukarıdan aşağıya dikey olarak, '#' karakterini geçmeden oluşan bir harf dizisi \nolarak tanımlanır. Kelime en az 2 karakter uzunluğunda olmalı ve her iki ucunda \n'#' veya matrisin kenarı ile sınırlanmalıdır.\n\nÖrnek:\n>>> findSmallestWordInMatrix([[\"a\", \"b\", \"c\"], [\"#\", \"d\", \"#\"], [\"e\", \"f\", \"g\"]])\n\"abc\"\n*/",
      "vi": "import Foundation\n\nfunc findSmallestWordInMatrix(_ matrix: [[Character]]) -> String {\n/**\nTìm từ nhỏ nhất theo thứ tự từ điển trong một ma trận ký tự cho trước.\nMa trận bao gồm các chữ cái viết thường và '#'. Một từ được định nghĩa là một chuỗi\ncác chữ cái theo chiều ngang từ trái sang phải hoặc theo chiều dọc từ trên xuống dưới,\nkhông vượt qua '#'. Từ phải có ít nhất 2 ký tự và được giới hạn bởi '#'\nhoặc cạnh của ma trận ở cả hai đầu.\n\nVí dụ:\n>>> findSmallestWordInMatrix([[\"a\", \"b\", \"c\"], [\"#\", \"d\", \"#\"], [\"e\", \"f\", \"g\"]])\n\"abc\"\n*/"
    },
    "prompt_bertscore": {
      "es": "1",
      "arb": "0.9862023392117926",
      "sw": "0.9724914799000973",
      "tr": "0.9481262855800717",
      "vi": "0.9717233762166354"
    },
    "canonical_solution": "var smallestWord: String = String(repeating: \"z\", count: matrix.count * matrix[0].count)\n\n// Check horizontally\nfor row in matrix {\nlet words = String(row).split(separator: \"#\").map(String.init)\nfor word in words where word.count >= 2 && word < smallestWord {\nsmallestWord = word\n}\n}\n\n// Check vertically\nfor col in 0..<matrix[0].count {\nvar columnString = \"\"\nfor row in 0..<matrix.count {\ncolumnString.append(matrix[row][col])\n}\nlet words = columnString.split(separator: \"#\").map(String.init)\nfor word in words where word.count >= 2 && word < smallestWord {\nsmallestWord = word\n}\n}\n\nreturn smallestWord\n}",
    "instruction": {
      "en": "func findSmallestWordInMatrix(_ matrix: [[Character]]) -> String {\nvar smallestWord: String = String(repeating: \"z\", count: matrix.count * matrix[0].count)\n\n// Check horizontally\nfor row in matrix {\nlet words = String(row).split(separator: \"#\").map(String.init)\nfor word in words where word.count >= 2 && word < smallestWord {\nsmallestWord = word\n}\n}\n\n// Check vertically\nfor col in 0..<matrix[0].count {\nvar columnString = \"\"\nfor row in 0..<matrix.count {\ncolumnString.append(matrix[row][col])\n}\nlet words = columnString.split(separator: \"#\").map(String.init)\nfor word in words where word.count >= 2 && word < smallestWord {\nsmallestWord = word\n}\n}\n\nreturn smallestWord\n}\n\nProvide a concise natural language description (docstring) of the Swift code in English using at most 500 characters.",
      "es": "func findSmallestWordInMatrix(_ matrix: [[Character]]) -> String {\nvar smallestWord: String = String(repeating: \"z\", count: matrix.count * matrix[0].count)\n\n// Check horizontally\nfor row in matrix {\nlet words = String(row).split(separator: \"#\").map(String.init)\nfor word in words where word.count >= 2 && word < smallestWord {\nsmallestWord = word\n}\n}\n\n// Check vertically\nfor col in 0..<matrix[0].count {\nvar columnString = \"\"\nfor row in 0..<matrix.count {\ncolumnString.append(matrix[row][col])\n}\nlet words = columnString.split(separator: \"#\").map(String.init)\nfor word in words where word.count >= 2 && word < smallestWord {\nsmallestWord = word\n}\n}\n\nreturn smallestWord\n}\n\nProporciona una descripción concisa en lenguaje natural (docstring) del código Swift en español usando como máximo 500 caracteres.",
      "arb": "func findSmallestWordInMatrix(_ matrix: [[Character]]) -> String {\nvar smallestWord: String = String(repeating: \"z\", count: matrix.count * matrix[0].count)\n\n// Check horizontally\nfor row in matrix {\nlet words = String(row).split(separator: \"#\").map(String.init)\nfor word in words where word.count >= 2 && word < smallestWord {\nsmallestWord = word\n}\n}\n\n// Check vertically\nfor col in 0..<matrix[0].count {\nvar columnString = \"\"\nfor row in 0..<matrix.count {\ncolumnString.append(matrix[row][col])\n}\nlet words = columnString.split(separator: \"#\").map(String.init)\nfor word in words where word.count >= 2 && word < smallestWord {\nsmallestWord = word\n}\n}\n\nreturn smallestWord\n}\n\nقدم وصفًا موجزًا بلغة طبيعية (docstring) لكود Swift باللغة العربية الفصحى باستخدام 500 حرف كحد أقصى.",
      "sw": "func findSmallestWordInMatrix(_ matrix: [[Character]]) -> String {\nvar smallestWord: String = String(repeating: \"z\", count: matrix.count * matrix[0].count)\n\n// Check horizontally\nfor row in matrix {\nlet words = String(row).split(separator: \"#\").map(String.init)\nfor word in words where word.count >= 2 && word < smallestWord {\nsmallestWord = word\n}\n}\n\n// Check vertically\nfor col in 0..<matrix[0].count {\nvar columnString = \"\"\nfor row in 0..<matrix.count {\ncolumnString.append(matrix[row][col])\n}\nlet words = columnString.split(separator: \"#\").map(String.init)\nfor word in words where word.count >= 2 && word < smallestWord {\nsmallestWord = word\n}\n}\n\nreturn smallestWord\n}\n\nToa maelezo mafupi ya lugha asilia (docstring) ya msimbo wa Swift kwa Kiswahili kwa kutumia herufi zisizozidi 500.",
      "tr": "func findSmallestWordInMatrix(_ matrix: [[Character]]) -> String {\nvar smallestWord: String = String(repeating: \"z\", count: matrix.count * matrix[0].count)\n\n// Check horizontally\nfor row in matrix {\nlet words = String(row).split(separator: \"#\").map(String.init)\nfor word in words where word.count >= 2 && word < smallestWord {\nsmallestWord = word\n}\n}\n\n// Check vertically\nfor col in 0..<matrix[0].count {\nvar columnString = \"\"\nfor row in 0..<matrix.count {\ncolumnString.append(matrix[row][col])\n}\nlet words = columnString.split(separator: \"#\").map(String.init)\nfor word in words where word.count >= 2 && word < smallestWord {\nsmallestWord = word\n}\n}\n\nreturn smallestWord\n}\n\nSwift kodunun Türkçe olarak en fazla 500 karakter kullanarak doğal dilde kısa bir açıklamasını (docstring) sağlayın.",
      "vi": "func findSmallestWordInMatrix(_ matrix: [[Character]]) -> String {\nvar smallestWord: String = String(repeating: \"z\", count: matrix.count * matrix[0].count)\n\n// Check horizontally\nfor row in matrix {\nlet words = String(row).split(separator: \"#\").map(String.init)\nfor word in words where word.count >= 2 && word < smallestWord {\nsmallestWord = word\n}\n}\n\n// Check vertically\nfor col in 0..<matrix[0].count {\nvar columnString = \"\"\nfor row in 0..<matrix.count {\ncolumnString.append(matrix[row][col])\n}\nlet words = columnString.split(separator: \"#\").map(String.init)\nfor word in words where word.count >= 2 && word < smallestWord {\nsmallestWord = word\n}\n}\n\nreturn smallestWord\n}\n\nCung cấp mô tả ngắn gọn bằng ngôn ngữ tự nhiên (docstring) cho mã Swift bằng tiếng Việt, sử dụng tối đa 500 ký tự."
    },
    "instruction_bertscore": {
      "es": "0.9676013985493994",
      "arb": "0.9144786962935237",
      "sw": "0.933792521393451",
      "tr": "0.8966428798588769",
      "vi": "0.9054771646857847"
    },
    "level": "",
    "test": "func testFindSmallestWordInMatrix() {\nassert(findSmallestWordInMatrix([[\"a\", \"b\", \"c\"], [\"#\", \"d\", \"#\"], [\"e\", \"f\", \"g\"]]) == \"abc\")\nassert(findSmallestWordInMatrix([[\"a\", \"#\", \"c\"], [\"#\", \"d\", \"e\"], [\"f\", \"g\", \"#\"]]) == \"ce\")\nassert(findSmallestWordInMatrix([[\"#\", \"a\", \"#\"], [\"#\", \"b\", \"c\"], [\"#\", \"#\", \"d\"]]) == \"ab\")\nassert(findSmallestWordInMatrix([[\"m\", \"n\", \"o\"], [\"#\", \"#\", \"#\"], [\"p\", \"q\", \"r\"]]) == \"mno\")\nassert(findSmallestWordInMatrix([[\"x\", \"y\", \"#\"], [\"#\", \"z\", \"a\"], [\"b\", \"c\", \"d\"]]) == \"ad\")\n}\n\ntestFindSmallestWordInMatrix()",
    "entry_point": "findSmallestWordInMatrix",
    "signature": "func findSmallestWordInMatrix(_ matrix: [[Character]]) -> String {",
    "docstring": {
      "en": "\nFinds the lexicographically smallest word in a given matrix of characters. \nThe matrix consists of lowercase letters and '#'. A word is defined as a sequence \nof letters either horizontally from left to right or vertically from top to bottom, \nwithout crossing '#'. The word must be at least 2 characters long and be bounded by '#' \nor the edge of the matrix on both ends.\n\nExample:\n>>> findSmallestWordInMatrix([[\"a\", \"b\", \"c\"], [\"#\", \"d\", \"#\"], [\"e\", \"f\", \"g\"]])\n\"abc\"\n",
      "es": "Encuentra la palabra lexicográficamente más pequeña en una matriz dada de caracteres. \nLa matriz consiste en letras minúsculas y '#'. Una palabra se define como una secuencia \nde letras ya sea horizontalmente de izquierda a derecha o verticalmente de arriba a abajo, \nsin cruzar '#'. La palabra debe tener al menos 2 caracteres de largo y estar delimitada por '#' \no el borde de la matriz en ambos extremos.\n\nEjemplo:\n>>> findSmallestWordInMatrix([[\"a\", \"b\", \"c\"], [\"#\", \"d\", \"#\"], [\"e\", \"f\", \"g\"]])\n\"abc\"",
      "arb": "يجد الكلمة الأصغر ترتيبًا معجميًا في مصفوفة معينة من الأحرف. تتكون المصفوفة من حروف صغيرة و '#'. تُعرّف الكلمة على أنها سلسلة من الحروف إما أفقيًا من اليسار إلى اليمين أو عموديًا من الأعلى إلى الأسفل، دون عبور '#'. يجب أن تكون الكلمة مكونة من حرفين على الأقل وأن تكون محاطة بـ '#' أو حافة المصفوفة في كلا الطرفين.\n\nمثال:\n>>> findSmallestWordInMatrix([[\"a\", \"b\", \"c\"], [\"#\", \"d\", \"#\"], [\"e\", \"f\", \"g\"]])\n\"abc\"",
      "sw": "Inapata neno dogo zaidi kwa mpangilio wa alfabeti katika matriki iliyotolewa ya herufi. \nMatriki inajumuisha herufi ndogo na '#'. Neno linafafanuliwa kama mlolongo \nwa herufi aidha kwa usawa kutoka kushoto kwenda kulia au kwa wima kutoka juu kwenda chini, \nbila kuvuka '#'. Neno lazima liwe na urefu wa angalau herufi 2 na liwe limezungukwa na '#' \nau mwisho wa matriki kwa pande zote mbili.\n\nMfano:\n>>> findSmallestWordInMatrix([[\"a\", \"b\", \"c\"], [\"#\", \"d\", \"#\"], [\"e\", \"f\", \"g\"]])\n\"abc\"",
      "tr": "Verilen bir karakter matrisinde sözlük sırasına göre en küçük kelimeyi bulur. \nMatris küçük harfler ve '#' karakterlerinden oluşur. Bir kelime, soldan sağa yatay \nveya yukarıdan aşağıya dikey olarak, '#' karakterini geçmeden oluşan bir harf \ndizisi olarak tanımlanır. Kelime en az 2 karakter uzunluğunda olmalı ve her iki \nucunda '#' veya matrisin kenarı ile sınırlanmalıdır.\n\nÖrnek:\n>>> findSmallestWordInMatrix([[\"a\", \"b\", \"c\"], [\"#\", \"d\", \"#\"], [\"e\", \"f\", \"g\"]])\n\"abc\"",
      "vi": "Tìm từ nhỏ nhất theo thứ tự từ điển trong một ma trận ký tự cho trước. Ma trận bao gồm các chữ cái viết thường và '#'. Một từ được định nghĩa là một chuỗi các chữ cái theo chiều ngang từ trái sang phải hoặc theo chiều dọc từ trên xuống dưới, không vượt qua '#'. Từ phải dài ít nhất 2 ký tự và được giới hạn bởi '#' hoặc cạnh của ma trận ở cả hai đầu.\n\nVí dụ:\n>>> findSmallestWordInMatrix([[\"a\", \"b\", \"c\"], [\"#\", \"d\", \"#\"], [\"e\", \"f\", \"g\"]])\n\"abc\""
    },
    "docstring_bertscore": {
      "es": "0.9936740196248008",
      "arb": "0.9914398250989205",
      "sw": "0.9557248908065613",
      "tr": "0.9377488413229039",
      "vi": "0.9718542736377374"
    }
  },
  {
    "task_id": "Swift/25",
    "prompt": {
      "en": "import Foundation\n\nfunc findMissingNumber(in numbers: [Int]) -> Int {\n/**\nFinds the missing number in a sequence that was originally an arithmetic progression.\n\nThe input is an array of three integers, representing the remaining numbers of the sequence after one number is lost. The function returns the missing number. The original sequence of four numbers was in arithmetic progression.\n\nExamples:\n- If the input is [3, 7, 5], the function returns 1 or 9, since the sequence could have been [1, 3, 5, 7] or [3, 5, 7, 9].\n- If the input is [20, 14, 8], the function returns 26 or 2, since the sequence could have been [2, 8, 14, 20] or [8, 14, 20, 26].\n*/",
      "es": "import Foundation\n\nfunc findMissingNumber(in numbers: [Int]) -> Int {\n/**\nEncuentra el número que falta en una secuencia que originalmente era una progresión aritmética.\n\nLa entrada es un arreglo de tres enteros, que representan los números restantes de la secuencia después de que se pierde un número. La función devuelve el número que falta. La secuencia original de cuatro números estaba en progresión aritmética.\n\nEjemplos:\n- Si la entrada es [3, 7, 5], la función devuelve 1 o 9, ya que la secuencia podría haber sido [1, 3, 5, 7] o [3, 5, 7, 9].\n- Si la entrada es [20, 14, 8], la función devuelve 26 o 2, ya que la secuencia podría haber sido [2, 8, 14, 20] o [8, 14, 20, 26].\n*/",
      "arb": "import Foundation\n\nfunc findMissingNumber(in numbers: [Int]) -> Int {\n/**\nيجد الرقم المفقود في تسلسل كان في الأصل تتابعًا حسابيًا.\n\nالمدخل هو مصفوفة تحتوي على ثلاثة أعداد صحيحة، تمثل الأرقام المتبقية من التسلسل بعد فقدان رقم واحد. تعيد الدالة الرقم المفقود. كان التسلسل الأصلي المكون من أربعة أرقام في تتابع حسابي.\n\nأمثلة:\n- إذا كان المدخل هو [3, 7, 5]، فإن الدالة تعيد 1 أو 9، حيث يمكن أن يكون التسلسل [1, 3, 5, 7] أو [3, 5, 7, 9].\n- إذا كان المدخل هو [20, 14, 8]، فإن الدالة تعيد 26 أو 2، حيث يمكن أن يكون التسلسل [2, 8, 14, 20] أو [8, 14, 20, 26].\n*/",
      "sw": "import Foundation\n\nfunc findMissingNumber(in numbers: [Int]) -> Int {\n/**\nInapata nambari inayokosekana katika mlolongo ambao awali ulikuwa na maendeleo ya hesabu.\n\nIngizo ni safu ya nambari tatu, inayowakilisha nambari zilizobaki za mlolongo baada ya nambari moja kupotea. Kazi inarudisha nambari inayokosekana. Mlolongo wa awali wa nambari nne ulikuwa katika maendeleo ya hesabu.\n\nMifano:\n- Ikiwa ingizo ni [3, 7, 5], kazi inarudisha 1 au 9, kwani mlolongo ungeweza kuwa [1, 3, 5, 7] au [3, 5, 7, 9].\n- Ikiwa ingizo ni [20, 14, 8], kazi inarudisha 26 au 2, kwani mlolongo ungeweza kuwa [2, 8, 14, 20] au [8, 14, 20, 26].\n*/",
      "tr": "import Foundation\n\nfunc findMissingNumber(in numbers: [Int]) -> Int {\n/**\nBir aritmetik dizide eksik olan sayıyı bulur.\n\nGirdi, bir sayının kaybolmasından sonra dizinin kalan sayılarını temsil eden üç tam sayıdan oluşan bir dizidir. Fonksiyon, eksik olan sayıyı döndürür. Orijinal dört sayılık dizi aritmetik bir diziydi.\n\nÖrnekler:\n- Eğer girdi [3, 7, 5] ise, fonksiyon 1 veya 9 döndürür, çünkü dizi [1, 3, 5, 7] veya [3, 5, 7, 9] olabilirdi.\n- Eğer girdi [20, 14, 8] ise, fonksiyon 26 veya 2 döndürür, çünkü dizi [2, 8, 14, 20] veya [8, 14, 20, 26] olabilirdi.\n*/",
      "vi": "import Foundation\n\nfunc findMissingNumber(in numbers: [Int]) -> Int {\n/**\nTìm số bị thiếu trong một dãy số ban đầu là một cấp số cộng.\n\nĐầu vào là một mảng gồm ba số nguyên, đại diện cho các số còn lại của dãy sau khi một số bị mất. Hàm trả về số bị thiếu. Dãy số gốc gồm bốn số là một cấp số cộng.\n\nVí dụ:\n- Nếu đầu vào là [3, 7, 5], hàm trả về 1 hoặc 9, vì dãy số có thể là [1, 3, 5, 7] hoặc [3, 5, 7, 9].\n- Nếu đầu vào là [20, 14, 8], hàm trả về 26 hoặc 2, vì dãy số có thể là [2, 8, 14, 20] hoặc [8, 14, 20, 26].\n*/"
    },
    "prompt_bertscore": {
      "es": "0.996425050402134",
      "arb": "0.9875283956355815",
      "sw": "0.9924897852930709",
      "tr": "0.9637294965318863",
      "vi": "0.9736540635202945"
    },
    "canonical_solution": "let sortedNumbers = numbers.sorted()\nlet diff1 = sortedNumbers[1] - sortedNumbers[0]\nlet diff2 = sortedNumbers[2] - sortedNumbers[1]\n\nif diff1 == diff2 {\n// The missing number is either at the start or the end of the sequence.\nreturn sortedNumbers[2] + diff1\n} else {\n// The missing number is in the middle of the sequence.\nif diff1 > diff2 {\nreturn sortedNumbers[0] + diff2\n} else {\nreturn sortedNumbers[1] + diff1\n}\n}\n}",
    "instruction": {
      "en": "func findMissingNumber(in numbers: [Int]) -> Int {\nlet sortedNumbers = numbers.sorted()\nlet diff1 = sortedNumbers[1] - sortedNumbers[0]\nlet diff2 = sortedNumbers[2] - sortedNumbers[1]\n\nif diff1 == diff2 {\n// The missing number is either at the start or the end of the sequence.\nreturn sortedNumbers[2] + diff1\n} else {\n// The missing number is in the middle of the sequence.\nif diff1 > diff2 {\nreturn sortedNumbers[0] + diff2\n} else {\nreturn sortedNumbers[1] + diff1\n}\n}\n}\n\nProvide a concise natural language description (docstring) of the Swift code in English using at most 500 characters.",
      "es": "func findMissingNumber(in numbers: [Int]) -> Int {\nlet sortedNumbers = numbers.sorted()\nlet diff1 = sortedNumbers[1] - sortedNumbers[0]\nlet diff2 = sortedNumbers[2] - sortedNumbers[1]\n\nif diff1 == diff2 {\n// The missing number is either at the start or the end of the sequence.\nreturn sortedNumbers[2] + diff1\n} else {\n// The missing number is in the middle of the sequence.\nif diff1 > diff2 {\nreturn sortedNumbers[0] + diff2\n} else {\nreturn sortedNumbers[1] + diff1\n}\n}\n}\n\nProporciona una descripción concisa en lenguaje natural (docstring) del código Swift en español utilizando un máximo de 500 caracteres.",
      "arb": "func findMissingNumber(in numbers: [Int]) -> Int {\nlet sortedNumbers = numbers.sorted()\nlet diff1 = sortedNumbers[1] - sortedNumbers[0]\nlet diff2 = sortedNumbers[2] - sortedNumbers[1]\n\nif diff1 == diff2 {\n// The missing number is either at the start or the end of the sequence.\nreturn sortedNumbers[2] + diff1\n} else {\n// The missing number is in the middle of the sequence.\nif diff1 > diff2 {\nreturn sortedNumbers[0] + diff2\n} else {\nreturn sortedNumbers[1] + diff1\n}\n}\n}\n\nقدم وصفًا موجزًا بلغة طبيعية (docstring) لكود Swift باللغة العربية الفصحى باستخدام 500 حرف على الأكثر.",
      "sw": "func findMissingNumber(in numbers: [Int]) -> Int {\nlet sortedNumbers = numbers.sorted()\nlet diff1 = sortedNumbers[1] - sortedNumbers[0]\nlet diff2 = sortedNumbers[2] - sortedNumbers[1]\n\nif diff1 == diff2 {\n// The missing number is either at the start or the end of the sequence.\nreturn sortedNumbers[2] + diff1\n} else {\n// The missing number is in the middle of the sequence.\nif diff1 > diff2 {\nreturn sortedNumbers[0] + diff2\n} else {\nreturn sortedNumbers[1] + diff1\n}\n}\n}\n\nToa maelezo mafupi ya lugha asilia (docstring) ya msimbo wa Swift kwa Kiswahili kwa kutumia herufi zisizozidi 500.",
      "tr": "func findMissingNumber(in numbers: [Int]) -> Int {\nlet sortedNumbers = numbers.sorted()\nlet diff1 = sortedNumbers[1] - sortedNumbers[0]\nlet diff2 = sortedNumbers[2] - sortedNumbers[1]\n\nif diff1 == diff2 {\n// The missing number is either at the start or the end of the sequence.\nreturn sortedNumbers[2] + diff1\n} else {\n// The missing number is in the middle of the sequence.\nif diff1 > diff2 {\nreturn sortedNumbers[0] + diff2\n} else {\nreturn sortedNumbers[1] + diff1\n}\n}\n}\n\nSwift kodunun işlevini açıklayan, en fazla 500 karakter uzunluğunda, özlü bir doğal dil açıklaması (docstring) sağlayın.",
      "vi": "func findMissingNumber(in numbers: [Int]) -> Int {\nlet sortedNumbers = numbers.sorted()\nlet diff1 = sortedNumbers[1] - sortedNumbers[0]\nlet diff2 = sortedNumbers[2] - sortedNumbers[1]\n\nif diff1 == diff2 {\n// The missing number is either at the start or the end of the sequence.\nreturn sortedNumbers[2] + diff1\n} else {\n// The missing number is in the middle of the sequence.\nif diff1 > diff2 {\nreturn sortedNumbers[0] + diff2\n} else {\nreturn sortedNumbers[1] + diff1\n}\n}\n}\n\nCung cấp mô tả ngắn gọn bằng ngôn ngữ tự nhiên (docstring) cho mã Swift bằng tiếng Việt, sử dụng tối đa 500 ký tự."
    },
    "instruction_bertscore": {
      "es": "0.9676013985493994",
      "arb": "0.9081934351464368",
      "sw": "0.942496901951162",
      "tr": "0.8726078092321313",
      "vi": "0.9170773775686032"
    },
    "level": "",
    "test": "func testFindMissingNumber() {\nassert(findMissingNumber(in: [3, 7, 5]) == 1 || findMissingNumber(in: [3, 7, 5]) == 9)\nassert(findMissingNumber(in: [20, 14, 8]) == 26 || findMissingNumber(in: [20, 14, 8]) == 2)\nassert(findMissingNumber(in: [12, 6, 18]) == 0 || findMissingNumber(in: [12, 6, 18]) == 24)\nassert(findMissingNumber(in: [-4, 0, -8]) == -12 || findMissingNumber(in: [-4, 0, -8]) == 4)\nassert(findMissingNumber(in: [15, 5, 10]) == 0 || findMissingNumber(in: [15, 5, 10]) == 20)\n}\n\ntestFindMissingNumber()",
    "entry_point": "findMissingNumber",
    "signature": "func findMissingNumber(in numbers: [Int]) -> Int {",
    "docstring": {
      "en": "\nFinds the missing number in a sequence that was originally an arithmetic progression.\n\nThe input is an array of three integers, representing the remaining numbers of the sequence after one number is lost. The function returns the missing number. The original sequence of four numbers was in arithmetic progression.\n\nExamples:\n- If the input is [3, 7, 5], the function returns 1 or 9, since the sequence could have been [1, 3, 5, 7] or [3, 5, 7, 9].\n- If the input is [20, 14, 8], the function returns 26 or 2, since the sequence could have been [2, 8, 14, 20] or [8, 14, 20, 26].\n",
      "es": "Encuentra el número faltante en una secuencia que originalmente era una progresión aritmética.\n\nLa entrada es un arreglo de tres enteros, que representan los números restantes de la secuencia después de que se pierde un número. La función devuelve el número faltante. La secuencia original de cuatro números estaba en progresión aritmética.\n\nEjemplos:\n- Si la entrada es [3, 7, 5], la función devuelve 1 o 9, ya que la secuencia podría haber sido [1, 3, 5, 7] o [3, 5, 7, 9].\n- Si la entrada es [20, 14, 8], la función devuelve 26 o 2, ya que la secuencia podría haber sido [2, 8, 14, 20] o [8, 14, 20, 26].",
      "arb": "يعثر على الرقم المفقود في تسلسل كان في الأصل متتالية حسابية.\n\nالإدخال هو مصفوفة تحتوي على ثلاثة أعداد صحيحة، تمثل الأرقام المتبقية من التسلسل بعد فقدان رقم واحد. تُرجع الدالة الرقم المفقود. كان التسلسل الأصلي المكون من أربعة أرقام في متتالية حسابية.\n\nأمثلة:\n- إذا كان الإدخال هو [3, 7, 5]، تُرجع الدالة 1 أو 9، حيث يمكن أن يكون التسلسل [1, 3, 5, 7] أو [3, 5, 7, 9].\n- إذا كان الإدخال هو [20, 14, 8]، تُرجع الدالة 26 أو 2، حيث يمكن أن يكون التسلسل [2, 8, 14, 20] أو [8, 14, 20, 26].",
      "sw": "Inapata nambari inayokosekana katika mlolongo ambao awali ulikuwa mfululizo wa hesabu.\n\nIngizo ni safu ya nambari tatu, inayoashiria nambari zilizobaki za mlolongo baada ya nambari moja kupotea. Kazi inarudisha nambari inayokosekana. Mlolongo wa awali wa nambari nne ulikuwa katika mfululizo wa hesabu.\n\nMifano:\n- Ikiwa ingizo ni [3, 7, 5], kazi inarudisha 1 au 9, kwani mlolongo ungeweza kuwa [1, 3, 5, 7] au [3, 5, 7, 9].\n- Ikiwa ingizo ni [20, 14, 8], kazi inarudisha 26 au 2, kwani mlolongo ungeweza kuwa [2, 8, 14, 20] au [8, 14, 20, 26].",
      "tr": "Eksik sayıyı başlangıçta bir aritmetik dizi olan bir dizide bulur.\n\nGirdi, bir sayının kaybolmasından sonra dizinin kalan sayılarını temsil eden üç tamsayıdan oluşan bir dizidir. Fonksiyon eksik sayıyı döndürür. Dört sayıdan oluşan orijinal dizi aritmetik bir diziydi.\n\nÖrnekler:\n- Eğer giriş [3, 7, 5] ise, fonksiyon 1 veya 9 döndürür, çünkü dizi [1, 3, 5, 7] veya [3, 5, 7, 9] olabilirdi.\n- Eğer giriş [20, 14, 8] ise, fonksiyon 26 veya 2 döndürür, çünkü dizi [2, 8, 14, 20] veya [8, 14, 20, 26] olabilirdi.",
      "vi": "Tìm số bị thiếu trong một dãy số ban đầu là một cấp số cộng.\n\nĐầu vào là một mảng gồm ba số nguyên, đại diện cho các số còn lại của dãy số sau khi một số bị mất. Hàm trả về số bị thiếu. Dãy số gốc gồm bốn số là một cấp số cộng.\n\nVí dụ:\n- Nếu đầu vào là [3, 7, 5], hàm trả về 1 hoặc 9, vì dãy số có thể là [1, 3, 5, 7] hoặc [3, 5, 7, 9].\n- Nếu đầu vào là [20, 14, 8], hàm trả về 26 hoặc 2, vì dãy số có thể là [2, 8, 14, 20] hoặc [8, 14, 20, 26]."
    },
    "docstring_bertscore": {
      "es": "0.9943664451330885",
      "arb": "0.98428635055633",
      "sw": "0.9848635704436174",
      "tr": "0.9820134231061478",
      "vi": "0.9713332661482829"
    }
  },
  {
    "task_id": "Swift/26",
    "prompt": {
      "en": "import Foundation\n\nfunc countUnfairReminders(_ children: [String]) -> Int {\n/**\nCount the number of times the moms are reminded of a child's behavior.\nA mom is reminded if the number of food portions a child has taken\n(excluding the current one) is greater than the total number of food portions\ntaken by other children.\n\nExample:\nInput: [\"mirko\", \"stanko\", \"stanko\", \"stanko\"]\nOutput: 1\n*/",
      "es": "import Foundation\n\nfunc countUnfairReminders(_ children: [String]) -> Int {\n/**\nCuenta el número de veces que las madres son recordadas del comportamiento de un niño.\nUna madre es recordada si el número de porciones de comida que ha tomado un niño\n(excluyendo la actual) es mayor que el número total de porciones de comida\ntomadas por otros niños.\n\nEjemplo:\nInput: [\"mirko\", \"stanko\", \"stanko\", \"stanko\"]\nOutput: 1\n*/",
      "arb": "import Foundation\n\nfunc countUnfairReminders(_ children: [String]) -> Int {\n/**\nاحسب عدد المرات التي يتم فيها تذكير الأمهات بسلوك الطفل.\nيتم تذكير الأم إذا كان عدد حصص الطعام التي أخذها الطفل\n(باستثناء الحصة الحالية) أكبر من إجمالي عدد حصص الطعام\nالتي أخذها الأطفال الآخرون.\n\nمثال:\nInput: [\"mirko\", \"stanko\", \"stanko\", \"stanko\"]\nOutput: 1\n*/",
      "sw": "import Foundation\n\nfunc countUnfairReminders(_ children: [String]) -> Int {\n/**\nHesabu idadi ya mara ambazo mama anakumbushwa kuhusu tabia ya mtoto.\nMama anakumbushwa ikiwa idadi ya sehemu za chakula ambazo mtoto amechukua\n(ukiondoa ya sasa) ni kubwa kuliko jumla ya sehemu za chakula\nzilizochukuliwa na watoto wengine.\n\nMfano:\nInput: [\"mirko\", \"stanko\", \"stanko\", \"stanko\"]\nOutput: 1\n*/",
      "tr": "import Foundation\n\nfunc countUnfairReminders(_ children: [String]) -> Int {\n/**\nAnnelerin bir çocuğun davranışını hatırlatıldığı zamanların sayısını say.\nBir anne, bir çocuğun aldığı yemek porsiyonlarının sayısı\n(mevcut olan hariç) diğer çocuklar tarafından alınan toplam yemek porsiyonlarından\ndaha büyükse hatırlatılır.\n\nÖrnek:\nGirdi: [\"mirko\", \"stanko\", \"stanko\", \"stanko\"]\nÇıktı: 1\n*/",
      "vi": "import Foundation\n\nfunc countUnfairReminders(_ children: [String]) -> Int {\n/**\nĐếm số lần các bà mẹ được nhắc nhở về hành vi của một đứa trẻ.\nMột bà mẹ được nhắc nhở nếu số phần ăn mà một đứa trẻ đã lấy\n(ngoại trừ phần hiện tại) lớn hơn tổng số phần ăn\nmà các đứa trẻ khác đã lấy.\n\nVí dụ:\nInput: [\"mirko\", \"stanko\", \"stanko\", \"stanko\"]\nOutput: 1\n*/"
    },
    "prompt_bertscore": {
      "es": "0.9919586476541836",
      "arb": "0.9760163746419425",
      "sw": "0.988858027406229",
      "tr": "0.9797808176233156",
      "vi": "0.967155076083214"
    },
    "canonical_solution": "var foodCounts = [String: Int]()\nvar reminders = 0\n\nfor child in children {\nfoodCounts[child, default: 0] += 1\nlet otherFoodCount = children.filter { $0 != child }.map { foodCounts[$0, default: 0] }.reduce(0, +)\nif foodCounts[child, default: 0] > otherFoodCount+1 {\nreminders += 1\n}\n}\n\nreturn reminders\n}",
    "instruction": {
      "en": "func countUnfairReminders(_ children: [String]) -> Int {\nvar foodCounts = [String: Int]()\nvar reminders = 0\n\nfor child in children {\nfoodCounts[child, default: 0] += 1\nlet otherFoodCount = children.filter { $0 != child }.map { foodCounts[$0, default: 0] }.reduce(0, +)\nif foodCounts[child, default: 0] > otherFoodCount+1 {\nreminders += 1\n}\n}\n\nreturn reminders\n}\n\nProvide a concise natural language description (docstring) of the Swift code in English using at most 500 characters.",
      "es": "func countUnfairReminders(_ children: [String]) -> Int {\nvar foodCounts = [String: Int]()\nvar reminders = 0\n\nfor child in children {\nfoodCounts[child, default: 0] += 1\nlet otherFoodCount = children.filter { $0 != child }.map { foodCounts[$0, default: 0] }.reduce(0, +)\nif foodCounts[child, default: 0] > otherFoodCount+1 {\nreminders += 1\n}\n}\n\nreturn reminders\n}\n\nProporcione una descripción concisa en lenguaje natural (docstring) del código Swift en español utilizando un máximo de 500 caracteres.",
      "arb": "func countUnfairReminders(_ children: [String]) -> Int {\nvar foodCounts = [String: Int]()\nvar reminders = 0\n\nfor child in children {\nfoodCounts[child, default: 0] += 1\nlet otherFoodCount = children.filter { $0 != child }.map { foodCounts[$0, default: 0] }.reduce(0, +)\nif foodCounts[child, default: 0] > otherFoodCount+1 {\nreminders += 1\n}\n}\n\nreturn reminders\n}\n\nقدم وصفًا موجزًا بلغة طبيعية (docstring) لكود Swift باللغة العربية الفصحى باستخدام 500 حرف كحد أقصى.",
      "sw": "func countUnfairReminders(_ children: [String]) -> Int {\nvar foodCounts = [String: Int]()\nvar reminders = 0\n\nfor child in children {\nfoodCounts[child, default: 0] += 1\nlet otherFoodCount = children.filter { $0 != child }.map { foodCounts[$0, default: 0] }.reduce(0, +)\nif foodCounts[child, default: 0] > otherFoodCount+1 {\nreminders += 1\n}\n}\n\nreturn reminders\n}\n\nToa maelezo mafupi ya lugha asilia (docstring) ya msimbo wa Swift kwa Kiswahili kwa kutumia herufi zisizozidi 500.",
      "tr": "func countUnfairReminders(_ children: [String]) -> Int {\nvar foodCounts = [String: Int]()\nvar reminders = 0\n\nfor child in children {\nfoodCounts[child, default: 0] += 1\nlet otherFoodCount = children.filter { $0 != child }.map { foodCounts[$0, default: 0] }.reduce(0, +)\nif foodCounts[child, default: 0] > otherFoodCount+1 {\nreminders += 1\n}\n}\n\nreturn reminders\n}\n\nSwift kodunun işlevini açıklayan en fazla 500 karakterlik öz bir doğal dil açıklaması (docstring) sağlayın.",
      "vi": "func countUnfairReminders(_ children: [String]) -> Int {\nvar foodCounts = [String: Int]()\nvar reminders = 0\n\nfor child in children {\nfoodCounts[child, default: 0] += 1\nlet otherFoodCount = children.filter { $0 != child }.map { foodCounts[$0, default: 0] }.reduce(0, +)\nif foodCounts[child, default: 0] > otherFoodCount+1 {\nreminders += 1\n}\n}\n\nreturn reminders\n}\n\nCung cấp mô tả ngắn gọn bằng ngôn ngữ tự nhiên (docstring) cho mã Swift bằng tiếng Việt, sử dụng tối đa 500 ký tự."
    },
    "instruction_bertscore": {
      "es": "0.9676013985493994",
      "arb": "0.9017943587910168",
      "sw": "0.933792521393451",
      "tr": "0.8847876255668097",
      "vi": "0.9394594461643764"
    },
    "level": "",
    "test": "func testCountUnfairReminders() {\nassert(countUnfairReminders([\"mirko\", \"stanko\", \"stanko\", \"stanko\"]) == 1)\nassert(countUnfairReminders([\"a\", \"b\", \"b\", \"a\", \"a\", \"a\", \"c\", \"a\", \"b\", \"b\", \"c\", \"b\"]) == 0)\nassert(countUnfairReminders([\"a\", \"a\", \"a\", \"a\", \"a\", \"a\", \"a\", \"a\", \"a\", \"a\", \"a\"]) == 10)\nassert(countUnfairReminders([\"a\", \"b\", \"a\", \"b\", \"a\", \"b\", \"a\", \"b\", \"a\", \"b\", \"a\"]) == 0)\nprint(\"All test cases pass.\")\n}\n\ntestCountUnfairReminders()",
    "entry_point": "countUnfairReminders",
    "signature": "func countUnfairReminders(_ children: [String]) -> Int {",
    "docstring": {
      "en": "\nCount the number of times the moms are reminded of a child's behavior.\nA mom is reminded if the number of food portions a child has taken\n(excluding the current one) is greater than the total number of food portions\ntaken by other children.\n\nExample:\nInput: [\"mirko\", \"stanko\", \"stanko\", \"stanko\"]\nOutput: 1\n",
      "es": "Cuenta el número de veces que las mamás son recordadas del comportamiento de un niño. \nUna mamá es recordada si el número de porciones de comida que un niño ha tomado \n(excluyendo la actual) es mayor que el número total de porciones de comida \ntomadas por otros niños.\n\nEjemplo:\nEntrada: [\"mirko\", \"stanko\", \"stanko\", \"stanko\"]\nSalida: 1",
      "arb": "احسب عدد المرات التي يتم فيها تذكير الأمهات بسلوك الطفل. \nيتم تذكير الأم إذا كان عدد حصص الطعام التي أخذها الطفل \n(باستثناء الحصة الحالية) أكبر من العدد الإجمالي لحصص الطعام \nالتي أخذها الأطفال الآخرون.\n\nمثال:\nInput: [\"mirko\", \"stanko\", \"stanko\", \"stanko\"]\nOutput: 1",
      "sw": "Hesabu idadi ya mara ambazo mama hukumbushwa kuhusu tabia ya mtoto.\nMama hukumbushwa ikiwa idadi ya sehemu za chakula ambazo mtoto amechukua\n(ukiondoa ya sasa) ni kubwa kuliko idadi ya jumla ya sehemu za chakula\nzilizochukuliwa na watoto wengine.\n\nMfano:\nIngizo: [\"mirko\", \"stanko\", \"stanko\", \"stanko\"]\nMatokeo: 1",
      "tr": "Bir çocuğun davranışı hakkında annelere kaç kez hatırlatma yapıldığını sayın.\nBir anne, bir çocuğun aldığı yemek porsiyonlarının sayısı (mevcut olan hariç) diğer çocukların aldığı toplam yemek porsiyonlarından fazla olduğunda hatırlatılır.\n\nÖrnek:\nGirdi: [\"mirko\", \"stanko\", \"stanko\", \"stanko\"]\nÇıktı: 1",
      "vi": "Đếm số lần các bà mẹ được nhắc nhở về hành vi của một đứa trẻ.  \nMột bà mẹ được nhắc nhở nếu số phần thức ăn mà một đứa trẻ đã lấy  \n(ngoại trừ phần hiện tại) lớn hơn tổng số phần thức ăn  \nđược lấy bởi các đứa trẻ khác.\n\nVí dụ:  \nInput: [\"mirko\", \"stanko\", \"stanko\", \"stanko\"]  \nOutput: 1  "
    },
    "docstring_bertscore": {
      "es": "0.9951500419862711",
      "arb": "0.9744408384595737",
      "sw": "0.9846019742317944",
      "tr": "0.9534567304855239",
      "vi": "0.9839913844404932"
    }
  },
  {
    "task_id": "Swift/27",
    "prompt": {
      "en": "import Foundation\n\nfunc remainingApples(_ m: Int, _ t: Int, _ s: Int) -> Int {\n\n/**\nCalculate the number of remaining full apples after a certain amount of time.\nEating an apple takes a certain amount of time and you can only eat one apple at a time.\nThe function takes three parameters:\n- m: the total number of apples.\n- t: the time it takes to eat one apple.\n- s: the total time passed.\nThe function returns the number of full apples that remain.\n>>> remainingApples(50, 10, 200)\n30\n>>> remainingApples(100, 5, 1000)\n0\n*/",
      "es": "import Foundation\n\nfunc remainingApples(_ m: Int, _ t: Int, _ s: Int) -> Int {\n\n/**\nCalcular el número de manzanas completas restantes después de un cierto período de tiempo.\nComer una manzana toma una cierta cantidad de tiempo y solo puedes comer una manzana a la vez.\nLa función toma tres parámetros:\n- m: el número total de manzanas.\n- t: el tiempo que lleva comer una manzana.\n- s: el tiempo total transcurrido.\nLa función devuelve el número de manzanas completas que quedan.\n>>> remainingApples(50, 10, 200)\n30\n>>> remainingApples(100, 5, 1000)\n0\n*/",
      "arb": "import Foundation\n\nfunc remainingApples(_ m: Int, _ t: Int, _ s: Int) -> Int {\n\n/**\nاحسب عدد التفاح الكامل المتبقي بعد مرور فترة زمنية معينة.\nتناول تفاحة يستغرق وقتًا معينًا ويمكنك تناول تفاحة واحدة فقط في كل مرة.\nتأخذ الدالة ثلاثة معلمات:\n- m: العدد الإجمالي للتفاح.\n- t: الوقت الذي يستغرقه تناول تفاحة واحدة.\n- s: إجمالي الوقت المنقضي.\nتعيد الدالة عدد التفاح الكامل المتبقي.\n>>> remainingApples(50, 10, 200)\n30\n>>> remainingApples(100, 5, 1000)\n0\n*/",
      "sw": "import Foundation\n\nfunc remainingApples(_ m: Int, _ t: Int, _ s: Int) -> Int {\n\n/**\nHesabu idadi ya maapulo yaliyobaki kamili baada ya muda fulani kupita.\nKula tunda moja la apulo huchukua muda fulani na unaweza kula apulo moja tu kwa wakati mmoja.\nKazi inachukua vigezo vitatu:\n- m: jumla ya idadi ya maapulo.\n- t: muda unaochukua kula apulo moja.\n- s: muda wote uliopita.\nKazi inarudisha idadi ya maapulo kamili yaliyobaki.\n>>> remainingApples(50, 10, 200)\n30\n>>> remainingApples(100, 5, 1000)\n0\n*/",
      "tr": "import Foundation\n\nfunc remainingApples(_ m: Int, _ t: Int, _ s: Int) -> Int {\n\n/**\nBelirli bir süre geçtikten sonra kalan bütün elma sayısını hesapla.\nBir elmayı yemek belirli bir zaman alır ve aynı anda sadece bir elma yiyebilirsiniz.\nFonksiyon üç parametre alır:\n- m: toplam elma sayısı.\n- t: bir elmayı yemek için geçen süre.\n- s: geçen toplam süre.\nFonksiyon, kalan bütün elma sayısını döndürür.\n>>> remainingApples(50, 10, 200)\n30\n>>> remainingApples(100, 5, 1000)\n0\n*/",
      "vi": "import Foundation\n\nfunc remainingApples(_ m: Int, _ t: Int, _ s: Int) -> Int {\n\n/**\nTính số lượng táo nguyên còn lại sau một khoảng thời gian nhất định.\nĂn một quả táo mất một khoảng thời gian nhất định và bạn chỉ có thể ăn một quả táo một lần.\nHàm nhận ba tham số:\n- m: tổng số lượng táo.\n- t: thời gian để ăn một quả táo.\n- s: tổng thời gian đã trôi qua.\nHàm trả về số lượng táo nguyên còn lại.\n>>> remainingApples(50, 10, 200)\n30\n>>> remainingApples(100, 5, 1000)\n0\n*/"
    },
    "prompt_bertscore": {
      "es": "0.981633443187228",
      "arb": "0.9812345933821099",
      "sw": "0.9691910374888216",
      "tr": "0.9616317610777768",
      "vi": "0.9640383667743956"
    },
    "canonical_solution": "let eatenApples = s / t\nlet remainingApples = m - eatenApples\nreturn max(0, remainingApples)\n}",
    "instruction": {
      "en": "func remainingApples(_ m: Int, _ t: Int, _ s: Int) -> Int {\nlet eatenApples = s / t\nlet remainingApples = m - eatenApples\nreturn max(0, remainingApples)\n}\n\nProvide a concise natural language description (docstring) of the Swift code in English using at most 500 characters.",
      "es": "func remainingApples(_ m: Int, _ t: Int, _ s: Int) -> Int {\nlet eatenApples = s / t\nlet remainingApples = m - eatenApples\nreturn max(0, remainingApples)\n}\n\nProporcione una descripción concisa en lenguaje natural (docstring) del código Swift en español utilizando un máximo de 500 caracteres.",
      "arb": "func remainingApples(_ m: Int, _ t: Int, _ s: Int) -> Int {\nlet eatenApples = s / t\nlet remainingApples = m - eatenApples\nreturn max(0, remainingApples)\n}\n\nقدم وصفًا موجزًا بلغة طبيعية (docstring) لكود Swift باللغة العربية الفصحى باستخدام ما لا يزيد عن 500 حرف.",
      "sw": "func remainingApples(_ m: Int, _ t: Int, _ s: Int) -> Int {\nlet eatenApples = s / t\nlet remainingApples = m - eatenApples\nreturn max(0, remainingApples)\n}\n\nToa maelezo mafupi ya lugha asilia (docstring) ya msimbo wa Swift kwa Kiswahili kwa kutumia herufi zisizozidi 500.",
      "tr": "func remainingApples(_ m: Int, _ t: Int, _ s: Int) -> Int {\nlet eatenApples = s / t\nlet remainingApples = m - eatenApples\nreturn max(0, remainingApples)\n}\n\nSwift kodunun işlevini açıklayan kısa bir doğal dil açıklaması (docstring) sağlayın. Açıklama, Türkçe olarak en fazla 500 karakter kullanılarak yazılmalıdır.",
      "vi": "func remainingApples(_ m: Int, _ t: Int, _ s: Int) -> Int {\nlet eatenApples = s / t\nlet remainingApples = m - eatenApples\nreturn max(0, remainingApples)\n}\n\nCung cấp mô tả ngắn gọn bằng ngôn ngữ tự nhiên (docstring) cho mã Swift bằng tiếng Việt, sử dụng tối đa 500 ký tự."
    },
    "instruction_bertscore": {
      "es": "0.9676013985493994",
      "arb": "0.8880608556158835",
      "sw": "0.942496901951162",
      "tr": "0.8714851503185221",
      "vi": "0.9054771646857847"
    },
    "level": "",
    "test": "func check(_ remainingApples: (Int, Int, Int) -> Int) {\nassert(remainingApples(50, 10, 200) == 30)\nassert(remainingApples(100, 5, 1000) == 0)\nassert(remainingApples(75, 15, 300) == 55)\nassert(remainingApples(20, 20, 400) == 0)\nassert(remainingApples(30, 10, 300) == 0)\nassert(remainingApples(40, 15, 600) == 0)\nassert(remainingApples(60, 10, 600) == 0)\n}\n\ncheck(remainingApples)",
    "entry_point": "remainingApples",
    "signature": "func remainingApples(_ m: Int, _ t: Int, _ s: Int) -> Int {",
    "docstring": {
      "en": "\nCalculate the number of remaining full apples after a certain amount of time.\nEating an apple takes a certain amount of time and you can only eat one apple at a time.\nThe function takes three parameters:\n- m: the total number of apples.\n- t: the time it takes to eat one apple.\n- s: the total time passed.\nThe function returns the number of full apples that remain.\n>>> remainingApples(50, 10, 200)\n30\n>>> remainingApples(100, 5, 1000)\n0\n",
      "es": "Calcular el número de manzanas enteras restantes después de un cierto período de tiempo.\nComer una manzana toma una cierta cantidad de tiempo y solo se puede comer una manzana a la vez.\nLa función toma tres parámetros:\n- m: el número total de manzanas.\n- t: el tiempo que toma comer una manzana.\n- s: el tiempo total transcurrido.\nLa función devuelve el número de manzanas enteras que quedan.\n>>> remainingApples(50, 10, 200)\n30\n>>> remainingApples(100, 5, 1000)\n0",
      "arb": "احسب عدد التفاح الكامل المتبقي بعد مرور فترة زمنية معينة. \nيستغرق أكل تفاحة وقتًا معينًا ولا يمكنك أكل أكثر من تفاحة واحدة في نفس الوقت. \nتأخذ الدالة ثلاثة معلمات:\n- m: العدد الإجمالي للتفاح.\n- t: الوقت الذي يستغرقه أكل تفاحة واحدة.\n- s: إجمالي الوقت المنقضي.\nتعيد الدالة عدد التفاح الكامل المتبقي.\n>>> remainingApples(50, 10, 200)\n30\n>>> remainingApples(100, 5, 1000)\n0",
      "sw": "Hesabu idadi ya tufaha kamili zilizobaki baada ya muda fulani.\nKula tufaha moja kunachukua muda fulani na unaweza kula tufaha moja tu kwa wakati mmoja.\nKazi inachukua vigezo vitatu:\n- m: jumla ya idadi ya tufaha.\n- t: muda unaochukua kula tufaha moja.\n- s: jumla ya muda uliopita.\nKazi inarudisha idadi ya tufaha kamili zilizobaki.\n>>> remainingApples(50, 10, 200)\n30\n>>> remainingApples(100, 5, 1000)\n0",
      "tr": "Kalan tam elma sayısını belirli bir süre sonra hesaplayın.\nBir elmayı yemek belirli bir zaman alır ve aynı anda sadece bir elma yiyebilirsiniz.\nFonksiyon üç parametre alır:\n- m: toplam elma sayısı.\n- t: bir elmayı yemek için geçen süre.\n- s: geçen toplam süre.\nFonksiyon, kalan tam elma sayısını döndürür.\n>>> remainingApples(50, 10, 200)\n30\n>>> remainingApples(100, 5, 1000)\n0",
      "vi": "Tính số lượng táo nguyên còn lại sau một khoảng thời gian nhất định. Ăn một quả táo mất một khoảng thời gian nhất định và bạn chỉ có thể ăn một quả táo mỗi lần. Hàm nhận ba tham số: \n- m: tổng số táo. \n- t: thời gian cần để ăn một quả táo. \n- s: tổng thời gian đã trôi qua. Hàm trả về số lượng táo nguyên còn lại. \n>>> remainingApples(50, 10, 200)\n30\n>>> remainingApples(100, 5, 1000)\n0"
    },
    "docstring_bertscore": {
      "es": "0.9679277482654397",
      "arb": "0.9558444662959443",
      "sw": "0.9622451316944126",
      "tr": "0.9423121756967995",
      "vi": "0.9605458487846591"
    }
  },
  {
    "task_id": "Swift/28",
    "prompt": {
      "en": "import Foundation\n\nfunc checkLikes(_ x: Int) -> (Int, Int, Int, Int) {\n/**\nChecks if the given integer is liked by the four individuals:\n- Person A likes the integer if it is both even and between 4 and 12 (inclusive).\n- Person U likes the integer if it is either even or between 4 and 12 (inclusive).\n- Person H likes the integer if it is exactly one of the two properties (even or between 4 and 12).\n- Person G likes the integer if it does not have both of the properties (even and between 4 and 12).\n\n>>> checkLikes(12)\n(0, 1, 1, 0)\n*/",
      "es": "import Foundation\n\nfunc checkLikes(_ x: Int) -> (Int, Int, Int, Int) {\n/**\nVerifica si el entero dado es del agrado de las cuatro personas:\n- A la Persona A le gusta el entero si es par y está entre 4 y 12 (inclusive).\n- A la Persona U le gusta el entero si es par o está entre 4 y 12 (inclusive).\n- A la Persona H le gusta el entero si tiene exactamente una de las dos propiedades (par o entre 4 y 12).\n- A la Persona G le gusta el entero si no tiene ambas propiedades (par y entre 4 y 12).\n\n>>> checkLikes(12)\n(0, 1, 1, 0)\n*/",
      "arb": "import Foundation\n\nfunc checkLikes(_ x: Int) -> (Int, Int, Int, Int) {\n/**\nيتحقق مما إذا كان العدد الصحيح المعطى محبوبًا من قبل الأفراد الأربعة:\n- الشخص A يحب العدد الصحيح إذا كان زوجيًا وبين 4 و 12 (شامل).\n- الشخص U يحب العدد الصحيح إذا كان إما زوجيًا أو بين 4 و 12 (شامل).\n- الشخص H يحب العدد الصحيح إذا كان يملك واحدة فقط من الخاصيتين (زوجي أو بين 4 و 12).\n- الشخص G يحب العدد الصحيح إذا لم يكن لديه كلتا الخاصيتين (زوجي وبين 4 و 12).\n\n>>> checkLikes(12)\n(0, 1, 1, 0)\n*/",
      "sw": "import Foundation\n\nfunc checkLikes(_ x: Int) -> (Int, Int, Int, Int) {\n/**\nHukagua kama namba iliyotolewa inapendwa na watu wanne:\n- Mtu A anapenda namba hiyo ikiwa ni shufwa na iko kati ya 4 na 12 (pamoja na 4 na 12).\n- Mtu U anapenda namba hiyo ikiwa ni shufwa au iko kati ya 4 na 12 (pamoja na 4 na 12).\n- Mtu H anapenda namba hiyo ikiwa ina sifa moja tu kati ya mbili (shufwa au iko kati ya 4 na 12).\n- Mtu G anapenda namba hiyo ikiwa haina sifa zote mbili (shufwa na iko kati ya 4 na 12).\n\n>>> checkLikes(12)\n(0, 1, 1, 0)\n*/",
      "tr": "import Foundation\n\nfunc checkLikes(_ x: Int) -> (Int, Int, Int, Int) {\n/**\nVerilen tam sayının dört kişi tarafından beğenilip beğenilmediğini kontrol eder:\n- Kişi A, tam sayı hem çift hem de 4 ile 12 arasında (dahil) ise tam sayıyı beğenir.\n- Kişi U, tam sayı ya çift ya da 4 ile 12 arasında (dahil) ise tam sayıyı beğenir.\n- Kişi H, tam sayı tam olarak iki özellikten birine sahipse (çift veya 4 ile 12 arasında) tam sayıyı beğenir.\n- Kişi G, tam sayı her iki özelliğe de sahip değilse (çift ve 4 ile 12 arasında) tam sayıyı beğenir.\n\n>>> checkLikes(12)\n(0, 1, 1, 0)\n*/",
      "vi": "import Foundation\n\nfunc checkLikes(_ x: Int) -> (Int, Int, Int, Int) {\n/**\nKiểm tra xem số nguyên đã cho có được bốn người yêu thích hay không:\n- Người A thích số nguyên nếu nó vừa chẵn và nằm trong khoảng từ 4 đến 12 (bao gồm cả 4 và 12).\n- Người U thích số nguyên nếu nó hoặc là chẵn hoặc nằm trong khoảng từ 4 đến 12 (bao gồm cả 4 và 12).\n- Người H thích số nguyên nếu nó chính xác có một trong hai thuộc tính (chẵn hoặc nằm trong khoảng từ 4 đến 12).\n- Người G thích số nguyên nếu nó không có cả hai thuộc tính (chẵn và nằm trong khoảng từ 4 đến 12).\n\n>>> checkLikes(12)\n(0, 1, 1, 0)\n*/"
    },
    "prompt_bertscore": {
      "es": "0.9653481355069397",
      "arb": "0.9624046318903836",
      "sw": "0.9384700682364416",
      "tr": "0.9781085484453829",
      "vi": "0.927785938670956"
    },
    "canonical_solution": "let isEven = x % 2 == 0\nlet isBetween4And12 = x > 4 && x < 12\nlet isExactlyOneProperty = isEven != isBetween4And12\nlet isNeitherProperty = !isEven && !isBetween4And12\n\nlet a = isEven && isBetween4And12 ? 1 : 0\nlet u = isEven || isBetween4And12 ? 1 : 0\nlet h = isExactlyOneProperty ? 1 : 0\nlet g = isNeitherProperty ? 1 : 0\n\nreturn (a, u, h, g)\n}",
    "instruction": {
      "en": "func checkLikes(_ x: Int) -> (Int, Int, Int, Int) {\nlet isEven = x % 2 == 0\nlet isBetween4And12 = x > 4 && x < 12\nlet isExactlyOneProperty = isEven != isBetween4And12\nlet isNeitherProperty = !isEven && !isBetween4And12\n\nlet a = isEven && isBetween4And12 ? 1 : 0\nlet u = isEven || isBetween4And12 ? 1 : 0\nlet h = isExactlyOneProperty ? 1 : 0\nlet g = isNeitherProperty ? 1 : 0\n\nreturn (a, u, h, g)\n}\n\nProvide a concise natural language description (docstring) of the Swift code in English using at most 500 characters.",
      "es": "func checkLikes(_ x: Int) -> (Int, Int, Int, Int) {\nlet isEven = x % 2 == 0\nlet isBetween4And12 = x > 4 && x < 12\nlet isExactlyOneProperty = isEven != isBetween4And12\nlet isNeitherProperty = !isEven && !isBetween4And12\n\nlet a = isEven && isBetween4And12 ? 1 : 0\nlet u = isEven || isBetween4And12 ? 1 : 0\nlet h = isExactlyOneProperty ? 1 : 0\nlet g = isNeitherProperty ? 1 : 0\n\nreturn (a, u, h, g)\n}\n\nProporcione una descripción concisa en lenguaje natural (docstring) del código Swift en español utilizando un máximo de 500 caracteres.",
      "arb": "func checkLikes(_ x: Int) -> (Int, Int, Int, Int) {\nlet isEven = x % 2 == 0\nlet isBetween4And12 = x > 4 && x < 12\nlet isExactlyOneProperty = isEven != isBetween4And12\nlet isNeitherProperty = !isEven && !isBetween4And12\n\nlet a = isEven && isBetween4And12 ? 1 : 0\nlet u = isEven || isBetween4And12 ? 1 : 0\nlet h = isExactlyOneProperty ? 1 : 0\nlet g = isNeitherProperty ? 1 : 0\n\nreturn (a, u, h, g)\n}\n\nقدم وصفًا موجزًا بلغة طبيعية (docstring) لكود Swift باللغة العربية الفصحى باستخدام ما لا يزيد عن 500 حرف.",
      "sw": "func checkLikes(_ x: Int) -> (Int, Int, Int, Int) {\nlet isEven = x % 2 == 0\nlet isBetween4And12 = x > 4 && x < 12\nlet isExactlyOneProperty = isEven != isBetween4And12\nlet isNeitherProperty = !isEven && !isBetween4And12\n\nlet a = isEven && isBetween4And12 ? 1 : 0\nlet u = isEven || isBetween4And12 ? 1 : 0\nlet h = isExactlyOneProperty ? 1 : 0\nlet g = isNeitherProperty ? 1 : 0\n\nreturn (a, u, h, g)\n}\n\nToa maelezo mafupi ya lugha asilia (docstring) ya msimbo wa Swift kwa Kiswahili kwa kutumia herufi zisizozidi 500.",
      "tr": "func checkLikes(_ x: Int) -> (Int, Int, Int, Int) {\nlet isEven = x % 2 == 0\nlet isBetween4And12 = x > 4 && x < 12\nlet isExactlyOneProperty = isEven != isBetween4And12\nlet isNeitherProperty = !isEven && !isBetween4And12\n\nlet a = isEven && isBetween4And12 ? 1 : 0\nlet u = isEven || isBetween4And12 ? 1 : 0\nlet h = isExactlyOneProperty ? 1 : 0\nlet g = isNeitherProperty ? 1 : 0\n\nreturn (a, u, h, g)\n}\n\nSwift kodunun işlevselliğini açıklayan, en fazla 500 karakter uzunluğunda özlü bir doğal dil açıklaması (docstring) sağlayın.",
      "vi": "func checkLikes(_ x: Int) -> (Int, Int, Int, Int) {\nlet isEven = x % 2 == 0\nlet isBetween4And12 = x > 4 && x < 12\nlet isExactlyOneProperty = isEven != isBetween4And12\nlet isNeitherProperty = !isEven && !isBetween4And12\n\nlet a = isEven && isBetween4And12 ? 1 : 0\nlet u = isEven || isBetween4And12 ? 1 : 0\nlet h = isExactlyOneProperty ? 1 : 0\nlet g = isNeitherProperty ? 1 : 0\n\nreturn (a, u, h, g)\n}\n\nCung cấp mô tả ngắn gọn bằng ngôn ngữ tự nhiên (docstring) cho mã Swift bằng tiếng Việt, sử dụng tối đa 500 ký tự."
    },
    "instruction_bertscore": {
      "es": "0.9676013985493994",
      "arb": "0.8880608556158835",
      "sw": "0.942496901951162",
      "tr": "0.8731472893470221",
      "vi": "0.9054771646857847"
    },
    "level": "",
    "test": "func testCheckLikes(_ checkLikes: (Int) -> (Int, Int, Int, Int)) {\nassert(checkLikes(12) == (0, 1, 1, 0))\nassert(checkLikes(5) == (0, 1, 1, 0))\nassert(checkLikes(6) == (1, 1, 0, 0))\nassert(checkLikes(3) == (0, 0, 0, 1))\nassert(checkLikes(13) == (0, 0, 0, 1))\nassert(checkLikes(4) == (0, 1, 1, 0))\nassert(checkLikes(11) == (0, 1, 1, 0))\nassert(checkLikes(7) == (0, 1, 1, 0))\nassert(checkLikes(2) == (0, 1, 1, 0))\n}\n\ntestCheckLikes(checkLikes)",
    "entry_point": "checkLikes",
    "signature": "func checkLikes(_ x: Int) -> (Int, Int, Int, Int) {",
    "docstring": {
      "en": "\nChecks if the given integer is liked by the four individuals:\n- Person A likes the integer if it is both even and between 4 and 12 (inclusive).\n- Person U likes the integer if it is either even or between 4 and 12 (inclusive).\n- Person H likes the integer if it is exactly one of the two properties (even or between 4 and 12).\n- Person G likes the integer if it does not have both of the properties (even and between 4 and 12).\n\n>>> checkLikes(12)\n(0, 1, 1, 0)\n",
      "es": "Verifica si el entero dado es del agrado de las cuatro personas:\n- A la Persona A le gusta el entero si es par y está entre 4 y 12 (inclusive).\n- A la Persona U le gusta el entero si es par o está entre 4 y 12 (inclusive).\n- A la Persona H le gusta el entero si tiene exactamente una de las dos propiedades (par o entre 4 y 12).\n- A la Persona G le gusta el entero si no tiene ambas propiedades (par y entre 4 y 12).\n\n>>> checkLikes(12)\n(0, 1, 1, 0)",
      "arb": "يتحقق مما إذا كان العدد الصحيح المعطى محبوبًا من قبل الأفراد الأربعة:\n- الشخص A يحب العدد الصحيح إذا كان زوجيًا وبين 4 و 12 (شامل).\n- الشخص U يحب العدد الصحيح إذا كان إما زوجيًا أو بين 4 و 12 (شامل).\n- الشخص H يحب العدد الصحيح إذا كان يملك بالضبط واحدة من الخاصيتين (زوجي أو بين 4 و 12).\n- الشخص G يحب العدد الصحيح إذا لم يكن لديه كلتا الخاصيتين (زوجي وبين 4 و 12).\n\n>>> checkLikes(12)\n(0, 1, 1, 0)",
      "sw": "Hukagua ikiwa nambari kamili iliyotolewa inapendwa na watu wanne:\n- Mtu A anapenda nambari hiyo ikiwa ni shufwa na iko kati ya 4 na 12 (pamoja).\n- Mtu U anapenda nambari hiyo ikiwa ni shufwa au iko kati ya 4 na 12 (pamoja).\n- Mtu H anapenda nambari hiyo ikiwa ina sifa moja tu kati ya hizi mbili (shufwa au kati ya 4 na 12).\n- Mtu G anapenda nambari hiyo ikiwa haina sifa zote mbili (shufwa na kati ya 4 na 12).\n\n>>> checkLikes(12)\n(0, 1, 1, 0)",
      "tr": "Verilen tam sayının dört kişi tarafından beğenilip beğenilmediğini kontrol eder:\n- Kişi A, tam sayı hem çift hem de 4 ile 12 arasında (dahil) ise tam sayıyı beğenir.\n- Kişi U, tam sayı ya çift ya da 4 ile 12 arasında (dahil) ise tam sayıyı beğenir.\n- Kişi H, tam sayı tam olarak iki özelliğin (çift veya 4 ile 12 arasında) birine sahipse tam sayıyı beğenir.\n- Kişi G, tam sayı her iki özelliğe de (çift ve 4 ile 12 arasında) sahip değilse tam sayıyı beğenir.\n\n>>> checkLikes(12)\n(0, 1, 1, 0)",
      "vi": "Kiểm tra xem số nguyên đã cho có được bốn cá nhân yêu thích hay không:\n- Người A thích số nguyên nếu nó vừa chẵn vừa nằm trong khoảng từ 4 đến 12 (bao gồm cả 4 và 12).\n- Người U thích số nguyên nếu nó chẵn hoặc nằm trong khoảng từ 4 đến 12 (bao gồm cả 4 và 12).\n- Người H thích số nguyên nếu nó có chính xác một trong hai thuộc tính (chẵn hoặc nằm trong khoảng từ 4 đến 12).\n- Người G thích số nguyên nếu nó không có cả hai thuộc tính (chẵn và nằm trong khoảng từ 4 đến 12).\n\n>>> checkLikes(12)\n(0, 1, 1, 0)"
    },
    "docstring_bertscore": {
      "es": "0.9715763897346695",
      "arb": "0.9776673903691044",
      "sw": "0.9227665489422044",
      "tr": "0.9547273690330041",
      "vi": "0.9088103811099311"
    }
  },
  {
    "task_id": "Swift/29",
    "prompt": {
      "en": "import Foundation\n\nfunc isLeapYear(_ year: Int) -> Int {\n/**\nDetermine if a given year is a leap year.\nA leap year is exactly divisible by 4 except for end-of-century years which must be divisible by 400.\nThis means that the year 2000 was a leap year, although 1900 was not.\n>>> isLeapYear(1926)\n0\n>>> isLeapYear(1900)\n0\n>>> isLeapYear(2000)\n1\n>>> isLeapYear(1996)\n1\n*/",
      "es": "import Foundation\n\nfunc isLeapYear(_ year: Int) -> Int {\n/**\nDeterminar si un año dado es un año bisiesto.\nUn año bisiesto es exactamente divisible por 4, excepto los años de fin de siglo que deben ser divisibles por 400.\nEsto significa que el año 2000 fue un año bisiesto, aunque 1900 no lo fue.\n>>> isLeapYear(1926)\n0\n>>> isLeapYear(1900)\n0\n>>> isLeapYear(2000)\n1\n>>> isLeapYear(1996)\n1\n*/",
      "arb": "import Foundation\n\nfunc isLeapYear(_ year: Int) -> Int {\n/**\nتحديد ما إذا كانت السنة المعطاة سنة كبيسة.\nالسنة الكبيسة تقبل القسمة تمامًا على 4 باستثناء السنوات التي تنتهي بالقرن والتي يجب أن تقبل القسمة على 400.\nهذا يعني أن سنة 2000 كانت سنة كبيسة، على الرغم من أن سنة 1900 لم تكن كذلك.\n>>> isLeapYear(1926)\n0\n>>> isLeapYear(1900)\n0\n>>> isLeapYear(2000)\n1\n>>> isLeapYear(1996)\n1\n*/",
      "sw": "import Foundation\n\nfunc isLeapYear(_ year: Int) -> Int {\n/**\nTambua ikiwa mwaka uliotolewa ni mwaka wa kuruka.\nMwaka wa kuruka unagawanyika kwa 4 isipokuwa kwa miaka ya mwisho wa karne ambayo lazima yagawanyike kwa 400.\nHii inamaanisha kuwa mwaka 2000 ulikuwa mwaka wa kuruka, ingawa 1900 haukuwa.\n>>> isLeapYear(1926)\n0\n>>> isLeapYear(1900)\n0\n>>> isLeapYear(2000)\n1\n>>> isLeapYear(1996)\n1\n*/",
      "tr": "import Foundation\n\nfunc isLeapYear(_ year: Int) -> Int {\n/**\nBelirtilen bir yılın artık yıl olup olmadığını belirleyin.\nBir artık yıl, 4 ile tam bölünebilir, ancak yüzyıl sonu yılları 400 ile bölünebilir olmalıdır.\nBu, 2000 yılının artık yıl olduğu anlamına gelir, ancak 1900 yılı değildir.\n>>> isLeapYear(1926)\n0\n>>> isLeapYear(1900)\n0\n>>> isLeapYear(2000)\n1\n>>> isLeapYear(1996)\n1\n*/",
      "vi": "import Foundation\n\nfunc isLeapYear(_ year: Int) -> Int {\n/**\nXác định xem một năm cho trước có phải là năm nhuận hay không.\nMột năm nhuận chia hết cho 4, ngoại trừ những năm cuối thế kỷ phải chia hết cho 400.\nĐiều này có nghĩa là năm 2000 là năm nhuận, mặc dù năm 1900 thì không.\n>>> isLeapYear(1926)\n0\n>>> isLeapYear(1900)\n0\n>>> isLeapYear(2000)\n1\n>>> isLeapYear(1996)\n1\n*/"
    },
    "prompt_bertscore": {
      "es": "0.9980685181748168",
      "arb": "0.9718054105640028",
      "sw": "0.9917870310049695",
      "tr": "0.9649240596434301",
      "vi": "0.9861153391048992"
    },
    "canonical_solution": "if year % 4 == 0 {\nif year % 100 == 0 {\nif year % 400 == 0 {\nreturn 1\n} else {\nreturn 0\n}\n} else {\nreturn 1\n}\n} else {\nreturn 0\n}\n}",
    "instruction": {
      "en": "func isLeapYear(_ year: Int) -> Int {\nif year % 4 == 0 {\nif year % 100 == 0 {\nif year % 400 == 0 {\nreturn 1\n} else {\nreturn 0\n}\n} else {\nreturn 1\n}\n} else {\nreturn 0\n}\n}\n\nProvide a concise natural language description (docstring) of the Swift code in English using at most 500 characters.",
      "es": "func isLeapYear(_ year: Int) -> Int {\nif year % 4 == 0 {\nif year % 100 == 0 {\nif year % 400 == 0 {\nreturn 1\n} else {\nreturn 0\n}\n} else {\nreturn 1\n}\n} else {\nreturn 0\n}\n}\n\nProporcione una descripción concisa en lenguaje natural (docstring) del código Swift en español utilizando como máximo 500 caracteres.",
      "arb": "func isLeapYear(_ year: Int) -> Int {\nif year % 4 == 0 {\nif year % 100 == 0 {\nif year % 400 == 0 {\nreturn 1\n} else {\nreturn 0\n}\n} else {\nreturn 1\n}\n} else {\nreturn 0\n}\n}\n\nقم بتقديم وصف موجز بلغة طبيعية (docstring) لكود Swift باللغة العربية الفصحى باستخدام ما لا يزيد عن 500 حرف.",
      "sw": "func isLeapYear(_ year: Int) -> Int {\nif year % 4 == 0 {\nif year % 100 == 0 {\nif year % 400 == 0 {\nreturn 1\n} else {\nreturn 0\n}\n} else {\nreturn 1\n}\n} else {\nreturn 0\n}\n}\n\nToa maelezo mafupi ya lugha ya asili (docstring) ya msimbo wa Swift kwa Kiswahili kwa kutumia herufi zisizozidi 500.",
      "tr": "func isLeapYear(_ year: Int) -> Int {\nif year % 4 == 0 {\nif year % 100 == 0 {\nif year % 400 == 0 {\nreturn 1\n} else {\nreturn 0\n}\n} else {\nreturn 1\n}\n} else {\nreturn 0\n}\n}\n\nSwift kodunun Türkçe açıklamasını en fazla 500 karakter kullanarak doğal dilde sağlayın.",
      "vi": "func isLeapYear(_ year: Int) -> Int {\nif year % 4 == 0 {\nif year % 100 == 0 {\nif year % 400 == 0 {\nreturn 1\n} else {\nreturn 0\n}\n} else {\nreturn 1\n}\n} else {\nreturn 0\n}\n}\n\nCung cấp mô tả ngắn gọn bằng ngôn ngữ tự nhiên (docstring) cho mã Swift bằng tiếng Việt, sử dụng tối đa 500 ký tự."
    },
    "instruction_bertscore": {
      "es": "0.9676013985493994",
      "arb": "0.9081934351464368",
      "sw": "0.942496901951162",
      "tr": "0.8359944697263515",
      "vi": "0.9054771646857847"
    },
    "level": "",
    "test": "func check(_ isLeapYear: (Int) -> Int) {\nassert(isLeapYear(1926) == 0)\nassert(isLeapYear(1900) == 0)\nassert(isLeapYear(2000) == 1)\nassert(isLeapYear(1996) == 1)\nassert(isLeapYear(2020) == 1)\nassert(isLeapYear(2021) == 0)\nassert(isLeapYear(2022) == 0)\nassert(isLeapYear(2023) == 0)\nassert(isLeapYear(2024) == 1)\n}\n\ncheck(isLeapYear)",
    "entry_point": "isLeapYear",
    "signature": "func isLeapYear(_ year: Int) -> Int {",
    "docstring": {
      "en": "\nDetermine if a given year is a leap year.\nA leap year is exactly divisible by 4 except for end-of-century years which must be divisible by 400.\nThis means that the year 2000 was a leap year, although 1900 was not.\n>>> isLeapYear(1926)\n0\n>>> isLeapYear(1900)\n0\n>>> isLeapYear(2000)\n1\n>>> isLeapYear(1996)\n1\n",
      "es": "Determinar si un año dado es un año bisiesto.  \nUn año bisiesto es exactamente divisible por 4, excepto los años de fin de siglo que deben ser divisibles por 400.  \nEsto significa que el año 2000 fue un año bisiesto, aunque 1900 no lo fue.  \n>>> isLeapYear(1926)  \n0  \n>>> isLeapYear(1900)  \n0  \n>>> isLeapYear(2000)  \n1  \n>>> isLeapYear(1996)  \n1  ",
      "arb": "تحديد ما إذا كانت السنة المعطاة سنة كبيسة.\nالسنة الكبيسة تقبل القسمة تمامًا على 4 باستثناء السنوات التي تنتهي بالقرن والتي يجب أن تكون قابلة للقسمة على 400.\nهذا يعني أن سنة 2000 كانت سنة كبيسة، على الرغم من أن 1900 لم تكن كذلك.\n>>> isLeapYear(1926)\n0\n>>> isLeapYear(1900)\n0\n>>> isLeapYear(2000)\n1\n>>> isLeapYear(1996)\n1",
      "sw": "Tambua kama mwaka uliotolewa ni mwaka wa kisiku.\nMwaka wa kisiku hugawanyika kwa 4 isipokuwa kwa miaka ya mwisho wa karne ambayo lazima yagawanyike kwa 400.\nHii inamaanisha kwamba mwaka 2000 ulikuwa mwaka wa kisiku, ingawa 1900 haukuwa.\n>>> isLeapYear(1926)\n0\n>>> isLeapYear(1900)\n0\n>>> isLeapYear(2000)\n1\n>>> isLeapYear(1996)\n1",
      "tr": "Verilen bir yılın artık yıl olup olmadığını belirleyin.  \nBir artık yıl, 4 ile tam bölünebilir, ancak yüzyıl sonu yılları 400 ile bölünebilir olmalıdır.  \nBu, 2000 yılının artık yıl olduğu anlamına gelir, ancak 1900 yılı değildir.  \n>>> isLeapYear(1926)  \n0  \n>>> isLeapYear(1900)  \n0  \n>>> isLeapYear(2000)  \n1  \n>>> isLeapYear(1996)  \n1  ",
      "vi": "Xác định xem một năm cho trước có phải là năm nhuận hay không.  \nMột năm nhuận là năm chia hết cho 4, ngoại trừ các năm cuối thế kỷ phải chia hết cho 400.  \nĐiều này có nghĩa là năm 2000 là năm nhuận, mặc dù năm 1900 không phải.  \n>>> isLeapYear(1926)  \n0  \n>>> isLeapYear(1900)  \n0  \n>>> isLeapYear(2000)  \n1  \n>>> isLeapYear(1996)  \n1  "
    },
    "docstring_bertscore": {
      "es": "0.9982917787230999",
      "arb": "0.9837129046462822",
      "sw": "0.9908002352719881",
      "tr": "0.9576065164061048",
      "vi": "0.9709961903916666"
    }
  },
  {
    "task_id": "Swift/30",
    "prompt": {
      "en": "func daysInMonth(_ year: Int, _ month: Int) -> Int {\n/**\nCalculates the number of days in a given month of a given year.\nTakes into account whether the year is a leap year or not.\n\n- Parameters:\n- year: The year for which to calculate the number of days.\n- month: The month for which to calculate the number of days.\n\n- Returns: The number of days in the given month of the given year.\n\nExamples:\ndaysInMonth(1926, 8) // Returns 31\ndaysInMonth(2000, 2) // Returns 29\n*/",
      "es": "func daysInMonth(_ year: Int, _ month: Int) -> Int {\n/**\nCalcula el número de días en un mes dado de un año dado.\nTiene en cuenta si el año es bisiesto o no.\n\n- Parámetros:\n- year: El año para el cual calcular el número de días.\n- month: El mes para el cual calcular el número de días.\n\n- Retorna: El número de días en el mes dado del año dado.\n\nEjemplos:\ndaysInMonth(1926, 8) // Retorna 31\ndaysInMonth(2000, 2) // Retorna 29\n*/",
      "arb": "func daysInMonth(_ year: Int, _ month: Int) -> Int {\n/**\nيحسب عدد الأيام في شهر معين من سنة معينة.\nيأخذ في الاعتبار ما إذا كانت السنة سنة كبيسة أم لا.\n\n- Parameters:\n- year: السنة التي سيتم حساب عدد الأيام لها.\n- month: الشهر الذي سيتم حساب عدد الأيام له.\n\n- Returns: عدد الأيام في الشهر المعطى من السنة المعطاة.\n\nExamples:\ndaysInMonth(1926, 8) // Returns 31\ndaysInMonth(2000, 2) // Returns 29\n*/",
      "sw": "func daysInMonth(_ year: Int, _ month: Int) -> Int {\n/**\nHesabu idadi ya siku katika mwezi fulani wa mwaka fulani.\nInazingatia kama mwaka ni mwaka wa kisiku au la.\n\n- Vigezo:\n- year: Mwaka ambao unataka kuhesabu idadi ya siku.\n- month: Mwezi ambao unataka kuhesabu idadi ya siku.\n\n- Inarudisha: Idadi ya siku katika mwezi uliotolewa wa mwaka uliotolewa.\n\nMifano:\ndaysInMonth(1926, 8) // Inarudisha 31\ndaysInMonth(2000, 2) // Inarudisha 29\n*/",
      "tr": "func daysInMonth(_ year: Int, _ month: Int) -> Int {\n/**\nBelirtilen bir yılın belirtilen bir ayındaki gün sayısını hesaplar.\nYılın artık yıl olup olmadığını dikkate alır.\n\n- Parametreler:\n- year: Gün sayısını hesaplamak istediğiniz yıl.\n- month: Gün sayısını hesaplamak istediğiniz ay.\n\n- Döndürür: Belirtilen yılın belirtilen ayındaki gün sayısı.\n\nÖrnekler:\ndaysInMonth(1926, 8) // 31 döndürür\ndaysInMonth(2000, 2) // 29 döndürür\n*/",
      "vi": "func daysInMonth(_ year: Int, _ month: Int) -> Int {\n/**\nTính số ngày trong một tháng nhất định của một năm nhất định.\nXem xét liệu năm đó có phải là năm nhuận hay không.\n\n- Tham số:\n- year: Năm mà bạn muốn tính số ngày.\n- month: Tháng mà bạn muốn tính số ngày.\n\n- Trả về: Số ngày trong tháng nhất định của năm nhất định.\n\nVí dụ:\ndaysInMonth(1926, 8) // Trả về 31\ndaysInMonth(2000, 2) // Trả về 29\n*/"
    },
    "prompt_bertscore": {
      "es": "0.999999801369619",
      "arb": "0.9754264424102688",
      "sw": "0.9640526681618301",
      "tr": "0.9555590344383972",
      "vi": "0.9490737524976082"
    },
    "canonical_solution": "switch month {\ncase 2:\nif isLeapYear(year) {\nreturn 29\n} else {\nreturn 28\n}\ncase 4, 6, 9, 11:\nreturn 30\ndefault:\nreturn 31\n}\n}\nfunc isLeapYear(_ year: Int) -> Bool {\nreturn (year % 4 == 0 && year % 100 != 0) || year % 400 == 0\n}",
    "instruction": {
      "en": "func daysInMonth(_ year: Int, _ month: Int) -> Int {\nswitch month {\ncase 2:\nif isLeapYear(year) {\nreturn 29\n} else {\nreturn 28\n}\ncase 4, 6, 9, 11:\nreturn 30\ndefault:\nreturn 31\n}\n}\nfunc isLeapYear(_ year: Int) -> Bool {\nreturn (year % 4 == 0 && year % 100 != 0) || year % 400 == 0\n}\n\nProvide a concise natural language description (docstring) of the Swift code in English using at most 500 characters.",
      "es": "func daysInMonth(_ year: Int, _ month: Int) -> Int {\nswitch month {\ncase 2:\nif isLeapYear(year) {\nreturn 29\n} else {\nreturn 28\n}\ncase 4, 6, 9, 11:\nreturn 30\ndefault:\nreturn 31\n}\n}\nfunc isLeapYear(_ year: Int) -> Bool {\nreturn (year % 4 == 0 && year % 100 != 0) || year % 400 == 0\n}\n\nProporciona una descripción concisa en lenguaje natural (docstring) del código Swift en español utilizando un máximo de 500 caracteres.",
      "arb": "func daysInMonth(_ year: Int, _ month: Int) -> Int {\nswitch month {\ncase 2:\nif isLeapYear(year) {\nreturn 29\n} else {\nreturn 28\n}\ncase 4, 6, 9, 11:\nreturn 30\ndefault:\nreturn 31\n}\n}\nfunc isLeapYear(_ year: Int) -> Bool {\nreturn (year % 4 == 0 && year % 100 != 0) || year % 400 == 0\n}\n\nقدم وصفًا موجزًا بلغة طبيعية (docstring) لكود Swift باللغة العربية الفصحى باستخدام 500 حرف كحد أقصى.",
      "sw": "func daysInMonth(_ year: Int, _ month: Int) -> Int {\nswitch month {\ncase 2:\nif isLeapYear(year) {\nreturn 29\n} else {\nreturn 28\n}\ncase 4, 6, 9, 11:\nreturn 30\ndefault:\nreturn 31\n}\n}\nfunc isLeapYear(_ year: Int) -> Bool {\nreturn (year % 4 == 0 && year % 100 != 0) || year % 400 == 0\n}\n\nToa maelezo mafupi ya lugha ya asili (docstring) ya msimbo wa Swift kwa Kiswahili kwa kutumia herufi zisizozidi 500.",
      "tr": "func daysInMonth(_ year: Int, _ month: Int) -> Int {\nswitch month {\ncase 2:\nif isLeapYear(year) {\nreturn 29\n} else {\nreturn 28\n}\ncase 4, 6, 9, 11:\nreturn 30\ndefault:\nreturn 31\n}\n}\nfunc isLeapYear(_ year: Int) -> Bool {\nreturn (year % 4 == 0 && year % 100 != 0) || year % 400 == 0\n}\n\nSwift kodunun işlevini açıklayan kısa bir doğal dil açıklaması (docstring) sağlayın. Açıklama, Türkçe olarak en fazla 500 karakter kullanılarak yazılmalıdır.",
      "vi": "func daysInMonth(_ year: Int, _ month: Int) -> Int {\nswitch month {\ncase 2:\nif isLeapYear(year) {\nreturn 29\n} else {\nreturn 28\n}\ncase 4, 6, 9, 11:\nreturn 30\ndefault:\nreturn 31\n}\n}\nfunc isLeapYear(_ year: Int) -> Bool {\nreturn (year % 4 == 0 && year % 100 != 0) || year % 400 == 0\n}\n\nCung cấp mô tả ngắn gọn bằng ngôn ngữ tự nhiên (docstring) cho mã Swift bằng tiếng Việt, sử dụng tối đa 500 ký tự."
    },
    "instruction_bertscore": {
      "es": "0.9676013985493994",
      "arb": "0.913797592716955",
      "sw": "0.9148419912604365",
      "tr": "0.8714851503185221",
      "vi": "0.9280328362345824"
    },
    "level": "",
    "test": "func testDaysInMonth() {\n// Non-leap years\nassert(daysInMonth(1926, 8) == 31)\nassert(daysInMonth(1999, 12) == 31)\n\n// Leap years\nassert(daysInMonth(2000, 2) == 29)\nassert(daysInMonth(2020, 2) == 29)\n\n// Months with 30 days\nassert(daysInMonth(2022, 4) == 30)\nassert(daysInMonth(2022, 6) == 30)\n\n// Months with 31 days\nassert(daysInMonth(2022, 1) == 31)\nassert(daysInMonth(2022, 3) == 31)\n}\n\ntestDaysInMonth()",
    "entry_point": "daysInMonth",
    "signature": "func daysInMonth(_ year: Int, _ month: Int) -> Int {",
    "docstring": {
      "en": "\nCalculates the number of days in a given month of a given year.\nTakes into account whether the year is a leap year or not.\n\n- Parameters:\n- year: The year for which to calculate the number of days.\n- month: The month for which to calculate the number of days.\n\n- Returns: The number of days in the given month of the given year.\n\nExamples:\ndaysInMonth(1926, 8) // Returns 31\ndaysInMonth(2000, 2) // Returns 29\n",
      "es": "Calcula el número de días en un mes dado de un año dado. Tiene en cuenta si el año es bisiesto o no.\n\n- Parámetros:\n- year: El año para el cual calcular el número de días.\n- month: El mes para el cual calcular el número de días.\n\n- Devuelve: El número de días en el mes dado del año dado.\n\nEjemplos:\ndaysInMonth(1926, 8) // Devuelve 31\ndaysInMonth(2000, 2) // Devuelve 29",
      "arb": "يحسب عدد الأيام في شهر معين من سنة معينة. يأخذ في الاعتبار ما إذا كانت السنة سنة كبيسة أم لا.\n\n- المعاملات:\n- year: السنة التي سيتم حساب عدد الأيام لها.\n- month: الشهر الذي سيتم حساب عدد الأيام له.\n\n- العائدات: عدد الأيام في الشهر المحدد من السنة المحددة.\n\nأمثلة:\ndaysInMonth(1926, 8) // يعيد 31\ndaysInMonth(2000, 2) // يعيد 29",
      "sw": "Hesabu idadi ya siku katika mwezi uliotolewa wa mwaka uliotolewa. Inazingatia kama mwaka ni wa kisasa au la.\n\n- Vigezo:\n- year: Mwaka ambao unahesabu idadi ya siku.\n- month: Mwezi ambao unahesabu idadi ya siku.\n\n- Inarudisha: Idadi ya siku katika mwezi uliotolewa wa mwaka uliotolewa.\n\nMifano:\ndaysInMonth(1926, 8) // Inarudisha 31\ndaysInMonth(2000, 2) // Inarudisha 29",
      "tr": "Belirtilen bir yılın belirtilen bir ayındaki gün sayısını hesaplar.\nYılın artık yıl olup olmadığını dikkate alır.\n\n- Parametreler:\n- year: Gün sayısını hesaplamak için yıl.\n- month: Gün sayısını hesaplamak için ay.\n\n- Döndürür: Belirtilen yılın belirtilen ayındaki gün sayısı.\n\nÖrnekler:\ndaysInMonth(1926, 8) // 31 döndürür\ndaysInMonth(2000, 2) // 29 döndürür",
      "vi": "Tính toán số ngày trong một tháng nhất định của một năm nhất định.  \nXem xét liệu năm đó có phải là năm nhuận hay không.\n\n- Tham số:\n- year: Năm mà bạn muốn tính số ngày.\n- month: Tháng mà bạn muốn tính số ngày.\n\n- Trả về: Số ngày trong tháng nhất định của năm nhất định.\n\nVí dụ:\ndaysInMonth(1926, 8) // Trả về 31\ndaysInMonth(2000, 2) // Trả về 29"
    },
    "docstring_bertscore": {
      "es": "0.9927563472644197",
      "arb": "0.9492640404026396",
      "sw": "0.9455047618111733",
      "tr": "0.9337595487501993",
      "vi": "0.934566385357963"
    }
  },
  {
    "task_id": "Swift/31",
    "prompt": {
      "en": "import Foundation\n\nfunc minimumSwapsToOrder(_ trainCars: [Int]) -> Int {\n/**\nFinds the minimum number of 180-degree rotations needed to rearrange a train's cars into ascending order.\n\nThe function takes an array of integers representing the initial order of train cars, and returns the minimum number of rotations required to order them in ascending order.\n\nExample cases:\n>>> minimumSwapsToOrder([2, 3, 1])\n2\n>>> minimumSwapsToOrder([1, 4, 3, 2])\n3\n>>> minimumSwapsToOrder([5, 4, 3, 2, 1])\n10\n*/",
      "es": "import Foundation\n\nfunc minimumSwapsToOrder(_ trainCars: [Int]) -> Int {\n/**\nEncuentra el número mínimo de rotaciones de 180 grados necesarias para reorganizar los vagones de un tren en orden ascendente.\n\nLa función toma un arreglo de enteros que representa el orden inicial de los vagones del tren y devuelve el número mínimo de rotaciones necesarias para ordenarlos en orden ascendente.\n\nCasos de ejemplo:\n>>> minimumSwapsToOrder([2, 3, 1])\n2\n>>> minimumSwapsToOrder([1, 4, 3, 2])\n3\n>>> minimumSwapsToOrder([5, 4, 3, 2, 1])\n10\n*/",
      "arb": "import Foundation\n\nfunc minimumSwapsToOrder(_ trainCars: [Int]) -> Int {\n/**\nيجد الحد الأدنى لعدد الدورانات بزاوية 180 درجة اللازمة لإعادة ترتيب عربات القطار بترتيب تصاعدي.\n\nتأخذ الدالة مصفوفة من الأعداد الصحيحة تمثل الترتيب الأولي لعربات القطار، وتعيد الحد الأدنى لعدد الدورانات المطلوبة لترتيبها بترتيب تصاعدي.\n\nأمثلة على الحالات:\n>>> minimumSwapsToOrder([2, 3, 1])\n2\n>>> minimumSwapsToOrder([1, 4, 3, 2])\n3\n>>> minimumSwapsToOrder([5, 4, 3, 2, 1])\n10\n*/",
      "sw": "import Foundation\n\nfunc minimumSwapsToOrder(_ trainCars: [Int]) -> Int {\n/**\nInapata idadi ndogo zaidi ya mizunguko ya digrii 180 inayohitajika kupanga upya magari ya treni katika mpangilio wa kupanda.\n\nKazi inachukua safu ya nambari za mzima zinazowakilisha mpangilio wa awali wa magari ya treni, na inarudisha idadi ndogo zaidi ya mizunguko inayohitajika kuzipanga katika mpangilio wa kupanda.\n\nMifano ya kesi:\n>>> minimumSwapsToOrder([2, 3, 1])\n2\n>>> minimumSwapsToOrder([1, 4, 3, 2])\n3\n>>> minimumSwapsToOrder([5, 4, 3, 2, 1])\n10\n*/",
      "tr": "import Foundation\n\nfunc minimumSwapsToOrder(_ trainCars: [Int]) -> Int {\n/**\nBir trenin vagonlarını artan sıraya göre yeniden düzenlemek için gereken minimum 180 derece dönüş sayısını bulur.\n\nFonksiyon, tren vagonlarının başlangıç sırasını temsil eden bir tamsayı dizisini alır ve onları artan sıraya göre düzenlemek için gereken minimum dönüş sayısını döndürür.\n\nÖrnek durumlar:\n>>> minimumSwapsToOrder([2, 3, 1])\n2\n>>> minimumSwapsToOrder([1, 4, 3, 2])\n3\n>>> minimumSwapsToOrder([5, 4, 3, 2, 1])\n10\n*/",
      "vi": "import Foundation\n\nfunc minimumSwapsToOrder(_ trainCars: [Int]) -> Int {\n/**\nTìm số lần xoay 180 độ tối thiểu cần thiết để sắp xếp lại các toa tàu theo thứ tự tăng dần.\n\nHàm nhận một mảng số nguyên đại diện cho thứ tự ban đầu của các toa tàu, và trả về số lần xoay tối thiểu cần thiết để sắp xếp chúng theo thứ tự tăng dần.\n\nCác trường hợp ví dụ:\n>>> minimumSwapsToOrder([2, 3, 1])\n2\n>>> minimumSwapsToOrder([1, 4, 3, 2])\n3\n>>> minimumSwapsToOrder([5, 4, 3, 2, 1])\n10\n*/"
    },
    "prompt_bertscore": {
      "es": "0.9797003723189965",
      "arb": "0.9861050103250855",
      "sw": "0.9860541609475405",
      "tr": "0.9788830083010379",
      "vi": "0.979430036370408"
    },
    "canonical_solution": "var cars = trainCars\nvar swapCount = 0\nvar swapped: Bool\n\nrepeat {\nswapped = false\nfor i in 0..<cars.count - 1 {\nif cars[i] > cars[i + 1] {\ncars.swapAt(i, i + 1)\nswapCount += 1\nswapped = true\n}\n}\n} while swapped\n\nreturn swapCount\n}",
    "instruction": {
      "en": "func minimumSwapsToOrder(_ trainCars: [Int]) -> Int {\nvar cars = trainCars\nvar swapCount = 0\nvar swapped: Bool\n\nrepeat {\nswapped = false\nfor i in 0..<cars.count - 1 {\nif cars[i] > cars[i + 1] {\ncars.swapAt(i, i + 1)\nswapCount += 1\nswapped = true\n}\n}\n} while swapped\n\nreturn swapCount\n}\n\nProvide a concise natural language description (docstring) of the Swift code in English using at most 500 characters.",
      "es": "func minimumSwapsToOrder(_ trainCars: [Int]) -> Int {\nvar cars = trainCars\nvar swapCount = 0\nvar swapped: Bool\n\nrepeat {\nswapped = false\nfor i in 0..<cars.count - 1 {\nif cars[i] > cars[i + 1] {\ncars.swapAt(i, i + 1)\nswapCount += 1\nswapped = true\n}\n}\n} while swapped\n\nreturn swapCount\n}\n\nProporcione una descripción concisa en lenguaje natural (docstring) del código Swift en español utilizando un máximo de 500 caracteres.",
      "arb": "func minimumSwapsToOrder(_ trainCars: [Int]) -> Int {\nvar cars = trainCars\nvar swapCount = 0\nvar swapped: Bool\n\nrepeat {\nswapped = false\nfor i in 0..<cars.count - 1 {\nif cars[i] > cars[i + 1] {\ncars.swapAt(i, i + 1)\nswapCount += 1\nswapped = true\n}\n}\n} while swapped\n\nreturn swapCount\n}\n\nقدم وصفًا موجزًا بلغة طبيعية (docstring) لكود Swift باللغة العربية الفصحى باستخدام ما لا يزيد عن 500 حرف.",
      "sw": "func minimumSwapsToOrder(_ trainCars: [Int]) -> Int {\nvar cars = trainCars\nvar swapCount = 0\nvar swapped: Bool\n\nrepeat {\nswapped = false\nfor i in 0..<cars.count - 1 {\nif cars[i] > cars[i + 1] {\ncars.swapAt(i, i + 1)\nswapCount += 1\nswapped = true\n}\n}\n} while swapped\n\nreturn swapCount\n}\n\nToa maelezo mafupi ya lugha ya asili (docstring) ya msimbo wa Swift kwa Kiswahili kwa kutumia herufi zisizozidi 500.",
      "tr": "func minimumSwapsToOrder(_ trainCars: [Int]) -> Int {\nvar cars = trainCars\nvar swapCount = 0\nvar swapped: Bool\n\nrepeat {\nswapped = false\nfor i in 0..<cars.count - 1 {\nif cars[i] > cars[i + 1] {\ncars.swapAt(i, i + 1)\nswapCount += 1\nswapped = true\n}\n}\n} while swapped\n\nreturn swapCount\n}\n\nSwift kodunun işlevini açıklayan kısa bir doğal dil tanımı (docstring) sağlayın. Açıklama en fazla 500 karakter olmalıdır.",
      "vi": "func minimumSwapsToOrder(_ trainCars: [Int]) -> Int {\nvar cars = trainCars\nvar swapCount = 0\nvar swapped: Bool\n\nrepeat {\nswapped = false\nfor i in 0..<cars.count - 1 {\nif cars[i] > cars[i + 1] {\ncars.swapAt(i, i + 1)\nswapCount += 1\nswapped = true\n}\n}\n} while swapped\n\nreturn swapCount\n}\n\nCung cấp mô tả ngắn gọn bằng ngôn ngữ tự nhiên (docstring) cho mã Swift bằng tiếng Việt, sử dụng tối đa 500 ký tự."
    },
    "instruction_bertscore": {
      "es": "0.9676013985493994",
      "arb": "0.8880608556158835",
      "sw": "0.9148419912604365",
      "tr": "0.8416419287199354",
      "vi": "0.9054771646857847"
    },
    "level": "",
    "test": "func check(_ minimumSwapsToOrder: ([Int]) -> Int) {\nassert(minimumSwapsToOrder([2, 3, 1]) == 2)\nassert(minimumSwapsToOrder([1, 4, 3, 2]) == 3)\nassert(minimumSwapsToOrder([5, 4, 3, 2, 1]) == 10)\nassert(minimumSwapsToOrder([1, 2, 3, 4, 5]) == 0)\nassert(minimumSwapsToOrder([3, 1, 2]) == 2)\nassert(minimumSwapsToOrder([4, 5, 1, 3, 2]) == 7)\nassert(minimumSwapsToOrder([1]) == 0)\n}\n\ncheck(minimumSwapsToOrder)",
    "entry_point": "minimumSwapsToOrder",
    "signature": "func minimumSwapsToOrder(_ trainCars: [Int]) -> Int {",
    "docstring": {
      "en": "\nFinds the minimum number of 180-degree rotations needed to rearrange a train's cars into ascending order.\n\nThe function takes an array of integers representing the initial order of train cars, and returns the minimum number of rotations required to order them in ascending order.\n\nExample cases:\n>>> minimumSwapsToOrder([2, 3, 1])\n2\n>>> minimumSwapsToOrder([1, 4, 3, 2])\n3\n>>> minimumSwapsToOrder([5, 4, 3, 2, 1])\n10\n",
      "es": "Encuentra el número mínimo de rotaciones de 180 grados necesarias para reorganizar los vagones de un tren en orden ascendente.\n\nLa función toma un arreglo de enteros que representa el orden inicial de los vagones del tren y devuelve el número mínimo de rotaciones necesarias para ordenarlos en orden ascendente.\n\nCasos de ejemplo:\n>>> minimumSwapsToOrder([2, 3, 1])\n2\n>>> minimumSwapsToOrder([1, 4, 3, 2])\n3\n>>> minimumSwapsToOrder([5, 4, 3, 2, 1])\n10",
      "arb": "يجد الحد الأدنى لعدد الدورانات بزاوية 180 درجة اللازمة لإعادة ترتيب عربات القطار بترتيب تصاعدي.\n\nتأخذ الدالة مصفوفة من الأعداد الصحيحة التي تمثل الترتيب الأولي لعربات القطار، وتعيد الحد الأدنى لعدد الدورانات المطلوبة لترتيبها بترتيب تصاعدي.\n\nحالات المثال:\n>>> minimumSwapsToOrder([2, 3, 1])\n2\n>>> minimumSwapsToOrder([1, 4, 3, 2])\n3\n>>> minimumSwapsToOrder([5, 4, 3, 2, 1])\n10",
      "sw": "Inapata idadi ndogo ya mizunguko ya digrii 180 inayohitajika kupanga upya mabehewa ya treni katika mpangilio wa kupanda.\n\nKazi inachukua safu ya nambari za mzima zinazowakilisha mpangilio wa awali wa mabehewa ya treni, na inarejesha idadi ndogo ya mizunguko inayohitajika ili kuyaweka katika mpangilio wa kupanda.\n\nMifano ya kesi:\n>>> minimumSwapsToOrder([2, 3, 1])\n2\n>>> minimumSwapsToOrder([1, 4, 3, 2])\n3\n>>> minimumSwapsToOrder([5, 4, 3, 2, 1])\n10",
      "tr": "Tren vagonlarını artan sıraya göre yeniden düzenlemek için gereken minimum 180 derece dönüş sayısını bulur.\n\nFonksiyon, tren vagonlarının başlangıç sırasını temsil eden bir tamsayı dizisini alır ve bunları artan sıraya göre düzenlemek için gereken minimum dönüş sayısını döndürür.\n\nÖrnek durumlar:\n>>> minimumSwapsToOrder([2, 3, 1])\n2\n>>> minimumSwapsToOrder([1, 4, 3, 2])\n3\n>>> minimumSwapsToOrder([5, 4, 3, 2, 1])\n10",
      "vi": "Tìm số lần quay 180 độ tối thiểu cần thiết để sắp xếp lại các toa tàu theo thứ tự tăng dần.\n\nHàm nhận một mảng số nguyên đại diện cho thứ tự ban đầu của các toa tàu, và trả về số lần quay tối thiểu cần thiết để sắp xếp chúng theo thứ tự tăng dần.\n\nCác trường hợp ví dụ:\n>>> minimumSwapsToOrder([2, 3, 1])\n2\n>>> minimumSwapsToOrder([1, 4, 3, 2])\n3\n>>> minimumSwapsToOrder([5, 4, 3, 2, 1])\n10"
    },
    "docstring_bertscore": {
      "es": "0.9744094548593701",
      "arb": "0.9765306286984418",
      "sw": "0.973326720652349",
      "tr": "0.9702934361035652",
      "vi": "0.9750555994888767"
    }
  },
  {
    "task_id": "Swift/32",
    "prompt": {
      "en": "import Foundation\n\nfunc isLuckyWord(_ word: String) -> (isLucky: Bool, difference: Int) {\n/**\nDetermines if the given word is a \"Lucky Word.\" A word is considered lucky if the difference\nbetween the maximum and minimum character frequencies in the word is a prime number.\n\n- Parameters:\n- word: A string representing the word to be checked. Assumes only lowercase letters and a length less than 100.\n\n- Returns: A tuple containing a boolean indicating if the word is lucky, and an integer that is the difference\nbetween the max and min frequencies if the word is lucky, or 0 otherwise.\n\nExamples:\n>>> isLuckyWord(\"hello\")\n(false, 0)\n>>> isLuckyWord(\"banana\")\n(true, 2)\n*/",
      "es": "import Foundation\n\nfunc isLuckyWord(_ word: String) -> (isLucky: Bool, difference: Int) {\n/**\nDetermina si la palabra dada es una \"Palabra de la Suerte\". Una palabra se considera de la suerte si la diferencia\nentre las frecuencias máximas y mínimas de los caracteres en la palabra es un número primo.\n\n- Parámetros:\n- word: Una cadena que representa la palabra a verificar. Se asume que solo contiene letras minúsculas y una longitud menor a 100.\n\n- Retorna: Una tupla que contiene un booleano que indica si la palabra es de la suerte, y un entero que es la diferencia\nentre las frecuencias máxima y mínima si la palabra es de la suerte, o 0 de lo contrario.\n\nEjemplos:\n>>> isLuckyWord(\"hello\")\n(false, 0)\n>>> isLuckyWord(\"banana\")\n(true, 2)\n*/",
      "arb": "import Foundation\n\nfunc isLuckyWord(_ word: String) -> (isLucky: Bool, difference: Int) {\n/**\nيحدد ما إذا كانت الكلمة المعطاة هي \"كلمة محظوظة\". تعتبر الكلمة محظوظة إذا كان الفرق\nبين ترددات الحروف القصوى والدنيا في الكلمة هو عدد أولي.\n\n- المعلمات:\n- word: سلسلة تمثل الكلمة التي سيتم التحقق منها. يفترض وجود حروف صغيرة فقط وطول أقل من 100.\n\n- العوائد: زوج يحتوي على قيمة منطقية تشير إلى ما إذا كانت الكلمة محظوظة، وعدد صحيح يمثل الفرق\nبين الترددات القصوى والدنيا إذا كانت الكلمة محظوظة، أو 0 خلاف ذلك.\n\nأمثلة:\n>>> isLuckyWord(\"hello\")\n(false, 0)\n>>> isLuckyWord(\"banana\")\n(true, 2)\n*/",
      "sw": "import Foundation\n\nfunc isLuckyWord(_ word: String) -> (isLucky: Bool, difference: Int) {\n/**\nHuamua kama neno lililopewa ni \"Neno la Bahati.\" Neno linachukuliwa kuwa la bahati ikiwa tofauti\nkati ya marudio ya tabia ya juu na ya chini katika neno ni nambari ya kwanza.\n\n- Vigezo:\n- word: Kamba inayowakilisha neno linalopaswa kukaguliwa. Inadhaniwa kuwa na herufi ndogo pekee na urefu chini ya 100.\n\n- Inarudisha: Jozi inayoonyesha boolean ikiwa neno ni la bahati, na nambari ambayo ni tofauti\nkati ya marudio ya juu na ya chini ikiwa neno ni la bahati, au 0 vinginevyo.\n\nMifano:\n>>> isLuckyWord(\"hello\")\n(false, 0)\n>>> isLuckyWord(\"banana\")\n(true, 2)\n*/",
      "tr": "import Foundation\n\nfunc isLuckyWord(_ word: String) -> (isLucky: Bool, difference: Int) {\n/**\nVerilen kelimenin \"Şanslı Kelime\" olup olmadığını belirler. Bir kelime, kelimedeki maksimum ve minimum karakter\nfrekansları arasındaki fark asal bir sayı ise şanslı kabul edilir.\n\n- Parametreler:\n- word: Kontrol edilecek kelimeyi temsil eden bir string. Sadece küçük harfler ve 100'den kısa bir uzunluk içerdiği varsayılır.\n\n- Döndürür: Kelimenin şanslı olup olmadığını belirten bir boolean ve kelime şanslıysa maksimum ve minimum frekanslar\narasındaki fark olan bir tamsayı, aksi takdirde 0 içeren bir demet.\n\nÖrnekler:\n>>> isLuckyWord(\"hello\")\n(false, 0)\n>>> isLuckyWord(\"banana\")\n(true, 2)\n*/",
      "vi": "import Foundation\n\nfunc isLuckyWord(_ word: String) -> (isLucky: Bool, difference: Int) {\n/**\nXác định xem từ đã cho có phải là \"Từ May Mắn\" hay không. Một từ được coi là may mắn nếu sự chênh lệch\ngiữa tần suất ký tự lớn nhất và nhỏ nhất trong từ là một số nguyên tố.\n\n- Tham số:\n- word: Một chuỗi đại diện cho từ cần kiểm tra. Giả sử chỉ có chữ cái thường và độ dài nhỏ hơn 100.\n\n- Trả về: Một bộ giá trị chứa một giá trị boolean cho biết từ có may mắn hay không, và một số nguyên là sự chênh lệch\ngiữa tần suất lớn nhất và nhỏ nhất nếu từ là may mắn, hoặc 0 nếu không.\n\nVí dụ:\n>>> isLuckyWord(\"hello\")\n(false, 0)\n>>> isLuckyWord(\"banana\")\n(true, 2)\n*/"
    },
    "prompt_bertscore": {
      "es": "0.976412642252107",
      "arb": "0.9808113120401246",
      "sw": "0.9637006951266363",
      "tr": "0.968960030355678",
      "vi": "0.9441318286174601"
    },
    "canonical_solution": "let frequencies = word.reduce(into: [Character: Int]()) { counts, char in\ncounts[char, default: 0] += 1\n}\nguard let maxFreq = frequencies.values.max(), let minFreq = frequencies.values.min() else {\nreturn (false, 0)\n}\n\nlet difference = maxFreq - minFreq\n\nfunc isPrime(_ number: Int) -> Bool {\nguard number > 1 else { return false }\nguard number > 3 else { return true }\nfor i in 2...Int(sqrt(Double(number))) {\nif number % i == 0 {\nreturn false\n}\n}\nreturn true\n}\nif (isPrime(difference)){\nreturn (isPrime(difference), difference)\n}\n\nreturn (isPrime(difference),0)\n\n}",
    "instruction": {
      "en": "func isLuckyWord(_ word: String) -> (isLucky: Bool, difference: Int) {\nlet frequencies = word.reduce(into: [Character: Int]()) { counts, char in\ncounts[char, default: 0] += 1\n}\nguard let maxFreq = frequencies.values.max(), let minFreq = frequencies.values.min() else {\nreturn (false, 0)\n}\n\nlet difference = maxFreq - minFreq\n\nfunc isPrime(_ number: Int) -> Bool {\nguard number > 1 else { return false }\nguard number > 3 else { return true }\nfor i in 2...Int(sqrt(Double(number))) {\nif number % i == 0 {\nreturn false\n}\n}\nreturn true\n}\nif (isPrime(difference)){\nreturn (isPrime(difference), difference)\n}\n\nreturn (isPrime(difference),0)\n\n}\n\nProvide a concise natural language description (docstring) of the Swift code in English using at most 500 characters.",
      "es": "func isLuckyWord(_ word: String) -> (isLucky: Bool, difference: Int) {\nlet frequencies = word.reduce(into: [Character: Int]()) { counts, char in\ncounts[char, default: 0] += 1\n}\nguard let maxFreq = frequencies.values.max(), let minFreq = frequencies.values.min() else {\nreturn (false, 0)\n}\n\nlet difference = maxFreq - minFreq\n\nfunc isPrime(_ number: Int) -> Bool {\nguard number > 1 else { return false }\nguard number > 3 else { return true }\nfor i in 2...Int(sqrt(Double(number))) {\nif number % i == 0 {\nreturn false\n}\n}\nreturn true\n}\nif (isPrime(difference)){\nreturn (isPrime(difference), difference)\n}\n\nreturn (isPrime(difference),0)\n\n}\n\nProporcione una descripción concisa en lenguaje natural (docstring) del código Swift en español utilizando un máximo de 500 caracteres.",
      "arb": "func isLuckyWord(_ word: String) -> (isLucky: Bool, difference: Int) {\nlet frequencies = word.reduce(into: [Character: Int]()) { counts, char in\ncounts[char, default: 0] += 1\n}\nguard let maxFreq = frequencies.values.max(), let minFreq = frequencies.values.min() else {\nreturn (false, 0)\n}\n\nlet difference = maxFreq - minFreq\n\nfunc isPrime(_ number: Int) -> Bool {\nguard number > 1 else { return false }\nguard number > 3 else { return true }\nfor i in 2...Int(sqrt(Double(number))) {\nif number % i == 0 {\nreturn false\n}\n}\nreturn true\n}\nif (isPrime(difference)){\nreturn (isPrime(difference), difference)\n}\n\nreturn (isPrime(difference),0)\n\n}\n\nقدم وصفًا موجزًا بلغة طبيعية (docstring) لكود Swift باللغة العربية الفصحى باستخدام 500 حرف كحد أقصى.",
      "sw": "func isLuckyWord(_ word: String) -> (isLucky: Bool, difference: Int) {\nlet frequencies = word.reduce(into: [Character: Int]()) { counts, char in\ncounts[char, default: 0] += 1\n}\nguard let maxFreq = frequencies.values.max(), let minFreq = frequencies.values.min() else {\nreturn (false, 0)\n}\n\nlet difference = maxFreq - minFreq\n\nfunc isPrime(_ number: Int) -> Bool {\nguard number > 1 else { return false }\nguard number > 3 else { return true }\nfor i in 2...Int(sqrt(Double(number))) {\nif number % i == 0 {\nreturn false\n}\n}\nreturn true\n}\nif (isPrime(difference)){\nreturn (isPrime(difference), difference)\n}\n\nreturn (isPrime(difference),0)\n\n}\n\nToa maelezo mafupi ya lugha ya asili (docstring) ya msimbo wa Swift kwa Kiswahili kwa kutumia herufi zisizozidi 500.",
      "tr": "func isLuckyWord(_ word: String) -> (isLucky: Bool, difference: Int) {\nlet frequencies = word.reduce(into: [Character: Int]()) { counts, char in\ncounts[char, default: 0] += 1\n}\nguard let maxFreq = frequencies.values.max(), let minFreq = frequencies.values.min() else {\nreturn (false, 0)\n}\n\nlet difference = maxFreq - minFreq\n\nfunc isPrime(_ number: Int) -> Bool {\nguard number > 1 else { return false }\nguard number > 3 else { return true }\nfor i in 2...Int(sqrt(Double(number))) {\nif number % i == 0 {\nreturn false\n}\n}\nreturn true\n}\nif (isPrime(difference)){\nreturn (isPrime(difference), difference)\n}\n\nreturn (isPrime(difference),0)\n\n}\n\nSwift kodunun Türkçe dilinde en fazla 500 karakter kullanarak kısa bir doğal dil açıklamasını (docstring) sağlayın.",
      "vi": "func isLuckyWord(_ word: String) -> (isLucky: Bool, difference: Int) {\nlet frequencies = word.reduce(into: [Character: Int]()) { counts, char in\ncounts[char, default: 0] += 1\n}\nguard let maxFreq = frequencies.values.max(), let minFreq = frequencies.values.min() else {\nreturn (false, 0)\n}\n\nlet difference = maxFreq - minFreq\n\nfunc isPrime(_ number: Int) -> Bool {\nguard number > 1 else { return false }\nguard number > 3 else { return true }\nfor i in 2...Int(sqrt(Double(number))) {\nif number % i == 0 {\nreturn false\n}\n}\nreturn true\n}\nif (isPrime(difference)){\nreturn (isPrime(difference), difference)\n}\n\nreturn (isPrime(difference),0)\n\n}\n\nCung cấp mô tả ngắn gọn bằng ngôn ngữ tự nhiên (docstring) cho mã Swift bằng tiếng Việt, không quá 500 ký tự."
    },
    "instruction_bertscore": {
      "es": "0.9676013985493994",
      "arb": "0.896529660541687",
      "sw": "0.9096853479383898",
      "tr": "0.9225164732924815",
      "vi": "0.9059383844305476"
    },
    "level": "",
    "test": "func testIsLuckyWord() {\nassert(isLuckyWord(\"hello\") == (false, 0))\nassert(isLuckyWord(\"swift\") == (false, 0))\nassert(isLuckyWord(\"programming\") == (false, 0))\nassert(isLuckyWord(\"apple\") == (false, 0))\nassert(isLuckyWord(\"banana\") == (true, 2))\nassert(isLuckyWord(\"challenge\") == (false, 0))\nassert(isLuckyWord(\"developer\") == (true, 2))\n}\n\ntestIsLuckyWord()",
    "entry_point": "isLuckyWord",
    "signature": "func isLuckyWord(_ word: String) -> (isLucky: Bool, difference: Int) {",
    "docstring": {
      "en": "\nDetermines if the given word is a \"Lucky Word.\" A word is considered lucky if the difference\nbetween the maximum and minimum character frequencies in the word is a prime number.\n\n- Parameters:\n- word: A string representing the word to be checked. Assumes only lowercase letters and a length less than 100.\n\n- Returns: A tuple containing a boolean indicating if the word is lucky, and an integer that is the difference\nbetween the max and min frequencies if the word is lucky, or 0 otherwise.\n\nExamples:\n>>> isLuckyWord(\"hello\")\n(false, 0)\n>>> isLuckyWord(\"banana\")\n(true, 2)\n",
      "es": "Determina si la palabra dada es una \"Palabra Afortunada\". Una palabra se considera afortunada si la diferencia entre las frecuencias máximas y mínimas de los caracteres en la palabra es un número primo.\n\n- Parámetros:\n- word: Una cadena que representa la palabra a verificar. Se asume que solo contiene letras minúsculas y una longitud menor a 100.\n\n- Devuelve: Una tupla que contiene un booleano que indica si la palabra es afortunada, y un entero que es la diferencia entre las frecuencias máxima y mínima si la palabra es afortunada, o 0 en caso contrario.\n\nEjemplos:\n>>> isLuckyWord(\"hello\")\n(false, 0)\n>>> isLuckyWord(\"banana\")\n(true, 2)",
      "arb": "يحدد ما إذا كانت الكلمة المعطاة هي \"كلمة محظوظة\". تعتبر الكلمة محظوظة إذا كان الفرق بين تكرارات الأحرف القصوى والدنيا في الكلمة هو عدد أولي.\n\n- المعاملات:\n- word: سلسلة تمثل الكلمة التي سيتم التحقق منها. يُفترض أنها تحتوي فقط على أحرف صغيرة وطولها أقل من 100.\n\n- العوائد: زوج يحتوي على قيمة منطقية تشير إلى ما إذا كانت الكلمة محظوظة، وعدد صحيح يمثل الفرق بين التكرارات القصوى والدنيا إذا كانت الكلمة محظوظة، أو 0 خلاف ذلك.\n\nأمثلة:\n>>> isLuckyWord(\"hello\")\n(false, 0)\n>>> isLuckyWord(\"banana\")\n(true, 2)",
      "sw": "Inabainisha kama neno lililopeanwa ni \"Neno la Bahati.\" Neno linachukuliwa kuwa la bahati ikiwa tofauti\nkati ya masafa ya herufi ya juu zaidi na ya chini zaidi katika neno ni namba ya kwanza.\n\n- Vigezo:\n- word: Kamba inayowakilisha neno litakalokaguliwa. Inadhaniwa kuwa na herufi ndogo pekee na urefu chini ya 100.\n\n- Inarejesha: Jozi inayojumuisha boolean inayoonyesha kama neno ni la bahati, na nambari ambayo ni tofauti\nkati ya masafa ya juu na ya chini ikiwa neno ni la bahati, au 0 vinginevyo.\n\nMifano:\n>>> isLuckyWord(\"hello\")\n(false, 0)\n>>> isLuckyWord(\"banana\")\n(true, 2)",
      "tr": "Verilen kelimenin \"Şanslı Kelime\" olup olmadığını belirler. Bir kelime, kelimedeki maksimum ve minimum karakter frekansları arasındaki fark bir asal sayı ise şanslı kabul edilir.\n\n- Parametreler:\n- word: Kontrol edilecek kelimeyi temsil eden bir string. Sadece küçük harfler ve 100'den küçük bir uzunluk içerdiği varsayılır.\n\n- Döndürür: Kelimenin şanslı olup olmadığını belirten bir boolean ve kelime şanslıysa maksimum ve minimum frekanslar arasındaki farkı, aksi takdirde 0 olan bir tamsayı içeren bir demet.\n\nÖrnekler:\n>>> isLuckyWord(\"hello\")\n(false, 0)\n>>> isLuckyWord(\"banana\")\n(true, 2)",
      "vi": "Xác định xem từ đã cho có phải là \"Từ May Mắn\" hay không. Một từ được coi là may mắn nếu sự khác biệt giữa tần suất ký tự tối đa và tối thiểu trong từ là một số nguyên tố.\n\n- Tham số:\n- word: Một chuỗi đại diện cho từ cần kiểm tra. Giả sử chỉ có chữ cái thường và độ dài nhỏ hơn 100.\n\n- Trả về: Một bộ giá trị chứa một boolean chỉ ra nếu từ là may mắn, và một số nguyên là sự khác biệt giữa tần suất tối đa và tối thiểu nếu từ là may mắn, hoặc 0 nếu không.\n\nVí dụ:\n>>> isLuckyWord(\"hello\")\n(false, 0)\n>>> isLuckyWord(\"banana\")\n(true, 2)"
    },
    "docstring_bertscore": {
      "es": "0.9711717796485015",
      "arb": "0.9611119453706085",
      "sw": "0.9405972009869442",
      "tr": "0.9665979178644112",
      "vi": "0.9746458250128017"
    }
  },
  {
    "task_id": "Swift/33",
    "prompt": {
      "en": "import Foundation\n\nfunc maxSubArraySum(_ nums: [Int]) -> Int {\n\n/**\nFinds the maximum sum of a contiguous subarray in an array of integers.\n\n- Parameters:\n- nums: An array of integers.\n\n- Returns: The maximum sum of any contiguous subarray.\n\nExamples:\n>>> maxSubArraySum([1, -2, 3, 4, -1, 2, 1, -5, 4])\n9 // [3, 4, -1, 2, 1] sums to 9\n\n>>> maxSubArraySum([-2, -3, -1])\n-1 // [-1] is the largest sum in the array\n\n>>> maxSubArraySum([5, -3, 5])\n7 // [5, -3, 5] sums to 7\n*/",
      "es": "import Foundation\n\nfunc maxSubArraySum(_ nums: [Int]) -> Int {\n\n/**\nEncuentra la suma máxima de un subarray contiguo en un array de enteros.\n\n- Parámetros:\n- nums: Un array de enteros.\n\n- Retorna: La suma máxima de cualquier subarray contiguo.\n\nEjemplos:\n>>> maxSubArraySum([1, -2, 3, 4, -1, 2, 1, -5, 4])\n9 // [3, 4, -1, 2, 1] suma 9\n\n>>> maxSubArraySum([-2, -3, -1])\n-1 // [-1] es la mayor suma en el array\n\n>>> maxSubArraySum([5, -3, 5])\n7 // [5, -3, 5] suma 7\n*/",
      "arb": "import Foundation\n\nfunc maxSubArraySum(_ nums: [Int]) -> Int {\n\n/**\nيعثر على أكبر مجموع لمصفوفة فرعية متجاورة في مصفوفة من الأعداد الصحيحة.\n\n- Parameters:\n- nums: مصفوفة من الأعداد الصحيحة.\n\n- Returns: أكبر مجموع لأي مصفوفة فرعية متجاورة.\n\nأمثلة:\n>>> maxSubArraySum([1, -2, 3, 4, -1, 2, 1, -5, 4])\n9 // [3, 4, -1, 2, 1] مجموعها 9\n\n>>> maxSubArraySum([-2, -3, -1])\n-1 // [-1] هو أكبر مجموع في المصفوفة\n\n>>> maxSubArraySum([5, -3, 5])\n7 // [5, -3, 5] مجموعها 7\n*/",
      "sw": "import Foundation\n\nfunc maxSubArraySum(_ nums: [Int]) -> Int {\n\n/**\nInapata jumla ya juu zaidi ya subarray inayoendelea katika safu ya nambari za integer.\n\n- Vigezo:\n- nums: Safu ya nambari za integer.\n\n- Inarejesha: Jumla ya juu zaidi ya subarray yoyote inayoendelea.\n\nMifano:\n>>> maxSubArraySum([1, -2, 3, 4, -1, 2, 1, -5, 4])\n9 // [3, 4, -1, 2, 1] inajumlisha hadi 9\n\n>>> maxSubArraySum([-2, -3, -1])\n-1 // [-1] ndiyo jumla kubwa zaidi katika safu\n\n>>> maxSubArraySum([5, -3, 5])\n7 // [5, -3, 5] inajumlisha hadi 7\n*/",
      "tr": "import Foundation\n\nfunc maxSubArraySum(_ nums: [Int]) -> Int {\n\n/**\nBir tamsayı dizisindeki bitişik alt dizinin maksimum toplamını bulur.\n\n- Parametreler:\n- nums: Bir tamsayı dizisi.\n\n- Döndürür: Herhangi bir bitişik alt dizinin maksimum toplamı.\n\nÖrnekler:\n>>> maxSubArraySum([1, -2, 3, 4, -1, 2, 1, -5, 4])\n9 // [3, 4, -1, 2, 1] toplamı 9 eder\n\n>>> maxSubArraySum([-2, -3, -1])\n-1 // [-1] dizideki en büyük toplamdır\n\n>>> maxSubArraySum([5, -3, 5])\n7 // [5, -3, 5] toplamı 7 eder\n*/",
      "vi": "import Foundation\n\nfunc maxSubArraySum(_ nums: [Int]) -> Int {\n\n/**\nTìm tổng lớn nhất của một mảng con liên tiếp trong một mảng số nguyên.\n\n- Tham số:\n- nums: Một mảng số nguyên.\n\n- Trả về: Tổng lớn nhất của bất kỳ mảng con liên tiếp nào.\n\nVí dụ:\n>>> maxSubArraySum([1, -2, 3, 4, -1, 2, 1, -5, 4])\n9 // [3, 4, -1, 2, 1] có tổng là 9\n\n>>> maxSubArraySum([-2, -3, -1])\n-1 // [-1] là tổng lớn nhất trong mảng\n\n>>> maxSubArraySum([5, -3, 5])\n7 // [5, -3, 5] có tổng là 7\n*/"
    },
    "prompt_bertscore": {
      "es": "1",
      "arb": "0.992108812222246",
      "sw": "0.9822954782472173",
      "tr": "0.9686553313511705",
      "vi": "0.971704109069675"
    },
    "canonical_solution": "var maxSoFar = nums[0]\nvar currentMax = nums[0]\n\nfor num in nums.dropFirst() {\ncurrentMax = max(num, currentMax + num)\nmaxSoFar = max(maxSoFar, currentMax)\n}\n\nreturn maxSoFar\n}",
    "instruction": {
      "en": "func maxSubArraySum(_ nums: [Int]) -> Int {\nvar maxSoFar = nums[0]\nvar currentMax = nums[0]\n\nfor num in nums.dropFirst() {\ncurrentMax = max(num, currentMax + num)\nmaxSoFar = max(maxSoFar, currentMax)\n}\n\nreturn maxSoFar\n}\n\nProvide a concise natural language description (docstring) of the Swift code in English using at most 500 characters.",
      "es": "func maxSubArraySum(_ nums: [Int]) -> Int {\nvar maxSoFar = nums[0]\nvar currentMax = nums[0]\n\nfor num in nums.dropFirst() {\ncurrentMax = max(num, currentMax + num)\nmaxSoFar = max(maxSoFar, currentMax)\n}\n\nreturn maxSoFar\n}\n\nProporcione una descripción concisa en lenguaje natural (docstring) del código Swift en español utilizando un máximo de 500 caracteres.",
      "arb": "func maxSubArraySum(_ nums: [Int]) -> Int {\nvar maxSoFar = nums[0]\nvar currentMax = nums[0]\n\nfor num in nums.dropFirst() {\ncurrentMax = max(num, currentMax + num)\nmaxSoFar = max(maxSoFar, currentMax)\n}\n\nreturn maxSoFar\n}\n\nقدم وصفًا موجزًا بلغة طبيعية (docstring) لكود Swift باللغة العربية الفصحى باستخدام 500 حرف كحد أقصى.",
      "sw": "func maxSubArraySum(_ nums: [Int]) -> Int {\nvar maxSoFar = nums[0]\nvar currentMax = nums[0]\n\nfor num in nums.dropFirst() {\ncurrentMax = max(num, currentMax + num)\nmaxSoFar = max(maxSoFar, currentMax)\n}\n\nreturn maxSoFar\n}\n\nToa maelezo mafupi ya lugha ya asili (docstring) ya msimbo wa Swift kwa Kiswahili kwa kutumia herufi zisizozidi 500.",
      "tr": "func maxSubArraySum(_ nums: [Int]) -> Int {\nvar maxSoFar = nums[0]\nvar currentMax = nums[0]\n\nfor num in nums.dropFirst() {\ncurrentMax = max(num, currentMax + num)\nmaxSoFar = max(maxSoFar, currentMax)\n}\n\nreturn maxSoFar\n}\n\nSwift kodunun işlevini açıklayan kısa bir doğal dil tanımı (docstring) sağlayın. Açıklama Türkçe olmalı ve en fazla 500 karakter içermelidir.",
      "vi": "func maxSubArraySum(_ nums: [Int]) -> Int {\nvar maxSoFar = nums[0]\nvar currentMax = nums[0]\n\nfor num in nums.dropFirst() {\ncurrentMax = max(num, currentMax + num)\nmaxSoFar = max(maxSoFar, currentMax)\n}\n\nreturn maxSoFar\n}\n\nCung cấp mô tả ngắn gọn bằng ngôn ngữ tự nhiên (docstring) cho mã Swift bằng tiếng Việt với tối đa 500 ký tự."
    },
    "instruction_bertscore": {
      "es": "0.9676013985493994",
      "arb": "0.9017943587910168",
      "sw": "0.9148419912604365",
      "tr": "0.8726445558526228",
      "vi": "0.8999953634299838"
    },
    "level": "",
    "test": "func check(_ maxSubArraySum: ([Int]) -> Int) {\nassert(maxSubArraySum([1, -2, 3, 4, -1, 2, 1, -5, 4]) == 9)\nassert(maxSubArraySum([-2, -3, -1]) == -1)\nassert(maxSubArraySum([5, -3, 5]) == 7)\nassert(maxSubArraySum([-1, -2, -3, -4]) == -1)\nassert(maxSubArraySum([2, 3, -2, 5, -3]) == 8)\nassert(maxSubArraySum([10, -11, 12]) == 12)\nassert(maxSubArraySum([-2, 1, -3, 4, -1, 2, 1, -5, 4]) == 6)\n}\n\ncheck(maxSubArraySum)",
    "entry_point": "maxSubArraySum",
    "signature": "func maxSubArraySum(_ nums: [Int]) -> Int {",
    "docstring": {
      "en": "\nFinds the maximum sum of a contiguous subarray in an array of integers.\n\n- Parameters:\n- nums: An array of integers.\n\n- Returns: The maximum sum of any contiguous subarray.\n\nExamples:\n>>> maxSubArraySum([1, -2, 3, 4, -1, 2, 1, -5, 4])\n9 // [3, 4, -1, 2, 1] sums to 9\n\n>>> maxSubArraySum([-2, -3, -1])\n-1 // [-1] is the largest sum in the array\n\n>>> maxSubArraySum([5, -3, 5])\n7 // [5, -3, 5] sums to 7\n",
      "es": "Encuentra la suma máxima de un subarreglo contiguo en un arreglo de enteros.\n\n- Parámetros:\n- nums: Un arreglo de enteros.\n\n- Devuelve: La suma máxima de cualquier subarreglo contiguo.\n\nEjemplos:\n>>> maxSubArraySum([1, -2, 3, 4, -1, 2, 1, -5, 4])\n9 // [3, 4, -1, 2, 1] suma 9\n\n>>> maxSubArraySum([-2, -3, -1])\n-1 // [-1] es la mayor suma en el arreglo\n\n>>> maxSubArraySum([5, -3, 5])\n7 // [5, -3, 5] suma 7",
      "arb": "يجد أكبر مجموع لمصفوفة فرعية متجاورة في مصفوفة من الأعداد الصحيحة.\n\n- المعلمات:\n- nums: مصفوفة من الأعداد الصحيحة.\n\n- يعيد: أكبر مجموع لأي مصفوفة فرعية متجاورة.\n\nأمثلة:\n>>> maxSubArraySum([1, -2, 3, 4, -1, 2, 1, -5, 4])\n9 // [3, 4, -1, 2, 1] مجموعها 9\n\n>>> maxSubArraySum([-2, -3, -1])\n-1 // [-1] هو أكبر مجموع في المصفوفة\n\n>>> maxSubArraySum([5, -3, 5])\n7 // [5, -3, 5] مجموعها 7",
      "sw": "Inapata jumla ya juu zaidi ya subarray inayoendelea katika safu ya nambari za mzima.\n\n- Vigezo:\n- nums: Safu ya nambari za mzima.\n\n- Inarudisha: Jumla ya juu zaidi ya subarray yoyote inayoendelea.\n\nMifano:\n>>> maxSubArraySum([1, -2, 3, 4, -1, 2, 1, -5, 4])\n9 // [3, 4, -1, 2, 1] inajumlisha hadi 9\n\n>>> maxSubArraySum([-2, -3, -1])\n-1 // [-1] ndiyo jumla kubwa zaidi katika safu\n\n>>> maxSubArraySum([5, -3, 5])\n7 // [5, -3, 5] inajumlisha hadi 7",
      "tr": "Bir tamsayı dizisindeki ardışık alt dizinin maksimum toplamını bulur.\n\n- Parametreler:\n- nums: Bir tamsayı dizisi.\n\n- Döndürür: Herhangi bir ardışık alt dizinin maksimum toplamı.\n\nÖrnekler:\n>>> maxSubArraySum([1, -2, 3, 4, -1, 2, 1, -5, 4])\n9 // [3, 4, -1, 2, 1] toplamı 9 eder\n\n>>> maxSubArraySum([-2, -3, -1])\n-1 // [-1] dizideki en büyük toplamdır\n\n>>> maxSubArraySum([5, -3, 5])\n7 // [5, -3, 5] toplamı 7 eder",
      "vi": "Tìm tổng lớn nhất của một mảng con liền kề trong một mảng số nguyên.\n\n- Tham số:\n- nums: Một mảng các số nguyên.\n\n- Trả về: Tổng lớn nhất của bất kỳ mảng con liền kề nào.\n\nVí dụ:\n>>> maxSubArraySum([1, -2, 3, 4, -1, 2, 1, -5, 4])\n9 // [3, 4, -1, 2, 1] có tổng là 9\n\n>>> maxSubArraySum([-2, -3, -1])\n-1 // [-1] là tổng lớn nhất trong mảng\n\n>>> maxSubArraySum([5, -3, 5])\n7 // [5, -3, 5] có tổng là 7"
    },
    "docstring_bertscore": {
      "es": "0.98044384583521",
      "arb": "0.9850584268474126",
      "sw": "0.9927660801530904",
      "tr": "0.9660020267213064",
      "vi": "0.9702487442678324"
    }
  },
  {
    "task_id": "Swift/34",
    "prompt": {
      "en": "import Foundation\n\nfunc convertNumber(fromBase: Int, number: String, toBase: Int) -> String {\n/**\nConverts a number from one base to another. The bases can range from 2 to 16.\n\n- Parameters:\n- fromBase: The base of the input number (between 2 and 16 inclusive).\n- number: The number in string format to be converted. For bases greater than 10, \nit uses uppercase letters A to F.\n- toBase: The base to which the number is to be converted (between 2 and 16 inclusive).\n\n- Returns: A string representing the converted number in the new base.\n\nExamples:\n>>> convertNumber(fromBase: 10, number: \"255\", toBase: 2)\n\"11111111\"\n>>> convertNumber(fromBase: 2, number: \"1010\", toBase: 10)\n\"10\"\n>>> convertNumber(fromBase: 8, number: \"175\", toBase: 16)\n\"7D\"\n*/",
      "es": "import Foundation\n\nfunc convertNumber(fromBase: Int, number: String, toBase: Int) -> String {\n/**\nConvierte un número de una base a otra. Las bases pueden variar de 2 a 16.\n\n- Parámetros:\n- fromBase: La base del número de entrada (entre 2 y 16 inclusive).\n- number: El número en formato de cadena que se va a convertir. Para bases mayores que 10,\nutiliza letras mayúsculas de la A a la F.\n- toBase: La base a la que se va a convertir el número (entre 2 y 16 inclusive).\n\n- Retorna: Una cadena que representa el número convertido en la nueva base.\n\nEjemplos:\n>>> convertNumber(fromBase: 10, number: \"255\", toBase: 2)\n\"11111111\"\n>>> convertNumber(fromBase: 2, number: \"1010\", toBase: 10)\n\"10\"\n>>> convertNumber(fromBase: 8, number: \"175\", toBase: 16)\n\"7D\"\n*/",
      "arb": "import Foundation\n\nfunc convertNumber(fromBase: Int, number: String, toBase: Int) -> String {\n/**\nتحول رقمًا من قاعدة إلى أخرى. يمكن أن تتراوح القواعد من 2 إلى 16.\n\n- Parameters:\n- fromBase: قاعدة الرقم المدخل (بين 2 و 16 شامل).\n- number: الرقم بصيغة سلسلة ليتم تحويله. للقواعد الأكبر من 10، \nيستخدم الأحرف الكبيرة من A إلى F.\n- toBase: القاعدة التي سيتم تحويل الرقم إليها (بين 2 و 16 شامل).\n\n- Returns: سلسلة تمثل الرقم المحول في القاعدة الجديدة.\n\nأمثلة:\n>>> convertNumber(fromBase: 10, number: \"255\", toBase: 2)\n\"11111111\"\n>>> convertNumber(fromBase: 2, number: \"1010\", toBase: 10)\n\"10\"\n>>> convertNumber(fromBase: 8, number: \"175\", toBase: 16)\n\"7D\"\n*/",
      "sw": "import Foundation\n\nfunc convertNumber(fromBase: Int, number: String, toBase: Int) -> String {\n/**\nInabadilisha nambari kutoka msingi mmoja hadi mwingine. Misingi inaweza kuwa kati ya 2 hadi 16.\n\n- Parameters:\n- fromBase: Msingi wa nambari ya ingizo (kati ya 2 na 16 ikijumuisha).\n- number: Nambari katika muundo wa kamba ya maandishi inayopaswa kubadilishwa. Kwa misingi zaidi ya 10, \ninatumia herufi kubwa A hadi F.\n- toBase: Msingi ambao nambari itabadilishwa (kati ya 2 na 16 ikijumuisha).\n\n- Returns: Kamba ya maandishi inayowakilisha nambari iliyobadilishwa katika msingi mpya.\n\nMifano:\n>>> convertNumber(fromBase: 10, number: \"255\", toBase: 2)\n\"11111111\"\n>>> convertNumber(fromBase: 2, number: \"1010\", toBase: 10)\n\"10\"\n>>> convertNumber(fromBase: 8, number: \"175\", toBase: 16)\n\"7D\"\n*/",
      "tr": "import Foundation\n\nfunc convertNumber(fromBase: Int, number: String, toBase: Int) -> String {\n/**\nBir sayıyı bir tabandan diğerine dönüştürür. Tabanlar 2 ile 16 arasında olabilir.\n\n- Parametreler:\n- fromBase: Girdi sayısının tabanı (2 ile 16 dahil arasında).\n- number: Dönüştürülecek sayının string formatı. 10'dan büyük tabanlar için \nA'dan F'ye kadar büyük harfler kullanılır.\n- toBase: Sayının dönüştürüleceği taban (2 ile 16 dahil arasında).\n\n- Döndürür: Yeni tabanda dönüştürülmüş sayıyı temsil eden bir string.\n\nÖrnekler:\n>>> convertNumber(fromBase: 10, number: \"255\", toBase: 2)\n\"11111111\"\n>>> convertNumber(fromBase: 2, number: \"1010\", toBase: 10)\n\"10\"\n>>> convertNumber(fromBase: 8, number: \"175\", toBase: 16)\n\"7D\"\n*/",
      "vi": "import Foundation\n\nfunc convertNumber(fromBase: Int, number: String, toBase: Int) -> String {\n/**\nChuyển đổi một số từ một hệ cơ số này sang một hệ cơ số khác. Các hệ cơ số có thể từ 2 đến 16.\n\n- Tham số:\n- fromBase: Hệ cơ số của số đầu vào (từ 2 đến 16 bao gồm cả hai).\n- number: Số ở định dạng chuỗi cần được chuyển đổi. Đối với các hệ cơ số lớn hơn 10, \nnó sử dụng các chữ cái in hoa từ A đến F.\n- toBase: Hệ cơ số mà số cần được chuyển đổi sang (từ 2 đến 16 bao gồm cả hai).\n\n- Trả về: Một chuỗi đại diện cho số đã được chuyển đổi sang hệ cơ số mới.\n\nVí dụ:\n>>> convertNumber(fromBase: 10, number: \"255\", toBase: 2)\n\"11111111\"\n>>> convertNumber(fromBase: 2, number: \"1010\", toBase: 10)\n\"10\"\n>>> convertNumber(fromBase: 8, number: \"175\", toBase: 16)\n\"7D\"\n*/"
    },
    "prompt_bertscore": {
      "es": "0.9876461834515351",
      "arb": "0.987605861484185",
      "sw": "0.9846037619052237",
      "tr": "0.9681226046692349",
      "vi": "0.9821043958206618"
    },
    "canonical_solution": "let decimalValue = Int(number, radix: fromBase)!\nlet convertedNumber = String(decimalValue, radix: toBase).uppercased()\nreturn convertedNumber\n}",
    "instruction": {
      "en": "func convertNumber(fromBase: Int, number: String, toBase: Int) -> String {\nlet decimalValue = Int(number, radix: fromBase)!\nlet convertedNumber = String(decimalValue, radix: toBase).uppercased()\nreturn convertedNumber\n}\n\nProvide a concise natural language description (docstring) of the Swift code in English using at most 500 characters.",
      "es": "func convertNumber(fromBase: Int, number: String, toBase: Int) -> String {\nlet decimalValue = Int(number, radix: fromBase)!\nlet convertedNumber = String(decimalValue, radix: toBase).uppercased()\nreturn convertedNumber\n}\n\nProporcione una descripción concisa en lenguaje natural (docstring) del código Swift en español utilizando un máximo de 500 caracteres.",
      "arb": "func convertNumber(fromBase: Int, number: String, toBase: Int) -> String {\nlet decimalValue = Int(number, radix: fromBase)!\nlet convertedNumber = String(decimalValue, radix: toBase).uppercased()\nreturn convertedNumber\n}\n\nقدم وصفًا موجزًا بلغة طبيعية (docstring) لكود Swift باللغة العربية الفصحى باستخدام ما لا يزيد عن 500 حرف.",
      "sw": "func convertNumber(fromBase: Int, number: String, toBase: Int) -> String {\nlet decimalValue = Int(number, radix: fromBase)!\nlet convertedNumber = String(decimalValue, radix: toBase).uppercased()\nreturn convertedNumber\n}\n\nToa maelezo mafupi ya lugha asilia (docstring) ya msimbo wa Swift kwa Kiswahili kwa kutumia herufi zisizozidi 500.",
      "tr": "func convertNumber(fromBase: Int, number: String, toBase: Int) -> String {\nlet decimalValue = Int(number, radix: fromBase)!\nlet convertedNumber = String(decimalValue, radix: toBase).uppercased()\nreturn convertedNumber\n}\n\nSwift kodunun Türkçe olarak en fazla 500 karakter kullanarak doğal dilde kısa bir açıklamasını (docstring) sağlayın.",
      "vi": "func convertNumber(fromBase: Int, number: String, toBase: Int) -> String {\nlet decimalValue = Int(number, radix: fromBase)!\nlet convertedNumber = String(decimalValue, radix: toBase).uppercased()\nreturn convertedNumber\n}\n\nCung cấp mô tả ngắn gọn bằng ngôn ngữ tự nhiên (docstring) cho mã Swift bằng tiếng Việt, sử dụng tối đa 500 ký tự."
    },
    "instruction_bertscore": {
      "es": "0.9676013985493994",
      "arb": "0.8880608556158835",
      "sw": "0.942496901951162",
      "tr": "0.8932459030824184",
      "vi": "0.9172950764662174"
    },
    "level": "",
    "test": "func check(_ convertNumber: (Int, String, Int) -> String) {\nassert(convertNumber(10, \"255\", 2) == \"11111111\")\nassert(convertNumber(2, \"1010\", 10) == \"10\")\nassert(convertNumber(8, \"175\", 16) == \"7D\")\nassert(convertNumber(16, \"1A\", 10) == \"26\")\nassert(convertNumber(2, \"1111\", 16) == \"F\")\nassert(convertNumber(16, \"FF\", 8) == \"377\")\nassert(convertNumber(10, \"1000\", 16) == \"3E8\")\n}\n\ncheck(convertNumber)",
    "entry_point": "convertNumber",
    "signature": "func convertNumber(fromBase: Int, number: String, toBase: Int) -> String {",
    "docstring": {
      "en": "\nConverts a number from one base to another. The bases can range from 2 to 16.\n\n- Parameters:\n- fromBase: The base of the input number (between 2 and 16 inclusive).\n- number: The number in string format to be converted. For bases greater than 10, \nit uses uppercase letters A to F.\n- toBase: The base to which the number is to be converted (between 2 and 16 inclusive).\n\n- Returns: A string representing the converted number in the new base.\n\nExamples:\n>>> convertNumber(fromBase: 10, number: \"255\", toBase: 2)\n\"11111111\"\n>>> convertNumber(fromBase: 2, number: \"1010\", toBase: 10)\n\"10\"\n>>> convertNumber(fromBase: 8, number: \"175\", toBase: 16)\n\"7D\"\n",
      "es": "Convierte un número de una base a otra. Las bases pueden variar de 2 a 16.\n\n- Parámetros:\n- fromBase: La base del número de entrada (entre 2 y 16 inclusive).\n- number: El número en formato de cadena que se va a convertir. Para bases mayores que 10,\nutiliza letras mayúsculas de la A a la F.\n- toBase: La base a la que se va a convertir el número (entre 2 y 16 inclusive).\n\n- Retorna: Una cadena que representa el número convertido en la nueva base.\n\nEjemplos:\n>>> convertNumber(fromBase: 10, number: \"255\", toBase: 2)\n\"11111111\"\n>>> convertNumber(fromBase: 2, number: \"1010\", toBase: 10)\n\"10\"\n>>> convertNumber(fromBase: 8, number: \"175\", toBase: 16)\n\"7D\"",
      "arb": "تحول رقمًا من قاعدة إلى أخرى. يمكن أن تتراوح القواعد من 2 إلى 16.\n\n- المعلمات:\n- fromBase: قاعدة الرقم المدخل (بين 2 و 16 شاملًا).\n- number: الرقم بصيغة سلسلة ليتم تحويله. للقواعد الأكبر من 10، \nيستخدم الحروف الكبيرة من A إلى F.\n- toBase: القاعدة التي سيتم تحويل الرقم إليها (بين 2 و 16 شاملًا).\n\n- يعيد: سلسلة تمثل الرقم المحول في القاعدة الجديدة.\n\nأمثلة:\n>>> convertNumber(fromBase: 10, number: \"255\", toBase: 2)\n\"11111111\"\n>>> convertNumber(fromBase: 2, number: \"1010\", toBase: 10)\n\"10\"\n>>> convertNumber(fromBase: 8, number: \"175\", toBase: 16)\n\"7D\"",
      "sw": "Inabadilisha nambari kutoka msingi mmoja hadi mwingine. Misingi inaweza kuwa kati ya 2 hadi 16.\n\n- Vigezo:\n- fromBase: Msingi wa nambari ya ingizo (kati ya 2 na 16 ikijumuisha).\n- number: Nambari katika umbizo la kamba ya maandishi itakayobadilishwa. Kwa misingi zaidi ya 10, \ninatumia herufi kubwa A hadi F.\n- toBase: Msingi ambao nambari itabadilishwa (kati ya 2 na 16 ikijumuisha).\n\n- Inarudisha: Kamba inayowakilisha nambari iliyobadilishwa katika msingi mpya.\n\nMifano:\n>>> convertNumber(fromBase: 10, number: \"255\", toBase: 2)\n\"11111111\"\n>>> convertNumber(fromBase: 2, number: \"1010\", toBase: 10)\n\"10\"\n>>> convertNumber(fromBase: 8, number: \"175\", toBase: 16)\n\"7D\"",
      "tr": "Bir sayıyı bir tabandan başka bir tabana dönüştürür. Tabanlar 2 ile 16 arasında olabilir.\n\n- Parametreler:\n- fromBase: Girdi sayısının tabanı (2 ile 16 arasında dahil).\n- number: Dönüştürülecek olan sayının string formatındaki hali. 10'dan büyük tabanlar için, \nA'dan F'ye kadar büyük harfler kullanılır.\n- toBase: Sayının dönüştürüleceği taban (2 ile 16 arasında dahil).\n\n- Döndürür: Yeni tabandaki dönüştürülmüş sayıyı temsil eden bir string.\n\nÖrnekler:\n>>> convertNumber(fromBase: 10, number: \"255\", toBase: 2)\n\"11111111\"\n>>> convertNumber(fromBase: 2, number: \"1010\", toBase: 10)\n\"10\"\n>>> convertNumber(fromBase: 8, number: \"175\", toBase: 16)\n\"7D\"",
      "vi": "Chuyển đổi một số từ một hệ cơ số này sang hệ cơ số khác. Các hệ cơ số có thể nằm trong khoảng từ 2 đến 16.\n\n- Tham số:\n- fromBase: Hệ cơ số của số đầu vào (từ 2 đến 16 bao gồm cả hai).\n- number: Số ở định dạng chuỗi cần được chuyển đổi. Đối với các hệ cơ số lớn hơn 10, \nnó sử dụng các chữ cái in hoa từ A đến F.\n- toBase: Hệ cơ số mà số sẽ được chuyển đổi sang (từ 2 đến 16 bao gồm cả hai).\n\n- Trả về: Một chuỗi đại diện cho số đã được chuyển đổi trong hệ cơ số mới.\n\nVí dụ:\n>>> convertNumber(fromBase: 10, number: \"255\", toBase: 2)\n\"11111111\"\n>>> convertNumber(fromBase: 2, number: \"1010\", toBase: 10)\n\"10\"\n>>> convertNumber(fromBase: 8, number: \"175\", toBase: 16)\n\"7D\""
    },
    "docstring_bertscore": {
      "es": "0.9856561056639466",
      "arb": "0.9838018910569859",
      "sw": "0.9837466718110582",
      "tr": "0.9626958240289808",
      "vi": "0.9822376768063361"
    }
  },
  {
    "task_id": "Swift/35",
    "prompt": {
      "en": "import Foundation\nfunc kthUniqueSmallestNumber(_ numbers: [Int], _ k: Int) -> String {\n/**\nFinds the kth smallest unique number from a given list of integers. If two numbers are the same,\nthey are considered as one unique number. If the kth smallest unique number does not exist, returns \"NO RESULT\".\n\n- Parameters:\n- numbers: An array of integers.\n- k: The order of the smallest unique number to find.\n\n- Returns: A String representing the kth smallest unique number or \"NO RESULT\" if it doesn't exist.\n\nExamples:\n>>> kthUniqueSmallestNumber([5, 3, 9, 3, 5, 7, 2], 2)\n\"3\"\n\n>>> kthUniqueSmallestNumber([8, 1, 2, 2, 3, 4, 4, 6], 4)\n\"4\"\n\n>>> kthUniqueSmallestNumber([10, 20, 30], 4)\n\"NO RESULT\"\n*/",
      "es": "import Foundation\nfunc kthUniqueSmallestNumber(_ numbers: [Int], _ k: Int) -> String {\n/**\nEncuentra el k-ésimo número único más pequeño de una lista dada de enteros. Si dos números son iguales,\nse consideran como un solo número único. Si el k-ésimo número único más pequeño no existe, devuelve \"NO RESULT\".\n\n- Parámetros:\n- numbers: Un array de enteros.\n- k: El orden del número único más pequeño a encontrar.\n\n- Retorna: Un String que representa el k-ésimo número único más pequeño o \"NO RESULT\" si no existe.\n\nEjemplos:\n>>> kthUniqueSmallestNumber([5, 3, 9, 3, 5, 7, 2], 2)\n\"3\"\n\n>>> kthUniqueSmallestNumber([8, 1, 2, 2, 3, 4, 4, 6], 4)\n\"4\"\n\n>>> kthUniqueSmallestNumber([10, 20, 30], 4)\n\"NO RESULT\"\n*/",
      "arb": "import Foundation\nfunc kthUniqueSmallestNumber(_ numbers: [Int], _ k: Int) -> String {\n/**\nيجد العدد الفريد الأصغر بالترتيب k من قائمة الأعداد الصحيحة المعطاة. إذا كان هناك رقمان متشابهان،\nيعتبران كعدد فريد واحد. إذا لم يوجد العدد الفريد الأصغر بالترتيب k، يتم إرجاع \"NO RESULT\".\n\n- Parameters:\n- numbers: مصفوفة من الأعداد الصحيحة.\n- k: ترتيب العدد الفريد الأصغر المطلوب إيجاده.\n\n- Returns: سلسلة نصية تمثل العدد الفريد الأصغر بالترتيب k أو \"NO RESULT\" إذا لم يكن موجودًا.\n\nأمثلة:\n>>> kthUniqueSmallestNumber([5, 3, 9, 3, 5, 7, 2], 2)\n\"3\"\n\n>>> kthUniqueSmallestNumber([8, 1, 2, 2, 3, 4, 4, 6], 4)\n\"4\"\n\n>>> kthUniqueSmallestNumber([10, 20, 30], 4)\n\"NO RESULT\"\n*/",
      "sw": "import Foundation\nfunc kthUniqueSmallestNumber(_ numbers: [Int], _ k: Int) -> String {\n/**\nInapata nambari ya kipekee ya k ndogo zaidi kutoka kwenye orodha iliyotolewa ya nambari za mzima. Ikiwa nambari mbili ni sawa,\nzinachukuliwa kama nambari moja ya kipekee. Ikiwa nambari ya kipekee ya k ndogo zaidi haipo, inarudisha \"NO RESULT\".\n\n- Parameters:\n- numbers: Orodha ya nambari za mzima.\n- k: Mpangilio wa nambari ya kipekee ndogo zaidi ya kutafuta.\n\n- Returns: Mstari unaowakilisha nambari ya kipekee ya k ndogo zaidi au \"NO RESULT\" ikiwa haipo.\n\nMifano:\n>>> kthUniqueSmallestNumber([5, 3, 9, 3, 5, 7, 2], 2)\n\"3\"\n\n>>> kthUniqueSmallestNumber([8, 1, 2, 2, 3, 4, 4, 6], 4)\n\"4\"\n\n>>> kthUniqueSmallestNumber([10, 20, 30], 4)\n\"NO RESULT\"\n*/",
      "tr": "import Foundation\nfunc kthUniqueSmallestNumber(_ numbers: [Int], _ k: Int) -> String {\n/**\nVerilen bir tamsayı listesinden k. en küçük benzersiz sayıyı bulur. İki sayı aynıysa,\nbir benzersiz sayı olarak kabul edilirler. Eğer k. en küçük benzersiz sayı yoksa, \"NO RESULT\" döner.\n\n- Parametreler:\n- numbers: Bir tamsayı dizisi.\n- k: Bulunacak en küçük benzersiz sayının sırası.\n\n- Dönüş: k. en küçük benzersiz sayıyı veya yoksa \"NO RESULT\" döndüren bir String.\n\nÖrnekler:\n>>> kthUniqueSmallestNumber([5, 3, 9, 3, 5, 7, 2], 2)\n\"3\"\n\n>>> kthUniqueSmallestNumber([8, 1, 2, 2, 3, 4, 4, 6], 4)\n\"4\"\n\n>>> kthUniqueSmallestNumber([10, 20, 30], 4)\n\"NO RESULT\"\n*/",
      "vi": "import Foundation\nfunc kthUniqueSmallestNumber(_ numbers: [Int], _ k: Int) -> String {\n/**\nTìm số nhỏ nhất duy nhất thứ k từ một danh sách số nguyên cho trước. Nếu hai số giống nhau,\nchúng được coi là một số duy nhất. Nếu số nhỏ nhất duy nhất thứ k không tồn tại, trả về \"NO RESULT\".\n\n- Tham số:\n- numbers: Một mảng các số nguyên.\n- k: Thứ tự của số nhỏ nhất duy nhất cần tìm.\n\n- Trả về: Một chuỗi đại diện cho số nhỏ nhất duy nhất thứ k hoặc \"NO RESULT\" nếu không tồn tại.\n\nVí dụ:\n>>> kthUniqueSmallestNumber([5, 3, 9, 3, 5, 7, 2], 2)\n\"3\"\n\n>>> kthUniqueSmallestNumber([8, 1, 2, 2, 3, 4, 4, 6], 4)\n\"4\"\n\n>>> kthUniqueSmallestNumber([10, 20, 30], 4)\n\"NO RESULT\"\n*/"
    },
    "prompt_bertscore": {
      "es": "0.971875129827746",
      "arb": "0.9577296672423464",
      "sw": "0.9736878306850705",
      "tr": "0.9571780706742126",
      "vi": "0.9834540892597938"
    },
    "canonical_solution": "let uniqueNumbers = Set(numbers).sorted()\nif k > 0 && k <= uniqueNumbers.count {\nreturn \"\\(uniqueNumbers[k - 1])\"\n} else {\nreturn \"NO RESULT\"\n}\n}",
    "instruction": {
      "en": "func kthUniqueSmallestNumber(_ numbers: [Int], _ k: Int) -> String {\nlet uniqueNumbers = Set(numbers).sorted()\nif k > 0 && k <= uniqueNumbers.count {\nreturn \"\\(uniqueNumbers[k - 1])\"\n} else {\nreturn \"NO RESULT\"\n}\n}\n\nProvide a concise natural language description (docstring) of the Swift code in English using at most 500 characters.",
      "es": "func kthUniqueSmallestNumber(_ numbers: [Int], _ k: Int) -> String {\nlet uniqueNumbers = Set(numbers).sorted()\nif k > 0 && k <= uniqueNumbers.count {\nreturn \"\\(uniqueNumbers[k - 1])\"\n} else {\nreturn \"NO RESULT\"\n}\n}\n\nProporciona una descripción concisa en lenguaje natural (docstring) del código Swift en español utilizando un máximo de 500 caracteres.",
      "arb": "func kthUniqueSmallestNumber(_ numbers: [Int], _ k: Int) -> String {\nlet uniqueNumbers = Set(numbers).sorted()\nif k > 0 && k <= uniqueNumbers.count {\nreturn \"\\(uniqueNumbers[k - 1])\"\n} else {\nreturn \"NO RESULT\"\n}\n}\n\nقدم وصفًا موجزًا بلغة طبيعية (docstring) لكود Swift باللغة العربية الفصحى باستخدام 500 حرف كحد أقصى.",
      "sw": "func kthUniqueSmallestNumber(_ numbers: [Int], _ k: Int) -> String {\nlet uniqueNumbers = Set(numbers).sorted()\nif k > 0 && k <= uniqueNumbers.count {\nreturn \"\\(uniqueNumbers[k - 1])\"\n} else {\nreturn \"NO RESULT\"\n}\n}\n\nToa maelezo mafupi ya lugha ya asili (docstring) ya msimbo wa Swift kwa Kiswahili kwa kutumia herufi zisizozidi 500.",
      "tr": "func kthUniqueSmallestNumber(_ numbers: [Int], _ k: Int) -> String {\nlet uniqueNumbers = Set(numbers).sorted()\nif k > 0 && k <= uniqueNumbers.count {\nreturn \"\\(uniqueNumbers[k - 1])\"\n} else {\nreturn \"NO RESULT\"\n}\n}\n\nSwift kodunun işlevini açıklayan kısa bir doğal dil açıklaması (docstring) sağlayın. Açıklama, Türkçe dilinde ve en fazla 500 karakter uzunluğunda olmalıdır.",
      "vi": "func kthUniqueSmallestNumber(_ numbers: [Int], _ k: Int) -> String {\nlet uniqueNumbers = Set(numbers).sorted()\nif k > 0 && k <= uniqueNumbers.count {\nreturn \"\\(uniqueNumbers[k - 1])\"\n} else {\nreturn \"NO RESULT\"\n}\n}\n\nCung cấp mô tả ngắn gọn bằng ngôn ngữ tự nhiên (docstring) cho mã Swift bằng tiếng Việt với tối đa 500 ký tự."
    },
    "instruction_bertscore": {
      "es": "0.9676013985493994",
      "arb": "0.9337392884513337",
      "sw": "0.9148419912604365",
      "tr": "0.8581876408297605",
      "vi": "0.8999953634299838"
    },
    "level": "",
    "test": "func testKthUniqueSmallestNumber() {\nassert(kthUniqueSmallestNumber([5, 3, 9, 3, 5, 7, 2], 2) == \"3\")\nassert(kthUniqueSmallestNumber([8, 1, 2, 2, 3, 4, 4, 6], 4) == \"4\")\nassert(kthUniqueSmallestNumber([10, 20, 30], 4) == \"NO RESULT\")\nassert(kthUniqueSmallestNumber([1, 2, 3, 4, 5, 6, 7, 8, 9, 10], 7) == \"7\")\nassert(kthUniqueSmallestNumber([12, 15, 12, 18, 20, 22, 15, 18], 3) == \"18\")\nassert(kthUniqueSmallestNumber([3, 3, 3, 3, 3], 1) == \"3\")\nassert(kthUniqueSmallestNumber([40, 30, 20, 10], 2) == \"20\")\n}\n\ntestKthUniqueSmallestNumber()",
    "entry_point": "kthUniqueSmallestNumber",
    "signature": "func kthUniqueSmallestNumber(_ numbers: [Int], _ k: Int) -> String {",
    "docstring": {
      "en": "\nFinds the kth smallest unique number from a given list of integers. If two numbers are the same,\nthey are considered as one unique number. If the kth smallest unique number does not exist, returns \"NO RESULT\".\n\n- Parameters:\n- numbers: An array of integers.\n- k: The order of the smallest unique number to find.\n\n- Returns: A String representing the kth smallest unique number or \"NO RESULT\" if it doesn't exist.\n\nExamples:\n>>> kthUniqueSmallestNumber([5, 3, 9, 3, 5, 7, 2], 2)\n\"3\"\n\n>>> kthUniqueSmallestNumber([8, 1, 2, 2, 3, 4, 4, 6], 4)\n\"4\"\n\n>>> kthUniqueSmallestNumber([10, 20, 30], 4)\n\"NO RESULT\"\n",
      "es": "Encuentra el k-ésimo número único más pequeño de una lista dada de enteros. Si dos números son iguales, se consideran como un solo número único. Si el k-ésimo número único más pequeño no existe, devuelve \"NO RESULT\".\n\n- Parámetros:\n- numbers: Un arreglo de enteros.\n- k: El orden del número único más pequeño a encontrar.\n\n- Devuelve: Una cadena que representa el k-ésimo número único más pequeño o \"NO RESULT\" si no existe.\n\nEjemplos:\n>>> kthUniqueSmallestNumber([5, 3, 9, 3, 5, 7, 2], 2)\n\"3\"\n\n>>> kthUniqueSmallestNumber([8, 1, 2, 2, 3, 4, 4, 6], 4)\n\"4\"\n\n>>> kthUniqueSmallestNumber([10, 20, 30], 4)\n\"NO RESULT\"",
      "arb": "يعثر على العدد الفريد الأصغر بالترتيب k من قائمة معينة من الأعداد الصحيحة. إذا كان هناك رقمان متماثلان، يتم اعتبارهما كرقم فريد واحد. إذا لم يكن العدد الفريد الأصغر بالترتيب k موجودًا، يتم إرجاع \"NO RESULT\".\n\n- المعاملات:\n- numbers: مصفوفة من الأعداد الصحيحة.\n- k: ترتيب العدد الفريد الأصغر المراد العثور عليه.\n\n- يعيد: سلسلة نصية تمثل العدد الفريد الأصغر بالترتيب k أو \"NO RESULT\" إذا لم يكن موجودًا.\n\nأمثلة:\n>>> kthUniqueSmallestNumber([5, 3, 9, 3, 5, 7, 2], 2)\n\"3\"\n\n>>> kthUniqueSmallestNumber([8, 1, 2, 2, 3, 4, 4, 6], 4)\n\"4\"\n\n>>> kthUniqueSmallestNumber([10, 20, 30], 4)\n\"NO RESULT\"",
      "sw": "Inapata nambari ya kipekee ya kth ndogo zaidi kutoka kwenye orodha iliyotolewa ya nambari za mzima. Ikiwa nambari mbili ni sawa, zinachukuliwa kama nambari moja ya kipekee. Ikiwa nambari ya kipekee ya kth ndogo zaidi haipo, inarudisha \"HAKUNA MATOKEO\".\n\n- Vigezo:\n- numbers: Safu ya nambari za mzima.\n- k: Mpangilio wa nambari ya kipekee ndogo zaidi ya kupata.\n\n- Inarudisha: Kamba inayowakilisha nambari ya kipekee ya kth ndogo zaidi au \"HAKUNA MATOKEO\" ikiwa haipo.\n\nMifano:\n>>> kthUniqueSmallestNumber([5, 3, 9, 3, 5, 7, 2], 2)\n\"3\"\n\n>>> kthUniqueSmallestNumber([8, 1, 2, 2, 3, 4, 4, 6], 4)\n\"4\"\n\n>>> kthUniqueSmallestNumber([10, 20, 30], 4)\n\"HAKUNA MATOKEO\"",
      "tr": "Verilen bir tamsayı listesinden k. en küçük benzersiz sayıyı bulur. İki sayı aynıysa, bir benzersiz sayı olarak kabul edilirler. Eğer k. en küçük benzersiz sayı yoksa, \"SONUÇ YOK\" döndürür.\n\n- Parametreler:\n- numbers: Bir tamsayı dizisi.\n- k: Bulunacak en küçük benzersiz sayının sırası.\n\n- Döndürülen: k. en küçük benzersiz sayıyı veya yoksa \"SONUÇ YOK\"u temsil eden bir String.\n\nÖrnekler:\n>>> kthUniqueSmallestNumber([5, 3, 9, 3, 5, 7, 2], 2)\n\"3\"\n\n>>> kthUniqueSmallestNumber([8, 1, 2, 2, 3, 4, 4, 6], 4)\n\"4\"\n\n>>> kthUniqueSmallestNumber([10, 20, 30], 4)\n\"SONUÇ YOK\"",
      "vi": "Tìm số duy nhất nhỏ nhất thứ k từ một danh sách các số nguyên đã cho. Nếu hai số giống nhau, chúng được coi là một số duy nhất. Nếu số duy nhất nhỏ nhất thứ k không tồn tại, trả về \"NO RESULT\".\n\n- Tham số:\n- numbers: Một mảng các số nguyên.\n- k: Thứ tự của số duy nhất nhỏ nhất cần tìm.\n\n- Trả về: Một chuỗi đại diện cho số duy nhất nhỏ nhất thứ k hoặc \"NO RESULT\" nếu nó không tồn tại.\n\nVí dụ:\n>>> kthUniqueSmallestNumber([5, 3, 9, 3, 5, 7, 2], 2)\n\"3\"\n\n>>> kthUniqueSmallestNumber([8, 1, 2, 2, 3, 4, 4, 6], 4)\n\"4\"\n\n>>> kthUniqueSmallestNumber([10, 20, 30], 4)\n\"NO RESULT\""
    },
    "docstring_bertscore": {
      "es": "0.9738955980636329",
      "arb": "0.9653519094841793",
      "sw": "0.9931250052516204",
      "tr": "0.9666275137911853",
      "vi": "0.9811311069535908"
    }
  },
  {
    "task_id": "Swift/36",
    "prompt": {
      "en": "import Foundation\n\nfunc findShortestDistanceAmongPoints(_ points: [(Double, Double)]) -> Double {\n/**\nFinds the shortest distance between any two points in a given set of points in a 2D plane.\n\n- Parameters:\n- points: An array of tuples, where each tuple represents the x and y coordinates of a point.\n\n- Returns: The shortest distance between any two points, rounded to four decimal places.\n\nExample Usage:\n>>> findShortestDistanceAmongPoints([(1.0, 1.0), (1.0, 2.0), (2.0, 2.0)])\n1.0000\n>>> findShortestDistanceAmongPoints([(0.0, 0.0), (3.0, 4.0), (1.0, 1.0)])\n1.4142\n*/",
      "es": "import Foundation\n\nfunc findShortestDistanceAmongPoints(_ points: [(Double, Double)]) -> Double {\n/**\nEncuentra la distancia más corta entre dos puntos cualesquiera en un conjunto dado de puntos en un plano 2D.\n\n- Parámetros:\n- points: Un arreglo de tuplas, donde cada tupla representa las coordenadas x e y de un punto.\n\n- Retorna: La distancia más corta entre dos puntos cualesquiera, redondeada a cuatro decimales.\n\nEjemplo de uso:\n>>> findShortestDistanceAmongPoints([(1.0, 1.0), (1.0, 2.0), (2.0, 2.0)])\n1.0000\n>>> findShortestDistanceAmongPoints([(0.0, 0.0), (3.0, 4.0), (1.0, 1.0)])\n1.4142\n*/",
      "arb": "import Foundation\n\nfunc findShortestDistanceAmongPoints(_ points: [(Double, Double)]) -> Double {\n/**\nيجد أقصر مسافة بين أي نقطتين في مجموعة معينة من النقاط في مستوى ثنائي الأبعاد.\n\n- Parameters:\n- points: مصفوفة من الأزواج، حيث يمثل كل زوج الإحداثيات السينية والصادية لنقطة.\n\n- Returns: أقصر مسافة بين أي نقطتين، مقربة إلى أربعة منازل عشرية.\n\nمثال على الاستخدام:\n>>> findShortestDistanceAmongPoints([(1.0, 1.0), (1.0, 2.0), (2.0, 2.0)])\n1.0000\n>>> findShortestDistanceAmongPoints([(0.0, 0.0), (3.0, 4.0), (1.0, 1.0)])\n1.4142\n*/",
      "sw": "import Foundation\n\nfunc findShortestDistanceAmongPoints(_ points: [(Double, Double)]) -> Double {\n/**\nInapata umbali mfupi zaidi kati ya pointi zozote mbili katika seti iliyotolewa ya pointi kwenye ndege ya 2D.\n\n- Vigezo:\n- points: Kifurushi cha safu, ambapo kila kifurushi kinawakilisha viwianishi vya x na y vya pointi.\n\n- Inarudisha: Umbali mfupi zaidi kati ya pointi zozote mbili, ukizunguushwa hadi sehemu nne za desimali.\n\nMfano wa Matumizi:\n>>> findShortestDistanceAmongPoints([(1.0, 1.0), (1.0, 2.0), (2.0, 2.0)])\n1.0000\n>>> findShortestDistanceAmongPoints([(0.0, 0.0), (3.0, 4.0), (1.0, 1.0)])\n1.4142\n*/",
      "tr": "import Foundation\n\nfunc findShortestDistanceAmongPoints(_ points: [(Double, Double)]) -> Double {\n/**\nVerilen bir dizi noktada, 2D düzlemde herhangi iki nokta arasındaki en kısa mesafeyi bulur.\n\n- Parametreler:\n- points: Her bir demetin bir noktanın x ve y koordinatlarını temsil ettiği bir demet dizisi.\n\n- Döndürür: Herhangi iki nokta arasındaki en kısa mesafe, dört ondalık basamağa yuvarlanmış olarak.\n\nÖrnek Kullanım:\n>>> findShortestDistanceAmongPoints([(1.0, 1.0), (1.0, 2.0), (2.0, 2.0)])\n1.0000\n>>> findShortestDistanceAmongPoints([(0.0, 0.0), (3.0, 4.0), (1.0, 1.0)])\n1.4142\n*/",
      "vi": "import Foundation\n\nfunc findShortestDistanceAmongPoints(_ points: [(Double, Double)]) -> Double {\n/**\nTìm khoảng cách ngắn nhất giữa bất kỳ hai điểm nào trong một tập hợp điểm cho trước trên mặt phẳng 2D.\n\n- Tham số:\n- points: Một mảng các bộ giá trị, trong đó mỗi bộ giá trị đại diện cho tọa độ x và y của một điểm.\n\n- Trả về: Khoảng cách ngắn nhất giữa bất kỳ hai điểm nào, được làm tròn đến bốn chữ số thập phân.\n\nVí dụ sử dụng:\n>>> findShortestDistanceAmongPoints([(1.0, 1.0), (1.0, 2.0), (2.0, 2.0)])\n1.0000\n>>> findShortestDistanceAmongPoints([(0.0, 0.0), (3.0, 4.0), (1.0, 1.0)])\n1.4142\n*/"
    },
    "prompt_bertscore": {
      "es": "0.9964737148454876",
      "arb": "0.9818890804876199",
      "sw": "0.9973280241143186",
      "tr": "0.9919083941677818",
      "vi": "0.9919197160995008"
    },
    "canonical_solution": "guard !points.isEmpty else { return 0.0 }\n\nvar minDistance = Double.greatestFiniteMagnitude\n\nfor i in 0..<points.count {\nfor j in (i+1)..<points.count {\nlet distance = sqrt(pow(points[i].0 - points[j].0, 2) + pow(points[i].1 - points[j].1, 2))\nminDistance = min(minDistance, distance)\n}\n}\n\nreturn round(minDistance * 10000) / 10000.0\n}",
    "instruction": {
      "en": "func findShortestDistanceAmongPoints(_ points: [(Double, Double)]) -> Double {\nguard !points.isEmpty else { return 0.0 }\n\nvar minDistance = Double.greatestFiniteMagnitude\n\nfor i in 0..<points.count {\nfor j in (i+1)..<points.count {\nlet distance = sqrt(pow(points[i].0 - points[j].0, 2) + pow(points[i].1 - points[j].1, 2))\nminDistance = min(minDistance, distance)\n}\n}\n\nreturn round(minDistance * 10000) / 10000.0\n}\n\nProvide a concise natural language description (docstring) of the Swift code in English using at most 500 characters.",
      "es": "func findShortestDistanceAmongPoints(_ points: [(Double, Double)]) -> Double {\nguard !points.isEmpty else { return 0.0 }\n\nvar minDistance = Double.greatestFiniteMagnitude\n\nfor i in 0..<points.count {\nfor j in (i+1)..<points.count {\nlet distance = sqrt(pow(points[i].0 - points[j].0, 2) + pow(points[i].1 - points[j].1, 2))\nminDistance = min(minDistance, distance)\n}\n}\n\nreturn round(minDistance * 10000) / 10000.0\n}\n\nProporcione una descripción concisa en lenguaje natural (docstring) del código Swift en español utilizando como máximo 500 caracteres.",
      "arb": "func findShortestDistanceAmongPoints(_ points: [(Double, Double)]) -> Double {\nguard !points.isEmpty else { return 0.0 }\n\nvar minDistance = Double.greatestFiniteMagnitude\n\nfor i in 0..<points.count {\nfor j in (i+1)..<points.count {\nlet distance = sqrt(pow(points[i].0 - points[j].0, 2) + pow(points[i].1 - points[j].1, 2))\nminDistance = min(minDistance, distance)\n}\n}\n\nreturn round(minDistance * 10000) / 10000.0\n}\n\nقدم وصفًا موجزًا بلغة طبيعية (docstring) لشيفرة Swift باللغة العربية الفصحى باستخدام 500 حرف كحد أقصى.",
      "sw": "func findShortestDistanceAmongPoints(_ points: [(Double, Double)]) -> Double {\nguard !points.isEmpty else { return 0.0 }\n\nvar minDistance = Double.greatestFiniteMagnitude\n\nfor i in 0..<points.count {\nfor j in (i+1)..<points.count {\nlet distance = sqrt(pow(points[i].0 - points[j].0, 2) + pow(points[i].1 - points[j].1, 2))\nminDistance = min(minDistance, distance)\n}\n}\n\nreturn round(minDistance * 10000) / 10000.0\n}\n\nToa maelezo mafupi ya lugha ya asili (docstring) ya msimbo wa Swift kwa Kiswahili kwa kutumia herufi zisizozidi 500.",
      "tr": "func findShortestDistanceAmongPoints(_ points: [(Double, Double)]) -> Double {\nguard !points.isEmpty else { return 0.0 }\n\nvar minDistance = Double.greatestFiniteMagnitude\n\nfor i in 0..<points.count {\nfor j in (i+1)..<points.count {\nlet distance = sqrt(pow(points[i].0 - points[j].0, 2) + pow(points[i].1 - points[j].1, 2))\nminDistance = min(minDistance, distance)\n}\n}\n\nreturn round(minDistance * 10000) / 10000.0\n}\n\nSwift kodunun işlevini açıklayan kısa bir doğal dil açıklaması (docstring) sağlayın. Açıklama, Türkçe olarak en fazla 500 karakter kullanılarak yazılmalıdır.",
      "vi": "func findShortestDistanceAmongPoints(_ points: [(Double, Double)]) -> Double {\nguard !points.isEmpty else { return 0.0 }\n\nvar minDistance = Double.greatestFiniteMagnitude\n\nfor i in 0..<points.count {\nfor j in (i+1)..<points.count {\nlet distance = sqrt(pow(points[i].0 - points[j].0, 2) + pow(points[i].1 - points[j].1, 2))\nminDistance = min(minDistance, distance)\n}\n}\n\nreturn round(minDistance * 10000) / 10000.0\n}\n\nCung cấp mô tả ngắn gọn bằng ngôn ngữ tự nhiên (docstring) cho mã Swift bằng tiếng Việt, sử dụng tối đa 500 ký tự."
    },
    "instruction_bertscore": {
      "es": "0.9676013985493994",
      "arb": "0.896529660541687",
      "sw": "0.9148419912604365",
      "tr": "0.8714851503185221",
      "vi": "0.9256006072188102"
    },
    "level": "",
    "test": "func check(_ findShortestDistanceAmongPoints: ([(Double, Double)]) -> Double) {\nassert(findShortestDistanceAmongPoints([(1.0, 1.0), (1.0, 2.0), (2.0, 2.0)]) == 1.0000)\nassert(findShortestDistanceAmongPoints([(0.0, 0.0), (3.0, 4.0), (1.0, 1.0)]) == 1.4142)\nassert(findShortestDistanceAmongPoints([(0.0, 0.0), (5.0, 5.0), (1.0, 6.0), (2.0, 1.0)]) == 2.2361)\nassert(findShortestDistanceAmongPoints([(2.0, 3.0), (4.0, 4.0)]) == 2.2361)\nassert(findShortestDistanceAmongPoints([(1.5, 1.5), (3.5, 3.5), (5.5, 5.5)]) == 2.8284)\n}\n\ncheck(findShortestDistanceAmongPoints)",
    "entry_point": "findShortestDistanceAmongPoints",
    "signature": "func findShortestDistanceAmongPoints(_ points: [(Double, Double)]) -> Double {",
    "docstring": {
      "en": "\nFinds the shortest distance between any two points in a given set of points in a 2D plane.\n\n- Parameters:\n- points: An array of tuples, where each tuple represents the x and y coordinates of a point.\n\n- Returns: The shortest distance between any two points, rounded to four decimal places.\n\nExample Usage:\n>>> findShortestDistanceAmongPoints([(1.0, 1.0), (1.0, 2.0), (2.0, 2.0)])\n1.0000\n>>> findShortestDistanceAmongPoints([(0.0, 0.0), (3.0, 4.0), (1.0, 1.0)])\n1.4142\n",
      "es": "Encuentra la distancia más corta entre dos puntos cualesquiera en un conjunto dado de puntos en un plano 2D.\n\n- Parámetros:\n- points: Un arreglo de tuplas, donde cada tupla representa las coordenadas x e y de un punto.\n\n- Devuelve: La distancia más corta entre dos puntos cualesquiera, redondeada a cuatro decimales.\n\nEjemplo de uso:\n>>> findShortestDistanceAmongPoints([(1.0, 1.0), (1.0, 2.0), (2.0, 2.0)])\n1.0000\n>>> findShortestDistanceAmongPoints([(0.0, 0.0), (3.0, 4.0), (1.0, 1.0)])\n1.4142",
      "arb": "يجد أقصر مسافة بين أي نقطتين في مجموعة معينة من النقاط في مستوى ثنائي الأبعاد.\n\n- المعلمات:\n- points: مصفوفة من الأزواج، حيث يمثل كل زوج إحداثيات x و y لنقطة.\n\n- يعيد: أقصر مسافة بين أي نقطتين، مقربة إلى أربعة منازل عشرية.\n\nمثال على الاستخدام:\n>>> findShortestDistanceAmongPoints([(1.0, 1.0), (1.0, 2.0), (2.0, 2.0)])\n1.0000\n>>> findShortestDistanceAmongPoints([(0.0, 0.0), (3.0, 4.0), (1.0, 1.0)])\n1.4142",
      "sw": "Inapata umbali mfupi zaidi kati ya pointi zozote mbili katika seti iliyotolewa ya pointi kwenye ndege ya 2D.\n\n- Vigezo:\n- points: Kundi la jozi, ambapo kila jozi inawakilisha kuratibu za x na y za nukta.\n\n- Inarudisha: Umbali mfupi zaidi kati ya pointi zozote mbili, ukiwa umekadiriwa hadi sehemu nne za desimali.\n\nMfano wa Matumizi:\n>>> findShortestDistanceAmongPoints([(1.0, 1.0), (1.0, 2.0), (2.0, 2.0)])\n1.0000\n>>> findShortestDistanceAmongPoints([(0.0, 0.0), (3.0, 4.0), (1.0, 1.0)])\n1.4142",
      "tr": "Verilen bir dizi noktada, 2D düzlemde herhangi iki nokta arasındaki en kısa mesafeyi bulur.\n\n- Parametreler:\n- points: Her bir demetin bir noktanın x ve y koordinatlarını temsil ettiği demetlerden oluşan bir dizi.\n\n- Döndürür: Herhangi iki nokta arasındaki en kısa mesafe, dört ondalık basamağa yuvarlanmış olarak.\n\nÖrnek Kullanım:\n>>> findShortestDistanceAmongPoints([(1.0, 1.0), (1.0, 2.0), (2.0, 2.0)])\n1.0000\n>>> findShortestDistanceAmongPoints([(0.0, 0.0), (3.0, 4.0), (1.0, 1.0)])\n1.4142",
      "vi": "Tìm khoảng cách ngắn nhất giữa bất kỳ hai điểm nào trong một tập hợp các điểm trên mặt phẳng 2D.\n\n- Tham số:\n- points: Một mảng các bộ giá trị, trong đó mỗi bộ đại diện cho tọa độ x và y của một điểm.\n\n- Trả về: Khoảng cách ngắn nhất giữa bất kỳ hai điểm nào, được làm tròn đến bốn chữ số thập phân.\n\nVí dụ Sử dụng:\n>>> findShortestDistanceAmongPoints([(1.0, 1.0), (1.0, 2.0), (2.0, 2.0)])\n1.0000\n>>> findShortestDistanceAmongPoints([(0.0, 0.0), (3.0, 4.0), (1.0, 1.0)])\n1.4142"
    },
    "docstring_bertscore": {
      "es": "0.9876318820641006",
      "arb": "0.9799156876520383",
      "sw": "0.9722151850400778",
      "tr": "0.9912846947713322",
      "vi": "0.9842702614954661"
    }
  },
  {
    "task_id": "Swift/37",
    "prompt": {
      "en": "import Foundation\nfunc countMealCombinations(_ dishes: [Int], _ budget: Int) -> Int {\n/**\nCounts the number of ways to choose dishes from a menu such that the total cost\nexactly matches a given budget. Each dish can only be selected once.\n\n- Parameters:\n- dishes: An array of integers where each integer represents the cost of a dish.\n- budget: An integer representing the total budget for the meal.\n- Returns: The total number of unique combinations of dishes that exactly sum up to the budget.\n\n## Example:\n>>> countMealCombinations([1, 2, 3], 4)\n1 // [1, 3]\n*/",
      "es": "import Foundation\nfunc countMealCombinations(_ dishes: [Int], _ budget: Int) -> Int {\n/**\nCuenta el número de formas de elegir platos de un menú de manera que el costo total\ncoincida exactamente con un presupuesto dado. Cada plato solo se puede seleccionar una vez.\n\n- Parameters:\n- dishes: Un arreglo de enteros donde cada entero representa el costo de un plato.\n- budget: Un entero que representa el presupuesto total para la comida.\n- Returns: El número total de combinaciones únicas de platos que suman exactamente el presupuesto.\n\n## Example:\n>>> countMealCombinations([1, 2, 3], 4)\n1 // [1, 3]\n*/",
      "arb": "import Foundation\nfunc countMealCombinations(_ dishes: [Int], _ budget: Int) -> Int {\n/**\nيحسب عدد الطرق لاختيار الأطباق من قائمة بحيث يتطابق التكلفة الإجمالية\nتمامًا مع الميزانية المعطاة. يمكن اختيار كل طبق مرة واحدة فقط.\n\n- Parameters:\n- dishes: مصفوفة من الأعداد الصحيحة حيث يمثل كل عدد صحيح تكلفة طبق.\n- budget: عدد صحيح يمثل الميزانية الإجمالية للوجبة.\n- Returns: العدد الإجمالي للتوليفات الفريدة من الأطباق التي تساوي تمامًا الميزانية.\n\n## Example:\n>>> countMealCombinations([1, 2, 3], 4)\n1 // [1, 3]\n*/",
      "sw": "import Foundation\nfunc countMealCombinations(_ dishes: [Int], _ budget: Int) -> Int {\n/**\nInahesabu idadi ya njia za kuchagua sahani kutoka kwenye menyu ili gharama ya jumla\nilingane kabisa na bajeti iliyotolewa. Kila sahani inaweza kuchaguliwa mara moja tu.\n\n- Vigezo:\n- dishes: Mfululizo wa namba ambapo kila namba inawakilisha gharama ya sahani.\n- budget: Namba inayoashiria bajeti ya jumla kwa ajili ya mlo.\n- Inarudisha: Jumla ya idadi ya michanganyiko ya kipekee ya sahani ambazo jumla yake ni sawa na bajeti.\n\n## Mfano:\n>>> countMealCombinations([1, 2, 3], 4)\n1 // [1, 3]\n*/",
      "tr": "import Foundation\nfunc countMealCombinations(_ dishes: [Int], _ budget: Int) -> Int {\n/**\nMenüden yemek seçmenin toplam maliyetinin verilen bütçeyle tam olarak eşleştiği\nyolların sayısını sayar. Her yemek sadece bir kez seçilebilir.\n\n- Parametreler:\n- dishes: Her bir tamsayının bir yemeğin maliyetini temsil ettiği bir tamsayı dizisi.\n- budget: Yemek için toplam bütçeyi temsil eden bir tamsayı.\n- Döndürür: Bütçeye tam olarak eşit olan yemeklerin benzersiz kombinasyonlarının toplam sayısı.\n\n## Örnek:\n>>> countMealCombinations([1, 2, 3], 4)\n1 // [1, 3]\n*/",
      "vi": "import Foundation\nfunc countMealCombinations(_ dishes: [Int], _ budget: Int) -> Int {\n/**\nĐếm số cách chọn món ăn từ thực đơn sao cho tổng chi phí khớp chính xác với ngân sách đã cho. Mỗi món ăn chỉ có thể được chọn một lần.\n\n- Tham số:\n- dishes: Một mảng số nguyên trong đó mỗi số nguyên đại diện cho chi phí của một món ăn.\n- budget: Một số nguyên đại diện cho tổng ngân sách cho bữa ăn.\n- Trả về: Tổng số các tổ hợp món ăn duy nhất mà tổng chi phí chính xác bằng ngân sách.\n\n## Ví dụ:\n>>> countMealCombinations([1, 2, 3], 4)\n1 // [1, 3]\n*/"
    },
    "prompt_bertscore": {
      "es": "0.9967492151839831",
      "arb": "0.9720896506392637",
      "sw": "0.9602177113951895",
      "tr": "0.9488332111061749",
      "vi": "0.9697843464369728"
    },
    "canonical_solution": "var dp = Array(repeating: 0, count: budget + 1)\ndp[0] = 1\nfor dish in dishes {\nif dish <= budget {\nfor j in stride(from: budget, through: dish, by: -1) {\ndp[j] += dp[j - dish]\n}\n}\n}\nreturn dp[budget]\n}",
    "instruction": {
      "en": "func countMealCombinations(_ dishes: [Int], _ budget: Int) -> Int {\nvar dp = Array(repeating: 0, count: budget + 1)\ndp[0] = 1\nfor dish in dishes {\nif dish <= budget {\nfor j in stride(from: budget, through: dish, by: -1) {\ndp[j] += dp[j - dish]\n}\n}\n}\nreturn dp[budget]\n}\n\nProvide a concise natural language description (docstring) of the Swift code in English using at most 500 characters.",
      "es": "func countMealCombinations(_ dishes: [Int], _ budget: Int) -> Int {\nvar dp = Array(repeating: 0, count: budget + 1)\ndp[0] = 1\nfor dish in dishes {\nif dish <= budget {\nfor j in stride(from: budget, through: dish, by: -1) {\ndp[j] += dp[j - dish]\n}\n}\n}\nreturn dp[budget]\n}\n\nProporcione una descripción concisa en lenguaje natural (docstring) del código Swift en español utilizando como máximo 500 caracteres.",
      "arb": "func countMealCombinations(_ dishes: [Int], _ budget: Int) -> Int {\nvar dp = Array(repeating: 0, count: budget + 1)\ndp[0] = 1\nfor dish in dishes {\nif dish <= budget {\nfor j in stride(from: budget, through: dish, by: -1) {\ndp[j] += dp[j - dish]\n}\n}\n}\nreturn dp[budget]\n}\n\nقدم وصفًا موجزًا بلغة طبيعية (docstring) للكود المكتوب بلغة Swift باللغة العربية الفصحى باستخدام ما لا يزيد عن 500 حرف.",
      "sw": "func countMealCombinations(_ dishes: [Int], _ budget: Int) -> Int {\nvar dp = Array(repeating: 0, count: budget + 1)\ndp[0] = 1\nfor dish in dishes {\nif dish <= budget {\nfor j in stride(from: budget, through: dish, by: -1) {\ndp[j] += dp[j - dish]\n}\n}\n}\nreturn dp[budget]\n}\n\nToa maelezo mafupi ya lugha asilia (docstring) ya msimbo wa Swift kwa Kiswahili kwa kutumia herufi zisizozidi 500.",
      "tr": "func countMealCombinations(_ dishes: [Int], _ budget: Int) -> Int {\nvar dp = Array(repeating: 0, count: budget + 1)\ndp[0] = 1\nfor dish in dishes {\nif dish <= budget {\nfor j in stride(from: budget, through: dish, by: -1) {\ndp[j] += dp[j - dish]\n}\n}\n}\nreturn dp[budget]\n}\n\nSwift kodunun Türkçe olarak en fazla 500 karakter kullanarak kısa bir doğal dil açıklamasını (docstring) sağlayın.",
      "vi": "func countMealCombinations(_ dishes: [Int], _ budget: Int) -> Int {\nvar dp = Array(repeating: 0, count: budget + 1)\ndp[0] = 1\nfor dish in dishes {\nif dish <= budget {\nfor j in stride(from: budget, through: dish, by: -1) {\ndp[j] += dp[j - dish]\n}\n}\n}\nreturn dp[budget]\n}\n\nCung cấp mô tả ngắn gọn bằng ngôn ngữ tự nhiên (docstring) cho mã Swift bằng tiếng Việt, sử dụng tối đa 500 ký tự."
    },
    "instruction_bertscore": {
      "es": "0.9676013985493994",
      "arb": "0.8797543317113856",
      "sw": "0.942496901951162",
      "tr": "0.9385638217762902",
      "vi": "0.9256006072188102"
    },
    "level": "",
    "test": "func check(_ countMealCombinations: ([Int], Int) -> Int) {\nassert(countMealCombinations([1, 2, 3], 4) == 1)\nassert(countMealCombinations([1, 1, 3, 4, 5], 5) == 4)\nassert(countMealCombinations([2, 2, 2, 2], 8) == 1)\nassert(countMealCombinations([1, 1, 1, 1, 1], 3) == 10)\nassert(countMealCombinations([5, 5, 5, 5, 5], 10) == 10)\nassert(countMealCombinations([10, 15, 20], 25) == 1)\nassert(countMealCombinations([1, 3, 4, 6], 9) == 1)\n}\n\ncheck(countMealCombinations)",
    "entry_point": "countMealCombinations",
    "signature": "func countMealCombinations(_ dishes: [Int], _ budget: Int) -> Int {",
    "docstring": {
      "en": "\nCounts the number of ways to choose dishes from a menu such that the total cost\nexactly matches a given budget. Each dish can only be selected once.\n\n- Parameters:\n- dishes: An array of integers where each integer represents the cost of a dish.\n- budget: An integer representing the total budget for the meal.\n- Returns: The total number of unique combinations of dishes that exactly sum up to the budget.\n\n## Example:\n>>> countMealCombinations([1, 2, 3], 4)\n1 // [1, 3]\n",
      "es": "Cuenta el número de formas de elegir platos de un menú de tal manera que el costo total coincida exactamente con un presupuesto dado. Cada plato solo puede ser seleccionado una vez.\n\n- Parámetros:\n- dishes: Un arreglo de enteros donde cada entero representa el costo de un plato.\n- budget: Un entero que representa el presupuesto total para la comida.\n- Devuelve: El número total de combinaciones únicas de platos que suman exactamente el presupuesto.\n\n## Ejemplo:\n>>> countMealCombinations([1, 2, 3], 4)\n1 // [1, 3]",
      "arb": "يحسب عدد الطرق لاختيار الأطباق من قائمة طعام بحيث يتطابق التكلفة الإجمالية تمامًا مع ميزانية معينة. يمكن اختيار كل طبق مرة واحدة فقط.\n\n- المعلمات:\n- dishes: مصفوفة من الأعداد الصحيحة حيث يمثل كل عدد صحيح تكلفة طبق.\n- budget: عدد صحيح يمثل الميزانية الإجمالية للوجبة.\n- العائدات: العدد الإجمالي للتوليفات الفريدة من الأطباق التي تتطابق تمامًا مع الميزانية.\n\n## مثال:\n>>> countMealCombinations([1, 2, 3], 4)\n1 // [1, 3]",
      "sw": "Hesabu idadi ya njia za kuchagua sahani kutoka kwenye menyu ili jumla ya gharama\nilingane kabisa na bajeti iliyotolewa. Kila sahani inaweza kuchaguliwa mara moja tu.\n\n- Vigezo:\n- dishes: Kundi la nambari za mzima ambapo kila nambari inawakilisha gharama ya sahani.\n- budget: Nambari ya mzima inayowakilisha bajeti ya jumla kwa ajili ya chakula.\n- Inarejesha: Jumla ya idadi ya miunganiko ya kipekee ya sahani ambazo jumla yake ni sawa na bajeti.\n\n## Mfano:\n>>> countMealCombinations([1, 2, 3], 4)\n1 // [1, 3]",
      "tr": "Yemeklerin toplam maliyetinin verilen bir bütçeye tam olarak eşit olacak şekilde menüden seçilme sayısını sayar. Her yemek yalnızca bir kez seçilebilir.\n\n- Parametreler:\n- dishes: Her tamsayı bir yemeğin maliyetini temsil eden bir tamsayı dizisi.\n- budget: Yemek için toplam bütçeyi temsil eden bir tamsayı.\n- Döndürür: Yemeklerin tam olarak bütçeye eşit olan benzersiz kombinasyonlarının toplam sayısı.\n\n## Örnek:\n>>> countMealCombinations([1, 2, 3], 4)\n1 // [1, 3]",
      "vi": "Đếm số cách để chọn món ăn từ thực đơn sao cho tổng chi phí khớp chính xác với ngân sách đã cho. Mỗi món ăn chỉ có thể được chọn một lần.\n\n- Tham số:\n- dishes: Một mảng các số nguyên, mỗi số nguyên đại diện cho chi phí của một món ăn.\n- budget: Một số nguyên đại diện cho tổng ngân sách cho bữa ăn.\n- Trả về: Tổng số các tổ hợp món ăn duy nhất có tổng chính xác bằng ngân sách.\n\n## Ví dụ:\n>>> countMealCombinations([1, 2, 3], 4)\n1 // [1, 3]"
    },
    "docstring_bertscore": {
      "es": "0.9893410964929058",
      "arb": "0.9769688073190047",
      "sw": "0.9613006442325917",
      "tr": "0.952397831924227",
      "vi": "0.9815287649764226"
    }
  },
  {
    "task_id": "Swift/38",
    "prompt": {
      "en": "import Foundation\nfunc latestDepartureTime(distance: Int, speed: Int) -> String {\n/**\nCalculates the latest time yyy can leave for school without being late. \nThe school is 'distance' meters away, and yyy walks at a speed of 'speed' meters per minute. \nAdditionally, yyy spends an extra 10 minutes for garbage sorting on the way.\n\nThe school requires arrival by 08:00 AM. This function returns the latest departure time in HH:MM format.\n\nExamples:\n>>> latestDepartureTime(distance: 100, speed: 10)\n\"07:40\"\n*/",
      "es": "import Foundation\nfunc latestDepartureTime(distance: Int, speed: Int) -> String {\n/**\nCalcula la última hora a la que yyy puede salir para la escuela sin llegar tarde. \nLa escuela está a 'distance' metros de distancia, y yyy camina a una velocidad de 'speed' metros por minuto. \nAdemás, yyy pasa 10 minutos adicionales clasificando basura en el camino.\n\nLa escuela requiere llegar antes de las 08:00 AM. Esta función devuelve la última hora de salida en formato HH:MM.\n\nEjemplos:\n>>> latestDepartureTime(distance: 100, speed: 10)\n\"07:40\"\n*/",
      "arb": "import Foundation\nfunc latestDepartureTime(distance: Int, speed: Int) -> String {\n/**\nيحسب أحدث وقت يمكن لـ yyy مغادرة المنزل للذهاب إلى المدرسة دون تأخير.\nالمدرسة تبعد 'distance' مترًا، ويمشي yyy بسرعة 'speed' مترًا في الدقيقة.\nبالإضافة إلى ذلك، يقضي yyy 10 دقائق إضافية لفرز القمامة في الطريق.\n\nتتطلب المدرسة الوصول بحلول الساعة 08:00 صباحًا. تعيد هذه الدالة أحدث وقت للمغادرة بتنسيق HH:MM.\n\nأمثلة:\n>>> latestDepartureTime(distance: 100, speed: 10)\n\"07:40\"\n*/",
      "sw": "import Foundation\nfunc latestDepartureTime(distance: Int, speed: Int) -> String {\n/**\nHesabu muda wa mwisho ambao yyy anaweza kuondoka kwenda shuleni bila kuchelewa. \nShule iko umbali wa 'distance' mita, na yyy anatembea kwa kasi ya 'speed' mita kwa dakika. \nZaidi ya hayo, yyy hutumia dakika 10 za ziada kwa ajili ya kupanga takataka njiani.\n\nShule inahitaji kufika kabla ya saa 02:00 asubuhi. Kazi hii inarudisha muda wa mwisho wa kuondoka katika muundo wa HH:MM.\n\nMifano:\n>>> latestDepartureTime(distance: 100, speed: 10)\n\"07:40\"\n*/",
      "tr": "import Foundation\nfunc latestDepartureTime(distance: Int, speed: Int) -> String {\n/**\nOkula geç kalmadan yyy'nin en geç ne zaman çıkabileceğini hesaplar.\nOkul 'distance' metre uzakta ve yyy 'speed' metre/dakika hızla yürür.\nEk olarak, yyy yolda çöp ayrıştırma için ekstra 10 dakika harcar.\n\nOkul, 08:00 AM'e kadar varış gerektirir. Bu fonksiyon en geç çıkış saatini HH:MM formatında döndürür.\n\nÖrnekler:\n>>> latestDepartureTime(distance: 100, speed: 10)\n\"07:40\"\n*/",
      "vi": "import Foundation\nfunc latestDepartureTime(distance: Int, speed: Int) -> String {\n/**\nTính toán thời gian muộn nhất yyy có thể rời khỏi nhà để đến trường mà không bị muộn. \nTrường cách 'distance' mét, và yyy đi bộ với tốc độ 'speed' mét mỗi phút. \nNgoài ra, yyy dành thêm 10 phút để phân loại rác trên đường đi.\n\nTrường yêu cầu đến trước 08:00 sáng. Hàm này trả về thời gian khởi hành muộn nhất dưới dạng định dạng HH:MM.\n\nVí dụ:\n>>> latestDepartureTime(distance: 100, speed: 10)\n\"07:40\"\n*/"
    },
    "prompt_bertscore": {
      "es": "0.9824043276960245",
      "arb": "0.9827807322680855",
      "sw": "0.9716761021859491",
      "tr": "0.9848375498637018",
      "vi": "0.9737857554629207"
    },
    "canonical_solution": "let totalMinutesNeeded = (distance + speed - 1) / speed + 10 // Ceiling division for distance/speed and additional 10 minutes\nlet departureTime = Date().todayAt(hours: 8, minutes: 0).addingTimeInterval(-Double(totalMinutesNeeded) * 60)\nlet dateFormatter = DateFormatter()\ndateFormatter.dateFormat = \"HH:mm\"\nreturn dateFormatter.string(from: departureTime)\n}\n\nextension Date {\nfunc todayAt(hours: Int, minutes: Int) -> Date {\nlet calendar = Calendar.current\nvar dateComponents = calendar.dateComponents([.year, .month, .day], from: self)\ndateComponents.hour = hours\ndateComponents.minute = minutes\nreturn calendar.date(from: dateComponents)!\n}\n}",
    "instruction": {
      "en": "func latestDepartureTime(distance: Int, speed: Int) -> String {\nlet totalMinutesNeeded = (distance + speed - 1) / speed + 10 // Ceiling division for distance/speed and additional 10 minutes\nlet departureTime = Date().todayAt(hours: 8, minutes: 0).addingTimeInterval(-Double(totalMinutesNeeded) * 60)\nlet dateFormatter = DateFormatter()\ndateFormatter.dateFormat = \"HH:mm\"\nreturn dateFormatter.string(from: departureTime)\n}\n\nextension Date {\nfunc todayAt(hours: Int, minutes: Int) -> Date {\nlet calendar = Calendar.current\nvar dateComponents = calendar.dateComponents([.year, .month, .day], from: self)\ndateComponents.hour = hours\ndateComponents.minute = minutes\nreturn calendar.date(from: dateComponents)!\n}\n}\n\nProvide a concise natural language description (docstring) of the Swift code in English using at most 500 characters.",
      "es": "func latestDepartureTime(distance: Int, speed: Int) -> String {\nlet totalMinutesNeeded = (distance + speed - 1) / speed + 10 // Ceiling division for distance/speed and additional 10 minutes\nlet departureTime = Date().todayAt(hours: 8, minutes: 0).addingTimeInterval(-Double(totalMinutesNeeded) * 60)\nlet dateFormatter = DateFormatter()\ndateFormatter.dateFormat = \"HH:mm\"\nreturn dateFormatter.string(from: departureTime)\n}\n\nextension Date {\nfunc todayAt(hours: Int, minutes: Int) -> Date {\nlet calendar = Calendar.current\nvar dateComponents = calendar.dateComponents([.year, .month, .day], from: self)\ndateComponents.hour = hours\ndateComponents.minute = minutes\nreturn calendar.date(from: dateComponents)!\n}\n}\n\nProporcione una descripción concisa en lenguaje natural (docstring) del código Swift en español utilizando como máximo 500 caracteres.",
      "arb": "func latestDepartureTime(distance: Int, speed: Int) -> String {\nlet totalMinutesNeeded = (distance + speed - 1) / speed + 10 // Ceiling division for distance/speed and additional 10 minutes\nlet departureTime = Date().todayAt(hours: 8, minutes: 0).addingTimeInterval(-Double(totalMinutesNeeded) * 60)\nlet dateFormatter = DateFormatter()\ndateFormatter.dateFormat = \"HH:mm\"\nreturn dateFormatter.string(from: departureTime)\n}\n\nextension Date {\nfunc todayAt(hours: Int, minutes: Int) -> Date {\nlet calendar = Calendar.current\nvar dateComponents = calendar.dateComponents([.year, .month, .day], from: self)\ndateComponents.hour = hours\ndateComponents.minute = minutes\nreturn calendar.date(from: dateComponents)!\n}\n}\n\nقدم وصفًا موجزًا بلغة طبيعية (docstring) لكود Swift باللغة العربية الفصحى باستخدام ما لا يزيد عن 500 حرف.",
      "sw": "func latestDepartureTime(distance: Int, speed: Int) -> String {\nlet totalMinutesNeeded = (distance + speed - 1) / speed + 10 // Ceiling division for distance/speed and additional 10 minutes\nlet departureTime = Date().todayAt(hours: 8, minutes: 0).addingTimeInterval(-Double(totalMinutesNeeded) * 60)\nlet dateFormatter = DateFormatter()\ndateFormatter.dateFormat = \"HH:mm\"\nreturn dateFormatter.string(from: departureTime)\n}\n\nextension Date {\nfunc todayAt(hours: Int, minutes: Int) -> Date {\nlet calendar = Calendar.current\nvar dateComponents = calendar.dateComponents([.year, .month, .day], from: self)\ndateComponents.hour = hours\ndateComponents.minute = minutes\nreturn calendar.date(from: dateComponents)!\n}\n}\n\nToa maelezo mafupi ya lugha ya asili (docstring) ya msimbo wa Swift kwa Kiswahili kwa kutumia herufi zisizozidi 500.",
      "tr": "func latestDepartureTime(distance: Int, speed: Int) -> String {\nlet totalMinutesNeeded = (distance + speed - 1) / speed + 10 // Ceiling division for distance/speed and additional 10 minutes\nlet departureTime = Date().todayAt(hours: 8, minutes: 0).addingTimeInterval(-Double(totalMinutesNeeded) * 60)\nlet dateFormatter = DateFormatter()\ndateFormatter.dateFormat = \"HH:mm\"\nreturn dateFormatter.string(from: departureTime)\n}\n\nextension Date {\nfunc todayAt(hours: Int, minutes: Int) -> Date {\nlet calendar = Calendar.current\nvar dateComponents = calendar.dateComponents([.year, .month, .day], from: self)\ndateComponents.hour = hours\ndateComponents.minute = minutes\nreturn calendar.date(from: dateComponents)!\n}\n}\n\nSwift kodunun işlevini açıklayan kısa bir doğal dil açıklaması (docstring) sağlayın. Açıklama, Türkçe olarak en fazla 500 karakter kullanılarak yazılmalıdır.",
      "vi": "func latestDepartureTime(distance: Int, speed: Int) -> String {\nlet totalMinutesNeeded = (distance + speed - 1) / speed + 10 // Ceiling division for distance/speed and additional 10 minutes\nlet departureTime = Date().todayAt(hours: 8, minutes: 0).addingTimeInterval(-Double(totalMinutesNeeded) * 60)\nlet dateFormatter = DateFormatter()\ndateFormatter.dateFormat = \"HH:mm\"\nreturn dateFormatter.string(from: departureTime)\n}\n\nextension Date {\nfunc todayAt(hours: Int, minutes: Int) -> Date {\nlet calendar = Calendar.current\nvar dateComponents = calendar.dateComponents([.year, .month, .day], from: self)\ndateComponents.hour = hours\ndateComponents.minute = minutes\nreturn calendar.date(from: dateComponents)!\n}\n}\n\nCung cấp mô tả ngắn gọn bằng ngôn ngữ tự nhiên (docstring) cho mã Swift bằng tiếng Việt với tối đa 500 ký tự."
    },
    "instruction_bertscore": {
      "es": "0.9676013985493994",
      "arb": "0.8880608556158835",
      "sw": "0.9148419912604365",
      "tr": "0.8714851503185221",
      "vi": "0.9219021095239406"
    },
    "level": "",
    "test": "func check(_ latestDepartureTime: (Int, Int) -> String) {\nassert(latestDepartureTime(100, 10) == \"07:40\")\nassert(latestDepartureTime(50, 25) == \"07:48\")\nassert(latestDepartureTime(120, 60) == \"07:48\")\nassert(latestDepartureTime(80, 20) == \"07:46\")\nassert(latestDepartureTime(200, 40) == \"07:45\")\nassert(latestDepartureTime(90, 30) == \"07:47\")\n}\n\ncheck(latestDepartureTime)",
    "entry_point": "latestDepartureTime",
    "signature": "func latestDepartureTime(distance: Int, speed: Int) -> String {",
    "docstring": {
      "en": "\nCalculates the latest time yyy can leave for school without being late. \nThe school is 'distance' meters away, and yyy walks at a speed of 'speed' meters per minute. \nAdditionally, yyy spends an extra 10 minutes for garbage sorting on the way.\n\nThe school requires arrival by 08:00 AM. This function returns the latest departure time in HH:MM format.\n\nExamples:\n>>> latestDepartureTime(distance: 100, speed: 10)\n\"07:40\"\n",
      "es": "Calcula la última hora a la que yyy puede salir para la escuela sin llegar tarde. La escuela está a 'distance' metros de distancia, y yyy camina a una velocidad de 'speed' metros por minuto. Además, yyy pasa 10 minutos adicionales clasificando basura en el camino.\n\nLa escuela requiere llegar antes de las 08:00 AM. Esta función devuelve la última hora de salida en formato HH:MM.\n\nEjemplos:\n>>> latestDepartureTime(distance: 100, speed: 10)\n\"07:40\"",
      "arb": "يحسب أحدث وقت يمكن لـ yyy مغادرة المنزل إلى المدرسة دون التأخر. المدرسة تبعد 'distance' مترًا، ويمشي yyy بسرعة 'speed' متر في الدقيقة. بالإضافة إلى ذلك، يقضي yyy 10 دقائق إضافية في فرز القمامة في الطريق.\n\nتتطلب المدرسة الوصول بحلول الساعة 08:00 صباحًا. تُرجع هذه الدالة أحدث وقت للمغادرة بتنسيق HH:MM.\n\nأمثلة:\n>>> latestDepartureTime(distance: 100, speed: 10)\n\"07:40\"",
      "sw": "Hesabu wakati wa mwisho yyy anaweza kuondoka kwenda shule bila kuchelewa. \nShule iko umbali wa 'distance' mita, na yyy anatembea kwa kasi ya 'speed' mita kwa dakika. \nZaidi ya hayo, yyy hutumia dakika 10 za ziada kwa kupanga takataka njiani.\n\nShule inahitaji kufika ifikapo saa 02:00 asubuhi. Kazi hii inarudisha wakati wa mwisho wa kuondoka katika muundo wa HH:MM.\n\nMifano:\n>>> latestDepartureTime(distance: 100, speed: 10)\n\"07:40\"",
      "tr": "Okula geç kalmadan yyy'nin en son ne zaman çıkabileceğini hesaplar. \nOkul 'distance' metre uzaklıktadır ve yyy 'speed' metre/dakika hızla yürür. \nAyrıca, yyy yolda çöp ayrıştırma için ekstra 10 dakika harcar.\n\nOkul, saat 08:00'de varılmasını gerektirir. Bu fonksiyon, en geç çıkış saatini SS:DD formatında döndürür.\n\nÖrnekler:\n>>> latestDepartureTime(distance: 100, speed: 10)\n\"07:40\"",
      "vi": "Tính toán thời gian muộn nhất yyy có thể rời khỏi nhà để đến trường mà không bị muộn. Trường cách 'distance' mét, và yyy đi bộ với tốc độ 'speed' mét mỗi phút. Ngoài ra, yyy dành thêm 10 phút để phân loại rác trên đường đi.\n\nTrường yêu cầu đến trước 08:00 sáng. Hàm này trả về thời gian khởi hành muộn nhất dưới định dạng HH:MM.\n\nVí dụ:\n>>> latestDepartureTime(distance: 100, speed: 10)\n\"07:40\""
    },
    "docstring_bertscore": {
      "es": "0.9789163782050518",
      "arb": "0.9854807150374928",
      "sw": "0.9520073245951124",
      "tr": "0.9771676363304206",
      "vi": "0.9627329679102343"
    }
  },
  {
    "task_id": "Swift/39",
    "prompt": {
      "en": "import Foundation\nfunc calculateFinalScore(_ scores: [Double]) -> Double {\n/**\nCalculates the final score for a contestant by removing the highest and lowest scores from the\ngiven array of scores and then calculating the average of the remaining scores. \nThe result is rounded to two decimal places.\n\n- Parameters:\n- scores: An array of `Double` representing the scores given by each judge.\n\n- Returns: A `Double` representing the final score of the contestant, rounded to two decimal places.\n\nExamples:\n>>> calculateFinalScore([6.0, 7.5, 8.0, 7.0, 6.5])\n7.00\n*/",
      "es": "import Foundation\nfunc calculateFinalScore(_ scores: [Double]) -> Double {\n/**\nCalcula la puntuación final para un concursante eliminando las puntuaciones más altas y más bajas del\narreglo dado de puntuaciones y luego calculando el promedio de las puntuaciones restantes.\nEl resultado se redondea a dos decimales.\n\n- Parámetros:\n- scores: Un arreglo de `Double` que representa las puntuaciones dadas por cada juez.\n\n- Retorna: Un `Double` que representa la puntuación final del concursante, redondeada a dos decimales.\n\nEjemplos:\n>>> calculateFinalScore([6.0, 7.5, 8.0, 7.0, 6.5])\n7.00\n*/",
      "arb": "import Foundation\nfunc calculateFinalScore(_ scores: [Double]) -> Double {\n/**\nتحسب النتيجة النهائية لمتسابق عن طريق إزالة أعلى وأدنى الدرجات من\nالمصفوفة المعطاة من الدرجات ثم حساب متوسط الدرجات المتبقية.\nيتم تقريب النتيجة إلى منزلتين عشريتين.\n\n- Parameters:\n- scores: مصفوفة من `Double` تمثل الدرجات المعطاة من قبل كل حكم.\n\n- Returns: قيمة `Double` تمثل النتيجة النهائية للمتسابق، مقربة إلى منزلتين عشريتين.\n\nأمثلة:\n>>> calculateFinalScore([6.0, 7.5, 8.0, 7.0, 6.5])\n7.00\n*/",
      "sw": "import Foundation\nfunc calculateFinalScore(_ scores: [Double]) -> Double {\n/**\nHesabu alama ya mwisho kwa mshiriki kwa kuondoa alama za juu na za chini kutoka kwenye\norodha ya alama zilizotolewa na kisha kuhesabu wastani wa alama zilizobaki.\nMatokeo yanazungushwa hadi sehemu mbili za desimali.\n\n- Vigezo:\n- scores: Orodha ya `Double` inayowakilisha alama zilizotolewa na kila jaji.\n\n- Inarejesha: `Double` inayowakilisha alama ya mwisho ya mshiriki, iliyozungushwa hadi sehemu mbili za desimali.\n\nMifano:\n>>> calculateFinalScore([6.0, 7.5, 8.0, 7.0, 6.5])\n7.00\n*/",
      "tr": "import Foundation\nfunc calculateFinalScore(_ scores: [Double]) -> Double {\n/**\nBir yarışmacının nihai puanını hesaplar, verilen puanlar dizisinden en yüksek ve en düşük puanları çıkarır ve ardından kalan puanların ortalamasını hesaplar.\nSonuç, iki ondalık basamağa yuvarlanır.\n\n- Parametreler:\n- scores: Her hakem tarafından verilen puanları temsil eden `Double` türünde bir dizi.\n\n- Dönüş: Yarışmacının nihai puanını temsil eden, iki ondalık basamağa yuvarlanmış bir `Double`.\n\nÖrnekler:\n>>> calculateFinalScore([6.0, 7.5, 8.0, 7.0, 6.5])\n7.00\n*/",
      "vi": "import Foundation\nfunc calculateFinalScore(_ scores: [Double]) -> Double {\n/**\nTính điểm cuối cùng cho một thí sinh bằng cách loại bỏ điểm cao nhất và thấp nhất từ\nmảng điểm số đã cho và sau đó tính trung bình của các điểm số còn lại.\nKết quả được làm tròn đến hai chữ số thập phân.\n\n- Tham số:\n- scores: Một mảng `Double` đại diện cho điểm số được cho bởi mỗi giám khảo.\n\n- Trả về: Một `Double` đại diện cho điểm cuối cùng của thí sinh, được làm tròn đến hai chữ số thập phân.\n\nVí dụ:\n>>> calculateFinalScore([6.0, 7.5, 8.0, 7.0, 6.5])\n7.00\n*/"
    },
    "prompt_bertscore": {
      "es": "0.9947492058773427",
      "arb": "0.99017296052868",
      "sw": "0.9727566514587789",
      "tr": "0.9879167180305046",
      "vi": "0.9829233488816685"
    },
    "canonical_solution": "guard !scores.isEmpty else { return 0.0 }\nlet sortedScores = scores.sorted()\nlet filteredScores = sortedScores.dropFirst().dropLast()\nlet averageScore = filteredScores.reduce(0, +) / Double(filteredScores.count)\nreturn Double(round(100 * averageScore) / 100)\n}",
    "instruction": {
      "en": "func calculateFinalScore(_ scores: [Double]) -> Double {\nguard !scores.isEmpty else { return 0.0 }\nlet sortedScores = scores.sorted()\nlet filteredScores = sortedScores.dropFirst().dropLast()\nlet averageScore = filteredScores.reduce(0, +) / Double(filteredScores.count)\nreturn Double(round(100 * averageScore) / 100)\n}\n\nProvide a concise natural language description (docstring) of the Swift code in English using at most 500 characters.",
      "es": "func calculateFinalScore(_ scores: [Double]) -> Double {\nguard !scores.isEmpty else { return 0.0 }\nlet sortedScores = scores.sorted()\nlet filteredScores = sortedScores.dropFirst().dropLast()\nlet averageScore = filteredScores.reduce(0, +) / Double(filteredScores.count)\nreturn Double(round(100 * averageScore) / 100)\n}\n\nProporcione una descripción concisa en lenguaje natural (docstring) del código Swift en español utilizando como máximo 500 caracteres.",
      "arb": "func calculateFinalScore(_ scores: [Double]) -> Double {\nguard !scores.isEmpty else { return 0.0 }\nlet sortedScores = scores.sorted()\nlet filteredScores = sortedScores.dropFirst().dropLast()\nlet averageScore = filteredScores.reduce(0, +) / Double(filteredScores.count)\nreturn Double(round(100 * averageScore) / 100)\n}\n\nقدم وصفًا موجزًا بلغة طبيعية (docstring) لكود Swift باللغة العربية الفصحى باستخدام 500 حرف كحد أقصى.",
      "sw": "func calculateFinalScore(_ scores: [Double]) -> Double {\nguard !scores.isEmpty else { return 0.0 }\nlet sortedScores = scores.sorted()\nlet filteredScores = sortedScores.dropFirst().dropLast()\nlet averageScore = filteredScores.reduce(0, +) / Double(filteredScores.count)\nreturn Double(round(100 * averageScore) / 100)\n}\n\nToa maelezo mafupi ya lugha asilia (docstring) ya msimbo wa Swift kwa Kiswahili kwa kutumia herufi zisizozidi 500.",
      "tr": "func calculateFinalScore(_ scores: [Double]) -> Double {\nguard !scores.isEmpty else { return 0.0 }\nlet sortedScores = scores.sorted()\nlet filteredScores = sortedScores.dropFirst().dropLast()\nlet averageScore = filteredScores.reduce(0, +) / Double(filteredScores.count)\nreturn Double(round(100 * averageScore) / 100)\n}\n\nSwift kodunun işlevini açıklayan kısa bir doğal dil tanımı (docstring) sağlayın. Açıklama, Türkçe olarak en fazla 500 karakter kullanılarak yazılmalıdır.",
      "vi": "func calculateFinalScore(_ scores: [Double]) -> Double {\nguard !scores.isEmpty else { return 0.0 }\nlet sortedScores = scores.sorted()\nlet filteredScores = sortedScores.dropFirst().dropLast()\nlet averageScore = filteredScores.reduce(0, +) / Double(filteredScores.count)\nreturn Double(round(100 * averageScore) / 100)\n}\n\nCung cấp mô tả ngắn gọn bằng ngôn ngữ tự nhiên (docstring) cho mã Swift bằng tiếng Việt, sử dụng tối đa 500 ký tự."
    },
    "instruction_bertscore": {
      "es": "0.9676013985493994",
      "arb": "0.9017943587910168",
      "sw": "0.942496901951162",
      "tr": "0.870516032689453",
      "vi": "0.9256006072188102"
    },
    "level": "",
    "test": "func testCalculateFinalScore() {\nassert(calculateFinalScore([10.0, 8.5, 9.0, 9.5, 10.0]) == 9.50)\nassert(calculateFinalScore([6.0, 7.5, 8.0, 7.0, 6.5]) == 7.00)\nassert(calculateFinalScore([5.0, 5.5, 6.0, 5.5, 5.0]) == 5.33)\nassert(calculateFinalScore([]) == 0.0)\n}\n\ntestCalculateFinalScore()",
    "entry_point": "calculateFinalScore",
    "signature": "func calculateFinalScore(_ scores: [Double]) -> Double {",
    "docstring": {
      "en": "\nCalculates the final score for a contestant by removing the highest and lowest scores from the\ngiven array of scores and then calculating the average of the remaining scores. \nThe result is rounded to two decimal places.\n\n- Parameters:\n- scores: An array of `Double` representing the scores given by each judge.\n\n- Returns: A `Double` representing the final score of the contestant, rounded to two decimal places.\n\nExamples:\n>>> calculateFinalScore([6.0, 7.5, 8.0, 7.0, 6.5])\n7.00\n",
      "es": "Calcula la puntuación final para un concursante eliminando las puntuaciones más alta y más baja del\narreglo de puntuaciones dado y luego calculando el promedio de las puntuaciones restantes.\nEl resultado se redondea a dos decimales.\n\n- Parámetros:\n- scores: Un arreglo de `Double` que representa las puntuaciones dadas por cada juez.\n\n- Devuelve: Un `Double` que representa la puntuación final del concursante, redondeada a dos decimales.\n\nEjemplos:\n>>> calculateFinalScore([6.0, 7.5, 8.0, 7.0, 6.5])\n7.00",
      "arb": "يحسب النتيجة النهائية لمتسابق عن طريق إزالة أعلى وأدنى الدرجات من المصفوفة المعطاة للدرجات ثم حساب متوسط الدرجات المتبقية. يتم تقريب النتيجة إلى منزلتين عشريتين.\n\n- المعلمات:\n- scores: مصفوفة من `Double` تمثل الدرجات المعطاة من قبل كل حكم.\n\n- العوائد: `Double` يمثل النتيجة النهائية للمتسابق، مقربة إلى منزلتين عشريتين.\n\nأمثلة:\n>>> calculateFinalScore([6.0, 7.5, 8.0, 7.0, 6.5])\n7.00",
      "sw": "Hesabu alama ya mwisho kwa mshiriki kwa kuondoa alama ya juu na ya chini kutoka kwenye safu iliyotolewa ya alama na kisha kuhesabu wastani wa alama zilizobaki. \nMatokeo yanazungushwa hadi sehemu mbili za desimali.\n\n- Vigezo:\n- scores: Safu ya `Double` inayowakilisha alama zilizotolewa na kila jaji.\n\n- Inarudisha: `Double` inayowakilisha alama ya mwisho ya mshiriki, iliyozungushwa hadi sehemu mbili za desimali.\n\nMifano:\n>>> calculateFinalScore([6.0, 7.5, 8.0, 7.0, 6.5])\n7.00",
      "tr": "Verilen puanlar dizisinden en yüksek ve en düşük puanları çıkararak bir yarışmacının nihai puanını hesaplar ve ardından kalan puanların ortalamasını hesaplar. Sonuç, iki ondalık basamağa yuvarlanır.\n\n- Parametreler:\n- scores: Her bir jüri tarafından verilen puanları temsil eden bir `Double` dizisi.\n\n- Döndürür: Yarışmacının nihai puanını temsil eden ve iki ondalık basamağa yuvarlanmış bir `Double`.\n\nÖrnekler:\n>>> calculateFinalScore([6.0, 7.5, 8.0, 7.0, 6.5])\n7.00",
      "vi": "Tính điểm cuối cùng cho một thí sinh bằng cách loại bỏ điểm cao nhất và thấp nhất từ mảng điểm đã cho và sau đó tính trung bình của các điểm còn lại. Kết quả được làm tròn đến hai chữ số thập phân.\n\n- Tham số:\n- scores: Một mảng `Double` đại diện cho điểm số được cho bởi mỗi giám khảo.\n\n- Trả về: Một `Double` đại diện cho điểm cuối cùng của thí sinh, được làm tròn đến hai chữ số thập phân.\n\nVí dụ:\n>>> calculateFinalScore([6.0, 7.5, 8.0, 7.0, 6.5])\n7.00"
    },
    "docstring_bertscore": {
      "es": "0.992666566332192",
      "arb": "0.98531704360352",
      "sw": "0.9823459303640002",
      "tr": "0.9534763948932464",
      "vi": "0.9757613332326937"
    }
  },
  {
    "task_id": "Swift/40",
    "prompt": {
      "en": "import Foundation\n\nfunc minimumTasteDifference(_ ingredients: [(sourness: Int, bitterness: Int)]) -> Int {\n/**\nCalculates the minimum absolute difference between the total sourness and total bitterness of a combination of ingredients. The total sourness is the product of the sourness of each ingredient used, and the total bitterness is the sum of the bitterness of each ingredient used. At least one ingredient must be used.\n\n- Parameters:\n- ingredients: An array of tuples, where each tuple contains the sourness and bitterness of an ingredient.\n\n- Returns: The minimum absolute difference between total sourness and total bitterness.\n\nExample:\n>>> minimumTasteDifference([(3, 10)])\n7\n\n>>> minimumTasteDifference([(3, 8), (5, 8)])\n1\n\n*/",
      "es": "import Foundation\n\nfunc minimumTasteDifference(_ ingredients: [(sourness: Int, bitterness: Int)]) -> Int {\n/**\nCalcula la diferencia mínima absoluta entre la acidez total y la amargura total de una combinación de ingredientes. La acidez total es el producto de la acidez de cada ingrediente utilizado, y la amargura total es la suma de la amargura de cada ingrediente utilizado. Se debe usar al menos un ingrediente.\n\n- Parameters:\n- ingredients: Un arreglo de tuplas, donde cada tupla contiene la acidez y la amargura de un ingrediente.\n\n- Returns: La diferencia mínima absoluta entre la acidez total y la amargura total.\n\nExample:\n>>> minimumTasteDifference([(3, 10)])\n7\n\n>>> minimumTasteDifference([(3, 8), (5, 8)])\n1\n\n*/",
      "arb": "import Foundation\n\nfunc minimumTasteDifference(_ ingredients: [(sourness: Int, bitterness: Int)]) -> Int {\n/**\nيحسب الحد الأدنى للفرق المطلق بين الحموضة الكلية والمرارة الكلية لمجموعة من المكونات. الحموضة الكلية هي ناتج حموضة كل مكون مستخدم، والمرارة الكلية هي مجموع مرارة كل مكون مستخدم. يجب استخدام مكون واحد على الأقل.\n\n- Parameters:\n- ingredients: مصفوفة من الأزواج، حيث يحتوي كل زوج على حموضة ومرارة مكون.\n\n- Returns: الحد الأدنى للفرق المطلق بين الحموضة الكلية والمرارة الكلية.\n\nمثال:\n>>> minimumTasteDifference([(3, 10)])\n7\n\n>>> minimumTasteDifference([(3, 8), (5, 8)])\n1\n\n*/",
      "sw": "import Foundation\n\nfunc minimumTasteDifference(_ ingredients: [(sourness: Int, bitterness: Int)]) -> Int {\n/**\nInahesabu tofauti ndogo kabisa ya thamani kati ya uchachu wa jumla na uchungu wa jumla wa mchanganyiko wa viungo. Uchachu wa jumla ni zao la uchachu wa kila kiungo kilichotumika, na uchungu wa jumla ni jumla ya uchungu wa kila kiungo kilichotumika. Angalau kiungo kimoja lazima kitumike.\n\n- Vigezo:\n- ingredients: Mfululizo wa jozi, ambapo kila jozi ina uchachu na uchungu wa kiungo.\n\n- Inarudisha: Tofauti ndogo kabisa ya thamani kati ya uchachu wa jumla na uchungu wa jumla.\n\nMfano:\n>>> minimumTasteDifference([(3, 10)])\n7\n\n>>> minimumTasteDifference([(3, 8), (5, 8)])\n1\n\n*/",
      "tr": "import Foundation\n\nfunc minimumTasteDifference(_ ingredients: [(sourness: Int, bitterness: Int)]) -> Int {\n/**\nBir bileşen kombinasyonunun toplam ekşiliği ile toplam acılığı arasındaki minimum mutlak farkı hesaplar. Toplam ekşilik, kullanılan her bir bileşenin ekşiliğinin çarpımıdır ve toplam acılık, kullanılan her bir bileşenin acılığının toplamıdır. En az bir bileşen kullanılmalıdır.\n\n- Parametreler:\n- ingredients: Her bir demetin bir bileşenin ekşiliği ve acılığını içerdiği demetlerden oluşan bir dizi.\n\n- Dönüş: Toplam ekşilik ile toplam acılık arasındaki minimum mutlak fark.\n\nÖrnek:\n>>> minimumTasteDifference([(3, 10)])\n7\n\n>>> minimumTasteDifference([(3, 8), (5, 8)])\n1\n\n*/",
      "vi": "import Foundation\n\nfunc minimumTasteDifference(_ ingredients: [(sourness: Int, bitterness: Int)]) -> Int {\n/**\nTính toán sự khác biệt tuyệt đối nhỏ nhất giữa tổng độ chua và tổng độ đắng của một tổ hợp các nguyên liệu. Tổng độ chua là tích của độ chua của mỗi nguyên liệu được sử dụng, và tổng độ đắng là tổng của độ đắng của mỗi nguyên liệu được sử dụng. Ít nhất một nguyên liệu phải được sử dụng.\n\n- Tham số:\n- ingredients: Một mảng các bộ giá trị, trong đó mỗi bộ giá trị chứa độ chua và độ đắng của một nguyên liệu.\n\n- Trả về: Sự khác biệt tuyệt đối nhỏ nhất giữa tổng độ chua và tổng độ đắng.\n\nVí dụ:\n>>> minimumTasteDifference([(3, 10)])\n7\n\n>>> minimumTasteDifference([(3, 8), (5, 8)])\n1\n\n*/"
    },
    "prompt_bertscore": {
      "es": "0.9884669241859713",
      "arb": "0.9814491141936277",
      "sw": "0.9551470750281309",
      "tr": "0.9979982030199304",
      "vi": "0.9840849393499607"
    },
    "canonical_solution": "var minDifference = Int.max\n\nfunc calculateDifference(_ index: Int, _ currentSour: Int, _ currentBitter: Int) {\nif index == ingredients.count {\nif currentSour != 1 {\nlet difference = abs(currentSour - currentBitter)\nminDifference = min(minDifference, difference)\n}\nreturn\n}\n\ncalculateDifference(index + 1, currentSour * ingredients[index].sourness, currentBitter + ingredients[index].bitterness)\ncalculateDifference(index + 1, currentSour, currentBitter)\n}\n\ncalculateDifference(0, 1, 0)\nreturn minDifference\n}",
    "instruction": {
      "en": "func minimumTasteDifference(_ ingredients: [(sourness: Int, bitterness: Int)]) -> Int {\nvar minDifference = Int.max\n\nfunc calculateDifference(_ index: Int, _ currentSour: Int, _ currentBitter: Int) {\nif index == ingredients.count {\nif currentSour != 1 {\nlet difference = abs(currentSour - currentBitter)\nminDifference = min(minDifference, difference)\n}\nreturn\n}\n\ncalculateDifference(index + 1, currentSour * ingredients[index].sourness, currentBitter + ingredients[index].bitterness)\ncalculateDifference(index + 1, currentSour, currentBitter)\n}\n\ncalculateDifference(0, 1, 0)\nreturn minDifference\n}\n\nProvide a concise natural language description (docstring) of the Swift code in English using at most 500 characters.",
      "es": "func minimumTasteDifference(_ ingredients: [(sourness: Int, bitterness: Int)]) -> Int {\nvar minDifference = Int.max\n\nfunc calculateDifference(_ index: Int, _ currentSour: Int, _ currentBitter: Int) {\nif index == ingredients.count {\nif currentSour != 1 {\nlet difference = abs(currentSour - currentBitter)\nminDifference = min(minDifference, difference)\n}\nreturn\n}\n\ncalculateDifference(index + 1, currentSour * ingredients[index].sourness, currentBitter + ingredients[index].bitterness)\ncalculateDifference(index + 1, currentSour, currentBitter)\n}\n\ncalculateDifference(0, 1, 0)\nreturn minDifference\n}\n\nProporcione una descripción concisa en lenguaje natural (docstring) del código Swift en español utilizando como máximo 500 caracteres.",
      "arb": "func minimumTasteDifference(_ ingredients: [(sourness: Int, bitterness: Int)]) -> Int {\nvar minDifference = Int.max\n\nfunc calculateDifference(_ index: Int, _ currentSour: Int, _ currentBitter: Int) {\nif index == ingredients.count {\nif currentSour != 1 {\nlet difference = abs(currentSour - currentBitter)\nminDifference = min(minDifference, difference)\n}\nreturn\n}\n\ncalculateDifference(index + 1, currentSour * ingredients[index].sourness, currentBitter + ingredients[index].bitterness)\ncalculateDifference(index + 1, currentSour, currentBitter)\n}\n\ncalculateDifference(0, 1, 0)\nreturn minDifference\n}\n\nقدم وصفًا موجزًا بلغة طبيعية (docstring) لكود Swift باللغة العربية الفصحى باستخدام 500 حرف على الأكثر.",
      "sw": "func minimumTasteDifference(_ ingredients: [(sourness: Int, bitterness: Int)]) -> Int {\nvar minDifference = Int.max\n\nfunc calculateDifference(_ index: Int, _ currentSour: Int, _ currentBitter: Int) {\nif index == ingredients.count {\nif currentSour != 1 {\nlet difference = abs(currentSour - currentBitter)\nminDifference = min(minDifference, difference)\n}\nreturn\n}\n\ncalculateDifference(index + 1, currentSour * ingredients[index].sourness, currentBitter + ingredients[index].bitterness)\ncalculateDifference(index + 1, currentSour, currentBitter)\n}\n\ncalculateDifference(0, 1, 0)\nreturn minDifference\n}\n\nToa maelezo mafupi ya lugha ya asili (docstring) ya msimbo wa Swift kwa Kiswahili kwa kutumia herufi zisizozidi 500.",
      "tr": "func minimumTasteDifference(_ ingredients: [(sourness: Int, bitterness: Int)]) -> Int {\nvar minDifference = Int.max\n\nfunc calculateDifference(_ index: Int, _ currentSour: Int, _ currentBitter: Int) {\nif index == ingredients.count {\nif currentSour != 1 {\nlet difference = abs(currentSour - currentBitter)\nminDifference = min(minDifference, difference)\n}\nreturn\n}\n\ncalculateDifference(index + 1, currentSour * ingredients[index].sourness, currentBitter + ingredients[index].bitterness)\ncalculateDifference(index + 1, currentSour, currentBitter)\n}\n\ncalculateDifference(0, 1, 0)\nreturn minDifference\n}\n\nSwift kodunun Türkçe açıklamasını en fazla 500 karakter kullanarak doğal dilde sağlayın.",
      "vi": "func minimumTasteDifference(_ ingredients: [(sourness: Int, bitterness: Int)]) -> Int {\nvar minDifference = Int.max\n\nfunc calculateDifference(_ index: Int, _ currentSour: Int, _ currentBitter: Int) {\nif index == ingredients.count {\nif currentSour != 1 {\nlet difference = abs(currentSour - currentBitter)\nminDifference = min(minDifference, difference)\n}\nreturn\n}\n\ncalculateDifference(index + 1, currentSour * ingredients[index].sourness, currentBitter + ingredients[index].bitterness)\ncalculateDifference(index + 1, currentSour, currentBitter)\n}\n\ncalculateDifference(0, 1, 0)\nreturn minDifference\n}\n\nCung cấp mô tả ngắn gọn bằng ngôn ngữ tự nhiên (docstring) cho mã Swift bằng tiếng Việt, sử dụng tối đa 500 ký tự."
    },
    "instruction_bertscore": {
      "es": "0.9676013985493994",
      "arb": "0.8880608556158835",
      "sw": "0.9148419912604365",
      "tr": "0.8359944697263515",
      "vi": "0.9172950764662174"
    },
    "level": "",
    "test": "func testMinimumTasteDifference() {\nassert(minimumTasteDifference([(3, 10)]) == 7)\nassert(minimumTasteDifference([(3, 8), (5, 8)]) == 1)\nassert(minimumTasteDifference([(1, 2), (2, 3), (3, 4)]) == 1)\nassert(minimumTasteDifference([(2, 4), (3, 6)]) == 2)\nassert(minimumTasteDifference([(1, 3), (2, 5), (4, 1)]) == 0)\n}\n\ntestMinimumTasteDifference()",
    "entry_point": "minimumTasteDifference",
    "signature": "func minimumTasteDifference(_ ingredients: [(sourness: Int, bitterness: Int)]) -> Int {",
    "docstring": {
      "en": "\nCalculates the minimum absolute difference between the total sourness and total bitterness of a combination of ingredients. The total sourness is the product of the sourness of each ingredient used, and the total bitterness is the sum of the bitterness of each ingredient used. At least one ingredient must be used.\n\n- Parameters:\n- ingredients: An array of tuples, where each tuple contains the sourness and bitterness of an ingredient.\n\n- Returns: The minimum absolute difference between total sourness and total bitterness.\n\nExample:\n>>> minimumTasteDifference([(3, 10)])\n7\n\n>>> minimumTasteDifference([(3, 8), (5, 8)])\n1\n\n",
      "es": "Calcula la diferencia mínima absoluta entre la acidez total y la amargura total de una combinación de ingredientes. La acidez total es el producto de la acidez de cada ingrediente utilizado, y la amargura total es la suma de la amargura de cada ingrediente utilizado. Se debe utilizar al menos un ingrediente.\n\n- Parámetros:\n- ingredients: Un arreglo de tuplas, donde cada tupla contiene la acidez y la amargura de un ingrediente.\n\n- Devuelve: La diferencia mínima absoluta entre la acidez total y la amargura total.\n\nEjemplo:\n>>> minimumTasteDifference([(3, 10)])\n7\n\n>>> minimumTasteDifference([(3, 8), (5, 8)])\n1",
      "arb": "يحسب الحد الأدنى للفرق المطلق بين الحموضة الكلية والمرارة الكلية لمجموعة من المكونات. الحموضة الكلية هي ناتج حموضة كل مكون مستخدم، والمرارة الكلية هي مجموع مرارة كل مكون مستخدم. يجب استخدام مكون واحد على الأقل.\n\n- المعطيات:\n- ingredients: مصفوفة من الأزواج، حيث يحتوي كل زوج على حموضة ومرارة مكون.\n\n- يعيد: الحد الأدنى للفرق المطلق بين الحموضة الكلية والمرارة الكلية.\n\nمثال:\n>>> minimumTasteDifference([(3, 10)])\n7\n\n>>> minimumTasteDifference([(3, 8), (5, 8)])\n1",
      "sw": "Hesabu tofauti ndogo kabisa ya thamani kati ya jumla ya uchachu na jumla ya uchungu wa mchanganyiko wa viungo. Jumla ya uchachu ni bidhaa ya uchachu wa kila kiungo kinachotumika, na jumla ya uchungu ni jumla ya uchungu wa kila kiungo kinachotumika. Angalau kiungo kimoja lazima kitumike.\n\n- Vigezo:\n- ingredients: Mfululizo wa jozi, ambapo kila jozi ina uchachu na uchungu wa kiungo.\n\n- Inarejesha: Tofauti ndogo kabisa ya thamani kati ya jumla ya uchachu na jumla ya uchungu.\n\nMfano:\n>>> minimumTasteDifference([(3, 10)])\n7\n\n>>> minimumTasteDifference([(3, 8), (5, 8)])\n1",
      "tr": "Toplam ekşilik ve toplam acılık arasındaki minimum mutlak farkı hesaplar. Toplam ekşilik, kullanılan her bir malzemenin ekşiliğinin çarpımıdır ve toplam acılık, kullanılan her bir malzemenin acılığının toplamıdır. En az bir malzeme kullanılmalıdır.\n\n- Parametreler:\n- ingredients: Her bir demetin bir malzemenin ekşiliğini ve acılığını içerdiği demetlerden oluşan bir dizi.\n\n- Döndürür: Toplam ekşilik ve toplam acılık arasındaki minimum mutlak fark.\n\nÖrnek:\n>>> minimumTasteDifference([(3, 10)])\n7\n\n>>> minimumTasteDifference([(3, 8), (5, 8)])\n1",
      "vi": "Tính toán sự khác biệt tuyệt đối nhỏ nhất giữa tổng độ chua và tổng độ đắng của một tổ hợp nguyên liệu. Tổng độ chua là tích của độ chua của mỗi nguyên liệu được sử dụng, và tổng độ đắng là tổng của độ đắng của mỗi nguyên liệu được sử dụng. Ít nhất một nguyên liệu phải được sử dụng.\n\n- Tham số:\n- ingredients: Một mảng các bộ giá trị, trong đó mỗi bộ chứa độ chua và độ đắng của một nguyên liệu.\n\n- Trả về: Sự khác biệt tuyệt đối nhỏ nhất giữa tổng độ chua và tổng độ đắng.\n\nVí dụ:\n>>> minimumTasteDifference([(3, 10)])\n7\n\n>>> minimumTasteDifference([(3, 8), (5, 8)])\n1"
    },
    "docstring_bertscore": {
      "es": "0.9558577745314737",
      "arb": "0.9392357883553312",
      "sw": "0.9538931214326576",
      "tr": "0.9765508889973074",
      "vi": "0.9865398122291708"
    }
  },
  {
    "task_id": "Swift/41",
    "prompt": {
      "en": "func calculateProductOfSumAndValue(_ a: Int, _ b: Int, _ c: Int) -> Int {\n    /**\n    Calculates the product of the sum of the first two integers and the third integer.\n\n    This function takes three integers as input and computes the product of the sum of the first two integers (a and b) and the third integer (c), effectively calculating (a+b)*c.\n\n    - Parameters:\n        - a: The first integer.\n        - b: The second integer.\n        - c: The third integer.\n\n    - Returns: An integer that is the product of (a+b) and c.\n\n    ### Example:\n    calculateProductOfSumAndValue(1, 2, 3) // Returns 9 because (1+2)*3 = 9\n    calculateProductOfSumAndValue(-1, -2, -3) // Returns -9 because (-1-2)*-3 = 9\n    */",
      "es": "func calculateProductOfSumAndValue(_ a: Int, _ b: Int, _ c: Int) -> Int {\n    /**\n    Calcula el producto de la suma de los dos primeros enteros y el tercer entero.\n\n    Esta función toma tres enteros como entrada y calcula el producto de la suma de los dos primeros enteros (a y b) y el tercer entero (c), calculando efectivamente (a+b)*c.\n\n    - Parámetros:\n        - a: El primer entero.\n        - b: El segundo entero.\n        - c: El tercer entero.\n\n    - Retorna: Un entero que es el producto de (a+b) y c.\n\n    ### Ejemplo:\n    calculateProductOfSumAndValue(1, 2, 3) // Retorna 9 porque (1+2)*3 = 9\n    calculateProductOfSumAndValue(-1, -2, -3) // Retorna -9 porque (-1-2)*-3 = 9\n    */",
      "arb": "func calculateProductOfSumAndValue(_ a: Int, _ b: Int, _ c: Int) -> Int {\n    /**\n    يحسب حاصل ضرب مجموع العددين الأولين والعدد الثالث.\n\n    تأخذ هذه الدالة ثلاثة أعداد صحيحة كمدخلات وتحسب حاصل ضرب مجموع العددين الأولين (a و b) والعدد الثالث (c)، مما يعني حساب (a+b)*c.\n\n    - Parameters:\n        - a: العدد الصحيح الأول.\n        - b: العدد الصحيح الثاني.\n        - c: العدد الصحيح الثالث.\n\n    - Returns: عدد صحيح وهو حاصل ضرب (a+b) و c.\n\n    ### مثال:\n    calculateProductOfSumAndValue(1, 2, 3) // Returns 9 لأن (1+2)*3 = 9\n    calculateProductOfSumAndValue(-1, -2, -3) // Returns -9 لأن (-1-2)*-3 = 9\n    */",
      "sw": "func calculateProductOfSumAndValue(_ a: Int, _ b: Int, _ c: Int) -> Int {\n    /**\n    Inahesabu bidhaa ya jumla ya namba mbili za kwanza na namba ya tatu.\n\n    Kazi hii inachukua namba tatu kama pembejeo na inahesabu bidhaa ya jumla ya namba mbili za kwanza (a na b) na namba ya tatu (c), kwa ufanisi inahesabu (a+b)*c.\n\n    - Vigezo:\n        - a: Namba ya kwanza.\n        - b: Namba ya pili.\n        - c: Namba ya tatu.\n\n    - Inarejesha: Namba ambayo ni bidhaa ya (a+b) na c.\n\n    ### Mfano:\n    calculateProductOfSumAndValue(1, 2, 3) // Inarejesha 9 kwa sababu (1+2)*3 = 9\n    calculateProductOfSumAndValue(-1, -2, -3) // Inarejesha -9 kwa sababu (-1-2)*-3 = 9\n    */",
      "tr": "func calculateProductOfSumAndValue(_ a: Int, _ b: Int, _ c: Int) -> Int {\n    /**\n    İlk iki tam sayının toplamı ile üçüncü tam sayının çarpımını hesaplar.\n\n    Bu fonksiyon üç tam sayıyı girdi olarak alır ve ilk iki tam sayının (a ve b) toplamı ile üçüncü tam sayının (c) çarpımını hesaplar, yani (a+b)*c hesaplamasını yapar.\n\n    - Parametreler:\n        - a: Birinci tam sayı.\n        - b: İkinci tam sayı.\n        - c: Üçüncü tam sayı.\n\n    - Döndürür: (a+b) ve c'nin çarpımı olan bir tam sayı.\n\n    ### Örnek:\n    calculateProductOfSumAndValue(1, 2, 3) // (1+2)*3 = 9 olduğu için 9 döndürür\n    calculateProductOfSumAndValue(-1, -2, -3) // (-1-2)*-3 = 9 olduğu için -9 döndürür\n    */",
      "vi": "func calculateProductOfSumAndValue(_ a: Int, _ b: Int, _ c: Int) -> Int {\n    /**\n    Tính tích của tổng hai số nguyên đầu tiên và số nguyên thứ ba.\n\n    Hàm này nhận ba số nguyên làm đầu vào và tính tích của tổng hai số nguyên đầu tiên (a và b) và số nguyên thứ ba (c), thực hiện phép tính (a+b)*c.\n\n    - Tham số:\n        - a: Số nguyên thứ nhất.\n        - b: Số nguyên thứ hai.\n        - c: Số nguyên thứ ba.\n\n    - Trả về: Một số nguyên là tích của (a+b) và c.\n\n    ### Ví dụ:\n    calculateProductOfSumAndValue(1, 2, 3) // Trả về 9 vì (1+2)*3 = 9\n    calculateProductOfSumAndValue(-1, -2, -3) // Trả về -9 vì (-1-2)*-3 = 9\n    */"
    },
    "prompt_bertscore": {
      "es": "0.9948121717081307",
      "arb": "0.9821808685173602",
      "sw": "0.9719130682305237",
      "tr": "0.9740870777509506",
      "vi": "0.9875768614485539"
    },
    "canonical_solution": "    return (a + b) * c\n}",
    "instruction": {
      "en": "func calculateProductOfSumAndValue(_ a: Int, _ b: Int, _ c: Int) -> Int {\n    return (a + b) * c\n}\n\nProvide a concise natural language description (docstring) of the Swift code in English using at most 500 characters.",
      "es": "func calculateProductOfSumAndValue(_ a: Int, _ b: Int, _ c: Int) -> Int {\n    return (a + b) * c\n}\n\nProporcione una descripción concisa en lenguaje natural (docstring) del código Swift en español utilizando un máximo de 500 caracteres.",
      "arb": "func calculateProductOfSumAndValue(_ a: Int, _ b: Int, _ c: Int) -> Int {\n    return (a + b) * c\n}\n\nقدم وصفًا موجزًا بلغة طبيعية (docstring) للكود المكتوب بلغة Swift باللغة العربية الفصحى باستخدام 500 حرف كحد أقصى.",
      "sw": "func calculateProductOfSumAndValue(_ a: Int, _ b: Int, _ c: Int) -> Int {\n    return (a + b) * c\n}\n\nToa maelezo mafupi ya lugha ya asili (docstring) ya msimbo wa Swift kwa Kiswahili kwa kutumia herufi zisizozidi 500.",
      "tr": "func calculateProductOfSumAndValue(_ a: Int, _ b: Int, _ c: Int) -> Int {\n    return (a + b) * c\n}\n\nSwift kodunun işlevini açıklayan kısa bir doğal dil açıklaması (docstring) sağlayın. Açıklama Türkçe olmalı ve en fazla 500 karakter içermelidir.",
      "vi": "func calculateProductOfSumAndValue(_ a: Int, _ b: Int, _ c: Int) -> Int {\n    return (a + b) * c\n}\n\nCung cấp mô tả ngắn gọn bằng ngôn ngữ tự nhiên (docstring) cho mã Swift bằng tiếng Việt, sử dụng tối đa 500 ký tự."
    },
    "instruction_bertscore": {
      "es": "0.9676013985493994",
      "arb": "0.9132938660706507",
      "sw": "0.9096853479383898",
      "tr": "0.8726445558526228",
      "vi": "0.9394594461643764"
    },
    "level": "",
    "test": "func testCalculateProductOfSumAndValue() {\n    assert(calculateProductOfSumAndValue(1, 2, 3) == 9, \"Test Case 1 Failed\")\n    assert(calculateProductOfSumAndValue(-1, 2, 3) == 3, \"Test Case 2 Failed\")\n    assert(calculateProductOfSumAndValue(-1, -2, -3) == 9, \"Test Case 3 Failed\")\n    assert(calculateProductOfSumAndValue(0, 0, 1) == 0, \"Test Case 4 Failed\")\n    assert(calculateProductOfSumAndValue(10, 20, 30) == 900, \"Test Case 5 Failed\")\n    assert(calculateProductOfSumAndValue(-5, 5, 0) == 0, \"Test Case 6 Failed\")\n    assert(calculateProductOfSumAndValue(100, 200, -1) == -300, \"Test Case 7 Failed\")\n}\n\ntestCalculateProductOfSumAndValue()",
    "entry_point": "calculateProductOfSumAndValue",
    "signature": "func calculateProductOfSumAndValue(_ a: Int, _ b: Int, _ c: Int) -> Int {",
    "docstring": {
      "en": "\nCalculates the product of the sum of the first two integers and the third integer.\n\nThis function takes three integers as input and computes the product of the sum of the first two integers (a and b) and the third integer (c), effectively calculating (a+b)*c.\n\n- Parameters:\n- a: The first integer.\n- b: The second integer.\n- c: The third integer.\n\n- Returns: An integer that is the product of (a+b) and c.\n\n### Example:\ncalculateProductOfSumAndValue(1, 2, 3) // Returns 9 because (1+2)*3 = 9\ncalculateProductOfSumAndValue(-1, -2, -3) // Returns -9 because (-1-2)*-3 = 9\n",
      "es": "Calcula el producto de la suma de los dos primeros enteros y el tercer entero.\n\nEsta función toma tres enteros como entrada y calcula el producto de la suma de los dos primeros enteros (a y b) y el tercer entero (c), calculando efectivamente (a+b)*c.\n\n- Parámetros:\n- a: El primer entero.\n- b: El segundo entero.\n- c: El tercer entero.\n\n- Retorna: Un entero que es el producto de (a+b) y c.\n\n### Ejemplo:\ncalculateProductOfSumAndValue(1, 2, 3) // Retorna 9 porque (1+2)*3 = 9\ncalculateProductOfSumAndValue(-1, -2, -3) // Retorna -9 porque (-1-2)*-3 = 9",
      "arb": "يحسب ناتج ضرب مجموع العددين الصحيحين الأولين والعدد الصحيح الثالث.\n\nتأخذ هذه الدالة ثلاثة أعداد صحيحة كمدخلات وتحسب ناتج ضرب مجموع العددين الصحيحين الأولين (a و b) والعدد الصحيح الثالث (c)، مما يعني حساب (a+b)*c.\n\n- المعاملات:\n- a: العدد الصحيح الأول.\n- b: العدد الصحيح الثاني.\n- c: العدد الصحيح الثالث.\n\n- يعيد: عدد صحيح يمثل ناتج (a+b) و c.\n\n### مثال:\ncalculateProductOfSumAndValue(1, 2, 3) // يعيد 9 لأن (1+2)*3 = 9\ncalculateProductOfSumAndValue(-1, -2, -3) // يعيد -9 لأن (-1-2)*-3 = 9",
      "sw": "Hesabu bidhaa ya jumla ya namba mbili za kwanza na namba ya tatu.\n\nKazi hii inachukua namba tatu kama pembejeo na inahesabu bidhaa ya jumla ya namba mbili za kwanza (a na b) na namba ya tatu (c), kwa ufanisi inahesabu (a+b)*c.\n\n- Vigezo:\n- a: Namba ya kwanza.\n- b: Namba ya pili.\n- c: Namba ya tatu.\n\n- Inarudisha: Namba ambayo ni bidhaa ya (a+b) na c.\n\n### Mfano:\ncalculateProductOfSumAndValue(1, 2, 3) // Inarudisha 9 kwa sababu (1+2)*3 = 9\ncalculateProductOfSumAndValue(-1, -2, -3) // Inarudisha -9 kwa sababu (-1-2)*-3 = 9",
      "tr": "İlk iki tam sayının toplamının üçüncü tam sayı ile çarpımını hesaplar.\n\nBu fonksiyon üç tam sayıyı girdi olarak alır ve ilk iki tam sayının (a ve b) toplamının üçüncü tam sayı (c) ile çarpımını hesaplar, yani (a+b)*c işlemini gerçekleştirir.\n\n- Parametreler:\n- a: İlk tam sayı.\n- b: İkinci tam sayı.\n- c: Üçüncü tam sayı.\n\n- Döndürür: (a+b) ve c'nin çarpımı olan bir tam sayı.\n\n### Örnek:\ncalculateProductOfSumAndValue(1, 2, 3) // 9 döndürür çünkü (1+2)*3 = 9\ncalculateProductOfSumAndValue(-1, -2, -3) // -9 döndürür çünkü (-1-2)*-3 = 9",
      "vi": "Tính tích của tổng hai số nguyên đầu tiên và số nguyên thứ ba.\n\nHàm này nhận ba số nguyên làm đầu vào và tính tích của tổng hai số nguyên đầu tiên (a và b) và số nguyên thứ ba (c), thực hiện tính toán (a+b)*c.\n\n- Tham số:\n- a: Số nguyên thứ nhất.\n- b: Số nguyên thứ hai.\n- c: Số nguyên thứ ba.\n\n- Trả về: Một số nguyên là tích của (a+b) và c.\n\n### Ví dụ:\ncalculateProductOfSumAndValue(1, 2, 3) // Trả về 9 vì (1+2)*3 = 9\ncalculateProductOfSumAndValue(-1, -2, -3) // Trả về -9 vì (-1-2)*-3 = 9"
    },
    "docstring_bertscore": {
      "es": "0.9936809716881371",
      "arb": "0.9805469350029672",
      "sw": "0.9680379881269141",
      "tr": "0.9636162772146964",
      "vi": "0.9875039640987141"
    }
  },
  {
    "task_id": "Swift/42",
    "prompt": {
      "en": "func asciiCode(of character: Character) -> Int {\n    /**\n    Returns the ASCII code of the given character.\n\n    This function takes a single character (excluding space) as input and returns its ASCII code as an integer. The ASCII value is determined based on the character's representation in the ASCII table.\n\n    - Parameter character: A `Character` value representing a visible character (excluding space).\n\n    - Returns: An `Int` representing the ASCII code of the given character.\n\n    ### Example:\n    asciiCode(of: \"A\") // Returns 65\n    asciiCode(of: \"a\") // Returns 97\n    */",
      "es": "func asciiCode(of character: Character) -> Int {\n    /**\n    Devuelve el código ASCII del carácter dado.\n\n    Esta función toma un solo carácter (excluyendo el espacio) como entrada y devuelve su código ASCII como un entero. El valor ASCII se determina según la representación del carácter en la tabla ASCII.\n\n    - Parámetro character: Un valor `Character` que representa un carácter visible (excluyendo el espacio).\n\n    - Devuelve: Un `Int` que representa el código ASCII del carácter dado.\n\n    ### Ejemplo:\n    asciiCode(of: \"A\") // Devuelve 65\n    asciiCode(of: \"a\") // Devuelve 97\n    */",
      "arb": "func asciiCode(of character: Character) -> Int {\n    /**\n    يعيد الكود ASCII للحرف المعطى.\n\n    تأخذ هذه الدالة حرفًا واحدًا (باستثناء المسافة) كمدخل وتعيد كود ASCII الخاص به كعدد صحيح. يتم تحديد قيمة ASCII بناءً على تمثيل الحرف في جدول ASCII.\n\n    - Parameter character: قيمة `Character` تمثل حرفًا مرئيًا (باستثناء المسافة).\n\n    - Returns: قيمة `Int` تمثل كود ASCII للحرف المعطى.\n\n    ### مثال:\n    asciiCode(of: \"A\") // Returns 65\n    asciiCode(of: \"a\") // Returns 97\n    */",
      "sw": "func asciiCode(of character: Character) -> Int {\n    /**\n    Inarudisha msimbo wa ASCII wa herufi iliyopewa.\n\n    Kazi hii inachukua herufi moja (isipokuwa nafasi) kama ingizo na inarudisha msimbo wake wa ASCII kama nambari kamili. Thamani ya ASCII imedhamiriwa kulingana na uwakilishi wa herufi katika jedwali la ASCII.\n\n    - Parameter character: Thamani ya `Character` inayowakilisha herufi inayoonekana (isipokuwa nafasi).\n\n    - Returns: `Int` inayowakilisha msimbo wa ASCII wa herufi iliyopewa.\n\n    ### Mfano:\n    asciiCode(of: \"A\") // Inarudisha 65\n    asciiCode(of: \"a\") // Inarudisha 97\n    */",
      "tr": "func asciiCode(of character: Character) -> Int {\n    /**\n    Verilen karakterin ASCII kodunu döndürür.\n\n    Bu fonksiyon, tek bir karakteri (boşluk hariç) girdi olarak alır ve ASCII kodunu bir tamsayı olarak döndürür. ASCII değeri, karakterin ASCII tablosundaki temsilini temel alarak belirlenir.\n\n    - Parametre karakter: Görünür bir karakteri temsil eden bir `Character` değeri (boşluk hariç).\n\n    - Dönüş: Verilen karakterin ASCII kodunu temsil eden bir `Int`.\n\n    ### Örnek:\n    asciiCode(of: \"A\") // 65 döndürür\n    asciiCode(of: \"a\") // 97 döndürür\n    */",
      "vi": "func asciiCode(of character: Character) -> Int {\n    /**\n    Trả về mã ASCII của ký tự đã cho.\n\n    Hàm này nhận một ký tự đơn (không bao gồm khoảng trắng) làm đầu vào và trả về mã ASCII của nó dưới dạng số nguyên. Giá trị ASCII được xác định dựa trên biểu diễn của ký tự trong bảng ASCII.\n\n    - Tham số character: Một giá trị `Character` đại diện cho một ký tự có thể nhìn thấy (không bao gồm khoảng trắng).\n\n    - Trả về: Một `Int` đại diện cho mã ASCII của ký tự đã cho.\n\n    ### Ví dụ:\n    asciiCode(of: \"A\") // Trả về 65\n    asciiCode(of: \"a\") // Trả về 97\n    */"
    },
    "prompt_bertscore": {
      "es": "0.9984522720709762",
      "arb": "0.9971726951563494",
      "sw": "0.9942395203196072",
      "tr": "0.984975002087378",
      "vi": "0.98984859711645"
    },
    "canonical_solution": "    return Int(character.asciiValue!)\n}",
    "instruction": {
      "en": "func asciiCode(of character: Character) -> Int {\n    return Int(character.asciiValue!)\n}\n\nProvide a concise natural language description (docstring) of the Swift code in English using at most 500 characters.",
      "es": "func asciiCode(of character: Character) -> Int {\n    return Int(character.asciiValue!)\n}\n\nProporcione una descripción concisa en lenguaje natural (docstring) del código Swift en español utilizando un máximo de 500 caracteres.",
      "arb": "func asciiCode(of character: Character) -> Int {\n    return Int(character.asciiValue!)\n}\n\nقدم وصفًا موجزًا بلغة طبيعية (docstring) لكود Swift باللغة العربية الفصحى باستخدام 500 حرف على الأكثر.",
      "sw": "func asciiCode(of character: Character) -> Int {\n    return Int(character.asciiValue!)\n}\n\nToa maelezo mafupi ya lugha asilia (docstring) ya msimbo wa Swift kwa Kiswahili kwa kutumia herufi zisizozidi 500.",
      "tr": "func asciiCode(of character: Character) -> Int {\n    return Int(character.asciiValue!)\n}\n\nSwift kodunun işlevselliğini açıklayan en fazla 500 karakterlik öz bir doğal dil tanımı (docstring) sağlayın.",
      "vi": "func asciiCode(of character: Character) -> Int {\n    return Int(character.asciiValue!)\n}\n\nCung cấp mô tả ngắn gọn bằng ngôn ngữ tự nhiên (docstring) cho mã Swift bằng tiếng Việt, sử dụng tối đa 500 ký tự."
    },
    "instruction_bertscore": {
      "es": "0.9676013985493994",
      "arb": "0.899114437690094",
      "sw": "0.942496901951162",
      "tr": "0.8847687556806113",
      "vi": "0.9256006072188102"
    },
    "level": "",
    "test": "func testAsciiCode() {\n    assert(asciiCode(of: \"A\") == 65, \"Test Case 1 Failed\")\n    assert(asciiCode(of: \"a\") == 97, \"Test Case 2 Failed\")\n    assert(asciiCode(of: \"0\") == 48, \"Test Case 3 Failed\")\n    assert(asciiCode(of: \"#\") == 35, \"Test Case 4 Failed\")\n    assert(asciiCode(of: \"Z\") == 90, \"Test Case 5 Failed\")\n    assert(asciiCode(of: \"z\") == 122, \"Test Case 6 Failed\")\n}\n\ntestAsciiCode()",
    "entry_point": "asciiCode",
    "signature": "func asciiCode(of character: Character) -> Int {",
    "docstring": {
      "en": "\nReturns the ASCII code of the given character.\n\nThis function takes a single character (excluding space) as input and returns its ASCII code as an integer. The ASCII value is determined based on the character's representation in the ASCII table.\n\n- Parameter character: A `Character` value representing a visible character (excluding space).\n\n- Returns: An `Int` representing the ASCII code of the given character.\n\n### Example:\nasciiCode(of: \"A\") // Returns 65\nasciiCode(of: \"a\") // Returns 97\n",
      "es": "Devuelve el código ASCII del carácter dado.\n\nEsta función toma un solo carácter (excluyendo el espacio) como entrada y devuelve su código ASCII como un entero. El valor ASCII se determina en función de la representación del carácter en la tabla ASCII.\n\n- Parámetro character: Un valor `Character` que representa un carácter visible (excluyendo el espacio).\n\n- Devuelve: Un `Int` que representa el código ASCII del carácter dado.\n\n### Ejemplo:\nasciiCode(of: \"A\") // Devuelve 65\nasciiCode(of: \"a\") // Devuelve 97",
      "arb": "يعيد الرمز ASCII للحرف المعطى.\n\nتأخذ هذه الدالة حرفًا واحدًا (باستثناء المسافة) كمدخل وتعيد رمز ASCII الخاص به كعدد صحيح. يتم تحديد قيمة ASCII بناءً على تمثيل الحرف في جدول ASCII.\n\n- Parameter character: قيمة `Character` تمثل حرفًا مرئيًا (باستثناء المسافة).\n\n- Returns: قيمة `Int` تمثل رمز ASCII للحرف المعطى.\n\n### مثال:\nasciiCode(of: \"A\") // يعيد 65\nasciiCode(of: \"a\") // يعيد 97",
      "sw": "Inarejesha msimbo wa ASCII wa herufi iliyotolewa.\n\nKazi hii inachukua herufi moja (isipokuwa nafasi) kama ingizo na inarejesha msimbo wake wa ASCII kama nambari kamili. Thamani ya ASCII imedhamiriwa kulingana na uwakilishi wa herufi kwenye jedwali la ASCII.\n\n- Parameter character: Thamani ya `Character` inayowakilisha herufi inayoonekana (isipokuwa nafasi).\n\n- Returns: `Int` inayowakilisha msimbo wa ASCII wa herufi iliyotolewa.\n\n### Mfano:\nasciiCode(of: \"A\") // Inarejesha 65\nasciiCode(of: \"a\") // Inarejesha 97",
      "tr": "Verilen karakterin ASCII kodunu döndürür.\n\nBu fonksiyon, giriş olarak tek bir karakter (boşluk hariç) alır ve bu karakterin ASCII kodunu bir tamsayı olarak döndürür. ASCII değeri, karakterin ASCII tablosundaki temsilini temel alarak belirlenir.\n\n- Parametre karakter: Görünür bir karakteri (boşluk hariç) temsil eden bir `Character` değeri.\n\n- Döndürür: Verilen karakterin ASCII kodunu temsil eden bir `Int`.\n\n### Örnek:\nasciiCode(of: \"A\") // 65 döndürür\nasciiCode(of: \"a\") // 97 döndürür",
      "vi": "Trả về mã ASCII của ký tự được cung cấp.\n\nHàm này nhận một ký tự duy nhất (không bao gồm khoảng trắng) làm đầu vào và trả về mã ASCII của nó dưới dạng số nguyên. Giá trị ASCII được xác định dựa trên biểu diễn của ký tự trong bảng mã ASCII.\n\n- Tham số character: Một giá trị `Character` đại diện cho một ký tự có thể nhìn thấy (không bao gồm khoảng trắng).\n\n- Trả về: Một `Int` đại diện cho mã ASCII của ký tự được cung cấp.\n\n### Ví dụ:\nasciiCode(of: \"A\") // Trả về 65\nasciiCode(of: \"a\") // Trả về 97"
    },
    "docstring_bertscore": {
      "es": "1",
      "arb": "0.9954332889096269",
      "sw": "0.9926367717750367",
      "tr": "0.9771386362947896",
      "vi": "0.9791442072520988"
    }
  },
  {
    "task_id": "Swift/43",
    "prompt": {
      "en": "func characterForAsciiCode(_ code: Int) -> Character? {\n    /**\n    Returns the character corresponding to the given ASCII code.\n\n    This function takes an integer representing an ASCII code and returns the corresponding character. The function ensures that the input code is within the range of printable ASCII characters (greater than 0 and less than 128).\n\n    - Parameter code: An `Int` value representing the ASCII code.\n\n    - Returns: A `Character?` representing the corresponding character if the code is within the printable ASCII range; otherwise, `nil`.\n\n    ### Example:\n    characterForAsciiCode(65) // Returns \"A\"\n    characterForAsciiCode(97) // Returns \"a\"\n    */",
      "es": "func characterForAsciiCode(_ code: Int) -> Character? {\n    /**\n    Devuelve el carácter correspondiente al código ASCII dado.\n\n    Esta función toma un entero que representa un código ASCII y devuelve el carácter correspondiente. La función asegura que el código de entrada esté dentro del rango de caracteres ASCII imprimibles (mayor que 0 y menor que 128).\n\n    - Parámetro code: Un valor `Int` que representa el código ASCII.\n\n    - Devuelve: Un `Character?` que representa el carácter correspondiente si el código está dentro del rango ASCII imprimible; de lo contrario, `nil`.\n\n    ### Ejemplo:\n    characterForAsciiCode(65) // Devuelve \"A\"\n    characterForAsciiCode(97) // Devuelve \"a\"\n    */",
      "arb": "func characterForAsciiCode(_ code: Int) -> Character? {\n    /**\n    تُرجع الحرف المقابل لرمز ASCII المعطى.\n\n    تأخذ هذه الدالة عددًا صحيحًا يمثل رمز ASCII وتُرجع الحرف المقابل. تضمن الدالة أن يكون رمز الإدخال ضمن نطاق أحرف ASCII القابلة للطباعة (أكبر من 0 وأقل من 128).\n\n    - Parameter code: قيمة `Int` تمثل رمز ASCII.\n\n    - Returns: `Character?` يمثل الحرف المقابل إذا كان الرمز ضمن نطاق ASCII القابل للطباعة؛ وإلا، `nil`.\n\n    ### مثال:\n    characterForAsciiCode(65) // Returns \"A\"\n    characterForAsciiCode(97) // Returns \"a\"\n    */",
      "sw": "func characterForAsciiCode(_ code: Int) -> Character? {\n    /**\n    Inarudisha herufi inayolingana na msimbo wa ASCII uliotolewa.\n\n    Kazi hii inachukua nambari nzima inayowakilisha msimbo wa ASCII na inarudisha herufi inayolingana. Kazi hii inahakikisha kuwa msimbo wa ingizo uko ndani ya safu ya herufi za ASCII zinazoweza kuchapishwa (zaidi ya 0 na chini ya 128).\n\n    - Parameter code: Thamani ya `Int` inayowakilisha msimbo wa ASCII.\n\n    - Returns: `Character?` inayowakilisha herufi inayolingana ikiwa msimbo uko ndani ya safu ya herufi za ASCII zinazoweza kuchapishwa; vinginevyo, `nil`.\n\n    ### Mfano:\n    characterForAsciiCode(65) // Inarudisha \"A\"\n    characterForAsciiCode(97) // Inarudisha \"a\"\n    */",
      "tr": "func characterForAsciiCode(_ code: Int) -> Character? {\n    /**\n    Verilen ASCII koduna karşılık gelen karakteri döndürür.\n\n    Bu fonksiyon, bir ASCII kodunu temsil eden bir tam sayı alır ve karşılık gelen karakteri döndürür. Fonksiyon, giriş kodunun yazdırılabilir ASCII karakterleri aralığında (0'dan büyük ve 128'den küçük) olduğundan emin olur.\n\n    - Parametre code: ASCII kodunu temsil eden bir `Int` değeri.\n\n    - Dönüş: Eğer kod yazdırılabilir ASCII aralığındaysa karşılık gelen karakteri temsil eden bir `Character?`; aksi takdirde `nil`.\n\n    ### Örnek:\n    characterForAsciiCode(65) // \"A\" döndürür\n    characterForAsciiCode(97) // \"a\" döndürür\n    */",
      "vi": "func characterForAsciiCode(_ code: Int) -> Character? {\n    /**\n    Trả về ký tự tương ứng với mã ASCII được cung cấp.\n\n    Hàm này nhận một số nguyên đại diện cho mã ASCII và trả về ký tự tương ứng. Hàm đảm bảo rằng mã đầu vào nằm trong phạm vi các ký tự ASCII có thể in được (lớn hơn 0 và nhỏ hơn 128).\n\n    - Tham số code: Một giá trị `Int` đại diện cho mã ASCII.\n\n    - Trả về: Một `Character?` đại diện cho ký tự tương ứng nếu mã nằm trong phạm vi ASCII có thể in được; nếu không, trả về `nil`.\n\n    ### Ví dụ:\n    characterForAsciiCode(65) // Trả về \"A\"\n    characterForAsciiCode(97) // Trả về \"a\"\n    */"
    },
    "prompt_bertscore": {
      "es": "1",
      "arb": "0.9963664544397288",
      "sw": "0.9906923789750862",
      "tr": "0.9966109684387827",
      "vi": "0.9917234692830382"
    },
    "canonical_solution": "    guard code > 0 && code < 128 else { return nil }\n    return Character(UnicodeScalar(code)!)\n}",
    "instruction": {
      "en": "func characterForAsciiCode(_ code: Int) -> Character? {\n    guard code > 0 && code < 128 else { return nil }\n    return Character(UnicodeScalar(code)!)\n}\n\nProvide a concise natural language description (docstring) of the Swift code in English using at most 500 characters.",
      "es": "func characterForAsciiCode(_ code: Int) -> Character? {\n    guard code > 0 && code < 128 else { return nil }\n    return Character(UnicodeScalar(code)!)\n}\n\nProporcione una descripción concisa en lenguaje natural (docstring) del código Swift en español utilizando un máximo de 500 caracteres.",
      "arb": "func characterForAsciiCode(_ code: Int) -> Character? {\n    guard code > 0 && code < 128 else { return nil }\n    return Character(UnicodeScalar(code)!)\n}\n\nقدم وصفًا موجزًا بلغة طبيعية (docstring) لشيفرة Swift باللغة العربية الفصحى باستخدام ما لا يزيد عن 500 حرف.",
      "sw": "func characterForAsciiCode(_ code: Int) -> Character? {\n    guard code > 0 && code < 128 else { return nil }\n    return Character(UnicodeScalar(code)!)\n}\n\nToa maelezo mafupi ya lugha asilia (docstring) ya msimbo wa Swift kwa Kiswahili kwa kutumia herufi zisizozidi 500.",
      "tr": "func characterForAsciiCode(_ code: Int) -> Character? {\n    guard code > 0 && code < 128 else { return nil }\n    return Character(UnicodeScalar(code)!)\n}\n\nSwift kodunun işlevini açıklayan kısa bir doğal dil açıklaması (docstring) sağlayın. Açıklama Türkçe olmalı ve en fazla 500 karakter içermelidir.",
      "vi": "func characterForAsciiCode(_ code: Int) -> Character? {\n    guard code > 0 && code < 128 else { return nil }\n    return Character(UnicodeScalar(code)!)\n}\n\nCung cấp mô tả ngắn gọn bằng ngôn ngữ tự nhiên (docstring) cho mã Swift bằng tiếng Việt, sử dụng tối đa 500 ký tự."
    },
    "instruction_bertscore": {
      "es": "0.9676013985493994",
      "arb": "0.9081934351464368",
      "sw": "0.942496901951162",
      "tr": "0.8726445558526228",
      "vi": "0.9054771646857847"
    },
    "level": "",
    "test": "func testCharacterForAsciiCode() {\n    assert(characterForAsciiCode(65) == \"A\", \"Test Case 1 Failed\")\n    assert(characterForAsciiCode(97) == \"a\", \"Test Case 2 Failed\")\n    assert(characterForAsciiCode(48) == \"0\", \"Test Case 3 Failed\")\n    assert(characterForAsciiCode(35) == \"#\", \"Test Case 4 Failed\")\n    assert(characterForAsciiCode(90) == \"Z\", \"Test Case 5 Failed\")\n    assert(characterForAsciiCode(122) == \"z\", \"Test Case 6 Failed\")\n}\n\ntestCharacterForAsciiCode()",
    "entry_point": "characterForAsciiCode",
    "signature": "func characterForAsciiCode(_ code: Int) -> Character? {",
    "docstring": {
      "en": "\nReturns the character corresponding to the given ASCII code.\n\nThis function takes an integer representing an ASCII code and returns the corresponding character. The function ensures that the input code is within the range of printable ASCII characters (greater than 0 and less than 128).\n\n- Parameter code: An `Int` value representing the ASCII code.\n\n- Returns: A `Character?` representing the corresponding character if the code is within the printable ASCII range; otherwise, `nil`.\n\n### Example:\ncharacterForAsciiCode(65) // Returns \"A\"\ncharacterForAsciiCode(97) // Returns \"a\"\n",
      "es": "Devuelve el carácter correspondiente al código ASCII dado.\n\nEsta función toma un entero que representa un código ASCII y devuelve el carácter correspondiente. La función asegura que el código de entrada esté dentro del rango de caracteres ASCII imprimibles (mayor que 0 y menor que 128).\n\n- Parámetro code: Un valor `Int` que representa el código ASCII.\n\n- Devuelve: Un `Character?` que representa el carácter correspondiente si el código está dentro del rango ASCII imprimible; de lo contrario, `nil`.\n\n### Ejemplo:\ncharacterForAsciiCode(65) // Devuelve \"A\"\ncharacterForAsciiCode(97) // Devuelve \"a\"",
      "arb": "يعيد الحرف المقابل لرمز ASCII المعطى.\n\nتأخذ هذه الدالة عددًا صحيحًا يمثل رمز ASCII وتعيد الحرف المقابل. تضمن الدالة أن يكون رمز الإدخال ضمن نطاق أحرف ASCII القابلة للطباعة (أكبر من 0 وأقل من 128).\n\n- Parameter code: قيمة `Int` تمثل رمز ASCII.\n\n- Returns: قيمة `Character?` تمثل الحرف المقابل إذا كان الرمز ضمن نطاق ASCII القابل للطباعة؛ وإلا، `nil`.\n\n### مثال:\ncharacterForAsciiCode(65) // يعيد \"A\"\ncharacterForAsciiCode(97) // يعيد \"a\"",
      "sw": "Inarejesha herufi inayolingana na msimbo wa ASCII uliotolewa.\n\nKazi hii inachukua nambari nzima inayowakilisha msimbo wa ASCII na inarejesha herufi inayolingana. Kazi hii inahakikisha kwamba msimbo wa ingizo uko ndani ya safu ya herufi za ASCII zinazoweza kuchapishwa (zaidi ya 0 na chini ya 128).\n\n- Kigezo code: Thamani ya `Int` inayowakilisha msimbo wa ASCII.\n\n- Inarejesha: `Character?` inayowakilisha herufi inayolingana ikiwa msimbo uko ndani ya safu ya herufi za ASCII zinazoweza kuchapishwa; vinginevyo, `nil`.\n\n### Mfano:\ncharacterForAsciiCode(65) // Inarejesha \"A\"\ncharacterForAsciiCode(97) // Inarejesha \"a\"",
      "tr": "Verilen ASCII koduna karşılık gelen karakteri döndürür.\n\nBu fonksiyon, bir ASCII kodunu temsil eden bir tam sayı alır ve karşılık gelen karakteri döndürür. Fonksiyon, giriş kodunun yazdırılabilir ASCII karakterleri aralığında (0'dan büyük ve 128'den küçük) olmasını sağlar.\n\n- Parametre kodu: ASCII kodunu temsil eden bir `Int` değeri.\n\n- Döner: Kod yazdırılabilir ASCII aralığındaysa karşılık gelen karakteri temsil eden bir `Character?`; aksi takdirde, `nil`.\n\n### Örnek:\ncharacterForAsciiCode(65) // \"A\" döndürür\ncharacterForAsciiCode(97) // \"a\" döndürür",
      "vi": "Trả về ký tự tương ứng với mã ASCII được cung cấp.\n\nHàm này nhận một số nguyên đại diện cho mã ASCII và trả về ký tự tương ứng. Hàm đảm bảo rằng mã đầu vào nằm trong phạm vi các ký tự ASCII có thể in được (lớn hơn 0 và nhỏ hơn 128).\n\n- Tham số code: Một giá trị `Int` đại diện cho mã ASCII.\n\n- Trả về: Một `Character?` đại diện cho ký tự tương ứng nếu mã nằm trong phạm vi ASCII có thể in được; nếu không, trả về `nil`.\n\n### Ví dụ:\ncharacterForAsciiCode(65) // Trả về \"A\"\ncharacterForAsciiCode(97) // Trả về \"a\""
    },
    "docstring_bertscore": {
      "es": "0.9958331318666501",
      "arb": "0.9954291176716251",
      "sw": "0.992011880596301",
      "tr": "0.9961469678686853",
      "vi": "0.9883902528588918"
    }
  },
  {
    "task_id": "Swift/44",
    "prompt": {
      "en": "func convertIntToBoolToInt(_ value: Int) -> Int {\n    /**\n    Converts an integer to a boolean and then back to an integer, and returns the resulting integer value.\n\n    - Parameters:\n        - value: An integer value to be converted to boolean and back to integer.\n\n    - Returns: An integer value after conversion. The return value is 1 if the original integer was non-zero; otherwise, it is 0.\n\n    ### Example:\n    - `convertIntToBoolToInt(5)` returns `1`, because any non-zero integer converts to `true`, which then converts back to `1`.\n    - `convertIntToBoolToInt(0)` returns `0`, because `0` converts to `false`, which then converts back to `0`.\n    - `convertIntToBoolToInt(-10)` returns `1`, because any non-zero integer, including negative numbers, converts to `true`, which then converts back to `1`.\n    */",
      "es": "func convertIntToBoolToInt(_ value: Int) -> Int {\n    /**\n    Convierte un entero a un booleano y luego de nuevo a un entero, y devuelve el valor entero resultante.\n\n    - Parámetros:\n        - value: Un valor entero que se convertirá a booleano y luego de nuevo a entero.\n\n    - Devuelve: Un valor entero después de la conversión. El valor de retorno es 1 si el entero original era distinto de cero; de lo contrario, es 0.\n\n    ### Ejemplo:\n    - `convertIntToBoolToInt(5)` devuelve `1`, porque cualquier entero distinto de cero se convierte en `true`, que luego se convierte de nuevo en `1`.\n    - `convertIntToBoolToInt(0)` devuelve `0`, porque `0` se convierte en `false`, que luego se convierte de nuevo en `0`.\n    - `convertIntToBoolToInt(-10)` devuelve `1`, porque cualquier entero distinto de cero, incluidos los números negativos, se convierte en `true`, que luego se convierte de nuevo en `1`.\n    */",
      "arb": "func convertIntToBoolToInt(_ value: Int) -> Int {\n    /**\n    يحول عددًا صحيحًا إلى قيمة منطقية ثم يعيده إلى عدد صحيح، ويعيد قيمة العدد الصحيح الناتجة.\n\n    - Parameters:\n        - value: قيمة عدد صحيح ليتم تحويلها إلى قيمة منطقية ثم إلى عدد صحيح.\n\n    - Returns: قيمة عدد صحيح بعد التحويل. تكون القيمة المرجعة 1 إذا كان العدد الصحيح الأصلي غير صفري؛ وإلا، تكون 0.\n\n    ### Example:\n    - `convertIntToBoolToInt(5)` returns `1`, لأن أي عدد صحيح غير صفري يتحول إلى `true`، والذي يتحول بعد ذلك إلى `1`.\n    - `convertIntToBoolToInt(0)` returns `0`, لأن `0` يتحول إلى `false`، والذي يتحول بعد ذلك إلى `0`.\n    - `convertIntToBoolToInt(-10)` returns `1`, لأن أي عدد صحيح غير صفري، بما في ذلك الأعداد السالبة، يتحول إلى `true`، والذي يتحول بعد ذلك إلى `1`.\n    */",
      "sw": "func convertIntToBoolToInt(_ value: Int) -> Int {\n    /**\n    Inabadilisha nambari nzima kuwa boolean na kisha kurudi kwa nambari nzima, na inarudisha thamani ya nambari nzima inayopatikana.\n\n    - Vigezo:\n        - value: Thamani ya nambari nzima inayopaswa kubadilishwa kuwa boolean na kurudi kwa nambari nzima.\n\n    - Inarudisha: Thamani ya nambari nzima baada ya kubadilishwa. Thamani inayorudishwa ni 1 ikiwa nambari ya awali haikuwa sifuri; vinginevyo, ni 0.\n\n    ### Mfano:\n    - `convertIntToBoolToInt(5)` inarudisha `1`, kwa sababu nambari yoyote isiyo sifuri inabadilishwa kuwa `true`, ambayo kisha inabadilishwa kurudi `1`.\n    - `convertIntToBoolToInt(0)` inarudisha `0`, kwa sababu `0` inabadilishwa kuwa `false`, ambayo kisha inabadilishwa kurudi `0`.\n    - `convertIntToBoolToInt(-10)` inarudisha `1`, kwa sababu nambari yoyote isiyo sifuri, ikijumuisha nambari hasi, inabadilishwa kuwa `true`, ambayo kisha inabadilishwa kurudi `1`.\n    */",
      "tr": "func convertIntToBoolToInt(_ value: Int) -> Int {\n    /**\n    Bir tam sayıyı boolean'a ve ardından tekrar tam sayıya dönüştürür ve ortaya çıkan tam sayı değerini döndürür.\n\n    - Parametreler:\n        - value: Boolean'a ve ardından tam sayıya dönüştürülecek bir tam sayı değeri.\n\n    - Döndürür: Dönüştürme sonrası bir tam sayı değeri. Orijinal tam sayı sıfır değilse dönüş değeri 1'dir; aksi takdirde 0'dır.\n\n    ### Örnek:\n    - `convertIntToBoolToInt(5)` `1` döndürür, çünkü sıfır olmayan herhangi bir tam sayı `true`'ya dönüşür, bu da ardından `1`e dönüşür.\n    - `convertIntToBoolToInt(0)` `0` döndürür, çünkü `0` `false`'a dönüşür, bu da ardından `0`a dönüşür.\n    - `convertIntToBoolToInt(-10)` `1` döndürür, çünkü negatif sayılar dahil sıfır olmayan herhangi bir tam sayı `true`'ya dönüşür, bu da ardından `1`e dönüşür.\n    */",
      "vi": "func convertIntToBoolToInt(_ value: Int) -> Int {\n    /**\n    Chuyển đổi một số nguyên thành một giá trị boolean và sau đó chuyển đổi lại thành số nguyên, và trả về giá trị số nguyên kết quả.\n\n    - Tham số:\n        - value: Một giá trị số nguyên để chuyển đổi thành boolean và sau đó chuyển đổi lại thành số nguyên.\n\n    - Trả về: Một giá trị số nguyên sau khi chuyển đổi. Giá trị trả về là 1 nếu số nguyên ban đầu khác không; nếu không, nó là 0.\n\n    ### Ví dụ:\n    - `convertIntToBoolToInt(5)` trả về `1`, vì bất kỳ số nguyên nào khác không chuyển thành `true`, sau đó chuyển đổi lại thành `1`.\n    - `convertIntToBoolToInt(0)` trả về `0`, vì `0` chuyển thành `false`, sau đó chuyển đổi lại thành `0`.\n    - `convertIntToBoolToInt(-10)` trả về `1`, vì bất kỳ số nguyên nào khác không, bao gồm cả số âm, chuyển thành `true`, sau đó chuyển đổi lại thành `1`.\n    */"
    },
    "prompt_bertscore": {
      "es": "0.9916239554621398",
      "arb": "0.980045393290854",
      "sw": "0.970855560081894",
      "tr": "0.9781280142227243",
      "vi": "0.97716942400385"
    },
    "canonical_solution": "    let boolValue = value != 0 // Convert to boolean: true if value is not 0, false otherwise.\n    return boolValue ? 1 : 0   // Convert boolean back to integer: 1 if true, 0 if false.\n}",
    "instruction": {
      "en": "func convertIntToBoolToInt(_ value: Int) -> Int {\n    let boolValue = value != 0 // Convert to boolean: true if value is not 0, false otherwise.\n    return boolValue ? 1 : 0   // Convert boolean back to integer: 1 if true, 0 if false.\n}\n\nProvide a concise natural language description (docstring) of the Swift code in English using at most 500 characters.",
      "es": "func convertIntToBoolToInt(_ value: Int) -> Int {\n    let boolValue = value != 0 // Convert to boolean: true if value is not 0, false otherwise.\n    return boolValue ? 1 : 0   // Convert boolean back to integer: 1 if true, 0 if false.\n}\n\nProporcione una descripción concisa en lenguaje natural (docstring) del código Swift en español utilizando como máximo 500 caracteres.",
      "arb": "func convertIntToBoolToInt(_ value: Int) -> Int {\n    let boolValue = value != 0 // Convert to boolean: true if value is not 0, false otherwise.\n    return boolValue ? 1 : 0   // Convert boolean back to integer: 1 if true, 0 if false.\n}\n\nقدم وصفًا موجزًا بلغة طبيعية (docstring) لكود Swift باللغة العربية الفصحى باستخدام 500 حرف كحد أقصى.",
      "sw": "func convertIntToBoolToInt(_ value: Int) -> Int {\n    let boolValue = value != 0 // Convert to boolean: true if value is not 0, false otherwise.\n    return boolValue ? 1 : 0   // Convert boolean back to integer: 1 if true, 0 if false.\n}\n\nToa maelezo mafupi ya lugha asilia (docstring) ya msimbo wa Swift kwa Kiswahili kwa kutumia herufi zisizozidi 500.",
      "tr": "func convertIntToBoolToInt(_ value: Int) -> Int {\n    let boolValue = value != 0 // Convert to boolean: true if value is not 0, false otherwise.\n    return boolValue ? 1 : 0   // Convert boolean back to integer: 1 if true, 0 if false.\n}\n\nSwift kodunun işlevini açıklayan, en fazla 500 karakter uzunluğunda, özlü bir doğal dil açıklaması (docstring) sağlayın.",
      "vi": "func convertIntToBoolToInt(_ value: Int) -> Int {\n    let boolValue = value != 0 // Convert to boolean: true if value is not 0, false otherwise.\n    return boolValue ? 1 : 0   // Convert boolean back to integer: 1 if true, 0 if false.\n}\n\nCung cấp mô tả ngắn gọn bằng ngôn ngữ tự nhiên (docstring) cho mã Swift bằng tiếng Việt, không quá 500 ký tự."
    },
    "instruction_bertscore": {
      "es": "0.9676013985493994",
      "arb": "0.9144786962935237",
      "sw": "0.942496901951162",
      "tr": "0.8726078092321313",
      "vi": "0.8824596775010808"
    },
    "level": "",
    "test": "func testConvertIntToBoolToInt() {\n    assert(convertIntToBoolToInt(5) == 1, \"Conversion of 5 should return 1.\")\n    assert(convertIntToBoolToInt(0) == 0, \"Conversion of 0 should return 0.\")\n    assert(convertIntToBoolToInt(-10) == 1, \"Conversion of -10 should return 1.\")\n    assert(convertIntToBoolToInt(1) == 1, \"Conversion of 1 should return 1.\")\n    assert(convertIntToBoolToInt(-1) == 1, \"Conversion of -1 should return 1.\")\n    assert(convertIntToBoolToInt(100) == 1, \"Conversion of 100 should return 1.\")\n    assert(convertIntToBoolToInt(-100) == 1, \"Conversion of -100 should return 1.\")\n}\n\n// Call the test function to verify the functionality\ntestConvertIntToBoolToInt()",
    "entry_point": "convertIntToBoolToInt",
    "signature": "func convertIntToBoolToInt(_ value: Int) -> Int {",
    "docstring": {
      "en": "\nConverts an integer to a boolean and then back to an integer, and returns the resulting integer value.\n\n- Parameters:\n- value: An integer value to be converted to boolean and back to integer.\n\n- Returns: An integer value after conversion. The return value is 1 if the original integer was non-zero; otherwise, it is 0.\n\n### Example:\n- `convertIntToBoolToInt(5)` returns `1`, because any non-zero integer converts to `true`, which then converts back to `1`.\n- `convertIntToBoolToInt(0)` returns `0`, because `0` converts to `false`, which then converts back to `0`.\n- `convertIntToBoolToInt(-10)` returns `1`, because any non-zero integer, including negative numbers, converts to `true`, which then converts back to `1`.\n",
      "es": "Convierte un entero a un booleano y luego de nuevo a un entero, y devuelve el valor entero resultante.\n\n- Parámetros:\n- value: Un valor entero que se convertirá a booleano y luego de nuevo a entero.\n\n- Devuelve: Un valor entero después de la conversión. El valor devuelto es 1 si el entero original era distinto de cero; de lo contrario, es 0.\n\n### Ejemplo:\n- `convertIntToBoolToInt(5)` devuelve `1`, porque cualquier entero distinto de cero se convierte en `true`, que luego se convierte de nuevo en `1`.\n- `convertIntToBoolToInt(0)` devuelve `0`, porque `0` se convierte en `false`, que luego se convierte de nuevo en `0`.\n- `convertIntToBoolToInt(-10)` devuelve `1`, porque cualquier entero distinto de cero, incluidos los números negativos, se convierte en `true`, que luego se convierte de nuevo en `1`.",
      "arb": "يقوم بتحويل عدد صحيح إلى قيمة منطقية ثم يعيده إلى عدد صحيح، ويعيد القيمة الصحيحة الناتجة.\n\n- المعاملات:\n- value: قيمة عدد صحيح ليتم تحويلها إلى قيمة منطقية ثم إلى عدد صحيح.\n\n- يعيد: قيمة عدد صحيح بعد التحويل. تكون القيمة المعادة 1 إذا كان العدد الصحيح الأصلي غير صفري؛ وإلا، تكون 0.\n\n### مثال:\n- `convertIntToBoolToInt(5)` يعيد `1`، لأن أي عدد صحيح غير صفري يتحول إلى `true`، والذي يتحول بعد ذلك إلى `1`.\n- `convertIntToBoolToInt(0)` يعيد `0`، لأن `0` يتحول إلى `false`، والذي يتحول بعد ذلك إلى `0`.\n- `convertIntToBoolToInt(-10)` يعيد `1`، لأن أي عدد صحيح غير صفري، بما في ذلك الأرقام السالبة، يتحول إلى `true`، والذي يتحول بعد ذلك إلى `1`.",
      "sw": "Inabadilisha nambari kamili kuwa boolean na kisha kurudi kwenye nambari kamili, na inarejesha thamani ya nambari kamili inayotokana.\n\n- Vigezo:\n- value: Thamani ya nambari kamili inayobadilishwa kuwa boolean na kurudi kwenye nambari kamili.\n\n- Inarejesha: Thamani ya nambari kamili baada ya ubadilishaji. Thamani inayorejeshwa ni 1 ikiwa nambari kamili ya awali haikuwa sifuri; vinginevyo, ni 0.\n\n### Mfano:\n- `convertIntToBoolToInt(5)` inarejesha `1`, kwa sababu nambari yoyote kamili isiyo sifuri hubadilishwa kuwa `true`, ambayo kisha hubadilishwa tena kuwa `1`.\n- `convertIntToBoolToInt(0)` inarejesha `0`, kwa sababu `0` hubadilishwa kuwa `false`, ambayo kisha hubadilishwa tena kuwa `0`.\n- `convertIntToBoolToInt(-10)` inarejesha `1`, kwa sababu nambari yoyote kamili isiyo sifuri, ikijumuisha nambari hasi, hubadilishwa kuwa `true`, ambayo kisha hubadilishwa tena kuwa `1`.",
      "tr": "Bir tamsayıyı booleana ve ardından tekrar bir tamsayıya dönüştürür ve ortaya çıkan tamsayı değerini döndürür.\n\n- Parametreler:\n- value: Boolean'a ve ardından tamsayıya dönüştürülecek bir tamsayı değeri.\n\n- Döndürür: Dönüşümden sonra bir tamsayı değeri. Orijinal tamsayı sıfır değilse dönüş değeri 1'dir; aksi takdirde 0'dır.\n\n### Örnek:\n- `convertIntToBoolToInt(5)` `1` döndürür, çünkü sıfır olmayan herhangi bir tamsayı `true`'ya dönüşür, bu da ardından `1`e dönüşür.\n- `convertIntToBoolToInt(0)` `0` döndürür, çünkü `0` `false`'a dönüşür, bu da ardından `0`'a dönüşür.\n- `convertIntToBoolToInt(-10)` `1` döndürür, çünkü negatif sayılar da dahil olmak üzere sıfır olmayan herhangi bir tamsayı `true`'ya dönüşür, bu da ardından `1`e dönüşür.",
      "vi": "Chuyển đổi một số nguyên thành một giá trị boolean và sau đó trở lại thành một số nguyên, và trả về giá trị số nguyên kết quả.\n\n- Tham số:\n- value: Một giá trị số nguyên cần được chuyển đổi thành boolean và sau đó trở lại thành số nguyên.\n\n- Trả về: Một giá trị số nguyên sau khi chuyển đổi. Giá trị trả về là 1 nếu số nguyên ban đầu khác không; ngược lại, nó là 0.\n\n### Ví dụ:\n- `convertIntToBoolToInt(5)` trả về `1`, vì bất kỳ số nguyên nào khác không chuyển đổi thành `true`, sau đó chuyển đổi trở lại thành `1`.\n- `convertIntToBoolToInt(0)` trả về `0`, vì `0` chuyển đổi thành `false`, sau đó chuyển đổi trở lại thành `0`.\n- `convertIntToBoolToInt(-10)` trả về `1`, vì bất kỳ số nguyên nào khác không, bao gồm cả số âm, chuyển đổi thành `true`, sau đó chuyển đổi trở lại thành `1`."
    },
    "docstring_bertscore": {
      "es": "0.974756064874276",
      "arb": "0.9753398395641376",
      "sw": "0.9901584605108644",
      "tr": "0.9775023285224644",
      "vi": "0.9817109090358316"
    }
  },
  {
    "task_id": "Swift/45",
    "prompt": {
      "en": "func reverseThreeDigitNumber(_ number: Int) -> Int {\n    /**\n    Reverses a three-digit number and returns the result.\n\n    - Parameters:\n        - number: A three-digit integer to be reversed.\n\n    - Returns: The reversed integer. If the input number is not a three-digit integer, the function returns -1 to indicate an error.\n\n    ### Examples:\n    - `reverseThreeDigitNumber(123)` returns `321`.\n    - `reverseThreeDigitNumber(456)` returns `654`.\n    - `reverseThreeDigitNumber(789)` returns `987`.\n    - `reverseThreeDigitNumber(100)` returns `1`, as leading zeros are not represented in integers.\n    - `reverseThreeDigitNumber(905)` returns `509`.\n\n    Note: The function assumes the input is always a three-digit number.\n    */",
      "es": "func reverseThreeDigitNumber(_ number: Int) -> Int {\n    /**\n    Invierte un número de tres dígitos y devuelve el resultado.\n\n    - Parámetros:\n        - number: Un entero de tres dígitos que se va a invertir.\n\n    - Devuelve: El entero invertido. Si el número de entrada no es un entero de tres dígitos, la función devuelve -1 para indicar un error.\n\n    ### Ejemplos:\n    - `reverseThreeDigitNumber(123)` devuelve `321`.\n    - `reverseThreeDigitNumber(456)` devuelve `654`.\n    - `reverseThreeDigitNumber(789)` devuelve `987`.\n    - `reverseThreeDigitNumber(100)` devuelve `1`, ya que los ceros a la izquierda no se representan en enteros.\n    - `reverseThreeDigitNumber(905)` devuelve `509`.\n\n    Nota: La función asume que la entrada es siempre un número de tres dígitos.\n    */",
      "arb": "func reverseThreeDigitNumber(_ number: Int) -> Int {\n    /**\n    يعكس رقمًا مكونًا من ثلاثة أرقام ويعيد النتيجة.\n\n    - Parameters:\n        - number: عدد صحيح مكون من ثلاثة أرقام ليتم عكسه.\n\n    - Returns: العدد الصحيح المعكوس. إذا لم يكن الرقم المدخل عددًا صحيحًا مكونًا من ثلاثة أرقام، تعيد الدالة -1 للإشارة إلى خطأ.\n\n    ### أمثلة:\n    - `reverseThreeDigitNumber(123)` returns `321`.\n    - `reverseThreeDigitNumber(456)` returns `654`.\n    - `reverseThreeDigitNumber(789)` returns `987`.\n    - `reverseThreeDigitNumber(100)` returns `1`, حيث لا يتم تمثيل الأصفار البادئة في الأعداد الصحيحة.\n    - `reverseThreeDigitNumber(905)` returns `509`.\n\n    ملاحظة: تفترض الدالة أن المدخل هو دائمًا رقم مكون من ثلاثة أرقام.\n    */",
      "sw": "func reverseThreeDigitNumber(_ number: Int) -> Int {\n    /**\n    Inarudisha namba ya tarakimu tatu na kurudisha matokeo.\n\n    - Vigezo:\n        - number: Nambari ya tarakimu tatu inayopaswa kugeuzwa.\n\n    - Inarudisha: Nambari iliyogeuzwa. Ikiwa nambari ya ingizo si nambari ya tarakimu tatu, kazi inarudisha -1 kuashiria kosa.\n\n    ### Mifano:\n    - `reverseThreeDigitNumber(123)` inarudisha `321`.\n    - `reverseThreeDigitNumber(456)` inarudisha `654`.\n    - `reverseThreeDigitNumber(789)` inarudisha `987`.\n    - `reverseThreeDigitNumber(100)` inarudisha `1`, kwani sifuri za mwanzo hazionyeshwi katika nambari nzima.\n    - `reverseThreeDigitNumber(905)` inarudisha `509`.\n\n    Kumbuka: Kazi inadhani ingizo daima ni nambari ya tarakimu tatu.\n    */",
      "tr": "func reverseThreeDigitNumber(_ number: Int) -> Int {\n    /**\n    Üç basamaklı bir sayıyı ters çevirir ve sonucu döndürür.\n\n    - Parametreler:\n        - number: Ters çevrilecek üç basamaklı bir tamsayı.\n\n    - Döndürür: Ters çevrilmiş tamsayı. Eğer giriş sayısı üç basamaklı bir tamsayı değilse, fonksiyon bir hatayı belirtmek için -1 döndürür.\n\n    ### Örnekler:\n    - `reverseThreeDigitNumber(123)` `321` döndürür.\n    - `reverseThreeDigitNumber(456)` `654` döndürür.\n    - `reverseThreeDigitNumber(789)` `987` döndürür.\n    - `reverseThreeDigitNumber(100)` `1` döndürür, çünkü baştaki sıfırlar tamsayılarda temsil edilmez.\n    - `reverseThreeDigitNumber(905)` `509` döndürür.\n\n    Not: Fonksiyon, girişin her zaman üç basamaklı bir sayı olduğunu varsayar.\n    */",
      "vi": "func reverseThreeDigitNumber(_ number: Int) -> Int {\n    /**\n    Đảo ngược một số có ba chữ số và trả về kết quả.\n\n    - Tham số:\n        - number: Một số nguyên có ba chữ số cần được đảo ngược.\n\n    - Trả về: Số nguyên đã được đảo ngược. Nếu số đầu vào không phải là số nguyên có ba chữ số, hàm trả về -1 để chỉ ra lỗi.\n\n    ### Ví dụ:\n    - `reverseThreeDigitNumber(123)` trả về `321`.\n    - `reverseThreeDigitNumber(456)` trả về `654`.\n    - `reverseThreeDigitNumber(789)` trả về `987`.\n    - `reverseThreeDigitNumber(100)` trả về `1`, vì các số 0 đứng đầu không được biểu diễn trong số nguyên.\n    - `reverseThreeDigitNumber(905)` trả về `509`.\n\n    Lưu ý: Hàm giả định rằng đầu vào luôn là một số có ba chữ số.\n    */"
    },
    "prompt_bertscore": {
      "es": "0.9929734502708908",
      "arb": "0.9960186526425368",
      "sw": "0.9844091041318096",
      "tr": "0.9917937844379247",
      "vi": "0.9886643627847199"
    },
    "canonical_solution": "    guard number >= 100 && number <= 999 else {\n        return -1 // Error code for invalid input\n    }\n    let hundreds = number / 100\n    let tens = (number / 10) % 10\n    let ones = number % 10\n    return ones * 100 + tens * 10 + hundreds\n}",
    "instruction": {
      "en": "func reverseThreeDigitNumber(_ number: Int) -> Int {\n    guard number >= 100 && number <= 999 else {\n        return -1 // Error code for invalid input\n    }\n    let hundreds = number / 100\n    let tens = (number / 10) % 10\n    let ones = number % 10\n    return ones * 100 + tens * 10 + hundreds\n}\n\nProvide a concise natural language description (docstring) of the Swift code in English using at most 500 characters.",
      "es": "func reverseThreeDigitNumber(_ number: Int) -> Int {\n    guard number >= 100 && number <= 999 else {\n        return -1 // Error code for invalid input\n    }\n    let hundreds = number / 100\n    let tens = (number / 10) % 10\n    let ones = number % 10\n    return ones * 100 + tens * 10 + hundreds\n}\n\nProporcione una descripción concisa en lenguaje natural (docstring) del código Swift en español utilizando como máximo 500 caracteres.",
      "arb": "func reverseThreeDigitNumber(_ number: Int) -> Int {\n    guard number >= 100 && number <= 999 else {\n        return -1 // Error code for invalid input\n    }\n    let hundreds = number / 100\n    let tens = (number / 10) % 10\n    let ones = number % 10\n    return ones * 100 + tens * 10 + hundreds\n}\n\nقدم وصفًا موجزًا بلغة طبيعية (docstring) لكود Swift باللغة العربية الفصحى باستخدام 500 حرف كحد أقصى.",
      "sw": "func reverseThreeDigitNumber(_ number: Int) -> Int {\n    guard number >= 100 && number <= 999 else {\n        return -1 // Error code for invalid input\n    }\n    let hundreds = number / 100\n    let tens = (number / 10) % 10\n    let ones = number % 10\n    return ones * 100 + tens * 10 + hundreds\n}\n\nToa maelezo mafupi ya lugha ya asili (docstring) ya msimbo wa Swift kwa Kiswahili kwa kutumia herufi zisizozidi 500.",
      "tr": "func reverseThreeDigitNumber(_ number: Int) -> Int {\n    guard number >= 100 && number <= 999 else {\n        return -1 // Error code for invalid input\n    }\n    let hundreds = number / 100\n    let tens = (number / 10) % 10\n    let ones = number % 10\n    return ones * 100 + tens * 10 + hundreds\n}\n\nSwift kodunun işlevselliğini açıklayan, en fazla 500 karakter uzunluğunda özlü bir doğal dil açıklaması (docstring) sağlayın.",
      "vi": "func reverseThreeDigitNumber(_ number: Int) -> Int {\n    guard number >= 100 && number <= 999 else {\n        return -1 // Error code for invalid input\n    }\n    let hundreds = number / 100\n    let tens = (number / 10) % 10\n    let ones = number % 10\n    return ones * 100 + tens * 10 + hundreds\n}\n\nCung cấp mô tả ngắn gọn bằng ngôn ngữ tự nhiên (docstring) cho mã Swift bằng tiếng Việt, sử dụng tối đa 500 ký tự."
    },
    "instruction_bertscore": {
      "es": "0.9676013985493994",
      "arb": "0.9144786962935237",
      "sw": "0.9148419912604365",
      "tr": "0.8731472893470221",
      "vi": "0.9054771646857847"
    },
    "level": "",
    "test": "func testReverseThreeDigitNumber() {\n    assert(reverseThreeDigitNumber(123) == 321, \"Reverse of 123 should be 321.\")\n    assert(reverseThreeDigitNumber(456) == 654, \"Reverse of 456 should be 654.\")\n    assert(reverseThreeDigitNumber(789) == 987, \"Reverse of 789 should be 987.\")\n    assert(reverseThreeDigitNumber(100) == 1, \"Reverse of 100 should be 1.\")\n    assert(reverseThreeDigitNumber(905) == 509, \"Reverse of 905 should be 509.\")\n    assert(reverseThreeDigitNumber(999) == 999, \"Reverse of 999 should be 999.\")\n    assert(reverseThreeDigitNumber(210) == 12, \"Reverse of 210 should be 12.\")\n}\n\n// Call the test function to verify the functionality\ntestReverseThreeDigitNumber()",
    "entry_point": "reverseThreeDigitNumber",
    "signature": "func reverseThreeDigitNumber(_ number: Int) -> Int {",
    "docstring": {
      "en": "\nReverses a three-digit number and returns the result.\n\n- Parameters:\n- number: A three-digit integer to be reversed.\n\n- Returns: The reversed integer. If the input number is not a three-digit integer, the function returns -1 to indicate an error.\n\n### Examples:\n- `reverseThreeDigitNumber(123)` returns `321`.\n- `reverseThreeDigitNumber(456)` returns `654`.\n- `reverseThreeDigitNumber(789)` returns `987`.\n- `reverseThreeDigitNumber(100)` returns `1`, as leading zeros are not represented in integers.\n- `reverseThreeDigitNumber(905)` returns `509`.\n\nNote: The function assumes the input is always a three-digit number.\n",
      "es": "Invierte un número de tres dígitos y devuelve el resultado.\n\n- Parámetros:\n- number: Un número entero de tres dígitos que se va a invertir.\n\n- Devuelve: El número entero invertido. Si el número de entrada no es un número entero de tres dígitos, la función devuelve -1 para indicar un error.\n\n### Ejemplos:\n- `reverseThreeDigitNumber(123)` devuelve `321`.\n- `reverseThreeDigitNumber(456)` devuelve `654`.\n- `reverseThreeDigitNumber(789)` devuelve `987`.\n- `reverseThreeDigitNumber(100)` devuelve `1`, ya que los ceros a la izquierda no se representan en enteros.\n- `reverseThreeDigitNumber(905)` devuelve `509`.\n\nNota: La función asume que la entrada es siempre un número de tres dígitos.",
      "arb": "يعكس رقمًا مكونًا من ثلاثة أرقام ويعيد النتيجة.\n\n- المعلمات:\n- number: عدد صحيح مكون من ثلاثة أرقام ليتم عكسه.\n\n- يعيد: العدد الصحيح المعكوس. إذا لم يكن الرقم المدخل عددًا صحيحًا مكونًا من ثلاثة أرقام، فإن الدالة تعيد -1 للإشارة إلى خطأ.\n\n### أمثلة:\n- `reverseThreeDigitNumber(123)` يعيد `321`.\n- `reverseThreeDigitNumber(456)` يعيد `654`.\n- `reverseThreeDigitNumber(789)` يعيد `987`.\n- `reverseThreeDigitNumber(100)` يعيد `1`، حيث لا يتم تمثيل الأصفار البادئة في الأعداد الصحيحة.\n- `reverseThreeDigitNumber(905)` يعيد `509`.\n\nملاحظة: تفترض الدالة أن المدخل دائمًا عدد مكون من ثلاثة أرقام.",
      "sw": "Inageuza namba ya tarakimu tatu na kurudisha matokeo.\n\n- Vigezo:\n- number: Namba ya tarakimu tatu inayotakiwa kugeuzwa.\n\n- Inarudisha: Namba iliyogeuzwa. Ikiwa namba iliyoingizwa si namba ya tarakimu tatu, kazi inarudisha -1 kuonyesha kosa.\n\n### Mifano:\n- `reverseThreeDigitNumber(123)` inarudisha `321`.\n- `reverseThreeDigitNumber(456)` inarudisha `654`.\n- `reverseThreeDigitNumber(789)` inarudisha `987`.\n- `reverseThreeDigitNumber(100)` inarudisha `1`, kwa kuwa sifuri zinazoongoza hazionyeshwi kwenye namba nzima.\n- `reverseThreeDigitNumber(905)` inarudisha `509`.\n\nKumbuka: Kazi inadhani kwamba ingizo daima ni namba ya tarakimu tatu.",
      "tr": "Üç basamaklı bir sayıyı ters çevirir ve sonucu döndürür.\n\n- Parametreler:\n- number: Ters çevrilecek üç basamaklı bir tamsayı.\n\n- Döndürür: Ters çevrilmiş tamsayı. Eğer giriş sayısı üç basamaklı bir tamsayı değilse, fonksiyon bir hatayı belirtmek için -1 döndürür.\n\n### Örnekler:\n- `reverseThreeDigitNumber(123)` `321` döndürür.\n- `reverseThreeDigitNumber(456)` `654` döndürür.\n- `reverseThreeDigitNumber(789)` `987` döndürür.\n- `reverseThreeDigitNumber(100)` `1` döndürür, çünkü önde gelen sıfırlar tamsayılarda temsil edilmez.\n- `reverseThreeDigitNumber(905)` `509` döndürür.\n\nNot: Fonksiyon, girişin her zaman üç basamaklı bir sayı olduğunu varsayar.",
      "vi": "Đảo ngược một số có ba chữ số và trả về kết quả.\n\n- Tham số:\n- number: Một số nguyên có ba chữ số cần được đảo ngược.\n\n- Trả về: Số nguyên đã được đảo ngược. Nếu số đầu vào không phải là số nguyên có ba chữ số, hàm trả về -1 để chỉ ra lỗi.\n\n### Ví dụ:\n- `reverseThreeDigitNumber(123)` trả về `321`.\n- `reverseThreeDigitNumber(456)` trả về `654`.\n- `reverseThreeDigitNumber(789)` trả về `987`.\n- `reverseThreeDigitNumber(100)` trả về `1`, vì các số không có chữ số 0 đứng đầu trong số nguyên.\n- `reverseThreeDigitNumber(905)` trả về `509`.\n\nLưu ý: Hàm giả định rằng đầu vào luôn là một số có ba chữ số."
    },
    "docstring_bertscore": {
      "es": "0.9870099703410804",
      "arb": "0.9873053337176793",
      "sw": "0.9801081604912611",
      "tr": "0.9981741895375273",
      "vi": "0.9767002590438455"
    }
  },
  {
    "task_id": "Swift/46",
    "prompt": {
      "en": "func arithmeticSequenceLastTerm(_ a1: Int, _ a2: Int, _ n: Int) -> Int {\n    /**\n    Calculates the nth term of an arithmetic sequence given its first two terms.\n\n    - Parameters:\n        - a1: The first term of the arithmetic sequence.\n        - a2: The second term of the arithmetic sequence.\n        - n: The position of the term in the sequence to be found (1-based index).\n\n    - Returns: The nth term of the arithmetic sequence.\n\n    ### Example:\n    - `arithmeticSequenceLastTerm(1, 4, 100)` calculates the 100th term of an arithmetic sequence starting with 1, 4.\n    - `arithmeticSequenceLastTerm(5, 9, 20)` calculates the 20th term of an arithmetic sequence starting with 5, 9.\n    - `arithmeticSequenceLastTerm(-3, 1, 10)` calculates the 10th term of an arithmetic sequence starting with -3, 1.\n\n    Note: The function assumes the input values for `a1`, `a2`, and `n` follow the constraints -100 <= a1,a2 <= 100, 0 < n <= 1000.\n    */",
      "es": "func arithmeticSequenceLastTerm(_ a1: Int, _ a2: Int, _ n: Int) -> Int {\n    /**\n    Calcula el enésimo término de una secuencia aritmética dados sus dos primeros términos.\n\n    - Parámetros:\n        - a1: El primer término de la secuencia aritmética.\n        - a2: El segundo término de la secuencia aritmética.\n        - n: La posición del término en la secuencia que se desea encontrar (índice basado en 1).\n\n    - Retorna: El enésimo término de la secuencia aritmética.\n\n    ### Ejemplo:\n    - `arithmeticSequenceLastTerm(1, 4, 100)` calcula el término 100 de una secuencia aritmética comenzando con 1, 4.\n    - `arithmeticSequenceLastTerm(5, 9, 20)` calcula el término 20 de una secuencia aritmética comenzando con 5, 9.\n    - `arithmeticSequenceLastTerm(-3, 1, 10)` calcula el término 10 de una secuencia aritmética comenzando con -3, 1.\n\n    Nota: La función asume que los valores de entrada para `a1`, `a2`, y `n` siguen las restricciones -100 <= a1,a2 <= 100, 0 < n <= 1000.\n    */",
      "arb": "func arithmeticSequenceLastTerm(_ a1: Int, _ a2: Int, _ n: Int) -> Int {\n    /**\n    يحسب الحد النوني لمتتالية حسابية معطاة أول حدين لها.\n\n    - المعاملات:\n        - a1: الحد الأول للمتتالية الحسابية.\n        - a2: الحد الثاني للمتتالية الحسابية.\n        - n: موضع الحد في المتتالية المطلوب إيجاده (مؤشر يبدأ من 1).\n\n    - يعيد: الحد النوني للمتتالية الحسابية.\n\n    ### مثال:\n    - `arithmeticSequenceLastTerm(1, 4, 100)` يحسب الحد المائة لمتتالية حسابية تبدأ بـ 1، 4.\n    - `arithmeticSequenceLastTerm(5, 9, 20)` يحسب الحد العشرين لمتتالية حسابية تبدأ بـ 5، 9.\n    - `arithmeticSequenceLastTerm(-3, 1, 10)` يحسب الحد العاشر لمتتالية حسابية تبدأ بـ -3، 1.\n\n    ملاحظة: تفترض الدالة أن القيم المدخلة لـ `a1`، `a2`، و `n` تتبع القيود -100 <= a1,a2 <= 100، 0 < n <= 1000.\n    */",
      "sw": "func arithmeticSequenceLastTerm(_ a1: Int, _ a2: Int, _ n: Int) -> Int {\n    /**\n    Inahesabu neno la n la mlolongo wa hesabu ukizingatia maneno yake mawili ya kwanza.\n\n    - Vigezo:\n        - a1: Neno la kwanza la mlolongo wa hesabu.\n        - a2: Neno la pili la mlolongo wa hesabu.\n        - n: Nafasi ya neno katika mlolongo inayotafutwa (kiwango cha kuanzia 1).\n\n    - Inarudisha: Neno la n la mlolongo wa hesabu.\n\n    ### Mfano:\n    - `arithmeticSequenceLastTerm(1, 4, 100)` inahesabu neno la 100 la mlolongo wa hesabu unaoanza na 1, 4.\n    - `arithmeticSequenceLastTerm(5, 9, 20)` inahesabu neno la 20 la mlolongo wa hesabu unaoanza na 5, 9.\n    - `arithmeticSequenceLastTerm(-3, 1, 10)` inahesabu neno la 10 la mlolongo wa hesabu unaoanza na -3, 1.\n\n    Kumbuka: Kazi inadhani thamani za ingizo kwa `a1`, `a2`, na `n` zinafuata vikwazo -100 <= a1,a2 <= 100, 0 < n <= 1000.\n    */",
      "tr": "func arithmeticSequenceLastTerm(_ a1: Int, _ a2: Int, _ n: Int) -> Int {\n    /**\n    İlk iki terimi verilen bir aritmetik dizinin n'inci terimini hesaplar.\n\n    - Parametreler:\n        - a1: Aritmetik dizinin ilk terimi.\n        - a2: Aritmetik dizinin ikinci terimi.\n        - n: Dizide bulunacak terimin pozisyonu (1 tabanlı indeks).\n\n    - Döndürür: Aritmetik dizinin n'inci terimi.\n\n    ### Örnek:\n    - `arithmeticSequenceLastTerm(1, 4, 100)` 1, 4 ile başlayan bir aritmetik dizinin 100. terimini hesaplar.\n    - `arithmeticSequenceLastTerm(5, 9, 20)` 5, 9 ile başlayan bir aritmetik dizinin 20. terimini hesaplar.\n    - `arithmeticSequenceLastTerm(-3, 1, 10)` -3, 1 ile başlayan bir aritmetik dizinin 10. terimini hesaplar.\n\n    Not: Fonksiyon, `a1`, `a2` ve `n` için verilen giriş değerlerinin -100 <= a1,a2 <= 100, 0 < n <= 1000 kısıtlamalarına uyduğunu varsayar.\n    */",
      "vi": "func arithmeticSequenceLastTerm(_ a1: Int, _ a2: Int, _ n: Int) -> Int {\n    /**\n    Tính toán số hạng thứ n của một dãy số cộng khi biết hai số hạng đầu tiên.\n\n    - Tham số:\n        - a1: Số hạng đầu tiên của dãy số cộng.\n        - a2: Số hạng thứ hai của dãy số cộng.\n        - n: Vị trí của số hạng cần tìm trong dãy số (chỉ số bắt đầu từ 1).\n\n    - Trả về: Số hạng thứ n của dãy số cộng.\n\n    ### Ví dụ:\n    - `arithmeticSequenceLastTerm(1, 4, 100)` tính toán số hạng thứ 100 của một dãy số cộng bắt đầu với 1, 4.\n    - `arithmeticSequenceLastTerm(5, 9, 20)` tính toán số hạng thứ 20 của một dãy số cộng bắt đầu với 5, 9.\n    - `arithmeticSequenceLastTerm(-3, 1, 10)` tính toán số hạng thứ 10 của một dãy số cộng bắt đầu với -3, 1.\n\n    Lưu ý: Hàm giả định rằng các giá trị đầu vào cho `a1`, `a2`, và `n` tuân theo các ràng buộc -100 <= a1,a2 <= 100, 0 < n <= 1000.\n    */"
    },
    "prompt_bertscore": {
      "es": "0.9947821785205945",
      "arb": "0.99832058012835",
      "sw": "0.9775982669965043",
      "tr": "0.986017017066287",
      "vi": "0.9844899466968907"
    },
    "canonical_solution": "    let difference = a2 - a1 // Calculate the common difference of the sequence.\n    return a1 + (n - 1) * difference // Use the formula for the nth term of an arithmetic sequence.\n}",
    "instruction": {
      "en": "func arithmeticSequenceLastTerm(_ a1: Int, _ a2: Int, _ n: Int) -> Int {\n    let difference = a2 - a1 // Calculate the common difference of the sequence.\n    return a1 + (n - 1) * difference // Use the formula for the nth term of an arithmetic sequence.\n}\n\nProvide a concise natural language description (docstring) of the Swift code in English using at most 500 characters.",
      "es": "func arithmeticSequenceLastTerm(_ a1: Int, _ a2: Int, _ n: Int) -> Int {\n    let difference = a2 - a1 // Calculate the common difference of the sequence.\n    return a1 + (n - 1) * difference // Use the formula for the nth term of an arithmetic sequence.\n}\n\nProporcione una descripción concisa en lenguaje natural (docstring) del código Swift en español utilizando un máximo de 500 caracteres.",
      "arb": "func arithmeticSequenceLastTerm(_ a1: Int, _ a2: Int, _ n: Int) -> Int {\n    let difference = a2 - a1 // Calculate the common difference of the sequence.\n    return a1 + (n - 1) * difference // Use the formula for the nth term of an arithmetic sequence.\n}\n\nقدم وصفًا موجزًا بلغة طبيعية (docstring) لكود Swift باللغة العربية الفصحى باستخدام 500 حرف كحد أقصى.",
      "sw": "func arithmeticSequenceLastTerm(_ a1: Int, _ a2: Int, _ n: Int) -> Int {\n    let difference = a2 - a1 // Calculate the common difference of the sequence.\n    return a1 + (n - 1) * difference // Use the formula for the nth term of an arithmetic sequence.\n}\n\nToa maelezo mafupi ya lugha asilia (docstring) ya msimbo wa Swift kwa Kiswahili kwa kutumia herufi zisizozidi 500.",
      "tr": "func arithmeticSequenceLastTerm(_ a1: Int, _ a2: Int, _ n: Int) -> Int {\n    let difference = a2 - a1 // Calculate the common difference of the sequence.\n    return a1 + (n - 1) * difference // Use the formula for the nth term of an arithmetic sequence.\n}\n\nSwift kodunun işlevini açıklayan kısa bir doğal dil açıklaması (docstring) sağlayın. Açıklama, Türkçe olarak en fazla 500 karakter içermelidir.",
      "vi": "func arithmeticSequenceLastTerm(_ a1: Int, _ a2: Int, _ n: Int) -> Int {\n    let difference = a2 - a1 // Calculate the common difference of the sequence.\n    return a1 + (n - 1) * difference // Use the formula for the nth term of an arithmetic sequence.\n}\n\nCung cấp mô tả ngắn gọn bằng ngôn ngữ tự nhiên (docstring) cho mã Swift bằng tiếng Việt, sử dụng tối đa 500 ký tự."
    },
    "instruction_bertscore": {
      "es": "0.9676013985493994",
      "arb": "0.9144786962935237",
      "sw": "0.933792521393451",
      "tr": "0.8678813993154062",
      "vi": "0.9054771646857847"
    },
    "level": "",
    "test": "func testArithmeticSequenceLastTerm() {\n    assert(arithmeticSequenceLastTerm(1, 4, 100) == 298, \"The 100th term should be 298.\")\n    assert(arithmeticSequenceLastTerm(5, 9, 20) == 81, \"The 20th term should be 77.\")\n    assert(arithmeticSequenceLastTerm(-3, 1, 10) == 33, \"The 10th term should be 33.\")\n    assert(arithmeticSequenceLastTerm(0, 2, 50) == 98, \"The 50th term should be 98.\")\n    assert(arithmeticSequenceLastTerm(-100, -97, 1000) == 2897, \"The 1000th term should be 2897.\")\n    assert(arithmeticSequenceLastTerm(2, 5, 3) == 8, \"The 3rd term should be 8.\")\n}\n\n// Call the test function to verify the functionality\ntestArithmeticSequenceLastTerm()",
    "entry_point": "arithmeticSequenceLastTerm",
    "signature": "func arithmeticSequenceLastTerm(_ a1: Int, _ a2: Int, _ n: Int) -> Int {",
    "docstring": {
      "en": "\nCalculates the nth term of an arithmetic sequence given its first two terms.\n\n- Parameters:\n- a1: The first term of the arithmetic sequence.\n- a2: The second term of the arithmetic sequence.\n- n: The position of the term in the sequence to be found (1-based index).\n\n- Returns: The nth term of the arithmetic sequence.\n\n### Example:\n- `arithmeticSequenceLastTerm(1, 4, 100)` calculates the 100th term of an arithmetic sequence starting with 1, 4.\n- `arithmeticSequenceLastTerm(5, 9, 20)` calculates the 20th term of an arithmetic sequence starting with 5, 9.\n- `arithmeticSequenceLastTerm(-3, 1, 10)` calculates the 10th term of an arithmetic sequence starting with -3, 1.\n\nNote: The function assumes the input values for `a1`, `a2`, and `n` follow the constraints -100 <= a1,a2 <= 100, 0 < n <= 1000.\n",
      "es": "Calcula el enésimo término de una secuencia aritmética dados sus dos primeros términos.\n\n- Parámetros:\n- a1: El primer término de la secuencia aritmética.\n- a2: El segundo término de la secuencia aritmética.\n- n: La posición del término en la secuencia que se desea encontrar (índice basado en 1).\n\n- Retorna: El enésimo término de la secuencia aritmética.\n\n### Ejemplo:\n- `arithmeticSequenceLastTerm(1, 4, 100)` calcula el término 100 de una secuencia aritmética que comienza con 1, 4.\n- `arithmeticSequenceLastTerm(5, 9, 20)` calcula el término 20 de una secuencia aritmética que comienza con 5, 9.\n- `arithmeticSequenceLastTerm(-3, 1, 10)` calcula el término 10 de una secuencia aritmética que comienza con -3, 1.\n\nNota: La función asume que los valores de entrada para `a1`, `a2` y `n` siguen las restricciones -100 <= a1,a2 <= 100, 0 < n <= 1000.",
      "arb": "يحسب الحد n من متتالية حسابية معطاة أول حدين لها.\n\n- المعاملات:\n- a1: الحد الأول من المتتالية الحسابية.\n- a2: الحد الثاني من المتتالية الحسابية.\n- n: موضع الحد في المتتالية المطلوب إيجاده (مؤشر يبدأ من 1).\n\n- يعيد: الحد n من المتتالية الحسابية.\n\n### مثال:\n- `arithmeticSequenceLastTerm(1, 4, 100)` يحسب الحد 100 من متتالية حسابية تبدأ بـ 1، 4.\n- `arithmeticSequenceLastTerm(5, 9, 20)` يحسب الحد 20 من متتالية حسابية تبدأ بـ 5، 9.\n- `arithmeticSequenceLastTerm(-3, 1, 10)` يحسب الحد 10 من متتالية حسابية تبدأ بـ -3، 1.\n\nملاحظة: تفترض الدالة أن القيم المدخلة لـ `a1`، `a2`، و `n` تتبع القيود -100 <= a1,a2 <= 100، 0 < n <= 1000.",
      "sw": "Huhesabu neno la nth la mfuatano wa hesabu ukizingatia maneno yake mawili ya kwanza.\n\n- Vigezo:\n- a1: Neno la kwanza la mfuatano wa hesabu.\n- a2: Neno la pili la mfuatano wa hesabu.\n- n: Nafasi ya neno katika mfuatano inayopaswa kupatikana (kiashiria cha kuanzia 1).\n\n- Inarudisha: Neno la nth la mfuatano wa hesabu.\n\n### Mfano:\n- `arithmeticSequenceLastTerm(1, 4, 100)` huhesabu neno la 100 la mfuatano wa hesabu unaoanza na 1, 4.\n- `arithmeticSequenceLastTerm(5, 9, 20)` huhesabu neno la 20 la mfuatano wa hesabu unaoanza na 5, 9.\n- `arithmeticSequenceLastTerm(-3, 1, 10)` huhesabu neno la 10 la mfuatano wa hesabu unaoanza na -3, 1.\n\nKumbuka: Kazi inadhani thamani za ingizo za `a1`, `a2`, na `n` zinafuata vikwazo -100 <= a1,a2 <= 100, 0 < n <= 1000.",
      "tr": "Bir aritmetik dizinin ilk iki terimi verildiğinde n'inci terimini hesaplar.\n\n- Parametreler:\n- a1: Aritmetik dizinin ilk terimi.\n- a2: Aritmetik dizinin ikinci terimi.\n- n: Dizide bulunacak terimin konumu (1 tabanlı indeks).\n\n- Döndürür: Aritmetik dizinin n'inci terimi.\n\n### Örnek:\n- `arithmeticSequenceLastTerm(1, 4, 100)` 1, 4 ile başlayan bir aritmetik dizinin 100. terimini hesaplar.\n- `arithmeticSequenceLastTerm(5, 9, 20)` 5, 9 ile başlayan bir aritmetik dizinin 20. terimini hesaplar.\n- `arithmeticSequenceLastTerm(-3, 1, 10)` -3, 1 ile başlayan bir aritmetik dizinin 10. terimini hesaplar.\n\nNot: Fonksiyon, `a1`, `a2` ve `n` için giriş değerlerinin -100 <= a1,a2 <= 100, 0 < n <= 1000 kısıtlamalarına uyduğunu varsayar.",
      "vi": "Tính toán số hạng thứ n của một dãy số học cho trước hai số hạng đầu tiên của nó.\n\n- Tham số:\n- a1: Số hạng đầu tiên của dãy số học.\n- a2: Số hạng thứ hai của dãy số học.\n- n: Vị trí của số hạng trong dãy cần tìm (chỉ số bắt đầu từ 1).\n\n- Trả về: Số hạng thứ n của dãy số học.\n\n### Ví dụ:\n- `arithmeticSequenceLastTerm(1, 4, 100)` tính toán số hạng thứ 100 của một dãy số học bắt đầu với 1, 4.\n- `arithmeticSequenceLastTerm(5, 9, 20)` tính toán số hạng thứ 20 của một dãy số học bắt đầu với 5, 9.\n- `arithmeticSequenceLastTerm(-3, 1, 10)` tính toán số hạng thứ 10 của một dãy số học bắt đầu với -3, 1.\n\nLưu ý: Hàm giả định các giá trị đầu vào cho `a1`, `a2`, và `n` tuân theo các ràng buộc -100 <= a1,a2 <= 100, 0 < n <= 1000."
    },
    "docstring_bertscore": {
      "es": "0.9871200115721737",
      "arb": "0.9895407200258459",
      "sw": "0.9980705044786271",
      "tr": "0.9817677173248076",
      "vi": "0.9861318254265251"
    }
  },
  {
    "task_id": "Swift/47",
    "prompt": {
      "en": "func multiply(_ a: Int, _ b: Int) -> Int {\n    /**\n    Calculates the product of two positive integers.\n\n    - Parameters:\n        - a: The first positive integer.\n        - b: The second positive integer.\n        - Both `a` and `b` should be in the range of 1 to 50,000.\n\n    - Returns: The product of `a` and `b` as an integer.\n\n    ### Example:\n    - `multiply(3, 4)` returns `12`.\n    - `multiply(10, 5)` returns `50`.\n    - `multiply(36, 18)` returns `648`.\n\n    Note: The function handles multiplication within the specified range, ensuring no overflow for values up to 50,000.\n    */",
      "es": "func multiply(_ a: Int, _ b: Int) -> Int {\n    /**\n    Calcula el producto de dos enteros positivos.\n\n    - Parámetros:\n        - a: El primer entero positivo.\n        - b: El segundo entero positivo.\n        - Tanto `a` como `b` deben estar en el rango de 1 a 50,000.\n\n    - Retorna: El producto de `a` y `b` como un entero.\n\n    ### Ejemplo:\n    - `multiply(3, 4)` retorna `12`.\n    - `multiply(10, 5)` retorna `50`.\n    - `multiply(36, 18)` retorna `648`.\n\n    Nota: La función maneja la multiplicación dentro del rango especificado, asegurando que no haya desbordamiento para valores de hasta 50,000.\n    */",
      "arb": "func multiply(_ a: Int, _ b: Int) -> Int {\n    /**\n    يحسب حاصل ضرب عددين صحيحين موجبين.\n\n    - Parameters:\n        - a: العدد الصحيح الموجب الأول.\n        - b: العدد الصحيح الموجب الثاني.\n        - يجب أن يكون كلا من `a` و `b` في النطاق من 1 إلى 50,000.\n\n    - Returns: حاصل ضرب `a` و `b` كعدد صحيح.\n\n    ### Example:\n    - `multiply(3, 4)` returns `12`.\n    - `multiply(10, 5)` returns `50`.\n    - `multiply(36, 18)` returns `648`.\n\n    ملاحظة: تتعامل الدالة مع الضرب ضمن النطاق المحدد، مما يضمن عدم حدوث تجاوز للقيم حتى 50,000.\n    */",
      "sw": "func multiply(_ a: Int, _ b: Int) -> Int {\n    /**\n    Inahesabu bidhaa ya nambari mbili nzima chanya.\n\n    - Vigezo:\n        - a: Nambari ya kwanza nzima chanya.\n        - b: Nambari ya pili nzima chanya.\n        - Zote `a` na `b` zinapaswa kuwa katika kiwango cha 1 hadi 50,000.\n\n    - Inarudisha: Bidhaa ya `a` na `b` kama nambari nzima.\n\n    ### Mfano:\n    - `multiply(3, 4)` inarudisha `12`.\n    - `multiply(10, 5)` inarudisha `50`.\n    - `multiply(36, 18)` inarudisha `648`.\n\n    Kumbuka: Kazi inashughulikia kuzidisha ndani ya kiwango kilichobainishwa, kuhakikisha hakuna kufurika kwa thamani hadi 50,000.\n    */",
      "tr": "func multiply(_ a: Int, _ b: Int) -> Int {\n    /**\n    İki pozitif tamsayının çarpımını hesaplar.\n\n    - Parametreler:\n        - a: İlk pozitif tamsayı.\n        - b: İkinci pozitif tamsayı.\n        - Hem `a` hem de `b`, 1 ile 50,000 arasında olmalıdır.\n\n    - Döndürür: `a` ve `b`'nin çarpımını bir tamsayı olarak döndürür.\n\n    ### Örnek:\n    - `multiply(3, 4)` `12` döndürür.\n    - `multiply(10, 5)` `50` döndürür.\n    - `multiply(36, 18)` `648` döndürür.\n\n    Not: Fonksiyon, belirtilen aralık içinde çarpmayı ele alır ve 50,000'e kadar olan değerler için taşma olmadığını garanti eder.\n    */",
      "vi": "func multiply(_ a: Int, _ b: Int) -> Int {\n    /**\n    Tính tích của hai số nguyên dương.\n\n    - Tham số:\n        - a: Số nguyên dương thứ nhất.\n        - b: Số nguyên dương thứ hai.\n        - Cả `a` và `b` nên nằm trong khoảng từ 1 đến 50,000.\n\n    - Trả về: Tích của `a` và `b` dưới dạng một số nguyên.\n\n    ### Ví dụ:\n    - `multiply(3, 4)` trả về `12`.\n    - `multiply(10, 5)` trả về `50`.\n    - `multiply(36, 18)` trả về `648`.\n\n    Lưu ý: Hàm xử lý phép nhân trong phạm vi được chỉ định, đảm bảo không tràn số cho các giá trị lên đến 50,000.\n    */"
    },
    "prompt_bertscore": {
      "es": "0.9973077638154532",
      "arb": "0.9942544175981848",
      "sw": "0.9949573705166673",
      "tr": "0.9836525210104476",
      "vi": "0.9951202474291159"
    },
    "canonical_solution": "    return a * b\n}",
    "instruction": {
      "en": "func multiply(_ a: Int, _ b: Int) -> Int {\n    return a * b\n}\n\nProvide a concise natural language description (docstring) of the Swift code in English using at most 500 characters.",
      "es": "func multiply(_ a: Int, _ b: Int) -> Int {\n    return a * b\n}\n\nProporciona una descripción concisa en lenguaje natural (docstring) del código Swift en español utilizando un máximo de 500 caracteres.",
      "arb": "func multiply(_ a: Int, _ b: Int) -> Int {\n    return a * b\n}\n\nقدم وصفًا موجزًا بلغة طبيعية (docstring) لشيفرة Swift باللغة العربية الفصحى باستخدام ما لا يزيد عن 500 حرف.",
      "sw": "func multiply(_ a: Int, _ b: Int) -> Int {\n    return a * b\n}\n\nToa maelezo mafupi ya lugha ya asili (docstring) ya msimbo wa Swift kwa Kiswahili kwa kutumia herufi zisizozidi 500.",
      "tr": "func multiply(_ a: Int, _ b: Int) -> Int {\n    return a * b\n}\n\nSwift kodunun işlevini açıklayan kısa bir doğal dil açıklaması (docstring) sağlayın. Açıklama, Türkçe olarak en fazla 500 karakter kullanılacak şekilde olmalıdır.",
      "vi": "func multiply(_ a: Int, _ b: Int) -> Int {\n    return a * b\n}\n\nCung cấp mô tả ngắn gọn bằng ngôn ngữ tự nhiên (docstring) cho mã Swift bằng tiếng Việt với tối đa 500 ký tự."
    },
    "instruction_bertscore": {
      "es": "0.9676013985493994",
      "arb": "0.9081934351464368",
      "sw": "0.9148419912604365",
      "tr": "0.8781058981791771",
      "vi": "0.8999953634299838"
    },
    "level": "",
    "test": "func testMultiply() {\n    assert(multiply(3, 4) == 12, \"Product of 3 and 4 should be 12.\")\n    assert(multiply(10, 5) == 50, \"Product of 10 and 5 should be 50.\")\n    assert(multiply(36, 18) == 648, \"Product of 36 and 18 should be 648.\")\n    assert(multiply(1, 50000) == 50000, \"Product of 1 and 50000 should be 50000.\")\n    assert(multiply(123, 456) == 56088, \"Product of 123 and 456 should be 56088.\")\n    assert(multiply(500, 100) == 50000, \"Product of 500 and 100 should be 50000.\")\n}\n\n// Call the test function to verify the functionality\ntestMultiply()",
    "entry_point": "multiply",
    "signature": "func multiply(_ a: Int, _ b: Int) -> Int {",
    "docstring": {
      "en": "\nCalculates the product of two positive integers.\n\n- Parameters:\n- a: The first positive integer.\n- b: The second positive integer.\n- Both `a` and `b` should be in the range of 1 to 50,000.\n\n- Returns: The product of `a` and `b` as an integer.\n\n### Example:\n- `multiply(3, 4)` returns `12`.\n- `multiply(10, 5)` returns `50`.\n- `multiply(36, 18)` returns `648`.\n\nNote: The function handles multiplication within the specified range, ensuring no overflow for values up to 50,000.\n",
      "es": "Calcula el producto de dos enteros positivos.\n\n- Parámetros:\n- a: El primer entero positivo.\n- b: El segundo entero positivo.\n- Tanto `a` como `b` deben estar en el rango de 1 a 50,000.\n\n- Retorna: El producto de `a` y `b` como un entero.\n\n### Ejemplo:\n- `multiply(3, 4)` retorna `12`.\n- `multiply(10, 5)` retorna `50`.\n- `multiply(36, 18)` retorna `648`.\n\nNota: La función maneja la multiplicación dentro del rango especificado, asegurando que no haya desbordamiento para valores de hasta 50,000.",
      "arb": "يحسب ناتج ضرب عددين صحيحين موجبين.\n\n- المعاملات:\n- a: العدد الصحيح الموجب الأول.\n- b: العدد الصحيح الموجب الثاني.\n- يجب أن يكون كلا من `a` و `b` في النطاق من 1 إلى 50,000.\n\n- يعيد: ناتج ضرب `a` و `b` كعدد صحيح.\n\n### مثال:\n- `multiply(3, 4)` يعيد `12`.\n- `multiply(10, 5)` يعيد `50`.\n- `multiply(36, 18)` يعيد `648`.\n\nملاحظة: تتعامل الدالة مع الضرب ضمن النطاق المحدد، مما يضمن عدم تجاوز القيم حتى 50,000.",
      "sw": "Inahesabu bidhaa ya nambari mbili kamili chanya.\n\n- Vigezo:\n- a: Nambari ya kwanza kamili chanya.\n- b: Nambari ya pili kamili chanya.\n- Zote `a` na `b` zinapaswa kuwa katika kiwango cha 1 hadi 50,000.\n\n- Inarejesha: Bidhaa ya `a` na `b` kama nambari kamili.\n\n### Mfano:\n- `multiply(3, 4)` inarejesha `12`.\n- `multiply(10, 5)` inarejesha `50`.\n- `multiply(36, 18)` inarejesha `648`.\n\nKumbuka: Kazi inashughulikia kuzidisha ndani ya kiwango kilichotajwa, kuhakikisha hakuna kupita kiasi kwa thamani hadi 50,000.",
      "tr": "İki pozitif tam sayının çarpımını hesaplar.\n\n- Parametreler:\n- a: İlk pozitif tam sayı.\n- b: İkinci pozitif tam sayı.\n- Hem `a` hem de `b` 1 ile 50.000 arasında olmalıdır.\n\n- Döndürür: `a` ve `b`'nin çarpımını bir tam sayı olarak döndürür.\n\n### Örnek:\n- `multiply(3, 4)` `12` döndürür.\n- `multiply(10, 5)` `50` döndürür.\n- `multiply(36, 18)` `648` döndürür.\n\nNot: Fonksiyon, belirtilen aralıkta çarpmayı ele alır ve 50.000'e kadar olan değerler için taşma olmamasını sağlar.",
      "vi": "Tính tích của hai số nguyên dương.\n\n- Tham số:\n- a: Số nguyên dương thứ nhất.\n- b: Số nguyên dương thứ hai.\n- Cả `a` và `b` nên nằm trong khoảng từ 1 đến 50,000.\n\n- Trả về: Tích của `a` và `b` dưới dạng số nguyên.\n\n### Ví dụ:\n- `multiply(3, 4)` trả về `12`.\n- `multiply(10, 5)` trả về `50`.\n- `multiply(36, 18)` trả về `648`.\n\nLưu ý: Hàm xử lý phép nhân trong phạm vi được chỉ định, đảm bảo không tràn số cho các giá trị lên đến 50,000."
    },
    "docstring_bertscore": {
      "es": "0.9921693944884616",
      "arb": "0.9809710108664766",
      "sw": "0.9954773848542167",
      "tr": "0.9822323137860483",
      "vi": "0.9943827328243333"
    }
  },
  {
    "task_id": "Swift/48",
    "prompt": {
      "en": "func powerOfTwo(_ n: Int) -> Int {\n    /**\n    Calculates the power of 2 for a given non-negative integer.\n\n    - Parameters:\n        - n: A non-negative integer for which the power of 2 is calculated. The value of `n` must be in the range 0 to 30, inclusive.\n\n    - Returns: The result of 2 raised to the power of `n`.\n\n    ### Example:\n    - `powerOfTwo(3)` returns `8`, as 2^3 = 8.\n    - `powerOfTwo(5)` returns `32`, as 2^5 = 32.\n    - `powerOfTwo(10)` returns `1024`, as 2^10 = 1024.\n\n    Note: The function is designed to handle inputs within the specified range without resulting in integer overflow.\n    */",
      "es": "func powerOfTwo(_ n: Int) -> Int {\n    /**\n    Calcula la potencia de 2 para un entero no negativo dado.\n\n    - Parámetros:\n        - n: Un entero no negativo para el cual se calcula la potencia de 2. El valor de `n` debe estar en el rango de 0 a 30, inclusive.\n\n    - Devuelve: El resultado de 2 elevado a la potencia de `n`.\n\n    ### Ejemplo:\n    - `powerOfTwo(3)` devuelve `8`, ya que 2^3 = 8.\n    - `powerOfTwo(5)` devuelve `32`, ya que 2^5 = 32.\n    - `powerOfTwo(10)` devuelve `1024`, ya que 2^10 = 1024.\n\n    Nota: La función está diseñada para manejar entradas dentro del rango especificado sin resultar en un desbordamiento de enteros.\n    */",
      "arb": "func powerOfTwo(_ n: Int) -> Int {\n    /**\n    يحسب قوة 2 لعدد صحيح غير سالب معين.\n\n    - المعلمات:\n        - n: عدد صحيح غير سالب يتم حساب قوة 2 له. يجب أن تكون قيمة `n` في النطاق من 0 إلى 30، بما في ذلك.\n\n    - يعيد: نتيجة 2 مرفوعة إلى قوة `n`.\n\n    ### مثال:\n    - `powerOfTwo(3)` يعيد `8`، حيث 2^3 = 8.\n    - `powerOfTwo(5)` يعيد `32`، حيث 2^5 = 32.\n    - `powerOfTwo(10)` يعيد `1024`، حيث 2^10 = 1024.\n\n    ملاحظة: تم تصميم الدالة للتعامل مع المدخلات ضمن النطاق المحدد دون أن يؤدي ذلك إلى تجاوز عدد صحيح.\n    */",
      "sw": "func powerOfTwo(_ n: Int) -> Int {\n    /**\n    Inahesabu nguvu ya 2 kwa nambari kamili isiyo na alama.\n\n    - Vigezo:\n        - n: Nambari kamili isiyo na alama ambayo nguvu ya 2 inahesabiwa. Thamani ya `n` lazima iwe katika safu ya 0 hadi 30, ikijumuisha.\n\n    - Inarudisha: Matokeo ya 2 iliyoinuliwa kwa nguvu ya `n`.\n\n    ### Mfano:\n    - `powerOfTwo(3)` inarudisha `8`, kama 2^3 = 8.\n    - `powerOfTwo(5)` inarudisha `32`, kama 2^5 = 32.\n    - `powerOfTwo(10)` inarudisha `1024`, kama 2^10 = 1024.\n\n    Kumbuka: Kazi imeundwa kushughulikia pembejeo ndani ya safu iliyobainishwa bila kusababisha kufurika kwa nambari kamili.\n    */",
      "tr": "func powerOfTwo(_ n: Int) -> Int {\n    /**\n    Belirtilen pozitif olmayan bir tamsayı için 2'nin kuvvetini hesaplar.\n\n    - Parametreler:\n        - n: 2'nin kuvvetinin hesaplandığı pozitif olmayan bir tamsayı. `n` değeri 0 ile 30 arasında, dahil olmak üzere olmalıdır.\n\n    - Döndürür: `n` kuvvetine yükseltilmiş 2'nin sonucu.\n\n    ### Örnek:\n    - `powerOfTwo(3)` `8` döndürür, çünkü 2^3 = 8.\n    - `powerOfTwo(5)` `32` döndürür, çünkü 2^5 = 32.\n    - `powerOfTwo(10)` `1024` döndürür, çünkü 2^10 = 1024.\n\n    Not: Fonksiyon, belirtilen aralıktaki girdileri tamsayı taşması olmadan işlemek için tasarlanmıştır.\n    */",
      "vi": "func powerOfTwo(_ n: Int) -> Int {\n    /**\n    Tính lũy thừa của 2 cho một số nguyên không âm đã cho.\n\n    - Tham số:\n        - n: Một số nguyên không âm mà lũy thừa của 2 được tính toán. Giá trị của `n` phải nằm trong khoảng từ 0 đến 30, bao gồm cả hai đầu mút.\n\n    - Trả về: Kết quả của 2 mũ `n`.\n\n    ### Ví dụ:\n    - `powerOfTwo(3)` trả về `8`, vì 2^3 = 8.\n    - `powerOfTwo(5)` trả về `32`, vì 2^5 = 32.\n    - `powerOfTwo(10)` trả về `1024`, vì 2^10 = 1024.\n\n    Lưu ý: Hàm này được thiết kế để xử lý các đầu vào trong phạm vi đã chỉ định mà không dẫn đến tràn số nguyên.\n    */"
    },
    "prompt_bertscore": {
      "es": "0.9890874454963243",
      "arb": "0.9875403134584435",
      "sw": "0.9708623135148492",
      "tr": "0.9695052707516187",
      "vi": "0.9834439591103611"
    },
    "canonical_solution": "    guard n >= 0 && n < 31 else {\n        return -1 // Error code for invalid input\n    }\n    return 1 << n // Left shift operation equivalent to calculating 2^n\n}",
    "instruction": {
      "en": "func powerOfTwo(_ n: Int) -> Int {\n    guard n >= 0 && n < 31 else {\n        return -1 // Error code for invalid input\n    }\n    return 1 << n // Left shift operation equivalent to calculating 2^n\n}\n\nProvide a concise natural language description (docstring) of the Swift code in English using at most 500 characters.",
      "es": "func powerOfTwo(_ n: Int) -> Int {\n    guard n >= 0 && n < 31 else {\n        return -1 // Error code for invalid input\n    }\n    return 1 << n // Left shift operation equivalent to calculating 2^n\n}\n\nProporcione una descripción concisa en lenguaje natural (docstring) del código Swift en español utilizando un máximo de 500 caracteres.",
      "arb": "func powerOfTwo(_ n: Int) -> Int {\n    guard n >= 0 && n < 31 else {\n        return -1 // Error code for invalid input\n    }\n    return 1 << n // Left shift operation equivalent to calculating 2^n\n}\n\nقدم وصفًا موجزًا بلغة طبيعية (docstring) لكود Swift باللغة العربية الفصحى باستخدام ما لا يزيد عن 500 حرف.",
      "sw": "func powerOfTwo(_ n: Int) -> Int {\n    guard n >= 0 && n < 31 else {\n        return -1 // Error code for invalid input\n    }\n    return 1 << n // Left shift operation equivalent to calculating 2^n\n}\n\nToa maelezo mafupi ya lugha asilia (docstring) ya msimbo wa Swift kwa Kiswahili kwa kutumia herufi zisizozidi 500.",
      "tr": "func powerOfTwo(_ n: Int) -> Int {\n    guard n >= 0 && n < 31 else {\n        return -1 // Error code for invalid input\n    }\n    return 1 << n // Left shift operation equivalent to calculating 2^n\n}\n\nSwift kodunun Türkçe olarak en fazla 500 karakter kullanarak doğal dilde kısa bir açıklamasını (docstring) sağlayın.",
      "vi": "func powerOfTwo(_ n: Int) -> Int {\n    guard n >= 0 && n < 31 else {\n        return -1 // Error code for invalid input\n    }\n    return 1 << n // Left shift operation equivalent to calculating 2^n\n}\n\nCung cấp mô tả ngắn gọn bằng ngôn ngữ tự nhiên (docstring) cho mã Swift bằng tiếng Việt, sử dụng tối đa 500 ký tự."
    },
    "instruction_bertscore": {
      "es": "0.9676013985493994",
      "arb": "0.8880608556158835",
      "sw": "0.942496901951162",
      "tr": "0.8932459030824184",
      "vi": "0.9054771646857847"
    },
    "level": "",
    "test": "func testPowerOfTwo() {\n    assert(powerOfTwo(3) == 8, \"2^3 should be 8.\")\n    assert(powerOfTwo(5) == 32, \"2^5 should be 32.\")\n    assert(powerOfTwo(10) == 1024, \"2^10 should be 1024.\")\n    assert(powerOfTwo(0) == 1, \"2^0 should be 1.\")\n    assert(powerOfTwo(15) == 32768, \"2^15 should be 32768.\")\n    assert(powerOfTwo(30) == 1073741824, \"2^30 should be 1073741824.\")\n}\n\n// Call the test function to verify the functionality\ntestPowerOfTwo()",
    "entry_point": "powerOfTwo",
    "signature": "func powerOfTwo(_ n: Int) -> Int {",
    "docstring": {
      "en": "\nCalculates the power of 2 for a given non-negative integer.\n\n- Parameters:\n- n: A non-negative integer for which the power of 2 is calculated. The value of `n` must be in the range 0 to 30, inclusive.\n\n- Returns: The result of 2 raised to the power of `n`.\n\n### Example:\n- `powerOfTwo(3)` returns `8`, as 2^3 = 8.\n- `powerOfTwo(5)` returns `32`, as 2^5 = 32.\n- `powerOfTwo(10)` returns `1024`, as 2^10 = 1024.\n\nNote: The function is designed to handle inputs within the specified range without resulting in integer overflow.\n",
      "es": "Calcula la potencia de 2 para un entero no negativo dado.\n\n- Parámetros:\n- n: Un entero no negativo para el cual se calcula la potencia de 2. El valor de `n` debe estar en el rango de 0 a 30, inclusive.\n\n- Retorna: El resultado de 2 elevado a la potencia de `n`.\n\n### Ejemplo:\n- `powerOfTwo(3)` retorna `8`, ya que 2^3 = 8.\n- `powerOfTwo(5)` retorna `32`, ya que 2^5 = 32.\n- `powerOfTwo(10)` retorna `1024`, ya que 2^10 = 1024.\n\nNota: La función está diseñada para manejar entradas dentro del rango especificado sin resultar en un desbordamiento de enteros.",
      "arb": "يحسب قوة 2 لعدد صحيح غير سالب معين.\n\n- المعاملات:\n- n: عدد صحيح غير سالب يتم حساب قوة 2 له. يجب أن تكون قيمة `n` في النطاق من 0 إلى 30، شاملًا.\n\n- يعيد: نتيجة 2 مرفوعة إلى قوة `n`.\n\n### مثال:\n- `powerOfTwo(3)` يعيد `8`، حيث 2^3 = 8.\n- `powerOfTwo(5)` يعيد `32`، حيث 2^5 = 32.\n- `powerOfTwo(10)` يعيد `1024`، حيث 2^10 = 1024.\n\nملاحظة: تم تصميم الدالة للتعامل مع المدخلات ضمن النطاق المحدد دون التسبب في تجاوز عدد صحيح.",
      "sw": "Hukokotoa nguvu ya 2 kwa nambari kamili isiyo hasi iliyotolewa.\n\n- Vigezo:\n- n: Nambari kamili isiyo hasi ambayo nguvu ya 2 inakokotolewa. Thamani ya `n` lazima iwe katika kiwango cha 0 hadi 30, ikijumuisha.\n\n- Inarejesha: Matokeo ya 2 iliyoinuliwa kwa nguvu ya `n`.\n\n### Mfano:\n- `powerOfTwo(3)` inarejesha `8`, kwani 2^3 = 8.\n- `powerOfTwo(5)` inarejesha `32`, kwani 2^5 = 32.\n- `powerOfTwo(10)` inarejesha `1024`, kwani 2^10 = 1024.\n\nKumbuka: Kazi hii imeundwa kushughulikia pembejeo ndani ya kiwango kilichobainishwa bila kusababisha kufurika kwa nambari kamili.",
      "tr": "Verilen pozitif olmayan bir tam sayı için 2'nin kuvvetini hesaplar.\n\n- Parametreler:\n- n: 2'nin kuvvetinin hesaplandığı pozitif olmayan bir tam sayı. `n` değeri 0 ile 30 arasında, dahil olmak üzere, olmalıdır.\n\n- Döndürülen: 2'nin `n` kuvveti olarak elde edilen sonuç.\n\n### Örnek:\n- `powerOfTwo(3)` `8` döndürür, çünkü 2^3 = 8.\n- `powerOfTwo(5)` `32` döndürür, çünkü 2^5 = 32.\n- `powerOfTwo(10)` `1024` döndürür, çünkü 2^10 = 1024.\n\nNot: Fonksiyon, belirtilen aralıktaki girdileri, tam sayı taşması olmadan işlemek üzere tasarlanmıştır.",
      "vi": "Tính lũy thừa của 2 cho một số nguyên không âm đã cho.\n\n- Tham số:\n- n: Một số nguyên không âm mà lũy thừa của 2 được tính. Giá trị của `n` phải nằm trong khoảng từ 0 đến 30, bao gồm cả hai đầu.\n\n- Trả về: Kết quả của 2 lũy thừa `n`.\n\n### Ví dụ:\n- `powerOfTwo(3)` trả về `8`, vì 2^3 = 8.\n- `powerOfTwo(5)` trả về `32`, vì 2^5 = 32.\n- `powerOfTwo(10)` trả về `1024`, vì 2^10 = 1024.\n\nLưu ý: Hàm được thiết kế để xử lý các đầu vào trong phạm vi đã chỉ định mà không dẫn đến tràn số nguyên."
    },
    "docstring_bertscore": {
      "es": "0.9863598531039532",
      "arb": "0.9842376861129765",
      "sw": "0.984035877645845",
      "tr": "0.9706352789893262",
      "vi": "0.9819840258097546"
    }
  },
  {
    "task_id": "Swift/49",
    "prompt": {
      "en": "func determineSign(_ n: Int) -> String {\n    /**\n    Determines if a given integer is positive, zero, or negative.\n\n    - Parameters:\n        - n: An integer value that can range from -10^9 to 10^9.\n\n    - Returns: A string that indicates whether the integer is `positive`, `zero`, or `negative`.\n\n    ### Example:\n    - `determineSign(3)` returns `\"positive\"`.\n    - `determineSign(0)` returns `\"zero\"`.\n    - `determineSign(-5)` returns `\"negative\"`.\n\n    Note: This function accurately classifies any integer within the specified range into one of the three categories.\n    */",
      "es": "func determineSign(_ n: Int) -> String {\n    /**\n    Determina si un entero dado es positivo, cero o negativo.\n\n    - Parámetros:\n        - n: Un valor entero que puede variar de -10^9 a 10^9.\n\n    - Retorna: Una cadena que indica si el entero es `positive`, `zero`, o `negative`.\n\n    ### Ejemplo:\n    - `determineSign(3)` retorna `\"positive\"`.\n    - `determineSign(0)` retorna `\"zero\"`.\n    - `determineSign(-5)` retorna `\"negative\"`.\n\n    Nota: Esta función clasifica con precisión cualquier entero dentro del rango especificado en una de las tres categorías.\n    */",
      "arb": "func determineSign(_ n: Int) -> String {\n    /**\n    يحدد ما إذا كان العدد الصحيح المعطى موجبًا أو صفرًا أو سالبًا.\n\n    - المعلمات:\n        - n: قيمة عدد صحيح يمكن أن تتراوح من -10^9 إلى 10^9.\n\n    - يعيد: سلسلة تشير إلى ما إذا كان العدد الصحيح `موجبًا`، `صفرًا`، أو `سالبًا`.\n\n    ### مثال:\n    - `determineSign(3)` يعيد `\"positive\"`.\n    - `determineSign(0)` يعيد `\"zero\"`.\n    - `determineSign(-5)` يعيد `\"negative\"`.\n\n    ملاحظة: تقوم هذه الدالة بتصنيف أي عدد صحيح ضمن النطاق المحدد بدقة إلى واحدة من الفئات الثلاث.\n    */",
      "sw": "func determineSign(_ n: Int) -> String {\n    /**\n    Huamua ikiwa nambari kamili iliyotolewa ni chanya, sifuri, au hasi.\n\n    - Vigezo:\n        - n: Thamani ya nambari kamili inayoweza kuwa kati ya -10^9 hadi 10^9.\n\n    - Inarudisha: Mfuatano wa herufi unaoonyesha ikiwa nambari kamili ni `chanya`, `sifuri`, au `hasi`.\n\n    ### Mfano:\n    - `determineSign(3)` inarudisha `\"positive\"`.\n    - `determineSign(0)` inarudisha `\"zero\"`.\n    - `determineSign(-5)` inarudisha `\"negative\"`.\n\n    Kumbuka: Kazi hii inatambua kwa usahihi nambari yoyote ndani ya anuwai iliyotajwa katika moja ya makundi matatu.\n    */",
      "tr": "func determineSign(_ n: Int) -> String {\n    /**\n    Verilen bir tam sayının pozitif, sıfır veya negatif olup olmadığını belirler.\n\n    - Parametreler:\n        - n: -10^9 ile 10^9 arasında değişebilen bir tam sayı değeri.\n\n    - Döndürür: Tam sayının `pozitif`, `sıfır` veya `negatif` olduğunu belirten bir string.\n\n    ### Örnek:\n    - `determineSign(3)` `\"positive\"` döndürür.\n    - `determineSign(0)` `\"zero\"` döndürür.\n    - `determineSign(-5)` `\"negative\"` döndürür.\n\n    Not: Bu fonksiyon, belirtilen aralıktaki herhangi bir tam sayıyı üç kategoriden birine doğru bir şekilde sınıflandırır.\n    */",
      "vi": "func determineSign(_ n: Int) -> String {\n    /**\n    Xác định xem một số nguyên đã cho là dương, bằng không, hay âm.\n\n    - Tham số:\n        - n: Một giá trị số nguyên có thể nằm trong khoảng từ -10^9 đến 10^9.\n\n    - Trả về: Một chuỗi cho biết số nguyên là `positive`, `zero`, hay `negative`.\n\n    ### Ví dụ:\n    - `determineSign(3)` trả về `\"positive\"`.\n    - `determineSign(0)` trả về `\"zero\"`.\n    - `determineSign(-5)` trả về `\"negative\"`.\n\n    Lưu ý: Hàm này phân loại chính xác bất kỳ số nguyên nào trong phạm vi đã chỉ định vào một trong ba loại.\n    */"
    },
    "prompt_bertscore": {
      "es": "0.996897393448235",
      "arb": "0.99560470692846",
      "sw": "0.9863338325240376",
      "tr": "0.9955010218695598",
      "vi": "0.9837750759555461"
    },
    "canonical_solution": "    if n > 0 {\n        return \"positive\"\n    } else if n == 0 {\n        return \"zero\"\n    } else {\n        return \"negative\"\n    }\n}",
    "instruction": {
      "en": "func determineSign(_ n: Int) -> String {\n    if n > 0 {\n        return \"positive\"\n    } else if n == 0 {\n        return \"zero\"\n    } else {\n        return \"negative\"\n    }\n}\n\nProvide a concise natural language description (docstring) of the Swift code in English using at most 500 characters.",
      "es": "func determineSign(_ n: Int) -> String {\n    if n > 0 {\n        return \"positive\"\n    } else if n == 0 {\n        return \"zero\"\n    } else {\n        return \"negative\"\n    }\n}\n\nProporcione una descripción concisa en lenguaje natural (docstring) del código Swift en español utilizando como máximo 500 caracteres.",
      "arb": "func determineSign(_ n: Int) -> String {\n    if n > 0 {\n        return \"positive\"\n    } else if n == 0 {\n        return \"zero\"\n    } else {\n        return \"negative\"\n    }\n}\n\nقدم وصفًا موجزًا بلغة طبيعية (docstring) لكود Swift باللغة العربية الفصحى باستخدام 500 حرف كحد أقصى.",
      "sw": "func determineSign(_ n: Int) -> String {\n    if n > 0 {\n        return \"positive\"\n    } else if n == 0 {\n        return \"zero\"\n    } else {\n        return \"negative\"\n    }\n}\n\nToa maelezo mafupi ya lugha asilia (docstring) ya msimbo wa Swift kwa Kiswahili kwa kutumia herufi zisizozidi 500.",
      "tr": "func determineSign(_ n: Int) -> String {\n    if n > 0 {\n        return \"positive\"\n    } else if n == 0 {\n        return \"zero\"\n    } else {\n        return \"negative\"\n    }\n}\n\nSwift kodunun işlevini açıklayan kısa bir doğal dil açıklaması (docstring) sağlayın. Açıklama, Türkçe olarak en fazla 500 karakter kullanılarak yazılmalıdır.",
      "vi": "func determineSign(_ n: Int) -> String {\n    if n > 0 {\n        return \"positive\"\n    } else if n == 0 {\n        return \"zero\"\n    } else {\n        return \"negative\"\n    }\n}\n\nCung cấp mô tả ngắn gọn bằng ngôn ngữ tự nhiên (docstring) cho mã Swift bằng tiếng Việt, sử dụng tối đa 500 ký tự."
    },
    "instruction_bertscore": {
      "es": "0.9676013985493994",
      "arb": "0.9017943587910168",
      "sw": "0.933792521393451",
      "tr": "0.8714124515990634",
      "vi": "0.9256006072188102"
    },
    "level": "",
    "test": "func testDetermineSign() {\n    assert(determineSign(3) == \"positive\", \"3 should be positive.\")\n    assert(determineSign(0) == \"zero\", \"0 should be zero.\")\n    assert(determineSign(-5) == \"negative\", \"-5 should be negative.\")\n    assert(determineSign(1000000000) == \"positive\", \"1000000000 should be positive.\")\n    assert(determineSign(-1000000000) == \"negative\", \"-1000000000 should be negative.\")\n    assert(determineSign(1) == \"positive\", \"1 should be positive.\")\n}\n\n// Call the test function to verify the functionality\ntestDetermineSign()",
    "entry_point": "determineSign",
    "signature": "func determineSign(_ n: Int) -> String {",
    "docstring": {
      "en": "\nDetermines if a given integer is positive, zero, or negative.\n\n- Parameters:\n- n: An integer value that can range from -10^9 to 10^9.\n\n- Returns: A string that indicates whether the integer is `positive`, `zero`, or `negative`.\n\n### Example:\n- `determineSign(3)` returns `\"positive\"`.\n- `determineSign(0)` returns `\"zero\"`.\n- `determineSign(-5)` returns `\"negative\"`.\n\nNote: This function accurately classifies any integer within the specified range into one of the three categories.\n",
      "es": "Determina si un entero dado es positivo, cero o negativo.\n\n- Parámetros:\n- n: Un valor entero que puede variar de -10^9 a 10^9.\n\n- Retorna: Una cadena que indica si el entero es `positivo`, `cero` o `negativo`.\n\n### Ejemplo:\n- `determineSign(3)` retorna `\"positive\"`.\n- `determineSign(0)` retorna `\"zero\"`.\n- `determineSign(-5)` retorna `\"negative\"`.\n\nNota: Esta función clasifica con precisión cualquier entero dentro del rango especificado en una de las tres categorías.",
      "arb": "يحدد ما إذا كان العدد الصحيح المعطى موجبًا، صفرًا، أو سالبًا.\n\n- المعاملات:\n- n: قيمة عدد صحيح يمكن أن تتراوح من -10^9 إلى 10^9.\n\n- يعيد: سلسلة نصية تشير إلى ما إذا كان العدد الصحيح `موجبًا`، `صفرًا`، أو `سالبًا`.\n\n### مثال:\n- `determineSign(3)` يعيد `\"positive\"`.\n- `determineSign(0)` يعيد `\"zero\"`.\n- `determineSign(-5)` يعيد `\"negative\"`.\n\nملاحظة: تقوم هذه الدالة بتصنيف أي عدد صحيح ضمن النطاق المحدد بدقة إلى واحدة من الفئات الثلاث.",
      "sw": "Inabainisha ikiwa nambari kamili iliyotolewa ni chanya, sifuri, au hasi.\n\n- Vigezo:\n- n: Thamani ya nambari kamili inayoweza kuwa kati ya -10^9 hadi 10^9.\n\n- Inarudisha: Kamba ya maandishi inayoonyesha ikiwa nambari kamili ni `chanya`, `sifuri`, au `hasi`.\n\n### Mfano:\n- `determineSign(3)` inarudisha `\"positive\"`.\n- `determineSign(0)` inarudisha `\"zero\"`.\n- `determineSign(-5)` inarudisha `\"negative\"`.\n\nKumbuka: Kazi hii inabainisha kwa usahihi nambari yoyote kamili ndani ya kiwango kilichobainishwa katika moja ya makundi matatu.",
      "tr": "Verilen bir tam sayının pozitif, sıfır veya negatif olup olmadığını belirler.\n\n- Parametreler:\n- n: -10^9 ile 10^9 arasında değişebilen bir tam sayı değeri.\n\n- Döndürür: Tam sayının `pozitif`, `sıfır` veya `negatif` olduğunu belirten bir dize.\n\n### Örnek:\n- `determineSign(3)` `\"positive\"` döndürür.\n- `determineSign(0)` `\"zero\"` döndürür.\n- `determineSign(-5)` `\"negative\"` döndürür.\n\nNot: Bu fonksiyon, belirtilen aralıktaki herhangi bir tam sayıyı üç kategoriden birine doğru bir şekilde sınıflandırır.",
      "vi": "Xác định xem một số nguyên cho trước là dương, bằng không, hay âm.\n\n- Tham số:\n- n: Một giá trị số nguyên có thể nằm trong khoảng từ -10^9 đến 10^9.\n\n- Trả về: Một chuỗi chỉ ra liệu số nguyên là `positive`, `zero`, hay `negative`.\n\n### Ví dụ:\n- `determineSign(3)` trả về `\"positive\"`.\n- `determineSign(0)` trả về `\"zero\"`.\n- `determineSign(-5)` trả về `\"negative\"`.\n\nLưu ý: Hàm này phân loại chính xác bất kỳ số nguyên nào trong phạm vi đã chỉ định vào một trong ba loại."
    },
    "docstring_bertscore": {
      "es": "0.9895029802534493",
      "arb": "0.9931381148567687",
      "sw": "0.9844261863445786",
      "tr": "0.9931971080799361",
      "vi": "0.9846176660318962"
    }
  },
  {
    "task_id": "Swift/50",
    "prompt": {
      "en": "func absoluteValue(_ n: Int) -> Int {\n    /**\n    Calculates and returns the absolute value of a given integer.\n\n    - Parameters:\n        - n: An integer whose absolute value is to be calculated. The value of `n` must not exceed the absolute value of 10000.\n\n    - Returns: The absolute value of `n`.\n\n    ### Example:\n    - `absoluteValue(-3)` returns `3`.\n    - `absoluteValue(5)` returns `5`.\n    - `absoluteValue(0)` returns `0`.\n    - `absoluteValue(-10000)` returns `10000`.\n\n    Note: This function ensures that the absolute value is correctly calculated for any integer within the specified limit.\n    */",
      "es": "func absoluteValue(_ n: Int) -> Int {\n    /**\n    Calcula y devuelve el valor absoluto de un entero dado.\n\n    - Parámetros:\n        - n: Un entero cuyo valor absoluto se va a calcular. El valor de `n` no debe exceder el valor absoluto de 10000.\n\n    - Devuelve: El valor absoluto de `n`.\n\n    ### Ejemplo:\n    - `absoluteValue(-3)` devuelve `3`.\n    - `absoluteValue(5)` devuelve `5`.\n    - `absoluteValue(0)` devuelve `0`.\n    - `absoluteValue(-10000)` devuelve `10000`.\n\n    Nota: Esta función asegura que el valor absoluto se calcule correctamente para cualquier entero dentro del límite especificado.\n    */",
      "arb": "func absoluteValue(_ n: Int) -> Int {\n    /**\n    يحسب ويعيد القيمة المطلقة لعدد صحيح معين.\n\n    - Parameters:\n        - n: عدد صحيح يجب حساب قيمته المطلقة. يجب ألا يتجاوز قيمة `n` المطلقة 10000.\n\n    - Returns: القيمة المطلقة لـ `n`.\n\n    ### Example:\n    - `absoluteValue(-3)` returns `3`.\n    - `absoluteValue(5)` returns `5`.\n    - `absoluteValue(0)` returns `0`.\n    - `absoluteValue(-10000)` returns `10000`.\n\n    ملاحظة: تضمن هذه الدالة أن القيمة المطلقة تحسب بشكل صحيح لأي عدد صحيح ضمن الحد المحدد.\n    */",
      "sw": "func absoluteValue(_ n: Int) -> Int {\n    /**\n    Hukokotoa na kurudisha thamani kamili ya nambari nzima iliyotolewa.\n\n    - Vigezo:\n        - n: Nambari nzima ambayo thamani yake kamili inapaswa kukokotolewa. Thamani ya `n` haipaswi kuzidi thamani kamili ya 10000.\n\n    - Inarudisha: Thamani kamili ya `n`.\n\n    ### Mfano:\n    - `absoluteValue(-3)` inarudisha `3`.\n    - `absoluteValue(5)` inarudisha `5`.\n    - `absoluteValue(0)` inarudisha `0`.\n    - `absoluteValue(-10000)` inarudisha `10000`.\n\n    Kumbuka: Kazi hii inahakikisha kuwa thamani kamili inakokotolewa kwa usahihi kwa nambari yoyote nzima ndani ya kikomo kilichowekwa.\n    */",
      "tr": "func absoluteValue(_ n: Int) -> Int {\n    /**\n    Verilen bir tam sayının mutlak değerini hesaplar ve döndürür.\n\n    - Parametreler:\n        - n: Mutlak değeri hesaplanacak bir tam sayı. `n`'in değeri mutlak değer olarak 10000'i geçmemelidir.\n\n    - Döndürür: `n`'in mutlak değeri.\n\n    ### Örnek:\n    - `absoluteValue(-3)` `3` döndürür.\n    - `absoluteValue(5)` `5` döndürür.\n    - `absoluteValue(0)` `0` döndürür.\n    - `absoluteValue(-10000)` `10000` döndürür.\n\n    Not: Bu fonksiyon, belirtilen sınırlar içindeki herhangi bir tam sayı için mutlak değerin doğru bir şekilde hesaplanmasını sağlar.\n    */",
      "vi": "func absoluteValue(_ n: Int) -> Int {\n    /**\n    Tính toán và trả về giá trị tuyệt đối của một số nguyên cho trước.\n\n    - Tham số:\n        - n: Một số nguyên mà giá trị tuyệt đối cần được tính. Giá trị của `n` không được vượt quá giá trị tuyệt đối của 10000.\n\n    - Trả về: Giá trị tuyệt đối của `n`.\n\n    ### Ví dụ:\n    - `absoluteValue(-3)` trả về `3`.\n    - `absoluteValue(5)` trả về `5`.\n    - `absoluteValue(0)` trả về `0`.\n    - `absoluteValue(-10000)` trả về `10000`.\n\n    Lưu ý: Hàm này đảm bảo rằng giá trị tuyệt đối được tính chính xác cho bất kỳ số nguyên nào trong giới hạn đã chỉ định.\n    */"
    },
    "prompt_bertscore": {
      "es": "0.9994450267153885",
      "arb": "0.988294910275995",
      "sw": "0.9850770981032299",
      "tr": "0.9756934016423797",
      "vi": "0.987344066641981"
    },
    "canonical_solution": "    return abs(n)\n}",
    "instruction": {
      "en": "func absoluteValue(_ n: Int) -> Int {\n    return abs(n)\n}\n\nProvide a concise natural language description (docstring) of the Swift code in English using at most 500 characters.",
      "es": "func absoluteValue(_ n: Int) -> Int {\n    return abs(n)\n}\n\nProporcione una descripción concisa en lenguaje natural (docstring) del código Swift en español utilizando un máximo de 500 caracteres.",
      "arb": "func absoluteValue(_ n: Int) -> Int {\n    return abs(n)\n}\n\nقدم وصفًا موجزًا بلغة طبيعية (docstring) لكود Swift باللغة العربية الفصحى باستخدام 500 حرف كحد أقصى.",
      "sw": "func absoluteValue(_ n: Int) -> Int {\n    return abs(n)\n}\n\nToa maelezo mafupi ya lugha ya asili (docstring) ya msimbo wa Swift kwa Kiswahili kwa kutumia herufi zisizozidi 500.",
      "tr": "func absoluteValue(_ n: Int) -> Int {\n    return abs(n)\n}\n\nSwift kodunun Türkçe açıklaması için en fazla 500 karakter kullanarak kısa ve öz bir doğal dil açıklaması (docstring) sağlayın.",
      "vi": "func absoluteValue(_ n: Int) -> Int {\n    return abs(n)\n}\n\nCung cấp mô tả ngắn gọn bằng ngôn ngữ tự nhiên (docstring) cho mã Swift bằng tiếng Việt, sử dụng tối đa 500 ký tự."
    },
    "instruction_bertscore": {
      "es": "0.9676013985493994",
      "arb": "0.9202294430852458",
      "sw": "0.942496901951162",
      "tr": "0.904072450631106",
      "vi": "0.9054771646857847"
    },
    "level": "",
    "test": "func testAbsoluteValue() {\n    assert(absoluteValue(-3) == 3, \"-3's absolute value should be 3.\")\n    assert(absoluteValue(5) == 5, \"5's absolute value should be 5.\")\n    assert(absoluteValue(0) == 0, \"0's absolute value should be 0.\")\n    assert(absoluteValue(-10000) == 10000, \"-10000's absolute value should be 10000.\")\n    assert(absoluteValue(10000) == 10000, \"10000's absolute value should be 10000.\")\n    assert(absoluteValue(-1) == 1, \"-1's absolute value should be 1.\")\n}\n\n// Call the test function to verify the functionality\ntestAbsoluteValue()",
    "entry_point": "absoluteValue",
    "signature": "func absoluteValue(_ n: Int) -> Int {",
    "docstring": {
      "en": "\nCalculates and returns the absolute value of a given integer.\n\n- Parameters:\n- n: An integer whose absolute value is to be calculated. The value of `n` must not exceed the absolute value of 10000.\n\n- Returns: The absolute value of `n`.\n\n### Example:\n- `absoluteValue(-3)` returns `3`.\n- `absoluteValue(5)` returns `5`.\n- `absoluteValue(0)` returns `0`.\n- `absoluteValue(-10000)` returns `10000`.\n\nNote: This function ensures that the absolute value is correctly calculated for any integer within the specified limit.\n",
      "es": "Calcula y devuelve el valor absoluto de un número entero dado.\n\n- Parámetros:\n- n: Un número entero cuyo valor absoluto se va a calcular. El valor de `n` no debe exceder el valor absoluto de 10000.\n\n- Devuelve: El valor absoluto de `n`.\n\n### Ejemplo:\n- `absoluteValue(-3)` devuelve `3`.\n- `absoluteValue(5)` devuelve `5`.\n- `absoluteValue(0)` devuelve `0`.\n- `absoluteValue(-10000)` devuelve `10000`.\n\nNota: Esta función asegura que el valor absoluto se calcule correctamente para cualquier número entero dentro del límite especificado.",
      "arb": "يحسب ويعيد القيمة المطلقة لعدد صحيح معين.\n\n- المعلمات:\n- n: عدد صحيح يراد حساب قيمته المطلقة. يجب ألا تتجاوز قيمة `n` القيمة المطلقة لـ 10000.\n\n- العوائد: القيمة المطلقة لـ `n`.\n\n### مثال:\n- `absoluteValue(-3)` يعيد `3`.\n- `absoluteValue(5)` يعيد `5`.\n- `absoluteValue(0)` يعيد `0`.\n- `absoluteValue(-10000)` يعيد `10000`.\n\nملاحظة: تضمن هذه الدالة حساب القيمة المطلقة بشكل صحيح لأي عدد صحيح ضمن الحد المحدد.",
      "sw": "Inahesabu na kurudisha thamani kamili ya nambari kamili iliyotolewa.\n\n- Vigezo:\n- n: Nambari kamili ambayo thamani yake kamili inatakiwa kuhesabiwa. Thamani ya `n` haipaswi kuzidi thamani kamili ya 10000.\n\n- Inarudisha: Thamani kamili ya `n`.\n\n### Mfano:\n- `absoluteValue(-3)` inarudisha `3`.\n- `absoluteValue(5)` inarudisha `5`.\n- `absoluteValue(0)` inarudisha `0`.\n- `absoluteValue(-10000)` inarudisha `10000`.\n\nKumbuka: Kazi hii inahakikisha kwamba thamani kamili inahesabiwa kwa usahihi kwa nambari yoyote kamili ndani ya kikomo kilichowekwa.",
      "tr": "Verilen bir tam sayının mutlak değerini hesaplar ve döndürür.\n\n- Parametreler:\n- n: Mutlak değeri hesaplanacak bir tam sayı. `n`'nin değeri 10000'in mutlak değerini aşmamalıdır.\n\n- Döndürür: `n`'nin mutlak değeri.\n\n### Örnek:\n- `absoluteValue(-3)` `3` döndürür.\n- `absoluteValue(5)` `5` döndürür.\n- `absoluteValue(0)` `0` döndürür.\n- `absoluteValue(-10000)` `10000` döndürür.\n\nNot: Bu fonksiyon, belirtilen sınırlar içindeki herhangi bir tam sayı için mutlak değerin doğru bir şekilde hesaplanmasını sağlar.",
      "vi": "Tính toán và trả về giá trị tuyệt đối của một số nguyên cho trước.\n\n- Tham số:\n- n: Một số nguyên mà giá trị tuyệt đối cần được tính toán. Giá trị của `n` không được vượt quá giá trị tuyệt đối của 10000.\n\n- Trả về: Giá trị tuyệt đối của `n`.\n\n### Ví dụ:\n- `absoluteValue(-3)` trả về `3`.\n- `absoluteValue(5)` trả về `5`.\n- `absoluteValue(0)` trả về `0`.\n- `absoluteValue(-10000)` trả về `10000`.\n\nLưu ý: Hàm này đảm bảo rằng giá trị tuyệt đối được tính toán chính xác cho bất kỳ số nguyên nào trong giới hạn đã chỉ định."
    },
    "docstring_bertscore": {
      "es": "0.9993196909449555",
      "arb": "0.9816852857166781",
      "sw": "0.9942524312943745",
      "tr": "0.9819695257919391",
      "vi": "0.9862605379134357"
    }
  }
]