[
  {
    "task_id": "C#/1",
    "prompt": {
      "es": "using System;\nusing System.Collections.Generic;\n\nclass Program\n{\n    /* Verificar si en la lista dada de números, hay dos números que están más cerca uno del otro que\n   el umbral dado.\n   >>> hasCloseElements([1.0, 2.0, 3.0], 0.5)\n   false\n   >>> hasCloseElements([1.0, 2.8, 3.0, 4.0, 5.0, 2.0], 0.3)\n   true\n    */\n    static bool HasCloseElements(List<double> numbers, double threshold)",
      "arb": "using System;\nusing System.Collections.Generic;\n\nclass Program\n{\n    /* التحقق مما إذا كان في قائمة الأرقام المعطاة، أي رقمين أقرب إلى بعضهما البعض من\n   العتبة المعطاة.\n   >>> hasCloseElements([1.0, 2.0, 3.0], 0.5)\n   false\n   >>> hasCloseElements([1.0, 2.8, 3.0, 4.0, 5.0, 2.0], 0.3)\n   true\n    */\n    static bool HasCloseElements(List<double> numbers, double threshold)",
      "sw": "using System;\nusing System.Collections.Generic;\n\nclass Program\n{\n    /* Angalia kama katika orodha iliyotolewa ya namba, kuna namba mbili zozote ambazo ziko karibu zaidi kuliko\n   kizingiti kilichotolewa.\n   >>> hasCloseElements([1.0, 2.0, 3.0], 0.5)\n   false\n   >>> hasCloseElements([1.0, 2.8, 3.0, 4.0, 5.0, 2.0], 0.3)\n   true\n    */\n    static bool HasCloseElements(List<double> numbers, double threshold)",
      "tr": "using System;\nusing System.Collections.Generic;\n\nclass Program\n{\n    /* Verilen sayı listesindeki herhangi iki sayının\n   verilen eşikten daha yakın olup olmadığını kontrol edin.\n   >>> hasCloseElements([1.0, 2.0, 3.0], 0.5)\n   false\n   >>> hasCloseElements([1.0, 2.8, 3.0, 4.0, 5.0, 2.0], 0.3)\n   true\n    */\n    static bool HasCloseElements(List<double> numbers, double threshold)",
      "vi": "using System;\nusing System.Collections.Generic;\n\nclass Program\n{\n    /* Kiểm tra xem trong danh sách số đã cho, có bất kỳ hai số nào gần nhau hơn\n   ngưỡng đã cho hay không.\n   >>> hasCloseElements([1.0, 2.0, 3.0], 0.5)\n   false\n   >>> hasCloseElements([1.0, 2.8, 3.0, 4.0, 5.0, 2.0], 0.3)\n   true\n    */\n    static bool HasCloseElements(List<double> numbers, double threshold)"
    },
    "prompt_bertscore": {
      "es": "0.9808506408555695",
      "arb": "0.9934285124738418",
      "sw": "0.9781498635646382",
      "tr": "0.9647605868398385",
      "vi": "0.9816409911417073"
    },
    "canonical_solution": "    {\n        for (int i = 0; i < numbers.Count; i++)\n        {\n            for (int j = 0; j < numbers.Count; j++)\n            {\n                if (i != j)\n                {\n                    double distance = Math.Abs(numbers[i] - numbers[j]);\n                    if (distance < threshold)\n                    {\n                        return true;\n                    }\n                }\n            }\n        }\n        return false;\n    }",
    "instruction": {
      "es": "static bool HasCloseElements(List<double> numbers, double threshold)\n    {\n        for (int i = 0; i < numbers.Count; i++)\n        {\n            for (int j = 0; j < numbers.Count; j++)\n            {\n                if (i != j)\n                {\n                    double distance = Math.Abs(numbers[i] - numbers[j]);\n                    if (distance < threshold)\n                    {\n                        return true;\n                    }\n                }\n            }\n        }\n        return false;\n    }\n\nProporcione una descripción concisa en lenguaje natural (docstring) del código C# en español utilizando como máximo 500 caracteres.",
      "arb": "static bool HasCloseElements(List<double> numbers, double threshold)\n    {\n        for (int i = 0; i < numbers.Count; i++)\n        {\n            for (int j = 0; j < numbers.Count; j++)\n            {\n                if (i != j)\n                {\n                    double distance = Math.Abs(numbers[i] - numbers[j]);\n                    if (distance < threshold)\n                    {\n                        return true;\n                    }\n                }\n            }\n        }\n        return false;\n    }\n\nيرجى تقديم وصف موجز بلغة طبيعية (docstring) للكود المكتوب بلغة C# باللغة العربية الفصحى، بحيث لا يتجاوز 500 حرف.",
      "sw": "static bool HasCloseElements(List<double> numbers, double threshold)\n    {\n        for (int i = 0; i < numbers.Count; i++)\n        {\n            for (int j = 0; j < numbers.Count; j++)\n            {\n                if (i != j)\n                {\n                    double distance = Math.Abs(numbers[i] - numbers[j]);\n                    if (distance < threshold)\n                    {\n                        return true;\n                    }\n                }\n            }\n        }\n        return false;\n    }\n\nToa maelezo mafupi ya lugha asilia (docstring) ya msimbo wa C# kwa Kiswahili kwa kutumia herufi zisizozidi 500.",
      "tr": "static bool HasCloseElements(List<double> numbers, double threshold)\n    {\n        for (int i = 0; i < numbers.Count; i++)\n        {\n            for (int j = 0; j < numbers.Count; j++)\n            {\n                if (i != j)\n                {\n                    double distance = Math.Abs(numbers[i] - numbers[j]);\n                    if (distance < threshold)\n                    {\n                        return true;\n                    }\n                }\n            }\n        }\n        return false;\n    }\n\nC# kodunun Türkçe olarak en fazla 500 karakter kullanarak kısa bir doğal dil açıklamasını (docstring) sağlayın.",
      "vi": "static bool HasCloseElements(List<double> numbers, double threshold)\n    {\n        for (int i = 0; i < numbers.Count; i++)\n        {\n            for (int j = 0; j < numbers.Count; j++)\n            {\n                if (i != j)\n                {\n                    double distance = Math.Abs(numbers[i] - numbers[j]);\n                    if (distance < threshold)\n                    {\n                        return true;\n                    }\n                }\n            }\n        }\n        return false;\n    }\n\nCung cấp mô tả ngắn gọn bằng ngôn ngữ tự nhiên (docstring) cho mã C# bằng tiếng Việt, không quá 500 ký tự."
    },
    "instruction_bertscore": {
      "es": "0.9702167647764858",
      "arb": "0.8716935135882278",
      "sw": "0.9446027812508938",
      "tr": "0.941090996114197",
      "vi": "0.9093975325162702"
    },
    "level": "",
    "test": "static void Main()\n    {\n\n        // Test cases\n        Console.WriteLine(HasCloseElements(new List<double> { 1.0, 2.0, 3.9, 4.0, 5.0, 2.2 }, 0.3) == true);\n        Console.WriteLine(HasCloseElements(new List<double> { 1.0, 2.0, 3.9, 4.0, 5.0, 2.2 }, 0.05) == false);\n        Console.WriteLine(HasCloseElements(new List<double> { 1.0, 2.0, 5.9, 4.0, 5.0 }, 0.95) == true);\n        Console.WriteLine(HasCloseElements(new List<double> { 1.0, 2.0, 5.9, 4.0, 5.0 }, 0.8) == false);\n        Console.WriteLine(HasCloseElements(new List<double> { 1.0, 2.0, 3.0, 4.0, 5.0, 2.0 }, 0.1) == true);\n        Console.WriteLine(HasCloseElements(new List<double> { 1.1, 2.2, 3.1, 4.1, 5.1 }, 1.0) == true);\n        Console.WriteLine(HasCloseElements(new List<double> { 1.1, 2.2, 3.1, 4.1, 5.1 }, 0.5) == false);\n    }\n}",
    "entry_point": "HasCloseElements",
    "signature": "static bool HasCloseElements(List<double> numbers, double threshold)",
    "docstring": {
      "es": "Verifica si en la lista dada de números, hay dos números más cercanos entre sí que el umbral dado.\n   >>> hasCloseElements([1.0, 2.0, 3.0], 0.5)\n   false\n   >>> hasCloseElements([1.0, 2.8, 3.0, 4.0, 5.0, 2.0], 0.3)\n   true",
      "arb": "تحقق مما إذا كان في قائمة الأرقام المعطاة، أي رقمين أقرب إلى بعضهما البعض من العتبة المعطاة.\n   >>> hasCloseElements([1.0, 2.0, 3.0], 0.5)\n   false\n   >>> hasCloseElements([1.0, 2.8, 3.0, 4.0, 5.0, 2.0], 0.3)\n   true",
      "sw": "Angalia ikiwa katika orodha iliyotolewa ya nambari, nambari yoyote mbili ziko karibu zaidi na kila mmoja kuliko kizingiti kilichotolewa.\n   >>> hasCloseElements([1.0, 2.0, 3.0], 0.5)\n   false\n   >>> hasCloseElements([1.0, 2.8, 3.0, 4.0, 5.0, 2.0], 0.3)\n   true",
      "tr": "Verilen sayı listesindeki herhangi iki sayının, verilen eşikten daha yakın olup olmadığını kontrol edin.\n   >>> hasCloseElements([1.0, 2.0, 3.0], 0.5)\n   false\n   >>> hasCloseElements([1.0, 2.8, 3.0, 4.0, 5.0, 2.0], 0.3)\n   true",
      "vi": "Kiểm tra xem trong danh sách số đã cho, có hai số nào gần nhau hơn ngưỡng đã cho hay không.\n   >>> hasCloseElements([1.0, 2.0, 3.0], 0.5)\n   false\n   >>> hasCloseElements([1.0, 2.8, 3.0, 4.0, 5.0, 2.0], 0.3)\n   true"
    },
    "docstring_bertscore": {
      "es": "0.9821582246539222",
      "arb": "0.9912743659915184",
      "sw": "0.9912743659915184",
      "tr": "0.959816478025499",
      "vi": "0.979270536174437"
    }
  },
  {
    "task_id": "C#/2",
    "prompt": {
      "es": "using System;\nusing System.Collections.Generic;\nusing System.Diagnostics;\n\nclass Program\n{\n /* Convierte una temperatura dada en Fahrenheit a Celsius y devuelve el resultado como una cadena formateada a dos decimales.\n    La fórmula utilizada es: Celsius = 5/9 * (Fahrenheit - 32).\n    Ejemplo de uso:\n    >>> ConvertFahrenheitToCelsius(32)\n    \"c=0.00\"\n    >>> ConvertFahrenheitToCelsius(212)\n    \"c=100.00\"\n*/  \nstatic string ConvertFahrenheitToCelsius(double fahrenheitTemperature)",
      "arb": "using System;\nusing System.Collections.Generic;\nusing System.Diagnostics;\n\nclass Program\n{\n /* يحول درجة الحرارة المعطاة بالفهرنهايت إلى درجة مئوية ويعيد النتيجة كقيمة نصية منسقة إلى منزلتين عشريتين.\n    الصيغة المستخدمة هي: Celsius = 5/9 * (Fahrenheit - 32).\n    مثال على الاستخدام:\n    >>> ConvertFahrenheitToCelsius(32)\n    \"c=0.00\"\n    >>> ConvertFahrenheitToCelsius(212)\n    \"c=100.00\"\n*/  \nstatic string ConvertFahrenheitToCelsius(double fahrenheitTemperature)",
      "sw": "using System;\nusing System.Collections.Generic;\nusing System.Diagnostics;\n\nclass Program\n{\n /* Hubadilisha joto lililo katika Fahrenheit kuwa Celsius na kurudisha matokeo kama kamba iliyopangwa kwa sehemu mbili za desimali.\n    Fomula inayotumika ni: Celsius = 5/9 * (Fahrenheit - 32).\n    Mfano wa matumizi:\n    >>> ConvertFahrenheitToCelsius(32)\n    \"c=0.00\"\n    >>> ConvertFahrenheitToCelsius(212)\n    \"c=100.00\"\n*/  \nstatic string ConvertFahrenheitToCelsius(double fahrenheitTemperature)",
      "tr": "using System;\nusing System.Collections.Generic;\nusing System.Diagnostics;\n\nclass Program\n{\n /* Verilen Fahrenheit sıcaklığını Celsius'a çevirir ve sonucu iki ondalık basamağa yuvarlanmış bir string olarak döndürür.\n    Kullanılan formül: Celsius = 5/9 * (Fahrenheit - 32).\n    Örnek kullanım:\n    >>> ConvertFahrenheitToCelsius(32)\n    \"c=0.00\"\n    >>> ConvertFahrenheitToCelsius(212)\n    \"c=100.00\"\n*/  \nstatic string ConvertFahrenheitToCelsius(double fahrenheitTemperature)",
      "vi": "using System;\nusing System.Collections.Generic;\nusing System.Diagnostics;\n\nclass Program\n{\n /* Chuyển đổi một nhiệt độ Fahrenheit đã cho sang Celsius và trả về kết quả dưới dạng chuỗi định dạng đến hai chữ số thập phân.\n    Công thức được sử dụng là: Celsius = 5/9 * (Fahrenheit - 32).\n    Ví dụ sử dụng:\n    >>> ConvertFahrenheitToCelsius(32)\n    \"c=0.00\"\n    >>> ConvertFahrenheitToCelsius(212)\n    \"c=100.00\"\n*/  \nstatic string ConvertFahrenheitToCelsius(double fahrenheitTemperature)"
    },
    "prompt_bertscore": {
      "es": "0.9899892274262226",
      "arb": "0.9914509484002584",
      "sw": "0.9876940533733646",
      "tr": "0.9816525117038074",
      "vi": "0.9921827027239909"
    },
    "canonical_solution": "{\n    double celsiusTemperature = 5.0 / 9.0 * (fahrenheitTemperature - 32);\n    return $\"c={celsiusTemperature:F2}\";\n}",
    "instruction": {
      "es": "static string ConvertFahrenheitToCelsius(double fahrenheitTemperature)\n{\n    double celsiusTemperature = 5.0 / 9.0 * (fahrenheitTemperature - 32);\n    return $\"c={celsiusTemperature:F2}\";\n}\n\nProporcione una descripción concisa en lenguaje natural (docstring) del código C# en español utilizando un máximo de 500 caracteres.",
      "arb": "static string ConvertFahrenheitToCelsius(double fahrenheitTemperature)\n{\n    double celsiusTemperature = 5.0 / 9.0 * (fahrenheitTemperature - 32);\n    return $\"c={celsiusTemperature:F2}\";\n}\n\nقدم وصفًا موجزًا بلغة طبيعية (docstring) لكود C# باللغة العربية الفصحى باستخدام 500 حرف كحد أقصى.",
      "sw": "static string ConvertFahrenheitToCelsius(double fahrenheitTemperature)\n{\n    double celsiusTemperature = 5.0 / 9.0 * (fahrenheitTemperature - 32);\n    return $\"c={celsiusTemperature:F2}\";\n}\n\nToa maelezo mafupi ya lugha ya asili (docstring) ya msimbo wa C# kwa Kiswahili kwa kutumia herufi zisizozidi 500.",
      "tr": "static string ConvertFahrenheitToCelsius(double fahrenheitTemperature)\n{\n    double celsiusTemperature = 5.0 / 9.0 * (fahrenheitTemperature - 32);\n    return $\"c={celsiusTemperature:F2}\";\n}\n\nAşağıdaki C# kodunun işlevini açıklayan kısa bir doğal dil açıklaması (docstring) sağlayın. Açıklama Türkçe olmalı ve en fazla 500 karakter kullanılmalıdır.",
      "vi": "static string ConvertFahrenheitToCelsius(double fahrenheitTemperature)\n{\n    double celsiusTemperature = 5.0 / 9.0 * (fahrenheitTemperature - 32);\n    return $\"c={celsiusTemperature:F2}\";\n}\n\nCung cấp mô tả ngắn gọn bằng ngôn ngữ tự nhiên (docstring) cho mã C# bằng tiếng Việt với tối đa 500 ký tự."
    },
    "instruction_bertscore": {
      "es": "0.9702167647764858",
      "arb": "0.920145025173306",
      "sw": "0.918288824262535",
      "tr": "0.8651067315227299",
      "vi": "0.918539495803401"
    },
    "level": "",
    "test": "    static void Main()\n    {\n        Debug.Assert(ConvertFahrenheitToCelsius(32) == \"c=0.00\");\n        Debug.Assert(ConvertFahrenheitToCelsius(212) == \"c=100.00\");\n        Debug.Assert(ConvertFahrenheitToCelsius(-40) == \"c=-40.00\");\n        Debug.Assert(ConvertFahrenheitToCelsius(98.6) == \"c=37.00\");\n        Debug.Assert(ConvertFahrenheitToCelsius(0) == \"c=-17.78\");\n\n    }\n}",
    "entry_point": "ConvertFahrenheitToCelsius",
    "signature": "static string ConvertFahrenheitToCelsius(double fahrenheitTemperature)",
    "docstring": {
      "es": "Convierte una temperatura dada en Fahrenheit a Celsius y devuelve el resultado como una cadena formateada con dos decimales.\n    La fórmula utilizada es: Celsius = 5/9 * (Fahrenheit - 32).\n    Ejemplo de uso:\n    >>> ConvertFahrenheitToCelsius(32)\n    \"c=0.00\"\n    >>> ConvertFahrenheitToCelsius(212)\n    \"c=100.00\"",
      "arb": "يقوم بتحويل درجة الحرارة المعطاة بالفهرنهايت إلى درجة مئوية ويعيد النتيجة كسلسلة نصية منسقة إلى منزلتين عشريتين.\n    الصيغة المستخدمة هي: Celsius = 5/9 * (Fahrenheit - 32).\n    مثال على الاستخدام:\n    >>> ConvertFahrenheitToCelsius(32)\n    \"c=0.00\"\n    >>> ConvertFahrenheitToCelsius(212)\n    \"c=100.00\"",
      "sw": "Hurekebisha joto lililopewa la Fahrenheit kuwa Celsius na kurudisha matokeo kama kamba iliyowekwa katika sehemu mbili za desimali. \n    Fomula inayotumika ni: Celsius = 5/9 * (Fahrenheit - 32).\n    Mfano wa matumizi:\n    >>> ConvertFahrenheitToCelsius(32)\n    \"c=0.00\"\n    >>> ConvertFahrenheitToCelsius(212)\n    \"c=100.00\"",
      "tr": "Verilen Fahrenheit sıcaklığını Celsius'a dönüştürür ve sonucu iki ondalık basamaklı bir string olarak döndürür.\n    Kullanılan formül: Celsius = 5/9 * (Fahrenheit - 32).\n    Örnek kullanım:\n    >>> ConvertFahrenheitToCelsius(32)\n    \"c=0.00\"\n    >>> ConvertFahrenheitToCelsius(212)\n    \"c=100.00\"",
      "vi": "Chuyển đổi nhiệt độ Fahrenheit đã cho sang Celsius và trả về kết quả dưới dạng chuỗi được định dạng đến hai chữ số thập phân. \n    Công thức được sử dụng là: Celsius = 5/9 * (Fahrenheit - 32).\n    Ví dụ sử dụng:\n    >>> ConvertFahrenheitToCelsius(32)\n    \"c=0.00\"\n    >>> ConvertFahrenheitToCelsius(212)\n    \"c=100.00\""
    },
    "docstring_bertscore": {
      "es": "0.9633262768583855",
      "arb": "0.9911166534689767",
      "sw": "0.9895458844157528",
      "tr": "0.9767959988875043",
      "vi": "0.9895458844157528"
    }
  },
  {
    "task_id": "C#/3",
    "prompt": {
      "es": "using System;\nusing System.Collections.Generic;\nusing System.Diagnostics;\n\nclass Program\n{\n   /*\n    Codifica la cadena dada desplazando cada letra un número especificado de lugares en el alfabeto.\n    Si el desplazamiento lleva la letra más allá de 'z', se reinicia al comienzo del alfabeto.\n    \n    Ejemplos:\n    >>> EncodeString(\"apple\", 2)\n    \"crrng\"\n    \n    >>> EncodeString(\"hello\", 5)\n    \"mjqqt\"\n*/\n   static string EncodeString(string input, int shift)",
      "arb": "using System;\nusing System.Collections.Generic;\nusing System.Diagnostics;\n\nclass Program\n{\n   /*\n    يقوم بترميز السلسلة النصية المعطاة عن طريق تحريك كل حرف بعدد محدد من الأماكن في الأبجدية.\n    إذا أخذ التحول الحرف إلى ما بعد 'z'، فإنه يلتف إلى بداية الأبجدية.\n    \n    أمثلة:\n    >>> EncodeString(\"apple\", 2)\n    \"crrng\"\n    \n    >>> EncodeString(\"hello\", 5)\n    \"mjqqt\"\n*/\n   static string EncodeString(string input, int shift)",
      "sw": "using System;\nusing System.Collections.Generic;\nusing System.Diagnostics;\n\nclass Program\n{\n   /*\n    Husimba mfuatano wa herufi uliotolewa kwa kusogeza kila herufi kwa idadi maalum ya nafasi katika alfabeti.\n    Ikiwa mabadiliko yanapeleka herufi zaidi ya 'z', inarudi mwanzo wa alfabeti.\n    \n    Mifano:\n    >>> EncodeString(\"apple\", 2)\n    \"crrng\"\n    \n    >>> EncodeString(\"hello\", 5)\n    \"mjqqt\"\n*/\n   static string EncodeString(string input, int shift)",
      "tr": "using System;\nusing System.Collections.Generic;\nusing System.Diagnostics;\n\nclass Program\n{\n   /*\n    Verilen string'i alfabede belirtilen sayıda yer kaydırarak kodlar.\n    Eğer kaydırma harfi 'z' harfinin ötesine taşırsa, alfabenin başına döner.\n    \n    Örnekler:\n    >>> EncodeString(\"apple\", 2)\n    \"crrng\"\n    \n    >>> EncodeString(\"hello\", 5)\n    \"mjqqt\"\n*/\n   static string EncodeString(string input, int shift)",
      "vi": "using System;\nusing System.Collections.Generic;\nusing System.Diagnostics;\n\nclass Program\n{\n   /*\n    Mã hóa chuỗi đã cho bằng cách dịch chuyển mỗi chữ cái một số vị trí nhất định trong bảng chữ cái.\n    Nếu dịch chuyển làm chữ cái vượt quá 'z', nó sẽ quay về đầu bảng chữ cái.\n    \n    Ví dụ:\n    >>> EncodeString(\"apple\", 2)\n    \"crrng\"\n    \n    >>> EncodeString(\"hello\", 5)\n    \"mjqqt\"\n*/\n   static string EncodeString(string input, int shift)"
    },
    "prompt_bertscore": {
      "es": "0.9766545740562075",
      "arb": "0.9885646503334404",
      "sw": "0.9864671135097121",
      "tr": "0.9803949827614755",
      "vi": "0.9726517746175924"
    },
    "canonical_solution": "{\n    char[] encodedChars = new char[input.Length];\n    for (int i = 0; i < input.Length; i++)\n    {\n        char letter = input[i];\n        if (char.IsLetter(letter))\n        {\n            char baseChar = char.IsUpper(letter) ? 'A' : 'a';\n            encodedChars[i] = (char)(((letter + shift - baseChar) % 26) + baseChar);\n        }\n        else\n        {\n            encodedChars[i] = letter;\n        }\n    }\n    return new string(encodedChars);\n}",
    "instruction": {
      "es": "static string EncodeString(string input, int shift)\n{\n    char[] encodedChars = new char[input.Length];\n    for (int i = 0; i < input.Length; i++)\n    {\n        char letter = input[i];\n        if (char.IsLetter(letter))\n        {\n            char baseChar = char.IsUpper(letter) ? 'A' : 'a';\n            encodedChars[i] = (char)(((letter + shift - baseChar) % 26) + baseChar);\n        }\n        else\n        {\n            encodedChars[i] = letter;\n        }\n    }\n    return new string(encodedChars);\n}\n\nProporcione una descripción concisa en lenguaje natural (docstring) del código C# en español utilizando como máximo 500 caracteres.",
      "arb": "static string EncodeString(string input, int shift)\n{\n    char[] encodedChars = new char[input.Length];\n    for (int i = 0; i < input.Length; i++)\n    {\n        char letter = input[i];\n        if (char.IsLetter(letter))\n        {\n            char baseChar = char.IsUpper(letter) ? 'A' : 'a';\n            encodedChars[i] = (char)(((letter + shift - baseChar) % 26) + baseChar);\n        }\n        else\n        {\n            encodedChars[i] = letter;\n        }\n    }\n    return new string(encodedChars);\n}\n\nقدم وصفًا موجزًا بلغة طبيعية (docstring) لكود C# باللغة العربية الفصحى باستخدام ما لا يزيد عن 500 حرف.",
      "sw": "static string EncodeString(string input, int shift)\n{\n    char[] encodedChars = new char[input.Length];\n    for (int i = 0; i < input.Length; i++)\n    {\n        char letter = input[i];\n        if (char.IsLetter(letter))\n        {\n            char baseChar = char.IsUpper(letter) ? 'A' : 'a';\n            encodedChars[i] = (char)(((letter + shift - baseChar) % 26) + baseChar);\n        }\n        else\n        {\n            encodedChars[i] = letter;\n        }\n    }\n    return new string(encodedChars);\n}\n\nToa maelezo mafupi ya lugha asilia (docstring) ya msimbo wa C# kwa Kiswahili kwa kutumia herufi zisizozidi 500.",
      "tr": "static string EncodeString(string input, int shift)\n{\n    char[] encodedChars = new char[input.Length];\n    for (int i = 0; i < input.Length; i++)\n    {\n        char letter = input[i];\n        if (char.IsLetter(letter))\n        {\n            char baseChar = char.IsUpper(letter) ? 'A' : 'a';\n            encodedChars[i] = (char)(((letter + shift - baseChar) % 26) + baseChar);\n        }\n        else\n        {\n            encodedChars[i] = letter;\n        }\n    }\n    return new string(encodedChars);\n}\n\nAşağıdaki C# kodunun Türkçe olarak en fazla 500 karakter kullanarak kısa bir doğal dil açıklamasını (docstring) sağlayın.",
      "vi": "static string EncodeString(string input, int shift)\n{\n    char[] encodedChars = new char[input.Length];\n    for (int i = 0; i < input.Length; i++)\n    {\n        char letter = input[i];\n        if (char.IsLetter(letter))\n        {\n            char baseChar = char.IsUpper(letter) ? 'A' : 'a';\n            encodedChars[i] = (char)(((letter + shift - baseChar) % 26) + baseChar);\n        }\n        else\n        {\n            encodedChars[i] = letter;\n        }\n    }\n    return new string(encodedChars);\n}\n\nCung cấp mô tả ngắn gọn bằng ngôn ngữ tự nhiên (docstring) cho mã C# bằng tiếng Việt, không quá 500 ký tự."
    },
    "instruction_bertscore": {
      "es": "0.9702167647764858",
      "arb": "0.9134170169068923",
      "sw": "0.9446027812508938",
      "tr": "0.8954906250184936",
      "vi": "0.8888496168589731"
    },
    "level": "",
    "test": "    static void Main()\n    {\n        Debug.Assert(EncodeString(\"China\", 4) == \"Glmre\");\n        Debug.Assert(EncodeString(\"apple\", 2) == \"crrng\");\n        Debug.Assert(EncodeString(\"hello\", 5) == \"mjqqt\");\n        Debug.Assert(EncodeString(\"xyz\", 3) == \"abc\");\n        Debug.Assert(EncodeString(\"AbCdE\", 1) == \"BcDeF\");\n        Debug.Assert(EncodeString(\"Java\", 10) == \"Tkfk\");\n        Debug.Assert(EncodeString(\"OpenAI\", 4) == \"StirEM\");\n        Debug.Assert(EncodeString(\"\", 5) == \"\");\n\n    }\n}\n",
    "entry_point": "EncodeString",
    "signature": "static string EncodeString(string input, int shift)",
    "docstring": {
      "es": "Codifica la cadena dada desplazando cada letra un número especificado de lugares en el alfabeto. Si el desplazamiento lleva la letra más allá de 'z', se reinicia al comienzo del alfabeto.\n\n    Ejemplos:\n    >>> EncodeString(\"apple\", 2)\n    \"crrng\"\n    \n    >>> EncodeString(\"hello\", 5)\n    \"mjqqt\"",
      "arb": "يقوم بترميز السلسلة النصية المعطاة عن طريق تحريك كل حرف بعدد محدد من الأماكن في الأبجدية.\n    إذا أخذ التحريك الحرف إلى ما بعد 'z'، فإنه يلتف حول بداية الأبجدية.\n    \n    أمثلة:\n    >>> EncodeString(\"apple\", 2)\n    \"crrng\"\n    \n    >>> EncodeString(\"hello\", 5)\n    \"mjqqt\"",
      "sw": "Inasimba mfuatano uliotolewa kwa kusogeza kila herufi kwa idadi maalum ya nafasi katika alfabeti. Ikiwa mabadiliko yatampeleka herufi zaidi ya 'z', itarudi mwanzo wa alfabeti.\n\n    Mifano:\n    >>> EncodeString(\"apple\", 2)\n    \"crrng\"\n    \n    >>> EncodeString(\"hello\", 5)\n    \"mjqqt\"",
      "tr": "Verilen string'i, alfabede belirtilen sayıda yer kaydırarak şifreler. \n    Eğer kaydırma harfi 'z' harfinin ötesine taşırsa, alfabenin başına döner.\n    \n    Örnekler:\n    >>> EncodeString(\"apple\", 2)\n    \"crrng\"\n    \n    >>> EncodeString(\"hello\", 5)\n    \"mjqqt\"",
      "vi": "Mã hóa chuỗi được cung cấp bằng cách dịch chuyển mỗi chữ cái một số vị trí xác định trong bảng chữ cái. Nếu sự dịch chuyển đưa chữ cái vượt quá 'z', nó sẽ quay trở lại đầu bảng chữ cái.\n\n    Ví dụ:\n    >>> EncodeString(\"apple\", 2)\n    \"crrng\"\n    \n    >>> EncodeString(\"hello\", 5)\n    \"mjqqt\""
    },
    "docstring_bertscore": {
      "es": "0.9497884246085716",
      "arb": "0.9830073695328464",
      "sw": "0.9505885077833802",
      "tr": "0.9485634710487295",
      "vi": "0.9543442110279878"
    }
  },
  {
    "task_id": "C#/4",
    "prompt": {
      "es": "using System;\nusing System.Collections.Generic;\nusing System.Diagnostics;\n\nclass Program\n{\n/* Calcula un valor basado en la entrada x según funciones lineales especificadas.\n   La función aplica diferentes fórmulas basadas en el valor de x:\n   - Para x menor que 1, devuelve x.\n   - Para x entre 1 y 10, devuelve 2x - 1.\n   - Para x mayor o igual a 10, devuelve 3x - 11.\n   Casos de ejemplo:\n   >>> ComputeValue(0.5)\n   0.5\n   >>> ComputeValue(5)\n   9\n   >>> ComputeValue(10)\n   19\n*/\nstatic double ComputeValue(double x)",
      "arb": "using System;\nusing System.Collections.Generic;\nusing System.Diagnostics;\n\nclass Program\n{\n/* يحسب قيمة بناءً على المدخل x وفقًا لدوال خطية محددة.\n   تطبق الدالة صيغًا مختلفة بناءً على قيمة x:\n   - لـ x أقل من 1، تعيد x.\n   - لـ x بين 1 و 10، تعيد 2x - 1.\n   - لـ x أكبر من أو يساوي 10، تعيد 3x - 11.\n   حالات المثال:\n   >>> ComputeValue(0.5)\n   0.5\n   >>> ComputeValue(5)\n   9\n   >>> ComputeValue(10)\n   19\n*/\nstatic double ComputeValue(double x)",
      "sw": "using System;\nusing System.Collections.Generic;\nusing System.Diagnostics;\n\nclass Program\n{\n/* Inahesabu thamani kulingana na ingizo x kulingana na kazi za mstari zilizobainishwa.\n   Kazi hutumia kanuni tofauti kulingana na thamani ya x:\n   - Kwa x chini ya 1, inarudisha x.\n   - Kwa x kati ya 1 na 10, inarudisha 2x - 1.\n   - Kwa x kubwa au sawa na 10, inarudisha 3x - 11.\n   Mifano ya kesi:\n   >>> ComputeValue(0.5)\n   0.5\n   >>> ComputeValue(5)\n   9\n   >>> ComputeValue(10)\n   19\n*/\nstatic double ComputeValue(double x)",
      "tr": "using System;\nusing System.Collections.Generic;\nusing System.Diagnostics;\n\nclass Program\n{\n/* Girdi x'e göre belirtilen doğrusal fonksiyonlara göre bir değer hesaplar.\n   Fonksiyon, x'in değerine bağlı olarak farklı formüller uygular:\n   - x 1'den küçükse, x'i döndürür.\n   - x 1 ile 10 arasında ise, 2x - 1'i döndürür.\n   - x 10 veya daha büyükse, 3x - 11'i döndürür.\n   Örnek durumlar:\n   >>> ComputeValue(0.5)\n   0.5\n   >>> ComputeValue(5)\n   9\n   >>> ComputeValue(10)\n   19\n*/\nstatic double ComputeValue(double x)",
      "vi": "using System;\nusing System.Collections.Generic;\nusing System.Diagnostics;\n\nclass Program\n{\n/* Tính toán một giá trị dựa trên đầu vào x theo các hàm tuyến tính được chỉ định.\n   Hàm áp dụng các công thức khác nhau dựa trên giá trị của x:\n   - Đối với x nhỏ hơn 1, trả về x.\n   - Đối với x từ 1 đến 10, trả về 2x - 1.\n   - Đối với x lớn hơn hoặc bằng 10, trả về 3x - 11.\n   Các trường hợp ví dụ:\n   >>> ComputeValue(0.5)\n   0.5\n   >>> ComputeValue(5)\n   9\n   >>> ComputeValue(10)\n   19\n*/\nstatic double ComputeValue(double x)"
    },
    "prompt_bertscore": {
      "es": "0.9953905833777044",
      "arb": "0.9953905833777044",
      "sw": "0.9748462430672659",
      "tr": "0.9582898049168649",
      "vi": "0.9866540246982659"
    },
    "canonical_solution": "{\n    if (x < 1)\n    {\n        return x;\n    }\n    else if (x < 10)\n    {\n        return 2 * x - 1;\n    }\n    else\n    {\n        return 3 * x - 11;\n    }\n}",
    "instruction": {
      "es": "static double ComputeValue(double x)\n{\n    if (x < 1)\n    {\n        return x;\n    }\n    else if (x < 10)\n    {\n        return 2 * x - 1;\n    }\n    else\n    {\n        return 3 * x - 11;\n    }\n}\n\nProporcione una descripción concisa en lenguaje natural (docstring) del código C# en español utilizando un máximo de 500 caracteres.",
      "arb": "static double ComputeValue(double x)\n{\n    if (x < 1)\n    {\n        return x;\n    }\n    else if (x < 10)\n    {\n        return 2 * x - 1;\n    }\n    else\n    {\n        return 3 * x - 11;\n    }\n}\n\nقدم وصفًا موجزًا بلغة طبيعية (docstring) للكود المكتوب بلغة C# باللغة العربية الفصحى باستخدام 500 حرف كحد أقصى.",
      "sw": "static double ComputeValue(double x)\n{\n    if (x < 1)\n    {\n        return x;\n    }\n    else if (x < 10)\n    {\n        return 2 * x - 1;\n    }\n    else\n    {\n        return 3 * x - 11;\n    }\n}\n\nToa maelezo mafupi ya lugha asilia (docstring) ya msimbo wa C# kwa Kiswahili kwa kutumia herufi zisizozidi 500.",
      "tr": "static double ComputeValue(double x)\n{\n    if (x < 1)\n    {\n        return x;\n    }\n    else if (x < 10)\n    {\n        return 2 * x - 1;\n    }\n    else\n    {\n        return 3 * x - 11;\n    }\n}\n\nC# kodunun işlevselliğini açıklayan en fazla 500 karakterlik kısa bir doğal dil açıklaması (docstring) sağlayın.",
      "vi": "static double ComputeValue(double x)\n{\n    if (x < 1)\n    {\n        return x;\n    }\n    else if (x < 10)\n    {\n        return 2 * x - 1;\n    }\n    else\n    {\n        return 3 * x - 11;\n    }\n}\n\nCung cấp mô tả ngắn gọn bằng ngôn ngữ tự nhiên (docstring) cho mã C# bằng tiếng Việt với tối đa 500 ký tự."
    },
    "instruction_bertscore": {
      "es": "0.9702167647764858",
      "arb": "0.90332659355032",
      "sw": "0.9446027812508938",
      "tr": "0.8705730396088099",
      "vi": "0.9066002208601559"
    },
    "level": "",
    "test": "    static void Main()\n    {\n        Debug.Assert(ComputeValue(0.5) == 0.5);\n        Debug.Assert(ComputeValue(2) == 3);\n        Debug.Assert(ComputeValue(5) == 9);\n        Debug.Assert(ComputeValue(10) == 19);\n        Debug.Assert(ComputeValue(15) == 34);\n        Debug.Assert(ComputeValue(0) == 0);\n        Debug.Assert(ComputeValue(1) == 1);\n\n    }\n}",
    "entry_point": "ComputeValue",
    "signature": "static double ComputeValue(double x)",
    "docstring": {
      "es": "Calcula un valor basado en la entrada x según funciones lineales especificadas.\n   La función aplica diferentes fórmulas basadas en el valor de x:\n   - Para x menor que 1, devuelve x.\n   - Para x entre 1 y 10, devuelve 2x - 1.\n   - Para x mayor o igual a 10, devuelve 3x - 11.\n   Casos de ejemplo:\n   >>> ComputeValue(0.5)\n   0.5\n   >>> ComputeValue(5)\n   9\n   >>> ComputeValue(10)\n   19",
      "arb": "يحسب قيمة بناءً على المدخل x وفقًا لدوال خطية محددة.\n   تطبق الدالة صيغًا مختلفة بناءً على قيمة x:\n   - إذا كانت x أقل من 1، تُرجع x.\n   - إذا كانت x بين 1 و 10، تُرجع 2x - 1.\n   - إذا كانت x أكبر من أو تساوي 10، تُرجع 3x - 11.\n   حالات المثال:\n   >>> ComputeValue(0.5)\n   0.5\n   >>> ComputeValue(5)\n   9\n   >>> ComputeValue(10)\n   19",
      "sw": "Hesabu thamani kulingana na x iliyoingizwa kulingana na kazi za mstari maalum.\n   Kazi hutumia fomula tofauti kulingana na thamani ya x:\n   - Kwa x chini ya 1, inarudisha x.\n   - Kwa x kati ya 1 na 10, inarudisha 2x - 1.\n   - Kwa x kubwa au sawa na 10, inarudisha 3x - 11.\n   Mifano ya kesi:\n   >>> ComputeValue(0.5)\n   0.5\n   >>> ComputeValue(5)\n   9\n   >>> ComputeValue(10)\n   19",
      "tr": "Girdi x'e göre belirtilen doğrusal fonksiyonlara göre bir değer hesaplar.\n   Fonksiyon, x'in değerine göre farklı formüller uygular:\n   - x 1'den küçükse, x'i döndürür.\n   - x 1 ile 10 arasında ise, 2x - 1'i döndürür.\n   - x 10'a eşit veya büyükse, 3x - 11'i döndürür.\n   Örnek durumlar:\n   >>> ComputeValue(0.5)\n   0.5\n   >>> ComputeValue(5)\n   9\n   >>> ComputeValue(10)\n   19",
      "vi": "Tính toán một giá trị dựa trên đầu vào x theo các hàm tuyến tính được chỉ định.\n   Hàm áp dụng các công thức khác nhau dựa trên giá trị của x:\n   - Với x nhỏ hơn 1, trả về x.\n   - Với x trong khoảng từ 1 đến 10, trả về 2x - 1.\n   - Với x lớn hơn hoặc bằng 10, trả về 3x - 11.\n   Các trường hợp ví dụ:\n   >>> ComputeValue(0.5)\n   0.5\n   >>> ComputeValue(5)\n   9\n   >>> ComputeValue(10)\n   19"
    },
    "docstring_bertscore": {
      "es": "0.9910669958737179",
      "arb": "0.9613073976655468",
      "sw": "0.9664266984759591",
      "tr": "0.9441665889341412",
      "vi": "0.9731886725375297"
    }
  },
  {
    "task_id": "C#/5",
    "prompt": {
      "es": "using System;\nusing System.Collections.Generic;\nusing System.Diagnostics;\n\nclass Program\n{\n/* Esta función encuentra todos los números narcisistas dentro de un rango dado.\n   Un número narcisista es un número que es la suma de sus propios dígitos, cada uno elevado a la potencia del número de dígitos.\n   Por ejemplo, 153 es un número narcisista porque 153 = 1^3 + 5^3 + 3^3.\n   \n   Ejemplos:\n   >>> FindNarcissisticNumbers(100, 170)\n   [153]\n   >>> FindNarcissisticNumbers(100, 500)\n   [153, 370, 371, 407]\n*/\n   static List<int> FindNarcissisticNumbers(int start, int end)",
      "arb": "using System;\nusing System.Collections.Generic;\nusing System.Diagnostics;\n\nclass Program\n{\n/* هذه الدالة تجد جميع الأعداد النرجسية ضمن نطاق معين.\n   العدد النرجسي هو عدد يساوي مجموع أرقامه كل مرفوع إلى قوة عدد الأرقام.\n   على سبيل المثال، 153 هو عدد نرجسي لأن 153 = 1^3 + 5^3 + 3^3.\n   \n   أمثلة:\n   >>> FindNarcissisticNumbers(100, 170)\n   [153]\n   >>> FindNarcissisticNumbers(100, 500)\n   [153, 370, 371, 407]\n*/\n   static List<int> FindNarcissisticNumbers(int start, int end)",
      "sw": "using System;\nusing System.Collections.Generic;\nusing System.Diagnostics;\n\nclass Program\n{\n/* Kazi ya hii function ni kutafuta namba zote za narcissistic ndani ya wigo uliotolewa.\n   Namba ya narcissistic ni namba ambayo ni jumla ya tarakimu zake yenyewe kila moja ikiwa imeinuliwa kwa nguvu ya idadi ya tarakimu.\n   Kwa mfano, 153 ni namba ya narcissistic kwa sababu 153 = 1^3 + 5^3 + 3^3.\n   \n   Mifano:\n   >>> FindNarcissisticNumbers(100, 170)\n   [153]\n   >>> FindNarcissisticNumbers(100, 500)\n   [153, 370, 371, 407]\n*/\n   static List<int> FindNarcissisticNumbers(int start, int end)",
      "tr": "using System;\nusing System.Collections.Generic;\nusing System.Diagnostics;\n\nclass Program\n{\n/* Bu fonksiyon, verilen bir aralık içindeki tüm narsistik sayıları bulur.\n   Narsistik bir sayı, kendi basamaklarının her birinin basamak sayısı kadar üssü alınarak toplanmasıyla elde edilen sayıdır.\n   Örneğin, 153 bir narsistik sayıdır çünkü 153 = 1^3 + 5^3 + 3^3.\n   \n   Örnekler:\n   >>> FindNarcissisticNumbers(100, 170)\n   [153]\n   >>> FindNarcissisticNumbers(100, 500)\n   [153, 370, 371, 407]\n*/\n   static List<int> FindNarcissisticNumbers(int start, int end)",
      "vi": "using System;\nusing System.Collections.Generic;\nusing System.Diagnostics;\n\nclass Program\n{\n/* Hàm này tìm tất cả các số narcissistic trong một phạm vi cho trước.\n   Một số narcissistic là một số mà là tổng của các chữ số của chính nó, mỗi chữ số được nâng lên lũy thừa của số chữ số.\n   Ví dụ, 153 là một số narcissistic vì 153 = 1^3 + 5^3 + 3^3.\n   \n   Ví dụ:\n   >>> FindNarcissisticNumbers(100, 170)\n   [153]\n   >>> FindNarcissisticNumbers(100, 500)\n   [153, 370, 371, 407]\n*/\n   static List<int> FindNarcissisticNumbers(int start, int end)"
    },
    "prompt_bertscore": {
      "es": "0.9962790570720734",
      "arb": "0.9854914410780686",
      "sw": "0.9783788843939714",
      "tr": "1",
      "vi": "0.9953953505068492"
    },
    "canonical_solution": "{\n    List<int> narcissisticNumbers = new List<int>();\n    for (int i = start; i <= end; i++)\n    {\n        if (i < 100) continue;\n        int sum = 0;\n        int number = i;\n        int digits = (int)Math.Floor(Math.Log10(i) + 1);\n        while (number > 0)\n        {\n            int digit = number % 10;\n            sum += (int)Math.Pow(digit, 3);\n            number /= 10;\n        }\n        if (sum == i)\n        {\n            narcissisticNumbers.Add(i);\n        }\n    }\n    return narcissisticNumbers;\n}",
    "instruction": {
      "es": "static List<int> FindNarcissisticNumbers(int start, int end)\n{\n    List<int> narcissisticNumbers = new List<int>();\n    for (int i = start; i <= end; i++)\n    {\n        if (i < 100) continue;\n        int sum = 0;\n        int number = i;\n        int digits = (int)Math.Floor(Math.Log10(i) + 1);\n        while (number > 0)\n        {\n            int digit = number % 10;\n            sum += (int)Math.Pow(digit, 3);\n            number /= 10;\n        }\n        if (sum == i)\n        {\n            narcissisticNumbers.Add(i);\n        }\n    }\n    return narcissisticNumbers;\n}\n\nProporcione una descripción concisa en lenguaje natural (docstring) del código C# en español utilizando como máximo 500 caracteres.",
      "arb": "static List<int> FindNarcissisticNumbers(int start, int end)\n{\n    List<int> narcissisticNumbers = new List<int>();\n    for (int i = start; i <= end; i++)\n    {\n        if (i < 100) continue;\n        int sum = 0;\n        int number = i;\n        int digits = (int)Math.Floor(Math.Log10(i) + 1);\n        while (number > 0)\n        {\n            int digit = number % 10;\n            sum += (int)Math.Pow(digit, 3);\n            number /= 10;\n        }\n        if (sum == i)\n        {\n            narcissisticNumbers.Add(i);\n        }\n    }\n    return narcissisticNumbers;\n}\n\nقدم وصفًا موجزًا بلغة طبيعية (docstring) للكود المكتوب بلغة C# باللغة العربية الفصحى باستخدام 500 حرف كحد أقصى.",
      "sw": "static List<int> FindNarcissisticNumbers(int start, int end)\n{\n    List<int> narcissisticNumbers = new List<int>();\n    for (int i = start; i <= end; i++)\n    {\n        if (i < 100) continue;\n        int sum = 0;\n        int number = i;\n        int digits = (int)Math.Floor(Math.Log10(i) + 1);\n        while (number > 0)\n        {\n            int digit = number % 10;\n            sum += (int)Math.Pow(digit, 3);\n            number /= 10;\n        }\n        if (sum == i)\n        {\n            narcissisticNumbers.Add(i);\n        }\n    }\n    return narcissisticNumbers;\n}\n\nToa maelezo mafupi ya lugha asilia (docstring) ya msimbo wa C# kwa Kiswahili kwa kutumia herufi zisizozidi 500.",
      "tr": "static List<int> FindNarcissisticNumbers(int start, int end)\n{\n    List<int> narcissisticNumbers = new List<int>();\n    for (int i = start; i <= end; i++)\n    {\n        if (i < 100) continue;\n        int sum = 0;\n        int number = i;\n        int digits = (int)Math.Floor(Math.Log10(i) + 1);\n        while (number > 0)\n        {\n            int digit = number % 10;\n            sum += (int)Math.Pow(digit, 3);\n            number /= 10;\n        }\n        if (sum == i)\n        {\n            narcissisticNumbers.Add(i);\n        }\n    }\n    return narcissisticNumbers;\n}\n\nAşağıdaki C# kodunun Türkçe olarak en fazla 500 karakterle doğal dilde kısa bir açıklamasını (docstring) sağlayın.",
      "vi": "static List<int> FindNarcissisticNumbers(int start, int end)\n{\n    List<int> narcissisticNumbers = new List<int>();\n    for (int i = start; i <= end; i++)\n    {\n        if (i < 100) continue;\n        int sum = 0;\n        int number = i;\n        int digits = (int)Math.Floor(Math.Log10(i) + 1);\n        while (number > 0)\n        {\n            int digit = number % 10;\n            sum += (int)Math.Pow(digit, 3);\n            number /= 10;\n        }\n        if (sum == i)\n        {\n            narcissisticNumbers.Add(i);\n        }\n    }\n    return narcissisticNumbers;\n}\n\nCung cấp mô tả ngắn gọn bằng ngôn ngữ tự nhiên (docstring) cho mã C# bằng tiếng Việt, không quá 500 ký tự."
    },
    "instruction_bertscore": {
      "es": "0.9702167647764858",
      "arb": "0.90332659355032",
      "sw": "0.9446027812508938",
      "tr": "0.862346365117488",
      "vi": "0.9187315713818617"
    },
    "level": "",
    "test": "    static void Main()\n    {\n \n        Debug.Assert(FindNarcissisticNumbers(100, 170).SequenceEqual(new List<int> { 153 }));\n        Debug.Assert(FindNarcissisticNumbers(100, 500).SequenceEqual(new List<int> { 153, 370, 371, 407 }));\n        Debug.Assert(FindNarcissisticNumbers(1, 100).SequenceEqual(new List<int> { }));\n        Debug.Assert(FindNarcissisticNumbers(370, 380).SequenceEqual(new List<int> { 370, 371 }));\n        Debug.Assert(FindNarcissisticNumbers(0, 999).SequenceEqual(new List<int> { 153, 370, 371, 407 }));\n        Debug.Assert(FindNarcissisticNumbers(900, 1000).SequenceEqual(new List<int> { }));\n        Debug.Assert(FindNarcissisticNumbers(10, 15).SequenceEqual(new List<int> { }));\n\n    }\n}",
    "entry_point": "FindNarcissisticNumbers",
    "signature": "static List<int> FindNarcissisticNumbers(int start, int end)",
    "docstring": {
      "es": "Esta función encuentra todos los números narcisistas dentro de un rango dado.  \nUn número narcisista es un número que es la suma de sus propios dígitos, cada uno elevado a la potencia del número de dígitos.  \nPor ejemplo, 153 es un número narcisista porque 153 = 1^3 + 5^3 + 3^3.\n   \nEjemplos:\n>>> FindNarcissisticNumbers(100, 170)\n[153]\n>>> FindNarcissisticNumbers(100, 500)\n[153, 370, 371, 407]",
      "arb": "هذه الدالة تجد جميع الأعداد النرجسية ضمن نطاق معين.  \n   الرقم النرجسي هو رقم يساوي مجموع أرقامه كل منها مرفوع إلى قوة عدد الأرقام.  \n   على سبيل المثال، 153 هو رقم نرجسي لأن 153 = 1^3 + 5^3 + 3^3.  \n   \n   أمثلة:\n   >>> FindNarcissisticNumbers(100, 170)\n   [153]\n   >>> FindNarcissisticNumbers(100, 500)\n   [153, 370, 371, 407]",
      "sw": "Kazi ya hii function ni kutafuta namba zote za narcissistic ndani ya wigo uliotolewa.\n   Nambari ya narcissistic ni nambari ambayo ni jumla ya tarakimu zake yenyewe kila moja ikiwa imeinuliwa kwa nguvu ya idadi ya tarakimu.\n   Kwa mfano, 153 ni nambari ya narcissistic kwa sababu 153 = 1^3 + 5^3 + 3^3.\n   \n   Mifano:\n   >>> FindNarcissisticNumbers(100, 170)\n   [153]\n   >>> FindNarcissisticNumbers(100, 500)\n   [153, 370, 371, 407]",
      "tr": "Bu fonksiyon, belirtilen aralıktaki tüm narsistik sayıları bulur.\n   Narsistik bir sayı, kendi basamaklarının her birinin, basamak sayısı kadar üssü alınarak toplamına eşit olan bir sayıdır.\n   Örneğin, 153 bir narsistik sayıdır çünkü 153 = 1^3 + 5^3 + 3^3.\n   \n   Örnekler:\n   >>> FindNarcissisticNumbers(100, 170)\n   [153]\n   >>> FindNarcissisticNumbers(100, 500)\n   [153, 370, 371, 407]",
      "vi": "Hàm này tìm tất cả các số narcissistic trong một phạm vi cho trước.  \nMột số narcissistic là một số mà tổng của các chữ số của nó mỗi chữ số được nâng lên lũy thừa của số chữ số.  \nVí dụ, 153 là một số narcissistic vì 153 = 1^3 + 5^3 + 3^3.\n   \nVí dụ:\n>>> FindNarcissisticNumbers(100, 170)\n[153]\n>>> FindNarcissisticNumbers(100, 500)\n[153, 370, 371, 407]"
    },
    "docstring_bertscore": {
      "es": "0.9900321315885262",
      "arb": "0.9856845098084346",
      "sw": "0.9985730393426454",
      "tr": "0.9780437949411656",
      "vi": "0.6934128150903639"
    }
  },
  {
    "task_id": "C#/6",
    "prompt": {
      "es": "using System;\nusing System.Collections.Generic;\nusing System.Diagnostics;\n\nclass Program\n{\n/* Ordena tres enteros dados en orden ascendente y devuelve la lista ordenada.\n    Ejemplo de uso:\n    >>> SortIntegersAscending(3, 1, 2)\n    [1, 2, 3]\n    >>> SortIntegersAscending(5, 7, 2)\n    [2, 5, 7]\n    >>> SortIntegersAscending(-1, 0, -3)\n    [-3, -1, 0]\n*/\nstatic List<int> SortIntegersAscending(int num1, int num2, int num3)",
      "arb": "using System;\nusing System.Collections.Generic;\nusing System.Diagnostics;\n\nclass Program\n{\n/* يقوم بترتيب ثلاثة أعداد صحيحة معطاة بترتيب تصاعدي ويعيد القائمة المرتبة.\n    مثال على الاستخدام:\n    >>> SortIntegersAscending(3, 1, 2)\n    [1, 2, 3]\n    >>> SortIntegersAscending(5, 7, 2)\n    [2, 5, 7]\n    >>> SortIntegersAscending(-1, 0, -3)\n    [-3, -1, 0]\n*/\nstatic List<int> SortIntegersAscending(int num1, int num2, int num3)",
      "sw": "using System;\nusing System.Collections.Generic;\nusing System.Diagnostics;\n\nclass Program\n{\n/* Hupanga nambari tatu zilizotolewa kwa mpangilio wa kupanda na kurudisha orodha iliyopangwa.\n    Mfano wa matumizi:\n    >>> SortIntegersAscending(3, 1, 2)\n    [1, 2, 3]\n    >>> SortIntegersAscending(5, 7, 2)\n    [2, 5, 7]\n    >>> SortIntegersAscending(-1, 0, -3)\n    [-3, -1, 0]\n*/\nstatic List<int> SortIntegersAscending(int num1, int num2, int num3)",
      "tr": "using System;\nusing System.Collections.Generic;\nusing System.Diagnostics;\n\nclass Program\n{\n/* Üç verilen tam sayıyı artan sırayla sıralar ve sıralı listeyi döndürür.\n    Örnek kullanım:\n    >>> SortIntegersAscending(3, 1, 2)\n    [1, 2, 3]\n    >>> SortIntegersAscending(5, 7, 2)\n    [2, 5, 7]\n    >>> SortIntegersAscending(-1, 0, -3)\n    [-3, -1, 0]\n*/\nstatic List<int> SortIntegersAscending(int num1, int num2, int num3)",
      "vi": "using System;\nusing System.Collections.Generic;\nusing System.Diagnostics;\n\nclass Program\n{\n/* Sắp xếp ba số nguyên đã cho theo thứ tự tăng dần và trả về danh sách đã sắp xếp.\n    Ví dụ sử dụng:\n    >>> SortIntegersAscending(3, 1, 2)\n    [1, 2, 3]\n    >>> SortIntegersAscending(5, 7, 2)\n    [2, 5, 7]\n    >>> SortIntegersAscending(-1, 0, -3)\n    [-3, -1, 0]\n*/\nstatic List<int> SortIntegersAscending(int num1, int num2, int num3)"
    },
    "prompt_bertscore": {
      "es": "0.998001579736408",
      "arb": "1",
      "sw": "0.9848854197855312",
      "tr": "1",
      "vi": "0.9937357936733028"
    },
    "canonical_solution": "{\n    List<int> numbers = new List<int> { num1, num2, num3 };\n    numbers.Sort();\n    return numbers;\n}",
    "instruction": {
      "es": "static List<int> SortIntegersAscending(int num1, int num2, int num3)\n{\n    List<int> numbers = new List<int> { num1, num2, num3 };\n    numbers.Sort();\n    return numbers;\n}\n\nProporcione una descripción concisa en lenguaje natural (docstring) del código C# en español usando un máximo de 500 caracteres.",
      "arb": "static List<int> SortIntegersAscending(int num1, int num2, int num3)\n{\n    List<int> numbers = new List<int> { num1, num2, num3 };\n    numbers.Sort();\n    return numbers;\n}\n\nقدم وصفًا موجزًا بلغة طبيعية (docstring) لكود C# باللغة العربية الفصحى باستخدام 500 حرف كحد أقصى.",
      "sw": "static List<int> SortIntegersAscending(int num1, int num2, int num3)\n{\n    List<int> numbers = new List<int> { num1, num2, num3 };\n    numbers.Sort();\n    return numbers;\n}\n\nToa maelezo mafupi ya lugha ya asili (docstring) ya msimbo wa C# kwa Kiswahili kwa kutumia herufi zisizozidi 500.",
      "tr": "static List<int> SortIntegersAscending(int num1, int num2, int num3)\n{\n    List<int> numbers = new List<int> { num1, num2, num3 };\n    numbers.Sort();\n    return numbers;\n}\n\nC# kodunun Türkçe açıklamasını (docstring) en fazla 500 karakter kullanarak sağlayın.",
      "vi": "static List<int> SortIntegersAscending(int num1, int num2, int num3)\n{\n    List<int> numbers = new List<int> { num1, num2, num3 };\n    numbers.Sort();\n    return numbers;\n}\n\nCung cấp mô tả ngắn gọn bằng ngôn ngữ tự nhiên (docstring) cho mã C# bằng tiếng Việt với tối đa 500 ký tự."
    },
    "instruction_bertscore": {
      "es": "0.9702167647764858",
      "arb": "0.9189595990592898",
      "sw": "0.918288824262535",
      "tr": "0.8742941811671175",
      "vi": "0.9399717139170654"
    },
    "level": "",
    "test": "    static void Main()\n    {\n        Debug.Assert(SortIntegersAscending(3, 1, 2).SequenceEqual(new List<int> { 1, 2, 3 }));\n        Debug.Assert(SortIntegersAscending(5, 7, 2).SequenceEqual(new List<int> { 2, 5, 7 }));\n        Debug.Assert(SortIntegersAscending(-1, 0, -3).SequenceEqual(new List<int> { -3, -1, 0 }));\n        Debug.Assert(SortIntegersAscending(10, 10, 10).SequenceEqual(new List<int> { 10, 10, 10 }));\n        Debug.Assert(SortIntegersAscending(0, -1, 1).SequenceEqual(new List<int> { -1, 0, 1 }));\n        Debug.Assert(SortIntegersAscending(100, 50, 75).SequenceEqual(new List<int> { 50, 75, 100 }));\n        Debug.Assert(SortIntegersAscending(-5, -10, -7).SequenceEqual(new List<int> { -10, -7, -5 }));\n\n\n    }\n}",
    "entry_point": "SortIntegersAscending",
    "signature": "static List<int> SortIntegersAscending(int num1, int num2, int num3)",
    "docstring": {
      "es": "Ordena tres enteros dados en orden ascendente y devuelve la lista ordenada.\n    Ejemplo de uso:\n    >>> SortIntegersAscending(3, 1, 2)\n    [1, 2, 3]\n    >>> SortIntegersAscending(5, 7, 2)\n    [2, 5, 7]\n    >>> SortIntegersAscending(-1, 0, -3)\n    [-3, -1, 0]",
      "arb": "يرتب ثلاثة أعداد صحيحة معطاة بترتيب تصاعدي ويعيد القائمة المرتبة.\n    مثال على الاستخدام:\n    >>> SortIntegersAscending(3, 1, 2)\n    [1, 2, 3]\n    >>> SortIntegersAscending(5, 7, 2)\n    [2, 5, 7]\n    >>> SortIntegersAscending(-1, 0, -3)\n    [-3, -1, 0]",
      "sw": "Hupanga nambari tatu zilizotolewa kwa mpangilio wa kupanda na kurudisha orodha iliyopangwa.\n    Mfano wa matumizi:\n    >>> SortIntegersAscending(3, 1, 2)\n    [1, 2, 3]\n    >>> SortIntegersAscending(5, 7, 2)\n    [2, 5, 7]\n    >>> SortIntegersAscending(-1, 0, -3)\n    [-3, -1, 0]",
      "tr": "Üç verilen tam sayıyı artan sırayla sıralar ve sıralı listeyi döndürür.\n    Örnek kullanım:\n    >>> SortIntegersAscending(3, 1, 2)\n    [1, 2, 3]\n    >>> SortIntegersAscending(5, 7, 2)\n    [2, 5, 7]\n    >>> SortIntegersAscending(-1, 0, -3)\n    [-3, -1, 0]",
      "vi": "Sắp xếp ba số nguyên được cung cấp theo thứ tự tăng dần và trả về danh sách đã sắp xếp.\n    Ví dụ sử dụng:\n    >>> SortIntegersAscending(3, 1, 2)\n    [1, 2, 3]\n    >>> SortIntegersAscending(5, 7, 2)\n    [2, 5, 7]\n    >>> SortIntegersAscending(-1, 0, -3)\n    [-3, -1, 0]"
    },
    "docstring_bertscore": {
      "es": "0.9883852870993659",
      "arb": "0.993686334708425",
      "sw": "0.9752017914493184",
      "tr": "1",
      "vi": "0.9886742943037717"
    }
  },
  {
    "task_id": "C#/7",
    "prompt": {
      "es": "using System;\nusing System.Collections.Generic;\nusing System.Diagnostics;\n\nclass Program\n{\n/* Copia una subcadena desde el índice de inicio especificado en la cadena de entrada hasta el final de la cadena.\n   Si el índice de inicio es mayor que la longitud de la cadena, devuelve una cadena vacía.\n   Ejemplos:\n   >>> CopySubstringFromIndex(\"Hello World\", 6)\n   \"World\"\n   >>> CopySubstringFromIndex(\"Example\", 3)\n   \"mple\"\n   >>> CopySubstringFromIndex(\"Short\", 10)\n   \"\"\n*/   \n   static string CopySubstringFromIndex(string input, int startIndex)",
      "arb": "using System;\nusing System.Collections.Generic;\nusing System.Diagnostics;\n\nclass Program\n{\n/* ينسخ جزءًا من السلسلة النصية من الفهرس المحدد في بداية السلسلة إلى نهاية السلسلة.\n   إذا كان الفهرس المبدئي أكبر من طول السلسلة، فإنه يعيد سلسلة فارغة.\n   أمثلة:\n   >>> CopySubstringFromIndex(\"Hello World\", 6)\n   \"World\"\n   >>> CopySubstringFromIndex(\"Example\", 3)\n   \"mple\"\n   >>> CopySubstringFromIndex(\"Short\", 10)\n   \"\"\n*/   \n   static string CopySubstringFromIndex(string input, int startIndex)",
      "sw": "using System;\nusing System.Collections.Generic;\nusing System.Diagnostics;\n\nclass Program\n{\n/* Nakili sehemu ndogo kutoka kwa nafasi ya kuanzia iliyobainishwa katika kamba ya ingizo hadi mwisho wa kamba.\n   Ikiwa nafasi ya kuanzia ni kubwa kuliko urefu wa kamba, inarudisha kamba tupu.\n   Mifano:\n   >>> CopySubstringFromIndex(\"Hello World\", 6)\n   \"World\"\n   >>> CopySubstringFromIndex(\"Example\", 3)\n   \"mple\"\n   >>> CopySubstringFromIndex(\"Short\", 10)\n   \"\"\n*/   \n   static string CopySubstringFromIndex(string input, int startIndex)",
      "tr": "using System;\nusing System.Collections.Generic;\nusing System.Diagnostics;\n\nclass Program\n{\n/* Belirtilen başlangıç indeksinden itibaren giriş dizisinin sonuna kadar olan alt diziyi kopyalar.\n   Başlangıç indeksi dizinin uzunluğundan büyükse, boş bir dize döndürür.\n   Örnekler:\n   >>> CopySubstringFromIndex(\"Hello World\", 6)\n   \"World\"\n   >>> CopySubstringFromIndex(\"Example\", 3)\n   \"mple\"\n   >>> CopySubstringFromIndex(\"Short\", 10)\n   \"\"\n*/   \n   static string CopySubstringFromIndex(string input, int startIndex)",
      "vi": "using System;\nusing System.Collections.Generic;\nusing System.Diagnostics;\n\nclass Program\n{\n/* Sao chép một chuỗi con từ chỉ số bắt đầu được chỉ định trong chuỗi đầu vào đến cuối chuỗi.\n   Nếu chỉ số bắt đầu lớn hơn độ dài của chuỗi, trả về một chuỗi rỗng.\n   Ví dụ:\n   >>> CopySubstringFromIndex(\"Hello World\", 6)\n   \"World\"\n   >>> CopySubstringFromIndex(\"Example\", 3)\n   \"mple\"\n   >>> CopySubstringFromIndex(\"Short\", 10)\n   \"\"\n*/   \n   static string CopySubstringFromIndex(string input, int startIndex)"
    },
    "prompt_bertscore": {
      "es": "0.9856815303527191",
      "arb": "0.9668430277546082",
      "sw": "0.9711481426331584",
      "tr": "0.9819734983995597",
      "vi": "0.9862365036373305"
    },
    "canonical_solution": "{\n    if (startIndex >= input.Length)\n    {\n        return \"\";\n    }\n    return input.Substring(startIndex);\n}",
    "instruction": {
      "es": "static string CopySubstringFromIndex(string input, int startIndex)\n{\n    if (startIndex >= input.Length)\n    {\n        return \"\";\n    }\n    return input.Substring(startIndex);\n}\n\nProporcione una descripción concisa en lenguaje natural (docstring) del código C# en español usando como máximo 500 caracteres.",
      "arb": "static string CopySubstringFromIndex(string input, int startIndex)\n{\n    if (startIndex >= input.Length)\n    {\n        return \"\";\n    }\n    return input.Substring(startIndex);\n}\n\nقدم وصفًا موجزًا بلغة طبيعية (docstring) للكود المكتوب بلغة C# باللغة العربية الفصحى باستخدام 500 حرف كحد أقصى.",
      "sw": "static string CopySubstringFromIndex(string input, int startIndex)\n{\n    if (startIndex >= input.Length)\n    {\n        return \"\";\n    }\n    return input.Substring(startIndex);\n}\n\nToa maelezo mafupi ya lugha asilia (docstring) ya msimbo wa C# kwa Kiswahili kwa kutumia herufi zisizozidi 500.",
      "tr": "static string CopySubstringFromIndex(string input, int startIndex)\n{\n    if (startIndex >= input.Length)\n    {\n        return \"\";\n    }\n    return input.Substring(startIndex);\n}\n\nAşağıdaki C# kodunun işlevini açıklayan, en fazla 500 karakter uzunluğunda, özlü bir doğal dil tanımı (docstring) sağlayın.",
      "vi": "static string CopySubstringFromIndex(string input, int startIndex)\n{\n    if (startIndex >= input.Length)\n    {\n        return \"\";\n    }\n    return input.Substring(startIndex);\n}\n\nCung cấp mô tả ngắn gọn bằng ngôn ngữ tự nhiên (docstring) cho mã C# bằng tiếng Việt với tối đa 500 ký tự."
    },
    "instruction_bertscore": {
      "es": "0.9702167647764858",
      "arb": "0.915670279949352",
      "sw": "0.9446027812508938",
      "tr": "0.8599965677098452",
      "vi": "0.9066002208601559"
    },
    "level": "",
    "test": "static void Main()\n    {\n        Debug.Assert(CopySubstringFromIndex(\"Hello World\", 6) == \"World\");\n        Debug.Assert(CopySubstringFromIndex(\"Example\", 3) == \"mple\");\n        Debug.Assert(CopySubstringFromIndex(\"Short\", 10) == \"\");\n        Debug.Assert(CopySubstringFromIndex(\"AnotherExample\", 0) == \"AnotherExample\");\n        Debug.Assert(CopySubstringFromIndex(\"Test\", 4) == \"\");\n        Debug.Assert(CopySubstringFromIndex(\"\", 0) == \"\");\n        Debug.Assert(CopySubstringFromIndex(\"LastOne\", 7) == \"\");\n\n    }\n}",
    "entry_point": "CopySubstringFromIndex",
    "signature": "static string CopySubstringFromIndex(string input, int startIndex)",
    "docstring": {
      "es": "Copia una subcadena desde el índice de inicio especificado en la cadena de entrada hasta el final de la cadena.\n   Si el índice de inicio es mayor que la longitud de la cadena, devuelve una cadena vacía.\n   Ejemplos:\n   >>> CopySubstringFromIndex(\"Hello World\", 6)\n   \"World\"\n   >>> CopySubstringFromIndex(\"Example\", 3)\n   \"mple\"\n   >>> CopySubstringFromIndex(\"Short\", 10)\n   \"\"",
      "arb": "ينسخ جزءًا من السلسلة النصية بدءًا من الفهرس المحدد في السلسلة النصية المدخلة إلى نهاية السلسلة.\n   إذا كان الفهرس المبدئي أكبر من طول السلسلة النصية، فإنه يعيد سلسلة نصية فارغة.\n   أمثلة:\n   >>> CopySubstringFromIndex(\"Hello World\", 6)\n   \"World\"\n   >>> CopySubstringFromIndex(\"Example\", 3)\n   \"mple\"\n   >>> CopySubstringFromIndex(\"Short\", 10)\n   \"\"",
      "sw": "Nakala ndogo kutoka kwa kiashiria cha mwanzo kilichobainishwa katika kamba ya kuingiza hadi mwisho wa kamba.\n   Ikiwa kiashiria cha mwanzo ni kikubwa kuliko urefu wa kamba, inarudisha kamba tupu.\n   Mifano:\n   >>> CopySubstringFromIndex(\"Hello World\", 6)\n   \"World\"\n   >>> CopySubstringFromIndex(\"Example\", 3)\n   \"mple\"\n   >>> CopySubstringFromIndex(\"Short\", 10)\n   \"\"",
      "tr": "Belirtilen başlangıç indeksinden itibaren giriş dizesinin sonuna kadar bir alt dize kopyalar.\n   Başlangıç indeksi dizenin uzunluğundan büyükse, boş bir dize döndürür.\n   Örnekler:\n   >>> CopySubstringFromIndex(\"Hello World\", 6)\n   \"World\"\n   >>> CopySubstringFromIndex(\"Example\", 3)\n   \"mple\"\n   >>> CopySubstringFromIndex(\"Short\", 10)\n   \"\"",
      "vi": "Sao chép một chuỗi con từ chỉ số bắt đầu được chỉ định trong chuỗi đầu vào đến cuối chuỗi. \nNếu chỉ số bắt đầu lớn hơn độ dài của chuỗi, trả về một chuỗi rỗng. \nVí dụ:\n>>> CopySubstringFromIndex(\"Hello World\", 6)\n\"World\"\n>>> CopySubstringFromIndex(\"Example\", 3)\n\"mple\"\n>>> CopySubstringFromIndex(\"Short\", 10)\n\"\""
    },
    "docstring_bertscore": {
      "es": "0.9865282916670708",
      "arb": "0.9530811204349869",
      "sw": "0.975951621137725",
      "tr": "0.9832260615823658",
      "vi": "0.9845398029225305"
    }
  },
  {
    "task_id": "C#/8",
    "prompt": {
      "es": "using System;\nusing System.Collections.Generic;\nusing System.Diagnostics;\n\nclass Program\n{\n/* Convierte un número dado de segundos en una cadena de tiempo formateada sin ceros a la izquierda.\n    El formato de la salida es \"<Horas>:<Minutos>:<Segundos>\". Cada componente es un entero sin ceros a la izquierda.\n    Ejemplos:\n    >>> FormatTime(0)\n    \"0:0:0\"\n    >>> FormatTime(3661)\n    \"1:1:1\"\n    >>> FormatTime(5436)\n    \"1:30:36\"\n*/\n   static string FormatTime(int seconds)",
      "arb": "using System;\nusing System.Collections.Generic;\nusing System.Diagnostics;\n\nclass Program\n{\n/* يحول عدد معين من الثواني إلى سلسلة زمنية منسقة بدون أصفار بادئة.\n    صيغة الإخراج هي \"<ساعات>:<دقائق>:<ثواني>\". كل مكون هو عدد صحيح بدون أصفار بادئة.\n    أمثلة:\n    >>> FormatTime(0)\n    \"0:0:0\"\n    >>> FormatTime(3661)\n    \"1:1:1\"\n    >>> FormatTime(5436)\n    \"1:30:36\"\n*/\n   static string FormatTime(int seconds)",
      "sw": "using System;\nusing System.Collections.Generic;\nusing System.Diagnostics;\n\nclass Program\n{\n/* Hubadilisha idadi fulani ya sekunde kuwa kamba ya muda iliyopangwa bila sifuri zinazoongoza.\n    Muundo wa matokeo ni \"<Saa>:<Dakika>:<Sekunde>\". Kila sehemu ni nambari bila sifuri zinazoongoza.\n    Mifano:\n    >>> FormatTime(0)\n    \"0:0:0\"\n    >>> FormatTime(3661)\n    \"1:1:1\"\n    >>> FormatTime(5436)\n    \"1:30:36\"\n*/\n   static string FormatTime(int seconds)",
      "tr": "using System;\nusing System.Collections.Generic;\nusing System.Diagnostics;\n\nclass Program\n{\n/* Belirtilen bir saniye sayısını baştaki sıfırlar olmadan biçimlendirilmiş bir zaman dizgesine dönüştürür.\n    Çıktının formatı \"<Saatler>:<Dakikalar>:<Saniyeler>\" şeklindedir. Her bileşen baştaki sıfırlar olmadan bir tam sayıdır.\n    Örnekler:\n    >>> FormatTime(0)\n    \"0:0:0\"\n    >>> FormatTime(3661)\n    \"1:1:1\"\n    >>> FormatTime(5436)\n    \"1:30:36\"\n*/\n   static string FormatTime(int seconds)",
      "vi": "using System;\nusing System.Collections.Generic;\nusing System.Diagnostics;\n\nclass Program\n{\n/* Chuyển đổi một số giây đã cho thành một chuỗi thời gian có định dạng không có số 0 đứng đầu.\n    Định dạng của đầu ra là \"<Giờ>:<Phút>:<Giây>\". Mỗi thành phần là một số nguyên không có số 0 đứng đầu.\n    Ví dụ:\n    >>> FormatTime(0)\n    \"0:0:0\"\n    >>> FormatTime(3661)\n    \"1:1:1\"\n    >>> FormatTime(5436)\n    \"1:30:36\"\n*/\n   static string FormatTime(int seconds)"
    },
    "prompt_bertscore": {
      "es": "0.9919175311653093",
      "arb": "0.9859371676531109",
      "sw": "0.9772155062522501",
      "tr": "0.9919175311653093",
      "vi": "0.9897550422069825"
    },
    "canonical_solution": "{\n    int hours = seconds / 3600;\n    int minutes = (seconds % 3600) / 60;\n    int remainingSeconds = seconds % 60;\n\n    return $\"{hours}:{minutes}:{remainingSeconds}\";\n}",
    "instruction": {
      "es": "static string FormatTime(int seconds)\n{\n    int hours = seconds / 3600;\n    int minutes = (seconds % 3600) / 60;\n    int remainingSeconds = seconds % 60;\n\n    return $\"{hours}:{minutes}:{remainingSeconds}\";\n}\n\nProporcione una descripción concisa en lenguaje natural (docstring) del código C# en español utilizando un máximo de 500 caracteres.",
      "arb": "static string FormatTime(int seconds)\n{\n    int hours = seconds / 3600;\n    int minutes = (seconds % 3600) / 60;\n    int remainingSeconds = seconds % 60;\n\n    return $\"{hours}:{minutes}:{remainingSeconds}\";\n}\n\nيرجى تقديم وصف موجز بلغة طبيعية (docstring) لشيفرة C# باللغة العربية الفصحى، بحيث لا يتجاوز 500 حرف.",
      "sw": "static string FormatTime(int seconds)\n{\n    int hours = seconds / 3600;\n    int minutes = (seconds % 3600) / 60;\n    int remainingSeconds = seconds % 60;\n\n    return $\"{hours}:{minutes}:{remainingSeconds}\";\n}\n\nToa maelezo mafupi ya lugha asilia (docstring) ya msimbo wa C# kwa Kiswahili kwa kutumia herufi zisizozidi 500.",
      "tr": "static string FormatTime(int seconds)\n{\n    int hours = seconds / 3600;\n    int minutes = (seconds % 3600) / 60;\n    int remainingSeconds = seconds % 60;\n\n    return $\"{hours}:{minutes}:{remainingSeconds}\";\n}\n\nC# kodunun Türkçe olarak en fazla 500 karakter kullanarak kısa bir doğal dil açıklamasını (docstring) sağlayın.",
      "vi": "static string FormatTime(int seconds)\n{\n    int hours = seconds / 3600;\n    int minutes = (seconds % 3600) / 60;\n    int remainingSeconds = seconds % 60;\n\n    return $\"{hours}:{minutes}:{remainingSeconds}\";\n}\n\nCung cấp mô tả ngắn gọn bằng ngôn ngữ tự nhiên (docstring) cho mã C# bằng tiếng Việt, không quá 500 ký tự."
    },
    "instruction_bertscore": {
      "es": "0.9702167647764858",
      "arb": "0.8991488007460131",
      "sw": "0.9446027812508938",
      "tr": "0.941090996114197",
      "vi": "0.9187315713818617"
    },
    "level": "",
    "test": "    static void Main()\n    {\n        Debug.Assert(FormatTime(0) == \"0:0:0\");\n        Debug.Assert(FormatTime(3661) == \"1:1:1\");\n        Debug.Assert(FormatTime(5436) == \"1:30:36\");\n        Debug.Assert(FormatTime(3600) == \"1:0:0\");\n        Debug.Assert(FormatTime(7200) == \"2:0:0\");\n        Debug.Assert(FormatTime(86399) == \"23:59:59\");\n        Debug.Assert(FormatTime(12345) == \"3:25:45\");\n\n    }\n}",
    "entry_point": "FormatTime",
    "signature": "static string FormatTime(int seconds)",
    "docstring": {
      "es": "Convierte un número dado de segundos en una cadena de tiempo formateada sin ceros a la izquierda.\n    El formato de la salida es \"<Horas>:<Minutos>:<Segundos>\". Cada componente es un entero sin ceros a la izquierda.\n    Ejemplos:\n    >>> FormatTime(0)\n    \"0:0:0\"\n    >>> FormatTime(3661)\n    \"1:1:1\"\n    >>> FormatTime(5436)\n    \"1:30:36\"",
      "arb": "يقوم بتحويل عدد معين من الثواني إلى سلسلة زمنية منسقة بدون أصفار بادئة.\n    تنسيق المخرجات هو \"<ساعات>:<دقائق>:<ثواني>\". كل مكون هو عدد صحيح بدون أصفار بادئة.\n    أمثلة:\n    >>> FormatTime(0)\n    \"0:0:0\"\n    >>> FormatTime(3661)\n    \"1:1:1\"\n    >>> FormatTime(5436)\n    \"1:30:36\"",
      "sw": "Hurekebisha idadi fulani ya sekunde kuwa kamba ya muda iliyopangwa bila sifuri za mwanzo.  \n    Muundo wa matokeo ni \"<Saa>:<Dakika>:<Sekunde>\". Kila sehemu ni nambari bila sifuri za mwanzo.  \n    Mifano:  \n    >>> FormatTime(0)  \n    \"0:0:0\"  \n    >>> FormatTime(3661)  \n    \"1:1:1\"  \n    >>> FormatTime(5436)  \n    \"1:30:36\"  ",
      "tr": "Verilen bir saniye sayısını baştaki sıfırlar olmadan biçimlendirilmiş bir zaman dizgesine dönüştürür.\n    Çıktının formatı \"<Saatler>:<Dakikalar>:<Saniyeler>\" şeklindedir. Her bileşen baştaki sıfırlar olmadan bir tam sayıdır.\n    Örnekler:\n    >>> FormatTime(0)\n    \"0:0:0\"\n    >>> FormatTime(3661)\n    \"1:1:1\"\n    >>> FormatTime(5436)\n    \"1:30:36\"",
      "vi": "Chuyển đổi một số giây đã cho thành một chuỗi thời gian định dạng mà không có số 0 đứng đầu.\n    Định dạng của đầu ra là \"<Giờ>:<Phút>:<Giây>\". Mỗi thành phần là một số nguyên không có số 0 đứng đầu.\n    Ví dụ:\n    >>> FormatTime(0)\n    \"0:0:0\"\n    >>> FormatTime(3661)\n    \"1:1:1\"\n    >>> FormatTime(5436)\n    \"1:30:36\""
    },
    "docstring_bertscore": {
      "es": "1",
      "arb": "0.9835569797971699",
      "sw": "0.965003114535082",
      "tr": "0.9910989753650646",
      "vi": "0.990418269049258"
    }
  },
  {
    "task_id": "C#/9",
    "prompt": {
      "es": "using System;\nusing System.Collections.Generic;\nusing System.Diagnostics;\n\n\nclass Program\n{\n/* Calcula el área de intersección entre dos rectángulos.\n   Cada rectángulo está definido por las coordenadas de su esquina superior izquierda (x1, y1) y su esquina inferior derecha (x2, y2).\n   \n   Ejemplos:\n   >>> CalculateIntersectionArea(0, 0, 2, 2, 1, 1, 3, 3)\n   1.00\n   >>> CalculateIntersectionArea(1, 1, 3, 4, 2, 2, 5, 5)\n   2.00\n   >>> CalculateIntersectionArea(0, 0, 1, 1, 2, 2, 3, 3)\n   0.00 (Sin Intersección)\n*/\nstatic double CalculateIntersectionArea(int x1Rect1, int y1Rect1, int x2Rect1, int y2Rect1, int x1Rect2, int y1Rect2, int x2Rect2, int y2Rect2)",
      "arb": "using System;\nusing System.Collections.Generic;\nusing System.Diagnostics;\n\n\nclass Program\n{\n/* يحسب مساحة التقاطع بين مستطيلين.\n   يتم تعريف كل مستطيل بواسطة إحداثيات الزاوية العلوية اليسرى (x1, y1) والزاوية السفلية اليمنى (x2, y2).\n   \n   أمثلة:\n   >>> CalculateIntersectionArea(0, 0, 2, 2, 1, 1, 3, 3)\n   1.00\n   >>> CalculateIntersectionArea(1, 1, 3, 4, 2, 2, 5, 5)\n   2.00\n   >>> CalculateIntersectionArea(0, 0, 1, 1, 2, 2, 3, 3)\n   0.00 (لا يوجد تقاطع)\n*/\nstatic double CalculateIntersectionArea(int x1Rect1, int y1Rect1, int x2Rect1, int y2Rect1, int x1Rect2, int y1Rect2, int x2Rect2, int y2Rect2)",
      "sw": "using System;\nusing System.Collections.Generic;\nusing System.Diagnostics;\n\n\nclass Program\n{\n/* Inahesabu eneo la makutano kati ya mistatili miwili.\n   Kila mstatili unafafanuliwa na kuratibu za kona yake ya juu-kushoto (x1, y1) na kona ya chini-kulia (x2, y2).\n   \n   Mifano:\n   >>> CalculateIntersectionArea(0, 0, 2, 2, 1, 1, 3, 3)\n   1.00\n   >>> CalculateIntersectionArea(1, 1, 3, 4, 2, 2, 5, 5)\n   2.00\n   >>> CalculateIntersectionArea(0, 0, 1, 1, 2, 2, 3, 3)\n   0.00 (Hakuna Makutano)\n*/\nstatic double CalculateIntersectionArea(int x1Rect1, int y1Rect1, int x2Rect1, int y2Rect1, int x1Rect2, int y1Rect2, int x2Rect2, int y2Rect2)",
      "tr": "using System;\nusing System.Collections.Generic;\nusing System.Diagnostics;\n\n\nclass Program\n{\n/* İki dikdörtgen arasındaki kesişim alanını hesaplar.\n   Her dikdörtgen, sol üst (x1, y1) ve sağ alt (x2, y2) köşelerinin koordinatları ile tanımlanır.\n   \n   Örnekler:\n   >>> CalculateIntersectionArea(0, 0, 2, 2, 1, 1, 3, 3)\n   1.00\n   >>> CalculateIntersectionArea(1, 1, 3, 4, 2, 2, 5, 5)\n   2.00\n   >>> CalculateIntersectionArea(0, 0, 1, 1, 2, 2, 3, 3)\n   0.00 (Kesişim Yok)\n*/\nstatic double CalculateIntersectionArea(int x1Rect1, int y1Rect1, int x2Rect1, int y2Rect1, int x1Rect2, int y1Rect2, int x2Rect2, int y2Rect2)",
      "vi": "using System;\nusing System.Collections.Generic;\nusing System.Diagnostics;\n\n\nclass Program\n{\n/* Tính diện tích giao nhau giữa hai hình chữ nhật.\n   Mỗi hình chữ nhật được xác định bởi tọa độ của góc trên-trái (x1, y1) và góc dưới-phải (x2, y2).\n   \n   Ví dụ:\n   >>> CalculateIntersectionArea(0, 0, 2, 2, 1, 1, 3, 3)\n   1.00\n   >>> CalculateIntersectionArea(1, 1, 3, 4, 2, 2, 5, 5)\n   2.00\n   >>> CalculateIntersectionArea(0, 0, 1, 1, 2, 2, 3, 3)\n   0.00 (Không có giao nhau)\n*/\nstatic double CalculateIntersectionArea(int x1Rect1, int y1Rect1, int x2Rect1, int y2Rect1, int x1Rect2, int y1Rect2, int x2Rect2, int y2Rect2)"
    },
    "prompt_bertscore": {
      "es": "0.986905292130275",
      "arb": "0.9841616106770401",
      "sw": "0.9908655846673486",
      "tr": "0.9804823801291308",
      "vi": "0.9815571691209106"
    },
    "canonical_solution": "{\n    int xOverlap = Math.Max(0, Math.Min(x2Rect1, x2Rect2) - Math.Max(x1Rect1, x1Rect2));\n    int yOverlap = Math.Max(0, Math.Min(y2Rect1, y2Rect2) - Math.Max(y1Rect1, y1Rect2));\n    return xOverlap * yOverlap;\n}",
    "instruction": {
      "es": "static double CalculateIntersectionArea(int x1Rect1, int y1Rect1, int x2Rect1, int y2Rect1, int x1Rect2, int y1Rect2, int x2Rect2, int y2Rect2)\n{\n    int xOverlap = Math.Max(0, Math.Min(x2Rect1, x2Rect2) - Math.Max(x1Rect1, x1Rect2));\n    int yOverlap = Math.Max(0, Math.Min(y2Rect1, y2Rect2) - Math.Max(y1Rect1, y1Rect2));\n    return xOverlap * yOverlap;\n}\n\nProporcione una descripción concisa en lenguaje natural (docstring) del código C# en español utilizando como máximo 500 caracteres.",
      "arb": "static double CalculateIntersectionArea(int x1Rect1, int y1Rect1, int x2Rect1, int y2Rect1, int x1Rect2, int y1Rect2, int x2Rect2, int y2Rect2)\n{\n    int xOverlap = Math.Max(0, Math.Min(x2Rect1, x2Rect2) - Math.Max(x1Rect1, x1Rect2));\n    int yOverlap = Math.Max(0, Math.Min(y2Rect1, y2Rect2) - Math.Max(y1Rect1, y1Rect2));\n    return xOverlap * yOverlap;\n}\n\nقم بتقديم وصف موجز بلغة طبيعية (docstring) للكود المكتوب بلغة C# باللغة العربية الفصحى باستخدام 500 حرف كحد أقصى.",
      "sw": "static double CalculateIntersectionArea(int x1Rect1, int y1Rect1, int x2Rect1, int y2Rect1, int x1Rect2, int y1Rect2, int x2Rect2, int y2Rect2)\n{\n    int xOverlap = Math.Max(0, Math.Min(x2Rect1, x2Rect2) - Math.Max(x1Rect1, x1Rect2));\n    int yOverlap = Math.Max(0, Math.Min(y2Rect1, y2Rect2) - Math.Max(y1Rect1, y1Rect2));\n    return xOverlap * yOverlap;\n}\n\nToa maelezo mafupi ya lugha ya asili (docstring) ya msimbo wa C# kwa Kiswahili kwa kutumia herufi zisizozidi 500.",
      "tr": "static double CalculateIntersectionArea(int x1Rect1, int y1Rect1, int x2Rect1, int y2Rect1, int x1Rect2, int y1Rect2, int x2Rect2, int y2Rect2)\n{\n    int xOverlap = Math.Max(0, Math.Min(x2Rect1, x2Rect2) - Math.Max(x1Rect1, x1Rect2));\n    int yOverlap = Math.Max(0, Math.Min(y2Rect1, y2Rect2) - Math.Max(y1Rect1, y1Rect2));\n    return xOverlap * yOverlap;\n}\n\nC# kodunun Türkçe olarak en fazla 500 karakter kullanarak kısa bir doğal dil açıklamasını (docstring) sağlayın.",
      "vi": "static double CalculateIntersectionArea(int x1Rect1, int y1Rect1, int x2Rect1, int y2Rect1, int x1Rect2, int y1Rect2, int x2Rect2, int y2Rect2)\n{\n    int xOverlap = Math.Max(0, Math.Min(x2Rect1, x2Rect2) - Math.Max(x1Rect1, x1Rect2));\n    int yOverlap = Math.Max(0, Math.Min(y2Rect1, y2Rect2) - Math.Max(y1Rect1, y1Rect2));\n    return xOverlap * yOverlap;\n}\n\nCung cấp mô tả ngắn gọn bằng ngôn ngữ tự nhiên (docstring) cho mã C# bằng tiếng Việt, sử dụng tối đa 500 ký tự."
    },
    "instruction_bertscore": {
      "es": "0.9702167647764858",
      "arb": "0.9203796076533082",
      "sw": "0.918288824262535",
      "tr": "0.9401900087058227",
      "vi": "0.943402259227919"
    },
    "level": "",
    "test": "    static void Main()\n    {\n\n        Debug.Assert(Math.Abs(CalculateIntersectionArea(0, 0, 2, 2, 1, 1, 3, 3) - 1.00) < 0.01);\n        Debug.Assert(Math.Abs(CalculateIntersectionArea(1, 1, 3, 4, 2, 2, 5, 5) - 2.00) < 0.01);\n        Debug.Assert(Math.Abs(CalculateIntersectionArea(0, 0, 1, 1, 2, 2, 3, 3) - 0.00) < 0.01);\n        Debug.Assert(Math.Abs(CalculateIntersectionArea(1, 1, 4, 4, 3, 3, 6, 6) - 1.00) < 0.01);\n        Debug.Assert(Math.Abs(CalculateIntersectionArea(0, 0, 3, 3, 1, 1, 2, 2) - 1.00) < 0.01);\n        Debug.Assert(Math.Abs(CalculateIntersectionArea(2, 2, 5, 5, 3, 3, 6, 6) - 4.00) < 0.01);\n        Debug.Assert(Math.Abs(CalculateIntersectionArea(0, 0, 2, 2, 3, 3, 5, 5) - 0.00) < 0.01);\n\n    }\n}",
    "entry_point": "CalculateIntersectionArea",
    "signature": "static double CalculateIntersectionArea(int x1Rect1, int y1Rect1, int x2Rect1, int y2Rect1, int x1Rect2, int y1Rect2, int x2Rect2, int y2Rect2)",
    "docstring": {
      "es": "Calcula el área de intersección entre dos rectángulos.  \n   Cada rectángulo está definido por las coordenadas de su esquina superior izquierda (x1, y1) y su esquina inferior derecha (x2, y2).\n   \n   Ejemplos:\n   >>> CalculateIntersectionArea(0, 0, 2, 2, 1, 1, 3, 3)\n   1.00\n   >>> CalculateIntersectionArea(1, 1, 3, 4, 2, 2, 5, 5)\n   2.00\n   >>> CalculateIntersectionArea(0, 0, 1, 1, 2, 2, 3, 3)\n   0.00 (Sin intersección)",
      "arb": "يحسب مساحة التقاطع بين مستطيلين.   \nكل مستطيل يُعرف بإحداثيات الزاوية العلوية اليسرى (x1, y1) والزاوية السفلية اليمنى (x2, y2).\n\nأمثلة:\n>>> CalculateIntersectionArea(0, 0, 2, 2, 1, 1, 3, 3)\n1.00\n>>> CalculateIntersectionArea(1, 1, 3, 4, 2, 2, 5, 5)\n2.00\n>>> CalculateIntersectionArea(0, 0, 1, 1, 2, 2, 3, 3)\n0.00 (لا يوجد تقاطع)",
      "sw": "Huhesabu eneo la makutano kati ya mrectangle mawili.  \nKila mrectangle umefafanuliwa na kuratibu za kona zake za juu-kushoto (x1, y1) na kona za chini-kulia (x2, y2).\n\nMifano:\n>>> CalculateIntersectionArea(0, 0, 2, 2, 1, 1, 3, 3)\n1.00\n>>> CalculateIntersectionArea(1, 1, 3, 4, 2, 2, 5, 5)\n2.00\n>>> CalculateIntersectionArea(0, 0, 1, 1, 2, 2, 3, 3)\n0.00 (Hakuna Makutano)",
      "tr": "İki dikdörtgen arasındaki kesişim alanını hesaplar.  \n   Her dikdörtgen, sol üst (x1, y1) ve sağ alt (x2, y2) köşelerinin koordinatları ile tanımlanır.\n   \n   Örnekler:\n   >>> CalculateIntersectionArea(0, 0, 2, 2, 1, 1, 3, 3)\n   1.00\n   >>> CalculateIntersectionArea(1, 1, 3, 4, 2, 2, 5, 5)\n   2.00\n   >>> CalculateIntersectionArea(0, 0, 1, 1, 2, 2, 3, 3)\n   0.00 (Kesişim Yok)",
      "vi": "Tính diện tích giao nhau giữa hai hình chữ nhật.  \nMỗi hình chữ nhật được xác định bởi tọa độ của góc trên bên trái (x1, y1) và góc dưới bên phải (x2, y2).\n\nVí dụ:\n>>> CalculateIntersectionArea(0, 0, 2, 2, 1, 1, 3, 3)\n1.00\n>>> CalculateIntersectionArea(1, 1, 3, 4, 2, 2, 5, 5)\n2.00\n>>> CalculateIntersectionArea(0, 0, 1, 1, 2, 2, 3, 3)\n0.00 (Không giao nhau)"
    },
    "docstring_bertscore": {
      "es": "0.9775496025531507",
      "arb": "0.9770776567678119",
      "sw": "0.9860899144161268",
      "tr": "0.9922977097146102",
      "vi": "0.9745288317183721"
    }
  },
  {
    "task_id": "C#/10",
    "prompt": {
      "es": "using System;\nusing System.Collections.Generic;\nusing System.Diagnostics;\n\nclass Program\n{\n/*\n    Resuelve una ecuación lineal de la forma ax + b = 0.\n    La función devuelve la solución como un doble con precisión de dos decimales.\n    Supone que 'a' no es cero.\n\n    Ejemplos:\n    >>> SolveLinearEquation(2, -4)\n    2.00\n    >>> SolveLinearEquation(5, 10)\n    -2.00\n*/\n    static double SolveLinearEquation(double a, double b)",
      "arb": "using System;\nusing System.Collections.Generic;\nusing System.Diagnostics;\n\nclass Program\n{\n/*\n    يحل معادلة خطية من الشكل ax + b = 0.\n    تُرجع الدالة الحل كعدد عشري بدقة تصل إلى منزلتين عشريتين.\n    يفترض أن 'a' ليست صفراً.\n\n    أمثلة:\n    >>> SolveLinearEquation(2, -4)\n    2.00\n    >>> SolveLinearEquation(5, 10)\n    -2.00\n*/\n    static double SolveLinearEquation(double a, double b)",
      "sw": "using System;\nusing System.Collections.Generic;\nusing System.Diagnostics;\n\nclass Program\n{\n/*\n    Inasuluhisha mlinganyo wa mstari wa fomu ax + b = 0.\n    Kazi inarudisha suluhisho kama namba ya desimali yenye usahihi wa sehemu mbili za desimali.\n    Inadhani kwamba 'a' si sifuri.\n\n    Mifano:\n    >>> SolveLinearEquation(2, -4)\n    2.00\n    >>> SolveLinearEquation(5, 10)\n    -2.00\n*/\n    static double SolveLinearEquation(double a, double b)",
      "tr": "using System;\nusing System.Collections.Generic;\nusing System.Diagnostics;\n\nclass Program\n{\n/*\n    ax + b = 0 formundaki bir lineer denklemi çözer.\n    Fonksiyon, çözümü iki ondalık basamak hassasiyetinde bir double olarak döndürür.\n    'a'nın sıfır olmadığını varsayar.\n\n    Örnekler:\n    >>> SolveLinearEquation(2, -4)\n    2.00\n    >>> SolveLinearEquation(5, 10)\n    -2.00\n*/\n    static double SolveLinearEquation(double a, double b)",
      "vi": "using System;\nusing System.Collections.Generic;\nusing System.Diagnostics;\n\nclass Program\n{\n/*\n    Giải phương trình bậc nhất dạng ax + b = 0.\n    Hàm trả về nghiệm dưới dạng số thực với độ chính xác hai chữ số thập phân.\n    Giả sử rằng 'a' không bằng không.\n\n    Ví dụ:\n    >>> SolveLinearEquation(2, -4)\n    2.00\n    >>> SolveLinearEquation(5, 10)\n    -2.00\n*/\n    static double SolveLinearEquation(double a, double b)"
    },
    "prompt_bertscore": {
      "es": "0.9913331605843048",
      "arb": "0.9675318779160372",
      "sw": "0.9703919567725585",
      "tr": "0.9880676771200911",
      "vi": "0.9729884531134466"
    },
    "canonical_solution": "{\n    if (a == 0) throw new ArgumentException(\"Coefficient 'a' cannot be zero.\");\n    double solution = -b / a;\n    return Math.Round(solution, 2);\n}",
    "instruction": {
      "es": "static double SolveLinearEquation(double a, double b)\n{\n    if (a == 0) throw new ArgumentException(\"Coefficient 'a' cannot be zero.\");\n    double solution = -b / a;\n    return Math.Round(solution, 2);\n}\n\nProporcione una descripción concisa en lenguaje natural (docstring) del código C# en español utilizando un máximo de 500 caracteres.",
      "arb": "static double SolveLinearEquation(double a, double b)\n{\n    if (a == 0) throw new ArgumentException(\"Coefficient 'a' cannot be zero.\");\n    double solution = -b / a;\n    return Math.Round(solution, 2);\n}\n\nقدم وصفًا موجزًا بلغة طبيعية (docstring) للكود المكتوب بلغة C# باللغة العربية الفصحى باستخدام 500 حرف كحد أقصى.",
      "sw": "static double SolveLinearEquation(double a, double b)\n{\n    if (a == 0) throw new ArgumentException(\"Coefficient 'a' cannot be zero.\");\n    double solution = -b / a;\n    return Math.Round(solution, 2);\n}\n\nToa maelezo mafupi ya lugha ya asili (docstring) ya msimbo wa C# kwa Kiswahili kwa kutumia herufi zisizozidi 500.",
      "tr": "static double SolveLinearEquation(double a, double b)\n{\n    if (a == 0) throw new ArgumentException(\"Coefficient 'a' cannot be zero.\");\n    double solution = -b / a;\n    return Math.Round(solution, 2);\n}\n\nC# kodunun Türkçe dilinde en fazla 500 karakter kullanarak kısa bir doğal dil açıklamasını (docstring) sağlayın.",
      "vi": "static double SolveLinearEquation(double a, double b)\n{\n    if (a == 0) throw new ArgumentException(\"Coefficient 'a' cannot be zero.\");\n    double solution = -b / a;\n    return Math.Round(solution, 2);\n}\n\nCung cấp mô tả ngắn gọn bằng ngôn ngữ tự nhiên (docstring) cho mã C# bằng tiếng Việt, không quá 500 ký tự."
    },
    "instruction_bertscore": {
      "es": "0.9702167647764858",
      "arb": "0.915670279949352",
      "sw": "0.918288824262535",
      "tr": "0.9541634573812461",
      "vi": "0.9093975325162702"
    },
    "level": "",
    "test": "    static void Main()\n    {\n        Debug.Assert(SolveLinearEquation(1, -3) == 3.00);\n        Debug.Assert(SolveLinearEquation(4, 8) == -2.00);\n        Debug.Assert(SolveLinearEquation(-2, 6) == 3.00);\n        Debug.Assert(SolveLinearEquation(3, -9) == 3.00);\n        Debug.Assert(SolveLinearEquation(0.5, -1.5) == 3.00);\n        Debug.Assert(SolveLinearEquation(-5, 10) == 2.00);\n        Debug.Assert(SolveLinearEquation(10, -20) == 2.00);\n\n    }\n}",
    "entry_point": "SolveLinearEquation",
    "signature": "static double SolveLinearEquation(double a, double b)",
    "docstring": {
      "es": "Resuelve una ecuación lineal de la forma ax + b = 0.  \n    La función devuelve la solución como un doble con precisión de dos decimales.  \n    Supone que 'a' no es cero.\n\n    Ejemplos:\n    >>> SolveLinearEquation(2, -4)\n    2.00\n    >>> SolveLinearEquation(5, 10)\n    -2.00",
      "arb": "يحل معادلة خطية من الشكل ax + b = 0.\n    تُرجع الدالة الحل كرقم عشري مزدوج بدقة تصل إلى منزلتين عشريتين.\n    يفترض أن 'a' ليس صفراً.\n\n    أمثلة:\n    >>> SolveLinearEquation(2, -4)\n    2.00\n    >>> SolveLinearEquation(5, 10)\n    -2.00",
      "sw": "Hutatua mlingano wa mstari wa fomu ax + b = 0. \n    Kazi inarudisha suluhisho kama namba ya desimali yenye usahihi wa sehemu mbili za desimali. \n    Inadhani kwamba 'a' si sifuri.\n\n    Mifano:\n    >>> SolveLinearEquation(2, -4)\n    2.00\n    >>> SolveLinearEquation(5, 10)\n    -2.00",
      "tr": "ax + b = 0 biçimindeki bir lineer denklemi çözer.\n    Fonksiyon, çözümü iki ondalık basamak hassasiyetinde bir double olarak döndürür.\n    'a'nın sıfır olmadığını varsayar.\n\n    Örnekler:\n    >>> SolveLinearEquation(2, -4)\n    2.00\n    >>> SolveLinearEquation(5, 10)\n    -2.00",
      "vi": "Giải một phương trình bậc nhất dạng ax + b = 0. Hàm trả về nghiệm dưới dạng số thực với độ chính xác hai chữ số thập phân. Giả sử rằng 'a' không bằng không.\n\n    Ví dụ:\n    >>> SolveLinearEquation(2, -4)\n    2.00\n    >>> SolveLinearEquation(5, 10)\n    -2.00"
    },
    "docstring_bertscore": {
      "es": "0.9880929031784826",
      "arb": "0.9521852974165197",
      "sw": "0.9621197959239796",
      "tr": "0.9552338765046431",
      "vi": "0.9676629739675202"
    }
  },
  {
    "task_id": "C#/11",
    "prompt": {
      "es": "using System;\nusing System.Collections.Generic;\nusing System.Diagnostics;\n\nclass Program\n{\n   /* Calcula el número total de vacas después de un número dado de años, siguiendo la regla de que cada vaca da a luz a otra vaca cada año a partir de su cuarto año.\n    Casos de ejemplo:\n    >>> TotalCows(1)\n    1\n    >>> TotalCows(4)\n    2\n    >>> TotalCows(5)\n    3\n    >>> TotalCows(6)\n    4\n*/\n   static int TotalCows(int years)",
      "arb": "using System;\nusing System.Collections.Generic;\nusing System.Diagnostics;\n\nclass Program\n{\n   /* يحسب العدد الإجمالي للأبقار بعد عدد معين من السنوات، وفقًا للقاعدة التي تنص على أن كل بقرة تلد بقرة أخرى كل عام بدءًا من عامها الرابع.\n    أمثلة الحالات:\n    >>> TotalCows(1)\n    1\n    >>> TotalCows(4)\n    2\n    >>> TotalCows(5)\n    3\n    >>> TotalCows(6)\n    4\n*/\n   static int TotalCows(int years)",
      "sw": "using System;\nusing System.Collections.Generic;\nusing System.Diagnostics;\n\nclass Program\n{\n   /* Inahesabu jumla ya ng'ombe baada ya miaka fulani, kufuatia kanuni kwamba kila ng'ombe anazaa ng'ombe mwingine kila mwaka kuanzia mwaka wake wa nne.\n    Mifano ya kesi:\n    >>> TotalCows(1)\n    1\n    >>> TotalCows(4)\n    2\n    >>> TotalCows(5)\n    3\n    >>> TotalCows(6)\n    4\n*/\n   static int TotalCows(int years)",
      "tr": "using System;\nusing System.Collections.Generic;\nusing System.Diagnostics;\n\nclass Program\n{\n   /* Belirli bir yıl sayısından sonra toplam inek sayısını hesaplar, her ineğin dördüncü yılından itibaren her yıl başka bir inek doğurduğu kuralını takip ederek.\n    Örnek durumlar:\n    >>> TotalCows(1)\n    1\n    >>> TotalCows(4)\n    2\n    >>> TotalCows(5)\n    3\n    >>> TotalCows(6)\n    4\n*/\n   static int TotalCows(int years)",
      "vi": "using System;\nusing System.Collections.Generic;\nusing System.Diagnostics;\n\nclass Program\n{\n   /* Tính tổng số bò sau một số năm nhất định, theo quy tắc rằng mỗi con bò sinh ra một con bò khác mỗi năm từ năm thứ tư của nó.\n    Các trường hợp ví dụ:\n    >>> TotalCows(1)\n    1\n    >>> TotalCows(4)\n    2\n    >>> TotalCows(5)\n    3\n    >>> TotalCows(6)\n    4\n*/\n   static int TotalCows(int years)"
    },
    "prompt_bertscore": {
      "es": "0.9946989523909409",
      "arb": "0.9835712811846044",
      "sw": "0.98937069241968",
      "tr": "0.98937069241968",
      "vi": "0.9873806146320915"
    },
    "canonical_solution": "{\n        if (years <= 0)\n        {\n            return 0;\n        }\n        else if (years <= 3)\n        {\n            return 1;\n        }\n        else\n        {\n            return TotalCows(years - 1) + TotalCows(years - 3);\n        }\n}",
    "instruction": {
      "es": "static int TotalCows(int years)\n{\n        if (years <= 0)\n        {\n            return 0;\n        }\n        else if (years <= 3)\n        {\n            return 1;\n        }\n        else\n        {\n            return TotalCows(years - 1) + TotalCows(years - 3);\n        }\n}\n\nProporciona una descripción concisa en lenguaje natural (docstring) del código C# en español utilizando un máximo de 500 caracteres.",
      "arb": "static int TotalCows(int years)\n{\n        if (years <= 0)\n        {\n            return 0;\n        }\n        else if (years <= 3)\n        {\n            return 1;\n        }\n        else\n        {\n            return TotalCows(years - 1) + TotalCows(years - 3);\n        }\n}\n\nيرجى تقديم وصف موجز بلغة طبيعية (docstring) للكود المكتوب بلغة C# باللغة العربية الفصحى، بحيث لا يتجاوز 500 حرف.",
      "sw": "static int TotalCows(int years)\n{\n        if (years <= 0)\n        {\n            return 0;\n        }\n        else if (years <= 3)\n        {\n            return 1;\n        }\n        else\n        {\n            return TotalCows(years - 1) + TotalCows(years - 3);\n        }\n}\n\nToa maelezo mafupi ya lugha ya asili (docstring) ya msimbo wa C# kwa Kiswahili kwa kutumia herufi zisizozidi 500.",
      "tr": "static int TotalCows(int years)\n{\n        if (years <= 0)\n        {\n            return 0;\n        }\n        else if (years <= 3)\n        {\n            return 1;\n        }\n        else\n        {\n            return TotalCows(years - 1) + TotalCows(years - 3);\n        }\n}\n\nC# kodunun işlevini açıklayan en fazla 500 karakterlik özlü bir doğal dil açıklaması (docstring) sağlayın.",
      "vi": "static int TotalCows(int years)\n{\n        if (years <= 0)\n        {\n            return 0;\n        }\n        else if (years <= 3)\n        {\n            return 1;\n        }\n        else\n        {\n            return TotalCows(years - 1) + TotalCows(years - 3);\n        }\n}\n\nCung cấp mô tả ngắn gọn bằng ngôn ngữ tự nhiên (docstring) cho mã C# bằng tiếng Việt, sử dụng tối đa 500 ký tự."
    },
    "instruction_bertscore": {
      "es": "0.9702167647764858",
      "arb": "0.8890840007085943",
      "sw": "0.918288824262535",
      "tr": "0.8861824081024366",
      "vi": "0.9298151466436084"
    },
    "level": "",
    "test": "    static void Main()\n    {\n        Debug.Assert(TotalCows(1) == 1);\n        Debug.Assert(TotalCows(2) == 1);\n        Debug.Assert(TotalCows(3) == 1);\n        Debug.Assert(TotalCows(4) == 2);\n        Debug.Assert(TotalCows(5) == 3);\n        Debug.Assert(TotalCows(6) == 4);\n        Debug.Assert(TotalCows(7) == 6);\n        Debug.Assert(TotalCows(8) == 9);\n        Debug.Assert(TotalCows(10) == 19);\n    }\n}\n",
    "entry_point": "TotalCows",
    "signature": "static int TotalCows(int years)",
    "docstring": {
      "es": "Calcula el número total de vacas después de un número dado de años, siguiendo la regla de que cada vaca da a luz a otra vaca cada año a partir de su cuarto año.\n    Casos de ejemplo:\n    >>> TotalCows(1)\n    1\n    >>> TotalCows(4)\n    2\n    >>> TotalCows(5)\n    3\n    >>> TotalCows(6)\n    4",
      "arb": "يحسب العدد الإجمالي للأبقار بعد عدد معين من السنوات، وفقًا للقاعدة التي تنص على أن كل بقرة تلد بقرة أخرى كل عام بدءًا من عامها الرابع.\n    حالات المثال:\n    >>> TotalCows(1)\n    1\n    >>> TotalCows(4)\n    2\n    >>> TotalCows(5)\n    3\n    >>> TotalCows(6)\n    4",
      "sw": "Hesabu jumla ya idadi ya ng'ombe baada ya miaka fulani, kufuatia kanuni kwamba kila ng'ombe huzaa ng'ombe mwingine kila mwaka kuanzia mwaka wake wa nne.\n    Mifano ya kesi:\n    >>> TotalCows(1)\n    1\n    >>> TotalCows(4)\n    2\n    >>> TotalCows(5)\n    3\n    >>> TotalCows(6)\n    4",
      "tr": "Verilen yıl sayısından sonra toplam inek sayısını hesaplar, her ineğin dördüncü yılından itibaren her yıl başka bir inek doğurduğu kuralını takip eder.\n    Örnek vakalar:\n    >>> TotalCows(1)\n    1\n    >>> TotalCows(4)\n    2\n    >>> TotalCows(5)\n    3\n    >>> TotalCows(6)\n    4",
      "vi": "Tính tổng số bò sau một số năm nhất định, theo quy tắc rằng mỗi con bò sinh ra một con bò khác mỗi năm từ năm thứ tư của nó.\n    Ví dụ trường hợp:\n    >>> TotalCows(1)\n    1\n    >>> TotalCows(4)\n    2\n    >>> TotalCows(5)\n    3\n    >>> TotalCows(6)\n    4"
    },
    "docstring_bertscore": {
      "es": "0.9863707777749101",
      "arb": "0.9710067178018615",
      "sw": "0.9769370264580391",
      "tr": "0.9872435596691774",
      "vi": "0.9761385323262789"
    }
  },
  {
    "task_id": "C#/12",
    "prompt": {
      "es": "using System;\nusing System.Collections.Generic;\nusing System.Diagnostics;\n\nclass Program\n{\n/* Esta función cuenta cuántas manzanas son alcanzables.\n    Toma una lista de enteros que representan las alturas de las manzanas desde el suelo y un entero que representa la altura máxima que se puede alcanzar (con o sin un taburete).\n    Se considera que una manzana es alcanzable si su altura es menor o igual a la altura máxima alcanzable.\n    Ejemplo:\n    >>> CountReachableApples(new List<int> {150, 200, 160, 310, 220}, 210)\n    3\n    >>> CountReachableApples(new List<int> {100, 180, 250, 300, 320}, 200)\n    2\n*/\nstatic int CountReachableApples(List<int> appleHeights, int maxReachHeight)",
      "arb": "using System;\nusing System.Collections.Generic;\nusing System.Diagnostics;\n\nclass Program\n{\n/* هذه الدالة تحسب عدد التفاحات التي يمكن الوصول إليها.\n   تأخذ قائمة من الأعداد الصحيحة التي تمثل ارتفاعات التفاح من الأرض وعدد صحيح يمثل أقصى ارتفاع يمكن الوصول إليه (مع أو بدون كرسي).\n   يعتبر التفاح قابلاً للوصول إذا كان ارتفاعه أقل من أو يساوي أقصى ارتفاع يمكن الوصول إليه.\n   مثال:\n   >>> CountReachableApples(new List<int> {150, 200, 160, 310, 220}, 210)\n   3\n   >>> CountReachableApples(new List<int> {100, 180, 250, 300, 320}, 200)\n   2\n*/\nstatic int CountReachableApples(List<int> appleHeights, int maxReachHeight)",
      "sw": "using System;\nusing System.Collections.Generic;\nusing System.Diagnostics;\n\nclass Program\n{\n/* Kazi ya hii function ni kuhesabu ni maapulo mangapi yanaweza kufikiwa.\n    Inachukua orodha ya namba nzima inayowakilisha urefu wa maapulo kutoka ardhini na namba nzima inayowakilisha urefu wa juu kabisa unaoweza kufikiwa (kwa kutumia kigoda au bila).\n    Tufaha linachukuliwa kuwa linaweza kufikiwa ikiwa urefu wake ni chini au sawa na urefu wa juu unaoweza kufikiwa.\n    Mfano:\n    >>> CountReachableApples(new List<int> {150, 200, 160, 310, 220}, 210)\n    3\n    >>> CountReachableApples(new List<int> {100, 180, 250, 300, 320}, 200)\n    2\n*/\nstatic int CountReachableApples(List<int> appleHeights, int maxReachHeight)",
      "tr": "using System;\nusing System.Collections.Generic;\nusing System.Diagnostics;\n\nclass Program\n{\n/* Bu fonksiyon kaç tane elmanın ulaşılabilir olduğunu sayar.\n    Yerden elma yüksekliklerini temsil eden bir tamsayı listesi ve ulaşılabilecek maksimum yüksekliği temsil eden bir tamsayı alır (tabureli veya taburesiz).\n    Bir elma, yüksekliği ulaşılabilir maksimum yüksekliğe eşit veya daha az ise ulaşılabilir kabul edilir.\n    Örnek:\n    >>> CountReachableApples(new List<int> {150, 200, 160, 310, 220}, 210)\n    3\n    >>> CountReachableApples(new List<int> {100, 180, 250, 300, 320}, 200)\n    2\n*/\nstatic int CountReachableApples(List<int> appleHeights, int maxReachHeight)",
      "vi": "using System;\nusing System.Collections.Generic;\nusing System.Diagnostics;\n\nclass Program\n{\n/* Hàm này đếm có bao nhiêu quả táo có thể với tới được.\n    Nó nhận một danh sách các số nguyên đại diện cho độ cao của các quả táo từ mặt đất và một số nguyên đại diện cho độ cao tối đa có thể với tới (có hoặc không có ghế đẩu).\n    Một quả táo được coi là có thể với tới nếu độ cao của nó nhỏ hơn hoặc bằng độ cao tối đa có thể với tới.\n    Ví dụ:\n    >>> CountReachableApples(new List<int> {150, 200, 160, 310, 220}, 210)\n    3\n    >>> CountReachableApples(new List<int> {100, 180, 250, 300, 320}, 200)\n    2\n*/\nstatic int CountReachableApples(List<int> appleHeights, int maxReachHeight)"
    },
    "prompt_bertscore": {
      "es": "0.9971123115205148",
      "arb": "0.9818874914445717",
      "sw": "0.9714556224630003",
      "tr": "0.9801605989118544",
      "vi": "0.9864184490663584"
    },
    "canonical_solution": "{\n    int reachableApples = 0;\n    foreach (int height in appleHeights)\n    {\n        if (height <= maxReachHeight)\n        {\n            reachableApples++;\n        }\n    }\n    return reachableApples;\n}",
    "instruction": {
      "es": "static int CountReachableApples(List<int> appleHeights, int maxReachHeight)\n{\n    int reachableApples = 0;\n    foreach (int height in appleHeights)\n    {\n        if (height <= maxReachHeight)\n        {\n            reachableApples++;\n        }\n    }\n    return reachableApples;\n}\n\nProporcione una descripción concisa en lenguaje natural (docstring) del código C# en español utilizando como máximo 500 caracteres.",
      "arb": "static int CountReachableApples(List<int> appleHeights, int maxReachHeight)\n{\n    int reachableApples = 0;\n    foreach (int height in appleHeights)\n    {\n        if (height <= maxReachHeight)\n        {\n            reachableApples++;\n        }\n    }\n    return reachableApples;\n}\n\nيرجى تقديم وصف موجز بلغة طبيعية (docstring) للشيفرة البرمجية المكتوبة بلغة C# باللغة العربية الفصحى، بحيث لا يتجاوز 500 حرف.",
      "sw": "static int CountReachableApples(List<int> appleHeights, int maxReachHeight)\n{\n    int reachableApples = 0;\n    foreach (int height in appleHeights)\n    {\n        if (height <= maxReachHeight)\n        {\n            reachableApples++;\n        }\n    }\n    return reachableApples;\n}\n\nToa maelezo mafupi ya lugha ya asili (docstring) ya msimbo wa C# kwa Kiswahili kwa kutumia herufi zisizozidi 500.",
      "tr": "static int CountReachableApples(List<int> appleHeights, int maxReachHeight)\n{\n    int reachableApples = 0;\n    foreach (int height in appleHeights)\n    {\n        if (height <= maxReachHeight)\n        {\n            reachableApples++;\n        }\n    }\n    return reachableApples;\n}\n\nC# kodunun işlevini açıklayan kısa bir doğal dil açıklaması (docstring) sağlayın. Açıklama Türkçe olmalı ve en fazla 500 karakter içermelidir.",
      "vi": "static int CountReachableApples(List<int> appleHeights, int maxReachHeight)\n{\n    int reachableApples = 0;\n    foreach (int height in appleHeights)\n    {\n        if (height <= maxReachHeight)\n        {\n            reachableApples++;\n        }\n    }\n    return reachableApples;\n}\n\nCung cấp mô tả ngắn gọn bằng ngôn ngữ tự nhiên (docstring) cho mã C# bằng tiếng Việt, sử dụng tối đa 500 ký tự."
    },
    "instruction_bertscore": {
      "es": "0.9702167647764858",
      "arb": "0.8829437397396628",
      "sw": "0.918288824262535",
      "tr": "0.8751955658362539",
      "vi": "0.912055207014517"
    },
    "level": "",
    "test": "    static void Main()\n    {\n        Debug.Assert(CountReachableApples(new List<int> {150, 190, 300, 210, 220}, 200) == 2);\n        Debug.Assert(CountReachableApples(new List<int> {120, 180, 260, 310, 150}, 250) == 3);\n        Debug.Assert(CountReachableApples(new List<int> {100, 200, 300, 400, 500}, 350) == 3);\n\n    }\n}",
    "entry_point": "CountReachableApples",
    "signature": "static int CountReachableApples(List<int> appleHeights, int maxReachHeight)",
    "docstring": {
      "es": "Esta función cuenta cuántas manzanas son alcanzables.\n    Toma una lista de enteros que representan las alturas de las manzanas desde el suelo y un entero que representa la altura máxima que se puede alcanzar (con o sin un taburete).\n    Se considera que una manzana es alcanzable si su altura es menor o igual a la altura máxima alcanzable.\n    Ejemplo:\n    >>> CountReachableApples(new List<int> {150, 200, 160, 310, 220}, 210)\n    3\n    >>> CountReachableApples(new List<int> {100, 180, 250, 300, 320}, 200)\n    2",
      "arb": "هذه الدالة تحسب عدد التفاحات التي يمكن الوصول إليها.\n    تأخذ قائمة من الأعداد الصحيحة التي تمثل ارتفاعات التفاحات من الأرض وعدد صحيح يمثل أقصى ارتفاع يمكن الوصول إليه (مع أو بدون كرسي).\n    تعتبر التفاحة قابلة للوصول إذا كان ارتفاعها أقل من أو يساوي أقصى ارتفاع يمكن الوصول إليه.\n    مثال:\n    >>> CountReachableApples(new List<int> {150, 200, 160, 310, 220}, 210)\n    3\n    >>> CountReachableApples(new List<int> {100, 180, 250, 300, 320}, 200)\n    2",
      "sw": "Kazi ya hii function ni kuhesabu ni maapulo mangapi yanaweza kufikiwa.  \nKazi ya hii kazi ni kuhesabu ni tufaha ngapi zinaweza kufikiwa.  \n    It takes a list of integers representing the heights of apples from the ground and an integer representing the maximum height that can be reached (with or without a stool).  \n    Inachukua orodha ya namba nzima zinazoonyesha urefu wa tufaha kutoka ardhini na namba nzima inayoonyesha urefu wa juu zaidi unaoweza kufikiwa (kwa kutumia kigoda au bila).  \n    An apple is considered reachable if its height is less than or equal to the maximum reachable height.  \n    Tufaha inachukuliwa kuwa inaweza kufikiwa ikiwa urefu wake ni chini au sawa na urefu wa juu zaidi unaoweza kufikiwa.  \n    Example:  \n    Mfano:  \n    >>> CountReachableApples(new List<int> {150, 200, 160, 310, 220}, 210)  \n    3  \n    >>> CountReachableApples(new List<int> {100, 180, 250, 300, 320}, 200)  \n    2  ",
      "tr": "Bu fonksiyon, ulaşılabilir elma sayısını sayar.\n    Yerden elma yüksekliklerini temsil eden bir tamsayı listesi ve ulaşılabilecek maksimum yüksekliği temsil eden bir tamsayı alır (tabure ile veya tabure olmadan).\n    Bir elma, yüksekliği ulaşılabilir maksimum yüksekliğe eşit veya daha az ise ulaşılabilir kabul edilir.\n    Örnek:\n    >>> CountReachableApples(new List<int> {150, 200, 160, 310, 220}, 210)\n    3\n    >>> CountReachableApples(new List<int> {100, 180, 250, 300, 320}, 200)\n    2",
      "vi": "Hàm này đếm có bao nhiêu quả táo có thể với tới được.\n    Nó nhận một danh sách các số nguyên đại diện cho chiều cao của các quả táo từ mặt đất và một số nguyên đại diện cho chiều cao tối đa có thể với tới được (có hoặc không có ghế đẩu).\n    Một quả táo được coi là có thể với tới được nếu chiều cao của nó nhỏ hơn hoặc bằng chiều cao tối đa có thể với tới.\n    Ví dụ:\n    >>> CountReachableApples(new List<int> {150, 200, 160, 310, 220}, 210)\n    3\n    >>> CountReachableApples(new List<int> {100, 180, 250, 300, 320}, 200)\n    2"
    },
    "docstring_bertscore": {
      "es": "0.9967079000647278",
      "arb": "0.979264577263006",
      "sw": "0.8850198244822395",
      "tr": "0.9696971476996985",
      "vi": "0.9871593403876187"
    }
  },
  {
    "task_id": "C#/13",
    "prompt": {
      "es": "using System;\nusing System.Collections.Generic;\nusing System.Diagnostics;\n\nclass Program\n{\n   /*\n    Calcula el valor total máximo de hierbas que se pueden recolectar dentro de un tiempo dado.\n    La función toma el tiempo total disponible para recolectar hierbas, el número de diferentes hierbas,\n    un arreglo de costos de tiempo para cada hierba, y un arreglo de valores para cada hierba.\n\n    Parámetros:\n    totalMinutes - el tiempo total disponible para recolectar hierbas.\n    herbCount - el número de diferentes hierbas disponibles.\n    timeCosts - un arreglo donde timeCosts[i] representa el tiempo requerido para recolectar la i-ésima hierba.\n    values - un arreglo donde values[i] representa el valor de la i-ésima hierba.\n\n    Retorna:\n    El valor total máximo de las hierbas que se pueden recolectar dentro del tiempo dado.\n\n    Ejemplos:\n    >>> MaxHerbValue(10, 3, new int[] {3, 4, 5}, new int[] {200, 300, 350})\n    550\n    >>> MaxHerbValue(5, 2, new int[] {1, 4}, new int[] {150, 300})\n    450\n*/\n   static int MaxHerbValue(int totalMinutes, int herbCount, int[] timeCosts, int[] values)",
      "arb": "using System;\nusing System.Collections.Generic;\nusing System.Diagnostics;\n\nclass Program\n{\n   /*\n    يحسب القيمة الإجمالية القصوى للأعشاب التي يمكن جمعها خلال فترة زمنية معينة.\n    تأخذ الدالة الوقت الإجمالي المتاح لجمع الأعشاب، وعدد الأعشاب المختلفة،\n    ومصفوفة تكاليف الوقت لكل عشب، ومصفوفة القيم لكل عشب.\n\n    المعلمات:\n    totalMinutes - الوقت الإجمالي المتاح لجمع الأعشاب.\n    herbCount - عدد الأعشاب المختلفة المتاحة.\n    timeCosts - مصفوفة حيث timeCosts[i] تمثل الوقت المطلوب لجمع العشب i.\n    values - مصفوفة حيث values[i] تمثل قيمة العشب i.\n\n    يعيد:\n    القيمة الإجمالية القصوى للأعشاب التي يمكن جمعها خلال الفترة الزمنية المحددة.\n\n    أمثلة:\n    >>> MaxHerbValue(10, 3, new int[] {3, 4, 5}, new int[] {200, 300, 350})\n    550\n    >>> MaxHerbValue(5, 2, new int[] {1, 4}, new int[] {150, 300})\n    450\n*/\n   static int MaxHerbValue(int totalMinutes, int herbCount, int[] timeCosts, int[] values)",
      "sw": "using System;\nusing System.Collections.Generic;\nusing System.Diagnostics;\n\nclass Program\n{\n   /*\n    Inahesabu thamani ya juu kabisa ya mimea ambayo inaweza kukusanywa ndani ya muda uliotolewa.\n    Kazi inachukua muda wote unaopatikana kwa ajili ya kukusanya mimea, idadi ya mimea tofauti,\n    safu ya gharama za muda kwa kila mmea, na safu ya thamani kwa kila mmea.\n\n    Vigezo:\n    totalMinutes - muda wote unaopatikana kwa ajili ya kukusanya mimea.\n    herbCount - idadi ya mimea tofauti inayopatikana.\n    timeCosts - safu ambapo timeCosts[i] inawakilisha muda unaohitajika kukusanya mmea wa i-th.\n    values - safu ambapo values[i] inawakilisha thamani ya mmea wa i-th.\n\n    Inarudisha:\n    Thamani ya juu kabisa ya mimea ambayo inaweza kukusanywa ndani ya muda uliotolewa.\n\n    Mifano:\n    >>> MaxHerbValue(10, 3, new int[] {3, 4, 5}, new int[] {200, 300, 350})\n    550\n    >>> MaxHerbValue(5, 2, new int[] {1, 4}, new int[] {150, 300})\n    450\n*/\n   static int MaxHerbValue(int totalMinutes, int herbCount, int[] timeCosts, int[] values)",
      "tr": "using System;\nusing System.Collections.Generic;\nusing System.Diagnostics;\n\nclass Program\n{\n   /*\n    Belirli bir süre içinde toplanabilecek otların maksimum toplam değerini hesaplar.\n    Fonksiyon, ot toplamak için mevcut toplam süreyi, farklı otların sayısını,\n    her bir ot için zaman maliyetleri dizisini ve her bir ot için değerler dizisini alır.\n\n    Parametreler:\n    totalMinutes - ot toplamak için mevcut toplam süre.\n    herbCount - mevcut farklı otların sayısı.\n    timeCosts - timeCosts[i] i-inci otu toplamak için gereken süreyi temsil eden bir dizi.\n    values - values[i] i-inci otun değerini temsil eden bir dizi.\n\n    Döndürür:\n    Belirtilen süre içinde toplanabilecek otların maksimum toplam değerini döndürür.\n\n    Örnekler:\n    >>> MaxHerbValue(10, 3, new int[] {3, 4, 5}, new int[] {200, 300, 350})\n    550\n    >>> MaxHerbValue(5, 2, new int[] {1, 4}, new int[] {150, 300})\n    450\n*/\n   static int MaxHerbValue(int totalMinutes, int herbCount, int[] timeCosts, int[] values)",
      "vi": "using System;\nusing System.Collections.Generic;\nusing System.Diagnostics;\n\nclass Program\n{\n   /*\n    Tính giá trị tổng tối đa của các loại thảo mộc có thể thu thập trong một khoảng thời gian nhất định.\n    Hàm nhận tổng thời gian có sẵn để thu thập thảo mộc, số lượng các loại thảo mộc khác nhau,\n    một mảng chi phí thời gian cho mỗi loại thảo mộc, và một mảng giá trị cho mỗi loại thảo mộc.\n\n    Tham số:\n    totalMinutes - tổng thời gian có sẵn để thu thập thảo mộc.\n    herbCount - số lượng các loại thảo mộc khác nhau có sẵn.\n    timeCosts - một mảng mà timeCosts[i] đại diện cho thời gian cần thiết để thu thập loại thảo mộc thứ i.\n    values - một mảng mà values[i] đại diện cho giá trị của loại thảo mộc thứ i.\n\n    Trả về:\n    Giá trị tổng tối đa của các loại thảo mộc có thể thu thập trong khoảng thời gian đã cho.\n\n    Ví dụ:\n    >>> MaxHerbValue(10, 3, new int[] {3, 4, 5}, new int[] {200, 300, 350})\n    550\n    >>> MaxHerbValue(5, 2, new int[] {1, 4}, new int[] {150, 300})\n    450\n*/\n   static int MaxHerbValue(int totalMinutes, int herbCount, int[] timeCosts, int[] values)"
    },
    "prompt_bertscore": {
      "es": "0.9981992169655377",
      "arb": "0.966762582450289",
      "sw": "0.9898285354479655",
      "tr": "0.9888959658090066",
      "vi": "0.9637908733196261"
    },
    "canonical_solution": "{\n    int[,] dp = new int[herbCount + 1, totalMinutes + 1];\n\n    for (int i = 1; i <= herbCount; i++)\n    {\n        for (int j = 1; j <= totalMinutes; j++)\n        {\n            if (j < timeCosts[i - 1])\n                dp[i, j] = dp[i - 1, j];\n            else\n                dp[i, j] = Math.Max(dp[i - 1, j], dp[i - 1, j - timeCosts[i - 1]] + values[i - 1]);\n        }\n    }\n    Console.WriteLine(dp[herbCount, totalMinutes]);\n    return dp[herbCount, totalMinutes];\n}",
    "instruction": {
      "es": "static int MaxHerbValue(int totalMinutes, int herbCount, int[] timeCosts, int[] values)\n{\n    int[,] dp = new int[herbCount + 1, totalMinutes + 1];\n\n    for (int i = 1; i <= herbCount; i++)\n    {\n        for (int j = 1; j <= totalMinutes; j++)\n        {\n            if (j < timeCosts[i - 1])\n                dp[i, j] = dp[i - 1, j];\n            else\n                dp[i, j] = Math.Max(dp[i - 1, j], dp[i - 1, j - timeCosts[i - 1]] + values[i - 1]);\n        }\n    }\n    Console.WriteLine(dp[herbCount, totalMinutes]);\n    return dp[herbCount, totalMinutes];\n}\n\nProporcione una descripción concisa en lenguaje natural (docstring) del código C# en español utilizando como máximo 500 caracteres.",
      "arb": "static int MaxHerbValue(int totalMinutes, int herbCount, int[] timeCosts, int[] values)\n{\n    int[,] dp = new int[herbCount + 1, totalMinutes + 1];\n\n    for (int i = 1; i <= herbCount; i++)\n    {\n        for (int j = 1; j <= totalMinutes; j++)\n        {\n            if (j < timeCosts[i - 1])\n                dp[i, j] = dp[i - 1, j];\n            else\n                dp[i, j] = Math.Max(dp[i - 1, j], dp[i - 1, j - timeCosts[i - 1]] + values[i - 1]);\n        }\n    }\n    Console.WriteLine(dp[herbCount, totalMinutes]);\n    return dp[herbCount, totalMinutes];\n}\n\nيرجى تقديم وصف موجز بلغة طبيعية (docstring) للكود المكتوب بلغة C# باللغة العربية الفصحى، بحيث لا يتجاوز 500 حرف.",
      "sw": "static int MaxHerbValue(int totalMinutes, int herbCount, int[] timeCosts, int[] values)\n{\n    int[,] dp = new int[herbCount + 1, totalMinutes + 1];\n\n    for (int i = 1; i <= herbCount; i++)\n    {\n        for (int j = 1; j <= totalMinutes; j++)\n        {\n            if (j < timeCosts[i - 1])\n                dp[i, j] = dp[i - 1, j];\n            else\n                dp[i, j] = Math.Max(dp[i - 1, j], dp[i - 1, j - timeCosts[i - 1]] + values[i - 1]);\n        }\n    }\n    Console.WriteLine(dp[herbCount, totalMinutes]);\n    return dp[herbCount, totalMinutes];\n}\n\nToa maelezo mafupi kwa lugha ya asili (docstring) ya msimbo wa C# kwa Kiswahili kwa kutumia herufi zisizozidi 500.",
      "tr": "static int MaxHerbValue(int totalMinutes, int herbCount, int[] timeCosts, int[] values)\n{\n    int[,] dp = new int[herbCount + 1, totalMinutes + 1];\n\n    for (int i = 1; i <= herbCount; i++)\n    {\n        for (int j = 1; j <= totalMinutes; j++)\n        {\n            if (j < timeCosts[i - 1])\n                dp[i, j] = dp[i - 1, j];\n            else\n                dp[i, j] = Math.Max(dp[i - 1, j], dp[i - 1, j - timeCosts[i - 1]] + values[i - 1]);\n        }\n    }\n    Console.WriteLine(dp[herbCount, totalMinutes]);\n    return dp[herbCount, totalMinutes];\n}\n\nC# kodunun işlevini açıklayan, en fazla 500 karakterlik özlü bir doğal dil tanımı (docstring) sağlayın.",
      "vi": "static int MaxHerbValue(int totalMinutes, int herbCount, int[] timeCosts, int[] values)\n{\n    int[,] dp = new int[herbCount + 1, totalMinutes + 1];\n\n    for (int i = 1; i <= herbCount; i++)\n    {\n        for (int j = 1; j <= totalMinutes; j++)\n        {\n            if (j < timeCosts[i - 1])\n                dp[i, j] = dp[i - 1, j];\n            else\n                dp[i, j] = Math.Max(dp[i - 1, j], dp[i - 1, j - timeCosts[i - 1]] + values[i - 1]);\n        }\n    }\n    Console.WriteLine(dp[herbCount, totalMinutes]);\n    return dp[herbCount, totalMinutes];\n}\n\nCung cấp mô tả ngắn gọn bằng ngôn ngữ tự nhiên (docstring) cho mã C# bằng tiếng Việt, sử dụng tối đa 500 ký tự."
    },
    "instruction_bertscore": {
      "es": "0.9702167647764858",
      "arb": "0.8829437397396628",
      "sw": "0.916415938399757",
      "tr": "0.8861824081024366",
      "vi": "0.912055207014517"
    },
    "level": "",
    "test": "static void Main()\n    {\n        Debug.Assert(MaxHerbValue(10, 3, new int[] {3, 4, 5}, new int[] {200, 300, 350}) == 650);\n        Debug.Assert(MaxHerbValue(5, 2, new int[] {1, 4}, new int[] {150, 300}) == 450);\n        Debug.Assert(MaxHerbValue(7, 3, new int[] {2, 3, 5}, new int[] {100, 200, 300}) == 400);\n        Debug.Assert(MaxHerbValue(12, 4, new int[] {2, 4, 6, 3}, new int[] {100, 200, 300, 150}) == 600);\n        Debug.Assert(MaxHerbValue(8, 3, new int[] {1, 3, 4}, new int[] {150, 250, 350}) == 750);\n        Debug.Assert(MaxHerbValue(15, 5, new int[] {3, 5, 7, 4, 2}, new int[] {120, 280, 350, 220, 180}) == 810);\n\n\n    }\n}",
    "entry_point": "MaxHerbValue",
    "signature": "static int MaxHerbValue(int totalMinutes, int herbCount, int[] timeCosts, int[] values)",
    "docstring": {
      "es": "Calcula el valor total máximo de hierbas que se pueden recolectar dentro de un tiempo dado. La función toma el tiempo total disponible para recolectar hierbas, el número de diferentes hierbas, un arreglo de costos de tiempo para cada hierba y un arreglo de valores para cada hierba.\n\n    Parámetros:\n    totalMinutes - el tiempo total disponible para recolectar hierbas.\n    herbCount - el número de diferentes hierbas disponibles.\n    timeCosts - un arreglo donde timeCosts[i] representa el tiempo requerido para recolectar la i-ésima hierba.\n    values - un arreglo donde values[i] representa el valor de la i-ésima hierba.\n\n    Retorna:\n    El valor total máximo de las hierbas que se pueden recolectar dentro del tiempo dado.\n\n    Ejemplos:\n    >>> MaxHerbValue(10, 3, new int[] {3, 4, 5}, new int[] {200, 300, 350})\n    550\n    >>> MaxHerbValue(5, 2, new int[] {1, 4}, new int[] {150, 300})\n    450",
      "arb": "يحسب القيمة الإجمالية القصوى للأعشاب التي يمكن جمعها في غضون وقت معين. \n    تأخذ الدالة الوقت الإجمالي المتاح لجمع الأعشاب، عدد الأعشاب المختلفة، \n    مصفوفة تكاليف الوقت لكل عشب، ومصفوفة القيم لكل عشب.\n\n    Args:\n    totalMinutes - الوقت الإجمالي المتاح لجمع الأعشاب.\n    herbCount - عدد الأعشاب المختلفة المتاحة.\n    timeCosts - مصفوفة حيث timeCosts[i] تمثل الوقت المطلوب لجمع العشب i.\n    values - مصفوفة حيث values[i] تمثل قيمة العشب i.\n\n    Returns:\n    القيمة الإجمالية القصوى للأعشاب التي يمكن جمعها في الوقت المحدد.\n\n    Examples:\n    >>> MaxHerbValue(10, 3, new int[] {3, 4, 5}, new int[] {200, 300, 350})\n    550\n    >>> MaxHerbValue(5, 2, new int[] {1, 4}, new int[] {150, 300})\n    450",
      "sw": "Hesabu thamani ya juu kabisa ya mimea ambayo inaweza kukusanywa ndani ya muda uliotolewa. Kazi hii inachukua muda wote unaopatikana kwa kukusanya mimea, idadi ya mimea tofauti, safu ya gharama za muda kwa kila mmea, na safu ya thamani kwa kila mmea.\n\nVigezo:\ntotalMinutes - muda wote unaopatikana kwa kukusanya mimea.\nherbCount - idadi ya mimea tofauti inayopatikana.\ntimeCosts - safu ambapo timeCosts[i] inawakilisha muda unaohitajika kukusanya mmea wa i.\nvalues - safu ambapo values[i] inawakilisha thamani ya mmea wa i.\n\nInarejesha:\nThamani ya juu kabisa ya mimea ambayo inaweza kukusanywa ndani ya muda uliotolewa.\n\nMifano:\n>>> MaxHerbValue(10, 3, new int[] {3, 4, 5}, new int[] {200, 300, 350})\n550\n>>> MaxHerbValue(5, 2, new int[] {1, 4}, new int[] {150, 300})\n450",
      "tr": "Belirli bir süre içinde toplanabilecek otların maksimum toplam değerini hesaplar.\n    Fonksiyon, ot toplamak için mevcut toplam süreyi, farklı otların sayısını,\n    her bir ot için zaman maliyetlerini içeren bir dizi ve her bir otun değerlerini içeren bir dizi alır.\n\n    Parametreler:\n    totalMinutes - ot toplamak için mevcut toplam süre.\n    herbCount - mevcut farklı otların sayısı.\n    timeCosts - timeCosts[i] i-inci otu toplamak için gereken süreyi temsil eden bir dizi.\n    values - values[i] i-inci otun değerini temsil eden bir dizi.\n\n    Döndürür:\n    Belirli süre içinde toplanabilecek otların maksimum toplam değeri.\n\n    Örnekler:\n    >>> MaxHerbValue(10, 3, new int[] {3, 4, 5}, new int[] {200, 300, 350})\n    550\n    >>> MaxHerbValue(5, 2, new int[] {1, 4}, new int[] {150, 300})\n    450",
      "vi": "Tính toán tổng giá trị tối đa của các loại thảo mộc có thể thu thập trong một khoảng thời gian nhất định. \n    Hàm này nhận tổng thời gian có sẵn để thu thập thảo mộc, số lượng các loại thảo mộc khác nhau, \n    một mảng chi phí thời gian cho mỗi loại thảo mộc, và một mảng giá trị cho mỗi loại thảo mộc.\n\n    Tham số:\n    totalMinutes - tổng thời gian có sẵn để thu thập thảo mộc.\n    herbCount - số lượng các loại thảo mộc khác nhau có sẵn.\n    timeCosts - một mảng trong đó timeCosts[i] đại diện cho thời gian cần thiết để thu thập loại thảo mộc thứ i.\n    values - một mảng trong đó values[i] đại diện cho giá trị của loại thảo mộc thứ i.\n\n    Trả về:\n    Tổng giá trị tối đa của các loại thảo mộc có thể thu thập trong khoảng thời gian đã cho.\n\n    Ví dụ:\n    >>> MaxHerbValue(10, 3, new int[] {3, 4, 5}, new int[] {200, 300, 350})\n    550\n    >>> MaxHerbValue(5, 2, new int[] {1, 4}, new int[] {150, 300})\n    450"
    },
    "docstring_bertscore": {
      "es": "0.995383035423225",
      "arb": "0.957909030476421",
      "sw": "0.9547833828004559",
      "tr": "0.9795508036420773",
      "vi": "0.9605490268707557"
    }
  },
  {
    "task_id": "C#/14",
    "prompt": {
      "es": "using System;\nusing System.Collections.Generic;\nusing System.Diagnostics;\n\nclass Program\n{\n/* \n    Esta función toma una lista de enteros y realiza dos operaciones. En primer lugar, elimina cualquier número duplicado, asegurando que cada número sea único. En segundo lugar, ordena los números restantes en orden ascendente.\n    Ejemplo de uso:\n    >>> UniqueAndSorted(new List<int> {4, 2, 2, 5, 1})\n    [1, 2, 4, 5]\n    >>> UniqueAndSorted(new List<int> {10, 9, 8, 7, 8, 9, 10})\n    [7, 8, 9, 10]\n*/\n   static List<int> UniqueAndSorted(List<int> numbers)",
      "arb": "using System;\nusing System.Collections.Generic;\nusing System.Diagnostics;\n\nclass Program\n{\n/* \n    تأخذ هذه الدالة قائمة من الأعداد الصحيحة وتقوم بعمليتين. أولاً، تزيل أي أرقام مكررة، مما يضمن أن يكون كل رقم فريدًا. ثانيًا، تقوم بترتيب الأرقام المتبقية بترتيب تصاعدي.\n    مثال على الاستخدام:\n    >>> UniqueAndSorted(new List<int> {4, 2, 2, 5, 1})\n    [1, 2, 4, 5]\n    >>> UniqueAndSorted(new List<int> {10, 9, 8, 7, 8, 9, 10})\n    [7, 8, 9, 10]\n*/\n   static List<int> UniqueAndSorted(List<int> numbers)",
      "sw": "using System;\nusing System.Collections.Generic;\nusing System.Diagnostics;\n\nclass Program\n{\n/* \n    Kazi ya hii ni kuchukua orodha ya namba za mzima na kufanya shughuli mbili. Kwanza, inaondoa namba zozote zinazojirudia, kuhakikisha kila namba ni ya kipekee. Pili, inapanga namba zilizobaki kwa mpangilio wa kuongezeka.\n    Mfano wa matumizi:\n    >>> UniqueAndSorted(new List<int> {4, 2, 2, 5, 1})\n    [1, 2, 4, 5]\n    >>> UniqueAndSorted(new List<int> {10, 9, 8, 7, 8, 9, 10})\n    [7, 8, 9, 10]\n*/\n   static List<int> UniqueAndSorted(List<int> numbers)",
      "tr": "using System;\nusing System.Collections.Generic;\nusing System.Diagnostics;\n\nclass Program\n{\n/* \n    Bu fonksiyon bir tamsayı listesi alır ve iki işlem gerçekleştirir. İlk olarak, her sayının benzersiz olmasını sağlayarak yinelenen sayıları kaldırır. İkinci olarak, kalan sayıları artan sırayla sıralar.\n    Örnek kullanım:\n    >>> UniqueAndSorted(new List<int> {4, 2, 2, 5, 1})\n    [1, 2, 4, 5]\n    >>> UniqueAndSorted(new List<int> {10, 9, 8, 7, 8, 9, 10})\n    [7, 8, 9, 10]\n*/\n   static List<int> UniqueAndSorted(List<int> numbers)",
      "vi": "using System;\nusing System.Collections.Generic;\nusing System.Diagnostics;\n\nclass Program\n{\n/* \n    Hàm này nhận một danh sách các số nguyên và thực hiện hai thao tác. Đầu tiên, nó loại bỏ bất kỳ số trùng lặp nào, đảm bảo mỗi số là duy nhất. Thứ hai, nó sắp xếp các số còn lại theo thứ tự tăng dần.\n    Ví dụ sử dụng:\n    >>> UniqueAndSorted(new List<int> {4, 2, 2, 5, 1})\n    [1, 2, 4, 5]\n    >>> UniqueAndSorted(new List<int> {10, 9, 8, 7, 8, 9, 10})\n    [7, 8, 9, 10]\n*/\n   static List<int> UniqueAndSorted(List<int> numbers)"
    },
    "prompt_bertscore": {
      "es": "0.9916040924240364",
      "arb": "0.9920426683053614",
      "sw": "0.9623510016875042",
      "tr": "0.9899987616845124",
      "vi": "0.9938416636663944"
    },
    "canonical_solution": "{\n    HashSet<int> uniqueNumbers = new HashSet<int>(numbers);\n    List<int> sortedNumbers = new List<int>(uniqueNumbers);\n    sortedNumbers.Sort();\n    return sortedNumbers;\n}",
    "instruction": {
      "es": "static List<int> UniqueAndSorted(List<int> numbers)\n{\n    HashSet<int> uniqueNumbers = new HashSet<int>(numbers);\n    List<int> sortedNumbers = new List<int>(uniqueNumbers);\n    sortedNumbers.Sort();\n    return sortedNumbers;\n}\n\nProporcione una descripción concisa en lenguaje natural (docstring) del código C# en español utilizando como máximo 500 caracteres.",
      "arb": "static List<int> UniqueAndSorted(List<int> numbers)\n{\n    HashSet<int> uniqueNumbers = new HashSet<int>(numbers);\n    List<int> sortedNumbers = new List<int>(uniqueNumbers);\n    sortedNumbers.Sort();\n    return sortedNumbers;\n}\n\nيرجى تقديم وصف موجز بلغة طبيعية (docstring) للكود المكتوب بلغة C# باللغة العربية الفصحى، بحيث لا يتجاوز 500 حرف.",
      "sw": "static List<int> UniqueAndSorted(List<int> numbers)\n{\n    HashSet<int> uniqueNumbers = new HashSet<int>(numbers);\n    List<int> sortedNumbers = new List<int>(uniqueNumbers);\n    sortedNumbers.Sort();\n    return sortedNumbers;\n}\n\nToa maelezo mafupi ya lugha ya asili (docstring) ya msimbo wa C# kwa Kiswahili kwa kutumia herufi zisizozidi 500.",
      "tr": "static List<int> UniqueAndSorted(List<int> numbers)\n{\n    HashSet<int> uniqueNumbers = new HashSet<int>(numbers);\n    List<int> sortedNumbers = new List<int>(uniqueNumbers);\n    sortedNumbers.Sort();\n    return sortedNumbers;\n}\n\nC# kodunun işlevselliğini açıklayan en fazla 500 karakterlik özlü bir doğal dil açıklaması (docstring) sağlayın.",
      "vi": "static List<int> UniqueAndSorted(List<int> numbers)\n{\n    HashSet<int> uniqueNumbers = new HashSet<int>(numbers);\n    List<int> sortedNumbers = new List<int>(uniqueNumbers);\n    sortedNumbers.Sort();\n    return sortedNumbers;\n}\n\nCung cấp mô tả ngắn gọn bằng ngôn ngữ tự nhiên (docstring) cho mã C# bằng tiếng Việt, sử dụng tối đa 500 ký tự."
    },
    "instruction_bertscore": {
      "es": "0.9702167647764858",
      "arb": "0.8716935135882278",
      "sw": "0.918288824262535",
      "tr": "0.8866275387863358",
      "vi": "0.9298151466436084"
    },
    "level": "",
    "test": "static void Main()\n    {\n        Debug.Assert(UniqueAndSorted(new List<int> { 3, 1, 2, 1 }) .SequenceEqual(new List<int> { 1, 2, 3 }));\n        Debug.Assert(UniqueAndSorted(new List<int> { 5, 4, 5, 4, 5 }) .SequenceEqual(new List<int> { 4, 5 }));\n        Debug.Assert(UniqueAndSorted(new List<int> { 8, 7, 9, 6, 10 }) .SequenceEqual(new List<int> { 6, 7, 8, 9, 10 }));\n        Debug.Assert(UniqueAndSorted(new List<int> { 11, 11, 11 }) .SequenceEqual(new List<int> { 11 }));\n        Debug.Assert(UniqueAndSorted(new List<int> { 15, 14, 13, 12, 11, 15, 14 }) .SequenceEqual(new List<int> { 11, 12, 13, 14, 15 }));\n\n    }\n}",
    "entry_point": "UniqueAndSorted",
    "signature": "static List<int> UniqueAndSorted(List<int> numbers)",
    "docstring": {
      "es": "Esta función toma una lista de enteros y realiza dos operaciones. En primer lugar, elimina cualquier número duplicado, asegurando que cada número sea único. En segundo lugar, ordena los números restantes en orden ascendente.\n    Ejemplo de uso:\n    >>> UniqueAndSorted(new List<int> {4, 2, 2, 5, 1})\n    [1, 2, 4, 5]\n    >>> UniqueAndSorted(new List<int> {10, 9, 8, 7, 8, 9, 10})\n    [7, 8, 9, 10]",
      "arb": "هذه الدالة تأخذ قائمة من الأعداد الصحيحة وتقوم بعمليتين. أولاً، تزيل أي أرقام مكررة، مما يضمن أن كل رقم فريد. ثانياً، تقوم بترتيب الأرقام المتبقية بترتيب تصاعدي.\n    مثال على الاستخدام:\n    >>> UniqueAndSorted(new List<int> {4, 2, 2, 5, 1})\n    [1, 2, 4, 5]\n    >>> UniqueAndSorted(new List<int> {10, 9, 8, 7, 8, 9, 10})\n    [7, 8, 9, 10]",
      "sw": "Kazi ya hii ni kuchukua orodha ya namba za mzima na kufanya shughuli mbili. Kwanza, inaondoa namba zozote zinazojirudia, kuhakikisha kila namba ni ya kipekee. Pili, inapanga namba zilizobaki kwa mpangilio wa kuongezeka.\n    Matumizi ya mfano:\n    >>> UniqueAndSorted(new List<int> {4, 2, 2, 5, 1})\n    [1, 2, 4, 5]\n    >>> UniqueAndSorted(new List<int> {10, 9, 8, 7, 8, 9, 10})\n    [7, 8, 9, 10]",
      "tr": "Bu fonksiyon bir tamsayı listesini alır ve iki işlem gerçekleştirir. İlk olarak, her sayının benzersiz olmasını sağlayarak yinelenen sayıları kaldırır. İkinci olarak, kalan sayıları artan sırayla sıralar.\n    Örnek kullanım:\n    >>> UniqueAndSorted(new List<int> {4, 2, 2, 5, 1})\n    [1, 2, 4, 5]\n    >>> UniqueAndSorted(new List<int> {10, 9, 8, 7, 8, 9, 10})\n    [7, 8, 9, 10]",
      "vi": "Hàm này nhận một danh sách các số nguyên và thực hiện hai thao tác. Thứ nhất, nó loại bỏ bất kỳ số trùng lặp nào, đảm bảo mỗi số là duy nhất. Thứ hai, nó sắp xếp các số còn lại theo thứ tự tăng dần.\n    Ví dụ sử dụng:\n    >>> UniqueAndSorted(new List<int> {4, 2, 2, 5, 1})\n    [1, 2, 4, 5]\n    >>> UniqueAndSorted(new List<int> {10, 9, 8, 7, 8, 9, 10})\n    [7, 8, 9, 10]"
    },
    "docstring_bertscore": {
      "es": "0.9829952530796032",
      "arb": "0.9847149949186033",
      "sw": "1",
      "tr": "0.9887013080355924",
      "vi": "0.9966626123378518"
    }
  },
  {
    "task_id": "C#/15",
    "prompt": {
      "es": "using System;\nusing System.Collections.Generic;\nusing System.Diagnostics;\n\nclass Program\n{\n/* Esta función premia a los 5 mejores estudiantes basándose en sus puntuaciones totales. Los estudiantes se ordenan primero por su puntuación total (Chino, Matemáticas, Inglés),\n   luego por su puntuación en Chino, y finalmente por su ID de estudiante en caso de empate. La función devuelve una lista de los 5 mejores estudiantes con sus IDs y puntuaciones totales.\n   Ejemplo:\n   >>> AwardTopStudents([(1, 80, 90, 85), (2, 85, 80, 90), (3, 90, 85, 80)])\n   [(3, 255), (2, 255), (1, 255)]\n   >>> AwardTopStudents([(4, 88, 75, 95), (5, 95, 88, 75)])\n   [(4, 258), (5, 258)]\n*/\n   static List<(int, int)> AwardTopStudents(List<(int, int, int, int)> students)",
      "arb": "using System;\nusing System.Collections.Generic;\nusing System.Diagnostics;\n\nclass Program\n{\n/* تقوم هذه الدالة بمنح الجوائز لأفضل 5 طلاب بناءً على مجموع درجاتهم. يتم ترتيب الطلاب أولاً حسب مجموع درجاتهم (الصينية، الرياضيات، الإنجليزية)،\n   ثم حسب درجة اللغة الصينية، وأخيراً حسب معرف الطالب في حالة التعادل. تُرجع الدالة قائمة بأفضل 5 طلاب مع معرفاتهم ومجموع درجاتهم.\n   مثال:\n   >>> AwardTopStudents([(1, 80, 90, 85), (2, 85, 80, 90), (3, 90, 85, 80)])\n   [(3, 255), (2, 255), (1, 255)]\n   >>> AwardTopStudents([(4, 88, 75, 95), (5, 95, 88, 75)])\n   [(4, 258), (5, 258)]\n*/\n   static List<(int, int)> AwardTopStudents(List<(int, int, int, int)> students)",
      "sw": "using System;\nusing System.Collections.Generic;\nusing System.Diagnostics;\n\nclass Program\n{\n/* Kazi ya hii kazi ni kutoa tuzo kwa wanafunzi 5 bora kulingana na jumla ya alama zao. Wanafunzi wanapangwa kwanza kwa jumla ya alama zao (Kichina, Hisabati, Kiingereza),\n   kisha kwa alama zao za Kichina, na hatimaye kwa kitambulisho cha mwanafunzi ikiwa kuna sare. Kazi hii inarudisha orodha ya wanafunzi 5 bora na vitambulisho vyao na jumla ya alama zao.\n   Mfano:\n   >>> AwardTopStudents([(1, 80, 90, 85), (2, 85, 80, 90), (3, 90, 85, 80)])\n   [(3, 255), (2, 255), (1, 255)]\n   >>> AwardTopStudents([(4, 88, 75, 95), (5, 95, 88, 75)])\n   [(4, 258), (5, 258)]\n*/\n   static List<(int, int)> AwardTopStudents(List<(int, int, int, int)> students)",
      "tr": "using System;\nusing System.Collections.Generic;\nusing System.Diagnostics;\n\nclass Program\n{\n/* Bu fonksiyon, toplam puanlarına göre en iyi 5 öğrenciyi ödüllendirir. Öğrenciler önce toplam puanlarına (Çince, Matematik, İngilizce),\n   sonra Çince puanlarına ve son olarak eşitlik durumunda öğrenci kimlik numaralarına göre sıralanır. Fonksiyon, en iyi 5 öğrencinin kimlik numaralarını ve toplam puanlarını içeren bir liste döndürür.\n   Örnek:\n   >>> AwardTopStudents([(1, 80, 90, 85), (2, 85, 80, 90), (3, 90, 85, 80)])\n   [(3, 255), (2, 255), (1, 255)]\n   >>> AwardTopStudents([(4, 88, 75, 95), (5, 95, 88, 75)])\n   [(4, 258), (5, 258)]\n*/\n   static List<(int, int)> AwardTopStudents(List<(int, int, int, int)> students)",
      "vi": "using System;\nusing System.Collections.Generic;\nusing System.Diagnostics;\n\nclass Program\n{\n/* Hàm này trao thưởng cho 5 học sinh có tổng điểm cao nhất. Học sinh được sắp xếp trước tiên theo tổng điểm (Tiếng Trung, Toán, Tiếng Anh),\n   sau đó theo điểm Tiếng Trung, và cuối cùng theo mã học sinh nếu có điểm bằng nhau. Hàm trả về danh sách 5 học sinh đứng đầu với mã học sinh và tổng điểm của họ.\n   Ví dụ:\n   >>> AwardTopStudents([(1, 80, 90, 85), (2, 85, 80, 90), (3, 90, 85, 80)])\n   [(3, 255), (2, 255), (1, 255)]\n   >>> AwardTopStudents([(4, 88, 75, 95), (5, 95, 88, 75)])\n   [(4, 258), (5, 258)]\n*/\n   static List<(int, int)> AwardTopStudents(List<(int, int, int, int)> students)"
    },
    "prompt_bertscore": {
      "es": "0.9863495243241394",
      "arb": "0.9886665477189114",
      "sw": "0.9687844410988432",
      "tr": "0.9734089536300975",
      "vi": "0.9737355019765188"
    },
    "canonical_solution": "{\n    List<(int, int)> res = students\n        .Select(s => (s.Item1, TotalScore: s.Item2 + s.Item3 + s.Item4))\n        .OrderByDescending(s => s.TotalScore)\n        .ThenByDescending(s => students.First(st => st.Item1 == s.Item1).Item2)\n        .ThenBy(s => s.Item1)\n        .Take(5)\n        .ToList();\n\n    return res;\n}",
    "instruction": {
      "es": "static List<(int, int)> AwardTopStudents(List<(int, int, int, int)> students)\n{\n    List<(int, int)> res = students\n        .Select(s => (s.Item1, TotalScore: s.Item2 + s.Item3 + s.Item4))\n        .OrderByDescending(s => s.TotalScore)\n        .ThenByDescending(s => students.First(st => st.Item1 == s.Item1).Item2)\n        .ThenBy(s => s.Item1)\n        .Take(5)\n        .ToList();\n\n    return res;\n}\n\nProporcione una descripción concisa en lenguaje natural (docstring) del código C# en español utilizando un máximo de 500 caracteres.",
      "arb": "static List<(int, int)> AwardTopStudents(List<(int, int, int, int)> students)\n{\n    List<(int, int)> res = students\n        .Select(s => (s.Item1, TotalScore: s.Item2 + s.Item3 + s.Item4))\n        .OrderByDescending(s => s.TotalScore)\n        .ThenByDescending(s => students.First(st => st.Item1 == s.Item1).Item2)\n        .ThenBy(s => s.Item1)\n        .Take(5)\n        .ToList();\n\n    return res;\n}\n\nيرجى تقديم وصف موجز بلغة طبيعية (docstring) للكود المكتوب بلغة C# باللغة العربية الفصحى، بحيث لا يتجاوز 500 حرف.",
      "sw": "static List<(int, int)> AwardTopStudents(List<(int, int, int, int)> students)\n{\n    List<(int, int)> res = students\n        .Select(s => (s.Item1, TotalScore: s.Item2 + s.Item3 + s.Item4))\n        .OrderByDescending(s => s.TotalScore)\n        .ThenByDescending(s => students.First(st => st.Item1 == s.Item1).Item2)\n        .ThenBy(s => s.Item1)\n        .Take(5)\n        .ToList();\n\n    return res;\n}\n\nToa maelezo mafupi ya lugha asilia (docstring) ya msimbo wa C# kwa Kiswahili kwa kutumia herufi zisizozidi 500.",
      "tr": "static List<(int, int)> AwardTopStudents(List<(int, int, int, int)> students)\n{\n    List<(int, int)> res = students\n        .Select(s => (s.Item1, TotalScore: s.Item2 + s.Item3 + s.Item4))\n        .OrderByDescending(s => s.TotalScore)\n        .ThenByDescending(s => students.First(st => st.Item1 == s.Item1).Item2)\n        .ThenBy(s => s.Item1)\n        .Take(5)\n        .ToList();\n\n    return res;\n}\n\nAşağıdaki C# kodunun Türkçe dilinde, en fazla 500 karakter kullanarak kısa bir doğal dil açıklamasını (docstring) sağlayın.",
      "vi": "static List<(int, int)> AwardTopStudents(List<(int, int, int, int)> students)\n{\n    List<(int, int)> res = students\n        .Select(s => (s.Item1, TotalScore: s.Item2 + s.Item3 + s.Item4))\n        .OrderByDescending(s => s.TotalScore)\n        .ThenByDescending(s => students.First(st => st.Item1 == s.Item1).Item2)\n        .ThenBy(s => s.Item1)\n        .Take(5)\n        .ToList();\n\n    return res;\n}\n\nCung cấp mô tả ngắn gọn bằng ngôn ngữ tự nhiên (docstring) cho mã C# bằng tiếng Việt, sử dụng tối đa 500 ký tự."
    },
    "instruction_bertscore": {
      "es": "0.9702167647764858",
      "arb": "0.8716935135882278",
      "sw": "0.9446027812508938",
      "tr": "0.8909997907336757",
      "vi": "0.912055207014517"
    },
    "level": "",
    "test": "    static void Main()\n    {\n        // Test Case 1\n        Debug.Assert(AwardTopStudents(new List<(int, int, int, int)> { (1, 80, 90, 85), (2, 85, 80, 90), (3, 90, 85, 80) }).SequenceEqual(new List<(int, int)> { (3, 255), (2, 255), (1, 255) }));\n\n        // Test Case 2\n        Debug.Assert(AwardTopStudents(new List<(int, int, int, int)> { (4, 88, 75, 95), (5, 95, 88, 75) }).SequenceEqual(new List<(int, int)> { (5, 258), (4, 258) }));\n\n        // Test Case 3\n        Debug.Assert(AwardTopStudents(new List<(int, int, int, int)> { (6, 75, 85, 90), (7, 90, 75, 85) }).SequenceEqual(new List<(int, int)> { (7, 250), (6, 250) }));\n\n        // Test Case 4\n        Debug.Assert(AwardTopStudents(new List<(int, int, int, int)> { (8, 80, 90, 80), (9, 90, 80, 80) }).SequenceEqual(new List<(int, int)> { (9, 250), (8, 250) }));\n\n        // Test Case 5\n        Debug.Assert(AwardTopStudents(new List<(int, int, int, int)> { (10, 85, 85, 85), (11, 86, 85, 84), (12, 84, 86, 85) }).SequenceEqual(new List<(int, int)> { (11, 255), (10, 255), (12, 255) }));\n        }\n}\n",
    "entry_point": "AwardTopStudents",
    "signature": "static List<(int, int)> AwardTopStudents(List<(int, int, int, int)> students)",
    "docstring": {
      "es": "Esta función premia a los 5 mejores estudiantes basándose en sus puntuaciones totales. Los estudiantes se ordenan primero por su puntuación total (Chino, Matemáticas, Inglés), luego por su puntuación en Chino, y finalmente por su ID de estudiante en caso de empate. La función devuelve una lista de los 5 mejores estudiantes con sus IDs y puntuaciones totales.\n   Ejemplo:\n   >>> AwardTopStudents([(1, 80, 90, 85), (2, 85, 80, 90), (3, 90, 85, 80)])\n   [(3, 255), (2, 255), (1, 255)]\n   >>> AwardTopStudents([(4, 88, 75, 95), (5, 95, 88, 75)])\n   [(4, 258), (5, 258)]",
      "arb": "هذه الدالة تمنح الجوائز لأفضل 5 طلاب بناءً على إجمالي درجاتهم. يتم ترتيب الطلاب أولاً حسب إجمالي درجاتهم (الصينية، الرياضيات، الإنجليزية)، ثم حسب درجاتهم في اللغة الصينية، وأخيراً حسب معرف الطالب في حالة التعادل. تعيد الدالة قائمة بأفضل 5 طلاب مع معرفاتهم وإجمالي درجاتهم.\nمثال:\n>>> AwardTopStudents([(1, 80, 90, 85), (2, 85, 80, 90), (3, 90, 85, 80)])\n[(3, 255), (2, 255), (1, 255)]\n>>> AwardTopStudents([(4, 88, 75, 95), (5, 95, 88, 75)])\n[(4, 258), (5, 258)]",
      "sw": "Kazi hii inatoa tuzo kwa wanafunzi 5 bora kulingana na alama zao jumla. Wanafunzi wanapangwa kwanza kwa alama zao jumla (Kichina, Hisabati, Kiingereza), kisha kwa alama zao za Kichina, na hatimaye kwa kitambulisho cha mwanafunzi ikiwa kuna sare. Kazi hii inarejesha orodha ya wanafunzi 5 bora na vitambulisho vyao na alama jumla.\nMfano:\n>>> AwardTopStudents([(1, 80, 90, 85), (2, 85, 80, 90), (3, 90, 85, 80)])\n[(3, 255), (2, 255), (1, 255)]\n>>> AwardTopStudents([(4, 88, 75, 95), (5, 95, 88, 75)])\n[(4, 258), (5, 258)]",
      "tr": "Bu fonksiyon, toplam puanlarına göre en iyi 5 öğrenciyi ödüllendirir. Öğrenciler önce toplam puanlarına (Çince, Matematik, İngilizce), sonra Çince puanlarına ve eşitlik durumunda öğrenci kimlik numaralarına göre sıralanır. Fonksiyon, en iyi 5 öğrencinin kimlik numaralarını ve toplam puanlarını içeren bir liste döndürür.\nÖrnek:\n>>> AwardTopStudents([(1, 80, 90, 85), (2, 85, 80, 90), (3, 90, 85, 80)])\n[(3, 255), (2, 255), (1, 255)]\n>>> AwardTopStudents([(4, 88, 75, 95), (5, 95, 88, 75)])\n[(4, 258), (5, 258)]",
      "vi": "Hàm này trao thưởng cho 5 học sinh đứng đầu dựa trên tổng điểm của họ. Học sinh được sắp xếp trước tiên theo tổng điểm (Ngữ văn, Toán, Tiếng Anh), sau đó theo điểm Ngữ văn, và cuối cùng theo mã số học sinh nếu có điểm bằng nhau. Hàm trả về danh sách 5 học sinh đứng đầu với mã số và tổng điểm của họ.\n   Ví dụ:\n   >>> AwardTopStudents([(1, 80, 90, 85), (2, 85, 80, 90), (3, 90, 85, 80)])\n   [(3, 255), (2, 255), (1, 255)]\n   >>> AwardTopStudents([(4, 88, 75, 95), (5, 95, 88, 75)])\n   [(4, 258), (5, 258)]"
    },
    "docstring_bertscore": {
      "es": "0.9934169919117417",
      "arb": "0.9842309326800213",
      "sw": "0.9793064882734043",
      "tr": "0.9667580139515253",
      "vi": "0.9640947778026094"
    }
  },
  {
    "task_id": "C#/16",
    "prompt": {
      "es": "using System;\nusing System.Collections.Generic;\nusing System.Diagnostics;\n\nclass Program\n{\n/* \n    Determinar el número mínimo de grupos necesarios para distribuir recuerdos donde cada grupo puede tener como máximo dos recuerdos y el precio total de los recuerdos en un grupo no puede exceder un límite especificado.\n    Ejemplo:\n    >>> MinimumGroups(new List<int> { 15, 20, 10, 30, 40 }, 50)\n    3\n    >>> MinimumGroups(new List<int> { 5, 20, 25, 10 }, 30)\n    2\n*/\n   \nstatic int MinimumGroups(List<int> souvenirPrices, int maxPriceSum)",
      "arb": "using System;\nusing System.Collections.Generic;\nusing System.Diagnostics;\n\nclass Program\n{\n/* \n    تحديد الحد الأدنى لعدد المجموعات اللازمة لتوزيع الهدايا التذكارية حيث يمكن أن تحتوي كل مجموعة على ما لا يزيد عن هديتين تذكاريتين ولا يمكن أن يتجاوز السعر الإجمالي للهدايا التذكارية في مجموعة حدًا محددًا.\n    مثال:\n    >>> MinimumGroups(new List<int> { 15, 20, 10, 30, 40 }, 50)\n    3\n    >>> MinimumGroups(new List<int> { 5, 20, 25, 10 }, 30)\n    2\n*/\n   \nstatic int MinimumGroups(List<int> souvenirPrices, int maxPriceSum)",
      "sw": "using System;\nusing System.Collections.Generic;\nusing System.Diagnostics;\n\nclass Program\n{\n/* \n    Kuamua idadi ndogo ya vikundi vinavyohitajika kusambaza zawadi ambapo kila kikundi kinaweza kuwa na zawadi zisizozidi mbili na jumla ya bei ya zawadi katika kikundi haiwezi kuzidi kikomo kilichobainishwa.\n    Mfano:\n    >>> MinimumGroups(new List<int> { 15, 20, 10, 30, 40 }, 50)\n    3\n    >>> MinimumGroups(new List<int> { 5, 20, 25, 10 }, 30)\n    2\n*/\n   \nstatic int MinimumGroups(List<int> souvenirPrices, int maxPriceSum)",
      "tr": "using System;\nusing System.Collections.Generic;\nusing System.Diagnostics;\n\nclass Program\n{\n/* \n    Her grubun en fazla iki hatıra eşyası alabileceği ve bir gruptaki hatıra eşyalarının toplam fiyatının belirtilen bir limiti aşamayacağı şekilde hatıra eşyalarını dağıtmak için gereken minimum grup sayısını belirleyin.\n    Örnek:\n    >>> MinimumGroups(new List<int> { 15, 20, 10, 30, 40 }, 50)\n    3\n    >>> MinimumGroups(new List<int> { 5, 20, 25, 10 }, 30)\n    2\n*/\n   \nstatic int MinimumGroups(List<int> souvenirPrices, int maxPriceSum)",
      "vi": "using System;\nusing System.Collections.Generic;\nusing System.Diagnostics;\n\nclass Program\n{\n/* \n    Xác định số lượng nhóm tối thiểu cần thiết để phân phối quà lưu niệm, trong đó mỗi nhóm có thể có tối đa hai quà lưu niệm và tổng giá của quà lưu niệm trong một nhóm không được vượt quá một giới hạn đã chỉ định.\n    Ví dụ:\n    >>> MinimumGroups(new List<int> { 15, 20, 10, 30, 40 }, 50)\n    3\n    >>> MinimumGroups(new List<int> { 5, 20, 25, 10 }, 30)\n    2\n*/\n   \nstatic int MinimumGroups(List<int> souvenirPrices, int maxPriceSum)"
    },
    "prompt_bertscore": {
      "es": "0.9973447090663257",
      "arb": "0.9822178137682327",
      "sw": "0.969016838644654",
      "tr": "0.9821985466212723",
      "vi": "0.9770353484966514"
    },
    "canonical_solution": "{\n    souvenirPrices.Sort();\n    int i = 0, j = souvenirPrices.Count - 1, groups = 0;\n    while (i <= j)\n    {\n        if (souvenirPrices[i] + souvenirPrices[j] <= maxPriceSum)\n        {\n            i++; \n        }\n        j--;\n        groups++;\n    }\n    return groups;\n}",
    "instruction": {
      "es": "static int MinimumGroups(List<int> souvenirPrices, int maxPriceSum)\n{\n    souvenirPrices.Sort();\n    int i = 0, j = souvenirPrices.Count - 1, groups = 0;\n    while (i <= j)\n    {\n        if (souvenirPrices[i] + souvenirPrices[j] <= maxPriceSum)\n        {\n            i++; \n        }\n        j--;\n        groups++;\n    }\n    return groups;\n}\n\nProporcione una descripción concisa en lenguaje natural (docstring) del código C# en español utilizando como máximo 500 caracteres.",
      "arb": "static int MinimumGroups(List<int> souvenirPrices, int maxPriceSum)\n{\n    souvenirPrices.Sort();\n    int i = 0, j = souvenirPrices.Count - 1, groups = 0;\n    while (i <= j)\n    {\n        if (souvenirPrices[i] + souvenirPrices[j] <= maxPriceSum)\n        {\n            i++; \n        }\n        j--;\n        groups++;\n    }\n    return groups;\n}\n\nيرجى تقديم وصف موجز بلغة طبيعية (docstring) للكود المكتوب بلغة C# باللغة العربية الفصحى، بحيث لا يتجاوز 500 حرف.",
      "sw": "static int MinimumGroups(List<int> souvenirPrices, int maxPriceSum)\n{\n    souvenirPrices.Sort();\n    int i = 0, j = souvenirPrices.Count - 1, groups = 0;\n    while (i <= j)\n    {\n        if (souvenirPrices[i] + souvenirPrices[j] <= maxPriceSum)\n        {\n            i++; \n        }\n        j--;\n        groups++;\n    }\n    return groups;\n}\n\nToa maelezo mafupi ya lugha ya asili (docstring) ya msimbo wa C# kwa Kiswahili kwa kutumia herufi zisizozidi 500.",
      "tr": "static int MinimumGroups(List<int> souvenirPrices, int maxPriceSum)\n{\n    souvenirPrices.Sort();\n    int i = 0, j = souvenirPrices.Count - 1, groups = 0;\n    while (i <= j)\n    {\n        if (souvenirPrices[i] + souvenirPrices[j] <= maxPriceSum)\n        {\n            i++; \n        }\n        j--;\n        groups++;\n    }\n    return groups;\n}\n\nAşağıdaki C# kodunun Türkçe olarak en fazla 500 karakter kullanarak kısa bir doğal dil açıklamasını (docstring) sağlayın.",
      "vi": "static int MinimumGroups(List<int> souvenirPrices, int maxPriceSum)\n{\n    souvenirPrices.Sort();\n    int i = 0, j = souvenirPrices.Count - 1, groups = 0;\n    while (i <= j)\n    {\n        if (souvenirPrices[i] + souvenirPrices[j] <= maxPriceSum)\n        {\n            i++; \n        }\n        j--;\n        groups++;\n    }\n    return groups;\n}\n\nCung cấp mô tả ngắn gọn bằng ngôn ngữ tự nhiên (docstring) cho mã C# bằng tiếng Việt với tối đa 500 ký tự."
    },
    "instruction_bertscore": {
      "es": "0.9702167647764858",
      "arb": "0.8829437397396628",
      "sw": "0.918288824262535",
      "tr": "0.8916963874799652",
      "vi": "0.9066002208601559"
    },
    "level": "",
    "test": "    static void Main()\n    {\n        Debug.Assert(MinimumGroups(new List<int> { 15, 20, 10, 30, 40 }, 50) == 3);\n        Debug.Assert(MinimumGroups(new List<int> { 5, 20, 25, 10 }, 30) == 2);\n        Debug.Assert(MinimumGroups(new List<int> { 10, 20, 30, 40, 50 }, 60) == 3);\n        Debug.Assert(MinimumGroups(new List<int> { 25, 30, 35, 5, 15, 20 }, 40) == 4);\n        Debug.Assert(MinimumGroups(new List<int> { 32, 42, 52, 12, 22 }, 70) == 3);\n        Debug.Assert(MinimumGroups(new List<int> { 30, 35, 40, 10, 15, 20, 25}, 45) == 4);\n        Debug.Assert(MinimumGroups(new List<int> { 5, 10, 15, 20, 25 }, 30) == 3);\n\n    }\n}\n",
    "entry_point": "MinimumGroups",
    "signature": "static int MinimumGroups(List<int> souvenirPrices, int maxPriceSum)",
    "docstring": {
      "es": "Determinar el número mínimo de grupos necesarios para distribuir recuerdos donde cada grupo puede tener como máximo dos recuerdos y el precio total de los recuerdos en un grupo no puede exceder un límite especificado.\n    Ejemplo:\n    >>> MinimumGroups(new List<int> { 15, 20, 10, 30, 40 }, 50)\n    3\n    >>> MinimumGroups(new List<int> { 5, 20, 25, 10 }, 30)\n    2",
      "arb": "تحديد الحد الأدنى لعدد المجموعات اللازمة لتوزيع التذكارات حيث يمكن لكل مجموعة أن تحتوي على تذكارتين كحد أقصى ولا يمكن أن يتجاوز السعر الإجمالي للتذكارات في مجموعة حدًا محددًا.\n    مثال:\n    >>> MinimumGroups(new List<int> { 15, 20, 10, 30, 40 }, 50)\n    3\n    >>> MinimumGroups(new List<int> { 5, 20, 25, 10 }, 30)\n    2",
      "sw": "Amua idadi ndogo ya vikundi vinavyohitajika kugawa zawadi ambapo kila kikundi kinaweza kuwa na zawadi zisizozidi mbili na jumla ya bei ya zawadi katika kikundi haiwezi kuzidi kikomo kilichobainishwa.\n    Mfano:\n    >>> MinimumGroups(new List<int> { 15, 20, 10, 30, 40 }, 50)\n    3\n    >>> MinimumGroups(new List<int> { 5, 20, 25, 10 }, 30)\n    2",
      "tr": "Hediyelik eşyaları dağıtmak için gereken minimum grup sayısını belirleyin; burada her grup en fazla iki hediyelik eşya içerebilir ve bir gruptaki hediyelik eşyaların toplam fiyatı belirtilen bir limiti aşamaz.\n    Örnek:\n    >>> MinimumGroups(new List<int> { 15, 20, 10, 30, 40 }, 50)\n    3\n    >>> MinimumGroups(new List<int> { 5, 20, 25, 10 }, 30)\n    2",
      "vi": "Xác định số lượng nhóm tối thiểu cần thiết để phân phối quà lưu niệm, trong đó mỗi nhóm có thể có tối đa hai quà lưu niệm và tổng giá của quà lưu niệm trong một nhóm không được vượt quá một giới hạn đã chỉ định.\n    Ví dụ:\n    >>> MinimumGroups(new List<int> { 15, 20, 10, 30, 40 }, 50)\n    3\n    >>> MinimumGroups(new List<int> { 5, 20, 25, 10 }, 30)\n    2"
    },
    "docstring_bertscore": {
      "es": "0.9846214400091359",
      "arb": "0.9785250763544131",
      "sw": "0.9518142558647464",
      "tr": "0.973781981485681",
      "vi": "0.9712635468845396"
    }
  },
  {
    "task_id": "C#/17",
    "prompt": {
      "es": "using System;\nusing System.Collections.Generic;\nusing System.Diagnostics;\n\nclass Program\n{\n/* Calcular el número inicial de melocotones que tenía un mono, dado que cada día come la mitad de los melocotones más uno más, y en el día N solo queda un melocotón.\n    Ejemplos:\n    >>> InitialPeachesCount(1)\n    1\n    >>> InitialPeachesCount(2)\n    4\n    >>> InitialPeachesCount(3)\n    10\n*/\n   \n   static int InitialPeachesCount(int days)",
      "arb": "using System;\nusing System.Collections.Generic;\nusing System.Diagnostics;\n\nclass Program\n{\n/* حساب العدد الأولي من الخوخ الذي كان لدى القرد، مع العلم أنه في كل يوم يأكل نصف الخوخ بالإضافة إلى واحدة أخرى، وفي اليوم N يتبقى خوخة واحدة فقط.\n    أمثلة:\n    >>> InitialPeachesCount(1)\n    1\n    >>> InitialPeachesCount(2)\n    4\n    >>> InitialPeachesCount(3)\n    10\n*/\n   \n   static int InitialPeachesCount(int days)",
      "sw": "using System;\nusing System.Collections.Generic;\nusing System.Diagnostics;\n\nclass Program\n{\n/* Hesabu idadi ya awali ya pichi ambazo tumbili alikuwa nazo, ikizingatiwa kwamba kila siku anakula nusu ya pichi pamoja na moja zaidi, na katika siku ya N pichi moja tu imebaki.\n    Mifano:\n    >>> InitialPeachesCount(1)\n    1\n    >>> InitialPeachesCount(2)\n    4\n    >>> InitialPeachesCount(3)\n    10\n*/\n   \n   static int InitialPeachesCount(int days)",
      "tr": "using System;\nusing System.Collections.Generic;\nusing System.Diagnostics;\n\nclass Program\n{\n/* Bir maymunun başlangıçta kaç tane şeftaliye sahip olduğunu hesaplayın, her gün şeftalilerin yarısını artı bir tane daha yediği ve N. günde sadece bir şeftali kaldığı verilmiştir.\n    Örnekler:\n    >>> InitialPeachesCount(1)\n    1\n    >>> InitialPeachesCount(2)\n    4\n    >>> InitialPeachesCount(3)\n    10\n*/\n   \n   static int InitialPeachesCount(int days)",
      "vi": "using System;\nusing System.Collections.Generic;\nusing System.Diagnostics;\n\nclass Program\n{\n/* Tính số lượng quả đào ban đầu mà một con khỉ có, cho biết rằng mỗi ngày nó ăn một nửa số quả đào cộng thêm một quả nữa, và vào ngày thứ N chỉ còn lại một quả đào.\n    Ví dụ:\n    >>> InitialPeachesCount(1)\n    1\n    >>> InitialPeachesCount(2)\n    4\n    >>> InitialPeachesCount(3)\n    10\n*/\n   \n   static int InitialPeachesCount(int days)"
    },
    "prompt_bertscore": {
      "es": "0.9824214099087935",
      "arb": "0.9765731355999833",
      "sw": "0.9778409933221289",
      "tr": "0.9777919316180133",
      "vi": "0.9861850583686425"
    },
    "canonical_solution": "{\n    int peaches = 1; // Start with 1 peach on the last day\n    for (int day = 1; day < days; day++)\n    {\n        peaches = 2 * (peaches + 1); // Double and add two for each previous day\n    }\n    return peaches;\n}",
    "instruction": {
      "es": "static int InitialPeachesCount(int days)\n{\n    int peaches = 1; // Start with 1 peach on the last day\n    for (int day = 1; day < days; day++)\n    {\n        peaches = 2 * (peaches + 1); // Double and add two for each previous day\n    }\n    return peaches;\n}\n\nProporcione una descripción concisa en lenguaje natural (docstring) del código C# en español utilizando como máximo 500 caracteres.",
      "arb": "static int InitialPeachesCount(int days)\n{\n    int peaches = 1; // Start with 1 peach on the last day\n    for (int day = 1; day < days; day++)\n    {\n        peaches = 2 * (peaches + 1); // Double and add two for each previous day\n    }\n    return peaches;\n}\n\nيرجى تقديم وصف موجز بلغة طبيعية (docstring) للكود المكتوب بلغة C# باللغة العربية الفصحى، بحيث لا يتجاوز 500 حرف.",
      "sw": "static int InitialPeachesCount(int days)\n{\n    int peaches = 1; // Start with 1 peach on the last day\n    for (int day = 1; day < days; day++)\n    {\n        peaches = 2 * (peaches + 1); // Double and add two for each previous day\n    }\n    return peaches;\n}\n\nToa maelezo mafupi ya lugha ya asili (docstring) ya msimbo wa C# kwa Kiswahili kwa kutumia herufi zisizozidi 500.",
      "tr": "static int InitialPeachesCount(int days)\n{\n    int peaches = 1; // Start with 1 peach on the last day\n    for (int day = 1; day < days; day++)\n    {\n        peaches = 2 * (peaches + 1); // Double and add two for each previous day\n    }\n    return peaches;\n}\n\nC# kodunun Türkçe olarak en fazla 500 karakter kullanarak kısa bir doğal dil açıklamasını (docstring) sağlayın.",
      "vi": "static int InitialPeachesCount(int days)\n{\n    int peaches = 1; // Start with 1 peach on the last day\n    for (int day = 1; day < days; day++)\n    {\n        peaches = 2 * (peaches + 1); // Double and add two for each previous day\n    }\n    return peaches;\n}\n\nCung cấp mô tả ngắn gọn bằng ngôn ngữ tự nhiên (docstring) cho mã C# bằng tiếng Việt, không quá 500 ký tự."
    },
    "instruction_bertscore": {
      "es": "0.9702167647764858",
      "arb": "0.8829437397396628",
      "sw": "0.9446027812508938",
      "tr": "0.9401900087058227",
      "vi": "0.9093975325162702"
    },
    "level": "",
    "test": "    static void Main()\n    {\n        Debug.Assert(InitialPeachesCount(1) == 1);\n        Debug.Assert(InitialPeachesCount(2) == 4);\n        Debug.Assert(InitialPeachesCount(3) == 10);\n        Debug.Assert(InitialPeachesCount(4) == 22);\n\n\n    }\n}",
    "entry_point": "InitialPeachesCount",
    "signature": "static int InitialPeachesCount(int days)",
    "docstring": {
      "es": "Calcular el número inicial de duraznos que tenía un mono, dado que cada día come la mitad de los duraznos más uno más, y en el día N solo queda un durazno.\n    Ejemplos:\n    >>> InitialPeachesCount(1)\n    1\n    >>> InitialPeachesCount(2)\n    4\n    >>> InitialPeachesCount(3)\n    10",
      "arb": "احسب العدد الأولي للخوخ الذي كان لدى القرد، مع العلم أنه في كل يوم يأكل نصف الخوخ بالإضافة إلى واحدة أخرى، وفي اليوم N يتبقى خوخة واحدة فقط.\n    أمثلة:\n    >>> InitialPeachesCount(1)\n    1\n    >>> InitialPeachesCount(2)\n    4\n    >>> InitialPeachesCount(3)\n    10",
      "sw": "Hesabu idadi ya awali ya pichi ambazo tumbili alikuwa nazo, ikizingatiwa kwamba kila siku anakula nusu ya pichi pamoja na moja zaidi, na katika siku ya N moja tu ya pichi inabaki.\n    \n    Mifano:\n    >>> InitialPeachesCount(1)\n    1\n    >>> InitialPeachesCount(2)\n    4\n    >>> InitialPeachesCount(3)\n    10",
      "tr": "Başlangıçta bir maymunun kaç tane şeftaliye sahip olduğunu hesaplayın. Her gün şeftalilerin yarısını ve bir tane daha yediği ve N. günde sadece bir şeftalinin kaldığı varsayılır.\n    Örnekler:\n    >>> InitialPeachesCount(1)\n    1\n    >>> InitialPeachesCount(2)\n    4\n    >>> InitialPeachesCount(3)\n    10",
      "vi": "Tính số lượng đào ban đầu mà một con khỉ có, biết rằng mỗi ngày nó ăn một nửa số đào cộng thêm một quả nữa, và vào ngày thứ N chỉ còn lại một quả đào. \n    Ví dụ:\n    >>> InitialPeachesCount(1)\n    1\n    >>> InitialPeachesCount(2)\n    4\n    >>> InitialPeachesCount(3)\n    10"
    },
    "docstring_bertscore": {
      "es": "0.9836120004127166",
      "arb": "0.9696727161628312",
      "sw": "0.9702298743816341",
      "tr": "0.942856422940835",
      "vi": "0.9778398015398427"
    }
  },
  {
    "task_id": "C#/18",
    "prompt": {
      "es": "using System;\nusing System.Collections.Generic;\nusing System.Diagnostics;\n\nclass Program\n{\n    /* \n    FindAmicableNumbers - Encuentra todos los pares de números amigos dentro de un límite especificado.\n    Los números amigos son dos números diferentes relacionados de tal manera que la suma de los divisores propios de cada uno es igual al otro número.\n\n    Ejemplo de uso:\n    >>> FindAmicableNumbers(300)\n    >>> (220, 284)\n    */\nstatic List<(int, int)> FindAmicableNumbers(int limit)",
      "arb": "using System;\nusing System.Collections.Generic;\nusing System.Diagnostics;\n\nclass Program\n{\n    /* \n    FindAmicableNumbers - يجد جميع أزواج الأعداد المتحابّة ضمن حد معين.\n    الأعداد المتحابّة هي عددان مختلفان بحيث يكون مجموع القواسم الصحيحة لكل منهما مساوياً للعدد الآخر.\n\n    مثال على الاستخدام:\n    >>> FindAmicableNumbers(300)\n    >>> (220, 284)\n    */\nstatic List<(int, int)> FindAmicableNumbers(int limit)",
      "sw": "using System;\nusing System.Collections.Generic;\nusing System.Diagnostics;\n\nclass Program\n{\n    /* \n    FindAmicableNumbers - Inapata jozi zote za namba rafiki ndani ya kikomo kilichowekwa.\n    Namba rafiki ni namba mbili tofauti ambazo zinahusiana kwa njia kwamba jumla ya wagawanyaji sahihi wa kila moja ni sawa na namba nyingine.\n\n    Mfano wa matumizi:\n    >>> FindAmicableNumbers(300)\n    >>> (220, 284)\n    */\nstatic List<(int, int)> FindAmicableNumbers(int limit)",
      "tr": "using System;\nusing System.Collections.Generic;\nusing System.Diagnostics;\n\nclass Program\n{\n    /* \n    FindAmicableNumbers - Belirtilen bir sınır içinde tüm dost sayıları bulur.\n    Dost sayılar, her birinin uygun bölenlerinin toplamının diğer sayıya eşit olduğu iki farklı sayıdır.\n\n    Örnek kullanım:\n    >>> FindAmicableNumbers(300)\n    >>> (220, 284)\n    */\nstatic List<(int, int)> FindAmicableNumbers(int limit)",
      "vi": "using System;\nusing System.Collections.Generic;\nusing System.Diagnostics;\n\nclass Program\n{\n    /* \n    FindAmicableNumbers - Tìm tất cả các cặp số thân thiện trong một giới hạn được chỉ định.\n    Số thân thiện là hai số khác nhau có liên quan đến mức tổng của các ước số thực sự của mỗi số bằng với số kia.\n\n    Ví dụ sử dụng:\n    >>> FindAmicableNumbers(300)\n    >>> (220, 284)\n    */\nstatic List<(int, int)> FindAmicableNumbers(int limit)"
    },
    "prompt_bertscore": {
      "es": "0.9747189209930225",
      "arb": "0.9772166980345363",
      "sw": "0.9788639397844586",
      "tr": "0.9788212342525361",
      "vi": "0.9811803672880874"
    },
    "canonical_solution": "{\n    List<(int, int)> amicablePairs = new List<(int, int)>();\n    for (int i = 1; i <= limit; i++)\n    {\n        int sumOfDivisors = SumProperDivisors(i);\n        if (sumOfDivisors > i && sumOfDivisors <= limit)\n        {\n            if (SumProperDivisors(sumOfDivisors) == i)\n            {\n                amicablePairs.Add((i, sumOfDivisors));\n            }\n        }\n    }\n    return amicablePairs;\n}\n\nstatic int SumProperDivisors(int number)\n{\n    int sum = 0;\n    for (int i = 1; i <= number / 2; i++)\n    {\n        if (number % i == 0)\n        {\n            sum += i;\n        }\n    }\n    return sum;\n}",
    "instruction": {
      "es": "static List<(int, int)> FindAmicableNumbers(int limit)\n{\n    List<(int, int)> amicablePairs = new List<(int, int)>();\n    for (int i = 1; i <= limit; i++)\n    {\n        int sumOfDivisors = SumProperDivisors(i);\n        if (sumOfDivisors > i && sumOfDivisors <= limit)\n        {\n            if (SumProperDivisors(sumOfDivisors) == i)\n            {\n                amicablePairs.Add((i, sumOfDivisors));\n            }\n        }\n    }\n    return amicablePairs;\n}\n\nstatic int SumProperDivisors(int number)\n{\n    int sum = 0;\n    for (int i = 1; i <= number / 2; i++)\n    {\n        if (number % i == 0)\n        {\n            sum += i;\n        }\n    }\n    return sum;\n}\n\nProporcione una descripción concisa en lenguaje natural (docstring) del código C# en español utilizando un máximo de 500 caracteres.",
      "arb": "static List<(int, int)> FindAmicableNumbers(int limit)\n{\n    List<(int, int)> amicablePairs = new List<(int, int)>();\n    for (int i = 1; i <= limit; i++)\n    {\n        int sumOfDivisors = SumProperDivisors(i);\n        if (sumOfDivisors > i && sumOfDivisors <= limit)\n        {\n            if (SumProperDivisors(sumOfDivisors) == i)\n            {\n                amicablePairs.Add((i, sumOfDivisors));\n            }\n        }\n    }\n    return amicablePairs;\n}\n\nstatic int SumProperDivisors(int number)\n{\n    int sum = 0;\n    for (int i = 1; i <= number / 2; i++)\n    {\n        if (number % i == 0)\n        {\n            sum += i;\n        }\n    }\n    return sum;\n}\n\nيرجى تقديم وصف موجز بلغة طبيعية (docstring) للشيفرة البرمجية المكتوبة بلغة C# باللغة العربية الفصحى، بحيث لا يتجاوز 500 حرف.",
      "sw": "static List<(int, int)> FindAmicableNumbers(int limit)\n{\n    List<(int, int)> amicablePairs = new List<(int, int)>();\n    for (int i = 1; i <= limit; i++)\n    {\n        int sumOfDivisors = SumProperDivisors(i);\n        if (sumOfDivisors > i && sumOfDivisors <= limit)\n        {\n            if (SumProperDivisors(sumOfDivisors) == i)\n            {\n                amicablePairs.Add((i, sumOfDivisors));\n            }\n        }\n    }\n    return amicablePairs;\n}\n\nstatic int SumProperDivisors(int number)\n{\n    int sum = 0;\n    for (int i = 1; i <= number / 2; i++)\n    {\n        if (number % i == 0)\n        {\n            sum += i;\n        }\n    }\n    return sum;\n}\n\nToa maelezo mafupi ya lugha asilia (docstring) ya msimbo wa C# kwa Kiswahili kwa kutumia herufi zisizozidi 500.",
      "tr": "static List<(int, int)> FindAmicableNumbers(int limit)\n{\n    List<(int, int)> amicablePairs = new List<(int, int)>();\n    for (int i = 1; i <= limit; i++)\n    {\n        int sumOfDivisors = SumProperDivisors(i);\n        if (sumOfDivisors > i && sumOfDivisors <= limit)\n        {\n            if (SumProperDivisors(sumOfDivisors) == i)\n            {\n                amicablePairs.Add((i, sumOfDivisors));\n            }\n        }\n    }\n    return amicablePairs;\n}\n\nstatic int SumProperDivisors(int number)\n{\n    int sum = 0;\n    for (int i = 1; i <= number / 2; i++)\n    {\n        if (number % i == 0)\n        {\n            sum += i;\n        }\n    }\n    return sum;\n}\n\nAşağıdaki C# kodunun işlevini açıklayan, en fazla 500 karakter uzunluğunda özlü bir doğal dil açıklaması (docstring) sağlayın.",
      "vi": "static List<(int, int)> FindAmicableNumbers(int limit)\n{\n    List<(int, int)> amicablePairs = new List<(int, int)>();\n    for (int i = 1; i <= limit; i++)\n    {\n        int sumOfDivisors = SumProperDivisors(i);\n        if (sumOfDivisors > i && sumOfDivisors <= limit)\n        {\n            if (SumProperDivisors(sumOfDivisors) == i)\n            {\n                amicablePairs.Add((i, sumOfDivisors));\n            }\n        }\n    }\n    return amicablePairs;\n}\n\nstatic int SumProperDivisors(int number)\n{\n    int sum = 0;\n    for (int i = 1; i <= number / 2; i++)\n    {\n        if (number % i == 0)\n        {\n            sum += i;\n        }\n    }\n    return sum;\n}\n\nCung cấp mô tả ngắn gọn bằng ngôn ngữ tự nhiên (docstring) cho mã C# bằng tiếng Việt với tối đa 500 ký tự."
    },
    "instruction_bertscore": {
      "es": "0.9702167647764858",
      "arb": "0.8829437397396628",
      "sw": "0.9446027812508938",
      "tr": "0.8599965677098452",
      "vi": "0.9258024156859417"
    },
    "level": "",
    "test": "    static void Main()\n    {\n        Debug.Assert(FindAmicableNumbers(300).SequenceEqual(new List<(int, int)> { (220, 284) }));\n        Debug.Assert(FindAmicableNumbers(2000).SequenceEqual(new List<(int, int)> { (220, 284), (1184, 1210) }));\n        Debug.Assert(FindAmicableNumbers(500).Count == 1);\n        Debug.Assert(FindAmicableNumbers(100).Count == 0);\n        Debug.Assert(FindAmicableNumbers(3000).SequenceEqual(new List<(int, int)> { (220, 284), (1184, 1210) ,(2620,2924)}));\n\n    }\n}\n\n\n\n",
    "entry_point": "FindAmicableNumbers",
    "signature": "static List<(int, int)> FindAmicableNumbers(int limit)",
    "docstring": {
      "es": "FindAmicableNumbers - Encuentra todos los pares de números amigos dentro de un límite especificado.\n    Los números amigos son dos números diferentes tan relacionados que la suma de los divisores propios de cada uno es igual al otro número.\n\n    Ejemplo de uso:\n    >>> FindAmicableNumbers(300)\n    >>> (220, 284)",
      "arb": "FindAmicableNumbers - يعثر على جميع أزواج الأعداد المتآلفة ضمن حد محدد.\n    الأعداد المتآلفة هي عددان مختلفان مرتبطان بحيث يكون مجموع القواسم الصحيحة لكل منهما مساوياً للعدد الآخر.\n\n    مثال على الاستخدام:\n    >>> FindAmicableNumbers(300)\n    >>> (220, 284)",
      "sw": "FindAmicableNumbers - Inapata jozi zote za nambari za kirafiki ndani ya kikomo kilichobainishwa.\n    Nambari za kirafiki ni nambari mbili tofauti zinazohusiana kwa namna kwamba jumla ya wagawanyaji sahihi wa kila moja ni sawa na nambari nyingine.\n\n    Mfano wa matumizi:\n    >>> FindAmicableNumbers(300)\n    >>> (220, 284)",
      "tr": "FindAmicableNumbers - Belirtilen bir sınır içinde tüm dost sayı çiftlerini bulur.\n    Dost sayılar, her birinin uygun bölenlerinin toplamının diğer sayıya eşit olduğu iki farklı sayıdır.\n\n    Örnek kullanım:\n    >>> FindAmicableNumbers(300)\n    >>> (220, 284)",
      "vi": "FindAmicableNumbers - Tìm tất cả các cặp số thân thiện trong giới hạn được chỉ định. \n    Số thân thiện là hai số khác nhau có liên quan sao cho tổng của các ước số thực sự của mỗi số bằng số kia.\n\n    Ví dụ sử dụng:\n    >>> FindAmicableNumbers(300)\n    >>> (220, 284)"
    },
    "docstring_bertscore": {
      "es": "0.9803038114165805",
      "arb": "0.9783961652371215",
      "sw": "0.9646702100164676",
      "tr": "0.9754359766685585",
      "vi": "0.958740099990671"
    }
  },
  {
    "task_id": "C#/19",
    "prompt": {
      "es": "using System;\nusing System.Collections.Generic;\nusing System.Diagnostics;\n\nclass Program\n{\n/* Esta función toma una cadena, la invierte y luego la concatena con la cadena original.\n    Ejemplo de uso:\n    >>> ReverseAndConcatenate(\"hello\")\n    \"helloolleh\"\n    >>> ReverseAndConcatenate(\"123\")\n    \"123321\"\n*/\nstatic string ReverseAndConcatenate(string input)",
      "arb": "using System;\nusing System.Collections.Generic;\nusing System.Diagnostics;\n\nclass Program\n{\n/* تأخذ هذه الدالة سلسلة نصية، تعكسها، ثم تقوم بربطها بالسلسلة الأصلية.\n    مثال على الاستخدام:\n    >>> ReverseAndConcatenate(\"hello\")\n    \"helloolleh\"\n    >>> ReverseAndConcatenate(\"123\")\n    \"123321\"\n*/\nstatic string ReverseAndConcatenate(string input)",
      "sw": "using System;\nusing System.Collections.Generic;\nusing System.Diagnostics;\n\nclass Program\n{\n/* Kazi ya hii kazi ni kuchukua kamba, kuigeuza, na kisha kuiunganisha na kamba ya awali.\n    Mfano wa matumizi:\n    >>> ReverseAndConcatenate(\"hello\")\n    \"helloolleh\"\n    >>> ReverseAndConcatenate(\"123\")\n    \"123321\"\n*/\nstatic string ReverseAndConcatenate(string input)",
      "tr": "using System;\nusing System.Collections.Generic;\nusing System.Diagnostics;\n\nclass Program\n{\n/* Bu fonksiyon bir dize alır, tersine çevirir ve ardından orijinal dize ile birleştirir.\n    Örnek kullanım:\n    >>> ReverseAndConcatenate(\"hello\")\n    \"helloolleh\"\n    >>> ReverseAndConcatenate(\"123\")\n    \"123321\"\n*/\nstatic string ReverseAndConcatenate(string input)",
      "vi": "using System;\nusing System.Collections.Generic;\nusing System.Diagnostics;\n\nclass Program\n{\n/* Hàm này nhận một chuỗi, đảo ngược nó, và sau đó nối nó với chuỗi gốc.\n    Ví dụ sử dụng:\n    >>> ReverseAndConcatenate(\"hello\")\n    \"helloolleh\"\n    >>> ReverseAndConcatenate(\"123\")\n    \"123321\"\n*/\nstatic string ReverseAndConcatenate(string input)"
    },
    "prompt_bertscore": {
      "es": "0.9936617045411767",
      "arb": "0.9959874676727142",
      "sw": "0.9715050814278781",
      "tr": "1",
      "vi": "0.9971494554017684"
    },
    "canonical_solution": "{\n    char[] charArray = input.ToCharArray();\n    Array.Reverse(charArray);\n    return input + new string(charArray);\n}",
    "instruction": {
      "es": "static string ReverseAndConcatenate(string input)\n{\n    char[] charArray = input.ToCharArray();\n    Array.Reverse(charArray);\n    return input + new string(charArray);\n}\n\nProporcione una descripción concisa en lenguaje natural (docstring) del código C# en español utilizando un máximo de 500 caracteres.",
      "arb": "static string ReverseAndConcatenate(string input)\n{\n    char[] charArray = input.ToCharArray();\n    Array.Reverse(charArray);\n    return input + new string(charArray);\n}\n\nيرجى تقديم وصف موجز بلغة طبيعية (docstring) للكود المكتوب بلغة C# باللغة العربية الفصحى، بحيث لا يتجاوز 500 حرف.",
      "sw": "static string ReverseAndConcatenate(string input)\n{\n    char[] charArray = input.ToCharArray();\n    Array.Reverse(charArray);\n    return input + new string(charArray);\n}\n\nToa maelezo mafupi ya lugha ya asili (docstring) ya msimbo wa C# kwa Kiswahili kwa kutumia herufi zisizozidi 500.",
      "tr": "static string ReverseAndConcatenate(string input)\n{\n    char[] charArray = input.ToCharArray();\n    Array.Reverse(charArray);\n    return input + new string(charArray);\n}\n\nC# kodunun Türkçe olarak en fazla 500 karakter kullanarak kısa bir doğal dil açıklamasını (docstring) sağlayın.",
      "vi": "static string ReverseAndConcatenate(string input)\n{\n    char[] charArray = input.ToCharArray();\n    Array.Reverse(charArray);\n    return input + new string(charArray);\n}\n\nCung cấp mô tả ngắn gọn bằng ngôn ngữ tự nhiên (docstring) cho mã C# bằng tiếng Việt, không quá 500 ký tự."
    },
    "instruction_bertscore": {
      "es": "0.9702167647764858",
      "arb": "0.8829437397396628",
      "sw": "0.918288824262535",
      "tr": "0.941090996114197",
      "vi": "0.9187315713818617"
    },
    "level": "",
    "test": "    static void Main()\n    {\n        Debug.Assert(ReverseAndConcatenate(\"abc\") == \"abccba\");\n        Debug.Assert(ReverseAndConcatenate(\"test\") == \"testtset\");\n        Debug.Assert(ReverseAndConcatenate(\"\") == \"\");\n        Debug.Assert(ReverseAndConcatenate(\"12345\") == \"1234554321\");\n\n    }\n}",
    "entry_point": "ReverseAndConcatenate",
    "signature": "static string ReverseAndConcatenate(string input)",
    "docstring": {
      "es": "Esta función toma una cadena, la invierte y luego la concatena con la cadena original.\n    Ejemplo de uso:\n    >>> ReverseAndConcatenate(\"hello\")\n    \"helloolleh\"\n    >>> ReverseAndConcatenate(\"123\")\n    \"123321\"",
      "arb": "هذه الدالة تأخذ سلسلة نصية، تعكسها، ثم تدمجها مع السلسلة الأصلية.\n    مثال على الاستخدام:\n    >>> ReverseAndConcatenate(\"hello\")\n    \"helloolleh\"\n    >>> ReverseAndConcatenate(\"123\")\n    \"123321\"",
      "sw": "Kazi ya kazi hii ni kuchukua kamba, kuigeuza, na kisha kuiunganisha na kamba ya awali.\n    Mfano wa matumizi:\n    >>> ReverseAndConcatenate(\"hello\")\n    \"helloolleh\"\n    >>> ReverseAndConcatenate(\"123\")\n    \"123321\"",
      "tr": "Bu fonksiyon bir dize alır, ters çevirir ve ardından orijinal dize ile birleştirir.\n    Örnek kullanım:\n    >>> ReverseAndConcatenate(\"hello\")\n    \"helloolleh\"\n    >>> ReverseAndConcatenate(\"123\")\n    \"123321\"",
      "vi": "Hàm này nhận một chuỗi, đảo ngược nó, và sau đó nối nó với chuỗi gốc.\n    Ví dụ sử dụng:\n    >>> ReverseAndConcatenate(\"hello\")\n    \"helloolleh\"\n    >>> ReverseAndConcatenate(\"123\")\n    \"123321\""
    },
    "docstring_bertscore": {
      "es": "0.9916609007130123",
      "arb": "0.9920637231257511",
      "sw": "0.9555723426739265",
      "tr": "1",
      "vi": "1"
    }
  },
  {
    "task_id": "C#/20",
    "prompt": {
      "es": "using System;\nusing System.Collections.Generic;\nusing System.Diagnostics;\n\nclass Program\n{\n/* Calcula el número de valores de franqueo únicos que se pueden crear usando un número dado de sellos de 3 centavos y de 5 centavos.\n        Parámetros:\n        threeCentStamps - el número de sellos de 3 centavos disponibles\n        fiveCentStamps - el número de sellos de 5 centavos disponibles\n\n        Devuelve:\n        El número de valores de franqueo únicos que se pueden crear.\n\n        Ejemplo:\n        >>> CountUniquePostageCombinations(4, 3)\n        19\n\n        >>> CountUniquePostageCombinations(2, 2)\n        8\n    */\n    static int CountUniquePostageCombinations(int threeCentStamps, int fiveCentStamps)",
      "arb": "using System;\nusing System.Collections.Generic;\nusing System.Diagnostics;\n\nclass Program\n{\n/* يحسب عدد القيم الفريدة للطوابع البريدية التي يمكن إنشاؤها باستخدام عدد معين من الطوابع بقيمة 3 سنتات و5 سنتات.\n        المعلمات:\n        threeCentStamps - عدد الطوابع المتاحة بقيمة 3 سنتات\n        fiveCentStamps - عدد الطوابع المتاحة بقيمة 5 سنتات\n\n        يعيد:\n        عدد القيم الفريدة للطوابع البريدية التي يمكن إنشاؤها.\n\n        مثال:\n        >>> CountUniquePostageCombinations(4, 3)\n        19\n\n        >>> CountUniquePostageCombinations(2, 2)\n        8\n    */\n    static int CountUniquePostageCombinations(int threeCentStamps, int fiveCentStamps)",
      "sw": "using System;\nusing System.Collections.Generic;\nusing System.Diagnostics;\n\nclass Program\n{\n/* Inahesabu idadi ya thamani za kipekee za stempu ambazo zinaweza kuundwa kwa kutumia idadi fulani ya stempu za senti 3 na senti 5.\n        Vigezo:\n        threeCentStamps - idadi ya stempu za senti 3 zinazopatikana\n        fiveCentStamps - idadi ya stempu za senti 5 zinazopatikana\n\n        Inarejesha:\n        Idadi ya thamani za kipekee za stempu ambazo zinaweza kuundwa.\n\n        Mfano:\n        >>> CountUniquePostageCombinations(4, 3)\n        19\n\n        >>> CountUniquePostageCombinations(2, 2)\n        8\n    */\n    static int CountUniquePostageCombinations(int threeCentStamps, int fiveCentStamps)",
      "tr": "using System;\nusing System.Collections.Generic;\nusing System.Diagnostics;\n\nclass Program\n{\n/* Belirli bir sayıda 3 sentlik ve 5 sentlik pul kullanarak oluşturulabilecek benzersiz posta değerlerinin sayısını hesaplar.\n        Parametreler:\n        threeCentStamps - mevcut 3 sentlik pulların sayısı\n        fiveCentStamps - mevcut 5 sentlik pulların sayısı\n\n        Döndürür:\n        Oluşturulabilecek benzersiz posta değerlerinin sayısı.\n\n        Örnek:\n        >>> CountUniquePostageCombinations(4, 3)\n        19\n\n        >>> CountUniquePostageCombinations(2, 2)\n        8\n    */\n    static int CountUniquePostageCombinations(int threeCentStamps, int fiveCentStamps)",
      "vi": "using System;\nusing System.Collections.Generic;\nusing System.Diagnostics;\n\nclass Program\n{\n/* Tính toán số lượng giá trị bưu phí duy nhất có thể được tạo ra bằng cách sử dụng một số lượng tem 3 xu và 5 xu nhất định.\n        Tham số:\n        threeCentStamps - số lượng tem 3 xu có sẵn\n        fiveCentStamps - số lượng tem 5 xu có sẵn\n\n        Trả về:\n        Số lượng giá trị bưu phí duy nhất có thể được tạo ra.\n\n        Ví dụ:\n        >>> CountUniquePostageCombinations(4, 3)\n        19\n\n        >>> CountUniquePostageCombinations(2, 2)\n        8\n    */\n    static int CountUniquePostageCombinations(int threeCentStamps, int fiveCentStamps)"
    },
    "prompt_bertscore": {
      "es": "0.9956732344099171",
      "arb": "0.9541525327102892",
      "sw": "0.9814028333148466",
      "tr": "0.9921135793513908",
      "vi": "0.9881761293081363"
    },
    "canonical_solution": "   {\n\n        HashSet<int> uniqueValues = new HashSet<int>();\n\n        for (int i = 0; i <= threeCentStamps; i++)\n        {\n            for (int j = 0; j <= fiveCentStamps; j++)\n            {\n                int postageValue = 3 * i + 5 * j;\n                uniqueValues.Add(postageValue);\n            }\n        }\n\n        // Subtract 1 to exclude the value 0 (no stamps used)\n        return uniqueValues.Count - 1;\n    }",
    "instruction": {
      "es": "static int CountUniquePostageCombinations(int threeCentStamps, int fiveCentStamps)\n   {\n\n        HashSet<int> uniqueValues = new HashSet<int>();\n\n        for (int i = 0; i <= threeCentStamps; i++)\n        {\n            for (int j = 0; j <= fiveCentStamps; j++)\n            {\n                int postageValue = 3 * i + 5 * j;\n                uniqueValues.Add(postageValue);\n            }\n        }\n\n        // Subtract 1 to exclude the value 0 (no stamps used)\n        return uniqueValues.Count - 1;\n    }\n\nProporcione una descripción concisa en lenguaje natural (docstring) del código C# en español utilizando como máximo 500 caracteres.",
      "arb": "static int CountUniquePostageCombinations(int threeCentStamps, int fiveCentStamps)\n   {\n\n        HashSet<int> uniqueValues = new HashSet<int>();\n\n        for (int i = 0; i <= threeCentStamps; i++)\n        {\n            for (int j = 0; j <= fiveCentStamps; j++)\n            {\n                int postageValue = 3 * i + 5 * j;\n                uniqueValues.Add(postageValue);\n            }\n        }\n\n        // Subtract 1 to exclude the value 0 (no stamps used)\n        return uniqueValues.Count - 1;\n    }\n\nيرجى تقديم وصف موجز بلغة طبيعية (docstring) للكود المكتوب بلغة C# باللغة العربية الفصحى، بحيث لا يتجاوز 500 حرف.",
      "sw": "static int CountUniquePostageCombinations(int threeCentStamps, int fiveCentStamps)\n   {\n\n        HashSet<int> uniqueValues = new HashSet<int>();\n\n        for (int i = 0; i <= threeCentStamps; i++)\n        {\n            for (int j = 0; j <= fiveCentStamps; j++)\n            {\n                int postageValue = 3 * i + 5 * j;\n                uniqueValues.Add(postageValue);\n            }\n        }\n\n        // Subtract 1 to exclude the value 0 (no stamps used)\n        return uniqueValues.Count - 1;\n    }\n\nToa maelezo mafupi ya lugha ya asili (docstring) ya msimbo wa C# kwa Kiswahili kwa kutumia herufi zisizozidi 500.",
      "tr": "static int CountUniquePostageCombinations(int threeCentStamps, int fiveCentStamps)\n   {\n\n        HashSet<int> uniqueValues = new HashSet<int>();\n\n        for (int i = 0; i <= threeCentStamps; i++)\n        {\n            for (int j = 0; j <= fiveCentStamps; j++)\n            {\n                int postageValue = 3 * i + 5 * j;\n                uniqueValues.Add(postageValue);\n            }\n        }\n\n        // Subtract 1 to exclude the value 0 (no stamps used)\n        return uniqueValues.Count - 1;\n    }\n\nAşağıdaki C# kodunun işlevini açıklayan, en fazla 500 karakter uzunluğunda, özlü bir doğal dil açıklaması (docstring) sağlayın.",
      "vi": "static int CountUniquePostageCombinations(int threeCentStamps, int fiveCentStamps)\n   {\n\n        HashSet<int> uniqueValues = new HashSet<int>();\n\n        for (int i = 0; i <= threeCentStamps; i++)\n        {\n            for (int j = 0; j <= fiveCentStamps; j++)\n            {\n                int postageValue = 3 * i + 5 * j;\n                uniqueValues.Add(postageValue);\n            }\n        }\n\n        // Subtract 1 to exclude the value 0 (no stamps used)\n        return uniqueValues.Count - 1;\n    }\n\nCung cấp mô tả ngắn gọn bằng ngôn ngữ tự nhiên (docstring) cho mã C# bằng tiếng Việt với tối đa 500 ký tự."
    },
    "instruction_bertscore": {
      "es": "0.9702167647764858",
      "arb": "0.8716935135882278",
      "sw": "0.918288824262535",
      "tr": "0.8599965677098452",
      "vi": "0.9399717139170654"
    },
    "level": "",
    "test": "    static void Main()\n    {\n        Debug.Assert(CountUniquePostageCombinations(4, 3) == 19); \n        Debug.Assert(CountUniquePostageCombinations(2, 2) == 8); \n        Debug.Assert(CountUniquePostageCombinations(3, 1) == 7);\n        Debug.Assert(CountUniquePostageCombinations(1, 3) == 7); \n\n    }\n}\n",
    "entry_point": "CountUniquePostageCombinations",
    "signature": "static int CountUniquePostageCombinations(int threeCentStamps, int fiveCentStamps)",
    "docstring": {
      "es": "Calcula el número de valores de franqueo únicos que se pueden crear usando un número dado de sellos de 3 centavos y 5 centavos.\n        \n        Parámetros:\n        threeCentStamps - el número de sellos de 3 centavos disponibles\n        fiveCentStamps - el número de sellos de 5 centavos disponibles\n\n        Devuelve:\n        El número de valores de franqueo únicos que se pueden crear.\n\n        Ejemplo:\n        >>> CountUniquePostageCombinations(4, 3)\n        19\n\n        >>> CountUniquePostageCombinations(2, 2)\n        8",
      "arb": "يحسب عدد القيم الفريدة للطوابع البريدية التي يمكن إنشاؤها باستخدام عدد معين من الطوابع بقيمة 3 سنتات و 5 سنتات.\n        المعلمات:\n        threeCentStamps - عدد الطوابع المتاحة بقيمة 3 سنتات\n        fiveCentStamps - عدد الطوابع المتاحة بقيمة 5 سنتات\n\n        يعيد:\n        عدد القيم الفريدة للطوابع البريدية التي يمكن إنشاؤها.\n\n        مثال:\n        >>> CountUniquePostageCombinations(4, 3)\n        19\n\n        >>> CountUniquePostageCombinations(2, 2)\n        8",
      "sw": "Hesabu idadi ya thamani za kipekee za posta ambazo zinaweza kuundwa kwa kutumia idadi fulani ya stempu za senti 3 na senti 5.\n        \n        Vigezo:\n        threeCentStamps - idadi ya stempu za senti 3 zinazopatikana\n        fiveCentStamps - idadi ya stempu za senti 5 zinazopatikana\n\n        Inarejesha:\n        Idadi ya thamani za kipekee za posta ambazo zinaweza kuundwa.\n\n        Mfano:\n        >>> CountUniquePostageCombinations(4, 3)\n        19\n\n        >>> CountUniquePostageCombinations(2, 2)\n        8",
      "tr": "Verilen sayıda 3 sentlik ve 5 sentlik pullar kullanılarak oluşturulabilecek benzersiz posta değerlerinin sayısını hesaplar.\n        Parametreler:\n        threeCentStamps - mevcut 3 sentlik pulların sayısı\n        fiveCentStamps - mevcut 5 sentlik pulların sayısı\n\n        Döndürür:\n        Oluşturulabilecek benzersiz posta değerlerinin sayısı.\n\n        Örnek:\n        >>> CountUniquePostageCombinations(4, 3)\n        19\n\n        >>> CountUniquePostageCombinations(2, 2)\n        8",
      "vi": "Tính toán số lượng giá trị tem bưu chính duy nhất có thể được tạo ra bằng cách sử dụng một số lượng tem 3 xu và 5 xu nhất định.\n        \n        Tham số:\n        threeCentStamps - số lượng tem 3 xu có sẵn\n        fiveCentStamps - số lượng tem 5 xu có sẵn\n\n        Trả về:\n        Số lượng giá trị tem bưu chính duy nhất có thể được tạo ra.\n\n        Ví dụ:\n        >>> CountUniquePostageCombinations(4, 3)\n        19\n\n        >>> CountUniquePostageCombinations(2, 2)\n        8"
    },
    "docstring_bertscore": {
      "es": "1",
      "arb": "0.9381047869657185",
      "sw": "0.9726597198328338",
      "tr": "0.9853315436213356",
      "vi": "0.9823038207232208"
    }
  },
  {
    "task_id": "C#/21",
    "prompt": {
      "es": "using System;\nusing System.Collections.Generic;\nusing System.Diagnostics;\n\nclass Program\n{\n/* Determina si una secuencia tiene \"Jolly Jumps\" donde las diferencias absolutas entre elementos adyacentes, \n   cuando se ordenan, forman una secuencia continua desde 1 hasta (longitud de la secuencia - 1).\n   Una secuencia con un solo elemento siempre se considera jolly.\n   \n        Ejemplos:\n        >>> IsSequenceJolly(new int[] {1, 4, 2, 3})\n        \"Jolly\"\n        \n        >>> IsSequenceJolly(new int[] {1, 3})\n        \"Not Jolly\"\n\n        >>> IsSequenceJolly(new int[] {5})\n        \"Jolly\"\n    */\n    static string IsSequenceJolly(int[] sequence)",
      "arb": "using System;\nusing System.Collections.Generic;\nusing System.Diagnostics;\n\nclass Program\n{\n/* يحدد ما إذا كانت سلسلة تحتوي على \"قفزات مرحة\" حيث أن الفروق المطلقة بين العناصر المتجاورة، \n   عند ترتيبها، تشكل تسلسلاً مستمرًا من 1 إلى (طول السلسلة - 1).\n   تعتبر السلسلة التي تحتوي على عنصر واحد دائمًا مرحة.\n   \n        أمثلة:\n        >>> IsSequenceJolly(new int[] {1, 4, 2, 3})\n        \"Jolly\"\n        \n        >>> IsSequenceJolly(new int[] {1, 3})\n        \"Not Jolly\"\n\n        >>> IsSequenceJolly(new int[] {5})\n        \"Jolly\"\n    */\n    static string IsSequenceJolly(int[] sequence)",
      "sw": "using System;\nusing System.Collections.Generic;\nusing System.Diagnostics;\n\nclass Program\n{\n/* Huamua ikiwa mlolongo una \"Jolly Jumps\" ambapo tofauti za thamani kabisa kati ya vipengele vya karibu, \n   zinapopangwa, zinaunda mlolongo unaoendelea kutoka 1 hadi (urefu wa mlolongo - 1).\n   Mlolongo wenye kipengele kimoja daima unachukuliwa kuwa jolly.\n   \n        Mifano:\n        >>> IsSequenceJolly(new int[] {1, 4, 2, 3})\n        \"Jolly\"\n        \n        >>> IsSequenceJolly(new int[] {1, 3})\n        \"Not Jolly\"\n\n        >>> IsSequenceJolly(new int[] {5})\n        \"Jolly\"\n    */\n    static string IsSequenceJolly(int[] sequence)",
      "tr": "using System;\nusing System.Collections.Generic;\nusing System.Diagnostics;\n\nclass Program\n{\n/* Bir dizinin \"Jolly Jumps\" olup olmadığını belirler, burada bitişik elemanlar arasındaki mutlak farklar, \n   sıralandığında, 1'den (dizinin uzunluğu - 1)'e kadar kesintisiz bir dizi oluşturur.\n   Tek bir eleman içeren bir dizi her zaman jolly olarak kabul edilir.\n   \n        Örnekler:\n        >>> IsSequenceJolly(new int[] {1, 4, 2, 3})\n        \"Jolly\"\n        \n        >>> IsSequenceJolly(new int[] {1, 3})\n        \"Not Jolly\"\n\n        >>> IsSequenceJolly(new int[] {5})\n        \"Jolly\"\n    */\n    static string IsSequenceJolly(int[] sequence)",
      "vi": "using System;\nusing System.Collections.Generic;\nusing System.Diagnostics;\n\nclass Program\n{\n/* Xác định xem một dãy có \"Jolly Jumps\" hay không, trong đó sự khác biệt tuyệt đối giữa các phần tử liền kề, \n   khi được sắp xếp, tạo thành một dãy liên tục từ 1 đến (độ dài của dãy - 1).\n   Một dãy với một phần tử luôn được coi là jolly.\n   \n        Ví dụ:\n        >>> IsSequenceJolly(new int[] {1, 4, 2, 3})\n        \"Jolly\"\n        \n        >>> IsSequenceJolly(new int[] {1, 3})\n        \"Not Jolly\"\n\n        >>> IsSequenceJolly(new int[] {5})\n        \"Jolly\"\n    */\n    static string IsSequenceJolly(int[] sequence)"
    },
    "prompt_bertscore": {
      "es": "0.9971462773156717",
      "arb": "0.9871128608784564",
      "sw": "0.994517602853056",
      "tr": "0.9781524457595916",
      "vi": "0.9852622216183544"
    },
    "canonical_solution": "{\n        if (sequence.Length == 1) return \"Jolly\";\n\n        int[] differences = new int[sequence.Length - 1];\n        for (int i = 0; i < sequence.Length - 1; i++)\n        {\n            differences[i] = Math.Abs(sequence[i] - sequence[i + 1]);\n        }\n\n        Array.Sort(differences);\n        for (int i = 0; i < differences.Length; i++)\n        {\n            if (differences[i] != i + 1) return \"Not Jolly\";\n        }\n\n        return \"Jolly\";\n    }",
    "instruction": {
      "es": "static string IsSequenceJolly(int[] sequence)\n{\n        if (sequence.Length == 1) return \"Jolly\";\n\n        int[] differences = new int[sequence.Length - 1];\n        for (int i = 0; i < sequence.Length - 1; i++)\n        {\n            differences[i] = Math.Abs(sequence[i] - sequence[i + 1]);\n        }\n\n        Array.Sort(differences);\n        for (int i = 0; i < differences.Length; i++)\n        {\n            if (differences[i] != i + 1) return \"Not Jolly\";\n        }\n\n        return \"Jolly\";\n    }\n\nProporcione una descripción concisa en lenguaje natural (docstring) del código C# en español utilizando como máximo 500 caracteres.",
      "arb": "static string IsSequenceJolly(int[] sequence)\n{\n        if (sequence.Length == 1) return \"Jolly\";\n\n        int[] differences = new int[sequence.Length - 1];\n        for (int i = 0; i < sequence.Length - 1; i++)\n        {\n            differences[i] = Math.Abs(sequence[i] - sequence[i + 1]);\n        }\n\n        Array.Sort(differences);\n        for (int i = 0; i < differences.Length; i++)\n        {\n            if (differences[i] != i + 1) return \"Not Jolly\";\n        }\n\n        return \"Jolly\";\n    }\n\nيرجى تقديم وصف موجز بلغة طبيعية (docstring) للكود المكتوب بلغة C# باللغة العربية الفصحى، بحيث لا يتجاوز 500 حرف.",
      "sw": "static string IsSequenceJolly(int[] sequence)\n{\n        if (sequence.Length == 1) return \"Jolly\";\n\n        int[] differences = new int[sequence.Length - 1];\n        for (int i = 0; i < sequence.Length - 1; i++)\n        {\n            differences[i] = Math.Abs(sequence[i] - sequence[i + 1]);\n        }\n\n        Array.Sort(differences);\n        for (int i = 0; i < differences.Length; i++)\n        {\n            if (differences[i] != i + 1) return \"Not Jolly\";\n        }\n\n        return \"Jolly\";\n    }\n\nToa maelezo mafupi ya lugha ya asili (docstring) ya msimbo wa C# kwa Kiswahili kwa kutumia herufi zisizozidi 500.",
      "tr": "static string IsSequenceJolly(int[] sequence)\n{\n        if (sequence.Length == 1) return \"Jolly\";\n\n        int[] differences = new int[sequence.Length - 1];\n        for (int i = 0; i < sequence.Length - 1; i++)\n        {\n            differences[i] = Math.Abs(sequence[i] - sequence[i + 1]);\n        }\n\n        Array.Sort(differences);\n        for (int i = 0; i < differences.Length; i++)\n        {\n            if (differences[i] != i + 1) return \"Not Jolly\";\n        }\n\n        return \"Jolly\";\n    }\n\nAşağıdaki C# kodunun Türkçe dilinde en fazla 500 karakter kullanarak kısa bir doğal dil açıklamasını (docstring) sağlayın.",
      "vi": "static string IsSequenceJolly(int[] sequence)\n{\n        if (sequence.Length == 1) return \"Jolly\";\n\n        int[] differences = new int[sequence.Length - 1];\n        for (int i = 0; i < sequence.Length - 1; i++)\n        {\n            differences[i] = Math.Abs(sequence[i] - sequence[i + 1]);\n        }\n\n        Array.Sort(differences);\n        for (int i = 0; i < differences.Length; i++)\n        {\n            if (differences[i] != i + 1) return \"Not Jolly\";\n        }\n\n        return \"Jolly\";\n    }\n\nCung cấp mô tả ngắn gọn bằng ngôn ngữ tự nhiên (docstring) cho mã C# bằng tiếng Việt với tối đa 500 ký tự."
    },
    "instruction_bertscore": {
      "es": "0.9702167647764858",
      "arb": "0.8716935135882278",
      "sw": "0.918288824262535",
      "tr": "0.8955079058616436",
      "vi": "0.918539495803401"
    },
    "level": "",
    "test": "    static void Main()\n    {\n\n        Debug.Assert(IsSequenceJolly(new int[] {1, 4, 2, 3}) == \"Jolly\");\n        Debug.Assert(IsSequenceJolly(new int[] {1, 3}) == \"Not Jolly\");\n        Debug.Assert(IsSequenceJolly(new int[] {5}) == \"Jolly\");\n        Debug.Assert(IsSequenceJolly(new int[] {10, 7, 8, 9}) == \"Not Jolly\");\n\n    }\n}",
    "entry_point": "IsSequenceJolly",
    "signature": "static string IsSequenceJolly(int[] sequence)",
    "docstring": {
      "es": "Determina si una secuencia tiene \"Jolly Jumps\" donde las diferencias absolutas entre elementos adyacentes, \n   cuando se ordenan, forman una secuencia continua desde 1 hasta (longitud de la secuencia - 1).\n   Una secuencia con un solo elemento siempre se considera jolly.\n   \n        Ejemplos:\n        >>> IsSequenceJolly(new int[] {1, 4, 2, 3})\n        \"Jolly\"\n        \n        >>> IsSequenceJolly(new int[] {1, 3})\n        \"Not Jolly\"\n\n        >>> IsSequenceJolly(new int[] {5})\n        \"Jolly\"",
      "arb": "يحدد ما إذا كانت تسلسل يحتوي على \"قفزات مرحة\" حيث تشكل الفروق المطلقة بين العناصر المتجاورة، عند ترتيبها، تسلسلًا مستمرًا من 1 إلى (طول التسلسل - 1). \nيعتبر التسلسل الذي يحتوي على عنصر واحد دائمًا مرحًا.\n\nأمثلة:\n>>> IsSequenceJolly(new int[] {1, 4, 2, 3})\n\"Jolly\"\n\n>>> IsSequenceJolly(new int[] {1, 3})\n\"Not Jolly\"\n\n>>> IsSequenceJolly(new int[] {5})\n\"Jolly\"",
      "sw": "Inabainisha kama mlolongo una \"Jolly Jumps\" ambapo tofauti za thamani kabisa kati ya vipengele vya karibu, \n   zinapopangwa, huunda mlolongo unaoendelea kutoka 1 hadi (urefu wa mlolongo - 1).\n   Mlolongo wenye kipengele kimoja daima unachukuliwa kuwa jolly.\n   \n        Mifano:\n        >>> IsSequenceJolly(new int[] {1, 4, 2, 3})\n        \"Jolly\"\n        \n        >>> IsSequenceJolly(new int[] {1, 3})\n        \"Not Jolly\"\n\n        >>> IsSequenceJolly(new int[] {5})\n        \"Jolly\"",
      "tr": "Bir dizinin \"Jolly Jumps\" olup olmadığını belirler; burada bitişik elemanlar arasındaki mutlak farklar, \n   sıralandığında 1'den (dizinin uzunluğu - 1)'e kadar kesintisiz bir dizi oluşturur.\n   Tek bir elemanı olan bir dizi her zaman jolly olarak kabul edilir.\n   \n        Örnekler:\n        >>> IsSequenceJolly(new int[] {1, 4, 2, 3})\n        \"Jolly\"\n        \n        >>> IsSequenceJolly(new int[] {1, 3})\n        \"Not Jolly\"\n\n        >>> IsSequenceJolly(new int[] {5})\n        \"Jolly\"",
      "vi": "Xác định xem một dãy có \"Jolly Jumps\" hay không, trong đó các giá trị tuyệt đối của sự khác biệt giữa các phần tử liền kề, khi được sắp xếp, tạo thành một dãy liên tục từ 1 đến (độ dài của dãy - 1). Một dãy với một phần tử luôn được coi là jolly.\n\n        Ví dụ:\n        >>> IsSequenceJolly(new int[] {1, 4, 2, 3})\n        \"Jolly\"\n        \n        >>> IsSequenceJolly(new int[] {1, 3})\n        \"Not Jolly\"\n\n        >>> IsSequenceJolly(new int[] {5})\n        \"Jolly\""
    },
    "docstring_bertscore": {
      "es": "0.9905420157766428",
      "arb": "0.9808113120401246",
      "sw": "0.9966483109504173",
      "tr": "0.9736063922288462",
      "vi": "0.9711386083748687"
    }
  },
  {
    "task_id": "C#/22",
    "prompt": {
      "es": "using System;\nusing System.Collections.Generic;\nusing System.Diagnostics;\n\nclass Program\n{\n\n    /* Determina el ganador en un juego de Piedra-Papel-Tijeras jugado durante un número de rondas.\n    Los jugadores A y B tienen sus propios patrones repetitivos de movimientos.\n    Piedra (representada por 0) vence a Tijeras (2), Tijeras vence a Papel (5), y Papel vence a Piedra.\n    Si ambos jugadores eligen el mismo movimiento, la ronda es un empate.\n\n    Ejemplos:\n    >>> DetermineWinner(10, new List<int> {0, 2, 5}, new List<int> {0, 5, 0, 2})\n    \"A\"\n\n    >>> DetermineWinner(6, new List<int> {2, 5, 0}, new List<int> {5, 0, 2})\n    \"A\"\n\n    >>> DetermineWinner(7, new List<int> {5, 5, 2}, new List<int> {5, 5, 2})\n    \"draw\"\n    */\n\n    static string DetermineWinner(int rounds, List<int> patternA, List<int> patternB)",
      "arb": "using System;\nusing System.Collections.Generic;\nusing System.Diagnostics;\n\nclass Program\n{\n\n    /* يحدد الفائز في لعبة حجر-ورقة-مقص التي تُلعب لعدد من الجولات.\n    اللاعبان A و B لديهما أنماط متكررة خاصة بهما من الحركات.\n    الحجر (يمثله 0) يهزم المقص (2)، المقص يهزم الورقة (5)، والورقة تهزم الحجر.\n    إذا اختار كلا اللاعبين نفس الحركة، تكون الجولة تعادل.\n\n    أمثلة:\n    >>> DetermineWinner(10, new List<int> {0, 2, 5}, new List<int> {0, 5, 0, 2})\n    \"A\"\n\n    >>> DetermineWinner(6, new List<int> {2, 5, 0}, new List<int> {5, 0, 2})\n    \"A\"\n\n    >>> DetermineWinner(7, new List<int> {5, 5, 2}, new List<int> {5, 5, 2})\n    \"draw\"\n    */\n\n    static string DetermineWinner(int rounds, List<int> patternA, List<int> patternB)",
      "sw": "using System;\nusing System.Collections.Generic;\nusing System.Diagnostics;\n\nclass Program\n{\n\n    /* Huamua mshindi katika mchezo wa Jiwe-Karatasi-Makasi uliochezwa kwa idadi ya raundi.\n    Wachezaji A na B wana mifumo yao inayojirudia ya hatua.\n    Jiwe (linalowakilishwa na 0) linashinda Makasi (2), Makasi yanashinda Karatasi (5), na Karatasi inashinda Jiwe.\n    Ikiwa wachezaji wote wanachagua hatua sawa, raundi ni sare.\n\n    Mifano:\n    >>> DetermineWinner(10, new List<int> {0, 2, 5}, new List<int> {0, 5, 0, 2})\n    \"A\"\n\n    >>> DetermineWinner(6, new List<int> {2, 5, 0}, new List<int> {5, 0, 2})\n    \"A\"\n\n    >>> DetermineWinner(7, new List<int> {5, 5, 2}, new List<int> {5, 5, 2})\n    \"draw\"\n    */\n\n    static string DetermineWinner(int rounds, List<int> patternA, List<int> patternB)",
      "tr": "using System;\nusing System.Collections.Generic;\nusing System.Diagnostics;\n\nclass Program\n{\n\n    /* Bir dizi tur için oynanan Taş-Kağıt-Makas oyununda kazananı belirler.\n    Oyuncular A ve B'nin kendi tekrar eden hamle desenleri vardır.\n    Taş (0 ile temsil edilir) Makas'ı (2) yener, Makas Kağıt'ı (5) yener ve Kağıt Taş'ı yener.\n    Eğer her iki oyuncu da aynı hamleyi seçerse, tur berabere biter.\n\n    Örnekler:\n    >>> DetermineWinner(10, new List<int> {0, 2, 5}, new List<int> {0, 5, 0, 2})\n    \"A\"\n\n    >>> DetermineWinner(6, new List<int> {2, 5, 0}, new List<int> {5, 0, 2})\n    \"A\"\n\n    >>> DetermineWinner(7, new List<int> {5, 5, 2}, new List<int> {5, 5, 2})\n    \"draw\"\n    */\n\n    static string DetermineWinner(int rounds, List<int> patternA, List<int> patternB)",
      "vi": "using System;\nusing System.Collections.Generic;\nusing System.Diagnostics;\n\nclass Program\n{\n\n    /* Xác định người chiến thắng trong trò chơi Kéo-Búa-Bao được chơi trong một số vòng.\n    Người chơi A và B có các mẫu di chuyển lặp lại của riêng họ.\n    Đá (được biểu diễn bằng 0) thắng Kéo (2), Kéo thắng Bao (5), và Bao thắng Đá.\n    Nếu cả hai người chơi chọn cùng một nước đi, vòng đó hòa.\n\n    Ví dụ:\n    >>> DetermineWinner(10, new List<int> {0, 2, 5}, new List<int> {0, 5, 0, 2})\n    \"A\"\n\n    >>> DetermineWinner(6, new List<int> {2, 5, 0}, new List<int> {5, 0, 2})\n    \"A\"\n\n    >>> DetermineWinner(7, new List<int> {5, 5, 2}, new List<int> {5, 5, 2})\n    \"draw\"\n    */\n\n    static string DetermineWinner(int rounds, List<int> patternA, List<int> patternB)"
    },
    "prompt_bertscore": {
      "es": "0.9924776688398278",
      "arb": "0.9957435495648034",
      "sw": "0.9936764031893733",
      "tr": "0.9713618689231519",
      "vi": "0.9713785538751588"
    },
    "canonical_solution": "    {\n        int scoreA = 0, scoreB = 0;\n        for (int i = 0; i < rounds; i++)\n        {\n            int moveA = patternA[i % patternA.Count];\n            int moveB = patternB[i % patternB.Count];\n\n            if (moveA == moveB) continue;\n            if ((moveA == 0 && moveB == 2) || (moveA == 2 && moveB == 5) || (moveA == 5 && moveB == 0))\n                scoreA++;\n            else\n                scoreB++;\n        }\n\n        if (scoreA > scoreB) return \"A\";\n        if (scoreB > scoreA) return \"B\";\n        return \"draw\";\n    }",
    "instruction": {
      "es": "static string DetermineWinner(int rounds, List<int> patternA, List<int> patternB)\n    {\n        int scoreA = 0, scoreB = 0;\n        for (int i = 0; i < rounds; i++)\n        {\n            int moveA = patternA[i % patternA.Count];\n            int moveB = patternB[i % patternB.Count];\n\n            if (moveA == moveB) continue;\n            if ((moveA == 0 && moveB == 2) || (moveA == 2 && moveB == 5) || (moveA == 5 && moveB == 0))\n                scoreA++;\n            else\n                scoreB++;\n        }\n\n        if (scoreA > scoreB) return \"A\";\n        if (scoreB > scoreA) return \"B\";\n        return \"draw\";\n    }\n\nProporcione una descripción concisa en lenguaje natural (docstring) del código C# en español utilizando un máximo de 500 caracteres.",
      "arb": "static string DetermineWinner(int rounds, List<int> patternA, List<int> patternB)\n    {\n        int scoreA = 0, scoreB = 0;\n        for (int i = 0; i < rounds; i++)\n        {\n            int moveA = patternA[i % patternA.Count];\n            int moveB = patternB[i % patternB.Count];\n\n            if (moveA == moveB) continue;\n            if ((moveA == 0 && moveB == 2) || (moveA == 2 && moveB == 5) || (moveA == 5 && moveB == 0))\n                scoreA++;\n            else\n                scoreB++;\n        }\n\n        if (scoreA > scoreB) return \"A\";\n        if (scoreB > scoreA) return \"B\";\n        return \"draw\";\n    }\n\nيرجى تقديم وصف موجز بلغة طبيعية (docstring) للكود المكتوب بلغة C# باللغة العربية الفصحى، بحيث لا يتجاوز 500 حرف.",
      "sw": "static string DetermineWinner(int rounds, List<int> patternA, List<int> patternB)\n    {\n        int scoreA = 0, scoreB = 0;\n        for (int i = 0; i < rounds; i++)\n        {\n            int moveA = patternA[i % patternA.Count];\n            int moveB = patternB[i % patternB.Count];\n\n            if (moveA == moveB) continue;\n            if ((moveA == 0 && moveB == 2) || (moveA == 2 && moveB == 5) || (moveA == 5 && moveB == 0))\n                scoreA++;\n            else\n                scoreB++;\n        }\n\n        if (scoreA > scoreB) return \"A\";\n        if (scoreB > scoreA) return \"B\";\n        return \"draw\";\n    }\n\nToa maelezo mafupi ya lugha ya asili (docstring) ya msimbo wa C# kwa Kiswahili kwa kutumia herufi zisizozidi 500.",
      "tr": "static string DetermineWinner(int rounds, List<int> patternA, List<int> patternB)\n    {\n        int scoreA = 0, scoreB = 0;\n        for (int i = 0; i < rounds; i++)\n        {\n            int moveA = patternA[i % patternA.Count];\n            int moveB = patternB[i % patternB.Count];\n\n            if (moveA == moveB) continue;\n            if ((moveA == 0 && moveB == 2) || (moveA == 2 && moveB == 5) || (moveA == 5 && moveB == 0))\n                scoreA++;\n            else\n                scoreB++;\n        }\n\n        if (scoreA > scoreB) return \"A\";\n        if (scoreB > scoreA) return \"B\";\n        return \"draw\";\n    }\n\nC# kodunun işlevselliğini açıklayan en fazla 500 karakterlik kısa bir doğal dil tanımı (docstring) sağlayın.",
      "vi": "static string DetermineWinner(int rounds, List<int> patternA, List<int> patternB)\n    {\n        int scoreA = 0, scoreB = 0;\n        for (int i = 0; i < rounds; i++)\n        {\n            int moveA = patternA[i % patternA.Count];\n            int moveB = patternB[i % patternB.Count];\n\n            if (moveA == moveB) continue;\n            if ((moveA == 0 && moveB == 2) || (moveA == 2 && moveB == 5) || (moveA == 5 && moveB == 0))\n                scoreA++;\n            else\n                scoreB++;\n        }\n\n        if (scoreA > scoreB) return \"A\";\n        if (scoreB > scoreA) return \"B\";\n        return \"draw\";\n    }\n\nCung cấp mô tả ngắn gọn bằng ngôn ngữ tự nhiên (docstring) cho mã C# bằng tiếng Việt với tối đa 500 ký tự."
    },
    "instruction_bertscore": {
      "es": "0.9702167647764858",
      "arb": "0.8829437397396628",
      "sw": "0.918288824262535",
      "tr": "0.8705730396088099",
      "vi": "0.9066002208601559"
    },
    "level": "",
    "test": "    static void Main()\n    {\n        Debug.Assert(DetermineWinner(10, new List<int> {0, 2, 5}, new List<int> {0, 5, 0, 2}) == \"A\");\n        Debug.Assert(DetermineWinner(6, new List<int> {2, 5, 0}, new List<int> {5, 0, 2}) == \"A\");\n        Debug.Assert(DetermineWinner(5, new List<int> {0, 0, 0}, new List<int> {2, 2, 2}) == \"A\");\n        Debug.Assert(DetermineWinner(7, new List<int> {5, 5, 2}, new List<int> {5, 5, 2}) == \"draw\");\n    }\n}",
    "entry_point": "DetermineWinner",
    "signature": "static string DetermineWinner(int rounds, List<int> patternA, List<int> patternB)",
    "docstring": {
      "es": "Determina el ganador en un juego de Piedra-Papel-Tijeras jugado durante un número de rondas.\n    Los jugadores A y B tienen sus propios patrones repetitivos de movimientos.\n    Piedra (representada por 0) vence a Tijeras (2), Tijeras vence a Papel (5), y Papel vence a Piedra.\n    Si ambos jugadores eligen el mismo movimiento, la ronda es un empate.\n\n    Ejemplos:\n    >>> DetermineWinner(10, new List<int> {0, 2, 5}, new List<int> {0, 5, 0, 2})\n    \"A\"\n\n    >>> DetermineWinner(6, new List<int> {2, 5, 0}, new List<int> {5, 0, 2})\n    \"A\"\n\n    >>> DetermineWinner(7, new List<int> {5, 5, 2}, new List<int> {5, 5, 2})\n    \"draw\"",
      "arb": "يحدد الفائز في لعبة حجر-ورقة-مقص التي تُلعب لعدد من الجولات.\n    اللاعبان A و B لديهما أنماط متكررة خاصة بهما من الحركات.\n    الحجر (يمثله 0) يهزم المقص (2)، المقص يهزم الورقة (5)، والورقة تهزم الحجر.\n    إذا اختار كلا اللاعبين نفس الحركة، تكون الجولة تعادل.\n\n    أمثلة:\n    >>> DetermineWinner(10, new List<int> {0, 2, 5}, new List<int> {0, 5, 0, 2})\n    \"A\"\n\n    >>> DetermineWinner(6, new List<int> {2, 5, 0}, new List<int> {5, 0, 2})\n    \"A\"\n\n    >>> DetermineWinner(7, new List<int> {5, 5, 2}, new List<int> {5, 5, 2})\n    \"draw\"",
      "sw": "Inabainisha mshindi katika mchezo wa Jiwe-Karatasi-Makasi uliochezwa kwa idadi fulani ya raundi. \nWachezaji A na B wana mifumo yao ya kurudia ya miendo. \nJiwe (linalowakilishwa na 0) linashinda Makasi (2), Makasi yanashinda Karatasi (5), na Karatasi inashinda Jiwe. \nIkiwa wachezaji wote wawili watachagua mwendo sawa, raundi hiyo ni sare.\n\nMifano:\n>>> DetermineWinner(10, new List<int> {0, 2, 5}, new List<int> {0, 5, 0, 2})\n\"A\"\n\n>>> DetermineWinner(6, new List<int> {2, 5, 0}, new List<int> {5, 0, 2})\n\"A\"\n\n>>> DetermineWinner(7, new List<int> {5, 5, 2}, new List<int> {5, 5, 2})\n\"draw\"",
      "tr": "Bir dizi tur için oynanan Taş-Kağıt-Makas oyununda kazananı belirler.\n    Oyuncular A ve B'nin kendi tekrarlayan hamle desenleri vardır.\n    Taş (0 ile temsil edilir) Makas'ı (2) yener, Makas Kağıt'ı (5) yener ve Kağıt Taş'ı yener.\n    Her iki oyuncu da aynı hamleyi seçerse, tur berabere biter.\n\n    Örnekler:\n    >>> DetermineWinner(10, new List<int> {0, 2, 5}, new List<int> {0, 5, 0, 2})\n    \"A\"\n\n    >>> DetermineWinner(6, new List<int> {2, 5, 0}, new List<int> {5, 0, 2})\n    \"A\"\n\n    >>> DetermineWinner(7, new List<int> {5, 5, 2}, new List<int> {5, 5, 2})\n    \"draw\"",
      "vi": "Xác định người chiến thắng trong trò chơi Oẳn Tù Tì được chơi qua một số vòng.\nNgười chơi A và B có các mẫu di chuyển lặp lại của riêng họ.\nĐá (được biểu diễn bằng 0) thắng Kéo (2), Kéo thắng Giấy (5), và Giấy thắng Đá.\nNếu cả hai người chơi chọn cùng một nước đi, vòng đó hòa.\n\nVí dụ:\n>>> DetermineWinner(10, new List<int> {0, 2, 5}, new List<int> {0, 5, 0, 2})\n\"A\"\n\n>>> DetermineWinner(6, new List<int> {2, 5, 0}, new List<int> {5, 0, 2})\n\"A\"\n\n>>> DetermineWinner(7, new List<int> {5, 5, 2}, new List<int> {5, 5, 2})\n\"draw\""
    },
    "docstring_bertscore": {
      "es": "0.9819035805054355",
      "arb": "0.9911516124160389",
      "sw": "0.9924061619026552",
      "tr": "0.990834201067145",
      "vi": "0.9731402067245573"
    }
  },
  {
    "task_id": "C#/23",
    "prompt": {
      "es": "using System;\nusing System.Collections.Generic;\nusing System.Diagnostics;\n\nclass Program\n{\n\n\n/* \n    Calcular el producto punto de dos vectores enteros n-dimensionales.\n    El producto punto es la suma de los productos de los elementos correspondientes de los dos vectores.\n\n    Ejemplo 1:\n    >>> CalculateDotProduct(new List<int> {1, 3, -5}, new List<int> {4, -2, -1})\n    3\n\n    Ejemplo 2:\n    >>> CalculateDotProduct(new List<int> {2, 5, 7}, new List<int> {3, 6, 8})\n    100\n*/\n\nstatic int CalculateDotProduct(List<int> vectorA, List<int> vectorB)",
      "arb": "using System;\nusing System.Collections.Generic;\nusing System.Diagnostics;\n\nclass Program\n{\n\n\n/* \n    احسب الجداء النقطي لمتجهين صحيحين ذوي أبعاد n.\n    الجداء النقطي هو مجموع نواتج العناصر المقابلة للمتجهين.\n\n    المثال 1:\n    >>> CalculateDotProduct(new List<int> {1, 3, -5}, new List<int> {4, -2, -1})\n    3\n\n    المثال 2:\n    >>> CalculateDotProduct(new List<int> {2, 5, 7}, new List<int> {3, 6, 8})\n    100\n*/\n\nstatic int CalculateDotProduct(List<int> vectorA, List<int> vectorB)",
      "sw": "using System;\nusing System.Collections.Generic;\nusing System.Diagnostics;\n\nclass Program\n{\n\n\n/* \n    Hesabu toleo la nukta la vekta mbili za n-dimensional integer.\n    Toleo la nukta ni jumla ya bidhaa za vipengele vinavyolingana vya vekta mbili.\n\n    Mfano 1:\n    >>> CalculateDotProduct(new List<int> {1, 3, -5}, new List<int> {4, -2, -1})\n    3\n\n    Mfano 2:\n    >>> CalculateDotProduct(new List<int> {2, 5, 7}, new List<int> {3, 6, 8})\n    100\n*/\n\nstatic int CalculateDotProduct(List<int> vectorA, List<int> vectorB)",
      "tr": "using System;\nusing System.Collections.Generic;\nusing System.Diagnostics;\n\nclass Program\n{\n\n\n/* \n    İki n boyutlu tamsayı vektörünün nokta çarpımını hesaplayın.\n    Nokta çarpımı, iki vektörün karşılık gelen elemanlarının çarpımlarının toplamıdır.\n\n    Örnek 1:\n    >>> CalculateDotProduct(new List<int> {1, 3, -5}, new List<int> {4, -2, -1})\n    3\n\n    Örnek 2:\n    >>> CalculateDotProduct(new List<int> {2, 5, 7}, new List<int> {3, 6, 8})\n    100\n*/\n\nstatic int CalculateDotProduct(List<int> vectorA, List<int> vectorB)",
      "vi": "using System;\nusing System.Collections.Generic;\nusing System.Diagnostics;\n\nclass Program\n{\n\n\n/* \n    Tính tích vô hướng của hai vector số nguyên n chiều.\n    Tích vô hướng là tổng của các tích của các phần tử tương ứng của hai vector.\n\n    Ví dụ 1:\n    >>> CalculateDotProduct(new List<int> {1, 3, -5}, new List<int> {4, -2, -1})\n    3\n\n    Ví dụ 2:\n    >>> CalculateDotProduct(new List<int> {2, 5, 7}, new List<int> {3, 6, 8})\n    100\n*/\n\nstatic int CalculateDotProduct(List<int> vectorA, List<int> vectorB)"
    },
    "prompt_bertscore": {
      "es": "1",
      "arb": "0.9879923962056789",
      "sw": "1",
      "tr": "1",
      "vi": "1"
    },
    "canonical_solution": "{\n    if (vectorA.Count != vectorB.Count)\n        throw new ArgumentException(\"Vectors must be of the same dimension.\");\n\n    int dotProduct = 0;\n    for (int i = 0; i < vectorA.Count; i++)\n    {\n        dotProduct += vectorA[i] * vectorB[i];\n    }\n    return dotProduct;\n}",
    "instruction": {
      "es": "static int CalculateDotProduct(List<int> vectorA, List<int> vectorB)\n{\n    if (vectorA.Count != vectorB.Count)\n        throw new ArgumentException(\"Vectors must be of the same dimension.\");\n\n    int dotProduct = 0;\n    for (int i = 0; i < vectorA.Count; i++)\n    {\n        dotProduct += vectorA[i] * vectorB[i];\n    }\n    return dotProduct;\n}\n\nProporcione una descripción concisa en lenguaje natural (docstring) del código C# en español utilizando un máximo de 500 caracteres.",
      "arb": "static int CalculateDotProduct(List<int> vectorA, List<int> vectorB)\n{\n    if (vectorA.Count != vectorB.Count)\n        throw new ArgumentException(\"Vectors must be of the same dimension.\");\n\n    int dotProduct = 0;\n    for (int i = 0; i < vectorA.Count; i++)\n    {\n        dotProduct += vectorA[i] * vectorB[i];\n    }\n    return dotProduct;\n}\n\nيرجى تقديم وصف موجز بلغة طبيعية (docstring) للشفرة البرمجية المكتوبة بلغة C# باللغة العربية الفصحى، باستخدام 500 حرف كحد أقصى.",
      "sw": "static int CalculateDotProduct(List<int> vectorA, List<int> vectorB)\n{\n    if (vectorA.Count != vectorB.Count)\n        throw new ArgumentException(\"Vectors must be of the same dimension.\");\n\n    int dotProduct = 0;\n    for (int i = 0; i < vectorA.Count; i++)\n    {\n        dotProduct += vectorA[i] * vectorB[i];\n    }\n    return dotProduct;\n}\n\nToa maelezo mafupi ya lugha asilia (docstring) ya msimbo wa C# kwa Kiswahili kwa kutumia herufi zisizozidi 500.",
      "tr": "static int CalculateDotProduct(List<int> vectorA, List<int> vectorB)\n{\n    if (vectorA.Count != vectorB.Count)\n        throw new ArgumentException(\"Vectors must be of the same dimension.\");\n\n    int dotProduct = 0;\n    for (int i = 0; i < vectorA.Count; i++)\n    {\n        dotProduct += vectorA[i] * vectorB[i];\n    }\n    return dotProduct;\n}\n\nC# kodunun Türkçe dilinde en fazla 500 karakter kullanarak özlü bir doğal dil açıklamasını (docstring) sağlayın.",
      "vi": "static int CalculateDotProduct(List<int> vectorA, List<int> vectorB)\n{\n    if (vectorA.Count != vectorB.Count)\n        throw new ArgumentException(\"Vectors must be of the same dimension.\");\n\n    int dotProduct = 0;\n    for (int i = 0; i < vectorA.Count; i++)\n    {\n        dotProduct += vectorA[i] * vectorB[i];\n    }\n    return dotProduct;\n}\n\nCung cấp mô tả ngắn gọn bằng ngôn ngữ tự nhiên (docstring) cho mã C# bằng tiếng Việt với tối đa 500 ký tự."
    },
    "instruction_bertscore": {
      "es": "0.9702167647764858",
      "arb": "0.9080967021508728",
      "sw": "0.9446027812508938",
      "tr": "0.9520575780815143",
      "vi": "0.9066002208601559"
    },
    "level": "",
    "test": "    static void Main()\n    {\n        Debug.Assert(CalculateDotProduct(new List<int> {1, 3, -5}, new List<int> {4, -2, -1}) == 3);\n        Debug.Assert(CalculateDotProduct(new List<int> {2, 5, 7}, new List<int> {3, 6, 8}) == 92);\n        Debug.Assert(CalculateDotProduct(new List<int> {0, 0, 0}, new List<int> {0, 0, 0}) == 0);\n        Debug.Assert(CalculateDotProduct(new List<int> {1, 2}, new List<int> {3, 4}) == 11);\n\n    }\n}",
    "entry_point": "CalculateDotProduct",
    "signature": "static int CalculateDotProduct(List<int> vectorA, List<int> vectorB)",
    "docstring": {
      "es": "Calcular el producto punto de dos vectores enteros n-dimensionales.  \nEl producto punto es la suma de los productos de los elementos correspondientes de los dos vectores.\n\nEjemplo 1:\n>>> CalculateDotProduct(new List<int> {1, 3, -5}, new List<int> {4, -2, -1})\n3\n\nEjemplo 2:\n>>> CalculateDotProduct(new List<int> {2, 5, 7}, new List<int> {3, 6, 8})\n100",
      "arb": "احسب الجداء النقطي لمتجهين صحيحين من الأبعاد n.\n    الجداء النقطي هو مجموع نواتج العناصر المقابلة للمتجهين.\n\n    المثال 1:\n    >>> CalculateDotProduct(new List<int> {1, 3, -5}, new List<int> {4, -2, -1})\n    3\n\n    المثال 2:\n    >>> CalculateDotProduct(new List<int> {2, 5, 7}, new List<int> {3, 6, 8})\n    100",
      "sw": "Hesabu tokeo la nukta la vekta mbili za n-dimensional integer.\n    Tokeo la nukta ni jumla ya bidhaa za vipengele vinavyolingana vya vekta mbili.\n\n    Mfano 1:\n    >>> CalculateDotProduct(new List<int> {1, 3, -5}, new List<int> {4, -2, -1})\n    3\n\n    Mfano 2:\n    >>> CalculateDotProduct(new List<int> {2, 5, 7}, new List<int> {3, 6, 8})\n    100",
      "tr": "İki n boyutlu tamsayı vektörünün nokta çarpımını hesaplayın. \n    Nokta çarpımı, iki vektörün karşılık gelen elemanlarının çarpımlarının toplamıdır.\n\n    Örnek 1:\n    >>> CalculateDotProduct(new List<int> {1, 3, -5}, new List<int> {4, -2, -1})\n    3\n\n    Örnek 2:\n    >>> CalculateDotProduct(new List<int> {2, 5, 7}, new List<int> {3, 6, 8})\n    100",
      "vi": "Tính tích vô hướng của hai vector số nguyên n chiều.  \n    Tích vô hướng là tổng của các tích của các phần tử tương ứng của hai vector.\n\n    Ví dụ 1:\n    >>> CalculateDotProduct(new List<int> {1, 3, -5}, new List<int> {4, -2, -1})\n    3\n\n    Ví dụ 2:\n    >>> CalculateDotProduct(new List<int> {2, 5, 7}, new List<int> {3, 6, 8})\n    100"
    },
    "docstring_bertscore": {
      "es": "1",
      "arb": "0.9897139257181083",
      "sw": "1",
      "tr": "1",
      "vi": "1"
    }
  },
  {
    "task_id": "C#/24",
    "prompt": {
      "es": "using System;\nusing System.Collections.Generic;\nusing System.Diagnostics;\nusing System.Numerics;\nclass Program\n{\n\n    \n\n    /* Calcula el valor de 2 elevado a la potencia de un entero no negativo dado 'n'.\n    Esta función utiliza aritmética de alta precisión para manejar exponentes grandes.\n    Ejemplos:\n    >>> CalculatePowerOfTwo(3)\n    8\n    >>> CalculatePowerOfTwo(10)\n    1024\n    >>> CalculatePowerOfTwo(0)\n    1\n    */\n\n    static BigInteger CalculatePowerOfTwo(int n)",
      "arb": "using System;\nusing System.Collections.Generic;\nusing System.Diagnostics;\nusing System.Numerics;\nclass Program\n{\n\n    \n\n    /* احسب قيمة 2 مرفوعة إلى قوة عدد صحيح غير سالب 'n'.\n    تستخدم هذه الدالة الحسابات عالية الدقة للتعامل مع الأسس الكبيرة.\n    أمثلة:\n    >>> CalculatePowerOfTwo(3)\n    8\n    >>> CalculatePowerOfTwo(10)\n    1024\n    >>> CalculatePowerOfTwo(0)\n    1\n    */\n\n    static BigInteger CalculatePowerOfTwo(int n)",
      "sw": "using System;\nusing System.Collections.Generic;\nusing System.Diagnostics;\nusing System.Numerics;\nclass Program\n{\n\n    \n\n    /* Hesabu thamani ya 2 iliyopandishwa kwa nguvu ya nambari isiyo hasi 'n'.\n    Kazi hii inatumia hesabu ya usahihi wa juu kushughulikia viinua vikubwa.\n    Mifano:\n    >>> CalculatePowerOfTwo(3)\n    8\n    >>> CalculatePowerOfTwo(10)\n    1024\n    >>> CalculatePowerOfTwo(0)\n    1\n    */\n\n    static BigInteger CalculatePowerOfTwo(int n)",
      "tr": "using System;\nusing System.Collections.Generic;\nusing System.Diagnostics;\nusing System.Numerics;\nclass Program\n{\n\n    \n\n    /* Verilen pozitif olmayan bir tamsayı 'n' için 2'nin kuvvetini hesaplayın.\n    Bu fonksiyon, büyük üslü sayıları işlemek için yüksek hassasiyetli aritmetik kullanır.\n    Örnekler:\n    >>> CalculatePowerOfTwo(3)\n    8\n    >>> CalculatePowerOfTwo(10)\n    1024\n    >>> CalculatePowerOfTwo(0)\n    1\n    */\n\n    static BigInteger CalculatePowerOfTwo(int n)",
      "vi": "using System;\nusing System.Collections.Generic;\nusing System.Diagnostics;\nusing System.Numerics;\nclass Program\n{\n\n    \n\n    /* Tính giá trị của 2 lũy thừa của một số nguyên không âm 'n' cho trước.\n    Hàm này sử dụng số học độ chính xác cao để xử lý các số mũ lớn.\n    Ví dụ:\n    >>> CalculatePowerOfTwo(3)\n    8\n    >>> CalculatePowerOfTwo(10)\n    1024\n    >>> CalculatePowerOfTwo(0)\n    1\n    */\n\n    static BigInteger CalculatePowerOfTwo(int n)"
    },
    "prompt_bertscore": {
      "es": "0.9985976695098937",
      "arb": "0.9904321731759305",
      "sw": "0.983688274479034",
      "tr": "0.9614228019169282",
      "vi": "0.9961030705544766"
    },
    "canonical_solution": "    {\n        BigInteger result = 1;\n        for (int i = 0; i < n; i++)\n        {\n            result *= 2;\n        }\n        return result;\n    }",
    "instruction": {
      "es": "static BigInteger CalculatePowerOfTwo(int n)\n    {\n        BigInteger result = 1;\n        for (int i = 0; i < n; i++)\n        {\n            result *= 2;\n        }\n        return result;\n    }\n\nProporcione una descripción concisa en lenguaje natural (docstring) del código C# en español utilizando un máximo de 500 caracteres.",
      "arb": "static BigInteger CalculatePowerOfTwo(int n)\n    {\n        BigInteger result = 1;\n        for (int i = 0; i < n; i++)\n        {\n            result *= 2;\n        }\n        return result;\n    }\n\nيرجى تقديم وصف موجز بلغة طبيعية (docstring) للكود المكتوب بلغة C# باللغة العربية الفصحى، بحيث لا يتجاوز 500 حرف.",
      "sw": "static BigInteger CalculatePowerOfTwo(int n)\n    {\n        BigInteger result = 1;\n        for (int i = 0; i < n; i++)\n        {\n            result *= 2;\n        }\n        return result;\n    }\n\nToa maelezo mafupi ya lugha asilia (docstring) ya msimbo wa C# kwa Kiswahili kwa kutumia herufi zisizozidi 500.",
      "tr": "static BigInteger CalculatePowerOfTwo(int n)\n    {\n        BigInteger result = 1;\n        for (int i = 0; i < n; i++)\n        {\n            result *= 2;\n        }\n        return result;\n    }\n\nAşağıdaki C# kodunun işlevini en fazla 500 karakter kullanarak Türkçe bir doğal dil açıklaması (docstring) sağlayın.",
      "vi": "static BigInteger CalculatePowerOfTwo(int n)\n    {\n        BigInteger result = 1;\n        for (int i = 0; i < n; i++)\n        {\n            result *= 2;\n        }\n        return result;\n    }\n\nCung cấp mô tả ngắn gọn bằng ngôn ngữ tự nhiên (docstring) cho mã C# bằng tiếng Việt, không quá 500 ký tự."
    },
    "instruction_bertscore": {
      "es": "0.9702167647764858",
      "arb": "0.8829437397396628",
      "sw": "0.9446027812508938",
      "tr": "0.8553603359861099",
      "vi": "0.9093975325162702"
    },
    "level": "",
    "test": "    static void Main()\n    {           \n        Debug.Assert(CalculatePowerOfTwo(3).Equals(new BigInteger(8)));\n        Debug.Assert(CalculatePowerOfTwo(10).Equals(new BigInteger(1024)));\n        Debug.Assert(CalculatePowerOfTwo(15).Equals(new BigInteger(32768)));\n        Debug.Assert(CalculatePowerOfTwo(0).Equals(new BigInteger(1)));\n\n    }\n}\n",
    "entry_point": "CalculatePowerOfTwo",
    "signature": "static BigInteger CalculatePowerOfTwo(int n)",
    "docstring": {
      "es": "Calcular el valor de 2 elevado a la potencia de un entero no negativo 'n'.\n    Esta función utiliza aritmética de alta precisión para manejar exponentes grandes.\n    Ejemplos:\n    >>> CalculatePowerOfTwo(3)\n    8\n    >>> CalculatePowerOfTwo(10)\n    1024\n    >>> CalculatePowerOfTwo(0)\n    1",
      "arb": "احسب قيمة 2 مرفوعة إلى أس العدد الصحيح غير السالب 'n'.\n    تستخدم هذه الدالة الحساب الدقيق للتعامل مع الأسس الكبيرة.\n    أمثلة:\n    >>> CalculatePowerOfTwo(3)\n    8\n    >>> CalculatePowerOfTwo(10)\n    1024\n    >>> CalculatePowerOfTwo(0)\n    1",
      "sw": "Hesabu thamani ya 2 iliyopandishwa kwa nguvu ya nambari kamili isiyo na alama hasi 'n'.  \n    Kazi hii hutumia hesabu ya usahihi wa hali ya juu kushughulikia viinua vikubwa.  \n    Mifano:  \n    >>> CalculatePowerOfTwo(3)  \n    8  \n    >>> CalculatePowerOfTwo(10)  \n    1024  \n    >>> CalculatePowerOfTwo(0)  \n    1  ",
      "tr": "Verilen negatif olmayan bir tamsayı 'n' için 2'nin kuvvetini hesaplayın.\n    Bu fonksiyon, büyük üsleri işlemek için yüksek hassasiyetli aritmetik kullanır.\n    Örnekler:\n    >>> CalculatePowerOfTwo(3)\n    8\n    >>> CalculatePowerOfTwo(10)\n    1024\n    >>> CalculatePowerOfTwo(0)\n    1",
      "vi": "Tính giá trị của 2 lũy thừa với số nguyên không âm 'n' cho trước. \n    Hàm này sử dụng số học độ chính xác cao để xử lý các số mũ lớn.\n    Ví dụ:\n    >>> CalculatePowerOfTwo(3)\n    8\n    >>> CalculatePowerOfTwo(10)\n    1024\n    >>> CalculatePowerOfTwo(0)\n    1"
    },
    "docstring_bertscore": {
      "es": "0.9912008727505355",
      "arb": "0.9641059011039474",
      "sw": "0.9833508014616557",
      "tr": "0.9611985482167398",
      "vi": "0.9976281546200624"
    }
  },
  {
    "task_id": "C#/25",
    "prompt": {
      "es": "using System;\nusing System.Collections.Generic;\nusing System.Diagnostics;\n\nclass Program\n{\n\n/* Encuentra el primer carácter en una cadena que aparece solo una vez.\n   Si todos los caracteres aparecen más de una vez o la cadena está vacía, devuelve 'n' como carácter.\n   Ejemplos:\n   - FirstUniqueChar(\"aabbcdde\") debería devolver 'c'.\n   - FirstUniqueChar(\"aabbcc\") debería devolver 'n', representando \"no\".\n   - FirstUniqueChar(\"xxyyzz\") debería devolver 'n'.\n   - FirstUniqueChar(\"\") debería devolver 'n'.\n*/\n    static char FirstUniqueChar(string str)",
      "arb": "using System;\nusing System.Collections.Generic;\nusing System.Diagnostics;\n\nclass Program\n{\n\n/* يجد أول حرف في سلسلة يظهر مرة واحدة فقط.\n   إذا ظهرت جميع الأحرف أكثر من مرة أو كانت السلسلة فارغة، فإنه يعيد 'n' كحرف.\n   أمثلة:\n   - FirstUniqueChar(\"aabbcdde\") يجب أن تعيد 'c'.\n   - FirstUniqueChar(\"aabbcc\") يجب أن تعيد 'n'، لتمثيل \"لا\".\n   - FirstUniqueChar(\"xxyyzz\") يجب أن تعيد 'n'.\n   - FirstUniqueChar(\"\") يجب أن تعيد 'n'.\n*/\n    static char FirstUniqueChar(string str)",
      "sw": "using System;\nusing System.Collections.Generic;\nusing System.Diagnostics;\n\nclass Program\n{\n\n/* Inapata herufi ya kwanza katika kamba ambayo inaonekana mara moja tu.\n   Ikiwa herufi zote zinaonekana zaidi ya mara moja au kamba ni tupu, inarudisha 'n' kama herufi.\n   Mifano:\n   - FirstUniqueChar(\"aabbcdde\") inapaswa kurudisha 'c'.\n   - FirstUniqueChar(\"aabbcc\") inapaswa kurudisha 'n', ikiwakilisha \"hapana\".\n   - FirstUniqueChar(\"xxyyzz\") inapaswa kurudisha 'n'.\n   - FirstUniqueChar(\"\") inapaswa kurudisha 'n'.\n*/\n    static char FirstUniqueChar(string str)",
      "tr": "using System;\nusing System.Collections.Generic;\nusing System.Diagnostics;\n\nclass Program\n{\n\n/* Bir dizgede yalnızca bir kez görünen ilk karakteri bulur.\n   Tüm karakterler birden fazla kez görünüyorsa veya dizge boşsa, 'no' karakteri olarak 'n' döner.\n   Örnekler:\n   - FirstUniqueChar(\"aabbcdde\") 'c' döndürmelidir.\n   - FirstUniqueChar(\"aabbcc\") 'n' döndürmelidir, bu \"no\"yu temsil eder.\n   - FirstUniqueChar(\"xxyyzz\") 'n' döndürmelidir.\n   - FirstUniqueChar(\"\") 'n' döndürmelidir.\n*/\n    static char FirstUniqueChar(string str)",
      "vi": "using System;\nusing System.Collections.Generic;\nusing System.Diagnostics;\n\nclass Program\n{\n\n/* Tìm ký tự đầu tiên trong một chuỗi xuất hiện duy nhất một lần.\n   Nếu tất cả các ký tự xuất hiện nhiều hơn một lần hoặc chuỗi rỗng, nó trả về 'no' như một ký tự.\n   Ví dụ:\n   - FirstUniqueChar(\"aabbcdde\") nên trả về 'c'.\n   - FirstUniqueChar(\"aabbcc\") nên trả về 'n', đại diện cho \"no\".\n   - FirstUniqueChar(\"xxyyzz\") nên trả về 'n'.\n   - FirstUniqueChar(\"\") nên trả về 'n'.\n*/\n    static char FirstUniqueChar(string str)"
    },
    "prompt_bertscore": {
      "es": "0.9910677903952421",
      "arb": "0.9946862400465547",
      "sw": "0.9882881568430398",
      "tr": "0.974715742906926",
      "vi": "0.9886738970430097"
    },
    "canonical_solution": "    {\n        if (string.IsNullOrEmpty(str))\n            return 'n';\n\n        Dictionary<char, int> charCount = new Dictionary<char, int>();\n        foreach (char c in str)\n        {\n            if (charCount.ContainsKey(c))\n                charCount[c]++;\n            else\n                charCount[c] = 1;\n        }\n\n        foreach (char c in str)\n        {\n            if (charCount[c] == 1)\n                return c;\n        }\n\n        return 'n';\n    }",
    "instruction": {
      "es": "static char FirstUniqueChar(string str)\n    {\n        if (string.IsNullOrEmpty(str))\n            return 'n';\n\n        Dictionary<char, int> charCount = new Dictionary<char, int>();\n        foreach (char c in str)\n        {\n            if (charCount.ContainsKey(c))\n                charCount[c]++;\n            else\n                charCount[c] = 1;\n        }\n\n        foreach (char c in str)\n        {\n            if (charCount[c] == 1)\n                return c;\n        }\n\n        return 'n';\n    }\n\nProporcione una descripción concisa en lenguaje natural (docstring) del código C# en español utilizando como máximo 500 caracteres.",
      "arb": "static char FirstUniqueChar(string str)\n    {\n        if (string.IsNullOrEmpty(str))\n            return 'n';\n\n        Dictionary<char, int> charCount = new Dictionary<char, int>();\n        foreach (char c in str)\n        {\n            if (charCount.ContainsKey(c))\n                charCount[c]++;\n            else\n                charCount[c] = 1;\n        }\n\n        foreach (char c in str)\n        {\n            if (charCount[c] == 1)\n                return c;\n        }\n\n        return 'n';\n    }\n\nيرجى تقديم وصف موجز بلغة طبيعية (docstring) للكود المكتوب بلغة C# باللغة العربية الفصحى، بحيث لا يتجاوز 500 حرف.",
      "sw": "static char FirstUniqueChar(string str)\n    {\n        if (string.IsNullOrEmpty(str))\n            return 'n';\n\n        Dictionary<char, int> charCount = new Dictionary<char, int>();\n        foreach (char c in str)\n        {\n            if (charCount.ContainsKey(c))\n                charCount[c]++;\n            else\n                charCount[c] = 1;\n        }\n\n        foreach (char c in str)\n        {\n            if (charCount[c] == 1)\n                return c;\n        }\n\n        return 'n';\n    }\n\nToa maelezo mafupi ya lugha asilia (docstring) ya msimbo wa C# kwa Kiswahili kwa kutumia herufi zisizozidi 500.",
      "tr": "static char FirstUniqueChar(string str)\n    {\n        if (string.IsNullOrEmpty(str))\n            return 'n';\n\n        Dictionary<char, int> charCount = new Dictionary<char, int>();\n        foreach (char c in str)\n        {\n            if (charCount.ContainsKey(c))\n                charCount[c]++;\n            else\n                charCount[c] = 1;\n        }\n\n        foreach (char c in str)\n        {\n            if (charCount[c] == 1)\n                return c;\n        }\n\n        return 'n';\n    }\n\nAşağıdaki C# kodunun işlevini açıklayan, en fazla 500 karakter uzunluğunda, özlü bir doğal dil açıklaması (docstring) sağlayın.",
      "vi": "static char FirstUniqueChar(string str)\n    {\n        if (string.IsNullOrEmpty(str))\n            return 'n';\n\n        Dictionary<char, int> charCount = new Dictionary<char, int>();\n        foreach (char c in str)\n        {\n            if (charCount.ContainsKey(c))\n                charCount[c]++;\n            else\n                charCount[c] = 1;\n        }\n\n        foreach (char c in str)\n        {\n            if (charCount[c] == 1)\n                return c;\n        }\n\n        return 'n';\n    }\n\nCung cấp mô tả ngắn gọn bằng ngôn ngữ tự nhiên (docstring) cho mã C# bằng tiếng Việt, sử dụng tối đa 500 ký tự."
    },
    "instruction_bertscore": {
      "es": "0.9702167647764858",
      "arb": "0.8716935135882278",
      "sw": "0.9446027812508938",
      "tr": "0.8509189606661699",
      "vi": "0.912055207014517"
    },
    "level": "",
    "test": "    static void Main()\n    {\n        Debug.Assert(FirstUniqueChar(\"aabbcdde\") == 'c');\n        Debug.Assert(FirstUniqueChar(\"aabbcc\") == 'n');\n        Debug.Assert(FirstUniqueChar(\"xxyyazz\") == 'a');\n        Debug.Assert(FirstUniqueChar(\"\") == 'n');\n        Debug.Assert(FirstUniqueChar(\"aabbcceeddf\") == 'f');\n\n    }\n}",
    "entry_point": "FirstUniqueChar",
    "signature": "static char FirstUniqueChar(string str)",
    "docstring": {
      "es": "Encuentra el primer carácter en una cadena que aparece solo una vez.\n   Si todos los caracteres aparecen más de una vez o la cadena está vacía, devuelve 'n' como carácter.\n   Ejemplos:\n   - FirstUniqueChar(\"aabbcdde\") debería devolver 'c'.\n   - FirstUniqueChar(\"aabbcc\") debería devolver 'n', representando \"no\".\n   - FirstUniqueChar(\"xxyyzz\") debería devolver 'n'.\n   - FirstUniqueChar(\"\") debería devolver 'n'.",
      "arb": "يجد أول حرف في سلسلة يظهر مرة واحدة فقط.\n   إذا ظهرت جميع الأحرف أكثر من مرة أو كانت السلسلة فارغة، فإنه يعيد 'n' كحرف.\n   أمثلة:\n   - FirstUniqueChar(\"aabbcdde\") يجب أن يعيد 'c'.\n   - FirstUniqueChar(\"aabbcc\") يجب أن يعيد 'n'، مما يمثل \"لا\".\n   - FirstUniqueChar(\"xxyyzz\") يجب أن يعيد 'n'.\n   - FirstUniqueChar(\"\") يجب أن يعيد 'n'.",
      "sw": "Inapata herufi ya kwanza katika kamba inayotokea mara moja tu.  \n   Ikiwa herufi zote zinatokea zaidi ya mara moja au kamba ni tupu, inarudisha 'n' kama herufi.  \n   Mifano:  \n   - FirstUniqueChar(\"aabbcdde\") inapaswa kurudisha 'c'.  \n   - FirstUniqueChar(\"aabbcc\") inapaswa kurudisha 'n', ikiwakilisha \"hapana\".  \n   - FirstUniqueChar(\"xxyyzz\") inapaswa kurudisha 'n'.  \n   - FirstUniqueChar(\"\") inapaswa kurudisha 'n'.  ",
      "tr": "Bir dizgede yalnızca bir kez görünen ilk karakteri bulur.\nTüm karakterler birden fazla kez görünüyorsa veya dize boşsa, karakter olarak 'no' döndürür. \nÖrnekler:\n- FirstUniqueChar(\"aabbcdde\") should return 'c'.  \n- FirstUniqueChar(\"aabbcdde\") 'c' döndürmelidir.\n- FirstUniqueChar(\"aabbcc\") should return 'n', representing \"no\".  \n- FirstUniqueChar(\"aabbcc\") \"hayır\"ı temsil eden 'n' döndürmelidir.\n- FirstUniqueChar(\"xxyyzz\") should return 'n'.  \n- FirstUniqueChar(\"xxyyzz\") 'n' döndürmelidir.\n- FirstUniqueChar(\"\") should return 'n'.  \n- FirstUniqueChar(\"\") 'n' döndürmelidir.",
      "vi": "Tìm ký tự đầu tiên trong một chuỗi xuất hiện duy nhất một lần.\n   Nếu tất cả các ký tự xuất hiện nhiều hơn một lần hoặc chuỗi rỗng, nó trả về 'n' như một ký tự.\n   Ví dụ:\n   - FirstUniqueChar(\"aabbcdde\") nên trả về 'c'.\n   - FirstUniqueChar(\"aabbcc\") nên trả về 'n', đại diện cho \"không\".\n   - FirstUniqueChar(\"xxyyzz\") nên trả về 'n'.\n   - FirstUniqueChar(\"\") nên trả về 'n'."
    },
    "docstring_bertscore": {
      "es": "0.9749529075818817",
      "arb": "0.9849398445099348",
      "sw": "0.9737017348117428",
      "tr": "0.9298737426060137",
      "vi": "0.9782469938209643"
    }
  },
  {
    "task_id": "C#/26",
    "prompt": {
      "es": "using System;\nusing System.Collections.Generic;\nusing System.Diagnostics;\n\nclass Program\n{\n\n/* Determina si dos secuencias de ADN están relacionadas en función del umbral de similitud.\n   La función compara dos secuencias de ADN de la misma longitud, par de bases por par de bases.\n   Si la proporción de pares de bases idénticos es mayor o igual al umbral dado,\n   las secuencias se consideran relacionadas.\n   \n   Ejemplo:\n   >>> AreDNAsRelated(\"ATCG\", \"ATCC\", 0.75)\n   true\n*/\n\n    static bool AreDNAsRelated(string dnaSequence1, string dnaSequence2, double similarityThreshold)",
      "arb": "using System;\nusing System.Collections.Generic;\nusing System.Diagnostics;\n\nclass Program\n{\n\n/* يحدد ما إذا كانت سلسلتان من الحمض النووي متعلقتين بناءً على عتبة التشابه.\n   تقارن الدالة سلسلتين من الحمض النووي لهما نفس الطول، زوج قاعدة بزوج قاعدة.\n   إذا كانت نسبة أزواج القواعد المتطابقة أكبر من أو تساوي العتبة المحددة،\n   تعتبر السلسلتان متعلقتين.\n   \n   مثال:\n   >>> AreDNAsRelated(\"ATCG\", \"ATCC\", 0.75)\n   true\n*/\n\n    static bool AreDNAsRelated(string dnaSequence1, string dnaSequence2, double similarityThreshold)",
      "sw": "using System;\nusing System.Collections.Generic;\nusing System.Diagnostics;\n\nclass Program\n{\n\n/* Huamua ikiwa mlolongo miwili ya DNA yanahusiana kulingana na kizingiti cha kufanana.\n   Kazi hii inalinganisha mlolongo miwili ya DNA yenye urefu sawa, jozi kwa jozi.\n   Ikiwa uwiano wa jozi za msingi zinazofanana ni kubwa au sawa na kizingiti kilichopewa,\n   milolongo hiyo inachukuliwa kuwa inahusiana.\n   \n   Mfano:\n   >>> AreDNAsRelated(\"ATCG\", \"ATCC\", 0.75)\n   true\n*/\n\n    static bool AreDNAsRelated(string dnaSequence1, string dnaSequence2, double similarityThreshold)",
      "tr": "using System;\nusing System.Collections.Generic;\nusing System.Diagnostics;\n\nclass Program\n{\n\n/* İki DNA dizisinin benzerlik eşiğine göre ilişkili olup olmadığını belirler.\n   Fonksiyon, aynı uzunluktaki iki DNA dizisini baz çifti bazında karşılaştırır.\n   Eğer özdeş baz çiftlerinin oranı verilen eşikten büyük veya eşitse,\n   diziler ilişkili kabul edilir.\n   \n   Örnek:\n   >>> AreDNAsRelated(\"ATCG\", \"ATCC\", 0.75)\n   true\n*/\n\n    static bool AreDNAsRelated(string dnaSequence1, string dnaSequence2, double similarityThreshold)",
      "vi": "using System;\nusing System.Collections.Generic;\nusing System.Diagnostics;\n\nclass Program\n{\n\n/* Xác định xem hai chuỗi DNA có liên quan hay không dựa trên ngưỡng tương đồng.\n   Hàm so sánh hai chuỗi DNA có cùng độ dài, từng cặp base một.\n   Nếu tỷ lệ các cặp base giống nhau lớn hơn hoặc bằng ngưỡng cho trước,\n   các chuỗi được coi là có liên quan.\n   \n   Ví dụ:\n   >>> AreDNAsRelated(\"ATCG\", \"ATCC\", 0.75)\n   true\n*/\n\n    static bool AreDNAsRelated(string dnaSequence1, string dnaSequence2, double similarityThreshold)"
    },
    "prompt_bertscore": {
      "es": "1",
      "arb": "0.9860615102716388",
      "sw": "0.969364044550703",
      "tr": "0.9760419979610959",
      "vi": "0.9817772515830973"
    },
    "canonical_solution": "    {\n        if (dnaSequence1.Length != dnaSequence2.Length)\n            throw new ArgumentException(\"DNA sequences must be of the same length.\");\n\n        int identicalPairsCount = 0;\n        for (int i = 0; i < dnaSequence1.Length; i++)\n        {\n            if (dnaSequence1[i] == dnaSequence2[i])\n                identicalPairsCount++;\n        }\n\n        double similarity = (double)identicalPairsCount / dnaSequence1.Length;\n        return similarity >= similarityThreshold;\n    }",
    "instruction": {
      "es": "static bool AreDNAsRelated(string dnaSequence1, string dnaSequence2, double similarityThreshold)\n    {\n        if (dnaSequence1.Length != dnaSequence2.Length)\n            throw new ArgumentException(\"DNA sequences must be of the same length.\");\n\n        int identicalPairsCount = 0;\n        for (int i = 0; i < dnaSequence1.Length; i++)\n        {\n            if (dnaSequence1[i] == dnaSequence2[i])\n                identicalPairsCount++;\n        }\n\n        double similarity = (double)identicalPairsCount / dnaSequence1.Length;\n        return similarity >= similarityThreshold;\n    }\n\nProporcione una descripción concisa en lenguaje natural (docstring) del código C# en español utilizando como máximo 500 caracteres.",
      "arb": "static bool AreDNAsRelated(string dnaSequence1, string dnaSequence2, double similarityThreshold)\n    {\n        if (dnaSequence1.Length != dnaSequence2.Length)\n            throw new ArgumentException(\"DNA sequences must be of the same length.\");\n\n        int identicalPairsCount = 0;\n        for (int i = 0; i < dnaSequence1.Length; i++)\n        {\n            if (dnaSequence1[i] == dnaSequence2[i])\n                identicalPairsCount++;\n        }\n\n        double similarity = (double)identicalPairsCount / dnaSequence1.Length;\n        return similarity >= similarityThreshold;\n    }\n\nيرجى تقديم وصف موجز بلغة طبيعية (docstring) للكود المكتوب بلغة C# باللغة العربية الفصحى، بحيث لا يتجاوز 500 حرف.",
      "sw": "static bool AreDNAsRelated(string dnaSequence1, string dnaSequence2, double similarityThreshold)\n    {\n        if (dnaSequence1.Length != dnaSequence2.Length)\n            throw new ArgumentException(\"DNA sequences must be of the same length.\");\n\n        int identicalPairsCount = 0;\n        for (int i = 0; i < dnaSequence1.Length; i++)\n        {\n            if (dnaSequence1[i] == dnaSequence2[i])\n                identicalPairsCount++;\n        }\n\n        double similarity = (double)identicalPairsCount / dnaSequence1.Length;\n        return similarity >= similarityThreshold;\n    }\n\nToa maelezo mafupi ya lugha asilia (docstring) ya msimbo wa C# kwa Kiswahili kwa kutumia herufi zisizozidi 500.",
      "tr": "static bool AreDNAsRelated(string dnaSequence1, string dnaSequence2, double similarityThreshold)\n    {\n        if (dnaSequence1.Length != dnaSequence2.Length)\n            throw new ArgumentException(\"DNA sequences must be of the same length.\");\n\n        int identicalPairsCount = 0;\n        for (int i = 0; i < dnaSequence1.Length; i++)\n        {\n            if (dnaSequence1[i] == dnaSequence2[i])\n                identicalPairsCount++;\n        }\n\n        double similarity = (double)identicalPairsCount / dnaSequence1.Length;\n        return similarity >= similarityThreshold;\n    }\n\nC# kodunun işlevini açıklayan en fazla 500 karakterlik özlü bir doğal dil açıklaması (docstring) sağlayın.",
      "vi": "static bool AreDNAsRelated(string dnaSequence1, string dnaSequence2, double similarityThreshold)\n    {\n        if (dnaSequence1.Length != dnaSequence2.Length)\n            throw new ArgumentException(\"DNA sequences must be of the same length.\");\n\n        int identicalPairsCount = 0;\n        for (int i = 0; i < dnaSequence1.Length; i++)\n        {\n            if (dnaSequence1[i] == dnaSequence2[i])\n                identicalPairsCount++;\n        }\n\n        double similarity = (double)identicalPairsCount / dnaSequence1.Length;\n        return similarity >= similarityThreshold;\n    }\n\nCung cấp mô tả ngắn gọn bằng ngôn ngữ tự nhiên (docstring) cho mã C# bằng tiếng Việt, sử dụng tối đa 500 ký tự."
    },
    "instruction_bertscore": {
      "es": "0.9702167647764858",
      "arb": "0.8829437397396628",
      "sw": "0.9446027812508938",
      "tr": "0.8861824081024366",
      "vi": "0.912055207014517"
    },
    "level": "",
    "test": "    static void Main()\n    {\n\n        Debug.Assert(AreDNAsRelated(\"ATCGCCGTAAGTAACGGTTTTAAATAGGCC\", \"ATCGCCGGAAGTAACGGTCTTAAATAGGCC\", 0.85) == true);\n        Debug.Assert(AreDNAsRelated(\"GGCATGAC\", \"TGACATGC\", 0.50) == false);\n        Debug.Assert(AreDNAsRelated(\"AAAA\", \"AAAA\", 1.00) == true);\n        Debug.Assert(AreDNAsRelated(\"CCCC\", \"GGTT\", 0.25) == false);\n\n    }\n}",
    "entry_point": "AreDNAsRelated",
    "signature": "static bool AreDNAsRelated(string dnaSequence1, string dnaSequence2, double similarityThreshold)",
    "docstring": {
      "es": "Determina si dos secuencias de ADN están relacionadas en función del umbral de similitud.\n   La función compara dos secuencias de ADN de la misma longitud, par de bases por par de bases.\n   Si la proporción de pares de bases idénticos es mayor o igual al umbral dado,\n   las secuencias se consideran relacionadas.\n   \n   Ejemplo:\n   >>> AreDNAsRelated(\"ATCG\", \"ATCC\", 0.75)\n   true",
      "arb": "يحدد ما إذا كانت سلسلتان من الحمض النووي مرتبطتين بناءً على عتبة التشابه. \n   تقارن الدالة سلسلتين من الحمض النووي لهما نفس الطول، زوج قاعدي بزوج قاعدي. \n   إذا كانت نسبة الأزواج القاعدية المتطابقة أكبر من أو تساوي العتبة المعطاة، \n   تعتبر السلاسل مرتبطة.\n   \n   مثال:\n   >>> AreDNAsRelated(\"ATCG\", \"ATCC\", 0.75)\n   true",
      "sw": "Inabainisha ikiwa mlolongo miwili ya DNA yanahusiana kulingana na kizingiti cha mfanano.\n   Kazi hii inalinganisha mlolongo miwili ya DNA yenye urefu sawa, jozi ya besi kwa jozi ya besi.\n   Ikiwa uwiano wa jozi za besi zinazofanana ni kubwa au sawa na kizingiti kilichopewa,\n   milolongo hiyo inachukuliwa kuwa inahusiana.\n   \n   Mfano:\n   >>> AreDNAsRelated(\"ATCG\", \"ATCC\", 0.75)\n   true",
      "tr": "İki DNA dizisinin benzerlik eşiğine göre ilişkili olup olmadığını belirler.\n   Fonksiyon, aynı uzunluktaki iki DNA dizisini baz çift baz çift karşılaştırır.\n   Eğer aynı baz çiftlerinin oranı verilen eşikten büyük veya eşitse,\n   diziler ilişkili kabul edilir.\n   \n   Örnek:\n   >>> AreDNAsRelated(\"ATCG\", \"ATCC\", 0.75)\n   true",
      "vi": "Xác định xem hai chuỗi DNA có liên quan dựa trên ngưỡng tương đồng.\n   Hàm so sánh hai chuỗi DNA có cùng độ dài, từng cặp base một.\n   Nếu tỷ lệ các cặp base giống nhau lớn hơn hoặc bằng ngưỡng đã cho,\n   thì các chuỗi được coi là có liên quan.\n   \n   Ví dụ:\n   >>> AreDNAsRelated(\"ATCG\", \"ATCC\", 0.75)\n   true"
    },
    "docstring_bertscore": {
      "es": "1",
      "arb": "0.9896193776567357",
      "sw": "0.9730442682505174",
      "tr": "0.9716053897703006",
      "vi": "0.9778000754636357"
    }
  },
  {
    "task_id": "C#/27",
    "prompt": {
      "es": "using System;\nusing System.Text;\nusing System.Collections.Generic;\nusing System.Diagnostics;\n\nclass Program\n{\n\n\n/* Esta función toma una cadena como entrada y devuelve una cadena 'Amigo Cercano' basada en manipulaciones específicas de valores ASCII.\n   La cadena Amigo Cercano se genera sumando los valores ASCII de cada par de caracteres adyacentes en la cadena de entrada,\n   creando un nuevo carácter a partir de la suma. Para el último carácter de la cadena Amigo Cercano, suma el valor ASCII del\n   último y primer carácter de la cadena de entrada. La longitud de la cadena de entrada debe estar entre 2 y 100 caracteres, y\n   el valor ASCII de cada carácter no debe exceder 63.\n\n   Ejemplo:\n   >>> GenerateCloseFriendString(\"1234\")\n   \"cege\"\n\n*/\n    static string GenerateCloseFriendString(string inputString)",
      "arb": "using System;\nusing System.Text;\nusing System.Collections.Generic;\nusing System.Diagnostics;\n\nclass Program\n{\n\n\n/* تأخذ هذه الدالة سلسلة نصية كمدخل وتعيد سلسلة \"الصديق المقرب\" بناءً على تلاعبات محددة بقيم ASCII.\n   يتم إنشاء سلسلة الصديق المقرب عن طريق جمع قيم ASCII لكل زوج من الأحرف المتجاورة في السلسلة المدخلة،\n   وإنشاء حرف جديد من المجموع. بالنسبة للحرف الأخير في سلسلة الصديق المقرب، يتم جمع قيمة ASCII للحرف الأخير\n   والأول من السلسلة المدخلة. يجب أن يكون طول السلسلة المدخلة بين 2 و100 حرف، ويجب ألا تتجاوز قيمة ASCII\n   لكل حرف 63.\n\n   مثال:\n   >>> GenerateCloseFriendString(\"1234\")\n   \"cege\"\n\n*/\n    static string GenerateCloseFriendString(string inputString)",
      "sw": "using System;\nusing System.Text;\nusing System.Collections.Generic;\nusing System.Diagnostics;\n\nclass Program\n{\n\n\n/* Kazi ya hii kazi ni kuchukua kamba kama ingizo na kurudisha kamba ya 'Rafiki wa Karibu' kulingana na mabadiliko maalum ya thamani za ASCII.\n   Kamba ya Rafiki wa Karibu inatengenezwa kwa kuongeza thamani za ASCII za kila jozi ya herufi zinazofuatana katika kamba ya ingizo,\n   na kuunda herufi mpya kutoka kwa jumla hiyo. Kwa herufi ya mwisho ya kamba ya Rafiki wa Karibu, ongeza thamani ya ASCII ya \n   herufi ya mwisho na ya kwanza ya kamba ya ingizo. Urefu wa kamba ya ingizo unapaswa kuwa kati ya herufi 2 na 100, na \n   thamani ya ASCII ya kila herufi haipaswi kuzidi 63.\n\n   Mfano:\n   >>> GenerateCloseFriendString(\"1234\")\n   \"cege\"\n\n*/\n    static string GenerateCloseFriendString(string inputString)",
      "tr": "using System;\nusing System.Text;\nusing System.Collections.Generic;\nusing System.Diagnostics;\n\nclass Program\n{\n\n\n/* Bu fonksiyon bir string alır ve belirli ASCII değeri manipülasyonlarına dayalı bir 'Yakın Arkadaş' stringi döndürür.\n   Yakın Arkadaş stringi, giriş stringindeki bitişik karakter çiftlerinin ASCII değerlerinin toplamı ile yeni bir karakter \n   oluşturarak üretilir. Yakın Arkadaş stringinin son karakteri için, giriş stringinin son ve ilk karakterlerinin ASCII \n   değerlerinin toplamını alın. Giriş stringinin uzunluğu 2 ile 100 karakter arasında olmalı ve her karakterin ASCII \n   değeri 63'ü geçmemelidir.\n\n   Örnek:\n   >>> GenerateCloseFriendString(\"1234\")\n   \"cege\"\n\n*/\n    static string GenerateCloseFriendString(string inputString)",
      "vi": "using System;\nusing System.Text;\nusing System.Collections.Generic;\nusing System.Diagnostics;\n\nclass Program\n{\n\n\n/* Hàm này nhận một chuỗi làm đầu vào và trả về một chuỗi 'Bạn Thân' dựa trên các thao tác giá trị ASCII cụ thể.\n   Chuỗi Bạn Thân được tạo ra bằng cách cộng các giá trị ASCII của từng cặp ký tự liền kề trong chuỗi đầu vào,\n   tạo ra một ký tự mới từ tổng đó. Đối với ký tự cuối cùng của chuỗi Bạn Thân, cộng giá trị ASCII của \n   ký tự cuối và ký tự đầu tiên của chuỗi đầu vào. Độ dài chuỗi đầu vào nên nằm trong khoảng từ 2 đến 100 ký tự, và \n   giá trị ASCII của mỗi ký tự không được vượt quá 63.\n\n   Ví dụ:\n   >>> GenerateCloseFriendString(\"1234\")\n   \"cege\"\n\n*/\n    static string GenerateCloseFriendString(string inputString)"
    },
    "prompt_bertscore": {
      "es": "0.9717231775862544",
      "arb": "0.9681527964871522",
      "sw": "0.9437985268380835",
      "tr": "0.961473254033711",
      "vi": "0.9627266117380412"
    },
    "canonical_solution": "    {\n        if (inputString.Length < 2 || inputString.Length > 100)\n        {\n            throw new ArgumentException(\"Input string length should be between 2 and 100 characters.\");\n        }\n\n        StringBuilder closeFriendString = new StringBuilder();\n\n        for (int i = 0; i < inputString.Length; i++)\n        {\n            int asciiValue = (int)inputString[i];\n            if (asciiValue > 63)\n            {\n                throw new ArgumentException(\"Each character's ASCII value should not exceed 63.\");\n            }\n\n            int nextAsciiValue = (i == inputString.Length - 1) ? (int)inputString[0] : (int)inputString[i + 1];\n            int sum = asciiValue + nextAsciiValue;\n            char closeFriendChar = (char)(sum % 128); // Modulo 128 to ensure the ASCII value is within the valid range\n            closeFriendString.Append(closeFriendChar);\n        }\n\n        return closeFriendString.ToString();\n    }",
    "instruction": {
      "es": "static string GenerateCloseFriendString(string inputString)\n    {\n        if (inputString.Length < 2 || inputString.Length > 100)\n        {\n            throw new ArgumentException(\"Input string length should be between 2 and 100 characters.\");\n        }\n\n        StringBuilder closeFriendString = new StringBuilder();\n\n        for (int i = 0; i < inputString.Length; i++)\n        {\n            int asciiValue = (int)inputString[i];\n            if (asciiValue > 63)\n            {\n                throw new ArgumentException(\"Each character's ASCII value should not exceed 63.\");\n            }\n\n            int nextAsciiValue = (i == inputString.Length - 1) ? (int)inputString[0] : (int)inputString[i + 1];\n            int sum = asciiValue + nextAsciiValue;\n            char closeFriendChar = (char)(sum % 128); // Modulo 128 to ensure the ASCII value is within the valid range\n            closeFriendString.Append(closeFriendChar);\n        }\n\n        return closeFriendString.ToString();\n    }\n\nProporcione una descripción concisa en lenguaje natural (docstring) del código C# en español utilizando un máximo de 500 caracteres.",
      "arb": "static string GenerateCloseFriendString(string inputString)\n    {\n        if (inputString.Length < 2 || inputString.Length > 100)\n        {\n            throw new ArgumentException(\"Input string length should be between 2 and 100 characters.\");\n        }\n\n        StringBuilder closeFriendString = new StringBuilder();\n\n        for (int i = 0; i < inputString.Length; i++)\n        {\n            int asciiValue = (int)inputString[i];\n            if (asciiValue > 63)\n            {\n                throw new ArgumentException(\"Each character's ASCII value should not exceed 63.\");\n            }\n\n            int nextAsciiValue = (i == inputString.Length - 1) ? (int)inputString[0] : (int)inputString[i + 1];\n            int sum = asciiValue + nextAsciiValue;\n            char closeFriendChar = (char)(sum % 128); // Modulo 128 to ensure the ASCII value is within the valid range\n            closeFriendString.Append(closeFriendChar);\n        }\n\n        return closeFriendString.ToString();\n    }\n\nيرجى تقديم وصف موجز بلغة طبيعية (docstring) لكود C# باللغة العربية الفصحى باستخدام ما لا يزيد عن 500 حرف.",
      "sw": "static string GenerateCloseFriendString(string inputString)\n    {\n        if (inputString.Length < 2 || inputString.Length > 100)\n        {\n            throw new ArgumentException(\"Input string length should be between 2 and 100 characters.\");\n        }\n\n        StringBuilder closeFriendString = new StringBuilder();\n\n        for (int i = 0; i < inputString.Length; i++)\n        {\n            int asciiValue = (int)inputString[i];\n            if (asciiValue > 63)\n            {\n                throw new ArgumentException(\"Each character's ASCII value should not exceed 63.\");\n            }\n\n            int nextAsciiValue = (i == inputString.Length - 1) ? (int)inputString[0] : (int)inputString[i + 1];\n            int sum = asciiValue + nextAsciiValue;\n            char closeFriendChar = (char)(sum % 128); // Modulo 128 to ensure the ASCII value is within the valid range\n            closeFriendString.Append(closeFriendChar);\n        }\n\n        return closeFriendString.ToString();\n    }\n\nToa maelezo mafupi ya lugha ya asili (docstring) ya msimbo wa C# kwa Kiswahili kwa kutumia herufi zisizozidi 500.",
      "tr": "static string GenerateCloseFriendString(string inputString)\n    {\n        if (inputString.Length < 2 || inputString.Length > 100)\n        {\n            throw new ArgumentException(\"Input string length should be between 2 and 100 characters.\");\n        }\n\n        StringBuilder closeFriendString = new StringBuilder();\n\n        for (int i = 0; i < inputString.Length; i++)\n        {\n            int asciiValue = (int)inputString[i];\n            if (asciiValue > 63)\n            {\n                throw new ArgumentException(\"Each character's ASCII value should not exceed 63.\");\n            }\n\n            int nextAsciiValue = (i == inputString.Length - 1) ? (int)inputString[0] : (int)inputString[i + 1];\n            int sum = asciiValue + nextAsciiValue;\n            char closeFriendChar = (char)(sum % 128); // Modulo 128 to ensure the ASCII value is within the valid range\n            closeFriendString.Append(closeFriendChar);\n        }\n\n        return closeFriendString.ToString();\n    }\n\nAşağıdaki C# kodunun işlevini açıklayan en fazla 500 karakterlik bir doğal dil açıklaması (docstring) sağlayın.",
      "vi": "static string GenerateCloseFriendString(string inputString)\n    {\n        if (inputString.Length < 2 || inputString.Length > 100)\n        {\n            throw new ArgumentException(\"Input string length should be between 2 and 100 characters.\");\n        }\n\n        StringBuilder closeFriendString = new StringBuilder();\n\n        for (int i = 0; i < inputString.Length; i++)\n        {\n            int asciiValue = (int)inputString[i];\n            if (asciiValue > 63)\n            {\n                throw new ArgumentException(\"Each character's ASCII value should not exceed 63.\");\n            }\n\n            int nextAsciiValue = (i == inputString.Length - 1) ? (int)inputString[0] : (int)inputString[i + 1];\n            int sum = asciiValue + nextAsciiValue;\n            char closeFriendChar = (char)(sum % 128); // Modulo 128 to ensure the ASCII value is within the valid range\n            closeFriendString.Append(closeFriendChar);\n        }\n\n        return closeFriendString.ToString();\n    }\n\nCung cấp mô tả ngắn gọn bằng ngôn ngữ tự nhiên (docstring) cho mã C# bằng tiếng Việt với tối đa 500 ký tự."
    },
    "instruction_bertscore": {
      "es": "0.9702167647764858",
      "arb": "0.8984436628933392",
      "sw": "0.918288824262535",
      "tr": "0.8385236303680687",
      "vi": "0.9066002208601559"
    },
    "level": "",
    "test": "    static void Main()\n    {\n        Debug.Assert(GenerateCloseFriendString(\"1234\") == \"cege\");\n        Debug.Assert(GenerateCloseFriendString(\"4312\") == \"gdcf\");\n\n    }\n}",
    "entry_point": "GenerateCloseFriendString",
    "signature": "static string GenerateCloseFriendString(string inputString)",
    "docstring": {
      "es": "Esta función toma una cadena como entrada y devuelve una cadena 'Amigo Cercano' basada en manipulaciones específicas de valores ASCII.\n   La cadena Amigo Cercano se genera sumando los valores ASCII de cada par de caracteres adyacentes en la cadena de entrada,\n   creando un nuevo carácter a partir de la suma. Para el último carácter de la cadena Amigo Cercano, suma el valor ASCII del\n   último y primer carácter de la cadena de entrada. La longitud de la cadena de entrada debe estar entre 2 y 100 caracteres, y\n   el valor ASCII de cada carácter no debe exceder 63.\n\n   Ejemplo:\n   >>> GenerateCloseFriendString(\"1234\")\n   \"cege\"",
      "arb": "هذه الدالة تأخذ سلسلة نصية كمدخل وتعيد سلسلة \"صديق مقرب\" بناءً على تلاعبات محددة في قيم ASCII.\n   يتم إنشاء سلسلة الصديق المقرب عن طريق جمع قيم ASCII لكل زوج من الأحرف المتجاورة في السلسلة المدخلة،\n   وإنشاء حرف جديد من المجموع. بالنسبة للحرف الأخير من سلسلة الصديق المقرب، يتم جمع قيمة ASCII للحرف الأخير والأول من السلسلة المدخلة. يجب أن يكون طول السلسلة المدخلة بين 2 و100 حرف، وألا تتجاوز قيمة ASCII لكل حرف 63.\n\n   مثال:\n   >>> GenerateCloseFriendString(\"1234\")\n   \"cege\"",
      "sw": "Kazi ya hii kazi ni kuchukua kamba kama ingizo na kurudisha kamba ya 'Rafiki wa Karibu' kulingana na mabadiliko maalum ya thamani za ASCII.\n   Kamba ya Rafiki wa Karibu inazalishwa kwa kujumlisha thamani za ASCII za kila jozi ya herufi zinazofuatana katika kamba ya ingizo,\n   ikitengeneza herufi mpya kutoka kwenye jumla hiyo. Kwa herufi ya mwisho ya kamba ya Rafiki wa Karibu, jumlisha thamani ya ASCII ya \n   herufi ya mwisho na ya kwanza ya kamba ya ingizo. Urefu wa kamba ya ingizo unapaswa kuwa kati ya herufi 2 na 100, na \n   thamani ya ASCII ya kila herufi haipaswi kuzidi 63.\n\n   Mfano:\n   >>> GenerateCloseFriendString(\"1234\")\n   \"cege\"",
      "tr": "Bu fonksiyon bir dizeyi girdi olarak alır ve belirli ASCII değeri manipülasyonlarına dayanarak bir 'Yakın Arkadaş' dizesi döndürür.\n   Yakın Arkadaş dizesi, giriş dizisindeki bitişik karakter çiftlerinin ASCII değerlerinin toplanmasıyla oluşturulur,\n   toplamdan yeni bir karakter oluşturulur. Yakın Arkadaş dizesinin son karakteri için, giriş dizisinin son ve ilk karakterlerinin \n   ASCII değerlerini toplayın. Giriş dizesinin uzunluğu 2 ile 100 karakter arasında olmalıdır ve \n   her karakterin ASCII değeri 63'ü geçmemelidir.\n\n   Örnek:\n   >>> GenerateCloseFriendString(\"1234\")\n   \"cege\"",
      "vi": "Hàm này nhận một chuỗi đầu vào và trả về một chuỗi 'Close Friend' dựa trên các thao tác giá trị ASCII cụ thể. Chuỗi Close Friend được tạo ra bằng cách cộng các giá trị ASCII của từng cặp ký tự liền kề trong chuỗi đầu vào, tạo ra một ký tự mới từ tổng đó. Đối với ký tự cuối cùng của chuỗi Close Friend, cộng giá trị ASCII của ký tự cuối cùng và ký tự đầu tiên của chuỗi đầu vào. Độ dài chuỗi đầu vào nên nằm trong khoảng từ 2 đến 100 ký tự, và giá trị ASCII của mỗi ký tự không được vượt quá 63.\n\n   Ví dụ:\n   >>> GenerateCloseFriendString(\"1234\")\n   \"cege\""
    },
    "docstring_bertscore": {
      "es": "0.9638631747783228",
      "arb": "0.9609500616100651",
      "sw": "0.976014189707751",
      "tr": "0.9667987331796374",
      "vi": "0.9486770876266815"
    }
  },
  {
    "task_id": "C#/28",
    "prompt": {
      "es": "using System;\nusing System.Collections.Generic;\nusing System.Diagnostics;\n\nclass Program\n{\n\n/*\n    Descifra un texto cifrado que fue encriptado usando un cifrado César con un desplazamiento de 5 letras.\n    La función solo desplaza caracteres alfabéticos en mayúsculas y deja otros caracteres sin cambios.\n    Ejemplo:\n    >>> DecryptCaesarCipher(\"NS BFW, JAJSYX TK NRUTWYFSHJ FWJ YMJ WJXZQY TK YWNANFQ HFZXJX\")\n    \"IN WAR, EVENTS OF IMPORTANCE ARE THE RESULT OF TRIVIAL CAUSES\"\n\n*/\n    static string DecryptCaesarCipher(string cipherText)",
      "arb": "using System;\nusing System.Collections.Generic;\nusing System.Diagnostics;\n\nclass Program\n{\n\n/*\n    يفك تشفير نص مشفر تم تشفيره باستخدام شفرة قيصر مع إزاحة 5 أحرف.\n    تقوم الدالة فقط بإزاحة الأحرف الأبجدية الكبيرة وتترك الأحرف الأخرى دون تغيير.\n    مثال:\n    >>> DecryptCaesarCipher(\"NS BFW, JAJSYX TK NRUTWYFSHJ FWJ YMJ WJXZQY TK YWNANFQ HFZXJX\")\n    \"IN WAR, EVENTS OF IMPORTANCE ARE THE RESULT OF TRIVIAL CAUSES\"\n\n*/\n    static string DecryptCaesarCipher(string cipherText)",
      "sw": "using System;\nusing System.Collections.Generic;\nusing System.Diagnostics;\n\nclass Program\n{\n\n/*\n    Hufungua maandishi ya siri ambayo yalifichwa kwa kutumia kanuni ya Caesar yenye mabadiliko ya herufi 5.\n    Kazi hii inabadilisha tu herufi kubwa za alfabeti na inaacha herufi nyingine bila kubadilishwa.\n    Mfano:\n    >>> DecryptCaesarCipher(\"NS BFW, JAJSYX TK NRUTWYFSHJ FWJ YMJ WJXZQY TK YWNANFQ HFZXJX\")\n    \"IN WAR, EVENTS OF IMPORTANCE ARE THE RESULT OF TRIVIAL CAUSES\"\n\n*/\n    static string DecryptCaesarCipher(string cipherText)",
      "tr": "using System;\nusing System.Collections.Generic;\nusing System.Diagnostics;\n\nclass Program\n{\n\n/*\n    5 harflik bir kaydırma ile şifrelenmiş bir metni, Sezar şifresi kullanarak çözer.\n    Fonksiyon sadece büyük harfli alfabetik karakterleri kaydırır ve diğer karakterleri değiştirmeden bırakır.\n    Örnek:\n    >>> DecryptCaesarCipher(\"NS BFW, JAJSYX TK NRUTWYFSHJ FWJ YMJ WJXZQY TK YWNANFQ HFZXJX\")\n    \"IN WAR, EVENTS OF IMPORTANCE ARE THE RESULT OF TRIVIAL CAUSES\"\n\n*/\n    static string DecryptCaesarCipher(string cipherText)",
      "vi": "using System;\nusing System.Collections.Generic;\nusing System.Diagnostics;\n\nclass Program\n{\n\n/*\n    Giải mã một văn bản mã hóa đã được mã hóa bằng mã Caesar với dịch chuyển 5 chữ cái.\n    Hàm chỉ dịch chuyển các ký tự chữ hoa và giữ nguyên các ký tự khác.\n    Ví dụ:\n    >>> DecryptCaesarCipher(\"NS BFW, JAJSYX TK NRUTWYFSHJ FWJ YMJ WJXZQY TK YWNANFQ HFZXJX\")\n    \"IN WAR, EVENTS OF IMPORTANCE ARE THE RESULT OF TRIVIAL CAUSES\"\n\n*/\n    static string DecryptCaesarCipher(string cipherText)"
    },
    "prompt_bertscore": {
      "es": "0.9764108545786777",
      "arb": "0.9833907261682436",
      "sw": "0.9486764917355384",
      "tr": "0.9615111924364886",
      "vi": "0.9624225086246767"
    },
    "canonical_solution": "    {\n        char[] decrypted = new char[cipherText.Length];\n        for (int i = 0; i < cipherText.Length; i++)\n        {\n            char ch = cipherText[i];\n            if (char.IsUpper(ch))\n            {\n                decrypted[i] = (char)((ch - 'A' - 5 + 26) % 26 + 'A');\n            }\n            else\n            {\n                decrypted[i] = ch;\n            }\n        }\n        return new string(decrypted);\n    }",
    "instruction": {
      "es": "static string DecryptCaesarCipher(string cipherText)\n    {\n        char[] decrypted = new char[cipherText.Length];\n        for (int i = 0; i < cipherText.Length; i++)\n        {\n            char ch = cipherText[i];\n            if (char.IsUpper(ch))\n            {\n                decrypted[i] = (char)((ch - 'A' - 5 + 26) % 26 + 'A');\n            }\n            else\n            {\n                decrypted[i] = ch;\n            }\n        }\n        return new string(decrypted);\n    }\n\nProporcione una descripción concisa en lenguaje natural (docstring) del código C# en español utilizando como máximo 500 caracteres.",
      "arb": "static string DecryptCaesarCipher(string cipherText)\n    {\n        char[] decrypted = new char[cipherText.Length];\n        for (int i = 0; i < cipherText.Length; i++)\n        {\n            char ch = cipherText[i];\n            if (char.IsUpper(ch))\n            {\n                decrypted[i] = (char)((ch - 'A' - 5 + 26) % 26 + 'A');\n            }\n            else\n            {\n                decrypted[i] = ch;\n            }\n        }\n        return new string(decrypted);\n    }\n\nيرجى تقديم وصف موجز بلغة طبيعية (docstring) للشيفرة البرمجية المكتوبة بلغة C# باللغة العربية الفصحى، بحيث لا يتجاوز 500 حرف.",
      "sw": "static string DecryptCaesarCipher(string cipherText)\n    {\n        char[] decrypted = new char[cipherText.Length];\n        for (int i = 0; i < cipherText.Length; i++)\n        {\n            char ch = cipherText[i];\n            if (char.IsUpper(ch))\n            {\n                decrypted[i] = (char)((ch - 'A' - 5 + 26) % 26 + 'A');\n            }\n            else\n            {\n                decrypted[i] = ch;\n            }\n        }\n        return new string(decrypted);\n    }\n\nToa maelezo mafupi ya lugha ya asili (docstring) ya msimbo wa C# kwa Kiswahili kwa kutumia herufi zisizozidi 500.",
      "tr": "static string DecryptCaesarCipher(string cipherText)\n    {\n        char[] decrypted = new char[cipherText.Length];\n        for (int i = 0; i < cipherText.Length; i++)\n        {\n            char ch = cipherText[i];\n            if (char.IsUpper(ch))\n            {\n                decrypted[i] = (char)((ch - 'A' - 5 + 26) % 26 + 'A');\n            }\n            else\n            {\n                decrypted[i] = ch;\n            }\n        }\n        return new string(decrypted);\n    }\n\nC# kodunun işlevini açıklayan en fazla 500 karakterlik kısa bir doğal dil açıklaması (docstring) sağlayın.",
      "vi": "static string DecryptCaesarCipher(string cipherText)\n    {\n        char[] decrypted = new char[cipherText.Length];\n        for (int i = 0; i < cipherText.Length; i++)\n        {\n            char ch = cipherText[i];\n            if (char.IsUpper(ch))\n            {\n                decrypted[i] = (char)((ch - 'A' - 5 + 26) % 26 + 'A');\n            }\n            else\n            {\n                decrypted[i] = ch;\n            }\n        }\n        return new string(decrypted);\n    }\n\nCung cấp mô tả ngắn gọn bằng ngôn ngữ tự nhiên (docstring) cho mã C# bằng tiếng Việt với tối đa 500 ký tự."
    },
    "instruction_bertscore": {
      "es": "0.9702167647764858",
      "arb": "0.8829437397396628",
      "sw": "0.918288824262535",
      "tr": "0.8705853546924341",
      "vi": "0.9258024156859417"
    },
    "level": "",
    "test": "static void Main()\n    {\n        Debug.Assert(DecryptCaesarCipher(\"NS BFW, JAJSYX TK NRUTWYFSHJ FWJ YMJ WJXZQY TK YWNANFQ HFZXJX\") == \"IN WAR, EVENTS OF IMPORTANCE ARE THE RESULT OF TRIVIAL CAUSES\");\n        Debug.Assert(DecryptCaesarCipher(\"F XYWNFYNTS YT XJHWJY\") == \"A STRIATION TO SECRET\");\n        Debug.Assert(DecryptCaesarCipher(\"YMJ VZNHP TS X HNUMJW\") == \"THE QUICK ON S CIPHER\");\n        Debug.Assert(DecryptCaesarCipher(\"JXU UQFSI QDT TZW YMZXW\") == \"ESP PLAND LYO OUR THUSR\");\n    }\n}",
    "entry_point": "DecryptCaesarCipher",
    "signature": "static string DecryptCaesarCipher(string cipherText)",
    "docstring": {
      "es": "Desencripta un texto cifrado que fue encriptado usando un cifrado César con un desplazamiento de 5 letras.\n    La función solo desplaza caracteres alfabéticos en mayúsculas y deja otros caracteres sin cambios.\n    Ejemplo:\n    >>> DecryptCaesarCipher(\"NS BFW, JAJSYX TK NRUTWYFSHJ FWJ YMJ WJXZQY TK YWNANFQ HFZXJX\")\n    \"IN WAR, EVENTS OF IMPORTANCE ARE THE RESULT OF TRIVIAL CAUSES\"",
      "arb": "يفك تشفير نص مشفر تم تشفيره باستخدام شيفرة قيصر مع إزاحة 5 حروف. \n    تقوم الدالة فقط بإزاحة الأحرف الأبجدية الكبيرة وتترك الأحرف الأخرى دون تغيير.\n    مثال:\n    >>> DecryptCaesarCipher(\"NS BFW, JAJSYX TK NRUTWYFSHJ FWJ YMJ WJXZQY TK YWNANFQ HFZXJX\")\n    \"IN WAR, EVENTS OF IMPORTANCE ARE THE RESULT OF TRIVIAL CAUSES\"",
      "sw": "Inafungua maandishi ya siri ambayo yalifichwa kwa kutumia msimbo wa Caesar na mabadiliko ya herufi 5. \n    Kazi hii inahamisha tu herufi kubwa za alfabeti na inaacha herufi nyingine bila kubadilika.\n    Mfano:\n    >>> DecryptCaesarCipher(\"NS BFW, JAJSYX TK NRUTWYFSHJ FWJ YMJ WJXZQY TK YWNANFQ HFZXJX\")\n    \"IN WAR, EVENTS OF IMPORTANCE ARE THE RESULT OF TRIVIAL CAUSES\"",
      "tr": "Şifreli bir metni, 5 harf kaydırmalı bir Sezar şifresi kullanılarak şifrelenmiş olan metni çözer.\n    Fonksiyon yalnızca büyük harfli alfabe karakterlerini kaydırır ve diğer karakterleri değiştirmeden bırakır.\n    Örnek:\n    >>> DecryptCaesarCipher(\"NS BFW, JAJSYX TK NRUTWYFSHJ FWJ YMJ WJXZQY TK YWNANFQ HFZXJX\")\n    \"IN WAR, EVENTS OF IMPORTANCE ARE THE RESULT OF TRIVIAL CAUSES\"",
      "vi": "Giải mã một văn bản mã hóa đã được mã hóa bằng mã Caesar với một dịch chuyển 5 chữ cái. \n    Hàm chỉ dịch chuyển các ký tự chữ cái viết hoa và để nguyên các ký tự khác. \n    Ví dụ:\n    >>> DecryptCaesarCipher(\"NS BFW, JAJSYX TK NRUTWYFSHJ FWJ YMJ WJXZQY TK YWNANFQ HFZXJX\")\n    \"IN WAR, EVENTS OF IMPORTANCE ARE THE RESULT OF TRIVIAL CAUSES\""
    },
    "docstring_bertscore": {
      "es": "0.9906727145673637",
      "arb": "0.977631041009375",
      "sw": "0.958546832629924",
      "tr": "0.9884003830083246",
      "vi": "0.9570219471947192"
    }
  },
  {
    "task_id": "C#/29",
    "prompt": {
      "es": "using System;\nusing System.Collections.Generic;\nusing System.Diagnostics;\n\nclass Program\n{\n    /* Determina cuál de las dos cadenas proporcionadas es una subcadena de la otra. \n    Si ninguna cadena es una subcadena de la otra, devuelve \"No substring\".\n    >>> CheckSubstring(\"hello\", \"world\")\n    \"No substring\"\n    >>> CheckSubstring(\"code\", \"decode\")\n    \"code is substring of decode\"\n    >>> CheckSubstring(\"book\", \"notebook\")\n    \"book is substring of notebook\"\n    */\n\n    static string CheckSubstring(string str1, string str2)",
      "arb": "using System;\nusing System.Collections.Generic;\nusing System.Diagnostics;\n\nclass Program\n{\n    /* يحدد أي من السلسلتين المقدمتين هو جزء من الأخرى.\n    إذا لم تكن أي من السلسلتين جزءًا من الأخرى، فإنه يعيد \"لا يوجد جزء\".\n    >>> CheckSubstring(\"hello\", \"world\")\n    \"No substring\"\n    >>> CheckSubstring(\"code\", \"decode\")\n    \"code is substring of decode\"\n    >>> CheckSubstring(\"book\", \"notebook\")\n    \"book is substring of notebook\"\n    */\n\n    static string CheckSubstring(string str1, string str2)",
      "sw": "using System;\nusing System.Collections.Generic;\nusing System.Diagnostics;\n\nclass Program\n{\n    /* Huamua ni ipi kati ya mistari miwili iliyotolewa ni sehemu ndogo ya nyingine.\n    Ikiwa hakuna mstari wowote ni sehemu ndogo ya mwingine, inarudisha \"Hakuna sehemu ndogo\".\n    >>> CheckSubstring(\"hello\", \"world\")\n    \"Hakuna sehemu ndogo\"\n    >>> CheckSubstring(\"code\", \"decode\")\n    \"code ni sehemu ndogo ya decode\"\n    >>> CheckSubstring(\"book\", \"notebook\")\n    \"book ni sehemu ndogo ya notebook\"\n    */\n\n    static string CheckSubstring(string str1, string str2)",
      "tr": "using System;\nusing System.Collections.Generic;\nusing System.Diagnostics;\n\nclass Program\n{\n    /* Verilen iki dizeden hangisinin diğerinin alt dizesi olduğunu belirler. \n    Eğer hiçbir dize diğerinin alt dizesi değilse, \"Alt dize yok\" döner.\n    >>> CheckSubstring(\"hello\", \"world\")\n    \"No substring\"\n    >>> CheckSubstring(\"code\", \"decode\")\n    \"code is substring of decode\"\n    >>> CheckSubstring(\"book\", \"notebook\")\n    \"book is substring of notebook\"\n    */\n\n    static string CheckSubstring(string str1, string str2)",
      "vi": "using System;\nusing System.Collections.Generic;\nusing System.Diagnostics;\n\nclass Program\n{\n    /* Xác định chuỗi nào trong hai chuỗi được cung cấp là chuỗi con của chuỗi kia.\n    Nếu không có chuỗi nào là chuỗi con của chuỗi kia, nó trả về \"No substring\".\n    >>> CheckSubstring(\"hello\", \"world\")\n    \"No substring\"\n    >>> CheckSubstring(\"code\", \"decode\")\n    \"code is substring of decode\"\n    >>> CheckSubstring(\"book\", \"notebook\")\n    \"book is substring of notebook\"\n    */\n\n    static string CheckSubstring(string str1, string str2)"
    },
    "prompt_bertscore": {
      "es": "1",
      "arb": "1",
      "sw": "0.9907315091601501",
      "tr": "0.9960109060576764",
      "vi": "0.9939280678821445"
    },
    "canonical_solution": "    {\n        if (str1.Contains(str2))\n        {\n            return $\"\\\"{str2}\\\" is substring of \\\"{str1}\\\"\";\n        }\n        else if (str2.Contains(str1))\n        {\n            return $\"\\\"{str1}\\\" is substring of \\\"{str2}\\\"\";\n        }\n        else\n        {\n            return \"No substring\";\n        }\n    }",
    "instruction": {
      "es": "static string CheckSubstring(string str1, string str2)\n    {\n        if (str1.Contains(str2))\n        {\n            return $\"\\\"{str2}\\\" is substring of \\\"{str1}\\\"\";\n        }\n        else if (str2.Contains(str1))\n        {\n            return $\"\\\"{str1}\\\" is substring of \\\"{str2}\\\"\";\n        }\n        else\n        {\n            return \"No substring\";\n        }\n    }\n\nProporcione una descripción concisa en lenguaje natural (docstring) del código C# en español utilizando como máximo 500 caracteres.",
      "arb": "static string CheckSubstring(string str1, string str2)\n    {\n        if (str1.Contains(str2))\n        {\n            return $\"\\\"{str2}\\\" is substring of \\\"{str1}\\\"\";\n        }\n        else if (str2.Contains(str1))\n        {\n            return $\"\\\"{str1}\\\" is substring of \\\"{str2}\\\"\";\n        }\n        else\n        {\n            return \"No substring\";\n        }\n    }\n\nيرجى تقديم وصف موجز بلغة طبيعية (docstring) للشيفرة البرمجية المكتوبة بلغة C# باللغة العربية الفصحى، بحيث لا يتجاوز 500 حرف.",
      "sw": "static string CheckSubstring(string str1, string str2)\n    {\n        if (str1.Contains(str2))\n        {\n            return $\"\\\"{str2}\\\" is substring of \\\"{str1}\\\"\";\n        }\n        else if (str2.Contains(str1))\n        {\n            return $\"\\\"{str1}\\\" is substring of \\\"{str2}\\\"\";\n        }\n        else\n        {\n            return \"No substring\";\n        }\n    }\n\nToa maelezo mafupi ya lugha ya asili (docstring) ya msimbo wa C# kwa Kiswahili kwa kutumia herufi zisizozidi 500.",
      "tr": "static string CheckSubstring(string str1, string str2)\n    {\n        if (str1.Contains(str2))\n        {\n            return $\"\\\"{str2}\\\" is substring of \\\"{str1}\\\"\";\n        }\n        else if (str2.Contains(str1))\n        {\n            return $\"\\\"{str1}\\\" is substring of \\\"{str2}\\\"\";\n        }\n        else\n        {\n            return \"No substring\";\n        }\n    }\n\nC# kodunun işlevselliğini açıklayan en fazla 500 karakterlik kısa bir doğal dil açıklaması (docstring) sağlayın.",
      "vi": "static string CheckSubstring(string str1, string str2)\n    {\n        if (str1.Contains(str2))\n        {\n            return $\"\\\"{str2}\\\" is substring of \\\"{str1}\\\"\";\n        }\n        else if (str2.Contains(str1))\n        {\n            return $\"\\\"{str1}\\\" is substring of \\\"{str2}\\\"\";\n        }\n        else\n        {\n            return \"No substring\";\n        }\n    }\n\nCung cấp mô tả ngắn gọn bằng ngôn ngữ tự nhiên (docstring) cho mã C# bằng tiếng Việt, không quá 500 ký tự."
    },
    "instruction_bertscore": {
      "es": "0.9702167647764858",
      "arb": "0.8829437397396628",
      "sw": "0.918288824262535",
      "tr": "0.8705730396088099",
      "vi": "0.9187315713818617"
    },
    "level": "",
    "test": "    static void Main()\n    {\n        Debug.Assert(CheckSubstring(\"apple\", \"pineapple\") == \"\\\"apple\\\" is substring of \\\"pineapple\\\"\");\n        Debug.Assert(CheckSubstring(\"star\", \"astrophysics\") == \"No substring\");\n        Debug.Assert(CheckSubstring(\"sun\", \"sunset\") == \"\\\"sun\\\" is substring of \\\"sunset\\\"\");\n        Debug.Assert(CheckSubstring(\"moon\", \"moonlight\") == \"\\\"moon\\\" is substring of \\\"moonlight\\\"\");\n\n\n    }\n}",
    "entry_point": "CheckSubstring",
    "signature": "static string CheckSubstring(string str1, string str2)",
    "docstring": {
      "es": "Determina cuál de las dos cadenas proporcionadas es una subcadena de la otra. \n    Si ninguna cadena es una subcadena de la otra, devuelve \"No substring\".\n    >>> CheckSubstring(\"hello\", \"world\")\n    \"No substring\"\n    >>> CheckSubstring(\"code\", \"decode\")\n    \"code is substring of decode\"\n    >>> CheckSubstring(\"book\", \"notebook\")\n    \"book is substring of notebook\"",
      "arb": "يحدد أي من السلسلتين المقدمتين هو جزء من السلسلة الأخرى. \n    إذا لم تكن أي من السلسلتين جزءًا من الأخرى، فإنه يعيد \"لا يوجد جزء\".\n    >>> CheckSubstring(\"hello\", \"world\")\n    \"No substring\"\n    >>> CheckSubstring(\"code\", \"decode\")\n    \"code is substring of decode\"\n    >>> CheckSubstring(\"book\", \"notebook\")\n    \"book is substring of notebook\"",
      "sw": "Inabainisha ni ipi kati ya mistari miwili iliyotolewa ni sehemu ndogo ya nyingine. \n    Ikiwa hakuna mstari wowote ni sehemu ndogo ya mwingine, inarejesha \"Hakuna sehemu ndogo\".\n    >>> CheckSubstring(\"hello\", \"world\")\n    \"No substring\"\n    >>> CheckSubstring(\"code\", \"decode\")\n    \"code is substring of decode\"\n    >>> CheckSubstring(\"book\", \"notebook\")\n    \"book is substring of notebook\"",
      "tr": "Belirtilen iki stringden hangisinin diğerinin alt dizisi olduğunu belirler. \n    Eğer hiçbir string diğerinin alt dizisi değilse, \"No substring\" döndürür.\n    >>> CheckSubstring(\"hello\", \"world\")\n    \"No substring\"\n    >>> CheckSubstring(\"code\", \"decode\")\n    \"code is substring of decode\"\n    >>> CheckSubstring(\"book\", \"notebook\")\n    \"book is substring of notebook\"",
      "vi": "Xác định chuỗi nào trong hai chuỗi được cung cấp là chuỗi con của chuỗi kia. \n    Nếu không có chuỗi nào là chuỗi con của chuỗi kia, nó trả về \"Không có chuỗi con\".\n    >>> CheckSubstring(\"hello\", \"world\")\n    \"No substring\"\n    >>> CheckSubstring(\"code\", \"decode\")\n    \"code is substring of decode\"\n    >>> CheckSubstring(\"book\", \"notebook\")\n    \"book is substring of notebook\""
    },
    "docstring_bertscore": {
      "es": "0.9831029107461241",
      "arb": "1",
      "sw": "0.9837007881930392",
      "tr": "0.992405367381131",
      "vi": "0.9844017548077113"
    }
  },
  {
    "task_id": "C#/30",
    "prompt": {
      "es": "using System;\nusing System.Collections.Generic;\nusing System.Diagnostics;\n\nclass Program\n{\n\n/* Elimina un sufijo específico ('er', 'ly' o 'ing') de la palabra dada si termina con uno de estos sufijos. \n    La función asegura que la palabra restante no esté vacía.\n    Ejemplos:\n        >>> RemoveSuffix(\"happily\")\n        \"happi\"\n        >>> RemoveSuffix(\"dancing\")\n        \"danc\"\n        >>> RemoveSuffix(\"flower\")\n        \"flow\"\n*/\nstatic string RemoveSuffix(string word)",
      "arb": "using System;\nusing System.Collections.Generic;\nusing System.Diagnostics;\n\nclass Program\n{\n\n/* يزيل لاحقة معينة ('er', 'ly', أو 'ing') من الكلمة المعطاة إذا انتهت بإحدى هذه اللواحق.\n    تضمن الدالة أن الكلمة المتبقية ليست فارغة.\n    أمثلة:\n        >>> RemoveSuffix(\"happily\")\n        \"happi\"\n        >>> RemoveSuffix(\"dancing\")\n        \"danc\"\n        >>> RemoveSuffix(\"flower\")\n        \"flow\"\n*/\nstatic string RemoveSuffix(string word)",
      "sw": "using System;\nusing System.Collections.Generic;\nusing System.Diagnostics;\n\nclass Program\n{\n\n/* Huondoa kiambishi tamati maalum ('er', 'ly', au 'ing') kutoka kwenye neno lililopewa ikiwa linamalizika na moja ya viambishi hivi. \n    Kazi hii inahakikisha neno linalobaki haliko tupu.\n    Mifano:\n        >>> RemoveSuffix(\"happily\")\n        \"happi\"\n        >>> RemoveSuffix(\"dancing\")\n        \"danc\"\n        >>> RemoveSuffix(\"flower\")\n        \"flow\"\n*/\nstatic string RemoveSuffix(string word)",
      "tr": "using System;\nusing System.Collections.Generic;\nusing System.Diagnostics;\n\nclass Program\n{\n\n/* Verilen kelimenin sonu belirli bir ekle ('er', 'ly' veya 'ing') bitiyorsa bu eki kaldırır.\n    Fonksiyon, geriye kalan kelimenin boş olmadığını garanti eder.\n    Örnekler:\n        >>> RemoveSuffix(\"happily\")\n        \"happi\"\n        >>> RemoveSuffix(\"dancing\")\n        \"danc\"\n        >>> RemoveSuffix(\"flower\")\n        \"flow\"\n*/\nstatic string RemoveSuffix(string word)",
      "vi": "using System;\nusing System.Collections.Generic;\nusing System.Diagnostics;\n\nclass Program\n{\n\n/* Loại bỏ một hậu tố cụ thể ('er', 'ly', hoặc 'ing') từ từ đã cho nếu nó kết thúc bằng một trong những hậu tố này.\n    Hàm đảm bảo từ còn lại không bị rỗng.\n    Ví dụ:\n        >>> RemoveSuffix(\"happily\")\n        \"happi\"\n        >>> RemoveSuffix(\"dancing\")\n        \"danc\"\n        >>> RemoveSuffix(\"flower\")\n        \"flow\"\n*/\nstatic string RemoveSuffix(string word)"
    },
    "prompt_bertscore": {
      "es": "0.9973947639223464",
      "arb": "0.9973947639223464",
      "sw": "0.997972976961539",
      "tr": "0.9625047416024252",
      "vi": "0.9943024861503953"
    },
    "canonical_solution": "{\n    if (word.EndsWith(\"er\") && word.Length > 2)\n    {\n        return word.Substring(0, word.Length - 2);\n    }\n    else if (word.EndsWith(\"ly\") && word.Length > 2)\n    {\n        return word.Substring(0, word.Length - 2);\n    }\n    else if (word.EndsWith(\"ing\") && word.Length > 3)\n    {\n        return word.Substring(0, word.Length - 3);\n    }\n    return word;\n}",
    "instruction": {
      "es": "static string RemoveSuffix(string word)\n{\n    if (word.EndsWith(\"er\") && word.Length > 2)\n    {\n        return word.Substring(0, word.Length - 2);\n    }\n    else if (word.EndsWith(\"ly\") && word.Length > 2)\n    {\n        return word.Substring(0, word.Length - 2);\n    }\n    else if (word.EndsWith(\"ing\") && word.Length > 3)\n    {\n        return word.Substring(0, word.Length - 3);\n    }\n    return word;\n}\n\nProporcione una descripción concisa en lenguaje natural (docstring) del código C# en español utilizando como máximo 500 caracteres.",
      "arb": "static string RemoveSuffix(string word)\n{\n    if (word.EndsWith(\"er\") && word.Length > 2)\n    {\n        return word.Substring(0, word.Length - 2);\n    }\n    else if (word.EndsWith(\"ly\") && word.Length > 2)\n    {\n        return word.Substring(0, word.Length - 2);\n    }\n    else if (word.EndsWith(\"ing\") && word.Length > 3)\n    {\n        return word.Substring(0, word.Length - 3);\n    }\n    return word;\n}\n\nيرجى تقديم وصف موجز بلغة طبيعية (docstring) للكود المكتوب بلغة C# باللغة العربية الفصحى، بحيث لا يتجاوز 500 حرف.",
      "sw": "static string RemoveSuffix(string word)\n{\n    if (word.EndsWith(\"er\") && word.Length > 2)\n    {\n        return word.Substring(0, word.Length - 2);\n    }\n    else if (word.EndsWith(\"ly\") && word.Length > 2)\n    {\n        return word.Substring(0, word.Length - 2);\n    }\n    else if (word.EndsWith(\"ing\") && word.Length > 3)\n    {\n        return word.Substring(0, word.Length - 3);\n    }\n    return word;\n}\n\nToa maelezo mafupi ya lugha ya asili (docstring) ya msimbo wa C# kwa Kiswahili kwa kutumia herufi zisizozidi 500.",
      "tr": "static string RemoveSuffix(string word)\n{\n    if (word.EndsWith(\"er\") && word.Length > 2)\n    {\n        return word.Substring(0, word.Length - 2);\n    }\n    else if (word.EndsWith(\"ly\") && word.Length > 2)\n    {\n        return word.Substring(0, word.Length - 2);\n    }\n    else if (word.EndsWith(\"ing\") && word.Length > 3)\n    {\n        return word.Substring(0, word.Length - 3);\n    }\n    return word;\n}\n\nC# kodunun Türkçe olarak en fazla 500 karakter kullanarak doğal dilde kısa bir açıklamasını (docstring) sağlayın.",
      "vi": "static string RemoveSuffix(string word)\n{\n    if (word.EndsWith(\"er\") && word.Length > 2)\n    {\n        return word.Substring(0, word.Length - 2);\n    }\n    else if (word.EndsWith(\"ly\") && word.Length > 2)\n    {\n        return word.Substring(0, word.Length - 2);\n    }\n    else if (word.EndsWith(\"ing\") && word.Length > 3)\n    {\n        return word.Substring(0, word.Length - 3);\n    }\n    return word;\n}\n\nCung cấp mô tả ngắn gọn bằng ngôn ngữ tự nhiên (docstring) cho mã C# bằng tiếng Việt, không quá 500 ký tự."
    },
    "instruction_bertscore": {
      "es": "0.9702167647764858",
      "arb": "0.8829437397396628",
      "sw": "0.918288824262535",
      "tr": "0.8978134086943156",
      "vi": "0.9093975325162702"
    },
    "level": "",
    "test": "    static void Main()\n    {\n        Debug.Assert(RemoveSuffix(\"happily\") == \"happi\");\n        Debug.Assert(RemoveSuffix(\"dancing\") == \"danc\");\n        Debug.Assert(RemoveSuffix(\"flower\") == \"flow\");\n        Debug.Assert(RemoveSuffix(\"computer\") == \"comput\");\n        Debug.Assert(RemoveSuffix(\"flying\") == \"fly\");\n        Debug.Assert(RemoveSuffix(\"ing\") == \"ing\");\n        Debug.Assert(RemoveSuffix(\"er\") == \"er\");\n    }\n}",
    "entry_point": "RemoveSuffix",
    "signature": "static string RemoveSuffix(string word)",
    "docstring": {
      "es": "Elimina un sufijo específico ('er', 'ly' o 'ing') de la palabra dada si termina con uno de estos sufijos. \n    La función asegura que la palabra restante no esté vacía.\n    Ejemplos:\n        >>> RemoveSuffix(\"happily\")\n        \"happi\"\n        >>> RemoveSuffix(\"dancing\")\n        \"danc\"\n        >>> RemoveSuffix(\"flower\")\n        \"flow\"",
      "arb": "يزيل لاحقة معينة ('er', 'ly', أو 'ing') من الكلمة المعطاة إذا انتهت بإحدى هذه اللواحق. \n    تضمن الدالة أن الكلمة المتبقية ليست فارغة.\n    أمثلة:\n        >>> RemoveSuffix(\"happily\")\n        \"happi\"\n        >>> RemoveSuffix(\"dancing\")\n        \"danc\"\n        >>> RemoveSuffix(\"flower\")\n        \"flow\"",
      "sw": "Huondoa kiambishi tamati maalum ('er', 'ly', au 'ing') kutoka kwenye neno lililopewa ikiwa linaishia na moja ya viambishi hivi. \n    Kazi hii inahakikisha neno linalobaki haliko tupu.\n    Mifano:\n        >>> RemoveSuffix(\"happily\")\n        \"happi\"\n        >>> RemoveSuffix(\"dancing\")\n        \"danc\"\n        >>> RemoveSuffix(\"flower\")\n        \"flow\"",
      "tr": "Belirtilen kelimenin sonundaki belirli bir eki ('er', 'ly' veya 'ing') kaldırır. \n    Fonksiyon, geriye kalan kelimenin boş olmadığını garanti eder.\n    Örnekler:\n        >>> RemoveSuffix(\"happily\")\n        \"happi\"\n        >>> RemoveSuffix(\"dancing\")\n        \"danc\"\n        >>> RemoveSuffix(\"flower\")\n        \"flow\"",
      "vi": "Loại bỏ một hậu tố cụ thể ('er', 'ly', hoặc 'ing') khỏi từ đã cho nếu nó kết thúc bằng một trong các hậu tố này. \n    Hàm đảm bảo từ còn lại không bị rỗng.\n    Ví dụ:\n        >>> RemoveSuffix(\"happily\")\n        \"happi\"\n        >>> RemoveSuffix(\"dancing\")\n        \"danc\"\n        >>> RemoveSuffix(\"flower\")\n        \"flow\""
    },
    "docstring_bertscore": {
      "es": "0.9905722075945601",
      "arb": "0.9973039898382134",
      "sw": "0.9946322125829132",
      "tr": "0.9584645996521756",
      "vi": "0.991659311669964"
    }
  },
  {
    "task_id": "C#/31",
    "prompt": {
      "es": "using System;\nusing System.Collections.Generic;\nusing System.Diagnostics;\n\nclass Program\n{\n\n/* \n    Encuentra la primera palabra más larga y la primera palabra más corta en una oración dada. \n    Una palabra se define como una secuencia continua de letras (A-Z, a-z), \n    y las palabras están separadas por espacios y comas. Las comillas y otros \n    signos de puntuación no son parte de las palabras.\n\n    Ejemplos:\n    >>> FindLongestAndShortestWord(\"The quick, brown fox jumps over a lazy dog\")\n    (\"quick\", \"a\")\n\n    >>> FindLongestAndShortestWord(\"Hello world, this is an example sentence\")\n    (\"sentence\", \"is\")\n*/\n\n    static (string, string) FindLongestAndShortestWord(string sentence)",
      "arb": "using System;\nusing System.Collections.Generic;\nusing System.Diagnostics;\n\nclass Program\n{\n\n/* \n    يجد أول كلمة أطول وأول كلمة أقصر في جملة معينة.\n    تُعرف الكلمة على أنها تسلسل مستمر من الأحرف (A-Z, a-z)،\n    ويتم فصل الكلمات بواسطة مسافات وفواصل. علامات الاقتباس وعلامات الترقيم الأخرى\n    ليست جزءًا من الكلمات.\n\n    أمثلة:\n    >>> FindLongestAndShortestWord(\"The quick, brown fox jumps over a lazy dog\")\n    (\"quick\", \"a\")\n\n    >>> FindLongestAndShortestWord(\"Hello world, this is an example sentence\")\n    (\"sentence\", \"is\")\n*/\n\n    static (string, string) FindLongestAndShortestWord(string sentence)",
      "sw": "using System;\nusing System.Collections.Generic;\nusing System.Diagnostics;\n\nclass Program\n{\n\n/* \n    Inapata neno la kwanza refu zaidi na neno la kwanza fupi zaidi katika sentensi iliyotolewa. \n    Neno linafafanuliwa kama mfululizo wa herufi (A-Z, a-z), \n    na maneno yanatenganishwa na nafasi na koma. Alama za nukuu na \n    alama nyingine za uakifishaji si sehemu ya maneno.\n\n    Mifano:\n    >>> FindLongestAndShortestWord(\"The quick, brown fox jumps over a lazy dog\")\n    (\"quick\", \"a\")\n\n    >>> FindLongestAndShortestWord(\"Hello world, this is an example sentence\")\n    (\"sentence\", \"is\")\n*/\n\n    static (string, string) FindLongestAndShortestWord(string sentence)",
      "tr": "using System;\nusing System.Collections.Generic;\nusing System.Diagnostics;\n\nclass Program\n{\n\n/* \n    Verilen bir cümledeki ilk en uzun ve ilk en kısa kelimeyi bulur. \n    Bir kelime, harflerin (A-Z, a-z) kesintisiz bir dizisi olarak tanımlanır \n    ve kelimeler boşluklar ve virgüllerle ayrılır. Tırnak işaretleri ve diğer \n    noktalama işaretleri kelimelerin parçası değildir.\n\n    Örnekler:\n    >>> FindLongestAndShortestWord(\"The quick, brown fox jumps over a lazy dog\")\n    (\"quick\", \"a\")\n\n    >>> FindLongestAndShortestWord(\"Hello world, this is an example sentence\")\n    (\"sentence\", \"is\")\n*/\n\n    static (string, string) FindLongestAndShortestWord(string sentence)",
      "vi": "using System;\nusing System.Collections.Generic;\nusing System.Diagnostics;\n\nclass Program\n{\n\n/* \n    Tìm từ dài nhất đầu tiên và từ ngắn nhất đầu tiên trong một câu cho trước. \n    Một từ được định nghĩa là một chuỗi liên tục các chữ cái (A-Z, a-z), \n    và các từ được phân tách bằng khoảng trắng và dấu phẩy. Dấu ngoặc kép và các \n    dấu chấm câu khác không phải là một phần của các từ.\n\n    Ví dụ:\n    >>> FindLongestAndShortestWord(\"The quick, brown fox jumps over a lazy dog\")\n    (\"quick\", \"a\")\n\n    >>> FindLongestAndShortestWord(\"Hello world, this is an example sentence\")\n    (\"sentence\", \"is\")\n*/\n\n    static (string, string) FindLongestAndShortestWord(string sentence)"
    },
    "prompt_bertscore": {
      "es": "0.9919689764339974",
      "arb": "0.9946506852083494",
      "sw": "0.9820346765569185",
      "tr": "0.9954124327196182",
      "vi": "0.9909466258628108"
    },
    "canonical_solution": "    {\n        // Remove punctuation and split the sentence into words\n        string[] words = sentence.Split(new char[] { ' ', ',', '.', '!', '?', ';', ':' }, StringSplitOptions.RemoveEmptyEntries);\n\n        // Initialize the longest and shortest words with the first word\n        string longestWord = words[0];\n        string shortestWord = words[0];\n\n        // Iterate over the words to find the longest and shortest\n        foreach (string word in words)\n        {\n            if (word.Length > longestWord.Length)\n            {\n                longestWord = word;\n            }\n            else if (word.Length < shortestWord.Length)\n            {\n                shortestWord = word;\n            }\n        }\n\n        // Return the longest and shortest words\n        return (longestWord, shortestWord);\n    }",
    "instruction": {
      "es": "static (string, string) FindLongestAndShortestWord(string sentence)\n    {\n        // Remove punctuation and split the sentence into words\n        string[] words = sentence.Split(new char[] { ' ', ',', '.', '!', '?', ';', ':' }, StringSplitOptions.RemoveEmptyEntries);\n\n        // Initialize the longest and shortest words with the first word\n        string longestWord = words[0];\n        string shortestWord = words[0];\n\n        // Iterate over the words to find the longest and shortest\n        foreach (string word in words)\n        {\n            if (word.Length > longestWord.Length)\n            {\n                longestWord = word;\n            }\n            else if (word.Length < shortestWord.Length)\n            {\n                shortestWord = word;\n            }\n        }\n\n        // Return the longest and shortest words\n        return (longestWord, shortestWord);\n    }\n\nProporcione una descripción concisa en lenguaje natural (docstring) del código C# en español utilizando como máximo 500 caracteres.",
      "arb": "static (string, string) FindLongestAndShortestWord(string sentence)\n    {\n        // Remove punctuation and split the sentence into words\n        string[] words = sentence.Split(new char[] { ' ', ',', '.', '!', '?', ';', ':' }, StringSplitOptions.RemoveEmptyEntries);\n\n        // Initialize the longest and shortest words with the first word\n        string longestWord = words[0];\n        string shortestWord = words[0];\n\n        // Iterate over the words to find the longest and shortest\n        foreach (string word in words)\n        {\n            if (word.Length > longestWord.Length)\n            {\n                longestWord = word;\n            }\n            else if (word.Length < shortestWord.Length)\n            {\n                shortestWord = word;\n            }\n        }\n\n        // Return the longest and shortest words\n        return (longestWord, shortestWord);\n    }\n\nيرجى تقديم وصف موجز بلغة طبيعية (docstring) للكود المكتوب بلغة C# باللغة العربية الفصحى، باستخدام 500 حرف كحد أقصى.",
      "sw": "static (string, string) FindLongestAndShortestWord(string sentence)\n    {\n        // Remove punctuation and split the sentence into words\n        string[] words = sentence.Split(new char[] { ' ', ',', '.', '!', '?', ';', ':' }, StringSplitOptions.RemoveEmptyEntries);\n\n        // Initialize the longest and shortest words with the first word\n        string longestWord = words[0];\n        string shortestWord = words[0];\n\n        // Iterate over the words to find the longest and shortest\n        foreach (string word in words)\n        {\n            if (word.Length > longestWord.Length)\n            {\n                longestWord = word;\n            }\n            else if (word.Length < shortestWord.Length)\n            {\n                shortestWord = word;\n            }\n        }\n\n        // Return the longest and shortest words\n        return (longestWord, shortestWord);\n    }\n\nToa maelezo mafupi ya lugha ya asili (docstring) ya msimbo wa C# kwa Kiswahili kwa kutumia herufi zisizozidi 500.",
      "tr": "static (string, string) FindLongestAndShortestWord(string sentence)\n    {\n        // Remove punctuation and split the sentence into words\n        string[] words = sentence.Split(new char[] { ' ', ',', '.', '!', '?', ';', ':' }, StringSplitOptions.RemoveEmptyEntries);\n\n        // Initialize the longest and shortest words with the first word\n        string longestWord = words[0];\n        string shortestWord = words[0];\n\n        // Iterate over the words to find the longest and shortest\n        foreach (string word in words)\n        {\n            if (word.Length > longestWord.Length)\n            {\n                longestWord = word;\n            }\n            else if (word.Length < shortestWord.Length)\n            {\n                shortestWord = word;\n            }\n        }\n\n        // Return the longest and shortest words\n        return (longestWord, shortestWord);\n    }\n\nAşağıdaki C# kodunun işlevselliğini açıklayan en fazla 500 karakterlik kısa bir doğal dil açıklaması (docstring) sağlayın.",
      "vi": "static (string, string) FindLongestAndShortestWord(string sentence)\n    {\n        // Remove punctuation and split the sentence into words\n        string[] words = sentence.Split(new char[] { ' ', ',', '.', '!', '?', ';', ':' }, StringSplitOptions.RemoveEmptyEntries);\n\n        // Initialize the longest and shortest words with the first word\n        string longestWord = words[0];\n        string shortestWord = words[0];\n\n        // Iterate over the words to find the longest and shortest\n        foreach (string word in words)\n        {\n            if (word.Length > longestWord.Length)\n            {\n                longestWord = word;\n            }\n            else if (word.Length < shortestWord.Length)\n            {\n                shortestWord = word;\n            }\n        }\n\n        // Return the longest and shortest words\n        return (longestWord, shortestWord);\n    }\n\nCung cấp mô tả ngắn gọn bằng ngôn ngữ tự nhiên (docstring) cho mã C# bằng tiếng Việt, không quá 500 ký tự."
    },
    "instruction_bertscore": {
      "es": "0.9702167647764858",
      "arb": "0.8926559708507447",
      "sw": "0.9446027812508938",
      "tr": "0.8504209943009153",
      "vi": "0.9239873312640449"
    },
    "level": "",
    "test": "    static void Main()\n    {\n        Debug.Assert(FindLongestAndShortestWord(\"Fast cars, smooth drives\") == (\"smooth\", \"Fast\"));\n        Debug.Assert(FindLongestAndShortestWord(\"Sunshine brings happiness\") == (\"happiness\", \"brings\"));\n        Debug.Assert(FindLongestAndShortestWord(\"A\") == (\"A\", \"A\")); // Edge case: Only one word\n        Debug.Assert(FindLongestAndShortestWord(\"Every cloud has a silver lining\") == (\"silver\", \"a\"));\n\n\n    }\n}",
    "entry_point": "FindLongestAndShortestWord",
    "signature": "static (string, string) FindLongestAndShortestWord(string sentence)",
    "docstring": {
      "es": "Encuentra la primera palabra más larga y la primera palabra más corta en una oración dada. \n    Una palabra se define como una secuencia continua de letras (A-Z, a-z), \n    y las palabras están separadas por espacios y comas. Las comillas y otros \n    signos de puntuación no son parte de las palabras.\n\n    Ejemplos:\n    >>> FindLongestAndShortestWord(\"The quick, brown fox jumps over a lazy dog\")\n    (\"quick\", \"a\")\n\n    >>> FindLongestAndShortestWord(\"Hello world, this is an example sentence\")\n    (\"sentence\", \"is\")",
      "arb": "يجد أول أطول كلمة وأول أقصر كلمة في الجملة المعطاة. \n    تُعرف الكلمة على أنها تسلسل مستمر من الحروف (A-Z، a-z)، \n    ويتم فصل الكلمات بالمسافات والفواصل. لا تعتبر علامات الاقتباس وعلامات الترقيم الأخرى \n    جزءًا من الكلمات.\n\n    أمثلة:\n    >>> FindLongestAndShortestWord(\"The quick, brown fox jumps over a lazy dog\")\n    (\"quick\", \"a\")\n\n    >>> FindLongestAndShortestWord(\"Hello world, this is an example sentence\")\n    (\"sentence\", \"is\")",
      "sw": "Inapata neno la kwanza refu zaidi na neno la kwanza fupi zaidi katika sentensi iliyotolewa. \n    Neno linafafanuliwa kama mlolongo endelevu wa herufi (A-Z, a-z), \n    na maneno yanatenganishwa na nafasi na koma. Alama za nukuu na \n    alama nyingine za uakifishaji si sehemu ya maneno.\n\n    Mifano:\n    >>> FindLongestAndShortestWord(\"The quick, brown fox jumps over a lazy dog\")\n    (\"quick\", \"a\")\n\n    >>> FindLongestAndShortestWord(\"Hello world, this is an example sentence\")\n    (\"sentence\", \"is\")",
      "tr": "Verilen bir cümledeki ilk en uzun ve ilk en kısa kelimeyi bulur.\n    Bir kelime, harflerin (A-Z, a-z) kesintisiz bir dizisi olarak tanımlanır \n    ve kelimeler boşluklar ve virgüllerle ayrılır. Tırnak işaretleri ve diğer \n    noktalama işaretleri kelimelerin parçası değildir.\n\n    Örnekler:\n    >>> FindLongestAndShortestWord(\"The quick, brown fox jumps over a lazy dog\")\n    (\"quick\", \"a\")\n\n    >>> FindLongestAndShortestWord(\"Hello world, this is an example sentence\")\n    (\"sentence\", \"is\")",
      "vi": "Tìm từ dài nhất đầu tiên và từ ngắn nhất đầu tiên trong một câu cho trước. \n    Một từ được định nghĩa là một chuỗi liên tục của các chữ cái (A-Z, a-z), \n    và các từ được ngăn cách bởi dấu cách và dấu phẩy. Dấu ngoặc kép và các \n    dấu câu khác không phải là một phần của các từ.\n\n    Ví dụ:\n    >>> FindLongestAndShortestWord(\"The quick, brown fox jumps over a lazy dog\")\n    (\"quick\", \"a\")\n\n    >>> FindLongestAndShortestWord(\"Hello world, this is an example sentence\")\n    (\"sentence\", \"is\")"
    },
    "docstring_bertscore": {
      "es": "0.9892882608115505",
      "arb": "0.9816511212911402",
      "sw": "0.9839850282683",
      "tr": "0.9935075673654936",
      "vi": "0.9839762885315345"
    }
  },
  {
    "task_id": "C#/32",
    "prompt": {
      "es": "using System;\nusing System.Collections.Generic;\nusing System.Diagnostics;\n\nclass Program\n{\n\n\n/* Calcular la velocidad de un vehículo y el siguiente número palindrómico en el odómetro.\n     Dada la lectura actual del odómetro palindrómico y el tiempo transcurrido en horas,\n     encontrar la velocidad constante del vehículo y la siguiente lectura palindrómica del odómetro.\n     La velocidad se calcula por hora.\n     Ejemplo:\n     >>> CalculateSpeedAndNextPalindrome(12321, 2)\n     (50, 12421)\n     >>> CalculateSpeedAndNextPalindrome(23332, 4)\n     (25, 23432)\n*/\nstatic (int, int) CalculateSpeedAndNextPalindrome(int currentPalindrome, int elapsedHours)",
      "arb": "using System;\nusing System.Collections.Generic;\nusing System.Diagnostics;\n\nclass Program\n{\n\n\n/* حساب سرعة المركبة والرقم التالي المتناظر على عداد المسافات.\n     بالنظر إلى قراءة عداد المسافات المتناظرة الحالية والوقت المنقضي بالساعات،\n     ابحث عن السرعة الثابتة للمركبة وقراءة عداد المسافات المتناظرة التالية.\n     يتم حساب السرعة لكل ساعة.\n     مثال:\n     >>> CalculateSpeedAndNextPalindrome(12321, 2)\n     (50, 12421)\n     >>> CalculateSpeedAndNextPalindrome(23332, 4)\n     (25, 23432)\n*/\nstatic (int, int) CalculateSpeedAndNextPalindrome(int currentPalindrome, int elapsedHours)",
      "sw": "using System;\nusing System.Collections.Generic;\nusing System.Diagnostics;\n\nclass Program\n{\n\n\n/* Hesabu kasi ya gari na namba inayofuata ya palindromu kwenye odomita.\n     Ukipewa usomaji wa sasa wa palindromu kwenye odomita na muda uliopita kwa saa,\n     pata kasi ya gari isiyobadilika na usomaji unaofuata wa palindromu kwenye odomita.\n     Kasi inahesabiwa kwa saa.\n     Mfano:\n     >>> CalculateSpeedAndNextPalindrome(12321, 2)\n     (50, 12421)\n     >>> CalculateSpeedAndNextPalindrome(23332, 4)\n     (25, 23432)\n*/\nstatic (int, int) CalculateSpeedAndNextPalindrome(int currentPalindrome, int elapsedHours)",
      "tr": "using System;\nusing System.Collections.Generic;\nusing System.Diagnostics;\n\nclass Program\n{\n\n\n/* Bir aracın hızını ve kilometre sayacındaki bir sonraki palindromik sayıyı hesaplayın.\n     Mevcut palindromik kilometre sayacı okuması ve geçen süre saat cinsinden verildiğinde,\n     aracın sabit hızını ve bir sonraki palindromik kilometre sayacı okumasını bulun.\n     Hız saat başına hesaplanır.\n     Örnek:\n     >>> CalculateSpeedAndNextPalindrome(12321, 2)\n     (50, 12421)\n     >>> CalculateSpeedAndNextPalindrome(23332, 4)\n     (25, 23432)\n*/\nstatic (int, int) CalculateSpeedAndNextPalindrome(int currentPalindrome, int elapsedHours)",
      "vi": "using System;\nusing System.Collections.Generic;\nusing System.Diagnostics;\n\nclass Program\n{\n\n\n/* Tính tốc độ của một phương tiện và số đối xứng tiếp theo trên đồng hồ đo quãng đường.\n     Cho số đọc đồng hồ đo quãng đường đối xứng hiện tại và thời gian đã trôi qua tính bằng giờ,\n     tìm tốc độ không đổi của phương tiện và số đọc đồng hồ đo quãng đường đối xứng tiếp theo.\n     Tốc độ được tính theo giờ.\n     Ví dụ:\n     >>> CalculateSpeedAndNextPalindrome(12321, 2)\n     (50, 12421)\n     >>> CalculateSpeedAndNextPalindrome(23332, 4)\n     (25, 23432)\n*/\nstatic (int, int) CalculateSpeedAndNextPalindrome(int currentPalindrome, int elapsedHours)"
    },
    "prompt_bertscore": {
      "es": "0.9985374845044401",
      "arb": "0.9907352831373897",
      "sw": "0.9699698672128594",
      "tr": "0.9955409465761478",
      "vi": "0.9711866769270792"
    },
    "canonical_solution": "{\n    int nextPalindrome = currentPalindrome;\n    do\n    {\n        nextPalindrome++;\n    } while (!IsPalindrome(nextPalindrome));\n\n    int speed = (nextPalindrome - currentPalindrome) / elapsedHours;\n    return (speed, nextPalindrome);\n}\n\nstatic bool IsPalindrome(int number)\n{\n    string numStr = number.ToString();\n    for (int i = 0; i < numStr.Length / 2; i++)\n    {\n        if (numStr[i] != numStr[numStr.Length - 1 - i])\n        {\n            return false;\n        }\n    }\n    return true;\n}",
    "instruction": {
      "es": "static (int, int) CalculateSpeedAndNextPalindrome(int currentPalindrome, int elapsedHours)\n{\n    int nextPalindrome = currentPalindrome;\n    do\n    {\n        nextPalindrome++;\n    } while (!IsPalindrome(nextPalindrome));\n\n    int speed = (nextPalindrome - currentPalindrome) / elapsedHours;\n    return (speed, nextPalindrome);\n}\n\nstatic bool IsPalindrome(int number)\n{\n    string numStr = number.ToString();\n    for (int i = 0; i < numStr.Length / 2; i++)\n    {\n        if (numStr[i] != numStr[numStr.Length - 1 - i])\n        {\n            return false;\n        }\n    }\n    return true;\n}\n\nProporciona una descripción concisa en lenguaje natural (docstring) del código C# en español utilizando un máximo de 500 caracteres.",
      "arb": "static (int, int) CalculateSpeedAndNextPalindrome(int currentPalindrome, int elapsedHours)\n{\n    int nextPalindrome = currentPalindrome;\n    do\n    {\n        nextPalindrome++;\n    } while (!IsPalindrome(nextPalindrome));\n\n    int speed = (nextPalindrome - currentPalindrome) / elapsedHours;\n    return (speed, nextPalindrome);\n}\n\nstatic bool IsPalindrome(int number)\n{\n    string numStr = number.ToString();\n    for (int i = 0; i < numStr.Length / 2; i++)\n    {\n        if (numStr[i] != numStr[numStr.Length - 1 - i])\n        {\n            return false;\n        }\n    }\n    return true;\n}\n\nيرجى تقديم وصف موجز بلغة طبيعية (docstring) للشيفرة البرمجية المكتوبة بلغة C# باللغة العربية الفصحى، باستخدام 500 حرف كحد أقصى.",
      "sw": "static (int, int) CalculateSpeedAndNextPalindrome(int currentPalindrome, int elapsedHours)\n{\n    int nextPalindrome = currentPalindrome;\n    do\n    {\n        nextPalindrome++;\n    } while (!IsPalindrome(nextPalindrome));\n\n    int speed = (nextPalindrome - currentPalindrome) / elapsedHours;\n    return (speed, nextPalindrome);\n}\n\nstatic bool IsPalindrome(int number)\n{\n    string numStr = number.ToString();\n    for (int i = 0; i < numStr.Length / 2; i++)\n    {\n        if (numStr[i] != numStr[numStr.Length - 1 - i])\n        {\n            return false;\n        }\n    }\n    return true;\n}\n\nToa maelezo mafupi ya lugha ya asili (docstring) ya msimbo wa C# kwa Kiswahili kwa kutumia herufi zisizozidi 500.",
      "tr": "static (int, int) CalculateSpeedAndNextPalindrome(int currentPalindrome, int elapsedHours)\n{\n    int nextPalindrome = currentPalindrome;\n    do\n    {\n        nextPalindrome++;\n    } while (!IsPalindrome(nextPalindrome));\n\n    int speed = (nextPalindrome - currentPalindrome) / elapsedHours;\n    return (speed, nextPalindrome);\n}\n\nstatic bool IsPalindrome(int number)\n{\n    string numStr = number.ToString();\n    for (int i = 0; i < numStr.Length / 2; i++)\n    {\n        if (numStr[i] != numStr[numStr.Length - 1 - i])\n        {\n            return false;\n        }\n    }\n    return true;\n}\n\nC# kodunun Türkçe dilinde en fazla 500 karakter kullanarak özlü bir doğal dil açıklamasını (docstring) sağlayın.",
      "vi": "static (int, int) CalculateSpeedAndNextPalindrome(int currentPalindrome, int elapsedHours)\n{\n    int nextPalindrome = currentPalindrome;\n    do\n    {\n        nextPalindrome++;\n    } while (!IsPalindrome(nextPalindrome));\n\n    int speed = (nextPalindrome - currentPalindrome) / elapsedHours;\n    return (speed, nextPalindrome);\n}\n\nstatic bool IsPalindrome(int number)\n{\n    string numStr = number.ToString();\n    for (int i = 0; i < numStr.Length / 2; i++)\n    {\n        if (numStr[i] != numStr[numStr.Length - 1 - i])\n        {\n            return false;\n        }\n    }\n    return true;\n}\n\nCung cấp mô tả ngắn gọn bằng ngôn ngữ tự nhiên (docstring) cho mã C# bằng tiếng Việt với tối đa 500 ký tự."
    },
    "instruction_bertscore": {
      "es": "0.9702167647764858",
      "arb": "0.9080967021508728",
      "sw": "0.918288824262535",
      "tr": "0.9520575780815143",
      "vi": "0.9066002208601559"
    },
    "level": "",
    "test": "    static void Main()\n    {\n        Debug.Assert(CalculateSpeedAndNextPalindrome(12321, 2) == (50, 12421));\n        Debug.Assert(CalculateSpeedAndNextPalindrome(11111, 1) == (100, 11211));\n        Debug.Assert(CalculateSpeedAndNextPalindrome(23332, 2) == (50, 23432));\n        Debug.Assert(CalculateSpeedAndNextPalindrome(45654, 4) == (25, 45754));\n\n    }\n}",
    "entry_point": "CalculateSpeedAndNextPalindrome",
    "signature": "static (int, int) CalculateSpeedAndNextPalindrome(int currentPalindrome, int elapsedHours)",
    "docstring": {
      "es": "Calcular la velocidad de un vehículo y el siguiente número palindrómico en el odómetro.\n     Dada la lectura actual del odómetro palindrómico y el tiempo transcurrido en horas,\n     encuentre la velocidad constante del vehículo y la siguiente lectura palindrómica del odómetro.\n     La velocidad se calcula por hora.\n     Ejemplo:\n     >>> CalculateSpeedAndNextPalindrome(12321, 2)\n     (50, 12421)\n     >>> CalculateSpeedAndNextPalindrome(23332, 4)\n     (25, 23432)",
      "arb": "احسب سرعة المركبة والرقم التالي المتناظر على عداد المسافات.\n     بالنظر إلى قراءة عداد المسافات المتناظرة الحالية والوقت المنقضي بالساعات،\n     ابحث عن السرعة الثابتة للمركبة وقراءة عداد المسافات المتناظرة التالية.\n     يتم حساب السرعة لكل ساعة.\n     مثال:\n     >>> CalculateSpeedAndNextPalindrome(12321, 2)\n     (50, 12421)\n     >>> CalculateSpeedAndNextPalindrome(23332, 4)\n     (25, 23432)",
      "sw": "Hesabu kasi ya gari na nambari inayofuata ya palindromu kwenye odomita.\n     Ukipewa usomaji wa sasa wa odomita ya palindromu na muda uliopita kwa saa,\n     pata kasi ya gari isiyobadilika na usomaji unaofuata wa odomita ya palindromu.\n     Kasi inahesabiwa kwa saa.\n     Mfano:\n     >>> CalculateSpeedAndNextPalindrome(12321, 2)\n     (50, 12421)\n     >>> CalculateSpeedAndNextPalindrome(23332, 4)\n     (25, 23432)",
      "tr": "Bir aracın hızını ve kilometre sayacındaki bir sonraki palindromik sayıyı hesaplayın.\n     Verilen mevcut palindromik kilometre sayacı okuması ve geçen süre saat cinsinden olduğunda,\n     aracın sabit hızını ve bir sonraki palindromik kilometre sayacı okumasını bulun.\n     Hız saat başına hesaplanır.\n     Örnek:\n     >>> CalculateSpeedAndNextPalindrome(12321, 2)\n     (50, 12421)\n     >>> CalculateSpeedAndNextPalindrome(23332, 4)\n     (25, 23432)",
      "vi": "Tính toán tốc độ của một phương tiện và số palindromic tiếp theo trên đồng hồ đo quãng đường.\n     Cho số đọc đồng hồ đo quãng đường palindromic hiện tại và thời gian đã trôi qua tính bằng giờ,\n     tìm tốc độ không đổi của phương tiện và số đọc đồng hồ đo quãng đường palindromic tiếp theo.\n     Tốc độ được tính theo giờ.\n     Ví dụ:\n     >>> CalculateSpeedAndNextPalindrome(12321, 2)\n     (50, 12421)\n     >>> CalculateSpeedAndNextPalindrome(23332, 4)\n     (25, 23432)"
    },
    "docstring_bertscore": {
      "es": "0.9983964569339053",
      "arb": "0.9959596594193694",
      "sw": "0.9616863844325615",
      "tr": "0.9983964569339053",
      "vi": "0.9983964569339053"
    }
  },
  {
    "task_id": "C#/33",
    "prompt": {
      "es": "using System;\nusing System.Collections.Generic;\nusing System.Diagnostics;\n\nclass Program\n{\n\n/* Encuentra todos los números automórficos dentro de un límite especificado.\n    Un número automórfico es un número cuyo cuadrado termina en el mismo número.\n    Ejemplos:\n    >>> FindAutomorphicNumbers(100)\n    [0, 1, 5, 6, 25, 76]\n    >>> FindAutomorphicNumbers(500)\n    [0, 1, 5, 6, 25, 76, 376]\n*/\n\nstatic List<int> FindAutomorphicNumbers(int limit)",
      "arb": "using System;\nusing System.Collections.Generic;\nusing System.Diagnostics;\n\nclass Program\n{\n\n/* يجد جميع الأعداد الذاتية ضمن حد محدد.\n    العدد الذاتي هو عدد ينتهي مربعه بنفس العدد.\n    أمثلة:\n    >>> FindAutomorphicNumbers(100)\n    [0, 1, 5, 6, 25, 76]\n    >>> FindAutomorphicNumbers(500)\n    [0, 1, 5, 6, 25, 76, 376]\n*/\n\nstatic List<int> FindAutomorphicNumbers(int limit)",
      "sw": "using System;\nusing System.Collections.Generic;\nusing System.Diagnostics;\n\nclass Program\n{\n\n/* Inapata namba zote za automorphic ndani ya kikomo kilichobainishwa.\n    Namba ya automorphic ni namba ambayo mraba wake unaishia na namba yenyewe.\n    Mifano:\n    >>> FindAutomorphicNumbers(100)\n    [0, 1, 5, 6, 25, 76]\n    >>> FindAutomorphicNumbers(500)\n    [0, 1, 5, 6, 25, 76, 376]\n*/\n\nstatic List<int> FindAutomorphicNumbers(int limit)",
      "tr": "using System;\nusing System.Collections.Generic;\nusing System.Diagnostics;\n\nclass Program\n{\n\n/* Belirtilen bir sınır içindeki tüm otomorfik sayıları bulur.\n    Bir otomorfik sayı, karesi kendisiyle biten bir sayıdır.\n    Örnekler:\n    >>> FindAutomorphicNumbers(100)\n    [0, 1, 5, 6, 25, 76]\n    >>> FindAutomorphicNumbers(500)\n    [0, 1, 5, 6, 25, 76, 376]\n*/\n\nstatic List<int> FindAutomorphicNumbers(int limit)",
      "vi": "using System;\nusing System.Collections.Generic;\nusing System.Diagnostics;\n\nclass Program\n{\n\n/* Tìm tất cả các số tự hình trong một giới hạn được chỉ định.\n    Một số tự hình là một số có bình phương kết thúc bằng chính số đó.\n    Ví dụ:\n    >>> FindAutomorphicNumbers(100)\n    [0, 1, 5, 6, 25, 76]\n    >>> FindAutomorphicNumbers(500)\n    [0, 1, 5, 6, 25, 76, 376]\n*/\n\nstatic List<int> FindAutomorphicNumbers(int limit)"
    },
    "prompt_bertscore": {
      "es": "0.9891802058842676",
      "arb": "0.9882649170884588",
      "sw": "0.9982792650090948",
      "tr": "0.9982792650090948",
      "vi": "0.9923706070644499"
    },
    "canonical_solution": "{\n    var automorphicNumbers = new List<int>();\n    for (int i = 0; i <= limit; i++)\n    {\n        long square = (long)i * i;\n        string numberStr = i.ToString();\n        string squareStr = square.ToString();\n        if (squareStr.EndsWith(numberStr))\n        {\n            automorphicNumbers.Add(i);\n        }\n    }\n    return automorphicNumbers;\n}",
    "instruction": {
      "es": "static List<int> FindAutomorphicNumbers(int limit)\n{\n    var automorphicNumbers = new List<int>();\n    for (int i = 0; i <= limit; i++)\n    {\n        long square = (long)i * i;\n        string numberStr = i.ToString();\n        string squareStr = square.ToString();\n        if (squareStr.EndsWith(numberStr))\n        {\n            automorphicNumbers.Add(i);\n        }\n    }\n    return automorphicNumbers;\n}\n\nProporcione una descripción concisa en lenguaje natural (docstring) del código C# en español usando un máximo de 500 caracteres.",
      "arb": "static List<int> FindAutomorphicNumbers(int limit)\n{\n    var automorphicNumbers = new List<int>();\n    for (int i = 0; i <= limit; i++)\n    {\n        long square = (long)i * i;\n        string numberStr = i.ToString();\n        string squareStr = square.ToString();\n        if (squareStr.EndsWith(numberStr))\n        {\n            automorphicNumbers.Add(i);\n        }\n    }\n    return automorphicNumbers;\n}\n\nيرجى تقديم وصف موجز بلغة طبيعية (docstring) للكود المكتوب بلغة C# باللغة العربية الفصحى، على ألا يتجاوز 500 حرف.",
      "sw": "static List<int> FindAutomorphicNumbers(int limit)\n{\n    var automorphicNumbers = new List<int>();\n    for (int i = 0; i <= limit; i++)\n    {\n        long square = (long)i * i;\n        string numberStr = i.ToString();\n        string squareStr = square.ToString();\n        if (squareStr.EndsWith(numberStr))\n        {\n            automorphicNumbers.Add(i);\n        }\n    }\n    return automorphicNumbers;\n}\n\nToa maelezo mafupi ya lugha ya asili (docstring) ya msimbo wa C# kwa Kiswahili kwa kutumia herufi zisizozidi 500.",
      "tr": "static List<int> FindAutomorphicNumbers(int limit)\n{\n    var automorphicNumbers = new List<int>();\n    for (int i = 0; i <= limit; i++)\n    {\n        long square = (long)i * i;\n        string numberStr = i.ToString();\n        string squareStr = square.ToString();\n        if (squareStr.EndsWith(numberStr))\n        {\n            automorphicNumbers.Add(i);\n        }\n    }\n    return automorphicNumbers;\n}\n\nAşağıdaki C# kodunun işlevini açıklayan, en fazla 500 karakter uzunluğunda özlü bir doğal dil açıklaması (docstring) sağlayın.",
      "vi": "static List<int> FindAutomorphicNumbers(int limit)\n{\n    var automorphicNumbers = new List<int>();\n    for (int i = 0; i <= limit; i++)\n    {\n        long square = (long)i * i;\n        string numberStr = i.ToString();\n        string squareStr = square.ToString();\n        if (squareStr.EndsWith(numberStr))\n        {\n            automorphicNumbers.Add(i);\n        }\n    }\n    return automorphicNumbers;\n}\n\nCung cấp mô tả ngắn gọn bằng ngôn ngữ tự nhiên (docstring) cho mã C# bằng tiếng Việt, sử dụng tối đa 500 ký tự."
    },
    "instruction_bertscore": {
      "es": "0.9702167647764858",
      "arb": "0.8829437397396628",
      "sw": "0.918288824262535",
      "tr": "0.8561385698190046",
      "vi": "0.9230923027671016"
    },
    "level": "",
    "test": "    static void Main()\n    {\n     Debug.Assert(FindAutomorphicNumbers(100).SequenceEqual(new List<int> { 0, 1, 5, 6, 25, 76 }));\n    Debug.Assert(FindAutomorphicNumbers(500).SequenceEqual(new List<int> { 0, 1, 5, 6, 25, 76, 376 }));\n    Debug.Assert(FindAutomorphicNumbers(1000).SequenceEqual(new List<int> { 0, 1, 5, 6, 25, 76, 376, 625 }));\n    Debug.Assert(FindAutomorphicNumbers(200000).SequenceEqual(new List<int> { 0, 1, 5, 6, 25, 76, 376, 625,9376, 90625, 109376 }));\n\n    }\n}",
    "entry_point": "FindAutomorphicNumbers",
    "signature": "static List<int> FindAutomorphicNumbers(int limit)",
    "docstring": {
      "es": "Encuentra todos los números automórficos dentro de un límite especificado.\n    Un número automórfico es un número cuyo cuadrado termina en el mismo número.\n    Ejemplos:\n    >>> FindAutomorphicNumbers(100)\n    [0, 1, 5, 6, 25, 76]\n    >>> FindAutomorphicNumbers(500)\n    [0, 1, 5, 6, 25, 76, 376]",
      "arb": "يجد جميع الأعداد الذاتية ضمن حد محدد.\n    العدد الذاتي هو عدد ينتهي مربعه بالعدد نفسه.\n    أمثلة:\n    >>> FindAutomorphicNumbers(100)\n    [0, 1, 5, 6, 25, 76]\n    >>> FindAutomorphicNumbers(500)\n    [0, 1, 5, 6, 25, 76, 376]",
      "sw": "Inapata nambari zote za automorphic ndani ya kikomo kilichobainishwa.\n    Nambari ya automorphic ni nambari ambayo mraba wake unamalizika na nambari yenyewe.\n    Mifano:\n    >>> FindAutomorphicNumbers(100)\n    [0, 1, 5, 6, 25, 76]\n    >>> FindAutomorphicNumbers(500)\n    [0, 1, 5, 6, 25, 76, 376]",
      "tr": "Belirtilen bir sınır içinde tüm otomorfik sayıları bulur.\n    Bir otomorfik sayı, karesi kendisiyle biten bir sayıdır.\n    Örnekler:\n    >>> FindAutomorphicNumbers(100)\n    [0, 1, 5, 6, 25, 76]\n    >>> FindAutomorphicNumbers(500)\n    [0, 1, 5, 6, 25, 76, 376]",
      "vi": "Tìm tất cả các số tự động trong một giới hạn được chỉ định.  \nMột số tự động là một số mà bình phương của nó kết thúc bằng chính số đó.  \nVí dụ:  \n>>> FindAutomorphicNumbers(100)  \n[0, 1, 5, 6, 25, 76]  \n>>> FindAutomorphicNumbers(500)  \n[0, 1, 5, 6, 25, 76, 376]  "
    },
    "docstring_bertscore": {
      "es": "0.9737021320725049",
      "arb": "0.987856533025051",
      "sw": "0.9977272711801988",
      "tr": "0.9977272711801988",
      "vi": "0.9867813467725092"
    }
  },
  {
    "task_id": "C#/34",
    "prompt": {
      "es": "using System;\nusing System.Collections.Generic;\nusing System.Diagnostics;\n\nclass Program\n{\n\n/* Determinar el número de la última persona que queda en un juego de conteo circular.\n   En este juego, las personas están numeradas del 1 al totalPeople y se sientan en un círculo.\n   Comenzando con la primera persona, cuentan del 1 al countNumber.\n   La persona que está en countNumber es eliminada del círculo,\n   y el conteo se reanuda desde la siguiente persona.\n   Este proceso continúa hasta que solo queda una persona.\n\n   Ejemplo:\n   >>> LastRemainingPerson(5, 2)\n   3\n   >>> LastRemainingPerson(6, 4)\n   5\n*/\n\nstatic int LastRemainingPerson(int totalPeople, int countNumber)",
      "arb": "using System;\nusing System.Collections.Generic;\nusing System.Diagnostics;\n\nclass Program\n{\n\n/* تحديد رقم الشخص الأخير المتبقي في لعبة العد الدائري.\n   في هذه اللعبة، يتم ترقيم الأشخاص من 1 إلى totalPeople ويجلسون في دائرة.\n   بدءًا من الشخص الأول، يقومون بالعد من 1 إلى countNumber.\n   الشخص الذي يكون عند countNumber يتم إزالته من الدائرة،\n   ويستأنف العد من الشخص التالي.\n   تستمر هذه العملية حتى يبقى شخص واحد فقط.\n\n   مثال:\n   >>> LastRemainingPerson(5, 2)\n   3\n   >>> LastRemainingPerson(6, 4)\n   5\n*/\n\nstatic int LastRemainingPerson(int totalPeople, int countNumber)",
      "sw": "using System;\nusing System.Collections.Generic;\nusing System.Diagnostics;\n\nclass Program\n{\n\n/* Tambua namba ya mtu wa mwisho aliyebaki katika mchezo wa kuhesabu wa mduara.\n   Katika mchezo huu, watu wanapewa namba kutoka 1 hadi totalPeople na wanakaa katika mduara. \n   Kuanzia na mtu wa kwanza, wanahesabu kutoka 1 hadi countNumber. \n   Mtu ambaye yuko kwenye countNumber anaondolewa kwenye mduara, \n   na kuhesabu kunaanza tena kutoka kwa mtu anayefuata. \n   Mchakato huu unaendelea hadi mtu mmoja tu abaki.\n\n   Mfano:\n   >>> LastRemainingPerson(5, 2)\n   3\n   >>> LastRemainingPerson(6, 4)\n   5\n*/\n\nstatic int LastRemainingPerson(int totalPeople, int countNumber)",
      "tr": "using System;\nusing System.Collections.Generic;\nusing System.Diagnostics;\n\nclass Program\n{\n\n/* Dairesel bir sayma oyununda son kalan kişinin numarasını belirleyin.\n   Bu oyunda, insanlar 1'den totalPeople'a kadar numaralandırılır ve bir çemberde otururlar.\n   İlk kişiden başlayarak, 1'den countNumber'a kadar sayarlar.\n   countNumber'da olan kişi çemberden çıkarılır,\n   ve sayma bir sonraki kişiden devam eder.\n   Bu süreç sadece bir kişi kalana kadar devam eder.\n\n   Örnek:\n   >>> LastRemainingPerson(5, 2)\n   3\n   >>> LastRemainingPerson(6, 4)\n   5\n*/\n\nstatic int LastRemainingPerson(int totalPeople, int countNumber)",
      "vi": "using System;\nusing System.Collections.Generic;\nusing System.Diagnostics;\n\nclass Program\n{\n\n/* Xác định số của người cuối cùng còn lại trong một trò chơi đếm vòng tròn.\n   Trong trò chơi này, mọi người được đánh số từ 1 đến totalPeople và ngồi thành vòng tròn.\n   Bắt đầu từ người đầu tiên, họ đếm từ 1 đến countNumber.\n   Người ở vị trí countNumber sẽ bị loại khỏi vòng tròn,\n   và việc đếm tiếp tục từ người kế tiếp.\n   Quá trình này tiếp tục cho đến khi chỉ còn lại một người.\n\n   Ví dụ:\n   >>> LastRemainingPerson(5, 2)\n   3\n   >>> LastRemainingPerson(6, 4)\n   5\n*/\n\nstatic int LastRemainingPerson(int totalPeople, int countNumber)"
    },
    "prompt_bertscore": {
      "es": "0.9911837905377665",
      "arb": "0.9894187609718905",
      "sw": "0.9698010313889798",
      "tr": "0.989290843006504",
      "vi": "0.9764078751229622"
    },
    "canonical_solution": "{\n    List<int> people = new List<int>();\n    for (int i = 1; i <= totalPeople; i++)\n    {\n        people.Add(i);\n    }\n\n    int index = 0;\n    while (people.Count > 1)\n    {\n        index = (index + countNumber - 1) % people.Count;\n        people.RemoveAt(index);\n    }\n\n    return people[0];\n}",
    "instruction": {
      "es": "static int LastRemainingPerson(int totalPeople, int countNumber)\n{\n    List<int> people = new List<int>();\n    for (int i = 1; i <= totalPeople; i++)\n    {\n        people.Add(i);\n    }\n\n    int index = 0;\n    while (people.Count > 1)\n    {\n        index = (index + countNumber - 1) % people.Count;\n        people.RemoveAt(index);\n    }\n\n    return people[0];\n}\n\nProporcione una descripción concisa en lenguaje natural (docstring) del código C# en español utilizando como máximo 500 caracteres.",
      "arb": "static int LastRemainingPerson(int totalPeople, int countNumber)\n{\n    List<int> people = new List<int>();\n    for (int i = 1; i <= totalPeople; i++)\n    {\n        people.Add(i);\n    }\n\n    int index = 0;\n    while (people.Count > 1)\n    {\n        index = (index + countNumber - 1) % people.Count;\n        people.RemoveAt(index);\n    }\n\n    return people[0];\n}\n\nيرجى تقديم وصف موجز بلغة طبيعية (docstring) للكود المكتوب بلغة C# باللغة العربية الفصحى، بحيث لا يتجاوز 500 حرف.",
      "sw": "static int LastRemainingPerson(int totalPeople, int countNumber)\n{\n    List<int> people = new List<int>();\n    for (int i = 1; i <= totalPeople; i++)\n    {\n        people.Add(i);\n    }\n\n    int index = 0;\n    while (people.Count > 1)\n    {\n        index = (index + countNumber - 1) % people.Count;\n        people.RemoveAt(index);\n    }\n\n    return people[0];\n}\n\nToa maelezo mafupi ya lugha asilia (docstring) ya msimbo wa C# kwa Kiswahili kwa kutumia herufi zisizozidi 500.",
      "tr": "static int LastRemainingPerson(int totalPeople, int countNumber)\n{\n    List<int> people = new List<int>();\n    for (int i = 1; i <= totalPeople; i++)\n    {\n        people.Add(i);\n    }\n\n    int index = 0;\n    while (people.Count > 1)\n    {\n        index = (index + countNumber - 1) % people.Count;\n        people.RemoveAt(index);\n    }\n\n    return people[0];\n}\n\nC# kodunun işlevselliğini açıklayan en fazla 500 karakterlik özlü bir açıklama (docstring) sağlayın.",
      "vi": "static int LastRemainingPerson(int totalPeople, int countNumber)\n{\n    List<int> people = new List<int>();\n    for (int i = 1; i <= totalPeople; i++)\n    {\n        people.Add(i);\n    }\n\n    int index = 0;\n    while (people.Count > 1)\n    {\n        index = (index + countNumber - 1) % people.Count;\n        people.RemoveAt(index);\n    }\n\n    return people[0];\n}\n\nCung cấp mô tả ngắn gọn bằng ngôn ngữ tự nhiên (docstring) cho mã C# bằng tiếng Việt với tối đa 500 ký tự."
    },
    "instruction_bertscore": {
      "es": "0.9702167647764858",
      "arb": "0.8829437397396628",
      "sw": "0.9446027812508938",
      "tr": "0.840984660789091",
      "vi": "0.9258024156859417"
    },
    "level": "",
    "test": "static void Main()\n    {\n        Debug.Assert(LastRemainingPerson(5, 2) == 3);\n        Debug.Assert(LastRemainingPerson(6, 4) == 5);\n        Debug.Assert(LastRemainingPerson(10, 3) == 4);\n        Debug.Assert(LastRemainingPerson(7, 2) == 7);\n\n    }\n}",
    "entry_point": "LastRemainingPerson",
    "signature": "static int LastRemainingPerson(int totalPeople, int countNumber)",
    "docstring": {
      "es": "Determinar el número de la última persona restante en un juego de conteo circular.\n   En este juego, las personas están numeradas del 1 al totalPeople y se sientan en un círculo.\n   Comenzando con la primera persona, cuentan del 1 al countNumber.\n   La persona que está en countNumber es eliminada del círculo,\n   y el conteo se reanuda desde la siguiente persona.\n   Este proceso continúa hasta que solo queda una persona.\n\n   Ejemplo:\n   >>> LastRemainingPerson(5, 2)\n   3\n   >>> LastRemainingPerson(6, 4)\n   5",
      "arb": "تحديد رقم الشخص الأخير المتبقي في لعبة العد الدائرية.\n   في هذه اللعبة، يتم ترقيم الأشخاص من 1 إلى totalPeople ويجلسون في دائرة.\n   بدءًا من الشخص الأول، يقومون بالعد من 1 إلى countNumber.\n   الشخص الذي يكون عند countNumber يتم إزالته من الدائرة،\n   ويستأنف العد من الشخص التالي.\n   تستمر هذه العملية حتى يبقى شخص واحد فقط.\n\n   مثال:\n   >>> LastRemainingPerson(5, 2)\n   3\n   >>> LastRemainingPerson(6, 4)\n   5",
      "sw": "Amua namba ya mtu wa mwisho aliyebaki katika mchezo wa kuhesabu wa mduara.\n   Katika mchezo huu, watu wanapewa namba kutoka 1 hadi totalPeople na wanakaa katika mduara.\n   Kuanzia na mtu wa kwanza, wanahesabu kutoka 1 hadi countNumber.\n   Mtu ambaye yuko kwenye countNumber anaondolewa kwenye mduara,\n   na kuhesabu kunaanza tena kutoka kwa mtu anayefuata.\n   Mchakato huu unaendelea hadi mtu mmoja tu atakapobaki.\n\n   Mfano:\n   >>> LastRemainingPerson(5, 2)\n   3\n   >>> LastRemainingPerson(6, 4)\n   5",
      "tr": "Dairesel bir sayma oyununda son kalan kişinin numarasını belirleyin.\n   Bu oyunda, insanlar 1'den totalPeople'a kadar numaralandırılır ve bir daire şeklinde otururlar.\n   İlk kişiden başlayarak, 1'den countNumber'a kadar sayarlar.\n   countNumber'da olan kişi daireden çıkarılır,\n   ve sayma işlemi bir sonraki kişiden devam eder.\n   Bu süreç sadece bir kişi kalana kadar devam eder.\n\n   Örnek:\n   >>> LastRemainingPerson(5, 2)\n   3\n   >>> LastRemainingPerson(6, 4)\n   5",
      "vi": "Xác định số của người còn lại cuối cùng trong một trò chơi đếm vòng tròn.\n   Trong trò chơi này, mọi người được đánh số từ 1 đến totalPeople và ngồi thành một vòng tròn.\n   Bắt đầu với người đầu tiên, họ đếm từ 1 đến countNumber.\n   Người ở vị trí countNumber sẽ bị loại khỏi vòng tròn,\n   và việc đếm tiếp tục từ người kế tiếp.\n   Quá trình này tiếp tục cho đến khi chỉ còn lại một người.\n\n   Ví dụ:\n   >>> LastRemainingPerson(5, 2)\n   3\n   >>> LastRemainingPerson(6, 4)\n   5"
    },
    "docstring_bertscore": {
      "es": "0.9900877480952159",
      "arb": "0.9816912446281092",
      "sw": "0.9730116928680277",
      "tr": "0.9902549948760474",
      "vi": "0.9629357695292708"
    }
  },
  {
    "task_id": "C#/35",
    "prompt": {
      "es": "using System;\nusing System.Collections.Generic;\nusing System.Diagnostics;\nusing System.Numerics;\nclass Program\n{\n\n/* Determina el número mínimo de pasos necesarios para convertir un número en un palíndromo en una base dada (de 2 a 16). \n   La función toma un entero que representa la base y una cadena que representa el número en esa base. \n   Un palíndromo es un número que se lee igual hacia adelante y hacia atrás en la misma base.\n   Calcula el número de pasos necesarios para alcanzar un palíndromo sumando repetidamente el número a su reverso en la base dada.\n   Si no se obtiene un palíndromo dentro de 30 pasos, devuelve \"¡Imposible!\".\n\n   Casos de ejemplo:\n   >>> StepsToPalindrome(10, \"56\")  // En base 10, \"56\" se convierte en el palíndromo \"121\" en 1 paso\n   \"STEP=1\"\n   >>> StepsToPalindrome(9, \"87\")   // En base 9, \"87\" se convierte en el palíndromo \"4884\" en 6 pasos\n   \"STEP=6\"\n   >>> StepsToPalindrome(2, \"1001\") \n   \"STEP=0\"\n\n*/\n    public static string StepsToPalindrome(int baseNum, string num)",
      "arb": "using System;\nusing System.Collections.Generic;\nusing System.Diagnostics;\nusing System.Numerics;\nclass Program\n{\n\n/* يحدد الحد الأدنى لعدد الخطوات المطلوبة لتحويل رقم إلى عدد متناظر في قاعدة معينة (من 2 إلى 16).\n   تأخذ الدالة عددًا صحيحًا يمثل القاعدة وسلسلة تمثل الرقم في تلك القاعدة.\n   العدد المتناظر هو رقم يقرأ بنفس الشكل من الأمام والخلف في نفس القاعدة.\n   يحسب عدد الخطوات المطلوبة للوصول إلى عدد متناظر عن طريق إضافة الرقم إلى عكسه في القاعدة المعطاة بشكل متكرر.\n   إذا لم يتم الحصول على عدد متناظر خلال 30 خطوة، فإنه يعيد \"مستحيل!\".\n\n   أمثلة الحالات:\n   >>> StepsToPalindrome(10, \"56\")  // في القاعدة 10، \"56\" يصبح العدد المتناظر \"121\" في خطوة واحدة\n   \"STEP=1\"\n   >>> StepsToPalindrome(9, \"87\")   // في القاعدة 9، \"87\" يصبح العدد المتناظر \"4884\" في 6 خطوات\n   \"STEP=6\"\n   >>> StepsToPalindrome(2, \"1001\") \n   \"STEP=0\"\n\n*/\n    public static string StepsToPalindrome(int baseNum, string num)",
      "sw": "using System;\nusing System.Collections.Generic;\nusing System.Diagnostics;\nusing System.Numerics;\nclass Program\n{\n\n/* Huamua idadi ndogo ya hatua zinazohitajika kubadilisha namba kuwa palindromu katika msingi uliotolewa (kutoka 2 hadi 16). \n   Kazi inachukua nambari nzima inayowakilisha msingi na kamba inayowakilisha nambari katika msingi huo. \n   Palindromu ni namba inayosomwa sawa mbele na nyuma katika msingi huo huo.\n   Inahesabu idadi ya hatua zinazohitajika kufikia palindromu kwa kuongeza namba kwa kinyume chake katika msingi uliotolewa.\n   Ikiwa palindromu haipatikani ndani ya hatua 30, inarudisha \"Haiwezekani!\".\n\n   Mifano ya kesi:\n   >>> StepsToPalindrome(10, \"56\")  // Katika msingi 10, \"56\" inakuwa palindromu \"121\" katika hatua 1\n   \"STEP=1\"\n   >>> StepsToPalindrome(9, \"87\")   // Katika msingi 9, \"87\" inakuwa palindromu \"4884\" katika hatua 6\n   \"STEP=6\"\n   >>> StepsToPalindrome(2, \"1001\") \n   \"STEP=0\"\n\n*/\n    public static string StepsToPalindrome(int baseNum, string num)",
      "tr": "using System;\nusing System.Collections.Generic;\nusing System.Diagnostics;\nusing System.Numerics;\nclass Program\n{\n\n/* Bir sayıyı verilen bir tabanda (2'den 16'ya kadar) palindrom haline getirmek için gereken minimum adım sayısını belirler.\n   Fonksiyon, tabanı temsil eden bir tam sayı ve o tabandaki sayıyı temsil eden bir dize alır.\n   Palindrom, aynı tabanda ileri ve geri okunduğunda aynı olan bir sayıdır.\n   Verilen tabanda sayıya tersini ekleyerek bir palindroma ulaşmak için gereken adım sayısını hesaplar.\n   Eğer 30 adım içinde bir palindrom elde edilmezse, \"Impossible!\" döner.\n\n   Örnek durumlar:\n   >>> StepsToPalindrome(10, \"56\")  // Taban 10'da, \"56\" 1 adımda palindrom \"121\" olur\n   \"STEP=1\"\n   >>> StepsToPalindrome(9, \"87\")   // Taban 9'da, \"87\" 6 adımda palindrom \"4884\" olur\n   \"STEP=6\"\n   >>> StepsToPalindrome(2, \"1001\") \n   \"STEP=0\"\n\n*/\n    public static string StepsToPalindrome(int baseNum, string num)",
      "vi": "using System;\nusing System.Collections.Generic;\nusing System.Diagnostics;\nusing System.Numerics;\nclass Program\n{\n\n/* Xác định số bước tối thiểu cần thiết để chuyển đổi một số thành số đối xứng trong một hệ cơ số cho trước (từ 2 đến 16).\n   Hàm nhận một số nguyên đại diện cho cơ số và một chuỗi đại diện cho số trong cơ số đó.\n   Một số đối xứng là một số đọc giống nhau từ trái sang phải và từ phải sang trái trong cùng một cơ số.\n   Nó tính toán số bước cần thiết để đạt được số đối xứng bằng cách liên tục cộng số đó với số đảo ngược của nó trong cơ số cho trước.\n   Nếu không đạt được số đối xứng trong vòng 30 bước, nó trả về \"Impossible!\".\n\n   Các trường hợp ví dụ:\n   >>> StepsToPalindrome(10, \"56\")  // Trong cơ số 10, \"56\" trở thành số đối xứng \"121\" trong 1 bước\n   \"STEP=1\"\n   >>> StepsToPalindrome(9, \"87\")   // Trong cơ số 9, \"87\" trở thành số đối xứng \"4884\" trong 6 bước\n   \"STEP=6\"\n   >>> StepsToPalindrome(2, \"1001\") \n   \"STEP=0\"\n\n*/\n    public static string StepsToPalindrome(int baseNum, string num)"
    },
    "prompt_bertscore": {
      "es": "0.9886977326887338",
      "arb": "0.9940829995793518",
      "sw": "0.9864575792514224",
      "tr": "0.9791007071986522",
      "vi": "0.9656425057316333"
    },
    "canonical_solution": "    {\n        const int maxSteps = 30;\n        BigInteger originalNumber = ConvertToBase10(num, baseNum);\n\n        if (IsPalindrome(originalNumber, baseNum)){\n            return \"STEP=0\";\n        }\n\n        for (int step = 1; step <= maxSteps; step++)\n        {\n            BigInteger reversed = ReverseNumber(originalNumber, baseNum);\n            BigInteger sum = originalNumber + reversed;\n\n            if (IsPalindrome(sum, baseNum))\n            {\n                \n                Console.WriteLine($\"STEP={step}\");\n                return $\"STEP={step}\";\n            }\n\n            originalNumber = sum;\n        }\n\n        return \"Impossible!\";\n    }\n\n    private static BigInteger ConvertToBase10(string number, int baseNum)\n    {\n        return number\n            .Select(c => \"0123456789ABCDEF\".IndexOf(Char.ToUpper(c)))\n            .Aggregate(new BigInteger(0), (current, digit) => current * baseNum + digit);\n    }\n\n    private static string ConvertFromBase10(BigInteger number, int baseNum)\n    {\n        string result = \"\";\n        while (number > 0)\n        {\n            int remainder = (int)(number % baseNum);\n            result = \"0123456789ABCDEF\"[remainder] + result;\n            number /= baseNum;\n        }\n        return result == \"\" ? \"0\" : result;\n    }\n\n    private static BigInteger ReverseNumber(BigInteger number, int baseNum)\n    {\n        string reversedStr = new string(ConvertFromBase10(number, baseNum).Reverse().ToArray());\n        return ConvertToBase10(reversedStr, baseNum);\n    }\n\n    private static bool IsPalindrome(BigInteger number, int baseNum)\n    {\n        string numStr = ConvertFromBase10(number, baseNum);\n        return numStr.SequenceEqual(numStr.Reverse());\n    }",
    "instruction": {
      "es": "public static string StepsToPalindrome(int baseNum, string num)\n    {\n        const int maxSteps = 30;\n        BigInteger originalNumber = ConvertToBase10(num, baseNum);\n\n        if (IsPalindrome(originalNumber, baseNum)){\n            return \"STEP=0\";\n        }\n\n        for (int step = 1; step <= maxSteps; step++)\n        {\n            BigInteger reversed = ReverseNumber(originalNumber, baseNum);\n            BigInteger sum = originalNumber + reversed;\n\n            if (IsPalindrome(sum, baseNum))\n            {\n                \n                Console.WriteLine($\"STEP={step}\");\n                return $\"STEP={step}\";\n            }\n\n            originalNumber = sum;\n        }\n\n        return \"Impossible!\";\n    }\n\n    private static BigInteger ConvertToBase10(string number, int baseNum)\n    {\n        return number\n            .Select(c => \"0123456789ABCDEF\".IndexOf(Char.ToUpper(c)))\n            .Aggregate(new BigInteger(0), (current, digit) => current * baseNum + digit);\n    }\n\n    private static string ConvertFromBase10(BigInteger number, int baseNum)\n    {\n        string result = \"\";\n        while (number > 0)\n        {\n            int remainder = (int)(number % baseNum);\n            result = \"0123456789ABCDEF\"[remainder] + result;\n            number /= baseNum;\n        }\n        return result == \"\" ? \"0\" : result;\n    }\n\n    private static BigInteger ReverseNumber(BigInteger number, int baseNum)\n    {\n        string reversedStr = new string(ConvertFromBase10(number, baseNum).Reverse().ToArray());\n        return ConvertToBase10(reversedStr, baseNum);\n    }\n\n    private static bool IsPalindrome(BigInteger number, int baseNum)\n    {\n        string numStr = ConvertFromBase10(number, baseNum);\n        return numStr.SequenceEqual(numStr.Reverse());\n    }\n\nProporcione una descripción concisa en lenguaje natural (docstring) del código C# en español utilizando un máximo de 500 caracteres.",
      "arb": "public static string StepsToPalindrome(int baseNum, string num)\n    {\n        const int maxSteps = 30;\n        BigInteger originalNumber = ConvertToBase10(num, baseNum);\n\n        if (IsPalindrome(originalNumber, baseNum)){\n            return \"STEP=0\";\n        }\n\n        for (int step = 1; step <= maxSteps; step++)\n        {\n            BigInteger reversed = ReverseNumber(originalNumber, baseNum);\n            BigInteger sum = originalNumber + reversed;\n\n            if (IsPalindrome(sum, baseNum))\n            {\n                \n                Console.WriteLine($\"STEP={step}\");\n                return $\"STEP={step}\";\n            }\n\n            originalNumber = sum;\n        }\n\n        return \"Impossible!\";\n    }\n\n    private static BigInteger ConvertToBase10(string number, int baseNum)\n    {\n        return number\n            .Select(c => \"0123456789ABCDEF\".IndexOf(Char.ToUpper(c)))\n            .Aggregate(new BigInteger(0), (current, digit) => current * baseNum + digit);\n    }\n\n    private static string ConvertFromBase10(BigInteger number, int baseNum)\n    {\n        string result = \"\";\n        while (number > 0)\n        {\n            int remainder = (int)(number % baseNum);\n            result = \"0123456789ABCDEF\"[remainder] + result;\n            number /= baseNum;\n        }\n        return result == \"\" ? \"0\" : result;\n    }\n\n    private static BigInteger ReverseNumber(BigInteger number, int baseNum)\n    {\n        string reversedStr = new string(ConvertFromBase10(number, baseNum).Reverse().ToArray());\n        return ConvertToBase10(reversedStr, baseNum);\n    }\n\n    private static bool IsPalindrome(BigInteger number, int baseNum)\n    {\n        string numStr = ConvertFromBase10(number, baseNum);\n        return numStr.SequenceEqual(numStr.Reverse());\n    }\n\nيرجى تقديم وصف موجز بلغة طبيعية (docstring) للشفرة البرمجية بلغة C# باللغة العربية الفصحى، بحيث لا يتجاوز 500 حرف.",
      "sw": "public static string StepsToPalindrome(int baseNum, string num)\n    {\n        const int maxSteps = 30;\n        BigInteger originalNumber = ConvertToBase10(num, baseNum);\n\n        if (IsPalindrome(originalNumber, baseNum)){\n            return \"STEP=0\";\n        }\n\n        for (int step = 1; step <= maxSteps; step++)\n        {\n            BigInteger reversed = ReverseNumber(originalNumber, baseNum);\n            BigInteger sum = originalNumber + reversed;\n\n            if (IsPalindrome(sum, baseNum))\n            {\n                \n                Console.WriteLine($\"STEP={step}\");\n                return $\"STEP={step}\";\n            }\n\n            originalNumber = sum;\n        }\n\n        return \"Impossible!\";\n    }\n\n    private static BigInteger ConvertToBase10(string number, int baseNum)\n    {\n        return number\n            .Select(c => \"0123456789ABCDEF\".IndexOf(Char.ToUpper(c)))\n            .Aggregate(new BigInteger(0), (current, digit) => current * baseNum + digit);\n    }\n\n    private static string ConvertFromBase10(BigInteger number, int baseNum)\n    {\n        string result = \"\";\n        while (number > 0)\n        {\n            int remainder = (int)(number % baseNum);\n            result = \"0123456789ABCDEF\"[remainder] + result;\n            number /= baseNum;\n        }\n        return result == \"\" ? \"0\" : result;\n    }\n\n    private static BigInteger ReverseNumber(BigInteger number, int baseNum)\n    {\n        string reversedStr = new string(ConvertFromBase10(number, baseNum).Reverse().ToArray());\n        return ConvertToBase10(reversedStr, baseNum);\n    }\n\n    private static bool IsPalindrome(BigInteger number, int baseNum)\n    {\n        string numStr = ConvertFromBase10(number, baseNum);\n        return numStr.SequenceEqual(numStr.Reverse());\n    }\n\nToa maelezo mafupi ya lugha ya asili (docstring) ya msimbo wa C# kwa Kiswahili kwa kutumia herufi zisizozidi 500.",
      "tr": "public static string StepsToPalindrome(int baseNum, string num)\n    {\n        const int maxSteps = 30;\n        BigInteger originalNumber = ConvertToBase10(num, baseNum);\n\n        if (IsPalindrome(originalNumber, baseNum)){\n            return \"STEP=0\";\n        }\n\n        for (int step = 1; step <= maxSteps; step++)\n        {\n            BigInteger reversed = ReverseNumber(originalNumber, baseNum);\n            BigInteger sum = originalNumber + reversed;\n\n            if (IsPalindrome(sum, baseNum))\n            {\n                \n                Console.WriteLine($\"STEP={step}\");\n                return $\"STEP={step}\";\n            }\n\n            originalNumber = sum;\n        }\n\n        return \"Impossible!\";\n    }\n\n    private static BigInteger ConvertToBase10(string number, int baseNum)\n    {\n        return number\n            .Select(c => \"0123456789ABCDEF\".IndexOf(Char.ToUpper(c)))\n            .Aggregate(new BigInteger(0), (current, digit) => current * baseNum + digit);\n    }\n\n    private static string ConvertFromBase10(BigInteger number, int baseNum)\n    {\n        string result = \"\";\n        while (number > 0)\n        {\n            int remainder = (int)(number % baseNum);\n            result = \"0123456789ABCDEF\"[remainder] + result;\n            number /= baseNum;\n        }\n        return result == \"\" ? \"0\" : result;\n    }\n\n    private static BigInteger ReverseNumber(BigInteger number, int baseNum)\n    {\n        string reversedStr = new string(ConvertFromBase10(number, baseNum).Reverse().ToArray());\n        return ConvertToBase10(reversedStr, baseNum);\n    }\n\n    private static bool IsPalindrome(BigInteger number, int baseNum)\n    {\n        string numStr = ConvertFromBase10(number, baseNum);\n        return numStr.SequenceEqual(numStr.Reverse());\n    }\n\nC# kodunun Türkçe dilinde en fazla 500 karakter kullanarak kısa bir doğal dil açıklamasını (docstring) sağlayın.",
      "vi": "public static string StepsToPalindrome(int baseNum, string num)\n    {\n        const int maxSteps = 30;\n        BigInteger originalNumber = ConvertToBase10(num, baseNum);\n\n        if (IsPalindrome(originalNumber, baseNum)){\n            return \"STEP=0\";\n        }\n\n        for (int step = 1; step <= maxSteps; step++)\n        {\n            BigInteger reversed = ReverseNumber(originalNumber, baseNum);\n            BigInteger sum = originalNumber + reversed;\n\n            if (IsPalindrome(sum, baseNum))\n            {\n                \n                Console.WriteLine($\"STEP={step}\");\n                return $\"STEP={step}\";\n            }\n\n            originalNumber = sum;\n        }\n\n        return \"Impossible!\";\n    }\n\n    private static BigInteger ConvertToBase10(string number, int baseNum)\n    {\n        return number\n            .Select(c => \"0123456789ABCDEF\".IndexOf(Char.ToUpper(c)))\n            .Aggregate(new BigInteger(0), (current, digit) => current * baseNum + digit);\n    }\n\n    private static string ConvertFromBase10(BigInteger number, int baseNum)\n    {\n        string result = \"\";\n        while (number > 0)\n        {\n            int remainder = (int)(number % baseNum);\n            result = \"0123456789ABCDEF\"[remainder] + result;\n            number /= baseNum;\n        }\n        return result == \"\" ? \"0\" : result;\n    }\n\n    private static BigInteger ReverseNumber(BigInteger number, int baseNum)\n    {\n        string reversedStr = new string(ConvertFromBase10(number, baseNum).Reverse().ToArray());\n        return ConvertToBase10(reversedStr, baseNum);\n    }\n\n    private static bool IsPalindrome(BigInteger number, int baseNum)\n    {\n        string numStr = ConvertFromBase10(number, baseNum);\n        return numStr.SequenceEqual(numStr.Reverse());\n    }\n\nCung cấp mô tả ngắn gọn bằng ngôn ngữ tự nhiên (docstring) cho mã C# bằng tiếng Việt, sử dụng tối đa 500 ký tự."
    },
    "instruction_bertscore": {
      "es": "0.9702167647764858",
      "arb": "0.908884072981295",
      "sw": "0.918288824262535",
      "tr": "0.9379850128459545",
      "vi": "0.9298151466436084"
    },
    "level": "",
    "test": "    static void Main()\n    {\n\n        Debug.Assert(StepsToPalindrome(10, \"56\") == \"STEP=1\");\n        Debug.Assert(StepsToPalindrome(9, \"87\") == \"STEP=6\");\n        Debug.Assert(StepsToPalindrome(10, \"87\") == \"STEP=4\");\n        Debug.Assert(StepsToPalindrome(2, \"1001\") == \"STEP=0\"); // Already a palindrome\n        Debug.Assert(StepsToPalindrome(16, \"1A3\") == \"STEP=2\");\n\n\n    }\n}",
    "entry_point": "StepsToPalindrome",
    "signature": "public static string StepsToPalindrome(int baseNum, string num)",
    "docstring": {
      "es": "Determina el número mínimo de pasos necesarios para convertir un número en un palíndromo en una base dada (de 2 a 16). \n   La función toma un entero que representa la base y una cadena que representa el número en esa base. \n   Un palíndromo es un número que se lee igual de adelante hacia atrás en la misma base.\n   Calcula el número de pasos necesarios para alcanzar un palíndromo sumando repetidamente el número a su inverso en la base dada.\n   Si no se obtiene un palíndromo en 30 pasos, devuelve \"¡Imposible!\".\n\n   Casos de ejemplo:\n   >>> StepsToPalindrome(10, \"56\")  // En base 10, \"56\" se convierte en palíndromo \"121\" en 1 paso\n   \"STEP=1\"\n   >>> StepsToPalindrome(9, \"87\")   // En base 9, \"87\" se convierte en palíndromo \"4884\" en 6 pasos\n   \"STEP=6\"\n   >>> StepsToPalindrome(2, \"1001\") \n   \"STEP=0\"",
      "arb": "يحدد الحد الأدنى لعدد الخطوات المطلوبة لتحويل رقم إلى عدد متناظر في قاعدة معينة (من 2 إلى 16). \nتأخذ الدالة عددًا صحيحًا يمثل القاعدة وسلسلة تمثل الرقم في تلك القاعدة. \nالعدد المتناظر هو رقم يقرأ بنفس الطريقة من الأمام والخلف في نفس القاعدة.\nتحسب عدد الخطوات المطلوبة للوصول إلى عدد متناظر عن طريق إضافة الرقم إلى عكسه في القاعدة المعطاة بشكل متكرر.\nإذا لم يتم الحصول على عدد متناظر في غضون 30 خطوة، فإنها تعيد \"مستحيل!\".\n\nحالات المثال:\n>>> StepsToPalindrome(10, \"56\")  // في القاعدة 10، \"56\" يصبح العدد المتناظر \"121\" في خطوة واحدة\n\"STEP=1\"\n>>> StepsToPalindrome(9, \"87\")   // في القاعدة 9، \"87\" يصبح العدد المتناظر \"4884\" في 6 خطوات\n\"STEP=6\"\n>>> StepsToPalindrome(2, \"1001\") \n\"STEP=0\"",
      "sw": "Inabainisha idadi ndogo ya hatua zinazohitajika kubadilisha nambari kuwa palindromu katika msingi uliotolewa (kutoka 2 hadi 16). \n   Kazi inachukua nambari nzima inayowakilisha msingi na kamba inayowakilisha nambari katika msingi huo. \n   Palindromu ni nambari inayosomwa sawa mbele na nyuma katika msingi huo huo.\n   Inahesabu idadi ya hatua zinazohitajika kufikia palindromu kwa kuongeza nambari kwa kinyume chake katika msingi uliotolewa mara kwa mara.\n   Ikiwa palindromu haipatikani ndani ya hatua 30, inarudisha \"Haiwezekani!\".\n\n   Mifano ya kesi:\n   >>> StepsToPalindrome(10, \"56\")  // Katika msingi 10, \"56\" inakuwa palindromu \"121\" katika hatua 1\n   \"STEP=1\"\n   >>> StepsToPalindrome(9, \"87\")   // Katika msingi 9, \"87\" inakuwa palindromu \"4884\" katika hatua 6\n   \"STEP=6\"\n   >>> StepsToPalindrome(2, \"1001\") \n   \"STEP=0\"",
      "tr": "Verilen bir tabanda (2'den 16'ya kadar) bir sayıyı palindroma dönüştürmek için gereken minimum adım sayısını belirler. \n   Fonksiyon, tabanı temsil eden bir tam sayı ve bu tabandaki sayıyı temsil eden bir dize alır. \n   Palindrom, aynı tabanda ileri ve geri okunduğunda aynı olan bir sayıdır.\n   Verilen tabanda sayıyı tersine ekleyerek bir palindroma ulaşmak için gereken adım sayısını hesaplar.\n   Eğer 30 adım içinde bir palindrom elde edilmezse, \"Impossible!\" döner.\n\n   Örnek durumlar:\n   >>> StepsToPalindrome(10, \"56\")  // Taban 10'da, \"56\" 1 adımda palindrom \"121\" olur\n   \"STEP=1\"\n   >>> StepsToPalindrome(9, \"87\")   // Taban 9'da, \"87\" 6 adımda palindrom \"4884\" olur\n   \"STEP=6\"\n   >>> StepsToPalindrome(2, \"1001\") \n   \"STEP=0\"",
      "vi": "Xác định số bước tối thiểu cần thiết để chuyển đổi một số thành một số palindrome trong một cơ số cho trước (từ 2 đến 16). \n   Hàm nhận một số nguyên đại diện cho cơ số và một chuỗi đại diện cho số trong cơ số đó. \n   Một số palindrome là số đọc xuôi hay ngược đều giống nhau trong cùng một cơ số.\n   Nó tính toán số bước cần thiết để đạt được một số palindrome bằng cách liên tục cộng số đó với số đảo ngược của nó trong cơ số cho trước.\n   Nếu không đạt được số palindrome trong vòng 30 bước, nó trả về \"Impossible!\".\n\n   Các trường hợp ví dụ:\n   >>> StepsToPalindrome(10, \"56\")  // Trong cơ số 10, \"56\" trở thành palindrome \"121\" trong 1 bước\n   \"STEP=1\"\n   >>> StepsToPalindrome(9, \"87\")   // Trong cơ số 9, \"87\" trở thành palindrome \"4884\" trong 6 bước\n   \"STEP=6\"\n   >>> StepsToPalindrome(2, \"1001\") \n   \"STEP=0\""
    },
    "docstring_bertscore": {
      "es": "0.9900756316419729",
      "arb": "0.983813411619086",
      "sw": "0.9853329340340028",
      "tr": "0.9848121251749293",
      "vi": "0.9881564649004138"
    }
  },
  {
    "task_id": "C#/36",
    "prompt": {
      "es": "using System;\nusing System.Collections.Generic;\nusing System.Diagnostics;\n\nclass Program\n{\n\n/* Determina si una contraseña dada es segura según criterios específicos.\n   Una contraseña segura debe:\n   1. Tener al menos 8 caracteres y no más de 16 caracteres.\n   2. Incluir caracteres de al menos tres de las siguientes categorías:\n      - Letras mayúsculas (A-Z)\n      - Letras minúsculas (a-z)\n      - Números (0-9)\n      - Símbolos especiales (~, !, @, #, $, %, ^)\n\n   Ejemplos:\n   >>> IsPasswordSecure(\"Password123!\")\n   \"YES\"\n   >>> IsPasswordSecure(\"short\")\n   \"NO\"\n   >>> IsPasswordSecure(\"LongPasswordWithoutNumbersOrSymbols\")\n   \"NO\"\n*/\nstatic string IsPasswordSecure(string password)",
      "arb": "using System;\nusing System.Collections.Generic;\nusing System.Diagnostics;\n\nclass Program\n{\n\n/* يحدد ما إذا كانت كلمة المرور المعطاة آمنة بناءً على معايير محددة.\n   يجب أن تكون كلمة المرور الآمنة:\n   1. لا تقل عن 8 أحرف ولا تزيد عن 16 حرفًا.\n   2. تشمل أحرفًا من ثلاث فئات على الأقل من الفئات التالية:\n      - أحرف كبيرة (A-Z)\n      - أحرف صغيرة (a-z)\n      - أرقام (0-9)\n      - رموز خاصة (~, !, @, #, $, %, ^)\n\n   أمثلة:\n   >>> IsPasswordSecure(\"Password123!\")\n   \"YES\"\n   >>> IsPasswordSecure(\"short\")\n   \"NO\"\n   >>> IsPasswordSecure(\"LongPasswordWithoutNumbersOrSymbols\")\n   \"NO\"\n*/\nstatic string IsPasswordSecure(string password)",
      "sw": "using System;\nusing System.Collections.Generic;\nusing System.Diagnostics;\n\nclass Program\n{\n\n/* Huamua ikiwa nenosiri lililotolewa ni salama kulingana na vigezo maalum.\n   Nenosiri salama lazima:\n   1. Liwe na urefu wa angalau herufi 8 na si zaidi ya herufi 16.\n   2. Lijumuishe herufi kutoka angalau makundi matatu kati ya yafuatayo:\n      - Herufi kubwa (A-Z)\n      - Herufi ndogo (a-z)\n      - Nambari (0-9)\n      - Alama maalum (~, !, @, #, $, %, ^)\n\n   Mifano:\n   >>> IsPasswordSecure(\"Password123!\")\n   \"YES\"\n   >>> IsPasswordSecure(\"short\")\n   \"NO\"\n   >>> IsPasswordSecure(\"LongPasswordWithoutNumbersOrSymbols\")\n   \"NO\"\n*/\nstatic string IsPasswordSecure(string password)",
      "tr": "using System;\nusing System.Collections.Generic;\nusing System.Diagnostics;\n\nclass Program\n{\n\n/* Belirli kriterlere göre verilen bir şifrenin güvenli olup olmadığını belirler.\n   Güvenli bir şifre:\n   1. En az 8 karakter uzunluğunda ve en fazla 16 karakter olmalıdır.\n   2. Aşağıdaki kategorilerden en az üçünden karakterler içermelidir:\n      - Büyük harfler (A-Z)\n      - Küçük harfler (a-z)\n      - Sayılar (0-9)\n      - Özel semboller (~, !, @, #, $, %, ^)\n\n   Örnekler:\n   >>> IsPasswordSecure(\"Password123!\")\n   \"YES\"\n   >>> IsPasswordSecure(\"short\")\n   \"NO\"\n   >>> IsPasswordSecure(\"LongPasswordWithoutNumbersOrSymbols\")\n   \"NO\"\n*/\nstatic string IsPasswordSecure(string password)",
      "vi": "using System;\nusing System.Collections.Generic;\nusing System.Diagnostics;\n\nclass Program\n{\n\n/* Xác định xem một mật khẩu đã cho có an toàn dựa trên các tiêu chí cụ thể hay không.\n   Một mật khẩu an toàn phải:\n   1. Dài ít nhất 8 ký tự và không quá 16 ký tự.\n   2. Bao gồm các ký tự từ ít nhất ba trong số các danh mục sau:\n      - Chữ cái viết hoa (A-Z)\n      - Chữ cái viết thường (a-z)\n      - Số (0-9)\n      - Ký hiệu đặc biệt (~, !, @, #, $, %, ^)\n\n   Ví dụ:\n   >>> IsPasswordSecure(\"Password123!\")\n   \"YES\"\n   >>> IsPasswordSecure(\"short\")\n   \"NO\"\n   >>> IsPasswordSecure(\"LongPasswordWithoutNumbersOrSymbols\")\n   \"NO\"\n*/\nstatic string IsPasswordSecure(string password)"
    },
    "prompt_bertscore": {
      "es": "0.9895905762514856",
      "arb": "0.996111015769718",
      "sw": "0.9812111549971478",
      "tr": "0.984109966777971",
      "vi": "0.9930272791041513"
    },
    "canonical_solution": "{\n    if (password.Length < 8 || password.Length > 16)\n        return \"NO\";\n\n    bool hasUpper = false, hasLower = false, hasDigit = false, hasSymbol = false;\n    foreach (char c in password)\n    {\n        if (char.IsUpper(c)) hasUpper = true;\n        else if (char.IsLower(c)) hasLower = true;\n        else if (char.IsDigit(c)) hasDigit = true;\n        else if (\"~!@#$%^\".Contains(c)) hasSymbol = true;\n    }\n\n    int categories = (hasUpper ? 1 : 0) + (hasLower ? 1 : 0) + (hasDigit ? 1 : 0) + (hasSymbol ? 1 : 0);\n    return categories >= 3 ? \"YES\" : \"NO\";\n}",
    "instruction": {
      "es": "static string IsPasswordSecure(string password)\n{\n    if (password.Length < 8 || password.Length > 16)\n        return \"NO\";\n\n    bool hasUpper = false, hasLower = false, hasDigit = false, hasSymbol = false;\n    foreach (char c in password)\n    {\n        if (char.IsUpper(c)) hasUpper = true;\n        else if (char.IsLower(c)) hasLower = true;\n        else if (char.IsDigit(c)) hasDigit = true;\n        else if (\"~!@#$%^\".Contains(c)) hasSymbol = true;\n    }\n\n    int categories = (hasUpper ? 1 : 0) + (hasLower ? 1 : 0) + (hasDigit ? 1 : 0) + (hasSymbol ? 1 : 0);\n    return categories >= 3 ? \"YES\" : \"NO\";\n}\n\nProporcione una descripción concisa en lenguaje natural (docstring) del código C# en español utilizando como máximo 500 caracteres.",
      "arb": "static string IsPasswordSecure(string password)\n{\n    if (password.Length < 8 || password.Length > 16)\n        return \"NO\";\n\n    bool hasUpper = false, hasLower = false, hasDigit = false, hasSymbol = false;\n    foreach (char c in password)\n    {\n        if (char.IsUpper(c)) hasUpper = true;\n        else if (char.IsLower(c)) hasLower = true;\n        else if (char.IsDigit(c)) hasDigit = true;\n        else if (\"~!@#$%^\".Contains(c)) hasSymbol = true;\n    }\n\n    int categories = (hasUpper ? 1 : 0) + (hasLower ? 1 : 0) + (hasDigit ? 1 : 0) + (hasSymbol ? 1 : 0);\n    return categories >= 3 ? \"YES\" : \"NO\";\n}\n\nيرجى تقديم وصف موجز بلغة طبيعية (docstring) للكود المكتوب بلغة C# باللغة العربية الفصحى، على ألا يتجاوز 500 حرف.",
      "sw": "static string IsPasswordSecure(string password)\n{\n    if (password.Length < 8 || password.Length > 16)\n        return \"NO\";\n\n    bool hasUpper = false, hasLower = false, hasDigit = false, hasSymbol = false;\n    foreach (char c in password)\n    {\n        if (char.IsUpper(c)) hasUpper = true;\n        else if (char.IsLower(c)) hasLower = true;\n        else if (char.IsDigit(c)) hasDigit = true;\n        else if (\"~!@#$%^\".Contains(c)) hasSymbol = true;\n    }\n\n    int categories = (hasUpper ? 1 : 0) + (hasLower ? 1 : 0) + (hasDigit ? 1 : 0) + (hasSymbol ? 1 : 0);\n    return categories >= 3 ? \"YES\" : \"NO\";\n}\n\nToa maelezo mafupi ya lugha ya asili (docstring) ya msimbo wa C# kwa Kiswahili kwa kutumia herufi zisizozidi 500.",
      "tr": "static string IsPasswordSecure(string password)\n{\n    if (password.Length < 8 || password.Length > 16)\n        return \"NO\";\n\n    bool hasUpper = false, hasLower = false, hasDigit = false, hasSymbol = false;\n    foreach (char c in password)\n    {\n        if (char.IsUpper(c)) hasUpper = true;\n        else if (char.IsLower(c)) hasLower = true;\n        else if (char.IsDigit(c)) hasDigit = true;\n        else if (\"~!@#$%^\".Contains(c)) hasSymbol = true;\n    }\n\n    int categories = (hasUpper ? 1 : 0) + (hasLower ? 1 : 0) + (hasDigit ? 1 : 0) + (hasSymbol ? 1 : 0);\n    return categories >= 3 ? \"YES\" : \"NO\";\n}\n\nC# kodunun işlevselliğini açıklayan, en fazla 500 karakter uzunluğunda özlü bir açıklama (docstring) sağlayın.",
      "vi": "static string IsPasswordSecure(string password)\n{\n    if (password.Length < 8 || password.Length > 16)\n        return \"NO\";\n\n    bool hasUpper = false, hasLower = false, hasDigit = false, hasSymbol = false;\n    foreach (char c in password)\n    {\n        if (char.IsUpper(c)) hasUpper = true;\n        else if (char.IsLower(c)) hasLower = true;\n        else if (char.IsDigit(c)) hasDigit = true;\n        else if (\"~!@#$%^\".Contains(c)) hasSymbol = true;\n    }\n\n    int categories = (hasUpper ? 1 : 0) + (hasLower ? 1 : 0) + (hasDigit ? 1 : 0) + (hasSymbol ? 1 : 0);\n    return categories >= 3 ? \"YES\" : \"NO\";\n}\n\nCung cấp mô tả ngắn gọn bằng ngôn ngữ tự nhiên (docstring) cho mã C# bằng tiếng Việt, sử dụng tối đa 500 ký tự."
    },
    "instruction_bertscore": {
      "es": "0.9702167647764858",
      "arb": "0.8716935135882278",
      "sw": "0.918288824262535",
      "tr": "0.8377189786944963",
      "vi": "0.9298151466436084"
    },
    "level": "",
    "test": "    static void Main()\n    {\n\n        Debug.Assert(IsPasswordSecure(\"Password123!\") == \"YES\");\n        Debug.Assert(IsPasswordSecure(\"short\") == \"NO\");\n        Debug.Assert(IsPasswordSecure(\"LongPasswordWithoutNumbersOrSymbols\") == \"NO\");\n        Debug.Assert(IsPasswordSecure(\"Good@Pass1\") == \"YES\");\n        Debug.Assert(IsPasswordSecure(\"1234567890\") == \"NO\");\n\n    }\n}",
    "entry_point": "IsPasswordSecure",
    "signature": "static string IsPasswordSecure(string password)",
    "docstring": {
      "es": "Determina si una contraseña dada es segura según criterios específicos.\n   Una contraseña segura debe:\n   1. Tener al menos 8 caracteres y no más de 16 caracteres.\n   2. Incluir caracteres de al menos tres de las siguientes categorías:\n      - Letras mayúsculas (A-Z)\n      - Letras minúsculas (a-z)\n      - Números (0-9)\n      - Símbolos especiales (~, !, @, #, $, %, ^)\n\n   Ejemplos:\n   >>> IsPasswordSecure(\"Password123!\")\n   \"YES\"\n   >>> IsPasswordSecure(\"short\")\n   \"NO\"\n   >>> IsPasswordSecure(\"LongPasswordWithoutNumbersOrSymbols\")\n   \"NO\"",
      "arb": "يتحقق مما إذا كانت كلمة المرور المعطاة آمنة بناءً على معايير محددة.\n   يجب أن تكون كلمة المرور الآمنة:\n   1. لا تقل عن 8 أحرف ولا تزيد عن 16 حرفًا.\n   2. تتضمن أحرفًا من ثلاث فئات على الأقل من الفئات التالية:\n      - أحرف كبيرة (A-Z)\n      - أحرف صغيرة (a-z)\n      - أرقام (0-9)\n      - رموز خاصة (~, !, @, #, $, %, ^)\n\n   أمثلة:\n   >>> IsPasswordSecure(\"Password123!\")\n   \"YES\"\n   >>> IsPasswordSecure(\"short\")\n   \"NO\"\n   >>> IsPasswordSecure(\"LongPasswordWithoutNumbersOrSymbols\")\n   \"NO\"",
      "sw": "Inabainisha ikiwa nenosiri lililotolewa ni salama kulingana na vigezo maalum.  \n   Nenosiri salama lazima:  \n   1. Liwe na urefu wa angalau herufi 8 na si zaidi ya herufi 16.  \n   2. Lijumuishe herufi kutoka angalau makundi matatu kati ya yafuatayo:  \n      - Herufi kubwa (A-Z)  \n      - Herufi ndogo (a-z)  \n      - Nambari (0-9)  \n      - Alama maalum (~, !, @, #, $, %, ^)  \n\n   Mifano:  \n   >>> IsPasswordSecure(\"Password123!\")  \n   \"YES\"  \n   >>> IsPasswordSecure(\"short\")  \n   \"NO\"  \n   >>> IsPasswordSecure(\"LongPasswordWithoutNumbersOrSymbols\")  \n   \"NO\"  ",
      "tr": "Belirli kriterlere göre verilen bir şifrenin güvenli olup olmadığını belirler.\n   Güvenli bir şifre:\n   1. En az 8 karakter uzunluğunda ve en fazla 16 karakter olmalıdır.\n   2. Aşağıdaki kategorilerden en az üçünden karakterler içermelidir:\n      - Büyük harfler (A-Z)\n      - Küçük harfler (a-z)\n      - Sayılar (0-9)\n      - Özel semboller (~, !, @, #, $, %, ^)\n\n   Örnekler:\n   >>> IsPasswordSecure(\"Password123!\")\n   \"YES\"\n   >>> IsPasswordSecure(\"short\")\n   \"NO\"\n   >>> IsPasswordSecure(\"LongPasswordWithoutNumbersOrSymbols\")\n   \"NO\"",
      "vi": "Xác định xem một mật khẩu cho trước có an toàn dựa trên các tiêu chí cụ thể hay không.\n   Một mật khẩu an toàn phải:\n   1. Có độ dài ít nhất 8 ký tự và không quá 16 ký tự.\n   2. Bao gồm các ký tự từ ít nhất ba trong số các loại sau:\n      - Chữ cái viết hoa (A-Z)\n      - Chữ cái viết thường (a-z)\n      - Số (0-9)\n      - Ký hiệu đặc biệt (~, !, @, #, $, %, ^)\n\n   Ví dụ:\n   >>> IsPasswordSecure(\"Password123!\")\n   \"YES\"\n   >>> IsPasswordSecure(\"short\")\n   \"NO\"\n   >>> IsPasswordSecure(\"LongPasswordWithoutNumbersOrSymbols\")\n   \"NO\""
    },
    "docstring_bertscore": {
      "es": "0.9916736130573985",
      "arb": "0.9721381164522362",
      "sw": "0.9841691586315194",
      "tr": "0.9789330631570587",
      "vi": "0.9897812614172792"
    }
  },
  {
    "task_id": "C#/37",
    "prompt": {
      "es": "using System;\nusing System.Collections.Generic;\nusing System.Diagnostics;\n\nclass Program\n{\n\n\n/* Cuenta el número de formas en que un grupo de niños puede hacer fila para comprar boletos, asegurando que el vendedor de boletos siempre pueda dar cambio.\n   - totalKids: Número total de niños.\n   - oneDollarKids: Número de niños con exactamente 1 dólar.\n   - twoDollarKids: Número de niños con exactamente 2 dólares.\n   El vendedor de boletos no tiene cambio inicialmente, y el boleto cuesta 1 dólar.\n   Diferentes permutaciones de niños con la misma cantidad se consideran arreglos distintos.\n   Ejemplo:\n   >>> CountQueueArrangements(4, 2, 2)\n   8\n\n*/\n    static int CountQueueArrangements(int totalKids, int oneDollarKids, int twoDollarKids)",
      "arb": "using System;\nusing System.Collections.Generic;\nusing System.Diagnostics;\n\nclass Program\n{\n\n\n/* يحسب عدد الطرق التي يمكن لمجموعة من الأطفال الاصطفاف لشراء التذاكر، مع ضمان أن البائع يمكنه دائمًا إعطاء الباقي.\n   - totalKids: العدد الإجمالي للأطفال.\n   - oneDollarKids: عدد الأطفال الذين لديهم دولار واحد بالضبط.\n   - twoDollarKids: عدد الأطفال الذين لديهم دولاران بالضبط.\n   لا يمتلك بائع التذاكر أي فكة في البداية، وتكلفة التذكرة دولار واحد.\n   تعتبر الترتيبات المختلفة للأطفال الذين لديهم نفس المبلغ ترتيبات مميزة.\n   مثال:\n   >>> CountQueueArrangements(4, 2, 2)\n   8\n\n*/\n    static int CountQueueArrangements(int totalKids, int oneDollarKids, int twoDollarKids)",
      "sw": "using System;\nusing System.Collections.Generic;\nusing System.Diagnostics;\n\nclass Program\n{\n\n\n/* Inahesabu idadi ya njia ambazo kundi la watoto linaweza kupanga foleni kununua tiketi, kuhakikisha muuzaji wa tiketi anaweza kila mara kutoa chenji.\n   - totalKids: Jumla ya idadi ya watoto.\n   - oneDollarKids: Idadi ya watoto walio na dola 1 tu.\n   - twoDollarKids: Idadi ya watoto walio na dola 2 tu.\n   Muuzaji wa tiketi hana chenji mwanzoni, na tiketi inagharimu dola 1.\n   Mchanganyiko tofauti wa watoto wenye kiasi sawa huzingatiwa kama mipangilio tofauti.\n   Mfano:\n   >>> CountQueueArrangements(4, 2, 2)\n   8\n\n*/\n    static int CountQueueArrangements(int totalKids, int oneDollarKids, int twoDollarKids)",
      "tr": "using System;\nusing System.Collections.Generic;\nusing System.Diagnostics;\n\nclass Program\n{\n\n\n/* Bir grup çocuğun bilet almak için sıraya girmesinin kaç farklı yolu olduğunu sayar, bilet satıcısının her zaman para üstü verebilmesini sağlar.\n   - totalKids: Toplam çocuk sayısı.\n   - oneDollarKids: Tam olarak 1 doları olan çocuk sayısı.\n   - twoDollarKids: Tam olarak 2 doları olan çocuk sayısı.\n   Bilet satıcısının başlangıçta para üstü yoktur ve bilet 1 dolar tutarındadır.\n   Aynı miktara sahip çocukların farklı permütasyonları farklı düzenlemeler olarak kabul edilir.\n   Örnek:\n   >>> CountQueueArrangements(4, 2, 2)\n   8\n\n*/\n    static int CountQueueArrangements(int totalKids, int oneDollarKids, int twoDollarKids)",
      "vi": "using System;\nusing System.Collections.Generic;\nusing System.Diagnostics;\n\nclass Program\n{\n\n\n/* Đếm số cách mà một nhóm trẻ có thể xếp hàng để mua vé, đảm bảo rằng người bán vé luôn có thể trả lại tiền thừa.\n   - totalKids: Tổng số trẻ.\n   - oneDollarKids: Số trẻ có đúng 1 đô la.\n   - twoDollarKids: Số trẻ có đúng 2 đô la.\n   Người bán vé không có tiền thừa ban đầu, và vé có giá 1 đô la.\n   Các hoán vị khác nhau của trẻ có cùng số tiền được coi là các sắp xếp khác nhau.\n   Ví dụ:\n   >>> CountQueueArrangements(4, 2, 2)\n   8\n\n*/\n    static int CountQueueArrangements(int totalKids, int oneDollarKids, int twoDollarKids)"
    },
    "prompt_bertscore": {
      "es": "0.9896167954617823",
      "arb": "0.9556950962494061",
      "sw": "0.9695243392681981",
      "tr": "0.9874507311565968",
      "vi": "0.9800765782606766"
    },
    "canonical_solution": "    {\n        oneDollarTotal = oneDollarKids;\n        twoDollarTotal = twoDollarKids;\n        permutations = Factorial(oneDollarKids) * Factorial(twoDollarKids);\n        arrangements = 0;\n\n        CountArrangements(totalKids, oneDollarKids, twoDollarKids);\n        return arrangements;\n    }\n\n    static int arrangements = 0, oneDollarTotal, twoDollarTotal, permutations;\n\n\n\n    static void CountArrangements(int n, int oneDollarRemaining, int twoDollarRemaining)\n    {\n        // Check if the arrangement is invalid\n        if ((oneDollarTotal - oneDollarRemaining) < (twoDollarTotal - twoDollarRemaining))\n            return;\n\n        // If no kids are left, add the number of permutations to arrangements\n        if (n == 0)\n        {\n            arrangements += permutations;\n            return;\n        }\n\n        // Choose a one-dollar kid\n        if (oneDollarRemaining > 0)\n            CountArrangements(n - 1, oneDollarRemaining - 1, twoDollarRemaining);\n\n        // Choose a two-dollar kid\n        if (twoDollarRemaining > 0)\n            CountArrangements(n - 1, oneDollarRemaining, twoDollarRemaining - 1);\n    }\n\n\n    static int Factorial(int number)\n    {\n        int result = 1;\n        for (int i = 2; i <= number; i++)\n            result *= i;\n        return result;\n    }\n\n",
    "instruction": {
      "es": "static int CountQueueArrangements(int totalKids, int oneDollarKids, int twoDollarKids)\n    {\n        oneDollarTotal = oneDollarKids;\n        twoDollarTotal = twoDollarKids;\n        permutations = Factorial(oneDollarKids) * Factorial(twoDollarKids);\n        arrangements = 0;\n\n        CountArrangements(totalKids, oneDollarKids, twoDollarKids);\n        return arrangements;\n    }\n\n    static int arrangements = 0, oneDollarTotal, twoDollarTotal, permutations;\n\n\n\n    static void CountArrangements(int n, int oneDollarRemaining, int twoDollarRemaining)\n    {\n        // Check if the arrangement is invalid\n        if ((oneDollarTotal - oneDollarRemaining) < (twoDollarTotal - twoDollarRemaining))\n            return;\n\n        // If no kids are left, add the number of permutations to arrangements\n        if (n == 0)\n        {\n            arrangements += permutations;\n            return;\n        }\n\n        // Choose a one-dollar kid\n        if (oneDollarRemaining > 0)\n            CountArrangements(n - 1, oneDollarRemaining - 1, twoDollarRemaining);\n\n        // Choose a two-dollar kid\n        if (twoDollarRemaining > 0)\n            CountArrangements(n - 1, oneDollarRemaining, twoDollarRemaining - 1);\n    }\n\n\n    static int Factorial(int number)\n    {\n        int result = 1;\n        for (int i = 2; i <= number; i++)\n            result *= i;\n        return result;\n    }\n\n\n\nProporciona una descripción concisa en lenguaje natural (docstring) del código C# en español utilizando un máximo de 500 caracteres.",
      "arb": "static int CountQueueArrangements(int totalKids, int oneDollarKids, int twoDollarKids)\n    {\n        oneDollarTotal = oneDollarKids;\n        twoDollarTotal = twoDollarKids;\n        permutations = Factorial(oneDollarKids) * Factorial(twoDollarKids);\n        arrangements = 0;\n\n        CountArrangements(totalKids, oneDollarKids, twoDollarKids);\n        return arrangements;\n    }\n\n    static int arrangements = 0, oneDollarTotal, twoDollarTotal, permutations;\n\n\n\n    static void CountArrangements(int n, int oneDollarRemaining, int twoDollarRemaining)\n    {\n        // Check if the arrangement is invalid\n        if ((oneDollarTotal - oneDollarRemaining) < (twoDollarTotal - twoDollarRemaining))\n            return;\n\n        // If no kids are left, add the number of permutations to arrangements\n        if (n == 0)\n        {\n            arrangements += permutations;\n            return;\n        }\n\n        // Choose a one-dollar kid\n        if (oneDollarRemaining > 0)\n            CountArrangements(n - 1, oneDollarRemaining - 1, twoDollarRemaining);\n\n        // Choose a two-dollar kid\n        if (twoDollarRemaining > 0)\n            CountArrangements(n - 1, oneDollarRemaining, twoDollarRemaining - 1);\n    }\n\n\n    static int Factorial(int number)\n    {\n        int result = 1;\n        for (int i = 2; i <= number; i++)\n            result *= i;\n        return result;\n    }\n\n\n\nيرجى تقديم وصف موجز بلغة طبيعية (docstring) للكود المكتوب بلغة C# باللغة العربية الفصحى، بحيث لا يتجاوز 500 حرف.",
      "sw": "static int CountQueueArrangements(int totalKids, int oneDollarKids, int twoDollarKids)\n    {\n        oneDollarTotal = oneDollarKids;\n        twoDollarTotal = twoDollarKids;\n        permutations = Factorial(oneDollarKids) * Factorial(twoDollarKids);\n        arrangements = 0;\n\n        CountArrangements(totalKids, oneDollarKids, twoDollarKids);\n        return arrangements;\n    }\n\n    static int arrangements = 0, oneDollarTotal, twoDollarTotal, permutations;\n\n\n\n    static void CountArrangements(int n, int oneDollarRemaining, int twoDollarRemaining)\n    {\n        // Check if the arrangement is invalid\n        if ((oneDollarTotal - oneDollarRemaining) < (twoDollarTotal - twoDollarRemaining))\n            return;\n\n        // If no kids are left, add the number of permutations to arrangements\n        if (n == 0)\n        {\n            arrangements += permutations;\n            return;\n        }\n\n        // Choose a one-dollar kid\n        if (oneDollarRemaining > 0)\n            CountArrangements(n - 1, oneDollarRemaining - 1, twoDollarRemaining);\n\n        // Choose a two-dollar kid\n        if (twoDollarRemaining > 0)\n            CountArrangements(n - 1, oneDollarRemaining, twoDollarRemaining - 1);\n    }\n\n\n    static int Factorial(int number)\n    {\n        int result = 1;\n        for (int i = 2; i <= number; i++)\n            result *= i;\n        return result;\n    }\n\n\n\nToa maelezo mafupi ya lugha ya asili (docstring) ya msimbo wa C# kwa Kiswahili kwa kutumia herufi zisizozidi 500.",
      "tr": "static int CountQueueArrangements(int totalKids, int oneDollarKids, int twoDollarKids)\n    {\n        oneDollarTotal = oneDollarKids;\n        twoDollarTotal = twoDollarKids;\n        permutations = Factorial(oneDollarKids) * Factorial(twoDollarKids);\n        arrangements = 0;\n\n        CountArrangements(totalKids, oneDollarKids, twoDollarKids);\n        return arrangements;\n    }\n\n    static int arrangements = 0, oneDollarTotal, twoDollarTotal, permutations;\n\n\n\n    static void CountArrangements(int n, int oneDollarRemaining, int twoDollarRemaining)\n    {\n        // Check if the arrangement is invalid\n        if ((oneDollarTotal - oneDollarRemaining) < (twoDollarTotal - twoDollarRemaining))\n            return;\n\n        // If no kids are left, add the number of permutations to arrangements\n        if (n == 0)\n        {\n            arrangements += permutations;\n            return;\n        }\n\n        // Choose a one-dollar kid\n        if (oneDollarRemaining > 0)\n            CountArrangements(n - 1, oneDollarRemaining - 1, twoDollarRemaining);\n\n        // Choose a two-dollar kid\n        if (twoDollarRemaining > 0)\n            CountArrangements(n - 1, oneDollarRemaining, twoDollarRemaining - 1);\n    }\n\n\n    static int Factorial(int number)\n    {\n        int result = 1;\n        for (int i = 2; i <= number; i++)\n            result *= i;\n        return result;\n    }\n\n\n\nC# kodunun Türkçe olarak en fazla 500 karakter kullanarak kısa bir doğal dil açıklamasını (docstring) sağlayın.",
      "vi": "static int CountQueueArrangements(int totalKids, int oneDollarKids, int twoDollarKids)\n    {\n        oneDollarTotal = oneDollarKids;\n        twoDollarTotal = twoDollarKids;\n        permutations = Factorial(oneDollarKids) * Factorial(twoDollarKids);\n        arrangements = 0;\n\n        CountArrangements(totalKids, oneDollarKids, twoDollarKids);\n        return arrangements;\n    }\n\n    static int arrangements = 0, oneDollarTotal, twoDollarTotal, permutations;\n\n\n\n    static void CountArrangements(int n, int oneDollarRemaining, int twoDollarRemaining)\n    {\n        // Check if the arrangement is invalid\n        if ((oneDollarTotal - oneDollarRemaining) < (twoDollarTotal - twoDollarRemaining))\n            return;\n\n        // If no kids are left, add the number of permutations to arrangements\n        if (n == 0)\n        {\n            arrangements += permutations;\n            return;\n        }\n\n        // Choose a one-dollar kid\n        if (oneDollarRemaining > 0)\n            CountArrangements(n - 1, oneDollarRemaining - 1, twoDollarRemaining);\n\n        // Choose a two-dollar kid\n        if (twoDollarRemaining > 0)\n            CountArrangements(n - 1, oneDollarRemaining, twoDollarRemaining - 1);\n    }\n\n\n    static int Factorial(int number)\n    {\n        int result = 1;\n        for (int i = 2; i <= number; i++)\n            result *= i;\n        return result;\n    }\n\n\n\nCung cấp mô tả ngắn gọn bằng ngôn ngữ tự nhiên (docstring) cho mã C# bằng tiếng Việt, không quá 500 ký tự."
    },
    "instruction_bertscore": {
      "es": "0.9702167647764858",
      "arb": "0.8829437397396628",
      "sw": "0.918288824262535",
      "tr": "0.941090996114197",
      "vi": "0.9093975325162702"
    },
    "level": "",
    "test": "    static void Main()\n    {\n        Debug.Assert(CountQueueArrangements(4, 2, 2) == 8);\n        Debug.Assert(CountQueueArrangements(5, 3, 2) == 60); // Expected output: True\n        Debug.Assert(CountQueueArrangements(6, 4, 2) == 432); // Expected output: True\n\n    }\n}\n",
    "entry_point": "CountQueueArrangements",
    "signature": "static int CountQueueArrangements(int totalKids, int oneDollarKids, int twoDollarKids)",
    "docstring": {
      "es": "Cuenta el número de formas en que un grupo de niños puede hacer fila para comprar boletos, asegurando que el vendedor de boletos siempre pueda dar cambio.\n   - totalKids: Número total de niños.\n   - oneDollarKids: Número de niños con exactamente 1 dólar.\n   - twoDollarKids: Número de niños con exactamente 2 dólares.\n   El vendedor de boletos no tiene cambio inicialmente, y el boleto cuesta 1 dólar.\n   Diferentes permutaciones de niños con la misma cantidad se consideran arreglos distintos.\n   Ejemplo:\n   >>> CountQueueArrangements(4, 2, 2)\n   8",
      "arb": "يحسب عدد الطرق التي يمكن لمجموعة من الأطفال الاصطفاف فيها لشراء التذاكر، مع ضمان أن البائع يمكنه دائمًا إعطاء الباقي.\n   - totalKids: العدد الإجمالي للأطفال.\n   - oneDollarKids: عدد الأطفال الذين لديهم دولار واحد بالضبط.\n   - twoDollarKids: عدد الأطفال الذين لديهم دولارين بالضبط.\n   البائع ليس لديه أي فكة في البداية، وسعر التذكرة دولار واحد.\n   تعتبر الترتيبات المختلفة للأطفال الذين لديهم نفس المبلغ ترتيبات مميزة.\n   مثال:\n   >>> CountQueueArrangements(4, 2, 2)\n   8",
      "sw": "Hesabu idadi ya njia ambazo kundi la watoto linaweza kupanga foleni kununua tiketi, kuhakikisha kwamba muuzaji wa tiketi anaweza kila mara kutoa chenji.\n   - totalKids: Jumla ya idadi ya watoto.\n   - oneDollarKids: Idadi ya watoto walio na dola 1 tu.\n   - twoDollarKids: Idadi ya watoto walio na dola 2 tu.\n   Muuzaji wa tiketi hana chenji mwanzoni, na tiketi inagharimu dola 1.\n   Mchanganyiko tofauti wa watoto wenye kiasi sawa huzingatiwa kama mipangilio tofauti.\n   Mfano:\n   >>> CountQueueArrangements(4, 2, 2)\n   8",
      "tr": "Çocuk grubunun bilet almak için sıraya girebileceği yolların sayısını sayar, bilet satıcısının her zaman para üstü verebilmesini sağlar.\n   - totalKids: Toplam çocuk sayısı.\n   - oneDollarKids: Tam olarak 1 doları olan çocuk sayısı.\n   - twoDollarKids: Tam olarak 2 doları olan çocuk sayısı.\n   Bilet satıcısının başlangıçta para üstü yoktur ve bilet 1 dolar tutarındadır.\n   Aynı miktarda parası olan çocukların farklı permütasyonları farklı düzenlemeler olarak kabul edilir.\n   Örnek:\n   >>> CountQueueArrangements(4, 2, 2)\n   8",
      "vi": "Đếm số cách một nhóm trẻ có thể xếp hàng để mua vé, đảm bảo rằng người bán vé luôn có thể trả lại tiền thừa.\n   - totalKids: Tổng số trẻ.\n   - oneDollarKids: Số trẻ có đúng 1 đô la.\n   - twoDollarKids: Số trẻ có đúng 2 đô la.\n   Người bán vé không có tiền thừa ban đầu, và vé có giá 1 đô la.\n   Các hoán vị khác nhau của trẻ với cùng số tiền được coi là các sắp xếp khác biệt.\n   Ví dụ:\n   >>> CountQueueArrangements(4, 2, 2)\n   8"
    },
    "docstring_bertscore": {
      "es": "0.9829807530617877",
      "arb": "0.9384601367173899",
      "sw": "0.9584254694671117",
      "tr": "0.9772252391409207",
      "vi": "0.9743595986337305"
    }
  },
  {
    "task_id": "C#/38",
    "prompt": {
      "es": "using System;\nusing System.Collections.Generic;\nusing System.Diagnostics;\n\nclass Program\n{\n\n/* Determina la diferencia absoluta mínima entre elementos de dos arreglos ordenados.\n   Se supone que cada arreglo está ordenado en orden ascendente.\n   Ejemplos:\n   >>> MinArrayDistance(new[] {1, 3, 5}, new[] {2, 4, 6})\n   1\n   >>> MinArrayDistance(new[] {10, 20, 30}, new[] {15, 25, 35})\n   5\n*/\nstatic int MinArrayDistance(int[] array1, int[] array2)",
      "arb": "using System;\nusing System.Collections.Generic;\nusing System.Diagnostics;\n\nclass Program\n{\n\n/* يحدد الحد الأدنى للفارق المطلق بين عناصر مصفوفتين مرتبتين.\n   يُفترض أن تكون كل مصفوفة مرتبة بترتيب تصاعدي.\n   أمثلة:\n   >>> MinArrayDistance(new[] {1, 3, 5}, new[] {2, 4, 6})\n   1\n   >>> MinArrayDistance(new[] {10, 20, 30}, new[] {15, 25, 35})\n   5\n*/\nstatic int MinArrayDistance(int[] array1, int[] array2)",
      "sw": "using System;\nusing System.Collections.Generic;\nusing System.Diagnostics;\n\nclass Program\n{\n\n/* Huamua tofauti ndogo kabisa ya thamani kati ya vipengele vya safu mbili zilizopangwa.\n   Kila safu inadhaniwa kuwa imepangwa kwa mpangilio wa kupanda.\n   Mifano:\n   >>> MinArrayDistance(new[] {1, 3, 5}, new[] {2, 4, 6})\n   1\n   >>> MinArrayDistance(new[] {10, 20, 30}, new[] {15, 25, 35})\n   5\n*/\nstatic int MinArrayDistance(int[] array1, int[] array2)",
      "tr": "using System;\nusing System.Collections.Generic;\nusing System.Diagnostics;\n\nclass Program\n{\n\n/* İki sıralı dizinin elemanları arasındaki minimum mutlak farkı belirler.\n   Her bir dizinin artan sırayla sıralandığı varsayılır.\n   Örnekler:\n   >>> MinArrayDistance(new[] {1, 3, 5}, new[] {2, 4, 6})\n   1\n   >>> MinArrayDistance(new[] {10, 20, 30}, new[] {15, 25, 35})\n   5\n*/\nstatic int MinArrayDistance(int[] array1, int[] array2)",
      "vi": "using System;\nusing System.Collections.Generic;\nusing System.Diagnostics;\n\nclass Program\n{\n\n/* Xác định sự khác biệt tuyệt đối nhỏ nhất giữa các phần tử của hai mảng đã sắp xếp.\n   Mỗi mảng được giả định là sắp xếp theo thứ tự tăng dần.\n   Ví dụ:\n   >>> MinArrayDistance(new[] {1, 3, 5}, new[] {2, 4, 6})\n   1\n   >>> MinArrayDistance(new[] {10, 20, 30}, new[] {15, 25, 35})\n   5\n*/\nstatic int MinArrayDistance(int[] array1, int[] array2)"
    },
    "prompt_bertscore": {
      "es": "0.9917431336907607",
      "arb": "0.9917431336907607",
      "sw": "0.9847513442783327",
      "tr": "0.9852568585980664",
      "vi": "0.9859327977847282"
    },
    "canonical_solution": "{\n    int i = 0, j = 0;\n    int minDistance = int.MaxValue;\n\n    while (i < array1.Length && j < array2.Length)\n    {\n        int diff = Math.Abs(array1[i] - array2[j]);\n        minDistance = Math.Min(minDistance, diff);\n\n        if (array1[i] < array2[j])\n            i++;\n        else\n            j++;\n    }\n\n    return minDistance;\n}",
    "instruction": {
      "es": "static int MinArrayDistance(int[] array1, int[] array2)\n{\n    int i = 0, j = 0;\n    int minDistance = int.MaxValue;\n\n    while (i < array1.Length && j < array2.Length)\n    {\n        int diff = Math.Abs(array1[i] - array2[j]);\n        minDistance = Math.Min(minDistance, diff);\n\n        if (array1[i] < array2[j])\n            i++;\n        else\n            j++;\n    }\n\n    return minDistance;\n}\n\nProporcione una descripción concisa en lenguaje natural (docstring) del código C# en español utilizando un máximo de 500 caracteres.",
      "arb": "static int MinArrayDistance(int[] array1, int[] array2)\n{\n    int i = 0, j = 0;\n    int minDistance = int.MaxValue;\n\n    while (i < array1.Length && j < array2.Length)\n    {\n        int diff = Math.Abs(array1[i] - array2[j]);\n        minDistance = Math.Min(minDistance, diff);\n\n        if (array1[i] < array2[j])\n            i++;\n        else\n            j++;\n    }\n\n    return minDistance;\n}\n\nيرجى تقديم وصف موجز بلغة طبيعية (docstring) للكود المكتوب بلغة C# باللغة العربية الفصحى، بحيث لا يتجاوز 500 حرف.",
      "sw": "static int MinArrayDistance(int[] array1, int[] array2)\n{\n    int i = 0, j = 0;\n    int minDistance = int.MaxValue;\n\n    while (i < array1.Length && j < array2.Length)\n    {\n        int diff = Math.Abs(array1[i] - array2[j]);\n        minDistance = Math.Min(minDistance, diff);\n\n        if (array1[i] < array2[j])\n            i++;\n        else\n            j++;\n    }\n\n    return minDistance;\n}\n\nToa maelezo mafupi ya lugha asilia (docstring) ya msimbo wa C# kwa Kiswahili kwa kutumia herufi zisizozidi 500.",
      "tr": "static int MinArrayDistance(int[] array1, int[] array2)\n{\n    int i = 0, j = 0;\n    int minDistance = int.MaxValue;\n\n    while (i < array1.Length && j < array2.Length)\n    {\n        int diff = Math.Abs(array1[i] - array2[j]);\n        minDistance = Math.Min(minDistance, diff);\n\n        if (array1[i] < array2[j])\n            i++;\n        else\n            j++;\n    }\n\n    return minDistance;\n}\n\nAşağıdaki C# kodunun işlevini açıklayan, en fazla 500 karakter uzunluğunda bir doğal dil açıklaması (docstring) sağlayın.",
      "vi": "static int MinArrayDistance(int[] array1, int[] array2)\n{\n    int i = 0, j = 0;\n    int minDistance = int.MaxValue;\n\n    while (i < array1.Length && j < array2.Length)\n    {\n        int diff = Math.Abs(array1[i] - array2[j]);\n        minDistance = Math.Min(minDistance, diff);\n\n        if (array1[i] < array2[j])\n            i++;\n        else\n            j++;\n    }\n\n    return minDistance;\n}\n\nCung cấp mô tả ngắn gọn bằng ngôn ngữ tự nhiên (docstring) cho mã C# bằng tiếng Việt, sử dụng tối đa 500 ký tự."
    },
    "instruction_bertscore": {
      "es": "0.9702167647764858",
      "arb": "0.8829437397396628",
      "sw": "0.9446027812508938",
      "tr": "0.8333503020940151",
      "vi": "0.912055207014517"
    },
    "level": "",
    "test": "    static void Main()\n    {\n\n        Debug.Assert(MinArrayDistance(new[] {1, 3, 5}, new[] {2, 4, 6}) == 1);\n        Debug.Assert(MinArrayDistance(new[] {10, 20, 30}, new[] {15, 25, 35}) == 5);\n\n    }\n}",
    "entry_point": "MinArrayDistance",
    "signature": "static int MinArrayDistance(int[] array1, int[] array2)",
    "docstring": {
      "es": "Determina la diferencia absoluta mínima entre elementos de dos arreglos ordenados.  \n   Se supone que cada arreglo está ordenado en orden ascendente.  \n   Ejemplos:  \n   >>> MinArrayDistance(new[] {1, 3, 5}, new[] {2, 4, 6})  \n   1  \n   >>> MinArrayDistance(new[] {10, 20, 30}, new[] {15, 25, 35})  \n   5  ",
      "arb": "يحدد الحد الأدنى للفرق المطلق بين عناصر مصفوفتين مرتبتين.\n   يُفترض أن تكون كل مصفوفة مرتبة بترتيب تصاعدي.\n   أمثلة:\n   >>> MinArrayDistance(new[] {1, 3, 5}, new[] {2, 4, 6})\n   1\n   >>> MinArrayDistance(new[] {10, 20, 30}, new[] {15, 25, 35})\n   5",
      "sw": "Inabainisha tofauti ndogo kabisa kati ya vipengele vya safu mbili zilizopangwa.\n   Kila safu inadhaniwa kuwa imepangwa kwa mpangilio wa kupanda.\n   Mifano:\n   >>> MinArrayDistance(new[] {1, 3, 5}, new[] {2, 4, 6})\n   1\n   >>> MinArrayDistance(new[] {10, 20, 30}, new[] {15, 25, 35})\n   5",
      "tr": "İki sıralı dizinin elemanları arasındaki minimum mutlak farkı belirler.\n   Her bir dizinin artan sırayla sıralandığı varsayılır.\n   Örnekler:\n   >>> MinArrayDistance(new[] {1, 3, 5}, new[] {2, 4, 6})\n   1\n   >>> MinArrayDistance(new[] {10, 20, 30}, new[] {15, 25, 35})\n   5",
      "vi": "Xác định sự khác biệt tuyệt đối nhỏ nhất giữa các phần tử của hai mảng đã được sắp xếp.\n   Mỗi mảng được giả định là đã được sắp xếp theo thứ tự tăng dần.\n   Ví dụ:\n   >>> MinArrayDistance(new[] {1, 3, 5}, new[] {2, 4, 6})\n   1\n   >>> MinArrayDistance(new[] {10, 20, 30}, new[] {15, 25, 35})\n   5"
    },
    "docstring_bertscore": {
      "es": "0.9843822890303698",
      "arb": "0.9921795246378944",
      "sw": "0.9649526624182991",
      "tr": "0.9828830269143185",
      "vi": "0.9783945761940731"
    }
  },
  {
    "task_id": "C#/39",
    "prompt": {
      "es": "using System;\nusing System.Collections.Generic;\nusing System.Diagnostics;\n\nclass Program\n{\n\n\n/* Ordena una lista de enteros en orden descendente basado en sus valores absolutos.\n    Ejemplos:\n    >>> SortByAbsoluteDescending(new List<int> { 3, -4, 2 })\n    [-4, 3, 2]\n    >>> SortByAbsoluteDescending(new List<int> { 0, 1, 2, -3 })\n    [-3, 2, 1, 0]\n*/\nstatic List<int> SortByAbsoluteDescending(List<int> numbers)",
      "arb": "using System;\nusing System.Collections.Generic;\nusing System.Diagnostics;\n\nclass Program\n{\n\n\n/* ترتيب قائمة من الأعداد الصحيحة بترتيب تنازلي بناءً على قيمها المطلقة.\n    أمثلة:\n    >>> SortByAbsoluteDescending(new List<int> { 3, -4, 2 })\n    [-4, 3, 2]\n    >>> SortByAbsoluteDescending(new List<int> { 0, 1, 2, -3 })\n    [-3, 2, 1, 0]\n*/\nstatic List<int> SortByAbsoluteDescending(List<int> numbers)",
      "sw": "using System;\nusing System.Collections.Generic;\nusing System.Diagnostics;\n\nclass Program\n{\n\n\n/* Panga orodha ya nambari za mzima kwa mpangilio wa kushuka kulingana na thamani zao kamili.\n    Mifano:\n    >>> SortByAbsoluteDescending(new List<int> { 3, -4, 2 })\n    [-4, 3, 2]\n    >>> SortByAbsoluteDescending(new List<int> { 0, 1, 2, -3 })\n    [-3, 2, 1, 0]\n*/\nstatic List<int> SortByAbsoluteDescending(List<int> numbers)",
      "tr": "using System;\nusing System.Collections.Generic;\nusing System.Diagnostics;\n\nclass Program\n{\n\n\n/* Bir tamsayı listesini mutlak değerlerine göre azalan sırayla sıralayın.\n    Örnekler:\n    >>> SortByAbsoluteDescending(new List<int> { 3, -4, 2 })\n    [-4, 3, 2]\n    >>> SortByAbsoluteDescending(new List<int> { 0, 1, 2, -3 })\n    [-3, 2, 1, 0]\n*/\nstatic List<int> SortByAbsoluteDescending(List<int> numbers)",
      "vi": "using System;\nusing System.Collections.Generic;\nusing System.Diagnostics;\n\nclass Program\n{\n\n\n/* Sắp xếp một danh sách các số nguyên theo thứ tự giảm dần dựa trên giá trị tuyệt đối của chúng.\n    Ví dụ:\n    >>> SortByAbsoluteDescending(new List<int> { 3, -4, 2 })\n    [-4, 3, 2]\n    >>> SortByAbsoluteDescending(new List<int> { 0, 1, 2, -3 })\n    [-3, 2, 1, 0]\n*/\nstatic List<int> SortByAbsoluteDescending(List<int> numbers)"
    },
    "prompt_bertscore": {
      "es": "0.9953210627443422",
      "arb": "0.999999801369619",
      "sw": "0.999999801369619",
      "tr": "0.999999801369619",
      "vi": "0.9989438822640375"
    },
    "canonical_solution": "{\n    numbers.Sort((a, b) => Math.Abs(b).CompareTo(Math.Abs(a)));\n    return numbers;\n}",
    "instruction": {
      "es": "static List<int> SortByAbsoluteDescending(List<int> numbers)\n{\n    numbers.Sort((a, b) => Math.Abs(b).CompareTo(Math.Abs(a)));\n    return numbers;\n}\n\nProporcione una descripción concisa en lenguaje natural (docstring) del código C# en español utilizando como máximo 500 caracteres.",
      "arb": "static List<int> SortByAbsoluteDescending(List<int> numbers)\n{\n    numbers.Sort((a, b) => Math.Abs(b).CompareTo(Math.Abs(a)));\n    return numbers;\n}\n\nيرجى تقديم وصف موجز بلغة طبيعية (docstring) للكود المكتوب بلغة C# باللغة العربية الفصحى، بحيث لا يتجاوز 500 حرف.",
      "sw": "static List<int> SortByAbsoluteDescending(List<int> numbers)\n{\n    numbers.Sort((a, b) => Math.Abs(b).CompareTo(Math.Abs(a)));\n    return numbers;\n}\n\nToa maelezo mafupi ya lugha asilia (docstring) ya msimbo wa C# kwa Kiswahili kwa kutumia herufi zisizozidi 500.",
      "tr": "static List<int> SortByAbsoluteDescending(List<int> numbers)\n{\n    numbers.Sort((a, b) => Math.Abs(b).CompareTo(Math.Abs(a)));\n    return numbers;\n}\n\nAşağıdaki C# kodunun işlevini en fazla 500 karakter kullanarak Türkçe bir doğal dil açıklaması (docstring) sağlayın.",
      "vi": "static List<int> SortByAbsoluteDescending(List<int> numbers)\n{\n    numbers.Sort((a, b) => Math.Abs(b).CompareTo(Math.Abs(a)));\n    return numbers;\n}\n\nCung cấp mô tả ngắn gọn bằng ngôn ngữ tự nhiên (docstring) cho mã C# bằng tiếng Việt, sử dụng tối đa 500 ký tự."
    },
    "instruction_bertscore": {
      "es": "0.9702167647764858",
      "arb": "0.8829437397396628",
      "sw": "0.9446027812508938",
      "tr": "0.8667200074774952",
      "vi": "0.9298151466436084"
    },
    "level": "",
    "test": "    static void Main()\n    {\n        Debug.Assert(SortByAbsoluteDescending(new List<int> { 3, -4, 2 }).SequenceEqual(new List<int> { -4, 3, 2 }));\n        Debug.Assert(SortByAbsoluteDescending(new List<int> { 0, 1, 2, -3 }).SequenceEqual(new List<int> { -3, 2, 1, 0 }));\n\n\n    }\n}",
    "entry_point": "SortByAbsoluteDescending",
    "signature": "static List<int> SortByAbsoluteDescending(List<int> numbers)",
    "docstring": {
      "es": "Ordenar una lista de enteros en orden descendente basado en sus valores absolutos.\n    Ejemplos:\n    >>> SortByAbsoluteDescending(new List<int> { 3, -4, 2 })\n    [-4, 3, 2]\n    >>> SortByAbsoluteDescending(new List<int> { 0, 1, 2, -3 })\n    [-3, 2, 1, 0]",
      "arb": "فرز قائمة من الأعداد الصحيحة بترتيب تنازلي بناءً على قيمها المطلقة.\n    أمثلة:\n    >>> SortByAbsoluteDescending(new List<int> { 3, -4, 2 })\n    [-4, 3, 2]\n    >>> SortByAbsoluteDescending(new List<int> { 0, 1, 2, -3 })\n    [-3, 2, 1, 0]",
      "sw": "Panga orodha ya nambari nzima kwa mpangilio wa kushuka kulingana na thamani zao kamili. \n    Mifano:\n    >>> SortByAbsoluteDescending(new List<int> { 3, -4, 2 })\n    [-4, 3, 2]\n    >>> SortByAbsoluteDescending(new List<int> { 0, 1, 2, -3 })\n    [-3, 2, 1, 0]",
      "tr": "Mutlak değerlerine göre azalan sırayla bir tamsayı listesini sıralayın.\n    Örnekler:\n    >>> SortByAbsoluteDescending(new List<int> { 3, -4, 2 })\n    [-4, 3, 2]\n    >>> SortByAbsoluteDescending(new List<int> { 0, 1, 2, -3 })\n    [-3, 2, 1, 0]",
      "vi": "Sắp xếp một danh sách các số nguyên theo thứ tự giảm dần dựa trên giá trị tuyệt đối của chúng.\n    Ví dụ:\n    >>> SortByAbsoluteDescending(new List<int> { 3, -4, 2 })\n    [-4, 3, 2]\n    >>> SortByAbsoluteDescending(new List<int> { 0, 1, 2, -3 })\n    [-3, 2, 1, 0]"
    },
    "docstring_bertscore": {
      "es": "1",
      "arb": "1",
      "sw": "1",
      "tr": "0.9926039977621659",
      "vi": "0.9981149976839789"
    }
  },
  {
    "task_id": "C#/40",
    "prompt": {
      "es": "using System;\nusing System.Collections.Generic;\nusing System.Diagnostics;\n\nclass Program\n{\n\n\n/* Calcula el valor total máximo de compras dentro de un presupuesto, considerando artículos principales y sus accesorios.\n    - `totalMoney` es el presupuesto total.\n    - `items` es una lista de tuplas, donde cada tupla representa un artículo con su precio, importancia y categoría (0 para artículos principales, número de artículo del artículo principal si es un accesorio).\n    Por ejemplo:\n    >>> MaxValueOfPurchases(1000, new List<(int, int, int)> { (800, 2, 0), (400, 5, 1), (300, 5, 1), (400, 3, 0), (500, 2, 0) })\n    2200\n    >>> MaxValueOfPurchases(500, new List<(int, int, int)> { (300, 3, 0), (200, 4, 1), (100, 2, 0) })\n    1700\n*/\npublic static int MaxValueOfPurchases(int totalMoney, List<(int price, int importance, int category)> items)",
      "arb": "using System;\nusing System.Collections.Generic;\nusing System.Diagnostics;\n\nclass Program\n{\n\n\n/* يحسب القيمة الإجمالية القصوى للمشتريات ضمن الميزانية، مع الأخذ في الاعتبار العناصر الرئيسية وملحقاتها.\n    - `totalMoney` هو إجمالي الميزانية.\n    - `items` هي قائمة من الأزواج، حيث يمثل كل زوج عنصرًا مع سعره، أهميته، وفئته (0 للعناصر الرئيسية، رقم العنصر الرئيسي إذا كان ملحقًا).\n    على سبيل المثال:\n    >>> MaxValueOfPurchases(1000, new List<(int, int, int)> { (800, 2, 0), (400, 5, 1), (300, 5, 1), (400, 3, 0), (500, 2, 0) })\n    2200\n    >>> MaxValueOfPurchases(500, new List<(int, int, int)> { (300, 3, 0), (200, 4, 1), (100, 2, 0) })\n    1700\n*/\npublic static int MaxValueOfPurchases(int totalMoney, List<(int price, int importance, int category)> items)",
      "sw": "using System;\nusing System.Collections.Generic;\nusing System.Diagnostics;\n\nclass Program\n{\n\n\n/* Inakokotoa thamani ya juu kabisa ya manunuzi ndani ya bajeti, ikizingatia vitu vikuu na vifaa vya ziada.\n    - `totalMoney` ni jumla ya bajeti.\n    - `items` ni orodha ya jozi, ambapo kila jozi inawakilisha kipengee na bei yake, umuhimu, na aina (0 kwa vitu vikuu, nambari ya kipengee cha msingi ikiwa ni kifaa cha ziada).\n    Kwa mfano:\n    >>> MaxValueOfPurchases(1000, new List<(int, int, int)> { (800, 2, 0), (400, 5, 1), (300, 5, 1), (400, 3, 0), (500, 2, 0) })\n    2200\n    >>> MaxValueOfPurchases(500, new List<(int, int, int)> { (300, 3, 0), (200, 4, 1), (100, 2, 0) })\n    1700\n*/\npublic static int MaxValueOfPurchases(int totalMoney, List<(int price, int importance, int category)> items)",
      "tr": "using System;\nusing System.Collections.Generic;\nusing System.Diagnostics;\n\nclass Program\n{\n\n\n/* Bir bütçe dahilinde, ana ürünler ve bunların aksesuarlarını dikkate alarak satın alımların maksimum toplam değerini hesaplar.\n    - `totalMoney` toplam bütçedir.\n    - `items`, her bir demetin bir ürünün fiyatını, önemini ve kategorisini temsil ettiği bir demet listesidir (0 ana ürünler için, bir aksesuar ise ana ürünün numarası).\n    Örneğin:\n    >>> MaxValueOfPurchases(1000, new List<(int, int, int)> { (800, 2, 0), (400, 5, 1), (300, 5, 1), (400, 3, 0), (500, 2, 0) })\n    2200\n    >>> MaxValueOfPurchases(500, new List<(int, int, int)> { (300, 3, 0), (200, 4, 1), (100, 2, 0) })\n    1700\n*/\npublic static int MaxValueOfPurchases(int totalMoney, List<(int price, int importance, int category)> items)",
      "vi": "using System;\nusing System.Collections.Generic;\nusing System.Diagnostics;\n\nclass Program\n{\n\n\n/* Tính toán tổng giá trị tối đa của các giao dịch mua trong một ngân sách, xem xét các mặt hàng chính và phụ kiện của chúng.\n    - `totalMoney` là tổng ngân sách.\n    - `items` là danh sách các bộ giá trị, trong đó mỗi bộ giá trị đại diện cho một mặt hàng với giá của nó, tầm quan trọng, và loại (0 cho mặt hàng chính, số thứ tự của mặt hàng chính nếu là phụ kiện).\n    Ví dụ:\n    >>> MaxValueOfPurchases(1000, new List<(int, int, int)> { (800, 2, 0), (400, 5, 1), (300, 5, 1), (400, 3, 0), (500, 2, 0) })\n    2200\n    >>> MaxValueOfPurchases(500, new List<(int, int, int)> { (300, 3, 0), (200, 4, 1), (100, 2, 0) })\n    1700\n*/\npublic static int MaxValueOfPurchases(int totalMoney, List<(int price, int importance, int category)> items)"
    },
    "prompt_bertscore": {
      "es": "0.9922411000560152",
      "arb": "0.9876177793070472",
      "sw": "0.9867507576938298",
      "tr": "0.978336774753192",
      "vi": "0.9806025515096569"
    },
    "canonical_solution": "{\n    int[] dp = new int[totalMoney + 1];\n    foreach (var item in items.Where(i => i.category == 0))\n    {\n        var accessories = items.Where(i => i.category == items.IndexOf(item) + 1).ToList();\n        for (int j = totalMoney; j >= item.price; j--)\n        {\n            dp[j] = Math.Max(dp[j], dp[j - item.price] + item.price * item.importance);\n            foreach (var accessory in accessories)\n            {\n                if (j >= item.price + accessory.price)\n                {\n                    dp[j] = Math.Max(dp[j], dp[j - item.price - accessory.price] + item.price * item.importance + accessory.price * accessory.importance);\n                }\n            }\n        }\n    }\n    return dp[totalMoney];\n}",
    "instruction": {
      "es": "public static int MaxValueOfPurchases(int totalMoney, List<(int price, int importance, int category)> items)\n{\n    int[] dp = new int[totalMoney + 1];\n    foreach (var item in items.Where(i => i.category == 0))\n    {\n        var accessories = items.Where(i => i.category == items.IndexOf(item) + 1).ToList();\n        for (int j = totalMoney; j >= item.price; j--)\n        {\n            dp[j] = Math.Max(dp[j], dp[j - item.price] + item.price * item.importance);\n            foreach (var accessory in accessories)\n            {\n                if (j >= item.price + accessory.price)\n                {\n                    dp[j] = Math.Max(dp[j], dp[j - item.price - accessory.price] + item.price * item.importance + accessory.price * accessory.importance);\n                }\n            }\n        }\n    }\n    return dp[totalMoney];\n}\n\nProporcione una descripción concisa en lenguaje natural (docstring) del código C# en español utilizando como máximo 500 caracteres.",
      "arb": "public static int MaxValueOfPurchases(int totalMoney, List<(int price, int importance, int category)> items)\n{\n    int[] dp = new int[totalMoney + 1];\n    foreach (var item in items.Where(i => i.category == 0))\n    {\n        var accessories = items.Where(i => i.category == items.IndexOf(item) + 1).ToList();\n        for (int j = totalMoney; j >= item.price; j--)\n        {\n            dp[j] = Math.Max(dp[j], dp[j - item.price] + item.price * item.importance);\n            foreach (var accessory in accessories)\n            {\n                if (j >= item.price + accessory.price)\n                {\n                    dp[j] = Math.Max(dp[j], dp[j - item.price - accessory.price] + item.price * item.importance + accessory.price * accessory.importance);\n                }\n            }\n        }\n    }\n    return dp[totalMoney];\n}\n\nيرجى تقديم وصف موجز بلغة طبيعية (docstring) للكود المكتوب بلغة C# باللغة العربية الفصحى، بحيث لا يتجاوز 500 حرف.",
      "sw": "public static int MaxValueOfPurchases(int totalMoney, List<(int price, int importance, int category)> items)\n{\n    int[] dp = new int[totalMoney + 1];\n    foreach (var item in items.Where(i => i.category == 0))\n    {\n        var accessories = items.Where(i => i.category == items.IndexOf(item) + 1).ToList();\n        for (int j = totalMoney; j >= item.price; j--)\n        {\n            dp[j] = Math.Max(dp[j], dp[j - item.price] + item.price * item.importance);\n            foreach (var accessory in accessories)\n            {\n                if (j >= item.price + accessory.price)\n                {\n                    dp[j] = Math.Max(dp[j], dp[j - item.price - accessory.price] + item.price * item.importance + accessory.price * accessory.importance);\n                }\n            }\n        }\n    }\n    return dp[totalMoney];\n}\n\nToa maelezo mafupi ya lugha asilia (docstring) ya msimbo wa C# kwa Kiswahili kwa kutumia herufi zisizozidi 500.",
      "tr": "public static int MaxValueOfPurchases(int totalMoney, List<(int price, int importance, int category)> items)\n{\n    int[] dp = new int[totalMoney + 1];\n    foreach (var item in items.Where(i => i.category == 0))\n    {\n        var accessories = items.Where(i => i.category == items.IndexOf(item) + 1).ToList();\n        for (int j = totalMoney; j >= item.price; j--)\n        {\n            dp[j] = Math.Max(dp[j], dp[j - item.price] + item.price * item.importance);\n            foreach (var accessory in accessories)\n            {\n                if (j >= item.price + accessory.price)\n                {\n                    dp[j] = Math.Max(dp[j], dp[j - item.price - accessory.price] + item.price * item.importance + accessory.price * accessory.importance);\n                }\n            }\n        }\n    }\n    return dp[totalMoney];\n}\n\nC# kodunun Türkçe olarak en fazla 500 karakter kullanarak doğal dilde kısa bir açıklamasını (docstring) sağlayın.",
      "vi": "public static int MaxValueOfPurchases(int totalMoney, List<(int price, int importance, int category)> items)\n{\n    int[] dp = new int[totalMoney + 1];\n    foreach (var item in items.Where(i => i.category == 0))\n    {\n        var accessories = items.Where(i => i.category == items.IndexOf(item) + 1).ToList();\n        for (int j = totalMoney; j >= item.price; j--)\n        {\n            dp[j] = Math.Max(dp[j], dp[j - item.price] + item.price * item.importance);\n            foreach (var accessory in accessories)\n            {\n                if (j >= item.price + accessory.price)\n                {\n                    dp[j] = Math.Max(dp[j], dp[j - item.price - accessory.price] + item.price * item.importance + accessory.price * accessory.importance);\n                }\n            }\n        }\n    }\n    return dp[totalMoney];\n}\n\nCung cấp mô tả ngắn gọn bằng ngôn ngữ tự nhiên (docstring) cho mã C# bằng tiếng Việt, không quá 500 ký tự."
    },
    "instruction_bertscore": {
      "es": "0.9702167647764858",
      "arb": "0.8829437397396628",
      "sw": "0.9446027812508938",
      "tr": "0.8978134086943156",
      "vi": "0.8888496168589731"
    },
    "level": "",
    "test": "    static void Main()\n    {\n\n        Debug.Assert(MaxValueOfPurchases(1000, new List<(int, int, int)> { (800, 2, 0), (400, 5, 1), (300, 5, 1), (400, 3, 0), (500, 2, 0) }) == 2200);\n        Debug.Assert(MaxValueOfPurchases(500, new List<(int, int, int)> { (300, 3, 0), (200, 4, 1), (100, 2, 0) }) == 1700);\n\n    }\n}\n",
    "entry_point": "MaxValueOfPurchases",
    "signature": "public static int MaxValueOfPurchases(int totalMoney, List<(int price, int importance, int category)> items)",
    "docstring": {
      "es": "Calcula el valor total máximo de compras dentro de un presupuesto, considerando artículos principales y sus accesorios.\n    - `totalMoney` es el presupuesto total.\n    - `items` es una lista de tuplas, donde cada tupla representa un artículo con su precio, importancia y categoría (0 para artículos principales, número de artículo del artículo principal si es un accesorio).\n    Por ejemplo:\n    >>> MaxValueOfPurchases(1000, new List<(int, int, int)> { (800, 2, 0), (400, 5, 1), (300, 5, 1), (400, 3, 0), (500, 2, 0) })\n    2200\n    >>> MaxValueOfPurchases(500, new List<(int, int, int)> { (300, 3, 0), (200, 4, 1), (100, 2, 0) })\n    1700",
      "arb": "يحسب القيمة الإجمالية القصوى للمشتريات ضمن الميزانية، مع الأخذ في الاعتبار العناصر الرئيسية وملحقاتها.\n- `totalMoney` هو إجمالي الميزانية.\n- `items` هي قائمة من الأزواج، حيث يمثل كل زوج عنصرًا مع سعره وأهميته وفئته (0 للعناصر الرئيسية، رقم العنصر الرئيسي إذا كان ملحقًا).\nعلى سبيل المثال:\n>>> MaxValueOfPurchases(1000, new List<(int, int, int)> { (800, 2, 0), (400, 5, 1), (300, 5, 1), (400, 3, 0), (500, 2, 0) })\n2200\n>>> MaxValueOfPurchases(500, new List<(int, int, int)> { (300, 3, 0), (200, 4, 1), (100, 2, 0) })\n1700",
      "sw": "Huhesabu thamani ya juu kabisa ya manunuzi ndani ya bajeti, kwa kuzingatia vitu vikuu na vifaa vyake.\n- `totalMoney` ni jumla ya bajeti.\n- `items` ni orodha ya jozi, ambapo kila jozi inawakilisha kipengee na bei yake, umuhimu, na kategoria (0 kwa vitu vikuu, namba ya kipengee kikuu ikiwa ni kifaa).\nKwa mfano:\n>>> MaxValueOfPurchases(1000, new List<(int, int, int)> { (800, 2, 0), (400, 5, 1), (300, 5, 1), (400, 3, 0), (500, 2, 0) })\n2200\n>>> MaxValueOfPurchases(500, new List<(int, int, int)> { (300, 3, 0), (200, 4, 1), (100, 2, 0) })\n1700",
      "tr": "Satın alımların maksimum toplam değerini, ana ürünler ve bunların aksesuarlarını dikkate alarak bir bütçe dahilinde hesaplar.\n- `totalMoney` toplam bütçedir.\n- `items`, her bir demetin fiyat, önem ve kategori (ana ürünler için 0, bir aksesuar ise ana ürünün ürün numarası) ile bir ürünü temsil ettiği demetlerin bir listesidir.\nÖrneğin:\n>>> MaxValueOfPurchases(1000, new List<(int, int, int)> { (800, 2, 0), (400, 5, 1), (300, 5, 1), (400, 3, 0), (500, 2, 0) })\n2200\n>>> MaxValueOfPurchases(500, new List<(int, int, int)> { (300, 3, 0), (200, 4, 1), (100, 2, 0) })\n1700",
      "vi": "Tính toán giá trị tổng tối đa của các lần mua hàng trong một ngân sách, xem xét các mặt hàng chính và phụ kiện của chúng.\n- `totalMoney` là tổng ngân sách.\n- `items` là một danh sách các bộ ba, trong đó mỗi bộ ba đại diện cho một mặt hàng với giá của nó, tầm quan trọng, và loại (0 cho các mặt hàng chính, số thứ tự của mặt hàng chính nếu là phụ kiện).\nVí dụ:\n>>> MaxValueOfPurchases(1000, new List<(int, int, int)> { (800, 2, 0), (400, 5, 1), (300, 5, 1), (400, 3, 0), (500, 2, 0) })\n2200\n>>> MaxValueOfPurchases(500, new List<(int, int, int)> { (300, 3, 0), (200, 4, 1), (100, 2, 0) })\n1700"
    },
    "docstring_bertscore": {
      "es": "0.9901560769462919",
      "arb": "0.9751213461449992",
      "sw": "0.989797747738905",
      "tr": "0.9656188687162902",
      "vi": "0.9752351613533322"
    }
  },
  {
    "task_id": "C#/41",
    "prompt": {
      "es": "using System;\nusing System.Collections.Generic;\nusing System.Diagnostics;\n\nclass Program\n{\n\n/* Calcula el número total de cigarrillos que Peter puede fumar dado un número inicial de cigarrillos y una tasa de conversión de colillas a nuevos cigarrillos.\n    Se asume que Peter puede continuar fumando y convirtiendo colillas en nuevos cigarrillos siempre que tenga suficientes colillas para hacerlo.\n    \n    >>> TotalSmokedCigarettes(4, 3)\n    5\n    >>> TotalSmokedCigarettes(10, 3)\n    14\n*/\n\nstatic int TotalSmokedCigarettes(int initialCigarettes, int buttConversionRate)",
      "arb": "using System;\nusing System.Collections.Generic;\nusing System.Diagnostics;\n\nclass Program\n{\n\n/* يحسب العدد الإجمالي للسجائر التي يمكن أن يدخنها بيتر مع إعطاء عدد أولي من السجائر ومعدل تحويل أعقاب السجائر إلى سجائر جديدة.\n    يُفترض أن بيتر يمكنه الاستمرار في التدخين وتحويل الأعقاب إلى سجائر جديدة طالما كان لديه ما يكفي من الأعقاب للقيام بذلك.\n    \n    >>> TotalSmokedCigarettes(4, 3)\n    5\n    >>> TotalSmokedCigarettes(10, 3)\n    14\n*/\n\nstatic int TotalSmokedCigarettes(int initialCigarettes, int buttConversionRate)",
      "sw": "using System;\nusing System.Collections.Generic;\nusing System.Diagnostics;\n\nclass Program\n{\n\n/* Inahesabu jumla ya sigara ambazo Peter anaweza kuvuta akipewa idadi ya awali ya sigara na kiwango cha ubadilishaji wa vishina kuwa sigara mpya.\n    Inadhaniwa kwamba Peter anaweza kuendelea kuvuta na kubadilisha vishina kuwa sigara mpya mradi tu ana vishina vya kutosha kufanya hivyo.\n    \n    >>> TotalSmokedCigarettes(4, 3)\n    5\n    >>> TotalSmokedCigarettes(10, 3)\n    14\n*/\n\nstatic int TotalSmokedCigarettes(int initialCigarettes, int buttConversionRate)",
      "tr": "using System;\nusing System.Collections.Generic;\nusing System.Diagnostics;\n\nclass Program\n{\n\n/* Peter'ın başlangıçta sahip olduğu sigara sayısı ve izmaritlerin yeni sigaralara dönüşüm oranı verildiğinde, Peter'ın toplamda kaç sigara içebileceğini hesaplar.\n    Peter'ın yeterince izmariti olduğu sürece sigara içmeye ve izmaritleri yeni sigaralara dönüştürmeye devam edebileceği varsayılmaktadır.\n    \n    >>> TotalSmokedCigarettes(4, 3)\n    5\n    >>> TotalSmokedCigarettes(10, 3)\n    14\n*/\n\nstatic int TotalSmokedCigarettes(int initialCigarettes, int buttConversionRate)",
      "vi": "using System;\nusing System.Collections.Generic;\nusing System.Diagnostics;\n\nclass Program\n{\n\n/* Tính tổng số điếu thuốc mà Peter có thể hút được với số lượng điếu thuốc ban đầu và tỷ lệ chuyển đổi đầu lọc thành điếu thuốc mới.\n    Giả sử rằng Peter có thể tiếp tục hút và chuyển đổi đầu lọc thành điếu thuốc mới miễn là anh ta có đủ đầu lọc để làm như vậy.\n    \n    >>> TotalSmokedCigarettes(4, 3)\n    5\n    >>> TotalSmokedCigarettes(10, 3)\n    14\n*/\n\nstatic int TotalSmokedCigarettes(int initialCigarettes, int buttConversionRate)"
    },
    "prompt_bertscore": {
      "es": "0.9970171675679991",
      "arb": "0.9815627307715796",
      "sw": "0.9987810053515889",
      "tr": "0.9834417741761696",
      "vi": "0.9775815820444973"
    },
    "canonical_solution": "{\n    int totalSmoked = initialCigarettes;\n    int butts = initialCigarettes;\n\n    while (butts >= buttConversionRate)\n    {\n        int newCigarettes = butts / buttConversionRate;\n        totalSmoked += newCigarettes;\n        butts = butts % buttConversionRate + newCigarettes;\n    }\n\n    return totalSmoked;\n}",
    "instruction": {
      "es": "static int TotalSmokedCigarettes(int initialCigarettes, int buttConversionRate)\n{\n    int totalSmoked = initialCigarettes;\n    int butts = initialCigarettes;\n\n    while (butts >= buttConversionRate)\n    {\n        int newCigarettes = butts / buttConversionRate;\n        totalSmoked += newCigarettes;\n        butts = butts % buttConversionRate + newCigarettes;\n    }\n\n    return totalSmoked;\n}\n\nProporcione una descripción concisa en lenguaje natural (docstring) del código C# en español utilizando un máximo de 500 caracteres.",
      "arb": "static int TotalSmokedCigarettes(int initialCigarettes, int buttConversionRate)\n{\n    int totalSmoked = initialCigarettes;\n    int butts = initialCigarettes;\n\n    while (butts >= buttConversionRate)\n    {\n        int newCigarettes = butts / buttConversionRate;\n        totalSmoked += newCigarettes;\n        butts = butts % buttConversionRate + newCigarettes;\n    }\n\n    return totalSmoked;\n}\n\nيرجى تقديم وصف موجز بلغة طبيعية (docstring) للكود المكتوب بلغة C# باللغة العربية الفصحى، بحيث لا يتجاوز 500 حرف.",
      "sw": "static int TotalSmokedCigarettes(int initialCigarettes, int buttConversionRate)\n{\n    int totalSmoked = initialCigarettes;\n    int butts = initialCigarettes;\n\n    while (butts >= buttConversionRate)\n    {\n        int newCigarettes = butts / buttConversionRate;\n        totalSmoked += newCigarettes;\n        butts = butts % buttConversionRate + newCigarettes;\n    }\n\n    return totalSmoked;\n}\n\nToa maelezo mafupi ya lugha ya asili (docstring) ya msimbo wa C# kwa Kiswahili kwa kutumia herufi zisizozidi 500.",
      "tr": "static int TotalSmokedCigarettes(int initialCigarettes, int buttConversionRate)\n{\n    int totalSmoked = initialCigarettes;\n    int butts = initialCigarettes;\n\n    while (butts >= buttConversionRate)\n    {\n        int newCigarettes = butts / buttConversionRate;\n        totalSmoked += newCigarettes;\n        butts = butts % buttConversionRate + newCigarettes;\n    }\n\n    return totalSmoked;\n}\n\nAşağıdaki C# kodunun Türkçe olarak en fazla 500 karakter kullanarak kısa bir doğal dil açıklamasını (docstring) sağlayın.",
      "vi": "static int TotalSmokedCigarettes(int initialCigarettes, int buttConversionRate)\n{\n    int totalSmoked = initialCigarettes;\n    int butts = initialCigarettes;\n\n    while (butts >= buttConversionRate)\n    {\n        int newCigarettes = butts / buttConversionRate;\n        totalSmoked += newCigarettes;\n        butts = butts % buttConversionRate + newCigarettes;\n    }\n\n    return totalSmoked;\n}\n\nCung cấp mô tả ngắn gọn bằng ngôn ngữ tự nhiên (docstring) cho mã C# bằng tiếng Việt, không quá 500 ký tự."
    },
    "instruction_bertscore": {
      "es": "0.9702167647764858",
      "arb": "0.8829437397396628",
      "sw": "0.9446027812508938",
      "tr": "0.8954906250184936",
      "vi": "0.8888496168589731"
    },
    "level": "",
    "test": "static void Main()\n    {\n        Debug.Assert(TotalSmokedCigarettes(4, 3) == 5);\n        Debug.Assert(TotalSmokedCigarettes(10, 3) == 14);\n        Debug.Assert(TotalSmokedCigarettes(1, 2) == 1); // No conversion possible, should return initial cigarettes\n        Debug.Assert(TotalSmokedCigarettes(20, 4) ==26); // Additional case to test\n\n    }\n}",
    "entry_point": "TotalSmokedCigarettes",
    "signature": "static int TotalSmokedCigarettes(int initialCigarettes, int buttConversionRate)",
    "docstring": {
      "es": "Calcula el número total de cigarrillos que Peter puede fumar dado un número inicial de cigarrillos y una tasa de conversión de colillas a nuevos cigarrillos. Se asume que Peter puede continuar fumando y convirtiendo colillas en nuevos cigarrillos siempre que tenga suficientes colillas para hacerlo.\n    \n    >>> TotalSmokedCigarettes(4, 3)\n    5\n    >>> TotalSmokedCigarettes(10, 3)\n    14",
      "arb": "يحسب العدد الإجمالي للسجائر التي يمكن لبيتر تدخينها بالنظر إلى عدد مبدئي من السجائر ومعدل تحويل أعقاب السجائر إلى سجائر جديدة.   \n    يُفترض أن بيتر يمكنه الاستمرار في التدخين وتحويل الأعقاب إلى سجائر جديدة طالما كان لديه ما يكفي من الأعقاب للقيام بذلك.\n    \n    >>> TotalSmokedCigarettes(4, 3)\n    5\n    >>> TotalSmokedCigarettes(10, 3)\n    14",
      "sw": "Hesabu jumla ya sigara ambazo Peter anaweza kuvuta kwa kuzingatia idadi ya awali ya sigara na kiwango cha ubadilishaji wa vipande vya sigara kuwa sigara mpya. \n    Inadhaniwa kwamba Peter anaweza kuendelea kuvuta na kubadilisha vipande vya sigara kuwa sigara mpya mradi ana vipande vya kutosha kufanya hivyo.\n    \n    >>> TotalSmokedCigarettes(4, 3)\n    5\n    >>> TotalSmokedCigarettes(10, 3)\n    14",
      "tr": "Peter'ın başlangıçta sahip olduğu sigara sayısı ve izmaritlerin yeni sigaralara dönüşüm oranı verildiğinde, Peter'ın toplamda kaç sigara içebileceğini hesaplar. \n    Peter'ın izmaritleri yeni sigaralara dönüştürmek için yeterli izmarite sahip olduğu sürece sigara içmeye ve izmaritleri dönüştürmeye devam edebileceği varsayılmaktadır.\n    \n    >>> TotalSmokedCigarettes(4, 3)\n    5\n    >>> TotalSmokedCigarettes(10, 3)\n    14",
      "vi": "Tính tổng số điếu thuốc mà Peter có thể hút được với một số lượng ban đầu các điếu thuốc và tỷ lệ chuyển đổi từ đầu mẩu thuốc thành điếu thuốc mới. \n    Giả sử rằng Peter có thể tiếp tục hút và chuyển đổi đầu mẩu thuốc thành điếu thuốc mới miễn là anh ấy có đủ đầu mẩu thuốc để làm điều đó.\n    \n    >>> TotalSmokedCigarettes(4, 3)\n    5\n    >>> TotalSmokedCigarettes(10, 3)\n    14"
    },
    "docstring_bertscore": {
      "es": "0.9963841325436409",
      "arb": "0.9857705167634226",
      "sw": "0.9624157551917215",
      "tr": "0.9434846908360485",
      "vi": "0.9655737796197953"
    }
  },
  {
    "task_id": "C#/42",
    "prompt": {
      "es": "using System;\nusing System.Collections.Generic;\nusing System.Diagnostics;\n\nclass Program\n{\n\n/* Determina el número de pares de estudiantes que se consideran \"oponentes iguales\". Dos estudiantes son oponentes iguales si la diferencia en cada una de sus puntuaciones de las materias (Chino, Matemáticas, Inglés) no supera 5, y la diferencia total en sus puntuaciones no supera 10.\n    >>> FindEqualOpponents(new List<Tuple<int, int, int>> { Tuple.Create(90, 90, 90), Tuple.Create(85, 95, 90), Tuple.Create(80, 100, 91) })\n    2\n\n*/\n\n\nstatic int FindEqualOpponents(List<Tuple<int, int, int>> scores)",
      "arb": "using System;\nusing System.Collections.Generic;\nusing System.Diagnostics;\n\nclass Program\n{\n\n/* يحدد عدد الأزواج من الطلاب الذين يعتبرون \"خصوماً متساوين\". يعتبر الطالبان خصوماً متساوين إذا لم يتجاوز الفرق في درجات كل من مواضيعهم (الصينية، الرياضيات، الإنجليزية) 5، ولم يتجاوز الفرق الإجمالي في درجاتهم 10.\n    >>> FindEqualOpponents(new List<Tuple<int, int, int>> { Tuple.Create(90, 90, 90), Tuple.Create(85, 95, 90), Tuple.Create(80, 100, 91) })\n    2\n\n*/\n\n\nstatic int FindEqualOpponents(List<Tuple<int, int, int>> scores)",
      "sw": "using System;\nusing System.Collections.Generic;\nusing System.Diagnostics;\n\nclass Program\n{\n\n/* Huamua idadi ya wanandoa wa wanafunzi ambao wanachukuliwa kuwa \"wapinzani sawa\". Wanafunzi wawili ni wapinzani sawa ikiwa tofauti katika kila moja ya alama zao za masomo (Kichina, Hisabati, Kiingereza) haizidi 5, na tofauti ya jumla ya alama zao haizidi 10.\n    >>> FindEqualOpponents(new List<Tuple<int, int, int>> { Tuple.Create(90, 90, 90), Tuple.Create(85, 95, 90), Tuple.Create(80, 100, 91) })\n    2\n\n*/\n\n\nstatic int FindEqualOpponents(List<Tuple<int, int, int>> scores)",
      "tr": "using System;\nusing System.Collections.Generic;\nusing System.Diagnostics;\n\nclass Program\n{\n\n/* \"Eşit rakipler\" olarak kabul edilen öğrenci çiftlerinin sayısını belirler. İki öğrenci, her bir derslerindeki (Çince, Matematik, İngilizce) puan farkı 5'i geçmiyorsa ve toplam puan farkı 10'u geçmiyorsa eşit rakipler olarak kabul edilir.\n    >>> FindEqualOpponents(new List<Tuple<int, int, int>> { Tuple.Create(90, 90, 90), Tuple.Create(85, 95, 90), Tuple.Create(80, 100, 91) })\n    2\n\n*/\n\n\nstatic int FindEqualOpponents(List<Tuple<int, int, int>> scores)",
      "vi": "using System;\nusing System.Collections.Generic;\nusing System.Diagnostics;\n\nclass Program\n{\n\n/* Xác định số lượng cặp học sinh được coi là \"đối thủ ngang tài\". Hai học sinh là đối thủ ngang tài nếu sự chênh lệch điểm số của từng môn học (Ngữ văn, Toán, Tiếng Anh) không vượt quá 5, và tổng sự chênh lệch điểm số của họ không vượt quá 10.\n    >>> FindEqualOpponents(new List<Tuple<int, int, int>> { Tuple.Create(90, 90, 90), Tuple.Create(85, 95, 90), Tuple.Create(80, 100, 91) })\n    2\n\n*/\n\n\nstatic int FindEqualOpponents(List<Tuple<int, int, int>> scores)"
    },
    "prompt_bertscore": {
      "es": "0.9851247693946783",
      "arb": "0.9892143703098055",
      "sw": "0.9929436557137356",
      "tr": "0.9725083634824853",
      "vi": "0.9586155587417621"
    },
    "canonical_solution": "{\n    int equalOpponentsCount = 0;\n    for (int i = 0; i < scores.Count - 1; i++)\n    {\n        for (int j = i + 1; j < scores.Count; j++)\n        {\n            var score1 = scores[i];\n            var score2 = scores[j];\n            if (Math.Abs(score1.Item1 - score2.Item1) <= 5 &&\n                Math.Abs(score1.Item2 - score2.Item2) <= 5 &&\n                Math.Abs(score1.Item3 - score2.Item3) <= 5 &&\n                Math.Abs((score1.Item1 + score1.Item2 + score1.Item3) - (score2.Item1 + score2.Item2 + score2.Item3)) <= 10)\n            {\n                equalOpponentsCount++;\n            }\n        }\n    }\n    return equalOpponentsCount;\n}",
    "instruction": {
      "es": "static int FindEqualOpponents(List<Tuple<int, int, int>> scores)\n{\n    int equalOpponentsCount = 0;\n    for (int i = 0; i < scores.Count - 1; i++)\n    {\n        for (int j = i + 1; j < scores.Count; j++)\n        {\n            var score1 = scores[i];\n            var score2 = scores[j];\n            if (Math.Abs(score1.Item1 - score2.Item1) <= 5 &&\n                Math.Abs(score1.Item2 - score2.Item2) <= 5 &&\n                Math.Abs(score1.Item3 - score2.Item3) <= 5 &&\n                Math.Abs((score1.Item1 + score1.Item2 + score1.Item3) - (score2.Item1 + score2.Item2 + score2.Item3)) <= 10)\n            {\n                equalOpponentsCount++;\n            }\n        }\n    }\n    return equalOpponentsCount;\n}\n\nProporcione una descripción concisa en lenguaje natural (docstring) del código C# en español utilizando como máximo 500 caracteres.",
      "arb": "static int FindEqualOpponents(List<Tuple<int, int, int>> scores)\n{\n    int equalOpponentsCount = 0;\n    for (int i = 0; i < scores.Count - 1; i++)\n    {\n        for (int j = i + 1; j < scores.Count; j++)\n        {\n            var score1 = scores[i];\n            var score2 = scores[j];\n            if (Math.Abs(score1.Item1 - score2.Item1) <= 5 &&\n                Math.Abs(score1.Item2 - score2.Item2) <= 5 &&\n                Math.Abs(score1.Item3 - score2.Item3) <= 5 &&\n                Math.Abs((score1.Item1 + score1.Item2 + score1.Item3) - (score2.Item1 + score2.Item2 + score2.Item3)) <= 10)\n            {\n                equalOpponentsCount++;\n            }\n        }\n    }\n    return equalOpponentsCount;\n}\n\nيرجى تقديم وصف موجز بلغة طبيعية (docstring) للكود المكتوب بلغة C# باللغة العربية الفصحى، بحيث لا يتجاوز 500 حرف.",
      "sw": "static int FindEqualOpponents(List<Tuple<int, int, int>> scores)\n{\n    int equalOpponentsCount = 0;\n    for (int i = 0; i < scores.Count - 1; i++)\n    {\n        for (int j = i + 1; j < scores.Count; j++)\n        {\n            var score1 = scores[i];\n            var score2 = scores[j];\n            if (Math.Abs(score1.Item1 - score2.Item1) <= 5 &&\n                Math.Abs(score1.Item2 - score2.Item2) <= 5 &&\n                Math.Abs(score1.Item3 - score2.Item3) <= 5 &&\n                Math.Abs((score1.Item1 + score1.Item2 + score1.Item3) - (score2.Item1 + score2.Item2 + score2.Item3)) <= 10)\n            {\n                equalOpponentsCount++;\n            }\n        }\n    }\n    return equalOpponentsCount;\n}\n\nToa maelezo mafupi ya lugha ya asili (docstring) ya msimbo wa C# kwa Kiswahili kwa kutumia herufi zisizozidi 500.",
      "tr": "static int FindEqualOpponents(List<Tuple<int, int, int>> scores)\n{\n    int equalOpponentsCount = 0;\n    for (int i = 0; i < scores.Count - 1; i++)\n    {\n        for (int j = i + 1; j < scores.Count; j++)\n        {\n            var score1 = scores[i];\n            var score2 = scores[j];\n            if (Math.Abs(score1.Item1 - score2.Item1) <= 5 &&\n                Math.Abs(score1.Item2 - score2.Item2) <= 5 &&\n                Math.Abs(score1.Item3 - score2.Item3) <= 5 &&\n                Math.Abs((score1.Item1 + score1.Item2 + score1.Item3) - (score2.Item1 + score2.Item2 + score2.Item3)) <= 10)\n            {\n                equalOpponentsCount++;\n            }\n        }\n    }\n    return equalOpponentsCount;\n}\n\nAşağıdaki C# kodunun Türkçe olarak en fazla 500 karakter kullanarak kısa bir doğal dil açıklamasını (docstring) sağlayın.",
      "vi": "static int FindEqualOpponents(List<Tuple<int, int, int>> scores)\n{\n    int equalOpponentsCount = 0;\n    for (int i = 0; i < scores.Count - 1; i++)\n    {\n        for (int j = i + 1; j < scores.Count; j++)\n        {\n            var score1 = scores[i];\n            var score2 = scores[j];\n            if (Math.Abs(score1.Item1 - score2.Item1) <= 5 &&\n                Math.Abs(score1.Item2 - score2.Item2) <= 5 &&\n                Math.Abs(score1.Item3 - score2.Item3) <= 5 &&\n                Math.Abs((score1.Item1 + score1.Item2 + score1.Item3) - (score2.Item1 + score2.Item2 + score2.Item3)) <= 10)\n            {\n                equalOpponentsCount++;\n            }\n        }\n    }\n    return equalOpponentsCount;\n}\n\nCung cấp mô tả ngắn gọn bằng ngôn ngữ tự nhiên (docstring) cho mã C# bằng tiếng Việt, sử dụng tối đa 500 ký tự."
    },
    "instruction_bertscore": {
      "es": "0.9702167647764858",
      "arb": "0.8829437397396628",
      "sw": "0.918288824262535",
      "tr": "0.8955079058616436",
      "vi": "0.912055207014517"
    },
    "level": "",
    "test": "    static void Main()\n    {\n        Debug.Assert(FindEqualOpponents(new List<Tuple<int, int, int>> { Tuple.Create(90, 90, 90), Tuple.Create(85, 95, 90), Tuple.Create(80, 100, 91) }) == 2);\n        Debug.Assert(FindEqualOpponents(new List<Tuple<int, int, int>> { Tuple.Create(100, 100, 100), Tuple.Create(92, 95, 98), Tuple.Create(85, 90, 95) }) == 0);\n        Debug.Assert(FindEqualOpponents(new List<Tuple<int, int, int>> { Tuple.Create(100, 95, 90), Tuple.Create(95, 90, 85), Tuple.Create(90, 85, 80) }) == 0);\n        Debug.Assert(FindEqualOpponents(new List<Tuple<int, int, int>> { Tuple.Create(100, 100, 100), Tuple.Create(80, 80, 80) }) == 0);\n        Debug.Assert(FindEqualOpponents(new List<Tuple<int, int, int>> { Tuple.Create(100, 100, 100), Tuple.Create(100, 100, 99), Tuple.Create(101, 100, 99) }) == 3);\n\n    }\n}\n",
    "entry_point": "FindEqualOpponents",
    "signature": "static int FindEqualOpponents(List<Tuple<int, int, int>> scores)",
    "docstring": {
      "es": "Determina el número de pares de estudiantes que se consideran \"oponentes iguales\". Dos estudiantes son oponentes iguales si la diferencia en cada una de sus puntuaciones de materias (Chino, Matemáticas, Inglés) no supera 5, y la diferencia total en sus puntuaciones no supera 10.\n    >>> FindEqualOpponents(new List<Tuple<int, int, int>> { Tuple.Create(90, 90, 90), Tuple.Create(85, 95, 90), Tuple.Create(80, 100, 91) })\n    2",
      "arb": "يحدد عدد الأزواج من الطلاب الذين يعتبرون \"خصومًا متساوين\". يعتبر الطالبان خصومًا متساوين إذا لم يتجاوز الفرق في درجات كل من موادهم (الصينية، الرياضيات، الإنجليزية) 5، ولم يتجاوز الفرق الإجمالي في درجاتهم 10.\n    >>> FindEqualOpponents(new List<Tuple<int, int, int>> { Tuple.Create(90, 90, 90), Tuple.Create(85, 95, 90), Tuple.Create(80, 100, 91) })\n    2",
      "sw": "Inabainisha idadi ya wanandoa wa wanafunzi wanaozingatiwa kuwa \"wapinzani sawa\". Wanafunzi wawili ni wapinzani sawa ikiwa tofauti katika kila moja ya alama zao za masomo (Kichina, Hisabati, Kiingereza) haizidi 5, na tofauti ya jumla katika alama zao haizidi 10.\n    >>> FindEqualOpponents(new List<Tuple<int, int, int>> { Tuple.Create(90, 90, 90), Tuple.Create(85, 95, 90), Tuple.Create(80, 100, 91) })\n    2",
      "tr": "Belirler, \"eşit rakip\" olarak kabul edilen öğrenci çiftlerinin sayısını. İki öğrenci, her bir ders notlarındaki (Çince, Matematik, İngilizce) fark 5'i geçmiyorsa ve toplam not farkı 10'u geçmiyorsa eşit rakip olarak kabul edilirler.\n    >>> FindEqualOpponents(new List<Tuple<int, int, int>> { Tuple.Create(90, 90, 90), Tuple.Create(85, 95, 90), Tuple.Create(80, 100, 91) })\n    2",
      "vi": "Xác định số cặp học sinh được coi là \"đối thủ ngang tài\". Hai học sinh là đối thủ ngang tài nếu chênh lệch điểm số của từng môn học của họ (Ngữ văn, Toán, Tiếng Anh) không vượt quá 5, và tổng chênh lệch điểm số của họ không vượt quá 10.\n    >>> FindEqualOpponents(new List<Tuple<int, int, int>> { Tuple.Create(90, 90, 90), Tuple.Create(85, 95, 90), Tuple.Create(80, 100, 91) })\n    2"
    },
    "docstring_bertscore": {
      "es": "0.9825250949676937",
      "arb": "0.9894366377061836",
      "sw": "0.9791861182624971",
      "tr": "0.9593711487112188",
      "vi": "0.9545072865708175"
    }
  },
  {
    "task_id": "C#/43",
    "prompt": {
      "es": "using System;\nusing System.Collections.Generic;\nusing System.Diagnostics;\n\nclass Program\n{\n\n/* Encuentra la longitud de la secuencia más larga de elementos consecutivos en una lista dada de enteros.\n    La secuencia no necesita estar en orden pero debe consistir en números naturales consecutivos.\n    >>> LongestConsecutiveSequence(new List<int> {1, 5, 6, 2, 3, 4, 5, 6, 8, 9})\n    6\n    >>> LongestConsecutiveSequence(new List<int> {10, 4, 20, 1, 3, 2})\n    4\n*/\n\nstatic int LongestConsecutiveSequence(List<int> sequence)",
      "arb": "using System;\nusing System.Collections.Generic;\nusing System.Diagnostics;\n\nclass Program\n{\n\n/* يجد طول أطول تسلسل من العناصر المتتالية في قائمة معينة من الأعداد الصحيحة.\n    لا يحتاج التسلسل إلى أن يكون مرتبا ولكن يجب أن يتكون من أعداد طبيعية متتالية.\n    >>> LongestConsecutiveSequence(new List<int> {1, 5, 6, 2, 3, 4, 5, 6, 8, 9})\n    6\n    >>> LongestConsecutiveSequence(new List<int> {10, 4, 20, 1, 3, 2})\n    4\n*/\n\nstatic int LongestConsecutiveSequence(List<int> sequence)",
      "sw": "using System;\nusing System.Collections.Generic;\nusing System.Diagnostics;\n\nclass Program\n{\n\n/* Inapata urefu wa mlolongo mrefu zaidi wa vipengele vinavyoendelea katika orodha iliyotolewa ya nambari za nzima.\n    Mlolongo hauhitaji kuwa katika mpangilio lakini lazima uwe na nambari za asili zinazoendelea.\n    >>> LongestConsecutiveSequence(new List<int> {1, 5, 6, 2, 3, 4, 5, 6, 8, 9})\n    6\n    >>> LongestConsecutiveSequence(new List<int> {10, 4, 20, 1, 3, 2})\n    4\n*/\n\nstatic int LongestConsecutiveSequence(List<int> sequence)",
      "tr": "using System;\nusing System.Collections.Generic;\nusing System.Diagnostics;\n\nclass Program\n{\n\n/* Verilen bir tamsayı listesindeki en uzun ardışık elemanlar dizisinin uzunluğunu bulur.\n    Dizi sıralı olmak zorunda değildir ancak ardışık doğal sayılardan oluşmalıdır.\n    >>> LongestConsecutiveSequence(new List<int> {1, 5, 6, 2, 3, 4, 5, 6, 8, 9})\n    6\n    >>> LongestConsecutiveSequence(new List<int> {10, 4, 20, 1, 3, 2})\n    4\n*/\n\nstatic int LongestConsecutiveSequence(List<int> sequence)",
      "vi": "using System;\nusing System.Collections.Generic;\nusing System.Diagnostics;\n\nclass Program\n{\n\n/* Tìm độ dài của dãy phần tử liên tiếp dài nhất trong một danh sách số nguyên cho trước.\n    Dãy không cần phải theo thứ tự nhưng phải bao gồm các số tự nhiên liên tiếp.\n    >>> LongestConsecutiveSequence(new List<int> {1, 5, 6, 2, 3, 4, 5, 6, 8, 9})\n    6\n    >>> LongestConsecutiveSequence(new List<int> {10, 4, 20, 1, 3, 2})\n    4\n*/\n\nstatic int LongestConsecutiveSequence(List<int> sequence)"
    },
    "prompt_bertscore": {
      "es": "0.9936062866648679",
      "arb": "0.9871482170862806",
      "sw": "0.990543207558929",
      "tr": "0.9829819448440739",
      "vi": "0.9799466739914797"
    },
    "canonical_solution": "{\n    var numberSet = new HashSet<int>(sequence);\n    int longestStreak = 0;\n\n    foreach (int number in numberSet)\n    {\n        if (!numberSet.Contains(number - 1))\n        {\n            int currentNumber = number;\n            int currentStreak = 1;\n\n            while (numberSet.Contains(currentNumber + 1))\n            {\n                currentNumber += 1;\n                currentStreak += 1;\n            }\n\n            longestStreak = Math.Max(longestStreak, currentStreak);\n        }\n    }\n\n    return longestStreak;\n}",
    "instruction": {
      "es": "static int LongestConsecutiveSequence(List<int> sequence)\n{\n    var numberSet = new HashSet<int>(sequence);\n    int longestStreak = 0;\n\n    foreach (int number in numberSet)\n    {\n        if (!numberSet.Contains(number - 1))\n        {\n            int currentNumber = number;\n            int currentStreak = 1;\n\n            while (numberSet.Contains(currentNumber + 1))\n            {\n                currentNumber += 1;\n                currentStreak += 1;\n            }\n\n            longestStreak = Math.Max(longestStreak, currentStreak);\n        }\n    }\n\n    return longestStreak;\n}\n\nProporcione una descripción concisa en lenguaje natural (docstring) del código C# en español utilizando como máximo 500 caracteres.",
      "arb": "static int LongestConsecutiveSequence(List<int> sequence)\n{\n    var numberSet = new HashSet<int>(sequence);\n    int longestStreak = 0;\n\n    foreach (int number in numberSet)\n    {\n        if (!numberSet.Contains(number - 1))\n        {\n            int currentNumber = number;\n            int currentStreak = 1;\n\n            while (numberSet.Contains(currentNumber + 1))\n            {\n                currentNumber += 1;\n                currentStreak += 1;\n            }\n\n            longestStreak = Math.Max(longestStreak, currentStreak);\n        }\n    }\n\n    return longestStreak;\n}\n\nيرجى تقديم وصف موجز بلغة طبيعية (docstring) للكود المكتوب بلغة C# باللغة العربية الفصحى، بحيث لا يتجاوز 500 حرف.",
      "sw": "static int LongestConsecutiveSequence(List<int> sequence)\n{\n    var numberSet = new HashSet<int>(sequence);\n    int longestStreak = 0;\n\n    foreach (int number in numberSet)\n    {\n        if (!numberSet.Contains(number - 1))\n        {\n            int currentNumber = number;\n            int currentStreak = 1;\n\n            while (numberSet.Contains(currentNumber + 1))\n            {\n                currentNumber += 1;\n                currentStreak += 1;\n            }\n\n            longestStreak = Math.Max(longestStreak, currentStreak);\n        }\n    }\n\n    return longestStreak;\n}\n\nToa maelezo mafupi ya lugha ya asili (docstring) ya msimbo wa C# kwa Kiswahili kwa kutumia herufi zisizozidi 500.",
      "tr": "static int LongestConsecutiveSequence(List<int> sequence)\n{\n    var numberSet = new HashSet<int>(sequence);\n    int longestStreak = 0;\n\n    foreach (int number in numberSet)\n    {\n        if (!numberSet.Contains(number - 1))\n        {\n            int currentNumber = number;\n            int currentStreak = 1;\n\n            while (numberSet.Contains(currentNumber + 1))\n            {\n                currentNumber += 1;\n                currentStreak += 1;\n            }\n\n            longestStreak = Math.Max(longestStreak, currentStreak);\n        }\n    }\n\n    return longestStreak;\n}\n\nC# kodunun Türkçe olarak en fazla 500 karakter kullanarak doğal dilde kısa bir açıklamasını (docstring) sağlayın.",
      "vi": "static int LongestConsecutiveSequence(List<int> sequence)\n{\n    var numberSet = new HashSet<int>(sequence);\n    int longestStreak = 0;\n\n    foreach (int number in numberSet)\n    {\n        if (!numberSet.Contains(number - 1))\n        {\n            int currentNumber = number;\n            int currentStreak = 1;\n\n            while (numberSet.Contains(currentNumber + 1))\n            {\n                currentNumber += 1;\n                currentStreak += 1;\n            }\n\n            longestStreak = Math.Max(longestStreak, currentStreak);\n        }\n    }\n\n    return longestStreak;\n}\n\nCung cấp mô tả ngắn gọn bằng ngôn ngữ tự nhiên (docstring) cho mã C# bằng tiếng Việt với tối đa 500 ký tự."
    },
    "instruction_bertscore": {
      "es": "0.9702167647764858",
      "arb": "0.8829437397396628",
      "sw": "0.918288824262535",
      "tr": "0.9156557799315365",
      "vi": "0.9066002208601559"
    },
    "level": "",
    "test": "    static void Main()\n    {\n        Debug.Assert(LongestConsecutiveSequence(new List<int> {1, 5, 6, 2, 3, 4, 5, 6, 8, 9}) == 6);\n        Debug.Assert(LongestConsecutiveSequence(new List<int> {10, 4, 20, 1, 3, 2}) == 4);\n        Debug.Assert(LongestConsecutiveSequence(new List<int> {100, 4, 200, 1, 3, 2}) == 4);\n        Debug.Assert(LongestConsecutiveSequence(new List<int> {1, 1}) == 1);\n\n    }\n}\n\n",
    "entry_point": "LongestConsecutiveSequence",
    "signature": "static int LongestConsecutiveSequence(List<int> sequence)",
    "docstring": {
      "es": "Encuentra la longitud de la secuencia de elementos consecutivos más larga en una lista dada de enteros.\n    La secuencia no necesita estar en orden pero debe consistir en números naturales consecutivos.\n    >>> LongestConsecutiveSequence(new List<int> {1, 5, 6, 2, 3, 4, 5, 6, 8, 9})\n    6\n    >>> LongestConsecutiveSequence(new List<int> {10, 4, 20, 1, 3, 2})\n    4",
      "arb": "يجد طول أطول تسلسل من العناصر المتتالية في قائمة معينة من الأعداد الصحيحة.\n    لا يحتاج التسلسل إلى أن يكون مرتبًا ولكنه يجب أن يتكون من أعداد طبيعية متتالية.\n    >>> LongestConsecutiveSequence(new List<int> {1, 5, 6, 2, 3, 4, 5, 6, 8, 9})\n    6\n    >>> LongestConsecutiveSequence(new List<int> {10, 4, 20, 1, 3, 2})\n    4",
      "sw": "Inapata urefu wa mlolongo mrefu zaidi wa vipengele vinavyoendelea katika orodha iliyotolewa ya nambari za mzima.  \nMlolongo hauhitaji kuwa katika mpangilio lakini lazima uwe na nambari za asili zinazoendelea.  \n>>> LongestConsecutiveSequence(new List<int> {1, 5, 6, 2, 3, 4, 5, 6, 8, 9})  \n6  \n>>> LongestConsecutiveSequence(new List<int> {10, 4, 20, 1, 3, 2})  \n4  ",
      "tr": "Verilen bir tamsayı listesindeki en uzun ardışık elemanlar dizisinin uzunluğunu bulur.\n    Dizi sıralı olmak zorunda değildir ancak ardışık doğal sayılardan oluşmalıdır.\n    >>> LongestConsecutiveSequence(new List<int> {1, 5, 6, 2, 3, 4, 5, 6, 8, 9})\n    6\n    >>> LongestConsecutiveSequence(new List<int> {10, 4, 20, 1, 3, 2})\n    4",
      "vi": "Tìm độ dài của dãy phần tử liên tiếp dài nhất trong một danh sách số nguyên cho trước. \n    Dãy số không cần phải theo thứ tự nhưng phải bao gồm các số tự nhiên liên tiếp.\n    >>> LongestConsecutiveSequence(new List<int> {1, 5, 6, 2, 3, 4, 5, 6, 8, 9})\n    6\n    >>> LongestConsecutiveSequence(new List<int> {10, 4, 20, 1, 3, 2})\n    4"
    },
    "docstring_bertscore": {
      "es": "0.990116748130847",
      "arb": "0.981838827001218",
      "sw": "0.9892272812845728",
      "tr": "0.9826994924422423",
      "vi": "0.9724040825324419"
    }
  },
  {
    "task_id": "C#/44",
    "prompt": {
      "es": "using System;\nusing System.Collections.Generic;\nusing System.Diagnostics;\n\nclass Program\n{\n\n/* Determina de quién es la forma geométrica que tiene un área más grande: el cuadrado de Alice con lado de longitud a, o el rectángulo de Bob con lados b y c.\n    - Si el cuadrado de Alice tiene un área más grande, devuelve \"Alice\".\n    - Si el rectángulo de Bob tiene un área más grande, devuelve \"Bob\".\n    \n    Ejemplos:\n    >>> CompareArea(5, 4, 6)\n    \"Alice\"\n    \n    >>> CompareArea(7, 5, 10)\n    \"Bob\"\n*/\n\nstatic string CompareArea(int a, int b, int c)",
      "arb": "using System;\nusing System.Collections.Generic;\nusing System.Diagnostics;\n\nclass Program\n{\n\n/* يحدد الشكل الهندسي الذي يمتلك مساحة أكبر: مربع أليس بطول ضلع a، أو مستطيل بوب بأضلاع b و c.\n    - إذا كان مربع أليس يمتلك مساحة أكبر، يعيد \"Alice\".\n    - إذا كان مستطيل بوب يمتلك مساحة أكبر، يعيد \"Bob\".\n    \n    أمثلة:\n    >>> CompareArea(5, 4, 6)\n    \"Alice\"\n    \n    >>> CompareArea(7, 5, 10)\n    \"Bob\"\n*/\n\nstatic string CompareArea(int a, int b, int c)",
      "sw": "using System;\nusing System.Collections.Generic;\nusing System.Diagnostics;\n\nclass Program\n{\n\n/* Huamua ni nani mwenye umbo la kijiometri lenye eneo kubwa zaidi: Mraba wa Alice wenye urefu wa upande a, au Mstatili wa Bob wenye pande b na c.\n    - Ikiwa mraba wa Alice una eneo kubwa zaidi, rudisha \"Alice\".\n    - Ikiwa mstatili wa Bob una eneo kubwa zaidi, rudisha \"Bob\".\n    \n    Mifano:\n    >>> CompareArea(5, 4, 6)\n    \"Alice\"\n    \n    >>> CompareArea(7, 5, 10)\n    \"Bob\"\n*/\n\nstatic string CompareArea(int a, int b, int c)",
      "tr": "using System;\nusing System.Collections.Generic;\nusing System.Diagnostics;\n\nclass Program\n{\n\n/* Kimin geometrik şeklinin daha büyük bir alana sahip olduğunu belirler: Kenar uzunluğu a olan Alice'in karesi mi, yoksa kenarları b ve c olan Bob'un dikdörtgeni mi.\n    - Eğer Alice'in karesi daha büyük bir alana sahipse, \"Alice\" döndür.\n    - Eğer Bob'un dikdörtgeni daha büyük bir alana sahipse, \"Bob\" döndür.\n    \n    Örnekler:\n    >>> CompareArea(5, 4, 6)\n    \"Alice\"\n    \n    >>> CompareArea(7, 5, 10)\n    \"Bob\"\n*/\n\nstatic string CompareArea(int a, int b, int c)",
      "vi": "using System;\nusing System.Collections.Generic;\nusing System.Diagnostics;\n\nclass Program\n{\n\n/* Xác định hình dạng hình học của ai có diện tích lớn hơn: hình vuông của Alice với độ dài cạnh a, hay hình chữ nhật của Bob với các cạnh b và c.\n    - Nếu hình vuông của Alice có diện tích lớn hơn, trả về \"Alice\".\n    - Nếu hình chữ nhật của Bob có diện tích lớn hơn, trả về \"Bob\".\n    \n    Ví dụ:\n    >>> CompareArea(5, 4, 6)\n    \"Alice\"\n    \n    >>> CompareArea(7, 5, 10)\n    \"Bob\"\n*/\n\nstatic string CompareArea(int a, int b, int c)"
    },
    "prompt_bertscore": {
      "es": "0.9999996027392379",
      "arb": "0.9862255789663736",
      "sw": "0.9859220717441523",
      "tr": "0.9999996027392379",
      "vi": "0.9919630175225663"
    },
    "canonical_solution": "{\n    int squareArea = a * a;\n    int rectangleArea = b * c;\n    return squareArea > rectangleArea ? \"Alice\" : \"Bob\";\n}",
    "instruction": {
      "es": "static string CompareArea(int a, int b, int c)\n{\n    int squareArea = a * a;\n    int rectangleArea = b * c;\n    return squareArea > rectangleArea ? \"Alice\" : \"Bob\";\n}\n\nProporcione una descripción concisa en lenguaje natural (docstring) del código C# en español utilizando como máximo 500 caracteres.",
      "arb": "static string CompareArea(int a, int b, int c)\n{\n    int squareArea = a * a;\n    int rectangleArea = b * c;\n    return squareArea > rectangleArea ? \"Alice\" : \"Bob\";\n}\n\nيرجى تقديم وصف موجز بلغة طبيعية (docstring) للكود المكتوب بلغة C# باللغة العربية الفصحى، بحيث لا يتجاوز 500 حرف.",
      "sw": "static string CompareArea(int a, int b, int c)\n{\n    int squareArea = a * a;\n    int rectangleArea = b * c;\n    return squareArea > rectangleArea ? \"Alice\" : \"Bob\";\n}\n\nToa maelezo mafupi ya lugha asilia (docstring) ya msimbo wa C# kwa Kiswahili kwa kutumia herufi zisizozidi 500.",
      "tr": "static string CompareArea(int a, int b, int c)\n{\n    int squareArea = a * a;\n    int rectangleArea = b * c;\n    return squareArea > rectangleArea ? \"Alice\" : \"Bob\";\n}\n\nC# kodunun Türkçe olarak en fazla 500 karakter kullanarak kısa bir doğal dil açıklamasını (docstring) sağlayın.",
      "vi": "static string CompareArea(int a, int b, int c)\n{\n    int squareArea = a * a;\n    int rectangleArea = b * c;\n    return squareArea > rectangleArea ? \"Alice\" : \"Bob\";\n}\n\nCung cấp mô tả ngắn gọn bằng ngôn ngữ tự nhiên (docstring) cho mã C# bằng tiếng Việt, không quá 500 ký tự."
    },
    "instruction_bertscore": {
      "es": "0.9702167647764858",
      "arb": "0.8890840007085943",
      "sw": "0.9446027812508938",
      "tr": "0.9379850128459545",
      "vi": "0.9187315713818617"
    },
    "level": "",
    "test": "    static void Main()\n    {\n        Debug.Assert(CompareArea(5, 4, 6) == \"Alice\");\n        Debug.Assert(CompareArea(7, 5, 10) == \"Bob\");\n        Debug.Assert(CompareArea(2, 2, 8) == \"Bob\"); // Testing with a square of side 2 and a rectangle 2x8\n        Debug.Assert(CompareArea(10, 5, 5) == \"Alice\"); // Testing with a square of side 10 and a rectangle 5x5\n\n\n    }\n}\n\n",
    "entry_point": "CompareArea",
    "signature": "static string CompareArea(int a, int b, int c)",
    "docstring": {
      "es": "Determina qué forma geométrica tiene un área más grande: el cuadrado de Alice con lado de longitud a, o el rectángulo de Bob con lados b y c.\n    - Si el cuadrado de Alice tiene un área más grande, devuelve \"Alice\".\n    - Si el rectángulo de Bob tiene un área más grande, devuelve \"Bob\".\n    \n    Ejemplos:\n    >>> CompareArea(5, 4, 6)\n    \"Alice\"\n    \n    >>> CompareArea(7, 5, 10)\n    \"Bob\"",
      "arb": "يحدد الشكل الهندسي الذي له مساحة أكبر: مربع أليس بطول ضلع a، أو مستطيل بوب بأضلاع b و c.\n    - إذا كان لمربع أليس مساحة أكبر، أعد \"Alice\".\n    - إذا كان لمستطيل بوب مساحة أكبر، أعد \"Bob\".\n    \n    أمثلة:\n    >>> CompareArea(5, 4, 6)\n    \"Alice\"\n    \n    >>> CompareArea(7, 5, 10)\n    \"Bob\"",
      "sw": "Inabainisha ni umbo gani la kijiometri lina eneo kubwa zaidi: mraba wa Alice wenye urefu wa upande a, au mstatili wa Bob wenye pande b na c.\n- Ikiwa mraba wa Alice una eneo kubwa zaidi, rudisha \"Alice\".\n- Ikiwa mstatili wa Bob una eneo kubwa zaidi, rudisha \"Bob\".\n\nMifano:\n>>> CompareArea(5, 4, 6)\n\"Alice\"\n\n>>> CompareArea(7, 5, 10)\n\"Bob\"",
      "tr": "Alice'in kenar uzunluğu a olan karesinin mi, yoksa Bob'un kenarları b ve c olan dikdörtgeninin mi daha büyük bir alana sahip olduğunu belirler:\n- Eğer Alice'in karesi daha büyük bir alana sahipse, \"Alice\" döndürün.\n- Eğer Bob'un dikdörtgeni daha büyük bir alana sahipse, \"Bob\" döndürün.\n\nÖrnekler:\n>>> CompareArea(5, 4, 6)\n\"Alice\"\n\n>>> CompareArea(7, 5, 10)\n\"Bob\"",
      "vi": "Xác định hình dạng hình học của ai có diện tích lớn hơn: hình vuông của Alice với chiều dài cạnh a, hay hình chữ nhật của Bob với các cạnh b và c.\n- Nếu hình vuông của Alice có diện tích lớn hơn, trả về \"Alice\".\n- Nếu hình chữ nhật của Bob có diện tích lớn hơn, trả về \"Bob\".\n    \nVí dụ:\n>>> CompareArea(5, 4, 6)\n\"Alice\"\n\n>>> CompareArea(7, 5, 10)\n\"Bob\""
    },
    "docstring_bertscore": {
      "es": "0.9842213984217316",
      "arb": "0.9941604654279553",
      "sw": "0.9913436879944996",
      "tr": "0.9443622398594606",
      "vi": "0.9874821147568004"
    }
  },
  {
    "task_id": "C#/45",
    "prompt": {
      "es": "using System;\nusing System.Collections.Generic;\nusing System.Diagnostics;\n\nclass Program\n{\n\n/* Encuentra M enteros positivos que suman N y tienen el producto máximo posible. Si existen múltiples soluciones,\n   devuelve la secuencia lexicográficamente más pequeña.\n    >>> MaxProductPartition(6, 3)\n    [2, 2, 2]\n\n*/\n\n\n    public static List<int> MaxProductPartition(int N, int M)",
      "arb": "using System;\nusing System.Collections.Generic;\nusing System.Diagnostics;\n\nclass Program\n{\n\n/* يجد M من الأعداد الصحيحة الموجبة التي مجموعها N وتحقق أكبر حاصل ضرب ممكن. إذا وجدت حلول متعددة، \n   يعيد الحل الذي يحتوي على التسلسل الأصغر ترتيبًا لغويًا.\n    >>> MaxProductPartition(6, 3)\n    [2, 2, 2]\n\n*/\n\n\n    public static List<int> MaxProductPartition(int N, int M)",
      "sw": "using System;\nusing System.Collections.Generic;\nusing System.Diagnostics;\n\nclass Program\n{\n\n/* Inapata nambari M za asili ambazo jumla yake ni N na zina bidhaa kubwa zaidi iwezekanavyo. Ikiwa suluhisho nyingi zipo,\n   inarudisha ile iliyo na mlolongo mdogo zaidi kwa mpangilio wa alfabeti.\n    >>> MaxProductPartition(6, 3)\n    [2, 2, 2]\n\n*/\n\n\n    public static List<int> MaxProductPartition(int N, int M)",
      "tr": "using System;\nusing System.Collections.Generic;\nusing System.Diagnostics;\n\nclass Program\n{\n\n/* N toplamına sahip ve maksimum olası çarpıma sahip M pozitif tam sayı bulur. Birden fazla çözüm varsa, \n   sözlük sırasına göre en küçük olan diziyi döndürür.\n    >>> MaxProductPartition(6, 3)\n    [2, 2, 2]\n\n*/\n\n\n    public static List<int> MaxProductPartition(int N, int M)",
      "vi": "using System;\nusing System.Collections.Generic;\nusing System.Diagnostics;\n\nclass Program\n{\n\n/* Tìm M số nguyên dương mà tổng bằng N và có tích lớn nhất có thể. Nếu có nhiều giải pháp, \n   trả về giải pháp có dãy từ điển nhỏ nhất.\n    >>> MaxProductPartition(6, 3)\n    [2, 2, 2]\n\n*/\n\n\n    public static List<int> MaxProductPartition(int N, int M)"
    },
    "prompt_bertscore": {
      "es": "0.9760072376444148",
      "arb": "0.9577660166020758",
      "sw": "0.9247240513473033",
      "tr": "0.9403320294282627",
      "vi": "0.956463001302487"
    },
    "canonical_solution": "    {\n        List<int> partition = new List<int>();\n\n        // If M is greater than N, then we'll have M numbers of 1\n        if (M >= N)\n        {\n            for (int i = 0; i < N; i++)\n            {\n                partition.Add(1);\n            }\n            return partition;\n        }\n\n        // Otherwise, distribute the sum N among M numbers\n        int quotient = N / M;\n        int remainder = N % M;\n\n        // Add M-remainder numbers of quotient\n        for (int i = 0; i < M - remainder; i++)\n        {\n            partition.Add(quotient);\n        }\n\n        // Add remainder numbers of quotient + 1\n        for (int i = 0; i < remainder; i++)\n        {\n            partition.Add(quotient + 1);\n        }\n\n        return partition;\n    }",
    "instruction": {
      "es": "public static List<int> MaxProductPartition(int N, int M)\n    {\n        List<int> partition = new List<int>();\n\n        // If M is greater than N, then we'll have M numbers of 1\n        if (M >= N)\n        {\n            for (int i = 0; i < N; i++)\n            {\n                partition.Add(1);\n            }\n            return partition;\n        }\n\n        // Otherwise, distribute the sum N among M numbers\n        int quotient = N / M;\n        int remainder = N % M;\n\n        // Add M-remainder numbers of quotient\n        for (int i = 0; i < M - remainder; i++)\n        {\n            partition.Add(quotient);\n        }\n\n        // Add remainder numbers of quotient + 1\n        for (int i = 0; i < remainder; i++)\n        {\n            partition.Add(quotient + 1);\n        }\n\n        return partition;\n    }\n\nProporcione una descripción concisa en lenguaje natural (docstring) del código C# en español utilizando como máximo 500 caracteres.",
      "arb": "public static List<int> MaxProductPartition(int N, int M)\n    {\n        List<int> partition = new List<int>();\n\n        // If M is greater than N, then we'll have M numbers of 1\n        if (M >= N)\n        {\n            for (int i = 0; i < N; i++)\n            {\n                partition.Add(1);\n            }\n            return partition;\n        }\n\n        // Otherwise, distribute the sum N among M numbers\n        int quotient = N / M;\n        int remainder = N % M;\n\n        // Add M-remainder numbers of quotient\n        for (int i = 0; i < M - remainder; i++)\n        {\n            partition.Add(quotient);\n        }\n\n        // Add remainder numbers of quotient + 1\n        for (int i = 0; i < remainder; i++)\n        {\n            partition.Add(quotient + 1);\n        }\n\n        return partition;\n    }\n\nيرجى تقديم وصف موجز بلغة طبيعية (docstring) للكود المكتوب بلغة C# باللغة العربية الفصحى، بحيث لا يتجاوز 500 حرف.",
      "sw": "public static List<int> MaxProductPartition(int N, int M)\n    {\n        List<int> partition = new List<int>();\n\n        // If M is greater than N, then we'll have M numbers of 1\n        if (M >= N)\n        {\n            for (int i = 0; i < N; i++)\n            {\n                partition.Add(1);\n            }\n            return partition;\n        }\n\n        // Otherwise, distribute the sum N among M numbers\n        int quotient = N / M;\n        int remainder = N % M;\n\n        // Add M-remainder numbers of quotient\n        for (int i = 0; i < M - remainder; i++)\n        {\n            partition.Add(quotient);\n        }\n\n        // Add remainder numbers of quotient + 1\n        for (int i = 0; i < remainder; i++)\n        {\n            partition.Add(quotient + 1);\n        }\n\n        return partition;\n    }\n\nToa maelezo mafupi ya lugha asilia (docstring) ya msimbo wa C# kwa Kiswahili kwa kutumia herufi zisizozidi 500.",
      "tr": "public static List<int> MaxProductPartition(int N, int M)\n    {\n        List<int> partition = new List<int>();\n\n        // If M is greater than N, then we'll have M numbers of 1\n        if (M >= N)\n        {\n            for (int i = 0; i < N; i++)\n            {\n                partition.Add(1);\n            }\n            return partition;\n        }\n\n        // Otherwise, distribute the sum N among M numbers\n        int quotient = N / M;\n        int remainder = N % M;\n\n        // Add M-remainder numbers of quotient\n        for (int i = 0; i < M - remainder; i++)\n        {\n            partition.Add(quotient);\n        }\n\n        // Add remainder numbers of quotient + 1\n        for (int i = 0; i < remainder; i++)\n        {\n            partition.Add(quotient + 1);\n        }\n\n        return partition;\n    }\n\nC# kodunun işlevini açıklayan en fazla 500 karakterlik öz bir doğal dil açıklaması (docstring) sağlayın.",
      "vi": "public static List<int> MaxProductPartition(int N, int M)\n    {\n        List<int> partition = new List<int>();\n\n        // If M is greater than N, then we'll have M numbers of 1\n        if (M >= N)\n        {\n            for (int i = 0; i < N; i++)\n            {\n                partition.Add(1);\n            }\n            return partition;\n        }\n\n        // Otherwise, distribute the sum N among M numbers\n        int quotient = N / M;\n        int remainder = N % M;\n\n        // Add M-remainder numbers of quotient\n        for (int i = 0; i < M - remainder; i++)\n        {\n            partition.Add(quotient);\n        }\n\n        // Add remainder numbers of quotient + 1\n        for (int i = 0; i < remainder; i++)\n        {\n            partition.Add(quotient + 1);\n        }\n\n        return partition;\n    }\n\nCung cấp mô tả ngắn gọn bằng ngôn ngữ tự nhiên (docstring) cho mã C# bằng tiếng Việt, sử dụng tối đa 500 ký tự."
    },
    "instruction_bertscore": {
      "es": "0.9702167647764858",
      "arb": "0.8829437397396628",
      "sw": "0.9446027812508938",
      "tr": "0.8787129126236197",
      "vi": "0.9298151466436084"
    },
    "level": "",
    "test": "    static void Main()\n    {\n\n        Debug.Assert(MaxProductPartition(6, 3).SequenceEqual(new List<int> { 2, 2, 2 }));\n        Debug.Assert(MaxProductPartition(8, 3).SequenceEqual(new List<int> { 2, 3, 3 }));\n        Debug.Assert(MaxProductPartition(10, 2).SequenceEqual(new List<int> { 5, 5 }));\n        Debug.Assert(MaxProductPartition(7, 3).SequenceEqual(new List<int> { 2, 2, 3 }));\n\n    }\n}\n",
    "entry_point": "MaxProductPartition",
    "signature": "public static List<int> MaxProductPartition(int N, int M)",
    "docstring": {
      "es": "Encuentra M enteros positivos que suman N y tienen el producto máximo posible. Si existen múltiples soluciones, \n   devuelve la secuencia lexicográficamente más pequeña.\n    >>> MaxProductPartition(6, 3)\n    [2, 2, 2]",
      "arb": "يعثر على M من الأعداد الصحيحة الموجبة التي مجموعها N ولها أكبر حاصل ضرب ممكن. إذا كانت هناك حلول متعددة، \n   يعيد الحل الذي يحتوي على التسلسل الأصغر حسب الترتيب المعجمي.\n    >>> MaxProductPartition(6, 3)\n    [2, 2, 2]",
      "sw": "Inapata nambari M za asili ambazo jumla yake ni N na zina bidhaa kubwa zaidi inayowezekana. Ikiwa suluhisho nyingi zipo, \n   inarudisha ile iliyo na mlolongo mdogo zaidi kwa mpangilio wa herufi.\n    >>> MaxProductPartition(6, 3)\n    [2, 2, 2]",
      "tr": "M pozitif tam sayıyı bulur, bu sayılar N'ye toplamı verir ve mümkün olan en yüksek çarpıma sahiptir. Birden fazla çözüm varsa, \n   sözlük sırasına göre en küçük diziyi döndürür.\n    >>> MaxProductPartition(6, 3)\n    [2, 2, 2]",
      "vi": "Tìm M số nguyên dương có tổng bằng N và có tích lớn nhất có thể. Nếu tồn tại nhiều giải pháp, \n   trả về giải pháp có dãy từ điển nhỏ nhất.\n    >>> MaxProductPartition(6, 3)\n    [2, 2, 2]"
    },
    "docstring_bertscore": {
      "es": "0.9508423574103427",
      "arb": "0.9111327675249911",
      "sw": "0.9036026897799584",
      "tr": "0.8490510405629178",
      "vi": "0.9301780443497593"
    }
  },
  {
    "task_id": "C#/46",
    "prompt": {
      "es": "using System;\nusing System.Collections.Generic;\nusing System.Diagnostics;\n\nclass Program\n{\n\n/* Cuenta el número de caracteres en una cadena de título dada, excluyendo espacios y caracteres de nueva línea.\n    >>> CountTitleCharacters(\"234\")\n    3\n    >>> CountTitleCharacters(\"Ca 45\")\n    4\n    >>> CountTitleCharacters(\"Hello World\\n\")\n    10\n    >>> CountTitleCharacters(\" 123 \")\n    3\n*/\n\nstatic int CountTitleCharacters(string title)",
      "arb": "using System;\nusing System.Collections.Generic;\nusing System.Diagnostics;\n\nclass Program\n{\n\n/* يحسب عدد الأحرف في سلسلة عنوان معينة، باستثناء المسافات وأحرف السطر الجديد.\n    >>> CountTitleCharacters(\"234\")\n    3\n    >>> CountTitleCharacters(\"Ca 45\")\n    4\n    >>> CountTitleCharacters(\"Hello World\\n\")\n    10\n    >>> CountTitleCharacters(\" 123 \")\n    3\n*/\n\nstatic int CountTitleCharacters(string title)",
      "sw": "using System;\nusing System.Collections.Generic;\nusing System.Diagnostics;\n\nclass Program\n{\n\n/* Inahesabu idadi ya herufi katika kichwa kilichopewa, bila kujumuisha nafasi na herufi za kurudi mstari mpya.\n    >>> CountTitleCharacters(\"234\")\n    3\n    >>> CountTitleCharacters(\"Ca 45\")\n    4\n    >>> CountTitleCharacters(\"Hello World\\n\")\n    10\n    >>> CountTitleCharacters(\" 123 \")\n    3\n*/\n\nstatic int CountTitleCharacters(string title)",
      "tr": "using System;\nusing System.Collections.Generic;\nusing System.Diagnostics;\n\nclass Program\n{\n\n/* Verilen bir başlık dizesindeki karakterlerin sayısını, boşluklar ve yeni satır karakterleri hariç tutarak sayar.\n    >>> CountTitleCharacters(\"234\")\n    3\n    >>> CountTitleCharacters(\"Ca 45\")\n    4\n    >>> CountTitleCharacters(\"Hello World\\n\")\n    10\n    >>> CountTitleCharacters(\" 123 \")\n    3\n*/\n\nstatic int CountTitleCharacters(string title)",
      "vi": "using System;\nusing System.Collections.Generic;\nusing System.Diagnostics;\n\nclass Program\n{\n\n/* Đếm số ký tự trong một chuỗi tiêu đề đã cho, không bao gồm khoảng trắng và ký tự xuống dòng.\n    >>> CountTitleCharacters(\"234\")\n    3\n    >>> CountTitleCharacters(\"Ca 45\")\n    4\n    >>> CountTitleCharacters(\"Hello World\\n\")\n    10\n    >>> CountTitleCharacters(\" 123 \")\n    3\n*/\n\nstatic int CountTitleCharacters(string title)"
    },
    "prompt_bertscore": {
      "es": "1",
      "arb": "0.9898009258250016",
      "sw": "0.9912525166496046",
      "tr": "1",
      "vi": "0.9955326041001443"
    },
    "canonical_solution": "{\n    int count = 0;\n    foreach (char c in title)\n    {\n        if (!char.IsWhiteSpace(c)) // Checks for any whitespace character including space and newline.\n        {\n            count++;\n        }\n    }\n    return count;\n}",
    "instruction": {
      "es": "static int CountTitleCharacters(string title)\n{\n    int count = 0;\n    foreach (char c in title)\n    {\n        if (!char.IsWhiteSpace(c)) // Checks for any whitespace character including space and newline.\n        {\n            count++;\n        }\n    }\n    return count;\n}\n\nProporcione una descripción concisa en lenguaje natural (docstring) del código C# en español utilizando un máximo de 500 caracteres.",
      "arb": "static int CountTitleCharacters(string title)\n{\n    int count = 0;\n    foreach (char c in title)\n    {\n        if (!char.IsWhiteSpace(c)) // Checks for any whitespace character including space and newline.\n        {\n            count++;\n        }\n    }\n    return count;\n}\n\nيرجى تقديم وصف موجز بلغة طبيعية (docstring) للشفرة البرمجية بلغة C# باللغة العربية الفصحى باستخدام ما لا يزيد عن 500 حرف.",
      "sw": "static int CountTitleCharacters(string title)\n{\n    int count = 0;\n    foreach (char c in title)\n    {\n        if (!char.IsWhiteSpace(c)) // Checks for any whitespace character including space and newline.\n        {\n            count++;\n        }\n    }\n    return count;\n}\n\nToa maelezo mafupi ya lugha ya asili (docstring) ya msimbo wa C# kwa Kiswahili kwa kutumia herufi zisizozidi 500.",
      "tr": "static int CountTitleCharacters(string title)\n{\n    int count = 0;\n    foreach (char c in title)\n    {\n        if (!char.IsWhiteSpace(c)) // Checks for any whitespace character including space and newline.\n        {\n            count++;\n        }\n    }\n    return count;\n}\n\nAşağıdaki C# kodunun işlevselliğini açıklayan, en fazla 500 karakter uzunluğunda özlü bir doğal dil tanımı (docstring) sağlayın.",
      "vi": "static int CountTitleCharacters(string title)\n{\n    int count = 0;\n    foreach (char c in title)\n    {\n        if (!char.IsWhiteSpace(c)) // Checks for any whitespace character including space and newline.\n        {\n            count++;\n        }\n    }\n    return count;\n}\n\nCung cấp mô tả ngắn gọn bằng ngôn ngữ tự nhiên (docstring) cho mã C# bằng tiếng Việt với tối đa 500 ký tự."
    },
    "instruction_bertscore": {
      "es": "0.9702167647764858",
      "arb": "0.9180298102456654",
      "sw": "0.918288824262535",
      "tr": "0.8622345362129653",
      "vi": "0.9066002208601559"
    },
    "level": "",
    "test": "    static void Main()\n    {\n        Debug.Assert(CountTitleCharacters(\"234\") == 3);\n        Debug.Assert(CountTitleCharacters(\"Ca 45\") == 4);\n        Debug.Assert(CountTitleCharacters(\"Hello World\\n\") == 10);\n        Debug.Assert(CountTitleCharacters(\" 123 \") == 3);\n        Debug.Assert(CountTitleCharacters(\"\\nNew\\tLine\") == 7);\n\n    }\n}",
    "entry_point": "CountTitleCharacters",
    "signature": "static int CountTitleCharacters(string title)",
    "docstring": {
      "es": "Cuenta el número de caracteres en una cadena de título dada, excluyendo espacios y caracteres de nueva línea.\n    >>> CountTitleCharacters(\"234\")\n    3\n    >>> CountTitleCharacters(\"Ca 45\")\n    4\n    >>> CountTitleCharacters(\"Hello World\\n\")\n    10\n    >>> CountTitleCharacters(\" 123 \")\n    3",
      "arb": "يقوم بحساب عدد الأحرف في سلسلة عنوان معينة، باستثناء المسافات وأحرف السطر الجديد.\n    >>> CountTitleCharacters(\"234\")\n    3\n    >>> CountTitleCharacters(\"Ca 45\")\n    4\n    >>> CountTitleCharacters(\"Hello World\\n\")\n    10\n    >>> CountTitleCharacters(\" 123 \")\n    3",
      "sw": "Inahesabu idadi ya herufi katika mfuatano wa maandishi wa kichwa kilichopewa, bila kujumuisha nafasi na herufi za kurudi kwenye mstari mpya.\n    >>> CountTitleCharacters(\"234\")\n    3\n    >>> CountTitleCharacters(\"Ca 45\")\n    4\n    >>> CountTitleCharacters(\"Hello World\\n\")\n    10\n    >>> CountTitleCharacters(\" 123 \")\n    3",
      "tr": "Verilen bir başlık dizesindeki karakter sayısını, boşluk ve yeni satır karakterleri hariç, sayar.\n    >>> CountTitleCharacters(\"234\")\n    3\n    >>> CountTitleCharacters(\"Ca 45\")\n    4\n    >>> CountTitleCharacters(\"Hello World\\n\")\n    10\n    >>> CountTitleCharacters(\" 123 \")\n    3",
      "vi": "Đếm số ký tự trong một chuỗi tiêu đề đã cho, không bao gồm các ký tự khoảng trắng và ký tự xuống dòng.\n    >>> CountTitleCharacters(\"234\")\n    3\n    >>> CountTitleCharacters(\"Ca 45\")\n    4\n    >>> CountTitleCharacters(\"Hello World\\n\")\n    10\n    >>> CountTitleCharacters(\" 123 \")\n    3"
    },
    "docstring_bertscore": {
      "es": "0.9919220996640732",
      "arb": "0.98208870402056",
      "sw": "0.9882216156653932",
      "tr": "1",
      "vi": "0.9819659504450804"
    }
  },
  {
    "task_id": "C#/47",
    "prompt": {
      "es": "using System;\nusing System.Collections.Generic;\nusing System.Diagnostics;\n\nclass Program\n{\n\n/* Determina el número de estudiantes que se han inscrito tanto en el Curso A como en el Curso B.\n    Dadas dos listas de IDs de estudiantes para cada curso, esta función cuenta cuántos IDs aparecen en ambas listas.\n    - courseAStudents: List<int> que representa los IDs de estudiantes inscritos en el Curso A.\n    - courseBStudents: List<int> que representa los IDs de estudiantes inscritos en el Curso B.\n    \n    Ejemplo de uso:\n    >>> CountCommonStudents(new List<int> {1, 2, 3, 4, 5}, new List<int> {1, 3, 4, 5, 6})\n    4\n    >>> CountCommonStudents(new List<int> {7, 8, 9}, new List<int> {10, 11, 12})\n    0\n*/\n\n\nstatic int CountCommonStudents(List<int> courseAStudents, List<int> courseBStudents)",
      "arb": "using System;\nusing System.Collections.Generic;\nusing System.Diagnostics;\n\nclass Program\n{\n\n/* يحدد عدد الطلاب الذين سجلوا في كل من الدورة A والدورة B.\n    بالنظر إلى قائمتين من معرفات الطلاب لكل دورة، تقوم هذه الدالة بحساب عدد المعرفات التي تظهر في كلتا القائمتين.\n    - courseAStudents: List<int> تمثل معرفات الطلاب المسجلين في الدورة A.\n    - courseBStudents: List<int> تمثل معرفات الطلاب المسجلين في الدورة B.\n    \n    مثال على الاستخدام:\n    >>> CountCommonStudents(new List<int> {1, 2, 3, 4, 5}, new List<int> {1, 3, 4, 5, 6})\n    4\n    >>> CountCommonStudents(new List<int> {7, 8, 9}, new List<int> {10, 11, 12})\n    0\n*/\n\n\nstatic int CountCommonStudents(List<int> courseAStudents, List<int> courseBStudents)",
      "sw": "using System;\nusing System.Collections.Generic;\nusing System.Diagnostics;\n\nclass Program\n{\n\n/* Huamua idadi ya wanafunzi ambao wamejiandikisha katika Kozi A na Kozi B.\n    Ukipewa orodha mbili za vitambulisho vya wanafunzi kwa kila kozi, kazi hii huhesabu ni vitambulisho vingapi vinavyoonekana katika orodha zote mbili.\n    - courseAStudents: List<int> inayowakilisha vitambulisho vya wanafunzi waliojiandikisha katika Kozi A.\n    - courseBStudents: List<int> inayowakilisha vitambulisho vya wanafunzi waliojiandikisha katika Kozi B.\n    \n    Mfano wa matumizi:\n    >>> CountCommonStudents(new List<int> {1, 2, 3, 4, 5}, new List<int> {1, 3, 4, 5, 6})\n    4\n    >>> CountCommonStudents(new List<int> {7, 8, 9}, new List<int> {10, 11, 12})\n    0\n*/\n\n\nstatic int CountCommonStudents(List<int> courseAStudents, List<int> courseBStudents)",
      "tr": "using System;\nusing System.Collections.Generic;\nusing System.Diagnostics;\n\nclass Program\n{\n\n/* Hem Kurs A'ya hem de Kurs B'ye kayıtlı olan öğrenci sayısını belirler.\n    Her kurs için öğrenci kimliklerinin iki listesi verildiğinde, bu işlev her iki listede de görünen kimliklerin sayısını sayar.\n    - courseAStudents: Kurs A'ya kayıtlı öğrenci kimliklerini temsil eden List<int>.\n    - courseBStudents: Kurs B'ye kayıtlı öğrenci kimliklerini temsil eden List<int>.\n    \n    Örnek kullanım:\n    >>> CountCommonStudents(new List<int> {1, 2, 3, 4, 5}, new List<int> {1, 3, 4, 5, 6})\n    4\n    >>> CountCommonStudents(new List<int> {7, 8, 9}, new List<int> {10, 11, 12})\n    0\n*/\n\n\nstatic int CountCommonStudents(List<int> courseAStudents, List<int> courseBStudents)",
      "vi": "using System;\nusing System.Collections.Generic;\nusing System.Diagnostics;\n\nclass Program\n{\n\n/* Xác định số lượng sinh viên đã đăng ký cả Khóa học A và Khóa học B.\n    Cho hai danh sách ID sinh viên cho mỗi khóa học, hàm này đếm có bao nhiêu ID xuất hiện trong cả hai danh sách.\n    - courseAStudents: List<int> đại diện cho ID sinh viên đã đăng ký Khóa học A.\n    - courseBStudents: List<int> đại diện cho ID sinh viên đã đăng ký Khóa học B.\n    \n    Ví dụ sử dụng:\n    >>> CountCommonStudents(new List<int> {1, 2, 3, 4, 5}, new List<int> {1, 3, 4, 5, 6})\n    4\n    >>> CountCommonStudents(new List<int> {7, 8, 9}, new List<int> {10, 11, 12})\n    0\n*/\n\n\nstatic int CountCommonStudents(List<int> courseAStudents, List<int> courseBStudents)"
    },
    "prompt_bertscore": {
      "es": "0.9801850304487216",
      "arb": "0.9714196703640331",
      "sw": "0.9788786384326552",
      "tr": "0.9936591223462232",
      "vi": "0.9788555973084552"
    },
    "canonical_solution": "{\n    HashSet<int> courseASet = new HashSet<int>(courseAStudents);\n    int commonStudents = 0;\n    foreach (int studentId in courseBStudents)\n    {\n        if (courseASet.Contains(studentId))\n        {\n            commonStudents++;\n        }\n    }\n    return commonStudents;\n}",
    "instruction": {
      "es": "static int CountCommonStudents(List<int> courseAStudents, List<int> courseBStudents)\n{\n    HashSet<int> courseASet = new HashSet<int>(courseAStudents);\n    int commonStudents = 0;\n    foreach (int studentId in courseBStudents)\n    {\n        if (courseASet.Contains(studentId))\n        {\n            commonStudents++;\n        }\n    }\n    return commonStudents;\n}\n\nProporcione una descripción concisa en lenguaje natural (docstring) del código C# en español utilizando como máximo 500 caracteres.",
      "arb": "static int CountCommonStudents(List<int> courseAStudents, List<int> courseBStudents)\n{\n    HashSet<int> courseASet = new HashSet<int>(courseAStudents);\n    int commonStudents = 0;\n    foreach (int studentId in courseBStudents)\n    {\n        if (courseASet.Contains(studentId))\n        {\n            commonStudents++;\n        }\n    }\n    return commonStudents;\n}\n\nيرجى تقديم وصف موجز بلغة طبيعية (docstring) للكود المكتوب بلغة C# باللغة العربية الفصحى، بحيث لا يتجاوز 500 حرف.",
      "sw": "static int CountCommonStudents(List<int> courseAStudents, List<int> courseBStudents)\n{\n    HashSet<int> courseASet = new HashSet<int>(courseAStudents);\n    int commonStudents = 0;\n    foreach (int studentId in courseBStudents)\n    {\n        if (courseASet.Contains(studentId))\n        {\n            commonStudents++;\n        }\n    }\n    return commonStudents;\n}\n\nToa maelezo mafupi ya lugha asilia (docstring) ya msimbo wa C# kwa Kiswahili kwa kutumia herufi zisizozidi 500.",
      "tr": "static int CountCommonStudents(List<int> courseAStudents, List<int> courseBStudents)\n{\n    HashSet<int> courseASet = new HashSet<int>(courseAStudents);\n    int commonStudents = 0;\n    foreach (int studentId in courseBStudents)\n    {\n        if (courseASet.Contains(studentId))\n        {\n            commonStudents++;\n        }\n    }\n    return commonStudents;\n}\n\nAşağıdaki C# kodunun Türkçe olarak en fazla 500 karakter kullanarak kısa bir doğal dil açıklamasını (docstring) sağlayın.",
      "vi": "static int CountCommonStudents(List<int> courseAStudents, List<int> courseBStudents)\n{\n    HashSet<int> courseASet = new HashSet<int>(courseAStudents);\n    int commonStudents = 0;\n    foreach (int studentId in courseBStudents)\n    {\n        if (courseASet.Contains(studentId))\n        {\n            commonStudents++;\n        }\n    }\n    return commonStudents;\n}\n\nCung cấp mô tả ngắn gọn bằng ngôn ngữ tự nhiên (docstring) cho mã C# bằng tiếng Việt, không quá 500 ký tự."
    },
    "instruction_bertscore": {
      "es": "0.9702167647764858",
      "arb": "0.8716935135882278",
      "sw": "0.9446027812508938",
      "tr": "0.8916963874799652",
      "vi": "0.9187315713818617"
    },
    "level": "",
    "test": "    static void Main()\n    {\n        Debug.Assert(CountCommonStudents(new List<int> { 1, 2, 3, 4, 5 }, new List<int> { 1, 3, 4, 5, 6 }) == 4);\n        Debug.Assert(CountCommonStudents(new List<int> { 7, 8, 9 }, new List<int> { 10, 11, 12 }) == 0);\n        Debug.Assert(CountCommonStudents(new List<int> { 1, 3, 5, 7, 9 }, new List<int> { 2, 4, 6, 8, 10 }) == 0);\n        Debug.Assert(CountCommonStudents(new List<int> { 2, 4, 6, 8 }, new List<int> { 1, 3, 5, 7, 8 }) == 1);\n\n\n    }\n}",
    "entry_point": "CountCommonStudents",
    "signature": "static int CountCommonStudents(List<int> courseAStudents, List<int> courseBStudents)",
    "docstring": {
      "es": "Determina el número de estudiantes que se han inscrito tanto en el Curso A como en el Curso B.  \n    Dadas dos listas de IDs de estudiantes para cada curso, esta función cuenta cuántos IDs aparecen en ambas listas.\n    - courseAStudents: List<int> que representa los IDs de estudiantes inscritos en el Curso A.\n    - courseBStudents: List<int> que representa los IDs de estudiantes inscritos en el Curso B.\n    \n    Ejemplo de uso:\n    >>> CountCommonStudents(new List<int> {1, 2, 3, 4, 5}, new List<int> {1, 3, 4, 5, 6})\n    4\n    >>> CountCommonStudents(new List<int> {7, 8, 9}, new List<int> {10, 11, 12})\n    0",
      "arb": "يحدد عدد الطلاب الذين سجلوا في كل من الدورة A والدورة B.  \n    بالنظر إلى قائمتين من معرفات الطلاب لكل دورة، تقوم هذه الدالة بحساب عدد المعرفات التي تظهر في كلتا القائمتين.\n    - courseAStudents: List<int> تمثل معرفات الطلاب المسجلين في الدورة A.\n    - courseBStudents: List<int> تمثل معرفات الطلاب المسجلين في الدورة B.\n    \n    مثال على الاستخدام:\n    >>> CountCommonStudents(new List<int> {1, 2, 3, 4, 5}, new List<int> {1, 3, 4, 5, 6})\n    4\n    >>> CountCommonStudents(new List<int> {7, 8, 9}, new List<int> {10, 11, 12})\n    0",
      "sw": "Inabainisha idadi ya wanafunzi ambao wamejiandikisha katika Kozi A na Kozi B.\n    Ukipewa orodha mbili za vitambulisho vya wanafunzi kwa kila kozi, kazi hii inahesabu ni vitambulisho vingapi vinavyoonekana katika orodha zote mbili.\n    - courseAStudents: List<int> inayowakilisha vitambulisho vya wanafunzi waliosajiliwa katika Kozi A.\n    - courseBStudents: List<int> inayowakilisha vitambulisho vya wanafunzi waliosajiliwa katika Kozi B.\n    \n    Mfano wa matumizi:\n    >>> CountCommonStudents(new List<int> {1, 2, 3, 4, 5}, new List<int> {1, 3, 4, 5, 6})\n    4\n    >>> CountCommonStudents(new List<int> {7, 8, 9}, new List<int> {10, 11, 12})\n    0",
      "tr": "Her iki Kurs A ve Kurs B'ye kayıtlı olan öğrenci sayısını belirler.\n    Her kurs için iki öğrenci kimlik listesi verildiğinde, bu fonksiyon her iki listede de kaç kimliğin göründüğünü sayar.\n    - courseAStudents: Kurs A'ya kayıtlı öğrenci kimliklerini temsil eden List<int>.\n    - courseBStudents: Kurs B'ye kayıtlı öğrenci kimliklerini temsil eden List<int>.\n    \n    Örnek kullanım:\n    >>> CountCommonStudents(new List<int> {1, 2, 3, 4, 5}, new List<int> {1, 3, 4, 5, 6})\n    4\n    >>> CountCommonStudents(new List<int> {7, 8, 9}, new List<int> {10, 11, 12})\n    0",
      "vi": "Xác định số lượng sinh viên đã đăng ký cả Khóa học A và Khóa học B.  \nDựa trên hai danh sách mã số sinh viên cho mỗi khóa học, hàm này đếm có bao nhiêu mã số xuất hiện trong cả hai danh sách.  \n- courseAStudents: List<int> đại diện cho mã số sinh viên đã đăng ký Khóa học A.  \n- courseBStudents: List<int> đại diện cho mã số sinh viên đã đăng ký Khóa học B.  \n\nVí dụ sử dụng:  \n>>> CountCommonStudents(new List<int> {1, 2, 3, 4, 5}, new List<int> {1, 3, 4, 5, 6})  \n4  \n>>> CountCommonStudents(new List<int> {7, 8, 9}, new List<int> {10, 11, 12})  \n0  "
    },
    "docstring_bertscore": {
      "es": "0.9770826225273377",
      "arb": "0.9635209346317997",
      "sw": "0.9713819305916365",
      "tr": "0.9900869535736918",
      "vi": "0.9815466417107158"
    }
  },
  {
    "task_id": "C#/48",
    "prompt": {
      "es": "using System;\nusing System.Collections.Generic;\nusing System.Diagnostics;\n\nclass Program\n{\n\n/* Calcula el número de manzanas enteras que quedan después de comer manzanas durante un tiempo determinado.\n   Cada manzana toma una cantidad específica de tiempo para comer, y la función devuelve cuántas manzanas enteras quedan sin comer.\n   - totalApples: el número total de manzanas disponibles\n   - timePerApple: el tiempo que se tarda en comer una manzana (timePerApple>=0)\n   - timeElapsed: el tiempo total transcurrido\n\n   Ejemplos:\n   >>> RemainingApples(50, 10, 200)\n   30\n\n*/\n\nstatic int RemainingApples(int totalApples, int timePerApple, int timeElapsed)",
      "arb": "using System;\nusing System.Collections.Generic;\nusing System.Diagnostics;\n\nclass Program\n{\n\n/* يحسب عدد التفاح الكامل المتبقي بعد أكل التفاح لفترة زمنية معينة.\n   يستغرق كل تفاحة وقتًا محددًا للأكل، وتعيد الدالة عدد التفاح الكامل المتبقي غير المأكول.\n   - totalApples: العدد الإجمالي للتفاح المتاح\n   - timePerApple: الوقت الذي يستغرقه أكل تفاحة واحدة (timePerApple>=0)\n   - timeElapsed: الوقت الكلي المنقضي\n\n   أمثلة:\n   >>> RemainingApples(50, 10, 200)\n   30\n\n*/\n\nstatic int RemainingApples(int totalApples, int timePerApple, int timeElapsed)",
      "sw": "using System;\nusing System.Collections.Generic;\nusing System.Diagnostics;\n\nclass Program\n{\n\n/* Hukokotoa idadi ya maapulo kamili yaliyobaki baada ya kula maapulo kwa muda fulani.\n   Kila apulo inachukua muda maalum kuliwa, na kazi hii inarudisha ni maapulo mangapi kamili yaliyobaki bila kuliwa.\n   - totalApples: jumla ya maapulo yanayopatikana\n   - timePerApple: muda unaochukua kula apulo moja (timePerApple>=0)\n   - timeElapsed: muda wote uliopita\n\n   Mifano:\n   >>> RemainingApples(50, 10, 200)\n   30\n\n*/\n\nstatic int RemainingApples(int totalApples, int timePerApple, int timeElapsed)",
      "tr": "using System;\nusing System.Collections.Generic;\nusing System.Diagnostics;\n\nclass Program\n{\n\n/* Belirli bir süre boyunca elma yedikten sonra kalan bütün elmaların sayısını hesaplar.\n   Her bir elmayı yemek belirli bir süre alır ve fonksiyon kaç tane bütün elmanın yenmeden kaldığını döndürür.\n   - totalApples: mevcut toplam elma sayısı\n   - timePerApple: bir elmayı yemek için geçen süre (timePerApple>=0)\n   - timeElapsed: geçen toplam süre\n\n   Örnekler:\n   >>> RemainingApples(50, 10, 200)\n   30\n\n*/\n\nstatic int RemainingApples(int totalApples, int timePerApple, int timeElapsed)",
      "vi": "using System;\nusing System.Collections.Generic;\nusing System.Diagnostics;\n\nclass Program\n{\n\n/* Tính số lượng táo nguyên còn lại sau khi ăn táo trong một khoảng thời gian nhất định.\n   Mỗi quả táo mất một khoảng thời gian cụ thể để ăn, và hàm trả về số lượng táo nguyên còn lại chưa ăn.\n   - totalApples: tổng số lượng táo có sẵn\n   - timePerApple: thời gian để ăn một quả táo (timePerApple>=0)\n   - timeElapsed: tổng thời gian đã trôi qua\n\n   Ví dụ:\n   >>> RemainingApples(50, 10, 200)\n   30\n\n*/\n\nstatic int RemainingApples(int totalApples, int timePerApple, int timeElapsed)"
    },
    "prompt_bertscore": {
      "es": "0.9949134732024586",
      "arb": "0.9875667312991212",
      "sw": "0.9735648784792098",
      "tr": "0.9774677668361643",
      "vi": "0.9661730474793775"
    },
    "canonical_solution": "{\n    if (timePerApple == 0) return 0; // Prevent division by zero\n\n    // Calculate the number of apples consumed\n    int applesConsumed = timeElapsed / timePerApple;\n\n    // Calculate the remaining apples\n    int remainingApples = totalApples - applesConsumed;\n    if (timeElapsed % timePerApple >  0){\n        remainingApples-=1;\n    } \n    // Ensure remaining apples is non-negative\n    if (remainingApples < 0)\n    {\n        return 0;\n    }\n\n    return remainingApples;\n}",
    "instruction": {
      "es": "static int RemainingApples(int totalApples, int timePerApple, int timeElapsed)\n{\n    if (timePerApple == 0) return 0; // Prevent division by zero\n\n    // Calculate the number of apples consumed\n    int applesConsumed = timeElapsed / timePerApple;\n\n    // Calculate the remaining apples\n    int remainingApples = totalApples - applesConsumed;\n    if (timeElapsed % timePerApple >  0){\n        remainingApples-=1;\n    } \n    // Ensure remaining apples is non-negative\n    if (remainingApples < 0)\n    {\n        return 0;\n    }\n\n    return remainingApples;\n}\n\nProporcione una descripción concisa en lenguaje natural (docstring) del código C# en español utilizando como máximo 500 caracteres.",
      "arb": "static int RemainingApples(int totalApples, int timePerApple, int timeElapsed)\n{\n    if (timePerApple == 0) return 0; // Prevent division by zero\n\n    // Calculate the number of apples consumed\n    int applesConsumed = timeElapsed / timePerApple;\n\n    // Calculate the remaining apples\n    int remainingApples = totalApples - applesConsumed;\n    if (timeElapsed % timePerApple >  0){\n        remainingApples-=1;\n    } \n    // Ensure remaining apples is non-negative\n    if (remainingApples < 0)\n    {\n        return 0;\n    }\n\n    return remainingApples;\n}\n\nيرجى تقديم وصف موجز بلغة طبيعية (docstring) للكود المكتوب بلغة C# باللغة العربية الفصحى، بحيث لا يتجاوز 500 حرف.",
      "sw": "static int RemainingApples(int totalApples, int timePerApple, int timeElapsed)\n{\n    if (timePerApple == 0) return 0; // Prevent division by zero\n\n    // Calculate the number of apples consumed\n    int applesConsumed = timeElapsed / timePerApple;\n\n    // Calculate the remaining apples\n    int remainingApples = totalApples - applesConsumed;\n    if (timeElapsed % timePerApple >  0){\n        remainingApples-=1;\n    } \n    // Ensure remaining apples is non-negative\n    if (remainingApples < 0)\n    {\n        return 0;\n    }\n\n    return remainingApples;\n}\n\nToa maelezo mafupi ya lugha ya asili (docstring) ya msimbo wa C# kwa Kiswahili kwa kutumia herufi zisizozidi 500.",
      "tr": "static int RemainingApples(int totalApples, int timePerApple, int timeElapsed)\n{\n    if (timePerApple == 0) return 0; // Prevent division by zero\n\n    // Calculate the number of apples consumed\n    int applesConsumed = timeElapsed / timePerApple;\n\n    // Calculate the remaining apples\n    int remainingApples = totalApples - applesConsumed;\n    if (timeElapsed % timePerApple >  0){\n        remainingApples-=1;\n    } \n    // Ensure remaining apples is non-negative\n    if (remainingApples < 0)\n    {\n        return 0;\n    }\n\n    return remainingApples;\n}\n\nAşağıdaki C# kodunun Türkçe olarak en fazla 500 karakter kullanarak kısa bir doğal dil açıklamasını (docstring) sağlayın.",
      "vi": "static int RemainingApples(int totalApples, int timePerApple, int timeElapsed)\n{\n    if (timePerApple == 0) return 0; // Prevent division by zero\n\n    // Calculate the number of apples consumed\n    int applesConsumed = timeElapsed / timePerApple;\n\n    // Calculate the remaining apples\n    int remainingApples = totalApples - applesConsumed;\n    if (timeElapsed % timePerApple >  0){\n        remainingApples-=1;\n    } \n    // Ensure remaining apples is non-negative\n    if (remainingApples < 0)\n    {\n        return 0;\n    }\n\n    return remainingApples;\n}\n\nCung cấp mô tả ngắn gọn bằng ngôn ngữ tự nhiên (docstring) cho mã C# bằng tiếng Việt, sử dụng tối đa 500 ký tự."
    },
    "instruction_bertscore": {
      "es": "0.9702167647764858",
      "arb": "0.8829437397396628",
      "sw": "0.918288824262535",
      "tr": "0.8909997907336757",
      "vi": "0.912055207014517"
    },
    "level": "",
    "test": "    static void Main()\n    {\n        Debug.Assert(RemainingApples(50, 10, 200) == 30);\n        Debug.Assert(RemainingApples(10, 2, 5) == 7);\n        Debug.Assert(RemainingApples(5, 15, 10) == 4);\n        Debug.Assert(RemainingApples(20, 0, 100) == 0); // Case to test division by zero handling\n        Debug.Assert(RemainingApples(3, 10, 130) == 0); // Case where all apples are eaten\n\n    }\n}",
    "entry_point": "RemainingApples",
    "signature": "static int RemainingApples(int totalApples, int timePerApple, int timeElapsed)",
    "docstring": {
      "es": "Calcula el número de manzanas enteras que quedan después de comer manzanas durante un tiempo determinado.\n   Cada manzana toma una cantidad específica de tiempo para comer, y la función devuelve cuántas manzanas enteras quedan sin comer.\n   - totalApples: el número total de manzanas disponibles\n   - timePerApple: el tiempo que se tarda en comer una manzana (timePerApple>=0)\n   - timeElapsed: el tiempo total transcurrido\n\n   Ejemplos:\n   >>> RemainingApples(50, 10, 200)\n   30",
      "arb": "يحسب عدد التفاحات الكاملة المتبقية بعد تناول التفاح لمدة زمنية معينة.\n   تستغرق كل تفاحة وقتًا محددًا لتناولها، وتعيد الدالة عدد التفاحات الكاملة المتبقية غير مأكولة.\n   - totalApples: العدد الإجمالي للتفاحات المتاحة\n   - timePerApple: الوقت الذي يستغرقه تناول تفاحة واحدة (timePerApple>=0)\n   - timeElapsed: الوقت الإجمالي المنقضي\n\n   أمثلة:\n   >>> RemainingApples(50, 10, 200)\n   30",
      "sw": "Hesabu idadi ya tufaha nzima zilizobaki baada ya kula tufaha kwa muda uliotolewa.\n   Kila tufaha inachukua muda maalum kuliwa, na kazi inarudisha ni tufaha ngapi nzima zimebaki bila kuliwa.\n   - totalApples: jumla ya idadi ya tufaha zinazopatikana\n   - timePerApple: muda unaochukua kula tufaha moja (timePerApple>=0)\n   - timeElapsed: jumla ya muda uliopita\n\n   Mifano:\n   >>> RemainingApples(50, 10, 200)\n   30",
      "tr": "Belli bir süre boyunca elma yedikten sonra kalan bütün elmaların sayısını hesaplar. Her bir elmayı yemek belirli bir zaman alır ve fonksiyon, yenmemiş kaç bütün elma kaldığını döndürür.\n   - totalApples: mevcut toplam elma sayısı\n   - timePerApple: bir elmayı yemek için gereken süre (timePerApple>=0)\n   - timeElapsed: geçen toplam süre\n\n   Örnekler:\n   >>> RemainingApples(50, 10, 200)\n   30",
      "vi": "Tính toán số lượng táo nguyên còn lại sau khi ăn táo trong một khoảng thời gian nhất định.  \nMỗi quả táo mất một khoảng thời gian cụ thể để ăn, và hàm trả về có bao nhiêu quả táo nguyên còn lại chưa ăn.  \n- totalApples: tổng số lượng táo có sẵn  \n- timePerApple: thời gian cần để ăn một quả táo (timePerApple>=0)  \n- timeElapsed: tổng thời gian đã trôi qua  \n\nVí dụ:  \n>>> RemainingApples(50, 10, 200)  \n30  "
    },
    "docstring_bertscore": {
      "es": "0.9822213891150913",
      "arb": "0.9816884638027747",
      "sw": "0.961512781479537",
      "tr": "0.9564812752975422",
      "vi": "0.9619902889155448"
    }
  },
  {
    "task_id": "C#/49",
    "prompt": {
      "es": "using System;\nusing System.Collections.Generic;\nusing System.Diagnostics;\n\nclass Program\n{\n\n/*\n    Encuentra el ID faltante (roto) y duplicado de una serie de secuencias de ID.\n    Se supone que los IDs son continuos, pero debido a un error, falta un ID y uno está duplicado.\n    La función devuelve una tupla con el primer elemento siendo el ID faltante y el segundo el ID duplicado.\n\n    Args:\n    ids: Una lista de listas, cada sublista contiene una serie de IDs de tickets.\n\n    Returns:\n    Una tupla de dos enteros: el primero es el ID faltante (m) y el segundo es el ID duplicado (n).\n\n    Examples:\n    >>> FindErrorIds(new List<List<int>> { new List<int> {5, 6, 8, 11, 9}, new List<int> {10, 12, 9} })\n    (7, 9)\n    >>> FindErrorIds(new List<List<int>> { new List<int> {1, 2, 4}, new List<int> {3, 3} })\n    (5, 3)\n*/\n\n    static (int, int) FindErrorIds(List<List<int>> ids)",
      "arb": "using System;\nusing System.Collections.Generic;\nusing System.Diagnostics;\n\nclass Program\n{\n\n/*\n    يجد المعرف المفقود (المعطل) والمعرف المكرر من سلسلة من تسلسلات المعرفات.\n    من المفترض أن تكون المعرفات متتالية ولكن بسبب خطأ، يوجد معرف مفقود وآخر مكرر.\n    تقوم الدالة بإرجاع زوج من العناصر حيث يكون العنصر الأول هو المعرف المفقود والثاني هو المعرف المكرر.\n\n    Args:\n    ids: قائمة من القوائم، تحتوي كل قائمة فرعية على سلسلة من معرفات التذاكر.\n\n    Returns:\n    زوج من الأعداد الصحيحة: الأول هو المعرف المفقود (m) والثاني هو المعرف المكرر (n).\n\n    أمثلة:\n    >>> FindErrorIds(new List<List<int>> { new List<int> {5, 6, 8, 11, 9}, new List<int> {10, 12, 9} })\n    (7, 9)\n    >>> FindErrorIds(new List<List<int>> { new List<int> {1, 2, 4}, new List<int> {3, 3} })\n    (5, 3)\n*/\n\n    static (int, int) FindErrorIds(List<List<int>> ids)",
      "sw": "using System;\nusing System.Collections.Generic;\nusing System.Diagnostics;\n\nclass Program\n{\n\n/*\n    Inapata ID iliyopotea (iliyovunjika) na ID iliyozidishwa kutoka kwa mfuatano wa ID.\n    ID zinatakiwa kuwa mfululizo lakini kutokana na hitilafu, ID moja imepotea na nyingine imezidishwa.\n    Kazi inarejesha jozi yenye kipengele cha kwanza ikiwa ni ID iliyopotea na cha pili ikiwa ni ID iliyozidishwa.\n\n    Args:\n    ids: Orodha ya orodha, kila orodha ndogo ina mfuatano wa ID za tiketi.\n\n    Returns:\n    Jozi ya nambari mbili: ya kwanza ni ID iliyopotea (m) na ya pili ni ID iliyozidishwa (n).\n\n    Mifano:\n    >>> FindErrorIds(new List<List<int>> { new List<int> {5, 6, 8, 11, 9}, new List<int> {10, 12, 9} })\n    (7, 9)\n    >>> FindErrorIds(new List<List<int>> { new List<int> {1, 2, 4}, new List<int> {3, 3} })\n    (5, 3)\n*/\n\n    static (int, int) FindErrorIds(List<List<int>> ids)",
      "tr": "using System;\nusing System.Collections.Generic;\nusing System.Diagnostics;\n\nclass Program\n{\n\n/*\n    Bir dizi kimlik dizisinden eksik (bozuk) ve yinelenen kimliği bulur.\n    Kimliklerin sürekli olması gerekiyor ancak bir hata nedeniyle bir kimlik eksik ve biri yinelenmiş.\n    Fonksiyon, ilk elemanı eksik kimlik ve ikinci elemanı yinelenen kimlik olan bir ikili döndürür.\n\n    Argümanlar:\n    ids: Her alt liste bir dizi bilet kimliği içeren bir liste listesi.\n\n    Döndürür:\n    İki tam sayıdan oluşan bir ikili: ilki eksik kimlik (m) ve ikincisi yinelenen kimlik (n).\n\n    Örnekler:\n    >>> FindErrorIds(new List<List<int>> { new List<int> {5, 6, 8, 11, 9}, new List<int> {10, 12, 9} })\n    (7, 9)\n    >>> FindErrorIds(new List<List<int>> { new List<int> {1, 2, 4}, new List<int> {3, 3} })\n    (5, 3)\n*/\n\n    static (int, int) FindErrorIds(List<List<int>> ids)",
      "vi": "using System;\nusing System.Collections.Generic;\nusing System.Diagnostics;\n\nclass Program\n{\n\n/*\n    Tìm ID bị thiếu (bị hỏng) và ID bị trùng lặp từ một chuỗi các dãy ID.\n    Các ID được cho là liên tục nhưng do lỗi, một ID bị thiếu và một ID bị trùng lặp.\n    Hàm trả về một bộ giá trị với phần tử đầu tiên là ID bị thiếu và phần tử thứ hai là ID bị trùng lặp.\n\n    Tham số:\n    ids: Một danh sách các danh sách, mỗi danh sách con chứa một chuỗi các ID vé.\n\n    Trả về:\n    Một bộ hai số nguyên: đầu tiên là ID bị thiếu (m) và thứ hai là ID bị trùng lặp (n).\n\n    Ví dụ:\n    >>> FindErrorIds(new List<List<int>> { new List<int> {5, 6, 8, 11, 9}, new List<int> {10, 12, 9} })\n    (7, 9)\n    >>> FindErrorIds(new List<List<int>> { new List<int> {1, 2, 4}, new List<int> {3, 3} })\n    (5, 3)\n*/\n\n    static (int, int) FindErrorIds(List<List<int>> ids)"
    },
    "prompt_bertscore": {
      "es": "0.9864518189703724",
      "arb": "0.9580965375561179",
      "sw": "0.9711991906410843",
      "tr": "0.9696401407803414",
      "vi": "0.971146354959729"
    },
    "canonical_solution": "    {\n        var allIds = ids.SelectMany(idList => idList).OrderBy(id => id).ToList();\n        int missingId = 0, duplicatedId = 0;\n\n        for (int i = 1; i < allIds.Count; i++)\n        {\n            if (allIds[i] == allIds[i - 1])\n            {\n                duplicatedId = allIds[i];\n            }\n            else if (allIds[i] - allIds[i - 1] > 1)\n            {\n                missingId = allIds[i - 1] + 1;\n            }\n        }\n\n        return (missingId, duplicatedId);\n    }",
    "instruction": {
      "es": "static (int, int) FindErrorIds(List<List<int>> ids)\n    {\n        var allIds = ids.SelectMany(idList => idList).OrderBy(id => id).ToList();\n        int missingId = 0, duplicatedId = 0;\n\n        for (int i = 1; i < allIds.Count; i++)\n        {\n            if (allIds[i] == allIds[i - 1])\n            {\n                duplicatedId = allIds[i];\n            }\n            else if (allIds[i] - allIds[i - 1] > 1)\n            {\n                missingId = allIds[i - 1] + 1;\n            }\n        }\n\n        return (missingId, duplicatedId);\n    }\n\nProporcione una descripción concisa en lenguaje natural (docstring) del código C# en español utilizando como máximo 500 caracteres.",
      "arb": "static (int, int) FindErrorIds(List<List<int>> ids)\n    {\n        var allIds = ids.SelectMany(idList => idList).OrderBy(id => id).ToList();\n        int missingId = 0, duplicatedId = 0;\n\n        for (int i = 1; i < allIds.Count; i++)\n        {\n            if (allIds[i] == allIds[i - 1])\n            {\n                duplicatedId = allIds[i];\n            }\n            else if (allIds[i] - allIds[i - 1] > 1)\n            {\n                missingId = allIds[i - 1] + 1;\n            }\n        }\n\n        return (missingId, duplicatedId);\n    }\n\nيرجى تقديم وصف موجز بلغة طبيعية (docstring) للكود المكتوب بلغة C# باللغة العربية الفصحى، بحيث لا يتجاوز 500 حرف.",
      "sw": "static (int, int) FindErrorIds(List<List<int>> ids)\n    {\n        var allIds = ids.SelectMany(idList => idList).OrderBy(id => id).ToList();\n        int missingId = 0, duplicatedId = 0;\n\n        for (int i = 1; i < allIds.Count; i++)\n        {\n            if (allIds[i] == allIds[i - 1])\n            {\n                duplicatedId = allIds[i];\n            }\n            else if (allIds[i] - allIds[i - 1] > 1)\n            {\n                missingId = allIds[i - 1] + 1;\n            }\n        }\n\n        return (missingId, duplicatedId);\n    }\n\nToa maelezo mafupi ya lugha ya asili (docstring) ya msimbo wa C# kwa Kiswahili kwa kutumia herufi zisizozidi 500.",
      "tr": "static (int, int) FindErrorIds(List<List<int>> ids)\n    {\n        var allIds = ids.SelectMany(idList => idList).OrderBy(id => id).ToList();\n        int missingId = 0, duplicatedId = 0;\n\n        for (int i = 1; i < allIds.Count; i++)\n        {\n            if (allIds[i] == allIds[i - 1])\n            {\n                duplicatedId = allIds[i];\n            }\n            else if (allIds[i] - allIds[i - 1] > 1)\n            {\n                missingId = allIds[i - 1] + 1;\n            }\n        }\n\n        return (missingId, duplicatedId);\n    }\n\nAşağıdaki C# kodunun Türkçe olarak en fazla 500 karakter kullanarak kısa bir doğal dil açıklamasını (docstring) sağlayın.",
      "vi": "static (int, int) FindErrorIds(List<List<int>> ids)\n    {\n        var allIds = ids.SelectMany(idList => idList).OrderBy(id => id).ToList();\n        int missingId = 0, duplicatedId = 0;\n\n        for (int i = 1; i < allIds.Count; i++)\n        {\n            if (allIds[i] == allIds[i - 1])\n            {\n                duplicatedId = allIds[i];\n            }\n            else if (allIds[i] - allIds[i - 1] > 1)\n            {\n                missingId = allIds[i - 1] + 1;\n            }\n        }\n\n        return (missingId, duplicatedId);\n    }\n\nCung cấp mô tả ngắn gọn bằng ngôn ngữ tự nhiên (docstring) cho mã C# bằng tiếng Việt, sử dụng tối đa 500 ký tự."
    },
    "instruction_bertscore": {
      "es": "0.9702167647764858",
      "arb": "0.8716935135882278",
      "sw": "0.918288824262535",
      "tr": "0.8909997907336757",
      "vi": "0.912055207014517"
    },
    "level": "",
    "test": "static void Main()\n    {\n\n        Debug.Assert(FindErrorIds(new List<List<int>> { new List<int> {5, 6, 8, 11, 9}, new List<int> {10, 12, 9} }) == (7, 9));\n        Debug.Assert(FindErrorIds(new List<List<int>> { new List<int> {1, 2, 4, 6}, new List<int> {3, 3} }) == (5, 3));\n        Debug.Assert(FindErrorIds(new List<List<int>> { new List<int> { 110, 112, 108 }, new List<int> { 107, 109, 108 } }) == (111, 108));\n\n    }\n}",
    "entry_point": "FindErrorIds",
    "signature": "static (int, int) FindErrorIds(List<List<int>> ids)",
    "docstring": {
      "es": "Encuentra el ID faltante (roto) y duplicado de una serie de secuencias de ID.\n    Se supone que los IDs son continuos, pero debido a un error, falta un ID y uno está duplicado.\n    La función devuelve una tupla con el primer elemento siendo el ID faltante y el segundo el ID duplicado.\n\n    Args:\n    ids: Una lista de listas, cada sublista contiene una serie de IDs de tickets.\n\n    Returns:\n    Una tupla de dos enteros: el primero es el ID faltante (m) y el segundo es el ID duplicado (n).\n\n    Examples:\n    >>> FindErrorIds(new List<List<int>> { new List<int> {5, 6, 8, 11, 9}, new List<int> {10, 12, 9} })\n    (7, 9)\n    >>> FindErrorIds(new List<List<int>> { new List<int> {1, 2, 4}, new List<int> {3, 3} })\n    (5, 3)",
      "arb": "يجد المعرف المفقود (المعطل) والمكرر من سلسلة من تسلسلات المعرفات.\n    من المفترض أن تكون المعرفات متتابعة ولكن بسبب خطأ، يوجد معرف مفقود وآخر مكرر.\n    تعيد الدالة زوجًا من العناصر حيث يكون العنصر الأول هو المعرف المفقود والعنصر الثاني هو المعرف المكرر.\n\n    Args:\n    ids: قائمة من القوائم، كل قائمة فرعية تحتوي على سلسلة من معرفات التذاكر.\n\n    Returns:\n    زوج من الأعداد الصحيحة: الأول هو المعرف المفقود (m) والثاني هو المعرف المكرر (n).\n\n    Examples:\n    >>> FindErrorIds(new List<List<int>> { new List<int> {5, 6, 8, 11, 9}, new List<int> {10, 12, 9} })\n    (7, 9)\n    >>> FindErrorIds(new List<List<int>> { new List<int> {1, 2, 4}, new List<int> {3, 3} })\n    (5, 3)",
      "sw": "Inapata ID iliyopotea (iliyovunjika) na ID iliyozidishwa kutoka kwa mfululizo wa misururu ya ID.\n    ID zinapaswa kuwa mfululizo lakini kutokana na hitilafu, ID moja imepotea na nyingine imezidishwa.\n    Kazi inarudisha jozi na kipengele cha kwanza kikiwa ni ID iliyopotea na cha pili ni ID iliyozidishwa.\n\n    Args:\n    ids: Orodha ya orodha, kila orodha ndogo ina mfululizo wa ID za tiketi.\n\n    Returns:\n    Jozi ya nambari mbili: ya kwanza ni ID iliyopotea (m) na ya pili ni ID iliyozidishwa (n).\n\n    Examples:\n    >>> FindErrorIds(new List<List<int>> { new List<int> {5, 6, 8, 11, 9}, new List<int> {10, 12, 9} })\n    (7, 9)\n    >>> FindErrorIds(new List<List<int>> { new List<int> {1, 2, 4}, new List<int> {3, 3} })\n    (5, 3)",
      "tr": "Eksik (bozuk) ve yinelenen kimliği bir dizi kimlik dizisinden bulur.\n    Kimliklerin kesintisiz olması gerekir, ancak bir hata nedeniyle bir kimlik eksik ve biri yinelenmiştir.\n    Fonksiyon, ilk elemanı eksik kimlik ve ikinci elemanı yinelenen kimlik olan bir demet döndürür.\n\n    Args:\n    ids: Her alt liste bir dizi bilet kimliği içeren listelerin bir listesi.\n\n    Returns:\n    İki tam sayıdan oluşan bir demet: ilki eksik kimlik (m) ve ikincisi yinelenen kimlik (n).\n\n    Examples:\n    >>> FindErrorIds(new List<List<int>> { new List<int> {5, 6, 8, 11, 9}, new List<int> {10, 12, 9} })\n    (7, 9)\n    >>> FindErrorIds(new List<List<int>> { new List<int> {1, 2, 4}, new List<int> {3, 3} })\n    (5, 3)",
      "vi": "Tìm ID bị thiếu (bị hỏng) và ID bị trùng lặp từ một chuỗi các dãy ID.\n    Các ID được cho là liên tục nhưng do lỗi, một ID bị thiếu và một ID bị trùng lặp.\n    Hàm trả về một bộ dữ liệu với phần tử đầu tiên là ID bị thiếu và phần tử thứ hai là ID bị trùng lặp.\n\n    Tham số:\n    ids: Một danh sách các danh sách, mỗi danh sách con chứa một chuỗi các ID vé.\n\n    Trả về:\n    Một bộ dữ liệu gồm hai số nguyên: số đầu tiên là ID bị thiếu (m) và số thứ hai là ID bị trùng lặp (n).\n\n    Ví dụ:\n    >>> FindErrorIds(new List<List<int>> { new List<int> {5, 6, 8, 11, 9}, new List<int> {10, 12, 9} })\n    (7, 9)\n    >>> FindErrorIds(new List<List<int>> { new List<int> {1, 2, 4}, new List<int> {3, 3} })\n    (5, 3)"
    },
    "docstring_bertscore": {
      "es": "0.9848423169928466",
      "arb": "0.9456527414450443",
      "sw": "0.9725613977942216",
      "tr": "0.9705123267834657",
      "vi": "0.9553892054626124"
    }
  },
  {
    "task_id": "C#/50",
    "prompt": {
      "es": "using System;\nusing System.Collections.Generic;\nusing System.Diagnostics;\n\nclass Program\n{\n\n\n    /* Cuenta el número de caracteres numéricos, minúsculas y mayúsculas en una cadena dada de longitud 8.\n        >>> CountCharacters(\"1n2s0e1s\")\n        (4, 4, 0)\n    */\n\n    static (int, int, int) CountCharacters(string s)",
      "arb": "using System;\nusing System.Collections.Generic;\nusing System.Diagnostics;\n\nclass Program\n{\n\n\n    /* يحسب عدد الأحرف الرقمية، والأحرف الصغيرة، والأحرف الكبيرة في سلسلة معينة بطول 8.\n        >>> CountCharacters(\"1n2s0e1s\")\n        (4, 4, 0)\n    */\n\n    static (int, int, int) CountCharacters(string s)",
      "sw": "using System;\nusing System.Collections.Generic;\nusing System.Diagnostics;\n\nclass Program\n{\n\n\n    /* Inahesabu idadi ya tarakimu, herufi ndogo, na herufi kubwa katika kamba iliyopewa ya urefu wa 8.\n        >>> CountCharacters(\"1n2s0e1s\")\n        (4, 4, 0)\n    */\n\n    static (int, int, int) CountCharacters(string s)",
      "tr": "using System;\nusing System.Collections.Generic;\nusing System.Diagnostics;\n\nclass Program\n{\n\n\n    /* Verilen 8 uzunluğundaki bir stringdeki rakam, küçük harf ve büyük harf karakterlerinin sayısını sayar.\n        >>> CountCharacters(\"1n2s0e1s\")\n        (4, 4, 0)\n    */\n\n    static (int, int, int) CountCharacters(string s)",
      "vi": "using System;\nusing System.Collections.Generic;\nusing System.Diagnostics;\n\nclass Program\n{\n\n\n    /* Đếm số lượng ký tự chữ số, chữ thường và chữ hoa trong một chuỗi có độ dài 8.\n        >>> CountCharacters(\"1n2s0e1s\")\n        (4, 4, 0)\n    */\n\n    static (int, int, int) CountCharacters(string s)"
    },
    "prompt_bertscore": {
      "es": "0.9879624030181426",
      "arb": "0.9583553529426064",
      "sw": "0.9836116031519545",
      "tr": "1",
      "vi": "0.9765761150556987"
    },
    "canonical_solution": "    {\n        int digitCount = 0, lowerCaseCount = 0, upperCaseCount = 0;\n        foreach (char c in s)\n        {\n            if (char.IsDigit(c)) digitCount++;\n            else if (char.IsLower(c)) lowerCaseCount++;\n            else if (char.IsUpper(c)) upperCaseCount++;\n        }\n        return (digitCount, lowerCaseCount, upperCaseCount);\n    }",
    "instruction": {
      "es": "static (int, int, int) CountCharacters(string s)\n    {\n        int digitCount = 0, lowerCaseCount = 0, upperCaseCount = 0;\n        foreach (char c in s)\n        {\n            if (char.IsDigit(c)) digitCount++;\n            else if (char.IsLower(c)) lowerCaseCount++;\n            else if (char.IsUpper(c)) upperCaseCount++;\n        }\n        return (digitCount, lowerCaseCount, upperCaseCount);\n    }\n\nProporcione una descripción concisa en lenguaje natural (docstring) del código C# en español utilizando como máximo 500 caracteres.",
      "arb": "static (int, int, int) CountCharacters(string s)\n    {\n        int digitCount = 0, lowerCaseCount = 0, upperCaseCount = 0;\n        foreach (char c in s)\n        {\n            if (char.IsDigit(c)) digitCount++;\n            else if (char.IsLower(c)) lowerCaseCount++;\n            else if (char.IsUpper(c)) upperCaseCount++;\n        }\n        return (digitCount, lowerCaseCount, upperCaseCount);\n    }\n\nيرجى تقديم وصف موجز بلغة طبيعية (docstring) للكود المكتوب بلغة C# باللغة العربية الفصحى، بحيث لا يتجاوز 500 حرف.",
      "sw": "static (int, int, int) CountCharacters(string s)\n    {\n        int digitCount = 0, lowerCaseCount = 0, upperCaseCount = 0;\n        foreach (char c in s)\n        {\n            if (char.IsDigit(c)) digitCount++;\n            else if (char.IsLower(c)) lowerCaseCount++;\n            else if (char.IsUpper(c)) upperCaseCount++;\n        }\n        return (digitCount, lowerCaseCount, upperCaseCount);\n    }\n\nToa maelezo mafupi ya lugha asilia (docstring) ya msimbo wa C# kwa Kiswahili ukitumia herufi zisizozidi 500.",
      "tr": "static (int, int, int) CountCharacters(string s)\n    {\n        int digitCount = 0, lowerCaseCount = 0, upperCaseCount = 0;\n        foreach (char c in s)\n        {\n            if (char.IsDigit(c)) digitCount++;\n            else if (char.IsLower(c)) lowerCaseCount++;\n            else if (char.IsUpper(c)) upperCaseCount++;\n        }\n        return (digitCount, lowerCaseCount, upperCaseCount);\n    }\n\nAşağıdaki C# kodunun Türkçe olarak en fazla 500 karakter kullanarak kısa bir doğal dil açıklamasını (docstring) sağlayın.",
      "vi": "static (int, int, int) CountCharacters(string s)\n    {\n        int digitCount = 0, lowerCaseCount = 0, upperCaseCount = 0;\n        foreach (char c in s)\n        {\n            if (char.IsDigit(c)) digitCount++;\n            else if (char.IsLower(c)) lowerCaseCount++;\n            else if (char.IsUpper(c)) upperCaseCount++;\n        }\n        return (digitCount, lowerCaseCount, upperCaseCount);\n    }\n\nCung cấp mô tả ngắn gọn bằng ngôn ngữ tự nhiên (docstring) cho mã C# bằng tiếng Việt, không quá 500 ký tự."
    },
    "instruction_bertscore": {
      "es": "0.9702167647764858",
      "arb": "0.8596346631555997",
      "sw": "0.9446027812508938",
      "tr": "0.8916963874799652",
      "vi": "0.9093975325162702"
    },
    "level": "",
    "test": "    static void Main()\n    {\n        Debug.Assert(CountCharacters(\"yLAX2022\") == (4, 1, 3));\n        Debug.Assert(CountCharacters(\"MBKKOKOK\") == (0, 0, 8));\n        Debug.Assert(CountCharacters(\"1n2s0e1s\") == (4, 4, 0));\n        Debug.Assert(CountCharacters(\"1234ABCD\") == (4, 0, 4));\n\n\n    }\n}",
    "entry_point": "CountCharacters",
    "signature": "static (int, int, int) CountCharacters(string s)",
    "docstring": {
      "es": "Cuenta el número de caracteres dígitos, minúsculas y mayúsculas en una cadena dada de longitud 8.\n        >>> CountCharacters(\"1n2s0e1s\")\n        (4, 4, 0)",
      "arb": "يحسب عدد الأحرف الرقمية، الأحرف الصغيرة، والأحرف الكبيرة في سلسلة معينة بطول 8.\n        >>> CountCharacters(\"1n2s0e1s\")\n        (4, 4, 0)",
      "sw": "Inahesabu idadi ya tarakimu, herufi ndogo, na herufi kubwa katika mfuatano uliotolewa wa urefu wa 8.\n        >>> CountCharacters(\"1n2s0e1s\")\n        (4, 4, 0)",
      "tr": "Verilen 8 uzunluğundaki bir dizgede rakam, küçük harf ve büyük harf karakterlerinin sayısını sayar.\n        >>> CountCharacters(\"1n2s0e1s\")\n        (4, 4, 0)",
      "vi": "Đếm số ký tự chữ số, chữ thường, và chữ hoa trong một chuỗi có độ dài 8 được cung cấp.  \n        >>> CountCharacters(\"1n2s0e1s\")  \n        (4, 4, 0)"
    },
    "docstring_bertscore": {
      "es": "0.9797355298964396",
      "arb": "0.9290277758131862",
      "sw": "0.9510898508651122",
      "tr": "0.973901954235826",
      "vi": "0.9657732045223543"
    }
  }
]