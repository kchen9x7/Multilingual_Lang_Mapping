[
  {
    "task_id": "CPP/1",
    "prompt": {
      "en": "#include <bits/stdc++.h>\nusing namespace std;\n// Return \"Hello, MMCODEEVAL: Masssively Multilingual Code Evaluation\"\nstring hello_mmcodeeval()",
      "es": "#include <bits/stdc++.h>\nusing namespace std;\n// Devuelve \"Hello, MMCODEEVAL: Masssively Multilingual Code Evaluation\"\nstring hello_mmcodeeval()",
      "arb": "#include <bits/stdc++.h>\nusing namespace std;\n// إرجاع \"Hello, MMCODEEVAL: Masssively Multilingual Code Evaluation\"\nstring hello_mmcodeeval()",
      "sw": "#include <bits/stdc++.h>\nusing namespace std;\n// Rudisha \"Hello, MMCODEEVAL: Masssively Multilingual Code Evaluation\"\nstring hello_mmcodeeval()",
      "tr": "#include <bits/stdc++.h>\nusing namespace std;\n// \"Hello, MMCODEEVAL: Masssively Multilingual Code Evaluation\" döndür\nstring hello_mmcodeeval()",
      "vi": "#include <bits/stdc++.h>\nusing namespace std;\n// Trả về \"Hello, MMCODEEVAL: Masssively Multilingual Code Evaluation\"\nstring hello_mmcodeeval()"
    },
    "prompt_bertscore": {
      "es": "0.9980401140303288",
      "arb": "1",
      "sw": "1",
      "tr": "0.9369284978492299",
      "vi": "0.9343600083920678"
    },
    "canonical_solution": "{\n    return \"Hello, MMCODEEVAL: Masssively Multilingual Code Evaluation\";\n}",
    "instruction": {
      "en": "string hello_mmcodeeval()\n{\n    return \"Hello, MMCODEEVAL: Masssively Multilingual Code Evaluation\";\n}\n\nProvide a concise natural language description (docstring) of the CPP code in English using at most 500 characters.",
      "es": "string hello_mmcodeeval()\n{\n    return \"Hello, MMCODEEVAL: Masssively Multilingual Code Evaluation\";\n}\n\nProporcione una descripción concisa en lenguaje natural (docstring) del código CPP en español utilizando como máximo 500 caracteres.",
      "arb": "string hello_mmcodeeval()\n{\n    return \"Hello, MMCODEEVAL: Masssively Multilingual Code Evaluation\";\n}\n\nيرجى تقديم وصف موجز بلغة طبيعية (docstring) للكود المكتوب بلغة C++ باللغة العربية الفصحى، بحيث لا يتجاوز 500 حرف.",
      "sw": "string hello_mmcodeeval()\n{\n    return \"Hello, MMCODEEVAL: Masssively Multilingual Code Evaluation\";\n}\n\nToa maelezo mafupi ya lugha ya asili (docstring) ya msimbo wa CPP kwa Kiswahili kwa kutumia herufi zisizozidi 500.",
      "tr": "string hello_mmcodeeval()\n{\n    return \"Hello, MMCODEEVAL: Masssively Multilingual Code Evaluation\";\n}\n\nAşağıdaki CPP kodunun Türkçe olarak en fazla 500 karakter kullanarak özlü bir doğal dil açıklamasını (docstring) sağlayın.",
      "vi": "string hello_mmcodeeval()\n{\n    return \"Hello, MMCODEEVAL: Masssively Multilingual Code Evaluation\";\n}\n\nCung cấp mô tả ngắn gọn bằng ngôn ngữ tự nhiên (docstring) cho mã CPP bằng tiếng Việt với tối đa 500 ký tự."
    },
    "instruction_bertscore": {
      "es": "0.9695565173899258",
      "arb": "0.8291343722565495",
      "sw": "0.9176812139269492",
      "tr": "0.904443094922117",
      "vi": "0.9171611995893999"
    },
    "level": "",
    "test": "int main()\n{\n    assert(hello_mmcodeeval() ==  \"Hello, MMCODEEVAL: Masssively Multilingual Code Evaluation\");\n    return 0;\n}",
    "entry_point": "hello_mmcodeeval",
    "signature": "string hello_mmcodeeval()",
    "docstring": {
      "en": "Return \"Hello, MMCODEEVAL: Masssively Multilingual Code Evaluation\"",
      "es": "Devuelve \"Hello, MMCODEEVAL: Masssively Multilingual Code Evaluation\"",
      "arb": "إرجاع \"Hello, MMCODEEVAL: Masssively Multilingual Code Evaluation\"",
      "sw": "Rudisha \"Hello, MMCODEEVAL: Masssively Multilingual Code Evaluation\"",
      "tr": " \"Hello, MMCODEEVAL: Masssively Multilingual Code Evaluation\" döndür",
      "vi": "Trả về \"Hello, MMCODEEVAL: Masssively Multilingual Code Evaluation\""
    },
    "docstring_bertscore": {
      "es": "0.956679309787434",
      "arb": "0.956679309787434",
      "sw": "0.8942376645749255",
      "tr": "0.999999801369619",
      "vi": "0.9075671535550337"
    }
  },
  {
    "task_id": "CPP/2",
    "prompt": {
      "en": "#include <cassert>\n#include <cmath>\n#include <cstdio>\n#include <cstring>\n/**\n * Calculate the area of a triangle given its three sides.\n *\n * @param a (double): Length of side 'a'.\n * @param b (double): Length of side 'b'.\n * @param c (double): Length of side 'c'.\n *\n * @return (double): If the provided sides form a triangle, return the\n *                   calculated area rounded to 2 decimal places.\n *                   Otherwise, return -1 as an indicator.\n *\n * Example usage:\n *     double area = calculate_triangle_area(3, 5, 4);\n *     assert(fabs(area - 6.00) < 1e-6); // Area should be approximately 6\n */\ndouble calculate_triangle_area(double a, double b, double c)",
      "es": "#include <cassert>\n#include <cmath>\n#include <cstdio>\n#include <cstring>\n/**\n * Calcular el área de un triángulo dados sus tres lados.\n *\n * @param a (double): Longitud del lado 'a'.\n * @param b (double): Longitud del lado 'b'.\n * @param c (double): Longitud del lado 'c'.\n *\n * @return (double): Si los lados proporcionados forman un triángulo, devuelve el\n *                   área calculada redondeada a 2 decimales.\n *                   De lo contrario, devuelve -1 como indicador.\n *\n * Ejemplo de uso:\n *     double area = calculate_triangle_area(3, 5, 4);\n *     assert(fabs(area - 6.00) < 1e-6); // El área debería ser aproximadamente 6\n */\ndouble calculate_triangle_area(double a, double b, double c)",
      "arb": "#include <cassert>\n#include <cmath>\n#include <cstdio>\n#include <cstring>\n/**\n * حساب مساحة مثلث معطى أضلاعه الثلاثة.\n *\n * @param a (double): طول الضلع 'a'.\n * @param b (double): طول الضلع 'b'.\n * @param c (double): طول الضلع 'c'.\n *\n * @return (double): إذا كانت الأضلاع المعطاة تشكل مثلثًا، يتم إرجاع\n *                   المساحة المحسوبة مقربة إلى منزلتين عشريتين.\n *                   خلاف ذلك، يتم إرجاع -1 كمؤشر.\n *\n * مثال على الاستخدام:\n *     double area = calculate_triangle_area(3, 5, 4);\n *     assert(fabs(area - 6.00) < 1e-6); // يجب أن تكون المساحة تقريبًا 6\n */\ndouble calculate_triangle_area(double a, double b, double c)",
      "sw": "#include <cassert>\n#include <cmath>\n#include <cstdio>\n#include <cstring>\n/**\n * Hesabu eneo la pembetatu ukipewa pande zake tatu.\n *\n * @param a (double): Urefu wa upande 'a'.\n * @param b (double): Urefu wa upande 'b'.\n * @param c (double): Urefu wa upande 'c'.\n *\n * @return (double): Ikiwa pande zilizotolewa zinaunda pembetatu, rudisha\n *                   eneo lililohesabiwa na kulizungusha hadi sehemu 2 za desimali.\n *                   Vinginevyo, rudisha -1 kama kiashiria.\n *\n * Mfano wa matumizi:\n *     double area = calculate_triangle_area(3, 5, 4);\n *     assert(fabs(area - 6.00) < 1e-6); // Eneo linapaswa kuwa takriban 6\n */\ndouble calculate_triangle_area(double a, double b, double c)",
      "tr": "#include <cassert>\n#include <cmath>\n#include <cstdio>\n#include <cstring>\n/**\n * Üç kenarı verilen bir üçgenin alanını hesaplayın.\n *\n * @param a (double): 'a' kenarının uzunluğu.\n * @param b (double): 'b' kenarının uzunluğu.\n * @param c (double): 'c' kenarının uzunluğu.\n *\n * @return (double): Verilen kenarlar bir üçgen oluşturuyorsa,\n *                   hesaplanan alanı 2 ondalık basamağa yuvarlanmış\n *                   olarak döndürün. Aksi takdirde, bir gösterge\n *                   olarak -1 döndürün.\n *\n * Örnek kullanım:\n *     double area = calculate_triangle_area(3, 5, 4);\n *     assert(fabs(area - 6.00) < 1e-6); // Alan yaklaşık olarak 6 olmalıdır\n */\ndouble calculate_triangle_area(double a, double b, double c)",
      "vi": "#include <cassert>\n#include <cmath>\n#include <cstdio>\n#include <cstring>\n/**\n * Tính diện tích của một tam giác khi biết ba cạnh của nó.\n *\n * @param a (double): Chiều dài của cạnh 'a'.\n * @param b (double): Chiều dài của cạnh 'b'.\n * @param c (double): Chiều dài của cạnh 'c'.\n *\n * @return (double): Nếu các cạnh được cung cấp tạo thành một tam giác, trả về\n *                   diện tích đã tính toán được làm tròn đến 2 chữ số thập phân.\n *                   Nếu không, trả về -1 như một chỉ báo.\n *\n * Ví dụ sử dụng:\n *     double area = calculate_triangle_area(3, 5, 4);\n *     assert(fabs(area - 6.00) < 1e-6); // Diện tích nên xấp xỉ 6\n */\ndouble calculate_triangle_area(double a, double b, double c)"
    },
    "prompt_bertscore": {
      "es": "0.9920432641965045",
      "arb": "0.9841943846899108",
      "sw": "0.9928338131130233",
      "tr": "0.9932090259027982",
      "vi": "0.9990988139612447"
    },
    "canonical_solution": "{\n    if (a + b > c && a + c > b && b + c > a) {\n        double s = (a + b + c) / 2.0;\n        return sqrt(s * (s - a) * (s - b) * (s - c));\n    } else {\n        return -1; // Special value to indicate it's not a triangle\n    }\n}",
    "instruction": {
      "en": "double calculate_triangle_area(double a, double b, double c)\n{\n    if (a + b > c && a + c > b && b + c > a) {\n        double s = (a + b + c) / 2.0;\n        return sqrt(s * (s - a) * (s - b) * (s - c));\n    } else {\n        return -1; // Special value to indicate it's not a triangle\n    }\n}\n\nProvide a concise natural language description (docstring) of the CPP code in English using at most 500 characters.",
      "es": "double calculate_triangle_area(double a, double b, double c)\n{\n    if (a + b > c && a + c > b && b + c > a) {\n        double s = (a + b + c) / 2.0;\n        return sqrt(s * (s - a) * (s - b) * (s - c));\n    } else {\n        return -1; // Special value to indicate it's not a triangle\n    }\n}\n\nProporcione una descripción concisa en lenguaje natural (docstring) del código CPP en español utilizando como máximo 500 caracteres.",
      "arb": "double calculate_triangle_area(double a, double b, double c)\n{\n    if (a + b > c && a + c > b && b + c > a) {\n        double s = (a + b + c) / 2.0;\n        return sqrt(s * (s - a) * (s - b) * (s - c));\n    } else {\n        return -1; // Special value to indicate it's not a triangle\n    }\n}\n\nقدم وصفًا موجزًا بلغة طبيعية (docstring) لشفرة CPP باللغة العربية الفصحى باستخدام 500 حرف على الأكثر.",
      "sw": "double calculate_triangle_area(double a, double b, double c)\n{\n    if (a + b > c && a + c > b && b + c > a) {\n        double s = (a + b + c) / 2.0;\n        return sqrt(s * (s - a) * (s - b) * (s - c));\n    } else {\n        return -1; // Special value to indicate it's not a triangle\n    }\n}\n\nToa maelezo mafupi ya lugha ya asili (docstring) ya msimbo wa CPP kwa Kiswahili kwa kutumia herufi zisizozidi 500.",
      "tr": "double calculate_triangle_area(double a, double b, double c)\n{\n    if (a + b > c && a + c > b && b + c > a) {\n        double s = (a + b + c) / 2.0;\n        return sqrt(s * (s - a) * (s - b) * (s - c));\n    } else {\n        return -1; // Special value to indicate it's not a triangle\n    }\n}\n\nAşağıdaki CPP kodunun işlevini açıklayan, en fazla 500 karakter uzunluğunda, özlü bir doğal dil açıklaması (docstring) sağlayın.",
      "vi": "double calculate_triangle_area(double a, double b, double c)\n{\n    if (a + b > c && a + c > b && b + c > a) {\n        double s = (a + b + c) / 2.0;\n        return sqrt(s * (s - a) * (s - b) * (s - c));\n    } else {\n        return -1; // Special value to indicate it's not a triangle\n    }\n}\n\nCung cấp mô tả ngắn gọn bằng ngôn ngữ tự nhiên (docstring) cho mã CPP bằng tiếng Việt với tối đa 500 ký tự."
    },
    "instruction_bertscore": {
      "es": "0.9695565173899258",
      "arb": "0.9113258362553569",
      "sw": "0.8854305921102196",
      "tr": "0.8552588358614012",
      "vi": "0.9171611995893999"
    },
    "level": "",
    "test": "int main() {\n    // Test cases for the calculate_triangle_area function\n    assert(fabs(calculate_triangle_area(3, 5, 4) - 6.00) < 1e-6); // Expected area is 6\n    assert(calculate_triangle_area(1, 1, 4) == -1);  // Not a triangle, should return -1\n    assert(fabs(calculate_triangle_area(7, 24, 25) - 84.00) < 1e-6); // Expected area is 84\n    assert(fabs(calculate_triangle_area(10.5, 6.2, 7.3) - 22.15) < 1e-2); // Expected area is approx 22.15\n\n    // All tests passed\n    \n    return 0;\n}",
    "entry_point": "calculate_triangle_area",
    "signature": "double calculate_triangle_area(double a, double b, double c)",
    "docstring": {
      "en": "Calculate the area of a triangle given its three sides.\n\n@param a (double): Length of side 'a'.\n@param b (double): Length of side 'b'.\n@param c (double): Length of side 'c'.\n\n@return (double): If the provided sides form a triangle, return the calculated area rounded to 2 decimal places. Otherwise, return -1 as an indicator.\n\nExample usage:\n    double area = calculate_triangle_area(3, 5, 4);\n    assert(fabs(area - 6.00) < 1e-6); // Area should be approximately 6",
      "es": "Calcular el área de un triángulo dados sus tres lados.\n\n@param a (double): Longitud del lado 'a'.\n@param b (double): Longitud del lado 'b'.\n@param c (double): Longitud del lado 'c'.\n\n@return (double): Si los lados proporcionados forman un triángulo, devuelve el área calculada redondeada a 2 decimales. De lo contrario, devuelve -1 como indicador.\n\nEjemplo de uso:\n    double area = calculate_triangle_area(3, 5, 4);\n    assert(fabs(area - 6.00) < 1e-6); // El área debería ser aproximadamente 6",
      "arb": "حساب مساحة مثلث معطى أطوال أضلاعه الثلاثة.\n\n@param a (double): طول الضلع 'a'.\n@param b (double): طول الضلع 'b'.\n@param c (double): طول الضلع 'c'.\n\n@return (double): إذا كانت الأضلاع المعطاة تشكل مثلثًا، يتم إرجاع المساحة المحسوبة مقربة إلى منزلتين عشريتين. خلاف ذلك، يتم إرجاع -1 كمؤشر.\n\nمثال على الاستخدام:\n    double area = calculate_triangle_area(3, 5, 4);\n    assert(fabs(area - 6.00) < 1e-6); // يجب أن تكون المساحة تقريبًا 6",
      "sw": "Hesabu eneo la pembetatu ukitumia pande zake tatu.\n\n@param a (double): Urefu wa upande 'a'.\n@param b (double): Urefu wa upande 'b'.\n@param c (double): Urefu wa upande 'c'.\n\n@return (double): Ikiwa pande zilizotolewa zinaunda pembetatu, rudisha eneo lililohesabiwa likiwa limezungushwa hadi sehemu 2 za desimali. Vinginevyo, rudisha -1 kama kiashiria.\n\nMfano wa matumizi:\n    double area = calculate_triangle_area(3, 5, 4);\n    assert(fabs(area - 6.00) < 1e-6); // Eneo linapaswa kuwa takriban 6",
      "tr": "Bir üçgenin üç kenarı verildiğinde alanını hesaplayın.\n\n@param a (double): 'a' kenarının uzunluğu.\n@param b (double): 'b' kenarının uzunluğu.\n@param c (double): 'c' kenarının uzunluğu.\n\n@return (double): Verilen kenarlar bir üçgen oluşturuyorsa, hesaplanan alanı 2 ondalık basamağa yuvarlanmış olarak döndürür. Aksi takdirde, bir gösterge olarak -1 döndürür.\n\nÖrnek kullanım:\n    double area = calculate_triangle_area(3, 5, 4);\n    assert(fabs(area - 6.00) < 1e-6); // Alan yaklaşık olarak 6 olmalıdır.",
      "vi": "Tính diện tích của một tam giác khi biết ba cạnh của nó.\n\n@param a (double): Chiều dài của cạnh 'a'.\n@param b (double): Chiều dài của cạnh 'b'.\n@param c (double): Chiều dài của cạnh 'c'.\n\n@return (double): Nếu các cạnh được cung cấp tạo thành một tam giác, trả về diện tích đã tính toán được làm tròn đến 2 chữ số thập phân. Nếu không, trả về -1 như là một chỉ báo.\n\nVí dụ sử dụng:\n    double area = calculate_triangle_area(3, 5, 4);\n    assert(fabs(area - 6.00) < 1e-6); // Diện tích nên xấp xỉ 6"
    },
    "docstring_bertscore": {
      "es": "0.9938557664234478",
      "arb": "0.9694522364398824",
      "sw": "0.988414485765378",
      "tr": "0.9913911606555669",
      "vi": "0.9978095041579472"
    }
  },
  {
    "task_id": "CPP/3",
    "prompt": {
      "en": "#include <cassert>\n#include <cmath>\n#include <cstring>\n#include <iostream>\n#include <string>\n/**\n * Calculate the value of the function for a given input.\n * Parameters:\n * - x (int): Input value for the function.\n * Returns:\n * - std::string: If x is not in the defined domain, returns \"Not define\".\n *   Otherwise, returns the calculated function value rounded to 5 decimal places.\n *\n * Function Definitions:\n * - For 0 <= x < 10: y = cos(x + 3.0)\n * - For 10 <= x < 20: y = (cos(x + 7.5))^2\n * - For 20 <= x < 30: y = (cos(x + 4.0))^4\n * Example:\n *   calculate_function_value(40) returns \"Not define\"\n */\nstd::string calculate_function_value(int x)",
      "es": "#include <cassert>\n#include <cmath>\n#include <cstring>\n#include <iostream>\n#include <string>\n/**\n * Calcula el valor de la función para una entrada dada.\n * Parámetros:\n * - x (int): Valor de entrada para la función.\n * Retorna:\n * - std::string: Si x no está en el dominio definido, retorna \"Not define\".\n *   De lo contrario, retorna el valor calculado de la función redondeado a 5 decimales.\n *\n * Definiciones de la función:\n * - Para 0 <= x < 10: y = cos(x + 3.0)\n * - Para 10 <= x < 20: y = (cos(x + 7.5))^2\n * - Para 20 <= x < 30: y = (cos(x + 4.0))^4\n * Ejemplo:\n *   calculate_function_value(40) retorna \"Not define\"\n */\nstd::string calculate_function_value(int x)",
      "arb": "#include <cassert>\n#include <cmath>\n#include <cstring>\n#include <iostream>\n#include <string>\n/**\n * حساب قيمة الدالة لمدخل معين.\n * المعطيات:\n * - x (int): قيمة المدخل للدالة.\n * يعيد:\n * - std::string: إذا لم يكن x في النطاق المحدد، يعيد \"Not define\".\n *   خلاف ذلك، يعيد قيمة الدالة المحسوبة مقربة إلى 5 منازل عشرية.\n *\n * تعريفات الدالة:\n * - لـ 0 <= x < 10: y = cos(x + 3.0)\n * - لـ 10 <= x < 20: y = (cos(x + 7.5))^2\n * - لـ 20 <= x < 30: y = (cos(x + 4.0))^4\n * مثال:\n *   calculate_function_value(40) يعيد \"Not define\"\n */\nstd::string calculate_function_value(int x)",
      "sw": "#include <cassert>\n#include <cmath>\n#include <cstring>\n#include <iostream>\n#include <string>\n/**\n * Hesabu thamani ya kazi kwa pembejeo iliyotolewa.\n * Vigezo:\n * - x (int): Thamani ya pembejeo kwa kazi.\n * Inarudisha:\n * - std::string: Ikiwa x haipo katika kikoa kilichobainishwa, inarudisha \"Not define\".\n *   Vinginevyo, inarudisha thamani ya kazi iliyohesabiwa iliyokatwa hadi sehemu 5 za desimali.\n *\n * Ufafanuzi wa Kazi:\n * - Kwa 0 <= x < 10: y = cos(x + 3.0)\n * - Kwa 10 <= x < 20: y = (cos(x + 7.5))^2\n * - Kwa 20 <= x < 30: y = (cos(x + 4.0))^4\n * Mfano:\n *   calculate_function_value(40) inarudisha \"Not define\"\n */\nstd::string calculate_function_value(int x)",
      "tr": "#include <cassert>\n#include <cmath>\n#include <cstring>\n#include <iostream>\n#include <string>\n/**\n * Belirli bir giriş için fonksiyonun değerini hesapla.\n * Parametreler:\n * - x (int): Fonksiyon için giriş değeri.\n * Döndürür:\n * - std::string: Eğer x tanımlı alanda değilse, \"Not define\" döndürür.\n *   Aksi takdirde, hesaplanan fonksiyon değerini 5 ondalık basamağa yuvarlanmış olarak döndürür.\n *\n * Fonksiyon Tanımları:\n * - 0 <= x < 10 için: y = cos(x + 3.0)\n * - 10 <= x < 20 için: y = (cos(x + 7.5))^2\n * - 20 <= x < 30 için: y = (cos(x + 4.0))^4\n * Örnek:\n *   calculate_function_value(40) \"Not define\" döndürür\n */\nstd::string calculate_function_value(int x)",
      "vi": "#include <cassert>\n#include <cmath>\n#include <cstring>\n#include <iostream>\n#include <string>\n/**\n * Tính giá trị của hàm cho một đầu vào nhất định.\n * Tham số:\n * - x (int): Giá trị đầu vào cho hàm.\n * Trả về:\n * - std::string: Nếu x không nằm trong miền xác định, trả về \"Not define\".\n *   Ngược lại, trả về giá trị hàm đã tính được làm tròn đến 5 chữ số thập phân.\n *\n * Định nghĩa hàm:\n * - Với 0 <= x < 10: y = cos(x + 3.0)\n * - Với 10 <= x < 20: y = (cos(x + 7.5))^2\n * - Với 20 <= x < 30: y = (cos(x + 4.0))^4\n * Ví dụ:\n *   calculate_function_value(40) trả về \"Not define\"\n */\nstd::string calculate_function_value(int x)"
    },
    "prompt_bertscore": {
      "es": "0.9820452039671134",
      "arb": "0.9863372092405153",
      "sw": "0.9930952106944653",
      "tr": "0.9923866961253137",
      "vi": "0.9946586304235908"
    },
    "canonical_solution": "{\n    char output[50]; // Buffer to hold the output string.\n\n    if (0 <= x && x < 10) {\n        snprintf(output, sizeof(output), \"%.5f\", cos(x + 3.0));\n    } else if (10 <= x && x < 20) {\n        snprintf(output, sizeof(output), \"%.5f\", pow(cos(x + 7.5), 2.0));\n    } else if (20 <= x && x < 30) {\n        snprintf(output, sizeof(output), \"%.5f\", pow(cos(x + 4.0), 4.0));\n    } else {\n        return \"Not define\";\n    }\n    return std::string(output);\n}",
    "instruction": {
      "en": "std::string calculate_function_value(int x)\n{\n    char output[50]; // Buffer to hold the output string.\n\n    if (0 <= x && x < 10) {\n        snprintf(output, sizeof(output), \"%.5f\", cos(x + 3.0));\n    } else if (10 <= x && x < 20) {\n        snprintf(output, sizeof(output), \"%.5f\", pow(cos(x + 7.5), 2.0));\n    } else if (20 <= x && x < 30) {\n        snprintf(output, sizeof(output), \"%.5f\", pow(cos(x + 4.0), 4.0));\n    } else {\n        return \"Not define\";\n    }\n    return std::string(output);\n}\n\nProvide a concise natural language description (docstring) of the CPP code in English using at most 500 characters.",
      "es": "std::string calculate_function_value(int x)\n{\n    char output[50]; // Buffer to hold the output string.\n\n    if (0 <= x && x < 10) {\n        snprintf(output, sizeof(output), \"%.5f\", cos(x + 3.0));\n    } else if (10 <= x && x < 20) {\n        snprintf(output, sizeof(output), \"%.5f\", pow(cos(x + 7.5), 2.0));\n    } else if (20 <= x && x < 30) {\n        snprintf(output, sizeof(output), \"%.5f\", pow(cos(x + 4.0), 4.0));\n    } else {\n        return \"Not define\";\n    }\n    return std::string(output);\n}\n\nProporcione una descripción concisa en lenguaje natural (docstring) del código CPP en español utilizando como máximo 500 caracteres.",
      "arb": "std::string calculate_function_value(int x)\n{\n    char output[50]; // Buffer to hold the output string.\n\n    if (0 <= x && x < 10) {\n        snprintf(output, sizeof(output), \"%.5f\", cos(x + 3.0));\n    } else if (10 <= x && x < 20) {\n        snprintf(output, sizeof(output), \"%.5f\", pow(cos(x + 7.5), 2.0));\n    } else if (20 <= x && x < 30) {\n        snprintf(output, sizeof(output), \"%.5f\", pow(cos(x + 4.0), 4.0));\n    } else {\n        return \"Not define\";\n    }\n    return std::string(output);\n}\n\nقدم وصفًا موجزًا بلغة طبيعية (docstring) للكود المكتوب بلغة C++ باللغة العربية الفصحى باستخدام ما لا يزيد عن 500 حرف.",
      "sw": "std::string calculate_function_value(int x)\n{\n    char output[50]; // Buffer to hold the output string.\n\n    if (0 <= x && x < 10) {\n        snprintf(output, sizeof(output), \"%.5f\", cos(x + 3.0));\n    } else if (10 <= x && x < 20) {\n        snprintf(output, sizeof(output), \"%.5f\", pow(cos(x + 7.5), 2.0));\n    } else if (20 <= x && x < 30) {\n        snprintf(output, sizeof(output), \"%.5f\", pow(cos(x + 4.0), 4.0));\n    } else {\n        return \"Not define\";\n    }\n    return std::string(output);\n}\n\nToa maelezo mafupi ya lugha ya asili (docstring) ya msimbo wa CPP kwa Kiswahili kwa kutumia herufi zisizozidi 500.",
      "tr": "std::string calculate_function_value(int x)\n{\n    char output[50]; // Buffer to hold the output string.\n\n    if (0 <= x && x < 10) {\n        snprintf(output, sizeof(output), \"%.5f\", cos(x + 3.0));\n    } else if (10 <= x && x < 20) {\n        snprintf(output, sizeof(output), \"%.5f\", pow(cos(x + 7.5), 2.0));\n    } else if (20 <= x && x < 30) {\n        snprintf(output, sizeof(output), \"%.5f\", pow(cos(x + 4.0), 4.0));\n    } else {\n        return \"Not define\";\n    }\n    return std::string(output);\n}\n\nAşağıdaki CPP kodunun Türkçe'de en fazla 500 karakter kullanarak kısa bir doğal dil açıklamasını (docstring) sağlayın.",
      "vi": "std::string calculate_function_value(int x)\n{\n    char output[50]; // Buffer to hold the output string.\n\n    if (0 <= x && x < 10) {\n        snprintf(output, sizeof(output), \"%.5f\", cos(x + 3.0));\n    } else if (10 <= x && x < 20) {\n        snprintf(output, sizeof(output), \"%.5f\", pow(cos(x + 7.5), 2.0));\n    } else if (20 <= x && x < 30) {\n        snprintf(output, sizeof(output), \"%.5f\", pow(cos(x + 4.0), 4.0));\n    } else {\n        return \"Not define\";\n    }\n    return std::string(output);\n}\n\nCung cấp mô tả ngắn gọn bằng ngôn ngữ tự nhiên (docstring) cho mã CPP bằng tiếng Việt với tối đa 500 ký tự."
    },
    "instruction_bertscore": {
      "es": "0.9695565173899258",
      "arb": "0.8526196339885905",
      "sw": "0.9176812139269492",
      "tr": "0.8786900701298007",
      "vi": "0.9171611995893999"
    },
    "level": "",
    "test": "int main() {\n    assert(calculate_function_value(40) == \"Not define\");\n\n    // Additional test cases based on provided function definitions\n    assert(calculate_function_value(5) == \"-0.14550\");\n    assert(calculate_function_value(15) == \"0.76266\");\n    assert(calculate_function_value(25) == \"0.31314\");\n    assert(calculate_function_value(-1) == \"Not define\");\n\n    // std::cout << \"All tests passed successfully.\" << std::endl;\n\n    return 0;\n}",
    "entry_point": "calculate_function_value",
    "signature": "std::string calculate_function_value(int x)",
    "docstring": {
      "en": "Calculate the value of the function for a given input. Parameters: - x (int): Input value for the function. Returns: - std::string: If x is not in the defined domain, returns \"Not define\". Otherwise, returns the calculated function value rounded to 5 decimal places. Function Definitions: - For 0 <= x < 10: y = cos(x + 3.0) - For 10 <= x < 20: y = (cos(x + 7.5))^2 - For 20 <= x < 30: y = (cos(x + 4.0))^4 Example: calculate_function_value(40) returns \"Not define\"",
      "es": "Calcular el valor de la función para una entrada dada. Parámetros: - x (int): Valor de entrada para la función. Devuelve: - std::string: Si x no está en el dominio definido, devuelve \"Not define\". De lo contrario, devuelve el valor calculado de la función redondeado a 5 decimales. Definiciones de Función: - Para 0 <= x < 10: y = cos(x + 3.0) - Para 10 <= x < 20: y = (cos(x + 7.5))^2 - Para 20 <= x < 30: y = (cos(x + 4.0))^4 Ejemplo: calculate_function_value(40) devuelve \"Not define\"",
      "arb": "احسب قيمة الدالة لإدخال معين.  \nالمعلمات:  \n- x (int): قيمة الإدخال للدالة.  \nالقيم المعادة:  \n- std::string: إذا لم يكن x في النطاق المحدد، يعيد \"غير معرف\". خلاف ذلك، يعيد قيمة الدالة المحسوبة مقربة إلى 5 منازل عشرية.  \nتعريفات الدالة:  \n- لـ 0 <= x < 10: y = cos(x + 3.0)  \n- لـ 10 <= x < 20: y = (cos(x + 7.5))^2  \n- لـ 20 <= x < 30: y = (cos(x + 4.0))^4  \nمثال:  \ncalculate_function_value(40) يعيد \"غير معرف\"",
      "sw": "Hesabu thamani ya kazi kwa pembejeo iliyotolewa.\n\nVigezo:\n- x (int): Thamani ya pembejeo kwa kazi.\n\nInarejesha:\n- std::string: Ikiwa x haipo katika kikoa kilichobainishwa, inarejesha \"Not define\". Vinginevyo, inarejesha thamani ya kazi iliyohesabiwa iliyozungushwa hadi sehemu tano za desimali.\n\nUfafanuzi wa Kazi:\n- Kwa 0 <= x < 10: y = cos(x + 3.0)\n- Kwa 10 <= x < 20: y = (cos(x + 7.5))^2\n- Kwa 20 <= x < 30: y = (cos(x + 4.0))^4\n\nMfano:\ncalculate_function_value(40) inarejesha \"Not define\"",
      "tr": "Belirli bir giriş için fonksiyonun değerini hesapla.\n\nParametreler:\n- x (int): Fonksiyon için giriş değeri.\n\nDöndürülenler:\n- std::string: Eğer x tanımlı alanda değilse, \"Not define\" döner. Aksi takdirde, hesaplanan fonksiyon değerini 5 ondalık basamağa yuvarlanmış olarak döner.\n\nFonksiyon Tanımları:\n- 0 <= x < 10 için: y = cos(x + 3.0)\n- 10 <= x < 20 için: y = (cos(x + 7.5))^2\n- 20 <= x < 30 için: y = (cos(x + 4.0))^4\n\nÖrnek:\ncalculate_function_value(40) returns \"Not define\"",
      "vi": "Tính giá trị của hàm cho một đầu vào nhất định.\n\nTham số:\n- x (int): Giá trị đầu vào cho hàm.\n\nTrả về:\n- std::string: Nếu x không nằm trong miền xác định, trả về \"Not define\". Ngược lại, trả về giá trị hàm đã tính toán được làm tròn đến 5 chữ số thập phân.\n\nĐịnh nghĩa hàm:\n- Đối với 0 <= x < 10: y = cos(x + 3.0)\n- Đối với 10 <= x < 20: y = (cos(x + 7.5))^2\n- Đối với 20 <= x < 30: y = (cos(x + 4.0))^4\n\nVí dụ:\ncalculate_function_value(40) trả về \"Not define\""
    },
    "docstring_bertscore": {
      "es": "0.9765655876455039",
      "arb": "0.9589133056829334",
      "sw": "0.9866877918630418",
      "tr": "0.983489246837237",
      "vi": "0.9894866925622045"
    }
  },
  {
    "task_id": "CPP/4",
    "prompt": {
      "en": "#include <cassert>\n#include <cstdio>\n/*\nFind the maximum and minimum of three distinct integers.\nParameters:\na (int): The first integer.\nb (int): The second integer.\nc (int): The third integer.\n\nReturns:\nTuple[int, int]: A tuple is not a concept in C; instead, we will return by reference.\n\n>>> Example call: \nint max, min;\nfind_max_min(1,2,3, &max, &min);\nassert(max == 3 && min == 1);\n*/\nvoid find_max_min(int a, int b, int c, int *max, int *min)",
      "es": "#include <cassert>\n#include <cstdio>\n/*\nEncuentra el máximo y el mínimo de tres enteros distintos.\nParámetros:\na (int): El primer entero.\nb (int): El segundo entero.\nc (int): El tercer entero.\n\nDevuelve:\nTuple[int, int]: Una tupla no es un concepto en C; en su lugar, devolveremos por referencia.\n\n>>> Llamada de ejemplo: \nint max, min;\nfind_max_min(1,2,3, &max, &min);\nassert(max == 3 && min == 1);\n*/\nvoid find_max_min(int a, int b, int c, int *max, int *min)",
      "arb": "#include <cassert>\n#include <cstdio>\n/*\nالعثور على الحد الأقصى والأدنى من ثلاثة أعداد صحيحة مميزة.\nالمعلمات:\na (int): العدد الصحيح الأول.\nb (int): العدد الصحيح الثاني.\nc (int): العدد الصحيح الثالث.\n\nالإرجاع:\nTuple[int, int]: الزوج المرتب ليس مفهومًا في C؛ بدلاً من ذلك، سنعيده بالإشارة.\n\n>>> مثال على الاستدعاء: \nint max, min;\nfind_max_min(1,2,3, &max, &min);\nassert(max == 3 && min == 1);\n*/\nvoid find_max_min(int a, int b, int c, int *max, int *min)",
      "sw": "#include <cassert>\n#include <cstdio>\n/*\nPata kubwa na ndogo kati ya nambari tatu tofauti.\nVigezo:\na (int): Nambari ya kwanza.\nb (int): Nambari ya pili.\nc (int): Nambari ya tatu.\n\nInarejesha:\nTuple[int, int]: Tuple si dhana katika C; badala yake, tutarejesha kwa marejeleo.\n\n>>> Mfano wa kupiga:\nint max, min;\nfind_max_min(1,2,3, &max, &min);\nassert(max == 3 && min == 1);\n*/\nvoid find_max_min(int a, int b, int c, int *max, int *min)",
      "tr": "#include <cassert>\n#include <cstdio>\n/*\nÜç farklı tam sayının maksimum ve minimumunu bulun.\nParametreler:\na (int): Birinci tam sayı.\nb (int): İkinci tam sayı.\nc (int): Üçüncü tam sayı.\n\nDöndürür:\nTuple[int, int]: C'de tuple bir kavram değildir; bunun yerine referansla döneceğiz.\n\n>>> Örnek çağrı: \nint max, min;\nfind_max_min(1,2,3, &max, &min);\nassert(max == 3 && min == 1);\n*/\nvoid find_max_min(int a, int b, int c, int *max, int *min)",
      "vi": "#include <cassert>\n#include <cstdio>\n/*\nTìm giá trị lớn nhất và nhỏ nhất của ba số nguyên khác nhau.\nTham số:\na (int): Số nguyên thứ nhất.\nb (int): Số nguyên thứ hai.\nc (int): Số nguyên thứ ba.\n\nTrả về:\nTuple[int, int]: Một tuple không phải là khái niệm trong C; thay vào đó, chúng ta sẽ trả về bằng tham chiếu.\n\n>>> Ví dụ gọi:\nint max, min;\nfind_max_min(1,2,3, &max, &min);\nassert(max == 3 && min == 1);\n*/\nvoid find_max_min(int a, int b, int c, int *max, int *min)"
    },
    "prompt_bertscore": {
      "es": "1",
      "arb": "0.981832073568263",
      "sw": "0.9665917603225991",
      "tr": "0.9779991031054327",
      "vi": "0.9917629967288643"
    },
    "canonical_solution": "{\n    if (a > b) {\n        if (a > c) {\n            *max = a;\n            *min = (b < c) ? b : c;\n        } else {\n            *max = c;\n            *min = b;\n        }\n    } else if (b > c) {\n        *max = b;\n        *min = (a < c) ? a : c;\n    } else {\n        *max = c;\n        *min = a;\n    }\n}",
    "instruction": {
      "en": "void find_max_min(int a, int b, int c, int *max, int *min)\n{\n    if (a > b) {\n        if (a > c) {\n            *max = a;\n            *min = (b < c) ? b : c;\n        } else {\n            *max = c;\n            *min = b;\n        }\n    } else if (b > c) {\n        *max = b;\n        *min = (a < c) ? a : c;\n    } else {\n        *max = c;\n        *min = a;\n    }\n}\n\nProvide a concise natural language description (docstring) of the CPP code in English using at most 500 characters.",
      "es": "void find_max_min(int a, int b, int c, int *max, int *min)\n{\n    if (a > b) {\n        if (a > c) {\n            *max = a;\n            *min = (b < c) ? b : c;\n        } else {\n            *max = c;\n            *min = b;\n        }\n    } else if (b > c) {\n        *max = b;\n        *min = (a < c) ? a : c;\n    } else {\n        *max = c;\n        *min = a;\n    }\n}\n\nProporcione una descripción concisa en lenguaje natural (docstring) del código CPP en español utilizando como máximo 500 caracteres.",
      "arb": "void find_max_min(int a, int b, int c, int *max, int *min)\n{\n    if (a > b) {\n        if (a > c) {\n            *max = a;\n            *min = (b < c) ? b : c;\n        } else {\n            *max = c;\n            *min = b;\n        }\n    } else if (b > c) {\n        *max = b;\n        *min = (a < c) ? a : c;\n    } else {\n        *max = c;\n        *min = a;\n    }\n}\n\nيرجى تقديم وصف موجز بلغة طبيعية (docstring) للشفرة البرمجية بلغة C++ باللغة العربية الفصحى، بحيث لا يتجاوز 500 حرف.",
      "sw": "void find_max_min(int a, int b, int c, int *max, int *min)\n{\n    if (a > b) {\n        if (a > c) {\n            *max = a;\n            *min = (b < c) ? b : c;\n        } else {\n            *max = c;\n            *min = b;\n        }\n    } else if (b > c) {\n        *max = b;\n        *min = (a < c) ? a : c;\n    } else {\n        *max = c;\n        *min = a;\n    }\n}\n\nToa maelezo mafupi ya lugha asilia (docstring) ya msimbo wa CPP kwa Kiswahili kwa kutumia herufi zisizozidi 500.",
      "tr": "void find_max_min(int a, int b, int c, int *max, int *min)\n{\n    if (a > b) {\n        if (a > c) {\n            *max = a;\n            *min = (b < c) ? b : c;\n        } else {\n            *max = c;\n            *min = b;\n        }\n    } else if (b > c) {\n        *max = b;\n        *min = (a < c) ? a : c;\n    } else {\n        *max = c;\n        *min = a;\n    }\n}\n\nAşağıdaki CPP kodunun Türkçe olarak en fazla 500 karakter kullanarak kısa bir doğal dil açıklamasını (docstring) sağlayın.",
      "vi": "void find_max_min(int a, int b, int c, int *max, int *min)\n{\n    if (a > b) {\n        if (a > c) {\n            *max = a;\n            *min = (b < c) ? b : c;\n        } else {\n            *max = c;\n            *min = b;\n        }\n    } else if (b > c) {\n        *max = b;\n        *min = (a < c) ? a : c;\n    } else {\n        *max = c;\n        *min = a;\n    }\n}\n\nCung cấp mô tả ngắn gọn bằng ngôn ngữ tự nhiên (docstring) cho mã CPP bằng tiếng Việt với tối đa 500 ký tự."
    },
    "instruction_bertscore": {
      "es": "0.9695565173899258",
      "arb": "0.8562400699437135",
      "sw": "0.9449839529520998",
      "tr": "0.8933178072803529",
      "vi": "0.9171611995893999"
    },
    "level": "",
    "test": "int main() {\n    int max, min;\n\n    // Test with a set of values\n    find_max_min(1, 2, 3, &max, &min);\n    assert(max == 3 && min == 1);\n\n    // Additional tests\n    find_max_min(5, 3, 4, &max, &min);\n    assert(max == 5 && min == 3);\n\n    find_max_min(10, -2, 7, &max, &min);\n    assert(max == 10 && min == -2);\n\n    find_max_min(-1, -3, -2, &max, &min);\n    assert(max == -1 && min == -3);\n\n    return 0;\n}",
    "entry_point": "find_max_min",
    "signature": "void find_max_min(int a, int b, int c, int *max, int *min)",
    "docstring": {
      "en": "Find the maximum and minimum of three distinct integers.\nParameters:\na (int): The first integer.\nb (int): The second integer.\nc (int): The third integer.\n\nReturns:\nTuple[int, int]: A tuple is not a concept in C; instead, we will return by reference.\n\n>>> Example call:\nint max, min;\nfind_max_min(1,2,3, &max, &min);\nassert(max == 3 && min == 1);\n",
      "es": "Encuentra el máximo y el mínimo de tres enteros distintos.\nParámetros:\na (int): El primer entero.\nb (int): El segundo entero.\nc (int): El tercer entero.\n\nDevuelve:\nTuple[int, int]: Una tupla no es un concepto en C; en su lugar, devolveremos por referencia.\n\n>>> Llamada de ejemplo:\nint max, min;\nfind_max_min(1,2,3, &max, &min);\nassert(max == 3 && min == 1);",
      "arb": "إيجاد القيمة القصوى والدنيا لثلاثة أعداد صحيحة مميزة.\nالمعلمات:\na (int): العدد الصحيح الأول.\nb (int): العدد الصحيح الثاني.\nc (int): العدد الصحيح الثالث.\n\nالقيم المعادة:\nTuple[int, int]: الترتيب ليس مفهومًا في C؛ بدلاً من ذلك، سنعيد بالقيمة المرجعية.\n\n>>> مثال على الاستدعاء:\nint max, min;\nfind_max_min(1,2,3, &max, &min);\nassert(max == 3 && min == 1);",
      "sw": "Pata kiwango cha juu na cha chini cha nambari tatu tofauti za mzima.\n\nVigezo:\na (int): Nambari ya kwanza ya mzima.\nb (int): Nambari ya pili ya mzima.\nc (int): Nambari ya tatu ya mzima.\n\nInarejesha:\nTuple[int, int]: Tuple si dhana katika C; badala yake, tutarejesha kwa marejeleo.\n\n>>> Mfano wa kupiga:\nint max, min;\nfind_max_min(1,2,3, &max, &min);\nassert(max == 3 && min == 1);",
      "tr": "Üç farklı tamsayının maksimum ve minimumunu bulun.  \nParametreler:  \na (int): Birinci tamsayı.  \nb (int): İkinci tamsayı.  \nc (int): Üçüncü tamsayı.  \n\nDöndürülenler:  \nTuple[int, int]: C'de bir kavram olarak tuple yoktur; bunun yerine referansla döneceğiz.\n\n>>> Örnek çağrı:  \nint max, min;  \nfind_max_min(1,2,3, &max, &min);  \nassert(max == 3 && min == 1);  ",
      "vi": "Tìm giá trị lớn nhất và nhỏ nhất của ba số nguyên khác nhau.  \nTham số:  \na (int): Số nguyên thứ nhất.  \nb (int): Số nguyên thứ hai.  \nc (int): Số nguyên thứ ba.  \n\nTrả về:  \nTuple[int, int]: Một tuple không phải là khái niệm trong C; thay vào đó, chúng ta sẽ trả về bằng tham chiếu.  \n\n>>> Ví dụ gọi:  \nint max, min;  \nfind_max_min(1,2,3, &max, &min);  \nassert(max == 3 && min == 1);  "
    },
    "docstring_bertscore": {
      "es": "1",
      "arb": "0.9650944845103581",
      "sw": "0.97329811787748",
      "tr": "0.9722207466907468",
      "vi": "0.9877168958671836"
    }
  },
  {
    "task_id": "CPP/5",
    "prompt": {
      "en": "#include <cassert>\n#include <cmath>\n#include <cstring>\n/**\n * Calculate the distance between two points A (xa, ya) and B (xb, yb).\n * \n * Parameters:\n * - xa (double): x-coordinate of point A.\n * - ya (double): y-coordinate of point A.\n * - xb (double): x-coordinate of point B.\n * - yb (double): y-coordinate of point B.\n * \n * Returns:\n * double: The distance between points A and B.\n * \n * Examples:\n * calculate_distance(0, 0, 3, 4) returns 5\n */\ndouble calculate_distance(double xa, double ya, double xb, double yb)",
      "es": "#include <cassert>\n#include <cmath>\n#include <cstring>\n/**\n * Calcular la distancia entre dos puntos A (xa, ya) y B (xb, yb).\n * \n * Parámetros:\n * - xa (double): coordenada x del punto A.\n * - ya (double): coordenada y del punto A.\n * - xb (double): coordenada x del punto B.\n * - yb (double): coordenada y del punto B.\n * \n * Devuelve:\n * double: La distancia entre los puntos A y B.\n * \n * Ejemplos:\n * calculate_distance(0, 0, 3, 4) returns 5\n */\ndouble calculate_distance(double xa, double ya, double xb, double yb)",
      "arb": "#include <cassert>\n#include <cmath>\n#include <cstring>\n/**\n * احسب المسافة بين نقطتين A (xa, ya) و B (xb, yb).\n * \n * المعلمات:\n * - xa (double): الإحداثي السيني للنقطة A.\n * - ya (double): الإحداثي الصادي للنقطة A.\n * - xb (double): الإحداثي السيني للنقطة B.\n * - yb (double): الإحداثي الصادي للنقطة B.\n * \n * يعيد:\n * double: المسافة بين النقطتين A و B.\n * \n * أمثلة:\n * calculate_distance(0, 0, 3, 4) returns 5\n */\ndouble calculate_distance(double xa, double ya, double xb, double yb)",
      "sw": "#include <cassert>\n#include <cmath>\n#include <cstring>\n/**\n * Hesabu umbali kati ya pointi mbili A (xa, ya) na B (xb, yb).\n * \n * Vigezo:\n * - xa (double): x-kiwango cha pointi A.\n * - ya (double): y-kiwango cha pointi A.\n * - xb (double): x-kiwango cha pointi B.\n * - yb (double): y-kiwango cha pointi B.\n * \n * Inarudisha:\n * double: Umbali kati ya pointi A na B.\n * \n * Mifano:\n * calculate_distance(0, 0, 3, 4) inarudisha 5\n */\ndouble calculate_distance(double xa, double ya, double xb, double yb)",
      "tr": "#include <cassert>\n#include <cmath>\n#include <cstring>\n/**\n * İki nokta A (xa, ya) ve B (xb, yb) arasındaki mesafeyi hesapla.\n * \n * Parametreler:\n * - xa (double): A noktasının x-koordinatı.\n * - ya (double): A noktasının y-koordinatı.\n * - xb (double): B noktasının x-koordinatı.\n * - yb (double): B noktasının y-koordinatı.\n * \n * Döndürür:\n * double: A ve B noktaları arasındaki mesafe.\n * \n * Örnekler:\n * calculate_distance(0, 0, 3, 4) 5 döndürür\n */\ndouble calculate_distance(double xa, double ya, double xb, double yb)",
      "vi": "#include <cassert>\n#include <cmath>\n#include <cstring>\n/**\n * Tính khoảng cách giữa hai điểm A (xa, ya) và B (xb, yb).\n * \n * Tham số:\n * - xa (double): tọa độ x của điểm A.\n * - ya (double): tọa độ y của điểm A.\n * - xb (double): tọa độ x của điểm B.\n * - yb (double): tọa độ y của điểm B.\n * \n * Trả về:\n * double: Khoảng cách giữa điểm A và B.\n * \n * Ví dụ:\n * calculate_distance(0, 0, 3, 4) trả về 5\n */\ndouble calculate_distance(double xa, double ya, double xb, double yb)"
    },
    "prompt_bertscore": {
      "es": "1",
      "arb": "0.9780849114300397",
      "sw": "0.9965450231522791",
      "tr": "1",
      "vi": "0.9973536474334722"
    },
    "canonical_solution": "{\n    return sqrt((xa - xb) * (xa - xb) + (ya - yb) * (ya - yb));\n}",
    "instruction": {
      "en": "double calculate_distance(double xa, double ya, double xb, double yb)\n{\n    return sqrt((xa - xb) * (xa - xb) + (ya - yb) * (ya - yb));\n}\n\nProvide a concise natural language description (docstring) of the CPP code in English using at most 500 characters.",
      "es": "double calculate_distance(double xa, double ya, double xb, double yb)\n{\n    return sqrt((xa - xb) * (xa - xb) + (ya - yb) * (ya - yb));\n}\n\nProporcione una descripción concisa en lenguaje natural (docstring) del código CPP en español utilizando un máximo de 500 caracteres.",
      "arb": "double calculate_distance(double xa, double ya, double xb, double yb)\n{\n    return sqrt((xa - xb) * (xa - xb) + (ya - yb) * (ya - yb));\n}\n\nيرجى تقديم وصف موجز بلغة طبيعية (docstring) للكود المكتوب بلغة C++ باللغة العربية الفصحى، بحيث لا يتجاوز 500 حرف.",
      "sw": "double calculate_distance(double xa, double ya, double xb, double yb)\n{\n    return sqrt((xa - xb) * (xa - xb) + (ya - yb) * (ya - yb));\n}\n\nToa maelezo mafupi ya lugha ya asili (docstring) ya msimbo wa CPP kwa Kiswahili kwa kutumia herufi zisizozidi 500.",
      "tr": "double calculate_distance(double xa, double ya, double xb, double yb)\n{\n    return sqrt((xa - xb) * (xa - xb) + (ya - yb) * (ya - yb));\n}\n\nAşağıdaki CPP kodunun işlevini açıklayan, en fazla 500 karakter uzunluğunda özlü bir doğal dil açıklaması (docstring) sağlayın. Açıklama Türkçe olmalıdır.",
      "vi": "double calculate_distance(double xa, double ya, double xb, double yb)\n{\n    return sqrt((xa - xb) * (xa - xb) + (ya - yb) * (ya - yb));\n}\n\nCung cấp mô tả ngắn gọn bằng ngôn ngữ tự nhiên (docstring) cho mã CPP bằng tiếng Việt với tối đa 500 ký tự."
    },
    "instruction_bertscore": {
      "es": "0.9695565173899258",
      "arb": "0.8366737856294908",
      "sw": "0.9176812139269492",
      "tr": "0.862920804179441",
      "vi": "0.9171611995893999"
    },
    "level": "",
    "test": "int main() \n{\n    assert(fabs(calculate_distance(0, 0, 3, 4) - 5) < 1e-6);\n    assert(fabs(calculate_distance(0, 0, 0, 0) - 0) < 1e-6);\n    assert(fabs(calculate_distance(-1, -1, 2, 2) - 4.242640687) < 1e-6);\n    assert(fabs(calculate_distance(1.5, 3.9, 4.2, -1.1) - 5.68243) < 1e-6);\n    //std::cout << \"All test cases passed!\\n\"; // printf can be replaced with std::cout\n    return 0;\n}",
    "entry_point": "calculate_distance",
    "signature": "double calculate_distance(double xa, double ya, double xb, double yb)",
    "docstring": {
      "en": "Calculate the distance between two points A (xa, ya) and B (xb, yb).\n\nParameters:\n- xa (double): x-coordinate of point A.\n- ya (double): y-coordinate of point A.\n- xb (double): x-coordinate of point B.\n- yb (double): y-coordinate of point B.\n\nReturns:\ndouble: The distance between points A and B.\n\nExamples:\ncalculate_distance(0, 0, 3, 4) returns 5",
      "es": "Calcular la distancia entre dos puntos A (xa, ya) y B (xb, yb).\n\nParámetros:\n- xa (double): coordenada x del punto A.\n- ya (double): coordenada y del punto A.\n- xb (double): coordenada x del punto B.\n- yb (double): coordenada y del punto B.\n\nDevuelve:\ndouble: La distancia entre los puntos A y B.\n\nEjemplos:\ncalculate_distance(0, 0, 3, 4) devuelve 5",
      "arb": "احسب المسافة بين نقطتين A (xa, ya) و B (xb, yb).\n\nالمعلمات:\n- xa (double): الإحداثي السيني للنقطة A.\n- ya (double): الإحداثي الصادي للنقطة A.\n- xb (double): الإحداثي السيني للنقطة B.\n- yb (double): الإحداثي الصادي للنقطة B.\n\nالقيم المعادة:\ndouble: المسافة بين النقطتين A و B.\n\nأمثلة:\ncalculate_distance(0, 0, 3, 4) يعيد 5",
      "sw": "Hesabu umbali kati ya pointi mbili A (xa, ya) na B (xb, yb).\n\nVigezo:\n- xa (double): x-kipeo cha pointi A.\n- ya (double): y-kipeo cha pointi A.\n- xb (double): x-kipeo cha pointi B.\n- yb (double): y-kipeo cha pointi B.\n\nRudisha:\ndouble: Umbali kati ya pointi A na B.\n\nMifano:\ncalculate_distance(0, 0, 3, 4) inarudisha 5",
      "tr": "İki nokta A (xa, ya) ve B (xb, yb) arasındaki mesafeyi hesaplayın.\n\nParametreler:\n- xa (double): A noktasının x-koordinatı.\n- ya (double): A noktasının y-koordinatı.\n- xb (double): B noktasının x-koordinatı.\n- yb (double): B noktasının y-koordinatı.\n\nDöndürülenler:\ndouble: A ve B noktaları arasındaki mesafe.\n\nÖrnekler:\ncalculate_distance(0, 0, 3, 4) 5 döndürür",
      "vi": "Tính khoảng cách giữa hai điểm A (xa, ya) và B (xb, yb).\n\nTham số:\n- xa (double): tọa độ x của điểm A.\n- ya (double): tọa độ y của điểm A.\n- xb (double): tọa độ x của điểm B.\n- yb (double): tọa độ y của điểm B.\n\nTrả về:\ndouble: Khoảng cách giữa các điểm A và B.\n\nVí dụ:\ncalculate_distance(0, 0, 3, 4) trả về 5"
    },
    "docstring_bertscore": {
      "es": "1",
      "arb": "0.9703883814256999",
      "sw": "1",
      "tr": "1",
      "vi": "0.9979173604548492"
    }
  },
  {
    "task_id": "CPP/6",
    "prompt": {
      "en": "#include <cassert>\n#include <cmath>\n#include <cstdio>\n#include <cstring>\n/**\n * Calculates the factorial of N modulo 10007.\n * \n * Parameters:\n * - N (int): An integer representing the input value (N <= 10000).\n * \n * Returns:\n * int: The result after calculating the factorial of N and\n * taking the modulo 10007.\n * \n * Examples:\n * >>> process_request(1)\n * 1\n * >>> process_request(10)\n * 6266\n */\nint process_request(int n)",
      "es": "#include <cassert>\n#include <cmath>\n#include <cstdio>\n#include <cstring>\n/**\n * Calcula el factorial de N módulo 10007.\n * \n * Parámetros:\n * - N (int): Un entero que representa el valor de entrada (N <= 10000).\n * \n * Retorna:\n * int: El resultado después de calcular el factorial de N y\n * tomar el módulo 10007.\n * \n * Ejemplos:\n * >>> process_request(1)\n * 1\n * >>> process_request(10)\n * 6266\n */\nint process_request(int n)",
      "arb": "#include <cassert>\n#include <cmath>\n#include <cstdio>\n#include <cstring>\n/**\n * يحسب مضروب N موديولو 10007.\n * \n * المعاملات:\n * - N (int): عدد صحيح يمثل قيمة الإدخال (N <= 10000).\n * \n * يعيد:\n * int: النتيجة بعد حساب مضروب N وأخذ الموديولو 10007.\n * \n * أمثلة:\n * >>> process_request(1)\n * 1\n * >>> process_request(10)\n * 6266\n */\nint process_request(int n)",
      "sw": "#include <cassert>\n#include <cmath>\n#include <cstdio>\n#include <cstring>\n/**\n * Inahesabu faktoria ya N modulo 10007.\n * \n * Vigezo:\n * - N (int): Nambari nzima inayowakilisha thamani ya pembejeo (N <= 10000).\n * \n * Inarudisha:\n * int: Matokeo baada ya kuhesabu faktoria ya N na\n * kuchukua modulo 10007.\n * \n * Mifano:\n * >>> process_request(1)\n * 1\n * >>> process_request(10)\n * 6266\n */\nint process_request(int n)",
      "tr": "#include <cassert>\n#include <cmath>\n#include <cstdio>\n#include <cstring>\n/**\n * N faktöriyelinin 10007 ile modülünü hesaplar.\n * \n * Parametreler:\n * - N (int): Girdi değerini temsil eden bir tamsayı (N <= 10000).\n * \n * Döndürür:\n * int: N faktöriyelini hesapladıktan sonra 10007 ile modülünü aldıktan sonraki sonuç.\n * \n * Örnekler:\n * >>> process_request(1)\n * 1\n * >>> process_request(10)\n * 6266\n */\nint process_request(int n)",
      "vi": "#include <cassert>\n#include <cmath>\n#include <cstdio>\n#include <cstring>\n/**\n * Tính giai thừa của N modulo 10007.\n * \n * Tham số:\n * - N (int): Một số nguyên đại diện cho giá trị đầu vào (N <= 10000).\n * \n * Trả về:\n * int: Kết quả sau khi tính giai thừa của N và\n * lấy modulo 10007.\n * \n * Ví dụ:\n * >>> process_request(1)\n * 1\n * >>> process_request(10)\n * 6266\n */\nint process_request(int n)"
    },
    "prompt_bertscore": {
      "es": "1",
      "arb": "0.9919081955374007",
      "sw": "0.9945021096833353",
      "tr": "0.9684505434283235",
      "vi": "0.9904663376014685"
    },
    "canonical_solution": "{\n    int a[10010];\n    a[0] = 1;\n    a[1] = 1;\n    for (register int i = 2; i <= 10000; i++) {\n        a[i] = (a[i - 1] * i) % 10007;\n    }\n    return a[n];\n}",
    "instruction": {
      "en": "int process_request(int n)\n{\n    int a[10010];\n    a[0] = 1;\n    a[1] = 1;\n    for (register int i = 2; i <= 10000; i++) {\n        a[i] = (a[i - 1] * i) % 10007;\n    }\n    return a[n];\n}\n\nProvide a concise natural language description (docstring) of the CPP code in English using at most 500 characters.",
      "es": "int process_request(int n)\n{\n    int a[10010];\n    a[0] = 1;\n    a[1] = 1;\n    for (register int i = 2; i <= 10000; i++) {\n        a[i] = (a[i - 1] * i) % 10007;\n    }\n    return a[n];\n}\n\nProporcione una descripción concisa en lenguaje natural (docstring) del código CPP en español utilizando como máximo 500 caracteres.",
      "arb": "int process_request(int n)\n{\n    int a[10010];\n    a[0] = 1;\n    a[1] = 1;\n    for (register int i = 2; i <= 10000; i++) {\n        a[i] = (a[i - 1] * i) % 10007;\n    }\n    return a[n];\n}\n\nيرجى تقديم وصف موجز بلغة طبيعية (docstring) لشفرة CPP باللغة العربية الفصحى، بحيث لا يتجاوز 500 حرف.",
      "sw": "int process_request(int n)\n{\n    int a[10010];\n    a[0] = 1;\n    a[1] = 1;\n    for (register int i = 2; i <= 10000; i++) {\n        a[i] = (a[i - 1] * i) % 10007;\n    }\n    return a[n];\n}\n\nToa maelezo mafupi ya lugha ya asili (docstring) ya msimbo wa CPP kwa Kiswahili kwa kutumia herufi zisizozidi 500.",
      "tr": "int process_request(int n)\n{\n    int a[10010];\n    a[0] = 1;\n    a[1] = 1;\n    for (register int i = 2; i <= 10000; i++) {\n        a[i] = (a[i - 1] * i) % 10007;\n    }\n    return a[n];\n}\n\nAşağıdaki CPP kodunun Türkçe olarak en fazla 500 karakterle doğal dilde kısa bir açıklamasını (docstring) sağlayın.",
      "vi": "int process_request(int n)\n{\n    int a[10010];\n    a[0] = 1;\n    a[1] = 1;\n    for (register int i = 2; i <= 10000; i++) {\n        a[i] = (a[i - 1] * i) % 10007;\n    }\n    return a[n];\n}\n\nCung cấp mô tả ngắn gọn bằng ngôn ngữ tự nhiên (docstring) cho mã CPP bằng tiếng Việt với tối đa 500 ký tự."
    },
    "instruction_bertscore": {
      "es": "0.9695565173899258",
      "arb": "0.9072064407830744",
      "sw": "0.9176812139269492",
      "tr": "0.851591324505973",
      "vi": "0.9171611995893999"
    },
    "level": "",
    "test": "int main()\n{\n    assert(process_request(0) == 1); // Added test for boundary condition\n    assert(process_request(1) == 1);\n    assert(process_request(2) == 2);\n    assert(process_request(3) == 6);\n    assert(process_request(4) == 24);\n    assert(process_request(10) == 6266); // 10! % 10007 = 3628800 % 10007 = 6266\n    assert(process_request(10000) == 6991); // Added a test for upper boundary condition\n    // printf(\"All tests passed.\\n\");\n    return 0;\n}",
    "entry_point": "process_request",
    "signature": "int process_request(int n)",
    "docstring": {
      "en": "Calculates the factorial of N modulo 10007.\n\nParameters:\n- N (int): An integer representing the input value (N <= 10000).\n\nReturns:\nint: The result after calculating the factorial of N and\ntaking the modulo 10007.\n\nExamples:\n>>> process_request(1)\n1\n>>> process_request(10)\n6266",
      "es": "Calcula el factorial de N módulo 10007.\n\nParámetros:\n- N (int): Un entero que representa el valor de entrada (N <= 10000).\n\nDevuelve:\nint: El resultado después de calcular el factorial de N y\ntomar el módulo 10007.\n\nEjemplos:\n>>> process_request(1)\n1\n>>> process_request(10)\n6266",
      "arb": "يحسب مضروب N موديولو 10007.\n\nالمعلمات:\n- N (int): عدد صحيح يمثل قيمة الإدخال (N <= 10000).\n\nالقيم المعادة:\nint: النتيجة بعد حساب مضروب N وأخذ الموديولو 10007.\n\nأمثلة:\n>>> process_request(1)\n1\n>>> process_request(10)\n6266",
      "sw": "Hesabu faktoria ya N modulo 10007.\n\nVigezo:\n- N (int): Nambari nzima inayowakilisha thamani ya ingizo (N <= 10000).\n\nInarejesha:\nint: Matokeo baada ya kuhesabu faktoria ya N na\nkuchukua modulo 10007.\n\nMifano:\n>>> process_request(1)\n1\n>>> process_request(10)\n6266",
      "tr": "N'nin faktöriyelini 10007 modunda hesaplar.\n\nParametreler:\n- N (int): Girdi değerini temsil eden bir tamsayı (N <= 10000).\n\nDöndürülenler:\nint: N'nin faktöriyelini hesapladıktan sonra\n10007 modunu alarak elde edilen sonuç.\n\nÖrnekler:\n>>> process_request(1)\n1\n>>> process_request(10)\n6266",
      "vi": "Tính giai thừa của N theo modulo 10007.\n\nTham số:\n- N (int): Một số nguyên đại diện cho giá trị đầu vào (N <= 10000).\n\nTrả về:\nint: Kết quả sau khi tính giai thừa của N và\nlấy modulo 10007.\n\nVí dụ:\n>>> process_request(1)\n1\n>>> process_request(10)\n6266"
    },
    "docstring_bertscore": {
      "es": "0.9971651472018701",
      "arb": "0.9939062185402306",
      "sw": "0.9910791123269611",
      "tr": "0.9776103834497474",
      "vi": "0.9890262673389655"
    }
  },
  {
    "task_id": "CPP/7",
    "prompt": {
      "en": "#include <bits/stdc++.h>\n/*\nCalculate the area of a triangle given its base and height.\n​    Parameters:\n- base (int): The base length of the triangle.\n- height (int): The height of the triangle.\n​    Returns:\n​    float: The calculated area of the triangle, rounded to one decimal place.\n\t>>> calculate_triangle_area(1,2)\n\t1.0\n*/\nfloat calculate_triangle_area(int base, int height)",
      "es": "#include <bits/stdc++.h>\n/*\nCalcular el área de un triángulo dado su base y altura.\n    Parámetros:\n- base (int): La longitud de la base del triángulo.\n- height (int): La altura del triángulo.\n    Devuelve:\n    float: El área calculada del triángulo, redondeada a un decimal.\n\t>>> calculate_triangle_area(1,2)\n\t1.0\n*/\nfloat calculate_triangle_area(int base, int height)",
      "arb": "#include <bits/stdc++.h>\n/*\nحساب مساحة المثلث المعطى قاعدته وارتفاعه.\n​    المعاملات:\n- base (int): طول قاعدة المثلث.\n- height (int): ارتفاع المثلث.\n​    يعيد:\n​    float: المساحة المحسوبة للمثلث، مقربة إلى مكان عشري واحد.\n\t>>> calculate_triangle_area(1,2)\n\t1.0\n*/\nfloat calculate_triangle_area(int base, int height)",
      "sw": "#include <bits/stdc++.h>\n/*\nHesabu eneo la pembetatu ukizingatia msingi wake na urefu.\n​    Vigezo:\n- base (int): Urefu wa msingi wa pembetatu.\n- height (int): Urefu wa pembetatu.\n​    Inarejesha:\n​    float: Eneo lililohesabiwa la pembetatu, limezungushwa hadi sehemu moja ya desimali.\n\t>>> calculate_triangle_area(1,2)\n\t1.0\n*/\nfloat calculate_triangle_area(int base, int height)",
      "tr": "#include <bits/stdc++.h>\n/*\nBir üçgenin alanını, tabanı ve yüksekliği verildiğinde hesaplayın.\n​    Parametreler:\n- base (int): Üçgenin taban uzunluğu.\n- height (int): Üçgenin yüksekliği.\n​    Döndürür:\n​    float: Hesaplanan üçgenin alanı, bir ondalık basamağa yuvarlanmış.\n\t>>> calculate_triangle_area(1,2)\n\t1.0\n*/\nfloat calculate_triangle_area(int base, int height)",
      "vi": "#include <bits/stdc++.h>\n/*\nTính diện tích của một tam giác khi biết đáy và chiều cao của nó.\n    Tham số:\n- base (int): Chiều dài đáy của tam giác.\n- height (int): Chiều cao của tam giác.\n    Trả về:\n    float: Diện tích đã tính của tam giác, làm tròn đến một chữ số thập phân.\n\t>>> calculate_triangle_area(1,2)\n\t1.0\n*/\nfloat calculate_triangle_area(int base, int height)"
    },
    "prompt_bertscore": {
      "es": "0.9780082401029603",
      "arb": "0.9780082401029603",
      "sw": "0.966210389991012",
      "tr": "0.9725689457487009",
      "vi": "0.9780082401029603"
    },
    "canonical_solution": "{\n    return base * height / 2.0; // The area formula is correct and casted to float\n}",
    "instruction": {
      "en": "float calculate_triangle_area(int base, int height)\n{\n    return base * height / 2.0; // The area formula is correct and casted to float\n}\n\nProvide a concise natural language description (docstring) of the CPP code in English using at most 500 characters.",
      "es": "float calculate_triangle_area(int base, int height)\n{\n    return base * height / 2.0; // The area formula is correct and casted to float\n}\n\nProporcione una descripción concisa en lenguaje natural (docstring) del código CPP en español utilizando un máximo de 500 caracteres.",
      "arb": "float calculate_triangle_area(int base, int height)\n{\n    return base * height / 2.0; // The area formula is correct and casted to float\n}\n\nيرجى تقديم وصف موجز بلغة طبيعية (docstring) لشفرة CPP باللغة العربية الفصحى، بحيث لا يتجاوز 500 حرف.",
      "sw": "float calculate_triangle_area(int base, int height)\n{\n    return base * height / 2.0; // The area formula is correct and casted to float\n}\n\nToa maelezo mafupi ya lugha ya asili (docstring) ya msimbo wa CPP kwa Kiswahili kwa kutumia herufi zisizozidi 500.",
      "tr": "float calculate_triangle_area(int base, int height)\n{\n    return base * height / 2.0; // The area formula is correct and casted to float\n}\n\nAşağıdaki CPP kodunun Türkçe olarak en fazla 500 karakter kullanarak özlü bir doğal dil açıklamasını (docstring) sağlayın.",
      "vi": "float calculate_triangle_area(int base, int height)\n{\n    return base * height / 2.0; // The area formula is correct and casted to float\n}\n\nCung cấp mô tả ngắn gọn bằng ngôn ngữ tự nhiên (docstring) cho mã CPP bằng tiếng Việt với tối đa 500 ký tự."
    },
    "instruction_bertscore": {
      "es": "0.9695565173899258",
      "arb": "0.9072064407830744",
      "sw": "0.9176812139269492",
      "tr": "0.904443094922117",
      "vi": "0.9171611995893999"
    },
    "level": "",
    "test": "int main()\n{\n    // Adding more comprehensive test cases and correcting the expected values\n    assert(fabs(calculate_triangle_area(1, 2) - 1.0) < 1e-6); // Should assert true with close approximate comparison\n    assert(fabs(calculate_triangle_area(3, 4) - 6.0) < 1e-6); // Should assert true with close approximate comparison\n    assert(fabs(calculate_triangle_area(5, 8) - 20.0) < 1e-6); // Additional test case\n    assert(fabs(calculate_triangle_area(7, 3) - 10.5) < 1e-6); // Additional test case\n    assert(fabs(calculate_triangle_area(10, 10) - 50.0) < 1e-6); // Additional test case\n\n    // printf(\"All tests passed.\\n\");\n    return 0;\n}",
    "entry_point": "calculate_triangle_area",
    "signature": "float calculate_triangle_area(int base, int height)",
    "docstring": {
      "en": "Calculate the area of a triangle given its base and height.\n    Parameters:\n- base (int): The base length of the triangle.\n- height (int): The height of the triangle.\n​    Returns:\n​    float: The calculated area of the triangle, rounded to one decimal place.\n    >>> calculate_triangle_area(1,2)\n    1.0\n",
      "es": "Calcular el área de un triángulo dada su base y altura.\n    Parámetros:\n- base (int): La longitud de la base del triángulo.\n- height (int): La altura del triángulo.\n​    Devuelve:\n​    float: El área calculada del triángulo, redondeada a un decimal.\n    >>> calculate_triangle_area(1,2)\n    1.0",
      "arb": "احسب مساحة المثلث بناءً على قاعدته وارتفاعه.\n    المعلمات:\n- base (int): طول قاعدة المثلث.\n- height (int): ارتفاع المثلث.\n    يعيد:\n    float: المساحة المحسوبة للمثلث، مقربة إلى منزلة عشرية واحدة.\n    >>> calculate_triangle_area(1,2)\n    1.0",
      "sw": "Hesabu eneo la pembetatu ukitumia msingi wake na urefu.\n\n    Vigezo:\n    - base (int): Urefu wa msingi wa pembetatu.\n    - height (int): Urefu wa pembetatu.\n\n    Inarejesha:\n    float: Eneo lililohesabiwa la pembetatu, limezungushwa hadi sehemu moja ya desimali.\n\n    >>> calculate_triangle_area(1,2)\n    1.0",
      "tr": "Üçgenin tabanı ve yüksekliği verildiğinde alanını hesaplayın.\n    Parametreler:\n- base (int): Üçgenin taban uzunluğu.\n- height (int): Üçgenin yüksekliği.\n​    Döndürür:\n​    float: Üçgenin hesaplanan alanı, bir ondalık basamağa yuvarlanmış.\n    >>> calculate_triangle_area(1,2)\n    1.0",
      "vi": "Tính diện tích của một tam giác khi biết đáy và chiều cao của nó.\n    Tham số:\n- base (int): Độ dài đáy của tam giác.\n- height (int): Chiều cao của tam giác.\n    Trả về:\n    float: Diện tích được tính của tam giác, làm tròn đến một chữ số thập phân.\n    >>> calculate_triangle_area(1,2)\n    1.0"
    },
    "docstring_bertscore": {
      "es": "0.9800811467594404",
      "arb": "0.9666829316674941",
      "sw": "0.9741562011235507",
      "tr": "0.9851646941012663",
      "vi": "0.9800811467594404"
    }
  },
  {
    "task_id": "CPP/8",
    "prompt": {
      "en": "#include <bits/stdc++.h>\n/*\nCalculate the Hamming distance between two integers in binary representation.\n​    Parameters:\n- x (int): The first positive integer (x <= 1,000,000,000).\n- y (int): The second positive integer (y <= 1,000,000,000).\n​    Returns:\n​    int: The Hamming distance between x and y, i.e., the number of bits that need to be flipped\n​         to transform x into y in binary.\n\t>>> hamming_distance(1,2)\n\t2\n*/\nint hamming_distance(int x, int y)",
      "es": "#include <bits/stdc++.h>\n/*\nCalcular la distancia de Hamming entre dos enteros en representación binaria.\n    Parámetros:\n- x (int): El primer entero positivo (x <= 1,000,000,000).\n- y (int): El segundo entero positivo (y <= 1,000,000,000).\n    Devuelve:\n    int: La distancia de Hamming entre x e y, es decir, el número de bits que deben cambiarse\n         para transformar x en y en binario.\n\t>>> hamming_distance(1,2)\n\t2\n*/\nint hamming_distance(int x, int y)",
      "arb": "#include <bits/stdc++.h>\n/*\nاحسب مسافة هامنج بين عددين صحيحين في التمثيل الثنائي.\n​    المعاملات:\n- x (int): العدد الصحيح الأول الموجب (x <= 1,000,000,000).\n- y (int): العدد الصحيح الثاني الموجب (y <= 1,000,000,000).\n​    يعيد:\n​    int: مسافة هامنج بين x و y، أي عدد البتات التي تحتاج إلى قلب\n​         لتحويل x إلى y في النظام الثنائي.\n\t>>> hamming_distance(1,2)\n\t2\n*/\nint hamming_distance(int x, int y)",
      "sw": "#include <bits/stdc++.h>\n/*\nHesabu umbali wa Hamming kati ya nambari mbili katika uwakilishi wa binary.\n​    Vigezo:\n- x (int): Nambari ya kwanza chanya (x <= 1,000,000,000).\n- y (int): Nambari ya pili chanya (y <= 1,000,000,000).\n​    Inarudisha:\n​    int: Umbali wa Hamming kati ya x na y, yaani, idadi ya biti zinazohitajika kubadilishwa\n​         ili kubadilisha x kuwa y katika binary.\n\t>>> hamming_distance(1,2)\n\t2\n*/\nint hamming_distance(int x, int y)",
      "tr": "#include <bits/stdc++.h>\n/*\nİki tamsayı arasındaki Hamming mesafesini ikili gösterimde hesaplayın.\n​    Parametreler:\n- x (int): İlk pozitif tamsayı (x <= 1,000,000,000).\n- y (int): İkinci pozitif tamsayı (y <= 1,000,000,000).\n​    Döndürür:\n​    int: x ve y arasındaki Hamming mesafesi, yani x'i ikili olarak y'ye dönüştürmek için\n​         çevrilmesi gereken bit sayısı.\n\t>>> hamming_distance(1,2)\n\t2\n*/\nint hamming_distance(int x, int y)",
      "vi": "#include <bits/stdc++.h>\n/*\nTính khoảng cách Hamming giữa hai số nguyên trong biểu diễn nhị phân.\n​    Tham số:\n- x (int): Số nguyên dương thứ nhất (x <= 1,000,000,000).\n- y (int): Số nguyên dương thứ hai (y <= 1,000,000,000).\n​    Trả về:\n​    int: Khoảng cách Hamming giữa x và y, tức là số bit cần phải thay đổi\n​         để biến đổi x thành y trong nhị phân.\n\t>>> hamming_distance(1,2)\n\t2\n*/\nint hamming_distance(int x, int y)"
    },
    "prompt_bertscore": {
      "es": "0.9688781946386916",
      "arb": "0.973059364159476",
      "sw": "0.9535212853593603",
      "tr": "0.968823372653526",
      "vi": "0.9656371427113454"
    },
    "canonical_solution": "{\n    int distance = 0;\n    int xor_result = x ^ y; // XOR x and y to get a number where set bits are the differences\n    // Count the number of bits set in xor_result\n    // printf(\"%d\\n\", xor_result);\n    while (xor_result) {\n        if (xor_result & 1) {\n            distance++;\n        }\n        xor_result >>= 1;\n    }\n    return distance;\n}",
    "instruction": {
      "en": "int hamming_distance(int x, int y)\n{\n    int distance = 0;\n    int xor_result = x ^ y; // XOR x and y to get a number where set bits are the differences\n    // Count the number of bits set in xor_result\n    // printf(\"%d\\n\", xor_result);\n    while (xor_result) {\n        if (xor_result & 1) {\n            distance++;\n        }\n        xor_result >>= 1;\n    }\n    return distance;\n}\n\nProvide a concise natural language description (docstring) of the CPP code in English using at most 500 characters.",
      "es": "int hamming_distance(int x, int y)\n{\n    int distance = 0;\n    int xor_result = x ^ y; // XOR x and y to get a number where set bits are the differences\n    // Count the number of bits set in xor_result\n    // printf(\"%d\\n\", xor_result);\n    while (xor_result) {\n        if (xor_result & 1) {\n            distance++;\n        }\n        xor_result >>= 1;\n    }\n    return distance;\n}\n\nProporcione una descripción concisa en lenguaje natural (docstring) del código CPP en español utilizando como máximo 500 caracteres.",
      "arb": "int hamming_distance(int x, int y)\n{\n    int distance = 0;\n    int xor_result = x ^ y; // XOR x and y to get a number where set bits are the differences\n    // Count the number of bits set in xor_result\n    // printf(\"%d\\n\", xor_result);\n    while (xor_result) {\n        if (xor_result & 1) {\n            distance++;\n        }\n        xor_result >>= 1;\n    }\n    return distance;\n}\n\nيرجى تقديم وصف موجز بلغة طبيعية (docstring) لشفرة CPP باللغة العربية الفصحى باستخدام 500 حرف كحد أقصى.",
      "sw": "int hamming_distance(int x, int y)\n{\n    int distance = 0;\n    int xor_result = x ^ y; // XOR x and y to get a number where set bits are the differences\n    // Count the number of bits set in xor_result\n    // printf(\"%d\\n\", xor_result);\n    while (xor_result) {\n        if (xor_result & 1) {\n            distance++;\n        }\n        xor_result >>= 1;\n    }\n    return distance;\n}\n\nToa maelezo mafupi ya lugha asilia (docstring) ya msimbo wa CPP kwa Kiswahili kwa kutumia herufi zisizozidi 500.",
      "tr": "int hamming_distance(int x, int y)\n{\n    int distance = 0;\n    int xor_result = x ^ y; // XOR x and y to get a number where set bits are the differences\n    // Count the number of bits set in xor_result\n    // printf(\"%d\\n\", xor_result);\n    while (xor_result) {\n        if (xor_result & 1) {\n            distance++;\n        }\n        xor_result >>= 1;\n    }\n    return distance;\n}\n\nAşağıdaki CPP kodunun Türkçe olarak en fazla 500 karakter kullanarak kısa bir doğal dil açıklamasını (docstring) sağlayın.",
      "vi": "int hamming_distance(int x, int y)\n{\n    int distance = 0;\n    int xor_result = x ^ y; // XOR x and y to get a number where set bits are the differences\n    // Count the number of bits set in xor_result\n    // printf(\"%d\\n\", xor_result);\n    while (xor_result) {\n        if (xor_result & 1) {\n            distance++;\n        }\n        xor_result >>= 1;\n    }\n    return distance;\n}\n\nCung cấp mô tả ngắn gọn bằng ngôn ngữ tự nhiên (docstring) cho mã CPP bằng tiếng Việt với tối đa 500 ký tự."
    },
    "instruction_bertscore": {
      "es": "0.9695565173899258",
      "arb": "0.9189683387960553",
      "sw": "0.9449839529520998",
      "tr": "0.8874105397483754",
      "vi": "0.9171611995893999"
    },
    "level": "",
    "test": "int main() {\n    assert(hamming_distance(1, 2) == 2); // 01 and 10 have 2 different bits\n    assert(hamming_distance(4, 7) == 2); // 100 and 111 have 2 different bits\n    assert(hamming_distance(25, 30) == 3); // Additional test: 11001 and 11110 have 3 different bits\n    assert(hamming_distance(0, 0) == 0); // Additional test: Same numbers have 0 different bits\n    assert(hamming_distance(0xFFFFFFF, 0x0000000) == 28); // Additional test: Max unsigned int and 0 have 32 different bits\n    return 0;\n}",
    "entry_point": "hamming_distance",
    "signature": "int hamming_distance(int x, int y)",
    "docstring": {
      "en": "Calculate the Hamming distance between two integers in binary representation.\n    Parameters:\n- x (int): The first positive integer (x <= 1,000,000,000).\n- y (int): The second positive integer (y <= 1,000,000,000).\n    Returns:\n    int: The Hamming distance between x and y, i.e., the number of bits that need to be flipped to transform x into y in binary.\n    >>> hamming_distance(1,2)\n    2\n",
      "es": "Calcular la distancia de Hamming entre dos enteros en representación binaria.\n    Parámetros:\n- x (int): El primer entero positivo (x <= 1,000,000,000).\n- y (int): El segundo entero positivo (y <= 1,000,000,000).\n    Devuelve:\n    int: La distancia de Hamming entre x e y, es decir, el número de bits que deben ser cambiados para transformar x en y en binario.\n    >>> hamming_distance(1,2)\n    2",
      "arb": "احسب مسافة هامنج بين عددين صحيحين في التمثيل الثنائي.\n    المعاملات:\n- x (int): العدد الصحيح الأول الموجب (x <= 1,000,000,000).\n- y (int): العدد الصحيح الثاني الموجب (y <= 1,000,000,000).\n    يعيد:\n    int: مسافة هامنج بين x و y، أي عدد البتات التي تحتاج إلى قلب لتحويل x إلى y في النظام الثنائي.\n    >>> hamming_distance(1,2)\n    2",
      "sw": "Hesabu umbali wa Hamming kati ya nambari mbili katika uwakilishi wa binary.\n    Vigezo:\n- x (int): Nambari ya kwanza chanya (x <= 1,000,000,000).\n- y (int): Nambari ya pili chanya (y <= 1,000,000,000).\n    Inarejesha:\n    int: Umbali wa Hamming kati ya x na y, yaani, idadi ya biti zinazohitaji kubadilishwa ili kubadilisha x kuwa y katika binary.\n    >>> hamming_distance(1,2)\n    2",
      "tr": "İkili gösterimde iki tamsayı arasındaki Hamming mesafesini hesaplayın.\n    Parametreler:\n- x (int): İlk pozitif tamsayı (x <= 1,000,000,000).\n- y (int): İkinci pozitif tamsayı (y <= 1,000,000,000).\n    Döndürür:\n    int: x ve y arasındaki Hamming mesafesi, yani x'i ikili olarak y'ye dönüştürmek için çevrilmesi gereken bit sayısı.\n    >>> hamming_distance(1,2)\n    2",
      "vi": "Tính khoảng cách Hamming giữa hai số nguyên trong biểu diễn nhị phân.\n    Tham số:\n- x (int): Số nguyên dương thứ nhất (x <= 1,000,000,000).\n- y (int): Số nguyên dương thứ hai (y <= 1,000,000,000).\n    Trả về:\n    int: Khoảng cách Hamming giữa x và y, tức là số bit cần phải lật để biến đổi x thành y trong nhị phân.\n    >>> hamming_distance(1,2)\n    2"
    },
    "docstring_bertscore": {
      "es": "0.9877568205737716",
      "arb": "0.9888826575734773",
      "sw": "0.9742779615471251",
      "tr": "0.9963179886267562",
      "vi": "0.9900289535024297"
    }
  },
  {
    "task_id": "CPP/9",
    "prompt": {
      "en": "#include <assert.h>\n#include <stdarg.h>\n\n/**\n * Count the number of odd integers in a given list of numbers.\n * Parameters:\n * - count (int): The number of integers to evaluate.\n * - ... (int): A sequence of integers.\n * Returns:\n *   int: The count of odd numbers in the input list.\n * Usage:\n *   count_odd_numbers(5, 1, 4, 3, 2, 5) should return 3\n */\nint count_odd_numbers(int count, ...)",
      "es": "#include <assert.h>\n#include <stdarg.h>\n\n/**\n * Cuenta el número de enteros impares en una lista dada de números.\n * Parámetros:\n * - count (int): El número de enteros a evaluar.\n * - ... (int): Una secuencia de enteros.\n * Retorna:\n *   int: La cuenta de números impares en la lista de entrada.\n * Uso:\n *   count_odd_numbers(5, 1, 4, 3, 2, 5) debería retornar 3\n */\nint count_odd_numbers(int count, ...)",
      "arb": "#include <assert.h>\n#include <stdarg.h>\n\n/**\n * عد عدد الأعداد الفردية في قائمة معينة من الأرقام.\n * المعلمات:\n * - count (int): عدد الأعداد لتقييمها.\n * - ... (int): تسلسل من الأعداد.\n * يعيد:\n *   int: عدد الأعداد الفردية في قائمة الإدخال.\n * الاستخدام:\n *   count_odd_numbers(5, 1, 4, 3, 2, 5) يجب أن تعيد 3\n */\nint count_odd_numbers(int count, ...)",
      "sw": "#include <assert.h>\n#include <stdarg.h>\n\n/**\n * Hesabu idadi ya namba zisizo za kawaida katika orodha iliyotolewa ya namba.\n * Vigezo:\n * - count (int): Idadi ya namba za kutathmini.\n * - ... (int): Mlolongo wa namba.\n * Inarudisha:\n *   int: Idadi ya namba zisizo za kawaida katika orodha ya ingizo.\n * Matumizi:\n *   count_odd_numbers(5, 1, 4, 3, 2, 5) inapaswa kurudisha 3\n */\nint count_odd_numbers(int count, ...)",
      "tr": "#include <assert.h>\n#include <stdarg.h>\n\n/**\n * Verilen bir sayı listesindeki tek sayıların sayısını hesaplayın.\n * Parametreler:\n * - count (int): Değerlendirilecek sayıların sayısı.\n * - ... (int): Bir dizi tamsayı.\n * Döndürür:\n *   int: Girdi listesindeki tek sayıların sayısı.\n * Kullanım:\n *   count_odd_numbers(5, 1, 4, 3, 2, 5) 3 döndürmelidir\n */\nint count_odd_numbers(int count, ...)",
      "vi": "#include <assert.h>\n#include <stdarg.h>\n\n/**\n * Đếm số lượng số nguyên lẻ trong một danh sách số đã cho.\n * Tham số:\n * - count (int): Số lượng số nguyên cần đánh giá.\n * - ... (int): Một dãy số nguyên.\n * Trả về:\n *   int: Số lượng số lẻ trong danh sách đầu vào.\n * Sử dụng:\n *   count_odd_numbers(5, 1, 4, 3, 2, 5) sẽ trả về 3\n */\nint count_odd_numbers(int count, ...)"
    },
    "prompt_bertscore": {
      "es": "0.9954517615350631",
      "arb": "0.9858873114274712",
      "sw": "0.9788816178883707",
      "tr": "0.9710581630705496",
      "vi": "0.994089753012307"
    },
    "canonical_solution": "{\n    va_list args;\n    va_start(args, count);\n    int ans = 0;\n    for (int i = 0; i < count; i++) {\n        int num = va_arg(args, int);\n        if (num & 1) {\n            ans++;\n        }\n    }\n    va_end(args);\n    return ans;\n}",
    "instruction": {
      "en": "int count_odd_numbers(int count, ...)\n{\n    va_list args;\n    va_start(args, count);\n    int ans = 0;\n    for (int i = 0; i < count; i++) {\n        int num = va_arg(args, int);\n        if (num & 1) {\n            ans++;\n        }\n    }\n    va_end(args);\n    return ans;\n}\n\nProvide a concise natural language description (docstring) of the CPP code in English using at most 500 characters.",
      "es": "int count_odd_numbers(int count, ...)\n{\n    va_list args;\n    va_start(args, count);\n    int ans = 0;\n    for (int i = 0; i < count; i++) {\n        int num = va_arg(args, int);\n        if (num & 1) {\n            ans++;\n        }\n    }\n    va_end(args);\n    return ans;\n}\n\nProporcione una descripción concisa en lenguaje natural (docstring) del código CPP en español utilizando como máximo 500 caracteres.",
      "arb": "int count_odd_numbers(int count, ...)\n{\n    va_list args;\n    va_start(args, count);\n    int ans = 0;\n    for (int i = 0; i < count; i++) {\n        int num = va_arg(args, int);\n        if (num & 1) {\n            ans++;\n        }\n    }\n    va_end(args);\n    return ans;\n}\n\nيرجى تقديم وصف موجز بلغة طبيعية (docstring) للشفرة البرمجية المكتوبة بلغة CPP باللغة العربية الفصحى، على ألا يتجاوز 500 حرف.",
      "sw": "int count_odd_numbers(int count, ...)\n{\n    va_list args;\n    va_start(args, count);\n    int ans = 0;\n    for (int i = 0; i < count; i++) {\n        int num = va_arg(args, int);\n        if (num & 1) {\n            ans++;\n        }\n    }\n    va_end(args);\n    return ans;\n}\n\nToa maelezo mafupi ya lugha asilia (docstring) ya msimbo wa CPP kwa Kiswahili kwa kutumia herufi zisizozidi 500.",
      "tr": "int count_odd_numbers(int count, ...)\n{\n    va_list args;\n    va_start(args, count);\n    int ans = 0;\n    for (int i = 0; i < count; i++) {\n        int num = va_arg(args, int);\n        if (num & 1) {\n            ans++;\n        }\n    }\n    va_end(args);\n    return ans;\n}\n\nAşağıdaki CPP kodunun işlevini açıklayan, en fazla 500 karakter uzunluğunda bir doğal dil açıklaması (docstring) sağlayın.",
      "vi": "int count_odd_numbers(int count, ...)\n{\n    va_list args;\n    va_start(args, count);\n    int ans = 0;\n    for (int i = 0; i < count; i++) {\n        int num = va_arg(args, int);\n        if (num & 1) {\n            ans++;\n        }\n    }\n    va_end(args);\n    return ans;\n}\n\nCung cấp mô tả ngắn gọn bằng ngôn ngữ tự nhiên (docstring) cho mã CPP bằng tiếng Việt với tối đa 500 ký tự."
    },
    "instruction_bertscore": {
      "es": "0.9695565173899258",
      "arb": "0.8291343722565495",
      "sw": "0.9449839529520998",
      "tr": "0.8400385842842217",
      "vi": "0.9171611995893999"
    },
    "level": "",
    "test": "int main() {\n    assert(count_odd_numbers(5, 1, 4, 3, 2, 5) == 3);\n    assert(count_odd_numbers(4, 2, 2, 0, 0) == 0);\n    assert(count_odd_numbers(6, 7, 7, 8, 1, 9, 10) == 4); // Additional Test Sample\n    // Uncomment the following line to print a success message\n    // std::printf(\"All tests passed!\\n\");\n    return 0;\n}",
    "entry_point": "count_odd_numbers",
    "signature": "int count_odd_numbers(int count, ...)",
    "docstring": {
      "en": "Count the number of odd integers in a given list of numbers.\nParameters:\n- count (int): The number of integers to evaluate.\n- ... (int): A sequence of integers.\nReturns:\n  int: The count of odd numbers in the input list.\nUsage:\n  count_odd_numbers(5, 1, 4, 3, 2, 5) should return 3",
      "es": "Cuenta el número de enteros impares en una lista dada de números.\nParámetros:\n- count (int): La cantidad de enteros a evaluar.\n- ... (int): Una secuencia de enteros.\nDevuelve:\n  int: La cantidad de números impares en la lista de entrada.\nUso:\n  count_odd_numbers(5, 1, 4, 3, 2, 5) debería devolver 3",
      "arb": "احسب عدد الأعداد الفردية في قائمة معينة من الأرقام.\nالمعلمات:\n- count (int): عدد الأعداد التي سيتم تقييمها.\n- ... (int): سلسلة من الأعداد الصحيحة.\nالقيم المعادة:\n  int: عدد الأعداد الفردية في قائمة الإدخال.\nالاستخدام:\n  count_odd_numbers(5, 1, 4, 3, 2, 5) يجب أن تعيد 3",
      "sw": "Hesabu idadi ya nambari zisizo za kawaida katika orodha iliyotolewa ya nambari.  \nVigezo:  \n- count (int): Idadi ya nambari za kutathmini.  \n- ... (int): Mfululizo wa nambari.  \nRudisha:  \n  int: Idadi ya nambari zisizo za kawaida katika orodha ya ingizo.  \nMatumizi:  \n  count_odd_numbers(5, 1, 4, 3, 2, 5) inapaswa kurudisha 3  ",
      "tr": "Verilen bir sayı listesinde tek sayıların sayısını sayın.\nParametreler:\n- count (int): Değerlendirilecek tamsayıların sayısı.\n- ... (int): Bir dizi tamsayı.\nDöndürür:\n  int: Girdi listesindeki tek sayıların sayısı.\nKullanım:\n  count_odd_numbers(5, 1, 4, 3, 2, 5) 3 döndürmelidir.",
      "vi": "Đếm số lượng số nguyên lẻ trong một danh sách số đã cho.\nTham số:\n- count (int): Số lượng số nguyên cần đánh giá.\n- ... (int): Một dãy số nguyên.\nTrả về:\n  int: Số lượng số lẻ trong danh sách đầu vào.\nSử dụng:\n  count_odd_numbers(5, 1, 4, 3, 2, 5) nên trả về 3"
    },
    "docstring_bertscore": {
      "es": "0.995206254384104",
      "arb": "0.9571826391729764",
      "sw": "0.976133367936372",
      "tr": "0.9903950292946769",
      "vi": "0.995206254384104"
    }
  },
  {
    "task_id": "CPP/10",
    "prompt": {
      "en": "#include <cassert>\n#include <iostream>\n#include <vector>\n/**\n * Calculate the sum of even numbers in a given array.\n * \n * Parameters:\n * - numbers (vector<int>): A vector of integers.\n * - size (int): The size of the array.\n * \n * Returns:\n * int: The sum of even numbers in the input array.\n * \n * Examples:\n * >>> calculate_even_sum({1,4,3,2,5}, 5)\n * 6\n */\nint calculate_even_sum(const std::vector<int>& numbers)",
      "es": "#include <cassert>\n#include <iostream>\n#include <vector>\n/**\n * Calcular la suma de números pares en un arreglo dado.\n * \n * Parámetros:\n * - numbers (vector<int>): Un vector de enteros.\n * - size (int): El tamaño del arreglo.\n * \n * Devuelve:\n * int: La suma de los números pares en el arreglo de entrada.\n * \n * Ejemplos:\n * >>> calculate_even_sum({1,4,3,2,5}, 5)\n * 6\n */\nint calculate_even_sum(const std::vector<int>& numbers)",
      "arb": "#include <cassert>\n#include <iostream>\n#include <vector>\n/**\n * حساب مجموع الأعداد الزوجية في مصفوفة معينة.\n * \n * المعاملات:\n * - numbers (vector<int>): متجه من الأعداد الصحيحة.\n * - size (int): حجم المصفوفة.\n * \n * يعيد:\n * int: مجموع الأعداد الزوجية في المصفوفة المدخلة.\n * \n * أمثلة:\n * >>> calculate_even_sum({1,4,3,2,5}, 5)\n * 6\n */\nint calculate_even_sum(const std::vector<int>& numbers)",
      "sw": "#include <cassert>\n#include <iostream>\n#include <vector>\n/**\n * Hesabu jumla ya namba shufwa katika safu iliyotolewa.\n * \n * Vigezo:\n * - numbers (vector<int>): Vector ya namba nzima.\n * - size (int): Ukubwa wa safu.\n * \n * Inarudisha:\n * int: Jumla ya namba shufwa katika safu ya ingizo.\n * \n * Mifano:\n * >>> calculate_even_sum({1,4,3,2,5}, 5)\n * 6\n */\nint calculate_even_sum(const std::vector<int>& numbers)",
      "tr": "#include <cassert>\n#include <iostream>\n#include <vector>\n/**\n * Verilen bir dizideki çift sayıların toplamını hesapla.\n * \n * Parametreler:\n * - numbers (vector<int>): Bir tamsayı vektörü.\n * - size (int): Dizinin boyutu.\n * \n * Döndürür:\n * int: Girdi dizisindeki çift sayıların toplamı.\n * \n * Örnekler:\n * >>> calculate_even_sum({1,4,3,2,5}, 5)\n * 6\n */\nint calculate_even_sum(const std::vector<int>& numbers)",
      "vi": "#include <cassert>\n#include <iostream>\n#include <vector>\n/**\n * Tính tổng các số chẵn trong một mảng cho trước.\n * \n * Tham số:\n * - numbers (vector<int>): Một vector các số nguyên.\n * - size (int): Kích thước của mảng.\n * \n * Trả về:\n * int: Tổng các số chẵn trong mảng đầu vào.\n * \n * Ví dụ:\n * >>> calculate_even_sum({1,4,3,2,5}, 5)\n * 6\n */\nint calculate_even_sum(const std::vector<int>& numbers)"
    },
    "prompt_bertscore": {
      "es": "0.9964635846960549",
      "arb": "1",
      "sw": "0.9820738067419824",
      "tr": "0.9941491434962363",
      "vi": "0.9984723337394606"
    },
    "canonical_solution": "{\n    int ans = 0;\n    for (auto num : numbers) {\n        if ((num & 1) == 0) { // Only sum the even numbers\n            ans += num;\n        }\n    }\n    return ans;\n}",
    "instruction": {
      "en": "int calculate_even_sum(const std::vector<int>& numbers)\n{\n    int ans = 0;\n    for (auto num : numbers) {\n        if ((num & 1) == 0) { // Only sum the even numbers\n            ans += num;\n        }\n    }\n    return ans;\n}\n\nProvide a concise natural language description (docstring) of the CPP code in English using at most 500 characters.",
      "es": "int calculate_even_sum(const std::vector<int>& numbers)\n{\n    int ans = 0;\n    for (auto num : numbers) {\n        if ((num & 1) == 0) { // Only sum the even numbers\n            ans += num;\n        }\n    }\n    return ans;\n}\n\nProporcione una descripción concisa en lenguaje natural (docstring) del código CPP en español utilizando como máximo 500 caracteres.",
      "arb": "int calculate_even_sum(const std::vector<int>& numbers)\n{\n    int ans = 0;\n    for (auto num : numbers) {\n        if ((num & 1) == 0) { // Only sum the even numbers\n            ans += num;\n        }\n    }\n    return ans;\n}\n\nتقديم وصف موجز بلغة طبيعية (docstring) للكود المكتوب بلغة C++ باللغة العربية الفصحى باستخدام 500 حرف كحد أقصى.",
      "sw": "int calculate_even_sum(const std::vector<int>& numbers)\n{\n    int ans = 0;\n    for (auto num : numbers) {\n        if ((num & 1) == 0) { // Only sum the even numbers\n            ans += num;\n        }\n    }\n    return ans;\n}\n\nToa maelezo mafupi ya lugha ya asili (docstring) ya msimbo wa CPP kwa Kiswahili kwa kutumia herufi zisizozidi 500.",
      "tr": "int calculate_even_sum(const std::vector<int>& numbers)\n{\n    int ans = 0;\n    for (auto num : numbers) {\n        if ((num & 1) == 0) { // Only sum the even numbers\n            ans += num;\n        }\n    }\n    return ans;\n}\n\nAşağıdaki CPP kodunun işlevini açıklayan, en fazla 500 karakter uzunluğunda, özlü bir doğal dil açıklaması (docstring) sağlayın.",
      "vi": "int calculate_even_sum(const std::vector<int>& numbers)\n{\n    int ans = 0;\n    for (auto num : numbers) {\n        if ((num & 1) == 0) { // Only sum the even numbers\n            ans += num;\n        }\n    }\n    return ans;\n}\n\nCung cấp mô tả ngắn gọn bằng ngôn ngữ tự nhiên (docstring) cho mã CPP bằng tiếng Việt với tối đa 500 ký tự."
    },
    "instruction_bertscore": {
      "es": "0.9695565173899258",
      "arb": "0.848198717597897",
      "sw": "0.8854305921102196",
      "tr": "0.8552588358614012",
      "vi": "0.9171611995893999"
    },
    "level": "",
    "test": "int main() {\n    std::vector<int> sample1 = {1, 4, 3, 2, 5};\n    std::vector<int> sample2 = {2, 2, 0, 0};\n    std::vector<int> sample3 = {7, 11, 19}; // Additional test with no even numbers\n    std::vector<int> sample4 = {12, 14, 16, 18, 20}; // Additional test with all even numbers\n\n    assert(calculate_even_sum(sample1) == 6);\n    assert(calculate_even_sum(sample2) == 4);\n    assert(calculate_even_sum(sample3) == 0); // Should return 0 because there are no even numbers\n    assert(calculate_even_sum(sample4) == 12 + 14 + 16 + 18 + 20);\n\n    // std::cout << \"All tests passed successfully.\\n\";\n\n    return 0;\n}",
    "entry_point": "calculate_even_sum",
    "signature": "int calculate_even_sum(const std::vector<int>& numbers)",
    "docstring": {
      "en": "Calculate the sum of even numbers in a given array.\n\nParameters:\n- numbers (vector<int>): A vector of integers.\n\nReturns:\nint: The sum of even numbers in the input array.\n\nExamples:\n>>> calculate_even_sum({1,4,3,2,5}, 5)\n6\n",
      "es": "Calcular la suma de números pares en un arreglo dado.\n\nParámetros:\n- numbers (vector<int>): Un vector de enteros.\n\nDevuelve:\nint: La suma de los números pares en el arreglo de entrada.\n\nEjemplos:\n>>> calculate_even_sum({1,4,3,2,5}, 5)\n6",
      "arb": "حساب مجموع الأعداد الزوجية في مصفوفة معينة.\n\nالمعطيات:\n- numbers (vector<int>): متجه من الأعداد الصحيحة.\n\nالقيم المعادة:\nint: مجموع الأعداد الزوجية في المصفوفة المدخلة.\n\nأمثلة:\n>>> calculate_even_sum({1,4,3,2,5}, 5)\n6",
      "sw": "Hesabu jumla ya nambari za jozi katika safu iliyotolewa.\n\nVigezo:\n- numbers (vector<int>): Kundi la nambari za mzima.\n\nRudisha:\nint: Jumla ya nambari za jozi katika safu ya ingizo.\n\nMifano:\n>>> calculate_even_sum({1,4,3,2,5}, 5)\n6",
      "tr": "Verilen bir dizideki çift sayıların toplamını hesaplayın.\n\nParametreler:\n- numbers (vector<int>): Bir tamsayı vektörü.\n\nDöndürülenler:\nint: Girdi dizisindeki çift sayıların toplamı.\n\nÖrnekler:\n>>> calculate_even_sum({1,4,3,2,5}, 5)\n6",
      "vi": "Tính tổng các số chẵn trong một mảng cho trước.\n\nTham số:\n- numbers (vector<int>): Một vector các số nguyên.\n\nTrả về:\nint: Tổng các số chẵn trong mảng đầu vào.\n\nVí dụ:\n>>> calculate_even_sum({1,4,3,2,5}, 5)\n6"
    },
    "docstring_bertscore": {
      "es": "0.9955381657508133",
      "arb": "0.9769429853694702",
      "sw": "0.9736006319477961",
      "tr": "0.9914340648178704",
      "vi": "0.9975447298600277"
    }
  },
  {
    "task_id": "CPP/11",
    "prompt": {
      "en": "#include <cassert>\n#include <cstdio>\n/**\n * Determines if two closed intervals intersect.\n *\n * @param a The lower bound of the first closed interval [a,b].\n * @param b The upper bound of the first closed interval [a,b].\n * @param c The lower bound of the second closed interval [c,d].\n * @param d The upper bound of the second closed interval [c,d].\n *\n * @return 1 if the intervals intersect, 0 otherwise.\n *\n * Examples:\n * are_intervals_intersecting(1, 1, 1, 2) returns 1\n * are_intervals_intersecting(3, 5, 2, 6) returns 1\n * are_intervals_intersecting(3, 5, 4, 7) returns 1\n * are_intervals_intersecting(3, 5, 6, 7) returns 0\n */\nint are_intervals_intersecting(int a, int b, int c, int d)",
      "es": "#include <cassert>\n#include <cstdio>\n/**\n * Determina si dos intervalos cerrados se intersectan.\n *\n * @param a El límite inferior del primer intervalo cerrado [a,b].\n * @param b El límite superior del primer intervalo cerrado [a,b].\n * @param c El límite inferior del segundo intervalo cerrado [c,d].\n * @param d El límite superior del segundo intervalo cerrado [c,d].\n *\n * @return 1 si los intervalos se intersectan, 0 en caso contrario.\n *\n * Ejemplos:\n * are_intervals_intersecting(1, 1, 1, 2) returns 1\n * are_intervals_intersecting(3, 5, 2, 6) returns 1\n * are_intervals_intersecting(3, 5, 4, 7) returns 1\n * are_intervals_intersecting(3, 5, 6, 7) returns 0\n */\nint are_intervals_intersecting(int a, int b, int c, int d)",
      "arb": "#include <cassert>\n#include <cstdio>\n/**\n * يحدد ما إذا كان هناك تقاطع بين فترتين مغلقتين.\n *\n * @param a الحد الأدنى للفترة المغلقة الأولى [a,b].\n * @param b الحد الأعلى للفترة المغلقة الأولى [a,b].\n * @param c الحد الأدنى للفترة المغلقة الثانية [c,d].\n * @param d الحد الأعلى للفترة المغلقة الثانية [c,d].\n *\n * @return 1 إذا كانت الفترات تتقاطع، 0 خلاف ذلك.\n *\n * أمثلة:\n * are_intervals_intersecting(1, 1, 1, 2) returns 1\n * are_intervals_intersecting(3, 5, 2, 6) returns 1\n * are_intervals_intersecting(3, 5, 4, 7) returns 1\n * are_intervals_intersecting(3, 5, 6, 7) returns 0\n */\nint are_intervals_intersecting(int a, int b, int c, int d)",
      "sw": "#include <cassert>\n#include <cstdio>\n/**\n * Huamua kama vipindi viwili vilivyofungwa vinaingiliana.\n *\n * @param a Kikomo cha chini cha kipindi cha kwanza kilichofungwa [a,b].\n * @param b Kikomo cha juu cha kipindi cha kwanza kilichofungwa [a,b].\n * @param c Kikomo cha chini cha kipindi cha pili kilichofungwa [c,d].\n * @param d Kikomo cha juu cha kipindi cha pili kilichofungwa [c,d].\n *\n * @return 1 ikiwa vipindi vinaingiliana, 0 vinginevyo.\n *\n * Mifano:\n * are_intervals_intersecting(1, 1, 1, 2) inarudisha 1\n * are_intervals_intersecting(3, 5, 2, 6) inarudisha 1\n * are_intervals_intersecting(3, 5, 4, 7) inarudisha 1\n * are_intervals_intersecting(3, 5, 6, 7) inarudisha 0\n */\nint are_intervals_intersecting(int a, int b, int c, int d)",
      "tr": "#include <cassert>\n#include <cstdio>\n/**\n * İki kapalı aralığın kesişip kesişmediğini belirler.\n *\n * @param a İlk kapalı aralığın alt sınırı [a,b].\n * @param b İlk kapalı aralığın üst sınırı [a,b].\n * @param c İkinci kapalı aralığın alt sınırı [c,d].\n * @param d İkinci kapalı aralığın üst sınırı [c,d].\n *\n * @return Aralıklar kesişiyorsa 1, aksi takdirde 0.\n *\n * Örnekler:\n * are_intervals_intersecting(1, 1, 1, 2) 1 döndürür\n * are_intervals_intersecting(3, 5, 2, 6) 1 döndürür\n * are_intervals_intersecting(3, 5, 4, 7) 1 döndürür\n * are_intervals_intersecting(3, 5, 6, 7) 0 döndürür\n */\nint are_intervals_intersecting(int a, int b, int c, int d)",
      "vi": "#include <cassert>\n#include <cstdio>\n/**\n * Xác định xem hai khoảng đóng có giao nhau hay không.\n *\n * @param a Giới hạn dưới của khoảng đóng thứ nhất [a,b].\n * @param b Giới hạn trên của khoảng đóng thứ nhất [a,b].\n * @param c Giới hạn dưới của khoảng đóng thứ hai [c,d].\n * @param d Giới hạn trên của khoảng đóng thứ hai [c,d].\n *\n * @return 1 nếu các khoảng giao nhau, 0 nếu không.\n *\n * Ví dụ:\n * are_intervals_intersecting(1, 1, 1, 2) trả về 1\n * are_intervals_intersecting(3, 5, 2, 6) trả về 1\n * are_intervals_intersecting(3, 5, 4, 7) trả về 1\n * are_intervals_intersecting(3, 5, 6, 7) trả về 0\n */\nint are_intervals_intersecting(int a, int b, int c, int d)"
    },
    "prompt_bertscore": {
      "es": "1",
      "arb": "0.9818714023837078",
      "sw": "0.9753777779669153",
      "tr": "0.9730520148353777",
      "vi": "0.969421250100441"
    },
    "canonical_solution": "{\n    if ((c <= a && b <= d) ||\n        (a <= c && c <= b && b <= d) ||\n        (a <= c && d <= b) ||\n        (c <= a && a <= d && d <= b)) {\n        return 1; // Yes\n    } else {\n        return 0; // No\n    }\n}",
    "instruction": {
      "en": "int are_intervals_intersecting(int a, int b, int c, int d)\n{\n    if ((c <= a && b <= d) ||\n        (a <= c && c <= b && b <= d) ||\n        (a <= c && d <= b) ||\n        (c <= a && a <= d && d <= b)) {\n        return 1; // Yes\n    } else {\n        return 0; // No\n    }\n}\n\nProvide a concise natural language description (docstring) of the CPP code in English using at most 500 characters.",
      "es": "int are_intervals_intersecting(int a, int b, int c, int d)\n{\n    if ((c <= a && b <= d) ||\n        (a <= c && c <= b && b <= d) ||\n        (a <= c && d <= b) ||\n        (c <= a && a <= d && d <= b)) {\n        return 1; // Yes\n    } else {\n        return 0; // No\n    }\n}\n\nProporcione una descripción concisa en lenguaje natural (docstring) del código CPP en español utilizando como máximo 500 caracteres.",
      "arb": "int are_intervals_intersecting(int a, int b, int c, int d)\n{\n    if ((c <= a && b <= d) ||\n        (a <= c && c <= b && b <= d) ||\n        (a <= c && d <= b) ||\n        (c <= a && a <= d && d <= b)) {\n        return 1; // Yes\n    } else {\n        return 0; // No\n    }\n}\n\nيرجى تقديم وصف موجز بلغة طبيعية (docstring) للكود المكتوب بلغة CPP باللغة العربية الفصحى، بحيث لا يتجاوز 500 حرف.",
      "sw": "int are_intervals_intersecting(int a, int b, int c, int d)\n{\n    if ((c <= a && b <= d) ||\n        (a <= c && c <= b && b <= d) ||\n        (a <= c && d <= b) ||\n        (c <= a && a <= d && d <= b)) {\n        return 1; // Yes\n    } else {\n        return 0; // No\n    }\n}\n\nToa maelezo mafupi ya lugha asilia (docstring) ya msimbo wa CPP kwa Kiswahili kwa kutumia herufi zisizozidi 500.",
      "tr": "int are_intervals_intersecting(int a, int b, int c, int d)\n{\n    if ((c <= a && b <= d) ||\n        (a <= c && c <= b && b <= d) ||\n        (a <= c && d <= b) ||\n        (c <= a && a <= d && d <= b)) {\n        return 1; // Yes\n    } else {\n        return 0; // No\n    }\n}\n\nAşağıdaki CPP kodunun işlevini açıklayan en fazla 500 karakterlik özlü bir doğal dil açıklaması (docstring) sağlayın.",
      "vi": "int are_intervals_intersecting(int a, int b, int c, int d)\n{\n    if ((c <= a && b <= d) ||\n        (a <= c && c <= b && b <= d) ||\n        (a <= c && d <= b) ||\n        (c <= a && a <= d && d <= b)) {\n        return 1; // Yes\n    } else {\n        return 0; // No\n    }\n}\n\nCung cấp mô tả ngắn gọn bằng ngôn ngữ tự nhiên (docstring) cho mã CPP bằng tiếng Việt với tối đa 500 ký tự."
    },
    "instruction_bertscore": {
      "es": "0.9695565173899258",
      "arb": "0.875213641200928",
      "sw": "0.9449839529520998",
      "tr": "0.8537198476691428",
      "vi": "0.9171611995893999"
    },
    "level": "",
    "test": "int main() {\n    assert(are_intervals_intersecting(1, 1, 1, 2) == 1);\n    assert(are_intervals_intersecting(3, 5, 2, 6) == 1);\n    assert(are_intervals_intersecting(3, 5, 4, 7) == 1);\n    assert(are_intervals_intersecting(3, 5, 6, 7) == 0);\n    // Additional test cases\n    assert(are_intervals_intersecting(0, 0, 0, 0) == 1);\n    assert(are_intervals_intersecting(1, 3, 2, 4) == 1);\n    assert(are_intervals_intersecting(1, 3, 4, 6) == 0);\n    assert(are_intervals_intersecting(10, 20, 20, 30) == 1);\n    assert(are_intervals_intersecting(10, 20, 21, 30) == 0);\n    \n    // printf(\"All tests passed.\\n\");\n    return 0;\n}",
    "entry_point": "are_intervals_intersecting",
    "signature": "int are_intervals_intersecting(int a, int b, int c, int d)",
    "docstring": {
      "en": "Determines if two closed intervals intersect.\n\n@param a The lower bound of the first closed interval [a,b].\n@param b The upper bound of the first closed interval [a,b].\n@param c The lower bound of the second closed interval [c,d].\n@param d The upper bound of the second closed interval [c,d].\n\n@return 1 if the intervals intersect, 0 otherwise.\n\nExamples:\nare_intervals_intersecting(1, 1, 1, 2) returns 1\nare_intervals_intersecting(3, 5, 2, 6) returns 1\nare_intervals_intersecting(3, 5, 4, 7) returns 1\nare_intervals_intersecting(3, 5, 6, 7) returns 0\n",
      "es": "Determina si dos intervalos cerrados se intersectan.\n\n@param a El límite inferior del primer intervalo cerrado [a,b].\n@param b El límite superior del primer intervalo cerrado [a,b].\n@param c El límite inferior del segundo intervalo cerrado [c,d].\n@param d El límite superior del segundo intervalo cerrado [c,d].\n\n@return 1 si los intervalos se intersectan, 0 en caso contrario.\n\nEjemplos:\nare_intervals_intersecting(1, 1, 1, 2) returns 1\nare_intervals_intersecting(3, 5, 2, 6) returns 1\nare_intervals_intersecting(3, 5, 4, 7) returns 1\nare_intervals_intersecting(3, 5, 6, 7) returns 0",
      "arb": "يحدد ما إذا كان هناك تقاطع بين فترتين مغلقتين.\n\n@param a الحد الأدنى للفاصل المغلق الأول [a,b].\n@param b الحد الأقصى للفاصل المغلق الأول [a,b].\n@param c الحد الأدنى للفاصل المغلق الثاني [c,d].\n@param d الحد الأقصى للفاصل المغلق الثاني [c,d].\n\n@return 1 إذا كانت الفواصل تتقاطع، 0 خلاف ذلك.\n\nأمثلة:\nare_intervals_intersecting(1, 1, 1, 2) returns 1\nare_intervals_intersecting(3, 5, 2, 6) returns 1\nare_intervals_intersecting(3, 5, 4, 7) returns 1\nare_intervals_intersecting(3, 5, 6, 7) returns 0",
      "sw": "Huamua kama vipindi viwili vilivyofungwa vinaingiliana.\n\n@param a Chini ya kikomo cha kwanza kilichofungwa [a,b].\n@param b Juu ya kikomo cha kwanza kilichofungwa [a,b].\n@param c Chini ya kikomo cha pili kilichofungwa [c,d].\n@param d Juu ya kikomo cha pili kilichofungwa [c,d].\n\n@return 1 ikiwa vipindi vinaingiliana, 0 vinginevyo.\n\nExamples:\nare_intervals_intersecting(1, 1, 1, 2) returns 1\nare_intervals_intersecting(3, 5, 2, 6) returns 1\nare_intervals_intersecting(3, 5, 4, 7) returns 1\nare_intervals_intersecting(3, 5, 6, 7) returns 0",
      "tr": "İki kapalı aralığın kesişip kesişmediğini belirler.\n\n@param a İlk kapalı aralığın [a,b] alt sınırı.\n@param b İlk kapalı aralığın [a,b] üst sınırı.\n@param c İkinci kapalı aralığın [c,d] alt sınırı.\n@param d İkinci kapalı aralığın [c,d] üst sınırı.\n\n@return Aralıklar kesişiyorsa 1, aksi takdirde 0.\n\nÖrnekler:\nare_intervals_intersecting(1, 1, 1, 2) 1 döndürür\nare_intervals_intersecting(3, 5, 2, 6) 1 döndürür\nare_intervals_intersecting(3, 5, 4, 7) 1 döndürür\nare_intervals_intersecting(3, 5, 6, 7) 0 döndürür",
      "vi": "Xác định xem hai khoảng đóng có giao nhau hay không.\n\n@param a Giới hạn dưới của khoảng đóng đầu tiên [a,b].\n@param b Giới hạn trên của khoảng đóng đầu tiên [a,b].\n@param c Giới hạn dưới của khoảng đóng thứ hai [c,d].\n@param d Giới hạn trên của khoảng đóng thứ hai [c,d].\n\n@return 1 nếu các khoảng giao nhau, 0 nếu không.\n\nVí dụ:\nare_intervals_intersecting(1, 1, 1, 2) trả về 1\nare_intervals_intersecting(3, 5, 2, 6) trả về 1\nare_intervals_intersecting(3, 5, 4, 7) trả về 1\nare_intervals_intersecting(3, 5, 6, 7) trả về 0"
    },
    "docstring_bertscore": {
      "es": "0.999999801369619",
      "arb": "0.9652150531516462",
      "sw": "0.9709505054040286",
      "tr": "0.9674480558952404",
      "vi": "0.9623045221783421"
    }
  },
  {
    "task_id": "CPP/12",
    "prompt": {
      "en": "#include <cassert>\n#include <cmath>\n#include <cstdio>\n/**\n * You are given three integers a, b, c, where two of them are equal, and the\n * third is different from the other two. Your task is to find the value that\n * occurs exactly once.\n *\n * Examples:\n *   extraNumber(0, 0, 1) returns 1\n *   extraNumber(4, 3, 4) returns 3\n */\nint extraNumber(int a, int b, int c)",
      "es": "#include <cassert>\n#include <cmath>\n#include <cstdio>\n/**\n * Se te dan tres enteros a, b, c, donde dos de ellos son iguales, y el\n * tercero es diferente de los otros dos. Tu tarea es encontrar el valor que\n * ocurre exactamente una vez.\n *\n * Ejemplos:\n *   extraNumber(0, 0, 1) returns 1\n *   extraNumber(4, 3, 4) returns 3\n */\nint extraNumber(int a, int b, int c)",
      "arb": "#include <cassert>\n#include <cmath>\n#include <cstdio>\n/**\n * لديك ثلاثة أعداد صحيحة a, b, c، حيث أن اثنين منهما متساويان،\n * والثالث مختلف عن الآخرين. مهمتك هي إيجاد القيمة التي تظهر مرة واحدة فقط.\n *\n * أمثلة:\n *   extraNumber(0, 0, 1) returns 1\n *   extraNumber(4, 3, 4) returns 3\n */\nint extraNumber(int a, int b, int c)",
      "sw": "#include <cassert>\n#include <cmath>\n#include <cstdio>\n/**\n * Umepewa nambari tatu za mzima a, b, c, ambapo mbili kati yao ni sawa, na\n * ya tatu ni tofauti na zile mbili nyingine. Kazi yako ni kupata thamani ambayo\n * inatokea mara moja tu.\n *\n * Mifano:\n *   extraNumber(0, 0, 1) inarudisha 1\n *   extraNumber(4, 3, 4) inarudisha 3\n */\nint extraNumber(int a, int b, int c)",
      "tr": "#include <cassert>\n#include <cmath>\n#include <cstdio>\n/**\n * Üç tamsayı a, b, c verilir, bunlardan ikisi eşittir ve\n * üçüncüsü diğer ikisinden farklıdır. Göreviniz, tam olarak bir kez\n * geçen değeri bulmaktır.\n *\n * Örnekler:\n *   extraNumber(0, 0, 1) 1 döndürür\n *   extraNumber(4, 3, 4) 3 döndürür\n */\nint extraNumber(int a, int b, int c)",
      "vi": "#include <cassert>\n#include <cmath>\n#include <cstdio>\n/**\n * Bạn được cung cấp ba số nguyên a, b, c, trong đó hai số bằng nhau, và\n * số thứ ba khác với hai số còn lại. Nhiệm vụ của bạn là tìm giá trị xuất hiện\n * chính xác một lần.\n *\n * Ví dụ:\n *   extraNumber(0, 0, 1) trả về 1\n *   extraNumber(4, 3, 4) trả về 3\n */\nint extraNumber(int a, int b, int c)"
    },
    "prompt_bertscore": {
      "es": "0.9903763580388597",
      "arb": "0.9721464589282397",
      "sw": "0.9813954839907483",
      "tr": "0.9816431760758988",
      "vi": "0.9825950128618179"
    },
    "canonical_solution": "{\n    if (a == b) {\n        return c;\n    } else if (a == c) {\n        return b;\n    } else {\n        return a;\n    }\n}",
    "instruction": {
      "en": "int extraNumber(int a, int b, int c)\n{\n    if (a == b) {\n        return c;\n    } else if (a == c) {\n        return b;\n    } else {\n        return a;\n    }\n}\n\nProvide a concise natural language description (docstring) of the CPP code in English using at most 500 characters.",
      "es": "int extraNumber(int a, int b, int c)\n{\n    if (a == b) {\n        return c;\n    } else if (a == c) {\n        return b;\n    } else {\n        return a;\n    }\n}\n\nProporciona una descripción concisa en lenguaje natural (docstring) del código CPP en español utilizando un máximo de 500 caracteres.",
      "arb": "int extraNumber(int a, int b, int c)\n{\n    if (a == b) {\n        return c;\n    } else if (a == c) {\n        return b;\n    } else {\n        return a;\n    }\n}\n\nقدم وصفًا موجزًا بلغة طبيعية (docstring) لشيفرة CPP باللغة العربية الفصحى باستخدام ما لا يزيد عن 500 حرف.",
      "sw": "int extraNumber(int a, int b, int c)\n{\n    if (a == b) {\n        return c;\n    } else if (a == c) {\n        return b;\n    } else {\n        return a;\n    }\n}\n\nToa maelezo mafupi ya lugha ya asili (docstring) ya msimbo wa CPP kwa Kiswahili kwa kutumia herufi zisizozidi 500.",
      "tr": "int extraNumber(int a, int b, int c)\n{\n    if (a == b) {\n        return c;\n    } else if (a == c) {\n        return b;\n    } else {\n        return a;\n    }\n}\n\nAşağıdaki CPP kodunun işlevini açıklayan, en fazla 500 karakter uzunluğunda Türkçe bir doğal dil açıklaması (docstring) sağlayın.",
      "vi": "int extraNumber(int a, int b, int c)\n{\n    if (a == b) {\n        return c;\n    } else if (a == c) {\n        return b;\n    } else {\n        return a;\n    }\n}\n\nCung cấp mô tả ngắn gọn bằng ngôn ngữ tự nhiên (docstring) cho mã CPP bằng tiếng Việt với tối đa 500 ký tự."
    },
    "instruction_bertscore": {
      "es": "0.9695565173899258",
      "arb": "0.9230905150936723",
      "sw": "0.9164634110608243",
      "tr": "0.8461508383694274",
      "vi": "0.9343528576983505"
    },
    "level": "",
    "test": "int main() {\n    assert(extraNumber(2, 7, 2) == 7);\n    assert(extraNumber(3, 2, 2) == 3);\n    assert(extraNumber(5, 5, 1) == 1);\n    assert(extraNumber(500000000, 3, 500000000) == 3);\n    assert(extraNumber(500000000, 500000000, 3) == 3);\n\n    \n    return 0;\n}",
    "entry_point": "extraNumber",
    "signature": "int extraNumber(int a, int b, int c)",
    "docstring": {
      "en": "You are given three integers a, b, c, where two of them are equal, and the third is different from the other two. Your task is to find the value that occurs exactly once.\n\nExamples:\n  extraNumber(0, 0, 1) returns 1\n  extraNumber(4, 3, 4) returns 3\n",
      "es": "Se te dan tres enteros a, b, c, donde dos de ellos son iguales y el tercero es diferente de los otros dos. Tu tarea es encontrar el valor que ocurre exactamente una vez.\n\nEjemplos:\n  extraNumber(0, 0, 1) devuelve 1\n  extraNumber(4, 3, 4) devuelve 3",
      "arb": "أنت مُعطى ثلاثة أعداد صحيحة a، b، c، حيث يكون اثنان منها متساويين، والثالث مختلف عن الآخرين. مهمتك هي إيجاد القيمة التي تظهر مرة واحدة فقط.\n\nأمثلة:\n  extraNumber(0, 0, 1) returns 1\n  extraNumber(4, 3, 4) returns 3",
      "sw": "Unapewa nambari tatu za integer a, b, c, ambapo mbili kati ya hizo ni sawa, na ya tatu ni tofauti na hizo mbili. Kazi yako ni kupata thamani inayotokea mara moja tu.\n\nMifano:\n  extraNumber(0, 0, 1) inarejesha 1\n  extraNumber(4, 3, 4) inarejesha 3",
      "tr": "Üç tamsayı a, b, c verilir; bunlardan ikisi eşittir ve üçüncüsü diğer ikisinden farklıdır. Göreviniz, tam olarak bir kez geçen değeri bulmaktır.\n\nÖrnekler:\n  extraNumber(0, 0, 1) 1 döndürür\n  extraNumber(4, 3, 4) 3 döndürür",
      "vi": "Bạn được cung cấp ba số nguyên a, b, c, trong đó hai số bằng nhau, và số thứ ba khác với hai số còn lại. Nhiệm vụ của bạn là tìm giá trị xuất hiện đúng một lần.\n\nVí dụ:\n  extraNumber(0, 0, 1) trả về 1\n  extraNumber(4, 3, 4) trả về 3"
    },
    "docstring_bertscore": {
      "es": "0.9890749317823191",
      "arb": "0.9787459533381239",
      "sw": "0.9724150072033989",
      "tr": "0.9701653195077977",
      "vi": "0.9739518104614658"
    }
  },
  {
    "task_id": "CPP/13",
    "prompt": {
      "en": "#include <cassert>\n#include <cmath>\n#include <cstdio>\n#include <cstring>\n/**\n * Calculate the total score for a student based on the scores in different subjects.\n *\n * Parameters:\n * - subject_scores (list): A list containing the scores for each subject.\n *\n * Returns:\n *   int: The total score obtained by summing up the scores in all subjects.\n *\n * Examples:\n *   >>> calculate_total_score(100,100,100,100,100)\n *   500\n */\nint calculate_total_score(int score1, int score2, int score3, int score4, int score5)",
      "es": "#include <cassert>\n#include <cmath>\n#include <cstdio>\n#include <cstring>\n/**\n * Calcular la puntuación total de un estudiante basada en las puntuaciones en diferentes materias.\n *\n * Parámetros:\n * - subject_scores (list): Una lista que contiene las puntuaciones para cada materia.\n *\n * Devuelve:\n *   int: La puntuación total obtenida al sumar las puntuaciones en todas las materias.\n *\n * Ejemplos:\n *   >>> calculate_total_score(100,100,100,100,100)\n *   500\n */\nint calculate_total_score(int score1, int score2, int score3, int score4, int score5)",
      "arb": "#include <cassert>\n#include <cmath>\n#include <cstdio>\n#include <cstring>\n/**\n * حساب المجموع الكلي للدرجات لطالب بناءً على الدرجات في مواد مختلفة.\n *\n * المعلمات:\n * - subject_scores (list): قائمة تحتوي على الدرجات لكل مادة.\n *\n * يعيد:\n *   int: المجموع الكلي الذي يتم الحصول عليه بجمع الدرجات في جميع المواد.\n *\n * أمثلة:\n *   >>> calculate_total_score(100,100,100,100,100)\n *   500\n */\nint calculate_total_score(int score1, int score2, int score3, int score4, int score5)",
      "sw": "#include <cassert>\n#include <cmath>\n#include <cstdio>\n#include <cstring>\n/**\n * Hesabu jumla ya alama kwa mwanafunzi kulingana na alama katika masomo tofauti.\n *\n * Vigezo:\n * - subject_scores (list): Orodha inayoonyesha alama za kila somo.\n *\n * Inarudisha:\n *   int: Jumla ya alama zilizopatikana kwa kujumlisha alama katika masomo yote.\n *\n * Mifano:\n *   >>> calculate_total_score(100,100,100,100,100)\n *   500\n */\nint calculate_total_score(int score1, int score2, int score3, int score4, int score5)",
      "tr": "#include <cassert>\n#include <cmath>\n#include <cstdio>\n#include <cstring>\n/**\n * Farklı derslerdeki puanlara göre bir öğrencinin toplam puanını hesaplayın.\n *\n * Parametreler:\n * - subject_scores (list): Her ders için puanları içeren bir liste.\n *\n * Döndürür:\n *   int: Tüm derslerdeki puanların toplanmasıyla elde edilen toplam puan.\n *\n * Örnekler:\n *   >>> calculate_total_score(100,100,100,100,100)\n *   500\n */\nint calculate_total_score(int score1, int score2, int score3, int score4, int score5)",
      "vi": "#include <cassert>\n#include <cmath>\n#include <cstdio>\n#include <cstring>\n/**\n * Tính tổng điểm cho một học sinh dựa trên điểm số ở các môn học khác nhau.\n *\n * Tham số:\n * - subject_scores (list): Một danh sách chứa điểm số cho mỗi môn học.\n *\n * Trả về:\n *   int: Tổng điểm đạt được bằng cách cộng điểm số của tất cả các môn học.\n *\n * Ví dụ:\n *   >>> calculate_total_score(100,100,100,100,100)\n *   500\n */\nint calculate_total_score(int score1, int score2, int score3, int score4, int score5)"
    },
    "prompt_bertscore": {
      "es": "0.986996662105551",
      "arb": "0.9835450619743078",
      "sw": "0.990657221397643",
      "tr": "0.9865564971811778",
      "vi": "0.9856733865070966"
    },
    "canonical_solution": "{\n    return score1 + score2 + score3 + score4 + score5;\n}",
    "instruction": {
      "en": "int calculate_total_score(int score1, int score2, int score3, int score4, int score5)\n{\n    return score1 + score2 + score3 + score4 + score5;\n}\n\nProvide a concise natural language description (docstring) of the CPP code in English using at most 500 characters.",
      "es": "int calculate_total_score(int score1, int score2, int score3, int score4, int score5)\n{\n    return score1 + score2 + score3 + score4 + score5;\n}\n\nProporcione una descripción concisa en lenguaje natural (docstring) del código CPP en español utilizando como máximo 500 caracteres.",
      "arb": "int calculate_total_score(int score1, int score2, int score3, int score4, int score5)\n{\n    return score1 + score2 + score3 + score4 + score5;\n}\n\nيرجى تقديم وصف موجز بلغة طبيعية (docstring) للشيفرة المكتوبة بلغة CPP باللغة العربية الفصحى، بحيث لا يتجاوز 500 حرف.",
      "sw": "int calculate_total_score(int score1, int score2, int score3, int score4, int score5)\n{\n    return score1 + score2 + score3 + score4 + score5;\n}\n\nToa maelezo mafupi ya lugha ya asili (docstring) ya msimbo wa CPP kwa Kiswahili kwa kutumia herufi zisizozidi 500.",
      "tr": "int calculate_total_score(int score1, int score2, int score3, int score4, int score5)\n{\n    return score1 + score2 + score3 + score4 + score5;\n}\n\nAşağıdaki CPP kodunun Türkçe olarak en fazla 500 karakter kullanarak kısa bir doğal dil açıklamasını (docstring) sağlayın.",
      "vi": "int calculate_total_score(int score1, int score2, int score3, int score4, int score5)\n{\n    return score1 + score2 + score3 + score4 + score5;\n}\n\nCung cấp mô tả ngắn gọn bằng ngôn ngữ tự nhiên (docstring) cho mã CPP bằng tiếng Việt, không quá 500 ký tự."
    },
    "instruction_bertscore": {
      "es": "0.9695565173899258",
      "arb": "0.875213641200928",
      "sw": "0.9176812139269492",
      "tr": "0.8874105397483754",
      "vi": "0.8987727934347141"
    },
    "level": "",
    "test": "int main() {\n    assert(calculate_total_score(100,100,100,100,100) == 500);\n    assert(calculate_total_score(0,0,0,0,0) == 0);\n    assert(calculate_total_score(20, 30, 40, 10, 50) == 150);\n    assert(calculate_total_score(23, 45, 67, 89, 12) == 236);\n    assert(calculate_total_score(5, 5, 5, 5, 5) == 25);\n    return 0;\n}",
    "entry_point": "calculate_total_score",
    "signature": "int calculate_total_score(int score1, int score2, int score3, int score4, int score5)",
    "docstring": {
      "en": "Calculate the total score for a student based on the scores in different subjects.\n\nParameters:\n- score1 (int): The score for the first subject.\n- score2 (int): The score for the second subject.\n- score3 (int): The score for the third subject.\n- score4 (int): The score for the fourth subject.\n- score5 (int): The score for the fifth subject.\n\nReturns:\n  int: The total score obtained by summing up the scores in all subjects.\n\nExamples:\n  >>> calculate_total_score(100,100,100,100,100)\n  500\n",
      "es": "Calcular la puntuación total para un estudiante basado en las puntuaciones en diferentes materias.\n\nParámetros:\n- score1 (int): La puntuación para la primera materia.\n- score2 (int): La puntuación para la segunda materia.\n- score3 (int): La puntuación para la tercera materia.\n- score4 (int): La puntuación para la cuarta materia.\n- score5 (int): La puntuación para la quinta materia.\n\nDevuelve:\n  int: La puntuación total obtenida al sumar las puntuaciones en todas las materias.\n\nEjemplos:\n  >>> calculate_total_score(100,100,100,100,100)\n  500",
      "arb": "احسب المجموع الكلي للدرجات لطالب بناءً على الدرجات في مواد مختلفة.\n\nالمعلمات:\n- score1 (int): الدرجة للمادة الأولى.\n- score2 (int): الدرجة للمادة الثانية.\n- score3 (int): الدرجة للمادة الثالثة.\n- score4 (int): الدرجة للمادة الرابعة.\n- score5 (int): الدرجة للمادة الخامسة.\n\nالقيم المعادة:\n  int: المجموع الكلي للدرجات المحصل عليه بجمع الدرجات في جميع المواد.\n\nأمثلة:\n  >>> calculate_total_score(100,100,100,100,100)\n  500",
      "sw": "Hesabu jumla ya alama kwa mwanafunzi kulingana na alama katika masomo tofauti.\n\nVigezo:\n- score1 (int): Alama ya somo la kwanza.\n- score2 (int): Alama ya somo la pili.\n- score3 (int): Alama ya somo la tatu.\n- score4 (int): Alama ya somo la nne.\n- score5 (int): Alama ya somo la tano.\n\nInarejesha:\n  int: Jumla ya alama iliyopatikana kwa kujumlisha alama katika masomo yote.\n\nMifano:\n  >>> calculate_total_score(100,100,100,100,100)\n  500",
      "tr": "Bir öğrencinin farklı derslerdeki puanlarına dayanarak toplam puanını hesaplayın.\n\nParametreler:\n- score1 (int): Birinci dersin puanı.\n- score2 (int): İkinci dersin puanı.\n- score3 (int): Üçüncü dersin puanı.\n- score4 (int): Dördüncü dersin puanı.\n- score5 (int): Beşinci dersin puanı.\n\nDöndürülenler:\n  int: Tüm derslerdeki puanların toplanmasıyla elde edilen toplam puan.\n\nÖrnekler:\n  >>> calculate_total_score(100,100,100,100,100)\n  500",
      "vi": "Tính tổng điểm cho một học sinh dựa trên điểm số ở các môn học khác nhau.\n\nTham số:\n- score1 (int): Điểm số cho môn học thứ nhất.\n- score2 (int): Điểm số cho môn học thứ hai.\n- score3 (int): Điểm số cho môn học thứ ba.\n- score4 (int): Điểm số cho môn học thứ tư.\n- score5 (int): Điểm số cho môn học thứ năm.\n\nTrả về:\n  int: Tổng điểm đạt được bằng cách cộng điểm số ở tất cả các môn học.\n\nVí dụ:\n  >>> calculate_total_score(100,100,100,100,100)\n  500"
    },
    "docstring_bertscore": {
      "es": "0.9884798351607386",
      "arb": "0.9533987304142618",
      "sw": "0.9689010371325106",
      "tr": "0.9649351829447681",
      "vi": "0.9730631381367157"
    }
  },
  {
    "task_id": "CPP/14",
    "prompt": {
      "en": "#include <cassert>\n#include <cstring>\n#include <iostream>\n/*\nDecode a series of numbers to reveal the pattern and understand the actual values \neach digit represents.\n\nEquations provided for reference:\n0000=4 8888=8 1234=1 5678=3 9012=2 1357=0 2468=4\n\nParameters:\n- data_str: A constant character array (C-style string) representing a series of numbers. Length does not exceed 100.\n\nReturns:\nint: The result of each data string corresponding to the right-hand side of the equation.\n\nExample usage:\nassert(decode_numbers(\"0000\") == 4);\n*/\nint decode_numbers(const char* data_str)",
      "es": "#include <cassert>\n#include <cstring>\n#include <iostream>\n/*\nDecodificar una serie de números para revelar el patrón y entender los valores reales \nque cada dígito representa.\n\nEcuaciones proporcionadas como referencia:\n0000=4 8888=8 1234=1 5678=3 9012=2 1357=0 2468=4\n\nParámetros:\n- data_str: Una matriz de caracteres constante (cadena estilo C) que representa una serie de números. La longitud no excede 100.\n\nDevuelve:\nint: El resultado de cada cadena de datos correspondiente al lado derecho de la ecuación.\n\nEjemplo de uso:\nassert(decode_numbers(\"0000\") == 4);\n*/\nint decode_numbers(const char* data_str)",
      "arb": "#include <cassert>\n#include <cstring>\n#include <iostream>\n/*\nفك سلسلة من الأرقام للكشف عن النمط وفهم القيم الفعلية التي يمثلها كل رقم.\n\nالمعادلات المقدمة للمرجع:\n0000=4 8888=8 1234=1 5678=3 9012=2 1357=0 2468=4\n\nالمعلمات:\n- data_str: مصفوفة حرفية ثابتة (سلسلة نمط C) تمثل سلسلة من الأرقام. الطول لا يتجاوز 100.\n\nالإرجاع:\nint: نتيجة كل سلسلة بيانات مطابقة للجانب الأيمن من المعادلة.\n\nمثال على الاستخدام:\nassert(decode_numbers(\"0000\") == 4);\n*/\nint decode_numbers(const char* data_str)",
      "sw": "#include <cassert>\n#include <cstring>\n#include <iostream>\n/*\nFasiri mfululizo wa nambari ili kufichua muundo na kuelewa thamani halisi \nambayo kila tarakimu inawakilisha.\n\nMlinganyo uliotolewa kwa marejeleo:\n0000=4 8888=8 1234=1 5678=3 9012=2 1357=0 2468=4\n\nVigezo:\n- data_str: Mfululizo wa herufi wa tabia za kudumu (mfululizo wa C-style) unaowakilisha mfululizo wa nambari. Urefu hauzidi 100.\n\nInarudisha:\nint: Matokeo ya kila mfululizo wa data yanayolingana na upande wa kulia wa mlinganyo.\n\nMfano wa matumizi:\nassert(decode_numbers(\"0000\") == 4);\n*/\nint decode_numbers(const char* data_str)",
      "tr": "#include <cassert>\n#include <cstring>\n#include <iostream>\n/*\nBir dizi sayıyı çözerek deseni ortaya çıkarın ve her bir rakamın temsil ettiği gerçek değerleri anlayın.\n\nReferans için sağlanan denklemler:\n0000=4 8888=8 1234=1 5678=3 9012=2 1357=0 2468=4\n\nParametreler:\n- data_str: Bir dizi sayıyı temsil eden sabit karakter dizisi (C tarzı dize). Uzunluğu 100'ü geçmez.\n\nDöndürür:\nint: Her veri dizisinin denklemin sağ tarafına karşılık gelen sonucu.\n\nÖrnek kullanım:\nassert(decode_numbers(\"0000\") == 4);\n*/\nint decode_numbers(const char* data_str)",
      "vi": "#include <cassert>\n#include <cstring>\n#include <iostream>\n/*\nGiải mã một chuỗi số để tiết lộ mẫu và hiểu các giá trị thực tế mà mỗi chữ số đại diện.\n\nCác phương trình được cung cấp để tham khảo:\n0000=4 8888=8 1234=1 5678=3 9012=2 1357=0 2468=4\n\nTham số:\n- data_str: Một mảng ký tự hằng số (chuỗi kiểu C) đại diện cho một chuỗi số. Độ dài không vượt quá 100.\n\nTrả về:\nint: Kết quả của mỗi chuỗi dữ liệu tương ứng với vế phải của phương trình.\n\nVí dụ sử dụng:\nassert(decode_numbers(\"0000\") == 4);\n*/\nint decode_numbers(const char* data_str)"
    },
    "prompt_bertscore": {
      "es": "0.9855687082962913",
      "arb": "0.9739273789245985",
      "sw": "0.9703129018809067",
      "tr": "0.9679108646830518",
      "vi": "0.9767519029429146"
    },
    "canonical_solution": "{\n    int a[] = {1, 0, 0, 0, 1, 0, 1, 0, 2, 1};\n    int ans = 0;\n    for(int i = 0; i < std::strlen(data_str); i++) {\n        ans += a[data_str[i] - '0'];\n    }\n    return ans;\n}",
    "instruction": {
      "en": "int decode_numbers(const char* data_str)\n{\n    int a[] = {1, 0, 0, 0, 1, 0, 1, 0, 2, 1};\n    int ans = 0;\n    for(int i = 0; i < std::strlen(data_str); i++) {\n        ans += a[data_str[i] - '0'];\n    }\n    return ans;\n}\n\nProvide a concise natural language description (docstring) of the CPP code in English using at most 500 characters.",
      "es": "int decode_numbers(const char* data_str)\n{\n    int a[] = {1, 0, 0, 0, 1, 0, 1, 0, 2, 1};\n    int ans = 0;\n    for(int i = 0; i < std::strlen(data_str); i++) {\n        ans += a[data_str[i] - '0'];\n    }\n    return ans;\n}\n\nProporciona una descripción concisa en lenguaje natural (docstring) del código CPP en español utilizando como máximo 500 caracteres.",
      "arb": "int decode_numbers(const char* data_str)\n{\n    int a[] = {1, 0, 0, 0, 1, 0, 1, 0, 2, 1};\n    int ans = 0;\n    for(int i = 0; i < std::strlen(data_str); i++) {\n        ans += a[data_str[i] - '0'];\n    }\n    return ans;\n}\n\nيرجى تقديم وصف موجز بلغة طبيعية (docstring) للشفرة البرمجية بلغة C++ باللغة العربية الفصحى، بحيث لا يتجاوز 500 حرف.",
      "sw": "int decode_numbers(const char* data_str)\n{\n    int a[] = {1, 0, 0, 0, 1, 0, 1, 0, 2, 1};\n    int ans = 0;\n    for(int i = 0; i < std::strlen(data_str); i++) {\n        ans += a[data_str[i] - '0'];\n    }\n    return ans;\n}\n\nToa maelezo mafupi ya lugha asilia (docstring) ya msimbo wa CPP kwa Kiswahili kwa kutumia herufi zisizozidi 500.",
      "tr": "int decode_numbers(const char* data_str)\n{\n    int a[] = {1, 0, 0, 0, 1, 0, 1, 0, 2, 1};\n    int ans = 0;\n    for(int i = 0; i < std::strlen(data_str); i++) {\n        ans += a[data_str[i] - '0'];\n    }\n    return ans;\n}\n\nAşağıdaki CPP kodunun Türkçe'de en fazla 500 karakter kullanarak kısa bir doğal dil açıklamasını (docstring) sağlayın.",
      "vi": "int decode_numbers(const char* data_str)\n{\n    int a[] = {1, 0, 0, 0, 1, 0, 1, 0, 2, 1};\n    int ans = 0;\n    for(int i = 0; i < std::strlen(data_str); i++) {\n        ans += a[data_str[i] - '0'];\n    }\n    return ans;\n}\n\nCung cấp mô tả ngắn gọn bằng ngôn ngữ tự nhiên (docstring) cho mã CPP bằng tiếng Việt, không quá 500 ký tự."
    },
    "instruction_bertscore": {
      "es": "0.9695565173899258",
      "arb": "0.8562400699437135",
      "sw": "0.9449839529520998",
      "tr": "0.8766952252130673",
      "vi": "0.8987727934347141"
    },
    "level": "",
    "test": "int main() {\n    // Assert basic provided test cases\n    assert(decode_numbers(\"0000\") == 4);\n    assert(decode_numbers(\"8888\") == 8);\n    assert(decode_numbers(\"1234\") == 1);\n    assert(decode_numbers(\"5678\") == 3);\n    assert(decode_numbers(\"9012\") == 2);\n    assert(decode_numbers(\"1357\") == 0);\n    assert(decode_numbers(\"2468\") == 4);\n\n    // Assert additional test cases\n    assert(decode_numbers(\"9999\") == 4);\n    assert(decode_numbers(\"1111\") == 0);\n    assert(decode_numbers(\"2222\") == 0);\n    assert(decode_numbers(\"3333\") == 0);\n    assert(decode_numbers(\"4444\") == 4);\n    assert(decode_numbers(\"5555\") == 0);\n    assert(decode_numbers(\"6666\") == 4);\n    assert(decode_numbers(\"7777\") == 0);\n    assert(decode_numbers(\"0001\") == 3);\n    assert(decode_numbers(\"2301\") == 1);\n\n    // Indicate that all tests passed\n    // std::cout << \"All tests passed successfully!\" << std::endl;\n\n    return 0;\n}",
    "entry_point": "decode_numbers",
    "signature": "int decode_numbers(const char* data_str)",
    "docstring": {
      "en": "Decode a series of numbers to reveal the pattern and understand the actual values each digit represents.\n\nEquations provided for reference:\n0000=4 8888=8 1234=1 5678=3 9012=2 1357=0 2468=4\n\nParameters:\n- data_str: A constant character array (C-style string) representing a series of numbers. Length does not exceed 100.\n\nReturns:\nint: The result of each data string corresponding to the right-hand side of the equation.\n\nExample usage:\nassert(decode_numbers(\"0000\") == 4);",
      "es": "Decodificar una serie de números para revelar el patrón y entender los valores reales que representa cada dígito.\n\nEcuaciones proporcionadas como referencia:\n0000=4 8888=8 1234=1 5678=3 9012=2 1357=0 2468=4\n\nParámetros:\n- data_str: Una matriz de caracteres constante (cadena de estilo C) que representa una serie de números. La longitud no excede de 100.\n\nDevuelve:\nint: El resultado de cada cadena de datos correspondiente al lado derecho de la ecuación.\n\nEjemplo de uso:\nassert(decode_numbers(\"0000\") == 4);",
      "arb": "فك سلسلة من الأرقام للكشف عن النمط وفهم القيم الفعلية التي يمثلها كل رقم.\n\nالمعادلات المقدمة للرجوع إليها:\n0000=4 8888=8 1234=1 5678=3 9012=2 1357=0 2468=4\n\nالمعلمات:\n- data_str: مصفوفة ثابتة من الأحرف (سلسلة نمط C) تمثل سلسلة من الأرقام. الطول لا يتجاوز 100.\n\nالقيم المعادة:\nint: نتيجة كل سلسلة بيانات تتوافق مع الجانب الأيمن من المعادلة.\n\nمثال على الاستخدام:\nassert(decode_numbers(\"0000\") == 4);",
      "sw": "Fasiri mfululizo wa nambari ili kufichua muundo na kuelewa thamani halisi ambayo kila tarakimu inawakilisha.\n\nMlinganyo uliotolewa kwa marejeleo:\n0000=4 8888=8 1234=1 5678=3 9012=2 1357=0 2468=4\n\nVigezo:\n- data_str: Safu ya tabia ya kudumu (mfululizo wa herufi za mtindo wa C) inayowakilisha mfululizo wa nambari. Urefu hauzidi 100.\n\nInarejesha:\nint: Matokeo ya kila mfululizo wa data yanayolingana na upande wa kulia wa mlinganyo.\n\nMfano wa matumizi:\nassert(decode_numbers(\"0000\") == 4);",
      "tr": "Decode bir dizi numarayı, deseni ortaya çıkarmak ve her bir rakamın temsil ettiği gerçek değerleri anlamak için çöz.\n\nReferans için sağlanan denklemler:\n0000=4 8888=8 1234=1 5678=3 9012=2 1357=0 2468=4\n\nParametreler:\n- data_str: Bir dizi numarayı temsil eden sabit bir karakter dizisi (C tarzı string). Uzunluk 100'ü geçmez.\n\nDöndürülenler:\nint: Her bir veri dizisinin denklemin sağ tarafına karşılık gelen sonucu.\n\nÖrnek kullanım:\nassert(decode_numbers(\"0000\") == 4);",
      "vi": "Giải mã một chuỗi số để tiết lộ mô hình và hiểu các giá trị thực mà mỗi chữ số đại diện.\n\nCác phương trình được cung cấp để tham khảo:\n0000=4 8888=8 1234=1 5678=3 9012=2 1357=0 2468=4\n\nTham số:\n- data_str: Một mảng ký tự hằng số (chuỗi kiểu C) đại diện cho một chuỗi số. Độ dài không vượt quá 100.\n\nTrả về:\nint: Kết quả của mỗi chuỗi dữ liệu tương ứng với phía bên phải của phương trình.\n\nVí dụ sử dụng:\nassert(decode_numbers(\"0000\") == 4);"
    },
    "docstring_bertscore": {
      "es": "0.9849132280388762",
      "arb": "0.9667899934428719",
      "sw": "0.965651841359542",
      "tr": "0.9706767927389626",
      "vi": "0.9662930202295226"
    }
  },
  {
    "task_id": "CPP/15",
    "prompt": {
      "en": "#include <cassert>\n#include <iostream>\n/**\n * Counts the number of different coloring methods for n squares with m colors,\n * considering the requirement that adjacent squares and the first/last squares\n * must have different colors.\n * \n * @param n The number of squares.\n * @param m The number of colors.\n * @return The count of different coloring methods satisfying the specified conditions.\n *         The result is modulo 1000003.\n *\n * Examples:\n * count_coloring_methods(1,1) returns 1\n * count_coloring_methods(2,2) returns 2\n */\nint count_coloring_methods(int n, int m)",
      "es": "#include <cassert>\n#include <iostream>\n/**\n * Cuenta el número de diferentes métodos de coloreado para n cuadrados con m colores,\n * considerando el requisito de que los cuadrados adyacentes y los primeros/últimos cuadrados\n * deben tener colores diferentes.\n * \n * @param n El número de cuadrados.\n * @param m El número de colores.\n * @return El conteo de diferentes métodos de coloreado que satisfacen las condiciones especificadas.\n *         El resultado es módulo 1000003.\n *\n * Ejemplos:\n * count_coloring_methods(1,1) returns 1\n * count_coloring_methods(2,2) returns 2\n */\nint count_coloring_methods(int n, int m)",
      "arb": "#include <cassert>\n#include <iostream>\n/**\n * يحسب عدد طرق التلوين المختلفة لـ n من المربعات باستخدام m من الألوان،\n * مع مراعاة الشرط بأن المربعات المتجاورة والمربعات الأولى/الأخيرة\n * يجب أن تكون بألوان مختلفة.\n * \n * @param n عدد المربعات.\n * @param m عدد الألوان.\n * @return عدد طرق التلوين المختلفة التي تلبي الشروط المحددة.\n *         النتيجة تكون مخرجة بنسبة 1000003.\n *\n * أمثلة:\n * count_coloring_methods(1,1) returns 1\n * count_coloring_methods(2,2) returns 2\n */\nint count_coloring_methods(int n, int m)",
      "sw": "#include <cassert>\n#include <iostream>\n/**\n * Inahesabu idadi ya mbinu tofauti za kupaka rangi miraba n kwa rangi m,\n * kwa kuzingatia hitaji kwamba miraba iliyo karibu na miraba ya kwanza/mwisho\n * lazima iwe na rangi tofauti.\n * \n * @param n Idadi ya miraba.\n * @param m Idadi ya rangi.\n * @return Idadi ya mbinu tofauti za kupaka rangi zinazokidhi masharti yaliyobainishwa.\n *         Matokeo ni modulo 1000003.\n *\n * Mifano:\n * count_coloring_methods(1,1) inarudisha 1\n * count_coloring_methods(2,2) inarudisha 2\n */\nint count_coloring_methods(int n, int m)",
      "tr": "#include <cassert>\n#include <iostream>\n/**\n * n kare için m renk ile farklı boyama yöntemlerinin sayısını sayar,\n * bitişik karelerin ve ilk/son karelerin farklı renklere sahip olması\n * gerektiği şartını göz önünde bulundurur.\n * \n * @param n Karelerin sayısı.\n * @param m Renklerin sayısı.\n * @return Belirtilen koşulları karşılayan farklı boyama yöntemlerinin sayısı.\n *         Sonuç 1000003 ile mod alınır.\n *\n * Örnekler:\n * count_coloring_methods(1,1) 1 döndürür\n * count_coloring_methods(2,2) 2 döndürür\n */\nint count_coloring_methods(int n, int m)",
      "vi": "#include <cassert>\n#include <iostream>\n/**\n * Đếm số lượng phương pháp tô màu khác nhau cho n ô vuông với m màu,\n * với điều kiện rằng các ô liền kề và ô đầu/cuối phải có màu khác nhau.\n * \n * @param n Số lượng ô vuông.\n * @param m Số lượng màu.\n * @return Số lượng phương pháp tô màu khác nhau thỏa mãn các điều kiện đã chỉ định.\n *         Kết quả được lấy modulo 1000003.\n *\n * Ví dụ:\n * count_coloring_methods(1,1) trả về 1\n * count_coloring_methods(2,2) trả về 2\n */\nint count_coloring_methods(int n, int m)"
    },
    "prompt_bertscore": {
      "es": "0.9952443914172627",
      "arb": "0.9587361273830503",
      "sw": "0.9617036652757115",
      "tr": "0.9775279518416179",
      "vi": "0.9709016423302941"
    },
    "canonical_solution": "{\n    int f[1111]; // Array to store results\n    if (n == 1) return m;\n    if (n == 2) return static_cast<long long>(m) * (m - 1) % 1000003;\n    // Initialize the first three elements\n    f[1] = m;\n    f[2] = static_cast<long long>(m) * (m - 1) % 1000003;\n    // Formula derived from the given gold.c code\n    f[3] = static_cast<long long>(f[2]) * (m - 2) % 1000003;\n    for(int i = 4; i <= n; ++i) {\n        f[i] = (static_cast<long long>(f[i - 1]) * (m - 2) % 1000003 +\n                static_cast<long long>(f[i - 2]) * (m - 1) % 1000003) % 1000003;\n    }\n    return f[n];\n}",
    "instruction": {
      "en": "int count_coloring_methods(int n, int m)\n{\n    int f[1111]; // Array to store results\n    if (n == 1) return m;\n    if (n == 2) return static_cast<long long>(m) * (m - 1) % 1000003;\n    // Initialize the first three elements\n    f[1] = m;\n    f[2] = static_cast<long long>(m) * (m - 1) % 1000003;\n    // Formula derived from the given gold.c code\n    f[3] = static_cast<long long>(f[2]) * (m - 2) % 1000003;\n    for(int i = 4; i <= n; ++i) {\n        f[i] = (static_cast<long long>(f[i - 1]) * (m - 2) % 1000003 +\n                static_cast<long long>(f[i - 2]) * (m - 1) % 1000003) % 1000003;\n    }\n    return f[n];\n}\n\nProvide a concise natural language description (docstring) of the CPP code in English using at most 500 characters.",
      "es": "int count_coloring_methods(int n, int m)\n{\n    int f[1111]; // Array to store results\n    if (n == 1) return m;\n    if (n == 2) return static_cast<long long>(m) * (m - 1) % 1000003;\n    // Initialize the first three elements\n    f[1] = m;\n    f[2] = static_cast<long long>(m) * (m - 1) % 1000003;\n    // Formula derived from the given gold.c code\n    f[3] = static_cast<long long>(f[2]) * (m - 2) % 1000003;\n    for(int i = 4; i <= n; ++i) {\n        f[i] = (static_cast<long long>(f[i - 1]) * (m - 2) % 1000003 +\n                static_cast<long long>(f[i - 2]) * (m - 1) % 1000003) % 1000003;\n    }\n    return f[n];\n}\n\nProporcione una descripción concisa en lenguaje natural (docstring) del código CPP en español utilizando como máximo 500 caracteres.",
      "arb": "int count_coloring_methods(int n, int m)\n{\n    int f[1111]; // Array to store results\n    if (n == 1) return m;\n    if (n == 2) return static_cast<long long>(m) * (m - 1) % 1000003;\n    // Initialize the first three elements\n    f[1] = m;\n    f[2] = static_cast<long long>(m) * (m - 1) % 1000003;\n    // Formula derived from the given gold.c code\n    f[3] = static_cast<long long>(f[2]) * (m - 2) % 1000003;\n    for(int i = 4; i <= n; ++i) {\n        f[i] = (static_cast<long long>(f[i - 1]) * (m - 2) % 1000003 +\n                static_cast<long long>(f[i - 2]) * (m - 1) % 1000003) % 1000003;\n    }\n    return f[n];\n}\n\nيرجى تقديم وصف موجز بلغة طبيعية (docstring) لشفرة CPP باللغة العربية الفصحى باستخدام ما لا يزيد عن 500 حرف.",
      "sw": "int count_coloring_methods(int n, int m)\n{\n    int f[1111]; // Array to store results\n    if (n == 1) return m;\n    if (n == 2) return static_cast<long long>(m) * (m - 1) % 1000003;\n    // Initialize the first three elements\n    f[1] = m;\n    f[2] = static_cast<long long>(m) * (m - 1) % 1000003;\n    // Formula derived from the given gold.c code\n    f[3] = static_cast<long long>(f[2]) * (m - 2) % 1000003;\n    for(int i = 4; i <= n; ++i) {\n        f[i] = (static_cast<long long>(f[i - 1]) * (m - 2) % 1000003 +\n                static_cast<long long>(f[i - 2]) * (m - 1) % 1000003) % 1000003;\n    }\n    return f[n];\n}\n\nToa maelezo mafupi ya lugha ya asili (docstring) ya msimbo wa CPP kwa Kiswahili kwa kutumia herufi zisizozidi 500.",
      "tr": "int count_coloring_methods(int n, int m)\n{\n    int f[1111]; // Array to store results\n    if (n == 1) return m;\n    if (n == 2) return static_cast<long long>(m) * (m - 1) % 1000003;\n    // Initialize the first three elements\n    f[1] = m;\n    f[2] = static_cast<long long>(m) * (m - 1) % 1000003;\n    // Formula derived from the given gold.c code\n    f[3] = static_cast<long long>(f[2]) * (m - 2) % 1000003;\n    for(int i = 4; i <= n; ++i) {\n        f[i] = (static_cast<long long>(f[i - 1]) * (m - 2) % 1000003 +\n                static_cast<long long>(f[i - 2]) * (m - 1) % 1000003) % 1000003;\n    }\n    return f[n];\n}\n\nAşağıdaki CPP kodunun Türkçe olarak en fazla 500 karakter kullanarak kısa bir doğal dil açıklamasını (docstring) sağlayın.",
      "vi": "int count_coloring_methods(int n, int m)\n{\n    int f[1111]; // Array to store results\n    if (n == 1) return m;\n    if (n == 2) return static_cast<long long>(m) * (m - 1) % 1000003;\n    // Initialize the first three elements\n    f[1] = m;\n    f[2] = static_cast<long long>(m) * (m - 1) % 1000003;\n    // Formula derived from the given gold.c code\n    f[3] = static_cast<long long>(f[2]) * (m - 2) % 1000003;\n    for(int i = 4; i <= n; ++i) {\n        f[i] = (static_cast<long long>(f[i - 1]) * (m - 2) % 1000003 +\n                static_cast<long long>(f[i - 2]) * (m - 1) % 1000003) % 1000003;\n    }\n    return f[n];\n}\n\nCung cấp mô tả ngắn gọn bằng ngôn ngữ tự nhiên (docstring) cho mã CPP bằng tiếng Việt với tối đa 500 ký tự."
    },
    "instruction_bertscore": {
      "es": "0.9695565173899258",
      "arb": "0.9190017087000691",
      "sw": "0.9176812139269492",
      "tr": "0.8874105397483754",
      "vi": "0.9171611995893999"
    },
    "level": "",
    "test": "int main() {\n    assert(count_coloring_methods(1, 1) == 1);\n    assert(count_coloring_methods(2, 2) == 2);\n    assert(count_coloring_methods(3, 3) == 6);\n    assert(count_coloring_methods(4, 2) == 2);\n    assert(count_coloring_methods(1000, 10) == 566585); // We don't have the expected result for this case\n\n    // Additional test cases\n    assert(count_coloring_methods(2, 3) == 6);\n    assert(count_coloring_methods(1000, 1000) == 67911);\n    assert(count_coloring_methods(999, 66) == 501817);\n    assert(count_coloring_methods(5, 3) == 30); // Example of an expected output\n\n    // std::cout << \"All tests passed!\\n\";\n    return 0;\n}",
    "entry_point": "count_coloring_methods",
    "signature": "int count_coloring_methods(int n, int m)",
    "docstring": {
      "en": "Counts the number of different coloring methods for n squares with m colors, considering the requirement that adjacent squares and the first/last squares must have different colors.\n\n@param n The number of squares.\n@param m The number of colors.\n@return The count of different coloring methods satisfying the specified conditions. The result is modulo 1000003.\n\nExamples:\ncount_coloring_methods(1,1) returns 1\ncount_coloring_methods(2,2) returns 2\n",
      "es": "Cuenta el número de diferentes métodos de coloreo para n cuadrados con m colores, considerando el requisito de que los cuadrados adyacentes y los primeros/últimos cuadrados deben tener colores diferentes.\n\n@param n El número de cuadrados.\n@param m El número de colores.\n@return El conteo de diferentes métodos de coloreo que satisfacen las condiciones especificadas. El resultado es módulo 1000003.\n\nEjemplos:\ncount_coloring_methods(1,1) devuelve 1\ncount_coloring_methods(2,2) devuelve 2",
      "arb": "يحسب عدد طرق التلوين المختلفة لـ n من المربعات باستخدام m من الألوان، مع مراعاة الشرط الذي يتطلب أن تكون المربعات المتجاورة والمربعات الأولى/الأخيرة بألوان مختلفة.\n\n@param n عدد المربعات.\n@param m عدد الألوان.\n@return عدد طرق التلوين المختلفة التي تفي بالشروط المحددة. النتيجة هي باقي القسمة على 1000003.\n\nأمثلة:\ncount_coloring_methods(1,1) returns 1\ncount_coloring_methods(2,2) returns 2",
      "sw": "Hesabu idadi ya mbinu tofauti za kupaka rangi kwa miraba n yenye rangi m, ukizingatia hitaji kwamba miraba iliyo karibu na miraba ya kwanza/ya mwisho lazima iwe na rangi tofauti.\n\n@param n Idadi ya miraba.\n@param m Idadi ya rangi.\n@return Hesabu ya mbinu tofauti za kupaka rangi zinazokidhi masharti yaliyotajwa. Matokeo ni modulo 1000003.\n\nMifano:\ncount_coloring_methods(1,1) inarudisha 1\ncount_coloring_methods(2,2) inarudisha 2",
      "tr": "Farklı renklendirme yöntemlerinin sayısını, n kare ve m renk ile, bitişik karelerin ve ilk/son karelerin farklı renklere sahip olması gerekliliğini göz önünde bulundurarak sayar.\n\n@param n Kare sayısı.\n@param m Renk sayısı.\n@return Belirtilen koşulları karşılayan farklı renklendirme yöntemlerinin sayısı. Sonuç 1000003 ile mod alınır.\n\nÖrnekler:\ncount_coloring_methods(1,1) 1 döndürür\ncount_coloring_methods(2,2) 2 döndürür",
      "vi": "Đếm số lượng phương pháp tô màu khác nhau cho n ô vuông với m màu, xem xét yêu cầu rằng các ô vuông liền kề và ô đầu/ô cuối phải có màu khác nhau.\n\n@param n Số lượng ô vuông.\n@param m Số lượng màu sắc.\n@return Số lượng phương pháp tô màu khác nhau thỏa mãn các điều kiện đã chỉ định. Kết quả được lấy theo modulo 1000003.\n\nVí dụ:\ncount_coloring_methods(1,1) trả về 1\ncount_coloring_methods(2,2) trả về 2"
    },
    "docstring_bertscore": {
      "es": "0.9913724893997496",
      "arb": "0.9291761527078193",
      "sw": "0.954452663216033",
      "tr": "0.9641936957323648",
      "vi": "0.9632847631087492"
    }
  },
  {
    "task_id": "CPP/16",
    "prompt": {
      "en": "#include <cassert>\n#include <cmath>\n#include <cstdio>\n#include <cstring>\n/**\n * Count the number of valid coin toss sequences with no consecutive heads in n tosses.\n *\n * Parameters:\n * - n (int): The number of coin tosses.\n *\n * Returns:\n * - unsigned long long: The count of valid sequences.\n *\n * Examples:\n *   count_valid_coin_toss_sequences(1) returns 2\n *   count_valid_coin_toss_sequences(2) returns 3\n */\nunsigned long long count_valid_coin_toss_sequences(int n)",
      "es": "#include <cassert>\n#include <cmath>\n#include <cstdio>\n#include <cstring>\n/**\n * Cuenta el número de secuencias válidas de lanzamientos de moneda sin caras consecutivas en n lanzamientos.\n *\n * Parámetros:\n * - n (int): El número de lanzamientos de moneda.\n *\n * Devuelve:\n * - unsigned long long: El conteo de secuencias válidas.\n *\n * Ejemplos:\n *   count_valid_coin_toss_sequences(1) returns 2\n *   count_valid_coin_toss_sequences(2) returns 3\n */\nunsigned long long count_valid_coin_toss_sequences(int n)",
      "arb": "#include <cassert>\n#include <cmath>\n#include <cstdio>\n#include <cstring>\n/**\n * احسب عدد تسلسلات رمي العملة الصحيحة بدون رؤوس متتالية في n رميات.\n *\n * المعلمات:\n * - n (int): عدد رميات العملة.\n *\n * يعيد:\n * - unsigned long long: عدد التسلسلات الصحيحة.\n *\n * أمثلة:\n *   count_valid_coin_toss_sequences(1) returns 2\n *   count_valid_coin_toss_sequences(2) returns 3\n */\nunsigned long long count_valid_coin_toss_sequences(int n)",
      "sw": "#include <cassert>\n#include <cmath>\n#include <cstdio>\n#include <cstring>\n/**\n * Hesabu idadi ya mlolongo sahihi wa kurusha sarafu bila vichwa mfululizo katika kurusha mara n.\n *\n * Vigezo:\n * - n (int): Idadi ya kurusha sarafu.\n *\n * Inarudisha:\n * - unsigned long long: Hesabu ya milolongo sahihi.\n *\n * Mifano:\n *   count_valid_coin_toss_sequences(1) inarudisha 2\n *   count_valid_coin_toss_sequences(2) inarudisha 3\n */\nunsigned long long count_valid_coin_toss_sequences(int n)",
      "tr": "#include <cassert>\n#include <cmath>\n#include <cstdio>\n#include <cstring>\n/**\n * Ardışık yazı gelmeyen geçerli para atışı dizilerinin sayısını n atışta sayar.\n *\n * Parametreler:\n * - n (int): Para atışlarının sayısı.\n *\n * Döndürür:\n * - unsigned long long: Geçerli dizilerin sayısı.\n *\n * Örnekler:\n *   count_valid_coin_toss_sequences(1) 2 döndürür\n *   count_valid_coin_toss_sequences(2) 3 döndürür\n */\nunsigned long long count_valid_coin_toss_sequences(int n)",
      "vi": "#include <cassert>\n#include <cmath>\n#include <cstdio>\n#include <cstring>\n/**\n * Đếm số lượng dãy tung đồng xu hợp lệ mà không có hai mặt ngửa liên tiếp trong n lần tung.\n *\n * Tham số:\n * - n (int): Số lần tung đồng xu.\n *\n * Trả về:\n * - unsigned long long: Số lượng dãy hợp lệ.\n *\n * Ví dụ:\n *   count_valid_coin_toss_sequences(1) trả về 2\n *   count_valid_coin_toss_sequences(2) trả về 3\n */\nunsigned long long count_valid_coin_toss_sequences(int n)"
    },
    "prompt_bertscore": {
      "es": "0.9884957255912213",
      "arb": "0.9832020273062605",
      "sw": "0.9854439684170013",
      "tr": "0.9872423678868912",
      "vi": "0.9858362634195452"
    },
    "canonical_solution": "{\n    unsigned long long a[41][2];\n    a[1][0] = a[1][1] = 1;\n\n    for(int i = 2; i <= n; i++){\n        a[i][0] = a[i - 1][1] + a[i - 1][0];\n        a[i][1] = a[i - 1][0];\n    }\n\n    return a[n][0] + a[n][1];\n}",
    "instruction": {
      "en": "unsigned long long count_valid_coin_toss_sequences(int n)\n{\n    unsigned long long a[41][2];\n    a[1][0] = a[1][1] = 1;\n\n    for(int i = 2; i <= n; i++){\n        a[i][0] = a[i - 1][1] + a[i - 1][0];\n        a[i][1] = a[i - 1][0];\n    }\n\n    return a[n][0] + a[n][1];\n}\n\nProvide a concise natural language description (docstring) of the CPP code in English using at most 500 characters.",
      "es": "unsigned long long count_valid_coin_toss_sequences(int n)\n{\n    unsigned long long a[41][2];\n    a[1][0] = a[1][1] = 1;\n\n    for(int i = 2; i <= n; i++){\n        a[i][0] = a[i - 1][1] + a[i - 1][0];\n        a[i][1] = a[i - 1][0];\n    }\n\n    return a[n][0] + a[n][1];\n}\n\nProporcione una descripción concisa en lenguaje natural (docstring) del código CPP en español utilizando como máximo 500 caracteres.",
      "arb": "unsigned long long count_valid_coin_toss_sequences(int n)\n{\n    unsigned long long a[41][2];\n    a[1][0] = a[1][1] = 1;\n\n    for(int i = 2; i <= n; i++){\n        a[i][0] = a[i - 1][1] + a[i - 1][0];\n        a[i][1] = a[i - 1][0];\n    }\n\n    return a[n][0] + a[n][1];\n}\n\nيرجى تقديم وصف موجز بلغة طبيعية (docstring) للشفرة البرمجية بلغة C++ باللغة العربية الفصحى، بحيث لا يتجاوز 500 حرف.",
      "sw": "unsigned long long count_valid_coin_toss_sequences(int n)\n{\n    unsigned long long a[41][2];\n    a[1][0] = a[1][1] = 1;\n\n    for(int i = 2; i <= n; i++){\n        a[i][0] = a[i - 1][1] + a[i - 1][0];\n        a[i][1] = a[i - 1][0];\n    }\n\n    return a[n][0] + a[n][1];\n}\n\nToa maelezo mafupi ya lugha ya asili (docstring) ya msimbo wa CPP kwa Kiswahili kwa kutumia herufi zisizozidi 500.",
      "tr": "unsigned long long count_valid_coin_toss_sequences(int n)\n{\n    unsigned long long a[41][2];\n    a[1][0] = a[1][1] = 1;\n\n    for(int i = 2; i <= n; i++){\n        a[i][0] = a[i - 1][1] + a[i - 1][0];\n        a[i][1] = a[i - 1][0];\n    }\n\n    return a[n][0] + a[n][1];\n}\n\nAşağıdaki CPP kodunun Türkçe'de en fazla 500 karakter kullanarak kısa bir doğal dil açıklamasını (docstring) sağlayın.",
      "vi": "unsigned long long count_valid_coin_toss_sequences(int n)\n{\n    unsigned long long a[41][2];\n    a[1][0] = a[1][1] = 1;\n\n    for(int i = 2; i <= n; i++){\n        a[i][0] = a[i - 1][1] + a[i - 1][0];\n        a[i][1] = a[i - 1][0];\n    }\n\n    return a[n][0] + a[n][1];\n}\n\nCung cấp mô tả ngắn gọn bằng ngôn ngữ tự nhiên (docstring) cho mã CPP bằng tiếng Việt với tối đa 500 ký tự."
    },
    "instruction_bertscore": {
      "es": "0.9695565173899258",
      "arb": "0.8654990265252738",
      "sw": "0.9176812139269492",
      "tr": "0.8766952252130673",
      "vi": "0.9171611995893999"
    },
    "level": "",
    "test": "int main() {\n    assert(count_valid_coin_toss_sequences(1) == 2);\n    assert(count_valid_coin_toss_sequences(2) == 3);\n    assert(count_valid_coin_toss_sequences(3) == 5);\n    assert(count_valid_coin_toss_sequences(4) == 8); // Additional test\n    assert(count_valid_coin_toss_sequences(5) == 13); // Additional test\n    // Feel free to add more tests here\n    assert(count_valid_coin_toss_sequences(40) == 267914296ULL); // Additional test\n    assert(count_valid_coin_toss_sequences(39) == 165580141ULL);\n    assert(count_valid_coin_toss_sequences(38) == 102334155ULL);\n    // printf(\"All tests passed!\\n\");\n    return 0;\n}",
    "entry_point": "count_valid_coin_toss_sequences",
    "signature": "unsigned long long count_valid_coin_toss_sequences(int n)",
    "docstring": {
      "en": "Count the number of valid coin toss sequences with no consecutive heads in n tosses.\n\nParameters:\n- n (int): The number of coin tosses.\n\nReturns:\n- unsigned long long: The count of valid sequences.\n\nExamples:\n  count_valid_coin_toss_sequences(1) returns 2\n  count_valid_coin_toss_sequences(2) returns 3\n",
      "es": "Cuenta el número de secuencias válidas de lanzamientos de moneda sin caras consecutivas en n lanzamientos.\n\nParámetros:\n- n (int): El número de lanzamientos de moneda.\n\nDevuelve:\n- unsigned long long: La cuenta de secuencias válidas.\n\nEjemplos:\n  count_valid_coin_toss_sequences(1) devuelve 2\n  count_valid_coin_toss_sequences(2) devuelve 3",
      "arb": "احسب عدد تسلسلات رمي العملة الصحيحة بدون رؤوس متتالية في n من الرميات.\n\nالمعلمات:\n- n (int): عدد رميات العملة.\n\nالقيم المعادة:\n- unsigned long long: عدد التسلسلات الصحيحة.\n\nأمثلة:\n  count_valid_coin_toss_sequences(1) returns 2\n  count_valid_coin_toss_sequences(2) returns 3",
      "sw": "Hesabu idadi ya mfuatano halali wa kurusha sarafu bila vichwa vinavyofuatana katika kurusha sarafu n.\n\nVigezo:\n- n (int): Idadi ya kurusha sarafu.\n\nInarejesha:\n- unsigned long long: Idadi ya mfuatano halali.\n\nMifano:\n  count_valid_coin_toss_sequences(1) inarejesha 2\n  count_valid_coin_toss_sequences(2) inarejesha 3",
      "tr": "n atışında ardışık yazı gelmeyen geçerli madeni para atış dizilerinin sayısını sayın.\n\nParametreler:\n- n (int): Madeni para atışlarının sayısı.\n\nDöndürür:\n- unsigned long long: Geçerli dizilerin sayısı.\n\nÖrnekler:\n  count_valid_coin_toss_sequences(1) 2 döndürür\n  count_valid_coin_toss_sequences(2) 3 döndürür",
      "vi": "Đếm số lượng dãy tung đồng xu hợp lệ mà không có hai mặt ngửa liên tiếp trong n lần tung.\n\nTham số:\n- n (int): Số lần tung đồng xu.\n\nTrả về:\n- unsigned long long: Số lượng dãy hợp lệ.\n\nVí dụ:\n  count_valid_coin_toss_sequences(1) trả về 2\n  count_valid_coin_toss_sequences(2) trả về 3"
    },
    "docstring_bertscore": {
      "es": "0.9895401241347028",
      "arb": "0.9744513658697685",
      "sw": "0.9764187997939191",
      "tr": "0.9651067995939823",
      "vi": "0.9785850627294856"
    }
  },
  {
    "task_id": "CPP/17",
    "prompt": {
      "en": "#include <cassert>\n#include <cmath>\n#include <cstdio>\n#include <cstring>\n/**\n * Find the length of the longest consecutive sequence of 1s in the binary \n * representation of a non-negative integer.\n *\n * Parameters:\n * - n (unsigned long long): A non-negative integer (0 ≤ n ≤ 2^64 - 1).\n *\n * Returns:\n * - int: The length of the longest consecutive sequence of 1s in the binary \n *        representation of the given integer.\n *\n * Examples:\n *   >>> find_longest_consecutive_ones_length(7)\n *   3\n */\nint find_longest_consecutive_ones_length(unsigned long long n)",
      "es": "#include <cassert>\n#include <cmath>\n#include <cstdio>\n#include <cstring>\n/**\n * Encuentra la longitud de la secuencia consecutiva más larga de 1s en la \n * representación binaria de un entero no negativo.\n *\n * Parámetros:\n * - n (unsigned long long): Un entero no negativo (0 ≤ n ≤ 2^64 - 1).\n *\n * Retorna:\n * - int: La longitud de la secuencia consecutiva más larga de 1s en la \n *        representación binaria del entero dado.\n *\n * Ejemplos:\n *   >>> find_longest_consecutive_ones_length(7)\n *   3\n */\nint find_longest_consecutive_ones_length(unsigned long long n)",
      "arb": "#include <cassert>\n#include <cmath>\n#include <cstdio>\n#include <cstring>\n/**\n * إيجاد طول أطول تسلسل متتابع من الأرقام 1 في التمثيل الثنائي لعدد صحيح غير سالب.\n *\n * المعاملات:\n * - n (unsigned long long): عدد صحيح غير سالب (0 ≤ n ≤ 2^64 - 1).\n *\n * يعيد:\n * - int: طول أطول تسلسل متتابع من الأرقام 1 في التمثيل الثنائي للعدد المعطى.\n *\n * أمثلة:\n *   >>> find_longest_consecutive_ones_length(7)\n *   3\n */\nint find_longest_consecutive_ones_length(unsigned long long n)",
      "sw": "#include <cassert>\n#include <cmath>\n#include <cstdio>\n#include <cstring>\n/**\n * Tafuta urefu wa mfululizo mrefu zaidi wa 1s katika uwakilishi wa \n * nambari ya binary ya nambari isiyo na alama.\n *\n * Vigezo:\n * - n (unsigned long long): Nambari isiyo na alama (0 ≤ n ≤ 2^64 - 1).\n *\n * Inarudisha:\n * - int: Urefu wa mfululizo mrefu zaidi wa 1s katika uwakilishi wa \n *        nambari ya binary ya nambari iliyotolewa.\n *\n * Mifano:\n *   >>> find_longest_consecutive_ones_length(7)\n *   3\n */\nint find_longest_consecutive_ones_length(unsigned long long n)",
      "tr": "#include <cassert>\n#include <cmath>\n#include <cstdio>\n#include <cstring>\n/**\n * Bir negatif olmayan tamsayının ikili gösterimindeki en uzun ardışık 1 \n * dizisinin uzunluğunu bulun.\n *\n * Parametreler:\n * - n (unsigned long long): Negatif olmayan bir tamsayı (0 ≤ n ≤ 2^64 - 1).\n *\n * Döndürür:\n * - int: Verilen tamsayının ikili gösterimindeki en uzun ardışık 1 dizisinin \n *        uzunluğu.\n *\n * Örnekler:\n *   >>> find_longest_consecutive_ones_length(7)\n *   3\n */\nint find_longest_consecutive_ones_length(unsigned long long n)",
      "vi": "#include <cassert>\n#include <cmath>\n#include <cstdio>\n#include <cstring>\n/**\n * Tìm độ dài của dãy liên tiếp dài nhất của các số 1 trong biểu diễn nhị phân \n * của một số nguyên không âm.\n *\n * Tham số:\n * - n (unsigned long long): Một số nguyên không âm (0 ≤ n ≤ 2^64 - 1).\n *\n * Trả về:\n * - int: Độ dài của dãy liên tiếp dài nhất của các số 1 trong biểu diễn nhị phân \n *        của số nguyên đã cho.\n *\n * Ví dụ:\n *   >>> find_longest_consecutive_ones_length(7)\n *   3\n */\nint find_longest_consecutive_ones_length(unsigned long long n)"
    },
    "prompt_bertscore": {
      "es": "0.9915369553552466",
      "arb": "0.9866862028199935",
      "sw": "0.9530030586952403",
      "tr": "1",
      "vi": "0.9984842515623228"
    },
    "canonical_solution": "{\n    int max_length = 0;\n    int current_length = 0;\n    while (n) {\n        if (n & 1) {\n            current_length++;\n        } else {\n            if (current_length > max_length) {\n                max_length = current_length;\n            }\n            current_length = 0;\n        }\n        n >>= 1;\n    }\n    if (current_length > max_length) {\n        max_length = current_length;\n    }\n    return max_length;\n}",
    "instruction": {
      "en": "int find_longest_consecutive_ones_length(unsigned long long n)\n{\n    int max_length = 0;\n    int current_length = 0;\n    while (n) {\n        if (n & 1) {\n            current_length++;\n        } else {\n            if (current_length > max_length) {\n                max_length = current_length;\n            }\n            current_length = 0;\n        }\n        n >>= 1;\n    }\n    if (current_length > max_length) {\n        max_length = current_length;\n    }\n    return max_length;\n}\n\nProvide a concise natural language description (docstring) of the CPP code in English using at most 500 characters.",
      "es": "int find_longest_consecutive_ones_length(unsigned long long n)\n{\n    int max_length = 0;\n    int current_length = 0;\n    while (n) {\n        if (n & 1) {\n            current_length++;\n        } else {\n            if (current_length > max_length) {\n                max_length = current_length;\n            }\n            current_length = 0;\n        }\n        n >>= 1;\n    }\n    if (current_length > max_length) {\n        max_length = current_length;\n    }\n    return max_length;\n}\n\nProporcione una descripción concisa en lenguaje natural (docstring) del código CPP en español utilizando como máximo 500 caracteres.",
      "arb": "int find_longest_consecutive_ones_length(unsigned long long n)\n{\n    int max_length = 0;\n    int current_length = 0;\n    while (n) {\n        if (n & 1) {\n            current_length++;\n        } else {\n            if (current_length > max_length) {\n                max_length = current_length;\n            }\n            current_length = 0;\n        }\n        n >>= 1;\n    }\n    if (current_length > max_length) {\n        max_length = current_length;\n    }\n    return max_length;\n}\n\nيرجى تقديم وصف موجز بلغة طبيعية (docstring) لشفرة CPP باللغة العربية الفصحى، بحيث لا يتجاوز 500 حرف.",
      "sw": "int find_longest_consecutive_ones_length(unsigned long long n)\n{\n    int max_length = 0;\n    int current_length = 0;\n    while (n) {\n        if (n & 1) {\n            current_length++;\n        } else {\n            if (current_length > max_length) {\n                max_length = current_length;\n            }\n            current_length = 0;\n        }\n        n >>= 1;\n    }\n    if (current_length > max_length) {\n        max_length = current_length;\n    }\n    return max_length;\n}\n\nToa maelezo mafupi ya lugha asilia (docstring) ya msimbo wa CPP kwa Kiswahili kwa kutumia herufi zisizozidi 500.",
      "tr": "int find_longest_consecutive_ones_length(unsigned long long n)\n{\n    int max_length = 0;\n    int current_length = 0;\n    while (n) {\n        if (n & 1) {\n            current_length++;\n        } else {\n            if (current_length > max_length) {\n                max_length = current_length;\n            }\n            current_length = 0;\n        }\n        n >>= 1;\n    }\n    if (current_length > max_length) {\n        max_length = current_length;\n    }\n    return max_length;\n}\n\nAşağıdaki CPP kodunun Türkçe olarak en fazla 500 karakter kullanarak kısa bir doğal dil açıklamasını (docstring) sağlayın.",
      "vi": "int find_longest_consecutive_ones_length(unsigned long long n)\n{\n    int max_length = 0;\n    int current_length = 0;\n    while (n) {\n        if (n & 1) {\n            current_length++;\n        } else {\n            if (current_length > max_length) {\n                max_length = current_length;\n            }\n            current_length = 0;\n        }\n        n >>= 1;\n    }\n    if (current_length > max_length) {\n        max_length = current_length;\n    }\n    return max_length;\n}\n\nCung cấp mô tả ngắn gọn bằng ngôn ngữ tự nhiên (docstring) cho mã CPP bằng tiếng Việt với tối đa 500 ký tự."
    },
    "instruction_bertscore": {
      "es": "0.9695565173899258",
      "arb": "0.8802665994640746",
      "sw": "0.9449839529520998",
      "tr": "0.8890214321385683",
      "vi": "0.9171611995893999"
    },
    "level": "",
    "test": "int main()\n{\n    assert(find_longest_consecutive_ones_length(7) == 3);\n    assert(find_longest_consecutive_ones_length(13) == 2);\n    assert(find_longest_consecutive_ones_length(12345) == 3); // New test sample\n    assert(find_longest_consecutive_ones_length(0b11011101111) == 4); // New test sample using binary literal for clarity\n    assert(find_longest_consecutive_ones_length(0xFFFFFFFF) == 32); // New test sample: all ones for a 32-bit number\n    assert(find_longest_consecutive_ones_length(0) == 0); // New test sample: no ones in a zero\n\n    // printf(\"All tests passed!\\n\"); // In C++, you might use std::cout, but it is commented out as per the original code.\n    return 0;\n}",
    "entry_point": "find_longest_consecutive_ones_length",
    "signature": "int find_longest_consecutive_ones_length(unsigned long long n)",
    "docstring": {
      "en": "Find the length of the longest consecutive sequence of 1s in the binary representation of a non-negative integer.\n\nParameters:\n- n (unsigned long long): A non-negative integer (0 ≤ n ≤ 2^64 - 1).\n\nReturns:\n- int: The length of the longest consecutive sequence of 1s in the binary representation of the given integer.\n\nExamples:\n  >>> find_longest_consecutive_ones_length(7)\n  3\n",
      "es": "Encuentra la longitud de la secuencia consecutiva más larga de 1s en la representación binaria de un número entero no negativo.\n\nParámetros:\n- n (unsigned long long): Un número entero no negativo (0 ≤ n ≤ 2^64 - 1).\n\nDevuelve:\n- int: La longitud de la secuencia consecutiva más larga de 1s en la representación binaria del número entero dado.\n\nEjemplos:\n  >>> find_longest_consecutive_ones_length(7)\n  3",
      "arb": "إيجاد طول أطول تسلسل متتالي من الأرقام 1 في التمثيل الثنائي لعدد صحيح غير سالب.\n\nالمعلمات:\n- n (unsigned long long): عدد صحيح غير سالب (0 ≤ n ≤ 2^64 - 1).\n\nالقيم المعادة:\n- int: طول أطول تسلسل متتالي من الأرقام 1 في التمثيل الثنائي للعدد المعطى.\n\nأمثلة:\n  >>> find_longest_consecutive_ones_length(7)\n  3",
      "sw": "Tafuta urefu wa mlolongo mrefu zaidi wa 1 mfululizo katika uwakilishi wa binary wa nambari isiyo hasi.\n\nVigezo:\n- n (unsigned long long): Nambari isiyo hasi (0 ≤ n ≤ 2^64 - 1).\n\nInarejesha:\n- int: Urefu wa mlolongo mrefu zaidi wa 1 mfululizo katika uwakilishi wa binary wa nambari iliyotolewa.\n\nMifano:\n  >>> find_longest_consecutive_ones_length(7)\n  3",
      "tr": "Bir negatif olmayan tamsayının ikili gösterimindeki en uzun ardışık 1 dizisinin uzunluğunu bulun.\n\nParametreler:\n- n (unsigned long long): Negatif olmayan bir tam sayı (0 ≤ n ≤ 2^64 - 1).\n\nDöndürülenler:\n- int: Verilen tam sayının ikili gösterimindeki en uzun ardışık 1 dizisinin uzunluğu.\n\nÖrnekler:\n  >>> find_longest_consecutive_ones_length(7)\n  3",
      "vi": "Tìm độ dài của dãy liên tiếp dài nhất của các số 1 trong biểu diễn nhị phân của một số nguyên không âm.\n\nTham số:\n- n (unsigned long long): Một số nguyên không âm (0 ≤ n ≤ 2^64 - 1).\n\nTrả về:\n- int: Độ dài của dãy liên tiếp dài nhất của các số 1 trong biểu diễn nhị phân của số nguyên đã cho.\n\nVí dụ:\n  >>> find_longest_consecutive_ones_length(7)\n  3"
    },
    "docstring_bertscore": {
      "es": "1",
      "arb": "0.9578488454709674",
      "sw": "0.9677793713708066",
      "tr": "1",
      "vi": "0.9978675042292094"
    }
  },
  {
    "task_id": "CPP/18",
    "prompt": {
      "en": "#include <iostream>\n#include <string>\n#include <cassert>\n/**\n * Generates a unique identifier by interweaving two words in a specified pattern.\n * @param word1 The first word to be used in the ID creation process.\n * @param word2 The second word to be used in the ID creation process.\n * @return A unique identifier formed by alternating characters from the second word,\n *         reversed, with characters from the first word.\n * Example Usage:\n * \n * create_id(\"fish\", \"cat\") returns \"ftiasch\"\n * create_id(\"icpc\", \"acm\") returns \"imccpac\"\n * \n */\nstd::string create_id(const std::string& word1, const std::string& word2)",
      "es": "#include <iostream>\n#include <string>\n#include <cassert>\n/**\n * Genera un identificador único entrelazando dos palabras en un patrón especificado.\n * @param word1 La primera palabra que se utilizará en el proceso de creación del ID.\n * @param word2 La segunda palabra que se utilizará en el proceso de creación del ID.\n * @return Un identificador único formado alternando caracteres de la segunda palabra,\n *         invertida, con caracteres de la primera palabra.\n * Ejemplo de uso:\n * \n * create_id(\"fish\", \"cat\") returns \"ftiasch\"\n * create_id(\"icpc\", \"acm\") returns \"imccpac\"\n * \n */\nstd::string create_id(const std::string& word1, const std::string& word2)",
      "arb": "#include <iostream>\n#include <string>\n#include <cassert>\n/**\n * ينشئ معرفًا فريدًا عن طريق تشابك كلمتين بنمط محدد.\n * @param word1 الكلمة الأولى التي سيتم استخدامها في عملية إنشاء المعرف.\n * @param word2 الكلمة الثانية التي سيتم استخدامها في عملية إنشاء المعرف.\n * @return معرف فريد يتكون من تبديل الأحرف من الكلمة الثانية،\n *         معكوسة، مع الأحرف من الكلمة الأولى.\n * مثال على الاستخدام:\n * \n * create_id(\"fish\", \"cat\") returns \"ftiasch\"\n * create_id(\"icpc\", \"acm\") returns \"imccpac\"\n * \n */\nstd::string create_id(const std::string& word1, const std::string& word2)",
      "sw": "#include <iostream>\n#include <string>\n#include <cassert>\n/**\n * Hutengeneza kitambulisho cha kipekee kwa kuchanganya maneno mawili kwa mtindo maalum.\n * @param word1 Neno la kwanza litakalotumika katika mchakato wa kuunda kitambulisho.\n * @param word2 Neno la pili litakalotumika katika mchakato wa kuunda kitambulisho.\n * @return Kitambulisho cha kipekee kinachoundwa kwa kubadilisha herufi kutoka neno la pili,\n *         lililogeuzwa, na herufi kutoka neno la kwanza.\n * Mfano wa Matumizi:\n * \n * create_id(\"fish\", \"cat\") returns \"ftiasch\"\n * create_id(\"icpc\", \"acm\") returns \"imccpac\"\n * \n */\nstd::string create_id(const std::string& word1, const std::string& word2)",
      "tr": "#include <iostream>\n#include <string>\n#include <cassert>\n/**\n * Belirli bir desende iki kelimeyi iç içe geçirerek benzersiz bir kimlik oluşturur.\n * @param word1 Kimlik oluşturma sürecinde kullanılacak ilk kelime.\n * @param word2 Kimlik oluşturma sürecinde kullanılacak ikinci kelime.\n * @return İkinci kelimenin karakterlerinin ters çevrilmiş haliyle, \n *         birinci kelimenin karakterlerinin dönüşümlü olarak kullanılmasıyla oluşturulan benzersiz bir kimlik.\n * Örnek Kullanım:\n * \n * create_id(\"fish\", \"cat\") returns \"ftiasch\"\n * create_id(\"icpc\", \"acm\") returns \"imccpac\"\n * \n */\nstd::string create_id(const std::string& word1, const std::string& word2)",
      "vi": "#include <iostream>\n#include <string>\n#include <cassert>\n/**\n * Tạo một định danh duy nhất bằng cách xen kẽ hai từ theo một mẫu được chỉ định.\n * @param word1 Từ đầu tiên được sử dụng trong quá trình tạo ID.\n * @param word2 Từ thứ hai được sử dụng trong quá trình tạo ID.\n * @return Một định danh duy nhất được tạo bằng cách xen kẽ các ký tự từ từ thứ hai,\n *         đảo ngược, với các ký tự từ từ đầu tiên.\n * Ví dụ Sử dụng:\n * \n * create_id(\"fish\", \"cat\") trả về \"ftiasch\"\n * create_id(\"icpc\", \"acm\") trả về \"imccpac\"\n * \n */\nstd::string create_id(const std::string& word1, const std::string& word2)"
    },
    "prompt_bertscore": {
      "es": "0.9909784067237765",
      "arb": "0.9645313673801241",
      "sw": "0.9629494750255623",
      "tr": "0.9622977687453869",
      "vi": "0.9654748616900398"
    },
    "canonical_solution": "{\n    std::string id;\n    int j = 0, k = word2.length() - 1;\n    for (int i = 0; i < word1.length() + word2.length(); ++i) {\n        if (i % 2 == 0) {\n            id += word1[j++]; // Take character from word1\n        } else {\n            id += word2[k--]; // Take character from word2 in reverse\n        }\n    }\n    return id;\n}",
    "instruction": {
      "en": "std::string create_id(const std::string& word1, const std::string& word2)\n{\n    std::string id;\n    int j = 0, k = word2.length() - 1;\n    for (int i = 0; i < word1.length() + word2.length(); ++i) {\n        if (i % 2 == 0) {\n            id += word1[j++]; // Take character from word1\n        } else {\n            id += word2[k--]; // Take character from word2 in reverse\n        }\n    }\n    return id;\n}\n\nProvide a concise natural language description (docstring) of the CPP code in English using at most 500 characters.",
      "es": "std::string create_id(const std::string& word1, const std::string& word2)\n{\n    std::string id;\n    int j = 0, k = word2.length() - 1;\n    for (int i = 0; i < word1.length() + word2.length(); ++i) {\n        if (i % 2 == 0) {\n            id += word1[j++]; // Take character from word1\n        } else {\n            id += word2[k--]; // Take character from word2 in reverse\n        }\n    }\n    return id;\n}\n\nProporcione una descripción concisa en lenguaje natural (docstring) del código CPP en español utilizando como máximo 500 caracteres.",
      "arb": "std::string create_id(const std::string& word1, const std::string& word2)\n{\n    std::string id;\n    int j = 0, k = word2.length() - 1;\n    for (int i = 0; i < word1.length() + word2.length(); ++i) {\n        if (i % 2 == 0) {\n            id += word1[j++]; // Take character from word1\n        } else {\n            id += word2[k--]; // Take character from word2 in reverse\n        }\n    }\n    return id;\n}\n\nيرجى تقديم وصف موجز بلغة طبيعية (docstring) للكود المكتوب بلغة C++ باللغة العربية الفصحى، بحيث لا يتجاوز 500 حرف.",
      "sw": "std::string create_id(const std::string& word1, const std::string& word2)\n{\n    std::string id;\n    int j = 0, k = word2.length() - 1;\n    for (int i = 0; i < word1.length() + word2.length(); ++i) {\n        if (i % 2 == 0) {\n            id += word1[j++]; // Take character from word1\n        } else {\n            id += word2[k--]; // Take character from word2 in reverse\n        }\n    }\n    return id;\n}\n\nToa maelezo mafupi ya lugha ya asili (docstring) ya msimbo wa CPP kwa Kiswahili kwa kutumia herufi zisizozidi 500.",
      "tr": "std::string create_id(const std::string& word1, const std::string& word2)\n{\n    std::string id;\n    int j = 0, k = word2.length() - 1;\n    for (int i = 0; i < word1.length() + word2.length(); ++i) {\n        if (i % 2 == 0) {\n            id += word1[j++]; // Take character from word1\n        } else {\n            id += word2[k--]; // Take character from word2 in reverse\n        }\n    }\n    return id;\n}\n\nAşağıdaki CPP kodunun işlevini açıklayan, en fazla 500 karakter uzunluğunda özlü bir doğal dil açıklaması (docstring) sağlayın.",
      "vi": "std::string create_id(const std::string& word1, const std::string& word2)\n{\n    std::string id;\n    int j = 0, k = word2.length() - 1;\n    for (int i = 0; i < word1.length() + word2.length(); ++i) {\n        if (i % 2 == 0) {\n            id += word1[j++]; // Take character from word1\n        } else {\n            id += word2[k--]; // Take character from word2 in reverse\n        }\n    }\n    return id;\n}\n\nCung cấp mô tả ngắn gọn bằng ngôn ngữ tự nhiên (docstring) cho mã CPP bằng tiếng Việt với tối đa 500 ký tự."
    },
    "instruction_bertscore": {
      "es": "0.9695565173899258",
      "arb": "0.8291343722565495",
      "sw": "0.9176812139269492",
      "tr": "0.8500634596150526",
      "vi": "0.9171611995893999"
    },
    "level": "",
    "test": "int main() {\n    std::string id; // To hold the results from create_id\n\n    id = create_id(\"fish\", \"cat\");\n    assert(id.compare(\"ftiasch\") == 0);\n\n    id = create_id(\"icpc\", \"acm\");\n    assert(id.compare(\"imccpac\") == 0);\n\n    id = create_id(\"oo\", \"w\");\n    assert(id.compare(\"owo\") == 0);\n\n    // Add more test samples\n    id = create_id(\"hello\", \"world\");\n    assert(id.compare(\"hdellrloow\") == 0);\n\n    id = create_id(\"abc\", \"def\");\n    assert(id.compare(\"afbecd\") == 0);\n\n    id = create_id(\"buaanb\", \"nbbuaa\");\n    assert(id.compare(\"bauaauabnbbn\") == 0);\n\n    id = create_id(\"xtuisgood\", \"ilovextu\");\n    assert(id.compare(\"xuttuxiesvgooloid\") == 0);\n\n    // std::cout << \"All tests passed!\" << std::endl;\n\n    return 0;\n}",
    "entry_point": "create_id",
    "signature": "std::string create_id(const std::string& word1, const std::string& word2)",
    "docstring": {
      "en": "Generates a unique identifier by interweaving two words in a specified pattern.\n@param word1 The first word to be used in the ID creation process.\n@param word2 The second word to be used in the ID creation process.\n@return A unique identifier formed by alternating characters from the second word, reversed, with characters from the first word.\nExample Usage:\n\ncreate_id(\"fish\", \"cat\") returns \"ftiasch\"\ncreate_id(\"icpc\", \"acm\") returns \"imccpac\"\n\n",
      "es": "Genera un identificador único entrelazando dos palabras en un patrón especificado.\n@param word1 La primera palabra que se utilizará en el proceso de creación del ID.\n@param word2 La segunda palabra que se utilizará en el proceso de creación del ID.\n@return Un identificador único formado alternando caracteres de la segunda palabra, invertida, con caracteres de la primera palabra.\nEjemplo de uso:\n\ncreate_id(\"fish\", \"cat\") devuelve \"ftiasch\"\ncreate_id(\"icpc\", \"acm\") devuelve \"imccpac\"",
      "arb": "ينشئ معرفًا فريدًا عن طريق تشابك كلمتين بنمط محدد.\n@param word1 الكلمة الأولى التي سيتم استخدامها في عملية إنشاء المعرف.\n@param word2 الكلمة الثانية التي سيتم استخدامها في عملية إنشاء المعرف.\n@return معرف فريد يتكون من تبديل الأحرف من الكلمة الثانية، معكوسة، مع الأحرف من الكلمة الأولى.\nمثال على الاستخدام:\n\ncreate_id(\"fish\", \"cat\") returns \"ftiasch\"\ncreate_id(\"icpc\", \"acm\") returns \"imccpac\"",
      "sw": "Hutengeneza kitambulisho cha kipekee kwa kuchanganya maneno mawili kwa mtindo maalum.\n@param word1 Neno la kwanza litakalotumika katika mchakato wa kuunda kitambulisho.\n@param word2 Neno la pili litakalotumika katika mchakato wa kuunda kitambulisho.\n@return Kitambulisho cha kipekee kinachoundwa kwa kubadilishana herufi kutoka neno la pili, lililogeuzwa, na herufi kutoka neno la kwanza.\nMfano wa Matumizi:\n\ncreate_id(\"fish\", \"cat\") inarudisha \"ftiasch\"\ncreate_id(\"icpc\", \"acm\") inarudisha \"imccpac\"",
      "tr": "Belirtilen bir desende iki kelimeyi iç içe geçirerek benzersiz bir tanımlayıcı oluşturur.\n@param word1 ID oluşturma sürecinde kullanılacak ilk kelime.\n@param word2 ID oluşturma sürecinde kullanılacak ikinci kelime.\n@return İkinci kelimenin karakterlerinin ters çevrilmiş hali ile birinci kelimenin karakterlerinin dönüşümlü olarak kullanılmasıyla oluşturulmuş benzersiz bir tanımlayıcı.\nÖrnek Kullanım:\n\ncreate_id(\"fish\", \"cat\") returns \"ftiasch\"\ncreate_id(\"icpc\", \"acm\") returns \"imccpac\"",
      "vi": "Tạo một định danh duy nhất bằng cách xen kẽ hai từ theo một mẫu được chỉ định.\n@param word1 Từ đầu tiên được sử dụng trong quá trình tạo ID.\n@param word2 Từ thứ hai được sử dụng trong quá trình tạo ID.\n@return Một định danh duy nhất được tạo ra bằng cách xen kẽ các ký tự từ từ thứ hai, đảo ngược, với các ký tự từ từ thứ nhất.\nVí dụ Sử dụng:\n\ncreate_id(\"fish\", \"cat\") trả về \"ftiasch\"\ncreate_id(\"icpc\", \"acm\") trả về \"imccpac\""
    },
    "docstring_bertscore": {
      "es": "0.9873913406726673",
      "arb": "0.9684471667118459",
      "sw": "0.9381695404699358",
      "tr": "0.9538047309130971",
      "vi": "0.9492515266886343"
    }
  },
  {
    "task_id": "CPP/19",
    "prompt": {
      "en": "#include <cassert>\n#include <cmath>\n#include <cstdio>\n#include <cstring>\n/**\n * Count the number of different permutation schemes for a binary string of length n,\n * where the number of '1's is m and the number of '0's is n - m.\n * \n * Parameters:\n * - n (int): Length of the binary string.\n * - m (int): Number of '1's in the binary string.\n * \n * Returns:\n * - int: The total number of different permutation schemes.\n */\nint count_permutations_of_binary_string(int n, int m)",
      "es": "#include <cassert>\n#include <cmath>\n#include <cstdio>\n#include <cstring>\n/**\n * Cuenta el número de diferentes esquemas de permutación para una cadena binaria de longitud n,\n * donde el número de '1's es m y el número de '0's es n - m.\n * \n * Parámetros:\n * - n (int): Longitud de la cadena binaria.\n * - m (int): Número de '1's en la cadena binaria.\n * \n * Devuelve:\n * - int: El número total de diferentes esquemas de permutación.\n */\nint count_permutations_of_binary_string(int n, int m)",
      "arb": "#include <cassert>\n#include <cmath>\n#include <cstdio>\n#include <cstring>\n/**\n * احسب عدد مخططات التبديل المختلفة لسلسلة ثنائية بطول n،\n * حيث يكون عدد '1's هو m وعدد '0's هو n - m.\n * \n * المعلمات:\n * - n (int): طول السلسلة الثنائية.\n * - m (int): عدد '1's في السلسلة الثنائية.\n * \n * يعيد:\n * - int: العدد الإجمالي لمخططات التبديل المختلفة.\n */\nint count_permutations_of_binary_string(int n, int m)",
      "sw": "#include <cassert>\n#include <cmath>\n#include <cstdio>\n#include <cstring>\n/**\n * Hesabu idadi ya mipango tofauti ya mpangilio kwa kamba ya binary ya urefu n,\n * ambapo idadi ya '1's ni m na idadi ya '0's ni n - m.\n * \n * Vigezo:\n * - n (int): Urefu wa kamba ya binary.\n * - m (int): Idadi ya '1's katika kamba ya binary.\n * \n * Inarudisha:\n * - int: Jumla ya idadi ya mipango tofauti ya mpangilio.\n */\nint count_permutations_of_binary_string(int n, int m)",
      "tr": "#include <cassert>\n#include <cmath>\n#include <cstdio>\n#include <cstring>\n/**\n * Uzunluğu n olan bir ikili dizgenin, '1'lerin sayısının m ve '0'ların sayısının n - m olduğu\n * farklı permütasyon şemalarının sayısını sayar.\n * \n * Parametreler:\n * - n (int): İkili dizgenin uzunluğu.\n * - m (int): İkili dizgedeki '1'lerin sayısı.\n * \n * Döndürür:\n * - int: Farklı permütasyon şemalarının toplam sayısı.\n */\nint count_permutations_of_binary_string(int n, int m)",
      "vi": "#include <cassert>\n#include <cmath>\n#include <cstdio>\n#include <cstring>\n/**\n * Đếm số lượng các sơ đồ hoán vị khác nhau cho một chuỗi nhị phân có độ dài n,\n * trong đó số lượng '1's là m và số lượng '0's là n - m.\n * \n * Tham số:\n * - n (int): Độ dài của chuỗi nhị phân.\n * - m (int): Số lượng '1's trong chuỗi nhị phân.\n * \n * Trả về:\n * - int: Tổng số lượng các sơ đồ hoán vị khác nhau.\n */\nint count_permutations_of_binary_string(int n, int m)"
    },
    "prompt_bertscore": {
      "es": "0.9965648861903826",
      "arb": "0.991681955533402",
      "sw": "0.9757041276829556",
      "tr": "0.9931824094317395",
      "vi": "0.9975139421509673"
    },
    "canonical_solution": "{\n    double factorial = 1.0;\n    int i;\n\n    // Calculate n factorial (n!)\n    for (i = 2; i <= n; ++i) {\n        factorial *= i;\n    }\n\n    double numerator = factorial; // n!\n\n    // Calculate (n+m)/2 factorial\n    factorial = 1.0;\n    for (i = 2; i <= (n + m) / 2; ++i) {\n        factorial *= i;\n    }\n\n    double denominator1 = factorial; // ((n+m)/2)!\n\n    // Calculate (n-m)/2 factorial\n    factorial = 1.0;\n    for (i = 2; i <= (n - m) / 2; ++i) {\n        factorial *= i;\n    }\n\n    double denominator2 = factorial; // ((n-m)/2)!\n\n    if ((n + m) & 1) {\n        return 0;\n    } else if (n == m) {\n        return 1;\n    } else {\n        // Calculating the number of permutations using the factorial values\n        return static_cast<int>(numerator / denominator1 / denominator2 + 0.5);\n    }\n}",
    "instruction": {
      "en": "int count_permutations_of_binary_string(int n, int m)\n{\n    double factorial = 1.0;\n    int i;\n\n    // Calculate n factorial (n!)\n    for (i = 2; i <= n; ++i) {\n        factorial *= i;\n    }\n\n    double numerator = factorial; // n!\n\n    // Calculate (n+m)/2 factorial\n    factorial = 1.0;\n    for (i = 2; i <= (n + m) / 2; ++i) {\n        factorial *= i;\n    }\n\n    double denominator1 = factorial; // ((n+m)/2)!\n\n    // Calculate (n-m)/2 factorial\n    factorial = 1.0;\n    for (i = 2; i <= (n - m) / 2; ++i) {\n        factorial *= i;\n    }\n\n    double denominator2 = factorial; // ((n-m)/2)!\n\n    if ((n + m) & 1) {\n        return 0;\n    } else if (n == m) {\n        return 1;\n    } else {\n        // Calculating the number of permutations using the factorial values\n        return static_cast<int>(numerator / denominator1 / denominator2 + 0.5);\n    }\n}\n\nProvide a concise natural language description (docstring) of the CPP code in English using at most 500 characters.",
      "es": "int count_permutations_of_binary_string(int n, int m)\n{\n    double factorial = 1.0;\n    int i;\n\n    // Calculate n factorial (n!)\n    for (i = 2; i <= n; ++i) {\n        factorial *= i;\n    }\n\n    double numerator = factorial; // n!\n\n    // Calculate (n+m)/2 factorial\n    factorial = 1.0;\n    for (i = 2; i <= (n + m) / 2; ++i) {\n        factorial *= i;\n    }\n\n    double denominator1 = factorial; // ((n+m)/2)!\n\n    // Calculate (n-m)/2 factorial\n    factorial = 1.0;\n    for (i = 2; i <= (n - m) / 2; ++i) {\n        factorial *= i;\n    }\n\n    double denominator2 = factorial; // ((n-m)/2)!\n\n    if ((n + m) & 1) {\n        return 0;\n    } else if (n == m) {\n        return 1;\n    } else {\n        // Calculating the number of permutations using the factorial values\n        return static_cast<int>(numerator / denominator1 / denominator2 + 0.5);\n    }\n}\n\nProporcione una descripción concisa en lenguaje natural (docstring) del código CPP en español utilizando como máximo 500 caracteres.",
      "arb": "int count_permutations_of_binary_string(int n, int m)\n{\n    double factorial = 1.0;\n    int i;\n\n    // Calculate n factorial (n!)\n    for (i = 2; i <= n; ++i) {\n        factorial *= i;\n    }\n\n    double numerator = factorial; // n!\n\n    // Calculate (n+m)/2 factorial\n    factorial = 1.0;\n    for (i = 2; i <= (n + m) / 2; ++i) {\n        factorial *= i;\n    }\n\n    double denominator1 = factorial; // ((n+m)/2)!\n\n    // Calculate (n-m)/2 factorial\n    factorial = 1.0;\n    for (i = 2; i <= (n - m) / 2; ++i) {\n        factorial *= i;\n    }\n\n    double denominator2 = factorial; // ((n-m)/2)!\n\n    if ((n + m) & 1) {\n        return 0;\n    } else if (n == m) {\n        return 1;\n    } else {\n        // Calculating the number of permutations using the factorial values\n        return static_cast<int>(numerator / denominator1 / denominator2 + 0.5);\n    }\n}\n\nيرجى تقديم وصف موجز بلغة طبيعية (docstring) للكود المكتوب بلغة C++ باللغة العربية الفصحى، بحيث لا يتجاوز 500 حرف.",
      "sw": "int count_permutations_of_binary_string(int n, int m)\n{\n    double factorial = 1.0;\n    int i;\n\n    // Calculate n factorial (n!)\n    for (i = 2; i <= n; ++i) {\n        factorial *= i;\n    }\n\n    double numerator = factorial; // n!\n\n    // Calculate (n+m)/2 factorial\n    factorial = 1.0;\n    for (i = 2; i <= (n + m) / 2; ++i) {\n        factorial *= i;\n    }\n\n    double denominator1 = factorial; // ((n+m)/2)!\n\n    // Calculate (n-m)/2 factorial\n    factorial = 1.0;\n    for (i = 2; i <= (n - m) / 2; ++i) {\n        factorial *= i;\n    }\n\n    double denominator2 = factorial; // ((n-m)/2)!\n\n    if ((n + m) & 1) {\n        return 0;\n    } else if (n == m) {\n        return 1;\n    } else {\n        // Calculating the number of permutations using the factorial values\n        return static_cast<int>(numerator / denominator1 / denominator2 + 0.5);\n    }\n}\n\nToa maelezo mafupi ya lugha ya asili (docstring) ya msimbo wa CPP kwa Kiswahili kwa kutumia herufi zisizozidi 500.",
      "tr": "int count_permutations_of_binary_string(int n, int m)\n{\n    double factorial = 1.0;\n    int i;\n\n    // Calculate n factorial (n!)\n    for (i = 2; i <= n; ++i) {\n        factorial *= i;\n    }\n\n    double numerator = factorial; // n!\n\n    // Calculate (n+m)/2 factorial\n    factorial = 1.0;\n    for (i = 2; i <= (n + m) / 2; ++i) {\n        factorial *= i;\n    }\n\n    double denominator1 = factorial; // ((n+m)/2)!\n\n    // Calculate (n-m)/2 factorial\n    factorial = 1.0;\n    for (i = 2; i <= (n - m) / 2; ++i) {\n        factorial *= i;\n    }\n\n    double denominator2 = factorial; // ((n-m)/2)!\n\n    if ((n + m) & 1) {\n        return 0;\n    } else if (n == m) {\n        return 1;\n    } else {\n        // Calculating the number of permutations using the factorial values\n        return static_cast<int>(numerator / denominator1 / denominator2 + 0.5);\n    }\n}\n\nAşağıdaki CPP kodunun işlevini açıklayan, en fazla 500 karakter uzunluğunda, kısa ve öz bir doğal dil açıklaması (docstring) sağlayın.",
      "vi": "int count_permutations_of_binary_string(int n, int m)\n{\n    double factorial = 1.0;\n    int i;\n\n    // Calculate n factorial (n!)\n    for (i = 2; i <= n; ++i) {\n        factorial *= i;\n    }\n\n    double numerator = factorial; // n!\n\n    // Calculate (n+m)/2 factorial\n    factorial = 1.0;\n    for (i = 2; i <= (n + m) / 2; ++i) {\n        factorial *= i;\n    }\n\n    double denominator1 = factorial; // ((n+m)/2)!\n\n    // Calculate (n-m)/2 factorial\n    factorial = 1.0;\n    for (i = 2; i <= (n - m) / 2; ++i) {\n        factorial *= i;\n    }\n\n    double denominator2 = factorial; // ((n-m)/2)!\n\n    if ((n + m) & 1) {\n        return 0;\n    } else if (n == m) {\n        return 1;\n    } else {\n        // Calculating the number of permutations using the factorial values\n        return static_cast<int>(numerator / denominator1 / denominator2 + 0.5);\n    }\n}\n\nCung cấp mô tả ngắn gọn bằng ngôn ngữ tự nhiên (docstring) cho mã CPP bằng tiếng Việt với tối đa 500 ký tự."
    },
    "instruction_bertscore": {
      "es": "0.9695565173899258",
      "arb": "0.8291343722565495",
      "sw": "0.9176812139269492",
      "tr": "0.8464815579538505",
      "vi": "0.9280338293864876"
    },
    "level": "",
    "test": "int main() {\n    assert(count_permutations_of_binary_string(2, 0) == 2);\n    assert(count_permutations_of_binary_string(2, 1) == 0);\n    assert(count_permutations_of_binary_string(3, 0) == 0);\n    assert(count_permutations_of_binary_string(3, 1) == 3);\n    assert(count_permutations_of_binary_string(3, 2) == 0);\n    assert(count_permutations_of_binary_string(30, 2) == 145422675);\n    assert(count_permutations_of_binary_string(4, 2) == 4);\n    assert(count_permutations_of_binary_string(5, 5) == 1);\n    assert(count_permutations_of_binary_string(33, 17) == 13884156);\n    assert(count_permutations_of_binary_string(1000, 1000) == 1);\n    // Add more test cases if necessary\n    return 0;\n}",
    "entry_point": "count_permutations_of_binary_string",
    "signature": "int count_permutations_of_binary_string(int n, int m)",
    "docstring": {
      "en": "Count the number of different permutation schemes for a binary string of length n, where the number of '1's is m and the number of '0's is n - m.\n\nParameters:\n- n (int): Length of the binary string.\n- m (int): Number of '1's in the binary string.\n\nReturns:\n- int: The total number of different permutation schemes.",
      "es": "Cuenta el número de diferentes esquemas de permutación para una cadena binaria de longitud n, donde el número de '1's es m y el número de '0's es n - m.\n\nParámetros:\n- n (int): Longitud de la cadena binaria.\n- m (int): Número de '1's en la cadena binaria.\n\nDevuelve:\n- int: El número total de diferentes esquemas de permutación.",
      "arb": "احسب عدد مخططات التبديل المختلفة لسلسلة ثنائية بطول n، حيث يكون عدد '1's هو m وعدد '0's هو n - m.\n\nالمعلمات:\n- n (int): طول السلسلة الثنائية.\n- m (int): عدد '1's في السلسلة الثنائية.\n\nالقيم المعادة:\n- int: العدد الإجمالي لمخططات التبديل المختلفة.",
      "sw": "Hesabu idadi ya mipango tofauti ya mpangilio kwa kamba ya binary yenye urefu n, ambapo idadi ya '1' ni m na idadi ya '0' ni n - m.\n\nVigezo:\n- n (int): Urefu wa kamba ya binary.\n- m (int): Idadi ya '1' katika kamba ya binary.\n\nRudisha:\n- int: Jumla ya idadi ya mipango tofauti ya mpangilio.",
      "tr": "İkili bir dizinin uzunluğu n olan ve '1'lerin sayısı m, '0'ların sayısı n - m olan farklı permütasyon şemalarının sayısını hesaplayın.\n\nParametreler:\n- n (int): İkili dizinin uzunluğu.\n- m (int): İkili dizideki '1'lerin sayısı.\n\nDöndürür:\n- int: Farklı permütasyon şemalarının toplam sayısı.",
      "vi": "Đếm số lượng các sơ đồ hoán vị khác nhau cho một chuỗi nhị phân có độ dài n, trong đó số lượng '1' là m và số lượng '0' là n - m.\n\nTham số:\n- n (int): Độ dài của chuỗi nhị phân.\n- m (int): Số lượng '1' trong chuỗi nhị phân.\n\nTrả về:\n- int: Tổng số lượng các sơ đồ hoán vị khác nhau."
    },
    "docstring_bertscore": {
      "es": "1",
      "arb": "0.9806355241529088",
      "sw": "0.9859909964863715",
      "tr": "0.9490832867558978",
      "vi": "0.9963597010067736"
    }
  },
  {
    "task_id": "CPP/20",
    "prompt": {
      "en": "#include <cassert>\n#include <cmath>\n#include <cstdlib>\n#include <cstdio>\n#include <cstring>\n/**\n *  Answer a series of questions by providing choices A, B, C, or D for each question.\n *  \n *  Question 1:\n *  Constants like 1e6 belong to which data type?\n *      A. unsigned int\n *      B. int\n *      C. float\n *      D. double\n *  \n *  Question 2:\n *  Given 21! = 51,090,942,171,709,440,000, which data type can be used to store this value?\n *      A. int\n *      B. long long\n *      C. double\n *      D. None of the above\n *  \n *  Question 3:\n *  Which statement about left values in expressions is incorrect?\n *      A. Variable name expressions are left values.\n *      B. Increment operation requires the operand to be a left value.\n *      C. Pointer dereference expressions are left values.\n *      D. Prefix increment operation expressions are left values.\n *  \n *  Question 4:\n *  Which statement about functions is incorrect?\n *      A. Formal parameters of a function are local variables.\n *      B. Local variables are allocated space in the stack.\n *      C. The function type is the same as the return value type.\n *      D. A function can call itself from within its body.\n *  \n *  Question 5:\n *  Which statement about pointers is incorrect?\n *      A. Subtracting two pointers equals the difference in their address values.\n *      B. Pointer dereference involves resolving based on the pointer's type.\n *      C. int *p[4], p is an array of int pointers.\n *      D. Function names can be assigned to function pointers.\n *  \n *  You're supposed to only return strings similar to \"AAAAA\", which stand for the choices of the question.\n */\nconst char* answer_questions()",
      "es": "#include <cassert>\n#include <cmath>\n#include <cstdlib>\n#include <cstdio>\n#include <cstring>\n/**\n *  Responder a una serie de preguntas proporcionando opciones A, B, C o D para cada pregunta.\n *  \n *  Pregunta 1:\n *  ¿A qué tipo de datos pertenecen constantes como 1e6?\n *      A. unsigned int\n *      B. int\n *      C. float\n *      D. double\n *  \n *  Pregunta 2:\n *  Dado 21! = 51,090,942,171,709,440,000, ¿qué tipo de datos se puede usar para almacenar este valor?\n *      A. int\n *      B. long long\n *      C. double\n *      D. Ninguna de las anteriores\n *  \n *  Pregunta 3:\n *  ¿Cuál afirmación sobre los valores a la izquierda en expresiones es incorrecta?\n *      A. Las expresiones de nombres de variables son valores a la izquierda.\n *      B. La operación de incremento requiere que el operando sea un valor a la izquierda.\n *      C. Las expresiones de desreferencia de punteros son valores a la izquierda.\n *      D. Las expresiones de operación de incremento prefijo son valores a la izquierda.\n *  \n *  Pregunta 4:\n *  ¿Cuál afirmación sobre las funciones es incorrecta?\n *      A. Los parámetros formales de una función son variables locales.\n *      B. Las variables locales se asignan espacio en la pila.\n *      C. El tipo de la función es el mismo que el tipo de valor de retorno.\n *      D. Una función puede llamarse a sí misma desde dentro de su cuerpo.\n *  \n *  Pregunta 5:\n *  ¿Cuál afirmación sobre los punteros es incorrecta?\n *      A. Restar dos punteros equivale a la diferencia en sus valores de dirección.\n *      B. La desreferencia de punteros implica resolver basado en el tipo del puntero.\n *      C. int *p[4], p es un arreglo de punteros a int.\n *      D. Los nombres de funciones pueden asignarse a punteros de funciones.\n *  \n *  Se supone que debes devolver solo cadenas similares a \"AAAAA\", que representan las opciones de la pregunta.\n */\nconst char* answer_questions()",
      "arb": "#include <cassert>\n#include <cmath>\n#include <cstdlib>\n#include <cstdio>\n#include <cstring>\n/**\n *  أجب عن سلسلة من الأسئلة بتقديم الخيارات A، B، C، أو D لكل سؤال.\n *  \n *  السؤال 1:\n *  الثوابت مثل 1e6 تنتمي إلى أي نوع من البيانات؟\n *      A. unsigned int\n *      B. int\n *      C. float\n *      D. double\n *  \n *  السؤال 2:\n *  بالنظر إلى 21! = 51,090,942,171,709,440,000، أي نوع من البيانات يمكن استخدامه لتخزين هذه القيمة؟\n *      A. int\n *      B. long long\n *      C. double\n *      D. لا شيء مما سبق\n *  \n *  السؤال 3:\n *  أي عبارة عن القيم اليسارية في التعبيرات غير صحيحة؟\n *      A. تعبيرات أسماء المتغيرات هي قيم يسارية.\n *      B. عملية الزيادة تتطلب أن يكون المعامل قيمة يسارية.\n *      C. تعبيرات إلغاء المؤشر هي قيم يسارية.\n *      D. تعبيرات عملية الزيادة المسبقة هي قيم يسارية.\n *  \n *  السؤال 4:\n *  أي عبارة عن الدوال غير صحيحة؟\n *      A. المعاملات الشكلية للدالة هي متغيرات محلية.\n *      B. يتم تخصيص مساحة للمتغيرات المحلية في المكدس.\n *      C. نوع الدالة هو نفسه نوع قيمة الإرجاع.\n *      D. يمكن للدالة أن تستدعي نفسها من داخل جسمها.\n *  \n *  السؤال 5:\n *  أي عبارة عن المؤشرات غير صحيحة؟\n *      A. طرح مؤشرين يساوي الفرق في قيم عناوينهما.\n *      B. إلغاء المؤشر يتضمن الحل بناءً على نوع المؤشر.\n *      C. int *p[4]، p هو مصفوفة من مؤشرات int.\n *      D. يمكن تعيين أسماء الدوال إلى مؤشرات الدوال.\n *  \n *  من المفترض أن تعيد فقط سلاسل مشابهة لـ \"AAAAA\"، والتي تمثل خيارات السؤال.\n */\nconst char* answer_questions()",
      "sw": "#include <cassert>\n#include <cmath>\n#include <cstdlib>\n#include <cstdio>\n#include <cstring>\n/**\n *  Jibu mfululizo wa maswali kwa kutoa chaguo A, B, C, au D kwa kila swali.\n *  \n *  Swali la 1:\n *  Vigezo kama 1e6 vinahusiana na aina gani ya data?\n *      A. unsigned int\n *      B. int\n *      C. float\n *      D. double\n *  \n *  Swali la 2:\n *  Ikitolewa 21! = 51,090,942,171,709,440,000, aina gani ya data inaweza kutumika kuhifadhi thamani hii?\n *      A. int\n *      B. long long\n *      C. double\n *      D. Hakuna kati ya haya\n *  \n *  Swali la 3:\n *  Ni kauli gani kuhusu thamani za kushoto katika maonyesho si sahihi?\n *      A. Maonyesho ya majina ya vigezo ni thamani za kushoto.\n *      B. Operesheni ya kuongeza inahitaji operand kuwa thamani ya kushoto.\n *      C. Maonyesho ya kufuta pointer ni thamani za kushoto.\n *      D. Maonyesho ya operesheni ya kuongeza awali ni thamani za kushoto.\n *  \n *  Swali la 4:\n *  Ni kauli gani kuhusu kazi si sahihi?\n *      A. Vigezo rasmi vya kazi ni vigezo vya ndani.\n *      B. Vigezo vya ndani vinatengewa nafasi kwenye stack.\n *      C. Aina ya kazi ni sawa na aina ya thamani ya kurudi.\n *      D. Kazi inaweza kujita kutoka ndani ya mwili wake.\n *  \n *  Swali la 5:\n *  Ni kauli gani kuhusu pointers si sahihi?\n *      A. Kutoa pointers mbili ni sawa na tofauti katika thamani za anwani zao.\n *      B. Kufuta pointer kunahusisha kutatua kulingana na aina ya pointer.\n *      C. int *p[4], p ni safu ya pointers za int.\n *      D. Majina ya kazi yanaweza kupewa pointers za kazi.\n *  \n *  Unatakiwa kurudisha tu misururu kama \"AAAAA\", ambayo inasimama kwa chaguo za swali.\n */\nconst char* answer_questions()",
      "tr": "#include <cassert>\n#include <cmath>\n#include <cstdlib>\n#include <cstdio>\n#include <cstring>\n/**\n *  Her bir soru için A, B, C veya D seçeneklerini sağlayarak bir dizi soruya cevap verin.\n *  \n *  Soru 1:\n *  1e6 gibi sabitler hangi veri tipine aittir?\n *      A. unsigned int\n *      B. int\n *      C. float\n *      D. double\n *  \n *  Soru 2:\n *  21! = 51,090,942,171,709,440,000 verildiğinde, bu değeri saklamak için hangi veri tipi kullanılabilir?\n *      A. int\n *      B. long long\n *      C. double\n *      D. Yukarıdakilerin hiçbiri\n *  \n *  Soru 3:\n *  İfadelerdeki sol değerler hakkında hangi ifade yanlıştır?\n *      A. Değişken adı ifadeleri sol değerlerdir.\n *      B. Artırma işlemi, operandın bir sol değer olmasını gerektirir.\n *      C. Gösterici çözme ifadeleri sol değerlerdir.\n *      D. Ön ek artırma işlemi ifadeleri sol değerlerdir.\n *  \n *  Soru 4:\n *  Fonksiyonlar hakkında hangi ifade yanlıştır?\n *      A. Bir fonksiyonun resmi parametreleri yerel değişkenlerdir.\n *      B. Yerel değişkenler yığında alan tahsis edilir.\n *      C. Fonksiyon türü, dönüş değeri türü ile aynıdır.\n *      D. Bir fonksiyon, gövdesi içinden kendini çağırabilir.\n *  \n *  Soru 5:\n *  Göstericiler hakkında hangi ifade yanlıştır?\n *      A. İki göstericinin çıkarılması, adres değerlerindeki farkı eşittir.\n *      B. Gösterici çözme, göstericinin türüne göre çözümlemeyi içerir.\n *      C. int *p[4], p bir dizi int göstericisidir.\n *      D. Fonksiyon isimleri, fonksiyon göstericilerine atanabilir.\n *  \n *  Sadece soruların seçeneklerini temsil eden \"AAAAA\" gibi dizeler döndürmeniz gerekiyor.\n */\nconst char* answer_questions()",
      "vi": "#include <cassert>\n#include <cmath>\n#include <cstdlib>\n#include <cstdio>\n#include <cstring>\n/**\n *  Trả lời một loạt câu hỏi bằng cách cung cấp lựa chọn A, B, C, hoặc D cho mỗi câu hỏi.\n *  \n *  Câu hỏi 1:\n *  Hằng số như 1e6 thuộc kiểu dữ liệu nào?\n *      A. unsigned int\n *      B. int\n *      C. float\n *      D. double\n *  \n *  Câu hỏi 2:\n *  Cho 21! = 51,090,942,171,709,440,000, kiểu dữ liệu nào có thể được sử dụng để lưu trữ giá trị này?\n *      A. int\n *      B. long long\n *      C. double\n *      D. Không có kiểu nào ở trên\n *  \n *  Câu hỏi 3:\n *  Câu nào về giá trị bên trái trong biểu thức là không đúng?\n *      A. Biểu thức tên biến là giá trị bên trái.\n *      B. Phép toán tăng yêu cầu toán hạng phải là giá trị bên trái.\n *      C. Biểu thức giải tham chiếu con trỏ là giá trị bên trái.\n *      D. Biểu thức phép toán tăng tiền tố là giá trị bên trái.\n *  \n *  Câu hỏi 4:\n *  Câu nào về hàm là không đúng?\n *      A. Tham số hình thức của một hàm là biến cục bộ.\n *      B. Biến cục bộ được cấp phát không gian trong ngăn xếp.\n *      C. Kiểu của hàm giống với kiểu giá trị trả về.\n *      D. Một hàm có thể gọi chính nó từ bên trong thân hàm.\n *  \n *  Câu hỏi 5:\n *  Câu nào về con trỏ là không đúng?\n *      A. Trừ hai con trỏ bằng với sự khác biệt trong giá trị địa chỉ của chúng.\n *      B. Giải tham chiếu con trỏ liên quan đến việc giải quyết dựa trên kiểu của con trỏ.\n *      C. int *p[4], p là một mảng các con trỏ int.\n *      D. Tên hàm có thể được gán cho con trỏ hàm.\n *  \n *  Bạn cần chỉ trả về chuỗi tương tự như \"AAAAA\", đại diện cho lựa chọn của câu hỏi.\n */\nconst char* answer_questions()"
    },
    "prompt_bertscore": {
      "es": "0.9567700838715669",
      "arb": "0.9448012130015476",
      "sw": "0.9273584860909689",
      "tr": "0.9455516385810975",
      "vi": "0.9215114035644449"
    },
    "canonical_solution": "{\n    return \"DDDBA\";\n}",
    "instruction": {
      "en": "const char* answer_questions()\n{\n    return \"DDDBA\";\n}\n\nProvide a concise natural language description (docstring) of the CPP code in English using at most 500 characters.",
      "es": "const char* answer_questions()\n{\n    return \"DDDBA\";\n}\n\nProporcione una descripción concisa en lenguaje natural (docstring) del código CPP en español utilizando como máximo 500 caracteres.",
      "arb": "const char* answer_questions()\n{\n    return \"DDDBA\";\n}\n\nيرجى تقديم وصف موجز بلغة طبيعية (docstring) للكود المكتوب بلغة C++ باللغة العربية الفصحى، بحيث لا يتجاوز 500 حرف.",
      "sw": "const char* answer_questions()\n{\n    return \"DDDBA\";\n}\n\nToa maelezo mafupi kwa lugha ya asili (docstring) ya msimbo wa CPP kwa Kiswahili kwa kutumia herufi zisizozidi 500.",
      "tr": "const char* answer_questions()\n{\n    return \"DDDBA\";\n}\n\nAşağıdaki CPP kodunun işlevini açıklayan, en fazla 500 karakter uzunluğunda bir doğal dil açıklaması (docstring) sağlayın.",
      "vi": "const char* answer_questions()\n{\n    return \"DDDBA\";\n}\n\nCung cấp mô tả ngắn gọn bằng ngôn ngữ tự nhiên (docstring) cho mã CPP bằng tiếng Việt với tối đa 500 ký tự."
    },
    "instruction_bertscore": {
      "es": "0.9695565173899258",
      "arb": "0.8291343722565495",
      "sw": "0.9164634110608243",
      "tr": "0.8400385842842217",
      "vi": "0.9171611995893999"
    },
    "level": "",
    "test": "int main() {\n    // The assert should compare strings, not literals or enums, using strcmp\n    const char* expected_answers = \"DDDBA\";\n    assert(strcmp(answer_questions(), expected_answers) == 0);\n    \n    return 0;\n}",
    "entry_point": "answer_questions",
    "signature": "const char* answer_questions()",
    "docstring": {
      "en": "Answer a series of questions by providing choices A, B, C, or D for each question.\n\nQuestion 1:\nConstants like 1e6 belong to which data type?\n    A. unsigned int\n    B. int\n    C. float\n    D. double\n\nQuestion 2:\nGiven 21! = 51,090,942,171,709,440,000, which data type can be used to store this value?\n    A. int\n    B. long long\n    C. double\n    D. None of the above\n\nQuestion 3:\nWhich statement about left values in expressions is incorrect?\n    A. Variable name expressions are left values.\n    B. Increment operation requires the operand to be a left value.\n    C. Pointer dereference expressions are left values.\n    D. Prefix increment operation expressions are left values.\n\nQuestion 4:\nWhich statement about functions is incorrect?\n    A. Formal parameters of a function are local variables.\n    B. Local variables are allocated space in the stack.\n    C. The function type is the same as the return value type.\n    D. A function can call itself from within its body.\n\nQuestion 5:\nWhich statement about pointers is incorrect?\n    A. Subtracting two pointers equals the difference in their address values.\n    B. Pointer dereference involves resolving based on the pointer's type.\n    C. int *p[4], p is an array of int pointers.\n    D. Function names can be assigned to function pointers.\n\nYou're supposed to only return strings similar to \"AAAAA\", which stand for the choices of the question.",
      "es": "Responde a una serie de preguntas proporcionando opciones A, B, C o D para cada pregunta.\n\nPregunta 1:\n¿A qué tipo de datos pertenecen constantes como 1e6?\n    A. unsigned int\n    B. int\n    C. float\n    D. double\n\nPregunta 2:\nDado 21! = 51,090,942,171,709,440,000, ¿qué tipo de datos se puede usar para almacenar este valor?\n    A. int\n    B. long long\n    C. double\n    D. Ninguna de las anteriores\n\nPregunta 3:\n¿Cuál afirmación sobre los valores a la izquierda en las expresiones es incorrecta?\n    A. Las expresiones de nombres de variables son valores a la izquierda.\n    B. La operación de incremento requiere que el operando sea un valor a la izquierda.\n    C. Las expresiones de desreferenciación de punteros son valores a la izquierda.\n    D. Las expresiones de operación de incremento prefijo son valores a la izquierda.\n\nPregunta 4:\n¿Cuál afirmación sobre las funciones es incorrecta?\n    A. Los parámetros formales de una función son variables locales.\n    B. Las variables locales se asignan espacio en la pila.\n    C. El tipo de la función es el mismo que el tipo del valor de retorno.\n    D. Una función puede llamarse a sí misma desde dentro de su cuerpo.\n\nPregunta 5:\n¿Cuál afirmación sobre los punteros es incorrecta?\n    A. Restar dos punteros equivale a la diferencia en sus valores de dirección.\n    B. La desreferenciación de punteros implica resolver en función del tipo del puntero.\n    C. int *p[4], p es un arreglo de punteros a int.\n    D. Los nombres de funciones pueden asignarse a punteros de funciones.\n\nSe supone que solo debes devolver cadenas similares a \"AAAAA\", que representan las opciones de la pregunta.",
      "arb": "الإجابة على سلسلة من الأسئلة عن طريق تقديم الخيارات A، B، C، أو D لكل سؤال.\n\nالسؤال 1:\nالثوابت مثل 1e6 تنتمي إلى أي نوع من البيانات؟\n    A. unsigned int\n    B. int\n    C. float\n    D. double\n\nالسؤال 2:\nبالنظر إلى 21! = 51,090,942,171,709,440,000، أي نوع من البيانات يمكن استخدامه لتخزين هذه القيمة؟\n    A. int\n    B. long long\n    C. double\n    D. لا شيء مما سبق\n\nالسؤال 3:\nأي عبارة عن القيم اليسرى في التعبيرات غير صحيحة؟\n    A. تعبيرات أسماء المتغيرات هي قيم يسرى.\n    B. عملية الزيادة تتطلب أن يكون المعامل قيمة يسرى.\n    C. تعبيرات إلغاء الإشارة للمؤشر هي قيم يسرى.\n    D. تعبيرات عملية الزيادة السابقة هي قيم يسرى.\n\nالسؤال 4:\nأي عبارة عن الدوال غير صحيحة؟\n    A. المعاملات الرسمية للدالة هي متغيرات محلية.\n    B. يتم تخصيص مساحة للمتغيرات المحلية في المكدس.\n    C. نوع الدالة هو نفسه نوع قيمة الإرجاع.\n    D. يمكن للدالة أن تستدعي نفسها من داخل جسمها.\n\nالسؤال 5:\nأي عبارة عن المؤشرات غير صحيحة؟\n    A. طرح مؤشرين يساوي الفرق في قيم عناوينهما.\n    B. إلغاء الإشارة للمؤشر يتضمن الحل بناءً على نوع المؤشر.\n    C. int *p[4]، p هو مصفوفة من مؤشرات int.\n    D. يمكن تعيين أسماء الدوال لمؤشرات الدوال.\n\nمن المفترض أن تعيد فقط سلاسل مشابهة لـ \"AAAAA\"، والتي تمثل اختيارات السؤال.",
      "sw": "Jibu maswali kadhaa kwa kutoa chaguo A, B, C, au D kwa kila swali.\n\nSwali la 1:\nKonstant kama 1e6 ni ya aina gani ya data?\n    A. unsigned int\n    B. int\n    C. float\n    D. double\n\nSwali la 2:\nKwa kuzingatia 21! = 51,090,942,171,709,440,000, aina gani ya data inaweza kutumika kuhifadhi thamani hii?\n    A. int\n    B. long long\n    C. double\n    D. Hakuna kati ya haya\n\nSwali la 3:\nNi tamko gani kuhusu thamani za kushoto katika maonyesho ambalo si sahihi?\n    A. Maonyesho ya majina ya vigezo ni thamani za kushoto.\n    B. Operesheni ya kuongeza inahitaji operand kuwa thamani ya kushoto.\n    C. Maonyesho ya kufuta pointer ni thamani za kushoto.\n    D. Maonyesho ya operesheni ya kuongeza awali ni thamani za kushoto.\n\nSwali la 4:\nNi tamko gani kuhusu kazi ambalo si sahihi?\n    A. Vigezo rasmi vya kazi ni vigezo vya ndani.\n    B. Vigezo vya ndani vinatengewa nafasi kwenye stack.\n    C. Aina ya kazi ni sawa na aina ya thamani inayorejeshwa.\n    D. Kazi inaweza kujita kutoka ndani ya mwili wake.\n\nSwali la 5:\nNi tamko gani kuhusu pointer ambalo si sahihi?\n    A. Kutoa pointer mbili ni sawa na tofauti katika thamani za anuani zao.\n    B. Kufuta pointer kunahusisha kutatua kulingana na aina ya pointer.\n    C. int *p[4], p ni safu ya pointer za int.\n    D. Majina ya kazi yanaweza kupewa pointer za kazi.\n\nUnatakiwa kurudisha tu mistari kama \"AAAAA\", ambayo inawakilisha chaguo za swali.",
      "tr": "Bir dizi soruya, her soru için A, B, C veya D seçeneklerini sağlayarak cevap verin.\n\nSoru 1:\n1e6 gibi sabitler hangi veri türüne aittir?\n    A. unsigned int\n    B. int\n    C. float\n    D. double\n\nSoru 2:\n21! = 51,090,942,171,709,440,000 verildiğinde, bu değeri saklamak için hangi veri türü kullanılabilir?\n    A. int\n    B. long long\n    C. double\n    D. Yukarıdakilerin hiçbiri\n\nSoru 3:\nİfadelerdeki sol değerler hakkında hangi ifade yanlıştır?\n    A. Değişken adı ifadeleri sol değerlerdir.\n    B. Artırma işlemi, operandın bir sol değer olmasını gerektirir.\n    C. Gösterici çözme ifadeleri sol değerlerdir.\n    D. Ön ek artırma işlemi ifadeleri sol değerlerdir.\n\nSoru 4:\nFonksiyonlar hakkında hangi ifade yanlıştır?\n    A. Bir fonksiyonun resmi parametreleri yerel değişkenlerdir.\n    B. Yerel değişkenler yığında yer kaplar.\n    C. Fonksiyon türü, dönüş değeri türü ile aynıdır.\n    D. Bir fonksiyon, kendi gövdesinden kendisini çağırabilir.\n\nSoru 5:\nGöstericiler hakkında hangi ifade yanlıştır?\n    A. İki göstericinin çıkarılması, adres değerlerindeki farkı eşittir.\n    B. Gösterici çözme, göstericinin türüne göre çözümlemeyi içerir.\n    C. int *p[4], p bir int gösterici dizisidir.\n    D. Fonksiyon adları, fonksiyon göstericilerine atanabilir.\n\nSoruların seçeneklerini temsil eden \"AAAAA\" gibi dizeleri döndürmeniz bekleniyor.",
      "vi": "Trả lời một loạt câu hỏi bằng cách cung cấp lựa chọn A, B, C, hoặc D cho mỗi câu hỏi.\n\nCâu hỏi 1:\nHằng số như 1e6 thuộc kiểu dữ liệu nào?\n    A. unsigned int\n    B. int\n    C. float\n    D. double\n\nCâu hỏi 2:\nCho 21! = 51,090,942,171,709,440,000, kiểu dữ liệu nào có thể được sử dụng để lưu trữ giá trị này?\n    A. int\n    B. long long\n    C. double\n    D. Không có kiểu nào ở trên\n\nCâu hỏi 3:\nCâu nào về giá trị bên trái trong biểu thức là không đúng?\n    A. Biểu thức tên biến là giá trị bên trái.\n    B. Phép toán tăng yêu cầu toán hạng là giá trị bên trái.\n    C. Biểu thức giải tham chiếu con trỏ là giá trị bên trái.\n    D. Biểu thức phép toán tăng trước là giá trị bên trái.\n\nCâu hỏi 4:\nCâu nào về hàm là không đúng?\n    A. Tham số hình thức của một hàm là biến cục bộ.\n    B. Biến cục bộ được cấp phát không gian trong ngăn xếp.\n    C. Kiểu hàm giống với kiểu giá trị trả về.\n    D. Một hàm có thể gọi chính nó từ trong thân hàm.\n\nCâu hỏi 5:\nCâu nào về con trỏ là không đúng?\n    A. Trừ hai con trỏ bằng với sự khác biệt trong giá trị địa chỉ của chúng.\n    B. Giải tham chiếu con trỏ liên quan đến việc giải quyết dựa trên kiểu của con trỏ.\n    C. int *p[4], p là một mảng của các con trỏ int.\n    D. Tên hàm có thể được gán cho con trỏ hàm.\n\nBạn được yêu cầu chỉ trả về chuỗi tương tự như \"AAAAA\", đại diện cho các lựa chọn của câu hỏi."
    },
    "docstring_bertscore": {
      "es": "0.9448397472954685",
      "arb": "0.951304967567773",
      "sw": "0.9045213552922448",
      "tr": "0.9455315769126129",
      "vi": "0.948873930334287"
    }
  },
  {
    "task_id": "CPP/21",
    "prompt": {
      "en": "#include <cassert>\n#include <cmath>\n#include <vector>\n/**\n * Determines if it is possible to assemble the wooden squares from n buckets\n * into a single larger square, where each bucket contains squares with a side length of 1.\n * \n * Input: vector of numbers\n * Example:\n *    >>> Is_Square({9})\n *    true\n * \n * @param squares Vector containing the count of squares in each bucket.\n * @return True if it is possible to form a larger square, False otherwise.\n */\nbool Is_Square(std::vector<int> squares)",
      "es": "#include <cassert>\n#include <cmath>\n#include <vector>\n/**\n * Determina si es posible ensamblar los cuadrados de madera de n cubetas\n * en un cuadrado más grande, donde cada cubeta contiene cuadrados con un lado de longitud 1.\n * \n * Entrada: vector de números\n * Ejemplo:\n *    >>> Is_Square({9})\n *    true\n * \n * @param squares Vector que contiene la cantidad de cuadrados en cada cubeta.\n * @return True si es posible formar un cuadrado más grande, False en caso contrario.\n */\nbool Is_Square(std::vector<int> squares)",
      "arb": "#include <cassert>\n#include <cmath>\n#include <vector>\n/**\n * يحدد ما إذا كان من الممكن تجميع المربعات الخشبية من n دلاء\n * في مربع أكبر واحد، حيث يحتوي كل دلو على مربعات بطول ضلع 1.\n * \n * المدخل: متجه من الأرقام\n * مثال:\n *    >>> Is_Square({9})\n *    true\n * \n * @param squares متجه يحتوي على عدد المربعات في كل دلو.\n * @return صحيح إذا كان من الممكن تشكيل مربع أكبر، خطأ خلاف ذلك.\n */\nbool Is_Square(std::vector<int> squares)",
      "sw": "#include <cassert>\n#include <cmath>\n#include <vector>\n/**\n * Huamua ikiwa inawezekana kuunganisha miraba ya mbao kutoka kwenye n ndoo\n * kuwa mraba mmoja mkubwa, ambapo kila ndoo ina miraba yenye urefu wa upande wa 1.\n * \n * Ingizo: vector ya namba\n * Mfano:\n *    >>> Is_Square({9})\n *    true\n * \n * @param squares Vector inayoshikilia idadi ya miraba katika kila ndoo.\n * @return True ikiwa inawezekana kuunda mraba mkubwa, False vinginevyo.\n */\nbool Is_Square(std::vector<int> squares)",
      "tr": "#include <cassert>\n#include <cmath>\n#include <vector>\n/**\n * n kovadan ahşap kareleri, her kovada kenar uzunluğu 1 olan kareler bulunan tek bir büyük kareye monte etmenin mümkün olup olmadığını belirler.\n * \n * Girdi: sayıların vektörü\n * Örnek:\n *    >>> Is_Square({9})\n *    true\n * \n * @param squares Her kovadaki karelerin sayısını içeren vektör.\n * @return Daha büyük bir kare oluşturmak mümkünse True, aksi takdirde False döner.\n */\nbool Is_Square(std::vector<int> squares)",
      "vi": "#include <cassert>\n#include <cmath>\n#include <vector>\n/**\n * Xác định xem có thể lắp ráp các hình vuông gỗ từ n xô\n * thành một hình vuông lớn hơn duy nhất hay không, trong đó mỗi xô chứa các hình vuông có độ dài cạnh là 1.\n * \n * Đầu vào: vector các số\n * Ví dụ:\n *    >>> Is_Square({9})\n *    true\n * \n * @param squares Vector chứa số lượng hình vuông trong mỗi xô.\n * @return True nếu có thể tạo thành một hình vuông lớn hơn, False nếu không thể.\n */\nbool Is_Square(std::vector<int> squares)"
    },
    "prompt_bertscore": {
      "es": "0.9924707167764916",
      "arb": "0.9795051186544392",
      "sw": "0.974351256157727",
      "tr": "0.9654599644114623",
      "vi": "0.9798207423299037"
    },
    "canonical_solution": "{\n    long long sum = 0;\n    for (int square : squares) {\n        sum += square; // Sum the squares\n    }\n    int root = static_cast<int>(std::sqrt(sum));\n    return root * root == sum; // Check if the sum is a perfect square\n}",
    "instruction": {
      "en": "bool Is_Square(std::vector<int> squares)\n{\n    long long sum = 0;\n    for (int square : squares) {\n        sum += square; // Sum the squares\n    }\n    int root = static_cast<int>(std::sqrt(sum));\n    return root * root == sum; // Check if the sum is a perfect square\n}\n\nProvide a concise natural language description (docstring) of the CPP code in English using at most 500 characters.",
      "es": "bool Is_Square(std::vector<int> squares)\n{\n    long long sum = 0;\n    for (int square : squares) {\n        sum += square; // Sum the squares\n    }\n    int root = static_cast<int>(std::sqrt(sum));\n    return root * root == sum; // Check if the sum is a perfect square\n}\n\nProporcione una descripción concisa en lenguaje natural (docstring) del código CPP en español utilizando como máximo 500 caracteres.",
      "arb": "bool Is_Square(std::vector<int> squares)\n{\n    long long sum = 0;\n    for (int square : squares) {\n        sum += square; // Sum the squares\n    }\n    int root = static_cast<int>(std::sqrt(sum));\n    return root * root == sum; // Check if the sum is a perfect square\n}\n\nيرجى تقديم وصف موجز بلغة طبيعية (docstring) للكود المكتوب بلغة C++ باللغة العربية الفصحى، بحيث لا يتجاوز 500 حرف.",
      "sw": "bool Is_Square(std::vector<int> squares)\n{\n    long long sum = 0;\n    for (int square : squares) {\n        sum += square; // Sum the squares\n    }\n    int root = static_cast<int>(std::sqrt(sum));\n    return root * root == sum; // Check if the sum is a perfect square\n}\n\nToa maelezo mafupi ya lugha ya asili (docstring) ya msimbo wa CPP kwa Kiswahili kwa kutumia herufi zisizozidi 500.",
      "tr": "bool Is_Square(std::vector<int> squares)\n{\n    long long sum = 0;\n    for (int square : squares) {\n        sum += square; // Sum the squares\n    }\n    int root = static_cast<int>(std::sqrt(sum));\n    return root * root == sum; // Check if the sum is a perfect square\n}\n\nAşağıdaki CPP kodunun Türkçe'de en fazla 500 karakter kullanarak özlü bir doğal dil açıklamasını (docstring) sağlayın.",
      "vi": "bool Is_Square(std::vector<int> squares)\n{\n    long long sum = 0;\n    for (int square : squares) {\n        sum += square; // Sum the squares\n    }\n    int root = static_cast<int>(std::sqrt(sum));\n    return root * root == sum; // Check if the sum is a perfect square\n}\n\nCung cấp mô tả ngắn gọn bằng ngôn ngữ tự nhiên (docstring) cho mã CPP bằng tiếng Việt với tối đa 500 ký tự."
    },
    "instruction_bertscore": {
      "es": "0.9695565173899258",
      "arb": "0.8291343722565495",
      "sw": "0.9176812139269492",
      "tr": "0.8827899998247418",
      "vi": "0.9171611995893999"
    },
    "level": "",
    "test": "int main() {\n    assert(Is_Square({9}) == true);\n    assert(Is_Square({14, 2}) == true);\n    assert(Is_Square({7, 7}) == false);\n    assert(Is_Square({1, 2, 3, 4, 5, 6, 7}) == false);\n    assert(Is_Square({1, 3, 5, 7, 9, 11}) == true);\n    assert(Is_Square({2, 2, 2, 2}) == false);\n\n    // Additional test cases\n    assert(Is_Square({4, 5, 6}) == false);\n    assert(Is_Square({16, 9, 4, 1}) == false);\n    assert(Is_Square({1, 1, 1, 1, 1}) == false);\n    assert(Is_Square({25, 25}) == false);\n    assert(Is_Square({10, 10, 5}) == true);\n\n    // All tests passed\n    return 0;\n}",
    "entry_point": "Is_Square",
    "signature": "bool Is_Square(std::vector<int> squares)",
    "docstring": {
      "en": "Determines if it is possible to assemble the wooden squares from n buckets\ninto a single larger square, where each bucket contains squares with a side length of 1.\n\nInput: vector of numbers\nExample:\n   >>> Is_Square({9})\n   true\n\n@param squares Vector containing the count of squares in each bucket.\n@return True if it is possible to form a larger square, False otherwise.\n",
      "es": "Determina si es posible ensamblar los cuadrados de madera de n cubetas en un solo cuadrado más grande, donde cada cubeta contiene cuadrados con un lado de longitud 1.\n\nEntrada: vector de números\nEjemplo:\n   >>> Is_Square({9})\n   true\n\n@param squares Vector que contiene la cantidad de cuadrados en cada cubeta.\n@return True si es posible formar un cuadrado más grande, False en caso contrario.",
      "arb": "يحدد ما إذا كان من الممكن تجميع المربعات الخشبية من n دلاء في مربع أكبر واحد، حيث يحتوي كل دلو على مربعات بطول ضلع 1.\n\nالمدخلات: متجه من الأرقام\nمثال:\n   >>> Is_Square({9})\n   true\n\n@param squares متجه يحتوي على عدد المربعات في كل دلو.\n@return صحيح إذا كان من الممكن تشكيل مربع أكبر، خطأ خلاف ذلك.",
      "sw": "Inabainisha kama inawezekana kuunganisha miraba ya mbao kutoka kwenye ndoo n kuwa mraba mmoja mkubwa zaidi, ambapo kila ndoo ina miraba yenye urefu wa upande wa 1.\n\nIngizo: vector ya namba\nMfano:\n   >>> Is_Square({9})\n   true\n\n@param squares Vector inayojumuisha idadi ya miraba katika kila ndoo.\n@return Kweli ikiwa inawezekana kuunda mraba mkubwa zaidi, Si kweli vinginevyo.",
      "tr": "Ahşap kareleri n kovasından tek bir büyük kareye monte etmenin mümkün olup olmadığını belirler, burada her kova kenar uzunluğu 1 olan kareler içerir.\n\nGirdi: sayıların vektörü\nÖrnek:\n   >>> Is_Square({9})\n   true\n\n@param squares Her kovadaki karelerin sayısını içeren vektör.\n@return Daha büyük bir kare oluşturmak mümkünse True, aksi takdirde False.",
      "vi": "Xác định xem có thể lắp ráp các hình vuông gỗ từ n thùng thành một hình vuông lớn hơn hay không, trong đó mỗi thùng chứa các hình vuông có độ dài cạnh là 1.\n\nĐầu vào: vector của các số\nVí dụ:\n   >>> Is_Square({9})\n   true\n\n@param squares Vector chứa số lượng hình vuông trong mỗi thùng.\n@return True nếu có thể tạo thành một hình vuông lớn hơn, False nếu không."
    },
    "docstring_bertscore": {
      "es": "0.9687308108959638",
      "arb": "0.9655922522452315",
      "sw": "0.970690696865635",
      "tr": "0.9693557020746996",
      "vi": "0.9382237665639583"
    }
  },
  {
    "task_id": "CPP/22",
    "prompt": {
      "en": "#include <cassert>\n#include <cmath>\n#include <cstdio>\n#include <cstring>\n/**\n * Given integers c and d, where a + b = c and a * b = d, this function\n * finds the possible value of a with the condition a <= b. When multiple \n * pairs (a, b) are possible, it returns the pair with the smallest a.\n * If no valid pair exists, it returns -1.\n *\n * Parameters:\n *  - c (int): The sum of a and b.\n *  - d (int): The product of a and b.\n *\n * Returns:\n *  - int: A possible value of a or -1 if no valid values exist.\n *\n * Examples:\n *  find_integers(7, 11) returns -1\n *  find_integers(5, 6) returns 2\n */\nint find_integers(int c, int d)",
      "es": "#include <cassert>\n#include <cmath>\n#include <cstdio>\n#include <cstring>\n/**\n * Dados los enteros c y d, donde a + b = c y a * b = d, esta función\n * encuentra el valor posible de a con la condición a <= b. Cuando múltiples \n * pares (a, b) son posibles, devuelve el par con el menor a.\n * Si no existe un par válido, devuelve -1.\n *\n * Parámetros:\n *  - c (int): La suma de a y b.\n *  - d (int): El producto de a y b.\n *\n * Devuelve:\n *  - int: Un valor posible de a o -1 si no existen valores válidos.\n *\n * Ejemplos:\n *  find_integers(7, 11) returns -1\n *  find_integers(5, 6) returns 2\n */\nint find_integers(int c, int d)",
      "arb": "#include <cassert>\n#include <cmath>\n#include <cstdio>\n#include <cstring>\n/**\n * بالنظر إلى الأعداد الصحيحة c و d، حيث a + b = c و a * b = d، هذه الدالة\n * تجد القيمة الممكنة لـ a بشرط a <= b. عندما تكون هناك أزواج متعددة (a, b) ممكنة، \n * فإنها تعيد الزوج الذي يحتوي على أصغر a.\n * إذا لم يوجد زوج صالح، فإنها تعيد -1.\n *\n * المعاملات:\n *  - c (int): مجموع a و b.\n *  - d (int): حاصل ضرب a و b.\n *\n * تعيد:\n *  - int: قيمة ممكنة لـ a أو -1 إذا لم توجد قيم صالحة.\n *\n * أمثلة:\n *  find_integers(7, 11) returns -1\n *  find_integers(5, 6) returns 2\n */\nint find_integers(int c, int d)",
      "sw": "#include <cassert>\n#include <cmath>\n#include <cstdio>\n#include <cstring>\n/**\n * Ukipewa nambari nzima c na d, ambapo a + b = c na a * b = d, kazi hii\n * inapata thamani inayowezekana ya a kwa sharti a <= b. Wakati jozi nyingi \n * (a, b) zinawezekana, inarudisha jozi yenye a ndogo zaidi.\n * Ikiwa hakuna jozi halali ipo, inarudisha -1.\n *\n * Vigezo:\n *  - c (int): Jumla ya a na b.\n *  - d (int): Bidhaa ya a na b.\n *\n * Inarudisha:\n *  - int: Thamani inayowezekana ya a au -1 ikiwa hakuna thamani halali ipo.\n *\n * Mifano:\n *  find_integers(7, 11) inarudisha -1\n *  find_integers(5, 6) inarudisha 2\n */\nint find_integers(int c, int d)",
      "tr": "#include <cassert>\n#include <cmath>\n#include <cstdio>\n#include <cstring>\n/**\n * a + b = c ve a * b = d olan tamsayılar c ve d verildiğinde, bu fonksiyon\n * a <= b koşuluyla a'nın olası değerini bulur. Birden fazla (a, b) çifti mümkün olduğunda,\n * en küçük a'ya sahip çifti döndürür. Geçerli bir çift yoksa, -1 döndürür.\n *\n * Parametreler:\n *  - c (int): a ve b'nin toplamı.\n *  - d (int): a ve b'nin çarpımı.\n *\n * Döndürür:\n *  - int: a'nın olası bir değeri veya geçerli değer yoksa -1.\n *\n * Örnekler:\n *  find_integers(7, 11) -1 döndürür\n *  find_integers(5, 6) 2 döndürür\n */\nint find_integers(int c, int d)",
      "vi": "#include <cassert>\n#include <cmath>\n#include <cstdio>\n#include <cstring>\n/**\n * Cho các số nguyên c và d, trong đó a + b = c và a * b = d, hàm này\n * tìm giá trị có thể của a với điều kiện a <= b. Khi có nhiều cặp \n * (a, b) có thể, nó trả về cặp với a nhỏ nhất.\n * Nếu không tồn tại cặp hợp lệ nào, nó trả về -1.\n *\n * Tham số:\n *  - c (int): Tổng của a và b.\n *  - d (int): Tích của a và b.\n *\n * Trả về:\n *  - int: Một giá trị có thể của a hoặc -1 nếu không tồn tại giá trị hợp lệ nào.\n *\n * Ví dụ:\n *  find_integers(7, 11) trả về -1\n *  find_integers(5, 6) trả về 2\n */\nint find_integers(int c, int d)"
    },
    "prompt_bertscore": {
      "es": "0.9969408935016817",
      "arb": "0.9650621077582494",
      "sw": "0.9887434176763719",
      "tr": "0.9847223442427016",
      "vi": "0.9917339966932331"
    },
    "canonical_solution": "{\n    for (int i = 0; i <= c / 2; i++) {\n        if (i * (c - i) != d) continue;\n        return i; // Return the value of a where a <= b and both conditions are satisfied\n    }\n    return -1; // Return -1 if no valid pairs (a, b) are found.\n}",
    "instruction": {
      "en": "int find_integers(int c, int d)\n{\n    for (int i = 0; i <= c / 2; i++) {\n        if (i * (c - i) != d) continue;\n        return i; // Return the value of a where a <= b and both conditions are satisfied\n    }\n    return -1; // Return -1 if no valid pairs (a, b) are found.\n}\n\nProvide a concise natural language description (docstring) of the CPP code in English using at most 500 characters.",
      "es": "int find_integers(int c, int d)\n{\n    for (int i = 0; i <= c / 2; i++) {\n        if (i * (c - i) != d) continue;\n        return i; // Return the value of a where a <= b and both conditions are satisfied\n    }\n    return -1; // Return -1 if no valid pairs (a, b) are found.\n}\n\nProporcione una descripción concisa en lenguaje natural (docstring) del código CPP en español utilizando como máximo 500 caracteres.",
      "arb": "int find_integers(int c, int d)\n{\n    for (int i = 0; i <= c / 2; i++) {\n        if (i * (c - i) != d) continue;\n        return i; // Return the value of a where a <= b and both conditions are satisfied\n    }\n    return -1; // Return -1 if no valid pairs (a, b) are found.\n}\n\nيرجى تقديم وصف موجز بلغة طبيعية (docstring) للكود المكتوب بلغة C++ باللغة العربية الفصحى، بحيث لا يتجاوز 500 حرف.",
      "sw": "int find_integers(int c, int d)\n{\n    for (int i = 0; i <= c / 2; i++) {\n        if (i * (c - i) != d) continue;\n        return i; // Return the value of a where a <= b and both conditions are satisfied\n    }\n    return -1; // Return -1 if no valid pairs (a, b) are found.\n}\n\nToa maelezo mafupi ya lugha ya asili (docstring) ya msimbo wa CPP kwa Kiswahili kwa kutumia herufi zisizozidi 500.",
      "tr": "int find_integers(int c, int d)\n{\n    for (int i = 0; i <= c / 2; i++) {\n        if (i * (c - i) != d) continue;\n        return i; // Return the value of a where a <= b and both conditions are satisfied\n    }\n    return -1; // Return -1 if no valid pairs (a, b) are found.\n}\n\nAşağıdaki CPP kodunun Türkçe olarak en fazla 500 karakter kullanarak doğal dilde kısa bir açıklamasını (docstring) sağlayın.",
      "vi": "int find_integers(int c, int d)\n{\n    for (int i = 0; i <= c / 2; i++) {\n        if (i * (c - i) != d) continue;\n        return i; // Return the value of a where a <= b and both conditions are satisfied\n    }\n    return -1; // Return -1 if no valid pairs (a, b) are found.\n}\n\nCung cấp mô tả ngắn gọn bằng ngôn ngữ tự nhiên (docstring) cho mã CPP bằng tiếng Việt với tối đa 500 ký tự."
    },
    "instruction_bertscore": {
      "es": "0.9695565173899258",
      "arb": "0.8291343722565495",
      "sw": "0.8925413611208876",
      "tr": "0.8483371629734784",
      "vi": "0.9044266086004912"
    },
    "level": "",
    "test": "int main() {\n    assert(find_integers(5, 6) == 2);\n    assert(find_integers(6, 9) == 3);\n    assert(find_integers(7, 12) == 3);\n    assert(find_integers(7, 11) == -1);\n    assert(find_integers(9, 8) == 1);\n    assert(find_integers(10, 25) == 5);\n    assert(find_integers(10000, 8765) == -1);\n\n    return 0;\n}",
    "entry_point": "find_integers",
    "signature": "int find_integers(int c, int d)",
    "docstring": {
      "en": "Given integers c and d, where a + b = c and a * b = d, this function\nfinds the possible value of a with the condition a <= b. When multiple\npairs (a, b) are possible, it returns the pair with the smallest a.\nIf no valid pair exists, it returns -1.\n\nParameters:\n- c (int): The sum of a and b.\n- d (int): The product of a and b.\n\nReturns:\n- int: A possible value of a or -1 if no valid values exist.\n\nExamples:\nfind_integers(7, 11) returns -1\nfind_integers(5, 6) returns 2\n",
      "es": "Dado los enteros c y d, donde a + b = c y a * b = d, esta función\nencuentra el valor posible de a con la condición a <= b. Cuando múltiples\npares (a, b) son posibles, devuelve el par con el a más pequeño.\nSi no existe un par válido, devuelve -1.\n\nParámetros:\n- c (int): La suma de a y b.\n- d (int): El producto de a y b.\n\nDevuelve:\n- int: Un valor posible de a o -1 si no existen valores válidos.\n\nEjemplos:\nfind_integers(7, 11) devuelve -1\nfind_integers(5, 6) devuelve 2",
      "arb": "المعطى عددان صحيحان c و d، حيث a + b = c و a * b = d، هذه الدالة\nتجد القيمة الممكنة لـ a بشرط أن a <= b. عندما تكون هناك أزواج متعددة (a, b) ممكنة، فإنها تعيد الزوج الذي يحتوي على أصغر قيمة لـ a.\nإذا لم يكن هناك زوج صالح، فإنها تعيد -1.\n\nالمعطيات:\n- c (int): مجموع a و b.\n- d (int): حاصل ضرب a و b.\n\nالقيم المعادة:\n- int: قيمة ممكنة لـ a أو -1 إذا لم تكن هناك قيم صالحة.\n\nأمثلة:\nfind_integers(7, 11) يعيد -1\nfind_integers(5, 6) يعيد 2",
      "sw": "Ukipewa nambari nzima c na d, ambapo a + b = c na a * b = d, kazi hii\ninapata thamani inayowezekana ya a kwa sharti a <= b. Wakati jozi nyingi\n(a, b) zinawezekana, inarudisha jozi yenye a ndogo zaidi.\nIkiwa hakuna jozi halali ipo, inarudisha -1.\n\nVigezo:\n- c (int): Jumla ya a na b.\n- d (int): Bidhaa ya a na b.\n\nInarejesha:\n- int: Thamani inayowezekana ya a au -1 ikiwa hakuna thamani halali.\n\nMifano:\nfind_integers(7, 11) inarejesha -1\nfind_integers(5, 6) inarejesha 2",
      "tr": "Verilen c ve d tam sayıları için, burada a + b = c ve a * b = d, bu fonksiyon a <= b koşuluyla a'nın olası değerini bulur. Birden fazla (a, b) çifti mümkün olduğunda, en küçük a'ya sahip çifti döndürür. Geçerli bir çift yoksa, -1 döndürür.\n\nParametreler:\n- c (int): a ve b'nin toplamı.\n- d (int): a ve b'nin çarpımı.\n\nDöndürülen:\n- int: a'nın olası bir değeri veya geçerli bir değer yoksa -1.\n\nÖrnekler:\nfind_integers(7, 11) -1 döndürür\nfind_integers(5, 6) 2 döndürür",
      "vi": "Cho các số nguyên c và d, trong đó a + b = c và a * b = d, hàm này tìm giá trị có thể có của a với điều kiện a <= b. Khi có nhiều cặp (a, b) có thể, nó trả về cặp với a nhỏ nhất. Nếu không tồn tại cặp hợp lệ, nó trả về -1.\n\nTham số:\n- c (int): Tổng của a và b.\n- d (int): Tích của a và b.\n\nTrả về:\n- int: Một giá trị có thể có của a hoặc -1 nếu không tồn tại giá trị hợp lệ.\n\nVí dụ:\nfind_integers(7, 11) trả về -1\nfind_integers(5, 6) trả về 2"
    },
    "docstring_bertscore": {
      "es": "0.9958770291808589",
      "arb": "0.9631562492522197",
      "sw": "0.9883978008133711",
      "tr": "0.9805475308941103",
      "vi": "0.9912135850949217"
    }
  },
  {
    "task_id": "CPP/23",
    "prompt": {
      "en": "#include <cassert>\n#include <cmath>\n#include <cstdio>\n#include <cstdlib>\n#include <cstring>\n#include <cstdarg>\n/**\nCount the number of acute-angled triangles that can be formed by selecting any 3 edges out of\na given set of edges.\n  \nArgs:\n- edges_count: The number of edges passed.\n- An arbitrary number of integer arguments representing the lengths of the edges.\n  \nReturns:\nint: The count of distinct acute-angled triangles that can be formed.\n  \nExamples:\n>>> count_acute_triangles(4, 1, 1, 1, 1)\n4\n**/\nint count_acute_triangles(int edges_count, ...)",
      "es": "#include <cassert>\n#include <cmath>\n#include <cstdio>\n#include <cstdlib>\n#include <cstring>\n#include <cstdarg>\n/**\nCuenta el número de triángulos acutángulos que se pueden formar seleccionando cualquier 3 lados de un conjunto dado de lados.\n  \nArgs:\n- edges_count: El número de lados pasados.\n- Un número arbitrario de argumentos enteros que representan las longitudes de los lados.\n  \nReturns:\nint: La cantidad de triángulos acutángulos distintos que se pueden formar.\n  \nExamples:\n>>> count_acute_triangles(4, 1, 1, 1, 1)\n4\n**/\nint count_acute_triangles(int edges_count, ...)",
      "arb": "#include <cassert>\n#include <cmath>\n#include <cstdio>\n#include <cstdlib>\n#include <cstring>\n#include <cstdarg>\n/**\nاحسب عدد المثلثات الحادة الزاوية التي يمكن تشكيلها عن طريق اختيار أي 3 حواف من مجموعة معينة من الحواف.\n\nالمعطيات:\n- edges_count: عدد الحواف الممررة.\n- عدد تعسفي من الوسيطات الصحيحة التي تمثل أطوال الحواف.\n\nالإرجاع:\nint: عدد المثلثات الحادة الزاوية المميزة التي يمكن تشكيلها.\n\nأمثلة:\n>>> count_acute_triangles(4, 1, 1, 1, 1)\n4\n**/\nint count_acute_triangles(int edges_count, ...)",
      "sw": "#include <cassert>\n#include <cmath>\n#include <cstdio>\n#include <cstdlib>\n#include <cstring>\n#include <cstdarg>\n/**\nHesabu idadi ya pembetatu zenye pembe kali ambazo zinaweza kuundwa kwa kuchagua pande 3 yoyote kutoka kwenye seti ya pande zilizotolewa.\n\nArgs:\n- edges_count: Idadi ya pande zilizopitishwa.\n- Idadi isiyo ya kawaida ya hoja za nambari nzima zinazowakilisha urefu wa pande.\n\nReturns:\nint: Idadi ya pembetatu tofauti zenye pembe kali ambazo zinaweza kuundwa.\n\nExamples:\n>>> count_acute_triangles(4, 1, 1, 1, 1)\n4\n**/\nint count_acute_triangles(int edges_count, ...)",
      "tr": "#include <cassert>\n#include <cmath>\n#include <cstdio>\n#include <cstdlib>\n#include <cstring>\n#include <cstdarg>\n/**\nVerilen bir kenar kümesinden herhangi 3 kenar seçilerek oluşturulabilecek keskin açılı üçgenlerin sayısını sayar.\n  \nArgümanlar:\n- edges_count: Geçilen kenarların sayısı.\n- Kenar uzunluklarını temsil eden rastgele sayıda tamsayı argümanı.\n  \nDöndürür:\nint: Oluşturulabilecek farklı keskin açılı üçgenlerin sayısı.\n  \nÖrnekler:\n>>> count_acute_triangles(4, 1, 1, 1, 1)\n4\n**/\nint count_acute_triangles(int edges_count, ...)",
      "vi": "#include <cassert>\n#include <cmath>\n#include <cstdio>\n#include <cstdlib>\n#include <cstring>\n#include <cstdarg>\n/**\nĐếm số lượng tam giác nhọn có thể được tạo thành bằng cách chọn bất kỳ 3 cạnh nào từ\nmột tập hợp các cạnh cho trước.\n  \nTham số:\n- edges_count: Số lượng cạnh được truyền vào.\n- Một số lượng tùy ý các đối số nguyên đại diện cho độ dài của các cạnh.\n  \nTrả về:\nint: Số lượng tam giác nhọn khác biệt có thể được tạo thành.\n  \nVí dụ:\n>>> count_acute_triangles(4, 1, 1, 1, 1)\n4\n**/\nint count_acute_triangles(int edges_count, ...)"
    },
    "prompt_bertscore": {
      "es": "0.9673054392816574",
      "arb": "0.9558428772528961",
      "sw": "0.9620552410501433",
      "tr": "0.9730853847393917",
      "vi": "0.9648330869289161"
    },
    "canonical_solution": "{\n    va_list args;\n    va_start(args, edges_count);\n\n    int* edges = (int*) malloc(edges_count * sizeof(int));\n    for (int i = 0; i < edges_count; i++) {\n        edges[i] = va_arg(args, int);\n    }\n    va_end(args);\n\n    // qsort(edges, edges_count, sizeof(int), [](const void * a, const void * b) -> int {\n    //     return *(int*)a - *(int*)b;\n    // });\n    qsort(edges, edges_count, sizeof(int), (int (*)(const void *, const void *)) strcmp);\n\n\n    int sum = 0;\n    for (int i = 0; i < edges_count - 2; i++) {\n        for (int j = i + 1; j < edges_count - 1; j++) {\n            for (int k = j + 1; k < edges_count; k++) {\n                int x = edges[i], y = edges[j], z = edges[k];\n                if (x + y > z && x * x + y * y > z * z) {\n                    sum++;\n                }\n            }\n        }\n    }\n\n    free(edges);\n    return sum;\n}",
    "instruction": {
      "en": "int count_acute_triangles(int edges_count, ...)\n{\n    va_list args;\n    va_start(args, edges_count);\n\n    int* edges = (int*) malloc(edges_count * sizeof(int));\n    for (int i = 0; i < edges_count; i++) {\n        edges[i] = va_arg(args, int);\n    }\n    va_end(args);\n\n    // qsort(edges, edges_count, sizeof(int), [](const void * a, const void * b) -> int {\n    //     return *(int*)a - *(int*)b;\n    // });\n    qsort(edges, edges_count, sizeof(int), (int (*)(const void *, const void *)) strcmp);\n\n\n    int sum = 0;\n    for (int i = 0; i < edges_count - 2; i++) {\n        for (int j = i + 1; j < edges_count - 1; j++) {\n            for (int k = j + 1; k < edges_count; k++) {\n                int x = edges[i], y = edges[j], z = edges[k];\n                if (x + y > z && x * x + y * y > z * z) {\n                    sum++;\n                }\n            }\n        }\n    }\n\n    free(edges);\n    return sum;\n}\n\nProvide a concise natural language description (docstring) of the CPP code in English using at most 500 characters.",
      "es": "int count_acute_triangles(int edges_count, ...)\n{\n    va_list args;\n    va_start(args, edges_count);\n\n    int* edges = (int*) malloc(edges_count * sizeof(int));\n    for (int i = 0; i < edges_count; i++) {\n        edges[i] = va_arg(args, int);\n    }\n    va_end(args);\n\n    // qsort(edges, edges_count, sizeof(int), [](const void * a, const void * b) -> int {\n    //     return *(int*)a - *(int*)b;\n    // });\n    qsort(edges, edges_count, sizeof(int), (int (*)(const void *, const void *)) strcmp);\n\n\n    int sum = 0;\n    for (int i = 0; i < edges_count - 2; i++) {\n        for (int j = i + 1; j < edges_count - 1; j++) {\n            for (int k = j + 1; k < edges_count; k++) {\n                int x = edges[i], y = edges[j], z = edges[k];\n                if (x + y > z && x * x + y * y > z * z) {\n                    sum++;\n                }\n            }\n        }\n    }\n\n    free(edges);\n    return sum;\n}\n\nProporcione una descripción concisa en lenguaje natural (docstring) del código CPP en español utilizando como máximo 500 caracteres.",
      "arb": "int count_acute_triangles(int edges_count, ...)\n{\n    va_list args;\n    va_start(args, edges_count);\n\n    int* edges = (int*) malloc(edges_count * sizeof(int));\n    for (int i = 0; i < edges_count; i++) {\n        edges[i] = va_arg(args, int);\n    }\n    va_end(args);\n\n    // qsort(edges, edges_count, sizeof(int), [](const void * a, const void * b) -> int {\n    //     return *(int*)a - *(int*)b;\n    // });\n    qsort(edges, edges_count, sizeof(int), (int (*)(const void *, const void *)) strcmp);\n\n\n    int sum = 0;\n    for (int i = 0; i < edges_count - 2; i++) {\n        for (int j = i + 1; j < edges_count - 1; j++) {\n            for (int k = j + 1; k < edges_count; k++) {\n                int x = edges[i], y = edges[j], z = edges[k];\n                if (x + y > z && x * x + y * y > z * z) {\n                    sum++;\n                }\n            }\n        }\n    }\n\n    free(edges);\n    return sum;\n}\n\nيرجى تقديم وصف موجز بلغة طبيعية (docstring) لشفرة CPP باللغة العربية الفصحى باستخدام ما لا يزيد عن 500 حرف.",
      "sw": "int count_acute_triangles(int edges_count, ...)\n{\n    va_list args;\n    va_start(args, edges_count);\n\n    int* edges = (int*) malloc(edges_count * sizeof(int));\n    for (int i = 0; i < edges_count; i++) {\n        edges[i] = va_arg(args, int);\n    }\n    va_end(args);\n\n    // qsort(edges, edges_count, sizeof(int), [](const void * a, const void * b) -> int {\n    //     return *(int*)a - *(int*)b;\n    // });\n    qsort(edges, edges_count, sizeof(int), (int (*)(const void *, const void *)) strcmp);\n\n\n    int sum = 0;\n    for (int i = 0; i < edges_count - 2; i++) {\n        for (int j = i + 1; j < edges_count - 1; j++) {\n            for (int k = j + 1; k < edges_count; k++) {\n                int x = edges[i], y = edges[j], z = edges[k];\n                if (x + y > z && x * x + y * y > z * z) {\n                    sum++;\n                }\n            }\n        }\n    }\n\n    free(edges);\n    return sum;\n}\n\nToa maelezo mafupi ya lugha asilia (docstring) ya msimbo wa CPP kwa Kiswahili kwa kutumia herufi zisizozidi 500.",
      "tr": "int count_acute_triangles(int edges_count, ...)\n{\n    va_list args;\n    va_start(args, edges_count);\n\n    int* edges = (int*) malloc(edges_count * sizeof(int));\n    for (int i = 0; i < edges_count; i++) {\n        edges[i] = va_arg(args, int);\n    }\n    va_end(args);\n\n    // qsort(edges, edges_count, sizeof(int), [](const void * a, const void * b) -> int {\n    //     return *(int*)a - *(int*)b;\n    // });\n    qsort(edges, edges_count, sizeof(int), (int (*)(const void *, const void *)) strcmp);\n\n\n    int sum = 0;\n    for (int i = 0; i < edges_count - 2; i++) {\n        for (int j = i + 1; j < edges_count - 1; j++) {\n            for (int k = j + 1; k < edges_count; k++) {\n                int x = edges[i], y = edges[j], z = edges[k];\n                if (x + y > z && x * x + y * y > z * z) {\n                    sum++;\n                }\n            }\n        }\n    }\n\n    free(edges);\n    return sum;\n}\n\nAşağıdaki CPP kodunun işlevini açıklayan, en fazla 500 karakter uzunluğunda bir doğal dil açıklaması (docstring) sağlayın. Açıklama Türkçe olmalıdır.",
      "vi": "int count_acute_triangles(int edges_count, ...)\n{\n    va_list args;\n    va_start(args, edges_count);\n\n    int* edges = (int*) malloc(edges_count * sizeof(int));\n    for (int i = 0; i < edges_count; i++) {\n        edges[i] = va_arg(args, int);\n    }\n    va_end(args);\n\n    // qsort(edges, edges_count, sizeof(int), [](const void * a, const void * b) -> int {\n    //     return *(int*)a - *(int*)b;\n    // });\n    qsort(edges, edges_count, sizeof(int), (int (*)(const void *, const void *)) strcmp);\n\n\n    int sum = 0;\n    for (int i = 0; i < edges_count - 2; i++) {\n        for (int j = i + 1; j < edges_count - 1; j++) {\n            for (int k = j + 1; k < edges_count; k++) {\n                int x = edges[i], y = edges[j], z = edges[k];\n                if (x + y > z && x * x + y * y > z * z) {\n                    sum++;\n                }\n            }\n        }\n    }\n\n    free(edges);\n    return sum;\n}\n\nCung cấp mô tả ngắn gọn bằng ngôn ngữ tự nhiên (docstring) cho mã CPP bằng tiếng Việt với tối đa 500 ký tự."
    },
    "instruction_bertscore": {
      "es": "0.9695565173899258",
      "arb": "0.9190017087000691",
      "sw": "0.9094664572584894",
      "tr": "0.8461508383694274",
      "vi": "0.9171611995893999"
    },
    "level": "",
    "test": "int main() {\n    assert(count_acute_triangles(4, 1, 1, 1, 1) == 4);\n    assert(count_acute_triangles(3, 1, 2, 3) == 0);\n    // Additional tests to ensure correctness\n    assert(count_acute_triangles(5, 3, 4, 5, 7, 10) == 0);\n    assert(count_acute_triangles(6, 6, 8, 10, 5, 5, 5) == 4);\n    return 0;\n}",
    "entry_point": "count_acute_triangles",
    "signature": "int count_acute_triangles(int edges_count, ...)",
    "docstring": {
      "en": "Count the number of acute-angled triangles that can be formed by selecting any 3 edges out of a given set of edges.\n\nArgs:\n- edges_count: The number of edges passed.\n- An arbitrary number of integer arguments representing the lengths of the edges.\n\nReturns:\nint: The count of distinct acute-angled triangles that can be formed.\n\nExamples:\n>>> count_acute_triangles(4, 1, 1, 1, 1)\n4\n",
      "es": "Cuenta el número de triángulos acutángulos que se pueden formar seleccionando cualquier 3 aristas de un conjunto dado de aristas.\n\nArgs:\n- edges_count: El número de aristas pasadas.\n- Un número arbitrario de argumentos enteros que representan las longitudes de las aristas.\n\nReturns:\nint: La cuenta de triángulos acutángulos distintos que se pueden formar.\n\nExamples:\n>>> count_acute_triangles(4, 1, 1, 1, 1)\n4",
      "arb": "عد عدد المثلثات الحادة الزاوية التي يمكن تشكيلها عن طريق اختيار أي 3 حواف من مجموعة الحواف المعطاة.\n\nArgs:\n- edges_count: عدد الحواف الممررة.\n- عدد تعسفي من الوسيطات الصحيحة التي تمثل أطوال الحواف.\n\nReturns:\nint: عدد المثلثات الحادة الزاوية المميزة التي يمكن تشكيلها.\n\nExamples:\n>>> count_acute_triangles(4, 1, 1, 1, 1)\n4",
      "sw": "Hesabu idadi ya pembetatu zenye pembe kali ambazo zinaweza kuundwa kwa kuchagua kingo 3 kutoka kwenye seti iliyotolewa ya kingo.\n\nArgs:\n- edges_count: Idadi ya kingo zilizopitishwa.\n- Idadi yoyote ya hoja za nambari nzima zinazowakilisha urefu wa kingo.\n\nReturns:\nint: Idadi ya pembetatu tofauti zenye pembe kali ambazo zinaweza kuundwa.\n\nExamples:\n>>> count_acute_triangles(4, 1, 1, 1, 1)\n4",
      "tr": "Verilen bir dizi kenardan herhangi 3 kenar seçilerek oluşturulabilecek keskin açılı üçgenlerin sayısını sayın.\n\nArgs:\n- edges_count: Geçilen kenarların sayısı.\n- Kenarların uzunluklarını temsil eden rastgele sayıda tamsayı argümanı.\n\nReturns:\nint: Oluşturulabilecek farklı keskin açılı üçgenlerin sayısı.\n\nExamples:\n>>> count_acute_triangles(4, 1, 1, 1, 1)\n4",
      "vi": "Đếm số lượng tam giác nhọn có thể được tạo thành bằng cách chọn bất kỳ 3 cạnh nào từ một tập hợp các cạnh đã cho.\n\nTham số:\n- edges_count: Số lượng cạnh được truyền vào.\n- Một số lượng tùy ý các đối số kiểu số nguyên đại diện cho độ dài của các cạnh.\n\nTrả về:\nint: Số lượng tam giác nhọn khác nhau có thể được tạo thành.\n\nVí dụ:\n>>> count_acute_triangles(4, 1, 1, 1, 1)\n4"
    },
    "docstring_bertscore": {
      "es": "0.9735740154767374",
      "arb": "0.9855492425189498",
      "sw": "0.9713473689053364",
      "tr": "0.9735311113144339",
      "vi": "0.9221521851736635"
    }
  },
  {
    "task_id": "CPP/24",
    "prompt": {
      "en": "#include <bits/stdc++.h>\n/**\n * Reads an integer and a character, then returns them as a formatted string separated by a comma.\n * \n * Parameters:\n * - integer_value (int): The input integer.\n * - char_value (char): The input character.\n * \n * Returns:\n * - char*: A string containing the integer and character separated by a comma.\n * \n * Example:\n * process_integer_and_char(234, 'H') returns \"234,H\"\n */\nchar* process_integer_and_char(int integer_value, char char_value)",
      "es": "#include <bits/stdc++.h>\n/**\n * Lee un entero y un carácter, luego los devuelve como una cadena formateada separada por una coma.\n * \n * Parámetros:\n * - integer_value (int): El entero de entrada.\n * - char_value (char): El carácter de entrada.\n * \n * Devuelve:\n * - char*: Una cadena que contiene el entero y el carácter separados por una coma.\n * \n * Ejemplo:\n * process_integer_and_char(234, 'H') returns \"234,H\"\n */\nchar* process_integer_and_char(int integer_value, char char_value)",
      "arb": "#include <bits/stdc++.h>\n/**\n * يقرأ عددًا صحيحًا وحرفًا، ثم يعيدهما كسلسلة نصية منسقة مفصولة بفاصلة.\n * \n * المعلمات:\n * - integer_value (int): العدد الصحيح المدخل.\n * - char_value (char): الحرف المدخل.\n * \n * يعيد:\n * - char*: سلسلة نصية تحتوي على العدد الصحيح والحرف مفصولين بفاصلة.\n * \n * مثال:\n * process_integer_and_char(234, 'H') returns \"234,H\"\n */\nchar* process_integer_and_char(int integer_value, char char_value)",
      "sw": "#include <bits/stdc++.h>\n/**\n * Husoma nambari kamili na herufi, kisha kuzirejesha kama mfuatano wa maandishi uliopangwa ukitenganishwa na koma.\n * \n * Vigezo:\n * - integer_value (int): Nambari kamili ya ingizo.\n * - char_value (char): Herufi ya ingizo.\n * \n * Inarejesha:\n * - char*: Mfuatano wa maandishi unao na nambari kamili na herufi zikitenganishwa na koma.\n * \n * Mfano:\n * process_integer_and_char(234, 'H') inarejesha \"234,H\"\n */\nchar* process_integer_and_char(int integer_value, char char_value)",
      "tr": "#include <bits/stdc++.h>\n/**\n * Bir tam sayı ve bir karakter okur, ardından bunları virgülle ayrılmış biçimlendirilmiş bir dize olarak döndürür.\n * \n * Parametreler:\n * - integer_value (int): Girdi tam sayısı.\n * - char_value (char): Girdi karakteri.\n * \n * Döndürür:\n * - char*: Tam sayı ve karakteri virgülle ayrılmış bir dize olarak içeren bir dize.\n * \n * Örnek:\n * process_integer_and_char(234, 'H') \"234,H\" döndürür\n */\nchar* process_integer_and_char(int integer_value, char char_value)",
      "vi": "#include <bits/stdc++.h>\n/**\n * Đọc một số nguyên và một ký tự, sau đó trả về chúng dưới dạng chuỗi định dạng được phân tách bằng dấu phẩy.\n * \n * Tham số:\n * - integer_value (int): Số nguyên đầu vào.\n * - char_value (char): Ký tự đầu vào.\n * \n * Trả về:\n * - char*: Một chuỗi chứa số nguyên và ký tự được phân tách bằng dấu phẩy.\n * \n * Ví dụ:\n * process_integer_and_char(234, 'H') trả về \"234,H\"\n */\nchar* process_integer_and_char(int integer_value, char char_value)"
    },
    "prompt_bertscore": {
      "es": "0.9969416880232058",
      "arb": "1",
      "sw": "0.9879729304283376",
      "tr": "0.990071063143209",
      "vi": "0.9836644388333098"
    },
    "canonical_solution": "{\n    // Allocate memory for the resulting string\n    // 12 bytes for the integer, 2 for the char and comma, 1 for null-terminator\n    char* result = (char*)malloc(15 * sizeof(char));\n    if (result == NULL) {\n        fprintf(stderr, \"Memory allocation failed\\n\");\n        exit(EXIT_FAILURE);\n    }\n    // Format the string\n    sprintf(result, \"%d,%c\", integer_value, char_value);\n    return result;\n}",
    "instruction": {
      "en": "char* process_integer_and_char(int integer_value, char char_value)\n{\n    // Allocate memory for the resulting string\n    // 12 bytes for the integer, 2 for the char and comma, 1 for null-terminator\n    char* result = (char*)malloc(15 * sizeof(char));\n    if (result == NULL) {\n        fprintf(stderr, \"Memory allocation failed\\n\");\n        exit(EXIT_FAILURE);\n    }\n    // Format the string\n    sprintf(result, \"%d,%c\", integer_value, char_value);\n    return result;\n}\n\nProvide a concise natural language description (docstring) of the CPP code in English using at most 500 characters.",
      "es": "char* process_integer_and_char(int integer_value, char char_value)\n{\n    // Allocate memory for the resulting string\n    // 12 bytes for the integer, 2 for the char and comma, 1 for null-terminator\n    char* result = (char*)malloc(15 * sizeof(char));\n    if (result == NULL) {\n        fprintf(stderr, \"Memory allocation failed\\n\");\n        exit(EXIT_FAILURE);\n    }\n    // Format the string\n    sprintf(result, \"%d,%c\", integer_value, char_value);\n    return result;\n}\n\nProporcione una descripción concisa en lenguaje natural (docstring) del código CPP en español utilizando como máximo 500 caracteres.",
      "arb": "char* process_integer_and_char(int integer_value, char char_value)\n{\n    // Allocate memory for the resulting string\n    // 12 bytes for the integer, 2 for the char and comma, 1 for null-terminator\n    char* result = (char*)malloc(15 * sizeof(char));\n    if (result == NULL) {\n        fprintf(stderr, \"Memory allocation failed\\n\");\n        exit(EXIT_FAILURE);\n    }\n    // Format the string\n    sprintf(result, \"%d,%c\", integer_value, char_value);\n    return result;\n}\n\nيرجى تقديم وصف موجز بلغة طبيعية (docstring) للشفرة البرمجية بلغة C++ باللغة العربية الفصحى، بحيث لا يتجاوز 500 حرف.",
      "sw": "char* process_integer_and_char(int integer_value, char char_value)\n{\n    // Allocate memory for the resulting string\n    // 12 bytes for the integer, 2 for the char and comma, 1 for null-terminator\n    char* result = (char*)malloc(15 * sizeof(char));\n    if (result == NULL) {\n        fprintf(stderr, \"Memory allocation failed\\n\");\n        exit(EXIT_FAILURE);\n    }\n    // Format the string\n    sprintf(result, \"%d,%c\", integer_value, char_value);\n    return result;\n}\n\nToa maelezo mafupi ya lugha ya asili (docstring) ya msimbo wa CPP kwa Kiswahili kwa kutumia herufi zisizozidi 500.",
      "tr": "char* process_integer_and_char(int integer_value, char char_value)\n{\n    // Allocate memory for the resulting string\n    // 12 bytes for the integer, 2 for the char and comma, 1 for null-terminator\n    char* result = (char*)malloc(15 * sizeof(char));\n    if (result == NULL) {\n        fprintf(stderr, \"Memory allocation failed\\n\");\n        exit(EXIT_FAILURE);\n    }\n    // Format the string\n    sprintf(result, \"%d,%c\", integer_value, char_value);\n    return result;\n}\n\nAşağıdaki CPP kodunun Türkçe'de en fazla 500 karakter kullanarak kısa bir doğal dil açıklamasını (docstring) sağlayın.",
      "vi": "char* process_integer_and_char(int integer_value, char char_value)\n{\n    // Allocate memory for the resulting string\n    // 12 bytes for the integer, 2 for the char and comma, 1 for null-terminator\n    char* result = (char*)malloc(15 * sizeof(char));\n    if (result == NULL) {\n        fprintf(stderr, \"Memory allocation failed\\n\");\n        exit(EXIT_FAILURE);\n    }\n    // Format the string\n    sprintf(result, \"%d,%c\", integer_value, char_value);\n    return result;\n}\n\nCung cấp mô tả ngắn gọn bằng ngôn ngữ tự nhiên (docstring) cho mã CPP bằng tiếng Việt với tối đa 500 ký tự."
    },
    "instruction_bertscore": {
      "es": "0.9695565173899258",
      "arb": "0.8562400699437135",
      "sw": "0.9164634110608243",
      "tr": "0.8890214321385683",
      "vi": "0.9171611995893999"
    },
    "level": "",
    "test": "int main() {\n    // Test 1\n    char* output1 = process_integer_and_char(234, 'H');\n    assert(strcmp(output1, \"234,H\") == 0);\n    free(output1); // Don't forget to free the allocated memory\n\n    // Additional tests can be added here with different input values\n    // Test 2\n    char* output2 = process_integer_and_char(123, 'A');\n    assert(strcmp(output2, \"123,A\") == 0);\n    free(output2);\n\n    // Test 3\n    char* output3 = process_integer_and_char(0, 'Z');\n    assert(strcmp(output3, \"0,Z\") == 0);\n    free(output3);\n\n    return 0;\n}",
    "entry_point": "process_integer_and_char",
    "signature": "char* process_integer_and_char(int integer_value, char char_value)",
    "docstring": {
      "en": "Reads an integer and a character, then returns them as a formatted string separated by a comma.\n\nParameters:\n- integer_value (int): The input integer.\n- char_value (char): The input character.\n\nReturns:\n- char*: A string containing the integer and character separated by a comma.\n\nExample:\nprocess_integer_and_char(234, 'H') returns \"234,H\"",
      "es": "Lee un entero y un carácter, luego los devuelve como una cadena formateada separada por una coma.\n\nParámetros:\n- integer_value (int): El entero de entrada.\n- char_value (char): El carácter de entrada.\n\nDevuelve:\n- char*: Una cadena que contiene el entero y el carácter separados por una coma.\n\nEjemplo:\nprocess_integer_and_char(234, 'H') devuelve \"234,H\"",
      "arb": "يقرأ عددًا صحيحًا وحرفًا، ثم يعيدهما كسلسلة منسقة مفصولة بفاصلة.\n\nالمعلمات:\n- integer_value (int): العدد الصحيح المدخل.\n- char_value (char): الحرف المدخل.\n\nالقيم المعادة:\n- char*: سلسلة تحتوي على العدد الصحيح والحرف مفصولين بفاصلة.\n\nمثال:\nprocess_integer_and_char(234, 'H') يعيد \"234,H\"",
      "sw": "Husoma nambari kamili na herufi, kisha inazirejesha kama kamba iliyopangwa iliyotenganishwa na koma.\n\nVigezo:\n- integer_value (int): Nambari kamili ya ingizo.\n- char_value (char): Herufi ya ingizo.\n\nInarejesha:\n- char*: Kamba inayojumuisha nambari kamili na herufi iliyotenganishwa na koma.\n\nMfano:\nprocess_integer_and_char(234, 'H') inarejesha \"234,H\"",
      "tr": "Bir tam sayı ve bir karakter okur, ardından bunları virgülle ayrılmış biçimlendirilmiş bir dize olarak döndürür.\n\nParametreler:\n- integer_value (int): Girdi tam sayısı.\n- char_value (char): Girdi karakteri.\n\nDöndürür:\n- char*: Tam sayı ve karakteri virgülle ayırarak içeren bir dize.\n\nÖrnek:\nprocess_integer_and_char(234, 'H') \"234,H\" döndürür.",
      "vi": "Đọc một số nguyên và một ký tự, sau đó trả về chúng dưới dạng một chuỗi định dạng được phân tách bằng dấu phẩy.\n\nTham số:\n- integer_value (int): Số nguyên đầu vào.\n- char_value (char): Ký tự đầu vào.\n\nTrả về:\n- char*: Một chuỗi chứa số nguyên và ký tự được phân tách bằng dấu phẩy.\n\nVí dụ:\nprocess_integer_and_char(234, 'H') trả về \"234,H\""
    },
    "docstring_bertscore": {
      "es": "0.9893629458348197",
      "arb": "0.9913494482755496",
      "sw": "0.9831102600702224",
      "tr": "0.9731684122386642",
      "vi": "0.9784303296626594"
    }
  },
  {
    "task_id": "CPP/25",
    "prompt": {
      "en": "#include <bits/stdc++.h>\n/*\nShifts all characters by 5 positions in alphabetical order. Only letters are replaced,\nand all letters are in uppercase.\n\nParameters:\ntext (std::string&): The input text to be processed, modified in place.\n\nReturns:\nstd::string&: The transformed text with characters shifted by 5 positions.\n\n>>> shift_characters(\"NS BFW, JAJSYX TK NRUTWYFSHJ FWJ YMJ WJXZQY TK YWNANFQ HFZXJX\")\n\"IN WAR, EVENTS OF IMPORTANCE ARE THE RESULT OF TRIVIAL CAUSES\"\n*/\nstd::string& shift_characters(std::string& text)",
      "es": "#include <bits/stdc++.h>\n/*\nDesplaza todos los caracteres 5 posiciones en orden alfabético. Solo se reemplazan las letras,\ny todas las letras están en mayúsculas.\n\nParámetros:\ntext (std::string&): El texto de entrada a procesar, modificado en su lugar.\n\nDevuelve:\nstd::string&: El texto transformado con caracteres desplazados 5 posiciones.\n\n>>> shift_characters(\"NS BFW, JAJSYX TK NRUTWYFSHJ FWJ YMJ WJXZQY TK YWNANFQ HFZXJX\")\n\"IN WAR, EVENTS OF IMPORTANCE ARE THE RESULT OF TRIVIAL CAUSES\"\n*/\nstd::string& shift_characters(std::string& text)",
      "arb": "#include <bits/stdc++.h>\n/*\nينقل جميع الأحرف بمقدار 5 مواقع في الترتيب الأبجدي. يتم استبدال الأحرف فقط،\nوجميع الأحرف تكون بحروف كبيرة.\n\nالمعلمات:\ntext (std::string&): النص المدخل ليتم معالجته، يتم تعديله في مكانه.\n\nيعيد:\nstd::string&: النص المحول مع الأحرف المنقولة بمقدار 5 مواقع.\n\n>>> shift_characters(\"NS BFW, JAJSYX TK NRUTWYFSHJ FWJ YMJ WJXZQY TK YWNANFQ HFZXJX\")\n\"IN WAR, EVENTS OF IMPORTANCE ARE THE RESULT OF TRIVIAL CAUSES\"\n*/\nstd::string& shift_characters(std::string& text)",
      "sw": "#include <bits/stdc++.h>\n/*\nInasogeza herufi zote kwa nafasi 5 katika mpangilio wa alfabeti. Ni herufi pekee zinazobadilishwa,\nna herufi zote ni za herufi kubwa.\n\nVigezo:\ntext (std::string&): Maandishi ya kuingiza yatakayoshughulikiwa, yanabadilishwa papo hapo.\n\nInarudisha:\nstd::string&: Maandishi yaliyobadilishwa na herufi zilizohamishwa kwa nafasi 5.\n\n>>> shift_characters(\"NS BFW, JAJSYX TK NRUTWYFSHJ FWJ YMJ WJXZQY TK YWNANFQ HFZXJX\")\n\"IN WAR, EVENTS OF IMPORTANCE ARE THE RESULT OF TRIVIAL CAUSES\"\n*/\nstd::string& shift_characters(std::string& text)",
      "tr": "#include <bits/stdc++.h>\n/*\nAlfabetik sırada tüm karakterleri 5 pozisyon kaydırır. Sadece harfler değiştirilir\nve tüm harfler büyük harfle yazılır.\n\nParametreler:\ntext (std::string&): İşlenecek giriş metni, yerinde değiştirilir.\n\nDöndürür:\nstd::string&: Karakterleri 5 pozisyon kaydırılmış dönüştürülmüş metin.\n\n>>> shift_characters(\"NS BFW, JAJSYX TK NRUTWYFSHJ FWJ YMJ WJXZQY TK YWNANFQ HFZXJX\")\n\"IN WAR, EVENTS OF IMPORTANCE ARE THE RESULT OF TRIVIAL CAUSES\"\n*/\nstd::string& shift_characters(std::string& text)",
      "vi": "#include <bits/stdc++.h>\n/*\nDịch chuyển tất cả các ký tự 5 vị trí trong thứ tự bảng chữ cái. Chỉ các chữ cái được thay thế,\nvà tất cả các chữ cái đều ở dạng chữ hoa.\n\nTham số:\ntext (std::string&): Văn bản đầu vào cần được xử lý, được sửa đổi tại chỗ.\n\nTrả về:\nstd::string&: Văn bản đã được biến đổi với các ký tự dịch chuyển 5 vị trí.\n\n>>> shift_characters(\"NS BFW, JAJSYX TK NRUTWYFSHJ FWJ YMJ WJXZQY TK YWNANFQ HFZXJX\")\n\"IN WAR, EVENTS OF IMPORTANCE ARE THE RESULT OF TRIVIAL CAUSES\"\n*/\nstd::string& shift_characters(std::string& text)"
    },
    "prompt_bertscore": {
      "es": "0.9813515866765395",
      "arb": "0.9954245491728614",
      "sw": "0.986608935601771",
      "tr": "0.9695320858530585",
      "vi": "0.9721150753280362"
    },
    "canonical_solution": "{\n    size_t len = text.length();\n    for (size_t i = 0; i < len; ++i) {\n        if ('A' <= text[i] && text[i] <= 'E') {\n            text[i] = text[i] + 'V' - 'A';\n        } else if ('F' <= text[i] && text[i] <= 'Z') {\n            text[i] = text[i] + 'A' - 'F';\n        }\n    }\n    return text;\n}",
    "instruction": {
      "en": "std::string& shift_characters(std::string& text)\n{\n    size_t len = text.length();\n    for (size_t i = 0; i < len; ++i) {\n        if ('A' <= text[i] && text[i] <= 'E') {\n            text[i] = text[i] + 'V' - 'A';\n        } else if ('F' <= text[i] && text[i] <= 'Z') {\n            text[i] = text[i] + 'A' - 'F';\n        }\n    }\n    return text;\n}\n\nProvide a concise natural language description (docstring) of the CPP code in English using at most 500 characters.",
      "es": "std::string& shift_characters(std::string& text)\n{\n    size_t len = text.length();\n    for (size_t i = 0; i < len; ++i) {\n        if ('A' <= text[i] && text[i] <= 'E') {\n            text[i] = text[i] + 'V' - 'A';\n        } else if ('F' <= text[i] && text[i] <= 'Z') {\n            text[i] = text[i] + 'A' - 'F';\n        }\n    }\n    return text;\n}\n\nProporcione una descripción concisa en lenguaje natural (docstring) del código CPP en español utilizando como máximo 500 caracteres.",
      "arb": "std::string& shift_characters(std::string& text)\n{\n    size_t len = text.length();\n    for (size_t i = 0; i < len; ++i) {\n        if ('A' <= text[i] && text[i] <= 'E') {\n            text[i] = text[i] + 'V' - 'A';\n        } else if ('F' <= text[i] && text[i] <= 'Z') {\n            text[i] = text[i] + 'A' - 'F';\n        }\n    }\n    return text;\n}\n\nيرجى تقديم وصف موجز بلغة طبيعية (docstring) للكود المكتوب بلغة C++ باللغة العربية الفصحى، بحيث لا يتجاوز 500 حرف.",
      "sw": "std::string& shift_characters(std::string& text)\n{\n    size_t len = text.length();\n    for (size_t i = 0; i < len; ++i) {\n        if ('A' <= text[i] && text[i] <= 'E') {\n            text[i] = text[i] + 'V' - 'A';\n        } else if ('F' <= text[i] && text[i] <= 'Z') {\n            text[i] = text[i] + 'A' - 'F';\n        }\n    }\n    return text;\n}\n\nToa maelezo mafupi ya lugha ya asili (docstring) ya msimbo wa CPP kwa Kiswahili kwa kutumia herufi zisizozidi 500.",
      "tr": "std::string& shift_characters(std::string& text)\n{\n    size_t len = text.length();\n    for (size_t i = 0; i < len; ++i) {\n        if ('A' <= text[i] && text[i] <= 'E') {\n            text[i] = text[i] + 'V' - 'A';\n        } else if ('F' <= text[i] && text[i] <= 'Z') {\n            text[i] = text[i] + 'A' - 'F';\n        }\n    }\n    return text;\n}\n\nAşağıdaki CPP kodunun işlevini açıklayan, en fazla 500 karakter uzunluğunda, özlü bir doğal dil açıklaması (docstring) sağlayın.",
      "vi": "std::string& shift_characters(std::string& text)\n{\n    size_t len = text.length();\n    for (size_t i = 0; i < len; ++i) {\n        if ('A' <= text[i] && text[i] <= 'E') {\n            text[i] = text[i] + 'V' - 'A';\n        } else if ('F' <= text[i] && text[i] <= 'Z') {\n            text[i] = text[i] + 'A' - 'F';\n        }\n    }\n    return text;\n}\n\nCung cấp mô tả ngắn gọn bằng ngôn ngữ tự nhiên (docstring) cho mã CPP bằng tiếng Việt, sử dụng tối đa 500 ký tự."
    },
    "instruction_bertscore": {
      "es": "0.9695565173899258",
      "arb": "0.8366737856294908",
      "sw": "0.9108155548064784",
      "tr": "0.8500634596150526",
      "vi": "0.9209653686469801"
    },
    "level": "",
    "test": "int main()\n{\n    std::string test1 = \"NS BFW, JAJSYX TK NRUTWYFSHJ FWJ YMJ WJXZQY TK YWNANFQ HFZXJX\";\n    std::string test2 = \"N BTZQI WFYMJW GJ KNWXY NS F QNYYQJ NGJWNFS ANQQFLJ YMFS XJHTSI NS WTRJ\";\n    std::string test3 = \"IFSLJW PSTBX KZQQ BJQQ YMFY HFJXFW NX RTWJ IFSLJWTZX YMFS MJ\";\n\n    assert(shift_characters(test1) == \"IN WAR, EVENTS OF IMPORTANCE ARE THE RESULT OF TRIVIAL CAUSES\");\n    assert(shift_characters(test2) == \"I WOULD RATHER BE FIRST IN A LITTLE IBERIAN VILLAGE THAN SECOND IN ROME\");\n    assert(shift_characters(test3) == \"DANGER KNOWS FULL WELL THAT CAESAR IS MORE DANGEROUS THAN HE\");\n    return 0;\n}",
    "entry_point": "shift_characters",
    "signature": "std::string& shift_characters(std::string& text)",
    "docstring": {
      "en": "Shifts all characters by 5 positions in alphabetical order. Only letters are replaced, and all letters are in uppercase.\n\nParameters:\ntext (std::string&): The input text to be processed, modified in place.\n\nReturns:\nstd::string&: The transformed text with characters shifted by 5 positions.\n\n>>> shift_characters(\"NS BFW, JAJSYX TK NRUTWYFSHJ FWJ YMJ WJXZQY TK YWNANFQ HFZXJX\")\n\"IN WAR, EVENTS OF IMPORTANCE ARE THE RESULT OF TRIVIAL CAUSES\"\n",
      "es": "Desplaza todos los caracteres 5 posiciones en orden alfabético. Solo se reemplazan letras, y todas las letras están en mayúsculas.\n\nParámetros:\ntext (std::string&): El texto de entrada a procesar, modificado en su lugar.\n\nDevuelve:\nstd::string&: El texto transformado con caracteres desplazados 5 posiciones.\n\n>>> shift_characters(\"NS BFW, JAJSYX TK NRUTWYFSHJ FWJ YMJ WJXZQY TK YWNANFQ HFZXJX\")\n\"IN WAR, EVENTS OF IMPORTANCE ARE THE RESULT OF TRIVIAL CAUSES\"",
      "arb": "ينقل جميع الأحرف بمقدار 5 مواقع في الترتيب الأبجدي. يتم استبدال الأحرف فقط، وجميع الأحرف تكون بأحرف كبيرة.\n\nالمعلمات:\ntext (std::string&): النص المدخل ليتم معالجته، يتم تعديله في مكانه.\n\nالقيم المعادة:\nstd::string&: النص المحول مع الأحرف المنقولة بمقدار 5 مواقع.\n\n>>> shift_characters(\"NS BFW, JAJSYX TK NRUTWYFSHJ FWJ YMJ WJXZQY TK YWNANFQ HFZXJX\")\n\"IN WAR, EVENTS OF IMPORTANCE ARE THE RESULT OF TRIVIAL CAUSES\"",
      "sw": "Hubadilisha herufi zote kwa nafasi 5 katika mpangilio wa alfabeti. Ni herufi pekee ndizo hubadilishwa, na herufi zote ziko katika herufi kubwa.\n\nVigezo:\ntext (std::string&): Maandishi ya ingizo yatakayoshughulikiwa, yanabadilishwa papo hapo.\n\nInarejesha:\nstd::string&: Maandishi yaliyobadilishwa na herufi zilizohamishwa kwa nafasi 5.\n\n>>> shift_characters(\"NS BFW, JAJSYX TK NRUTWYFSHJ FWJ YMJ WJXZQY TK YWNANFQ HFZXJX\")\n\"IN WAR, EVENTS OF IMPORTANCE ARE THE RESULT OF TRIVIAL CAUSES\"",
      "tr": "Alfabetik sırada tüm karakterleri 5 pozisyon kaydırır. Yalnızca harfler değiştirilir ve tüm harfler büyük harfle yazılır.\n\nParametreler:\ntext (std::string&): İşlenecek giriş metni, yerinde değiştirilir.\n\nDöndürür:\nstd::string&: Karakterleri 5 pozisyon kaydırılmış dönüştürülmüş metin.\n\n>>> shift_characters(\"NS BFW, JAJSYX TK NRUTWYFSHJ FWJ YMJ WJXZQY TK YWNANFQ HFZXJX\")\n\"IN WAR, EVENTS OF IMPORTANCE ARE THE RESULT OF TRIVIAL CAUSES\"",
      "vi": "Dịch chuyển tất cả các ký tự lên 5 vị trí theo thứ tự bảng chữ cái. Chỉ các chữ cái được thay thế, và tất cả các chữ cái đều ở dạng chữ hoa.\n\nTham số:\ntext (std::string&): Văn bản đầu vào cần được xử lý, được sửa đổi tại chỗ.\n\nTrả về:\nstd::string&: Văn bản đã được biến đổi với các ký tự dịch chuyển lên 5 vị trí.\n\n>>> shift_characters(\"NS BFW, JAJSYX TK NRUTWYFSHJ FWJ YMJ WJXZQY TK YWNANFQ HFZXJX\")\n\"IN WAR, EVENTS OF IMPORTANCE ARE THE RESULT OF TRIVIAL CAUSES\""
    },
    "docstring_bertscore": {
      "es": "0.9703814293623637",
      "arb": "0.9874302722273502",
      "sw": "0.9788559945692172",
      "tr": "0.9813962785122724",
      "vi": "0.9829457941147255"
    }
  },
  {
    "task_id": "CPP/26",
    "prompt": {
      "en": "#include <cassert>\n#include <cmath>\n#include <cstdio>\n#include <cstring>\n/**\n * Classify the integer x based on the following method:\n * If x is a single-digit number, x belongs to its own class.\n * Otherwise, sum the digits of x, get a new x, and iterate until \n * the class is determined.\n *\n * Parameters:\n * - x (const char*): The integer to be classified in string form.\n *\n * Returns:\n * int: The class to which the integer x belongs.\n *\n * Usage:\n * >>> classify_integer(\"24\")\n * 6\n */\nint classify_integer(const char *x)",
      "es": "#include <cassert>\n#include <cmath>\n#include <cstdio>\n#include <cstring>\n/**\n * Clasificar el entero x basado en el siguiente método:\n * Si x es un número de un solo dígito, x pertenece a su propia clase.\n * De lo contrario, suma los dígitos de x, obtiene un nuevo x, e itera hasta \n * que se determine la clase.\n *\n * Parámetros:\n * - x (const char*): El entero a clasificar en forma de cadena.\n *\n * Devuelve:\n * int: La clase a la que pertenece el entero x.\n *\n * Uso:\n * >>> classify_integer(\"24\")\n * 6\n */\nint classify_integer(const char *x)",
      "arb": "#include <cassert>\n#include <cmath>\n#include <cstdio>\n#include <cstring>\n/**\n * صنف العدد الصحيح x بناءً على الطريقة التالية:\n * إذا كان x رقمًا مكونًا من رقم واحد، فإن x ينتمي إلى فئته الخاصة.\n * خلاف ذلك، اجمع أرقام x، واحصل على x جديد، وكرر حتى يتم تحديد الفئة.\n *\n * المعلمات:\n * - x (const char*): العدد الصحيح الذي سيتم تصنيفه في شكل سلسلة.\n *\n * يعيد:\n * int: الفئة التي ينتمي إليها العدد الصحيح x.\n *\n * الاستخدام:\n * >>> classify_integer(\"24\")\n * 6\n */\nint classify_integer(const char *x)",
      "sw": "#include <cassert>\n#include <cmath>\n#include <cstdio>\n#include <cstring>\n/**\n * Ainisha nambari x kulingana na njia ifuatayo:\n * Ikiwa x ni nambari ya tarakimu moja, x inamiliki darasa lake lenyewe.\n * Vinginevyo, jumlisha tarakimu za x, pata x mpya, na rudia hadi \n * darasa litakapobainishwa.\n *\n * Vigezo:\n * - x (const char*): Nambari inayopaswa kuainishwa katika umbo la kamba.\n *\n * Inarudisha:\n * int: Darasa ambalo nambari x inamiliki.\n *\n * Matumizi:\n * >>> classify_integer(\"24\")\n * 6\n */\nint classify_integer(const char *x)",
      "tr": "#include <cassert>\n#include <cmath>\n#include <cstdio>\n#include <cstring>\n/**\n * x tam sayısını aşağıdaki yönteme göre sınıflandır:\n * Eğer x tek basamaklı bir sayı ise, x kendi sınıfına aittir.\n * Aksi takdirde, x'in basamaklarını topla, yeni bir x elde et ve \n * sınıf belirlenene kadar yinele.\n *\n * Parametreler:\n * - x (const char*): Sınıflandırılacak tam sayı, string formunda.\n *\n * Döndürür:\n * int: x tam sayısının ait olduğu sınıf.\n *\n * Kullanım:\n * >>> classify_integer(\"24\")\n * 6\n */\nint classify_integer(const char *x)",
      "vi": "#include <cassert>\n#include <cmath>\n#include <cstdio>\n#include <cstring>\n/**\n * Phân loại số nguyên x dựa trên phương pháp sau:\n * Nếu x là một số có một chữ số, x thuộc về lớp của chính nó.\n * Ngược lại, tổng các chữ số của x, lấy một x mới, và lặp lại cho đến khi \n * lớp được xác định.\n *\n * Tham số:\n * - x (const char*): Số nguyên cần được phân loại dưới dạng chuỗi.\n *\n * Trả về:\n * int: Lớp mà số nguyên x thuộc về.\n *\n * Sử dụng:\n * >>> classify_integer(\"24\")\n * 6\n */\nint classify_integer(const char *x)"
    },
    "prompt_bertscore": {
      "es": "0.9935544441354178",
      "arb": "0.9772115336446293",
      "sw": "0.968088837504459",
      "tr": "0.9894561034835251",
      "vi": "0.9820062724124305"
    },
    "canonical_solution": "{\n    int n = 0, i, a, t;\n    for (i = 0; i < std::strlen(x); i++)\n        n += x[i] - '0';\n    while (n > 9) {\n        t = n;\n        a = 0;\n        while (t) {\n            a += t % 10;\n            t /= 10;\n        }\n        n = a;\n    }\n    return n;\n}",
    "instruction": {
      "en": "int classify_integer(const char *x)\n{\n    int n = 0, i, a, t;\n    for (i = 0; i < std::strlen(x); i++)\n        n += x[i] - '0';\n    while (n > 9) {\n        t = n;\n        a = 0;\n        while (t) {\n            a += t % 10;\n            t /= 10;\n        }\n        n = a;\n    }\n    return n;\n}\n\nProvide a concise natural language description (docstring) of the CPP code in English using at most 500 characters.",
      "es": "int classify_integer(const char *x)\n{\n    int n = 0, i, a, t;\n    for (i = 0; i < std::strlen(x); i++)\n        n += x[i] - '0';\n    while (n > 9) {\n        t = n;\n        a = 0;\n        while (t) {\n            a += t % 10;\n            t /= 10;\n        }\n        n = a;\n    }\n    return n;\n}\n\nProporcione una descripción concisa en lenguaje natural (docstring) del código CPP en español utilizando como máximo 500 caracteres.",
      "arb": "int classify_integer(const char *x)\n{\n    int n = 0, i, a, t;\n    for (i = 0; i < std::strlen(x); i++)\n        n += x[i] - '0';\n    while (n > 9) {\n        t = n;\n        a = 0;\n        while (t) {\n            a += t % 10;\n            t /= 10;\n        }\n        n = a;\n    }\n    return n;\n}\n\nيرجى تقديم وصف موجز بلغة طبيعية (docstring) للشفرة البرمجية بلغة C++ باللغة العربية الفصحى باستخدام 500 حرف كحد أقصى.",
      "sw": "int classify_integer(const char *x)\n{\n    int n = 0, i, a, t;\n    for (i = 0; i < std::strlen(x); i++)\n        n += x[i] - '0';\n    while (n > 9) {\n        t = n;\n        a = 0;\n        while (t) {\n            a += t % 10;\n            t /= 10;\n        }\n        n = a;\n    }\n    return n;\n}\n\nToa maelezo mafupi ya lugha ya asili (docstring) ya msimbo wa CPP kwa Kiswahili kwa kutumia herufi zisizozidi 500.",
      "tr": "int classify_integer(const char *x)\n{\n    int n = 0, i, a, t;\n    for (i = 0; i < std::strlen(x); i++)\n        n += x[i] - '0';\n    while (n > 9) {\n        t = n;\n        a = 0;\n        while (t) {\n            a += t % 10;\n            t /= 10;\n        }\n        n = a;\n    }\n    return n;\n}\n\nAşağıdaki CPP kodunun doğal dilde kısa bir açıklamasını (docstring) Türkçe olarak en fazla 500 karakter kullanarak sağlayın.",
      "vi": "int classify_integer(const char *x)\n{\n    int n = 0, i, a, t;\n    for (i = 0; i < std::strlen(x); i++)\n        n += x[i] - '0';\n    while (n > 9) {\n        t = n;\n        a = 0;\n        while (t) {\n            a += t % 10;\n            t /= 10;\n        }\n        n = a;\n    }\n    return n;\n}\n\nCung cấp mô tả ngắn gọn bằng ngôn ngữ tự nhiên (docstring) cho mã CPP bằng tiếng Việt với tối đa 500 ký tự."
    },
    "instruction_bertscore": {
      "es": "0.9695565173899258",
      "arb": "0.8806972301301582",
      "sw": "0.9164634110608243",
      "tr": "0.8824406089845014",
      "vi": "0.9171611995893999"
    },
    "level": "",
    "test": "int main() {\n    assert(classify_integer(\"24\") == 6);\n    assert(classify_integer(\"39\") == 3);\n    assert(classify_integer(\"123456789\") == 9);\n    assert(classify_integer(\"123456789012345678901234567890\") == 9);\n    assert(classify_integer(\"12345\") == 6);\n    assert(classify_integer(\"999999999\") == 9);\n    // std::printf(\"All tests passed successfully!\\n\");\n    return 0;\n}",
    "entry_point": "classify_integer",
    "signature": "int classify_integer(const char *x)",
    "docstring": {
      "en": "Classify the integer x based on the following method:\nIf x is a single-digit number, x belongs to its own class.\nOtherwise, sum the digits of x, get a new x, and iterate until the class is determined.\n\nParameters:\n- x (const char*): The integer to be classified in string form.\n\nReturns:\nint: The class to which the integer x belongs.\n\nUsage:\n>>> classify_integer(\"24\")\n6",
      "es": "Clasificar el entero x basado en el siguiente método:\nSi x es un número de un solo dígito, x pertenece a su propia clase.\nDe lo contrario, suma los dígitos de x, obtiene un nuevo x, e itera hasta que se determine la clase.\n\nParámetros:\n- x (const char*): El entero a clasificar en forma de cadena.\n\nDevuelve:\nint: La clase a la que pertenece el entero x.\n\nUso:\n>>> classify_integer(\"24\")\n6",
      "arb": "تصنيف العدد الصحيح x بناءً على الطريقة التالية:\nإذا كان x رقمًا مكونًا من رقم واحد، فإن x ينتمي إلى فئته الخاصة.\nخلاف ذلك، اجمع أرقام x، واحصل على x جديد، وكرر حتى يتم تحديد الفئة.\n\nالمعلمات:\n- x (const char*): العدد الصحيح الذي سيتم تصنيفه في شكل سلسلة.\n\nالقيم المعادة:\nint: الفئة التي ينتمي إليها العدد الصحيح x.\n\nالاستخدام:\n>>> classify_integer(\"24\")\n6",
      "sw": "Ainisha nambari x kulingana na njia ifuatayo: \nIkiwa x ni nambari ya tarakimu moja, x ni ya darasa lake lenyewe.  \nVinginevyo, jumlisha tarakimu za x, pata x mpya, na rudia mpaka darasa litakapobainishwa.  \n\nParameters:  \n- x (const char*): Nambari ya kuhesabiwa katika mfumo wa herufi.  \n\nReturns:  \nint: Darasa ambalo nambari x inahusishwa.  \n\nUsage:  \n>>> classify_integer(\"24\")  \n6",
      "tr": "Tam sayı x'i aşağıdaki yönteme göre sınıflandırın:\nEğer x tek basamaklı bir sayı ise, x kendi sınıfına aittir.\nAksi takdirde, x'in basamaklarını toplayın, yeni bir x elde edin ve sınıf belirlenene kadar yineleyin.\n\nParametreler:\n- x (const char*): Sınıflandırılacak tam sayının string formu.\n\nDöndürülen:\nint: Tam sayı x'in ait olduğu sınıf.\n\nKullanım:\n>>> classify_integer(\"24\")\n6",
      "vi": "Phân loại số nguyên x dựa trên phương pháp sau:\nNếu x là một số có một chữ số, x thuộc về lớp của chính nó.\nNgược lại, tổng các chữ số của x, lấy một x mới, và lặp lại cho đến khi xác định được lớp.\n\nTham số:\n- x (const char*): Số nguyên cần được phân loại dưới dạng chuỗi.\n\nTrả về:\nint: Lớp mà số nguyên x thuộc về.\n\nSử dụng:\n>>> classify_integer(\"24\")\n6"
    },
    "docstring_bertscore": {
      "es": "0.9928475186093147",
      "arb": "0.9596561833080038",
      "sw": "0.9690956949059248",
      "tr": "0.9748281677025917",
      "vi": "0.9678880221892328"
    }
  },
  {
    "task_id": "CPP/27",
    "prompt": {
      "en": "#include <cassert>\n#include <cstdio>\n/**\n * Transforms the case of a given letter.\n * \n * If the input is a lowercase letter, it returns the uppercase version,\n * and if the input is an uppercase letter, it returns the lowercase version.\n * Non-alphabetic characters are returned unchanged.\n *\n * Usage:\n *   char result = transform_letter_case('b'); // result will be 'B'\n *   char result = transform_letter_case('B'); // result will be 'b'\n *\n * @param letter The input letter to be transformed.\n * @return The letter with its case reversed if it's alphabetic, otherwise the original letter.\n */\nchar transform_letter_case(char letter)",
      "es": "#include <cassert>\n#include <cstdio>\n/**\n * Transforma el caso de una letra dada.\n * \n * Si la entrada es una letra minúscula, devuelve la versión en mayúscula,\n * y si la entrada es una letra mayúscula, devuelve la versión en minúscula.\n * Los caracteres no alfabéticos se devuelven sin cambios.\n *\n * Uso:\n *   char result = transform_letter_case('b'); // result será 'B'\n *   char result = transform_letter_case('B'); // result será 'b'\n *\n * @param letter La letra de entrada a transformar.\n * @return La letra con su caso invertido si es alfabética, de lo contrario la letra original.\n */\nchar transform_letter_case(char letter)",
      "arb": "#include <cassert>\n#include <cstdio>\n/**\n * يحول حالة الحرف المعطى.\n * \n * إذا كان الإدخال حرفًا صغيرًا، فإنه يعيد النسخة الكبيرة،\n * وإذا كان الإدخال حرفًا كبيرًا، فإنه يعيد النسخة الصغيرة.\n * الأحرف غير الأبجدية تُعاد دون تغيير.\n *\n * الاستخدام:\n *   char result = transform_letter_case('b'); // النتيجة ستكون 'B'\n *   char result = transform_letter_case('B'); // النتيجة ستكون 'b'\n *\n * @param letter الحرف المدخل الذي سيتم تحويله.\n * @return الحرف مع عكس حالته إذا كان أبجديًا، وإلا الحرف الأصلي.\n */\nchar transform_letter_case(char letter)",
      "sw": "#include <cassert>\n#include <cstdio>\n/**\n * Hubadilisha herufi kubwa au ndogo ya herufi iliyotolewa.\n * \n * Ikiwa ingizo ni herufi ndogo, inarudisha toleo la herufi kubwa,\n * na ikiwa ingizo ni herufi kubwa, inarudisha toleo la herufi ndogo.\n * Herufi zisizo za alfabeti zinarudishwa bila kubadilishwa.\n *\n * Matumizi:\n *   char result = transform_letter_case('b'); // result itakuwa 'B'\n *   char result = transform_letter_case('B'); // result itakuwa 'b'\n *\n * @param letter Herufi ya ingizo inayopaswa kubadilishwa.\n * @return Herufi ikiwa imebadilishwa herufi kubwa au ndogo ikiwa ni ya alfabeti, vinginevyo herufi ya asili.\n */\nchar transform_letter_case(char letter)",
      "tr": "#include <cassert>\n#include <cstdio>\n/**\n * Belirtilen bir harfin büyük/küçük harf durumunu değiştirir.\n * \n * Eğer giriş küçük harf ise, büyük harf versiyonunu döndürür,\n * ve eğer giriş büyük harf ise, küçük harf versiyonunu döndürür.\n * Alfabetik olmayan karakterler değişmeden döndürülür.\n *\n * Kullanım:\n *   char result = transform_letter_case('b'); // result 'B' olacaktır\n *   char result = transform_letter_case('B'); // result 'b' olacaktır\n *\n * @param letter Dönüştürülecek giriş harfi.\n * @return Eğer alfabetikse harfin büyük/küçük harf durumu değiştirilmiş hali, aksi takdirde orijinal harf.\n */\nchar transform_letter_case(char letter)",
      "vi": "#include <cassert>\n#include <cstdio>\n/**\n * Chuyển đổi chữ hoa/thường của một chữ cái cho trước.\n * \n * Nếu đầu vào là một chữ cái thường, nó trả về phiên bản chữ hoa,\n * và nếu đầu vào là một chữ cái hoa, nó trả về phiên bản chữ thường.\n * Các ký tự không phải chữ cái được trả về không thay đổi.\n *\n * Sử dụng:\n *   char result = transform_letter_case('b'); // result sẽ là 'B'\n *   char result = transform_letter_case('B'); // result sẽ là 'b'\n *\n * @param letter Chữ cái đầu vào cần được chuyển đổi.\n * @return Chữ cái với chữ hoa/thường được đảo ngược nếu nó là chữ cái, nếu không thì trả về chữ cái gốc.\n */\nchar transform_letter_case(char letter)"
    },
    "prompt_bertscore": {
      "es": "0.993002847567284",
      "arb": "0.976799574234363",
      "sw": "0.9868051824182335",
      "tr": "0.9661907255832897",
      "vi": "0.9690778181716317"
    },
    "canonical_solution": "{\n    if (letter >= 'A' && letter <= 'Z') {\n        return letter + 'a' - 'A';\n    }\n    else if (letter >= 'a' && letter <= 'z') {\n        return letter + 'A' - 'a';\n    }\n    else {\n        // Non-alphabetic characters are returned unchanged\n        return letter;\n    }\n}",
    "instruction": {
      "en": "char transform_letter_case(char letter)\n{\n    if (letter >= 'A' && letter <= 'Z') {\n        return letter + 'a' - 'A';\n    }\n    else if (letter >= 'a' && letter <= 'z') {\n        return letter + 'A' - 'a';\n    }\n    else {\n        // Non-alphabetic characters are returned unchanged\n        return letter;\n    }\n}\n\nProvide a concise natural language description (docstring) of the CPP code in English using at most 500 characters.",
      "es": "char transform_letter_case(char letter)\n{\n    if (letter >= 'A' && letter <= 'Z') {\n        return letter + 'a' - 'A';\n    }\n    else if (letter >= 'a' && letter <= 'z') {\n        return letter + 'A' - 'a';\n    }\n    else {\n        // Non-alphabetic characters are returned unchanged\n        return letter;\n    }\n}\n\nProporciona una descripción concisa en lenguaje natural (docstring) del código CPP en español utilizando como máximo 500 caracteres.",
      "arb": "char transform_letter_case(char letter)\n{\n    if (letter >= 'A' && letter <= 'Z') {\n        return letter + 'a' - 'A';\n    }\n    else if (letter >= 'a' && letter <= 'z') {\n        return letter + 'A' - 'a';\n    }\n    else {\n        // Non-alphabetic characters are returned unchanged\n        return letter;\n    }\n}\n\nيرجى تقديم وصف موجز بلغة طبيعية (docstring) لشفرة CPP باللغة العربية الفصحى باستخدام ما لا يزيد عن 500 حرف.",
      "sw": "char transform_letter_case(char letter)\n{\n    if (letter >= 'A' && letter <= 'Z') {\n        return letter + 'a' - 'A';\n    }\n    else if (letter >= 'a' && letter <= 'z') {\n        return letter + 'A' - 'a';\n    }\n    else {\n        // Non-alphabetic characters are returned unchanged\n        return letter;\n    }\n}\n\nToa maelezo mafupi ya lugha ya asili (docstring) ya msimbo wa CPP kwa Kiswahili kwa kutumia herufi zisizozidi 500.",
      "tr": "char transform_letter_case(char letter)\n{\n    if (letter >= 'A' && letter <= 'Z') {\n        return letter + 'a' - 'A';\n    }\n    else if (letter >= 'a' && letter <= 'z') {\n        return letter + 'A' - 'a';\n    }\n    else {\n        // Non-alphabetic characters are returned unchanged\n        return letter;\n    }\n}\n\nAşağıdaki CPP kodunun işlevini açıklayan en fazla 500 karakterlik özlü bir doğal dil açıklaması (docstring) sağlayın.",
      "vi": "char transform_letter_case(char letter)\n{\n    if (letter >= 'A' && letter <= 'Z') {\n        return letter + 'a' - 'A';\n    }\n    else if (letter >= 'a' && letter <= 'z') {\n        return letter + 'A' - 'a';\n    }\n    else {\n        // Non-alphabetic characters are returned unchanged\n        return letter;\n    }\n}\n\nCung cấp mô tả ngắn gọn bằng ngôn ngữ tự nhiên (docstring) cho mã CPP bằng tiếng Việt với tối đa 500 ký tự."
    },
    "instruction_bertscore": {
      "es": "0.9695565173899258",
      "arb": "0.9057093636012145",
      "sw": "0.9176812139269492",
      "tr": "0.8537198476691428",
      "vi": "0.9171611995893999"
    },
    "level": "",
    "test": "int main() {\n    assert(transform_letter_case('b') == 'B');\n    assert(transform_letter_case('B') == 'b');\n    // Additional test cases\n    assert(transform_letter_case('z') == 'Z');\n    assert(transform_letter_case('Z') == 'z');\n    assert(transform_letter_case('m') == 'M');\n    assert(transform_letter_case('M') == 'm');\n    assert(transform_letter_case('1') == '1'); // Non-alphabetic, should be unchanged\n    assert(transform_letter_case('!') == '!'); // Non-alphabetic, should be unchanged\n\n    // Uncomment the following line to print a success message (optional)\n    \n    return 0;\n}",
    "entry_point": "transform_letter_case",
    "signature": "char transform_letter_case(char letter)",
    "docstring": {
      "en": "Transforms the case of a given letter.\n\nIf the input is a lowercase letter, it returns the uppercase version,\nand if the input is an uppercase letter, it returns the lowercase version.\nNon-alphabetic characters are returned unchanged.\n\nUsage:\n  char result = transform_letter_case('b'); // result will be 'B'\n  char result = transform_letter_case('B'); // result will be 'b'\n\n@param letter The input letter to be transformed.\n@return The letter with its case reversed if it's alphabetic, otherwise the original letter.\n",
      "es": "Transforma el caso de una letra dada.\n\nSi la entrada es una letra minúscula, devuelve la versión en mayúscula,\ny si la entrada es una letra mayúscula, devuelve la versión en minúscula.\nLos caracteres no alfabéticos se devuelven sin cambios.\n\nUso:\n  char result = transform_letter_case('b'); // result será 'B'\n  char result = transform_letter_case('B'); // result será 'b'\n\n@param letter La letra de entrada a transformar.\n@return La letra con su caso invertido si es alfabética, de lo contrario, la letra original.",
      "arb": "يحوّل حالة حرف معين.\n\nإذا كان الإدخال حرفًا صغيرًا، فإنه يعيد النسخة الكبيرة،\nوإذا كان الإدخال حرفًا كبيرًا، فإنه يعيد النسخة الصغيرة.\nالحروف غير الأبجدية تُعاد دون تغيير.\n\nالاستخدام:\n  char result = transform_letter_case('b'); // النتيجة ستكون 'B'\n  char result = transform_letter_case('B'); // النتيجة ستكون 'b'\n\n@param letter الحرف المدخل الذي سيتم تحويله.\n@return الحرف مع عكس حالته إذا كان أبجديًا، وإلا الحرف الأصلي.",
      "sw": "Hubadilisha herufi ndogo kuwa kubwa au kubwa kuwa ndogo.\n\nIkiwa herufi ni ndogo, inarudisha toleo la herufi kubwa,\nna ikiwa herufi ni kubwa, inarudisha toleo la herufi ndogo.\nHerufi zisizo za alfabeti zinarudishwa bila kubadilishwa.\n\nMatumizi:\n  char result = transform_letter_case('b'); // result itakuwa 'B'\n  char result = transform_letter_case('B'); // result itakuwa 'b'\n\n@param letter Herufi ya kuingiza inayopaswa kubadilishwa.\n@return Herufi ikiwa imebadilishwa ukubwa wake ikiwa ni ya alfabeti, vinginevyo herufi asili.",
      "tr": "Verilen bir harfin büyük/küçük harf durumunu dönüştürür.\n\nEğer giriş küçük harfse, büyük harf versiyonunu döndürür,\nve eğer giriş büyük harfse, küçük harf versiyonunu döndürür.\nAlfabetik olmayan karakterler değişmeden döndürülür.\n\nKullanım:\n  char result = transform_letter_case('b'); // result 'B' olacak\n  char result = transform_letter_case('B'); // result 'b' olacak\n\n@param letter Dönüştürülecek giriş harfi.\n@return Eğer alfabetikse, harfin büyük/küçük harf durumu ters çevrilmiş hali, aksi takdirde orijinal harf.",
      "vi": "Chuyển đổi chữ hoa/thường của một chữ cái cho trước.\n\nNếu đầu vào là một chữ cái thường, nó sẽ trả về phiên bản chữ hoa,\nvà nếu đầu vào là một chữ cái hoa, nó sẽ trả về phiên bản chữ thường.\nCác ký tự không phải chữ cái được trả về không thay đổi.\n\nSử dụng:\n  char result = transform_letter_case('b'); // result sẽ là 'B'\n  char result = transform_letter_case('B'); // result sẽ là 'b'\n\n@param letter Chữ cái đầu vào cần được chuyển đổi.\n@return Chữ cái với chữ hoa/thường được đảo ngược nếu nó là chữ cái, nếu không thì trả về chữ cái gốc."
    },
    "docstring_bertscore": {
      "es": "0.9691956059875854",
      "arb": "0.9765536698226418",
      "sw": "0.9408734958469638",
      "tr": "0.9610885069856464",
      "vi": "0.9538430665766369"
    }
  },
  {
    "task_id": "CPP/28",
    "prompt": {
      "en": "#include <cassert>\n#include <cstdio>\n/**\n * Displays the ASCII information for a given character.\n * \n * @param character The input character for which ASCII information is to be displayed.\n * @return The corresponding ASCII code.\n * \n * Example:\n * ```cpp\n * int asciiCode = display_ascii_info('A');\n * std::cout << asciiCode; // Output: 65\n * ```\n */\nint display_ascii_info(char character)",
      "es": "#include <cassert>\n#include <cstdio>\n/**\n * Muestra la información ASCII para un carácter dado.\n * \n * @param character El carácter de entrada para el cual se mostrará la información ASCII.\n * @return El código ASCII correspondiente.\n * \n * Ejemplo:\n * ```cpp\n * int asciiCode = display_ascii_info('A');\n * std::cout << asciiCode; // Output: 65\n * ```\n */\nint display_ascii_info(char character)",
      "arb": "#include <cassert>\n#include <cstdio>\n/**\n * يعرض معلومات ASCII للحرف المعطى.\n * \n * @param character الحرف المدخل الذي سيتم عرض معلومات ASCII له.\n * @return الكود ASCII المقابل.\n * \n * مثال:\n * ```cpp\n * int asciiCode = display_ascii_info('A');\n * std::cout << asciiCode; // Output: 65\n * ```\n */\nint display_ascii_info(char character)",
      "sw": "#include <cassert>\n#include <cstdio>\n/**\n * Inaonyesha taarifa za ASCII kwa herufi iliyotolewa.\n * \n * @param character Herufi ya kuingiza ambayo taarifa za ASCII zinapaswa kuonyeshwa.\n * @return Nambari inayolingana ya ASCII.\n * \n * Mfano:\n * ```cpp\n * int asciiCode = display_ascii_info('A');\n * std::cout << asciiCode; // Output: 65\n * ```\n */\nint display_ascii_info(char character)",
      "tr": "#include <cassert>\n#include <cstdio>\n/**\n * Belirtilen bir karakter için ASCII bilgisini görüntüler.\n * \n * @param character ASCII bilgisinin görüntüleneceği giriş karakteri.\n * @return Karşılık gelen ASCII kodu.\n * \n * Örnek:\n * ```cpp\n * int asciiCode = display_ascii_info('A');\n * std::cout << asciiCode; // Çıktı: 65\n * ```\n */\nint display_ascii_info(char character)",
      "vi": "#include <cassert>\n#include <cstdio>\n/**\n * Hiển thị thông tin ASCII cho một ký tự nhất định.\n * \n * @param character Ký tự đầu vào mà thông tin ASCII cần được hiển thị.\n * @return Mã ASCII tương ứng.\n * \n * Ví dụ:\n * ```cpp\n * int asciiCode = display_ascii_info('A');\n * std::cout << asciiCode; // Output: 65\n * ```\n */\nint display_ascii_info(char character)"
    },
    "prompt_bertscore": {
      "es": "0.9939854720622636",
      "arb": "0.9872793131377637",
      "sw": "0.963471277036541",
      "tr": "0.9830441161533378",
      "vi": "0.9566691796380012"
    },
    "canonical_solution": "{\n    return character;\n}",
    "instruction": {
      "en": "int display_ascii_info(char character)\n{\n    return character;\n}\n\nProvide a concise natural language description (docstring) of the CPP code in English using at most 500 characters.",
      "es": "int display_ascii_info(char character)\n{\n    return character;\n}\n\nProporcione una descripción concisa en lenguaje natural (docstring) del código CPP en español utilizando como máximo 500 caracteres.",
      "arb": "int display_ascii_info(char character)\n{\n    return character;\n}\n\nيرجى تقديم وصف موجز بلغة طبيعية (docstring) لشفرة CPP باللغة العربية الفصحى باستخدام 500 حرف كحد أقصى.",
      "sw": "int display_ascii_info(char character)\n{\n    return character;\n}\n\nToa maelezo mafupi ya lugha ya asili (docstring) ya msimbo wa CPP kwa Kiswahili kwa kutumia herufi zisizozidi 500.",
      "tr": "int display_ascii_info(char character)\n{\n    return character;\n}\n\nAşağıdaki CPP kodunun işlevini açıklayan, en fazla 500 karakter uzunluğunda, özlü bir doğal dil açıklaması (docstring) sağlayın.",
      "vi": "int display_ascii_info(char character)\n{\n    return character;\n}\n\nCung cấp mô tả ngắn gọn bằng ngôn ngữ tự nhiên (docstring) cho mã CPP bằng tiếng Việt với tối đa 500 ký tự."
    },
    "instruction_bertscore": {
      "es": "0.9695565173899258",
      "arb": "0.9268249648875093",
      "sw": "0.9176812139269492",
      "tr": "0.8500634596150526",
      "vi": "0.9171611995893999"
    },
    "level": "",
    "test": "int main() {\n    assert(display_ascii_info('A') == 65);\n    assert(display_ascii_info('B') == 66); // Additional test case\n    assert(display_ascii_info('0') == 48); // Additional test case\n    assert(display_ascii_info(' ') == 32); // Additional test case\n    \n    // Uncomment the line below to print a success message if compiled outside a test framework\n    // std::printf(\"All tests passed.\\n\");\n\n    return 0;\n}",
    "entry_point": "display_ascii_info",
    "signature": "int display_ascii_info(char character)",
    "docstring": {
      "en": "Displays the ASCII information for a given character.\n\n@param character The input character for which ASCII information is to be displayed.\n@return The corresponding ASCII code.\n\nExample:\n```cpp\nint asciiCode = display_ascii_info('A');\nstd::cout << asciiCode; // Output: 65",
      "es": "Muestra la información ASCII para un carácter dado.\n\n@param character El carácter de entrada para el cual se mostrará la información ASCII.\n@return El código ASCII correspondiente.\n\nEjemplo:\n```cpp\nint asciiCode = display_ascii_info('A');\nstd::cout << asciiCode; // Output: 65",
      "arb": "يعرض معلومات ASCII لحرف معين.\n\n@param character الحرف المدخل الذي سيتم عرض معلومات ASCII له.\n@return رمز ASCII المقابل.\n\nمثال:\n```cpp\nint asciiCode = display_ascii_info('A');\nstd::cout << asciiCode; // Output: 65",
      "sw": "Inaonyesha taarifa za ASCII kwa herufi iliyotolewa.\n\n@param character Herufi ya ingizo ambayo taarifa za ASCII zinapaswa kuonyeshwa.\n@return Nambari ya ASCII inayolingana.\n\nMfano:\n```cpp\nint asciiCode = display_ascii_info('A');\nstd::cout << asciiCode; // Output: 65",
      "tr": "Verilen bir karakter için ASCII bilgisini gösterir.\n\n@param character ASCII bilgisinin gösterileceği giriş karakteri.\n@return Karşılık gelen ASCII kodu.\n\nÖrnek:\n```cpp\nint asciiCode = display_ascii_info('A');\nstd::cout << asciiCode; // Çıktı: 65",
      "vi": "Hiển thị thông tin ASCII cho một ký tự nhất định.\n\n@param character Ký tự đầu vào mà thông tin ASCII sẽ được hiển thị.\n@return Mã ASCII tương ứng.\n\nVí dụ:\n```cpp\nint asciiCode = display_ascii_info('A');\nstd::cout << asciiCode; // Output: 65"
    },
    "docstring_bertscore": {
      "es": "0.9793690568434303",
      "arb": "0.9792490840932853",
      "sw": "0.9482694980847979",
      "tr": "0.9808214421895574",
      "vi": "0.9642481204567684"
    }
  },
  {
    "task_id": "CPP/29",
    "prompt": {
      "en": "#include <cassert> // Used for making assertions in test cases\n/**\n * @brief Evaluate the grade for an input integer.\n * \n * @param score The integer score to be evaluated.\n * @return char The grade corresponding to the input score.\n *              If the score is between 90 and 100 (inclusive), returns 'A'.\n *              Otherwise, returns 'B'.\n * \n * Examples:\n *     evaluate_integer_grade(90) -> 'A'\n *     evaluate_integer_grade(89) -> 'B'\n */\nchar evaluate_integer_grade(int score)",
      "es": "#include <cassert> // Usado para hacer afirmaciones en casos de prueba\n/**\n * @brief Evalúa la calificación para un entero de entrada.\n * \n * @param score La puntuación entera a evaluar.\n * @return char La calificación correspondiente a la puntuación de entrada.\n *              Si la puntuación está entre 90 y 100 (inclusive), devuelve 'A'.\n *              De lo contrario, devuelve 'B'.\n * \n * Ejemplos:\n *     evaluate_integer_grade(90) -> 'A'\n *     evaluate_integer_grade(89) -> 'B'\n */\nchar evaluate_integer_grade(int score)",
      "arb": "#include <cassert> // مستخدم لإجراء التأكيدات في حالات الاختبار\n/**\n * @brief تقييم الدرجة لعدد صحيح مدخل.\n * \n * @param score الدرجة الصحيحة التي سيتم تقييمها.\n * @return char الدرجة المقابلة للدرجة المدخلة.\n *              إذا كانت الدرجة بين 90 و 100 (شاملة)، تعيد 'A'.\n *              خلاف ذلك، تعيد 'B'.\n * \n * أمثلة:\n *     evaluate_integer_grade(90) -> 'A'\n *     evaluate_integer_grade(89) -> 'B'\n */\nchar evaluate_integer_grade(int score)",
      "sw": "#include <cassert> // Inatumika kwa kufanya uthibitisho katika kesi za majaribio\n/**\n * @brief Tambua alama kwa namba kamili iliyoingizwa.\n * \n * @param score Alama ya namba kamili itakayotathminiwa.\n * @return char Alama inayolingana na alama iliyoingizwa.\n *              Ikiwa alama iko kati ya 90 na 100 (ikiwemo), inarudisha 'A'.\n *              Vinginevyo, inarudisha 'B'.\n * \n * Mifano:\n *     evaluate_integer_grade(90) -> 'A'\n *     evaluate_integer_grade(89) -> 'B'\n */\nchar evaluate_integer_grade(int score)",
      "tr": "#include <cassert> // Test durumlarında doğrulama yapmak için kullanılır\n/**\n * @brief Bir tam sayı notunu değerlendirir.\n * \n * @param score Değerlendirilecek tam sayı notu.\n * @return char Girdi notuna karşılık gelen harf notu.\n *              Eğer not 90 ile 100 arasında (dahil) ise, 'A' döner.\n *              Aksi takdirde, 'B' döner.\n * \n * Örnekler:\n *     evaluate_integer_grade(90) -> 'A'\n *     evaluate_integer_grade(89) -> 'B'\n */\nchar evaluate_integer_grade(int score)",
      "vi": "#include <cassert> // Được sử dụng để thực hiện các khẳng định trong các trường hợp kiểm tra\n/**\n * @brief Đánh giá điểm cho một số nguyên đầu vào.\n * \n * @param score Điểm số nguyên cần được đánh giá.\n * @return char Điểm tương ứng với điểm số đầu vào.\n *              Nếu điểm số nằm trong khoảng từ 90 đến 100 (bao gồm cả 90 và 100), trả về 'A'.\n *              Ngược lại, trả về 'B'.\n * \n * Ví dụ:\n *     evaluate_integer_grade(90) -> 'A'\n *     evaluate_integer_grade(89) -> 'B'\n */\nchar evaluate_integer_grade(int score)"
    },
    "prompt_bertscore": {
      "es": "0.9932255122244241",
      "arb": "0.996891633167185",
      "sw": "0.9728613296695843",
      "tr": "0.9712905606163603",
      "vi": "0.9693525239886029"
    },
    "canonical_solution": "{\n    return ((90 <= score && score <= 100) ? 'A' : 'B'); // Return 'A' or 'B' based on the condition\n}",
    "instruction": {
      "en": "char evaluate_integer_grade(int score)\n{\n    return ((90 <= score && score <= 100) ? 'A' : 'B'); // Return 'A' or 'B' based on the condition\n}\n\nProvide a concise natural language description (docstring) of the CPP code in English using at most 500 characters.",
      "es": "char evaluate_integer_grade(int score)\n{\n    return ((90 <= score && score <= 100) ? 'A' : 'B'); // Return 'A' or 'B' based on the condition\n}\n\nProporcione una descripción concisa en lenguaje natural (docstring) del código CPP en español utilizando un máximo de 500 caracteres.",
      "arb": "char evaluate_integer_grade(int score)\n{\n    return ((90 <= score && score <= 100) ? 'A' : 'B'); // Return 'A' or 'B' based on the condition\n}\n\nيرجى تقديم وصف موجز بلغة طبيعية (docstring) للكود المكتوب بلغة C++ باللغة العربية الفصحى، بحيث لا يتجاوز 500 حرف.",
      "sw": "char evaluate_integer_grade(int score)\n{\n    return ((90 <= score && score <= 100) ? 'A' : 'B'); // Return 'A' or 'B' based on the condition\n}\n\nToa maelezo mafupi ya lugha asilia (docstring) ya msimbo wa CPP kwa Kiswahili kwa kutumia herufi zisizozidi 500.",
      "tr": "char evaluate_integer_grade(int score)\n{\n    return ((90 <= score && score <= 100) ? 'A' : 'B'); // Return 'A' or 'B' based on the condition\n}\n\nAşağıdaki CPP kodunun Türkçe dilinde en fazla 500 karakter kullanarak kısa bir doğal dil açıklamasını (docstring) sağlayın.",
      "vi": "char evaluate_integer_grade(int score)\n{\n    return ((90 <= score && score <= 100) ? 'A' : 'B'); // Return 'A' or 'B' based on the condition\n}\n\nCung cấp mô tả ngắn gọn bằng ngôn ngữ tự nhiên (docstring) cho mã CPP bằng tiếng Việt với tối đa 500 ký tự."
    },
    "instruction_bertscore": {
      "es": "0.9695565173899258",
      "arb": "0.8366737856294908",
      "sw": "0.9449839529520998",
      "tr": "0.8753570523360352",
      "vi": "0.9171611995893999"
    },
    "level": "",
    "test": "int main() {\n    assert(evaluate_integer_grade(90) == 'A'); // Test for lower bound of 'A' grade\n    assert(evaluate_integer_grade(89) == 'B'); // Test for score just below 'A' grade\n    assert(evaluate_integer_grade(95) == 'A'); // Test for a score well within the 'A' range\n    assert(evaluate_integer_grade(100) == 'A'); // Test for upper boundary of 'A' grade\n    assert(evaluate_integer_grade(101) == 'B'); // Test for score above 'A' grade range\n\n    // Print \"All tests passed\" if all assertions hold true (optional)\n    // std::cout << \"All tests passed\\n\";\n\n    return 0;\n}",
    "entry_point": "evaluate_integer_grade",
    "signature": "char evaluate_integer_grade(int score)",
    "docstring": {
      "en": "Evaluate the grade for an input integer.\n\n@param score The integer score to be evaluated.\n@return char The grade corresponding to the input score.\n             If the score is between 90 and 100 (inclusive), returns 'A'.\n             Otherwise, returns 'B'.\n\nExamples:\n    evaluate_integer_grade(90) -> 'A'\n    evaluate_integer_grade(89) -> 'B'\n",
      "es": "Evalúa la calificación para un entero de entrada.\n\n@param score El puntaje entero a ser evaluado.\n@return char La calificación correspondiente al puntaje de entrada.\n             Si el puntaje está entre 90 y 100 (inclusive), devuelve 'A'.\n             De lo contrario, devuelve 'B'.\n\nEjemplos:\n    evaluate_integer_grade(90) -> 'A'\n    evaluate_integer_grade(89) -> 'B'",
      "arb": "تقييم الدرجة لعدد صحيح مدخل.\n\n@param score الدرجة الصحيحة التي سيتم تقييمها.\n@return char الدرجة المقابلة للدرجة المدخلة.\n             إذا كانت الدرجة بين 90 و 100 (شاملة)، تعيد 'A'.\n             خلاف ذلك، تعيد 'B'.\n\nأمثلة:\n    evaluate_integer_grade(90) -> 'A'\n    evaluate_integer_grade(89) -> 'B'",
      "sw": "Tambua alama kwa namba kamili iliyoingizwa.\n\n@param score Alama ya nambari ambayo itatathminiwa.\n@return char Alama inayolingana na alama ya ingizo.\n             Ikiwa alama iko kati ya 90 na 100 (pamoja), inarudisha 'A'.\n             Vinginevyo, inarudisha 'B'.\n\nMifano:\n    evaluate_integer_grade(90) -> 'A'\n    evaluate_integer_grade(89) -> 'B'",
      "tr": "Bir girdi tam sayısının notunu değerlendirin.\n\n@param score Değerlendirilecek tam sayı puanı.\n@return char Girdi puanına karşılık gelen not.\n             Eğer puan 90 ile 100 arasında (dahil) ise, 'A' döner.\n             Aksi takdirde, 'B' döner.\n\nÖrnekler:\n    evaluate_integer_grade(90) -> 'A'\n    evaluate_integer_grade(89) -> 'B'",
      "vi": "Đánh giá điểm cho một số nguyên đầu vào.\n\n@param score Số nguyên điểm cần được đánh giá.\n@return char Điểm tương ứng với điểm đầu vào.\n             Nếu điểm nằm trong khoảng từ 90 đến 100 (bao gồm cả 90 và 100), trả về 'A'.\n             Ngược lại, trả về 'B'.\n\nVí dụ:\n    evaluate_integer_grade(90) -> 'A'\n    evaluate_integer_grade(89) -> 'B'"
    },
    "docstring_bertscore": {
      "es": "0.9945883152687045",
      "arb": "0.9890308358377293",
      "sw": "0.9756348056799744",
      "tr": "0.9934251357573641",
      "vi": "0.9578889688079365"
    }
  },
  {
    "task_id": "CPP/30",
    "prompt": {
      "en": "#include <cassert>\n#include <cstring>\n#include <cstdio>\n/**\n * Checks if a three-character string has exactly two characters that are the same.\n * \n * @param s A three-character string to be checked.\n * \n * @return Returns \"Yes\" if the input has exactly two equal characters, otherwise \"No\".\n * Examples:\n *   >>> check_two_equal_digits(\"112\")\n *   \"Yes\"\n *   >>> check_two_equal_digits(\"123\")\n *   \"No\"\n */\nconst char* check_two_equal_digits(const char s[4])",
      "es": "#include <cassert>\n#include <cstring>\n#include <cstdio>\n/**\n * Verifica si una cadena de tres caracteres tiene exactamente dos caracteres que son iguales.\n * \n * @param s Una cadena de tres caracteres a verificar.\n * \n * @return Devuelve \"Yes\" si la entrada tiene exactamente dos caracteres iguales, de lo contrario \"No\".\n * Ejemplos:\n *   >>> check_two_equal_digits(\"112\")\n *   \"Yes\"\n *   >>> check_two_equal_digits(\"123\")\n *   \"No\"\n */\nconst char* check_two_equal_digits(const char s[4])",
      "arb": "#include <cassert>\n#include <cstring>\n#include <cstdio>\n/**\n * يتحقق مما إذا كانت سلسلة مكونة من ثلاثة أحرف تحتوي على حرفين متطابقين بالضبط.\n * \n * @param s سلسلة مكونة من ثلاثة أحرف للتحقق منها.\n * \n * @return يعيد \"Yes\" إذا كانت المدخلات تحتوي على حرفين متساويين بالضبط، وإلا يعيد \"No\".\n * أمثلة:\n *   >>> check_two_equal_digits(\"112\")\n *   \"Yes\"\n *   >>> check_two_equal_digits(\"123\")\n *   \"No\"\n */\nconst char* check_two_equal_digits(const char s[4])",
      "sw": "#include <cassert>\n#include <cstring>\n#include <cstdio>\n/**\n * Hukagua kama kamba yenye herufi tatu ina herufi mbili ambazo ni sawa.\n * \n * @param s Kamba yenye herufi tatu inayopaswa kukaguliwa.\n * \n * @return Inarudisha \"Yes\" ikiwa ingizo lina herufi mbili sawa, vinginevyo \"No\".\n * Mifano:\n *   >>> check_two_equal_digits(\"112\")\n *   \"Yes\"\n *   >>> check_two_equal_digits(\"123\")\n *   \"No\"\n */\nconst char* check_two_equal_digits(const char s[4])",
      "tr": "#include <cassert>\n#include <cstring>\n#include <cstdio>\n/**\n * Üç karakterli bir dizgede tam olarak iki karakterin aynı olup olmadığını kontrol eder.\n * \n * @param s Kontrol edilecek üç karakterli bir dizge.\n * \n * @return Girdi tam olarak iki eşit karaktere sahipse \"Yes\", aksi takdirde \"No\" döner.\n * Örnekler:\n *   >>> check_two_equal_digits(\"112\")\n *   \"Yes\"\n *   >>> check_two_equal_digits(\"123\")\n *   \"No\"\n */\nconst char* check_two_equal_digits(const char s[4])",
      "vi": "#include <cassert>\n#include <cstring>\n#include <cstdio>\n/**\n * Kiểm tra xem một chuỗi ba ký tự có chính xác hai ký tự giống nhau hay không.\n * \n * @param s Một chuỗi ba ký tự cần được kiểm tra.\n * \n * @return Trả về \"Yes\" nếu đầu vào có chính xác hai ký tự bằng nhau, ngược lại \"No\".\n * Ví dụ:\n *   >>> check_two_equal_digits(\"112\")\n *   \"Yes\"\n *   >>> check_two_equal_digits(\"123\")\n *   \"No\"\n */\nconst char* check_two_equal_digits(const char s[4])"
    },
    "prompt_bertscore": {
      "es": "0.9919238873375025",
      "arb": "0.9672972954360349",
      "sw": "0.9734671523317406",
      "tr": "0.9888387602592686",
      "vi": "0.974385817844027"
    },
    "canonical_solution": "{\n    if ((s[0] == s[1] && s[1] != s[2]) ||\n        (s[0] == s[2] && s[0] != s[1]) ||\n        (s[1] == s[2] && s[0] != s[1])) {\n        return \"Yes\";\n    } else {\n        return \"No\";\n    }\n}",
    "instruction": {
      "en": "const char* check_two_equal_digits(const char s[4])\n{\n    if ((s[0] == s[1] && s[1] != s[2]) ||\n        (s[0] == s[2] && s[0] != s[1]) ||\n        (s[1] == s[2] && s[0] != s[1])) {\n        return \"Yes\";\n    } else {\n        return \"No\";\n    }\n}\n\nProvide a concise natural language description (docstring) of the CPP code in English using at most 500 characters.",
      "es": "const char* check_two_equal_digits(const char s[4])\n{\n    if ((s[0] == s[1] && s[1] != s[2]) ||\n        (s[0] == s[2] && s[0] != s[1]) ||\n        (s[1] == s[2] && s[0] != s[1])) {\n        return \"Yes\";\n    } else {\n        return \"No\";\n    }\n}\n\nProporcione una descripción concisa en lenguaje natural (docstring) del código CPP en español utilizando como máximo 500 caracteres.",
      "arb": "const char* check_two_equal_digits(const char s[4])\n{\n    if ((s[0] == s[1] && s[1] != s[2]) ||\n        (s[0] == s[2] && s[0] != s[1]) ||\n        (s[1] == s[2] && s[0] != s[1])) {\n        return \"Yes\";\n    } else {\n        return \"No\";\n    }\n}\n\nيرجى تقديم وصف موجز بلغة طبيعية (docstring) للكود المكتوب بلغة C++ باللغة العربية الفصحى، بحيث لا يتجاوز 500 حرف.",
      "sw": "const char* check_two_equal_digits(const char s[4])\n{\n    if ((s[0] == s[1] && s[1] != s[2]) ||\n        (s[0] == s[2] && s[0] != s[1]) ||\n        (s[1] == s[2] && s[0] != s[1])) {\n        return \"Yes\";\n    } else {\n        return \"No\";\n    }\n}\n\nToa maelezo mafupi ya lugha asilia (docstring) ya msimbo wa CPP kwa Kiswahili kwa kutumia herufi zisizozidi 500.",
      "tr": "const char* check_two_equal_digits(const char s[4])\n{\n    if ((s[0] == s[1] && s[1] != s[2]) ||\n        (s[0] == s[2] && s[0] != s[1]) ||\n        (s[1] == s[2] && s[0] != s[1])) {\n        return \"Yes\";\n    } else {\n        return \"No\";\n    }\n}\n\nAşağıdaki CPP kodunun doğal dilde kısa bir açıklamasını (docstring) Türkçe olarak en fazla 500 karakter kullanarak sağlayın.",
      "vi": "const char* check_two_equal_digits(const char s[4])\n{\n    if ((s[0] == s[1] && s[1] != s[2]) ||\n        (s[0] == s[2] && s[0] != s[1]) ||\n        (s[1] == s[2] && s[0] != s[1])) {\n        return \"Yes\";\n    } else {\n        return \"No\";\n    }\n}\n\nCung cấp mô tả ngắn gọn bằng ngôn ngữ tự nhiên (docstring) cho mã CPP bằng tiếng Việt, tối đa 500 ký tự."
    },
    "instruction_bertscore": {
      "es": "0.9695565173899258",
      "arb": "0.8291343722565495",
      "sw": "0.9449839529520998",
      "tr": "0.8481701148230281",
      "vi": "0.9187053521715651"
    },
    "level": "",
    "test": "int main() {\n    // Testing the logic with various cases and using string comparison for assert.\n    assert(strcmp(check_two_equal_digits(\"112\"), \"Yes\") == 0);\n    assert(strcmp(check_two_equal_digits(\"123\"), \"No\") == 0);\n    assert(strcmp(check_two_equal_digits(\"232\"), \"Yes\") == 0);\n    assert(strcmp(check_two_equal_digits(\"444\"), \"No\") == 0); // All three characters are equal, not two.\n    assert(strcmp(check_two_equal_digits(\"121\"), \"Yes\") == 0);\n\n    // Additional test cases to cover more scenarios\n    assert(strcmp(check_two_equal_digits(\"787\"), \"Yes\") == 0);\n    assert(strcmp(check_two_equal_digits(\"999\"), \"No\") == 0); // All three characters are equal\n    assert(strcmp(check_two_equal_digits(\"890\"), \"No\") == 0);\n    assert(strcmp(check_two_equal_digits(\"556\"), \"Yes\") == 0);\n    assert(strcmp(check_two_equal_digits(\"353\"), \"Yes\") == 0); // No two characters are equal\n\n    \n    return 0;\n}",
    "entry_point": "check_two_equal_digits",
    "signature": "const char* check_two_equal_digits(const char s[4])",
    "docstring": {
      "en": "Checks if a three-character string has exactly two characters that are the same.\n \nParameters:\n@param s A three-character string to be checked.\n \nReturns:\nReturns \"Yes\" if the input has exactly two equal characters, otherwise \"No\".\nExamples:\n  >>> check_two_equal_digits(\"112\")\n  \"Yes\"\n  >>> check_two_equal_digits(\"123\")\n  \"No\"\n",
      "es": "Verifica si una cadena de tres caracteres tiene exactamente dos caracteres que son iguales.\n\nParámetros:\n@param s Una cadena de tres caracteres a verificar.\n\nDevuelve:\nDevuelve \"Sí\" si la entrada tiene exactamente dos caracteres iguales, de lo contrario \"No\".\nEjemplos:\n  >>> check_two_equal_digits(\"112\")\n  \"Yes\"\n  >>> check_two_equal_digits(\"123\")\n  \"No\"",
      "arb": "يتحقق مما إذا كانت سلسلة مكونة من ثلاثة أحرف تحتوي على حرفين متطابقين بالضبط.\n\nالمعلمات:\n@param s سلسلة مكونة من ثلاثة أحرف ليتم التحقق منها.\n\nالقيم المعادة:\nيعيد \"Yes\" إذا كان الإدخال يحتوي على حرفين متساويين بالضبط، وإلا يعيد \"No\".\n\nأمثلة:\n  >>> check_two_equal_digits(\"112\")\n  \"Yes\"\n  >>> check_two_equal_digits(\"123\")\n  \"No\"",
      "sw": "Hukagua kama mfuatano wa herufi tatu una herufi mbili sawa.\n\nVigezo:\n@param s Mfuatano wa herufi tatu ambao unapaswa kukaguliwa.\n\nInarejesha:\nInarejesha \"Yes\" ikiwa ingizo lina herufi mbili sawa, vinginevyo \"No\".\n\nMifano:\n  >>> check_two_equal_digits(\"112\")\n  \"Yes\"\n  >>> check_two_equal_digits(\"123\")\n  \"No\"",
      "tr": "Üç karakterli bir dizgede tam olarak iki karakterin aynı olup olmadığını kontrol eder.\n\nParametreler:\n@param s Kontrol edilecek üç karakterli bir dizge.\n\nDöndürür:\nGirdi tam olarak iki eşit karaktere sahipse \"Yes\", aksi takdirde \"No\" döndürür.\nÖrnekler:\n  >>> check_two_equal_digits(\"112\")\n  \"Yes\"\n  >>> check_two_equal_digits(\"123\")\n  \"No\"",
      "vi": "Kiểm tra xem một chuỗi ba ký tự có chính xác hai ký tự giống nhau hay không.\n\nTham số:\n@param s Một chuỗi ba ký tự cần được kiểm tra.\n\nTrả về:\nTrả về \"Yes\" nếu đầu vào có chính xác hai ký tự bằng nhau, ngược lại trả về \"No\".\n\nVí dụ:\n  >>> check_two_equal_digits(\"112\")\n  \"Yes\"\n  >>> check_two_equal_digits(\"123\")\n  \"No\""
    },
    "docstring_bertscore": {
      "es": "0.9797782354283622",
      "arb": "0.9707218818354575",
      "sw": "0.9331686233666204",
      "tr": "0.9763691421986603",
      "vi": "0.9715370609192246"
    }
  },
  {
    "task_id": "CPP/31",
    "prompt": {
      "en": "#include <cassert>\n#include <cstring>\n#include <iostream>\n/**\n * Given a string consisting of lowercase English letters, in each round you can change\n * one of the characters to another character. The question is: what is the minimum\n * number of rounds needed to make the string composed of the same character?\n * \n * Examples:\n * >>> minRoundsToSameChar(\"aab\")\n * 1\n * >>> minRoundsToSameChar(\"abc\")\n * 2\n * >>> minRoundsToSameChar(\"aaa\")\n * 0\n */\nint minRoundsToSameChar(const char* s)",
      "es": "#include <cassert>\n#include <cstring>\n#include <iostream>\n/**\n * Dada una cadena compuesta por letras minúsculas del alfabeto inglés, en cada ronda puedes cambiar\n * uno de los caracteres por otro carácter. La pregunta es: ¿cuál es el número mínimo\n * de rondas necesarias para hacer que la cadena esté compuesta por el mismo carácter?\n * \n * Ejemplos:\n * >>> minRoundsToSameChar(\"aab\")\n * 1\n * >>> minRoundsToSameChar(\"abc\")\n * 2\n * >>> minRoundsToSameChar(\"aaa\")\n * 0\n */\nint minRoundsToSameChar(const char* s)",
      "arb": "#include <cassert>\n#include <cstring>\n#include <iostream>\n/**\n * بالنظر إلى سلسلة تتكون من أحرف إنجليزية صغيرة، في كل جولة يمكنك تغيير\n * أحد الأحرف إلى حرف آخر. السؤال هو: ما هو الحد الأدنى\n * لعدد الجولات اللازمة لجعل السلسلة تتكون من نفس الحرف؟\n * \n * أمثلة:\n * >>> minRoundsToSameChar(\"aab\")\n * 1\n * >>> minRoundsToSameChar(\"abc\")\n * 2\n * >>> minRoundsToSameChar(\"aaa\")\n * 0\n */\nint minRoundsToSameChar(const char* s)",
      "sw": "#include <cassert>\n#include <cstring>\n#include <iostream>\n/**\n * Ukipewa kamba inayojumuisha herufi ndogo za Kiingereza, katika kila raundi unaweza kubadilisha\n * moja ya herufi kuwa herufi nyingine. Swali ni: ni idadi ndogo ya raundi ngapi zinazohitajika\n * kufanya kamba iwe na herufi sawa?\n * \n * Mifano:\n * >>> minRoundsToSameChar(\"aab\")\n * 1\n * >>> minRoundsToSameChar(\"abc\")\n * 2\n * >>> minRoundsToSameChar(\"aaa\")\n * 0\n */\nint minRoundsToSameChar(const char* s)",
      "tr": "#include <cassert>\n#include <cstring>\n#include <iostream>\n/**\n * Küçük harflerden oluşan bir dize verildiğinde, her turda karakterlerden birini başka bir karaktere\n * değiştirebilirsiniz. Soru şu: Diziyi aynı karakterden oluşacak şekilde yapmak için gereken minimum\n * tur sayısı nedir?\n * \n * Örnekler:\n * >>> minRoundsToSameChar(\"aab\")\n * 1\n * >>> minRoundsToSameChar(\"abc\")\n * 2\n * >>> minRoundsToSameChar(\"aaa\")\n * 0\n */\nint minRoundsToSameChar(const char* s)",
      "vi": "#include <cassert>\n#include <cstring>\n#include <iostream>\n/**\n * Cho một chuỗi bao gồm các chữ cái tiếng Anh viết thường, trong mỗi vòng bạn có thể thay đổi\n * một trong các ký tự thành ký tự khác. Câu hỏi là: số vòng tối thiểu\n * cần thiết để làm cho chuỗi được tạo thành từ cùng một ký tự là bao nhiêu?\n * \n * Ví dụ:\n * >>> minRoundsToSameChar(\"aab\")\n * 1\n * >>> minRoundsToSameChar(\"abc\")\n * 2\n * >>> minRoundsToSameChar(\"aaa\")\n * 0\n */\nint minRoundsToSameChar(const char* s)"
    },
    "prompt_bertscore": {
      "es": "0.9833597398288022",
      "arb": "0.9910590506584765",
      "sw": "0.9805582569346862",
      "tr": "0.9789811317092691",
      "vi": "0.993822595149815"
    },
    "canonical_solution": "{\n    int charCount[26] = {0}; // Assuming only lowercase letters\n    for (int i = 0; i < 26; i++) {\n        charCount[i] = 0;\n    }\n    while (*s) {\n        charCount[*s - 'a']++;\n        s++;\n    }\n    int maxCount = 0;\n    for (int i = 0; i < 26; i++) {\n        if (charCount[i] != 0 ) {\n            maxCount ++;\n        }\n    }\n\n    return maxCount - 1;\n}\n\n",
    "instruction": {
      "en": "int minRoundsToSameChar(const char* s)\n{\n    int charCount[26] = {0}; // Assuming only lowercase letters\n    for (int i = 0; i < 26; i++) {\n        charCount[i] = 0;\n    }\n    while (*s) {\n        charCount[*s - 'a']++;\n        s++;\n    }\n    int maxCount = 0;\n    for (int i = 0; i < 26; i++) {\n        if (charCount[i] != 0 ) {\n            maxCount ++;\n        }\n    }\n\n    return maxCount - 1;\n}\n\n\n\nProvide a concise natural language description (docstring) of the CPP code in English using at most 500 characters.",
      "es": "int minRoundsToSameChar(const char* s)\n{\n    int charCount[26] = {0}; // Assuming only lowercase letters\n    for (int i = 0; i < 26; i++) {\n        charCount[i] = 0;\n    }\n    while (*s) {\n        charCount[*s - 'a']++;\n        s++;\n    }\n    int maxCount = 0;\n    for (int i = 0; i < 26; i++) {\n        if (charCount[i] != 0 ) {\n            maxCount ++;\n        }\n    }\n\n    return maxCount - 1;\n}\n\n\n\nProporcione una descripción concisa en lenguaje natural (docstring) del código CPP en español utilizando como máximo 500 caracteres.",
      "arb": "int minRoundsToSameChar(const char* s)\n{\n    int charCount[26] = {0}; // Assuming only lowercase letters\n    for (int i = 0; i < 26; i++) {\n        charCount[i] = 0;\n    }\n    while (*s) {\n        charCount[*s - 'a']++;\n        s++;\n    }\n    int maxCount = 0;\n    for (int i = 0; i < 26; i++) {\n        if (charCount[i] != 0 ) {\n            maxCount ++;\n        }\n    }\n\n    return maxCount - 1;\n}\n\n\n\nقدم وصفًا موجزًا بلغة طبيعية (docstring) للكود المكتوب بلغة C++ باللغة العربية الفصحى باستخدام 500 حرف كحد أقصى.",
      "sw": "int minRoundsToSameChar(const char* s)\n{\n    int charCount[26] = {0}; // Assuming only lowercase letters\n    for (int i = 0; i < 26; i++) {\n        charCount[i] = 0;\n    }\n    while (*s) {\n        charCount[*s - 'a']++;\n        s++;\n    }\n    int maxCount = 0;\n    for (int i = 0; i < 26; i++) {\n        if (charCount[i] != 0 ) {\n            maxCount ++;\n        }\n    }\n\n    return maxCount - 1;\n}\n\n\n\nToa maelezo mafupi ya lugha ya asili (docstring) ya msimbo wa CPP kwa Kiswahili kwa kutumia herufi zisizozidi 500.",
      "tr": "int minRoundsToSameChar(const char* s)\n{\n    int charCount[26] = {0}; // Assuming only lowercase letters\n    for (int i = 0; i < 26; i++) {\n        charCount[i] = 0;\n    }\n    while (*s) {\n        charCount[*s - 'a']++;\n        s++;\n    }\n    int maxCount = 0;\n    for (int i = 0; i < 26; i++) {\n        if (charCount[i] != 0 ) {\n            maxCount ++;\n        }\n    }\n\n    return maxCount - 1;\n}\n\n\n\nAşağıdaki CPP kodunun Türkçe olarak en fazla 500 karakter kullanarak kısa bir doğal dil açıklamasını (docstring) sağlayın.",
      "vi": "int minRoundsToSameChar(const char* s)\n{\n    int charCount[26] = {0}; // Assuming only lowercase letters\n    for (int i = 0; i < 26; i++) {\n        charCount[i] = 0;\n    }\n    while (*s) {\n        charCount[*s - 'a']++;\n        s++;\n    }\n    int maxCount = 0;\n    for (int i = 0; i < 26; i++) {\n        if (charCount[i] != 0 ) {\n            maxCount ++;\n        }\n    }\n\n    return maxCount - 1;\n}\n\n\n\nCung cấp mô tả ngắn gọn bằng ngôn ngữ tự nhiên (docstring) của mã CPP bằng tiếng Việt với tối đa 500 ký tự."
    },
    "instruction_bertscore": {
      "es": "0.9695565173899258",
      "arb": "0.8615087408006639",
      "sw": "0.9176812139269492",
      "tr": "0.8786900701298007",
      "vi": "0.9268035128063575"
    },
    "level": "",
    "test": "int main() {\n    assert(minRoundsToSameChar(\"aab\") == 1);\n    assert(minRoundsToSameChar(\"abc\") == 2);\n    assert(minRoundsToSameChar(\"aaa\") == 0);\n    assert(minRoundsToSameChar(\"abab\") == 1);\n    assert(minRoundsToSameChar(\"zzzzz\") == 0);\n\n    return 0;\n}",
    "entry_point": "minRoundsToSameChar",
    "signature": "int minRoundsToSameChar(const char* s)",
    "docstring": {
      "en": "Given a string consisting of lowercase English letters, in each round you can change\none of the characters to another character. The question is: what is the minimum\nnumber of rounds needed to make the string composed of the same character?\n\nExamples:\n>>> minRoundsToSameChar(\"aab\")\n1\n>>> minRoundsToSameChar(\"abc\")\n2\n>>> minRoundsToSameChar(\"aaa\")\n0",
      "es": "Dada una cadena que consiste en letras minúsculas del alfabeto inglés, en cada ronda puedes cambiar uno de los caracteres por otro carácter. La pregunta es: ¿cuál es el número mínimo de rondas necesarias para que la cadena esté compuesta por el mismo carácter?\n\nEjemplos:\n>>> minRoundsToSameChar(\"aab\")\n1\n>>> minRoundsToSameChar(\"abc\")\n2\n>>> minRoundsToSameChar(\"aaa\")\n0",
      "arb": "بالنظر إلى سلسلة تتكون من أحرف إنجليزية صغيرة، في كل جولة يمكنك تغيير أحد الأحرف إلى حرف آخر. السؤال هو: ما هو الحد الأدنى لعدد الجولات اللازمة لجعل السلسلة تتكون من نفس الحرف؟\n\nأمثلة:\n>>> minRoundsToSameChar(\"aab\")\n1\n>>> minRoundsToSameChar(\"abc\")\n2\n>>> minRoundsToSameChar(\"aaa\")\n0",
      "sw": "Kutolewa kwa herufi ndogo za Kiingereza, katika kila mzunguko unaweza kubadilisha moja ya herufi kuwa herufi nyingine. Swali ni: ni idadi ndogo ya mizunguko gani inahitajika kufanya herufi zote ziwe sawa?\n\nMifano:\n>>> minRoundsToSameChar(\"aab\")\n1\n>>> minRoundsToSameChar(\"abc\")\n2\n>>> minRoundsToSameChar(\"aaa\")\n0",
      "tr": "Verilen bir küçük İngiliz harflerinden oluşan bir dizede, her turda karakterlerden birini başka bir karaktere değiştirebilirsiniz. Soru şu: Dizenin aynı karakterden oluşması için gereken minimum tur sayısı nedir?\n\nÖrnekler:\n>>> minRoundsToSameChar(\"aab\")\n1\n>>> minRoundsToSameChar(\"abc\")\n2\n>>> minRoundsToSameChar(\"aaa\")\n0",
      "vi": "Cho một chuỗi bao gồm các chữ cái tiếng Anh viết thường, trong mỗi vòng bạn có thể thay đổi một trong các ký tự thành ký tự khác. Câu hỏi là: số vòng tối thiểu cần thiết để làm cho chuỗi được tạo thành từ cùng một ký tự là bao nhiêu?\n\nVí dụ:\n>>> minRoundsToSameChar(\"aab\")\n1\n>>> minRoundsToSameChar(\"abc\")\n2\n>>> minRoundsToSameChar(\"aaa\")\n0"
    },
    "docstring_bertscore": {
      "es": "0.9740112009453953",
      "arb": "0.9839230555894172",
      "sw": "0.9248323049049673",
      "tr": "0.9803866402854721",
      "vi": "0.9915151060133327"
    }
  },
  {
    "task_id": "CPP/32",
    "prompt": {
      "en": "#include <cassert>\n#include <cstdio>\n/**\n * Given a sequence of n events, each occurring with a periodicity of a_i years, the task is to find\n * the year Y_n when the n-th event occurs. The countdown for event i+1 only starts in the year\n * immediately following the occurrence of event i.\n * Example usage:\n *     apocalypseYear(6, {3,2,4,5,9,18}) returns 36\n */\nint apocalypseYear(int n, int signs[])",
      "es": "#include <cassert>\n#include <cstdio>\n/**\n * Dada una secuencia de n eventos, cada uno ocurriendo con una periodicidad de a_i años, la tarea es encontrar\n * el año Y_n cuando ocurre el n-ésimo evento. La cuenta regresiva para el evento i+1 solo comienza en el año\n * inmediatamente después de la ocurrencia del evento i.\n * Ejemplo de uso:\n *     apocalypseYear(6, {3,2,4,5,9,18}) devuelve 36\n */\nint apocalypseYear(int n, int signs[])",
      "arb": "#include <cassert>\n#include <cstdio>\n/**\n * بالنظر إلى تسلسل من n أحداث، كل منها يحدث بشكل دوري كل a_i سنة، المهمة هي إيجاد\n * السنة Y_n عندما يحدث الحدث n. يبدأ العد التنازلي للحدث i+1 فقط في السنة\n * التي تلي مباشرة حدوث الحدث i.\n * مثال على الاستخدام:\n *     apocalypseYear(6, {3,2,4,5,9,18}) returns 36\n */\nint apocalypseYear(int n, int signs[])",
      "sw": "#include <cassert>\n#include <cstdio>\n/**\n * Ukipewa mlolongo wa matukio n, kila moja likitokea kwa kipindi cha miaka a_i, kazi ni kupata\n * mwaka Y_n ambapo tukio la n-th linatokea. Hesabu ya tukio i+1 inaanza tu katika mwaka\n * unaofuata mara tu baada ya tukio i kutokea.\n * Mfano wa matumizi:\n *     apocalypseYear(6, {3,2,4,5,9,18}) inarudisha 36\n */\nint apocalypseYear(int n, int signs[])",
      "tr": "#include <cassert>\n#include <cstdio>\n/**\n * n adet olaydan oluşan bir dizide, her biri a_i yıl periyoduyla meydana gelen olaylar verildiğinde,\n * n'inci olayın meydana geldiği Y_n yılını bulma görevidir. i+1'inci olayın geri sayımı, yalnızca\n * i'inci olayın meydana gelmesinden hemen sonraki yılda başlar.\n * Örnek kullanım:\n *     apocalypseYear(6, {3,2,4,5,9,18}) 36 döndürür\n */\nint apocalypseYear(int n, int signs[])",
      "vi": "#include <cassert>\n#include <cstdio>\n/**\n * Cho một dãy n sự kiện, mỗi sự kiện xảy ra với chu kỳ a_i năm, nhiệm vụ là tìm\n * năm Y_n khi sự kiện thứ n xảy ra. Đếm ngược cho sự kiện i+1 chỉ bắt đầu vào năm\n * ngay sau khi sự kiện i xảy ra.\n * Ví dụ sử dụng:\n *     apocalypseYear(6, {3,2,4,5,9,18}) trả về 36\n */\nint apocalypseYear(int n, int signs[])"
    },
    "prompt_bertscore": {
      "es": "0.9930834915019842",
      "arb": "0.959264484196603",
      "sw": "0.965628998865723",
      "tr": "0.9384968833378814",
      "vi": "0.9682970021437836"
    },
    "canonical_solution": "{\n    int year = 0;\n    for (int i = 0; i < n; ++i) {\n        int period = signs[i];\n        year = ((year / period) + 1) * period;\n    }\n    return year;\n}",
    "instruction": {
      "en": "int apocalypseYear(int n, int signs[])\n{\n    int year = 0;\n    for (int i = 0; i < n; ++i) {\n        int period = signs[i];\n        year = ((year / period) + 1) * period;\n    }\n    return year;\n}\n\nProvide a concise natural language description (docstring) of the CPP code in English using at most 500 characters.",
      "es": "int apocalypseYear(int n, int signs[])\n{\n    int year = 0;\n    for (int i = 0; i < n; ++i) {\n        int period = signs[i];\n        year = ((year / period) + 1) * period;\n    }\n    return year;\n}\n\nProporcione una descripción concisa en lenguaje natural (docstring) del código CPP en español utilizando como máximo 500 caracteres.",
      "arb": "int apocalypseYear(int n, int signs[])\n{\n    int year = 0;\n    for (int i = 0; i < n; ++i) {\n        int period = signs[i];\n        year = ((year / period) + 1) * period;\n    }\n    return year;\n}\n\nقدم وصفًا موجزًا بلغة طبيعية (docstring) لشفرة CPP باللغة العربية الفصحى باستخدام ما لا يزيد عن 500 حرف.",
      "sw": "int apocalypseYear(int n, int signs[])\n{\n    int year = 0;\n    for (int i = 0; i < n; ++i) {\n        int period = signs[i];\n        year = ((year / period) + 1) * period;\n    }\n    return year;\n}\n\nToa maelezo mafupi ya lugha ya asili (docstring) ya msimbo wa CPP kwa Kiswahili kwa kutumia herufi zisizozidi 500.",
      "tr": "int apocalypseYear(int n, int signs[])\n{\n    int year = 0;\n    for (int i = 0; i < n; ++i) {\n        int period = signs[i];\n        year = ((year / period) + 1) * period;\n    }\n    return year;\n}\n\nAşağıdaki CPP kodunun Türkçe olarak en fazla 500 karakter kullanarak kısa ve doğal bir dilde açıklamasını (docstring) sağlayın.",
      "vi": "int apocalypseYear(int n, int signs[])\n{\n    int year = 0;\n    for (int i = 0; i < n; ++i) {\n        int period = signs[i];\n        year = ((year / period) + 1) * period;\n    }\n    return year;\n}\n\nCung cấp mô tả ngắn gọn bằng ngôn ngữ tự nhiên (docstring) cho mã CPP bằng tiếng Việt với tối đa 500 ký tự."
    },
    "instruction_bertscore": {
      "es": "0.9695565173899258",
      "arb": "0.8910291880300689",
      "sw": "0.9449839529520998",
      "tr": "0.8684049889998141",
      "vi": "0.9343528576983505"
    },
    "level": "",
    "test": "int main() {\n    int arr1[] = {3,2,4,5,9,18};\n    assert(apocalypseYear(6, arr1) == 36);\n    int arr2[] = {1, 2,3,4,5};\n    assert(apocalypseYear(5, arr2) == 5);\n    int arr3[] = {1,1,1,1,1};\n    assert(apocalypseYear(5, arr3) == 5);\n    int arr4[] = {50,30,711,200,503,1006};\n    assert(apocalypseYear(6, arr4) == 2012);\n    int arr5[] = {1, 2};\n    assert(apocalypseYear(2, arr5) == 2);\n    int arr6[] = {3, 1, 2};\n    assert(apocalypseYear(3, arr6) == 6);\n    int arr7[] = {2, 3, 4};\n    assert(apocalypseYear(3, arr7) == 4);\n    int arr8[] = {1, 2, 3, 4};\n    assert(apocalypseYear(4, arr8) == 4);\n    int arr9[] = {5, 7, 11, 13};\n    assert(apocalypseYear(4, arr9) == 13);\n    int arr10[] = {2, 2, 2, 2, 2};\n    assert(apocalypseYear(5, arr10) == 10);\n    int arr11[] = {6, 10, 15};\n    assert(apocalypseYear(3, arr11) == 15);\n    int arr12[] = {4, 6, 14};\n    assert(apocalypseYear(3, arr12) == 14);\n    int arr13[] = {50, 30, 711, 200};\n    assert(apocalypseYear(4, arr13) == 800);\n    int arr14[] = {1, 1, 1, 1, 1, 1};\n    assert(apocalypseYear(6, arr14) == 6);\n    int arr15[] = {1000000, 999999};\n    assert(apocalypseYear(2, arr15) == 1999998);\n    return 0;\n}",
    "entry_point": "apocalypseYear",
    "signature": "int apocalypseYear(int n, int signs[])",
    "docstring": {
      "en": "Given a sequence of n events, each occurring with a periodicity of a_i years, the task is to find\nthe year Y_n when the n-th event occurs. The countdown for event i+1 only starts in the year\nimmediately following the occurrence of event i.\nExample usage:\napocalypseYear(6, {3,2,4,5,9,18}) returns 36",
      "es": "Dada una secuencia de n eventos, cada uno ocurriendo con una periodicidad de a_i años, la tarea es encontrar el año Y_n cuando ocurre el n-ésimo evento. La cuenta regresiva para el evento i+1 solo comienza en el año inmediatamente posterior a la ocurrencia del evento i.\nUso de ejemplo:\napocalypseYear(6, {3,2,4,5,9,18}) devuelve 36",
      "arb": "بالنظر إلى تسلسل من n أحداث، كل منها يحدث بتكرار a_i سنوات، فإن المهمة هي إيجاد السنة Y_n عندما يحدث الحدث n. يبدأ العد التنازلي للحدث i+1 فقط في السنة التي تلي مباشرة حدوث الحدث i.\n\nاستخدام المثال:\napocalypseYear(6, {3,2,4,5,9,18}) يعيد 36",
      "sw": "Kwa kupewa mlolongo wa matukio n, kila moja likitokea kwa kipindi cha miaka a_i, kazi ni kupata mwaka Y_n ambapo tukio la n linatokea. Hesabu ya tukio i+1 inaanza tu katika mwaka unaofuata mara tu baada ya tukio i kutokea. \n\nMfano wa matumizi:\napocalypseYear(6, {3,2,4,5,9,18}) inarudisha 36",
      "tr": "Verilen n olayından oluşan bir dizide, her biri a_i yıllık bir periyodiklikle meydana gelen, n'inci olayın gerçekleştiği Y_n yılını bulma görevi. i+1 olayının geri sayımı, yalnızca i olayının gerçekleştiği yılın hemen ardından başlar.\nÖrnek kullanım:\napocalypseYear(6, {3,2,4,5,9,18}) 36 döndürür",
      "vi": "Cho một dãy gồm n sự kiện, mỗi sự kiện xảy ra với chu kỳ a_i năm, nhiệm vụ là tìm năm Y_n khi sự kiện thứ n xảy ra. Đếm ngược cho sự kiện i+1 chỉ bắt đầu vào năm ngay sau khi sự kiện i xảy ra.\n\nVí dụ sử dụng:\napocalypseYear(6, {3,2,4,5,9,18}) returns 36"
    },
    "docstring_bertscore": {
      "es": "0.9991268208449706",
      "arb": "0.9651594366449565",
      "sw": "0.9394677886403799",
      "tr": "0.8971402503329883",
      "vi": "1"
    }
  },
  {
    "task_id": "CPP/33",
    "prompt": {
      "en": "#include <cassert>\n#include <cstdio>\n/**\n * This problem introduces a custom modulo operation, denoted by \"⊕\".\n * When calculating x ⊕ y, if x is not a multiple of y, the result is x % y.\n * If x is a multiple of y, divide x by y repeatedly until x is no longer a\n * multiple of y, denoting this final value as x'. Then the result is x' % y.\n * For example:\n * - 4⊕5=4,\n * - 20⊕5=4,\n * - 100⊕5=4.\n * Given a prime number p, you need to handle several queries where you're given\n * an integer n and you must compute n! ⊕ p. Here, n! is the factorial of n.\n * Example:\n *    newModuloFactorial(3, 7) returns 6\n */\nunsigned long long newModuloFactorial(unsigned long long n, unsigned long long p)",
      "es": "#include <cassert>\n#include <cstdio>\n/**\n * Este problema introduce una operación de módulo personalizada, denotada por \"⊕\".\n * Al calcular x ⊕ y, si x no es un múltiplo de y, el resultado es x % y.\n * Si x es un múltiplo de y, divide x por y repetidamente hasta que x ya no sea un\n * múltiplo de y, denotando este valor final como x'. Entonces el resultado es x' % y.\n * Por ejemplo:\n * - 4⊕5=4,\n * - 20⊕5=4,\n * - 100⊕5=4.\n * Dado un número primo p, necesitas manejar varias consultas donde se te da\n * un entero n y debes calcular n! ⊕ p. Aquí, n! es el factorial de n.\n * Ejemplo:\n *    newModuloFactorial(3, 7) devuelve 6\n */\nunsigned long long newModuloFactorial(unsigned long long n, unsigned long long p)",
      "arb": "#include <cassert>\n#include <cstdio>\n/**\n * هذه المسألة تقدم عملية باقي مخصصة، يرمز لها بـ \"⊕\".\n * عند حساب x ⊕ y، إذا لم يكن x مضاعفًا لـ y، تكون النتيجة x % y.\n * إذا كان x مضاعفًا لـ y، قسّم x على y بشكل متكرر حتى لا يكون x\n * مضاعفًا لـ y، يرمز لهذه القيمة النهائية بـ x'. ثم تكون النتيجة x' % y.\n * على سبيل المثال:\n * - 4⊕5=4،\n * - 20⊕5=4،\n * - 100⊕5=4.\n * بالنظر إلى عدد أولي p، تحتاج إلى معالجة عدة استفسارات حيث يُعطى لك\n * عدد صحيح n ويجب عليك حساب n! ⊕ p. هنا، n! هو مضروب n.\n * مثال:\n *    newModuloFactorial(3, 7) يعيد 6\n */\nunsigned long long newModuloFactorial(unsigned long long n, unsigned long long p)",
      "sw": "#include <cassert>\n#include <cstdio>\n/**\n * Shida hii inatambulisha operesheni maalum ya modulo, inayojulikana kama \"⊕\".\n * Wakati wa kuhesabu x ⊕ y, ikiwa x si kizio cha y, matokeo ni x % y.\n * Ikiwa x ni kizio cha y, gawanya x kwa y mara kwa mara hadi x si kizio tena cha y,\n * ukitaja thamani hii ya mwisho kama x'. Kisha matokeo ni x' % y.\n * Kwa mfano:\n * - 4⊕5=4,\n * - 20⊕5=4,\n * - 100⊕5=4.\n * Ukipewa nambari ya kwanza p, unahitaji kushughulikia maswali kadhaa ambapo umepewa\n * nambari nzima n na lazima uhakiki n! ⊕ p. Hapa, n! ni factorial ya n.\n * Mfano:\n *    newModuloFactorial(3, 7) inarudisha 6\n */\nunsigned long long newModuloFactorial(unsigned long long n, unsigned long long p)",
      "tr": "#include <cassert>\n#include <cstdio>\n/**\n * Bu problem, \"⊕\" ile gösterilen özel bir modül işlemi tanıtır.\n * x ⊕ y hesaplanırken, eğer x, y'nin katı değilse, sonuç x % y olur.\n * Eğer x, y'nin katı ise, x artık y'nin katı olmayana kadar x'i y'ye bölün,\n * bu son değeri x' olarak belirtin. Sonra sonuç x' % y olur.\n * Örneğin:\n * - 4⊕5=4,\n * - 20⊕5=4,\n * - 100⊕5=4.\n * Verilen bir asal sayı p ile, size bir tamsayı n verildiğinde birkaç sorguyu\n * ele almanız ve n! ⊕ p hesaplamanız gerekir. Burada, n! n'nin faktöriyelidir.\n * Örnek:\n *    newModuloFactorial(3, 7) 6 döndürür\n */\nunsigned long long newModuloFactorial(unsigned long long n, unsigned long long p)",
      "vi": "#include <cassert>\n#include <cstdio>\n/**\n * Vấn đề này giới thiệu một phép toán modulo tùy chỉnh, được ký hiệu là \"⊕\".\n * Khi tính toán x ⊕ y, nếu x không phải là bội số của y, kết quả là x % y.\n * Nếu x là bội số của y, chia x cho y liên tục cho đến khi x không còn là\n * bội số của y, ký hiệu giá trị cuối cùng này là x'. Sau đó kết quả là x' % y.\n * Ví dụ:\n * - 4⊕5=4,\n * - 20⊕5=4,\n * - 100⊕5=4.\n * Cho một số nguyên tố p, bạn cần xử lý một số truy vấn trong đó bạn được cho\n * một số nguyên n và bạn phải tính n! ⊕ p. Ở đây, n! là giai thừa của n.\n * Ví dụ:\n *    newModuloFactorial(3, 7) trả về 6\n */\nunsigned long long newModuloFactorial(unsigned long long n, unsigned long long p)"
    },
    "prompt_bertscore": {
      "es": "0.9963386461863839",
      "arb": "0.9848172895648363",
      "sw": "0.9731924465147694",
      "tr": "0.9651959846350668",
      "vi": "0.9861945926269322"
    },
    "canonical_solution": "{\n    unsigned long long pj[p];\n    pj[0] = 1;\n    pj[1] = 1;\n    for (unsigned long long i = 2; i < p; i++) pj[i] = i * pj[i - 1] % p;\n\n    unsigned long long ans = 1;\n    while (n) {\n        ans = ans * pj[n % p] % p;\n        ans = (n / p) & 1 ? p - ans : ans;\n        n /= p;\n    }\n    return ans;\n}",
    "instruction": {
      "en": "unsigned long long newModuloFactorial(unsigned long long n, unsigned long long p)\n{\n    unsigned long long pj[p];\n    pj[0] = 1;\n    pj[1] = 1;\n    for (unsigned long long i = 2; i < p; i++) pj[i] = i * pj[i - 1] % p;\n\n    unsigned long long ans = 1;\n    while (n) {\n        ans = ans * pj[n % p] % p;\n        ans = (n / p) & 1 ? p - ans : ans;\n        n /= p;\n    }\n    return ans;\n}\n\nProvide a concise natural language description (docstring) of the CPP code in English using at most 500 characters.",
      "es": "unsigned long long newModuloFactorial(unsigned long long n, unsigned long long p)\n{\n    unsigned long long pj[p];\n    pj[0] = 1;\n    pj[1] = 1;\n    for (unsigned long long i = 2; i < p; i++) pj[i] = i * pj[i - 1] % p;\n\n    unsigned long long ans = 1;\n    while (n) {\n        ans = ans * pj[n % p] % p;\n        ans = (n / p) & 1 ? p - ans : ans;\n        n /= p;\n    }\n    return ans;\n}\n\nProporciona una descripción concisa en lenguaje natural (docstring) del código CPP en español usando como máximo 500 caracteres.",
      "arb": "unsigned long long newModuloFactorial(unsigned long long n, unsigned long long p)\n{\n    unsigned long long pj[p];\n    pj[0] = 1;\n    pj[1] = 1;\n    for (unsigned long long i = 2; i < p; i++) pj[i] = i * pj[i - 1] % p;\n\n    unsigned long long ans = 1;\n    while (n) {\n        ans = ans * pj[n % p] % p;\n        ans = (n / p) & 1 ? p - ans : ans;\n        n /= p;\n    }\n    return ans;\n}\n\nيرجى تقديم وصف موجز بلغة طبيعية (docstring) للكود المكتوب بلغة C++ باللغة العربية الفصحى، بحيث لا يتجاوز 500 حرف.",
      "sw": "unsigned long long newModuloFactorial(unsigned long long n, unsigned long long p)\n{\n    unsigned long long pj[p];\n    pj[0] = 1;\n    pj[1] = 1;\n    for (unsigned long long i = 2; i < p; i++) pj[i] = i * pj[i - 1] % p;\n\n    unsigned long long ans = 1;\n    while (n) {\n        ans = ans * pj[n % p] % p;\n        ans = (n / p) & 1 ? p - ans : ans;\n        n /= p;\n    }\n    return ans;\n}\n\nToa maelezo mafupi ya lugha asilia (docstring) ya msimbo wa CPP kwa Kiswahili kwa kutumia herufi zisizozidi 500.",
      "tr": "unsigned long long newModuloFactorial(unsigned long long n, unsigned long long p)\n{\n    unsigned long long pj[p];\n    pj[0] = 1;\n    pj[1] = 1;\n    for (unsigned long long i = 2; i < p; i++) pj[i] = i * pj[i - 1] % p;\n\n    unsigned long long ans = 1;\n    while (n) {\n        ans = ans * pj[n % p] % p;\n        ans = (n / p) & 1 ? p - ans : ans;\n        n /= p;\n    }\n    return ans;\n}\n\nAşağıdaki CPP kodunun Türkçe'de en fazla 500 karakter kullanarak özlü bir doğal dil açıklamasını (docstring) sağlayın.",
      "vi": "unsigned long long newModuloFactorial(unsigned long long n, unsigned long long p)\n{\n    unsigned long long pj[p];\n    pj[0] = 1;\n    pj[1] = 1;\n    for (unsigned long long i = 2; i < p; i++) pj[i] = i * pj[i - 1] % p;\n\n    unsigned long long ans = 1;\n    while (n) {\n        ans = ans * pj[n % p] % p;\n        ans = (n / p) & 1 ? p - ans : ans;\n        n /= p;\n    }\n    return ans;\n}\n\nCung cấp mô tả ngắn gọn bằng ngôn ngữ tự nhiên (docstring) cho mã CPP bằng tiếng Việt với tối đa 500 ký tự."
    },
    "instruction_bertscore": {
      "es": "0.9695565173899258",
      "arb": "0.8245899077688523",
      "sw": "0.9449839529520998",
      "tr": "0.8959109269047634",
      "vi": "0.9171611995893999"
    },
    "level": "",
    "test": "int main() {\n    // Test cases\n    assert(newModuloFactorial(3, 7) == 6);\n    assert(newModuloFactorial(10, 3) == 1);\n    assert(newModuloFactorial(11, 7) == 4);\n    assert(newModuloFactorial(45, 7) == 1);\n    assert(newModuloFactorial(14, 7) == 2);\n    assert(newModuloFactorial(1919, 10007) == 3152);\n    assert(newModuloFactorial(810, 10007) == 3679);\n    assert(newModuloFactorial(3, 7) == 6);\n    assert(newModuloFactorial(10, 3) == 1);\n    assert(newModuloFactorial(1, 2) == 1);\n    assert(newModuloFactorial(5, 11) == 10);\n    assert(newModuloFactorial(6, 13) == 5);\n    assert(newModuloFactorial(8, 17) == 13);\n    assert(newModuloFactorial(15, 19) == 16);\n    assert(newModuloFactorial(21, 23) == 1);\n    assert(newModuloFactorial(30, 29) == 28);\n    assert(newModuloFactorial(100, 101) == 100);\n    return 0;\n}",
    "entry_point": "newModuloFactorial",
    "signature": "unsigned long long newModuloFactorial(unsigned long long n, unsigned long long p)",
    "docstring": {
      "en": "This problem introduces a custom modulo operation, denoted by \"⊕\".\nWhen calculating x ⊕ y, if x is not a multiple of y, the result is x % y.\nIf x is a multiple of y, divide x by y repeatedly until x is no longer a\nmultiple of y, denoting this final value as x'. Then the result is x' % y.\nFor example:\n- 4⊕5=4,\n- 20⊕5=4,\n- 100⊕5=4.\nGiven a prime number p, you need to handle several queries where you're given\nan integer n and you must compute n! ⊕ p. Here, n! is the factorial of n.\nExample:\n   newModuloFactorial(3, 7) returns 6\n",
      "es": "Este problema introduce una operación de módulo personalizada, denotada por \"⊕\".  \nAl calcular x ⊕ y, si x no es un múltiplo de y, el resultado es x % y.  \nSi x es un múltiplo de y, divide x por y repetidamente hasta que x ya no sea un múltiplo de y, denotando este valor final como x'. Entonces el resultado es x' % y.  \nPor ejemplo:  \n- 4⊕5=4,  \n- 20⊕5=4,  \n- 100⊕5=4.  \nDado un número primo p, necesitas manejar varias consultas donde se te da un entero n y debes calcular n! ⊕ p. Aquí, n! es el factorial de n.  \nEjemplo:  \n   newModuloFactorial(3, 7) devuelve 6  ",
      "arb": "هذه المشكلة تقدم عملية باقي مخصصة، يرمز لها بـ \"⊕\".  \nعند حساب x ⊕ y، إذا لم يكن x مضاعفًا لـ y، فإن النتيجة هي x % y.  \nإذا كان x مضاعفًا لـ y، قم بقسمة x على y بشكل متكرر حتى لا يكون x مضاعفًا لـ y، مشيرًا إلى هذه القيمة النهائية بـ x'. ثم تكون النتيجة هي x' % y.  \nعلى سبيل المثال:  \n- 4⊕5=4،  \n- 20⊕5=4،  \n- 100⊕5=4.  \nبالنظر إلى عدد أولي p، تحتاج إلى معالجة عدة استفسارات حيث يُعطى لك عدد صحيح n ويجب عليك حساب n! ⊕ p. هنا، n! هو مضروب n.  \nمثال:  \n   newModuloFactorial(3, 7) returns 6  ",
      "sw": "Tatizo hili linaanzisha operesheni maalum ya modulo, inayojulikana kama \"⊕\". Wakati wa kuhesabu x ⊕ y, ikiwa x si kigezo cha y, matokeo ni x % y. Ikiwa x ni kigezo cha y, gawanya x kwa y mara kwa mara hadi x isiwe tena kigezo cha y, ukitaja thamani hii ya mwisho kama x'. Kisha matokeo ni x' % y. Kwa mfano:\n- 4⊕5=4,\n- 20⊕5=4,\n- 100⊕5=4.\nUkipewa nambari ya kwanza p, unahitaji kushughulikia maswali kadhaa ambapo umepewa nambari n na lazima uhakiki n! ⊕ p. Hapa, n! ni factorial ya n.\nMfano:\n   newModuloFactorial(3, 7) inarudisha 6",
      "tr": "Bu problem, \"⊕\" ile gösterilen özel bir modül işlemi tanıtmaktadır.\nx ⊕ y hesaplanırken, eğer x, y'nin katı değilse, sonuç x % y olur.\nEğer x, y'nin katıysa, x'i artık y'nin katı olmayana kadar y ile tekrar tekrar bölün, bu son değeri x' olarak belirtin. Sonuç x' % y olur.\nÖrneğin:\n- 4⊕5=4,\n- 20⊕5=4,\n- 100⊕5=4.\nVerilen bir asal sayı p için, birkaç sorguyu ele almanız gerekmektedir; burada size bir tamsayı n verilir ve n! ⊕ p hesaplamanız gerekir. Burada n!, n'nin faktöriyelidir.\nÖrnek:\n   newModuloFactorial(3, 7) 6 döndürür.",
      "vi": "Vấn đề này giới thiệu một phép toán modulo tùy chỉnh, được ký hiệu là \"⊕\".  \nKhi tính toán x ⊕ y, nếu x không phải là bội số của y, kết quả là x % y.  \nNếu x là bội số của y, chia x cho y liên tục cho đến khi x không còn là bội số của y, ký hiệu giá trị cuối cùng này là x'. Sau đó kết quả là x' % y.  \nVí dụ:  \n- 4⊕5=4,  \n- 20⊕5=4,  \n- 100⊕5=4.  \nCho một số nguyên tố p, bạn cần xử lý một số truy vấn trong đó bạn được cho một số nguyên n và bạn phải tính n! ⊕ p. Ở đây, n! là giai thừa của n.  \nVí dụ:  \n   newModuloFactorial(3, 7) trả về 6  "
    },
    "docstring_bertscore": {
      "es": "0.9955582274192978",
      "arb": "0.9828959378890858",
      "sw": "0.9722402124680881",
      "tr": "0.9608658423285064",
      "vi": "0.9837133019070443"
    }
  },
  {
    "task_id": "CPP/34",
    "prompt": {
      "en": "#include <cstdio>\n#include <cassert>\n/**\n * You are given an array a of n integers. You can perform at most one operation where you\n * select three integers i, j, x (1 <= i <= j <= n) and replace all elements from a[i] to a[j] with x,\n * at a cost of (j - i + 1). Find the minimum cost to make all elements in the array equal.\n *\n * Examples:\n *    >>> makeEqualAgain(3, (int[]){1, 2, 1})\n *    1\n *    >>> makeEqualAgain(5, (int[]){5, 5, 1, 5, 5})\n *    1\n */\nint makeEqualAgain(int n, int a[])",
      "es": "#include <cstdio>\n#include <cassert>\n/**\n * Se te da un array a de n enteros. Puedes realizar como máximo una operación donde\n * seleccionas tres enteros i, j, x (1 <= i <= j <= n) y reemplazas todos los elementos desde a[i] hasta a[j] con x,\n * a un costo de (j - i + 1). Encuentra el costo mínimo para hacer que todos los elementos en el array sean iguales.\n *\n * Ejemplos:\n *    >>> makeEqualAgain(3, (int[]){1, 2, 1})\n *    1\n *    >>> makeEqualAgain(5, (int[]){5, 5, 1, 5, 5})\n *    1\n */\nint makeEqualAgain(int n, int a[])",
      "arb": "#include <cstdio>\n#include <cassert>\n/**\n * لديك مصفوفة a تحتوي على n من الأعداد الصحيحة. يمكنك تنفيذ عملية واحدة على الأكثر حيث\n * تختار ثلاثة أعداد صحيحة i, j, x (1 <= i <= j <= n) وتستبدل جميع العناصر من a[i] إلى a[j] بـ x،\n * بتكلفة (j - i + 1). جد التكلفة الدنيا لجعل جميع العناصر في المصفوفة متساوية.\n *\n * أمثلة:\n *    >>> makeEqualAgain(3, (int[]){1, 2, 1})\n *    1\n *    >>> makeEqualAgain(5, (int[]){5, 5, 1, 5, 5})\n *    1\n */\nint makeEqualAgain(int n, int a[])",
      "sw": "#include <cstdio>\n#include <cassert>\n/**\n * Umepewa safu a ya n nambari za mzima. Unaweza kufanya operesheni moja tu ambapo unachagua nambari tatu i, j, x (1 <= i <= j <= n) na kubadilisha vipengele vyote kutoka a[i] hadi a[j] na x, kwa gharama ya (j - i + 1). Pata gharama ya chini zaidi ya kufanya vipengele vyote katika safu kuwa sawa.\n *\n * Mifano:\n *    >>> makeEqualAgain(3, (int[]){1, 2, 1})\n *    1\n *    >>> makeEqualAgain(5, (int[]){5, 5, 1, 5, 5})\n *    1\n */\nint makeEqualAgain(int n, int a[])",
      "tr": "#include <cstdio>\n#include <cassert>\n/**\n * Size n olan bir tamsayı dizisi verilmektedir. En fazla bir işlem gerçekleştirebilirsiniz, bu işlemde\n * i, j, x (1 <= i <= j <= n) üç tamsayısını seçip a[i] ile a[j] arasındaki tüm elemanları x ile değiştirebilirsiniz,\n * maliyeti (j - i + 1) olacak şekilde. Dizideki tüm elemanları eşit yapmak için minimum maliyeti bulun.\n *\n * Örnekler:\n *    >>> makeEqualAgain(3, (int[]){1, 2, 1})\n *    1\n *    >>> makeEqualAgain(5, (int[]){5, 5, 1, 5, 5})\n *    1\n */\nint makeEqualAgain(int n, int a[])",
      "vi": "#include <cstdio>\n#include <cassert>\n/**\n * Bạn được cho một mảng a gồm n số nguyên. Bạn có thể thực hiện tối đa một thao tác, trong đó bạn\n * chọn ba số nguyên i, j, x (1 <= i <= j <= n) và thay thế tất cả các phần tử từ a[i] đến a[j] bằng x,\n * với chi phí là (j - i + 1). Tìm chi phí tối thiểu để làm cho tất cả các phần tử trong mảng bằng nhau.\n *\n * Ví dụ:\n *    >>> makeEqualAgain(3, (int[]){1, 2, 1})\n *    1\n *    >>> makeEqualAgain(5, (int[]){5, 5, 1, 5, 5})\n *    1\n */\nint makeEqualAgain(int n, int a[])"
    },
    "prompt_bertscore": {
      "es": "0.9990074439859686",
      "arb": "0.990936297082997",
      "sw": "0.9765270533515831",
      "tr": "0.957345516085425",
      "vi": "0.9782481856032504"
    },
    "canonical_solution": "{\n    int j = 0, p = 1, q = 0, c, d;\n    int k = n;\n    for (p = 1; p < k; p++) {\n        if (a[p] != a[p - 1])\n            break;\n    }\n    for (q = k - 1; q > p; q--) {\n        if (a[q] != a[p - 1])\n            break;\n    }\n    for (d = k - 2; d >= 0; d--) {\n        if (a[d] != a[d + 1])\n            break;\n    }\n    for (c = 0; c < d; c++) {\n        if (a[c] != a[c + 1])\n            break;\n    }\n    if (q - p + 1 < d - c + 1)\n        return q - p + 1;\n    else\n        return d - c + 1;\n}",
    "instruction": {
      "en": "int makeEqualAgain(int n, int a[])\n{\n    int j = 0, p = 1, q = 0, c, d;\n    int k = n;\n    for (p = 1; p < k; p++) {\n        if (a[p] != a[p - 1])\n            break;\n    }\n    for (q = k - 1; q > p; q--) {\n        if (a[q] != a[p - 1])\n            break;\n    }\n    for (d = k - 2; d >= 0; d--) {\n        if (a[d] != a[d + 1])\n            break;\n    }\n    for (c = 0; c < d; c++) {\n        if (a[c] != a[c + 1])\n            break;\n    }\n    if (q - p + 1 < d - c + 1)\n        return q - p + 1;\n    else\n        return d - c + 1;\n}\n\nProvide a concise natural language description (docstring) of the CPP code in English using at most 500 characters.",
      "es": "int makeEqualAgain(int n, int a[])\n{\n    int j = 0, p = 1, q = 0, c, d;\n    int k = n;\n    for (p = 1; p < k; p++) {\n        if (a[p] != a[p - 1])\n            break;\n    }\n    for (q = k - 1; q > p; q--) {\n        if (a[q] != a[p - 1])\n            break;\n    }\n    for (d = k - 2; d >= 0; d--) {\n        if (a[d] != a[d + 1])\n            break;\n    }\n    for (c = 0; c < d; c++) {\n        if (a[c] != a[c + 1])\n            break;\n    }\n    if (q - p + 1 < d - c + 1)\n        return q - p + 1;\n    else\n        return d - c + 1;\n}\n\nProporcione una descripción concisa en lenguaje natural (docstring) del código CPP en español utilizando un máximo de 500 caracteres.",
      "arb": "int makeEqualAgain(int n, int a[])\n{\n    int j = 0, p = 1, q = 0, c, d;\n    int k = n;\n    for (p = 1; p < k; p++) {\n        if (a[p] != a[p - 1])\n            break;\n    }\n    for (q = k - 1; q > p; q--) {\n        if (a[q] != a[p - 1])\n            break;\n    }\n    for (d = k - 2; d >= 0; d--) {\n        if (a[d] != a[d + 1])\n            break;\n    }\n    for (c = 0; c < d; c++) {\n        if (a[c] != a[c + 1])\n            break;\n    }\n    if (q - p + 1 < d - c + 1)\n        return q - p + 1;\n    else\n        return d - c + 1;\n}\n\nيرجى تقديم وصف موجز بلغة طبيعية (docstring) للشفرة البرمجية بلغة C++ باللغة العربية الفصحى، باستخدام 500 حرف كحد أقصى.",
      "sw": "int makeEqualAgain(int n, int a[])\n{\n    int j = 0, p = 1, q = 0, c, d;\n    int k = n;\n    for (p = 1; p < k; p++) {\n        if (a[p] != a[p - 1])\n            break;\n    }\n    for (q = k - 1; q > p; q--) {\n        if (a[q] != a[p - 1])\n            break;\n    }\n    for (d = k - 2; d >= 0; d--) {\n        if (a[d] != a[d + 1])\n            break;\n    }\n    for (c = 0; c < d; c++) {\n        if (a[c] != a[c + 1])\n            break;\n    }\n    if (q - p + 1 < d - c + 1)\n        return q - p + 1;\n    else\n        return d - c + 1;\n}\n\nToa maelezo mafupi ya lugha asilia (docstring) ya msimbo wa CPP kwa Kiswahili kwa kutumia herufi zisizozidi 500.",
      "tr": "int makeEqualAgain(int n, int a[])\n{\n    int j = 0, p = 1, q = 0, c, d;\n    int k = n;\n    for (p = 1; p < k; p++) {\n        if (a[p] != a[p - 1])\n            break;\n    }\n    for (q = k - 1; q > p; q--) {\n        if (a[q] != a[p - 1])\n            break;\n    }\n    for (d = k - 2; d >= 0; d--) {\n        if (a[d] != a[d + 1])\n            break;\n    }\n    for (c = 0; c < d; c++) {\n        if (a[c] != a[c + 1])\n            break;\n    }\n    if (q - p + 1 < d - c + 1)\n        return q - p + 1;\n    else\n        return d - c + 1;\n}\n\nAşağıdaki CPP kodunun Türkçe olarak en fazla 500 karakter kullanarak kısa bir doğal dil açıklamasını (docstring) sağlayın.",
      "vi": "int makeEqualAgain(int n, int a[])\n{\n    int j = 0, p = 1, q = 0, c, d;\n    int k = n;\n    for (p = 1; p < k; p++) {\n        if (a[p] != a[p - 1])\n            break;\n    }\n    for (q = k - 1; q > p; q--) {\n        if (a[q] != a[p - 1])\n            break;\n    }\n    for (d = k - 2; d >= 0; d--) {\n        if (a[d] != a[d + 1])\n            break;\n    }\n    for (c = 0; c < d; c++) {\n        if (a[c] != a[c + 1])\n            break;\n    }\n    if (q - p + 1 < d - c + 1)\n        return q - p + 1;\n    else\n        return d - c + 1;\n}\n\nCung cấp mô tả ngắn gọn bằng ngôn ngữ tự nhiên (docstring) cho mã CPP bằng tiếng Việt với tối đa 500 ký tự."
    },
    "instruction_bertscore": {
      "es": "0.9695565173899258",
      "arb": "0.8806972301301582",
      "sw": "0.9449839529520998",
      "tr": "0.8890214321385683",
      "vi": "0.9171611995893999"
    },
    "level": "",
    "test": "int main() {\n    int a1[] = {1,2,3,4,5,1};\n    int a2[] = {1,1,1,1,1,1,1};\n    int a3[] = {8,8,8,1,2,8,8,8};\n    int a4[] = {1,2,3};\n    int a5[] = {4,3,2,7,1,1,3};\n    int a6[] = {9,9,2,9,2,5,5,5,3};\n    \n    assert(makeEqualAgain(6, a1) == 4);\n    assert(makeEqualAgain(7, a2) == 0);\n    assert(makeEqualAgain(8, a3) == 2);\n    assert(makeEqualAgain(3, a4) == 2);\n    assert(makeEqualAgain(7, a5) == 6);\n    assert(makeEqualAgain(9, a6) == 7);\n\n    int a7[] = {1, 2, 1};\n    int a8[] = {5, 5, 1, 5, 5};\n    int a9[] = {1, 1, 1, 1};\n    int a10[] = {2, 2, 2, 3, 2, 2};\n    int a11[] = {1};\n    int a12[] = {1, 2};\n    int a13[] = {1, 2, 2, 1};\n    int a14[] = {4, 4, 4, 3, 3, 4, 4};\n    int a15[] = {5, 4, 4, 4, 5, 5};\n    int a16[] = {1, 2, 1, 2, 1, 2, 1};\n    // Additional provided tests\n    assert(makeEqualAgain(3, a7) == 1);\n    assert(makeEqualAgain(5, a8) == 1);\n    assert(makeEqualAgain(4, a9) == 0);\n    assert(makeEqualAgain(6, a10) == 1);\n    assert(makeEqualAgain(1, a11) == 0);\n    assert(makeEqualAgain(2, a12) == 1);\n    assert(makeEqualAgain(4, a13) == 2);\n    assert(makeEqualAgain(7, a14) == 2);\n    assert(makeEqualAgain(6, a15) == 3);\n    assert(makeEqualAgain(7, a16) == 5);\n    \n    return 0;\n}",
    "entry_point": "makeEqualAgain",
    "signature": "int makeEqualAgain(int n, int a[])",
    "docstring": {
      "en": "You are given an array a of n integers. You can perform at most one operation where you select three integers i, j, x (1 <= i <= j <= n) and replace all elements from a[i] to a[j] with x, at a cost of (j - i + 1). Find the minimum cost to make all elements in the array equal.\n\nExamples:\n   >>> makeEqualAgain(3, (int[]){1, 2, 1})\n   1\n   >>> makeEqualAgain(5, (int[]){5, 5, 1, 5, 5})\n   1\n",
      "es": "Se te da un array a de n enteros. Puedes realizar como máximo una operación donde seleccionas tres enteros i, j, x (1 <= i <= j <= n) y reemplazas todos los elementos desde a[i] hasta a[j] con x, a un costo de (j - i + 1). Encuentra el costo mínimo para hacer que todos los elementos en el array sean iguales.\n\nEjemplos:\n   >>> makeEqualAgain(3, (int[]){1, 2, 1})\n   1\n   >>> makeEqualAgain(5, (int[]){5, 5, 1, 5, 5})\n   1",
      "arb": "أنت مُعطى مصفوفة a تحتوي على n عدد صحيح. يمكنك تنفيذ عملية واحدة على الأكثر حيث تختار ثلاثة أعداد صحيحة i، j، x (1 <= i <= j <= n) وتستبدل جميع العناصر من a[i] إلى a[j] بـ x، بتكلفة (j - i + 1). جد الحد الأدنى للتكلفة لجعل جميع العناصر في المصفوفة متساوية.\n\nأمثلة:\n   >>> makeEqualAgain(3, (int[]){1, 2, 1})\n   1\n   >>> makeEqualAgain(5, (int[]){5, 5, 1, 5, 5})\n   1",
      "sw": "Umepewa safu a ya n ya nambari za mzima. Unaweza kufanya operesheni moja tu ambapo unachagua nambari tatu i, j, x (1 <= i <= j <= n) na kubadilisha vipengele vyote kutoka a[i] hadi a[j] na x, kwa gharama ya (j - i + 1). Pata gharama ya chini kabisa ya kufanya vipengele vyote katika safu kuwa sawa.\n\nMifano:\n   >>> makeEqualAgain(3, (int[]){1, 2, 1})\n   1\n   >>> makeEqualAgain(5, (int[]){5, 5, 1, 5, 5})\n   1",
      "tr": "Bir n tam sayısından oluşan bir dizi verildi. En fazla bir işlem gerçekleştirebilirsiniz; burada i, j, x (1 <= i <= j <= n) üç tam sayısını seçip a[i] ile a[j] arasındaki tüm elemanları x ile değiştirirsiniz, bu işlemin maliyeti (j - i + 1) olur. Dizideki tüm elemanları eşit hale getirmek için minimum maliyeti bulun.\n\nÖrnekler:\n   >>> makeEqualAgain(3, (int[]){1, 2, 1})\n   1\n   >>> makeEqualAgain(5, (int[]){5, 5, 1, 5, 5})\n   1",
      "vi": "Bạn được cung cấp một mảng a gồm n số nguyên. Bạn có thể thực hiện tối đa một thao tác, trong đó bạn chọn ba số nguyên i, j, x (1 <= i <= j <= n) và thay thế tất cả các phần tử từ a[i] đến a[j] bằng x, với chi phí là (j - i + 1). Tìm chi phí tối thiểu để làm cho tất cả các phần tử trong mảng bằng nhau.\n\nVí dụ:\n   >>> makeEqualAgain(3, (int[]){1, 2, 1})\n   1\n   >>> makeEqualAgain(5, (int[]){5, 5, 1, 5, 5})\n   1"
    },
    "docstring_bertscore": {
      "es": "1",
      "arb": "0.996202187114613",
      "sw": "0.9868776825073111",
      "tr": "0.9630072764664435",
      "vi": "0.9775527806392473"
    }
  },
  {
    "task_id": "CPP/35",
    "prompt": {
      "en": "#include <cassert>\n#include <iostream>\n/**\n * Given a sequence of N piles of stones numbered from 1 to N, each containing a positive number of stones, determine the winner\n * of a game played by Charlie and Dan. Charlie starts, taking turns with Dan moving stones from the leftmost non-empty pile\n * to the adjacent right pile. The one who can only move stones in the last pile loses. Assuming perfect play, find the winner.\n *\n * >>> gameWinner(3, {1, 2, 2})\n * \"Dan\"\n */\nconst char* gameWinner(int n, const int piles[])",
      "es": "#include <cassert>\n#include <iostream>\n/**\n * Dada una secuencia de N pilas de piedras numeradas del 1 al N, cada una conteniendo un número positivo de piedras, determina el ganador\n * de un juego jugado por Charlie y Dan. Charlie comienza, turnándose con Dan moviendo piedras desde la pila más a la izquierda no vacía\n * a la pila adyacente a la derecha. El que solo pueda mover piedras en la última pila pierde. Asumiendo juego perfecto, encuentra al ganador.\n *\n * >>> gameWinner(3, {1, 2, 2})\n * \"Dan\"\n */\nconst char* gameWinner(int n, const int piles[])",
      "arb": "#include <cassert>\n#include <iostream>\n/**\n * بالنظر إلى تسلسل من N أكوام من الحجارة مرقمة من 1 إلى N، يحتوي كل منها على عدد موجب من الحجارة، حدد الفائز\n * في لعبة يلعبها تشارلي ودان. يبدأ تشارلي، بالتناوب مع دان في نقل الحجارة من الكومة اليسرى غير الفارغة\n * إلى الكومة المجاورة على اليمين. الشخص الذي لا يستطيع نقل الحجارة إلا في الكومة الأخيرة يخسر. بافتراض اللعب المثالي، حدد الفائز.\n *\n * >>> gameWinner(3, {1, 2, 2})\n * \"Dan\"\n */\nconst char* gameWinner(int n, const int piles[])",
      "sw": "#include <cassert>\n#include <iostream>\n/**\n * Ukipewa mlolongo wa marundo ya mawe N yaliyo na namba kutoka 1 hadi N, kila moja likiwa na idadi chanya ya mawe, amua mshindi\n * wa mchezo unaochezwa na Charlie na Dan. Charlie anaanza, wakibadilishana na Dan kuhamisha mawe kutoka kwenye rundo la kwanza lisilo tupu\n * kwenda kwenye rundo la kulia lililo karibu. Yule ambaye anaweza tu kuhamisha mawe kwenye rundo la mwisho anapoteza. Ukizingatia uchezaji kamili, pata mshindi.\n *\n * >>> gameWinner(3, {1, 2, 2})\n * \"Dan\"\n */\nconst char* gameWinner(int n, const int piles[])",
      "tr": "#include <cassert>\n#include <iostream>\n/**\n * 1'den N'e kadar numaralandırılmış N taş yığını dizisi verildiğinde, her biri pozitif sayıda taş içeren, Charlie ve Dan tarafından oynanan bir oyunun kazananını belirleyin.\n * Charlie başlar, Dan ile sırayla taşları en soldaki boş olmayan yığından bitişik sağdaki yığına taşır.\n * Sadece son yığındaki taşları hareket ettirebilen kişi kaybeder. Mükemmel oyun varsayıldığında, kazananı bulun.\n *\n * >>> gameWinner(3, {1, 2, 2})\n * \"Dan\"\n */\nconst char* gameWinner(int n, const int piles[])",
      "vi": "#include <cassert>\n#include <iostream>\n/**\n * Cho một dãy N đống đá được đánh số từ 1 đến N, mỗi đống chứa một số lượng đá dương, xác định người chiến thắng\n * của trò chơi được chơi bởi Charlie và Dan. Charlie bắt đầu, lần lượt với Dan di chuyển đá từ đống không rỗng bên trái nhất\n * sang đống liền kề bên phải. Người chỉ có thể di chuyển đá trong đống cuối cùng sẽ thua. Giả sử chơi hoàn hảo, tìm người chiến thắng.\n *\n * >>> gameWinner(3, {1, 2, 2})\n * \"Dan\"\n */\nconst char* gameWinner(int n, const int piles[])"
    },
    "prompt_bertscore": {
      "es": "0.9788059397131964",
      "arb": "0.9791436113609557",
      "sw": "0.966767945470577",
      "tr": "0.9786947066998168",
      "vi": "0.9595167447805174"
    },
    "canonical_solution": "{\n    // Only the first pile's stone count is needed to determine the winner.\n    int firstPileStones = piles[0];\n    if (n == 2) { // With only two piles, Charlie always wins.\n        return \"Charlie\";\n    }\n    if (firstPileStones == 1) { // If the first pile has only one stone, Dan wins.\n        return \"Dan\";\n    }\n    return \"Charlie\"; // In all other cases, Charlie wins.\n}",
    "instruction": {
      "en": "const char* gameWinner(int n, const int piles[])\n{\n    // Only the first pile's stone count is needed to determine the winner.\n    int firstPileStones = piles[0];\n    if (n == 2) { // With only two piles, Charlie always wins.\n        return \"Charlie\";\n    }\n    if (firstPileStones == 1) { // If the first pile has only one stone, Dan wins.\n        return \"Dan\";\n    }\n    return \"Charlie\"; // In all other cases, Charlie wins.\n}\n\nProvide a concise natural language description (docstring) of the CPP code in English using at most 500 characters.",
      "es": "const char* gameWinner(int n, const int piles[])\n{\n    // Only the first pile's stone count is needed to determine the winner.\n    int firstPileStones = piles[0];\n    if (n == 2) { // With only two piles, Charlie always wins.\n        return \"Charlie\";\n    }\n    if (firstPileStones == 1) { // If the first pile has only one stone, Dan wins.\n        return \"Dan\";\n    }\n    return \"Charlie\"; // In all other cases, Charlie wins.\n}\n\nProporcione una descripción concisa en lenguaje natural (docstring) del código CPP en español utilizando como máximo 500 caracteres.",
      "arb": "const char* gameWinner(int n, const int piles[])\n{\n    // Only the first pile's stone count is needed to determine the winner.\n    int firstPileStones = piles[0];\n    if (n == 2) { // With only two piles, Charlie always wins.\n        return \"Charlie\";\n    }\n    if (firstPileStones == 1) { // If the first pile has only one stone, Dan wins.\n        return \"Dan\";\n    }\n    return \"Charlie\"; // In all other cases, Charlie wins.\n}\n\nيرجى تقديم وصف موجز بلغة طبيعية (docstring) للشفرة البرمجية بلغة C++ باللغة العربية الفصحى، بحيث لا يتجاوز 500 حرف.",
      "sw": "const char* gameWinner(int n, const int piles[])\n{\n    // Only the first pile's stone count is needed to determine the winner.\n    int firstPileStones = piles[0];\n    if (n == 2) { // With only two piles, Charlie always wins.\n        return \"Charlie\";\n    }\n    if (firstPileStones == 1) { // If the first pile has only one stone, Dan wins.\n        return \"Dan\";\n    }\n    return \"Charlie\"; // In all other cases, Charlie wins.\n}\n\nToa maelezo mafupi ya lugha ya asili (docstring) ya msimbo wa CPP kwa Kiswahili kwa kutumia herufi zisizozidi 500.",
      "tr": "const char* gameWinner(int n, const int piles[])\n{\n    // Only the first pile's stone count is needed to determine the winner.\n    int firstPileStones = piles[0];\n    if (n == 2) { // With only two piles, Charlie always wins.\n        return \"Charlie\";\n    }\n    if (firstPileStones == 1) { // If the first pile has only one stone, Dan wins.\n        return \"Dan\";\n    }\n    return \"Charlie\"; // In all other cases, Charlie wins.\n}\n\nAşağıdaki CPP kodunun işlevini açıklayan, en fazla 500 karakter uzunluğunda, özlü bir doğal dil açıklaması (docstring) sağlayın.",
      "vi": "const char* gameWinner(int n, const int piles[])\n{\n    // Only the first pile's stone count is needed to determine the winner.\n    int firstPileStones = piles[0];\n    if (n == 2) { // With only two piles, Charlie always wins.\n        return \"Charlie\";\n    }\n    if (firstPileStones == 1) { // If the first pile has only one stone, Dan wins.\n        return \"Dan\";\n    }\n    return \"Charlie\"; // In all other cases, Charlie wins.\n}\n\nCung cấp mô tả ngắn gọn bằng ngôn ngữ tự nhiên (docstring) cho mã CPP bằng tiếng Việt với tối đa 500 ký tự."
    },
    "instruction_bertscore": {
      "es": "0.9695565173899258",
      "arb": "0.8562400699437135",
      "sw": "0.9176812139269492",
      "tr": "0.8601759309439198",
      "vi": "0.9343528576983505"
    },
    "level": "",
    "test": "int main() {\n    int test1[] = {1, 2, 2};\n    int test2[] = {5, 5, 5, 5, 5};\n    int test3[] = {2, 1, 2};\n    int test4[] = {3, 3, 3, 3};\n    int test5[] = {1, 1};\n    int test6[] = {2, 1};\n    int test7[] = {1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1};\n    int test8[] = {2, 2, 2, 2, 2, 2, 2, 2, 2, 1};\n    int test9[] = {10, 10, 10, 10, 10, 10, 10, 10, 10, 10};\n    int test10[] = {1, 2, 3, 4, 5, 6, 7, 8, 9, 10};\n\n    assert(std::string(gameWinner(3, test1)) == \"Dan\");\n    assert(std::string(gameWinner(5, test2)) == \"Charlie\");\n    assert(std::string(gameWinner(3, test3)) == \"Charlie\");\n    assert(std::string(gameWinner(4, test4)) == \"Charlie\");\n    assert(std::string(gameWinner(2, test5)) == \"Charlie\");\n    assert(std::string(gameWinner(2, test6)) == \"Charlie\");\n    assert(std::string(gameWinner(11, test7)) == \"Dan\");\n    assert(std::string(gameWinner(10, test8)) == \"Charlie\");\n    assert(std::string(gameWinner(10, test9)) == \"Charlie\");\n    assert(std::string(gameWinner(10, test10)) == \"Dan\");\n\n    return 0;\n}",
    "entry_point": "gameWinner",
    "signature": "const char* gameWinner(int n, const int piles[])",
    "docstring": {
      "en": "Given a sequence of N piles of stones numbered from 1 to N, each containing a positive number of stones, determine the winner of a game played by Charlie and Dan. Charlie starts, taking turns with Dan moving stones from the leftmost non-empty pile to the adjacent right pile. The one who can only move stones in the last pile loses. Assuming perfect play, find the winner.\n\n>>> gameWinner(3, {1, 2, 2})\n\"Dan\"\n",
      "es": "Dada una secuencia de N pilas de piedras numeradas del 1 al N, cada una conteniendo un número positivo de piedras, determina el ganador de un juego jugado por Charlie y Dan. Charlie comienza, turnándose con Dan moviendo piedras de la pila más a la izquierda que no esté vacía a la pila adyacente a la derecha. El que solo pueda mover piedras en la última pila pierde. Suponiendo un juego perfecto, encuentra al ganador.\n\n>>> gameWinner(3, {1, 2, 2})\n\"Dan\"",
      "arb": "بالنظر إلى تسلسل من N أكوام من الحجارة مرقمة من 1 إلى N، كل منها يحتوي على عدد إيجابي من الحجارة، حدد الفائز في لعبة يلعبها تشارلي ودان. يبدأ تشارلي، بالتناوب مع دان في نقل الحجارة من الكومة غير الفارغة اليسرى إلى الكومة المجاورة على اليمين. الشخص الذي لا يمكنه سوى نقل الحجارة في الكومة الأخيرة يخسر. بافتراض اللعب المثالي، حدد الفائز.\n\n>>> gameWinner(3, {1, 2, 2})\n\"Dan\"",
      "sw": "Kwa kuzingatia mlolongo wa marundo N ya mawe yaliyohesabiwa kutoka 1 hadi N, kila moja ikiwa na idadi chanya ya mawe, tambua mshindi wa mchezo unaochezwa na Charlie na Dan. Charlie anaanza, wakibadilishana zamu na Dan kuhamisha mawe kutoka kwenye rundo la kwanza lisilo tupu kwenda kwenye rundo la kulia lililo karibu. Yule ambaye anaweza tu kuhamisha mawe kwenye rundo la mwisho anapoteza. Tukichukulia uchezaji kamili, pata mshindi.\n\n>>> gameWinner(3, {1, 2, 2})\n\"Dan\"",
      "tr": "Taşlardan oluşan N yığınından oluşan bir diziliş verildiğinde, her biri pozitif sayıda taş içeren ve 1'den N'ye kadar numaralandırılmış, Charlie ve Dan tarafından oynanan bir oyunun kazananını belirleyin. Charlie başlar, Dan ile sırayla taşları en soldaki boş olmayan yığından bitişik sağdaki yığına taşır. Sadece son yığındaki taşları hareket ettirebilen kişi kaybeder. Mükemmel oyun varsayıldığında, kazananı bulun.\n\n>>> gameWinner(3, {1, 2, 2})\n\"Dan\"",
      "vi": "Cho một dãy N đống đá được đánh số từ 1 đến N, mỗi đống chứa một số lượng đá dương, xác định người chiến thắng của trò chơi được chơi bởi Charlie và Dan. Charlie bắt đầu, lần lượt với Dan di chuyển đá từ đống không trống bên trái nhất sang đống liền kề bên phải. Người chỉ có thể di chuyển đá trong đống cuối cùng sẽ thua. Giả sử chơi hoàn hảo, tìm người chiến thắng.\n\n>>> gameWinner(3, {1, 2, 2})\n\"Dan\""
    },
    "docstring_bertscore": {
      "es": "0.9690980784704972",
      "arb": "0.9598802383778112",
      "sw": "0.9725139251331543",
      "tr": "0.9647274155662056",
      "vi": "0.974487715229498"
    }
  },
  {
    "task_id": "CPP/36",
    "prompt": {
      "en": "#include <cassert>\n#include <iostream>\n#include <vector>\n/**\n * @doc\n * Given n doors arranged in a circle, the player starts in front of door 1.\n * Each turn, the player can choose a number i and pay a cost C_i to move i steps to the right\n * and then open the door at that position. It is guaranteed that C_i >= C_{i+1} for 1 <= i < n.\n * The task is to determine the minimum total cost required to open all doors.\n *\n * Example:\n *     >>> minTotalCost(3, (1, 1, 1))\n *     3\n */\nlong long minTotalCost(int n, const std::vector<int>& C)",
      "es": "#include <cassert>\n#include <iostream>\n#include <vector>\n/**\n * @doc\n * Dado n puertas dispuestas en un círculo, el jugador comienza frente a la puerta 1.\n * En cada turno, el jugador puede elegir un número i y pagar un costo C_i para moverse i pasos a la derecha\n * y luego abrir la puerta en esa posición. Se garantiza que C_i >= C_{i+1} para 1 <= i < n.\n * La tarea es determinar el costo total mínimo requerido para abrir todas las puertas.\n *\n * Ejemplo:\n *     >>> minTotalCost(3, (1, 1, 1))\n *     3\n */\nlong long minTotalCost(int n, const std::vector<int>& C)",
      "arb": "#include <cassert>\n#include <iostream>\n#include <vector>\n/**\n * @doc\n * بالنظر إلى n أبواب مرتبة في دائرة، يبدأ اللاعب أمام الباب 1.\n * في كل دور، يمكن للاعب اختيار رقم i ودفع تكلفة C_i للتحرك i خطوات إلى اليمين\n * ثم فتح الباب في ذلك الموقع. من المضمون أن C_i >= C_{i+1} لـ 1 <= i < n.\n * المهمة هي تحديد الحد الأدنى للتكلفة الإجمالية المطلوبة لفتح جميع الأبواب.\n *\n * مثال:\n *     >>> minTotalCost(3, (1, 1, 1))\n *     3\n */\nlong long minTotalCost(int n, const std::vector<int>& C)",
      "sw": "#include <cassert>\n#include <iostream>\n#include <vector>\n/**\n * @doc\n * Ukipewa milango n iliyopangwa katika mduara, mchezaji huanza mbele ya mlango wa 1.\n * Kila zamu, mchezaji anaweza kuchagua namba i na kulipa gharama C_i ili kusonga hatua i kwenda kulia\n * na kisha kufungua mlango katika nafasi hiyo. Inahakikishwa kuwa C_i >= C_{i+1} kwa 1 <= i < n.\n * Kazi ni kubaini gharama ndogo kabisa inayohitajika kufungua milango yote.\n *\n * Mfano:\n *     >>> minTotalCost(3, (1, 1, 1))\n *     3\n */\nlong long minTotalCost(int n, const std::vector<int>& C)",
      "tr": "#include <cassert>\n#include <iostream>\n#include <vector>\n/**\n * @doc\n * Daire şeklinde düzenlenmiş n kapı verildiğinde, oyuncu 1 numaralı kapının önünde başlar.\n * Her turda, oyuncu bir sayı i seçebilir ve i adım sağa hareket etmek için bir maliyet C_i ödeyebilir\n * ve ardından o konumdaki kapıyı açabilir. C_i >= C_{i+1} olduğu garanti edilir, 1 <= i < n için.\n * Görev, tüm kapıları açmak için gereken minimum toplam maliyeti belirlemektir.\n *\n * Örnek:\n *     >>> minTotalCost(3, (1, 1, 1))\n *     3\n */\nlong long minTotalCost(int n, const std::vector<int>& C)",
      "vi": "#include <cassert>\n#include <iostream>\n#include <vector>\n/**\n * @doc\n * Cho n cánh cửa được sắp xếp thành một vòng tròn, người chơi bắt đầu trước cửa số 1.\n * Mỗi lượt, người chơi có thể chọn một số i và trả một chi phí C_i để di chuyển i bước sang phải\n * và sau đó mở cánh cửa ở vị trí đó. Đảm bảo rằng C_i >= C_{i+1} cho 1 <= i < n.\n * Nhiệm vụ là xác định tổng chi phí tối thiểu cần thiết để mở tất cả các cửa.\n *\n * Ví dụ:\n *     >>> minTotalCost(3, (1, 1, 1))\n *     3\n */\nlong long minTotalCost(int n, const std::vector<int>& C)"
    },
    "prompt_bertscore": {
      "es": "0.9943040751934435",
      "arb": "0.9921572780352185",
      "sw": "0.9966207013274534",
      "tr": "0.9861216952770924",
      "vi": "0.989484507628013"
    },
    "canonical_solution": "{\n    return static_cast<long long>(C[n - 2]) * (n - 1) + C[n - 1];\n}",
    "instruction": {
      "en": "long long minTotalCost(int n, const std::vector<int>& C)\n{\n    return static_cast<long long>(C[n - 2]) * (n - 1) + C[n - 1];\n}\n\nProvide a concise natural language description (docstring) of the CPP code in English using at most 500 characters.",
      "es": "long long minTotalCost(int n, const std::vector<int>& C)\n{\n    return static_cast<long long>(C[n - 2]) * (n - 1) + C[n - 1];\n}\n\nProporcione una descripción concisa en lenguaje natural (docstring) del código CPP en español utilizando como máximo 500 caracteres.",
      "arb": "long long minTotalCost(int n, const std::vector<int>& C)\n{\n    return static_cast<long long>(C[n - 2]) * (n - 1) + C[n - 1];\n}\n\nيرجى تقديم وصف موجز بلغة طبيعية (docstring) للكود المكتوب بلغة C++ باللغة العربية الفصحى، بحيث لا يتجاوز 500 حرف.",
      "sw": "long long minTotalCost(int n, const std::vector<int>& C)\n{\n    return static_cast<long long>(C[n - 2]) * (n - 1) + C[n - 1];\n}\n\nToa maelezo mafupi ya lugha asilia (docstring) ya msimbo wa CPP kwa Kiswahili kwa kutumia herufi zisizozidi 500.",
      "tr": "long long minTotalCost(int n, const std::vector<int>& C)\n{\n    return static_cast<long long>(C[n - 2]) * (n - 1) + C[n - 1];\n}\n\nAşağıdaki CPP kodunun Türkçe olarak en fazla 500 karakterle doğal dilde kısa bir açıklamasını (docstring) sağlayın.",
      "vi": "long long minTotalCost(int n, const std::vector<int>& C)\n{\n    return static_cast<long long>(C[n - 2]) * (n - 1) + C[n - 1];\n}\n\nCung cấp mô tả ngắn gọn bằng ngôn ngữ tự nhiên (docstring) cho mã CPP bằng tiếng Việt với tối đa 500 ký tự."
    },
    "instruction_bertscore": {
      "es": "0.9695565173899258",
      "arb": "0.8291343722565495",
      "sw": "0.9449839529520998",
      "tr": "0.8602498214456648",
      "vi": "0.9171611995893999"
    },
    "level": "",
    "test": "int main() {\n    std::vector<int> costs1 = {4, 3, 3, 3, 3}; // 1-indexed array\n    assert(minTotalCost(5, costs1) == 15);\n\n    std::vector<int> costs2 = {1, 1, 1};\n    assert(minTotalCost(3, costs2) == 3);\n\n    std::vector<int> costs3 = {5, 4, 3, 2};\n    assert(minTotalCost(4, costs3) == 11);\n\n    std::vector<int> costs4 = {100, 99, 98, 97};\n    assert(minTotalCost(4, costs4) == 391);\n\n    std::vector<int> costs5 = {10, 9, 8, 7, 6, 5};\n    assert(minTotalCost(6, costs5) == 35);\n\n    std::vector<int> costs6 = {2, 2, 2, 2, 2, 2, 2};\n    assert(minTotalCost(7, costs6) == 14);\n\n    std::vector<int> costs7 = {9, 7, 7, 7, 7, 7, 7, 7};\n    assert(minTotalCost(8, costs7) == 56);\n\n    std::vector<int> costs8 = {3, 2, 2, 2, 2, 2, 2, 2, 2};\n    assert(minTotalCost(9, costs8) == 18);\n\n    std::vector<int> costs9 = {6, 5, 5, 5, 5, 5, 5, 5, 5, 5};\n    assert(minTotalCost(10, costs9) == 50);\n\n    std::vector<int> costs10 = {8, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1};\n    assert(minTotalCost(11, costs10) == 11);\n\n\n    return 0;\n}",
    "entry_point": "minTotalCost",
    "signature": "long long minTotalCost(int n, const std::vector<int>& C)",
    "docstring": {
      "en": "Given n doors arranged in a circle, the player starts in front of door 1.\nEach turn, the player can choose a number i and pay a cost C_i to move i steps to the right\nand then open the door at that position. It is guaranteed that C_i >= C_{i+1} for 1 <= i < n.\nThe task is to determine the minimum total cost required to open all doors.\n\nExample:\n    >>> minTotalCost(3, (1, 1, 1))\n    3\n",
      "es": "Dado n puertas dispuestas en un círculo, el jugador comienza frente a la puerta 1.  \nCada turno, el jugador puede elegir un número i y pagar un costo C_i para moverse i pasos a la derecha  \ny luego abrir la puerta en esa posición. Se garantiza que C_i >= C_{i+1} para 1 <= i < n.  \nLa tarea es determinar el costo total mínimo requerido para abrir todas las puertas.\n\nEjemplo:\n    >>> minTotalCost(3, (1, 1, 1))\n    3",
      "arb": "معطى n أبواب مرتبة في دائرة، يبدأ اللاعب أمام الباب 1.  \nفي كل دور، يمكن للاعب اختيار رقم i ودفع تكلفة C_i للتحرك i خطوات إلى اليمين ثم فتح الباب في ذلك الموقع. من المضمون أن C_i >= C_{i+1} لكل 1 <= i < n.  \nالمهمة هي تحديد الحد الأدنى للتكلفة الإجمالية المطلوبة لفتح جميع الأبواب.\n\nمثال:  \n    >>> minTotalCost(3, (1, 1, 1))  \n    3  ",
      "sw": "Kwa kuwa kuna milango n iliyopangwa katika mduara, mchezaji anaanza mbele ya mlango wa 1.  \nKila zamu, mchezaji anaweza kuchagua namba i na kulipa gharama C_i ili kusonga hatua i kwenda kulia  \nkisha kufungua mlango katika nafasi hiyo. Inahakikishwa kuwa C_i >= C_{i+1} kwa 1 <= i < n.  \nKazi ni kuamua gharama ndogo kabisa inayohitajika kufungua milango yote.\n\nMfano:\n    >>> minTotalCost(3, (1, 1, 1))\n    3",
      "tr": "Verilen n kapı bir çember şeklinde düzenlenmiştir, oyuncu kapı 1'in önünde başlar.  \nHer turda, oyuncu bir sayı i seçebilir ve i adım sağa hareket etmek için bir maliyet C_i ödeyebilir  \nve ardından o konumdaki kapıyı açabilir. C_i >= C_{i+1} olduğu garanti edilmiştir, 1 <= i < n için.  \nGörev, tüm kapıları açmak için gereken minimum toplam maliyeti belirlemektir.\n\nÖrnek:\n    >>> minTotalCost(3, (1, 1, 1))\n    3",
      "vi": "Cho n cửa được sắp xếp thành vòng tròn, người chơi bắt đầu trước cửa số 1.  \nMỗi lượt, người chơi có thể chọn một số i và trả một chi phí C_i để di chuyển i bước sang phải  \nvà sau đó mở cửa tại vị trí đó. Đảm bảo rằng C_i >= C_{i+1} cho 1 <= i < n.  \nNhiệm vụ là xác định tổng chi phí tối thiểu cần thiết để mở tất cả các cửa.\n\nVí dụ:\n    >>> minTotalCost(3, (1, 1, 1))\n    3"
    },
    "docstring_bertscore": {
      "es": "0.9973691406031929",
      "arb": "0.9835099043968646",
      "sw": "0.9873029501531069",
      "tr": "0.9696705312286398",
      "vi": "0.9847334675440396"
    }
  },
  {
    "task_id": "CPP/37",
    "prompt": {
      "en": "#include <cassert>\n#include <vector>\n/**\n * Computes the total number of handshakes in a classroom scenario given\n * the sequence of student IDs as they enter the classroom. It assumes\n * that students have IDs ranging from 0 to N-1 and that each student\n * will shake hands only with students already in the classroom with a\n * smaller ID.\n *\n * Examples:\n * >>> countHandshakes(3, {2, 1, 0})\n * 0\n */\nlong long countHandshakes(int n, const std::vector<int>& order)",
      "es": "#include <cassert>\n#include <vector>\n/**\n * Calcula el número total de apretones de manos en un escenario de aula dado\n * la secuencia de IDs de estudiantes a medida que ingresan al aula. Se asume\n * que los estudiantes tienen IDs que van de 0 a N-1 y que cada estudiante\n * solo dará la mano a estudiantes que ya están en el aula con un\n * ID más pequeño.\n *\n * Ejemplos:\n * >>> countHandshakes(3, {2, 1, 0})\n * 0\n */\nlong long countHandshakes(int n, const std::vector<int>& order)",
      "arb": "#include <cassert>\n#include <vector>\n/**\n * يحسب العدد الإجمالي للمصافحات في سيناريو الفصل الدراسي المعطى\n * تسلسل معرفات الطلاب عند دخولهم الفصل. يفترض\n * أن الطلاب لديهم معرفات تتراوح من 0 إلى N-1 وأن كل طالب\n * سيصافح فقط الطلاب الموجودين بالفعل في الفصل مع\n * معرف أصغر.\n *\n * أمثلة:\n * >>> countHandshakes(3, {2, 1, 0})\n * 0\n */\nlong long countHandshakes(int n, const std::vector<int>& order)",
      "sw": "#include <cassert>\n#include <vector>\n/**\n * Inahesabu jumla ya mikono iliyoshikwa katika hali ya darasani kutokana na\n * mfuatano wa vitambulisho vya wanafunzi wanapoingia darasani. Inadhani\n * kwamba wanafunzi wana vitambulisho vinavyoanzia 0 hadi N-1 na kwamba kila\n * mwanafunzi atashikana mikono tu na wanafunzi ambao tayari wako darasani\n * wenye kitambulisho kidogo.\n *\n * Mifano:\n * >>> countHandshakes(3, {2, 1, 0})\n * 0\n */\nlong long countHandshakes(int n, const std::vector<int>& order)",
      "tr": "#include <cassert>\n#include <vector>\n/**\n * Bir sınıf senaryosunda, öğrencilerin sınıfa giriş sırasına göre toplam\n * tokalaşma sayısını hesaplar. Öğrencilerin kimliklerinin 0'dan N-1'e kadar\n * olduğunu ve her öğrencinin yalnızca sınıfta zaten bulunan ve daha küçük\n * kimlikli öğrencilerle tokalaşacağını varsayar.\n *\n * Örnekler:\n * >>> countHandshakes(3, {2, 1, 0})\n * 0\n */\nlong long countHandshakes(int n, const std::vector<int>& order)",
      "vi": "#include <cassert>\n#include <vector>\n/**\n * Tính tổng số lần bắt tay trong một tình huống lớp học cho trước\n * dãy số ID của học sinh khi họ vào lớp. Giả định rằng\n * học sinh có ID từ 0 đến N-1 và mỗi học sinh\n * sẽ chỉ bắt tay với những học sinh đã có mặt trong lớp với\n * ID nhỏ hơn.\n *\n * Ví dụ:\n * >>> countHandshakes(3, {2, 1, 0})\n * 0\n */\nlong long countHandshakes(int n, const std::vector<int>& order)"
    },
    "prompt_bertscore": {
      "es": "0.9840912955221537",
      "arb": "0.9774433352992971",
      "sw": "0.9650960735534063",
      "tr": "0.9309536959877005",
      "vi": "0.9623013440922454"
    },
    "canonical_solution": "{\n    long long ans = 0;\n    std::vector<int> tr(n + 1, 0);\n    \n    for (int i = 0; i < n; ++i) {\n        int x = order[i] + 1; // Convert 0-indexed to 1-indexed\n        for (int j = x - 1; j > 0; j -= j & (-j)) {\n            ans += tr[j];\n        }\n        for (int j = x; j <= n; j += j & (-j)) {\n            ++tr[j];\n        }\n    }\n\n    return ans;\n}",
    "instruction": {
      "en": "long long countHandshakes(int n, const std::vector<int>& order)\n{\n    long long ans = 0;\n    std::vector<int> tr(n + 1, 0);\n    \n    for (int i = 0; i < n; ++i) {\n        int x = order[i] + 1; // Convert 0-indexed to 1-indexed\n        for (int j = x - 1; j > 0; j -= j & (-j)) {\n            ans += tr[j];\n        }\n        for (int j = x; j <= n; j += j & (-j)) {\n            ++tr[j];\n        }\n    }\n\n    return ans;\n}\n\nProvide a concise natural language description (docstring) of the CPP code in English using at most 500 characters.",
      "es": "long long countHandshakes(int n, const std::vector<int>& order)\n{\n    long long ans = 0;\n    std::vector<int> tr(n + 1, 0);\n    \n    for (int i = 0; i < n; ++i) {\n        int x = order[i] + 1; // Convert 0-indexed to 1-indexed\n        for (int j = x - 1; j > 0; j -= j & (-j)) {\n            ans += tr[j];\n        }\n        for (int j = x; j <= n; j += j & (-j)) {\n            ++tr[j];\n        }\n    }\n\n    return ans;\n}\n\nProporcione una descripción concisa en lenguaje natural (docstring) del código CPP en español utilizando como máximo 500 caracteres.",
      "arb": "long long countHandshakes(int n, const std::vector<int>& order)\n{\n    long long ans = 0;\n    std::vector<int> tr(n + 1, 0);\n    \n    for (int i = 0; i < n; ++i) {\n        int x = order[i] + 1; // Convert 0-indexed to 1-indexed\n        for (int j = x - 1; j > 0; j -= j & (-j)) {\n            ans += tr[j];\n        }\n        for (int j = x; j <= n; j += j & (-j)) {\n            ++tr[j];\n        }\n    }\n\n    return ans;\n}\n\nيرجى تقديم وصف موجز بلغة طبيعية (docstring) للكود المكتوب بلغة C++ باللغة العربية الفصحى، على ألا يتجاوز 500 حرف.",
      "sw": "long long countHandshakes(int n, const std::vector<int>& order)\n{\n    long long ans = 0;\n    std::vector<int> tr(n + 1, 0);\n    \n    for (int i = 0; i < n; ++i) {\n        int x = order[i] + 1; // Convert 0-indexed to 1-indexed\n        for (int j = x - 1; j > 0; j -= j & (-j)) {\n            ans += tr[j];\n        }\n        for (int j = x; j <= n; j += j & (-j)) {\n            ++tr[j];\n        }\n    }\n\n    return ans;\n}\n\nToa maelezo mafupi ya lugha asilia (docstring) ya msimbo wa CPP kwa Kiswahili kwa kutumia herufi zisizozidi 500.",
      "tr": "long long countHandshakes(int n, const std::vector<int>& order)\n{\n    long long ans = 0;\n    std::vector<int> tr(n + 1, 0);\n    \n    for (int i = 0; i < n; ++i) {\n        int x = order[i] + 1; // Convert 0-indexed to 1-indexed\n        for (int j = x - 1; j > 0; j -= j & (-j)) {\n            ans += tr[j];\n        }\n        for (int j = x; j <= n; j += j & (-j)) {\n            ++tr[j];\n        }\n    }\n\n    return ans;\n}\n\nAşağıdaki CPP kodunun işlevini açıklayan kısa bir doğal dil açıklaması (docstring) sağlayın. Açıklama, Türkçe olarak ve en fazla 500 karakter kullanılarak yazılmalıdır.",
      "vi": "long long countHandshakes(int n, const std::vector<int>& order)\n{\n    long long ans = 0;\n    std::vector<int> tr(n + 1, 0);\n    \n    for (int i = 0; i < n; ++i) {\n        int x = order[i] + 1; // Convert 0-indexed to 1-indexed\n        for (int j = x - 1; j > 0; j -= j & (-j)) {\n            ans += tr[j];\n        }\n        for (int j = x; j <= n; j += j & (-j)) {\n            ++tr[j];\n        }\n    }\n\n    return ans;\n}\n\nCung cấp mô tả ngắn gọn bằng ngôn ngữ tự nhiên (docstring) cho mã CPP bằng tiếng Việt với tối đa 500 ký tự."
    },
    "instruction_bertscore": {
      "es": "0.9695565173899258",
      "arb": "0.8291343722565495",
      "sw": "0.9449839529520998",
      "tr": "0.834597104995771",
      "vi": "0.9171611995893999"
    },
    "level": "",
    "test": "int main() {\n    assert(countHandshakes(4, {2, 1, 3, 0}) == 2);\n    assert(countHandshakes(6, {0, 1, 2, 3, 4, 5}) == 15);\n    assert(countHandshakes(3, {1, 2, 0}) == 1);\n    assert(countHandshakes(4, {3, 2, 1, 0}) == 0);\n    assert(countHandshakes(4, {0, 1, 2, 3}) == 6);\n    assert(countHandshakes(6, {5, 4, 3, 2, 1, 0}) == 0);\n    assert(countHandshakes(4, {0, 2, 1, 3}) == 5);\n    assert(countHandshakes(5, {3, 1, 4, 2, 0}) == 3);\n    assert(countHandshakes(4, {1, 0, 3, 2}) == 4);\n    assert(countHandshakes(3, {2, 0, 1}) == 1);\n    assert(countHandshakes(5, {1, 3, 0, 2, 4}) == 7);\n    assert(countHandshakes(5, {4, 3, 2, 1, 0}) == 0);\n\n    return 0;\n}",
    "entry_point": "countHandshakes",
    "signature": "long long countHandshakes(int n, const std::vector<int>& order)",
    "docstring": {
      "en": "Computes the total number of handshakes in a classroom scenario given the sequence of student IDs as they enter the classroom. It assumes that students have IDs ranging from 0 to N-1 and that each student will shake hands only with students already in the classroom with a smaller ID.\n\nExamples:\n>>> countHandshakes(3, {2, 1, 0})\n0\n",
      "es": "Calcula el número total de apretones de manos en un escenario de aula dado la secuencia de identificaciones de estudiantes a medida que ingresan al aula. Se asume que los estudiantes tienen identificaciones que van de 0 a N-1 y que cada estudiante solo estrechará la mano con estudiantes que ya están en el aula con una identificación menor.\n\nEjemplos:\n>>> countHandshakes(3, {2, 1, 0})\n0",
      "arb": "يحسب العدد الإجمالي للمصافحات في سيناريو الفصل الدراسي بالنظر إلى تسلسل معرفات الطلاب عند دخولهم الفصل. يفترض أن الطلاب لديهم معرفات تتراوح من 0 إلى N-1 وأن كل طالب سيصافح فقط الطلاب الموجودين بالفعل في الفصل بمعرف أصغر.\n\nأمثلة:\n>>> countHandshakes(3, {2, 1, 0})\n0",
      "sw": "Hesabu jumla ya mikono iliyoshikana katika hali ya darasani ukizingatia mlolongo wa vitambulisho vya wanafunzi wanapoingia darasani. Inadhani kwamba wanafunzi wana vitambulisho vinavyotoka 0 hadi N-1 na kwamba kila mwanafunzi atashikana mikono tu na wanafunzi ambao tayari wapo darasani wenye kitambulisho kidogo.\n\nMifano:\n>>> countHandshakes(3, {2, 1, 0})\n0\n",
      "tr": "Sınıfa giren öğrenci kimlik numaralarının sırasına göre bir sınıf senaryosunda toplam el sıkışma sayısını hesaplar. Öğrencilerin kimlik numaralarının 0'dan N-1'e kadar olduğu ve her öğrencinin yalnızca sınıfta zaten bulunan ve daha küçük kimlik numarasına sahip öğrencilerle el sıkışacağı varsayılır.\n\nÖrnekler:\n>>> countHandshakes(3, {2, 1, 0})\n0",
      "vi": "Tính tổng số lần bắt tay trong một kịch bản lớp học dựa trên trình tự các ID sinh viên khi họ vào lớp. Giả sử rằng các sinh viên có ID từ 0 đến N-1 và mỗi sinh viên chỉ bắt tay với những sinh viên đã có mặt trong lớp với ID nhỏ hơn.\n\nVí dụ:\n>>> countHandshakes(3, {2, 1, 0})\n0"
    },
    "docstring_bertscore": {
      "es": "0.9657003071725144",
      "arb": "0.971715232371013",
      "sw": "0.9690829825615386",
      "tr": "0.9093595941134925",
      "vi": "0.9395059256735386"
    }
  },
  {
    "task_id": "CPP/38",
    "prompt": {
      "en": "#include <cassert>\n#include <cstdio>\n/**\n * Given n positive integers representing the count of each number from 1 to n,\n * find the maximum sum of the mode (most frequent element) for all prefixes of\n * a sequence constructed from these numbers. The mode is the largest number among\n * the most frequent elements in a sequence.\n * \n * Example:\n * >>> maxModeSum(3, {1, 2, 3})\n * 17\n * A sequence that reaches its maximum value is (3,2,3,1,2,2).\n */\nlong long maxModeSum(int n, const int* counts)",
      "es": "#include <cassert>\n#include <cstdio>\n/**\n * Dado n números enteros positivos que representan la cantidad de cada número de 1 a n,\n * encuentra la suma máxima del modo (elemento más frecuente) para todos los prefijos de\n * una secuencia construida a partir de estos números. El modo es el número más grande entre\n * los elementos más frecuentes en una secuencia.\n * \n * Ejemplo:\n * >>> maxModeSum(3, {1, 2, 3})\n * 17\n * Una secuencia que alcanza su valor máximo es (3,2,3,1,2,2).\n */\nlong long maxModeSum(int n, const int* counts)",
      "arb": "#include <cassert>\n#include <cstdio>\n/**\n * معطى n من الأعداد الصحيحة الموجبة التي تمثل عدد كل رقم من 1 إلى n،\n * ابحث عن الحد الأقصى لمجموع النمط (العنصر الأكثر تكرارًا) لجميع البادئات\n * لتسلسل مُنشأ من هذه الأرقام. النمط هو أكبر رقم بين\n * العناصر الأكثر تكرارًا في تسلسل.\n * \n * مثال:\n * >>> maxModeSum(3, {1, 2, 3})\n * 17\n * تسلسل يصل إلى قيمته القصوى هو (3,2,3,1,2,2).\n */\nlong long maxModeSum(int n, const int* counts)",
      "sw": "#include <cassert>\n#include <cstdio>\n/**\n * Ukipewa n nambari chanya zinazowakilisha idadi ya kila nambari kutoka 1 hadi n,\n * pata jumla ya juu zaidi ya hali (kipengele kinachojitokeza mara nyingi zaidi) kwa viambishi vyote vya\n * mlolongo uliojengwa kutoka kwa nambari hizi. Hali ni nambari kubwa zaidi kati ya\n * vipengele vinavyojitokeza mara nyingi zaidi katika mlolongo.\n * \n * Mfano:\n * >>> maxModeSum(3, {1, 2, 3})\n * 17\n * Mlolongo unaofikia thamani yake ya juu zaidi ni (3,2,3,1,2,2).\n */\nlong long maxModeSum(int n, const int* counts)",
      "tr": "#include <cassert>\n#include <cstdio>\n/**\n * 1'den n'e kadar olan her sayının sayısını temsil eden n pozitif tamsayı verildiğinde,\n * bu sayılardan oluşturulan bir dizinin tüm ön ekleri için modun (en sık görülen eleman) maksimum\n * toplamını bulun. Mod, bir dizideki en sık görülen elemanlar arasında en büyük sayıdır.\n * \n * Örnek:\n * >>> maxModeSum(3, {1, 2, 3})\n * 17\n * Maksimum değerine ulaşan bir dizi (3,2,3,1,2,2) şeklindedir.\n */\nlong long maxModeSum(int n, const int* counts)",
      "vi": "#include <cassert>\n#include <cstdio>\n/**\n * Cho n số nguyên dương đại diện cho số lượng của mỗi số từ 1 đến n,\n * tìm tổng lớn nhất của mode (phần tử xuất hiện nhiều nhất) cho tất cả các tiền tố của\n * một dãy được tạo từ các số này. Mode là số lớn nhất trong số\n * các phần tử xuất hiện nhiều nhất trong một dãy.\n * \n * Ví dụ:\n * >>> maxModeSum(3, {1, 2, 3})\n * 17\n * Một dãy đạt giá trị lớn nhất là (3,2,3,1,2,2).\n */\nlong long maxModeSum(int n, const int* counts)"
    },
    "prompt_bertscore": {
      "es": "0.9943420135962212",
      "arb": "0.9847384333035654",
      "sw": "0.960134882526298",
      "tr": "0.9676311931065547",
      "vi": "0.9692569827753251"
    },
    "canonical_solution": "{\n    long long ans = 0;\n    int mx = 0;\n    long long f[100000];\n    for (int i = 0; i <= n; ++i) f[i] = 0;\n\n    for (int i = n; i > 0; --i) {\n        while (mx < counts[i - 1]) {\n            mx++;\n            f[mx] = f[mx - 1] + i;\n        }\n        ans += f[counts[i - 1]];\n    }\n    return ans;\n}",
    "instruction": {
      "en": "long long maxModeSum(int n, const int* counts)\n{\n    long long ans = 0;\n    int mx = 0;\n    long long f[100000];\n    for (int i = 0; i <= n; ++i) f[i] = 0;\n\n    for (int i = n; i > 0; --i) {\n        while (mx < counts[i - 1]) {\n            mx++;\n            f[mx] = f[mx - 1] + i;\n        }\n        ans += f[counts[i - 1]];\n    }\n    return ans;\n}\n\nProvide a concise natural language description (docstring) of the CPP code in English using at most 500 characters.",
      "es": "long long maxModeSum(int n, const int* counts)\n{\n    long long ans = 0;\n    int mx = 0;\n    long long f[100000];\n    for (int i = 0; i <= n; ++i) f[i] = 0;\n\n    for (int i = n; i > 0; --i) {\n        while (mx < counts[i - 1]) {\n            mx++;\n            f[mx] = f[mx - 1] + i;\n        }\n        ans += f[counts[i - 1]];\n    }\n    return ans;\n}\n\nProporcione una descripción concisa en lenguaje natural (docstring) del código CPP en español utilizando como máximo 500 caracteres.",
      "arb": "long long maxModeSum(int n, const int* counts)\n{\n    long long ans = 0;\n    int mx = 0;\n    long long f[100000];\n    for (int i = 0; i <= n; ++i) f[i] = 0;\n\n    for (int i = n; i > 0; --i) {\n        while (mx < counts[i - 1]) {\n            mx++;\n            f[mx] = f[mx - 1] + i;\n        }\n        ans += f[counts[i - 1]];\n    }\n    return ans;\n}\n\nيرجى تقديم وصف موجز بلغة طبيعية (docstring) للكود المكتوب بلغة C++ باللغة العربية الفصحى، بحيث لا يتجاوز 500 حرف.",
      "sw": "long long maxModeSum(int n, const int* counts)\n{\n    long long ans = 0;\n    int mx = 0;\n    long long f[100000];\n    for (int i = 0; i <= n; ++i) f[i] = 0;\n\n    for (int i = n; i > 0; --i) {\n        while (mx < counts[i - 1]) {\n            mx++;\n            f[mx] = f[mx - 1] + i;\n        }\n        ans += f[counts[i - 1]];\n    }\n    return ans;\n}\n\nToa maelezo mafupi ya lugha asilia (docstring) ya msimbo wa CPP kwa Kiswahili kwa kutumia herufi zisizozidi 500.",
      "tr": "long long maxModeSum(int n, const int* counts)\n{\n    long long ans = 0;\n    int mx = 0;\n    long long f[100000];\n    for (int i = 0; i <= n; ++i) f[i] = 0;\n\n    for (int i = n; i > 0; --i) {\n        while (mx < counts[i - 1]) {\n            mx++;\n            f[mx] = f[mx - 1] + i;\n        }\n        ans += f[counts[i - 1]];\n    }\n    return ans;\n}\n\nAşağıdaki CPP kodunun işlevini açıklayan, en fazla 500 karakter uzunluğunda, özlü bir doğal dil açıklaması (docstring) sağlayın.",
      "vi": "long long maxModeSum(int n, const int* counts)\n{\n    long long ans = 0;\n    int mx = 0;\n    long long f[100000];\n    for (int i = 0; i <= n; ++i) f[i] = 0;\n\n    for (int i = n; i > 0; --i) {\n        while (mx < counts[i - 1]) {\n            mx++;\n            f[mx] = f[mx - 1] + i;\n        }\n        ans += f[counts[i - 1]];\n    }\n    return ans;\n}\n\nCung cấp mô tả ngắn gọn bằng ngôn ngữ tự nhiên (docstring) cho mã CPP bằng tiếng Việt với tối đa 500 ký tự."
    },
    "instruction_bertscore": {
      "es": "0.9695565173899258",
      "arb": "0.8291343722565495",
      "sw": "0.9449839529520998",
      "tr": "0.8552588358614012",
      "vi": "0.9171611995893999"
    },
    "level": "",
    "test": "int main() {\n    int a1[] = {1, 3, 2};\n    int a2[] = {4, 1, 2, 3};\n    int a3[] = {1, 1};\n    int a4[] = {1, 2, 3, 4, 5};\n    int a5[] = {100000};\n    int a6[] = {5, 3, 2, 4, 1};\n    int a7[] = {100000, 100000, 100000};\n    int a8[] = {2, 2, 5};\n    int a9[] = {4, 4, 4, 4};\n    int a10[] = {1, 2, 3, 4, 5, 6};\n    int a11[] = {3, 1, 2};\n\n    assert(maxModeSum(3, a1) == 17);\n    assert(maxModeSum(4, a2) == 37);\n    assert(maxModeSum(2, a3) == 4);\n    assert(maxModeSum(5, a4) == 75);\n    assert(maxModeSum(1, a5) == 100000);\n    assert(maxModeSum(5, a6) == 62);\n    assert(maxModeSum(3, a7) == 900000);\n    assert(maxModeSum(3, a8) == 27);\n    assert(maxModeSum(4, a9) == 64);\n    assert(maxModeSum(6, a10) == 126);\n    assert(maxModeSum(3, a11) == 16);\n    return 0;\n}",
    "entry_point": "maxModeSum",
    "signature": "long long maxModeSum(int n, const int* counts)",
    "docstring": {
      "en": "Given n positive integers representing the count of each number from 1 to n,\nfind the maximum sum of the mode (most frequent element) for all prefixes of\na sequence constructed from these numbers. The mode is the largest number among\nthe most frequent elements in a sequence.\n\nExample:\n>>> maxModeSum(3, {1, 2, 3})\n17\nA sequence that reaches its maximum value is (3,2,3,1,2,2).\n",
      "es": "Dado n enteros positivos que representan el conteo de cada número del 1 al n, encuentra la suma máxima de la moda (elemento más frecuente) para todos los prefijos de una secuencia construida a partir de estos números. La moda es el número más grande entre los elementos más frecuentes en una secuencia.\n\nEjemplo:\n>>> maxModeSum(3, {1, 2, 3})\n17\nUna secuencia que alcanza su valor máximo es (3,2,3,1,2,2).",
      "arb": "معطى n من الأعداد الصحيحة الموجبة التي تمثل عدد كل رقم من 1 إلى n، \nابحث عن الحد الأقصى لمجموع النمط (العنصر الأكثر تكرارًا) لجميع البادئات \nلسلسلة تم إنشاؤها من هذه الأرقام. النمط هو أكبر عدد بين \nالعناصر الأكثر تكرارًا في سلسلة.\n\nمثال:\n>>> maxModeSum(3, {1, 2, 3})\n17\nسلسلة تصل إلى قيمتها القصوى هي (3,2,3,1,2,2).",
      "sw": "Kutolewa n nambari chanya zinazowakilisha idadi ya kila nambari kutoka 1 hadi n, pata jumla ya juu zaidi ya hali (kipengele kinachojitokeza mara nyingi zaidi) kwa viambishi vyote vya mlolongo uliotengenezwa kutoka kwa nambari hizi. Hali ni nambari kubwa zaidi kati ya vipengele vinavyojitokeza mara nyingi zaidi katika mlolongo.\n\nMfano:\n>>> maxModeSum(3, {1, 2, 3})\n17\nMlolongo unaofikia thamani yake ya juu zaidi ni (3,2,3,1,2,2).",
      "tr": "Verilen n pozitif tamsayı, 1'den n'e kadar olan her sayının sayısını temsil eder,\nbu sayılardan oluşturulan bir dizinin tüm önekleri için modun (en sık görülen eleman) maksimum toplamını bulun. Mod, bir dizideki en sık görülen elemanlar arasında en büyük sayıdır.\n\nÖrnek:\n>>> maxModeSum(3, {1, 2, 3})\n17\nMaksimum değerine ulaşan bir dizi (3,2,3,1,2,2) şeklindedir.",
      "vi": "Cho n số nguyên dương đại diện cho số lượng của mỗi số từ 1 đến n, tìm tổng lớn nhất của mode (phần tử xuất hiện nhiều nhất) cho tất cả các tiền tố của một dãy được tạo từ các số này. Mode là số lớn nhất trong số các phần tử xuất hiện nhiều nhất trong một dãy.\n\nVí dụ:\n>>> maxModeSum(3, {1, 2, 3})\n17\nMột dãy đạt giá trị tối đa là (3,2,3,1,2,2)."
    },
    "docstring_bertscore": {
      "es": "1",
      "arb": "0.9820837382610341",
      "sw": "0.951054494657288",
      "tr": "0.9330706985887702",
      "vi": "0.9611802742216845"
    }
  },
  {
    "task_id": "CPP/39",
    "prompt": {
      "en": "#include <cassert>\n#include <iostream>\n#include <vector>\n/**\n * Given an array A of integers, the task is to calculate the sum of the XOR of all subarrays.\n * A subarray is defined by a pair of indices (L, R) such that 1 <= L <= R <= n, where n is the size of the array.\n * The XOR sum of a subarray is the result of XORing all elements from L to R.\n * The final result is the sum of the XOR sums for all possible subarrays.\n *\n * Example cases:\n *     >>> sumOfXorSubarrays({1, 2, 3, 4, 5}, 5)\n *     39\n */\nlong long sumOfXorSubarrays(const std::vector<int>& A)",
      "es": "#include <cassert>\n#include <iostream>\n#include <vector>\n/**\n * Dado un array A de enteros, la tarea es calcular la suma del XOR de todos los subarrays.\n * Un subarray se define por un par de índices (L, R) tal que 1 <= L <= R <= n, donde n es el tamaño del array.\n * La suma XOR de un subarray es el resultado de aplicar XOR a todos los elementos desde L hasta R.\n * El resultado final es la suma de las sumas XOR para todos los subarrays posibles.\n *\n * Casos de ejemplo:\n *     >>> sumOfXorSubarrays({1, 2, 3, 4, 5}, 5)\n *     39\n */\nlong long sumOfXorSubarrays(const std::vector<int>& A)",
      "arb": "#include <cassert>\n#include <iostream>\n#include <vector>\n/**\n * بالنظر إلى مصفوفة A من الأعداد الصحيحة، المهمة هي حساب مجموع XOR لجميع المصفوفات الجزئية.\n * تُعرّف المصفوفة الجزئية بواسطة زوج من الفهارس (L, R) بحيث 1 <= L <= R <= n، حيث n هو حجم المصفوفة.\n * مجموع XOR لمصفوفة جزئية هو نتيجة XOR لجميع العناصر من L إلى R.\n * النتيجة النهائية هي مجموع مجموعات XOR لجميع المصفوفات الجزئية الممكنة.\n *\n * أمثلة الحالات:\n *     >>> sumOfXorSubarrays({1, 2, 3, 4, 5}, 5)\n *     39\n */\nlong long sumOfXorSubarrays(const std::vector<int>& A)",
      "sw": "#include <cassert>\n#include <iostream>\n#include <vector>\n/**\n * Ukipewa safu A ya nambari za mzima, kazi ni kuhesabu jumla ya XOR ya vipengele vidogo vyote.\n * Kipengele kidogo kinafafanuliwa na jozi ya faharasa (L, R) ambapo 1 <= L <= R <= n, ambapo n ni ukubwa wa safu.\n * Jumla ya XOR ya kipengele kidogo ni matokeo ya XOR ya vipengele vyote kutoka L hadi R.\n * Matokeo ya mwisho ni jumla ya jumla za XOR kwa vipengele vidogo vyote vinavyowezekana.\n *\n * Mifano ya kesi:\n *     >>> sumOfXorSubarrays({1, 2, 3, 4, 5}, 5)\n *     39\n */\nlong long sumOfXorSubarrays(const std::vector<int>& A)",
      "tr": "#include <cassert>\n#include <iostream>\n#include <vector>\n/**\n * Bir tamsayı dizisi A verildiğinde, görev tüm alt dizilerin XOR toplamını hesaplamaktır.\n * Bir alt dizi, 1 <= L <= R <= n olacak şekilde (L, R) indeks çifti ile tanımlanır, burada n dizinin boyutudur.\n * Bir alt dizinin XOR toplamı, L'den R'ye kadar olan tüm elemanların XOR'lanması sonucu elde edilir.\n * Nihai sonuç, tüm olası alt diziler için XOR toplamlarının toplamıdır.\n *\n * Örnek durumlar:\n *     >>> sumOfXorSubarrays({1, 2, 3, 4, 5}, 5)\n *     39\n */\nlong long sumOfXorSubarrays(const std::vector<int>& A)",
      "vi": "#include <cassert>\n#include <iostream>\n#include <vector>\n/**\n * Cho một mảng A gồm các số nguyên, nhiệm vụ là tính tổng của XOR của tất cả các mảng con.\n * Một mảng con được định nghĩa bởi một cặp chỉ số (L, R) sao cho 1 <= L <= R <= n, trong đó n là kích thước của mảng.\n * Tổng XOR của một mảng con là kết quả của việc XOR tất cả các phần tử từ L đến R.\n * Kết quả cuối cùng là tổng của các tổng XOR cho tất cả các mảng con có thể.\n *\n * Các trường hợp ví dụ:\n *     >>> sumOfXorSubarrays({1, 2, 3, 4, 5}, 5)\n *     39\n */\nlong long sumOfXorSubarrays(const std::vector<int>& A)"
    },
    "prompt_bertscore": {
      "es": "0.991835695448323",
      "arb": "0.9661525885501309",
      "sw": "0.9811704357690357",
      "tr": "0.9755106616918277",
      "vi": "0.9956064946018893"
    },
    "canonical_solution": "{\n    int n = A.size();\n    std::vector<long long> q(n + 1, 0);\n    std::vector<std::vector<long long>> w(21, std::vector<long long>(2, 0));\n    long long ans = 0;\n\n    for (int i = 1; i <= n; ++i) {\n        q[i] = q[i - 1] ^ A[i - 1];\n    }\n\n    for (int i = 0; i <= n; ++i) {\n        for (int j = 20; j >= 0; --j) {\n            w[j][(q[i] >> j) & 1]++;\n        }\n    }\n\n    for (int i = 0; i <= 20; ++i) {\n        ans += w[i][0] * w[i][1] * (1LL << i);\n    }\n\n    return ans;\n}",
    "instruction": {
      "en": "long long sumOfXorSubarrays(const std::vector<int>& A)\n{\n    int n = A.size();\n    std::vector<long long> q(n + 1, 0);\n    std::vector<std::vector<long long>> w(21, std::vector<long long>(2, 0));\n    long long ans = 0;\n\n    for (int i = 1; i <= n; ++i) {\n        q[i] = q[i - 1] ^ A[i - 1];\n    }\n\n    for (int i = 0; i <= n; ++i) {\n        for (int j = 20; j >= 0; --j) {\n            w[j][(q[i] >> j) & 1]++;\n        }\n    }\n\n    for (int i = 0; i <= 20; ++i) {\n        ans += w[i][0] * w[i][1] * (1LL << i);\n    }\n\n    return ans;\n}\n\nProvide a concise natural language description (docstring) of the CPP code in English using at most 500 characters.",
      "es": "long long sumOfXorSubarrays(const std::vector<int>& A)\n{\n    int n = A.size();\n    std::vector<long long> q(n + 1, 0);\n    std::vector<std::vector<long long>> w(21, std::vector<long long>(2, 0));\n    long long ans = 0;\n\n    for (int i = 1; i <= n; ++i) {\n        q[i] = q[i - 1] ^ A[i - 1];\n    }\n\n    for (int i = 0; i <= n; ++i) {\n        for (int j = 20; j >= 0; --j) {\n            w[j][(q[i] >> j) & 1]++;\n        }\n    }\n\n    for (int i = 0; i <= 20; ++i) {\n        ans += w[i][0] * w[i][1] * (1LL << i);\n    }\n\n    return ans;\n}\n\nProporcione una descripción concisa en lenguaje natural (docstring) del código CPP en español utilizando un máximo de 500 caracteres.",
      "arb": "long long sumOfXorSubarrays(const std::vector<int>& A)\n{\n    int n = A.size();\n    std::vector<long long> q(n + 1, 0);\n    std::vector<std::vector<long long>> w(21, std::vector<long long>(2, 0));\n    long long ans = 0;\n\n    for (int i = 1; i <= n; ++i) {\n        q[i] = q[i - 1] ^ A[i - 1];\n    }\n\n    for (int i = 0; i <= n; ++i) {\n        for (int j = 20; j >= 0; --j) {\n            w[j][(q[i] >> j) & 1]++;\n        }\n    }\n\n    for (int i = 0; i <= 20; ++i) {\n        ans += w[i][0] * w[i][1] * (1LL << i);\n    }\n\n    return ans;\n}\n\nيرجى تقديم وصف موجز بلغة طبيعية (docstring) للكود المكتوب بلغة C++ باللغة العربية الفصحى، بحيث لا يتجاوز 500 حرف.",
      "sw": "long long sumOfXorSubarrays(const std::vector<int>& A)\n{\n    int n = A.size();\n    std::vector<long long> q(n + 1, 0);\n    std::vector<std::vector<long long>> w(21, std::vector<long long>(2, 0));\n    long long ans = 0;\n\n    for (int i = 1; i <= n; ++i) {\n        q[i] = q[i - 1] ^ A[i - 1];\n    }\n\n    for (int i = 0; i <= n; ++i) {\n        for (int j = 20; j >= 0; --j) {\n            w[j][(q[i] >> j) & 1]++;\n        }\n    }\n\n    for (int i = 0; i <= 20; ++i) {\n        ans += w[i][0] * w[i][1] * (1LL << i);\n    }\n\n    return ans;\n}\n\nToa maelezo mafupi ya lugha asilia (docstring) ya msimbo wa CPP kwa Kiswahili kwa kutumia herufi zisizozidi 500.",
      "tr": "long long sumOfXorSubarrays(const std::vector<int>& A)\n{\n    int n = A.size();\n    std::vector<long long> q(n + 1, 0);\n    std::vector<std::vector<long long>> w(21, std::vector<long long>(2, 0));\n    long long ans = 0;\n\n    for (int i = 1; i <= n; ++i) {\n        q[i] = q[i - 1] ^ A[i - 1];\n    }\n\n    for (int i = 0; i <= n; ++i) {\n        for (int j = 20; j >= 0; --j) {\n            w[j][(q[i] >> j) & 1]++;\n        }\n    }\n\n    for (int i = 0; i <= 20; ++i) {\n        ans += w[i][0] * w[i][1] * (1LL << i);\n    }\n\n    return ans;\n}\n\nAşağıdaki CPP kodunun Türkçe'de en fazla 500 karakter kullanarak doğal dilde kısa bir açıklamasını (docstring) sağlayın.",
      "vi": "long long sumOfXorSubarrays(const std::vector<int>& A)\n{\n    int n = A.size();\n    std::vector<long long> q(n + 1, 0);\n    std::vector<std::vector<long long>> w(21, std::vector<long long>(2, 0));\n    long long ans = 0;\n\n    for (int i = 1; i <= n; ++i) {\n        q[i] = q[i - 1] ^ A[i - 1];\n    }\n\n    for (int i = 0; i <= n; ++i) {\n        for (int j = 20; j >= 0; --j) {\n            w[j][(q[i] >> j) & 1]++;\n        }\n    }\n\n    for (int i = 0; i <= 20; ++i) {\n        ans += w[i][0] * w[i][1] * (1LL << i);\n    }\n\n    return ans;\n}\n\nCung cấp mô tả ngắn gọn bằng ngôn ngữ tự nhiên (docstring) cho mã CPP bằng tiếng Việt với tối đa 500 ký tự."
    },
    "instruction_bertscore": {
      "es": "0.9695565173899258",
      "arb": "0.8291343722565495",
      "sw": "0.9449839529520998",
      "tr": "0.8483371629734784",
      "vi": "0.9171611995893999"
    },
    "level": "",
    "test": "int main() {\n    assert(sumOfXorSubarrays({1, 2, 3, 4, 5}) == 39);\n    assert(sumOfXorSubarrays({1, 1, 1}) == 4);\n    assert(sumOfXorSubarrays({2, 3, 1}) == 9);\n    assert(sumOfXorSubarrays({4, 5, 7, 9}) == 74);\n    assert(sumOfXorSubarrays({0, 0, 0, 0}) == 0);\n    assert(sumOfXorSubarrays({8, 8, 8, 8, 8}) == 72);\n    assert(sumOfXorSubarrays({3, 6, 9, 12, 15}) == 125);\n    assert(sumOfXorSubarrays({10, 20, 30, 40, 50}) == 390);\n    assert(sumOfXorSubarrays({16, 16, 16, 16, 16, 16}) == 192);\n    assert(sumOfXorSubarrays({1, 3, 5, 7, 9, 11, 13}) == 192);\n    assert(sumOfXorSubarrays({0, 1, 2, 3, 4, 5, 6, 7, 8, 9}) == 218);\n\n\n    return 0;\n}",
    "entry_point": "sumOfXorSubarrays",
    "signature": "long long sumOfXorSubarrays(const std::vector<int>& A)",
    "docstring": {
      "en": "Given an array A of integers, the task is to calculate the sum of the XOR of all subarrays.\nA subarray is defined by a pair of indices (L, R) such that 1 <= L <= R <= n, where n is the size of the array.\nThe XOR sum of a subarray is the result of XORing all elements from L to R.\nThe final result is the sum of the XOR sums for all possible subarrays.\n\nExample cases:\n    >>> sumOfXorSubarrays({1, 2, 3, 4, 5}, 5)\n    39\n",
      "es": "Dado un array A de enteros, la tarea es calcular la suma del XOR de todos los subarrays.  \nUn subarray se define por un par de índices (L, R) tal que 1 <= L <= R <= n, donde n es el tamaño del array.  \nLa suma XOR de un subarray es el resultado de aplicar XOR a todos los elementos desde L hasta R.  \nEl resultado final es la suma de las sumas XOR para todos los subarrays posibles.\n\nCasos de ejemplo:\n    >>> sumOfXorSubarrays({1, 2, 3, 4, 5}, 5)\n    39",
      "arb": "بالنظر إلى مصفوفة A من الأعداد الصحيحة، المهمة هي حساب مجموع عملية XOR لجميع المصفوفات الفرعية. \nيتم تعريف المصفوفة الفرعية بواسطة زوج من الفهارس (L, R) بحيث 1 <= L <= R <= n، حيث n هو حجم المصفوفة. \nمجموع XOR لمصفوفة فرعية هو نتيجة عملية XOR لجميع العناصر من L إلى R. \nالنتيجة النهائية هي مجموع نتائج XOR لجميع المصفوفات الفرعية الممكنة.\n\nحالات المثال:\n    >>> sumOfXorSubarrays({1, 2, 3, 4, 5}, 5)\n    39",
      "sw": "Kwa kupewa safu A ya nambari za mzima, kazi ni kuhesabu jumla ya XOR ya sehemu ndogo zote.\nSehemu ndogo inafafanuliwa na jozi ya fahirisi (L, R) ambapo 1 <= L <= R <= n, ambapo n ni ukubwa wa safu.\nJumla ya XOR ya sehemu ndogo ni matokeo ya XOR ya vipengele vyote kutoka L hadi R.\nMatokeo ya mwisho ni jumla ya jumla za XOR kwa sehemu ndogo zote zinazowezekana.\n\nMifano ya kesi:\n    >>> sumOfXorSubarrays({1, 2, 3, 4, 5}, 5)\n    39",
      "tr": "Verilen bir tamsayı dizisi A için, tüm alt dizilerin XOR toplamını hesaplama görevi.\nBir alt dizi, (L, R) indeks çifti ile tanımlanır ve burada 1 <= L <= R <= n, n dizinin boyutudur.\nBir alt dizinin XOR toplamı, L'den R'ye kadar olan tüm elemanların XOR'lanması sonucudur.\nNihai sonuç, tüm olası alt diziler için XOR toplamlarının toplamıdır.\n\nÖrnek durumlar:\n    >>> sumOfXorSubarrays({1, 2, 3, 4, 5}, 5)\n    39",
      "vi": "Cho một mảng A gồm các số nguyên, nhiệm vụ là tính tổng của phép XOR của tất cả các mảng con. \nMột mảng con được định nghĩa bởi một cặp chỉ số (L, R) sao cho 1 <= L <= R <= n, trong đó n là kích thước của mảng. \nTổng XOR của một mảng con là kết quả của phép XOR tất cả các phần tử từ L đến R. \nKết quả cuối cùng là tổng của các tổng XOR cho tất cả các mảng con có thể.\n\nCác trường hợp ví dụ:\n    >>> sumOfXorSubarrays({1, 2, 3, 4, 5}, 5)\n    39"
    },
    "docstring_bertscore": {
      "es": "0.9875641491041677",
      "arb": "0.9698397643132816",
      "sw": "0.9781413224582537",
      "tr": "0.9637410170939863",
      "vi": "0.9862134625131305"
    }
  },
  {
    "task_id": "CPP/40",
    "prompt": {
      "en": "#include <cassert>\n#include <cmath>\n#include <cstdio>\n#include <cstdlib>\n/**\n * Given two positive integers n and k, find the number of positive integers x,\n * where 1 <= x <= n, that can be expressed as x = a^b with a and b being\n * positive integers and b >= k. Different legal representations of x are counted\n * only once. For example:\n *     >>> countPowerNumbers(99, 1)\n *     99\n */\nint countPowerNumbers(int n, int k)",
      "es": "#include <cassert>\n#include <cmath>\n#include <cstdio>\n#include <cstdlib>\n/**\n * Dado dos enteros positivos n y k, encuentra el número de enteros positivos x,\n * donde 1 <= x <= n, que pueden expresarse como x = a^b con a y b siendo\n * enteros positivos y b >= k. Diferentes representaciones legales de x se cuentan\n * solo una vez. Por ejemplo:\n *     >>> countPowerNumbers(99, 1)\n *     99\n */\nint countPowerNumbers(int n, int k)",
      "arb": "#include <cassert>\n#include <cmath>\n#include <cstdio>\n#include <cstdlib>\n/**\n * معطى عددين صحيحين موجبين n و k، جد عدد الأعداد الصحيحة الموجبة x،\n * حيث 1 <= x <= n، التي يمكن التعبير عنها كـ x = a^b مع كون a و b\n * أعدادًا صحيحة موجبة و b >= k. يتم احتساب التمثيلات القانونية المختلفة لـ x\n * مرة واحدة فقط. على سبيل المثال:\n *     >>> countPowerNumbers(99, 1)\n *     99\n */\nint countPowerNumbers(int n, int k)",
      "sw": "#include <cassert>\n#include <cmath>\n#include <cstdio>\n#include <cstdlib>\n/**\n * Ukipewa nambari mbili nzima chanya n na k, pata idadi ya nambari chanya x,\n * ambapo 1 <= x <= n, ambazo zinaweza kuonyeshwa kama x = a^b na a na b zikiwa\n * nambari nzima chanya na b >= k. Uwakilishi tofauti halali wa x unahesabiwa\n * mara moja tu. Kwa mfano:\n *     >>> countPowerNumbers(99, 1)\n *     99\n */\nint countPowerNumbers(int n, int k)",
      "tr": "#include <cassert>\n#include <cmath>\n#include <cstdio>\n#include <cstdlib>\n/**\n * İki pozitif tamsayı n ve k verildiğinde, 1 <= x <= n aralığında olan ve\n * x = a^b şeklinde ifade edilebilen pozitif tamsayı x sayısını bulun,\n * burada a ve b pozitif tamsayılar ve b >= k. x'in farklı yasal gösterimleri\n * yalnızca bir kez sayılır. Örneğin:\n *     >>> countPowerNumbers(99, 1)\n *     99\n */\nint countPowerNumbers(int n, int k)",
      "vi": "#include <cassert>\n#include <cmath>\n#include <cstdio>\n#include <cstdlib>\n/**\n * Cho hai số nguyên dương n và k, tìm số lượng số nguyên dương x,\n * với 1 <= x <= n, có thể được biểu diễn dưới dạng x = a^b với a và b là\n * các số nguyên dương và b >= k. Các biểu diễn hợp lệ khác nhau của x chỉ được đếm\n * một lần. Ví dụ:\n *     >>> countPowerNumbers(99, 1)\n *     99\n */\nint countPowerNumbers(int n, int k)"
    },
    "prompt_bertscore": {
      "es": "0.999999801369619",
      "arb": "0.9885948421513577",
      "sw": "0.9946373769728201",
      "tr": "0.9717634995536044",
      "vi": "0.9791179880418022"
    },
    "canonical_solution": "{\n    int count = 0;\n    int x = 0;\n    bool *mp = (bool *)calloc(n + 1, sizeof(bool));\n    \n    for (int i = 2; i <= cbrt(n); ++i) {\n        long long t = i * i;\n        int m = 2;\n        while (t <= n / i) {\n            t *= i;\n            m++;\n            if (m < k || mp[t]) continue;\n            if ((int)sqrt(t) * (int)sqrt(t) == t) x++;\n            mp[t] = true;\n            count++;\n        }\n    }\n    if (k == 1) {\n        count = n;\n    } else if (k >= 3) {\n        count += 1;\n    } else {\n        count += static_cast<int>(sqrt(n)) - x;\n    }\n    free(mp);\n    return count;\n}",
    "instruction": {
      "en": "int countPowerNumbers(int n, int k)\n{\n    int count = 0;\n    int x = 0;\n    bool *mp = (bool *)calloc(n + 1, sizeof(bool));\n    \n    for (int i = 2; i <= cbrt(n); ++i) {\n        long long t = i * i;\n        int m = 2;\n        while (t <= n / i) {\n            t *= i;\n            m++;\n            if (m < k || mp[t]) continue;\n            if ((int)sqrt(t) * (int)sqrt(t) == t) x++;\n            mp[t] = true;\n            count++;\n        }\n    }\n    if (k == 1) {\n        count = n;\n    } else if (k >= 3) {\n        count += 1;\n    } else {\n        count += static_cast<int>(sqrt(n)) - x;\n    }\n    free(mp);\n    return count;\n}\n\nProvide a concise natural language description (docstring) of the CPP code in English using at most 500 characters.",
      "es": "int countPowerNumbers(int n, int k)\n{\n    int count = 0;\n    int x = 0;\n    bool *mp = (bool *)calloc(n + 1, sizeof(bool));\n    \n    for (int i = 2; i <= cbrt(n); ++i) {\n        long long t = i * i;\n        int m = 2;\n        while (t <= n / i) {\n            t *= i;\n            m++;\n            if (m < k || mp[t]) continue;\n            if ((int)sqrt(t) * (int)sqrt(t) == t) x++;\n            mp[t] = true;\n            count++;\n        }\n    }\n    if (k == 1) {\n        count = n;\n    } else if (k >= 3) {\n        count += 1;\n    } else {\n        count += static_cast<int>(sqrt(n)) - x;\n    }\n    free(mp);\n    return count;\n}\n\nProporcione una descripción concisa en lenguaje natural (docstring) del código CPP en español utilizando un máximo de 500 caracteres.",
      "arb": "int countPowerNumbers(int n, int k)\n{\n    int count = 0;\n    int x = 0;\n    bool *mp = (bool *)calloc(n + 1, sizeof(bool));\n    \n    for (int i = 2; i <= cbrt(n); ++i) {\n        long long t = i * i;\n        int m = 2;\n        while (t <= n / i) {\n            t *= i;\n            m++;\n            if (m < k || mp[t]) continue;\n            if ((int)sqrt(t) * (int)sqrt(t) == t) x++;\n            mp[t] = true;\n            count++;\n        }\n    }\n    if (k == 1) {\n        count = n;\n    } else if (k >= 3) {\n        count += 1;\n    } else {\n        count += static_cast<int>(sqrt(n)) - x;\n    }\n    free(mp);\n    return count;\n}\n\nيرجى تقديم وصف موجز بلغة طبيعية (docstring) لشفرة CPP باللغة العربية الفصحى باستخدام ما لا يزيد عن 500 حرف.",
      "sw": "int countPowerNumbers(int n, int k)\n{\n    int count = 0;\n    int x = 0;\n    bool *mp = (bool *)calloc(n + 1, sizeof(bool));\n    \n    for (int i = 2; i <= cbrt(n); ++i) {\n        long long t = i * i;\n        int m = 2;\n        while (t <= n / i) {\n            t *= i;\n            m++;\n            if (m < k || mp[t]) continue;\n            if ((int)sqrt(t) * (int)sqrt(t) == t) x++;\n            mp[t] = true;\n            count++;\n        }\n    }\n    if (k == 1) {\n        count = n;\n    } else if (k >= 3) {\n        count += 1;\n    } else {\n        count += static_cast<int>(sqrt(n)) - x;\n    }\n    free(mp);\n    return count;\n}\n\nToa maelezo mafupi ya lugha asilia (docstring) ya msimbo wa CPP kwa Kiswahili kwa kutumia herufi zisizozidi 500.",
      "tr": "int countPowerNumbers(int n, int k)\n{\n    int count = 0;\n    int x = 0;\n    bool *mp = (bool *)calloc(n + 1, sizeof(bool));\n    \n    for (int i = 2; i <= cbrt(n); ++i) {\n        long long t = i * i;\n        int m = 2;\n        while (t <= n / i) {\n            t *= i;\n            m++;\n            if (m < k || mp[t]) continue;\n            if ((int)sqrt(t) * (int)sqrt(t) == t) x++;\n            mp[t] = true;\n            count++;\n        }\n    }\n    if (k == 1) {\n        count = n;\n    } else if (k >= 3) {\n        count += 1;\n    } else {\n        count += static_cast<int>(sqrt(n)) - x;\n    }\n    free(mp);\n    return count;\n}\n\nAşağıdaki CPP kodunun işlevini açıklayan kısa bir doğal dil açıklaması (docstring) sağlayın. Açıklama Türkçe olmalı ve en fazla 500 karakter kullanılmalıdır.",
      "vi": "int countPowerNumbers(int n, int k)\n{\n    int count = 0;\n    int x = 0;\n    bool *mp = (bool *)calloc(n + 1, sizeof(bool));\n    \n    for (int i = 2; i <= cbrt(n); ++i) {\n        long long t = i * i;\n        int m = 2;\n        while (t <= n / i) {\n            t *= i;\n            m++;\n            if (m < k || mp[t]) continue;\n            if ((int)sqrt(t) * (int)sqrt(t) == t) x++;\n            mp[t] = true;\n            count++;\n        }\n    }\n    if (k == 1) {\n        count = n;\n    } else if (k >= 3) {\n        count += 1;\n    } else {\n        count += static_cast<int>(sqrt(n)) - x;\n    }\n    free(mp);\n    return count;\n}\n\nCung cấp mô tả ngắn gọn bằng ngôn ngữ tự nhiên (docstring) cho mã CPP bằng tiếng Việt với tối đa 500 ký tự."
    },
    "instruction_bertscore": {
      "es": "0.9695565173899258",
      "arb": "0.9057093636012145",
      "sw": "0.9449839529520998",
      "tr": "0.844042376874742",
      "vi": "0.9171611995893999"
    },
    "level": "",
    "test": "int main() {\n    assert(countPowerNumbers(99, 1) == 99);\n    assert(countPowerNumbers(99, 3) == 7);\n    assert(countPowerNumbers(99, 2) == 12);\n    assert(countPowerNumbers(10, 1) == 10);\n    assert(countPowerNumbers(10, 2) == 4);\n    assert(countPowerNumbers(500, 1) == 500);\n    assert(countPowerNumbers(500, 2) == 30);\n    assert(countPowerNumbers(500, 3) == 13);\n    assert(countPowerNumbers(1000, 1) == 1000);\n    assert(countPowerNumbers(1000, 2) == 41);\n    assert(countPowerNumbers(1000, 3) == 17);\n    assert(countPowerNumbers(1000, 93) == 1);\n    assert(countPowerNumbers(50, 2) == 10);\n    assert(countPowerNumbers(50, 3) == 5);\n    assert(countPowerNumbers(2, 3) == 1);\n    return 0;\n}",
    "entry_point": "countPowerNumbers",
    "signature": "int countPowerNumbers(int n, int k)",
    "docstring": {
      "en": "Given two positive integers n and k, find the number of positive integers x, where 1 <= x <= n, that can be expressed as x = a^b with a and b being positive integers and b >= k. Different legal representations of x are counted only once. For example:\n    >>> countPowerNumbers(99, 1)\n    99\n",
      "es": "Dado dos enteros positivos n y k, encuentra el número de enteros positivos x, donde 1 <= x <= n, que pueden expresarse como x = a^b con a y b siendo enteros positivos y b >= k. Diferentes representaciones legales de x se cuentan solo una vez. Por ejemplo:\n    >>> countPowerNumbers(99, 1)\n    99",
      "arb": "بالنظر إلى عددين صحيحين موجبين n و k، ابحث عن عدد الأعداد الصحيحة الموجبة x، حيث 1 <= x <= n، والتي يمكن التعبير عنها كـ x = a^b مع كون a و b أعداد صحيحة موجبة و b >= k. يتم احتساب التمثيلات القانونية المختلفة لـ x مرة واحدة فقط. على سبيل المثال:\n    >>> countPowerNumbers(99, 1)\n    99",
      "sw": "Ukipewa nambari mbili nzima chanya n na k, tafuta idadi ya nambari chanya x, ambapo 1 <= x <= n, ambazo zinaweza kuonyeshwa kama x = a^b huku a na b zikiwa nambari nzima chanya na b >= k. Uwiano tofauti halali wa x unahesabiwa mara moja tu. Kwa mfano:\n    >>> countPowerNumbers(99, 1)\n    99",
      "tr": "İki pozitif tamsayı n ve k verildiğinde, 1 <= x <= n olacak şekilde x = a^b olarak ifade edilebilen pozitif tamsayı x'lerin sayısını bulun, burada a ve b pozitif tamsayılar ve b >= k'dir. x'in farklı yasal gösterimleri yalnızca bir kez sayılır. Örneğin:\n    >>> countPowerNumbers(99, 1)\n    99",
      "vi": "Cho hai số nguyên dương n và k, tìm số lượng số nguyên dương x, với 1 <= x <= n, có thể được biểu diễn dưới dạng x = a^b với a và b là các số nguyên dương và b >= k. Các biểu diễn hợp lệ khác nhau của x chỉ được đếm một lần. Ví dụ:\n    >>> countPowerNumbers(99, 1)\n    99"
    },
    "docstring_bertscore": {
      "es": "0.999999801369619",
      "arb": "0.9822966700295035",
      "sw": "0.9907092625574742",
      "tr": "0.9562143160654313",
      "vi": "0.9676123232203563"
    }
  },
  {
    "task_id": "CPP/41",
    "prompt": {
      "en": "#include <cassert>\n/* Given three integers n, m, and k, find the number of sequences consisting of n '(' and m ')',\nsuch that the longest balanced subsequence is of length 2 * k. The result should be calculated modulo 1,000,000,007 (10^9 + 7).\n\nFor example:\n    >>> countBalancedSubsequences(2, 2, 2)\n    2\n*/\nlong long countBalancedSubsequences(long long n, long long m, long long k)",
      "es": "#include <cassert>\n/* Dados tres enteros n, m, y k, encuentra el número de secuencias que consisten en n '(' y m ')',\ntal que la subsecuencia balanceada más larga tenga una longitud de 2 * k. El resultado debe ser calculado módulo 1,000,000,007 (10^9 + 7).\n\nPor ejemplo:\n    >>> countBalancedSubsequences(2, 2, 2)\n    2\n*/\nlong long countBalancedSubsequences(long long n, long long m, long long k)",
      "arb": "#include <cassert>\n/* معطى ثلاثة أعداد صحيحة n، m، و k، ابحث عن عدد التتابعات التي تتكون من n '(' و m ')',\nبحيث يكون أطول تتابع متوازن بطول 2 * k. يجب حساب النتيجة بتطبيق باقي القسمة على 1,000,000,007 (10^9 + 7).\n\nعلى سبيل المثال:\n    >>> countBalancedSubsequences(2, 2, 2)\n    2\n*/\nlong long countBalancedSubsequences(long long n, long long m, long long k)",
      "sw": "#include <cassert>\n/* Ukipewa nambari tatu n, m, na k, pata idadi ya misururu inayojumuisha n '(' na m ')',\nhivyo kwamba mfuatano mrefu zaidi ulio sawa ni wa urefu 2 * k. Matokeo yanapaswa kuhesabiwa kwa modulo 1,000,000,007 (10^9 + 7).\n\nKwa mfano:\n    >>> countBalancedSubsequences(2, 2, 2)\n    2\n*/\nlong long countBalancedSubsequences(long long n, long long m, long long k)",
      "tr": "#include <cassert>\n/* Üç tamsayı n, m ve k verildiğinde, n '(' ve m ')' karakterlerinden oluşan dizilerin sayısını bulun,\nöyle ki en uzun dengeli alt dizi uzunluğu 2 * k olsun. Sonuç 1,000,000,007 (10^9 + 7) modunda hesaplanmalıdır.\n\nÖrneğin:\n    >>> countBalancedSubsequences(2, 2, 2)\n    2\n*/\nlong long countBalancedSubsequences(long long n, long long m, long long k)",
      "vi": "#include <cassert>\n/* Cho ba số nguyên n, m và k, tìm số lượng dãy bao gồm n '(' và m ')',\nsao cho dãy con cân bằng dài nhất có độ dài 2 * k. Kết quả nên được tính theo modulo 1,000,000,007 (10^9 + 7).\n\nVí dụ:\n    >>> countBalancedSubsequences(2, 2, 2)\n    2\n*/\nlong long countBalancedSubsequences(long long n, long long m, long long k)"
    },
    "prompt_bertscore": {
      "es": "0.9895502542841356",
      "arb": "0.9924578058017243",
      "sw": "0.9887964519881082",
      "tr": "0.9747411675956984",
      "vi": "0.9895431035904183"
    },
    "canonical_solution": "{\n    const long long P = static_cast<long long>(1e9) + 7;\n    static long long C[4001][4001] = {0};\n\n    // Compute binomial coefficients only once.\n    if (C[0][0] == 0) {\n        for (long long i = 0; i <= 4000; i++) C[i][0] = 1;\n        for (long long i = 1; i <= 4000; i++)\n            for (long long j = 1; j <= i; j++)\n                C[i][j] = (C[i - 1][j - 1] + C[i - 1][j]) % P;\n    }\n\n    // Calculate the number of balanced subsequences.\n    if (k > n || k > m) return 0;\n    return (C[n + m][k] - C[n + m][k - 1] + P) % P;\n}",
    "instruction": {
      "en": "long long countBalancedSubsequences(long long n, long long m, long long k)\n{\n    const long long P = static_cast<long long>(1e9) + 7;\n    static long long C[4001][4001] = {0};\n\n    // Compute binomial coefficients only once.\n    if (C[0][0] == 0) {\n        for (long long i = 0; i <= 4000; i++) C[i][0] = 1;\n        for (long long i = 1; i <= 4000; i++)\n            for (long long j = 1; j <= i; j++)\n                C[i][j] = (C[i - 1][j - 1] + C[i - 1][j]) % P;\n    }\n\n    // Calculate the number of balanced subsequences.\n    if (k > n || k > m) return 0;\n    return (C[n + m][k] - C[n + m][k - 1] + P) % P;\n}\n\nProvide a concise natural language description (docstring) of the CPP code in English using at most 500 characters.",
      "es": "long long countBalancedSubsequences(long long n, long long m, long long k)\n{\n    const long long P = static_cast<long long>(1e9) + 7;\n    static long long C[4001][4001] = {0};\n\n    // Compute binomial coefficients only once.\n    if (C[0][0] == 0) {\n        for (long long i = 0; i <= 4000; i++) C[i][0] = 1;\n        for (long long i = 1; i <= 4000; i++)\n            for (long long j = 1; j <= i; j++)\n                C[i][j] = (C[i - 1][j - 1] + C[i - 1][j]) % P;\n    }\n\n    // Calculate the number of balanced subsequences.\n    if (k > n || k > m) return 0;\n    return (C[n + m][k] - C[n + m][k - 1] + P) % P;\n}\n\nProporcione una descripción concisa en lenguaje natural (docstring) del código CPP en español utilizando como máximo 500 caracteres.",
      "arb": "long long countBalancedSubsequences(long long n, long long m, long long k)\n{\n    const long long P = static_cast<long long>(1e9) + 7;\n    static long long C[4001][4001] = {0};\n\n    // Compute binomial coefficients only once.\n    if (C[0][0] == 0) {\n        for (long long i = 0; i <= 4000; i++) C[i][0] = 1;\n        for (long long i = 1; i <= 4000; i++)\n            for (long long j = 1; j <= i; j++)\n                C[i][j] = (C[i - 1][j - 1] + C[i - 1][j]) % P;\n    }\n\n    // Calculate the number of balanced subsequences.\n    if (k > n || k > m) return 0;\n    return (C[n + m][k] - C[n + m][k - 1] + P) % P;\n}\n\nيرجى تقديم وصف موجز بلغة طبيعية (docstring) للكود المكتوب بلغة C++ باللغة العربية الفصحى، بحيث لا يتجاوز 500 حرف.",
      "sw": "long long countBalancedSubsequences(long long n, long long m, long long k)\n{\n    const long long P = static_cast<long long>(1e9) + 7;\n    static long long C[4001][4001] = {0};\n\n    // Compute binomial coefficients only once.\n    if (C[0][0] == 0) {\n        for (long long i = 0; i <= 4000; i++) C[i][0] = 1;\n        for (long long i = 1; i <= 4000; i++)\n            for (long long j = 1; j <= i; j++)\n                C[i][j] = (C[i - 1][j - 1] + C[i - 1][j]) % P;\n    }\n\n    // Calculate the number of balanced subsequences.\n    if (k > n || k > m) return 0;\n    return (C[n + m][k] - C[n + m][k - 1] + P) % P;\n}\n\nToa maelezo mafupi ya lugha asilia (docstring) ya msimbo wa CPP kwa Kiswahili kwa kutumia herufi zisizozidi 500.",
      "tr": "long long countBalancedSubsequences(long long n, long long m, long long k)\n{\n    const long long P = static_cast<long long>(1e9) + 7;\n    static long long C[4001][4001] = {0};\n\n    // Compute binomial coefficients only once.\n    if (C[0][0] == 0) {\n        for (long long i = 0; i <= 4000; i++) C[i][0] = 1;\n        for (long long i = 1; i <= 4000; i++)\n            for (long long j = 1; j <= i; j++)\n                C[i][j] = (C[i - 1][j - 1] + C[i - 1][j]) % P;\n    }\n\n    // Calculate the number of balanced subsequences.\n    if (k > n || k > m) return 0;\n    return (C[n + m][k] - C[n + m][k - 1] + P) % P;\n}\n\nAşağıdaki CPP kodunun işlevini açıklayan, en fazla 500 karakterlik özlü bir doğal dil açıklaması (docstring) sağlayın.",
      "vi": "long long countBalancedSubsequences(long long n, long long m, long long k)\n{\n    const long long P = static_cast<long long>(1e9) + 7;\n    static long long C[4001][4001] = {0};\n\n    // Compute binomial coefficients only once.\n    if (C[0][0] == 0) {\n        for (long long i = 0; i <= 4000; i++) C[i][0] = 1;\n        for (long long i = 1; i <= 4000; i++)\n            for (long long j = 1; j <= i; j++)\n                C[i][j] = (C[i - 1][j - 1] + C[i - 1][j]) % P;\n    }\n\n    // Calculate the number of balanced subsequences.\n    if (k > n || k > m) return 0;\n    return (C[n + m][k] - C[n + m][k - 1] + P) % P;\n}\n\nCung cấp mô tả ngắn gọn bằng ngôn ngữ tự nhiên (docstring) cho mã CPP bằng tiếng Việt với tối đa 500 ký tự."
    },
    "instruction_bertscore": {
      "es": "0.9695565173899258",
      "arb": "0.8291343722565495",
      "sw": "0.9449839529520998",
      "tr": "0.8686119618568525",
      "vi": "0.9483503406498791"
    },
    "level": "",
    "test": "int main() {\n    assert(countBalancedSubsequences(2, 2, 2) == 2);\n    assert(countBalancedSubsequences(3, 2, 3) == 0);\n    assert(countBalancedSubsequences(3, 2, 1) == 4);\n    assert(countBalancedSubsequences(4, 3, 2) == 14);\n    assert(countBalancedSubsequences(5, 5, 2) == 35);\n    assert(countBalancedSubsequences(6, 1, 1) == 6);\n    assert(countBalancedSubsequences(1, 6, 1) == 6);\n    assert(countBalancedSubsequences(7, 2, 2) == 27);\n    assert(countBalancedSubsequences(8, 3, 3) == 110);\n    assert(countBalancedSubsequences(10, 10, 5) == 10659);\n    assert(countBalancedSubsequences(20, 20, 10) == 574221648);\n    assert(countBalancedSubsequences(2000, 2000, 1000) == 854104531);\n    assert(countBalancedSubsequences(2000, 1999, 1000) == 334874485);\n    assert(countBalancedSubsequences(2000, 2000, 1999) == 259428024);\n    return 0;\n}",
    "entry_point": "countBalancedSubsequences",
    "signature": "long long countBalancedSubsequences(long long n, long long m, long long k)",
    "docstring": {
      "en": "Given three integers n, m, and k, find the number of sequences consisting of n '(' and m ')',\nsuch that the longest balanced subsequence is of length 2 * k. The result should be calculated modulo 1,000,000,007 (10^9 + 7).\n\nFor example:\n    >>> countBalancedSubsequences(2, 2, 2)\n    2\n",
      "es": "Dado tres enteros n, m, y k, encuentra el número de secuencias que consisten en n '(' y m ')', \ntal que la subsecuencia balanceada más larga tenga una longitud de 2 * k. El resultado debe ser calculado módulo 1,000,000,007 (10^9 + 7).\n\nPor ejemplo:\n    >>> countBalancedSubsequences(2, 2, 2)\n    2",
      "arb": "بالنظر إلى ثلاثة أعداد صحيحة n و m و k، ابحث عن عدد التسلسلات المكونة من n '(' و m ')',\nبحيث يكون أطول تسلسل متوازن بطول 2 * k. يجب حساب النتيجة بتقسيمها على 1,000,000,007 (10^9 + 7).\n\nعلى سبيل المثال:\n    >>> countBalancedSubsequences(2, 2, 2)\n    2",
      "sw": "Kwa kupewa nambari tatu nzima n, m, na k, pata idadi ya mlolongo unaojumuisha n '(' na m ')', \nhivyo kwamba mlolongo mrefu zaidi ulio na usawa una urefu wa 2 * k. Matokeo yanapaswa kuhesabiwa kwa modulo 1,000,000,007 (10^9 + 7).\n\nKwa mfano:\n    >>> countBalancedSubsequences(2, 2, 2)\n    2",
      "tr": "Üç tam sayı n, m ve k verildiğinde, n '(' ve m ')' karakterlerinden oluşan dizilerin sayısını bulun, öyle ki en uzun dengeli alt dizi uzunluğu 2 * k olsun. Sonuç 1,000,000,007 (10^9 + 7) modunda hesaplanmalıdır.\n\nÖrneğin:\n    >>> countBalancedSubsequences(2, 2, 2)\n    2",
      "vi": "Được cho ba số nguyên n, m và k, tìm số lượng dãy bao gồm n dấu '(' và m dấu ')', sao cho dãy con cân bằng dài nhất có độ dài 2 * k. Kết quả nên được tính theo modulo 1,000,000,007 (10^9 + 7).\n\nVí dụ:\n    >>> countBalancedSubsequences(2, 2, 2)\n    2"
    },
    "docstring_bertscore": {
      "es": "0.9874193475563933",
      "arb": "0.9658641772368682",
      "sw": "0.9883090130330485",
      "tr": "0.9725582197081251",
      "vi": "0.9838467815230998"
    }
  },
  {
    "task_id": "CPP/42",
    "prompt": {
      "en": "#include <cassert>\n#include <cstdio>\n/**\n * Given a rectangle paper of size n x m placed on a plane Cartesian coordinate \n * system with its bottom-left corner at (0,0) and top-right corner at (n,m), \n * you need to calculate the expected number of operations to cut the paper such that \n * the remaining area is less than k. In each operation, a line is randomly chosen \n * that is parallel to the axes, passes through points with integer coordinates, \n * and cuts through (not just touching the edge) the paper. The bottom or right part \n * of the paper along this line is then discarded. The answer should be modulo 10^9+7.\n *\n * For example:\n *     >>> expectedCuts(3, 3, 4)\n *     3\n *     >>> expectedCuts(5, 5, 12)\n *     2\n */\nlong long expectedCuts(int n, int m, long long k)",
      "es": "#include <cassert>\n#include <cstdio>\n/**\n * Dado un papel rectangular de tamaño n x m colocado en un sistema de coordenadas \n * cartesianas en un plano, con su esquina inferior izquierda en (0,0) y la esquina \n * superior derecha en (n,m), necesitas calcular el número esperado de operaciones \n * para cortar el papel de tal manera que el área restante sea menor que k. En cada \n * operación, se elige aleatoriamente una línea que es paralela a los ejes, pasa por \n * puntos con coordenadas enteras, y corta (no solo toca el borde) el papel. La parte \n * inferior o derecha del papel a lo largo de esta línea se descarta. La respuesta \n * debe ser módulo 10^9+7.\n *\n * Por ejemplo:\n *     >>> expectedCuts(3, 3, 4)\n *     3\n *     >>> expectedCuts(5, 5, 12)\n *     2\n */\nlong long expectedCuts(int n, int m, long long k)",
      "arb": "#include <cassert>\n#include <cstdio>\n/**\n * بالنظر إلى ورقة مستطيلة بحجم n x m موضوعة على نظام إحداثيات ديكارتي \n * على مستوى مع الزاوية السفلية اليسرى عند (0,0) والزاوية العلوية اليمنى عند (n,m)، \n * تحتاج إلى حساب العدد المتوقع من العمليات لقطع الورقة بحيث \n * تكون المساحة المتبقية أقل من k. في كل عملية، يتم اختيار خط عشوائي \n * يكون موازياً للمحاور، ويمر عبر نقاط ذات إحداثيات صحيحة، \n * ويقطع الورقة (وليس فقط لمس الحافة). يتم بعد ذلك التخلص من الجزء السفلي أو الأيمن \n * من الورقة على طول هذا الخط. يجب أن تكون الإجابة موديولو 10^9+7.\n *\n * على سبيل المثال:\n *     >>> expectedCuts(3, 3, 4)\n *     3\n *     >>> expectedCuts(5, 5, 12)\n *     2\n */\nlong long expectedCuts(int n, int m, long long k)",
      "sw": "#include <cassert>\n#include <cstdio>\n/**\n * Ukipewa karatasi ya mstatili ya ukubwa n x m iliyowekwa kwenye mfumo wa kuratibu wa \n * Cartesian kwenye ndege na kona yake ya chini-kushoto iko kwenye (0,0) na kona ya juu-kulia \n * iko kwenye (n,m), unahitaji kuhesabu idadi inayotarajiwa ya operesheni za kukata karatasi \n * ili eneo lililobaki liwe chini ya k. Katika kila operesheni, mstari unachaguliwa kwa nasibu \n * ambao ni sambamba na mhimili, unapita kupitia pointi zenye kuratibu za nambari kamili, \n * na unakata (si kugusa tu ukingo) karatasi. Sehemu ya chini au ya kulia ya karatasi \n * kando ya mstari huu kisha inatupwa. Jibu linapaswa kuwa modulo 10^9+7.\n *\n * Kwa mfano:\n *     >>> expectedCuts(3, 3, 4)\n *     3\n *     >>> expectedCuts(5, 5, 12)\n *     2\n */\nlong long expectedCuts(int n, int m, long long k)",
      "tr": "#include <cassert>\n#include <cstdio>\n/**\n * n x m boyutlarında bir dikdörtgen kağıt, alt-sol köşesi (0,0) ve üst-sağ köşesi (n,m) \n * olan bir Kartezyen koordinat sistemine yerleştirilmiştir. Kağıdı kesmek için gereken \n * beklenen işlem sayısını hesaplamanız gerekmektedir, böylece kalan alan k'dan küçük olur. \n * Her işlemde, eksenlere paralel, tam sayı koordinatlarına sahip noktalardan geçen ve \n * kağıdı kesen (sadece kenara dokunmayan) bir çizgi rastgele seçilir. Bu çizgi boyunca \n * kağıdın alt veya sağ kısmı atılır. Cevap 10^9+7 modunda olmalıdır.\n *\n * Örneğin:\n *     >>> expectedCuts(3, 3, 4)\n *     3\n *     >>> expectedCuts(5, 5, 12)\n *     2\n */\nlong long expectedCuts(int n, int m, long long k)",
      "vi": "#include <cassert>\n#include <cstdio>\n/**\n * Cho một tờ giấy hình chữ nhật kích thước n x m đặt trên hệ tọa độ phẳng \n * Cartesian với góc dưới bên trái tại (0,0) và góc trên bên phải tại (n,m), \n * bạn cần tính số lượng thao tác kỳ vọng để cắt tờ giấy sao cho diện tích còn lại \n * nhỏ hơn k. Trong mỗi thao tác, một đường thẳng được chọn ngẫu nhiên \n * song song với các trục, đi qua các điểm có tọa độ nguyên, \n * và cắt qua (không chỉ chạm vào cạnh) tờ giấy. Phần dưới hoặc bên phải \n * của tờ giấy dọc theo đường này sau đó bị loại bỏ. Kết quả nên được lấy modulo 10^9+7.\n *\n * Ví dụ:\n *     >>> expectedCuts(3, 3, 4)\n *     3\n *     >>> expectedCuts(5, 5, 12)\n *     2\n */\nlong long expectedCuts(int n, int m, long long k)"
    },
    "prompt_bertscore": {
      "es": "0.9683095158577888",
      "arb": "0.9671181308323415",
      "sw": "0.9620075697586948",
      "tr": "0.9501662195933",
      "vi": "0.9526560514195723"
    },
    "canonical_solution": "{\n    const int MD = 1000000007;\n    const int N = 1000000;\n    int vv[N * 2 + 1], i, j;\n    long long ans = 1;\n\n    vv[1] = 1;\n    for (i = 2; i <= N * 2; i++)\n        vv[i] = (long long)vv[i - MD % i] * (MD / i + 1) % MD;\n\n    if (k > (long long)n * m) {\n        return 0;\n    }\n\n    for (i = (k + m - 1) / m; i < n; i++)\n        ans = (ans + vv[i + (k + i - 1) / i - 1]) % MD;\n    for (j = (k + n - 1) / n; j < m; j++)\n        ans = (ans + vv[(k + j - 1) / j + j - 1]) % MD;\n\n    return ans;\n}",
    "instruction": {
      "en": "long long expectedCuts(int n, int m, long long k)\n{\n    const int MD = 1000000007;\n    const int N = 1000000;\n    int vv[N * 2 + 1], i, j;\n    long long ans = 1;\n\n    vv[1] = 1;\n    for (i = 2; i <= N * 2; i++)\n        vv[i] = (long long)vv[i - MD % i] * (MD / i + 1) % MD;\n\n    if (k > (long long)n * m) {\n        return 0;\n    }\n\n    for (i = (k + m - 1) / m; i < n; i++)\n        ans = (ans + vv[i + (k + i - 1) / i - 1]) % MD;\n    for (j = (k + n - 1) / n; j < m; j++)\n        ans = (ans + vv[(k + j - 1) / j + j - 1]) % MD;\n\n    return ans;\n}\n\nProvide a concise natural language description (docstring) of the CPP code in English using at most 500 characters.",
      "es": "long long expectedCuts(int n, int m, long long k)\n{\n    const int MD = 1000000007;\n    const int N = 1000000;\n    int vv[N * 2 + 1], i, j;\n    long long ans = 1;\n\n    vv[1] = 1;\n    for (i = 2; i <= N * 2; i++)\n        vv[i] = (long long)vv[i - MD % i] * (MD / i + 1) % MD;\n\n    if (k > (long long)n * m) {\n        return 0;\n    }\n\n    for (i = (k + m - 1) / m; i < n; i++)\n        ans = (ans + vv[i + (k + i - 1) / i - 1]) % MD;\n    for (j = (k + n - 1) / n; j < m; j++)\n        ans = (ans + vv[(k + j - 1) / j + j - 1]) % MD;\n\n    return ans;\n}\n\nProporcione una descripción concisa en lenguaje natural (docstring) del código CPP en español utilizando como máximo 500 caracteres.",
      "arb": "long long expectedCuts(int n, int m, long long k)\n{\n    const int MD = 1000000007;\n    const int N = 1000000;\n    int vv[N * 2 + 1], i, j;\n    long long ans = 1;\n\n    vv[1] = 1;\n    for (i = 2; i <= N * 2; i++)\n        vv[i] = (long long)vv[i - MD % i] * (MD / i + 1) % MD;\n\n    if (k > (long long)n * m) {\n        return 0;\n    }\n\n    for (i = (k + m - 1) / m; i < n; i++)\n        ans = (ans + vv[i + (k + i - 1) / i - 1]) % MD;\n    for (j = (k + n - 1) / n; j < m; j++)\n        ans = (ans + vv[(k + j - 1) / j + j - 1]) % MD;\n\n    return ans;\n}\n\nيرجى تقديم وصف موجز بلغة طبيعية (docstring) للشفرة البرمجية بلغة C++ باللغة العربية الفصحى، بحيث لا يتجاوز 500 حرف.",
      "sw": "long long expectedCuts(int n, int m, long long k)\n{\n    const int MD = 1000000007;\n    const int N = 1000000;\n    int vv[N * 2 + 1], i, j;\n    long long ans = 1;\n\n    vv[1] = 1;\n    for (i = 2; i <= N * 2; i++)\n        vv[i] = (long long)vv[i - MD % i] * (MD / i + 1) % MD;\n\n    if (k > (long long)n * m) {\n        return 0;\n    }\n\n    for (i = (k + m - 1) / m; i < n; i++)\n        ans = (ans + vv[i + (k + i - 1) / i - 1]) % MD;\n    for (j = (k + n - 1) / n; j < m; j++)\n        ans = (ans + vv[(k + j - 1) / j + j - 1]) % MD;\n\n    return ans;\n}\n\nToa maelezo mafupi ya lugha ya asili (docstring) ya msimbo wa CPP kwa Kiswahili kwa kutumia herufi zisizozidi 500.",
      "tr": "long long expectedCuts(int n, int m, long long k)\n{\n    const int MD = 1000000007;\n    const int N = 1000000;\n    int vv[N * 2 + 1], i, j;\n    long long ans = 1;\n\n    vv[1] = 1;\n    for (i = 2; i <= N * 2; i++)\n        vv[i] = (long long)vv[i - MD % i] * (MD / i + 1) % MD;\n\n    if (k > (long long)n * m) {\n        return 0;\n    }\n\n    for (i = (k + m - 1) / m; i < n; i++)\n        ans = (ans + vv[i + (k + i - 1) / i - 1]) % MD;\n    for (j = (k + n - 1) / n; j < m; j++)\n        ans = (ans + vv[(k + j - 1) / j + j - 1]) % MD;\n\n    return ans;\n}\n\nAşağıdaki CPP kodunun işlevini açıklayan, en fazla 500 karakter uzunluğunda bir doğal dil açıklaması (docstring) sağlayın.",
      "vi": "long long expectedCuts(int n, int m, long long k)\n{\n    const int MD = 1000000007;\n    const int N = 1000000;\n    int vv[N * 2 + 1], i, j;\n    long long ans = 1;\n\n    vv[1] = 1;\n    for (i = 2; i <= N * 2; i++)\n        vv[i] = (long long)vv[i - MD % i] * (MD / i + 1) % MD;\n\n    if (k > (long long)n * m) {\n        return 0;\n    }\n\n    for (i = (k + m - 1) / m; i < n; i++)\n        ans = (ans + vv[i + (k + i - 1) / i - 1]) % MD;\n    for (j = (k + n - 1) / n; j < m; j++)\n        ans = (ans + vv[(k + j - 1) / j + j - 1]) % MD;\n\n    return ans;\n}\n\nCung cấp mô tả ngắn gọn bằng ngôn ngữ tự nhiên (docstring) cho mã CPP bằng tiếng Việt với tối đa 500 ký tự."
    },
    "instruction_bertscore": {
      "es": "0.9695565173899258",
      "arb": "0.8654990265252738",
      "sw": "0.9176812139269492",
      "tr": "0.8326749587984964",
      "vi": "0.9343528576983505"
    },
    "level": "",
    "test": "int main() {\n    assert(expectedCuts(2, 4, 10) == 0);\n    assert(expectedCuts(2, 4, 8) == 1);\n    assert(expectedCuts(2, 4, 2) == 833333342);\n    assert(expectedCuts(2, 4, 6) == 250000003);\n    assert(expectedCuts(3, 3, 4) == 666666673);\n    assert(expectedCuts(5, 5, 12) == 666666673);\n    assert(expectedCuts(6, 7, 20) == 722222229);\n    assert(expectedCuts(8, 8, 30) == 72727275);\n    assert(expectedCuts(10, 10, 50) == 714285721);\n    assert(expectedCuts(1, 10, 5) == 945634929);\n    assert(expectedCuts(10, 1, 5) == 945634929);\n    return 0;\n}",
    "entry_point": "expectedCuts",
    "signature": "long long expectedCuts(int n, int m, long long k)",
    "docstring": {
      "en": "Given a rectangle paper of size n x m placed on a plane Cartesian coordinate \n system with its bottom-left corner at (0,0) and top-right corner at (n,m), \n you need to calculate the expected number of operations to cut the paper such that \n the remaining area is less than k. In each operation, a line is randomly chosen \n that is parallel to the axes, passes through points with integer coordinates, \n and cuts through (not just touching the edge) the paper. The bottom or right part \n of the paper along this line is then discarded. The answer should be modulo 10^9+7.\n\nFor example:\n    >>> expectedCuts(3, 3, 4)\n    3\n    >>> expectedCuts(5, 5, 12)\n    2\n",
      "es": "Dado un papel rectangular de tamaño n x m colocado en un sistema de coordenadas \ncartesianas en un plano, con su esquina inferior izquierda en (0,0) y la esquina superior derecha en (n,m), \nnecesitas calcular el número esperado de operaciones para cortar el papel de tal manera que \nel área restante sea menor que k. En cada operación, se elige aleatoriamente una línea \nque es paralela a los ejes, pasa por puntos con coordenadas enteras, \ny corta (no solo toca el borde) el papel. La parte inferior o derecha \ndel papel a lo largo de esta línea se descarta. La respuesta debe ser módulo 10^9+7.\n\nPor ejemplo:\n    >>> expectedCuts(3, 3, 4)\n    3\n    >>> expectedCuts(5, 5, 12)\n    2",
      "arb": "معطى ورقة مستطيلة بحجم n x m موضوعة على نظام إحداثيات ديكارتي مستوي مع الزاوية السفلية اليسرى عند (0,0) والزاوية العلوية اليمنى عند (n,m)، تحتاج إلى حساب العدد المتوقع من العمليات لقطع الورقة بحيث تكون المساحة المتبقية أقل من k. في كل عملية، يتم اختيار خط عشوائي موازٍ للمحاور، يمر عبر نقاط ذات إحداثيات صحيحة، ويقطع (وليس فقط يلامس الحافة) الورقة. يتم بعد ذلك التخلص من الجزء السفلي أو الأيمن من الورقة على طول هذا الخط. يجب أن تكون الإجابة موديولو 10^9+7.\n\nعلى سبيل المثال:\n    >>> expectedCuts(3, 3, 4)\n    3\n    >>> expectedCuts(5, 5, 12)\n    2",
      "sw": "Ukipata karatasi ya mstatili ya ukubwa n x m iliyowekwa kwenye mfumo wa kuratibu wa Cartesian kwenye ndege na kona yake ya chini-kushoto iko kwenye (0,0) na kona ya juu-kulia iko kwenye (n,m), unahitaji kuhesabu idadi inayotarajiwa ya operesheni za kukata karatasi hiyo ili eneo lililosalia liwe chini ya k. Katika kila operesheni, mstari unachaguliwa kwa nasibu ambao ni sambamba na mhimili, unapita kwenye pointi zenye kuratibu za nambari kamili, na unakata (sio kugusa tu ukingo) karatasi hiyo. Sehemu ya chini au ya kulia ya karatasi kando ya mstari huu kisha hutupwa. Jibu linapaswa kuwa moduli 10^9+7.\n\nKwa mfano:\n    >>> expectedCuts(3, 3, 4)\n    3\n    >>> expectedCuts(5, 5, 12)\n    2",
      "tr": "Verilen bir dikdörtgen kağıt, (0,0) noktasında sol alt köşesi ve (n,m) noktasında sağ üst köşesi olan bir düzlem Kartezyen koordinat sistemine yerleştirilmiştir. Kağıdın kalan alanının k'dan küçük olması için gereken beklenen işlem sayısını hesaplamanız gerekmektedir. Her işlemde, eksenlere paralel, tam sayı koordinatlarına sahip noktalardan geçen ve kağıdı kesen (sadece kenara dokunmayan) bir çizgi rastgele seçilir. Bu çizgi boyunca kağıdın alt veya sağ kısmı atılır. Cevap 10^9+7 modunda olmalıdır.\n\nÖrneğin:\n    >>> expectedCuts(3, 3, 4)\n    3\n    >>> expectedCuts(5, 5, 12)\n    2",
      "vi": "Cho một tờ giấy hình chữ nhật kích thước n x m đặt trên hệ tọa độ Đề-các phẳng với góc dưới bên trái tại (0,0) và góc trên bên phải tại (n,m), bạn cần tính số lần cắt dự kiến để cắt tờ giấy sao cho diện tích còn lại nhỏ hơn k. Trong mỗi lần cắt, một đường thẳng được chọn ngẫu nhiên song song với các trục, đi qua các điểm có tọa độ nguyên và cắt qua (không chỉ chạm vào cạnh) tờ giấy. Phần dưới hoặc bên phải của tờ giấy dọc theo đường này sau đó bị loại bỏ. Câu trả lời phải được lấy modulo 10^9+7.\n\nVí dụ:\n    >>> expectedCuts(3, 3, 4)\n    3\n    >>> expectedCuts(5, 5, 12)\n    2"
    },
    "docstring_bertscore": {
      "es": "0.972888343401405",
      "arb": "0.9550366365362755",
      "sw": "0.9496394518227955",
      "tr": "0.9270903350765719",
      "vi": "0.9368649361272987"
    }
  },
  {
    "task_id": "CPP/43",
    "prompt": {
      "en": "#include <bits/stdc++.h>\n/*\nGiven a permutation q of n elements and an integer k, find the number of permutations p of n elements such that f(p) = q, where f(p) is the lexicographically smallest permutation that can be obtained by dividing p into exactly k non-empty contiguous segments and sorting each segment (i.e., choose k-1 breakpoints 1 <= x_1 < x_2 < ... < x_{k-1} < n, and divide it into [1, x_1], (x_1, x_2], ..., (x_{k-1}, n]). The result should be modulo 998244353.\n\n    >>> countPermutations(2, 1, [1, 2])\n    2\n\n*/\nint countPermutations(int n, int k, int qq[])",
      "es": "#include <bits/stdc++.h>\n/*\nDada una permutación q de n elementos y un entero k, encuentra el número de permutaciones p de n elementos tal que f(p) = q, donde f(p) es la permutación lexicográficamente más pequeña que se puede obtener dividiendo p en exactamente k segmentos contiguos no vacíos y ordenando cada segmento (es decir, elige k-1 puntos de corte 1 <= x_1 < x_2 < ... < x_{k-1} < n, y divídelo en [1, x_1], (x_1, x_2], ..., (x_{k-1}, n]). El resultado debe ser módulo 998244353.\n\n    >>> countPermutations(2, 1, [1, 2])\n    2\n\n*/\nint countPermutations(int n, int k, int qq[])",
      "arb": "#include <bits/stdc++.h>\n/*\nمعطى تبديل q لعدد n من العناصر وعدد صحيح k، ابحث عن عدد التبديلات p لعدد n من العناصر بحيث يكون f(p) = q، حيث أن f(p) هو التبديل الأصغر لغوياً الذي يمكن الحصول عليه عن طريق تقسيم p إلى k مقاطع متجاورة غير فارغة بالضبط وترتيب كل مقطع (أي اختيار k-1 نقاط تقسيم 1 <= x_1 < x_2 < ... < x_{k-1} < n، وتقسيمه إلى [1, x_1]، (x_1, x_2]، ...، (x_{k-1}, n]). يجب أن تكون النتيجة موديولو 998244353.\n\n    >>> countPermutations(2, 1, [1, 2])\n    2\n\n*/\nint countPermutations(int n, int k, int qq[])",
      "sw": "#include <bits/stdc++.h>\n/*\nUkipiwa mpangilio q wa vipengele n na nambari k, pata idadi ya mipangilio p ya vipengele n kama f(p) = q, ambapo f(p) ni mpangilio mdogo zaidi kwa mpangilio wa lexicographically ambao unaweza kupatikana kwa kugawanya p katika sehemu k zisizo tupu na kupanga kila sehemu (yaani, chagua sehemu k-1 za kuvunja 1 <= x_1 < x_2 < ... < x_{k-1} < n, na igawanye katika [1, x_1], (x_1, x_2], ..., (x_{k-1}, n]). Matokeo yanapaswa kuwa modulo 998244353.\n\n    >>> countPermutations(2, 1, [1, 2])\n    2\n\n*/\nint countPermutations(int n, int k, int qq[])",
      "tr": "#include <bits/stdc++.h>\n/*\nn elemanlı bir q permütasyonu ve bir k tam sayısı verildiğinde, f(p) = q olacak şekilde n elemanlı kaç tane p permütasyonu olduğunu bulun, burada f(p), p'yi tam olarak k boş olmayan ardışık segmente bölerek ve her segmenti sıralayarak elde edilebilecek sözlük sırasına göre en küçük permütasyondur (yani, k-1 tane kırılma noktası seçin 1 <= x_1 < x_2 < ... < x_{k-1} < n ve [1, x_1], (x_1, x_2], ..., (x_{k-1}, n] şeklinde bölün). Sonuç 998244353 ile mod alınmalıdır.\n\n    >>> countPermutations(2, 1, [1, 2])\n    2\n\n*/\nint countPermutations(int n, int k, int qq[])",
      "vi": "#include <bits/stdc++.h>\n/*\nCho một hoán vị q của n phần tử và một số nguyên k, tìm số lượng hoán vị p của n phần tử sao cho f(p) = q, trong đó f(p) là hoán vị nhỏ nhất theo từ điển có thể thu được bằng cách chia p thành chính xác k đoạn liên tiếp không rỗng và sắp xếp mỗi đoạn (tức là, chọn k-1 điểm ngắt 1 <= x_1 < x_2 < ... < x_{k-1} < n, và chia nó thành [1, x_1], (x_1, x_2], ..., (x_{k-1}, n]). Kết quả nên được lấy modulo 998244353.\n\n    >>> countPermutations(2, 1, [1, 2])\n    2\n\n*/\nint countPermutations(int n, int k, int qq[])"
    },
    "prompt_bertscore": {
      "es": "0.9823936016554485",
      "arb": "0.9902261934707973",
      "sw": "0.9739555844387054",
      "tr": "0.9744920850978807",
      "vi": "0.9929100871793407"
    },
    "canonical_solution": "{\n    const int N = 505, P = 998244353;\n    int q[N], m, dp[N][N], jc[N], f[N], ans;\n    memset(q, 0, sizeof(q));\n    memset(dp, 0, sizeof(dp));\n    memset(jc, 0, sizeof(jc));\n    memset(f, 0, sizeof(f));\n    ans = 0;\n\n    for (int i = 1; i <= n; i++)\n        q[i] = qq[i - 1];\n    dp[0][0] = f[0] = 1;\n    for (int i = jc[0] = 1; i <= n; i++)\n        jc[i] = 1LL * jc[i - 1] * i % P;\n    for (int i = 1; i <= n; i++)\n    {\n        f[i] = jc[i];\n        for (int j = 1; j < i; j++)\n            f[i] = (f[i] + P - 1LL * f[j] * jc[i - j] % P) % P;\n    }\n    for (int i = 1; i <= n; i++)\n    {\n        for (int j = 0; j < i; j++)\n            for (int k = 1; k <= n; k++)\n                dp[i][k] = (dp[i][k] + dp[j][k - 1] * 1LL * f[i - j] % P) % P;\n    }\n    m = 0;\n    for (int i = 1; i <= n; i++)\n        if (q[i] > q[i + 1])\n        {\n            m = i;\n            break;\n        }\n    if (m == n)\n    {\n        for (int i = k; i <= n; i++)\n            ans = (ans + dp[n][i]) % P;\n    }\n    else\n    {\n        for (int i = m + 1; i <= n; i++)\n        {\n            if (i != m + 1 && (q[i - 1] > q[i] || q[i] < q[m]))\n                break;\n            int c = k + i - n - 1;\n            if (c >= 0)\n                ans = (ans + dp[m][c] * 1LL * jc[i - m - 1] % P) % P;\n        }\n    }\n    return ans;\n}",
    "instruction": {
      "en": "int countPermutations(int n, int k, int qq[])\n{\n    const int N = 505, P = 998244353;\n    int q[N], m, dp[N][N], jc[N], f[N], ans;\n    memset(q, 0, sizeof(q));\n    memset(dp, 0, sizeof(dp));\n    memset(jc, 0, sizeof(jc));\n    memset(f, 0, sizeof(f));\n    ans = 0;\n\n    for (int i = 1; i <= n; i++)\n        q[i] = qq[i - 1];\n    dp[0][0] = f[0] = 1;\n    for (int i = jc[0] = 1; i <= n; i++)\n        jc[i] = 1LL * jc[i - 1] * i % P;\n    for (int i = 1; i <= n; i++)\n    {\n        f[i] = jc[i];\n        for (int j = 1; j < i; j++)\n            f[i] = (f[i] + P - 1LL * f[j] * jc[i - j] % P) % P;\n    }\n    for (int i = 1; i <= n; i++)\n    {\n        for (int j = 0; j < i; j++)\n            for (int k = 1; k <= n; k++)\n                dp[i][k] = (dp[i][k] + dp[j][k - 1] * 1LL * f[i - j] % P) % P;\n    }\n    m = 0;\n    for (int i = 1; i <= n; i++)\n        if (q[i] > q[i + 1])\n        {\n            m = i;\n            break;\n        }\n    if (m == n)\n    {\n        for (int i = k; i <= n; i++)\n            ans = (ans + dp[n][i]) % P;\n    }\n    else\n    {\n        for (int i = m + 1; i <= n; i++)\n        {\n            if (i != m + 1 && (q[i - 1] > q[i] || q[i] < q[m]))\n                break;\n            int c = k + i - n - 1;\n            if (c >= 0)\n                ans = (ans + dp[m][c] * 1LL * jc[i - m - 1] % P) % P;\n        }\n    }\n    return ans;\n}\n\nProvide a concise natural language description (docstring) of the CPP code in English using at most 500 characters.",
      "es": "int countPermutations(int n, int k, int qq[])\n{\n    const int N = 505, P = 998244353;\n    int q[N], m, dp[N][N], jc[N], f[N], ans;\n    memset(q, 0, sizeof(q));\n    memset(dp, 0, sizeof(dp));\n    memset(jc, 0, sizeof(jc));\n    memset(f, 0, sizeof(f));\n    ans = 0;\n\n    for (int i = 1; i <= n; i++)\n        q[i] = qq[i - 1];\n    dp[0][0] = f[0] = 1;\n    for (int i = jc[0] = 1; i <= n; i++)\n        jc[i] = 1LL * jc[i - 1] * i % P;\n    for (int i = 1; i <= n; i++)\n    {\n        f[i] = jc[i];\n        for (int j = 1; j < i; j++)\n            f[i] = (f[i] + P - 1LL * f[j] * jc[i - j] % P) % P;\n    }\n    for (int i = 1; i <= n; i++)\n    {\n        for (int j = 0; j < i; j++)\n            for (int k = 1; k <= n; k++)\n                dp[i][k] = (dp[i][k] + dp[j][k - 1] * 1LL * f[i - j] % P) % P;\n    }\n    m = 0;\n    for (int i = 1; i <= n; i++)\n        if (q[i] > q[i + 1])\n        {\n            m = i;\n            break;\n        }\n    if (m == n)\n    {\n        for (int i = k; i <= n; i++)\n            ans = (ans + dp[n][i]) % P;\n    }\n    else\n    {\n        for (int i = m + 1; i <= n; i++)\n        {\n            if (i != m + 1 && (q[i - 1] > q[i] || q[i] < q[m]))\n                break;\n            int c = k + i - n - 1;\n            if (c >= 0)\n                ans = (ans + dp[m][c] * 1LL * jc[i - m - 1] % P) % P;\n        }\n    }\n    return ans;\n}\n\nProporcione una descripción concisa en lenguaje natural (docstring) del código CPP en español utilizando un máximo de 500 caracteres.",
      "arb": "int countPermutations(int n, int k, int qq[])\n{\n    const int N = 505, P = 998244353;\n    int q[N], m, dp[N][N], jc[N], f[N], ans;\n    memset(q, 0, sizeof(q));\n    memset(dp, 0, sizeof(dp));\n    memset(jc, 0, sizeof(jc));\n    memset(f, 0, sizeof(f));\n    ans = 0;\n\n    for (int i = 1; i <= n; i++)\n        q[i] = qq[i - 1];\n    dp[0][0] = f[0] = 1;\n    for (int i = jc[0] = 1; i <= n; i++)\n        jc[i] = 1LL * jc[i - 1] * i % P;\n    for (int i = 1; i <= n; i++)\n    {\n        f[i] = jc[i];\n        for (int j = 1; j < i; j++)\n            f[i] = (f[i] + P - 1LL * f[j] * jc[i - j] % P) % P;\n    }\n    for (int i = 1; i <= n; i++)\n    {\n        for (int j = 0; j < i; j++)\n            for (int k = 1; k <= n; k++)\n                dp[i][k] = (dp[i][k] + dp[j][k - 1] * 1LL * f[i - j] % P) % P;\n    }\n    m = 0;\n    for (int i = 1; i <= n; i++)\n        if (q[i] > q[i + 1])\n        {\n            m = i;\n            break;\n        }\n    if (m == n)\n    {\n        for (int i = k; i <= n; i++)\n            ans = (ans + dp[n][i]) % P;\n    }\n    else\n    {\n        for (int i = m + 1; i <= n; i++)\n        {\n            if (i != m + 1 && (q[i - 1] > q[i] || q[i] < q[m]))\n                break;\n            int c = k + i - n - 1;\n            if (c >= 0)\n                ans = (ans + dp[m][c] * 1LL * jc[i - m - 1] % P) % P;\n        }\n    }\n    return ans;\n}\n\nيرجى تقديم وصف موجز بلغة طبيعية (docstring) لشفرة CPP باللغة العربية الفصحى باستخدام 500 حرف كحد أقصى.",
      "sw": "int countPermutations(int n, int k, int qq[])\n{\n    const int N = 505, P = 998244353;\n    int q[N], m, dp[N][N], jc[N], f[N], ans;\n    memset(q, 0, sizeof(q));\n    memset(dp, 0, sizeof(dp));\n    memset(jc, 0, sizeof(jc));\n    memset(f, 0, sizeof(f));\n    ans = 0;\n\n    for (int i = 1; i <= n; i++)\n        q[i] = qq[i - 1];\n    dp[0][0] = f[0] = 1;\n    for (int i = jc[0] = 1; i <= n; i++)\n        jc[i] = 1LL * jc[i - 1] * i % P;\n    for (int i = 1; i <= n; i++)\n    {\n        f[i] = jc[i];\n        for (int j = 1; j < i; j++)\n            f[i] = (f[i] + P - 1LL * f[j] * jc[i - j] % P) % P;\n    }\n    for (int i = 1; i <= n; i++)\n    {\n        for (int j = 0; j < i; j++)\n            for (int k = 1; k <= n; k++)\n                dp[i][k] = (dp[i][k] + dp[j][k - 1] * 1LL * f[i - j] % P) % P;\n    }\n    m = 0;\n    for (int i = 1; i <= n; i++)\n        if (q[i] > q[i + 1])\n        {\n            m = i;\n            break;\n        }\n    if (m == n)\n    {\n        for (int i = k; i <= n; i++)\n            ans = (ans + dp[n][i]) % P;\n    }\n    else\n    {\n        for (int i = m + 1; i <= n; i++)\n        {\n            if (i != m + 1 && (q[i - 1] > q[i] || q[i] < q[m]))\n                break;\n            int c = k + i - n - 1;\n            if (c >= 0)\n                ans = (ans + dp[m][c] * 1LL * jc[i - m - 1] % P) % P;\n        }\n    }\n    return ans;\n}\n\nToa maelezo mafupi ya lugha ya asili (docstring) ya msimbo wa CPP kwa Kiswahili kwa kutumia herufi zisizozidi 500.",
      "tr": "int countPermutations(int n, int k, int qq[])\n{\n    const int N = 505, P = 998244353;\n    int q[N], m, dp[N][N], jc[N], f[N], ans;\n    memset(q, 0, sizeof(q));\n    memset(dp, 0, sizeof(dp));\n    memset(jc, 0, sizeof(jc));\n    memset(f, 0, sizeof(f));\n    ans = 0;\n\n    for (int i = 1; i <= n; i++)\n        q[i] = qq[i - 1];\n    dp[0][0] = f[0] = 1;\n    for (int i = jc[0] = 1; i <= n; i++)\n        jc[i] = 1LL * jc[i - 1] * i % P;\n    for (int i = 1; i <= n; i++)\n    {\n        f[i] = jc[i];\n        for (int j = 1; j < i; j++)\n            f[i] = (f[i] + P - 1LL * f[j] * jc[i - j] % P) % P;\n    }\n    for (int i = 1; i <= n; i++)\n    {\n        for (int j = 0; j < i; j++)\n            for (int k = 1; k <= n; k++)\n                dp[i][k] = (dp[i][k] + dp[j][k - 1] * 1LL * f[i - j] % P) % P;\n    }\n    m = 0;\n    for (int i = 1; i <= n; i++)\n        if (q[i] > q[i + 1])\n        {\n            m = i;\n            break;\n        }\n    if (m == n)\n    {\n        for (int i = k; i <= n; i++)\n            ans = (ans + dp[n][i]) % P;\n    }\n    else\n    {\n        for (int i = m + 1; i <= n; i++)\n        {\n            if (i != m + 1 && (q[i - 1] > q[i] || q[i] < q[m]))\n                break;\n            int c = k + i - n - 1;\n            if (c >= 0)\n                ans = (ans + dp[m][c] * 1LL * jc[i - m - 1] % P) % P;\n        }\n    }\n    return ans;\n}\n\nAşağıdaki CPP kodunun Türkçe olarak en fazla 500 karakter kullanarak kısa bir doğal dil açıklamasını (docstring) sağlayın.",
      "vi": "int countPermutations(int n, int k, int qq[])\n{\n    const int N = 505, P = 998244353;\n    int q[N], m, dp[N][N], jc[N], f[N], ans;\n    memset(q, 0, sizeof(q));\n    memset(dp, 0, sizeof(dp));\n    memset(jc, 0, sizeof(jc));\n    memset(f, 0, sizeof(f));\n    ans = 0;\n\n    for (int i = 1; i <= n; i++)\n        q[i] = qq[i - 1];\n    dp[0][0] = f[0] = 1;\n    for (int i = jc[0] = 1; i <= n; i++)\n        jc[i] = 1LL * jc[i - 1] * i % P;\n    for (int i = 1; i <= n; i++)\n    {\n        f[i] = jc[i];\n        for (int j = 1; j < i; j++)\n            f[i] = (f[i] + P - 1LL * f[j] * jc[i - j] % P) % P;\n    }\n    for (int i = 1; i <= n; i++)\n    {\n        for (int j = 0; j < i; j++)\n            for (int k = 1; k <= n; k++)\n                dp[i][k] = (dp[i][k] + dp[j][k - 1] * 1LL * f[i - j] % P) % P;\n    }\n    m = 0;\n    for (int i = 1; i <= n; i++)\n        if (q[i] > q[i + 1])\n        {\n            m = i;\n            break;\n        }\n    if (m == n)\n    {\n        for (int i = k; i <= n; i++)\n            ans = (ans + dp[n][i]) % P;\n    }\n    else\n    {\n        for (int i = m + 1; i <= n; i++)\n        {\n            if (i != m + 1 && (q[i - 1] > q[i] || q[i] < q[m]))\n                break;\n            int c = k + i - n - 1;\n            if (c >= 0)\n                ans = (ans + dp[m][c] * 1LL * jc[i - m - 1] % P) % P;\n        }\n    }\n    return ans;\n}\n\nCung cấp mô tả ngắn gọn bằng ngôn ngữ tự nhiên (docstring) cho mã CPP bằng tiếng Việt, sử dụng tối đa 500 ký tự."
    },
    "instruction_bertscore": {
      "es": "0.9695565173899258",
      "arb": "0.9189683387960553",
      "sw": "0.9164634110608243",
      "tr": "0.8766952252130673",
      "vi": "0.9209653686469801"
    },
    "level": "",
    "test": "int main() {\n    int q1[] = {1, 2};\n    assert(countPermutations(2, 1, q1) == 2);\n\n    int q2[] = {3, 1, 2};\n    assert(countPermutations(3, 3, q2) == 1);\n\n    int q3[] = {1, 2, 3, 6, 5, 4};\n    assert(countPermutations(6, 3, q3) == 13);\n\n    int q4[] = {1, 2, 3, 4, 5, 6};\n    assert(countPermutations(6, 1, q4) == 720);\n\n    int q5[] = {1, 2, 5, 3, 4, 5};\n    assert(countPermutations(6, 3, q5) == 0);\n\n    int q6[] = {1, 2, 3, 4, 5, 6, 7, 8, 9};\n    assert(countPermutations(9, 9, q6) == 1);\n\n    int q7[] = {1, 2, 3, 4, 5, 6, 7, 9, 8};\n    assert(countPermutations(9, 2, q7) == 29093);\n    return 0;}",
    "entry_point": "countPermutations",
    "signature": "int countPermutations(int n, int k, int qq[])",
    "docstring": {
      "en": "Given a permutation q of n elements and an integer k, find the number of permutations p of n elements such that f(p) = q, where f(p) is the lexicographically smallest permutation that can be obtained by dividing p into exactly k non-empty contiguous segments and sorting each segment (i.e., choose k-1 breakpoints 1 <= x_1 < x_2 < ... < x_{k-1} < n, and divide it into [1, x_1], (x_1, x_2], ..., (x_{k-1}, n]). The result should be modulo 998244353.\n\n    >>> countPermutations(2, 1, [1, 2])\n    2\n\n",
      "es": "Dada una permutación q de n elementos y un entero k, encuentra el número de permutaciones p de n elementos tal que f(p) = q, donde f(p) es la permutación lexicográficamente más pequeña que se puede obtener dividiendo p en exactamente k segmentos contiguos no vacíos y ordenando cada segmento (es decir, elige k-1 puntos de ruptura 1 <= x_1 < x_2 < ... < x_{k-1} < n, y divídelo en [1, x_1], (x_1, x_2], ..., (x_{k-1}, n]). El resultado debe ser módulo 998244353.\n\n    >>> countPermutations(2, 1, [1, 2])\n    2",
      "arb": "بالنظر إلى ترتيب q من n عنصر وعدد صحيح k، ابحث عن عدد الترتيبات p من n عنصر بحيث f(p) = q، حيث أن f(p) هو الترتيب الأصغر لغوياً الذي يمكن الحصول عليه عن طريق تقسيم p إلى k مقاطع متجاورة غير فارغة تماماً وترتيب كل مقطع (أي اختيار k-1 نقطة قطع 1 <= x_1 < x_2 < ... < x_{k-1} < n، وتقسيمها إلى [1, x_1]، (x_1, x_2]، ...، (x_{k-1}, n]). يجب أن تكون النتيجة موديولو 998244353.\n\n    >>> countPermutations(2, 1, [1, 2])\n    2",
      "sw": "Kwa kupewa mpangilio q wa vipengele n na nambari k, pata idadi ya mipangilio p ya vipengele n kama f(p) = q, ambapo f(p) ni mpangilio mdogo zaidi wa lexicographically ambao unaweza kupatikana kwa kugawanya p katika sehemu k zisizo tupu na zinazofuatana na kupanga kila sehemu (yaani, chagua k-1 sehemu za kuvunja 1 <= x_1 < x_2 < ... < x_{k-1} < n, na igawanye katika [1, x_1], (x_1, x_2], ..., (x_{k-1}, n]). Matokeo yanapaswa kuwa modulo 998244353.\n\n    >>> countPermutations(2, 1, [1, 2])\n    2",
      "tr": "Verilen n elemanlı bir q permütasyonu ve bir k tam sayısı için, f(p) = q olacak şekilde n elemanlı kaç tane p permütasyonu olduğunu bulun. Burada f(p), p'yi tam olarak k tane boş olmayan ardışık segmente bölerek ve her segmenti sıralayarak elde edilebilecek sözlük sırasına göre en küçük permütasyondur (yani, k-1 tane kırılma noktası seçin 1 <= x_1 < x_2 < ... < x_{k-1} < n ve [1, x_1], (x_1, x_2], ..., (x_{k-1}, n] olarak bölün). Sonuç 998244353 ile mod alınmalıdır.\n\n    >>> countPermutations(2, 1, [1, 2])\n    2",
      "vi": "Đưa ra một hoán vị q của n phần tử và một số nguyên k, tìm số lượng hoán vị p của n phần tử sao cho f(p) = q, trong đó f(p) là hoán vị nhỏ nhất theo từ điển có thể thu được bằng cách chia p thành chính xác k đoạn liên tiếp không rỗng và sắp xếp từng đoạn (tức là, chọn k-1 điểm ngắt 1 <= x_1 < x_2 < ... < x_{k-1} < n, và chia nó thành [1, x_1], (x_1, x_2], ..., (x_{k-1}, n]). Kết quả cần lấy modulo 998244353.\n\n    >>> countPermutations(2, 1, [1, 2])\n    2"
    },
    "docstring_bertscore": {
      "es": "0.999152046903362",
      "arb": "0.9805592500865914",
      "sw": "0.9652510052506136",
      "tr": "0.9657350674891956",
      "vi": "0.9885471708599094"
    }
  },
  {
    "task_id": "CPP/44",
    "prompt": {
      "en": "#include <cassert>\n#include <algorithm>\n#include <vector>\n/**\n * Given an array of n distinct integers representing the heights of Kira's friends, \n * find the number of ways to choose a triplet (a, b, c) such that the greatest common divisor (GCD) \n * of the maximum and minimum values of the triplet is 1.\n * \n * Example usage:\n * >>> countTriplets({1, 5, 7})\n * 1\n */\nint countTriplets(const std::vector<int>& heights)",
      "es": "#include <cassert>\n#include <algorithm>\n#include <vector>\n/**\n * Dado un array de n enteros distintos que representan las alturas de los amigos de Kira,\n * encuentra el número de formas de elegir un triplete (a, b, c) tal que el máximo común divisor (MCD)\n * de los valores máximo y mínimo del triplete sea 1.\n * \n * Ejemplo de uso:\n * >>> countTriplets({1, 5, 7})\n * 1\n */\nint countTriplets(const std::vector<int>& heights)",
      "arb": "#include <cassert>\n#include <algorithm>\n#include <vector>\n/**\n * بالنظر إلى مصفوفة من n عدد صحيح مميز تمثل ارتفاعات أصدقاء كيرا،\n * جد عدد الطرق لاختيار ثلاثية (a, b, c) بحيث يكون القاسم المشترك الأكبر (GCD)\n * للقيمتين العظمى والصغرى للثلاثية هو 1.\n * \n * مثال على الاستخدام:\n * >>> countTriplets({1, 5, 7})\n * 1\n */\nint countTriplets(const std::vector<int>& heights)",
      "sw": "#include <cassert>\n#include <algorithm>\n#include <vector>\n/**\n * Ukipewa safu ya n ya nambari tofauti zinazoashiria urefu wa marafiki wa Kira,\n * pata idadi ya njia za kuchagua tatu (a, b, c) kama kwamba kipeo cha mgawanyiko wa kawaida (GCD)\n * wa thamani za juu na za chini za tatu ni 1.\n * \n * Mfano wa matumizi:\n * >>> countTriplets({1, 5, 7})\n * 1\n */\nint countTriplets(const std::vector<int>& heights)",
      "tr": "#include <cassert>\n#include <algorithm>\n#include <vector>\n/**\n * Kira'nın arkadaşlarının yüksekliklerini temsil eden n farklı tamsayıdan oluşan bir dizi verildiğinde,\n * maksimum ve minimum değerlerinin en büyük ortak böleni (GCD) 1 olan bir üçlü (a, b, c) seçmenin\n * kaç yolu olduğunu bulun.\n * \n * Örnek kullanım:\n * >>> countTriplets({1, 5, 7})\n * 1\n */\nint countTriplets(const std::vector<int>& heights)",
      "vi": "#include <cassert>\n#include <algorithm>\n#include <vector>\n/**\n * Cho một mảng gồm n số nguyên khác nhau đại diện cho chiều cao của bạn bè Kira,\n * tìm số cách chọn một bộ ba (a, b, c) sao cho ước số chung lớn nhất (GCD)\n * của giá trị lớn nhất và nhỏ nhất của bộ ba là 1.\n * \n * Ví dụ sử dụng:\n * >>> countTriplets({1, 5, 7})\n * 1\n */\nint countTriplets(const std::vector<int>& heights)"
    },
    "prompt_bertscore": {
      "es": "0.9954972478923201",
      "arb": "0.999999801369619",
      "sw": "0.9572396460923334",
      "tr": "0.9725286237813509",
      "vi": "0.999999801369619"
    },
    "canonical_solution": "{\n    int count = 0;\n    int n = heights.size();\n    for (int i = 0; i < n; ++i) {\n        for (int j = i + 1; j < n; ++j) {\n            for (int k = j + 1; k < n; ++k) {\n                int minVal = std::min({heights[i], heights[j], heights[k]});\n                int maxVal = std::max({heights[i], heights[j], heights[k]});\n                \n                // GCD algorithm\n                int a = minVal, b = maxVal;\n                while (b != 0) {\n                    int t = b;\n                    b = a % b;\n                    a = t;\n                }\n                \n                if (a == 1) {\n                    count++;\n                }\n            }\n        }\n    }\n    return count;\n}",
    "instruction": {
      "en": "int countTriplets(const std::vector<int>& heights)\n{\n    int count = 0;\n    int n = heights.size();\n    for (int i = 0; i < n; ++i) {\n        for (int j = i + 1; j < n; ++j) {\n            for (int k = j + 1; k < n; ++k) {\n                int minVal = std::min({heights[i], heights[j], heights[k]});\n                int maxVal = std::max({heights[i], heights[j], heights[k]});\n                \n                // GCD algorithm\n                int a = minVal, b = maxVal;\n                while (b != 0) {\n                    int t = b;\n                    b = a % b;\n                    a = t;\n                }\n                \n                if (a == 1) {\n                    count++;\n                }\n            }\n        }\n    }\n    return count;\n}\n\nProvide a concise natural language description (docstring) of the CPP code in English using at most 500 characters.",
      "es": "int countTriplets(const std::vector<int>& heights)\n{\n    int count = 0;\n    int n = heights.size();\n    for (int i = 0; i < n; ++i) {\n        for (int j = i + 1; j < n; ++j) {\n            for (int k = j + 1; k < n; ++k) {\n                int minVal = std::min({heights[i], heights[j], heights[k]});\n                int maxVal = std::max({heights[i], heights[j], heights[k]});\n                \n                // GCD algorithm\n                int a = minVal, b = maxVal;\n                while (b != 0) {\n                    int t = b;\n                    b = a % b;\n                    a = t;\n                }\n                \n                if (a == 1) {\n                    count++;\n                }\n            }\n        }\n    }\n    return count;\n}\n\nProporcione una descripción concisa en lenguaje natural (docstring) del código CPP en español utilizando como máximo 500 caracteres.",
      "arb": "int countTriplets(const std::vector<int>& heights)\n{\n    int count = 0;\n    int n = heights.size();\n    for (int i = 0; i < n; ++i) {\n        for (int j = i + 1; j < n; ++j) {\n            for (int k = j + 1; k < n; ++k) {\n                int minVal = std::min({heights[i], heights[j], heights[k]});\n                int maxVal = std::max({heights[i], heights[j], heights[k]});\n                \n                // GCD algorithm\n                int a = minVal, b = maxVal;\n                while (b != 0) {\n                    int t = b;\n                    b = a % b;\n                    a = t;\n                }\n                \n                if (a == 1) {\n                    count++;\n                }\n            }\n        }\n    }\n    return count;\n}\n\nيرجى تقديم وصف موجز بلغة طبيعية (docstring) للكود المكتوب بلغة C++ باللغة العربية الفصحى، بحيث لا يتجاوز 500 حرف.",
      "sw": "int countTriplets(const std::vector<int>& heights)\n{\n    int count = 0;\n    int n = heights.size();\n    for (int i = 0; i < n; ++i) {\n        for (int j = i + 1; j < n; ++j) {\n            for (int k = j + 1; k < n; ++k) {\n                int minVal = std::min({heights[i], heights[j], heights[k]});\n                int maxVal = std::max({heights[i], heights[j], heights[k]});\n                \n                // GCD algorithm\n                int a = minVal, b = maxVal;\n                while (b != 0) {\n                    int t = b;\n                    b = a % b;\n                    a = t;\n                }\n                \n                if (a == 1) {\n                    count++;\n                }\n            }\n        }\n    }\n    return count;\n}\n\nToa maelezo mafupi ya lugha ya asili (docstring) ya msimbo wa CPP kwa Kiswahili kwa kutumia herufi zisizozidi 500.",
      "tr": "int countTriplets(const std::vector<int>& heights)\n{\n    int count = 0;\n    int n = heights.size();\n    for (int i = 0; i < n; ++i) {\n        for (int j = i + 1; j < n; ++j) {\n            for (int k = j + 1; k < n; ++k) {\n                int minVal = std::min({heights[i], heights[j], heights[k]});\n                int maxVal = std::max({heights[i], heights[j], heights[k]});\n                \n                // GCD algorithm\n                int a = minVal, b = maxVal;\n                while (b != 0) {\n                    int t = b;\n                    b = a % b;\n                    a = t;\n                }\n                \n                if (a == 1) {\n                    count++;\n                }\n            }\n        }\n    }\n    return count;\n}\n\nAşağıdaki CPP kodunun Türkçe olarak en fazla 500 karakter kullanarak kısa bir doğal dil açıklamasını (docstring) sağlayın.",
      "vi": "int countTriplets(const std::vector<int>& heights)\n{\n    int count = 0;\n    int n = heights.size();\n    for (int i = 0; i < n; ++i) {\n        for (int j = i + 1; j < n; ++j) {\n            for (int k = j + 1; k < n; ++k) {\n                int minVal = std::min({heights[i], heights[j], heights[k]});\n                int maxVal = std::max({heights[i], heights[j], heights[k]});\n                \n                // GCD algorithm\n                int a = minVal, b = maxVal;\n                while (b != 0) {\n                    int t = b;\n                    b = a % b;\n                    a = t;\n                }\n                \n                if (a == 1) {\n                    count++;\n                }\n            }\n        }\n    }\n    return count;\n}\n\nCung cấp mô tả ngắn gọn bằng ngôn ngữ tự nhiên (docstring) cho mã CPP bằng tiếng Việt với tối đa 500 ký tự."
    },
    "instruction_bertscore": {
      "es": "0.9695565173899258",
      "arb": "0.8245899077688523",
      "sw": "0.9176812139269492",
      "tr": "0.8890214321385683",
      "vi": "0.9171611995893999"
    },
    "level": "",
    "test": "int main() {\n    assert(countTriplets({1, 5, 7}) == 1);\n    assert(countTriplets({1, 6, 2, 3}) == 3);\n    assert(countTriplets({16, 4, 8, 2}) == 0);\n    assert(countTriplets({10, 1, 6, 7, 9, 8, 4, 3, 5, 2}) == 77);\n    assert(countTriplets({4, 5, 9, 11, 14}) == 7);\n    assert(countTriplets({15, 10, 6, 9, 7, 3, 12, 8, 11, 1, 2}) == 104);\n    assert(countTriplets({3, 7, 11, 13}) == 4);\n    assert(countTriplets({5, 12, 13, 17, 19}) == 10);\n    assert(countTriplets({2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12}) == 87);\n    assert(countTriplets({1, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17}) == 122);\n\n    return 0;\n}",
    "entry_point": "countTriplets",
    "signature": "int countTriplets(const std::vector<int>& heights)",
    "docstring": {
      "en": "Given an array of n distinct integers representing the heights of Kira's friends, find the number of ways to choose a triplet (a, b, c) such that the greatest common divisor (GCD) of the maximum and minimum values of the triplet is 1.\n\nExample usage:\n>>> countTriplets({1, 5, 7})\n1",
      "es": "Dado un array de n enteros distintos que representan las alturas de los amigos de Kira, encuentra el número de formas de elegir un triplete (a, b, c) tal que el máximo común divisor (GCD) de los valores máximo y mínimo del triplete sea 1.\n\nUso de ejemplo:\n>>> countTriplets({1, 5, 7})\n1",
      "arb": "إعطاء مصفوفة تحتوي على n من الأعداد الصحيحة المميزة التي تمثل ارتفاعات أصدقاء كيرا، ابحث عن عدد الطرق لاختيار ثلاثية (a، b، c) بحيث يكون القاسم المشترك الأكبر (GCD) للقيمتين القصوى والدنيا للثلاثية هو 1.\n\nاستخدام المثال:\n>>> countTriplets({1, 5, 7})\n1",
      "sw": "Ikizingatiwa safu ya n ya nambari tofauti zinazoashiria urefu wa marafiki wa Kira, tafuta idadi ya njia za kuchagua tatu (a, b, c) ili kwamba mgawanyiko mkuu wa kawaida (GCD) wa thamani ya juu na ya chini ya tatu hiyo ni 1.\n\nMfano wa matumizi:\n>>> countTriplets({1, 5, 7})\n1",
      "tr": "n tane farklı tam sayıdan oluşan ve Kira'nın arkadaşlarının boylarını temsil eden bir dizi verildiğinde, maksimum ve minimum değerlerinin en büyük ortak böleni (GCD) 1 olan bir üçlü (a, b, c) seçmenin kaç yolu olduğunu bulun.\n\nÖrnek kullanım:\n>>> countTriplets({1, 5, 7})\n1",
      "vi": "Cho một mảng gồm n số nguyên khác nhau đại diện cho chiều cao của bạn bè Kira, tìm số cách chọn một bộ ba (a, b, c) sao cho ước số chung lớn nhất (GCD) của giá trị lớn nhất và nhỏ nhất của bộ ba là 1.\n\nVí dụ sử dụng:\n>>> countTriplets({1, 5, 7})\n1"
    },
    "docstring_bertscore": {
      "es": "1",
      "arb": "0.9783802748066386",
      "sw": "0.9163752191716449",
      "tr": "0.973930358380314",
      "vi": "1"
    }
  },
  {
    "task_id": "CPP/45",
    "prompt": {
      "en": "#include <cassert>\n#include <cstdio>\n/**\n * You are given a 1 by n pixel image, where each pixel has a color \n * represented by an integer. You can perform an operation where you \n * pick a color and change all connected pixels of the same color to \n * the chosen color. Two pixels are connected if they are adjacent \n * and have the same color. Find the minimum number of operations \n * required to make all pixels the same color.\n *\n * Note: For each color, there are at most 20 pixels of that color.\n *\n * Examples:\n *   minOperations(5, {1, 2, 3, 2, 1}) -> 2\n */\nint minOperations(int n, int* pixels)",
      "es": "#include <cassert>\n#include <cstdio>\n/**\n * Se te da una imagen de 1 por n píxeles, donde cada píxel tiene un color \n * representado por un entero. Puedes realizar una operación donde \n * eliges un color y cambias todos los píxeles conectados del mismo color \n * al color elegido. Dos píxeles están conectados si son adyacentes \n * y tienen el mismo color. Encuentra el número mínimo de operaciones \n * requeridas para hacer que todos los píxeles sean del mismo color.\n *\n * Nota: Para cada color, hay como máximo 20 píxeles de ese color.\n *\n * Ejemplos:\n *   minOperations(5, {1, 2, 3, 2, 1}) -> 2\n */\nint minOperations(int n, int* pixels)",
      "arb": "#include <cassert>\n#include <cstdio>\n/**\n * لديك صورة مكونة من 1 في n بكسل، حيث يتم تمثيل كل بكسل بلون \n * ممثل بعدد صحيح. يمكنك تنفيذ عملية حيث تختار لونًا وتغير \n * جميع البكسلات المتصلة من نفس اللون إلى اللون المختار. \n * يعتبر البكسلان متصلين إذا كانا متجاورين ولهما نفس اللون. \n * ابحث عن الحد الأدنى لعدد العمليات المطلوبة لجعل جميع \n * البكسلات بنفس اللون.\n *\n * ملاحظة: لكل لون، هناك بحد أقصى 20 بكسل من ذلك اللون.\n *\n * أمثلة:\n *   minOperations(5, {1, 2, 3, 2, 1}) -> 2\n */\nint minOperations(int n, int* pixels)",
      "sw": "#include <cassert>\n#include <cstdio>\n/**\n * Umepewa picha ya pikseli 1 kwa n, ambapo kila pikseli ina rangi \n * inayowakilishwa na nambari. Unaweza kufanya operesheni ambapo unachagua \n * rangi na kubadilisha pikseli zote zilizounganishwa za rangi sawa kuwa \n * rangi iliyochaguliwa. Pikseli mbili zimeunganishwa ikiwa ziko karibu \n * na zina rangi sawa. Pata idadi ndogo ya operesheni zinazohitajika \n * kufanya pikseli zote ziwe na rangi sawa.\n *\n * Kumbuka: Kwa kila rangi, kuna pikseli zisizozidi 20 za rangi hiyo.\n *\n * Mifano:\n *   minOperations(5, {1, 2, 3, 2, 1}) -> 2\n */\nint minOperations(int n, int* pixels)",
      "tr": "#include <cassert>\n#include <cstdio>\n/**\n * 1'e n pikselden oluşan bir görüntü verilir, burada her piksel bir \n * tamsayı ile temsil edilen bir renge sahiptir. Bir renk seçip aynı \n * renkteki tüm bağlı pikselleri seçilen renge değiştirebileceğiniz \n * bir işlem gerçekleştirebilirsiniz. İki piksel, bitişik ve aynı \n * renkte ise bağlıdır. Tüm pikselleri aynı renkte yapmak için gereken \n * minimum işlem sayısını bulun.\n *\n * Not: Her renk için en fazla 20 piksel vardır.\n *\n * Örnekler:\n *   minOperations(5, {1, 2, 3, 2, 1}) -> 2\n */\nint minOperations(int n, int* pixels)",
      "vi": "#include <cassert>\n#include <cstdio>\n/**\n * Bạn được cung cấp một hình ảnh 1 x n pixel, trong đó mỗi pixel có một màu \n * được biểu diễn bằng một số nguyên. Bạn có thể thực hiện một thao tác mà bạn \n * chọn một màu và thay đổi tất cả các pixel kết nối có cùng màu thành màu đã chọn. \n * Hai pixel được kết nối nếu chúng liền kề và có cùng màu. Tìm số lượng thao tác \n * tối thiểu cần thiết để làm cho tất cả các pixel có cùng màu.\n *\n * Lưu ý: Đối với mỗi màu, có tối đa 20 pixel của màu đó.\n *\n * Ví dụ:\n *   minOperations(5, {1, 2, 3, 2, 1}) -> 2\n */\nint minOperations(int n, int* pixels)"
    },
    "prompt_bertscore": {
      "es": "0.9966453314947018",
      "arb": "0.9658417320038113",
      "sw": "0.9759808198037372",
      "tr": "0.9652303476909859",
      "vi": "0.9870796896048236"
    },
    "canonical_solution": "{\n    int pre[n+1], u[n+1], f[n+1][n+1];\n    for (int i = 1; i <= n; i++) {\n        pre[i] = u[i] = 0;\n    }\n    for (int i = 1; i <= n; i++) {\n        pre[i] = u[pixels[i-1]];\n        u[pixels[i-1]] = i;\n    }\n    for (int i = 1; i <= n; i++) {\n        for (int j = 1; j <= n; j++) {\n            if (i != j) f[i][j] = 1000000000;\n            else f[i][j] = 0;\n        }\n    }\n    for (int len = 2; len <= n; len++) {\n        for (int i = 1; i <= n - len + 1; i++) {\n            int j = i + len - 1;\n            f[i][j] = f[i][j - 1] + 1;\n            for (int l = pre[j]; l >= i; l = pre[l]) {\n                f[i][j] = f[i][j] < f[i][l] + f[l + 1][j] ? f[i][j] : f[i][l] + f[l + 1][j];\n            }\n        }\n    }\n    return f[1][n];\n}",
    "instruction": {
      "en": "int minOperations(int n, int* pixels)\n{\n    int pre[n+1], u[n+1], f[n+1][n+1];\n    for (int i = 1; i <= n; i++) {\n        pre[i] = u[i] = 0;\n    }\n    for (int i = 1; i <= n; i++) {\n        pre[i] = u[pixels[i-1]];\n        u[pixels[i-1]] = i;\n    }\n    for (int i = 1; i <= n; i++) {\n        for (int j = 1; j <= n; j++) {\n            if (i != j) f[i][j] = 1000000000;\n            else f[i][j] = 0;\n        }\n    }\n    for (int len = 2; len <= n; len++) {\n        for (int i = 1; i <= n - len + 1; i++) {\n            int j = i + len - 1;\n            f[i][j] = f[i][j - 1] + 1;\n            for (int l = pre[j]; l >= i; l = pre[l]) {\n                f[i][j] = f[i][j] < f[i][l] + f[l + 1][j] ? f[i][j] : f[i][l] + f[l + 1][j];\n            }\n        }\n    }\n    return f[1][n];\n}\n\nProvide a concise natural language description (docstring) of the CPP code in English using at most 500 characters.",
      "es": "int minOperations(int n, int* pixels)\n{\n    int pre[n+1], u[n+1], f[n+1][n+1];\n    for (int i = 1; i <= n; i++) {\n        pre[i] = u[i] = 0;\n    }\n    for (int i = 1; i <= n; i++) {\n        pre[i] = u[pixels[i-1]];\n        u[pixels[i-1]] = i;\n    }\n    for (int i = 1; i <= n; i++) {\n        for (int j = 1; j <= n; j++) {\n            if (i != j) f[i][j] = 1000000000;\n            else f[i][j] = 0;\n        }\n    }\n    for (int len = 2; len <= n; len++) {\n        for (int i = 1; i <= n - len + 1; i++) {\n            int j = i + len - 1;\n            f[i][j] = f[i][j - 1] + 1;\n            for (int l = pre[j]; l >= i; l = pre[l]) {\n                f[i][j] = f[i][j] < f[i][l] + f[l + 1][j] ? f[i][j] : f[i][l] + f[l + 1][j];\n            }\n        }\n    }\n    return f[1][n];\n}\n\nProporcione una descripción concisa en lenguaje natural (docstring) del código CPP en español utilizando como máximo 500 caracteres.",
      "arb": "int minOperations(int n, int* pixels)\n{\n    int pre[n+1], u[n+1], f[n+1][n+1];\n    for (int i = 1; i <= n; i++) {\n        pre[i] = u[i] = 0;\n    }\n    for (int i = 1; i <= n; i++) {\n        pre[i] = u[pixels[i-1]];\n        u[pixels[i-1]] = i;\n    }\n    for (int i = 1; i <= n; i++) {\n        for (int j = 1; j <= n; j++) {\n            if (i != j) f[i][j] = 1000000000;\n            else f[i][j] = 0;\n        }\n    }\n    for (int len = 2; len <= n; len++) {\n        for (int i = 1; i <= n - len + 1; i++) {\n            int j = i + len - 1;\n            f[i][j] = f[i][j - 1] + 1;\n            for (int l = pre[j]; l >= i; l = pre[l]) {\n                f[i][j] = f[i][j] < f[i][l] + f[l + 1][j] ? f[i][j] : f[i][l] + f[l + 1][j];\n            }\n        }\n    }\n    return f[1][n];\n}\n\nيرجى تقديم وصف موجز بلغة طبيعية (docstring) للكود المكتوب بلغة C++ باللغة العربية الفصحى، بحيث لا يتجاوز 500 حرف.",
      "sw": "int minOperations(int n, int* pixels)\n{\n    int pre[n+1], u[n+1], f[n+1][n+1];\n    for (int i = 1; i <= n; i++) {\n        pre[i] = u[i] = 0;\n    }\n    for (int i = 1; i <= n; i++) {\n        pre[i] = u[pixels[i-1]];\n        u[pixels[i-1]] = i;\n    }\n    for (int i = 1; i <= n; i++) {\n        for (int j = 1; j <= n; j++) {\n            if (i != j) f[i][j] = 1000000000;\n            else f[i][j] = 0;\n        }\n    }\n    for (int len = 2; len <= n; len++) {\n        for (int i = 1; i <= n - len + 1; i++) {\n            int j = i + len - 1;\n            f[i][j] = f[i][j - 1] + 1;\n            for (int l = pre[j]; l >= i; l = pre[l]) {\n                f[i][j] = f[i][j] < f[i][l] + f[l + 1][j] ? f[i][j] : f[i][l] + f[l + 1][j];\n            }\n        }\n    }\n    return f[1][n];\n}\n\nToa maelezo mafupi ya lugha ya asili (docstring) ya msimbo wa CPP kwa Kiswahili kwa kutumia herufi zisizozidi 500.",
      "tr": "int minOperations(int n, int* pixels)\n{\n    int pre[n+1], u[n+1], f[n+1][n+1];\n    for (int i = 1; i <= n; i++) {\n        pre[i] = u[i] = 0;\n    }\n    for (int i = 1; i <= n; i++) {\n        pre[i] = u[pixels[i-1]];\n        u[pixels[i-1]] = i;\n    }\n    for (int i = 1; i <= n; i++) {\n        for (int j = 1; j <= n; j++) {\n            if (i != j) f[i][j] = 1000000000;\n            else f[i][j] = 0;\n        }\n    }\n    for (int len = 2; len <= n; len++) {\n        for (int i = 1; i <= n - len + 1; i++) {\n            int j = i + len - 1;\n            f[i][j] = f[i][j - 1] + 1;\n            for (int l = pre[j]; l >= i; l = pre[l]) {\n                f[i][j] = f[i][j] < f[i][l] + f[l + 1][j] ? f[i][j] : f[i][l] + f[l + 1][j];\n            }\n        }\n    }\n    return f[1][n];\n}\n\nAşağıdaki CPP kodunun Türkçe olarak en fazla 500 karakterle doğal dilde kısa bir açıklamasını (docstring) sağlayın.",
      "vi": "int minOperations(int n, int* pixels)\n{\n    int pre[n+1], u[n+1], f[n+1][n+1];\n    for (int i = 1; i <= n; i++) {\n        pre[i] = u[i] = 0;\n    }\n    for (int i = 1; i <= n; i++) {\n        pre[i] = u[pixels[i-1]];\n        u[pixels[i-1]] = i;\n    }\n    for (int i = 1; i <= n; i++) {\n        for (int j = 1; j <= n; j++) {\n            if (i != j) f[i][j] = 1000000000;\n            else f[i][j] = 0;\n        }\n    }\n    for (int len = 2; len <= n; len++) {\n        for (int i = 1; i <= n - len + 1; i++) {\n            int j = i + len - 1;\n            f[i][j] = f[i][j - 1] + 1;\n            for (int l = pre[j]; l >= i; l = pre[l]) {\n                f[i][j] = f[i][j] < f[i][l] + f[l + 1][j] ? f[i][j] : f[i][l] + f[l + 1][j];\n            }\n        }\n    }\n    return f[1][n];\n}\n\nCung cấp mô tả ngắn gọn bằng ngôn ngữ tự nhiên (docstring) cho mã CPP bằng tiếng Việt với tối đa 500 ký tự."
    },
    "instruction_bertscore": {
      "es": "0.9695565173899258",
      "arb": "0.8291343722565495",
      "sw": "0.9449839529520998",
      "tr": "0.8602498214456648",
      "vi": "0.9171611995893999"
    },
    "level": "",
    "test": "int main() {\n    int a1[] = {1, 2, 3, 2, 1};\n    int a2[] = {1, 1, 2, 2};\n    int a3[] = {1, 2, 1, 4, 2};\n    int a4[] = {5, 5, 5, 5, 5};\n    int a5[] = {1, 1, 1, 2, 2, 2};\n    int a6[] = {1, 3, 3, 3, 2, 2, 2};\n    int a7[] = {4, 4, 4, 4, 3, 3, 3, 3};\n    int a8[] = {1, 2, 3, 4, 5, 6, 7, 8, 9};\n    int a9[] = {1, 2, 1, 2, 1, 2, 1, 2, 1, 2};\n    int a10[] = {3, 3, 3};\n    int a11[] = {2, 1, 1, 2};\n    assert(minOperations(5, a1) == 2);\n    assert(minOperations(4, a2) == 1);\n    assert(minOperations(5, a3) == 3);\n    assert(minOperations(5, a4) == 0);\n    assert(minOperations(6, a5) == 1);\n    assert(minOperations(7, a6) == 2);\n    assert(minOperations(8, a7) == 1);\n    assert(minOperations(9, a8) == 8);\n    assert(minOperations(10, a9) == 5);\n    assert(minOperations(3, a10) == 0);\n    assert(minOperations(4, a11) == 1);\n    return 0;\n}",
    "entry_point": "minOperations",
    "signature": "int minOperations(int n, int* pixels)",
    "docstring": {
      "en": "You are given a 1 by n pixel image, where each pixel has a color represented by an integer. You can perform an operation where you pick a color and change all connected pixels of the same color to the chosen color. Two pixels are connected if they are adjacent and have the same color. Find the minimum number of operations required to make all pixels the same color.\n\nNote: For each color, there are at most 20 pixels of that color.\n\nExamples:\n  minOperations(5, {1, 2, 3, 2, 1}) -> 2\n",
      "es": "Se te da una imagen de 1 por n píxeles, donde cada píxel tiene un color representado por un entero. Puedes realizar una operación donde eliges un color y cambias todos los píxeles conectados del mismo color al color elegido. Dos píxeles están conectados si son adyacentes y tienen el mismo color. Encuentra el número mínimo de operaciones necesarias para hacer que todos los píxeles sean del mismo color.\n\nNota: Para cada color, hay como máximo 20 píxeles de ese color.\n\nEjemplos:\n  minOperations(5, {1, 2, 3, 2, 1}) -> 2",
      "arb": "أنت تملك صورة مكونة من 1 في n بكسل، حيث أن كل بكسل له لون ممثل برقم صحيح. يمكنك تنفيذ عملية حيث تختار لونًا وتغير جميع البكسلات المتصلة من نفس اللون إلى اللون المختار. يعتبر البكسلان متصلين إذا كانا متجاورين ولهما نفس اللون. ابحث عن الحد الأدنى لعدد العمليات المطلوبة لجعل جميع البكسلات بنفس اللون.\n\nملاحظة: لكل لون، هناك بحد أقصى 20 بكسل من ذلك اللون.\n\nأمثلة:\n  minOperations(5, {1, 2, 3, 2, 1}) -> 2",
      "sw": "Unapewa picha ya pikseli 1 kwa n, ambapo kila pikseli ina rangi inayowakilishwa na nambari. Unaweza kufanya operesheni ambapo unachagua rangi na kubadilisha pikseli zote zilizounganishwa za rangi sawa kuwa rangi iliyochaguliwa. Pikseli mbili zimeunganishwa ikiwa ziko karibu na zina rangi sawa. Tafuta idadi ndogo ya operesheni zinazohitajika ili kufanya pikseli zote kuwa na rangi sawa.\n\nKumbuka: Kwa kila rangi, kuna pikseli zisizozidi 20 za rangi hiyo.\n\nMifano:\n  minOperations(5, {1, 2, 3, 2, 1}) -> 2",
      "tr": "1'e n piksel boyutunda bir görüntü verilir ve her piksel bir tamsayı ile temsil edilen bir renge sahiptir. Bir renk seçip aynı renkteki tüm bağlı pikselleri seçilen renge değiştirebileceğiniz bir işlem gerçekleştirebilirsiniz. İki piksel, bitişikse ve aynı renge sahipse bağlı kabul edilir. Tüm pikselleri aynı renge getirmek için gereken minimum işlem sayısını bulun.\n\nNot: Her renk için en fazla 20 piksel bulunmaktadır.\n\nÖrnekler:\n  minOperations(5, {1, 2, 3, 2, 1}) -> 2",
      "vi": "Bạn được cung cấp một hình ảnh 1 x n pixel, trong đó mỗi pixel có một màu được biểu diễn bằng một số nguyên. Bạn có thể thực hiện một thao tác trong đó bạn chọn một màu và thay đổi tất cả các pixel kết nối có cùng màu thành màu đã chọn. Hai pixel được kết nối nếu chúng liền kề và có cùng màu. Tìm số lượng thao tác tối thiểu cần thiết để làm cho tất cả các pixel có cùng màu.\n\nLưu ý: Đối với mỗi màu, có tối đa 20 pixel của màu đó.\n\nVí dụ:\n  minOperations(5, {1, 2, 3, 2, 1}) -> 2"
    },
    "docstring_bertscore": {
      "es": "0.9974700448367586",
      "arb": "0.9779448770114102",
      "sw": "0.9729076105483654",
      "tr": "0.9539815119522181",
      "vi": "0.9930606490081652"
    }
  },
  {
    "task_id": "CPP/46",
    "prompt": {
      "en": "#include <cassert>\n#include <iostream>\n/**\n * @brief Computes the sum of all numbers from 1 to n that are multiples of either 3 or 5.\n *\n * Counts each number only once even if it is a multiple of both 3 and 5.\n * For example:\n *     @code\n *     std::cout << sumOfMultiples(10); // Outputs: 33 (3 + 5 + 6 + 9 + 10)\n *     @endcode\n *\n * @param n The upper bound of the range to check for multiples.\n * @return The sum of the multiples of either 3 or 5 within the range.\n */\nint sumOfMultiples(int n)",
      "es": "#include <cassert>\n#include <iostream>\n/**\n * @brief Calcula la suma de todos los números desde 1 hasta n que son múltiplos de 3 o 5.\n *\n * Cuenta cada número solo una vez, incluso si es múltiplo de ambos 3 y 5.\n * Por ejemplo:\n *     @code\n *     std::cout << sumOfMultiples(10); // Outputs: 33 (3 + 5 + 6 + 9 + 10)\n *     @endcode\n *\n * @param n El límite superior del rango para verificar múltiplos.\n * @return La suma de los múltiplos de 3 o 5 dentro del rango.\n */\nint sumOfMultiples(int n)",
      "arb": "#include <cassert>\n#include <iostream>\n/**\n * @brief يحسب مجموع جميع الأرقام من 1 إلى n التي هي مضاعفات إما لـ 3 أو 5.\n *\n * يحسب كل رقم مرة واحدة فقط حتى لو كان مضاعفًا لكل من 3 و 5.\n * على سبيل المثال:\n *     @code\n *     std::cout << sumOfMultiples(10); // Outputs: 33 (3 + 5 + 6 + 9 + 10)\n *     @endcode\n *\n * @param n الحد الأعلى للنطاق للتحقق من المضاعفات.\n * @return مجموع المضاعفات إما لـ 3 أو 5 ضمن النطاق.\n */\nint sumOfMultiples(int n)",
      "sw": "#include <cassert>\n#include <iostream>\n/**\n * @brief Inahesabu jumla ya namba zote kutoka 1 hadi n ambazo ni marudufu ya 3 au 5.\n *\n * Inahesabu kila namba mara moja tu hata kama ni marudufu ya 3 na 5.\n * Kwa mfano:\n *     @code\n *     std::cout << sumOfMultiples(10); // Inatoa: 33 (3 + 5 + 6 + 9 + 10)\n *     @endcode\n *\n * @param n Kikomo cha juu cha upeo wa kuangalia marudufu.\n * @return Jumla ya marudufu ya 3 au 5 ndani ya upeo.\n */\nint sumOfMultiples(int n)",
      "tr": "#include <cassert>\n#include <iostream>\n/**\n * @brief 1'den n'ye kadar olan sayılardan 3 veya 5'in katı olanların toplamını hesaplar.\n *\n * Hem 3 hem de 5'in katı olan sayıları yalnızca bir kez sayar.\n * Örneğin:\n *     @code\n *     std::cout << sumOfMultiples(10); // Çıktı: 33 (3 + 5 + 6 + 9 + 10)\n *     @endcode\n *\n * @param n Katlar için kontrol edilecek aralığın üst sınırı.\n * @return Aralık içindeki 3 veya 5'in katlarının toplamı.\n */\nint sumOfMultiples(int n)",
      "vi": "#include <cassert>\n#include <iostream>\n/**\n * @brief Tính tổng của tất cả các số từ 1 đến n mà là bội số của 3 hoặc 5.\n *\n * Chỉ đếm mỗi số một lần ngay cả khi nó là bội số của cả 3 và 5.\n * Ví dụ:\n *     @code\n *     std::cout << sumOfMultiples(10); // Outputs: 33 (3 + 5 + 6 + 9 + 10)\n *     @endcode\n *\n * @param n Giới hạn trên của phạm vi để kiểm tra các bội số.\n * @return Tổng của các bội số của 3 hoặc 5 trong phạm vi.\n */\nint sumOfMultiples(int n)"
    },
    "prompt_bertscore": {
      "es": "0.9858956539034747",
      "arb": "0.9868983400669388",
      "sw": "0.9832590342256176",
      "tr": "0.9510618439813863",
      "vi": "0.9648110389566212"
    },
    "canonical_solution": "{\n    int sum = 0;\n    for (int i = 1; i <= n; ++i)\n    {\n        if (i % 3 == 0 || i % 5 == 0)\n        {\n            sum += i;\n        }\n    }\n    return sum;\n}",
    "instruction": {
      "en": "int sumOfMultiples(int n)\n{\n    int sum = 0;\n    for (int i = 1; i <= n; ++i)\n    {\n        if (i % 3 == 0 || i % 5 == 0)\n        {\n            sum += i;\n        }\n    }\n    return sum;\n}\n\nProvide a concise natural language description (docstring) of the CPP code in English using at most 500 characters.",
      "es": "int sumOfMultiples(int n)\n{\n    int sum = 0;\n    for (int i = 1; i <= n; ++i)\n    {\n        if (i % 3 == 0 || i % 5 == 0)\n        {\n            sum += i;\n        }\n    }\n    return sum;\n}\n\nProporcione una descripción concisa en lenguaje natural (docstring) del código CPP en español utilizando como máximo 500 caracteres.",
      "arb": "int sumOfMultiples(int n)\n{\n    int sum = 0;\n    for (int i = 1; i <= n; ++i)\n    {\n        if (i % 3 == 0 || i % 5 == 0)\n        {\n            sum += i;\n        }\n    }\n    return sum;\n}\n\nيرجى تقديم وصف موجز بلغة طبيعية (docstring) للكود المكتوب بلغة C++ باللغة العربية الفصحى، بحيث لا يتجاوز 500 حرف.",
      "sw": "int sumOfMultiples(int n)\n{\n    int sum = 0;\n    for (int i = 1; i <= n; ++i)\n    {\n        if (i % 3 == 0 || i % 5 == 0)\n        {\n            sum += i;\n        }\n    }\n    return sum;\n}\n\nToa maelezo mafupi ya lugha ya asili (docstring) ya msimbo wa CPP kwa Kiswahili kwa kutumia herufi zisizozidi 500.",
      "tr": "int sumOfMultiples(int n)\n{\n    int sum = 0;\n    for (int i = 1; i <= n; ++i)\n    {\n        if (i % 3 == 0 || i % 5 == 0)\n        {\n            sum += i;\n        }\n    }\n    return sum;\n}\n\nAşağıdaki CPP kodunun Türkçe olarak en fazla 500 karakter kullanarak kısa bir doğal dil açıklamasını (docstring) sağlayın.",
      "vi": "int sumOfMultiples(int n)\n{\n    int sum = 0;\n    for (int i = 1; i <= n; ++i)\n    {\n        if (i % 3 == 0 || i % 5 == 0)\n        {\n            sum += i;\n        }\n    }\n    return sum;\n}\n\nCung cấp mô tả ngắn gọn bằng ngôn ngữ tự nhiên (docstring) cho mã CPP bằng tiếng Việt với tối đa 500 ký tự."
    },
    "instruction_bertscore": {
      "es": "0.9695565173899258",
      "arb": "0.8245899077688523",
      "sw": "0.9108155548064784",
      "tr": "0.8766952252130673",
      "vi": "0.9171611995893999"
    },
    "level": "",
    "test": "int main()\n{\n    assert(sumOfMultiples(10) == 33);\n    assert(sumOfMultiples(15) == 60);\n    assert(sumOfMultiples(20) == 98);\n    assert(sumOfMultiples(5) == 8);\n    assert(sumOfMultiples(3) == 3);\n    assert(sumOfMultiples(6) == 14);\n    assert(sumOfMultiples(9) == 23);\n    assert(sumOfMultiples(12) == 45);\n    assert(sumOfMultiples(17) == 60);\n    assert(sumOfMultiples(21) == 119);\n    assert(sumOfMultiples(25) == 168);\n\n    return 0;\n}",
    "entry_point": "sumOfMultiples",
    "signature": "int sumOfMultiples(int n)",
    "docstring": {
      "en": "Computes the sum of all numbers from 1 to n that are multiples of either 3 or 5.\n\nCounts each number only once even if it is a multiple of both 3 and 5.\nFor example:\n    std::cout << sumOfMultiples(10); // Outputs: 33 (3 + 5 + 6 + 9 + 10)\n\n@param n The upper bound of the range to check for multiples.\n@return The sum of the multiples of either 3 or 5 within the range.",
      "es": "Calcula la suma de todos los números desde 1 hasta n que son múltiplos de 3 o 5.\n\nCuenta cada número solo una vez, incluso si es un múltiplo de ambos 3 y 5.\nPor ejemplo:\n    std::cout << sumOfMultiples(10); // Outputs: 33 (3 + 5 + 6 + 9 + 10)\n\n@param n El límite superior del rango para verificar múltiplos.\n@return La suma de los múltiplos de 3 o 5 dentro del rango.",
      "arb": "يحسب مجموع جميع الأرقام من 1 إلى n التي هي مضاعفات إما لـ 3 أو 5.\n\nيحسب كل رقم مرة واحدة فقط حتى لو كان مضاعفًا لكل من 3 و 5. على سبيل المثال:\n    std::cout << sumOfMultiples(10); // المخرجات: 33 (3 + 5 + 6 + 9 + 10)\n\n@param n الحد الأعلى للنطاق للتحقق من المضاعفات.\n@return مجموع المضاعفات إما لـ 3 أو 5 ضمن النطاق.",
      "sw": "Hesabu jumla ya namba zote kutoka 1 hadi n ambazo ni maradufu ya aidha 3 au 5.\n\nHesabu kila namba mara moja tu hata kama ni maradufu ya 3 na 5.\nKwa mfano:\n    std::cout << sumOfMultiples(10); // Inatoa: 33 (3 + 5 + 6 + 9 + 10)\n\n@param n Kikomo cha juu cha safu ya kuangalia maradufu.\n@return Jumla ya maradufu ya aidha 3 au 5 ndani ya safu.",
      "tr": "1'den n'ye kadar olan sayılardan 3 veya 5'in katı olanların toplamını hesaplar.\n\nBir sayı hem 3 hem de 5'in katı olsa bile her sayıyı yalnızca bir kez sayar.\nÖrneğin:\n    std::cout << sumOfMultiples(10); // Çıktı: 33 (3 + 5 + 6 + 9 + 10)\n\n@param n Katları kontrol etmek için aralığın üst sınırı.\n@return Aralık içindeki 3 veya 5'in katlarının toplamı.",
      "vi": "Tính tổng của tất cả các số từ 1 đến n mà là bội số của 3 hoặc 5.\n\nĐếm mỗi số chỉ một lần ngay cả khi nó là bội số của cả 3 và 5.\nVí dụ:\n    std::cout << sumOfMultiples(10); // Kết quả: 33 (3 + 5 + 6 + 9 + 10)\n\n@param n Giới hạn trên của phạm vi để kiểm tra bội số.\n@return Tổng của các bội số của 3 hoặc 5 trong phạm vi."
    },
    "docstring_bertscore": {
      "es": "0.9703101210555721",
      "arb": "0.9734274262555337",
      "sw": "0.9763230599502603",
      "tr": "0.9471921268980646",
      "vi": "0.9384895340137831"
    }
  },
  {
    "task_id": "CPP/47",
    "prompt": {
      "en": "#include <cassert>\n#include <cctype> // For isalnum and tolower\n#include <cstring> // For strlen\n/**\n * Determine if a given string is a palindrome. A palindrome is a word, phrase,\n * number, or other sequence of characters that reads the same forward and\n * backward (ignoring spaces, punctuation, and capitalization).\n * Examples:\n *   >>> isPalindrome(\"racecar\")\n *   true\n *   >>> isPalindrome(\"hello\")\n *   false\n */\nbool isPalindrome(const char* str)",
      "es": "#include <cassert>\n#include <cctype> // For isalnum and tolower\n#include <cstring> // For strlen\n/**\n * Determinar si una cadena dada es un palíndromo. Un palíndromo es una palabra, frase,\n * número u otra secuencia de caracteres que se lee igual de adelante hacia atrás\n * y de atrás hacia adelante (ignorando espacios, puntuación y mayúsculas).\n * Ejemplos:\n *   >>> isPalindrome(\"racecar\")\n *   true\n *   >>> isPalindrome(\"hello\")\n *   false\n */\nbool isPalindrome(const char* str)",
      "arb": "#include <cassert>\n#include <cctype> // For isalnum and tolower\n#include <cstring> // For strlen\n/**\n * تحديد ما إذا كانت سلسلة معينة هي كلمة متكاملة. الكلمة المتكاملة هي كلمة أو عبارة أو\n * رقم أو تسلسل آخر من الأحرف الذي يقرأ نفسه بنفس الطريقة من الأمام إلى الخلف\n * والعكس صحيح (مع تجاهل المسافات وعلامات الترقيم والحروف الكبيرة).\n * أمثلة:\n *   >>> isPalindrome(\"racecar\")\n *   true\n *   >>> isPalindrome(\"hello\")\n *   false\n */\nbool isPalindrome(const char* str)",
      "sw": "#include <cassert>\n#include <cctype> // For isalnum and tolower\n#include <cstring> // For strlen\n/**\n * Kuamua kama kamba iliyotolewa ni palindrome. Palindrome ni neno, kifungu,\n * nambari, au mlolongo mwingine wa herufi ambao unasomwa sawa mbele na\n * nyuma (ukipuuza nafasi, alama za uakifishaji, na herufi kubwa).\n * Mifano:\n *   >>> isPalindrome(\"racecar\")\n *   true\n *   >>> isPalindrome(\"hello\")\n *   false\n */\nbool isPalindrome(const char* str)",
      "tr": "#include <cassert>\n#include <cctype> // isalnum ve tolower için\n#include <cstring> // strlen için\n/**\n * Verilen bir dizgenin palindrom olup olmadığını belirleyin. Palindrom, ileri ve\n * geri okunduğunda aynı olan (boşluklar, noktalama işaretleri ve büyük/küçük harf farkı göz ardı edilerek)\n * kelime, ifade, sayı veya diğer karakter dizisidir.\n * Örnekler:\n *   >>> isPalindrome(\"racecar\")\n *   true\n *   >>> isPalindrome(\"hello\")\n *   false\n */\nbool isPalindrome(const char* str)",
      "vi": "#include <cassert>\n#include <cctype> // For isalnum and tolower\n#include <cstring> // For strlen\n/**\n * Xác định xem một chuỗi đã cho có phải là palindrome hay không. Một palindrome là một từ, cụm từ,\n * số, hoặc chuỗi ký tự khác mà đọc xuôi hay ngược đều giống nhau (bỏ qua khoảng trắng, dấu câu, và chữ hoa).\n * Ví dụ:\n *   >>> isPalindrome(\"racecar\")\n *   true\n *   >>> isPalindrome(\"hello\")\n *   false\n */\nbool isPalindrome(const char* str)"
    },
    "prompt_bertscore": {
      "es": "0.9977093944459057",
      "arb": "0.997050736102394",
      "sw": "0.9982335800214568",
      "tr": "0.9804212019717721",
      "vi": "0.9950815145048141"
    },
    "canonical_solution": "{\n    int start = 0;\n    int end = strlen(str) - 1;\n    \n    while (start < end) {\n        // Skip non-alphanumeric characters and handle case insensitivity\n        while (!isalnum(str[start]) && start < end) start++;\n        while (!isalnum(str[end]) && start < end) end--;\n        if (tolower(str[start]) != tolower(str[end]))\n            return false;\n        start++;\n        end--;\n    }\n    return true;\n}",
    "instruction": {
      "en": "bool isPalindrome(const char* str)\n{\n    int start = 0;\n    int end = strlen(str) - 1;\n    \n    while (start < end) {\n        // Skip non-alphanumeric characters and handle case insensitivity\n        while (!isalnum(str[start]) && start < end) start++;\n        while (!isalnum(str[end]) && start < end) end--;\n        if (tolower(str[start]) != tolower(str[end]))\n            return false;\n        start++;\n        end--;\n    }\n    return true;\n}\n\nProvide a concise natural language description (docstring) of the CPP code in English using at most 500 characters.",
      "es": "bool isPalindrome(const char* str)\n{\n    int start = 0;\n    int end = strlen(str) - 1;\n    \n    while (start < end) {\n        // Skip non-alphanumeric characters and handle case insensitivity\n        while (!isalnum(str[start]) && start < end) start++;\n        while (!isalnum(str[end]) && start < end) end--;\n        if (tolower(str[start]) != tolower(str[end]))\n            return false;\n        start++;\n        end--;\n    }\n    return true;\n}\n\nProporcione una descripción concisa en lenguaje natural (docstring) del código CPP en español utilizando como máximo 500 caracteres.",
      "arb": "bool isPalindrome(const char* str)\n{\n    int start = 0;\n    int end = strlen(str) - 1;\n    \n    while (start < end) {\n        // Skip non-alphanumeric characters and handle case insensitivity\n        while (!isalnum(str[start]) && start < end) start++;\n        while (!isalnum(str[end]) && start < end) end--;\n        if (tolower(str[start]) != tolower(str[end]))\n            return false;\n        start++;\n        end--;\n    }\n    return true;\n}\n\nيرجى تقديم وصف موجز بلغة طبيعية (docstring) لشفرة CPP باللغة العربية الفصحى باستخدام ما لا يزيد عن 500 حرف.",
      "sw": "bool isPalindrome(const char* str)\n{\n    int start = 0;\n    int end = strlen(str) - 1;\n    \n    while (start < end) {\n        // Skip non-alphanumeric characters and handle case insensitivity\n        while (!isalnum(str[start]) && start < end) start++;\n        while (!isalnum(str[end]) && start < end) end--;\n        if (tolower(str[start]) != tolower(str[end]))\n            return false;\n        start++;\n        end--;\n    }\n    return true;\n}\n\nToa maelezo mafupi ya lugha ya asili (docstring) ya msimbo wa CPP kwa Kiswahili kwa kutumia herufi zisizozidi 500.",
      "tr": "bool isPalindrome(const char* str)\n{\n    int start = 0;\n    int end = strlen(str) - 1;\n    \n    while (start < end) {\n        // Skip non-alphanumeric characters and handle case insensitivity\n        while (!isalnum(str[start]) && start < end) start++;\n        while (!isalnum(str[end]) && start < end) end--;\n        if (tolower(str[start]) != tolower(str[end]))\n            return false;\n        start++;\n        end--;\n    }\n    return true;\n}\n\nAşağıdaki CPP kodunun işlevini açıklayan en fazla 500 karakterlik öz bir doğal dil açıklaması (docstring) sağlayın.",
      "vi": "bool isPalindrome(const char* str)\n{\n    int start = 0;\n    int end = strlen(str) - 1;\n    \n    while (start < end) {\n        // Skip non-alphanumeric characters and handle case insensitivity\n        while (!isalnum(str[start]) && start < end) start++;\n        while (!isalnum(str[end]) && start < end) end--;\n        if (tolower(str[start]) != tolower(str[end]))\n            return false;\n        start++;\n        end--;\n    }\n    return true;\n}\n\nCung cấp mô tả ngắn gọn bằng ngôn ngữ tự nhiên (docstring) cho mã CPP bằng tiếng Việt với tối đa 500 ký tự."
    },
    "instruction_bertscore": {
      "es": "0.9695565173899258",
      "arb": "0.9190017087000691",
      "sw": "0.9176812139269492",
      "tr": "0.8672189669946548",
      "vi": "0.9171611995893999"
    },
    "level": "",
    "test": "int main()\n{\n    assert(isPalindrome(\"A man a plan a canal Panama\") == true);\n    assert(isPalindrome(\"No lemon, no melon\") == true);\n    assert(isPalindrome(\"Was it a car or a cat I saw\") == true);\n    assert(isPalindrome(\"Madam, in Eden, I'm Adam\") == true);\n    assert(isPalindrome(\"Never odd or even\") == true);\n    assert(isPalindrome(\"Eva, can I see bees in a cave\") == true);\n    assert(isPalindrome(\"hello\") == false);\n    assert(isPalindrome(\"GitHub\") == false);\n    assert(isPalindrome(\"programming\") == false);\n    \n    return 0;\n}",
    "entry_point": "isPalindrome",
    "signature": "bool isPalindrome(const char* str)",
    "docstring": {
      "en": "Determine if a given string is a palindrome. A palindrome is a word, phrase, number, or other sequence of characters that reads the same forward and backward (ignoring spaces, punctuation, and capitalization).\nExamples:\n  >>> isPalindrome(\"racecar\")\n  true\n  >>> isPalindrome(\"hello\")\n  false",
      "es": "Determinar si una cadena dada es un palíndromo. Un palíndromo es una palabra, frase, número u otra secuencia de caracteres que se lee igual de adelante hacia atrás (ignorando espacios, puntuación y mayúsculas).\n\nEjemplos:\n  >>> isPalindrome(\"racecar\")\n  true\n  >>> isPalindrome(\"hello\")\n  false",
      "arb": "تحديد ما إذا كانت سلسلة معينة هي جملة مقلوبة. الجملة المقلوبة هي كلمة أو عبارة أو رقم أو تسلسل آخر من الأحرف التي تُقرأ بنفس الطريقة للأمام والخلف (مع تجاهل المسافات وعلامات الترقيم والحروف الكبيرة).\n\nأمثلة:\n  >>> isPalindrome(\"racecar\")\n  true\n  >>> isPalindrome(\"hello\")\n  false",
      "sw": "Amua kama kamba fulani ni palindrome. Palindrome ni neno, kifungu, nambari, au mlolongo mwingine wa herufi ambao unasomwa sawa mbele na nyuma (kupuuza nafasi, alama za uakifishaji, na herufi kubwa na ndogo).\n\nMifano:\n  >>> isPalindrome(\"racecar\")\n  true\n  >>> isPalindrome(\"hello\")\n  false",
      "tr": "Verilen bir stringin palindrom olup olmadığını belirleyin. Palindrom, ileri ve geri okunduğunda aynı olan (boşluklar, noktalama işaretleri ve büyük/küçük harf duyarlılığı göz ardı edilerek) bir kelime, ifade, sayı veya başka bir karakter dizisidir.\nÖrnekler:\n  >>> isPalindrome(\"racecar\")\n  true\n  >>> isPalindrome(\"hello\")\n  false",
      "vi": "Xác định xem một chuỗi cho trước có phải là palindrome hay không. Một palindrome là một từ, cụm từ, số, hoặc chuỗi ký tự khác mà đọc xuôi hay ngược đều giống nhau (bỏ qua khoảng trắng, dấu câu và chữ hoa chữ thường).\n\nVí dụ:\n  >>> isPalindrome(\"racecar\")\n  true\n  >>> isPalindrome(\"hello\")\n  false"
    },
    "docstring_bertscore": {
      "es": "1",
      "arb": "0.9990139987885428",
      "sw": "1",
      "tr": "0.9831960683948295",
      "vi": "0.9971899759994994"
    }
  },
  {
    "task_id": "CPP/48",
    "prompt": {
      "en": "#include <cassert>\n#include <cstdio>\n/*\nGiven a non-negative integer num, this function reduces it to a single digit by repeatedly adding all its digits.\nFor example:\n    >>> addDigits(38)\n    2\nThe calculation is because 3 + 8 = 11, and further 1 + 1 = 2. 2 is returned since it is a single-digit number.\n*/\nint addDigits(int num)",
      "es": "#include <cassert>\n#include <cstdio>\n/*\nDado un número entero no negativo num, esta función lo reduce a un solo dígito sumando repetidamente todos sus dígitos.\nPor ejemplo:\n    >>> addDigits(38)\n    2\nEl cálculo es porque 3 + 8 = 11, y además 1 + 1 = 2. Se devuelve 2 ya que es un número de un solo dígito.\n*/\nint addDigits(int num)",
      "arb": "#include <cassert>\n#include <cstdio>\n/*\nبالنظر إلى عدد صحيح غير سالب num، تقوم هذه الدالة بتقليله إلى رقم واحد عن طريق جمع جميع أرقامه بشكل متكرر.\nعلى سبيل المثال:\n    >>> addDigits(38)\n    2\nالحساب هو لأن 3 + 8 = 11، ومزيد من 1 + 1 = 2. يتم إرجاع 2 لأنه رقم مكون من خانة واحدة.\n*/\nint addDigits(int num)",
      "sw": "#include <cassert>\n#include <cstdio>\n/*\nIkizingatiwa nambari isiyo hasi num, kazi hii inapunguza hadi tarakimu moja kwa kuongeza mara kwa mara tarakimu zake zote.\nKwa mfano:\n    >>> addDigits(38)\n    2\nHesabu ni kwa sababu 3 + 8 = 11, na zaidi 1 + 1 = 2. 2 inarudishwa kwa kuwa ni nambari ya tarakimu moja.\n*/\nint addDigits(int num)",
      "tr": "#include <cassert>\n#include <cstdio>\n/*\nVerilen negatif olmayan bir tam sayı num, bu fonksiyon tüm basamaklarını tekrar tekrar toplayarak tek bir rakama indirger.\nÖrneğin:\n    >>> addDigits(38)\n    2\nHesaplama, 3 + 8 = 11 ve daha sonra 1 + 1 = 2 olduğu içindir. 2, tek basamaklı bir sayı olduğu için döndürülür.\n*/\nint addDigits(int num)",
      "vi": "#include <cassert>\n#include <cstdio>\n/*\nCho một số nguyên không âm num, hàm này giảm nó xuống một chữ số bằng cách liên tục cộng tất cả các chữ số của nó.\nVí dụ:\n    >>> addDigits(38)\n    2\nPhép tính là vì 3 + 8 = 11, và tiếp tục 1 + 1 = 2. 2 được trả về vì nó là một số có một chữ số.\n*/\nint addDigits(int num)"
    },
    "prompt_bertscore": {
      "es": "0.9746619140736655",
      "arb": "0.9878072726905545",
      "sw": "0.9948773224731102",
      "tr": "0.970030052218313",
      "vi": "0.9839667542732449"
    },
    "canonical_solution": "{\n    while (num >= 10) {\n        int sum = 0;\n        while (num > 0) {\n            sum += num % 10;\n            num /= 10;\n        }\n        num = sum;\n    }\n    return num;\n}",
    "instruction": {
      "en": "int addDigits(int num)\n{\n    while (num >= 10) {\n        int sum = 0;\n        while (num > 0) {\n            sum += num % 10;\n            num /= 10;\n        }\n        num = sum;\n    }\n    return num;\n}\n\nProvide a concise natural language description (docstring) of the CPP code in English using at most 500 characters.",
      "es": "int addDigits(int num)\n{\n    while (num >= 10) {\n        int sum = 0;\n        while (num > 0) {\n            sum += num % 10;\n            num /= 10;\n        }\n        num = sum;\n    }\n    return num;\n}\n\nProporcione una descripción concisa en lenguaje natural (docstring) del código CPP en español utilizando como máximo 500 caracteres.",
      "arb": "int addDigits(int num)\n{\n    while (num >= 10) {\n        int sum = 0;\n        while (num > 0) {\n            sum += num % 10;\n            num /= 10;\n        }\n        num = sum;\n    }\n    return num;\n}\n\nقدم وصفًا موجزًا بلغة طبيعية (docstring) لشفرة CPP باللغة العربية الفصحى باستخدام 500 حرف كحد أقصى.",
      "sw": "int addDigits(int num)\n{\n    while (num >= 10) {\n        int sum = 0;\n        while (num > 0) {\n            sum += num % 10;\n            num /= 10;\n        }\n        num = sum;\n    }\n    return num;\n}\n\nToa maelezo mafupi ya lugha ya asili (docstring) ya msimbo wa CPP kwa Kiswahili kwa kutumia herufi zisizozidi 500.",
      "tr": "int addDigits(int num)\n{\n    while (num >= 10) {\n        int sum = 0;\n        while (num > 0) {\n            sum += num % 10;\n            num /= 10;\n        }\n        num = sum;\n    }\n    return num;\n}\n\nAşağıdaki CPP kodunun Türkçe'de en fazla 500 karakter kullanarak kısa bir doğal dil açıklamasını (docstring) sağlayın.",
      "vi": "int addDigits(int num)\n{\n    while (num >= 10) {\n        int sum = 0;\n        while (num > 0) {\n            sum += num % 10;\n            num /= 10;\n        }\n        num = sum;\n    }\n    return num;\n}\n\nCung cấp mô tả ngắn gọn bằng ngôn ngữ tự nhiên (docstring) cho mã CPP bằng tiếng Việt với tối đa 500 ký tự."
    },
    "instruction_bertscore": {
      "es": "0.9695565173899258",
      "arb": "0.92360059791217",
      "sw": "0.9176812139269492",
      "tr": "0.8890214321385683",
      "vi": "0.9171611995893999"
    },
    "level": "",
    "test": "int main() {\n    assert(addDigits(38) == 2);\n    assert(addDigits(0) == 0);\n    assert(addDigits(9) == 9);\n    assert(addDigits(123) == 6);\n    assert(addDigits(456) == 6);\n    assert(addDigits(9999) == 9);\n    assert(addDigits(100) == 1);\n    assert(addDigits(1010) == 2);\n    assert(addDigits(1234) == 1);\n    assert(addDigits(9876) == 3);\n    assert(addDigits(199) == 1);\n    return 0;\n}",
    "entry_point": "addDigits",
    "signature": "int addDigits(int num)",
    "docstring": {
      "en": "Given a non-negative integer num, this function reduces it to a single digit by repeatedly adding all its digits.\nFor example:\n    >>> addDigits(38)\n    2\nThe calculation is because 3 + 8 = 11, and further 1 + 1 = 2. 2 is returned since it is a single-digit number.\n",
      "es": "Dado un número entero no negativo num, esta función lo reduce a un solo dígito sumando repetidamente todos sus dígitos.\nPor ejemplo:\n    >>> addDigits(38)\n    2\nEl cálculo es porque 3 + 8 = 11, y además 1 + 1 = 2. Se devuelve 2 ya que es un número de un solo dígito.",
      "arb": "بالنظر إلى عدد صحيح غير سالب num، تقوم هذه الدالة بتقليله إلى رقم واحد عن طريق جمع جميع أرقامه بشكل متكرر.\nعلى سبيل المثال:\n    >>> addDigits(38)\n    2\nالحساب هو لأن 3 + 8 = 11، وأيضًا 1 + 1 = 2. يتم إرجاع 2 لأنه رقم مكون من خانة واحدة.",
      "sw": "Kwa kupewa nambari isiyo hasi num, kazi hii inapunguza hadi tarakimu moja kwa kuongeza mara kwa mara tarakimu zake zote. \n\nKwa mfano:\n    >>> addDigits(38)\n    2\n\nHesabu ni kwa sababu 3 + 8 = 11, na zaidi 1 + 1 = 2. 2 inarudishwa kwa kuwa ni nambari ya tarakimu moja.",
      "tr": "Verilen negatif olmayan bir tamsayı num için, bu fonksiyon tüm basamaklarını tekrar tekrar toplayarak onu tek bir rakama indirger.\nÖrneğin:\n    >>> addDigits(38)\n    2\nHesaplama 3 + 8 = 11 ve daha sonra 1 + 1 = 2 olduğu içindir. 2, tek basamaklı bir sayı olduğu için döndürülür.",
      "vi": "Cho một số nguyên không âm num, hàm này sẽ giảm nó xuống một chữ số bằng cách liên tục cộng tất cả các chữ số của nó.\nVí dụ:\n    >>> addDigits(38)\n    2\nPhép tính là vì 3 + 8 = 11, và tiếp tục 1 + 1 = 2. 2 được trả về vì nó là một số có một chữ số."
    },
    "docstring_bertscore": {
      "es": "0.9783915967383576",
      "arb": "0.974857962259747",
      "sw": "0.9901260837587557",
      "tr": "0.9446139045522318",
      "vi": "0.9727280486839098"
    }
  },
  {
    "task_id": "CPP/49",
    "prompt": {
      "en": "#include <cassert>\n#include <cstdio>\n/**\n * You are playing a game called Nim. In this game, you start with a pile of n stones, and you and\n * your opponent take turns to remove 1 to 3 stones from the pile. The one who removes the last\n * stone wins the game. Given the number of stones n, determine if you can win the game if both you\n * and your opponent play optimally.\n * Note: You always take the first turn.\n *\n * Here are some cases:\n *     >>> canWinNim(1)\n *     true\n */\nbool canWinNim(int n)",
      "es": "#include <cassert>\n#include <cstdio>\n/**\n * Estás jugando un juego llamado Nim. En este juego, comienzas con una pila de n piedras, y tú y\n * tu oponente se turnan para quitar de 1 a 3 piedras de la pila. Quien quite la última\n * piedra gana el juego. Dado el número de piedras n, determina si puedes ganar el juego si tanto tú\n * como tu oponente juegan de manera óptima.\n * Nota: Siempre tomas el primer turno.\n *\n * Aquí hay algunos casos:\n *     >>> canWinNim(1)\n *     true\n */\nbool canWinNim(int n)",
      "arb": "#include <cassert>\n#include <cstdio>\n/**\n * أنت تلعب لعبة تسمى نيم. في هذه اللعبة، تبدأ بكومة من الحجارة n، وأنت وخصمك تتناوبان على إزالة 1 إلى 3 حجارة من الكومة. الشخص الذي يزيل آخر حجر يفوز باللعبة. بالنظر إلى عدد الحجارة n، حدد ما إذا كان بإمكانك الفوز باللعبة إذا كنت أنت وخصمك تلعبان بشكل مثالي.\n * ملاحظة: أنت دائمًا تأخذ الدور الأول.\n *\n * هنا بعض الحالات:\n *     >>> canWinNim(1)\n *     true\n */\nbool canWinNim(int n)",
      "sw": "#include <cassert>\n#include <cstdio>\n/**\n * Unacheza mchezo unaoitwa Nim. Katika mchezo huu, unaanza na rundo la mawe n, na wewe na\n * mpinzani wako mnapokezana kuondoa mawe 1 hadi 3 kutoka kwenye rundo. Yule anayeondoa jiwe la mwisho\n * anashinda mchezo. Ukipewa idadi ya mawe n, amua kama unaweza kushinda mchezo ikiwa wote wewe\n * na mpinzani wako mna cheza kwa ustadi.\n * Kumbuka: Daima unachukua zamu ya kwanza.\n *\n * Hizi ni baadhi ya kesi:\n *     >>> canWinNim(1)\n *     true\n */\nbool canWinNim(int n)",
      "tr": "#include <cassert>\n#include <cstdio>\n/**\n * Nim adında bir oyun oynuyorsunuz. Bu oyunda, n taşlık bir yığınla başlarsınız ve siz ve\n * rakibiniz sırayla yığından 1 ila 3 taş çıkarırsınız. Son taşı çıkaran oyunu kazanır. Taş sayısı n\n * verildiğinde, hem siz hem de rakibiniz en iyi şekilde oynarsa oyunu kazanıp kazanamayacağınızı\n * belirleyin.\n * Not: Her zaman ilk hamleyi siz yaparsınız.\n *\n * İşte bazı durumlar:\n *     >>> canWinNim(1)\n *     true\n */\nbool canWinNim(int n)",
      "vi": "#include <cassert>\n#include <cstdio>\n/**\n * Bạn đang chơi một trò chơi gọi là Nim. Trong trò chơi này, bạn bắt đầu với một đống n viên đá, và bạn cùng\n * đối thủ của bạn lần lượt lấy đi từ 1 đến 3 viên đá từ đống. Người lấy viên đá cuối cùng sẽ thắng trò chơi. Cho số lượng viên đá n, xác định xem bạn có thể thắng trò chơi nếu cả bạn\n * và đối thủ của bạn chơi tối ưu hay không.\n * Lưu ý: Bạn luôn đi trước.\n *\n * Dưới đây là một số trường hợp:\n *     >>> canWinNim(1)\n *     true\n */\nbool canWinNim(int n)"
    },
    "prompt_bertscore": {
      "es": "0.9936644853665112",
      "arb": "0.9784231789689422",
      "sw": "0.9919683805428543",
      "tr": "0.9785785079269115",
      "vi": "0.9798576875807762"
    },
    "canonical_solution": "{\n    return n % 4 != 0;\n}",
    "instruction": {
      "en": "bool canWinNim(int n)\n{\n    return n % 4 != 0;\n}\n\nProvide a concise natural language description (docstring) of the CPP code in English using at most 500 characters.",
      "es": "bool canWinNim(int n)\n{\n    return n % 4 != 0;\n}\n\nProporcione una descripción concisa en lenguaje natural (docstring) del código CPP en español utilizando como máximo 500 caracteres.",
      "arb": "bool canWinNim(int n)\n{\n    return n % 4 != 0;\n}\n\nيرجى تقديم وصف موجز بلغة طبيعية (docstring) للكود المكتوب بلغة C++ باللغة العربية الفصحى، بحيث لا يتجاوز 500 حرف.",
      "sw": "bool canWinNim(int n)\n{\n    return n % 4 != 0;\n}\n\nToa maelezo mafupi ya lugha asilia (docstring) ya msimbo wa CPP kwa Kiswahili kwa kutumia herufi zisizozidi 500.",
      "tr": "bool canWinNim(int n)\n{\n    return n % 4 != 0;\n}\n\nAşağıdaki CPP kodunun Türkçe'de en fazla 500 karakter kullanarak kısa bir doğal dil açıklamasını (docstring) sağlayın.",
      "vi": "bool canWinNim(int n)\n{\n    return n % 4 != 0;\n}\n\nCung cấp mô tả ngắn gọn bằng ngôn ngữ tự nhiên (docstring) cho mã CPP bằng tiếng Việt với tối đa 500 ký tự."
    },
    "instruction_bertscore": {
      "es": "0.9695565173899258",
      "arb": "0.8245899077688523",
      "sw": "0.9449839529520998",
      "tr": "0.8874105397483754",
      "vi": "0.9343528576983505"
    },
    "level": "",
    "test": "int main() {\n    assert(canWinNim(1) == true);\n    assert(canWinNim(2) == true);\n    assert(canWinNim(3) == true);\n    assert(canWinNim(4) == false);\n    assert(canWinNim(5) == true);\n    assert(canWinNim(6) == true);\n    assert(canWinNim(7) == true);\n    assert(canWinNim(8) == false);\n    assert(canWinNim(9) == true);\n    assert(canWinNim(10) == true);\n    assert(canWinNim(11) == true);\n    assert(canWinNim(12) == false);\n    assert(canWinNim(13) == true);\n    assert(canWinNim(14) == true);\n    assert(canWinNim(15) == true);\n    assert(canWinNim(16) == false);\n    assert(canWinNim(17) == true);\n    assert(canWinNim(18) == true);\n    assert(canWinNim(19) == true);\n    assert(canWinNim(20) == false);\n    return 0;\n}",
    "entry_point": "canWinNim",
    "signature": "bool canWinNim(int n)",
    "docstring": {
      "en": "You are playing a game called Nim. In this game, you start with a pile of n stones, and you and\nyour opponent take turns to remove 1 to 3 stones from the pile. The one who removes the last\nstone wins the game. Given the number of stones n, determine if you can win the game if both you\nand your opponent play optimally.\nNote: You always take the first turn.\n\nHere are some cases:\n    >>> canWinNim(1)\n    true\n",
      "es": "Estás jugando un juego llamado Nim. En este juego, comienzas con una pila de n piedras, y tú y tu oponente se turnan para quitar de 1 a 3 piedras de la pila. El que quita la última piedra gana el juego. Dado el número de piedras n, determina si puedes ganar el juego si tanto tú como tu oponente juegan de manera óptima.\nNota: Siempre tomas el primer turno.\n\nAquí hay algunos casos:\n    >>> canWinNim(1)\n    true",
      "arb": "أنت تلعب لعبة تسمى نيم. في هذه اللعبة، تبدأ بكومة من الحجارة عددها n، وأنت وخصمك تتناوبان على إزالة 1 إلى 3 حجارة من الكومة. الشخص الذي يزيل آخر حجر يفوز باللعبة. بالنظر إلى عدد الحجارة n، حدد ما إذا كان بإمكانك الفوز باللعبة إذا لعبت أنت وخصمك بشكل مثالي.\nملاحظة: أنت دائمًا تأخذ الدور الأول.\n\nهنا بعض الحالات:\n    >>> canWinNim(1)\n    true",
      "sw": "Unacheza mchezo unaoitwa Nim. Katika mchezo huu, unaanza na rundo la mawe n, na wewe na mpinzani wako mnachukua zamu kuondoa mawe 1 hadi 3 kutoka kwenye rundo. Yule anayeondoa jiwe la mwisho anashinda mchezo. Ukipewa idadi ya mawe n, amua kama unaweza kushinda mchezo ikiwa wewe na mpinzani wako mna cheza kwa ustadi.\n\nKumbuka: Daima unachukua zamu ya kwanza.\n\nHapa kuna baadhi ya kesi:\n    >>> canWinNim(1)\n    true",
      "tr": "Nim adlı bir oyun oynuyorsunuz. Bu oyunda, n taşlık bir yığınla başlarsınız ve siz ve rakibiniz sırayla yığından 1 ila 3 taş alırsınız. Son taşı alan oyunu kazanır. Taş sayısı n verildiğinde, hem sizin hem de rakibinizin en iyi şekilde oynadığı durumda oyunu kazanıp kazanamayacağınızı belirleyin. \nNot: Her zaman ilk hamleyi siz yaparsınız.\n\nİşte bazı durumlar:\n    >>> canWinNim(1)\n    true\n",
      "vi": "Bạn đang chơi một trò chơi có tên là Nim. Trong trò chơi này, bạn bắt đầu với một đống n viên đá, và bạn cùng đối thủ luân phiên nhau loại bỏ từ 1 đến 3 viên đá khỏi đống. Người nào loại bỏ viên đá cuối cùng sẽ thắng trò chơi. Với số lượng viên đá n cho trước, xác định xem bạn có thể thắng trò chơi hay không nếu cả bạn và đối thủ đều chơi tối ưu. \nLưu ý: Bạn luôn đi trước.\n\nDưới đây là một số trường hợp:\n    >>> canWinNim(1)\n    true"
    },
    "docstring_bertscore": {
      "es": "0.9948346169411877",
      "arb": "0.9782660623375435",
      "sw": "0.9899181177498122",
      "tr": "0.9727381788333427",
      "vi": "0.9816066280857884"
    }
  },
  {
    "task_id": "CPP/50",
    "prompt": {
      "en": "#include <cassert>\n#include <cstdio>\n/**\n * Given two integers a and b, return the sum if the sum is even, or the product of a and b if the sum is odd.\n * Examples:\n *    evenSumOrOddProduct(2, 3) returns 6\n *    evenSumOrOddProduct(5, 5) returns 10\n */\nint evenSumOrOddProduct(int a, int b)",
      "es": "#include <cassert>\n#include <cstdio>\n/**\n * Dados dos enteros a y b, devuelve la suma si la suma es par, o el producto de a y b si la suma es impar.\n * Ejemplos:\n *    evenSumOrOddProduct(2, 3) returns 6\n *    evenSumOrOddProduct(5, 5) returns 10\n */\nint evenSumOrOddProduct(int a, int b)",
      "arb": "#include <cassert>\n#include <cstdio>\n/**\n * معطى عددين صحيحين a و b، أعد المجموع إذا كان المجموع زوجيًا، أو حاصل ضرب a و b إذا كان المجموع فرديًا.\n * أمثلة:\n *    evenSumOrOddProduct(2, 3) returns 6\n *    evenSumOrOddProduct(5, 5) returns 10\n */\nint evenSumOrOddProduct(int a, int b)",
      "sw": "#include <cassert>\n#include <cstdio>\n/**\n * Ukipewa nambari mbili a na b, rudisha jumla ikiwa jumla ni shufwa, au bidhaa ya a na b ikiwa jumla ni witiri.\n * Mifano:\n *    evenSumOrOddProduct(2, 3) returns 6\n *    evenSumOrOddProduct(5, 5) returns 10\n */\nint evenSumOrOddProduct(int a, int b)",
      "tr": "#include <cassert>\n#include <cstdio>\n/**\n * İki tamsayı a ve b verildiğinde, toplam çift ise toplamı, toplam tek ise a ve b'nin çarpımını döndürün.\n * Örnekler:\n *    evenSumOrOddProduct(2, 3) 6 döndürür\n *    evenSumOrOddProduct(5, 5) 10 döndürür\n */\nint evenSumOrOddProduct(int a, int b)",
      "vi": "#include <cassert>\n#include <cstdio>\n/**\n * Cho hai số nguyên a và b, trả về tổng nếu tổng là số chẵn, hoặc tích của a và b nếu tổng là số lẻ.\n * Ví dụ:\n *    evenSumOrOddProduct(2, 3) trả về 6\n *    evenSumOrOddProduct(5, 5) trả về 10\n */\nint evenSumOrOddProduct(int a, int b)"
    },
    "prompt_bertscore": {
      "es": "0.9969557907802593",
      "arb": "1",
      "sw": "0.9908320161329537",
      "tr": "1",
      "vi": "0.9972753870633444"
    },
    "canonical_solution": "{\n    int sum = a + b;\n    if (sum % 2 == 0)\n        return sum;\n    else\n        return a * b;\n}",
    "instruction": {
      "en": "int evenSumOrOddProduct(int a, int b)\n{\n    int sum = a + b;\n    if (sum % 2 == 0)\n        return sum;\n    else\n        return a * b;\n}\n\nProvide a concise natural language description (docstring) of the CPP code in English using at most 500 characters.",
      "es": "int evenSumOrOddProduct(int a, int b)\n{\n    int sum = a + b;\n    if (sum % 2 == 0)\n        return sum;\n    else\n        return a * b;\n}\n\nProporcione una descripción concisa en lenguaje natural (docstring) del código CPP en español utilizando como máximo 500 caracteres.",
      "arb": "int evenSumOrOddProduct(int a, int b)\n{\n    int sum = a + b;\n    if (sum % 2 == 0)\n        return sum;\n    else\n        return a * b;\n}\n\nيرجى تقديم وصف موجز بلغة طبيعية (docstring) للكود المكتوب بلغة C++ باللغة العربية الفصحى، بحيث لا يتجاوز 500 حرف.",
      "sw": "int evenSumOrOddProduct(int a, int b)\n{\n    int sum = a + b;\n    if (sum % 2 == 0)\n        return sum;\n    else\n        return a * b;\n}\n\nToa maelezo mafupi ya lugha ya asili (docstring) ya msimbo wa CPP kwa Kiswahili kwa kutumia herufi zisizozidi 500.",
      "tr": "int evenSumOrOddProduct(int a, int b)\n{\n    int sum = a + b;\n    if (sum % 2 == 0)\n        return sum;\n    else\n        return a * b;\n}\n\nAşağıdaki CPP kodunun Türkçe olarak en fazla 500 karakter kullanarak kısa bir doğal dil açıklamasını (docstring) sağlayın.",
      "vi": "int evenSumOrOddProduct(int a, int b)\n{\n    int sum = a + b;\n    if (sum % 2 == 0)\n        return sum;\n    else\n        return a * b;\n}\n\nCung cấp mô tả ngắn gọn bằng ngôn ngữ tự nhiên (docstring) cho mã CPP bằng tiếng Việt với tối đa 500 ký tự."
    },
    "instruction_bertscore": {
      "es": "0.9695565173899258",
      "arb": "0.8291343722565495",
      "sw": "0.9176812139269492",
      "tr": "0.8874105397483754",
      "vi": "0.9171611995893999"
    },
    "level": "",
    "test": "int main() {\n    assert(evenSumOrOddProduct(2, 3) == 6);\n    assert(evenSumOrOddProduct(5, 5) == 10);\n    assert(evenSumOrOddProduct(1, 1) == 2);\n    assert(evenSumOrOddProduct(0, 0) == 0);\n    assert(evenSumOrOddProduct(-1, -1) == -2);\n    assert(evenSumOrOddProduct(100, 200) == 300);\n    assert(evenSumOrOddProduct(3, 4) == 12);\n    assert(evenSumOrOddProduct(-5, 5) == 0);\n    assert(evenSumOrOddProduct(7, 8) == 56);\n    assert(evenSumOrOddProduct(9, 10) == 90);\n    assert(evenSumOrOddProduct(11, 14) == 154);\n    return 0;\n}",
    "entry_point": "evenSumOrOddProduct",
    "signature": "int evenSumOrOddProduct(int a, int b)",
    "docstring": {
      "en": "Given two integers a and b, return the sum if the sum is even, or the product of a and b if the sum is odd.\nExamples:\nevenSumOrOddProduct(2, 3) returns 6\nevenSumOrOddProduct(5, 5) returns 10",
      "es": "Dado dos enteros a y b, devuelve la suma si la suma es par, o el producto de a y b si la suma es impar.\nEjemplos:\nevenSumOrOddProduct(2, 3) devuelve 6\nevenSumOrOddProduct(5, 5) devuelve 10",
      "arb": "نظرًا لعددين صحيحين a و b، قم بإرجاع المجموع إذا كان المجموع زوجيًا، أو حاصل ضرب a و b إذا كان المجموع فرديًا.\nأمثلة:\nevenSumOrOddProduct(2, 3) returns 6\nevenSumOrOddProduct(5, 5) returns 10",
      "sw": "Ukipewa nambari mbili a na b, rudisha jumla ikiwa jumla ni shufwa, au bidhaa ya a na b ikiwa jumla ni witiri.\nMfano:\nevenSumOrOddProduct(2, 3) inarudisha 6\nevenSumOrOddProduct(5, 5) inarudisha 10",
      "tr": "Verilen iki tamsayı a ve b için, toplam çift ise toplamı, toplam tek ise a ve b'nin çarpımını döndürün.\nÖrnekler:\nevenSumOrOddProduct(2, 3) 6 döndürür\nevenSumOrOddProduct(5, 5) 10 döndürür",
      "vi": "Cho hai số nguyên a và b, trả về tổng nếu tổng là số chẵn, hoặc tích của a và b nếu tổng là số lẻ.\nVí dụ:\nevenSumOrOddProduct(2, 3) trả về 6\nevenSumOrOddProduct(5, 5) trả về 10"
    },
    "docstring_bertscore": {
      "es": "1",
      "arb": "1",
      "sw": "0.9969615510613093",
      "tr": "0.9395458503801266",
      "vi": "0.9969615510613093"
    }
  }
]