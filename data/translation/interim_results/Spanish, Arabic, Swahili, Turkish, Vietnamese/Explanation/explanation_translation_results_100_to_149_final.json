[
  {
    "task_id": "C/1",
    "prompt": {
      "es": "#include <assert.h>\n#include <string.h>\n// Devuelve \"Hello, MMCODEEVAL: Masssively Multilingual Code Evaluation\"\nchar *hello_mmcodeeval()",
      "arb": "#include <assert.h>\n#include <string.h>\n// إرجاع \"Hello, MMCODEEVAL: Masssively Multilingual Code Evaluation\"\nchar *hello_mmcodeeval()",
      "sw": "#include <assert.h>\n#include <string.h>\n// Rudisha \"Hello, MMCODEEVAL: Masssively Multilingual Code Evaluation\"\nchar *hello_mmcodeeval()",
      "tr": "#include <assert.h>\n#include <string.h>\n// çözün\"Hello, MMCODEEVAL: Masssively Multilingual Code Evaluation\" döndür\nchar *hello_mmcodeeval()",
      "vi": "#include <assert.h>\n#include <string.h>\n// Trả về \"Hello, MMCODEEVAL: Masssively Multilingual Code Evaluation\"\nchar *hello_mmcodeeval()"
    },
    "prompt_bertscore": {
      "es": "0.9978188397858558",
      "arb": "1",
      "sw": "0.9355251742072184",
      "tr": "1",
      "vi": "0.9134865375402544"
    },
    "canonical_solution": "{\n    return \"Hello, MMCODEEVAL: Masssively Multilingual Code Evaluation\";\n}",
    "instruction": {
      "es": "char *hello_mmcodeeval()\n{\n    return \"Hello, MMCODEEVAL: Masssively Multilingual Code Evaluation\";\n}\n\nProporcione una descripción concisa en lenguaje natural (docstring) del código C en español utilizando como máximo 500 caracteres.",
      "arb": "char *hello_mmcodeeval()\n{\n    return \"Hello, MMCODEEVAL: Masssively Multilingual Code Evaluation\";\n}\n\nيرجى تقديم وصف موجز بلغة طبيعية (docstring) للشفرة البرمجية بلغة C باللغة العربية الفصحى، بحيث لا يتجاوز 500 حرف.",
      "sw": "char *hello_mmcodeeval()\n{\n    return \"Hello, MMCODEEVAL: Masssively Multilingual Code Evaluation\";\n}\n\nToa maelezo mafupi ya lugha ya asili (docstring) ya msimbo wa C kwa Kiswahili kwa kutumia herufi zisizozidi 500.",
      "tr": "char *hello_mmcodeeval()\n{\n    return \"Hello, MMCODEEVAL: Masssively Multilingual Code Evaluation\";\n}\n\nC kodunun işlevini açıklayan kısa bir doğal dil açıklaması (docstring) sağlayın. Açıklama, en fazla 500 karakter kullanarak Türkçe olarak yazılmalıdır.",
      "vi": "char *hello_mmcodeeval()\n{\n    return \"Hello, MMCODEEVAL: Masssively Multilingual Code Evaluation\";\n}\n\nCung cấp mô tả ngắn gọn bằng ngôn ngữ tự nhiên (docstring) của mã C bằng tiếng Việt, sử dụng tối đa 500 ký tự."
    },
    "instruction_bertscore": {
      "es": "0.9687963589217052",
      "arb": "0.9123744060368401",
      "sw": "0.9146175389298671",
      "tr": "0.8827657669182556",
      "vi": "0.927643123426992"
    },
    "level": "",
    "test": "int main()\n{\n    assert(strcmp(hello_mmcodeeval(), \"Hello, MMCODEEVAL: Masssively Multilingual Code Evaluation\") == 0);\n    return 0;\n}",
    "entry_point": "hello_mmcodeeval",
    "signature": "char *hello_mmcodeeval()",
    "docstring": {
      "es": "Devuelve \"Hello, MMCODEEVAL: Masssively Multilingual Code Evaluation\"",
      "arb": "إرجاع \"Hello, MMCODEEVAL: Masssively Multilingual Code Evaluation\"",
      "sw": "Rudisha \"Hello, MMCODEEVAL: Masssively Multilingual Code Evaluation\"",
      "tr": "Return \"Hello, MMCODEEVAL: Masssively Multilingual Code Evaluation\"",
      "vi": "Trả về \"Hello, MMCODEEVAL: Masssively Multilingual Code Evaluation\""
    },
    "docstring_bertscore": {
      "es": "1",
      "arb": "1",
      "sw": "0.8844229401872296",
      "tr": "0.953923710511337",
      "vi": "0.9390822470707911"
    }
  },
  {
    "task_id": "C/2",
    "prompt": {
      "es": "#include <assert.h>\n#include <math.h>\n#include <stdbool.h>\n#include <stdio.h>\n#include <string.h>\n/*\nCalcular el área de un triángulo dados sus tres lados.\n    Parámetros:\n- a (float): Longitud del lado 'a'.\n- b (float): Longitud del lado 'b'.\n- c (float): Longitud del lado 'c'.\n    Devuelve:\n- str: Si los lados proporcionados forman un triángulo, devuelve el área calculada con 2 decimales.\nDe lo contrario, devuelve \"-1\"\n    >>> calculate_triangle_area(3,5,4)\n    6\n*/\ndouble calculate_triangle_area(double a, double b, double c)",
      "arb": "#include <assert.h>\n#include <math.h>\n#include <stdbool.h>\n#include <stdio.h>\n#include <string.h>\n/*\nاحسب مساحة المثلث المعطى أضلاعه الثلاثة.\n    المعاملات:\n- a (float): طول الضلع 'a'.\n- b (float): طول الضلع 'b'.\n- c (float): طول الضلع 'c'.\n    يعيد:\n- str: إذا كانت الأضلاع المقدمة تشكل مثلثًا، يعيد المساحة المحسوبة بدقة منزلتين عشريتين.\nخلاف ذلك، يعيد \"-1\"\n    >>> calculate_triangle_area(3,5,4)\n    6\n*/\ndouble calculate_triangle_area(double a, double b, double c)",
      "sw": "#include <assert.h>\n#include <math.h>\n#include <stdbool.h>\n#include <stdio.h>\n#include <string.h>\n/*\nHesabu eneo la pembetatu ukitumia pande zake tatu.\n​    Vigezo:\n- a (float): Urefu wa upande 'a'.\n- b (float): Urefu wa upande 'b'.\n- c (float): Urefu wa upande 'c'.\n​    Inarudisha:\n- str: Ikiwa pande zilizotolewa zinaunda pembetatu, rudisha eneo lililohesabiwa na sehemu 2 za desimali.\nVinginevyo, rudisha \"-1\"\n    >>> calculate_triangle_area(3,5,4)\n    6\n*/\ndouble calculate_triangle_area(double a, double b, double c)",
      "tr": "#include <assert.h>\n#include <math.h>\n#include <stdbool.h>\n#include <stdio.h>\n#include <string.h>\n/*\nÜç kenarı verilen bir üçgenin alanını hesaplayın.\n​    Parametreler:\n- a (float): 'a' kenarının uzunluğu.\n- b (float): 'b' kenarının uzunluğu.\n- c (float): 'c' kenarının uzunluğu.\n​    Döndürür:\n- str: Eğer verilen kenarlar bir üçgen oluşturuyorsa, hesaplanan alanı 2 ondalık basamakla döndürün.\nAksi takdirde, \"-1\" döndürün.\n    >>> calculate_triangle_area(3,5,4)\n    6\n*/\ndouble calculate_triangle_area(double a, double b, double c)",
      "vi": "#include <assert.h>\n#include <math.h>\n#include <stdbool.h>\n#include <stdio.h>\n#include <string.h>\n/*\nTính diện tích của một tam giác khi biết ba cạnh của nó.\n​    Tham số:\n- a (float): Độ dài cạnh 'a'.\n- b (float): Độ dài cạnh 'b'.\n- c (float): Độ dài cạnh 'c'.\n​    Trả về:\n- str: Nếu các cạnh được cung cấp tạo thành một tam giác, trả về diện tích đã tính với 2 chữ số thập phân.\nNếu không, trả về \"-1\"\n    >>> calculate_triangle_area(3,5,4)\n    6\n*/\ndouble calculate_triangle_area(double a, double b, double c)"
    },
    "prompt_bertscore": {
      "es": "0.9776175341434646",
      "arb": "0.981303319493948",
      "sw": "0.984497296020989",
      "tr": "0.9853744477836391",
      "vi": "0.9884347460642436"
    },
    "canonical_solution": "{\n    if (a + b > c && a + c > b && b + c > a) {\n        double s = (a + b + c) / 2.0;\n        return sqrt(s * (s - a) * (s - b) * (s - c));\n    } else {\n        // printf(\"Not a triangle.\\n\");\n        return -1; // Use a special value to indicate not a triangle\n    }\n}",
    "instruction": {
      "es": "double calculate_triangle_area(double a, double b, double c)\n{\n    if (a + b > c && a + c > b && b + c > a) {\n        double s = (a + b + c) / 2.0;\n        return sqrt(s * (s - a) * (s - b) * (s - c));\n    } else {\n        // printf(\"Not a triangle.\\n\");\n        return -1; // Use a special value to indicate not a triangle\n    }\n}\n\nProporcione una descripción concisa en lenguaje natural (docstring) del código C en español utilizando como máximo 500 caracteres.",
      "arb": "double calculate_triangle_area(double a, double b, double c)\n{\n    if (a + b > c && a + c > b && b + c > a) {\n        double s = (a + b + c) / 2.0;\n        return sqrt(s * (s - a) * (s - b) * (s - c));\n    } else {\n        // printf(\"Not a triangle.\\n\");\n        return -1; // Use a special value to indicate not a triangle\n    }\n}\n\nيرجى تقديم وصف موجز بلغة طبيعية (docstring) للكود المكتوب بلغة C باللغة العربية الفصحى، بحيث لا يتجاوز 500 حرف.",
      "sw": "double calculate_triangle_area(double a, double b, double c)\n{\n    if (a + b > c && a + c > b && b + c > a) {\n        double s = (a + b + c) / 2.0;\n        return sqrt(s * (s - a) * (s - b) * (s - c));\n    } else {\n        // printf(\"Not a triangle.\\n\");\n        return -1; // Use a special value to indicate not a triangle\n    }\n}\n\nToa maelezo mafupi ya lugha ya asili (docstring) ya msimbo wa C kwa Kiswahili kwa kutumia herufi zisizozidi 500.",
      "tr": "double calculate_triangle_area(double a, double b, double c)\n{\n    if (a + b > c && a + c > b && b + c > a) {\n        double s = (a + b + c) / 2.0;\n        return sqrt(s * (s - a) * (s - b) * (s - c));\n    } else {\n        // printf(\"Not a triangle.\\n\");\n        return -1; // Use a special value to indicate not a triangle\n    }\n}\n\nC kodunun işlevini açıklayan kısa bir doğal dil açıklaması (docstring) sağlayın. Açıklama, en fazla 500 karakter kullanarak Türkçe olarak yazılmalıdır.",
      "vi": "double calculate_triangle_area(double a, double b, double c)\n{\n    if (a + b > c && a + c > b && b + c > a) {\n        double s = (a + b + c) / 2.0;\n        return sqrt(s * (s - a) * (s - b) * (s - c));\n    } else {\n        // printf(\"Not a triangle.\\n\");\n        return -1; // Use a special value to indicate not a triangle\n    }\n}\n\nCung cấp mô tả ngắn gọn bằng ngôn ngữ tự nhiên (docstring) của mã C bằng tiếng Việt với tối đa 500 ký tự."
    },
    "instruction_bertscore": {
      "es": "0.9687963589217052",
      "arb": "0.8727085148353161",
      "sw": "0.9146175389298671",
      "tr": "0.8827657669182556",
      "vi": "0.9439043968311751"
    },
    "level": "",
    "test": "int main()\n{\n    double area;\n\n    // Triangle with sides 3, 5, 4 should return area 6\n    area = calculate_triangle_area(3, 5, 4);\n    assert(fabs(area - 6) < 1e-6);\n\n    // Not a triangle with sides 1, 1, 4 should print \"Not a triangle.\"\n    area = calculate_triangle_area(1, 1, 4);\n    assert(area == -1);\n\n    // Triangle with sides 7, 24, 25 should return area 84\n    area = calculate_triangle_area(7, 24, 25);\n    assert(fabs(area - 84) < 1e-6);\n\n    // Triangle with sides 10.5, 6.2, 7.3 should return a correct area\n    area = calculate_triangle_area(10.5, 6.2, 7.3);\n    // printf(\"%lf\\n\", area); // Print the area with 2 decimal places\n    // For precision issues, we test if the calculated area is close enough to the expected value\n    assert(fabs(area - 22.15) < 1e-2);\n\n    \n    return 0;\n}",
    "entry_point": "calculate_triangle_area",
    "signature": "double calculate_triangle_area(double a, double b, double c)",
    "docstring": {
      "es": "Calcular el área de un triángulo dados sus tres lados.\n    Parámetros:\n- a (float): Longitud del lado 'a'.\n- b (float): Longitud del lado 'b'.\n- c (float): Longitud del lado 'c'.\n    Devuelve:\n- str: Si los lados proporcionados forman un triángulo, devuelve el área calculada con 2 decimales.\nDe lo contrario, devuelve \"-1\"\n    >>> calculate_triangle_area(3,5,4)\n    6",
      "arb": "حساب مساحة مثلث معطى أضلاعه الثلاثة.\n    المعلمات:\n- a (float): طول الضلع 'a'.\n- b (float): طول الضلع 'b'.\n- c (float): طول الضلع 'c'.\n    يعيد:\n- str: إذا كانت الأضلاع المقدمة تشكل مثلثًا، يتم إرجاع المساحة المحسوبة مع منزلتين عشريتين.\nخلاف ذلك، يتم إرجاع \"-1\"\n    >>> calculate_triangle_area(3,5,4)\n    6",
      "sw": "Hesabu eneo la pembetatu ukitumia pande zake tatu.\n    Vigezo:\n- a (float): Urefu wa upande 'a'.\n- b (float): Urefu wa upande 'b'.\n- c (float): Urefu wa upande 'c'.\n    Inarejesha:\n- str: Ikiwa pande zilizotolewa zinaunda pembetatu, rejesha eneo lililohesabiwa na sehemu 2 za desimali.\nVinginevyo, rejesha \"-1\"\n    >>> calculate_triangle_area(3,5,4)\n    6",
      "tr": "Üç kenarı verilen bir üçgenin alanını hesaplayın.\n    Parametreler:\n- a (float): 'a' kenarının uzunluğu.\n- b (float): 'b' kenarının uzunluğu.\n- c (float): 'c' kenarının uzunluğu.\n    Döndürülenler:\n- str: Verilen kenarlar bir üçgen oluşturuyorsa, hesaplanan alanı 2 ondalık basamakla döndürün.\nAksi takdirde, \"-1\" döndürün.\n    >>> calculate_triangle_area(3,5,4)\n    6",
      "vi": "Tính diện tích của một tam giác khi biết ba cạnh của nó.\n    Tham số:\n- a (float): Độ dài của cạnh 'a'.\n- b (float): Độ dài của cạnh 'b'.\n- c (float): Độ dài của cạnh 'c'.\n    Trả về:\n- str: Nếu các cạnh được cung cấp tạo thành một tam giác, trả về diện tích đã tính với 2 chữ số thập phân.\nNếu không, trả về \"-1\"\n    >>> calculate_triangle_area(3,5,4)\n    6"
    },
    "docstring_bertscore": {
      "es": "0.9792892074302543",
      "arb": "0.979282255366918",
      "sw": "0.9909331189969005",
      "tr": "0.9919228941855973",
      "vi": "0.9744090575986081"
    }
  },
  {
    "task_id": "C/3",
    "prompt": {
      "es": "#include <assert.h>\n#include <math.h>\n#include <stdbool.h>\n#include <stdio.h>\n#include <string.h>\n/*\nCalcular el valor de la función para una entrada dada.\n    Parámetros:\n- x (int): Valor de entrada para la función.\n    Retorna:\n- double o string: Si x no está en el dominio definido, retorna \"Not define\".\nDe lo contrario, retorna el valor calculado de la función redondeado a 5 decimales.\n\n    Definiciones de Función:\n- Para 0 <= x < 10: y = cos(x + 3.0)\n- Para 10 <= x < 20: y = (cos(x + 7.5))^2\n- Para 20 <= x < 30: y = (cos(x + 4.0))^4\n    >>> calculate_function_value(40)\n\tNot define\n*/\nconst char* calculate_function_value(int x)",
      "arb": "#include <assert.h>\n#include <math.h>\n#include <stdbool.h>\n#include <stdio.h>\n#include <string.h>\n/*\nاحسب قيمة الدالة لمدخل معين.\n    المعاملات:\n- x (int): قيمة المدخل للدالة.\n    يعيد:\n- double أو string: إذا لم يكن x في النطاق المحدد، يعيد \"Not define\".\nوإلا، يعيد قيمة الدالة المحسوبة مقربة إلى 5 منازل عشرية.\n\n    تعريفات الدوال:\n- لـ 0 <= x < 10: y = cos(x + 3.0)\n- لـ 10 <= x < 20: y = (cos(x + 7.5))^2\n- لـ 20 <= x < 30: y = (cos(x + 4.0))^4\n    >>> calculate_function_value(40)\n\tNot define\n*/\nconst char* calculate_function_value(int x)",
      "sw": "#include <assert.h>\n#include <math.h>\n#include <stdbool.h>\n#include <stdio.h>\n#include <string.h>\n/*\nHesabu thamani ya kazi kwa pembejeo iliyotolewa.\n    Vigezo:\n- x (int): Thamani ya pembejeo kwa kazi.\n    Inarejesha:\n- double au string: Ikiwa x haipo katika kikoa kilichobainishwa, inarejesha \"Not define\".\nVinginevyo, inarejesha thamani ya kazi iliyohesabiwa iliyokatwa hadi sehemu 5 za desimali.\n\n    Ufafanuzi wa Kazi:\n- Kwa 0 <= x < 10: y = cos(x + 3.0)\n- Kwa 10 <= x < 20: y = (cos(x + 7.5))^2\n- Kwa 20 <= x < 30: y = (cos(x + 4.0))^4\n    >>> calculate_function_value(40)\n\tNot define\n*/\nconst char* calculate_function_value(int x)",
      "tr": "#include <assert.h>\n#include <math.h>\n#include <stdbool.h>\n#include <stdio.h>\n#include <string.h>\n/*\nBelirtilen bir giriş için fonksiyonun değerini hesaplayın.\n    Parametreler:\n- x (int): Fonksiyon için giriş değeri.\n    Döndürür:\n- double veya string: Eğer x tanımlı alanda değilse, \"Not define\" döndürür.\nAksi takdirde, hesaplanan fonksiyon değerini 5 ondalık basamağa yuvarlanmış olarak döndürür.\n\n    Fonksiyon Tanımları:\n- 0 <= x < 10 için: y = cos(x + 3.0)\n- 10 <= x < 20 için: y = (cos(x + 7.5))^2\n- 20 <= x < 30 için: y = (cos(x + 4.0))^4\n    >>> calculate_function_value(40)\n\tNot define\n*/\nconst char* calculate_function_value(int x)",
      "vi": "#include <assert.h>\n#include <math.h>\n#include <stdbool.h>\n#include <stdio.h>\n#include <string.h>\n/*\nTính giá trị của hàm cho một đầu vào cho trước.\n    Tham số:\n- x (int): Giá trị đầu vào cho hàm.\n    Trả về:\n- double hoặc string: Nếu x không nằm trong miền xác định, trả về \"Not define\".\nNgược lại, trả về giá trị hàm đã tính toán được làm tròn đến 5 chữ số thập phân.\n\n    Định nghĩa hàm:\n- Đối với 0 <= x < 10: y = cos(x + 3.0)\n- Đối với 10 <= x < 20: y = (cos(x + 7.5))^2\n- Đối với 20 <= x < 30: y = (cos(x + 4.0))^4\n    >>> calculate_function_value(40)\n\tNot define\n*/\nconst char* calculate_function_value(int x)"
    },
    "prompt_bertscore": {
      "es": "0.9617412064177271",
      "arb": "0.985527393177036",
      "sw": "0.9824907319117746",
      "tr": "1",
      "vi": "0.9928536761511267"
    },
    "canonical_solution": "{\n    static char output[50]; // Buffer to hold the output string.\n    \n    if (0 <= x && x < 10) {\n        sprintf(output, \"%.5lf\", cos(x + 3.0));\n    } else if (10 <= x && x < 20) {\n        sprintf(output, \"%.5lf\", pow(cos(x + 7.5), 2.0));\n    } else if (20 <= x && x < 30) {\n        sprintf(output, \"%.5lf\", pow(cos(x + 4.0), 4.0));\n    } else {\n        return \"Not define\";\n    }\n    return output;\n}",
    "instruction": {
      "es": "const char* calculate_function_value(int x)\n{\n    static char output[50]; // Buffer to hold the output string.\n    \n    if (0 <= x && x < 10) {\n        sprintf(output, \"%.5lf\", cos(x + 3.0));\n    } else if (10 <= x && x < 20) {\n        sprintf(output, \"%.5lf\", pow(cos(x + 7.5), 2.0));\n    } else if (20 <= x && x < 30) {\n        sprintf(output, \"%.5lf\", pow(cos(x + 4.0), 4.0));\n    } else {\n        return \"Not define\";\n    }\n    return output;\n}\n\nProporcione una descripción concisa en lenguaje natural (docstring) del código C en español utilizando un máximo de 500 caracteres.",
      "arb": "const char* calculate_function_value(int x)\n{\n    static char output[50]; // Buffer to hold the output string.\n    \n    if (0 <= x && x < 10) {\n        sprintf(output, \"%.5lf\", cos(x + 3.0));\n    } else if (10 <= x && x < 20) {\n        sprintf(output, \"%.5lf\", pow(cos(x + 7.5), 2.0));\n    } else if (20 <= x && x < 30) {\n        sprintf(output, \"%.5lf\", pow(cos(x + 4.0), 4.0));\n    } else {\n        return \"Not define\";\n    }\n    return output;\n}\n\nيرجى تقديم وصف موجز بلغة طبيعية (docstring) للشفرة البرمجية المكتوبة بلغة C باللغة العربية الفصحى، بحيث لا يتجاوز 500 حرف.",
      "sw": "const char* calculate_function_value(int x)\n{\n    static char output[50]; // Buffer to hold the output string.\n    \n    if (0 <= x && x < 10) {\n        sprintf(output, \"%.5lf\", cos(x + 3.0));\n    } else if (10 <= x && x < 20) {\n        sprintf(output, \"%.5lf\", pow(cos(x + 7.5), 2.0));\n    } else if (20 <= x && x < 30) {\n        sprintf(output, \"%.5lf\", pow(cos(x + 4.0), 4.0));\n    } else {\n        return \"Not define\";\n    }\n    return output;\n}\n\nToa maelezo mafupi ya lugha ya asili (docstring) ya msimbo wa C kwa Kiswahili kwa kutumia herufi zisizozidi 500.",
      "tr": "const char* calculate_function_value(int x)\n{\n    static char output[50]; // Buffer to hold the output string.\n    \n    if (0 <= x && x < 10) {\n        sprintf(output, \"%.5lf\", cos(x + 3.0));\n    } else if (10 <= x && x < 20) {\n        sprintf(output, \"%.5lf\", pow(cos(x + 7.5), 2.0));\n    } else if (20 <= x && x < 30) {\n        sprintf(output, \"%.5lf\", pow(cos(x + 4.0), 4.0));\n    } else {\n        return \"Not define\";\n    }\n    return output;\n}\n\nC kodunun işlevini açıklayan kısa bir doğal dil tanımı (docstring) sağlayın. Açıklama, en fazla 500 karakter kullanılarak Türkçe olarak yazılmalıdır.",
      "vi": "const char* calculate_function_value(int x)\n{\n    static char output[50]; // Buffer to hold the output string.\n    \n    if (0 <= x && x < 10) {\n        sprintf(output, \"%.5lf\", cos(x + 3.0));\n    } else if (10 <= x && x < 20) {\n        sprintf(output, \"%.5lf\", pow(cos(x + 7.5), 2.0));\n    } else if (20 <= x && x < 30) {\n        sprintf(output, \"%.5lf\", pow(cos(x + 4.0), 4.0));\n    } else {\n        return \"Not define\";\n    }\n    return output;\n}\n\nCung cấp mô tả ngắn gọn bằng ngôn ngữ tự nhiên (docstring) của mã C bằng tiếng Việt, sử dụng tối đa 500 ký tự."
    },
    "instruction_bertscore": {
      "es": "0.9687963589217052",
      "arb": "0.8727085148353161",
      "sw": "0.9146175389298671",
      "tr": "0.8690074349454929",
      "vi": "0.927643123426992"
    },
    "level": "",
    "test": "int main() {\n    const char* result = calculate_function_value(40);\n    assert(strcmp(result, \"Not define\") == 0);\n    \n    // Additional test cases based on provided function definitions\n    assert(strcmp(calculate_function_value(40), \"Not define\") == 0);\n    assert(strcmp(calculate_function_value(5), \"-0.14550\") == 0);\n    assert(strcmp(calculate_function_value(15), \"0.76266\") == 0);\n    assert(strcmp(calculate_function_value(25), \"0.31314\") == 0);\n    assert(strcmp(calculate_function_value(-1), \"Not define\") == 0);\n    return 0;\n}",
    "entry_point": "calculate_function_value",
    "signature": "const char* calculate_function_value(int x)",
    "docstring": {
      "es": "Calcular el valor de la función para una entrada dada.\n    Parámetros:\n- x (int): Valor de entrada para la función.\n    Retorna:\n- double o string: Si x no está en el dominio definido, retorna \"Not define\".\nDe lo contrario, retorna el valor calculado de la función redondeado a 5 decimales.\n\n    Definiciones de Función:\n- Para 0 <= x < 10: y = cos(x + 3.0)\n- Para 10 <= x < 20: y = (cos(x + 7.5))^2\n- Para 20 <= x < 30: y = (cos(x + 4.0))^4\n    >>> calculate_function_value(40)\n    Not define",
      "arb": "احسب قيمة الدالة لمدخل معين.\n    المعلمات:\n- x (int): قيمة المدخل للدالة.\n    يعيد:\n- double أو string: إذا لم يكن x في النطاق المحدد، يعيد \"غير معرف\".\nوإلا، يعيد قيمة الدالة المحسوبة مقربة إلى 5 منازل عشرية.\n\n    تعريفات الدوال:\n- لـ 0 <= x < 10: y = cos(x + 3.0)\n- لـ 10 <= x < 20: y = (cos(x + 7.5))^2\n- لـ 20 <= x < 30: y = (cos(x + 4.0))^4\n    >>> calculate_function_value(40)\n    Not define",
      "sw": "Hesabu thamani ya kazi kwa pembejeo iliyotolewa.\n    Vigezo:\n- x (int): Thamani ya pembejeo kwa kazi.\n    Inarejesha:\n- double au string: Ikiwa x haipo katika kikoa kilichobainishwa, inarejesha \"Not define\".\nVinginevyo, inarejesha thamani ya kazi iliyohesabiwa iliyopunguzwa hadi sehemu 5 za desimali.\n\n    Ufafanuzi wa Kazi:\n- Kwa 0 <= x < 10: y = cos(x + 3.0)\n- Kwa 10 <= x < 20: y = (cos(x + 7.5))^2\n- Kwa 20 <= x < 30: y = (cos(x + 4.0))^4\n    >>> calculate_function_value(40)\n    Not define",
      "tr": "Fonksiyonun değerini verilen bir girdi için hesaplayın.\n    Parametreler:\n- x (int): Fonksiyon için giriş değeri.\n    Döndürülenler:\n- double veya string: Eğer x tanımlı alanda değilse, \"Not define\" döndürür.\nAksi takdirde, hesaplanan fonksiyon değerini 5 ondalık basamağa yuvarlanmış olarak döndürür.\n\n    Fonksiyon Tanımları:\n- 0 <= x < 10 için: y = cos(x + 3.0)\n- 10 <= x < 20 için: y = (cos(x + 7.5))^2\n- 20 <= x < 30 için: y = (cos(x + 4.0))^4\n    >>> calculate_function_value(40)\n    Not define",
      "vi": "Tính giá trị của hàm cho một đầu vào nhất định.\n    Tham số:\n- x (int): Giá trị đầu vào cho hàm.\n    Trả về:\n- double hoặc string: Nếu x không nằm trong miền xác định, trả về \"Not define\".\nNgược lại, trả về giá trị hàm đã tính toán được làm tròn đến 5 chữ số thập phân.\n\n    Định nghĩa hàm:\n- Đối với 0 <= x < 10: y = cos(x + 3.0)\n- Đối với 10 <= x < 20: y = (cos(x + 7.5))^2\n- Đối với 20 <= x < 30: y = (cos(x + 4.0))^4\n    >>> calculate_function_value(40)\n    Not define"
    },
    "docstring_bertscore": {
      "es": "0.9764950738602365",
      "arb": "0.9793271458330319",
      "sw": "0.9854654204981531",
      "tr": "0.9924699222549674",
      "vi": "0.9905447966019773"
    }
  },
  {
    "task_id": "C/4",
    "prompt": {
      "es": "#include <assert.h>\n#include <stdio.h>\n/*\nEncuentra el máximo y mínimo de tres enteros distintos.\nParámetros:\na (int): El primer entero.\nb (int): El segundo entero.\nc (int): El tercer entero.\n\nDevuelve:\nTuple[int, int]: Una tupla no es un concepto en C; en su lugar, devolveremos por referencia.\n\n>>> Llamada de ejemplo: \nint max, min;\nfind_max_min(1,2,3, &max, &min);\nassert(max == 3 && min == 1);\n*/\nvoid find_max_min(int a, int b, int c, int *max, int *min)",
      "arb": "#include <assert.h>\n#include <stdio.h>\n/*\nالعثور على الحد الأقصى والحد الأدنى من ثلاثة أعداد صحيحة مميزة.\nالمعلمات:\na (int): العدد الصحيح الأول.\nb (int): العدد الصحيح الثاني.\nc (int): العدد الصحيح الثالث.\n\nالإرجاع:\nTuple[int, int]: الزوج ليس مفهومًا في C؛ بدلاً من ذلك، سنقوم بالإرجاع عن طريق المرجع.\n\n>>> مثال على الاستدعاء: \nint max, min;\nfind_max_min(1,2,3, &max, &min);\nassert(max == 3 && min == 1);\n*/\nvoid find_max_min(int a, int b, int c, int *max, int *min)",
      "sw": "#include <assert.h>\n#include <stdio.h>\n/*\nPata ya juu na ya chini ya nambari tatu tofauti za mzima.\nVigezo:\na (int): Nambari ya kwanza ya mzima.\nb (int): Nambari ya pili ya mzima.\nc (int): Nambari ya tatu ya mzima.\n\nInarejesha:\nTuple[int, int]: Tuple si dhana katika C; badala yake, tutarejesha kwa marejeleo.\n\n>>> Mfano wa kuita: \nint max, min;\nfind_max_min(1,2,3, &max, &min);\nassert(max == 3 && min == 1);\n*/\nvoid find_max_min(int a, int b, int c, int *max, int *min)",
      "tr": "#include <assert.h>\n#include <stdio.h>\n/*\nÜç farklı tam sayının maksimum ve minimumunu bulun.\nParametreler:\na (int): Birinci tam sayı.\nb (int): İkinci tam sayı.\nc (int): Üçüncü tam sayı.\n\nDöndürür:\nTuple[int, int]: C'de bir tuple kavramı yoktur; bunun yerine referansla döndüreceğiz.\n\n>>> Örnek çağrı: \nint max, min;\nfind_max_min(1,2,3, &max, &min);\nassert(max == 3 && min == 1);\n*/\nvoid find_max_min(int a, int b, int c, int *max, int *min)",
      "vi": "#include <assert.h>\n#include <stdio.h>\n/*\nTìm giá trị lớn nhất và nhỏ nhất của ba số nguyên khác nhau.\nTham số:\na (int): Số nguyên thứ nhất.\nb (int): Số nguyên thứ hai.\nc (int): Số nguyên thứ ba.\n\nTrả về:\nTuple[int, int]: Một tuple không phải là khái niệm trong C; thay vào đó, chúng ta sẽ trả về bằng tham chiếu.\n\n>>> Ví dụ gọi:\nint max, min;\nfind_max_min(1,2,3, &max, &min);\nassert(max == 3 && min == 1);\n*/\nvoid find_max_min(int a, int b, int c, int *max, int *min)"
    },
    "prompt_bertscore": {
      "es": "0.999999801369619",
      "arb": "0.9946715413983581",
      "sw": "0.9929380940630667",
      "tr": "0.9790474742565348",
      "vi": "0.9834026439911058"
    },
    "canonical_solution": "{\n    if (a > b) {\n        if (a > c) {\n            *max = a;\n            *min = (b < c) ? b : c;\n        } else {\n            *max = c;\n            *min = b;\n        }\n    } else {\n        if (b > c) {\n            *max = b;\n            *min = (a < c) ? a : c;\n        } else {\n            *max = c;\n            *min = a;\n        }\n    }\n}",
    "instruction": {
      "es": "void find_max_min(int a, int b, int c, int *max, int *min)\n{\n    if (a > b) {\n        if (a > c) {\n            *max = a;\n            *min = (b < c) ? b : c;\n        } else {\n            *max = c;\n            *min = b;\n        }\n    } else {\n        if (b > c) {\n            *max = b;\n            *min = (a < c) ? a : c;\n        } else {\n            *max = c;\n            *min = a;\n        }\n    }\n}\n\nProporcione una descripción concisa en lenguaje natural (docstring) del código C en español utilizando como máximo 500 caracteres.",
      "arb": "void find_max_min(int a, int b, int c, int *max, int *min)\n{\n    if (a > b) {\n        if (a > c) {\n            *max = a;\n            *min = (b < c) ? b : c;\n        } else {\n            *max = c;\n            *min = b;\n        }\n    } else {\n        if (b > c) {\n            *max = b;\n            *min = (a < c) ? a : c;\n        } else {\n            *max = c;\n            *min = a;\n        }\n    }\n}\n\nيرجى تقديم وصف موجز بلغة طبيعية (docstring) للكود المكتوب بلغة C باللغة العربية الفصحى، بحيث لا يتجاوز 500 حرف.",
      "sw": "void find_max_min(int a, int b, int c, int *max, int *min)\n{\n    if (a > b) {\n        if (a > c) {\n            *max = a;\n            *min = (b < c) ? b : c;\n        } else {\n            *max = c;\n            *min = b;\n        }\n    } else {\n        if (b > c) {\n            *max = b;\n            *min = (a < c) ? a : c;\n        } else {\n            *max = c;\n            *min = a;\n        }\n    }\n}\n\nToa maelezo mafupi ya lugha ya asili (docstring) ya msimbo wa C kwa Kiswahili kwa kutumia herufi zisizozidi 500.",
      "tr": "void find_max_min(int a, int b, int c, int *max, int *min)\n{\n    if (a > b) {\n        if (a > c) {\n            *max = a;\n            *min = (b < c) ? b : c;\n        } else {\n            *max = c;\n            *min = b;\n        }\n    } else {\n        if (b > c) {\n            *max = b;\n            *min = (a < c) ? a : c;\n        } else {\n            *max = c;\n            *min = a;\n        }\n    }\n}\n\nC kodunun işlevini açıklayan kısa bir doğal dil açıklaması (docstring) sağlayın. Açıklama, en fazla 500 karakter kullanılarak Türkçe olarak yazılmalıdır.",
      "vi": "void find_max_min(int a, int b, int c, int *max, int *min)\n{\n    if (a > b) {\n        if (a > c) {\n            *max = a;\n            *min = (b < c) ? b : c;\n        } else {\n            *max = c;\n            *min = b;\n        }\n    } else {\n        if (b > c) {\n            *max = b;\n            *min = (a < c) ? a : c;\n        } else {\n            *max = c;\n            *min = a;\n        }\n    }\n}\n\nCung cấp mô tả ngắn gọn bằng ngôn ngữ tự nhiên (docstring) cho mã C bằng tiếng Việt, sử dụng tối đa 500 ký tự."
    },
    "instruction_bertscore": {
      "es": "0.9687963589217052",
      "arb": "0.8727085148353161",
      "sw": "0.9146175389298671",
      "tr": "0.8690074349454929",
      "vi": "0.918266379029478"
    },
    "level": "",
    "test": "int main() {\n    int max, min;\n\n    find_max_min(1, 2, 3, &max, &min);\n    assert(max == 3 && min == 1);\n\n    // Additional tests\n    find_max_min(5, 3, 4, &max, &min);\n    assert(max == 5 && min == 3);\n\n    find_max_min(10, -2, 7, &max, &min);\n    assert(max == 10 && min == -2);\n\n    find_max_min(-1, -3, -2, &max, &min);\n    assert(max == -1 && min == -3);\n\n    return 0;\n}",
    "entry_point": "find_max_min",
    "signature": "void find_max_min(int a, int b, int c, int *max, int *min)",
    "docstring": {
      "es": "Encuentra el máximo y el mínimo de tres enteros distintos.\nParámetros:\na (int): El primer entero.\nb (int): El segundo entero.\nc (int): El tercer entero.\n\nDevuelve:\nTuple[int, int]: Una tupla no es un concepto en C; en su lugar, devolveremos por referencia.\n\n>>> Llamada de ejemplo: \nint max, min;\nfind_max_min(1,2,3, &max, &min);\nassert(max == 3 && min == 1);",
      "arb": "إيجاد القيمة القصوى والدنيا لثلاثة أعداد صحيحة متميزة.\nالمعلمات:\na (int): العدد الصحيح الأول.\nb (int): العدد الصحيح الثاني.\nc (int): العدد الصحيح الثالث.\n\nالقيم المعادة:\nTuple[int, int]: الزوج ليس مفهومًا في C؛ بدلاً من ذلك، سنعيد القيم بالإشارة.\n\n>>> مثال على الاستدعاء:\nint max, min;\nfind_max_min(1,2,3, &max, &min);\nassert(max == 3 && min == 1);",
      "sw": "Pata kubwa na ndogo kati ya nambari tatu tofauti za mzima.\n\nVipengele:\na (int): Nambari ya kwanza ya mzima.\nb (int): Nambari ya pili ya mzima.\nc (int): Nambari ya tatu ya mzima.\n\nInarejesha:\nTuple[int, int]: Tuple si dhana katika C; badala yake, tutarejesha kwa marejeleo.\n\n>>> Mfano wa kuita:\nint max, min;\nfind_max_min(1,2,3, &max, &min);\nassert(max == 3 && min == 1);",
      "tr": "Üç farklı tam sayının maksimum ve minimumunu bulun.  \nParametreler:  \na (int): Birinci tam sayı.  \nb (int): İkinci tam sayı.  \nc (int): Üçüncü tam sayı.  \n\nDöndürülenler:  \nTuple[int, int]: C'de bir kavram olarak tuple yoktur; bunun yerine referansla döneceğiz.  \n\n>>> Örnek çağrı:  \nint max, min;  \nfind_max_min(1,2,3, &max, &min);  \nassert(max == 3 && min == 1);  ",
      "vi": "Tìm giá trị lớn nhất và nhỏ nhất của ba số nguyên khác nhau.  \nTham số:  \na (int): Số nguyên thứ nhất.  \nb (int): Số nguyên thứ hai.  \nc (int): Số nguyên thứ ba.  \n\nTrả về:  \nTuple[int, int]: Một tuple không phải là khái niệm trong C; thay vào đó, chúng ta sẽ trả về bằng tham chiếu.  \n\n>>> Ví dụ gọi:  \nint max, min;  \nfind_max_min(1,2,3, &max, &min);  \nassert(max == 3 && min == 1);  "
    },
    "docstring_bertscore": {
      "es": "1",
      "arb": "0.9637843185170519",
      "sw": "0.9675094326829803",
      "tr": "0.9722207466907468",
      "vi": "0.9877168958671836"
    }
  },
  {
    "task_id": "C/5",
    "prompt": {
      "es": "#include <assert.h>\n#include <math.h>\n#include <stdbool.h>\n#include <stdio.h>\n#include <string.h>\n/*\nCalcular la distancia entre dos puntos A (xa, ya) y B (xb, yb).\n    Parámetros:\n- xa (double): coordenada x del punto A.\n- ya (double): coordenada y del punto A.\n- xb (double): coordenada x del punto B.\n- yb (double): coordenada y del punto B.\n    \n    Devuelve:\n    double: La distancia entre los puntos A y B.\n    >>> calculate_distance(0,0,3,4)\n    5\n*/\ndouble calculate_distance(double xa, double ya, double xb, double yb)",
      "arb": "#include <assert.h>\n#include <math.h>\n#include <stdbool.h>\n#include <stdio.h>\n#include <string.h>\n/*\nاحسب المسافة بين نقطتين A (xa, ya) و B (xb, yb).\n    المعلمات:\n- xa (double): الإحداثي السيني للنقطة A.\n- ya (double): الإحداثي الصادي للنقطة A.\n- xb (double): الإحداثي السيني للنقطة B.\n- yb (double): الإحداثي الصادي للنقطة B.\n    \n    يعيد:\n    double: المسافة بين النقطتين A و B.\n    >>> calculate_distance(0,0,3,4)\n    5\n*/\ndouble calculate_distance(double xa, double ya, double xb, double yb)",
      "sw": "#include <assert.h>\n#include <math.h>\n#include <stdbool.h>\n#include <stdio.h>\n#include <string.h>\n/*\nHesabu umbali kati ya pointi mbili A (xa, ya) na B (xb, yb).\n    Vigezo:\n- xa (double): x-kiwianishi cha pointi A.\n- ya (double): y-kiwianishi cha pointi A.\n- xb (double): x-kiwianishi cha pointi B.\n- yb (double): y-kiwianishi cha pointi B.\n    \n    Inarejesha:\n    double: Umbali kati ya pointi A na B.\n    >>> calculate_distance(0,0,3,4)\n    5\n*/\ndouble calculate_distance(double xa, double ya, double xb, double yb)",
      "tr": "#include <assert.h>\n#include <math.h>\n#include <stdbool.h>\n#include <stdio.h>\n#include <string.h>\n/*\nİki nokta A (xa, ya) ve B (xb, yb) arasındaki mesafeyi hesapla.\n    Parametreler:\n- xa (double): A noktasının x-koordinatı.\n- ya (double): A noktasının y-koordinatı.\n- xb (double): B noktasının x-koordinatı.\n- yb (double): B noktasının y-koordinatı.\n    \n    Döndürür:\n    double: A ve B noktaları arasındaki mesafe.\n    >>> calculate_distance(0,0,3,4)\n    5\n*/\ndouble calculate_distance(double xa, double ya, double xb, double yb)",
      "vi": "#include <assert.h>\n#include <math.h>\n#include <stdbool.h>\n#include <stdio.h>\n#include <string.h>\n/*\nTính khoảng cách giữa hai điểm A (xa, ya) và B (xb, yb).\n    Tham số:\n- xa (double): tọa độ x của điểm A.\n- ya (double): tọa độ y của điểm A.\n- xb (double): tọa độ x của điểm B.\n- yb (double): tọa độ y của điểm B.\n    \n    Trả về:\n    double: Khoảng cách giữa điểm A và B.\n    >>> calculate_distance(0,0,3,4)\n    5\n*/\ndouble calculate_distance(double xa, double ya, double xb, double yb)"
    },
    "prompt_bertscore": {
      "es": "1",
      "arb": "0.9776507054170975",
      "sw": "0.9970292840212422",
      "tr": "1",
      "vi": "0.996288392699982"
    },
    "canonical_solution": "{\n    return sqrt((xa - xb) * (xa - xb) + (ya - yb) * (ya - yb));\n}",
    "instruction": {
      "es": "double calculate_distance(double xa, double ya, double xb, double yb)\n{\n    return sqrt((xa - xb) * (xa - xb) + (ya - yb) * (ya - yb));\n}\n\nProporcione una descripción concisa en lenguaje natural (docstring) del código C en español utilizando como máximo 500 caracteres.",
      "arb": "double calculate_distance(double xa, double ya, double xb, double yb)\n{\n    return sqrt((xa - xb) * (xa - xb) + (ya - yb) * (ya - yb));\n}\n\nيرجى تقديم وصف موجز بلغة طبيعية (docstring) للكود المكتوب بلغة C باللغة العربية الفصحى، بحيث لا يتجاوز 500 حرف.",
      "sw": "double calculate_distance(double xa, double ya, double xb, double yb)\n{\n    return sqrt((xa - xb) * (xa - xb) + (ya - yb) * (ya - yb));\n}\n\nToa maelezo mafupi ya lugha asilia (docstring) ya msimbo wa C kwa Kiswahili kwa kutumia herufi zisizozidi 500.",
      "tr": "double calculate_distance(double xa, double ya, double xb, double yb)\n{\n    return sqrt((xa - xb) * (xa - xb) + (ya - yb) * (ya - yb));\n}\n\nC kodunun işlevini açıklayan kısa bir doğal dil açıklaması (docstring) sağlayın. Açıklama, Türkçe dilinde ve en fazla 500 karakter olmalıdır.",
      "vi": "double calculate_distance(double xa, double ya, double xb, double yb)\n{\n    return sqrt((xa - xb) * (xa - xb) + (ya - yb) * (ya - yb));\n}\n\nCung cấp mô tả ngắn gọn bằng ngôn ngữ tự nhiên (docstring) của mã C bằng tiếng Việt, sử dụng tối đa 500 ký tự."
    },
    "instruction_bertscore": {
      "es": "0.9687963589217052",
      "arb": "0.8800316197233103",
      "sw": "0.9423429634058599",
      "tr": "0.8525258804487421",
      "vi": "0.927643123426992"
    },
    "level": "",
    "test": "int main() {\n    assert(fabs(calculate_distance(0,0,3,4) - 5) < 1e-6);\n    assert(fabs(calculate_distance(0,0,0,0) - 0) < 1e-6);\n    assert(fabs(calculate_distance(-1,-1,2,2) - 4.242640687) < 1e-6);\n    assert(fabs(calculate_distance(1.5,3.9,4.2,-1.1) - 5.68243) < 1e-6);\n    // printf(\"All test cases passed!\\n\");\n    return 0;\n}",
    "entry_point": "calculate_distance",
    "signature": "double calculate_distance(double xa, double ya, double xb, double yb)",
    "docstring": {
      "es": "Calcular la distancia entre dos puntos A (xa, ya) y B (xb, yb).\n    Parámetros:\n- xa (double): coordenada x del punto A.\n- ya (double): coordenada y del punto A.\n- xb (double): coordenada x del punto B.\n- yb (double): coordenada y del punto B.\n    \n    Devuelve:\n    double: La distancia entre los puntos A y B.\n    >>> calculate_distance(0,0,3,4)\n    5",
      "arb": "احسب المسافة بين نقطتين A (xa, ya) و B (xb, yb).\n    المعلمات:\n- xa (double): الإحداثي السيني للنقطة A.\n- ya (double): الإحداثي الصادي للنقطة A.\n- xb (double): الإحداثي السيني للنقطة B.\n- yb (double): الإحداثي الصادي للنقطة B.\n    \n    يعيد:\n    double: المسافة بين النقطتين A و B.\n    >>> calculate_distance(0,0,3,4)\n    5",
      "sw": "Hesabu umbali kati ya pointi mbili A (xa, ya) na B (xb, yb). \n    Vigezo:\n- xa (double): x-kiwianishi cha pointi A.\n- ya (double): y-kiwianishi cha pointi A.\n- xb (double): x-kiwianishi cha pointi B.\n- yb (double): y-kiwianishi cha pointi B.\n    \n    Inarejesha:\n    double: Umbali kati ya pointi A na B.\n    >>> calculate_distance(0,0,3,4)\n    5",
      "tr": "Calculate the distance between two points A (xa, ya) and B (xb, yb).\n    Parametreler:\n- xa (double): A noktasının x-koordinatı.\n- ya (double): A noktasının y-koordinatı.\n- xb (double): B noktasının x-koordinatı.\n- yb (double): B noktasının y-koordinatı.\n    \n    Döndürülenler:\n    double: A ve B noktaları arasındaki mesafe.\n    >>> calculate_distance(0,0,3,4)\n    5",
      "vi": "Tính khoảng cách giữa hai điểm A (xa, ya) và B (xb, yb).\n    Tham số:\n- xa (double): tọa độ x của điểm A.\n- ya (double): tọa độ y của điểm A.\n- xb (double): tọa độ x của điểm B.\n- yb (double): tọa độ y của điểm B.\n    \n    Trả về:\n    double: Khoảng cách giữa điểm A và B.\n    >>> calculate_distance(0,0,3,4)\n    5"
    },
    "docstring_bertscore": {
      "es": "0.963688181412631",
      "arb": "0.9711094097088565",
      "sw": "1",
      "tr": "1",
      "vi": "0.998719032672706"
    }
  },
  {
    "task_id": "C/6",
    "prompt": {
      "es": "#include <assert.h>\n#include <math.h>\n#include <stdbool.h>\n#include <stdio.h>\n#include <string.h>\n/*\nEncuentra el factorial de N y toma el módulo 10007 del resultado.\n​    Parámetros:\n- N (int): Un entero que representa el valor de entrada (N <= 10000).\n​    Retorna:\n​    int: El resultado después de tomar el módulo 10007 de la salida.\n    >>> process_request(1)\n    1\n*/\nint process_request(int n)",
      "arb": "#include <assert.h>\n#include <math.h>\n#include <stdbool.h>\n#include <stdio.h>\n#include <string.h>\n/*\nابحث عن مضروب N وخذ باقي القسمة 10007 للنتيجة.\n​    المعلمات:\n- N (int): عدد صحيح يمثل قيمة الإدخال (N <= 10000).\n​    يعيد:\n​    int: النتيجة بعد أخذ باقي القسمة 10007 من المخرجات.\n    >>> process_request(1)\n    1\n*/\nint process_request(int n)",
      "sw": "#include <assert.h>\n#include <math.h>\n#include <stdbool.h>\n#include <stdio.h>\n#include <string.h>\n/*\nTafuta faktoria ya N na chukua modulo 10007 ya matokeo.\n​    Vigezo:\n- N (int): Nambari kamili inayowakilisha thamani ya ingizo (N <= 10000).\n​    Inarejesha:\n​    int: Matokeo baada ya kuchukua modulo 10007 ya pato.\n    >>> process_request(1)\n    1\n*/\nint process_request(int n)",
      "tr": "#include <assert.h>\n#include <math.h>\n#include <stdbool.h>\n#include <stdio.h>\n#include <string.h>\n/*\nN'in faktöriyelini bulun ve sonucun 10007 ile modunu alın.\n​    Parametreler:\n- N (int): Girdi değerini temsil eden bir tamsayı (N <= 10000).\n​    Döndürür:\n​    int: Çıktının 10007 ile modunu aldıktan sonra elde edilen sonuç.\n    >>> process_request(1)\n    1\n*/\nint process_request(int n)",
      "vi": "#include <assert.h>\n#include <math.h>\n#include <stdbool.h>\n#include <stdio.h>\n#include <string.h>\n/*\nTìm giai thừa của N và lấy modulo 10007 của kết quả.\n​    Tham số:\n- N (int): Một số nguyên đại diện cho giá trị đầu vào (N <= 10000).\n​    Trả về:\n​    int: Kết quả sau khi lấy modulo 10007 của đầu ra.\n    >>> process_request(1)\n    1\n*/\nint process_request(int n)"
    },
    "prompt_bertscore": {
      "es": "0.9834018494695816",
      "arb": "0.9379810402383337",
      "sw": "0.9686803587791809",
      "tr": "0.9587160657145657",
      "vi": "0.9686803587791809"
    },
    "canonical_solution": "{\n    int a[10010];\n    a[0] = 1;\n    a[1] = 1;\n    for(register int i = 2; i <= 10000; i++) {\n        a[i] = (a[i-1] * i) % 10007;\n    }\n    return a[n];\n}",
    "instruction": {
      "es": "int process_request(int n)\n{\n    int a[10010];\n    a[0] = 1;\n    a[1] = 1;\n    for(register int i = 2; i <= 10000; i++) {\n        a[i] = (a[i-1] * i) % 10007;\n    }\n    return a[n];\n}\n\nProporcione una descripción concisa en lenguaje natural (docstring) del código C en español utilizando un máximo de 500 caracteres.",
      "arb": "int process_request(int n)\n{\n    int a[10010];\n    a[0] = 1;\n    a[1] = 1;\n    for(register int i = 2; i <= 10000; i++) {\n        a[i] = (a[i-1] * i) % 10007;\n    }\n    return a[n];\n}\n\nيرجى تقديم وصف موجز بلغة طبيعية (docstring) للكود المكتوب بلغة C باللغة العربية الفصحى، بحيث لا يتجاوز 500 حرف.",
      "sw": "int process_request(int n)\n{\n    int a[10010];\n    a[0] = 1;\n    a[1] = 1;\n    for(register int i = 2; i <= 10000; i++) {\n        a[i] = (a[i-1] * i) % 10007;\n    }\n    return a[n];\n}\n\nToa maelezo mafupi ya lugha ya asili (docstring) ya msimbo wa C kwa Kiswahili kwa kutumia herufi zisizozidi 500.",
      "tr": "int process_request(int n)\n{\n    int a[10010];\n    a[0] = 1;\n    a[1] = 1;\n    for(register int i = 2; i <= 10000; i++) {\n        a[i] = (a[i-1] * i) % 10007;\n    }\n    return a[n];\n}\n\nC kodunun işlevini açıklayan en fazla 500 karakterlik kısa bir doğal dil tanımı (docstring) sağlayın.",
      "vi": "int process_request(int n)\n{\n    int a[10010];\n    a[0] = 1;\n    a[1] = 1;\n    for(register int i = 2; i <= 10000; i++) {\n        a[i] = (a[i-1] * i) % 10007;\n    }\n    return a[n];\n}\n\nCung cấp mô tả ngắn gọn bằng ngôn ngữ tự nhiên (docstring) của mã C bằng tiếng Việt, sử dụng tối đa 500 ký tự."
    },
    "instruction_bertscore": {
      "es": "0.9687963589217052",
      "arb": "0.8609607195793886",
      "sw": "0.9146175389298671",
      "tr": "0.8637917984002789",
      "vi": "0.927643123426992"
    },
    "level": "",
    "test": "int main()\n{\n    assert(process_request(0) == 1); // Added test for boundary condition\n    assert(process_request(1) == 1);\n    assert(process_request(2) == 2);\n    assert(process_request(3) == 6);\n    assert(process_request(4) == 24);\n    assert(process_request(10) == 6266); // 10! % 10007 = 3628800 % 10007 = 362\n    assert(process_request(10000) == 6991); // Added a test for upper boundary condition\n    // printf(\"All tests passed.\\n\");\n    return 0;\n}",
    "entry_point": "process_request",
    "signature": "int process_request(int n)",
    "docstring": {
      "es": "Encontrar el factorial de N y tomar el módulo 10007 del resultado.\n    Parámetros:\n- N (int): Un entero que representa el valor de entrada (N <= 10000).\n    Devuelve:\n    int: El resultado después de tomar el módulo 10007 de la salida.\n    >>> process_request(1)\n    1",
      "arb": "ابحث عن مضروب N وخذ باقي القسمة 10007 من النتيجة.\n    المعلمات:\n- N (int): عدد صحيح يمثل قيمة الإدخال (N <= 10000).\n    يعيد:\n    int: النتيجة بعد أخذ باقي القسمة 10007 من الناتج.\n    >>> process_request(1)\n    1",
      "sw": "Tafuta factorial ya N na chukua modulo 10007 ya matokeo.\n    Vigezo:\n- N (int): Nambari kamili inayowakilisha thamani ya ingizo (N <= 10000).\n    Inarejesha:\n    int: Matokeo baada ya kuchukua modulo 10007 ya pato.\n    >>> process_request(1)\n    1",
      "tr": "Find the factorial of N and take the modulo 10007 of the result.\n    Parametreler:\n- N (int): Girdi değerini temsil eden bir tamsayı (N <= 10000).\n    Döndürür:\n    int: Çıktının 10007 ile modülüsünün alınmasından sonra elde edilen sonuç.\n    >>> process_request(1)\n    1",
      "vi": "Tìm giai thừa của N và lấy modulo 10007 của kết quả.\n    Tham số:\n- N (int): Một số nguyên đại diện cho giá trị đầu vào (N <= 10000).\n    Trả về:\n    int: Kết quả sau khi lấy modulo 10007 của đầu ra.\n    >>> process_request(1)\n    1"
    },
    "docstring_bertscore": {
      "es": "1",
      "arb": "0.9187099206703289",
      "sw": "1",
      "tr": "0.9695730037115516",
      "vi": "0.9845400015529115"
    }
  },
  {
    "task_id": "C/7",
    "prompt": {
      "es": "#include <assert.h>\n#include <math.h>\n#include <stdbool.h>\n#include <stdio.h>\n#include <string.h>\n/*\nCalcular el área de un triángulo dado su base y altura.\n    Parámetros:\n- base (int): La longitud de la base del triángulo.\n- height (int): La altura del triángulo.\n    Retorna:\n    float: El área calculada del triángulo, redondeada a un decimal.\n\t>>> calculate_triangle_area(1,2)\n\t1.0\n*/\nfloat calculate_triangle_area(int base, int height)",
      "arb": "#include <assert.h>\n#include <math.h>\n#include <stdbool.h>\n#include <stdio.h>\n#include <string.h>\n/*\nحساب مساحة المثلث المعطى قاعدته وارتفاعه.\n    المعلمات:\n- base (int): طول قاعدة المثلث.\n- height (int): ارتفاع المثلث.\n    يعيد:\n    float: المساحة المحسوبة للمثلث، مقربة إلى منزلة عشرية واحدة.\n\t>>> calculate_triangle_area(1,2)\n\t1.0\n*/\nfloat calculate_triangle_area(int base, int height)",
      "sw": "#include <assert.h>\n#include <math.h>\n#include <stdbool.h>\n#include <stdio.h>\n#include <string.h>\n/*\nHesabu eneo la pembetatu ukizingatia msingi wake na urefu.\n​    Vigezo:\n- base (int): Urefu wa msingi wa pembetatu.\n- height (int): Urefu wa pembetatu.\n​    Inarejesha:\n​    float: Eneo lililohesabiwa la pembetatu, limezungushwa hadi sehemu moja ya desimali.\n\t>>> calculate_triangle_area(1,2)\n\t1.0\n*/\nfloat calculate_triangle_area(int base, int height)",
      "tr": "#include <assert.h>\n#include <math.h>\n#include <stdbool.h>\n#include <stdio.h>\n#include <string.h>\n/*\nBir üçgenin tabanı ve yüksekliği verildiğinde alanını hesaplayın.\n​    Parametreler:\n- base (int): Üçgenin taban uzunluğu.\n- height (int): Üçgenin yüksekliği.\n​    Döndürür:\n​    float: Üçgenin hesaplanan alanı, bir ondalık basamağa yuvarlanmış.\n\t>>> calculate_triangle_area(1,2)\n\t1.0\n*/\nfloat calculate_triangle_area(int base, int height)",
      "vi": "#include <assert.h>\n#include <math.h>\n#include <stdbool.h>\n#include <stdio.h>\n#include <string.h>\n/*\nTính diện tích của một tam giác khi biết đáy và chiều cao của nó.\n​    Tham số:\n- base (int): Chiều dài đáy của tam giác.\n- height (int): Chiều cao của tam giác.\n​    Trả về:\n​    float: Diện tích đã tính của tam giác, làm tròn đến một chữ số thập phân.\n\t>>> calculate_triangle_area(1,2)\n\t1.0\n*/\nfloat calculate_triangle_area(int base, int height)"
    },
    "prompt_bertscore": {
      "es": "0.9758902443499853",
      "arb": "0.9780992128174743",
      "sw": "0.9664050477644263",
      "tr": "0.9822062932061326",
      "vi": "0.9795347145812134"
    },
    "canonical_solution": "{\n    return base * height / 2.0; // The area formula is correct and casted to float\n}",
    "instruction": {
      "es": "float calculate_triangle_area(int base, int height)\n{\n    return base * height / 2.0; // The area formula is correct and casted to float\n}\n\nProporcione una descripción concisa en lenguaje natural (docstring) del código C en español utilizando como máximo 500 caracteres.",
      "arb": "float calculate_triangle_area(int base, int height)\n{\n    return base * height / 2.0; // The area formula is correct and casted to float\n}\n\nيرجى تقديم وصف موجز بلغة طبيعية (docstring) للكود المكتوب بلغة C باللغة العربية الفصحى، بحيث لا يتجاوز 500 حرف.",
      "sw": "float calculate_triangle_area(int base, int height)\n{\n    return base * height / 2.0; // The area formula is correct and casted to float\n}\n\nToa maelezo mafupi ya lugha ya asili (docstring) ya msimbo wa C kwa Kiswahili kwa kutumia herufi zisizozidi 500.",
      "tr": "float calculate_triangle_area(int base, int height)\n{\n    return base * height / 2.0; // The area formula is correct and casted to float\n}\n\nC kodunun işlevini açıklayan kısa bir doğal dil açıklaması (docstring) sağlayın. Açıklama, en fazla 500 karakter kullanılarak Türkçe olarak yazılmalıdır.",
      "vi": "float calculate_triangle_area(int base, int height)\n{\n    return base * height / 2.0; // The area formula is correct and casted to float\n}\n\nCung cấp mô tả ngắn gọn bằng ngôn ngữ tự nhiên (docstring) của mã C bằng tiếng Việt, sử dụng tối đa 500 ký tự."
    },
    "instruction_bertscore": {
      "es": "0.9687963589217052",
      "arb": "0.8727085148353161",
      "sw": "0.9146175389298671",
      "tr": "0.8827657669182556",
      "vi": "0.927643123426992"
    },
    "level": "",
    "test": "int main()\n{\n    // Adding more comprehensive test cases and correcting the expected values\n    assert(fabs(calculate_triangle_area(1, 2) - 1.0) < 1e-6); // Should assert true with close approximate comparison\n    assert(fabs(calculate_triangle_area(3, 4) - 6.0) < 1e-6); // Should assert true with close approximate comparison\n    assert(fabs(calculate_triangle_area(5, 8) - 20.0) < 1e-6); // Additional test case\n    assert(fabs(calculate_triangle_area(7, 3) - 10.5) < 1e-6); // Additional test case\n    assert(fabs(calculate_triangle_area(10, 10) - 50.0) < 1e-6); // Additional test case\n\n    // printf(\"All tests passed.\\n\");\n    return 0;\n}",
    "entry_point": "calculate_triangle_area",
    "signature": "float calculate_triangle_area(int base, int height)",
    "docstring": {
      "es": "Calcular el área de un triángulo dada su base y altura.\n    Parámetros:\n- base (int): La longitud de la base del triángulo.\n- height (int): La altura del triángulo.\n    Devuelve:\n    float: El área calculada del triángulo, redondeada a un decimal.\n    >>> calculate_triangle_area(1,2)\n    1.0",
      "arb": "حساب مساحة المثلث بناءً على قاعدته وارتفاعه.\n    المعلمات:\n- base (int): طول قاعدة المثلث.\n- height (int): ارتفاع المثلث.\n    يعيد:\n    float: المساحة المحسوبة للمثلث، مقربة إلى منزلة عشرية واحدة.\n    >>> calculate_triangle_area(1,2)\n    1.0",
      "sw": "Hesabu eneo la pembetatu ukizingatia msingi wake na urefu.\n    Vigezo:\n- base (int): Urefu wa msingi wa pembetatu.\n- height (int): Urefu wa pembetatu.\n    Inarejesha:\n    float: Eneo lililohesabiwa la pembetatu, limezungushwa hadi sehemu moja ya desimali.\n    >>> calculate_triangle_area(1,2)\n    1.0",
      "tr": "Üçgenin tabanı ve yüksekliği verildiğinde alanını hesaplayın.\n    Parametreler:\n- base (int): Üçgenin taban uzunluğu.\n- height (int): Üçgenin yüksekliği.\n    Döndürür:\n    float: Üçgenin hesaplanan alanı, bir ondalık basamağa yuvarlanmış olarak.\n    >>> calculate_triangle_area(1,2)\n    1.0",
      "vi": "Tính diện tích của một tam giác dựa trên đáy và chiều cao của nó.\n    Tham số:\n- base (int): Chiều dài đáy của tam giác.\n- height (int): Chiều cao của tam giác.\n    Trả về:\n    float: Diện tích được tính của tam giác, làm tròn đến một chữ số thập phân.\n    >>> calculate_triangle_area(1,2)\n    1.0"
    },
    "docstring_bertscore": {
      "es": "0.9881097867608706",
      "arb": "0.9763528545074155",
      "sw": "0.9881097867608706",
      "tr": "0.999999801369619",
      "vi": "0.9766956905450818"
    }
  },
  {
    "task_id": "C/8",
    "prompt": {
      "es": "#include <assert.h>\n#include <stdio.h>\n/*\nCalcular la distancia de Hamming entre dos enteros en representación binaria.\n    Parámetros:\n- x (int): El primer entero positivo (x <= 1,000,000,000).\n- y (int): El segundo entero positivo (y <= 1,000,000,000).\n    Devuelve:\n    int: La distancia de Hamming entre x e y, es decir, el número de bits que necesitan ser cambiados\n         para transformar x en y en binario.\n\t>>> hamming_distance(1,2)\n\t2\n*/\nint hamming_distance(int x, int y)",
      "arb": "#include <assert.h>\n#include <stdio.h>\n/*\nاحسب مسافة هامنج بين عددين صحيحين في التمثيل الثنائي.\n    المعلمات:\n- x (int): العدد الصحيح الأول الموجب (x <= 1,000,000,000).\n- y (int): العدد الصحيح الثاني الموجب (y <= 1,000,000,000).\n    يعيد:\n    int: مسافة هامنج بين x و y، أي عدد البتات التي تحتاج إلى قلب\n         لتحويل x إلى y في النظام الثنائي.\n\t>>> hamming_distance(1,2)\n\t2\n*/\nint hamming_distance(int x, int y)",
      "sw": "#include <assert.h>\n#include <stdio.h>\n/*\nHesabu umbali wa Hamming kati ya nambari mbili katika uwakilishi wa binary.\n​    Vigezo:\n- x (int): Nambari ya kwanza chanya (x <= 1,000,000,000).\n- y (int): Nambari ya pili chanya (y <= 1,000,000,000).\n​    Inarejesha:\n​    int: Umbali wa Hamming kati ya x na y, yaani, idadi ya biti zinazohitajika kubadilishwa\n​         ili kubadilisha x kuwa y katika binary.\n\t>>> hamming_distance(1,2)\n\t2\n*/\nint hamming_distance(int x, int y)",
      "tr": "#include <assert.h>\n#include <stdio.h>\n/*\nİki tam sayı arasındaki Hamming mesafesini ikili gösterimde hesaplayın.\n​    Parametreler:\n- x (int): İlk pozitif tam sayı (x <= 1,000,000,000).\n- y (int): İkinci pozitif tam sayı (y <= 1,000,000,000).\n​    Döndürür:\n​    int: x ve y arasındaki Hamming mesafesi, yani x'i ikili olarak y'ye dönüştürmek için\n​         çevrilmesi gereken bit sayısı.\n\t>>> hamming_distance(1,2)\n\t2\n*/\nint hamming_distance(int x, int y)",
      "vi": "#include <assert.h>\n#include <stdio.h>\n/*\nTính khoảng cách Hamming giữa hai số nguyên trong biểu diễn nhị phân.\n​    Tham số:\n- x (int): Số nguyên dương thứ nhất (x <= 1,000,000,000).\n- y (int): Số nguyên dương thứ hai (y <= 1,000,000,000).\n​    Trả về:\n​    int: Khoảng cách Hamming giữa x và y, tức là số bit cần lật để biến đổi x thành y trong nhị phân.\n\t>>> hamming_distance(1,2)\n\t2\n*/\nint hamming_distance(int x, int y)"
    },
    "prompt_bertscore": {
      "es": "0.9705385459937623",
      "arb": "0.9762737996157637",
      "sw": "0.9570753787672176",
      "tr": "0.9709566629458407",
      "vi": "0.9726277403414872"
    },
    "canonical_solution": "{\n    int distance = 0;\n    int xor_result = x ^ y; // XOR x and y to get a number where set bits are the differences\n    // Count the number of bits set in xor_result\n    // printf(\"%d\\n\", xor_result);\n    while (xor_result) {\n        if (xor_result & 1) {\n            distance++;\n        }\n        xor_result >>= 1;\n    }\n    return distance;\n}",
    "instruction": {
      "es": "int hamming_distance(int x, int y)\n{\n    int distance = 0;\n    int xor_result = x ^ y; // XOR x and y to get a number where set bits are the differences\n    // Count the number of bits set in xor_result\n    // printf(\"%d\\n\", xor_result);\n    while (xor_result) {\n        if (xor_result & 1) {\n            distance++;\n        }\n        xor_result >>= 1;\n    }\n    return distance;\n}\n\nProporcione una descripción concisa en lenguaje natural (docstring) del código C en español utilizando como máximo 500 caracteres.",
      "arb": "int hamming_distance(int x, int y)\n{\n    int distance = 0;\n    int xor_result = x ^ y; // XOR x and y to get a number where set bits are the differences\n    // Count the number of bits set in xor_result\n    // printf(\"%d\\n\", xor_result);\n    while (xor_result) {\n        if (xor_result & 1) {\n            distance++;\n        }\n        xor_result >>= 1;\n    }\n    return distance;\n}\n\nيرجى تقديم وصف موجز بلغة طبيعية (docstring) للكود المكتوب بلغة C باللغة العربية الفصحى، بحيث لا يتجاوز 500 حرف.",
      "sw": "int hamming_distance(int x, int y)\n{\n    int distance = 0;\n    int xor_result = x ^ y; // XOR x and y to get a number where set bits are the differences\n    // Count the number of bits set in xor_result\n    // printf(\"%d\\n\", xor_result);\n    while (xor_result) {\n        if (xor_result & 1) {\n            distance++;\n        }\n        xor_result >>= 1;\n    }\n    return distance;\n}\n\nToa maelezo mafupi ya lugha ya asili (docstring) ya msimbo wa C kwa Kiswahili kwa kutumia herufi zisizozidi 500.",
      "tr": "int hamming_distance(int x, int y)\n{\n    int distance = 0;\n    int xor_result = x ^ y; // XOR x and y to get a number where set bits are the differences\n    // Count the number of bits set in xor_result\n    // printf(\"%d\\n\", xor_result);\n    while (xor_result) {\n        if (xor_result & 1) {\n            distance++;\n        }\n        xor_result >>= 1;\n    }\n    return distance;\n}\n\nC kodunun işlevselliğini açıklayan kısa bir doğal dil açıklaması (docstring) sağlayın. Açıklama, en fazla 500 karakter kullanılarak Türkçe olarak yazılmalıdır.",
      "vi": "int hamming_distance(int x, int y)\n{\n    int distance = 0;\n    int xor_result = x ^ y; // XOR x and y to get a number where set bits are the differences\n    // Count the number of bits set in xor_result\n    // printf(\"%d\\n\", xor_result);\n    while (xor_result) {\n        if (xor_result & 1) {\n            distance++;\n        }\n        xor_result >>= 1;\n    }\n    return distance;\n}\n\nCung cấp mô tả ngắn gọn bằng ngôn ngữ tự nhiên (docstring) của mã C bằng tiếng Việt với tối đa 500 ký tự."
    },
    "instruction_bertscore": {
      "es": "0.9687963589217052",
      "arb": "0.8727085148353161",
      "sw": "0.9146175389298671",
      "tr": "0.8813211281569888",
      "vi": "0.923675282935439"
    },
    "level": "",
    "test": "int main() {\n    assert(hamming_distance(1, 2) == 2); // 01 and 10 have 2 different bits\n    assert(hamming_distance(4, 7) == 2); // 100 and 111 have 2 different bits\n    assert(hamming_distance(25, 30) == 3); // Additional test: 11001 and 11110 have 3 different bits\n    assert(hamming_distance(0, 0) == 0); // Additional test: Same numbers have 0 different bits\n    assert(hamming_distance(0xFFFFFFF, 0x0000000) == 28); // Additional test: Max unsigned int and 0 have 32 different bits\n    return 0;\n}",
    "entry_point": "hamming_distance",
    "signature": "int hamming_distance(int x, int y)",
    "docstring": {
      "es": "Calcular la distancia de Hamming entre dos enteros en representación binaria.\n    Parámetros:\n- x (int): El primer entero positivo (x <= 1,000,000,000).\n- y (int): El segundo entero positivo (y <= 1,000,000,000).\n    Devuelve:\n    int: La distancia de Hamming entre x e y, es decir, el número de bits que deben ser cambiados para transformar x en y en binario.\n    >>> hamming_distance(1,2)\n    2",
      "arb": "احسب مسافة هامينغ بين عددين صحيحين في التمثيل الثنائي.\n    المعلمات:\n- x (int): العدد الصحيح الأول الموجب (x <= 1,000,000,000).\n- y (int): العدد الصحيح الثاني الموجب (y <= 1,000,000,000).\n    يعيد:\n    int: مسافة هامينغ بين x و y، أي عدد البتات التي تحتاج إلى قلبها لتحويل x إلى y في التمثيل الثنائي.\n    >>> hamming_distance(1,2)\n    2",
      "sw": "Hesabu umbali wa Hamming kati ya nambari mbili katika uwakilishi wa binary.\n    Vigezo:\n- x (int): Nambari ya kwanza chanya (x <= 1,000,000,000).\n- y (int): Nambari ya pili chanya (y <= 1,000,000,000).\n    Inarejesha:\n    int: Umbali wa Hamming kati ya x na y, yaani, idadi ya biti zinazohitajika kubadilishwa ili kubadilisha x kuwa y katika binary.\n    >>> hamming_distance(1,2)\n    2",
      "tr": "İki tamsayı arasındaki ikili gösterimdeki Hamming mesafesini hesaplayın.\n    Parametreler:\n- x (int): İlk pozitif tamsayı (x <= 1,000,000,000).\n- y (int): İkinci pozitif tamsayı (y <= 1,000,000,000).\n    Döndürür:\n    int: x ve y arasındaki Hamming mesafesi, yani x'i ikili olarak y'ye dönüştürmek için çevrilmesi gereken bit sayısı.\n    >>> hamming_distance(1,2)\n    2",
      "vi": "Tính khoảng cách Hamming giữa hai số nguyên trong biểu diễn nhị phân.\n    Tham số:\n- x (int): Số nguyên dương thứ nhất (x <= 1,000,000,000).\n- y (int): Số nguyên dương thứ hai (y <= 1,000,000,000).\n    Trả về:\n    int: Khoảng cách Hamming giữa x và y, tức là số bit cần phải lật để biến đổi x thành y trong nhị phân.\n    >>> hamming_distance(1,2)\n    2"
    },
    "docstring_bertscore": {
      "es": "0.9859604074076921",
      "arb": "0.9915703252592604",
      "sw": "0.9742779615471251",
      "tr": "0.9850868309919006",
      "vi": "0.9900289535024297"
    }
  },
  {
    "task_id": "C/9",
    "prompt": {
      "es": "#include <assert.h>\n#include <stdarg.h>\n\n/*\nCuenta el número de enteros impares en una lista dada de números.\n    Parámetros:\n- count (int): La cantidad de números a evaluar.\n- ... (int): Una secuencia de enteros.\n    Devuelve:\n    int: La cantidad de números impares en la lista de entrada.\n    >>> count_odd_numbers(5, 1, 4, 3, 2, 5)\n    3\n*/\nint count_odd_numbers(int count, ...)",
      "arb": "#include <assert.h>\n#include <stdarg.h>\n\n/*\nاحسب عدد الأعداد الفردية في قائمة معينة من الأرقام.\n    المعلمات:\n- count (int): عدد الأرقام لتقييمها.\n- ... (int): تسلسل من الأعداد الصحيحة.\n    يعيد:\n    int: عدد الأعداد الفردية في قائمة الإدخال.\n    >>> count_odd_numbers(5, 1, 4, 3, 2, 5)\n    3\n*/\nint count_odd_numbers(int count, ...)",
      "sw": "#include <assert.h>\n#include <stdarg.h>\n\n/*\nHesabu idadi ya nambari zisizo za kawaida katika orodha iliyotolewa ya nambari.\n    Vigezo:\n- count (int): Idadi ya nambari za kutathmini.\n- ... (int): Mfululizo wa nambari za mzima.\n    Inarudisha:\n    int: Idadi ya nambari zisizo za kawaida katika orodha ya pembejeo.\n    >>> count_odd_numbers(5, 1, 4, 3, 2, 5)\n    3\n*/\nint count_odd_numbers(int count, ...)",
      "tr": "#include <assert.h>\n#include <stdarg.h>\n\n/*\nVerilen bir sayı listesindeki tek sayıların sayısını sayar.\n    Parametreler:\n- count (int): Değerlendirilecek sayıların sayısı.\n- ... (int): Bir dizi tam sayı.\n    Döndürür:\n    int: Girdi listesindeki tek sayıların sayısı.\n    >>> count_odd_numbers(5, 1, 4, 3, 2, 5)\n    3\n*/\nint count_odd_numbers(int count, ...)",
      "vi": "#include <assert.h>\n#include <stdarg.h>\n\n/*\nĐếm số lượng số nguyên lẻ trong một danh sách số đã cho.\n    Tham số:\n- count (int): Số lượng số cần đánh giá.\n- ... (int): Một dãy số nguyên.\n    Trả về:\n    int: Số lượng số lẻ trong danh sách đầu vào.\n    >>> count_odd_numbers(5, 1, 4, 3, 2, 5)\n    3\n*/\nint count_odd_numbers(int count, ...)"
    },
    "prompt_bertscore": {
      "es": "0.9886111298426026",
      "arb": "0.9812894153672757",
      "sw": "0.9635819141587774",
      "tr": "0.9747081949524466",
      "vi": "0.9926780868942919"
    },
    "canonical_solution": "{\n    va_list args;\n    va_start(args, count);\n    int ans = 0;\n    for (int i = 0; i < count; i++) {\n        int num = va_arg(args, int);\n        if (num & 1)\n            ans++;\n    }\n    va_end(args);\n    return ans;\n}",
    "instruction": {
      "es": "int count_odd_numbers(int count, ...)\n{\n    va_list args;\n    va_start(args, count);\n    int ans = 0;\n    for (int i = 0; i < count; i++) {\n        int num = va_arg(args, int);\n        if (num & 1)\n            ans++;\n    }\n    va_end(args);\n    return ans;\n}\n\nProporcione una descripción concisa en lenguaje natural (docstring) del código C en español utilizando como máximo 500 caracteres.",
      "arb": "int count_odd_numbers(int count, ...)\n{\n    va_list args;\n    va_start(args, count);\n    int ans = 0;\n    for (int i = 0; i < count; i++) {\n        int num = va_arg(args, int);\n        if (num & 1)\n            ans++;\n    }\n    va_end(args);\n    return ans;\n}\n\nيرجى تقديم وصف موجز بلغة طبيعية (docstring) للشفرة البرمجية بلغة C باللغة العربية الفصحى، بحيث لا يتجاوز 500 حرف.",
      "sw": "int count_odd_numbers(int count, ...)\n{\n    va_list args;\n    va_start(args, count);\n    int ans = 0;\n    for (int i = 0; i < count; i++) {\n        int num = va_arg(args, int);\n        if (num & 1)\n            ans++;\n    }\n    va_end(args);\n    return ans;\n}\n\nToa maelezo mafupi ya lugha asilia (docstring) ya msimbo wa C kwa Kiswahili kwa kutumia herufi zisizozidi 500.",
      "tr": "int count_odd_numbers(int count, ...)\n{\n    va_list args;\n    va_start(args, count);\n    int ans = 0;\n    for (int i = 0; i < count; i++) {\n        int num = va_arg(args, int);\n        if (num & 1)\n            ans++;\n    }\n    va_end(args);\n    return ans;\n}\n\nVerilen C kodunun işlevini açıklayan, en fazla 500 karakter uzunluğunda, özlü bir doğal dil açıklaması (docstring) sağlayın.",
      "vi": "int count_odd_numbers(int count, ...)\n{\n    va_list args;\n    va_start(args, count);\n    int ans = 0;\n    for (int i = 0; i < count; i++) {\n        int num = va_arg(args, int);\n        if (num & 1)\n            ans++;\n    }\n    va_end(args);\n    return ans;\n}\n\nCung cấp mô tả ngắn gọn bằng ngôn ngữ tự nhiên (docstring) cho mã C bằng tiếng Việt, không quá 500 ký tự."
    },
    "instruction_bertscore": {
      "es": "0.9687963589217052",
      "arb": "0.903070757619547",
      "sw": "0.9423429634058599",
      "tr": "0.8475241688239026",
      "vi": "0.8955772278646248"
    },
    "level": "",
    "test": "int main() {\n    assert(count_odd_numbers(5, 1, 4, 3, 2, 5) == 3);\n    assert(count_odd_numbers(4, 2, 2, 0, 0) == 0);\n    assert(count_odd_numbers(6, 7, 7, 8, 1, 9, 10) == 4); // Additional Test Sample\n    // printf(\"All tests passed!\\n\");\n    return 0;\n}",
    "entry_point": "count_odd_numbers",
    "signature": "int count_odd_numbers(int count, ...)",
    "docstring": {
      "es": "Cuenta el número de enteros impares en una lista dada de números.\n    Parámetros:\n- count (int): La cantidad de números a evaluar.\n- ... (int): Una secuencia de enteros.\n    Devuelve:\n    int: La cantidad de números impares en la lista de entrada.\n    >>> count_odd_numbers(5, 1, 4, 3, 2, 5)\n    3",
      "arb": "احسب عدد الأعداد الفردية في قائمة معينة من الأرقام.\n    المعلمات:\n- count (int): عدد الأرقام لتقييمها.\n- ... (int): تسلسل من الأعداد الصحيحة.\n    يعيد:\n    int: عدد الأعداد الفردية في قائمة الإدخال.\n    >>> count_odd_numbers(5, 1, 4, 3, 2, 5)\n    3",
      "sw": "Hesabu idadi ya nambari zisizo za kawaida katika orodha iliyotolewa ya nambari.\n    Vigezo:\n- count (int): Idadi ya nambari za kutathmini.\n- ... (int): Mfululizo wa nambari za mzima.\n    Inarejesha:\n    int: Idadi ya nambari zisizo za kawaida katika orodha ya ingizo.\n    >>> count_odd_numbers(5, 1, 4, 3, 2, 5)\n    3",
      "tr": "Verilen bir sayı listesindeki tek sayıların sayısını sayın.\n    Parametreler:\n- count (int): Değerlendirilecek sayıların sayısı.\n- ... (int): Bir dizi tam sayı.\n    Döndürür:\n    int: Girdi listesindeki tek sayıların sayısı.\n    >>> count_odd_numbers(5, 1, 4, 3, 2, 5)\n    3",
      "vi": "Đếm số lượng số nguyên lẻ trong một danh sách số đã cho.\n    Tham số:\n- count (int): Số lượng số cần đánh giá.\n- ... (int): Một dãy số nguyên.\n    Trả về:\n    int: Số lượng số lẻ trong danh sách đầu vào.\n    >>> count_odd_numbers(5, 1, 4, 3, 2, 5)\n    3"
    },
    "docstring_bertscore": {
      "es": "0.9807247091939935",
      "arb": "0.9717601228371269",
      "sw": "0.9645498400055604",
      "tr": "0.9823493070804777",
      "vi": "0.9893275896269954"
    }
  },
  {
    "task_id": "C/10",
    "prompt": {
      "es": "#include <assert.h>\n#include <stdio.h>\n/*\nCalcular la suma de los números pares en una lista dada.\n    Parámetros:\n- numbers (list): Una lista de enteros.\n- size (int): El tamaño de la lista.\n    Devuelve:\n    int: La suma de los números pares en la lista de entrada.\n    >>> calculate_even_sum([1,4,3,2,5], 5)\n    6\n*/\nint calculate_even_sum(int *numbers, int size); // Fixed declaration",
      "arb": "#include <assert.h>\n#include <stdio.h>\n/*\nحساب مجموع الأرقام الزوجية في قائمة معينة.\n    المعاملات:\n- numbers (list): قائمة من الأعداد الصحيحة.\n- size (int): حجم القائمة.\n    يعيد:\n    int: مجموع الأرقام الزوجية في القائمة المدخلة.\n    >>> calculate_even_sum([1,4,3,2,5], 5)\n    6\n*/\nint calculate_even_sum(int *numbers, int size); // Fixed declaration",
      "sw": "#include <assert.h>\n#include <stdio.h>\n/*\nHesabu jumla ya nambari shufwa katika orodha iliyotolewa.\n    Vigezo:\n- numbers (list): Orodha ya nambari kamili.\n- size (int): Ukubwa wa orodha.\n    Inarudisha:\n    int: Jumla ya nambari shufwa katika orodha ya ingizo.\n    >>> calculate_even_sum([1,4,3,2,5], 5)\n    6\n*/\nint calculate_even_sum(int *numbers, int size); // Fixed declaration",
      "tr": "#include <assert.h>\n#include <stdio.h>\n/*\nVerilen bir listedeki çift sayıların toplamını hesapla.\n    Parametreler:\n- numbers (list): Bir tamsayı listesi.\n- size (int): Listenin boyutu.\n    Döndürür:\n    int: Girdi listesindeki çift sayıların toplamı.\n    >>> calculate_even_sum([1,4,3,2,5], 5)\n    6\n*/\nint calculate_even_sum(int *numbers, int size); // Sabit bildirim",
      "vi": "#include <assert.h>\n#include <stdio.h>\n/*\nTính tổng các số chẵn trong một danh sách cho trước.\n    Tham số:\n- numbers (list): Một danh sách các số nguyên.\n- size (int): Kích thước của danh sách.\n    Trả về:\n    int: Tổng các số chẵn trong danh sách đầu vào.\n    >>> calculate_even_sum([1,4,3,2,5], 5)\n    6\n*/\nint calculate_even_sum(int *numbers, int size); // Fixed declaration"
    },
    "prompt_bertscore": {
      "es": "0.9931317586845756",
      "arb": "1",
      "sw": "0.9802656743834218",
      "tr": "0.9944989315972388",
      "vi": "1"
    },
    "canonical_solution": "int calculate_even_sum(int *numbers, int size) { // Fixed solution\n    int ans = 0;\n    for (int i = 0; i < size; i++) {\n        if ((numbers[i] & 1) == 0) { // Only sum the even numbers\n            ans += numbers[i];\n        }\n    }\n    return ans;\n}",
    "instruction": {
      "es": "int calculate_even_sum(int *numbers, int size)\nint calculate_even_sum(int *numbers, int size) { // Fixed solution\n    int ans = 0;\n    for (int i = 0; i < size; i++) {\n        if ((numbers[i] & 1) == 0) { // Only sum the even numbers\n            ans += numbers[i];\n        }\n    }\n    return ans;\n}\n\nProporcione una descripción concisa en lenguaje natural (docstring) del código C en español utilizando un máximo de 500 caracteres.",
      "arb": "int calculate_even_sum(int *numbers, int size)\nint calculate_even_sum(int *numbers, int size) { // Fixed solution\n    int ans = 0;\n    for (int i = 0; i < size; i++) {\n        if ((numbers[i] & 1) == 0) { // Only sum the even numbers\n            ans += numbers[i];\n        }\n    }\n    return ans;\n}\n\nيرجى تقديم وصف موجز بلغة طبيعية (docstring) للشيفرة البرمجية المكتوبة بلغة C باللغة العربية الفصحى، بحيث لا يتجاوز 500 حرف.",
      "sw": "int calculate_even_sum(int *numbers, int size)\nint calculate_even_sum(int *numbers, int size) { // Fixed solution\n    int ans = 0;\n    for (int i = 0; i < size; i++) {\n        if ((numbers[i] & 1) == 0) { // Only sum the even numbers\n            ans += numbers[i];\n        }\n    }\n    return ans;\n}\n\nToa maelezo mafupi ya lugha ya asili (docstring) ya msimbo wa C kwa Kiswahili kwa kutumia herufi zisizozidi 500.",
      "tr": "int calculate_even_sum(int *numbers, int size)\nint calculate_even_sum(int *numbers, int size) { // Fixed solution\n    int ans = 0;\n    for (int i = 0; i < size; i++) {\n        if ((numbers[i] & 1) == 0) { // Only sum the even numbers\n            ans += numbers[i];\n        }\n    }\n    return ans;\n}\n\nC kodunun işlevini açıklayan kısa bir doğal dil açıklaması (docstring) sağlayın. Açıklama, en fazla 500 karakter kullanılarak Türkçe olarak yazılmalıdır.",
      "vi": "int calculate_even_sum(int *numbers, int size)\nint calculate_even_sum(int *numbers, int size) { // Fixed solution\n    int ans = 0;\n    for (int i = 0; i < size; i++) {\n        if ((numbers[i] & 1) == 0) { // Only sum the even numbers\n            ans += numbers[i];\n        }\n    }\n    return ans;\n}\n\nCung cấp mô tả ngắn gọn bằng ngôn ngữ tự nhiên (docstring) của mã C bằng tiếng Việt với tối đa 500 ký tự."
    },
    "instruction_bertscore": {
      "es": "0.9687963589217052",
      "arb": "0.8800316197233103",
      "sw": "0.9146175389298671",
      "tr": "0.8690074349454929",
      "vi": "0.9598375328458887"
    },
    "level": "",
    "test": "int main() {\n    int sample1[] = {1, 4, 3, 2, 5};\n    int sample2[] = {2, 2, 0, 0};\n    int sample3[] = {7, 11, 19}; // Additional test with no even numbers\n    int sample4[] = {12, 14, 16, 18, 20}; // Additional test with all even numbers\n\n    assert(calculate_even_sum(sample1, 5) == 6);\n    assert(calculate_even_sum(sample2, 4) == 4);\n    assert(calculate_even_sum(sample3, 3) == 0); // Should return 0 because there are no even numbers\n    assert(calculate_even_sum(sample4, 5) == 12 + 14 + 16 + 18 + 20);\n\n    \n\n    return 0;\n}",
    "entry_point": "calculate_even_sum",
    "signature": "int calculate_even_sum(int *numbers, int size)",
    "docstring": {
      "es": "Calcular la suma de los números pares en una lista dada.\n    Parámetros:\n- numbers (list): Una lista de enteros.\n- size (int): El tamaño de la lista.\n    Devuelve:\n    int: La suma de los números pares en la lista de entrada.\n    >>> calculate_even_sum([1,4,3,2,5], 5)\n    6",
      "arb": "حساب مجموع الأعداد الزوجية في قائمة معينة.\n    المعاملات:\n- numbers (list): قائمة من الأعداد الصحيحة.\n- size (int): حجم القائمة.\n    يعيد:\n    int: مجموع الأعداد الزوجية في القائمة المدخلة.\n    >>> calculate_even_sum([1,4,3,2,5], 5)\n    6",
      "sw": "Hesabu jumla ya namba shufwa katika orodha iliyotolewa.\n    Vigezo:\n- numbers (list): Orodha ya namba nzima.\n- size (int): Ukubwa wa orodha.\n    Inarejesha:\n    int: Jumla ya namba shufwa katika orodha iliyoingizwa.\n    >>> calculate_even_sum([1,4,3,2,5], 5)\n    6",
      "tr": "Verilen bir listedeki çift sayıların toplamını hesaplayın.\n    Parametreler:\n- numbers (list): Bir tamsayı listesi.\n- size (int): Listenin boyutu.\n    Döndürür:\n    int: Girdi listesindeki çift sayıların toplamı.\n    >>> calculate_even_sum([1,4,3,2,5], 5)\n    6",
      "vi": "Tính tổng các số chẵn trong một danh sách cho trước.\n    Tham số:\n- numbers (list): Một danh sách các số nguyên.\n- size (int): Kích thước của danh sách.\n    Trả về:\n    int: Tổng các số chẵn trong danh sách đầu vào.\n    >>> calculate_even_sum([1,4,3,2,5], 5)\n    6"
    },
    "docstring_bertscore": {
      "es": "0.9891321373320572",
      "arb": "0.995814857871595",
      "sw": "0.9534700387210533",
      "tr": "1",
      "vi": "1"
    }
  },
  {
    "task_id": "C/11",
    "prompt": {
      "es": "#include <assert.h>\n#include <stdio.h>\n/*\nDeterminar si dos intervalos cerrados se intersectan.\n​    Args:\n​    a, b: Representando el primer intervalo cerrado [a, b] donde 0 <= a <= b <= 1000.\n​    c, d: Representando el segundo intervalo cerrado [c, d] donde 0 <= c <= d <= 1000.\n​    Retorna:\n​    int: 1 si los intervalos se intersectan, 0 de lo contrario.\n*/\nint are_intervals_intersecting(int a, int b, int c, int d)",
      "arb": "#include <assert.h>\n#include <stdio.h>\n/*\nتحديد ما إذا كان هناك تقاطع بين فترتين مغلقتين.\n​    Args:\n​    a, b: تمثل الفترة المغلقة الأولى [a, b] حيث 0 <= a <= b <= 1000.\n​    c, d: تمثل الفترة المغلقة الثانية [c, d] حيث 0 <= c <= d <= 1000.\n​    Returns:\n​    int: 1 إذا كانت الفترات تتقاطع، 0 خلاف ذلك.\n*/\nint are_intervals_intersecting(int a, int b, int c, int d)",
      "sw": "#include <assert.h>\n#include <stdio.h>\n/*\nTambua kama vipindi viwili vilivyofungwa vinakatana.\n​    Args:\n​    a, b: Inawakilisha kipindi cha kwanza kilichofungwa [a, b] ambapo 0 <= a <= b <= 1000.\n​    c, d: Inawakilisha kipindi cha pili kilichofungwa [c, d] ambapo 0 <= c <= d <= 1000.\n​    Inarudisha:\n​    int: 1 ikiwa vipindi vinakatana, 0 vinginevyo.\n*/\nint are_intervals_intersecting(int a, int b, int c, int d)",
      "tr": "#include <assert.h>\n#include <stdio.h>\n/*\nİki kapalı aralığın kesişip kesişmediğini belirleyin.\n​    Args:\n​    a, b: İlk kapalı aralığı [a, b] temsil eder, burada 0 <= a <= b <= 1000.\n​    c, d: İkinci kapalı aralığı [c, d] temsil eder, burada 0 <= c <= d <= 1000.\n​    Döndürür:\n​    int: Aralıklar kesişiyorsa 1, aksi takdirde 0.\n*/\nint are_intervals_intersecting(int a, int b, int c, int d)",
      "vi": "#include <assert.h>\n#include <stdio.h>\n/*\nXác định xem hai khoảng đóng có giao nhau hay không.\n​    Args:\n​    a, b: Đại diện cho khoảng đóng đầu tiên [a, b] với điều kiện 0 <= a <= b <= 1000.\n​    c, d: Đại diện cho khoảng đóng thứ hai [c, d] với điều kiện 0 <= c <= d <= 1000.\n​    Trả về:\n​    int: 1 nếu các khoảng giao nhau, 0 nếu không.\n*/\nint are_intervals_intersecting(int a, int b, int c, int d)"
    },
    "prompt_bertscore": {
      "es": "0.9626753650997342",
      "arb": "0.9588970179916885",
      "sw": "0.9897615970095567",
      "tr": "0.947519072505248",
      "vi": "0.9310514221351696"
    },
    "canonical_solution": "{\n    if ((c <= a && b <= d) ||\n        (a <= c && c <= b && b <= d) ||\n        (a <= c && d <= b) ||\n        (c <= a && a <= d && d <= b)) {\n        return 1; // Yes\n    } else {\n        return 0; // No\n    }\n}",
    "instruction": {
      "es": "int are_intervals_intersecting(int a, int b, int c, int d)\n{\n    if ((c <= a && b <= d) ||\n        (a <= c && c <= b && b <= d) ||\n        (a <= c && d <= b) ||\n        (c <= a && a <= d && d <= b)) {\n        return 1; // Yes\n    } else {\n        return 0; // No\n    }\n}\n\nProporcione una descripción concisa en lenguaje natural (docstring) del código C en español utilizando como máximo 500 caracteres.",
      "arb": "int are_intervals_intersecting(int a, int b, int c, int d)\n{\n    if ((c <= a && b <= d) ||\n        (a <= c && c <= b && b <= d) ||\n        (a <= c && d <= b) ||\n        (c <= a && a <= d && d <= b)) {\n        return 1; // Yes\n    } else {\n        return 0; // No\n    }\n}\n\nيرجى تقديم وصف موجز بلغة طبيعية (docstring) للكود المكتوب بلغة C باللغة العربية الفصحى، بحيث لا يتجاوز 500 حرف.",
      "sw": "int are_intervals_intersecting(int a, int b, int c, int d)\n{\n    if ((c <= a && b <= d) ||\n        (a <= c && c <= b && b <= d) ||\n        (a <= c && d <= b) ||\n        (c <= a && a <= d && d <= b)) {\n        return 1; // Yes\n    } else {\n        return 0; // No\n    }\n}\n\nToa maelezo mafupi ya lugha asilia (docstring) ya msimbo wa C kwa Kiswahili kwa kutumia herufi zisizozidi 500.",
      "tr": "int are_intervals_intersecting(int a, int b, int c, int d)\n{\n    if ((c <= a && b <= d) ||\n        (a <= c && c <= b && b <= d) ||\n        (a <= c && d <= b) ||\n        (c <= a && a <= d && d <= b)) {\n        return 1; // Yes\n    } else {\n        return 0; // No\n    }\n}\n\nVerilen C kodunun işlevini açıklayan, en fazla 500 karakter uzunluğunda, özlü bir doğal dil açıklaması (docstring) sağlayın.",
      "vi": "int are_intervals_intersecting(int a, int b, int c, int d)\n{\n    if ((c <= a && b <= d) ||\n        (a <= c && c <= b && b <= d) ||\n        (a <= c && d <= b) ||\n        (c <= a && a <= d && d <= b)) {\n        return 1; // Yes\n    } else {\n        return 0; // No\n    }\n}\n\nCung cấp mô tả ngắn gọn bằng ngôn ngữ tự nhiên (docstring) của mã C bằng tiếng Việt với tối đa 500 ký tự."
    },
    "instruction_bertscore": {
      "es": "0.9687963589217052",
      "arb": "0.8609607195793886",
      "sw": "0.9423429634058599",
      "tr": "0.8375622593238599",
      "vi": "0.9439043968311751"
    },
    "level": "",
    "test": "int main() {\n    assert(are_intervals_intersecting(1, 1, 1, 2) == 1);\n    assert(are_intervals_intersecting(3, 5, 2, 6) == 1);\n    assert(are_intervals_intersecting(3, 5, 4, 7) == 1);\n    assert(are_intervals_intersecting(3, 5, 6, 7) == 0);\n    // Additional test cases\n    assert(are_intervals_intersecting(0, 0, 0, 0) == 1);\n    assert(are_intervals_intersecting(1, 3, 2, 4) == 1);\n    assert(are_intervals_intersecting(1, 3, 4, 6) == 0);\n    assert(are_intervals_intersecting(10, 20, 20, 30) == 1);\n    assert(are_intervals_intersecting(10, 20, 21, 30) == 0);\n    \n    return 0;\n}",
    "entry_point": "are_intervals_intersecting",
    "signature": "int are_intervals_intersecting(int a, int b, int c, int d)",
    "docstring": {
      "es": "Determinar si dos intervalos cerrados se intersectan.\n    Args:\n    a, b: Representando el primer intervalo cerrado [a, b] donde 0 <= a <= b <= 1000.\n    c, d: Representando el segundo intervalo cerrado [c, d] donde 0 <= c <= d <= 1000.\n    Returns:\n    int: 1 si los intervalos se intersectan, 0 en caso contrario.",
      "arb": "Determine if two closed intervals intersect.  \n    Args:  \n    a, b: تمثل الفترة المغلقة الأولى [a, b] حيث 0 <= a <= b <= 1000.  \n    c, d: تمثل الفترة المغلقة الثانية [c, d] حيث 0 <= c <= d <= 1000.  \n    Returns:  \n    int: 1 إذا كانت الفترات تتقاطع، 0 خلاف ذلك.  ",
      "sw": "Determine if two closed intervals intersect.\n    Args:\n    a, b: Inawakilisha kipengele cha kwanza kilichofungwa [a, b] ambapo 0 <= a <= b <= 1000.\n    c, d: Inawakilisha kipengele cha pili kilichofungwa [c, d] ambapo 0 <= c <= d <= 1000.\n    Returns:\n    int: 1 ikiwa vipengele vinaingiliana, 0 vinginevyo.",
      "tr": "Determine if two closed intervals intersect.\n    Args:\n    a, b: İlk kapalı aralığı temsil eden [a, b] burada 0 <= a <= b <= 1000.\n    c, d: İkinci kapalı aralığı temsil eden [c, d] burada 0 <= c <= d <= 1000.\n    Returns:\n    int: Aralıklar kesişiyorsa 1, aksi takdirde 0.",
      "vi": "Xác định xem hai khoảng đóng có giao nhau hay không.\n    Args:\n    a, b: Đại diện cho khoảng đóng đầu tiên [a, b] với 0 <= a <= b <= 1000.\n    c, d: Đại diện cho khoảng đóng thứ hai [c, d] với 0 <= c <= d <= 1000.\n    Trả về:\n    int: 1 nếu các khoảng giao nhau, 0 nếu không."
    },
    "docstring_bertscore": {
      "es": "1",
      "arb": "0.9861322226872872",
      "sw": "0.9861322226872872",
      "tr": "0.976458327239745",
      "vi": "0.9380201704233976"
    }
  },
  {
    "task_id": "C/12",
    "prompt": {
      "es": "#include <assert.h>\n#include <math.h>\n#include <stdbool.h>\n#include <stdio.h>\n/*\nSe te dan tres dígitos a, b, c. Dos de ellos son iguales, pero el tercero es diferente de los otros dos. Encuentra el valor que aparece exactamente una vez.\n    >>> extraNumber(0,0,1)\n    1\n    >>> extraNumber(4,3,4)\n    3\n*/\nint extraNumber(int a, int b, int c)",
      "arb": "#include <assert.h>\n#include <math.h>\n#include <stdbool.h>\n#include <stdio.h>\n/*\nأنت تُعطى ثلاثة أرقام a، b، c. اثنان منهما متساويان، لكن الثالث مختلف عن الآخرين. جد القيمة التي تظهر مرة واحدة فقط.\n    >>> extraNumber(0,0,1)\n    1\n    >>> extraNumber(4,3,4)\n    3\n*/\nint extraNumber(int a, int b, int c)",
      "sw": "#include <assert.h>\n#include <math.h>\n#include <stdbool.h>\n#include <stdio.h>\n/*\nUnapewa tarakimu tatu a, b, c. Mbili kati ya hizo ni sawa, lakini ya tatu ni tofauti na zile nyingine mbili. Tafuta thamani inayotokea mara moja tu.\n    >>> extraNumber(0,0,1)\n    1\n    >>> extraNumber(4,3,4)\n    3\n*/\nint extraNumber(int a, int b, int c)",
      "tr": "#include <assert.h>\n#include <math.h>\n#include <stdbool.h>\n#include <stdio.h>\n/*\nÜç basamak a, b, c verilir. İkisi eşittir, ancak üçüncüsü diğer ikisinden farklıdır. Tam olarak bir kez geçen değeri bulun.\n    >>> extraNumber(0,0,1)\n    1\n    >>> extraNumber(4,3,4)\n    3\n*/\nint extraNumber(int a, int b, int c)",
      "vi": "#include <assert.h>\n#include <math.h>\n#include <stdbool.h>\n#include <stdio.h>\n/*\nBạn được cung cấp ba chữ số a, b, c. Hai trong số đó bằng nhau, nhưng chữ số thứ ba khác với hai chữ số còn lại. Tìm giá trị xuất hiện chính xác một lần.\n    >>> extraNumber(0,0,1)\n    1\n    >>> extraNumber(4,3,4)\n    3\n*/\nint extraNumber(int a, int b, int c)"
    },
    "prompt_bertscore": {
      "es": "0.9879028139038322",
      "arb": "0.9775136504541834",
      "sw": "0.985327769644096",
      "tr": "0.9785024324909751",
      "vi": "0.9871966828992532"
    },
    "canonical_solution": "{\n    if (a == b)\n        return c;\n    else if (a == c)\n        return b;\n    else\n        return a;\n}",
    "instruction": {
      "es": "int extraNumber(int a, int b, int c)\n{\n    if (a == b)\n        return c;\n    else if (a == c)\n        return b;\n    else\n        return a;\n}\n\nProporcione una descripción concisa en lenguaje natural (docstring) del código C en español utilizando un máximo de 500 caracteres.",
      "arb": "int extraNumber(int a, int b, int c)\n{\n    if (a == b)\n        return c;\n    else if (a == c)\n        return b;\n    else\n        return a;\n}\n\nيرجى تقديم وصف موجز بلغة طبيعية (docstring) للكود المكتوب بلغة C باللغة العربية الفصحى، بحيث لا يتجاوز 500 حرف.",
      "sw": "int extraNumber(int a, int b, int c)\n{\n    if (a == b)\n        return c;\n    else if (a == c)\n        return b;\n    else\n        return a;\n}\n\nToa maelezo mafupi ya lugha ya asili (docstring) ya msimbo wa C kwa Kiswahili kwa kutumia herufi zisizozidi 500.",
      "tr": "int extraNumber(int a, int b, int c)\n{\n    if (a == b)\n        return c;\n    else if (a == c)\n        return b;\n    else\n        return a;\n}\n\nC kodunun işlevini açıklayan kısa bir doğal dil açıklaması (docstring) sağlayın. Açıklama, en fazla 500 karakter kullanılarak Türkçe olarak yazılmalıdır.",
      "vi": "int extraNumber(int a, int b, int c)\n{\n    if (a == b)\n        return c;\n    else if (a == c)\n        return b;\n    else\n        return a;\n}\n\nCung cấp mô tả ngắn gọn bằng ngôn ngữ tự nhiên (docstring) của mã C bằng tiếng Việt, sử dụng tối đa 500 ký tự."
    },
    "instruction_bertscore": {
      "es": "0.9687963589217052",
      "arb": "0.8727085148353161",
      "sw": "0.9146175389298671",
      "tr": "0.8827657669182556",
      "vi": "0.9627502487533843"
    },
    "level": "",
    "test": "int main()\n{\n    assert(extraNumber(2, 7, 2) == 7);\n    assert(extraNumber(3, 2, 2) == 3);\n    assert(extraNumber(5, 5, 1) == 1);\n    assert(extraNumber(500000000, 3, 500000000) == 3);\n    assert(extraNumber(500000000, 500000000, 3) == 3);\n    return 0;\n}",
    "entry_point": "extraNumber",
    "signature": "int extraNumber(int a, int b, int c)",
    "docstring": {
      "es": "Se te dan tres dígitos a, b, c. Dos de ellos son iguales, pero el tercero es diferente de los otros dos. Encuentra el valor que ocurre exactamente una vez.\n    >>> extraNumber(0,0,1)\n    1\n    >>> extraNumber(4,3,4)\n    3",
      "arb": "أنت مُعطى ثلاثة أرقام a، b، c. اثنان منهما متساويان، ولكن الرقم الثالث مختلف عن الاثنين الآخرين. ابحث عن القيمة التي تظهر مرة واحدة فقط.\n    >>> extraNumber(0,0,1)\n    1\n    >>> extraNumber(4,3,4)\n    3",
      "sw": "Unapewa tarakimu tatu a, b, c. Mbili kati ya hizo ni sawa, lakini ya tatu ni tofauti na zile nyingine mbili. Tafuta thamani inayotokea mara moja tu.\n    >>> extraNumber(0,0,1)\n    1\n    >>> extraNumber(4,3,4)\n    3",
      "tr": "Üç basamaklı sayı verilir: a, b, c. Bunlardan ikisi eşittir, ancak üçüncüsü diğer ikisinden farklıdır. Tam olarak bir kez meydana gelen değeri bulun.\n    >>> extraNumber(0,0,1)\n    1\n    >>> extraNumber(4,3,4)\n    3",
      "vi": "Bạn được cho ba chữ số a, b, c. Hai trong số chúng bằng nhau, nhưng chữ số thứ ba khác với hai chữ số còn lại. Tìm giá trị xuất hiện chính xác một lần.\n    >>> extraNumber(0,0,1)\n    1\n    >>> extraNumber(4,3,4)\n    3"
    },
    "docstring_bertscore": {
      "es": "0.9823834715060158",
      "arb": "0.9654379164391674",
      "sw": "0.976156409060572",
      "tr": "0.9560965282494777",
      "vi": "0.975626661834352"
    }
  },
  {
    "task_id": "C/13",
    "prompt": {
      "es": "#include <assert.h>\n#include <math.h>\n#include <stdbool.h>\n#include <stdio.h>\n#include <string.h>\n/*\nCalcular la puntuación total de un estudiante basada en las puntuaciones en diferentes asignaturas.\n    Parámetros:\n- subject_scores (list): Una lista que contiene las puntuaciones para cada asignatura.\n    Devuelve:\n    int: La puntuación total obtenida sumando las puntuaciones en todas las asignaturas.\n    >>> calculate_total_score(100,100,100,100,100)\n    500\n*/\nint calculate_total_score(int score1, int score2, int score3, int score4, int score5)",
      "arb": "#include <assert.h>\n#include <math.h>\n#include <stdbool.h>\n#include <stdio.h>\n#include <string.h>\n/*\nاحسب المجموع الكلي للدرجات لطالب بناءً على الدرجات في مواد مختلفة.\n    المعلمات:\n- subject_scores (list): قائمة تحتوي على الدرجات لكل مادة.\n    يعيد:\n    int: المجموع الكلي للدرجات المحصل عليه بجمع الدرجات في جميع المواد.\n    >>> calculate_total_score(100,100,100,100,100)\n    500\n*/\nint calculate_total_score(int score1, int score2, int score3, int score4, int score5)",
      "sw": "#include <assert.h>\n#include <math.h>\n#include <stdbool.h>\n#include <stdio.h>\n#include <string.h>\n/*\nHesabu jumla ya alama kwa mwanafunzi kulingana na alama katika masomo tofauti.\n    Vigezo:\n- subject_scores (orodha): Orodha inayoonyesha alama za kila somo.\n    Inarudisha:\n    int: Jumla ya alama zilizopatikana kwa kujumlisha alama katika masomo yote.\n    >>> calculate_total_score(100,100,100,100,100)\n    500\n*/\nint calculate_total_score(int score1, int score2, int score3, int score4, int score5)",
      "tr": "#include <assert.h>\n#include <math.h>\n#include <stdbool.h>\n#include <stdio.h>\n#include <string.h>\n/*\nBir öğrencinin farklı derslerdeki puanlarına göre toplam puanını hesaplayın.\n    Parametreler:\n- subject_scores (list): Her ders için puanları içeren bir liste.\n    Döndürür:\n    int: Tüm derslerdeki puanların toplamını elde ederek elde edilen toplam puan.\n    >>> calculate_total_score(100,100,100,100,100)\n    500\n*/\nint calculate_total_score(int score1, int score2, int score3, int score4, int score5)",
      "vi": "#include <assert.h>\n#include <math.h>\n#include <stdbool.h>\n#include <stdio.h>\n#include <string.h>\n/*\nTính tổng điểm cho một học sinh dựa trên điểm số trong các môn học khác nhau.\n    Tham số:\n- subject_scores (list): Một danh sách chứa điểm số cho mỗi môn học.\n    Trả về:\n    int: Tổng điểm đạt được bằng cách cộng điểm số trong tất cả các môn học.\n    >>> calculate_total_score(100,100,100,100,100)\n    500\n*/\nint calculate_total_score(int score1, int score2, int score3, int score4, int score5)"
    },
    "prompt_bertscore": {
      "es": "0.992615518324266",
      "arb": "0.9933059575287433",
      "sw": "0.9913788455719428",
      "tr": "0.9863739558610066",
      "vi": "0.9896020968135857"
    },
    "canonical_solution": "{\n    return score1 + score2 + score3 + score4 + score5;\n}",
    "instruction": {
      "es": "int calculate_total_score(int score1, int score2, int score3, int score4, int score5)\n{\n    return score1 + score2 + score3 + score4 + score5;\n}\n\nProporcione una descripción concisa en lenguaje natural (docstring) del código C en español utilizando un máximo de 500 caracteres.",
      "arb": "int calculate_total_score(int score1, int score2, int score3, int score4, int score5)\n{\n    return score1 + score2 + score3 + score4 + score5;\n}\n\nيرجى تقديم وصف موجز بلغة طبيعية (docstring) للكود المكتوب بلغة C باللغة العربية الفصحى، بحيث لا يتجاوز 500 حرف.",
      "sw": "int calculate_total_score(int score1, int score2, int score3, int score4, int score5)\n{\n    return score1 + score2 + score3 + score4 + score5;\n}\n\nToa maelezo mafupi ya lugha ya asili (docstring) ya msimbo wa C kwa Kiswahili kwa kutumia herufi zisizozidi 500.",
      "tr": "int calculate_total_score(int score1, int score2, int score3, int score4, int score5)\n{\n    return score1 + score2 + score3 + score4 + score5;\n}\n\nAşağıdaki C kodunun işlevini açıklayan, en fazla 500 karakter uzunluğunda, özlü bir doğal dil açıklaması (docstring) sağlayın.",
      "vi": "int calculate_total_score(int score1, int score2, int score3, int score4, int score5)\n{\n    return score1 + score2 + score3 + score4 + score5;\n}\n\nCung cấp mô tả ngắn gọn bằng ngôn ngữ tự nhiên (docstring) của mã C bằng tiếng Việt, sử dụng tối đa 500 ký tự."
    },
    "instruction_bertscore": {
      "es": "0.9687963589217052",
      "arb": "0.8609607195793886",
      "sw": "0.9146175389298671",
      "tr": "0.8531317031108985",
      "vi": "0.927643123426992"
    },
    "level": "",
    "test": "int main()\n{\n    assert(calculate_total_score(100,100,100,100,100) == 500);\n    assert(calculate_total_score(0,0,0,0,0) == 0);\n    assert(calculate_total_score(20, 30, 40, 10, 50) == 150);\n    assert(calculate_total_score(23, 45, 67, 89, 12) == 236);\n    assert(calculate_total_score(5, 5, 5, 5, 5) == 25);\n    return 0;\n}",
    "entry_point": "calculate_total_score",
    "signature": "int calculate_total_score(int score1, int score2, int score3, int score4, int score5)",
    "docstring": {
      "es": "Calcular la puntuación total de un estudiante basada en las puntuaciones en diferentes materias.\n    Parámetros:\n- subject_scores (list): Una lista que contiene las puntuaciones para cada materia.\n    Devuelve:\n    int: La puntuación total obtenida al sumar las puntuaciones en todas las materias.\n    >>> calculate_total_score(100,100,100,100,100)\n    500",
      "arb": "احسب المجموع الكلي للدرجات لطالب بناءً على الدرجات في مواد مختلفة.\n    المعاملات:\n- subject_scores (list): قائمة تحتوي على الدرجات لكل مادة.\n    يعيد:\n    int: المجموع الكلي للدرجات المحصل عليه عن طريق جمع الدرجات في جميع المواد.\n    >>> calculate_total_score(100,100,100,100,100)\n    500",
      "sw": "Hesabu jumla ya alama kwa mwanafunzi kulingana na alama katika masomo tofauti.\n    Vigezo:\n- subject_scores (list): Orodha inayojumuisha alama za kila somo.\n    Inarejesha:\n    int: Jumla ya alama inayopatikana kwa kujumlisha alama katika masomo yote.\n    >>> calculate_total_score(100,100,100,100,100)\n    500",
      "tr": "Öğrencinin farklı derslerdeki puanlarına göre toplam puanını hesaplayın.\n    Parametreler:\n- subject_scores (list): Her ders için puanları içeren bir liste.\n    Döndürülen:\n    int: Tüm derslerdeki puanların toplanmasıyla elde edilen toplam puan.\n    >>> calculate_total_score(100,100,100,100,100)\n    500",
      "vi": "Tính tổng điểm cho một học sinh dựa trên điểm số trong các môn học khác nhau.\n    Tham số:\n- subject_scores (list): Một danh sách chứa điểm số cho mỗi môn học.\n    Trả về:\n    int: Tổng điểm đạt được bằng cách cộng điểm số trong tất cả các môn học.\n    >>> calculate_total_score(100,100,100,100,100)\n    500"
    },
    "docstring_bertscore": {
      "es": "0.9899991589452745",
      "arb": "0.9888331986085996",
      "sw": "0.9888331986085996",
      "tr": "0.9758521073168266",
      "vi": "0.9842366929610713"
    }
  },
  {
    "task_id": "C/14",
    "prompt": {
      "es": "#include <assert.h>\n#include <stdio.h>\n#include <string.h>\n/*\nDecodificar una serie de números para revelar el patrón y entender los valores reales \nque representa cada dígito.\n0000=4 8888=8 1234=1 5678=3 9012=2 1357=0 2468=4\n\nParámetros:\n- data_str: Una cadena que representa una serie de números. La longitud no excede 100.\n\nDevuelve:\nint: El resultado de cada cadena de datos correspondiente al lado derecho de la ecuación.\n\nEjemplo de uso:\nassert(decode_numbers(\"0000\") == 4);\n*/\nint decode_numbers(const char* data_str)",
      "arb": "#include <assert.h>\n#include <stdio.h>\n#include <string.h>\n/*\nفك شفرة سلسلة من الأرقام للكشف عن النمط وفهم القيم الفعلية التي يمثلها كل رقم.\n0000=4 8888=8 1234=1 5678=3 9012=2 1357=0 2468=4\n\nالمعلمات:\n- data_str: سلسلة تمثل سلسلة من الأرقام. الطول لا يتجاوز 100.\n\nالإرجاع:\nint: نتيجة كل سلسلة بيانات تتوافق مع الجانب الأيمن من المعادلة.\n\nمثال على الاستخدام:\nassert(decode_numbers(\"0000\") == 4);\n*/\nint decode_numbers(const char* data_str)",
      "sw": "#include <assert.h>\n#include <stdio.h>\n#include <string.h>\n/*\nFasiri mfululizo wa nambari ili kufichua muundo na kuelewa thamani halisi \nkila tarakimu inawakilisha.\n0000=4 8888=8 1234=1 5678=3 9012=2 1357=0 2468=4\n\nVigezo:\n- data_str: Kamba inayowakilisha mfululizo wa nambari. Urefu hauzidi 100.\n\nInarejesha:\nint: Matokeo ya kila kamba ya data inayolingana na upande wa kulia wa mlingano.\n\nMfano wa matumizi:\nassert(decode_numbers(\"0000\") == 4);\n*/\nint decode_numbers(const char* data_str)",
      "tr": "#include <assert.h>\n#include <stdio.h>\n#include <string.h>\n/*\nBir dizi sayıyı çözerek deseni ortaya çıkarın ve her bir rakamın temsil ettiği gerçek \ndeğerleri anlayın.\n0000=4 8888=8 1234=1 5678=3 9012=2 1357=0 2468=4\n\nParametreler:\n- data_str: Bir dizi sayıyı temsil eden bir dize. Uzunluk 100'ü geçmez.\n\nDöndürülenler:\nint: Her bir veri dizisinin, eşitliğin sağ tarafına karşılık gelen sonucu.\n\nÖrnek kullanım:\nassert(decode_numbers(\"0000\") == 4);\n*/\nint decode_numbers(const char* data_str)",
      "vi": "#include <assert.h>\n#include <stdio.h>\n#include <string.h>\n/*\nGiải mã một chuỗi số để tiết lộ mẫu và hiểu các giá trị thực tế\nmỗi chữ số đại diện.\n0000=4 8888=8 1234=1 5678=3 9012=2 1357=0 2468=4\n\nTham số:\n- data_str: Một chuỗi đại diện cho một chuỗi số. Độ dài không vượt quá 100.\n\nTrả về:\nint: Kết quả của mỗi chuỗi dữ liệu tương ứng với phía bên phải của phương trình.\n\nVí dụ sử dụng:\nassert(decode_numbers(\"0000\") == 4);\n*/\nint decode_numbers(const char* data_str)"
    },
    "prompt_bertscore": {
      "es": "0.9868528537096818",
      "arb": "0.9858954552730936",
      "sw": "0.9773483899771623",
      "tr": "0.981052449322701",
      "vi": "0.9857399276847433"
    },
    "canonical_solution": "{\n    int a[] = {1, 0, 0, 0, 1, 0, 1, 0, 2, 1};\n    int ans = 0;\n    for(int i = 0; i < strlen(data_str); i++) {\n        ans += a[data_str[i] - '0'];\n    }\n    return ans;\n}",
    "instruction": {
      "es": "int decode_numbers(const char* data_str)\n{\n    int a[] = {1, 0, 0, 0, 1, 0, 1, 0, 2, 1};\n    int ans = 0;\n    for(int i = 0; i < strlen(data_str); i++) {\n        ans += a[data_str[i] - '0'];\n    }\n    return ans;\n}\n\nProporcione una descripción concisa en lenguaje natural (docstring) del código C en español utilizando como máximo 500 caracteres.",
      "arb": "int decode_numbers(const char* data_str)\n{\n    int a[] = {1, 0, 0, 0, 1, 0, 1, 0, 2, 1};\n    int ans = 0;\n    for(int i = 0; i < strlen(data_str); i++) {\n        ans += a[data_str[i] - '0'];\n    }\n    return ans;\n}\n\nيرجى تقديم وصف موجز بلغة طبيعية (docstring) للكود المكتوب بلغة C باللغة العربية الفصحى، بحيث لا يتجاوز 500 حرف.",
      "sw": "int decode_numbers(const char* data_str)\n{\n    int a[] = {1, 0, 0, 0, 1, 0, 1, 0, 2, 1};\n    int ans = 0;\n    for(int i = 0; i < strlen(data_str); i++) {\n        ans += a[data_str[i] - '0'];\n    }\n    return ans;\n}\n\nToa maelezo mafupi ya lugha ya asili (docstring) ya msimbo wa C kwa Kiswahili kwa kutumia herufi zisizozidi 500.",
      "tr": "int decode_numbers(const char* data_str)\n{\n    int a[] = {1, 0, 0, 0, 1, 0, 1, 0, 2, 1};\n    int ans = 0;\n    for(int i = 0; i < strlen(data_str); i++) {\n        ans += a[data_str[i] - '0'];\n    }\n    return ans;\n}\n\nC kodunun işlevini açıklayan kısa bir doğal dil açıklaması (docstring) sağlayın. Açıklama, en fazla 500 karakter kullanılarak Türkçe olarak yazılmalıdır.",
      "vi": "int decode_numbers(const char* data_str)\n{\n    int a[] = {1, 0, 0, 0, 1, 0, 1, 0, 2, 1};\n    int ans = 0;\n    for(int i = 0; i < strlen(data_str); i++) {\n        ans += a[data_str[i] - '0'];\n    }\n    return ans;\n}\n\nCung cấp mô tả ngắn gọn bằng ngôn ngữ tự nhiên (docstring) của mã C bằng tiếng Việt, sử dụng tối đa 500 ký tự."
    },
    "instruction_bertscore": {
      "es": "0.9687963589217052",
      "arb": "0.8727085148353161",
      "sw": "0.9146175389298671",
      "tr": "0.8827657669182556",
      "vi": "0.946887229263176"
    },
    "level": "",
    "test": "int main() {\n    assert(decode_numbers(\"0000\") == 4);\n    assert(decode_numbers(\"8888\") == 8);\n    assert(decode_numbers(\"1234\") == 1);\n    assert(decode_numbers(\"5678\") == 3);\n    assert(decode_numbers(\"9012\") == 2);\n    assert(decode_numbers(\"1357\") == 0);\n    assert(decode_numbers(\"2468\") == 4);\n\n    // Additional test samples\n    assert(decode_numbers(\"9999\") == 4);\n    assert(decode_numbers(\"1111\") == 0);\n    assert(decode_numbers(\"2222\") == 0);\n    assert(decode_numbers(\"3333\") == 0);\n    assert(decode_numbers(\"4444\") == 4);\n    assert(decode_numbers(\"5555\") == 0);\n    assert(decode_numbers(\"6666\") == 4);\n    assert(decode_numbers(\"7777\") == 0);\n    assert(decode_numbers(\"0001\") == 3);\n    assert(decode_numbers(\"2301\") == 1);\n\n    return 0;\n}",
    "entry_point": "decode_numbers",
    "signature": "int decode_numbers(const char* data_str)",
    "docstring": {
      "es": "Decodificar una serie de números para revelar el patrón y entender los valores reales que representa cada dígito.\n0000=4 8888=8 1234=1 5678=3 9012=2 1357=0 2468=4\n\nParámetros:\n- data_str: Una cadena que representa una serie de números. La longitud no excede 100.\n\nDevuelve:\nint: El resultado de cada cadena de datos correspondiente al lado derecho de la ecuación.\n\nEjemplo de uso:\nassert(decode_numbers(\"0000\") == 4);",
      "arb": "فك سلسلة من الأرقام للكشف عن النمط وفهم القيم الفعلية التي يمثلها كل رقم.\n0000=4 8888=8 1234=1 5678=3 9012=2 1357=0 2468=4\n\nالمعلمات:\n- data_str: سلسلة تمثل مجموعة من الأرقام. الطول لا يتجاوز 100.\n\nالقيم المعادة:\nint: نتيجة كل سلسلة بيانات تتوافق مع الجانب الأيمن من المعادلة.\n\nمثال على الاستخدام:\nassert(decode_numbers(\"0000\") == 4);",
      "sw": "Decode nambari kadhaa ili kufichua muundo na kuelewa thamani halisi ambayo kila tarakimu inawakilisha.\n0000=4 8888=8 1234=1 5678=3 9012=2 1357=0 2468=4\n\nVigezo:\n- data_str: Kamba inayoashiria mfululizo wa nambari. Urefu hauzidi 100.\n\nInarejesha:\nint: Matokeo ya kila kamba ya data inayolingana na upande wa kulia wa usawa.\n\nMfano wa matumizi:\nassert(decode_numbers(\"0000\") == 4);",
      "tr": "Bir dizi sayıyı çözerek deseni ortaya çıkarın ve her bir rakamın temsil ettiği gerçek değerleri anlayın.\n0000=4 8888=8 1234=1 5678=3 9012=2 1357=0 2468=4\n\nParametreler:\n- data_str: Bir dizi sayıyı temsil eden bir string. Uzunluk 100'ü geçmez.\n\nDöndürülenler:\nint: Her bir veri dizisinin denklemin sağ tarafına karşılık gelen sonucu.\n\nÖrnek kullanım:\nassert(decode_numbers(\"0000\") == 4);",
      "vi": "Giải mã một chuỗi số để tiết lộ mô hình và hiểu các giá trị thực mà mỗi chữ số đại diện.\n\nTham số:\n- data_str: Một chuỗi đại diện cho một loạt các số. Độ dài không vượt quá 100.\n\nTrả về:\nint: Kết quả của mỗi chuỗi dữ liệu tương ứng với phía bên phải của phương trình.\n\nVí dụ sử dụng:\nassert(decode_numbers(\"0000\") == 4);"
    },
    "docstring_bertscore": {
      "es": "0.9826973075080508",
      "arb": "0.9688827631374555",
      "sw": "0.9482553953277444",
      "tr": "0.9620089601713621",
      "vi": "0.8444191787075652"
    }
  },
  {
    "task_id": "C/15",
    "prompt": {
      "es": "#include <assert.h>\n#include <stdio.h>\n/*\nCuenta el número de diferentes métodos de coloreado para n cuadrados con m colores,\nconsiderando el requisito de que los cuadrados adyacentes y los primeros/últimos cuadrados\ndeben tener colores diferentes.\n    Args:\n- n (int): El número de cuadrados.\n- m (int): El número de colores.\n    Returns:\n    int: La cuenta de diferentes métodos de coloreado que satisfacen las condiciones especificadas. El resultado es módulo 1000003.\n    >>> count_coloring_methods(1,1)\n    1\n*/\nint count_coloring_methods(int n, int m)",
      "arb": "#include <assert.h>\n#include <stdio.h>\n/*\nيحسب عدد طرق التلوين المختلفة لمربعات n بألوان m،\nمع مراعاة الشرط الذي يتطلب أن تكون المربعات المتجاورة والمربعات الأولى/الأخيرة\nلها ألوان مختلفة.\n    Args:\n- n (int): عدد المربعات.\n- m (int): عدد الألوان.\n    Returns:\n    int: عدد طرق التلوين المختلفة التي تلبي الشروط المحددة. النتيجة تكون موديولو 1000003.\n    >>> count_coloring_methods(1,1)\n    1\n*/\nint count_coloring_methods(int n, int m)",
      "sw": "#include <assert.h>\n#include <stdio.h>\n/*\nInahesabu idadi ya mbinu tofauti za kupaka rangi miraba n kwa rangi m,\nikizingatia hitaji kwamba miraba ya karibu na miraba ya kwanza/mwisho\nlazima iwe na rangi tofauti.\n    Args:\n- n (int): Idadi ya miraba.\n- m (int): Idadi ya rangi.\n    Returns:\n    int: Idadi ya mbinu tofauti za kupaka rangi zinazokidhi masharti maalum. Matokeo ni modulo 1000003.\n    >>> count_coloring_methods(1,1)\n    1\n*/\nint count_coloring_methods(int n, int m)",
      "tr": "#include <assert.h>\n#include <stdio.h>\n/*\nn kare için m renk ile farklı boyama yöntemlerinin sayısını sayar,\nbitişik karelerin ve ilk/son karelerin farklı renklere sahip olması gerektiği şartını dikkate alarak.\n    Args:\n- n (int): Karelerin sayısı.\n- m (int): Renklerin sayısı.\n    Returns:\n    int: Belirtilen koşulları karşılayan farklı boyama yöntemlerinin sayısı. Sonuç 1000003 ile mod alınır.\n    >>> count_coloring_methods(1,1)\n    1\n*/\nint count_coloring_methods(int n, int m)",
      "vi": "#include <assert.h>\n#include <stdio.h>\n/*\nĐếm số lượng phương pháp tô màu khác nhau cho n ô vuông với m màu,\nxét đến yêu cầu rằng các ô vuông liền kề và ô đầu/cuối\nphải có màu khác nhau.\n    Tham số:\n- n (int): Số lượng ô vuông.\n- m (int): Số lượng màu.\n    Trả về:\n    int: Số lượng phương pháp tô màu khác nhau thỏa mãn các điều kiện đã chỉ định. Kết quả là modulo 1000003.\n    >>> count_coloring_methods(1,1)\n    1\n*/\nint count_coloring_methods(int n, int m)"
    },
    "prompt_bertscore": {
      "es": "0.9934418207093711",
      "arb": "0.9664980067827506",
      "sw": "0.9643259835661341",
      "tr": "0.9720187395932343",
      "vi": "0.9677932754974791"
    },
    "canonical_solution": "{\n    int f[1111]; // Array to store results\n    if (n == 1) return m;\n    if (n == 2) return (long long)m * (m - 1) % 1000003;\n    // Initialize the first three elements\n    f[1] = m;\n    f[2] = (long long)m * (m - 1) % 1000003;\n    // Formula derived from the given gold.c code\n    f[3] = (long long)f[2] * (m - 2) % 1000003;\n    for(int i = 4; i <= n; i++) {\n        f[i] = ((long long)f[i - 1] * (m - 2) % 1000003 +\n                (long long)f[i - 2] * (m - 1) % 1000003) % 1000003;\n    }\n    return f[n];\n}",
    "instruction": {
      "es": "int count_coloring_methods(int n, int m)\n{\n    int f[1111]; // Array to store results\n    if (n == 1) return m;\n    if (n == 2) return (long long)m * (m - 1) % 1000003;\n    // Initialize the first three elements\n    f[1] = m;\n    f[2] = (long long)m * (m - 1) % 1000003;\n    // Formula derived from the given gold.c code\n    f[3] = (long long)f[2] * (m - 2) % 1000003;\n    for(int i = 4; i <= n; i++) {\n        f[i] = ((long long)f[i - 1] * (m - 2) % 1000003 +\n                (long long)f[i - 2] * (m - 1) % 1000003) % 1000003;\n    }\n    return f[n];\n}\n\nProporcione una descripción concisa en lenguaje natural (docstring) del código C en español utilizando como máximo 500 caracteres.",
      "arb": "int count_coloring_methods(int n, int m)\n{\n    int f[1111]; // Array to store results\n    if (n == 1) return m;\n    if (n == 2) return (long long)m * (m - 1) % 1000003;\n    // Initialize the first three elements\n    f[1] = m;\n    f[2] = (long long)m * (m - 1) % 1000003;\n    // Formula derived from the given gold.c code\n    f[3] = (long long)f[2] * (m - 2) % 1000003;\n    for(int i = 4; i <= n; i++) {\n        f[i] = ((long long)f[i - 1] * (m - 2) % 1000003 +\n                (long long)f[i - 2] * (m - 1) % 1000003) % 1000003;\n    }\n    return f[n];\n}\n\nيرجى تقديم وصف موجز بلغة طبيعية (docstring) للكود المكتوب بلغة C باللغة العربية الفصحى، بحيث لا يتجاوز 500 حرف.",
      "sw": "int count_coloring_methods(int n, int m)\n{\n    int f[1111]; // Array to store results\n    if (n == 1) return m;\n    if (n == 2) return (long long)m * (m - 1) % 1000003;\n    // Initialize the first three elements\n    f[1] = m;\n    f[2] = (long long)m * (m - 1) % 1000003;\n    // Formula derived from the given gold.c code\n    f[3] = (long long)f[2] * (m - 2) % 1000003;\n    for(int i = 4; i <= n; i++) {\n        f[i] = ((long long)f[i - 1] * (m - 2) % 1000003 +\n                (long long)f[i - 2] * (m - 1) % 1000003) % 1000003;\n    }\n    return f[n];\n}\n\nToa maelezo mafupi ya lugha ya asili (docstring) ya msimbo wa C kwa Kiswahili kwa kutumia herufi zisizozidi 500.",
      "tr": "int count_coloring_methods(int n, int m)\n{\n    int f[1111]; // Array to store results\n    if (n == 1) return m;\n    if (n == 2) return (long long)m * (m - 1) % 1000003;\n    // Initialize the first three elements\n    f[1] = m;\n    f[2] = (long long)m * (m - 1) % 1000003;\n    // Formula derived from the given gold.c code\n    f[3] = (long long)f[2] * (m - 2) % 1000003;\n    for(int i = 4; i <= n; i++) {\n        f[i] = ((long long)f[i - 1] * (m - 2) % 1000003 +\n                (long long)f[i - 2] * (m - 1) % 1000003) % 1000003;\n    }\n    return f[n];\n}\n\nC kodunun işlevini açıklayan kısa bir doğal dil açıklaması (docstring) sağlayın. Açıklama, Türkçe olarak en fazla 500 karakter içermelidir.",
      "vi": "int count_coloring_methods(int n, int m)\n{\n    int f[1111]; // Array to store results\n    if (n == 1) return m;\n    if (n == 2) return (long long)m * (m - 1) % 1000003;\n    // Initialize the first three elements\n    f[1] = m;\n    f[2] = (long long)m * (m - 1) % 1000003;\n    // Formula derived from the given gold.c code\n    f[3] = (long long)f[2] * (m - 2) % 1000003;\n    for(int i = 4; i <= n; i++) {\n        f[i] = ((long long)f[i - 1] * (m - 2) % 1000003 +\n                (long long)f[i - 2] * (m - 1) % 1000003) % 1000003;\n    }\n    return f[n];\n}\n\nCung cấp mô tả ngắn gọn bằng ngôn ngữ tự nhiên (docstring) của mã C bằng tiếng Việt, sử dụng tối đa 500 ký tự."
    },
    "instruction_bertscore": {
      "es": "0.9687963589217052",
      "arb": "0.8727085148353161",
      "sw": "0.9423429634058599",
      "tr": "0.8645904911624201",
      "vi": "0.927643123426992"
    },
    "level": "",
    "test": "int main() {\n    assert(count_coloring_methods(1, 1) == 1);\n    assert(count_coloring_methods(2, 2) == 2);\n    assert(count_coloring_methods(3, 3) == 6);\n    assert(count_coloring_methods(4, 2) == 2);\n    assert(count_coloring_methods(1000, 10) == 566585); // We don't have the expected result for this case\n\n    // Additional test cases\n    assert(count_coloring_methods(2, 3) == 6);\n    assert(count_coloring_methods(1000, 1000) == 67911);\n    assert(count_coloring_methods(999,66) == 501817);\n    assert(count_coloring_methods(5, 3) == 30); // Example of an expected output\n\n    // printf(\"All tests passed!\\n\");\n    return 0;\n}",
    "entry_point": "count_coloring_methods",
    "signature": "int count_coloring_methods(int n, int m)",
    "docstring": {
      "es": "Cuenta el número de diferentes métodos de coloreado para n cuadrados con m colores, considerando el requisito de que los cuadrados adyacentes y los primeros/últimos cuadrados deben tener colores diferentes.\n    Args:\n- n (int): El número de cuadrados.\n- m (int): El número de colores.\n    Returns:\n    int: El conteo de diferentes métodos de coloreado que satisfacen las condiciones especificadas. El resultado es módulo 1000003.\n    >>> count_coloring_methods(1,1)\n    1",
      "arb": "يحسب عدد طرق التلوين المختلفة لمربعات n باستخدام ألوان m، مع مراعاة الشرط الذي ينص على أن المربعات المتجاورة والمربعات الأولى/الأخيرة يجب أن تكون بألوان مختلفة.\n    المعاملات:\n- n (int): عدد المربعات.\n- m (int): عدد الألوان.\n    يعيد:\n    int: عدد طرق التلوين المختلفة التي تلبي الشروط المحددة. النتيجة هي باقي القسمة على 1000003.\n    >>> count_coloring_methods(1,1)\n    1",
      "sw": "Hesabu idadi ya mbinu tofauti za kupaka rangi mraba n kwa rangi m, ukizingatia hitaji kwamba miraba iliyo karibu na mraba wa kwanza/wa mwisho lazima iwe na rangi tofauti.\n    Args:\n- n (int): Idadi ya miraba.\n- m (int): Idadi ya rangi.\n    Returns:\n    int: Idadi ya mbinu tofauti za kupaka rangi zinazokidhi masharti maalum. Matokeo ni modulo 1000003.\n    >>> count_coloring_methods(1,1)\n    1",
      "tr": "n kareyi m renkle boyamak için farklı yöntemlerin sayısını, bitişik karelerin ve ilk/son karelerin farklı renklere sahip olması gerektiği şartını göz önünde bulundurarak sayar.\n    Args:\n- n (int): Karelerin sayısı.\n- m (int): Renklerin sayısı.\n    Returns:\n    int: Belirtilen koşulları karşılayan farklı boyama yöntemlerinin sayısı. Sonuç 1000003 ile mod alınır.\n    >>> count_coloring_methods(1,1)\n    1",
      "vi": "Đếm số lượng phương pháp tô màu khác nhau cho n ô vuông với m màu, xem xét yêu cầu rằng các ô vuông liền kề và ô vuông đầu/cuối phải có màu khác nhau.\n    Tham số:\n- n (int): Số lượng ô vuông.\n- m (int): Số lượng màu.\n    Trả về:\n    int: Số lượng phương pháp tô màu khác nhau thỏa mãn các điều kiện đã chỉ định. Kết quả là modulo 1000003.\n    >>> count_coloring_methods(1,1)\n    1"
    },
    "docstring_bertscore": {
      "es": "0.9866921617314246",
      "arb": "0.9121640564633242",
      "sw": "0.946493742478346",
      "tr": "0.9608120134952459",
      "vi": "0.9662751434952295"
    }
  },
  {
    "task_id": "C/16",
    "prompt": {
      "es": "#include <assert.h>\n#include <math.h>\n#include <stdbool.h>\n#include <stdio.h>\n#include <string.h>\n/*\nCuenta el número de secuencias válidas de lanzamientos de moneda sin caras consecutivas en n lanzamientos.\n    Parámetros:\n- n (int): El número de lanzamientos de moneda.\n    Devuelve:\n    unsigned long long: El conteo de secuencias válidas.\n    >>> count_valid_coin_toss_sequences(1)\n    2\n*/\nunsigned long long count_valid_coin_toss_sequences(int n)",
      "arb": "#include <assert.h>\n#include <math.h>\n#include <stdbool.h>\n#include <stdio.h>\n#include <string.h>\n/*\nاحسب عدد تسلسلات رمي العملة الصحيحة بدون رؤوس متتالية في n رميات.\n    المعلمات:\n- n (int): عدد رميات العملة.\n    يعيد:\n    unsigned long long: عدد التسلسلات الصحيحة.\n    >>> count_valid_coin_toss_sequences(1)\n    2\n*/\nunsigned long long count_valid_coin_toss_sequences(int n)",
      "sw": "#include <assert.h>\n#include <math.h>\n#include <stdbool.h>\n#include <stdio.h>\n#include <string.h>\n/*\nHesabu idadi ya mfuatano halali wa kurusha sarafu bila vichwa mfululizo katika kurusha n.\n    Vigezo:\n- n (int): Idadi ya kurusha sarafu.\n    Inarudisha:\n    unsigned long long: Idadi ya mfuatano halali.\n    >>> count_valid_coin_toss_sequences(1)\n    2\n*/\nunsigned long long count_valid_coin_toss_sequences(int n)",
      "tr": "#include <assert.h>\n#include <math.h>\n#include <stdbool.h>\n#include <stdio.h>\n#include <string.h>\n/*\nArdışık yazı tura atışlarında ardışık turalar olmadan geçerli atış dizilerinin sayısını sayın.\n​    Parametreler:\n- n (int): Yazı tura atışlarının sayısı.\n​    Döndürür:\n​    unsigned long long: Geçerli dizilerin sayısı.\n    >>> count_valid_coin_toss_sequences(1)\n    2\n*/\nunsigned long long count_valid_coin_toss_sequences(int n)",
      "vi": "#include <assert.h>\n#include <math.h>\n#include <stdbool.h>\n#include <stdio.h>\n#include <string.h>\n/*\nĐếm số lượng chuỗi tung đồng xu hợp lệ không có hai mặt ngửa liên tiếp trong n lần tung.\n    Tham số:\n- n (int): Số lần tung đồng xu.\n    Trả về:\n    unsigned long long: Số lượng chuỗi hợp lệ.\n    >>> count_valid_coin_toss_sequences(1)\n    2\n*/\nunsigned long long count_valid_coin_toss_sequences(int n)"
    },
    "prompt_bertscore": {
      "es": "0.9792673580883404",
      "arb": "0.9649184979927612",
      "sw": "0.9649184979927612",
      "tr": "0.9635950237639257",
      "vi": "0.9474116134691082"
    },
    "canonical_solution": "{\n    unsigned long long a[41][2];\n    a[1][0] = a[1][1] = 1;\n    \n    for(int i = 2; i <= n; i++){\n        a[i][0] = a[i - 1][1] + a[i - 1][0];\n        a[i][1] = a[i - 1][0];\n    }\n    \n    return a[n][0] + a[n][1];\n}",
    "instruction": {
      "es": "unsigned long long count_valid_coin_toss_sequences(int n)\n{\n    unsigned long long a[41][2];\n    a[1][0] = a[1][1] = 1;\n    \n    for(int i = 2; i <= n; i++){\n        a[i][0] = a[i - 1][1] + a[i - 1][0];\n        a[i][1] = a[i - 1][0];\n    }\n    \n    return a[n][0] + a[n][1];\n}\n\nProporcione una descripción concisa en lenguaje natural (docstring) del código C en español utilizando como máximo 500 caracteres.",
      "arb": "unsigned long long count_valid_coin_toss_sequences(int n)\n{\n    unsigned long long a[41][2];\n    a[1][0] = a[1][1] = 1;\n    \n    for(int i = 2; i <= n; i++){\n        a[i][0] = a[i - 1][1] + a[i - 1][0];\n        a[i][1] = a[i - 1][0];\n    }\n    \n    return a[n][0] + a[n][1];\n}\n\nيرجى تقديم وصف موجز بلغة طبيعية (docstring) للكود المكتوب بلغة C باللغة العربية الفصحى، بحيث لا يتجاوز 500 حرف.",
      "sw": "unsigned long long count_valid_coin_toss_sequences(int n)\n{\n    unsigned long long a[41][2];\n    a[1][0] = a[1][1] = 1;\n    \n    for(int i = 2; i <= n; i++){\n        a[i][0] = a[i - 1][1] + a[i - 1][0];\n        a[i][1] = a[i - 1][0];\n    }\n    \n    return a[n][0] + a[n][1];\n}\n\nToa maelezo mafupi ya lugha asilia (docstring) ya msimbo wa C kwa Kiswahili kwa kutumia herufi zisizozidi 500.",
      "tr": "unsigned long long count_valid_coin_toss_sequences(int n)\n{\n    unsigned long long a[41][2];\n    a[1][0] = a[1][1] = 1;\n    \n    for(int i = 2; i <= n; i++){\n        a[i][0] = a[i - 1][1] + a[i - 1][0];\n        a[i][1] = a[i - 1][0];\n    }\n    \n    return a[n][0] + a[n][1];\n}\n\nC kodunun işlevini açıklayan kısa bir doğal dil tanımı (docstring) sağlayın. Açıklama, Türkçe olarak en fazla 500 karakter kullanılacak şekilde olmalıdır.",
      "vi": "unsigned long long count_valid_coin_toss_sequences(int n)\n{\n    unsigned long long a[41][2];\n    a[1][0] = a[1][1] = 1;\n    \n    for(int i = 2; i <= n; i++){\n        a[i][0] = a[i - 1][1] + a[i - 1][0];\n        a[i][1] = a[i - 1][0];\n    }\n    \n    return a[n][0] + a[n][1];\n}\n\nCung cấp mô tả ngắn gọn bằng ngôn ngữ tự nhiên (docstring) của mã C bằng tiếng Việt, sử dụng tối đa 500 ký tự."
    },
    "instruction_bertscore": {
      "es": "0.9687963589217052",
      "arb": "0.8727085148353161",
      "sw": "0.9423429634058599",
      "tr": "0.8628683657588477",
      "vi": "0.927643123426992"
    },
    "level": "",
    "test": "int main() {\n    assert(count_valid_coin_toss_sequences(1) == 2);\n    assert(count_valid_coin_toss_sequences(2) == 3);\n    assert(count_valid_coin_toss_sequences(3) == 5);\n    assert(count_valid_coin_toss_sequences(4) == 8); // Additional test\n    assert(count_valid_coin_toss_sequences(5) == 13); // Additional test\n    // Feel free to add more tests here\n    assert(count_valid_coin_toss_sequences(40) == 267914296); // Additional test\n    assert(count_valid_coin_toss_sequences(39) == 165580141); \n    assert(count_valid_coin_toss_sequences(38) == 102334155);\n    // printf(\"All tests passed!\\n\");\n    return 0;\n}",
    "entry_point": "count_valid_coin_toss_sequences",
    "signature": "unsigned long long count_valid_coin_toss_sequences(int n)",
    "docstring": {
      "es": "Cuenta el número de secuencias válidas de lanzamientos de moneda sin caras consecutivas en n lanzamientos.\n    Parámetros:\n- n (int): El número de lanzamientos de moneda.\n​    Devuelve:\n​    unsigned long long: El conteo de secuencias válidas.\n    >>> count_valid_coin_toss_sequences(1)\n    2",
      "arb": "احسب عدد تسلسلات رمي العملة الصحيحة بدون رؤوس متتالية في n رميات.\n    Parameters:\n- n (int): عدد رميات العملة.\n​    Returns:\n​    unsigned long long: عدد التسلسلات الصحيحة.\n    >>> count_valid_coin_toss_sequences(1)\n    2",
      "sw": "Hesabu idadi ya mfuatano halali wa kurusha sarafu bila vichwa mfululizo katika kurusha mara n.\n    Vigezo:\n- n (int): Idadi ya kurusha sarafu.\n​    Inarejesha:\n​    unsigned long long: Idadi ya mfuatano halali.\n    >>> count_valid_coin_toss_sequences(1)\n    2",
      "tr": "n atışında ardışık yazı olmayan geçerli para atışı dizilerinin sayısını sayın.\n    Parametreler:\n    - n (int): Para atışlarının sayısı.\n    Döndürür:\n    unsigned long long: Geçerli dizilerin sayısı.\n    >>> count_valid_coin_toss_sequences(1)\n    2",
      "vi": "Đếm số lượng dãy tung đồng xu hợp lệ mà không có hai mặt ngửa liên tiếp trong n lần tung.\n    Tham số:\n- n (int): Số lần tung đồng xu.\n    Trả về:\n    unsigned long long: Số lượng dãy hợp lệ.\n    >>> count_valid_coin_toss_sequences(1)\n    2"
    },
    "docstring_bertscore": {
      "es": "0.96752472722232",
      "arb": "0.9492968144155103",
      "sw": "0.9553157122216295",
      "tr": "0.927085369317046",
      "vi": "0.9591361689704545"
    }
  },
  {
    "task_id": "C/17",
    "prompt": {
      "es": "#include <assert.h>\n#include <math.h>\n#include <stdbool.h>\n#include <stdio.h>\n#include <string.h>\n/*\nEncuentra la longitud de la secuencia consecutiva más larga de 1s en la representación binaria de un entero no negativo.\n    Parámetros:\n- n (unsigned long long): Un entero no negativo (0 ≤ n ≤ 2^64 - 1).\n    Devuelve:\n    int: La longitud de la secuencia consecutiva más larga de 1s en la representación binaria del entero dado.\n    \n    Ejemplos:\n    >>> find_longest_consecutive_ones_length(7)\n    3\n*/\nint find_longest_consecutive_ones_length(unsigned long long n)",
      "arb": "#include <assert.h>\n#include <math.h>\n#include <stdbool.h>\n#include <stdio.h>\n#include <string.h>\n/*\nإيجاد طول أطول تسلسل متتابع من الأرقام 1 في التمثيل الثنائي لعدد صحيح غير سالب.\nالمعطيات:\n- n (unsigned long long): عدد صحيح غير سالب (0 ≤ n ≤ 2^64 - 1).\nالإرجاع:\nint: طول أطول تسلسل متتابع من الأرقام 1 في التمثيل الثنائي للعدد الصحيح المعطى.\n\nأمثلة:\n>>> find_longest_consecutive_ones_length(7)\n3\n*/\nint find_longest_consecutive_ones_length(unsigned long long n)",
      "sw": "#include <assert.h>\n#include <math.h>\n#include <stdbool.h>\n#include <stdio.h>\n#include <string.h>\n/*\nPata urefu wa mlolongo mrefu zaidi wa 1 katika uwakilishi wa binary wa nambari isiyo hasi.\n​    Vigezo:\n- n (unsigned long long): Nambari isiyo hasi (0 ≤ n ≤ 2^64 - 1).\n​    Inarejesha:\n​    int: Urefu wa mlolongo mrefu zaidi wa 1 katika uwakilishi wa binary wa nambari iliyotolewa.\n​    \n    Mifano:\n    >>> find_longest_consecutive_ones_length(7)\n    3\n*/\nint find_longest_consecutive_ones_length(unsigned long long n)",
      "tr": "#include <assert.h>\n#include <math.h>\n#include <stdbool.h>\n#include <stdio.h>\n#include <string.h>\n/*\nBir negatif olmayan tam sayının ikili gösterimindeki en uzun ardışık 1 dizisinin uzunluğunu bulun.\n​    Parametreler:\n- n (unsigned long long): Negatif olmayan bir tam sayı (0 ≤ n ≤ 2^64 - 1).\n​    Döndürür:\n​    int: Verilen tam sayının ikili gösterimindeki en uzun ardışık 1 dizisinin uzunluğu.\n​    \n    Örnekler:\n    >>> find_longest_consecutive_ones_length(7)\n    3\n*/\nint find_longest_consecutive_ones_length(unsigned long long n)",
      "vi": "#include <assert.h>\n#include <math.h>\n#include <stdbool.h>\n#include <stdio.h>\n#include <string.h>\n/*\nTìm độ dài của dãy liên tiếp dài nhất của các số 1 trong biểu diễn nhị phân của một số nguyên không âm.\n​    Tham số:\n- n (unsigned long long): Một số nguyên không âm (0 ≤ n ≤ 2^64 - 1).\n​    Trả về:\n​    int: Độ dài của dãy liên tiếp dài nhất của các số 1 trong biểu diễn nhị phân của số nguyên đã cho.\n​    \n    Ví dụ:\n    >>> find_longest_consecutive_ones_length(7)\n    3\n*/\nint find_longest_consecutive_ones_length(unsigned long long n)"
    },
    "prompt_bertscore": {
      "es": "0.9811845385260892",
      "arb": "0.9775412600771473",
      "sw": "0.9561092405938638",
      "tr": "0.9811845385260892",
      "vi": "0.9793082759468337"
    },
    "canonical_solution": "{\n    int max = 0;\n    int ans = 0;\n    while(n){\n        if(n & 1)\n            ans++;\n        else{\n            if(ans > max)\n                max = ans;\n            ans = 0;\n        }\n        n >>= 1;\n    }\n    if(ans > max)\n        max = ans;\n    return max;\n}",
    "instruction": {
      "es": "int find_longest_consecutive_ones_length(unsigned long long n)\n{\n    int max = 0;\n    int ans = 0;\n    while(n){\n        if(n & 1)\n            ans++;\n        else{\n            if(ans > max)\n                max = ans;\n            ans = 0;\n        }\n        n >>= 1;\n    }\n    if(ans > max)\n        max = ans;\n    return max;\n}\n\nProporcione una descripción concisa en lenguaje natural (docstring) del código C en español utilizando como máximo 500 caracteres.",
      "arb": "int find_longest_consecutive_ones_length(unsigned long long n)\n{\n    int max = 0;\n    int ans = 0;\n    while(n){\n        if(n & 1)\n            ans++;\n        else{\n            if(ans > max)\n                max = ans;\n            ans = 0;\n        }\n        n >>= 1;\n    }\n    if(ans > max)\n        max = ans;\n    return max;\n}\n\nيرجى تقديم وصف موجز بلغة طبيعية (docstring) للكود المكتوب بلغة C باللغة العربية الفصحى، بحيث لا يتجاوز 500 حرف.",
      "sw": "int find_longest_consecutive_ones_length(unsigned long long n)\n{\n    int max = 0;\n    int ans = 0;\n    while(n){\n        if(n & 1)\n            ans++;\n        else{\n            if(ans > max)\n                max = ans;\n            ans = 0;\n        }\n        n >>= 1;\n    }\n    if(ans > max)\n        max = ans;\n    return max;\n}\n\nToa maelezo mafupi ya lugha ya asili (docstring) ya msimbo wa C kwa Kiswahili kwa kutumia herufi zisizozidi 500.",
      "tr": "int find_longest_consecutive_ones_length(unsigned long long n)\n{\n    int max = 0;\n    int ans = 0;\n    while(n){\n        if(n & 1)\n            ans++;\n        else{\n            if(ans > max)\n                max = ans;\n            ans = 0;\n        }\n        n >>= 1;\n    }\n    if(ans > max)\n        max = ans;\n    return max;\n}\n\nC kodunun işlevini açıklayan kısa bir doğal dil tanımı (docstring) sağlayın. Açıklama en fazla 500 karakter olmalıdır.",
      "vi": "int find_longest_consecutive_ones_length(unsigned long long n)\n{\n    int max = 0;\n    int ans = 0;\n    while(n){\n        if(n & 1)\n            ans++;\n        else{\n            if(ans > max)\n                max = ans;\n            ans = 0;\n        }\n        n >>= 1;\n    }\n    if(ans > max)\n        max = ans;\n    return max;\n}\n\nCung cấp mô tả ngắn gọn bằng ngôn ngữ tự nhiên (docstring) của mã C bằng tiếng Việt, sử dụng tối đa 500 ký tự."
    },
    "instruction_bertscore": {
      "es": "0.9687963589217052",
      "arb": "0.8727085148353161",
      "sw": "0.9146175389298671",
      "tr": "0.8359883121845394",
      "vi": "0.946887229263176"
    },
    "level": "",
    "test": "int main()\n{\n    assert(find_longest_consecutive_ones_length(7) == 3);\n    assert(find_longest_consecutive_ones_length(13) == 2);\n    assert(find_longest_consecutive_ones_length(12345) == 3); // New test sample\n    assert(find_longest_consecutive_ones_length(0b11011101111) == 4); // New test sample using binary literal for clarity\n    assert(find_longest_consecutive_ones_length(0xFFFFFFFF) == 32); // New test sample: all ones for a 32-bit number\n    assert(find_longest_consecutive_ones_length(0) == 0); // New test sample: no ones in a zero\n\n    // printf(\"All tests passed!\\n\");\n    return 0;\n}",
    "entry_point": "find_longest_consecutive_ones_length",
    "signature": "int find_longest_consecutive_ones_length(unsigned long long n)",
    "docstring": {
      "es": "Encontrar la longitud de la secuencia consecutiva más larga de 1s en la representación binaria de un entero no negativo.\n    Parámetros:\n- n (unsigned long long): Un entero no negativo (0 ≤ n ≤ 2^64 - 1).\n    Devuelve:\n    int: La longitud de la secuencia consecutiva más larga de 1s en la representación binaria del entero dado.\n    \n    Ejemplos:\n    >>> find_longest_consecutive_ones_length(7)\n    3",
      "arb": "ابحث عن طول أطول تسلسل متتابع من الأرقام 1 في التمثيل الثنائي لعدد صحيح غير سالب.\n    المعاملات:\n- n (unsigned long long): عدد صحيح غير سالب (0 ≤ n ≤ 2^64 - 1).\n    يعود:\n    int: طول أطول تسلسل متتابع من الأرقام 1 في التمثيل الثنائي للعدد الصحيح المعطى.\n    \n    أمثلة:\n    >>> find_longest_consecutive_ones_length(7)\n    3",
      "sw": "Pata urefu wa mlolongo mrefu zaidi wa 1 mfululizo katika uwakilishi wa binary wa nambari isiyo hasi.\n    Vigezo:\n- n (unsigned long long): Nambari isiyo hasi (0 ≤ n ≤ 2^64 - 1).\n    Inarejesha:\n    int: Urefu wa mlolongo mrefu zaidi wa 1 mfululizo katika uwakilishi wa binary wa nambari iliyotolewa.\n    \n    Mifano:\n    >>> find_longest_consecutive_ones_length(7)\n    3",
      "tr": "Find the length of the longest consecutive sequence of 1s in the binary representation of a non-negative integer.\n    Parametreler:\n- n (unsigned long long): Negatif olmayan bir tam sayı (0 ≤ n ≤ 2^64 - 1).\n    Döndürür:\n    int: Verilen tam sayının ikili gösterimindeki en uzun ardışık 1'ler dizisinin uzunluğu.\n    \n    Örnekler:\n    >>> find_longest_consecutive_ones_length(7)\n    3",
      "vi": "Tìm độ dài của dãy liên tiếp dài nhất của các số 1 trong biểu diễn nhị phân của một số nguyên không âm.\n    Tham số:\n- n (unsigned long long): Một số nguyên không âm (0 ≤ n ≤ 2^64 - 1).\n    Trả về:\n    int: Độ dài của dãy liên tiếp dài nhất của các số 1 trong biểu diễn nhị phân của số nguyên đã cho.\n    \n    Ví dụ:\n    >>> find_longest_consecutive_ones_length(7)\n    3"
    },
    "docstring_bertscore": {
      "es": "1",
      "arb": "1",
      "sw": "0.9613598360861401",
      "tr": "1",
      "vi": "0.9978671069684474"
    }
  },
  {
    "task_id": "C/18",
    "prompt": {
      "es": "#include <stdio.h>\n#include <string.h>\n#include <stdlib.h>\n#include <assert.h>\n/*\nCrea un ID combinando dos palabras de una manera específica.\nParámetros:\n- word1 (char*): La primera palabra que se usará en el ID.\n- word2 (char*): La segunda palabra que se usará en el ID.\nDevuelve:\nchar*: Un ID divino formado invirtiendo cada otro carácter de la segunda \n       palabra y combinándolo con la primera palabra.\np.ej.:\n    >>> create_id(fish,cat)\n\tftiasch\n*/\nchar* create_id(const char* word1, const char* word2)",
      "arb": "#include <stdio.h>\n#include <string.h>\n#include <stdlib.h>\n#include <assert.h>\n/*\nينشئ معرفًا عن طريق دمج كلمتين بطريقة معينة.\nالمعلمات:\n- word1 (char*): الكلمة الأولى المستخدمة في المعرف.\n- word2 (char*): الكلمة الثانية المستخدمة في المعرف.\nيعيد:\nchar*: معرف إلهي يتم تشكيله عن طريق عكس كل حرف آخر من الكلمة الثانية ودمجه مع الكلمة الأولى.\nمثال:\n    >>> create_id(fish,cat)\n\tftiasch\n*/\nchar* create_id(const char* word1, const char* word2)",
      "sw": "#include <stdio.h>\n#include <string.h>\n#include <stdlib.h>\n#include <assert.h>\n/*\nHutengeneza kitambulisho kwa kuchanganya maneno mawili kwa namna maalum.\n​Vigezo:\n- word1 (char*): Neno la kwanza litakalotumika kwenye kitambulisho.\n- word2 (char*): Neno la pili litakalotumika kwenye kitambulisho.\n​Inarudisha:\n​char*: Kitambulisho cha kipekee kinachoundwa kwa kurudisha kila herufi nyingine ya neno la pili \n        na kuichanganya na neno la kwanza.\nmfano:\n    >>> create_id(fish,cat)\n\tftiasch\n*/\nchar* create_id(const char* word1, const char* word2)",
      "tr": "#include <stdio.h>\n#include <string.h>\n#include <stdlib.h>\n#include <assert.h>\n/*\nBelirli bir şekilde iki kelimeyi birleştirerek bir kimlik oluşturur.\nParametreler:\n- word1 (char*): Kimlikte kullanılacak ilk kelime.\n- word2 (char*): Kimlikte kullanılacak ikinci kelime.\nDöndürür:\n​char*: İkinci kelimenin her iki karakterini ters çevirerek ve ilk kelimeyle \n        birleştirerek oluşturulan ilahi bir kimlik.\nÖrnek:\n    >>> create_id(fish,cat)\n\tftiasch\n*/\nchar* create_id(const char* word1, const char* word2)",
      "vi": "#include <stdio.h>\n#include <string.h>\n#include <stdlib.h>\n#include <assert.h>\n/*\nTạo một ID bằng cách kết hợp hai từ theo một cách cụ thể.\nTham số:\n- word1 (char*): Từ đầu tiên được sử dụng trong ID.\n- word2 (char*): Từ thứ hai được sử dụng trong ID.\nTrả về:\nchar*: Một ID thần thánh được tạo bằng cách đảo ngược mỗi ký tự thứ hai của từ thứ hai\n        và kết hợp nó với từ đầu tiên.\nví dụ:\n    >>> create_id(fish,cat)\n\tftiasch\n*/\nchar* create_id(const char* word1, const char* word2)"
    },
    "prompt_bertscore": {
      "es": "0.9734010084148561",
      "arb": "0.9489253756029751",
      "sw": "0.9384027325372708",
      "tr": "0.9586638259243535",
      "vi": "0.9319396971991576"
    },
    "canonical_solution": "{\n    int length1 = strlen(word1);\n    int length2 = strlen(word2);\n    int total_length = length1 + length2;\n    char* id = malloc(sizeof(char) * (total_length + 1)); // +1 for the null-terminator\n\n    for (int i = 0, j = 0, k = length2 - 1; i < total_length; ++i) {\n        if (i & 1) {\n            id[i] = word2[k--]; // Take character from word2 in reverse\n        } else {\n            id[i] = word1[j++]; // Take character from word1\n        }\n    }\n    \n    id[total_length] = '\\0'; // Null-terminate the string\n    return id;\n}",
    "instruction": {
      "es": "char* create_id(const char* word1, const char* word2)\n{\n    int length1 = strlen(word1);\n    int length2 = strlen(word2);\n    int total_length = length1 + length2;\n    char* id = malloc(sizeof(char) * (total_length + 1)); // +1 for the null-terminator\n\n    for (int i = 0, j = 0, k = length2 - 1; i < total_length; ++i) {\n        if (i & 1) {\n            id[i] = word2[k--]; // Take character from word2 in reverse\n        } else {\n            id[i] = word1[j++]; // Take character from word1\n        }\n    }\n    \n    id[total_length] = '\\0'; // Null-terminate the string\n    return id;\n}\n\nProporcione una descripción concisa en lenguaje natural (docstring) del código C en español utilizando un máximo de 500 caracteres.",
      "arb": "char* create_id(const char* word1, const char* word2)\n{\n    int length1 = strlen(word1);\n    int length2 = strlen(word2);\n    int total_length = length1 + length2;\n    char* id = malloc(sizeof(char) * (total_length + 1)); // +1 for the null-terminator\n\n    for (int i = 0, j = 0, k = length2 - 1; i < total_length; ++i) {\n        if (i & 1) {\n            id[i] = word2[k--]; // Take character from word2 in reverse\n        } else {\n            id[i] = word1[j++]; // Take character from word1\n        }\n    }\n    \n    id[total_length] = '\\0'; // Null-terminate the string\n    return id;\n}\n\nيرجى تقديم وصف موجز بلغة طبيعية (docstring) للكود المكتوب بلغة C باللغة العربية الفصحى، بحيث لا يتجاوز 500 حرف.",
      "sw": "char* create_id(const char* word1, const char* word2)\n{\n    int length1 = strlen(word1);\n    int length2 = strlen(word2);\n    int total_length = length1 + length2;\n    char* id = malloc(sizeof(char) * (total_length + 1)); // +1 for the null-terminator\n\n    for (int i = 0, j = 0, k = length2 - 1; i < total_length; ++i) {\n        if (i & 1) {\n            id[i] = word2[k--]; // Take character from word2 in reverse\n        } else {\n            id[i] = word1[j++]; // Take character from word1\n        }\n    }\n    \n    id[total_length] = '\\0'; // Null-terminate the string\n    return id;\n}\n\nToa maelezo mafupi ya lugha ya asili (docstring) ya msimbo wa C kwa Kiswahili kwa kutumia herufi zisizozidi 500.",
      "tr": "char* create_id(const char* word1, const char* word2)\n{\n    int length1 = strlen(word1);\n    int length2 = strlen(word2);\n    int total_length = length1 + length2;\n    char* id = malloc(sizeof(char) * (total_length + 1)); // +1 for the null-terminator\n\n    for (int i = 0, j = 0, k = length2 - 1; i < total_length; ++i) {\n        if (i & 1) {\n            id[i] = word2[k--]; // Take character from word2 in reverse\n        } else {\n            id[i] = word1[j++]; // Take character from word1\n        }\n    }\n    \n    id[total_length] = '\\0'; // Null-terminate the string\n    return id;\n}\n\nC kodunun işlevini açıklayan kısa bir doğal dil tanımı (docstring) sağlayın. Açıklama 500 karakteri geçmemelidir.",
      "vi": "char* create_id(const char* word1, const char* word2)\n{\n    int length1 = strlen(word1);\n    int length2 = strlen(word2);\n    int total_length = length1 + length2;\n    char* id = malloc(sizeof(char) * (total_length + 1)); // +1 for the null-terminator\n\n    for (int i = 0, j = 0, k = length2 - 1; i < total_length; ++i) {\n        if (i & 1) {\n            id[i] = word2[k--]; // Take character from word2 in reverse\n        } else {\n            id[i] = word1[j++]; // Take character from word1\n        }\n    }\n    \n    id[total_length] = '\\0'; // Null-terminate the string\n    return id;\n}\n\nCung cấp mô tả ngắn gọn bằng ngôn ngữ tự nhiên (docstring) của mã C bằng tiếng Việt, sử dụng tối đa 500 ký tự."
    },
    "instruction_bertscore": {
      "es": "0.9687963589217052",
      "arb": "0.8727085148353161",
      "sw": "0.9146175389298671",
      "tr": "0.8407240577291731",
      "vi": "0.927643123426992"
    },
    "level": "",
    "test": "int main() {\n    char* id; // To hold the results from create_id\n\n    id = create_id(\"fish\", \"cat\");\n    assert(strcmp(id, \"ftiasch\") == 0);\n    free(id);\n\n    id = create_id(\"icpc\", \"acm\");\n    assert(strcmp(id, \"imccpac\") == 0);\n    free(id);\n\n    id = create_id(\"oo\", \"w\");\n    assert(strcmp(id, \"owo\") == 0);\n    free(id);\n\n    // Add more test samples\n    id = create_id(\"hello\", \"world\");\n    assert(strcmp(id, \"hdellrloow\") == 0);\n    free(id);\n\n    id = create_id(\"abc\", \"def\");\n    assert(strcmp(id, \"afbecd\") == 0);\n    free(id);\n\n    id = create_id(\"buaanb\", \"nbbuaa\");\n    assert(strcmp(id, \"bauaauabnbbn\") == 0);\n    free(id);\n\n    id = create_id(\"xtuisgood\", \"ilovextu\");\n    assert(strcmp(id, \"xuttuxiesvgooloid\") == 0);\n    free(id);\n\n    return 0;\n}",
    "entry_point": "create_id",
    "signature": "char* create_id(const char* word1, const char* word2)",
    "docstring": {
      "es": "Crea un ID combinando dos palabras de una manera específica.\nParámetros:\n- word1 (char*): La primera palabra que se utilizará en el ID.\n- word2 (char*): La segunda palabra que se utilizará en el ID.\nDevuelve:\nchar*: Un ID divino formado al invertir cada otro carácter de la segunda palabra y combinarlo con la primera palabra.\ne.g.:\n    >>> create_id(fish,cat)\n    ftiasch",
      "arb": "ينشئ معرفًا عن طريق دمج كلمتين بطريقة محددة.\nالمعلمات:\n- word1 (char*): الكلمة الأولى التي سيتم استخدامها في المعرف.\n- word2 (char*): الكلمة الثانية التي سيتم استخدامها في المعرف.\nالقيم المعادة:\nchar*: معرف إلهي يتكون من عكس كل حرف آخر من الكلمة الثانية ودمجه مع الكلمة الأولى.\nمثال:\n    >>> create_id(fish,cat)\n    ftiasch",
      "sw": "Huumba kitambulisho kwa kuchanganya maneno mawili kwa njia maalum.  \nVigezo:  \n- word1 (char*): Neno la kwanza litakalotumika kwenye kitambulisho.  \n- word2 (char*): Neno la pili litakalotumika kwenye kitambulisho.  \nRudisha:  \nchar*: Kitambulisho cha kipekee kinachoundwa kwa kubadilisha mpangilio wa kila herufi nyingine ya neno la pili na kuichanganya na neno la kwanza.  \nmfano:  \n    >>> create_id(fish,cat)  \n    ftiasch  ",
      "tr": "Belirli bir şekilde iki kelimeyi birleştirerek bir kimlik oluşturur.\nParametreler:\n- word1 (char*): Kimlikte kullanılacak ilk kelime.\n- word2 (char*): Kimlikte kullanılacak ikinci kelime.\nDöndürür:\nchar*: İkinci kelimenin her iki karakterini ters çevirerek ve ilk kelimeyle birleştirerek oluşturulan ilahi bir kimlik.\nörneğin:\n    >>> create_id(fish,cat)\n    ftiasch",
      "vi": "Tạo một ID bằng cách kết hợp hai từ theo một cách cụ thể.  \nTham số:  \n- word1 (char*): Từ đầu tiên được sử dụng trong ID.  \n- word2 (char*): Từ thứ hai được sử dụng trong ID.  \nTrả về:  \nchar*: Một ID thần thánh được tạo ra bằng cách đảo ngược mỗi ký tự khác của từ thứ hai và kết hợp với từ đầu tiên.  \nví dụ:  \n    >>> create_id(fish,cat)  \n    ftiasch  "
    },
    "docstring_bertscore": {
      "es": "0.9909003449840297",
      "arb": "0.9505279255171646",
      "sw": "0.9292540158171849",
      "tr": "0.9403217006484489",
      "vi": "0.9569248169383932"
    }
  },
  {
    "task_id": "C/19",
    "prompt": {
      "es": "#include <assert.h>\n#include <math.h>\n#include <stdbool.h>\n#include <stdio.h>\n#include <string.h>\n/*\nCuenta el número de diferentes esquemas de permutación para una cadena binaria de longitud n,\ndonde el número de '1's es m y el número de '0's es n - m.\n    Parámetros:\n- n (int): Longitud de la cadena binaria.\n- m (int): Número de '1's en la cadena binaria.\n    Devuelve:\n    int: El número total de diferentes esquemas de permutación.\n*/\nint count_permutations_of_binary_string(int n, int m)",
      "arb": "#include <assert.h>\n#include <math.h>\n#include <stdbool.h>\n#include <stdio.h>\n#include <string.h>\n/*\nاحسب عدد مخططات التبديل المختلفة لسلسلة ثنائية بطول n،\nحيث أن عدد '1's هو m وعدد '0's هو n - m.\n​    المعاملات:\n- n (int): طول السلسلة الثنائية.\n- m (int): عدد '1's في السلسلة الثنائية.\n​    يعيد:\n​    int: العدد الإجمالي لمخططات التبديل المختلفة.\n*/\nint count_permutations_of_binary_string(int n, int m)",
      "sw": "#include <assert.h>\n#include <math.h>\n#include <stdbool.h>\n#include <stdio.h>\n#include <string.h>\n/*\nHesabu idadi ya mipango tofauti ya mpangilio kwa kamba ya binary yenye urefu n,\nambapo idadi ya '1's ni m na idadi ya '0's ni n - m.\n​    Vigezo:\n- n (int): Urefu wa kamba ya binary.\n- m (int): Idadi ya '1's katika kamba ya binary.\n​    Inarudisha:\n​    int: Jumla ya idadi ya mipango tofauti ya mpangilio.\n*/\nint count_permutations_of_binary_string(int n, int m)",
      "tr": "#include <assert.h>\n#include <math.h>\n#include <stdbool.h>\n#include <stdio.h>\n#include <string.h>\n/*\nUzunluğu n olan bir ikili dizge için, '1'lerin sayısının m ve '0'ların sayısının n - m olduğu farklı permütasyon şemalarının sayısını sayın.\n    Parametreler:\n- n (int): İkili dizgenin uzunluğu.\n- m (int): İkili dizgedeki '1'lerin sayısı.\n    Döndürür:\n    int: Farklı permütasyon şemalarının toplam sayısı.\n*/\nint count_permutations_of_binary_string(int n, int m)",
      "vi": "#include <assert.h>\n#include <math.h>\n#include <stdbool.h>\n#include <stdio.h>\n#include <string.h>\n/*\nĐếm số lượng các sơ đồ hoán vị khác nhau cho một chuỗi nhị phân có độ dài n,\ntrong đó số lượng '1' là m và số lượng '0' là n - m.\n    Tham số:\n- n (int): Độ dài của chuỗi nhị phân.\n- m (int): Số lượng '1' trong chuỗi nhị phân.\n    Trả về:\n    int: Tổng số lượng các sơ đồ hoán vị khác nhau.\n*/\nint count_permutations_of_binary_string(int n, int m)"
    },
    "prompt_bertscore": {
      "es": "0.9852381873422492",
      "arb": "0.9813752236918827",
      "sw": "0.950052603015348",
      "tr": "0.973566070261496",
      "vi": "0.9833500069401315"
    },
    "canonical_solution": "{\n    double factorial = 1.0;\n    int i;\n\n    // Calculate n factorial (n!)\n    for (i = 2; i <= n; ++i) {\n        factorial *= i;\n    }\n\n    double numerator = factorial; // n!\n\n    // Calculate (n+m)/2 factorial\n    factorial = 1.0;\n    for (i = 2; i <= (n + m) / 2; ++i) {\n        factorial *= i;\n    }\n\n    double denominator1 = factorial; // ((n+m)/2)!\n\n    // Calculate (n-m)/2 factorial\n    factorial = 1.0;\n    for (i = 2; i <= (n - m) / 2; ++i) {\n        factorial *= i;\n    }\n\n    double denominator2 = factorial; // ((n-m)/2)!\n\n    // printf(\"%f %f %f\\n\", numerator, denominator1, denominator2);\n\n\n    if ((n + m) & 1) {\n        return 0;\n    } else if (n == m) {\n        return 1;\n    } else {\n        // printf(\"%f\\n\", numerator / denominator1 / denominator2);\n        // Calculating the number of permutations using the factorial values\n        return (int)(numerator / denominator1 / denominator2 + 0.5);\n    }\n}",
    "instruction": {
      "es": "int count_permutations_of_binary_string(int n, int m)\n{\n    double factorial = 1.0;\n    int i;\n\n    // Calculate n factorial (n!)\n    for (i = 2; i <= n; ++i) {\n        factorial *= i;\n    }\n\n    double numerator = factorial; // n!\n\n    // Calculate (n+m)/2 factorial\n    factorial = 1.0;\n    for (i = 2; i <= (n + m) / 2; ++i) {\n        factorial *= i;\n    }\n\n    double denominator1 = factorial; // ((n+m)/2)!\n\n    // Calculate (n-m)/2 factorial\n    factorial = 1.0;\n    for (i = 2; i <= (n - m) / 2; ++i) {\n        factorial *= i;\n    }\n\n    double denominator2 = factorial; // ((n-m)/2)!\n\n    // printf(\"%f %f %f\\n\", numerator, denominator1, denominator2);\n\n\n    if ((n + m) & 1) {\n        return 0;\n    } else if (n == m) {\n        return 1;\n    } else {\n        // printf(\"%f\\n\", numerator / denominator1 / denominator2);\n        // Calculating the number of permutations using the factorial values\n        return (int)(numerator / denominator1 / denominator2 + 0.5);\n    }\n}\n\nProporcione una descripción concisa en lenguaje natural (docstring) del código C en español utilizando como máximo 500 caracteres.",
      "arb": "int count_permutations_of_binary_string(int n, int m)\n{\n    double factorial = 1.0;\n    int i;\n\n    // Calculate n factorial (n!)\n    for (i = 2; i <= n; ++i) {\n        factorial *= i;\n    }\n\n    double numerator = factorial; // n!\n\n    // Calculate (n+m)/2 factorial\n    factorial = 1.0;\n    for (i = 2; i <= (n + m) / 2; ++i) {\n        factorial *= i;\n    }\n\n    double denominator1 = factorial; // ((n+m)/2)!\n\n    // Calculate (n-m)/2 factorial\n    factorial = 1.0;\n    for (i = 2; i <= (n - m) / 2; ++i) {\n        factorial *= i;\n    }\n\n    double denominator2 = factorial; // ((n-m)/2)!\n\n    // printf(\"%f %f %f\\n\", numerator, denominator1, denominator2);\n\n\n    if ((n + m) & 1) {\n        return 0;\n    } else if (n == m) {\n        return 1;\n    } else {\n        // printf(\"%f\\n\", numerator / denominator1 / denominator2);\n        // Calculating the number of permutations using the factorial values\n        return (int)(numerator / denominator1 / denominator2 + 0.5);\n    }\n}\n\nيرجى تقديم وصف موجز بلغة طبيعية (docstring) للكود المكتوب بلغة C باللغة العربية الفصحى، بحيث لا يتجاوز 500 حرف.",
      "sw": "int count_permutations_of_binary_string(int n, int m)\n{\n    double factorial = 1.0;\n    int i;\n\n    // Calculate n factorial (n!)\n    for (i = 2; i <= n; ++i) {\n        factorial *= i;\n    }\n\n    double numerator = factorial; // n!\n\n    // Calculate (n+m)/2 factorial\n    factorial = 1.0;\n    for (i = 2; i <= (n + m) / 2; ++i) {\n        factorial *= i;\n    }\n\n    double denominator1 = factorial; // ((n+m)/2)!\n\n    // Calculate (n-m)/2 factorial\n    factorial = 1.0;\n    for (i = 2; i <= (n - m) / 2; ++i) {\n        factorial *= i;\n    }\n\n    double denominator2 = factorial; // ((n-m)/2)!\n\n    // printf(\"%f %f %f\\n\", numerator, denominator1, denominator2);\n\n\n    if ((n + m) & 1) {\n        return 0;\n    } else if (n == m) {\n        return 1;\n    } else {\n        // printf(\"%f\\n\", numerator / denominator1 / denominator2);\n        // Calculating the number of permutations using the factorial values\n        return (int)(numerator / denominator1 / denominator2 + 0.5);\n    }\n}\n\nToa maelezo mafupi ya lugha ya asili (docstring) ya msimbo wa C kwa Kiswahili kwa kutumia herufi zisizozidi 500.",
      "tr": "int count_permutations_of_binary_string(int n, int m)\n{\n    double factorial = 1.0;\n    int i;\n\n    // Calculate n factorial (n!)\n    for (i = 2; i <= n; ++i) {\n        factorial *= i;\n    }\n\n    double numerator = factorial; // n!\n\n    // Calculate (n+m)/2 factorial\n    factorial = 1.0;\n    for (i = 2; i <= (n + m) / 2; ++i) {\n        factorial *= i;\n    }\n\n    double denominator1 = factorial; // ((n+m)/2)!\n\n    // Calculate (n-m)/2 factorial\n    factorial = 1.0;\n    for (i = 2; i <= (n - m) / 2; ++i) {\n        factorial *= i;\n    }\n\n    double denominator2 = factorial; // ((n-m)/2)!\n\n    // printf(\"%f %f %f\\n\", numerator, denominator1, denominator2);\n\n\n    if ((n + m) & 1) {\n        return 0;\n    } else if (n == m) {\n        return 1;\n    } else {\n        // printf(\"%f\\n\", numerator / denominator1 / denominator2);\n        // Calculating the number of permutations using the factorial values\n        return (int)(numerator / denominator1 / denominator2 + 0.5);\n    }\n}\n\nC kodunun işlevini açıklayan kısa bir doğal dil açıklaması (docstring) sağlayın. Açıklama, en fazla 500 karakter kullanılarak Türkçe olarak yazılmalıdır.",
      "vi": "int count_permutations_of_binary_string(int n, int m)\n{\n    double factorial = 1.0;\n    int i;\n\n    // Calculate n factorial (n!)\n    for (i = 2; i <= n; ++i) {\n        factorial *= i;\n    }\n\n    double numerator = factorial; // n!\n\n    // Calculate (n+m)/2 factorial\n    factorial = 1.0;\n    for (i = 2; i <= (n + m) / 2; ++i) {\n        factorial *= i;\n    }\n\n    double denominator1 = factorial; // ((n+m)/2)!\n\n    // Calculate (n-m)/2 factorial\n    factorial = 1.0;\n    for (i = 2; i <= (n - m) / 2; ++i) {\n        factorial *= i;\n    }\n\n    double denominator2 = factorial; // ((n-m)/2)!\n\n    // printf(\"%f %f %f\\n\", numerator, denominator1, denominator2);\n\n\n    if ((n + m) & 1) {\n        return 0;\n    } else if (n == m) {\n        return 1;\n    } else {\n        // printf(\"%f\\n\", numerator / denominator1 / denominator2);\n        // Calculating the number of permutations using the factorial values\n        return (int)(numerator / denominator1 / denominator2 + 0.5);\n    }\n}\n\nCung cấp mô tả ngắn gọn bằng ngôn ngữ tự nhiên (docstring) của mã C bằng tiếng Việt, sử dụng tối đa 500 ký tự."
    },
    "instruction_bertscore": {
      "es": "0.9687963589217052",
      "arb": "0.8727085148353161",
      "sw": "0.9146175389298671",
      "tr": "0.8559035900782404",
      "vi": "0.927643123426992"
    },
    "level": "",
    "test": "int main() {\n    // printf(\"%d\\n\", count_permutations_of_binary_string(2, 0));\n    assert(count_permutations_of_binary_string(2, 0) == 2);\n    assert(count_permutations_of_binary_string(2, 1) == 0);\n    assert(count_permutations_of_binary_string(3, 0) == 0);\n    assert(count_permutations_of_binary_string(3, 1) == 3);\n    assert(count_permutations_of_binary_string(3, 2) == 0);\n    assert(count_permutations_of_binary_string(30, 2) == 145422675);\n    assert(count_permutations_of_binary_string(4, 2) == 4);\n    assert(count_permutations_of_binary_string(5, 5) == 1);\n    assert(count_permutations_of_binary_string(33, 17) == 13884156);\n    assert(count_permutations_of_binary_string(1000, 1000) == 1);\n    // Add more test cases if necessary\n    return 0;\n}",
    "entry_point": "count_permutations_of_binary_string",
    "signature": "int count_permutations_of_binary_string(int n, int m)",
    "docstring": {
      "es": "Cuenta el número de diferentes esquemas de permutación para una cadena binaria de longitud n, donde el número de '1's es m y el número de '0's es n - m.\n    Parámetros:\n- n (int): Longitud de la cadena binaria.\n- m (int): Número de '1's en la cadena binaria.\n    Devuelve:\n    int: El número total de diferentes esquemas de permutación.",
      "arb": "احسب عدد مخططات التبديل المختلفة لسلسلة ثنائية بطول n، حيث يكون عدد '1's هو m وعدد '0's هو n - m.\n    المعلمات:\n- n (int): طول السلسلة الثنائية.\n- m (int): عدد '1's في السلسلة الثنائية.\n    يعيد:\n    int: العدد الإجمالي لمخططات التبديل المختلفة.",
      "sw": "Hesabu idadi ya mpangilio tofauti wa mpangilio kwa kamba ya binary yenye urefu n, ambapo idadi ya '1' ni m na idadi ya '0' ni n - m.\n​    Vigezo:\n- n (int): Urefu wa kamba ya binary.\n- m (int): Idadi ya '1' katika kamba ya binary.\n​    Inarudisha:\n​    int: Jumla ya idadi ya mpangilio tofauti wa mpangilio.",
      "tr": "İkili bir dizginin uzunluğu n olan ve '1'lerin sayısı m, '0'ların sayısı n - m olan farklı permütasyon şemalarının sayısını sayın.\n\nParametreler:\n- n (int): İkili dizginin uzunluğu.\n- m (int): İkili dizgideki '1'lerin sayısı.\n\nDöndürür:\nint: Farklı permütasyon şemalarının toplam sayısı.",
      "vi": "Đếm số lượng các sơ đồ hoán vị khác nhau cho một chuỗi nhị phân có độ dài n, trong đó số lượng '1' là m và số lượng '0' là n - m.\n\n    Tham số:\n    - n (int): Độ dài của chuỗi nhị phân.\n    - m (int): Số lượng '1' trong chuỗi nhị phân.\n\n    Trả về:\n    int: Tổng số lượng các sơ đồ hoán vị khác nhau."
    },
    "docstring_bertscore": {
      "es": "0.9778286782385047",
      "arb": "0.9674528230243853",
      "sw": "0.9477733193929727",
      "tr": "0.9714298005134658",
      "vi": "0.9790009947473727"
    }
  },
  {
    "task_id": "C/20",
    "prompt": {
      "es": "#include <assert.h>\n#include <math.h>\n#include <stdbool.h>\n#include <stdio.h>\n#include <string.h>\n/*\n​    Responder a una serie de preguntas proporcionando opciones A, B, C o D para cada pregunta.\n​    Pregunta 1:\n​    ¿A qué tipo de datos pertenecen las constantes como 1e6?\n​        A. unsigned int\n​        B. int\n​        C. float\n​        D. double\n​    Pregunta 2:\n​    Dado 21! = 51,090,942,171,709,440,000, ¿qué tipo de datos se puede usar para almacenar este valor?\n​        A. int\n​        B. long long\n​        C. double\n​        D. Ninguna de las anteriores\n​    Pregunta 3:\n​    ¿Qué afirmación sobre los valores a la izquierda en las expresiones es incorrecta?\n​        A. Las expresiones de nombres de variables son valores a la izquierda.\n​        B. La operación de incremento requiere que el operando sea un valor a la izquierda.\n​        C. Las expresiones de desreferencia de punteros son valores a la izquierda.\n​        D. Las expresiones de operación de incremento prefijo son valores a la izquierda.\n​    Pregunta 4:\n​    ¿Qué afirmación sobre las funciones es incorrecta?\n​        A. Los parámetros formales de una función son variables locales.\n​        B. Las variables locales se asignan espacio en la pila.\n​        C. El tipo de la función es el mismo que el tipo de valor de retorno.\n​        D. Una función puede llamarse a sí misma desde dentro de su cuerpo.\n​    Pregunta 5:\n​    ¿Qué afirmación sobre los punteros es incorrecta?\n​        A. Restar dos punteros equivale a la diferencia en sus valores de dirección.\n​        B. La desreferencia de puntero implica resolver en función del tipo del puntero.\n​        C. int *p[4], p es un arreglo de punteros a int.\n​        D. Los nombres de funciones se pueden asignar a punteros de funciones.\n\t>>> answer_questions()\n\tAAAAA\nSe supone que solo debes devolver cadenas similares a \"AAAAA\", que representan las opciones de la pregunta.\n*/\nconst char* answer_questions()",
      "arb": "#include <assert.h>\n#include <math.h>\n#include <stdbool.h>\n#include <stdio.h>\n#include <string.h>\n/*\n​    أجب عن سلسلة من الأسئلة بتقديم الخيارات A، B، C، أو D لكل سؤال.\n​    السؤال 1:\n​    الثوابت مثل 1e6 تنتمي إلى أي نوع من البيانات؟\n​        A. unsigned int\n​        B. int\n​        C. float\n​        D. double\n​    السؤال 2:\n​    بالنظر إلى 21! = 51,090,942,171,709,440,000، أي نوع من البيانات يمكن استخدامه لتخزين هذه القيمة؟\n​        A. int\n​        B. long long\n​        C. double\n​        D. لا شيء مما سبق\n​    السؤال 3:\n​    أي عبارة عن القيم اليسرى في التعبيرات غير صحيحة؟\n​        A. تعبيرات أسماء المتغيرات هي قيم يسرى.\n​        B. عملية الزيادة تتطلب أن يكون المعامل قيمة يسرى.\n​        C. تعبيرات إلغاء الإشارة للمؤشر هي قيم يسرى.\n​        D. تعبيرات عملية الزيادة المسبقة هي قيم يسرى.\n​    السؤال 4:\n​    أي عبارة عن الدوال غير صحيحة؟\n​        A. المعاملات الشكلية للدالة هي متغيرات محلية.\n​        B. يتم تخصيص مساحة للمتغيرات المحلية في المكدس.\n​        C. نوع الدالة هو نفسه نوع قيمة الإرجاع.\n​        D. يمكن للدالة أن تستدعي نفسها من داخل جسمها.\n​    السؤال 5:\n​    أي عبارة عن المؤشرات غير صحيحة؟\n​        A. طرح مؤشرين يساوي الفرق في قيم عناوينهما.\n​        B. إلغاء إشارة المؤشر يتضمن الحل بناءً على نوع المؤشر.\n​        C. int *p[4]، p هو مصفوفة من مؤشرات int.\n​        D. يمكن تعيين أسماء الدوال إلى مؤشرات الدوال.\n\t>>> answer_questions()\n\tAAAAA\nمن المفترض أن تعيد فقط سلاسل مشابهة لـ \"AAAAA\"، والتي تمثل اختيارات السؤال.\n*/\nconst char* answer_questions()",
      "sw": "#include <assert.h>\n#include <math.h>\n#include <stdbool.h>\n#include <stdio.h>\n#include <string.h>\n/*\n​    Jibu mfululizo wa maswali kwa kutoa chaguo A, B, C, au D kwa kila swali.\n​    Swali la 1:\n​    Vigezo kama 1e6 vinatoka kwa aina gani ya data?\n​        A. unsigned int\n​        B. int\n​        C. float\n​        D. double\n​    Swali la 2:\n​    Ikitolewa 21! = 51,090,942,171,709,440,000, ni aina gani ya data inaweza kutumika kuhifadhi thamani hii?\n​        A. int\n​        B. long long\n​        C. double\n​        D. Hakuna kati ya hapo juu\n​    Swali la 3:\n​    Ni kauli gani kuhusu thamani za kushoto katika maelezo si sahihi?\n​        A. Maelezo ya jina la kigezo ni thamani za kushoto.\n​        B. Operesheni ya kuongeza inahitaji operand kuwa thamani ya kushoto.\n​        C. Maelezo ya kufuta pointer ni thamani za kushoto.\n​        D. Maelezo ya operesheni ya kuongeza awali ni thamani za kushoto.\n​    Swali la 4:\n​    Ni kauli gani kuhusu kazi si sahihi?\n​        A. Vigezo rasmi vya kazi ni vigezo vya ndani.\n​        B. Vigezo vya ndani vinapewa nafasi katika stack.\n​        C. Aina ya kazi ni sawa na aina ya thamani ya kurudi.\n​        D. Kazi inaweza kujirejelea yenyewe kutoka ndani ya mwili wake.\n​    Swali la 5:\n​    Ni kauli gani kuhusu pointers si sahihi?\n​        A. Kutoa tofauti ya anwani za pointers mbili ni sawa na kutoa tofauti katika thamani zao za anwani.\n​        B. Kufuta pointer kunahusisha kutatua kulingana na aina ya pointer.\n​        C. int *p[4], p ni safu ya pointers za int.\n​        D. Majina ya kazi yanaweza kupewa pointers za kazi.\n\t>>> answer_questions()\n\tAAAAA\nUnatakiwa kurudisha tu misururu inayofanana na \"AAAAA\", ambayo inawakilisha chaguo za swali.\n*/\nconst char* answer_questions()",
      "tr": "#include <assert.h>\n#include <math.h>\n#include <stdbool.h>\n#include <stdio.h>\n#include <string.h>\n/*\n​    Her bir soru için A, B, C veya D seçeneklerini sağlayarak bir dizi soruyu yanıtlayın.\n​    Soru 1:\n​    1e6 gibi sabitler hangi veri türüne aittir?\n​        A. unsigned int\n​        B. int\n​        C. float\n​        D. double\n​    Soru 2:\n​    21! = 51,090,942,171,709,440,000 verildiğinde, bu değeri saklamak için hangi veri türü kullanılabilir?\n​        A. int\n​        B. long long\n​        C. double\n​        D. Yukarıdakilerin hiçbiri\n​    Soru 3:\n​    İfadelerdeki sol değerler hakkında hangi ifade yanlıştır?\n​        A. Değişken adı ifadeleri sol değerlerdir.\n​        B. Artırma işlemi, operandın bir sol değer olmasını gerektirir.\n​        C. İşaretçi dereference ifadeleri sol değerlerdir.\n​        D. Ön ek artırma işlemi ifadeleri sol değerlerdir.\n​    Soru 4:\n​    Fonksiyonlar hakkında hangi ifade yanlıştır?\n​        A. Bir fonksiyonun resmi parametreleri yerel değişkenlerdir.\n​        B. Yerel değişkenler yığın içinde alan tahsis edilir.\n​        C. Fonksiyon türü, dönüş değeri türü ile aynıdır.\n​        D. Bir fonksiyon kendi gövdesinden kendisini çağırabilir.\n​    Soru 5:\n​    İşaretçiler hakkında hangi ifade yanlıştır?\n​        A. İki işaretçinin çıkarılması, adres değerlerindeki farkı eşittir.\n​        B. İşaretçi dereference, işaretçinin türüne göre çözümlemeyi içerir.\n​        C. int *p[4], p bir int işaretçi dizisidir.\n​        D. Fonksiyon adları, fonksiyon işaretçilerine atanabilir.\n\t>>> answer_questions()\n\tAAAAA\nSadece soruların seçeneklerini temsil eden \"AAAAA\" gibi dizeleri döndürmeniz gerekiyor.\n*/\nconst char* answer_questions()",
      "vi": "#include <assert.h>\n#include <math.h>\n#include <stdbool.h>\n#include <stdio.h>\n#include <string.h>\n/*\n    Trả lời một loạt câu hỏi bằng cách cung cấp lựa chọn A, B, C, hoặc D cho mỗi câu hỏi.\n    Câu hỏi 1:\n    Hằng số như 1e6 thuộc kiểu dữ liệu nào?\n        A. unsigned int\n        B. int\n        C. float\n        D. double\n    Câu hỏi 2:\n    Cho 21! = 51,090,942,171,709,440,000, kiểu dữ liệu nào có thể được sử dụng để lưu trữ giá trị này?\n        A. int\n        B. long long\n        C. double\n        D. Không có cái nào ở trên\n    Câu hỏi 3:\n    Câu nào về giá trị bên trái trong biểu thức là không đúng?\n        A. Biểu thức tên biến là giá trị bên trái.\n        B. Phép toán tăng yêu cầu toán hạng phải là giá trị bên trái.\n        C. Biểu thức giải tham chiếu con trỏ là giá trị bên trái.\n        D. Biểu thức phép toán tăng tiền tố là giá trị bên trái.\n    Câu hỏi 4:\n    Câu nào về hàm là không đúng?\n        A. Tham số hình thức của một hàm là biến cục bộ.\n        B. Biến cục bộ được cấp phát không gian trong ngăn xếp.\n        C. Kiểu hàm giống với kiểu giá trị trả về.\n        D. Một hàm có thể gọi chính nó từ bên trong thân hàm.\n    Câu hỏi 5:\n    Câu nào về con trỏ là không đúng?\n        A. Trừ hai con trỏ bằng với sự khác biệt trong giá trị địa chỉ của chúng.\n        B. Giải tham chiếu con trỏ liên quan đến việc giải quyết dựa trên kiểu của con trỏ.\n        C. int *p[4], p là một mảng các con trỏ int.\n        D. Tên hàm có thể được gán cho con trỏ hàm.\n    >>> answer_questions()\n    AAAAA\nBạn chỉ cần trả về các chuỗi tương tự như \"AAAAA\", đại diện cho các lựa chọn của câu hỏi.\n*/\nconst char* answer_questions()"
    },
    "prompt_bertscore": {
      "es": "0.916706534647211",
      "arb": "0.9015035639131818",
      "sw": "0.880200852807952",
      "tr": "0.9105730271112347",
      "vi": "0.9072296805376555"
    },
    "canonical_solution": "{\n    return \"DDDBA\";\n}",
    "instruction": {
      "es": "const char* answer_questions()\n{\n    return \"DDDBA\";\n}\n\nProporcione una descripción concisa en lenguaje natural (docstring) del código C en español utilizando como máximo 500 caracteres.",
      "arb": "const char* answer_questions()\n{\n    return \"DDDBA\";\n}\n\nيرجى تقديم وصف موجز بلغة طبيعية (docstring) للكود المكتوب بلغة C باللغة العربية الفصحى باستخدام 500 حرف كحد أقصى.",
      "sw": "const char* answer_questions()\n{\n    return \"DDDBA\";\n}\n\nToa maelezo mafupi ya lugha ya asili (docstring) ya msimbo wa C kwa Kiswahili kwa kutumia herufi zisizozidi 500.",
      "tr": "const char* answer_questions()\n{\n    return \"DDDBA\";\n}\n\nAşağıdaki C kodunun işlevini açıklayan, en fazla 500 karakter uzunluğunda, özlü bir doğal dil açıklaması (docstring) sağlayın.",
      "vi": "const char* answer_questions()\n{\n    return \"DDDBA\";\n}\n\nCung cấp mô tả ngắn gọn bằng ngôn ngữ tự nhiên (docstring) của mã C bằng tiếng Việt, sử dụng tối đa 500 ký tự."
    },
    "instruction_bertscore": {
      "es": "0.9687963589217052",
      "arb": "0.8812990801846939",
      "sw": "0.9146175389298671",
      "tr": "0.8531317031108985",
      "vi": "0.927643123426992"
    },
    "level": "",
    "test": "int main() {\n    // The assert should compare strings, not literals or enums, using strcmp\n    const char* expected_answers = \"DDDBA\";\n    assert(strcmp(answer_questions(), expected_answers) == 0);\n    \n    return 0;\n}",
    "entry_point": "answer_questions",
    "signature": "const char* answer_questions()",
    "docstring": {
      "es": "Responder a una serie de preguntas proporcionando opciones A, B, C o D para cada pregunta.\n\nPregunta 1:\n¿Las constantes como 1e6 pertenecen a qué tipo de dato?\n    A. unsigned int\n    B. int\n    C. float\n    D. double\n\nPregunta 2:\nDado 21! = 51,090,942,171,709,440,000, ¿qué tipo de dato se puede usar para almacenar este valor?\n    A. int\n    B. long long\n    C. double\n    D. Ninguna de las anteriores\n\nPregunta 3:\n¿Cuál afirmación sobre los valores de la izquierda en expresiones es incorrecta?\n    A. Las expresiones de nombres de variables son valores de la izquierda.\n    B. La operación de incremento requiere que el operando sea un valor de la izquierda.\n    C. Las expresiones de desreferencia de punteros son valores de la izquierda.\n    D. Las expresiones de operación de incremento prefijo son valores de la izquierda.\n\nPregunta 4:\n¿Cuál afirmación sobre las funciones es incorrecta?\n    A. Los parámetros formales de una función son variables locales.\n    B. Las variables locales se asignan espacio en la pila.\n    C. El tipo de la función es el mismo que el tipo de valor de retorno.\n    D. Una función puede llamarse a sí misma desde dentro de su cuerpo.\n\nPregunta 5:\n¿Cuál afirmación sobre los punteros es incorrecta?\n    A. Restar dos punteros equivale a la diferencia en sus valores de dirección.\n    B. La desreferencia de punteros implica resolver basado en el tipo del puntero.\n    C. int *p[4], p es un arreglo de punteros a int.\n    D. Los nombres de funciones pueden asignarse a punteros de función.\n\n>>> answer_questions()\nAAAAA\nSe supone que solo debes devolver cadenas similares a \"AAAAA\", que representan las opciones de la pregunta.",
      "arb": "ترجمة سلسلة من الأسئلة عن طريق تقديم الخيارات A، B، C، أو D لكل سؤال.\n\nالسؤال 1:\nالثوابت مثل 1e6 تنتمي إلى أي نوع من البيانات؟\n    A. عدد صحيح غير موقع\n    B. عدد صحيح\n    C. عدد عشري\n    D. مزدوج\n\nالسؤال 2:\nبالنظر إلى 21! = 51,090,942,171,709,440,000، أي نوع من البيانات يمكن استخدامه لتخزين هذه القيمة؟\n    A. عدد صحيح\n    B. عدد صحيح طويل طويل\n    C. مزدوج\n    D. لا شيء مما سبق\n\nالسؤال 3:\nأي عبارة عن القيم اليسارية في التعبيرات غير صحيحة؟\n    A. تعبيرات أسماء المتغيرات هي قيم يسارية.\n    B. تتطلب عملية الزيادة أن يكون المعامل قيمة يسارية.\n    C. تعبيرات إلغاء المؤشر هي قيم يسارية.\n    D. تعبيرات عملية الزيادة المسبقة هي قيم يسارية.\n\nالسؤال 4:\nأي عبارة عن الدوال غير صحيحة؟\n    A. المعاملات الشكلية للدالة هي متغيرات محلية.\n    B. يتم تخصيص مساحة للمتغيرات المحلية في المكدس.\n    C. نوع الدالة هو نفس نوع قيمة الإرجاع.\n    D. يمكن للدالة أن تستدعي نفسها من داخل جسمها.\n\nالسؤال 5:\nأي عبارة عن المؤشرات غير صحيحة؟\n    A. طرح مؤشرين يساوي الفرق في قيم عناوينهما.\n    B. إلغاء المؤشر يتضمن الحل بناءً على نوع المؤشر.\n    C. int *p[4]، p هو مصفوفة من مؤشرات int.\n    D. يمكن تعيين أسماء الدوال إلى مؤشرات الدوال.\n\n>>> answer_questions()\nAAAAA\nمن المفترض أن تعيد فقط سلاسل مشابهة لـ \"AAAAA\"، والتي تمثل اختيارات السؤال.",
      "sw": "Jibu maswali kadhaa kwa kutoa chaguo A, B, C, au D kwa kila swali.\n\nSwali la 1:\nKonstant kama 1e6 ni ya aina gani ya data?\n    A. unsigned int\n    B. int\n    C. float\n    D. double\n\nSwali la 2:\nKwa kuzingatia 21! = 51,090,942,171,709,440,000, ni aina gani ya data inaweza kutumika kuhifadhi thamani hii?\n    A. int\n    B. long long\n    C. double\n    D. Hakuna kati ya haya\n\nSwali la 3:\nNi kauli gani kuhusu thamani za kushoto katika maonyesho si sahihi?\n    A. Maonyesho ya majina ya vigezo ni thamani za kushoto.\n    B. Operesheni ya kuongeza inahitaji operand kuwa thamani ya kushoto.\n    C. Maonyesho ya kufuta pointer ni thamani za kushoto.\n    D. Maonyesho ya operesheni ya kuongeza awali ni thamani za kushoto.\n\nSwali la 4:\nNi kauli gani kuhusu kazi si sahihi?\n    A. Vigezo rasmi vya kazi ni vigezo vya ndani.\n    B. Vigezo vya ndani vinatengewa nafasi kwenye stack.\n    C. Aina ya kazi ni sawa na aina ya thamani ya kurudi.\n    D. Kazi inaweza kujiita yenyewe kutoka ndani ya mwili wake.\n\nSwali la 5:\nNi kauli gani kuhusu pointer si sahihi?\n    A. Kutoa pointer mbili ni sawa na tofauti katika thamani za anwani zao.\n    B. Kufuta pointer kunahusisha kutatua kulingana na aina ya pointer.\n    C. int *p[4], p ni safu ya pointer za int.\n    D. Majina ya kazi yanaweza kupewa pointer za kazi.\n\n>>> answer_questions()\nAAAAA\nUnatakiwa kurudisha tu mistari inayofanana na \"AAAAA\", ambayo inasimama kwa chaguo za swali.",
      "tr": "Sorulara A, B, C veya D seçeneklerini vererek yanıtlayın.\n\nSoru 1:\n1e6 gibi sabitler hangi veri tipine aittir?\n    A. unsigned int\n    B. int\n    C. float\n    D. double\n\nSoru 2:\n21! = 51,090,942,171,709,440,000 verildiğinde, bu değeri saklamak için hangi veri tipi kullanılabilir?\n    A. int\n    B. long long\n    C. double\n    D. Yukarıdakilerin hiçbiri\n\nSoru 3:\nİfadelerdeki sol değerler hakkında hangi ifade yanlıştır?\n    A. Değişken adı ifadeleri sol değerlerdir.\n    B. Artırma işlemi, operandın sol değer olmasını gerektirir.\n    C. İşaretçi çözme ifadeleri sol değerlerdir.\n    D. Ön ek artırma işlemi ifadeleri sol değerlerdir.\n\nSoru 4:\nFonksiyonlar hakkında hangi ifade yanlıştır?\n    A. Bir fonksiyonun resmi parametreleri yerel değişkenlerdir.\n    B. Yerel değişkenler yığın içinde alan tahsis edilir.\n    C. Fonksiyon tipi, dönüş değeri tipi ile aynıdır.\n    D. Bir fonksiyon, gövdesi içinde kendisini çağırabilir.\n\nSoru 5:\nİşaretçiler hakkında hangi ifade yanlıştır?\n    A. İki işaretçinin çıkarılması, adres değerlerindeki farkı eşittir.\n    B. İşaretçi çözme, işaretçinin türüne göre çözümlemeyi içerir.\n    C. int *p[4], p bir int işaretçi dizisidir.\n    D. Fonksiyon isimleri, fonksiyon işaretçilerine atanabilir.\n\n>>> answer_questions()\nAAAAA\nSadece soruların seçeneklerini temsil eden \"AAAAA\" gibi dizeleri döndürmeniz gerekiyor.",
      "vi": "Trả lời một loạt câu hỏi bằng cách cung cấp lựa chọn A, B, C, hoặc D cho mỗi câu hỏi.\n\nCâu hỏi 1:\nHằng số như 1e6 thuộc kiểu dữ liệu nào?\n    A. unsigned int\n    B. int\n    C. float\n    D. double\n\nCâu hỏi 2:\nCho 21! = 51,090,942,171,709,440,000, kiểu dữ liệu nào có thể được sử dụng để lưu trữ giá trị này?\n    A. int\n    B. long long\n    C. double\n    D. Không có kiểu nào trong số trên\n\nCâu hỏi 3:\nCâu nào về giá trị bên trái trong biểu thức là không đúng?\n    A. Biểu thức tên biến là giá trị bên trái.\n    B. Toán tử tăng yêu cầu toán hạng phải là giá trị bên trái.\n    C. Biểu thức giải tham chiếu con trỏ là giá trị bên trái.\n    D. Biểu thức toán tử tăng trước là giá trị bên trái.\n\nCâu hỏi 4:\nCâu nào về hàm là không đúng?\n    A. Tham số hình thức của một hàm là biến cục bộ.\n    B. Biến cục bộ được cấp phát không gian trong ngăn xếp.\n    C. Kiểu của hàm giống với kiểu giá trị trả về.\n    D. Một hàm có thể tự gọi trong thân của nó.\n\nCâu hỏi 5:\nCâu nào về con trỏ là không đúng?\n    A. Trừ hai con trỏ bằng sự khác biệt trong giá trị địa chỉ của chúng.\n    B. Giải tham chiếu con trỏ liên quan đến việc giải quyết dựa trên kiểu của con trỏ.\n    C. int *p[4], p là một mảng con trỏ int.\n    D. Tên hàm có thể được gán cho con trỏ hàm.\n\n>>> answer_questions()\nAAAAA\nBạn cần chỉ trả về chuỗi tương tự như \"AAAAA\", đại diện cho các lựa chọn của câu hỏi."
    },
    "docstring_bertscore": {
      "es": "0.9544584234970829",
      "arb": "0.9203007513920374",
      "sw": "0.9128823039211463",
      "tr": "0.9420285315126816",
      "vi": "0.9230392684553653"
    }
  },
  {
    "task_id": "C/21",
    "prompt": {
      "es": "#include <assert.h>\n#include <math.h>\n#include <stdbool.h>\n#include <stdio.h>\n#include <string.h>\n/*\nLa tarea es determinar si es posible ensamblar los cuadrados de madera de n cubetas,\ndonde cada cubeta contiene $a_i$ cuadrados con un lado de longitud 1, en un solo cuadrado más grande.\nEntrada: longitud de la lista, arreglo de números\n    >>> Is_Square(1, (int[]){9})\n    1\n*/\nint Is_Square(int length, int squares[])",
      "arb": "#include <assert.h>\n#include <math.h>\n#include <stdbool.h>\n#include <stdio.h>\n#include <string.h>\n/*\nالمهمة هي تحديد ما إذا كان من الممكن تجميع المربعات الخشبية من n دلاء،\nحيث يحتوي كل دلو على $a_i$ مربعات بطول ضلع 1، في مربع أكبر واحد.\nالمدخلات: طول القائمة، مصفوفة الأرقام\n    >>> Is_Square(1, (int[]){9})\n    1\n*/\nint Is_Square(int length, int squares[])",
      "sw": "#include <assert.h>\n#include <math.h>\n#include <stdbool.h>\n#include <stdio.h>\n#include <string.h>\n/*\nKazi ni kuamua kama inawezekana kuunganisha miraba ya mbao kutoka kwenye ndoo n,\nambapo kila ndoo ina $a_i$ miraba yenye urefu wa upande wa 1, kuwa mraba mmoja mkubwa.\nIngizo: urefu wa orodha, safu ya namba\n    >>> Is_Square(1, (int[]){9})\n    1\n*/\nint Is_Square(int length, int squares[])",
      "tr": "#include <assert.h>\n#include <math.h>\n#include <stdbool.h>\n#include <stdio.h>\n#include <string.h>\n/*\nGörev, her kovada kenar uzunluğu 1 olan $a_i$ kare bulunan n kovadan ahşap kareleri tek bir büyük kareye monte etmenin mümkün olup olmadığını belirlemektir.\nGirdi: liste uzunluğu, sayıların dizisi\n    >>> Is_Square(1, (int[]){9})\n    1\n*/\nint Is_Square(int length, int squares[])",
      "vi": "#include <assert.h>\n#include <math.h>\n#include <stdbool.h>\n#include <stdio.h>\n#include <string.h>\n/*\nNhiệm vụ là xác định xem có thể lắp ráp các hình vuông gỗ từ n thùng,\nmỗi thùng chứa $a_i$ hình vuông với độ dài cạnh là 1, thành một hình vuông lớn hơn hay không.\nĐầu vào: độ dài của danh sách, mảng các số\n    >>> Is_Square(1, (int[]){9})\n    1\n*/\nint Is_Square(int length, int squares[])"
    },
    "prompt_bertscore": {
      "es": "0.9884891707886472",
      "arb": "0.9874924435366141",
      "sw": "0.977169225373469",
      "tr": "0.9703107169467152",
      "vi": "0.9749928322884697"
    },
    "canonical_solution": "{\n    long long sum = 0;\n    for (int i = 0; i < length; ++i) {\n        sum += squares[i]; // 求和\n    }\n    int root = (int)sqrt(sum);\n    return root * root == sum; // 是某个整数的平方\n}",
    "instruction": {
      "es": "int Is_Square(int length, int squares[])\n{\n    long long sum = 0;\n    for (int i = 0; i < length; ++i) {\n        sum += squares[i]; // 求和\n    }\n    int root = (int)sqrt(sum);\n    return root * root == sum; // 是某个整数的平方\n}\n\nProporcione una descripción concisa en lenguaje natural (docstring) del código C en español utilizando un máximo de 500 caracteres.",
      "arb": "int Is_Square(int length, int squares[])\n{\n    long long sum = 0;\n    for (int i = 0; i < length; ++i) {\n        sum += squares[i]; // 求和\n    }\n    int root = (int)sqrt(sum);\n    return root * root == sum; // 是某个整数的平方\n}\n\nيرجى تقديم وصف موجز بلغة طبيعية (docstring) للكود المكتوب بلغة C باللغة العربية الفصحى، بحيث لا يتجاوز 500 حرف.",
      "sw": "int Is_Square(int length, int squares[])\n{\n    long long sum = 0;\n    for (int i = 0; i < length; ++i) {\n        sum += squares[i]; // 求和\n    }\n    int root = (int)sqrt(sum);\n    return root * root == sum; // 是某个整数的平方\n}\n\nToa maelezo mafupi ya lugha ya asili (docstring) ya msimbo wa C kwa Kiswahili kwa kutumia herufi zisizozidi 500.",
      "tr": "int Is_Square(int length, int squares[])\n{\n    long long sum = 0;\n    for (int i = 0; i < length; ++i) {\n        sum += squares[i]; // 求和\n    }\n    int root = (int)sqrt(sum);\n    return root * root == sum; // 是某个整数的平方\n}\n\nC kodunun işlevini açıklayan kısa bir doğal dil açıklaması (docstring) sağlayın. Açıklama, en fazla 500 karakter kullanılarak Türkçe olarak yazılmalıdır.",
      "vi": "int Is_Square(int length, int squares[])\n{\n    long long sum = 0;\n    for (int i = 0; i < length; ++i) {\n        sum += squares[i]; // 求和\n    }\n    int root = (int)sqrt(sum);\n    return root * root == sum; // 是某个整数的平方\n}\n\nCung cấp mô tả ngắn gọn bằng ngôn ngữ tự nhiên (docstring) của mã C bằng tiếng Việt với tối đa 500 ký tự."
    },
    "instruction_bertscore": {
      "es": "0.9687963589217052",
      "arb": "0.8727085148353161",
      "sw": "0.9146175389298671",
      "tr": "0.8690074349454929",
      "vi": "0.923675282935439"
    },
    "level": "",
    "test": "int main() {\n    assert(Is_Square(1, (int[]){9}) == 1);\n    assert(Is_Square(2, (int[]){14, 2}) == 1);\n    assert(Is_Square(2, (int[]){7, 7}) == 0);\n    assert(Is_Square(7, (int[]){1, 2, 3, 4, 5, 6, 7}) == 0);\n    assert(Is_Square(6, (int[]){1, 3, 5, 7, 9, 11}) == 1);\n    assert(Is_Square(4, (int[]){2, 2, 2, 2}) == 0);\n\n    // Additional test cases\n    assert(Is_Square(3, (int[]){4, 5, 6}) == 0);\n    assert(Is_Square(4, (int[]){16, 9, 4, 1}) == 0);\n    assert(Is_Square(5, (int[]){1, 1, 1, 1, 1}) == 0);\n    assert(Is_Square(2, (int[]){25, 25}) == 0);\n    assert(Is_Square(3, (int[]){10, 10, 5}) == 1);\n\n    // printf(\"All tests passed!\\n\");\n    return 0;\n}",
    "entry_point": "Is_Square",
    "signature": "int Is_Square(int length, int squares[])",
    "docstring": {
      "es": "La tarea es determinar si es posible ensamblar los cuadrados de madera de n cubos, donde cada cubo contiene $a_i$ cuadrados con un lado de longitud 1, en un solo cuadrado más grande.\nEntrada: longitud de la lista, array de números\n    >>> Is_Square(1, (int[]){9})\n    1",
      "arb": "المهمة هي تحديد ما إذا كان من الممكن تجميع المربعات الخشبية من n دلاء، حيث يحتوي كل دلو على $a_i$ مربعات بطول ضلع 1، في مربع أكبر واحد.\n\nمدخلات: طول القائمة، مصفوفة الأرقام\n    >>> Is_Square(1, (int[]){9})\n    1",
      "sw": "Kazi ni kuamua kama inawezekana kuunganisha miraba ya mbao kutoka kwenye ndoo n, ambapo kila ndoo ina $a_i$ miraba yenye urefu wa upande 1, kuwa mraba mmoja mkubwa zaidi.\nIngizo: urefu wa orodha, safu ya namba\n    >>> Is_Square(1, (int[]){9})\n    1",
      "tr": "Görev, her bir kovada kenar uzunluğu 1 olan $a_i$ kare bulunan n kovadan ahşap kareleri tek bir büyük kareye monte etmenin mümkün olup olmadığını belirlemektir.\nGirdi: liste uzunluğu, sayıların dizisi\n    >>> Is_Square(1, (int[]){9})\n    1",
      "vi": "Nhiệm vụ là xác định xem có thể lắp ráp các hình vuông gỗ từ n xô, trong đó mỗi xô chứa $a_i$ hình vuông với chiều dài cạnh là 1, thành một hình vuông lớn hơn duy nhất hay không.\nĐầu vào: độ dài của danh sách, mảng số\n    >>> Is_Square(1, (int[]){9})\n    1"
    },
    "docstring_bertscore": {
      "es": "0.9658592114773424",
      "arb": "0.9791245428443763",
      "sw": "0.9788534123742637",
      "tr": "0.9487279370042264",
      "vi": "0.9827906637871373"
    }
  },
  {
    "task_id": "C/22",
    "prompt": {
      "es": "#include <assert.h>\n#include <math.h>\n#include <stdbool.h>\n#include <stdio.h>\n#include <string.h>\n/*\nDado los enteros c y d, donde a + b = c y a * b = d, encuentra y devuelve el valor posible de a (a <= b). Si hay múltiples grupos, muestra el grupo con el menor a.\n    Parámetros:\n    - c (int): La suma de a y b.\n    - d (int): El producto de a y b.\n\n    Devuelve:\n    Optional[int]: Un valor posible de a. Devuelve -1 si no existen valores válidos.\n\n    >>> find_integers(7,11)\n    -1\n*/\nint find_integers(int c, int d)",
      "arb": "#include <assert.h>\n#include <math.h>\n#include <stdbool.h>\n#include <stdio.h>\n#include <string.h>\n/*\nبالنظر إلى الأعداد الصحيحة c و d، حيث a + b = c و a * b = d، ابحث وأعد القيمة الممكنة لـ a (a <= b). إذا كانت هناك مجموعات متعددة، قم بإخراج المجموعة التي تحتوي على أصغر a.\n    المعاملات:\n    - c (int): مجموع a و b.\n    - d (int): حاصل ضرب a و b.\n\n    يعيد:\n    Optional[int]: قيمة ممكنة لـ a. يعيد -1 إذا لم تكن هناك قيم صالحة موجودة،\n\\\n    >>> find_integers(7,11)\n    -1\n*/\nint find_integers(int c, int d)",
      "sw": "#include <assert.h>\n#include <math.h>\n#include <stdbool.h>\n#include <stdio.h>\n#include <string.h>\n/*\nKwa kupewa nambari kamili c na d, ambapo a + b = c na a * b = d, pata na rudisha thamani inayowezekana ya a (a <= b). Ikiwa kuna makundi mengi, toa kundi lenye a ndogo zaidi.\n    Vigezo:\n    - c (int): Jumla ya a na b.\n    - d (int): Bidhaa ya a na b.\n\n    Inarudisha:\n    Optional[int]: Thamani inayowezekana ya a. Inarudisha -1 ikiwa thamani halali hazipo,\n\\\n    >>> find_integers(7,11)\n    -1\n*/\nint find_integers(int c, int d)",
      "tr": "#include <assert.h>\n#include <math.h>\n#include <stdbool.h>\n#include <stdio.h>\n#include <string.h>\n/*\nVerilen tamsayılar c ve d için, burada a + b = c ve a * b = d, a'nın olası değerini bulun ve döndürün (a <= b). Birden fazla grup varsa, en küçük a'ya sahip grubu çıkışlayın.\n    Parametreler:\n    - c (int): a ve b'nin toplamı.\n    - d (int): a ve b'nin çarpımı.\n\n    Döndürür:\n    Optional[int]: a'nın olası bir değeri. Geçerli değerler yoksa -1 döndürür.\n\\\n    >>> find_integers(7,11)\n    -1\n*/\nint find_integers(int c, int d)",
      "vi": "#include <assert.h>\n#include <math.h>\n#include <stdbool.h>\n#include <stdio.h>\n#include <string.h>\n/*\nCho các số nguyên c và d, trong đó a + b = c và a * b = d, tìm và trả về giá trị có thể của a (a <= b). Nếu có nhiều nhóm, xuất nhóm có a nhỏ nhất.\n    Tham số:\n    - c (int): Tổng của a và b.\n    - d (int): Tích của a và b.\n\n    Trả về:\n    Optional[int]: Một giá trị có thể của a. Trả về -1 nếu không tồn tại giá trị hợp lệ,\n\\\n    >>> find_integers(7,11)\n    -1\n*/\nint find_integers(int c, int d)"
    },
    "prompt_bertscore": {
      "es": "0.9713271086064708",
      "arb": "0.951002652127838",
      "sw": "0.9558172539337426",
      "tr": "0.9819160942194407",
      "vi": "0.9524049826179443"
    },
    "canonical_solution": "{\n    for (int i = 0; i <= c / 2; i++) {\n        if (i * (c - i) != d) continue;\n        return i;\n    }\n    return -1; // Return -1 if no valid pairs (a, b) are found.\n}",
    "instruction": {
      "es": "int find_integers(int c, int d)\n{\n    for (int i = 0; i <= c / 2; i++) {\n        if (i * (c - i) != d) continue;\n        return i;\n    }\n    return -1; // Return -1 if no valid pairs (a, b) are found.\n}\n\nProporcione una descripción concisa en lenguaje natural (docstring) del código C en español utilizando como máximo 500 caracteres.",
      "arb": "int find_integers(int c, int d)\n{\n    for (int i = 0; i <= c / 2; i++) {\n        if (i * (c - i) != d) continue;\n        return i;\n    }\n    return -1; // Return -1 if no valid pairs (a, b) are found.\n}\n\nيرجى تقديم وصف موجز بلغة طبيعية (docstring) للكود المكتوب بلغة C باللغة العربية الفصحى، بحيث لا يتجاوز 500 حرف.",
      "sw": "int find_integers(int c, int d)\n{\n    for (int i = 0; i <= c / 2; i++) {\n        if (i * (c - i) != d) continue;\n        return i;\n    }\n    return -1; // Return -1 if no valid pairs (a, b) are found.\n}\n\nToa maelezo mafupi ya lugha ya asili (docstring) ya msimbo wa C kwa Kiswahili kwa kutumia herufi zisizozidi 500.",
      "tr": "int find_integers(int c, int d)\n{\n    for (int i = 0; i <= c / 2; i++) {\n        if (i * (c - i) != d) continue;\n        return i;\n    }\n    return -1; // Return -1 if no valid pairs (a, b) are found.\n}\n\nC kodunun işlevselliğini açıklayan kısa bir doğal dil açıklaması (docstring) sağlayın. Açıklama, en fazla 500 karakter kullanılarak Türkçe olarak yazılmalıdır.",
      "vi": "int find_integers(int c, int d)\n{\n    for (int i = 0; i <= c / 2; i++) {\n        if (i * (c - i) != d) continue;\n        return i;\n    }\n    return -1; // Return -1 if no valid pairs (a, b) are found.\n}\n\nCung cấp mô tả ngắn gọn bằng ngôn ngữ tự nhiên (docstring) cho mã C bằng tiếng Việt với tối đa 500 ký tự."
    },
    "instruction_bertscore": {
      "es": "0.9687963589217052",
      "arb": "0.8727085148353161",
      "sw": "0.9423429634058599",
      "tr": "0.8813211281569888",
      "vi": "0.8995836026500985"
    },
    "level": "",
    "test": "int main() {\n    assert(find_integers(5, 6) == 2);\n    assert(find_integers(6, 9) == 3);\n    assert(find_integers(7, 12) == 3);\n    assert(find_integers(7, 11) == -1);\n    assert(find_integers(9, 8) == 1);\n    assert(find_integers(10, 25) == 5);\n    assert(find_integers(10000, 8765) == -1);\n\n    \n\n    return 0;\n}",
    "entry_point": "find_integers",
    "signature": "int find_integers(int c, int d)",
    "docstring": {
      "es": "Dado los enteros c y d, donde a + b = c y a * b = d, encuentra y devuelve el valor posible de a (a <= b). Si hay múltiples grupos, devuelve el grupo con el menor a.\n    Parámetros:\n    - c (int): La suma de a y b.\n    - d (int): El producto de a y b.\n\n    Devuelve:\n    Optional[int]: Un valor posible de a. Devuelve -1 si no existen valores válidos.\n\n    >>> find_integers(7,11)\n    -1",
      "arb": "المعطى عددان صحيحان c و d، حيث أن a + b = c و a * b = d، ابحث وأرجع القيمة الممكنة لـ a (حيث a <= b). إذا كانت هناك مجموعات متعددة، قم بإخراج المجموعة ذات القيمة الأصغر لـ a.\n    المعطيات:\n    - c (int): مجموع a و b.\n    - d (int): حاصل ضرب a و b.\n\n    المخرجات:\n    Optional[int]: قيمة ممكنة لـ a. يرجع -1 إذا لم تكن هناك قيم صالحة موجودة.\n\n    >>> find_integers(7,11)\n    -1",
      "sw": "Given integers c and d, ambapo a + b = c na a * b = d, tafuta na rudisha thamani inayowezekana ya a (a <= b). Ikiwa kuna makundi mengi, toa kundi lenye a ndogo zaidi.\n    Parameters:\n    - c (int): Jumla ya a na b.\n    - d (int): Bidhaa ya a na b.\n\n    Returns:\n    Optional[int]: Thamani inayowezekana ya a. Inarudisha -1 ikiwa thamani halali hazipo,\n\n    >>> find_integers(7,11)\n    -1",
      "tr": "Verilen tamsayılar c ve d için, burada a + b = c ve a * b = d, a'nın olası değerini bulun ve döndürün (a <= b). Birden fazla grup varsa, en küçük a'ya sahip grubu çıktılayın.\n    Parametreler:\n    - c (int): a ve b'nin toplamı.\n    - d (int): a ve b'nin çarpımı.\n\n    Döndürür:\n    Optional[int]: a'nın olası bir değeri. Geçerli değerler yoksa -1 döner.\n\n    >>> find_integers(7,11)\n    -1",
      "vi": "Cho các số nguyên c và d, trong đó a + b = c và a * b = d, tìm và trả về giá trị có thể có của a (a <= b). Nếu có nhiều nhóm, xuất nhóm có a nhỏ nhất.\n    Tham số:\n    - c (int): Tổng của a và b.\n    - d (int): Tích của a và b.\n\n    Trả về:\n    Optional[int]: Một giá trị có thể có của a. Trả về -1 nếu không tồn tại giá trị hợp lệ,\n\n    >>> find_integers(7,11)\n    -1"
    },
    "docstring_bertscore": {
      "es": "0.9842935012500472",
      "arb": "0.945947310300119",
      "sw": "0.9688966672641279",
      "tr": "0.9877381493179542",
      "vi": "0.9881866567183311"
    }
  },
  {
    "task_id": "C/23",
    "prompt": {
      "es": "#include <assert.h>\n#include <math.h>\n#include <stdbool.h>\n#include <stdio.h>\n#include <string.h>\n#include <stdarg.h>\n#include <stdlib.h>\n/*\nCuenta el número de triángulos acutángulos que se pueden formar seleccionando cualquier 3 bordes de un conjunto dado de bordes.\n    \nArgs:\n- edges_count: El número de bordes pasados.\n- Un número arbitrario de argumentos enteros que representan las longitudes de los bordes.\n    \nReturns:\nint: La cantidad de triángulos acutángulos distintos que se pueden formar.\n    \nExamples:\n>>> count_acute_triangles(4, 1, 1, 1, 1)\n4\n*/\nint count_acute_triangles(int edges_count, ...)",
      "arb": "#include <assert.h>\n#include <math.h>\n#include <stdbool.h>\n#include <stdio.h>\n#include <string.h>\n#include <stdarg.h>\n#include <stdlib.h>\n/*\nاحسب عدد المثلثات الحادة الزاوية التي يمكن تشكيلها عن طريق اختيار أي 3 أضلاع من مجموعة معينة من الأضلاع.\n\nالمعطيات:\n- edges_count: عدد الأضلاع الممررة.\n- عدد تعسفي من المعطيات الصحيحة التي تمثل أطوال الأضلاع.\n\nالقيم المعادة:\nint: عدد المثلثات الحادة الزاوية المختلفة التي يمكن تشكيلها.\n\nأمثلة:\n>>> count_acute_triangles(4, 1, 1, 1, 1)\n4\n*/\nint count_acute_triangles(int edges_count, ...)",
      "sw": "#include <assert.h>\n#include <math.h>\n#include <stdbool.h>\n#include <stdio.h>\n#include <string.h>\n#include <stdarg.h>\n#include <stdlib.h>\n/*\nHesabu idadi ya pembetatu zenye pembe kali ambazo zinaweza kuundwa kwa kuchagua kingo 3 zozote kutoka kwenye seti iliyotolewa ya kingo.\n\nArgs:\n- edges_count: Idadi ya kingo zilizopitishwa.\n- Idadi isiyo na mpangilio ya hoja za nambari nzima zinazowakilisha urefu wa kingo.\n\nReturns:\nint: Idadi ya pembetatu tofauti zenye pembe kali ambazo zinaweza kuundwa.\n\nExamples:\n>>> count_acute_triangles(4, 1, 1, 1, 1)\n4\n*/\nint count_acute_triangles(int edges_count, ...)",
      "tr": "#include <assert.h>\n#include <math.h>\n#include <stdbool.h>\n#include <stdio.h>\n#include <string.h>\n#include <stdarg.h>\n#include <stdlib.h>\n/*\nVerilen bir kenar kümesinden herhangi 3 kenar seçilerek oluşturulabilecek dar açılı üçgenlerin sayısını sayın.\n    \nArgümanlar:\n- edges_count: Geçilen kenarların sayısı.\n- Kenarların uzunluklarını temsil eden keyfi sayıda tamsayı argümanı.\n    \nDöndürür:\nint: Oluşturulabilecek farklı dar açılı üçgenlerin sayısı.\n    \nÖrnekler:\n>>> count_acute_triangles(4, 1, 1, 1, 1)\n4\n*/\nint count_acute_triangles(int edges_count, ...)",
      "vi": "#include <assert.h>\n#include <math.h>\n#include <stdbool.h>\n#include <stdio.h>\n#include <string.h>\n#include <stdarg.h>\n#include <stdlib.h>\n/*\nĐếm số lượng tam giác nhọn có thể được tạo thành bằng cách chọn bất kỳ 3 cạnh nào từ một tập hợp các cạnh cho trước.\n    \nTham số:\n- edges_count: Số lượng cạnh được truyền vào.\n- Một số lượng tùy ý các đối số kiểu nguyên đại diện cho độ dài của các cạnh.\n    \nTrả về:\nint: Số lượng tam giác nhọn khác nhau có thể được tạo thành.\n    \nVí dụ:\n>>> count_acute_triangles(4, 1, 1, 1, 1)\n4\n*/\nint count_acute_triangles(int edges_count, ...)"
    },
    "prompt_bertscore": {
      "es": "0.980517537706574",
      "arb": "0.935904160974233",
      "sw": "0.9615495281000284",
      "tr": "0.9851239748731542",
      "vi": "0.9381073691606719"
    },
    "canonical_solution": "{\n    va_list args;\n    va_start(args, edges_count);\n\n    int* edges = malloc(edges_count * sizeof(int));\n    for (int i = 0; i < edges_count; i++) {\n        edges[i] = va_arg(args, int);\n    }\n    va_end(args);\n\n    qsort(edges, edges_count, sizeof(int), (int (*)(const void *, const void *)) strcmp);\n\n    int sum = 0;\n    for (int i = 0; i < edges_count - 2; i++) {\n        for (int j = i + 1; j < edges_count - 1; j++) {\n            for (int k = j + 1; k < edges_count; k++) {\n                int x = edges[i], y = edges[j], z = edges[k];\n                if (x + y > z && x * x + y * y > z * z) {\n                    sum++;\n                }\n            }\n        }\n    }\n\n    free(edges);\n    return sum;\n}",
    "instruction": {
      "es": "int count_acute_triangles(int edges_count, ...)\n{\n    va_list args;\n    va_start(args, edges_count);\n\n    int* edges = malloc(edges_count * sizeof(int));\n    for (int i = 0; i < edges_count; i++) {\n        edges[i] = va_arg(args, int);\n    }\n    va_end(args);\n\n    qsort(edges, edges_count, sizeof(int), (int (*)(const void *, const void *)) strcmp);\n\n    int sum = 0;\n    for (int i = 0; i < edges_count - 2; i++) {\n        for (int j = i + 1; j < edges_count - 1; j++) {\n            for (int k = j + 1; k < edges_count; k++) {\n                int x = edges[i], y = edges[j], z = edges[k];\n                if (x + y > z && x * x + y * y > z * z) {\n                    sum++;\n                }\n            }\n        }\n    }\n\n    free(edges);\n    return sum;\n}\n\nProporcione una descripción concisa en lenguaje natural (docstring) del código C en español utilizando como máximo 500 caracteres.",
      "arb": "int count_acute_triangles(int edges_count, ...)\n{\n    va_list args;\n    va_start(args, edges_count);\n\n    int* edges = malloc(edges_count * sizeof(int));\n    for (int i = 0; i < edges_count; i++) {\n        edges[i] = va_arg(args, int);\n    }\n    va_end(args);\n\n    qsort(edges, edges_count, sizeof(int), (int (*)(const void *, const void *)) strcmp);\n\n    int sum = 0;\n    for (int i = 0; i < edges_count - 2; i++) {\n        for (int j = i + 1; j < edges_count - 1; j++) {\n            for (int k = j + 1; k < edges_count; k++) {\n                int x = edges[i], y = edges[j], z = edges[k];\n                if (x + y > z && x * x + y * y > z * z) {\n                    sum++;\n                }\n            }\n        }\n    }\n\n    free(edges);\n    return sum;\n}\n\nيرجى تقديم وصف موجز بلغة طبيعية (docstring) للكود المكتوب بلغة C باللغة العربية الفصحى، بحيث لا يتجاوز 500 حرف.",
      "sw": "int count_acute_triangles(int edges_count, ...)\n{\n    va_list args;\n    va_start(args, edges_count);\n\n    int* edges = malloc(edges_count * sizeof(int));\n    for (int i = 0; i < edges_count; i++) {\n        edges[i] = va_arg(args, int);\n    }\n    va_end(args);\n\n    qsort(edges, edges_count, sizeof(int), (int (*)(const void *, const void *)) strcmp);\n\n    int sum = 0;\n    for (int i = 0; i < edges_count - 2; i++) {\n        for (int j = i + 1; j < edges_count - 1; j++) {\n            for (int k = j + 1; k < edges_count; k++) {\n                int x = edges[i], y = edges[j], z = edges[k];\n                if (x + y > z && x * x + y * y > z * z) {\n                    sum++;\n                }\n            }\n        }\n    }\n\n    free(edges);\n    return sum;\n}\n\nToa maelezo mafupi ya lugha asilia (docstring) ya msimbo wa C kwa Kiswahili kwa kutumia herufi zisizozidi 500.",
      "tr": "int count_acute_triangles(int edges_count, ...)\n{\n    va_list args;\n    va_start(args, edges_count);\n\n    int* edges = malloc(edges_count * sizeof(int));\n    for (int i = 0; i < edges_count; i++) {\n        edges[i] = va_arg(args, int);\n    }\n    va_end(args);\n\n    qsort(edges, edges_count, sizeof(int), (int (*)(const void *, const void *)) strcmp);\n\n    int sum = 0;\n    for (int i = 0; i < edges_count - 2; i++) {\n        for (int j = i + 1; j < edges_count - 1; j++) {\n            for (int k = j + 1; k < edges_count; k++) {\n                int x = edges[i], y = edges[j], z = edges[k];\n                if (x + y > z && x * x + y * y > z * z) {\n                    sum++;\n                }\n            }\n        }\n    }\n\n    free(edges);\n    return sum;\n}\n\nC kodunun işlevini açıklayan kısa bir doğal dil açıklaması (docstring) sağlayın. Açıklama, Türkçe dilinde ve en fazla 500 karakterle sınırlı olmalıdır.",
      "vi": "int count_acute_triangles(int edges_count, ...)\n{\n    va_list args;\n    va_start(args, edges_count);\n\n    int* edges = malloc(edges_count * sizeof(int));\n    for (int i = 0; i < edges_count; i++) {\n        edges[i] = va_arg(args, int);\n    }\n    va_end(args);\n\n    qsort(edges, edges_count, sizeof(int), (int (*)(const void *, const void *)) strcmp);\n\n    int sum = 0;\n    for (int i = 0; i < edges_count - 2; i++) {\n        for (int j = i + 1; j < edges_count - 1; j++) {\n            for (int k = j + 1; k < edges_count; k++) {\n                int x = edges[i], y = edges[j], z = edges[k];\n                if (x + y > z && x * x + y * y > z * z) {\n                    sum++;\n                }\n            }\n        }\n    }\n\n    free(edges);\n    return sum;\n}\n\nCung cấp mô tả ngắn gọn bằng ngôn ngữ tự nhiên (docstring) của mã C bằng tiếng Việt, sử dụng tối đa 500 ký tự."
    },
    "instruction_bertscore": {
      "es": "0.9687963589217052",
      "arb": "0.8727085148353161",
      "sw": "0.9423429634058599",
      "tr": "0.8562748302603945",
      "vi": "0.927643123426992"
    },
    "level": "",
    "test": "int main()\n{\n    assert(count_acute_triangles(4, 1, 1, 1, 1) == 4);\n    assert(count_acute_triangles(3, 1, 2, 3) == 0);\n    // Additional tests to ensure correctness\n    assert(count_acute_triangles(5, 3, 4, 5, 7, 10) == 0);\n    assert(count_acute_triangles(6, 6, 8, 10, 5, 5, 5) == 4);\n    return 0;\n}",
    "entry_point": "count_acute_triangles",
    "signature": "int count_acute_triangles(int edges_count, ...)",
    "docstring": {
      "es": "Contar el número de triángulos acutángulos que se pueden formar seleccionando cualquier 3 lados de un conjunto dado de lados.\n\nArgs:\n- edges_count: El número de lados pasados.\n- Un número arbitrario de argumentos enteros que representan las longitudes de los lados.\n\nReturns:\nint: La cantidad de triángulos acutángulos distintos que se pueden formar.\n\nExamples:\n>>> count_acute_triangles(4, 1, 1, 1, 1)\n4",
      "arb": "احسب عدد المثلثات الحادة الزوايا التي يمكن تشكيلها عن طريق اختيار أي 3 حواف من مجموعة الحواف المعطاة.\n\nالمعطيات:\n- edges_count: عدد الحواف الممررة.\n- عدد تعسفي من المعطيات الصحيحة التي تمثل أطوال الحواف.\n\nالقيم المعادة:\nint: عدد المثلثات الحادة الزوايا المميزة التي يمكن تشكيلها.\n\nأمثلة:\n>>> count_acute_triangles(4, 1, 1, 1, 1)\n4",
      "sw": "Hesabu idadi ya pembetatu zenye pembe kali ambazo zinaweza kuundwa kwa kuchagua pande 3 zozote kutoka kwenye seti iliyotolewa ya pande.\n\nArgs:\n- edges_count: Idadi ya pande zilizopitishwa.\n- Idadi isiyo ya kawaida ya hoja za nambari nzima zinazowakilisha urefu wa pande.\n\nReturns:\nint: Idadi ya pembetatu tofauti zenye pembe kali ambazo zinaweza kuundwa.\n\nExamples:\n>>> count_acute_triangles(4, 1, 1, 1, 1)\n4",
      "tr": "Verilen bir kenar kümesinden herhangi 3 kenar seçilerek oluşturulabilecek dik açılı üçgenlerin sayısını sayın.\n\nArgs:\n- edges_count: Geçilen kenarların sayısı.\n- Kenarların uzunluklarını temsil eden rastgele sayıda tamsayı argümanı.\n\nReturns:\nint: Oluşturulabilecek farklı dik açılı üçgenlerin sayısı.\n\nÖrnekler:\n>>> count_acute_triangles(4, 1, 1, 1, 1)\n4",
      "vi": "Đếm số lượng tam giác nhọn có thể được tạo thành bằng cách chọn bất kỳ 3 cạnh nào từ một tập hợp các cạnh đã cho.\n\nTham số:\n- edges_count: Số lượng cạnh được truyền vào.\n- Một số lượng bất kỳ các đối số kiểu số nguyên đại diện cho độ dài của các cạnh.\n\nTrả về:\nint: Số lượng tam giác nhọn khác nhau có thể được tạo thành.\n\nVí dụ:\n>>> count_acute_triangles(4, 1, 1, 1, 1)\n4"
    },
    "docstring_bertscore": {
      "es": "0.9504182815468333",
      "arb": "0.9549905542878754",
      "sw": "0.9618659462970169",
      "tr": "0.9616675145463631",
      "vi": "0.927524143828752"
    }
  },
  {
    "task_id": "C/24",
    "prompt": {
      "es": "#include <assert.h>\n#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n/*\nLee un entero y un carácter, luego los devuelve como una cadena formateada separada por una coma.\nParámetros:\n- integer_value (int): El entero de entrada.\n- char_value (char): El carácter de entrada.\nDevuelve:\n- char*: Una cadena que contiene el entero y el carácter separados por una coma.\n>>> process_integer_and_char(234,H)\n\t234,H\n*/\nchar* process_integer_and_char(int integer_value, char char_value)",
      "arb": "#include <assert.h>\n#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n/*\nيقرأ عددًا صحيحًا وحرفًا، ثم يعيدهما كسلسلة منسقة مفصولة بفاصلة.\nالمعطيات:\n- integer_value (int): العدد الصحيح المدخل.\n- char_value (char): الحرف المدخل.\nالإرجاع:\n- char*: سلسلة تحتوي على العدد الصحيح والحرف مفصولين بفاصلة.\n>>> process_integer_and_char(234,H)\n\t234,H\n*/\nchar* process_integer_and_char(int integer_value, char char_value)",
      "sw": "#include <assert.h>\n#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n/*\nHusoma nambari nzima na herufi, kisha huzirudisha kama kamba iliyopangwa ikitenganishwa na koma.\nVigezo:\n- integer_value (int): Nambari nzima ya ingizo.\n- char_value (char): Herufi ya ingizo.\nInarudisha:\n- char*: Kamba inayojumuisha nambari nzima na herufi ikitenganishwa na koma.\n>>> process_integer_and_char(234,H)\n\t234,H\n*/\nchar* process_integer_and_char(int integer_value, char char_value)",
      "tr": "#include <assert.h>\n#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n/*\nBir tamsayı ve bir karakter okur, ardından bunları virgülle ayrılmış biçimlendirilmiş bir dize olarak döndürür.\nParametreler:\n- integer_value (int): Girdi tamsayısı.\n- char_value (char): Girdi karakteri.\nDöndürür:\n- char*: Tamsayı ve karakteri virgülle ayrılmış olarak içeren bir dize.\n>>> process_integer_and_char(234,H)\n\t234,H\n*/\nchar* process_integer_and_char(int integer_value, char char_value)",
      "vi": "#include <assert.h>\n#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n/*\nĐọc một số nguyên và một ký tự, sau đó trả về chúng dưới dạng một chuỗi định dạng được ngăn cách bởi dấu phẩy.\nTham số:\n- integer_value (int): Số nguyên đầu vào.\n- char_value (char): Ký tự đầu vào.\nTrả về:\n- char*: Một chuỗi chứa số nguyên và ký tự được ngăn cách bởi dấu phẩy.\n>>> process_integer_and_char(234,H)\n\t234,H\n*/\nchar* process_integer_and_char(int integer_value, char char_value)"
    },
    "prompt_bertscore": {
      "es": "0.9970332566288629",
      "arb": "0.9864871751781965",
      "sw": "0.9833881439732902",
      "tr": "0.9892036442692297",
      "vi": "0.984565426241684"
    },
    "canonical_solution": "{\n    // Allocate memory for the resulting string\n    // 12 bytes for the integer, 2 for the char and comma, 1 for null-terminator\n    char* result = (char*)malloc(15 * sizeof(char));\n    if (result == NULL) {\n        fprintf(stderr, \"Memory allocation failed\\n\");\n        exit(EXIT_FAILURE);\n    }\n    // Format the string\n    sprintf(result, \"%d,%c\", integer_value, char_value);\n    return result;\n}",
    "instruction": {
      "es": "char* process_integer_and_char(int integer_value, char char_value)\n{\n    // Allocate memory for the resulting string\n    // 12 bytes for the integer, 2 for the char and comma, 1 for null-terminator\n    char* result = (char*)malloc(15 * sizeof(char));\n    if (result == NULL) {\n        fprintf(stderr, \"Memory allocation failed\\n\");\n        exit(EXIT_FAILURE);\n    }\n    // Format the string\n    sprintf(result, \"%d,%c\", integer_value, char_value);\n    return result;\n}\n\nProporcione una descripción concisa en lenguaje natural (docstring) del código C en español utilizando como máximo 500 caracteres.",
      "arb": "char* process_integer_and_char(int integer_value, char char_value)\n{\n    // Allocate memory for the resulting string\n    // 12 bytes for the integer, 2 for the char and comma, 1 for null-terminator\n    char* result = (char*)malloc(15 * sizeof(char));\n    if (result == NULL) {\n        fprintf(stderr, \"Memory allocation failed\\n\");\n        exit(EXIT_FAILURE);\n    }\n    // Format the string\n    sprintf(result, \"%d,%c\", integer_value, char_value);\n    return result;\n}\n\nيرجى تقديم وصف موجز بلغة طبيعية (docstring) للكود المكتوب بلغة C باللغة العربية الفصحى، على ألا يتجاوز 500 حرف.",
      "sw": "char* process_integer_and_char(int integer_value, char char_value)\n{\n    // Allocate memory for the resulting string\n    // 12 bytes for the integer, 2 for the char and comma, 1 for null-terminator\n    char* result = (char*)malloc(15 * sizeof(char));\n    if (result == NULL) {\n        fprintf(stderr, \"Memory allocation failed\\n\");\n        exit(EXIT_FAILURE);\n    }\n    // Format the string\n    sprintf(result, \"%d,%c\", integer_value, char_value);\n    return result;\n}\n\nToa maelezo mafupi ya lugha ya asili (docstring) ya msimbo wa C kwa Kiswahili kwa kutumia herufi zisizozidi 500.",
      "tr": "char* process_integer_and_char(int integer_value, char char_value)\n{\n    // Allocate memory for the resulting string\n    // 12 bytes for the integer, 2 for the char and comma, 1 for null-terminator\n    char* result = (char*)malloc(15 * sizeof(char));\n    if (result == NULL) {\n        fprintf(stderr, \"Memory allocation failed\\n\");\n        exit(EXIT_FAILURE);\n    }\n    // Format the string\n    sprintf(result, \"%d,%c\", integer_value, char_value);\n    return result;\n}\n\nC kodunun işlevini açıklayan kısa bir doğal dil açıklaması (docstring) sağlayın. Açıklama en fazla 500 karakter olmalıdır.",
      "vi": "char* process_integer_and_char(int integer_value, char char_value)\n{\n    // Allocate memory for the resulting string\n    // 12 bytes for the integer, 2 for the char and comma, 1 for null-terminator\n    char* result = (char*)malloc(15 * sizeof(char));\n    if (result == NULL) {\n        fprintf(stderr, \"Memory allocation failed\\n\");\n        exit(EXIT_FAILURE);\n    }\n    // Format the string\n    sprintf(result, \"%d,%c\", integer_value, char_value);\n    return result;\n}\n\nCung cấp mô tả ngắn gọn bằng ngôn ngữ tự nhiên (docstring) của mã C bằng tiếng Việt với tối đa 500 ký tự."
    },
    "instruction_bertscore": {
      "es": "0.9687963589217052",
      "arb": "0.8727085148353161",
      "sw": "0.9146175389298671",
      "tr": "0.8359883121845394",
      "vi": "0.923675282935439"
    },
    "level": "",
    "test": "int main()\n{\n    // Test 1\n    char* output1 = process_integer_and_char(234, 'H');\n    assert(strcmp(output1, \"234,H\") == 0);\n    free(output1); // Don't forget to free the allocated memory\n\n    // Additional tests can be added here with different input values\n    // Test 2\n    char* output2 = process_integer_and_char(123, 'A');\n    assert(strcmp(output2, \"123,A\") == 0);\n    free(output2);\n\n    // Test 3\n    char* output3 = process_integer_and_char(0, 'Z');\n    assert(strcmp(output3, \"0,Z\") == 0);\n    free(output3);\n\n    return 0;\n}",
    "entry_point": "process_integer_and_char",
    "signature": "char* process_integer_and_char(int integer_value, char char_value)",
    "docstring": {
      "es": "Lee un entero y un carácter, luego los devuelve como una cadena formateada separada por una coma.\nParámetros:\n- integer_value (int): El entero de entrada.\n- char_value (char): El carácter de entrada.\nDevuelve:\n- char*: Una cadena que contiene el entero y el carácter separados por una coma.\n>>> process_integer_and_char(234,H)\n\t234,H",
      "arb": "يقرأ عددًا صحيحًا وحرفًا، ثم يعيدهما كسلسلة منسقة مفصولة بفاصلة. \nالمعلمات:\n- integer_value (int): العدد الصحيح المدخل.\n- char_value (char): الحرف المدخل.\nالقيم المعادة:\n- char*: سلسلة تحتوي على العدد الصحيح والحرف مفصولين بفاصلة.\n>>> process_integer_and_char(234,H)\n\t234,H",
      "sw": "Husoma nambari kamili na herufi, kisha inazirudisha kama kamba iliyopangwa iliyotenganishwa na koma.  \nVigezo:  \n- integer_value (int): Nambari kamili ya ingizo.  \n- char_value (char): Herufi ya ingizo.  \nInarudisha:  \n- char*: Kamba inayojumuisha nambari kamili na herufi iliyotenganishwa na koma.  \n>>> process_integer_and_char(234,H)  \n\t234,H  ",
      "tr": "Bir tam sayı ve bir karakter okur, ardından bunları virgülle ayrılmış biçimlendirilmiş bir dize olarak döndürür.\nParametreler:\n- integer_value (int): Girdi tam sayısı.\n- char_value (char): Girdi karakteri.\nDöndürülenler:\n- char*: Virgülle ayrılmış tam sayı ve karakter içeren bir dize.\n>>> process_integer_and_char(234,H)\n\t234,H",
      "vi": "Đọc một số nguyên và một ký tự, sau đó trả về chúng dưới dạng một chuỗi định dạng được ngăn cách bằng dấu phẩy.  \nTham số:  \n- integer_value (int): Số nguyên đầu vào.  \n- char_value (char): Ký tự đầu vào.  \nTrả về:  \n- char*: Một chuỗi chứa số nguyên và ký tự được ngăn cách bằng dấu phẩy.  \n>>> process_integer_and_char(234,H)  \n\t234,H  "
    },
    "docstring_bertscore": {
      "es": "0.9883320541572486",
      "arb": "0.9786736518794271",
      "sw": "0.9825832936693368",
      "tr": "0.9745312152829446",
      "vi": "0.9779742743078034"
    }
  },
  {
    "task_id": "C/25",
    "prompt": {
      "es": "#include <assert.h>\n#include <math.h>\n#include <stdbool.h>\n#include <stdio.h>\n#include <string.h>\n/*\nDesplaza todos los caracteres 5 posiciones en orden alfabético. Solo se reemplazan letras, y todas las letras están en mayúsculas.\n​    Parámetros:\n​    text (str): El texto de entrada a procesar.\n​\n​    Retorna:\n​    str: El texto transformado con caracteres desplazados 5 posiciones.\n\t>>> shift_characters(NS,BFW,,JAJSYX,TK,NRUTWYFSHJ,FWJ,YMJ,WJXZQY,TK,YWNANFQ,HFZXJX)\n\tIN WAR, EVENTS OF IMPORTANCE ARE THE RESULT OF TRIVIAL CAUSES\n*/\nchar* shift_characters(char* text)",
      "arb": "#include <assert.h>\n#include <math.h>\n#include <stdbool.h>\n#include <stdio.h>\n#include <string.h>\n/*\nيقوم بتحريك جميع الأحرف بمقدار 5 مواقع في الترتيب الأبجدي. يتم استبدال الأحرف فقط، وجميع الأحرف تكون بأحرف كبيرة.\n    المعلمات:\n    text (str): النص المدخل ليتم معالجته.\n    \n    يعيد:\n    str: النص المحول مع الأحرف المحركة بمقدار 5 مواقع.\n    >>> shift_characters(NS,BFW,,JAJSYX,TK,NRUTWYFSHJ,FWJ,YMJ,WJXZQY,TK,YWNANFQ,HFZXJX)\n    IN WAR, EVENTS OF IMPORTANCE ARE THE RESULT OF TRIVIAL CAUSES\n*/\nchar* shift_characters(char* text)",
      "sw": "#include <assert.h>\n#include <math.h>\n#include <stdbool.h>\n#include <stdio.h>\n#include <string.h>\n/*\nInasogeza herufi zote kwa nafasi 5 katika mpangilio wa alfabeti. Ni herufi pekee ndizo hubadilishwa, na herufi zote ni kubwa.\n​    Vigezo:\n​    text (str): Maandishi ya ingizo yanayopaswa kushughulikiwa.\n​\n​    Inarejesha:\n​    str: Maandishi yaliyobadilishwa na herufi zilizogeuzwa kwa nafasi 5.\n\t>>> shift_characters(NS,BFW,,JAJSYX,TK,NRUTWYFSHJ,FWJ,YMJ,WJXZQY,TK,YWNANFQ,HFZXJX)\n\tIN WAR, EVENTS OF IMPORTANCE ARE THE RESULT OF TRIVIAL CAUSES\n*/\nchar* shift_characters(char* text)",
      "tr": "#include <assert.h>\n#include <math.h>\n#include <stdbool.h>\n#include <stdio.h>\n#include <string.h>\n/*\nAlfabetik sırada tüm karakterleri 5 pozisyon kaydırır. Yalnızca harfler değiştirilir ve tüm harfler büyük harfle yazılır.\n​    Parametreler:\n​    text (str): İşlenecek giriş metni.\n​\n​    Döndürür:\n​    str: Karakterlerin 5 pozisyon kaydırıldığı dönüştürülmüş metin.\n\t>>> shift_characters(NS,BFW,,JAJSYX,TK,NRUTWYFSHJ,FWJ,YMJ,WJXZQY,TK,YWNANFQ,HFZXJX)\n\tIN WAR, EVENTS OF IMPORTANCE ARE THE RESULT OF TRIVIAL CAUSES\n*/\nchar* shift_characters(char* text)",
      "vi": "#include <assert.h>\n#include <math.h>\n#include <stdbool.h>\n#include <stdio.h>\n#include <string.h>\n/*\nDịch chuyển tất cả các ký tự 5 vị trí trong thứ tự bảng chữ cái. Chỉ các chữ cái được thay thế, và tất cả các chữ cái đều ở dạng chữ hoa.\n​    Tham số:\n​    text (str): Văn bản đầu vào cần được xử lý.\n​\n​    Trả về:\n​    str: Văn bản đã được biến đổi với các ký tự dịch chuyển 5 vị trí.\n\t>>> shift_characters(NS,BFW,,JAJSYX,TK,NRUTWYFSHJ,FWJ,YMJ,WJXZQY,TK,YWNANFQ,HFZXJX)\n\tIN WAR, EVENTS OF IMPORTANCE ARE THE RESULT OF TRIVIAL CAUSES\n*/\nchar* shift_characters(char* text)"
    },
    "prompt_bertscore": {
      "es": "0.948384306445036",
      "arb": "0.9672297611064831",
      "sw": "0.9458408444158842",
      "tr": "0.9609288081592944",
      "vi": "0.9489613277019424"
    },
    "canonical_solution": "{\n\tsize_t len = strlen(text);\n    for (size_t i = 0; i < len; ++i) {\n        if ('A' <= text[i] && text[i] <= 'E') {\n            text[i] = text[i] + 'V' - 'A';\n        } else if ('F' <= text[i] && text[i] <= 'Z') {\n            text[i] = text[i] + 'A' - 'F';\n        }\n    }\n    return text;\n}",
    "instruction": {
      "es": "char* shift_characters(char* text)\n{\n\tsize_t len = strlen(text);\n    for (size_t i = 0; i < len; ++i) {\n        if ('A' <= text[i] && text[i] <= 'E') {\n            text[i] = text[i] + 'V' - 'A';\n        } else if ('F' <= text[i] && text[i] <= 'Z') {\n            text[i] = text[i] + 'A' - 'F';\n        }\n    }\n    return text;\n}\n\nProporcione una descripción concisa en lenguaje natural (docstring) del código C en español utilizando como máximo 500 caracteres.",
      "arb": "char* shift_characters(char* text)\n{\n\tsize_t len = strlen(text);\n    for (size_t i = 0; i < len; ++i) {\n        if ('A' <= text[i] && text[i] <= 'E') {\n            text[i] = text[i] + 'V' - 'A';\n        } else if ('F' <= text[i] && text[i] <= 'Z') {\n            text[i] = text[i] + 'A' - 'F';\n        }\n    }\n    return text;\n}\n\nيرجى تقديم وصف موجز بلغة طبيعية (docstring) للكود المكتوب بلغة C باللغة العربية الفصحى، بحيث لا يتجاوز 500 حرف.",
      "sw": "char* shift_characters(char* text)\n{\n\tsize_t len = strlen(text);\n    for (size_t i = 0; i < len; ++i) {\n        if ('A' <= text[i] && text[i] <= 'E') {\n            text[i] = text[i] + 'V' - 'A';\n        } else if ('F' <= text[i] && text[i] <= 'Z') {\n            text[i] = text[i] + 'A' - 'F';\n        }\n    }\n    return text;\n}\n\nToa maelezo mafupi ya lugha ya asili (docstring) ya msimbo wa C kwa Kiswahili kwa kutumia herufi zisizozidi 500.",
      "tr": "char* shift_characters(char* text)\n{\n\tsize_t len = strlen(text);\n    for (size_t i = 0; i < len; ++i) {\n        if ('A' <= text[i] && text[i] <= 'E') {\n            text[i] = text[i] + 'V' - 'A';\n        } else if ('F' <= text[i] && text[i] <= 'Z') {\n            text[i] = text[i] + 'A' - 'F';\n        }\n    }\n    return text;\n}\n\nC kodunun işlevini açıklayan kısa bir doğal dil tanımı (docstring) sağlayın. Açıklama Türkçe olmalı ve en fazla 500 karakter içermelidir.",
      "vi": "char* shift_characters(char* text)\n{\n\tsize_t len = strlen(text);\n    for (size_t i = 0; i < len; ++i) {\n        if ('A' <= text[i] && text[i] <= 'E') {\n            text[i] = text[i] + 'V' - 'A';\n        } else if ('F' <= text[i] && text[i] <= 'Z') {\n            text[i] = text[i] + 'A' - 'F';\n        }\n    }\n    return text;\n}\n\nCung cấp mô tả ngắn gọn bằng ngôn ngữ tự nhiên (docstring) của mã C bằng tiếng Việt, sử dụng tối đa 500 ký tự."
    },
    "instruction_bertscore": {
      "es": "0.9687963589217052",
      "arb": "0.8727085148353161",
      "sw": "0.9146175389298671",
      "tr": "0.8729432959456993",
      "vi": "0.927643123426992"
    },
    "level": "",
    "test": "int main()\n{\n\tchar test1[] = \"NS BFW, JAJSYX TK NRUTWYFSHJ FWJ YMJ WJXZQY TK YWNANFQ HFZXJX\";\n    char test2[] = \"N BTZQI WFYMJW GJ KNWXY NS F QNYYQJ NGJWNFS ANQQFLJ YMFS XJHTSI NS WTRJ\";\n    char test3[] = \"IFSLJW PSTBX KZQQ BJQQ YMFY HFJXFW NX RTWJ IFSLJWTZX YMFS MJ\";\n\n    assert(strcmp(shift_characters(test1), \"IN WAR, EVENTS OF IMPORTANCE ARE THE RESULT OF TRIVIAL CAUSES\") == 0);\n    assert(strcmp(shift_characters(test2), \"I WOULD RATHER BE FIRST IN A LITTLE IBERIAN VILLAGE THAN SECOND IN ROME\") == 0);\n    assert(strcmp(shift_characters(test3), \"DANGER KNOWS FULL WELL THAT CAESAR IS MORE DANGEROUS THAN HE\") == 0);\n\treturn 0;\n}",
    "entry_point": "shift_characters",
    "signature": "char* shift_characters(char* text)",
    "docstring": {
      "es": "Desplaza todos los caracteres 5 posiciones en orden alfabético. Solo se reemplazan las letras, y todas las letras están en mayúsculas.\n​    Parámetros:\n​    text (str): El texto de entrada a ser procesado.\n\n​    Devuelve:\n​    str: El texto transformado con caracteres desplazados por 5 posiciones.\n\t>>> shift_characters('NS BFW JAJSYX TK NRUTWYFSHJ FWJ YMJ WJXZQY TK YWNANFQ HFZXJX')\n\t'IN WAR, EVENTS OF IMPORTANCE ARE THE RESULT OF TRIVIAL CAUSES'",
      "arb": "ينقل جميع الأحرف بمقدار 5 مواقع في الترتيب الأبجدي. يتم استبدال الحروف فقط، وجميع الحروف تكون بأحرف كبيرة.\n\nالمعلمات:\ntext (str): النص المدخل ليتم معالجته.\n\nالقيم المعادة:\nstr: النص المحول مع الأحرف المنقولة بمقدار 5 مواقع.\n>>> shift_characters('NS BFW JAJSYX TK NRUTWYFSHJ FWJ YMJ WJXZQY TK YWNANFQ HFZXJX')\n'IN WAR, EVENTS OF IMPORTANCE ARE THE RESULT OF TRIVIAL CAUSES'",
      "sw": "Hubadilisha herufi zote kwa nafasi 5 katika mpangilio wa alfabeti. Ni herufi pekee ndizo hubadilishwa, na herufi zote ziko katika herufi kubwa.\n​    Vigezo:\n​    text (str): Maandishi ya kuingiza yatakayoshughulikiwa.\n\n​    Inarejesha:\n​    str: Maandishi yaliyobadilishwa na herufi zilizohamishwa kwa nafasi 5.\n\t>>> shift_characters('NS BFW JAJSYX TK NRUTWYFSHJ FWJ YMJ WJXZQY TK YWNANFQ HFZXJX')\n\t'IN WAR, EVENTS OF IMPORTANCE ARE THE RESULT OF TRIVIAL CAUSES'",
      "tr": "Alfabetik sırada tüm karakterleri 5 pozisyon kaydırır. Yalnızca harfler değiştirilir ve tüm harfler büyük harfle yazılır.\n​    Parametreler:\n​    text (str): İşlenecek giriş metni.\n\n​    Döndürür:\n​    str: Karakterlerin 5 pozisyon kaydırıldığı dönüştürülmüş metin.\n\t>>> shift_characters('NS BFW JAJSYX TK NRUTWYFSHJ FWJ YMJ WJXZQY TK YWNANFQ HFZXJX')\n\t'IN WAR, EVENTS OF IMPORTANCE ARE THE RESULT OF TRIVIAL CAUSES'",
      "vi": "Dịch chuyển tất cả các ký tự theo 5 vị trí trong thứ tự bảng chữ cái. Chỉ các chữ cái được thay thế, và tất cả các chữ cái đều ở dạng chữ hoa.\n​    Tham số:\n​    text (str): Văn bản đầu vào cần được xử lý.\n\n​    Trả về:\n​    str: Văn bản đã được biến đổi với các ký tự được dịch chuyển 5 vị trí.\n\t>>> shift_characters('NS BFW JAJSYX TK NRUTWYFSHJ FWJ YMJ WJXZQY TK YWNANFQ HFZXJX')\n\t'IN WAR, EVENTS OF IMPORTANCE ARE THE RESULT OF TRIVIAL CAUSES'"
    },
    "docstring_bertscore": {
      "es": "0.9599861083709028",
      "arb": "0.9728730488620653",
      "sw": "0.9435834101354228",
      "tr": "0.939781823272796",
      "vi": "0.9676780698764789"
    }
  },
  {
    "task_id": "C/26",
    "prompt": {
      "es": "#include <assert.h>\n#include <math.h>\n#include <stdbool.h>\n#include <stdio.h>\n#include <string.h>\n/*\nClasificar el entero x basado en el siguiente método:\nSi x es un número de un solo dígito, x pertenece a su propia clase.\nDe lo contrario, suma los dígitos de x, obtiene un nuevo x, e itera hasta que se determine la clase.\nParámetros:\n- x (char*): El entero a clasificar.\n    Devuelve:\n    int: La clase a la que pertenece el entero x.\n\t>>> classify_integer(24)\n\t6\n*/\nint classify_integer(char *x)",
      "arb": "#include <assert.h>\n#include <math.h>\n#include <stdbool.h>\n#include <stdio.h>\n#include <string.h>\n/*\nتصنيف العدد الصحيح x بناءً على الطريقة التالية:\nإذا كان x رقمًا مكونًا من رقم واحد، فإن x ينتمي إلى فئته الخاصة.\nخلاف ذلك، اجمع أرقام x، احصل على x جديد، وكرر حتى يتم تحديد الفئة.\nالمعلمات:\n- x (char*): العدد الصحيح الذي سيتم تصنيفه.\n    يعيد:\n    int: الفئة التي ينتمي إليها العدد الصحيح x.\n\t>>> classify_integer(24)\n\t6\n*/\nint classify_integer(char *x)",
      "sw": "#include <assert.h>\n#include <math.h>\n#include <stdbool.h>\n#include <stdio.h>\n#include <string.h>\n/*\nTambua nambari x kulingana na njia ifuatayo:\nIkiwa x ni nambari ya tarakimu moja, x ni ya darasa lake lenyewe.\nVinginevyo, jumlisha tarakimu za x, pata x mpya, na rudia hadi darasa litakapobainishwa.\nVigezo:\n- x (char*): Nambari ya kutambuliwa.\n​    Inarudisha:\n​    int: Darasa ambalo nambari x ni ya.\n\t>>> classify_integer(24)\n\t6\n*/\nint classify_integer(char *x)",
      "tr": "#include <assert.h>\n#include <math.h>\n#include <stdbool.h>\n#include <stdio.h>\n#include <string.h>\n/*\nTam sayı x'i aşağıdaki yönteme göre sınıflandırın:\nEğer x tek basamaklı bir sayıysa, x kendi sınıfına aittir.\nAksi takdirde, x'in basamaklarını toplayın, yeni bir x elde edin ve sınıf belirlenene kadar yineleyin.\nParametreler:\n- x (char*): Sınıflandırılacak tam sayı.\n    Döndürür:\n    int: Tam sayı x'in ait olduğu sınıf.\n\t>>> classify_integer(24)\n\t6\n*/\nint classify_integer(char *x)",
      "vi": "#include <assert.h>\n#include <math.h>\n#include <stdbool.h>\n#include <stdio.h>\n#include <string.h>\n/*\nPhân loại số nguyên x dựa trên phương pháp sau:\nNếu x là một số có một chữ số, x thuộc về lớp của chính nó.\nNgược lại, tổng các chữ số của x, lấy một x mới, và lặp lại cho đến khi lớp được xác định.\nTham số:\n- x (char*): Số nguyên cần được phân loại.\n    Trả về:\n    int: Lớp mà số nguyên x thuộc về.\n\t>>> classify_integer(24)\n\t6\n*/\nint classify_integer(char *x)"
    },
    "prompt_bertscore": {
      "es": "0.9846683167790601",
      "arb": "0.9701851825459012",
      "sw": "0.9536233813752122",
      "tr": "0.9858475853512643",
      "vi": "0.9751576955047286"
    },
    "canonical_solution": "{\n\tint n = 0, i, a, t;\n    for (i = 0; i < strlen(x); i++)\n        n += x[i] - '0';\n    while (n > 9) {\n        t = n;\n        a = 0;\n        while (t) {\n            a += t % 10;\n            t /= 10;\n        }\n        n = a;\n    }\n    return n;\n}",
    "instruction": {
      "es": "int classify_integer(char *x)\n{\n\tint n = 0, i, a, t;\n    for (i = 0; i < strlen(x); i++)\n        n += x[i] - '0';\n    while (n > 9) {\n        t = n;\n        a = 0;\n        while (t) {\n            a += t % 10;\n            t /= 10;\n        }\n        n = a;\n    }\n    return n;\n}\n\nProporcione una descripción concisa en lenguaje natural (docstring) del código C en español utilizando como máximo 500 caracteres.",
      "arb": "int classify_integer(char *x)\n{\n\tint n = 0, i, a, t;\n    for (i = 0; i < strlen(x); i++)\n        n += x[i] - '0';\n    while (n > 9) {\n        t = n;\n        a = 0;\n        while (t) {\n            a += t % 10;\n            t /= 10;\n        }\n        n = a;\n    }\n    return n;\n}\n\nيرجى تقديم وصف موجز بلغة طبيعية (docstring) للكود المكتوب بلغة C باللغة العربية الفصحى باستخدام 500 حرف كحد أقصى.",
      "sw": "int classify_integer(char *x)\n{\n\tint n = 0, i, a, t;\n    for (i = 0; i < strlen(x); i++)\n        n += x[i] - '0';\n    while (n > 9) {\n        t = n;\n        a = 0;\n        while (t) {\n            a += t % 10;\n            t /= 10;\n        }\n        n = a;\n    }\n    return n;\n}\n\nToa maelezo mafupi ya lugha ya asili (docstring) ya msimbo wa C kwa Kiswahili kwa kutumia herufi zisizozidi 500.",
      "tr": "int classify_integer(char *x)\n{\n\tint n = 0, i, a, t;\n    for (i = 0; i < strlen(x); i++)\n        n += x[i] - '0';\n    while (n > 9) {\n        t = n;\n        a = 0;\n        while (t) {\n            a += t % 10;\n            t /= 10;\n        }\n        n = a;\n    }\n    return n;\n}\n\nC kodunun işlevini açıklayan kısa bir doğal dil tanımı (docstring) sağlayın. Açıklama, en fazla 500 karakter kullanılarak Türkçe olarak yazılmalıdır.",
      "vi": "int classify_integer(char *x)\n{\n\tint n = 0, i, a, t;\n    for (i = 0; i < strlen(x); i++)\n        n += x[i] - '0';\n    while (n > 9) {\n        t = n;\n        a = 0;\n        while (t) {\n            a += t % 10;\n            t /= 10;\n        }\n        n = a;\n    }\n    return n;\n}\n\nCung cấp mô tả ngắn gọn bằng ngôn ngữ tự nhiên (docstring) của mã C bằng tiếng Việt với tối đa 500 ký tự."
    },
    "instruction_bertscore": {
      "es": "0.9687963589217052",
      "arb": "0.8812990801846939",
      "sw": "0.9146175389298671",
      "tr": "0.8678881527483614",
      "vi": "0.923675282935439"
    },
    "level": "",
    "test": "int main()\n{\n\tassert(classify_integer(\"24\") == 6);\n\tassert(classify_integer(\"39\") == 3);\n\tassert(classify_integer(\"123456789\") == 9);\n\tassert(classify_integer(\"123456789012345678901234567890\") == 9);\n\tassert(classify_integer(\"12345\") == 6);\n    assert(classify_integer(\"999999999\") == 9);\n    return 0;\n}",
    "entry_point": "classify_integer",
    "signature": "int classify_integer(char *x)",
    "docstring": {
      "es": "Clasificar el entero x basado en el siguiente método:  \nSi x es un número de un solo dígito, x pertenece a su propia clase.  \nDe lo contrario, suma los dígitos de x, obtén un nuevo x, e itera hasta que se determine la clase.  \nParámetros:  \n- x (char*): El entero a clasificar.\n\n    Devuelve:  \n    int: La clase a la que pertenece el entero x.\n\t>>> classify_integer(24)\n\t6",
      "arb": "صنّف العدد الصحيح x بناءً على الطريقة التالية:\nإذا كان x رقمًا مكونًا من خانة واحدة، فإن x ينتمي إلى فئته الخاصة.\nوإلا، اجمع أرقام x، واحصل على x جديد، وكرر حتى يتم تحديد الفئة.\nالمعلمات:\n- x (char*): العدد الصحيح الذي سيتم تصنيفه.\n\n    العوائد:\n    int: الفئة التي ينتمي إليها العدد الصحيح x.\n\t>>> classify_integer(24)\n\t6",
      "sw": "Classify nambari x kulingana na njia ifuatayo:\nIkiwa x ni nambari ya tarakimu moja, x inahusiana na darasa lake lenyewe.\nVinginevyo, jumlisha tarakimu za x, pata x mpya, na rudia mpaka darasa litakapobainishwa.\nVigezo:\n- x (char*): Nambari ambayo inahitaji kuainishwa.\n\n    Inarudisha:\n    int: Darasa ambalo nambari x inahusiana.\n\t>>> classify_integer(24)\n\t6",
      "tr": "Tam sayı x'i aşağıdaki yönteme göre sınıflandırın:\nEğer x tek basamaklı bir sayıysa, x kendi sınıfına aittir.\nAksi takdirde, x'in basamaklarını toplayın, yeni bir x elde edin ve sınıf belirlenene kadar yineleyin.\nParametreler:\n- x (char*): Sınıflandırılacak tam sayı.\n\n    Döndürür:\n    int: Tam sayı x'in ait olduğu sınıf.\n\t>>> classify_integer(24)\n\t6",
      "vi": "Phân loại số nguyên x dựa trên phương pháp sau:\nNếu x là một số có một chữ số, x thuộc về lớp của chính nó.\nNgược lại, tổng các chữ số của x, lấy một x mới, và lặp lại cho đến khi xác định được lớp.\nTham số:\n- x (char*): Số nguyên cần được phân loại.\n\n    Trả về:\n    int: Lớp mà số nguyên x thuộc về.\n\t>>> classify_integer(24)\n\t6"
    },
    "docstring_bertscore": {
      "es": "0.9935121358642575",
      "arb": "0.9686738039766067",
      "sw": "0.9425789362985294",
      "tr": "0.9860265513245766",
      "vi": "0.9810560246695597"
    }
  },
  {
    "task_id": "C/27",
    "prompt": {
      "es": "#include <assert.h>\n#include <stdio.h>\n/*\nTransforma el caso de una letra dada.\n    Parámetros:\n- letter (char): La letra de entrada a ser transformada.\n    Devuelve:\n- char: La letra con su caso invertido. Si la entrada es minúscula, devuelve la versión en mayúscula,\ny si la entrada es mayúscula, devuelve la versión en minúscula.\n    >>> transform_letter_case('b')\n    'Z'\n*/\nchar transform_letter_case(char letter);",
      "arb": "#include <assert.h>\n#include <stdio.h>\n/*\nتحول حالة حرف معين.\n    المعاملات:\n- letter (char): الحرف المدخل الذي سيتم تحويله.\n    يعيد:\n- char: الحرف مع عكس حالته. إذا كان المدخل بحروف صغيرة، فإنه يعيد النسخة الكبيرة،\nوإذا كان المدخل بحروف كبيرة، فإنه يعيد النسخة الصغيرة.\n    >>> transform_letter_case('b')\n    'Z'\n*/\nchar transform_letter_case(char letter);",
      "sw": "#include <assert.h>\n#include <stdio.h>\n/*\nHubadilisha herufi kubwa au ndogo ya herufi iliyotolewa.\n    Vigezo:\n- letter (char): Herufi ya kuingiza inayopaswa kubadilishwa.\n    Inarudisha:\n- char: Herufi ikiwa na herufi kubwa au ndogo imebadilishwa. Ikiwa ingizo ni herufi ndogo, inarudisha toleo la herufi kubwa,\nna ikiwa ingizo ni herufi kubwa, inarudisha toleo la herufi ndogo.\n    >>> transform_letter_case('b')\n    'Z'\n*/\nchar transform_letter_case(char letter);",
      "tr": "#include <assert.h>\n#include <stdio.h>\n/*\nVerilen bir harfin durumunu değiştirir.\n    Parametreler:\n- letter (char): Dönüştürülecek giriş harfi.\n    Döndürür:\n- char: Harfin durumu ters çevrilmiş hali. Eğer giriş küçük harfse, büyük harf versiyonunu döndürür,\nve eğer giriş büyük harfse, küçük harf versiyonunu döndürür.\n    >>> transform_letter_case('b')\n    'Z'\n*/\nchar transform_letter_case(char letter);",
      "vi": "#include <assert.h>\n#include <stdio.h>\n/*\nChuyển đổi chữ hoa/thường của một chữ cái cho trước.\n    Tham số:\n- letter (char): Chữ cái đầu vào cần được chuyển đổi.\n    Trả về:\n- char: Chữ cái với chữ hoa/thường được đảo ngược. Nếu đầu vào là chữ thường, nó trả về phiên bản chữ hoa,\nvà nếu đầu vào là chữ hoa, nó trả về phiên bản chữ thường.\n    >>> transform_letter_case('b')\n    'Z'\n*/\nchar transform_letter_case(char letter);"
    },
    "prompt_bertscore": {
      "es": "0.9973169008129807",
      "arb": "0.9950324528006985",
      "sw": "0.9612867401059193",
      "tr": "0.9627957351106413",
      "vi": "0.9804126608653876"
    },
    "canonical_solution": "char transform_letter_case(char letter) {\n    if (letter >= 'A' && letter <= 'Z') {\n        return letter + 'a' - 'A';\n    }\n    else if (letter >= 'a' && letter <= 'z') {\n        return letter + 'A' - 'a';\n    } else {\n        // Non-alphabetic characters are returned unchanged\n        return letter;\n    }\n}",
    "instruction": {
      "es": "char transform_letter_case(char letter)\nchar transform_letter_case(char letter) {\n    if (letter >= 'A' && letter <= 'Z') {\n        return letter + 'a' - 'A';\n    }\n    else if (letter >= 'a' && letter <= 'z') {\n        return letter + 'A' - 'a';\n    } else {\n        // Non-alphabetic characters are returned unchanged\n        return letter;\n    }\n}\n\nProporcione una descripción concisa en lenguaje natural (docstring) del código C en español utilizando un máximo de 500 caracteres.",
      "arb": "char transform_letter_case(char letter)\nchar transform_letter_case(char letter) {\n    if (letter >= 'A' && letter <= 'Z') {\n        return letter + 'a' - 'A';\n    }\n    else if (letter >= 'a' && letter <= 'z') {\n        return letter + 'A' - 'a';\n    } else {\n        // Non-alphabetic characters are returned unchanged\n        return letter;\n    }\n}\n\nيرجى تقديم وصف موجز بلغة طبيعية (docstring) للكود المكتوب بلغة C باللغة العربية الفصحى، بحيث لا يتجاوز 500 حرف.",
      "sw": "char transform_letter_case(char letter)\nchar transform_letter_case(char letter) {\n    if (letter >= 'A' && letter <= 'Z') {\n        return letter + 'a' - 'A';\n    }\n    else if (letter >= 'a' && letter <= 'z') {\n        return letter + 'A' - 'a';\n    } else {\n        // Non-alphabetic characters are returned unchanged\n        return letter;\n    }\n}\n\nToa maelezo mafupi ya lugha asilia (docstring) ya msimbo wa C kwa Kiswahili kwa kutumia herufi zisizozidi 500.",
      "tr": "char transform_letter_case(char letter)\nchar transform_letter_case(char letter) {\n    if (letter >= 'A' && letter <= 'Z') {\n        return letter + 'a' - 'A';\n    }\n    else if (letter >= 'a' && letter <= 'z') {\n        return letter + 'A' - 'a';\n    } else {\n        // Non-alphabetic characters are returned unchanged\n        return letter;\n    }\n}\n\nVerilen C kodunun işlevini açıklayan, en fazla 500 karakter uzunluğunda özlü bir doğal dil açıklaması (docstring) sağlayın.",
      "vi": "char transform_letter_case(char letter)\nchar transform_letter_case(char letter) {\n    if (letter >= 'A' && letter <= 'Z') {\n        return letter + 'a' - 'A';\n    }\n    else if (letter >= 'a' && letter <= 'z') {\n        return letter + 'A' - 'a';\n    } else {\n        // Non-alphabetic characters are returned unchanged\n        return letter;\n    }\n}\n\nCung cấp mô tả ngắn gọn bằng ngôn ngữ tự nhiên (docstring) của mã C bằng tiếng Việt với tối đa 500 ký tự."
    },
    "instruction_bertscore": {
      "es": "0.9687963589217052",
      "arb": "0.8609607195793886",
      "sw": "0.9423429634058599",
      "tr": "0.8478703815780464",
      "vi": "0.923675282935439"
    },
    "level": "",
    "test": "int main() {\n    assert(transform_letter_case('b') == 'B');\n    assert(transform_letter_case('B') == 'b');\n\n    // Additional test cases\n    assert(transform_letter_case('z') == 'Z');\n    assert(transform_letter_case('Z') == 'z');\n    assert(transform_letter_case('m') == 'M');\n    assert(transform_letter_case('M') == 'm');\n    assert(transform_letter_case('1') == '1'); // Non-alphabetic, should be unchanged\n    assert(transform_letter_case('!') == '!'); // Non-alphabetic, should be unchanged\n    return 0;\n}",
    "entry_point": "transform_letter_case",
    "signature": "char transform_letter_case(char letter)",
    "docstring": {
      "es": "Transforma el caso de una letra dada.\n    Parámetros:\n- letter (char): La letra de entrada a transformar.\n    Retorna:\n- char: La letra con su caso invertido. Si la entrada es minúscula, devuelve la versión mayúscula,\ny si la entrada es mayúscula, devuelve la versión minúscula.\n    >>> transform_letter_case('b')\n    'Z'",
      "arb": "يحول حالة حرف معين.\n    المعلمات:\n- letter (char): الحرف المدخل الذي سيتم تحويله.\n    يعيد:\n- char: الحرف مع حالته معكوسة. إذا كان المدخل بحروف صغيرة، يعيد النسخة بحروف كبيرة،\nوإذا كان المدخل بحروف كبيرة، يعيد النسخة بحروف صغيرة.\n    >>> transform_letter_case('b')\n    'Z'",
      "sw": "Hubadilisha herufi ya kesi iliyotolewa.\n\n    Vigezo:\n- letter (char): Herufi ya kuingiza inayopaswa kubadilishwa.\n\n    Inarudisha:\n- char: Herufi ikiwa na kesi yake imebadilishwa. Ikiwa ingizo ni herufi ndogo, inarudisha toleo la herufi kubwa,\nna ikiwa ingizo ni herufi kubwa, inarudisha toleo la herufi ndogo.\n\n    >>> transform_letter_case('b')\n    'Z'",
      "tr": "Verilen bir harfin durumunu dönüştürür.\n    Parametreler:\n- letter (char): Dönüştürülecek giriş harfi.\n    Döndürülenler:\n- char: Harfin durumu ters çevrilmiş hali. Eğer giriş küçük harfse, büyük harf versiyonunu döndürür,\nve eğer giriş büyük harfse, küçük harf versiyonunu döndürür.\n    >>> transform_letter_case('b')\n    'Z'",
      "vi": "Chuyển đổi chữ hoa/thường của một chữ cái đã cho.\n    Tham số:\n- letter (char): Chữ cái đầu vào cần được chuyển đổi.\n    Trả về:\n- char: Chữ cái với chữ hoa/thường được đảo ngược. Nếu đầu vào là chữ thường, nó trả về phiên bản chữ hoa,\nvà nếu đầu vào là chữ hoa, nó trả về phiên bản chữ thường.\n    >>> transform_letter_case('b')\n    'Z'"
    },
    "docstring_bertscore": {
      "es": "0.9774038078534711",
      "arb": "0.9759271896008578",
      "sw": "0.9655702042729366",
      "tr": "0.9596140736672245",
      "vi": "0.9767385947073853"
    }
  },
  {
    "task_id": "C/28",
    "prompt": {
      "es": "#include <stdio.h>\n#include <assert.h>\n/*\nMostrar la información ASCII para un carácter dado.\n​    Parámetros:\n- character (char): El carácter de entrada para el cual se mostrará la información ASCII.\n​    Devuelve:\n- int: código ASCII correspondiente\n    >>> display_ascii_info('A')\n    65\n*/\nint display_ascii_info(char character)\n{",
      "arb": "#include <stdio.h>\n#include <assert.h>\n/*\nعرض معلومات ASCII لحرف معين.\n​    المعلمات:\n- character (char): الحرف المدخل الذي سيتم عرض معلومات ASCII له.\n​    يعيد:\n- int: الكود ASCII المقابل\n    >>> display_ascii_info('A')\n    65\n*/\nint display_ascii_info(char character)\n{",
      "sw": "#include <stdio.h>\n#include <assert.h>\n/*\nOnyesha taarifa za ASCII kwa herufi iliyotolewa.\n​    Vigezo:\n- character (char): Herufi ya pembejeo ambayo taarifa za ASCII zinapaswa kuonyeshwa.\n​    Inarejesha:\n- int: msimbo wa ASCII unaolingana\n    >>> display_ascii_info('A')\n    65\n*/\nint display_ascii_info(char character)\n{",
      "tr": "#include <stdio.h>\n#include <assert.h>\n/*\nBelirtilen bir karakter için ASCII bilgisini göster.\n​    Parametreler:\n- character (char): ASCII bilgisinin gösterileceği giriş karakteri.\n​    Döndürür:\n- int: Karşılık gelen ASCII kodu\n    >>> display_ascii_info('A')\n    65\n*/\nint display_ascii_info(char character)\n{",
      "vi": "#include <stdio.h>\n#include <assert.h>\n/*\nHiển thị thông tin ASCII cho một ký tự cho trước.\n    Tham số:\n- character (char): Ký tự đầu vào mà thông tin ASCII cần được hiển thị.\n    Trả về:\n- int: mã ASCII tương ứng\n    >>> display_ascii_info('A')\n    65\n*/\nint display_ascii_info(char character)\n{"
    },
    "prompt_bertscore": {
      "es": "0.9760094225786062",
      "arb": "0.9632660918529319",
      "sw": "0.9638629761479418",
      "tr": "0.9601841428607946",
      "vi": "0.9608348559890649"
    },
    "canonical_solution": "return character;\n}",
    "instruction": {
      "es": "int display_ascii_info(char character)\nreturn character;\n}\n\nProporcione una descripción concisa en lenguaje natural (docstring) del código C en español utilizando un máximo de 500 caracteres.",
      "arb": "int display_ascii_info(char character)\nreturn character;\n}\n\nيرجى تقديم وصف موجز بلغة طبيعية (docstring) للكود المكتوب بلغة C باللغة العربية الفصحى، بحيث لا يتجاوز 500 حرف.",
      "sw": "int display_ascii_info(char character)\nreturn character;\n}\n\nToa maelezo mafupi ya lugha asilia (docstring) ya msimbo wa C kwa Kiswahili kwa kutumia herufi zisizozidi 500.",
      "tr": "int display_ascii_info(char character)\nreturn character;\n}\n\nC kodunun işlevini açıklayan, en fazla 500 karakter uzunluğunda bir doğal dil açıklaması (docstring) sağlayın.",
      "vi": "int display_ascii_info(char character)\nreturn character;\n}\n\nCung cấp mô tả ngắn gọn bằng ngôn ngữ tự nhiên (docstring) của mã C bằng tiếng Việt, không quá 500 ký tự."
    },
    "instruction_bertscore": {
      "es": "0.9687963589217052",
      "arb": "0.8609607195793886",
      "sw": "0.9423429634058599",
      "tr": "0.8492371572299474",
      "vi": "0.9048961708212576"
    },
    "level": "",
    "test": "int main() {\n    assert(display_ascii_info('A') == 65);\n    assert(display_ascii_info('B') == 66); // Additional test case\n    assert(display_ascii_info('0') == 48); // Additional test case\n    assert(display_ascii_info(' ') == 32); // Additional test case\n    // printf(\"All tests passed.\\n\");\n    return 0;\n}",
    "entry_point": "display_ascii_info",
    "signature": "int display_ascii_info(char character)",
    "docstring": {
      "es": "Mostrar la información ASCII para un carácter dado.\n\n    Parámetros:\n- character (char): El carácter de entrada para el cual se mostrará la información ASCII.\n\n    Devuelve:\n- int: código ASCII correspondiente\n    >>> display_ascii_info('A')\n    65",
      "arb": "عرض معلومات ASCII للحرف المعطى.\n\n    المعلمات:\n- character (char): الحرف المدخل الذي سيتم عرض معلومات ASCII له.\n\n    يعيد:\n- int: رمز ASCII المقابل\n    >>> display_ascii_info('A')\n    65",
      "sw": "Onyesha taarifa za ASCII kwa herufi iliyotolewa.\n\n    Vigezo:\n- character (char): Herufi ya ingizo ambayo taarifa za ASCII zinapaswa kuonyeshwa.\n\n    Inarejesha:\n- int: nambari ya ASCII inayolingana\n    >>> display_ascii_info('A')\n    65",
      "tr": "Verilen bir karakter için ASCII bilgisini görüntüleyin.\n\n    Parametreler:\n- character (char): ASCII bilgisinin görüntüleneceği giriş karakteri.\n\n    Döndürülenler:\n- int: karşılık gelen ASCII kodu\n    >>> display_ascii_info('A')\n    65",
      "vi": "Hiển thị thông tin ASCII cho một ký tự cho trước.\n\n    Tham số:\n- character (char): Ký tự đầu vào mà thông tin ASCII cần được hiển thị.\n\n    Trả về:\n- int: mã ASCII tương ứng\n    >>> display_ascii_info('A')\n    65"
    },
    "docstring_bertscore": {
      "es": "0.9782811582465022",
      "arb": "0.9698344012929936",
      "sw": "0.9556446441326233",
      "tr": "0.9800324823160869",
      "vi": "0.9755384699451725"
    }
  },
  {
    "task_id": "C/29",
    "prompt": {
      "es": "#include <assert.h> // Usado para probar la función con afirmaciones\n#include <math.h> // No necesario para esta función\n#include <stdbool.h> // No necesario para esta función\n#include <stdio.h> // Necesario para funciones de entrada/salida\n#include <string.h> // No necesario para esta función\n/*\nEvalúa la calificación para un entero de entrada.\n    Parámetros:\n- score (int): La puntuación entera a evaluar.\n    Devuelve:\n​​    char: La calificación correspondiente a la puntuación de entrada.\n​​         Si la puntuación está entre 90 y 100 (inclusive), devuelve 'A'.\n​​         De lo contrario, devuelve 'B'.\n>>> evaluate_integer_grade(90)\nA\n*/\nchar evaluate_integer_grade(int score)",
      "arb": "#include <assert.h> // مستخدم لاختبار الدالة باستخدام التأكيدات\n#include <math.h> // غير مطلوب لهذه الدالة\n#include <stdbool.h> // غير مطلوب لهذه الدالة\n#include <stdio.h> // مطلوب لوظائف الإدخال/الإخراج\n#include <string.h> // غير مطلوب لهذه الدالة\n/*\nتقييم الدرجة لعدد صحيح مدخل.\n    المعاملات:\n- score (int): الدرجة الصحيحة التي سيتم تقييمها.\n    يعيد:\n​​    char: الدرجة المقابلة للدرجة المدخلة.\n​​         إذا كانت الدرجة بين 90 و 100 (شاملة)، يعيد 'A'.\n​​         خلاف ذلك، يعيد 'B'.\n>>> evaluate_integer_grade(90)\nA\n*/\nchar evaluate_integer_grade(int score)",
      "sw": "#include <assert.h> // Inatumika kwa kupima kazi na uthibitisho\n#include <math.h> // Haitajiki kwa kazi hii\n#include <stdbool.h> // Haitajiki kwa kazi hii\n#include <stdio.h> // Inahitajika kwa kazi za ingizo/utoaji\n#include <string.h> // Haitajiki kwa kazi hii\n/*\nTambua alama kwa namba kamili ya ingizo.\n    Vigezo:\n- score (int): Alama ya namba kamili inayotakiwa kutambuliwa.\n    Inarejesha:\n​​    char: Alama inayolingana na alama ya ingizo.\n​​         Ikiwa alama iko kati ya 90 na 100 (ikiwemo), inarejesha 'A'.\n​​         Vinginevyo, inarejesha 'B'.\n>>> evaluate_integer_grade(90)\nA\n*/\nchar evaluate_integer_grade(int score)",
      "tr": "#include <assert.h> // Fonksiyonu test etmek için assert kullanılır\n#include <math.h> // Bu fonksiyon için gerekli değil\n#include <stdbool.h> // Bu fonksiyon için gerekli değil\n#include <stdio.h> // Girdi/çıktı fonksiyonları için gerekli\n#include <string.h> // Bu fonksiyon için gerekli değil\n/*\nBir tamsayı notunu değerlendir.\n    Parametreler:\n- score (int): Değerlendirilecek tamsayı notu.\n    Döndürür:\n​​    char: Girdi notuna karşılık gelen harf notu.\n​​         Eğer not 90 ile 100 arasında (dahil) ise, 'A' döndürür.\n​​         Aksi takdirde, 'B' döndürür.\n>>> evaluate_integer_grade(90)\nA\n*/\nchar evaluate_integer_grade(int score)",
      "vi": "#include <assert.h> // Được sử dụng để kiểm tra hàm với các khẳng định\n#include <math.h> // Không cần thiết cho hàm này\n#include <stdbool.h> // Không cần thiết cho hàm này\n#include <stdio.h> // Cần thiết cho các hàm nhập/xuất\n#include <string.h> // Không cần thiết cho hàm này\n/*\nĐánh giá điểm cho một số nguyên đầu vào.\n    Tham số:\n- score (int): Điểm số nguyên cần được đánh giá.\n    Trả về:\n​​    char: Điểm tương ứng với điểm số đầu vào.\n​​         Nếu điểm số nằm trong khoảng từ 90 đến 100 (bao gồm), trả về 'A'.\n​​         Ngược lại, trả về 'B'.\n>>> evaluate_integer_grade(90)\nA\n*/\nchar evaluate_integer_grade(int score)"
    },
    "prompt_bertscore": {
      "es": "0.9624820977389872",
      "arb": "0.9677773850669963",
      "sw": "0.9366398879055862",
      "tr": "0.9455248234796578",
      "vi": "0.9616414939664476"
    },
    "canonical_solution": "{\n    return ((90 <= score && score <= 100) ? 'A' : 'B'); // Return 'A' or 'B' based on the condition\n}",
    "instruction": {
      "es": "char evaluate_integer_grade(int score)\n{\n    return ((90 <= score && score <= 100) ? 'A' : 'B'); // Return 'A' or 'B' based on the condition\n}\n\nProporcione una descripción concisa en lenguaje natural (docstring) del código C en español utilizando como máximo 500 caracteres.",
      "arb": "char evaluate_integer_grade(int score)\n{\n    return ((90 <= score && score <= 100) ? 'A' : 'B'); // Return 'A' or 'B' based on the condition\n}\n\nيرجى تقديم وصف موجز بلغة طبيعية (docstring) للكود المكتوب بلغة C باللغة العربية الفصحى، بحيث لا يتجاوز 500 حرف.",
      "sw": "char evaluate_integer_grade(int score)\n{\n    return ((90 <= score && score <= 100) ? 'A' : 'B'); // Return 'A' or 'B' based on the condition\n}\n\nToa maelezo mafupi ya lugha ya asili (docstring) ya msimbo wa C kwa Kiswahili kwa kutumia herufi zisizozidi 500.",
      "tr": "char evaluate_integer_grade(int score)\n{\n    return ((90 <= score && score <= 100) ? 'A' : 'B'); // Return 'A' or 'B' based on the condition\n}\n\nC kodunun işlevini açıklayan kısa bir doğal dil açıklaması (docstring) sağlayın. Açıklama Türkçe olmalı ve en fazla 500 karakter içermelidir.",
      "vi": "char evaluate_integer_grade(int score)\n{\n    return ((90 <= score && score <= 100) ? 'A' : 'B'); // Return 'A' or 'B' based on the condition\n}\n\nCung cấp mô tả ngắn gọn bằng ngôn ngữ tự nhiên (docstring) của mã C bằng tiếng Việt với tối đa 500 ký tự."
    },
    "instruction_bertscore": {
      "es": "0.9687963589217052",
      "arb": "0.8800316197233103",
      "sw": "0.9146175389298671",
      "tr": "0.8703118406577491",
      "vi": "0.923675282935439"
    },
    "level": "",
    "test": "int main() // Updated test function to reflect the correct usage of the evaluate_integer_grade function\n{\n    assert(evaluate_integer_grade(90) == 'A'); // Corrected the assertion to compare against character literals\n    assert(evaluate_integer_grade(89) == 'B'); // Additional test for a score less than 90\n    assert(evaluate_integer_grade(95) == 'A'); // Additional test within the 'A' range\n    assert(evaluate_integer_grade(100) == 'A'); // Additional test for the boundary condition\n    assert(evaluate_integer_grade(101) == 'B'); // Additional test for a score greater than 100\n\n    // Print \"All tests passed\" if all assertions hold true (optional)\n    // printf(\"All tests passed\\n\");\n\n    return 0;\n}",
    "entry_point": "evaluate_integer_grade",
    "signature": "char evaluate_integer_grade(int score)",
    "docstring": {
      "es": "Evalúa la calificación para un número entero de entrada.\n    Parámetros:\n- score (int): La puntuación entera a evaluar.\n    Devuelve:\n    char: La calificación correspondiente a la puntuación de entrada.\n    Si la puntuación está entre 90 y 100 (inclusive), devuelve 'A'.\n    De lo contrario, devuelve 'B'.\n>>> evaluate_integer_grade(90)\nA",
      "arb": "تقييم الدرجة لعدد صحيح مدخل.\n    المعلمات:\n- score (int): الدرجة الصحيحة التي سيتم تقييمها.\n    يعيد:\n    char: الدرجة المقابلة للدرجة المدخلة.\n    إذا كانت الدرجة بين 90 و 100 (شاملة)، يعيد 'A'.\n    خلاف ذلك، يعيد 'B'.\n>>> evaluate_integer_grade(90)\nA",
      "sw": "Tathmini daraja kwa nambari kamili ya ingizo.\n    Vigezo:\n- score (int): Alama ya nambari kamili itakayopimwa.\n    Inarejesha:\n    char: Daraja linalolingana na alama ya ingizo.\n    Ikiwa alama iko kati ya 90 na 100 (ikijumuisha), inarejesha 'A'.\n    Vinginevyo, inarejesha 'B'.\n>>> evaluate_integer_grade(90)\nA",
      "tr": "Girdi tamsayısı için notu değerlendirir.\n    Parametreler:\n- score (int): Değerlendirilecek tamsayı puanı.\n    Döndürülenler:\n    char: Girdi puanına karşılık gelen not.\n    Eğer puan 90 ile 100 arasında (dahil) ise, 'A' döner.\n    Aksi takdirde, 'B' döner.\n>>> evaluate_integer_grade(90)\nA",
      "vi": "Đánh giá điểm cho một số nguyên đầu vào.  \n    Tham số:  \n- score (int): Điểm số nguyên cần được đánh giá.  \n    Trả về:  \n    char: Điểm tương ứng với điểm số đầu vào.  \n    Nếu điểm số nằm trong khoảng từ 90 đến 100 (bao gồm cả 90 và 100), trả về 'A'.  \n    Ngược lại, trả về 'B'.  \n>>> evaluate_integer_grade(90)  \nA  "
    },
    "docstring_bertscore": {
      "es": "0.9940363214398085",
      "arb": "0.9903157757726441",
      "sw": "0.9834977879436215",
      "tr": "0.9937357936733028",
      "vi": "0.9486208752288485"
    }
  },
  {
    "task_id": "C/30",
    "prompt": {
      "es": "#include <assert.h>\n#include <stdbool.h>\n#include <stdio.h>\n#include <string.h>\n/*\nVerifica si una cadena de tres caracteres tiene exactamente dos caracteres que son iguales.\n​\nArgs:\n    s (char array): La cadena de tres caracteres a verificar.\n​\nReturns:\n    str: Devuelve 'Yes' si la entrada tiene exactamente dos caracteres iguales, de lo contrario 'No'.\n\t>>> check_two_equal_digits(112)\n\tYes\n*/\nconst char* check_two_equal_digits(const char s[4])",
      "arb": "#include <assert.h>\n#include <stdbool.h>\n#include <stdio.h>\n#include <string.h>\n/*\nيتحقق مما إذا كانت سلسلة مكونة من ثلاثة أحرف تحتوي على حرفين متطابقين بالضبط.\n\nالمعطيات:\n    s (مصفوفة char): السلسلة المكونة من ثلاثة أحرف التي سيتم التحقق منها.\n\nالقيم المعادة:\n    str: يعيد 'Yes' إذا كانت المدخلات تحتوي على حرفين متساويين بالضبط، وإلا يعيد 'No'.\n\t>>> check_two_equal_digits(112)\n\tYes\n*/\nconst char* check_two_equal_digits(const char s[4])",
      "sw": "#include <assert.h>\n#include <stdbool.h>\n#include <stdio.h>\n#include <string.h>\n/*\nHukagua kama mfuatano wa herufi tatu una herufi mbili ambazo ni sawa kabisa.\n\nArgs:\n    s (char array): Mfuatano wa herufi tatu ambao unapaswa kukaguliwa.\n\nReturns:\n    str: Inarudisha 'Yes' ikiwa ingizo lina herufi mbili sawa kabisa, vinginevyo 'No'.\n\t>>> check_two_equal_digits(112)\n\tYes\n*/\nconst char* check_two_equal_digits(const char s[4])",
      "tr": "#include <assert.h>\n#include <stdbool.h>\n#include <stdio.h>\n#include <string.h>\n/*\nÜç karakterli bir dizgede tam olarak iki karakterin aynı olup olmadığını kontrol eder.\n\nArgümanlar:\n    s (char dizi): Kontrol edilecek üç karakterli dizge.\n\nDöndürür:\n    str: Girdi tam olarak iki eşit karakter içeriyorsa 'Yes' döndürür, aksi takdirde 'No' döndürür.\n\t>>> check_two_equal_digits(112)\n\tYes\n*/\nconst char* check_two_equal_digits(const char s[4])",
      "vi": "#include <assert.h>\n#include <stdbool.h>\n#include <stdio.h>\n#include <string.h>\n/*\nKiểm tra xem một chuỗi ba ký tự có chính xác hai ký tự giống nhau hay không.\n\nTham số:\n    s (mảng char): Chuỗi ba ký tự cần kiểm tra.\n\nTrả về:\n    str: Trả về 'Yes' nếu đầu vào có chính xác hai ký tự bằng nhau, ngược lại trả về 'No'.\n\t>>> check_two_equal_digits(112)\n\tYes\n*/\nconst char* check_two_equal_digits(const char s[4])"
    },
    "prompt_bertscore": {
      "es": "0.9683476528909475",
      "arb": "0.9514853239537527",
      "sw": "0.9518575572878121",
      "tr": "0.959833560238268",
      "vi": "0.9521294822794488"
    },
    "canonical_solution": "{\n    if ((s[0] == s[1] && s[1] != s[2]) ||\n        (s[0] == s[2] && s[0] != s[1]) ||\n        (s[1] == s[2] && s[0] != s[1])) {\n        return \"Yes\";\n    } else {\n        return \"No\";\n    }\n}",
    "instruction": {
      "es": "const char* check_two_equal_digits(const char s[4])\n{\n    if ((s[0] == s[1] && s[1] != s[2]) ||\n        (s[0] == s[2] && s[0] != s[1]) ||\n        (s[1] == s[2] && s[0] != s[1])) {\n        return \"Yes\";\n    } else {\n        return \"No\";\n    }\n}\n\nProporcione una descripción concisa en lenguaje natural (docstring) del código C en español utilizando como máximo 500 caracteres.",
      "arb": "const char* check_two_equal_digits(const char s[4])\n{\n    if ((s[0] == s[1] && s[1] != s[2]) ||\n        (s[0] == s[2] && s[0] != s[1]) ||\n        (s[1] == s[2] && s[0] != s[1])) {\n        return \"Yes\";\n    } else {\n        return \"No\";\n    }\n}\n\nيرجى تقديم وصف موجز بلغة طبيعية (docstring) للكود المكتوب بلغة C باللغة العربية الفصحى، بحيث لا يتجاوز 500 حرف.",
      "sw": "const char* check_two_equal_digits(const char s[4])\n{\n    if ((s[0] == s[1] && s[1] != s[2]) ||\n        (s[0] == s[2] && s[0] != s[1]) ||\n        (s[1] == s[2] && s[0] != s[1])) {\n        return \"Yes\";\n    } else {\n        return \"No\";\n    }\n}\n\nToa maelezo mafupi ya lugha asilia (docstring) ya msimbo wa C kwa Kiswahili kwa kutumia herufi zisizozidi 500.",
      "tr": "const char* check_two_equal_digits(const char s[4])\n{\n    if ((s[0] == s[1] && s[1] != s[2]) ||\n        (s[0] == s[2] && s[0] != s[1]) ||\n        (s[1] == s[2] && s[0] != s[1])) {\n        return \"Yes\";\n    } else {\n        return \"No\";\n    }\n}\n\nC kodunun işlevini açıklayan kısa bir doğal dil tanımı (docstring) sağlayın. Açıklama en fazla 500 karakter olmalıdır.",
      "vi": "const char* check_two_equal_digits(const char s[4])\n{\n    if ((s[0] == s[1] && s[1] != s[2]) ||\n        (s[0] == s[2] && s[0] != s[1]) ||\n        (s[1] == s[2] && s[0] != s[1])) {\n        return \"Yes\";\n    } else {\n        return \"No\";\n    }\n}\n\nCung cấp mô tả ngắn gọn bằng ngôn ngữ tự nhiên (docstring) của mã C bằng tiếng Việt, sử dụng tối đa 500 ký tự."
    },
    "instruction_bertscore": {
      "es": "0.9687963589217052",
      "arb": "0.8727085148353161",
      "sw": "0.9423429634058599",
      "tr": "0.8359883121845394",
      "vi": "0.927643123426992"
    },
    "level": "",
    "test": "int main() {\n    // Testing the logic with various cases and using string comparison for assert.\n    assert(strcmp(check_two_equal_digits(\"112\"), \"Yes\") == 0);\n    assert(strcmp(check_two_equal_digits(\"123\"), \"No\") == 0);\n    assert(strcmp(check_two_equal_digits(\"232\"), \"Yes\") == 0);\n    assert(strcmp(check_two_equal_digits(\"444\"), \"No\") == 0); // All three characters are equal, not two.\n    assert(strcmp(check_two_equal_digits(\"121\"), \"Yes\") == 0);\n\n    // Additional test cases to cover more scenarios\n    assert(strcmp(check_two_equal_digits(\"787\"), \"Yes\") == 0);\n    assert(strcmp(check_two_equal_digits(\"999\"), \"No\") == 0); // All three characters are equal\n    assert(strcmp(check_two_equal_digits(\"890\"), \"No\") == 0);\n    assert(strcmp(check_two_equal_digits(\"556\"), \"Yes\") == 0);\n    assert(strcmp(check_two_equal_digits(\"353\"), \"Yes\") == 0); // No two characters are equal\n\n    \n    return 0;\n}",
    "entry_point": "check_two_equal_digits",
    "signature": "const char* check_two_equal_digits(const char s[4])",
    "docstring": {
      "es": "Verifica si una cadena de tres caracteres tiene exactamente dos caracteres que son iguales.\n\nArgs:\n    s (char array): La cadena de tres caracteres a verificar.\n\nReturns:\n    str: Devuelve 'Yes' si la entrada tiene exactamente dos caracteres iguales, de lo contrario 'No'.\n    >>> check_two_equal_digits(112)\n    Yes",
      "arb": "يتحقق مما إذا كانت سلسلة مكونة من ثلاثة أحرف تحتوي على حرفين متطابقين بالضبط.\n\nArgs:\n    s (char array): سلسلة مكونة من ثلاثة أحرف للتحقق منها.\n\nالقيم المعادة:\n    str: تعيد 'Yes' إذا كان المدخل يحتوي على حرفين متساويين بالضبط، وإلا تعيد 'No'.\n    >>> check_two_equal_digits(112)\n    Yes",
      "sw": "Hukagua kama mfuatano wa herufi tatu una herufi mbili ambazo ni sawa kabisa.\n\nArgs:\n    s (char array): Mfuatano wa herufi tatu wa kukaguliwa.\n\nReturns:\n    str: Inarudisha 'Yes' ikiwa ingizo lina herufi mbili zilizo sawa kabisa, vinginevyo 'No'.\n    >>> check_two_equal_digits(112)\n    Yes",
      "tr": "Üç karakterli bir dizgede tam olarak iki karakterin aynı olup olmadığını kontrol eder.\n\nArgs:\n    s (char array): Kontrol edilecek üç karakterli dizge.\n\nReturns:\n    str: Girdi tam olarak iki eşit karaktere sahipse 'Yes' döner, aksi takdirde 'No' döner.\n    >>> check_two_equal_digits(112)\n    Yes",
      "vi": "Kiểm tra xem một chuỗi ba ký tự có chính xác hai ký tự giống nhau hay không.\n\nArgs:\n    s (char array): Chuỗi ba ký tự cần được kiểm tra.\n\nReturns:\n    str: Trả về 'Yes' nếu đầu vào có chính xác hai ký tự bằng nhau, ngược lại trả về 'No'.\n    >>> check_two_equal_digits(112)\n    Yes"
    },
    "docstring_bertscore": {
      "es": "0.9777061232934062",
      "arb": "0.9266094509240864",
      "sw": "0.9437736980404542",
      "tr": "0.9621452206127521",
      "vi": "0.9571609884614436"
    }
  },
  {
    "task_id": "C/31",
    "prompt": {
      "es": "#include <assert.h>\n#include <stdio.h>\n#include <string.h>\n/*\nDada una cadena que consiste en letras minúsculas del alfabeto inglés, en cada ronda puedes cambiar uno de los caracteres por otro carácter. La pregunta es: ¿cuál es el número mínimo de rondas necesarias para hacer que la cadena esté compuesta por el mismo carácter?\nPor ejemplo:\n    >>> minRoundsToSameChar(\"aab\")\n    1\n    >>> minRoundsToSameChar(\"abc\")\n    2\n    >>> minRoundsToSameChar(\"aaa\")\n    0\n*/\nint minRoundsToSameChar(const char* s)",
      "arb": "#include <assert.h>\n#include <stdio.h>\n#include <string.h>\n/*\nبالنظر إلى سلسلة مكونة من أحرف إنجليزية صغيرة، في كل جولة يمكنك تغيير أحد الأحرف إلى حرف آخر. السؤال هو: ما هو الحد الأدنى لعدد الجولات اللازمة لجعل السلسلة مكونة من نفس الحرف؟\nعلى سبيل المثال:\n    >>> minRoundsToSameChar(\"aab\")\n    1\n    >>> minRoundsToSameChar(\"abc\")\n    2\n    >>> minRoundsToSameChar(\"aaa\")\n    0\n*/\nint minRoundsToSameChar(const char* s)",
      "sw": "#include <assert.h>\n#include <stdio.h>\n#include <string.h>\n/*\nUkipiwa kamba inayojumuisha herufi ndogo za Kiingereza, katika kila raundi unaweza kubadilisha moja ya herufi kuwa herufi nyingine. Swali ni: ni idadi gani ndogo ya raundi zinazohitajika kufanya kamba iwe na herufi sawa?\nKwa mfano:\n    >>> minRoundsToSameChar(\"aab\")\n    1\n    >>> minRoundsToSameChar(\"abc\")\n    2\n    >>> minRoundsToSameChar(\"aaa\")\n    0\n*/\nint minRoundsToSameChar(const char* s)",
      "tr": "#include <assert.h>\n#include <stdio.h>\n#include <string.h>\n/*\nKüçük harflerden oluşan bir dize verildiğinde, her turda karakterlerden birini başka bir karakterle değiştirebilirsiniz. Soru şu: Diziyi aynı karakterden oluşacak şekilde yapmak için gereken minimum tur sayısı nedir?\nÖrneğin:\n    >>> minRoundsToSameChar(\"aab\")\n    1\n    >>> minRoundsToSameChar(\"abc\")\n    2\n    >>> minRoundsToSameChar(\"aaa\")\n    0\n*/\nint minRoundsToSameChar(const char* s)",
      "vi": "#include <assert.h>\n#include <stdio.h>\n#include <string.h>\n/*\nCho một chuỗi bao gồm các chữ cái tiếng Anh viết thường, trong mỗi lượt bạn có thể thay đổi một trong các ký tự thành ký tự khác. Câu hỏi là: cần tối thiểu bao nhiêu lượt để làm cho chuỗi được tạo thành từ cùng một ký tự?\nVí dụ:\n    >>> minRoundsToSameChar(\"aab\")\n    1\n    >>> minRoundsToSameChar(\"abc\")\n    2\n    >>> minRoundsToSameChar(\"aaa\")\n    0\n*/\nint minRoundsToSameChar(const char* s)"
    },
    "prompt_bertscore": {
      "es": "0.9873289707330224",
      "arb": "0.9909927081112109",
      "sw": "0.97907150853264",
      "tr": "0.9870427443539511",
      "vi": "0.9815377033435693"
    },
    "canonical_solution": "{\n    int charCount[26] = {0}; // Assuming only lowercase letters\n    for (int i = 0; i < 26; i++) {\n        charCount[i] = 0;\n    }\n    while (*s) {\n        charCount[*s - 'a']++;\n        s++;\n    }\n    int maxCount = 0;\n    for (int i = 0; i < 26; i++) {\n        if (charCount[i] != 0 ) {\n            maxCount ++;\n        }\n    }\n\n    return maxCount - 1;\n}",
    "instruction": {
      "es": "int minRoundsToSameChar(const char* s)\n{\n    int charCount[26] = {0}; // Assuming only lowercase letters\n    for (int i = 0; i < 26; i++) {\n        charCount[i] = 0;\n    }\n    while (*s) {\n        charCount[*s - 'a']++;\n        s++;\n    }\n    int maxCount = 0;\n    for (int i = 0; i < 26; i++) {\n        if (charCount[i] != 0 ) {\n            maxCount ++;\n        }\n    }\n\n    return maxCount - 1;\n}\n\nProporcione una descripción concisa en lenguaje natural (docstring) del código C en español utilizando como máximo 500 caracteres.",
      "arb": "int minRoundsToSameChar(const char* s)\n{\n    int charCount[26] = {0}; // Assuming only lowercase letters\n    for (int i = 0; i < 26; i++) {\n        charCount[i] = 0;\n    }\n    while (*s) {\n        charCount[*s - 'a']++;\n        s++;\n    }\n    int maxCount = 0;\n    for (int i = 0; i < 26; i++) {\n        if (charCount[i] != 0 ) {\n            maxCount ++;\n        }\n    }\n\n    return maxCount - 1;\n}\n\nيرجى تقديم وصف موجز بلغة طبيعية (docstring) للكود المكتوب بلغة C باللغة العربية الفصحى، بحيث لا يتجاوز 500 حرف.",
      "sw": "int minRoundsToSameChar(const char* s)\n{\n    int charCount[26] = {0}; // Assuming only lowercase letters\n    for (int i = 0; i < 26; i++) {\n        charCount[i] = 0;\n    }\n    while (*s) {\n        charCount[*s - 'a']++;\n        s++;\n    }\n    int maxCount = 0;\n    for (int i = 0; i < 26; i++) {\n        if (charCount[i] != 0 ) {\n            maxCount ++;\n        }\n    }\n\n    return maxCount - 1;\n}\n\nToa maelezo mafupi ya lugha asilia (docstring) ya msimbo wa C kwa Kiswahili kwa kutumia herufi zisizozidi 500.",
      "tr": "int minRoundsToSameChar(const char* s)\n{\n    int charCount[26] = {0}; // Assuming only lowercase letters\n    for (int i = 0; i < 26; i++) {\n        charCount[i] = 0;\n    }\n    while (*s) {\n        charCount[*s - 'a']++;\n        s++;\n    }\n    int maxCount = 0;\n    for (int i = 0; i < 26; i++) {\n        if (charCount[i] != 0 ) {\n            maxCount ++;\n        }\n    }\n\n    return maxCount - 1;\n}\n\nC kodunun işlevini açıklayan kısa bir doğal dil açıklaması (docstring) sağlayın. Açıklama en fazla 500 karakter olmalıdır.",
      "vi": "int minRoundsToSameChar(const char* s)\n{\n    int charCount[26] = {0}; // Assuming only lowercase letters\n    for (int i = 0; i < 26; i++) {\n        charCount[i] = 0;\n    }\n    while (*s) {\n        charCount[*s - 'a']++;\n        s++;\n    }\n    int maxCount = 0;\n    for (int i = 0; i < 26; i++) {\n        if (charCount[i] != 0 ) {\n            maxCount ++;\n        }\n    }\n\n    return maxCount - 1;\n}\n\nCung cấp mô tả ngắn gọn bằng ngôn ngữ tự nhiên (docstring) cho mã C bằng tiếng Việt với tối đa 500 ký tự."
    },
    "instruction_bertscore": {
      "es": "0.9687963589217052",
      "arb": "0.8727085148353161",
      "sw": "0.9423429634058599",
      "tr": "0.8359883121845394",
      "vi": "0.9220669727401996"
    },
    "level": "",
    "test": "int main() {\n    assert(minRoundsToSameChar(\"aab\") == 1);\n    assert(minRoundsToSameChar(\"abc\") == 2);\n    assert(minRoundsToSameChar(\"aaa\") == 0);\n    assert(minRoundsToSameChar(\"abab\") == 1);\n    assert(minRoundsToSameChar(\"zzzzz\") == 0);\n    return 0;\n}",
    "entry_point": "minRoundsToSameChar",
    "signature": "int minRoundsToSameChar(const char* s)",
    "docstring": {
      "es": "Dada una cadena compuesta por letras minúsculas del alfabeto inglés, en cada ronda puedes cambiar uno de los caracteres por otro carácter. La pregunta es: ¿cuál es el número mínimo de rondas necesarias para hacer que la cadena esté compuesta por el mismo carácter?\nPor ejemplo:\n    >>> minRoundsToSameChar(\"aab\")\n    1\n    >>> minRoundsToSameChar(\"abc\")\n    2\n    >>> minRoundsToSameChar(\"aaa\")\n    0",
      "arb": "بالنظر إلى سلسلة تتكون من أحرف إنجليزية صغيرة، في كل جولة يمكنك تغيير أحد الأحرف إلى حرف آخر. السؤال هو: ما هو الحد الأدنى لعدد الجولات اللازمة لجعل السلسلة مكونة من نفس الحرف؟\n\nعلى سبيل المثال:\n    >>> minRoundsToSameChar(\"aab\")\n    1\n    >>> minRoundsToSameChar(\"abc\")\n    2\n    >>> minRoundsToSameChar(\"aaa\")\n    0",
      "sw": "Kwa kupewa kamba inayojumuisha herufi ndogo za Kiingereza, katika kila raundi unaweza kubadilisha moja ya herufi kuwa herufi nyingine. Swali ni: ni idadi ndogo ya raundi ngapi zinazohitajika ili kufanya kamba iwe na herufi sawa?\n\nKwa mfano:\n    >>> minRoundsToSameChar(\"aab\")\n    1\n    >>> minRoundsToSameChar(\"abc\")\n    2\n    >>> minRoundsToSameChar(\"aaa\")\n    0",
      "tr": "Verilen bir küçük harflerden oluşan İngilizce harf dizisi için, her turda karakterlerden birini başka bir karaktere değiştirebilirsiniz. Soru şu: Diziyi aynı karakterden oluşacak şekilde yapmak için gereken minimum tur sayısı nedir?\nÖrneğin:\n    >>> minRoundsToSameChar(\"aab\")\n    1\n    >>> minRoundsToSameChar(\"abc\")\n    2\n    >>> minRoundsToSameChar(\"aaa\")\n    0",
      "vi": "Cho một chuỗi bao gồm các chữ cái tiếng Anh viết thường, trong mỗi vòng bạn có thể thay đổi một trong các ký tự thành ký tự khác. Câu hỏi là: cần tối thiểu bao nhiêu vòng để làm cho chuỗi được tạo thành từ cùng một ký tự?\nVí dụ:\n    >>> minRoundsToSameChar(\"aab\")\n    1\n    >>> minRoundsToSameChar(\"abc\")\n    2\n    >>> minRoundsToSameChar(\"aaa\")\n    0"
    },
    "docstring_bertscore": {
      "es": "0.9832173218456002",
      "arb": "0.9778211302840254",
      "sw": "0.9755706480669001",
      "tr": "0.9688700507930692",
      "vi": "0.9903507347197061"
    }
  },
  {
    "task_id": "C/32",
    "prompt": {
      "es": "#include <assert.h>\n#include <stdio.h>\n/*\nDada una secuencia de n eventos, cada uno ocurriendo con una periodicidad de a_i años, el problema es encontrar el año Y_n cuando ocurre el n-ésimo evento, bajo la condición de que la cuenta regresiva para el evento i+1 solo puede comenzar en el año inmediatamente posterior a la ocurrencia del evento i.\n    >>> apocalypseYear(6, (int[]){3,2,4,5,9,18})\n    36\n*/\nint apocalypseYear(int n, int signs[])",
      "arb": "#include <assert.h>\n#include <stdio.h>\n/*\nبالنظر إلى سلسلة من الأحداث n، كل منها يحدث بشكل دوري كل a_i سنة، المشكلة هي إيجاد السنة Y_n عندما يحدث الحدث n، تحت شرط أن العد التنازلي للحدث i+1 يمكن أن يبدأ فقط في السنة التي تلي مباشرة حدوث الحدث i.\n    >>> apocalypseYear(6, (int[]){3,2,4,5,9,18})\n    36\n*/\nint apocalypseYear(int n, int signs[])",
      "sw": "#include <assert.h>\n#include <stdio.h>\n/*\nIkizingatiwa mlolongo wa matukio n, kila moja likitokea kwa vipindi vya miaka a_i, tatizo ni kupata mwaka Y_n ambapo tukio la n linatokea, chini ya sharti kwamba kuhesabu kwa tukio i+1 kunaweza kuanza tu katika mwaka unaofuata mara tu baada ya tukio i kutokea. \n    >>> apocalypseYear(6, (int[]){3,2,4,5,9,18})\n    36\n*/\nint apocalypseYear(int n, int signs[])",
      "tr": "#include <assert.h>\n#include <stdio.h>\n/*\nn olaydan oluşan bir dizi verildiğinde, her biri a_i yıl periyoduyla meydana gelen, problem n. olayın meydana geldiği Y_n yılını bulmaktır. Burada i+1. olayın geri sayımı, yalnızca i. olayın meydana gelmesinden hemen sonraki yılda başlayabilir.\n    >>> apocalypseYear(6, (int[]){3,2,4,5,9,18})\n    36\n*/\nint apocalypseYear(int n, int signs[])",
      "vi": "#include <assert.h>\n#include <stdio.h>\n/*\nCho một dãy gồm n sự kiện, mỗi sự kiện xảy ra với chu kỳ a_i năm, vấn đề là tìm năm Y_n khi sự kiện thứ n xảy ra, với điều kiện rằng việc đếm ngược cho sự kiện i+1 chỉ có thể bắt đầu vào năm ngay sau khi sự kiện i xảy ra.\n    >>> apocalypseYear(6, (int[]){3,2,4,5,9,18})\n    36\n*/\nint apocalypseYear(int n, int signs[])"
    },
    "prompt_bertscore": {
      "es": "0.999129005779162",
      "arb": "0.9535121483618327",
      "sw": "0.9469575444180625",
      "tr": "0.9421995522707527",
      "vi": "0.963335016595151"
    },
    "canonical_solution": "{\n    int year = 0;\n    for (int i = 0; i < n; ++i) {\n        int period = signs[i];\n        int nextOccurrence = (year / period + 1) * period;\n        year = nextOccurrence;\n    }\n    return year;\n}",
    "instruction": {
      "es": "int apocalypseYear(int n, int signs[])\n{\n    int year = 0;\n    for (int i = 0; i < n; ++i) {\n        int period = signs[i];\n        int nextOccurrence = (year / period + 1) * period;\n        year = nextOccurrence;\n    }\n    return year;\n}\n\nProporcione una descripción concisa en lenguaje natural (docstring) del código C en español utilizando como máximo 500 caracteres.",
      "arb": "int apocalypseYear(int n, int signs[])\n{\n    int year = 0;\n    for (int i = 0; i < n; ++i) {\n        int period = signs[i];\n        int nextOccurrence = (year / period + 1) * period;\n        year = nextOccurrence;\n    }\n    return year;\n}\n\nيرجى تقديم وصف موجز بلغة طبيعية (docstring) للكود المكتوب بلغة C باللغة العربية الفصحى، بحيث لا يتجاوز 500 حرف.",
      "sw": "int apocalypseYear(int n, int signs[])\n{\n    int year = 0;\n    for (int i = 0; i < n; ++i) {\n        int period = signs[i];\n        int nextOccurrence = (year / period + 1) * period;\n        year = nextOccurrence;\n    }\n    return year;\n}\n\nToa maelezo mafupi ya lugha ya asili (docstring) ya msimbo wa C kwa Kiswahili kwa kutumia herufi zisizozidi 500.",
      "tr": "int apocalypseYear(int n, int signs[])\n{\n    int year = 0;\n    for (int i = 0; i < n; ++i) {\n        int period = signs[i];\n        int nextOccurrence = (year / period + 1) * period;\n        year = nextOccurrence;\n    }\n    return year;\n}\n\nC kodunun işlevini açıklayan, en fazla 500 karakter uzunluğunda özlü bir doğal dil açıklaması (docstring) sağlayın.",
      "vi": "int apocalypseYear(int n, int signs[])\n{\n    int year = 0;\n    for (int i = 0; i < n; ++i) {\n        int period = signs[i];\n        int nextOccurrence = (year / period + 1) * period;\n        year = nextOccurrence;\n    }\n    return year;\n}\n\nCung cấp mô tả ngắn gọn bằng ngôn ngữ tự nhiên (docstring) của mã C bằng tiếng Việt, sử dụng tối đa 500 ký tự."
    },
    "instruction_bertscore": {
      "es": "0.9687963589217052",
      "arb": "0.8727085148353161",
      "sw": "0.9146175389298671",
      "tr": "0.8690445788267465",
      "vi": "0.927643123426992"
    },
    "level": "",
    "test": "int main() {\n    assert(apocalypseYear(6, (int[]){3,2,4,5,9,18}) == 36);\n    assert(apocalypseYear(5, (int[]){1, 2,3,4,5}) == 5);\n    assert(apocalypseYear(5, (int[]){1,1,1,1,1}) == 5);\n    assert(apocalypseYear(6, (int[]){50,30,711,200,503,1006}) == 2012);\n    assert(apocalypseYear(2, (int[]){1, 2}) == 2);\n    assert(apocalypseYear(3, (int[]){3, 1, 2}) == 6);\n    assert(apocalypseYear(3, (int[]){2, 3, 4}) == 4);\n    assert(apocalypseYear(4, (int[]){1, 2, 3, 4}) == 4);\n    assert(apocalypseYear(4, (int[]){5, 7, 11, 13}) == 13);\n    assert(apocalypseYear(5, (int[]){2, 2, 2, 2, 2}) == 10);\n    assert(apocalypseYear(3, (int[]){6, 10, 15}) == 15);\n    assert(apocalypseYear(3, (int[]){4, 6, 14}) == 14);\n    assert(apocalypseYear(4, (int[]){50, 30, 711, 200}) == 800);\n    assert(apocalypseYear(6, (int[]){1, 1, 1, 1, 1, 1}) == 6);\n    assert(apocalypseYear(2, (int[]){1000000, 999999}) == 1999998);\n    return 0;\n}",
    "entry_point": "apocalypseYear",
    "signature": "int apocalypseYear(int n, int signs[])",
    "docstring": {
      "es": "Dada una secuencia de n eventos, cada uno ocurriendo con una periodicidad de a_i años, el problema es encontrar el año Y_n cuando ocurre el n-ésimo evento, bajo la condición de que la cuenta regresiva para el evento i+1 solo puede comenzar en el año inmediatamente posterior a la ocurrencia del evento i.\n    >>> apocalypseYear(6, (int[]){3,2,4,5,9,18})\n    36",
      "arb": "بالنظر إلى تسلسل من n أحداث، كل منها يحدث بتكرار دوري كل a_i سنة، فإن المشكلة هي إيجاد السنة Y_n عندما يحدث الحدث n، بشرط أن العد التنازلي للحدث i+1 يمكن أن يبدأ فقط في السنة التي تلي مباشرة حدوث الحدث i.\n    >>> apocalypseYear(6, (int[]){3,2,4,5,9,18})\n    36",
      "sw": "Kwa kuzingatia mlolongo wa matukio n, kila moja likitokea kwa kipindi cha miaka a_i, tatizo ni kupata mwaka Y_n ambapo tukio la n linatokea, chini ya sharti kwamba kuhesabu kwa tukio i+1 kunaweza kuanza tu katika mwaka unaofuata mara baada ya tukio i kutokea.\n    >>> apocalypseYear(6, (int[]){3,2,4,5,9,18})\n    36",
      "tr": "Verilen n olayından oluşan bir dizide, her biri a_i yıllık bir periyodiklikle meydana gelen olaylar için, n'inci olayın gerçekleştiği Y_n yılını bulma problemi, i+1 olayının geri sayımının yalnızca i olayının gerçekleştiği yılın hemen ardından başlayabileceği şartı altında çözülmelidir. \n    >>> apocalypseYear(6, (int[]){3,2,4,5,9,18})\n    36",
      "vi": "Đưa ra một chuỗi gồm n sự kiện, mỗi sự kiện xảy ra với chu kỳ a_i năm, vấn đề là tìm năm Y_n khi sự kiện thứ n xảy ra, với điều kiện rằng đếm ngược cho sự kiện i+1 chỉ có thể bắt đầu vào năm ngay sau khi sự kiện i xảy ra.\n    >>> apocalypseYear(6, (int[]){3,2,4,5,9,18})\n    36"
    },
    "docstring_bertscore": {
      "es": "0.9986512997127731",
      "arb": "0.9453810150837885",
      "sw": "0.9270331295268338",
      "tr": "0.9250615243646815",
      "vi": "0.9499769248401737"
    }
  },
  {
    "task_id": "C/33",
    "prompt": {
      "es": "#include <stdio.h>\n#include <assert.h>\n#include <stdbool.h>\n/*\nEste problema introduce una nueva operación de módulo, denotada por el símbolo \"⊕\". Al calcular x ⊕ y, si x no es un múltiplo de y, el resultado es el resto de x dividido por y. De lo contrario, divide x por y repetidamente hasta que x ya no sea un múltiplo de y, denotando el valor final como x'. Entonces el resultado es el resto de x' dividido por y. Por ejemplo, 4⊕5=4, 20⊕5=4, 100⊕5=4.\nDado un número primo p, habrá varias consultas. Para cada consulta, se da un número entero n, y necesitas calcular el valor de n! ⊕ p, donde n! es el factorial de n, es decir, el producto de todos los enteros positivos menores o iguales a n.\n    >>> newModuloFactorial(3, 7)\n    6\n*/\nunsigned long long newModuloFactorial(unsigned long long n, unsigned long long p)",
      "arb": "#include <stdio.h>\n#include <assert.h>\n#include <stdbool.h>\n/*\nهذه المشكلة تقدم عملية باقي جديدة، يرمز لها بالرمز \"⊕\". عند حساب x ⊕ y، إذا لم يكن x مضاعفًا لـ y، فإن النتيجة هي باقي قسمة x على y. خلاف ذلك، قم بقسمة x على y بشكل متكرر حتى لا يكون x مضاعفًا لـ y، مع تسمية القيمة النهائية x'. ثم تكون النتيجة هي باقي قسمة x' على y. على سبيل المثال، 4⊕5=4، 20⊕5=4، 100⊕5=4.\nمعطى عدد أولي p، سيكون هناك عدة استفسارات. لكل استفسار، يُعطى عدد صحيح n، وتحتاج إلى حساب قيمة n! ⊕ p، حيث n! هو مضروب n، أي حاصل ضرب جميع الأعداد الصحيحة الموجبة الأقل من أو تساوي n.\n    >>> newModuloFactorial(3, 7)\n    6\n*/\nunsigned long long newModuloFactorial(unsigned long long n, unsigned long long p)",
      "sw": "#include <stdio.h>\n#include <assert.h>\n#include <stdbool.h>\n/*\nTatizo hili linaanzisha operesheni mpya ya modulo, inayojulikana kwa alama \"⊕\". Wakati wa kuhesabu x ⊕ y, ikiwa x si kigezo cha y, matokeo ni baki ya x iliyogawanywa na y. Vinginevyo, gawanya x kwa y mara kwa mara hadi x isiwe tena kigezo cha y, ukionyesha thamani ya mwisho kama x'. Kisha matokeo ni baki ya x' iliyogawanywa na y. Kwa mfano, 4⊕5=4, 20⊕5=4, 100⊕5=4.\nUkipata namba ya kwanza p, kutakuwa na maswali kadhaa. Kwa kila swali, namba nzima n inatolewa, na unahitaji kuhesabu thamani ya n! ⊕ p, ambapo n! ni factorial ya n, yaani, bidhaa ya namba zote chanya zilizo chini au sawa na n.\n    >>> newModuloFactorial(3, 7)\n    6\n*/\nunsigned long long newModuloFactorial(unsigned long long n, unsigned long long p)",
      "tr": "#include <stdio.h>\n#include <assert.h>\n#include <stdbool.h>\n/*\nBu problem, \"⊕\" sembolüyle gösterilen yeni bir modül işlemi tanıtır. x ⊕ y hesaplanırken, eğer x, y'nin katı değilse, sonuç x'in y'ye bölümünden kalan olur. Aksi takdirde, x y'nin katı olmayana kadar x'i y'ye tekrar tekrar bölün, son değeri x' olarak belirtin. Sonra sonuç, x' in y'ye bölümünden kalan olur. Örneğin, 4⊕5=4, 20⊕5=4, 100⊕5=4.\nVerilen bir asal sayı p için birkaç sorgu olacaktır. Her sorgu için bir tamsayı n verilir ve n! ⊕ p değerini hesaplamanız gerekir, burada n! n'nin faktöriyelidir, yani n'ye eşit veya daha küçük olan tüm pozitif tamsayıların çarpımıdır.\n    >>> newModuloFactorial(3, 7)\n    6\n*/\nunsigned long long newModuloFactorial(unsigned long long n, unsigned long long p)",
      "vi": "#include <stdio.h>\n#include <assert.h>\n#include <stdbool.h>\n/*\nVấn đề này giới thiệu một phép toán modulo mới, được ký hiệu bằng biểu tượng \"⊕\". Khi tính toán x ⊕ y, nếu x không phải là bội số của y, kết quả là phần dư của x chia cho y. Ngược lại, chia x cho y liên tục cho đến khi x không còn là bội số của y, ký hiệu giá trị cuối cùng là x'. Sau đó kết quả là phần dư của x' chia cho y. Ví dụ, 4⊕5=4, 20⊕5=4, 100⊕5=4.\nCho một số nguyên tố p, sẽ có một số truy vấn. Đối với mỗi truy vấn, một số nguyên n được cho, và bạn cần tính giá trị của n! ⊕ p, trong đó n! là giai thừa của n, tức là tích của tất cả các số nguyên dương nhỏ hơn hoặc bằng n.\n    >>> newModuloFactorial(3, 7)\n    6\n*/\nunsigned long long newModuloFactorial(unsigned long long n, unsigned long long p)"
    },
    "prompt_bertscore": {
      "es": "0.9980532236354771",
      "arb": "0.9756644016067486",
      "sw": "0.983267376701621",
      "tr": "0.9827481568855958",
      "vi": "0.9802988456570546"
    },
    "canonical_solution": "{\n    unsigned long long pj[p];\n    pj[0] = 1;\n    pj[1] = 1;\n    for (unsigned long long i = 2; i < p; i++) pj[i] = i * pj[i - 1] % p;\n    \n    unsigned long long ans = 1;\n    while (n) {\n        ans = ans * pj[n % p] % p;\n        ans = (n / p) & 1 ? p - ans : ans;\n        n /= p;\n    }\n    return ans;\n}",
    "instruction": {
      "es": "unsigned long long newModuloFactorial(unsigned long long n, unsigned long long p)\n{\n    unsigned long long pj[p];\n    pj[0] = 1;\n    pj[1] = 1;\n    for (unsigned long long i = 2; i < p; i++) pj[i] = i * pj[i - 1] % p;\n    \n    unsigned long long ans = 1;\n    while (n) {\n        ans = ans * pj[n % p] % p;\n        ans = (n / p) & 1 ? p - ans : ans;\n        n /= p;\n    }\n    return ans;\n}\n\nProporcione una descripción concisa en lenguaje natural (docstring) del código C en español utilizando como máximo 500 caracteres.",
      "arb": "unsigned long long newModuloFactorial(unsigned long long n, unsigned long long p)\n{\n    unsigned long long pj[p];\n    pj[0] = 1;\n    pj[1] = 1;\n    for (unsigned long long i = 2; i < p; i++) pj[i] = i * pj[i - 1] % p;\n    \n    unsigned long long ans = 1;\n    while (n) {\n        ans = ans * pj[n % p] % p;\n        ans = (n / p) & 1 ? p - ans : ans;\n        n /= p;\n    }\n    return ans;\n}\n\nيرجى تقديم وصف موجز بلغة طبيعية (docstring) للكود المكتوب بلغة C باللغة العربية الفصحى، بحيث لا يتجاوز 500 حرف.",
      "sw": "unsigned long long newModuloFactorial(unsigned long long n, unsigned long long p)\n{\n    unsigned long long pj[p];\n    pj[0] = 1;\n    pj[1] = 1;\n    for (unsigned long long i = 2; i < p; i++) pj[i] = i * pj[i - 1] % p;\n    \n    unsigned long long ans = 1;\n    while (n) {\n        ans = ans * pj[n % p] % p;\n        ans = (n / p) & 1 ? p - ans : ans;\n        n /= p;\n    }\n    return ans;\n}\n\nToa maelezo mafupi ya lugha ya asili (docstring) ya msimbo wa C kwa Kiswahili kwa kutumia herufi zisizozidi 500.",
      "tr": "unsigned long long newModuloFactorial(unsigned long long n, unsigned long long p)\n{\n    unsigned long long pj[p];\n    pj[0] = 1;\n    pj[1] = 1;\n    for (unsigned long long i = 2; i < p; i++) pj[i] = i * pj[i - 1] % p;\n    \n    unsigned long long ans = 1;\n    while (n) {\n        ans = ans * pj[n % p] % p;\n        ans = (n / p) & 1 ? p - ans : ans;\n        n /= p;\n    }\n    return ans;\n}\n\nVerilen C kodunun işlevini açıklayan, en fazla 500 karakter uzunluğunda özlü bir doğal dil açıklaması (docstring) sağlayın.",
      "vi": "unsigned long long newModuloFactorial(unsigned long long n, unsigned long long p)\n{\n    unsigned long long pj[p];\n    pj[0] = 1;\n    pj[1] = 1;\n    for (unsigned long long i = 2; i < p; i++) pj[i] = i * pj[i - 1] % p;\n    \n    unsigned long long ans = 1;\n    while (n) {\n        ans = ans * pj[n % p] % p;\n        ans = (n / p) & 1 ? p - ans : ans;\n        n /= p;\n    }\n    return ans;\n}\n\nCung cấp mô tả ngắn gọn bằng ngôn ngữ tự nhiên (docstring) của mã C bằng tiếng Việt, sử dụng tối đa 500 ký tự."
    },
    "instruction_bertscore": {
      "es": "0.9687963589217052",
      "arb": "0.8727085148353161",
      "sw": "0.9146175389298671",
      "tr": "0.8475241688239026",
      "vi": "0.927643123426992"
    },
    "level": "",
    "test": "int main() {\n    // Test cases\n    assert(newModuloFactorial(3, 7) == 6);\n    assert(newModuloFactorial(10, 3) == 1);\n    assert(newModuloFactorial(11, 7) == 4);\n    assert(newModuloFactorial(45, 7) == 1);\n    assert(newModuloFactorial(14, 7) == 2);\n    assert(newModuloFactorial(1919, 10007) == 3152);\n    assert(newModuloFactorial(810, 10007) == 3679);\n    assert(newModuloFactorial(3, 7) == 6);\n    assert(newModuloFactorial(10, 3) == 1);\n    assert(newModuloFactorial(1, 2) == 1);\n    assert(newModuloFactorial(5, 11) == 10);\n    assert(newModuloFactorial(6, 13) == 5);\n    assert(newModuloFactorial(8, 17) == 13);\n    assert(newModuloFactorial(15, 19) == 16);\n    assert(newModuloFactorial(21, 23) == 1);\n    assert(newModuloFactorial(30, 29) == 28);\n    assert(newModuloFactorial(100, 101) == 100);\n    return 0;\n}",
    "entry_point": "newModuloFactorial",
    "signature": "unsigned long long newModuloFactorial(unsigned long long n, unsigned long long p)",
    "docstring": {
      "es": "Este problema introduce una nueva operación de módulo, denotada por el símbolo \"⊕\". Al calcular x ⊕ y, si x no es un múltiplo de y, el resultado es el residuo de x dividido por y. De lo contrario, divide x por y repetidamente hasta que x ya no sea un múltiplo de y, denotando el valor final como x'. Entonces, el resultado es el residuo de x' dividido por y. Por ejemplo, 4⊕5=4, 20⊕5=4, 100⊕5=4. Dado un número primo p, habrá varias consultas. Para cada consulta, se da un número entero n, y necesitas calcular el valor de n! ⊕ p, donde n! es el factorial de n, es decir, el producto de todos los enteros positivos menores o iguales a n.\n    >>> newModuloFactorial(3, 7)\n    6",
      "arb": "هذه المشكلة تقدم عملية باقي جديدة، يرمز لها بالرمز \"⊕\". عند حساب x ⊕ y، إذا لم يكن x مضاعفًا لـ y، فإن النتيجة هي باقي قسمة x على y. أما إذا كان x مضاعفًا لـ y، فقم بقسمة x على y بشكل متكرر حتى لا يكون x مضاعفًا لـ y، واعتبر القيمة النهائية x'. ثم تكون النتيجة هي باقي قسمة x' على y. على سبيل المثال، 4⊕5=4، 20⊕5=4، 100⊕5=4. بالنظر إلى عدد أولي p، سيكون هناك عدة استفسارات. لكل استفسار، يُعطى عدد صحيح n، وتحتاج إلى حساب قيمة n! ⊕ p، حيث n! هو مضروب n، أي حاصل ضرب جميع الأعداد الصحيحة الموجبة الأقل من أو تساوي n.\n    >>> newModuloFactorial(3, 7)\n    6",
      "sw": "Tatizo hili linaanzisha operesheni mpya ya modulo, inayowakilishwa na alama \"⊕\". Wakati wa kuhesabu x ⊕ y, ikiwa x si kigezo cha y, matokeo ni mabaki ya x kugawanywa na y. Vinginevyo, gawanya x kwa y mara kwa mara hadi x isiwe tena kigezo cha y, ukionyesha thamani ya mwisho kama x'. Kisha matokeo ni mabaki ya x' kugawanywa na y. Kwa mfano, 4⊕5=4, 20⊕5=4, 100⊕5=4. Ukipewa nambari ya kwanza p, kutakuwa na maswali kadhaa. Kwa kila swali, nambari nzima n inatolewa, na unahitaji kuhesabu thamani ya n! ⊕ p, ambapo n! ni factorial ya n, yaani, bidhaa ya nambari zote chanya zilizo chini au sawa na n.\n    >>> newModuloFactorial(3, 7)\n    6",
      "tr": "Bu problem, \"⊕\" sembolü ile gösterilen yeni bir modül işlemi tanıtmaktadır. x ⊕ y hesaplanırken, eğer x, y'nin katı değilse, sonuç x'in y'ye bölünmesinden kalan değerdir. Aksi takdirde, x artık y'nin katı olmayana kadar x'i y'ye tekrar tekrar bölün, son değeri x' olarak belirtin. Sonra sonuç, x' in y'ye bölünmesinden kalan değerdir. Örneğin, 4⊕5=4, 20⊕5=4, 100⊕5=4.\nVerilen bir asal sayı p için, birkaç sorgu olacaktır. Her sorgu için bir tamsayı n verilir ve n! ⊕ p değerini hesaplamanız gerekir; burada n!, n'ye eşit veya n'den küçük tüm pozitif tamsayıların çarpımıdır.\n    >>> newModuloFactorial(3, 7)\n    6",
      "vi": "Vấn đề này giới thiệu một phép toán modulo mới, được ký hiệu bằng biểu tượng \"⊕\". Khi tính x ⊕ y, nếu x không phải là bội số của y, kết quả là phần dư của x chia cho y. Ngược lại, chia x cho y liên tục cho đến khi x không còn là bội số của y, ký hiệu giá trị cuối cùng là x'. Sau đó kết quả là phần dư của x' chia cho y. Ví dụ, 4⊕5=4, 20⊕5=4, 100⊕5=4. Cho một số nguyên tố p, sẽ có một số truy vấn. Đối với mỗi truy vấn, một số nguyên n được cho, và bạn cần tính giá trị của n! ⊕ p, trong đó n! là giai thừa của n, tức là tích của tất cả các số nguyên dương nhỏ hơn hoặc bằng n.\n    >>> newModuloFactorial(3, 7)\n    6"
    },
    "docstring_bertscore": {
      "es": "0.9940379104828568",
      "arb": "0.9563644806334937",
      "sw": "0.9826708896673733",
      "tr": "0.9629685435421417",
      "vi": "0.981303120863567"
    }
  },
  {
    "task_id": "C/34",
    "prompt": {
      "es": "#include <stdio.h>\n#include <assert.h>\n/*\nSe te da un arreglo a de n enteros. Puedes realizar como máximo una operación donde seleccionas tres enteros i, j, x (1 <= i <= j <= n) y reemplazas todos los elementos de a[i] a a[j] con x, a un costo de (j - i + 1).\nEncuentra el costo mínimo para hacer que todos los elementos en el arreglo sean iguales.\n    >>> makeEqualAgain(3, (int[]){1, 2, 1})\n    1\n*/\nint makeEqualAgain(int n, int a[])",
      "arb": "#include <stdio.h>\n#include <assert.h>\n/*\nلديك مصفوفة a تحتوي على n عدد صحيح. يمكنك تنفيذ عملية واحدة على الأكثر حيث تختار ثلاثة أعداد صحيحة i، j، x (1 <= i <= j <= n) وتستبدل جميع العناصر من a[i] إلى a[j] بـ x، بتكلفة (j - i + 1).\nابحث عن الحد الأدنى للتكلفة لجعل جميع العناصر في المصفوفة متساوية.\n    >>> makeEqualAgain(3, (int[]){1, 2, 1})\n    1\n*/\nint makeEqualAgain(int n, int a[])",
      "sw": "#include <stdio.h>\n#include <assert.h>\n/*\nUmepewa safu a ya n nambari za mzima. Unaweza kufanya operesheni moja tu ambapo unachagua nambari tatu i, j, x (1 <= i <= j <= n) na kubadilisha vipengele vyote kutoka a[i] hadi a[j] na x, kwa gharama ya (j - i + 1).\nPata gharama ndogo zaidi ya kufanya vipengele vyote katika safu kuwa sawa.\n    >>> makeEqualAgain(3, (int[]){1, 2, 1})\n    1\n*/\nint makeEqualAgain(int n, int a[])",
      "tr": "#include <stdio.h>\n#include <assert.h>\n/*\nSize n olan bir tamsayı dizisi verilmektedir. En fazla bir işlem yaparak i, j, x (1 <= i <= j <= n) üç tamsayısını seçebilir ve a[i] ile a[j] arasındaki tüm elemanları x ile değiştirebilirsiniz, bu işlemin maliyeti (j - i + 1) olacaktır.\nDizideki tüm elemanları eşit yapmak için minimum maliyeti bulun.\n    >>> makeEqualAgain(3, (int[]){1, 2, 1})\n    1\n*/\nint makeEqualAgain(int n, int a[])",
      "vi": "#include <stdio.h>\n#include <assert.h>\n/*\nBạn được cho một mảng a gồm n số nguyên. Bạn có thể thực hiện tối đa một thao tác, trong đó bạn chọn ba số nguyên i, j, x (1 <= i <= j <= n) và thay thế tất cả các phần tử từ a[i] đến a[j] bằng x, với chi phí là (j - i + 1).\nTìm chi phí tối thiểu để làm cho tất cả các phần tử trong mảng bằng nhau.\n    >>> makeEqualAgain(3, (int[]){1, 2, 1})\n    1\n*/\nint makeEqualAgain(int n, int a[])"
    },
    "prompt_bertscore": {
      "es": "0.9726573362682615",
      "arb": "0.9902204331897473",
      "sw": "0.9869501825963889",
      "tr": "0.9520653246663746",
      "vi": "0.981348805851205"
    },
    "canonical_solution": "{\n    int p = 1, q = 0, c, d;\n    int k = n;\n    for (p = 1; p < k; p++) {\n        if (a[p] != a[p - 1])\n            break;\n    }\n    for (q = k - 1; q > p; q--) {\n        if (a[q] != a[p - 1])\n            break;\n    }\n    for (d = k - 2; d >= 0; d--) {\n        if (a[d] != a[d + 1])\n            break;\n    }\n    for (c = 0; c < d; c++) {\n        if (a[c] != a[c + 1])\n            break;\n    }\n    if (q - p + 1 < d - c + 1)\n        return q - p + 1;\n    else\n        return d - c + 1;\n}",
    "instruction": {
      "es": "int makeEqualAgain(int n, int a[])\n{\n    int p = 1, q = 0, c, d;\n    int k = n;\n    for (p = 1; p < k; p++) {\n        if (a[p] != a[p - 1])\n            break;\n    }\n    for (q = k - 1; q > p; q--) {\n        if (a[q] != a[p - 1])\n            break;\n    }\n    for (d = k - 2; d >= 0; d--) {\n        if (a[d] != a[d + 1])\n            break;\n    }\n    for (c = 0; c < d; c++) {\n        if (a[c] != a[c + 1])\n            break;\n    }\n    if (q - p + 1 < d - c + 1)\n        return q - p + 1;\n    else\n        return d - c + 1;\n}\n\nProporcione una descripción concisa en lenguaje natural (docstring) del código C en español utilizando como máximo 500 caracteres.",
      "arb": "int makeEqualAgain(int n, int a[])\n{\n    int p = 1, q = 0, c, d;\n    int k = n;\n    for (p = 1; p < k; p++) {\n        if (a[p] != a[p - 1])\n            break;\n    }\n    for (q = k - 1; q > p; q--) {\n        if (a[q] != a[p - 1])\n            break;\n    }\n    for (d = k - 2; d >= 0; d--) {\n        if (a[d] != a[d + 1])\n            break;\n    }\n    for (c = 0; c < d; c++) {\n        if (a[c] != a[c + 1])\n            break;\n    }\n    if (q - p + 1 < d - c + 1)\n        return q - p + 1;\n    else\n        return d - c + 1;\n}\n\nيرجى تقديم وصف موجز بلغة طبيعية (docstring) للكود المكتوب بلغة C باللغة العربية الفصحى، بحيث لا يتجاوز 500 حرف.",
      "sw": "int makeEqualAgain(int n, int a[])\n{\n    int p = 1, q = 0, c, d;\n    int k = n;\n    for (p = 1; p < k; p++) {\n        if (a[p] != a[p - 1])\n            break;\n    }\n    for (q = k - 1; q > p; q--) {\n        if (a[q] != a[p - 1])\n            break;\n    }\n    for (d = k - 2; d >= 0; d--) {\n        if (a[d] != a[d + 1])\n            break;\n    }\n    for (c = 0; c < d; c++) {\n        if (a[c] != a[c + 1])\n            break;\n    }\n    if (q - p + 1 < d - c + 1)\n        return q - p + 1;\n    else\n        return d - c + 1;\n}\n\nToa maelezo mafupi kwa lugha ya asili (docstring) ya msimbo wa C kwa Kiswahili kwa kutumia herufi zisizozidi 500.",
      "tr": "int makeEqualAgain(int n, int a[])\n{\n    int p = 1, q = 0, c, d;\n    int k = n;\n    for (p = 1; p < k; p++) {\n        if (a[p] != a[p - 1])\n            break;\n    }\n    for (q = k - 1; q > p; q--) {\n        if (a[q] != a[p - 1])\n            break;\n    }\n    for (d = k - 2; d >= 0; d--) {\n        if (a[d] != a[d + 1])\n            break;\n    }\n    for (c = 0; c < d; c++) {\n        if (a[c] != a[c + 1])\n            break;\n    }\n    if (q - p + 1 < d - c + 1)\n        return q - p + 1;\n    else\n        return d - c + 1;\n}\n\nC kodunun işlevselliğini açıklayan en fazla 500 karakterlik Türkçe bir açıklama (docstring) sağlayın.",
      "vi": "int makeEqualAgain(int n, int a[])\n{\n    int p = 1, q = 0, c, d;\n    int k = n;\n    for (p = 1; p < k; p++) {\n        if (a[p] != a[p - 1])\n            break;\n    }\n    for (q = k - 1; q > p; q--) {\n        if (a[q] != a[p - 1])\n            break;\n    }\n    for (d = k - 2; d >= 0; d--) {\n        if (a[d] != a[d + 1])\n            break;\n    }\n    for (c = 0; c < d; c++) {\n        if (a[c] != a[c + 1])\n            break;\n    }\n    if (q - p + 1 < d - c + 1)\n        return q - p + 1;\n    else\n        return d - c + 1;\n}\n\nCung cấp mô tả ngắn gọn bằng ngôn ngữ tự nhiên (docstring) của mã C bằng tiếng Việt với tối đa 500 ký tự."
    },
    "instruction_bertscore": {
      "es": "0.9687963589217052",
      "arb": "0.8727085148353161",
      "sw": "0.9131508521963055",
      "tr": "0.8354943184269056",
      "vi": "0.9439043968311751"
    },
    "level": "",
    "test": "int main() {\n    int test1[] = {1, 2, 1};\n    int test2[] = {5, 5, 1, 5, 5};\n    int test3[] = {1, 1, 1, 1};\n    int test4[] = {2, 2, 2, 3, 2, 2};\n    int test5[] = {1};\n    int test6[] = {1, 2};\n    int test7[] = {1, 2, 2, 1};\n    int test8[] = {4, 4, 4, 3, 3, 4, 4};\n    int test9[] = {5, 4, 4, 4, 5, 5};\n    int test10[] = {1, 2, 1, 2, 1, 2, 1};\n    int a1[] = {1,2,3,4,5,1};\n    int a2[] = {1,1,1,1,1,1,1};\n    int a3[] = {8,8,8,1,2,8,8,8};\n    int a4[] = {1,2,3};\n    int a5[] = {4,3,2,7,1,1,3};\n    int a6[] = {9,9,2,9,2,5,5,5,3};\n    assert(makeEqualAgain(6, a1) == 4);\n    assert(makeEqualAgain(7, a2) == 0);\n    assert(makeEqualAgain(8, a3) == 2);\n    assert(makeEqualAgain(3, a4) == 2);\n    assert(makeEqualAgain(7, a5) == 6);\n    assert(makeEqualAgain(9, a6) == 7);\n\n    assert(makeEqualAgain(3, test1) == 1);\n    assert(makeEqualAgain(5, test2) == 1);\n    assert(makeEqualAgain(4, test3) == 0);\n    assert(makeEqualAgain(6, test4) == 1);\n    assert(makeEqualAgain(1, test5) == 0);\n    assert(makeEqualAgain(2, test6) == 1);\n    assert(makeEqualAgain(4, test7) == 2);\n    assert(makeEqualAgain(7, test8) == 2);\n    assert(makeEqualAgain(6, test9) == 3);\n    assert(makeEqualAgain(7, test10) == 5);\n\n    return 0;\n}",
    "entry_point": "makeEqualAgain",
    "signature": "int makeEqualAgain(int n, int a[])",
    "docstring": {
      "es": "Se te da un array a de n enteros. Puedes realizar como máximo una operación donde seleccionas tres enteros i, j, x (1 <= i <= j <= n) y reemplazas todos los elementos de a[i] a a[j] con x, a un costo de (j - i + 1). Encuentra el costo mínimo para hacer que todos los elementos en el array sean iguales.\n    >>> makeEqualAgain(3, (int[]){1, 2, 1})\n    1",
      "arb": "أنت مُعطى مصفوفة a تحتوي على n من الأعداد الصحيحة. يمكنك تنفيذ عملية واحدة على الأكثر حيث تختار ثلاثة أعداد صحيحة i، j، x (1 <= i <= j <= n) وتستبدل جميع العناصر من a[i] إلى a[j] بـ x، بتكلفة (j - i + 1). \nاعثر على الحد الأدنى للتكلفة لجعل جميع العناصر في المصفوفة متساوية.\n    >>> makeEqualAgain(3, (int[]){1, 2, 1})\n    1",
      "sw": "Umepewa safu a ya n nambari nzima. Unaweza kufanya operesheni moja tu ambapo unachagua nambari tatu i, j, x (1 <= i <= j <= n) na kubadilisha vipengele vyote kutoka a[i] hadi a[j] na x, kwa gharama ya (j - i + 1). \nPata gharama ndogo zaidi ya kufanya vipengele vyote katika safu kuwa sawa.\n    >>> makeEqualAgain(3, (int[]){1, 2, 1})\n    1",
      "tr": "Size n olan bir tamsayı dizisi a veriliyor. En fazla bir işlem gerçekleştirebilirsiniz; burada i, j, x (1 <= i <= j <= n) üç tamsayısını seçip a[i] ile a[j] arasındaki tüm elemanları x ile değiştirirsiniz ve bu işlem (j - i + 1) maliyetine sahiptir. Dizideki tüm elemanları eşit hale getirmek için minimum maliyeti bulun.\n    >>> makeEqualAgain(3, (int[]){1, 2, 1})\n    1",
      "vi": "Bạn được cung cấp một mảng a gồm n số nguyên. Bạn có thể thực hiện tối đa một thao tác, trong đó bạn chọn ba số nguyên i, j, x (1 <= i <= j <= n) và thay thế tất cả các phần tử từ a[i] đến a[j] bằng x, với chi phí là (j - i + 1). Tìm chi phí tối thiểu để làm cho tất cả các phần tử trong mảng bằng nhau.\n    >>> makeEqualAgain(3, (int[]){1, 2, 1})\n    1"
    },
    "docstring_bertscore": {
      "es": "1",
      "arb": "0.9952136037082023",
      "sw": "0.9842595354548903",
      "tr": "0.9455266111530871",
      "vi": "0.9863902435522516"
    }
  },
  {
    "task_id": "C/35",
    "prompt": {
      "es": "#include <assert.h>\n#include <stdio.h>\n/*\nDada una secuencia de N pilas de piedras numeradas del 1 al N, con cada pila conteniendo un número positivo de piedras, determina el ganador de un juego jugado por Charlie y Dan. Charlie comienza primero, y se turnan moviendo un número positivo de piedras de la pila más a la izquierda no vacía a la pila adyacente a la derecha. El jugador que solo puede mover piedras en la última pila pierde. Suponiendo que ambos jugadores usan la mejor estrategia posible, averigua quién ganará el juego.\n    >>> gameWinner(3, 1, 2, 2)\n    \"Dan\"\n*/\nconst char* gameWinner(int n, int piles[])",
      "arb": "#include <assert.h>\n#include <stdio.h>\n/*\nبالنظر إلى تسلسل من N كومة من الحجارة مرقمة من 1 إلى N، تحتوي كل كومة على عدد موجب من الحجارة، حدد الفائز في لعبة يلعبها تشارلي ودان. يبدأ تشارلي أولاً، ويتناوبون في نقل عدد موجب من الحجارة من الكومة اليسرى غير الفارغة إلى الكومة المجاورة على اليمين. اللاعب الذي لا يستطيع سوى نقل الحجارة في الكومة الأخيرة يخسر. بافتراض أن كلا اللاعبين يستخدمان أفضل استراتيجية ممكنة، اكتشف من سيفوز في اللعبة.\n    >>> gameWinner(3, 1, 2, 2)\n    \"Dan\"\n*/\nconst char* gameWinner(int n, int piles[])",
      "sw": "#include <assert.h>\n#include <stdio.h>\n/*\nUkipiwa mlolongo wa mirundo N ya mawe yenye namba kutoka 1 hadi N, ambapo kila rundo lina idadi chanya ya mawe, amua mshindi wa mchezo unaochezwa na Charlie na Dan. Charlie huanza kwanza, na wanachukua zamu kuhamisha idadi chanya ya mawe kutoka kwenye rundo la kwanza lisilo tupu kwenda kwenye rundo la kulia lililo karibu. Mchezaji ambaye anaweza tu kuhamisha mawe kwenye rundo la mwisho anapoteza. Tukidhani wachezaji wote wanatumia mkakati bora zaidi, tafuta nani atashinda mchezo.\n    >>> gameWinner(3, 1, 2, 2)\n    \"Dan\"\n*/\nconst char* gameWinner(int n, int piles[])",
      "tr": "#include <assert.h>\n#include <stdio.h>\n/*\n1'den N'e kadar numaralandırılmış N taş yığını dizisi verildiğinde, her yığın pozitif sayıda taş içerir, Charlie ve Dan tarafından oynanan bir oyunun kazananını belirleyin. Charlie ilk başlar ve sırayla en soldaki dolu olmayan yığından bitişik sağ yığına pozitif sayıda taş taşırlar. Sadece son yığındaki taşları hareket ettirebilen oyuncu kaybeder. Her iki oyuncunun da mümkün olan en iyi stratejiyi kullandığını varsayarak, oyunu kimin kazanacağını bulun.\n    >>> gameWinner(3, 1, 2, 2)\n    \"Dan\"\n*/\nconst char* gameWinner(int n, int piles[])",
      "vi": "#include <assert.h>\n#include <stdio.h>\n/*\nCho một dãy N đống đá được đánh số từ 1 đến N, với mỗi đống chứa một số lượng đá dương, xác định người chiến thắng của trò chơi được chơi bởi Charlie và Dan. Charlie đi trước, và họ lần lượt di chuyển một số lượng đá dương từ đống không rỗng ngoài cùng bên trái sang đống liền kề bên phải. Người chơi chỉ có thể di chuyển đá trong đống cuối cùng sẽ thua. Giả sử cả hai người chơi đều sử dụng chiến lược tốt nhất có thể, tìm ra ai sẽ thắng trò chơi.\n    >>> gameWinner(3, 1, 2, 2)\n    \"Dan\"\n*/\nconst char* gameWinner(int n, int piles[])"
    },
    "prompt_bertscore": {
      "es": "0.9733106315914852",
      "arb": "0.9572209748365161",
      "sw": "0.9695034830781895",
      "tr": "0.9709802999611838",
      "vi": "0.9955383643811944"
    },
    "canonical_solution": "{\n    // Only the first pile's stone count is needed to determine the winner.\n    int firstPileStones = piles[0];\n    if (n == 2) { // With only two piles, Charlie always wins.\n        return \"Charlie\";\n    }\n    if (firstPileStones == 1) { // If the first pile has only one stone, Dan wins.\n        return \"Dan\";\n    }\n    return \"Charlie\"; // In all other cases, Charlie wins.\n}",
    "instruction": {
      "es": "const char* gameWinner(int n, int piles[])\n{\n    // Only the first pile's stone count is needed to determine the winner.\n    int firstPileStones = piles[0];\n    if (n == 2) { // With only two piles, Charlie always wins.\n        return \"Charlie\";\n    }\n    if (firstPileStones == 1) { // If the first pile has only one stone, Dan wins.\n        return \"Dan\";\n    }\n    return \"Charlie\"; // In all other cases, Charlie wins.\n}\n\nProporcione una descripción concisa en lenguaje natural (docstring) del código C en español utilizando como máximo 500 caracteres.",
      "arb": "const char* gameWinner(int n, int piles[])\n{\n    // Only the first pile's stone count is needed to determine the winner.\n    int firstPileStones = piles[0];\n    if (n == 2) { // With only two piles, Charlie always wins.\n        return \"Charlie\";\n    }\n    if (firstPileStones == 1) { // If the first pile has only one stone, Dan wins.\n        return \"Dan\";\n    }\n    return \"Charlie\"; // In all other cases, Charlie wins.\n}\n\nيرجى تقديم وصف موجز بلغة طبيعية (docstring) للكود المكتوب بلغة C باللغة العربية الفصحى، بحيث لا يتجاوز 500 حرف.",
      "sw": "const char* gameWinner(int n, int piles[])\n{\n    // Only the first pile's stone count is needed to determine the winner.\n    int firstPileStones = piles[0];\n    if (n == 2) { // With only two piles, Charlie always wins.\n        return \"Charlie\";\n    }\n    if (firstPileStones == 1) { // If the first pile has only one stone, Dan wins.\n        return \"Dan\";\n    }\n    return \"Charlie\"; // In all other cases, Charlie wins.\n}\n\nToa maelezo mafupi ya lugha ya asili (docstring) ya msimbo wa C kwa Kiswahili kwa kutumia herufi zisizozidi 500.",
      "tr": "const char* gameWinner(int n, int piles[])\n{\n    // Only the first pile's stone count is needed to determine the winner.\n    int firstPileStones = piles[0];\n    if (n == 2) { // With only two piles, Charlie always wins.\n        return \"Charlie\";\n    }\n    if (firstPileStones == 1) { // If the first pile has only one stone, Dan wins.\n        return \"Dan\";\n    }\n    return \"Charlie\"; // In all other cases, Charlie wins.\n}\n\nC kodunun işlevini açıklayan kısa bir doğal dil açıklaması (docstring) sağlayın. Açıklama en fazla 500 karakter olmalıdır.",
      "vi": "const char* gameWinner(int n, int piles[])\n{\n    // Only the first pile's stone count is needed to determine the winner.\n    int firstPileStones = piles[0];\n    if (n == 2) { // With only two piles, Charlie always wins.\n        return \"Charlie\";\n    }\n    if (firstPileStones == 1) { // If the first pile has only one stone, Dan wins.\n        return \"Dan\";\n    }\n    return \"Charlie\"; // In all other cases, Charlie wins.\n}\n\nCung cấp mô tả ngắn gọn bằng ngôn ngữ tự nhiên (docstring) của mã C bằng tiếng Việt, sử dụng tối đa 500 ký tự."
    },
    "instruction_bertscore": {
      "es": "0.9687963589217052",
      "arb": "0.8727085148353161",
      "sw": "0.9146175389298671",
      "tr": "0.8359883121845394",
      "vi": "0.946887229263176"
    },
    "level": "",
    "test": "int main() {\n    int test1[] = {1, 2, 2};\n    int test2[] = {5, 5, 5, 5, 5};\n    int test3[] = {2, 1, 2};\n    int test4[] = {3, 3, 3, 3};\n    int test5[] = {1, 1};\n    int test6[] = {2, 1};\n    int test7[] = {1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1};\n    int test8[] = {2, 2, 2, 2, 2, 2, 2, 2, 2, 1};\n    int test9[] = {10, 10, 10, 10, 10, 10, 10, 10, 10, 10};\n    int test10[] = {1, 2, 3, 4, 5, 6, 7, 8, 9, 10};\n\n    assert(gameWinner(3, test1) == \"Dan\");\n    assert(gameWinner(5, test2) == \"Charlie\");\n    assert(gameWinner(3, test3) == \"Charlie\");\n    assert(gameWinner(4, test4) == \"Charlie\");\n    assert(gameWinner(2, test5) == \"Charlie\");\n    assert(gameWinner(2, test6) == \"Charlie\");\n    assert(gameWinner(11, test7) == \"Dan\");\n    assert(gameWinner(10, test8) == \"Charlie\");\n    assert(gameWinner(10, test9) == \"Charlie\");\n    assert(gameWinner(10, test10) == \"Dan\");\n\n    return 0;\n}",
    "entry_point": "gameWinner",
    "signature": "const char* gameWinner(int n, int piles[])",
    "docstring": {
      "es": "Dada una secuencia de N montones de piedras numerados del 1 al N, con cada montón conteniendo un número positivo de piedras, determina el ganador de un juego jugado por Charlie y Dan. Charlie va primero, y se turnan para mover un número positivo de piedras del montón no vacío más a la izquierda al montón adyacente a la derecha. El jugador que solo puede mover piedras en el último montón pierde. Suponiendo que ambos jugadores usan la mejor estrategia posible, averigua quién ganará el juego.\n    >>> gameWinner(3, 1, 2, 2)\n    \"Dan\"",
      "arb": "بالنظر إلى تسلسل من N أكوام من الحجارة مرقمة من 1 إلى N، حيث تحتوي كل كومة على عدد موجب من الحجارة، حدد الفائز في لعبة يلعبها تشارلي ودان. يبدأ تشارلي أولاً، ويتناوبون في نقل عدد موجب من الحجارة من الكومة غير الفارغة الأكثر يسارًا إلى الكومة المجاورة على اليمين. اللاعب الذي يمكنه فقط نقل الحجارة في الكومة الأخيرة يخسر. بافتراض أن كلا اللاعبين يستخدمان أفضل استراتيجية ممكنة، اكتشف من سيفوز باللعبة.\n    >>> gameWinner(3, 1, 2, 2)\n    \"Dan\"",
      "sw": "Kwa kuzingatia mlolongo wa marundo N ya mawe yaliyohesabiwa kutoka 1 hadi N, ambapo kila rundo lina idadi chanya ya mawe, bainisha mshindi wa mchezo unaochezwa na Charlie na Dan. Charlie huanza kwanza, na wanachukua zamu kuhamisha idadi chanya ya mawe kutoka kwenye rundo la kwanza lisilo tupu kwenda kwenye rundo la kulia lililo karibu. Mchezaji ambaye anaweza tu kuhamisha mawe kwenye rundo la mwisho anapoteza. Tukichukulia kwamba wachezaji wote wanatumia mkakati bora zaidi, tafuta ni nani atakayeshinda mchezo.\n    >>> gameWinner(3, 1, 2, 2)\n    \"Dan\"",
      "tr": "Verilen 1'den N'ye kadar numaralandırılmış N taş yığını dizisinde, her yığın pozitif sayıda taş içerir, Charlie ve Dan tarafından oynanan bir oyunun kazananını belirleyin. Charlie ilk hamleyi yapar ve sırayla, soldaki en sol dolu yığından sağdaki bitişik yığına pozitif sayıda taş taşırlar. Sadece son yığındaki taşları hareket ettirebilen oyuncu kaybeder. Her iki oyuncunun da en iyi stratejiyi kullandığını varsayarak, oyunu kimin kazanacağını bulun.\n    >>> gameWinner(3, 1, 2, 2)\n    \"Dan\"",
      "vi": "Cho một dãy N đống đá được đánh số từ 1 đến N, với mỗi đống chứa một số lượng đá dương, xác định người chiến thắng của trò chơi được chơi bởi Charlie và Dan. Charlie đi trước, và họ lần lượt di chuyển một số lượng đá dương từ đống không rỗng ngoài cùng bên trái sang đống liền kề bên phải. Người chơi chỉ có thể di chuyển đá trong đống cuối cùng sẽ thua. Giả sử cả hai người chơi đều sử dụng chiến lược tốt nhất có thể, hãy tìm ra ai sẽ thắng trò chơi.\n    >>> gameWinner(3, 1, 2, 2)\n    \"Dan\""
    },
    "docstring_bertscore": {
      "es": "0.9888441232795565",
      "arb": "0.9851758174026042",
      "sw": "0.9713267113457087",
      "tr": "0.9547452457672972",
      "vi": "0.9947643017863014"
    }
  },
  {
    "task_id": "C/36",
    "prompt": {
      "es": "#include <assert.h>\n#include <stdio.h>\n/*\nDado n puertas dispuestas en un círculo, el jugador comienza frente a la puerta 1. En cada turno, el jugador puede elegir un número i y pagar un costo C_i para moverse i pasos a la derecha y luego abrir la puerta en esa posición. Se garantiza que C_i >= C_{i+1} para 1 <= i < n.\nLa tarea es determinar el costo total mínimo requerido para abrir todas las puertas.\n\nEjemplo:\n    >>> minTotalCost(3, (1, 1, 1))\n    3\n*/\nlong long minTotalCost(int n, int *C)",
      "arb": "#include <assert.h>\n#include <stdio.h>\n/*\nمعطى n من الأبواب مرتبة في دائرة، يبدأ اللاعب أمام الباب 1. في كل دور، يمكن للاعب اختيار رقم i ودفع تكلفة C_i للتحرك i خطوات إلى اليمين ثم فتح الباب في ذلك الموقع. من المضمون أن C_i >= C_{i+1} لكل 1 <= i < n.\nالمهمة هي تحديد الحد الأدنى من التكلفة الإجمالية المطلوبة لفتح جميع الأبواب.\n\nمثال:\n    >>> minTotalCost(3, (1, 1, 1))\n    3\n*/\nlong long minTotalCost(int n, int *C)",
      "sw": "#include <assert.h>\n#include <stdio.h>\n/*\nUkipiwa milango n iliyopangwa kwa mduara, mchezaji anaanza mbele ya mlango wa 1. Kila zamu, mchezaji anaweza kuchagua nambari i na kulipa gharama C_i ili kusonga hatua i kwenda kulia na kisha kufungua mlango katika nafasi hiyo. Imethibitishwa kuwa C_i >= C_{i+1} kwa 1 <= i < n.\nKazi ni kuamua gharama ndogo kabisa inayohitajika kufungua milango yote.\n\nMfano:\n    >>> minTotalCost(3, (1, 1, 1))\n    3\n*/\nlong long minTotalCost(int n, int *C)",
      "tr": "#include <assert.h>\n#include <stdio.h>\n/*\nBir daire şeklinde düzenlenmiş n kapı verildiğinde, oyuncu 1 numaralı kapının önünde başlar. Her turda, oyuncu bir sayı i seçebilir ve i adım sağa hareket etmek için bir maliyet C_i ödeyebilir ve ardından o konumdaki kapıyı açabilir. C_i >= C_{i+1} olduğu garanti edilir, burada 1 <= i < n.\nGörev, tüm kapıları açmak için gereken minimum toplam maliyeti belirlemektir.\n\nÖrnek:\n    >>> minTotalCost(3, (1, 1, 1))\n    3\n*/\nlong long minTotalCost(int n, int *C)",
      "vi": "#include <assert.h>\n#include <stdio.h>\n/*\nCho n cánh cửa được sắp xếp thành một vòng tròn, người chơi bắt đầu trước cửa số 1. Mỗi lượt, người chơi có thể chọn một số i và trả một chi phí C_i để di chuyển i bước sang phải và sau đó mở cánh cửa tại vị trí đó. Đảm bảo rằng C_i >= C_{i+1} cho 1 <= i < n.\nNhiệm vụ là xác định tổng chi phí tối thiểu cần thiết để mở tất cả các cửa.\n\nVí dụ:\n    >>> minTotalCost(3, (1, 1, 1))\n    3\n*/\nlong long minTotalCost(int n, int *C)"
    },
    "prompt_bertscore": {
      "es": "0.9925904908962556",
      "arb": "0.9850395569612143",
      "sw": "0.9961948377905147",
      "tr": "0.9788933370808518",
      "vi": "0.9867253330050574"
    },
    "canonical_solution": "{\n   return (long long)(C[n-2]) * (n - 1) + C[n-1];\n}",
    "instruction": {
      "es": "long long minTotalCost(int n, int *C)\n{\n   return (long long)(C[n-2]) * (n - 1) + C[n-1];\n}\n\nProporcione una descripción concisa en lenguaje natural (docstring) del código C en español utilizando como máximo 500 caracteres.",
      "arb": "long long minTotalCost(int n, int *C)\n{\n   return (long long)(C[n-2]) * (n - 1) + C[n-1];\n}\n\nيرجى تقديم وصف موجز بلغة طبيعية (docstring) للكود المكتوب بلغة C باللغة العربية الفصحى، بحيث لا يتجاوز 500 حرف.",
      "sw": "long long minTotalCost(int n, int *C)\n{\n   return (long long)(C[n-2]) * (n - 1) + C[n-1];\n}\n\nToa maelezo mafupi ya lugha asilia (docstring) ya msimbo wa C kwa Kiswahili kwa kutumia herufi zisizozidi 500.",
      "tr": "long long minTotalCost(int n, int *C)\n{\n   return (long long)(C[n-2]) * (n - 1) + C[n-1];\n}\n\nC kodunun işlevini açıklayan kısa bir doğal dil tanımı (docstring) sağlayın. Açıklama, en fazla 500 karakter kullanılarak Türkçe olarak yazılmalıdır.",
      "vi": "long long minTotalCost(int n, int *C)\n{\n   return (long long)(C[n-2]) * (n - 1) + C[n-1];\n}\n\nCung cấp mô tả ngắn gọn bằng ngôn ngữ tự nhiên (docstring) của mã C bằng tiếng Việt với tối đa 500 ký tự."
    },
    "instruction_bertscore": {
      "es": "0.9687963589217052",
      "arb": "0.8800316197233103",
      "sw": "0.9423429634058599",
      "tr": "0.8690074349454929",
      "vi": "0.923675282935439"
    },
    "level": "",
    "test": "int main() {\n    int costs1[] = {4, 3, 3, 3, 3}; // 1-indexed array\n    assert(minTotalCost(5, costs1) == 15);\n\n    int costs2[] = {1, 1, 1};\n    assert(minTotalCost(3, costs2) == 3);\n\n    int costs3[] = {5, 4, 3, 2};\n    assert(minTotalCost(4, costs3) == 11);\n\n    int costs4[] = {100, 99, 98, 97};\n    assert(minTotalCost(4, costs4) == 391);\n\n    int costs5[] = {10, 9, 8, 7, 6, 5};\n    assert(minTotalCost(6, costs5) == 35);\n\n    int costs6[] = {2, 2, 2, 2, 2, 2, 2};\n    assert(minTotalCost(7, costs6) == 14);\n\n    int costs7[] = {9, 7, 7, 7, 7, 7, 7, 7};\n    assert(minTotalCost(8, costs7) == 56);\n\n    int costs8[] = {3, 2, 2, 2, 2, 2, 2, 2, 2};\n    assert(minTotalCost(9, costs8) == 18);\n\n    int costs9[] = {6, 5, 5, 5, 5, 5, 5, 5, 5, 5};\n    assert(minTotalCost(10, costs9) == 50);\n\n    int costs10[] = {8, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1};\n    assert(minTotalCost(11, costs10) == 11);\n\n    return 0;\n}",
    "entry_point": "minTotalCost",
    "signature": "long long minTotalCost(int n, int *C)",
    "docstring": {
      "es": "Dadas n puertas dispuestas en un círculo, el jugador comienza frente a la puerta 1. En cada turno, el jugador puede elegir un número i y pagar un costo C_i para moverse i pasos a la derecha y luego abrir la puerta en esa posición. Se garantiza que C_i >= C_{i+1} para 1 <= i < n. La tarea es determinar el costo total mínimo requerido para abrir todas las puertas.\n\nEjemplo:\n    >>> minTotalCost(3, (1, 1, 1))\n    3",
      "arb": "معطى n أبواب مرتبة في دائرة، يبدأ اللاعب أمام الباب 1. في كل دور، يمكن للاعب اختيار رقم i ودفع تكلفة C_i للتحرك i خطوات إلى اليمين ثم فتح الباب في ذلك الموقع. من المضمون أن C_i >= C_{i+1} لـ 1 <= i < n. المهمة هي تحديد الحد الأدنى للتكلفة الإجمالية المطلوبة لفتح جميع الأبواب.\n\nمثال:\n    >>> minTotalCost(3, (1, 1, 1))\n    3",
      "sw": "Kwa milango n iliyopangwa katika mduara, mchezaji anaanza mbele ya mlango wa 1. Kila zamu, mchezaji anaweza kuchagua namba i na kulipa gharama C_i ili kusonga hatua i kwenda kulia na kisha kufungua mlango katika nafasi hiyo. Inahakikishwa kuwa C_i >= C_{i+1} kwa 1 <= i < n. \nKazi ni kubaini gharama ndogo kabisa inayohitajika kufungua milango yote.\n\nMfano:\n    >>> minTotalCost(3, (1, 1, 1))\n    3",
      "tr": "Verilen n kapı bir daire şeklinde düzenlenmiştir, oyuncu 1 numaralı kapının önünde başlar. Her turda, oyuncu bir sayı i seçebilir ve i adım sağa hareket etmek ve ardından o konumdaki kapıyı açmak için bir maliyet C_i öder. C_i >= C_{i+1} olduğu garanti edilmektedir, burada 1 <= i < n.\nGörev, tüm kapıları açmak için gereken minimum toplam maliyeti belirlemektir.\n\nÖrnek:\n    >>> minTotalCost(3, (1, 1, 1))\n    3",
      "vi": "Cho n cánh cửa được sắp xếp thành vòng tròn, người chơi bắt đầu trước cửa số 1. Mỗi lượt, người chơi có thể chọn một số i và trả một chi phí C_i để di chuyển i bước sang phải và sau đó mở cánh cửa tại vị trí đó. Đảm bảo rằng C_i >= C_{i+1} cho 1 <= i < n. Nhiệm vụ là xác định tổng chi phí tối thiểu cần thiết để mở tất cả các cánh cửa.\n\nVí dụ:\n    >>> minTotalCost(3, (1, 1, 1))\n    3"
    },
    "docstring_bertscore": {
      "es": "0.9858438113740245",
      "arb": "0.9897169051738238",
      "sw": "0.9954920835024132",
      "tr": "0.9631713451611783",
      "vi": "0.9847779607493914"
    }
  },
  {
    "task_id": "C/37",
    "prompt": {
      "es": "#include <assert.h>\n#include <stdio.h>\n/*\nDada una secuencia de IDs de estudiantes que entran a un aula, donde los IDs van de 0 a N-1, calcula el número total de apretones de manos que ocurren. Cada estudiante dará la mano a cada estudiante que ya esté en el aula con un número de ID menor. La secuencia representa el orden en que los estudiantes entran al aula.\n\nEjemplos:\n    >>> countHandshakes(3, (2, 1, 0))\n    0\n*/\nlong long countHandshakes(int n, int order[])",
      "arb": "#include <assert.h>\n#include <stdio.h>\n/*\nبالنظر إلى تسلسل معرفات الطلاب الذين يدخلون إلى الفصل، حيث تتراوح المعرفات من 0 إلى N-1، احسب العدد الإجمالي للمصافحات التي تحدث. كل طالب سيصافح كل طالب موجود بالفعل في الفصل برقم معرف أصغر. يمثل التسلسل الترتيب الذي يدخل به الطلاب إلى الفصل.\n\nأمثلة:\n    >>> countHandshakes(3, (2, 1, 0))\n    0\n*/\nlong long countHandshakes(int n, int order[])",
      "sw": "#include <assert.h>\n#include <stdio.h>\n/*\nKwa kuzingatia mlolongo wa vitambulisho vya wanafunzi wanaoingia darasani, ambapo vitambulisho vinatoka 0 hadi N-1, hesabu jumla ya mikono inayoshikana. Kila mwanafunzi atashikana mikono na kila mwanafunzi ambaye tayari yuko darasani na ana namba ndogo ya kitambulisho. Mlolongo unawakilisha mpangilio ambao wanafunzi wanaingia darasani.\n\nMifano:\n    >>> countHandshakes(3, (2, 1, 0))\n    0\n*/\nlong long countHandshakes(int n, int order[])",
      "tr": "#include <assert.h>\n#include <stdio.h>\n/*\nBir sınıfa giren öğrenci kimliklerinin bir dizisi verildiğinde, kimliklerin 0'dan N-1'e kadar değiştiği varsayılırsa, gerçekleşen toplam el sıkışma sayısını hesaplayın. Her öğrenci, sınıfta zaten bulunan ve daha küçük bir kimlik numarasına sahip her öğrenciyle el sıkışacaktır. Dizi, öğrencilerin sınıfa giriş sırasını temsil eder.\n\nÖrnekler:\n    >>> countHandshakes(3, (2, 1, 0))\n    0\n*/\nlong long countHandshakes(int n, int order[])",
      "vi": "#include <assert.h>\n#include <stdio.h>\n/*\nCho một dãy số ID của học sinh khi vào lớp học, trong đó các ID nằm trong khoảng từ 0 đến N-1, tính tổng số lần bắt tay xảy ra. Mỗi học sinh sẽ bắt tay với mọi học sinh đã có mặt trong lớp với số ID nhỏ hơn. Dãy số đại diện cho thứ tự mà học sinh vào lớp.\n\nVí dụ:\n    >>> countHandshakes(3, (2, 1, 0))\n    0\n*/\nlong long countHandshakes(int n, int order[])"
    },
    "prompt_bertscore": {
      "es": "0.9945475960405923",
      "arb": "0.984536624836434",
      "sw": "0.9842158367710626",
      "tr": "0.9406077283971391",
      "vi": "0.9763089571932068"
    },
    "canonical_solution": "{\n    long long ans = 0;\n    int tr[10000] = {0}; // N should be defined as a constant representing the maximum possible value of n\n    for (int i = 0; i < 10000; ++i) {\n        tr[i] = 0;\n    }\n    for (int i = 0; i < n; ++i) {\n        int x = order[i] + 1; // Convert 0-indexed to 1-indexed\n        for (int j = x - 1; j > 0; j -= j & (-j)) {\n            ans += tr[j];\n        }\n        for (int j = x; j <= n; j += j & (-j)) {\n            ++tr[j];\n        }\n    }\n    return ans;\n}",
    "instruction": {
      "es": "long long countHandshakes(int n, int order[])\n{\n    long long ans = 0;\n    int tr[10000] = {0}; // N should be defined as a constant representing the maximum possible value of n\n    for (int i = 0; i < 10000; ++i) {\n        tr[i] = 0;\n    }\n    for (int i = 0; i < n; ++i) {\n        int x = order[i] + 1; // Convert 0-indexed to 1-indexed\n        for (int j = x - 1; j > 0; j -= j & (-j)) {\n            ans += tr[j];\n        }\n        for (int j = x; j <= n; j += j & (-j)) {\n            ++tr[j];\n        }\n    }\n    return ans;\n}\n\nProporcione una descripción concisa en lenguaje natural (docstring) del código C en español utilizando como máximo 500 caracteres.",
      "arb": "long long countHandshakes(int n, int order[])\n{\n    long long ans = 0;\n    int tr[10000] = {0}; // N should be defined as a constant representing the maximum possible value of n\n    for (int i = 0; i < 10000; ++i) {\n        tr[i] = 0;\n    }\n    for (int i = 0; i < n; ++i) {\n        int x = order[i] + 1; // Convert 0-indexed to 1-indexed\n        for (int j = x - 1; j > 0; j -= j & (-j)) {\n            ans += tr[j];\n        }\n        for (int j = x; j <= n; j += j & (-j)) {\n            ++tr[j];\n        }\n    }\n    return ans;\n}\n\nيرجى تقديم وصف موجز بلغة طبيعية (docstring) للكود المكتوب بلغة C باللغة العربية الفصحى، بحيث لا يتجاوز 500 حرف.",
      "sw": "long long countHandshakes(int n, int order[])\n{\n    long long ans = 0;\n    int tr[10000] = {0}; // N should be defined as a constant representing the maximum possible value of n\n    for (int i = 0; i < 10000; ++i) {\n        tr[i] = 0;\n    }\n    for (int i = 0; i < n; ++i) {\n        int x = order[i] + 1; // Convert 0-indexed to 1-indexed\n        for (int j = x - 1; j > 0; j -= j & (-j)) {\n            ans += tr[j];\n        }\n        for (int j = x; j <= n; j += j & (-j)) {\n            ++tr[j];\n        }\n    }\n    return ans;\n}\n\nToa maelezo mafupi ya lugha ya asili (docstring) ya msimbo wa C kwa Kiswahili kwa kutumia herufi zisizozidi 500.",
      "tr": "long long countHandshakes(int n, int order[])\n{\n    long long ans = 0;\n    int tr[10000] = {0}; // N should be defined as a constant representing the maximum possible value of n\n    for (int i = 0; i < 10000; ++i) {\n        tr[i] = 0;\n    }\n    for (int i = 0; i < n; ++i) {\n        int x = order[i] + 1; // Convert 0-indexed to 1-indexed\n        for (int j = x - 1; j > 0; j -= j & (-j)) {\n            ans += tr[j];\n        }\n        for (int j = x; j <= n; j += j & (-j)) {\n            ++tr[j];\n        }\n    }\n    return ans;\n}\n\nC kodunun işlevini açıklayan, en fazla 500 karakter uzunluğunda özlü bir doğal dil açıklaması (docstring) sağlayın.",
      "vi": "long long countHandshakes(int n, int order[])\n{\n    long long ans = 0;\n    int tr[10000] = {0}; // N should be defined as a constant representing the maximum possible value of n\n    for (int i = 0; i < 10000; ++i) {\n        tr[i] = 0;\n    }\n    for (int i = 0; i < n; ++i) {\n        int x = order[i] + 1; // Convert 0-indexed to 1-indexed\n        for (int j = x - 1; j > 0; j -= j & (-j)) {\n            ans += tr[j];\n        }\n        for (int j = x; j <= n; j += j & (-j)) {\n            ++tr[j];\n        }\n    }\n    return ans;\n}\n\nCung cấp mô tả ngắn gọn bằng ngôn ngữ tự nhiên (docstring) cho mã C bằng tiếng Việt với tối đa 500 ký tự."
    },
    "instruction_bertscore": {
      "es": "0.9687963589217052",
      "arb": "0.8609607195793886",
      "sw": "0.9146175389298671",
      "tr": "0.8690445788267465",
      "vi": "0.9133171058252317"
    },
    "level": "",
    "test": "int main() {\n    int or1[] = {2, 1, 3, 0};\n    assert(countHandshakes(4, or1) == 2);\n    int or2[] = {0, 1, 2, 3, 4, 5};\n    assert(countHandshakes(6, or2) == 15);\n    int order1[] = {1, 2, 0};\n    assert(countHandshakes(3, order1) == 1);\n\n    int order2[] = {3, 2, 1, 0};\n    assert(countHandshakes(4, order2) == 0);\n\n    int order3[] = {0, 1, 2, 3};\n    assert(countHandshakes(4, order3) == 6);\n\n    int order4[] = {5, 4, 3, 2, 1, 0};\n    assert(countHandshakes(6, order4) == 0);\n\n    int order5[] = {0, 2, 1, 3};\n    assert(countHandshakes(4, order5) == 5);\n\n    int order6[] = {3, 1, 4, 2, 0};\n    assert(countHandshakes(5, order6) == 3);\n\n    int order7[] = {1, 0, 3, 2};\n    assert(countHandshakes(4, order7) == 4);\n\n    int order8[] = {2, 0, 1};\n    assert(countHandshakes(3, order8) == 1);\n\n    int order9[] = {1, 3, 0, 2, 4};\n    assert(countHandshakes(5, order9) == 7);\n\n    int order10[] = {4, 3, 2, 1, 0};\n    assert(countHandshakes(5, order10) == 0);\n\n    return 0;\n}",
    "entry_point": "countHandshakes",
    "signature": "long long countHandshakes(int n, int order[])",
    "docstring": {
      "es": "Dada una secuencia de identificaciones de estudiantes que ingresan a un aula, donde las identificaciones varían de 0 a N-1, calcule el número total de apretones de manos que ocurren. Cada estudiante estrechará la mano con cada estudiante que ya esté en el aula con un número de identificación menor. La secuencia representa el orden en que los estudiantes ingresan al aula.\n\nEjemplos:\n    >>> countHandshakes(3, (2, 1, 0))\n    0",
      "arb": "بالنظر إلى تسلسل معرفات الطلاب الذين يدخلون الفصل، حيث تتراوح المعرفات من 0 إلى N-1، احسب العدد الإجمالي للمصافحات التي تحدث. كل طالب سوف يصافح كل طالب موجود بالفعل في الفصل بمعرف أصغر. يمثل التسلسل ترتيب دخول الطلاب إلى الفصل.\n\nأمثلة:\n    >>> countHandshakes(3, (2, 1, 0))\n    0",
      "sw": "Given a sequence of student IDs entering a classroom, where the IDs range from 0 to N-1, calculate the total number of handshakes that occur. Kila mwanafunzi atapiga mikono na kila mwanafunzi tayari ndani ya darasa mwenye namba ya ID ndogo. Mfuatano unawakilisha mpangilio ambao wanafunzi wanaingia darasani.\n\nMifano:\n    >>> countHandshakes(3, (2, 1, 0))\n    0",
      "tr": "Verilen bir sınıfa giren öğrenci kimlik numaralarının sıralamasına göre, gerçekleşen toplam tokalaşma sayısını hesaplayın. Kimlik numaraları 0'dan N-1'e kadar olan her öğrenci, sınıfta kendisinden daha küçük kimlik numarasına sahip olan her öğrenciyle tokalaşacaktır. Sıralama, öğrencilerin sınıfa giriş sırasını temsil eder.\n\nÖrnekler:\n    >>> countHandshakes(3, (2, 1, 0))\n    0",
      "vi": "Cho một dãy số ID sinh viên khi vào lớp học, trong đó các ID có phạm vi từ 0 đến N-1, tính tổng số lần bắt tay xảy ra. Mỗi sinh viên sẽ bắt tay với mọi sinh viên đã có mặt trong lớp với số ID nhỏ hơn. Dãy số đại diện cho thứ tự mà các sinh viên vào lớp.\n\nVí dụ:\n    >>> countHandshakes(3, (2, 1, 0))\n    0"
    },
    "docstring_bertscore": {
      "es": "0.9960053444070074",
      "arb": "0.9776691780425337",
      "sw": "1",
      "tr": "0.8945681855289676",
      "vi": "0.9653113888864482"
    }
  },
  {
    "task_id": "C/38",
    "prompt": {
      "es": "#include <assert.h>\n#include <stdio.h>\n/*\nDado n enteros positivos que representan la cantidad de cada número de 1 a n,\nencuentra la suma máxima del modo (elemento más frecuente) para todos los prefijos de \nuna secuencia construida a partir de estos números. El modo es el número más grande entre \nlos elementos más frecuentes en una secuencia.\n    >>> maxModeSum(3, (int[]){1, 2, 3})\n    17\n    Una secuencia que alcanza su valor máximo es (3,2,3,1,2,2).\n*/\nlong long maxModeSum(int n, const int* counts)",
      "arb": "#include <assert.h>\n#include <stdio.h>\n/*\nمعطى n عدد صحيح موجب يمثل عدد كل رقم من 1 إلى n،\nابحث عن الحد الأقصى لمجموع النمط (العنصر الأكثر تكرارًا) لجميع البادئات\nلسلسلة مُنشأة من هذه الأرقام. النمط هو أكبر عدد بين\nالعناصر الأكثر تكرارًا في سلسلة.\n    >>> maxModeSum(3, (int[]){1, 2, 3})\n    17\n    سلسلة تصل إلى قيمتها القصوى هي (3,2,3,1,2,2).\n*/\nlong long maxModeSum(int n, const int* counts)",
      "sw": "#include <assert.h>\n#include <stdio.h>\n/*\nUkipiwa n nambari chanya zinazowakilisha idadi ya kila nambari kutoka 1 hadi n,\ntafuta jumla ya juu zaidi ya modi (kipengele kinachojitokeza mara nyingi zaidi) kwa viambishi vyote vya\nmlolongo ulioundwa kutoka kwa hizi nambari. Modi ni nambari kubwa zaidi kati ya\nvipengele vinavyojitokeza mara nyingi zaidi katika mlolongo.\n    >>> maxModeSum(3, (int[]){1, 2, 3})\n    17\n    Mlolongo unaofikia thamani yake ya juu zaidi ni (3,2,3,1,2,2).\n*/\nlong long maxModeSum(int n, const int* counts)",
      "tr": "#include <assert.h>\n#include <stdio.h>\n/*\n1'den n'e kadar olan her sayının sayısını temsil eden n pozitif tamsayı verildiğinde,\nbu sayılardan oluşturulan bir dizinin tüm ön ekleri için modun (en sık görülen eleman) \nmaksimum toplamını bulun. Mod, bir dizideki en sık görülen elemanlar arasında \nen büyük sayıdır.\n    >>> maxModeSum(3, (int[]){1, 2, 3})\n    17\n    Maksimum değerine ulaşan bir dizi (3,2,3,1,2,2) şeklindedir.\n*/\nlong long maxModeSum(int n, const int* counts)",
      "vi": "#include <assert.h>\n#include <stdio.h>\n/*\nCho n số nguyên dương đại diện cho số lượng của mỗi số từ 1 đến n,\ntìm tổng lớn nhất của mode (phần tử xuất hiện nhiều nhất) cho tất cả các tiền tố của\nmột dãy được tạo từ các số này. Mode là số lớn nhất trong số các phần tử xuất hiện nhiều nhất trong một dãy.\n    >>> maxModeSum(3, (int[]){1, 2, 3})\n    17\n    Một dãy đạt giá trị tối đa là (3,2,3,1,2,2).\n*/\nlong long maxModeSum(int n, const int* counts)"
    },
    "prompt_bertscore": {
      "es": "0.9647407238017349",
      "arb": "0.9443602535556502",
      "sw": "0.9470232910741849",
      "tr": "0.960613780374973",
      "vi": "0.9427795529833746"
    },
    "canonical_solution": "{\n    long long ans = 0;\n    int mx = 0;\n    long long f[100000];\n    for (int i = 0; i <= n; ++i) f[i] = 0;\n\n    for (int i = n; i > 0; --i) {\n        while (mx < counts[i - 1]) {\n            mx++;\n            f[mx] = f[mx - 1] + i;\n        }\n        ans += f[counts[i - 1]];\n    }\n    return ans;\n}",
    "instruction": {
      "es": "long long maxModeSum(int n, const int* counts)\n{\n    long long ans = 0;\n    int mx = 0;\n    long long f[100000];\n    for (int i = 0; i <= n; ++i) f[i] = 0;\n\n    for (int i = n; i > 0; --i) {\n        while (mx < counts[i - 1]) {\n            mx++;\n            f[mx] = f[mx - 1] + i;\n        }\n        ans += f[counts[i - 1]];\n    }\n    return ans;\n}\n\nProporcione una descripción concisa en lenguaje natural (docstring) del código C en español utilizando como máximo 500 caracteres.",
      "arb": "long long maxModeSum(int n, const int* counts)\n{\n    long long ans = 0;\n    int mx = 0;\n    long long f[100000];\n    for (int i = 0; i <= n; ++i) f[i] = 0;\n\n    for (int i = n; i > 0; --i) {\n        while (mx < counts[i - 1]) {\n            mx++;\n            f[mx] = f[mx - 1] + i;\n        }\n        ans += f[counts[i - 1]];\n    }\n    return ans;\n}\n\nيرجى تقديم وصف موجز بلغة طبيعية (docstring) للكود المكتوب بلغة C باللغة العربية الفصحى، بحيث لا يتجاوز 500 حرف.",
      "sw": "long long maxModeSum(int n, const int* counts)\n{\n    long long ans = 0;\n    int mx = 0;\n    long long f[100000];\n    for (int i = 0; i <= n; ++i) f[i] = 0;\n\n    for (int i = n; i > 0; --i) {\n        while (mx < counts[i - 1]) {\n            mx++;\n            f[mx] = f[mx - 1] + i;\n        }\n        ans += f[counts[i - 1]];\n    }\n    return ans;\n}\n\nToa maelezo mafupi ya lugha ya asili (docstring) ya msimbo wa C kwa Kiswahili kwa kutumia herufi zisizozidi 500.",
      "tr": "long long maxModeSum(int n, const int* counts)\n{\n    long long ans = 0;\n    int mx = 0;\n    long long f[100000];\n    for (int i = 0; i <= n; ++i) f[i] = 0;\n\n    for (int i = n; i > 0; --i) {\n        while (mx < counts[i - 1]) {\n            mx++;\n            f[mx] = f[mx - 1] + i;\n        }\n        ans += f[counts[i - 1]];\n    }\n    return ans;\n}\n\nC kodunun işlevini açıklayan en fazla 500 karakterlik kısa bir doğal dil açıklaması (docstring) sağlayın.",
      "vi": "long long maxModeSum(int n, const int* counts)\n{\n    long long ans = 0;\n    int mx = 0;\n    long long f[100000];\n    for (int i = 0; i <= n; ++i) f[i] = 0;\n\n    for (int i = n; i > 0; --i) {\n        while (mx < counts[i - 1]) {\n            mx++;\n            f[mx] = f[mx - 1] + i;\n        }\n        ans += f[counts[i - 1]];\n    }\n    return ans;\n}\n\nCung cấp mô tả ngắn gọn bằng ngôn ngữ tự nhiên (docstring) cho mã C bằng tiếng Việt với tối đa 500 ký tự."
    },
    "instruction_bertscore": {
      "es": "0.9687963589217052",
      "arb": "0.8727085148353161",
      "sw": "0.9423429634058599",
      "tr": "0.8637917984002789",
      "vi": "0.9133171058252317"
    },
    "level": "",
    "test": "int main() {\n    assert(maxModeSum(3, (int[]){1, 3, 2}) == 17);\n    assert(maxModeSum(4, (int[]){4, 1, 2, 3}) == 37);\n    assert(maxModeSum(2, (int[]){1, 1}) == 4);\n    assert(maxModeSum(5, (int[]){1, 2, 3, 4, 5}) == 75);\n    assert(maxModeSum(1, (int[]){100000}) == 100000);\n    assert(maxModeSum(5, (int[]){5, 3, 2, 4, 1}) == 62);\n    assert(maxModeSum(3, (int[]){100000, 100000, 100000}) == 900000);\n    assert(maxModeSum(3, (int[]){2, 2, 5}) == 27);\n    assert(maxModeSum(4, (int[]){4, 4, 4, 4}) == 64);\n    assert(maxModeSum(6, (int[]){1, 2, 3, 4, 5, 6}) == 126);\n    assert(maxModeSum(3, (int[]){3, 1, 2}) == 16);\n    return 0;\n}",
    "entry_point": "maxModeSum",
    "signature": "long long maxModeSum(int n, const int* counts)",
    "docstring": {
      "es": "Dado n enteros positivos que representan la cantidad de cada número de 1 a n, \nencuentra la suma máxima del modo (elemento más frecuente) para todos los prefijos de \nuna secuencia construida a partir de estos números. El modo es el número más grande entre \nlos elementos más frecuentes en una secuencia.\n    >>> maxModeSum(3, (int[]){1, 2, 3})\n    17\n    Una secuencia que alcanza su valor máximo es (3,2,3,1,2,2).",
      "arb": "نظرًا لوجود n من الأعداد الصحيحة الموجبة التي تمثل عدد كل رقم من 1 إلى n، \nابحث عن الحد الأقصى لمجموع النمط (العنصر الأكثر تكرارًا) لجميع البادئات \nلسلسلة مبنية من هذه الأرقام. النمط هو أكبر رقم بين العناصر الأكثر تكرارًا في سلسلة.\n    >>> maxModeSum(3, (int[]){1, 2, 3})\n    17\n    سلسلة تصل إلى قيمتها القصوى هي (3,2,3,1,2,2).",
      "sw": "Ukipatiwa n nambari chanya zinazowakilisha idadi ya kila nambari kutoka 1 hadi n, \ntafuta jumla ya juu zaidi ya modi (kipengele kinachojitokeza mara nyingi zaidi) kwa awamu zote za \nmlolongo ulioundwa kutoka kwa nambari hizi. Modi ni nambari kubwa zaidi kati ya \nvipengele vinavyojitokeza mara nyingi zaidi katika mlolongo.\n    >>> maxModeSum(3, (int[]){1, 2, 3})\n    17\n    Mlolongo unaofikia thamani yake ya juu zaidi ni (3,2,3,1,2,2).",
      "tr": "Verilen n pozitif tamsayı, 1'den n'ye kadar olan her sayının sayısını temsil eder, \nbu sayılardan oluşturulan bir dizinin tüm önekleri için modun (en sık görülen eleman) maksimum toplamını bulun. \nMod, bir dizideki en sık görülen elemanlar arasında en büyük sayıdır.\n    >>> maxModeSum(3, (int[]){1, 2, 3})\n    17\n    Maksimum değerine ulaşan bir dizi (3,2,3,1,2,2) şeklindedir.",
      "vi": "Cho n số nguyên dương đại diện cho số lượng của mỗi số từ 1 đến n, tìm tổng lớn nhất của mode (phần tử xuất hiện nhiều nhất) cho tất cả các tiền tố của một dãy được tạo thành từ các số này. Mode là số lớn nhất trong số các phần tử xuất hiện nhiều nhất trong một dãy.\n    >>> maxModeSum(3, (int[]){1, 2, 3})\n    17\n    Một dãy đạt giá trị tối đa là (3,2,3,1,2,2)."
    },
    "docstring_bertscore": {
      "es": "0.9924723058195398",
      "arb": "0.9746041126327843",
      "sw": "0.9266956565094555",
      "tr": "0.9475784629891775",
      "vi": "0.9619732067027759"
    }
  },
  {
    "task_id": "C/39",
    "prompt": {
      "es": "#include <assert.h>\n#include <stdio.h>\n/*\nDado un array A de enteros, la tarea es calcular la suma del XOR de todos los subarrays.\nUn subarray se define por un par de índices (L, R) tal que 1 <= L <= R <= n, donde n es el tamaño del array.\nLa suma XOR de un subarray es el resultado de aplicar XOR a todos los elementos desde L hasta R.\nEl resultado final es la suma de las sumas XOR para todos los subarrays posibles.\n\nCasos de ejemplo:\n    >>> sumOfXorSubarrays({1, 2, 3, 4, 5}, 5)\n    39\n*/\nlong long sumOfXorSubarrays(int A[], int n)",
      "arb": "#include <assert.h>\n#include <stdio.h>\n/*\nبالنظر إلى مصفوفة A من الأعداد الصحيحة، المهمة هي حساب مجموع XOR لجميع المقاطع الفرعية.\nيتم تعريف المقطع الفرعي بواسطة زوج من الفهارس (L, R) بحيث 1 <= L <= R <= n، حيث n هو حجم المصفوفة.\nمجموع XOR للمقطع الفرعي هو نتيجة XOR لجميع العناصر من L إلى R.\nالنتيجة النهائية هي مجموع نتائج XOR لجميع المقاطع الفرعية الممكنة.\n\nحالات المثال:\n    >>> sumOfXorSubarrays({1, 2, 3, 4, 5}, 5)\n    39\n*/\nlong long sumOfXorSubarrays(int A[], int n)",
      "sw": "#include <assert.h>\n#include <stdio.h>\n/*\nUkipiwa safu A ya nambari za mzima, kazi ni kuhesabu jumla ya XOR ya sehemu zote ndogo.\nSehemu ndogo inafafanuliwa na jozi ya fahirisi (L, R) ambapo 1 <= L <= R <= n, ambapo n ni ukubwa wa safu.\nJumla ya XOR ya sehemu ndogo ni matokeo ya XOR ya vipengele vyote kutoka L hadi R.\nMatokeo ya mwisho ni jumla ya XOR kwa sehemu ndogo zote zinazowezekana.\n\nMifano ya kesi:\n    >>> sumOfXorSubarrays({1, 2, 3, 4, 5}, 5)\n    39\n*/\nlong long sumOfXorSubarrays(int A[], int n)",
      "tr": "#include <assert.h>\n#include <stdio.h>\n/*\nBir tamsayı dizisi A verildiğinde, görev tüm alt dizilerin XOR toplamını hesaplamaktır.\nBir alt dizi, 1 <= L <= R <= n olacak şekilde (L, R) indeks çifti ile tanımlanır, burada n dizinin boyutudur.\nBir alt dizinin XOR toplamı, L'den R'ye kadar olan tüm elemanların XOR işlemi sonucudur.\nSonuç, tüm olası alt dizilerin XOR toplamlarının toplamıdır.\n\nÖrnek durumlar:\n    >>> sumOfXorSubarrays({1, 2, 3, 4, 5}, 5)\n    39\n*/\nlong long sumOfXorSubarrays(int A[], int n)",
      "vi": "#include <assert.h>\n#include <stdio.h>\n/*\nCho một mảng A gồm các số nguyên, nhiệm vụ là tính tổng của XOR của tất cả các mảng con.\nMột mảng con được định nghĩa bởi một cặp chỉ số (L, R) sao cho 1 <= L <= R <= n, trong đó n là kích thước của mảng.\nTổng XOR của một mảng con là kết quả của việc XOR tất cả các phần tử từ L đến R.\nKết quả cuối cùng là tổng của các tổng XOR cho tất cả các mảng con có thể.\n\nCác trường hợp ví dụ:\n    >>> sumOfXorSubarrays({1, 2, 3, 4, 5}, 5)\n    39\n*/\nlong long sumOfXorSubarrays(int A[], int n)"
    },
    "prompt_bertscore": {
      "es": "0.9920212162242096",
      "arb": "0.9733535357537887",
      "sw": "0.9598548136890388",
      "tr": "0.9638488733908883",
      "vi": "0.9959183443001141"
    },
    "canonical_solution": "{\n    long long q[100010] = {0}, w[100010][2] = {{0}}, ans = 0;\n    for (int i = 1; i <= n; i++) q[i] = q[i - 1] ^ A[i - 1];\n    for (int i = 0; i <= n; i++)\n        for (int j = 20; j >= 0; j--)\n            w[j][(q[i] >> j) & 1]++;\n    for (int i = 0; i <= 20; i++)\n        ans += w[i][0] * w[i][1] * (1LL << i);\n    return ans;\n}",
    "instruction": {
      "es": "long long sumOfXorSubarrays(int A[], int n)\n{\n    long long q[100010] = {0}, w[100010][2] = {{0}}, ans = 0;\n    for (int i = 1; i <= n; i++) q[i] = q[i - 1] ^ A[i - 1];\n    for (int i = 0; i <= n; i++)\n        for (int j = 20; j >= 0; j--)\n            w[j][(q[i] >> j) & 1]++;\n    for (int i = 0; i <= 20; i++)\n        ans += w[i][0] * w[i][1] * (1LL << i);\n    return ans;\n}\n\nProporcione una descripción concisa en lenguaje natural (docstring) del código C en español utilizando como máximo 500 caracteres.",
      "arb": "long long sumOfXorSubarrays(int A[], int n)\n{\n    long long q[100010] = {0}, w[100010][2] = {{0}}, ans = 0;\n    for (int i = 1; i <= n; i++) q[i] = q[i - 1] ^ A[i - 1];\n    for (int i = 0; i <= n; i++)\n        for (int j = 20; j >= 0; j--)\n            w[j][(q[i] >> j) & 1]++;\n    for (int i = 0; i <= 20; i++)\n        ans += w[i][0] * w[i][1] * (1LL << i);\n    return ans;\n}\n\nيرجى تقديم وصف موجز بلغة طبيعية (docstring) للكود المكتوب بلغة C باللغة العربية الفصحى، بحيث لا يتجاوز 500 حرف.",
      "sw": "long long sumOfXorSubarrays(int A[], int n)\n{\n    long long q[100010] = {0}, w[100010][2] = {{0}}, ans = 0;\n    for (int i = 1; i <= n; i++) q[i] = q[i - 1] ^ A[i - 1];\n    for (int i = 0; i <= n; i++)\n        for (int j = 20; j >= 0; j--)\n            w[j][(q[i] >> j) & 1]++;\n    for (int i = 0; i <= 20; i++)\n        ans += w[i][0] * w[i][1] * (1LL << i);\n    return ans;\n}\n\nToa maelezo mafupi ya lugha asilia (docstring) ya msimbo wa C kwa Kiswahili kwa kutumia herufi zisizozidi 500.",
      "tr": "long long sumOfXorSubarrays(int A[], int n)\n{\n    long long q[100010] = {0}, w[100010][2] = {{0}}, ans = 0;\n    for (int i = 1; i <= n; i++) q[i] = q[i - 1] ^ A[i - 1];\n    for (int i = 0; i <= n; i++)\n        for (int j = 20; j >= 0; j--)\n            w[j][(q[i] >> j) & 1]++;\n    for (int i = 0; i <= 20; i++)\n        ans += w[i][0] * w[i][1] * (1LL << i);\n    return ans;\n}\n\nC kodunun işlevini açıklayan kısa bir doğal dil açıklaması (docstring) sağlayın. Açıklama, en fazla 500 karakter kullanılarak Türkçe olarak yazılmalıdır.",
      "vi": "long long sumOfXorSubarrays(int A[], int n)\n{\n    long long q[100010] = {0}, w[100010][2] = {{0}}, ans = 0;\n    for (int i = 1; i <= n; i++) q[i] = q[i - 1] ^ A[i - 1];\n    for (int i = 0; i <= n; i++)\n        for (int j = 20; j >= 0; j--)\n            w[j][(q[i] >> j) & 1]++;\n    for (int i = 0; i <= 20; i++)\n        ans += w[i][0] * w[i][1] * (1LL << i);\n    return ans;\n}\n\nCung cấp mô tả ngắn gọn bằng ngôn ngữ tự nhiên (docstring) của mã C bằng tiếng Việt, không quá 500 ký tự."
    },
    "instruction_bertscore": {
      "es": "0.9687963589217052",
      "arb": "0.8609607195793886",
      "sw": "0.9423429634058599",
      "tr": "0.8690074349454929",
      "vi": "0.9255499564716463"
    },
    "level": "",
    "test": "int main() {\n    int test[] = {1,2, 3, 4, 5};\n    assert(sumOfXorSubarrays(test, 5) == 39);\n    int test1[] = {1, 1, 1};\n    assert(sumOfXorSubarrays(test1, 3) == 4);\n    \n    int test2[] = {2, 3, 1};\n    assert(sumOfXorSubarrays(test2, 3) == 9);\n    \n    int test3[] = {4, 5, 7, 9};\n    assert(sumOfXorSubarrays(test3, 4) == 74);\n    \n    int test4[] = {0, 0, 0, 0};\n    assert(sumOfXorSubarrays(test4, 4) == 0);\n    \n    int test5[] = {8, 8, 8, 8, 8};\n    assert(sumOfXorSubarrays(test5, 5) == 72);\n    \n    int test6[] = {3, 6, 9, 12, 15};\n    assert(sumOfXorSubarrays(test6, 5) == 125);\n    \n    int test7[] = {10, 20, 30, 40, 50};\n    assert(sumOfXorSubarrays(test7, 5) == 390);\n    \n    int test8[] = {16, 16, 16, 16, 16, 16};\n    assert(sumOfXorSubarrays(test8, 6) == 192);\n    \n    int test9[] = {1, 3, 5, 7, 9, 11, 13};\n    assert(sumOfXorSubarrays(test9, 7) == 192);\n    \n    int test10[] = {0, 1, 2, 3, 4, 5, 6, 7, 8, 9};\n    assert(sumOfXorSubarrays(test10, 10) == 218);\n    \n    return 0;\n}",
    "entry_point": "sumOfXorSubarrays",
    "signature": "long long sumOfXorSubarrays(int A[], int n)",
    "docstring": {
      "es": "Dado un array A de enteros, la tarea es calcular la suma del XOR de todos los subarrays.  \nUn subarray se define por un par de índices (L, R) tal que 1 <= L <= R <= n, donde n es el tamaño del array.  \nLa suma XOR de un subarray es el resultado de aplicar XOR a todos los elementos desde L hasta R.  \nEl resultado final es la suma de las sumas XOR para todos los subarrays posibles.\n\nCasos de ejemplo:\n    >>> sumOfXorSubarrays({1, 2, 3, 4, 5}, 5)\n    39",
      "arb": "معطى مصفوفة A من الأعداد الصحيحة، المهمة هي حساب مجموع XOR لجميع القطع الفرعية.\nيتم تعريف القطعة الفرعية بواسطة زوج من الفهارس (L, R) بحيث 1 <= L <= R <= n، حيث n هو حجم المصفوفة.\nمجموع XOR للقطعة الفرعية هو نتيجة XOR لجميع العناصر من L إلى R.\nالنتيجة النهائية هي مجموع نتائج XOR لجميع القطع الفرعية الممكنة.\n\nأمثلة الحالات:\n    >>> sumOfXorSubarrays({1, 2, 3, 4, 5}, 5)\n    39",
      "sw": "Kwa kupewa safu A ya nambari za mzima, kazi ni kuhesabu jumla ya XOR ya sehemu ndogo zote za safu hiyo. \nSehemu ndogo ya safu inafafanuliwa na jozi ya faharasa (L, R) ambapo 1 <= L <= R <= n, ambapo n ni ukubwa wa safu. \nJumla ya XOR ya sehemu ndogo ya safu ni matokeo ya kufanya XOR kwa vipengele vyote kutoka L hadi R. \nMatokeo ya mwisho ni jumla ya jumla za XOR kwa sehemu ndogo zote zinazowezekana.\n\nMifano ya kesi:\n    >>> sumOfXorSubarrays({1, 2, 3, 4, 5}, 5)\n    39",
      "tr": "Verilen bir tamsayı dizisi A için, tüm alt dizilerin XOR toplamını hesaplama görevi.\nBir alt dizi, (L, R) indeks çifti ile tanımlanır ve burada 1 <= L <= R <= n, n dizinin boyutudur.\nBir alt dizinin XOR toplamı, L'den R'ye kadar olan tüm elemanların XOR işlemi sonucudur.\nSonuç, tüm olası alt dizilerin XOR toplamlarının toplamıdır.\n\nÖrnek durumlar:\n    >>> sumOfXorSubarrays({1, 2, 3, 4, 5}, 5)\n    39",
      "vi": "Cho một mảng A gồm các số nguyên, nhiệm vụ là tính tổng của XOR của tất cả các mảng con.  \nMột mảng con được định nghĩa bởi một cặp chỉ số (L, R) sao cho 1 <= L <= R <= n, trong đó n là kích thước của mảng.  \nTổng XOR của một mảng con là kết quả của việc XOR tất cả các phần tử từ L đến R.  \nKết quả cuối cùng là tổng của các tổng XOR cho tất cả các mảng con có thể.  \n\nCác trường hợp ví dụ:\n    >>> sumOfXorSubarrays({1, 2, 3, 4, 5}, 5)\n    39"
    },
    "docstring_bertscore": {
      "es": "0.9911249959449802",
      "arb": "0.9658047867529388",
      "sw": "0.9572132282516558",
      "tr": "0.9469966746031263",
      "vi": "0.9957681797320517"
    }
  },
  {
    "task_id": "C/40",
    "prompt": {
      "es": "#include <assert.h>\n#include <math.h>\n#include <stdbool.h>\n#include <stdio.h>\n#include <stdlib.h>\n/*\nDado dos enteros positivos n y k, encuentra el número de enteros positivos x, donde 1 <= x <= n, que pueden expresarse como x = a^b con a y b siendo enteros positivos y b >= k.\nDiferentes representaciones legales del mismo número se cuentan solo una vez.\n    >>> countPowerNumbers(99, 1)\n    99\n*/\nint countPowerNumbers(int n, int k)",
      "arb": "#include <assert.h>\n#include <math.h>\n#include <stdbool.h>\n#include <stdio.h>\n#include <stdlib.h>\n/*\nبالنظر إلى عددين صحيحين موجبين n و k، جد عدد الأعداد الصحيحة الموجبة x، حيث 1 <= x <= n، التي يمكن التعبير عنها كـ x = a^b مع كون a و b عددين صحيحين موجبين و b >= k.\nيتم احتساب التمثيلات القانونية المختلفة لنفس الرقم مرة واحدة فقط.\n    >>> countPowerNumbers(99, 1)\n    99\n*/\nint countPowerNumbers(int n, int k)",
      "sw": "#include <assert.h>\n#include <math.h>\n#include <stdbool.h>\n#include <stdio.h>\n#include <stdlib.h>\n/*\nUkipiwa nambari mbili nzima chanya n na k, pata idadi ya nambari chanya x, ambapo 1 <= x <= n, ambazo zinaweza kuonyeshwa kama x = a^b huku a na b wakiwa nambari nzima chanya na b >= k.\nMwakilishi tofauti halali wa nambari sawa huhesabiwa mara moja tu.\n    >>> countPowerNumbers(99, 1)\n    99\n*/\nint countPowerNumbers(int n, int k)",
      "tr": "#include <assert.h>\n#include <math.h>\n#include <stdbool.h>\n#include <stdio.h>\n#include <stdlib.h>\n/*\nİki pozitif tam sayı n ve k verildiğinde, 1 <= x <= n aralığında, x = a^b şeklinde ifade edilebilen pozitif tam sayı x'lerin sayısını bulun. Burada a ve b pozitif tam sayılar ve b >= k.\nAynı sayının farklı yasal temsilleri yalnızca bir kez sayılır.\n    >>> countPowerNumbers(99, 1)\n    99\n*/\nint countPowerNumbers(int n, int k)",
      "vi": "#include <assert.h>\n#include <math.h>\n#include <stdbool.h>\n#include <stdio.h>\n#include <stdlib.h>\n/*\nCho hai số nguyên dương n và k, tìm số lượng số nguyên dương x, với 1 <= x <= n, có thể được biểu diễn dưới dạng x = a^b với a và b là các số nguyên dương và b >= k.\nCác biểu diễn hợp lệ khác nhau của cùng một số chỉ được đếm một lần.\n    >>> countPowerNumbers(99, 1)\n    99\n*/\nint countPowerNumbers(int n, int k)"
    },
    "prompt_bertscore": {
      "es": "0.999999801369619",
      "arb": "0.999999801369619",
      "sw": "0.9576911329484257",
      "tr": "0.9235729882892061",
      "vi": "0.9544093617929673"
    },
    "canonical_solution": "{\n    int count = 0;\n    int x = 0;\n    bool *mp = (bool *)calloc(n + 1, sizeof(bool));\n    \n    for (int i = 2; i <= cbrt(n); ++i) {\n        long long t = i * i;\n        int m = 2;\n        while (t <= n / i) {\n            t *= i;\n            m++;\n            if (m < k || mp[t]) continue;\n            if ((int)sqrt(t) * (int)sqrt(t) == t) x++;\n            mp[t] = true;\n            count++;\n        }\n    }\n    if (k == 1) {\n        count = n;\n    } else if (k >= 3) {\n        count += 1;\n    } else {\n        count += (int)sqrt(n) - x;\n    }\n    free(mp);\n    return count;\n}",
    "instruction": {
      "es": "int countPowerNumbers(int n, int k)\n{\n    int count = 0;\n    int x = 0;\n    bool *mp = (bool *)calloc(n + 1, sizeof(bool));\n    \n    for (int i = 2; i <= cbrt(n); ++i) {\n        long long t = i * i;\n        int m = 2;\n        while (t <= n / i) {\n            t *= i;\n            m++;\n            if (m < k || mp[t]) continue;\n            if ((int)sqrt(t) * (int)sqrt(t) == t) x++;\n            mp[t] = true;\n            count++;\n        }\n    }\n    if (k == 1) {\n        count = n;\n    } else if (k >= 3) {\n        count += 1;\n    } else {\n        count += (int)sqrt(n) - x;\n    }\n    free(mp);\n    return count;\n}\n\nProporcione una descripción concisa en lenguaje natural (docstring) del código C en español utilizando como máximo 500 caracteres.",
      "arb": "int countPowerNumbers(int n, int k)\n{\n    int count = 0;\n    int x = 0;\n    bool *mp = (bool *)calloc(n + 1, sizeof(bool));\n    \n    for (int i = 2; i <= cbrt(n); ++i) {\n        long long t = i * i;\n        int m = 2;\n        while (t <= n / i) {\n            t *= i;\n            m++;\n            if (m < k || mp[t]) continue;\n            if ((int)sqrt(t) * (int)sqrt(t) == t) x++;\n            mp[t] = true;\n            count++;\n        }\n    }\n    if (k == 1) {\n        count = n;\n    } else if (k >= 3) {\n        count += 1;\n    } else {\n        count += (int)sqrt(n) - x;\n    }\n    free(mp);\n    return count;\n}\n\nيرجى تقديم وصف موجز بلغة طبيعية (docstring) للكود المكتوب بلغة C باللغة العربية الفصحى، بحيث لا يتجاوز 500 حرف.",
      "sw": "int countPowerNumbers(int n, int k)\n{\n    int count = 0;\n    int x = 0;\n    bool *mp = (bool *)calloc(n + 1, sizeof(bool));\n    \n    for (int i = 2; i <= cbrt(n); ++i) {\n        long long t = i * i;\n        int m = 2;\n        while (t <= n / i) {\n            t *= i;\n            m++;\n            if (m < k || mp[t]) continue;\n            if ((int)sqrt(t) * (int)sqrt(t) == t) x++;\n            mp[t] = true;\n            count++;\n        }\n    }\n    if (k == 1) {\n        count = n;\n    } else if (k >= 3) {\n        count += 1;\n    } else {\n        count += (int)sqrt(n) - x;\n    }\n    free(mp);\n    return count;\n}\n\nToa maelezo mafupi ya lugha ya asili (docstring) ya msimbo wa C kwa Kiswahili kwa kutumia herufi zisizozidi 500.",
      "tr": "int countPowerNumbers(int n, int k)\n{\n    int count = 0;\n    int x = 0;\n    bool *mp = (bool *)calloc(n + 1, sizeof(bool));\n    \n    for (int i = 2; i <= cbrt(n); ++i) {\n        long long t = i * i;\n        int m = 2;\n        while (t <= n / i) {\n            t *= i;\n            m++;\n            if (m < k || mp[t]) continue;\n            if ((int)sqrt(t) * (int)sqrt(t) == t) x++;\n            mp[t] = true;\n            count++;\n        }\n    }\n    if (k == 1) {\n        count = n;\n    } else if (k >= 3) {\n        count += 1;\n    } else {\n        count += (int)sqrt(n) - x;\n    }\n    free(mp);\n    return count;\n}\n\nC kodunun işlevini açıklayan kısa bir doğal dil açıklaması (docstring) sağlayın. Açıklama, en fazla 500 karakter kullanılarak Türkçe olarak yazılmalıdır.",
      "vi": "int countPowerNumbers(int n, int k)\n{\n    int count = 0;\n    int x = 0;\n    bool *mp = (bool *)calloc(n + 1, sizeof(bool));\n    \n    for (int i = 2; i <= cbrt(n); ++i) {\n        long long t = i * i;\n        int m = 2;\n        while (t <= n / i) {\n            t *= i;\n            m++;\n            if (m < k || mp[t]) continue;\n            if ((int)sqrt(t) * (int)sqrt(t) == t) x++;\n            mp[t] = true;\n            count++;\n        }\n    }\n    if (k == 1) {\n        count = n;\n    } else if (k >= 3) {\n        count += 1;\n    } else {\n        count += (int)sqrt(n) - x;\n    }\n    free(mp);\n    return count;\n}\n\nCung cấp mô tả ngắn gọn bằng ngôn ngữ tự nhiên (docstring) của mã C bằng tiếng Việt, sử dụng tối đa 500 ký tự."
    },
    "instruction_bertscore": {
      "es": "0.9687963589217052",
      "arb": "0.8727085148353161",
      "sw": "0.9146175389298671",
      "tr": "0.8690074349454929",
      "vi": "0.946887229263176"
    },
    "level": "",
    "test": "int main() {\n    assert(countPowerNumbers(99, 1) == 99);\n    assert(countPowerNumbers(99, 3) == 7);\n    assert(countPowerNumbers(99, 2) == 12);\n    assert(countPowerNumbers(10, 1) == 10);\n    assert(countPowerNumbers(10, 2) == 4);\n    assert(countPowerNumbers(500, 1) == 500);\n    assert(countPowerNumbers(500, 2) == 30);\n    assert(countPowerNumbers(500, 3) == 13);\n    assert(countPowerNumbers(1000, 1) == 1000);\n    assert(countPowerNumbers(1000, 2) == 41);\n    assert(countPowerNumbers(1000, 3) == 17);\n    assert(countPowerNumbers(1000, 93) == 1);\n    assert(countPowerNumbers(50, 2) == 10);\n    assert(countPowerNumbers(50, 3) == 5);\n    assert(countPowerNumbers(2, 3) == 1);\n    return 0;\n}",
    "entry_point": "countPowerNumbers",
    "signature": "int countPowerNumbers(int n, int k)",
    "docstring": {
      "es": "Dado dos enteros positivos n y k, encuentra el número de enteros positivos x, donde 1 <= x <= n, que pueden expresarse como x = a^b con a y b siendo enteros positivos y b >= k.\nDiferentes representaciones legales del mismo número se cuentan solo una vez.\n    >>> countPowerNumbers(99, 1)\n    99",
      "arb": "معطى عددان صحيحان موجبان n و k، ابحث عن عدد الأعداد الصحيحة الموجبة x، حيث 1 <= x <= n، التي يمكن التعبير عنها كـ x = a^b مع كون a و b عددين صحيحين موجبين و b >= k. يتم احتساب التمثيلات القانونية المختلفة لنفس الرقم مرة واحدة فقط.\n    >>> countPowerNumbers(99, 1)\n    99",
      "sw": "Ukipewa nambari mbili chanya n na k, pata idadi ya nambari chanya x, ambapo 1 <= x <= n, ambazo zinaweza kuonyeshwa kama x = a^b huku a na b wakiwa nambari chanya na b >= k. Uwakilishi tofauti halali wa nambari sawa huhesabiwa mara moja tu.\n    >>> countPowerNumbers(99, 1)\n    99",
      "tr": "İki pozitif tamsayı n ve k verildiğinde, 1 <= x <= n aralığında x = a^b şeklinde ifade edilebilen pozitif tamsayı x sayısını bulun, burada a ve b pozitif tamsayılardır ve b >= k'dır. Aynı sayının farklı yasal temsilleri yalnızca bir kez sayılır.\n    >>> countPowerNumbers(99, 1)\n    99",
      "vi": "Cho hai số nguyên dương n và k, tìm số lượng số nguyên dương x, với 1 <= x <= n, có thể được biểu diễn dưới dạng x = a^b với a và b là các số nguyên dương và b >= k. Các biểu diễn hợp lệ khác nhau của cùng một số chỉ được đếm một lần.  \n    >>> countPowerNumbers(99, 1)  \n    99  "
    },
    "docstring_bertscore": {
      "es": "0.9999996027392379",
      "arb": "0.9902891593015853",
      "sw": "0.9700463399095578",
      "tr": "0.9290915361654983",
      "vi": "0.9674724874321078"
    }
  },
  {
    "task_id": "C/41",
    "prompt": {
      "es": "#include <stdio.h>\n#include <assert.h>\n/*\nDado tres enteros n, m, y k, encuentra el número de secuencias que consisten en n '(' y m ')', tal que la subsecuencia balanceada más larga tiene una longitud de 2 * k. El resultado debe calcularse módulo 1,000,000,007 (10^9 + 7).\n\nPor ejemplo:\n    >>> countBalancedSubsequences(2, 2, 2)\n    2\n*/\nlong long countBalancedSubsequences(long long n, long long m, long long k)",
      "arb": "#include <stdio.h>\n#include <assert.h>\n/*\nمعطى ثلاثة أعداد صحيحة n و m و k، قم بإيجاد عدد التتابعات المكونة من n '(' و m ')', بحيث يكون أطول تتابع متوازن بطول 2 * k. يجب حساب النتيجة بتطبيق باقي القسمة على 1,000,000,007 (10^9 + 7).\n\nعلى سبيل المثال:\n    >>> countBalancedSubsequences(2, 2, 2)\n    2\n*/\nlong long countBalancedSubsequences(long long n, long long m, long long k)",
      "sw": "#include <stdio.h>\n#include <assert.h>\n/*\nUkipewa nambari tatu n, m, na k, pata idadi ya mlolongo unaojumuisha n '(' na m ')', ili kwamba mlolongo mrefu zaidi ulio sawa una urefu wa 2 * k. Matokeo yanapaswa kuhesabiwa kwa modulo 1,000,000,007 (10^9 + 7).\n\nKwa mfano:\n    >>> countBalancedSubsequences(2, 2, 2)\n    2\n*/\nlong long countBalancedSubsequences(long long n, long long m, long long k)",
      "tr": "#include <stdio.h>\n#include <assert.h>\n/*\nÜç tamsayı n, m ve k verildiğinde, n '(' ve m ')' karakterlerinden oluşan dizilerin sayısını bulun, böylece en uzun dengeli alt dizi uzunluğu 2 * k olur. Sonuç, 1,000,000,007 (10^9 + 7) ile mod alınarak hesaplanmalıdır.\n\nÖrneğin:\n    >>> countBalancedSubsequences(2, 2, 2)\n    2\n*/\nlong long countBalancedSubsequences(long long n, long long m, long long k)",
      "vi": "#include <stdio.h>\n#include <assert.h>\n/*\nCho ba số nguyên n, m và k, tìm số lượng dãy gồm n '(' và m ')', sao cho dãy con cân bằng dài nhất có độ dài là 2 * k. Kết quả cần được tính theo modulo 1,000,000,007 (10^9 + 7).\n\nVí dụ:\n    >>> countBalancedSubsequences(2, 2, 2)\n    2\n*/\nlong long countBalancedSubsequences(long long n, long long m, long long k)"
    },
    "prompt_bertscore": {
      "es": "0.9900637138191107",
      "arb": "0.9999996027392379",
      "sw": "0.9841483024415107",
      "tr": "0.9775003422186541",
      "vi": "0.9838733979941585"
    },
    "canonical_solution": "{\n    const long long P = 1e9 + 7;\n    static long long C[4001][4001] = {0};\n\n    // Compute binomial coefficients only once.\n    if (C[0][0] == 0) {\n        for (long long i = 0; i <= 4000; i++) C[i][0] = 1;\n        for (long long i = 1; i <= 4000; i++)\n            for (long long j = 1; j <= i; j++)\n                C[i][j] = (C[i - 1][j - 1] + C[i - 1][j]) % P;\n    }\n    // Calculate the number of balanced subsequences.\n    if (k > n || k > m) return 0;\n    return (C[n + m][k] - C[n + m][k - 1] + P) % P;\n}",
    "instruction": {
      "es": "long long countBalancedSubsequences(long long n, long long m, long long k)\n{\n    const long long P = 1e9 + 7;\n    static long long C[4001][4001] = {0};\n\n    // Compute binomial coefficients only once.\n    if (C[0][0] == 0) {\n        for (long long i = 0; i <= 4000; i++) C[i][0] = 1;\n        for (long long i = 1; i <= 4000; i++)\n            for (long long j = 1; j <= i; j++)\n                C[i][j] = (C[i - 1][j - 1] + C[i - 1][j]) % P;\n    }\n    // Calculate the number of balanced subsequences.\n    if (k > n || k > m) return 0;\n    return (C[n + m][k] - C[n + m][k - 1] + P) % P;\n}\n\nProporcione una descripción concisa en lenguaje natural (docstring) del código C en español utilizando como máximo 500 caracteres.",
      "arb": "long long countBalancedSubsequences(long long n, long long m, long long k)\n{\n    const long long P = 1e9 + 7;\n    static long long C[4001][4001] = {0};\n\n    // Compute binomial coefficients only once.\n    if (C[0][0] == 0) {\n        for (long long i = 0; i <= 4000; i++) C[i][0] = 1;\n        for (long long i = 1; i <= 4000; i++)\n            for (long long j = 1; j <= i; j++)\n                C[i][j] = (C[i - 1][j - 1] + C[i - 1][j]) % P;\n    }\n    // Calculate the number of balanced subsequences.\n    if (k > n || k > m) return 0;\n    return (C[n + m][k] - C[n + m][k - 1] + P) % P;\n}\n\nيرجى تقديم وصف موجز بلغة طبيعية (docstring) للكود المكتوب بلغة C باللغة العربية الفصحى، بحيث لا يتجاوز 500 حرف.",
      "sw": "long long countBalancedSubsequences(long long n, long long m, long long k)\n{\n    const long long P = 1e9 + 7;\n    static long long C[4001][4001] = {0};\n\n    // Compute binomial coefficients only once.\n    if (C[0][0] == 0) {\n        for (long long i = 0; i <= 4000; i++) C[i][0] = 1;\n        for (long long i = 1; i <= 4000; i++)\n            for (long long j = 1; j <= i; j++)\n                C[i][j] = (C[i - 1][j - 1] + C[i - 1][j]) % P;\n    }\n    // Calculate the number of balanced subsequences.\n    if (k > n || k > m) return 0;\n    return (C[n + m][k] - C[n + m][k - 1] + P) % P;\n}\n\nToa maelezo mafupi ya lugha ya asili (docstring) ya msimbo wa C kwa Kiswahili kwa kutumia herufi zisizozidi 500.",
      "tr": "long long countBalancedSubsequences(long long n, long long m, long long k)\n{\n    const long long P = 1e9 + 7;\n    static long long C[4001][4001] = {0};\n\n    // Compute binomial coefficients only once.\n    if (C[0][0] == 0) {\n        for (long long i = 0; i <= 4000; i++) C[i][0] = 1;\n        for (long long i = 1; i <= 4000; i++)\n            for (long long j = 1; j <= i; j++)\n                C[i][j] = (C[i - 1][j - 1] + C[i - 1][j]) % P;\n    }\n    // Calculate the number of balanced subsequences.\n    if (k > n || k > m) return 0;\n    return (C[n + m][k] - C[n + m][k - 1] + P) % P;\n}\n\nC kodunun işlevini açıklayan, en fazla 500 karakter uzunluğunda, Türkçe bir açıklama (docstring) sağlayın.",
      "vi": "long long countBalancedSubsequences(long long n, long long m, long long k)\n{\n    const long long P = 1e9 + 7;\n    static long long C[4001][4001] = {0};\n\n    // Compute binomial coefficients only once.\n    if (C[0][0] == 0) {\n        for (long long i = 0; i <= 4000; i++) C[i][0] = 1;\n        for (long long i = 1; i <= 4000; i++)\n            for (long long j = 1; j <= i; j++)\n                C[i][j] = (C[i - 1][j - 1] + C[i - 1][j]) % P;\n    }\n    // Calculate the number of balanced subsequences.\n    if (k > n || k > m) return 0;\n    return (C[n + m][k] - C[n + m][k - 1] + P) % P;\n}\n\nCung cấp mô tả ngắn gọn bằng ngôn ngữ tự nhiên (docstring) của mã C bằng tiếng Việt, sử dụng tối đa 500 ký tự."
    },
    "instruction_bertscore": {
      "es": "0.9687963589217052",
      "arb": "0.8727085148353161",
      "sw": "0.9146175389298671",
      "tr": "0.8383633356505735",
      "vi": "0.9627502487533843"
    },
    "level": "",
    "test": "int main() {\n    assert(countBalancedSubsequences(2, 2, 2) == 2);\n    assert(countBalancedSubsequences(3, 2, 3) == 0);\n    assert(countBalancedSubsequences(3, 2, 1) == 4);\n    assert(countBalancedSubsequences(4, 3, 2) == 14);\n    assert(countBalancedSubsequences(5, 5, 2) == 35);\n    assert(countBalancedSubsequences(6, 1, 1) == 6);\n    assert(countBalancedSubsequences(1, 6, 1) == 6);\n    assert(countBalancedSubsequences(7, 2, 2) == 27);\n    assert(countBalancedSubsequences(8, 3, 3) == 110);\n    assert(countBalancedSubsequences(10, 10, 5) == 10659);\n    assert(countBalancedSubsequences(20, 20, 10) == 574221648);\n    assert(countBalancedSubsequences(2000, 2000, 1000) == 854104531);\n    assert(countBalancedSubsequences(2000, 1999, 1000) == 334874485);\n    assert(countBalancedSubsequences(2000, 2000, 1999) == 259428024);\n    return 0;\n}",
    "entry_point": "countBalancedSubsequences",
    "signature": "long long countBalancedSubsequences(long long n, long long m, long long k)",
    "docstring": {
      "es": "Dado tres enteros n, m y k, encuentra el número de secuencias que consisten en n '(' y m ')', tal que la subsecuencia balanceada más larga sea de longitud 2 * k. El resultado debe ser calculado módulo 1,000,000,007 (10^9 + 7).\n\nPor ejemplo:\n    >>> countBalancedSubsequences(2, 2, 2)\n    2",
      "arb": "إعطاء ثلاثة أعداد صحيحة n، m، و k، ابحث عن عدد التتابعات المكونة من n '(' و m ')', بحيث يكون أطول تتابع متوازن بطول 2 * k. يجب حساب النتيجة بتطبيق المودولو 1,000,000,007 (10^9 + 7).\n\nعلى سبيل المثال:\n    >>> countBalancedSubsequences(2, 2, 2)\n    2",
      "sw": "Kwa kupewa nambari tatu za mzima n, m, na k, tafuta idadi ya mlolongo unaojumuisha n '(' na m ')', ili kwamba mlolongo mrefu zaidi ulio sawa una urefu wa 2 * k. Matokeo yanapaswa kuhesabiwa kwa moduli 1,000,000,007 (10^9 + 7).\n\nKwa mfano:\n    >>> countBalancedSubsequences(2, 2, 2)\n    2",
      "tr": "Üç tamsayı n, m ve k verildiğinde, n '(' ve m ')' karakterlerinden oluşan dizilerin sayısını bulun, öyle ki en uzun dengeli alt dizi uzunluğu 2 * k olsun. Sonuç, 1,000,000,007 (10^9 + 7) ile mod alınarak hesaplanmalıdır.\n\nÖrneğin:\n    >>> countBalancedSubsequences(2, 2, 2)\n    2",
      "vi": "Cho ba số nguyên n, m và k, tìm số lượng dãy bao gồm n dấu '(' và m dấu ')', sao cho dãy con cân bằng dài nhất có độ dài là 2 * k. Kết quả cần được tính theo modulo 1,000,000,007 (10^9 + 7).\n\nVí dụ:\n    >>> countBalancedSubsequences(2, 2, 2)\n    2"
    },
    "docstring_bertscore": {
      "es": "0.9964649751087221",
      "arb": "0.980898908038161",
      "sw": "0.9842877409689973",
      "tr": "0.9725582197081251",
      "vi": "0.9798666259479227"
    }
  },
  {
    "task_id": "C/42",
    "prompt": {
      "es": "#include <stdio.h>\n#include <assert.h>\n/*\nDado un papel rectangular de tamaño n x m colocado en un sistema de coordenadas Cartesianas en un plano con su esquina inferior izquierda en (0,0) y la esquina superior derecha en (n,m),\nnecesitas calcular el número esperado de operaciones para cortar el papel de tal manera que el área restante sea menor que k.\nEn cada operación, se elige aleatoriamente una línea que es paralela a los ejes, pasa por puntos con coordenadas enteras y corta (no solo toca el borde) el papel. La parte inferior o derecha del papel a lo largo de esta línea se descarta.\nLa respuesta debe ser módulo 10^9+7.\n\nPor ejemplo:\n    >>> expectedCuts(3, 3, 4)\n    3\n*/\nlong long expectedCuts(int n, int m, long long k)",
      "arb": "#include <stdio.h>\n#include <assert.h>\n/*\nمعطى ورقة مستطيلة بحجم n x m موضوعة على نظام إحداثيات ديكارتي مستوي مع وجود زاويتها السفلية اليسرى عند (0,0) والزاوية العلوية اليمنى عند (n,m)، \nتحتاج إلى حساب العدد المتوقع من العمليات لقطع الورقة بحيث تكون المساحة المتبقية أقل من k. \nفي كل عملية، يتم اختيار خط عشوائي موازٍ للمحاور، يمر عبر نقاط ذات إحداثيات صحيحة، ويقطع (وليس فقط يلامس الحافة) الورقة. ثم يتم التخلص من الجزء السفلي أو الأيمن من الورقة على طول هذا الخط.\nيجب أن تكون الإجابة موديولو 10^9+7.\n\nعلى سبيل المثال:\n    >>> expectedCuts(3, 3, 4)\n    3\n*/\nlong long expectedCuts(int n, int m, long long k)",
      "sw": "#include <stdio.h>\n#include <assert.h>\n/*\nUkipiwa karatasi ya mstatili ya ukubwa n x m iliyowekwa kwenye mfumo wa kuratibu wa Cartesian kwenye ndege na kona yake ya chini-kushoto iko kwenye (0,0) na kona ya juu-kulia iko kwenye (n,m), \nunahitaji kuhesabu idadi inayotarajiwa ya operesheni za kukata karatasi ili eneo lililobaki liwe chini ya k. \nKatika kila operesheni, mstari unachaguliwa kwa nasibu ambao ni sambamba na mhimili, unapita kwenye pointi zenye kuratibu za namba nzima, na unakata (sio kugusa tu ukingo) karatasi. Sehemu ya chini au ya kulia ya karatasi kando ya mstari huu kisha hutupwa.\nJibu linapaswa kuwa modulo 10^9+7.\n\nKwa mfano:\n    >>> expectedCuts(3, 3, 4)\n    3\n*/\nlong long expectedCuts(int n, int m, long long k)",
      "tr": "#include <stdio.h>\n#include <assert.h>\n/*\nn x m boyutunda bir dikdörtgen kağıt, alt-sol köşesi (0,0) ve üst-sağ köşesi (n,m) olan bir düzlem Kartezyen koordinat sistemine yerleştirilmiştir. \nKağıdı kesmek için gereken beklenen işlem sayısını hesaplamanız gerekiyor, böylece kalan alan k'dan küçük olur. \nHer işlemde, eksenlere paralel olan, tam sayı koordinatlarına sahip noktalardan geçen ve kağıdı kesen (sadece kenara dokunmayan) bir çizgi rastgele seçilir. Bu çizgi boyunca kağıdın alt veya sağ kısmı atılır.\nCevap 10^9+7 modunda olmalıdır.\n\nÖrneğin:\n    >>> expectedCuts(3, 3, 4)\n    3\n*/\nlong long expectedCuts(int n, int m, long long k)",
      "vi": "#include <stdio.h>\n#include <assert.h>\n/*\nCho một tờ giấy hình chữ nhật kích thước n x m đặt trên hệ tọa độ phẳng Đề-các với góc dưới bên trái tại (0,0) và góc trên bên phải tại (n,m),\nbạn cần tính số lượng thao tác kỳ vọng để cắt tờ giấy sao cho diện tích còn lại nhỏ hơn k.\nTrong mỗi thao tác, một đường thẳng được chọn ngẫu nhiên song song với các trục, đi qua các điểm có tọa độ nguyên, và cắt qua (không chỉ chạm vào cạnh) tờ giấy. Phần dưới hoặc bên phải của tờ giấy dọc theo đường này sau đó bị loại bỏ.\nCâu trả lời cần lấy modulo 10^9+7.\n\nVí dụ:\n    >>> expectedCuts(3, 3, 4)\n    3\n*/\nlong long expectedCuts(int n, int m, long long k)"
    },
    "prompt_bertscore": {
      "es": "0.9707276421165075",
      "arb": "0.9421653878452148",
      "sw": "0.9625651252382598",
      "tr": "0.9535270456404104",
      "vi": "0.9320777453139769"
    },
    "canonical_solution": "{\n    const int MD = 1000000007;\n    const int N = 1000000;\n    int vv[N * 2 + 1], i, j;\n    long long ans = 1;\n\n    vv[1] = 1;\n    for (i = 2; i <= N * 2; i++)\n        vv[i] = (long long)vv[i - MD % i] * (MD / i + 1) % MD;\n    if (k > (long long)n * m) {\n        return 0;\n    }\n    for (i = (k + m - 1) / m; i < n; i++)\n        ans = (ans + vv[i + (k + i - 1) / i - 1]) % MD;\n    for (j = (k + n - 1) / n; j < m; j++)\n        ans = (ans + vv[(k + j - 1) / j + j - 1]) % MD;\n\n    return ans;\n}",
    "instruction": {
      "es": "long long expectedCuts(int n, int m, long long k)\n{\n    const int MD = 1000000007;\n    const int N = 1000000;\n    int vv[N * 2 + 1], i, j;\n    long long ans = 1;\n\n    vv[1] = 1;\n    for (i = 2; i <= N * 2; i++)\n        vv[i] = (long long)vv[i - MD % i] * (MD / i + 1) % MD;\n    if (k > (long long)n * m) {\n        return 0;\n    }\n    for (i = (k + m - 1) / m; i < n; i++)\n        ans = (ans + vv[i + (k + i - 1) / i - 1]) % MD;\n    for (j = (k + n - 1) / n; j < m; j++)\n        ans = (ans + vv[(k + j - 1) / j + j - 1]) % MD;\n\n    return ans;\n}\n\nProporcione una descripción concisa en lenguaje natural (docstring) del código C en español utilizando como máximo 500 caracteres.",
      "arb": "long long expectedCuts(int n, int m, long long k)\n{\n    const int MD = 1000000007;\n    const int N = 1000000;\n    int vv[N * 2 + 1], i, j;\n    long long ans = 1;\n\n    vv[1] = 1;\n    for (i = 2; i <= N * 2; i++)\n        vv[i] = (long long)vv[i - MD % i] * (MD / i + 1) % MD;\n    if (k > (long long)n * m) {\n        return 0;\n    }\n    for (i = (k + m - 1) / m; i < n; i++)\n        ans = (ans + vv[i + (k + i - 1) / i - 1]) % MD;\n    for (j = (k + n - 1) / n; j < m; j++)\n        ans = (ans + vv[(k + j - 1) / j + j - 1]) % MD;\n\n    return ans;\n}\n\nيرجى تقديم وصف موجز بلغة طبيعية (docstring) للكود المكتوب بلغة C باللغة العربية الفصحى، على ألا يتجاوز 500 حرف.",
      "sw": "long long expectedCuts(int n, int m, long long k)\n{\n    const int MD = 1000000007;\n    const int N = 1000000;\n    int vv[N * 2 + 1], i, j;\n    long long ans = 1;\n\n    vv[1] = 1;\n    for (i = 2; i <= N * 2; i++)\n        vv[i] = (long long)vv[i - MD % i] * (MD / i + 1) % MD;\n    if (k > (long long)n * m) {\n        return 0;\n    }\n    for (i = (k + m - 1) / m; i < n; i++)\n        ans = (ans + vv[i + (k + i - 1) / i - 1]) % MD;\n    for (j = (k + n - 1) / n; j < m; j++)\n        ans = (ans + vv[(k + j - 1) / j + j - 1]) % MD;\n\n    return ans;\n}\n\nToa maelezo mafupi ya lugha ya asili (docstring) ya msimbo wa C kwa Kiswahili kwa kutumia herufi zisizozidi 500.",
      "tr": "long long expectedCuts(int n, int m, long long k)\n{\n    const int MD = 1000000007;\n    const int N = 1000000;\n    int vv[N * 2 + 1], i, j;\n    long long ans = 1;\n\n    vv[1] = 1;\n    for (i = 2; i <= N * 2; i++)\n        vv[i] = (long long)vv[i - MD % i] * (MD / i + 1) % MD;\n    if (k > (long long)n * m) {\n        return 0;\n    }\n    for (i = (k + m - 1) / m; i < n; i++)\n        ans = (ans + vv[i + (k + i - 1) / i - 1]) % MD;\n    for (j = (k + n - 1) / n; j < m; j++)\n        ans = (ans + vv[(k + j - 1) / j + j - 1]) % MD;\n\n    return ans;\n}\n\nC kodunun işlevini açıklayan kısa bir doğal dil açıklaması (docstring) sağlayın. Açıklama, en fazla 500 karakter kullanılarak Türkçe olarak yazılmalıdır.",
      "vi": "long long expectedCuts(int n, int m, long long k)\n{\n    const int MD = 1000000007;\n    const int N = 1000000;\n    int vv[N * 2 + 1], i, j;\n    long long ans = 1;\n\n    vv[1] = 1;\n    for (i = 2; i <= N * 2; i++)\n        vv[i] = (long long)vv[i - MD % i] * (MD / i + 1) % MD;\n    if (k > (long long)n * m) {\n        return 0;\n    }\n    for (i = (k + m - 1) / m; i < n; i++)\n        ans = (ans + vv[i + (k + i - 1) / i - 1]) % MD;\n    for (j = (k + n - 1) / n; j < m; j++)\n        ans = (ans + vv[(k + j - 1) / j + j - 1]) % MD;\n\n    return ans;\n}\n\nCung cấp mô tả ngắn gọn bằng ngôn ngữ tự nhiên (docstring) của mã C bằng tiếng Việt với tối đa 500 ký tự."
    },
    "instruction_bertscore": {
      "es": "0.9687963589217052",
      "arb": "0.8800316197233103",
      "sw": "0.9146175389298671",
      "tr": "0.8690074349454929",
      "vi": "0.9439043968311751"
    },
    "level": "",
    "test": "int main() {\n    assert(expectedCuts(2, 4, 10) == 0);\n    assert(expectedCuts(2, 4, 8) == 1);\n    assert(expectedCuts(2, 4, 2) == 833333342);\n    assert(expectedCuts(2, 4, 6) == 250000003);\n    assert(expectedCuts(3, 3, 4) == 666666673);\n    assert(expectedCuts(5, 5, 12) == 666666673);\n    assert(expectedCuts(6, 7, 20) == 722222229);\n    assert(expectedCuts(8, 8, 30) == 72727275);\n    assert(expectedCuts(10, 10, 50) == 714285721);\n    assert(expectedCuts(1, 10, 5) == 945634929);\n    assert(expectedCuts(10, 1, 5) == 945634929);\n    return 0;\n}",
    "entry_point": "expectedCuts",
    "signature": "long long expectedCuts(int n, int m, long long k)",
    "docstring": {
      "es": "Dado un papel rectangular de tamaño n x m colocado en un sistema de coordenadas cartesianas en un plano con su esquina inferior izquierda en (0,0) y la esquina superior derecha en (n,m), necesitas calcular el número esperado de operaciones para cortar el papel de tal manera que el área restante sea menor que k. En cada operación, se elige aleatoriamente una línea que es paralela a los ejes, pasa por puntos con coordenadas enteras, y corta (no solo toca el borde) el papel. La parte inferior o derecha del papel a lo largo de esta línea se descarta. La respuesta debe ser módulo 10^9+7.\n\nPor ejemplo:\n    >>> expectedCuts(3, 3, 4)\n    3",
      "arb": "معطى ورقة مستطيلة بحجم n x m موضوعة على نظام إحداثيات ديكارتي مستوي مع زاويتها السفلية اليسرى عند (0,0) وزاويتها العلوية اليمنى عند (n,m)، تحتاج إلى حساب العدد المتوقع من العمليات لقطع الورقة بحيث تكون المساحة المتبقية أقل من k. في كل عملية، يتم اختيار خط عشوائي موازٍ للمحاور، يمر عبر نقاط ذات إحداثيات صحيحة، ويقطع (وليس فقط يلامس الحافة) الورقة. يتم بعد ذلك التخلص من الجزء السفلي أو الأيمن من الورقة على طول هذا الخط. يجب أن تكون الإجابة بتقسيم الباقي على 10^9+7.\n\nعلى سبيل المثال:\n    >>> expectedCuts(3, 3, 4)\n    3",
      "sw": "Kwa kuzingatia karatasi ya mstatili yenye ukubwa wa n x m iliyowekwa kwenye mfumo wa kuratibu wa Cartesian kwenye ndege na kona yake ya chini-kushoto iko kwenye (0,0) na kona ya juu-kulia iko kwenye (n,m), unahitaji kuhesabu idadi inayotarajiwa ya operesheni za kukata karatasi ili eneo lililobaki liwe chini ya k. Katika kila operesheni, mstari unachaguliwa kwa nasibu ambao ni sambamba na mhimili, unapita kupitia pointi zenye kuratibu za nambari kamili, na unakata (si kugusa tu ukingo) karatasi. Sehemu ya chini au ya kulia ya karatasi kando ya mstari huu kisha hutupwa. Jibu linapaswa kuwa modulo 10^9+7.\n\nKwa mfano:\n    >>> expectedCuts(3, 3, 4)\n    3",
      "tr": "Verilen bir dikdörtgen kağıt, n x m boyutlarında olup, düzlem Kartezyen koordinat sisteminde sol alt köşesi (0,0) ve sağ üst köşesi (n,m) olacak şekilde yerleştirilmiştir. \nKağıdın kalan alanının k'dan küçük olması için gereken beklenen işlem sayısını hesaplamanız gerekmektedir. \nHer işlemde, eksenlere paralel olan, tam sayı koordinatlarına sahip noktalardan geçen ve kağıdı kesen (sadece kenara dokunmayan) bir çizgi rastgele seçilir. Bu çizgi boyunca kağıdın alt veya sağ kısmı atılır.\nCevap, 10^9+7 ile mod alınmalıdır.\n\nÖrneğin:\n    >>> expectedCuts(3, 3, 4)\n    3",
      "vi": "Cho một tờ giấy hình chữ nhật kích thước n x m được đặt trên hệ tọa độ Đề-các phẳng với góc dưới bên trái tại (0,0) và góc trên bên phải tại (n,m), bạn cần tính số lượng kỳ vọng các thao tác để cắt giấy sao cho diện tích còn lại nhỏ hơn k. Trong mỗi thao tác, một đường thẳng được chọn ngẫu nhiên song song với các trục, đi qua các điểm có tọa độ nguyên và cắt qua (không chỉ chạm vào cạnh) tờ giấy. Phần dưới hoặc bên phải của tờ giấy dọc theo đường này sau đó bị loại bỏ. Câu trả lời nên được tính theo modulo 10^9+7.\n\nVí dụ:\n    >>> expectedCuts(3, 3, 4)\n    3"
    },
    "docstring_bertscore": {
      "es": "0.974613448260693",
      "arb": "0.9329731710716822",
      "sw": "0.9559398088788411",
      "tr": "0.9160909790963839",
      "vi": "0.9367761483469761"
    }
  },
  {
    "task_id": "C/43",
    "prompt": {
      "es": "#include <stdio.h>\n#include <assert.h>\n#include <string.h>\n/*\nDada una permutación q de n elementos y un entero k, encuentra el número de permutaciones p de n elementos tal que f(p) = q, donde f(p) es la permutación lexicográficamente más pequeña que se puede obtener dividiendo p en exactamente k segmentos contiguos no vacíos y ordenando cada segmento (es decir, elige $ k-1 $ puntos de ruptura $ 1\\le x_1 < x_2 < \\cdots < x_{k-1} < n $, y divídelo en $ [1, x_1], (x_1, x_2], \\cdots, (x_{k-1}, n] $). El resultado debe ser módulo 998244353.\n    >>> countPermutations(2, 1, [1, 2])\n    2\n\n*/\nint countPermutations(int n, int k, int qq[])",
      "arb": "#include <stdio.h>\n#include <assert.h>\n#include <string.h>\n/*\nبالنظر إلى تبديل q من n عنصرًا وعدد صحيح k، ابحث عن عدد التبديلات p من n عنصرًا بحيث يكون f(p) = q، حيث أن f(p) هو التبديل الأصغر لغويًا الذي يمكن الحصول عليه عن طريق تقسيم p إلى k مقاطع متجاورة غير فارغة بالضبط وترتيب كل مقطع (أي، اختر $ k-1 $ نقاط توقف $ 1\\le x_1 < x_2 < \\cdots < x_{k-1} < n $، وقسمها إلى $ [1, x_1], (x_1, x_2], \\cdots, (x_{k-1}, n] $). يجب أن تكون النتيجة موديولو 998244353.\n    >>> countPermutations(2, 1, [1, 2])\n    2\n\n*/\nint countPermutations(int n, int k, int qq[])",
      "sw": "#include <stdio.h>\n#include <assert.h>\n#include <string.h>\n/*\nIkizingatiwa permutation q ya vipengele n na nambari k, pata idadi ya permutations p ya vipengele n kama f(p) = q, ambapo f(p) ni permutation ndogo zaidi kwa mpangilio wa lexicographically ambayo inaweza kupatikana kwa kugawanya p katika sehemu k zisizo tupu zinazofuatana na kupanga kila sehemu (yaani, chagua $ k-1 $ alama za kuvunja $ 1\\le x_1 < x_2 < \\cdots < x_{k-1} < n $, na igawanye katika $ [1, x_1], (x_1, x_2], \\cdots, (x_{k-1}, n] $). Matokeo yanapaswa kuwa modulo 998244353.\n    >>> countPermutations(2, 1, [1, 2])\n    2\n\n*/\nint countPermutations(int n, int k, int qq[])",
      "tr": "#include <stdio.h>\n#include <assert.h>\n#include <string.h>\n/*\nn elemanlı bir q permütasyonu ve bir tamsayı k verildiğinde, f(p) = q olacak şekilde n elemanlı kaç tane p permütasyonu olduğunu bulun, burada f(p), p'yi tam olarak k boş olmayan ardışık segmente bölerek ve her segmenti sıralayarak elde edilebilecek sözlük sırasına göre en küçük permütasyondur (yani, $ 1\\le x_1 < x_2 < \\cdots < x_{k-1} < n $ olacak şekilde $ k-1 $ kırılma noktası seçin ve bunu $ [1, x_1], (x_1, x_2], \\cdots, (x_{k-1}, n] $ olarak bölün). Sonuç 998244353 ile mod alınmalıdır.\n    >>> countPermutations(2, 1, [1, 2])\n    2\n\n*/\nint countPermutations(int n, int k, int qq[])",
      "vi": "#include <stdio.h>\n#include <assert.h>\n#include <string.h>\n/*\nCho một hoán vị q của n phần tử và một số nguyên k, tìm số lượng hoán vị p của n phần tử sao cho f(p) = q, trong đó f(p) là hoán vị nhỏ nhất theo thứ tự từ điển có thể thu được bằng cách chia p thành chính xác k đoạn liên tiếp không rỗng và sắp xếp từng đoạn (tức là, chọn $ k-1 $ điểm ngắt $ 1\\le x_1 < x_2 < \\cdots < x_{k-1} < n $, và chia nó thành $ [1, x_1], (x_1, x_2], \\cdots, (x_{k-1}, n] $). Kết quả phải được lấy modulo 998244353.\n    >>> countPermutations(2, 1, [1, 2])\n    2\n\n*/\nint countPermutations(int n, int k, int qq[])"
    },
    "prompt_bertscore": {
      "es": "0.9959606525712745",
      "arb": "0.9945644796229803",
      "sw": "0.9496793765293835",
      "tr": "0.9737656937944361",
      "vi": "0.9558331443642254"
    },
    "canonical_solution": "{\n    const int N = 505, P = 998244353;\n    int q[N], m, dp[N][N], jc[N], f[N], ans;\n    memset(q, 0, sizeof(q));\n    memset(dp, 0, sizeof(dp));\n    memset(jc, 0, sizeof(jc));\n    memset(f, 0, sizeof(f));\n    ans = 0;\n\n    for (int i = 1; i <= n; i++)\n        q[i] = qq[i - 1];\n    dp[0][0] = f[0] = 1;\n    for (int i = jc[0] = 1; i <= n; i++)\n        jc[i] = 1LL * jc[i - 1] * i % P;\n    for (int i = 1; i <= n; i++)\n    {\n        f[i] = jc[i];\n        for (int j = 1; j < i; j++)\n            f[i] = (f[i] + P - 1LL * f[j] * jc[i - j] % P) % P;\n    }\n    for (int i = 1; i <= n; i++)\n    {\n        for (int j = 0; j < i; j++)\n            for (int k = 1; k <= n; k++)\n                dp[i][k] = (dp[i][k] + dp[j][k - 1] * 1LL * f[i - j] % P) % P;\n    }\n    m = 0;\n    for (int i = 1; i <= n; i++)\n        if (q[i] > q[i + 1])\n        {\n            m = i;\n            break;\n        }\n    if (m == n)\n    {\n        for (int i = k; i <= n; i++)\n            ans = (ans + dp[n][i]) % P;\n    }\n    else\n    {\n        for (int i = m + 1; i <= n; i++)\n        {\n            if (i ^ m + 1 && (q[i - 1] > q[i] || q[i] < q[m]))\n                break;\n            int c = k + i - n - 1;\n            if (c >= 0)\n                ans = (ans + dp[m][c] * 1LL * jc[i - m - 1] % P) % P;\n        }\n    }\n    return ans;\n}",
    "instruction": {
      "es": "int countPermutations(int n, int k, int qq[])\n{\n    const int N = 505, P = 998244353;\n    int q[N], m, dp[N][N], jc[N], f[N], ans;\n    memset(q, 0, sizeof(q));\n    memset(dp, 0, sizeof(dp));\n    memset(jc, 0, sizeof(jc));\n    memset(f, 0, sizeof(f));\n    ans = 0;\n\n    for (int i = 1; i <= n; i++)\n        q[i] = qq[i - 1];\n    dp[0][0] = f[0] = 1;\n    for (int i = jc[0] = 1; i <= n; i++)\n        jc[i] = 1LL * jc[i - 1] * i % P;\n    for (int i = 1; i <= n; i++)\n    {\n        f[i] = jc[i];\n        for (int j = 1; j < i; j++)\n            f[i] = (f[i] + P - 1LL * f[j] * jc[i - j] % P) % P;\n    }\n    for (int i = 1; i <= n; i++)\n    {\n        for (int j = 0; j < i; j++)\n            for (int k = 1; k <= n; k++)\n                dp[i][k] = (dp[i][k] + dp[j][k - 1] * 1LL * f[i - j] % P) % P;\n    }\n    m = 0;\n    for (int i = 1; i <= n; i++)\n        if (q[i] > q[i + 1])\n        {\n            m = i;\n            break;\n        }\n    if (m == n)\n    {\n        for (int i = k; i <= n; i++)\n            ans = (ans + dp[n][i]) % P;\n    }\n    else\n    {\n        for (int i = m + 1; i <= n; i++)\n        {\n            if (i ^ m + 1 && (q[i - 1] > q[i] || q[i] < q[m]))\n                break;\n            int c = k + i - n - 1;\n            if (c >= 0)\n                ans = (ans + dp[m][c] * 1LL * jc[i - m - 1] % P) % P;\n        }\n    }\n    return ans;\n}\n\nProporcione una descripción concisa en lenguaje natural (docstring) del código C en español utilizando como máximo 500 caracteres.",
      "arb": "int countPermutations(int n, int k, int qq[])\n{\n    const int N = 505, P = 998244353;\n    int q[N], m, dp[N][N], jc[N], f[N], ans;\n    memset(q, 0, sizeof(q));\n    memset(dp, 0, sizeof(dp));\n    memset(jc, 0, sizeof(jc));\n    memset(f, 0, sizeof(f));\n    ans = 0;\n\n    for (int i = 1; i <= n; i++)\n        q[i] = qq[i - 1];\n    dp[0][0] = f[0] = 1;\n    for (int i = jc[0] = 1; i <= n; i++)\n        jc[i] = 1LL * jc[i - 1] * i % P;\n    for (int i = 1; i <= n; i++)\n    {\n        f[i] = jc[i];\n        for (int j = 1; j < i; j++)\n            f[i] = (f[i] + P - 1LL * f[j] * jc[i - j] % P) % P;\n    }\n    for (int i = 1; i <= n; i++)\n    {\n        for (int j = 0; j < i; j++)\n            for (int k = 1; k <= n; k++)\n                dp[i][k] = (dp[i][k] + dp[j][k - 1] * 1LL * f[i - j] % P) % P;\n    }\n    m = 0;\n    for (int i = 1; i <= n; i++)\n        if (q[i] > q[i + 1])\n        {\n            m = i;\n            break;\n        }\n    if (m == n)\n    {\n        for (int i = k; i <= n; i++)\n            ans = (ans + dp[n][i]) % P;\n    }\n    else\n    {\n        for (int i = m + 1; i <= n; i++)\n        {\n            if (i ^ m + 1 && (q[i - 1] > q[i] || q[i] < q[m]))\n                break;\n            int c = k + i - n - 1;\n            if (c >= 0)\n                ans = (ans + dp[m][c] * 1LL * jc[i - m - 1] % P) % P;\n        }\n    }\n    return ans;\n}\n\nيرجى تقديم وصف موجز بلغة طبيعية (docstring) للكود المكتوب بلغة C باللغة العربية الفصحى، باستخدام 500 حرف كحد أقصى.",
      "sw": "int countPermutations(int n, int k, int qq[])\n{\n    const int N = 505, P = 998244353;\n    int q[N], m, dp[N][N], jc[N], f[N], ans;\n    memset(q, 0, sizeof(q));\n    memset(dp, 0, sizeof(dp));\n    memset(jc, 0, sizeof(jc));\n    memset(f, 0, sizeof(f));\n    ans = 0;\n\n    for (int i = 1; i <= n; i++)\n        q[i] = qq[i - 1];\n    dp[0][0] = f[0] = 1;\n    for (int i = jc[0] = 1; i <= n; i++)\n        jc[i] = 1LL * jc[i - 1] * i % P;\n    for (int i = 1; i <= n; i++)\n    {\n        f[i] = jc[i];\n        for (int j = 1; j < i; j++)\n            f[i] = (f[i] + P - 1LL * f[j] * jc[i - j] % P) % P;\n    }\n    for (int i = 1; i <= n; i++)\n    {\n        for (int j = 0; j < i; j++)\n            for (int k = 1; k <= n; k++)\n                dp[i][k] = (dp[i][k] + dp[j][k - 1] * 1LL * f[i - j] % P) % P;\n    }\n    m = 0;\n    for (int i = 1; i <= n; i++)\n        if (q[i] > q[i + 1])\n        {\n            m = i;\n            break;\n        }\n    if (m == n)\n    {\n        for (int i = k; i <= n; i++)\n            ans = (ans + dp[n][i]) % P;\n    }\n    else\n    {\n        for (int i = m + 1; i <= n; i++)\n        {\n            if (i ^ m + 1 && (q[i - 1] > q[i] || q[i] < q[m]))\n                break;\n            int c = k + i - n - 1;\n            if (c >= 0)\n                ans = (ans + dp[m][c] * 1LL * jc[i - m - 1] % P) % P;\n        }\n    }\n    return ans;\n}\n\nToa maelezo mafupi ya lugha ya asili (docstring) ya msimbo wa C kwa Kiswahili kwa kutumia herufi zisizozidi 500.",
      "tr": "int countPermutations(int n, int k, int qq[])\n{\n    const int N = 505, P = 998244353;\n    int q[N], m, dp[N][N], jc[N], f[N], ans;\n    memset(q, 0, sizeof(q));\n    memset(dp, 0, sizeof(dp));\n    memset(jc, 0, sizeof(jc));\n    memset(f, 0, sizeof(f));\n    ans = 0;\n\n    for (int i = 1; i <= n; i++)\n        q[i] = qq[i - 1];\n    dp[0][0] = f[0] = 1;\n    for (int i = jc[0] = 1; i <= n; i++)\n        jc[i] = 1LL * jc[i - 1] * i % P;\n    for (int i = 1; i <= n; i++)\n    {\n        f[i] = jc[i];\n        for (int j = 1; j < i; j++)\n            f[i] = (f[i] + P - 1LL * f[j] * jc[i - j] % P) % P;\n    }\n    for (int i = 1; i <= n; i++)\n    {\n        for (int j = 0; j < i; j++)\n            for (int k = 1; k <= n; k++)\n                dp[i][k] = (dp[i][k] + dp[j][k - 1] * 1LL * f[i - j] % P) % P;\n    }\n    m = 0;\n    for (int i = 1; i <= n; i++)\n        if (q[i] > q[i + 1])\n        {\n            m = i;\n            break;\n        }\n    if (m == n)\n    {\n        for (int i = k; i <= n; i++)\n            ans = (ans + dp[n][i]) % P;\n    }\n    else\n    {\n        for (int i = m + 1; i <= n; i++)\n        {\n            if (i ^ m + 1 && (q[i - 1] > q[i] || q[i] < q[m]))\n                break;\n            int c = k + i - n - 1;\n            if (c >= 0)\n                ans = (ans + dp[m][c] * 1LL * jc[i - m - 1] % P) % P;\n        }\n    }\n    return ans;\n}\n\nC kodunun işlevini açıklayan kısa bir doğal dil açıklaması (docstring) sağlayın. Açıklama Türkçe olmalı ve en fazla 500 karakter kullanılmalıdır.",
      "vi": "int countPermutations(int n, int k, int qq[])\n{\n    const int N = 505, P = 998244353;\n    int q[N], m, dp[N][N], jc[N], f[N], ans;\n    memset(q, 0, sizeof(q));\n    memset(dp, 0, sizeof(dp));\n    memset(jc, 0, sizeof(jc));\n    memset(f, 0, sizeof(f));\n    ans = 0;\n\n    for (int i = 1; i <= n; i++)\n        q[i] = qq[i - 1];\n    dp[0][0] = f[0] = 1;\n    for (int i = jc[0] = 1; i <= n; i++)\n        jc[i] = 1LL * jc[i - 1] * i % P;\n    for (int i = 1; i <= n; i++)\n    {\n        f[i] = jc[i];\n        for (int j = 1; j < i; j++)\n            f[i] = (f[i] + P - 1LL * f[j] * jc[i - j] % P) % P;\n    }\n    for (int i = 1; i <= n; i++)\n    {\n        for (int j = 0; j < i; j++)\n            for (int k = 1; k <= n; k++)\n                dp[i][k] = (dp[i][k] + dp[j][k - 1] * 1LL * f[i - j] % P) % P;\n    }\n    m = 0;\n    for (int i = 1; i <= n; i++)\n        if (q[i] > q[i + 1])\n        {\n            m = i;\n            break;\n        }\n    if (m == n)\n    {\n        for (int i = k; i <= n; i++)\n            ans = (ans + dp[n][i]) % P;\n    }\n    else\n    {\n        for (int i = m + 1; i <= n; i++)\n        {\n            if (i ^ m + 1 && (q[i - 1] > q[i] || q[i] < q[m]))\n                break;\n            int c = k + i - n - 1;\n            if (c >= 0)\n                ans = (ans + dp[m][c] * 1LL * jc[i - m - 1] % P) % P;\n        }\n    }\n    return ans;\n}\n\nCung cấp mô tả ngắn gọn bằng ngôn ngữ tự nhiên (docstring) của mã C bằng tiếng Việt, sử dụng tối đa 500 ký tự."
    },
    "instruction_bertscore": {
      "es": "0.9687963589217052",
      "arb": "0.8947302679198921",
      "sw": "0.9146175389298671",
      "tr": "0.8628683657588477",
      "vi": "0.927643123426992"
    },
    "level": "",
    "test": "int main() {\n    int q1[] = {1, 2};\n    assert(countPermutations(2, 1, q1) == 2);\n\n    int q2[] = {3, 1, 2};\n    assert(countPermutations(3, 3, q2) == 1);\n\n    int q3[] = {1, 2, 3, 6, 5, 4};\n    assert(countPermutations(6, 3, q3) == 13);\n\n    int q4[] = {1, 2, 3, 4, 5, 6};\n    assert(countPermutations(6, 1, q4) == 720);\n\n    int q5[] = {1, 2, 5, 3, 4, 5};\n    assert(countPermutations(6, 3, q5) == 0);\n\n    int q6[] = {1, 2, 3, 4, 5, 6, 7, 8, 9};\n    assert(countPermutations(9, 9, q6) == 1);\n\n    int q7[] = {1, 2, 3, 4, 5, 6, 7, 9, 8};\n    assert(countPermutations(9, 2, q7) == 29093);\n    return 0;}",
    "entry_point": "countPermutations",
    "signature": "int countPermutations(int n, int k, int qq[])",
    "docstring": {
      "es": "Dada una permutación q de n elementos y un entero k, encuentra el número de permutaciones p de n elementos tal que f(p) = q, donde f(p) es la permutación lexicográficamente más pequeña que se puede obtener dividiendo p en exactamente k segmentos contiguos no vacíos y ordenando cada segmento (es decir, elige $ k-1 $ puntos de ruptura $ 1\\le x_1 < x_2 < \\cdots < x_{k-1} < n $, y divídelo en $ [1, x_1], (x_1, x_2], \\cdots, (x_{k-1}, n] $). El resultado debe ser módulo 998244353.\n    >>> countPermutations(2, 1, [1, 2])\n    2",
      "arb": "معطى ترتيب q من n عنصرًا وعدد صحيح k، ابحث عن عدد الترتيبات p من n عنصرًا بحيث f(p) = q، حيث f(p) هو الترتيب الأصغر لغويًا الذي يمكن الحصول عليه عن طريق تقسيم p إلى k مقاطع متجاورة غير فارغة بالضبط وترتيب كل مقطع (أي اختيار $ k-1 $ نقاط توقف $ 1\\le x_1 < x_2 < \\cdots < x_{k-1} < n $، وتقسيمها إلى $ [1, x_1], (x_1, x_2], \\cdots, (x_{k-1}, n] $). يجب أن تكون النتيجة مودولو 998244353.\n    >>> countPermutations(2, 1, [1, 2])\n    2",
      "sw": "Given a permutation q of n elements and an integer k, find the number of permutations p of n elements such that f(p) = q, where f(p) is the lexicographically smallest permutation that can be obtained by dividing p into exactly k non-empty contiguous segments and sorting each segment(that is, choose $ k-1 $ breakpoints $ 1\\le x_1 < x_2 < \\cdots < x_{k-1} < n $, and divide it into $ [1, x_1], (x_1, x_2], \\cdots, (x_{k-1}, n] $). The result should be modulo 998244353.\n    >>> countPermutations(2, 1, [1, 2])\n    2\n\nArgs:\n    n: Idadi ya vipengele katika permutation.\n    k: Idadi ya sehemu zisizo tupu za mfululizo.\n    q: Permutation inayolengwa ya vipengele n.\n\nReturns:\n    Idadi ya permutations p za vipengele n kama ilivyoelezwa, moduli 998244353.\n\nExamples:\n    >>> countPermutations(3, 2, [1, 3, 2])\n    1",
      "tr": "Verilen n elemanlı bir q permütasyonu ve bir k tam sayısı için, f(p) = q olacak şekilde n elemanlı kaç tane p permütasyonu olduğunu bulun. Burada f(p), p'yi tam olarak k tane boş olmayan ardışık segmente bölüp her segmenti sıralayarak elde edilebilecek sözlük sırasına göre en küçük permütasyondur (yani, $ 1\\le x_1 < x_2 < \\cdots < x_{k-1} < n $ olacak şekilde $ k-1 $ tane kırılma noktası seçin ve bunu $ [1, x_1], (x_1, x_2], \\cdots, (x_{k-1}, n] $ olarak bölün). Sonuç 998244353 ile mod alınmalıdır.\n    >>> countPermutations(2, 1, [1, 2])\n    2",
      "vi": "Given a permutation q của n phần tử và một số nguyên k, tìm số lượng hoán vị p của n phần tử sao cho f(p) = q, trong đó f(p) là hoán vị nhỏ nhất theo thứ tự từ điển có thể thu được bằng cách chia p thành chính xác k đoạn liên tiếp không rỗng và sắp xếp từng đoạn (tức là, chọn $ k-1 $ điểm ngắt $ 1\\le x_1 < x_2 < \\cdots < x_{k-1} < n $, và chia nó thành $ [1, x_1], (x_1, x_2], \\cdots, (x_{k-1}, n] $). Kết quả nên được lấy modulo 998244353.\n    >>> countPermutations(2, 1, [1, 2])\n    2"
    },
    "docstring_bertscore": {
      "es": "0.9890566577872638",
      "arb": "0.9896277201327391",
      "sw": "0.9251741477907283",
      "tr": "0.9443288699554467",
      "vi": "0.970593963870071"
    }
  },
  {
    "task_id": "C/44",
    "prompt": {
      "es": "#include <stdio.h>\n#include <assert.h>\n#include <stdbool.h>\n/*\nDado un arreglo de n enteros distintos que representan las alturas de los amigos de Kira,\nencuentra el número de formas de elegir un triplete (a, b, c) tal que el máximo común divisor (GCD)\nde los valores máximo y mínimo del triplete sea 1.\n    >>> countTriplets([1, 5, 7])\n    1\n*/\nint countTriplets(int heights[], int n)",
      "arb": "#include <stdio.h>\n#include <assert.h>\n#include <stdbool.h>\n/*\nبالنظر إلى مصفوفة تحتوي على n عدد صحيح مميز تمثل ارتفاعات أصدقاء كيرا،\nابحث عن عدد الطرق لاختيار ثلاثية (a, b, c) بحيث يكون القاسم المشترك الأكبر (GCD)\nللقيمتين العظمى والصغرى للثلاثية هو 1.\n    >>> countTriplets([1, 5, 7])\n    1\n*/\nint countTriplets(int heights[], int n)",
      "sw": "#include <stdio.h>\n#include <assert.h>\n#include <stdbool.h>\n/*\nUkipiwa safu ya n ya nambari za kipekee zinazoashiria urefu wa marafiki wa Kira,\npata idadi ya njia za kuchagua tatu (a, b, c) ili kwamba mgawanyiko mkubwa zaidi wa kawaida (GCD)\nwa thamani za juu na za chini za tatu ni 1.\n    >>> countTriplets([1, 5, 7])\n    1\n*/\nint countTriplets(int heights[], int n)",
      "tr": "#include <stdio.h>\n#include <assert.h>\n#include <stdbool.h>\n/*\nKira'nın arkadaşlarının yüksekliklerini temsil eden n farklı tam sayıdan oluşan bir dizi verildiğinde,\nbir üçlü (a, b, c) seçmenin kaç yolu olduğunu bulun, öyle ki üçlünün maksimum ve minimum değerlerinin\nen büyük ortak böleni (GCD) 1 olsun.\n    >>> countTriplets([1, 5, 7])\n    1\n*/\nint countTriplets(int heights[], int n)",
      "vi": "#include <stdio.h>\n#include <assert.h>\n#include <stdbool.h>\n/*\nCho một mảng gồm n số nguyên khác nhau đại diện cho chiều cao của bạn bè Kira,\ntìm số cách chọn một bộ ba (a, b, c) sao cho ước số chung lớn nhất (GCD)\ncủa giá trị lớn nhất và nhỏ nhất của bộ ba là 1.\n    >>> countTriplets([1, 5, 7])\n    1\n*/\nint countTriplets(int heights[], int n)"
    },
    "prompt_bertscore": {
      "es": "0.999999801369619",
      "arb": "0.996265152945401",
      "sw": "0.9528165447674485",
      "tr": "0.9917042021360779",
      "vi": "0.999999801369619"
    },
    "canonical_solution": "{\n    int count = 0;\n    for (int i = 0; i < n; ++i) {\n        for (int j = i + 1; j < n; ++j) {\n            for (int k = j + 1; k < n; ++k) {\n                int minVal = (heights[i] < heights[j]) ? ((heights[i] < heights[k]) ? heights[i] : heights[k]) : ((heights[j] < heights[k]) ? heights[j] : heights[k]);\n                int maxVal = (heights[i] > heights[j]) ? ((heights[i] > heights[k]) ? heights[i] : heights[k]) : ((heights[j] > heights[k]) ? heights[j] : heights[k]);\n                int a = minVal, b = maxVal;\n                while (b != 0) {\n                    int t = b;\n                    b = a % b;\n                    a = t;\n                }\n                if (a == 1) {\n                    count++;\n                }\n            }\n        }\n    }\n    return count;\n}",
    "instruction": {
      "es": "int countTriplets(int heights[], int n)\n{\n    int count = 0;\n    for (int i = 0; i < n; ++i) {\n        for (int j = i + 1; j < n; ++j) {\n            for (int k = j + 1; k < n; ++k) {\n                int minVal = (heights[i] < heights[j]) ? ((heights[i] < heights[k]) ? heights[i] : heights[k]) : ((heights[j] < heights[k]) ? heights[j] : heights[k]);\n                int maxVal = (heights[i] > heights[j]) ? ((heights[i] > heights[k]) ? heights[i] : heights[k]) : ((heights[j] > heights[k]) ? heights[j] : heights[k]);\n                int a = minVal, b = maxVal;\n                while (b != 0) {\n                    int t = b;\n                    b = a % b;\n                    a = t;\n                }\n                if (a == 1) {\n                    count++;\n                }\n            }\n        }\n    }\n    return count;\n}\n\nProporcione una descripción concisa en lenguaje natural (docstring) del código C en español utilizando como máximo 500 caracteres.",
      "arb": "int countTriplets(int heights[], int n)\n{\n    int count = 0;\n    for (int i = 0; i < n; ++i) {\n        for (int j = i + 1; j < n; ++j) {\n            for (int k = j + 1; k < n; ++k) {\n                int minVal = (heights[i] < heights[j]) ? ((heights[i] < heights[k]) ? heights[i] : heights[k]) : ((heights[j] < heights[k]) ? heights[j] : heights[k]);\n                int maxVal = (heights[i] > heights[j]) ? ((heights[i] > heights[k]) ? heights[i] : heights[k]) : ((heights[j] > heights[k]) ? heights[j] : heights[k]);\n                int a = minVal, b = maxVal;\n                while (b != 0) {\n                    int t = b;\n                    b = a % b;\n                    a = t;\n                }\n                if (a == 1) {\n                    count++;\n                }\n            }\n        }\n    }\n    return count;\n}\n\nيرجى تقديم وصف موجز بلغة طبيعية (docstring) للكود المكتوب بلغة C باللغة العربية الفصحى، بحيث لا يتجاوز 500 حرف.",
      "sw": "int countTriplets(int heights[], int n)\n{\n    int count = 0;\n    for (int i = 0; i < n; ++i) {\n        for (int j = i + 1; j < n; ++j) {\n            for (int k = j + 1; k < n; ++k) {\n                int minVal = (heights[i] < heights[j]) ? ((heights[i] < heights[k]) ? heights[i] : heights[k]) : ((heights[j] < heights[k]) ? heights[j] : heights[k]);\n                int maxVal = (heights[i] > heights[j]) ? ((heights[i] > heights[k]) ? heights[i] : heights[k]) : ((heights[j] > heights[k]) ? heights[j] : heights[k]);\n                int a = minVal, b = maxVal;\n                while (b != 0) {\n                    int t = b;\n                    b = a % b;\n                    a = t;\n                }\n                if (a == 1) {\n                    count++;\n                }\n            }\n        }\n    }\n    return count;\n}\n\nToa maelezo mafupi ya lugha ya asili (docstring) ya msimbo wa C kwa Kiswahili kwa kutumia herufi zisizozidi 500.",
      "tr": "int countTriplets(int heights[], int n)\n{\n    int count = 0;\n    for (int i = 0; i < n; ++i) {\n        for (int j = i + 1; j < n; ++j) {\n            for (int k = j + 1; k < n; ++k) {\n                int minVal = (heights[i] < heights[j]) ? ((heights[i] < heights[k]) ? heights[i] : heights[k]) : ((heights[j] < heights[k]) ? heights[j] : heights[k]);\n                int maxVal = (heights[i] > heights[j]) ? ((heights[i] > heights[k]) ? heights[i] : heights[k]) : ((heights[j] > heights[k]) ? heights[j] : heights[k]);\n                int a = minVal, b = maxVal;\n                while (b != 0) {\n                    int t = b;\n                    b = a % b;\n                    a = t;\n                }\n                if (a == 1) {\n                    count++;\n                }\n            }\n        }\n    }\n    return count;\n}\n\nC kodunun işlevini açıklayan kısa bir doğal dil tanımı (docstring) sağlayın. Açıklama Türkçe olmalı ve en fazla 500 karakter kullanılmalıdır.",
      "vi": "int countTriplets(int heights[], int n)\n{\n    int count = 0;\n    for (int i = 0; i < n; ++i) {\n        for (int j = i + 1; j < n; ++j) {\n            for (int k = j + 1; k < n; ++k) {\n                int minVal = (heights[i] < heights[j]) ? ((heights[i] < heights[k]) ? heights[i] : heights[k]) : ((heights[j] < heights[k]) ? heights[j] : heights[k]);\n                int maxVal = (heights[i] > heights[j]) ? ((heights[i] > heights[k]) ? heights[i] : heights[k]) : ((heights[j] > heights[k]) ? heights[j] : heights[k]);\n                int a = minVal, b = maxVal;\n                while (b != 0) {\n                    int t = b;\n                    b = a % b;\n                    a = t;\n                }\n                if (a == 1) {\n                    count++;\n                }\n            }\n        }\n    }\n    return count;\n}\n\nCung cấp mô tả ngắn gọn bằng ngôn ngữ tự nhiên (docstring) cho mã C bằng tiếng Việt, không quá 500 ký tự."
    },
    "instruction_bertscore": {
      "es": "0.9687963589217052",
      "arb": "0.8727085148353161",
      "sw": "0.9146175389298671",
      "tr": "0.879358461361983",
      "vi": "0.9148437789338658"
    },
    "level": "",
    "test": "int main() {\n    int heights1[] = {1, 5, 7};\n    assert(countTriplets(heights1, 3) == 1);\n\n    int heights2[] = {1, 6, 2, 3};\n    assert(countTriplets(heights2, 4) == 3);\n\n    int heights3[] = {16, 4, 8, 2};\n    assert(countTriplets(heights3, 4) == 0);\n\n    int heights4[] = {10, 1, 6, 7, 9, 8, 4, 3, 5, 2};\n    assert(countTriplets(heights4, 10) == 77);\n\n    int heights5[] = {4, 5, 9, 11, 14};\n    assert(countTriplets(heights5, 5) == 7);\n\n    int heights6[] = {15, 10, 6, 9, 7, 3, 12, 8, 11, 1, 2};\n    assert(countTriplets(heights6, 11) == 104);\n\n    int heights7[] = {3, 7, 11, 13};\n    assert(countTriplets(heights7, 4) == 4);\n\n    int heights8[] = {5, 12, 13, 17, 19};\n    assert(countTriplets(heights8, 5) == 10);\n\n    int heights9[] = {2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12};\n    assert(countTriplets(heights9, 11) == 87);\n\n    int heights10[] = {1, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17};\n    assert(countTriplets(heights10, 11) == 122);\n\n    return 0;\n}",
    "entry_point": "countTriplets",
    "signature": "int countTriplets(int heights[], int n)",
    "docstring": {
      "es": "Dado un array de n enteros distintos que representan las alturas de los amigos de Kira, encuentra el número de formas de elegir un triplete (a, b, c) tal que el máximo común divisor (MCD) de los valores máximo y mínimo del triplete sea 1.\n    >>> countTriplets([1, 5, 7])\n    1",
      "arb": "نظرًا لمصفوفة تحتوي على n من الأعداد الصحيحة المميزة التي تمثل أطوال أصدقاء كيرا، ابحث عن عدد الطرق لاختيار ثلاثي (a, b, c) بحيث يكون القاسم المشترك الأكبر (GCD) للقيمتين العظمى والصغرى في الثلاثي هو 1.\n    >>> countTriplets([1, 5, 7])\n    1",
      "sw": "Kwa kupewa safu ya nambari tofauti za n ambazo zinawakilisha urefu wa marafiki wa Kira, pata idadi ya njia za kuchagua tatu (a, b, c) ambapo mgawanyiko mkuu wa kawaida (GCD) wa thamani ya juu na ya chini ya tatu hiyo ni 1.\n    >>> countTriplets([1, 5, 7])\n    1",
      "tr": "Verilen bir dizi n farklı tam sayıdan oluşan ve Kira'nın arkadaşlarının boylarını temsil eden, maksimum ve minimum değerlerinin en büyük ortak böleni (GCD) 1 olan bir üçlü (a, b, c) seçmenin kaç yolu olduğunu bulun.\n    >>> countTriplets([1, 5, 7])\n    1",
      "vi": "Cho một mảng gồm n số nguyên khác nhau đại diện cho chiều cao của bạn bè Kira, tìm số cách chọn một bộ ba (a, b, c) sao cho ước số chung lớn nhất (GCD) của giá trị lớn nhất và nhỏ nhất của bộ ba là 1.\n    >>> countTriplets([1, 5, 7])\n    1"
    },
    "docstring_bertscore": {
      "es": "1",
      "arb": "0.9730949189976813",
      "sw": "0.9140957369188885",
      "tr": "0.9189528456263346",
      "vi": "1"
    }
  },
  {
    "task_id": "C/45",
    "prompt": {
      "es": "#include <stdio.h>\n#include <assert.h>\n/*\nSe te da una imagen de 1 por n píxeles, donde cada píxel tiene un color representado por un entero. Puedes realizar una operación donde eliges un color y cambias todos los píxeles conectados del mismo color al color elegido. Dos píxeles están conectados si son adyacentes y tienen el mismo color. Encuentra el número mínimo de operaciones requeridas para hacer que todos los píxeles sean del mismo color.\n\nNota: Para cada color, hay como máximo 20 píxeles de ese color.\n\nEjemplos:\n    >>> minOperations(5, (int[]){1, 2, 3, 2, 1})\n    2\n*/\nint minOperations(int n, int* pixels)",
      "arb": "#include <stdio.h>\n#include <assert.h>\n/*\nلديك صورة مكونة من 1 في n بكسل، حيث يتم تمثيل كل بكسل بلون يمثل برقم صحيح. يمكنك تنفيذ عملية حيث تختار لونًا وتغير جميع البكسلات المتصلة من نفس اللون إلى اللون المختار. يعتبر البكسلان متصلان إذا كانا متجاورين ولهما نفس اللون. ابحث عن الحد الأدنى لعدد العمليات المطلوبة لجعل جميع البكسلات بنفس اللون.\n\nملاحظة: لكل لون، هناك بحد أقصى 20 بكسل من ذلك اللون.\n\nأمثلة:\n    >>> minOperations(5, (int[]){1, 2, 3, 2, 1})\n    2\n*/\nint minOperations(int n, int* pixels)",
      "sw": "#include <stdio.h>\n#include <assert.h>\n/*\nUmepewa picha ya pikseli 1 kwa n, ambapo kila pikseli ina rangi inayowakilishwa na nambari. Unaweza kufanya operesheni ambapo unachagua rangi na kubadilisha pikseli zote zilizounganishwa za rangi sawa kuwa rangi iliyochaguliwa. Pikseli mbili zimeunganishwa ikiwa ziko karibu na zina rangi sawa. Pata idadi ndogo ya operesheni zinazohitajika kufanya pikseli zote kuwa na rangi sawa.\n\nKumbuka: Kwa kila rangi, kuna pikseli zisizozidi 20 za rangi hiyo.\n\nMifano:\n    >>> minOperations(5, (int[]){1, 2, 3, 2, 1})\n    2\n*/\nint minOperations(int n, int* pixels)",
      "tr": "#include <stdio.h>\n#include <assert.h>\n/*\n1'e n piksel boyutunda bir görüntü verilir, burada her piksel bir tamsayı ile temsil edilen bir renge sahiptir. Bir renk seçip aynı renkteki tüm bağlı pikselleri seçilen renge değiştirebileceğiniz bir işlem gerçekleştirebilirsiniz. İki piksel, bitişik ve aynı renkte olduklarında bağlı kabul edilir. Tüm pikselleri aynı renge getirmek için gereken minimum işlem sayısını bulun.\n\nNot: Her renk için en fazla 20 piksel vardır.\n\nÖrnekler:\n    >>> minOperations(5, (int[]){1, 2, 3, 2, 1})\n    2\n*/\nint minOperations(int n, int* pixels)",
      "vi": "#include <stdio.h>\n#include <assert.h>\n/*\nBạn được cung cấp một hình ảnh 1 x n pixel, trong đó mỗi pixel có một màu được biểu diễn bằng một số nguyên. Bạn có thể thực hiện một thao tác trong đó bạn chọn một màu và thay đổi tất cả các pixel kết nối có cùng màu thành màu đã chọn. Hai pixel được kết nối nếu chúng liền kề và có cùng màu. Tìm số lượng thao tác tối thiểu cần thiết để làm cho tất cả các pixel có cùng màu.\n\nLưu ý: Đối với mỗi màu, có tối đa 20 pixel của màu đó.\n\nVí dụ:\n    >>> minOperations(5, (int[]){1, 2, 3, 2, 1})\n    2\n*/\nint minOperations(int n, int* pixels)"
    },
    "prompt_bertscore": {
      "es": "0.9987460464045268",
      "arb": "0.9653038409319689",
      "sw": "0.9732540219328902",
      "tr": "0.9668783839624324",
      "vi": "0.9652587518354739"
    },
    "canonical_solution": "{\n    int pre[n+1], u[n+1], f[n+1][n+1];\n    for (int i = 1; i <= n; i++) {\n        pre[i] = u[i] = 0;\n    }\n    for (int i = 1; i <= n; i++) {\n        pre[i] = u[pixels[i-1]];\n        u[pixels[i-1]] = i;\n    }\n    for (int i = 1; i <= n; i++) {\n        for (int j = 1; j <= n; j++) {\n            if (i != j) f[i][j] = 1000000000;\n            else f[i][j] = 0;\n        }\n    }\n    for (int len = 2; len <= n; len++) {\n        for (int i = 1; i <= n - len + 1; i++) {\n            int j = i + len - 1;\n            f[i][j] = f[i][j - 1] + 1;\n            for (int l = pre[j]; l >= i; l = pre[l]) {\n                f[i][j] = f[i][j] < f[i][l] + f[l + 1][j] ? f[i][j] : f[i][l] + f[l + 1][j];\n            }\n        }\n    }\n    return f[1][n];\n}",
    "instruction": {
      "es": "int minOperations(int n, int* pixels)\n{\n    int pre[n+1], u[n+1], f[n+1][n+1];\n    for (int i = 1; i <= n; i++) {\n        pre[i] = u[i] = 0;\n    }\n    for (int i = 1; i <= n; i++) {\n        pre[i] = u[pixels[i-1]];\n        u[pixels[i-1]] = i;\n    }\n    for (int i = 1; i <= n; i++) {\n        for (int j = 1; j <= n; j++) {\n            if (i != j) f[i][j] = 1000000000;\n            else f[i][j] = 0;\n        }\n    }\n    for (int len = 2; len <= n; len++) {\n        for (int i = 1; i <= n - len + 1; i++) {\n            int j = i + len - 1;\n            f[i][j] = f[i][j - 1] + 1;\n            for (int l = pre[j]; l >= i; l = pre[l]) {\n                f[i][j] = f[i][j] < f[i][l] + f[l + 1][j] ? f[i][j] : f[i][l] + f[l + 1][j];\n            }\n        }\n    }\n    return f[1][n];\n}\n\nProporcione una descripción concisa en lenguaje natural (docstring) del código C en español utilizando como máximo 500 caracteres.",
      "arb": "int minOperations(int n, int* pixels)\n{\n    int pre[n+1], u[n+1], f[n+1][n+1];\n    for (int i = 1; i <= n; i++) {\n        pre[i] = u[i] = 0;\n    }\n    for (int i = 1; i <= n; i++) {\n        pre[i] = u[pixels[i-1]];\n        u[pixels[i-1]] = i;\n    }\n    for (int i = 1; i <= n; i++) {\n        for (int j = 1; j <= n; j++) {\n            if (i != j) f[i][j] = 1000000000;\n            else f[i][j] = 0;\n        }\n    }\n    for (int len = 2; len <= n; len++) {\n        for (int i = 1; i <= n - len + 1; i++) {\n            int j = i + len - 1;\n            f[i][j] = f[i][j - 1] + 1;\n            for (int l = pre[j]; l >= i; l = pre[l]) {\n                f[i][j] = f[i][j] < f[i][l] + f[l + 1][j] ? f[i][j] : f[i][l] + f[l + 1][j];\n            }\n        }\n    }\n    return f[1][n];\n}\n\nيرجى تقديم وصف موجز بلغة طبيعية (docstring) للكود المكتوب بلغة C باللغة العربية الفصحى باستخدام ما لا يزيد عن 500 حرف.",
      "sw": "int minOperations(int n, int* pixels)\n{\n    int pre[n+1], u[n+1], f[n+1][n+1];\n    for (int i = 1; i <= n; i++) {\n        pre[i] = u[i] = 0;\n    }\n    for (int i = 1; i <= n; i++) {\n        pre[i] = u[pixels[i-1]];\n        u[pixels[i-1]] = i;\n    }\n    for (int i = 1; i <= n; i++) {\n        for (int j = 1; j <= n; j++) {\n            if (i != j) f[i][j] = 1000000000;\n            else f[i][j] = 0;\n        }\n    }\n    for (int len = 2; len <= n; len++) {\n        for (int i = 1; i <= n - len + 1; i++) {\n            int j = i + len - 1;\n            f[i][j] = f[i][j - 1] + 1;\n            for (int l = pre[j]; l >= i; l = pre[l]) {\n                f[i][j] = f[i][j] < f[i][l] + f[l + 1][j] ? f[i][j] : f[i][l] + f[l + 1][j];\n            }\n        }\n    }\n    return f[1][n];\n}\n\nToa maelezo mafupi ya lugha ya asili (docstring) ya msimbo wa C kwa Kiswahili kwa kutumia herufi zisizozidi 500.",
      "tr": "int minOperations(int n, int* pixels)\n{\n    int pre[n+1], u[n+1], f[n+1][n+1];\n    for (int i = 1; i <= n; i++) {\n        pre[i] = u[i] = 0;\n    }\n    for (int i = 1; i <= n; i++) {\n        pre[i] = u[pixels[i-1]];\n        u[pixels[i-1]] = i;\n    }\n    for (int i = 1; i <= n; i++) {\n        for (int j = 1; j <= n; j++) {\n            if (i != j) f[i][j] = 1000000000;\n            else f[i][j] = 0;\n        }\n    }\n    for (int len = 2; len <= n; len++) {\n        for (int i = 1; i <= n - len + 1; i++) {\n            int j = i + len - 1;\n            f[i][j] = f[i][j - 1] + 1;\n            for (int l = pre[j]; l >= i; l = pre[l]) {\n                f[i][j] = f[i][j] < f[i][l] + f[l + 1][j] ? f[i][j] : f[i][l] + f[l + 1][j];\n            }\n        }\n    }\n    return f[1][n];\n}\n\nC kodunun işlevini açıklayan kısa bir doğal dil açıklaması (docstring) sağlayın. Açıklama, en fazla 500 karakter kullanılarak Türkçe olarak yazılmalıdır.",
      "vi": "int minOperations(int n, int* pixels)\n{\n    int pre[n+1], u[n+1], f[n+1][n+1];\n    for (int i = 1; i <= n; i++) {\n        pre[i] = u[i] = 0;\n    }\n    for (int i = 1; i <= n; i++) {\n        pre[i] = u[pixels[i-1]];\n        u[pixels[i-1]] = i;\n    }\n    for (int i = 1; i <= n; i++) {\n        for (int j = 1; j <= n; j++) {\n            if (i != j) f[i][j] = 1000000000;\n            else f[i][j] = 0;\n        }\n    }\n    for (int len = 2; len <= n; len++) {\n        for (int i = 1; i <= n - len + 1; i++) {\n            int j = i + len - 1;\n            f[i][j] = f[i][j - 1] + 1;\n            for (int l = pre[j]; l >= i; l = pre[l]) {\n                f[i][j] = f[i][j] < f[i][l] + f[l + 1][j] ? f[i][j] : f[i][l] + f[l + 1][j];\n            }\n        }\n    }\n    return f[1][n];\n}\n\nCung cấp mô tả ngắn gọn bằng ngôn ngữ tự nhiên (docstring) cho mã C bằng tiếng Việt, sử dụng tối đa 500 ký tự."
    },
    "instruction_bertscore": {
      "es": "0.9687963589217052",
      "arb": "0.8701598884162574",
      "sw": "0.9146175389298671",
      "tr": "0.8559035900782404",
      "vi": "0.9356658045169911"
    },
    "level": "",
    "test": "int main() {\n    assert(minOperations(5, (int[]){1, 2, 3, 2, 1}) == 2);\n    assert(minOperations(4, (int[]){1, 1, 2, 2}) == 1);\n    assert(minOperations(5, (int[]){1, 2, 1, 4, 2}) == 3);\n    assert(minOperations(5, (int[]){5, 5, 5, 5, 5}) == 0);\n    assert(minOperations(6, (int[]){1, 1, 1, 2, 2, 2}) == 1);\n    assert(minOperations(7, (int[]){1, 3, 3, 3, 2, 2, 2}) == 2);\n    assert(minOperations(8, (int[]){4, 4, 4, 4, 3, 3, 3, 3}) == 1);\n    assert(minOperations(9, (int[]){1, 2, 3, 4, 5, 6, 7, 8, 9}) == 8);\n    assert(minOperations(10, (int[]){1, 2, 1, 2, 1, 2, 1, 2, 1, 2}) == 5);\n    assert(minOperations(3, (int[]){3, 3, 3}) == 0);\n    assert(minOperations(4, (int[]){2, 1, 1, 2}) == 1);\n    return 0;\n}",
    "entry_point": "minOperations",
    "signature": "int minOperations(int n, int* pixels)",
    "docstring": {
      "es": "Se te da una imagen de 1 por n píxeles, donde cada píxel tiene un color representado por un entero. Puedes realizar una operación en la que eliges un color y cambias todos los píxeles conectados del mismo color al color elegido. Dos píxeles están conectados si son adyacentes y tienen el mismo color. Encuentra el número mínimo de operaciones necesarias para hacer que todos los píxeles sean del mismo color.\n\nNota: Para cada color, hay como máximo 20 píxeles de ese color.\n\nEjemplos:\n    >>> minOperations(5, (int[]){1, 2, 3, 2, 1})\n    2",
      "arb": "أنت لديك صورة مكونة من 1 في n بكسل، حيث كل بكسل له لون ممثل بعدد صحيح. يمكنك تنفيذ عملية حيث تختار لونًا وتغير جميع البكسلات المتصلة من نفس اللون إلى اللون المختار. يُعتبر البكسلان متصلين إذا كانا متجاورين ولهما نفس اللون. اعثر على الحد الأدنى لعدد العمليات المطلوبة لجعل جميع البكسلات بنفس اللون.\n\nملاحظة: لكل لون، هناك بحد أقصى 20 بكسل من ذلك اللون.\n\nأمثلة:\n    >>> minOperations(5, (int[]){1, 2, 3, 2, 1})\n    2",
      "sw": "Unapewa picha ya pikseli 1 kwa n, ambapo kila pikseli ina rangi inayowakilishwa na nambari kamili. Unaweza kufanya operesheni ambapo unachagua rangi na kubadilisha pikseli zote zilizounganishwa za rangi sawa kuwa rangi iliyochaguliwa. Pikseli mbili zimeunganishwa ikiwa ziko karibu na zina rangi sawa. Tafuta idadi ndogo ya operesheni zinazohitajika kufanya pikseli zote ziwe na rangi sawa.\n\nKumbuka: Kwa kila rangi, kuna pikseli zisizozidi 20 za rangi hiyo.\n\nMifano:\n    >>> minOperations(5, (int[]){1, 2, 3, 2, 1})\n    2",
      "tr": "1'e n piksel boyutunda bir görüntü veriliyor ve her piksel bir tamsayı ile temsil edilen bir renge sahip. Bir renk seçip aynı renkteki tüm bağlı pikselleri seçilen renge değiştirebileceğiniz bir işlem gerçekleştirebilirsiniz. İki piksel, bitişik ve aynı renkte ise bağlı kabul edilir. Tüm pikselleri aynı renkte yapmak için gereken minimum işlem sayısını bulun.\n\nNot: Her renk için en fazla 20 piksel vardır.\n\nÖrnekler:\n    >>> minOperations(5, (int[]){1, 2, 3, 2, 1})\n    2",
      "vi": "Bạn được cung cấp một hình ảnh 1 x n pixel, trong đó mỗi pixel có một màu được biểu diễn bằng một số nguyên. Bạn có thể thực hiện một thao tác trong đó bạn chọn một màu và thay đổi tất cả các pixel kết nối có cùng màu thành màu đã chọn. Hai pixel được kết nối nếu chúng liền kề và có cùng màu. Tìm số lượng thao tác tối thiểu cần thiết để làm cho tất cả các pixel có cùng màu.\n\nLưu ý: Đối với mỗi màu, có tối đa 20 pixel của màu đó.\n\nVí dụ:\n    >>> minOperations(5, (int[]){1, 2, 3, 2, 1})\n    2\n"
    },
    "docstring_bertscore": {
      "es": "0.988795061575441",
      "arb": "0.9699941001193456",
      "sw": "0.9802185989831165",
      "tr": "0.9663641299059331",
      "vi": "0.9877687383966337"
    }
  },
  {
    "task_id": "C/46",
    "prompt": {
      "es": "#include <assert.h>\n#include <stdio.h>\n/*\nDado un entero n, escribe una función para calcular la suma de todos los números desde 1 hasta n que son múltiplos de 3 o 5. Si un número es múltiplo de ambos, 3 y 5, debe contarse solo una vez.\nPor ejemplo:\n    >>> sumOfMultiples(10)\n    33 // (3 + 5 + 6 + 9 + 10)\n*/\nint sumOfMultiples(int n)",
      "arb": "#include <assert.h>\n#include <stdio.h>\n/*\nمُعطى عدد صحيح n، اكتب دالة لحساب مجموع جميع الأرقام من 1 إلى n التي هي مضاعفات لـ 3 أو 5. إذا كان الرقم مضاعفًا لكل من 3 و 5، يجب أن يُحسب مرة واحدة فقط.\nعلى سبيل المثال:\n    >>> sumOfMultiples(10)\n    33 // (3 + 5 + 6 + 9 + 10)\n*/\nint sumOfMultiples(int n)",
      "sw": "#include <assert.h>\n#include <stdio.h>\n/*\nUkipiwa nambari nzima n, andika kazi ya kuhesabu jumla ya nambari zote kutoka 1 hadi n ambazo ni maradufu ya 3 au 5. Ikiwa nambari ni maradufu ya 3 na 5, inapaswa kuhesabiwa mara moja tu.\nKwa mfano:\n    >>> sumOfMultiples(10)\n    33 // (3 + 5 + 6 + 9 + 10)\n*/\nint sumOfMultiples(int n)",
      "tr": "#include <assert.h>\n#include <stdio.h>\n/*\nVerilen bir tamsayı n için, 1'den n'ye kadar olan ve 3 veya 5'in katı olan tüm sayıların toplamını hesaplayan bir fonksiyon yazın. Bir sayı hem 3 hem de 5'in katıysa, yalnızca bir kez sayılmalıdır.\nÖrneğin:\n    >>> sumOfMultiples(10)\n    33 // (3 + 5 + 6 + 9 + 10)\n*/\nint sumOfMultiples(int n)",
      "vi": "#include <assert.h>\n#include <stdio.h>\n/*\nCho một số nguyên n, viết một hàm để tính tổng của tất cả các số từ 1 đến n mà là bội số của 3 hoặc 5. Nếu một số là bội số của cả 3 và 5, nó chỉ nên được tính một lần.\nVí dụ:\n    >>> sumOfMultiples(10)\n    33 // (3 + 5 + 6 + 9 + 10)\n*/\nint sumOfMultiples(int n)"
    },
    "prompt_bertscore": {
      "es": "0.9920259833533545",
      "arb": "0.9920259833533545",
      "sw": "0.9920259833533545",
      "tr": "0.96602188975941",
      "vi": "0.9883465541750641"
    },
    "canonical_solution": "{\n    int sum = 0;\n    for (int i = 1; i <= n; ++i)\n    {\n        if (i % 3 == 0 || i % 5 == 0)\n        {\n            sum += i;\n        }\n    }\n    return sum;\n}",
    "instruction": {
      "es": "int sumOfMultiples(int n)\n{\n    int sum = 0;\n    for (int i = 1; i <= n; ++i)\n    {\n        if (i % 3 == 0 || i % 5 == 0)\n        {\n            sum += i;\n        }\n    }\n    return sum;\n}\n\nProporcione una descripción concisa en lenguaje natural (docstring) del código C en español utilizando un máximo de 500 caracteres.",
      "arb": "int sumOfMultiples(int n)\n{\n    int sum = 0;\n    for (int i = 1; i <= n; ++i)\n    {\n        if (i % 3 == 0 || i % 5 == 0)\n        {\n            sum += i;\n        }\n    }\n    return sum;\n}\n\nيرجى تقديم وصف موجز بلغة طبيعية (docstring) للكود المكتوب بلغة C باللغة العربية الفصحى، بحيث لا يتجاوز 500 حرف.",
      "sw": "int sumOfMultiples(int n)\n{\n    int sum = 0;\n    for (int i = 1; i <= n; ++i)\n    {\n        if (i % 3 == 0 || i % 5 == 0)\n        {\n            sum += i;\n        }\n    }\n    return sum;\n}\n\nToa maelezo mafupi ya lugha ya asili (docstring) ya msimbo wa C kwa Kiswahili kwa kutumia herufi zisizozidi 500.",
      "tr": "int sumOfMultiples(int n)\n{\n    int sum = 0;\n    for (int i = 1; i <= n; ++i)\n    {\n        if (i % 3 == 0 || i % 5 == 0)\n        {\n            sum += i;\n        }\n    }\n    return sum;\n}\n\nC kodunun işlevini açıklayan kısa bir doğal dil açıklaması (docstring) sağlayın. Açıklama Türkçe olmalı ve en fazla 500 karakter kullanılmalıdır.",
      "vi": "int sumOfMultiples(int n)\n{\n    int sum = 0;\n    for (int i = 1; i <= n; ++i)\n    {\n        if (i % 3 == 0 || i % 5 == 0)\n        {\n            sum += i;\n        }\n    }\n    return sum;\n}\n\nCung cấp mô tả ngắn gọn bằng ngôn ngữ tự nhiên (docstring) của mã C bằng tiếng Việt, sử dụng tối đa 500 ký tự."
    },
    "instruction_bertscore": {
      "es": "0.9687963589217052",
      "arb": "0.8727085148353161",
      "sw": "0.9146175389298671",
      "tr": "0.853504730966482",
      "vi": "0.946887229263176"
    },
    "level": "",
    "test": "int main()\n{\n    assert(sumOfMultiples(10) == 33);\n    assert(sumOfMultiples(15) == 60);\n    assert(sumOfMultiples(20) == 98);\n    assert(sumOfMultiples(5) == 8);\n    assert(sumOfMultiples(3) == 3);\n    assert(sumOfMultiples(6) == 14);\n    assert(sumOfMultiples(9) == 23);\n    assert(sumOfMultiples(12) == 45);\n    assert(sumOfMultiples(17) == 60);\n    assert(sumOfMultiples(21) == 119);\n    assert(sumOfMultiples(25) == 168);\n    return 0;\n}",
    "entry_point": "sumOfMultiples",
    "signature": "int sumOfMultiples(int n)",
    "docstring": {
      "es": "Dado un entero n, escribe una función para calcular la suma de todos los números desde 1 hasta n que son múltiplos de 3 o 5. Si un número es múltiplo de ambos 3 y 5, solo debe contarse una vez.\nPor ejemplo:\n    >>> sumOfMultiples(10)\n    33 // (3 + 5 + 6 + 9 + 10)",
      "arb": "بالنظر إلى عدد صحيح n، اكتب دالة لحساب مجموع جميع الأرقام من 1 إلى n التي هي مضاعفات لـ 3 أو 5. إذا كان الرقم مضاعفًا لكل من 3 و 5، فيجب احتسابه مرة واحدة فقط.\nعلى سبيل المثال:\n    >>> sumOfMultiples(10)\n    33 // (3 + 5 + 6 + 9 + 10)",
      "sw": "Ikizingatiwa nambari nzima n, andika kazi ya kuhesabu jumla ya nambari zote kutoka 1 hadi n ambazo ni maradufu ya 3 au 5. Ikiwa nambari ni maradufu ya 3 na 5, inapaswa kuhesabiwa mara moja tu.\nKwa mfano:\n    >>> sumOfMultiples(10)\n    33 // (3 + 5 + 6 + 9 + 10)",
      "tr": "Verilen bir tam sayı n için, 1'den n'e kadar olan ve 3 veya 5'in katı olan tüm sayıların toplamını hesaplayan bir fonksiyon yazın. Bir sayı hem 3 hem de 5'in katıysa, yalnızca bir kez sayılmalıdır.\nÖrneğin:\n    >>> sumOfMultiples(10)\n    33 // (3 + 5 + 6 + 9 + 10)",
      "vi": "Cho một số nguyên n, viết một hàm để tính tổng của tất cả các số từ 1 đến n mà là bội số của 3 hoặc 5. Nếu một số là bội số của cả 3 và 5, nó chỉ nên được tính một lần.\nVí dụ:\n    >>> sumOfMultiples(10)\n    33 // (3 + 5 + 6 + 9 + 10)"
    },
    "docstring_bertscore": {
      "es": "0.9908419476520054",
      "arb": "0.9900521932570108",
      "sw": "0.9900521932570108",
      "tr": "0.9769298757643219",
      "vi": "0.9860144348713336"
    }
  },
  {
    "task_id": "C/47",
    "prompt": {
      "es": "#include <assert.h>\n#include <ctype.h>\n#include <stdbool.h>\n#include <stdio.h>\n#include <string.h>\n/*\nDeterminar si una cadena dada es un palíndromo. Un palíndromo es una palabra, frase, número u otra secuencia de caracteres que se lee igual de adelante hacia atrás (ignorando espacios, puntuación y mayúsculas).\n    >>> isPalindrome(\"racecar\")\n    true\n    >>> isPalindrome(\"hello\")\n    false\n*/\nbool isPalindrome(const char* str);",
      "arb": "#include <assert.h>\n#include <ctype.h>\n#include <stdbool.h>\n#include <stdio.h>\n#include <string.h>\n/*\nتحديد ما إذا كانت سلسلة معينة هي جملة مقلوبة. الجملة المقلوبة هي كلمة أو عبارة أو رقم أو تسلسل آخر من الأحرف التي تُقرأ بنفس الطريقة من الأمام إلى الخلف (مع تجاهل المسافات وعلامات الترقيم والحروف الكبيرة).\n    >>> isPalindrome(\"racecar\")\n    true\n    >>> isPalindrome(\"hello\")\n    false\n*/\nbool isPalindrome(const char* str);",
      "sw": "#include <assert.h>\n#include <ctype.h>\n#include <stdbool.h>\n#include <stdio.h>\n#include <string.h>\n/*\nTambua kama kamba iliyotolewa ni palindrome. Palindrome ni neno, kifungu, namba, au mlolongo mwingine wa herufi ambao unasomwa sawa mbele na nyuma (kupuuza nafasi, alama za uakifishaji, na herufi kubwa).\n    >>> isPalindrome(\"racecar\")\n    true\n    >>> isPalindrome(\"hello\")\n    false\n*/\nbool isPalindrome(const char* str);",
      "tr": "#include <assert.h>\n#include <ctype.h>\n#include <stdbool.h>\n#include <stdio.h>\n#include <string.h>\n/*\nVerilen bir dizgenin palindrom olup olmadığını belirleyin. Palindrom, ileri ve geri okunduğunda aynı olan (boşluklar, noktalama işaretleri ve büyük/küçük harf farkı göz ardı edilerek) bir kelime, ifade, sayı veya diğer karakter dizisidir.\n    >>> isPalindrome(\"racecar\")\n    true\n    >>> isPalindrome(\"hello\")\n    false\n*/\nbool isPalindrome(const char* str);",
      "vi": "#include <assert.h>\n#include <ctype.h>\n#include <stdbool.h>\n#include <stdio.h>\n#include <string.h>\n/*\nXác định xem một chuỗi cho trước có phải là palindrome hay không. Palindrome là một từ, cụm từ, số, hoặc một chuỗi ký tự khác mà khi đọc xuôi hay ngược đều giống nhau (bỏ qua khoảng trắng, dấu câu và chữ hoa chữ thường).\n    >>> isPalindrome(\"racecar\")\n    true\n    >>> isPalindrome(\"hello\")\n    false\n*/\nbool isPalindrome(const char* str);"
    },
    "prompt_bertscore": {
      "es": "1",
      "arb": "0.9992019031290018",
      "sw": "0.9981245319422686",
      "tr": "0.9886729038911045",
      "vi": "0.9914747840459825"
    },
    "canonical_solution": "bool isPalindrome(const char* str)\n{\n    int start = 0;\n    int end = strlen(str) - 1;\n    \n    while (start < end) {\n        // Skip non-alphanumeric characters and handle case insensitivity\n        while (!isalnum(str[start]) && start < end) start++;\n        while (!isalnum(str[end]) && start < end) end--;\n        if (tolower(str[start]) != tolower(str[end]))\n            return false;\n        start++;\n        end--;\n    }\n    return true;\n}",
    "instruction": {
      "es": "bool isPalindrome(const char* str)\nbool isPalindrome(const char* str)\n{\n    int start = 0;\n    int end = strlen(str) - 1;\n    \n    while (start < end) {\n        // Skip non-alphanumeric characters and handle case insensitivity\n        while (!isalnum(str[start]) && start < end) start++;\n        while (!isalnum(str[end]) && start < end) end--;\n        if (tolower(str[start]) != tolower(str[end]))\n            return false;\n        start++;\n        end--;\n    }\n    return true;\n}\n\nProporcione una descripción concisa en lenguaje natural (docstring) del código C en español utilizando como máximo 500 caracteres.",
      "arb": "bool isPalindrome(const char* str)\nbool isPalindrome(const char* str)\n{\n    int start = 0;\n    int end = strlen(str) - 1;\n    \n    while (start < end) {\n        // Skip non-alphanumeric characters and handle case insensitivity\n        while (!isalnum(str[start]) && start < end) start++;\n        while (!isalnum(str[end]) && start < end) end--;\n        if (tolower(str[start]) != tolower(str[end]))\n            return false;\n        start++;\n        end--;\n    }\n    return true;\n}\n\nيرجى تقديم وصف موجز بلغة طبيعية (docstring) للكود المكتوب بلغة C باللغة العربية الفصحى باستخدام 500 حرف كحد أقصى.",
      "sw": "bool isPalindrome(const char* str)\nbool isPalindrome(const char* str)\n{\n    int start = 0;\n    int end = strlen(str) - 1;\n    \n    while (start < end) {\n        // Skip non-alphanumeric characters and handle case insensitivity\n        while (!isalnum(str[start]) && start < end) start++;\n        while (!isalnum(str[end]) && start < end) end--;\n        if (tolower(str[start]) != tolower(str[end]))\n            return false;\n        start++;\n        end--;\n    }\n    return true;\n}\n\nToa maelezo mafupi ya lugha asilia (docstring) ya msimbo wa C kwa Kiswahili kwa kutumia herufi zisizozidi 500.",
      "tr": "bool isPalindrome(const char* str)\nbool isPalindrome(const char* str)\n{\n    int start = 0;\n    int end = strlen(str) - 1;\n    \n    while (start < end) {\n        // Skip non-alphanumeric characters and handle case insensitivity\n        while (!isalnum(str[start]) && start < end) start++;\n        while (!isalnum(str[end]) && start < end) end--;\n        if (tolower(str[start]) != tolower(str[end]))\n            return false;\n        start++;\n        end--;\n    }\n    return true;\n}\n\nC kodunun işlevini açıklayan kısa bir doğal dil tanımı (docstring) sağlayın. Açıklama, Türkçe olarak en fazla 500 karakter kullanılacak şekilde olmalıdır.",
      "vi": "bool isPalindrome(const char* str)\nbool isPalindrome(const char* str)\n{\n    int start = 0;\n    int end = strlen(str) - 1;\n    \n    while (start < end) {\n        // Skip non-alphanumeric characters and handle case insensitivity\n        while (!isalnum(str[start]) && start < end) start++;\n        while (!isalnum(str[end]) && start < end) end--;\n        if (tolower(str[start]) != tolower(str[end]))\n            return false;\n        start++;\n        end--;\n    }\n    return true;\n}\n\nCung cấp mô tả ngắn gọn bằng ngôn ngữ tự nhiên (docstring) của mã C bằng tiếng Việt với tối đa 500 ký tự."
    },
    "instruction_bertscore": {
      "es": "0.9687963589217052",
      "arb": "0.8812990801846939",
      "sw": "0.9423429634058599",
      "tr": "0.8628683657588477",
      "vi": "0.9439043968311751"
    },
    "level": "",
    "test": "int main()\n{\n    assert(isPalindrome(\"A man a plan a canal Panama\") == true);\n    assert(isPalindrome(\"No lemon, no melon\") == true);\n    assert(isPalindrome(\"Was it a car or a cat I saw\") == true);\n    assert(isPalindrome(\"Madam, in Eden, I'm Adam\") == true);\n    assert(isPalindrome(\"Never odd or even\") == true);\n    assert(isPalindrome(\"Eva, can I see bees in a cave\") == true);\n    assert(isPalindrome(\"hello\") == false);\n    assert(isPalindrome(\"GitHub\") == false);\n    assert(isPalindrome(\"programming\") == false);\n    \n    return 0;\n}",
    "entry_point": "isPalindrome",
    "signature": "bool isPalindrome(const char* str)",
    "docstring": {
      "es": "Determinar si una cadena dada es un palíndromo. Un palíndromo es una palabra, frase, número u otra secuencia de caracteres que se lee igual de adelante hacia atrás (ignorando espacios, puntuación y capitalización).\n    >>> isPalindrome(\"racecar\")\n    true\n    >>> isPalindrome(\"hello\")\n    false",
      "arb": "تحديد ما إذا كانت سلسلة معينة هي كلمة متطابقة عند قراءتها من الأمام والخلف. الكلمة المتطابقة هي كلمة، أو عبارة، أو رقم، أو تسلسل آخر من الأحرف التي تُقرأ بنفس الطريقة سواء من الأمام أو الخلف (مع تجاهل المسافات، وعلامات الترقيم، والحروف الكبيرة والصغيرة).\n    >>> isPalindrome(\"racecar\")\n    true\n    >>> isPalindrome(\"hello\")\n    false",
      "sw": "Amua ikiwa kamba iliyotolewa ni palindrome. Palindrome ni neno, kifungu, nambari, au mlolongo mwingine wa herufi ambao unasomwa sawa mbele na nyuma (kupuuza nafasi, alama za uakifishaji, na herufi kubwa na ndogo).\n    >>> isPalindrome(\"racecar\")\n    true\n    >>> isPalindrome(\"hello\")\n    false",
      "tr": "Verilen bir dizgenin palindrom olup olmadığını belirleyin. Palindrom, ileri ve geri okunduğunda aynı olan (boşluklar, noktalama işaretleri ve büyük/küçük harf farkı göz ardı edilerek) bir kelime, ifade, sayı veya diğer karakter dizisidir.\n    >>> isPalindrome(\"racecar\")\n    true\n    >>> isPalindrome(\"hello\")\n    false",
      "vi": "Xác định xem một chuỗi cho trước có phải là một chuỗi palindrome hay không. Một chuỗi palindrome là một từ, cụm từ, số, hoặc một dãy ký tự khác mà đọc xuôi hay ngược đều giống nhau (bỏ qua khoảng trắng, dấu câu, và phân biệt chữ hoa chữ thường).\n    >>> isPalindrome(\"racecar\")\n    true\n    >>> isPalindrome(\"hello\")\n    false"
    },
    "docstring_bertscore": {
      "es": "1",
      "arb": "0.9518458380953311",
      "sw": "0.9951458707482694",
      "tr": "0.9798765574669744",
      "vi": "0.9827060472448165"
    }
  },
  {
    "task_id": "C/48",
    "prompt": {
      "es": "#include <assert.h>\n#include <stdio.h>\n/*\nDado un número entero no negativo num, suma repetidamente todos sus dígitos hasta que el resultado tenga solo un dígito.\nPor ejemplo:\n    >>> addDigits(38)\n    2\n    Porque 3 + 8 = 11, y 1 + 1 = 2. Dado que 2 tiene solo un dígito, 2 es el resultado.\n*/\nint addDigits(int num)",
      "arb": "#include <assert.h>\n#include <stdio.h>\n/*\nمعطى عدد صحيح غير سالب num، اجمع جميع أرقامه بشكل متكرر حتى يكون الناتج رقمًا واحدًا فقط.\nعلى سبيل المثال:\n    >>> addDigits(38)\n    2\n    لأن 3 + 8 = 11، و 1 + 1 = 2. بما أن 2 هو رقم واحد فقط، فإن 2 هو الناتج.\n*/\nint addDigits(int num)",
      "sw": "#include <assert.h>\n#include <stdio.h>\n/*\nUkipewa nambari isiyo hasi num, ongeza mara kwa mara tarakimu zake zote hadi matokeo yawe na tarakimu moja tu.\nKwa mfano:\n    >>> addDigits(38)\n    2\n    Kwa sababu 3 + 8 = 11, na 1 + 1 = 2. Kwa kuwa 2 ina tarakimu moja tu, 2 ndiyo matokeo.\n*/\nint addDigits(int num)",
      "tr": "#include <assert.h>\n#include <stdio.h>\n/*\nVerilen negatif olmayan bir tamsayı num için, sonucu tek bir basamak kalana kadar tüm basamaklarını tekrar tekrar toplayın.\nÖrneğin:\n    >>> addDigits(38)\n    2\n    Çünkü 3 + 8 = 11 ve 1 + 1 = 2. 2 yalnızca bir basamak içerdiğinden, sonuç 2'dir.\n*/\nint addDigits(int num)",
      "vi": "#include <assert.h>\n#include <stdio.h>\n/*\nCho một số nguyên không âm num, liên tục cộng tất cả các chữ số của nó cho đến khi kết quả chỉ còn một chữ số.\nVí dụ:\n    >>> addDigits(38)\n    2\n    Bởi vì 3 + 8 = 11, và 1 + 1 = 2. Vì 2 chỉ có một chữ số, 2 là kết quả.\n*/\nint addDigits(int num)"
    },
    "prompt_bertscore": {
      "es": "0.9925549360580503",
      "arb": "0.9748645170623211",
      "sw": "0.993617409966206",
      "tr": "0.9759172580818061",
      "vi": "0.9672412816685831"
    },
    "canonical_solution": "{\n    while (num >= 10) {\n        int sum = 0;\n        while (num > 0) {\n            sum += num % 10;\n            num /= 10;\n        }\n        num = sum;\n    }\n    return num;\n}",
    "instruction": {
      "es": "int addDigits(int num)\n{\n    while (num >= 10) {\n        int sum = 0;\n        while (num > 0) {\n            sum += num % 10;\n            num /= 10;\n        }\n        num = sum;\n    }\n    return num;\n}\n\nProporcione una descripción concisa en lenguaje natural (docstring) del código C en español utilizando como máximo 500 caracteres.",
      "arb": "int addDigits(int num)\n{\n    while (num >= 10) {\n        int sum = 0;\n        while (num > 0) {\n            sum += num % 10;\n            num /= 10;\n        }\n        num = sum;\n    }\n    return num;\n}\n\nيرجى تقديم وصف موجز بلغة طبيعية (docstring) للشيفرة البرمجية المكتوبة بلغة C باللغة العربية الفصحى، بحيث لا يتجاوز 500 حرف.",
      "sw": "int addDigits(int num)\n{\n    while (num >= 10) {\n        int sum = 0;\n        while (num > 0) {\n            sum += num % 10;\n            num /= 10;\n        }\n        num = sum;\n    }\n    return num;\n}\n\nToa maelezo mafupi ya lugha ya asili (docstring) ya msimbo wa C kwa Kiswahili kwa kutumia herufi zisizozidi 500.",
      "tr": "int addDigits(int num)\n{\n    while (num >= 10) {\n        int sum = 0;\n        while (num > 0) {\n            sum += num % 10;\n            num /= 10;\n        }\n        num = sum;\n    }\n    return num;\n}\n\nC kodunun işlevini açıklayan kısa bir doğal dil açıklaması (docstring) sağlayın. Açıklama en fazla 500 karakter olmalıdır.",
      "vi": "int addDigits(int num)\n{\n    while (num >= 10) {\n        int sum = 0;\n        while (num > 0) {\n            sum += num % 10;\n            num /= 10;\n        }\n        num = sum;\n    }\n    return num;\n}\n\nCung cấp mô tả ngắn gọn bằng ngôn ngữ tự nhiên (docstring) của mã C bằng tiếng Việt với tối đa 500 ký tự."
    },
    "instruction_bertscore": {
      "es": "0.9687963589217052",
      "arb": "0.8800316197233103",
      "sw": "0.9146175389298671",
      "tr": "0.8359883121845394",
      "vi": "0.9439043968311751"
    },
    "level": "",
    "test": "int main() {\n    assert(addDigits(38) == 2);\n    assert(addDigits(0) == 0);\n    assert(addDigits(9) == 9);\n    assert(addDigits(123) == 6);\n    assert(addDigits(456) == 6);\n    assert(addDigits(9999) == 9);\n    assert(addDigits(100) == 1);\n    assert(addDigits(1010) == 2);\n    assert(addDigits(1234) == 1);\n    assert(addDigits(9876) == 3);\n    assert(addDigits(199) == 1);\n    return 0;\n}",
    "entry_point": "addDigits",
    "signature": "int addDigits(int num)",
    "docstring": {
      "es": "Dado un número entero no negativo num, suma repetidamente todos sus dígitos hasta que el resultado tenga solo un dígito.\nPor ejemplo:\n    >>> addDigits(38)\n    2\n    Porque 3 + 8 = 11, y 1 + 1 = 2. Dado que 2 tiene solo un dígito, 2 es el resultado.",
      "arb": "إعطاء عدد صحيح غير سالب num، قم بإضافة جميع أرقامه بشكل متكرر حتى يكون الناتج رقماً واحداً فقط.\nعلى سبيل المثال:\n    >>> addDigits(38)\n    2\n    لأن 3 + 8 = 11، و 1 + 1 = 2. بما أن 2 هو رقم واحد فقط، فإن 2 هو الناتج.",
      "sw": "Ukipiwa nambari isiyo hasi num, ongeza mara kwa mara tarakimu zake zote hadi matokeo yawe na tarakimu moja tu. Kwa mfano:\n    >>> addDigits(38)\n    2\n    Kwa sababu 3 + 8 = 11, na 1 + 1 = 2. Kwa kuwa 2 ina tarakimu moja tu, 2 ndiyo matokeo.",
      "tr": "Verilen bir negatif olmayan tam sayı num için, sonucu yalnızca bir basamak kalana kadar tüm basamaklarını tekrar tekrar toplayın.  \nÖrneğin:  \n    >>> addDigits(38)  \n    2  \n    Çünkü 3 + 8 = 11 ve 1 + 1 = 2. 2 yalnızca bir basamak olduğundan, sonuç 2'dir.",
      "vi": "Cho một số nguyên không âm num, liên tục cộng tất cả các chữ số của nó cho đến khi kết quả chỉ còn một chữ số.  \nVí dụ:  \n    >>> addDigits(38)  \n    2  \n    Bởi vì 3 + 8 = 11, và 1 + 1 = 2. Vì 2 chỉ có một chữ số, 2 là kết quả."
    },
    "docstring_bertscore": {
      "es": "0.9893973088907387",
      "arb": "0.9629500709167054",
      "sw": "0.9907863311453157",
      "tr": "0.9815402855385227",
      "vi": "0.9746295373215569"
    }
  },
  {
    "task_id": "C/49",
    "prompt": {
      "es": "#include <assert.h>\n#include <stdbool.h>\n#include <stdio.h>\n/*\nEstás jugando un juego llamado Nim. En este juego, comienzas con una pila de n piedras, y tú y tu oponente se turnan para quitar de 1 a 3 piedras de la pila. Quien quite la última piedra gana el juego. Dado el número de piedras n, determina si puedes ganar el juego si tanto tú como tu oponente juegan de manera óptima.\nNota: Siempre tomas el primer turno.\n\nAquí hay algunos casos:\n    >>> canWinNim(1)\n    true\n*/\nbool canWinNim(int n);",
      "arb": "#include <assert.h>\n#include <stdbool.h>\n#include <stdio.h>\n/*\nأنت تلعب لعبة تسمى نيم. في هذه اللعبة، تبدأ بكومة من n من الحجارة، وأنت وخصمك تتناوبان على إزالة 1 إلى 3 حجارة من الكومة. الشخص الذي يزيل الحجر الأخير يفوز باللعبة. بالنظر إلى عدد الحجارة n، حدد ما إذا كان بإمكانك الفوز باللعبة إذا لعبت أنت وخصمك بشكل مثالي.\nملاحظة: أنت دائمًا تأخذ الدور الأول.\n\nإليك بعض الحالات:\n    >>> canWinNim(1)\n    true\n*/\nbool canWinNim(int n);",
      "sw": "#include <assert.h>\n#include <stdbool.h>\n#include <stdio.h>\n/*\nUnacheza mchezo unaoitwa Nim. Katika mchezo huu, unaanza na rundo la mawe n, na wewe na mpinzani wako mnapokezana kuondoa mawe 1 hadi 3 kutoka kwenye rundo. Yule anayeondoa jiwe la mwisho anashinda mchezo. Ukipewa idadi ya mawe n, amua kama unaweza kushinda mchezo ikiwa wewe na mpinzani wako mnaweza kucheza kwa ustadi.\nKumbuka: Daima unachukua zamu ya kwanza.\n\nHapa kuna baadhi ya kesi:\n    >>> canWinNim(1)\n    true\n*/\nbool canWinNim(int n);",
      "tr": "#include <assert.h>\n#include <stdbool.h>\n#include <stdio.h>\n/*\nNim adında bir oyun oynuyorsunuz. Bu oyunda, n taşlık bir yığınla başlarsınız ve siz ve rakibiniz sırayla yığından 1 ila 3 taş çıkarırsınız. Son taşı çıkaran oyunu kazanır. Taş sayısı n verildiğinde, hem siz hem de rakibiniz optimal oynarsa oyunu kazanıp kazanamayacağınızı belirleyin.\nNot: Her zaman ilk hamleyi siz yaparsınız.\n\nİşte bazı durumlar:\n    >>> canWinNim(1)\n    true\n*/\nbool canWinNim(int n);",
      "vi": "#include <assert.h>\n#include <stdbool.h>\n#include <stdio.h>\n/*\nBạn đang chơi một trò chơi gọi là Nim. Trong trò chơi này, bạn bắt đầu với một đống n viên đá, và bạn cùng đối thủ lần lượt lấy từ 1 đến 3 viên đá ra khỏi đống. Người lấy viên đá cuối cùng sẽ thắng trò chơi. Cho số viên đá n, xác định xem bạn có thể thắng trò chơi nếu cả bạn và đối thủ đều chơi tối ưu hay không.\nLưu ý: Bạn luôn là người đi trước.\n\nDưới đây là một số trường hợp:\n    >>> canWinNim(1)\n    true\n*/\nbool canWinNim(int n);"
    },
    "prompt_bertscore": {
      "es": "0.99082744763419",
      "arb": "0.9860881267426974",
      "sw": "0.9889897193488552",
      "tr": "0.9856590851196622",
      "vi": "0.9825421771804627"
    },
    "canonical_solution": "bool canWinNim(int n) {\n    return n % 4 != 0;\n}",
    "instruction": {
      "es": "bool canWinNim(int n)\nbool canWinNim(int n) {\n    return n % 4 != 0;\n}\n\nProporcione una descripción concisa en lenguaje natural (docstring) del código C en español utilizando como máximo 500 caracteres.",
      "arb": "bool canWinNim(int n)\nbool canWinNim(int n) {\n    return n % 4 != 0;\n}\n\nيرجى تقديم وصف موجز بلغة طبيعية (docstring) للكود المكتوب بلغة C باللغة العربية الفصحى، بحيث لا يتجاوز 500 حرف.",
      "sw": "bool canWinNim(int n)\nbool canWinNim(int n) {\n    return n % 4 != 0;\n}\n\nToa maelezo mafupi ya lugha ya asili (docstring) ya msimbo wa C kwa Kiswahili kwa kutumia herufi zisizozidi 500.",
      "tr": "bool canWinNim(int n)\nbool canWinNim(int n) {\n    return n % 4 != 0;\n}\n\nC kodunun işlevselliğini açıklayan kısa bir doğal dil tanımı (docstring) sağlayın. Açıklama 500 karakteri geçmemelidir.",
      "vi": "bool canWinNim(int n)\nbool canWinNim(int n) {\n    return n % 4 != 0;\n}\n\nCung cấp mô tả ngắn gọn bằng ngôn ngữ tự nhiên (docstring) của mã C bằng tiếng Việt, sử dụng tối đa 500 ký tự."
    },
    "instruction_bertscore": {
      "es": "0.9687963589217052",
      "arb": "0.8727085148353161",
      "sw": "0.9146175389298671",
      "tr": "0.8381992669558387",
      "vi": "0.946887229263176"
    },
    "level": "",
    "test": "int main() {\n    assert(canWinNim(1) == true);\n    assert(canWinNim(2) == true);\n    assert(canWinNim(3) == true);\n    assert(canWinNim(4) == false);\n    assert(canWinNim(5) == true);\n    assert(canWinNim(6) == true);\n    assert(canWinNim(7) == true);\n    assert(canWinNim(8) == false);\n    assert(canWinNim(9) == true);\n    assert(canWinNim(10) == true);\n    assert(canWinNim(11) == true);\n    assert(canWinNim(12) == false);\n    assert(canWinNim(13) == true);\n    assert(canWinNim(14) == true);\n    assert(canWinNim(15) == true);\n    assert(canWinNim(16) == false);\n    assert(canWinNim(17) == true);\n    assert(canWinNim(18) == true);\n    assert(canWinNim(19) == true);\n    assert(canWinNim(20) == false);\n    return 0;\n}",
    "entry_point": "canWinNim",
    "signature": "bool canWinNim(int n)",
    "docstring": {
      "es": "Estás jugando un juego llamado Nim. En este juego, comienzas con un montón de n piedras, y tú y tu oponente se turnan para quitar de 1 a 3 piedras del montón. El que quite la última piedra gana el juego. Dado el número de piedras n, determina si puedes ganar el juego si tanto tú como tu oponente juegan de manera óptima.  \nNota: Siempre tomas el primer turno.\n\nAquí hay algunos casos:\n    >>> canWinNim(1)\n    true",
      "arb": "أنت تلعب لعبة تسمى نيم. في هذه اللعبة، تبدأ بكومة من n من الحجارة، وأنت وخصمك تتناوبان على إزالة 1 إلى 3 حجارة من الكومة. الشخص الذي يزيل الحجر الأخير يفوز باللعبة. بالنظر إلى عدد الحجارة n، حدد ما إذا كان بإمكانك الفوز باللعبة إذا لعبت أنت وخصمك بشكل مثالي. \nملاحظة: أنت دائمًا تأخذ الدور الأول.\n\nإليك بعض الحالات:\n    >>> canWinNim(1)\n    true",
      "sw": "Unacheza mchezo unaoitwa Nim. Katika mchezo huu, unaanza na rundo la mawe n, na wewe na mpinzani wako mnachukua zamu kuondoa mawe 1 hadi 3 kutoka kwenye rundo. Yule anayeondoa jiwe la mwisho anashinda mchezo. Ukipewa idadi ya mawe n, amua kama unaweza kushinda mchezo ikiwa wewe na mpinzani wako mna cheza kwa ustadi.\nKumbuka: Daima unachukua zamu ya kwanza.\n\nHapa kuna baadhi ya kesi:\n    >>> canWinNim(1)\n    true",
      "tr": "Nim adlı bir oyun oynuyorsunuz. Bu oyunda, n taşlık bir yığınla başlarsınız ve siz ve rakibiniz sırayla yığından 1 ila 3 taş çıkarırsınız. Son taşı çıkaran oyunu kazanır. Taş sayısı n verildiğinde, hem siz hem de rakibiniz en iyi şekilde oynarsa oyunu kazanıp kazanamayacağınızı belirleyin. \nNot: Her zaman ilk hamleyi siz yaparsınız.\n\nİşte bazı durumlar:\n    >>> canWinNim(1)\n    true",
      "vi": "Bạn đang chơi một trò chơi có tên là Nim. Trong trò chơi này, bạn bắt đầu với một đống gồm n viên đá, và bạn cùng đối thủ lần lượt lấy đi từ 1 đến 3 viên đá từ đống đó. Người nào lấy viên đá cuối cùng sẽ thắng trò chơi. Cho số lượng viên đá n, xác định xem bạn có thể thắng trò chơi hay không nếu cả bạn và đối thủ đều chơi tối ưu.\nLưu ý: Bạn luôn đi trước.\n\nDưới đây là một số trường hợp:\n    >>> canWinNim(1)\n    true"
    },
    "docstring_bertscore": {
      "es": "0.9878523617870494",
      "arb": "0.9816461555316143",
      "sw": "0.9863596544735722",
      "tr": "0.9684046598103044",
      "vi": "0.9769598689518582"
    }
  },
  {
    "task_id": "C/50",
    "prompt": {
      "es": "#include <assert.h>\n#include <stdio.h>\n/*\nDado dos enteros a y b, devuelve la suma si la suma es par, o devuelve el producto de a y b si la suma es impar.\n    >>> evenSumOrOddProduct(2, 3)\n    6\n    >>> evenSumOrOddProduct(5, 5)\n    10\n*/\nint evenSumOrOddProduct(int a, int b);",
      "arb": "#include <assert.h>\n#include <stdio.h>\n/*\nمعطى عددين صحيحين a و b، أعد المجموع إذا كان المجموع زوجياً، أو أعد حاصل ضرب a و b إذا كان المجموع فردياً.\n    >>> evenSumOrOddProduct(2, 3)\n    6\n    >>> evenSumOrOddProduct(5, 5)\n    10\n*/\nint evenSumOrOddProduct(int a, int b);",
      "sw": "#include <assert.h>\n#include <stdio.h>\n/*\nUkipokea nambari mbili nzima a na b, rudisha jumla ikiwa jumla ni shufwa, au rudisha bidhaa ya a na b ikiwa jumla ni witiri.\n    >>> evenSumOrOddProduct(2, 3)\n    6\n    >>> evenSumOrOddProduct(5, 5)\n    10\n*/\nint evenSumOrOddProduct(int a, int b);",
      "tr": "#include <assert.h>\n#include <stdio.h>\n/*\nVerilen iki tamsayı a ve b için, toplam çift ise toplamı döndürün, toplam tek ise a ve b'nin çarpımını döndürün.\n    >>> evenSumOrOddProduct(2, 3)\n    6\n    >>> evenSumOrOddProduct(5, 5)\n    10\n*/\nint evenSumOrOddProduct(int a, int b);",
      "vi": "#include <assert.h>\n#include <stdio.h>\n/*\nCho hai số nguyên a và b, trả về tổng nếu tổng là số chẵn, hoặc trả về tích của a và b nếu tổng là số lẻ.\n    >>> evenSumOrOddProduct(2, 3)\n    6\n    >>> evenSumOrOddProduct(5, 5)\n    10\n*/\nint evenSumOrOddProduct(int a, int b);"
    },
    "prompt_bertscore": {
      "es": "1",
      "arb": "1",
      "sw": "0.9820354710784427",
      "tr": "0.9631451259508816",
      "vi": "1"
    },
    "canonical_solution": "int evenSumOrOddProduct(int a, int b) {\n    int sum = a + b;\n    if (sum % 2 == 0)\n        return sum;\n    else\n        return a * b;\n}",
    "instruction": {
      "es": "int evenSumOrOddProduct(int a, int b)\nint evenSumOrOddProduct(int a, int b) {\n    int sum = a + b;\n    if (sum % 2 == 0)\n        return sum;\n    else\n        return a * b;\n}\n\nProporcione una descripción concisa en lenguaje natural (docstring) del código C en español utilizando como máximo 500 caracteres.",
      "arb": "int evenSumOrOddProduct(int a, int b)\nint evenSumOrOddProduct(int a, int b) {\n    int sum = a + b;\n    if (sum % 2 == 0)\n        return sum;\n    else\n        return a * b;\n}\n\nقم بتوفير وصف موجز بلغة طبيعية (docstring) للكود المكتوب بلغة C باللغة العربية الفصحى باستخدام ما لا يزيد عن 500 حرف.",
      "sw": "int evenSumOrOddProduct(int a, int b)\nint evenSumOrOddProduct(int a, int b) {\n    int sum = a + b;\n    if (sum % 2 == 0)\n        return sum;\n    else\n        return a * b;\n}\n\nToa maelezo mafupi ya lugha ya asili (docstring) ya msimbo wa C kwa Kiswahili kwa kutumia herufi zisizozidi 500.",
      "tr": "int evenSumOrOddProduct(int a, int b)\nint evenSumOrOddProduct(int a, int b) {\n    int sum = a + b;\n    if (sum % 2 == 0)\n        return sum;\n    else\n        return a * b;\n}\n\nC kodunun işlevini açıklayan kısa bir doğal dil tanımı (docstring) sağlayın. Açıklama en fazla 500 karakter olmalıdır.",
      "vi": "int evenSumOrOddProduct(int a, int b)\nint evenSumOrOddProduct(int a, int b) {\n    int sum = a + b;\n    if (sum % 2 == 0)\n        return sum;\n    else\n        return a * b;\n}\n\nCung cấp mô tả ngắn gọn bằng ngôn ngữ tự nhiên (docstring) cho mã C bằng tiếng Việt, sử dụng tối đa 500 ký tự."
    },
    "instruction_bertscore": {
      "es": "0.9687963589217052",
      "arb": "0.8982309297552509",
      "sw": "0.9146175389298671",
      "tr": "0.8359883121845394",
      "vi": "0.918266379029478"
    },
    "level": "",
    "test": "int main() {\n    assert(evenSumOrOddProduct(2, 3) == 6);\n    assert(evenSumOrOddProduct(5, 5) == 10);\n    assert(evenSumOrOddProduct(1, 1) == 2);\n    assert(evenSumOrOddProduct(0, 0) == 0);\n    assert(evenSumOrOddProduct(-1, -1) == -2);\n    assert(evenSumOrOddProduct(100, 200) == 300);\n    assert(evenSumOrOddProduct(3, 4) == 12);\n    assert(evenSumOrOddProduct(-5, 5) == 0);\n    assert(evenSumOrOddProduct(7, 8) == 56);\n    assert(evenSumOrOddProduct(9, 10) == 90);\n    assert(evenSumOrOddProduct(11, 14) == 154);\n    return 0;\n}",
    "entry_point": "evenSumOrOddProduct",
    "signature": "int evenSumOrOddProduct(int a, int b)",
    "docstring": {
      "es": "Dado dos enteros a y b, devuelve la suma si la suma es par, o devuelve el producto de a y b si la suma es impar.\n    >>> evenSumOrOddProduct(2, 3)\n    6\n    >>> evenSumOrOddProduct(5, 5)\n    10",
      "arb": "بالنظر إلى عددين صحيحين a و b، قم بإرجاع المجموع إذا كان المجموع زوجيًا، أو قم بإرجاع حاصل ضرب a و b إذا كان المجموع فرديًا.\n    >>> evenSumOrOddProduct(2, 3)\n    6\n    >>> evenSumOrOddProduct(5, 5)\n    10",
      "sw": "Ukipewa namba mbili nzima a na b, rudisha jumla ikiwa jumla ni namba shufwa, au rudisha bidhaa ya a na b ikiwa jumla ni namba witiri.\n    >>> evenSumOrOddProduct(2, 3)\n    6\n    >>> evenSumOrOddProduct(5, 5)\n    10",
      "tr": "Verilen iki tamsayı a ve b için, toplam çift ise toplamı döndürün, toplam tek ise a ve b'nin çarpımını döndürün.\n    >>> evenSumOrOddProduct(2, 3)\n    6\n    >>> evenSumOrOddProduct(5, 5)\n    10",
      "vi": "Cho hai số nguyên a và b, trả về tổng nếu tổng là số chẵn, hoặc trả về tích của a và b nếu tổng là số lẻ.\n    >>> evenSumOrOddProduct(2, 3)\n    6\n    >>> evenSumOrOddProduct(5, 5)\n    10"
    },
    "docstring_bertscore": {
      "es": "1",
      "arb": "1",
      "sw": "0.9676075560912115",
      "tr": "0.942986525840413",
      "vi": "1"
    }
  }
]