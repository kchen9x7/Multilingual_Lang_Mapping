[
  {
    "task_id": "Shell/1",
    "prompt": {
      "en": "#!/bin/bash\n\nhas_close_elements() {\nlocal numbers=($1)\nlocal threshold=$2\n#Check if in given list of numbers, are any two numbers closer to each other than\n#given threshold.\n#>>> has_close_elements([1.0, 2.0, 3.0], 0.5)\n#False\n#>>> has_close_elements([1.0, 2.8, 3.0, 4.0, 5.0, 2.0], 0.3)\n#True",
      "sq": "#!/bin/bash\n\nhas_close_elements() {\nlocal numbers=($1)\nlocal threshold=$2\n#Kontrollo nëse në listën e dhënë të numrave, ndonjë dy numra janë më afër njëri-tjetrit se\n#pragu i dhënë.\n#>>> has_close_elements([1.0, 2.0, 3.0], 0.5)\n#False\n#>>> has_close_elements([1.0, 2.8, 3.0, 4.0, 5.0, 2.0], 0.3)\n#True",
      "hy": "#!/bin/bash\n\nhas_close_elements() {\nlocal numbers=($1)\nlocal threshold=$2\n#Ստուգել, արդյոք տրված թվերի ցանկում որևէ երկու թիվ իրարից ավելի մոտ են, քան տրված շեմը։\n#>>> has_close_elements([1.0, 2.0, 3.0], 0.5)\n#False\n#>>> has_close_elements([1.0, 2.8, 3.0, 4.0, 5.0, 2.0], 0.3)\n#True",
      "bn": "#!/bin/bash\n\nhas_close_elements() {\nlocal numbers=($1)\nlocal threshold=$2\n#প্রদত্ত সংখ্যার তালিকায়, কোনো দুটি সংখ্যা কি একে অপরের থেকে প্রদত্ত সীমার চেয়ে কাছাকাছি আছে কিনা তা পরীক্ষা করুন।\n#>>> has_close_elements([1.0, 2.0, 3.0], 0.5)\n#False\n#>>> has_close_elements([1.0, 2.8, 3.0, 4.0, 5.0, 2.0], 0.3)\n#True",
      "bg": "#!/bin/bash\n\nhas_close_elements() {\nlocal numbers=($1)\nlocal threshold=$2\n#Проверете дали в дадения списък от числа има две числа, които са по-близо едно до друго\n#от дадения праг.\n#>>> has_close_elements([1.0, 2.0, 3.0], 0.5)\n#False\n#>>> has_close_elements([1.0, 2.8, 3.0, 4.0, 5.0, 2.0], 0.3)\n#True",
      "zh": "#!/bin/bash\n\nhas_close_elements() {\nlocal numbers=($1)\nlocal threshold=$2\n#检查在给定的数字列表中，是否有任意两个数字之间的距离小于给定的阈值。\n#>>> has_close_elements([1.0, 2.0, 3.0], 0.5)\n#False\n#>>> has_close_elements([1.0, 2.8, 3.0, 4.0, 5.0, 2.0], 0.3)\n#True",
      "fr": "#!/bin/bash\n\nhas_close_elements() {\nlocal numbers=($1)\nlocal threshold=$2\n#Vérifier si, dans la liste donnée de nombres, il y a deux nombres plus proches l'un de l'autre que le seuil donné.\n#>>> has_close_elements([1.0, 2.0, 3.0], 0.5)\n#False\n#>>> has_close_elements([1.0, 2.8, 3.0, 4.0, 5.0, 2.0], 0.3)\n#True",
      "de": "#!/bin/bash\n\nhas_close_elements() {\nlocal numbers=($1)\nlocal threshold=$2\n#Überprüfen, ob in der gegebenen Liste von Zahlen zwei Zahlen näher beieinander liegen als\n#der gegebene Schwellenwert.\n#>>> has_close_elements([1.0, 2.0, 3.0], 0.5)\n#False\n#>>> has_close_elements([1.0, 2.8, 3.0, 4.0, 5.0, 2.0], 0.3)\n#True",
      "ha": "#!/bin/bash\n\nhas_close_elements() {\nlocal numbers=($1)\nlocal threshold=$2\n# Duba idan a cikin jerin lambobin da aka bayar, akwai wasu lambobi biyu da suka fi kusa da juna fiye da\n# iyakar da aka bayar.\n#>>> has_close_elements([1.0, 2.0, 3.0], 0.5)\n#False\n#>>> has_close_elements([1.0, 2.8, 3.0, 4.0, 5.0, 2.0], 0.3)\n#True",
      "hi": "#!/bin/bash\n\nhas_close_elements() {\nlocal numbers=($1)\nlocal threshold=$2\n#जांचें कि दिए गए संख्याओं की सूची में, क्या कोई दो संख्याएँ एक-दूसरे के करीब हैं\n#दिए गए सीमा से।\n#>>> has_close_elements([1.0, 2.0, 3.0], 0.5)\n#False\n#>>> has_close_elements([1.0, 2.8, 3.0, 4.0, 5.0, 2.0], 0.3)\n#True",
      "hu": "#!/bin/bash\n\nhas_close_elements() {\nlocal numbers=($1)\nlocal threshold=$2\n#Ellenőrizze, hogy a megadott számok listájában van-e bármelyik két szám közelebb egymáshoz, mint a megadott küszöbérték.\n#>>> has_close_elements([1.0, 2.0, 3.0], 0.5)\n#False\n#>>> has_close_elements([1.0, 2.8, 3.0, 4.0, 5.0, 2.0], 0.3)\n#True"
    },
    "prompt_bertscore": {
      "sq": "0.9842734395815628",
      "hy": "0.9697479970772435",
      "bn": "0.9686585094372671",
      "bg": "0.972370315367666",
      "zh": "0.9597503341086144",
      "fr": "0.9771477732923172",
      "de": "0.9738185294757914",
      "ha": "0.9719269723571962",
      "hi": "0.9785510969343286",
      "hu": "0.9674432887660956"
    },
    "canonical_solution": "local n=${#numbers[@]}\n\nfor (( i=0; i<$n; i++ )); do\nfor (( j=0; j<$n; j++ )); do\nif [[ $i -ne $j ]]; then\nlocal diff=$(echo \"${numbers[$i]} - ${numbers[$j]}\" | bc)\ndiff=$(echo \"$diff\" | tr -d -) # Absolute value\n\nlocal result=$(echo \"$diff < $threshold\" | bc)\nif [[ $result -eq 1 ]]; then\necho \"true\"\nreturn 0\nfi\nfi\ndone\ndone\n\necho \"false\"\n}",
    "instruction": {
      "en": "Write a Shell function `has_close_elements() {\nlocal numbers=($1)\nlocal threshold=$2\n` to solve the following problem:\nCheck if in given list of numbers, are any two numbers closer to each other than\ngiven threshold.\n>>> has_close_elements([1.0, 2.0, 3.0], 0.5)\nFalse\n>>> has_close_elements([1.0, 2.8, 3.0, 4.0, 5.0, 2.0], 0.3)\nTrue",
      "sq": "Shkruani një funksion Shell `has_close_elements() {\nlocal numbers=($1)\nlocal threshold=$2\n` për të zgjidhur problemin e mëposhtëm:\nKontrolloni nëse në listën e dhënë të numrave, ndonjë dy numra janë më afër njëri-tjetrit sesa pragu i dhënë.\n>>> has_close_elements([1.0, 2.0, 3.0], 0.5)\nFalse\n>>> has_close_elements([1.0, 2.8, 3.0, 4.0, 5.0, 2.0], 0.3)\nTrue",
      "hy": "Գրեք Shell ֆունկցիա `has_close_elements() {\nlocal numbers=($1)\nlocal threshold=$2\n` հետևյալ խնդիրը լուծելու համար:\nՍտուգեք, արդյոք տրված թվերի ցուցակում որևէ երկու թիվ ավելի մոտ են միմյանց, քան տրված շեմը:\n>>> has_close_elements([1.0, 2.0, 3.0], 0.5)\nFalse\n>>> has_close_elements([1.0, 2.8, 3.0, 4.0, 5.0, 2.0], 0.3)\nTrue",
      "bn": "শেল ফাংশন `has_close_elements() {\nlocal numbers=($1)\nlocal threshold=$2\n` লিখুন নিম্নলিখিত সমস্যার সমাধানের জন্য:\nযাচাই করুন যে প্রদত্ত সংখ্যার তালিকায়, কোনো দুটি সংখ্যা কি একে অপরের থেকে প্রদত্ত সীমার চেয়ে কাছাকাছি আছে কিনা।\n>>> has_close_elements([1.0, 2.0, 3.0], 0.5)\nFalse\n>>> has_close_elements([1.0, 2.8, 3.0, 4.0, 5.0, 2.0], 0.3)\nTrue",
      "bg": "Напишете Shell функция `has_close_elements() {\nlocal numbers=($1)\nlocal threshold=$2\n` за решаване на следния проблем:\nПроверете дали в даден списък от числа има две числа, които са по-близо едно до друго от даден праг.\n>>> has_close_elements([1.0, 2.0, 3.0], 0.5)\nFalse\n>>> has_close_elements([1.0, 2.8, 3.0, 4.0, 5.0, 2.0], 0.3)\nTrue",
      "zh": "编写一个 Shell 函数 `has_close_elements() {\nlocal numbers=($1)\nlocal threshold=$2\n` 来解决以下问题：\n检查在给定的数字列表中，是否有任意两个数字之间的距离小于给定的阈值。\n>>> has_close_elements([1.0, 2.0, 3.0], 0.5)\nFalse\n>>> has_close_elements([1.0, 2.8, 3.0, 4.0, 5.0, 2.0], 0.3)\nTrue",
      "fr": "Écrire une fonction Shell `has_close_elements() {\nlocal numbers=($1)\nlocal threshold=$2\n` pour résoudre le problème suivant :\nVérifiez si, dans une liste donnée de nombres, deux nombres sont plus proches l'un de l'autre que le seuil donné.\n>>> has_close_elements([1.0, 2.0, 3.0], 0.5)\nFalse\n>>> has_close_elements([1.0, 2.8, 3.0, 4.0, 5.0, 2.0], 0.3)\nTrue",
      "de": "Schreiben Sie eine Shell-Funktion `has_close_elements() {\nlocal numbers=($1)\nlocal threshold=$2\n` um das folgende Problem zu lösen:\nÜberprüfen Sie, ob in der gegebenen Liste von Zahlen zwei Zahlen näher beieinander liegen als der gegebene Schwellenwert.\n>>> has_close_elements([1.0, 2.0, 3.0], 0.5)\nFalse\n>>> has_close_elements([1.0, 2.8, 3.0, 4.0, 5.0, 2.0], 0.3)\nTrue",
      "ha": "Rubuta aikin Shell `has_close_elements() {\nlocal numbers=($1)\nlocal threshold=$2\n` don warware matsalar mai zuwa:\nDuba idan a cikin jerin lambobi da aka bayar, akwai kowanne lambobi biyu da ke kusa da juna fiye da\niyakar da aka bayar.\n>>> has_close_elements([1.0, 2.0, 3.0], 0.5)\nFalse\n>>> has_close_elements([1.0, 2.8, 3.0, 4.0, 5.0, 2.0], 0.3)\nTrue",
      "hi": "Shell फ़ंक्शन `has_close_elements() {\nlocal numbers=($1)\nlocal threshold=$2\n` लिखें ताकि निम्नलिखित समस्या का समाधान किया जा सके:\nजांचें कि दिए गए संख्या सूची में, क्या कोई दो संख्याएँ एक-दूसरे के जितनी निकट हैं, जितना कि दिया गया सीमा मान।\n>>> has_close_elements([1.0, 2.0, 3.0], 0.5)\nFalse\n>>> has_close_elements([1.0, 2.8, 3.0, 4.0, 5.0, 2.0], 0.3)\nTrue",
      "hu": "Írj egy Shell függvényt `has_close_elements() {\nlocal numbers=($1)\nlocal threshold=$2\n` a következő probléma megoldására:\nEllenőrizd, hogy a megadott számok listájában van-e bármely két szám, amely közelebb van egymáshoz, mint a megadott küszöbérték.\n>>> has_close_elements([1.0, 2.0, 3.0], 0.5)\nFalse\n>>> has_close_elements([1.0, 2.8, 3.0, 4.0, 5.0, 2.0], 0.3)\nTrue"
    },
    "instruction_bertscore": {
      "sq": "0.9862519968070512",
      "hy": "0.9770679238791411",
      "bn": "0.9804186197768187",
      "bg": "0.9702525182450721",
      "zh": "0.9644413878175153",
      "fr": "0.9798827150087865",
      "de": "0.9850767008424678",
      "ha": "0.9673249050589988",
      "hi": "0.9461566667217297",
      "hu": "0.9719726573448342"
    },
    "level": "easy",
    "test": "# Testing function\ntest_close_elements() {\n[[ $(has_close_elements \"1.0 2.0 3.9 4.0 5.0 2.2\" 0.3) == \"true\" ]] || { echo \"Test 1 failed\"; exit 1; }\n[[ $(has_close_elements \"1.0 2.0 3.9 4.0 5.0 2.2\" 0.05) == \"false\" ]] || { echo \"Test 2 failed\"; exit 1; }\n[[ $(has_close_elements \"1.0 2.0 5.9 4.0 5.0\" 0.95) == \"true\" ]] || { echo \"Test 3 failed\"; exit 1; }\n[[ $(has_close_elements \"1.0 2.0 5.9 4.0 5.0\" 0.8) == \"false\" ]] || { echo \"Test 4 failed\"; exit 1; }\n[[ $(has_close_elements \"1.0 2.0 3.0 4.0 5.0 2.0\" 0.1) == \"true\" ]] || { echo \"Test 5 failed\"; exit 1; }\n[[ $(has_close_elements \"1.1 2.2 3.1 4.1 5.1\" 1.0) == \"true\" ]] || { echo \"Test 6 failed\"; exit 1; }\n[[ $(has_close_elements \"1.1 2.2 3.1 4.1 5.1\" 0.5) == \"false\" ]] || { echo \"Test 7 failed\"; exit 1; }\n}\n\ntest_close_elements",
    "entry_point": "has_close_elements",
    "signature": "has_close_elements() {\nlocal numbers=($1)\nlocal threshold=$2\n",
    "docstring": {
      "en": "Check if in given list of numbers, are any two numbers closer to each other than\ngiven threshold.\n>>> has_close_elements([1.0, 2.0, 3.0], 0.5)\nFalse\n>>> has_close_elements([1.0, 2.8, 3.0, 4.0, 5.0, 2.0], 0.3)\nTrue",
      "sq": "Kontrolloni nëse në listën e dhënë të numrave, ndonjë dy numra janë më afër njëri-tjetrit sesa pragu i dhënë.\n>>> has_close_elements([1.0, 2.0, 3.0], 0.5)\nFalse\n>>> has_close_elements([1.0, 2.8, 3.0, 4.0, 5.0, 2.0], 0.3)\nTrue",
      "hy": "Ստուգել, արդյոք տրված թվերի ցուցակում կան երկու թվեր, որոնք միմյանց ավելի մոտ են, քան տրված շեմը:\n>>> has_close_elements([1.0, 2.0, 3.0], 0.5)\nFalse\n>>> has_close_elements([1.0, 2.8, 3.0, 4.0, 5.0, 2.0], 0.3)\nTrue",
      "bn": "দেওয়া সংখ্যার তালিকায়, কোনো দুটি সংখ্যা দেওয়া থ্রেশহোল্ডের চেয়ে কাছাকাছি আছে কিনা তা পরীক্ষা করুন।\n>>> has_close_elements([1.0, 2.0, 3.0], 0.5)\nFalse\n>>> has_close_elements([1.0, 2.8, 3.0, 4.0, 5.0, 2.0], 0.3)\nTrue",
      "bg": "Проверете дали в даден списък от числа има две числа, които са по-близо едно до друго от дадения праг.\n>>> has_close_elements([1.0, 2.0, 3.0], 0.5)\nFalse\n>>> has_close_elements([1.0, 2.8, 3.0, 4.0, 5.0, 2.0], 0.3)\nTrue",
      "zh": "检查给定数字列表中是否有任意两个数字之间的距离小于给定的阈值。  \n>>> has_close_elements([1.0, 2.0, 3.0], 0.5)  \nFalse  \n>>> has_close_elements([1.0, 2.8, 3.0, 4.0, 5.0, 2.0], 0.3)  \nTrue  ",
      "fr": "Vérifiez si, dans une liste donnée de nombres, il y a deux nombres plus proches l'un de l'autre que le seuil donné.\n>>> has_close_elements([1.0, 2.0, 3.0], 0.5)\nFalse\n>>> has_close_elements([1.0, 2.8, 3.0, 4.0, 5.0, 2.0], 0.3)\nTrue",
      "de": "Überprüfen Sie, ob in der gegebenen Liste von Zahlen zwei Zahlen näher beieinander liegen als der angegebene Schwellenwert.\n>>> has_close_elements([1.0, 2.0, 3.0], 0.5)\nFalse\n>>> has_close_elements([1.0, 2.8, 3.0, 4.0, 5.0, 2.0], 0.3)\nTrue",
      "ha": "Duba ko a cikin jerin lambobin da aka bayar, akwai wasu lambobi guda biyu da suka fi kusa da juna fiye da ƙayyadadden ƙima.\n\n>>> has_close_elements([1.0, 2.0, 3.0], 0.5)\nFalse\n>>> has_close_elements([1.0, 2.8, 3.0, 4.0, 5.0, 2.0], 0.3)\nTrue",
      "hi": "दिए गए संख्याओं की सूची में जाँच करें कि क्या कोई दो संख्याएँ दी गई सीमा से अधिक निकट हैं।\n>>> has_close_elements([1.0, 2.0, 3.0], 0.5)\nFalse\n>>> has_close_elements([1.0, 2.8, 3.0, 4.0, 5.0, 2.0], 0.3)\nTrue",
      "hu": "Ellenőrizze, hogy a megadott számok listájában van-e bármely két szám közelebb egymáshoz, mint a megadott küszöbérték.\n>>> has_close_elements([1.0, 2.0, 3.0], 0.5)\nFalse\n>>> has_close_elements([1.0, 2.8, 3.0, 4.0, 5.0, 2.0], 0.3)\nTrue"
    },
    "docstring_bertscore": {
      "sq": "0.9793704472560976",
      "hy": "0.9519393930047985",
      "bn": "0.9464407081666096",
      "bg": "0.957357036647525",
      "zh": "0.9418730039243314",
      "fr": "0.9641676751524493",
      "de": "0.9632567562250233",
      "ha": "0.9519207217489811",
      "hi": "0.9486451081353349",
      "hu": "0.9531496479164441"
    }
  },
  {
    "task_id": "Shell/2",
    "prompt": {
      "en": "#!/bin/bash\n\n# Function to find the third largest number in an array. If the third largest number does not exist, returns the largest number.\n# >>> third_largest_number([1, 2, 3, 4, 5])\n# 3\n# >>> third_largest_number([10, 5, 1])\n# 1\nthird_largest_number() {\nlocal numbers=($1)",
      "sq": "#!/bin/bash\n\n# Funksioni për të gjetur numrin e tretë më të madh në një varg. Nëse numri i tretë më i madh nuk ekziston, kthen numrin më të madh.\n# >>> third_largest_number([1, 2, 3, 4, 5])\n# 3\n# >>> third_largest_number([10, 5, 1])\n# 1\nthird_largest_number() {\nlocal numbers=($1)",
      "hy": "#!/bin/bash\n\n# Ֆունկցիա, որը գտնում է զանգվածի երրորդ ամենամեծ թիվը։ Եթե երրորդ ամենամեծ թիվը գոյություն չունի, վերադարձնում է ամենամեծ թիվը։\n# >>> third_largest_number([1, 2, 3, 4, 5])\n# 3\n# >>> third_largest_number([10, 5, 1])\n# 1\nthird_largest_number() {\nlocal numbers=($1)",
      "bn": "#!/bin/bash\n\n# একটি অ্যারে থেকে তৃতীয় বৃহত্তম সংখ্যা খুঁজে বের করার জন্য ফাংশন। যদি তৃতীয় বৃহত্তম সংখ্যা না থাকে, তাহলে বৃহত্তম সংখ্যাটি ফেরত দেয়।\n# >>> third_largest_number([1, 2, 3, 4, 5])\n# 3\n# >>> third_largest_number([10, 5, 1])\n# 1\nthird_largest_number() {\nlocal numbers=($1)",
      "bg": "#!/bin/bash\n\n# Функция за намиране на третото най-голямо число в масив. Ако третото най-голямо число не съществува, връща най-голямото число.\n# >>> third_largest_number([1, 2, 3, 4, 5])\n# 3\n# >>> third_largest_number([10, 5, 1])\n# 1\nthird_largest_number() {\nlocal numbers=($1)",
      "zh": "#!/bin/bash\n\n# 查找数组中第三大的数字的函数。如果不存在第三大的数字，则返回最大的数字。\n# >>> third_largest_number([1, 2, 3, 4, 5])\n# 3\n# >>> third_largest_number([10, 5, 1])\n# 1\nthird_largest_number() {\nlocal numbers=($1)",
      "fr": "#!/bin/bash\n\n# Fonction pour trouver le troisième plus grand nombre dans un tableau. Si le troisième plus grand nombre n'existe pas, retourne le plus grand nombre.\n# >>> third_largest_number([1, 2, 3, 4, 5])\n# 3\n# >>> third_largest_number([10, 5, 1])\n# 1\nthird_largest_number() {\nlocal numbers=($1)",
      "de": "#!/bin/bash\n\n# Funktion, um die drittgrößte Zahl in einem Array zu finden. Wenn die drittgrößte Zahl nicht existiert, wird die größte Zahl zurückgegeben.\n# >>> third_largest_number([1, 2, 3, 4, 5])\n# 3\n# >>> third_largest_number([10, 5, 1])\n# 1\nthird_largest_number() {\nlocal numbers=($1)",
      "ha": "#!/bin/bash\n\n# Aiki don nemo lamba ta uku mafi girma a cikin jerin lambobi. Idan ba a sami lamba ta uku mafi girma ba, zai dawo da lamba mafi girma.\n# >>> third_largest_number([1, 2, 3, 4, 5])\n# 3\n# >>> third_largest_number([10, 5, 1])\n# 1\nthird_largest_number() {\nlocal numbers=($1)",
      "hi": "#!/bin/bash\n\n# एक फ़ंक्शन जो एक array में तीसरी सबसे बड़ी संख्या खोजता है। यदि तीसरी सबसे बड़ी संख्या मौजूद नहीं है, तो सबसे बड़ी संख्या लौटाता है।\n# >>> third_largest_number([1, 2, 3, 4, 5])\n# 3\n# >>> third_largest_number([10, 5, 1])\n# 1\nthird_largest_number() {\nlocal numbers=($1)",
      "hu": "#!/bin/bash\n\n# Függvény, amely megkeresi a harmadik legnagyobb számot egy tömbben. Ha a harmadik legnagyobb szám nem létezik, a legnagyobb számot adja vissza.\n# >>> third_largest_number([1, 2, 3, 4, 5])\n# 3\n# >>> third_largest_number([10, 5, 1])\n# 1\nthird_largest_number() {\nlocal numbers=($1)"
    },
    "prompt_bertscore": {
      "sq": "0.999999801369619",
      "hy": "0.9920909354879528",
      "bn": "0.9817687104767128",
      "bg": "0.999999801369619",
      "zh": "0.9844885562842235",
      "fr": "0.999999801369619",
      "de": "0.9943845204977627",
      "ha": "0.9560115144463947",
      "hi": "0.9854916397084497",
      "hu": "0.9920909354879528"
    },
    "canonical_solution": "local n=${#numbers[@]}\nlocal first=-INF second=-INF third=-INF\n\nfor num in ${numbers[@]}; do\nif (( num > first )); then\nthird=$second\nsecond=$first\nfirst=$num\nelif (( num > second && num != first )); then\nthird=$second\nsecond=$num\nelif (( num > third && num != second && num != first )); then\nthird=$num\nfi\ndone\n\nif [[ $third == -INF ]]; then\necho $first\nelse\necho $third\nfi\n}",
    "instruction": {
      "en": "Write a Shell function `third_largest_number() {\nlocal numbers=($1)` to solve the following problem:\n\nFunction to find the third largest number in an array. If the third largest number does not exist, returns the largest number.\n>>> third_largest_number([1, 2, 3, 4, 5])\n3\n>>> third_largest_number([10, 5, 1])\n1\n",
      "sq": "Shkruani një funksion Shell `third_largest_number() {\nlocal numbers=($1)` për të zgjidhur problemin e mëposhtëm:\n\nFunksion për të gjetur numrin e tretë më të madh në një varg. Nëse numri i tretë më i madh nuk ekziston, kthen numrin më të madh.\n>>> third_largest_number([1, 2, 3, 4, 5])\n3\n>>> third_largest_number([10, 5, 1])\n1",
      "hy": "Գրեք Shell ֆունկցիա `third_largest_number() {\nlocal numbers=($1)` հետևյալ խնդիրը լուծելու համար:\n\nՖունկցիա, որը գտնում է զանգվածի երրորդ ամենամեծ թիվը։ Եթե երրորդ ամենամեծ թիվը գոյություն չունի, վերադարձնում է ամենամեծ թիվը։\n>>> third_largest_number([1, 2, 3, 4, 5])\n3\n>>> third_largest_number([10, 5, 1])\n1",
      "bn": "একটি Shell ফাংশন লিখুন `third_largest_number() { local numbers=($1)` নিম্নলিখিত সমস্যার সমাধানের জন্য:\n\nএকটি অ্যারের মধ্যে তৃতীয় বৃহত্তম সংখ্যা খুঁজে বের করার ফাংশন। যদি তৃতীয় বৃহত্তম সংখ্যা বিদ্যমান না থাকে, তাহলে বৃহত্তম সংখ্যাটি ফেরত দেয়।\n>>> third_largest_number([1, 2, 3, 4, 5])\n3\n>>> third_largest_number([10, 5, 1])\n1",
      "bg": "Напишете Shell функция `third_largest_number() {\nlocal numbers=($1)` за решаване на следния проблем:\n\nФункция за намиране на третото по големина число в масив. Ако третото по големина число не съществува, връща най-голямото число.\n>>> third_largest_number([1, 2, 3, 4, 5])\n3\n>>> third_largest_number([10, 5, 1])\n1",
      "zh": "编写一个 Shell 函数 `third_largest_number() {\nlocal numbers=($1)` 来解决以下问题：\n\n函数用于在数组中找到第三大的数字。如果不存在第三大的数字，则返回最大的数字。\n>>> third_largest_number([1, 2, 3, 4, 5])\n3\n>>> third_largest_number([10, 5, 1])\n1",
      "fr": "Écrire une fonction Shell `third_largest_number() {\nlocal numbers=($1)` pour résoudre le problème suivant :\n\nFonction pour trouver le troisième plus grand nombre dans un tableau. Si le troisième plus grand nombre n'existe pas, retourne le plus grand nombre.\n>>> third_largest_number([1, 2, 3, 4, 5])\n3\n>>> third_largest_number([10, 5, 1])\n1",
      "de": "Schreiben Sie eine Shell-Funktion `third_largest_number() {\nlocal numbers=($1)` um das folgende Problem zu lösen:\n\nFunktion, um die drittgrößte Zahl in einem Array zu finden. Wenn die drittgrößte Zahl nicht existiert, wird die größte Zahl zurückgegeben.\n>>> third_largest_number([1, 2, 3, 4, 5])\n3\n>>> third_largest_number([10, 5, 1])\n1",
      "ha": "Rubuta aikin Shell `third_largest_number() { local numbers=($1)` don warware matsalar mai zuwa:\n\nAiki don nemo lamba ta uku mafi girma a cikin jerin lambobi. Idan lamba ta uku mafi girma ba ta wanzu, yana dawo da lamba mafi girma.\n>>> third_largest_number([1, 2, 3, 4, 5])\n3\n>>> third_largest_number([10, 5, 1])\n1",
      "hi": "Shell फ़ंक्शन `third_largest_number() {\nlocal numbers=($1)` निम्नलिखित समस्या को हल करने के लिए:\n\nएक array में तीसरी सबसे बड़ी संख्या खोजने के लिए फ़ंक्शन। यदि तीसरी सबसे बड़ी संख्या मौजूद नहीं है, तो सबसे बड़ी संख्या लौटाता है।\n>>> third_largest_number([1, 2, 3, 4, 5])\n3\n>>> third_largest_number([10, 5, 1])\n1",
      "hu": "Írj egy Shell függvényt `third_largest_number() { local numbers=($1)` a következő probléma megoldására:\n\nFüggvény, amely megkeresi a harmadik legnagyobb számot egy tömbben. Ha a harmadik legnagyobb szám nem létezik, visszaadja a legnagyobb számot.\n>>> third_largest_number([1, 2, 3, 4, 5])\n3\n>>> third_largest_number([10, 5, 1])\n1"
    },
    "instruction_bertscore": {
      "sq": "0.9986131626796144",
      "hy": "0.9857887907584779",
      "bn": "0.9820434162936841",
      "bg": "0.9986131626796144",
      "zh": "0.9778978016111048",
      "fr": "0.9986131626796144",
      "de": "0.9922522233573532",
      "ha": "0.9700707714464252",
      "hi": "0.9787497273153635",
      "hu": "0.9915923732315552"
    },
    "level": "middle",
    "test": "test_third_largest_number() {\n[[ $(third_largest_number \"4 5 1 3 2\") == \"3\" ]] || { echo \"Test 1 failed\"; exit 1; }\n[[ $(third_largest_number \"10 5 1\") == \"1\" ]] || { echo \"Test 2 failed\"; exit 1; }\n[[ $(third_largest_number \"7 7 7 7\") == \"7\" ]] || { echo \"Test 3 failed\"; exit 1; }\n[[ $(third_largest_number \"9 8 7 6 5\") == \"7\" ]] || { echo \"Test 4 failed\"; exit 1; }\n[[ $(third_largest_number \"1 2\") == \"2\" ]] || { echo \"Test 5 failed\"; exit 1; }\n[[ $(third_largest_number \"3 3 3 2 1\") == \"1\" ]] || { echo \"Test 6 failed\"; exit 1; }\n[[ $(third_largest_number \"1\") == \"1\" ]] || { echo \"Test 7 failed\"; exit 1; }\n}\n\ntest_third_largest_number",
    "entry_point": "third_largest_number",
    "signature": "third_largest_number() {\nlocal numbers=($1)",
    "docstring": {
      "en": "\nFunction to find the third largest number in an array. If the third largest number does not exist, returns the largest number.\n>>> third_largest_number([1, 2, 3, 4, 5])\n3\n>>> third_largest_number([10, 5, 1])\n1\n",
      "sq": "Funksioni për të gjetur numrin e tretë më të madh në një varg. Nëse numri i tretë më i madh nuk ekziston, kthen numrin më të madh.\n>>> third_largest_number([1, 2, 3, 4, 5])\n3\n>>> third_largest_number([10, 5, 1])\n1",
      "hy": "Ֆունկցիա, որը գտնում է երրորդ ամենամեծ թիվը զանգվածում: Եթե երրորդ ամենամեծ թիվը գոյություն չունի, վերադարձնում է ամենամեծ թիվը:\n>>> third_largest_number([1, 2, 3, 4, 5])\n3\n>>> third_largest_number([10, 5, 1])\n1",
      "bn": "একটি অ্যারেতে তৃতীয় বৃহত্তম সংখ্যা খুঁজে বের করার জন্য ফাংশন। যদি তৃতীয় বৃহত্তম সংখ্যা না থাকে, তবে বৃহত্তম সংখ্যাটি ফেরত দেয়।\n>>> third_largest_number([1, 2, 3, 4, 5])\n3\n>>> third_largest_number([10, 5, 1])\n1",
      "bg": "Функция за намиране на третото по големина число в масив. Ако третото по големина число не съществува, връща най-голямото число.\n>>> third_largest_number([1, 2, 3, 4, 5])\n3\n>>> third_largest_number([10, 5, 1])\n1",
      "zh": "查找数组中第三大的数字的函数。如果不存在第三大的数字，则返回最大的数字。  \n>>> third_largest_number([1, 2, 3, 4, 5])  \n3  \n>>> third_largest_number([10, 5, 1])  \n1  ",
      "fr": "Fonction pour trouver le troisième plus grand nombre dans un tableau. Si le troisième plus grand nombre n'existe pas, retourne le plus grand nombre.\n>>> third_largest_number([1, 2, 3, 4, 5])\n3\n>>> third_largest_number([10, 5, 1])\n1",
      "de": "Funktion, um die drittgrößte Zahl in einem Array zu finden. Wenn die drittgrößte Zahl nicht existiert, wird die größte Zahl zurückgegeben.\n>>> third_largest_number([1, 2, 3, 4, 5])\n3\n>>> third_largest_number([10, 5, 1])\n1",
      "ha": "Aiki don nemo lamba ta uku mafi girma a cikin jerin lambobi. Idan ba a sami lamba ta uku mafi girma ba, yana mayar da lamba mafi girma.\n>>> third_largest_number([1, 2, 3, 4, 5])\n3\n>>> third_largest_number([10, 5, 1])\n1",
      "hi": "तीसरी सबसे बड़ी संख्या को एक array में खोजने के लिए फ़ंक्शन। यदि तीसरी सबसे बड़ी संख्या मौजूद नहीं है, तो सबसे बड़ी संख्या लौटाता है।\n>>> third_largest_number([1, 2, 3, 4, 5])\n3\n>>> third_largest_number([10, 5, 1])\n1",
      "hu": "Függvény a tömb harmadik legnagyobb számának megtalálására. Ha a harmadik legnagyobb szám nem létezik, a legnagyobb számot adja vissza.\n>>> third_largest_number([1, 2, 3, 4, 5])\n3\n>>> third_largest_number([10, 5, 1])\n1"
    },
    "docstring_bertscore": {
      "sq": "1",
      "hy": "0.9793378718736079",
      "bn": "0.9618540284741549",
      "bg": "1",
      "zh": "0.9674957271866889",
      "fr": "0.9979239152574233",
      "de": "0.9918102707595505",
      "ha": "0.9576051259934376",
      "hi": "1",
      "hu": "0.9856934481755811"
    }
  },
  {
    "task_id": "Shell/3",
    "prompt": {
      "en": "#!/bin/bash\n\n# Calculate taxes based on a progressive tax bracket system.\n# The function takes two arguments:\n# 1. A string representing the tax brackets in the format \"upper0 percent0 upper1 percent1 ...\"\n# 2. An integer representing the total income.\n# It returns the total tax amount.\n# >>> calculate_tax \"10000 10 20000 20 30000 30\" 25000\n# 4500\n# >>> calculate_tax \"10000 10 20000 20 30000 30\" 15000\n# 2000\ncalculate_tax() {\nIFS=' ' read -ra brackets <<< \"$1\"\nlocal income=$2",
      "sq": "#!/bin/bash\n\n# Llogarit taksat bazuar në një sistem progresiv të shkallëve të taksave.\n# Funksioni merr dy argumente:\n# 1. Një varg që përfaqëson shkallët e taksave në formatin \"upper0 percent0 upper1 percent1 ...\"\n# 2. Një numër i plotë që përfaqëson të ardhurat totale.\n# Kthen shumën totale të taksës.\n# >>> calculate_tax \"10000 10 20000 20 30000 30\" 25000\n# 4500\n# >>> calculate_tax \"10000 10 20000 20 30000 30\" 15000\n# 2000\ncalculate_tax() {\nIFS=' ' read -ra brackets <<< \"$1\"\nlocal income=$2",
      "hy": "#!/bin/bash\n\n# Հաշվել հարկերը պրոգրեսիվ հարկային սանդղակի համակարգի հիման վրա։\n# Ֆունկցիան ընդունում է երկու արգումենտ․\n# 1. Տող, որը ներկայացնում է հարկային սանդղակները \"upper0 percent0 upper1 percent1 ...\" ձևաչափով\n# 2. Թիվ, որը ներկայացնում է ընդհանուր եկամուտը։\n# Վերադարձնում է ընդհանուր հարկի գումարը։\n# >>> calculate_tax \"10000 10 20000 20 30000 30\" 25000\n# 4500\n# >>> calculate_tax \"10000 10 20000 20 30000 30\" 15000\n# 2000\ncalculate_tax() {\nIFS=' ' read -ra brackets <<< \"$1\"\nlocal income=$2",
      "bn": "#!/bin/bash\n\n# একটি প্রগতিশীল কর ব্র্যাকেট সিস্টেমের উপর ভিত্তি করে কর গণনা করুন।\n# ফাংশনটি দুটি আর্গুমেন্ট গ্রহণ করে:\n# 1. একটি স্ট্রিং যা কর ব্র্যাকেটগুলি \"upper0 percent0 upper1 percent1 ...\" ফরম্যাটে উপস্থাপন করে\n# 2. একটি পূর্ণসংখ্যা যা মোট আয় উপস্থাপন করে।\n# এটি মোট করের পরিমাণ ফেরত দেয়।\n# >>> calculate_tax \"10000 10 20000 20 30000 30\" 25000\n# 4500\n# >>> calculate_tax \"10000 10 20000 20 30000 30\" 15000\n# 2000\ncalculate_tax() {\nIFS=' ' read -ra brackets <<< \"$1\"\nlocal income=$2",
      "bg": "#!/bin/bash\n\n# Изчисляване на данъци въз основа на прогресивна данъчна скала.\n# Функцията приема два аргумента:\n# 1. Низ, представляващ данъчните скали във формат \"горна0 процент0 горна1 процент1 ...\"\n# 2. Цяло число, представляващо общия доход.\n# Връща общата сума на данъка.\n# >>> calculate_tax \"10000 10 20000 20 30000 30\" 25000\n# 4500\n# >>> calculate_tax \"10000 10 20000 20 30000 30\" 15000\n# 2000\ncalculate_tax() {\nIFS=' ' read -ra brackets <<< \"$1\"\nlocal income=$2",
      "zh": "#!/bin/bash\n\n# 根据累进税率系统计算税款。\n# 该函数接受两个参数：\n# 1. 一个字符串，表示税率区间，格式为 \"upper0 percent0 upper1 percent1 ...\"\n# 2. 一个整数，表示总收入。\n# 它返回总税额。\n# >>> calculate_tax \"10000 10 20000 20 30000 30\" 25000\n# 4500\n# >>> calculate_tax \"10000 10 20000 20 30000 30\" 15000\n# 2000\ncalculate_tax() {\nIFS=' ' read -ra brackets <<< \"$1\"\nlocal income=$2",
      "fr": "#!/bin/bash\n\n# Calculer les impôts basés sur un système de tranches d'imposition progressives.\n# La fonction prend deux arguments :\n# 1. Une chaîne représentant les tranches d'imposition au format \"upper0 percent0 upper1 percent1 ...\"\n# 2. Un entier représentant le revenu total.\n# Elle retourne le montant total des impôts.\n# >>> calculate_tax \"10000 10 20000 20 30000 30\" 25000\n# 4500\n# >>> calculate_tax \"10000 10 20000 20 30000 30\" 15000\n# 2000\ncalculate_tax() {\nIFS=' ' read -ra brackets <<< \"$1\"\nlocal income=$2",
      "de": "#!/bin/bash\n\n# Berechne Steuern basierend auf einem progressiven Steuersatzsystem.\n# Die Funktion nimmt zwei Argumente:\n# 1. Einen String, der die Steuerklassen im Format \"upper0 percent0 upper1 percent1 ...\" darstellt\n# 2. Einen Integer, der das Gesamteinkommen darstellt.\n# Sie gibt den gesamten Steuerbetrag zurück.\n# >>> calculate_tax \"10000 10 20000 20 30000 30\" 25000\n# 4500\n# >>> calculate_tax \"10000 10 20000 20 30000 30\" 15000\n# 2000\ncalculate_tax() {\nIFS=' ' read -ra brackets <<< \"$1\"\nlocal income=$2",
      "ha": "#!/bin/bash\n\n# Lissafin haraji bisa tsarin rarrabuwa na haraji mai ci gaba.\n# Aikin yana karɓar hujjoji guda biyu:\n# 1. Wani zare mai wakiltar rarrabuwa na haraji a cikin tsarin \"upper0 percent0 upper1 percent1 ...\"\n# 2. Wani cikakken lamba mai wakiltar jimillar kudin shiga.\n# Yana mayar da jimillar adadin haraji.\n# >>> calculate_tax \"10000 10 20000 20 30000 30\" 25000\n# 4500\n# >>> calculate_tax \"10000 10 20000 20 30000 30\" 15000\n# 2000\ncalculate_tax() {\nIFS=' ' read -ra brackets <<< \"$1\"\nlocal income=$2",
      "hi": "#!/bin/bash\n\n# प्रगतिशील कर ब्रैकेट प्रणाली के आधार पर कर की गणना करें।\n# फ़ंक्शन दो तर्क लेता है:\n# 1. एक स्ट्रिंग जो कर ब्रैकेट को \"upper0 percent0 upper1 percent1 ...\" प्रारूप में दर्शाती है\n# 2. एक पूर्णांक जो कुल आय का प्रतिनिधित्व करता है।\n# यह कुल कर राशि लौटाता है।\n# >>> calculate_tax \"10000 10 20000 20 30000 30\" 25000\n# 4500\n# >>> calculate_tax \"10000 10 20000 20 30000 30\" 15000\n# 2000\ncalculate_tax() {\nIFS=' ' read -ra brackets <<< \"$1\"\nlocal income=$2",
      "hu": "#!/bin/bash\n\n# Adók kiszámítása egy progresszív adósáv rendszer alapján.\n# A függvény két argumentumot vesz át:\n# 1. Egy stringet, amely az adósávokat reprezentálja a következő formátumban: \"felső0 százalék0 felső1 százalék1 ...\"\n# 2. Egy egész számot, amely a teljes jövedelmet reprezentálja.\n# Visszaadja a teljes adóösszeget.\n# >>> calculate_tax \"10000 10 20000 20 30000 30\" 25000\n# 4500\n# >>> calculate_tax \"10000 10 20000 20 30000 30\" 15000\n# 2000\ncalculate_tax() {\nIFS=' ' read -ra brackets <<< \"$1\"\nlocal income=$2"
    },
    "prompt_bertscore": {
      "sq": "0.9922250109951514",
      "hy": "0.9898056929541464",
      "bn": "0.9936660744095595",
      "bg": "0.9837716992390686",
      "zh": "0.985032406267497",
      "fr": "0.9940341365056171",
      "de": "0.9964153175134633",
      "ha": "0.9786873573757185",
      "hi": "0.9990100261809222",
      "hu": "0.9873581693990345"
    },
    "canonical_solution": "local tax=0\nlocal prev_upper=0\n\nfor (( i=0; i<${#brackets[@]}; i+=2 )); do\nlocal upper=${brackets[i]}\nlocal percent=${brackets[i+1]}\n\nif (( income <= upper )); then\ntax=$(echo \"$tax + (($income - $prev_upper) * $percent / 100)\" | bc)\necho $tax\nreturn\nelse\ntax=$(echo \"$tax + (($upper - $prev_upper) * $percent / 100)\" | bc)\nprev_upper=$upper\nfi\ndone\n\necho $tax\n}",
    "instruction": {
      "en": "Write a Shell function `calculate_tax() {\nIFS=' ' read -ra brackets <<< \"$1\"\nlocal income=$2` to solve the following problem:\n\nCalculate taxes based on a progressive tax bracket system.\nThe function takes two arguments:\n1. A string representing the tax brackets in the format \"upper0 percent0 upper1 percent1 ...\"\n2. An integer representing the total income.\nIt returns the total tax amount.\n>>> calculate_tax \"10000 10 20000 20 30000 30\" 25000\n4500\n>>> calculate_tax \"10000 10 20000 20 30000 30\" 15000\n2000\n",
      "sq": "Shkruani një funksion Shell `calculate_tax() {\nIFS=' ' read -ra brackets <<< \"$1\"\nlocal income=$2` për të zgjidhur problemin e mëposhtëm:\n\nLlogaritni taksat bazuar në një sistem të shkallëzuar të taksave.\nFunksioni merr dy argumente:\n1. Një varg që përfaqëson shkallët e taksave në formatin \"upper0 percent0 upper1 percent1 ...\"\n2. Një numër i plotë që përfaqëson të ardhurat totale.\nKthen shumën totale të taksës.\n>>> calculate_tax \"10000 10 20000 20 30000 30\" 25000\n4500\n>>> calculate_tax \"10000 10 20000 20 30000 30\" 15000\n2000",
      "hy": "Shell ֆունկցիա գրեք `calculate_tax() {\nIFS=' ' read -ra brackets <<< \"$1\"\nlocal income=$2` հետևյալ խնդիրը լուծելու համար:\n\nՀաշվարկել հարկերը պրոգրեսիվ հարկային սանդղակի համակարգի հիման վրա:\nՖունկցիան ընդունում է երկու արգումենտ:\n1. Տող, որը ներկայացնում է հարկային սանդղակները հետևյալ ձևաչափով՝ \"upper0 percent0 upper1 percent1 ...\"\n2. Ամբողջ թիվ, որը ներկայացնում է ընդհանուր եկամուտը:\nԱյն վերադարձնում է ընդհանուր հարկի գումարը:\n>>> calculate_tax \"10000 10 20000 20 30000 30\" 25000\n4500\n>>> calculate_tax \"10000 10 20000 20 30000 30\" 15000\n2000",
      "bn": "একটি Shell ফাংশন লিখুন `calculate_tax() {\nIFS=' ' read -ra brackets <<< \"$1\"\nlocal income=$2` নিম্নলিখিত সমস্যার সমাধানের জন্য:\n\nএকটি প্রগতিশীল কর স্ল্যাব সিস্টেমের উপর ভিত্তি করে কর গণনা করুন।\nফাংশনটি দুটি আর্গুমেন্ট গ্রহণ করে:\n1. একটি স্ট্রিং যা কর স্ল্যাবগুলিকে \"upper0 percent0 upper1 percent1 ...\" ফরম্যাটে উপস্থাপন করে\n2. একটি পূর্ণসংখ্যা যা মোট আয় উপস্থাপন করে।\nএটি মোট করের পরিমাণ ফেরত দেয়।\n>>> calculate_tax \"10000 10 20000 20 30000 30\" 25000\n4500\n>>> calculate_tax \"10000 10 20000 20 30000 30\" 15000\n2000",
      "bg": "Напишете Shell функция `calculate_tax() {\nIFS=' ' read -ra brackets <<< \"$1\"\nlocal income=$2`, за да решите следния проблем:\n\nИзчислете данъците въз основа на прогресивна данъчна скала.\nФункцията приема два аргумента:\n1. Низ, представляващ данъчните скали във формат \"upper0 percent0 upper1 percent1 ...\"\n2. Цяло число, представляващо общия доход.\nТя връща общата сума на данъка.\n>>> calculate_tax \"10000 10 20000 20 30000 30\" 25000\n4500\n>>> calculate_tax \"10000 10 20000 20 30000 30\" 15000\n2000",
      "zh": "编写一个 Shell 函数 `calculate_tax() {\nIFS=' ' read -ra brackets <<< \"$1\"\nlocal income=$2` 来解决以下问题：\n\n根据累进税率系统计算税款。\n该函数接受两个参数：\n1. 一个表示税率区间的字符串，格式为 \"upper0 percent0 upper1 percent1 ...\"\n2. 一个表示总收入的整数。\n它返回总税额。\n>>> calculate_tax \"10000 10 20000 20 30000 30\" 25000\n4500\n>>> calculate_tax \"10000 10 20000 20 30000 30\" 15000\n2000",
      "fr": "Écrire une fonction Shell `calculate_tax() {\nIFS=' ' read -ra brackets <<< \"$1\"\nlocal income=$2` pour résoudre le problème suivant :\n\nCalculer les impôts basés sur un système de tranches d'imposition progressives.\nLa fonction prend deux arguments :\n1. Une chaîne représentant les tranches d'imposition au format \"upper0 percent0 upper1 percent1 ...\"\n2. Un entier représentant le revenu total.\nElle retourne le montant total des impôts.\n>>> calculate_tax \"10000 10 20000 20 30000 30\" 25000\n4500\n>>> calculate_tax \"10000 10 20000 20 30000 30\" 15000\n2000",
      "de": "Schreiben Sie eine Shell-Funktion `calculate_tax() {\nIFS=' ' read -ra brackets <<< \"$1\"\nlocal income=$2`, um das folgende Problem zu lösen:\n\nBerechnen Sie Steuern basierend auf einem progressiven Steuersatzsystem.\nDie Funktion nimmt zwei Argumente:\n1. Einen String, der die Steuerklassen im Format \"upper0 percent0 upper1 percent1 ...\" darstellt\n2. Eine Ganzzahl, die das Gesamteinkommen darstellt.\nSie gibt den Gesamtsteuerbetrag zurück.\n>>> calculate_tax \"10000 10 20000 20 30000 30\" 25000\n4500\n>>> calculate_tax \"10000 10 20000 20 30000 30\" 15000\n2000",
      "ha": "Rubuta aikin Shell `calculate_tax() {\nIFS=' ' read -ra brackets <<< \"$1\"\nlocal income=$2` don warware matsalar mai zuwa:\n\nƘididdige haraji bisa tsarin matakin haraji mai ci gaba.\nAikin yana ɗaukar hujjoji guda biyu:\n1. Wani igiya mai wakiltar matakan haraji a cikin tsarin \"upper0 percent0 upper1 percent1 ...\"\n2. Wani cikakken lamba mai wakiltar jimillar kudin shiga.\nYana dawo da jimillar adadin haraji.\n>>> calculate_tax \"10000 10 20000 20 30000 30\" 25000\n4500\n>>> calculate_tax \"10000 10 20000 20 30000 30\" 15000\n2000",
      "hi": "Shell फ़ंक्शन `calculate_tax() {\nIFS=' ' read -ra brackets <<< \"$1\"\nlocal income=$2` निम्नलिखित समस्या को हल करने के लिए:\n\nप्रगतिशील कर ब्रैकेट प्रणाली के आधार पर करों की गणना करें।\nयह फ़ंक्शन दो तर्क लेता है:\n1. एक स्ट्रिंग जो कर ब्रैकेट का प्रतिनिधित्व करती है, प्रारूप में \"upper0 percent0 upper1 percent1 ...\"\n2. एक पूर्णांक जो कुल आय का प्रतिनिधित्व करता है।\nयह कुल कर राशि लौटाता है।\n>>> calculate_tax \"10000 10 20000 20 30000 30\" 25000\n4500\n>>> calculate_tax \"10000 10 20000 20 30000 30\" 15000\n2000",
      "hu": "Írj egy Shell függvényt `calculate_tax() {\nIFS=' ' read -ra brackets <<< \"$1\"\nlocal income=$2` a következő probléma megoldására:\n\nSzámítsd ki az adókat egy progresszív adósáv rendszer alapján.\nA függvény két argumentumot vesz:\n1. Egy karakterlánc, amely az adósávokat reprezentálja a következő formátumban: \"upper0 percent0 upper1 percent1 ...\"\n2. Egy egész szám, amely a teljes jövedelmet képviseli.\nVisszaadja a teljes adóösszeget.\n>>> calculate_tax \"10000 10 20000 20 30000 30\" 25000\n4500\n>>> calculate_tax \"10000 10 20000 20 30000 30\" 15000\n2000"
    },
    "instruction_bertscore": {
      "sq": "0.9859028045971919",
      "hy": "0.9790438989096762",
      "bn": "0.9789763645801244",
      "bg": "0.9854721739311083",
      "zh": "0.9868760934642629",
      "fr": "0.9938970815427031",
      "de": "0.9916150170949932",
      "ha": "0.9950288774538398",
      "hi": "0.9732258164187833",
      "hu": "0.9798787424011658"
    },
    "level": "easy",
    "test": "# Testing function\ntest_calculate_tax() {\n[[ $(calculate_tax \"10000 10 20000 20 30000 30\" 25000) == \"4500\" ]] || { echo \"Test 1 failed\"; exit 1; }\n[[ $(calculate_tax \"10000 10 20000 20 30000 30\" 15000) == \"2000\" ]] || { echo \"Test 2 failed\"; exit 1; }\n[[ $(calculate_tax \"5000 5 10000 10 20000 20\" 12000) == \"1150\" ]] || { echo \"Test 3 failed\"; exit 1; }\n[[ $(calculate_tax \"5000 5 10000 10 20000 20\" 5000) == \"250\" ]] || { echo \"Test 4 failed\"; exit 1; }\n[[ $(calculate_tax \"10000 10 20000 20\" 0) == \"0\" ]] || { echo \"Test 5 failed\"; exit 1; }\n}\n\ntest_calculate_tax",
    "entry_point": "calculate_tax",
    "signature": "calculate_tax() {\nIFS=' ' read -ra brackets <<< \"$1\"\nlocal income=$2",
    "docstring": {
      "en": "\nCalculate taxes based on a progressive tax bracket system.\nThe function takes two arguments:\n1. A string representing the tax brackets in the format \"upper0 percent0 upper1 percent1 ...\"\n2. An integer representing the total income.\nIt returns the total tax amount.\n>>> calculate_tax \"10000 10 20000 20 30000 30\" 25000\n4500\n>>> calculate_tax \"10000 10 20000 20 30000 30\" 15000\n2000\n",
      "sq": "Llogarit taksat bazuar në një sistem taksash progresive.\nFunksioni merr dy argumente:\n1. Një varg që përfaqëson shkallët e taksave në formatin \"upper0 percent0 upper1 percent1 ...\"\n2. Një numër i plotë që përfaqëson të ardhurat totale.\nKthen shumën totale të taksës.\n>>> calculate_tax \"10000 10 20000 20 30000 30\" 25000\n4500\n>>> calculate_tax \"10000 10 20000 20 30000 30\" 15000\n2000",
      "hy": "Հաշվարկել հարկերը պրոգրեսիվ հարկային սանդղակային համակարգի հիման վրա։ \nՖունկցիան ընդունում է երկու արգումենտ՝\n1. Տող, որը ներկայացնում է հարկային սանդղակները \"վերին0 տոկոս0 վերին1 տոկոս1 ...\" ձևաչափով\n2. Ամբողջ թիվ, որը ներկայացնում է ընդհանուր եկամուտը։\nԱյն վերադարձնում է ընդհանուր հարկային գումարը։\n>>> calculate_tax \"10000 10 20000 20 30000 30\" 25000\n4500\n>>> calculate_tax \"10000 10 20000 20 30000 30\" 15000\n2000",
      "bn": "প্রগতিশীল কর ব্র্যাকেট সিস্টেমের উপর ভিত্তি করে কর গণনা করুন। \nফাংশনটি দুটি আর্গুমেন্ট গ্রহণ করে:\n1. একটি স্ট্রিং যা কর ব্র্যাকেটগুলিকে \"upper0 percent0 upper1 percent1 ...\" ফরম্যাটে উপস্থাপন করে\n2. একটি পূর্ণসংখ্যা যা মোট আয়কে উপস্থাপন করে।\nএটি মোট করের পরিমাণ ফেরত দেয়।\n>>> calculate_tax \"10000 10 20000 20 30000 30\" 25000\n4500\n>>> calculate_tax \"10000 10 20000 20 30000 30\" 15000\n2000",
      "bg": "Изчисляване на данъци въз основа на прогресивна данъчна скала.  \nФункцията приема два аргумента:  \n1. Низ, представляващ данъчните скали във формат \"upper0 percent0 upper1 percent1 ...\"  \n2. Цяло число, представляващо общия доход.  \nВръща общата сума на данъка.  \n>>> calculate_tax \"10000 10 20000 20 30000 30\" 25000  \n4500  \n>>> calculate_tax \"10000 10 20000 20 30000 30\" 15000  \n2000  ",
      "zh": "根据累进税率系统计算税款。\n该函数接受两个参数：\n1. 一个表示税率区间的字符串，格式为 \"upper0 percent0 upper1 percent1 ...\"\n2. 一个表示总收入的整数。\n它返回总税额。\n>>> calculate_tax \"10000 10 20000 20 30000 30\" 25000\n4500\n>>> calculate_tax \"10000 10 20000 20 30000 30\" 15000\n2000",
      "fr": "Calculer les impôts en fonction d'un système de tranches d'imposition progressives.  \nLa fonction prend deux arguments :  \n1. Une chaîne de caractères représentant les tranches d'imposition au format \"upper0 percent0 upper1 percent1 ...\"  \n2. Un entier représentant le revenu total.  \nElle renvoie le montant total des impôts.  \n>>> calculate_tax \"10000 10 20000 20 30000 30\" 25000  \n4500  \n>>> calculate_tax \"10000 10 20000 20 30000 30\" 15000  \n2000  ",
      "de": "Berechnen Sie Steuern basierend auf einem progressiven Steuersatzsystem.\nDie Funktion nimmt zwei Argumente entgegen:\n1. Ein String, der die Steuersätze im Format \"upper0 percent0 upper1 percent1 ...\" darstellt.\n2. Ein Integer, der das Gesamteinkommen repräsentiert.\nSie gibt den gesamten Steuerbetrag zurück.\n>>> calculate_tax \"10000 10 20000 20 30000 30\" 25000\n4500\n>>> calculate_tax \"10000 10 20000 20 30000 30\" 15000\n2000",
      "ha": "Ƙididdige haraji bisa tsarin rarraba haraji mai ci gaba.\nAikin yana ɗaukar hujjoji guda biyu:\n1. Wani kirtani da ke wakiltar rarraba haraji a cikin tsarin \"upper0 percent0 upper1 percent1 ...\"\n2. Wani cikakken lamba da ke wakiltar jimillar kudin shiga.\nYana mayar da jimillar adadin haraji.\n>>> calculate_tax \"10000 10 20000 20 30000 30\" 25000\n4500\n>>> calculate_tax \"10000 10 20000 20 30000 30\" 15000\n2000",
      "hi": "प्रगतिशील कर ब्रैकेट प्रणाली के आधार पर कर की गणना करें।  \nयह फ़ंक्शन दो तर्क लेता है:  \n1. एक स्ट्रिंग जो कर ब्रैकेट को \"upper0 percent0 upper1 percent1 ...\" प्रारूप में दर्शाती है  \n2. एक पूर्णांक जो कुल आय को दर्शाता है।  \nयह कुल कर राशि लौटाता है।  \n>>> calculate_tax \"10000 10 20000 20 30000 30\" 25000  \n4500  \n>>> calculate_tax \"10000 10 20000 20 30000 30\" 15000  \n2000  ",
      "hu": "Számítsa ki az adókat egy progresszív adósáv-rendszer alapján.  \nA függvény két argumentumot vesz fel:  \n1. Egy karakterlánc, amely az adósávokat a következő formátumban ábrázolja: \"felső0 százalék0 felső1 százalék1 ...\"  \n2. Egy egész szám, amely a teljes jövedelmet jelöli.  \nA visszatérési érték a teljes adóösszeg.  \n>>> calculate_tax \"10000 10 20000 20 30000 30\" 25000  \n4500  \n>>> calculate_tax \"10000 10 20000 20 30000 30\" 15000  \n2000  "
    },
    "docstring_bertscore": {
      "sq": "0.9865088258897293",
      "hy": "0.9759583745706802",
      "bn": "0.9919028325171128",
      "bg": "0.9781345690252985",
      "zh": "0.9571717145020194",
      "fr": "0.9925714223796762",
      "de": "0.982316731697988",
      "ha": "0.9618341654360514",
      "hi": "0.9874763544757503",
      "hu": "0.9699239835948403"
    }
  },
  {
    "task_id": "Shell/4",
    "prompt": {
      "en": "#!/bin/bash\n\n# Check if a given square matrix is an X Matrix.\n# An X Matrix has non-zero elements on its diagonals and zero elements elsewhere.\n# The function takes a single string argument representing the matrix, where rows are separated by semicolons and elements by spaces.\n# Returns true if it's an X Matrix, false otherwise.\n# >>> is_x_matrix \"1 0 0;0 1 0;0 0 1\"\n# false\n# >>> is_x_matrix \"1 0 2;0 1 0;3 0 1\"\n# true\nis_x_matrix() {\nIFS=';' read -ra rows <<< \"$1\"",
      "sq": "#!/bin/bash\n\n# Kontrollon nëse një matricë katrore e dhënë është një Matricë X.\n# Një Matricë X ka elemente jo-zero në diagonalet e saj dhe elemente zero në pjesët e tjera.\n# Funksioni merr një argument të vetëm të tipit string që përfaqëson matricën, ku rreshtat ndahen me pikëpresje dhe elementet me hapësira.\n# Kthen true nëse është një Matricë X, false përndryshe.\n# >>> is_x_matrix \"1 0 0;0 1 0;0 0 1\"\n# false\n# >>> is_x_matrix \"1 0 2;0 1 0;3 0 1\"\n# true\nis_x_matrix() {\nIFS=';' read -ra rows <<< \"$1\"",
      "hy": "#!/bin/bash\n\n# Ստուգել, արդյոք տրված քառակուսի մատրիցը X մատրից է:\n# X մատրիցն ունի անկյունագծերի վրա ոչ զրոյական տարրեր և այլ տեղերում զրոյական տարրեր:\n# Ֆունկցիան ընդունում է մեկ տողային արգումենտ, որը ներկայացնում է մատրիցը, որտեղ տողերը բաժանված են կետ-ստորակետներով, իսկ տարրերը՝ բացատներով:\n# Վերադարձնում է true, եթե դա X մատրից է, հակառակ դեպքում՝ false:\n# >>> is_x_matrix \"1 0 0;0 1 0;0 0 1\"\n# false\n# >>> is_x_matrix \"1 0 2;0 1 0;3 0 1\"\n# true\nis_x_matrix() {\nIFS=';' read -ra rows <<< \"$1\"",
      "bn": "#!/bin/bash\n\n# একটি প্রদত্ত বর্গাকার ম্যাট্রিক্স X ম্যাট্রিক্স কিনা তা পরীক্ষা করুন।\n# একটি X ম্যাট্রিক্সের তার কর্ণগুলিতে শূন্য নয় এমন উপাদান থাকে এবং অন্যত্র শূন্য উপাদান থাকে।\n# ফাংশনটি একটি একক স্ট্রিং আর্গুমেন্ট গ্রহণ করে যা ম্যাট্রিক্সকে উপস্থাপন করে, যেখানে সারিগুলি সেমিকোলন দ্বারা এবং উপাদানগুলি স্পেস দ্বারা পৃথক করা হয়।\n# এটি একটি X ম্যাট্রিক্স হলে true ফেরত দেয়, অন্যথায় false।\n# >>> is_x_matrix \"1 0 0;0 1 0;0 0 1\"\n# false\n# >>> is_x_matrix \"1 0 2;0 1 0;3 0 1\"\n# true\nis_x_matrix() {\nIFS=';' read -ra rows <<< \"$1\"",
      "bg": "#!/bin/bash\n\n# Проверява дали дадена квадратна матрица е X Матрица.\n# X Матрица има ненулеви елементи по диагоналите си и нулеви елементи на останалите места.\n# Функцията приема един аргумент от тип низ, представляващ матрицата, където редовете са разделени със запетаи, а елементите с интервали.\n# Връща true, ако е X Матрица, false в противен случай.\n# >>> is_x_matrix \"1 0 0;0 1 0;0 0 1\"\n# false\n# >>> is_x_matrix \"1 0 2;0 1 0;3 0 1\"\n# true\nis_x_matrix() {\nIFS=';' read -ra rows <<< \"$1\"",
      "zh": "#!/bin/bash\n\n# 检查给定的方阵是否为 X 矩阵。\n# X 矩阵在其对角线上有非零元素，而其他位置为零元素。\n# 该函数接受一个表示矩阵的字符串参数，其中行由分号分隔，元素由空格分隔。\n# 如果是 X 矩阵则返回 true，否则返回 false。\n# >>> is_x_matrix \"1 0 0;0 1 0;0 0 1\"\n# false\n# >>> is_x_matrix \"1 0 2;0 1 0;3 0 1\"\n# true\nis_x_matrix() {\nIFS=';' read -ra rows <<< \"$1\"",
      "fr": "#!/bin/bash\n\n# Vérifie si une matrice carrée donnée est une matrice X.\n# Une matrice X a des éléments non nuls sur ses diagonales et des éléments nuls ailleurs.\n# La fonction prend un seul argument de type chaîne représentant la matrice, où les lignes sont séparées par des points-virgules et les éléments par des espaces.\n# Retourne vrai si c'est une matrice X, faux sinon.\n# >>> is_x_matrix \"1 0 0;0 1 0;0 0 1\"\n# false\n# >>> is_x_matrix \"1 0 2;0 1 0;3 0 1\"\n# true\nis_x_matrix() {\nIFS=';' read -ra rows <<< \"$1\"",
      "de": "#!/bin/bash\n\n# Überprüfen, ob eine gegebene quadratische Matrix eine X-Matrix ist.\n# Eine X-Matrix hat Nicht-Null-Elemente auf ihren Diagonalen und Null-Elemente an anderen Stellen.\n# Die Funktion nimmt ein einzelnes String-Argument entgegen, das die Matrix repräsentiert, wobei Zeilen durch Semikolons und Elemente durch Leerzeichen getrennt sind.\n# Gibt true zurück, wenn es eine X-Matrix ist, andernfalls false.\n# >>> is_x_matrix \"1 0 0;0 1 0;0 0 1\"\n# false\n# >>> is_x_matrix \"1 0 2;0 1 0;3 0 1\"\n# true\nis_x_matrix() {\nIFS=';' read -ra rows <<< \"$1\"",
      "ha": "#!/bin/bash\n\n# Duba idan wani matrix mai kusurwa huɗu da aka bayar X Matrix ne.\n# X Matrix yana da abubuwa marasa sifili a kan diagonals ɗinsa kuma abubuwa sifili a sauran wurare.\n# Aikin yana ɗaukar huɗu guda ɗaya wanda ke wakiltar matrix, inda aka raba layuka da semicolons kuma abubuwa da sarari.\n# Yana dawowa gaskiya idan X Matrix ne, ƙarya in ba haka ba.\n# >>> is_x_matrix \"1 0 0;0 1 0;0 0 1\"\n# false\n# >>> is_x_matrix \"1 0 2;0 1 0;3 0 1\"\n# true\nis_x_matrix() {\nIFS=';' read -ra rows <<< \"$1\"",
      "hi": "#!/bin/bash\n\n# जाँचें कि क्या दी गई वर्ग मैट्रिक्स एक X मैट्रिक्स है।\n# एक X मैट्रिक्स में इसकी विकर्णों पर गैर-शून्य तत्व होते हैं और अन्यत्र शून्य तत्व होते हैं।\n# यह फ़ंक्शन मैट्रिक्स का प्रतिनिधित्व करने वाले एकल स्ट्रिंग आर्गुमेंट को लेता है, जहाँ पंक्तियाँ अर्धविराम द्वारा और तत्व स्थानों द्वारा अलग होते हैं।\n# यदि यह एक X मैट्रिक्स है तो true लौटाता है, अन्यथा false।\n# >>> is_x_matrix \"1 0 0;0 1 0;0 0 1\"\n# false\n# >>> is_x_matrix \"1 0 2;0 1 0;3 0 1\"\n# true\nis_x_matrix() {\nIFS=';' read -ra rows <<< \"$1\"",
      "hu": "#!/bin/bash\n\n# Ellenőrzi, hogy egy adott négyzetes mátrix X Mátrix-e.\n# Az X Mátrixnak nem nulla elemei vannak az átlóin, és nulla elemei máshol.\n# A függvény egyetlen karakterlánc argumentumot vesz fel, amely a mátrixot reprezentálja, ahol a sorokat pontosvesszők, az elemeket pedig szóközök választják el.\n# Igazat ad vissza, ha X Mátrix, különben hamisat.\n# >>> is_x_matrix \"1 0 0;0 1 0;0 0 1\"\n# false\n# >>> is_x_matrix \"1 0 2;0 1 0;3 0 1\"\n# true\nis_x_matrix() {\nIFS=';' read -ra rows <<< \"$1\""
    },
    "prompt_bertscore": {
      "sq": "0.9850856392096143",
      "hy": "0.9892151648313298",
      "bn": "0.9889972673033345",
      "bg": "0.9785004461871647",
      "zh": "0.9818217447884491",
      "fr": "0.9934138138256452",
      "de": "0.9786915286137203",
      "ha": "0.9665939452567904",
      "hi": "0.9898076792579568",
      "hu": "0.9966723452265225"
    },
    "canonical_solution": "local n=${#rows[@]}\n\nfor (( i=0; i<$n; i++ )); do\nIFS=' ' read -ra cols <<< \"${rows[i]}\"\nfor (( j=0; j<$n; j++ )); do\nif (( i == j || i + j == n - 1 )); then\nif (( cols[j] == 0 )); then\necho \"false\"\nreturn\nfi\nelse\nif (( cols[j] != 0 )); then\necho \"false\"\nreturn\nfi\nfi\ndone\ndone\n\necho \"true\"\n}",
    "instruction": {
      "en": "Write a Shell function `is_x_matrix() {\nIFS=';' read -ra rows <<< \"$1\"` to solve the following problem:\n\nCheck if a given square matrix is an X Matrix.\nAn X Matrix has non-zero elements on its diagonals and zero elements elsewhere.\nThe function takes a single string argument representing the matrix, where rows are separated by semicolons and elements by spaces.\nReturns true if it's an X Matrix, false otherwise.\n>>> is_x_matrix \"1 0 0;0 1 0;0 0 1\"\nfalse\n>>> is_x_matrix \"1 0 2;0 1 0;3 0 1\"\ntrue\n",
      "sq": "Shkruani një funksion Shell `is_x_matrix() {\nIFS=';' read -ra rows <<< \"$1\"` për të zgjidhur problemin e mëposhtëm:\n\nKontrolloni nëse një matricë katrore e dhënë është një Matricë X.\nNjë Matricë X ka elementë jo-zero në diagonalet e saj dhe elementë zero gjetkë.\nFunksioni merr një argument të vetëm string që përfaqëson matricën, ku rreshtat ndahen me pikëpresje dhe elementët me hapësira.\nKthen true nëse është një Matricë X, false përndryshe.\n>>> is_x_matrix \"1 0 0;0 1 0;0 0 1\"\nfalse\n>>> is_x_matrix \"1 0 2;0 1 0;3 0 1\"\ntrue",
      "hy": "Shell ֆունկցիա գրեք `is_x_matrix() {\nIFS=';' read -ra rows <<< \"$1\"` հետևյալ խնդիրը լուծելու համար:\n\nՍտուգեք, արդյոք տրված քառակուսի մատրիցը X մատրից է:\nX մատրիցն ունի ոչ զրոյական տարրեր իր անկյունագծերի վրա և զրոյական տարրեր մնացած տեղերում:\nՖունկցիան ընդունում է մեկ տողային արգումենտ, որը ներկայացնում է մատրիցը, որտեղ տողերը բաժանված են կետ-ստորակետերով, իսկ տարրերը՝ բացատներով:\nՎերադարձնում է true, եթե դա X մատրից է, false՝ հակառակ դեպքում:\n>>> is_x_matrix \"1 0 0;0 1 0;0 0 1\"\nfalse\n>>> is_x_matrix \"1 0 2;0 1 0;3 0 1\"\ntrue",
      "bn": "একটি Shell ফাংশন লিখুন `is_x_matrix() {\nIFS=';' read -ra rows <<< \"$1\"` নিম্নলিখিত সমস্যার সমাধানের জন্য:\n\nযাচাই করুন একটি প্রদত্ত বর্গাকার ম্যাট্রিক্স একটি X ম্যাট্রিক্স কিনা।\nএকটি X ম্যাট্রিক্সের তার কর্ণগুলিতে অ-শূন্য উপাদান এবং অন্যত্র শূন্য উপাদান থাকে।\nফাংশনটি একটি একক স্ট্রিং আর্গুমেন্ট নেয় যা ম্যাট্রিক্সকে উপস্থাপন করে, যেখানে সারিগুলি সেমিকোলন দ্বারা পৃথক এবং উপাদানগুলি স্পেস দ্বারা পৃথক।\nএটি যদি একটি X ম্যাট্রিক্স হয় তবে সত্য ফেরত দেয়, অন্যথায় মিথ্যা।\n>>> is_x_matrix \"1 0 0;0 1 0;0 0 1\"\nfalse\n>>> is_x_matrix \"1 0 2;0 1 0;3 0 1\"\ntrue",
      "bg": "Напишете Shell функция `is_x_matrix() {\nIFS=';' read -ra rows <<< \"$1\"` за решаване на следния проблем:\n\nПроверете дали дадена квадратна матрица е X матрица.\nX матрицата има ненулеви елементи по диагоналите си и нулеви елементи на останалите места.\nФункцията приема един аргумент - низ, представляващ матрицата, където редовете са разделени със запетаи, а елементите с интервали.\nВръща true, ако е X матрица, false в противен случай.\n>>> is_x_matrix \"1 0 0;0 1 0;0 0 1\"\nfalse\n>>> is_x_matrix \"1 0 2;0 1 0;3 0 1\"\ntrue",
      "zh": "编写一个 Shell 函数 `is_x_matrix() {\nIFS=';' read -ra rows <<< \"$1\"` 来解决以下问题：\n\n检查给定的方阵是否为 X 矩阵。\nX 矩阵在其对角线上有非零元素，而其他地方为零元素。\n该函数接受一个表示矩阵的单个字符串参数，其中行用分号分隔，元素用空格分隔。\n如果是 X 矩阵则返回 true，否则返回 false。\n>>> is_x_matrix \"1 0 0;0 1 0;0 0 1\"\nfalse\n>>> is_x_matrix \"1 0 2;0 1 0;3 0 1\"\ntrue",
      "fr": "Écrire une fonction Shell `is_x_matrix() {\nIFS=';' read -ra rows <<< \"$1\"` pour résoudre le problème suivant :\n\nVérifiez si une matrice carrée donnée est une matrice X.\nUne matrice X a des éléments non nuls sur ses diagonales et des éléments nuls ailleurs.\nLa fonction prend un seul argument de chaîne représentant la matrice, où les lignes sont séparées par des points-virgules et les éléments par des espaces.\nRetourne vrai si c'est une matrice X, faux sinon.\n>>> is_x_matrix \"1 0 0;0 1 0;0 0 1\"\nfalse\n>>> is_x_matrix \"1 0 2;0 1 0;3 0 1\"\ntrue\n",
      "de": "Schreiben Sie eine Shell-Funktion `is_x_matrix() {\nIFS=';' read -ra rows <<< \"$1\"` um das folgende Problem zu lösen:\n\nÜberprüfen Sie, ob eine gegebene quadratische Matrix eine X-Matrix ist.\nEine X-Matrix hat Nicht-Null-Elemente auf ihren Diagonalen und Null-Elemente an anderen Stellen.\nDie Funktion nimmt ein einzelnes String-Argument entgegen, das die Matrix darstellt, wobei die Zeilen durch Semikolons und die Elemente durch Leerzeichen getrennt sind.\nGibt true zurück, wenn es eine X-Matrix ist, andernfalls false.\n>>> is_x_matrix \"1 0 0;0 1 0;0 0 1\"\nfalse\n>>> is_x_matrix \"1 0 2;0 1 0;3 0 1\"\ntrue",
      "ha": "Rubuta aikin Shell `is_x_matrix() {\nIFS=';' read -ra rows <<< \"$1\"` don warware matsalar mai zuwa:\n\nDuba idan wata matrix mai kusurwa huɗu da aka bayar X Matrix ce.\nX Matrix tana da abubuwa marasa sifili a kan diagonals ɗinta kuma sifili a sauran wurare.\nAikin yana ɗaukar hujja guda ɗaya mai wakiltar matrix, inda aka raba layuka da semicolons kuma abubuwa da sarari.\nYana dawowa gaskiya idan X Matrix ce, ƙarya idan ba haka ba.\n>>> is_x_matrix \"1 0 0;0 1 0;0 0 1\"\nfalse\n>>> is_x_matrix \"1 0 2;0 1 0;3 0 1\"\ntrue",
      "hi": "एक Shell फ़ंक्शन `is_x_matrix() {\nIFS=';' read -ra rows <<< \"$1\"` निम्नलिखित समस्या को हल करने के लिए लिखें:\n\nजांचें कि क्या दिया गया वर्ग मैट्रिक्स एक X मैट्रिक्स है।\nएक X मैट्रिक्स में इसके विकर्णों पर गैर-शून्य तत्व होते हैं और अन्यत्र शून्य तत्व होते हैं।\nयह फ़ंक्शन एकल स्ट्रिंग तर्क लेता है जो मैट्रिक्स का प्रतिनिधित्व करता है, जहाँ पंक्तियाँ अर्धविराम द्वारा और तत्व स्थानों द्वारा अलग किए गए होते हैं।\nयदि यह एक X मैट्रिक्स है तो true लौटाता है, अन्यथा false।\n>>> is_x_matrix \"1 0 0;0 1 0;0 0 1\"\nfalse\n>>> is_x_matrix \"1 0 2;0 1 0;3 0 1\"\ntrue",
      "hu": "Írj egy Shell függvényt `is_x_matrix() {\nIFS=';' read -ra rows <<< \"$1\"` a következő probléma megoldására:\n\nEllenőrizd, hogy egy adott négyzetes mátrix X mátrix-e.\nEgy X mátrixnak nem nulla elemei vannak az átlóin, és nulla elemei máshol.\nA függvény egyetlen string argumentumot vesz, amely a mátrixot reprezentálja, ahol a sorok pontosvesszővel, az elemek pedig szóközökkel vannak elválasztva.\nIgazat ad vissza, ha X mátrix, különben hamisat.\n>>> is_x_matrix \"1 0 0;0 1 0;0 0 1\"\nfalse\n>>> is_x_matrix \"1 0 2;0 1 0;3 0 1\"\ntrue"
    },
    "instruction_bertscore": {
      "sq": "0.9992968484511365",
      "hy": "0.9772458967005484",
      "bn": "0.9773456091518279",
      "bg": "0.9763693408290415",
      "zh": "0.97583164838758",
      "fr": "0.9935472934417007",
      "de": "0.9754089629367377",
      "ha": "0.9621275425088399",
      "hi": "0.8866696484271153",
      "hu": "0.9913468660805961"
    },
    "level": "easy",
    "test": "# Testing function\ntest_is_x_matrix() {\n[[ $(is_x_matrix \"1 0 0;0 1 0;0 0 1\") == \"false\" ]] || { echo \"Test 1 failed\"; exit 1; }\n[[ $(is_x_matrix \"1 0 2;0 1 0;3 0 1\") == \"true\" ]] || { echo \"Test 2 failed\"; exit 1; }\n[[ $(is_x_matrix \"2 0 0 0;0 3 0 0;0 0 5 0;0 0 0 7\") == \"false\" ]] || { echo \"Test 3 failed\"; exit 1; }\n[[ $(is_x_matrix \"1 0 0;0 0 0;0 0 1\") == \"false\" ]] || { echo \"Test 4 failed\"; exit 1; }\n[[ $(is_x_matrix \"0\") == \"false\" ]] || { echo \"Test 5 failed\"; exit 1; }\n[[ $(is_x_matrix \"5\") == \"true\" ]] || { echo \"Test 6 failed\"; exit 1; }\n[[ $(is_x_matrix \"1 0 1;0 1 0;1 0 1\") == \"true\" ]] || { echo \"Test 7 failed\"; exit 1; }\n}\n\ntest_is_x_matrix",
    "entry_point": "is_x_matrix",
    "signature": "is_x_matrix() {\nIFS=';' read -ra rows <<< \"$1\"",
    "docstring": {
      "en": "\nCheck if a given square matrix is an X Matrix.\nAn X Matrix has non-zero elements on its diagonals and zero elements elsewhere.\nThe function takes a single string argument representing the matrix, where rows are separated by semicolons and elements by spaces.\nReturns true if it's an X Matrix, false otherwise.\n>>> is_x_matrix \"1 0 0;0 1 0;0 0 1\"\nfalse\n>>> is_x_matrix \"1 0 2;0 1 0;3 0 1\"\ntrue\n",
      "sq": "Kontrollo nëse një matricë katrore e dhënë është një Matricë X.  \nNjë Matricë X ka elemente jo-zero në diagonalet e saj dhe elemente zero në pjesët e tjera.  \nFunksioni merr një argument të vetëm me varg që përfaqëson matricën, ku rreshtat ndahen me pikëpresje dhe elementet me hapësira.  \nKthen true nëse është një Matricë X, false përndryshe.  \n>>> is_x_matrix \"1 0 0;0 1 0;0 0 1\"  \nfalse  \n>>> is_x_matrix \"1 0 2;0 1 0;3 0 1\"  \ntrue  ",
      "hy": "Ստուգել, արդյոք տրված քառակուսի մատրիցը X մատրից է:\nX մատրիցը ունի ոչ զրոյական տարրեր իր անկյունագծերի վրա և զրոյական տարրեր մնացած տեղերում:\nՖունկցիան ընդունում է միակ տողային արգումենտ, որը ներկայացնում է մատրիցը, որտեղ տողերը բաժանված են կետ-ստորակետերով, իսկ տարրերը՝ բացատներով:\nՎերադարձնում է true, եթե դա X մատրից է, հակառակ դեպքում՝ false:\n>>> is_x_matrix \"1 0 0;0 1 0;0 0 1\"\nfalse\n>>> is_x_matrix \"1 0 2;0 1 0;3 0 1\"\ntrue",
      "bn": "একটি প্রদত্ত বর্গাকার ম্যাট্রিক্স X ম্যাট্রিক্স কিনা তা পরীক্ষা করুন।  \nএকটি X ম্যাট্রিক্সের তার কর্ণগুলিতে অশূন্য উপাদান এবং অন্যত্র শূন্য উপাদান থাকে।  \nফাংশনটি একটি একক স্ট্রিং আর্গুমেন্ট গ্রহণ করে যা ম্যাট্রিক্সকে উপস্থাপন করে, যেখানে সারিগুলি সেমিকোলন দ্বারা পৃথক করা হয় এবং উপাদানগুলি স্পেস দ্বারা পৃথক করা হয়।  \nযদি এটি একটি X ম্যাট্রিক্স হয় তবে true ফেরত দেয়, অন্যথায় false।  \n>>> is_x_matrix \"1 0 0;0 1 0;0 0 1\"  \nfalse  \n>>> is_x_matrix \"1 0 2;0 1 0;3 0 1\"  \ntrue  ",
      "bg": "Проверете дали дадена квадратна матрица е X матрица.  \nX матрица има ненулеви елементи по своите диагонали и нулеви елементи на всички други места.  \nФункцията приема един аргумент от тип string, представляващ матрицата, където редовете са разделени със запетаи, а елементите - с интервали.  \nВръща true, ако е X матрица, false в противен случай.  \n>>> is_x_matrix \"1 0 0;0 1 0;0 0 1\"  \nfalse  \n>>> is_x_matrix \"1 0 2;0 1 0;3 0 1\"  \ntrue  ",
      "zh": "检查给定的方阵是否为 X 矩阵。  \nX 矩阵在其对角线上有非零元素，而在其他地方有零元素。  \n该函数接受一个表示矩阵的单个字符串参数，其中行由分号分隔，元素由空格分隔。  \n如果是 X 矩阵则返回 true，否则返回 false。  \n>>> is_x_matrix \"1 0 0;0 1 0;0 0 1\"  \nfalse  \n>>> is_x_matrix \"1 0 2;0 1 0;3 0 1\"  \ntrue  ",
      "fr": "Vérifiez si une matrice carrée donnée est une matrice X.  \nUne matrice X a des éléments non nuls sur ses diagonales et des éléments nuls ailleurs.  \nLa fonction prend un seul argument de type chaîne représentant la matrice, où les lignes sont séparées par des points-virgules et les éléments par des espaces.  \nRenvoie vrai si c'est une matrice X, faux sinon.  \n>>> is_x_matrix \"1 0 0;0 1 0;0 0 1\"  \nfalse  \n>>> is_x_matrix \"1 0 2;0 1 0;3 0 1\"  \ntrue  ",
      "de": "Überprüfen, ob eine gegebene quadratische Matrix eine X-Matrix ist.  \nEine X-Matrix hat Nicht-Null-Elemente auf ihren Diagonalen und Null-Elemente an allen anderen Stellen.  \nDie Funktion nimmt ein einzelnes String-Argument, das die Matrix darstellt, wobei die Zeilen durch Semikolons und die Elemente durch Leerzeichen getrennt sind.  \nGibt true zurück, wenn es eine X-Matrix ist, andernfalls false.  \n>>> is_x_matrix \"1 0 0;0 1 0;0 0 1\"  \nfalse  \n>>> is_x_matrix \"1 0 2;0 1 0;3 0 1\"  \ntrue  ",
      "ha": "Duba idan matrix mai kusurwa huɗu da aka bayar X Matrix ne.  \nX Matrix yana da abubuwa marasa sifili akan diagonals ɗinsa kuma sifili abubuwa a sauran wurare.  \nAikin yana ɗaukar hujja guda ɗaya ta igiyar zare da ke wakiltar matrix, inda aka raba layuka ta hanyar semicolons kuma abubuwa ta sarari.  \nYana dawowa gaskiya idan X Matrix ne, ƙarya in ba haka ba.  \n>>> is_x_matrix \"1 0 0;0 1 0;0 0 1\"  \nƙarya  \n>>> is_x_matrix \"1 0 2;0 1 0;3 0 1\"  \ngaskiya  ",
      "hi": "दिया गया वर्ग मैट्रिक्स X मैट्रिक्स है या नहीं, यह जांचें।  \nएक X मैट्रिक्स में इसके विकर्णों पर गैर-शून्य तत्व होते हैं और अन्यत्र शून्य तत्व होते हैं।  \nयह फ़ंक्शन एकल स्ट्रिंग तर्क लेता है जो मैट्रिक्स का प्रतिनिधित्व करता है, जहाँ पंक्तियाँ अर्धविराम द्वारा और तत्व रिक्त स्थान द्वारा अलग होते हैं।  \nयदि यह X मैट्रिक्स है तो सत्य लौटाता है, अन्यथा असत्य।  \n>>> is_x_matrix \"1 0 0;0 1 0;0 0 1\"  \nfalse  \n>>> is_x_matrix \"1 0 2;0 1 0;3 0 1\"  \ntrue  ",
      "hu": "Ellenőrzi, hogy egy adott négyzetes mátrix X Mátrix-e.\nEgy X Mátrixnak nem nulla elemei vannak az átlóin, és nulla elemei máshol.\nA függvény egyetlen karakterlánc argumentumot vesz, amely a mátrixot ábrázolja, ahol a sorokat pontosvesszők választják el, és az elemeket szóközök.\nIgaz értéket ad vissza, ha X Mátrix, hamisat egyébként.\n>>> is_x_matrix \"1 0 0;0 1 0;0 0 1\"\nfalse\n>>> is_x_matrix \"1 0 2;0 1 0;3 0 1\"\ntrue"
    },
    "docstring_bertscore": {
      "sq": "0.9990982180701016",
      "hy": "0.987087634820065",
      "bn": "0.9777202260504597",
      "bg": "0.9461783174332625",
      "zh": "0.9665861986719301",
      "fr": "0.9922085246735255",
      "de": "0.9544780879048054",
      "ha": "0.9586370108229139",
      "hi": "0.9711312590507704",
      "hu": "0.9989480535020392"
    }
  },
  {
    "task_id": "Shell/5",
    "prompt": {
      "en": "#!/bin/bash\n\n# Perform operations on an array to remove pairs of equal integers.\n# Returns a two-element array: [number of pairs formed, number of remaining integers].\n# >>> process_array \"3 1 2 3 2\"\n# 2 1\n# >>> process_array \"1 2 3 4\"\n# 0 4\nprocess_array() {\nlocal nums=($1)",
      "sq": "#!/bin/bash\n\n# Kryen operacione në një varg për të hequr çiftet e numrave të barabartë.\n# Kthen një varg me dy elementë: [numri i çifteve të formuara, numri i numrave të mbetur].\n# >>> process_array \"3 1 2 3 2\"\n# 2 1\n# >>> process_array \"1 2 3 4\"\n# 0 4\nprocess_array() {\nlocal nums=($1)",
      "hy": "#!/bin/bash\n\n# Կատարել գործողություններ զանգվածի վրա՝ հեռացնելու հավասար ամբողջ թվերի զույգերը։\n# Վերադարձնում է երկու տարրից բաղկացած զանգված՝ [կազմված զույգերի քանակը, մնացած ամբողջ թվերի քանակը]։\n# >>> process_array \"3 1 2 3 2\"\n# 2 1\n# >>> process_array \"1 2 3 4\"\n# 0 4\nprocess_array() {\nlocal nums=($1)",
      "bn": "#!/bin/bash\n\n# একটি অ্যারেতে অপারেশন সম্পাদন করে সমান পূর্ণসংখ্যার জোড়া সরিয়ে ফেলা।\n# একটি দুই-উপাদান বিশিষ্ট অ্যারে প্রদান করে: [গঠিত জোড়ার সংখ্যা, অবশিষ্ট পূর্ণসংখ্যার সংখ্যা]।\n# >>> process_array \"3 1 2 3 2\"\n# 2 1\n# >>> process_array \"1 2 3 4\"\n# 0 4\nprocess_array() {\nlocal nums=($1)",
      "bg": "#!/bin/bash\n\n# Извършва операции върху масив, за да премахне двойки от равни цели числа.\n# Връща масив с два елемента: [брой на формираните двойки, брой на останалите цели числа].\n# >>> process_array \"3 1 2 3 2\"\n# 2 1\n# >>> process_array \"1 2 3 4\"\n# 0 4\nprocess_array() {\nlocal nums=($1)",
      "zh": "#!/bin/bash\n\n# 对数组进行操作以移除成对的相等整数。\n# 返回一个包含两个元素的数组：[形成的对数，剩余整数的数量]。\n# >>> process_array \"3 1 2 3 2\"\n# 2 1\n# >>> process_array \"1 2 3 4\"\n# 0 4\nprocess_array() {\nlocal nums=($1)",
      "fr": "#!/bin/bash\n\n# Effectuer des opérations sur un tableau pour supprimer les paires d'entiers égaux.\n# Renvoie un tableau à deux éléments : [nombre de paires formées, nombre d'entiers restants].\n# >>> process_array \"3 1 2 3 2\"\n# 2 1\n# >>> process_array \"1 2 3 4\"\n# 0 4\nprocess_array() {\nlocal nums=($1)",
      "de": "#!/bin/bash\n\n# Führen Sie Operationen an einem Array durch, um Paare gleicher Ganzzahlen zu entfernen.\n# Gibt ein zwei-elementiges Array zurück: [Anzahl der gebildeten Paare, Anzahl der verbleibenden Ganzzahlen].\n# >>> process_array \"3 1 2 3 2\"\n# 2 1\n# >>> process_array \"1 2 3 4\"\n# 0 4\nprocess_array() {\nlocal nums=($1)",
      "ha": "#!/bin/bash\n\n# Yi ayyuka akan wani tsari don cire ma'aurata na lambobi daidai.\n# Yana mayar da tsari mai abubuwa biyu: [yawan ma'aurata da aka kafa, yawan lambobin da suka rage].\n# >>> process_array \"3 1 2 3 2\"\n# 2 1\n# >>> process_array \"1 2 3 4\"\n# 0 4\nprocess_array() {\nlocal nums=($1)",
      "hi": "#!/bin/bash\n\n# एक array पर संचालन करें ताकि समान पूर्णांकों के जोड़े हटा सकें।\n# एक दो-तत्वों वाली array लौटाता है: [बने जोड़ों की संख्या, शेष पूर्णांकों की संख्या]।\n# >>> process_array \"3 1 2 3 2\"\n# 2 1\n# >>> process_array \"1 2 3 4\"\n# 0 4\nprocess_array() {\nlocal nums=($1)",
      "hu": "#!/bin/bash\n\n# Végezzen műveleteket egy tömbön, hogy eltávolítsa az egyenlő egész számok párjait.\n# Két elemből álló tömböt ad vissza: [a képzett párok száma, a megmaradt egész számok száma].\n# >>> process_array \"3 1 2 3 2\"\n# 2 1\n# >>> process_array \"1 2 3 4\"\n# 0 4\nprocess_array() {\nlocal nums=($1)"
    },
    "prompt_bertscore": {
      "sq": "0.9698487026804281",
      "hy": "0.972336349572509",
      "bn": "0.9773336913289659",
      "bg": "0.9810536411049872",
      "zh": "0.9773704379494572",
      "fr": "1",
      "de": "0.9917059898095072",
      "ha": "0.9640586270732612",
      "hi": "0.9876449916692489",
      "hu": "0.9771066568034429"
    },
    "canonical_solution": "local -A count_map\nlocal pairs=0\nlocal remaining=0\n\nfor num in ${nums[@]}; do\n((count_map[$num]++))\ndone\n\nfor count in ${count_map[@]}; do\npairs=$((pairs + count / 2))\nremaining=$((remaining + count % 2))\ndone\n\necho \"$pairs $remaining\"\n}",
    "instruction": {
      "en": "Write a Shell function `process_array() {\nlocal nums=($1)` to solve the following problem:\n\nPerform operations on an array to remove pairs of equal integers.\nReturns a two-element array: [number of pairs formed, number of remaining integers].\n>>> process_array \"3 1 2 3 2\"\n2 1\n>>> process_array \"1 2 3 4\"\n0 4\n",
      "sq": "Shkruani një funksion Shell `process_array() {\nlocal nums=($1)` për të zgjidhur problemin e mëposhtëm:\n\nKryeni operacione në një varg për të hequr çiftet e numrave të barabartë.\nKthen një varg me dy elementë: [numri i çifteve të formuara, numri i numrave të mbetur].\n>>> process_array \"3 1 2 3 2\"\n2 1\n>>> process_array \"1 2 3 4\"\n0 4",
      "hy": "Գրեք Shell ֆունկցիա `process_array() {\nlocal nums=($1)` հետևյալ խնդիրը լուծելու համար:\n\nԿատարել գործողություններ զանգվածի վրա՝ հեռացնելու հավասար ամբողջ թվերի զույգերը։ Վերադարձնում է երկու տարրից բաղկացած զանգված՝ [կազմված զույգերի քանակը, մնացած ամբողջ թվերի քանակը]։\n>>> process_array \"3 1 2 3 2\"\n2 1\n>>> process_array \"1 2 3 4\"\n0 4",
      "bn": "একটি Shell ফাংশন লিখুন `process_array() {\nlocal nums=($1)` নিম্নলিখিত সমস্যার সমাধান করতে:\n\nএকটি অ্যারেতে অপারেশন সম্পাদন করুন যাতে সমান পূর্ণসংখ্যার জোড়া সরানো যায়।\nএকটি দুই-উপাদান অ্যারে ফেরত দেয়: [গঠিত জোড়ার সংখ্যা, অবশিষ্ট পূর্ণসংখ্যার সংখ্যা]।\n>>> process_array \"3 1 2 3 2\"\n2 1\n>>> process_array \"1 2 3 4\"\n0 4",
      "bg": "Напишете Shell функция `process_array() {\nlocal nums=($1)` за решаване на следния проблем:\n\nИзвършете операции върху масив, за да премахнете двойки от равни цели числа.\nВръща масив с два елемента: [брой на формираните двойки, брой на останалите цели числа].\n>>> process_array \"3 1 2 3 2\"\n2 1\n>>> process_array \"1 2 3 4\"\n0 4",
      "zh": "编写一个 Shell 函数 `process_array() {\nlocal nums=($1)` 来解决以下问题：\n\n对数组进行操作以移除成对的相等整数。\n返回一个两元素数组：[形成的对数，剩余整数的数量]。\n>>> process_array \"3 1 2 3 2\"\n2 1\n>>> process_array \"1 2 3 4\"\n0 4",
      "fr": "Écrire une fonction Shell `process_array() {\nlocal nums=($1)` pour résoudre le problème suivant :\n\nEffectuer des opérations sur un tableau pour supprimer des paires d'entiers égaux.\nRenvoie un tableau à deux éléments : [nombre de paires formées, nombre d'entiers restants].\n>>> process_array \"3 1 2 3 2\"\n2 1\n>>> process_array \"1 2 3 4\"\n0 4",
      "de": "Schreiben Sie eine Shell-Funktion `process_array() {\nlocal nums=($1)` um das folgende Problem zu lösen:\n\nFühren Sie Operationen an einem Array durch, um Paare von gleichen ganzen Zahlen zu entfernen.\nGibt ein zwei-elementiges Array zurück: [Anzahl der gebildeten Paare, Anzahl der verbleibenden ganzen Zahlen].\n>>> process_array \"3 1 2 3 2\"\n2 1\n>>> process_array \"1 2 3 4\"\n0 4",
      "ha": "Rubuta aikin Shell `process_array() { local nums=($1)` don warware matsalar mai zuwa:\n\nYi ayyuka akan wani tsari don cire ma'aurata na lambobi masu daidaito.\nYa dawo da tsari mai abubuwa biyu: [yawan ma'aurata da aka kafa, yawan lambobi da suka rage].\n>>> process_array \"3 1 2 3 2\"\n2 1\n>>> process_array \"1 2 3 4\"\n0 4",
      "hi": "`process_array() { local nums=($1)` निम्नलिखित समस्या को हल करने के लिए:\n\nएक array पर संचालन करें ताकि समान पूर्णांकों के जोड़े हटा दिए जाएं। एक दो-तत्वों वाला array लौटाता है: [बने जोड़ों की संख्या, शेष पूर्णांकों की संख्या]। \n>>> process_array \"3 1 2 3 2\"\n2 1\n>>> process_array \"1 2 3 4\"\n0 4",
      "hu": "Írj egy Shell függvényt `process_array() {\nlocal nums=($1)` a következő probléma megoldására:\n\nVégezz műveleteket egy tömbön, hogy eltávolítsd az egyenlő egész számok párosait.\nEgy két elemből álló tömböt ad vissza: [a képzett párok száma, a megmaradt egész számok száma].\n>>> process_array \"3 1 2 3 2\"\n2 1\n>>> process_array \"1 2 3 4\"\n0 4"
    },
    "instruction_bertscore": {
      "sq": "0.9783457131203386",
      "hy": "0.9700999701124372",
      "bn": "0.9987502176425285",
      "bg": "0.9918039145873574",
      "zh": "0.9875748751447436",
      "fr": "0.9987502176425285",
      "de": "0.9890360002276363",
      "ha": "0.9703772581243619",
      "hi": "0.9567623372867066",
      "hu": "0.9878452110933321"
    },
    "level": "easy",
    "test": "# Testing function\ntest_process_array() {\n[[ $(process_array \"3 1 2 3 2\") == \"2 1\" ]] || { echo \"Test 1 failed\"; exit 1; }\n[[ $(process_array \"1 2 3 4\") == \"0 4\" ]] || { echo \"Test 2 failed\"; exit 1; }\n[[ $(process_array \"5 5 5 5 5\") == \"2 1\" ]] || { echo \"Test 3 failed\"; exit 1; }\n[[ $(process_array \"1 1 2 2 3 3 4 4\") == \"4 0\" ]] || { echo \"Test 4 failed\"; exit 1; }\n[[ $(process_array \"1\") == \"0 1\" ]] || { echo \"Test 5 failed\"; exit 1; }\n[[ $(process_array \"\") == \"0 0\" ]] || { echo \"Test 6 failed\"; exit 1; }\n[[ $(process_array \"2 2 2 2 3 3 3\") == \"3 1\" ]] || { echo \"Test 7 failed\"; exit 1; }\n}\n\ntest_process_array",
    "entry_point": "process_array",
    "signature": "process_array() {\nlocal nums=($1)",
    "docstring": {
      "en": "\nPerform operations on an array to remove pairs of equal integers.\nReturns a two-element array: [number of pairs formed, number of remaining integers].\n>>> process_array \"3 1 2 3 2\"\n2 1\n>>> process_array \"1 2 3 4\"\n0 4\n",
      "sq": "Kryen operacione në një varg për të hequr çiftet e numrave të barabartë.\nKthen një varg me dy elemente: [numri i çifteve të formuara, numri i numrave të mbetur].\n>>> process_array \"3 1 2 3 2\"\n2 1\n>>> process_array \"1 2 3 4\"\n0 4",
      "hy": "Կատարել գործողություններ զանգվածի վրա՝ հավասար ամբողջ թվերի զույգերը հեռացնելու համար։ Վերադարձնում է երկու տարրից բաղկացած զանգված՝ [ձևավորված զույգերի քանակը, մնացած ամբողջ թվերի քանակը]։\n>>> process_array \"3 1 2 3 2\"\n2 1\n>>> process_array \"1 2 3 4\"\n0 4",
      "bn": "অ্যারের উপর অপারেশন সম্পাদন করে সমান পূর্ণসংখ্যার জোড়া অপসারণ করুন। \nএকটি দুই-উপাদান বিশিষ্ট অ্যারে ফেরত দেয়: [গঠিত জোড়ার সংখ্যা, অবশিষ্ট পূর্ণসংখ্যার সংখ্যা]।\n>>> process_array \"3 1 2 3 2\"\n2 1\n>>> process_array \"1 2 3 4\"\n0 4",
      "bg": "Извършва операции върху масив, за да премахне двойки от равни цели числа.  \nВръща масив с два елемента: [брой на формираните двойки, брой на останалите цели числа].  \n>>> process_array \"3 1 2 3 2\"  \n2 1  \n>>> process_array \"1 2 3 4\"  \n0 4  ",
      "zh": "对数组执行操作以移除成对的相等整数。  \n返回一个包含两个元素的数组：[形成的对数，剩余整数的数量]。  \n>>> process_array \"3 1 2 3 2\"  \n2 1  \n>>> process_array \"1 2 3 4\"  \n0 4  ",
      "fr": "Effectuer des opérations sur un tableau pour supprimer des paires d'entiers égaux.  \nRenvoie un tableau à deux éléments : [nombre de paires formées, nombre d'entiers restants].  \n>>> process_array \"3 1 2 3 2\"  \n2 1  \n>>> process_array \"1 2 3 4\"  \n0 4  ",
      "de": "Führen Sie Operationen an einem Array durch, um Paare von gleichen ganzen Zahlen zu entfernen. Gibt ein zwei-elementiges Array zurück: [Anzahl der gebildeten Paare, Anzahl der verbleibenden ganzen Zahlen].\n>>> process_array \"3 1 2 3 2\"\n2 1\n>>> process_array \"1 2 3 4\"\n0 4",
      "ha": "Ai aiki akan wani tsari don cire ma'aurata na lambobi masu daidaituwa.  \nYa dawo da tsari mai abubuwa biyu: [yawan ma'aurata da aka kafa, yawan lambobin da suka rage].  \n>>> process_array \"3 1 2 3 2\"  \n2 1  \n>>> process_array \"1 2 3 4\"  \n0 4  ",
      "hi": "समान पूर्णांकों के जोड़ों को हटाने के लिए एक array पर संचालन करें। एक दो-तत्वों वाली array लौटाता है: [बने हुए जोड़ों की संख्या, शेष पूर्णांकों की संख्या]।\n>>> process_array \"3 1 2 3 2\"\n2 1\n>>> process_array \"1 2 3 4\"\n0 4",
      "hu": "Végezzen műveleteket egy tömbön az egyenlő egész számok párjainak eltávolítására.\nEgy két elemből álló tömböt ad vissza: [a képzett párok száma, a megmaradt egész számok száma].\n>>> process_array \"3 1 2 3 2\"\n2 1\n>>> process_array \"1 2 3 4\"\n0 4"
    },
    "docstring_bertscore": {
      "sq": "0.9550545132705686",
      "hy": "0.9761407172604702",
      "bn": "0.9957512961496637",
      "bg": "0.9712480537148189",
      "zh": "0.9805111815343809",
      "fr": "0.9999996027392379",
      "de": "0.9936033072091525",
      "ha": "0.9217726025155059",
      "hi": "0.9758964018917974",
      "hu": "0.9755043055196345"
    }
  },
  {
    "task_id": "Shell/6",
    "prompt": {
      "en": "#!/bin/bash\n\n# Evaluate poker hands based on given ranks and suits.\n# The function takes two strings: one for ranks and one for suits, each value separated by spaces.\n# Returns the best hand type: \"Flush\", \"Three of a Kind\", \"Pair\", or \"High Card\".\n# >>> evaluate_hand \"2 3 4 5 6\" \"H H H H H\"\n# Flush\n# >>> evaluate_hand \"4 4 4 7 8\" \"H D S C H\"\n# Three of a Kind\nevaluate_hand() {\nlocal ranks=($1)\nlocal suits=($2)",
      "sq": "#!/bin/bash\n\n# Vlerësoni duart e pokerit bazuar në renditjet dhe ngjyrat e dhëna.\n# Funksioni merr dy vargje: një për renditjet dhe një për ngjyrat, secila vlerë e ndarë me hapësira.\n# Kthen llojin më të mirë të dorës: \"Flush\", \"Three of a Kind\", \"Pair\", ose \"High Card\".\n# >>> evaluate_hand \"2 3 4 5 6\" \"H H H H H\"\n# Flush\n# >>> evaluate_hand \"4 4 4 7 8\" \"H D S C H\"\n# Three of a Kind\nevaluate_hand() {\nlocal ranks=($1)\nlocal suits=($2)",
      "hy": "#!/bin/bash\n\n# Գնահատել պոկերի ձեռքերն ըստ տրված վարկանիշների և սյուտերի։\n# Ֆունկցիան ընդունում է երկու տող՝ մեկը վարկանիշների համար և մեկը սյուտերի համար, յուրաքանչյուր արժեքը բաժանված է բացատներով։\n# Վերադարձնում է լավագույն ձեռքի տեսակը՝ \"Flush\", \"Three of a Kind\", \"Pair\" կամ \"High Card\"։\n# >>> evaluate_hand \"2 3 4 5 6\" \"H H H H H\"\n# Flush\n# >>> evaluate_hand \"4 4 4 7 8\" \"H D S C H\"\n# Three of a Kind\nevaluate_hand() {\nlocal ranks=($1)\nlocal suits=($2)",
      "bn": "#!/bin/bash\n\n# প্রদত্ত র‍্যাঙ্ক এবং স্যুটের ভিত্তিতে পোকার হাত মূল্যায়ন করুন।\n# ফাংশনটি দুটি স্ট্রিং নেয়: একটি র‍্যাঙ্কের জন্য এবং একটি স্যুটের জন্য, প্রতিটি মান স্পেস দ্বারা পৃথক।\n# সেরা হাতের ধরন ফেরত দেয়: \"Flush\", \"Three of a Kind\", \"Pair\", বা \"High Card\"।\n# >>> evaluate_hand \"2 3 4 5 6\" \"H H H H H\"\n# Flush\n# >>> evaluate_hand \"4 4 4 7 8\" \"H D S C H\"\n# Three of a Kind\nevaluate_hand() {\nlocal ranks=($1)\nlocal suits=($2)",
      "bg": "#!/bin/bash\n\n# Оценява покер ръце на базата на дадени рангове и бои.\n# Функцията приема два низа: един за ранговете и един за боите, като всяка стойност е разделена с интервали.\n# Връща най-добрия тип ръка: \"Flush\", \"Three of a Kind\", \"Pair\" или \"High Card\".\n# >>> evaluate_hand \"2 3 4 5 6\" \"H H H H H\"\n# Flush\n# >>> evaluate_hand \"4 4 4 7 8\" \"H D S C H\"\n# Three of a Kind\nevaluate_hand() {\nlocal ranks=($1)\nlocal suits=($2)",
      "zh": "#!/bin/bash\n\n# 根据给定的点数和花色评估扑克牌手牌。\n# 该函数接受两个字符串：一个表示点数，一个表示花色，每个值用空格分隔。\n# 返回最佳手牌类型：\"Flush\"（同花），\"Three of a Kind\"（三条），\"Pair\"（对子），或 \"High Card\"（高牌）。\n# >>> evaluate_hand \"2 3 4 5 6\" \"H H H H H\"\n# Flush\n# >>> evaluate_hand \"4 4 4 7 8\" \"H D S C H\"\n# Three of a Kind\nevaluate_hand() {\nlocal ranks=($1)\nlocal suits=($2)",
      "fr": "#!/bin/bash\n\n# Évaluer les mains de poker en fonction des rangs et des couleurs donnés.\n# La fonction prend deux chaînes : une pour les rangs et une pour les couleurs, chaque valeur étant séparée par des espaces.\n# Retourne le meilleur type de main : \"Flush\", \"Brelan\", \"Paire\" ou \"Carte haute\".\n# >>> evaluate_hand \"2 3 4 5 6\" \"H H H H H\"\n# Flush\n# >>> evaluate_hand \"4 4 4 7 8\" \"H D S C H\"\n# Brelan\nevaluate_hand() {\nlocal ranks=($1)\nlocal suits=($2)",
      "de": "#!/bin/bash\n\n# Pokerhände basierend auf gegebenen Rängen und Farben bewerten.\n# Die Funktion nimmt zwei Zeichenfolgen: eine für Ränge und eine für Farben, wobei jeder Wert durch Leerzeichen getrennt ist.\n# Gibt den besten Handtyp zurück: \"Flush\", \"Three of a Kind\", \"Pair\" oder \"High Card\".\n# >>> evaluate_hand \"2 3 4 5 6\" \"H H H H H\"\n# Flush\n# >>> evaluate_hand \"4 4 4 7 8\" \"H D S C H\"\n# Three of a Kind\nevaluate_hand() {\nlocal ranks=($1)\nlocal suits=($2)",
      "ha": "#!/bin/bash\n\n# Kimanta hannun poker bisa ga matsayi da nau'in katin da aka bayar.\n# Aikin yana ɗaukar kirtani guda biyu: ɗaya don matsayi da ɗaya don nau'in katin, kowanne darajar an raba ta da sarari.\n# Yana mayar da mafi kyawun nau'in hannu: \"Flush\", \"Three of a Kind\", \"Pair\", ko \"High Card\".\n# >>> evaluate_hand \"2 3 4 5 6\" \"H H H H H\"\n# Flush\n# >>> evaluate_hand \"4 4 4 7 8\" \"H D S C H\"\n# Three of a Kind\nevaluate_hand() {\nlocal ranks=($1)\nlocal suits=($2)",
      "hi": "#!/bin/bash\n\n# दिए गए रैंक्स और सूट्स के आधार पर पोकर हाथों का मूल्यांकन करें।\n# यह फ़ंक्शन दो स्ट्रिंग्स लेता है: एक रैंक्स के लिए और एक सूट्स के लिए, प्रत्येक मान को स्पेस से अलग किया गया है।\n# सबसे अच्छे हाथ के प्रकार को लौटाता है: \"Flush\", \"Three of a Kind\", \"Pair\", या \"High Card\"।\n# >>> evaluate_hand \"2 3 4 5 6\" \"H H H H H\"\n# Flush\n# >>> evaluate_hand \"4 4 4 7 8\" \"H D S C H\"\n# Three of a Kind\nevaluate_hand() {\nlocal ranks=($1)\nlocal suits=($2)",
      "hu": "#!/bin/bash\n\n# Póker kezek értékelése a megadott rangok és színek alapján.\n# A függvény két karakterláncot vesz át: egyet a rangokhoz és egyet a színekhez, minden érték szóközzel elválasztva.\n# Visszaadja a legjobb kéztípust: \"Flush\", \"Three of a Kind\", \"Pair\", vagy \"High Card\".\n# >>> evaluate_hand \"2 3 4 5 6\" \"H H H H H\"\n# Flush\n# >>> evaluate_hand \"4 4 4 7 8\" \"H D S C H\"\n# Three of a Kind\nevaluate_hand() {\nlocal ranks=($1)\nlocal suits=($2)"
    },
    "prompt_bertscore": {
      "sq": "0.9850657761715109",
      "hy": "0.9938363006461064",
      "bn": "0.9887201779217908",
      "bg": "0.9846119057508462",
      "zh": "0.9767258823629991",
      "fr": "0.9779476578367446",
      "de": "0.9874429845717364",
      "ha": "0.9527142501212156",
      "hi": "0.9743746945426891",
      "hu": "0.9819192723055372"
    },
    "canonical_solution": "local -A rank_count\nlocal -A suit_count\nlocal max_rank_count=0\nlocal max_suit_count=0\n\nfor i in ${ranks[@]}; do\n((rank_count[$i]++))\nmax_rank_count=$((max_rank_count < rank_count[$i] ? rank_count[$i] : max_rank_count))\ndone\n\nfor i in ${suits[@]}; do\n((suit_count[$i]++))\nmax_suit_count=$((max_suit_count < suit_count[$i] ? suit_count[$i] : max_suit_count))\ndone\n\nif (( max_suit_count == 5 )); then\necho \"Flush\"\nelif (( max_rank_count == 3 || max_rank_count == 4)); then\necho \"Three of a Kind\"\nelif (( max_rank_count == 2 )); then\necho \"Pair\"\nelse\necho \"High Card\"\nfi\n}\n\n# Testing function\ntest_evaluate_hand() {\n[[ $(evaluate_hand \"2 3 4 5 6\" \"H H H H H\") == \"Flush\" ]] || { echo \"Test 1 failed\"; exit 1; }\n[[ $(evaluate_hand \"4 4 4 7 8\" \"H D S C H\") == \"Three of a Kind\" ]] || { echo \"Test 2 failed\"; exit 1; }\n[[ $(evaluate_hand \"5 5 9 10 J\" \"C D H S D\") == \"Pair\" ]] || { echo \"Test 3 failed\"; exit 1; }\n[[ $(evaluate_hand \"2 3 5 8 K\" \"C D H S D\") == \"High Card\" ]] || { echo \"Test 4 failed\"; exit 1; }\n[[ $(evaluate_hand \"9 9 9 9 8\" \"H D S C H\") == \"Three of a Kind\" ]] || { echo \"Test 5 failed\"; exit 1; }\n[[ $(evaluate_hand \"A K Q J 10\" \"H H C D S\") == \"High Card\" ]] || { echo \"Test 6 failed\"; exit 1; }\n[[ $(evaluate_hand \"3 3 6 6 K\" \"H D S C H\") == \"Pair\" ]] || { echo \"Test 7 failed\"; exit 1; }\n}\n\ntest_evaluate_hand",
    "instruction": {
      "en": "Write a Shell function `evaluate_hand() {\nlocal ranks=($1)\nlocal suits=($2)` to solve the following problem:\n\nEvaluate poker hands based on given ranks and suits.\nThe function takes two strings: one for ranks and one for suits, each value separated by spaces.\nReturns the best hand type: \"Flush\", \"Three of a Kind\", \"Pair\", or \"High Card\".\n>>> evaluate_hand \"2 3 4 5 6\" \"H H H H H\"\nFlush\n>>> evaluate_hand \"4 4 4 7 8\" \"H D S C H\"\nThree of a Kind\n",
      "sq": "Shkruani një funksion Shell `evaluate_hand() {\nlocal ranks=($1)\nlocal suits=($2)` për të zgjidhur problemin e mëposhtëm:\n\nVlerësoni duart e pokerit bazuar në renditjet dhe simbolet e dhëna.\nFunksioni merr dy vargje: një për renditjet dhe një për simbolet, secila vlerë e ndarë me hapësira.\nKthen llojin më të mirë të dorës: \"Flush\", \"Three of a Kind\", \"Pair\", ose \"High Card\".\n>>> evaluate_hand \"2 3 4 5 6\" \"H H H H H\"\nFlush\n>>> evaluate_hand \"4 4 4 7 8\" \"H D S C H\"\nThree of a Kind",
      "hy": "Գրեք Shell ֆունկցիա `evaluate_hand() {\nlocal ranks=($1)\nlocal suits=($2)` հետևյալ խնդիրը լուծելու համար:\n\nԳնահատել պոկերի ձեռքերն ըստ տրված արժեքների և գույների:\nՖունկցիան ընդունում է երկու տող՝ մեկը արժեքների համար և մեկը գույների համար, յուրաքանչյուր արժեքը բաժանված է բացատներով:\nՎերադարձնում է լավագույն ձեռքի տեսակը՝ \"Flush\", \"Three of a Kind\", \"Pair\" կամ \"High Card\":\n>>> evaluate_hand \"2 3 4 5 6\" \"H H H H H\"\nFlush\n>>> evaluate_hand \"4 4 4 7 8\" \"H D S C H\"\nThree of a Kind",
      "bn": "একটি Shell ফাংশন লিখুন `evaluate_hand() {\nlocal ranks=($1)\nlocal suits=($2)` নিম্নলিখিত সমস্যার সমাধানের জন্য:\n\nপ্রদত্ত র‍্যাঙ্ক এবং স্যুটের ভিত্তিতে পোকার হাত মূল্যায়ন করুন। \nফাংশনটি দুটি স্ট্রিং নেয়: একটি র‍্যাঙ্কের জন্য এবং একটি স্যুটের জন্য, প্রতিটি মান স্পেস দ্বারা পৃথক। \nসেরা হাতের ধরন ফেরত দেয়: \"Flush\", \"Three of a Kind\", \"Pair\", বা \"High Card\"।\n>>> evaluate_hand \"2 3 4 5 6\" \"H H H H H\"\nFlush\n>>> evaluate_hand \"4 4 4 7 8\" \"H D S C H\"\nThree of a Kind",
      "bg": "Напишете Shell функция `evaluate_hand() {\nlocal ranks=($1)\nlocal suits=($2)` за решаване на следния проблем:\n\nОценете покер ръце на базата на дадени стойности и бои.\nФункцията приема два низа: един за стойности и един за бои, всяка стойност разделена с интервали.\nВръща най-добрия тип ръка: \"Flush\", \"Three of a Kind\", \"Pair\" или \"High Card\".\n>>> evaluate_hand \"2 3 4 5 6\" \"H H H H H\"\nFlush\n>>> evaluate_hand \"4 4 4 7 8\" \"H D S C H\"\nThree of a Kind",
      "zh": "编写一个 Shell 函数 `evaluate_hand() {\nlocal ranks=($1)\nlocal suits=($2)` 来解决以下问题：\n\n根据给定的牌面和花色评估扑克牌手牌。\n该函数接收两个字符串：一个表示牌面，一个表示花色，每个值用空格分隔。\n返回最佳手牌类型：\"Flush\"（同花），\"Three of a Kind\"（三条），\"Pair\"（对子），或 \"High Card\"（高牌）。\n>>> evaluate_hand \"2 3 4 5 6\" \"H H H H H\"\nFlush\n>>> evaluate_hand \"4 4 4 7 8\" \"H D S C H\"\nThree of a Kind",
      "fr": "Écrire une fonction Shell `evaluate_hand() {\nlocal ranks=($1)\nlocal suits=($2)` pour résoudre le problème suivant :\n\nÉvaluer les mains de poker en fonction des rangs et des couleurs donnés.  \nLa fonction prend deux chaînes : une pour les rangs et une pour les couleurs, chaque valeur étant séparée par des espaces.  \nRetourne le meilleur type de main : \"Flush\", \"Three of a Kind\", \"Pair\", ou \"High Card\".  \n>>> evaluate_hand \"2 3 4 5 6\" \"H H H H H\"  \nFlush  \n>>> evaluate_hand \"4 4 4 7 8\" \"H D S C H\"  \nThree of a Kind  ",
      "de": "Schreiben Sie eine Shell-Funktion `evaluate_hand() {\nlocal ranks=($1)\nlocal suits=($2)` um das folgende Problem zu lösen:\n\nBewerten Sie Pokerhände basierend auf gegebenen Rängen und Farben.\nDie Funktion nimmt zwei Zeichenfolgen: eine für die Ränge und eine für die Farben, wobei jeder Wert durch Leerzeichen getrennt ist.\nGibt den besten Handtyp zurück: \"Flush\", \"Three of a Kind\", \"Pair\" oder \"High Card\".\n>>> evaluate_hand \"2 3 4 5 6\" \"H H H H H\"\nFlush\n>>> evaluate_hand \"4 4 4 7 8\" \"H D S C H\"\nThree of a Kind",
      "ha": "Rubuta aikin Shell `evaluate_hand() {\nlocal ranks=($1)\nlocal suits=($2)` don magance matsalar mai zuwa:\n\nKimanta hannun karta bisa ga matsayi da nau'i da aka bayar.\nAikin yana ɗaukar kirtani biyu: ɗaya don matsayi da ɗaya don nau'i, kowanne darajar an raba shi da sarari.\nYana mayar da mafi kyawun nau'in hannu: \"Flush\", \"Three of a Kind\", \"Pair\", ko \"High Card\".\n>>> evaluate_hand \"2 3 4 5 6\" \"H H H H H\"\nFlush\n>>> evaluate_hand \"4 4 4 7 8\" \"H D S C H\"\nThree of a Kind",
      "hi": "Write a Shell function `evaluate_hand() {\nlocal ranks=($1)\nlocal suits=($2)` निम्नलिखित समस्या को हल करने के लिए:\n\nदिए गए रैंक और सूट के आधार पर पोकर हाथों का मूल्यांकन करें।\nयह फ़ंक्शन दो स्ट्रिंग लेता है: एक रैंक के लिए और एक सूट के लिए, प्रत्येक मान को स्पेस द्वारा अलग किया गया है।\nसर्वश्रेष्ठ हाथ प्रकार लौटाता है: \"Flush\", \"Three of a Kind\", \"Pair\", या \"High Card\"।\n>>> evaluate_hand \"2 3 4 5 6\" \"H H H H H\"\nFlush\n>>> evaluate_hand \"4 4 4 7 8\" \"H D S C H\"\nThree of a Kind",
      "hu": "Írj egy Shell függvényt `evaluate_hand() {\nlocal ranks=($1)\nlocal suits=($2)` a következő probléma megoldására:\n\nÉrtékelje a pókerkezeket a megadott rangok és színek alapján.\nA függvény két karakterláncot vesz át: az egyik a rangoknak, a másik a színeknek, mindegyik érték szóközzel elválasztva.\nVisszaadja a legjobb kéztípust: \"Flush\", \"Three of a Kind\", \"Pair\", vagy \"High Card\".\n>>> evaluate_hand \"2 3 4 5 6\" \"H H H H H\"\nFlush\n>>> evaluate_hand \"4 4 4 7 8\" \"H D S C H\"\nThree of a Kind"
    },
    "instruction_bertscore": {
      "sq": "0.9875051558810004",
      "hy": "0.9791614880952488",
      "bn": "0.9850729268652282",
      "bg": "0.9811307096928287",
      "zh": "0.9707175119670747",
      "fr": "0.9816735665241971",
      "de": "0.9824804031319608",
      "ha": "0.970576285766159",
      "hi": "0.9858400373967849",
      "hu": "0.9832933972815366"
    },
    "level": "hard",
    "test": "# Testing function\ntest_evaluate_hand() {\n[[ $(evaluate_hand \"2 3 4 5 6\" \"H H H H H\") == \"Flush\" ]] || { echo \"Test 1 failed\"; exit 1; }\n[[ $(evaluate_hand \"4 4 4 7 8\" \"H D S C H\") == \"Three of a Kind\" ]] || { echo \"Test 2 failed\"; exit 1; }\n[[ $(evaluate_hand \"5 5 9 10 J\" \"C D H S D\") == \"Pair\" ]] || { echo \"Test 3 failed\"; exit 1; }\n[[ $(evaluate_hand \"2 3 5 8 K\" \"C D H S D\") == \"High Card\" ]] || { echo \"Test 4 failed\"; exit 1; }\n[[ $(evaluate_hand \"9 9 9 9 8\" \"H D S C H\") == \"Three of a Kind\" ]] || { echo \"Test 5 failed\"; exit 1; }\n[[ $(evaluate_hand \"A K Q J 10\" \"H H C D S\") == \"High Card\" ]] || { echo \"Test 6 failed\"; exit 1; }\n[[ $(evaluate_hand \"3 3 6 6 K\" \"H D S C H\") == \"Pair\" ]] || { echo \"Test 7 failed\"; exit 1; }\n}\n\ntest_evaluate_hand",
    "entry_point": "evaluate_hand",
    "signature": "evaluate_hand() {\nlocal ranks=($1)\nlocal suits=($2)",
    "docstring": {
      "en": "\nEvaluate poker hands based on given ranks and suits.\nThe function takes two strings: one for ranks and one for suits, each value separated by spaces.\nReturns the best hand type: \"Flush\", \"Three of a Kind\", \"Pair\", or \"High Card\".\n>>> evaluate_hand \"2 3 4 5 6\" \"H H H H H\"\nFlush\n>>> evaluate_hand \"4 4 4 7 8\" \"H D S C H\"\nThree of a Kind\n",
      "sq": "Vlerësoni duart e pokerit bazuar në rangjet dhe ngjyrat e dhëna.\nFunksioni merr dy vargje: një për rangjet dhe një për ngjyrat, secili vlerë i ndarë me hapësira.\nKthen llojin më të mirë të dorës: \"Flush\", \"Three of a Kind\", \"Pair\", ose \"High Card\".\n>>> evaluate_hand \"2 3 4 5 6\" \"H H H H H\"\nFlush\n>>> evaluate_hand \"4 4 4 7 8\" \"H D S C H\"\nThree of a Kind",
      "hy": "Գնահատել պոկերի ձեռքերն ըստ տրված արժեքների և սյուտերի:\nՖունկցիան ընդունում է երկու տող՝ մեկը արժեքների համար և մեկը սյուտերի, յուրաքանչյուր արժեքը բաժանված է բացատներով:\nՎերադարձնում է լավագույն ձեռքի տեսակը՝ \"Flush\", \"Three of a Kind\", \"Pair\" կամ \"High Card\":\n>>> evaluate_hand \"2 3 4 5 6\" \"H H H H H\"\nFlush\n>>> evaluate_hand \"4 4 4 7 8\" \"H D S C H\"\nThree of a Kind",
      "bn": "প্রদত্ত র‍্যাঙ্ক এবং স্যুটের উপর ভিত্তি করে পোকার হাত মূল্যায়ন করুন। \nফাংশনটি দুটি স্ট্রিং নেয়: একটি র‍্যাঙ্কের জন্য এবং একটি স্যুটের জন্য, প্রতিটি মান স্পেস দ্বারা পৃথক করা হয়। \nসেরা হাতের ধরন ফেরত দেয়: \"Flush\", \"Three of a Kind\", \"Pair\", অথবা \"High Card\"। \n>>> evaluate_hand \"2 3 4 5 6\" \"H H H H H\"\nFlush\n>>> evaluate_hand \"4 4 4 7 8\" \"H D S C H\"\nThree of a Kind",
      "bg": "Оценете покер ръце въз основа на дадени рангове и бои.  \nФункцията приема два низа: един за ранговете и един за боите, като всяка стойност е разделена с интервали.  \nВръща най-добрия тип ръка: \"Flush\", \"Three of a Kind\", \"Pair\" или \"High Card\".  \n>>> evaluate_hand \"2 3 4 5 6\" \"H H H H H\"  \nFlush  \n>>> evaluate_hand \"4 4 4 7 8\" \"H D S C H\"  \nThree of a Kind  ",
      "zh": "根据给定的牌面和花色评估扑克牌手牌。\n该函数接收两个字符串：一个表示牌面，一个表示花色，每个值用空格分隔。\n返回最佳手牌类型：\"Flush\"（同花顺）、\"Three of a Kind\"（三条）、\"Pair\"（对子）或 \"High Card\"（高牌）。\n>>> evaluate_hand \"2 3 4 5 6\" \"H H H H H\"\nFlush\n>>> evaluate_hand \"4 4 4 7 8\" \"H D S C H\"\nThree of a Kind",
      "fr": "Évaluer les mains de poker en fonction des rangs et des couleurs donnés.\nLa fonction prend deux chaînes de caractères : une pour les rangs et une pour les couleurs, chaque valeur étant séparée par des espaces.\nRenvoie le meilleur type de main : \"Flush\", \"Brelan\", \"Paire\" ou \"Carte Haute\".\n>>> evaluate_hand \"2 3 4 5 6\" \"H H H H H\"\nFlush\n>>> evaluate_hand \"4 4 4 7 8\" \"H D S C H\"\nBrelan",
      "de": "Bewerten Sie Pokerhände basierend auf gegebenen Rängen und Farben.\nDie Funktion nimmt zwei Zeichenfolgen: eine für die Ränge und eine für die Farben, wobei jeder Wert durch Leerzeichen getrennt ist.\nGibt den besten Handtyp zurück: \"Flush\", \"Drilling\", \"Paar\" oder \"Hohe Karte\".\n>>> evaluate_hand \"2 3 4 5 6\" \"H H H H H\"\nFlush\n>>> evaluate_hand \"4 4 4 7 8\" \"H D S C H\"\nDrilling",
      "ha": "Kimanta hannun poker bisa ga matsayi da nau'in da aka bayar.\nAikin yana ɗaukar kirtani guda biyu: ɗaya don matsayi da ɗaya don nau'in, kowanne darajar an raba shi da sarari.\nYana dawo da mafi kyawun nau'in hannu: \"Flush\", \"Three of a Kind\", \"Pair\", ko \"High Card\".\n>>> evaluate_hand \"2 3 4 5 6\" \"H H H H H\"\nFlush\n>>> evaluate_hand \"4 4 4 7 8\" \"H D S C H\"\nThree of a Kind",
      "hi": "दिए गए रैंक्स और सूट्स के आधार पर पोकर हाथों का मूल्यांकन करें।\nयह फ़ंक्शन दो स्ट्रिंग्स लेता है: एक रैंक्स के लिए और एक सूट्स के लिए, प्रत्येक मान स्पेस द्वारा अलग किया गया है।\nसर्वश्रेष्ठ हाथ प्रकार लौटाता है: \"Flush\", \"Three of a Kind\", \"Pair\", या \"High Card\"।\n>>> evaluate_hand \"2 3 4 5 6\" \"H H H H H\"\nFlush\n>>> evaluate_hand \"4 4 4 7 8\" \"H D S C H\"\nThree of a Kind",
      "hu": "Értékeli a pókerkezeket a megadott rangok és színek alapján.\nA függvény két karakterláncot vesz fel: egyet a rangok és egyet a színek számára, minden érték szóközzel elválasztva.\nVisszaadja a legjobb kéztípust: \"Flush\", \"Three of a Kind\", \"Pair\" vagy \"High Card\".\n>>> evaluate_hand \"2 3 4 5 6\" \"H H H H H\"\nFlush\n>>> evaluate_hand \"4 4 4 7 8\" \"H D S C H\"\nThree of a Kind"
    },
    "docstring_bertscore": {
      "sq": "0.9776729520197734",
      "hy": "0.9757438537591625",
      "bn": "0.9679871387493691",
      "bg": "0.9849589130265142",
      "zh": "0.963335215225532",
      "fr": "0.9744706330167289",
      "de": "0.9849589130265142",
      "ha": "0.963226564407106",
      "hi": "0.98363186345082",
      "hu": "0.9736592279102014"
    }
  },
  {
    "task_id": "Shell/7",
    "prompt": {
      "en": "#!/bin/bash\n\n# Calculate the minimum number of operations to reduce all elements of an array to zero.\n# Each operation consists of subtracting a positive integer x (less than or equal to the smallest non-zero element) from each positive element in the array.\n# The function takes a string representing the array, with elements separated by spaces.\n# Returns the minimum number of operations required.\n# >>> min_operations_to_zero \"3 3 2 2 1\"\n# 3\n# >>> min_operations_to_zero \"4 0 0 4\"\n# 1\nmin_operations_to_zero() {\nlocal nums=($1)",
      "sq": "#!/bin/bash\n\n# Llogarit numrin minimal të operacioneve për të reduktuar të gjitha elementet e një vargu në zero.\n# Çdo operacion përbëhet nga zbritja e një numri të plotë pozitiv x (më i vogël ose i barabartë me elementin më të vogël jo-zero) nga secili element pozitiv në varg.\n# Funksioni merr një varg që përfaqëson vargun, me elemente të ndara me hapësira.\n# Kthen numrin minimal të operacioneve të kërkuara.\n# >>> min_operations_to_zero \"3 3 2 2 1\"\n# 3\n# >>> min_operations_to_zero \"4 0 0 4\"\n# 1\nmin_operations_to_zero() {\nlocal nums=($1)",
      "hy": "#!/bin/bash\n\n# Հաշվել գործողությունների նվազագույն քանակը, որպեսզի զանգվածի բոլոր տարրերը հասցվեն զրոյի:\n# Յուրաքանչյուր գործողություն բաղկացած է դրական ամբողջ թիվ x (որը փոքր կամ հավասար է ամենափոքր ոչ զրո տարրին) հանելուց զանգվածի յուրաքանչյուր դրական տարրից:\n# Ֆունկցիան ընդունում է զանգվածը ներկայացնող տող, որտեղ տարրերը բաժանված են բացատներով:\n# Վերադարձնում է պահանջվող գործողությունների նվազագույն քանակը:\n# >>> min_operations_to_zero \"3 3 2 2 1\"\n# 3\n# >>> min_operations_to_zero \"4 0 0 4\"\n# 1\nmin_operations_to_zero() {\nlocal nums=($1)",
      "bn": "#!/bin/bash\n\n# একটি অ্যারের সমস্ত উপাদানকে শূন্যে কমানোর জন্য সর্বনিম্ন সংখ্যক অপারেশন গণনা করুন।\n# প্রতিটি অপারেশন একটি ধনাত্মক পূর্ণসংখ্যা x (যা সর্বনিম্ন অ-শূন্য উপাদানের সমান বা তার চেয়ে কম) প্রতিটি ধনাত্মক উপাদান থেকে বিয়োগ করা নিয়ে গঠিত।\n# ফাংশনটি একটি স্ট্রিং নেয় যা অ্যারের প্রতিনিধিত্ব করে, যেখানে উপাদানগুলি স্পেস দ্বারা পৃথক করা থাকে।\n# প্রয়োজনীয় সর্বনিম্ন সংখ্যক অপারেশন ফেরত দেয়।\n# >>> min_operations_to_zero \"3 3 2 2 1\"\n# 3\n# >>> min_operations_to_zero \"4 0 0 4\"\n# 1\nmin_operations_to_zero() {\nlocal nums=($1)",
      "bg": "#!/bin/bash\n\n# Изчислява минималния брой операции за намаляване на всички елементи на масив до нула.\n# Всяка операция се състои в изваждане на положително цяло число x (по-малко или равно на най-малкия ненулев елемент) от всеки положителен елемент в масива.\n# Функцията приема низ, представляващ масива, с елементи, разделени с интервали.\n# Връща минималния брой необходими операции.\n# >>> min_operations_to_zero \"3 3 2 2 1\"\n# 3\n# >>> min_operations_to_zero \"4 0 0 4\"\n# 1\nmin_operations_to_zero() {\nlocal nums=($1)",
      "zh": "#!/bin/bash\n\n# 计算将数组中所有元素减少到零的最小操作次数。\n# 每次操作包括从数组中的每个正元素中减去一个正整数 x（小于或等于最小的非零元素）。\n# 该函数接收一个表示数组的字符串，元素之间用空格分隔。\n# 返回所需的最小操作次数。\n# >>> min_operations_to_zero \"3 3 2 2 1\"\n# 3\n# >>> min_operations_to_zero \"4 0 0 4\"\n# 1\nmin_operations_to_zero() {\nlocal nums=($1)",
      "fr": "#!/bin/bash\n\n# Calculer le nombre minimum d'opérations pour réduire tous les éléments d'un tableau à zéro.\n# Chaque opération consiste à soustraire un entier positif x (inférieur ou égal au plus petit élément non nul) de chaque élément positif du tableau.\n# La fonction prend une chaîne représentant le tableau, avec des éléments séparés par des espaces.\n# Retourne le nombre minimum d'opérations requises.\n# >>> min_operations_to_zero \"3 3 2 2 1\"\n# 3\n# >>> min_operations_to_zero \"4 0 0 4\"\n# 1\nmin_operations_to_zero() {\nlocal nums=($1)",
      "de": "#!/bin/bash\n\n# Berechne die minimale Anzahl von Operationen, um alle Elemente eines Arrays auf null zu reduzieren.\n# Jede Operation besteht darin, eine positive ganze Zahl x (kleiner oder gleich dem kleinsten nicht-null Element) von jedem positiven Element im Array zu subtrahieren.\n# Die Funktion nimmt einen String, der das Array darstellt, mit durch Leerzeichen getrennten Elementen.\n# Gibt die minimale Anzahl der benötigten Operationen zurück.\n# >>> min_operations_to_zero \"3 3 2 2 1\"\n# 3\n# >>> min_operations_to_zero \"4 0 0 4\"\n# 1\nmin_operations_to_zero() {\nlocal nums=($1)",
      "ha": "#!/bin/bash\n\n# Lissafa mafi ƙarancin adadin ayyuka don rage dukkan abubuwan da ke cikin jerin zuwa sifili.\n# Kowanne aiki yana ƙunshe da cire wani adadi mai kyau x (wanda ya yi ƙasa da ko daidai da mafi ƙanƙanta wanda ba sifili ba) daga kowanne abu mai kyau a cikin jerin.\n# Aikin yana karɓar igiya da ke wakiltar jerin, tare da abubuwa da aka raba ta wurin sarari.\n# Yana mayar da mafi ƙarancin adadin ayyukan da ake buƙata.\n# >>> min_operations_to_zero \"3 3 2 2 1\"\n# 3\n# >>> min_operations_to_zero \"4 0 0 4\"\n# 1\nmin_operations_to_zero() {\nlocal nums=($1)",
      "hi": "#!/bin/bash\n\n# एक array के सभी तत्वों को शून्य तक घटाने के लिए न्यूनतम संचालन की संख्या की गणना करें।\n# प्रत्येक संचालन में array के प्रत्येक धनात्मक तत्व से एक धनात्मक पूर्णांक x (जो सबसे छोटे गैर-शून्य तत्व के बराबर या उससे कम हो) घटाना शामिल है।\n# यह फ़ंक्शन array का प्रतिनिधित्व करने वाले एक स्ट्रिंग को लेता है, जिसमें तत्व स्पेस द्वारा अलग किए गए होते हैं।\n# आवश्यक न्यूनतम संचालन की संख्या लौटाता है।\n# >>> min_operations_to_zero \"3 3 2 2 1\"\n# 3\n# >>> min_operations_to_zero \"4 0 0 4\"\n# 1\nmin_operations_to_zero() {\nlocal nums=($1)",
      "hu": "#!/bin/bash\n\n# Számítsa ki a minimális műveletek számát, hogy a tömb összes elemét nullára csökkentse.\n# Minden művelet abból áll, hogy kivonunk egy pozitív egész számot x (ami kisebb vagy egyenlő a legkisebb nem nulla elemmel) a tömb minden pozitív eleméből.\n# A függvény egy karakterláncot vesz fel, amely a tömböt reprezentálja, az elemek szóközzel elválasztva vannak.\n# Visszaadja a szükséges minimális műveletek számát.\n# >>> min_operations_to_zero \"3 3 2 2 1\"\n# 3\n# >>> min_operations_to_zero \"4 0 0 4\"\n# 1\nmin_operations_to_zero() {\nlocal nums=($1)"
    },
    "prompt_bertscore": {
      "sq": "0.9999996027392379",
      "hy": "0.9784136447106525",
      "bn": "0.9776769246273941",
      "bg": "0.9953002065543335",
      "zh": "0.9915971403607001",
      "fr": "0.9984316145113485",
      "de": "0.9990288960671204",
      "ha": "0.9633501125041096",
      "hi": "0.9781599937140709",
      "hu": "0.9861234829505217"
    },
    "canonical_solution": "local operations=0\nlocal min_non_zero=99999\n\n# Find the minimum non-zero element in the array\nfor num in ${nums[@]}; do\nif (( num > 0 && num < min_non_zero )); then\nmin_non_zero=$num\nfi\ndone\n\nwhile (( min_non_zero != 99999 )); do\n# Subtract min_non_zero from each element and count operation\nfor i in ${!nums[@]}; do\nif (( nums[i] > 0 )); then\nnums[i]=$(( nums[i] - min_non_zero ))\nfi\ndone\noperations=$((operations + 1))\n\n# Find new minimum non-zero element\nmin_non_zero=99999\nfor num in ${nums[@]}; do\nif (( num > 0 && num < min_non_zero )); then\nmin_non_zero=$num\nfi\ndone\ndone\n\necho $operations\n}",
    "instruction": {
      "en": "Write a Shell function `min_operations_to_zero() {\nlocal nums=($1)` to solve the following problem:\n\nCalculate the minimum number of operations to reduce all elements of an array to zero.\nEach operation consists of subtracting a positive integer x (less than or equal to the smallest non-zero element) from each positive element in the array.\nThe function takes a string representing the array, with elements separated by spaces.\nReturns the minimum number of operations required.\n>>> min_operations_to_zero \"3 3 2 2 1\"\n3\n>>> min_operations_to_zero \"4 0 0 4\"\n1\n",
      "sq": "Shkruani një funksion Shell `min_operations_to_zero() {\nlocal nums=($1)` për të zgjidhur problemin e mëposhtëm:\n\nLlogaritni numrin minimal të operacioneve për të reduktuar të gjitha elementet e një vargu në zero.\nÇdo operacion përbëhet nga zbritja e një numri të plotë pozitiv x (më i vogël ose i barabartë me elementin më të vogël jo-zero) nga secili element pozitiv në varg.\nFunksioni merr një varg që përfaqëson vargun, me elemente të ndara nga hapësira.\nKthen numrin minimal të operacioneve të kërkuara.\n>>> min_operations_to_zero \"3 3 2 2 1\"\n3\n>>> min_operations_to_zero \"4 0 0 4\"\n1\n",
      "hy": "Գրեք Shell ֆունկցիա `min_operations_to_zero() {\nlocal nums=($1)` հետևյալ խնդիրը լուծելու համար:\n\nՀաշվեք նվազագույն գործողությունների քանակը, որպեսզի զանգվածի բոլոր տարրերը հասցվեն զրոյի:\nՅուրաքանչյուր գործողություն բաղկացած է դրական ամբողջ թիվ x (որն փոքր է կամ հավասար է ամենափոքր ոչ զրոյական տարրին) հանելուց զանգվածի յուրաքանչյուր դրական տարրից:\nՖունկցիան ընդունում է զանգվածը ներկայացնող տող, որի տարրերը բաժանված են բացատներով:\nՎերադարձնում է անհրաժեշտ նվազագույն գործողությունների քանակը:\n>>> min_operations_to_zero \"3 3 2 2 1\"\n3\n>>> min_operations_to_zero \"4 0 0 4\"\n1",
      "bn": "একটি Shell ফাংশন লিখুন `min_operations_to_zero() { local nums=($1)` নিম্নলিখিত সমস্যাটি সমাধান করতে:\n\nএকটি অ্যারের সব উপাদানকে শূন্যে কমানোর জন্য সর্বনিম্ন সংখ্যক অপারেশন গণনা করুন।\nপ্রতিটি অপারেশন একটি ধনাত্মক পূর্ণসংখ্যা x (যা সবচেয়ে ছোট অ-শূন্য উপাদানের সমান বা তার চেয়ে কম) প্রতিটি ধনাত্মক উপাদান থেকে বিয়োগ করার সমন্বয়ে গঠিত।\nফাংশনটি একটি স্ট্রিং নেয় যা অ্যারের প্রতিনিধিত্ব করে, উপাদানগুলি স্পেস দ্বারা পৃথক করা থাকে।\nপ্রয়োজনীয় সর্বনিম্ন অপারেশনের সংখ্যা ফেরত দেয়।\n>>> min_operations_to_zero \"3 3 2 2 1\"\n3\n>>> min_operations_to_zero \"4 0 0 4\"\n1",
      "bg": "Напишете Shell функция `min_operations_to_zero() {\nlocal nums=($1)` за решаване на следния проблем:\n\nИзчислете минималния брой операции за намаляване на всички елементи на масив до нула.\nВсяка операция се състои в изваждане на положително цяло число x (по-малко или равно на най-малкия ненулев елемент) от всеки положителен елемент в масива.\nФункцията приема низ, представляващ масива, с елементи, разделени с интервали.\nВръща минималния брой необходими операции.\n>>> min_operations_to_zero \"3 3 2 2 1\"\n3\n>>> min_operations_to_zero \"4 0 0 4\"\n1",
      "zh": "编写一个 Shell 函数 `min_operations_to_zero() {\nlocal nums=($1)` 来解决以下问题：\n\n计算将数组中所有元素减少到零的最小操作次数。\n每次操作包括从数组中的每个正元素中减去一个正整数 x（小于或等于最小的非零元素）。\n该函数接受一个表示数组的字符串，元素之间用空格分隔。\n返回所需的最小操作次数。\n>>> min_operations_to_zero \"3 3 2 2 1\"\n3\n>>> min_operations_to_zero \"4 0 0 4\"\n1\n",
      "fr": "Écrire une fonction Shell `min_operations_to_zero() {\nlocal nums=($1)` pour résoudre le problème suivant :\n\nCalculer le nombre minimum d'opérations pour réduire tous les éléments d'un tableau à zéro.\nChaque opération consiste à soustraire un entier positif x (inférieur ou égal au plus petit élément non nul) de chaque élément positif du tableau.\nLa fonction prend une chaîne représentant le tableau, avec des éléments séparés par des espaces.\nRenvoie le nombre minimum d'opérations requis.\n>>> min_operations_to_zero \"3 3 2 2 1\"\n3\n>>> min_operations_to_zero \"4 0 0 4\"\n1\n",
      "de": "Schreiben Sie eine Shell-Funktion `min_operations_to_zero() {\nlocal nums=($1)` um das folgende Problem zu lösen:\n\nBerechnen Sie die minimale Anzahl von Operationen, um alle Elemente eines Arrays auf Null zu reduzieren.\nJede Operation besteht darin, eine positive ganze Zahl x (kleiner oder gleich dem kleinsten nicht-null Element) von jedem positiven Element im Array zu subtrahieren.\nDie Funktion nimmt einen String, der das Array darstellt, mit durch Leerzeichen getrennten Elementen.\nGibt die minimale Anzahl der erforderlichen Operationen zurück.\n>>> min_operations_to_zero \"3 3 2 2 1\"\n3\n>>> min_operations_to_zero \"4 0 0 4\"\n1\n",
      "ha": "Rubuta aikin Shell `min_operations_to_zero() {\nlocal nums=($1)` don warware matsalar mai zuwa:\n\nLissafa mafi ƙarancin adadin ayyuka don rage dukkan abubuwan cikin jerin zuwa sifili.\nKowane aiki ya ƙunshi rage wani cikakken lamba x (wanda ya yi ƙasa ko dai daidai da mafi ƙarancin abu mara sifili) daga kowane abu mai kyau a cikin jerin.\nAikin yana ɗaukar wani kirtani wanda ke wakiltar jerin, tare da abubuwa da aka raba ta sarari.\nYa dawo da mafi ƙarancin adadin ayyuka da ake bukata.\n>>> min_operations_to_zero \"3 3 2 2 1\"\n3\n>>> min_operations_to_zero \"4 0 0 4\"\n1\n",
      "hi": "`min_operations_to_zero() {\nlocal nums=($1)` निम्नलिखित समस्या को हल करने के लिए:\n\nसभी तत्वों को शून्य तक कम करने के लिए न्यूनतम ऑपरेशनों की गणना करें।\nप्रत्येक ऑपरेशन में एक धनात्मक पूर्णांक x (जो सबसे छोटे गैर-शून्य तत्व के बराबर या उससे कम है) को सरणी के प्रत्येक धनात्मक तत्व से घटाना शामिल है।\nयह फ़ंक्शन एक स्ट्रिंग लेता है जो सरणी का प्रतिनिधित्व करता है, जिसमें तत्व स्पेस द्वारा अलग किए गए होते हैं।\nआवश्यक न्यूनतम ऑपरेशनों की संख्या लौटाता है।\n>>> min_operations_to_zero \"3 3 2 2 1\"\n3\n>>> min_operations_to_zero \"4 0 0 4\"\n1",
      "hu": "Írj egy Shell függvényt `min_operations_to_zero() {\nlocal nums=($1)` a következő probléma megoldására:\n\nSzámítsd ki a minimális műveletek számát, hogy egy tömb összes elemét nullára csökkentsd.\nMinden művelet abból áll, hogy kivonsz egy pozitív egész számot x (ami kisebb vagy egyenlő a legkisebb nem nulla elemmel) minden pozitív elemből a tömbben.\nA függvény egy karakterláncot vesz át, amely a tömböt képviseli, az elemek szóközzel elválasztva vannak.\nVisszaadja a szükséges minimális műveletek számát.\n>>> min_operations_to_zero \"3 3 2 2 1\"\n3\n>>> min_operations_to_zero \"4 0 0 4\"\n1"
    },
    "instruction_bertscore": {
      "sq": "0.9913848044833738",
      "hy": "0.9854302629207099",
      "bn": "0.9835569797971699",
      "bg": "0.9983720253970381",
      "zh": "0.9888542534289894",
      "fr": "0.9963968448880272",
      "de": "0.9928683747993233",
      "ha": "0.9694295925764445",
      "hi": "0.9472612502706648",
      "hu": "0.9847223442427016"
    },
    "level": "hard",
    "test": "test_min_operations_to_zero() {\n[[ $(min_operations_to_zero \"3 3 2 2 1\") == \"3\" ]] || { echo \"Test 1 failed\"; exit 1; }\n[[ $(min_operations_to_zero \"4 0 0 4\") == \"1\" ]] || { echo \"Test 2 failed\"; exit 1; }\n[[ $(min_operations_to_zero \"1 2 3 4 5\") == \"5\" ]] || { echo \"Test 3 failed\"; exit 1; }\n[[ $(min_operations_to_zero \"0 0 0\") == \"0\" ]] || { echo \"Test 4 failed\"; exit 1; }\n[[ $(min_operations_to_zero \"5 5 5 5 5\") == \"1\" ]] || { echo \"Test 5 failed\"; exit 1; }\n[[ $(min_operations_to_zero \"1 1 1 1\") == \"1\" ]] || { echo \"Test 6 failed\"; exit 1; }\n[[ $(min_operations_to_zero \"10 10 10 10 20\") == \"2\" ]] || { echo \"Test 7 failed\"; exit 1; }\n}\n\ntest_min_operations_to_zero",
    "entry_point": "min_operations_to_zero",
    "signature": "min_operations_to_zero() {\nlocal nums=($1)",
    "docstring": {
      "en": "\nCalculate the minimum number of operations to reduce all elements of an array to zero.\nEach operation consists of subtracting a positive integer x (less than or equal to the smallest non-zero element) from each positive element in the array.\nThe function takes a string representing the array, with elements separated by spaces.\nReturns the minimum number of operations required.\n>>> min_operations_to_zero \"3 3 2 2 1\"\n3\n>>> min_operations_to_zero \"4 0 0 4\"\n1\n",
      "sq": "Llogarit numrin minimal të operacioneve për të reduktuar të gjitha elementet e një vargu në zero. Çdo operacion përbëhet nga zbritja e një numri të plotë pozitiv x (më i vogël ose i barabartë me elementin më të vogël jo-zero) nga secili element pozitiv në varg. Funksioni merr një varg që përfaqëson vargun, me elementet e ndara me hapësira. Kthen numrin minimal të operacioneve të nevojshme.\n>>> min_operations_to_zero \"3 3 2 2 1\"\n3\n>>> min_operations_to_zero \"4 0 0 4\"\n1",
      "hy": "Հաշվարկել գործողությունների նվազագույն քանակը, որպեսզի զանգվածի բոլոր տարրերը հասցվեն զրոյի:\nՅուրաքանչյուր գործողություն բաղկացած է դրական ամբողջ թիվ x-ի հանումից (որը փոքր կամ հավասար է ամենափոքր ոչ զրոյական տարրին) զանգվածի յուրաքանչյուր դրական տարրից:\nՖունկցիան ընդունում է տող, որը ներկայացնում է զանգվածը, տարրերը բաժանված են բացատներով:\nՎերադարձնում է պահանջվող գործողությունների նվազագույն քանակը:\n>>> min_operations_to_zero \"3 3 2 2 1\"\n3\n>>> min_operations_to_zero \"4 0 0 4\"\n1",
      "bn": "সমস্ত উপাদানকে শূন্যে নামিয়ে আনার জন্য ন্যূনতম সংখ্যক অপারেশন গণনা করুন। প্রতিটি অপারেশন একটি ধনাত্মক পূর্ণসংখ্যা x (যা সবচেয়ে ছোট অ-শূন্য উপাদানের সমান বা তার চেয়ে কম) প্রতিটি ধনাত্মক উপাদান থেকে বিয়োগ করার মাধ্যমে গঠিত। ফাংশনটি অ্যারের প্রতিনিধিত্বকারী একটি স্ট্রিং নেয়, যেখানে উপাদানগুলি স্পেস দ্বারা পৃথক করা থাকে। প্রয়োজনীয় ন্যূনতম সংখ্যক অপারেশন ফেরত দেয়।\n>>> min_operations_to_zero \"3 3 2 2 1\"\n3\n>>> min_operations_to_zero \"4 0 0 4\"\n1",
      "bg": "Изчислете минималния брой операции за намаляване на всички елементи на масив до нула. Всяка операция се състои в изваждане на положително цяло число x (по-малко или равно на най-малкия ненулев елемент) от всеки положителен елемент в масива. Функцията приема низ, представляващ масива, с елементи, разделени с интервали. Връща минималния брой необходими операции.\n>>> min_operations_to_zero \"3 3 2 2 1\"\n3\n>>> min_operations_to_zero \"4 0 0 4\"\n1",
      "zh": "计算将数组中的所有元素减少到零所需的最小操作次数。  \n每次操作包括从数组中的每个正元素中减去一个正整数 x（小于或等于最小的非零元素）。  \n该函数接受一个表示数组的字符串，元素之间用空格分隔。  \n返回所需的最小操作次数。  \n>>> min_operations_to_zero \"3 3 2 2 1\"  \n3  \n>>> min_operations_to_zero \"4 0 0 4\"  \n1  ",
      "fr": "Calculer le nombre minimum d'opérations pour réduire tous les éléments d'un tableau à zéro.\nChaque opération consiste à soustraire un entier positif x (inférieur ou égal au plus petit élément non nul) de chaque élément positif du tableau.\nLa fonction prend une chaîne représentant le tableau, avec des éléments séparés par des espaces.\nRenvoie le nombre minimum d'opérations requises.\n>>> min_operations_to_zero \"3 3 2 2 1\"\n3\n>>> min_operations_to_zero \"4 0 0 4\"\n1",
      "de": "Berechne die minimale Anzahl von Operationen, um alle Elemente eines Arrays auf null zu reduzieren.  \nJede Operation besteht darin, eine positive ganze Zahl x (kleiner oder gleich dem kleinsten nicht-null Element) von jedem positiven Element im Array zu subtrahieren.  \nDie Funktion nimmt einen String, der das Array repräsentiert, mit durch Leerzeichen getrennten Elementen.  \nGibt die minimale Anzahl der erforderlichen Operationen zurück.  \n>>> min_operations_to_zero \"3 3 2 2 1\"  \n3  \n>>> min_operations_to_zero \"4 0 0 4\"  \n1  ",
      "ha": "Ƙididdige mafi ƙarancin adadin ayyuka don rage duk abubuwan da ke cikin jerin zuwa sifili. \nKowane aiki ya ƙunshi cire adadi mai kyau x (wanda ya yi ƙasa ko daidai da ƙaramin abu mara sifili) daga kowane abu mai kyau a cikin jerin. \nAikin yana ɗaukar kirtani mai wakiltar jerin, tare da abubuwa da aka raba ta wurin sarari. \nYana dawowa da mafi ƙarancin adadin ayyuka da ake buƙata.\n>>> min_operations_to_zero \"3 3 2 2 1\"\n3\n>>> min_operations_to_zero \"4 0 0 4\"\n1",
      "hi": "सभी तत्वों को शून्य तक घटाने के लिए न्यूनतम संचालन की संख्या की गणना करें।  \nप्रत्येक संचालन में एक धनात्मक पूर्णांक x (जो सबसे छोटे गैर-शून्य तत्व के बराबर या उससे कम है) को सरणी के प्रत्येक धनात्मक तत्व से घटाना शामिल है।  \nयह फ़ंक्शन एक स्ट्रिंग लेता है जो सरणी का प्रतिनिधित्व करता है, जिसमें तत्व स्पेस द्वारा अलग किए गए होते हैं।  \nआवश्यक न्यूनतम संचालन की संख्या लौटाता है।  \n>>> min_operations_to_zero \"3 3 2 2 1\"  \n3  \n>>> min_operations_to_zero \"4 0 0 4\"  \n1  ",
      "hu": "Számítsa ki a minimális műveletek számát, hogy az összes elem egy tömbben nullára csökkenjen.\nMinden művelet abból áll, hogy kivonunk egy pozitív egész számot x (amely kisebb vagy egyenlő a legkisebb nem nulla elemmel) minden pozitív elemből a tömbben.\nA függvény egy karakterláncot vesz, amely a tömböt ábrázolja, az elemek szóközzel elválasztva vannak.\nVisszaadja a szükséges minimális műveletek számát.\n>>> min_operations_to_zero \"3 3 2 2 1\"\n3\n>>> min_operations_to_zero \"4 0 0 4\"\n1"
    },
    "docstring_bertscore": {
      "sq": "0.9857937565180037",
      "hy": "0.9807519215561952",
      "bn": "0.9614170416358782",
      "bg": "0.9920680929941338",
      "zh": "0.9856586878589",
      "fr": "0.9967462357282675",
      "de": "1",
      "ha": "0.9516968653095549",
      "hi": "0.9690269687940868",
      "hu": "0.9845499330719633"
    }
  },
  {
    "task_id": "Shell/8",
    "prompt": {
      "en": "#!/bin/bash\n\n# Merge two sets of items and sum the weights of items with the same value.\n# Each item is represented as [value, weight].\n# The function takes two strings, each representing an array of items, where items are separated by semicolons and values by spaces.\n# Returns a sorted array of unique values and their cumulative weights.\n# >>> merge_items \"10 5;15 10\" \"15 15;20 20\"\n# 10 5;15 25;20 20\nmerge_items() {\nlocal items1=(${1//;/ })\nlocal items2=(${2//;/ })",
      "sq": "#!/bin/bash\n\n# Bashkon dy grupe elementesh dhe mbledh peshat e elementeve me të njëjtën vlerë.\n# Çdo element përfaqësohet si [vlerë, peshë].\n# Funksioni merr dy vargje, secila që përfaqëson një varg elementesh, ku elementet ndahen me pikëpresje dhe vlerat me hapësira.\n# Kthen një varg të renditur të vlerave unike dhe peshat e tyre kumulative.\n# >>> merge_items \"10 5;15 10\" \"15 15;20 20\"\n# 10 5;15 25;20 20\nmerge_items() {\nlocal items1=(${1//;/ })\nlocal items2=(${2//;/ })",
      "hy": "#!/bin/bash\n\n# Միացրեք երկու հավաքածու տարրեր և գումարեք նույն արժեք ունեցող տարրերի քաշերը։\n# Յուրաքանչյուր տարր ներկայացված է որպես [արժեք, քաշ]։\n# Ֆունկցիան ընդունում է երկու տող, որոնք ներկայացնում են տարրերի զանգված, որտեղ տարրերը բաժանված են կետ-ստորակետերով, իսկ արժեքները՝ բացատներով։\n# Վերադարձնում է եզակի արժեքների և նրանց կուտակային քաշերի դասավորված զանգված։\n# >>> merge_items \"10 5;15 10\" \"15 15;20 20\"\n# 10 5;15 25;20 20\nmerge_items() {\nlocal items1=(${1//;/ })\nlocal items2=(${2//;/ })",
      "bn": "#!/bin/bash\n\n# দুটি সেটের আইটেম একত্রিত করুন এবং একই মানের আইটেমগুলোর ওজন যোগ করুন।\n# প্রতিটি আইটেমকে [মান, ওজন] হিসাবে উপস্থাপন করা হয়।\n# ফাংশনটি দুটি স্ট্রিং নেয়, প্রতিটি আইটেমের একটি অ্যারে উপস্থাপন করে, যেখানে আইটেমগুলো সেমিকোলন দ্বারা এবং মানগুলো স্পেস দ্বারা পৃথক করা হয়।\n# অনন্য মান এবং তাদের সমষ্টিগত ওজনের একটি সর্ট করা অ্যারে রিটার্ন করে।\n# >>> merge_items \"10 5;15 10\" \"15 15;20 20\"\n# 10 5;15 25;20 20\nmerge_items() {\nlocal items1=(${1//;/ })\nlocal items2=(${2//;/ })",
      "bg": "#!/bin/bash\n\n# Обединяване на два набора от елементи и сумиране на теглата на елементи със същата стойност.\n# Всеки елемент е представен като [стойност, тегло].\n# Функцията приема два низа, всеки представляващ масив от елементи, където елементите са разделени със запетаи и стойностите с интервали.\n# Връща сортиран масив от уникални стойности и техните кумулативни тегла.\n# >>> merge_items \"10 5;15 10\" \"15 15;20 20\"\n# 10 5;15 25;20 20\nmerge_items() {\nlocal items1=(${1//;/ })\nlocal items2=(${2//;/ })",
      "zh": "#!/bin/bash\n\n# 合并两组物品并对具有相同值的物品的权重求和。\n# 每个物品表示为 [值, 权重]。\n# 该函数接收两个字符串，每个字符串表示一个物品数组，其中物品用分号分隔，值和权重用空格分隔。\n# 返回一个排序后的唯一值及其累计权重的数组。\n# >>> merge_items \"10 5;15 10\" \"15 15;20 20\"\n# 10 5;15 25;20 20\nmerge_items() {\nlocal items1=(${1//;/ })\nlocal items2=(${2//;/ })",
      "fr": "#!/bin/bash\n\n# Fusionner deux ensembles d'articles et sommer les poids des articles ayant la même valeur.\n# Chaque article est représenté comme [valeur, poids].\n# La fonction prend deux chaînes, chacune représentant un tableau d'articles, où les articles sont séparés par des points-virgules et les valeurs par des espaces.\n# Renvoie un tableau trié de valeurs uniques et leurs poids cumulatifs.\n# >>> merge_items \"10 5;15 10\" \"15 15;20 20\"\n# 10 5;15 25;20 20\nmerge_items() {\nlocal items1=(${1//;/ })\nlocal items2=(${2//;/ })",
      "de": "#!/bin/bash\n\n# Zwei Mengen von Elementen zusammenführen und die Gewichte von Elementen mit demselben Wert summieren.\n# Jedes Element wird als [Wert, Gewicht] dargestellt.\n# Die Funktion nimmt zwei Zeichenfolgen, die jeweils ein Array von Elementen darstellen, wobei Elemente durch Semikolons und Werte durch Leerzeichen getrennt sind.\n# Gibt ein sortiertes Array von eindeutigen Werten und deren kumulierten Gewichten zurück.\n# >>> merge_items \"10 5;15 10\" \"15 15;20 20\"\n# 10 5;15 25;20 20\nmerge_items() {\nlocal items1=(${1//;/ })\nlocal items2=(${2//;/ })",
      "ha": "#!/bin/bash\n\n# Haɗa saitin abubuwa biyu kuma tara nauyin abubuwan da ke da irin wannan ƙima.\n# Kowane abu ana wakilta shi azaman [ƙima, nauyi].\n# Aikin yana ɗaukar igiyoyi guda biyu, kowanne yana wakiltar jerin abubuwa, inda abubuwan ke rabuwa da alamar semicolon kuma ƙimomi da sarari.\n# Yana mayar da jerin ƙima na musamman da nauyin su na tarawa.\n# >>> merge_items \"10 5;15 10\" \"15 15;20 20\"\n# 10 5;15 25;20 20\nmerge_items() {\nlocal items1=(${1//;/ })\nlocal items2=(${2//;/ })",
      "hi": "#!/bin/bash\n\n# दो सेटों के आइटम्स को मर्ज करें और समान मान वाले आइटम्स के वज़न को जोड़ें।\n# प्रत्येक आइटम को [मान, वज़न] के रूप में दर्शाया गया है।\n# यह फ़ंक्शन दो स्ट्रिंग्स लेता है, प्रत्येक आइटम्स की एक एरे का प्रतिनिधित्व करती है, जहाँ आइटम्स को सेमीकोलन द्वारा और मानों को स्पेस द्वारा अलग किया जाता है।\n# अद्वितीय मानों और उनके संचयी वज़न की एक सॉर्टेड एरे लौटाता है।\n# >>> merge_items \"10 5;15 10\" \"15 15;20 20\"\n# 10 5;15 25;20 20\nmerge_items() {\nlocal items1=(${1//;/ })\nlocal items2=(${2//;/ })",
      "hu": "#!/bin/bash\n\n# Két elemhalmaz egyesítése és az azonos értékű elemek súlyának összeadása.\n# Minden elem [érték, súly] formában van ábrázolva.\n# A függvény két karakterláncot vesz fel, amelyek mindegyike egy elemtömböt képvisel, ahol az elemek pontosvesszővel, az értékek pedig szóközzel vannak elválasztva.\n# Visszaad egy rendezett tömböt az egyedi értékekkel és azok összesített súlyával.\n# >>> merge_items \"10 5;15 10\" \"15 15;20 20\"\n# 10 5;15 25;20 20\nmerge_items() {\nlocal items1=(${1//;/ })\nlocal items2=(${2//;/ })"
    },
    "prompt_bertscore": {
      "sq": "0.9708938957454337",
      "hy": "0.9655088274851968",
      "bn": "0.9869533606824854",
      "bg": "0.971174560473836",
      "zh": "0.9768232112497062",
      "fr": "1",
      "de": "0.9866135041005347",
      "ha": "0.9827229308272044",
      "hi": "0.9764601149131744",
      "hu": "0.9459675705989845"
    },
    "canonical_solution": "local -A item_map\nlocal IFS=$'\\n'\n\n# Process items1\nfor (( i=0; i<${#items1[@]}; i+=2 )); do\nitem_map[${items1[i]}]=$((item_map[${items1[i]}] + items1[i+1]))\ndone\n\n# Process items2\nfor (( i=0; i<${#items2[@]}; i+=2 )); do\nitem_map[${items2[i]}]=$((item_map[${items2[i]}] + items2[i+1]))\ndone\n\n# Sort and output the result\nfor item in $(echo ${!item_map[@]} | tr ' ' '\\n' | sort -n); do\necho -n \"$item ${item_map[$item]};\"\ndone\n}",
    "instruction": {
      "en": "Write a Shell function `merge_items() {\nlocal items1=(${1//;/ })\nlocal items2=(${2//;/ })` to solve the following problem:\n\nMerge two sets of items and sum the weights of items with the same value.\nEach item is represented as [value, weight].\nThe function takes two strings, each representing an array of items, where items are separated by semicolons and values by spaces.\nReturns a sorted array of unique values and their cumulative weights.\n>>> merge_items \"10 5;15 10\" \"15 15;20 20\"\n10 5;15 25;20 20\n",
      "sq": "Shkruani një funksion Shell `merge_items() {\nlocal items1=(${1//;/ })\nlocal items2=(${2//;/ })` për të zgjidhur problemin e mëposhtëm:\n\nBashkoni dy grupe artikujsh dhe shuma peshat e artikujve me të njëjtën vlerë.\nÇdo artikull përfaqësohet si [vlera, pesha].\nFunksioni merr dy vargje, secila që përfaqëson një varg artikujsh, ku artikujt ndahen me pikëpresje dhe vlerat me hapësira.\nKthen një varg të renditur të vlerave unike dhe peshat e tyre kumulative.\n>>> merge_items \"10 5;15 10\" \"15 15;20 20\"\n10 5;15 25;20 20",
      "hy": "Գրեք Shell ֆունկցիա `merge_items() {\nlocal items1=(${1//;/ })\nlocal items2=(${2//;/ })` հետևյալ խնդիրը լուծելու համար:\n\nՄիավորել երկու հավաքածուի տարրերը և գումարել նույն արժեքով տարրերի քաշերը:\nՅուրաքանչյուր տարր ներկայացված է որպես [արժեք, քաշ]:\nՖունկցիան ընդունում է երկու տող, որոնցից յուրաքանչյուրը ներկայացնում է տարրերի զանգված, որտեղ տարրերը բաժանված են կետ-ստորակետերով, իսկ արժեքները՝ բացատներով:\nՎերադարձնում է եզակի արժեքների և նրանց կուտակային քաշերի դասավորված զանգված:\n>>> merge_items \"10 5;15 10\" \"15 15;20 20\"\n10 5;15 25;20 20",
      "bn": "একটি Shell ফাংশন লিখুন `merge_items() {\nlocal items1=(${1//;/ })\nlocal items2=(${2//;/ })` নিম্নলিখিত সমস্যার সমাধানের জন্য:\n\nদুই সেট আইটেম মিশ্রিত করুন এবং একই মানের আইটেমগুলোর ওজন যোগ করুন।\nপ্রতিটি আইটেম [মান, ওজন] হিসাবে উপস্থাপিত হয়।\nফাংশনটি দুটি স্ট্রিং নেয়, প্রতিটি আইটেমের একটি অ্যারে উপস্থাপন করে, যেখানে আইটেমগুলি সেমিকোলন দ্বারা পৃথক এবং মানগুলি স্পেস দ্বারা পৃথক।\nএকটি সাজানো অ্যারে ফেরত দেয় যা অনন্য মান এবং তাদের সামগ্রিক ওজন প্রদর্শন করে।\n>>> merge_items \"10 5;15 10\" \"15 15;20 20\"\n10 5;15 25;20 20",
      "bg": "Напишете Shell функция `merge_items() {\nlocal items1=(${1//;/ })\nlocal items2=(${2//;/ })`, за да решите следния проблем:\n\nСлейте два комплекта от елементи и сумирайте теглата на елементите със същата стойност.\nВсеки елемент е представен като [стойност, тегло].\nФункцията приема два низа, всеки представляващ масив от елементи, където елементите са разделени със запетаи и стойностите със спейсове.\nВръща сортиран масив от уникални стойности и техните кумулативни тегла.\n>>> merge_items \"10 5;15 10\" \"15 15;20 20\"\n10 5;15 25;20 20",
      "zh": "编写一个 Shell 函数 `merge_items() {\nlocal items1=(${1//;/ })\nlocal items2=(${2//;/ })` 来解决以下问题：\n\n合并两组项目，并对具有相同值的项目的权重求和。\n每个项目表示为 [value, weight]。\n该函数接受两个字符串，每个字符串表示一个项目数组，其中项目用分号分隔，值用空格分隔。\n返回一个排序后的唯一值及其累积权重数组。\n>>> merge_items \"10 5;15 10\" \"15 15;20 20\"\n10 5;15 25;20 20",
      "fr": "Écrire une fonction Shell `merge_items() {\nlocal items1=(${1//;/ })\nlocal items2=(${2//;/ })` pour résoudre le problème suivant :\n\nFusionner deux ensembles d'articles et sommer les poids des articles ayant la même valeur.\nChaque article est représenté sous la forme [valeur, poids].\nLa fonction prend deux chaînes, chacune représentant un tableau d'articles, où les articles sont séparés par des points-virgules et les valeurs par des espaces.\nRenvoie un tableau trié de valeurs uniques et de leurs poids cumulatifs.\n>>> merge_items \"10 5;15 10\" \"15 15;20 20\"\n10 5;15 25;20 20",
      "de": "Schreiben Sie eine Shell-Funktion `merge_items() {\nlocal items1=(${1//;/ })\nlocal items2=(${2//;/ })`, um das folgende Problem zu lösen:\n\nZwei Mengen von Gegenständen zusammenführen und die Gewichte von Gegenständen mit dem gleichen Wert summieren.\nJeder Gegenstand wird als [Wert, Gewicht] dargestellt.\nDie Funktion nimmt zwei Zeichenfolgen, die jeweils ein Array von Gegenständen darstellen, wobei Gegenstände durch Semikolons und Werte durch Leerzeichen getrennt sind.\nGibt ein sortiertes Array von einzigartigen Werten und deren kumulierten Gewichten zurück.\n>>> merge_items \"10 5;15 10\" \"15 15;20 20\"\n10 5;15 25;20 20",
      "ha": "Rubuta aikin Shell `merge_items() {\nlocal items1=(${1//;/ })\nlocal items2=(${2//;/ })` don warware matsalar mai zuwa:\n\nHaɗa saitin abubuwa biyu kuma tara nauyin abubuwan da ke da irin wannan ƙimar.\nKowane abu yana wakilta azaman [ƙima, nauyi].\nAikin yana ɗaukar kirtani biyu, kowanne yana wakiltar jerin abubuwa, inda abubuwa ke rabuwa da semicolons kuma ƙimomi da sarari.\nYana mayar da jerin ƙima na musamman da aka tsara da nauyin su na tarawa.\n>>> merge_items \"10 5;15 10\" \"15 15;20 20\"\n10 5;15 25;20 20",
      "hi": "Shell फ़ंक्शन `merge_items() {\nlocal items1=(${1//;/ })\nlocal items2=(${2//;/ })` लिखें ताकि निम्नलिखित समस्या का समाधान किया जा सके:\n\nदो सेट के आइटम्स को मर्ज करें और समान मान वाले आइटम्स के वज़न को जोड़ें।\nप्रत्येक आइटम को [value, weight] के रूप में दर्शाया जाता है।\nयह फ़ंक्शन दो स्ट्रिंग्स लेता है, प्रत्येक एक आइटम्स की array का प्रतिनिधित्व करती है, जहाँ आइटम्स को सेमीकोलन द्वारा और मानों को स्पेस द्वारा अलग किया जाता है।\nएक क्रमबद्ध array लौटाता है जिसमें अद्वितीय मान और उनके संचयी वज़न होते हैं।\n>>> merge_items \"10 5;15 10\" \"15 15;20 20\"\n10 5;15 25;20 20",
      "hu": "Írj egy Shell függvényt `merge_items() {\nlocal items1=(${1//;/ })\nlocal items2=(${2//;/ })` a következő probléma megoldására:\n\nKét elemhalmaz egyesítése és az azonos értékű elemek súlyainak összeadása.\nMinden elem [érték, súly] formában van ábrázolva.\nA függvény két karakterláncot vesz át, amelyek mindegyike egy elemtömböt képvisel, ahol az elemek pontosvesszővel, az értékek pedig szóközzel vannak elválasztva.\nEgy rendezett tömböt ad vissza az egyedi értékekkel és azok összesített súlyaival.\n>>> merge_items \"10 5;15 10\" \"15 15;20 20\"\n10 5;15 25;20 20"
    },
    "instruction_bertscore": {
      "sq": "1",
      "hy": "0.9763439161402689",
      "bn": "0.9748090991860123",
      "bg": "0.9883705884511693",
      "zh": "0.9894805350203923",
      "fr": "0.9804754280657947",
      "de": "0.9960788376479903",
      "ha": "0.9735082688206149",
      "hi": "0.9580671402597247",
      "hu": "0.9683289816351301"
    },
    "level": "middle",
    "test": "test_merge_items() {\n[[ $(merge_items \"10 5;15 10\" \"15 15;20 20\") == \"10 5;15 25;20 20;\" ]] || { echo \"Test 1 failed\"; exit 1; }\n[[ $(merge_items \"1 2;3 4\" \"5 6;7 8\") == \"1 2;3 4;5 6;7 8;\" ]] || { echo \"Test 2 failed\"; exit 1; }\n[[ $(merge_items \"2 2;4 4\" \"2 3;4 5\") == \"2 5;4 9;\" ]] || { echo \"Test 3 failed\"; exit 1; }\n[[ $(merge_items \"\" \"\") == \"\" ]] || { echo \"Test 4 failed\"; exit 1; }\n[[ $(merge_items \"10 10\" \"10 10\") == \"10 20;\" ]] || { echo \"Test 5 failed\"; exit 1; }\n[[ $(merge_items \"1 1;2 2;3 3\" \"4 4;5 5;6 6\") == \"1 1;2 2;3 3;4 4;5 5;6 6;\" ]] || { echo \"Test 6 failed\"; exit 1; }\n[[ $(merge_items \"9 9;8 8\" \"7 7;6 6\") == \"6 6;7 7;8 8;9 9;\" ]] || { echo \"Test 7 failed\"; exit 1; }\n}\n\ntest_merge_items",
    "entry_point": "merge_items",
    "signature": "merge_items() {\nlocal items1=(${1//;/ })\nlocal items2=(${2//;/ })",
    "docstring": {
      "en": "\nMerge two sets of items and sum the weights of items with the same value.\nEach item is represented as [value, weight].\nThe function takes two strings, each representing an array of items, where items are separated by semicolons and values by spaces.\nReturns a sorted array of unique values and their cumulative weights.\n>>> merge_items \"10 5;15 10\" \"15 15;20 20\"\n10 5;15 25;20 20\n",
      "sq": "Bashkoni dy grupe artikujsh dhe mbledhni peshat e artikujve me të njëjtën vlerë. \nÇdo artikull përfaqësohet si [vlerë, peshë]. \nFunksioni merr dy vargje, secili që përfaqëson një varg artikujsh, ku artikujt ndahen me pikëpresje dhe vlerat me hapësira. \nKthen një varg të renditur të vlerave unike dhe peshave të tyre kumulative.\n>>> merge_items \"10 5;15 10\" \"15 15;20 20\"\n10 5;15 25;20 20",
      "hy": "Միավորել երկու հավաքածուի տարրերը և գումարել նույն արժեք ունեցող տարրերի քաշերը:\nՅուրաքանչյուր տարր ներկայացված է որպես [արժեք, քաշ]:\nՖունկցիան ընդունում է երկու տող, որոնք ներկայացնում են տարրերի զանգվածներ, որտեղ տարրերը բաժանված են կետ-ստորակետներով և արժեքները՝ բացատներով:\nՎերադարձնում է եզակի արժեքների և դրանց կուտակային քաշերի դասավորված զանգված:\n>>> merge_items \"10 5;15 10\" \"15 15;20 20\"\n10 5;15 25;20 20",
      "bn": "দুটি সেটের আইটেম একত্রিত করুন এবং একই মানের আইটেমগুলির ওজন যোগ করুন।\nপ্রতিটি আইটেমকে [মান, ওজন] হিসাবে উপস্থাপন করা হয়।\nফাংশনটি দুটি স্ট্রিং নেয়, প্রতিটি আইটেমের একটি অ্যারে উপস্থাপন করে, যেখানে আইটেমগুলি সেমিকোলন দ্বারা এবং মানগুলি স্পেস দ্বারা পৃথক করা হয়।\nএকটি সাজানো অ্যারে প্রদান করে যা অনন্য মান এবং তাদের সমষ্টিগত ওজন ধারণ করে।\n>>> merge_items \"10 5;15 10\" \"15 15;20 20\"\n10 5;15 25;20 20",
      "bg": "Обединете два набора от елементи и сумирайте теглата на елементите със същата стойност. Всеки елемент е представен като [стойност, тегло]. Функцията приема два низа, всеки от които представлява масив от елементи, където елементите са разделени със запетаи, а стойностите със интервали. Връща сортиран масив от уникални стойности и техните кумулативни тегла.\n>>> merge_items \"10 5;15 10\" \"15 15;20 20\"\n10 5;15 25;20 20",
      "zh": "合并两个项目集并对具有相同值的项目的权重求和。  \n每个项目表示为 [值, 权重]。  \n该函数接受两个字符串，每个字符串表示一个项目数组，其中项目由分号分隔，值由空格分隔。  \n返回一个排序后的唯一值及其累积权重数组。  \n>>> merge_items \"10 5;15 10\" \"15 15;20 20\"  \n10 5;15 25;20 20  ",
      "fr": "Fusionner deux ensembles d'éléments et sommer les poids des éléments ayant la même valeur.  \nChaque élément est représenté sous la forme [valeur, poids].  \nLa fonction prend deux chaînes, chacune représentant un tableau d'éléments, où les éléments sont séparés par des points-virgules et les valeurs par des espaces.  \nRenvoie un tableau trié de valeurs uniques et leurs poids cumulatifs.  \n>>> merge_items \"10 5;15 10\" \"15 15;20 20\"  \n10 5;15 25;20 20  ",
      "de": "Zwei Mengen von Elementen zusammenführen und die Gewichte von Elementen mit demselben Wert summieren.\nJedes Element wird als [Wert, Gewicht] dargestellt.\nDie Funktion nimmt zwei Zeichenfolgen, die jeweils ein Array von Elementen darstellen, wobei Elemente durch Semikolons und Werte durch Leerzeichen getrennt sind.\nGibt ein sortiertes Array von eindeutigen Werten und deren kumulierten Gewichten zurück.\n>>> merge_items \"10 5;15 10\" \"15 15;20 20\"\n10 5;15 25;20 20",
      "ha": "Haɗa saitunan abubuwa biyu kuma tara nauyin abubuwan da ke da darajar iri ɗaya. \nKowane abu yana wakiltar [daraja, nauyi]. \nAikin yana ɗaukar igiyoyi biyu, kowanne yana wakiltar jerin abubuwa, inda abubuwa suke rabuwa da alamar semicolon kuma darajoji da sarari. \nYa dawo da jerin abubuwa masu daraja na musamman da nauyinsu na tarawa. \n>>> merge_items \"10 5;15 10\" \"15 15;20 20\" \n10 5;15 25;20 20",
      "hi": "दो सेटों के आइटम्स को मिलाएं और समान मान वाले आइटम्स के भार को जोड़ें।\nप्रत्येक आइटम को [मान, भार] के रूप में दर्शाया गया है।\nयह फ़ंक्शन दो स्ट्रिंग्स लेता है, प्रत्येक आइटम्स की एक एरे को दर्शाती है, जहाँ आइटम्स को सेमीकोलन द्वारा और मानों को स्पेस द्वारा अलग किया गया है।\nअद्वितीय मानों और उनके संचयी भारों की एक क्रमबद्ध एरे लौटाता है।\n>>> merge_items \"10 5;15 10\" \"15 15;20 20\"\n10 5;15 25;20 20",
      "hu": "Két elemhalmaz egyesítése és az azonos értékű elemek súlyainak összeadása.\nMinden elem [érték, súly] formában van ábrázolva.\nA függvény két karakterláncot vesz át, amelyek mindegyike egy-egy elem tömböt képvisel, ahol az elemeket pontosvessző választja el, és az értékeket szóköz választja el.\nEgy rendezett tömböt ad vissza az egyedi értékekkel és azok összesített súlyaival.\n>>> merge_items \"10 5;15 10\" \"15 15;20 20\"\n10 5;15 25;20 20"
    },
    "docstring_bertscore": {
      "sq": "0.9834183357912075",
      "hy": "0.948105230759682",
      "bn": "0.9643325383687082",
      "bg": "0.964012942085623",
      "zh": "0.9855724822735309",
      "fr": "0.9613071990351658",
      "de": "0.9828148966936235",
      "ha": "0.9170412268392548",
      "hi": "0.9638260308970693",
      "hu": "0.942610915789876"
    }
  },
  {
    "task_id": "Shell/9",
    "prompt": {
      "en": "#!/bin/bash\n\n# Count the number of distinct arithmetic triplets in a strictly increasing integer array.\n# A triplet (i, j, k) is arithmetic if nums[j] - nums[i] == diff and nums[k] - nums[j] == diff.\n# The function takes a string representing the array and an integer diff, with elements separated by spaces.\n# Returns the count of distinct arithmetic triplets.\n# >>> count_arithmetic_triplets \"1 2 3 4 5\" 1\n# 3\n# >>> count_arithmetic_triplets \"1 3 5 7 9\" 2\n# 4\ncount_arithmetic_triplets() {\nlocal nums=($1)\nlocal diff=$2",
      "sq": "#!/bin/bash\n\n# Numëron numrin e tresheve aritmetike të ndryshme në një varg të plotë në rritje të rreptë.\n# Një treshe (i, j, k) është aritmetike nëse nums[j] - nums[i] == diff dhe nums[k] - nums[j] == diff.\n# Funksioni merr një varg që përfaqëson vargun dhe një numër të plotë diff, me elemente të ndara nga hapësira.\n# Kthen numrin e tresheve aritmetike të ndryshme.\n# >>> count_arithmetic_triplets \"1 2 3 4 5\" 1\n# 3\n# >>> count_arithmetic_triplets \"1 3 5 7 9\" 2\n# 4\ncount_arithmetic_triplets() {\nlocal nums=($1)\nlocal diff=$2",
      "hy": "#!/bin/bash\n\n# Հաշվել տարբեր թվաբանական եռյակների քանակը խիստ աճող ամբողջ թվերի զանգվածում:\n# Եռյակը (i, j, k) թվաբանական է, եթե nums[j] - nums[i] == diff և nums[k] - nums[j] == diff:\n# Ֆունկցիան ընդունում է զանգվածը ներկայացնող տող և ամբողջ թիվ diff, տարրերը բաժանված են բացատներով:\n# Վերադարձնում է տարբեր թվաբանական եռյակների քանակը:\n# >>> count_arithmetic_triplets \"1 2 3 4 5\" 1\n# 3\n# >>> count_arithmetic_triplets \"1 3 5 7 9\" 2\n# 4\ncount_arithmetic_triplets() {\nlocal nums=($1)\nlocal diff=$2",
      "bn": "#!/bin/bash\n\n# একটি কঠোরভাবে ক্রমবর্ধমান পূর্ণসংখ্যার অ্যারেতে স্বতন্ত্র গাণিতিক ট্রিপলেটের সংখ্যা গণনা করুন।\n# একটি ট্রিপলেট (i, j, k) গাণিতিক যদি nums[j] - nums[i] == diff এবং nums[k] - nums[j] == diff হয়।\n# ফাংশনটি অ্যারে উপস্থাপনকারী একটি স্ট্রিং এবং একটি পূর্ণসংখ্যা diff গ্রহণ করে, যেখানে উপাদানগুলি স্পেস দ্বারা পৃথক করা থাকে।\n# স্বতন্ত্র গাণিতিক ট্রিপলেটের সংখ্যা ফেরত দেয়।\n# >>> count_arithmetic_triplets \"1 2 3 4 5\" 1\n# 3\n# >>> count_arithmetic_triplets \"1 3 5 7 9\" 2\n# 4\ncount_arithmetic_triplets() {\nlocal nums=($1)\nlocal diff=$2",
      "bg": "#!/bin/bash\n\n# Брой на различните аритметични тройки в строго нарастващ масив от цели числа.\n# Тройка (i, j, k) е аритметична, ако nums[j] - nums[i] == diff и nums[k] - nums[j] == diff.\n# Функцията приема низ, представляващ масива, и цяло число diff, с елементи, разделени с интервали.\n# Връща броя на различните аритметични тройки.\n# >>> count_arithmetic_triplets \"1 2 3 4 5\" 1\n# 3\n# >>> count_arithmetic_triplets \"1 3 5 7 9\" 2\n# 4\ncount_arithmetic_triplets() {\nlocal nums=($1)\nlocal diff=$2",
      "zh": "#!/bin/bash\n\n# 计算严格递增整数数组中不同的算术三元组的数量。\n# 如果三元组 (i, j, k) 满足 nums[j] - nums[i] == diff 且 nums[k] - nums[j] == diff，则为算术三元组。\n# 该函数接受一个表示数组的字符串和一个整数 diff，元素之间用空格分隔。\n# 返回不同算术三元组的数量。\n# >>> count_arithmetic_triplets \"1 2 3 4 5\" 1\n# 3\n# >>> count_arithmetic_triplets \"1 3 5 7 9\" 2\n# 4\ncount_arithmetic_triplets() {\nlocal nums=($1)\nlocal diff=$2",
      "fr": "#!/bin/bash\n\n# Compter le nombre de triplets arithmétiques distincts dans un tableau d'entiers strictement croissant.\n# Un triplet (i, j, k) est arithmétique si nums[j] - nums[i] == diff et nums[k] - nums[j] == diff.\n# La fonction prend une chaîne représentant le tableau et un entier diff, avec des éléments séparés par des espaces.\n# Renvoie le nombre de triplets arithmétiques distincts.\n# >>> count_arithmetic_triplets \"1 2 3 4 5\" 1\n# 3\n# >>> count_arithmetic_triplets \"1 3 5 7 9\" 2\n# 4\ncount_arithmetic_triplets() {\nlocal nums=($1)\nlocal diff=$2",
      "de": "#!/bin/bash\n\n# Zählt die Anzahl der unterschiedlichen arithmetischen Tripel in einem streng zunehmenden Integer-Array.\n# Ein Tripel (i, j, k) ist arithmetisch, wenn nums[j] - nums[i] == diff und nums[k] - nums[j] == diff.\n# Die Funktion nimmt einen String, der das Array darstellt, und einen Integer diff, mit durch Leerzeichen getrennten Elementen.\n# Gibt die Anzahl der unterschiedlichen arithmetischen Tripel zurück.\n# >>> count_arithmetic_triplets \"1 2 3 4 5\" 1\n# 3\n# >>> count_arithmetic_triplets \"1 3 5 7 9\" 2\n# 4\ncount_arithmetic_triplets() {\nlocal nums=($1)\nlocal diff=$2",
      "ha": "#!/bin/bash\n\n# Ƙirga adadin triplets na lissafi masu bambanta a cikin jerin lambobi masu ƙaruwa da tsanani.\n# Triplet (i, j, k) yana da lissafi idan nums[j] - nums[i] == diff kuma nums[k] - nums[j] == diff.\n# Aiki yana ɗaukar kirtani da ke wakiltar jerin da kuma bambanci na lamba, tare da abubuwa da aka raba ta wurin sarari.\n# Yana dawowa da adadin triplets na lissafi masu bambanta.\n# >>> count_arithmetic_triplets \"1 2 3 4 5\" 1\n# 3\n# >>> count_arithmetic_triplets \"1 3 5 7 9\" 2\n# 4\ncount_arithmetic_triplets() {\nlocal nums=($1)\nlocal diff=$2",
      "hi": "#!/bin/bash\n\n# एक सख्ती से बढ़ती हुई पूर्णांक सरणी में भिन्न अंकगणितीय त्रिकों की संख्या गिनें।\n# एक त्रिक (i, j, k) अंकगणितीय है यदि nums[j] - nums[i] == diff और nums[k] - nums[j] == diff हो।\n# यह फ़ंक्शन एक स्ट्रिंग लेता है जो सरणी का प्रतिनिधित्व करता है और एक पूर्णांक diff, जिसमें तत्व स्पेस द्वारा अलग किए गए होते हैं।\n# भिन्न अंकगणितीय त्रिकों की संख्या लौटाता है।\n# >>> count_arithmetic_triplets \"1 2 3 4 5\" 1\n# 3\n# >>> count_arithmetic_triplets \"1 3 5 7 9\" 2\n# 4\ncount_arithmetic_triplets() {\nlocal nums=($1)\nlocal diff=$2",
      "hu": "#!/bin/bash\n\n# Számolja meg a különböző számtani tripletek számát egy szigorúan növekvő egész számokat tartalmazó tömbben.\n# Egy triplet (i, j, k) akkor számtani, ha nums[j] - nums[i] == diff és nums[k] - nums[j] == diff.\n# A függvény egy karakterláncot vesz át, amely a tömböt ábrázolja, és egy egész számot, diff-et, az elemek szóközökkel elválasztva.\n# Visszaadja a különböző számtani tripletek számát.\n# >>> count_arithmetic_triplets \"1 2 3 4 5\" 1\n# 3\n# >>> count_arithmetic_triplets \"1 3 5 7 9\" 2\n# 4\ncount_arithmetic_triplets() {\nlocal nums=($1)\nlocal diff=$2"
    },
    "prompt_bertscore": {
      "sq": "0.9868667578363542",
      "hy": "0.9876146012209506",
      "bn": "0.9945620960584078",
      "bg": "0.9852691736816906",
      "zh": "0.9711654234763084",
      "fr": "0.9924039769684638",
      "de": "0.9942426984057038",
      "ha": "0.9674522271332422",
      "hi": "0.9963295091888563",
      "hu": "0.9864579765121845"
    },
    "canonical_solution": "local count=0\n\nfor (( i=0; i<${#nums[@]}; i++ )); do\nfor (( j=i+1; j<${#nums[@]}; j++ )); do\nif (( nums[j] - nums[i] == diff )); then\nfor (( k=j+1; k<${#nums[@]}; k++ )); do\nif (( nums[k] - nums[j] == diff )); then\ncount=$((count + 1))\nfi\ndone\nfi\ndone\ndone\n\necho $count\n}",
    "instruction": {
      "en": "Write a Shell function `count_arithmetic_triplets() {\nlocal nums=($1)\nlocal diff=$2` to solve the following problem:\n\nCount the number of distinct arithmetic triplets in a strictly increasing integer array.\nA triplet (i, j, k) is arithmetic if nums[j] - nums[i] == diff and nums[k] - nums[j] == diff.\nThe function takes a string representing the array and an integer diff, with elements separated by spaces.\nReturns the count of distinct arithmetic triplets.\n>>> count_arithmetic_triplets \"1 2 3 4 5\" 1\n3\n>>> count_arithmetic_triplets \"1 3 5 7 9\" 2\n4\n",
      "sq": "Shkruani një funksion Shell `count_arithmetic_triplets() {\nlocal nums=($1)\nlocal diff=$2` për të zgjidhur problemin e mëposhtëm:\n\nNumëroni numrin e tresheve aritmetike të dallueshme në një varg të plotë numrash në rritje strikte.\nNjë treshe (i, j, k) është aritmetike nëse nums[j] - nums[i] == diff dhe nums[k] - nums[j] == diff.\nFunksioni merr një varg që përfaqëson vargun dhe një numër të plotë diff, me elemente të ndara nga hapësira.\nKthen numrin e tresheve aritmetike të dallueshme.\n>>> count_arithmetic_triplets \"1 2 3 4 5\" 1\n3\n>>> count_arithmetic_triplets \"1 3 5 7 9\" 2\n4",
      "hy": "Գրեք Shell ֆունկցիա `count_arithmetic_triplets() {\nlocal nums=($1)\nlocal diff=$2` հետևյալ խնդիրը լուծելու համար:\n\nՀաշվեք տարբեր թվաբանական եռյակների քանակը խիստ աճող ամբողջ թվերի զանգվածում:\nԵռյակը (i, j, k) թվաբանական է, եթե nums[j] - nums[i] == diff և nums[k] - nums[j] == diff:\nՖունկցիան ընդունում է զանգվածը ներկայացնող տող և ամբողջ թիվ diff, որի տարրերը բաժանված են բացատներով:\nՎերադարձնում է տարբեր թվաբանական եռյակների քանակը:\n>>> count_arithmetic_triplets \"1 2 3 4 5\" 1\n3\n>>> count_arithmetic_triplets \"1 3 5 7 9\" 2\n4",
      "bn": "একটি Shell ফাংশন লিখুন `count_arithmetic_triplets() {\nlocal nums=($1)\nlocal diff=$2` নিম্নলিখিত সমস্যাটি সমাধান করতে:\n\nএকটি কঠোরভাবে ক্রমবর্ধমান পূর্ণসংখ্যার অ্যারেতে পৃথক গাণিতিক ট্রিপলেটের সংখ্যা গণনা করুন।\nএকটি ট্রিপলেট (i, j, k) গাণিতিক যদি nums[j] - nums[i] == diff এবং nums[k] - nums[j] == diff হয়।\nফাংশনটি একটি স্ট্রিং নেয় যা অ্যারে এবং একটি পূর্ণসংখ্যা diff উপস্থাপন করে, যেখানে উপাদানগুলি স্পেস দ্বারা পৃথক করা থাকে।\nপৃথক গাণিতিক ট্রিপলেটের সংখ্যা ফেরত দেয়।\n>>> count_arithmetic_triplets \"1 2 3 4 5\" 1\n3\n>>> count_arithmetic_triplets \"1 3 5 7 9\" 2\n4",
      "bg": "Напишете Shell функция `count_arithmetic_triplets() {\nlocal nums=($1)\nlocal diff=$2`, за да решите следния проблем:\n\nБройте броя на различните аритметични тройки в строго нарастващ масив от цели числа.\nТройка (i, j, k) е аритметична, ако nums[j] - nums[i] == diff и nums[k] - nums[j] == diff.\nФункцията приема низ, представляващ масива, и цяло число diff, с елементи, разделени с интервали.\nВръща броя на различните аритметични тройки.\n>>> count_arithmetic_triplets \"1 2 3 4 5\" 1\n3\n>>> count_arithmetic_triplets \"1 3 5 7 9\" 2\n4",
      "zh": "编写一个 Shell 函数 `count_arithmetic_triplets() {\nlocal nums=($1)\nlocal diff=$2` 来解决以下问题：\n\n计算严格递增整数数组中不同的等差三元组的数量。\n如果三元组 (i, j, k) 满足 nums[j] - nums[i] == diff 且 nums[k] - nums[j] == diff，则该三元组是等差的。\n该函数接收一个表示数组的字符串和一个整数 diff，数组元素用空格分隔。\n返回不同等差三元组的数量。\n>>> count_arithmetic_triplets \"1 2 3 4 5\" 1\n3\n>>> count_arithmetic_triplets \"1 3 5 7 9\" 2\n4",
      "fr": "Écrire une fonction Shell `count_arithmetic_triplets() {\nlocal nums=($1)\nlocal diff=$2` pour résoudre le problème suivant :\n\nCompter le nombre de triplets arithmétiques distincts dans un tableau d'entiers strictement croissant.\nUn triplet (i, j, k) est arithmétique si nums[j] - nums[i] == diff et nums[k] - nums[j] == diff.\nLa fonction prend une chaîne représentant le tableau et un entier diff, avec des éléments séparés par des espaces.\nRetourne le nombre de triplets arithmétiques distincts.\n>>> count_arithmetic_triplets \"1 2 3 4 5\" 1\n3\n>>> count_arithmetic_triplets \"1 3 5 7 9\" 2\n4",
      "de": "Schreiben Sie eine Shell-Funktion `count_arithmetic_triplets() {\nlocal nums=($1)\nlocal diff=$2`, um das folgende Problem zu lösen:\n\nZählen Sie die Anzahl der unterschiedlichen arithmetischen Tripel in einem streng zunehmenden Ganzzahl-Array.\nEin Tripel (i, j, k) ist arithmetisch, wenn nums[j] - nums[i] == diff und nums[k] - nums[j] == diff.\nDie Funktion nimmt einen String, der das Array darstellt, und eine Ganzzahl diff, mit durch Leerzeichen getrennten Elementen.\nGibt die Anzahl der unterschiedlichen arithmetischen Tripel zurück.\n>>> count_arithmetic_triplets \"1 2 3 4 5\" 1\n3\n>>> count_arithmetic_triplets \"1 3 5 7 9\" 2\n4",
      "ha": "Rubuta aikin Shell `count_arithmetic_triplets() {\nlocal nums=($1)\nlocal diff=$2` don warware matsalar mai zuwa:\n\nƘididdige yawan triplets na arithmetic masu bambanci a cikin jerin lambobi masu ƙaruwa sosai.\nTriplet (i, j, k) yana da arithmetic idan nums[j] - nums[i] == diff kuma nums[k] - nums[j] == diff.\nAikin yana ɗaukar igiyar da ke wakiltar jerin da kuma integer diff, tare da abubuwan da aka raba ta wurin sarari.\nYana dawo da ƙididdigar triplets na arithmetic masu bambanci.\n>>> count_arithmetic_triplets \"1 2 3 4 5\" 1\n3\n>>> count_arithmetic_triplets \"1 3 5 7 9\" 2\n4",
      "hi": "एक Shell फ़ंक्शन `count_arithmetic_triplets() {\nlocal nums=($1)\nlocal diff=$2` लिखें ताकि निम्नलिखित समस्या का समाधान किया जा सके:\n\nएक सख्ती से बढ़ती हुई पूर्णांक सरणी में विशिष्ट अंकगणितीय त्रिकों की संख्या गिनें।\nएक त्रिक (i, j, k) अंकगणितीय होता है यदि nums[j] - nums[i] == diff और nums[k] - nums[j] == diff।\nयह फ़ंक्शन एक स्ट्रिंग लेता है जो सरणी का प्रतिनिधित्व करता है और एक पूर्णांक diff, जिसमें तत्व स्पेस द्वारा अलग किए गए होते हैं।\nविशिष्ट अंकगणितीय त्रिकों की गिनती लौटाता है।\n>>> count_arithmetic_triplets \"1 2 3 4 5\" 1\n3\n>>> count_arithmetic_triplets \"1 3 5 7 9\" 2\n4",
      "hu": "Írj egy Shell függvényt `count_arithmetic_triplets() {\nlocal nums=($1)\nlocal diff=$2` a következő probléma megoldására:\n\nSzámold meg a különböző számtani hármasok számát egy szigorúan növekvő egész számokat tartalmazó tömbben.\nEgy hármas (i, j, k) számtani, ha nums[j] - nums[i] == diff és nums[k] - nums[j] == diff.\nA függvény egy karakterláncot vesz át, amely a tömböt reprezentálja, és egy egész számot, diff-et, az elemek szóközzel elválasztva.\nVisszaadja a különböző számtani hármasok számát.\n>>> count_arithmetic_triplets \"1 2 3 4 5\" 1\n3\n>>> count_arithmetic_triplets \"1 3 5 7 9\" 2\n4"
    },
    "instruction_bertscore": {
      "sq": "0.9840291242128898",
      "hy": "0.9840247543445071",
      "bn": "0.9947128565176133",
      "bg": "0.9899350013322001",
      "zh": "0.9836757607650287",
      "fr": "0.9976380861391142",
      "de": "0.9948844731668275",
      "ha": "0.9569512347790707",
      "hi": "0.9938289513220081",
      "hu": "0.9800952495164938"
    },
    "level": "easy",
    "test": "test_count_arithmetic_triplets() {\n[[ $(count_arithmetic_triplets \"1 2 3 4 5\" 1) == \"3\" ]] || { echo \"Test 1 failed\"; exit 1; }\n[[ $(count_arithmetic_triplets \"1 3 5 7 9\" 2) == \"3\" ]] || { echo \"Test 2 failed\"; exit 1; }\n[[ $(count_arithmetic_triplets \"2 4 6 8 10\" 2) == \"3\" ]] || { echo \"Test 3 failed\"; exit 1; }\n[[ $(count_arithmetic_triplets \"1 4 7 10 13\" 3) == \"3\" ]] || { echo \"Test 4 failed\"; exit 1; }\n[[ $(count_arithmetic_triplets \"1 2 4 5 7\" 2) == \"0\" ]] || { echo \"Test 5 failed\"; exit 1; }\n[[ $(count_arithmetic_triplets \"1 5 9 13 17\" 4) == \"3\" ]] || { echo \"Test 6 failed\"; exit 1; }\n[[ $(count_arithmetic_triplets \"10 20 30 40 50\" 10) == \"3\" ]] || { echo \"Test 7 failed\"; exit 1; }\n}\n\ntest_count_arithmetic_triplets",
    "entry_point": "count_arithmetic_triplets",
    "signature": "count_arithmetic_triplets() {\nlocal nums=($1)\nlocal diff=$2",
    "docstring": {
      "en": "\nCount the number of distinct arithmetic triplets in a strictly increasing integer array.\nA triplet (i, j, k) is arithmetic if nums[j] - nums[i] == diff and nums[k] - nums[j] == diff.\nThe function takes a string representing the array and an integer diff, with elements separated by spaces.\nReturns the count of distinct arithmetic triplets.\n>>> count_arithmetic_triplets \"1 2 3 4 5\" 1\n3\n>>> count_arithmetic_triplets \"1 3 5 7 9\" 2\n4\n",
      "sq": "Numëroni numrin e tresheve aritmetike të dallueshme në një varg të plotë rritës në mënyrë strikte.\nNjë treshe (i, j, k) është aritmetike nëse nums[j] - nums[i] == diff dhe nums[k] - nums[j] == diff.\nFunksioni merr një varg që përfaqëson vargun dhe një numër të plotë diff, me elemente të ndara me hapësira.\nKthen numrin e tresheve aritmetike të dallueshme.\n>>> count_arithmetic_triplets \"1 2 3 4 5\" 1\n3\n>>> count_arithmetic_triplets \"1 3 5 7 9\" 2\n4",
      "hy": "Հաշվել տարբեր թվաբանական եռյակների քանակը խիստ աճող ամբողջ թվերի զանգվածում։  \nԵռյակը (i, j, k) թվաբանական է, եթե nums[j] - nums[i] == diff և nums[k] - nums[j] == diff։  \nՖունկցիան ընդունում է զանգվածը ներկայացնող տող և ամբողջ թիվ diff, որոնց տարրերը բաժանված են բացատներով։  \nՎերադարձնում է տարբեր թվաբանական եռյակների քանակը։  \n>>> count_arithmetic_triplets \"1 2 3 4 5\" 1  \n3  \n>>> count_arithmetic_triplets \"1 3 5 7 9\" 2  \n4  ",
      "bn": "Count the number of distinct arithmetic triplets in a strictly increasing integer array.  \nএকটি কঠোরভাবে ক্রমবর্ধমান পূর্ণসংখ্যা অ্যারেতে পৃথক গাণিতিক ট্রিপলেটের সংখ্যা গণনা করুন।  \nA triplet (i, j, k) is arithmetic if nums[j] - nums[i] == diff and nums[k] - nums[j] == diff.  \nএকটি ট্রিপলেট (i, j, k) গাণিতিক যদি nums[j] - nums[i] == diff এবং nums[k] - nums[j] == diff হয়।  \nThe function takes a string representing the array and an integer diff, with elements separated by spaces.  \nফাংশনটি একটি স্ট্রিং নেয় যা অ্যারেটিকে উপস্থাপন করে এবং একটি পূর্ণসংখ্যা diff, যেখানে উপাদানগুলি স্পেস দ্বারা পৃথক করা হয়।  \nReturns the count of distinct arithmetic triplets.  \nপৃথক গাণিতিক ট্রিপলেটের সংখ্যা ফেরত দেয়।  \n>>> count_arithmetic_triplets \"1 2 3 4 5\" 1  \n3  \n>>> count_arithmetic_triplets \"1 3 5 7 9\" 2  \n4  ",
      "bg": "Бройте броя на различните аритметични тройки в строго нарастващ масив от цели числа.\nТройка (i, j, k) е аритметична, ако nums[j] - nums[i] == diff и nums[k] - nums[j] == diff.\nФункцията приема низ, представляващ масива, и цяло число diff, с елементи, разделени с интервали.\nВръща броя на различните аритметични тройки.\n>>> count_arithmetic_triplets \"1 2 3 4 5\" 1\n3\n>>> count_arithmetic_triplets \"1 3 5 7 9\" 2\n4",
      "zh": "计算严格递增整数数组中不同的算术三元组的数量。  \n如果三元组 (i, j, k) 满足 nums[j] - nums[i] == diff 且 nums[k] - nums[j] == diff，则称其为算术三元组。  \n该函数接收一个表示数组的字符串和一个整数 diff，数组元素以空格分隔。  \n返回不同算术三元组的数量。  \n>>> count_arithmetic_triplets \"1 2 3 4 5\" 1  \n3  \n>>> count_arithmetic_triplets \"1 3 5 7 9\" 2  \n4  ",
      "fr": "Compter le nombre de triplets arithmétiques distincts dans un tableau d'entiers strictement croissant.  \nUn triplet (i, j, k) est arithmétique si nums[j] - nums[i] == diff et nums[k] - nums[j] == diff.  \nLa fonction prend une chaîne représentant le tableau et un entier diff, avec des éléments séparés par des espaces.  \nRetourne le nombre de triplets arithmétiques distincts.  \n>>> count_arithmetic_triplets \"1 2 3 4 5\" 1  \n3  \n>>> count_arithmetic_triplets \"1 3 5 7 9\" 2  \n4  ",
      "de": "Zähle die Anzahl der unterschiedlichen arithmetischen Tripel in einem streng zunehmenden Ganzzahl-Array.\nEin Tripel (i, j, k) ist arithmetisch, wenn nums[j] - nums[i] == diff und nums[k] - nums[j] == diff.\nDie Funktion nimmt einen String, der das Array darstellt, und eine ganze Zahl diff, wobei die Elemente durch Leerzeichen getrennt sind.\nGibt die Anzahl der unterschiedlichen arithmetischen Tripel zurück.\n>>> count_arithmetic_triplets \"1 2 3 4 5\" 1\n3\n>>> count_arithmetic_triplets \"1 3 5 7 9\" 2\n4",
      "ha": "Kirga adadin nau'ikan triplet na lissafi a cikin jerin lambobi masu ƙaruwa daidai.\nTriplet (i, j, k) yana da lissafi idan nums[j] - nums[i] == diff kuma nums[k] - nums[j] == diff.\nAikin yana ɗaukar kirtani da ke wakiltar jerin da kuma cikakken lamba diff, tare da abubuwan da aka raba ta wurin sarari.\nYana mayar da adadin nau'ikan triplet na lissafi.\n>>> count_arithmetic_triplets \"1 2 3 4 5\" 1\n3\n>>> count_arithmetic_triplets \"1 3 5 7 9\" 2\n4",
      "hi": "सख्त रूप से बढ़ते हुए पूर्णांक सरणी में भिन्न अंकगणितीय त्रिकों की संख्या गिनें।\nएक त्रिक (i, j, k) अंकगणितीय होता है यदि nums[j] - nums[i] == diff और nums[k] - nums[j] == diff।\nयह फ़ंक्शन एक स्ट्रिंग लेता है जो सरणी का प्रतिनिधित्व करता है और एक पूर्णांक diff, जिसमें तत्व स्पेस द्वारा अलग होते हैं।\nभिन्न अंकगणितीय त्रिकों की गिनती लौटाता है।\n>>> count_arithmetic_triplets \"1 2 3 4 5\" 1\n3\n>>> count_arithmetic_triplets \"1 3 5 7 9\" 2\n4",
      "hu": "Számolja meg a különböző számtani hármasok számát egy szigorúan növekvő egész számokat tartalmazó tömbben.\nEgy hármas (i, j, k) akkor számtani, ha nums[j] - nums[i] == diff és nums[k] - nums[j] == diff.\nA függvény egy karakterláncot vesz át, amely a tömböt reprezentálja, és egy egész számot, diff-et, az elemek szóközzel elválasztva.\nVisszaadja a különböző számtani hármasok számát.\n>>> count_arithmetic_triplets \"1 2 3 4 5\" 1\n3\n>>> count_arithmetic_triplets \"1 3 5 7 9\" 2\n4"
    },
    "docstring_bertscore": {
      "sq": "0.9883507254130659",
      "hy": "0.9740993928345747",
      "bn": "0.999999801369619",
      "bg": "0.9906870159547982",
      "zh": "0.9570155910225261",
      "fr": "0.9906870159547982",
      "de": "0.996937318154823",
      "ha": "0.9676363574964615",
      "hi": "0.9983811623945656",
      "hu": "0.9721583767511018"
    }
  },
  {
    "task_id": "Shell/10",
    "prompt": {
      "en": "#!/bin/bash\n\n# Generate a matrix of maximum values from each 3x3 sub-matrix in a given n x n matrix.\n# The function takes a string representing the n x n matrix, where rows are separated by semicolons and elements by spaces.\n# Returns the (n-2) x (n-2) matrix of maximum values.\n# >>> generate_max_local \"1 2 3 4;5 6 7 8;9 10 11 12;13 14 15 16\"\n# 11 12;15 16\n# >>> generate_max_local \"9 1 7;4 8 2;3 6 5\"\n# 9 8\ngenerate_max_local() {\nlocal -a grid\nIFS=';' read -ra grid <<< \"$1\"",
      "sq": "#!/bin/bash\n\n# Gjenero një matricë të vlerave maksimale nga secila nën-matricë 3x3 në një matricë të dhënë n x n.\n# Funksioni merr një varg që përfaqëson matricën n x n, ku rreshtat ndahen me pikëpresje dhe elementet me hapësira.\n# Kthen matricën (n-2) x (n-2) të vlerave maksimale.\n# >>> generate_max_local \"1 2 3 4;5 6 7 8;9 10 11 12;13 14 15 16\"\n# 11 12;15 16\n# >>> generate_max_local \"9 1 7;4 8 2;3 6 5\"\n# 9 8\ngenerate_max_local() {\nlocal -a grid\nIFS=';' read -ra grid <<< \"$1\"",
      "hy": "#!/bin/bash\n\n# Ստեղծել առավելագույն արժեքների մատրիցա յուրաքանչյուր 3x3 ենթամատրիցայից տրված n x n մատրիցայում:\n# Ֆունկցիան ընդունում է տող, որը ներկայացնում է n x n մատրիցան, որտեղ տողերը բաժանված են կետ-ստորակետներով, իսկ տարրերը՝ բացատներով:\n# Վերադարձնում է առավելագույն արժեքների (n-2) x (n-2) մատրիցան:\n# >>> generate_max_local \"1 2 3 4;5 6 7 8;9 10 11 12;13 14 15 16\"\n# 11 12;15 16\n# >>> generate_max_local \"9 1 7;4 8 2;3 6 5\"\n# 9 8\ngenerate_max_local() {\nlocal -a grid\nIFS=';' read -ra grid <<< \"$1\"",
      "bn": "#!/bin/bash\n\n# প্রদত্ত n x n ম্যাট্রিক্সের প্রতিটি 3x3 উপ-ম্যাট্রিক্স থেকে সর্বোচ্চ মানগুলোর একটি ম্যাট্রিক্স তৈরি করুন।\n# ফাংশনটি একটি স্ট্রিং নেয় যা n x n ম্যাট্রিক্সকে উপস্থাপন করে, যেখানে সারিগুলি সেমিকোলন দ্বারা পৃথক এবং উপাদানগুলি স্পেস দ্বারা পৃথক হয়।\n# সর্বোচ্চ মানগুলোর (n-2) x (n-2) ম্যাট্রিক্সটি রিটার্ন করে।\n# >>> generate_max_local \"1 2 3 4;5 6 7 8;9 10 11 12;13 14 15 16\"\n# 11 12;15 16\n# >>> generate_max_local \"9 1 7;4 8 2;3 6 5\"\n# 9 8\ngenerate_max_local() {\nlocal -a grid\nIFS=';' read -ra grid <<< \"$1\"",
      "bg": "#!/bin/bash\n\n# Генерира матрица от максимални стойности от всяка 3x3 подматрица в дадена n x n матрица.\n# Функцията приема низ, представляващ n x n матрица, където редовете са разделени със запетаи, а елементите с интервали.\n# Връща (n-2) x (n-2) матрица от максимални стойности.\n# >>> generate_max_local \"1 2 3 4;5 6 7 8;9 10 11 12;13 14 15 16\"\n# 11 12;15 16\n# >>> generate_max_local \"9 1 7;4 8 2;3 6 5\"\n# 9 8\ngenerate_max_local() {\nlocal -a grid\nIFS=';' read -ra grid <<< \"$1\"",
      "zh": "#!/bin/bash\n\n# 从给定的 n x n 矩阵中生成每个 3x3 子矩阵的最大值矩阵。\n# 该函数接受一个表示 n x n 矩阵的字符串，其中行用分号分隔，元素用空格分隔。\n# 返回 (n-2) x (n-2) 的最大值矩阵。\n# >>> generate_max_local \"1 2 3 4;5 6 7 8;9 10 11 12;13 14 15 16\"\n# 11 12;15 16\n# >>> generate_max_local \"9 1 7;4 8 2;3 6 5\"\n# 9 8\ngenerate_max_local() {\nlocal -a grid\nIFS=';' read -ra grid <<< \"$1\"",
      "fr": "#!/bin/bash\n\n# Générer une matrice des valeurs maximales de chaque sous-matrice 3x3 dans une matrice n x n donnée.\n# La fonction prend une chaîne représentant la matrice n x n, où les lignes sont séparées par des points-virgules et les éléments par des espaces.\n# Retourne la matrice (n-2) x (n-2) des valeurs maximales.\n# >>> generate_max_local \"1 2 3 4;5 6 7 8;9 10 11 12;13 14 15 16\"\n# 11 12;15 16\n# >>> generate_max_local \"9 1 7;4 8 2;3 6 5\"\n# 9 8\ngenerate_max_local() {\nlocal -a grid\nIFS=';' read -ra grid <<< \"$1\"",
      "de": "#!/bin/bash\n\n# Erzeugt eine Matrix von Maximalwerten aus jeder 3x3-Submatrix in einer gegebenen n x n-Matrix.\n# Die Funktion nimmt einen String, der die n x n-Matrix repräsentiert, wobei die Zeilen durch Semikolons und die Elemente durch Leerzeichen getrennt sind.\n# Gibt die (n-2) x (n-2) Matrix der Maximalwerte zurück.\n# >>> generate_max_local \"1 2 3 4;5 6 7 8;9 10 11 12;13 14 15 16\"\n# 11 12;15 16\n# >>> generate_max_local \"9 1 7;4 8 2;3 6 5\"\n# 9 8\ngenerate_max_local() {\nlocal -a grid\nIFS=';' read -ra grid <<< \"$1\"",
      "ha": "#!/bin/bash\n\n# Ƙirƙiri matrix na ƙimar matsakaici daga kowace matrix 3x3 a cikin matrix n x n da aka bayar.\n# Aikin yana ɗaukar wani igiyar da ke wakiltar matrix n x n, inda aka raba layuka da semicolons kuma abubuwa da sarari.\n# Yana mayar da matrix (n-2) x (n-2) na ƙimar matsakaici.\n# >>> generate_max_local \"1 2 3 4;5 6 7 8;9 10 11 12;13 14 15 16\"\n# 11 12;15 16\n# >>> generate_max_local \"9 1 7;4 8 2;3 6 5\"\n# 9 8\ngenerate_max_local() {\nlocal -a grid\nIFS=';' read -ra grid <<< \"$1\"",
      "hi": "#!/bin/bash\n\n# दिए गए n x n मैट्रिक्स में प्रत्येक 3x3 उप-मैट्रिक्स से अधिकतम मानों का मैट्रिक्स उत्पन्न करें।\n# यह फ़ंक्शन एक स्ट्रिंग लेता है जो n x n मैट्रिक्स का प्रतिनिधित्व करता है, जहाँ पंक्तियाँ सेमीकोलन द्वारा और तत्व स्पेस द्वारा अलग होते हैं।\n# अधिकतम मानों का (n-2) x (n-2) मैट्रिक्स लौटाता है।\n# >>> generate_max_local \"1 2 3 4;5 6 7 8;9 10 11 12;13 14 15 16\"\n# 11 12;15 16\n# >>> generate_max_local \"9 1 7;4 8 2;3 6 5\"\n# 9 8\ngenerate_max_local() {\nlocal -a grid\nIFS=';' read -ra grid <<< \"$1\"",
      "hu": "#!/bin/bash\n\n# Generál egy mátrixot, amely az egyes 3x3-as rész-mátrixok maximális értékeit tartalmazza egy adott n x n mátrixból.\n# A függvény egy karakterláncot vesz át, amely az n x n mátrixot reprezentálja, ahol a sorokat pontosvesszők, az elemeket pedig szóközök választják el.\n# Visszaadja az (n-2) x (n-2) mátrixot a maximális értékekkel.\n# >>> generate_max_local \"1 2 3 4;5 6 7 8;9 10 11 12;13 14 15 16\"\n# 11 12;15 16\n# >>> generate_max_local \"9 1 7;4 8 2;3 6 5\"\n# 9 8\ngenerate_max_local() {\nlocal -a grid\nIFS=';' read -ra grid <<< \"$1\""
    },
    "prompt_bertscore": {
      "sq": "1",
      "hy": "0.9845004741070856",
      "bn": "0.9811021069179597",
      "bg": "0.98244762911909",
      "zh": "0.9808279969921315",
      "fr": "0.993532396163123",
      "de": "0.9962335707148164",
      "ha": "0.955910610212829",
      "hi": "0.9850109541863453",
      "hu": "0.9812337988605858"
    },
    "canonical_solution": "local -a maxLocal\nlocal n=${#grid[@]}\n\nfor (( i=0; i<n-2; i++ )); do\nlocal row=\"\"\nfor (( j=0; j<n-2; j++ )); do\nlocal max=0\nfor (( x=i; x<=i+2; x++ )); do\nIFS=' ' read -ra rowVals <<< \"${grid[x]}\"\nfor (( y=j; y<=j+2; y++ )); do\nmax=$((max < rowVals[y] ? rowVals[y] : max))\ndone\ndone\nrow+=\"$max \"\ndone\nmaxLocal+=(\"${row% }\")\ndone\n\necho \"${maxLocal[@]}\"\n}",
    "instruction": {
      "en": "Write a Shell function `generate_max_local() {\nlocal -a grid\nIFS=';' read -ra grid <<< \"$1\"` to solve the following problem:\n\nGenerate a matrix of maximum values from each 3x3 sub-matrix in a given n x n matrix.\nThe function takes a string representing the n x n matrix, where rows are separated by semicolons and elements by spaces.\nReturns the (n-2) x (n-2) matrix of maximum values.\n>>> generate_max_local \"1 2 3 4;5 6 7 8;9 10 11 12;13 14 15 16\"\n11 12;15 16\n>>> generate_max_local \"9 1 7;4 8 2;3 6 5\"\n9 8\n",
      "sq": "Shkruani një funksion Shell `generate_max_local() {\nlocal -a grid\nIFS=';' read -ra grid <<< \"$1\"` për të zgjidhur problemin e mëposhtëm:\n\nGjeneroni një matricë me vlerat maksimale nga secila nën-matricë 3x3 në një matricë të dhënë n x n.\nFunksioni merr një varg që përfaqëson matricën n x n, ku rreshtat ndahen me pikëpresje dhe elementet me hapësira.\nKthen matricën (n-2) x (n-2) të vlerave maksimale.\n>>> generate_max_local \"1 2 3 4;5 6 7 8;9 10 11 12;13 14 15 16\"\n11 12;15 16\n>>> generate_max_local \"9 1 7;4 8 2;3 6 5\"\n9 8",
      "hy": "Գրեք Shell ֆունկցիա `generate_max_local() {\nlocal -a grid\nIFS=';' read -ra grid <<< \"$1\"` հետևյալ խնդիրը լուծելու համար:\n\nՍտեղծել առավելագույն արժեքների մատրիցա յուրաքանչյուր 3x3 ենթամատրիցայից տրված n x n մատրիցայում:\nՖունկցիան ընդունում է տող, որը ներկայացնում է n x n մատրիցան, որտեղ տողերը բաժանված են կետ-ստորակետերով, իսկ տարրերը՝ բացատներով:\nՎերադարձնում է (n-2) x (n-2) մատրիցա առավելագույն արժեքներով:\n>>> generate_max_local \"1 2 3 4;5 6 7 8;9 10 11 12;13 14 15 16\"\n11 12;15 16\n>>> generate_max_local \"9 1 7;4 8 2;3 6 5\"\n9 8",
      "bn": "একটি Shell ফাংশন লিখুন `generate_max_local() {\nlocal -a grid\nIFS=';' read -ra grid <<< \"$1\"` নিম্নলিখিত সমস্যার সমাধানের জন্য:\n\nপ্রদত্ত n x n ম্যাট্রিক্সের প্রতিটি 3x3 সাব-ম্যাট্রিক্স থেকে সর্বাধিক মানগুলির একটি ম্যাট্রিক্স তৈরি করুন।\nফাংশনটি একটি স্ট্রিং নেয় যা n x n ম্যাট্রিক্সকে উপস্থাপন করে, যেখানে সারিগুলি সেমিকোলন দ্বারা এবং উপাদানগুলি স্পেস দ্বারা পৃথক করা হয়।\n(n-2) x (n-2) ম্যাট্রিক্স সর্বাধিক মানগুলির রিটার্ন করে।\n>>> generate_max_local \"1 2 3 4;5 6 7 8;9 10 11 12;13 14 15 16\"\n11 12;15 16\n>>> generate_max_local \"9 1 7;4 8 2;3 6 5\"\n9 8",
      "bg": "Напишете Shell функция `generate_max_local() {\nlocal -a grid\nIFS=';' read -ra grid <<< \"$1\"` за решаване на следния проблем:\n\nГенерирайте матрица от максимални стойности от всяка 3x3 подматрица в дадена n x n матрица.\nФункцията приема низ, представляващ n x n матрица, където редовете са разделени със запетаи, а елементите - с интервали.\nВръща (n-2) x (n-2) матрица от максимални стойности.\n>>> generate_max_local \"1 2 3 4;5 6 7 8;9 10 11 12;13 14 15 16\"\n11 12;15 16\n>>> generate_max_local \"9 1 7;4 8 2;3 6 5\"\n9 8",
      "zh": "编写一个 Shell 函数 `generate_max_local() {\nlocal -a grid\nIFS=';' read -ra grid <<< \"$1\"` 来解决以下问题：\n\n生成一个矩阵，其中每个 3x3 子矩阵的最大值来自给定的 n x n 矩阵。  \n该函数接受一个表示 n x n 矩阵的字符串，其中行用分号分隔，元素用空格分隔。  \n返回 (n-2) x (n-2) 的最大值矩阵。  \n>>> generate_max_local \"1 2 3 4;5 6 7 8;9 10 11 12;13 14 15 16\"\n11 12;15 16\n>>> generate_max_local \"9 1 7;4 8 2;3 6 5\"\n9 8",
      "fr": "Écrire une fonction Shell `generate_max_local() {\nlocal -a grid\nIFS=';' read -ra grid <<< \"$1\"` pour résoudre le problème suivant :\n\nGénérer une matrice des valeurs maximales de chaque sous-matrice 3x3 dans une matrice n x n donnée.\nLa fonction prend une chaîne représentant la matrice n x n, où les lignes sont séparées par des points-virgules et les éléments par des espaces.\nRetourne la matrice (n-2) x (n-2) des valeurs maximales.\n>>> generate_max_local \"1 2 3 4;5 6 7 8;9 10 11 12;13 14 15 16\"\n11 12;15 16\n>>> generate_max_local \"9 1 7;4 8 2;3 6 5\"\n9 8\n",
      "de": "Schreiben Sie eine Shell-Funktion `generate_max_local() {\nlocal -a grid\nIFS=';' read -ra grid <<< \"$1\"` um das folgende Problem zu lösen:\n\nErzeugen Sie eine Matrix der Maximalwerte aus jeder 3x3-Submatrix in einer gegebenen n x n-Matrix.\nDie Funktion nimmt einen String entgegen, der die n x n-Matrix darstellt, wobei Zeilen durch Semikolons und Elemente durch Leerzeichen getrennt sind.\nGibt die (n-2) x (n-2) Matrix der Maximalwerte zurück.\n>>> generate_max_local \"1 2 3 4;5 6 7 8;9 10 11 12;13 14 15 16\"\n11 12;15 16\n>>> generate_max_local \"9 1 7;4 8 2;3 6 5\"\n9 8",
      "ha": "Rubuta aikin Shell `generate_max_local() {\nlocal -a grid\nIFS=';' read -ra grid <<< \"$1\"` don warware matsalar mai zuwa:\n\nƘirƙiri matrix na ƙimar matsakaicin daga kowanne matrix 3x3 a cikin matrix n x n da aka bayar.\nAikin yana ɗaukar kirtani mai wakiltar matrix n x n, inda aka raba layuka da semicolons kuma abubuwa da sarari.\nYana mayar da matrix (n-2) x (n-2) na ƙimar matsakaicin.\n>>> generate_max_local \"1 2 3 4;5 6 7 8;9 10 11 12;13 14 15 16\"\n11 12;15 16\n>>> generate_max_local \"9 1 7;4 8 2;3 6 5\"\n9 8",
      "hi": "शेल फ़ंक्शन `generate_max_local() {\nlocal -a grid\nIFS=';' read -ra grid <<< \"$1\"` निम्नलिखित समस्या को हल करने के लिए:\n\nप्रत्येक 3x3 उप-मैट्रिक्स से अधिकतम मानों की एक मैट्रिक्स उत्पन्न करें जो एक दिए गए n x n मैट्रिक्स में है।\nयह फ़ंक्शन एक स्ट्रिंग लेता है जो n x n मैट्रिक्स का प्रतिनिधित्व करती है, जहाँ पंक्तियाँ सेमीकोलन द्वारा और तत्व स्पेस द्वारा अलग होते हैं।\n(n-2) x (n-2) मैट्रिक्स अधिकतम मानों की लौटाता है।\n>>> generate_max_local \"1 2 3 4;5 6 7 8;9 10 11 12;13 14 15 16\"\n11 12;15 16\n>>> generate_max_local \"9 1 7;4 8 2;3 6 5\"\n9 8",
      "hu": "Írj egy Shell függvényt `generate_max_local() {\nlocal -a grid\nIFS=';' read -ra grid <<< \"$1\"` a következő probléma megoldására:\n\nGenerálj egy mátrixot, amely a maximális értékeket tartalmazza minden 3x3-as rész-mátrixból egy adott n x n mátrixban.\nA függvény egy karakterláncot vesz át, amely az n x n mátrixot reprezentálja, ahol a sorokat pontosvesszők választják el, és az elemeket szóközök.\nVisszaadja az (n-2) x (n-2) mátrixot a maximális értékekkel.\n>>> generate_max_local \"1 2 3 4;5 6 7 8;9 10 11 12;13 14 15 16\"\n11 12;15 16\n>>> generate_max_local \"9 1 7;4 8 2;3 6 5\"\n9 8"
    },
    "instruction_bertscore": {
      "sq": "0.9928113678799664",
      "hy": "0.9830961573131689",
      "bn": "0.9892032470084676",
      "bg": "0.9823373892576157",
      "zh": "0.9507035147739994",
      "fr": "0.9946739249629305",
      "de": "0.9951705009155177",
      "ha": "0.969608955810519",
      "hi": "0.8957784404406132",
      "hu": "0.972825576200998"
    },
    "level": "easy",
    "test": "# Testing function\ntest_generate_max_local() {\n[[ $(generate_max_local \"1 2 3 4;5 6 7 8;9 10 11 12;13 14 15 16\") == \"11 12 15 16\" ]] || { echo \"Test 1 failed\"; exit 1; }\n[[ $(generate_max_local \"9 1 7;4 8 2;3 6 5\") == \"9\" ]] || { echo \"Test 2 failed\"; exit 1; }\n[[ $(generate_max_local \"1 2 3;4 5 6;7 8 9\") == \"9\" ]] || { echo \"Test 3 failed\"; exit 1; }\n[[ $(generate_max_local \"5 6 7;8 9 10;11 12 13\") == \"13\" ]] || { echo \"Test 4 failed\"; exit 1; }\n[[ $(generate_max_local \"10 20 30;40 50 60;70 80 90\") == \"90\" ]] || { echo \"Test 5 failed\"; exit 1; }\n}\n\ntest_generate_max_local",
    "entry_point": "generate_max_local",
    "signature": "generate_max_local() {\nlocal -a grid\nIFS=';' read -ra grid <<< \"$1\"",
    "docstring": {
      "en": "\nGenerate a matrix of maximum values from each 3x3 sub-matrix in a given n x n matrix.\nThe function takes a string representing the n x n matrix, where rows are separated by semicolons and elements by spaces.\nReturns the (n-2) x (n-2) matrix of maximum values.\n>>> generate_max_local \"1 2 3 4;5 6 7 8;9 10 11 12;13 14 15 16\"\n11 12;15 16\n>>> generate_max_local \"9 1 7;4 8 2;3 6 5\"\n9 8\n",
      "sq": "Gjenero një matricë të vlerave maksimale nga secila nën-matricë 3x3 në një matricë të dhënë n x n.\nFunksioni merr një varg që përfaqëson matricën n x n, ku rreshtat ndahen me pikëpresje dhe elementet me hapësira.\nKthen matricën (n-2) x (n-2) të vlerave maksimale.\n>>> generate_max_local \"1 2 3 4;5 6 7 8;9 10 11 12;13 14 15 16\"\n11 12;15 16\n>>> generate_max_local \"9 1 7;4 8 2;3 6 5\"\n9 8",
      "hy": "Ստեղծել մատրիցա, որը պարունակում է առավելագույն արժեքները յուրաքանչյուր 3x3 ենթամատրիցից տրված n x n մատրիցայում:\nՖունկցիան ընդունում է տող, որը ներկայացնում է n x n մատրիցան, որտեղ տողերը բաժանված են կետ-ստորակետներով, իսկ տարրերը՝ բացատներով:\nՎերադարձնում է առավելագույն արժեքների (n-2) x (n-2) մատրիցան:\n>>> generate_max_local \"1 2 3 4;5 6 7 8;9 10 11 12;13 14 15 16\"\n11 12;15 16\n>>> generate_max_local \"9 1 7;4 8 2;3 6 5\"\n9 8",
      "bn": "প্রতিটি 3x3 উপ-ম্যাট্রিক্স থেকে সর্বাধিক মানগুলির একটি ম্যাট্রিক্স তৈরি করুন একটি প্রদত্ত n x n ম্যাট্রিক্স থেকে।\nফাংশনটি একটি স্ট্রিং নেয় যা n x n ম্যাট্রিক্সকে উপস্থাপন করে, যেখানে সারিগুলি সেমিকোলন দ্বারা পৃথক করা হয় এবং উপাদানগুলি স্পেস দ্বারা পৃথক করা হয়।\n(n-2) x (n-2) ম্যাট্রিক্সটি সর্বাধিক মানগুলির রিটার্ন করে।\n>>> generate_max_local \"1 2 3 4;5 6 7 8;9 10 11 12;13 14 15 16\"\n11 12;15 16\n>>> generate_max_local \"9 1 7;4 8 2;3 6 5\"\n9 8",
      "bg": "Генерирайте матрица от максимални стойности от всяка 3x3 подматрица в дадена n x n матрица.\nФункцията приема низ, представляващ n x n матрица, където редовете са разделени със запетаи, а елементите с интервали.\nВръща (n-2) x (n-2) матрица от максимални стойности.\n>>> generate_max_local \"1 2 3 4;5 6 7 8;9 10 11 12;13 14 15 16\"\n11 12;15 16\n>>> generate_max_local \"9 1 7;4 8 2;3 6 5\"\n9 8",
      "zh": "生成一个矩阵，其中包含给定 n x n 矩阵中每个 3x3 子矩阵的最大值。\n该函数接受一个表示 n x n 矩阵的字符串，其中行由分号分隔，元素由空格分隔。\n返回 (n-2) x (n-2) 的最大值矩阵。\n>>> generate_max_local \"1 2 3 4;5 6 7 8;9 10 11 12;13 14 15 16\"\n11 12;15 16\n>>> generate_max_local \"9 1 7;4 8 2;3 6 5\"\n9 8",
      "fr": "Générer une matrice des valeurs maximales de chaque sous-matrice 3x3 dans une matrice n x n donnée.\nLa fonction prend une chaîne représentant la matrice n x n, où les lignes sont séparées par des points-virgules et les éléments par des espaces.\nRenvoie la matrice (n-2) x (n-2) des valeurs maximales.\n>>> generate_max_local \"1 2 3 4;5 6 7 8;9 10 11 12;13 14 15 16\"\n11 12;15 16\n>>> generate_max_local \"9 1 7;4 8 2;3 6 5\"\n9 8",
      "de": "Erzeuge eine Matrix von Maximalwerten aus jeder 3x3-Submatrix in einer gegebenen n x n-Matrix.\nDie Funktion nimmt einen String, der die n x n-Matrix darstellt, wobei die Zeilen durch Semikolons und die Elemente durch Leerzeichen getrennt sind.\nGibt die (n-2) x (n-2) Matrix der Maximalwerte zurück.\n>>> generate_max_local \"1 2 3 4;5 6 7 8;9 10 11 12;13 14 15 16\"\n11 12;15 16\n>>> generate_max_local \"9 1 7;4 8 2;3 6 5\"\n9 8",
      "ha": "Ƙirƙiri matrix na manyan ƙimomi daga kowace matrix 3x3 a cikin matrix n x n da aka bayar.\nAikin yana ɗaukar kirtani wanda ke wakiltar matrix n x n, inda aka raba layuka ta amfani da semicolons kuma abubuwa ta amfani da sarari.\nYana mayar da matrix (n-2) x (n-2) na manyan ƙimomi.\n>>> generate_max_local \"1 2 3 4;5 6 7 8;9 10 11 12;13 14 15 16\"\n11 12;15 16\n>>> generate_max_local \"9 1 7;4 8 2;3 6 5\"\n9 8",
      "hi": "प्रत्येक 3x3 उप-मैट्रिक्स से अधिकतम मानों का एक मैट्रिक्स उत्पन्न करें एक दिए गए n x n मैट्रिक्स में। \nयह फ़ंक्शन एक स्ट्रिंग लेता है जो n x n मैट्रिक्स का प्रतिनिधित्व करता है, जहाँ पंक्तियाँ सेमीकोलन द्वारा और तत्व स्पेस द्वारा अलग होते हैं। \n(n-2) x (n-2) मैट्रिक्स अधिकतम मानों का लौटाता है।\n>>> generate_max_local \"1 2 3 4;5 6 7 8;9 10 11 12;13 14 15 16\"\n11 12;15 16\n>>> generate_max_local \"9 1 7;4 8 2;3 6 5\"\n9 8",
      "hu": "Generáljon egy mátrixot, amely az egyes 3x3-as rész-mátrixok maximális értékeit tartalmazza egy adott n x n mátrixban.\nA függvény egy karakterláncot vesz át, amely az n x n mátrixot reprezentálja, ahol a sorokat pontosvesszők, az elemeket pedig szóközök választják el.\nVisszaadja az (n-2) x (n-2) mátrixot a maximális értékekkel.\n>>> generate_max_local \"1 2 3 4;5 6 7 8;9 10 11 12;13 14 15 16\"\n11 12;15 16\n>>> generate_max_local \"9 1 7;4 8 2;3 6 5\"\n9 8"
    },
    "docstring_bertscore": {
      "sq": "1",
      "hy": "0.9529267846289229",
      "bn": "0.9749155650702471",
      "bg": "0.9789193576607673",
      "zh": "0.9611216782592793",
      "fr": "0.9907392557450104",
      "de": "0.9887005135140683",
      "ha": "0.961359240194997",
      "hi": "0.9939842802799774",
      "hu": "0.9692156676560699"
    }
  },
  {
    "task_id": "Shell/11",
    "prompt": {
      "en": "#!/bin/bash\n\n# Find the maximum amount of water that can be contained between two lines.\n# The function takes a string representing the array of line heights, with elements separated by spaces.\n# Returns the maximum water container capacity.\n# >>> max_water_container \"1 8 6 2 5 4 8 3 7\"\n# 49\n# >>> max_water_container \"1 1\"\n# 1\nmax_water_container() {\nlocal -a heights=($1)",
      "sq": "#!/bin/bash\n\n# Gjeni sasinë maksimale të ujit që mund të përmbahet midis dy linjave.\n# Funksioni merr një varg që përfaqëson vargun e lartësive të linjave, me elemente të ndara me hapësira.\n# Kthen kapacitetin maksimal të enës së ujit.\n# >>> max_water_container \"1 8 6 2 5 4 8 3 7\"\n# 49\n# >>> max_water_container \"1 1\"\n# 1\nmax_water_container() {\nlocal -a heights=($1)",
      "hy": "#!/bin/bash\n\n# Գտնել ջրի առավելագույն քանակը, որը կարող է պարունակվել երկու գծերի միջև։\n# Ֆունկցիան ընդունում է տող, որը ներկայացնում է գծերի բարձրությունների զանգվածը, տարրերը բաժանված են բացատներով։\n# Վերադարձնում է ջրի առավելագույն տարողունակությունը։\n# >>> max_water_container \"1 8 6 2 5 4 8 3 7\"\n# 49\n# >>> max_water_container \"1 1\"\n# 1\nmax_water_container() {\nlocal -a heights=($1)",
      "bn": "#!/bin/bash\n\n# দুটি লাইনের মধ্যে সর্বাধিক পরিমাণ পানি ধারণ করা যেতে পারে তা খুঁজে বের করুন।\n# ফাংশনটি লাইন উচ্চতার অ্যারের প্রতিনিধিত্বকারী একটি স্ট্রিং নেয়, যেখানে উপাদানগুলি স্পেস দ্বারা পৃথক করা থাকে।\n# সর্বাধিক পানি ধারক ক্ষমতা ফেরত দেয়।\n# >>> max_water_container \"1 8 6 2 5 4 8 3 7\"\n# 49\n# >>> max_water_container \"1 1\"\n# 1\nmax_water_container() {\nlocal -a heights=($1)",
      "bg": "#!/bin/bash\n\n# Намерете максималното количество вода, което може да бъде задържано между две линии.\n# Функцията приема низ, представляващ масива от височини на линиите, с елементи, разделени с интервали.\n# Връща максималния капацитет на контейнера за вода.\n# >>> max_water_container \"1 8 6 2 5 4 8 3 7\"\n# 49\n# >>> max_water_container \"1 1\"\n# 1\nmax_water_container() {\nlocal -a heights=($1)",
      "zh": "#!/bin/bash\n\n# 找出可以在两条线之间容纳的最大水量。\n# 该函数接受一个表示线高度数组的字符串，元素之间用空格分隔。\n# 返回最大水容器的容量。\n# >>> max_water_container \"1 8 6 2 5 4 8 3 7\"\n# 49\n# >>> max_water_container \"1 1\"\n# 1\nmax_water_container() {\nlocal -a heights=($1)",
      "fr": "#!/bin/bash\n\n# Trouver la quantité maximale d'eau qui peut être contenue entre deux lignes.\n# La fonction prend une chaîne représentant le tableau des hauteurs de lignes, avec des éléments séparés par des espaces.\n# Retourne la capacité maximale du conteneur d'eau.\n# >>> max_water_container \"1 8 6 2 5 4 8 3 7\"\n# 49\n# >>> max_water_container \"1 1\"\n# 1\nmax_water_container() {\nlocal -a heights=($1)",
      "de": "#!/bin/bash\n\n# Finde die maximale Menge an Wasser, die zwischen zwei Linien enthalten sein kann.\n# Die Funktion nimmt einen String, der das Array der Linienhöhen darstellt, mit durch Leerzeichen getrennten Elementen.\n# Gibt die maximale Wasserkapazität des Containers zurück.\n# >>> max_water_container \"1 8 6 2 5 4 8 3 7\"\n# 49\n# >>> max_water_container \"1 1\"\n# 1\nmax_water_container() {\nlocal -a heights=($1)",
      "ha": "#!/bin/bash\n\n# Nemo mafi girman adadin ruwa da za a iya dauke tsakanin layuka biyu.\n# Aikin yana karɓar wani igiyar rubutu da ke wakiltar jerin tsayin layuka, tare da abubuwa da aka raba ta sarari.\n# Yana dawowa da mafi girman ƙarfin akwati na ruwa.\n# >>> max_water_container \"1 8 6 2 5 4 8 3 7\"\n# 49\n# >>> max_water_container \"1 1\"\n# 1\nmax_water_container() {\nlocal -a heights=($1)",
      "hi": "#!/bin/bash\n\n# दो रेखाओं के बीच अधिकतम पानी की मात्रा खोजें जो समाहित की जा सकती है।\n# यह फ़ंक्शन लाइन की ऊँचाइयों के एरे का प्रतिनिधित्व करने वाले एक स्ट्रिंग को लेता है, जिसमें तत्व स्पेस द्वारा अलग किए गए होते हैं।\n# अधिकतम जल कंटेनर क्षमता लौटाता है।\n# >>> max_water_container \"1 8 6 2 5 4 8 3 7\"\n# 49\n# >>> max_water_container \"1 1\"\n# 1\nmax_water_container() {\nlocal -a heights=($1)",
      "hu": "#!/bin/bash\n\n# Keresse meg a maximális vízmennyiséget, amely két vonal között tárolható.\n# A függvény egy karakterláncot vesz át, amely a vonalak magasságát ábrázolja, az elemek szóközökkel elválasztva vannak.\n# Visszaadja a maximális víztároló kapacitást.\n# >>> max_water_container \"1 8 6 2 5 4 8 3 7\"\n# 49\n# >>> max_water_container \"1 1\"\n# 1\nmax_water_container() {\nlocal -a heights=($1)"
    },
    "prompt_bertscore": {
      "sq": "0.9788319602931119",
      "hy": "0.9915818458213604",
      "bn": "0.9828421090558254",
      "bg": "0.9827781500731321",
      "zh": "0.9803822704170893",
      "fr": "0.9908097695302778",
      "de": "0.9895625693677598",
      "ha": "0.9598035670507318",
      "hi": "0.9953520490837836",
      "hu": "0.9774892189173161"
    },
    "canonical_solution": "local max_capacity=0\nlocal left=0\nlocal right=$((${#heights[@]} - 1))\n\nwhile (( left < right )); do\nlocal width=$((right - left))\nlocal height=$((heights[left] < heights[right] ? heights[left] : heights[right]))\nmax_capacity=$((max_capacity > width * height ? max_capacity : width * height))\n\nif (( heights[left] < heights[right] )); then\n((left++))\nelse\n((right--))\nfi\ndone\n\necho $max_capacity\n}",
    "instruction": {
      "en": "Write a Shell function `max_water_container() {\nlocal -a heights=($1)` to solve the following problem:\n\nFind the maximum amount of water that can be contained between two lines.\nThe function takes a string representing the array of line heights, with elements separated by spaces.\nReturns the maximum water container capacity.\n>>> max_water_container \"1 8 6 2 5 4 8 3 7\"\n49\n>>> max_water_container \"1 1\"\n1\n",
      "sq": "Shkruani një funksion Shell `max_water_container() {\nlocal -a heights=($1)` për të zgjidhur problemin e mëposhtëm:\n\nGjeni sasinë maksimale të ujit që mund të përmbahet midis dy linjave.\nFunksioni merr një varg që përfaqëson vargun e lartësive të linjave, me elemente të ndara me hapësira.\nKthen kapacitetin maksimal të enës së ujit.\n>>> max_water_container \"1 8 6 2 5 4 8 3 7\"\n49\n>>> max_water_container \"1 1\"\n1\n",
      "hy": "Գրեք Shell ֆունկցիա `max_water_container() {\nlocal -a heights=($1)` հետևյալ խնդիրը լուծելու համար:\n\nԳտնել առավելագույն ջրի քանակը, որը կարող է պարունակվել երկու գծերի միջև:\nՖունկցիան ընդունում է տող, որը ներկայացնում է գծերի բարձրությունների զանգվածը, տարրերը բաժանված են բացատներով:\nՎերադարձնում է առավելագույն ջրի տարողությունը:\n>>> max_water_container \"1 8 6 2 5 4 8 3 7\"\n49\n>>> max_water_container \"1 1\"\n1",
      "bn": "একটি Shell ফাংশন লিখুন `max_water_container() { local -a heights=($1)` নিম্নলিখিত সমস্যার সমাধানের জন্য:\n\nদুটি লাইনের মধ্যে সর্বাধিক পরিমাণ পানি ধারণ করা যেতে পারে তা খুঁজে বের করুন। ফাংশনটি লাইনের উচ্চতার অ্যারের প্রতিনিধিত্বকারী একটি স্ট্রিং গ্রহণ করে, যেখানে উপাদানগুলি স্পেস দ্বারা পৃথক করা থাকে। সর্বাধিক পানি ধারক ক্ষমতা রিটার্ন করে।\n>>> max_water_container \"1 8 6 2 5 4 8 3 7\"\n49\n>>> max_water_container \"1 1\"\n1",
      "bg": "Напишете Shell функция `max_water_container() {\nlocal -a heights=($1)` за решаване на следния проблем:\n\nНамерете максималното количество вода, което може да бъде съдържано между две линии.\nФункцията приема низ, представляващ масива от височини на линиите, с елементи, разделени с интервали.\nВръща максималния капацитет на контейнера за вода.\n>>> max_water_container \"1 8 6 2 5 4 8 3 7\"\n49\n>>> max_water_container \"1 1\"\n1",
      "zh": "编写一个 Shell 函数 `max_water_container() {\nlocal -a heights=($1)` 来解决以下问题：\n\n找出两条线之间可以容纳的最大水量。\n该函数接受一个表示线高度数组的字符串，元素之间用空格分隔。\n返回最大水容器的容量。\n>>> max_water_container \"1 8 6 2 5 4 8 3 7\"\n49\n>>> max_water_container \"1 1\"\n1",
      "fr": "Écrire une fonction Shell `max_water_container() {\nlocal -a heights=($1)` pour résoudre le problème suivant :\n\nTrouver la quantité maximale d'eau qui peut être contenue entre deux lignes.\nLa fonction prend une chaîne représentant le tableau des hauteurs de lignes, avec des éléments séparés par des espaces.\nRetourne la capacité maximale du conteneur d'eau.\n>>> max_water_container \"1 8 6 2 5 4 8 3 7\"\n49\n>>> max_water_container \"1 1\"\n1\n",
      "de": "Schreiben Sie eine Shell-Funktion `max_water_container() {\nlocal -a heights=($1)` um das folgende Problem zu lösen:\n\nFinden Sie die maximale Menge an Wasser, die zwischen zwei Linien enthalten sein kann.\nDie Funktion nimmt einen String entgegen, der das Array der Linienhöhen darstellt, mit durch Leerzeichen getrennten Elementen.\nGibt die maximale Wasserkapazität des Containers zurück.\n>>> max_water_container \"1 8 6 2 5 4 8 3 7\"\n49\n>>> max_water_container \"1 1\"\n1",
      "ha": "Rubuta aikin Shell `max_water_container() { local -a heights=($1)` don warware matsalar mai zuwa:\n\nNemo mafi girman adadin ruwa da za a iya dauka tsakanin layuka biyu. \nAikin yana ɗaukar igiyar da ke wakiltar jerin tsayin layi, tare da abubuwan da aka raba ta wurin sarari. \nYana mayar da iyakar ƙarfin akwati na ruwa.\n>>> max_water_container \"1 8 6 2 5 4 8 3 7\"\n49\n>>> max_water_container \"1 1\"\n1",
      "hi": "Shell फ़ंक्शन `max_water_container() {\nlocal -a heights=($1)` लिखें ताकि निम्नलिखित समस्या का समाधान किया जा सके:\n\nदो रेखाओं के बीच अधिकतम मात्रा में पानी जो समाहित किया जा सकता है, उसे खोजें। \nयह फ़ंक्शन रेखाओं की ऊँचाई के array का प्रतिनिधित्व करने वाली एक स्ट्रिंग लेता है, जिसमें तत्व स्पेस द्वारा अलग किए गए होते हैं।\nअधिकतम पानी कंटेनर क्षमता को लौटाता है।\n>>> max_water_container \"1 8 6 2 5 4 8 3 7\"\n49\n>>> max_water_container \"1 1\"\n1",
      "hu": "Írj egy Shell függvényt `max_water_container() {\nlocal -a heights=($1)` a következő probléma megoldására:\n\nTaláld meg a maximális vízmennyiséget, amely két vonal között tárolható.\nA függvény egy karakterláncot vesz át, amely a vonalak magasságát reprezentáló tömböt jelenti, az elemek szóközökkel elválasztva vannak.\nVisszaadja a maximális víztároló kapacitást.\n>>> max_water_container \"1 8 6 2 5 4 8 3 7\"\n49\n>>> max_water_container \"1 1\"\n1"
    },
    "instruction_bertscore": {
      "sq": "0.9846359400269514",
      "hy": "0.9901813030046834",
      "bn": "0.9772647665867467",
      "bg": "0.9973379556333705",
      "zh": "0.9858541401538383",
      "fr": "0.9915651608693534",
      "de": "0.9885213489103748",
      "ha": "0.9796673996757447",
      "hi": "0.9685486668365547",
      "hu": "0.9816483404658056"
    },
    "level": "middle",
    "test": "test_max_water_container() {\n[[ $(max_water_container \"1 8 6 2 5 4 8 3 7\") == \"49\" ]] || { echo \"Test 1 failed\"; exit 1; }\n[[ $(max_water_container \"1 1\") == \"1\" ]] || { echo \"Test 2 failed\"; exit 1; }\n[[ $(max_water_container \"4 3 2 1 4\") == \"16\" ]] || { echo \"Test 3 failed\"; exit 1; }\n[[ $(max_water_container \"1 2 1\") == \"2\" ]] || { echo \"Test 4 failed\"; exit 1; }\n[[ $(max_water_container \"2 3 4 5 18 17 6\") == \"17\" ]] || { echo \"Test 5 failed\"; exit 1; }\n[[ $(max_water_container \"1 2 4 3\") == \"4\" ]] || { echo \"Test 6 failed\"; exit 1; }\n[[ $(max_water_container \"3 9 3 4 7 2 12 6\") == \"45\" ]] || { echo \"Test 7 failed\"; exit 1; }\n}\n\ntest_max_water_container",
    "entry_point": "max_water_container",
    "signature": "max_water_container() {\nlocal -a heights=($1)",
    "docstring": {
      "en": "\nFind the maximum amount of water that can be contained between two lines.\nThe function takes a string representing the array of line heights, with elements separated by spaces.\nReturns the maximum water container capacity.\n>>> max_water_container \"1 8 6 2 5 4 8 3 7\"\n49\n>>> max_water_container \"1 1\"\n1\n",
      "sq": "Gjeni sasinë maksimale të ujit që mund të përmbajë midis dy vijave.\nFunksioni merr një varg që përfaqëson lartësitë e vijave, me elemente të ndara nga hapësira.\nKthen kapacitetin maksimal të enës së ujit.\n>>> max_water_container \"1 8 6 2 5 4 8 3 7\"\n49\n>>> max_water_container \"1 1\"\n1",
      "hy": "Գտնել առավելագույն ջրի քանակը, որը կարող է պարունակվել երկու գծերի միջև:\nՖունկցիան ընդունում է տող, որը ներկայացնում է գծերի բարձրությունների զանգվածը, որի տարրերը բաժանված են բացատներով:\nՎերադարձնում է ջրի կոնտեյների առավելագույն տարողությունը:\n>>> max_water_container \"1 8 6 2 5 4 8 3 7\"\n49\n>>> max_water_container \"1 1\"\n1",
      "bn": "দুটি রেখার মধ্যে সর্বাধিক পরিমাণ পানি ধারণ করা যেতে পারে তা খুঁজে বের করুন। ফাংশনটি একটি স্ট্রিং নেয় যা রেখার উচ্চতার অ্যারে উপস্থাপন করে, যেখানে উপাদানগুলি স্পেস দ্বারা পৃথক করা থাকে। সর্বাধিক পানি ধারণক্ষমতা ফেরত দেয়।\n>>> max_water_container \"1 8 6 2 5 4 8 3 7\"\n49\n>>> max_water_container \"1 1\"\n1",
      "bg": "Намерете максималното количество вода, което може да бъде съдържано между две линии. \nФункцията приема низ, представляващ масива от височини на линиите, с елементи, разделени с интервали. \nВръща максималния капацитет на контейнера за вода.\n>>> max_water_container \"1 8 6 2 5 4 8 3 7\"\n49\n>>> max_water_container \"1 1\"\n1",
      "zh": "找到两条线之间可以容纳的最大水量。  \n该函数接受一个字符串，表示线的高度数组，元素之间用空格分隔。  \n返回最大水容器的容量。  \n>>> max_water_container \"1 8 6 2 5 4 8 3 7\"  \n49  \n>>> max_water_container \"1 1\"  \n1  ",
      "fr": "Trouver la quantité maximale d'eau qui peut être contenue entre deux lignes.  \nLa fonction prend une chaîne de caractères représentant le tableau des hauteurs des lignes, avec des éléments séparés par des espaces.  \nRenvoie la capacité maximale du conteneur d'eau.  \n>>> max_water_container \"1 8 6 2 5 4 8 3 7\"  \n49  \n>>> max_water_container \"1 1\"  \n1  ",
      "de": "Finde die maximale Menge an Wasser, die zwischen zwei Linien enthalten sein kann.\nDie Funktion nimmt einen String, der das Array der Linienhöhen repräsentiert, mit durch Leerzeichen getrennten Elementen.\nGibt die maximale Wasserkapazität des Containers zurück.\n>>> max_water_container \"1 8 6 2 5 4 8 3 7\"\n49\n>>> max_water_container \"1 1\"\n1",
      "ha": "Nemo mafi girman adadin ruwa da za a iya dauka tsakanin layuka biyu.\nAikin yana karɓar igiyar rubutu da ke wakiltar jerin tsayin layi, tare da abubuwa da aka raba ta wurin sarari.\nYana mayar da mafi girman damar ruwan akwati.\n>>> max_water_container \"1 8 6 2 5 4 8 3 7\"\n49\n>>> max_water_container \"1 1\"\n1",
      "hi": "दो रेखाओं के बीच अधिकतम मात्रा में पानी खोजें जो समाहित किया जा सकता है। \nयह फ़ंक्शन रेखाओं की ऊँचाइयों के ऐरे का प्रतिनिधित्व करने वाले एक स्ट्रिंग को लेता है, जिसमें तत्व स्पेस द्वारा अलग किए गए होते हैं। \nअधिकतम पानी कंटेनर क्षमता लौटाता है।\n>>> max_water_container \"1 8 6 2 5 4 8 3 7\"\n49\n>>> max_water_container \"1 1\"\n1",
      "hu": "Keresse meg a maximális vízmennyiséget, amely két vonal között tárolható.  \nA függvény egy karakterláncot vesz fel, amely a vonalmagasságok tömbjét reprezentálja, az elemek szóközzel elválasztva vannak.  \nVisszaadja a maximális víztároló kapacitást.  \n>>> max_water_container \"1 8 6 2 5 4 8 3 7\"  \n49  \n>>> max_water_container \"1 1\"  \n1  "
    },
    "docstring_bertscore": {
      "sq": "0.9678288303356843",
      "hy": "0.9842384806345006",
      "bn": "0.9827523281235976",
      "bg": "1",
      "zh": "0.9820958547142773",
      "fr": "0.9886736984126286",
      "de": "0.98699646347517",
      "ha": "0.9527664899114278",
      "hi": "0.9927142376236403",
      "hu": "0.9768692934981063"
    }
  },
  {
    "task_id": "Shell/12",
    "prompt": {
      "en": "#!/bin/bash\n\n# Find the next permutation of the array in lexicographic order.\n# If the array is in descending order, rearrange it to the first permutation (ascending order).\n# The function takes a string representing the array, with elements separated by spaces.\n# Returns the next permutation of the array.\n# >>> next_permutation \"1 2 3\"\n# 1 3 2\n# >>> next_permutation \"3 2 1\"\n# 1 2 3\nnext_permutation() {\nlocal -a nums=($1)",
      "sq": "#!/bin/bash\n\n# Gjej permutimin tjetër të vargut në rend leksikografik.\n# Nëse vargu është në rend zbritës, riorganizoje atë në permutimin e parë (rend rritës).\n# Funksioni merr një varg që përfaqëson vargun, me elemente të ndara me hapësira.\n# Kthen permutimin tjetër të vargut.\n# >>> next_permutation \"1 2 3\"\n# 1 3 2\n# >>> next_permutation \"3 2 1\"\n# 1 2 3\nnext_permutation() {\nlocal -a nums=($1)",
      "hy": "#!/bin/bash\n\n# Գտնել զանգվածի հաջորդ փոխարկումը բառարանային կարգով:\n# Եթե զանգվածը նվազման կարգով է, վերադասավորել այն առաջին փոխարկման (աճման կարգով):\n# Ֆունկցիան ընդունում է զանգվածը ներկայացնող տող, որի տարրերը բաժանված են բացատներով:\n# Վերադարձնում է զանգվածի հաջորդ փոխարկումը:\n# >>> next_permutation \"1 2 3\"\n# 1 3 2\n# >>> next_permutation \"3 2 1\"\n# 1 2 3\nnext_permutation() {\nlocal -a nums=($1)",
      "bn": "#!/bin/bash\n\n# লেক্সিকোগ্রাফিক ক্রমে অ্যারের পরবর্তী পারমুটেশন খুঁজে বের করুন।\n# যদি অ্যারে অবরোহ ক্রমে থাকে, তবে এটি প্রথম পারমুটেশনে (আরোহ ক্রমে) পুনর্বিন্যাস করুন।\n# ফাংশনটি অ্যারের প্রতিনিধিত্বকারী একটি স্ট্রিং নেয়, যেখানে উপাদানগুলি স্পেস দ্বারা পৃথক করা থাকে।\n# অ্যারের পরবর্তী পারমুটেশনটি রিটার্ন করে।\n# >>> next_permutation \"1 2 3\"\n# 1 3 2\n# >>> next_permutation \"3 2 1\"\n# 1 2 3\nnext_permutation() {\nlocal -a nums=($1)",
      "bg": "#!/bin/bash\n\n# Намери следващата пермутация на масива в лексикографски ред.\n# Ако масивът е в низходящ ред, пренареди го до първата пермутация (възходящ ред).\n# Функцията приема низ, представляващ масива, с елементи, разделени с интервали.\n# Връща следващата пермутация на масива.\n# >>> next_permutation \"1 2 3\"\n# 1 3 2\n# >>> next_permutation \"3 2 1\"\n# 1 2 3\nnext_permutation() {\nlocal -a nums=($1)",
      "zh": "#!/bin/bash\n\n# 查找数组的下一个字典序排列。\n# 如果数组是降序排列，则将其重新排列为第一个排列（升序）。\n# 该函数接受一个表示数组的字符串，元素之间用空格分隔。\n# 返回数组的下一个排列。\n# >>> next_permutation \"1 2 3\"\n# 1 3 2\n# >>> next_permutation \"3 2 1\"\n# 1 2 3\nnext_permutation() {\nlocal -a nums=($1)",
      "fr": "#!/bin/bash\n\n# Trouver la permutation suivante du tableau dans l'ordre lexicographique.\n# Si le tableau est dans l'ordre décroissant, le réorganiser pour obtenir la première permutation (ordre croissant).\n# La fonction prend une chaîne représentant le tableau, avec les éléments séparés par des espaces.\n# Renvoie la permutation suivante du tableau.\n# >>> next_permutation \"1 2 3\"\n# 1 3 2\n# >>> next_permutation \"3 2 1\"\n# 1 2 3\nnext_permutation() {\nlocal -a nums=($1)",
      "de": "#!/bin/bash\n\n# Finde die nächste Permutation des Arrays in lexikographischer Reihenfolge.\n# Wenn das Array in absteigender Reihenfolge ist, ordne es zur ersten Permutation (aufsteigende Reihenfolge) um.\n# Die Funktion nimmt einen String, der das Array darstellt, mit durch Leerzeichen getrennten Elementen.\n# Gibt die nächste Permutation des Arrays zurück.\n# >>> next_permutation \"1 2 3\"\n# 1 3 2\n# >>> next_permutation \"3 2 1\"\n# 1 2 3\nnext_permutation() {\nlocal -a nums=($1)",
      "ha": "#!/bin/bash\n\n# Nemo permutation na gaba na jerin a cikin tsarin haruffa.\n# Idan jerin yana cikin tsarin saukowa, sake tsara shi zuwa permutation na farko (tsarin hawa).\n# Aikin yana karɓar igiyar da ke wakiltar jerin, tare da abubuwa da aka raba ta wurin sarari.\n# Yana mayar da permutation na gaba na jerin.\n# >>> next_permutation \"1 2 3\"\n# 1 3 2\n# >>> next_permutation \"3 2 1\"\n# 1 2 3\nnext_permutation() {\nlocal -a nums=($1)",
      "hi": "#!/bin/bash\n\n# सरणी का अगला क्रमानुसार क्रम ढूंढें।\n# यदि सरणी अवरोही क्रम में है, तो इसे पहले क्रम (आरोही क्रम) में पुनर्व्यवस्थित करें।\n# यह फ़ंक्शन एक स्ट्रिंग लेता है जो सरणी का प्रतिनिधित्व करता है, जिसमें तत्व स्पेस द्वारा अलग किए गए होते हैं।\n# सरणी का अगला क्रम लौटाता है।\n# >>> next_permutation \"1 2 3\"\n# 1 3 2\n# >>> next_permutation \"3 2 1\"\n# 1 2 3\nnext_permutation() {\nlocal -a nums=($1)",
      "hu": "#!/bin/bash\n\n# Keresse meg a tömb következő permutációját lexikografikus sorrendben.\n# Ha a tömb csökkenő sorrendben van, rendezze át az első permutációra (növekvő sorrend).\n# A függvény egy karakterláncot vesz át, amely a tömböt reprezentálja, az elemek szóközzel elválasztva vannak.\n# Visszaadja a tömb következő permutációját.\n# >>> next_permutation \"1 2 3\"\n# 1 3 2\n# >>> next_permutation \"3 2 1\"\n# 1 2 3\nnext_permutation() {\nlocal -a nums=($1)"
    },
    "prompt_bertscore": {
      "sq": "1",
      "hy": "0.9919574558718974",
      "bn": "0.992364648153019",
      "bg": "1",
      "zh": "0.9827002869637664",
      "fr": "0.9904502485406046",
      "de": "0.9987271765183284",
      "ha": "0.969722969649233",
      "hi": "0.9673638366136816",
      "hu": "0.9987271765183284"
    },
    "canonical_solution": "local i j n=${#nums[@]}\n\n# Find the first index i such that nums[i] < nums[i + 1]\nfor (( i=n-2; i>=0 && nums[i]>=nums[i+1]; i-- )); do :; done\n\n# If such index exists, find the first index j > i such that nums[i] < nums[j]\nif (( i >= 0 )); then\nfor (( j=n-1; j>i && nums[j]<=nums[i]; j-- )); do :; done\n# Swap nums[i] and nums[j]\nlocal temp=${nums[i]}\nnums[i]=${nums[j]}\nnums[j]=$temp\nfi\n\n# Reverse the subarray nums[i+1...end]\nfor (( j=i+1, k=n-1; j<k; j++, k-- )); do\nlocal temp=${nums[j]}\nnums[j]=${nums[k]}\nnums[k]=$temp\ndone\n\necho \"${nums[@]}\"\n}",
    "instruction": {
      "en": "Write a Shell function `next_permutation() {\nlocal -a nums=($1)` to solve the following problem:\n\nFind the next permutation of the array in lexicographic order.\nIf the array is in descending order, rearrange it to the first permutation (ascending order).\nThe function takes a string representing the array, with elements separated by spaces.\nReturns the next permutation of the array.\n>>> next_permutation \"1 2 3\"\n1 3 2\n>>> next_permutation \"3 2 1\"\n1 2 3\n",
      "sq": "Shkruani një funksion Shell `next_permutation() {\nlocal -a nums=($1)` për të zgjidhur problemin e mëposhtëm:\n\nGjeni permutacionin e ardhshëm të vargut në rend leksikografik.\nNëse vargu është në rend zbritës, riorganizojeni atë në permutacionin e parë (rend rritës).\nFunksioni merr një varg që përfaqëson vargun, me elemente të ndara me hapësira.\nKthen permutacionin e ardhshëm të vargut.\n>>> next_permutation \"1 2 3\"\n1 3 2\n>>> next_permutation \"3 2 1\"\n1 2 3",
      "hy": "Գրեք Shell ֆունկցիա `next_permutation() {\nlocal -a nums=($1)` հետևյալ խնդիրը լուծելու համար:\n\nԳտնել զանգվածի հաջորդ փոխադրումը բառարանի կարգով:\nԵթե զանգվածը նվազման կարգով է, վերադասավորել այն առաջին փոխադրումը (աճման կարգով):\nՖունկցիան ընդունում է զանգվածը ներկայացնող տող, որի տարրերը բաժանված են բացատներով:\nՎերադարձնում է զանգվածի հաջորդ փոխադրումը:\n>>> next_permutation \"1 2 3\"\n1 3 2\n>>> next_permutation \"3 2 1\"\n1 2 3",
      "bn": "একটি Shell ফাংশন লিখুন `next_permutation() { local -a nums=($1)` নিম্নলিখিত সমস্যাটি সমাধান করতে:\n\nঅ্যারের পরবর্তী পারমুটেশন লেক্সিকোগ্রাফিক ক্রমে খুঁজে বের করুন। \nযদি অ্যারে অবরোহ ক্রমে থাকে, তাহলে এটি প্রথম পারমুটেশনে (আরোহ ক্রমে) পুনর্বিন্যাস করুন। \nফাংশনটি অ্যারের প্রতিনিধিত্বকারী একটি স্ট্রিং নেয়, যেখানে উপাদানগুলি স্পেস দ্বারা পৃথক করা থাকে। \nঅ্যারের পরবর্তী পারমুটেশন রিটার্ন করে। \n>>> next_permutation \"1 2 3\"\n1 3 2\n>>> next_permutation \"3 2 1\"\n1 2 3",
      "bg": "Напишете Shell функция `next_permutation() {\nlocal -a nums=($1)` за решаване на следния проблем:\n\nНамерете следващата пермутация на масива в лексикографски ред.\nАко масивът е в низходящ ред, пренаредете го в първата пермутация (възходящ ред).\nФункцията приема низ, представляващ масива, с елементи, разделени с интервали.\nВръща следващата пермутация на масива.\n>>> next_permutation \"1 2 3\"\n1 3 2\n>>> next_permutation \"3 2 1\"\n1 2 3",
      "zh": "编写一个 Shell 函数 `next_permutation() {\nlocal -a nums=($1)` 来解决以下问题：\n\n找到数组按字典顺序排列的下一个排列。\n如果数组是降序排列，将其重新排列为第一个排列（升序）。\n该函数接受一个表示数组的字符串，元素之间用空格分隔。\n返回数组的下一个排列。\n>>> next_permutation \"1 2 3\"\n1 3 2\n>>> next_permutation \"3 2 1\"\n1 2 3",
      "fr": "Écrire une fonction Shell `next_permutation() {\nlocal -a nums=($1)` pour résoudre le problème suivant :\n\nTrouver la permutation suivante du tableau dans l'ordre lexicographique.\nSi le tableau est dans l'ordre décroissant, le réarranger à la première permutation (ordre croissant).\nLa fonction prend une chaîne représentant le tableau, avec des éléments séparés par des espaces.\nRenvoie la permutation suivante du tableau.\n>>> next_permutation \"1 2 3\"\n1 3 2\n>>> next_permutation \"3 2 1\"\n1 2 3",
      "de": "Schreiben Sie eine Shell-Funktion `next_permutation() {\nlocal -a nums=($1)` um das folgende Problem zu lösen:\n\nFinden Sie die nächste Permutation des Arrays in lexikographischer Reihenfolge.\nWenn das Array in absteigender Reihenfolge ist, ordnen Sie es zur ersten Permutation (aufsteigende Reihenfolge) um.\nDie Funktion nimmt einen String, der das Array darstellt, mit durch Leerzeichen getrennten Elementen.\nGibt die nächste Permutation des Arrays zurück.\n>>> next_permutation \"1 2 3\"\n1 3 2\n>>> next_permutation \"3 2 1\"\n1 2 3",
      "ha": "Rubuta aikin Shell `next_permutation() {\nlocal -a nums=($1)` don warware matsalar mai zuwa:\n\nNemo permutation na gaba na jerin a cikin tsari na lexicographic.\nIdan jerin yana cikin tsari mai saukowa, sake tsara shi zuwa permutation na farko (tsari mai hawa).\nAikin yana ɗaukar igiya mai wakiltar jerin, tare da abubuwa da aka raba ta sarari.\nYana mayar da permutation na gaba na jerin.\n>>> next_permutation \"1 2 3\"\n1 3 2\n>>> next_permutation \"3 2 1\"\n1 2 3",
      "hi": "`next_permutation() { local -a nums=($1)` समस्या को हल करने के लिए:\n\nसरणी के अगले क्रमचय को शब्दकोशीय क्रम में खोजें। यदि सरणी अवरोही क्रम में है, तो इसे पहले क्रमचय (आरोही क्रम) में पुनर्व्यवस्थित करें। यह फ़ंक्शन एक स्ट्रिंग लेता है जो सरणी का प्रतिनिधित्व करता है, जिसमें तत्व स्पेस द्वारा अलग किए गए होते हैं। सरणी के अगले क्रमचय को लौटाता है।\n>>> next_permutation \"1 2 3\"\n1 3 2\n>>> next_permutation \"3 2 1\"\n1 2 3",
      "hu": "Írj egy Shell függvényt `next_permutation() {\nlocal -a nums=($1)` a következő probléma megoldására:\n\nTaláld meg a tömb következő permutációját lexikografikus sorrendben.\nHa a tömb csökkenő sorrendben van, rendezd át az első permutációra (növekvő sorrend).\nA függvény egy karakterláncot vesz át, amely a tömböt reprezentálja, az elemek szóközzel vannak elválasztva.\nVisszaadja a tömb következő permutációját.\n>>> next_permutation \"1 2 3\"\n1 3 2\n>>> next_permutation \"3 2 1\"\n1 2 3"
    },
    "instruction_bertscore": {
      "sq": "0.9849616938518486",
      "hy": "0.9961882829879405",
      "bn": "0.9784287406196112",
      "bg": "0.9985066967953797",
      "zh": "0.9949261855468449",
      "fr": "1",
      "de": "0.9943882944750023",
      "ha": "0.9690921195590663",
      "hi": "0.9596871696474453",
      "hu": "0.9939336295328135"
    },
    "level": "hard",
    "test": "test_next_permutation() {\n[[ $(next_permutation \"1 2 3\") == \"1 3 2\" ]] || { echo \"Test 1 failed\"; exit 1; }\n[[ $(next_permutation \"3 2 1\") == \"1 2 3\" ]] || { echo \"Test 2 failed\"; exit 1; }\n[[ $(next_permutation \"1 3 2\") == \"2 1 3\" ]] || { echo \"Test 3 failed\"; exit 1; }\n[[ $(next_permutation \"2 3 1\") == \"3 1 2\" ]] || { echo \"Test 4 failed\"; exit 1; }\n[[ $(next_permutation \"1 1 5\") == \"1 5 1\" ]] || { echo \"Test 5 failed\"; exit 1; }\n[[ $(next_permutation \"2 1 3\") == \"2 3 1\" ]] || { echo \"Test 6 failed\"; exit 1; }\n[[ $(next_permutation \"5 4 3 2 1\") == \"1 2 3 4 5\" ]] || { echo \"Test 7 failed\"; exit 1; }\n}\n\ntest_next_permutation",
    "entry_point": "next_permutation",
    "signature": "next_permutation() {\nlocal -a nums=($1)",
    "docstring": {
      "en": "\nFind the next permutation of the array in lexicographic order.\nIf the array is in descending order, rearrange it to the first permutation (ascending order).\nThe function takes a string representing the array, with elements separated by spaces.\nReturns the next permutation of the array.\n>>> next_permutation \"1 2 3\"\n1 3 2\n>>> next_permutation \"3 2 1\"\n1 2 3\n",
      "sq": "Gjeni permutacionin tjetër të vargut në rend leksikografik.  \nNëse vargu është në rend zbritës, rregullojeni atë në permutacionin e parë (rend rritës).  \nFunksioni merr një varg që përfaqëson vargun, me elemente të ndara me hapësira.  \nKthen permutacionin tjetër të vargut.  \n>>> next_permutation \"1 2 3\"  \n1 3 2  \n>>> next_permutation \"3 2 1\"  \n1 2 3  ",
      "hy": "Հայտնաբերեք զանգվածի հաջորդ փոխատեղումը բառարանի կարգով։  \nԵթե զանգվածը նվազման կարգով է, վերադասավորեք այն առաջին փոխատեղմանը (աճման կարգով):  \nՖունկցիան ընդունում է զանգվածը ներկայացնող տող, որի տարրերը բաժանված են բացատներով։  \nՎերադարձնում է զանգվածի հաջորդ փոխատեղումը։  \n>>> next_permutation \"1 2 3\"  \n1 3 2  \n>>> next_permutation \"3 2 1\"  \n1 2 3  ",
      "bn": "অ্যারের পরবর্তী পারমুটেশন লেক্সিকোগ্রাফিক ক্রমে খুঁজে বের করুন। \nযদি অ্যারে অবতরণ ক্রমে থাকে, তবে এটিকে প্রথম পারমুটেশনে (আরোহণ ক্রমে) পুনর্বিন্যাস করুন। \nফাংশনটি একটি স্ট্রিং নেয় যা অ্যারেটিকে উপস্থাপন করে, যেখানে উপাদানগুলি স্পেস দ্বারা পৃথক করা থাকে। \nঅ্যারের পরবর্তী পারমুটেশন প্রদান করে।\n\n>>> next_permutation \"1 2 3\"\n1 3 2\n>>> next_permutation \"3 2 1\"\n1 2 3",
      "bg": "Намерете следващата пермутация на масива в лексикографски ред. Ако масивът е в низходящ ред, пренаредете го до първата пермутация (възходящ ред). Функцията приема низ, представляващ масива, с елементи, разделени с интервали. Връща следващата пермутация на масива.\n>>> next_permutation \"1 2 3\"\n1 3 2\n>>> next_permutation \"3 2 1\"\n1 2 3",
      "zh": "找到数组按字典序排列的下一个排列。\n如果数组是降序排列，则将其重新排列为第一个排列（升序排列）。\n该函数接受一个表示数组的字符串，元素之间用空格分隔。\n返回数组的下一个排列。\n>>> next_permutation \"1 2 3\"\n1 3 2\n>>> next_permutation \"3 2 1\"\n1 2 3",
      "fr": "Trouver la permutation suivante du tableau dans l'ordre lexicographique.  \nSi le tableau est dans l'ordre décroissant, le réorganiser pour obtenir la première permutation (ordre croissant).  \nLa fonction prend une chaîne représentant le tableau, avec des éléments séparés par des espaces.  \nRenvoie la permutation suivante du tableau.  \n>>> next_permutation \"1 2 3\"  \n1 3 2  \n>>> next_permutation \"3 2 1\"  \n1 2 3  ",
      "de": "Finde die nächste Permutation des Arrays in lexikographischer Reihenfolge.\nWenn das Array in absteigender Reihenfolge ist, ordne es zur ersten Permutation (aufsteigende Reihenfolge) um.\nDie Funktion nimmt einen String, der das Array darstellt, mit durch Leerzeichen getrennten Elementen.\nGibt die nächste Permutation des Arrays zurück.\n>>> next_permutation \"1 2 3\"\n1 3 2\n>>> next_permutation \"3 2 1\"\n1 2 3",
      "ha": "Nemo permutation na gaba na jerin a cikin tsarin haruffa.\nIdan jeri yana cikin tsarin saukowa, sake tsara shi zuwa permutation na farko (tsarin hawa).\nAikin yana ɗaukar igiyar da ke wakiltar jeri, tare da abubuwa da aka raba ta sarari.\nYana mayar da permutation na gaba na jeri.\n>>> next_permutation \"1 2 3\"\n1 3 2\n>>> next_permutation \"3 2 1\"\n1 2 3",
      "hi": "श्रेणीबद्ध क्रम में सरणी का अगला क्रमपरिवर्तन खोजें।  \nयदि सरणी अवरोही क्रम में है, तो इसे पहले क्रमपरिवर्तन (आरोही क्रम) में पुनर्व्यवस्थित करें।  \nयह फ़ंक्शन एक स्ट्रिंग लेता है जो सरणी का प्रतिनिधित्व करता है, जिसमें तत्व स्पेस द्वारा अलग किए गए होते हैं।  \nसरणी का अगला क्रमपरिवर्तन लौटाता है।  \n>>> next_permutation \"1 2 3\"  \n1 3 2  \n>>> next_permutation \"3 2 1\"  \n1 2 3  ",
      "hu": "Találja meg a tömb következő permutációját lexikografikus sorrendben.\nHa a tömb csökkenő sorrendben van, rendezze át az első permutációra (növekvő sorrend).\nA függvény egy karakterláncot vesz fel, amely a tömböt ábrázolja, az elemek szóközzel elválasztva vannak.\nVisszaadja a tömb következő permutációját.\n>>> next_permutation \"1 2 3\"\n1 3 2\n>>> next_permutation \"3 2 1\"\n1 2 3"
    },
    "docstring_bertscore": {
      "sq": "0.9715801637119093",
      "hy": "0.9627858035915896",
      "bn": "0.9803840580905185",
      "bg": "0.9981424086765617",
      "zh": "0.9857373454897899",
      "fr": "0.9877454986420525",
      "de": "0.9981424086765617",
      "ha": "0.9611878221761638",
      "hi": "0.9954664601832597",
      "hu": "0.9981424086765617"
    }
  },
  {
    "task_id": "Shell/13",
    "prompt": {
      "en": "#!/bin/bash\n\n# Perform modified binary search to find the target in a rotated sorted array.\n# The function takes a string representing the rotated array and an integer target.\n# Returns the index of the target if found, otherwise -1.\n# >>> search_rotated_array \"4 5 6 7 0 1 2\" 0\n# 4\n# >>> search_rotated_array \"4 5 6 7 0 1 2\" 3\n# -1\nsearch_rotated_array() {\nlocal -a nums=($1)\nlocal target=$2",
      "sq": "#!/bin/bash\n\n# Kryen kërkim binar të modifikuar për të gjetur objektivin në një varg të radhitur të rrotulluar.\n# Funksioni merr një varg karakteresh që përfaqëson vargun e rrotulluar dhe një objektiv të tipit integer.\n# Kthen indeksin e objektivit nëse gjendet, përndryshe -1.\n# >>> search_rotated_array \"4 5 6 7 0 1 2\" 0\n# 4\n# >>> search_rotated_array \"4 5 6 7 0 1 2\" 3\n# -1\nsearch_rotated_array() {\nlocal -a nums=($1)\nlocal target=$2",
      "hy": "#!/bin/bash\n\n# Կատարել փոփոխված բինար որոնում՝ գտնելու համար թիրախը պտտված դասավորված զանգվածում:\n# Ֆունկցիան ընդունում է պտտված զանգվածը ներկայացնող տող և ամբողջ թիվ թիրախ:\n# Վերադարձնում է թիրախի ինդեքսը, եթե գտնվել է, հակառակ դեպքում՝ -1:\n# >>> search_rotated_array \"4 5 6 7 0 1 2\" 0\n# 4\n# >>> search_rotated_array \"4 5 6 7 0 1 2\" 3\n# -1\nsearch_rotated_array() {\nlocal -a nums=($1)\nlocal target=$2",
      "bn": "#!/bin/bash\n\n# একটি ঘূর্ণিত সাজানো অ্যারেতে লক্ষ্য খুঁজে পেতে পরিবর্তিত বাইনারি অনুসন্ধান সম্পাদন করুন।\n# ফাংশনটি একটি স্ট্রিং নেয় যা ঘূর্ণিত অ্যারেকে উপস্থাপন করে এবং একটি পূর্ণসংখ্যা লক্ষ্য।\n# লক্ষ্য পাওয়া গেলে এর সূচক ফেরত দেয়, অন্যথায় -1।\n# >>> search_rotated_array \"4 5 6 7 0 1 2\" 0\n# 4\n# >>> search_rotated_array \"4 5 6 7 0 1 2\" 3\n# -1\nsearch_rotated_array() {\nlocal -a nums=($1)\nlocal target=$2",
      "bg": "#!/bin/bash\n\n# Извършва модифицирано двоично търсене за намиране на целта в завъртян сортиран масив.\n# Функцията приема низ, представляващ завъртения масив, и цяло число цел.\n# Връща индекса на целта, ако е намерена, в противен случай -1.\n# >>> search_rotated_array \"4 5 6 7 0 1 2\" 0\n# 4\n# >>> search_rotated_array \"4 5 6 7 0 1 2\" 3\n# -1\nsearch_rotated_array() {\nlocal -a nums=($1)\nlocal target=$2",
      "zh": "#!/bin/bash\n\n# 执行修改后的二分搜索以在旋转排序数组中找到目标。\n# 该函数接受一个表示旋转数组的字符串和一个整数目标。\n# 如果找到目标则返回其索引，否则返回 -1。\n# >>> search_rotated_array \"4 5 6 7 0 1 2\" 0\n# 4\n# >>> search_rotated_array \"4 5 6 7 0 1 2\" 3\n# -1\nsearch_rotated_array() {\nlocal -a nums=($1)\nlocal target=$2",
      "fr": "#!/bin/bash\n\n# Effectuer une recherche binaire modifiée pour trouver la cible dans un tableau trié et pivoté.\n# La fonction prend une chaîne représentant le tableau pivoté et un entier cible.\n# Retourne l'indice de la cible si elle est trouvée, sinon -1.\n# >>> search_rotated_array \"4 5 6 7 0 1 2\" 0\n# 4\n# >>> search_rotated_array \"4 5 6 7 0 1 2\" 3\n# -1\nsearch_rotated_array() {\nlocal -a nums=($1)\nlocal target=$2",
      "de": "#!/bin/bash\n\n# Führe eine modifizierte binäre Suche durch, um das Ziel in einem gedrehten sortierten Array zu finden.\n# Die Funktion nimmt einen String, der das gedrehte Array darstellt, und ein ganzzahliges Ziel.\n# Gibt den Index des Ziels zurück, falls gefunden, andernfalls -1.\n# >>> search_rotated_array \"4 5 6 7 0 1 2\" 0\n# 4\n# >>> search_rotated_array \"4 5 6 7 0 1 2\" 3\n# -1\nsearch_rotated_array() {\nlocal -a nums=($1)\nlocal target=$2",
      "ha": "#!/bin/bash\n\n# Yi amfani da binciken binary da aka gyara don nemo abin da ake nema a cikin jujjuyawar jerin da aka tsara.\n# Aikin yana karɓar rubutu da ke wakiltar jujjuyawar jerin da kuma integer da ake nema.\n# Yana mayar da index na abin da ake nema idan an same shi, in ba haka ba -1.\n# >>> search_rotated_array \"4 5 6 7 0 1 2\" 0\n# 4\n# >>> search_rotated_array \"4 5 6 7 0 1 2\" 3\n# -1\nsearch_rotated_array() {\nlocal -a nums=($1)\nlocal target=$2",
      "hi": "#!/bin/bash\n\n# एक घुमाए गए क्रमबद्ध array में लक्ष्य को खोजने के लिए संशोधित बाइनरी खोज करें।\n# यह फ़ंक्शन एक स्ट्रिंग लेता है जो घुमाए गए array का प्रतिनिधित्व करता है और एक पूर्णांक लक्ष्य।\n# यदि लक्ष्य पाया जाता है तो लक्ष्य का सूचकांक लौटाता है, अन्यथा -1।\n# >>> search_rotated_array \"4 5 6 7 0 1 2\" 0\n# 4\n# >>> search_rotated_array \"4 5 6 7 0 1 2\" 3\n# -1\nsearch_rotated_array() {\nlocal -a nums=($1)\nlocal target=$2",
      "hu": "#!/bin/bash\n\n# Módosított bináris keresést hajt végre, hogy megtalálja a célt egy elforgatott rendezett tömbben.\n# A függvény egy karakterláncot vesz át, amely az elforgatott tömböt reprezentálja, és egy egész szám célt.\n# Visszaadja a cél indexét, ha megtalálja, ellenkező esetben -1-et.\n# >>> search_rotated_array \"4 5 6 7 0 1 2\" 0\n# 4\n# >>> search_rotated_array \"4 5 6 7 0 1 2\" 3\n# -1\nsearch_rotated_array() {\nlocal -a nums=($1)\nlocal target=$2"
    },
    "prompt_bertscore": {
      "sq": "0.977460417512066",
      "hy": "0.9966614205555656",
      "bn": "0.9897443161664067",
      "bg": "0.9906709268939344",
      "zh": "0.9698786958679644",
      "fr": "0.9862939078174496",
      "de": "0.9966614205555656",
      "ha": "0.9871944979650618",
      "hi": "0.9950340418437468",
      "hu": "0.9906709268939344"
    },
    "canonical_solution": "local left=0\nlocal right=$((${#nums[@]} - 1))\n\nwhile (( left <= right )); do\nlocal mid=$(((left + right) / 2))\n\nif (( nums[mid] == target )); then\necho $mid\nreturn\nfi\n\nif (( nums[left] <= nums[mid] )); then\nif (( nums[left] <= target && target < nums[mid] )); then\nright=$((mid - 1))\nelse\nleft=$((mid + 1))\nfi\nelse\nif (( nums[mid] < target && target <= nums[right] )); then\nleft=$((mid + 1))\nelse\nright=$((mid - 1))\nfi\nfi\ndone\n\necho -1\n}",
    "instruction": {
      "en": "Write a Shell function `search_rotated_array() {\nlocal -a nums=($1)\nlocal target=$2` to solve the following problem:\n\nPerform modified binary search to find the target in a rotated sorted array.\nThe function takes a string representing the rotated array and an integer target.\nReturns the index of the target if found, otherwise -1.\n>>> search_rotated_array \"4 5 6 7 0 1 2\" 0\n4\n>>> search_rotated_array \"4 5 6 7 0 1 2\" 3\n-1\n",
      "sq": "Shkruani një funksion Shell `search_rotated_array() {\nlocal -a nums=($1)\nlocal target=$2` për të zgjidhur problemin e mëposhtëm:\n\nKryeni kërkim binar të modifikuar për të gjetur objektivin në një varg të radhitur të rrotulluar.\nFunksioni merr një varg të rrotulluar si string dhe një objektiv të tipit integer.\nKthen indeksin e objektivit nëse gjendet, përndryshe -1.\n>>> search_rotated_array \"4 5 6 7 0 1 2\" 0\n4\n>>> search_rotated_array \"4 5 6 7 0 1 2\" 3\n-1",
      "hy": "Գրեք Shell ֆունկցիա `search_rotated_array() {\nlocal -a nums=($1)\nlocal target=$2` հետևյալ խնդիրը լուծելու համար:\n\nԿատարել փոփոխված բինար որոնում՝ գտնելու համար նպատակային արժեքը պտտված սորտավորված զանգվածում։ Ֆունկցիան ընդունում է պտտված զանգվածը ներկայացնող տող և ամբողջ թիվ նպատակային արժեք։ Վերադարձնում է նպատակային արժեքի ինդեքսը, եթե գտնվել է, հակառակ դեպքում՝ -1։\n>>> search_rotated_array \"4 5 6 7 0 1 2\" 0\n4\n>>> search_rotated_array \"4 5 6 7 0 1 2\" 3\n-1",
      "bn": "`search_rotated_array() {\nlocal -a nums=($1)\nlocal target=$2` নিম্নলিখিত সমস্যার সমাধান করতে:\n\nএকটি ঘূর্ণিত সর্ট করা অ্যারেতে লক্ষ্য খুঁজে পেতে পরিবর্তিত বাইনারি অনুসন্ধান সম্পাদন করুন।\nফাংশনটি একটি স্ট্রিং নেয় যা ঘূর্ণিত অ্যারেকে উপস্থাপন করে এবং একটি পূর্ণসংখ্যা লক্ষ্য।\nলক্ষ্য পাওয়া গেলে এর সূচক ফেরত দেয়, অন্যথায় -1।\n>>> search_rotated_array \"4 5 6 7 0 1 2\" 0\n4\n>>> search_rotated_array \"4 5 6 7 0 1 2\" 3\n-1",
      "bg": "Напишете Shell функция `search_rotated_array() {\nlocal -a nums=($1)\nlocal target=$2`, за да решите следния проблем:\n\nИзвършете модифицирано двоично търсене, за да намерите целта в завъртян сортиран масив.\nФункцията приема низ, представляващ завъртения масив, и цяло число цел.\nВръща индекса на целта, ако е намерена, в противен случай -1.\n>>> search_rotated_array \"4 5 6 7 0 1 2\" 0\n4\n>>> search_rotated_array \"4 5 6 7 0 1 2\" 3\n-1",
      "zh": "编写一个 Shell 函数 `search_rotated_array() {\nlocal -a nums=($1)\nlocal target=$2` 来解决以下问题：\n\n执行修改后的二分查找以在旋转排序数组中查找目标。\n该函数接受一个表示旋转数组的字符串和一个整数目标。\n如果找到目标则返回其索引，否则返回 -1。\n>>> search_rotated_array \"4 5 6 7 0 1 2\" 0\n4\n>>> search_rotated_array \"4 5 6 7 0 1 2\" 3\n-1",
      "fr": "Écrire une fonction Shell `search_rotated_array() {\nlocal -a nums=($1)\nlocal target=$2` pour résoudre le problème suivant :\n\nEffectuer une recherche binaire modifiée pour trouver la cible dans un tableau trié et pivoté.\nLa fonction prend une chaîne représentant le tableau pivoté et un entier cible.\nRetourne l'indice de la cible si elle est trouvée, sinon -1.\n>>> search_rotated_array \"4 5 6 7 0 1 2\" 0\n4\n>>> search_rotated_array \"4 5 6 7 0 1 2\" 3\n-1",
      "de": "Schreiben Sie eine Shell-Funktion `search_rotated_array() {\nlocal -a nums=($1)\nlocal target=$2`, um das folgende Problem zu lösen:\n\nFühren Sie eine modifizierte binäre Suche durch, um das Ziel in einem gedrehten sortierten Array zu finden.\nDie Funktion nimmt eine Zeichenkette, die das gedrehte Array darstellt, und ein ganzzahliges Ziel.\nGibt den Index des Ziels zurück, falls gefunden, andernfalls -1.\n>>> search_rotated_array \"4 5 6 7 0 1 2\" 0\n4\n>>> search_rotated_array \"4 5 6 7 0 1 2\" 3\n-1",
      "ha": "Rubuta aikin Shell `search_rotated_array() {\nlocal -a nums=($1)\nlocal target=$2` don warware matsalar mai zuwa:\n\nYi amfani da binciken binary da aka gyara don nemo burin a cikin jujjuyawar jerin da aka tsara.\nAikin yana karɓar wani kirtani da ke wakiltar jujjuyawar jerin da aka tsara da kuma integer burin.\nYana mayar da lambar index na burin idan an same shi, in ba haka ba -1.\n>>> search_rotated_array \"4 5 6 7 0 1 2\" 0\n4\n>>> search_rotated_array \"4 5 6 7 0 1 2\" 3\n-1",
      "hi": "Shell फ़ंक्शन `search_rotated_array() {\nlocal -a nums=($1)\nlocal target=$2` लिखें ताकि निम्नलिखित समस्या का समाधान किया जा सके:\n\nएक घुमाए गए क्रमबद्ध array में लक्ष्य खोजने के लिए संशोधित बाइनरी खोज करें।\nयह फ़ंक्शन एक स्ट्रिंग लेता है जो घुमाए गए array का प्रतिनिधित्व करता है और एक पूर्णांक लक्ष्य।\nलक्ष्य का सूचकांक लौटाता है यदि पाया जाता है, अन्यथा -1।\n>>> search_rotated_array \"4 5 6 7 0 1 2\" 0\n4\n>>> search_rotated_array \"4 5 6 7 0 1 2\" 3\n-1",
      "hu": "Írj egy Shell függvényt `search_rotated_array() {\nlocal -a nums=($1)\nlocal target=$2` a következő probléma megoldására:\n\nVégezz módosított bináris keresést, hogy megtaláld a célt egy elforgatott rendezett tömbben.\nA függvény egy karakterláncot vesz át, amely az elforgatott tömböt képviseli, és egy egész szám célt.\nVisszaadja a cél indexét, ha megtalálja, ellenkező esetben -1-et.\n>>> search_rotated_array \"4 5 6 7 0 1 2\" 0\n4\n>>> search_rotated_array \"4 5 6 7 0 1 2\" 3\n-1"
    },
    "instruction_bertscore": {
      "sq": "0.9744013110137477",
      "hy": "0.9712685126440654",
      "bn": "0.9633656056738304",
      "bg": "0.9946111577625235",
      "zh": "0.9713447867103829",
      "fr": "0.9856034686129723",
      "de": "0.9932793410576846",
      "ha": "0.9790293988918607",
      "hi": "0.9738876528483915",
      "hu": "0.9919731476719992"
    },
    "level": "middle",
    "test": "test_search_rotated_array() {\n[[ $(search_rotated_array \"4 5 6 7 0 1 2\" 0) == \"4\" ]] || { echo \"Test 1 failed\"; exit 1; }\n[[ $(search_rotated_array \"4 5 6 7 0 1 2\" 3) == \"-1\" ]] || { echo \"Test 2 failed\"; exit 1; }\n[[ $(search_rotated_array \"0 1 2 4 5 6 7\" 3) == \"-1\" ]] || { echo \"Test 3 failed\"; exit 1; }\n[[ $(search_rotated_array \"6 7 0 1 2 4 5\" 3) == \"-1\" ]] || { echo \"Test 4 failed\"; exit 1; }\n[[ $(search_rotated_array \"7 0 1 2 4 5 6\" 0) == \"1\" ]] || { echo \"Test 5 failed\"; exit 1; }\n[[ $(search_rotated_array \"1\" 0) == \"-1\" ]] || { echo \"Test 6 failed\"; exit 1; }\n[[ $(search_rotated_array \"1 3\" 3) == \"1\" ]] || { echo \"Test 7 failed\"; exit 1; }\n}\n\ntest_search_rotated_array",
    "entry_point": "search_rotated_array",
    "signature": "search_rotated_array() {\nlocal -a nums=($1)\nlocal target=$2",
    "docstring": {
      "en": "\nPerform modified binary search to find the target in a rotated sorted array.\nThe function takes a string representing the rotated array and an integer target.\nReturns the index of the target if found, otherwise -1.\n>>> search_rotated_array \"4 5 6 7 0 1 2\" 0\n4\n>>> search_rotated_array \"4 5 6 7 0 1 2\" 3\n-1\n",
      "sq": "Kryen kërkim binar të modifikuar për të gjetur objektivin në një varg të rrotulluar dhe të renditur.\nFunksioni merr një varg të rrotulluar si string dhe një objektiv të tipit integer.\nKthen indeksin e objektivit nëse gjendet, përndryshe -1.\n>>> search_rotated_array \"4 5 6 7 0 1 2\" 0\n4\n>>> search_rotated_array \"4 5 6 7 0 1 2\" 3\n-1",
      "hy": "Կատարել փոփոխված բինար որոնում՝ գտնելու համար թիրախը պտտված դասավորված զանգվածում։  \nՖունկցիան ընդունում է պտտված զանգվածը ներկայացնող տող և ամբողջ թիվ թիրախ։  \nՎերադարձնում է թիրախի ինդեքսը, եթե գտնվել է, հակառակ դեպքում՝ -1։  \n>>> search_rotated_array \"4 5 6 7 0 1 2\" 0  \n4  \n>>> search_rotated_array \"4 5 6 7 0 1 2\" 3  \n-1  ",
      "bn": "ঘূর্ণিত সাজানো অ্যারেতে লক্ষ্য খুঁজতে পরিবর্তিত বাইনারি অনুসন্ধান সম্পাদন করুন। \nফাংশনটি একটি স্ট্রিং নেয় যা ঘূর্ণিত অ্যারে উপস্থাপন করে এবং একটি পূর্ণসংখ্যা লক্ষ্য নেয়। \nলক্ষ্য পাওয়া গেলে তার সূচক ফেরত দেয়, অন্যথায় -1 ফেরত দেয়।\n>>> search_rotated_array \"4 5 6 7 0 1 2\" 0\n4\n>>> search_rotated_array \"4 5 6 7 0 1 2\" 3\n-1",
      "bg": "Извършва модифицирано двоично търсене, за да намери целта в завъртян сортиран масив. Функцията приема низ, представляващ завъртяния масив, и цяло число цел. Връща индекса на целта, ако е намерена, в противен случай -1.\n>>> search_rotated_array \"4 5 6 7 0 1 2\" 0\n4\n>>> search_rotated_array \"4 5 6 7 0 1 2\" 3\n-1",
      "zh": "在旋转排序数组中执行修改后的二分查找以找到目标。  \n该函数接受一个表示旋转数组的字符串和一个整数目标。  \n如果找到目标则返回其索引，否则返回 -1。  \n>>> search_rotated_array \"4 5 6 7 0 1 2\" 0  \n4  \n>>> search_rotated_array \"4 5 6 7 0 1 2\" 3  \n-1  ",
      "fr": "Effectuer une recherche binaire modifiée pour trouver la cible dans un tableau trié et pivoté.\nLa fonction prend une chaîne représentant le tableau pivoté et un entier cible.\nRenvoie l'indice de la cible si elle est trouvée, sinon -1.\n>>> search_rotated_array \"4 5 6 7 0 1 2\" 0\n4\n>>> search_rotated_array \"4 5 6 7 0 1 2\" 3\n-1",
      "de": "Führe eine modifizierte binäre Suche durch, um das Ziel in einem gedrehten sortierten Array zu finden.\nDie Funktion nimmt einen String, der das gedrehte Array darstellt, und ein ganzzahliges Ziel.\nGibt den Index des Ziels zurück, wenn es gefunden wird, andernfalls -1.\n>>> search_rotated_array \"4 5 6 7 0 1 2\" 0\n4\n>>> search_rotated_array \"4 5 6 7 0 1 2\" 3\n-1",
      "ha": "Yi amfani da bincike na binary da aka gyara don nemo abin da ake nufi a cikin jujjuyawar jerin lambobi da aka rarraba. \nAikin yana karɓar wani rubutu da ke wakiltar jujjuyawar jerin lambobi da kuma wani adadi da ake nufi. \nYana dawowa da inda ake nufi idan an same shi, in ba haka ba -1.\n>>> search_rotated_array \"4 5 6 7 0 1 2\" 0\n4\n>>> search_rotated_array \"4 5 6 7 0 1 2\" 3\n-1",
      "hi": "घुमाए गए क्रमबद्ध सरणी में लक्ष्य खोजने के लिए संशोधित बाइनरी खोज करें।\nयह फ़ंक्शन घुमाए गए सरणी का प्रतिनिधित्व करने वाली एक स्ट्रिंग और एक पूर्णांक लक्ष्य लेता है।\nयदि लक्ष्य पाया जाता है तो लक्ष्य का सूचकांक लौटाता है, अन्यथा -1।\n>>> search_rotated_array \"4 5 6 7 0 1 2\" 0\n4\n>>> search_rotated_array \"4 5 6 7 0 1 2\" 3\n-1",
      "hu": "Végezzen módosított bináris keresést a célpont megtalálásához egy elforgatott rendezett tömbben.\nA függvény egy karakterláncot vesz át, amely az elforgatott tömböt reprezentálja, és egy egész szám célt.\nVisszaadja a cél indexét, ha megtalálja, különben -1-et.\n>>> search_rotated_array \"4 5 6 7 0 1 2\" 0\n4\n>>> search_rotated_array \"4 5 6 7 0 1 2\" 3\n-1"
    },
    "docstring_bertscore": {
      "sq": "0.9455272070442302",
      "hy": "0.9839802611391553",
      "bn": "0.9695704215165982",
      "bg": "0.9797647285624518",
      "zh": "0.9456376455360856",
      "fr": "0.9737170293510825",
      "de": "0.9870379772248064",
      "ha": "0.9336284526987163",
      "hi": "0.9779911578901913",
      "hu": "0.9806627365151105"
    }
  },
  {
    "task_id": "Shell/14",
    "prompt": {
      "en": "#!/bin/bash\n\n# Find the start and end positions of the target value in a non-decreasing array.\n# The function takes a string representing the array and an integer target.\n# Returns the start and end positions of the target, or [-1, -1] if not found.\n# >>> find_target_positions \"5 7 7 8 8 10\" 8\n# 3 4\n# >>> find_target_positions \"5 7 7 8 8 10\" 6\n# -1 -1\nfind_target_positions() {\nlocal -a nums=($1)\nlocal target=$2",
      "sq": "#!/bin/bash\n\n# Gjeni pozicionet e fillimit dhe të mbarimit të vlerës së synuar në një varg jo-zbritës.\n# Funksioni merr një varg që përfaqëson vargun dhe një numër të plotë synim.\n# Kthen pozicionet e fillimit dhe të mbarimit të synimit, ose [-1, -1] nëse nuk gjendet.\n# >>> find_target_positions \"5 7 7 8 8 10\" 8\n# 3 4\n# >>> find_target_positions \"5 7 7 8 8 10\" 6\n# -1 -1\nfind_target_positions() {\nlocal -a nums=($1)\nlocal target=$2",
      "hy": "#!/bin/bash\n\n# Գտնել թիրախ արժեքի սկիզբն ու վերջը ոչ նվազող զանգվածում:\n# Ֆունկցիան ընդունում է զանգվածը ներկայացնող տող և ամբողջ թիվ թիրախ:\n# Վերադարձնում է թիրախի սկիզբն ու վերջը, կամ [-1, -1] եթե չի գտնվել:\n# >>> find_target_positions \"5 7 7 8 8 10\" 8\n# 3 4\n# >>> find_target_positions \"5 7 7 8 8 10\" 6\n# -1 -1\nfind_target_positions() {\nlocal -a nums=($1)\nlocal target=$2",
      "bn": "#!/bin/bash\n\n# একটি অ-বৃদ্ধিশীল অ্যারেতে লক্ষ্য মানের শুরুর এবং শেষ অবস্থান খুঁজে বের করুন।\n# ফাংশনটি একটি স্ট্রিং নেয় যা অ্যারেকে উপস্থাপন করে এবং একটি পূর্ণসংখ্যা লক্ষ্য।\n# লক্ষ্য মানের শুরুর এবং শেষ অবস্থান ফেরত দেয়, অথবা [-1, -1] যদি না পাওয়া যায়।\n# >>> find_target_positions \"5 7 7 8 8 10\" 8\n# 3 4\n# >>> find_target_positions \"5 7 7 8 8 10\" 6\n# -1 -1\nfind_target_positions() {\nlocal -a nums=($1)\nlocal target=$2",
      "bg": "#!/bin/bash\n\n# Намерете началните и крайните позиции на целевата стойност в ненамаляващ масив.\n# Функцията приема низ, представляващ масива, и цяло число цел.\n# Връща началните и крайните позиции на целта или [-1, -1], ако не е намерена.\n# >>> find_target_positions \"5 7 7 8 8 10\" 8\n# 3 4\n# >>> find_target_positions \"5 7 7 8 8 10\" 6\n# -1 -1\nfind_target_positions() {\nlocal -a nums=($1)\nlocal target=$2",
      "zh": "#!/bin/bash\n\n# 在非递减数组中查找目标值的起始和结束位置。\n# 该函数接受一个表示数组的字符串和一个整数目标。\n# 返回目标的起始和结束位置，如果未找到则返回 [-1, -1]。\n# >>> find_target_positions \"5 7 7 8 8 10\" 8\n# 3 4\n# >>> find_target_positions \"5 7 7 8 8 10\" 6\n# -1 -1\nfind_target_positions() {\nlocal -a nums=($1)\nlocal target=$2",
      "fr": "#!/bin/bash\n\n# Trouver les positions de début et de fin de la valeur cible dans un tableau non décroissant.\n# La fonction prend une chaîne représentant le tableau et un entier cible.\n# Renvoie les positions de début et de fin de la cible, ou [-1, -1] si non trouvé.\n# >>> find_target_positions \"5 7 7 8 8 10\" 8\n# 3 4\n# >>> find_target_positions \"5 7 7 8 8 10\" 6\n# -1 -1\nfind_target_positions() {\nlocal -a nums=($1)\nlocal target=$2",
      "de": "#!/bin/bash\n\n# Finde die Start- und Endpositionen des Zielwerts in einem nicht abnehmenden Array.\n# Die Funktion nimmt einen String, der das Array darstellt, und ein ganzzahliges Ziel.\n# Gibt die Start- und Endpositionen des Ziels zurück oder [-1, -1], wenn nicht gefunden.\n# >>> find_target_positions \"5 7 7 8 8 10\" 8\n# 3 4\n# >>> find_target_positions \"5 7 7 8 8 10\" 6\n# -1 -1\nfind_target_positions() {\nlocal -a nums=($1)\nlocal target=$2",
      "ha": "#!/bin/bash\n\n# Nemo wuraren farawa da ƙarewa na ƙimar da ake nufi a cikin jerin da ba ya raguwa.\n# Aiki yana ɗaukar wani igiya da ke wakiltar jerin da kuma integer da ake nufi.\n# Yana mayar da wuraren farawa da ƙarewa na abin da ake nufi, ko [-1, -1] idan ba a samu ba.\n# >>> find_target_positions \"5 7 7 8 8 10\" 8\n# 3 4\n# >>> find_target_positions \"5 7 7 8 8 10\" 6\n# -1 -1\nfind_target_positions() {\nlocal -a nums=($1)\nlocal target=$2",
      "hi": "#!/bin/bash\n\n# एक गैर-घटते क्रम में व्यवस्थित array में लक्षित मान की शुरुआत और अंत की स्थिति खोजें।\n# फ़ंक्शन एक स्ट्रिंग लेता है जो array का प्रतिनिधित्व करता है और एक पूर्णांक लक्ष्य।\n# लक्ष्य की शुरुआत और अंत की स्थिति लौटाता है, या [-1, -1] यदि नहीं मिला।\n# >>> find_target_positions \"5 7 7 8 8 10\" 8\n# 3 4\n# >>> find_target_positions \"5 7 7 8 8 10\" 6\n# -1 -1\nfind_target_positions() {\nlocal -a nums=($1)\nlocal target=$2",
      "hu": "#!/bin/bash\n\n# Keresse meg a célérték kezdő és végpozícióját egy nem csökkenő tömbben.\n# A függvény egy karakterláncot vesz fel, amely a tömböt képviseli, és egy egész szám célértéket.\n# Visszaadja a célérték kezdő és végpozícióját, vagy [-1, -1]-et, ha nem található.\n# >>> find_target_positions \"5 7 7 8 8 10\" 8\n# 3 4\n# >>> find_target_positions \"5 7 7 8 8 10\" 6\n# -1 -1\nfind_target_positions() {\nlocal -a nums=($1)\nlocal target=$2"
    },
    "prompt_bertscore": {
      "sq": "0.986478634071812",
      "hy": "0.9845970084722686",
      "bn": "0.9962125158944267",
      "bg": "0.9952656448680335",
      "zh": "0.9960865842328507",
      "fr": "0.9975266544953536",
      "de": "0.9976726478254142",
      "ha": "0.9837419046819134",
      "hi": "0.9809523396106594",
      "hu": "0.984718768895843"
    },
    "canonical_solution": "local n=${#nums[@]}\nlocal start=-1 end=-1\n\n# Binary search for the starting position\nlocal left=0 right=$((n - 1))\nwhile (( left <= right )); do\nlocal mid=$(((left + right) / 2))\nif (( nums[mid] == target )); then\nstart=$mid\nright=$((mid - 1))\nelif (( nums[mid] < target )); then\nleft=$((mid + 1))\nelse\nright=$((mid - 1))\nfi\ndone\n\n# Binary search for the ending position\nleft=0 right=$((n - 1))\nwhile (( left <= right )); do\nlocal mid=$(((left + right) / 2))\nif (( nums[mid] == target )); then\nend=$mid\nleft=$((mid + 1))\nelif (( nums[mid] < target )); then\nleft=$((mid + 1))\nelse\nright=$((mid - 1))\nfi\ndone\n\necho \"$start $end\"\n}",
    "instruction": {
      "en": "Write a Shell function `find_target_positions() {\nlocal -a nums=($1)\nlocal target=$2` to solve the following problem:\n\nFind the start and end positions of the target value in a non-decreasing array.\nThe function takes a string representing the array and an integer target.\nReturns the start and end positions of the target, or [-1, -1] if not found.\n>>> find_target_positions \"5 7 7 8 8 10\" 8\n3 4\n>>> find_target_positions \"5 7 7 8 8 10\" 6\n-1 -1\n",
      "sq": "Shkruani një funksion Shell `find_target_positions() {\nlocal -a nums=($1)\nlocal target=$2` për të zgjidhur problemin e mëposhtëm:\n\nGjeni pozicionet e fillimit dhe të mbarimit të vlerës së synuar në një varg që nuk zvogëlohet.\nFunksioni merr një varg që përfaqëson vargun dhe një synim të plotë.\nKthen pozicionet e fillimit dhe të mbarimit të synimit, ose [-1, -1] nëse nuk gjendet.\n>>> find_target_positions \"5 7 7 8 8 10\" 8\n3 4\n>>> find_target_positions \"5 7 7 8 8 10\" 6\n-1 -1",
      "hy": "Գրեք Shell ֆունկցիա `find_target_positions() {\nlocal -a nums=($1)\nlocal target=$2` հետևյալ խնդիրը լուծելու համար:\n\nԳտեք թիրախ արժեքի սկիզբն ու վերջը ոչ նվազող զանգվածում:\nՖունկցիան ընդունում է զանգվածը ներկայացնող տող և ամբողջ թիվ թիրախ:\nՎերադարձնում է թիրախի սկիզբն ու վերջը, կամ [-1, -1] եթե չի գտնվել:\n>>> find_target_positions \"5 7 7 8 8 10\" 8\n3 4\n>>> find_target_positions \"5 7 7 8 8 10\" 6\n-1 -1",
      "bn": "একটি Shell ফাংশন লিখুন `find_target_positions() {\nlocal -a nums=($1)\nlocal target=$2` নিম্নলিখিত সমস্যার সমাধানের জন্য:\n\nএকটি অ-বৃদ্ধিমূলক অ্যারেতে লক্ষ্য মানের শুরুর এবং শেষ অবস্থানগুলি খুঁজুন।\nফাংশনটি অ্যারের প্রতিনিধিত্বকারী একটি স্ট্রিং এবং একটি পূর্ণসংখ্যা লক্ষ্য গ্রহণ করে।\nলক্ষ্যের শুরুর এবং শেষ অবস্থানগুলি ফেরত দেয়, অথবা [-1, -1] যদি না পাওয়া যায়।\n>>> find_target_positions \"5 7 7 8 8 10\" 8\n3 4\n>>> find_target_positions \"5 7 7 8 8 10\" 6\n-1 -1",
      "bg": "Напишете Shell функция `find_target_positions() {\nlocal -a nums=($1)\nlocal target=$2`, за да решите следния проблем:\n\nНамерете началните и крайните позиции на целевата стойност в не-намаляващ масив.\nФункцията приема низ, представляващ масива, и цяло число цел.\nВръща началните и крайните позиции на целта, или [-1, -1] ако не е намерена.\n>>> find_target_positions \"5 7 7 8 8 10\" 8\n3 4\n>>> find_target_positions \"5 7 7 8 8 10\" 6\n-1 -1",
      "zh": "编写一个 Shell 函数 `find_target_positions() {\nlocal -a nums=($1)\nlocal target=$2` 来解决以下问题：\n\n在一个非递减数组中找到目标值的起始和结束位置。\n该函数接受一个表示数组的字符串和一个整数目标。\n返回目标的起始和结束位置，如果未找到则返回 [-1, -1]。\n>>> find_target_positions \"5 7 7 8 8 10\" 8\n3 4\n>>> find_target_positions \"5 7 7 8 8 10\" 6\n-1 -1",
      "fr": "Écrire une fonction Shell `find_target_positions() {\nlocal -a nums=($1)\nlocal target=$2` pour résoudre le problème suivant :\n\nTrouver les positions de début et de fin de la valeur cible dans un tableau non décroissant.\nLa fonction prend une chaîne représentant le tableau et un entier cible.\nRetourne les positions de début et de fin de la cible, ou [-1, -1] si non trouvé.\n>>> find_target_positions \"5 7 7 8 8 10\" 8\n3 4\n>>> find_target_positions \"5 7 7 8 8 10\" 6\n-1 -1",
      "de": "Schreiben Sie eine Shell-Funktion `find_target_positions() {\nlocal -a nums=($1)\nlocal target=$2`, um das folgende Problem zu lösen:\n\nFinden Sie die Start- und Endpositionen des Zielwerts in einem nicht abnehmenden Array.\nDie Funktion nimmt einen String, der das Array darstellt, und ein ganzzahliges Ziel.\nGibt die Start- und Endpositionen des Ziels zurück oder [-1, -1], wenn nicht gefunden.\n>>> find_target_positions \"5 7 7 8 8 10\" 8\n3 4\n>>> find_target_positions \"5 7 7 8 8 10\" 6\n-1 -1",
      "ha": "Rubuta wani aikin Shell `find_target_positions() {\nlocal -a nums=($1)\nlocal target=$2` don warware matsalar mai zuwa:\n\nNemo wuraren farawa da ƙarewar ƙimar manufa a cikin jerin da ba ya raguwa.\nAikin yana ɗaukar wani kirtani da ke wakiltar jerin da kuma adadi manufa.\nYana mayar da wuraren farawa da ƙarewar manufa, ko [-1, -1] idan ba a samu ba.\n>>> find_target_positions \"5 7 7 8 8 10\" 8\n3 4\n>>> find_target_positions \"5 7 7 8 8 10\" 6\n-1 -1",
      "hi": "Write a Shell function `find_target_positions() {\nlocal -a nums=($1)\nlocal target=$2` निम्नलिखित समस्या को हल करने के लिए:\n\nगैर-घटते क्रम में एक सरणी में लक्ष्य मान की प्रारंभ और अंत स्थितियाँ खोजें।\nयह फ़ंक्शन सरणी का प्रतिनिधित्व करने वाली एक स्ट्रिंग और एक पूर्णांक लक्ष्य लेता है।\nलक्ष्य की प्रारंभ और अंत स्थितियाँ लौटाता है, या [-1, -1] अगर नहीं मिला।\n>>> find_target_positions \"5 7 7 8 8 10\" 8\n3 4\n>>> find_target_positions \"5 7 7 8 8 10\" 6\n-1 -1",
      "hu": "Írj egy Shell függvényt `find_target_positions() {\nlocal -a nums=($1)\nlocal target=$2` a következő probléma megoldására:\n\nTaláld meg a célérték kezdő és végpozícióját egy nem csökkenő tömbben.\nA függvény egy karakterláncot vesz át, amely a tömböt reprezentálja, és egy egész számot, mint célt.\nVisszaadja a cél kezdő és végpozícióját, vagy [-1, -1]-et, ha nem található.\n>>> find_target_positions \"5 7 7 8 8 10\" 8\n3 4\n>>> find_target_positions \"5 7 7 8 8 10\" 6\n-1 -1"
    },
    "instruction_bertscore": {
      "sq": "0.9885350544066662",
      "hy": "0.9830560339761999",
      "bn": "1",
      "bg": "0.9955618027661565",
      "zh": "0.9903680155628563",
      "fr": "0.9947297401000013",
      "de": "0.9940170542928481",
      "ha": "0.9749181472652005",
      "hi": "0.9927785938670957",
      "hu": "0.98259541012258"
    },
    "level": "hard",
    "test": "test_find_target_positions() {\n[[ $(find_target_positions \"5 7 7 8 8 10\" 8) == \"3 4\" ]] || { echo \"Test 1 failed\"; exit 1; }\n[[ $(find_target_positions \"5 7 7 8 8 10\" 6) == \"-1 -1\" ]] || { echo \"Test 2 failed\"; exit 1; }\n[[ $(find_target_positions \"1 2 3 4 5\" 5) == \"4 4\" ]] || { echo \"Test 3 failed\"; exit 1; }\n[[ $(find_target_positions \"1 2 3 4 5\" 1) == \"0 0\" ]] || { echo \"Test 4 failed\"; exit 1; }\n[[ $(find_target_positions \"1 1 1 1 1\" 1) == \"0 4\" ]] || { echo \"Test 5 failed\"; exit 1; }\n[[ $(find_target_positions \"1 2 3 3 3 4 5\" 3) == \"2 4\" ]] || { echo \"Test 6 failed\"; exit 1; }\n[[ $(find_target_positions \"1 2 2 3 4 5\" 2) == \"1 2\" ]] || { echo \"Test 7 failed\"; exit 1; }\n}\n\ntest_find_target_positions",
    "entry_point": "find_target_positions",
    "signature": "find_target_positions() {\nlocal -a nums=($1)\nlocal target=$2",
    "docstring": {
      "en": "\nFind the start and end positions of the target value in a non-decreasing array.\nThe function takes a string representing the array and an integer target.\nReturns the start and end positions of the target, or [-1, -1] if not found.\n>>> find_target_positions \"5 7 7 8 8 10\" 8\n3 4\n>>> find_target_positions \"5 7 7 8 8 10\" 6\n-1 -1\n",
      "sq": "Gjeni pozicionet e fillimit dhe të mbarimit të vlerës së synuar në një varg që nuk zvogëlohet.\nFunksioni merr një varg që përfaqëson vargun dhe një synim të plotë.\nKthen pozicionet e fillimit dhe të mbarimit të synimit, ose [-1, -1] nëse nuk gjendet.\n>>> find_target_positions \"5 7 7 8 8 10\" 8\n3 4\n>>> find_target_positions \"5 7 7 8 8 10\" 6\n-1 -1",
      "hy": "Գտնել թիրախ արժեքի սկզբի և վերջի դիրքերը չնվազող զանգվածում։  \nՖունկցիան ընդունում է զանգվածը ներկայացնող տող և ամբողջ թիվ թիրախ։  \nՎերադարձնում է թիրախի սկզբի և վերջի դիրքերը, կամ [-1, -1], եթե չի գտնվել։  \n>>> find_target_positions \"5 7 7 8 8 10\" 8  \n3 4  \n>>> find_target_positions \"5 7 7 8 8 10\" 6  \n-1 -1  ",
      "bn": "অ-হ্রাসমান অ্যারেতে লক্ষ্য মানের শুরুর এবং শেষ অবস্থানগুলি খুঁজে বের করুন। \nফাংশনটি অ্যারের প্রতিনিধিত্বকারী একটি স্ট্রিং এবং একটি পূর্ণসংখ্যা লক্ষ্য গ্রহণ করে। \nলক্ষ্যের শুরুর এবং শেষ অবস্থানগুলি ফেরত দেয়, অথবা [-1, -1] যদি না পাওয়া যায়। \n>>> find_target_positions \"5 7 7 8 8 10\" 8\n3 4\n>>> find_target_positions \"5 7 7 8 8 10\" 6\n-1 -1",
      "bg": "Намерете началната и крайната позиция на целевата стойност в ненамаляващ масив. \nФункцията приема низ, представляващ масива, и цяло число цел. \nВръща началната и крайната позиция на целта, или [-1, -1], ако не е намерена.\n>>> find_target_positions \"5 7 7 8 8 10\" 8\n3 4\n>>> find_target_positions \"5 7 7 8 8 10\" 6\n-1 -1",
      "zh": "在非递减数组中查找目标值的起始和结束位置。  \n该函数接受一个表示数组的字符串和一个整数目标。  \n返回目标的起始和结束位置，如果未找到则返回 [-1, -1]。  \n>>> find_target_positions \"5 7 7 8 8 10\" 8  \n3 4  \n>>> find_target_positions \"5 7 7 8 8 10\" 6  \n-1 -1  ",
      "fr": "Trouver les positions de début et de fin de la valeur cible dans un tableau non décroissant.  \nLa fonction prend une chaîne représentant le tableau et un entier cible.  \nRenvoie les positions de début et de fin de la cible, ou [-1, -1] si non trouvé.  \n>>> find_target_positions \"5 7 7 8 8 10\" 8  \n3 4  \n>>> find_target_positions \"5 7 7 8 8 10\" 6  \n-1 -1  ",
      "de": "Finde die Start- und Endpositionen des Zielwerts in einem nicht abnehmenden Array.  \nDie Funktion nimmt einen String, der das Array darstellt, und ein Integer-Ziel.  \nGibt die Start- und Endpositionen des Ziels zurück, oder [-1, -1], wenn nicht gefunden.  \n>>> find_target_positions \"5 7 7 8 8 10\" 8  \n3 4  \n>>> find_target_positions \"5 7 7 8 8 10\" 6  \n-1 -1  ",
      "ha": "Nemo wuraren farawa da ƙarewa na ƙimar manufa a cikin jerin da ba ya raguwa. \nAikin yana ɗaukar igiyar da ke wakiltar jerin da kuma integer manufa. \nYana mayar da wuraren farawa da ƙarewa na manufa, ko [-1, -1] idan ba a samu ba.\n>>> find_target_positions \"5 7 7 8 8 10\" 8\n3 4\n>>> find_target_positions \"5 7 7 8 8 10\" 6\n-1 -1",
      "hi": "गैर-घटते क्रम में व्यवस्थित एक array में लक्षित मान की आरंभ और अंत स्थितियाँ खोजें। \nयह फ़ंक्शन array का प्रतिनिधित्व करने वाले एक स्ट्रिंग और एक पूर्णांक लक्ष्य को लेता है। \nलक्ष्य की आरंभ और अंत स्थितियाँ लौटाता है, या [-1, -1] यदि नहीं मिला। \n>>> find_target_positions \"5 7 7 8 8 10\" 8\n3 4\n>>> find_target_positions \"5 7 7 8 8 10\" 6\n-1 -1",
      "hu": "Keresse meg a célérték kezdő és végpozícióját egy nem csökkenő tömbben.  \nA függvény egy karakterláncot vesz fel, amely a tömböt reprezentálja, és egy egész szám célt.  \nVisszaadja a cél kezdő és végpozícióját, vagy [-1, -1] ha nem található.  \n>>> find_target_positions \"5 7 7 8 8 10\" 8  \n3 4  \n>>> find_target_positions \"5 7 7 8 8 10\" 6  \n-1 -1  "
    },
    "docstring_bertscore": {
      "sq": "0.9812131413009582",
      "hy": "0.999999801369619",
      "bn": "0.9964053859944116",
      "bg": "0.9929784160304167",
      "zh": "0.9920371066546924",
      "fr": "0.9964631874352928",
      "de": "0.999999801369619",
      "ha": "0.9716453144768886",
      "hi": "0.9713821292220175",
      "hu": "0.9891194249876709"
    }
  },
  {
    "task_id": "Shell/15",
    "prompt": {
      "en": "#!/bin/bash\n\n# Validate a 9x9 Sudoku board.\n# The function takes a 9x9 Sudoku board as a string, where rows are separated by semicolons and elements by spaces.\n# Returns \"true\" if the Sudoku is valid, \"false\" otherwise.\n# >>> is_valid_sudoku \"5 3 . . 7 . . . .;6 . . 1 9 5 . . .;. 9 8 . . . . 6 .;8 . . . 6 . . . 3;4 . . 8 . 3 . . 1;7 . . . 2 . . . 6;. 6 . . . . 2 8 .;. . . 4 1 9 . . 5;. . . . 8 . . 7 9\"\n# true\n# >>> is_valid_sudoku \"8 3 . . 7 . . . .;6 . . 1 9 5 . . .;. 9 8 . . . . 6 .;8 . . . 6 . . . 3;4 . . 8 . 3 . . 1;7 . . . 2 . . . 6;. 6 . . . . 2 8 .;. . . 4 1 9 . . 5;. . . . 8 . . 7 9\"\n# false\nis_valid_sudoku() {\nlocal board=$1\nlocal -A rowSeen colSeen boxSeen\n\n# Convert string to 2D array\nlocal -a grid\nIFS=';' read -ra grid <<< \"$board\"",
      "sq": "#!/bin/bash\n\n# Vlerësoni një tabelë Sudoku 9x9.\n# Funksioni merr një tabelë Sudoku 9x9 si një varg, ku rreshtat ndahen me pikëpresje dhe elementet me hapësira.\n# Kthen \"true\" nëse Sudoku është i vlefshëm, \"false\" përndryshe.\n# >>> is_valid_sudoku \"5 3 . . 7 . . . .;6 . . 1 9 5 . . .;. 9 8 . . . . 6 .;8 . . . 6 . . . 3;4 . . 8 . 3 . . 1;7 . . . 2 . . . 6;. 6 . . . . 2 8 .;. . . 4 1 9 . . 5;. . . . 8 . . 7 9\"\n# true\n# >>> is_valid_sudoku \"8 3 . . 7 . . . .;6 . . 1 9 5 . . .;. 9 8 . . . . 6 .;8 . . . 6 . . . 3;4 . . 8 . 3 . . 1;7 . . . 2 . . . 6;. 6 . . . . 2 8 .;. . . 4 1 9 . . 5;. . . . 8 . . 7 9\"\n# false\nis_valid_sudoku() {\nlocal board=$1\nlocal -A rowSeen colSeen boxSeen\n\n# Konvertoni vargun në një varg 2D\nlocal -a grid\nIFS=';' read -ra grid <<< \"$board\"",
      "hy": "#!/bin/bash\n\n# Վավերացրեք 9x9 Սուդոկու տախտակը:\n# Ֆունկցիան ընդունում է 9x9 Սուդոկու տախտակ որպես տող, որտեղ տողերը բաժանված են կետ-ստորակետներով, իսկ տարրերը՝ բացատներով:\n# Վերադարձնում է \"true\", եթե Սուդոկուն վավեր է, \"false\"՝ հակառակ դեպքում:\n# >>> is_valid_sudoku \"5 3 . . 7 . . . .;6 . . 1 9 5 . . .;. 9 8 . . . . 6 .;8 . . . 6 . . . 3;4 . . 8 . 3 . . 1;7 . . . 2 . . . 6;. 6 . . . . 2 8 .;. . . 4 1 9 . . 5;. . . . 8 . . 7 9\"\n# true\n# >>> is_valid_sudoku \"8 3 . . 7 . . . .;6 . . 1 9 5 . . .;. 9 8 . . . . 6 .;8 . . . 6 . . . 3;4 . . 8 . 3 . . 1;7 . . . 2 . . . 6;. 6 . . . . 2 8 .;. . . 4 1 9 . . 5;. . . . 8 . . 7 9\"\n# false\nis_valid_sudoku() {\nlocal board=$1\nlocal -A rowSeen colSeen boxSeen\n\n# Տողը փոխակերպեք 2D զանգվածի\nlocal -a grid\nIFS=';' read -ra grid <<< \"$board\"",
      "bn": "#!/bin/bash\n\n# একটি 9x9 সুডোকু বোর্ড যাচাই করুন।\n# ফাংশনটি একটি 9x9 সুডোকু বোর্ডকে একটি স্ট্রিং হিসেবে গ্রহণ করে, যেখানে সারিগুলি সেমিকোলন দ্বারা এবং উপাদানগুলি স্পেস দ্বারা পৃথক করা হয়।\n# যদি সুডোকু বৈধ হয় তবে \"true\" রিটার্ন করে, অন্যথায় \"false\" রিটার্ন করে।\n# >>> is_valid_sudoku \"5 3 . . 7 . . . .;6 . . 1 9 5 . . .;. 9 8 . . . . 6 .;8 . . . 6 . . . 3;4 . . 8 . 3 . . 1;7 . . . 2 . . . 6;. 6 . . . . 2 8 .;. . . 4 1 9 . . 5;. . . . 8 . . 7 9\"\n# true\n# >>> is_valid_sudoku \"8 3 . . 7 . . . .;6 . . 1 9 5 . . .;. 9 8 . . . . 6 .;8 . . . 6 . . . 3;4 . . 8 . 3 . . 1;7 . . . 2 . . . 6;. 6 . . . . 2 8 .;. . . 4 1 9 . . 5;. . . . 8 . . 7 9\"\n# false\nis_valid_sudoku() {\nlocal board=$1\nlocal -A rowSeen colSeen boxSeen\n\n# স্ট্রিংকে 2D অ্যারেতে রূপান্তর করুন\nlocal -a grid\nIFS=';' read -ra grid <<< \"$board\"",
      "bg": "#!/bin/bash\n\n# Валидира 9x9 Судоку дъска.\n# Функцията приема 9x9 Судоку дъска като низ, където редовете са разделени със запетаи, а елементите с интервали.\n# Връща \"true\", ако Судокуто е валидно, \"false\" в противен случай.\n# >>> is_valid_sudoku \"5 3 . . 7 . . . .;6 . . 1 9 5 . . .;. 9 8 . . . . 6 .;8 . . . 6 . . . 3;4 . . 8 . 3 . . 1;7 . . . 2 . . . 6;. 6 . . . . 2 8 .;. . . 4 1 9 . . 5;. . . . 8 . . 7 9\"\n# true\n# >>> is_valid_sudoku \"8 3 . . 7 . . . .;6 . . 1 9 5 . . .;. 9 8 . . . . 6 .;8 . . . 6 . . . 3;4 . . 8 . 3 . . 1;7 . . . 2 . . . 6;. 6 . . . . 2 8 .;. . . 4 1 9 . . 5;. . . . 8 . . 7 9\"\n# false\nis_valid_sudoku() {\nlocal board=$1\nlocal -A rowSeen colSeen boxSeen\n\n# Преобразува низа в 2D масив\nlocal -a grid\nIFS=';' read -ra grid <<< \"$board\"",
      "zh": "#!/bin/bash\n\n# 验证一个9x9的数独棋盘。\n# 该函数接收一个9x9的数独棋盘作为字符串，其中行用分号分隔，元素用空格分隔。\n# 如果数独有效，则返回 \"true\"，否则返回 \"false\"。\n# >>> is_valid_sudoku \"5 3 . . 7 . . . .;6 . . 1 9 5 . . .;. 9 8 . . . . 6 .;8 . . . 6 . . . 3;4 . . 8 . 3 . . 1;7 . . . 2 . . . 6;. 6 . . . . 2 8 .;. . . 4 1 9 . . 5;. . . . 8 . . 7 9\"\n# true\n# >>> is_valid_sudoku \"8 3 . . 7 . . . .;6 . . 1 9 5 . . .;. 9 8 . . . . 6 .;8 . . . 6 . . . 3;4 . . 8 . 3 . . 1;7 . . . 2 . . . 6;. 6 . . . . 2 8 .;. . . 4 1 9 . . 5;. . . . 8 . . 7 9\"\n# false\nis_valid_sudoku() {\nlocal board=$1\nlocal -A rowSeen colSeen boxSeen\n\n# 将字符串转换为二维数组\nlocal -a grid\nIFS=';' read -ra grid <<< \"$board\"",
      "fr": "#!/bin/bash\n\n# Valider un tableau de Sudoku 9x9.\n# La fonction prend un tableau de Sudoku 9x9 sous forme de chaîne, où les lignes sont séparées par des points-virgules et les éléments par des espaces.\n# Retourne \"true\" si le Sudoku est valide, \"false\" sinon.\n# >>> is_valid_sudoku \"5 3 . . 7 . . . .;6 . . 1 9 5 . . .;. 9 8 . . . . 6 .;8 . . . 6 . . . 3;4 . . 8 . 3 . . 1;7 . . . 2 . . . 6;. 6 . . . . 2 8 .;. . . 4 1 9 . . 5;. . . . 8 . . 7 9\"\n# true\n# >>> is_valid_sudoku \"8 3 . . 7 . . . .;6 . . 1 9 5 . . .;. 9 8 . . . . 6 .;8 . . . 6 . . . 3;4 . . 8 . 3 . . 1;7 . . . 2 . . . 6;. 6 . . . . 2 8 .;. . . 4 1 9 . . 5;. . . . 8 . . 7 9\"\n# false\nis_valid_sudoku() {\nlocal board=$1\nlocal -A rowSeen colSeen boxSeen\n\n# Convertir la chaîne en tableau 2D\nlocal -a grid\nIFS=';' read -ra grid <<< \"$board\"",
      "de": "#!/bin/bash\n\n# Validiert ein 9x9 Sudoku-Brett.\n# Die Funktion nimmt ein 9x9 Sudoku-Brett als Zeichenkette, wobei Reihen durch Semikolons und Elemente durch Leerzeichen getrennt sind.\n# Gibt \"true\" zurück, wenn das Sudoku gültig ist, andernfalls \"false\".\n# >>> is_valid_sudoku \"5 3 . . 7 . . . .;6 . . 1 9 5 . . .;. 9 8 . . . . 6 .;8 . . . 6 . . . 3;4 . . 8 . 3 . . 1;7 . . . 2 . . . 6;. 6 . . . . 2 8 .;. . . 4 1 9 . . 5;. . . . 8 . . 7 9\"\n# true\n# >>> is_valid_sudoku \"8 3 . . 7 . . . .;6 . . 1 9 5 . . .;. 9 8 . . . . 6 .;8 . . . 6 . . . 3;4 . . 8 . 3 . . 1;7 . . . 2 . . . 6;. 6 . . . . 2 8 .;. . . 4 1 9 . . 5;. . . . 8 . . 7 9\"\n# false\nis_valid_sudoku() {\nlocal board=$1\nlocal -A rowSeen colSeen boxSeen\n\n# Konvertiert Zeichenkette in ein 2D-Array\nlocal -a grid\nIFS=';' read -ra grid <<< \"$board\"",
      "ha": "#!/bin/bash\n\n# Tabbatar da ingancin allo Sudoku 9x9.\n# Aiki yana karɓar allo Sudoku 9x9 a matsayin igiya, inda layuka suka rabu da semicolons kuma abubuwa suka rabu da sarari.\n# Yana dawowa \"true\" idan Sudoku yana da inganci, \"false\" in ba haka ba.\n# >>> is_valid_sudoku \"5 3 . . 7 . . . .;6 . . 1 9 5 . . .;. 9 8 . . . . 6 .;8 . . . 6 . . . 3;4 . . 8 . 3 . . 1;7 . . . 2 . . . 6;. 6 . . . . 2 8 .;. . . 4 1 9 . . 5;. . . . 8 . . 7 9\"\n# true\n# >>> is_valid_sudoku \"8 3 . . 7 . . . .;6 . . 1 9 5 . . .;. 9 8 . . . . 6 .;8 . . . 6 . . . 3;4 . . 8 . 3 . . 1;7 . . . 2 . . . 6;. 6 . . . . 2 8 .;. . . 4 1 9 . . 5;. . . . 8 . . 7 9\"\n# false\nis_valid_sudoku() {\nlocal board=$1\nlocal -A rowSeen colSeen boxSeen\n\n# Canza igiya zuwa jerin 2D\nlocal -a grid\nIFS=';' read -ra grid <<< \"$board\"",
      "hi": "#!/bin/bash\n\n# 9x9 Sudoku बोर्ड को मान्य करें।\n# फ़ंक्शन एक 9x9 Sudoku बोर्ड को एक स्ट्रिंग के रूप में लेता है, जहाँ पंक्तियाँ सेमीकोलन द्वारा और तत्व स्पेस द्वारा अलग होते हैं।\n# \"true\" लौटाता है यदि Sudoku मान्य है, अन्यथा \"false\"।\n# >>> is_valid_sudoku \"5 3 . . 7 . . . .;6 . . 1 9 5 . . .;. 9 8 . . . . 6 .;8 . . . 6 . . . 3;4 . . 8 . 3 . . 1;7 . . . 2 . . . 6;. 6 . . . . 2 8 .;. . . 4 1 9 . . 5;. . . . 8 . . 7 9\"\n# true\n# >>> is_valid_sudoku \"8 3 . . 7 . . . .;6 . . 1 9 5 . . .;. 9 8 . . . . 6 .;8 . . . 6 . . . 3;4 . . 8 . 3 . . 1;7 . . . 2 . . . 6;. 6 . . . . 2 8 .;. . . 4 1 9 . . 5;. . . . 8 . . 7 9\"\n# false\nis_valid_sudoku() {\nlocal board=$1\nlocal -A rowSeen colSeen boxSeen\n\n# स्ट्रिंग को 2D ऐरे में बदलें\nlocal -a grid\nIFS=';' read -ra grid <<< \"$board\"",
      "hu": "#!/bin/bash\n\n# Validál egy 9x9-es Sudoku táblát.\n# A függvény egy 9x9-es Sudoku táblát vesz fel stringként, ahol a sorokat pontosvesszők, az elemeket pedig szóközök választják el.\n# \"true\"-t ad vissza, ha a Sudoku érvényes, \"false\"-t egyébként.\n# >>> is_valid_sudoku \"5 3 . . 7 . . . .;6 . . 1 9 5 . . .;. 9 8 . . . . 6 .;8 . . . 6 . . . 3;4 . . 8 . 3 . . 1;7 . . . 2 . . . 6;. 6 . . . . 2 8 .;. . . 4 1 9 . . 5;. . . . 8 . . 7 9\"\n# true\n# >>> is_valid_sudoku \"8 3 . . 7 . . . .;6 . . 1 9 5 . . .;. 9 8 . . . . 6 .;8 . . . 6 . . . 3;4 . . 8 . 3 . . 1;7 . . . 2 . . . 6;. 6 . . . . 2 8 .;. . . 4 1 9 . . 5;. . . . 8 . . 7 9\"\n# false\nis_valid_sudoku() {\nlocal board=$1\nlocal -A rowSeen colSeen boxSeen\n\n# String átalakítása 2D tömbbé\nlocal -a grid\nIFS=';' read -ra grid <<< \"$board\""
    },
    "prompt_bertscore": {
      "sq": "0.9956994536202136",
      "hy": "0.9972201678174167",
      "bn": "0.9868252440867179",
      "bg": "0.9902720770888164",
      "zh": "0.9865386204468846",
      "fr": "0.9937822731824649",
      "de": "0.9902033509769783",
      "ha": "0.9757150523539125",
      "hi": "0.9917622022073401",
      "hu": "0.9991077523283913"
    },
    "canonical_solution": "for i in ${!grid[@]}; do\nIFS=' ' read -ra gridRow <<< \"${grid[i]}\"\nfor j in ${!gridRow[@]}; do\nlocal num=${gridRow[j]}\nif [[ \"$num\" != \".\" ]]; then\nlocal boxIndex=$((i / 3 * 3 + j / 3))\n\n# Check if the number has been seen before in the row, column, or box\nif [[ -n ${rowSeen[$i,$num]} || -n ${colSeen[$j,$num]} || -n ${boxSeen[$boxIndex,$num]} ]]; then\necho \"false\"\nreturn\nfi\n\n# Mark the number as seen for the row, column, and box\nrowSeen[$i,$num]=1\ncolSeen[$j,$num]=1\nboxSeen[$boxIndex,$num]=1\nfi\ndone\ndone\n\necho \"true\"\n}",
    "instruction": {
      "en": "Write a Shell function `is_valid_sudoku() {\nlocal board=$1\nlocal -A rowSeen colSeen boxSeen\n\n` to solve the following problem:\nConvert string to 2D array\nlocal -a grid\nIFS=';' read -ra grid <<< \"$board\"",
      "sq": "Shkruani një funksion Shell `is_valid_sudoku() {\nlocal board=$1\nlocal -A rowSeen colSeen boxSeen\n\n` për të zgjidhur problemin e mëposhtëm:\nKonvertoni vargun në një varg 2D\nlocal -a grid\nIFS=';' read -ra grid <<< \"$board\"`",
      "hy": "Գրեք Shell ֆունկցիա `is_valid_sudoku() {\nlocal board=$1\nlocal -A rowSeen colSeen boxSeen\n\n` հետևյալ խնդիրը լուծելու համար:\nՏողը փոխարկել 2D զանգվածի\nlocal -a grid\nIFS=';' read -ra grid <<< \"$board\"`",
      "bn": "একটি Shell ফাংশন লিখুন `is_valid_sudoku() {\nlocal board=$1\nlocal -A rowSeen colSeen boxSeen\n\n` নিম্নলিখিত সমস্যার সমাধানের জন্য:\nস্ট্রিংকে 2D অ্যারেতে রূপান্তর করুন\nlocal -a grid\nIFS=';' read -ra grid <<< \"$board\"`",
      "bg": "Напишете Shell функция `is_valid_sudoku() {\nlocal board=$1\nlocal -A rowSeen colSeen boxSeen\n\n` за решаване на следния проблем:\nПреобразуване на низ в двумерен масив\nlocal -a grid\nIFS=';' read -ra grid <<< \"$board\"`",
      "zh": "编写一个 Shell 函数 `is_valid_sudoku() {\nlocal board=$1\nlocal -A rowSeen colSeen boxSeen\n\n` 来解决以下问题：\n将字符串转换为二维数组\nlocal -a grid\nIFS=';' read -ra grid <<< \"$board\"`",
      "fr": "Écrire une fonction Shell `is_valid_sudoku() {\nlocal board=$1\nlocal -A rowSeen colSeen boxSeen\n\n` pour résoudre le problème suivant :\nConvertir une chaîne en tableau 2D\nlocal -a grid\nIFS=';' read -ra grid <<< \"$board\"`",
      "de": "Schreiben Sie eine Shell-Funktion `is_valid_sudoku() {\nlocal board=$1\nlocal -A rowSeen colSeen boxSeen\n\n` um das folgende Problem zu lösen:\nZeichenkette in 2D-Array umwandeln\nlocal -a grid\nIFS=';' read -ra grid <<< \"$board\"`",
      "ha": "Rubuta wani aikin Shell `is_valid_sudoku() {\nlocal board=$1\nlocal -A rowSeen colSeen boxSeen\n\n` don warware matsalar mai zuwa:\nCanza igiya zuwa jerin 2D\nlocal -a grid\nIFS=';' read -ra grid <<< \"$board\"`",
      "hi": "Shell फ़ंक्शन `is_valid_sudoku() {\nlocal board=$1\nlocal -A rowSeen colSeen boxSeen\n\n` निम्नलिखित समस्या को हल करने के लिए:\nस्ट्रिंग को 2D एरे में परिवर्तित करें\nlocal -a grid\nIFS=';' read -ra grid <<< \"$board\"`",
      "hu": "Írj egy Shell függvényt `is_valid_sudoku() {\nlocal board=$1\nlocal -A rowSeen colSeen boxSeen\n\n` a következő probléma megoldására:\nKonvertálj egy karakterláncot 2D tömbbé\nlocal -a grid\nIFS=';' read -ra grid <<< \"$board\"`"
    },
    "instruction_bertscore": {
      "sq": "0.981240750923922",
      "hy": "0.9817651351298542",
      "bn": "0.981240750923922",
      "bg": "0.9720386026313378",
      "zh": "0.972409842813492",
      "fr": "0.9814207100491397",
      "de": "0.9897359736904032",
      "ha": "0.9817651351298542",
      "hi": "0.9609147054022409",
      "hu": "0.9814207100491397"
    },
    "level": "middle",
    "test": "# Testing function\ntest_is_valid_sudoku() {\nlocal validSudoku=\"5 3 . . 7 . . . .;6 . . 1 9 5 . . .;. 9 8 . . . . 6 .;8 . . . 6 . . . 3;4 . . 8 . 3 . . 1;7 . . . 2 . . . 6;. 6 . . . . 2 8 .;. . . 4 1 9 . . 5;. . . . 8 . . 7 9\"\nlocal invalidSudoku=\"8 3 . . 7 . . . .;6 . . 1 9 5 . . .;. 9 8 . . . . 6 .;8 . . . 6 . . . 3;4 . . 8 . 3 . . 1;7 . . . 2 . . . 6;. 6 . . . . 2 8 .;. . . 4 1 9 . . 5;. . . . 8 . . 7 9\"\n\n[[ $(is_valid_sudoku \"$validSudoku\") == \"true\" ]] || { echo \"Test 1 failed\"; exit 1; }\n[[ $(is_valid_sudoku \"$invalidSudoku\") == \"false\" ]] || { echo \"Test 2 failed\"; exit 1; }\n}\n\ntest_is_valid_sudoku",
    "entry_point": "is_valid_sudoku",
    "signature": "is_valid_sudoku() {\nlocal board=$1\nlocal -A rowSeen colSeen boxSeen\n\n",
    "docstring": {
      "en": "Convert string to 2D array\nlocal -a grid\nIFS=';' read -ra grid <<< \"$board\"",
      "sq": "Convertimi i vargut në një varg 2D  \nlokale -a grid  \nIFS=';' lexoni -ra grid <<< \"$board\"",
      "hy": "Տողը փոխարկել 2D զանգվածի  \nտեղական -ա ցանց  \nIFS=';' կարդալ -րա ցանց <<< \"$board\"",
      "bn": "স্ট্রিংকে 2D অ্যারেতে রূপান্তর করুন  \nlocal -a grid  \nIFS=';' read -ra grid <<< \"$board\"",
      "bg": "Преобразуване на низ в 2D масив  \nlocal -a grid  \nIFS=';' read -ra grid <<< \"$board\"",
      "zh": "将字符串转换为二维数组  \nlocal -a grid  \nIFS=';' read -ra grid <<< \"$board\"",
      "fr": "Convertir une chaîne en tableau 2D  \nlocal -a grid  \nIFS=';' read -ra grid <<< \"$board\"",
      "de": "Konvertiere Zeichenkette in ein 2D-Array  \nlocal -a grid  \nIFS=';' read -ra grid <<< \"$board\"",
      "ha": "Canza kirtani zuwa tsararraki 2D  \nlocal -a grid  \nIFS=';' read -ra grid <<< \"$board\"",
      "hi": "Convert string to 2D array  \nlocal -a grid  \nIFS=';' read -ra grid <<< \"$board\"",
      "hu": "Konvertálja a karakterláncot kétdimenziós tömbbé  \nhelyi -a grid  \nIFS=';' read -ra grid <<< \"$board\""
    },
    "docstring_bertscore": {
      "sq": "0.9473432846180322",
      "hy": "1",
      "bn": "0.9686024956698153",
      "bg": "0.9762646626182361",
      "zh": "0.9435875813734245",
      "fr": "0.9677454055756497",
      "de": "0.9886153010806044",
      "ha": "0.976765409808825",
      "hi": "1",
      "hu": "0.9381941706371842"
    }
  },
  {
    "task_id": "Shell/16",
    "prompt": {
      "en": "#!/bin/bash\n\n# Count the number of strings that appear exactly once in both arrays.\n# The function takes two strings representing the arrays, where elements are separated by spaces.\n# Returns the count of strings that appear exactly once in both arrays.\n# >>> count_unique_strings \"apple banana mango\" \"banana fruits apple\"\n# 2\n# >>> count_unique_strings \"hello world\" \"world hello planet\"\n# 2\ncount_unique_strings() {\nlocal -a words1=($1)\nlocal -a words2=($2)",
      "sq": "#!/bin/bash\n\n# Numëron numrin e vargjeve që shfaqen saktësisht një herë në të dyja vargjet.\n# Funksioni merr dy vargje që përfaqësojnë vargjet, ku elementet ndahen me hapësira.\n# Kthen numrin e vargjeve që shfaqen saktësisht një herë në të dyja vargjet.\n# >>> count_unique_strings \"apple banana mango\" \"banana fruits apple\"\n# 2\n# >>> count_unique_strings \"hello world\" \"world hello planet\"\n# 2\ncount_unique_strings() {\nlocal -a words1=($1)\nlocal -a words2=($2)",
      "hy": "#!/bin/bash\n\n# Հաշվել այն տողերի քանակը, որոնք հայտնվում են միայն մեկ անգամ երկու զանգվածներում։\n# Ֆունկցիան ընդունում է երկու տող, որոնք ներկայացնում են զանգվածները, որտեղ տարրերը բաժանված են բացատներով։\n# Վերադարձնում է այն տողերի քանակը, որոնք հայտնվում են միայն մեկ անգամ երկու զանգվածներում։\n# >>> count_unique_strings \"apple banana mango\" \"banana fruits apple\"\n# 2\n# >>> count_unique_strings \"hello world\" \"world hello planet\"\n# 2\ncount_unique_strings() {\nlocal -a words1=($1)\nlocal -a words2=($2)",
      "bn": "#!/bin/bash\n\n# উভয় অ্যারেতে ঠিক একবার উপস্থিত স্ট্রিংগুলির সংখ্যা গণনা করুন।\n# ফাংশনটি দুটি স্ট্রিং নেয় যা অ্যারেগুলিকে উপস্থাপন করে, যেখানে উপাদানগুলি স্পেস দ্বারা পৃথক করা থাকে।\n# উভয় অ্যারেতে ঠিক একবার উপস্থিত স্ট্রিংগুলির সংখ্যা ফেরত দেয়।\n# >>> count_unique_strings \"apple banana mango\" \"banana fruits apple\"\n# 2\n# >>> count_unique_strings \"hello world\" \"world hello planet\"\n# 2\ncount_unique_strings() {\nlocal -a words1=($1)\nlocal -a words2=($2)",
      "bg": "#!/bin/bash\n\n# Преброй броя на низовете, които се появяват точно веднъж в двата масива.\n# Функцията приема два низа, представляващи масивите, където елементите са разделени с интервали.\n# Връща броя на низовете, които се появяват точно веднъж в двата масива.\n# >>> count_unique_strings \"apple banana mango\" \"banana fruits apple\"\n# 2\n# >>> count_unique_strings \"hello world\" \"world hello planet\"\n# 2\ncount_unique_strings() {\nlocal -a words1=($1)\nlocal -a words2=($2)",
      "zh": "#!/bin/bash\n\n# 计算在两个数组中恰好出现一次的字符串数量。\n# 该函数接受两个表示数组的字符串，其中元素由空格分隔。\n# 返回在两个数组中恰好出现一次的字符串数量。\n# >>> count_unique_strings \"apple banana mango\" \"banana fruits apple\"\n# 2\n# >>> count_unique_strings \"hello world\" \"world hello planet\"\n# 2\ncount_unique_strings() {\nlocal -a words1=($1)\nlocal -a words2=($2)",
      "fr": "#!/bin/bash\n\n# Compter le nombre de chaînes qui apparaissent exactement une fois dans les deux tableaux.\n# La fonction prend deux chaînes représentant les tableaux, où les éléments sont séparés par des espaces.\n# Renvoie le nombre de chaînes qui apparaissent exactement une fois dans les deux tableaux.\n# >>> count_unique_strings \"apple banana mango\" \"banana fruits apple\"\n# 2\n# >>> count_unique_strings \"hello world\" \"world hello planet\"\n# 2\ncount_unique_strings() {\nlocal -a words1=($1)\nlocal -a words2=($2)",
      "de": "#!/bin/bash\n\n# Zählt die Anzahl der Zeichenfolgen, die genau einmal in beiden Arrays erscheinen.\n# Die Funktion nimmt zwei Zeichenfolgen entgegen, die die Arrays repräsentieren, wobei die Elemente durch Leerzeichen getrennt sind.\n# Gibt die Anzahl der Zeichenfolgen zurück, die genau einmal in beiden Arrays erscheinen.\n# >>> count_unique_strings \"apple banana mango\" \"banana fruits apple\"\n# 2\n# >>> count_unique_strings \"hello world\" \"world hello planet\"\n# 2\ncount_unique_strings() {\nlocal -a words1=($1)\nlocal -a words2=($2)",
      "ha": "#!/bin/bash\n\n# Ƙirga adadin igiyoyi da suka bayyana sau ɗaya kawai a cikin dukkanin jerin.\n# Aiki yana ɗaukar igiyoyi biyu da ke wakiltar jerin, inda abubuwa ke rabuwa da sarari.\n# Yana mayar da adadin igiyoyi da suka bayyana sau ɗaya kawai a cikin dukkanin jerin.\n# >>> count_unique_strings \"apple banana mango\" \"banana fruits apple\"\n# 2\n# >>> count_unique_strings \"hello world\" \"world hello planet\"\n# 2\ncount_unique_strings() {\nlocal -a words1=($1)\nlocal -a words2=($2)",
      "hi": "#!/bin/bash\n\n# उन स्ट्रिंग्स की संख्या गिनें जो दोनों ऐरे में ठीक एक बार दिखाई देती हैं।\n# यह फ़ंक्शन दो स्ट्रिंग्स लेता है जो ऐरे का प्रतिनिधित्व करती हैं, जहाँ तत्व स्पेस द्वारा अलग होते हैं।\n# उन स्ट्रिंग्स की संख्या लौटाता है जो दोनों ऐरे में ठीक एक बार दिखाई देती हैं।\n# >>> count_unique_strings \"apple banana mango\" \"banana fruits apple\"\n# 2\n# >>> count_unique_strings \"hello world\" \"world hello planet\"\n# 2\ncount_unique_strings() {\nlocal -a words1=($1)\nlocal -a words2=($2)",
      "hu": "#!/bin/bash\n\n# Számolja meg azoknak a karakterláncoknak a számát, amelyek pontosan egyszer fordulnak elő mindkét tömbben.\n# A függvény két karakterláncot vesz át, amelyek a tömböket reprezentálják, ahol az elemek szóközökkel vannak elválasztva.\n# Visszaadja azoknak a karakterláncoknak a számát, amelyek pontosan egyszer fordulnak elő mindkét tömbben.\n# >>> count_unique_strings \"apple banana mango\" \"banana fruits apple\"\n# 2\n# >>> count_unique_strings \"hello world\" \"world hello planet\"\n# 2\ncount_unique_strings() {\nlocal -a words1=($1)\nlocal -a words2=($2)"
    },
    "prompt_bertscore": {
      "sq": "0.9928769159057079",
      "hy": "0.961176897505207",
      "bn": "0.9926770937423868",
      "bg": "0.9934146083471693",
      "zh": "0.9854260916827082",
      "fr": "0.9934146083471693",
      "de": "0.9914463799014946",
      "ha": "0.9514819472372751",
      "hi": "0.990857043560964",
      "hu": "0.989768946333655"
    },
    "canonical_solution": "local -A count1 count2\nlocal unique_count=0\n\n# Count occurrences in words1\nfor word in \"${words1[@]}\"; do\n((count1[$word]++))\ndone\n\n# Count occurrences in words2\nfor word in \"${words2[@]}\"; do\n((count2[$word]++))\ndone\n\n# Find common strings with exactly one occurrence in each array\nfor word in \"${!count1[@]}\"; do\nif [[ ${count1[$word]} -eq 1 && ${count2[$word]} -eq 1 ]]; then\n((unique_count++))\nfi\ndone\n\necho $unique_count\n}",
    "instruction": {
      "en": "Write a Shell function `count_unique_strings() {\nlocal -a words1=($1)\nlocal -a words2=($2)` to solve the following problem:\n\nCount the number of strings that appear exactly once in both arrays.\nThe function takes two strings representing the arrays, where elements are separated by spaces.\nReturns the count of strings that appear exactly once in both arrays.\n>>> count_unique_strings \"apple banana mango\" \"banana fruits apple\"\n2\n>>> count_unique_strings \"hello world\" \"world hello planet\"\n2\n",
      "sq": "Shkruani një funksion Shell `count_unique_strings() {\nlocal -a words1=($1)\nlocal -a words2=($2)` për të zgjidhur problemin e mëposhtëm:\n\nNumëroni numrin e vargjeve që shfaqen saktësisht një herë në të dyja vargjet.\nFunksioni merr dy vargje që përfaqësojnë vargjet, ku elementet ndahen me hapësira.\nKthen numrin e vargjeve që shfaqen saktësisht një herë në të dyja vargjet.\n>>> count_unique_strings \"apple banana mango\" \"banana fruits apple\"\n2\n>>> count_unique_strings \"hello world\" \"world hello planet\"\n2\n",
      "hy": "Գրեք Shell ֆունկցիա `count_unique_strings() {\nlocal -a words1=($1)\nlocal -a words2=($2)` հետևյալ խնդիրը լուծելու համար:\n\nՀաշվեք այն տողերի քանակը, որոնք հայտնվում են ճիշտ մեկ անգամ երկու զանգվածներում:\nՖունկցիան ընդունում է երկու տող, որոնք ներկայացնում են զանգվածները, որտեղ տարրերը բաժանված են բացատներով:\nՎերադարձնում է այն տողերի քանակը, որոնք հայտնվում են ճիշտ մեկ անգամ երկու զանգվածներում:\n>>> count_unique_strings \"apple banana mango\" \"banana fruits apple\"\n2\n>>> count_unique_strings \"hello world\" \"world hello planet\"\n2",
      "bn": "Write a Shell function `count_unique_strings() {\nlocal -a words1=($1)\nlocal -a words2=($2)` নিম্নলিখিত সমস্যার সমাধান করতে:\n\nসেই স্ট্রিংগুলির সংখ্যা গণনা করুন যা উভয় অ্যারেতে ঠিক একবার উপস্থিত হয়।\nফাংশনটি দুটি স্ট্রিং নেয় যা অ্যারের প্রতিনিধিত্ব করে, যেখানে উপাদানগুলি স্পেস দ্বারা পৃথক করা হয়।\nফাংশনটি সেই স্ট্রিংগুলির সংখ্যা ফেরত দেয় যা উভয় অ্যারেতে ঠিক একবার উপস্থিত হয়।\n>>> count_unique_strings \"apple banana mango\" \"banana fruits apple\"\n2\n>>> count_unique_strings \"hello world\" \"world hello planet\"\n2",
      "bg": "Напишете Shell функция `count_unique_strings() {\nlocal -a words1=($1)\nlocal -a words2=($2)` за решаване на следния проблем:\n\nБройте броя на низовете, които се появяват точно веднъж и в двата масива.\nФункцията приема два низа, представляващи масивите, където елементите са разделени с интервали.\nВръща броя на низовете, които се появяват точно веднъж и в двата масива.\n>>> count_unique_strings \"apple banana mango\" \"banana fruits apple\"\n2\n>>> count_unique_strings \"hello world\" \"world hello planet\"\n2",
      "zh": "编写一个 Shell 函数 `count_unique_strings() {\nlocal -a words1=($1)\nlocal -a words2=($2)` 来解决以下问题：\n\n统计在两个数组中恰好出现一次的字符串数量。\n该函数接受两个表示数组的字符串，其中元素由空格分隔。\n返回在两个数组中恰好出现一次的字符串的数量。\n>>> count_unique_strings \"apple banana mango\" \"banana fruits apple\"\n2\n>>> count_unique_strings \"hello world\" \"world hello planet\"\n2\n",
      "fr": "Écrire une fonction Shell `count_unique_strings() {\nlocal -a words1=($1)\nlocal -a words2=($2)` pour résoudre le problème suivant :\n\nCompter le nombre de chaînes qui apparaissent exactement une fois dans les deux tableaux.\nLa fonction prend deux chaînes représentant les tableaux, où les éléments sont séparés par des espaces.\nRenvoie le nombre de chaînes qui apparaissent exactement une fois dans les deux tableaux.\n>>> count_unique_strings \"apple banana mango\" \"banana fruits apple\"\n2\n>>> count_unique_strings \"hello world\" \"world hello planet\"\n2\n",
      "de": "Schreiben Sie eine Shell-Funktion `count_unique_strings() {\nlocal -a words1=($1)\nlocal -a words2=($2)` um das folgende Problem zu lösen:\n\nZählen Sie die Anzahl der Zeichenfolgen, die genau einmal in beiden Arrays erscheinen.\nDie Funktion nimmt zwei Zeichenfolgen entgegen, die die Arrays darstellen, wobei die Elemente durch Leerzeichen getrennt sind.\nGibt die Anzahl der Zeichenfolgen zurück, die genau einmal in beiden Arrays erscheinen.\n>>> count_unique_strings \"apple banana mango\" \"banana fruits apple\"\n2\n>>> count_unique_strings \"hello world\" \"world hello planet\"\n2\n",
      "ha": "Rubuta aikin Shell `count_unique_strings() {\nlocal -a words1=($1)\nlocal -a words2=($2)` don warware matsalar mai zuwa:\n\nƘirga adadin kirtani waɗanda suka bayyana sau ɗaya kawai a cikin duka arrays.\nAikin yana ɗaukar kirtani biyu da ke wakiltar arrays, inda abubuwa ke rabuwa da sarari.\nYa dawo da ƙididdigar kirtani waɗanda suka bayyana sau ɗaya kawai a cikin duka arrays.\n>>> count_unique_strings \"apple banana mango\" \"banana fruits apple\"\n2\n>>> count_unique_strings \"hello world\" \"world hello planet\"\n2",
      "hi": "Shell फ़ंक्शन `count_unique_strings() {\nlocal -a words1=($1)\nlocal -a words2=($2)` निम्नलिखित समस्या को हल करने के लिए लिखें:\n\nउन स्ट्रिंग्स की संख्या गिनें जो दोनों ऐरे में ठीक एक बार दिखाई देती हैं।\nयह फ़ंक्शन दो स्ट्रिंग्स लेता है जो ऐरे का प्रतिनिधित्व करती हैं, जहाँ तत्व स्पेस द्वारा अलग किए गए होते हैं।\nउन स्ट्रिंग्स की गिनती लौटाता है जो दोनों ऐरे में ठीक एक बार दिखाई देती हैं।\n>>> count_unique_strings \"apple banana mango\" \"banana fruits apple\"\n2\n>>> count_unique_strings \"hello world\" \"world hello planet\"\n2",
      "hu": "Írj egy Shell függvényt `count_unique_strings() {\nlocal -a words1=($1)\nlocal -a words2=($2)` a következő probléma megoldására:\n\nSzámold meg azon karakterláncok számát, amelyek pontosan egyszer fordulnak elő mindkét tömbben.\nA függvény két karakterláncot vesz át, amelyek a tömböket reprezentálják, ahol az elemek szóközzel vannak elválasztva.\nVisszaadja azon karakterláncok számát, amelyek pontosan egyszer fordulnak elő mindkét tömbben.\n>>> count_unique_strings \"apple banana mango\" \"banana fruits apple\"\n2\n>>> count_unique_strings \"hello world\" \"world hello planet\"\n2"
    },
    "instruction_bertscore": {
      "sq": "0.9964494819390014",
      "hy": "0.9825644237831386",
      "bn": "0.9877399369913836",
      "bg": "0.9826434786747904",
      "zh": "0.9880907182442912",
      "fr": "0.993452546749947",
      "de": "0.9915639690870672",
      "ha": "0.9836666237675011",
      "hi": "0.9771753829152809",
      "hu": "0.9773968557901349"
    },
    "level": "middle",
    "test": "# Testing function\ntest_count_unique_strings() {\n[[ $(count_unique_strings \"apple banana mango\" \"banana fruits apple\") == \"2\" ]] || { echo \"Test 1 failed\"; exit 1; }\n[[ $(count_unique_strings \"hello world\" \"world hello planet\") == \"2\" ]] || { echo \"Test 2 failed\"; exit 1; }\n[[ $(count_unique_strings \"one two three\" \"four five six\") == \"0\" ]] || { echo \"Test 3 failed\"; exit 1; }\n[[ $(count_unique_strings \"one two two\" \"two one one\") == \"0\" ]] || { echo \"Test 4 failed\"; exit 1; }\n[[ $(count_unique_strings \"a b c d e\" \"a b c d e\") == \"5\" ]] || { echo \"Test 5 failed\"; exit 1; }\n[[ $(count_unique_strings \"dog cat\" \"cat dog bird\") == \"2\" ]] || { echo \"Test 6 failed\"; exit 1; }\n[[ $(count_unique_strings \"x y z\" \"x y z a b c\") == \"3\" ]] || { echo \"Test 7 failed\"; exit 1; }\n}\n\ntest_count_unique_strings",
    "entry_point": "count_unique_strings",
    "signature": "count_unique_strings() {\nlocal -a words1=($1)\nlocal -a words2=($2)",
    "docstring": {
      "en": "\nCount the number of strings that appear exactly once in both arrays.\nThe function takes two strings representing the arrays, where elements are separated by spaces.\nReturns the count of strings that appear exactly once in both arrays.\n>>> count_unique_strings \"apple banana mango\" \"banana fruits apple\"\n2\n>>> count_unique_strings \"hello world\" \"world hello planet\"\n2\n",
      "sq": "Numëroni numrin e vargjeve që shfaqen saktësisht një herë në të dyja vargjet.\nFunksioni merr dy vargje që përfaqësojnë vargjet, ku elementet ndahen me hapësira.\nKthen numrin e vargjeve që shfaqen saktësisht një herë në të dyja vargjet.\n>>> count_unique_strings \"apple banana mango\" \"banana fruits apple\"\n2\n>>> count_unique_strings \"hello world\" \"world hello planet\"\n2",
      "hy": "Հաշվել տողերի քանակը, որոնք հայտնվում են հենց մեկ անգամ երկու զանգվածներում:\nՖունկցիան ընդունում է երկու տող, որոնք ներկայացնում են զանգվածները, որտեղ տարրերը բաժանված են բացատներով:\nՎերադարձնում է այն տողերի քանակը, որոնք հայտնվում են հենց մեկ անգամ երկու զանգվածներում:\n>>> count_unique_strings \"apple banana mango\" \"banana fruits apple\"\n2\n>>> count_unique_strings \"hello world\" \"world hello planet\"\n2",
      "bn": "দুটি অ্যারেতে ঠিক একবার প্রদর্শিত স্ট্রিংগুলির সংখ্যা গণনা করুন। \nফাংশনটি দুটি স্ট্রিং নেয় যা অ্যারেগুলিকে উপস্থাপন করে, যেখানে উপাদানগুলি স্পেস দ্বারা পৃথক করা হয়। \nদুটি অ্যারেতে ঠিক একবার প্রদর্শিত স্ট্রিংগুলির সংখ্যা ফেরত দেয়। \n>>> count_unique_strings \"apple banana mango\" \"banana fruits apple\"\n2\n>>> count_unique_strings \"hello world\" \"world hello planet\"\n2",
      "bg": "Бройте броя на низовете, които се появяват точно веднъж и в двата масива. \nФункцията приема два низа, представляващи масивите, където елементите са разделени с интервали. \nВръща броя на низовете, които се появяват точно веднъж и в двата масива.\n>>> count_unique_strings \"apple banana mango\" \"banana fruits apple\"\n2\n>>> count_unique_strings \"hello world\" \"world hello planet\"\n2",
      "zh": "计算在两个数组中恰好出现一次的字符串数量。  \n该函数接收两个表示数组的字符串，其中元素由空格分隔。  \n返回在两个数组中恰好出现一次的字符串的计数。  \n>>> count_unique_strings \"apple banana mango\" \"banana fruits apple\"  \n2  \n>>> count_unique_strings \"hello world\" \"world hello planet\"  \n2  ",
      "fr": "Comptez le nombre de chaînes qui apparaissent exactement une fois dans les deux tableaux.  \nLa fonction prend deux chaînes représentant les tableaux, où les éléments sont séparés par des espaces.  \nRenvoie le nombre de chaînes qui apparaissent exactement une fois dans les deux tableaux.  \n>>> count_unique_strings \"apple banana mango\" \"banana fruits apple\"  \n2  \n>>> count_unique_strings \"hello world\" \"world hello planet\"  \n2  ",
      "de": "Zähle die Anzahl der Zeichenfolgen, die genau einmal in beiden Arrays erscheinen.\nDie Funktion nimmt zwei Zeichenfolgen entgegen, die die Arrays darstellen, wobei die Elemente durch Leerzeichen getrennt sind.\nGibt die Anzahl der Zeichenfolgen zurück, die genau einmal in beiden Arrays erscheinen.\n>>> count_unique_strings \"apple banana mango\" \"banana fruits apple\"\n2\n>>> count_unique_strings \"hello world\" \"world hello planet\"\n2",
      "ha": "Ƙirga adadin igiyoyi da suka bayyana sau ɗaya kawai a cikin dukkanin jerin.\nAikin yana ɗaukar igiyoyi biyu da ke wakiltar jerin, inda abubuwan ke rabuwa da sarari.\nYana mayar da adadin igiyoyi da suka bayyana sau ɗaya kawai a cikin dukkanin jerin.\n>>> count_unique_strings \"apple banana mango\" \"banana fruits apple\"\n2\n>>> count_unique_strings \"hello world\" \"world hello planet\"\n2",
      "hi": "दोनों ऐरे में ठीक एक बार दिखाई देने वाले स्ट्रिंग्स की संख्या गिनें।\nयह फ़ंक्शन दो स्ट्रिंग्स लेता है जो ऐरे का प्रतिनिधित्व करती हैं, जहाँ तत्व स्पेस द्वारा अलग किए गए हैं।\nउन स्ट्रिंग्स की गिनती लौटाता है जो दोनों ऐरे में ठीक एक बार दिखाई देती हैं।\n>>> count_unique_strings \"apple banana mango\" \"banana fruits apple\"\n2\n>>> count_unique_strings \"hello world\" \"world hello planet\"\n2",
      "hu": "Számolja meg azon karakterláncok számát, amelyek pontosan egyszer fordulnak elő mindkét tömbben.  \nA függvény két karakterláncot vesz fel, amelyek a tömböket képviselik, ahol az elemek szóközzel vannak elválasztva.  \nVisszaadja azon karakterláncok számát, amelyek pontosan egyszer fordulnak elő mindkét tömbben.  \n>>> count_unique_strings \"apple banana mango\" \"banana fruits apple\"  \n2  \n>>> count_unique_strings \"hello world\" \"world hello planet\"  \n2  "
    },
    "docstring_bertscore": {
      "sq": "0.9675463779338527",
      "hy": "0.9480557717948043",
      "bn": "0.9736975635737412",
      "bg": "0.9908429408039107",
      "zh": "0.9735863305603616",
      "fr": "0.9908429408039107",
      "de": "0.9896871106166686",
      "ha": "0.929561495647027",
      "hi": "0.9914874963903688",
      "hu": "0.9852014407217577"
    }
  },
  {
    "task_id": "Shell/17",
    "prompt": {
      "en": "#!/bin/bash\n\n# Count the frequency of each word in frequency.txt\n# example\n# apple banana apple\\nbanana banana apple\n# apple 3\\nbanana 3\n\ncount_word_frequency() {",
      "sq": "#!/bin/bash\n\n# Numëroni frekuencën e secilës fjalë në frequency.txt\n# shembull\n# apple banana apple\\nbanana banana apple\n# apple 3\\nbanana 3\n\ncount_word_frequency() {",
      "hy": "#!/bin/bash\n\n# Հաշվել յուրաքանչյուր բառի հաճախականությունը frequency.txt-ում\n# օրինակ\n# apple banana apple\\nbanana banana apple\n# apple 3\\nbanana 3\n\ncount_word_frequency() {",
      "bn": "#!/bin/bash\n\n# frequency.txt এ প্রতিটি শব্দের ঘনত্ব গণনা করুন\n# উদাহরণ\n# apple banana apple\\nbanana banana apple\n# apple 3\\nbanana 3\n\ncount_word_frequency() {",
      "bg": "#!/bin/bash\n\n# Пребройте честотата на всяка дума в frequency.txt\n# пример\n# apple banana apple\\nbanana banana apple\n# apple 3\\nbanana 3\n\ncount_word_frequency() {",
      "zh": "#!/bin/bash\n\n# 统计 frequency.txt 中每个单词的频率\n# 例子\n# apple banana apple\\nbanana banana apple\n# apple 3\\nbanana 3\n\ncount_word_frequency() {",
      "fr": "#!/bin/bash\n\n# Compter la fréquence de chaque mot dans frequency.txt\n# exemple\n# apple banana apple\\nbanana banana apple\n# apple 3\\nbanana 3\n\ncount_word_frequency() {",
      "de": "#!/bin/bash\n\n# Zähle die Häufigkeit jedes Wortes in frequency.txt\n# Beispiel\n# apple banana apple\\nbanana banana apple\n# apple 3\\nbanana 3\n\ncount_word_frequency() {",
      "ha": "#!/bin/bash\n\n# Lissafa yawan kowace kalma a cikin frequency.txt\n# misali\n# apple banana apple\\nbanana banana apple\n# apple 3\\nbanana 3\n\ncount_word_frequency() {",
      "hi": "#!/bin/bash\n\n# frequency.txt में प्रत्येक शब्द की आवृत्ति गिनें\n# उदाहरण\n# apple banana apple\\nbanana banana apple\n# apple 3\\nbanana 3\n\ncount_word_frequency() {",
      "hu": "#!/bin/bash\n\n# Számolja meg az egyes szavak gyakoriságát a frequency.txt fájlban\n# példa\n# apple banana apple\\nbanana banana apple\n# apple 3\\nbanana 3\n\ncount_word_frequency() {"
    },
    "prompt_bertscore": {
      "sq": "0.999999801369619",
      "hy": "0.9791094469354177",
      "bn": "0.976953115518903",
      "bg": "0.999999801369619",
      "zh": "0.9975242709307811",
      "fr": "0.999999801369619",
      "de": "0.9975242709307811",
      "ha": "0.9795750365485635",
      "hi": "0.9975242709307811",
      "hu": "0.9771376431428843"
    },
    "canonical_solution": "tr -s ' ' '\\n' < frequency.txt | grep -v '^$' | sort | uniq -c | awk '{print $2, $1}'\n}",
    "instruction": {
      "en": "Write a Shell function `count_word_frequency() {` to solve the following problem:\n\nCount the frequency of each word in frequency.txt\nexample\napple banana apple\\nbanana banana apple\napple 3\\nbanana 3\n\n",
      "sq": "Shkruani një funksion Shell `count_word_frequency() {` për të zgjidhur problemin e mëposhtëm:\n\nNumëroni frekuencën e secilës fjalë në frequency.txt\nshembull\napple banana apple\\nbanana banana apple\napple 3\\nbanana 3",
      "hy": "Գրեք Shell ֆունկցիա `count_word_frequency() {` հետևյալ խնդիրը լուծելու համար:\n\nՀաշվեք յուրաքանչյուր բառի հաճախականությունը frequency.txt ֆայլում\nօրինակ\napple banana apple\\nbanana banana apple\napple 3\\nbanana 3",
      "bn": "একটি Shell ফাংশন `count_word_frequency() {` লিখুন নিম্নলিখিত সমস্যার সমাধানের জন্য:\n\nfrequency.txt এ প্রতিটি শব্দের ফ্রিকোয়েন্সি গণনা করুন\nউদাহরণ\napple banana apple\\nbanana banana apple\napple 3\\nbanana 3",
      "bg": "Напишете Shell функция `count_word_frequency() {` за решаване на следния проблем:\n\nБройте честотата на всяка дума в frequency.txt\nпример\napple banana apple\\nbanana banana apple\napple 3\\nbanana 3",
      "zh": "编写一个 Shell 函数 `count_word_frequency() {` 来解决以下问题：\n\n统计 frequency.txt 中每个单词的频率\n例子\napple banana apple\\nbanana banana apple\napple 3\\nbanana 3",
      "fr": "Écrire une fonction Shell `count_word_frequency() {` pour résoudre le problème suivant :\n\nCompter la fréquence de chaque mot dans frequency.txt\nexemple\napple banana apple\\nbanana banana apple\napple 3\\nbanana 3",
      "de": "Schreiben Sie eine Shell-Funktion `count_word_frequency() {`, um das folgende Problem zu lösen:\n\nZählen Sie die Häufigkeit jedes Wortes in frequency.txt\nBeispiel\napple banana apple\\nbanana banana apple\napple 3\\nbanana 3",
      "ha": "Rubuta aikin Shell `count_word_frequency() {` don magance matsalar mai zuwa:\n\nƘirga yawan kowace kalma a cikin frequency.txt\nmisali\napple banana apple\\nbanana banana apple\napple 3\\nbanana 3",
      "hi": "Shell फ़ंक्शन `count_word_frequency() {` लिखें ताकि निम्नलिखित समस्या का समाधान किया जा सके:\n\nfrequency.txt में प्रत्येक शब्द की आवृत्ति गिनें\nउदाहरण\napple banana apple\\nbanana banana apple\napple 3\\nbanana 3",
      "hu": "Írj egy Shell függvényt `count_word_frequency() {` a következő probléma megoldására:\n\nSzámold meg az egyes szavak gyakoriságát a frequency.txt fájlban\npélda\napple banana apple\\nbanana banana apple\napple 3\\nbanana 3"
    },
    "instruction_bertscore": {
      "sq": "1",
      "hy": "0.972113486284988",
      "bn": "0.9940379104828568",
      "bg": "1",
      "zh": "0.9940379104828568",
      "fr": "1",
      "de": "0.9907005228207086",
      "ha": "1",
      "hi": "0.9570489609265399",
      "hu": "0.972113486284988"
    },
    "level": "easy",
    "test": "# Test function for count_word_frequency\ntest_count_word_frequency() {\n# Create a sample frequency.txt file\necho -e \"apple banana apple\\nbanana banana apple\" > frequency.txt\n\n# Expected output\nlocal expected_output=$(echo -e \"apple 3\\nbanana 3\")\n\n# Actual output from the function\nlocal actual_output=$(count_word_frequency)\n\n# Compare actual output to expected output\n[[ \"$actual_output\" == \"$expected_output\" ]] || { echo \"Test 1 failed\"; exit 1; }\n\n# Clean up\nrm frequency.txt\n}\n\n# Call the test function\ntest_count_word_frequency",
    "entry_point": "count_word_frequency",
    "signature": "count_word_frequency() {",
    "docstring": {
      "en": "\nCount the frequency of each word in frequency.txt\nexample\napple banana apple\\nbanana banana apple\napple 3\\nbanana 3\n\n",
      "sq": "Numëroni frekuencën e secilës fjalë në frequency.txt\nshembull\napple banana apple\\nbanana banana apple\napple 3\\nbanana 3",
      "hy": "Հաշվել յուրաքանչյուր բառի հաճախականությունը frequency.txt ֆայլում\nօրինակ\napple banana apple\\nbanana banana apple\napple 3\\nbanana 3",
      "bn": "Count the frequency of each word in frequency.txt\nউদাহরণ\napple banana apple\\nbanana banana apple\napple 3\\nbanana 3",
      "bg": "Бройте честотата на всяка дума в frequency.txt\nпример\napple banana apple\\nbanana banana apple\napple 3\\nbanana 3",
      "zh": "统计 frequency.txt 中每个单词的频率  \n示例  \napple banana apple\\nbanana banana apple  \napple 3\\nbanana 3  ",
      "fr": "Compter la fréquence de chaque mot dans frequency.txt  \nexemple  \napple banana apple\\nbanana banana apple  \napple 3\\nbanana 3  ",
      "de": "Zähle die Häufigkeit jedes Wortes in frequency.txt  \nBeispiel  \napple banana apple\\nbanana banana apple  \napple 3\\nbanana 3  ",
      "ha": "Ƙirga yawan kowace kalma a frequency.txt\nmisali\napple banana apple\\nbanana banana apple\napple 3\\nbanana 3",
      "hi": "प्रत्येक शब्द की आवृत्ति की गणना frequency.txt में करें  \nउदाहरण  \napple banana apple\\nbanana banana apple  \napple 3\\nbanana 3  ",
      "hu": "Számolja meg az egyes szavak gyakoriságát a frequency.txt fájlban\npélda\napple banana apple\\nbanana banana apple\napple 3\\nbanana 3"
    },
    "docstring_bertscore": {
      "sq": "1",
      "hy": "0.9165150549598934",
      "bn": "0.9927825664747163",
      "bg": "1",
      "zh": "0.9927825664747163",
      "fr": "1",
      "de": "0.9927825664747163",
      "ha": "0.9764382655712606",
      "hi": "0.9927825664747163",
      "hu": "0.9507603230629753"
    }
  },
  {
    "task_id": "Shell/18",
    "prompt": {
      "en": "#!/bin/bash\n\n# Single-line script to output all valid phone numbers from file.txt\n# example\n# 123-456-7890\\n(123) 456-7890\\n123 456 7890\\n(123)-456-7890\n# 123-456-7890\\n(123) 456-7890\nfind_valid_numbers() {",
      "sq": "#!/bin/bash\n\n# Skript me një rresht për të nxjerrë të gjitha numrat e vlefshëm të telefonit nga file.txt\n# shembull\n# 123-456-7890\\n(123) 456-7890\\n123 456 7890\\n(123)-456-7890\n# 123-456-7890\\n(123) 456-7890\nfind_valid_numbers() {",
      "hy": "#!/bin/bash\n\n# Միատող սցենար՝ file.txt-ից բոլոր վավեր հեռախոսահամարները արտածելու համար\n# օրինակ\n# 123-456-7890\\n(123) 456-7890\\n123 456 7890\\n(123)-456-7890\n# 123-456-7890\\n(123) 456-7890\nfind_valid_numbers() {",
      "bn": "#!/bin/bash\n\n# file.txt থেকে সমস্ত বৈধ ফোন নম্বর আউটপুট করার জন্য এক-লাইন স্ক্রিপ্ট\n# উদাহরণ\n# 123-456-7890\\n(123) 456-7890\\n123 456 7890\\n(123)-456-7890\n# 123-456-7890\\n(123) 456-7890\nfind_valid_numbers() {",
      "bg": "#!/bin/bash\n\n# Едноредов скрипт за извеждане на всички валидни телефонни номера от file.txt\n# пример\n# 123-456-7890\\n(123) 456-7890\\n123 456 7890\\n(123)-456-7890\n# 123-456-7890\\n(123) 456-7890\nfind_valid_numbers() {",
      "zh": "#!/bin/bash\n\n# 单行脚本从file.txt输出所有有效的电话号码\n# 示例\n# 123-456-7890\\n(123) 456-7890\\n123 456 7890\\n(123)-456-7890\n# 123-456-7890\\n(123) 456-7890\nfind_valid_numbers() {",
      "fr": "#!/bin/bash\n\n# Script en une seule ligne pour afficher tous les numéros de téléphone valides à partir de file.txt\n# exemple\n# 123-456-7890\\n(123) 456-7890\\n123 456 7890\\n(123)-456-7890\n# 123-456-7890\\n(123) 456-7890\nfind_valid_numbers() {",
      "de": "#!/bin/bash\n\n# Einzeiliges Skript, um alle gültigen Telefonnummern aus file.txt auszugeben\n# Beispiel\n# 123-456-7890\\n(123) 456-7890\\n123 456 7890\\n(123)-456-7890\n# 123-456-7890\\n(123) 456-7890\nfind_valid_numbers() {",
      "ha": "#!/bin/bash\n\n# Rubutun layi daya don fitar da duk lambobin waya masu inganci daga file.txt\n# misali\n# 123-456-7890\\n(123) 456-7890\\n123 456 7890\\n(123)-456-7890\n# 123-456-7890\\n(123) 456-7890\nfind_valid_numbers() {",
      "hi": "#!/bin/bash\n\n# file.txt से सभी वैध फोन नंबर आउटपुट करने के लिए एकल-पंक्ति स्क्रिप्ट\n# उदाहरण\n# 123-456-7890\\n(123) 456-7890\\n123 456 7890\\n(123)-456-7890\n# 123-456-7890\\n(123) 456-7890\nfind_valid_numbers() {",
      "hu": "#!/bin/bash\n\n# Egysoros szkript, amely kiírja az összes érvényes telefonszámot a file.txt fájlból\n# példa\n# 123-456-7890\\n(123) 456-7890\\n123 456 7890\\n(123)-456-7890\n# 123-456-7890\\n(123) 456-7890\nfind_valid_numbers() {"
    },
    "prompt_bertscore": {
      "sq": "0.9847348579567068",
      "hy": "0.9793491938053268",
      "bn": "0.9898170148858654",
      "bg": "0.9900464329759607",
      "zh": "0.9988713821749597",
      "fr": "0.984912632147733",
      "de": "0.9988713821749597",
      "ha": "0.9847348579567068",
      "hi": "0.9988713821749597",
      "hu": "0.9797343381141534"
    },
    "canonical_solution": "grep -P '^(\\(\\d{3}\\) \\d{3}-\\d{4}|\\d{3}-\\d{3}-\\d{4})$' file.txt\n}",
    "instruction": {
      "en": "Write a Shell function `find_valid_numbers() {` to solve the following problem:\n\nSingle-line script to output all valid phone numbers from file.txt\nexample\n123-456-7890\\n(123) 456-7890\\n123 456 7890\\n(123)-456-7890\n123-456-7890\\n(123) 456-7890\n",
      "sq": "Shkruani një funksion Shell `find_valid_numbers() {` për të zgjidhur problemin e mëposhtëm:\n\nSkript me një rresht për të nxjerrë të gjitha numrat e vlefshëm të telefonit nga file.txt\nshembull\n123-456-7890\\n(123) 456-7890\\n123 456 7890\\n(123)-456-7890\n123-456-7890\\n(123) 456-7890",
      "hy": "Գրեք Shell ֆունկցիա `find_valid_numbers() {` հետևյալ խնդիրը լուծելու համար:\n\nՄեկ տողանոց սցենար՝ file.txt-ից բոլոր վավեր հեռախոսահամարները արտածելու համար\nօրինակ\n123-456-7890\\n(123) 456-7890\\n123 456 7890\\n(123)-456-7890\n123-456-7890\\n(123) 456-7890",
      "bn": "একটি Shell ফাংশন `find_valid_numbers() {` লিখুন নিম্নলিখিত সমস্যার সমাধানের জন্য:\n\nএকক-লাইন স্ক্রিপ্ট যা file.txt থেকে সমস্ত বৈধ ফোন নম্বর আউটপুট করবে\nউদাহরণ\n123-456-7890\\n(123) 456-7890\\n123 456 7890\\n(123)-456-7890\n123-456-7890\\n(123) 456-7890",
      "bg": "Напишете Shell функция `find_valid_numbers() {`, за да решите следния проблем:\n\nЕдноредов скрипт за извеждане на всички валидни телефонни номера от file.txt\nпример\n123-456-7890\\n(123) 456-7890\\n123 456 7890\\n(123)-456-7890\n123-456-7890\\n(123) 456-7890",
      "zh": "编写一个 Shell 函数 `find_valid_numbers() {` 来解决以下问题：\n\n单行脚本从 file.txt 输出所有有效的电话号码\n例子\n123-456-7890\\n(123) 456-7890\\n123 456 7890\\n(123)-456-7890\n123-456-7890\\n(123) 456-7890",
      "fr": "Écrire une fonction Shell `find_valid_numbers() {` pour résoudre le problème suivant :\n\nScript à une seule ligne pour afficher tous les numéros de téléphone valides à partir de file.txt\nexemple\n123-456-7890\\n(123) 456-7890\\n123 456 7890\\n(123)-456-7890\n123-456-7890\\n(123) 456-7890",
      "de": "Schreiben Sie eine Shell-Funktion `find_valid_numbers() {` um das folgende Problem zu lösen:\n\nEinzeiliges Skript, um alle gültigen Telefonnummern aus file.txt auszugeben\nBeispiel\n123-456-7890\\n(123) 456-7890\\n123 456 7890\\n(123)-456-7890\n123-456-7890\\n(123) 456-7890",
      "ha": "Rubuta aikin Shell `find_valid_numbers() {` don warware matsalar mai zuwa:\n\nRubutun layi guda don fitar da duk lambobin waya masu inganci daga file.txt\nmisali\n123-456-7890\\n(123) 456-7890\\n123 456 7890\\n(123)-456-7890\n123-456-7890\\n(123) 456-7890",
      "hi": "Shell फ़ंक्शन `find_valid_numbers() {` लिखें निम्नलिखित समस्या को हल करने के लिए:\n\nफ़ाइल file.txt से सभी मान्य फोन नंबर आउटपुट करने के लिए एकल-पंक्ति स्क्रिप्ट\nउदाहरण\n123-456-7890\\n(123) 456-7890\\n123 456 7890\\n(123)-456-7890\n123-456-7890\\n(123) 456-7890",
      "hu": "Írj egy Shell függvényt `find_valid_numbers() {` a következő probléma megoldására:\n\nEgysoros szkript az összes érvényes telefonszám kiírására a file.txt fájlból\npélda\n123-456-7890\\n(123) 456-7890\\n123 456 7890\\n(123)-456-7890\n123-456-7890\\n(123) 456-7890"
    },
    "instruction_bertscore": {
      "sq": "0.9869092647378956",
      "hy": "0.9877304027330939",
      "bn": "0.9843068094855766",
      "bg": "0.9833597398288022",
      "zh": "0.9844283712787699",
      "fr": "0.9868709290743559",
      "de": "0.988738451916846",
      "ha": "0.9877304027330939",
      "hi": "0.9664578834457815",
      "hu": "0.9753050792474565"
    },
    "level": "easy",
    "test": "test_find_valid_numbers() {\n# Create a sample file.txt file\necho -e \"123-456-7890\\n(123) 456-7890\\n123 456 7890\\n(123)-456-7890\" > file.txt\n\n# Expected output\nlocal expected_output=$(echo -e \"123-456-7890\\n(123) 456-7890\")\n\n# Actual output from the function\nlocal actual_output=$(find_valid_numbers)\n\n# Compare actual output to expected output\n[[ \"$actual_output\" == \"$expected_output\" ]] || { echo \"Test 1 failed\"; exit 1; }\n\n# Clean up\nrm file.txt\n}\n\n# Call the test function\ntest_find_valid_numbers",
    "entry_point": "find_valid_numbers",
    "signature": "find_valid_numbers() {",
    "docstring": {
      "en": "\nSingle-line script to output all valid phone numbers from file.txt\nexample\n123-456-7890\\n(123) 456-7890\\n123 456 7890\\n(123)-456-7890\n123-456-7890\\n(123) 456-7890\n",
      "sq": "Skript me një rresht për të nxjerrë të gjitha numrat e vlefshëm të telefonit nga file.txt\nshembull\n123-456-7890\\n(123) 456-7890\\n123 456 7890\\n(123)-456-7890\n123-456-7890\\n(123) 456-7890",
      "hy": "Մեկ տողի սցենար՝ file.txt-ից բոլոր վավեր հեռախոսահամարները արտածելու համար\nօրինակ\n123-456-7890\\n(123) 456-7890\\n123 456 7890\\n(123)-456-7890\n123-456-7890\\n(123) 456-7890",
      "bn": "ফাইল.txt থেকে সমস্ত বৈধ ফোন নম্বর আউটপুট করার জন্য একক-লাইন স্ক্রিপ্ট\n\nউদাহরণ\n\n123-456-7890\\n(123) 456-7890\\n123 456 7890\\n(123)-456-7890\n\n123-456-7890\\n(123) 456-7890",
      "bg": "Едноредов скрипт за извеждане на всички валидни телефонни номера от file.txt\nпример\n123-456-7890\\n(123) 456-7890\\n123 456 7890\\n(123)-456-7890\n123-456-7890\\n(123) 456-7890",
      "zh": "单行脚本从 file.txt 输出所有有效的电话号码  \n示例  \n123-456-7890\\n(123) 456-7890\\n123 456 7890\\n(123)-456-7890  \n123-456-7890\\n(123) 456-7890  ",
      "fr": "Script en une seule ligne pour afficher tous les numéros de téléphone valides à partir de file.txt\nexemple\n123-456-7890\\n(123) 456-7890\\n123 456 7890\\n(123)-456-7890\n123-456-7890\\n(123) 456-7890",
      "de": "Einzeiliges Skript, um alle gültigen Telefonnummern aus file.txt auszugeben\nBeispiel\n123-456-7890\\n(123) 456-7890\\n123 456 7890\\n(123)-456-7890\n123-456-7890\\n(123) 456-7890",
      "ha": "Single-line script don fitar da duk lambobin waya masu inganci daga file.txt\nmisali\n123-456-7890\\n(123) 456-7890\\n123 456 7890\\n(123)-456-7890\n123-456-7890\\n(123) 456-7890",
      "hi": "फ़ाइल file.txt से सभी मान्य फोन नंबरों को आउटपुट करने के लिए एकल-पंक्ति स्क्रिप्ट  \nउदाहरण  \n123-456-7890\\n(123) 456-7890\\n123 456 7890\\n(123)-456-7890  \n123-456-7890\\n(123) 456-7890  ",
      "hu": "Egysoros szkript az összes érvényes telefonszám kiíratására a file.txt fájlból\npélda\n123-456-7890\\n(123) 456-7890\\n123 456 7890\\n(123)-456-7890\n123-456-7890\\n(123) 456-7890"
    },
    "docstring_bertscore": {
      "sq": "0.9659859376604426",
      "hy": "0.9755380726844104",
      "bn": "0.9700364083905061",
      "bg": "0.9917111541994141",
      "zh": "0.9881451429686948",
      "fr": "0.9568815155153275",
      "de": "0.9973999283122533",
      "ha": "0.9917111541994141",
      "hi": "0.9694460788980704",
      "hu": "0.9610094520939946"
    }
  },
  {
    "task_id": "Shell/19",
    "prompt": {
      "en": "#!/bin/bash\n\n# Transpose the content of file.txt\n# example\n# input:1 2 3\\n4 5 6\\n7 8 9\n# output:1 4 7\\n2 5 8\\n3 6 9\ntranspose_file() {",
      "sq": "#!/bin/bash\n\n# Transpozoni përmbajtjen e file.txt\n# shembull\n# hyrja:1 2 3\\n4 5 6\\n7 8 9\n# dalja:1 4 7\\n2 5 8\\n3 6 9\ntranspose_file() {",
      "hy": "#!/bin/bash\n\n# Տեղափոխել file.txt ֆայլի պարունակությունը\n# օրինակ\n# մուտք:1 2 3\\n4 5 6\\n7 8 9\n# ելք:1 4 7\\n2 5 8\\n3 6 9\ntranspose_file() {",
      "bn": "#!/bin/bash\n\n# file.txt এর বিষয়বস্তু স্থানান্তর করুন\n# উদাহরণ\n# ইনপুট:1 2 3\\n4 5 6\\n7 8 9\n# আউটপুট:1 4 7\\n2 5 8\\n3 6 9\ntranspose_file() {",
      "bg": "#!/bin/bash\n\n# Транспониране на съдържанието на file.txt\n# пример\n# вход:1 2 3\\n4 5 6\\n7 8 9\n# изход:1 4 7\\n2 5 8\\n3 6 9\ntranspose_file() {",
      "zh": "#!/bin/bash\n\n# 转置 file.txt 的内容\n# 例子\n# 输入:1 2 3\\n4 5 6\\n7 8 9\n# 输出:1 4 7\\n2 5 8\\n3 6 9\ntranspose_file() {",
      "fr": "#!/bin/bash\n\n# Transposer le contenu de file.txt\n# exemple\n# entrée:1 2 3\\n4 5 6\\n7 8 9\n# sortie:1 4 7\\n2 5 8\\n3 6 9\ntranspose_file() {",
      "de": "#!/bin/bash\n\n# Den Inhalt von file.txt transponieren\n# Beispiel\n# Eingabe:1 2 3\\n4 5 6\\n7 8 9\n# Ausgabe:1 4 7\\n2 5 8\\n3 6 9\ntranspose_file() {",
      "ha": "#!/bin/bash\n\n# Juya abun ciki na file.txt\n# misali\n# shigarwa:1 2 3\\n4 5 6\\n7 8 9\n# fitarwa:1 4 7\\n2 5 8\\n3 6 9\ntranspose_file() {",
      "hi": "#!/bin/bash\n\n# file.txt की सामग्री को ट्रांसपोज़ करें\n# उदाहरण\n# इनपुट:1 2 3\\n4 5 6\\n7 8 9\n# आउटपुट:1 4 7\\n2 5 8\\n3 6 9\ntranspose_file() {",
      "hu": "#!/bin/bash\n\n# A file.txt tartalmának transzponálása\n# példa\n# bemenet:1 2 3\\n4 5 6\\n7 8 9\n# kimenet:1 4 7\\n2 5 8\\n3 6 9\ntranspose_file() {"
    },
    "prompt_bertscore": {
      "sq": "0.9964963587089256",
      "hy": "0.982755108948932",
      "bn": "0.977784979554677",
      "bg": "0.9942548148589468",
      "zh": "0.9911967015125338",
      "fr": "0.9964963587089256",
      "de": "0.994687829089603",
      "ha": "0.9964963587089256",
      "hi": "0.9911967015125338",
      "hu": "0.9967541809435089"
    },
    "canonical_solution": "awk '\n{\nfor (i = 1; i <= NF; i++) {\nif(NR == 1) {\ntransposed[i] = $i;\n} else {\ntransposed[i] = transposed[i] \" \" $i;\n}\n}\n}\nEND {\nfor (i = 1; i <= NF; i++) {\nprint transposed[i];\n}\n}' file.txt\n}",
    "instruction": {
      "en": "Write a Shell function `transpose_file() {` to solve the following problem:\n\nTranspose the content of file.txt\nexample\ninput:1 2 3\\n4 5 6\\n7 8 9\noutput:1 4 7\\n2 5 8\\n3 6 9\n",
      "sq": "Shkruani një funksion Shell `transpose_file() {` për të zgjidhur problemin e mëposhtëm:\n\nTranspozoni përmbajtjen e file.txt\nshembull\nhyrja:1 2 3\\n4 5 6\\n7 8 9\ndalja:1 4 7\\n2 5 8\\n3 6 9",
      "hy": "Գրեք Shell ֆունկցիա `transpose_file() {` հետևյալ խնդիրը լուծելու համար:\n\nՓոխարկել file.txt ֆայլի պարունակությունը\nօրինակ\nմուտք:1 2 3\\n4 5 6\\n7 8 9\nելք:1 4 7\\n2 5 8\\n3 6 9",
      "bn": "একটি Shell ফাংশন `transpose_file() {` লিখুন নিম্নলিখিত সমস্যার সমাধানের জন্য:\n\nfile.txt এর বিষয়বস্তু ট্রান্সপোজ করুন\nউদাহরণ\nইনপুট:1 2 3\\n4 5 6\\n7 8 9\nআউটপুট:1 4 7\\n2 5 8\\n3 6 9",
      "bg": "Напишете Shell функция `transpose_file() {` за решаване на следния проблем:\n\nТранспонирайте съдържанието на file.txt\nпример\nвход:1 2 3\\n4 5 6\\n7 8 9\nизход:1 4 7\\n2 5 8\\n3 6 9",
      "zh": "编写一个 Shell 函数 `transpose_file() {` 来解决以下问题：\n\n转置 file.txt 的内容\n示例\n输入:1 2 3\\n4 5 6\\n7 8 9\n输出:1 4 7\\n2 5 8\\n3 6 9",
      "fr": "Écrire une fonction Shell `transpose_file() {` pour résoudre le problème suivant :\n\nTransposer le contenu de file.txt\nexemple\nentrée:1 2 3\\n4 5 6\\n7 8 9\nsortie:1 4 7\\n2 5 8\\n3 6 9",
      "de": "Schreiben Sie eine Shell-Funktion `transpose_file() {`, um das folgende Problem zu lösen:\n\nTransponieren Sie den Inhalt von file.txt\nBeispiel\nEingabe:1 2 3\\n4 5 6\\n7 8 9\nAusgabe:1 4 7\\n2 5 8\\n3 6 9",
      "ha": "Rubuta wani aikin Shell `transpose_file() {` don warware matsalar mai zuwa:\n\nJuya abun cikin file.txt\nmisali\nshigarwa:1 2 3\\n4 5 6\\n7 8 9\nfitarwa:1 4 7\\n2 5 8\\n3 6 9",
      "hi": "एक Shell फ़ंक्शन `transpose_file() {` लिखें ताकि निम्नलिखित समस्या का समाधान किया जा सके:\n\nfile.txt की सामग्री को ट्रांसपोज़ करें\nउदाहरण\nइनपुट:1 2 3\\n4 5 6\\n7 8 9\nआउटपुट:1 4 7\\n2 5 8\\n3 6 9",
      "hu": "Írj egy Shell függvényt `transpose_file() {` a következő probléma megoldására:\n\nTranszponáld a file.txt tartalmát\npélda\nbemenet:1 2 3\\n4 5 6\\n7 8 9\nkimenet:1 4 7\\n2 5 8\\n3 6 9"
    },
    "instruction_bertscore": {
      "sq": "0.9972406267466634",
      "hy": "0.9797585710206397",
      "bn": "0.9837933499506014",
      "bg": "1",
      "zh": "0.97010433998082",
      "fr": "1",
      "de": "0.982065464265979",
      "ha": "0.9972406267466634",
      "hi": "0.9837933499506014",
      "hu": "0.9972406267466634"
    },
    "level": "easy",
    "test": "# Test function for transpose_file\ntest_transpose_file() {\n# Create a sample file.txt file\necho -e \"1 2 3\\n4 5 6\\n7 8 9\" > file.txt\n\n# Expected output\nlocal expected_output=$(echo -e \"1 4 7\\n2 5 8\\n3 6 9\")\n\n# Actual output from the function\nlocal actual_output=$(transpose_file)\n\n# Compare actual output to expected output\n[[ \"$actual_output\" == \"$expected_output\" ]] || { echo \"Test 1 failed\"; exit 1; }\n\n# Clean up\nrm file.txt\n}\n\n# Call the test function\ntest_transpose_file",
    "entry_point": "transpose_file",
    "signature": "transpose_file() {",
    "docstring": {
      "en": "\nTranspose the content of file.txt\nexample\ninput:1 2 3\\n4 5 6\\n7 8 9\noutput:1 4 7\\n2 5 8\\n3 6 9\n",
      "sq": "Transpozoni përmbajtjen e file.txt\nshembull\nhyrje:1 2 3\\n4 5 6\\n7 8 9\ndalje:1 4 7\\n2 5 8\\n3 6 9",
      "hy": "Փոխարկել file.txt-ի պարունակությունը  \nօրինակ  \nմուտքագրում:1 2 3\\n4 5 6\\n7 8 9  \nելք:1 4 7\\n2 5 8\\n3 6 9  ",
      "bn": "ফাইল.txt এর বিষয়বস্তু স্থানান্তর করুন\nউদাহরণ\nইনপুট:1 2 3\\n4 5 6\\n7 8 9\nআউটপুট:1 4 7\\n2 5 8\\n3 6 9",
      "bg": "Транспонирайте съдържанието на file.txt\nпример\nвход:1 2 3\\n4 5 6\\n7 8 9\nизход:1 4 7\\n2 5 8\\n3 6 9",
      "zh": "将文件 file.txt 的内容转置  \n示例  \n输入:1 2 3\\n4 5 6\\n7 8 9  \n输出:1 4 7\\n2 5 8\\n3 6 9  ",
      "fr": "Transposez le contenu de file.txt  \nexemple  \nentrée:1 2 3\\n4 5 6\\n7 8 9  \nsortie:1 4 7\\n2 5 8\\n3 6 9  ",
      "de": "Transponieren Sie den Inhalt von file.txt  \nBeispiel  \nEingabe:1 2 3\\n4 5 6\\n7 8 9  \nAusgabe:1 4 7\\n2 5 8\\n3 6 9  ",
      "ha": "Transpose abun cikin file.txt  \nmisali  \nshigarwa: 1 2 3\\n4 5 6\\n7 8 9  \nfitarwa: 1 4 7\\n2 5 8\\n3 6 9  ",
      "hi": "file.txt की सामग्री को ट्रांसपोज करें  \nउदाहरण  \nइनपुट:1 2 3\\n4 5 6\\n7 8 9  \nआउटपुट:1 4 7\\n2 5 8\\n3 6 9  ",
      "hu": "Transzponálja a file.txt tartalmát\npélda\nbemenet:1 2 3\\n4 5 6\\n7 8 9\nkimenet:1 4 7\\n2 5 8\\n3 6 9"
    },
    "docstring_bertscore": {
      "sq": "0.9933661425341967",
      "hy": "0.9769723826658634",
      "bn": "0.9611711372241569",
      "bg": "0.9933661425341967",
      "zh": "0.9676935630461996",
      "fr": "1",
      "de": "0.984611508490084",
      "ha": "0.9744835439914962",
      "hi": "0.9623964880447612",
      "hu": "1"
    }
  },
  {
    "task_id": "Shell/20",
    "prompt": {
      "en": "#!/bin/bash\n\n# Extract the tenth line from file.txt\n# example\n# input: for i in {1..20}; do echo \"Line $i\"; done > file.txt\n# output:Line 10\nextract_tenth_line() {",
      "sq": "#!/bin/bash\n\n# Nxjerr rreshtin e dhjetë nga file.txt\n# shembull\n# hyrje: për i në {1..20}; bëj echo \"Line $i\"; bërë > file.txt\n# dalje: Line 10\nextract_tenth_line() {",
      "hy": "#!/bin/bash\n\n# Հանել տասներորդ տողը file.txt-ից\n# օրինակ\n# մուտք: for i in {1..20}; do echo \"Line $i\"; done > file.txt\n# ելք:Line 10\nextract_tenth_line() {",
      "bn": "#!/bin/bash\n\n# file.txt থেকে দশম লাইনটি বের করুন\n# উদাহরণ\n# ইনপুট: for i in {1..20}; do echo \"Line $i\"; done > file.txt\n# আউটপুট:Line 10\nextract_tenth_line() {",
      "bg": "#!/bin/bash\n\n# Извлечете десетия ред от file.txt\n# пример\n# вход: for i in {1..20}; do echo \"Line $i\"; done > file.txt\n# изход:Line 10\nextract_tenth_line() {",
      "zh": "#!/bin/bash\n\n# 从 file.txt 中提取第十行\n# 例子\n# 输入: for i in {1..20}; do echo \"Line $i\"; done > file.txt\n# 输出:Line 10\nextract_tenth_line() {",
      "fr": "#!/bin/bash\n\n# Extraire la dixième ligne de file.txt\n# exemple\n# entrée : for i in {1..20}; do echo \"Line $i\"; done > file.txt\n# sortie : Line 10\nextract_tenth_line() {",
      "de": "#!/bin/bash\n\n# Extrahiere die zehnte Zeile aus file.txt\n# Beispiel\n# Eingabe: for i in {1..20}; do echo \"Line $i\"; done > file.txt\n# Ausgabe:Line 10\nextract_tenth_line() {",
      "ha": "#!/bin/bash\n\n# Fitar da layi na goma daga file.txt\n# misali\n# shigarwa: for i in {1..20}; do echo \"Line $i\"; done > file.txt\n# fitarwa:Line 10\nextract_tenth_line() {",
      "hi": "#!/bin/bash\n\n# file.txt से दसवीं पंक्ति निकालें\n# उदाहरण\n# इनपुट: for i in {1..20}; do echo \"Line $i\"; done > file.txt\n# आउटपुट:Line 10\nextract_tenth_line() {",
      "hu": "#!/bin/bash\n\n# A tizedik sor kinyerése a file.txt fájlból\n# példa\n# bemenet: for i in {1..20}; do echo \"Line $i\"; done > file.txt\n# kimenet:Line 10\nextract_tenth_line() {"
    },
    "prompt_bertscore": {
      "sq": "0.9868441139729163",
      "hy": "0.9899640013678312",
      "bn": "0.9935600057860868",
      "bg": "1",
      "zh": "0.9865112094543018",
      "fr": "0.9939600473734911",
      "de": "0.9865112094543018",
      "ha": "0.9817941351654853",
      "hi": "0.9865112094543018",
      "hu": "0.9806722707734002"
    },
    "canonical_solution": "sed -n '10p' file.txt\n}",
    "instruction": {
      "en": "Write a Shell function `extract_tenth_line() {` to solve the following problem:\n\nExtract the tenth line from file.txt\nexample\ninput: for i in {1..20}; do echo \"Line $i\"; done > file.txt\noutput:Line 10\n",
      "sq": "Shkruani një funksion Shell `extract_tenth_line() {` për të zgjidhur problemin e mëposhtëm:\n\nEkstraktoni linjën e dhjetë nga file.txt\nshembull\nhyrja: për i në {1..20}; bëni echo \"Line $i\"; bërë > file.txt\ndalja:Line 10",
      "hy": "Գրեք Shell ֆունկցիա `extract_tenth_line() {` հետևյալ խնդիրը լուծելու համար:\n\nՀանել տասներորդ տողը file.txt ֆայլից\nօրինակ\nմուտք: for i in {1..20}; do echo \"Line $i\"; done > file.txt\nելք:Line 10",
      "bn": "একটি Shell ফাংশন `extract_tenth_line() {` লিখুন নিম্নলিখিত সমস্যার সমাধানের জন্য:\n\nfile.txt থেকে দশম লাইনটি বের করুন\nউদাহরণ\nইনপুট: for i in {1..20}; do echo \"Line $i\"; done > file.txt\nআউটপুট:Line 10",
      "bg": "Напишете Shell функция `extract_tenth_line() {` за решаване на следния проблем:\n\nИзвлечете десетия ред от file.txt\nпример\nвход: for i in {1..20}; do echo \"Line $i\"; done > file.txt\nизход:Line 10",
      "zh": "编写一个 Shell 函数 `extract_tenth_line() {` 来解决以下问题：\n\n从 file.txt 中提取第十行\n示例\n输入: for i in {1..20}; do echo \"Line $i\"; done > file.txt\n输出:Line 10",
      "fr": "Écrire une fonction Shell `extract_tenth_line() {` pour résoudre le problème suivant :\n\nExtraire la dixième ligne de file.txt\nexemple\nentrée : for i in {1..20}; do echo \"Line $i\"; done > file.txt\nsortie :Line 10",
      "de": "Schreiben Sie eine Shell-Funktion `extract_tenth_line() {`, um das folgende Problem zu lösen:\n\nExtrahieren Sie die zehnte Zeile aus file.txt\nBeispiel\nEingabe: for i in {1..20}; do echo \"Line $i\"; done > file.txt\nAusgabe:Line 10",
      "ha": "Rubuta wani aikin Shell `extract_tenth_line() {` don warware matsalar mai zuwa:\n\nFitar da layi na goma daga file.txt\nmisali\nshigarwa: for i in {1..20}; do echo \"Line $i\"; done > file.txt\nfitarwa:Line 10",
      "hi": "Shell फ़ंक्शन `extract_tenth_line() {` लिखें ताकि निम्नलिखित समस्या का समाधान हो सके:\n\nfile.txt से दसवीं पंक्ति निकालें\nउदाहरण\nइनपुट: for i in {1..20}; do echo \"Line $i\"; done > file.txt\nआउटपुट:Line 10",
      "hu": "Írj egy Shell függvényt `extract_tenth_line() {` a következő probléma megoldására:\n\nA tizedik sor kinyerése a file.txt fájlból\npélda\nbemenet: for i in {1..20}; do echo \"Line $i\"; done > file.txt\nkimenet:Line 10"
    },
    "instruction_bertscore": {
      "sq": "0.995621789141229",
      "hy": "0.9861550651811062",
      "bn": "0.9815520047310037",
      "bg": "1",
      "zh": "0.9815520047310037",
      "fr": "0.995621789141229",
      "de": "0.9734506660101148",
      "ha": "0.995621789141229",
      "hi": "0.9490366086163546",
      "hu": "0.9907785845604553"
    },
    "level": "easy",
    "test": "test_extract_tenth_line() {\n# Create a sample file.txt file\nfor i in {1..20}; do echo \"Line $i\"; done > file.txt\n\n# Expected output\nlocal expected_output=\"Line 10\"\n\n# Actual output from the function\nlocal actual_output=$(extract_tenth_line)\n\n# Compare actual output to expected output\n[[ \"$actual_output\" == \"$expected_output\" ]] || { echo \"Test 1 failed\"; exit 1; }\n\n# Clean up\nrm file.txt\n}\n\n# Call the test function\ntest_extract_tenth_line",
    "entry_point": "extract_tenth_line",
    "signature": "extract_tenth_line() {",
    "docstring": {
      "en": "\nExtract the tenth line from file.txt\nexample\ninput: for i in {1..20}; do echo \"Line $i\"; done > file.txt\noutput:Line 10\n",
      "sq": "Nxirrni rreshtin e dhjetë nga file.txt\nshembull\nhyrje: për i në {1..20}; bëj echo \"Rreshti $i\"; bërë > file.txt\ndalje:Rreshti 10",
      "hy": "Տող 10-ը հանեք file.txt-ից\nօրինակ\nմուտք: for i in {1..20}; do echo \"Line $i\"; done > file.txt\nելք:Line 10",
      "bn": "ফাইল.txt থেকে দশম লাইনটি বের করুন\nউদাহরণ\nইনপুট: for i in {1..20}; do echo \"Line $i\"; done > file.txt\nআউটপুট:Line 10",
      "bg": "Извлечете десетия ред от file.txt  \nпример  \nвход: for i in {1..20}; do echo \"Line $i\"; done > file.txt  \nизход:Line 10  ",
      "zh": "从 file.txt 中提取第十行  \n示例  \n输入: for i in {1..20}; do echo \"Line $i\"; done > file.txt  \n输出:Line 10  ",
      "fr": "Extraire la dixième ligne de file.txt  \nexemple  \nentrée : for i in {1..20}; do echo \"Line $i\"; done > file.txt  \nsortie : Line 10  ",
      "de": "Extrahiere die zehnte Zeile aus file.txt  \nBeispiel  \nEingabe: for i in {1..20}; do echo \"Line $i\"; done > file.txt  \nAusgabe:Line 10  ",
      "ha": "Cire layi na goma daga file.txt\nmisali\nshigarwa: for i in {1..20}; do echo \"Line $i\"; done > file.txt\nfitarwa:Line 10",
      "hi": "दसवीं पंक्ति को file.txt से निकालें  \nउदाहरण  \nइनपुट: for i in {1..20}; do echo \"Line $i\"; done > file.txt  \nआउटपुट:Line 10  ",
      "hu": "A tizedik sor kinyerése a file.txt fájlból\npélda\nbemenet: for i in {1..20}; do echo \"Line $i\"; done > file.txt\nkimenet:Line 10"
    },
    "docstring_bertscore": {
      "sq": "0.9944214657486352",
      "hy": "0.9458954677706689",
      "bn": "0.9786257819575978",
      "bg": "1",
      "zh": "0.9786257819575978",
      "fr": "0.9944214657486352",
      "de": "0.9842831724702334",
      "ha": "0.9806585652771088",
      "hi": "0.9786257819575978",
      "hu": "0.9644582713999034"
    }
  },
  {
    "task_id": "Shell/21",
    "prompt": {
      "en": "#!/bin/bash\nfind_substring_index() {\nlocal haystack=\"$1\"\nlocal needle=\"$2\"\n\n# This function finds the first occurrence of the substring 'needle' in the string 'haystack'.\n# It returns the index of the first character of the first occurrence of 'needle'.\n# If 'needle' is not a part of 'haystack', it returns -1.\n# Example Usage:\n# >>> find_substring_index \"hello\" \"ll\"\n# 2\n# >>> find_substring_index \"abcd\" \"e\"\n# -1\n# >>> find_substring_index \"openai\" \"ai\"\n# 4",
      "sq": "#!/bin/bash\nfind_substring_index() {\nlocal haystack=\"$1\"\nlocal needle=\"$2\"\n\n# Kjo funksion gjen paraqitjen e parë të nënvargut 'needle' në vargun 'haystack'.\n# Kthen indeksin e karakterit të parë të paraqitjes së parë të 'needle'.\n# Nëse 'needle' nuk është pjesë e 'haystack', kthen -1.\n# Shembull i Përdorimit:\n# >>> find_substring_index \"hello\" \"ll\"\n# 2\n# >>> find_substring_index \"abcd\" \"e\"\n# -1\n# >>> find_substring_index \"openai\" \"ai\"\n# 4",
      "hy": "#!/bin/bash\nfind_substring_index() {\nlocal haystack=\"$1\"\nlocal needle=\"$2\"\n\n# Այս ֆունկցիան գտնում է 'needle' ենթատողի առաջին հանդիպումը 'haystack' տողի մեջ:\n# Այն վերադարձնում է 'needle'-ի առաջին հանդիպման առաջին սիմվոլի ինդեքսը:\n# Եթե 'needle'-ը 'haystack'-ի մաս չէ, այն վերադարձնում է -1:\n# Օգտագործման օրինակ:\n# >>> find_substring_index \"hello\" \"ll\"\n# 2\n# >>> find_substring_index \"abcd\" \"e\"\n# -1\n# >>> find_substring_index \"openai\" \"ai\"\n# 4",
      "bn": "#!/bin/bash\nfind_substring_index() {\nlocal haystack=\"$1\"\nlocal needle=\"$2\"\n\n# এই ফাংশনটি 'haystack' স্ট্রিংয়ে 'needle' সাবস্ট্রিংয়ের প্রথম উপস্থিতি খুঁজে পায়।\n# এটি 'needle'-এর প্রথম উপস্থিতির প্রথম অক্ষরের সূচক ফেরত দেয়।\n# যদি 'needle' 'haystack'-এর অংশ না হয়, এটি -1 ফেরত দেয়।\n# উদাহরণ ব্যবহার:\n# >>> find_substring_index \"hello\" \"ll\"\n# 2\n# >>> find_substring_index \"abcd\" \"e\"\n# -1\n# >>> find_substring_index \"openai\" \"ai\"\n# 4",
      "bg": "#!/bin/bash\nfind_substring_index() {\nlocal haystack=\"$1\"\nlocal needle=\"$2\"\n\n# Тази функция намира първото появяване на подниз 'needle' в низа 'haystack'.\n# Връща индекса на първия символ от първото появяване на 'needle'.\n# Ако 'needle' не е част от 'haystack', връща -1.\n# Пример за използване:\n# >>> find_substring_index \"hello\" \"ll\"\n# 2\n# >>> find_substring_index \"abcd\" \"e\"\n# -1\n# >>> find_substring_index \"openai\" \"ai\"\n# 4",
      "zh": "#!/bin/bash\nfind_substring_index() {\nlocal haystack=\"$1\"\nlocal needle=\"$2\"\n\n# 此函数查找子字符串 'needle' 在字符串 'haystack' 中的第一次出现。\n# 它返回 'needle' 第一次出现的第一个字符的索引。\n# 如果 'needle' 不是 'haystack' 的一部分，则返回 -1。\n# 示例用法：\n# >>> find_substring_index \"hello\" \"ll\"\n# 2\n# >>> find_substring_index \"abcd\" \"e\"\n# -1\n# >>> find_substring_index \"openai\" \"ai\"\n# 4",
      "fr": "#!/bin/bash\nfind_substring_index() {\nlocal haystack=\"$1\"\nlocal needle=\"$2\"\n\n# Cette fonction trouve la première occurrence de la sous-chaîne 'needle' dans la chaîne 'haystack'.\n# Elle renvoie l'index du premier caractère de la première occurrence de 'needle'.\n# Si 'needle' ne fait pas partie de 'haystack', elle renvoie -1.\n# Exemple d'utilisation :\n# >>> find_substring_index \"hello\" \"ll\"\n# 2\n# >>> find_substring_index \"abcd\" \"e\"\n# -1\n# >>> find_substring_index \"openai\" \"ai\"\n# 4",
      "de": "#!/bin/bash\nfind_substring_index() {\nlocal haystack=\"$1\"\nlocal needle=\"$2\"\n\n# Diese Funktion findet das erste Vorkommen des Teilstrings 'needle' im String 'haystack'.\n# Sie gibt den Index des ersten Zeichens des ersten Vorkommens von 'needle' zurück.\n# Wenn 'needle' kein Teil von 'haystack' ist, gibt sie -1 zurück.\n# Beispielverwendung:\n# >>> find_substring_index \"hello\" \"ll\"\n# 2\n# >>> find_substring_index \"abcd\" \"e\"\n# -1\n# >>> find_substring_index \"openai\" \"ai\"\n# 4",
      "ha": "#!/bin/bash\nfind_substring_index() {\nlocal haystack=\"$1\"\nlocal needle=\"$2\"\n\n# Wannan aikin yana nemo bayyanar farko na ƙaramin kirtani 'needle' a cikin kirtani 'haystack'.\n# Yana mayar da maƙasudin harafin farko na bayyanar farko na 'needle'.\n# Idan 'needle' ba ya cikin 'haystack', yana mayar da -1.\n# Misalin Amfani:\n# >>> find_substring_index \"hello\" \"ll\"\n# 2\n# >>> find_substring_index \"abcd\" \"e\"\n# -1\n# >>> find_substring_index \"openai\" \"ai\"\n# 4",
      "hi": "#!/bin/bash\nfind_substring_index() {\nlocal haystack=\"$1\"\nlocal needle=\"$2\"\n\n# यह फ़ंक्शन स्ट्रिंग 'haystack' में सबस्ट्रिंग 'needle' की पहली उपस्थिति को खोजता है।\n# यह 'needle' की पहली उपस्थिति के पहले वर्ण का इंडेक्स लौटाता है।\n# यदि 'needle', 'haystack' का हिस्सा नहीं है, तो यह -1 लौटाता है।\n# उदाहरण उपयोग:\n# >>> find_substring_index \"hello\" \"ll\"\n# 2\n# >>> find_substring_index \"abcd\" \"e\"\n# -1\n# >>> find_substring_index \"openai\" \"ai\"\n# 4",
      "hu": "#!/bin/bash\nfind_substring_index() {\nlocal haystack=\"$1\"\nlocal needle=\"$2\"\n\n# Ez a függvény megkeresi a 'needle' részsztring első előfordulását a 'haystack' sztringben.\n# Visszaadja a 'needle' első előfordulásának első karakterének indexét.\n# Ha a 'needle' nem része a 'haystack'-nek, akkor -1-et ad vissza.\n# Példa használat:\n# >>> find_substring_index \"hello\" \"ll\"\n# 2\n# >>> find_substring_index \"abcd\" \"e\"\n# -1\n# >>> find_substring_index \"openai\" \"ai\"\n# 4"
    },
    "prompt_bertscore": {
      "sq": "0.9852928106970338",
      "hy": "0.979680509280893",
      "bn": "0.9875293887874866",
      "bg": "0.9862170378599892",
      "zh": "0.9982572170367999",
      "fr": "0.9962550227959682",
      "de": "0.9982572170367999",
      "ha": "0.9924063605330362",
      "hi": "0.9931516217226791",
      "hu": "0.9664288834101504"
    },
    "canonical_solution": "# This function finds the first occurrence of the substring 'needle' in the string 'haystack'.\n# It returns the index of the first character of the first occurrence of 'needle'.\n# If 'needle' is not a part of 'haystack', it returns -1.\n# Example Usage:\n# >>> find_substring_index \"hello\" \"ll\"\n# 2\n# >>> find_substring_index \"abcd\" \"e\"\n# -1\n# >>> find_substring_index \"openai\" \"ai\"\n# 4\n\nif [ -z \"$needle\" ]; then\necho 0\nreturn 0\nfi\n\nlocal length=${#haystack}\nlocal needle_length=${#needle}\n\nfor (( i=0; i<=$length-needle_length; i++ )); do\nif [ \"${haystack:$i:$needle_length}\" == \"$needle\" ]; then\necho $i\nreturn 0\nfi\ndone\n\necho -1\n}",
    "instruction": {
      "en": "Write a Shell function `find_substring_index() {\nlocal haystack=\"$1\"\nlocal needle=\"$2\"\n\n` to solve the following problem:\nThis function finds the first occurrence of the substring 'needle' in the string 'haystack'.\nIt returns the index of the first character of the first occurrence of 'needle'.\nIf 'needle' is not a part of 'haystack', it returns -1.\nExample Usage:\n>>> find_substring_index \"hello\" \"ll\"\n2\n>>> find_substring_index \"abcd\" \"e\"\n-1\n>>> find_substring_index \"openai\" \"ai\"\n4",
      "sq": "Shkruani një funksion Shell `find_substring_index() {\nlocal haystack=\"$1\"\nlocal needle=\"$2\"\n\n` për të zgjidhur problemin e mëposhtëm:\nKy funksion gjen paraqitjen e parë të nënvargut 'needle' në vargun 'haystack'.\nKthen indeksin e karakterit të parë të paraqitjes së parë të 'needle'.\nNëse 'needle' nuk është pjesë e 'haystack', kthen -1.\nShembull Përdorimi:\n>>> find_substring_index \"hello\" \"ll\"\n2\n>>> find_substring_index \"abcd\" \"e\"\n-1\n>>> find_substring_index \"openai\" \"ai\"\n4",
      "hy": "Գրեք Shell ֆունկցիա `find_substring_index() {\nlocal haystack=\"$1\"\nlocal needle=\"$2\"\n\n` հետևյալ խնդիրը լուծելու համար:\nԱյս ֆունկցիան գտնում է 'needle' ենթատողի առաջին հանդիպումը 'haystack' տողի մեջ:\nԱյն վերադարձնում է 'needle'-ի առաջին հանդիպման առաջին սիմվոլի ինդեքսը:\nԵթե 'needle'-ը մաս չէ 'haystack'-ի, այն վերադարձնում է -1:\nՕրինակ օգտագործում:\n>>> find_substring_index \"hello\" \"ll\"\n2\n>>> find_substring_index \"abcd\" \"e\"\n-1\n>>> find_substring_index \"openai\" \"ai\"\n4",
      "bn": "একটি Shell ফাংশন লিখুন `find_substring_index() {\nlocal haystack=\"$1\"\nlocal needle=\"$2\"\n\n` নিম্নলিখিত সমস্যার সমাধানের জন্য:\nএই ফাংশনটি স্ট্রিং 'haystack' এর মধ্যে 'needle' সাবস্ট্রিংয়ের প্রথম উপস্থিতি খুঁজে বের করে।\nএটি 'needle' এর প্রথম উপস্থিতির প্রথম অক্ষরের সূচক ফেরত দেয়।\nযদি 'needle' 'haystack' এর অংশ না হয়, এটি -1 ফেরত দেয়।\nউদাহরণ ব্যবহার:\n>>> find_substring_index \"hello\" \"ll\"\n2\n>>> find_substring_index \"abcd\" \"e\"\n-1\n>>> find_substring_index \"openai\" \"ai\"\n4",
      "bg": "Напишете Shell функция `find_substring_index() {\nlocal haystack=\"$1\"\nlocal needle=\"$2\"\n\n` за решаване на следния проблем:\nТази функция намира първото появяване на подниз 'needle' в низа 'haystack'.\nТя връща индекса на първия символ от първото появяване на 'needle'.\nАко 'needle' не е част от 'haystack', тя връща -1.\nПример за използване:\n>>> find_substring_index \"hello\" \"ll\"\n2\n>>> find_substring_index \"abcd\" \"e\"\n-1\n>>> find_substring_index \"openai\" \"ai\"\n4",
      "zh": "编写一个 Shell 函数 `find_substring_index() {\nlocal haystack=\"$1\"\nlocal needle=\"$2\"\n\n` 来解决以下问题：\n此函数查找子字符串 'needle' 在字符串 'haystack' 中的第一次出现。\n它返回 'needle' 第一次出现的第一个字符的索引。\n如果 'needle' 不是 'haystack' 的一部分，则返回 -1。\n示例用法：\n>>> find_substring_index \"hello\" \"ll\"\n2\n>>> find_substring_index \"abcd\" \"e\"\n-1\n>>> find_substring_index \"openai\" \"ai\"\n4",
      "fr": "Écrire une fonction Shell `find_substring_index() {\nlocal haystack=\"$1\"\nlocal needle=\"$2\"\n\n` pour résoudre le problème suivant :\nCette fonction trouve la première occurrence de la sous-chaîne 'needle' dans la chaîne 'haystack'.\nElle retourne l'index du premier caractère de la première occurrence de 'needle'.\nSi 'needle' ne fait pas partie de 'haystack', elle retourne -1.\nExemple d'utilisation :\n>>> find_substring_index \"hello\" \"ll\"\n2\n>>> find_substring_index \"abcd\" \"e\"\n-1\n>>> find_substring_index \"openai\" \"ai\"\n4",
      "de": "Schreiben Sie eine Shell-Funktion `find_substring_index() {\nlocal haystack=\"$1\"\nlocal needle=\"$2\"\n\n` um das folgende Problem zu lösen:\nDiese Funktion findet das erste Vorkommen des Teilstrings 'needle' im String 'haystack'.\nSie gibt den Index des ersten Zeichens des ersten Vorkommens von 'needle' zurück.\nWenn 'needle' kein Teil von 'haystack' ist, gibt sie -1 zurück.\nBeispielverwendung:\n>>> find_substring_index \"hello\" \"ll\"\n2\n>>> find_substring_index \"abcd\" \"e\"\n-1\n>>> find_substring_index \"openai\" \"ai\"\n4",
      "ha": "Rubuta aikin Shell `find_substring_index() {\nlocal haystack=\"$1\"\nlocal needle=\"$2\"\n\n` don warware matsalar mai zuwa:\nWannan aikin yana nemo farkon bayyanar 'needle' a cikin igiyar 'haystack'.\nYana dawowa da ma'aunin farkon hali na farkon bayyanar 'needle'.\nIdan 'needle' ba wani ɓangare ne na 'haystack', yana dawowa -1.\nMisalin Amfani:\n>>> find_substring_index \"hello\" \"ll\"\n2\n>>> find_substring_index \"abcd\" \"e\"\n-1\n>>> find_substring_index \"openai\" \"ai\"\n4",
      "hi": "Shell फ़ंक्शन `find_substring_index() {\nlocal haystack=\"$1\"\nlocal needle=\"$2\"\n\n` निम्नलिखित समस्या को हल करने के लिए:\nयह फ़ंक्शन स्ट्रिंग 'haystack' में सबस्ट्रिंग 'needle' की पहली उपस्थिति को खोजता है।\nयह 'needle' की पहली उपस्थिति के पहले अक्षर का इंडेक्स लौटाता है।\nयदि 'needle', 'haystack' का हिस्सा नहीं है, तो यह -1 लौटाता है।\nउदाहरण उपयोग:\n>>> find_substring_index \"hello\" \"ll\"\n2\n>>> find_substring_index \"abcd\" \"e\"\n-1\n>>> find_substring_index \"openai\" \"ai\"\n4",
      "hu": "Írj egy Shell függvényt `find_substring_index() {\nlocal haystack=\"$1\"\nlocal needle=\"$2\"\n\n` a következő probléma megoldására:\nEz a függvény megkeresi a 'needle' részsztring első előfordulását a 'haystack' sztringben.\nVisszaadja a 'needle' első előfordulásának első karakterének indexét.\nHa a 'needle' nem része a 'haystack'-nek, akkor -1-et ad vissza.\nPélda használat:\n>>> find_substring_index \"hello\" \"ll\"\n2\n>>> find_substring_index \"abcd\" \"e\"\n-1\n>>> find_substring_index \"openai\" \"ai\"\n4"
    },
    "instruction_bertscore": {
      "sq": "0.9855996946357327",
      "hy": "0.9842426518725024",
      "bn": "0.9943503560722247",
      "bg": "0.9966806877025259",
      "zh": "0.9986767244015455",
      "fr": "0.9943340683809798",
      "de": "0.995730241329274",
      "ha": "0.9784023227789335",
      "hi": "0.9826667184293715",
      "hu": "0.9859304142201558"
    },
    "level": "hard",
    "test": "test_find_substring_index() {\n[[ $(find_substring_index \"hello\" \"ll\") -eq 2 ]] || { echo \"Test 1 failed\"; exit 1; }\n[[ $(find_substring_index \"abcd\" \"e\") -eq -1 ]] || { echo \"Test 2 failed\"; exit 1; }\n[[ $(find_substring_index \"openai\" \"ai\") -eq 4 ]] || { echo \"Test 3 failed\"; exit 1; }\n[[ $(find_substring_index \"apple\" \"pp\") -eq 1 ]] || { echo \"Test 4 failed\"; exit 1; }\n[[ $(find_substring_index \"banana\" \"na\") -eq 2 ]] || { echo \"Test 5 failed\"; exit 1; }\n[[ $(find_substring_index \"teststring\" \"string\") -eq 4 ]] || { echo \"Test 6 failed\"; exit 1; }\n[[ $(find_substring_index \"abcd\" \"\") -eq 0 ]] || { echo \"Test 7 failed\"; exit 1; }\n}\n\ntest_find_substring_index",
    "entry_point": "find_substring_index",
    "signature": "find_substring_index() {\nlocal haystack=\"$1\"\nlocal needle=\"$2\"\n\n",
    "docstring": {
      "en": "This function finds the first occurrence of the substring 'needle' in the string 'haystack'.\nIt returns the index of the first character of the first occurrence of 'needle'.\nIf 'needle' is not a part of 'haystack', it returns -1.\nExample Usage:\n>>> find_substring_index \"hello\" \"ll\"\n2\n>>> find_substring_index \"abcd\" \"e\"\n-1\n>>> find_substring_index \"openai\" \"ai\"\n4",
      "sq": "Kjo funksion gjen paraqitjen e parë të nënvargut 'needle' në vargun 'haystack'.\nKthen indeksin e karakterit të parë të paraqitjes së parë të 'needle'.\nNëse 'needle' nuk është pjesë e 'haystack', kthen -1.\nShembull Përdorimi:\n>>> find_substring_index \"hello\" \"ll\"\n2\n>>> find_substring_index \"abcd\" \"e\"\n-1\n>>> find_substring_index \"openai\" \"ai\"\n4",
      "hy": "Այս ֆունկցիան գտնում է 'needle' ենթատողի առաջին հանդիպումը 'haystack' տողի մեջ:  \nԱյն վերադարձնում է 'needle'-ի առաջին հանդիպման առաջին նիշի ինդեքսը:  \nԵթե 'needle'-ը 'haystack'-ի մաս չէ, այն վերադարձնում է -1:  \nՕգտագործման օրինակ:  \n>>> find_substring_index \"hello\" \"ll\"  \n2  \n>>> find_substring_index \"abcd\" \"e\"  \n-1  \n>>> find_substring_index \"openai\" \"ai\"  \n4  ",
      "bn": "এই ফাংশনটি 'haystack' স্ট্রিংয়ে 'needle' সাবস্ট্রিংয়ের প্রথম উপস্থিতি খুঁজে পায়। এটি 'needle' এর প্রথম উপস্থিতির প্রথম অক্ষরের সূচক প্রদান করে। যদি 'needle' 'haystack' এর অংশ না হয়, তাহলে এটি -1 প্রদান করে। \nউদাহরণ ব্যবহার:\n>>> find_substring_index \"hello\" \"ll\"\n2\n>>> find_substring_index \"abcd\" \"e\"\n-1\n>>> find_substring_index \"openai\" \"ai\"\n4",
      "bg": "Тази функция намира първото срещане на подниз 'needle' в низа 'haystack'.\nВръща индекса на първия символ от първото срещане на 'needle'.\nАко 'needle' не е част от 'haystack', връща -1.\nПример за използване:\n>>> find_substring_index \"hello\" \"ll\"\n2\n>>> find_substring_index \"abcd\" \"e\"\n-1\n>>> find_substring_index \"openai\" \"ai\"\n4",
      "zh": "该函数在字符串 'haystack' 中查找子字符串 'needle' 的第一次出现。  \n它返回 'needle' 第一次出现的第一个字符的索引。  \n如果 'needle' 不是 'haystack' 的一部分，则返回 -1。  \n示例用法:  \n>>> find_substring_index \"hello\" \"ll\"  \n2  \n>>> find_substring_index \"abcd\" \"e\"  \n-1  \n>>> find_substring_index \"openai\" \"ai\"  \n4  ",
      "fr": "Cette fonction trouve la première occurrence de la sous-chaîne 'needle' dans la chaîne 'haystack'.\nElle renvoie l'indice du premier caractère de la première occurrence de 'needle'.\nSi 'needle' ne fait pas partie de 'haystack', elle renvoie -1.\nExemple d'utilisation :\n>>> find_substring_index \"hello\" \"ll\"\n2\n>>> find_substring_index \"abcd\" \"e\"\n-1\n>>> find_substring_index \"openai\" \"ai\"\n4",
      "de": "Diese Funktion findet das erste Vorkommen des Teilstrings 'needle' im String 'haystack'.\nSie gibt den Index des ersten Zeichens des ersten Vorkommens von 'needle' zurück.\nWenn 'needle' kein Teil von 'haystack' ist, gibt sie -1 zurück.\nBeispielverwendung:\n>>> find_substring_index \"hello\" \"ll\"\n2\n>>> find_substring_index \"abcd\" \"e\"\n-1\n>>> find_substring_index \"openai\" \"ai\"\n4",
      "ha": "Wannan aikin yana nemo bayyanar farko na ƙaramin kirtani 'needle' a cikin kirtani 'haystack'.\nYana mayar da alamar harafin farko na bayyanar farko na 'needle'.\nIdan 'needle' ba ya cikin 'haystack', yana mayar da -1.\nMisalin Amfani:\n>>> find_substring_index \"hello\" \"ll\"\n2\n>>> find_substring_index \"abcd\" \"e\"\n-1\n>>> find_substring_index \"openai\" \"ai\"\n4",
      "hi": "यह फ़ंक्शन स्ट्रिंग 'haystack' में उपस्ट्रिंग 'needle' की पहली घटना को खोजता है।  \nयह 'needle' की पहली घटना के पहले वर्ण का सूचकांक लौटाता है।  \nयदि 'needle', 'haystack' का हिस्सा नहीं है, तो यह -1 लौटाता है।  \nउदाहरण उपयोग:  \n>>> find_substring_index \"hello\" \"ll\"  \n2  \n>>> find_substring_index \"abcd\" \"e\"  \n-1  \n>>> find_substring_index \"openai\" \"ai\"  \n4  ",
      "hu": "Ez a függvény megkeresi a 'needle' részszöveg első előfordulását a 'haystack' szövegben.\nVisszaadja a 'needle' első előfordulásának első karakterének indexét.\nHa a 'needle' nem része a 'haystack'-nek, -1-et ad vissza.\nPélda használat:\n>>> find_substring_index \"hello\" \"ll\"\n2\n>>> find_substring_index \"abcd\" \"e\"\n-1\n>>> find_substring_index \"openai\" \"ai\"\n4"
    },
    "docstring_bertscore": {
      "sq": "0.9851529749087852",
      "hy": "0.9797587696510207",
      "bn": "0.9817349433119369",
      "bg": "0.9838664459308223",
      "zh": "0.9919193188387386",
      "fr": "0.9923978194266517",
      "de": "0.9985948886845593",
      "ha": "0.9821137314485704",
      "hi": "0.9907344886158655",
      "hu": "0.9549287802393736"
    }
  },
  {
    "task_id": "Shell/22",
    "prompt": {
      "en": "#!/bin/bash\ntoggle_lights() {\nlocal n=$1\n# This function simulates a sequence of toggling lights. Initially, all lights are off. \n# In each round, a person toggles the state of lights that are multiples of their number. \n# For example, the first person toggles all lights, the second person toggles every second light, and so on.\n# The function outputs the numbers of the lights that remain on after N rounds.\n# Example Usage:\n# >>> toggle_lights 5\n# 1 4\n# >>> toggle_lights 6\n# 1 4\n# >>> toggle_lights 10\n# 1 4 9",
      "sq": "#!/bin/bash\ntoggle_lights() {\nlocal n=$1\n# Kjo funksion simulon një sekuencë të ndezjes dhe fikjes së dritave. Fillimisht, të gjitha dritat janë fikur.\n# Në çdo raund, një person ndryshon gjendjen e dritave që janë shumëfish i numrit të tyre.\n# Për shembull, personi i parë ndryshon gjendjen e të gjitha dritave, personi i dytë ndryshon çdo dritë të dytë, e kështu me radhë.\n# Funksioni shfaq numrat e dritave që mbeten të ndezura pas N raundeve.\n# Shembull Përdorimi:\n# >>> toggle_lights 5\n# 1 4\n# >>> toggle_lights 6\n# 1 4\n# >>> toggle_lights 10\n# 1 4 9",
      "hy": "#!/bin/bash\ntoggle_lights() {\nlocal n=$1\n# Այս ֆունկցիան մոդելավորում է լույսերի միացման հերթականությունը։ Սկզբում բոլոր լույսերը անջատված են։\n# Յուրաքանչյուր փուլում մարդը միացնում է այն լույսերը, որոնց համարը բազմապատիկ է իր համարի։\n# Օրինակ, առաջին մարդը միացնում է բոլոր լույսերը, երկրորդ մարդը միացնում է յուրաքանչյուր երկրորդ լույսը և այդպես շարունակ։\n# Ֆունկցիան վերադարձնում է այն լույսերի համարները, որոնք միացված են մնում N փուլերից հետո։\n# Օրինակ օգտագործում:\n# >>> toggle_lights 5\n# 1 4\n# >>> toggle_lights 6\n# 1 4\n# >>> toggle_lights 10\n# 1 4 9",
      "bn": "#!/bin/bash\ntoggle_lights() {\nlocal n=$1\n# এই ফাংশনটি একটি লাইট টগল করার সিকোয়েন্স অনুকরণ করে। শুরুতে, সব লাইট বন্ধ থাকে।\n# প্রতিটি রাউন্ডে, একজন ব্যক্তি তার সংখ্যার গুণিতক লাইটগুলোর অবস্থা টগল করে।\n# উদাহরণস্বরূপ, প্রথম ব্যক্তি সব লাইট টগল করে, দ্বিতীয় ব্যক্তি প্রতি দ্বিতীয় লাইট টগল করে, এবং এভাবে চলতে থাকে।\n# ফাংশনটি N রাউন্ডের পরে যে লাইটগুলো অন থাকে তাদের সংখ্যা আউটপুট করে।\n# উদাহরণ ব্যবহার:\n# >>> toggle_lights 5\n# 1 4\n# >>> toggle_lights 6\n# 1 4\n# >>> toggle_lights 10\n# 1 4 9",
      "bg": "#!/bin/bash\ntoggle_lights() {\nlocal n=$1\n# Тази функция симулира последователност от превключване на светлини. Първоначално всички светлини са изключени.\n# Във всеки кръг човек превключва състоянието на светлините, които са кратни на неговия номер.\n# Например, първият човек превключва всички светлини, вторият човек превключва всяка втора светлина и така нататък.\n# Функцията извежда номерата на светлините, които остават включени след N кръга.\n# Пример за използване:\n# >>> toggle_lights 5\n# 1 4\n# >>> toggle_lights 6\n# 1 4\n# >>> toggle_lights 10\n# 1 4 9",
      "zh": "#!/bin/bash\ntoggle_lights() {\nlocal n=$1\n# 此函数模拟一个切换灯光的序列。最初，所有灯都是关闭的。\n# 在每一轮中，一个人切换其编号倍数的灯的状态。\n# 例如，第一个人切换所有灯，第二个人切换每隔一个灯，依此类推。\n# 函数输出在 N 轮后仍然亮着的灯的编号。\n# 示例用法:\n# >>> toggle_lights 5\n# 1 4\n# >>> toggle_lights 6\n# 1 4\n# >>> toggle_lights 10\n# 1 4 9",
      "fr": "#!/bin/bash\ntoggle_lights() {\nlocal n=$1\n# Cette fonction simule une séquence de basculement des lumières. Initialement, toutes les lumières sont éteintes.\n# À chaque tour, une personne bascule l'état des lumières qui sont des multiples de son numéro.\n# Par exemple, la première personne bascule toutes les lumières, la deuxième personne bascule chaque deuxième lumière, et ainsi de suite.\n# La fonction affiche les numéros des lumières qui restent allumées après N tours.\n# Exemple d'utilisation :\n# >>> toggle_lights 5\n# 1 4\n# >>> toggle_lights 6\n# 1 4\n# >>> toggle_lights 10\n# 1 4 9",
      "de": "#!/bin/bash\ntoggle_lights() {\nlocal n=$1\n# Diese Funktion simuliert eine Abfolge von Lichtschaltern. Anfänglich sind alle Lichter aus.\n# In jeder Runde schaltet eine Person den Zustand der Lichter um, die Vielfache ihrer Nummer sind.\n# Zum Beispiel schaltet die erste Person alle Lichter um, die zweite Person schaltet jedes zweite Licht um, und so weiter.\n# Die Funktion gibt die Nummern der Lichter aus, die nach N Runden an bleiben.\n# Beispielverwendung:\n# >>> toggle_lights 5\n# 1 4\n# >>> toggle_lights 6\n# 1 4\n# >>> toggle_lights 10\n# 1 4 9",
      "ha": "#!/bin/bash\ntoggle_lights() {\nlocal n=$1\n# Wannan aikin yana kwaikwayon jerin kunna da kashe fitilu. Da farko, duk fitilu a kashe suke.\n# A kowace zagaye, mutum yana canza yanayin fitilu waɗanda suke ninki na lambarsu.\n# Alal misali, mutum na farko yana canza duk fitilu, mutum na biyu yana canza duk fitilu na biyu, da sauransu.\n# Aikin yana fitar da lambobin fitilu waɗanda suka rage a kunne bayan zagaye N.\n# Misalin Amfani:\n# >>> toggle_lights 5\n# 1 4\n# >>> toggle_lights 6\n# 1 4\n# >>> toggle_lights 10\n# 1 4 9",
      "hi": "#!/bin/bash\ntoggle_lights() {\nlocal n=$1\n# यह फ़ंक्शन लाइट्स को टॉगल करने के अनुक्रम का अनुकरण करता है। प्रारंभ में, सभी लाइट्स बंद होती हैं।\n# प्रत्येक राउंड में, एक व्यक्ति उन लाइट्स की स्थिति को टॉगल करता है जो उनके नंबर के गुणज होते हैं।\n# उदाहरण के लिए, पहला व्यक्ति सभी लाइट्स को टॉगल करता है, दूसरा व्यक्ति हर दूसरी लाइट को टॉगल करता है, और इसी प्रकार।\n# फ़ंक्शन उन लाइट्स के नंबर को आउटपुट करता है जो N राउंड के बाद चालू रहती हैं।\n# उदाहरण उपयोग:\n# >>> toggle_lights 5\n# 1 4\n# >>> toggle_lights 6\n# 1 4\n# >>> toggle_lights 10\n# 1 4 9",
      "hu": "#!/bin/bash\ntoggle_lights() {\nlocal n=$1\n# Ez a függvény egy sorozatot szimulál a lámpák kapcsolgatásával. Kezdetben minden lámpa ki van kapcsolva.\n# Minden körben egy személy kapcsolgatja azoknak a lámpáknak az állapotát, amelyek az ő számának többszörösei.\n# Például az első személy az összes lámpát kapcsolgatja, a második személy minden második lámpát, és így tovább.\n# A függvény azoknak a lámpáknak a számát adja vissza, amelyek bekapcsolva maradnak N kör után.\n# Példa használat:\n# >>> toggle_lights 5\n# 1 4\n# >>> toggle_lights 6\n# 1 4\n# >>> toggle_lights 10\n# 1 4 9"
    },
    "prompt_bertscore": {
      "sq": "0.9563356792282436",
      "hy": "0.9415365240588582",
      "bn": "0.9875635532130246",
      "bg": "0.9896650626443737",
      "zh": "0.9948316374854722",
      "fr": "0.9798564957984899",
      "de": "0.9856433933195603",
      "ha": "0.9473776476739512",
      "hi": "0.9943205615150694",
      "hu": "0.9702543059185014"
    },
    "canonical_solution": "local lights=()\n\n# Initialize all lights to off (0)\nfor (( i=1; i<=n; i++ )); do\nlights[$i]=0\ndone\n\n# Toggle lights\nfor (( i=1; i<=n; i++ )); do\nfor (( j=i; j<=n; j+=i )); do\nlights[$j]=$((1 - lights[$j]))\ndone\ndone\n\n# Output lights that are on (1)\nfor (( i=1; i<=n; i++ )); do\nif [[ ${lights[$i]} -eq 1 ]]; then\necho -n \"$i \"\nfi\ndone\necho\n}",
    "instruction": {
      "en": "Write a Shell function `toggle_lights() {\nlocal n=$1\n` to solve the following problem:\nThis function simulates a sequence of toggling lights. Initially, all lights are off. \nIn each round, a person toggles the state of lights that are multiples of their number. \nFor example, the first person toggles all lights, the second person toggles every second light, and so on.\nThe function outputs the numbers of the lights that remain on after N rounds.\nExample Usage:\n>>> toggle_lights 5\n1 4\n>>> toggle_lights 6\n1 4\n>>> toggle_lights 10\n1 4 9",
      "sq": "Shkruani një funksion Shell `toggle_lights() {\nlocal n=$1\n` për të zgjidhur problemin e mëposhtëm:\nKy funksion simulon një sekuencë të ndezjes dhe fikjes së dritave. Fillimisht, të gjitha dritat janë fikur. \nNë çdo raund, një person ndryshon gjendjen e dritave që janë shumëfish i numrit të tyre. \nPër shembull, personi i parë ndryshon të gjitha dritat, personi i dytë ndryshon çdo dritë të dytë, e kështu me radhë.\nFunksioni jep numrat e dritave që mbeten ndezur pas N raundeve.\nShembull Përdorimi:\n>>> toggle_lights 5\n1 4\n>>> toggle_lights 6\n1 4\n>>> toggle_lights 10\n1 4 9",
      "hy": "Գրեք Shell ֆունկցիա `toggle_lights() {\nlocal n=$1\n` հետևյալ խնդիրը լուծելու համար:\nԱյս ֆունկցիան մոդելավորում է լույսերի հերթականության միացումը: Սկզբում բոլոր լույսերը անջատված են:\nՅուրաքանչյուր փուլում, մարդը միացնում է այն լույսերը, որոնք իրենց համարի բազմապատիկ են:\nՕրինակ, առաջին մարդը միացնում է բոլոր լույսերը, երկրորդ մարդը միացնում է յուրաքանչյուր երկրորդ լույսը, և այսպես շարունակ:\nՖունկցիան վերադարձնում է այն լույսերի համարները, որոնք մնում են միացված N փուլից հետո:\nՕրինակ օգտագործում:\n>>> toggle_lights 5\n1 4\n>>> toggle_lights 6\n1 4\n>>> toggle_lights 10\n1 4 9",
      "bn": "একটি Shell ফাংশন লিখুন `toggle_lights() {\nlocal n=$1\n` নিম্নলিখিত সমস্যার সমাধানের জন্য:\nএই ফাংশনটি লাইটগুলি টগল করার একটি ক্রম অনুকরণ করে। প্রাথমিকভাবে, সব লাইট বন্ধ থাকে।\nপ্রতিটি রাউন্ডে, একজন ব্যক্তি তাদের সংখ্যার গুণিতক লাইটের অবস্থা টগল করে। \nউদাহরণস্বরূপ, প্রথম ব্যক্তি সব লাইট টগল করে, দ্বিতীয় ব্যক্তি প্রতি দ্বিতীয় লাইট টগল করে, এবং এভাবে চলতে থাকে।\nফাংশনটি N রাউন্ডের পরে যে লাইটগুলি চালু থাকে তাদের সংখ্যা আউটপুট করে।\nউদাহরণ ব্যবহার:\n>>> toggle_lights 5\n1 4\n>>> toggle_lights 6\n1 4\n>>> toggle_lights 10\n1 4 9",
      "bg": "Напишете Shell функция `toggle_lights() {\nlocal n=$1\n` за решаване на следния проблем:\nТази функция симулира последователност от превключване на светлини. Първоначално всички светлини са изключени.\nВъв всеки рунд човек превключва състоянието на светлините, които са кратни на неговия номер.\nНапример, първият човек превключва всички светлини, вторият човек превключва всяка втора светлина и така нататък.\nФункцията извежда номерата на светлините, които остават включени след N рунда.\nПример за използване:\n>>> toggle_lights 5\n1 4\n>>> toggle_lights 6\n1 4\n>>> toggle_lights 10\n1 4 9",
      "zh": "编写一个 Shell 函数 `toggle_lights() {\nlocal n=$1\n` 来解决以下问题：\n此函数模拟一个切换灯的序列。最初，所有灯都是关闭的。\n在每一轮中，一个人切换其编号倍数的灯的状态。\n例如，第一个人切换所有灯，第二个人切换每隔一个灯，以此类推。\n函数输出在 N 轮后仍然亮着的灯的编号。\n示例用法：\n>>> toggle_lights 5\n1 4\n>>> toggle_lights 6\n1 4\n>>> toggle_lights 10\n1 4 9",
      "fr": "Écrire une fonction Shell `toggle_lights() {\nlocal n=$1\n` pour résoudre le problème suivant :\nCette fonction simule une séquence de basculement des lumières. Initialement, toutes les lumières sont éteintes.\nÀ chaque tour, une personne bascule l'état des lumières qui sont des multiples de son numéro.\nPar exemple, la première personne bascule toutes les lumières, la deuxième personne bascule toutes les deux lumières, et ainsi de suite.\nLa fonction affiche les numéros des lumières qui restent allumées après N tours.\nExemple d'utilisation :\n>>> toggle_lights 5\n1 4\n>>> toggle_lights 6\n1 4\n>>> toggle_lights 10\n1 4 9",
      "de": "Schreiben Sie eine Shell-Funktion `toggle_lights() {\nlocal n=$1\n` um das folgende Problem zu lösen:\nDiese Funktion simuliert eine Sequenz von Lichtwechseln. Anfangs sind alle Lichter aus. \nIn jeder Runde wechselt eine Person den Zustand der Lichter, die Vielfache ihrer Zahl sind. \nZum Beispiel wechselt die erste Person alle Lichter, die zweite Person wechselt jedes zweite Licht und so weiter.\nDie Funktion gibt die Nummern der Lichter aus, die nach N Runden an bleiben.\nBeispielverwendung:\n>>> toggle_lights 5\n1 4\n>>> toggle_lights 6\n1 4\n>>> toggle_lights 10\n1 4 9",
      "ha": "Rubuta aikin Shell `toggle_lights() {\nlocal n=$1\n` don warware matsalar mai zuwa:\nWannan aikin yana kwaikwayon jerin kunna da kashe fitilu. Da farko, duk fitilu suna kashe. \nA kowanne zagaye, wani mutum yana canza yanayin fitilu waɗanda suke lambobin masu yawa na lambarsu. \nMisali, mutum na farko yana canza duk fitilu, mutum na biyu yana canza kowanne fitila na biyu, da sauransu.\nAikin yana fitar da lambobin fitilu waɗanda suka rage a kunne bayan zagaye N.\nMisalin Amfani:\n>>> toggle_lights 5\n1 4\n>>> toggle_lights 6\n1 4\n>>> toggle_lights 10\n1 4 9",
      "hi": "शेल फ़ंक्शन `toggle_lights() {\nlocal n=$1\n` निम्नलिखित समस्या को हल करने के लिए लिखें:\nयह फ़ंक्शन लाइट्स को टॉगल करने के अनुक्रम का अनुकरण करता है। प्रारंभ में, सभी लाइट्स बंद होती हैं। \nप्रत्येक दौर में, एक व्यक्ति उन लाइट्स की स्थिति को टॉगल करता है जो उनके नंबर के गुणज होते हैं। \nउदाहरण के लिए, पहला व्यक्ति सभी लाइट्स को टॉगल करता है, दूसरा व्यक्ति हर दूसरी लाइट को टॉगल करता है, और इसी तरह।\nफ़ंक्शन उन लाइट्स के नंबर को आउटपुट करता है जो N दौर के बाद चालू रहती हैं।\nउदाहरण उपयोग:\n>>> toggle_lights 5\n1 4\n>>> toggle_lights 6\n1 4\n>>> toggle_lights 10\n1 4 9",
      "hu": "Írj egy Shell függvényt `toggle_lights() {\nlocal n=$1\n` a következő probléma megoldására:\nEz a függvény egy sorozatban történő lámpakapcsolást szimulál. Kezdetben minden lámpa ki van kapcsolva. \nMinden körben egy személy kapcsolja a lámpák állapotát, amelyek az ő számának többszörösei. \nPéldául az első személy minden lámpát kapcsol, a második személy minden második lámpát kapcsol, és így tovább.\nA függvény kiírja azoknak a lámpáknak a számát, amelyek bekapcsolva maradnak N kör után.\nPélda használat:\n>>> toggle_lights 5\n1 4\n>>> toggle_lights 6\n1 4\n>>> toggle_lights 10\n1 4 9"
    },
    "instruction_bertscore": {
      "sq": "0.9626986048543152",
      "hy": "0.9683899611621078",
      "bn": "0.9881161429330637",
      "bg": "0.9906862214332741",
      "zh": "0.9916525582370088",
      "fr": "0.9783904049560714",
      "de": "0.9868834427883612",
      "ha": "0.9531184629466215",
      "hi": "0.8868100801065069",
      "hu": "0.9787084121961083"
    },
    "level": "easy",
    "test": "test_toggle_lights() {\n[[ $(toggle_lights 5) == \"1 4 \" ]] || { echo \"Test 1 failed\"; exit 1; }\n[[ $(toggle_lights 6) == \"1 4 \" ]] || { echo \"Test 2 failed\"; exit 1; }\n[[ $(toggle_lights 10) == \"1 4 9 \" ]] || { echo \"Test 3 failed\"; exit 1; }\n[[ $(toggle_lights 3) == \"1 \" ]] || { echo \"Test 4 failed\"; exit 1; }\n[[ $(toggle_lights 7) == \"1 4 \" ]] || { echo \"Test 5 failed\"; exit 1; }\n}\n\ntest_toggle_lights",
    "entry_point": "toggle_lights",
    "signature": "toggle_lights() {\nlocal n=$1\n",
    "docstring": {
      "en": "This function simulates a sequence of toggling lights. Initially, all lights are off. \nIn each round, a person toggles the state of lights that are multiples of their number. \nFor example, the first person toggles all lights, the second person toggles every second light, and so on.\nThe function outputs the numbers of the lights that remain on after N rounds.\nExample Usage:\n>>> toggle_lights 5\n1 4\n>>> toggle_lights 6\n1 4\n>>> toggle_lights 10\n1 4 9",
      "sq": "Kjo funksion simulon një sekuencë të ndezjes dhe fikjes së dritave. Fillimisht, të gjitha dritat janë të fikura. Në çdo raund, një person ndryshon gjendjen e dritave që janë shumëfish i numrit të tij. Për shembull, personi i parë ndryshon të gjitha dritat, personi i dytë ndryshon çdo dritë të dytë, dhe kështu me radhë. Funksioni jep numrat e dritave që mbeten të ndezura pas N raundeve.\nShembull Përdorimi:\n>>> toggle_lights 5\n1 4\n>>> toggle_lights 6\n1 4\n>>> toggle_lights 10\n1 4 9",
      "hy": "Այս ֆունկցիան մոդելավորում է լույսերի միացման և անջատման հաջորդականությունը։ Սկզբում բոլոր լույսերը անջատված են։ \nՅուրաքանչյուր փուլում մարդը փոխում է այն լույսերի վիճակը, որոնք իրենց համարի բազմապատիկներն են։ \nՕրինակ, առաջին մարդը փոխում է բոլոր լույսերը, երկրորդ մարդը փոխում է յուրաքանչյուր երկրորդ լույսը և այդպես շարունակ։\nՖունկցիան արտածում է այն լույսերի համարները, որոնք մնում են միացված N փուլերից հետո։\nՕրինակ օգտագործում:\n>>> toggle_lights 5\n1 4\n>>> toggle_lights 6\n1 4\n>>> toggle_lights 10\n1 4 9",
      "bn": "এই ফাংশনটি একটি লাইট টগল করার ক্রম অনুকরণ করে। প্রাথমিকভাবে, সব লাইট বন্ধ থাকে। \nপ্রতিটি রাউন্ডে, একজন ব্যক্তি তাদের সংখ্যার গুণিতক লাইটের অবস্থান পরিবর্তন করে। \nউদাহরণস্বরূপ, প্রথম ব্যক্তি সব লাইট টগল করে, দ্বিতীয় ব্যক্তি প্রতি দ্বিতীয় লাইট টগল করে, এবং এভাবে চলতে থাকে।\nফাংশনটি N রাউন্ডের পরে যে লাইটগুলি চালু থাকে তাদের সংখ্যা আউটপুট করে।\nব্যবহারের উদাহরণ:\n>>> toggle_lights 5\n1 4\n>>> toggle_lights 6\n1 4\n>>> toggle_lights 10\n1 4 9",
      "bg": "Тази функция симулира последователност от превключване на светлини. Първоначално всички светлини са изключени. \nВъв всеки рунд, човек превключва състоянието на светлините, които са кратни на неговия номер. \nНапример, първият човек превключва всички светлини, вторият човек превключва всяка втора светлина и така нататък.\nФункцията извежда номерата на светлините, които остават включени след N рунда.\nПример за използване:\n>>> toggle_lights 5\n1 4\n>>> toggle_lights 6\n1 4\n>>> toggle_lights 10\n1 4 9",
      "zh": "该函数模拟了一系列开关灯的操作。最初，所有灯都是关闭的。在每一轮中，一个人会切换其编号倍数的灯的状态。例如，第一个人切换所有灯，第二个人切换每隔一个灯，依此类推。该函数输出在 N 轮后仍然亮着的灯的编号。\n\n示例用法：\n>>> toggle_lights 5\n1 4\n>>> toggle_lights 6\n1 4\n>>> toggle_lights 10\n1 4 9",
      "fr": "Cette fonction simule une séquence de commutation de lumières. Initialement, toutes les lumières sont éteintes. À chaque tour, une personne change l'état des lumières qui sont des multiples de son numéro. Par exemple, la première personne change toutes les lumières, la deuxième personne change toutes les deux lumières, et ainsi de suite. La fonction renvoie les numéros des lumières qui restent allumées après N tours.\nExemple d'utilisation :\n>>> toggle_lights 5\n1 4\n>>> toggle_lights 6\n1 4\n>>> toggle_lights 10\n1 4 9",
      "de": "Diese Funktion simuliert eine Sequenz von Umschalten von Lichtern. Anfänglich sind alle Lichter aus. In jeder Runde schaltet eine Person den Zustand der Lichter um, die Vielfache ihrer Nummer sind. Zum Beispiel schaltet die erste Person alle Lichter um, die zweite Person schaltet jedes zweite Licht um, und so weiter. Die Funktion gibt die Nummern der Lichter aus, die nach N Runden an bleiben.\nBeispielverwendung:\n>>> toggle_lights 5\n1 4\n>>> toggle_lights 6\n1 4\n>>> toggle_lights 10\n1 4 9",
      "ha": "Wannan aikin yana kwaikwayon jerin kunnawa da kashe fitilu. Da fari dai, duk fitilu a kashe suke. A kowace zagaye, wani mutum yana kunnawa ko kashe fitilu waɗanda suke ninki na lambarsu. Alal misali, mutum na farko yana kunnawa ko kashe dukkan fitilu, mutum na biyu yana kunnawa ko kashe kowane fitilu na biyu, da sauransu. Aikin yana fitar da lambobin fitilu waɗanda suka rage a kunne bayan zagaye N.\n\nMisalin Amfani:\n>>> toggle_lights 5\n1 4\n>>> toggle_lights 6\n1 4\n>>> toggle_lights 10\n1 4 9",
      "hi": "यह फ़ंक्शन लाइट्स को टॉगल करने के अनुक्रम का अनुकरण करता है। प्रारंभ में, सभी लाइट्स बंद होती हैं। \nप्रत्येक राउंड में, एक व्यक्ति उन लाइट्स की स्थिति को टॉगल करता है जो उनके संख्या के गुणज होती हैं। \nउदाहरण के लिए, पहला व्यक्ति सभी लाइट्स को टॉगल करता है, दूसरा व्यक्ति हर दूसरी लाइट को टॉगल करता है, और इसी प्रकार आगे। \nफ़ंक्शन उन लाइट्स की संख्याओं को आउटपुट करता है जो N राउंड के बाद चालू रहती हैं।\nउदाहरण उपयोग:\n>>> toggle_lights 5\n1 4\n>>> toggle_lights 6\n1 4\n>>> toggle_lights 10\n1 4 9",
      "hu": "Ez a függvény egy sorozat fénykapcsolást szimulál. Kezdetben minden lámpa ki van kapcsolva. \nMinden körben egy személy átkapcsolja azoknak a lámpáknak az állapotát, amelyek az ő számának többszörösei. \nPéldául az első személy az összes lámpát átkapcsolja, a második személy minden második lámpát kapcsol át, és így tovább.\nA függvény azoknak a lámpáknak a számát adja vissza, amelyek bekapcsolva maradnak N kör után.\nPélda használat:\n>>> toggle_lights 5\n1 4\n>>> toggle_lights 6\n1 4\n>>> toggle_lights 10\n1 4 9"
    },
    "docstring_bertscore": {
      "sq": "0.9539056351466628",
      "hy": "0.9428351694900644",
      "bn": "0.9792800704327267",
      "bg": "0.9835774387264165",
      "zh": "0.974198112133949",
      "fr": "0.9430185053317596",
      "de": "0.9924534359333415",
      "ha": "0.9619595012064844",
      "hi": "0.9961876870967974",
      "hu": "0.9661682803502327"
    }
  },
  {
    "task_id": "Shell/23",
    "prompt": {
      "en": "#!/bin/bash\nmaximize_product() {\nlocal sum_n=$1\nlocal num_m=$2\n# This function finds M positive integers that sum up to N and have the maximum possible product.\n# The function outputs the integers in a lexicographically smallest order.\n# If no such combination exists, it outputs an error message.\n# Example Usage:\n# >>> maximize_product 6 3\n# 2 2 2\n# >>> maximize_product 8 3\n# 2 3 3\n# >>> maximize_product 10 2\n# 5 5\n# >>> maximize_product 20 5\n# 4 4 4 4 4",
      "sq": "#!/bin/bash\nmaximize_product() {\nlocal sum_n=$1\nlocal num_m=$2\n# Kjo funksion gjen M numra pozitivë që shuma e tyre është N dhe kanë produktin maksimal të mundshëm.\n# Funksioni jep numrat në rend leksikografikisht më të vogël.\n# Nëse nuk ekziston një kombinim i tillë, jep një mesazh gabimi.\n# Shembull Përdorimi:\n# >>> maximize_product 6 3\n# 2 2 2\n# >>> maximize_product 8 3\n# 2 3 3\n# >>> maximize_product 10 2\n# 5 5\n# >>> maximize_product 20 5\n# 4 4 4 4 4",
      "hy": "#!/bin/bash\nmaximize_product() {\nlocal sum_n=$1\nlocal num_m=$2\n# Այս ֆունկցիան գտնում է M դրական ամբողջ թվեր, որոնք գումարվում են N-ի և ունեն առավելագույն հնարավոր արտադրյալ:\n# Ֆունկցիան արտածում է թվերը բառարանային ամենափոքր հերթականությամբ:\n# Եթե նման համակցություն գոյություն չունի, այն արտածում է սխալի հաղորդագրություն:\n# Օրինակ օգտագործում:\n# >>> maximize_product 6 3\n# 2 2 2\n# >>> maximize_product 8 3\n# 2 3 3\n# >>> maximize_product 10 2\n# 5 5\n# >>> maximize_product 20 5\n# 4 4 4 4 4",
      "bn": "#!/bin/bash\nmaximize_product() {\nlocal sum_n=$1\nlocal num_m=$2\n# এই ফাংশনটি M টি ধনাত্মক পূর্ণসংখ্যা খুঁজে বের করে যেগুলোর যোগফল N এবং যাদের গুণফল সম্ভবপর সর্বাধিক।\n# ফাংশনটি পূর্ণসংখ্যাগুলোকে অভিধানক্রমে ক্ষুদ্রতম ক্রমে আউটপুট করে।\n# যদি এমন কোনো সমন্বয় না থাকে, তবে এটি একটি ত্রুটি বার্তা আউটপুট করে।\n# উদাহরণ ব্যবহার:\n# >>> maximize_product 6 3\n# 2 2 2\n# >>> maximize_product 8 3\n# 2 3 3\n# >>> maximize_product 10 2\n# 5 5\n# >>> maximize_product 20 5\n# 4 4 4 4 4",
      "bg": "#!/bin/bash\nmaximize_product() {\nlocal sum_n=$1\nlocal num_m=$2\n# Тази функция намира M положителни цели числа, които се сумират до N и имат максимално възможен произведение.\n# Функцията извежда числата в лексикографски най-малък ред.\n# Ако не съществува такава комбинация, тя извежда съобщение за грешка.\n# Пример за използване:\n# >>> maximize_product 6 3\n# 2 2 2\n# >>> maximize_product 8 3\n# 2 3 3\n# >>> maximize_product 10 2\n# 5 5\n# >>> maximize_product 20 5\n# 4 4 4 4 4",
      "zh": "#!/bin/bash\nmaximize_product() {\nlocal sum_n=$1\nlocal num_m=$2\n# 此函数找到 M 个正整数，这些整数的和为 N，并且乘积最大。\n# 函数按字典序最小的顺序输出这些整数。\n# 如果不存在这样的组合，则输出错误信息。\n# 示例用法：\n# >>> maximize_product 6 3\n# 2 2 2\n# >>> maximize_product 8 3\n# 2 3 3\n# >>> maximize_product 10 2\n# 5 5\n# >>> maximize_product 20 5\n# 4 4 4 4 4",
      "fr": "#!/bin/bash\nmaximize_product() {\nlocal sum_n=$1\nlocal num_m=$2\n# Cette fonction trouve M entiers positifs qui s'additionnent pour donner N et ont le produit maximal possible.\n# La fonction affiche les entiers dans l'ordre lexicographiquement le plus petit.\n# Si aucune combinaison de ce type n'existe, elle affiche un message d'erreur.\n# Exemple d'utilisation :\n# >>> maximize_product 6 3\n# 2 2 2\n# >>> maximize_product 8 3\n# 2 3 3\n# >>> maximize_product 10 2\n# 5 5\n# >>> maximize_product 20 5\n# 4 4 4 4 4",
      "de": "#!/bin/bash\nmaximize_product() {\nlocal sum_n=$1\nlocal num_m=$2\n# Diese Funktion findet M positive ganze Zahlen, die sich zu N summieren und das maximal mögliche Produkt haben.\n# Die Funktion gibt die Zahlen in lexikografisch kleinster Reihenfolge aus.\n# Wenn keine solche Kombination existiert, gibt sie eine Fehlermeldung aus.\n# Beispielverwendung:\n# >>> maximize_product 6 3\n# 2 2 2\n# >>> maximize_product 8 3\n# 2 3 3\n# >>> maximize_product 10 2\n# 5 5\n# >>> maximize_product 20 5\n# 4 4 4 4 4",
      "ha": "#!/bin/bash\nmaximize_product() {\nlocal sum_n=$1\nlocal num_m=$2\n# Wannan aikin yana nemo lambobi M masu kyau waɗanda suka haɗu zuwa N kuma suna da mafi girman samfurin da zai yiwu.\n# Aikin yana fitar da lambobin a cikin tsari mafi ƙarami na lexicographically.\n# Idan babu irin wannan haɗin, yana fitar da saƙon kuskure.\n# Misalin Amfani:\n# >>> maximize_product 6 3\n# 2 2 2\n# >>> maximize_product 8 3\n# 2 3 3\n# >>> maximize_product 10 2\n# 5 5\n# >>> maximize_product 20 5\n# 4 4 4 4 4",
      "hi": "#!/bin/bash\nmaximize_product() {\nlocal sum_n=$1\nlocal num_m=$2\n# यह फ़ंक्शन M धनात्मक पूर्णांक खोजता है जो N के बराबर होते हैं और जिनका गुणनफल अधिकतम संभव होता है।\n# फ़ंक्शन पूर्णांकों को लेक्सिकोग्राफिक रूप से सबसे छोटे क्रम में आउटपुट करता है।\n# यदि ऐसा कोई संयोजन मौजूद नहीं है, तो यह एक त्रुटि संदेश आउटपुट करता है।\n# उदाहरण उपयोग:\n# >>> maximize_product 6 3\n# 2 2 2\n# >>> maximize_product 8 3\n# 2 3 3\n# >>> maximize_product 10 2\n# 5 5\n# >>> maximize_product 20 5\n# 4 4 4 4 4",
      "hu": "#!/bin/bash\nmaximize_product() {\nlocal sum_n=$1\nlocal num_m=$2\n# Ez a függvény M pozitív egész számot talál, amelyek összege N, és amelyek maximális lehetséges szorzattal rendelkeznek.\n# A függvény a számokat lexikografikusan legkisebb sorrendben adja meg.\n# Ha nincs ilyen kombináció, hibaüzenetet ad ki.\n# Példa használat:\n# >>> maximize_product 6 3\n# 2 2 2\n# >>> maximize_product 8 3\n# 2 3 3\n# >>> maximize_product 10 2\n# 5 5\n# >>> maximize_product 20 5\n# 4 4 4 4 4"
    },
    "prompt_bertscore": {
      "sq": "0.9693417979480271",
      "hy": "0.9882275745768242",
      "bn": "0.972097198593743",
      "bg": "0.9879923962056789",
      "zh": "0.9668577264028048",
      "fr": "0.9682602555232921",
      "de": "0.9882275745768242",
      "ha": "0.9680963854589383",
      "hi": "0.9868913880036025",
      "hu": "0.9736800841002101"
    },
    "canonical_solution": "if (( sum_n < num_m )); then\necho \"Error: Cannot divide $sum_n into $num_m parts\"\nreturn 1\nfi\n\n# Initialize an array to hold the numbers\nlocal -a numbers\nfor (( i=0; i<num_m; i++ )); do\nnumbers[$i]=$((sum_n / num_m))\ndone\n\n# Distribute the remainder\nlocal remainder=$((sum_n % num_m))\nfor (( i=0; i<remainder; i++ )); do\n((numbers[i]++))\ndone\n\n# Output the numbers in reverse to get lexicographically smallest order\nfor (( i=num_m-1; i>=0; i-- )); do\necho -n \"${numbers[i]} \"\ndone\necho\n}",
    "instruction": {
      "en": "Write a Shell function `maximize_product() {\nlocal sum_n=$1\nlocal num_m=$2\n` to solve the following problem:\nThis function finds M positive integers that sum up to N and have the maximum possible product.\nThe function outputs the integers in a lexicographically smallest order.\nIf no such combination exists, it outputs an error message.\nExample Usage:\n>>> maximize_product 6 3\n2 2 2\n>>> maximize_product 8 3\n2 3 3\n>>> maximize_product 10 2\n5 5\n>>> maximize_product 20 5\n4 4 4 4 4",
      "sq": "Shkruani një funksion Shell `maximize_product() {\nlocal sum_n=$1\nlocal num_m=$2\n` për të zgjidhur problemin e mëposhtëm:\nKy funksion gjen M numra të plotë pozitivë që kanë shumën N dhe kanë produktin maksimal të mundshëm.\nFunksioni jep numrat në rendin leksikografikisht më të vogël.\nNëse nuk ekziston një kombinim i tillë, jep një mesazh gabimi.\nShembull Përdorimi:\n>>> maximize_product 6 3\n2 2 2\n>>> maximize_product 8 3\n2 3 3\n>>> maximize_product 10 2\n5 5\n>>> maximize_product 20 5\n4 4 4 4 4",
      "hy": "Գրեք Shell ֆունկցիա `maximize_product() {\nlocal sum_n=$1\nlocal num_m=$2\n` հետևյալ խնդիրը լուծելու համար:\nԱյս ֆունկցիան գտնում է M դրական ամբողջ թվեր, որոնք գումարվում են N-ի և ունեն առավելագույն հնարավոր արտադրյալ:\nՖունկցիան արտածում է ամբողջ թվերը բառարանային ամենափոքր հերթականությամբ:\nԵթե այդպիսի համակցություն գոյություն չունի, այն արտածում է սխալի հաղորդագրություն:\nՕրինակ օգտագործում:\n>>> maximize_product 6 3\n2 2 2\n>>> maximize_product 8 3\n2 3 3\n>>> maximize_product 10 2\n5 5\n>>> maximize_product 20 5\n4 4 4 4 4",
      "bn": "একটি Shell ফাংশন লিখুন `maximize_product() {\nlocal sum_n=$1\nlocal num_m=$2\n` নিম্নলিখিত সমস্যার সমাধানের জন্য:\nএই ফাংশনটি M টি ধনাত্মক পূর্ণসংখ্যা খুঁজে বের করে যেগুলোর যোগফল N এবং যেগুলোর গুণফল সম্ভবপর সর্বাধিক।\nফাংশনটি পূর্ণসংখ্যাগুলোকে লেক্সিকোগ্রাফিক্যালি ক্ষুদ্রতম ক্রমে আউটপুট করে।\nযদি এমন কোনো সংমিশ্রণ না থাকে, এটি একটি ত্রুটি বার্তা আউটপুট করে।\nউদাহরণ ব্যবহার:\n>>> maximize_product 6 3\n2 2 2\n>>> maximize_product 8 3\n2 3 3\n>>> maximize_product 10 2\n5 5\n>>> maximize_product 20 5\n4 4 4 4 4",
      "bg": "Напишете Shell функция `maximize_product() {\nlocal sum_n=$1\nlocal num_m=$2\n` за решаване на следния проблем:\nТази функция намира M положителни цели числа, които се сумират до N и имат максимално възможен произведение.\nФункцията извежда числата в лексикографски най-малък ред.\nАко не съществува такава комбинация, тя извежда съобщение за грешка.\nПример за използване:\n>>> maximize_product 6 3\n2 2 2\n>>> maximize_product 8 3\n2 3 3\n>>> maximize_product 10 2\n5 5\n>>> maximize_product 20 5\n4 4 4 4 4",
      "zh": "编写一个 Shell 函数 `maximize_product() {\nlocal sum_n=$1\nlocal num_m=$2\n` 来解决以下问题：\n此函数找到 M 个正整数，这些整数的和为 N，并且乘积最大。\n函数按字典序最小的顺序输出这些整数。\n如果不存在这样的组合，则输出错误信息。\n示例用法：\n>>> maximize_product 6 3\n2 2 2\n>>> maximize_product 8 3\n2 3 3\n>>> maximize_product 10 2\n5 5\n>>> maximize_product 20 5\n4 4 4 4 4",
      "fr": "Écrire une fonction Shell `maximize_product() {\nlocal sum_n=$1\nlocal num_m=$2\n` pour résoudre le problème suivant :\nCette fonction trouve M entiers positifs qui s'additionnent pour donner N et ont le produit maximum possible.\nLa fonction affiche les entiers dans l'ordre lexicographiquement le plus petit.\nSi aucune combinaison de ce type n'existe, elle affiche un message d'erreur.\nExemple d'utilisation :\n>>> maximize_product 6 3\n2 2 2\n>>> maximize_product 8 3\n2 3 3\n>>> maximize_product 10 2\n5 5\n>>> maximize_product 20 5\n4 4 4 4 4",
      "de": "Schreiben Sie eine Shell-Funktion `maximize_product() {\nlocal sum_n=$1\nlocal num_m=$2\n` um das folgende Problem zu lösen:\nDiese Funktion findet M positive ganze Zahlen, die sich zu N summieren und das maximal mögliche Produkt haben.\nDie Funktion gibt die Zahlen in lexikographisch kleinster Reihenfolge aus.\nWenn keine solche Kombination existiert, gibt sie eine Fehlermeldung aus.\nBeispielverwendung:\n>>> maximize_product 6 3\n2 2 2\n>>> maximize_product 8 3\n2 3 3\n>>> maximize_product 10 2\n5 5\n>>> maximize_product 20 5\n4 4 4 4 4",
      "ha": "Rubuta aikin Shell `maximize_product() {\nlocal sum_n=$1\nlocal num_m=$2\n` don warware matsalar mai zuwa:\nWannan aikin yana nemo lambobi M masu kyau waɗanda suka haɗu zuwa N kuma suna da mafi girman samfurin da zai yiwu.\nAikin yana fitar da lambobin a cikin tsari mafi ƙarancin lexicographically.\nIdan babu irin wannan haɗin, yana fitar da saƙon kuskure.\nMisalin Amfani:\n>>> maximize_product 6 3\n2 2 2\n>>> maximize_product 8 3\n2 3 3\n>>> maximize_product 10 2\n5 5\n>>> maximize_product 20 5\n4 4 4 4 4",
      "hi": "Shell फ़ंक्शन `maximize_product() {\nlocal sum_n=$1\nlocal num_m=$2\n` निम्नलिखित समस्या को हल करने के लिए:\nयह फ़ंक्शन M धनात्मक पूर्णांक खोजता है जो N के बराबर होते हैं और जिनका गुणनफल अधिकतम संभव होता है।\nफ़ंक्शन पूर्णांकों को शब्दकोश क्रम में सबसे छोटे क्रम में आउटपुट करता है।\nयदि ऐसा कोई संयोजन मौजूद नहीं है, तो यह एक त्रुटि संदेश आउटपुट करता है।\nउदाहरण उपयोग:\n>>> maximize_product 6 3\n2 2 2\n>>> maximize_product 8 3\n2 3 3\n>>> maximize_product 10 2\n5 5\n>>> maximize_product 20 5\n4 4 4 4 4",
      "hu": "Írj egy Shell függvényt `maximize_product() {\nlocal sum_n=$1\nlocal num_m=$2\n` a következő probléma megoldására:\nEz a függvény M pozitív egész számot talál, amelyek összege N és a lehető legnagyobb szorzatot adják.\nA függvény a számokat lexikografikusan legkisebb sorrendben adja vissza.\nHa nem létezik ilyen kombináció, akkor hibaüzenetet ad ki.\nPélda használat:\n>>> maximize_product 6 3\n2 2 2\n>>> maximize_product 8 3\n2 3 3\n>>> maximize_product 10 2\n5 5\n>>> maximize_product 20 5\n4 4 4 4 4"
    },
    "instruction_bertscore": {
      "sq": "0.9865072368466811",
      "hy": "0.9869905045637389",
      "bn": "0.9786261792183598",
      "bg": "0.9922140863241945",
      "zh": "0.9595783201986382",
      "fr": "0.9747822840845727",
      "de": "0.9849559335707986",
      "ha": "0.98007340017458",
      "hi": "0.9517922078924516",
      "hu": "0.961176897505207"
    },
    "level": "middle",
    "test": "test_maximize_product() {\n[[ $(maximize_product 6 3) == \"2 2 2 \" ]] || { echo \"Test 1 failed\"; exit 1; }\n[[ $(maximize_product 8 3) == \"2 3 3 \" ]] || { echo \"Test 2 failed\"; exit 1; }\n[[ $(maximize_product 10 2) == \"5 5 \" ]] || { echo \"Test 3 failed\"; exit 1; }\n[[ $(maximize_product 20 5) == \"4 4 4 4 4 \" ]] || { echo \"Test 4 failed\"; exit 1; }\n[[ $(maximize_product 7 3) == \"2 2 3 \" ]] || { echo \"Test 5 failed\"; exit 1; }\n[[ $(maximize_product 12 4) == \"3 3 3 3 \" ]] || { echo \"Test 6 failed\"; exit 1; }\n[[ $(maximize_product 5 6) == \"Error: Cannot divide 5 into 6 parts\" ]] && { echo \"Test 7 passed\"; } || { echo \"Test 7 failed\"; exit 1; }\n}\n\ntest_maximize_product",
    "entry_point": "maximize_product",
    "signature": "maximize_product() {\nlocal sum_n=$1\nlocal num_m=$2\n",
    "docstring": {
      "en": "This function finds M positive integers that sum up to N and have the maximum possible product.\nThe function outputs the integers in a lexicographically smallest order.\nIf no such combination exists, it outputs an error message.\nExample Usage:\n>>> maximize_product 6 3\n2 2 2\n>>> maximize_product 8 3\n2 3 3\n>>> maximize_product 10 2\n5 5\n>>> maximize_product 20 5\n4 4 4 4 4",
      "sq": "Kjo funksion gjen M numra të plotë pozitivë që shuma e tyre është N dhe kanë produktin maksimal të mundshëm.\nFunksioni jep numrat në një rend leksikografikisht më të vogël.\nNëse nuk ekziston një kombinim i tillë, jep një mesazh gabimi.\nShembull i Përdorimit:\n>>> maximize_product 6 3\n2 2 2\n>>> maximize_product 8 3\n2 3 3\n>>> maximize_product 10 2\n5 5\n>>> maximize_product 20 5\n4 4 4 4 4",
      "hy": "Այս ֆունկցիան գտնում է M դրական ամբողջ թվեր, որոնք գումարվում են N-ի և ունեն հնարավոր ամենամեծ արտադրյալը։ Ֆունկցիան արդյունք է տալիս թվերը բառարանային ամենափոքր հերթականությամբ։ Եթե նման համակցություն գոյություն չունի, այն արտածում է սխալի հաղորդագրություն։ Օրինակ օգտագործում:\n>>> maximize_product 6 3\n2 2 2\n>>> maximize_product 8 3\n2 3 3\n>>> maximize_product 10 2\n5 5\n>>> maximize_product 20 5\n4 4 4 4 4",
      "bn": "এই ফাংশনটি M টি ধনাত্মক পূর্ণসংখ্যা খুঁজে বের করে যা N এর সমান এবং যাদের গুণফল সম্ভবপর সর্বাধিক হয়। \nফাংশনটি পূর্ণসংখ্যাগুলি লেক্সিকোগ্রাফিকভাবে ক্ষুদ্রতম ক্রমে আউটপুট করে। \nযদি এমন কোনো সংমিশ্রণ না থাকে, এটি একটি ত্রুটি বার্তা আউটপুট করে। \nব্যবহারের উদাহরণ:\n>>> maximize_product 6 3\n2 2 2\n>>> maximize_product 8 3\n2 3 3\n>>> maximize_product 10 2\n5 5\n>>> maximize_product 20 5\n4 4 4 4 4",
      "bg": "Тази функция намира M положителни цели числа, които се сумират до N и имат максимално възможен произведение. Функцията извежда числата в лексикографски най-малък ред. Ако не съществува такава комбинация, тя извежда съобщение за грешка.\nПример за използване:\n>>> maximize_product 6 3\n2 2 2\n>>> maximize_product 8 3\n2 3 3\n>>> maximize_product 10 2\n5 5\n>>> maximize_product 20 5\n4 4 4 4 4",
      "zh": "该函数查找 M 个正整数，这些整数的和为 N，并且具有可能的最大乘积。\n函数按字典序最小的顺序输出这些整数。\n如果不存在这样的组合，则输出错误信息。\n示例用法：\n>>> maximize_product 6 3\n2 2 2\n>>> maximize_product 8 3\n2 3 3\n>>> maximize_product 10 2\n5 5\n>>> maximize_product 20 5\n4 4 4 4 4",
      "fr": "Cette fonction trouve M entiers positifs qui s'additionnent pour donner N et qui ont le produit maximum possible.  \nLa fonction renvoie les entiers dans un ordre lexicographiquement le plus petit.  \nSi aucune combinaison de ce type n'existe, elle renvoie un message d'erreur.  \nExemple d'utilisation :  \n>>> maximize_product 6 3  \n2 2 2  \n>>> maximize_product 8 3  \n2 3 3  \n>>> maximize_product 10 2  \n5 5  \n>>> maximize_product 20 5  \n4 4 4 4 4  ",
      "de": "Diese Funktion findet M positive ganze Zahlen, die sich zu N summieren und das maximal mögliche Produkt haben.\nDie Funktion gibt die ganzen Zahlen in lexikographisch kleinster Reihenfolge aus.\nWenn keine solche Kombination existiert, gibt sie eine Fehlermeldung aus.\nBeispielverwendung:\n>>> maximize_product 6 3\n2 2 2\n>>> maximize_product 8 3\n2 3 3\n>>> maximize_product 10 2\n5 5\n>>> maximize_product 20 5\n4 4 4 4 4",
      "ha": "Wannan aikin yana nemo lambobin M masu kyau waɗanda suka tara zuwa N kuma suna da mafi girman samfurin da zai yiwu. \nAikin yana fitar da lambobin a cikin tsari mafi ƙarancin haruffa. \nIdan babu irin wannan haɗin, yana fitar da saƙon kuskure.\n\nMisalin Amfani:\n>>> maximize_product 6 3\n2 2 2\n>>> maximize_product 8 3\n2 3 3\n>>> maximize_product 10 2\n5 5\n>>> maximize_product 20 5\n4 4 4 4 4",
      "hi": "यह फ़ंक्शन M धनात्मक पूर्णांक खोजता है जो N के बराबर होते हैं और जिनका गुणनफल अधिकतम संभव होता है। \nफ़ंक्शन इन पूर्णांकों को शब्दकोशीय दृष्टि से सबसे छोटे क्रम में आउटपुट करता है। \nयदि ऐसा कोई संयोजन मौजूद नहीं है, तो यह एक त्रुटि संदेश आउटपुट करता है। \nउदाहरण उपयोग:\n>>> maximize_product 6 3\n2 2 2\n>>> maximize_product 8 3\n2 3 3\n>>> maximize_product 10 2\n5 5\n>>> maximize_product 20 5\n4 4 4 4 4",
      "hu": "Ez a függvény megkeresi azt az M pozitív egész számot, amelyek összege N és a lehető legnagyobb szorzatot adják.\nA függvény a számokat lexikografikusan legkisebb sorrendben adja meg.\nHa nem létezik ilyen kombináció, hibaüzenetet ad ki.\nPéldahasználat:\n>>> maximize_product 6 3\n2 2 2\n>>> maximize_product 8 3\n2 3 3\n>>> maximize_product 10 2\n5 5\n>>> maximize_product 20 5\n4 4 4 4 4"
    },
    "docstring_bertscore": {
      "sq": "0.9501930346947397",
      "hy": "0.9790325769779572",
      "bn": "0.9299754413611037",
      "bg": "0.9799017835253658",
      "zh": "0.9655308754574917",
      "fr": "0.9590759839650009",
      "de": "0.9861973734522667",
      "ha": "0.9407044613927031",
      "hi": "0.9659245608727028",
      "hu": "0.9440952806273497"
    }
  },
  {
    "task_id": "Shell/24",
    "prompt": {
      "en": "#!/bin/bash\ncalculate_sine() {\nlocal a=$1\nlocal b=$2\nlocal c=$3\n# This function calculates the sine of the smaller acute angle in a Pythagorean triplet (a, b, c).\n# It outputs the sine value in reduced fraction format.\n# The Pythagorean triplet is provided as three positive integers, which represent the sides of a right-angled triangle.\n# The function assumes that the input numbers form a valid Pythagorean triplet.\n# Example Usage:\n# >>> calculate_sine 3 5 4\n# 3/5\n# >>> calculate_sine 5 12 13\n# 5/13\n# >>> calculate_sine 8 15 17\n# 8/17",
      "sq": "#!/bin/bash\ncalculate_sine() {\nlocal a=$1\nlocal b=$2\nlocal c=$3\n# Kjo funksion llogarit sinusin e këndit të mprehtë më të vogël në një treshe Pitagoriane (a, b, c).\n# Ai jep si rezultat vlerën e sinusit në formatin e thyesës së reduktuar.\n# Tresha Pitagoriane jepet si tre numra të plotë pozitivë, të cilët përfaqësojnë anët e një trekëndëshi kënddrejtë.\n# Funksioni supozon që numrat e dhënë formojnë një treshe Pitagoriane të vlefshme.\n# Shembull i Përdorimit:\n# >>> calculate_sine 3 5 4\n# 3/5\n# >>> calculate_sine 5 12 13\n# 5/13\n# >>> calculate_sine 8 15 17\n# 8/17",
      "hy": "#!/bin/bash\ncalculate_sine() {\nlocal a=$1\nlocal b=$2\nlocal c=$3\n# Այս ֆունկցիան հաշվում է սուր անկյուններից փոքրագույնի սինուսը Պյութագորասյան եռյակ (a, b, c)-ում:\n# Այն արդյունքը տալիս է կրճատված կոտորակի ձևով:\n# Պյութագորասյան եռյակը տրվում է որպես երեք դրական ամբողջ թվեր, որոնք ներկայացնում են ուղիղանկյուն եռանկյան կողմերը:\n# Ֆունկցիան ենթադրում է, որ մուտքային թվերը կազմում են վավեր Պյութագորասյան եռյակ:\n# Օրինակ օգտագործում:\n# >>> calculate_sine 3 5 4\n# 3/5\n# >>> calculate_sine 5 12 13\n# 5/13\n# >>> calculate_sine 8 15 17\n# 8/17",
      "bn": "#!/bin/bash\ncalculate_sine() {\nlocal a=$1\nlocal b=$2\nlocal c=$3\n# এই ফাংশনটি একটি পিথাগোরিয়ান ট্রিপলেটের (a, b, c) ছোট তীক্ষ্ণ কোণের সাইন গণনা করে।\n# এটি সাইন মানকে হ্রাসকৃত ভগ্নাংশ বিন্যাসে আউটপুট করে।\n# পিথাগোরিয়ান ট্রিপলেটটি তিনটি ধনাত্মক পূর্ণসংখ্যা হিসাবে প্রদান করা হয়, যা একটি সমকোণী ত্রিভুজের বাহুগুলি উপস্থাপন করে।\n# ফাংশনটি ধরে নেয় যে ইনপুট সংখ্যা একটি বৈধ পিথাগোরিয়ান ট্রিপলেট গঠন করে।\n# উদাহরণ ব্যবহার:\n# >>> calculate_sine 3 5 4\n# 3/5\n# >>> calculate_sine 5 12 13\n# 5/13\n# >>> calculate_sine 8 15 17\n# 8/17",
      "bg": "#!/bin/bash\ncalculate_sine() {\nlocal a=$1\nlocal b=$2\nlocal c=$3\n# Тази функция изчислява синуса на по-малкия остър ъгъл в Питагорова тройка (a, b, c).\n# Тя извежда стойността на синуса във формат на съкратена дроб.\n# Питагоровата тройка е предоставена като три положителни цели числа, които представляват страните на правоъгълен триъгълник.\n# Функцията приема, че входните числа образуват валидна Питагорова тройка.\n# Пример за използване:\n# >>> calculate_sine 3 5 4\n# 3/5\n# >>> calculate_sine 5 12 13\n# 5/13\n# >>> calculate_sine 8 15 17\n# 8/17",
      "zh": "#!/bin/bash\ncalculate_sine() {\nlocal a=$1\nlocal b=$2\nlocal c=$3\n# 此函数计算毕达哥拉斯三元组 (a, b, c) 中较小锐角的正弦值。\n# 它以最简分数格式输出正弦值。\n# 毕达哥拉斯三元组由三个正整数提供，表示直角三角形的边。\n# 函数假设输入数字构成一个有效的毕达哥拉斯三元组。\n# 示例用法：\n# >>> calculate_sine 3 5 4\n# 3/5\n# >>> calculate_sine 5 12 13\n# 5/13\n# >>> calculate_sine 8 15 17\n# 8/17",
      "fr": "#!/bin/bash\ncalculate_sine() {\nlocal a=$1\nlocal b=$2\nlocal c=$3\n# Cette fonction calcule le sinus du plus petit angle aigu dans un triplet pythagoricien (a, b, c).\n# Elle affiche la valeur du sinus sous forme de fraction réduite.\n# Le triplet pythagoricien est fourni sous forme de trois entiers positifs, qui représentent les côtés d'un triangle rectangle.\n# La fonction suppose que les nombres d'entrée forment un triplet pythagoricien valide.\n# Exemple d'utilisation :\n# >>> calculate_sine 3 5 4\n# 3/5\n# >>> calculate_sine 5 12 13\n# 5/13\n# >>> calculate_sine 8 15 17\n# 8/17",
      "de": "#!/bin/bash\ncalculate_sine() {\nlocal a=$1\nlocal b=$2\nlocal c=$3\n# Diese Funktion berechnet den Sinus des kleineren spitzen Winkels in einem pythagoreischen Tripel (a, b, c).\n# Sie gibt den Sinuswert im gekürzten Bruchformat aus.\n# Das pythagoreische Tripel wird als drei positive ganze Zahlen angegeben, die die Seiten eines rechtwinkligen Dreiecks darstellen.\n# Die Funktion geht davon aus, dass die Eingabezahlen ein gültiges pythagoreisches Tripel bilden.\n# Beispielverwendung:\n# >>> calculate_sine 3 5 4\n# 3/5\n# >>> calculate_sine 5 12 13\n# 5/13\n# >>> calculate_sine 8 15 17\n# 8/17",
      "ha": "#!/bin/bash\ncalculate_sine() {\nlocal a=$1\nlocal b=$2\nlocal c=$3\n# Wannan aiki yana lissafin sine na ƙaramin kusurwar mai kaifi a cikin Pythagorean triplet (a, b, c).\n# Yana fitar da ƙimar sine a cikin tsarin ragi na kason.\n# Ana bayar da Pythagorean triplet a matsayin lambobi guda uku masu kyau, waɗanda ke wakiltar sassan alwatika mai kusurwa madaidaiciya.\n# Aikin yana ɗauka cewa lambobin da aka shigar suna samar da ingantaccen Pythagorean triplet.\n# Misalin Amfani:\n# >>> calculate_sine 3 5 4\n# 3/5\n# >>> calculate_sine 5 12 13\n# 5/13\n# >>> calculate_sine 8 15 17\n# 8/17",
      "hi": "#!/bin/bash\ncalculate_sine() {\nlocal a=$1\nlocal b=$2\nlocal c=$3\n# यह फ़ंक्शन एक पाइथागोरियन ट्रिपलेट (a, b, c) में छोटे तीव्र कोण का साइन गणना करता है।\n# यह साइन मान को घटित भिन्न प्रारूप में आउटपुट करता है।\n# पाइथागोरियन ट्रिपलेट को तीन धनात्मक पूर्णांकों के रूप में प्रदान किया जाता है, जो एक समकोण त्रिभुज की भुजाओं का प्रतिनिधित्व करते हैं।\n# फ़ंक्शन मानता है कि इनपुट संख्याएँ एक मान्य पाइथागोरियन ट्रिपलेट बनाती हैं।\n# उदाहरण उपयोग:\n# >>> calculate_sine 3 5 4\n# 3/5\n# >>> calculate_sine 5 12 13\n# 5/13\n# >>> calculate_sine 8 15 17\n# 8/17",
      "hu": "#!/bin/bash\ncalculate_sine() {\nlocal a=$1\nlocal b=$2\nlocal c=$3\n# Ez a függvény kiszámítja a kisebb hegyesszög szinuszát egy Pitagoraszi hármasban (a, b, c).\n# A szinusz értékét egyszerűsített tört formátumban adja meg.\n# A Pitagoraszi hármast három pozitív egész számként adjuk meg, amelyek egy derékszögű háromszög oldalait képviselik.\n# A függvény feltételezi, hogy a bemeneti számok érvényes Pitagoraszi hármast alkotnak.\n# Példa használat:\n# >>> calculate_sine 3 5 4\n# 3/5\n# >>> calculate_sine 5 12 13\n# 5/13\n# >>> calculate_sine 8 15 17\n# 8/17"
    },
    "prompt_bertscore": {
      "sq": "0.9693122020212529",
      "hy": "0.9542468821412807",
      "bn": "0.9785806928611028",
      "bg": "0.9738042280883569",
      "zh": "0.9693467637075529",
      "fr": "0.9783546514874851",
      "de": "0.9768077180799855",
      "ha": "0.9771874993685241",
      "hi": "0.9800130165387454",
      "hu": "0.9645124974939259"
    },
    "canonical_solution": "local -a sides=($(echo -e \"$a\\n$b\\n$c\" | sort -n))\nlocal opposite=${sides[0]} # Smallest side, opposite to the smaller acute angle\nlocal hypotenuse=${sides[2]} # Largest side, the hypotenuse\n\n# Function to calculate GCD (Greatest Common Divisor)\ngcd() {\nlocal x=$1\nlocal y=$2\nwhile [[ $y -ne 0 ]]; do\nlocal temp=$y\ny=$((x % y))\nx=$temp\ndone\necho $x\n}\n\n# Calculate GCD of opposite and hypotenuse\nlocal common_divisor=$(gcd $opposite $hypotenuse)\n\n# Calculate reduced fraction\nlocal numerator=$((opposite / common_divisor))\nlocal denominator=$((hypotenuse / common_divisor))\n\necho \"$numerator/$denominator\"\n}",
    "instruction": {
      "en": "Write a Shell function `calculate_sine() {\nlocal a=$1\nlocal b=$2\nlocal c=$3\n` to solve the following problem:\nThis function calculates the sine of the smaller acute angle in a Pythagorean triplet (a, b, c).\nIt outputs the sine value in reduced fraction format.\nThe Pythagorean triplet is provided as three positive integers, which represent the sides of a right-angled triangle.\nThe function assumes that the input numbers form a valid Pythagorean triplet.\nExample Usage:\n>>> calculate_sine 3 5 4\n3/5\n>>> calculate_sine 5 12 13\n5/13\n>>> calculate_sine 8 15 17\n8/17",
      "sq": "Shkruani një funksion Shell `calculate_sine() {\nlocal a=$1\nlocal b=$2\nlocal c=$3\n` për të zgjidhur problemin e mëposhtëm:\nKy funksion llogarit sinusin e këndit akut më të vogël në një treshe Pitagoriane (a, b, c).\nAi jep vlerën e sinusit në formatin e thyesës së reduktuar.\nTresha Pitagoriane jepet si tre numra të plotë pozitivë, të cilët përfaqësojnë anët e një trekëndëshi kënddrejtë.\nFunksioni supozon se numrat e dhënë formojnë një treshe Pitagoriane të vlefshme.\nShembull i Përdorimit:\n>>> calculate_sine 3 5 4\n3/5\n>>> calculate_sine 5 12 13\n5/13\n>>> calculate_sine 8 15 17\n8/17",
      "hy": "Գրեք Shell ֆունկցիա `calculate_sine() {\nlocal a=$1\nlocal b=$2\nlocal c=$3\n` հետևյալ խնդիրը լուծելու համար:\nԱյս ֆունկցիան հաշվում է սուր անկյան սինուսը Պյութագորասյան եռյակ (a, b, c)-ում:\nԱյն արտածում է սինուսի արժեքը կրճատված կոտորակի ձևաչափով:\nՊյութագորասյան եռյակը տրվում է որպես երեք դրական ամբողջ թիվ, որոնք ներկայացնում են ուղղանկյուն եռանկյան կողմերը:\nՖունկցիան ենթադրում է, որ մուտքային թվերը կազմում են վավեր Պյութագորասյան եռյակ:\nՕրինակ օգտագործում:\n>>> calculate_sine 3 5 4\n3/5\n>>> calculate_sine 5 12 13\n5/13\n>>> calculate_sine 8 15 17\n8/17",
      "bn": "Write a Shell function `calculate_sine() {\nlocal a=$1\nlocal b=$2\nlocal c=$3\n` নিম্নলিখিত সমস্যার সমাধানের জন্য:\nএই ফাংশনটি একটি পিথাগোরিয়ান ত্রয়ী (a, b, c) এর ছোট তীক্ষ্ণ কোণের সাইন গণনা করে।\nএটি হ্রাসকৃত ভগ্নাংশ বিন্যাসে সাইন মান আউটপুট করে।\nপিথাগোরিয়ান ত্রয়ীটি তিনটি ধনাত্মক পূর্ণসংখ্যা হিসাবে প্রদান করা হয়, যা একটি সমকোণী ত্রিভুজের বাহুগুলি উপস্থাপন করে।\nফাংশনটি ধরে নেয় যে ইনপুট সংখ্যা একটি বৈধ পিথাগোরিয়ান ত্রয়ী গঠন করে।\nউদাহরণ ব্যবহার:\n>>> calculate_sine 3 5 4\n3/5\n>>> calculate_sine 5 12 13\n5/13\n>>> calculate_sine 8 15 17\n8/17",
      "bg": "Напишете Shell функция `calculate_sine() {\nlocal a=$1\nlocal b=$2\nlocal c=$3\n` за решаване на следния проблем:\nТази функция изчислява синуса на по-малкия остър ъгъл в Питагорова тройка (a, b, c).\nТя извежда стойността на синуса в съкратен дробен формат.\nПитагоровата тройка е предоставена като три положителни цели числа, които представляват страните на правоъгълен триъгълник.\nФункцията приема, че входните числа формират валидна Питагорова тройка.\nПример за използване:\n>>> calculate_sine 3 5 4\n3/5\n>>> calculate_sine 5 12 13\n5/13\n>>> calculate_sine 8 15 17\n8/17",
      "zh": "编写一个 Shell 函数 `calculate_sine() {\nlocal a=$1\nlocal b=$2\nlocal c=$3\n` 来解决以下问题：\n此函数计算直角三角形中较小锐角的正弦值。\n它以最简分数格式输出正弦值。\n毕达哥拉斯三元组由三个正整数提供，表示直角三角形的边。\n函数假设输入数字形成一个有效的毕达哥拉斯三元组。\n示例用法：\n>>> calculate_sine 3 5 4\n3/5\n>>> calculate_sine 5 12 13\n5/13\n>>> calculate_sine 8 15 17\n8/17",
      "fr": "Écrire une fonction Shell `calculate_sine() {\nlocal a=$1\nlocal b=$2\nlocal c=$3\n` pour résoudre le problème suivant :\nCette fonction calcule le sinus du plus petit angle aigu dans un triplet pythagoricien (a, b, c).\nElle affiche la valeur du sinus sous forme de fraction réduite.\nLe triplet pythagoricien est fourni sous forme de trois entiers positifs, qui représentent les côtés d'un triangle rectangle.\nLa fonction suppose que les nombres d'entrée forment un triplet pythagoricien valide.\nExemple d'utilisation :\n>>> calculate_sine 3 5 4\n3/5\n>>> calculate_sine 5 12 13\n5/13\n>>> calculate_sine 8 15 17\n8/17",
      "de": "Schreiben Sie eine Shell-Funktion `calculate_sine() {\nlocal a=$1\nlocal b=$2\nlocal c=$3\n`, um das folgende Problem zu lösen:\nDiese Funktion berechnet den Sinus des kleineren spitzen Winkels in einem pythagoreischen Tripel (a, b, c).\nSie gibt den Sinuswert im gekürzten Bruchformat aus.\nDas pythagoreische Tripel wird als drei positive ganze Zahlen angegeben, die die Seiten eines rechtwinkligen Dreiecks darstellen.\nDie Funktion geht davon aus, dass die Eingabezahlen ein gültiges pythagoreisches Tripel bilden.\nBeispielverwendung:\n>>> calculate_sine 3 5 4\n3/5\n>>> calculate_sine 5 12 13\n5/13\n>>> calculate_sine 8 15 17\n8/17",
      "ha": "Rubuta aikin Shell `calculate_sine() {\nlocal a=$1\nlocal b=$2\nlocal c=$3\n` don warware matsalar mai zuwa:\nWannan aikin yana lissafin sine na ƙaramin kusurwar mai kaifi a cikin triplet na Pythagorean (a, b, c).\nYana fitar da ƙimar sine a cikin tsarin ƙananan ƙima.\nAna bayar da triplet na Pythagorean a matsayin lambobi guda uku masu kyau, waɗanda ke wakiltar gefuna na kusurwar dama a cikin alwatika.\nAikin yana ɗauka cewa lambobin shigarwa suna samar da ingantaccen triplet na Pythagorean.\nMisalin Amfani:\n>>> calculate_sine 3 5 4\n3/5\n>>> calculate_sine 5 12 13\n5/13\n>>> calculate_sine 8 15 17\n8/17",
      "hi": "Write a Shell function `calculate_sine() {\nlocal a=$1\nlocal b=$2\nlocal c=$3\n` निम्नलिखित समस्या को हल करने के लिए:\nयह फ़ंक्शन एक पाइथागोरियन ट्रिपलेट (a, b, c) में छोटे तीव्र कोण का साइन गणना करता है।\nयह साइन मान को घटे हुए भिन्न प्रारूप में आउटपुट करता है।\nपाइथागोरियन ट्रिपलेट तीन धनात्मक पूर्णांकों के रूप में दिया गया है, जो एक समकोण त्रिभुज के भुजाओं का प्रतिनिधित्व करते हैं।\nफ़ंक्शन मानता है कि इनपुट संख्याएँ एक मान्य पाइथागोरियन ट्रिपलेट बनाती हैं।\nउदाहरण उपयोग:\n>>> calculate_sine 3 5 4\n3/5\n>>> calculate_sine 5 12 13\n5/13\n>>> calculate_sine 8 15 17\n8/17",
      "hu": "Írj egy Shell függvényt `calculate_sine() {\nlocal a=$1\nlocal b=$2\nlocal c=$3\n` a következő probléma megoldására:\nEz a függvény kiszámítja a kisebb hegyesszög szinuszát egy Pitagoraszi számhármasban (a, b, c).\nA szinusz értékét egyszerűsített tört formátumban adja meg.\nA Pitagoraszi számhármast három pozitív egész számként adják meg, amelyek egy derékszögű háromszög oldalait képviselik.\nA függvény feltételezi, hogy a bemeneti számok érvényes Pitagoraszi számhármast alkotnak.\nPélda használat:\n>>> calculate_sine 3 5 4\n3/5\n>>> calculate_sine 5 12 13\n5/13\n>>> calculate_sine 8 15 17\n8/17"
    },
    "instruction_bertscore": {
      "sq": "0.9686303039231601",
      "hy": "0.9768722729538217",
      "bn": "0.9795978790423825",
      "bg": "0.9716874241176681",
      "zh": "0.9464270026703182",
      "fr": "0.976088080209496",
      "de": "0.9730863778912968",
      "ha": "0.9757853675087989",
      "hi": "0.980317914173634",
      "hu": "0.9624374059032543"
    },
    "level": "hard",
    "test": "test_calculate_sine() {\n[[ $(calculate_sine 3 5 4) == \"3/5\" ]] || { echo \"Test 1 failed\"; exit 1; }\n[[ $(calculate_sine 5 12 13) == \"5/13\" ]] || { echo \"Test 2 failed\"; exit 1; }\n[[ $(calculate_sine 8 15 17) == \"8/17\" ]] || { echo \"Test 3 failed\"; exit 1; }\n[[ $(calculate_sine 7 24 25) == \"7/25\" ]] || { echo \"Test 4 failed\"; exit 1; }\n[[ $(calculate_sine 9 40 41) == \"9/41\" ]] || { echo \"Test 5 failed\"; exit 1; }\n}\n\ntest_calculate_sine",
    "entry_point": "calculate_sine",
    "signature": "calculate_sine() {\nlocal a=$1\nlocal b=$2\nlocal c=$3\n",
    "docstring": {
      "en": "This function calculates the sine of the smaller acute angle in a Pythagorean triplet (a, b, c).\nIt outputs the sine value in reduced fraction format.\nThe Pythagorean triplet is provided as three positive integers, which represent the sides of a right-angled triangle.\nThe function assumes that the input numbers form a valid Pythagorean triplet.\nExample Usage:\n>>> calculate_sine 3 5 4\n3/5\n>>> calculate_sine 5 12 13\n5/13\n>>> calculate_sine 8 15 17\n8/17",
      "sq": "Kjo funksion llogarit sinusin e këndit të vogël akut në një treshe Pitagoriane (a, b, c).\nAi jep vlerën e sinusit në formatin e thyesës së reduktuar.\nTresha Pitagoriane jepet si tre numra të plotë pozitivë, të cilët përfaqësojnë anët e një trekëndëshi kënddrejtë.\nFunksioni supozon se numrat e futur formojnë një treshe Pitagoriane të vlefshme.\nShembull Përdorimi:\n>>> calculate_sine 3 5 4\n3/5\n>>> calculate_sine 5 12 13\n5/13\n>>> calculate_sine 8 15 17\n8/17",
      "hy": "Այս ֆունկցիան հաշվում է Պյութագորասյան եռյակի (a, b, c) փոքր սուր անկյան սինուսը:\nԱյն արդյունք է տալիս սինուսի արժեքը կրճատված կոտորակի ձևաչափով:\nՊյութագորասյան եռյակը տրվում է որպես երեք դրական ամբողջ թիվ, որոնք ներկայացնում են ուղիղանկյուն եռանկյան կողմերը:\nՖունկցիան ենթադրում է, որ մուտքային թվերը կազմում են վավեր Պյութագորասյան եռյակ:\nՕրինակ օգտագործում:\n>>> calculate_sine 3 5 4\n3/5\n>>> calculate_sine 5 12 13\n5/13\n>>> calculate_sine 8 15 17\n8/17",
      "bn": "এই ফাংশনটি একটি পিথাগোরিয়ান ট্রিপলেটের (a, b, c) ছোট তীক্ষ্ণ কোণের সাইন গণনা করে। এটি হ্রাসকৃত ভগ্নাংশ বিন্যাসে সাইন মান আউটপুট করে। পিথাগোরিয়ান ট্রিপলেটটি তিনটি ধনাত্মক পূর্ণসংখ্যা হিসাবে প্রদান করা হয়, যা একটি সমকোণী ত্রিভুজের বাহুগুলি উপস্থাপন করে। ফাংশনটি ধরে নেয় যে ইনপুট সংখ্যা একটি বৈধ পিথাগোরিয়ান ট্রিপলেট গঠন করে।\n\nব্যবহারের উদাহরণ:\n>>> calculate_sine 3 5 4\n3/5\n>>> calculate_sine 5 12 13\n5/13\n>>> calculate_sine 8 15 17\n8/17",
      "bg": "Тази функция изчислява синуса на по-малкия остър ъгъл в Питагорова тройка (a, b, c). \nТя извежда стойността на синуса в намален дробен формат. \nПитагоровата тройка се предоставя като три положителни цели числа, които представляват страните на правоъгълен триъгълник. \nФункцията приема, че въведените числа образуват валидна Питагорова тройка.\nПример за използване:\n>>> calculate_sine 3 5 4\n3/5\n>>> calculate_sine 5 12 13\n5/13\n>>> calculate_sine 8 15 17\n8/17",
      "zh": "该函数计算毕达哥拉斯三元组 (a, b, c) 中较小锐角的正弦值。\n它以最简分数形式输出正弦值。\n毕达哥拉斯三元组由三个正整数提供，代表直角三角形的边。\n该函数假设输入数字构成一个有效的毕达哥拉斯三元组。\n示例用法：\n>>> calculate_sine 3 5 4\n3/5\n>>> calculate_sine 5 12 13\n5/13\n>>> calculate_sine 8 15 17\n8/17",
      "fr": "Cette fonction calcule le sinus du plus petit angle aigu dans un triplet pythagoricien (a, b, c).\nElle renvoie la valeur du sinus sous forme de fraction réduite.\nLe triplet pythagoricien est fourni sous forme de trois entiers positifs, qui représentent les côtés d'un triangle rectangle.\nLa fonction suppose que les nombres d'entrée forment un triplet pythagoricien valide.\nExemple d'utilisation :\n>>> calculate_sine 3 5 4\n3/5\n>>> calculate_sine 5 12 13\n5/13\n>>> calculate_sine 8 15 17\n8/17",
      "de": "Diese Funktion berechnet den Sinus des kleineren spitzen Winkels in einem pythagoreischen Tripel (a, b, c).\nSie gibt den Sinuswert im gekürzten Bruchformat aus.\nDas pythagoreische Tripel wird als drei positive ganze Zahlen angegeben, die die Seiten eines rechtwinkligen Dreiecks darstellen.\nDie Funktion geht davon aus, dass die Eingabezahlen ein gültiges pythagoreisches Tripel bilden.\nBeispielverwendung:\n>>> calculate_sine 3 5 4\n3/5\n>>> calculate_sine 5 12 13\n5/13\n>>> calculate_sine 8 15 17\n8/17",
      "ha": "Wannan aikin yana lissafin sine na ƙaramin kusurwar mai kaifi a cikin triplet na Pythagoras (a, b, c). \nYana fitar da ƙimar sine a cikin tsarin ragin kason. \nAna bayar da triplet na Pythagoras a matsayin lambobi guda uku masu kyau, waɗanda ke wakiltar sassan kusurwar dama na alwatika. \nAikin yana ɗauka cewa lambobin shigarwa suna samar da ingantaccen triplet na Pythagoras. \nMisalin Amfani:\n>>> calculate_sine 3 5 4\n3/5\n>>> calculate_sine 5 12 13\n5/13\n>>> calculate_sine 8 15 17\n8/17",
      "hi": "यह फ़ंक्शन एक पाइथागोरियन ट्रिपलेट (a, b, c) में छोटे तीव्र कोण का साइन गणना करता है।\nयह साइन मान को घटाए गए भिन्न प्रारूप में आउटपुट करता है।\nपाइथागोरियन ट्रिपलेट को तीन धनात्मक पूर्णांकों के रूप में प्रदान किया जाता है, जो एक समकोण त्रिभुज के भुजाओं का प्रतिनिधित्व करते हैं।\nफ़ंक्शन यह मानता है कि इनपुट संख्याएँ एक मान्य पाइथागोरियन ट्रिपलेट बनाती हैं।\nउदाहरण उपयोग:\n>>> calculate_sine 3 5 4\n3/5\n>>> calculate_sine 5 12 13\n5/13\n>>> calculate_sine 8 15 17\n8/17",
      "hu": "Ez a függvény kiszámítja a kisebb hegyesszög szinuszát egy Pitagoraszi számhármasban (a, b, c).  \nA szinusz értékét egyszerűsített tört formátumban adja meg.  \nA Pitagoraszi számhármast három pozitív egész számként adják meg, amelyek egy derékszögű háromszög oldalait képviselik.  \nA függvény feltételezi, hogy a bemeneti számok egy érvényes Pitagoraszi számhármast alkotnak.  \nPélda használat:  \n>>> calculate_sine 3 5 4  \n3/5  \n>>> calculate_sine 5 12 13  \n5/13  \n>>> calculate_sine 8 15 17  \n8/17  "
    },
    "docstring_bertscore": {
      "sq": "0.9638160993780175",
      "hy": "0.9529001681578642",
      "bn": "0.976156210430191",
      "bg": "0.9679315222426794",
      "zh": "0.9601261427895325",
      "fr": "0.9706239570576073",
      "de": "0.9700338261955527",
      "ha": "0.9802861333126683",
      "hi": "0.9825870676465766",
      "hu": "0.9573753106425802"
    }
  },
  {
    "task_id": "Shell/25",
    "prompt": {
      "en": "#!/bin/bash\ncalculate_minimum_cost() {\nlocal n=$1\nlocal -a pack1=($2)\nlocal -a pack2=($3)\nlocal -a pack3=($4)\n# This function calculates the minimum cost needed to buy at least 'n' pencils,\n# where pencils are available in three different packaging options, each with its own quantity and price.\n# The function does not allow breaking the packaging, so it may require buying more pencils than 'n'.\n# Each packaging option is given in the format 'quantity price'.\n# Input: Number of pencils needed and three packaging options.\n# Output: Minimum cost to buy at least 'n' pencils.\n# Example Usage:\n# >>> calculate_minimum_cost 57 \"2 2\" \"50 30\" \"30 27\"\n# 54\n# >>> calculate_minimum_cost 100 \"10 5\" \"20 8\" \"50 20\"\n# 40\n# >>> calculate_minimum_cost 45 \"5 3\" \"15 10\" \"25 17\"\n# 18",
      "sq": "#!/bin/bash\ncalculate_minimum_cost() {\nlocal n=$1\nlocal -a pack1=($2)\nlocal -a pack2=($3)\nlocal -a pack3=($4)\n# Kjo funksion llogarit koston minimale të nevojshme për të blerë të paktën 'n' lapsa,\n# ku lapsat janë të disponueshëm në tre opsione paketimi të ndryshme, secila me sasinë dhe çmimin e vet.\n# Funksioni nuk lejon thyerjen e paketimit, kështu që mund të kërkojë blerjen e më shumë lapsave se 'n'.\n# Çdo opsion paketimi jepet në formatin 'sasi çmim'.\n# Hyrja: Numri i lapsave të nevojshëm dhe tre opsione paketimi.\n# Dalja: Kosto minimale për të blerë të paktën 'n' lapsa.\n# Shembull Përdorimi:\n# >>> calculate_minimum_cost 57 \"2 2\" \"50 30\" \"30 27\"\n# 54\n# >>> calculate_minimum_cost 100 \"10 5\" \"20 8\" \"50 20\"\n# 40\n# >>> calculate_minimum_cost 45 \"5 3\" \"15 10\" \"25 17\"\n# 18",
      "hy": "#!/bin/bash\ncalculate_minimum_cost() {\nlocal n=$1\nlocal -a pack1=($2)\nlocal -a pack2=($3)\nlocal -a pack3=($4)\n# Այս ֆունկցիան հաշվում է նվազագույն արժեքը, որը անհրաժեշտ է գնել առնվազն 'n' մատիտներ,\n# որտեղ մատիտները հասանելի են երեք տարբեր փաթեթավորման տարբերակներով, յուրաքանչյուրը իր քանակով և գնով:\n# Ֆունկցիան թույլ չի տալիս փաթեթավորումը կոտրել, ուստի հնարավոր է, որ անհրաժեշտ լինի գնել ավելի շատ մատիտներ, քան 'n':\n# Յուրաքանչյուր փաթեթավորման տարբերակ տրվում է 'քանակ գին' ձևաչափով:\n# Մուտքագրում: Անհրաժեշտ մատիտների քանակը և երեք փաթեթավորման տարբերակներ:\n# Ելք: Նվազագույն արժեքը գնել առնվազն 'n' մատիտներ:\n# Օրինակ օգտագործում:\n# >>> calculate_minimum_cost 57 \"2 2\" \"50 30\" \"30 27\"\n# 54\n# >>> calculate_minimum_cost 100 \"10 5\" \"20 8\" \"50 20\"\n# 40\n# >>> calculate_minimum_cost 45 \"5 3\" \"15 10\" \"25 17\"\n# 18",
      "bn": "#!/bin/bash\ncalculate_minimum_cost() {\nlocal n=$1\nlocal -a pack1=($2)\nlocal -a pack2=($3)\nlocal -a pack3=($4)\n# এই ফাংশনটি কমপক্ষে 'n' টি পেন্সিল কেনার জন্য প্রয়োজনীয় সর্বনিম্ন খরচ হিসাব করে,\n# যেখানে পেন্সিল তিনটি ভিন্ন প্যাকেজিং বিকল্পে উপলব্ধ, প্রতিটি নিজস্ব পরিমাণ এবং মূল্যের সাথে।\n# ফাংশনটি প্যাকেজিং ভাঙতে দেয় না, তাই এটি 'n' এর চেয়ে বেশি পেন্সিল কিনতে প্রয়োজন হতে পারে।\n# প্রতিটি প্যাকেজিং বিকল্প 'পরিমাণ মূল্য' ফরম্যাটে দেওয়া হয়।\n# ইনপুট: প্রয়োজনীয় পেন্সিলের সংখ্যা এবং তিনটি প্যাকেজিং বিকল্প।\n# আউটপুট: কমপক্ষে 'n' পেন্সিল কেনার জন্য সর্বনিম্ন খরচ।\n# উদাহরণ ব্যবহার:\n# >>> calculate_minimum_cost 57 \"2 2\" \"50 30\" \"30 27\"\n# 54\n# >>> calculate_minimum_cost 100 \"10 5\" \"20 8\" \"50 20\"\n# 40\n# >>> calculate_minimum_cost 45 \"5 3\" \"15 10\" \"25 17\"\n# 18",
      "bg": "#!/bin/bash\ncalculate_minimum_cost() {\nlocal n=$1\nlocal -a pack1=($2)\nlocal -a pack2=($3)\nlocal -a pack3=($4)\n# Тази функция изчислява минималната цена, необходима за закупуване на поне 'n' молива,\n# където моливите са налични в три различни опции за опаковане, всяка със собствено количество и цена.\n# Функцията не позволява разчупване на опаковката, така че може да се наложи закупуване на повече моливи от 'n'.\n# Всяка опция за опаковане е дадена във формат 'количество цена'.\n# Вход: Брой необходими моливи и три опции за опаковане.\n# Изход: Минимална цена за закупуване на поне 'n' молива.\n# Пример за използване:\n# >>> calculate_minimum_cost 57 \"2 2\" \"50 30\" \"30 27\"\n# 54\n# >>> calculate_minimum_cost 100 \"10 5\" \"20 8\" \"50 20\"\n# 40\n# >>> calculate_minimum_cost 45 \"5 3\" \"15 10\" \"25 17\"\n# 18",
      "zh": "#!/bin/bash\ncalculate_minimum_cost() {\nlocal n=$1\nlocal -a pack1=($2)\nlocal -a pack2=($3)\nlocal -a pack3=($4)\n# 此函数计算购买至少 'n' 支铅笔所需的最低成本，\n# 铅笔有三种不同的包装选项，每种选项有其对应的数量和价格。\n# 该函数不允许拆分包装，因此可能需要购买多于 'n' 支的铅笔。\n# 每种包装选项的格式为 '数量 价格'。\n# 输入：所需铅笔数量和三种包装选项。\n# 输出：购买至少 'n' 支铅笔的最低成本。\n# 示例用法：\n# >>> calculate_minimum_cost 57 \"2 2\" \"50 30\" \"30 27\"\n# 54\n# >>> calculate_minimum_cost 100 \"10 5\" \"20 8\" \"50 20\"\n# 40\n# >>> calculate_minimum_cost 45 \"5 3\" \"15 10\" \"25 17\"\n# 18",
      "fr": "#!/bin/bash\ncalculate_minimum_cost() {\nlocal n=$1\nlocal -a pack1=($2)\nlocal -a pack2=($3)\nlocal -a pack3=($4)\n# Cette fonction calcule le coût minimum nécessaire pour acheter au moins 'n' crayons,\n# où les crayons sont disponibles en trois options d'emballage différentes, chacune avec sa propre quantité et son prix.\n# La fonction n'autorise pas la rupture de l'emballage, il peut donc être nécessaire d'acheter plus de crayons que 'n'.\n# Chaque option d'emballage est donnée au format 'quantité prix'.\n# Entrée : Nombre de crayons nécessaires et trois options d'emballage.\n# Sortie : Coût minimum pour acheter au moins 'n' crayons.\n# Exemple d'utilisation :\n# >>> calculate_minimum_cost 57 \"2 2\" \"50 30\" \"30 27\"\n# 54\n# >>> calculate_minimum_cost 100 \"10 5\" \"20 8\" \"50 20\"\n# 40\n# >>> calculate_minimum_cost 45 \"5 3\" \"15 10\" \"25 17\"\n# 18",
      "de": "#!/bin/bash\ncalculate_minimum_cost() {\nlocal n=$1\nlocal -a pack1=($2)\nlocal -a pack2=($3)\nlocal -a pack3=($4)\n# Diese Funktion berechnet die minimalen Kosten, die benötigt werden, um mindestens 'n' Bleistifte zu kaufen,\n# wobei Bleistifte in drei verschiedenen Verpackungsoptionen erhältlich sind, jede mit eigener Menge und Preis.\n# Die Funktion erlaubt es nicht, die Verpackung zu brechen, daher kann es erforderlich sein, mehr Bleistifte als 'n' zu kaufen.\n# Jede Verpackungsoption wird im Format 'Menge Preis' angegeben.\n# Eingabe: Anzahl der benötigten Bleistifte und drei Verpackungsoptionen.\n# Ausgabe: Minimale Kosten, um mindestens 'n' Bleistifte zu kaufen.\n# Beispielverwendung:\n# >>> calculate_minimum_cost 57 \"2 2\" \"50 30\" \"30 27\"\n# 54\n# >>> calculate_minimum_cost 100 \"10 5\" \"20 8\" \"50 20\"\n# 40\n# >>> calculate_minimum_cost 45 \"5 3\" \"15 10\" \"25 17\"\n# 18",
      "ha": "#!/bin/bash\ncalculate_minimum_cost() {\nlocal n=$1\nlocal -a pack1=($2)\nlocal -a pack2=($3)\nlocal -a pack3=($4)\n# Wannan aikin yana lissafin mafi ƙarancin kuɗi da ake buƙata don siyan akalla 'n' fensir,\n# inda fensir suna samuwa a cikin zaɓuɓɓukan marufi guda uku daban-daban, kowanne yana da adadi da farashinsa.\n# Aikin ba ya ba da damar karya marufi, don haka yana iya buƙatar siyan fensir fiye da 'n'.\n# Kowane zaɓin marufi an bayar dashi a cikin tsarin 'adadi farashi'.\n# Shigarwa: Yawan fensir da ake buƙata da zaɓuɓɓukan marufi guda uku.\n# Fitarwa: Mafi ƙarancin kuɗi don siyan akalla 'n' fensir.\n# Misalin Amfani:\n# >>> calculate_minimum_cost 57 \"2 2\" \"50 30\" \"30 27\"\n# 54\n# >>> calculate_minimum_cost 100 \"10 5\" \"20 8\" \"50 20\"\n# 40\n# >>> calculate_minimum_cost 45 \"5 3\" \"15 10\" \"25 17\"\n# 18",
      "hi": "#!/bin/bash\ncalculate_minimum_cost() {\nlocal n=$1\nlocal -a pack1=($2)\nlocal -a pack2=($3)\nlocal -a pack3=($4)\n# यह फ़ंक्शन कम से कम 'n' पेंसिल खरीदने के लिए आवश्यक न्यूनतम लागत की गणना करता है,\n# जहाँ पेंसिल तीन अलग-अलग पैकेजिंग विकल्पों में उपलब्ध हैं, प्रत्येक का अपना मात्रा और मूल्य है।\n# फ़ंक्शन पैकेजिंग को तोड़ने की अनुमति नहीं देता, इसलिए यह 'n' से अधिक पेंसिल खरीदने की आवश्यकता हो सकती है।\n# प्रत्येक पैकेजिंग विकल्प 'मात्रा मूल्य' के प्रारूप में दिया गया है।\n# इनपुट: आवश्यक पेंसिलों की संख्या और तीन पैकेजिंग विकल्प।\n# आउटपुट: कम से कम 'n' पेंसिल खरीदने की न्यूनतम लागत।\n# उदाहरण उपयोग:\n# >>> calculate_minimum_cost 57 \"2 2\" \"50 30\" \"30 27\"\n# 54\n# >>> calculate_minimum_cost 100 \"10 5\" \"20 8\" \"50 20\"\n# 40\n# >>> calculate_minimum_cost 45 \"5 3\" \"15 10\" \"25 17\"\n# 18",
      "hu": "#!/bin/bash\ncalculate_minimum_cost() {\nlocal n=$1\nlocal -a pack1=($2)\nlocal -a pack2=($3)\nlocal -a pack3=($4)\n# Ez a függvény kiszámítja a minimális költséget, amely szükséges legalább 'n' ceruza megvásárlásához,\n# ahol a ceruzák három különböző csomagolási opcióban érhetők el, mindegyik saját mennyiséggel és árral.\n# A függvény nem engedi a csomagolás bontását, így előfordulhat, hogy több ceruzát kell vásárolni, mint 'n'.\n# Minden csomagolási opció a 'mennyiség ár' formátumban van megadva.\n# Bemenet: Szükséges ceruzák száma és három csomagolási opció.\n# Kimenet: Minimális költség legalább 'n' ceruza megvásárlásához.\n# Példa használat:\n# >>> calculate_minimum_cost 57 \"2 2\" \"50 30\" \"30 27\"\n# 54\n# >>> calculate_minimum_cost 100 \"10 5\" \"20 8\" \"50 20\"\n# 40\n# >>> calculate_minimum_cost 45 \"5 3\" \"15 10\" \"25 17\"\n# 18"
    },
    "prompt_bertscore": {
      "sq": "0.9890209043186776",
      "hy": "0.9710863685846565",
      "bn": "0.9914106264329083",
      "bg": "0.9832928013903934",
      "zh": "0.9563056860407073",
      "fr": "0.9862438529614288",
      "de": "0.987457484589552",
      "ha": "0.9864480449931327",
      "hi": "0.9819981285668081",
      "hu": "0.9771453897277448"
    },
    "canonical_solution": "local min_cost=1000000 # Arbitrary large number\n\n# Function to calculate cost\ncalculate_cost() {\nlocal quantity=$1\nlocal price=$2\nlocal cost=$(( (n + quantity - 1) / quantity * price ))\nif (( cost < min_cost )); then\nmin_cost=$cost\nfi\n}\n\n# Calculate cost for each packaging option\ncalculate_cost ${pack1[0]} ${pack1[1]}\ncalculate_cost ${pack2[0]} ${pack2[1]}\ncalculate_cost ${pack3[0]} ${pack3[1]}\n\necho $min_cost\n}",
    "instruction": {
      "en": "Write a Shell function `calculate_minimum_cost() {\nlocal n=$1\nlocal -a pack1=($2)\nlocal -a pack2=($3)\nlocal -a pack3=($4)\n` to solve the following problem:\nThis function calculates the minimum cost needed to buy at least 'n' pencils,\nwhere pencils are available in three different packaging options, each with its own quantity and price.\nThe function does not allow breaking the packaging, so it may require buying more pencils than 'n'.\nEach packaging option is given in the format 'quantity price'.\nInput: Number of pencils needed and three packaging options.\nOutput: Minimum cost to buy at least 'n' pencils.\nExample Usage:\n>>> calculate_minimum_cost 57 \"2 2\" \"50 30\" \"30 27\"\n54\n>>> calculate_minimum_cost 100 \"10 5\" \"20 8\" \"50 20\"\n40\n>>> calculate_minimum_cost 45 \"5 3\" \"15 10\" \"25 17\"\n18",
      "sq": "Shkruani një funksion Shell `calculate_minimum_cost() {\nlocal n=$1\nlocal -a pack1=($2)\nlocal -a pack2=($3)\nlocal -a pack3=($4)\n` për të zgjidhur problemin e mëposhtëm:\nKy funksion llogarit koston minimale të nevojshme për të blerë të paktën 'n' lapsa,\nku lapsat janë të disponueshme në tre opsione paketimi të ndryshme, secila me sasinë dhe çmimin e vet.\nFunksioni nuk lejon thyerjen e paketimit, kështu që mund të kërkojë blerjen e më shumë lapsave se 'n'.\nÇdo opsion paketimi jepet në formatin 'sasi çmim'.\nInput: Numri i lapsave të nevojshëm dhe tre opsione paketimi.\nOutput: Kostoja minimale për të blerë të paktën 'n' lapsa.\nShembull i Përdorimit:\n>>> calculate_minimum_cost 57 \"2 2\" \"50 30\" \"30 27\"\n54\n>>> calculate_minimum_cost 100 \"10 5\" \"20 8\" \"50 20\"\n40\n>>> calculate_minimum_cost 45 \"5 3\" \"15 10\" \"25 17\"\n18",
      "hy": "Գրեք Shell ֆունկցիա `calculate_minimum_cost() {\nlocal n=$1\nlocal -a pack1=($2)\nlocal -a pack2=($3)\nlocal -a pack3=($4)\n` հետևյալ խնդիրը լուծելու համար:\nԱյս ֆունկցիան հաշվարկում է նվազագույն արժեքը, որը անհրաժեշտ է գոնե 'n' մատիտ գնելու համար,\nորտեղ մատիտները հասանելի են երեք տարբեր փաթեթավորման տարբերակներով, յուրաքանչյուրը իր քանակով և գնով:\nՖունկցիան թույլ չի տալիս փաթեթավորումը կոտրել, ուստի հնարավոր է, որ անհրաժեշտ լինի գնել ավելի շատ մատիտներ, քան 'n':\nՅուրաքանչյուր փաթեթավորման տարբերակ տրվում է 'քանակ գին' ձևաչափով:\nՄուտք: Անհրաժեշտ մատիտների քանակը և երեք փաթեթավորման տարբերակներ:\nԵլք: Նվազագույն արժեքը գոնե 'n' մատիտ գնելու համար:\nՕրինակ օգտագործում:\n>>> calculate_minimum_cost 57 \"2 2\" \"50 30\" \"30 27\"\n54\n>>> calculate_minimum_cost 100 \"10 5\" \"20 8\" \"50 20\"\n40\n>>> calculate_minimum_cost 45 \"5 3\" \"15 10\" \"25 17\"\n18",
      "bn": "Write a Shell function `calculate_minimum_cost() {\nlocal n=$1\nlocal -a pack1=($2)\nlocal -a pack2=($3)\nlocal -a pack3=($4)\n` নিম্নলিখিত সমস্যার সমাধান করতে:\nএই ফাংশনটি কমপক্ষে 'n' পেন্সিল কিনতে প্রয়োজনীয় সর্বনিম্ন খরচ হিসাব করে,\nযেখানে পেন্সিল তিনটি ভিন্ন প্যাকেজিং বিকল্পে উপলব্ধ, প্রতিটি নিজস্ব পরিমাণ এবং মূল্যের সাথে।\nফাংশনটি প্যাকেজিং ভাঙার অনুমতি দেয় না, তাই এটি 'n' এর চেয়ে বেশি পেন্সিল কিনতে প্রয়োজন হতে পারে।\nপ্রতিটি প্যাকেজিং বিকল্প 'পরিমাণ মূল্য' ফরম্যাটে দেওয়া হয়।\nইনপুট: প্রয়োজনীয় পেন্সিলের সংখ্যা এবং তিনটি প্যাকেজিং বিকল্প।\nআউটপুট: কমপক্ষে 'n' পেন্সিল কিনতে সর্বনিম্ন খরচ।\nউদাহরণ ব্যবহার:\n>>> calculate_minimum_cost 57 \"2 2\" \"50 30\" \"30 27\"\n54\n>>> calculate_minimum_cost 100 \"10 5\" \"20 8\" \"50 20\"\n40\n>>> calculate_minimum_cost 45 \"5 3\" \"15 10\" \"25 17\"\n18",
      "bg": "Напишете Shell функция `calculate_minimum_cost() {\nlocal n=$1\nlocal -a pack1=($2)\nlocal -a pack2=($3)\nlocal -a pack3=($4)\n` за решаване на следния проблем:\nТази функция изчислява минималната цена, необходима за закупуване на поне 'n' молива,\nкъдето моливите са налични в три различни опции за опаковане, всяка със собствено количество и цена.\nФункцията не позволява разчупване на опаковката, така че може да се наложи закупуване на повече моливи от 'n'.\nВсяка опция за опаковане е дадена във формат 'количество цена'.\nВход: Брой необходими моливи и три опции за опаковане.\nИзход: Минимална цена за закупуване на поне 'n' молива.\nПример за използване:\n>>> calculate_minimum_cost 57 \"2 2\" \"50 30\" \"30 27\"\n54\n>>> calculate_minimum_cost 100 \"10 5\" \"20 8\" \"50 20\"\n40\n>>> calculate_minimum_cost 45 \"5 3\" \"15 10\" \"25 17\"\n18",
      "zh": "编写一个 Shell 函数 `calculate_minimum_cost() {\nlocal n=$1\nlocal -a pack1=($2)\nlocal -a pack2=($3)\nlocal -a pack3=($4)\n` 来解决以下问题：\n此函数计算购买至少 'n' 支铅笔所需的最低成本，\n铅笔有三种不同的包装选项，每种都有自己的数量和价格。\n该函数不允许拆分包装，因此可能需要购买比 'n' 更多的铅笔。\n每个包装选项的格式为 '数量 价格'。\n输入：所需铅笔数量和三个包装选项。\n输出：购买至少 'n' 支铅笔的最低成本。\n示例用法：\n>>> calculate_minimum_cost 57 \"2 2\" \"50 30\" \"30 27\"\n54\n>>> calculate_minimum_cost 100 \"10 5\" \"20 8\" \"50 20\"\n40\n>>> calculate_minimum_cost 45 \"5 3\" \"15 10\" \"25 17\"\n18",
      "fr": "Écrire une fonction Shell `calculate_minimum_cost() {\nlocal n=$1\nlocal -a pack1=($2)\nlocal -a pack2=($3)\nlocal -a pack3=($4)\n` pour résoudre le problème suivant :\nCette fonction calcule le coût minimum nécessaire pour acheter au moins 'n' crayons,\noù les crayons sont disponibles en trois options d'emballage différentes, chacune avec sa propre quantité et son prix.\nLa fonction ne permet pas de casser l'emballage, il peut donc être nécessaire d'acheter plus de crayons que 'n'.\nChaque option d'emballage est donnée au format 'quantité prix'.\nEntrée : Nombre de crayons nécessaires et trois options d'emballage.\nSortie : Coût minimum pour acheter au moins 'n' crayons.\nExemple d'utilisation :\n>>> calculate_minimum_cost 57 \"2 2\" \"50 30\" \"30 27\"\n54\n>>> calculate_minimum_cost 100 \"10 5\" \"20 8\" \"50 20\"\n40\n>>> calculate_minimum_cost 45 \"5 3\" \"15 10\" \"25 17\"\n18",
      "de": "Schreiben Sie eine Shell-Funktion `calculate_minimum_cost() {\nlocal n=$1\nlocal -a pack1=($2)\nlocal -a pack2=($3)\nlocal -a pack3=($4)\n` um das folgende Problem zu lösen:\nDiese Funktion berechnet die minimalen Kosten, die benötigt werden, um mindestens 'n' Bleistifte zu kaufen,\nwobei Bleistifte in drei verschiedenen Verpackungsoptionen erhältlich sind, jede mit ihrer eigenen Menge und ihrem eigenen Preis.\nDie Funktion erlaubt es nicht, die Verpackung zu brechen, sodass es erforderlich sein kann, mehr Bleistifte als 'n' zu kaufen.\nJede Verpackungsoption wird im Format 'Menge Preis' angegeben.\nEingabe: Anzahl der benötigten Bleistifte und drei Verpackungsoptionen.\nAusgabe: Minimale Kosten, um mindestens 'n' Bleistifte zu kaufen.\nBeispielverwendung:\n>>> calculate_minimum_cost 57 \"2 2\" \"50 30\" \"30 27\"\n54\n>>> calculate_minimum_cost 100 \"10 5\" \"20 8\" \"50 20\"\n40\n>>> calculate_minimum_cost 45 \"5 3\" \"15 10\" \"25 17\"\n18",
      "ha": "Rubuta wani aikin Shell `calculate_minimum_cost() {\nlocal n=$1\nlocal -a pack1=($2)\nlocal -a pack2=($3)\nlocal -a pack3=($4)\n` don warware matsalar mai zuwa:\nWannan aikin yana ƙididdige mafi ƙarancin kuɗi da ake buƙata don siyan aƙalla 'n' fensir,\ninda fensir suna samuwa a cikin zaɓuɓɓukan marufi guda uku daban-daban, kowanne yana da adadinsa da farashinsa.\nAikin baya ba da damar karya marufi, don haka yana iya buƙatar siyan fensir fiye da 'n'.\nAna bayar da kowane zaɓin marufi a cikin tsarin 'quantity price'.\nShigarwa: Adadin fensir da ake buƙata da zaɓuɓɓukan marufi uku.\nFitarwa: Mafi ƙarancin kuɗi don siyan aƙalla 'n' fensir.\nMisalin Amfani:\n>>> calculate_minimum_cost 57 \"2 2\" \"50 30\" \"30 27\"\n54\n>>> calculate_minimum_cost 100 \"10 5\" \"20 8\" \"50 20\"\n40\n>>> calculate_minimum_cost 45 \"5 3\" \"15 10\" \"25 17\"\n18",
      "hi": "Write a Shell function `calculate_minimum_cost() {\nlocal n=$1\nlocal -a pack1=($2)\nlocal -a pack2=($3)\nlocal -a pack3=($4)\n` निम्नलिखित समस्या को हल करने के लिए:\nयह फ़ंक्शन कम से कम 'n' पेंसिल खरीदने के लिए आवश्यक न्यूनतम लागत की गणना करता है,\nजहां पेंसिल तीन अलग-अलग पैकेजिंग विकल्पों में उपलब्ध हैं, प्रत्येक का अपना मात्रा और मूल्य है।\nफ़ंक्शन पैकेजिंग को तोड़ने की अनुमति नहीं देता है, इसलिए यह 'n' से अधिक पेंसिल खरीदने की आवश्यकता हो सकती है।\nप्रत्येक पैकेजिंग विकल्प 'मात्रा मूल्य' के प्रारूप में दिया गया है।\nइनपुट: आवश्यक पेंसिल की संख्या और तीन पैकेजिंग विकल्प।\nआउटपुट: कम से कम 'n' पेंसिल खरीदने की न्यूनतम लागत।\nउदाहरण उपयोग:\n>>> calculate_minimum_cost 57 \"2 2\" \"50 30\" \"30 27\"\n54\n>>> calculate_minimum_cost 100 \"10 5\" \"20 8\" \"50 20\"\n40\n>>> calculate_minimum_cost 45 \"5 3\" \"15 10\" \"25 17\"\n18",
      "hu": "Írj egy Shell függvényt `calculate_minimum_cost() {\nlocal n=$1\nlocal -a pack1=($2)\nlocal -a pack2=($3)\nlocal -a pack3=($4)\n`, hogy megoldja a következő problémát:\nEz a függvény kiszámítja a minimális költséget, amely szükséges legalább 'n' ceruza megvásárlásához,\nahol a ceruzák három különböző csomagolási opcióban érhetők el, mindegyik saját mennyiséggel és árral.\nA függvény nem engedi a csomagolás megbontását, így előfordulhat, hogy több ceruzát kell vásárolni, mint 'n'.\nMinden csomagolási opció a következő formátumban van megadva: 'mennyiség ár'.\nBemenet: Szükséges ceruzák száma és három csomagolási opció.\nKimenet: Minimális költség legalább 'n' ceruza megvásárlásához.\nPélda használat:\n>>> calculate_minimum_cost 57 \"2 2\" \"50 30\" \"30 27\"\n54\n>>> calculate_minimum_cost 100 \"10 5\" \"20 8\" \"50 20\"\n40\n>>> calculate_minimum_cost 45 \"5 3\" \"15 10\" \"25 17\"\n18"
    },
    "instruction_bertscore": {
      "sq": "0.991460085397786",
      "hy": "0.9775321230796197",
      "bn": "0.9789425974153484",
      "bg": "0.9834530961078887",
      "zh": "0.9681728581556368",
      "fr": "0.9864400997778913",
      "de": "0.9874898613416607",
      "ha": "0.9851154337667696",
      "hi": "0.9898936862129449",
      "hu": "0.9738364062100845"
    },
    "level": "middle",
    "test": "test_calculate_minimum_cost() {\n[[ $(calculate_minimum_cost 57 \"2 2\" \"50 30\" \"30 27\") -eq 54 ]] || { echo \"Test 1 failed\"; exit 1; }\n[[ $(calculate_minimum_cost 100 \"10 5\" \"20 8\" \"50 20\") -eq 40 ]] || { echo \"Test 2 failed\"; exit 1; }\n[[ $(calculate_minimum_cost 45 \"5 3\" \"15 10\" \"25 17\") -eq 27 ]] || { echo \"Test 3 failed\"; exit 1; }\n[[ $(calculate_minimum_cost 80 \"8 4\" \"40 19\" \"60 28\") -eq 38 ]] || { echo \"Test 4 failed\"; exit 1; }\n[[ $(calculate_minimum_cost 120 \"12 6\" \"24 9\" \"48 18\") -eq 45 ]] || { echo \"Test 5 failed\"; exit 1; }\n}\n\ntest_calculate_minimum_cost",
    "entry_point": "calculate_minimum_cost",
    "signature": "calculate_minimum_cost() {\nlocal n=$1\nlocal -a pack1=($2)\nlocal -a pack2=($3)\nlocal -a pack3=($4)\n",
    "docstring": {
      "en": "This function calculates the minimum cost needed to buy at least 'n' pencils,\nwhere pencils are available in three different packaging options, each with its own quantity and price.\nThe function does not allow breaking the packaging, so it may require buying more pencils than 'n'.\nEach packaging option is given in the format 'quantity price'.\nInput: Number of pencils needed and three packaging options.\nOutput: Minimum cost to buy at least 'n' pencils.\nExample Usage:\n>>> calculate_minimum_cost 57 \"2 2\" \"50 30\" \"30 27\"\n54\n>>> calculate_minimum_cost 100 \"10 5\" \"20 8\" \"50 20\"\n40\n>>> calculate_minimum_cost 45 \"5 3\" \"15 10\" \"25 17\"\n18",
      "sq": "Kjo funksion llogarit koston minimale të nevojshme për të blerë të paktën 'n' lapsa,\nku lapsat janë të disponueshme në tre opsione paketimi të ndryshme, secila me sasinë dhe çmimin e vet.\nFunksioni nuk lejon thyerjen e paketimit, kështu që mund të kërkojë blerjen e më shumë lapsave sesa 'n'.\nÇdo opsion paketimi jepet në formatin 'sasi çmim'.\nInput: Numri i lapsave të nevojshëm dhe tre opsione paketimi.\nOutput: Kosto minimale për të blerë të paktën 'n' lapsa.\nShembull Përdorimi:\n>>> calculate_minimum_cost 57 \"2 2\" \"50 30\" \"30 27\"\n54\n>>> calculate_minimum_cost 100 \"10 5\" \"20 8\" \"50 20\"\n40\n>>> calculate_minimum_cost 45 \"5 3\" \"15 10\" \"25 17\"\n18",
      "hy": "Այս ֆունկցիան հաշվում է նվազագույն արժեքը, որը անհրաժեշտ է գնել առնվազն 'n' մատիտներ, որտեղ մատիտները հասանելի են երեք տարբեր փաթեթավորման տարբերակներով, որոնցից յուրաքանչյուրը ունի իր քանակը և գինը: Ֆունկցիան թույլ չի տալիս կոտրել փաթեթավորումը, ուստի կարող է պահանջվել գնել ավելի շատ մատիտներ, քան 'n'-ն է: Յուրաքանչյուր փաթեթավորման տարբերակ տրվում է 'քանակ գին' ձևաչափով:\nՄուտք: Անհրաժեշտ մատիտների քանակը և երեք փաթեթավորման տարբերակներ:\nԵլք: Առնվազն 'n' մատիտներ գնելու նվազագույն արժեքը:\nՕրինակ օգտագործում:\n>>> calculate_minimum_cost 57 \"2 2\" \"50 30\" \"30 27\"\n54\n>>> calculate_minimum_cost 100 \"10 5\" \"20 8\" \"50 20\"\n40\n>>> calculate_minimum_cost 45 \"5 3\" \"15 10\" \"25 17\"\n18",
      "bn": "এই ফাংশনটি কমপক্ষে 'n' পেন্সিল কেনার জন্য প্রয়োজনীয় সর্বনিম্ন খরচ গণনা করে, যেখানে পেন্সিল তিনটি ভিন্ন প্যাকেজিং বিকল্পে উপলব্ধ, প্রতিটি নিজস্ব পরিমাণ এবং মূল্যের সাথে। ফাংশনটি প্যাকেজিং ভাঙার অনুমতি দেয় না, তাই এটি 'n' এর চেয়ে বেশি পেন্সিল কেনার প্রয়োজন হতে পারে। প্রতিটি প্যাকেজিং বিকল্প 'পরিমাণ মূল্য' ফরম্যাটে দেওয়া হয়। ইনপুট: প্রয়োজনীয় পেন্সিলের সংখ্যা এবং তিনটি প্যাকেজিং বিকল্প। আউটপুট: কমপক্ষে 'n' পেন্সিল কেনার জন্য সর্বনিম্ন খরচ। উদাহরণ ব্যবহার:\n>>> calculate_minimum_cost 57 \"2 2\" \"50 30\" \"30 27\"\n54\n>>> calculate_minimum_cost 100 \"10 5\" \"20 8\" \"50 20\"\n40\n>>> calculate_minimum_cost 45 \"5 3\" \"15 10\" \"25 17\"\n18",
      "bg": "Тази функция изчислява минималната цена, необходима за закупуване на поне 'n' молива,\nкъдето моливите са налични в три различни опции за опаковка, всяка със собствено количество и цена.\nФункцията не позволява разчупване на опаковката, така че може да се наложи закупуване на повече моливи от 'n'.\nВсяка опция за опаковка е дадена във формат 'количество цена'.\nВход: Брой необходими моливи и три опции за опаковка.\nИзход: Минимална цена за закупуване на поне 'n' молива.\nПример за използване:\n>>> calculate_minimum_cost 57 \"2 2\" \"50 30\" \"30 27\"\n54\n>>> calculate_minimum_cost 100 \"10 5\" \"20 8\" \"50 20\"\n40\n>>> calculate_minimum_cost 45 \"5 3\" \"15 10\" \"25 17\"\n18",
      "zh": "此函数计算购买至少 'n' 支铅笔所需的最低成本，其中铅笔有三种不同的包装选项，每种都有其数量和价格。函数不允许拆分包装，因此可能需要购买多于 'n' 支的铅笔。每个包装选项的格式为 '数量 价格'。\n输入：所需铅笔数量和三个包装选项。\n输出：购买至少 'n' 支铅笔的最低成本。\n示例用法：\n>>> calculate_minimum_cost 57 \"2 2\" \"50 30\" \"30 27\"\n54\n>>> calculate_minimum_cost 100 \"10 5\" \"20 8\" \"50 20\"\n40\n>>> calculate_minimum_cost 45 \"5 3\" \"15 10\" \"25 17\"\n18",
      "fr": "Cette fonction calcule le coût minimum nécessaire pour acheter au moins 'n' crayons,\noù les crayons sont disponibles en trois options d'emballage différentes, chacune avec sa propre quantité et son prix.\nLa fonction ne permet pas de casser l'emballage, il peut donc être nécessaire d'acheter plus de crayons que 'n'.\nChaque option d'emballage est donnée au format 'quantité prix'.\nEntrée : Nombre de crayons nécessaires et trois options d'emballage.\nSortie : Coût minimum pour acheter au moins 'n' crayons.\nExemple d'utilisation :\n>>> calculate_minimum_cost 57 \"2 2\" \"50 30\" \"30 27\"\n54\n>>> calculate_minimum_cost 100 \"10 5\" \"20 8\" \"50 20\"\n40\n>>> calculate_minimum_cost 45 \"5 3\" \"15 10\" \"25 17\"\n18",
      "de": "Diese Funktion berechnet die minimalen Kosten, die benötigt werden, um mindestens 'n' Bleistifte zu kaufen,\nwobei Bleistifte in drei verschiedenen Verpackungsoptionen erhältlich sind, jede mit ihrer eigenen Menge und ihrem Preis.\nDie Funktion erlaubt es nicht, die Verpackung zu brechen, daher kann es erforderlich sein, mehr Bleistifte als 'n' zu kaufen.\nJede Verpackungsoption wird im Format 'Menge Preis' angegeben.\nEingabe: Anzahl der benötigten Bleistifte und drei Verpackungsoptionen.\nAusgabe: Minimale Kosten, um mindestens 'n' Bleistifte zu kaufen.\nBeispielverwendung:\n>>> calculate_minimum_cost 57 \"2 2\" \"50 30\" \"30 27\"\n54\n>>> calculate_minimum_cost 100 \"10 5\" \"20 8\" \"50 20\"\n40\n>>> calculate_minimum_cost 45 \"5 3\" \"15 10\" \"25 17\"\n18",
      "ha": "Wannan aikin yana ƙididdige mafi ƙarancin kuɗin da ake buƙata don siyan aƙalla 'n' fensir,\ninda fensir suna samuwa a cikin zaɓuɓɓukan marufi guda uku daban-daban, kowanne tare da adadi da farashinsa.\nAikin baya ba da izinin karya marufi, don haka yana iya buƙatar siyan fensir fiye da 'n'.\nKowane zaɓin marufi ana bayar dashi a cikin tsarin 'adadi farashi'.\nShigarwa: Yawan fensir da ake buƙata da zaɓuɓɓukan marufi guda uku.\nFitarwa: Mafi ƙarancin kuɗi don siyan aƙalla 'n' fensir.\nMisalin Amfani:\n>>> calculate_minimum_cost 57 \"2 2\" \"50 30\" \"30 27\"\n54\n>>> calculate_minimum_cost 100 \"10 5\" \"20 8\" \"50 20\"\n40\n>>> calculate_minimum_cost 45 \"5 3\" \"15 10\" \"25 17\"\n18",
      "hi": "यह फ़ंक्शन कम से कम 'n' पेंसिल खरीदने के लिए आवश्यक न्यूनतम लागत की गणना करता है, जहाँ पेंसिल तीन अलग-अलग पैकेजिंग विकल्पों में उपलब्ध हैं, प्रत्येक की अपनी मात्रा और कीमत है। फ़ंक्शन पैकेजिंग को तोड़ने की अनुमति नहीं देता है, इसलिए यह 'n' से अधिक पेंसिल खरीदने की आवश्यकता हो सकती है। प्रत्येक पैकेजिंग विकल्प 'मात्रा कीमत' के प्रारूप में दिया गया है। इनपुट: आवश्यक पेंसिल की संख्या और तीन पैकेजिंग विकल्प। आउटपुट: कम से कम 'n' पेंसिल खरीदने की न्यूनतम लागत। उदाहरण उपयोग:\n>>> calculate_minimum_cost 57 \"2 2\" \"50 30\" \"30 27\"\n54\n>>> calculate_minimum_cost 100 \"10 5\" \"20 8\" \"50 20\"\n40\n>>> calculate_minimum_cost 45 \"5 3\" \"15 10\" \"25 17\"\n18",
      "hu": "Ez a függvény kiszámítja a minimális költséget, amely szükséges legalább 'n' ceruza megvásárlásához, ahol a ceruzák három különböző csomagolási opcióban érhetők el, mindegyik saját mennyiséggel és árral. A függvény nem engedi a csomagolás bontását, így előfordulhat, hogy több ceruzát kell vásárolni, mint 'n'. Minden csomagolási opció a 'mennyiség ár' formátumban van megadva. Bemenet: Szükséges ceruzák száma és három csomagolási opció. Kimenet: Minimális költség legalább 'n' ceruza megvásárlásához.\nPélda használat:\n>>> calculate_minimum_cost 57 \"2 2\" \"50 30\" \"30 27\"\n54\n>>> calculate_minimum_cost 100 \"10 5\" \"20 8\" \"50 20\"\n40\n>>> calculate_minimum_cost 45 \"5 3\" \"15 10\" \"25 17\"\n18"
    },
    "docstring_bertscore": {
      "sq": "0.9857248317757846",
      "hy": "0.970195511325715",
      "bn": "0.9820285190151065",
      "bg": "0.9780628634577448",
      "zh": "0.9579894757807401",
      "fr": "0.9833420617248901",
      "de": "0.9849448102694607",
      "ha": "0.975894614218368",
      "hi": "0.9768063276673182",
      "hu": "0.9732309808086902"
    }
  },
  {
    "task_id": "Shell/26",
    "prompt": {
      "en": "#!/bin/bash\ngenerate_password() {\nlocal shift=$1\nlocal string=$2\n# This function generates a password by shifting each letter of the given string by 'n' positions in the alphabet.\n# The shift wraps around the alphabet, so 'z' followed by a shift of 1 would be 'a'.\n# Input: Shift amount 'n' and the original string.\n# Output: Transformed string representing the password.\n# Example Usage:\n# >>> generate_password 1 \"qwe\"\n# rxf\n# >>> generate_password 3 \"abc\"\n# def\n# >>> generate_password 2 \"xyz\"\n# zab",
      "sq": "#!/bin/bash\ngenerate_password() {\nlocal shift=$1\nlocal string=$2\n# Kjo funksion gjeneron një fjalëkalim duke zhvendosur secilën shkronjë të vargut të dhënë me 'n' pozicione në alfabet.\n# Zhvendosja përfundon rreth alfabetit, kështu që 'z' e ndjekur nga një zhvendosje prej 1 do të ishte 'a'.\n# Hyrja: Sasia e zhvendosjes 'n' dhe vargu origjinal.\n# Dalja: Vargu i transformuar që përfaqëson fjalëkalimin.\n# Shembull Përdorimi:\n# >>> generate_password 1 \"qwe\"\n# rxf\n# >>> generate_password 3 \"abc\"\n# def\n# >>> generate_password 2 \"xyz\"\n# zab",
      "hy": "#!/bin/bash\ngenerate_password() {\nlocal shift=$1\nlocal string=$2\n# Այս ֆունկցիան գեներացնում է գաղտնաբառ՝ տրված տողի յուրաքանչյուր տառը 'n' դիրքով այբուբենում տեղաշարժելով։\n# Տեղաշարժը շրջում է այբուբենը, այնպես որ 'z'-ից հետո 1 տեղաշարժը կլինի 'a'։\n# Մուտք: Տեղաշարժի չափը 'n' և սկզբնական տողը։\n# Ելք: Փոխակերպված տողը, որը ներկայացնում է գաղտնաբառը։\n# Օրինակ օգտագործում:\n# >>> generate_password 1 \"qwe\"\n# rxf\n# >>> generate_password 3 \"abc\"\n# def\n# >>> generate_password 2 \"xyz\"\n# zab",
      "bn": "#!/bin/bash\ngenerate_password() {\nlocal shift=$1\nlocal string=$2\n# এই ফাংশনটি প্রদত্ত স্ট্রিংয়ের প্রতিটি অক্ষরকে বর্ণমালায় 'n' অবস্থান সরিয়ে একটি পাসওয়ার্ড তৈরি করে।\n# শিফট বর্ণমালার চারপাশে ঘুরে যায়, তাই 'z' এর পরে 1 শিফট করলে 'a' হবে।\n# ইনপুট: শিফট পরিমাণ 'n' এবং মূল স্ট্রিং।\n# আউটপুট: পাসওয়ার্ড উপস্থাপনকারী রূপান্তরিত স্ট্রিং।\n# উদাহরণ ব্যবহার:\n# >>> generate_password 1 \"qwe\"\n# rxf\n# >>> generate_password 3 \"abc\"\n# def\n# >>> generate_password 2 \"xyz\"\n# zab",
      "bg": "#!/bin/bash\ngenerate_password() {\nlocal shift=$1\nlocal string=$2\n# Тази функция генерира парола, като измества всяка буква на дадения низ с 'n' позиции в азбуката.\n# Изместването обхваща азбуката, така че 'z', последвано от изместване с 1, ще бъде 'a'.\n# Вход: Размер на изместването 'n' и оригиналния низ.\n# Изход: Трансформиран низ, представляващ паролата.\n# Пример за използване:\n# >>> generate_password 1 \"qwe\"\n# rxf\n# >>> generate_password 3 \"abc\"\n# def\n# >>> generate_password 2 \"xyz\"\n# zab",
      "zh": "#!/bin/bash\ngenerate_password() {\nlocal shift=$1\nlocal string=$2\n# 这个函数通过将给定字符串中的每个字母在字母表中移动'n'个位置来生成密码。\n# 移动会在字母表中循环，因此'z'加上1的移动会变成'a'。\n# 输入：移动量'n'和原始字符串。\n# 输出：表示密码的转换字符串。\n# 示例用法：\n# >>> generate_password 1 \"qwe\"\n# rxf\n# >>> generate_password 3 \"abc\"\n# def\n# >>> generate_password 2 \"xyz\"\n# zab",
      "fr": "#!/bin/bash\ngenerate_password() {\nlocal shift=$1\nlocal string=$2\n# Cette fonction génère un mot de passe en décalant chaque lettre de la chaîne donnée de 'n' positions dans l'alphabet.\n# Le décalage fait le tour de l'alphabet, donc 'z' suivi d'un décalage de 1 deviendrait 'a'.\n# Entrée : Quantité de décalage 'n' et la chaîne originale.\n# Sortie : Chaîne transformée représentant le mot de passe.\n# Exemple d'utilisation :\n# >>> generate_password 1 \"qwe\"\n# rxf\n# >>> generate_password 3 \"abc\"\n# def\n# >>> generate_password 2 \"xyz\"\n# zab",
      "de": "#!/bin/bash\ngenerate_password() {\nlocal shift=$1\nlocal string=$2\n# Diese Funktion generiert ein Passwort, indem sie jeden Buchstaben des gegebenen Strings um 'n' Positionen im Alphabet verschiebt.\n# Die Verschiebung umwickelt das Alphabet, sodass 'z' gefolgt von einer Verschiebung um 1 zu 'a' wird.\n# Eingabe: Verschiebungsbetrag 'n' und der ursprüngliche String.\n# Ausgabe: Transformierter String, der das Passwort darstellt.\n# Beispielverwendung:\n# >>> generate_password 1 \"qwe\"\n# rxf\n# >>> generate_password 3 \"abc\"\n# def\n# >>> generate_password 2 \"xyz\"\n# zab",
      "ha": "#!/bin/bash\ngenerate_password() {\nlocal shift=$1\nlocal string=$2\n# Wannan aikin yana ƙirƙirar kalmar sirri ta hanyar motsa kowane harafi na igiyar da aka bayar ta wurin 'n' matsayi a cikin haruffa.\n# Motsawar tana zagayawa cikin haruffa, don haka 'z' da aka biyo bayan motsa na 1 zai zama 'a'.\n# Shigarwa: Adadin motsa 'n' da igiyar asali.\n# Fitarwa: Canjin igiya da ke wakiltar kalmar sirri.\n# Misalin Amfani:\n# >>> generate_password 1 \"qwe\"\n# rxf\n# >>> generate_password 3 \"abc\"\n# def\n# >>> generate_password 2 \"xyz\"\n# zab",
      "hi": "#!/bin/bash\ngenerate_password() {\nlocal shift=$1\nlocal string=$2\n# यह फ़ंक्शन दिए गए स्ट्रिंग के प्रत्येक अक्षर को वर्णमाला में 'n' स्थानों से शिफ्ट करके एक पासवर्ड उत्पन्न करता है।\n# शिफ्ट वर्णमाला के चारों ओर लपेटता है, इसलिए 'z' के बाद 1 का शिफ्ट 'a' होगा।\n# इनपुट: शिफ्ट मात्रा 'n' और मूल स्ट्रिंग।\n# आउटपुट: पासवर्ड का प्रतिनिधित्व करने वाला परिवर्तित स्ट्रिंग।\n# उदाहरण उपयोग:\n# >>> generate_password 1 \"qwe\"\n# rxf\n# >>> generate_password 3 \"abc\"\n# def\n# >>> generate_password 2 \"xyz\"\n# zab",
      "hu": "#!/bin/bash\ngenerate_password() {\nlocal shift=$1\nlocal string=$2\n# Ez a függvény jelszót generál azáltal, hogy az adott string minden egyes betűjét 'n' pozícióval eltolja az ábécében.\n# Az eltolás körbefordul az ábécében, így például 'z' után 1-es eltolással 'a' lesz.\n# Bemenet: Az eltolás mértéke 'n' és az eredeti string.\n# Kimenet: Az átalakított string, amely a jelszót képviseli.\n# Példa használat:\n# >>> generate_password 1 \"qwe\"\n# rxf\n# >>> generate_password 3 \"abc\"\n# def\n# >>> generate_password 2 \"xyz\"\n# zab"
    },
    "prompt_bertscore": {
      "sq": "0.9832989589322055",
      "hy": "0.9608443902473546",
      "bn": "0.9656017865035211",
      "bg": "0.9790000015954675",
      "zh": "0.9632217972779611",
      "fr": "0.9849080636489692",
      "de": "0.9872099911347825",
      "ha": "0.9837897746037427",
      "hi": "0.970155387988746",
      "hu": "0.9477955659956486"
    },
    "canonical_solution": "local shifted_string=\"\"\nlocal alphabet=(a b c d e f g h i j k l m n o p q r s t u v w x y z)\n\n# Function to find index of a character in the alphabet array\nfind_index() {\nlocal char=$1\nfor i in \"${!alphabet[@]}\"; do\nif [[ \"${alphabet[$i]}\" = \"${char}\" ]]; then\necho $i\nreturn\nfi\ndone\n}\n\n# Shift each character\nfor (( i=0; i<${#string}; i++ )); do\nlocal char=${string:$i:1}\nlocal index=$(find_index $char)\nlocal new_index=$(((index + shift) % 26))\nshifted_string+=\"${alphabet[$new_index]}\"\ndone\n\necho $shifted_string\n}",
    "instruction": {
      "en": "Write a Shell function `generate_password() {\nlocal shift=$1\nlocal string=$2\n` to solve the following problem:\nThis function generates a password by shifting each letter of the given string by 'n' positions in the alphabet.\nThe shift wraps around the alphabet, so 'z' followed by a shift of 1 would be 'a'.\nInput: Shift amount 'n' and the original string.\nOutput: Transformed string representing the password.\nExample Usage:\n>>> generate_password 1 \"qwe\"\nrxf\n>>> generate_password 3 \"abc\"\ndef\n>>> generate_password 2 \"xyz\"\nzab",
      "sq": "Shkruani një funksion Shell `generate_password() {\nlocal shift=$1\nlocal string=$2\n` për të zgjidhur problemin e mëposhtëm:\nKy funksion gjeneron një fjalëkalim duke zhvendosur secilën shkronjë të vargut të dhënë me 'n' pozicione në alfabet.\nZhvendosja rrotullohet rreth alfabetit, kështu që 'z' e ndjekur nga një zhvendosje prej 1 do të ishte 'a'.\nInput: Shuma e zhvendosjes 'n' dhe vargu origjinal.\nOutput: Vargu i transformuar që përfaqëson fjalëkalimin.\nShembull i Përdorimit:\n>>> generate_password 1 \"qwe\"\nrxf\n>>> generate_password 3 \"abc\"\ndef\n>>> generate_password 2 \"xyz\"\nzab",
      "hy": "Գրեք Shell ֆունկցիա `generate_password() {\nlocal shift=$1\nlocal string=$2\n` հետևյալ խնդիրը լուծելու համար:\nԱյս ֆունկցիան գեներացնում է գաղտնաբառ՝ տրված տողի յուրաքանչյուր տառը այբուբենում 'n' դիրքով տեղափոխելով:\nՏեղափոխումը շրջվում է այբուբենում, այնպես որ 'z'-ին 1 տեղափոխումից հետո կլինի 'a':\nՄուտք: Տեղափոխման քանակ 'n' և սկզբնական տող:\nԵլք: Փոխակերպված տող, որը ներկայացնում է գաղտնաբառը:\nՕրինակ օգտագործում:\n>>> generate_password 1 \"qwe\"\nrxf\n>>> generate_password 3 \"abc\"\ndef\n>>> generate_password 2 \"xyz\"\nzab",
      "bn": "Write a Shell function `generate_password() {\nlocal shift=$1\nlocal string=$2\n` নিম্নলিখিত সমস্যার সমাধানের জন্য:\nএই ফাংশনটি প্রদত্ত স্ট্রিংয়ের প্রতিটি অক্ষরকে বর্ণমালায় 'n' অবস্থানে সরিয়ে একটি পাসওয়ার্ড তৈরি করে।\nশিফটটি বর্ণমালার চারপাশে মোড়ানো হয়, তাই 'z' এর পরে 1 শিফট করলে 'a' হবে।\nইনপুট: শিফট পরিমাণ 'n' এবং মূল স্ট্রিং।\nআউটপুট: পাসওয়ার্ড উপস্থাপনকারী রূপান্তরিত স্ট্রিং।\nউদাহরণ ব্যবহার:\n>>> generate_password 1 \"qwe\"\nrxf\n>>> generate_password 3 \"abc\"\ndef\n>>> generate_password 2 \"xyz\"\nzab",
      "bg": "Напишете Shell функция `generate_password() {\nlocal shift=$1\nlocal string=$2\n` за решаване на следния проблем:\nТази функция генерира парола, като измества всяка буква от дадения низ с 'n' позиции в азбуката.\nИзместването обхваща азбуката, така че 'z', последвано от изместване с 1, би било 'a'.\nВход: Количество на изместване 'n' и оригиналния низ.\nИзход: Трансформиран низ, представляващ паролата.\nПример за използване:\n>>> generate_password 1 \"qwe\"\nrxf\n>>> generate_password 3 \"abc\"\ndef\n>>> generate_password 2 \"xyz\"\nzab",
      "zh": "编写一个 Shell 函数 `generate_password() {\nlocal shift=$1\nlocal string=$2\n` 来解决以下问题：\n此函数通过在字母表中将给定字符串的每个字母移动 'n' 个位置来生成密码。\n移动在字母表中循环，因此 'z' 后面跟着一个移动 1 的位置将是 'a'。\n输入：移动量 'n' 和原始字符串。\n输出：表示密码的转换字符串。\n示例用法：\n>>> generate_password 1 \"qwe\"\nrxf\n>>> generate_password 3 \"abc\"\ndef\n>>> generate_password 2 \"xyz\"\nzab",
      "fr": "Écrire une fonction Shell `generate_password() {\nlocal shift=$1\nlocal string=$2\n` pour résoudre le problème suivant :\nCette fonction génère un mot de passe en décalant chaque lettre de la chaîne donnée de 'n' positions dans l'alphabet.\nLe décalage fait le tour de l'alphabet, donc 'z' suivi d'un décalage de 1 deviendrait 'a'.\nEntrée : Montant du décalage 'n' et la chaîne originale.\nSortie : Chaîne transformée représentant le mot de passe.\nExemple d'utilisation :\n>>> generate_password 1 \"qwe\"\nrxf\n>>> generate_password 3 \"abc\"\ndef\n>>> generate_password 2 \"xyz\"\nzab",
      "de": "Schreiben Sie eine Shell-Funktion `generate_password() {\nlocal shift=$1\nlocal string=$2\n` um das folgende Problem zu lösen:\nDiese Funktion generiert ein Passwort, indem sie jeden Buchstaben des gegebenen Strings um 'n' Positionen im Alphabet verschiebt.\nDie Verschiebung umwickelt das Alphabet, sodass 'z' gefolgt von einer Verschiebung um 1 'a' wäre.\nEingabe: Verschiebungsbetrag 'n' und der ursprüngliche String.\nAusgabe: Transformierter String, der das Passwort darstellt.\nBeispielverwendung:\n>>> generate_password 1 \"qwe\"\nrxf\n>>> generate_password 3 \"abc\"\ndef\n>>> generate_password 2 \"xyz\"\nzab",
      "ha": "Rubuta aikin Shell `generate_password() {\nlocal shift=$1\nlocal string=$2\n` don warware matsalar mai zuwa:\nWannan aikin yana samar da kalmar sirri ta hanyar motsa kowane harafi na igiyar da aka bayar ta wurin 'n' matsayi a cikin haruffa.\nMotsawar yana zagayawa cikin haruffa, don haka 'z' da aka biyo bayan motsi na 1 zai zama 'a'.\nShigarwa: Adadin motsi 'n' da igiyar asali.\nFitarwa: Canjin igiya da ke wakiltar kalmar sirri.\nMisalin Amfani:\n>>> generate_password 1 \"qwe\"\nrxf\n>>> generate_password 3 \"abc\"\ndef\n>>> generate_password 2 \"xyz\"\nzab",
      "hi": "Write a Shell function `generate_password() {\nlocal shift=$1\nlocal string=$2\n` निम्नलिखित समस्या को हल करने के लिए:\nयह फ़ंक्शन दिए गए स्ट्रिंग के प्रत्येक अक्षर को वर्णमाला में 'n' स्थानों से शिफ्ट करके एक पासवर्ड उत्पन्न करता है।\nशिफ्ट वर्णमाला के चारों ओर लपेटता है, इसलिए 'z' के बाद 1 का शिफ्ट 'a' होगा।\nइनपुट: शिफ्ट मात्रा 'n' और मूल स्ट्रिंग।\nआउटपुट: पासवर्ड का प्रतिनिधित्व करने वाला परिवर्तित स्ट्रिंग।\nउदाहरण उपयोग:\n>>> generate_password 1 \"qwe\"\nrxf\n>>> generate_password 3 \"abc\"\ndef\n>>> generate_password 2 \"xyz\"\nzab",
      "hu": "Írj egy Shell függvényt `generate_password() {\nlocal shift=$1\nlocal string=$2\n` a következő probléma megoldására:\nEz a függvény jelszót generál azáltal, hogy az adott szöveg minden egyes betűjét 'n' pozícióval eltolja az ábécében.\nAz eltolás körbefordul az ábécében, így ha 'z'-t 1-gyel eltoljuk, akkor 'a' lesz belőle.\nBemenet: Az eltolás mértéke 'n' és az eredeti szöveg.\nKimenet: Az átalakított szöveg, amely a jelszót képviseli.\nPélda használat:\n>>> generate_password 1 \"qwe\"\nrxf\n>>> generate_password 3 \"abc\"\ndef\n>>> generate_password 2 \"xyz\"\nzab"
    },
    "instruction_bertscore": {
      "sq": "0.9818368406974077",
      "hy": "0.9689943934115971",
      "bn": "0.9702741689566048",
      "bg": "0.984781734726631",
      "zh": "0.9662928215991415",
      "fr": "0.9864373189525568",
      "de": "0.9879109577494546",
      "ha": "0.9767836838038803",
      "hi": "0.9719674929549272",
      "hu": "0.9528669968842314"
    },
    "level": "middle",
    "test": "test_generate_password() {\n[[ $(generate_password 1 \"qwe\") == \"rxf\" ]] || { echo \"Test 1 failed\"; exit 1; }\n[[ $(generate_password 3 \"abc\") == \"def\" ]] || { echo \"Test 2 failed\"; exit 1; }\n[[ $(generate_password 2 \"xyz\") == \"zab\" ]] || { echo \"Test 3 failed\"; exit 1; }\n[[ $(generate_password 4 \"hello\") == \"lipps\" ]] || { echo \"Test 4 failed\"; exit 1; }\n[[ $(generate_password 5 \"password\") == \"ufxxbtwi\" ]] || { echo \"Test 5 failed\"; exit 1; }\n}\n\ntest_generate_password",
    "entry_point": "generate_password",
    "signature": "generate_password() {\nlocal shift=$1\nlocal string=$2\n",
    "docstring": {
      "en": "This function generates a password by shifting each letter of the given string by 'n' positions in the alphabet.\nThe shift wraps around the alphabet, so 'z' followed by a shift of 1 would be 'a'.\nInput: Shift amount 'n' and the original string.\nOutput: Transformed string representing the password.\nExample Usage:\n>>> generate_password 1 \"qwe\"\nrxf\n>>> generate_password 3 \"abc\"\ndef\n>>> generate_password 2 \"xyz\"\nzab",
      "sq": "Kjo funksion gjeneron një fjalëkalim duke zhvendosur secilën shkronjë të vargut të dhënë me 'n' pozicione në alfabet. Zhvendosja mbështillet rreth alfabetit, kështu që 'z' e ndjekur nga një zhvendosje prej 1 do të ishte 'a'. Hyrja: Shuma e zhvendosjes 'n' dhe vargu origjinal. Dalja: Vargu i transformuar që përfaqëson fjalëkalimin. Shembull i Përdorimit:\n>>> generate_password 1 \"qwe\"\nrxf\n>>> generate_password 3 \"abc\"\ndef\n>>> generate_password 2 \"xyz\"\nzab",
      "hy": "Այս ֆունկցիան գեներացնում է գաղտնաբառ՝ տրված տողի յուրաքանչյուր տառը այբուբենում 'n' դիրքով տեղաշարժելով:\nՏեղաշարժը շրջվում է այբուբենով, այնպես որ 'z'-ից հետո 1 տեղաշարժը կլինի 'a':\nՄուտքագրում: Տեղաշարժի քանակը 'n' և սկզբնական տողը:\nԵլք: Փոխակերպված տող, որը ներկայացնում է գաղտնաբառը:\nՕրինակ օգտագործում:\n>>> generate_password 1 \"qwe\"\nrxf\n>>> generate_password 3 \"abc\"\ndef\n>>> generate_password 2 \"xyz\"\nzab",
      "bn": "এই ফাংশনটি প্রদত্ত স্ট্রিংয়ের প্রতিটি অক্ষরকে বর্ণমালায় 'n' অবস্থান সরিয়ে পাসওয়ার্ড তৈরি করে। \nসরানোটি বর্ণমালার চারপাশে ঘোরে, তাই 'z' এর পরে 1 সরানো হলে তা হবে 'a'। \nইনপুট: সরানোর পরিমাণ 'n' এবং মূল স্ট্রিং। \nআউটপুট: পাসওয়ার্ডকে উপস্থাপনকারী রূপান্তরিত স্ট্রিং। \nব্যবহারের উদাহরণ:\n>>> generate_password 1 \"qwe\"\nrxf\n>>> generate_password 3 \"abc\"\ndef\n>>> generate_password 2 \"xyz\"\nzab",
      "bg": "Тази функция генерира парола, като измества всяка буква на дадения низ с 'n' позиции в азбуката. Изместването обхваща азбуката, така че 'z', последвано от изместване с 1, би било 'a'. Вход: Размер на изместването 'n' и оригиналния низ. Изход: Трансформиран низ, представляващ паролата. Пример за използване:\n>>> generate_password 1 \"qwe\"\nrxf\n>>> generate_password 3 \"abc\"\ndef\n>>> generate_password 2 \"xyz\"\nzab",
      "zh": "此函数通过将给定字符串的每个字母在字母表中移动 'n' 个位置来生成密码。\n移动在字母表中循环，因此 'z' 后面跟着移动 1 会变成 'a'。\n输入：移动量 'n' 和原始字符串。\n输出：表示密码的转换后的字符串。\n示例用法：\n>>> generate_password 1 \"qwe\"\nrxf\n>>> generate_password 3 \"abc\"\ndef\n>>> generate_password 2 \"xyz\"\nzab",
      "fr": "Cette fonction génère un mot de passe en décalant chaque lettre de la chaîne donnée de 'n' positions dans l'alphabet.  \nLe décalage fait le tour de l'alphabet, donc 'z' suivi d'un décalage de 1 deviendrait 'a'.  \nEntrée : Quantité de décalage 'n' et la chaîne originale.  \nSortie : Chaîne transformée représentant le mot de passe.  \nExemple d'utilisation :  \n>>> generate_password 1 \"qwe\"  \nrxf  \n>>> generate_password 3 \"abc\"  \ndef  \n>>> generate_password 2 \"xyz\"  \nzab  ",
      "de": "Diese Funktion generiert ein Passwort, indem jeder Buchstabe des angegebenen Strings um 'n' Positionen im Alphabet verschoben wird.\nDie Verschiebung umwickelt das Alphabet, sodass 'z' gefolgt von einer Verschiebung um 1 'a' wäre.\nEingabe: Verschiebungsbetrag 'n' und der Originalstring.\nAusgabe: Transformierter String, der das Passwort darstellt.\nBeispielverwendung:\n>>> generate_password 1 \"qwe\"\nrxf\n>>> generate_password 3 \"abc\"\ndef\n>>> generate_password 2 \"xyz\"\nzab",
      "ha": "Wannan aikin yana ƙirƙirar kalmar sirri ta hanyar motsa kowace harafi na kirtani da aka bayar da 'n' matsayi a cikin haruffa. \n\nMotsawar tana zagayawa a cikin haruffa, don haka 'z' da aka biyo bayan motsa na 1 zai zama 'a'. \n\nShigarwa: Adadin motsa 'n' da kuma kirtani na asali. \n\nFitarwa: Kirtani da aka canza wanda ke wakiltar kalmar sirri. \n\nMisalin Amfani: \n>>> generate_password 1 \"qwe\"\nrxf\n>>> generate_password 3 \"abc\"\ndef\n>>> generate_password 2 \"xyz\"\nzab",
      "hi": "यह फ़ंक्शन दिए गए स्ट्रिंग के प्रत्येक अक्षर को वर्णमाला में 'n' स्थानों से शिफ्ट करके एक पासवर्ड उत्पन्न करता है।  \nशिफ्ट वर्णमाला के चारों ओर लपेटता है, इसलिए 'z' के बाद 1 का शिफ्ट 'a' होगा।  \nइनपुट: शिफ्ट मात्रा 'n' और मूल स्ट्रिंग।  \nआउटपुट: पासवर्ड का प्रतिनिधित्व करने वाला परिवर्तित स्ट्रिंग।  \nउदाहरण उपयोग:  \n>>> generate_password 1 \"qwe\"  \nrxf  \n>>> generate_password 3 \"abc\"  \ndef  \n>>> generate_password 2 \"xyz\"  \nzab  ",
      "hu": "Ez a függvény jelszót generál azáltal, hogy az adott sztring minden egyes betűjét 'n' pozícióval eltolja az ábécében.\nAz eltolás körbefordul az ábécében, így a 'z' után 1-es eltolással 'a' lesz.\nBemenet: Az eltolás mértéke 'n' és az eredeti sztring.\nKimenet: Az átalakított sztring, amely a jelszót képviseli.\nHasználati példa:\n>>> generate_password 1 \"qwe\"\nrxf\n>>> generate_password 3 \"abc\"\ndef\n>>> generate_password 2 \"xyz\"\nzab"
    },
    "docstring_bertscore": {
      "sq": "0.9763594093099897",
      "hy": "0.9523543318707803",
      "bn": "0.9534265386676066",
      "bg": "0.9724871100317145",
      "zh": "0.9440257599939875",
      "fr": "0.9767381974466232",
      "de": "0.9988972041244943",
      "ha": "0.9539832996256474",
      "hi": "0.9696806613780726",
      "hu": "0.9466723111908963"
    }
  },
  {
    "task_id": "Shell/27",
    "prompt": {
      "en": "#!/bin/bash\ncount_digit_occurrences() {\nlocal n=$1\nlocal x=$2\n# generate shell function\n# This function calculates the number of times a specific digit 'x' appears in all integers from 1 to 'n'.\n# Input: Upper limit of the range 'n' and the digit 'x' to be counted.\n# Output: Number of occurrences of the digit 'x'.\n# Example Usage:\n# >>> count_digit_occurrences 11 1\n# 4\n# >>> count_digit_occurrences 20 2\n# 3\n# >>> count_digit_occurrences 100 3\n# 20",
      "sq": "#!/bin/bash\ncount_digit_occurrences() {\nlocal n=$1\nlocal x=$2\n# gjenero funksionin shell\n# Ky funksion llogarit numrin e herëve që një shifër specifike 'x' shfaqet në të gjitha numrat nga 1 deri te 'n'.\n# Hyrja: Kufiri i sipërm i intervalit 'n' dhe shifra 'x' që do të numërohet.\n# Dalja: Numri i shfaqjeve të shifrës 'x'.\n# Shembull i Përdorimit:\n# >>> count_digit_occurrences 11 1\n# 4\n# >>> count_digit_occurrences 20 2\n# 3\n# >>> count_digit_occurrences 100 3\n# 20",
      "hy": "#!/bin/bash\ncount_digit_occurrences() {\nlocal n=$1\nlocal x=$2\n# ստեղծել shell ֆունկցիա\n# Այս ֆունկցիան հաշվում է, թե քանի անգամ է որոշակի թվանշան 'x'-ը հանդիպում 1-ից 'n' բոլոր ամբողջ թվերում:\n# Մուտք: Շարքի վերին սահմանը 'n' և հաշվող թվանշանը 'x':\n# Ելք: Թվանշան 'x'-ի հանդիպումների քանակը:\n# Օրինակ օգտագործում:\n# >>> count_digit_occurrences 11 1\n# 4\n# >>> count_digit_occurrences 20 2\n# 3\n# >>> count_digit_occurrences 100 3\n# 20",
      "bn": "#!/bin/bash\ncount_digit_occurrences() {\nlocal n=$1\nlocal x=$2\n# শেল ফাংশন তৈরি করুন\n# এই ফাংশনটি নির্দিষ্ট একটি অঙ্ক 'x' কতবার 1 থেকে 'n' পর্যন্ত সমস্ত পূর্ণসংখ্যায় উপস্থিত হয় তা গণনা করে।\n# ইনপুট: সীমার উপরের সীমা 'n' এবং গণনা করার জন্য অঙ্ক 'x'।\n# আউটপুট: অঙ্ক 'x' এর উপস্থিতির সংখ্যা।\n# উদাহরণ ব্যবহার:\n# >>> count_digit_occurrences 11 1\n# 4\n# >>> count_digit_occurrences 20 2\n# 3\n# >>> count_digit_occurrences 100 3\n# 20",
      "bg": "#!/bin/bash\ncount_digit_occurrences() {\nlocal n=$1\nlocal x=$2\n# генериране на shell функция\n# Тази функция изчислява колко пъти специфичната цифра 'x' се появява във всички цели числа от 1 до 'n'.\n# Вход: Горна граница на обхвата 'n' и цифрата 'x', която трябва да се преброи.\n# Изход: Брой на срещанията на цифрата 'x'.\n# Пример за използване:\n# >>> count_digit_occurrences 11 1\n# 4\n# >>> count_digit_occurrences 20 2\n# 3\n# >>> count_digit_occurrences 100 3\n# 20",
      "zh": "#!/bin/bash\ncount_digit_occurrences() {\nlocal n=$1\nlocal x=$2\n# 生成 shell 函数\n# 此函数计算特定数字 'x' 在从 1 到 'n' 的所有整数中出现的次数。\n# 输入: 范围的上限 'n' 和要计数的数字 'x'。\n# 输出: 数字 'x' 出现的次数。\n# 示例用法:\n# >>> count_digit_occurrences 11 1\n# 4\n# >>> count_digit_occurrences 20 2\n# 3\n# >>> count_digit_occurrences 100 3\n# 20",
      "fr": "#!/bin/bash\ncount_digit_occurrences() {\nlocal n=$1\nlocal x=$2\n# générer une fonction shell\n# Cette fonction calcule le nombre de fois qu'un chiffre spécifique 'x' apparaît dans tous les entiers de 1 à 'n'.\n# Entrée : Limite supérieure de la plage 'n' et le chiffre 'x' à compter.\n# Sortie : Nombre d'occurrences du chiffre 'x'.\n# Exemple d'utilisation :\n# >>> count_digit_occurrences 11 1\n# 4\n# >>> count_digit_occurrences 20 2\n# 3\n# >>> count_digit_occurrences 100 3\n# 20",
      "de": "#!/bin/bash\ncount_digit_occurrences() {\nlocal n=$1\nlocal x=$2\n# Shell-Funktion generieren\n# Diese Funktion berechnet, wie oft eine bestimmte Ziffer 'x' in allen ganzen Zahlen von 1 bis 'n' erscheint.\n# Eingabe: Obergrenze des Bereichs 'n' und die zu zählende Ziffer 'x'.\n# Ausgabe: Anzahl der Vorkommen der Ziffer 'x'.\n# Beispielverwendung:\n# >>> count_digit_occurrences 11 1\n# 4\n# >>> count_digit_occurrences 20 2\n# 3\n# >>> count_digit_occurrences 100 3\n# 20",
      "ha": "#!/bin/bash\ncount_digit_occurrences() {\nlocal n=$1\nlocal x=$2\n# ƙirƙiri aikin harsashi\n# Wannan aikin yana lissafin yawan lokutan da wata takamaiman lamba 'x' ta bayyana a duk lambobi daga 1 zuwa 'n'.\n# Shigarwa: Iyakar kewayon 'n' da kuma lambar 'x' da za a ƙirga.\n# Fitarwa: Yawan bayyana lambar 'x'.\n# Misalin Amfani:\n# >>> count_digit_occurrences 11 1\n# 4\n# >>> count_digit_occurrences 20 2\n# 3\n# >>> count_digit_occurrences 100 3\n# 20",
      "hi": "#!/bin/bash\ncount_digit_occurrences() {\nlocal n=$1\nlocal x=$2\n# शेल फ़ंक्शन उत्पन्न करें\n# यह फ़ंक्शन गणना करता है कि 'n' तक के सभी पूर्णांकों में एक विशिष्ट अंक 'x' कितनी बार प्रकट होता है।\n# इनपुट: श्रेणी की ऊपरी सीमा 'n' और गिनने के लिए अंक 'x'।\n# आउटपुट: अंक 'x' की घटनाओं की संख्या।\n# उदाहरण उपयोग:\n# >>> count_digit_occurrences 11 1\n# 4\n# >>> count_digit_occurrences 20 2\n# 3\n# >>> count_digit_occurrences 100 3\n# 20",
      "hu": "#!/bin/bash\ncount_digit_occurrences() {\nlocal n=$1\nlocal x=$2\n# generálj shell függvényt\n# Ez a függvény kiszámítja, hogy egy adott 'x' számjegy hányszor fordul elő az 1-től 'n'-ig terjedő összes egész szám között.\n# Bemenet: A tartomány felső határa 'n' és a számolandó számjegy 'x'.\n# Kimenet: Az 'x' számjegy előfordulásainak száma.\n# Példa használat:\n# >>> count_digit_occurrences 11 1\n# 4\n# >>> count_digit_occurrences 20 2\n# 3\n# >>> count_digit_occurrences 100 3\n# 20"
    },
    "prompt_bertscore": {
      "sq": "0.9810083533781112",
      "hy": "0.9560210487046844",
      "bn": "0.9773221707668658",
      "bg": "0.9803292361053529",
      "zh": "0.9685433038162669",
      "fr": "0.9899032204712346",
      "de": "0.985778064717902",
      "ha": "0.9690275646852299",
      "hi": "0.9685145024110168",
      "hu": "0.9669912060188602"
    },
    "canonical_solution": "local count=0\n\nfor (( i=1; i<=n; i++ )); do\nlocal num=$i\nwhile [[ $num -gt 0 ]]; do\nif [[ $((num % 10)) -eq $x ]]; then\n((count++))\nfi\nnum=$((num / 10))\ndone\ndone\n\necho $count\n}",
    "instruction": {
      "en": "Write a Shell function `count_digit_occurrences() {\nlocal n=$1\nlocal x=$2\n` to solve the following problem:\ngenerate shell function\nThis function calculates the number of times a specific digit 'x' appears in all integers from 1 to 'n'.\nInput: Upper limit of the range 'n' and the digit 'x' to be counted.\nOutput: Number of occurrences of the digit 'x'.\nExample Usage:\n>>> count_digit_occurrences 11 1\n4\n>>> count_digit_occurrences 20 2\n3\n>>> count_digit_occurrences 100 3\n20",
      "sq": "Shkruani një funksion Shell `count_digit_occurrences() {\nlocal n=$1\nlocal x=$2\n` për të zgjidhur problemin e mëposhtëm:\ngjeneroni funksionin shell\nKy funksion llogarit numrin e herëve që një shifër specifike 'x' shfaqet në të gjitha numrat e plotë nga 1 deri në 'n'.\nInput: Kufiri i sipërm i intervalit 'n' dhe shifra 'x' që do të numërohet.\nOutput: Numri i shfaqjeve të shifrës 'x'.\nShembull i përdorimit:\n>>> count_digit_occurrences 11 1\n4\n>>> count_digit_occurrences 20 2\n3\n>>> count_digit_occurrences 100 3\n20",
      "hy": "Գրեք Shell ֆունկցիա `count_digit_occurrences() {\nlocal n=$1\nlocal x=$2\n` հետևյալ խնդիրը լուծելու համար:\nստեղծել shell ֆունկցիա\nԱյս ֆունկցիան հաշվում է, թե քանի անգամ է որոշակի թվանշան 'x'-ը հանդիպում 1-ից 'n' բոլոր ամբողջ թվերում:\nՄուտք: Շրջանակի վերին սահմանը 'n' և հաշվող թվանշանը 'x':\nԵլք: Թվանշան 'x'-ի հանդիպումների քանակը:\nՕրինակ օգտագործում:\n>>> count_digit_occurrences 11 1\n4\n>>> count_digit_occurrences 20 2\n3\n>>> count_digit_occurrences 100 3\n20",
      "bn": "Write a Shell function `count_digit_occurrences() {\nlocal n=$1\nlocal x=$2\n` নিম্নলিখিত সমস্যার সমাধানের জন্য:\nshell function তৈরি করুন\nএই ফাংশনটি ১ থেকে 'n' পর্যন্ত সমস্ত পূর্ণসংখ্যায় নির্দিষ্ট একটি অঙ্ক 'x' কতবার উপস্থিত হয়েছে তা গণনা করে।\nইনপুট: সীমার উপরের সীমা 'n' এবং গণনা করার জন্য অঙ্ক 'x'।\nআউটপুট: অঙ্ক 'x' এর উপস্থিতির সংখ্যা।\nউদাহরণ ব্যবহার:\n>>> count_digit_occurrences 11 1\n4\n>>> count_digit_occurrences 20 2\n3\n>>> count_digit_occurrences 100 3\n20",
      "bg": "Напишете Shell функция `count_digit_occurrences() {\nlocal n=$1\nlocal x=$2\n` за решаване на следния проблем:\nгенерирайте shell функция\nТази функция изчислява колко пъти специфична цифра 'x' се появява във всички цели числа от 1 до 'n'.\nВход: Горна граница на диапазона 'n' и цифрата 'x', която трябва да се преброи.\nИзход: Брой на срещанията на цифрата 'x'.\nПример за използване:\n>>> count_digit_occurrences 11 1\n4\n>>> count_digit_occurrences 20 2\n3\n>>> count_digit_occurrences 100 3\n20",
      "zh": "编写一个 Shell 函数 `count_digit_occurrences() {\nlocal n=$1\nlocal x=$2\n` 来解决以下问题：\n生成 shell 函数\n此函数计算特定数字 'x' 在从 1 到 'n' 的所有整数中出现的次数。\n输入：范围的上限 'n' 和要计数的数字 'x'。\n输出：数字 'x' 出现的次数。\n示例用法：\n>>> count_digit_occurrences 11 1\n4\n>>> count_digit_occurrences 20 2\n3\n>>> count_digit_occurrences 100 3\n20",
      "fr": "Écrire une fonction Shell `count_digit_occurrences() {\nlocal n=$1\nlocal x=$2\n` pour résoudre le problème suivant :\ngénérer une fonction shell\nCette fonction calcule le nombre de fois qu'un chiffre spécifique 'x' apparaît dans tous les entiers de 1 à 'n'.\nEntrée : Limite supérieure de la plage 'n' et le chiffre 'x' à compter.\nSortie : Nombre d'occurrences du chiffre 'x'.\nExemple d'utilisation :\n>>> count_digit_occurrences 11 1\n4\n>>> count_digit_occurrences 20 2\n3\n>>> count_digit_occurrences 100 3\n20",
      "de": "Schreibe eine Shell-Funktion `count_digit_occurrences() {\nlocal n=$1\nlocal x=$2\n` um das folgende Problem zu lösen:\ngeneriere Shell-Funktion\nDiese Funktion berechnet, wie oft eine bestimmte Ziffer 'x' in allen ganzen Zahlen von 1 bis 'n' vorkommt.\nEingabe: Obergrenze des Bereichs 'n' und die zu zählende Ziffer 'x'.\nAusgabe: Anzahl der Vorkommen der Ziffer 'x'.\nBeispielverwendung:\n>>> count_digit_occurrences 11 1\n4\n>>> count_digit_occurrences 20 2\n3\n>>> count_digit_occurrences 100 3\n20",
      "ha": "Rubuta aikin Shell `count_digit_occurrences() {\nlocal n=$1\nlocal x=$2\n` don warware matsalar mai zuwa:\nƙirƙiri aikin shell\nWannan aikin yana ƙididdige yawan lokutan da wani takamaiman lamba 'x' ya bayyana a cikin duk lambobi daga 1 zuwa 'n'.\nShigarwa: Iyakar sama na zangon 'n' da lambar 'x' da za a ƙirga.\nFitarwa: Yawan bayyanar lambar 'x'.\nMisalin Amfani:\n>>> count_digit_occurrences 11 1\n4\n>>> count_digit_occurrences 20 2\n3\n>>> count_digit_occurrences 100 3\n20",
      "hi": "Write a Shell function `count_digit_occurrences() {\nlocal n=$1\nlocal x=$2\n` निम्नलिखित समस्या को हल करने के लिए:\ngenerate shell function\nयह फ़ंक्शन यह गणना करता है कि एक विशिष्ट अंक 'x' कितनी बार 1 से 'n' तक के सभी पूर्णांकों में दिखाई देता है।\nइनपुट: श्रेणी की ऊपरी सीमा 'n' और गिने जाने वाले अंक 'x'।\nआउटपुट: अंक 'x' की घटनाओं की संख्या।\nउदाहरण उपयोग:\n>>> count_digit_occurrences 11 1\n4\n>>> count_digit_occurrences 20 2\n3\n>>> count_digit_occurrences 100 3\n20",
      "hu": "Írj egy Shell függvényt `count_digit_occurrences() {\nlocal n=$1\nlocal x=$2\n`, hogy megoldja a következő problémát:\nshell függvény generálása\nEz a függvény kiszámítja, hogy egy adott 'x' számjegy hányszor fordul elő az 1-től 'n'-ig terjedő összes egész szám között.\nBemenet: A tartomány felső határa 'n' és a számolandó 'x' számjegy.\nKimenet: Az 'x' számjegy előfordulásainak száma.\nPélda használat:\n>>> count_digit_occurrences 11 1\n4\n>>> count_digit_occurrences 20 2\n3\n>>> count_digit_occurrences 100 3\n20"
    },
    "instruction_bertscore": {
      "sq": "0.9828454857723029",
      "hy": "0.9635193455887514",
      "bn": "0.9765904164431333",
      "bg": "0.9913651400756514",
      "zh": "0.9700717645983303",
      "fr": "0.990184878351542",
      "de": "0.9798523245604882",
      "ha": "0.9681605430720126",
      "hi": "0.9910391876203731",
      "hu": "0.9792848375618715"
    },
    "level": "easy",
    "test": "test_count_digit_occurrences() {\n[[ $(count_digit_occurrences 11 1) -eq 4 ]] || { echo \"Test 1 failed\"; exit 1; }\n[[ $(count_digit_occurrences 20 2) -eq 3 ]] || { echo \"Test 2 failed\"; exit 1; }\n[[ $(count_digit_occurrences 100 3) -eq 20 ]] || { echo \"Test 3 failed\"; exit 1; }\n[[ $(count_digit_occurrences 50 4) -eq 15 ]] || { echo \"Test 4 failed\"; exit 1; }\n[[ $(count_digit_occurrences 99 5) -eq 20 ]] || { echo \"Test 5 failed\"; exit 1; }\n}\n\ntest_count_digit_occurrences",
    "entry_point": "count_digit_occurrences",
    "signature": "count_digit_occurrences() {\nlocal n=$1\nlocal x=$2\n",
    "docstring": {
      "en": "generate shell function\nThis function calculates the number of times a specific digit 'x' appears in all integers from 1 to 'n'.\nInput: Upper limit of the range 'n' and the digit 'x' to be counted.\nOutput: Number of occurrences of the digit 'x'.\nExample Usage:\n>>> count_digit_occurrences 11 1\n4\n>>> count_digit_occurrences 20 2\n3\n>>> count_digit_occurrences 100 3\n20",
      "sq": "generate shell function\nKjo funksion llogarit sa herë shfaqet një shifër specifike 'x' në të gjitha numrat e plotë nga 1 deri në 'n'.\nInput: Kufiri i sipërm i intervalit 'n' dhe shifra 'x' që do të numërohet.\nOutput: Numri i shfaqjeve të shifrës 'x'.\nShembull Përdorimi:\n>>> count_digit_occurrences 11 1\n4\n>>> count_digit_occurrences 20 2\n3\n>>> count_digit_occurrences 100 3\n20",
      "hy": "generate shell function  \nԱյս ֆունկցիան հաշվում է, թե քանի անգամ է որոշակի թվանշան 'x'-ը հանդիպում բոլոր ամբողջ թվերի մեջ 1-ից 'n'-ը:  \nՄուտք: Շարքի վերին սահմանը 'n' և հաշվող թվանշանը 'x':  \nԵլք: Թվանշան 'x'-ի հանդիպումների քանակը:  \nՕրինակային օգտագործում:  \n>>> count_digit_occurrences 11 1  \n4  \n>>> count_digit_occurrences 20 2  \n3  \n>>> count_digit_occurrences 100 3  \n20  ",
      "bn": "generate shell function\nএই ফাংশনটি ১ থেকে 'n' পর্যন্ত সমস্ত পূর্ণসংখ্যায় নির্দিষ্ট ডিজিট 'x' কতবার উপস্থিত রয়েছে তা গণনা করে।\nইনপুট: পরিসরের উপরের সীমা 'n' এবং গণনা করার জন্য ডিজিট 'x'।\nআউটপুট: ডিজিট 'x'-এর উপস্থিতির সংখ্যা।\nউদাহরণ ব্যবহার:\n>>> count_digit_occurrences 11 1\n4\n>>> count_digit_occurrences 20 2\n3\n>>> count_digit_occurrences 100 3\n20",
      "bg": "generate shell function  \nТази функция изчислява колко пъти определена цифра 'x' се появява във всички цели числа от 1 до 'n'.  \nВход: Горна граница на диапазона 'n' и цифрата 'x', която трябва да се преброи.  \nИзход: Брой на появяванията на цифрата 'x'.  \nПример за използване:  \n>>> count_digit_occurrences 11 1  \n4  \n>>> count_digit_occurrences 20 2  \n3  \n>>> count_digit_occurrences 100 3  \n20  ",
      "zh": "generate shell function  \n此函数计算特定数字 'x' 在从 1 到 'n' 的所有整数中出现的次数。  \n输入：范围的上限 'n' 和要计数的数字 'x'。  \n输出：数字 'x' 出现的次数。  \n示例用法：  \n>>> count_digit_occurrences 11 1  \n4  \n>>> count_digit_occurrences 20 2  \n3  \n>>> count_digit_occurrences 100 3  \n20  ",
      "fr": "generate shell function  \nCette fonction calcule le nombre de fois qu'un chiffre spécifique 'x' apparaît dans tous les entiers de 1 à 'n'.  \nEntrée : Limite supérieure de la plage 'n' et le chiffre 'x' à compter.  \nSortie : Nombre d'occurrences du chiffre 'x'.  \nExemple d'utilisation :  \n>>> count_digit_occurrences 11 1  \n4  \n>>> count_digit_occurrences 20 2  \n3  \n>>> count_digit_occurrences 100 3  \n20  ",
      "de": "generate shell function  \nDiese Funktion berechnet, wie oft eine bestimmte Ziffer 'x' in allen ganzen Zahlen von 1 bis 'n' vorkommt.  \nEingabe: Obergrenze des Bereichs 'n' und die zu zählende Ziffer 'x'.  \nAusgabe: Anzahl der Vorkommen der Ziffer 'x'.  \nBeispielverwendung:  \n>>> count_digit_occurrences 11 1  \n4  \n>>> count_digit_occurrences 20 2  \n3  \n>>> count_digit_occurrences 100 3  \n20  ",
      "ha": "generate shell function\nWannan aikin yana ƙididdige yawan lokutan da wani takamaiman lamba 'x' ya bayyana a cikin duk lambobi daga 1 zuwa 'n'.\nShigarwa: Ƙayyadadden iyakar kewayon 'n' da kuma lambar 'x' da za a ƙirga.\nFitarwa: Yawan bayyanar lambar 'x'.\nMisalin Amfani:\n>>> count_digit_occurrences 11 1\n4\n>>> count_digit_occurrences 20 2\n3\n>>> count_digit_occurrences 100 3\n20",
      "hi": "generate shell function  \nयह फ़ंक्शन गणना करता है कि 1 से 'n' तक की सभी पूर्णांकों में एक विशिष्ट अंक 'x' कितनी बार आता है।  \nइनपुट: श्रेणी की ऊपरी सीमा 'n' और गिने जाने वाले अंक 'x'।  \nआउटपुट: अंक 'x' की घटनाओं की संख्या।  \nउदाहरण उपयोग:  \n>>> count_digit_occurrences 11 1  \n4  \n>>> count_digit_occurrences 20 2  \n3  \n>>> count_digit_occurrences 100 3  \n20  ",
      "hu": "generate shell function  \nEz a függvény kiszámítja, hogy egy adott 'x' számjegy hányszor fordul elő az összes 1-től 'n'-ig terjedő egész számokban.  \nBemenet: A tartomány felső határa 'n' és a számolandó 'x' számjegy.  \nKimenet: Az 'x' számjegy előfordulásainak száma.  \nPélda használat:  \n>>> count_digit_occurrences 11 1  \n4  \n>>> count_digit_occurrences 20 2  \n3  \n>>> count_digit_occurrences 100 3  \n20  "
    },
    "docstring_bertscore": {
      "sq": "0.9896475831708427",
      "hy": "0.9674256106621835",
      "bn": "0.9753924766151119",
      "bg": "0.9817424912664162",
      "zh": "0.9512914607018627",
      "fr": "0.9881207114318274",
      "de": "0.9853726601102099",
      "ha": "0.9594796008992639",
      "hi": "0.9901864673945903",
      "hu": "0.9833670891529005"
    }
  },
  {
    "task_id": "Shell/28",
    "prompt": {
      "en": "#!/bin/bash\nconvert_to_decimal_expression() {\nlocal base=$1\nlocal num=$2\n# This function converts a number 'N' from base 'M' to its decimal representation as an expression.\n# It outputs the expression as a sum of terms, each term in the form of coefficient*base^power.\n# Coefficients that are zero are omitted in the output.\n# Input: Base 'M' and number 'N' in base 'M'.\n# Output: Decimal representation as an expression.\n# Example Usage:\n# >>> convert_to_decimal_expression 2 10101\n# 1*2^4+1*2^2+1*2^0\n# >>> convert_to_decimal_expression 3 102\n# 1*3^2+2*3^0",
      "sq": "#!/bin/bash\nconvert_to_decimal_expression() {\nlocal base=$1\nlocal num=$2\n# Kjo funksion konverton një numër 'N' nga baza 'M' në përfaqësimin e tij decimal si një shprehje.\n# Ai jep si rezultat shprehjen si një shumë termash, secili term në formën koeficient*bazë^fuqi.\n# Koeficientët që janë zero nuk përfshihen në rezultat.\n# Hyrja: Baza 'M' dhe numri 'N' në bazën 'M'.\n# Dalja: Përfaqësimi decimal si një shprehje.\n# Shembull Përdorimi:\n# >>> convert_to_decimal_expression 2 10101\n# 1*2^4+1*2^2+1*2^0\n# >>> convert_to_decimal_expression 3 102\n# 1*3^2+2*3^0",
      "hy": "#!/bin/bash\nconvert_to_decimal_expression() {\nlocal base=$1\nlocal num=$2\n# Այս ֆունկցիան փոխակերպում է 'N' թիվը 'M' հիմքից իր տասնորդական ներկայացմանը որպես արտահայտություն։\n# Այն արտածում է արտահայտությունը որպես գումարած տերմինների, յուրաքանչյուր տերմինը `coefficient*base^power` ձևով։\n# Զրո գործակիցները բաց են թողնվում արտածման մեջ։\n# Մուտք: Հիմք 'M' և թիվ 'N' 'M' հիմքում։\n# Ելք: Տասնորդական ներկայացում որպես արտահայտություն։\n# Օրինակ օգտագործում:\n# >>> convert_to_decimal_expression 2 10101\n# 1*2^4+1*2^2+1*2^0\n# >>> convert_to_decimal_expression 3 102\n# 1*3^2+2*3^0",
      "bn": "#!/bin/bash\nconvert_to_decimal_expression() {\nlocal base=$1\nlocal num=$2\n# এই ফাংশনটি একটি সংখ্যা 'N' কে ভিত্তি 'M' থেকে তার দশমিক উপস্থাপনা হিসেবে একটি অভিব্যক্তিতে রূপান্তর করে।\n# এটি অভিব্যক্তিটি যোগফলের আকারে আউটপুট দেয়, প্রতিটি পদ সহগ*ভিত্তি^ঘাতের আকারে থাকে।\n# যেসব সহগ শূন্য তাদের আউটপুটে বাদ দেওয়া হয়।\n# ইনপুট: ভিত্তি 'M' এবং সংখ্যা 'N' ভিত্তি 'M' এ।\n# আউটপুট: দশমিক উপস্থাপনা একটি অভিব্যক্তি হিসেবে।\n# উদাহরণ ব্যবহার:\n# >>> convert_to_decimal_expression 2 10101\n# 1*2^4+1*2^2+1*2^0\n# >>> convert_to_decimal_expression 3 102\n# 1*3^2+2*3^0",
      "bg": "#!/bin/bash\nconvert_to_decimal_expression() {\nlocal base=$1\nlocal num=$2\n# Тази функция преобразува число 'N' от база 'M' към неговото десетично представяне като израз.\n# Тя извежда израза като сума от членове, всеки член във формата коефициент*база^степен.\n# Коефициентите, които са нула, се пропускат в изхода.\n# Вход: База 'M' и число 'N' в база 'M'.\n# Изход: Десетично представяне като израз.\n# Пример за използване:\n# >>> convert_to_decimal_expression 2 10101\n# 1*2^4+1*2^2+1*2^0\n# >>> convert_to_decimal_expression 3 102\n# 1*3^2+2*3^0",
      "zh": "#!/bin/bash\nconvert_to_decimal_expression() {\nlocal base=$1\nlocal num=$2\n# 此函数将一个基数为 'M' 的数字 'N' 转换为其十进制表示形式的表达式。\n# 它输出的表达式是项的和，每项的形式为系数*基数^幂。\n# 系数为零的项在输出中被省略。\n# 输入：基数 'M' 和基数为 'M' 的数字 'N'。\n# 输出：作为表达式的十进制表示。\n# 示例用法：\n# >>> convert_to_decimal_expression 2 10101\n# 1*2^4+1*2^2+1*2^0\n# >>> convert_to_decimal_expression 3 102\n# 1*3^2+2*3^0",
      "fr": "#!/bin/bash\nconvert_to_decimal_expression() {\nlocal base=$1\nlocal num=$2\n# Cette fonction convertit un nombre 'N' de base 'M' en sa représentation décimale sous forme d'expression.\n# Elle affiche l'expression comme une somme de termes, chaque terme sous la forme coefficient*base^puissance.\n# Les coefficients qui sont nuls sont omis dans la sortie.\n# Entrée : Base 'M' et nombre 'N' en base 'M'.\n# Sortie : Représentation décimale sous forme d'expression.\n# Exemple d'utilisation :\n# >>> convert_to_decimal_expression 2 10101\n# 1*2^4+1*2^2+1*2^0\n# >>> convert_to_decimal_expression 3 102\n# 1*3^2+2*3^0",
      "de": "#!/bin/bash\nconvert_to_decimal_expression() {\nlocal base=$1\nlocal num=$2\n# Diese Funktion konvertiert eine Zahl 'N' von der Basis 'M' in ihre dezimale Darstellung als Ausdruck.\n# Sie gibt den Ausdruck als Summe von Termen aus, wobei jeder Term in der Form Koeffizient*Basis^Potenz ist.\n# Koeffizienten, die null sind, werden in der Ausgabe weggelassen.\n# Eingabe: Basis 'M' und Zahl 'N' in der Basis 'M'.\n# Ausgabe: Dezimale Darstellung als Ausdruck.\n# Beispielverwendung:\n# >>> convert_to_decimal_expression 2 10101\n# 1*2^4+1*2^2+1*2^0\n# >>> convert_to_decimal_expression 3 102\n# 1*3^2+2*3^0",
      "ha": "#!/bin/bash\nconvert_to_decimal_expression() {\nlocal base=$1\nlocal num=$2\n# Wannan aikin yana canza lambar 'N' daga tushe 'M' zuwa wakilarsa ta decimal a matsayin magana.\n# Yana fitar da maganar a matsayin jumlar sharudda, kowanne sharadi a cikin nau'in coefficient*base^power.\n# Ana watsi da coefficients da suke sifili a cikin fitarwa.\n# Shigarwa: Tushe 'M' da lamba 'N' a cikin tushe 'M'.\n# Fitarwa: Wakilarsa ta decimal a matsayin magana.\n# Misalin Amfani:\n# >>> convert_to_decimal_expression 2 10101\n# 1*2^4+1*2^2+1*2^0\n# >>> convert_to_decimal_expression 3 102\n# 1*3^2+2*3^0",
      "hi": "#!/bin/bash\nconvert_to_decimal_expression() {\nlocal base=$1\nlocal num=$2\n# यह फ़ंक्शन एक संख्या 'N' को आधार 'M' से उसके दशमलव अभिव्यक्ति में बदलता है।\n# यह अभिव्यक्ति को पदों के योग के रूप में आउटपुट करता है, प्रत्येक पद coefficient*base^power के रूप में होता है।\n# जिन गुणांकों का मान शून्य होता है, वे आउटपुट में नहीं दिखाए जाते हैं।\n# इनपुट: आधार 'M' और संख्या 'N' आधार 'M' में।\n# आउटपुट: दशमलव अभिव्यक्ति के रूप में।\n# उदाहरण उपयोग:\n# >>> convert_to_decimal_expression 2 10101\n# 1*2^4+1*2^2+1*2^0\n# >>> convert_to_decimal_expression 3 102\n# 1*3^2+2*3^0",
      "hu": "#!/bin/bash\nconvert_to_decimal_expression() {\nlocal base=$1\nlocal num=$2\n# Ez a függvény egy 'N' számot az 'M' alapból a tizedes ábrázolásába konvertál kifejezésként.\n# Kimenetként az összeget adja meg, ahol minden tag az alábbi formában van: együttható*alap^kitevő.\n# A nulla együtthatók kimaradnak a kimenetből.\n# Bemenet: 'M' alap és 'N' szám az 'M' alapban.\n# Kimenet: Tizedes ábrázolás kifejezésként.\n# Példa használat:\n# >>> convert_to_decimal_expression 2 10101\n# 1*2^4+1*2^2+1*2^0\n# >>> convert_to_decimal_expression 3 102\n# 1*3^2+2*3^0"
    },
    "prompt_bertscore": {
      "sq": "0.9908349955886693",
      "hy": "0.966539917793149",
      "bn": "0.9727560555676358",
      "bg": "0.9907301187474828",
      "zh": "0.9781015963820466",
      "fr": "0.9741146873739144",
      "de": "0.9830022051429395",
      "ha": "0.984320514981868",
      "hi": "0.966870438747191",
      "hu": "0.95421410812841"
    },
    "canonical_solution": "local length=${#num}\nlocal expression=\"\"\nlocal coefficient\n\nfor (( i=0; i<length; i++ )); do\ncoefficient=${num:$i:1}\nif [[ $coefficient -ne 0 ]]; then\nif [[ -n $expression ]]; then\nexpression+=\"+\"\nfi\nexpression+=\"${coefficient}*${base}^$((length-i-1))\"\nfi\ndone\n\necho $expression\n}",
    "instruction": {
      "en": "Write a Shell function `convert_to_decimal_expression() {\nlocal base=$1\nlocal num=$2\n` to solve the following problem:\nThis function converts a number 'N' from base 'M' to its decimal representation as an expression.\nIt outputs the expression as a sum of terms, each term in the form of coefficient*base^power.\nCoefficients that are zero are omitted in the output.\nInput: Base 'M' and number 'N' in base 'M'.\nOutput: Decimal representation as an expression.\nExample Usage:\n>>> convert_to_decimal_expression 2 10101\n1*2^4+1*2^2+1*2^0\n>>> convert_to_decimal_expression 3 102\n1*3^2+2*3^0",
      "sq": "Shkruani një funksion Shell `convert_to_decimal_expression() {\nlocal base=$1\nlocal num=$2\n` për të zgjidhur problemin e mëposhtëm:\nKy funksion konverton një numër 'N' nga baza 'M' në përfaqësimin e tij dhjetor si një shprehje.\nAi jep shprehjen si një shumë të termave, secili term në formën koeficient*bazë^fuqi.\nKoeficientët që janë zero nuk përfshihen në rezultat.\nInput: Baza 'M' dhe numri 'N' në bazën 'M'.\nOutput: Përfaqësimi dhjetor si një shprehje.\nShembull Përdorimi:\n>>> convert_to_decimal_expression 2 10101\n1*2^4+1*2^2+1*2^0\n>>> convert_to_decimal_expression 3 102\n1*3^2+2*3^0",
      "hy": "Գրեք Shell ֆունկցիա `convert_to_decimal_expression() {\nlocal base=$1\nlocal num=$2\n` հետևյալ խնդիրը լուծելու համար:\nԱյս ֆունկցիան փոխակերպում է թիվ 'N'-ը հիմք 'M'-ից իր տասնորդական ներկայացմանը որպես արտահայտություն:\nԱյն արտածում է արտահայտությունը որպես գումար, որտեղ յուրաքանչյուր անդամ ունի տեսք՝ գործակից*հիմք^աստիճան:\nԳործակիցները, որոնք զրո են, չեն ներառվում արտածման մեջ:\nՄուտք: Հիմք 'M' և թիվ 'N' հիմքում 'M':\nԵլք: Տասնորդական ներկայացում որպես արտահայտություն:\nՕրինակ օգտագործում:\n>>> convert_to_decimal_expression 2 10101\n1*2^4+1*2^2+1*2^0\n>>> convert_to_decimal_expression 3 102\n1*3^2+2*3^0",
      "bn": "একটি Shell ফাংশন লিখুন `convert_to_decimal_expression() {\nlocal base=$1\nlocal num=$2\n` নিম্নলিখিত সমস্যার সমাধানের জন্য:\nএই ফাংশনটি একটি সংখ্যা 'N' কে ভিত্তি 'M' থেকে তার দশমিক উপস্থাপনায় একটি অভিব্যক্তি হিসাবে রূপান্তর করে।\nএটি প্রতিটি পদকে গুণফল*ভিত্তি^ঘাত আকারে একটি যোগফল হিসাবে অভিব্যক্তি আকারে আউটপুট দেয়।\nযে গুণফলগুলি শূন্য, সেগুলি আউটপুটে উপেক্ষা করা হয়।\nইনপুট: ভিত্তি 'M' এবং সংখ্যা 'N' ভিত্তি 'M' এ।\nআউটপুট: দশমিক উপস্থাপনা একটি অভিব্যক্তি হিসাবে।\nউদাহরণ ব্যবহার:\n>>> convert_to_decimal_expression 2 10101\n1*2^4+1*2^2+1*2^0\n>>> convert_to_decimal_expression 3 102\n1*3^2+2*3^0",
      "bg": "Напишете Shell функция `convert_to_decimal_expression() {\nlocal base=$1\nlocal num=$2\n` за решаване на следния проблем:\nТази функция преобразува число 'N' от база 'M' към неговото десетично представяне като израз.\nТя извежда израза като сума от членове, всеки член във формата коефициент*база^степен.\nКоефициенти, които са нула, се пропускат в изхода.\nВход: База 'M' и число 'N' в база 'M'.\nИзход: Десетично представяне като израз.\nПример за използване:\n>>> convert_to_decimal_expression 2 10101\n1*2^4+1*2^2+1*2^0\n>>> convert_to_decimal_expression 3 102\n1*3^2+2*3^0",
      "zh": "编写一个 Shell 函数 `convert_to_decimal_expression() {\nlocal base=$1\nlocal num=$2\n` 来解决以下问题：\n此函数将一个基数为 'M' 的数字 'N' 转换为其十进制表示形式的表达式。\n它输出的表达式是各项之和，每项的形式为系数*基数^幂。\n系数为零的项在输出中省略。\n输入：基数 'M' 和基数为 'M' 的数字 'N'。\n输出：作为表达式的十进制表示。\n示例用法：\n>>> convert_to_decimal_expression 2 10101\n1*2^4+1*2^2+1*2^0\n>>> convert_to_decimal_expression 3 102\n1*3^2+2*3^0",
      "fr": "Écrire une fonction Shell `convert_to_decimal_expression() {\nlocal base=$1\nlocal num=$2\n` pour résoudre le problème suivant :\nCette fonction convertit un nombre 'N' de base 'M' en sa représentation décimale sous forme d'expression.\nElle produit l'expression comme une somme de termes, chaque terme étant sous la forme coefficient*base^puissance.\nLes coefficients qui sont zéro sont omis dans la sortie.\nEntrée : Base 'M' et nombre 'N' en base 'M'.\nSortie : Représentation décimale sous forme d'expression.\nExemple d'utilisation :\n>>> convert_to_decimal_expression 2 10101\n1*2^4+1*2^2+1*2^0\n>>> convert_to_decimal_expression 3 102\n1*3^2+2*3^0",
      "de": "Schreiben Sie eine Shell-Funktion `convert_to_decimal_expression() {\nlocal base=$1\nlocal num=$2\n` um das folgende Problem zu lösen:\nDiese Funktion konvertiert eine Zahl 'N' von Basis 'M' in ihre dezimale Darstellung als Ausdruck.\nSie gibt den Ausdruck als Summe von Termen aus, wobei jeder Term in der Form Koeffizient*Basis^Potenz ist.\nKoeffizienten, die null sind, werden in der Ausgabe weggelassen.\nEingabe: Basis 'M' und Zahl 'N' in Basis 'M'.\nAusgabe: Dezimale Darstellung als Ausdruck.\nBeispielverwendung:\n>>> convert_to_decimal_expression 2 10101\n1*2^4+1*2^2+1*2^0\n>>> convert_to_decimal_expression 3 102\n1*3^2+2*3^0",
      "ha": "Rubuta aikin Shell `convert_to_decimal_expression() {\nlocal base=$1\nlocal num=$2\n` don warware matsalar mai zuwa:\nWannan aikin yana canza lamba 'N' daga tushe 'M' zuwa wakilcin decimal a matsayin wata bayyana.\nYana fitar da bayyana a matsayin jumlar sharuɗɗa, kowanne sharadi a cikin nau'i na coefficient*base^power.\nAna cire coefficients waɗanda suke sifili a cikin fitarwa.\nShigarwa: Tushe 'M' da lamba 'N' a cikin tushe 'M'.\nFitarwa: Wakilcin decimal a matsayin bayyana.\nMisalin Amfani:\n>>> convert_to_decimal_expression 2 10101\n1*2^4+1*2^2+1*2^0\n>>> convert_to_decimal_expression 3 102\n1*3^2+2*3^0",
      "hi": "Shell फ़ंक्शन `convert_to_decimal_expression() {\nlocal base=$1\nlocal num=$2\n` निम्नलिखित समस्या को हल करने के लिए:\nयह फ़ंक्शन संख्या 'N' को आधार 'M' से उसके दशमलव रूप में एक अभिव्यक्ति के रूप में परिवर्तित करता है।\nयह अभिव्यक्ति को पदों के योग के रूप में आउटपुट करता है, प्रत्येक पद के रूप में coefficient*base^power होता है।\nगुणांक जो शून्य हैं, उन्हें आउटपुट में छोड़ दिया जाता है।\nइनपुट: आधार 'M' और संख्या 'N' आधार 'M' में।\nआउटपुट: दशमलव रूप में एक अभिव्यक्ति।\nउदाहरण उपयोग:\n>>> convert_to_decimal_expression 2 10101\n1*2^4+1*2^2+1*2^0\n>>> convert_to_decimal_expression 3 102\n1*3^2+2*3^0",
      "hu": "Írj egy Shell függvényt `convert_to_decimal_expression() {\nlocal base=$1\nlocal num=$2\n` a következő probléma megoldására:\nEz a függvény egy 'N' számot 'M' alapból átalakít a tizedes ábrázolására kifejezésként.\nA kifejezést az egyes tagok összegének formájában adja meg, minden tag a következő formában: együttható*alap^kitevő.\nAz együtthatók, amelyek nullák, kimaradnak a kimenetből.\nBemenet: 'M' alap és 'N' szám 'M' alapban.\nKimenet: Tizedes ábrázolás kifejezésként.\nPélda használat:\n>>> convert_to_decimal_expression 2 10101\n1*2^4+1*2^2+1*2^0\n>>> convert_to_decimal_expression 3 102\n1*3^2+2*3^0"
    },
    "instruction_bertscore": {
      "sq": "0.9864869765478155",
      "hy": "0.9721665205967243",
      "bn": "0.8450629397724992",
      "bg": "0.9898873300407518",
      "zh": "0.9639473940598816",
      "fr": "0.972427123656642",
      "de": "0.9889873357842827",
      "ha": "0.9954887067859356",
      "hi": "0.9678139330571067",
      "hu": "0.9599553206618424"
    },
    "level": "easy",
    "test": "test_convert_to_decimal_expression() {\n[[ $(convert_to_decimal_expression 2 10101) == \"1*2^4+1*2^2+1*2^0\" ]] || { echo \"Test 1 failed\"; exit 1; }\n[[ $(convert_to_decimal_expression 3 102) == \"1*3^2+2*3^0\" ]] || { echo \"Test 2 failed\"; exit 1; }\n[[ $(convert_to_decimal_expression 5 143) == \"1*5^2+4*5^1+3*5^0\" ]] || { echo \"Test 3 failed\"; exit 1; }\n[[ $(convert_to_decimal_expression 8 123) == \"1*8^2+2*8^1+3*8^0\" ]] || { echo \"Test 4 failed\"; exit 1; }\n[[ $(convert_to_decimal_expression 4 1302) == \"1*4^3+3*4^2+2*4^0\" ]] || { echo \"Test 5 failed\"; exit 1; }\n}\n\ntest_convert_to_decimal_expression",
    "entry_point": "convert_to_decimal_expression",
    "signature": "convert_to_decimal_expression() {\nlocal base=$1\nlocal num=$2\n",
    "docstring": {
      "en": "This function converts a number 'N' from base 'M' to its decimal representation as an expression.\nIt outputs the expression as a sum of terms, each term in the form of coefficient*base^power.\nCoefficients that are zero are omitted in the output.\nInput: Base 'M' and number 'N' in base 'M'.\nOutput: Decimal representation as an expression.\nExample Usage:\n>>> convert_to_decimal_expression 2 10101\n1*2^4+1*2^2+1*2^0\n>>> convert_to_decimal_expression 3 102\n1*3^2+2*3^0",
      "sq": "Kjo funksion konverton një numër 'N' nga baza 'M' në përfaqësimin e tij dhjetor si një shprehje.\nAi jep shprehjen si një shumë e termave, secili term në formën e koeficientit*baza^fuqia.\nKoeficientët që janë zero janë të përjashtuar në rezultat.\nHyrja: Baza 'M' dhe numri 'N' në bazën 'M'.\nDalja: Përfaqësimi dhjetor si një shprehje.\nShembull i Përdorimit:\n>>> convert_to_decimal_expression 2 10101\n1*2^4+1*2^2+1*2^0\n>>> convert_to_decimal_expression 3 102\n1*3^2+2*3^0",
      "hy": "Այս ֆունկցիան փոխակերպում է թիվը 'N' հիմքից 'M' դեպի դրա տասնորդական ներկայացումը որպես արտահայտություն:\nԱյն արտածում է արտահայտությունը որպես գումար՝ տերմինների, յուրաքանչյուր տերմինը՝ ձևով գործակից*հիմք^աստիճան:\nԳործակիցները, որոնք զրո են, բաց են թողնվում արտածման մեջ:\nՄուտք: Հիմք 'M' և թիվ 'N' հիմքում 'M':\nԵլք: Տասնորդական ներկայացում որպես արտահայտություն:\nՕրինակ օգտագործում:\n>>> convert_to_decimal_expression 2 10101\n1*2^4+1*2^2+1*2^0\n>>> convert_to_decimal_expression 3 102\n1*3^2+2*3^0",
      "bn": "এই ফাংশনটি একটি সংখ্যা 'N' কে ভিত্তি 'M' থেকে তার দশমিক উপস্থাপনায় রূপান্তর করে একটি অভিব্যক্তি হিসাবে।\nএটি অভিব্যক্তিটি আউটপুট করে টার্মগুলোর যোগফল হিসাবে, প্রতিটি টার্ম coefficient*base^power আকারে।\nযেসব সহগ শূন্য, সেগুলো আউটপুটে অন্তর্ভুক্ত করা হয় না।\nইনপুট: ভিত্তি 'M' এবং ভিত্তি 'M' এ সংখ্যা 'N'।\nআউটপুট: দশমিক উপস্থাপনা একটি অভিব্যক্তি হিসাবে।\nব্যবহারের উদাহরণ:\n>>> convert_to_decimal_expression 2 10101\n1*2^4+1*2^2+1*2^0\n>>> convert_to_decimal_expression 3 102\n1*3^2+2*3^0",
      "bg": "Тази функция преобразува число 'N' от база 'M' към неговото десетично представяне като израз.\nТя извежда израза като сума от членове, всеки член във формата коефициент*база^степен.\nКоефициенти, които са нула, се пропускат в изхода.\nВход: База 'M' и число 'N' в база 'M'.\nИзход: Десетично представяне като израз.\nПример за използване:\n>>> convert_to_decimal_expression 2 10101\n1*2^4+1*2^2+1*2^0\n>>> convert_to_decimal_expression 3 102\n1*3^2+2*3^0",
      "zh": "该函数将数字'N'从基数'M'转换为其十进制表示形式作为表达式。\n它将表达式输出为项的和，每项的形式为系数*基数^幂。\n系数为零的项在输出中省略。\n输入：基数'M'和基数'M'中的数字'N'。\n输出：作为表达式的十进制表示。\n示例用法：\n>>> convert_to_decimal_expression 2 10101\n1*2^4+1*2^2+1*2^0\n>>> convert_to_decimal_expression 3 102\n1*3^2+2*3^0",
      "fr": "Cette fonction convertit un nombre 'N' de la base 'M' en sa représentation décimale sous forme d'expression.\nElle produit l'expression comme une somme de termes, chaque terme étant sous la forme coefficient*base^puissance.\nLes coefficients qui sont zéro sont omis dans la sortie.\nEntrée : Base 'M' et nombre 'N' en base 'M'.\nSortie : Représentation décimale sous forme d'expression.\nExemple d'utilisation :\n>>> convert_to_decimal_expression 2 10101\n1*2^4+1*2^2+1*2^0\n>>> convert_to_decimal_expression 3 102\n1*3^2+2*3^0",
      "de": "Diese Funktion konvertiert eine Zahl 'N' von der Basis 'M' in ihre dezimale Darstellung als Ausdruck.\nSie gibt den Ausdruck als Summe von Termen aus, wobei jeder Term in der Form Koeffizient*Basis^Potenz vorliegt.\nKoeffizienten, die null sind, werden in der Ausgabe weggelassen.\nEingabe: Basis 'M' und Zahl 'N' in der Basis 'M'.\nAusgabe: Dezimale Darstellung als Ausdruck.\nBeispielverwendung:\n>>> convert_to_decimal_expression 2 10101\n1*2^4+1*2^2+1*2^0\n>>> convert_to_decimal_expression 3 102\n1*3^2+2*3^0",
      "ha": "Wannan aikin yana canza lamba 'N' daga tushe 'M' zuwa wakilcin decimal a matsayin wata faɗi.\nYana fitar da faɗin a matsayin jumlar sharudda, kowanne sharadi a cikin nau'i na coefficient*base^power.\nAna cire coefficients waɗanda suke sifili a cikin fitarwa.\nShigarwa: Tushe 'M' da lamba 'N' a cikin tushe 'M'.\nFitarwa: Wakilcin decimal a matsayin faɗi.\nMisalin Amfani:\n>>> convert_to_decimal_expression 2 10101\n1*2^4+1*2^2+1*2^0\n>>> convert_to_decimal_expression 3 102\n1*3^2+2*3^0",
      "hi": "यह फ़ंक्शन संख्या 'N' को आधार 'M' से उसके दशमलव रूपांतरण के रूप में परिवर्तित करता है।\nयह आउटपुट को पदों के योग के रूप में प्रदर्शित करता है, प्रत्येक पद गुणांक*आधार^घात के रूप में होता है।\nगुणांक जो शून्य होते हैं, उन्हें आउटपुट में नहीं दिखाया जाता है।\nइनपुट: आधार 'M' और संख्या 'N' आधार 'M' में।\nआउटपुट: दशमलव रूपांतरण एक अभिव्यक्ति के रूप में।\nउदाहरण उपयोग:\n>>> convert_to_decimal_expression 2 10101\n1*2^4+1*2^2+1*2^0\n>>> convert_to_decimal_expression 3 102\n1*3^2+2*3^0",
      "hu": "Ez a függvény egy 'N' számot 'M' alapból a tizedes ábrázolásba konvertál kifejezésként.\nAz eredmény egy összegként jelenik meg, ahol minden tag a következő formában van: együttható*alap^hatvány.\nAzok az együtthatók, amelyek nulla, kimaradnak az eredményből.\nBemenet: 'M' alap és 'N' szám 'M' alapban.\nKimenet: Tizedes ábrázolás kifejezésként.\nPélda használat:\n>>> convert_to_decimal_expression 2 10101\n1*2^4+1*2^2+1*2^0\n>>> convert_to_decimal_expression 3 102\n1*3^2+2*3^0"
    },
    "docstring_bertscore": {
      "sq": "0.9880571497098963",
      "hy": "0.9674150832519887",
      "bn": "0.9839649665998156",
      "bg": "0.9889972673033345",
      "zh": "0.9789710015598364",
      "fr": "0.9868796688111215",
      "de": "0.9900243850036659",
      "ha": "0.9873921351941916",
      "hi": "0.940829399902374",
      "hu": "0.9596291695761832"
    }
  },
  {
    "task_id": "Shell/29",
    "prompt": {
      "en": "#!/bin/bash\narrange_cards_for_max_number() {\nlocal cards=($1)\n# This function arranges cards with numbers 0 and 5 to form the largest number divisible by 90.\n# If it's not possible to form such a number, the function returns -1.\n# Input: A string of numbers (only 0s and 5s) representing the cards.\n# Output: The largest number divisible by 90 that can be formed, or -1 if it's not possible.\n# Example Usage:\n# >>> arrange_cards_for_max_number \"5 0 5 0\"\n# 0\n# >>> arrange_cards_for_max_number \"5 5 5 5 5 5 5 5 0 5 5\"\n# 5555555550\n# >>> arrange_cards_for_max_number \"5 5\"\n# -1",
      "sq": "#!/bin/bash\narrange_cards_for_max_number() {\nlocal cards=($1)\n# Kjo funksion rregullon kartat me numra 0 dhe 5 për të formuar numrin më të madh të pjesëtueshëm me 90.\n# Nëse nuk është e mundur të formohet një numër i tillë, funksioni kthen -1.\n# Hyrja: Një varg numrash (vetëm 0 dhe 5) që përfaqësojnë kartat.\n# Dalja: Numri më i madh i pjesëtueshëm me 90 që mund të formohet, ose -1 nëse nuk është e mundur.\n# Shembull i Përdorimit:\n# >>> arrange_cards_for_max_number \"5 0 5 0\"\n# 0\n# >>> arrange_cards_for_max_number \"5 5 5 5 5 5 5 5 0 5 5\"\n# 5555555550\n# >>> arrange_cards_for_max_number \"5 5\"\n# -1",
      "hy": "#!/bin/bash\narrange_cards_for_max_number() {\nlocal cards=($1)\n# Այս ֆունկցիան դասավորում է 0 և 5 թվերով քարտերը՝ կազմելու համար 90-ով բաժանվող ամենամեծ թիվը։\n# Եթե հնարավոր չէ կազմել այդպիսի թիվ, ֆունկցիան վերադարձնում է -1։\n# Մուտք: Թվերի տող (միայն 0-ներ և 5-ներ), որը ներկայացնում է քարտերը։\n# Ելք: Ամենամեծ թիվը, որը բաժանվում է 90-ի, կամ -1, եթե հնարավոր չէ։\n# Օրինակ օգտագործում:\n# >>> arrange_cards_for_max_number \"5 0 5 0\"\n# 0\n# >>> arrange_cards_for_max_number \"5 5 5 5 5 5 5 5 0 5 5\"\n# 5555555550\n# >>> arrange_cards_for_max_number \"5 5\"\n# -1",
      "bn": "#!/bin/bash\narrange_cards_for_max_number() {\nlocal cards=($1)\n# এই ফাংশনটি 0 এবং 5 সংখ্যাযুক্ত কার্ডগুলোকে এমনভাবে সাজায় যাতে 90 দ্বারা বিভাজ্য সর্বোচ্চ সংখ্যা গঠন করা যায়।\n# যদি এমন সংখ্যা গঠন করা সম্ভব না হয়, তাহলে ফাংশনটি -1 রিটার্ন করে।\n# ইনপুট: সংখ্যার একটি স্ট্রিং (শুধুমাত্র 0 এবং 5) যা কার্ডগুলোকে উপস্থাপন করে।\n# আউটপুট: 90 দ্বারা বিভাজ্য সর্বোচ্চ সংখ্যা যা গঠন করা যায়, অথবা -1 যদি তা সম্ভব না হয়।\n# উদাহরণ ব্যবহার:\n# >>> arrange_cards_for_max_number \"5 0 5 0\"\n# 0\n# >>> arrange_cards_for_max_number \"5 5 5 5 5 5 5 5 0 5 5\"\n# 5555555550\n# >>> arrange_cards_for_max_number \"5 5\"\n# -1",
      "bg": "#!/bin/bash\narrange_cards_for_max_number() {\nlocal cards=($1)\n# Тази функция подрежда карти с числа 0 и 5, за да образува най-голямото число, делимо на 90.\n# Ако не е възможно да се образува такова число, функцията връща -1.\n# Вход: Низ от числа (само 0 и 5), представляващи картите.\n# Изход: Най-голямото число, делимо на 90, което може да бъде образувано, или -1, ако не е възможно.\n# Пример за използване:\n# >>> arrange_cards_for_max_number \"5 0 5 0\"\n# 0\n# >>> arrange_cards_for_max_number \"5 5 5 5 5 5 5 5 0 5 5\"\n# 5555555550\n# >>> arrange_cards_for_max_number \"5 5\"\n# -1",
      "zh": "#!/bin/bash\narrange_cards_for_max_number() {\nlocal cards=($1)\n# 这个函数将数字0和5的卡片排列成能被90整除的最大数字。\n# 如果无法形成这样的数字，函数返回-1。\n# 输入：一个仅包含0和5的数字字符串，表示卡片。\n# 输出：可以形成的能被90整除的最大数字，如果不可能则返回-1。\n# 示例用法：\n# >>> arrange_cards_for_max_number \"5 0 5 0\"\n# 0\n# >>> arrange_cards_for_max_number \"5 5 5 5 5 5 5 5 0 5 5\"\n# 5555555550\n# >>> arrange_cards_for_max_number \"5 5\"\n# -1",
      "fr": "#!/bin/bash\narrange_cards_for_max_number() {\nlocal cards=($1)\n# Cette fonction arrange les cartes avec les chiffres 0 et 5 pour former le plus grand nombre divisible par 90.\n# S'il n'est pas possible de former un tel nombre, la fonction renvoie -1.\n# Entrée : Une chaîne de chiffres (uniquement des 0 et des 5) représentant les cartes.\n# Sortie : Le plus grand nombre divisible par 90 qui peut être formé, ou -1 si ce n'est pas possible.\n# Exemple d'utilisation :\n# >>> arrange_cards_for_max_number \"5 0 5 0\"\n# 0\n# >>> arrange_cards_for_max_number \"5 5 5 5 5 5 5 5 0 5 5\"\n# 5555555550\n# >>> arrange_cards_for_max_number \"5 5\"\n# -1",
      "de": "#!/bin/bash\narrange_cards_for_max_number() {\nlocal cards=($1)\n# Diese Funktion ordnet Karten mit den Zahlen 0 und 5 so an, dass die größte Zahl entsteht, die durch 90 teilbar ist.\n# Wenn es nicht möglich ist, eine solche Zahl zu bilden, gibt die Funktion -1 zurück.\n# Eingabe: Eine Zeichenkette von Zahlen (nur 0en und 5en), die die Karten darstellen.\n# Ausgabe: Die größte Zahl, die durch 90 teilbar ist und gebildet werden kann, oder -1, wenn es nicht möglich ist.\n# Beispielverwendung:\n# >>> arrange_cards_for_max_number \"5 0 5 0\"\n# 0\n# >>> arrange_cards_for_max_number \"5 5 5 5 5 5 5 5 0 5 5\"\n# 5555555550\n# >>> arrange_cards_for_max_number \"5 5\"\n# -1",
      "ha": "#!/bin/bash\narrange_cards_for_max_number() {\nlocal cards=($1)\n# Wannan aikin yana tsara katunan da ke dauke da lambobi 0 da 5 don samar da babbar lamba da za a iya raba ta da 90.\n# Idan ba zai yiwu a samar da irin wannan lambar ba, aikin zai dawo da -1.\n# Shigarwa: Wata jere na lambobi (kawai 0s da 5s) da ke wakiltar katunan.\n# Fitarwa: Babbar lamba da za a iya raba ta da 90 da za a iya samarwa, ko -1 idan ba zai yiwu ba.\n# Misalin Amfani:\n# >>> arrange_cards_for_max_number \"5 0 5 0\"\n# 0\n# >>> arrange_cards_for_max_number \"5 5 5 5 5 5 5 5 0 5 5\"\n# 5555555550\n# >>> arrange_cards_for_max_number \"5 5\"\n# -1",
      "hi": "#!/bin/bash\narrange_cards_for_max_number() {\nlocal cards=($1)\n# यह फ़ंक्शन कार्ड्स को 0 और 5 के साथ इस प्रकार व्यवस्थित करता है कि सबसे बड़ा संख्या बने जो 90 से विभाज्य हो।\n# यदि ऐसी संख्या बनाना संभव नहीं है, तो फ़ंक्शन -1 लौटाता है।\n# इनपुट: संख्याओं की एक स्ट्रिंग (केवल 0 और 5) जो कार्ड्स का प्रतिनिधित्व करती है।\n# आउटपुट: सबसे बड़ी संख्या जो 90 से विभाज्य हो सकती है, या -1 यदि यह संभव नहीं है।\n# उदाहरण उपयोग:\n# >>> arrange_cards_for_max_number \"5 0 5 0\"\n# 0\n# >>> arrange_cards_for_max_number \"5 5 5 5 5 5 5 5 0 5 5\"\n# 5555555550\n# >>> arrange_cards_for_max_number \"5 5\"\n# -1",
      "hu": "#!/bin/bash\narrange_cards_for_max_number() {\nlocal cards=($1)\n# Ez a függvény a 0 és 5 számokat tartalmazó kártyákat rendezi úgy, hogy a legnagyobb, 90-cel osztható számot alkossa meg.\n# Ha nem lehetséges ilyen számot alkotni, a függvény -1-et ad vissza.\n# Bemenet: Egy számokból álló karakterlánc (csak 0-k és 5-ök), amely a kártyákat jelképezi.\n# Kimenet: A legnagyobb, 90-cel osztható szám, amelyet létre lehet hozni, vagy -1, ha nem lehetséges.\n# Példa használat:\n# >>> arrange_cards_for_max_number \"5 0 5 0\"\n# 0\n# >>> arrange_cards_for_max_number \"5 5 5 5 5 5 5 5 0 5 5\"\n# 5555555550\n# >>> arrange_cards_for_max_number \"5 5\"\n# -1"
    },
    "prompt_bertscore": {
      "sq": "0.984923755449071",
      "hy": "0.9820740053723634",
      "bn": "0.9616077268016716",
      "bg": "0.9884891707886472",
      "zh": "0.9608362464017322",
      "fr": "0.9856632563576638",
      "de": "0.9823717523135347",
      "ha": "0.9884919516139817",
      "hi": "0.9665538219198214",
      "hu": "0.9836543086838769"
    },
    "canonical_solution": "local count_5=0\nlocal count_0=0\n\n# Count the number of 5s and 0s\nfor card in \"${cards[@]}\"; do\nif [[ $card -eq 5 ]]; then\n((count_5++))\nelif [[ $card -eq 0 ]]; then\n((count_0++))\nfi\ndone\n\n# Special case: if only zeros are present, return 0\nif (( count_0 > 0 && count_5 < 9 )); then\necho 0\nreturn\nfi\n\n# Check if it's possible to form a number\nif (( count_0 == 0 || count_5 < 9 )); then\necho -1\nreturn\nfi\n\n# Calculate the number of 5s to use (multiple of 9)\ncount_5=$((count_5 / 9 * 9))\n\n# Construct the largest number\nlocal result=\"\"\nfor (( i=0; i<count_5; i++ )); do\nresult+=\"5\"\ndone\nfor (( i=0; i<count_0; i++ )); do\nresult+=\"0\"\ndone\n\necho $result\n}",
    "instruction": {
      "en": "Write a Shell function `arrange_cards_for_max_number() {\nlocal cards=($1)\n` to solve the following problem:\nThis function arranges cards with numbers 0 and 5 to form the largest number divisible by 90.\nIf it's not possible to form such a number, the function returns -1.\nInput: A string of numbers (only 0s and 5s) representing the cards.\nOutput: The largest number divisible by 90 that can be formed, or -1 if it's not possible.\nExample Usage:\n>>> arrange_cards_for_max_number \"5 0 5 0\"\n0\n>>> arrange_cards_for_max_number \"5 5 5 5 5 5 5 5 0 5 5\"\n5555555550\n>>> arrange_cards_for_max_number \"5 5\"\n-1",
      "sq": "Shkruani një funksion Shell `arrange_cards_for_max_number() {\nlocal cards=($1)\n` për të zgjidhur problemin e mëposhtëm:\nKy funksion rregullon kartat me numra 0 dhe 5 për të formuar numrin më të madh të plotpjesëtueshëm me 90.\nNëse nuk është e mundur të formohet një numër i tillë, funksioni kthen -1.\nHyrja: Një varg numrash (vetëm 0 dhe 5) që përfaqësojnë kartat.\nDalja: Numri më i madh i plotpjesëtueshëm me 90 që mund të formohet, ose -1 nëse nuk është e mundur.\nShembull i Përdorimit:\n>>> arrange_cards_for_max_number \"5 0 5 0\"\n0\n>>> arrange_cards_for_max_number \"5 5 5 5 5 5 5 5 0 5 5\"\n5555555550\n>>> arrange_cards_for_max_number \"5 5\"\n-1",
      "hy": "Գրեք Shell ֆունկցիա `arrange_cards_for_max_number() {\nlocal cards=($1)\n` հետևյալ խնդիրը լուծելու համար:\nԱյս ֆունկցիան դասավորում է 0 և 5 թվերով քարտերը, որպեսզի կազմի 90-ով բաժանվող ամենամեծ թիվը:\nԵթե հնարավոր չէ կազմել այդպիսի թիվ, ֆունկցիան վերադարձնում է -1:\nՄուտք: Թվերի տող (միայն 0-ներ և 5-ներ), որոնք ներկայացնում են քարտերը:\nԵլք: Ամենամեծ թիվը, որը կարող է կազմվել և 90-ով բաժանվում է, կամ -1, եթե դա հնարավոր չէ:\nՕրինակային օգտագործում:\n>>> arrange_cards_for_max_number \"5 0 5 0\"\n0\n>>> arrange_cards_for_max_number \"5 5 5 5 5 5 5 5 0 5 5\"\n5555555550\n>>> arrange_cards_for_max_number \"5 5\"\n-1",
      "bn": "একটি Shell ফাংশন লিখুন `arrange_cards_for_max_number() {\nlocal cards=($1)\n` নিম্নলিখিত সমস্যার সমাধানের জন্য:\nএই ফাংশনটি 0 এবং 5 সংখ্যাযুক্ত কার্ডগুলি এমনভাবে সাজায় যাতে 90 দ্বারা বিভাজ্য সর্বোচ্চ সংখ্যা গঠন করা যায়।\nযদি এমন একটি সংখ্যা গঠন করা সম্ভব না হয়, তাহলে ফাংশনটি -1 রিটার্ন করে।\nইনপুট: একটি সংখ্যার স্ট্রিং (শুধুমাত্র 0 এবং 5) যা কার্ডগুলি উপস্থাপন করে।\nআউটপুট: 90 দ্বারা বিভাজ্য সর্বোচ্চ সংখ্যা যা গঠন করা যেতে পারে, অথবা -1 যদি তা সম্ভব না হয়।\nউদাহরণ ব্যবহার:\n>>> arrange_cards_for_max_number \"5 0 5 0\"\n0\n>>> arrange_cards_for_max_number \"5 5 5 5 5 5 5 5 0 5 5\"\n5555555550\n>>> arrange_cards_for_max_number \"5 5\"\n-1",
      "bg": "Напишете Shell функция `arrange_cards_for_max_number() {\nlocal cards=($1)\n`, за да решите следния проблем:\nТази функция подрежда карти с числа 0 и 5, за да образува най-голямото число, което се дели на 90.\nАко не е възможно да се образува такова число, функцията връща -1.\nВход: Низ от числа (само 0 и 5), представляващи картите.\nИзход: Най-голямото число, което се дели на 90, което може да бъде образувано, или -1, ако не е възможно.\nПример за използване:\n>>> arrange_cards_for_max_number \"5 0 5 0\"\n0\n>>> arrange_cards_for_max_number \"5 5 5 5 5 5 5 5 0 5 5\"\n5555555550\n>>> arrange_cards_for_max_number \"5 5\"\n-1",
      "zh": "编写一个 Shell 函数 `arrange_cards_for_max_number() {\nlocal cards=($1)\n` 来解决以下问题：\n此函数排列带有数字 0 和 5 的卡片，以形成最大可被 90 整除的数字。\n如果无法形成这样的数字，函数返回 -1。\n输入：一个数字字符串（只有 0 和 5）表示卡片。\n输出：可以形成的最大可被 90 整除的数字，或者如果不可能则返回 -1。\n示例用法：\n>>> arrange_cards_for_max_number \"5 0 5 0\"\n0\n>>> arrange_cards_for_max_number \"5 5 5 5 5 5 5 5 0 5 5\"\n5555555550\n>>> arrange_cards_for_max_number \"5 5\"\n-1",
      "fr": "Écrire une fonction Shell `arrange_cards_for_max_number() {\nlocal cards=($1)\n` pour résoudre le problème suivant :\nCette fonction arrange les cartes avec les chiffres 0 et 5 pour former le plus grand nombre divisible par 90.\nS'il n'est pas possible de former un tel nombre, la fonction retourne -1.\nEntrée : Une chaîne de chiffres (uniquement des 0 et des 5) représentant les cartes.\nSortie : Le plus grand nombre divisible par 90 qui peut être formé, ou -1 s'il n'est pas possible.\nExemple d'utilisation :\n>>> arrange_cards_for_max_number \"5 0 5 0\"\n0\n>>> arrange_cards_for_max_number \"5 5 5 5 5 5 5 5 0 5 5\"\n5555555550\n>>> arrange_cards_for_max_number \"5 5\"\n-1",
      "de": "Schreiben Sie eine Shell-Funktion `arrange_cards_for_max_number() {\nlocal cards=($1)\n` um das folgende Problem zu lösen:\nDiese Funktion ordnet Karten mit den Zahlen 0 und 5 so an, dass die größte durch 90 teilbare Zahl entsteht.\nWenn es nicht möglich ist, eine solche Zahl zu bilden, gibt die Funktion -1 zurück.\nEingabe: Eine Zeichenkette von Zahlen (nur 0en und 5en), die die Karten darstellen.\nAusgabe: Die größte durch 90 teilbare Zahl, die gebildet werden kann, oder -1, wenn es nicht möglich ist.\nBeispielverwendung:\n>>> arrange_cards_for_max_number \"5 0 5 0\"\n0\n>>> arrange_cards_for_max_number \"5 5 5 5 5 5 5 5 0 5 5\"\n5555555550\n>>> arrange_cards_for_max_number \"5 5\"\n-1",
      "ha": "Rubuta aikin Shell `arrange_cards_for_max_number() {\nlocal cards=($1)\n` don warware matsalar mai zuwa:\nWannan aikin yana tsara katunan da ke dauke da lambobi 0 da 5 don samar da mafi girman lamba da za a iya rabawa da 90.\nIdan ba zai yiwu a samar da irin wannan lambar ba, aikin zai dawo da -1.\nShigarwa: Wani jeri na lambobi (0s kawai da 5s) da ke wakiltar katunan.\nFitarwa: Mafi girman lamba da za a iya rabawa da 90 da za a iya samarwa, ko -1 idan ba zai yiwu ba.\nMisalin Amfani:\n>>> arrange_cards_for_max_number \"5 0 5 0\"\n0\n>>> arrange_cards_for_max_number \"5 5 5 5 5 5 5 5 0 5 5\"\n5555555550\n>>> arrange_cards_for_max_number \"5 5\"\n-1",
      "hi": "Write a Shell function `arrange_cards_for_max_number() {\nlocal cards=($1)\n` निम्नलिखित समस्या को हल करने के लिए:\nयह फ़ंक्शन 0 और 5 के नंबर वाले कार्ड्स को इस प्रकार व्यवस्थित करता है कि सबसे बड़ा संख्या बने जो 90 से विभाज्य हो।\nयदि ऐसी संख्या बनाना संभव नहीं है, तो फ़ंक्शन -1 लौटाता है।\nइनपुट: संख्याओं की एक स्ट्रिंग (केवल 0 और 5) जो कार्ड्स का प्रतिनिधित्व करती है।\nआउटपुट: सबसे बड़ी संख्या जो 90 से विभाज्य हो सकती है, या -1 यदि यह संभव नहीं है।\nउदाहरण उपयोग:\n>>> arrange_cards_for_max_number \"5 0 5 0\"\n0\n>>> arrange_cards_for_max_number \"5 5 5 5 5 5 5 5 0 5 5\"\n5555555550\n>>> arrange_cards_for_max_number \"5 5\"\n-1",
      "hu": "Írj egy Shell függvényt `arrange_cards_for_max_number() {\nlocal cards=($1)\n` a következő probléma megoldására:\nEz a függvény a 0 és 5 számokat tartalmazó kártyákat rendezi úgy, hogy a legnagyobb, 90-nel osztható számot alkossa.\nHa nem lehetséges ilyen számot alkotni, a függvény -1-et ad vissza.\nBemenet: Egy számsorozat (csak 0-k és 5-ök), amely a kártyákat jelképezi.\nKimenet: A legnagyobb, 90-nel osztható szám, amely alkotható, vagy -1, ha nem lehetséges.\nPélda használat:\n>>> arrange_cards_for_max_number \"5 0 5 0\"\n0\n>>> arrange_cards_for_max_number \"5 5 5 5 5 5 5 5 0 5 5\"\n5555555550\n>>> arrange_cards_for_max_number \"5 5\"\n-1"
    },
    "instruction_bertscore": {
      "sq": "0.9852217010206232",
      "hy": "0.9854004683635547",
      "bn": "0.9591238538868304",
      "bg": "0.9894561034835251",
      "zh": "0.9853527970721063",
      "fr": "0.983853336325674",
      "de": "0.9805656062587844",
      "ha": "0.9874775462580365",
      "hi": "0.9616071309105285",
      "hu": "0.9912294755254045"
    },
    "level": "hard",
    "test": "test_arrange_cards_for_max_number() {\n[[ $(arrange_cards_for_max_number \"5 0 5 0\") == \"0\" ]] || { echo \"Test 1 failed\"; exit 1; }\n[[ $(arrange_cards_for_max_number \"5 5 5 5 5 5 5 5 0 5 5\") == \"5555555550\" ]] || { echo \"Test 2 failed\"; exit 1; }\n[[ $(arrange_cards_for_max_number \"5 5\") == \"-1\" ]] || { echo \"Test 3 failed\"; exit 1; }\n[[ $(arrange_cards_for_max_number \"0 0 0\") == \"0\" ]] || { echo \"Test 4 failed\"; exit 1; }\n[[ $(arrange_cards_for_max_number \"5 5 5 5 5 5 5 5 5 0\") == \"5555555550\" ]] || { echo \"Test 5 failed\"; exit 1; }\n}\n\ntest_arrange_cards_for_max_number",
    "entry_point": "arrange_cards_for_max_number",
    "signature": "arrange_cards_for_max_number() {\nlocal cards=($1)\n",
    "docstring": {
      "en": "This function arranges cards with numbers 0 and 5 to form the largest number divisible by 90.\nIf it's not possible to form such a number, the function returns -1.\nInput: A string of numbers (only 0s and 5s) representing the cards.\nOutput: The largest number divisible by 90 that can be formed, or -1 if it's not possible.\nExample Usage:\n>>> arrange_cards_for_max_number \"5 0 5 0\"\n0\n>>> arrange_cards_for_max_number \"5 5 5 5 5 5 5 5 0 5 5\"\n5555555550\n>>> arrange_cards_for_max_number \"5 5\"\n-1",
      "sq": "Kjo funksion rregullon kartat me numra 0 dhe 5 për të formuar numrin më të madh të plotpjesëtueshëm me 90. Nëse nuk është e mundur të formohet një numër i tillë, funksioni kthen -1. Hyrja: Një varg numrash (vetëm 0 dhe 5) që përfaqësojnë kartat. Dalja: Numri më i madh i plotpjesëtueshëm me 90 që mund të formohet, ose -1 nëse nuk është e mundur. Shembull Përdorimi:\n>>> arrange_cards_for_max_number \"5 0 5 0\"\n0\n>>> arrange_cards_for_max_number \"5 5 5 5 5 5 5 5 0 5 5\"\n5555555550\n>>> arrange_cards_for_max_number \"5 5\"\n-1",
      "hy": "Այս ֆունկցիան դասավորում է 0 և 5 թվերով քարտերը՝ կազմելու համար 90-ով բաժանվող ամենամեծ թիվը։  \nԵթե հնարավոր չէ կազմել այդպիսի թիվ, ֆունկցիան վերադարձնում է -1։  \nՄուտք: Թվերի տող (միայն 0-ներ և 5-ներ), որը ներկայացնում է քարտերը։  \nԵլք: Ամենամեծ թիվը, որը կարելի է կազմել և որը բաժանվում է 90-ով, կամ -1, եթե դա հնարավոր չէ։  \nՕրինակ օգտագործում:  \n>>> arrange_cards_for_max_number \"5 0 5 0\"  \n0  \n>>> arrange_cards_for_max_number \"5 5 5 5 5 5 5 5 0 5 5\"  \n5555555550  \n>>> arrange_cards_for_max_number \"5 5\"  \n-1",
      "bn": "এই ফাংশনটি 0 এবং 5 সংখ্যাযুক্ত কার্ডগুলি সাজিয়ে 90 দ্বারা বিভাজ্য সর্বাধিক সংখ্যাটি তৈরি করে। \nযদি এমন একটি সংখ্যা তৈরি করা সম্ভব না হয়, তাহলে ফাংশনটি -1 রিটার্ন করে। \nইনপুট: একটি সংখ্যার স্ট্রিং (শুধুমাত্র 0 এবং 5) যা কার্ডগুলি উপস্থাপন করে। \nআউটপুট: 90 দ্বারা বিভাজ্য সর্বাধিক সংখ্যাটি যা তৈরি করা যেতে পারে, অথবা যদি তা সম্ভব না হয় তবে -1। \nব্যবহারের উদাহরণ:\n>>> arrange_cards_for_max_number \"5 0 5 0\"\n0\n>>> arrange_cards_for_max_number \"5 5 5 5 5 5 5 5 0 5 5\"\n5555555550\n>>> arrange_cards_for_max_number \"5 5\"\n-1",
      "bg": "Тази функция подрежда карти с числа 0 и 5, за да образува най-голямото число, което се дели на 90.\nАко не е възможно да се образува такова число, функцията връща -1.\nВход: Низ от числа (само 0 и 5), представляващи картите.\nИзход: Най-голямото число, което се дели на 90, което може да бъде образувано, или -1, ако това не е възможно.\nПример за използване:\n>>> arrange_cards_for_max_number \"5 0 5 0\"\n0\n>>> arrange_cards_for_max_number \"5 5 5 5 5 5 5 5 0 5 5\"\n5555555550\n>>> arrange_cards_for_max_number \"5 5\"\n-1",
      "zh": "这个函数排列数字0和5的卡片以形成最大可被90整除的数字。\n如果无法形成这样的数字，函数返回-1。\n输入：一个数字字符串（仅包含0和5）表示卡片。\n输出：可以形成的最大可被90整除的数字，或者如果不可能则返回-1。\n示例用法：\n>>> arrange_cards_for_max_number \"5 0 5 0\"\n0\n>>> arrange_cards_for_max_number \"5 5 5 5 5 5 5 5 0 5 5\"\n5555555550\n>>> arrange_cards_for_max_number \"5 5\"\n-1",
      "fr": "Cette fonction arrange les cartes avec les chiffres 0 et 5 pour former le plus grand nombre divisible par 90.  \nSi ce n'est pas possible de former un tel nombre, la fonction retourne -1.  \nEntrée : Une chaîne de chiffres (uniquement des 0 et des 5) représentant les cartes.  \nSortie : Le plus grand nombre divisible par 90 qui peut être formé, ou -1 si ce n'est pas possible.  \nExemple d'utilisation :  \n>>> arrange_cards_for_max_number \"5 0 5 0\"  \n0  \n>>> arrange_cards_for_max_number \"5 5 5 5 5 5 5 5 0 5 5\"  \n5555555550  \n>>> arrange_cards_for_max_number \"5 5\"  \n-1  ",
      "de": "Diese Funktion ordnet Karten mit den Zahlen 0 und 5, um die größte Zahl zu bilden, die durch 90 teilbar ist.\nWenn es nicht möglich ist, eine solche Zahl zu bilden, gibt die Funktion -1 zurück.\nEingabe: Ein String von Zahlen (nur 0en und 5en), die die Karten darstellen.\nAusgabe: Die größte Zahl, die durch 90 teilbar ist und gebildet werden kann, oder -1, wenn es nicht möglich ist.\nBeispielverwendung:\n>>> arrange_cards_for_max_number \"5 0 5 0\"\n0\n>>> arrange_cards_for_max_number \"5 5 5 5 5 5 5 5 0 5 5\"\n5555555550\n>>> arrange_cards_for_max_number \"5 5\"\n-1",
      "ha": "Wannan aikin yana tsara katunan da ke dauke da lambobi 0 da 5 don samar da babbar lamba da za a iya rabawa da 90.  \nIdan ba zai yiwu a samar da irin wannan lamba ba, aikin yana dawowa da -1.  \nShigarwa: Wani kirtani na lambobi (kawai 0s da 5s) wanda ke wakiltar katunan.  \nFitarwa: Babbar lamba da za a iya rabawa da 90 da za a iya samarwa, ko -1 idan ba zai yiwu ba.  \nMisalin Amfani:  \n>>> arrange_cards_for_max_number \"5 0 5 0\"  \n0  \n>>> arrange_cards_for_max_number \"5 5 5 5 5 5 5 5 0 5 5\"  \n5555555550  \n>>> arrange_cards_for_max_number \"5 5\"  \n-1",
      "hi": "यह फ़ंक्शन 0 और 5 के संख्याओं वाले कार्ड्स को इस प्रकार व्यवस्थित करता है कि सबसे बड़ा संख्या बने जो 90 से विभाज्य हो।  \nयदि ऐसा संख्या बनाना संभव नहीं है, तो फ़ंक्शन -1 लौटाता है।  \nइनपुट: संख्याओं की एक स्ट्रिंग (केवल 0 और 5) जो कार्ड्स का प्रतिनिधित्व करती है।  \nआउटपुट: सबसे बड़ा संख्या जो 90 से विभाज्य है और बन सकती है, या -1 यदि यह संभव नहीं है।  \nउदाहरण उपयोग:  \n>>> arrange_cards_for_max_number \"5 0 5 0\"  \n0  \n>>> arrange_cards_for_max_number \"5 5 5 5 5 5 5 5 0 5 5\"  \n5555555550  \n>>> arrange_cards_for_max_number \"5 5\"  \n-1  ",
      "hu": "Ez a függvény a 0 és 5 számokat tartalmazó kártyákat úgy rendezi el, hogy a lehető legnagyobb, 90-cel osztható számot alkossa meg.\nHa nem lehetséges ilyen számot alkotni, a függvény -1-et ad vissza.\nBemenet: Egy számokból álló karakterlánc (csak 0-k és 5-ök), amely a kártyákat jelképezi.\nKimenet: A legnagyobb, 90-cel osztható szám, amelyet meg lehet alkotni, vagy -1, ha nem lehetséges.\nPélda használat:\n>>> arrange_cards_for_max_number \"5 0 5 0\"\n0\n>>> arrange_cards_for_max_number \"5 5 5 5 5 5 5 5 0 5 5\"\n5555555550\n>>> arrange_cards_for_max_number \"5 5\"\n-1"
    },
    "docstring_bertscore": {
      "sq": "0.98697342235097",
      "hy": "0.9856165782181207",
      "bn": "0.9701110934137752",
      "bg": "0.9818974229636234",
      "zh": "0.9638292089831658",
      "fr": "0.9790919674618866",
      "de": "0.9794788994441426",
      "ha": "0.9824373003392762",
      "hi": "0.9566443508403718",
      "hu": "0.9803435374927875"
    }
  },
  {
    "task_id": "Shell/30",
    "prompt": {
      "en": "calculate_lexicographical_rank() {\nlocal N=$1\nlocal permutation=$2\n# This function calculates the lexicographical rank of a given permutation of numbers from 1 to 'N'.\n# Input: The number of elements 'N' and the permutation 'X' as a string.\n# Output: The lexicographical rank of the permutation.\n# The permutation is considered as a sequence of digits without spaces.\n# Example Usage:\n# >>> calculate_lexicographical_rank 3 \"231\"\n# 4\n# >>> calculate_lexicographical_rank 4 \"2143\"\n# 8",
      "sq": "calculate_lexicographical_rank() {\nlocal N=$1\nlocal permutation=$2\n# Kjo funksion llogarit renditjen leksikografike të një permutacioni të dhënë të numrave nga 1 deri në 'N'.\n# Hyrja: Numri i elementeve 'N' dhe permutacioni 'X' si një varg.\n# Dalja: Renditja leksikografike e permutacionit.\n# Permutacioni konsiderohet si një sekuencë shifrash pa hapësira.\n# Shembull Përdorimi:\n# >>> calculate_lexicographical_rank 3 \"231\"\n# 4\n# >>> calculate_lexicographical_rank 4 \"2143\"\n# 8",
      "hy": "calculate_lexicographical_rank() {\nlocal N=$1\nlocal permutation=$2\n# Այս ֆունկցիան հաշվարկում է 1-ից 'N' թվերի տրված փոխատեղման լեքսիկոգրաֆիական կարգը:\n# Մուտք: Տարրերի քանակը 'N' և փոխատեղումը 'X' որպես տող:\n# Ելք: Փոխատեղման լեքսիկոգրաֆիական կարգը:\n# Փոխատեղումը դիտարկվում է որպես թվանշանների հաջորդականություն առանց բացատների:\n# Օրինակ օգտագործում:\n# >>> calculate_lexicographical_rank 3 \"231\"\n# 4\n# >>> calculate_lexicographical_rank 4 \"2143\"\n# 8",
      "bn": "calculate_lexicographical_rank() {\nlocal N=$1\nlocal permutation=$2\n# এই ফাংশনটি ১ থেকে 'N' পর্যন্ত সংখ্যার একটি প্রদত্ত permutation এর lexicographical rank গণনা করে।\n# ইনপুট: উপাদানের সংখ্যা 'N' এবং permutation 'X' একটি স্ট্রিং হিসেবে।\n# আউটপুট: permutation এর lexicographical rank।\n# permutation টি স্পেস ছাড়া অঙ্কের একটি ক্রম হিসেবে বিবেচিত হয়।\n# উদাহরণ ব্যবহার:\n# >>> calculate_lexicographical_rank 3 \"231\"\n# 4\n# >>> calculate_lexicographical_rank 4 \"2143\"\n# 8",
      "bg": "calculate_lexicographical_rank() {\nlocal N=$1\nlocal permutation=$2\n# Тази функция изчислява лексикографския ранг на дадена пермутация на числа от 1 до 'N'.\n# Вход: Броят на елементите 'N' и пермутацията 'X' като низ.\n# Изход: Лексикографският ранг на пермутацията.\n# Пермутацията се разглежда като последователност от цифри без интервали.\n# Пример за използване:\n# >>> calculate_lexicographical_rank 3 \"231\"\n# 4\n# >>> calculate_lexicographical_rank 4 \"2143\"\n# 8",
      "zh": "calculate_lexicographical_rank() {\nlocal N=$1\nlocal permutation=$2\n# 此函数计算给定从1到'N'的数字排列的字典序排名。\n# 输入: 元素数量'N'和排列'X'作为字符串。\n# 输出: 排列的字典序排名。\n# 排列被视为没有空格的数字序列。\n# 示例用法:\n# >>> calculate_lexicographical_rank 3 \"231\"\n# 4\n# >>> calculate_lexicographical_rank 4 \"2143\"\n# 8",
      "fr": "calculate_lexicographical_rank() {\nlocal N=$1\nlocal permutation=$2\n# Cette fonction calcule le rang lexicographique d'une permutation donnée de nombres de 1 à 'N'.\n# Entrée : Le nombre d'éléments 'N' et la permutation 'X' sous forme de chaîne.\n# Sortie : Le rang lexicographique de la permutation.\n# La permutation est considérée comme une séquence de chiffres sans espaces.\n# Exemple d'utilisation :\n# >>> calculate_lexicographical_rank 3 \"231\"\n# 4\n# >>> calculate_lexicographical_rank 4 \"2143\"\n# 8",
      "de": "calculate_lexicographical_rank() {\nlocal N=$1\nlocal permutation=$2\n# Diese Funktion berechnet den lexikographischen Rang einer gegebenen Permutation von Zahlen von 1 bis 'N'.\n# Eingabe: Die Anzahl der Elemente 'N' und die Permutation 'X' als Zeichenkette.\n# Ausgabe: Der lexikographische Rang der Permutation.\n# Die Permutation wird als eine Folge von Ziffern ohne Leerzeichen betrachtet.\n# Beispielverwendung:\n# >>> calculate_lexicographical_rank 3 \"231\"\n# 4\n# >>> calculate_lexicographical_rank 4 \"2143\"\n# 8",
      "ha": "calculate_lexicographical_rank() {\nlocal N=$1\nlocal permutation=$2\n# Wannan aikin yana ƙididdige matsayi na lexicographical na wata permutation da aka bayar na lambobi daga 1 zuwa 'N'.\n# Shigarwa: Yawan abubuwa 'N' da permutation 'X' a matsayin kirtani.\n# Fitarwa: Matsayin lexicographical na permutation.\n# Ana ɗaukar permutation a matsayin jerin lambobi ba tare da sarari ba.\n# Misalin Amfani:\n# >>> calculate_lexicographical_rank 3 \"231\"\n# 4\n# >>> calculate_lexicographical_rank 4 \"2143\"\n# 8",
      "hi": "calculate_lexicographical_rank() {\nlocal N=$1\nlocal permutation=$2\n# यह फ़ंक्शन 1 से 'N' तक की संख्याओं के दिए गए क्रमचय का शब्दकोशीय क्रमांक गणना करता है।\n# इनपुट: तत्वों की संख्या 'N' और क्रमचय 'X' एक स्ट्रिंग के रूप में।\n# आउटपुट: क्रमचय का शब्दकोशीय क्रमांक।\n# क्रमचय को बिना स्पेस के अंकों की एक श्रृंखला के रूप में माना जाता है।\n# उदाहरण उपयोग:\n# >>> calculate_lexicographical_rank 3 \"231\"\n# 4\n# >>> calculate_lexicographical_rank 4 \"2143\"\n# 8",
      "hu": "calculate_lexicographical_rank() {\nlocal N=$1\nlocal permutation=$2\n# Ez a függvény kiszámítja egy adott permutáció lexikografikus rangját az 1-től 'N'-ig terjedő számok esetén.\n# Bemenet: Az elemek száma 'N' és a permutáció 'X' karakterláncként.\n# Kimenet: A permutáció lexikografikus rangja.\n# A permutációt szóközök nélküli számjegysorozatként kezeljük.\n# Példa használat:\n# >>> calculate_lexicographical_rank 3 \"231\"\n# 4\n# >>> calculate_lexicographical_rank 4 \"2143\"\n# 8"
    },
    "prompt_bertscore": {
      "sq": "1",
      "hy": "0.9915047772335188",
      "bn": "0.9854560848702445",
      "bg": "0.9991534373160293",
      "zh": "0.9817836077552904",
      "fr": "0.9961785500992698",
      "de": "0.9991534373160293",
      "ha": "0.9886468833111889",
      "hi": "0.9812530660075462",
      "hu": "0.9846538167612445"
    },
    "canonical_solution": "local rank=0\nlocal factorial=1\nlocal smaller\n\n# Function to calculate factorial\ncalculate_factorial() {\nlocal num=$1\nlocal fact=1\nfor (( i=1; i<=num; i++ )); do\nfact=$((fact * i))\ndone\necho $fact\n}\n\nfor (( i=0; i<N-1; i++ )); do\nsmaller=0\nfor (( j=i+1; j<N; j++ )); do\nif [[ ${permutation:i:1} > ${permutation:j:1} ]]; then\n((smaller++))\nfi\ndone\nfactorial=$(calculate_factorial $((N-i-1)))\nrank=$((rank + smaller * factorial))\ndone\n\n# Adding 1 because rank starts from 1\necho $((rank + 1))\n}",
    "instruction": {
      "en": "Write a Shell function `calculate_lexicographical_rank() {\nlocal N=$1\nlocal permutation=$2\n` to solve the following problem:\nThis function calculates the lexicographical rank of a given permutation of numbers from 1 to 'N'.\nInput: The number of elements 'N' and the permutation 'X' as a string.\nOutput: The lexicographical rank of the permutation.\nThe permutation is considered as a sequence of digits without spaces.\nExample Usage:\n>>> calculate_lexicographical_rank 3 \"231\"\n4\n>>> calculate_lexicographical_rank 4 \"2143\"\n8",
      "sq": "Shkruani një funksion Shell `calculate_lexicographical_rank() {\nlocal N=$1\nlocal permutation=$2\n` për të zgjidhur problemin e mëposhtëm:\nKy funksion llogarit rendin leksikografik të një permutacioni të dhënë të numrave nga 1 deri në 'N'.\nHyrja: Numri i elementeve 'N' dhe permutacioni 'X' si një varg.\nDalja: Rendi leksikografik i permutacionit.\nPermutacioni konsiderohet si një sekuencë shifrash pa hapësira.\nShembull Përdorimi:\n>>> calculate_lexicographical_rank 3 \"231\"\n4\n>>> calculate_lexicographical_rank 4 \"2143\"\n8",
      "hy": "Գրեք Shell ֆունկցիա `calculate_lexicographical_rank() {\nlocal N=$1\nlocal permutation=$2\n` հետևյալ խնդիրը լուծելու համար:\nԱյս ֆունկցիան հաշվարկում է տրված թվերի 1-ից 'N' լեքսիկոգրաֆիական կարգը:\nՄուտք: Տարրերի քանակը 'N' և փոխատեղումը 'X' որպես տող:\nԵլք: Փոխատեղման լեքսիկոգրաֆիական կարգը:\nՓոխատեղումը համարվում է թվանշանների հաջորդականություն առանց բացատների:\nՕրինակ օգտագործում:\n>>> calculate_lexicographical_rank 3 \"231\"\n4\n>>> calculate_lexicographical_rank 4 \"2143\"\n8",
      "bn": "একটি Shell ফাংশন লিখুন `calculate_lexicographical_rank() {\nlocal N=$1\nlocal permutation=$2\n` নিম্নলিখিত সমস্যার সমাধানের জন্য:\nএই ফাংশনটি 1 থেকে 'N' পর্যন্ত সংখ্যার একটি প্রদত্ত permutation-এর লেক্সিকোগ্রাফিক্যাল র‍্যাঙ্ক গণনা করে।\nইনপুট: উপাদানের সংখ্যা 'N' এবং permutation 'X' একটি স্ট্রিং হিসেবে।\nআউটপুট: permutation-এর লেক্সিকোগ্রাফিক্যাল র‍্যাঙ্ক।\npermutation-টি কোনো ফাঁকা স্থান ছাড়া অঙ্কের একটি ক্রম হিসেবে বিবেচিত হয়।\nউদাহরণ ব্যবহার:\n>>> calculate_lexicographical_rank 3 \"231\"\n4\n>>> calculate_lexicographical_rank 4 \"2143\"\n8",
      "bg": "Напишете Shell функция `calculate_lexicographical_rank() {\nlocal N=$1\nlocal permutation=$2\n` за решаване на следния проблем:\nТази функция изчислява лексикографския ранг на дадена пермутация на числа от 1 до 'N'.\nВход: Броят на елементите 'N' и пермутацията 'X' като низ.\nИзход: Лексикографският ранг на пермутацията.\nПермутацията се разглежда като последователност от цифри без интервали.\nПримерна употреба:\n>>> calculate_lexicographical_rank 3 \"231\"\n4\n>>> calculate_lexicographical_rank 4 \"2143\"\n8",
      "zh": "编写一个 Shell 函数 `calculate_lexicographical_rank() {\nlocal N=$1\nlocal permutation=$2\n` 来解决以下问题：\n此函数计算给定的从 1 到 'N' 的数字排列的字典序排名。\n输入：元素数量 'N' 和排列 'X' 作为一个字符串。\n输出：排列的字典序排名。\n排列被视为没有空格的数字序列。\n示例用法：\n>>> calculate_lexicographical_rank 3 \"231\"\n4\n>>> calculate_lexicographical_rank 4 \"2143\"\n8",
      "fr": "Écrire une fonction Shell `calculate_lexicographical_rank() {\nlocal N=$1\nlocal permutation=$2\n` pour résoudre le problème suivant :\nCette fonction calcule le rang lexicographique d'une permutation donnée de nombres de 1 à 'N'.\nEntrée : Le nombre d'éléments 'N' et la permutation 'X' sous forme de chaîne de caractères.\nSortie : Le rang lexicographique de la permutation.\nLa permutation est considérée comme une séquence de chiffres sans espaces.\nExemple d'utilisation :\n>>> calculate_lexicographical_rank 3 \"231\"\n4\n>>> calculate_lexicographical_rank 4 \"2143\"\n8",
      "de": "Schreiben Sie eine Shell-Funktion `calculate_lexicographical_rank() {\nlocal N=$1\nlocal permutation=$2\n` um das folgende Problem zu lösen:\nDiese Funktion berechnet den lexikographischen Rang einer gegebenen Permutation von Zahlen von 1 bis 'N'.\nEingabe: Die Anzahl der Elemente 'N' und die Permutation 'X' als Zeichenkette.\nAusgabe: Der lexikographische Rang der Permutation.\nDie Permutation wird als eine Folge von Ziffern ohne Leerzeichen betrachtet.\nBeispielverwendung:\n>>> calculate_lexicographical_rank 3 \"231\"\n4\n>>> calculate_lexicographical_rank 4 \"2143\"\n8",
      "ha": "Rubuta aikin Shell `calculate_lexicographical_rank() {\nlocal N=$1\nlocal permutation=$2\n` don warware matsalar mai zuwa:\nWannan aikin yana ƙididdige matsayi na lexicographical na wata permutation da aka bayar na lambobi daga 1 zuwa 'N'.\nShigarwa: Yawan abubuwa 'N' da permutation 'X' a matsayin kirtani.\nFitarwa: Matsayi na lexicographical na permutation.\nAna ɗaukar permutation a matsayin jerin lambobi ba tare da sarari ba.\nMisalin Amfani:\n>>> calculate_lexicographical_rank 3 \"231\"\n4\n>>> calculate_lexicographical_rank 4 \"2143\"\n8",
      "hi": "Shell फ़ंक्शन `calculate_lexicographical_rank() {\nlocal N=$1\nlocal permutation=$2\n` निम्नलिखित समस्या को हल करने के लिए:\nयह फ़ंक्शन 1 से 'N' तक के संख्याओं के दिए गए क्रमचय का शब्दकोशीय क्रमांक गणना करता है।\nइनपुट: तत्वों की संख्या 'N' और क्रमचय 'X' एक स्ट्रिंग के रूप में।\nआउटपुट: क्रमचय का शब्दकोशीय क्रमांक।\nक्रमचय को बिना स्पेस के अंकों की एक श्रृंखला के रूप में माना जाता है।\nउदाहरण उपयोग:\n>>> calculate_lexicographical_rank 3 \"231\"\n4\n>>> calculate_lexicographical_rank 4 \"2143\"\n8",
      "hu": "Írj egy Shell függvényt `calculate_lexicographical_rank() {\nlocal N=$1\nlocal permutation=$2\n` a következő probléma megoldására:\nEz a függvény kiszámítja egy adott permutáció lexikografikus rangját az 1-től 'N'-ig terjedő számok esetén.\nBemenet: Az elemek száma 'N' és a permutáció 'X' karakterláncként.\nKimenet: A permutáció lexikografikus rangja.\nA permutációt szóközök nélküli számjegysorként kell tekinteni.\nPélda használat:\n>>> calculate_lexicographical_rank 3 \"231\"\n4\n>>> calculate_lexicographical_rank 4 \"2143\"\n8"
    },
    "instruction_bertscore": {
      "sq": "1",
      "hy": "0.9745608112097187",
      "bn": "0.9858549346753626",
      "bg": "0.9990352522393136",
      "zh": "0.9834336303305472",
      "fr": "0.9990352522393136",
      "de": "0.9970984073938424",
      "ha": "0.9809491615245628",
      "hi": "0.9693745719608978",
      "hu": "0.9840380625800363"
    },
    "level": "middle",
    "test": "test_calculate_lexicographical_rank() {\n[[ $(calculate_lexicographical_rank 3 \"231\") -eq 4 ]] || { echo \"Test 1 failed\"; exit 1; }\n[[ $(calculate_lexicographical_rank 4 \"2143\") -eq 8 ]] || { echo \"Test 2 failed\"; exit 1; }\n[[ $(calculate_lexicographical_rank 5 \"31245\") -eq 49 ]] || { echo \"Test 3 failed\"; exit 1; }\n[[ $(calculate_lexicographical_rank 3 \"123\") -eq 1 ]] || { echo \"Test 4 failed\"; exit 1; }\n[[ $(calculate_lexicographical_rank 4 \"4321\") -eq 24 ]] || { echo \"Test 5 failed\"; exit 1; }\n}\n\ntest_calculate_lexicographical_rank",
    "entry_point": "calculate_lexicographical_rank",
    "signature": "calculate_lexicographical_rank() {\nlocal N=$1\nlocal permutation=$2\n",
    "docstring": {
      "en": "This function calculates the lexicographical rank of a given permutation of numbers from 1 to 'N'.\nInput: The number of elements 'N' and the permutation 'X' as a string.\nOutput: The lexicographical rank of the permutation.\nThe permutation is considered as a sequence of digits without spaces.\nExample Usage:\n>>> calculate_lexicographical_rank 3 \"231\"\n4\n>>> calculate_lexicographical_rank 4 \"2143\"\n8",
      "sq": "Kjo funksion llogarit renditjen leksikografike të një permutacioni të dhënë të numrave nga 1 në 'N'.\nHyrja: Numri i elementeve 'N' dhe permutacioni 'X' si një varg.\nDalja: Renditja leksikografike e permutacionit.\nPermutacioni konsiderohet si një sekuencë shifrash pa hapësira.\nShembull Përdorimi:\n>>> calculate_lexicographical_rank 3 \"231\"\n4\n>>> calculate_lexicographical_rank 4 \"2143\"\n8",
      "hy": "Այս ֆունկցիան հաշվարկում է թվերի տրված փոխատեղման բառարանային կարգը 1-ից մինչև 'N':\nՄուտք: Տարրերի քանակը 'N' և փոխատեղումը 'X' որպես տող:\nԵլք: Փոխատեղման բառարանային կարգը:\nՓոխատեղումը համարվում է թվանշանների հաջորդականություն առանց բացատների:\nՕրինակ օգտագործում:\n>>> calculate_lexicographical_rank 3 \"231\"\n4\n>>> calculate_lexicographical_rank 4 \"2143\"\n8",
      "bn": "এই ফাংশনটি সংখ্যা 1 থেকে 'N' পর্যন্ত একটি প্রদত্ত বিন্যাসের শব্দকোষিক স্থান গণনা করে।  \nইনপুট: উপাদান সংখ্যা 'N' এবং বিন্যাস 'X' একটি স্ট্রিং হিসাবে।  \nআউটপুট: বিন্যাসের শব্দকোষিক স্থান।  \nবিন্যাসটি কোনো ফাঁক ছাড়া অঙ্কের একটি ক্রম হিসাবে বিবেচিত হয়।  \nউদাহরণ ব্যবহার:  \n>>> calculate_lexicographical_rank 3 \"231\"  \n4  \n>>> calculate_lexicographical_rank 4 \"2143\"  \n8  ",
      "bg": "Тази функция изчислява лексикографския ранг на дадена пермутация от числа от 1 до 'N'.\nВход: Броят на елементите 'N' и пермутацията 'X' като низ.\nИзход: Лексикографският ранг на пермутацията.\nПермутацията се разглежда като последователност от цифри без интервали.\nПример за използване:\n>>> calculate_lexicographical_rank 3 \"231\"\n4\n>>> calculate_lexicographical_rank 4 \"2143\"\n8",
      "zh": "该函数计算给定从1到'N'的数字排列的字典序排名。\n输入：元素数量'N'和排列'X'作为一个字符串。\n输出：排列的字典序排名。\n排列被视为没有空格的数字序列。\n示例用法：\n>>> calculate_lexicographical_rank 3 \"231\"\n4\n>>> calculate_lexicographical_rank 4 \"2143\"\n8",
      "fr": "Cette fonction calcule le rang lexicographique d'une permutation donnée de nombres de 1 à 'N'.\nEntrée : Le nombre d'éléments 'N' et la permutation 'X' sous forme de chaîne.\nSortie : Le rang lexicographique de la permutation.\nLa permutation est considérée comme une séquence de chiffres sans espaces.\nExemple d'utilisation :\n>>> calculate_lexicographical_rank 3 \"231\"\n4\n>>> calculate_lexicographical_rank 4 \"2143\"\n8",
      "de": "Diese Funktion berechnet den lexikographischen Rang einer gegebenen Permutation von Zahlen von 1 bis 'N'.\nEingabe: Die Anzahl der Elemente 'N' und die Permutation 'X' als Zeichenkette.\nAusgabe: Der lexikographische Rang der Permutation.\nDie Permutation wird als eine Folge von Ziffern ohne Leerzeichen betrachtet.\nBeispielverwendung:\n>>> calculate_lexicographical_rank 3 \"231\"\n4\n>>> calculate_lexicographical_rank 4 \"2143\"\n8",
      "ha": "Wannan aikin yana ƙididdige matsayi na haruffa na wata permutation da aka bayar na lambobi daga 1 zuwa 'N'.\nShigarwa: Yawan abubuwan 'N' da permutation 'X' a matsayin kirtani.\nFitarwa: Matsayin haruffa na permutation.\nAna ɗaukar permutation a matsayin jerin lambobi ba tare da sarari ba.\nMisalin Amfani:\n>>> calculate_lexicographical_rank 3 \"231\"\n4\n>>> calculate_lexicographical_rank 4 \"2143\"\n8",
      "hi": "यह फ़ंक्शन 1 से 'N' तक की संख्याओं के दिए गए क्रमचय की शब्दकोशीय रैंक की गणना करता है।\nइनपुट: तत्वों की संख्या 'N' और क्रमचय 'X' एक स्ट्रिंग के रूप में।\nआउटपुट: क्रमचय की शब्दकोशीय रैंक।\nक्रमचय को बिना स्पेस के अंकों की अनुक्रम के रूप में माना जाता है।\nउदाहरण उपयोग:\n>>> calculate_lexicographical_rank 3 \"231\"\n4\n>>> calculate_lexicographical_rank 4 \"2143\"\n8",
      "hu": "Ez a függvény kiszámítja egy adott permutáció lexikografikus rangját az 1-től 'N'-ig terjedő számok esetében.\nBemenet: Az elemek száma 'N' és a permutáció 'X' karakterláncként.\nKimenet: A permutáció lexikografikus rangja.\nA permutációt szóközök nélküli számjegysorozatként kezeljük.\nHasználati példa:\n>>> calculate_lexicographical_rank 3 \"231\"\n4\n>>> calculate_lexicographical_rank 4 \"2143\"\n8"
    },
    "docstring_bertscore": {
      "sq": "1",
      "hy": "0.9815742513336796",
      "bn": "0.9587220246259968",
      "bg": "0.9987347244728078",
      "zh": "0.9766537795346834",
      "fr": "0.9904776595331874",
      "de": "0.9987347244728078",
      "ha": "0.9870272511842304",
      "hi": "0.9815742513336796",
      "hu": "0.9794798925960477"
    }
  },
  {
    "task_id": "Shell/31",
    "prompt": {
      "en": "calculate_max_subsequence_sum() {\nlocal sequence=($1)\n# This function finds the maximum sum of a continuous non-empty subsequence in a given sequence of integers.\n# Input: A string of integers representing the sequence.\n# Output: The maximum sum of a continuous non-empty subsequence.\n# Example Usage:\n# >>> calculate_max_subsequence_sum \"2 -4 3 -1 2 -4 3\"\n# 4\n# >>> calculate_max_subsequence_sum \"-1 -2 -3 -4\"\n# -1\n# >>> calculate_max_subsequence_sum \"1 2 3 4 -10 5 6\"\n# 11",
      "sq": "calculate_max_subsequence_sum() {\nlocal sequence=($1)\n# Kjo funksion gjen shumën maksimale të një nënsekuence të vazhdueshme jo-bosh në një sekuencë të dhënë të numrave të plotë.\n# Hyrja: Një varg numrash të plotë që përfaqëson sekuencën.\n# Dalja: Shuma maksimale e një nënsekuence të vazhdueshme jo-bosh.\n# Shembull Përdorimi:\n# >>> calculate_max_subsequence_sum \"2 -4 3 -1 2 -4 3\"\n# 4\n# >>> calculate_max_subsequence_sum \"-1 -2 -3 -4\"\n# -1\n# >>> calculate_max_subsequence_sum \"1 2 3 4 -10 5 6\"\n# 11",
      "hy": "calculate_max_subsequence_sum() {\nlocal sequence=($1)\n# Այս ֆունկցիան գտնում է շարունակական ոչ դատարկ ենթահաջորդականության առավելագույն գումարը տրված ամբողջ թվերի հաջորդականությունում։\n# Մուտք: Ամբողջ թվերի հաջորդականությունը ներկայացնող տող։\n# Ելք: Շարունակական ոչ դատարկ ենթահաջորդականության առավելագույն գումարը։\n# Օրինակ օգտագործում:\n# >>> calculate_max_subsequence_sum \"2 -4 3 -1 2 -4 3\"\n# 4\n# >>> calculate_max_subsequence_sum \"-1 -2 -3 -4\"\n# -1\n# >>> calculate_max_subsequence_sum \"1 2 3 4 -10 5 6\"\n# 11",
      "bn": "calculate_max_subsequence_sum() {\nlocal sequence=($1)\n# এই ফাংশনটি একটি প্রদত্ত পূর্ণসংখ্যার সিকোয়েন্সে একটি ধারাবাহিক অ-খালি উপসিকোয়েন্সের সর্বাধিক যোগফল খুঁজে বের করে।\n# ইনপুট: পূর্ণসংখ্যার একটি স্ট্রিং যা সিকোয়েন্সকে উপস্থাপন করে।\n# আউটপুট: একটি ধারাবাহিক অ-খালি উপসিকোয়েন্সের সর্বাধিক যোগফল।\n# উদাহরণ ব্যবহার:\n# >>> calculate_max_subsequence_sum \"2 -4 3 -1 2 -4 3\"\n# 4\n# >>> calculate_max_subsequence_sum \"-1 -2 -3 -4\"\n# -1\n# >>> calculate_max_subsequence_sum \"1 2 3 4 -10 5 6\"\n# 11",
      "bg": "calculate_max_subsequence_sum() {\nlocal sequence=($1)\n# Тази функция намира максималната сума на непрекъсната непразна подредица в дадена последователност от цели числа.\n# Вход: Низ от цели числа, представляващ последователността.\n# Изход: Максималната сума на непрекъсната непразна подредица.\n# Пример за използване:\n# >>> calculate_max_subsequence_sum \"2 -4 3 -1 2 -4 3\"\n# 4\n# >>> calculate_max_subsequence_sum \"-1 -2 -3 -4\"\n# -1\n# >>> calculate_max_subsequence_sum \"1 2 3 4 -10 5 6\"\n# 11",
      "zh": "calculate_max_subsequence_sum() {\nlocal sequence=($1)\n# 此函数在给定的整数序列中找到连续非空子序列的最大和。\n# 输入：表示序列的整数字符串。\n# 输出：连续非空子序列的最大和。\n# 示例用法：\n# >>> calculate_max_subsequence_sum \"2 -4 3 -1 2 -4 3\"\n# 4\n# >>> calculate_max_subsequence_sum \"-1 -2 -3 -4\"\n# -1\n# >>> calculate_max_subsequence_sum \"1 2 3 4 -10 5 6\"\n# 11",
      "fr": "calculate_max_subsequence_sum() {\nlocal sequence=($1)\n# Cette fonction trouve la somme maximale d'une sous-séquence continue non vide dans une séquence donnée d'entiers.\n# Entrée : Une chaîne d'entiers représentant la séquence.\n# Sortie : La somme maximale d'une sous-séquence continue non vide.\n# Exemple d'utilisation :\n# >>> calculate_max_subsequence_sum \"2 -4 3 -1 2 -4 3\"\n# 4\n# >>> calculate_max_subsequence_sum \"-1 -2 -3 -4\"\n# -1\n# >>> calculate_max_subsequence_sum \"1 2 3 4 -10 5 6\"\n# 11",
      "de": "calculate_max_subsequence_sum() {\nlocal sequence=($1)\n# Diese Funktion findet die maximale Summe einer kontinuierlichen, nicht-leeren Teilsequenz in einer gegebenen Sequenz von ganzen Zahlen.\n# Eingabe: Eine Zeichenkette von ganzen Zahlen, die die Sequenz darstellt.\n# Ausgabe: Die maximale Summe einer kontinuierlichen, nicht-leeren Teilsequenz.\n# Beispielverwendung:\n# >>> calculate_max_subsequence_sum \"2 -4 3 -1 2 -4 3\"\n# 4\n# >>> calculate_max_subsequence_sum \"-1 -2 -3 -4\"\n# -1\n# >>> calculate_max_subsequence_sum \"1 2 3 4 -10 5 6\"\n# 11",
      "ha": "calculate_max_subsequence_sum() {\nlocal sequence=($1)\n# Wannan aikin yana nemo mafi girman jimillar wani jere mara fanko mai ci gaba a cikin wata jerin lambobi.\n# Shigarwa: Wani jeri na lambobi da ke wakiltar jerin.\n# Fitarwa: Mafi girman jimillar wani jere mara fanko mai ci gaba.\n# Misalin Amfani:\n# >>> calculate_max_subsequence_sum \"2 -4 3 -1 2 -4 3\"\n# 4\n# >>> calculate_max_subsequence_sum \"-1 -2 -3 -4\"\n# -1\n# >>> calculate_max_subsequence_sum \"1 2 3 4 -10 5 6\"\n# 11",
      "hi": "calculate_max_subsequence_sum() {\nlocal sequence=($1)\n# यह फ़ंक्शन दिए गए पूर्णांकों के अनुक्रम में एक सतत गैर-खाली उप-अनुक्रम का अधिकतम योग खोजता है।\n# इनपुट: पूर्णांकों के अनुक्रम का प्रतिनिधित्व करने वाली एक स्ट्रिंग।\n# आउटपुट: एक सतत गैर-खाली उप-अनुक्रम का अधिकतम योग।\n# उदाहरण उपयोग:\n# >>> calculate_max_subsequence_sum \"2 -4 3 -1 2 -4 3\"\n# 4\n# >>> calculate_max_subsequence_sum \"-1 -2 -3 -4\"\n# -1\n# >>> calculate_max_subsequence_sum \"1 2 3 4 -10 5 6\"\n# 11",
      "hu": "calculate_max_subsequence_sum() {\nlocal sequence=($1)\n# Ez a függvény megkeresi a maximális összegét egy folytonos, nem üres részszekvenciának egy adott egész számokból álló sorozatban.\n# Bemenet: Egy egész számokat tartalmazó karakterlánc, amely a sorozatot reprezentálja.\n# Kimenet: Egy folytonos, nem üres részszekvencia maximális összege.\n# Példa használat:\n# >>> calculate_max_subsequence_sum \"2 -4 3 -1 2 -4 3\"\n# 4\n# >>> calculate_max_subsequence_sum \"-1 -2 -3 -4\"\n# -1\n# >>> calculate_max_subsequence_sum \"1 2 3 4 -10 5 6\"\n# 11"
    },
    "prompt_bertscore": {
      "sq": "0.9933750809013434",
      "hy": "0.985396098495172",
      "bn": "0.9917854419619212",
      "bg": "0.999345314264109",
      "zh": "0.9857516468772244",
      "fr": "0.9951965214954333",
      "de": "0.9894904665394441",
      "ha": "0.9622107686384935",
      "hi": "0.991266420776277",
      "hu": "0.98615963367987"
    },
    "canonical_solution": "local max_so_far=0\n    local max_ending_here=0\n\n    for num in \"${sequence[@]}\"; do\n        max_ending_here=$((max_ending_here + num))\n        if (( max_ending_here < 0 )); then\n            max_ending_here=0\n        elif (( max_so_far < max_ending_here )); then\n            max_so_far=$max_ending_here\n        fi\n    done\n\n    if (( max_so_far == 0 )); then\n        max_so_far=${sequence[0]}\n        for num in \"${sequence[@]}\"; do\n            if (( num > max_so_far )); then\n                max_so_far=$num\n            fi\n        done\n    fi\n\n    echo $max_so_far\n}",
    "instruction": {
      "en": "Write a Shell function `calculate_max_subsequence_sum() {\nlocal sequence=($1)\n` to solve the following problem:\nThis function finds the maximum sum of a continuous non-empty subsequence in a given sequence of integers.\nInput: A string of integers representing the sequence.\nOutput: The maximum sum of a continuous non-empty subsequence.\nExample Usage:\n>>> calculate_max_subsequence_sum \"2 -4 3 -1 2 -4 3\"\n4\n>>> calculate_max_subsequence_sum \"-1 -2 -3 -4\"\n-1\n>>> calculate_max_subsequence_sum \"1 2 3 4 -10 5 6\"\n11",
      "sq": "Shkruani një funksion Shell `calculate_max_subsequence_sum() {\nlocal sequence=($1)\n` për të zgjidhur problemin e mëposhtëm:\nKy funksion gjen shumën maksimale të një nënsekuence të vazhdueshme jo-bosh në një sekuencë të dhënë të numrave të plotë.\nHyrja: Një varg numrash të plotë që përfaqëson sekuencën.\nDalja: Shuma maksimale e një nënsekuence të vazhdueshme jo-bosh.\nShembull i Përdorimit:\n>>> calculate_max_subsequence_sum \"2 -4 3 -1 2 -4 3\"\n4\n>>> calculate_max_subsequence_sum \"-1 -2 -3 -4\"\n-1\n>>> calculate_max_subsequence_sum \"1 2 3 4 -10 5 6\"\n11",
      "hy": "Գրեք Shell ֆունկցիա `calculate_max_subsequence_sum() {\nlocal sequence=($1)\n` հետևյալ խնդիրը լուծելու համար:\nԱյս ֆունկցիան գտնում է շարունակական ոչ դատարկ ենթահաջորդականության առավելագույն գումարը տրված ամբողջ թվերի հաջորդականության մեջ:\nՄուտք: Հաջորդականությունը ներկայացնող ամբողջ թվերի տող:\nԵլք: Շարունակական ոչ դատարկ ենթահաջորդականության առավելագույն գումարը:\nՕրինակ օգտագործում:\n>>> calculate_max_subsequence_sum \"2 -4 3 -1 2 -4 3\"\n4\n>>> calculate_max_subsequence_sum \"-1 -2 -3 -4\"\n-1\n>>> calculate_max_subsequence_sum \"1 2 3 4 -10 5 6\"\n11",
      "bn": "`calculate_max_subsequence_sum() {\nlocal sequence=($1)\n` নিম্নলিখিত সমস্যার সমাধান করতে:\nএই ফাংশনটি একটি প্রদত্ত পূর্ণসংখ্যার সিকোয়েন্সে একটি ধারাবাহিক নন-এম্পটি উপসিকোয়েন্সের সর্বাধিক যোগফল খুঁজে বের করে।\nইনপুট: পূর্ণসংখ্যার একটি স্ট্রিং যা সিকোয়েন্সকে উপস্থাপন করে।\nআউটপুট: একটি ধারাবাহিক নন-এম্পটি উপসিকোয়েন্সের সর্বাধিক যোগফল।\nউদাহরণ ব্যবহার:\n>>> calculate_max_subsequence_sum \"2 -4 3 -1 2 -4 3\"\n4\n>>> calculate_max_subsequence_sum \"-1 -2 -3 -4\"\n-1\n>>> calculate_max_subsequence_sum \"1 2 3 4 -10 5 6\"\n11",
      "bg": "Напишете Shell функция `calculate_max_subsequence_sum() {\nlocal sequence=($1)\n` за решаване на следния проблем:\nТази функция намира максималната сума на непрекъсната непразна подредица в дадена последователност от цели числа.\nВход: Низ от цели числа, представляващ последователността.\nИзход: Максималната сума на непрекъсната непразна подредица.\nПример за използване:\n>>> calculate_max_subsequence_sum \"2 -4 3 -1 2 -4 3\"\n4\n>>> calculate_max_subsequence_sum \"-1 -2 -3 -4\"\n-1\n>>> calculate_max_subsequence_sum \"1 2 3 4 -10 5 6\"\n11",
      "zh": "编写一个 Shell 函数 `calculate_max_subsequence_sum() {\nlocal sequence=($1)\n` 来解决以下问题：\n此函数在给定的整数序列中找到连续非空子序列的最大和。\n输入：表示序列的整数字符串。\n输出：连续非空子序列的最大和。\n示例用法：\n>>> calculate_max_subsequence_sum \"2 -4 3 -1 2 -4 3\"\n4\n>>> calculate_max_subsequence_sum \"-1 -2 -3 -4\"\n-1\n>>> calculate_max_subsequence_sum \"1 2 3 4 -10 5 6\"\n11",
      "fr": "Écrire une fonction Shell `calculate_max_subsequence_sum() {\nlocal sequence=($1)\n` pour résoudre le problème suivant :\nCette fonction trouve la somme maximale d'une sous-séquence continue non vide dans une séquence donnée d'entiers.\nEntrée : Une chaîne d'entiers représentant la séquence.\nSortie : La somme maximale d'une sous-séquence continue non vide.\nExemple d'utilisation :\n>>> calculate_max_subsequence_sum \"2 -4 3 -1 2 -4 3\"\n4\n>>> calculate_max_subsequence_sum \"-1 -2 -3 -4\"\n-1\n>>> calculate_max_subsequence_sum \"1 2 3 4 -10 5 6\"\n11",
      "de": "Schreiben Sie eine Shell-Funktion `calculate_max_subsequence_sum() {\nlocal sequence=($1)\n` um das folgende Problem zu lösen:\nDiese Funktion findet die maximale Summe einer kontinuierlichen, nicht-leeren Teilsequenz in einer gegebenen Sequenz von ganzen Zahlen.\nEingabe: Eine Zeichenkette von ganzen Zahlen, die die Sequenz darstellt.\nAusgabe: Die maximale Summe einer kontinuierlichen, nicht-leeren Teilsequenz.\nBeispielverwendung:\n>>> calculate_max_subsequence_sum \"2 -4 3 -1 2 -4 3\"\n4\n>>> calculate_max_subsequence_sum \"-1 -2 -3 -4\"\n-1\n>>> calculate_max_subsequence_sum \"1 2 3 4 -10 5 6\"\n11",
      "ha": "Rubuta wani aikin Shell `calculate_max_subsequence_sum() {\nlocal sequence=($1)\n` don warware matsalar mai zuwa:\nWannan aikin yana nemo mafi girman jimlar wata jere mai ci gaba mara komai a cikin wata jere na lambobin cikakku.\nShigarwa: Wani jeren lambobi da ke wakiltar jerin.\nFitarwa: Mafi girman jimlar wata jere mai ci gaba mara komai.\nMisalin Amfani:\n>>> calculate_max_subsequence_sum \"2 -4 3 -1 2 -4 3\"\n4\n>>> calculate_max_subsequence_sum \"-1 -2 -3 -4\"\n-1\n>>> calculate_max_subsequence_sum \"1 2 3 4 -10 5 6\"\n11",
      "hi": "Shell फ़ंक्शन `calculate_max_subsequence_sum() {\nlocal sequence=($1)\n` लिखें ताकि निम्नलिखित समस्या का समाधान किया जा सके:\nयह फ़ंक्शन एक दिए गए पूर्णांकों के अनुक्रम में एक सतत गैर-खाली उप-अनुक्रम का अधिकतम योग खोजता है।\nइनपुट: पूर्णांकों की एक स्ट्रिंग जो अनुक्रम का प्रतिनिधित्व करती है।\nआउटपुट: एक सतत गैर-खाली उप-अनुक्रम का अधिकतम योग।\nउदाहरण उपयोग:\n>>> calculate_max_subsequence_sum \"2 -4 3 -1 2 -4 3\"\n4\n>>> calculate_max_subsequence_sum \"-1 -2 -3 -4\"\n-1\n>>> calculate_max_subsequence_sum \"1 2 3 4 -10 5 6\"\n11",
      "hu": "Írj egy Shell függvényt `calculate_max_subsequence_sum() {\nlocal sequence=($1)\n` a következő probléma megoldására:\nEz a függvény megkeresi a maximális összegét egy folytonos, nem üres részszekvenciának egy adott egész számokból álló sorozatban.\nBemenet: Egy egész számokat reprezentáló karakterlánc, amely a sorozatot jelenti.\nKimenet: Egy folytonos, nem üres részszekvencia maximális összege.\nPélda használat:\n>>> calculate_max_subsequence_sum \"2 -4 3 -1 2 -4 3\"\n4\n>>> calculate_max_subsequence_sum \"-1 -2 -3 -4\"\n-1\n>>> calculate_max_subsequence_sum \"1 2 3 4 -10 5 6\"\n11"
    },
    "instruction_bertscore": {
      "sq": "0.9923110179501394",
      "hy": "0.9919288530970284",
      "bn": "0.9526347979688016",
      "bg": "0.9992724169142692",
      "zh": "0.9866754767794176",
      "fr": "0.9968177426654401",
      "de": "0.9889917056526655",
      "ha": "0.9585281613741067",
      "hi": "0.9765763136860798",
      "hu": "0.9704737924895449"
    },
    "level": "easy",
    "test": "test_calculate_max_subsequence_sum() {\n    [[ $(calculate_max_subsequence_sum \"2 -4 3 -1 2 -4 3\") -eq 4 ]] || { echo \"Test 1 failed\"; exit 1; }\n    [[ $(calculate_max_subsequence_sum \"-1 -2 -3 -4\") -eq -1 ]] || { echo \"Test 2 failed\"; exit 1; }\n    [[ $(calculate_max_subsequence_sum \"1 2 3 4 -10 5 6\") -eq 11 ]] || { echo \"Test 3 failed\"; exit 1; }\n    [[ $(calculate_max_subsequence_sum \"1 2 3 4 5 6\") -eq 21 ]] || { echo \"Test 4 failed\"; exit 1; }\n    [[ $(calculate_max_subsequence_sum \"-1 -2 -3 -4 -5 -6\") -eq -1 ]] || { echo \"Test 5 failed\"; exit 1; }\n}\n\ntest_calculate_max_subsequence_sum",
    "entry_point": "calculate_max_subsequence_sum",
    "signature": "calculate_max_subsequence_sum() {\nlocal sequence=($1)\n",
    "docstring": {
      "en": "This function finds the maximum sum of a continuous non-empty subsequence in a given sequence of integers.\nInput: A string of integers representing the sequence.\nOutput: The maximum sum of a continuous non-empty subsequence.\nExample Usage:\n>>> calculate_max_subsequence_sum \"2 -4 3 -1 2 -4 3\"\n4\n>>> calculate_max_subsequence_sum \"-1 -2 -3 -4\"\n-1\n>>> calculate_max_subsequence_sum \"1 2 3 4 -10 5 6\"\n11",
      "sq": "Kjo funksion gjen shumën maksimale të një nënsekuence të vazhdueshme jo-bosh në një sekuencë të dhënë të numrave të plotë.\nHyrja: Një varg numrash të plotë që përfaqëson sekuencën.\nDalja: Shuma maksimale e një nënsekuence të vazhdueshme jo-bosh.\nShembull Përdorimi:\n>>> calculate_max_subsequence_sum \"2 -4 3 -1 2 -4 3\"\n4\n>>> calculate_max_subsequence_sum \"-1 -2 -3 -4\"\n-1\n>>> calculate_max_subsequence_sum \"1 2 3 4 -10 5 6\"\n11",
      "hy": "Այս ֆունկցիան գտնում է անընդմեջ ոչ դատարկ ենթահաջորդականության առավելագույն գումարը տրված ամբողջ թվերի հաջորդականության մեջ:\nՄուտք: Ամբողջ թվերի տող, որը ներկայացնում է հաջորդականությունը:\nԵլք: Անընդմեջ ոչ դատարկ ենթահաջորդականության առավելագույն գումարը:\nՕրինակ օգտագործում:\n>>> calculate_max_subsequence_sum \"2 -4 3 -1 2 -4 3\"\n4\n>>> calculate_max_subsequence_sum \"-1 -2 -3 -4\"\n-1\n>>> calculate_max_subsequence_sum \"1 2 3 4 -10 5 6\"\n11",
      "bn": "এই ফাংশনটি একটি প্রদত্ত পূর্ণসংখ্যার ক্রমে একটি অবিচ্ছিন্ন অ-খালি উপক্রমের সর্বাধিক যোগফল খুঁজে বের করে।\nইনপুট: পূর্ণসংখ্যার ক্রমকে উপস্থাপনকারী একটি স্ট্রিং।\nআউটপুট: একটি অবিচ্ছিন্ন অ-খালি উপক্রমের সর্বাধিক যোগফল।\nব্যবহারের উদাহরণ:\n>>> calculate_max_subsequence_sum \"2 -4 3 -1 2 -4 3\"\n4\n>>> calculate_max_subsequence_sum \"-1 -2 -3 -4\"\n-1\n>>> calculate_max_subsequence_sum \"1 2 3 4 -10 5 6\"\n11",
      "bg": "Тази функция намира максималната сума на непрекъсната непразна подредица в дадена последователност от цели числа.\nВход: Низ от цели числа, представляващ последователността.\nИзход: Максималната сума на непрекъсната непразна подредица.\nПример за използване:\n>>> calculate_max_subsequence_sum \"2 -4 3 -1 2 -4 3\"\n4\n>>> calculate_max_subsequence_sum \"-1 -2 -3 -4\"\n-1\n>>> calculate_max_subsequence_sum \"1 2 3 4 -10 5 6\"\n11",
      "zh": "这个函数用于查找给定整数序列中连续非空子序列的最大和。\n输入: 一个表示序列的整数字符串。\n输出: 连续非空子序列的最大和。\n示例用法:\n>>> calculate_max_subsequence_sum \"2 -4 3 -1 2 -4 3\"\n4\n>>> calculate_max_subsequence_sum \"-1 -2 -3 -4\"\n-1\n>>> calculate_max_subsequence_sum \"1 2 3 4 -10 5 6\"\n11",
      "fr": "Cette fonction trouve la somme maximale d'une sous-séquence continue non vide dans une séquence donnée d'entiers.\nEntrée : Une chaîne de caractères d'entiers représentant la séquence.\nSortie : La somme maximale d'une sous-séquence continue non vide.\nExemple d'utilisation :\n>>> calculate_max_subsequence_sum \"2 -4 3 -1 2 -4 3\"\n4\n>>> calculate_max_subsequence_sum \"-1 -2 -3 -4\"\n-1\n>>> calculate_max_subsequence_sum \"1 2 3 4 -10 5 6\"\n11",
      "de": "Diese Funktion findet die maximale Summe einer kontinuierlichen, nicht-leeren Teilsequenz in einer gegebenen Sequenz von ganzen Zahlen.\nEingabe: Ein String von ganzen Zahlen, der die Sequenz darstellt.\nAusgabe: Die maximale Summe einer kontinuierlichen, nicht-leeren Teilsequenz.\nBeispielverwendung:\n>>> calculate_max_subsequence_sum \"2 -4 3 -1 2 -4 3\"\n4\n>>> calculate_max_subsequence_sum \"-1 -2 -3 -4\"\n-1\n>>> calculate_max_subsequence_sum \"1 2 3 4 -10 5 6\"\n11",
      "ha": "Wannan aikin yana nemo mafi girman jimillar wani jere mai ci gaba wanda ba komai ba a cikin wata jerin lambobi.\n\nShigarwa: Wani jeri na lambobi da ke wakiltar jerin.\n\nFitarwa: Mafi girman jimillar wani jere mai ci gaba wanda ba komai ba.\n\nMisalin Amfani:\n\n>>> calculate_max_subsequence_sum \"2 -4 3 -1 2 -4 3\"\n4\n\n>>> calculate_max_subsequence_sum \"-1 -2 -3 -4\"\n-1\n\n>>> calculate_max_subsequence_sum \"1 2 3 4 -10 5 6\"\n11",
      "hi": "यह फ़ंक्शन दिए गए पूर्णांकों के अनुक्रम में एक सतत गैर-खाली उप-अनुक्रम का अधिकतम योग खोजता है।  \nइनपुट: पूर्णांकों की एक स्ट्रिंग जो अनुक्रम का प्रतिनिधित्व करती है।  \nआउटपुट: एक सतत गैर-खाली उप-अनुक्रम का अधिकतम योग।  \nउदाहरण उपयोग:  \n>>> calculate_max_subsequence_sum \"2 -4 3 -1 2 -4 3\"  \n4  \n>>> calculate_max_subsequence_sum \"-1 -2 -3 -4\"  \n-1  \n>>> calculate_max_subsequence_sum \"1 2 3 4 -10 5 6\"  \n11  ",
      "hu": "Ez a függvény megtalálja a maximális összegét egy folytonos, nem üres részszekvenciának egy adott egész számokból álló sorozatban.\nBemenet: Egy egész számokat tartalmazó karakterlánc, amely a sorozatot képviseli.\nKimenet: A maximális összeg egy folytonos, nem üres részszekvenciában.\nPélda használat:\n>>> calculate_max_subsequence_sum \"2 -4 3 -1 2 -4 3\"\n4\n>>> calculate_max_subsequence_sum \"-1 -2 -3 -4\"\n-1\n>>> calculate_max_subsequence_sum \"1 2 3 4 -10 5 6\"\n11"
    },
    "docstring_bertscore": {
      "sq": "0.9884861913329317",
      "hy": "0.9876459848211541",
      "bn": "0.9808667299164333",
      "bg": "0.9991055673941999",
      "zh": "0.9728813913380688",
      "fr": "0.9905243376727306",
      "de": "0.9881395813180258",
      "ha": "0.9157310608459487",
      "hi": "0.9956831659289688",
      "hu": "0.9710371082501599"
    }
  },
  {
    "task_id": "Shell/32",
    "prompt": {
      "en": "calculate_min_bridge_rotations() {\nlocal N=$1\nlocal carriages=($2)\n# This function calculates the minimum number of bridge rotations required to sort train carriages.\n# The bridge can hold two carriages at a time and rotate 180 degrees to swap them.\n# Input: Number of carriages 'N' and a string representing the initial order of carriages.\n# Output: The minimum number of bridge rotations needed to sort the carriages in ascending order.\n# Example Usage:\n# >>> calculate_min_bridge_rotations 4 \"4 3 2 1\"\n# 6\n# >>> calculate_min_bridge_rotations 5 \"5 4 3 2 1\"\n# 10\n# >>> calculate_min_bridge_rotations 3 \"3 1 2\"\n# 2",
      "sq": "calculate_min_bridge_rotations() {\nlocal N=$1\nlocal carriages=($2)\n# Kjo funksion llogarit numrin minimal të rotacioneve të urës të nevojshme për të renditur vagonët e trenit.\n# Ura mund të mbajë dy vagonë në të njëjtën kohë dhe të rrotullohet 180 gradë për t'i ndërruar ato.\n# Hyrja: Numri i vagonëve 'N' dhe një varg që përfaqëson rendin fillestar të vagonëve.\n# Dalja: Numri minimal i rotacioneve të urës të nevojshme për të renditur vagonët në rend rritës.\n# Shembull i Përdorimit:\n# >>> calculate_min_bridge_rotations 4 \"4 3 2 1\"\n# 6\n# >>> calculate_min_bridge_rotations 5 \"5 4 3 2 1\"\n# 10\n# >>> calculate_min_bridge_rotations 3 \"3 1 2\"\n# 2",
      "hy": "calculate_min_bridge_rotations() {\nlocal N=$1\nlocal carriages=($2)\n# Այս ֆունկցիան հաշվում է կամուրջի պտույտների նվազագույն քանակը, որը պահանջվում է գնացքի վագոնները դասավորելու համար։\n# Կամուրջը կարող է պահել երկու վագոն և պտտվել 180 աստիճան՝ դրանք փոխանակելու համար։\n# Մուտք: Վագոնների քանակը 'N' և տող, որը ներկայացնում է վագոնների նախնական կարգը։\n# Ելք: Կամուրջի պտույտների նվազագույն քանակը, որը պահանջվում է վագոնները դասավորելու համար աճման կարգով։\n# Օրինակ օգտագործում:\n# >>> calculate_min_bridge_rotations 4 \"4 3 2 1\"\n# 6\n# >>> calculate_min_bridge_rotations 5 \"5 4 3 2 1\"\n# 10\n# >>> calculate_min_bridge_rotations 3 \"3 1 2\"\n# 2",
      "bn": "calculate_min_bridge_rotations() {\nlocal N=$1\nlocal carriages=($2)\n# এই ফাংশনটি ট্রেনের বগিগুলোকে সাজানোর জন্য প্রয়োজনীয় ন্যূনতম সেতু ঘূর্ণনের সংখ্যা গণনা করে।\n# সেতুটি এক সময়ে দুটি বগি ধরে রাখতে পারে এবং তাদের অদলবদল করতে ১৮০ ডিগ্রি ঘুরতে পারে।\n# ইনপুট: বগির সংখ্যা 'N' এবং বগির প্রাথমিক ক্রম উপস্থাপনকারী একটি স্ট্রিং।\n# আউটপুট: বগিগুলোকে ঊর্ধ্বক্রমে সাজানোর জন্য প্রয়োজনীয় ন্যূনতম সেতু ঘূর্ণনের সংখ্যা।\n# উদাহরণ ব্যবহার:\n# >>> calculate_min_bridge_rotations 4 \"4 3 2 1\"\n# 6\n# >>> calculate_min_bridge_rotations 5 \"5 4 3 2 1\"\n# 10\n# >>> calculate_min_bridge_rotations 3 \"3 1 2\"\n# 2",
      "bg": "calculate_min_bridge_rotations() {\nlocal N=$1\nlocal carriages=($2)\n# Тази функция изчислява минималния брой ротации на моста, необходими за сортиране на вагоните на влака.\n# Мостът може да държи два вагона едновременно и да се завърта на 180 градуса, за да ги размени.\n# Вход: Брой на вагоните 'N' и низ, представляващ началния ред на вагоните.\n# Изход: Минималният брой ротации на моста, необходими за сортиране на вагоните във възходящ ред.\n# Пример за използване:\n# >>> calculate_min_bridge_rotations 4 \"4 3 2 1\"\n# 6\n# >>> calculate_min_bridge_rotations 5 \"5 4 3 2 1\"\n# 10\n# >>> calculate_min_bridge_rotations 3 \"3 1 2\"\n# 2",
      "zh": "calculate_min_bridge_rotations() {\nlocal N=$1\nlocal carriages=($2)\n# 此函数计算将火车车厢排序所需的最小桥旋转次数。\n# 桥一次可以容纳两个车厢，并旋转180度以交换它们。\n# 输入：车厢数量'N'和表示车厢初始顺序的字符串。\n# 输出：将车厢按升序排序所需的最小桥旋转次数。\n# 示例用法：\n# >>> calculate_min_bridge_rotations 4 \"4 3 2 1\"\n# 6\n# >>> calculate_min_bridge_rotations 5 \"5 4 3 2 1\"\n# 10\n# >>> calculate_min_bridge_rotations 3 \"3 1 2\"\n# 2",
      "fr": "calculate_min_bridge_rotations() {\nlocal N=$1\nlocal carriages=($2)\n# Cette fonction calcule le nombre minimum de rotations de pont nécessaires pour trier les wagons de train.\n# Le pont peut contenir deux wagons à la fois et tourner de 180 degrés pour les échanger.\n# Entrée : Nombre de wagons 'N' et une chaîne représentant l'ordre initial des wagons.\n# Sortie : Le nombre minimum de rotations de pont nécessaires pour trier les wagons par ordre croissant.\n# Exemple d'utilisation :\n# >>> calculate_min_bridge_rotations 4 \"4 3 2 1\"\n# 6\n# >>> calculate_min_bridge_rotations 5 \"5 4 3 2 1\"\n# 10\n# >>> calculate_min_bridge_rotations 3 \"3 1 2\"\n# 2",
      "de": "calculate_min_bridge_rotations() {\nlocal N=$1\nlocal carriages=($2)\n# Diese Funktion berechnet die minimale Anzahl von Brückendrehungen, die erforderlich sind, um Zugwaggons zu sortieren.\n# Die Brücke kann zwei Waggons gleichzeitig halten und sich um 180 Grad drehen, um sie zu tauschen.\n# Eingabe: Anzahl der Waggons 'N' und ein String, der die anfängliche Reihenfolge der Waggons darstellt.\n# Ausgabe: Die minimale Anzahl von Brückendrehungen, die benötigt werden, um die Waggons in aufsteigender Reihenfolge zu sortieren.\n# Beispielverwendung:\n# >>> calculate_min_bridge_rotations 4 \"4 3 2 1\"\n# 6\n# >>> calculate_min_bridge_rotations 5 \"5 4 3 2 1\"\n# 10\n# >>> calculate_min_bridge_rotations 3 \"3 1 2\"\n# 2",
      "ha": "calculate_min_bridge_rotations() {\nlocal N=$1\nlocal carriages=($2)\n# Wannan aikin yana ƙididdige mafi ƙarancin adadin juyawar gada da ake buƙata don tsara motocin jirgin ƙasa.\n# Gadar na iya ɗaukar motoci biyu a lokaci guda kuma ta juya digiri 180 don musanya su.\n# Shigarwa: Adadin motocin 'N' da kuma jeri mai nuni ga tsarin farko na motocin.\n# Fitarwa: Mafi ƙarancin adadin juyawar gada da ake buƙata don tsara motocin a cikin tsari mai hawa.\n# Misalin Amfani:\n# >>> calculate_min_bridge_rotations 4 \"4 3 2 1\"\n# 6\n# >>> calculate_min_bridge_rotations 5 \"5 4 3 2 1\"\n# 10\n# >>> calculate_min_bridge_rotations 3 \"3 1 2\"\n# 2",
      "hi": "calculate_min_bridge_rotations() {\nlocal N=$1\nlocal carriages=($2)\n# यह फ़ंक्शन ट्रेन की बोगियों को क्रमबद्ध करने के लिए आवश्यक न्यूनतम पुल घुमावों की संख्या की गणना करता है।\n# पुल एक समय में दो बोगियों को पकड़ सकता है और उन्हें स्वैप करने के लिए 180 डिग्री घुमा सकता है।\n# इनपुट: बोगियों की संख्या 'N' और बोगियों के प्रारंभिक क्रम का प्रतिनिधित्व करने वाली एक स्ट्रिंग।\n# आउटपुट: बोगियों को आरोही क्रम में क्रमबद्ध करने के लिए आवश्यक न्यूनतम पुल घुमावों की संख्या।\n# उदाहरण उपयोग:\n# >>> calculate_min_bridge_rotations 4 \"4 3 2 1\"\n# 6\n# >>> calculate_min_bridge_rotations 5 \"5 4 3 2 1\"\n# 10\n# >>> calculate_min_bridge_rotations 3 \"3 1 2\"\n# 2",
      "hu": "calculate_min_bridge_rotations() {\nlocal N=$1\nlocal carriages=($2)\n# Ez a függvény kiszámítja a minimális számú hídforgatást, amely szükséges a vonatkocsik rendezéséhez.\n# A híd egyszerre két kocsit tud tartani, és 180 fokkal elforgatva felcserélheti őket.\n# Bemenet: A kocsik száma 'N' és egy string, amely a kocsik kezdeti sorrendjét jelöli.\n# Kimenet: A minimális hídforgatások száma, amely szükséges a kocsik növekvő sorrendbe rendezéséhez.\n# Példa használat:\n# >>> calculate_min_bridge_rotations 4 \"4 3 2 1\"\n# 6\n# >>> calculate_min_bridge_rotations 5 \"5 4 3 2 1\"\n# 10\n# >>> calculate_min_bridge_rotations 3 \"3 1 2\"\n# 2"
    },
    "prompt_bertscore": {
      "sq": "0.9759700937631614",
      "hy": "0.981838827001218",
      "bn": "0.9851760160329852",
      "bg": "0.9833645069579471",
      "zh": "0.9951273981228331",
      "fr": "0.9887587122157115",
      "de": "0.989319445781373",
      "ha": "0.9773497803898297",
      "hi": "0.9941781435318674",
      "hu": "0.9784013296270283"
    },
    "canonical_solution": "local count=0\n\nfor (( i=0; i<N; i++ )); do\nfor (( j=0; j<N-i-1; j++ )); do\nif (( carriages[j] > carriages[j+1] )); then\n# Swap carriages\nlocal temp=${carriages[j]}\ncarriages[j]=${carriages[j+1]}\ncarriages[j+1]=$temp\n((count++))\nfi\ndone\ndone\n\necho $count\n}",
    "instruction": {
      "en": "Write a Shell function `calculate_min_bridge_rotations() {\nlocal N=$1\nlocal carriages=($2)\n` to solve the following problem:\nThis function calculates the minimum number of bridge rotations required to sort train carriages.\nThe bridge can hold two carriages at a time and rotate 180 degrees to swap them.\nInput: Number of carriages 'N' and a string representing the initial order of carriages.\nOutput: The minimum number of bridge rotations needed to sort the carriages in ascending order.\nExample Usage:\n>>> calculate_min_bridge_rotations 4 \"4 3 2 1\"\n6\n>>> calculate_min_bridge_rotations 5 \"5 4 3 2 1\"\n10\n>>> calculate_min_bridge_rotations 3 \"3 1 2\"\n2",
      "sq": "Shkruani një funksion Shell `calculate_min_bridge_rotations() {\nlocal N=$1\nlocal carriages=($2)\n` për të zgjidhur problemin e mëposhtëm:\nKy funksion llogarit numrin minimal të rotacioneve të urës të nevojshme për të renditur vagonët e trenit.\nUra mund të mbajë dy vagonë në të njëjtën kohë dhe të rrotullohet 180 gradë për t'i shkëmbyer ato.\nHyrja: Numri i vagonëve 'N' dhe një varg që përfaqëson rendin fillestar të vagonëve.\nDalja: Numri minimal i rotacioneve të urës të nevojshme për të renditur vagonët në rend rritës.\nShembull Përdorimi:\n>>> calculate_min_bridge_rotations 4 \"4 3 2 1\"\n6\n>>> calculate_min_bridge_rotations 5 \"5 4 3 2 1\"\n10\n>>> calculate_min_bridge_rotations 3 \"3 1 2\"\n2",
      "hy": "Գրեք Shell ֆունկցիա `calculate_min_bridge_rotations() {\nlocal N=$1\nlocal carriages=($2)\n` հետևյալ խնդիրը լուծելու համար:\nԱյս ֆունկցիան հաշվում է կամրջի պտույտների նվազագույն քանակը, որը պահանջվում է գնացքի վագոնները դասավորելու համար:\nԿամուրջը կարող է պահել երկու վագոն և պտտվել 180 աստիճան՝ դրանք փոխանակելու համար:\nՄուտք: Վագոնների քանակը 'N' և տող, որը ներկայացնում է վագոնների սկզբնական կարգը:\nԵլք: Կամրջի պտույտների նվազագույն քանակը, որը պահանջվում է վագոնները աճման կարգով դասավորելու համար:\nՕրինակ օգտագործում:\n>>> calculate_min_bridge_rotations 4 \"4 3 2 1\"\n6\n>>> calculate_min_bridge_rotations 5 \"5 4 3 2 1\"\n10\n>>> calculate_min_bridge_rotations 3 \"3 1 2\"\n2",
      "bn": "একটি Shell ফাংশন লিখুন `calculate_min_bridge_rotations() {\nlocal N=$1\nlocal carriages=($2)\n` নিম্নলিখিত সমস্যার সমাধানের জন্য:\nএই ফাংশনটি ট্রেনের বগিগুলিকে সাজানোর জন্য প্রয়োজনীয় সর্বনিম্ন সেতু ঘূর্ণনের সংখ্যা গণনা করে।\nসেতুটি একবারে দুটি বগি ধরে রাখতে পারে এবং তাদের অদলবদল করতে ১৮০ ডিগ্রি ঘুরতে পারে।\nইনপুট: বগির সংখ্যা 'N' এবং বগির প্রাথমিক ক্রমকে উপস্থাপনকারী একটি স্ট্রিং।\nআউটপুট: বগিগুলিকে ঊর্ধ্বক্রমে সাজানোর জন্য প্রয়োজনীয় সর্বনিম্ন সেতু ঘূর্ণনের সংখ্যা।\nউদাহরণ ব্যবহার:\n>>> calculate_min_bridge_rotations 4 \"4 3 2 1\"\n6\n>>> calculate_min_bridge_rotations 5 \"5 4 3 2 1\"\n10\n>>> calculate_min_bridge_rotations 3 \"3 1 2\"\n2",
      "bg": "Напишете Shell функция `calculate_min_bridge_rotations() {\nlocal N=$1\nlocal carriages=($2)\n`, за да решите следния проблем:\nТази функция изчислява минималния брой ротации на моста, необходими за сортиране на вагоните.\nМостът може да държи два вагона едновременно и да се завърта на 180 градуса, за да ги размени.\nВход: Брой на вагоните 'N' и низ, представляващ първоначалния ред на вагоните.\nИзход: Минималният брой ротации на моста, необходими за сортиране на вагоните във възходящ ред.\nПример за използване:\n>>> calculate_min_bridge_rotations 4 \"4 3 2 1\"\n6\n>>> calculate_min_bridge_rotations 5 \"5 4 3 2 1\"\n10\n>>> calculate_min_bridge_rotations 3 \"3 1 2\"\n2",
      "zh": "编写一个 Shell 函数 `calculate_min_bridge_rotations() {\nlocal N=$1\nlocal carriages=($2)\n` 来解决以下问题：\n此函数计算将火车车厢排序所需的最小桥梁旋转次数。\n桥梁一次可以容纳两个车厢，并旋转180度以交换它们。\n输入：车厢数量 'N' 和一个表示车厢初始顺序的字符串。\n输出：将车厢按升序排序所需的最小桥梁旋转次数。\n示例用法：\n>>> calculate_min_bridge_rotations 4 \"4 3 2 1\"\n6\n>>> calculate_min_bridge_rotations 5 \"5 4 3 2 1\"\n10\n>>> calculate_min_bridge_rotations 3 \"3 1 2\"\n2",
      "fr": "Écrire une fonction Shell `calculate_min_bridge_rotations() {\nlocal N=$1\nlocal carriages=($2)\n` pour résoudre le problème suivant :\nCette fonction calcule le nombre minimum de rotations de pont nécessaires pour trier les wagons de train.\nLe pont peut contenir deux wagons à la fois et tourner de 180 degrés pour les échanger.\nEntrée : Nombre de wagons 'N' et une chaîne représentant l'ordre initial des wagons.\nSortie : Le nombre minimum de rotations de pont nécessaires pour trier les wagons dans l'ordre croissant.\nExemple d'utilisation :\n>>> calculate_min_bridge_rotations 4 \"4 3 2 1\"\n6\n>>> calculate_min_bridge_rotations 5 \"5 4 3 2 1\"\n10\n>>> calculate_min_bridge_rotations 3 \"3 1 2\"\n2",
      "de": "Schreiben Sie eine Shell-Funktion `calculate_min_bridge_rotations() {\nlocal N=$1\nlocal carriages=($2)\n` um das folgende Problem zu lösen:\nDiese Funktion berechnet die minimale Anzahl von Brückendrehungen, die erforderlich sind, um Zugwaggons zu sortieren.\nDie Brücke kann zwei Waggons gleichzeitig halten und sich um 180 Grad drehen, um sie zu tauschen.\nEingabe: Anzahl der Waggons 'N' und ein String, der die anfängliche Reihenfolge der Waggons darstellt.\nAusgabe: Die minimale Anzahl von Brückendrehungen, die benötigt werden, um die Waggons in aufsteigender Reihenfolge zu sortieren.\nBeispielverwendung:\n>>> calculate_min_bridge_rotations 4 \"4 3 2 1\"\n6\n>>> calculate_min_bridge_rotations 5 \"5 4 3 2 1\"\n10\n>>> calculate_min_bridge_rotations 3 \"3 1 2\"\n2",
      "ha": "Rubuta wani aikin Shell `calculate_min_bridge_rotations() {\nlocal N=$1\nlocal carriages=($2)\n` don warware matsalar mai zuwa:\nWannan aikin yana ƙididdige mafi ƙarancin adadin juyawar gada da ake buƙata don tsara kwantena na jirgin ƙasa.\nGadar na iya ɗaukar kwantena biyu a lokaci guda kuma ta juya digiri 180 don musanya su.\nShigarwa: Adadin kwantena 'N' da kuma wani igiya da ke wakiltar tsarin farko na kwantena.\nFitarwa: Mafi ƙarancin adadin juyawar gada da ake buƙata don tsara kwantenan cikin tsari mai hawa.\nMisalin Amfani:\n>>> calculate_min_bridge_rotations 4 \"4 3 2 1\"\n6\n>>> calculate_min_bridge_rotations 5 \"5 4 3 2 1\"\n10\n>>> calculate_min_bridge_rotations 3 \"3 1 2\"\n2",
      "hi": "Shell फ़ंक्शन `calculate_min_bridge_rotations() {\nlocal N=$1\nlocal carriages=($2)\n` निम्नलिखित समस्या को हल करने के लिए:\nयह फ़ंक्शन ट्रेन के डिब्बों को क्रमबद्ध करने के लिए आवश्यक न्यूनतम ब्रिज रोटेशन की गणना करता है।\nब्रिज एक समय में दो डिब्बों को पकड़ सकता है और उन्हें अदला-बदली करने के लिए 180 डिग्री घुमा सकता है।\nइनपुट: डिब्बों की संख्या 'N' और डिब्बों के प्रारंभिक क्रम का प्रतिनिधित्व करने वाली एक स्ट्रिंग।\nआउटपुट: डिब्बों को आरोही क्रम में क्रमबद्ध करने के लिए आवश्यक न्यूनतम ब्रिज रोटेशन की संख्या।\nउदाहरण उपयोग:\n>>> calculate_min_bridge_rotations 4 \"4 3 2 1\"\n6\n>>> calculate_min_bridge_rotations 5 \"5 4 3 2 1\"\n10\n>>> calculate_min_bridge_rotations 3 \"3 1 2\"\n2",
      "hu": "Írj egy Shell függvényt `calculate_min_bridge_rotations() {\nlocal N=$1\nlocal carriages=($2)\n` a következő probléma megoldására:\nEz a függvény kiszámítja a minimális számú hídforgatást, amely szükséges a vonatkocsik rendezéséhez.\nA híd egyszerre két kocsit képes tartani és 180 fokban elforgatva cserélni őket.\nBemenet: A kocsik száma 'N' és egy karakterlánc, amely a kocsik kezdeti sorrendjét jelöli.\nKimenet: A minimális számú hídforgatás, amely szükséges a kocsik növekvő sorrendbe rendezéséhez.\nPélda használat:\n>>> calculate_min_bridge_rotations 4 \"4 3 2 1\"\n6\n>>> calculate_min_bridge_rotations 5 \"5 4 3 2 1\"\n10\n>>> calculate_min_bridge_rotations 3 \"3 1 2\"\n2"
    },
    "instruction_bertscore": {
      "sq": "0.9823638070982933",
      "hy": "0.981895238029432",
      "bn": "0.8488279786450156",
      "bg": "0.984969837697471",
      "zh": "0.9942369381246537",
      "fr": "0.9896245420466426",
      "de": "0.995917748408971",
      "ha": "0.959879046595525",
      "hi": "0.9809271135522679",
      "hu": "0.9810262301124044"
    },
    "level": "easy",
    "test": "test_calculate_min_bridge_rotations() {\n[[ $(calculate_min_bridge_rotations 4 \"4 3 2 1\") -eq 6 ]] || { echo \"Test 1 failed\"; exit 1; }\n[[ $(calculate_min_bridge_rotations 5 \"5 4 3 2 1\") -eq 10 ]] || { echo \"Test 2 failed\"; exit 1; }\n[[ $(calculate_min_bridge_rotations 3 \"3 1 2\") -eq 2 ]] || { echo \"Test 3 failed\"; exit 1; }\n[[ $(calculate_min_bridge_rotations 6 \"6 5 4 3 2 1\") -eq 15 ]] || { echo \"Test 4 failed\"; exit 1; }\n}\n\ntest_calculate_min_bridge_rotations",
    "entry_point": "calculate_min_bridge_rotations",
    "signature": "calculate_min_bridge_rotations() {\nlocal N=$1\nlocal carriages=($2)\n",
    "docstring": {
      "en": "This function calculates the minimum number of bridge rotations required to sort train carriages.\nThe bridge can hold two carriages at a time and rotate 180 degrees to swap them.\nInput: Number of carriages 'N' and a string representing the initial order of carriages.\nOutput: The minimum number of bridge rotations needed to sort the carriages in ascending order.\nExample Usage:\n>>> calculate_min_bridge_rotations 4 \"4 3 2 1\"\n6\n>>> calculate_min_bridge_rotations 5 \"5 4 3 2 1\"\n10\n>>> calculate_min_bridge_rotations 3 \"3 1 2\"\n2",
      "sq": "Kjo funksion llogarit numrin minimal të rotacioneve të urës të nevojshme për të renditur vagonët e trenit.\nUra mund të mbajë dy vagonë në të njëjtën kohë dhe të rrotullohet 180 gradë për t'i ndërruar ato.\nInput: Numri i vagonëve 'N' dhe një varg që përfaqëson rendin fillestar të vagonëve.\nOutput: Numri minimal i rotacioneve të urës të nevojshme për të renditur vagonët në rend rritës.\nShembull Përdorimi:\n>>> calculate_min_bridge_rotations 4 \"4 3 2 1\"\n6\n>>> calculate_min_bridge_rotations 5 \"5 4 3 2 1\"\n10\n>>> calculate_min_bridge_rotations 3 \"3 1 2\"\n2",
      "hy": "Այս ֆունկցիան հաշվարկում է գնացքի վագոնները դասավորելու համար անհրաժեշտ կամրջի պտույտների նվազագույն քանակը:\nԿամուրջը կարող է պահել երկու վագոն միաժամանակ և պտտվել 180 աստիճան՝ դրանք փոխանակելու համար:\nՄուտք: Վագոնների քանակը 'N' և տող, որը ներկայացնում է վագոնների սկզբնական կարգը:\nԵլք: Վագոնները աճման կարգով դասավորելու համար անհրաժեշտ կամրջի պտույտների նվազագույն քանակը:\nՕրինակային օգտագործում:\n>>> calculate_min_bridge_rotations 4 \"4 3 2 1\"\n6\n>>> calculate_min_bridge_rotations 5 \"5 4 3 2 1\"\n10\n>>> calculate_min_bridge_rotations 3 \"3 1 2\"\n2",
      "bn": "এই ফাংশনটি ট্রেনের বগিগুলি সাজানোর জন্য প্রয়োজনীয় সর্বনিম্ন সেতু ঘূর্ণনের সংখ্যা গণনা করে।\nসেতুটি এক সময়ে দুটি বগি ধরে রাখতে পারে এবং তাদের অদলবদল করতে ১৮০ ডিগ্রি ঘুরতে পারে।\nইনপুট: বগির সংখ্যা 'N' এবং বগির প্রাথমিক ক্রম উপস্থাপনকারী একটি স্ট্রিং।\nআউটপুট: বগিগুলিকে ঊর্ধ্বক্রমে সাজানোর জন্য প্রয়োজনীয় সর্বনিম্ন সেতু ঘূর্ণনের সংখ্যা।\nব্যবহারের উদাহরণ:\n>>> calculate_min_bridge_rotations 4 \"4 3 2 1\"\n6\n>>> calculate_min_bridge_rotations 5 \"5 4 3 2 1\"\n10\n>>> calculate_min_bridge_rotations 3 \"3 1 2\"\n2",
      "bg": "Тази функция изчислява минималния брой ротации на моста, необходими за сортиране на вагоните.\nМостът може да държи два вагона едновременно и да се завърта на 180 градуса, за да ги размени.\nВход: Брой на вагоните 'N' и низ, представляващ началния ред на вагоните.\nИзход: Минималният брой ротации на моста, необходими за сортиране на вагоните във възходящ ред.\nПример за използване:\n>>> calculate_min_bridge_rotations 4 \"4 3 2 1\"\n6\n>>> calculate_min_bridge_rotations 5 \"5 4 3 2 1\"\n10\n>>> calculate_min_bridge_rotations 3 \"3 1 2\"\n2",
      "zh": "此函数计算将火车车厢排序所需的最少桥梁旋转次数。\n桥梁一次可以容纳两个车厢，并旋转180度以交换它们。\n输入：车厢数量'N'和表示车厢初始顺序的字符串。\n输出：将车厢按升序排序所需的最少桥梁旋转次数。\n示例用法：\n>>> calculate_min_bridge_rotations 4 \"4 3 2 1\"\n6\n>>> calculate_min_bridge_rotations 5 \"5 4 3 2 1\"\n10\n>>> calculate_min_bridge_rotations 3 \"3 1 2\"\n2",
      "fr": "Cette fonction calcule le nombre minimum de rotations de pont nécessaires pour trier les wagons de train.  \nLe pont peut contenir deux wagons à la fois et pivoter de 180 degrés pour les échanger.  \nEntrée : Nombre de wagons 'N' et une chaîne représentant l'ordre initial des wagons.  \nSortie : Le nombre minimum de rotations de pont nécessaires pour trier les wagons par ordre croissant.  \nExemple d'utilisation :  \n>>> calculate_min_bridge_rotations 4 \"4 3 2 1\"  \n6  \n>>> calculate_min_bridge_rotations 5 \"5 4 3 2 1\"  \n10  \n>>> calculate_min_bridge_rotations 3 \"3 1 2\"  \n2  ",
      "de": "Diese Funktion berechnet die minimale Anzahl von Brückendrehungen, die erforderlich sind, um Zugwaggons zu sortieren.\nDie Brücke kann gleichzeitig zwei Waggons halten und sich um 180 Grad drehen, um sie zu tauschen.\nEingabe: Anzahl der Waggons 'N' und ein String, der die anfängliche Reihenfolge der Waggons darstellt.\nAusgabe: Die minimale Anzahl von Brückendrehungen, die benötigt werden, um die Waggons in aufsteigender Reihenfolge zu sortieren.\nBeispielverwendung:\n>>> calculate_min_bridge_rotations 4 \"4 3 2 1\"\n6\n>>> calculate_min_bridge_rotations 5 \"5 4 3 2 1\"\n10\n>>> calculate_min_bridge_rotations 3 \"3 1 2\"\n2",
      "ha": "Wannan aikin yana lissafin mafi ƙarancin adadin juyawar gada da ake buƙata don tsara motoci na jirgin ƙasa.\nGadar na iya ɗaukar motoci biyu a lokaci guda kuma ta juyawa digiri 180 don musanya su.\nShigarwa: Yawan motoci 'N' da kuma wani igiya mai nuna tsarin farko na motoci.\nFitarwa: Mafi ƙarancin adadin juyawar gada da ake buƙata don tsara motoci a tsari mai hawa.\nMisalin Amfani:\n>>> calculate_min_bridge_rotations 4 \"4 3 2 1\"\n6\n>>> calculate_min_bridge_rotations 5 \"5 4 3 2 1\"\n10\n>>> calculate_min_bridge_rotations 3 \"3 1 2\"\n2",
      "hi": "यह फ़ंक्शन ट्रेन की बोगियों को क्रमबद्ध करने के लिए आवश्यक न्यूनतम पुल घुमावों की संख्या की गणना करता है। पुल एक समय में दो बोगियों को पकड़ सकता है और उन्हें अदला-बदली करने के लिए 180 डिग्री घुमा सकता है। इनपुट: बोगियों की संख्या 'N' और बोगियों के प्रारंभिक क्रम का प्रतिनिधित्व करने वाला एक स्ट्रिंग। आउटपुट: आरोही क्रम में बोगियों को क्रमबद्ध करने के लिए आवश्यक न्यूनतम पुल घुमावों की संख्या। उदाहरण उपयोग:\n>>> calculate_min_bridge_rotations 4 \"4 3 2 1\"\n6\n>>> calculate_min_bridge_rotations 5 \"5 4 3 2 1\"\n10\n>>> calculate_min_bridge_rotations 3 \"3 1 2\"\n2",
      "hu": "Ez a függvény kiszámítja a minimális számú hídforgatást, amely szükséges a vasúti kocsik rendezéséhez.\nA híd egyszerre két kocsit tud tartani, és 180 fokban el tudja forgatni őket, hogy felcserélje azokat.\nBemenet: A kocsik száma 'N' és egy karakterlánc, amely a kocsik kezdeti sorrendjét jelöli.\nKimenet: A minimális számú hídforgatás, amely szükséges a kocsik növekvő sorrendbe rendezéséhez.\nPélda használat:\n>>> calculate_min_bridge_rotations 4 \"4 3 2 1\"\n6\n>>> calculate_min_bridge_rotations 5 \"5 4 3 2 1\"\n10\n>>> calculate_min_bridge_rotations 3 \"3 1 2\"\n2"
    },
    "docstring_bertscore": {
      "sq": "0.9731096176458779",
      "hy": "0.9617630557596409",
      "bn": "0.9727850556032669",
      "bg": "0.9522113179964352",
      "zh": "0.9918631064409058",
      "fr": "0.9698689629792937",
      "de": "0.9564467136112421",
      "ha": "0.9635954210246878",
      "hi": "0.980506017144474",
      "hu": "0.968698434143855"
    }
  },
  {
    "task_id": "Shell/33",
    "prompt": {
      "en": "is_lucky_word() {\nlocal word=$1\nlocal -A letter_counts\n# This function checks if the given word is a \"Lucky Word\".\n# A word is considered \"Lucky\" if the difference between the highest and lowest letter frequency is a prime number.\n# Input: A single word consisting of lowercase letters and with a length less than 100.\n# Output: Two lines - the first line is either 'Lucky Word' or 'No Answer', and the second line is the difference if the word is \"Lucky\", or 0 otherwise.\n# Example Usage:\n# >>> is_lucky_word \"error\"\n# Lucky Word\n# 2\n# >>> is_lucky_word \"olympic\"\n# No Answer\n# 0",
      "sq": "is_lucky_word() {\nlocal word=$1\nlocal -A letter_counts\n# Kjo funksion kontrollon nëse fjala e dhënë është një \"Fjalë me Fat\".\n# Një fjalë konsiderohet \"me Fat\" nëse diferenca midis frekuencës më të lartë dhe më të ulët të shkronjave është një numër i thjeshtë.\n# Hyrja: Një fjalë e vetme që përbëhet nga shkronja të vogla dhe me gjatësi më pak se 100.\n# Dalja: Dy rreshta - rreshti i parë është ose 'Fjalë me Fat' ose 'Pa Përgjigje', dhe rreshti i dytë është diferenca nëse fjala është \"me Fat\", ose 0 përndryshe.\n# Shembull i Përdorimit:\n# >>> is_lucky_word \"error\"\n# Fjalë me Fat\n# 2\n# >>> is_lucky_word \"olympic\"\n# Pa Përgjigje\n# 0",
      "hy": "is_lucky_word() {\nlocal word=$1\nlocal -A letter_counts\n# Այս ֆունկցիան ստուգում է, արդյոք տրված բառը \"Բախտավոր Բառ\" է:\n# Բառը համարվում է \"Բախտավոր\", եթե ամենաբարձր և ամենացածր տառերի հաճախականությունների տարբերությունը պարզ թիվ է:\n# Մուտք: Միայն մեկ բառ, որը բաղկացած է փոքրատառերից և ունի 100-ից պակաս երկարություն:\n# Ելք: Երկու տող - առաջին տողը կամ 'Բախտավոր Բառ' է կամ 'Պատասխան Չկա', իսկ երկրորդ տողը տարբերությունն է, եթե բառը \"Բախտավոր\" է, կամ 0՝ հակառակ դեպքում:\n# Օրինակային Օգտագործում:\n# >>> is_lucky_word \"error\"\n# Lucky Word\n# 2\n# >>> is_lucky_word \"olympic\"\n# No Answer\n# 0",
      "bn": "is_lucky_word() {\nlocal word=$1\nlocal -A letter_counts\n# এই ফাংশনটি প্রদানকৃত শব্দটি \"লাকি ওয়ার্ড\" কিনা তা পরীক্ষা করে।\n# একটি শব্দকে \"লাকি\" বিবেচনা করা হয় যদি সর্বাধিক এবং সর্বনিম্ন অক্ষরের ফ্রিকোয়েন্সির মধ্যে পার্থক্য একটি মৌলিক সংখ্যা হয়।\n# ইনপুট: একটি একক শব্দ যা ছোট হাতের অক্ষর নিয়ে গঠিত এবং যার দৈর্ঘ্য ১০০ এর কম।\n# আউটপুট: দুটি লাইন - প্রথম লাইনটি হয় 'Lucky Word' অথবা 'No Answer', এবং দ্বিতীয় লাইনটি পার্থক্য যদি শব্দটি \"লাকি\" হয়, অথবা অন্যথায় 0।\n# উদাহরণ ব্যবহার:\n# >>> is_lucky_word \"error\"\n# Lucky Word\n# 2\n# >>> is_lucky_word \"olympic\"\n# No Answer\n# 0",
      "bg": "is_lucky_word() {\nlocal word=$1\nlocal -A letter_counts\n# Тази функция проверява дали дадената дума е \"Щастлива дума\".\n# Една дума се счита за \"Щастлива\", ако разликата между най-високата и най-ниската честота на буквите е просто число.\n# Вход: Една дума, състояща се от малки букви и с дължина по-малка от 100.\n# Изход: Два реда - първият ред е или 'Щастлива дума', или 'Няма отговор', а вторият ред е разликата, ако думата е \"Щастлива\", или 0 в противен случай.\n# Пример за използване:\n# >>> is_lucky_word \"error\"\n# Lucky Word\n# 2\n# >>> is_lucky_word \"olympic\"\n# No Answer\n# 0",
      "zh": "is_lucky_word() {\nlocal word=$1\nlocal -A letter_counts\n# 此函数检查给定的单词是否为“幸运单词”。\n# 如果最高和最低字母频率之间的差是一个质数，则该单词被认为是“幸运”的。\n# 输入：一个由小写字母组成且长度小于100的单词。\n# 输出：两行 - 第一行是 'Lucky Word' 或 'No Answer'，第二行是如果单词是“幸运”的则为差值，否则为0。\n# 示例用法：\n# >>> is_lucky_word \"error\"\n# Lucky Word\n# 2\n# >>> is_lucky_word \"olympic\"\n# No Answer\n# 0",
      "fr": "is_lucky_word() {\nlocal word=$1\nlocal -A letter_counts\n# Cette fonction vérifie si le mot donné est un \"Mot Chanceux\".\n# Un mot est considéré comme \"Chanceux\" si la différence entre la fréquence la plus élevée et la plus basse des lettres est un nombre premier.\n# Entrée : Un seul mot composé de lettres minuscules et d'une longueur inférieure à 100.\n# Sortie : Deux lignes - la première ligne est soit 'Lucky Word' soit 'No Answer', et la deuxième ligne est la différence si le mot est \"Chanceux\", ou 0 sinon.\n# Exemple d'utilisation :\n# >>> is_lucky_word \"error\"\n# Lucky Word\n# 2\n# >>> is_lucky_word \"olympic\"\n# No Answer\n# 0",
      "de": "is_lucky_word() {\nlocal word=$1\nlocal -A letter_counts\n# Diese Funktion überprüft, ob das gegebene Wort ein \"Glückswort\" ist.\n# Ein Wort wird als \"Glücklich\" betrachtet, wenn die Differenz zwischen der höchsten und niedrigsten Buchstabenhäufigkeit eine Primzahl ist.\n# Eingabe: Ein einzelnes Wort bestehend aus Kleinbuchstaben und mit einer Länge von weniger als 100.\n# Ausgabe: Zwei Zeilen - die erste Zeile ist entweder 'Lucky Word' oder 'No Answer', und die zweite Zeile ist die Differenz, wenn das Wort \"Glücklich\" ist, oder 0 andernfalls.\n# Beispielverwendung:\n# >>> is_lucky_word \"error\"\n# Lucky Word\n# 2\n# >>> is_lucky_word \"olympic\"\n# No Answer\n# 0",
      "ha": "is_lucky_word() {\nlocal word=$1\nlocal -A letter_counts\n# Wannan aikin yana duba idan kalmar da aka bayar tana da \"Kalmar Sa'a\".\n# Ana ɗaukar kalma tana da \"Sa'a\" idan bambancin tsakanin mafi yawan harafi da mafi ƙarancin yawan harafi yana da lamba mai lamba.\n# Shigarwa: Kalma guda ɗaya da ke ƙunshe da ƙananan haruffa kuma tana da tsawon ƙasa da 100.\n# Fitarwa: Layuka biyu - layi na farko ko dai 'Kalmar Sa'a' ko 'Babu Amsa', kuma layi na biyu shine bambanci idan kalmar tana da \"Sa'a\", ko 0 in ba haka ba.\n# Misalin Amfani:\n# >>> is_lucky_word \"error\"\n# Lucky Word\n# 2\n# >>> is_lucky_word \"olympic\"\n# No Answer\n# 0",
      "hi": "is_lucky_word() {\nlocal word=$1\nlocal -A letter_counts\n# यह फ़ंक्शन जांचता है कि दिया गया शब्द \"Lucky Word\" है या नहीं।\n# एक शब्द को \"Lucky\" माना जाता है यदि उच्चतम और निम्नतम अक्षर आवृत्ति के बीच का अंतर एक अभाज्य संख्या है।\n# इनपुट: छोटे अक्षरों से बना एकल शब्द जिसकी लंबाई 100 से कम है।\n# आउटपुट: दो पंक्तियाँ - पहली पंक्ति या तो 'Lucky Word' होगी या 'No Answer', और दूसरी पंक्ति अंतर होगी यदि शब्द \"Lucky\" है, अन्यथा 0।\n# उदाहरण उपयोग:\n# >>> is_lucky_word \"error\"\n# Lucky Word\n# 2\n# >>> is_lucky_word \"olympic\"\n# No Answer\n# 0",
      "hu": "is_lucky_word() {\nlocal word=$1\nlocal -A letter_counts\n# Ez a függvény ellenőrzi, hogy a megadott szó \"Szerencsés Szó\"-e.\n# Egy szót akkor tekintünk \"Szerencsésnek\", ha a leggyakoribb és a legkevésbé gyakori betűk gyakorisága közötti különbség prímszám.\n# Bemenet: Egyetlen szó, amely kisbetűkből áll, és hossza kevesebb, mint 100.\n# Kimenet: Két sor - az első sor vagy 'Szerencsés Szó', vagy 'Nincs Válasz', a második sor pedig a különbség, ha a szó \"Szerencsés\", vagy 0 egyébként.\n# Példa használat:\n# >>> is_lucky_word \"error\"\n# Lucky Word\n# 2\n# >>> is_lucky_word \"olympic\"\n# No Answer\n# 0"
    },
    "prompt_bertscore": {
      "sq": "0.9884275953705264",
      "hy": "0.9853432628138167",
      "bn": "0.980796414761547",
      "bg": "0.989523836443458",
      "zh": "0.9731586793499934",
      "fr": "0.9853714683279235",
      "de": "0.9908868381181193",
      "ha": "0.9728706652974929",
      "hi": "0.9717082803076768",
      "hu": "0.974892523946047"
    },
    "canonical_solution": "local max_count=0\nlocal min_count=100\nlocal count diff\n\n# Function to check if a number is prime\nis_prime() {\nlocal num=$1\nif (( num < 2 )); then return 1; fi\nfor (( i=2; i*i<=num; i++ )); do\nif (( num % i == 0 )); then return 1; fi\ndone\nreturn 0\n}\n\n# Count letter frequencies\nfor (( i=0; i<${#word}; i++ )); do\nletter=${word:$i:1}\n((letter_counts[$letter]++))\ndone\n\n# Find max and min counts\nfor letter in \"${!letter_counts[@]}\"; do\ncount=${letter_counts[$letter]}\nif (( count > max_count )); then max_count=$count; fi\nif (( count < min_count )); then min_count=$count; fi\ndone\n\ndiff=$((max_count - min_count))\n\nif is_prime $diff; then\necho \"Lucky Word\"\necho $diff\nelse\necho \"No Answer\"\necho 0\nfi\n}",
    "instruction": {
      "en": "Write a Shell function `is_lucky_word() {\nlocal word=$1\nlocal -A letter_counts\n` to solve the following problem:\nThis function checks if the given word is a \"Lucky Word\".\nA word is considered \"Lucky\" if the difference between the highest and lowest letter frequency is a prime number.\nInput: A single word consisting of lowercase letters and with a length less than 100.\nOutput: Two lines - the first line is either 'Lucky Word' or 'No Answer', and the second line is the difference if the word is \"Lucky\", or 0 otherwise.\nExample Usage:\n>>> is_lucky_word \"error\"\nLucky Word\n2\n>>> is_lucky_word \"olympic\"\nNo Answer\n0",
      "sq": "Shkruani një funksion Shell `is_lucky_word() {\nlocal word=$1\nlocal -A letter_counts\n` për të zgjidhur problemin e mëposhtëm:\nKy funksion kontrollon nëse fjala e dhënë është një \"Fjalë me Fat\".\nNjë fjalë konsiderohet \"me Fat\" nëse diferenca midis frekuencës më të lartë dhe më të ulët të shkronjave është një numër i thjeshtë.\nHyrja: Një fjalë e vetme që përbëhet nga shkronja të vogla dhe me një gjatësi më pak se 100.\nDalja: Dy rreshta - rreshti i parë është ose 'Fjalë me Fat' ose 'Pa Përgjigje', dhe rreshti i dytë është diferenca nëse fjala është \"me Fat\", ose 0 ndryshe.\nShembull Përdorimi:\n>>> is_lucky_word \"error\"\nFjalë me Fat\n2\n>>> is_lucky_word \"olympic\"\nPa Përgjigje\n0",
      "hy": "Գրեք Shell ֆունկցիա `is_lucky_word() {\nlocal word=$1\nlocal -A letter_counts\n` հետևյալ խնդիրը լուծելու համար:\nԱյս ֆունկցիան ստուգում է, արդյոք տրված բառը \"Lucky Word\" է:\nԲառը համարվում է \"Lucky\", եթե ամենաբարձր և ամենացածր տառերի հաճախականությունների տարբերությունը պարզ թիվ է:\nՄուտք: Միայն մեկ բառ, որը բաղկացած է փոքրատառերից և ունի 100-ից պակաս երկարություն:\nԵլք: Երկու տող - առաջին տողը կա՛մ 'Lucky Word', կա՛մ 'No Answer', և երկրորդ տողը տարբերությունն է, եթե բառը \"Lucky\" է, կամ 0՝ հակառակ դեպքում:\nՕրինակ օգտագործում:\n>>> is_lucky_word \"error\"\nLucky Word\n2\n>>> is_lucky_word \"olympic\"\nNo Answer\n0",
      "bn": "একটি Shell ফাংশন লিখুন `is_lucky_word() {\nlocal word=$1\nlocal -A letter_counts\n` নিম্নলিখিত সমস্যার সমাধানের জন্য:\nএই ফাংশনটি পরীক্ষা করে যে প্রদত্ত শব্দটি \"Lucky Word\" কিনা।\nএকটি শব্দকে \"Lucky\" বিবেচনা করা হয় যদি সর্বাধিক এবং সর্বনিম্ন অক্ষরের ফ্রিকোয়েন্সির মধ্যে পার্থক্য একটি মৌলিক সংখ্যা হয়।\nইনপুট: ছোট হাতের অক্ষর নিয়ে গঠিত একটি একক শব্দ এবং যার দৈর্ঘ্য ১০০-এর কম।\nআউটপুট: দুটি লাইন - প্রথম লাইন হয় 'Lucky Word' অথবা 'No Answer', এবং দ্বিতীয় লাইনটি পার্থক্য যদি শব্দটি \"Lucky\" হয়, অথবা অন্যথায় 0।\nউদাহরণ ব্যবহার:\n>>> is_lucky_word \"error\"\nLucky Word\n2\n>>> is_lucky_word \"olympic\"\nNo Answer\n0",
      "bg": "Напишете Shell функция `is_lucky_word() {\nlocal word=$1\nlocal -A letter_counts\n`, за да решите следния проблем:\nТази функция проверява дали дадената дума е \"Късметлийска дума\".\nЕдна дума се счита за \"Късметлийска\", ако разликата между най-високата и най-ниската честота на буквите е просто число.\nВход: Една дума, състояща се от малки букви и с дължина по-малка от 100.\nИзход: Два реда - първият ред е или 'Lucky Word', или 'No Answer', а вторият ред е разликата, ако думата е \"Късметлийска\", или 0 в противен случай.\nПример за използване:\n>>> is_lucky_word \"error\"\nLucky Word\n2\n>>> is_lucky_word \"olympic\"\nNo Answer\n0",
      "zh": "编写一个 Shell 函数 `is_lucky_word() {\nlocal word=$1\nlocal -A letter_counts\n` 来解决以下问题：\n此函数检查给定的单词是否为“幸运单词”。\n如果一个单词中最高和最低字母频率的差是一个质数，则该单词被认为是“幸运”的。\n输入：一个由小写字母组成且长度小于100的单词。\n输出：两行 - 第一行是 'Lucky Word' 或 'No Answer'，第二行是如果单词是“幸运”的则为差值，否则为0。\n示例用法：\n>>> is_lucky_word \"error\"\nLucky Word\n2\n>>> is_lucky_word \"olympic\"\nNo Answer\n0",
      "fr": "Écrire une fonction Shell `is_lucky_word() {\nlocal word=$1\nlocal -A letter_counts\n` pour résoudre le problème suivant :\nCette fonction vérifie si le mot donné est un \"Mot Chanceux\".\nUn mot est considéré comme \"Chanceux\" si la différence entre la fréquence la plus élevée et la plus basse des lettres est un nombre premier.\nEntrée : Un seul mot composé de lettres minuscules et d'une longueur inférieure à 100.\nSortie : Deux lignes - la première ligne est soit 'Lucky Word' soit 'No Answer', et la deuxième ligne est la différence si le mot est \"Chanceux\", ou 0 sinon.\nExemple d'utilisation :\n>>> is_lucky_word \"error\"\nLucky Word\n2\n>>> is_lucky_word \"olympic\"\nNo Answer\n0",
      "de": "Schreiben Sie eine Shell-Funktion `is_lucky_word() {\nlocal word=$1\nlocal -A letter_counts\n`, um das folgende Problem zu lösen:\nDiese Funktion überprüft, ob das gegebene Wort ein \"Lucky Word\" ist.\nEin Wort wird als \"Lucky\" betrachtet, wenn die Differenz zwischen der höchsten und niedrigsten Buchstabenhäufigkeit eine Primzahl ist.\nEingabe: Ein einzelnes Wort bestehend aus Kleinbuchstaben und mit einer Länge von weniger als 100.\nAusgabe: Zwei Zeilen - die erste Zeile ist entweder 'Lucky Word' oder 'No Answer', und die zweite Zeile ist die Differenz, wenn das Wort \"Lucky\" ist, oder 0 andernfalls.\nBeispielverwendung:\n>>> is_lucky_word \"error\"\nLucky Word\n2\n>>> is_lucky_word \"olympic\"\nNo Answer\n0",
      "ha": "Rubuta wani aikin Shell `is_lucky_word() {\nlocal word=$1\nlocal -A letter_counts\n` don warware matsalar mai zuwa:\nWannan aikin yana duba idan kalmar da aka bayar tana da \"Kalmar Sa'a\".\nAna ɗaukar kalma tana da \"Sa'a\" idan bambanci tsakanin mafi girma da mafi ƙanƙanta yawan haruffa lamba ce mai lamba.\nShigarwa: Kalma guda ɗaya mai ƙunshi ƙananan haruffa kuma mai tsawon ƙasa da 100.\nFitarwa: Layuka biyu - layi na farko ko dai 'Lucky Word' ko 'No Answer', kuma layi na biyu shine bambanci idan kalmar tana da \"Sa'a\", ko 0 in ba haka ba.\nMisalin Amfani:\n>>> is_lucky_word \"error\"\nLucky Word\n2\n>>> is_lucky_word \"olympic\"\nNo Answer\n0",
      "hi": "Shell फ़ंक्शन `is_lucky_word() {\nlocal word=$1\nlocal -A letter_counts\n` निम्नलिखित समस्या को हल करने के लिए लिखें:\nयह फ़ंक्शन यह जांचता है कि दिया गया शब्द \"Lucky Word\" है या नहीं।\nएक शब्द को \"Lucky\" तब माना जाता है जब सबसे अधिक और सबसे कम अक्षर आवृत्ति के बीच का अंतर एक अभाज्य संख्या होता है।\nइनपुट: एकल शब्द जिसमें छोटे अक्षर होते हैं और जिसकी लंबाई 100 से कम होती है।\nआउटपुट: दो पंक्तियाँ - पहली पंक्ति या तो 'Lucky Word' या 'No Answer' होती है, और दूसरी पंक्ति अंतर होता है यदि शब्द \"Lucky\" है, अन्यथा 0।\nउदाहरण उपयोग:\n>>> is_lucky_word \"error\"\nLucky Word\n2\n>>> is_lucky_word \"olympic\"\nNo Answer\n0",
      "hu": "Írj egy Shell függvényt `is_lucky_word() {\nlocal word=$1\nlocal -A letter_counts\n`, hogy megoldja a következő problémát:\nEz a függvény ellenőrzi, hogy a megadott szó \"Szerencsés Szó\"-e.\nEgy szót akkor tekintünk \"Szerencsésnek\", ha a leggyakoribb és a legkevésbé gyakori betűk előfordulásának különbsége prímszám.\nBemenet: Egyetlen szó, amely kisbetűkből áll, és hossza kevesebb mint 100.\nKimenet: Két sor - az első sor vagy 'Lucky Word' vagy 'No Answer', a második sor pedig a különbség, ha a szó \"Szerencsés\", vagy 0 egyébként.\nPélda használat:\n>>> is_lucky_word \"error\"\nLucky Word\n2\n>>> is_lucky_word \"olympic\"\nNo Answer\n0"
    },
    "instruction_bertscore": {
      "sq": "0.9905060636776755",
      "hy": "0.9830784792092568",
      "bn": "0.9822724371230173",
      "bg": "0.9864349353879844",
      "zh": "0.9741548107108835",
      "fr": "0.9832665821800969",
      "de": "0.9918347022964178",
      "ha": "0.9830840408599258",
      "hi": "0.9691858730989147",
      "hu": "0.9758560799244472"
    },
    "level": "hard",
    "test": "test_is_lucky_word() {\nlocal result\nresult=$(is_lucky_word \"error\")\n[[ $result == $'Lucky Word\\n2' ]] || { echo \"Test 1 failed\"; exit 1; }\nresult=$(is_lucky_word \"olympic\")\n[[ $result == $'No Answer\\n0' ]] || { echo \"Test 2 failed\"; exit 1; }\nresult=$(is_lucky_word \"apple\")\n[[ $result == $'No Answer\\n0' ]] || { echo \"Test 3 failed\"; exit 1; }\n}\n\ntest_is_lucky_word",
    "entry_point": "is_lucky_word",
    "signature": "is_lucky_word() {\nlocal word=$1\nlocal -A letter_counts\n",
    "docstring": {
      "en": "This function checks if the given word is a \"Lucky Word\".\nA word is considered \"Lucky\" if the difference between the highest and lowest letter frequency is a prime number.\nInput: A single word consisting of lowercase letters and with a length less than 100.\nOutput: Two lines - the first line is either 'Lucky Word' or 'No Answer', and the second line is the difference if the word is \"Lucky\", or 0 otherwise.\nExample Usage:\n>>> is_lucky_word \"error\"\nLucky Word\n2\n>>> is_lucky_word \"olympic\"\nNo Answer\n0",
      "sq": "Kjo funksion kontrollon nëse fjala e dhënë është një \"Fjalë me Fat\".  \nNjë fjalë konsiderohet \"me Fat\" nëse diferenca midis frekuencës më të lartë dhe më të ulët të shkronjave është një numër i thjeshtë.  \nHyrja: Një fjalë e vetme që përbëhet nga shkronja të vogla dhe me gjatësi më pak se 100.  \nDalja: Dy rreshta - rreshti i parë është ose 'Fjalë me Fat' ose 'Pa Përgjigje', dhe rreshti i dytë është diferenca nëse fjala është \"me Fat\", ose 0 përndryshe.  \nShembull Përdorimi:  \n>>> is_lucky_word \"error\"  \nFjalë me Fat  \n2  \n>>> is_lucky_word \"olympic\"  \nPa Përgjigje  \n0  ",
      "hy": "Այս ֆունկցիան ստուգում է, արդյոք տրված բառը \"Բախտավոր Բառ\" է:\nԲառը համարվում է \"Բախտավոր\", եթե ամենաբարձր և ամենացածր տառերի հաճախականությունների տարբերությունը պարզ թիվ է:\nՄուտք: Միայն մեկ բառ, որը բաղկացած է փոքրատառերից և ունի 100-ից պակաս երկարություն:\nԵլք: Երկու տող - առաջին տողը կամ 'Բախտավոր Բառ' է կամ 'Պատասխան Չկա', իսկ երկրորդ տողը տարբերությունն է, եթե բառը \"Բախտավոր\" է, կամ 0՝ հակառակ դեպքում:\nՕրինակային Օգտագործում:\n>>> is_lucky_word \"error\"\nLucky Word\n2\n>>> is_lucky_word \"olympic\"\nNo Answer\n0",
      "bn": "এই ফাংশনটি নির্ধারণ করে যে প্রদত্ত শব্দটি \"লাকি ওয়ার্ড\" কিনা। একটি শব্দকে \"লাকি\" বিবেচনা করা হয় যদি সর্বোচ্চ এবং সর্বনিম্ন অক্ষর ফ্রিকোয়েন্সির মধ্যে পার্থক্য একটি মৌলিক সংখ্যা হয়।  \nইনপুট: ছোট হাতের অক্ষর নিয়ে গঠিত একটি শব্দ এবং যার দৈর্ঘ্য ১০০ এর কম।  \nআউটপুট: দুটি লাইন - প্রথম লাইনটি হয় 'Lucky Word' অথবা 'No Answer', এবং দ্বিতীয় লাইনটি পার্থক্য যদি শব্দটি \"লাকি\" হয়, অথবা অন্যথায় 0।  \nউদাহরণ ব্যবহার:  \n>>> is_lucky_word \"error\"  \nLucky Word  \n2  \n>>> is_lucky_word \"olympic\"  \nNo Answer  \n0  ",
      "bg": "Тази функция проверява дали дадената дума е \"Щастлива дума\".  \nЕдна дума се счита за \"Щастлива\", ако разликата между най-високата и най-ниската честота на буквите е просто число.  \nВход: Една дума, състояща се от малки букви и с дължина по-малка от 100.  \nИзход: Два реда - първият ред е или 'Щастлива дума', или 'Няма отговор', а вторият ред е разликата, ако думата е \"Щастлива\", или 0 в противен случай.  \nПример за използване:  \n>>> is_lucky_word \"error\"  \nLucky Word  \n2  \n>>> is_lucky_word \"olympic\"  \nNo Answer  \n0  ",
      "zh": "该函数检查给定的单词是否为“幸运单词”。  \n如果最高和最低字母频率之间的差是一个质数，则该单词被认为是“幸运的”。  \n输入：一个由小写字母组成且长度小于100的单词。  \n输出：两行 - 第一行是 'Lucky Word' 或 'No Answer'，第二行是如果单词是“幸运的”则为差值，否则为0。  \n示例用法:  \n>>> is_lucky_word \"error\"  \nLucky Word  \n2  \n>>> is_lucky_word \"olympic\"  \nNo Answer  \n0  ",
      "fr": "Cette fonction vérifie si le mot donné est un \"Mot Chanceux\".  \nUn mot est considéré comme \"Chanceux\" si la différence entre la fréquence la plus élevée et la plus basse des lettres est un nombre premier.  \nEntrée : Un seul mot composé de lettres minuscules et d'une longueur inférieure à 100.  \nSortie : Deux lignes - la première ligne est soit 'Mot Chanceux' soit 'Pas de Réponse', et la deuxième ligne est la différence si le mot est \"Chanceux\", ou 0 sinon.  \nExemple d'utilisation :  \n>>> is_lucky_word \"error\"  \nLucky Word  \n2  \n>>> is_lucky_word \"olympic\"  \nNo Answer  \n0  ",
      "de": "Diese Funktion überprüft, ob das gegebene Wort ein \"Glückliches Wort\" ist.  \nEin Wort wird als \"Glücklich\" betrachtet, wenn die Differenz zwischen der höchsten und niedrigsten Buchstabenhäufigkeit eine Primzahl ist.  \nEingabe: Ein einzelnes Wort, bestehend aus Kleinbuchstaben und mit einer Länge von weniger als 100.  \nAusgabe: Zwei Zeilen - die erste Zeile ist entweder 'Glückliches Wort' oder 'Keine Antwort', und die zweite Zeile ist die Differenz, wenn das Wort \"Glücklich\" ist, oder 0 andernfalls.  \nBeispielverwendung:  \n>>> is_lucky_word \"error\"  \nGlückliches Wort  \n2  \n>>> is_lucky_word \"olympic\"  \nKeine Antwort  \n0  ",
      "ha": "Wannan aikin yana duba ko kalmar da aka bayar \"Kalmar Sa'a\" ce.\nAna ɗaukar kalma \"Mai Sa'a\" idan bambancin tsakanin mafi yawan harafi da mafi ƙarancin yawan harafi lamba ce mai firam.\nShigarwa: Kalma guda ɗaya da ke ƙunshe da ƙananan haruffa kuma da tsawo ƙasa da 100.\nFitarwa: Layuka biyu - layin farko ko dai 'Kalmar Sa'a' ko 'Babu Amsa', kuma layin na biyu shine bambancin idan kalmar \"Mai Sa'a\" ce, ko 0 in ba haka ba.\nMisalin Amfani:\n>>> is_lucky_word \"error\"\nKalmar Sa'a\n2\n>>> is_lucky_word \"olympic\"\nBabu Amsa\n0",
      "hi": "यह फ़ंक्शन यह जांचता है कि दिया गया शब्द \"Lucky Word\" है या नहीं।  \nएक शब्द को \"Lucky\" माना जाता है यदि उच्चतम और निम्नतम अक्षर आवृत्ति के बीच का अंतर एक अभाज्य संख्या है।  \nइनपुट: एकल शब्द जो छोटे अक्षरों से बना होता है और जिसकी लंबाई 100 से कम होती है।  \nआउटपुट: दो पंक्तियाँ - पहली पंक्ति या तो 'Lucky Word' होती है या 'No Answer', और दूसरी पंक्ति अंतर होता है यदि शब्द \"Lucky\" है, अन्यथा 0।  \nउदाहरण उपयोग:  \n>>> is_lucky_word \"error\"  \nLucky Word  \n2  \n>>> is_lucky_word \"olympic\"  \nNo Answer  \n0  ",
      "hu": "Ez a függvény ellenőrzi, hogy a megadott szó \"Szerencsés Szó\"-e.  \nEgy szót akkor tekintünk \"Szerencsésnek\", ha a leggyakoribb és a legkevésbé gyakori betűk gyakorisága közötti különbség prím szám.  \nBemenet: Egyetlen szó, amely kisbetűkből áll, és hossza kevesebb mint 100.  \nKimenet: Két sor - az első sor vagy 'Szerencsés Szó', vagy 'Nincs Válasz', a második sor pedig a különbség, ha a szó \"Szerencsés\", vagy 0 egyébként.  \nPélda használat:  \n>>> is_lucky_word \"error\"  \nSzerencsés Szó  \n2  \n>>> is_lucky_word \"olympic\"  \nNincs Válasz  \n0  "
    },
    "docstring_bertscore": {
      "sq": "0.9862937091870686",
      "hy": "0.9923465727883447",
      "bn": "0.9682300637053748",
      "bg": "0.9859552430177851",
      "zh": "0.969437935052448",
      "fr": "0.9869243606468543",
      "de": "0.9905300979537807",
      "ha": "0.9731255080763607",
      "hi": "0.9732458780872678",
      "hu": "0.9667258358297977"
    }
  },
  {
    "task_id": "Shell/34",
    "prompt": {
      "en": "find_kth_smallest_unique_number() {\nlocal numbers=($1)\nlocal k=$2\n\n# This function finds the kth smallest unique number from a list of positive integers. \n# Duplicate numbers are only counted once. If k is greater than the number of unique elements, \n# it returns 'NO RESULT'.\n# Args:\n# $1: A string of space-separated positive integers.\n# $2: An integer representing the value of k.\n# Returns:\n# The kth smallest unique number or 'NO RESULT' if k is too large.\n# Example:\n# find_kth_smallest_unique_number \"1 2 2 3 4\" 3\n# # Returns: 3\n# find_kth_smallest_unique_number \"7 8 9 10 11\" 6\n# # Returns: NO RESULT",
      "sq": "find_kth_smallest_unique_number() {\nlocal numbers=($1)\nlocal k=$2\n\n# Kjo funksion gjen numrin e kth më të vogël unik nga një listë numrash pozitivë.\n# Numrat e dyfishtë numërohen vetëm një herë. Nëse k është më i madh se numri i elementeve unike,\n# kthen 'NO RESULT'.\n# Argumentet:\n# $1: Një varg me numra pozitivë të ndarë me hapësira.\n# $2: Një numër i plotë që përfaqëson vlerën e k.\n# Kthen:\n# Numri i kth më i vogël unik ose 'NO RESULT' nëse k është shumë i madh.\n# Shembull:\n# find_kth_smallest_unique_number \"1 2 2 3 4\" 3\n# # Kthen: 3\n# find_kth_smallest_unique_number \"7 8 9 10 11\" 6\n# # Kthen: NO RESULT",
      "hy": "find_kth_smallest_unique_number() {\nlocal numbers=($1)\nlocal k=$2\n\n# Այս ֆունկցիան գտնում է k-րդ ամենափոքր եզակի թիվը դրական ամբողջ թվերի ցուցակից։\n# Կրկնվող թվերը հաշվում են միայն մեկ անգամ։ Եթե k-ն մեծ է եզակի տարրերի քանակից,\n# վերադարձնում է 'NO RESULT':\n# Արգումենտներ:\n# $1: Տարածքով բաժանված դրական ամբողջ թվերի տող։\n# $2: k-ի արժեքը ներկայացնող ամբողջ թիվ։\n# Վերադարձնում է:\n# k-րդ ամենափոքր եզակի թիվը կամ 'NO RESULT', եթե k-ն շատ մեծ է։\n# Օրինակ:\n# find_kth_smallest_unique_number \"1 2 2 3 4\" 3\n# # Վերադարձնում է: 3\n# find_kth_smallest_unique_number \"7 8 9 10 11\" 6\n# # Վերադարձնում է: NO RESULT",
      "bn": "find_kth_smallest_unique_number() {\nlocal numbers=($1)\nlocal k=$2\n\n# এই ফাংশনটি একটি ধনাত্মক পূর্ণসংখ্যার তালিকা থেকে kতম ক্ষুদ্রতম অনন্য সংখ্যা খুঁজে বের করে।\n# সদৃশ সংখ্যাগুলি কেবল একবার গণনা করা হয়। যদি k অনন্য উপাদানগুলির সংখ্যার চেয়ে বেশি হয়,\n# এটি 'NO RESULT' ফেরত দেয়।\n# আর্গুমেন্টসমূহ:\n# $1: স্পেস দ্বারা পৃথক ধনাত্মক পূর্ণসংখ্যার একটি স্ট্রিং।\n# $2: k এর মান প্রতিনিধিত্বকারী একটি পূর্ণসংখ্যা।\n# ফেরত দেয়:\n# kতম ক্ষুদ্রতম অনন্য সংখ্যা অথবা যদি k খুব বড় হয় তবে 'NO RESULT'।\n# উদাহরণ:\n# find_kth_smallest_unique_number \"1 2 2 3 4\" 3\n# # ফেরত দেয়: 3\n# find_kth_smallest_unique_number \"7 8 9 10 11\" 6\n# # ফেরত দেয়: NO RESULT",
      "bg": "find_kth_smallest_unique_number() {\nlocal numbers=($1)\nlocal k=$2\n\n# Тази функция намира k-тото най-малко уникално число от списък с положителни цели числа.\n# Дублиращите се числа се броят само веднъж. Ако k е по-голямо от броя на уникалните елементи,\n# функцията връща 'NO RESULT'.\n# Аргументи:\n# $1: Низ от положителни цели числа, разделени с интервали.\n# $2: Цяло число, представляващо стойността на k.\n# Връща:\n# k-тото най-малко уникално число или 'NO RESULT', ако k е твърде голямо.\n# Пример:\n# find_kth_smallest_unique_number \"1 2 2 3 4\" 3\n# # Връща: 3\n# find_kth_smallest_unique_number \"7 8 9 10 11\" 6\n# # Връща: NO RESULT",
      "zh": "find_kth_smallest_unique_number() {\nlocal numbers=($1)\nlocal k=$2\n\n# 此函数从正整数列表中查找第k小的唯一数字。\n# 重复的数字只计算一次。如果k大于唯一元素的数量，\n# 则返回'NO RESULT'。\n# 参数：\n# $1: 一个由空格分隔的正整数字符串。\n# $2: 一个整数，表示k的值。\n# 返回：\n# 第k小的唯一数字，如果k过大则返回'NO RESULT'。\n# 示例：\n# find_kth_smallest_unique_number \"1 2 2 3 4\" 3\n# # 返回: 3\n# find_kth_smallest_unique_number \"7 8 9 10 11\" 6\n# # 返回: NO RESULT",
      "fr": "find_kth_smallest_unique_number() {\nlocal numbers=($1)\nlocal k=$2\n\n# Cette fonction trouve le k-ième plus petit nombre unique d'une liste d'entiers positifs.\n# Les nombres en double ne sont comptés qu'une seule fois. Si k est supérieur au nombre d'éléments uniques,\n# elle retourne 'NO RESULT'.\n# Arguments :\n# $1 : Une chaîne de caractères d'entiers positifs séparés par des espaces.\n# $2 : Un entier représentant la valeur de k.\n# Renvoie :\n# Le k-ième plus petit nombre unique ou 'NO RESULT' si k est trop grand.\n# Exemple :\n# find_kth_smallest_unique_number \"1 2 2 3 4\" 3\n# # Renvoie : 3\n# find_kth_smallest_unique_number \"7 8 9 10 11\" 6\n# # Renvoie : NO RESULT",
      "de": "find_kth_smallest_unique_number() {\nlocal numbers=($1)\nlocal k=$2\n\n# Diese Funktion findet die k-kleinste eindeutige Zahl aus einer Liste positiver Ganzzahlen.\n# Doppelte Zahlen werden nur einmal gezählt. Wenn k größer als die Anzahl der eindeutigen Elemente ist,\n# gibt sie 'NO RESULT' zurück.\n# Argumente:\n# $1: Ein String aus durch Leerzeichen getrennten positiven Ganzzahlen.\n# $2: Eine Ganzzahl, die den Wert von k darstellt.\n# Rückgabe:\n# Die k-kleinste eindeutige Zahl oder 'NO RESULT', wenn k zu groß ist.\n# Beispiel:\n# find_kth_smallest_unique_number \"1 2 2 3 4\" 3\n# # Gibt zurück: 3\n# find_kth_smallest_unique_number \"7 8 9 10 11\" 6\n# # Gibt zurück: NO RESULT",
      "ha": "find_kth_smallest_unique_number() {\nlocal numbers=($1)\nlocal k=$2\n\n# Wannan aikin yana nemo lamba ta k mafi ƙanƙanta daga jerin lambobi masu kyau. \n# Lambobi masu maimaitawa ana ƙirga su sau ɗaya kawai. Idan k ya fi yawan abubuwan da ba su maimaita ba, \n# zai dawo da 'NO RESULT'.\n# Args:\n# $1: Wani jeri na lambobi masu kyau da aka raba da sarari.\n# $2: Lamba mai nuni da ƙimar k.\n# Returns:\n# Lamba ta k mafi ƙanƙanta ko 'NO RESULT' idan k ya yi girma sosai.\n# Misali:\n# find_kth_smallest_unique_number \"1 2 2 3 4\" 3\n# # Returns: 3\n# find_kth_smallest_unique_number \"7 8 9 10 11\" 6\n# # Returns: NO RESULT",
      "hi": "find_kth_smallest_unique_number() {\nlocal numbers=($1)\nlocal k=$2\n\n# यह फ़ंक्शन सकारात्मक पूर्णांकों की सूची से kth सबसे छोटा अद्वितीय संख्या खोजता है।\n# डुप्लिकेट संख्याओं को केवल एक बार गिना जाता है। यदि k अद्वितीय तत्वों की संख्या से अधिक है,\n# तो यह 'NO RESULT' लौटाता है।\n# तर्क:\n# $1: स्पेस से अलग किए गए सकारात्मक पूर्णांकों की एक स्ट्रिंग।\n# $2: k के मान का प्रतिनिधित्व करने वाला एक पूर्णांक।\n# लौटाता है:\n# kth सबसे छोटा अद्वितीय संख्या या 'NO RESULT' यदि k बहुत बड़ा है।\n# उदाहरण:\n# find_kth_smallest_unique_number \"1 2 2 3 4\" 3\n# # लौटाता है: 3\n# find_kth_smallest_unique_number \"7 8 9 10 11\" 6\n# # लौटाता है: NO RESULT",
      "hu": "find_kth_smallest_unique_number() {\nlocal numbers=($1)\nlocal k=$2\n\n# Ez a függvény megkeresi a k-adik legkisebb egyedi számot egy pozitív egész számokat tartalmazó listából.\n# Az ismétlődő számokat csak egyszer számítja. Ha k nagyobb, mint az egyedi elemek száma,\n# akkor 'NO RESULT'-ot ad vissza.\n# Argumentumok:\n# $1: Szóközzel elválasztott pozitív egész számokból álló string.\n# $2: Egy egész szám, amely k értékét jelöli.\n# Visszatér:\n# A k-adik legkisebb egyedi szám vagy 'NO RESULT', ha k túl nagy.\n# Példa:\n# find_kth_smallest_unique_number \"1 2 2 3 4\" 3\n# # Visszatér: 3\n# find_kth_smallest_unique_number \"7 8 9 10 11\" 6\n# # Visszatér: NO RESULT"
    },
    "prompt_bertscore": {
      "sq": "0.9809078464053076",
      "hy": "0.9831229724146087",
      "bn": "0.9799913658272126",
      "bg": "0.9762992243045361",
      "zh": "0.9771662459177534",
      "fr": "0.9802591195808477",
      "de": "0.9774266503472901",
      "ha": "0.9603074923274173",
      "hi": "0.9880051085500652",
      "hu": "0.9787721725484204"
    },
    "canonical_solution": "local sorted_unique_numbers=($(printf '%s\\n' \"${numbers[@]}\" | sort -n | uniq))\n\n# Check if k is within the range\nif [[ $k -le ${#sorted_unique_numbers[@]} && $k -gt 0 ]]; then\necho ${sorted_unique_numbers[$((k-1))]}\nelse\necho \"NO RESULT\"\nfi\n}",
    "instruction": {
      "en": "Write a Shell function `find_kth_smallest_unique_number() {\nlocal numbers=($1)\nlocal k=$2\n\n` to solve the following problem:\nThis function finds the kth smallest unique number from a list of positive integers. \nDuplicate numbers are only counted once. If k is greater than the number of unique elements, \nit returns 'NO RESULT'.\nArgs:\n$1: A string of space-separated positive integers.\n$2: An integer representing the value of k.\nReturns:\nThe kth smallest unique number or 'NO RESULT' if k is too large.\nExample:\nfind_kth_smallest_unique_number \"1 2 2 3 4\" 3\nReturns: 3\nfind_kth_smallest_unique_number \"7 8 9 10 11\" 6\nReturns: NO RESULT",
      "sq": "Shkruani një funksion Shell `find_kth_smallest_unique_number() {\nlocal numbers=($1)\nlocal k=$2\n\n` për të zgjidhur problemin e mëposhtëm:\nKy funksion gjen numrin e kth më të vogël unik nga një listë e numrave të plotë pozitivë. \nNumrat e dyfishtë numërohen vetëm një herë. Nëse k është më i madh se numri i elementeve unike, \nkthehet 'NO RESULT'.\nArgumentet:\n$1: Një varg me numra të plotë pozitivë të ndarë me hapësirë.\n$2: Një numër i plotë që përfaqëson vlerën e k.\nKthen:\nNumrin e kth më të vogël unik ose 'NO RESULT' nëse k është shumë i madh.\nShembull:\nfind_kth_smallest_unique_number \"1 2 2 3 4\" 3\nKthen: 3\nfind_kth_smallest_unique_number \"7 8 9 10 11\" 6\nKthen: NO RESULT",
      "hy": "Գրեք Shell ֆունկցիա `find_kth_smallest_unique_number() {\nlocal numbers=($1)\nlocal k=$2\n\n` հետևյալ խնդիրը լուծելու համար:\nԱյս ֆունկցիան գտնում է k-րդ ամենափոքր եզակի թիվը դրական ամբողջ թվերի ցուցակից:\nԿրկնվող թվերը հաշվում են միայն մեկ անգամ: Եթե k-ն մեծ է եզակի տարրերի քանակից,\nայն վերադարձնում է 'NO RESULT':\nԱրգումենտներ:\n$1: Դրական ամբողջ թվերի բացատով բաժանված տող:\n$2: k-ի արժեքը ներկայացնող ամբողջ թիվ:\nՎերադարձնում է:\nk-րդ ամենափոքր եզակի թիվը կամ 'NO RESULT', եթե k-ն չափազանց մեծ է:\nՕրինակ:\nfind_kth_smallest_unique_number \"1 2 2 3 4\" 3\nՎերադարձնում է: 3\nfind_kth_smallest_unique_number \"7 8 9 10 11\" 6\nՎերադարձնում է: NO RESULT",
      "bn": "একটি Shell ফাংশন লিখুন `find_kth_smallest_unique_number() {\nlocal numbers=($1)\nlocal k=$2\n\n` নিম্নলিখিত সমস্যাটি সমাধান করতে:\nএই ফাংশনটি একটি ধনাত্মক পূর্ণসংখ্যার তালিকা থেকে k তম ক্ষুদ্রতম অনন্য সংখ্যা খুঁজে বের করে। \nডুপ্লিকেট সংখ্যা কেবল একবার গণনা করা হয়। যদি k অনন্য উপাদানগুলির সংখ্যার চেয়ে বেশি হয়, \nতাহলে এটি 'NO RESULT' ফেরত দেয়।\nআর্গুমেন্টসমূহ:\n$1: স্পেস দ্বারা পৃথক করা ধনাত্মক পূর্ণসংখ্যার একটি স্ট্রিং।\n$2: k এর মান নির্দেশকারী একটি পূর্ণসংখ্যা।\nফেরত দেয়:\nk তম ক্ষুদ্রতম অনন্য সংখ্যা বা যদি k খুব বড় হয় তবে 'NO RESULT'।\nউদাহরণ:\nfind_kth_smallest_unique_number \"1 2 2 3 4\" 3\nফেরত দেয়: 3\nfind_kth_smallest_unique_number \"7 8 9 10 11\" 6\nফেরত দেয়: NO RESULT",
      "bg": "Напишете Shell функция `find_kth_smallest_unique_number() {\nlocal numbers=($1)\nlocal k=$2\n\n` за решаване на следния проблем:\nТази функция намира k-тото най-малко уникално число от списък с положителни цели числа.\nДублиращите се числа се броят само веднъж. Ако k е по-голямо от броя на уникалните елементи,\nвръща 'NO RESULT'.\nАргументи:\n$1: Низ от положителни цели числа, разделени с интервали.\n$2: Цяло число, представляващо стойността на k.\nВръща:\nk-тото най-малко уникално число или 'NO RESULT', ако k е твърде голямо.\nПример:\nfind_kth_smallest_unique_number \"1 2 2 3 4\" 3\nВръща: 3\nfind_kth_smallest_unique_number \"7 8 9 10 11\" 6\nВръща: NO RESULT",
      "zh": "编写一个 Shell 函数 `find_kth_smallest_unique_number() {\nlocal numbers=($1)\nlocal k=$2\n\n` 来解决以下问题：\n此函数从正整数列表中查找第 k 小的唯一数字。\n重复的数字只计算一次。如果 k 大于唯一元素的数量，\n则返回 'NO RESULT'。\n参数：\n$1: 一个由空格分隔的正整数字符串。\n$2: 一个整数，表示 k 的值。\n返回：\n第 k 小的唯一数字，如果 k 太大则返回 'NO RESULT'。\n示例：\nfind_kth_smallest_unique_number \"1 2 2 3 4\" 3\n返回：3\nfind_kth_smallest_unique_number \"7 8 9 10 11\" 6\n返回：NO RESULT",
      "fr": "Écrire une fonction Shell `find_kth_smallest_unique_number() {\nlocal numbers=($1)\nlocal k=$2\n\n` pour résoudre le problème suivant :\nCette fonction trouve le k-ième plus petit nombre unique d'une liste d'entiers positifs.\nLes nombres en double ne sont comptés qu'une seule fois. Si k est supérieur au nombre d'éléments uniques,\nelle renvoie 'NO RESULT'.\nArgs:\n$1: Une chaîne de caractères d'entiers positifs séparés par des espaces.\n$2: Un entier représentant la valeur de k.\nRenvoie:\nLe k-ième plus petit nombre unique ou 'NO RESULT' si k est trop grand.\nExemple:\nfind_kth_smallest_unique_number \"1 2 2 3 4\" 3\nRenvoie: 3\nfind_kth_smallest_unique_number \"7 8 9 10 11\" 6\nRenvoie: NO RESULT",
      "de": "Schreiben Sie eine Shell-Funktion `find_kth_smallest_unique_number() {\nlocal numbers=($1)\nlocal k=$2\n\n`, um das folgende Problem zu lösen:\nDiese Funktion findet die k-te kleinste eindeutige Zahl aus einer Liste von positiven ganzen Zahlen. \nDoppelte Zahlen werden nur einmal gezählt. Wenn k größer als die Anzahl der eindeutigen Elemente ist, \ngibt sie 'NO RESULT' zurück.\nArgumente:\n$1: Ein String von durch Leerzeichen getrennten positiven ganzen Zahlen.\n$2: Eine ganze Zahl, die den Wert von k darstellt.\nRückgabe:\nDie k-te kleinste eindeutige Zahl oder 'NO RESULT', wenn k zu groß ist.\nBeispiel:\nfind_kth_smallest_unique_number \"1 2 2 3 4\" 3\nGibt zurück: 3\nfind_kth_smallest_unique_number \"7 8 9 10 11\" 6\nGibt zurück: NO RESULT",
      "ha": "Rubuta wani aikin Shell `find_kth_smallest_unique_number() {\nlocal numbers=($1)\nlocal k=$2\n\n` don warware matsalar mai zuwa:\nWannan aikin yana nemo lamba ta k mafi ƙanƙanta daga jerin lambobi masu kyau. \nAna ƙidaya lambobi masu maimaituwa sau ɗaya kawai. Idan k ya fi yawan abubuwan da ba su maimaitu ba, \nyana dawowa da 'NO RESULT'.\nArgs:\n$1: Wani jeren lambobi masu kyau da aka raba da sarari.\n$2: Wani lamba wanda ke wakiltar ƙimar k.\nReturns:\nLamba ta k mafi ƙanƙanta ko 'NO RESULT' idan k ya yi girma sosai.\nMisali:\nfind_kth_smallest_unique_number \"1 2 2 3 4\" 3\nReturns: 3\nfind_kth_smallest_unique_number \"7 8 9 10 11\" 6\nReturns: NO RESULT",
      "hi": "Write a Shell function `find_kth_smallest_unique_number() {\nlocal numbers=($1)\nlocal k=$2\n\n` निम्नलिखित समस्या को हल करने के लिए:\nयह फ़ंक्शन सकारात्मक पूर्णांकों की सूची से kवां सबसे छोटा अद्वितीय संख्या खोजता है। \nडुप्लिकेट संख्याओं को केवल एक बार गिना जाता है। यदि k अद्वितीय तत्वों की संख्या से अधिक है, \nतो यह 'NO RESULT' लौटाता है।\nआर्ग्स:\n$1: स्पेस से अलग किए गए सकारात्मक पूर्णांकों की एक स्ट्रिंग।\n$2: k के मान का प्रतिनिधित्व करने वाला एक पूर्णांक।\nवापसी करता है:\nkवां सबसे छोटा अद्वितीय संख्या या 'NO RESULT' यदि k बहुत बड़ा है।\nउदाहरण:\nfind_kth_smallest_unique_number \"1 2 2 3 4\" 3\nवापसी करता है: 3\nfind_kth_smallest_unique_number \"7 8 9 10 11\" 6\nवापसी करता है: NO RESULT",
      "hu": "Írj egy Shell függvényt `find_kth_smallest_unique_number() {\nlocal numbers=($1)\nlocal k=$2\n\n` a következő probléma megoldására:\nEz a függvény megkeresi a lista k-adik legkisebb egyedi számát pozitív egészekből. \nAz ismétlődő számokat csak egyszer számítja. Ha k nagyobb, mint az egyedi elemek száma, \n'NO RESULT'-ot ad vissza.\nArgumentumok:\n$1: Szóközzel elválasztott pozitív egészeket tartalmazó karakterlánc.\n$2: Egy egész szám, amely k értékét jelöli.\nVisszatérési érték:\nA k-adik legkisebb egyedi szám vagy 'NO RESULT', ha k túl nagy.\nPélda:\nfind_kth_smallest_unique_number \"1 2 2 3 4\" 3\nVisszatér: 3\nfind_kth_smallest_unique_number \"7 8 9 10 11\" 6\nVisszatér: NO RESULT"
    },
    "instruction_bertscore": {
      "sq": "0.9925722169012003",
      "hy": "0.9826615540394646",
      "bn": "0.972506575809056",
      "bg": "0.9780541237209793",
      "zh": "0.9767183344085197",
      "fr": "0.9857635647000864",
      "de": "0.9770484581017997",
      "ha": "0.9707898134257714",
      "hi": "0.9888081711805893",
      "hu": "0.9742334683417733"
    },
    "level": "easy",
    "test": "test_kth_smallest_unique_number() {\n[[ $(find_kth_smallest_unique_number \"5 1 3 5 2 4 1\" 4) == \"4\" ]] || { echo \"Test 1 failed\"; exit 1; }\n[[ $(find_kth_smallest_unique_number \"8 7 6 5 4 3 2 1\" 3) == \"3\" ]] || { echo \"Test 2 failed\"; exit 1; }\n[[ $(find_kth_smallest_unique_number \"9 9 8 8 7 7\" 2) == \"8\" ]] || { echo \"Test 3 failed\"; exit 1; }\n[[ $(find_kth_smallest_unique_number \"10 20 30 40 50\" 5) == \"50\" ]] || { echo \"Test 4 failed\"; exit 1; }\n[[ $(find_kth_smallest_unique_number \"15 15 15 15 15\" 1) == \"15\" ]] || { echo \"Test 5 failed\"; exit 1; }\n[[ $(find_kth_smallest_unique_number \"1 2 3 4 5\" 6) == \"NO RESULT\" ]] || { echo \"Test 6 failed\"; exit 1; }\n[[ $(find_kth_smallest_unique_number \"3 3 3 3 3\" 2) == \"NO RESULT\" ]] || { echo \"Test 7 failed\"; exit 1; }\n}\n\ntest_kth_smallest_unique_number",
    "entry_point": "find_kth_smallest_unique_number",
    "signature": "find_kth_smallest_unique_number() {\nlocal numbers=($1)\nlocal k=$2\n\n",
    "docstring": {
      "en": "This function finds the kth smallest unique number from a list of positive integers. \nDuplicate numbers are only counted once. If k is greater than the number of unique elements, \nit returns 'NO RESULT'.\nArgs:\n$1: A string of space-separated positive integers.\n$2: An integer representing the value of k.\nReturns:\nThe kth smallest unique number or 'NO RESULT' if k is too large.\nExample:\nfind_kth_smallest_unique_number \"1 2 2 3 4\" 3\nReturns: 3\nfind_kth_smallest_unique_number \"7 8 9 10 11\" 6\nReturns: NO RESULT",
      "sq": "Kjo funksion gjen numrin e kth më të vogël unik nga një listë e numrave të plotë pozitivë. Numrat e dyfishtë numërohen vetëm një herë. Nëse k është më i madh se numri i elementeve unike, kthen 'NO RESULT'.\nArgumentet:\n$1: Një varg me numra të plotë pozitivë të ndarë me hapësirë.\n$2: Një numër i plotë që përfaqëson vlerën e k.\nKthen:\nNumrin e kth më të vogël unik ose 'NO RESULT' nëse k është shumë i madh.\nShembull:\nfind_kth_smallest_unique_number \"1 2 2 3 4\" 3\nKthen: 3\nfind_kth_smallest_unique_number \"7 8 9 10 11\" 6\nKthen: NO RESULT",
      "hy": "Այս ֆունկցիան գտնում է թվերի ցանկից k-րդ ամենափոքր եզակի թիվը: Կրկնվող թվերը հաշվում են միայն մեկ անգամ: Եթե k-ն մեծ է եզակի տարրերի քանակից, վերադարձնում է 'NO RESULT':\nԱրձագանքներ:\n$1: Դրական ամբողջ թվերի տարածքով բաժանված տող:\n$2: k-ի արժեքը ներկայացնող ամբողջ թիվ:\nՎերադարձնում է:\nk-րդ ամենափոքր եզակի թիվը կամ 'NO RESULT', եթե k-ն չափազանց մեծ է:\nՕրինակ:\nfind_kth_smallest_unique_number \"1 2 2 3 4\" 3\nՎերադարձնում է: 3\nfind_kth_smallest_unique_number \"7 8 9 10 11\" 6\nՎերադարձնում է: NO RESULT",
      "bn": "এই ফাংশনটি একটি ধনাত্মক পূর্ণসংখ্যার তালিকা থেকে kতম ক্ষুদ্রতম অনন্য সংখ্যা খুঁজে বের করে। \nডুপ্লিকেট সংখ্যা কেবল একবার গণনা করা হয়। যদি k অনন্য উপাদানের সংখ্যার চেয়ে বেশি হয়, \nতাহলে এটি 'NO RESULT' প্রদান করে।\nArgs:\n$1: স্পেস দ্বারা পৃথক ধনাত্মক পূর্ণসংখ্যার একটি স্ট্রিং।\n$2: k এর মানকে উপস্থাপনকারী একটি পূর্ণসংখ্যা।\nReturns:\nkতম ক্ষুদ্রতম অনন্য সংখ্যা বা যদি k খুব বড় হয় তবে 'NO RESULT'।\nExample:\nfind_kth_smallest_unique_number \"1 2 2 3 4\" 3\nReturns: 3\nfind_kth_smallest_unique_number \"7 8 9 10 11\" 6\nReturns: NO RESULT",
      "bg": "Тази функция намира k-тото най-малко уникално число от списък с положителни цели числа. \nДублиращите се числа се броят само веднъж. Ако k е по-голямо от броя на уникалните елементи, \nвръща 'NO RESULT'.\nАргументи:\n$1: Низ от положителни цели числа, разделени с интервали.\n$2: Цяло число, представляващо стойността на k.\nВръща:\nk-тото най-малко уникално число или 'NO RESULT', ако k е твърде голямо.\nПример:\nfind_kth_smallest_unique_number \"1 2 2 3 4\" 3\nВръща: 3\nfind_kth_smallest_unique_number \"7 8 9 10 11\" 6\nВръща: NO RESULT",
      "zh": "这个函数从一个正整数列表中找到第k个最小的唯一数字。重复的数字只计算一次。如果k大于唯一元素的数量，则返回“NO RESULT”。\n参数：\n$1: 一个由空格分隔的正整数字符串。\n$2: 一个整数，表示k的值。\n返回：\n第k个最小的唯一数字，如果k太大则返回“NO RESULT”。\n示例：\nfind_kth_smallest_unique_number \"1 2 2 3 4\" 3\n返回: 3\nfind_kth_smallest_unique_number \"7 8 9 10 11\" 6\n返回: NO RESULT",
      "fr": "Cette fonction trouve le k-ième plus petit nombre unique d'une liste d'entiers positifs. Les nombres en double ne sont comptés qu'une seule fois. Si k est supérieur au nombre d'éléments uniques, elle renvoie 'AUCUN RÉSULTAT'.\nArgs:\n$1: Une chaîne de caractères d'entiers positifs séparés par des espaces.\n$2: Un entier représentant la valeur de k.\nReturns:\nLe k-ième plus petit nombre unique ou 'AUCUN RÉSULTAT' si k est trop grand.\nExample:\nfind_kth_smallest_unique_number \"1 2 2 3 4\" 3\nReturns: 3\nfind_kth_smallest_unique_number \"7 8 9 10 11\" 6\nReturns: NO RESULT",
      "de": "Diese Funktion findet die k-kleinste eindeutige Zahl aus einer Liste von positiven ganzen Zahlen. Doppelte Zahlen werden nur einmal gezählt. Wenn k größer als die Anzahl der eindeutigen Elemente ist, gibt sie 'KEIN ERGEBNIS' zurück.\nArgs:\n$1: Ein String aus durch Leerzeichen getrennten positiven ganzen Zahlen.\n$2: Eine ganze Zahl, die den Wert von k darstellt.\nReturns:\nDie k-kleinste eindeutige Zahl oder 'KEIN ERGEBNIS', wenn k zu groß ist.\nExample:\nfind_kth_smallest_unique_number \"1 2 2 3 4\" 3\nReturns: 3\nfind_kth_smallest_unique_number \"7 8 9 10 11\" 6\nReturns: NO RESULT",
      "ha": "Wannan aikin yana nemo lamba ta k mafi ƙanƙanta daga jerin lambobin integers masu kyau. \nAna ƙidaya lambobi masu maimaitawa sau ɗaya kawai. Idan k ya fi yawan abubuwan da ba su maimaita ba, \nyana dawo da 'BA SAKAMAKO'.\nArgs:\n$1: Wani kirtani na lambobin integers masu kyau da aka raba da sarari.\n$2: Wani integer da ke wakiltar ƙimar k.\nReturns:\nLamba ta k mafi ƙanƙanta ko 'BA SAKAMAKO' idan k ya yi girma sosai.\nExample:\nfind_kth_smallest_unique_number \"1 2 2 3 4\" 3\nReturns: 3\nfind_kth_smallest_unique_number \"7 8 9 10 11\" 6\nReturns: NO RESULT",
      "hi": "यह फ़ंक्शन सकारात्मक पूर्णांकों की सूची से kवां सबसे छोटा अद्वितीय संख्या ढूंढता है। \nडुप्लिकेट संख्याओं को केवल एक बार गिना जाता है। यदि k अद्वितीय तत्वों की संख्या से अधिक है, \nतो यह 'NO RESULT' लौटाता है।\nआर्ग्स:\n$1: स्पेस से अलग किए गए सकारात्मक पूर्णांकों की एक स्ट्रिंग।\n$2: k के मान का प्रतिनिधित्व करने वाला एक पूर्णांक।\nरिटर्न्स:\nkवां सबसे छोटा अद्वितीय संख्या या 'NO RESULT' यदि k बहुत बड़ा है।\nउदाहरण:\nfind_kth_smallest_unique_number \"1 2 2 3 4\" 3\nरिटर्न्स: 3\nfind_kth_smallest_unique_number \"7 8 9 10 11\" 6\nरिटर्न्स: NO RESULT",
      "hu": "Ez a függvény megkeresi a lista k-adik legkisebb egyedi számát pozitív egész számokból. \nAz ismétlődő számokat csak egyszer számítja. Ha k nagyobb, mint az egyedi elemek száma, \n'NO RESULT'-ot ad vissza.\nArgs:\n$1: Szóközzel elválasztott pozitív egész számokat tartalmazó karakterlánc.\n$2: Egy egész szám, amely k értékét jelöli.\nReturns:\nA k-adik legkisebb egyedi szám vagy 'NO RESULT', ha k túl nagy.\nExample:\nfind_kth_smallest_unique_number \"1 2 2 3 4\" 3\nReturns: 3\nfind_kth_smallest_unique_number \"7 8 9 10 11\" 6\nReturns: NO RESULT"
    },
    "docstring_bertscore": {
      "sq": "0.9829020954308979",
      "hy": "0.9800338727287541",
      "bn": "0.9815152581105123",
      "bg": "0.9739951118845314",
      "zh": "0.9705298062569967",
      "fr": "0.981832073568263",
      "de": "0.9884029652032781",
      "ha": "0.9593878336632258",
      "hi": "0.9883378144382986",
      "hu": "0.972552459427075"
    }
  },
  {
    "task_id": "Shell/35",
    "prompt": {
      "en": "convert_bases() {\nlocal input_base=$1\nlocal number=$2\nlocal target_base=$3\n# This function converts a number from one base to another.\n# The function accepts three arguments: the base of the input number (2 to 16),\n# the number to be converted (in string format), and the base to which it should be converted (2 to 16).\n# The function returns the converted number in string format.\n# The input number may include digits 0-9 and uppercase letters A-F for bases higher than 10.\n# If the input number or the base is invalid, the function returns 'INVALID INPUT'.\n# Examples:\n# convert_bases 10 \"255\" 2\n# # Returns: \"11111111\"\n# convert_bases 2 \"1010\" 16\n# # Returns: \"A\"\n# convert_bases 8 \"17\" 10\n# # Returns: \"15\"",
      "sq": "convert_bases() {\nlocal input_base=$1\nlocal number=$2\nlocal target_base=$3\n# Kjo funksion konverton një numër nga një bazë në një tjetër.\n# Funksioni pranon tre argumente: baza e numrit hyrës (2 deri në 16),\n# numri që do të konvertohet (në formatin e vargut), dhe baza në të cilën duhet të konvertohet (2 deri në 16).\n# Funksioni kthen numrin e konvertuar në formatin e vargut.\n# Numri hyrës mund të përfshijë shifra 0-9 dhe shkronja të mëdha A-F për bazat më të larta se 10.\n# Nëse numri hyrës ose baza është e pavlefshme, funksioni kthen 'INPUT I PAVLEFSHËM'.\n# Shembuj:\n# convert_bases 10 \"255\" 2\n# # Kthen: \"11111111\"\n# convert_bases 2 \"1010\" 16\n# # Kthen: \"A\"\n# convert_bases 8 \"17\" 10\n# # Kthen: \"15\"",
      "hy": "convert_bases() {\nlocal input_base=$1\nlocal number=$2\nlocal target_base=$3\n# Այս ֆունկցիան փոխարկում է թիվը մեկ հիմքից մյուսը։\n# Ֆունկցիան ընդունում է երեք արգումենտ՝ մուտքային թվի հիմքը (2-ից 16),\n# փոխարկվող թիվը (տողային ձևաչափով), և հիմքը, որին այն պետք է փոխարկվի (2-ից 16)։\n# Ֆունկցիան վերադարձնում է փոխարկված թիվը տողային ձևաչափով։\n# Մուտքային թիվը կարող է ներառել 0-9 թվանշաններ և մեծատառ A-F տառեր 10-ից բարձր հիմքերի համար։\n# Եթե մուտքային թիվը կամ հիմքը անվավեր են, ֆունկցիան վերադարձնում է 'INVALID INPUT'։\n# Օրինակներ:\n# convert_bases 10 \"255\" 2\n# # Վերադարձնում է: \"11111111\"\n# convert_bases 2 \"1010\" 16\n# # Վերադարձնում է: \"A\"\n# convert_bases 8 \"17\" 10\n# # Վերադարձնում է: \"15\"",
      "bn": "convert_bases() {\nlocal input_base=$1\nlocal number=$2\nlocal target_base=$3\n# এই ফাংশনটি একটি সংখ্যা এক ভিত্তি থেকে অন্য ভিত্তিতে রূপান্তর করে।\n# ফাংশনটি তিনটি আর্গুমেন্ট গ্রহণ করে: ইনপুট সংখ্যার ভিত্তি (2 থেকে 16),\n# রূপান্তরিত করতে হবে এমন সংখ্যা (স্ট্রিং ফরম্যাটে), এবং যে ভিত্তিতে এটি রূপান্তরিত করা উচিত (2 থেকে 16)।\n# ফাংশনটি রূপান্তরিত সংখ্যাটি স্ট্রিং ফরম্যাটে ফেরত দেয়।\n# ইনপুট সংখ্যাটি 10 এর বেশি ভিত্তির জন্য সংখ্যা 0-9 এবং বড় হাতের অক্ষর A-F অন্তর্ভুক্ত করতে পারে।\n# যদি ইনপুট সংখ্যা বা ভিত্তি অবৈধ হয়, ফাংশনটি 'INVALID INPUT' ফেরত দেয়।\n# উদাহরণ:\n# convert_bases 10 \"255\" 2\n# # ফেরত দেয়: \"11111111\"\n# convert_bases 2 \"1010\" 16\n# # ফেরত দেয়: \"A\"\n# convert_bases 8 \"17\" 10\n# # ফেরত দেয়: \"15\"",
      "bg": "convert_bases() {\nlocal input_base=$1\nlocal number=$2\nlocal target_base=$3\n# Тази функция преобразува число от една база в друга.\n# Функцията приема три аргумента: базата на входното число (2 до 16),\n# числото, което трябва да бъде преобразувано (в стрингов формат), и базата, в която трябва да бъде преобразувано (2 до 16).\n# Функцията връща преобразуваното число в стрингов формат.\n# Входното число може да включва цифри 0-9 и главни букви A-F за бази по-високи от 10.\n# Ако входното число или базата са невалидни, функцията връща 'INVALID INPUT'.\n# Примери:\n# convert_bases 10 \"255\" 2\n# # Връща: \"11111111\"\n# convert_bases 2 \"1010\" 16\n# # Връща: \"A\"\n# convert_bases 8 \"17\" 10\n# # Връща: \"15\"",
      "zh": "convert_bases() {\nlocal input_base=$1\nlocal number=$2\nlocal target_base=$3\n# 这个函数将一个数字从一个进制转换为另一个进制。\n# 函数接受三个参数：输入数字的进制（2到16），\n# 要转换的数字（字符串格式），以及要转换到的进制（2到16）。\n# 函数返回转换后的数字，格式为字符串。\n# 输入数字可能包括数字0-9和大写字母A-F用于大于10的进制。\n# 如果输入数字或进制无效，函数返回 'INVALID INPUT'。\n# 示例：\n# convert_bases 10 \"255\" 2\n# # 返回: \"11111111\"\n# convert_bases 2 \"1010\" 16\n# # 返回: \"A\"\n# convert_bases 8 \"17\" 10\n# # 返回: \"15\"",
      "fr": "convert_bases() {\nlocal input_base=$1\nlocal number=$2\nlocal target_base=$3\n# Cette fonction convertit un nombre d'une base à une autre.\n# La fonction accepte trois arguments : la base du nombre d'entrée (2 à 16),\n# le nombre à convertir (en format chaîne), et la base vers laquelle il doit être converti (2 à 16).\n# La fonction renvoie le nombre converti en format chaîne.\n# Le nombre d'entrée peut inclure les chiffres 0-9 et les lettres majuscules A-F pour les bases supérieures à 10.\n# Si le nombre d'entrée ou la base est invalide, la fonction renvoie 'INVALID INPUT'.\n# Exemples :\n# convert_bases 10 \"255\" 2\n# # Renvoie : \"11111111\"\n# convert_bases 2 \"1010\" 16\n# # Renvoie : \"A\"\n# convert_bases 8 \"17\" 10\n# # Renvoie : \"15\"",
      "de": "convert_bases() {\nlocal input_base=$1\nlocal number=$2\nlocal target_base=$3\n# Diese Funktion konvertiert eine Zahl von einer Basis in eine andere.\n# Die Funktion akzeptiert drei Argumente: die Basis der Eingabezahl (2 bis 16),\n# die zu konvertierende Zahl (im String-Format) und die Basis, in die sie konvertiert werden soll (2 bis 16).\n# Die Funktion gibt die konvertierte Zahl im String-Format zurück.\n# Die Eingabezahl kann Ziffern 0-9 und Großbuchstaben A-F für Basen größer als 10 enthalten.\n# Wenn die Eingabezahl oder die Basis ungültig ist, gibt die Funktion 'INVALID INPUT' zurück.\n# Beispiele:\n# convert_bases 10 \"255\" 2\n# # Gibt zurück: \"11111111\"\n# convert_bases 2 \"1010\" 16\n# # Gibt zurück: \"A\"\n# convert_bases 8 \"17\" 10\n# # Gibt zurück: \"15\"",
      "ha": "convert_bases() {\nlocal input_base=$1\nlocal number=$2\nlocal target_base=$3\n# Wannan aikin yana sauya lambar daga wata tushe zuwa wata.\n# Aikin yana karɓar hujjoji guda uku: tushen lambar shigarwa (2 zuwa 16),\n# lambar da za a sauya (a cikin tsarin kirtani), da tushen da za a sauya ta (2 zuwa 16).\n# Aikin yana mayar da lambar da aka sauya a cikin tsarin kirtani.\n# Lambar shigarwa na iya haɗawa da lambobi 0-9 da manyan haruffa A-F don tushen da suka fi 10.\n# Idan lambar shigarwa ko tushen ba daidai ba ne, aikin yana mayar da 'INVALID INPUT'.\n# Misalai:\n# convert_bases 10 \"255\" 2\n# # Yana Mayar: \"11111111\"\n# convert_bases 2 \"1010\" 16\n# # Yana Mayar: \"A\"\n# convert_bases 8 \"17\" 10\n# # Yana Mayar: \"15\"",
      "hi": "convert_bases() {\nlocal input_base=$1\nlocal number=$2\nlocal target_base=$3\n# यह फ़ंक्शन एक संख्या को एक आधार से दूसरे आधार में परिवर्तित करता है।\n# फ़ंक्शन तीन तर्क स्वीकार करता है: इनपुट संख्या का आधार (2 से 16),\n# परिवर्तित की जाने वाली संख्या (स्ट्रिंग प्रारूप में), और वह आधार जिसमें इसे परिवर्तित किया जाना चाहिए (2 से 16)।\n# फ़ंक्शन परिवर्तित संख्या को स्ट्रिंग प्रारूप में लौटाता है।\n# इनपुट संख्या में 0-9 अंक और 10 से अधिक आधारों के लिए अपरकेस अक्षर A-F शामिल हो सकते हैं।\n# यदि इनपुट संख्या या आधार अमान्य है, तो फ़ंक्शन 'INVALID INPUT' लौटाता है।\n# उदाहरण:\n# convert_bases 10 \"255\" 2\n# # लौटाता है: \"11111111\"\n# convert_bases 2 \"1010\" 16\n# # लौटाता है: \"A\"\n# convert_bases 8 \"17\" 10\n# # लौटाता है: \"15\"",
      "hu": "convert_bases() {\nlocal input_base=$1\nlocal number=$2\nlocal target_base=$3\n# Ez a függvény egy számot átalakít egyik számrendszerből a másikba.\n# A függvény három argumentumot fogad el: a bemeneti szám számrendszerét (2-től 16-ig),\n# az átalakítandó számot (string formátumban), és a cél számrendszert, amelybe át kell alakítani (2-től 16-ig).\n# A függvény az átalakított számot string formátumban adja vissza.\n# A bemeneti szám tartalmazhat 0-9 számjegyeket és nagybetűs A-F betűket a 10-nél nagyobb számrendszerek esetén.\n# Ha a bemeneti szám vagy a számrendszer érvénytelen, a függvény 'INVALID INPUT'-ot ad vissza.\n# Példák:\n# convert_bases 10 \"255\" 2\n# # Visszaadja: \"11111111\"\n# convert_bases 2 \"1010\" 16\n# # Visszaadja: \"A\"\n# convert_bases 8 \"17\" 10\n# # Visszaadja: \"15\""
    },
    "prompt_bertscore": {
      "sq": "0.9978170521124266",
      "hy": "0.9915274210969568",
      "bn": "0.987293018634055",
      "bg": "0.9987837861769234",
      "zh": "0.9829394379425325",
      "fr": "0.9925749977265348",
      "de": "0.9975381750574536",
      "ha": "0.9765381766529211",
      "hi": "0.9952481653945023",
      "hu": "0.9527061062755932"
    },
    "canonical_solution": "if [[ $input_base -lt 2 || $input_base -gt 16 || $target_base -lt 2 || $target_base -gt 16 ]]; then\necho \"INVALID INPUT\"\nreturn 1\nfi\n\n# Convert input number to decimal\nlocal decimal_number=$(echo \"ibase=$input_base; $number\" | bc)\n\n# Convert decimal number to target base\nlocal converted_number=$(echo \"obase=$target_base; $decimal_number\" | bc)\n\necho $converted_number\n}",
    "instruction": {
      "en": "Write a Shell function `convert_bases() {\nlocal input_base=$1\nlocal number=$2\nlocal target_base=$3\n` to solve the following problem:\nThis function converts a number from one base to another.\nThe function accepts three arguments: the base of the input number (2 to 16),\nthe number to be converted (in string format), and the base to which it should be converted (2 to 16).\nThe function returns the converted number in string format.\nThe input number may include digits 0-9 and uppercase letters A-F for bases higher than 10.\nIf the input number or the base is invalid, the function returns 'INVALID INPUT'.\nExamples:\nconvert_bases 10 \"255\" 2\nReturns: \"11111111\"\nconvert_bases 2 \"1010\" 16\nReturns: \"A\"\nconvert_bases 8 \"17\" 10\nReturns: \"15\"",
      "sq": "Shkruani një funksion Shell `convert_bases() {\nlocal input_base=$1\nlocal number=$2\nlocal target_base=$3\n` për të zgjidhur problemin e mëposhtëm:\nKy funksion konverton një numër nga një bazë në një tjetër.\nFunksioni pranon tre argumente: baza e numrit hyrës (2 deri në 16),\nnumri që do të konvertohet (në formatin string), dhe baza në të cilën duhet të konvertohet (2 deri në 16).\nFunksioni kthen numrin e konvertuar në formatin string.\nNumri hyrës mund të përfshijë shifra 0-9 dhe shkronja të mëdha A-F për bazat më të larta se 10.\nNëse numri hyrës ose baza është e pavlefshme, funksioni kthen 'INVALID INPUT'.\nShembuj:\nconvert_bases 10 \"255\" 2\nKthen: \"11111111\"\nconvert_bases 2 \"1010\" 16\nKthen: \"A\"\nconvert_bases 8 \"17\" 10\nKthen: \"15\"",
      "hy": "Shell ֆունկցիա գրեք `convert_bases() {\nlocal input_base=$1\nlocal number=$2\nlocal target_base=$3\n` հետևյալ խնդիրը լուծելու համար:\nԱյս ֆունկցիան փոխակերպում է թիվը մեկ հիմքից մյուսը:\nՖունկցիան ընդունում է երեք արգումենտ՝ մուտքային թվի հիմքը (2-ից 16),\nփոխակերպվող թիվը (տողի ձևաչափով) և հիմքը, որին պետք է փոխակերպվի (2-ից 16):\nՖունկցիան վերադարձնում է փոխակերպված թիվը տողի ձևաչափով:\nՄուտքային թիվը կարող է ներառել 0-9 թվանշաններ և մեծատառ A-F տառեր 10-ից բարձր հիմքերի համար:\nԵթե մուտքային թիվը կամ հիմքը անվավեր են, ֆունկցիան վերադարձնում է 'INVALID INPUT':\nՕրինակներ:\nconvert_bases 10 \"255\" 2\nՎերադարձնում է: \"11111111\"\nconvert_bases 2 \"1010\" 16\nՎերադարձնում է: \"A\"\nconvert_bases 8 \"17\" 10\nՎերադարձնում է: \"15\"",
      "bn": "একটি Shell ফাংশন লিখুন `convert_bases() {\nlocal input_base=$1\nlocal number=$2\nlocal target_base=$3\n` নিম্নলিখিত সমস্যার সমাধানের জন্য:\nএই ফাংশনটি একটি সংখ্যা একটি ভিত্তি থেকে অন্য ভিত্তিতে রূপান্তর করে।\nফাংশনটি তিনটি আর্গুমেন্ট গ্রহণ করে: ইনপুট সংখ্যার ভিত্তি (2 থেকে 16),\nরূপান্তরিত করার জন্য সংখ্যা (স্ট্রিং ফরম্যাটে), এবং যে ভিত্তিতে এটি রূপান্তরিত হওয়া উচিত (2 থেকে 16)।\nফাংশনটি স্ট্রিং ফরম্যাটে রূপান্তরিত সংখ্যা ফেরত দেয়।\nইনপুট সংখ্যাটি 10 এর বেশি ভিত্তির জন্য 0-9 সংখ্যা এবং বড় হাতের অক্ষর A-F অন্তর্ভুক্ত করতে পারে।\nযদি ইনপুট সংখ্যা বা ভিত্তি অবৈধ হয়, ফাংশনটি 'INVALID INPUT' ফেরত দেয়।\nউদাহরণ:\nconvert_bases 10 \"255\" 2\nফেরত দেয়: \"11111111\"\nconvert_bases 2 \"1010\" 16\nফেরত দেয়: \"A\"\nconvert_bases 8 \"17\" 10\nফেরত দেয়: \"15\"",
      "bg": "Напишете Shell функция `convert_bases() {\nlocal input_base=$1\nlocal number=$2\nlocal target_base=$3\n` за решаване на следния проблем:\nТази функция преобразува число от една база в друга.\nФункцията приема три аргумента: базата на входното число (от 2 до 16),\nчислото, което трябва да бъде преобразувано (в стрингов формат), и базата, в която трябва да бъде преобразувано (от 2 до 16).\nФункцията връща преобразуваното число в стрингов формат.\nВходното число може да включва цифри 0-9 и главни букви A-F за бази по-високи от 10.\nАко входното число или базата са невалидни, функцията връща 'INVALID INPUT'.\nПримери:\nconvert_bases 10 \"255\" 2\nВръща: \"11111111\"\nconvert_bases 2 \"1010\" 16\nВръща: \"A\"\nconvert_bases 8 \"17\" 10\nВръща: \"15\"",
      "zh": "编写一个 Shell 函数 `convert_bases() {\nlocal input_base=$1\nlocal number=$2\nlocal target_base=$3\n` 来解决以下问题：\n此函数将一个数字从一个进制转换为另一个进制。\n函数接受三个参数：输入数字的进制（2到16），要转换的数字（字符串格式），以及要转换到的进制（2到16）。\n函数返回转换后的数字（字符串格式）。\n输入数字可能包含数字0-9和大写字母A-F（对于大于10的进制）。\n如果输入数字或进制无效，函数返回 'INVALID INPUT'。\n示例：\nconvert_bases 10 \"255\" 2\n返回: \"11111111\"\nconvert_bases 2 \"1010\" 16\n返回: \"A\"\nconvert_bases 8 \"17\" 10\n返回: \"15\"",
      "fr": "Écrire une fonction Shell `convert_bases() {\nlocal input_base=$1\nlocal number=$2\nlocal target_base=$3\n` pour résoudre le problème suivant :\nCette fonction convertit un nombre d'une base à une autre.\nLa fonction accepte trois arguments : la base du nombre d'entrée (2 à 16),\nle nombre à convertir (en format chaîne), et la base vers laquelle il doit être converti (2 à 16).\nLa fonction renvoie le nombre converti en format chaîne.\nLe nombre d'entrée peut inclure les chiffres 0-9 et les lettres majuscules A-F pour les bases supérieures à 10.\nSi le nombre d'entrée ou la base est invalide, la fonction renvoie 'INVALID INPUT'.\nExemples :\nconvert_bases 10 \"255\" 2\nRenvoie : \"11111111\"\nconvert_bases 2 \"1010\" 16\nRenvoie : \"A\"\nconvert_bases 8 \"17\" 10\nRenvoie : \"15\"",
      "de": "Schreiben Sie eine Shell-Funktion `convert_bases() {\nlocal input_base=$1\nlocal number=$2\nlocal target_base=$3\n` um das folgende Problem zu lösen:\nDiese Funktion konvertiert eine Zahl von einer Basis in eine andere.\nDie Funktion akzeptiert drei Argumente: die Basis der Eingabezahl (2 bis 16),\ndie zu konvertierende Zahl (im String-Format) und die Basis, in die sie konvertiert werden soll (2 bis 16).\nDie Funktion gibt die konvertierte Zahl im String-Format zurück.\nDie Eingabezahl kann Ziffern 0-9 und Großbuchstaben A-F für Basen größer als 10 enthalten.\nWenn die Eingabezahl oder die Basis ungültig ist, gibt die Funktion 'INVALID INPUT' zurück.\nBeispiele:\nconvert_bases 10 \"255\" 2\nGibt zurück: \"11111111\"\nconvert_bases 2 \"1010\" 16\nGibt zurück: \"A\"\nconvert_bases 8 \"17\" 10\nGibt zurück: \"15\"",
      "ha": "Rubuta aikin Shell `convert_bases() {\nlocal input_base=$1\nlocal number=$2\nlocal target_base=$3\n` don warware matsalar mai zuwa:\nWannan aikin yana canza lambar daga wata tushe zuwa wata.\nAikin yana karɓar hujjoji guda uku: tushe na lambar shigarwa (2 zuwa 16),\nlambar da za a canza (a cikin tsarin kirtani), da tushe inda za a canza ta (2 zuwa 16).\nAikin yana dawowa da lambar da aka canza a cikin tsarin kirtani.\nLambar shigarwa na iya haɗawa da lambobi 0-9 da manyan haruffa A-F don tushe mafi girma fiye da 10.\nIdan lambar shigarwa ko tushe ba daidai ba ne, aikin yana dawowa da 'INVALID INPUT'.\nMisalai:\nconvert_bases 10 \"255\" 2\nYana dawowa: \"11111111\"\nconvert_bases 2 \"1010\" 16\nYana dawowa: \"A\"\nconvert_bases 8 \"17\" 10\nYana dawowa: \"15\"",
      "hi": "Write a Shell function `convert_bases() {\nlocal input_base=$1\nlocal number=$2\nlocal target_base=$3\n` निम्नलिखित समस्या को हल करने के लिए:\nयह फ़ंक्शन एक संख्या को एक आधार से दूसरे आधार में परिवर्तित करता है।\nफ़ंक्शन तीन तर्क स्वीकार करता है: इनपुट संख्या का आधार (2 से 16),\nसंख्या जिसे परिवर्तित किया जाना है (स्ट्रिंग प्रारूप में), और आधार जिसमें इसे परिवर्तित किया जाना चाहिए (2 से 16)।\nफ़ंक्शन परिवर्तित संख्या को स्ट्रिंग प्रारूप में लौटाता है।\nइनपुट संख्या में 0-9 अंक और 10 से अधिक के आधारों के लिए अपरकेस अक्षर A-F शामिल हो सकते हैं।\nयदि इनपुट संख्या या आधार अमान्य है, तो फ़ंक्शन 'INVALID INPUT' लौटाता है।\nउदाहरण:\nconvert_bases 10 \"255\" 2\nलौटाता है: \"11111111\"\nconvert_bases 2 \"1010\" 16\nलौटाता है: \"A\"\nconvert_bases 8 \"17\" 10\nलौटाता है: \"15\"",
      "hu": "Írj egy Shell függvényt `convert_bases() {\nlocal input_base=$1\nlocal number=$2\nlocal target_base=$3\n` a következő probléma megoldására:\nEz a függvény egy számot konvertál egyik számrendszerből a másikba.\nA függvény három argumentumot fogad el: a bemeneti szám alapját (2-től 16-ig),\na konvertálandó számot (sztring formátumban), és azt az alapot, amelyre konvertálni kell (2-től 16-ig).\nA függvény a konvertált számot sztring formátumban adja vissza.\nA bemeneti szám tartalmazhat 0-9 közötti számjegyeket és nagybetűs A-F betűket a 10-nél nagyobb alapok esetén.\nHa a bemeneti szám vagy az alap érvénytelen, a függvény 'INVALID INPUT'-ot ad vissza.\nPéldák:\nconvert_bases 10 \"255\" 2\nVisszatér: \"11111111\"\nconvert_bases 2 \"1010\" 16\nVisszatér: \"A\"\nconvert_bases 8 \"17\" 10\nVisszatér: \"15\""
    },
    "instruction_bertscore": {
      "sq": "0.9977244903548643",
      "hy": "0.987531375091297",
      "bn": "0.9949241992430344",
      "bg": "0.9921821068328478",
      "zh": "0.9779434865987429",
      "fr": "0.9935427249429368",
      "de": "0.9966002423982069",
      "ha": "0.984924351340214",
      "hi": "0.9951331584038832",
      "hu": "0.9794264610235494"
    },
    "level": "easy",
    "test": "test_convert_bases() {\n[[ $(convert_bases 10 \"1024\" 2) == \"10000000000\" ]] || { echo \"Test 1 failed\"; exit 1; }\n[[ $(convert_bases 16 \"1A3\" 8) == \"643\" ]] || { echo \"Test 2 failed\"; exit 1; }\n[[ $(convert_bases 2 \"1101\" 10) == \"13\" ]] || { echo \"Test 3 failed\"; exit 1; }\n[[ $(convert_bases 16 \"ABC\" 2) == \"101010111100\" ]] || { echo \"Test 4 failed\"; exit 1; }\n[[ $(convert_bases 8 \"777\" 16) == \"1FF\" ]] || { echo \"Test 5 failed\"; exit 1; }\n[[ $(convert_bases 4 \"123\" 10) == \"27\" ]] || { echo \"Test 6 failed\"; exit 1; }\n[[ $(convert_bases 20 \"1A\" 2) == \"INVALID INPUT\" ]] || { echo \"Test 7 failed\"; exit 1; }\n}\n\ntest_convert_bases",
    "entry_point": "convert_bases",
    "signature": "convert_bases() {\nlocal input_base=$1\nlocal number=$2\nlocal target_base=$3\n",
    "docstring": {
      "en": "This function converts a number from one base to another.\nThe function accepts three arguments: the base of the input number (2 to 16),\nthe number to be converted (in string format), and the base to which it should be converted (2 to 16).\nThe function returns the converted number in string format.\nThe input number may include digits 0-9 and uppercase letters A-F for bases higher than 10.\nIf the input number or the base is invalid, the function returns 'INVALID INPUT'.\nExamples:\nconvert_bases 10 \"255\" 2\nReturns: \"11111111\"\nconvert_bases 2 \"1010\" 16\nReturns: \"A\"\nconvert_bases 8 \"17\" 10\nReturns: \"15\"",
      "sq": "Kjo funksion konverton një numër nga një bazë në një tjetër.\nFunksioni pranon tre argumente: baza e numrit hyrës (2 deri në 16),\nnumri që do të konvertohet (në formatin e vargut), dhe baza në të cilën duhet të konvertohet (2 deri në 16).\nFunksioni kthen numrin e konvertuar në formatin e vargut.\nNumri hyrës mund të përfshijë shifra 0-9 dhe shkronja të mëdha A-F për baza më të larta se 10.\nNëse numri hyrës ose baza është e pavlefshme, funksioni kthen 'INPUT I PAVLEFSHËM'.\nShembuj:\nconvert_bases 10 \"255\" 2\nKthen: \"11111111\"\nconvert_bases 2 \"1010\" 16\nKthen: \"A\"\nconvert_bases 8 \"17\" 10\nKthen: \"15\"",
      "hy": "Այս ֆունկցիան փոխակերպում է թիվը մի հիմքից մյուսը:\nՖունկցիան ընդունում է երեք արգումենտ՝ մուտքային թվի հիմքը (2-ից 16),\nփոխակերպվող թիվը (տողային ձևաչափով) և հիմքը, որին այն պետք է փոխակերպվի (2-ից 16):\nՖունկցիան վերադարձնում է փոխակերպված թիվը տողային ձևաչափով:\nՄուտքային թիվը կարող է ներառել թվանշաններ 0-9 և մեծատառեր A-F՝ 10-ից բարձր հիմքերի համար:\nԵթե մուտքային թիվը կամ հիմքը անվավեր է, ֆունկցիան վերադարձնում է 'INVALID INPUT':\nՕրինակներ:\nconvert_bases 10 \"255\" 2\nՎերադարձնում է: \"11111111\"\nconvert_bases 2 \"1010\" 16\nՎերադարձնում է: \"A\"\nconvert_bases 8 \"17\" 10\nՎերադարձնում է: \"15\"",
      "bn": "এই ফাংশনটি একটি সংখ্যা এক ভিত্তি থেকে অন্য ভিত্তিতে রূপান্তর করে। \nফাংশনটি তিনটি আর্গুমেন্ট গ্রহণ করে: ইনপুট সংখ্যার ভিত্তি (2 থেকে 16), \nরূপান্তর করার জন্য সংখ্যা (স্ট্রিং ফরম্যাটে), এবং যে ভিত্তিতে এটি রূপান্তর করা উচিত (2 থেকে 16)। \nফাংশনটি রূপান্তরিত সংখ্যাটি স্ট্রিং ফরম্যাটে ফেরত দেয়। \nইনপুট সংখ্যাটি 10 এর বেশি ভিত্তির জন্য সংখ্যা 0-9 এবং বড় হাতের অক্ষর A-F অন্তর্ভুক্ত করতে পারে। \nযদি ইনপুট সংখ্যা বা ভিত্তি অবৈধ হয়, ফাংশনটি 'INVALID INPUT' ফেরত দেয়। \nউদাহরণসমূহ:\nconvert_bases 10 \"255\" 2\nফেরত দেয়: \"11111111\"\nconvert_bases 2 \"1010\" 16\nফেরত দেয়: \"A\"\nconvert_bases 8 \"17\" 10\nফেরত দেয়: \"15\"",
      "bg": "Тази функция преобразува число от една база в друга.\nФункцията приема три аргумента: базата на входното число (от 2 до 16),\nчислото, което трябва да бъде преобразувано (в стрингов формат), и базата, в която трябва да бъде преобразувано (от 2 до 16).\nФункцията връща преобразуваното число в стрингов формат.\nВходното число може да включва цифри от 0-9 и главни букви A-F за бази по-високи от 10.\nАко входното число или базата са невалидни, функцията връща 'INVALID INPUT'.\nПримери:\nconvert_bases 10 \"255\" 2\nВръща: \"11111111\"\nconvert_bases 2 \"1010\" 16\nВръща: \"A\"\nconvert_bases 8 \"17\" 10\nВръща: \"15\"",
      "zh": "这个函数将一个数字从一个进制转换为另一个进制。\n函数接受三个参数：输入数字的进制（2到16），要转换的数字（字符串格式），以及要转换到的进制（2到16）。\n函数返回转换后的数字，格式为字符串。\n输入数字可能包括数字0-9和大写字母A-F（对于大于10的进制）。\n如果输入数字或进制无效，函数返回“INVALID INPUT”。\n示例：\nconvert_bases 10 \"255\" 2\n返回: \"11111111\"\nconvert_bases 2 \"1010\" 16\n返回: \"A\"\nconvert_bases 8 \"17\" 10\n返回: \"15\"",
      "fr": "Cette fonction convertit un nombre d'une base à une autre.  \nLa fonction accepte trois arguments : la base du nombre d'entrée (2 à 16),  \nle nombre à convertir (en format chaîne de caractères), et la base vers laquelle il doit être converti (2 à 16).  \nLa fonction renvoie le nombre converti en format chaîne de caractères.  \nLe nombre d'entrée peut inclure les chiffres 0-9 et les lettres majuscules A-F pour les bases supérieures à 10.  \nSi le nombre d'entrée ou la base est invalide, la fonction renvoie 'INVALID INPUT'.  \nExemples :  \nconvert_bases 10 \"255\" 2  \nRenvoie : \"11111111\"  \nconvert_bases 2 \"1010\" 16  \nRenvoie : \"A\"  \nconvert_bases 8 \"17\" 10  \nRenvoie : \"15\"  ",
      "de": "Diese Funktion konvertiert eine Zahl von einer Basis in eine andere.\nDie Funktion akzeptiert drei Argumente: die Basis der Eingabezahl (2 bis 16),\ndie zu konvertierende Zahl (im String-Format) und die Basis, in die sie konvertiert werden soll (2 bis 16).\nDie Funktion gibt die konvertierte Zahl im String-Format zurück.\nDie Eingabezahl kann Ziffern 0-9 und Großbuchstaben A-F für Basen größer als 10 enthalten.\nWenn die Eingabezahl oder die Basis ungültig ist, gibt die Funktion 'INVALID INPUT' zurück.\nBeispiele:\nconvert_bases 10 \"255\" 2\nGibt zurück: \"11111111\"\nconvert_bases 2 \"1010\" 16\nGibt zurück: \"A\"\nconvert_bases 8 \"17\" 10\nGibt zurück: \"15\"",
      "ha": "Wannan aikin yana canza lamba daga wata tushe zuwa wata.\nAikin yana karɓar hujjoji guda uku: tushen lambar shigarwa (2 zuwa 16),\nlambar da za a canza (a cikin tsarin kirtani), da tushen da za a canza shi zuwa (2 zuwa 16).\nAikin yana mayar da lambar da aka canza a cikin tsarin kirtani.\nLambar shigarwa na iya haɗawa da lambobi 0-9 da manyan haruffa A-F don tushe mafi girma fiye da 10.\nIdan lambar shigarwa ko tushen ba daidai ba ne, aikin yana mayar da 'INVALID INPUT'.\nMisalai:\nconvert_bases 10 \"255\" 2\nYana Mayar da: \"11111111\"\nconvert_bases 2 \"1010\" 16\nYana Mayar da: \"A\"\nconvert_bases 8 \"17\" 10\nYana Mayar da: \"15\"",
      "hi": "This function एक संख्या को एक आधार से दूसरे आधार में परिवर्तित करती है।\nयह फ़ंक्शन तीन तर्क स्वीकार करता है: इनपुट संख्या का आधार (2 से 16),\nपरिवर्तित की जाने वाली संख्या (स्ट्रिंग प्रारूप में), और वह आधार जिसमें इसे परिवर्तित किया जाना चाहिए (2 से 16)।\nयह फ़ंक्शन परिवर्तित संख्या को स्ट्रिंग प्रारूप में लौटाता है।\nइनपुट संख्या में 0-9 अंक और 10 से अधिक आधारों के लिए अपरकेस अक्षर A-F शामिल हो सकते हैं।\nयदि इनपुट संख्या या आधार अमान्य है, तो फ़ंक्शन 'INVALID INPUT' लौटाता है।\nउदाहरण:\nconvert_bases 10 \"255\" 2\nलौटाता है: \"11111111\"\nconvert_bases 2 \"1010\" 16\nलौटाता है: \"A\"\nconvert_bases 8 \"17\" 10\nलौटाता है: \"15\"",
      "hu": "Ez a függvény egy számot egyik számrendszerből a másikba konvertál.\nA függvény három argumentumot fogad el: a bemeneti szám alapját (2-től 16-ig),\na konvertálandó számot (string formátumban), és azt az alapot, amelyre konvertálni kell (2-től 16-ig).\nA függvény a konvertált számot string formátumban adja vissza.\nA bemeneti szám tartalmazhat 0-9 közötti számjegyeket és A-F nagybetűket 10-nél nagyobb alapok esetén.\nHa a bemeneti szám vagy az alap érvénytelen, a függvény 'INVALID INPUT'-ot ad vissza.\nPéldák:\nconvert_bases 10 \"255\" 2\nVisszaadja: \"11111111\"\nconvert_bases 2 \"1010\" 16\nVisszaadja: \"A\"\nconvert_bases 8 \"17\" 10\nVisszaadja: \"15\""
    },
    "docstring_bertscore": {
      "sq": "0.9961819268157474",
      "hy": "0.9938730472665979",
      "bn": "0.9770621635980911",
      "bg": "0.9850018171888176",
      "zh": "0.9727262610104805",
      "fr": "0.9910242903417955",
      "de": "0.9967343179054055",
      "ha": "0.9774788901375023",
      "hi": "0.9891933154894159",
      "hu": "0.9706044912802658"
    }
  },
  {
    "task_id": "Shell/36",
    "prompt": {
      "en": "find_sum_segments() {\nlocal M=$1\n# This function identifies all the continuous segments of positive integers that sum to a given integer M.\n# Each segment must contain at least two consecutive numbers.\n# Args:\n# $1: A positive integer M, the target sum (10 <= M <= 2,000,000).\n# Returns:\n# The output consists of several lines, each containing two positive integers separated by a space.\n# These integers represent the first and last numbers in a continuous segment that sums to M.\n# The lines are sorted in ascending order based on the starting number of each segment.\n# Example:\n# find_sum_segments 21\n# # Returns:\n# # 6 8\n# # 10 11",
      "sq": "find_sum_segments() {\nlocal M=$1\n# Kjo funksion identifikon të gjitha segmentet e vazhdueshme të numrave të plotë pozitivë që kanë shumën e barabartë me një numër të dhënë M.\n# Çdo segment duhet të përmbajë të paktën dy numra radhazi.\n# Argumentet:\n# $1: Një numër i plotë pozitiv M, shuma e synuar (10 <= M <= 2,000,000).\n# Kthen:\n# Rezultati përbëhet nga disa rreshta, secili që përmban dy numra të plotë pozitivë të ndarë nga një hapësirë.\n# Këta numra përfaqësojnë numrin e parë dhe të fundit në një segment të vazhdueshëm që ka shumën M.\n# Rreshtat janë të renditur në rritje bazuar në numrin fillestar të secilit segment.\n# Shembull:\n# find_sum_segments 21\n# # Kthen:\n# # 6 8\n# # 10 11",
      "hy": "find_sum_segments() {\nlocal M=$1\n# Այս ֆունկցիան հայտնաբերում է բոլոր այն շարունակական հատվածները, որոնք բաղկացած են դրական ամբողջ թվերից և որոնց գումարը հավասար է տրված M թվին։\n# Յուրաքանչյուր հատված պետք է պարունակի առնվազն երկու հաջորդական թվեր։\n# Պարամետրեր:\n# $1: Դրական ամբողջ թիվ M, նպատակային գումարը (10 <= M <= 2,000,000)։\n# Վերադարձնում է:\n# Արդյունքը բաղկացած է մի քանի տողերից, որոնցից յուրաքանչյուրում կան երկու դրական ամբողջ թվեր, որոնք բաժանված են բացատով։\n# Այս թվերը ներկայացնում են շարունակական հատվածի առաջին և վերջին թվերը, որոնց գումարը հավասար է M-ին։\n# Տողերը դասավորված են աճման կարգով՝ ըստ յուրաքանչյուր հատվածի սկզբնական թվի։\n# Օրինակ:\n# find_sum_segments 21\n# # Վերադարձնում է:\n# # 6 8\n# # 10 11",
      "bn": "find_sum_segments() {\nlocal M=$1\n# এই ফাংশনটি একটি নির্দিষ্ট পূর্ণসংখ্যা M এর সমান যোগফলযুক্ত সমস্ত ধারাবাহিক ধনাত্মক পূর্ণসংখ্যার অংশ চিহ্নিত করে।\n# প্রতিটি অংশে অন্তত দুটি ধারাবাহিক সংখ্যা থাকতে হবে।\n# আর্গস:\n# $1: একটি ধনাত্মক পূর্ণসংখ্যা M, লক্ষ্য যোগফল (10 <= M <= 2,000,000)।\n# রিটার্নস:\n# আউটপুটে একাধিক লাইন থাকবে, প্রতিটি লাইনে দুটি ধনাত্মক পূর্ণসংখ্যা একটি স্পেস দ্বারা পৃথক থাকবে।\n# এই পূর্ণসংখ্যাগুলি একটি ধারাবাহিক অংশের প্রথম এবং শেষ সংখ্যা যা M এর সমান যোগফল দেয়।\n# লাইনগুলি প্রতিটি অংশের শুরুর সংখ্যার উপর ভিত্তি করে ঊর্ধ্বক্রমে সাজানো থাকে।\n# উদাহরণ:\n# find_sum_segments 21\n# # রিটার্নস:\n# # 6 8\n# # 10 11",
      "bg": "find_sum_segments() {\nlocal M=$1\n# Тази функция идентифицира всички непрекъснати сегменти от положителни цели числа, които се сумират до дадено цяло число M.\n# Всеки сегмент трябва да съдържа поне две последователни числа.\n# Аргументи:\n# $1: Положително цяло число M, целевата сума (10 <= M <= 2,000,000).\n# Връща:\n# Изходът се състои от няколко реда, всеки съдържащ две положителни цели числа, разделени с интервал.\n# Тези числа представляват първото и последното число в непрекъснат сегмент, който се сумира до M.\n# Редовете са сортирани във възходящ ред въз основа на началното число на всеки сегмент.\n# Пример:\n# find_sum_segments 21\n# # Връща:\n# # 6 8\n# # 10 11",
      "zh": "find_sum_segments() {\nlocal M=$1\n# 此函数识别所有连续的正整数段，这些段的和等于给定的整数 M。\n# 每个段必须至少包含两个连续的数字。\n# 参数：\n# $1: 一个正整数 M，目标和 (10 <= M <= 2,000,000)。\n# 返回：\n# 输出由若干行组成，每行包含两个用空格分隔的正整数。\n# 这些整数表示连续段中和为 M 的第一个和最后一个数字。\n# 行按每个段的起始数字升序排序。\n# 示例：\n# find_sum_segments 21\n# # 返回：\n# # 6 8\n# # 10 11",
      "fr": "find_sum_segments() {\nlocal M=$1\n# Cette fonction identifie tous les segments continus d'entiers positifs qui somment à un entier donné M.\n# Chaque segment doit contenir au moins deux nombres consécutifs.\n# Arguments :\n# $1 : Un entier positif M, la somme cible (10 <= M <= 2,000,000).\n# Renvoie :\n# La sortie consiste en plusieurs lignes, chacune contenant deux entiers positifs séparés par un espace.\n# Ces entiers représentent les premiers et derniers nombres d'un segment continu qui somme à M.\n# Les lignes sont triées par ordre croissant en fonction du nombre de départ de chaque segment.\n# Exemple :\n# find_sum_segments 21\n# # Renvoie :\n# # 6 8\n# # 10 11",
      "de": "find_sum_segments() {\nlocal M=$1\n# Diese Funktion identifiziert alle kontinuierlichen Segmente positiver Ganzzahlen, die zu einer gegebenen Ganzzahl M summieren.\n# Jedes Segment muss mindestens zwei aufeinanderfolgende Zahlen enthalten.\n# Argumente:\n# $1: Eine positive Ganzzahl M, die Zielsumme (10 <= M <= 2,000,000).\n# Rückgabe:\n# Die Ausgabe besteht aus mehreren Zeilen, von denen jede zwei positive Ganzzahlen enthält, getrennt durch ein Leerzeichen.\n# Diese Ganzzahlen repräsentieren die erste und letzte Zahl in einem kontinuierlichen Segment, das zu M summiert.\n# Die Zeilen sind in aufsteigender Reihenfolge basierend auf der Startzahl jedes Segments sortiert.\n# Beispiel:\n# find_sum_segments 21\n# # Gibt zurück:\n# # 6 8\n# # 10 11",
      "ha": "find_sum_segments() {\nlocal M=$1\n# Wannan aikin yana gano dukkan jerin lambobi masu ci gaba na lambobi masu kyau waɗanda ke da jimillar wata lamba M.\n# Kowace jeri dole ne ta ƙunshi aƙalla lambobi biyu masu jere.\n# Args:\n# $1: Wata lamba mai kyau M, jimillar da ake nufi (10 <= M <= 2,000,000).\n# Returns:\n# Fitarwa tana ƙunshe da layuka da yawa, kowanne yana ɗauke da lambobi biyu masu kyau da aka raba da sarari.\n# Waɗannan lambobin suna wakiltar farkon da ƙarshen lambobi a cikin wata jeri mai ci gaba da ke da jimillar M.\n# Layukan suna jere a cikin tsari mai hawa bisa ga lambar farawa ta kowace jeri.\n# Misali:\n# find_sum_segments 21\n# # Yana dawo da:\n# # 6 8\n# # 10 11",
      "hi": "find_sum_segments() {\nlocal M=$1\n# यह फ़ंक्शन सभी निरंतर सकारात्मक पूर्णांकों के खंडों की पहचान करता है जिनका योग दिए गए पूर्णांक M के बराबर होता है।\n# प्रत्येक खंड में कम से कम दो लगातार संख्या होनी चाहिए।\n# तर्क:\n# $1: एक सकारात्मक पूर्णांक M, लक्षित योग (10 <= M <= 2,000,000)।\n# लौटाता है:\n# आउटपुट में कई पंक्तियाँ होती हैं, जिनमें से प्रत्येक में दो सकारात्मक पूर्णांक होते हैं जो एक स्पेस द्वारा अलग होते हैं।\n# ये पूर्णांक उस निरंतर खंड में पहले और अंतिम संख्या का प्रतिनिधित्व करते हैं जिसका योग M के बराबर होता है।\n# पंक्तियाँ प्रत्येक खंड की प्रारंभिक संख्या के आधार पर आरोही क्रम में क्रमबद्ध होती हैं।\n# उदाहरण:\n# find_sum_segments 21\n# # लौटाता है:\n# # 6 8\n# # 10 11",
      "hu": "find_sum_segments() {\nlocal M=$1\n# Ez a függvény azonosítja az összes olyan pozitív egész számokból álló folytonos szegmenst, amelyek összege egy adott M egész számot ad ki.\n# Minden szegmensnek legalább két egymást követő számot kell tartalmaznia.\n# Argumentumok:\n# $1: Egy pozitív egész szám M, a célösszeg (10 <= M <= 2,000,000).\n# Visszatérési érték:\n# A kimenet több sorból áll, mindegyik két pozitív egész számot tartalmaz, amelyeket egy szóköz választ el.\n# Ezek a számok egy folytonos szegmens első és utolsó számát jelölik, amelyek összege M.\n# A sorok növekvő sorrendben vannak rendezve az egyes szegmensek kezdőszáma alapján.\n# Példa:\n# find_sum_segments 21\n# # Visszaadja:\n# # 6 8\n# # 10 11"
    },
    "prompt_bertscore": {
      "sq": "0.9598389232585559",
      "hy": "0.9522075440191956",
      "bn": "0.9600294097939684",
      "bg": "0.9812425385973513",
      "zh": "0.9428516558116903",
      "fr": "0.9841949805810539",
      "de": "0.9858571196095539",
      "ha": "0.9424007648467411",
      "hi": "0.9655479576702607",
      "hu": "0.9663047394220037"
    },
    "canonical_solution": "local start=1\nlocal end=2\nlocal sum=$((start + end))\n\nwhile [[ start -lt end ]]; do\nif [[ sum -lt M ]]; then\nend=$((end + 1))\nsum=$((sum + end))\nelif [[ sum -gt M ]]; then\nsum=$((sum - start))\nstart=$((start + 1))\nelse\necho \"$start $end\"\nsum=$((sum - start))\nstart=$((start + 1))\nfi\ndone\n}",
    "instruction": {
      "en": "Write a Shell function `find_sum_segments() {\nlocal M=$1\n` to solve the following problem:\nThis function identifies all the continuous segments of positive integers that sum to a given integer M.\nEach segment must contain at least two consecutive numbers.\nArgs:\n$1: A positive integer M, the target sum (10 <= M <= 2,000,000).\nReturns:\nThe output consists of several lines, each containing two positive integers separated by a space.\nThese integers represent the first and last numbers in a continuous segment that sums to M.\nThe lines are sorted in ascending order based on the starting number of each segment.\nExample:\nfind_sum_segments 21\nReturns:\n6 8\n10 11",
      "sq": "Shkruani një funksion Shell `find_sum_segments() {\nlocal M=$1\n` për të zgjidhur problemin e mëposhtëm:\nKy funksion identifikon të gjitha segmentet e vazhdueshme të numrave të plotë pozitivë që kanë shumën e barabartë me një numër të dhënë M.\nÇdo segment duhet të përmbajë të paktën dy numra radhazi.\nArgumentet:\n$1: Një numër i plotë pozitiv M, shuma e synuar (10 <= M <= 2,000,000).\nKthen:\nDalja përbëhet nga disa rreshta, secili që përmban dy numra të plotë pozitivë të ndarë nga një hapësirë.\nKëta numra përfaqësojnë numrin e parë dhe të fundit në një segment të vazhdueshëm që ka shumën e barabartë me M.\nRreshtat janë të renditur në rend rritës bazuar në numrin fillestar të çdo segmenti.\nShembull:\nfind_sum_segments 21\nKthen:\n6 8\n10 11",
      "hy": "Գրեք Shell ֆունկցիա `find_sum_segments() {\nlocal M=$1\n` հետևյալ խնդիրը լուծելու համար:\nԱյս ֆունկցիան հայտնաբերում է բոլոր դրական ամբողջ թվերի շարունակական հատվածները, որոնք գումարվում են տրված M ամբողջ թվին:\nՅուրաքանչյուր հատված պետք է պարունակի առնվազն երկու հաջորդական թվեր:\nԱրգումենտներ:\n$1: Դրական ամբողջ թիվ M, նպատակային գումարը (10 <= M <= 2,000,000):\nՎերադարձնում է:\nԵլքը բաղկացած է մի քանի տողից, որոնցից յուրաքանչյուրում կա երկու դրական ամբողջ թիվ, որոնք բաժանված են բացատով:\nԱյս թվերը ներկայացնում են շարունակական հատվածի առաջին և վերջին թվերը, որոնք գումարվում են M-ին:\nՏողերը դասավորված են աճման կարգով՝ ըստ յուրաքանչյուր հատվածի մեկնարկային թվի:\nՕրինակ:\nfind_sum_segments 21\nՎերադարձնում է:\n6 8\n10 11",
      "bn": "একটি Shell ফাংশন লিখুন `find_sum_segments() {\nlocal M=$1\n` নিম্নলিখিত সমস্যার সমাধানের জন্য:\nএই ফাংশনটি একটি প্রদত্ত পূর্ণসংখ্যা M এর সমান যোগফলযুক্ত সব ধনাত্মক পূর্ণসংখ্যার ধারাবাহিক অংশগুলি সনাক্ত করে।\nপ্রতিটি অংশে কমপক্ষে দুটি পরপর সংখ্যা থাকতে হবে।\nআর্গুমেন্ট:\n$1: একটি ধনাত্মক পূর্ণসংখ্যা M, লক্ষ্য যোগফল (10 <= M <= 2,000,000)।\nফেরত দেয়:\nআউটপুটে একাধিক লাইন থাকে, প্রতিটি লাইনে দুটি ধনাত্মক পূর্ণসংখ্যা একটি স্পেস দ্বারা পৃথক থাকে।\nএই পূর্ণসংখ্যাগুলি একটি ধারাবাহিক অংশের প্রথম এবং শেষ সংখ্যা উপস্থাপন করে যা M এর সমান যোগফল দেয়।\nলাইনগুলি প্রতিটি অংশের শুরু সংখ্যার উপর ভিত্তি করে ঊর্ধ্বক্রমে সাজানো থাকে।\nউদাহরণ:\nfind_sum_segments 21\nফেরত দেয়:\n6 8\n10 11",
      "bg": "Напишете Shell функция `find_sum_segments() {\nlocal M=$1\n` за решаване на следния проблем:\nТази функция идентифицира всички непрекъснати сегменти от положителни цели числа, които се сумират до дадено цяло число M.\nВсеки сегмент трябва да съдържа поне две последователни числа.\nАргументи:\n$1: Положително цяло число M, целевата сума (10 <= M <= 2,000,000).\nВръща:\nИзходът се състои от няколко реда, всеки от които съдържа две положителни цели числа, разделени с интервал.\nТези числа представляват първото и последното число в непрекъснат сегмент, който се сумира до M.\nРедовете са сортирани във възходящ ред въз основа на началното число на всеки сегмент.\nПример:\nfind_sum_segments 21\nВръща:\n6 8\n10 11",
      "zh": "编写一个 Shell 函数 `find_sum_segments() {\nlocal M=$1\n` 来解决以下问题：\n此函数识别所有连续的正整数段，这些段的和为给定的整数 M。\n每个段必须包含至少两个连续的数字。\n参数：\n$1: 一个正整数 M，目标和 (10 <= M <= 2,000,000)。\n返回：\n输出由若干行组成，每行包含两个由空格分隔的正整数。\n这些整数表示和为 M 的连续段的第一个和最后一个数字。\n这些行按每个段的起始数字升序排序。\n示例：\nfind_sum_segments 21\n返回：\n6 8\n10 11",
      "fr": "Écrire une fonction Shell `find_sum_segments() {\nlocal M=$1\n` pour résoudre le problème suivant :\nCette fonction identifie tous les segments continus d'entiers positifs dont la somme est égale à un entier donné M.\nChaque segment doit contenir au moins deux nombres consécutifs.\nArgs:\n$1: Un entier positif M, la somme cible (10 <= M <= 2,000,000).\nRenvoie :\nLa sortie consiste en plusieurs lignes, chacune contenant deux entiers positifs séparés par un espace.\nCes entiers représentent les premiers et derniers nombres dans un segment continu dont la somme est égale à M.\nLes lignes sont triées par ordre croissant en fonction du nombre de départ de chaque segment.\nExemple :\nfind_sum_segments 21\nRenvoie :\n6 8\n10 11",
      "de": "Schreiben Sie eine Shell-Funktion `find_sum_segments() {\nlocal M=$1\n` um das folgende Problem zu lösen:\nDiese Funktion identifiziert alle kontinuierlichen Segmente von positiven ganzen Zahlen, die zu einer gegebenen Zahl M summieren.\nJedes Segment muss mindestens zwei aufeinanderfolgende Zahlen enthalten.\nArgumente:\n$1: Eine positive ganze Zahl M, die Zielsumme (10 <= M <= 2,000,000).\nRückgabe:\nDie Ausgabe besteht aus mehreren Zeilen, die jeweils zwei positive ganze Zahlen enthalten, getrennt durch ein Leerzeichen.\nDiese Zahlen repräsentieren die erste und letzte Zahl in einem kontinuierlichen Segment, das zu M summiert.\nDie Zeilen sind in aufsteigender Reihenfolge basierend auf der Startnummer jedes Segments sortiert.\nBeispiel:\nfind_sum_segments 21\nRückgabe:\n6 8\n10 11",
      "ha": "Rubuta aikin Shell `find_sum_segments() {\nlocal M=$1\n` don warware matsalar mai zuwa:\nWannan aikin yana gano dukkan sassan lambobi masu kyau da ke ci gaba da jimlar su zuwa wani lamba M da aka bayar.\nKowane sashe dole ne ya ƙunshi aƙalla lambobi biyu masu jere.\nArgs:\n$1: Lamba mai kyau M, jimlar da ake nufi (10 <= M <= 2,000,000).\nKomawa:\nFitarwa ya ƙunshi layuka da yawa, kowanne yana ɗauke da lambobi biyu masu kyau da aka raba ta sarari.\nWadannan lambobi suna wakiltar lambobi na farko da na ƙarshe a cikin wani sashe mai ci gaba wanda jimlarsa ta kai M.\nLayukan suna cikin tsari mai tashi bisa ga lambar farawa na kowane sashe.\nMisali:\nfind_sum_segments 21\nKomawa:\n6 8\n10 11",
      "hi": "Shell फ़ंक्शन `find_sum_segments() {\nlocal M=$1\n` निम्नलिखित समस्या को हल करने के लिए लिखें:\nयह फ़ंक्शन उन सभी सतत खंडों की पहचान करता है जिनमें सकारात्मक पूर्णांक होते हैं जो दिए गए पूर्णांक M के बराबर होते हैं।\nप्रत्येक खंड में कम से कम दो लगातार संख्या होनी चाहिए।\nआर्ग्स:\n$1: एक सकारात्मक पूर्णांक M, लक्ष्य योग (10 <= M <= 2,000,000)।\nरिटर्न्स:\nआउटपुट में कई पंक्तियाँ होती हैं, जिनमें से प्रत्येक में दो सकारात्मक पूर्णांक होते हैं जो एक स्पेस से अलग होते हैं।\nये पूर्णांक उस सतत खंड की पहली और अंतिम संख्या का प्रतिनिधित्व करते हैं जो M के बराबर होता है।\nपंक्तियाँ प्रत्येक खंड की प्रारंभिक संख्या के आधार पर आरोही क्रम में व्यवस्थित होती हैं।\nउदाहरण:\nfind_sum_segments 21\nरिटर्न्स:\n6 8\n10 11",
      "hu": "Írj egy Shell függvényt `find_sum_segments() {\nlocal M=$1\n` a következő probléma megoldására:\nEz a függvény azonosítja az összes olyan pozitív egész számokból álló folytonos szegmenst, amelyek összege egy adott M egész szám.\nMinden szegmensnek legalább két egymást követő számot kell tartalmaznia.\nArgumentumok:\n$1: Egy pozitív egész szám M, a célösszeg (10 <= M <= 2,000,000).\nVisszatérési érték:\nA kimenet több sorból áll, mindegyik két pozitív egész számot tartalmaz, amelyeket egy szóköz választ el.\nEzek a számok egy folytonos szegmens első és utolsó számát képviselik, amelyek összege M.\nA sorok növekvő sorrendben vannak rendezve az egyes szegmensek kezdőszáma alapján.\nPélda:\nfind_sum_segments 21\nVisszatér:\n6 8\n10 11"
    },
    "instruction_bertscore": {
      "sq": "0.9636907636075845",
      "hy": "0.9692982978945804",
      "bn": "0.964558778372707",
      "bg": "0.981877957186282",
      "zh": "0.9453619465672092",
      "fr": "0.9774622051854954",
      "de": "0.9785073982505009",
      "ha": "0.9490447524619771",
      "hi": "0.9446824320336888",
      "hu": "0.965481813753376"
    },
    "level": "easy",
    "test": "test_find_sum_segments() {\nlocal result=$(find_sum_segments 10000)\nlocal expected=\"18 142\n297 328\n388 412\n1998 2002\"\n[[ $result == \"$expected\" ]] || { echo \"Test 1 failed\"; exit 1; }\n\nresult=$(find_sum_segments 100)\nexpected=\"9 16\n18 22\"\n[[ $result == \"$expected\" ]] || { echo \"Test 2 failed\"; exit 1; }\n}\n\ntest_find_sum_segments",
    "entry_point": "find_sum_segments",
    "signature": "find_sum_segments() {\nlocal M=$1\n",
    "docstring": {
      "en": "This function identifies all the continuous segments of positive integers that sum to a given integer M.\nEach segment must contain at least two consecutive numbers.\nArgs:\n$1: A positive integer M, the target sum (10 <= M <= 2,000,000).\nReturns:\nThe output consists of several lines, each containing two positive integers separated by a space.\nThese integers represent the first and last numbers in a continuous segment that sums to M.\nThe lines are sorted in ascending order based on the starting number of each segment.\nExample:\nfind_sum_segments 21\nReturns:\n6 8\n10 11",
      "sq": "Kjo funksion identifikon të gjitha segmentet e vazhdueshme të numrave të plotë pozitivë që kanë shumën e barabartë me një numër të caktuar M. \nÇdo segment duhet të përmbajë të paktën dy numra radhazi.\nArgs:\n$1: Një numër i plotë pozitiv M, shuma e synuar (10 <= M <= 2,000,000).\nReturns:\nDalja përbëhet nga disa rreshta, secili që përmban dy numra të plotë pozitivë të ndarë nga një hapësirë. \nKëta numra përfaqësojnë numrin e parë dhe të fundit në një segment të vazhdueshëm që ka shumën M. \nRreshtat janë të renditura në rend rritës bazuar në numrin fillestar të çdo segmenti.\nExample:\nfind_sum_segments 21\nReturns:\n6 8\n10 11",
      "hy": "Այս ֆունկցիան հայտնաբերում է բոլոր շարունակական հատվածները դրական ամբողջ թվերի, որոնք գումարվում են տրված M ամբողջ թվին։  \nՅուրաքանչյուր հատված պետք է պարունակի առնվազն երկու հաջորդական թվեր։  \nԱրձագանքներ:  \n$1: Դրական ամբողջ թիվ M, թիրախային գումարը (10 <= M <= 2,000,000):  \nՎերադարձնում է:  \nԵլքը բաղկացած է մի քանի տողերից, որոնցից յուրաքանչյուրը պարունակում է երկու դրական ամբողջ թիվ, որոնք բաժանված են բացատով։  \nԱյս ամբողջ թվերը ներկայացնում են շարունակական հատվածի առաջին և վերջին թվերը, որոնք գումարվում են M-ին։  \nՏողերը դասավորված են աճման կարգով՝ ըստ յուրաքանչյուր հատվածի մեկնարկային թվի։  \nՕրինակ:  \nfind_sum_segments 21  \nՎերադարձնում է:  \n6 8  \n10 11  ",
      "bn": "This function identifies all the continuous segments of positive integers that sum to a given integer M.  \nএই ফাংশনটি সমস্ত ধারাবাহিক ধনাত্মক পূর্ণসংখ্যার সেগমেন্ট সনাক্ত করে যা একটি প্রদত্ত পূর্ণসংখ্যা M এর সমান হয়।  \nEach segment must contain at least two consecutive numbers.  \nপ্রতিটি সেগমেন্টে কমপক্ষে দুটি ধারাবাহিক সংখ্যা থাকতে হবে।  \nArgs:  \nআর্গস:  \n$1: A positive integer M, the target sum (10 <= M <= 2,000,000).  \n$1: একটি ধনাত্মক পূর্ণসংখ্যা M, লক্ষ্য যোগফল (10 <= M <= 2,000,000)।  \nReturns:  \nরিটার্নস:  \nThe output consists of several lines, each containing two positive integers separated by a space.  \nআউটপুটে কয়েকটি লাইন থাকে, প্রতিটি লাইনে দুটি ধনাত্মক পূর্ণসংখ্যা থাকে যা একটি স্পেস দ্বারা পৃথক করা হয়।  \nThese integers represent the first and last numbers in a continuous segment that sums to M.  \nএই পূর্ণসংখ্যাগুলি একটি ধারাবাহিক সেগমেন্টের প্রথম এবং শেষ সংখ্যাগুলি উপস্থাপন করে যা M এর সমান যোগফল হয়।  \nThe lines are sorted in ascending order based on the starting number of each segment.  \nলাইনগুলি প্রতিটি সেগমেন্টের শুরুর সংখ্যার উপর ভিত্তি করে ঊর্ধ্বক্রমে সাজানো হয়।  \nExample:  \nউদাহরণ:  \nfind_sum_segments 21  \nReturns:  \nরিটার্নস:  \n6 8  \n10 11  ",
      "bg": "This function идентифицира всички непрекъснати сегменти от положителни цели числа, които се сумират до дадено цяло число M.\nВсеки сегмент трябва да съдържа поне две последователни числа.\nArgs:\n$1: Положително цяло число M, целевата сума (10 <= M <= 2,000,000).\nReturns:\nИзходът се състои от няколко реда, всеки от които съдържа две положителни цели числа, разделени с интервал.\nТези числа представляват първото и последното число в непрекъснат сегмент, който се сумира до M.\nРедовете са сортирани във възходящ ред въз основа на началното число на всеки сегмент.\nExample:\nfind_sum_segments 21\nReturns:\n6 8\n10 11",
      "zh": "This function identifies all the continuous segments of positive integers that sum to a given integer M.  \n该函数识别所有连续的正整数段，这些段的和为给定的整数 M。  \nEach segment must contain at least two consecutive numbers.  \n每个段必须包含至少两个连续的数字。  \nArgs:  \n参数:  \n$1: A positive integer M, the target sum (10 <= M <= 2,000,000).  \n$1: 一个正整数 M，目标和 (10 <= M <= 2,000,000)。  \nReturns:  \n返回:  \nThe output consists of several lines, each containing two positive integers separated by a space.  \n输出由若干行组成，每行包含两个由空格分隔的正整数。  \nThese integers represent the first and last numbers in a continuous segment that sums to M.  \n这些整数表示和为 M 的连续段中的第一个和最后一个数字。  \nThe lines are sorted in ascending order based on the starting number of each segment.  \n这些行根据每个段的起始数字按升序排序。  \nExample:  \n示例:  \nfind_sum_segments 21  \nReturns:  \n返回:  \n6 8  \n10 11  ",
      "fr": "Cette fonction identifie tous les segments continus d'entiers positifs dont la somme est égale à un entier donné M.  \nChaque segment doit contenir au moins deux nombres consécutifs.  \nArgs:  \n$1: Un entier positif M, la somme cible (10 <= M <= 2,000,000).  \nReturns:  \nLa sortie consiste en plusieurs lignes, chacune contenant deux entiers positifs séparés par un espace.  \nCes entiers représentent les premiers et derniers nombres d'un segment continu dont la somme est égale à M.  \nLes lignes sont triées par ordre croissant en fonction du nombre de départ de chaque segment.  \nExample:  \nfind_sum_segments 21  \nReturns:  \n6 8  \n10 11  ",
      "de": "Diese Funktion identifiziert alle kontinuierlichen Segmente von positiven ganzen Zahlen, die zu einer gegebenen ganzen Zahl M summieren. Jedes Segment muss mindestens zwei aufeinanderfolgende Zahlen enthalten.  \nArgs:  \n$1: Eine positive ganze Zahl M, die Zielsumme (10 <= M <= 2,000,000).  \nReturns:  \nDie Ausgabe besteht aus mehreren Zeilen, von denen jede zwei positive ganze Zahlen enthält, die durch ein Leerzeichen getrennt sind. Diese Zahlen repräsentieren die erste und die letzte Zahl in einem kontinuierlichen Segment, das zu M summiert. Die Zeilen sind in aufsteigender Reihenfolge basierend auf der Startnummer jedes Segments sortiert.  \nBeispiel:  \nfind_sum_segments 21  \nReturns:  \n6 8  \n10 11  ",
      "ha": "Wannan aikin yana gano dukkan sassan lambobi masu kyau da ke ci gaba waɗanda ke haɗuwa zuwa wani lamba M da aka bayar.\nKowane yanki dole ne ya ƙunshi aƙalla lambobi biyu masu jere.\nArgs:\n$1: Wata lamba mai kyau M, adadin da ake nufi (10 <= M <= 2,000,000).\nReturns:\nFitarwa yana ƙunshe da layuka da yawa, kowanne yana ɗauke da lambobi biyu masu kyau da aka raba da sarari.\nWadannan lambobi suna wakiltar lamba ta farko da ta ƙarshe a cikin wani yanki mai ci gaba wanda ke haɗuwa zuwa M.\nAn tsara layukan a cikin tsari mai tashi bisa ga lambar farawa na kowane yanki.\nExample:\nfind_sum_segments 21\nReturns:\n6 8\n10 11",
      "hi": "This function उन सभी सतत खंडों की पहचान करता है जो दिए गए पूर्णांक M के बराबर होते हैं।\nप्रत्येक खंड में कम से कम दो लगातार संख्याएँ होनी चाहिए।\nतर्क:\n$1: एक धनात्मक पूर्णांक M, लक्ष्य योग (10 <= M <= 2,000,000)।\nवापसी:\nआउटपुट में कई पंक्तियाँ होती हैं, प्रत्येक में दो धनात्मक पूर्णांक होते हैं जो एक स्पेस द्वारा अलग होते हैं।\nये पूर्णांक एक सतत खंड में पहले और अंतिम संख्याओं का प्रतिनिधित्व करते हैं जो M के बराबर होते हैं।\nपंक्तियाँ प्रत्येक खंड की प्रारंभिक संख्या के आधार पर आरोही क्रम में क्रमबद्ध होती हैं।\nउदाहरण:\nfind_sum_segments 21\nवापसी:\n6 8\n10 11",
      "hu": "Ez a függvény az összes olyan folyamatos pozitív egész szám szegmenst azonosítja, amelyek összege egy adott M egész számot ad ki.\nMinden szegmensnek legalább két egymást követő számot kell tartalmaznia.\nArgs:\n$1: Egy pozitív egész szám M, a célösszeg (10 <= M <= 2,000,000).\nReturns:\nA kimenet több sorból áll, mindegyik két pozitív egész számot tartalmaz, amelyeket egy szóköz választ el.\nEzek a számok egy folyamatos szegmens első és utolsó számát jelölik, amely összege M.\nA sorok növekvő sorrendben vannak rendezve az egyes szegmensek kezdő száma alapján.\nExample:\nfind_sum_segments 21\nReturns:\n6 8\n10 11"
    },
    "docstring_bertscore": {
      "sq": "0.963864167930228",
      "hy": "0.9662568695001742",
      "bn": "1",
      "bg": "0.9862750379312513",
      "zh": "1",
      "fr": "0.972831137851667",
      "de": "0.9898060902149085",
      "ha": "0.9572100501655593",
      "hi": "0.9541555121660047",
      "hu": "0.9666964385334045"
    }
  },
  {
    "task_id": "Shell/37",
    "prompt": {
      "en": "count_meal_combinations() {\nlocal n=$1\nlocal m=$2\nlocal dish_prices=($3)\n# This function calculates the number of ways to spend all available money on a selection of dishes in a restaurant. Each dish can only be purchased once. The function takes the number of dishes available, the total amount of money, and a string containing the price of each dish.\n\n# Example Cases:\n\n# count_meal_combinations 3 5 \"1 2 3\" should return 2 (1+2+2 or 3+2).\n# count_meal_combinations 4 6 \"1 2 3 1\" should return 3 (1+2+3, 1+1+2+2, or 2+3+1).",
      "sq": "count_meal_combinations() {\nlocal n=$1\nlocal m=$2\nlocal dish_prices=($3)\n# Kjo funksion llogarit numrin e mënyrave për të shpenzuar të gjithë paratë e disponueshme në një përzgjedhje të pjatave në një restorant. Çdo pjatë mund të blihet vetëm një herë. Funksioni merr numrin e pjatave të disponueshme, shumën totale të parave dhe një varg që përmban çmimin e secilës pjatë.\n\n# Shembuj Rastesh:\n\n# count_meal_combinations 3 5 \"1 2 3\" duhet të kthejë 2 (1+2+2 ose 3+2).\n# count_meal_combinations 4 6 \"1 2 3 1\" duhet të kthejë 3 (1+2+3, 1+1+2+2, ose 2+3+1).",
      "hy": "count_meal_combinations() {\nlocal n=$1\nlocal m=$2\nlocal dish_prices=($3)\n# Այս ֆունկցիան հաշվարկում է, թե քանի եղանակով կարելի է ծախսել առկա բոլոր գումարը ռեստորանում ուտեստների ընտրության վրա: Յուրաքանչյուր ուտեստ կարելի է գնել միայն մեկ անգամ: Ֆունկցիան ընդունում է առկա ուտեստների քանակը, գումարի ընդհանուր չափը և տող, որը պարունակում է յուրաքանչյուր ուտեստի գինը:\n\n# Օրինակային դեպքեր:\n\n# count_meal_combinations 3 5 \"1 2 3\" պետք է վերադարձնի 2 (1+2+2 կամ 3+2):\n# count_meal_combinations 4 6 \"1 2 3 1\" պետք է վերադարձնի 3 (1+2+3, 1+1+2+2, կամ 2+3+1):",
      "bn": "count_meal_combinations() {\nlocal n=$1\nlocal m=$2\nlocal dish_prices=($3)\n# এই ফাংশনটি রেস্টুরেন্টে খাবারের একটি নির্বাচন নিয়ে সমস্ত উপলব্ধ অর্থ ব্যয় করার উপায়গুলির সংখ্যা গণনা করে। প্রতিটি খাবার শুধুমাত্র একবার কেনা যেতে পারে। ফাংশনটি উপলব্ধ খাবারের সংখ্যা, মোট অর্থের পরিমাণ এবং প্রতিটি খাবারের মূল্যের একটি স্ট্রিং নেয়।\n\n# উদাহরণ কেসসমূহ:\n\n# count_meal_combinations 3 5 \"1 2 3\" 2 ফেরত দেবে (1+2+2 বা 3+2)।\n# count_meal_combinations 4 6 \"1 2 3 1\" 3 ফেরত দেবে (1+2+3, 1+1+2+2, বা 2+3+1)।",
      "bg": "count_meal_combinations() {\nlocal n=$1\nlocal m=$2\nlocal dish_prices=($3)\n# Тази функция изчислява броя на начините да се изхарчат всички налични пари за избор на ястия в ресторант. Всяко ястие може да бъде закупено само веднъж. Функцията приема броя на наличните ястия, общата сума пари и низ, съдържащ цената на всяко ястие.\n\n# Примерни случаи:\n\n# count_meal_combinations 3 5 \"1 2 3\" трябва да върне 2 (1+2+2 или 3+2).\n# count_meal_combinations 4 6 \"1 2 3 1\" трябва да върне 3 (1+2+3, 1+1+2+2, или 2+3+1).",
      "zh": "count_meal_combinations() {\nlocal n=$1\nlocal m=$2\nlocal dish_prices=($3)\n# 此函数计算在餐厅中选择菜肴以花费所有可用资金的方法数量。每道菜只能购买一次。函数接收可用菜肴的数量、总金额和包含每道菜价格的字符串。\n\n# 示例案例:\n\n# count_meal_combinations 3 5 \"1 2 3\" 应返回 2 (1+2+2 或 3+2)。\n# count_meal_combinations 4 6 \"1 2 3 1\" 应返回 3 (1+2+3, 1+1+2+2, 或 2+3+1)。",
      "fr": "count_meal_combinations() {\nlocal n=$1\nlocal m=$2\nlocal dish_prices=($3)\n# Cette fonction calcule le nombre de façons de dépenser tout l'argent disponible sur une sélection de plats dans un restaurant. Chaque plat ne peut être acheté qu'une seule fois. La fonction prend le nombre de plats disponibles, le montant total d'argent, et une chaîne contenant le prix de chaque plat.\n\n# Cas d'exemples :\n\n# count_meal_combinations 3 5 \"1 2 3\" devrait retourner 2 (1+2+2 ou 3+2).\n# count_meal_combinations 4 6 \"1 2 3 1\" devrait retourner 3 (1+2+3, 1+1+2+2, ou 2+3+1).",
      "de": "count_meal_combinations() {\nlocal n=$1\nlocal m=$2\nlocal dish_prices=($3)\n# Diese Funktion berechnet die Anzahl der Möglichkeiten, das gesamte verfügbare Geld für eine Auswahl an Gerichten in einem Restaurant auszugeben. Jedes Gericht kann nur einmal gekauft werden. Die Funktion nimmt die Anzahl der verfügbaren Gerichte, den Gesamtbetrag des Geldes und eine Zeichenkette, die den Preis jedes Gerichts enthält.\n\n# Beispiel Fälle:\n\n# count_meal_combinations 3 5 \"1 2 3\" sollte 2 zurückgeben (1+2+2 oder 3+2).\n# count_meal_combinations 4 6 \"1 2 3 1\" sollte 3 zurückgeben (1+2+3, 1+1+2+2, oder 2+3+1).",
      "ha": "count_meal_combinations() {\nlocal n=$1\nlocal m=$2\nlocal dish_prices=($3)\n# Wannan aikin yana ƙididdige yawan hanyoyin da za a kashe duk kuɗin da ake da su akan zaɓin abinci a gidan abinci. Za a iya siyan kowanne abinci sau ɗaya kawai. Aikin yana ɗaukar yawan abincin da ake da su, jimillar kuɗin, da kuma jeri mai ɗauke da farashin kowanne abinci.\n\n# Misalan Lokuta:\n\n# count_meal_combinations 3 5 \"1 2 3\" ya kamata ya dawo 2 (1+2+2 ko 3+2).\n# count_meal_combinations 4 6 \"1 2 3 1\" ya kamata ya dawo 3 (1+2+3, 1+1+2+2, ko 2+3+1).",
      "hi": "count_meal_combinations() {\nlocal n=$1\nlocal m=$2\nlocal dish_prices=($3)\n# यह फ़ंक्शन रेस्तरां में व्यंजनों के चयन पर उपलब्ध सभी पैसे खर्च करने के तरीकों की संख्या की गणना करता है। प्रत्येक व्यंजन को केवल एक बार खरीदा जा सकता है। फ़ंक्शन उपलब्ध व्यंजनों की संख्या, कुल पैसे की मात्रा, और प्रत्येक व्यंजन की कीमत वाली एक स्ट्रिंग लेता है।\n\n# उदाहरण मामले:\n\n# count_meal_combinations 3 5 \"1 2 3\" को 2 लौटाना चाहिए (1+2+2 या 3+2)।\n# count_meal_combinations 4 6 \"1 2 3 1\" को 3 लौटाना चाहिए (1+2+3, 1+1+2+2, या 2+3+1)।",
      "hu": "count_meal_combinations() {\nlocal n=$1\nlocal m=$2\nlocal dish_prices=($3)\n# Ez a függvény kiszámítja, hányféleképpen lehet az összes rendelkezésre álló pénzt elkölteni egy étteremben kapható ételek kiválasztására. Minden ételt csak egyszer lehet megvásárolni. A függvény az elérhető ételek számát, a teljes pénzösszeget és az egyes ételek árát tartalmazó karakterláncot veszi át.\n\n# Példa esetek:\n\n# count_meal_combinations 3 5 \"1 2 3\" vissza kell adnia 2-t (1+2+2 vagy 3+2).\n# count_meal_combinations 4 6 \"1 2 3 1\" vissza kell adnia 3-at (1+2+3, 1+1+2+2, vagy 2+3+1)."
    },
    "prompt_bertscore": {
      "sq": "0.9913035646575306",
      "hy": "0.9910264752759869",
      "bn": "0.9742046669365232",
      "bg": "0.9897276312143998",
      "zh": "0.9694762707159877",
      "fr": "0.9954539464692546",
      "de": "0.9916263390267123",
      "ha": "0.9631675711839386",
      "hi": "0.9885286982344731",
      "hu": "0.9905519472956945"
    },
    "canonical_solution": "local dp=()\ndp[0]=1\n\nfor price in ${dish_prices[@]}; do\nfor (( i=m; i>=price; i-- )); do\n(( dp[i]+=${dp[i-price]:-0} ))\ndone\ndone\n\necho ${dp[m]:-0}\n}",
    "instruction": {
      "en": "Write a Shell function `count_meal_combinations() {\nlocal n=$1\nlocal m=$2\nlocal dish_prices=($3)\n` to solve the following problem:\nThis function calculates the number of ways to spend all available money on a selection of dishes in a restaurant. Each dish can only be purchased once. The function takes the number of dishes available, the total amount of money, and a string containing the price of each dish.\n\nExample Cases:\n\ncount_meal_combinations 3 5 \"1 2 3\" should return 2 (1+2+2 or 3+2).\ncount_meal_combinations 4 6 \"1 2 3 1\" should return 3 (1+2+3, 1+1+2+2, or 2+3+1).",
      "sq": "Shkruani një funksion Shell `count_meal_combinations() {\nlocal n=$1\nlocal m=$2\nlocal dish_prices=($3)\n` për të zgjidhur problemin e mëposhtëm:\nKy funksion llogarit numrin e mënyrave për të shpenzuar të gjitha paratë e disponueshme në një përzgjedhje të pjatave në një restorant. Çdo pjatë mund të blihet vetëm një herë. Funksioni merr numrin e pjatave të disponueshme, shumën totale të parave dhe një varg që përmban çmimin e secilës pjatë.\n\nRastet e Shembullit:\n\ncount_meal_combinations 3 5 \"1 2 3\" duhet të kthejë 2 (1+2+2 ose 3+2).\ncount_meal_combinations 4 6 \"1 2 3 1\" duhet të kthejë 3 (1+2+3, 1+1+2+2, ose 2+3+1).",
      "hy": "Գրեք Shell ֆունկցիա `count_meal_combinations() {\nlocal n=$1\nlocal m=$2\nlocal dish_prices=($3)\n` հետևյալ խնդիրը լուծելու համար:\nԱյս ֆունկցիան հաշվում է, թե քանի եղանակով կարելի է ծախսել ամբողջ հասանելի գումարը ռեստորանում ուտեստների ընտրության վրա: Յուրաքանչյուր ուտեստ կարելի է գնել միայն մեկ անգամ: Ֆունկցիան ընդունում է հասանելի ուտեստների քանակը, գումարի ընդհանուր չափը և յուրաքանչյուր ուտեստի գինը պարունակող տող:\n\nՕրինակներ:\n\ncount_meal_combinations 3 5 \"1 2 3\" պետք է վերադարձնի 2 (1+2+2 կամ 3+2):\ncount_meal_combinations 4 6 \"1 2 3 1\" պետք է վերադարձնի 3 (1+2+3, 1+1+2+2, կամ 2+3+1):",
      "bn": "একটি Shell ফাংশন লিখুন `count_meal_combinations() {\nlocal n=$1\nlocal m=$2\nlocal dish_prices=($3)\n` নিম্নলিখিত সমস্যার সমাধানের জন্য:\nএই ফাংশনটি রেস্তোরাঁয় বিভিন্ন খাবারের পছন্দের উপর সমস্ত উপলব্ধ টাকা খরচ করার উপায়গুলির সংখ্যা গণনা করে। প্রতিটি খাবার শুধুমাত্র একবার কেনা যেতে পারে। ফাংশনটি উপলব্ধ খাবারের সংখ্যা, মোট টাকার পরিমাণ এবং প্রতিটি খাবারের মূল্য ধারণকারী একটি স্ট্রিং নেয়।\n\nউদাহরণ কেসসমূহ:\n\ncount_meal_combinations 3 5 \"1 2 3\" 2 ফেরত দেবে (1+2+2 অথবা 3+2)।\ncount_meal_combinations 4 6 \"1 2 3 1\" 3 ফেরত দেবে (1+2+3, 1+1+2+2, অথবা 2+3+1)।",
      "bg": "Напишете Shell функция `count_meal_combinations() {\nlocal n=$1\nlocal m=$2\nlocal dish_prices=($3)\n` за решаване на следния проблем:\nТази функция изчислява броя на начините за изразходване на всички налични пари за избор на ястия в ресторант. Всяко ястие може да бъде закупено само веднъж. Функцията приема броя на наличните ястия, общата сума пари и низ, съдържащ цената на всяко ястие.\n\nПримерни случаи:\n\ncount_meal_combinations 3 5 \"1 2 3\" трябва да върне 2 (1+2+2 или 3+2).\ncount_meal_combinations 4 6 \"1 2 3 1\" трябва да върне 3 (1+2+3, 1+1+2+2, или 2+3+1).",
      "zh": "编写一个 Shell 函数 `count_meal_combinations() {\nlocal n=$1\nlocal m=$2\nlocal dish_prices=($3)\n` 来解决以下问题：\n此函数计算在餐厅中花费所有可用资金选择菜肴的方式数量。每道菜只能购买一次。函数接收可用菜肴的数量、总金额和包含每道菜价格的字符串。\n\n示例案例：\n\ncount_meal_combinations 3 5 \"1 2 3\" 应返回 2 (1+2+2 或 3+2)。\ncount_meal_combinations 4 6 \"1 2 3 1\" 应返回 3 (1+2+3, 1+1+2+2, 或 2+3+1)。",
      "fr": "Écrire une fonction Shell `count_meal_combinations() {\nlocal n=$1\nlocal m=$2\nlocal dish_prices=($3)\n` pour résoudre le problème suivant :\nCette fonction calcule le nombre de façons de dépenser tout l'argent disponible sur une sélection de plats dans un restaurant. Chaque plat ne peut être acheté qu'une seule fois. La fonction prend le nombre de plats disponibles, le montant total d'argent, et une chaîne contenant le prix de chaque plat.\n\nCas d'exemple :\n\ncount_meal_combinations 3 5 \"1 2 3\" devrait retourner 2 (1+2+2 ou 3+2).\ncount_meal_combinations 4 6 \"1 2 3 1\" devrait retourner 3 (1+2+3, 1+1+2+2, ou 2+3+1).",
      "de": "Schreiben Sie eine Shell-Funktion `count_meal_combinations() {\nlocal n=$1\nlocal m=$2\nlocal dish_prices=($3)\n` um das folgende Problem zu lösen:\nDiese Funktion berechnet die Anzahl der Möglichkeiten, das gesamte verfügbare Geld für eine Auswahl von Gerichten in einem Restaurant auszugeben. Jedes Gericht kann nur einmal gekauft werden. Die Funktion nimmt die Anzahl der verfügbaren Gerichte, den Gesamtbetrag des Geldes und eine Zeichenkette, die den Preis jedes Gerichts enthält.\n\nBeispiel Fälle:\n\ncount_meal_combinations 3 5 \"1 2 3\" sollte 2 zurückgeben (1+2+2 oder 3+2).\ncount_meal_combinations 4 6 \"1 2 3 1\" sollte 3 zurückgeben (1+2+3, 1+1+2+2, oder 2+3+1).",
      "ha": "Rubuta aikin Shell `count_meal_combinations() {\nlocal n=$1\nlocal m=$2\nlocal dish_prices=($3)\n` don warware matsalar mai zuwa:\nWannan aikin yana ƙididdige yawan hanyoyin kashe duk kuɗin da ake da su akan zaɓin abinci a gidan cin abinci. Ana iya siyan kowanne abinci sau ɗaya kawai. Aikin yana ɗaukar yawan abincin da ake da shi, jimillar kuɗin, da kuma jeren farashin kowanne abinci.\n\nMisalan Lokuta:\n\ncount_meal_combinations 3 5 \"1 2 3\" ya kamata ya dawo 2 (1+2+2 ko 3+2).\ncount_meal_combinations 4 6 \"1 2 3 1\" ya kamata ya dawo 3 (1+2+3, 1+1+2+2, ko 2+3+1).",
      "hi": "Shell फ़ंक्शन `count_meal_combinations() {\nlocal n=$1\nlocal m=$2\nlocal dish_prices=($3)\n` निम्नलिखित समस्या को हल करने के लिए लिखें:\nयह फ़ंक्शन रेस्तरां में व्यंजनों के चयन पर उपलब्ध सभी पैसे खर्च करने के तरीकों की संख्या की गणना करता है। प्रत्येक व्यंजन को केवल एक बार खरीदा जा सकता है। फ़ंक्शन उपलब्ध व्यंजनों की संख्या, कुल पैसे की राशि, और प्रत्येक व्यंजन की कीमत को शामिल करने वाली एक स्ट्रिंग लेता है।\n\nउदाहरण मामले:\n\ncount_meal_combinations 3 5 \"1 2 3\" को 2 लौटाना चाहिए (1+2+2 या 3+2)।\ncount_meal_combinations 4 6 \"1 2 3 1\" को 3 लौटाना चाहिए (1+2+3, 1+1+2+2, या 2+3+1)।",
      "hu": "Írj egy Shell függvényt `count_meal_combinations() {\nlocal n=$1\nlocal m=$2\nlocal dish_prices=($3)\n` a következő probléma megoldására:\nEz a függvény kiszámítja, hogy hányféleképpen lehet az összes rendelkezésre álló pénzt elkölteni egy étteremben választható ételekre. Minden ételt csak egyszer lehet megvásárolni. A függvény megkapja a rendelkezésre álló ételek számát, a teljes pénzösszeget, és egy karakterláncot, amely az egyes ételek árát tartalmazza.\n\nPélda esetek:\n\ncount_meal_combinations 3 5 \"1 2 3\" vissza kell adnia 2 (1+2+2 vagy 3+2).\ncount_meal_combinations 4 6 \"1 2 3 1\" vissza kell adnia 3 (1+2+3, 1+1+2+2, vagy 2+3+1)."
    },
    "instruction_bertscore": {
      "sq": "0.9942407121018935",
      "hy": "0.9841395627047452",
      "bn": "0.9718232872982959",
      "bg": "0.9885571023789611",
      "zh": "0.9694359487486376",
      "fr": "0.9942770614616228",
      "de": "0.9903280908562682",
      "ha": "0.96416588747902",
      "hi": "0.9740672147128471",
      "hu": "0.9827727870528441"
    },
    "level": "easy",
    "test": "test_meal_combinations() {\n[[ $(count_meal_combinations 3 5 \"1 2 3\") -eq 1 ]] || { echo \"Test 1 failed\"; exit 1; }\n[[ $(count_meal_combinations 4 6 \"1 2 3 1\") -eq 2 ]] || { echo \"Test 2 failed\"; exit 1; }\n[[ $(count_meal_combinations 5 10 \"2 2 2 2 2\") -eq 1 ]] || { echo \"Test 3 failed\"; exit 1; }\n[[ $(count_meal_combinations 3 3 \"1 1 1\") -eq 1 ]] || { echo \"Test 4 failed\"; exit 1; }\n[[ $(count_meal_combinations 4 8 \"1 2 3 5\") -eq 2 ]] || { echo \"Test 5 failed\"; exit 1; }\n}\n\ntest_meal_combinations",
    "entry_point": "count_meal_combinations",
    "signature": "count_meal_combinations() {\nlocal n=$1\nlocal m=$2\nlocal dish_prices=($3)\n",
    "docstring": {
      "en": "This function calculates the number of ways to spend all available money on a selection of dishes in a restaurant. Each dish can only be purchased once. The function takes the number of dishes available, the total amount of money, and a string containing the price of each dish.\n\nExample Cases:\n\ncount_meal_combinations 3 5 \"1 2 3\" should return 2 (1+2+2 or 3+2).\ncount_meal_combinations 4 6 \"1 2 3 1\" should return 3 (1+2+3, 1+1+2+2, or 2+3+1).",
      "sq": "Kjo funksion llogarit numrin e mënyrave për të shpenzuar të gjitha paratë e disponueshme në një përzgjedhje të pjatave në një restorant. Çdo pjatë mund të blihet vetëm një herë. Funksioni merr numrin e pjatave të disponueshme, shumën totale të parave dhe një varg që përmban çmimin e secilës pjatë.\n\nShembuj Rastesh:\n\ncount_meal_combinations 3 5 \"1 2 3\" duhet të kthejë 2 (1+2+2 ose 3+2).\ncount_meal_combinations 4 6 \"1 2 3 1\" duhet të kthejë 3 (1+2+3, 1+1+2+2, ose 2+3+1).",
      "hy": "Այս ֆունկցիան հաշվարկում է, թե քանի եղանակով կարելի է ծախսել բոլոր հասանելի գումարը ռեստորանում ուտեստների ընտրության վրա։ Յուրաքանչյուր ուտեստ կարելի է գնել միայն մեկ անգամ։ Ֆունկցիան ընդունում է հասանելի ուտեստների քանակը, գումարի ընդհանուր չափը և տող, որը պարունակում է յուրաքանչյուր ուտեստի գինը։\n\nՕրինակներ:\n\ncount_meal_combinations 3 5 \"1 2 3\" պետք է վերադարձնի 2 (1+2+2 կամ 3+2):\ncount_meal_combinations 4 6 \"1 2 3 1\" պետք է վերադարձնի 3 (1+2+3, 1+1+2+2, կամ 2+3+1):",
      "bn": "এই ফাংশনটি রেস্তোরাঁয় একটি পদের নির্বাচন করার জন্য সমস্ত উপলব্ধ অর্থ ব্যয় করার উপায়ের সংখ্যা গণনা করে। প্রতিটি পদ শুধুমাত্র একবার কেনা যেতে পারে। ফাংশনটি উপলব্ধ পদের সংখ্যা, মোট অর্থের পরিমাণ এবং প্রতিটি পদের মূল্য ধারণকারী একটি স্ট্রিং নেয়।\n\nউদাহরণ কেসসমূহ:\n\ncount_meal_combinations 3 5 \"1 2 3\" 2 ফেরত দেবে (1+2+2 বা 3+2)।\ncount_meal_combinations 4 6 \"1 2 3 1\" 3 ফেরত দেবে (1+2+3, 1+1+2+2, বা 2+3+1)।",
      "bg": "Тази функция изчислява броя на начините за изразходване на всички налични пари за избор на ястия в ресторант. Всяко ястие може да бъде закупено само веднъж. Функцията приема броя на наличните ястия, общата сума пари и низ, съдържащ цената на всяко ястие.\n\nПримерни случаи:\n\ncount_meal_combinations 3 5 \"1 2 3\" трябва да върне 2 (1+2+2 или 3+2).\ncount_meal_combinations 4 6 \"1 2 3 1\" трябва да върне 3 (1+2+3, 1+1+2+2, или 2+3+1).",
      "zh": "该函数计算在餐厅中用所有可用资金选择菜肴的方式数量。每道菜只能购买一次。函数接受可用菜肴的数量、总金额以及包含每道菜价格的字符串。\n\n示例案例：\n\ncount_meal_combinations 3 5 \"1 2 3\" 应返回 2 (1+2+2 或 3+2)。\ncount_meal_combinations 4 6 \"1 2 3 1\" 应返回 3 (1+2+3, 1+1+2+2, 或 2+3+1)。",
      "fr": "Cette fonction calcule le nombre de façons de dépenser tout l'argent disponible sur une sélection de plats dans un restaurant. Chaque plat ne peut être acheté qu'une seule fois. La fonction prend le nombre de plats disponibles, le montant total d'argent, et une chaîne contenant le prix de chaque plat.\n\nCas d'exemples :\n\ncount_meal_combinations 3 5 \"1 2 3\" devrait retourner 2 (1+2+2 ou 3+2).\ncount_meal_combinations 4 6 \"1 2 3 1\" devrait retourner 3 (1+2+3, 1+1+2+2, ou 2+3+1).",
      "de": "Diese Funktion berechnet die Anzahl der Möglichkeiten, das gesamte verfügbare Geld für eine Auswahl von Gerichten in einem Restaurant auszugeben. Jedes Gericht kann nur einmal gekauft werden. Die Funktion nimmt die Anzahl der verfügbaren Gerichte, den Gesamtbetrag des Geldes und einen String, der den Preis jedes Gerichts enthält.\n\nBeispiel Fälle:\n\ncount_meal_combinations 3 5 \"1 2 3\" sollte 2 zurückgeben (1+2+2 oder 3+2).\ncount_meal_combinations 4 6 \"1 2 3 1\" sollte 3 zurückgeben (1+2+3, 1+1+2+2, oder 2+3+1).",
      "ha": "Wannan aikin yana ƙididdige yawan hanyoyin da za a kashe duk kuɗin da ake da su kan zaɓin abinci a gidan abinci. Ana iya siyan kowanne abinci sau ɗaya kawai. Aikin yana ɗaukar adadin abincin da ake da su, jimillar kuɗi, da kuma kirtani mai ɗauke da farashin kowanne abinci.\n\nMisalan Lokuta:\n\ncount_meal_combinations 3 5 \"1 2 3\" ya kamata ya dawo 2 (1+2+2 ko 3+2).\ncount_meal_combinations 4 6 \"1 2 3 1\" ya kamata ya dawo 3 (1+2+3, 1+1+2+2, ko 2+3+1).",
      "hi": "यह फ़ंक्शन एक रेस्तरां में व्यंजनों के चयन पर उपलब्ध सभी पैसे खर्च करने के तरीकों की संख्या की गणना करता है। प्रत्येक व्यंजन को केवल एक बार खरीदा जा सकता है। फ़ंक्शन उपलब्ध व्यंजनों की संख्या, कुल पैसे की राशि, और प्रत्येक व्यंजन की कीमत वाली एक स्ट्रिंग लेता है।\n\nउदाहरण मामले:\n\ncount_meal_combinations 3 5 \"1 2 3\" को 2 लौटाना चाहिए (1+2+2 या 3+2)।\ncount_meal_combinations 4 6 \"1 2 3 1\" को 3 लौटाना चाहिए (1+2+3, 1+1+2+2, या 2+3+1)।",
      "hu": "Ez a függvény kiszámítja, hogy hányféleképpen lehet az összes rendelkezésre álló pénzt elkölteni egy étteremben kapható ételek kiválasztására. Minden ételt csak egyszer lehet megvásárolni. A függvény megkapja a rendelkezésre álló ételek számát, a teljes pénzösszeget, és egy karakterláncot, amely az egyes ételek árát tartalmazza.\n\nPélda esetek:\n\ncount_meal_combinations 3 5 \"1 2 3\" vissza kell adnia 2 (1+2+2 vagy 3+2).\ncount_meal_combinations 4 6 \"1 2 3 1\" vissza kell adnia 3 (1+2+3, 1+1+2+2, vagy 2+3+1)."
    },
    "docstring_bertscore": {
      "sq": "0.9907342899854845",
      "hy": "0.9738836802407709",
      "bn": "0.9810725109911855",
      "bg": "0.9853601463962046",
      "zh": "0.9582683528357131",
      "fr": "0.9946870345680788",
      "de": "0.9927974637532939",
      "ha": "0.9614810006185713",
      "hi": "0.9887753971677185",
      "hu": "0.9845338440110994"
    }
  },
  {
    "task_id": "Shell/38",
    "prompt": {
      "en": "previous_permutation() {\nlocal n=$1\nlocal permutation=($2)\nlocal i j\n# This function finds the previous lexicographical permutation of a given sequence.\n# If the current permutation is the first one in lexicographical order, it returns 'ERROR'.\n# The function takes the number of elements and the current permutation as arguments.\n# Example usage:\n# previous_permutation 3 \"1 2 3\"\n# This would return 'ERROR', as '1 2 3' is the first permutation.\n\n# previous_permutation 4 \"1 3 4 2\"\n# This would return '1 3 2 4', as it's the previous permutation in lexicographical order.\n",
      "sq": "previous_permutation() {\nlocal n=$1\nlocal permutation=($2)\nlocal i j\n# Kjo funksion gjen permutimin e mëparshëm leksikografik të një sekuence të dhënë.\n# Nëse permutimi aktual është i pari në rendin leksikografik, kthen 'ERROR'.\n# Funksioni merr numrin e elementeve dhe permutimin aktual si argumente.\n# Shembull përdorimi:\n# previous_permutation 3 \"1 2 3\"\n# Kjo do të kthente 'ERROR', pasi '1 2 3' është permutimi i parë.\n\n# previous_permutation 4 \"1 3 4 2\"\n# Kjo do të kthente '1 3 2 4', pasi është permutimi i mëparshëm në rendin leksikografik.\n",
      "hy": "previous_permutation() {\nlocal n=$1\nlocal permutation=($2)\nlocal i j\n# Այս ֆունկցիան գտնում է տրված հաջորդականության նախորդ բառարանային փոխարկումը։\n# Եթե ընթացիկ փոխարկումը բառարանային կարգով առաջինն է, այն վերադարձնում է 'ERROR'։\n# Ֆունկցիան ընդունում է տարրերի քանակը և ընթացիկ փոխարկումը որպես արգումենտներ։\n# Օրինակ օգտագործում՝\n# previous_permutation 3 \"1 2 3\"\n# Սա կվերադարձնի 'ERROR', քանի որ '1 2 3'-ը առաջին փոխարկումն է։\n\n# previous_permutation 4 \"1 3 4 2\"\n# Սա կվերադարձնի '1 3 2 4', քանի որ դա նախորդ փոխարկումն է բառարանային կարգով։",
      "bn": "previous_permutation() {\nlocal n=$1\nlocal permutation=($2)\nlocal i j\n# এই ফাংশনটি একটি প্রদত্ত ক্রমের পূর্ববর্তী অভিধানগত বিন্যাস খুঁজে বের করে।\n# যদি বর্তমান বিন্যাসটি অভিধানগত ক্রমে প্রথম হয়, তাহলে এটি 'ERROR' ফেরত দেয়।\n# ফাংশনটি উপাদানগুলির সংখ্যা এবং বর্তমান বিন্যাসকে আর্গুমেন্ট হিসেবে গ্রহণ করে।\n# উদাহরণ ব্যবহার:\n# previous_permutation 3 \"1 2 3\"\n# এটি 'ERROR' ফেরত দেবে, কারণ '1 2 3' প্রথম বিন্যাস।\n\n# previous_permutation 4 \"1 3 4 2\"\n# এটি '1 3 2 4' ফেরত দেবে, কারণ এটি অভিধানগত ক্রমে পূর্ববর্তী বিন্যাস।",
      "bg": "previous_permutation() {\nlocal n=$1\nlocal permutation=($2)\nlocal i j\n# Тази функция намира предишната лексикографска пермутация на дадена последователност.\n# Ако текущата пермутация е първата в лексикографски ред, тя връща 'ERROR'.\n# Функцията приема броя на елементите и текущата пермутация като аргументи.\n# Пример за използване:\n# previous_permutation 3 \"1 2 3\"\n# Това би върнало 'ERROR', тъй като '1 2 3' е първата пермутация.\n\n# previous_permutation 4 \"1 3 4 2\"\n# Това би върнало '1 3 2 4', тъй като това е предишната пермутация в лексикографски ред.",
      "zh": "previous_permutation() {\nlocal n=$1\nlocal permutation=($2)\nlocal i j\n# 此函数查找给定序列的前一个字典序排列。\n# 如果当前排列是字典序中的第一个排列，则返回 'ERROR'。\n# 函数以元素数量和当前排列作为参数。\n# 示例用法：\n# previous_permutation 3 \"1 2 3\"\n# 这将返回 'ERROR'，因为 '1 2 3' 是第一个排列。\n\n# previous_permutation 4 \"1 3 4 2\"\n# 这将返回 '1 3 2 4'，因为它是字典序中的前一个排列。",
      "fr": "previous_permutation() {\nlocal n=$1\nlocal permutation=($2)\nlocal i j\n# Cette fonction trouve la permutation lexicographique précédente d'une séquence donnée.\n# Si la permutation actuelle est la première dans l'ordre lexicographique, elle renvoie 'ERROR'.\n# La fonction prend le nombre d'éléments et la permutation actuelle comme arguments.\n# Exemple d'utilisation :\n# previous_permutation 3 \"1 2 3\"\n# Cela renverrait 'ERROR', car '1 2 3' est la première permutation.\n\n# previous_permutation 4 \"1 3 4 2\"\n# Cela renverrait '1 3 2 4', car c'est la permutation précédente dans l'ordre lexicographique.",
      "de": "previous_permutation() {\nlocal n=$1\nlocal permutation=($2)\nlocal i j\n# Diese Funktion findet die vorherige lexikographische Permutation einer gegebenen Sequenz.\n# Wenn die aktuelle Permutation die erste in lexikographischer Ordnung ist, gibt sie 'ERROR' zurück.\n# Die Funktion nimmt die Anzahl der Elemente und die aktuelle Permutation als Argumente.\n# Beispielverwendung:\n# previous_permutation 3 \"1 2 3\"\n# Dies würde 'ERROR' zurückgeben, da '1 2 3' die erste Permutation ist.\n\n# previous_permutation 4 \"1 3 4 2\"\n# Dies würde '1 3 2 4' zurückgeben, da es die vorherige Permutation in lexikographischer Ordnung ist.",
      "ha": "previous_permutation() {\nlocal n=$1\nlocal permutation=($2)\nlocal i j\n# Wannan aikin yana nemo permutation na baya a tsarin lexicographical na jerin da aka bayar.\n# Idan permutation na yanzu shine na farko a tsarin lexicographical, zai dawo da 'ERROR'.\n# Aikin yana karɓar adadin abubuwa da permutation na yanzu a matsayin hujjoji.\n# Misalin amfani:\n# previous_permutation 3 \"1 2 3\"\n# Wannan zai dawo da 'ERROR', saboda '1 2 3' shine permutation na farko.\n\n# previous_permutation 4 \"1 3 4 2\"\n# Wannan zai dawo da '1 3 2 4', saboda shine permutation na baya a tsarin lexicographical.",
      "hi": "previous_permutation() {\nlocal n=$1\nlocal permutation=($2)\nlocal i j\n# यह फ़ंक्शन दिए गए अनुक्रम का पिछला शब्दकोशीय क्रमविन्यास खोजता है।\n# यदि वर्तमान क्रमविन्यास शब्दकोशीय क्रम में पहला है, तो यह 'ERROR' लौटाता है।\n# फ़ंक्शन तत्वों की संख्या और वर्तमान क्रमविन्यास को तर्क के रूप में लेता है।\n# उदाहरण उपयोग:\n# previous_permutation 3 \"1 2 3\"\n# यह 'ERROR' लौटाएगा, क्योंकि '1 2 3' पहला क्रमविन्यास है।\n\n# previous_permutation 4 \"1 3 4 2\"\n# यह '1 3 2 4' लौटाएगा, क्योंकि यह शब्दकोशीय क्रम में पिछला क्रमविन्यास है।",
      "hu": "previous_permutation() {\nlocal n=$1\nlocal permutation=($2)\nlocal i j\n# Ez a függvény megkeresi egy adott sorozat előző lexikografikus permutációját.\n# Ha a jelenlegi permutáció az első a lexikografikus sorrendben, akkor 'ERROR'-t ad vissza.\n# A függvény a elemek számát és a jelenlegi permutációt veszi argumentumként.\n# Példa használat:\n# previous_permutation 3 \"1 2 3\"\n# Ez 'ERROR'-t adna vissza, mivel az '1 2 3' az első permutáció.\n\n# previous_permutation 4 \"1 3 4 2\"\n# Ez '1 3 2 4'-et adna vissza, mivel ez az előző permutáció a lexikografikus sorrendben.\n"
    },
    "prompt_bertscore": {
      "sq": "0.9870274498146114",
      "hy": "0.9837248224691444",
      "bn": "0.9876809437682162",
      "bg": "0.9894858980406802",
      "zh": "0.9812026138907634",
      "fr": "0.9855299753719894",
      "de": "0.9868190865449059",
      "ha": "0.9636772567416741",
      "hi": "0.9857625715481813",
      "hu": "0.9864998875225828"
    },
    "canonical_solution": "for (( i=n-2; i>=0; i-- )); do\nif [[ ${permutation[i]} -gt ${permutation[i+1]} ]]; then\nbreak\nfi\ndone\n\n# If no such index exists, the permutation is the first one\nif [[ i -eq -1 ]]; then\necho \"ERROR\"\nreturn\nfi\n\n# Find the largest index j greater than i such that permutation[j] < permutation[i]\nfor (( j=n-1; j>i; j-- )); do\nif [[ ${permutation[j]} -lt ${permutation[i]} ]]; then\nbreak\nfi\ndone\n\n# Swap values at i and j\nlocal temp=${permutation[i]}\npermutation[i]=${permutation[j]}\npermutation[j]=$temp\n\n# Reverse the sequence from i+1 to the end\nlocal left=$((i+1))\nlocal right=$((n-1))\nwhile [[ left -lt right ]]; do\ntemp=${permutation[left]}\npermutation[left]=${permutation[right]}\npermutation[right]=$temp\nleft=$((left+1))\nright=$((right-1))\ndone\n\necho \"${permutation[@]}\"\n}",
    "instruction": {
      "en": "Write a Shell function `previous_permutation() {\nlocal n=$1\nlocal permutation=($2)\nlocal i j\n` to solve the following problem:\nThis function finds the previous lexicographical permutation of a given sequence.\nIf the current permutation is the first one in lexicographical order, it returns 'ERROR'.\nThe function takes the number of elements and the current permutation as arguments.\nExample usage:\nprevious_permutation 3 \"1 2 3\"\nThis would return 'ERROR', as '1 2 3' is the first permutation.\n\nprevious_permutation 4 \"1 3 4 2\"\nThis would return '1 3 2 4', as it's the previous permutation in lexicographical order.\n",
      "sq": "Shkruani një funksion Shell `previous_permutation() {\nlocal n=$1\nlocal permutation=($2)\nlocal i j\n` për të zgjidhur problemin e mëposhtëm:\nKy funksion gjen permutimin e mëparshëm leksikografik të një sekuence të dhënë.\nNëse permutimi aktual është i pari në rendin leksikografik, ai kthen 'ERROR'.\nFunksioni merr numrin e elementeve dhe permutimin aktual si argumente.\nShembull përdorimi:\nprevious_permutation 3 \"1 2 3\"\nKjo do të kthente 'ERROR', pasi '1 2 3' është permutimi i parë.\n\nprevious_permutation 4 \"1 3 4 2\"\nKjo do të kthente '1 3 2 4', pasi është permutimi i mëparshëm në rendin leksikografik.",
      "hy": "Գրեք Shell ֆունկցիա `previous_permutation() {\nlocal n=$1\nlocal permutation=($2)\nlocal i j\n` հետևյալ խնդիրը լուծելու համար:\nԱյս ֆունկցիան գտնում է տրված հաջորդականության նախորդ լեքսիկոգրաֆիական փոխարկումը։\nԵթե ընթացիկ փոխարկումը լեքսիկոգրաֆիական կարգով առաջինն է, այն վերադարձնում է 'ERROR'։\nՖունկցիան ընդունում է տարրերի քանակը և ընթացիկ փոխարկումը որպես արգումենտներ։\nՕրինակ օգտագործում:\nprevious_permutation 3 \"1 2 3\"\nՍա կվերադարձնի 'ERROR', քանի որ '1 2 3' առաջին փոխարկումն է։\n\nprevious_permutation 4 \"1 3 4 2\"\nՍա կվերադարձնի '1 3 2 4', քանի որ դա լեքսիկոգրաֆիական կարգով նախորդ փոխարկումն է։",
      "bn": "একটি Shell ফাংশন লিখুন `previous_permutation() {\nlocal n=$1\nlocal permutation=($2)\nlocal i j\n` নিম্নলিখিত সমস্যার সমাধানের জন্য:\nএই ফাংশনটি একটি প্রদত্ত ক্রমের পূর্ববর্তী লেক্সিকোগ্রাফিক্যাল পারমুটেশন খুঁজে বের করে।\nযদি বর্তমান পারমুটেশনটি লেক্সিকোগ্রাফিক্যাল ক্রমের প্রথমটি হয়, তাহলে এটি 'ERROR' ফেরত দেয়।\nফাংশনটি উপাদানগুলির সংখ্যা এবং বর্তমান পারমুটেশনকে আর্গুমেন্ট হিসেবে নেয়।\nউদাহরণ ব্যবহার:\nprevious_permutation 3 \"1 2 3\"\nএটি 'ERROR' ফেরত দেবে, কারণ '1 2 3' প্রথম পারমুটেশন।\n\nprevious_permutation 4 \"1 3 4 2\"\nএটি '1 3 2 4' ফেরত দেবে, কারণ এটি লেক্সিকোগ্রাফিক্যাল ক্রমে পূর্ববর্তী পারমুটেশন।",
      "bg": "Напишете Shell функция `previous_permutation() {\nlocal n=$1\nlocal permutation=($2)\nlocal i j\n` за да решите следния проблем:\nТази функция намира предишната лексикографска пермутация на дадена последователност.\nАко текущата пермутация е първата в лексикографски ред, тя връща 'ERROR'.\nФункцията приема броя на елементите и текущата пермутация като аргументи.\nПример за използване:\nprevious_permutation 3 \"1 2 3\"\nТова би върнало 'ERROR', тъй като '1 2 3' е първата пермутация.\n\nprevious_permutation 4 \"1 3 4 2\"\nТова би върнало '1 3 2 4', тъй като това е предишната пермутация в лексикографски ред.",
      "zh": "编写一个 Shell 函数 `previous_permutation() {\nlocal n=$1\nlocal permutation=($2)\nlocal i j\n` 来解决以下问题：\n该函数查找给定序列的上一个字典序排列。\n如果当前排列是字典序中的第一个排列，则返回 'ERROR'。\n该函数接受元素数量和当前排列作为参数。\n示例用法：\nprevious_permutation 3 \"1 2 3\"\n这将返回 'ERROR'，因为 '1 2 3' 是第一个排列。\n\nprevious_permutation 4 \"1 3 4 2\"\n这将返回 '1 3 2 4'，因为它是字典序中的上一个排列。",
      "fr": "Écrire une fonction Shell `previous_permutation() {\nlocal n=$1\nlocal permutation=($2)\nlocal i j\n` pour résoudre le problème suivant :\nCette fonction trouve la permutation lexicographique précédente d'une séquence donnée.\nSi la permutation actuelle est la première dans l'ordre lexicographique, elle renvoie 'ERROR'.\nLa fonction prend le nombre d'éléments et la permutation actuelle comme arguments.\nExemple d'utilisation :\nprevious_permutation 3 \"1 2 3\"\nCela renverrait 'ERROR', car '1 2 3' est la première permutation.\n\nprevious_permutation 4 \"1 3 4 2\"\nCela renverrait '1 3 2 4', car c'est la permutation précédente dans l'ordre lexicographique.",
      "de": "Schreiben Sie eine Shell-Funktion `previous_permutation() {\nlocal n=$1\nlocal permutation=($2)\nlocal i j\n`, um das folgende Problem zu lösen:\nDiese Funktion findet die vorherige lexikographische Permutation einer gegebenen Sequenz.\nWenn die aktuelle Permutation die erste in lexikographischer Reihenfolge ist, gibt sie 'ERROR' zurück.\nDie Funktion nimmt die Anzahl der Elemente und die aktuelle Permutation als Argumente.\nBeispielverwendung:\nprevious_permutation 3 \"1 2 3\"\nDies würde 'ERROR' zurückgeben, da '1 2 3' die erste Permutation ist.\n\nprevious_permutation 4 \"1 3 4 2\"\nDies würde '1 3 2 4' zurückgeben, da es die vorherige Permutation in lexikographischer Reihenfolge ist.",
      "ha": "Rubuta aikin Shell `previous_permutation() {\nlocal n=$1\nlocal permutation=($2)\nlocal i j\n` don warware matsalar mai zuwa:\nWannan aikin yana nemo permutation na baya a cikin tsarin lexicographical na wani jerin da aka bayar.\nIdan permutation na yanzu shine na farko a cikin tsarin lexicographical, zai dawo da 'ERROR'.\nAikin yana ɗaukar adadin abubuwa da permutation na yanzu a matsayin hujjoji.\nMisalin amfani:\nprevious_permutation 3 \"1 2 3\"\nWannan zai dawo da 'ERROR', saboda '1 2 3' shine permutation na farko.\n\nprevious_permutation 4 \"1 3 4 2\"\nWannan zai dawo da '1 3 2 4', saboda shine permutation na baya a cikin tsarin lexicographical.",
      "hi": "शेल फ़ंक्शन लिखें `previous_permutation() {\nlocal n=$1\nlocal permutation=($2)\nlocal i j\n` निम्नलिखित समस्या को हल करने के लिए:\nयह फ़ंक्शन दिए गए अनुक्रम का पूर्ववर्ती शब्दकोशीय क्रमपरिवर्तन खोजता है।\nयदि वर्तमान क्रमपरिवर्तन शब्दकोशीय क्रम में पहला है, तो यह 'ERROR' लौटाता है।\nफ़ंक्शन तत्वों की संख्या और वर्तमान क्रमपरिवर्तन को तर्क के रूप में लेता है।\nउदाहरण उपयोग:\nprevious_permutation 3 \"1 2 3\"\nयह 'ERROR' लौटाएगा, क्योंकि '1 2 3' पहला क्रमपरिवर्तन है।\n\nprevious_permutation 4 \"1 3 4 2\"\nयह '1 3 2 4' लौटाएगा, क्योंकि यह शब्दकोशीय क्रम में पूर्ववर्ती क्रमपरिवर्तन है।",
      "hu": "Írj egy Shell függvényt `previous_permutation() {\nlocal n=$1\nlocal permutation=($2)\nlocal i j\n`, hogy megoldja a következő problémát:\nEz a függvény megkeresi egy adott sorozat előző lexikografikus permutációját.\nHa a jelenlegi permutáció az első a lexikografikus sorrendben, akkor 'ERROR'-t ad vissza.\nA függvény az elemek számát és a jelenlegi permutációt veszi argumentumként.\nPélda használat:\nprevious_permutation 3 \"1 2 3\"\nEz 'ERROR'-t adna vissza, mivel az '1 2 3' az első permutáció.\n\nprevious_permutation 4 \"1 3 4 2\"\nEz '1 3 2 4'-et adna vissza, mivel ez az előző permutáció a lexikografikus sorrendben."
    },
    "instruction_bertscore": {
      "sq": "0.9910936123447767",
      "hy": "0.991397318197379",
      "bn": "0.9889003356773894",
      "bg": "0.9916166061380415",
      "zh": "0.9867126206606711",
      "fr": "0.9901133714143695",
      "de": "0.9941576846026209",
      "ha": "0.9822102658137534",
      "hi": "0.8455213786919278",
      "hu": "0.9876916698087921"
    },
    "level": "hard",
    "test": "test_previous_permutation() {\n[[ $(previous_permutation 3 \"1 3 2\") == \"1 2 3\" ]] || { echo \"Test 1 failed\"; exit 1; }\n[[ $(previous_permutation 3 \"1 2 3\") == \"ERROR\" ]] || { echo \"Test 2 failed\"; exit 1; }\n[[ $(previous_permutation 4 \"2 1 4 3\") == \"2 1 3 4\" ]] || { echo \"Test 3 failed\"; exit 1; }\n[[ $(previous_permutation 5 \"5 4 3 2 1\") == \"5 4 3 1 2\" ]] || { echo \"Test 4 failed\"; exit 1; }\n[[ $(previous_permutation 4 \"1 4 3 2\") == \"1 4 2 3\" ]] || { echo \"Test 5 failed\"; exit 1; }\n}\n\ntest_previous_permutation",
    "entry_point": "previous_permutation",
    "signature": "previous_permutation() {\nlocal n=$1\nlocal permutation=($2)\nlocal i j\n",
    "docstring": {
      "en": "This function finds the previous lexicographical permutation of a given sequence.\nIf the current permutation is the first one in lexicographical order, it returns 'ERROR'.\nThe function takes the number of elements and the current permutation as arguments.\nExample usage:\nprevious_permutation 3 \"1 2 3\"\nThis would return 'ERROR', as '1 2 3' is the first permutation.\n\nprevious_permutation 4 \"1 3 4 2\"\nThis would return '1 3 2 4', as it's the previous permutation in lexicographical order.\n",
      "sq": "Kjo funksion gjen permutimin e mëparshëm leksikografik të një sekuence të dhënë. Nëse permutimi aktual është i pari në rendin leksikografik, ai kthen 'ERROR'. Funksioni merr numrin e elementeve dhe permutimin aktual si argumente. Shembull përdorimi: previous_permutation 3 \"1 2 3\" Kjo do të kthente 'ERROR', pasi '1 2 3' është permutimi i parë.\n\nprevious_permutation 4 \"1 3 4 2\" Kjo do të kthente '1 3 2 4', pasi është permutimi i mëparshëm në rendin leksikografik.",
      "hy": "Այս ֆունկցիան գտնում է տրված հաջորդականության նախորդ լեքսիկոգրաֆիական փոխատեղումը։  \nԵթե ընթացիկ փոխատեղումը լեքսիկոգրաֆիական կարգով առաջինն է, այն վերադարձնում է 'ERROR':  \nՖունկցիան ընդունում է տարրերի քանակը և ընթացիկ փոխատեղումը որպես արգումենտներ։  \nՕգտագործման օրինակ՝  \nprevious_permutation 3 \"1 2 3\"  \nՍա կվերադարձնի 'ERROR', քանի որ '1 2 3'-ը առաջին փոխատեղումն է։  \n\nprevious_permutation 4 \"1 3 4 2\"  \nՍա կվերադարձնի '1 3 2 4', քանի որ դա լեքսիկոգրաֆիական կարգով նախորդ փոխատեղումն է։  ",
      "bn": "This function finds the previous lexicographical permutation of a given sequence.\nএই ফাংশনটি একটি প্রদত্ত সিকোয়েন্সের পূর্ববর্তী লেক্সিকোগ্রাফিক্যাল পারমুটেশন খুঁজে বের করে।\nIf the current permutation is the first one in lexicographical order, it returns 'ERROR'.\nযদি বর্তমান পারমুটেশনটি লেক্সিকোগ্রাফিক্যাল ক্রমে প্রথম হয়, তাহলে এটি 'ERROR' রিটার্ন করে।\nThe function takes the number of elements and the current permutation as arguments.\nফাংশনটি উপাদানগুলির সংখ্যা এবং বর্তমান পারমুটেশনকে আর্গুমেন্ট হিসেবে গ্রহণ করে।\nExample usage:\nউদাহরণ ব্যবহার:\nprevious_permutation 3 \"1 2 3\"\nThis would return 'ERROR', as '1 2 3' is the first permutation.\nএটি 'ERROR' রিটার্ন করবে, কারণ '1 2 3' প্রথম পারমুটেশন।\n\nprevious_permutation 4 \"1 3 4 2\"\nThis would return '1 3 2 4', as it's the previous permutation in lexicographical order.\nএটি '1 3 2 4' রিটার্ন করবে, কারণ এটি লেক্সিকোগ্রাফিক্যাল ক্রমে পূর্ববর্তী পারমুটেশন।",
      "bg": "Тази функция намира предишната лексикографска пермутация на дадена последователност.  \nАко текущата пермутация е първата в лексикографски ред, тя връща 'ERROR'.  \nФункцията приема броя на елементите и текущата пермутация като аргументи.  \nПример за използване:  \nprevious_permutation 3 \"1 2 3\"  \nТова би върнало 'ERROR', тъй като '1 2 3' е първата пермутация.  \n\nprevious_permutation 4 \"1 3 4 2\"  \nТова би върнало '1 3 2 4', тъй като това е предишната пермутация в лексикографски ред.  ",
      "zh": "该函数用于查找给定序列的前一个字典序排列。\n如果当前排列是字典序中的第一个排列，则返回“ERROR”。\n该函数接受元素数量和当前排列作为参数。\n示例用法：\nprevious_permutation 3 \"1 2 3\"\n这将返回“ERROR”，因为“1 2 3”是第一个排列。\n\nprevious_permutation 4 \"1 3 4 2\"\n这将返回“1 3 2 4”，因为它是字典序中的前一个排列。",
      "fr": "Cette fonction trouve la permutation lexicographique précédente d'une séquence donnée.  \nSi la permutation actuelle est la première dans l'ordre lexicographique, elle renvoie 'ERREUR'.  \nLa fonction prend le nombre d'éléments et la permutation actuelle comme arguments.  \nExemple d'utilisation :  \nprevious_permutation 3 \"1 2 3\"  \nCela renverrait 'ERREUR', car '1 2 3' est la première permutation.  \n\nprevious_permutation 4 \"1 3 4 2\"  \nCela renverrait '1 3 2 4', car c'est la permutation précédente dans l'ordre lexicographique.  ",
      "de": "Diese Funktion findet die vorherige lexikographische Permutation einer gegebenen Sequenz.\nWenn die aktuelle Permutation die erste in lexikographischer Reihenfolge ist, gibt sie 'ERROR' zurück.\nDie Funktion nimmt die Anzahl der Elemente und die aktuelle Permutation als Argumente.\nBeispielverwendung:\nprevious_permutation 3 \"1 2 3\"\nDies würde 'ERROR' zurückgeben, da '1 2 3' die erste Permutation ist.\n\nprevious_permutation 4 \"1 3 4 2\"\nDies würde '1 3 2 4' zurückgeben, da es die vorherige Permutation in lexikographischer Reihenfolge ist.",
      "ha": "Wannan aikin yana nemo permutation na baya a cikin tsarin lexicographical na wata jerin abubuwa da aka bayar. Idan permutation na yanzu shine na farko a cikin tsarin lexicographical, zai dawo da 'ERROR'. Aikin yana daukar adadin abubuwa da permutation na yanzu a matsayin hujjoji.\n\nMisalin amfani:\nprevious_permutation 3 \"1 2 3\"\nWannan zai dawo da 'ERROR', saboda '1 2 3' shine permutation na farko.\n\nprevious_permutation 4 \"1 3 4 2\"\nWannan zai dawo da '1 3 2 4', saboda shine permutation na baya a cikin tsarin lexicographical.",
      "hi": "This function एक दिए गए अनुक्रम का पूर्ववर्ती शब्दकोशीय क्रमपरिवर्तन ढूंढता है।  \nयदि वर्तमान क्रमपरिवर्तन शब्दकोशीय क्रम में पहला है, तो यह 'ERROR' लौटाता है।  \nयह फ़ंक्शन तत्वों की संख्या और वर्तमान क्रमपरिवर्तन को तर्क के रूप में लेता है।  \nउदाहरण उपयोग:  \nprevious_permutation 3 \"1 2 3\"  \nयह 'ERROR' लौटाएगा, क्योंकि '1 2 3' पहला क्रमपरिवर्तन है।  \n\nprevious_permutation 4 \"1 3 4 2\"  \nयह '1 3 2 4' लौटाएगा, क्योंकि यह शब्दकोशीय क्रम में पूर्ववर्ती क्रमपरिवर्तन है।  ",
      "hu": "Ez a függvény megkeresi egy adott sorozat előző lexikografikus permutációját.\nHa a jelenlegi permutáció az első a lexikografikus sorrendben, akkor 'ERROR'-t ad vissza.\nA függvény a elemek számát és a jelenlegi permutációt veszi át argumentumként.\nPélda használat:\nprevious_permutation 3 \"1 2 3\"\nEz 'ERROR'-t adna vissza, mivel az '1 2 3' az első permutáció.\n\nprevious_permutation 4 \"1 3 4 2\"\nEz '1 3 2 4'-et adna vissza, mivel ez az előző permutáció a lexikografikus sorrendben."
    },
    "docstring_bertscore": {
      "sq": "0.9890034248451465",
      "hy": "0.979093953765697",
      "bn": "1",
      "bg": "0.9881550744877465",
      "zh": "0.957760653581788",
      "fr": "0.9857041742161571",
      "de": "0.9879081769241201",
      "ha": "0.9431507931655287",
      "hi": "0.9828371432962995",
      "hu": "0.9855373246960877"
    }
  },
  {
    "task_id": "Shell/39",
    "prompt": {
      "en": "check_lottery_winnings() {\nlocal winning_numbers=($1)\n# This function checks the number of matches each lottery ticket has with the winning numbers\n# and categorizes each ticket based on the prize won. It returns the count of tickets for each prize category.\n# The function takes the winning numbers and the lottery tickets as arguments.\n# Example usage:\n# check_lottery_winnings \"1 2 3 4 5 6 7\" \"1 8 9 10 11 12 13\" \"2 3 4 5 6 7 8\"\n# This would return '0 1 0 0 0 0 0', as the second ticket wins a first prize.\n\n# check_lottery_winnings \"10 11 12 13 14 15 16\" \"17 18 19 20 21 22 23\" \"24 25 26 27 28 29 30\"\n# This would return '0 0 0 0 0 0 0', as no tickets match any winning numbers.",
      "sq": "check_lottery_winnings() {\nlocal winning_numbers=($1)\n# Kjo funksion kontrollon numrin e përputhjeve që ka secili biletë llotarie me numrat fitues\n# dhe kategorizon secilën biletë bazuar në çmimin e fituar. Ai kthen numrin e biletave për secilën kategori çmimesh.\n# Funksioni merr numrat fitues dhe biletat e llotarisë si argumente.\n# Shembull përdorimi:\n# check_lottery_winnings \"1 2 3 4 5 6 7\" \"1 8 9 10 11 12 13\" \"2 3 4 5 6 7 8\"\n# Kjo do të kthente '0 1 0 0 0 0 0', pasi bileta e dytë fiton një çmim të parë.\n\n# check_lottery_winnings \"10 11 12 13 14 15 16\" \"17 18 19 20 21 22 23\" \"24 25 26 27 28 29 30\"\n# Kjo do të kthente '0 0 0 0 0 0 0', pasi asnjë biletë nuk përputhet me ndonjë numër fitues.",
      "hy": "check_lottery_winnings() {\nlocal winning_numbers=($1)\n# Այս ֆունկցիան ստուգում է, թե քանի համընկնում ունի յուրաքանչյուր վիճակախաղի տոմս հաղթող համարների հետ\n# և դասակարգում է յուրաքանչյուր տոմսը ըստ շահած մրցանակի: Այն վերադարձնում է տոմսերի քանակը յուրաքանչյուր մրցանակային կատեգորիայի համար:\n# Ֆունկցիան ընդունում է հաղթող համարները և վիճակախաղի տոմսերը որպես արգումենտներ:\n# Օրինակ օգտագործում:\n# check_lottery_winnings \"1 2 3 4 5 6 7\" \"1 8 9 10 11 12 13\" \"2 3 4 5 6 7 8\"\n# Սա կվերադարձնի '0 1 0 0 0 0 0', քանի որ երկրորդ տոմսը շահում է առաջին մրցանակը:\n\n# check_lottery_winnings \"10 11 12 13 14 15 16\" \"17 18 19 20 21 22 23\" \"24 25 26 27 28 29 30\"\n# Սա կվերադարձնի '0 0 0 0 0 0 0', քանի որ ոչ մի տոմս չի համընկնում հաղթող համարների հետ:",
      "bn": "check_lottery_winnings() {\nlocal winning_numbers=($1)\n# এই ফাংশনটি প্রতিটি লটারি টিকিটের সাথে বিজয়ী নম্বরগুলির মিলের সংখ্যা পরীক্ষা করে\n# এবং প্রতিটি টিকিটকে জেতা পুরস্কারের ভিত্তিতে শ্রেণীবদ্ধ করে। এটি প্রতিটি পুরস্কার শ্রেণীর জন্য টিকিটের সংখ্যা ফেরত দেয়।\n# ফাংশনটি বিজয়ী নম্বর এবং লটারি টিকিটগুলি আর্গুমেন্ট হিসেবে গ্রহণ করে।\n# উদাহরণ ব্যবহার:\n# check_lottery_winnings \"1 2 3 4 5 6 7\" \"1 8 9 10 11 12 13\" \"2 3 4 5 6 7 8\"\n# এটি '0 1 0 0 0 0 0' ফেরত দেবে, কারণ দ্বিতীয় টিকিট প্রথম পুরস্কার জেতে।\n\n# check_lottery_winnings \"10 11 12 13 14 15 16\" \"17 18 19 20 21 22 23\" \"24 25 26 27 28 29 30\"\n# এটি '0 0 0 0 0 0 0' ফেরত দেবে, কারণ কোনো টিকিট বিজয়ী নম্বরগুলির সাথে মেলে না।",
      "bg": "check_lottery_winnings() {\nlocal winning_numbers=($1)\n# Тази функция проверява броя на съвпаденията на всеки лотариен билет с печелившите числа\n# и категоризира всеки билет въз основа на спечелената награда. Връща броя на билетите за всяка категория награди.\n# Функцията приема печелившите числа и лотарийните билети като аргументи.\n# Пример за използване:\n# check_lottery_winnings \"1 2 3 4 5 6 7\" \"1 8 9 10 11 12 13\" \"2 3 4 5 6 7 8\"\n# Това би върнало '0 1 0 0 0 0 0', тъй като вторият билет печели първа награда.\n\n# check_lottery_winnings \"10 11 12 13 14 15 16\" \"17 18 19 20 21 22 23\" \"24 25 26 27 28 29 30\"\n# Това би върнало '0 0 0 0 0 0 0', тъй като няма билети, които да съвпадат с някое от печелившите числа.",
      "zh": "check_lottery_winnings() {\nlocal winning_numbers=($1)\n# 此函数检查每张彩票与中奖号码的匹配数量\n# 并根据赢得的奖品对每张彩票进行分类。它返回每个奖品类别的彩票数量。\n# 该函数将中奖号码和彩票作为参数。\n# 示例用法：\n# check_lottery_winnings \"1 2 3 4 5 6 7\" \"1 8 9 10 11 12 13\" \"2 3 4 5 6 7 8\"\n# 这将返回 '0 1 0 0 0 0 0'，因为第二张彩票赢得了一等奖。\n\n# check_lottery_winnings \"10 11 12 13 14 15 16\" \"17 18 19 20 21 22 23\" \"24 25 26 27 28 29 30\"\n# 这将返回 '0 0 0 0 0 0 0'，因为没有彩票匹配任何中奖号码。",
      "fr": "check_lottery_winnings() {\nlocal winning_numbers=($1)\n# Cette fonction vérifie le nombre de correspondances que chaque billet de loterie a avec les numéros gagnants\n# et catégorise chaque billet en fonction du prix gagné. Elle renvoie le nombre de billets pour chaque catégorie de prix.\n# La fonction prend les numéros gagnants et les billets de loterie comme arguments.\n# Exemple d'utilisation :\n# check_lottery_winnings \"1 2 3 4 5 6 7\" \"1 8 9 10 11 12 13\" \"2 3 4 5 6 7 8\"\n# Cela retournerait '0 1 0 0 0 0 0', car le deuxième billet gagne un premier prix.\n\n# check_lottery_winnings \"10 11 12 13 14 15 16\" \"17 18 19 20 21 22 23\" \"24 25 26 27 28 29 30\"\n# Cela retournerait '0 0 0 0 0 0 0', car aucun billet ne correspond à un numéro gagnant.",
      "de": "check_lottery_winnings() {\nlocal winning_numbers=($1)\n# Diese Funktion überprüft die Anzahl der Übereinstimmungen, die jedes Lotterielos mit den Gewinnzahlen hat\n# und kategorisiert jedes Ticket basierend auf dem gewonnenen Preis. Sie gibt die Anzahl der Tickets für jede Preiskategorie zurück.\n# Die Funktion nimmt die Gewinnzahlen und die Lotterielose als Argumente.\n# Beispielverwendung:\n# check_lottery_winnings \"1 2 3 4 5 6 7\" \"1 8 9 10 11 12 13\" \"2 3 4 5 6 7 8\"\n# Dies würde '0 1 0 0 0 0 0' zurückgeben, da das zweite Ticket einen ersten Preis gewinnt.\n\n# check_lottery_winnings \"10 11 12 13 14 15 16\" \"17 18 19 20 21 22 23\" \"24 25 26 27 28 29 30\"\n# Dies würde '0 0 0 0 0 0 0' zurückgeben, da keine Tickets mit den Gewinnzahlen übereinstimmen.",
      "ha": "check_lottery_winnings() {\nlocal winning_numbers=($1)\n# Wannan aikin yana duba yawan dacewar kowanne tikitin caca da lambobin nasara\n# kuma yana rarraba kowanne tikiti bisa ga kyautar da aka ci. Yana mayar da adadin tikiti don kowanne rukuni na kyauta.\n# Aikin yana ɗaukar lambobin nasara da tikitin caca a matsayin hujjoji.\n# Misalin amfani:\n# check_lottery_winnings \"1 2 3 4 5 6 7\" \"1 8 9 10 11 12 13\" \"2 3 4 5 6 7 8\"\n# Wannan zai mayar da '0 1 0 0 0 0 0', domin tikiti na biyu ya ci kyauta ta farko.\n\n# check_lottery_winnings \"10 11 12 13 14 15 16\" \"17 18 19 20 21 22 23\" \"24 25 26 27 28 29 30\"\n# Wannan zai mayar da '0 0 0 0 0 0 0', domin babu tikiti da ya dace da wani daga cikin lambobin nasara.",
      "hi": "check_lottery_winnings() {\nlocal winning_numbers=($1)\n# यह फ़ंक्शन प्रत्येक लॉटरी टिकट के जीतने वाले नंबरों के साथ मेल खाने की संख्या की जाँच करता है\n# और प्रत्येक टिकट को जीते गए पुरस्कार के आधार पर वर्गीकृत करता है। यह प्रत्येक पुरस्कार श्रेणी के लिए टिकटों की संख्या लौटाता है।\n# फ़ंक्शन जीतने वाले नंबरों और लॉटरी टिकटों को तर्क के रूप में लेता है।\n# उदाहरण उपयोग:\n# check_lottery_winnings \"1 2 3 4 5 6 7\" \"1 8 9 10 11 12 13\" \"2 3 4 5 6 7 8\"\n# यह '0 1 0 0 0 0 0' लौटाएगा, क्योंकि दूसरा टिकट पहला पुरस्कार जीतता है।\n\n# check_lottery_winnings \"10 11 12 13 14 15 16\" \"17 18 19 20 21 22 23\" \"24 25 26 27 28 29 30\"\n# यह '0 0 0 0 0 0 0' लौटाएगा, क्योंकि कोई भी टिकट किसी भी जीतने वाले नंबरों से मेल नहीं खाता।",
      "hu": "check_lottery_winnings() {\nlocal winning_numbers=($1)\n# Ez a függvény ellenőrzi, hogy az egyes lottószelvények hány találatot értek el a nyerőszámokkal\n# és kategorizálja az egyes szelvényeket a nyert díj alapján. Visszaadja az egyes díjkategóriákba tartozó szelvények számát.\n# A függvény a nyerőszámokat és a lottószelvényeket veszi át argumentumként.\n# Példa használat:\n# check_lottery_winnings \"1 2 3 4 5 6 7\" \"1 8 9 10 11 12 13\" \"2 3 4 5 6 7 8\"\n# Ez '0 1 0 0 0 0 0' eredményt adna vissza, mivel a második szelvény első díjat nyer.\n\n# check_lottery_winnings \"10 11 12 13 14 15 16\" \"17 18 19 20 21 22 23\" \"24 25 26 27 28 29 30\"\n# Ez '0 0 0 0 0 0 0' eredményt adna vissza, mivel egyetlen szelvény sem egyezik meg a nyerőszámokkal."
    },
    "prompt_bertscore": {
      "sq": "0.9925146140907002",
      "hy": "0.9778546988184204",
      "bn": "0.9708051079651111",
      "bg": "0.9835561852756457",
      "zh": "0.971948424438348",
      "fr": "0.988550944837149",
      "de": "0.9917727296175349",
      "ha": "0.974363173980589",
      "hi": "0.973457816703832",
      "hu": "0.9794667829908995"
    },
    "canonical_solution": "shift\nlocal tickets=(\"$@\")\nlocal prizes=(0 0 0 0 0 0 0)\n\nfor ticket in \"${tickets[@]}\"; do\nlocal matches=0\nfor number in $ticket; do\nfor win_num in \"${winning_numbers[@]}\"; do\nif [[ $number -eq $win_num ]]; then\n((matches++))\nbreak\nfi\ndone\ndone\nif (( matches > 0 )); then\n((prizes[7-matches]++))\nfi\ndone\n\necho \"${prizes[@]}\"\n}",
    "instruction": {
      "en": "Write a Shell function `check_lottery_winnings() {\nlocal winning_numbers=($1)\n` to solve the following problem:\nThis function checks the number of matches each lottery ticket has with the winning numbers\nand categorizes each ticket based on the prize won. It returns the count of tickets for each prize category.\nThe function takes the winning numbers and the lottery tickets as arguments.\nExample usage:\ncheck_lottery_winnings \"1 2 3 4 5 6 7\" \"1 8 9 10 11 12 13\" \"2 3 4 5 6 7 8\"\nThis would return '0 1 0 0 0 0 0', as the second ticket wins a first prize.\n\ncheck_lottery_winnings \"10 11 12 13 14 15 16\" \"17 18 19 20 21 22 23\" \"24 25 26 27 28 29 30\"\nThis would return '0 0 0 0 0 0 0', as no tickets match any winning numbers.",
      "sq": "Shkruani një funksion Shell `check_lottery_winnings() {\nlocal winning_numbers=($1)\n` për të zgjidhur problemin e mëposhtëm:\nKy funksion kontrollon numrin e përputhjeve që ka secila biletë llotarie me numrat fitues dhe kategorizon secilën biletë bazuar në çmimin e fituar. Ai kthen numrin e biletave për secilën kategori çmimi.\nFunksioni merr si argumente numrat fitues dhe biletat e llotarisë.\nShembull përdorimi:\ncheck_lottery_winnings \"1 2 3 4 5 6 7\" \"1 8 9 10 11 12 13\" \"2 3 4 5 6 7 8\"\nKjo do të kthente '0 1 0 0 0 0 0', pasi bileta e dytë fiton një çmim të parë.\n\ncheck_lottery_winnings \"10 11 12 13 14 15 16\" \"17 18 19 20 21 22 23\" \"24 25 26 27 28 29 30\"\nKjo do të kthente '0 0 0 0 0 0 0', pasi asnjë biletë nuk përputhet me ndonjë numër fitues.",
      "hy": "Գրեք Shell ֆունկցիա `check_lottery_winnings() {\nlocal winning_numbers=($1)\n` հետևյալ խնդիրը լուծելու համար:\nԱյս ֆունկցիան ստուգում է, թե քանի համընկնում ունի յուրաքանչյուր վիճակախաղի տոմս հաղթող համարների հետ\nև դասակարգում է յուրաքանչյուր տոմսը ըստ շահած մրցանակի: Այն վերադարձնում է տոմսերի քանակը յուրաքանչյուր մրցանակային կատեգորիայի համար:\nՖունկցիան ընդունում է հաղթող համարները և վիճակախաղի տոմսերը որպես արգումենտներ:\nՕրինակ օգտագործում:\ncheck_lottery_winnings \"1 2 3 4 5 6 7\" \"1 8 9 10 11 12 13\" \"2 3 4 5 6 7 8\"\nՍա կվերադարձնի '0 1 0 0 0 0 0', քանի որ երկրորդ տոմսը շահում է առաջին մրցանակը:\n\ncheck_lottery_winnings \"10 11 12 13 14 15 16\" \"17 18 19 20 21 22 23\" \"24 25 26 27 28 29 30\"\nՍա կվերադարձնի '0 0 0 0 0 0 0', քանի որ ոչ մի տոմս չի համընկնում հաղթող համարների հետ:",
      "bn": "একটি Shell ফাংশন লিখুন `check_lottery_winnings() {\nlocal winning_numbers=($1)\n` নিম্নলিখিত সমস্যার সমাধান করতে:\nএই ফাংশনটি প্রতিটি লটারির টিকিটের সাথে বিজয়ী নম্বরগুলির মিলের সংখ্যা পরীক্ষা করে এবং প্রতিটি টিকিটকে জেতা পুরস্কারের ভিত্তিতে শ্রেণীবদ্ধ করে। এটি প্রতিটি পুরস্কার বিভাগের জন্য টিকিটের সংখ্যা ফেরত দেয়। ফাংশনটি বিজয়ী নম্বর এবং লটারির টিকিটগুলি আর্গুমেন্ট হিসাবে নেয়।\nউদাহরণ ব্যবহার:\ncheck_lottery_winnings \"1 2 3 4 5 6 7\" \"1 8 9 10 11 12 13\" \"2 3 4 5 6 7 8\"\nএটি '0 1 0 0 0 0 0' ফেরত দেবে, কারণ দ্বিতীয় টিকিট একটি প্রথম পুরস্কার জেতে।\n\ncheck_lottery_winnings \"10 11 12 13 14 15 16\" \"17 18 19 20 21 22 23\" \"24 25 26 27 28 29 30\"\nএটি '0 0 0 0 0 0 0' ফেরত দেবে, কারণ কোনো টিকিট বিজয়ী নম্বরের সাথে মেলে না।",
      "bg": "Напишете Shell функция `check_lottery_winnings() {\nlocal winning_numbers=($1)\n` за решаване на следния проблем:\nТази функция проверява броя на съвпаденията, които всеки лотариен билет има с печелившите числа и категоризира всеки билет въз основа на спечелената награда. Тя връща броя на билетите за всяка категория награди.\nФункцията приема печелившите числа и лотарийните билети като аргументи.\nПример за използване:\ncheck_lottery_winnings \"1 2 3 4 5 6 7\" \"1 8 9 10 11 12 13\" \"2 3 4 5 6 7 8\"\nТова би върнало '0 1 0 0 0 0 0', тъй като вторият билет печели първа награда.\n\ncheck_lottery_winnings \"10 11 12 13 14 15 16\" \"17 18 19 20 21 22 23\" \"24 25 26 27 28 29 30\"\nТова би върнало '0 0 0 0 0 0 0', тъй като няма билети, които да съвпадат с някое от печелившите числа.",
      "zh": "编写一个 Shell 函数 `check_lottery_winnings() {\nlocal winning_numbers=($1)\n` 来解决以下问题：\n此函数检查每张彩票与中奖号码的匹配数量，并根据所赢得的奖品对每张彩票进行分类。它返回每个奖品类别的彩票数量。\n该函数将中奖号码和彩票作为参数。\n示例用法：\ncheck_lottery_winnings \"1 2 3 4 5 6 7\" \"1 8 9 10 11 12 13\" \"2 3 4 5 6 7 8\"\n这将返回 '0 1 0 0 0 0 0'，因为第二张彩票赢得了一等奖。\n\ncheck_lottery_winnings \"10 11 12 13 14 15 16\" \"17 18 19 20 21 22 23\" \"24 25 26 27 28 29 30\"\n这将返回 '0 0 0 0 0 0 0'，因为没有彩票匹配任何中奖号码。",
      "fr": "Écrire une fonction Shell `check_lottery_winnings() {\nlocal winning_numbers=($1)\n` pour résoudre le problème suivant :\nCette fonction vérifie le nombre de correspondances que chaque billet de loterie a avec les numéros gagnants et catégorise chaque billet en fonction du prix gagné. Elle renvoie le nombre de billets pour chaque catégorie de prix.\nLa fonction prend les numéros gagnants et les billets de loterie comme arguments.\nExemple d'utilisation :\ncheck_lottery_winnings \"1 2 3 4 5 6 7\" \"1 8 9 10 11 12 13\" \"2 3 4 5 6 7 8\"\nCela retournerait '0 1 0 0 0 0 0', car le deuxième billet gagne un premier prix.\n\ncheck_lottery_winnings \"10 11 12 13 14 15 16\" \"17 18 19 20 21 22 23\" \"24 25 26 27 28 29 30\"\nCela retournerait '0 0 0 0 0 0 0', car aucun billet ne correspond à un numéro gagnant.",
      "de": "Schreiben Sie eine Shell-Funktion `check_lottery_winnings() {\nlocal winning_numbers=($1)\n`, um das folgende Problem zu lösen:\nDiese Funktion überprüft die Anzahl der Übereinstimmungen, die jedes Lotterielos mit den Gewinnzahlen hat, und kategorisiert jedes Los basierend auf dem gewonnenen Preis. Sie gibt die Anzahl der Lose für jede Preiskategorie zurück.\nDie Funktion nimmt die Gewinnzahlen und die Lotterielose als Argumente.\nBeispielverwendung:\ncheck_lottery_winnings \"1 2 3 4 5 6 7\" \"1 8 9 10 11 12 13\" \"2 3 4 5 6 7 8\"\nDies würde '0 1 0 0 0 0 0' zurückgeben, da das zweite Los einen ersten Preis gewinnt.\n\ncheck_lottery_winnings \"10 11 12 13 14 15 16\" \"17 18 19 20 21 22 23\" \"24 25 26 27 28 29 30\"\nDies würde '0 0 0 0 0 0 0' zurückgeben, da keine Lose mit den Gewinnzahlen übereinstimmen.",
      "ha": "Rubuta wani aiki na Shell `check_lottery_winnings() {\nlocal winning_numbers=($1)\n` don warware matsalar mai zuwa:\nWannan aikin yana duba yawan daidaituwa kowace tikitin caca ke da shi tare da lambobin nasara\nkuma yana rarraba kowace tikiti bisa ga kyautar da aka ci. Yana dawo da adadin tikiti don kowace rukuni na kyauta.\nAikin yana ɗaukar lambobin nasara da tikitin caca a matsayin hujjoji.\nMisalin amfani:\ncheck_lottery_winnings \"1 2 3 4 5 6 7\" \"1 8 9 10 11 12 13\" \"2 3 4 5 6 7 8\"\nWannan zai dawo da '0 1 0 0 0 0 0', domin tikitin na biyu ya ci kyautar farko.\n\ncheck_lottery_winnings \"10 11 12 13 14 15 16\" \"17 18 19 20 21 22 23\" \"24 25 26 27 28 29 30\"\nWannan zai dawo da '0 0 0 0 0 0 0', domin babu tikiti da ya dace da kowanne daga cikin lambobin nasara.",
      "hi": "शेल फ़ंक्शन `check_lottery_winnings() {\nlocal winning_numbers=($1)\n` निम्नलिखित समस्या को हल करने के लिए:\nयह फ़ंक्शन प्रत्येक लॉटरी टिकट के जीतने वाले नंबरों के साथ मेल खाने की संख्या की जाँच करता है और प्रत्येक टिकट को जीते गए पुरस्कार के आधार पर वर्गीकृत करता है। यह प्रत्येक पुरस्कार श्रेणी के लिए टिकटों की संख्या लौटाता है। फ़ंक्शन जीतने वाले नंबरों और लॉटरी टिकटों को तर्क के रूप में लेता है।\nउदाहरण उपयोग:\ncheck_lottery_winnings \"1 2 3 4 5 6 7\" \"1 8 9 10 11 12 13\" \"2 3 4 5 6 7 8\"\nयह '0 1 0 0 0 0 0' लौटाएगा, क्योंकि दूसरा टिकट पहला पुरस्कार जीतता है।\n\ncheck_lottery_winnings \"10 11 12 13 14 15 16\" \"17 18 19 20 21 22 23\" \"24 25 26 27 28 29 30\"\nयह '0 0 0 0 0 0 0' लौटाएगा, क्योंकि कोई भी टिकट किसी भी जीतने वाले नंबर से मेल नहीं खाता।",
      "hu": "Írjon egy Shell függvényt `check_lottery_winnings() {\nlocal winning_numbers=($1)\n` a következő probléma megoldására:\nEz a függvény ellenőrzi, hogy hány egyezés van minden lottószelvényen a nyerőszámokkal, és kategorizálja a szelvényeket a nyert díj alapján. Visszaadja a szelvények számát minden díjkategóriában.\nA függvény a nyerőszámokat és a lottószelvényeket veszi át argumentumként.\nPélda használat:\ncheck_lottery_winnings \"1 2 3 4 5 6 7\" \"1 8 9 10 11 12 13\" \"2 3 4 5 6 7 8\"\nEz '0 1 0 0 0 0 0'-t adna vissza, mivel a második szelvény első díjat nyer.\n\ncheck_lottery_winnings \"10 11 12 13 14 15 16\" \"17 18 19 20 21 22 23\" \"24 25 26 27 28 29 30\"\nEz '0 0 0 0 0 0 0'-t adna vissza, mivel egyetlen szelvény sem egyezik a nyerőszámokkal."
    },
    "instruction_bertscore": {
      "sq": "0.993190950538124",
      "hy": "0.9776870547768268",
      "bn": "0.9806675036442554",
      "bg": "0.9877741014169216",
      "zh": "0.9810111342034458",
      "fr": "0.9888286301098358",
      "de": "0.9894608706126699",
      "ha": "0.9815017512446019",
      "hi": "0.8921331756878609",
      "hu": "0.9801572221953767"
    },
    "level": "easy",
    "test": "test_check_lottery_winnings() {\nlocal result\nresult=$(check_lottery_winnings \"23 31 1 14 19 17 18\" \"12 8 9 23 1 16 7\" \"11 7 10 21 2 9 31\")\n[[ $result == \"0 0 0 0 0 1 1\" ]] || { echo \"Test 1 failed\"; exit 1; }\n\nresult=$(check_lottery_winnings \"5 6 7 8 9 10 11\" \"1 2 3 4 5 6 7\" \"5 6 7 12 13 14 15\")\n[[ $result == \"0 0 0 0 2 0 0\" ]] || { echo \"Test 2 failed\"; exit 1; }\n\nresult=$(check_lottery_winnings \"15 16 17 18 19 20 21\" \"22 23 24 25 26 27 28\" \"29 30 31 32 33 1 2\")\n[[ $result == \"0 0 0 0 0 0 0\" ]] || { echo \"Test 3 failed\"; exit 1; }\n}\n\ntest_check_lottery_winnings",
    "entry_point": "check_lottery_winnings",
    "signature": "check_lottery_winnings() {\nlocal winning_numbers=($1)\n",
    "docstring": {
      "en": "This function checks the number of matches each lottery ticket has with the winning numbers\nand categorizes each ticket based on the prize won. It returns the count of tickets for each prize category.\nThe function takes the winning numbers and the lottery tickets as arguments.\nExample usage:\ncheck_lottery_winnings \"1 2 3 4 5 6 7\" \"1 8 9 10 11 12 13\" \"2 3 4 5 6 7 8\"\nThis would return '0 1 0 0 0 0 0', as the second ticket wins a first prize.\n\ncheck_lottery_winnings \"10 11 12 13 14 15 16\" \"17 18 19 20 21 22 23\" \"24 25 26 27 28 29 30\"\nThis would return '0 0 0 0 0 0 0', as no tickets match any winning numbers.",
      "sq": "Kjo funksion kontrollon numrin e përputhjeve që ka secili biletë llotarie me numrat fitues dhe kategorizon secilën biletë bazuar në çmimin e fituar. Ai kthen numrin e biletave për secilën kategori çmimesh. Funksioni merr si argumente numrat fitues dhe biletat e llotarisë.\nShembull përdorimi:\ncheck_lottery_winnings \"1 2 3 4 5 6 7\" \"1 8 9 10 11 12 13\" \"2 3 4 5 6 7 8\"\nKjo do të kthente '0 1 0 0 0 0 0', pasi bileta e dytë fiton një çmim të parë.\n\ncheck_lottery_winnings \"10 11 12 13 14 15 16\" \"17 18 19 20 21 22 23\" \"24 25 26 27 28 29 30\"\nKjo do të kthente '0 0 0 0 0 0 0', pasi asnjë biletë nuk përputhet me ndonjë numër fitues.",
      "hy": "Այս ֆունկցիան ստուգում է, թե քանի համընկնում ունի յուրաքանչյուր վիճակախաղի տոմսը հաղթող համարների հետ և դասակարգում է յուրաքանչյուր տոմսը ըստ շահած մրցանակի: Այն վերադարձնում է տոմսերի քանակը յուրաքանչյուր մրցանակային կատեգորիայի համար: Ֆունկցիան ընդունում է հաղթող համարները և վիճակախաղի տոմսերը որպես արգումենտներ:\nՕգտագործման օրինակ:\ncheck_lottery_winnings \"1 2 3 4 5 6 7\" \"1 8 9 10 11 12 13\" \"2 3 4 5 6 7 8\"\nՍա կվերադարձնի '0 1 0 0 0 0 0', քանի որ երկրորդ տոմսը շահում է առաջին մրցանակը:\n\ncheck_lottery_winnings \"10 11 12 13 14 15 16\" \"17 18 19 20 21 22 23\" \"24 25 26 27 28 29 30\"\nՍա կվերադարձնի '0 0 0 0 0 0 0', քանի որ ոչ մի տոմս չի համընկնում հաղթող համարների հետ:",
      "bn": "এই ফাংশনটি প্রতিটি লটারির টিকিটের সাথে বিজয়ী নম্বরগুলির মিলের সংখ্যা পরীক্ষা করে এবং প্রতিটি টিকিটকে জেতা পুরস্কারের ভিত্তিতে শ্রেণীবদ্ধ করে। এটি প্রতিটি পুরস্কার বিভাগের জন্য টিকিটের সংখ্যা ফেরত দেয়। ফাংশনটি বিজয়ী নম্বর এবং লটারির টিকিটগুলি আর্গুমেন্ট হিসেবে গ্রহণ করে।\n\nব্যবহারের উদাহরণ:\ncheck_lottery_winnings \"1 2 3 4 5 6 7\" \"1 8 9 10 11 12 13\" \"2 3 4 5 6 7 8\"\nএটি '0 1 0 0 0 0 0' ফেরত দেবে, কারণ দ্বিতীয় টিকিটটি প্রথম পুরস্কার জেতে।\n\ncheck_lottery_winnings \"10 11 12 13 14 15 16\" \"17 18 19 20 21 22 23\" \"24 25 26 27 28 29 30\"\nএটি '0 0 0 0 0 0 0' ফেরত দেবে, কারণ কোনো টিকিটই কোনো বিজয়ী নম্বরের সাথে মেলে না।",
      "bg": "Тази функция проверява броя на съвпаденията на всеки лотариен билет с печелившите числа и категоризира всеки билет въз основа на спечелената награда. Тя връща броя на билетите за всяка категория награди. Функцията приема печелившите числа и лотарийните билети като аргументи.\nПример за използване:\ncheck_lottery_winnings \"1 2 3 4 5 6 7\" \"1 8 9 10 11 12 13\" \"2 3 4 5 6 7 8\"\nТова би върнало '0 1 0 0 0 0 0', тъй като вторият билет печели първа награда.\n\ncheck_lottery_winnings \"10 11 12 13 14 15 16\" \"17 18 19 20 21 22 23\" \"24 25 26 27 28 29 30\"\nТова би върнало '0 0 0 0 0 0 0', тъй като нито един билет не съвпада с печелившите числа.",
      "zh": "这个函数检查每张彩票与中奖号码的匹配数量，并根据赢得的奖品对每张彩票进行分类。它返回每个奖品类别的彩票数量。函数接受中奖号码和彩票作为参数。\n\n示例用法：\ncheck_lottery_winnings \"1 2 3 4 5 6 7\" \"1 8 9 10 11 12 13\" \"2 3 4 5 6 7 8\"\n这将返回 '0 1 0 0 0 0 0'，因为第二张彩票赢得了一等奖。\n\ncheck_lottery_winnings \"10 11 12 13 14 15 16\" \"17 18 19 20 21 22 23\" \"24 25 26 27 28 29 30\"\n这将返回 '0 0 0 0 0 0 0'，因为没有彩票匹配任何中奖号码。",
      "fr": "Cette fonction vérifie le nombre de correspondances que chaque billet de loterie a avec les numéros gagnants et catégorise chaque billet en fonction du prix remporté. Elle renvoie le nombre de billets pour chaque catégorie de prix. La fonction prend les numéros gagnants et les billets de loterie comme arguments.\nExemple d'utilisation :\ncheck_lottery_winnings \"1 2 3 4 5 6 7\" \"1 8 9 10 11 12 13\" \"2 3 4 5 6 7 8\"\nCela renverrait '0 1 0 0 0 0 0', car le deuxième billet remporte un premier prix.\n\ncheck_lottery_winnings \"10 11 12 13 14 15 16\" \"17 18 19 20 21 22 23\" \"24 25 26 27 28 29 30\"\nCela renverrait '0 0 0 0 0 0 0', car aucun billet ne correspond à aucun numéro gagnant.",
      "de": "Diese Funktion überprüft die Anzahl der Übereinstimmungen, die jedes Lotterielos mit den Gewinnzahlen hat, und kategorisiert jedes Los basierend auf dem gewonnenen Preis. Sie gibt die Anzahl der Lose für jede Preiskategorie zurück. Die Funktion nimmt die Gewinnzahlen und die Lotterielose als Argumente.\n\nBeispielverwendung:\ncheck_lottery_winnings \"1 2 3 4 5 6 7\" \"1 8 9 10 11 12 13\" \"2 3 4 5 6 7 8\"\nDies würde '0 1 0 0 0 0 0' zurückgeben, da das zweite Los einen ersten Preis gewinnt.\n\ncheck_lottery_winnings \"10 11 12 13 14 15 16\" \"17 18 19 20 21 22 23\" \"24 25 26 27 28 29 30\"\nDies würde '0 0 0 0 0 0 0' zurückgeben, da keine Lose mit den Gewinnzahlen übereinstimmen.",
      "ha": "Wannan aikin yana duba yawan daidaituwa da kowanne tikitin caca ke da shi tare da lambobin da suka ci nasara\nkuma yana rarraba kowanne tikiti bisa ga kyautar da aka ci. Yana dawo da adadin tikiti don kowanne rukuni na kyauta.\nAikin yana karɓar lambobin da suka ci nasara da tikitin caca a matsayin hujjoji.\nMisalin amfani:\ncheck_lottery_winnings \"1 2 3 4 5 6 7\" \"1 8 9 10 11 12 13\" \"2 3 4 5 6 7 8\"\nWannan zai dawo da '0 1 0 0 0 0 0', domin tikitin na biyu ya ci kyauta ta farko.\n\ncheck_lottery_winnings \"10 11 12 13 14 15 16\" \"17 18 19 20 21 22 23\" \"24 25 26 27 28 29 30\"\nWannan zai dawo da '0 0 0 0 0 0 0', domin babu tikiti da ya dace da kowanne daga cikin lambobin da suka ci nasara.",
      "hi": "यह फ़ंक्शन प्रत्येक लॉटरी टिकट के विजेता नंबरों के साथ मेल खाने की संख्या की जाँच करता है और प्रत्येक टिकट को जीते गए पुरस्कार के आधार पर वर्गीकृत करता है। यह प्रत्येक पुरस्कार श्रेणी के लिए टिकटों की गिनती लौटाता है। फ़ंक्शन विजेता नंबरों और लॉटरी टिकटों को तर्क के रूप में लेता है।\n\nउदाहरण उपयोग:\ncheck_lottery_winnings \"1 2 3 4 5 6 7\" \"1 8 9 10 11 12 13\" \"2 3 4 5 6 7 8\"\nयह '0 1 0 0 0 0 0' लौटाएगा, क्योंकि दूसरा टिकट पहला पुरस्कार जीतता है।\n\ncheck_lottery_winnings \"10 11 12 13 14 15 16\" \"17 18 19 20 21 22 23\" \"24 25 26 27 28 29 30\"\nयह '0 0 0 0 0 0 0' लौटाएगा, क्योंकि कोई भी टिकट किसी भी विजेता नंबर से मेल नहीं खाता।",
      "hu": "Ez a függvény ellenőrzi, hogy az egyes lottószelvények hány találatot értek el a nyerőszámokkal, és kategorizálja az egyes szelvényeket a nyert díj alapján. Visszaadja a szelvények számát az egyes díjkategóriákban. A függvény a nyerőszámokat és a lottószelvényeket veszi argumentumként.\n\nPélda használat:\ncheck_lottery_winnings \"1 2 3 4 5 6 7\" \"1 8 9 10 11 12 13\" \"2 3 4 5 6 7 8\"\nEz '0 1 0 0 0 0 0'-t adna vissza, mivel a második szelvény első díjat nyer.\n\ncheck_lottery_winnings \"10 11 12 13 14 15 16\" \"17 18 19 20 21 22 23\" \"24 25 26 27 28 29 30\"\nEz '0 0 0 0 0 0 0'-t adna vissza, mivel egyik szelvény sem egyezik a nyerőszámokkal."
    },
    "docstring_bertscore": {
      "sq": "0.9889325137991171",
      "hy": "0.9696214695245242",
      "bn": "0.9767918276495027",
      "bg": "0.9790875975935038",
      "zh": "0.9746613181825224",
      "fr": "0.9875722929497901",
      "de": "0.9932487519790052",
      "ha": "0.971111594643048",
      "hi": "0.9798263039805726",
      "hu": "0.9840662680941433"
    }
  },
  {
    "task_id": "Shell/40",
    "prompt": {
      "en": "calculate_max_pens() {\n    # This function calculates the maximum number of pens that can be bought with a given amount of money.\n    # The price of one pen is 1 Yuan and 9 Jiao (1.9 Yuan). \n    # The function takes two integers, a and b, as input where 'a' represents the Yuan and 'b' represents the Jiao part of the total money available.\n    # It returns the maximum number of pens that can be purchased.\n    # For example, if a=5 and b=0, the function will return 2, as the total money is 5 Yuan, and two pens cost 3.8 Yuan.",
      "sq": "calculate_max_pens() {\n    # Kjo funksion llogarit numrin maksimal të stilolapsave që mund të blihen me një shumë të caktuar parash.\n    # Çmimi i një stilolapsi është 1 Yuan dhe 9 Jiao (1.9 Yuan).\n    # Funksioni merr dy numra të plotë, a dhe b, si input ku 'a' përfaqëson Yuan dhe 'b' përfaqëson pjesën Jiao të totalit të parave të disponueshme.\n    # Ai kthen numrin maksimal të stilolapsave që mund të blihen.\n    # Për shembull, nëse a=5 dhe b=0, funksioni do të kthejë 2, pasi totali i parave është 5 Yuan, dhe dy stilolapsa kushtojnë 3.8 Yuan.",
      "hy": "calculate_max_pens() {\n    # Այս ֆունկցիան հաշվում է առավելագույն թվով գրիչները, որոնք կարելի է գնել տրված գումարով:\n    # Մեկ գրիչի գինը 1 յուան և 9 ջիաո է (1.9 յուան):\n    # Ֆունկցիան ընդունում է երկու ամբողջ թիվ՝ a և b, որպես մուտք, որտեղ 'a'-ն ներկայացնում է յուանների և 'b'-ն ջիաոների մասը ընդհանուր հասանելի գումարից:\n    # Այն վերադարձնում է առավելագույն թվով գրիչները, որոնք կարելի է գնել:\n    # Օրինակ, եթե a=5 և b=0, ֆունկցիան կվերադարձնի 2, քանի որ ընդհանուր գումարը 5 յուան է, և երկու գրիչի արժեքը 3.8 յուան է:",
      "bn": "calculate_max_pens() {\n    # এই ফাংশনটি একটি নির্দিষ্ট পরিমাণ টাকার সাথে সর্বাধিক সংখ্যক কলম কেনা যেতে পারে তা গণনা করে।\n    # একটি কলমের মূল্য 1 ইউয়ান এবং 9 জিয়াও (1.9 ইউয়ান)।\n    # ফাংশনটি দুটি পূর্ণসংখ্যা, a এবং b, ইনপুট হিসাবে নেয় যেখানে 'a' ইউয়ান এবং 'b' মোট উপলব্ধ টাকার জিয়াও অংশকে উপস্থাপন করে।\n    # এটি সর্বাধিক সংখ্যক কলম ফেরত দেয় যা কেনা যেতে পারে।\n    # উদাহরণস্বরূপ, যদি a=5 এবং b=0 হয়, ফাংশনটি 2 ফেরত দেবে, কারণ মোট টাকা 5 ইউয়ান, এবং দুটি কলমের মূল্য 3.8 ইউয়ান।",
      "bg": "calculate_max_pens() {\n    # Тази функция изчислява максималния брой химикалки, които могат да бъдат купени с дадена сума пари.\n    # Цената на една химикалка е 1 Юан и 9 Дзяо (1.9 Юан).\n    # Функцията приема два цели числа, a и b, като вход, където 'a' представлява частта в Юани, а 'b' представлява частта в Дзяо от общата налична сума.\n    # Връща максималния брой химикалки, които могат да бъдат закупени.\n    # Например, ако a=5 и b=0, функцията ще върне 2, тъй като общата сума е 5 Юана, а две химикалки струват 3.8 Юана.",
      "zh": "calculate_max_pens() {\n    # 此函数计算可以用给定金额购买的最大钢笔数量。\n    # 一支钢笔的价格是1元9角（1.9元）。\n    # 该函数接受两个整数a和b作为输入，其中'a'表示可用总金额的元部分，'b'表示角部分。\n    # 它返回可以购买的最大钢笔数量。\n    # 例如，如果a=5且b=0，函数将返回2，因为总金额是5元，而两支钢笔的价格是3.8元。",
      "fr": "calculate_max_pens() {\n    # Cette fonction calcule le nombre maximum de stylos qui peuvent être achetés avec une somme d'argent donnée.\n    # Le prix d'un stylo est de 1 Yuan et 9 Jiao (1,9 Yuan).\n    # La fonction prend deux entiers, a et b, en entrée où 'a' représente la partie en Yuan et 'b' représente la partie en Jiao du montant total d'argent disponible.\n    # Elle retourne le nombre maximum de stylos qui peuvent être achetés.\n    # Par exemple, si a=5 et b=0, la fonction retournera 2, car le montant total est de 5 Yuan, et deux stylos coûtent 3,8 Yuan.",
      "de": "calculate_max_pens() {\n    # Diese Funktion berechnet die maximale Anzahl an Stiften, die mit einem gegebenen Geldbetrag gekauft werden können.\n    # Der Preis für einen Stift beträgt 1 Yuan und 9 Jiao (1,9 Yuan).\n    # Die Funktion nimmt zwei ganze Zahlen, a und b, als Eingabe, wobei 'a' den Yuan- und 'b' den Jiao-Teil des insgesamt verfügbaren Geldes darstellt.\n    # Sie gibt die maximale Anzahl an Stiften zurück, die gekauft werden können.\n    # Zum Beispiel, wenn a=5 und b=0, wird die Funktion 2 zurückgeben, da das gesamte Geld 5 Yuan beträgt und zwei Stifte 3,8 Yuan kosten.",
      "ha": "calculate_max_pens() {\n    # Wannan aikin yana ƙididdige yawan alkaluma mafi girma da za a iya saya da adadin kuɗi da aka bayar.\n    # Farashin alkalami ɗaya shine 1 Yuan da 9 Jiao (1.9 Yuan).\n    # Aikin yana ɗaukar lambobi guda biyu, a da b, a matsayin shigarwa inda 'a' ke wakiltar Yuan kuma 'b' ke wakiltar ɓangaren Jiao na jimlar kuɗin da ake da shi.\n    # Yana mayar da yawan alkaluma mafi girma da za a iya saya.\n    # Alal misali, idan a=5 da b=0, aikin zai dawo da 2, domin jimlar kuɗin shine 5 Yuan, kuma alkaluma biyu suna kashe 3.8 Yuan.",
      "hi": "calculate_max_pens() {\n    # यह फ़ंक्शन गणना करता है कि दिए गए धनराशि से अधिकतम कितने पेन खरीदे जा सकते हैं।\n    # एक पेन की कीमत 1 युआन और 9 जिआओ (1.9 युआन) है।\n    # फ़ंक्शन दो पूर्णांक, a और b, को इनपुट के रूप में लेता है जहाँ 'a' कुल उपलब्ध धनराशि के युआन को दर्शाता है और 'b' जिआओ भाग को।\n    # यह अधिकतम पेन की संख्या लौटाता है जो खरीदे जा सकते हैं।\n    # उदाहरण के लिए, यदि a=5 और b=0 है, तो फ़ंक्शन 2 लौटाएगा, क्योंकि कुल धनराशि 5 युआन है, और दो पेन की कीमत 3.8 युआन है।",
      "hu": "calculate_max_pens() {\n    # Ez a függvény kiszámítja, hogy egy adott pénzösszegből hány tollat lehet vásárolni.\n    # Egy toll ára 1 Yuan és 9 Jiao (1,9 Yuan).\n    # A függvény két egész számot vesz be bemenetként, ahol 'a' a Yuan és 'b' a Jiao részt jelöli a rendelkezésre álló összegből.\n    # Visszaadja a megvásárolható tollak maximális számát.\n    # Például, ha a=5 és b=0, a függvény 2-t ad vissza, mivel az összes pénz 5 Yuan, és két toll ára 3,8 Yuan."
    },
    "prompt_bertscore": {
      "sq": "0.9895562131955666",
      "hy": "0.9724539387580817",
      "bn": "0.9759903540620268",
      "bg": "0.9784486036577146",
      "zh": "0.9590587031218509",
      "fr": "0.9748557773255556",
      "de": "0.9954656656617356",
      "ha": "0.9907452146564415",
      "hi": "0.9669610142009429",
      "hu": "0.9611631920089155"
    },
    "canonical_solution": "    local yuan=$1\n    local jiao=$2\n    # Convert everything to jiao for simplicity\n    local total_jiao=$((yuan * 10 + jiao))\n    local price_per_pen=19  # 1 yuan 9 jiao equals 19 jiao\n    # Calculate max pens\n    local max_pens=$((total_jiao / price_per_pen))\n    echo \"$max_pens\"\n}",
    "instruction": {
      "en": "Write a Shell function `calculate_max_pens() {` to solve the following problem: This function calculates the maximum number of pens that can be bought with a given amount of money.\n The price of one pen is 1 Yuan and 9 Jiao (1.9 Yuan). \n The function takes two integers, a and b, as input where 'a' represents the Yuan and 'b' represents the Jiao part of the total money available.\n It returns the maximum number of pens that can be purchased.\n For example, if a=5 and b=0, the function will return 2, as the total money is 5 Yuan, and two pens cost 3.8 Yuan.",
      "sq": "Shkruani një funksion Shell `calculate_max_pens() {` për të zgjidhur problemin e mëposhtëm: Ky funksion llogarit numrin maksimal të stilolapsave që mund të blihen me një shumë të caktuar parash.\n Çmimi i një stilolapsi është 1 Yuan dhe 9 Jiao (1.9 Yuan).\n Funksioni merr dy numra të plotë, a dhe b, si hyrje ku 'a' përfaqëson Yuan dhe 'b' përfaqëson pjesën Jiao të shumës totale të parave të disponueshme.\n Ai kthen numrin maksimal të stilolapsave që mund të blihen.\n Për shembull, nëse a=5 dhe b=0, funksioni do të kthejë 2, pasi shuma totale e parave është 5 Yuan, dhe dy stilolapsa kushtojnë 3.8 Yuan.",
      "hy": "Գրեք Shell ֆունկցիա `calculate_max_pens() {` հետևյալ խնդիրը լուծելու համար: Այս ֆունկցիան հաշվում է առավելագույն գրիչների քանակը, որը կարելի է գնել տրված գումարով:\n Մեկ գրիչի գինը 1 յուան և 9 ջիաո է (1.9 յուան):\n Ֆունկցիան ընդունում է երկու ամբողջ թիվ՝ a և b, որպես մուտք, որտեղ 'a'-ն ներկայացնում է յուանների և 'b'-ն՝ ջիաոների մասը ընդհանուր հասանելի գումարի:\n Այն վերադարձնում է առավելագույն գրիչների քանակը, որը կարելի է գնել:\n Օրինակ, եթե a=5 և b=0, ֆունկցիան կվերադարձնի 2, քանի որ ընդհանուր գումարը 5 յուան է, և երկու գրիչների արժեքը 3.8 յուան է:",
      "bn": "একটি Shell ফাংশন `calculate_max_pens() {` লিখুন নিম্নলিখিত সমস্যার সমাধানের জন্য: এই ফাংশনটি একটি নির্দিষ্ট পরিমাণ অর্থ দিয়ে সর্বাধিক সংখ্যক কলম কেনা যেতে পারে তা গণনা করে।\nএকটি কলমের দাম হল 1 ইউয়ান এবং 9 জিয়াও (1.9 ইউয়ান)।\nফাংশনটি দুটি পূর্ণসংখ্যা, a এবং b, ইনপুট হিসাবে নেয় যেখানে 'a' মোট উপলব্ধ অর্থের ইউয়ান অংশ এবং 'b' জিয়াও অংশকে উপস্থাপন করে।\nএটি সর্বাধিক সংখ্যক কলম ফেরত দেয় যা কেনা যেতে পারে।\nউদাহরণস্বরূপ, যদি a=5 এবং b=0 হয়, তাহলে ফাংশনটি 2 ফেরত দেবে, কারণ মোট অর্থ হল 5 ইউয়ান, এবং দুটি কলমের দাম 3.8 ইউয়ান।",
      "bg": "Напишете Shell функция `calculate_max_pens() {`, за да решите следния проблем: Тази функция изчислява максималния брой химикалки, които могат да бъдат закупени с дадена сума пари.\n Цената на една химикалка е 1 Юан и 9 Дзяо (1.9 Юана).\n Функцията приема два цели числа, a и b, като вход, където 'a' представлява Юаните, а 'b' представлява Дзяо частта от общата налична сума пари.\n Тя връща максималния брой химикалки, които могат да бъдат закупени.\n Например, ако a=5 и b=0, функцията ще върне 2, тъй като общата сума е 5 Юана, а две химикалки струват 3.8 Юана.",
      "zh": "编写一个 Shell 函数 `calculate_max_pens() {` 来解决以下问题：此函数计算在给定金额下可以购买的最大数量的笔。  \n一支笔的价格是 1 元 9 角（1.9 元）。  \n该函数接收两个整数 a 和 b 作为输入，其中 'a' 表示可用总金额中的元部分，'b' 表示角部分。  \n它返回可以购买的最大笔数。  \n例如，如果 a=5 且 b=0，函数将返回 2，因为总金额是 5 元，而两支笔的价格是 3.8 元。",
      "fr": "Écrire une fonction Shell `calculate_max_pens() {` pour résoudre le problème suivant : Cette fonction calcule le nombre maximum de stylos qui peuvent être achetés avec un montant donné d'argent.\n Le prix d'un stylo est de 1 Yuan et 9 Jiao (1,9 Yuan).\n La fonction prend deux entiers, a et b, en entrée où 'a' représente la partie en Yuan et 'b' représente la partie en Jiao du montant total d'argent disponible.\n Elle renvoie le nombre maximum de stylos qui peuvent être achetés.\n Par exemple, si a=5 et b=0, la fonction renverra 2, car le montant total est de 5 Yuan, et deux stylos coûtent 3,8 Yuan.",
      "de": "Schreiben Sie eine Shell-Funktion `calculate_max_pens() {`, um das folgende Problem zu lösen: Diese Funktion berechnet die maximale Anzahl an Stiften, die mit einem gegebenen Geldbetrag gekauft werden können.\n Der Preis eines Stiftes beträgt 1 Yuan und 9 Jiao (1,9 Yuan).\n Die Funktion nimmt zwei ganze Zahlen, a und b, als Eingabe, wobei 'a' den Yuan und 'b' den Jiao-Teil des insgesamt verfügbaren Geldes darstellt.\n Sie gibt die maximale Anzahl an Stiften zurück, die gekauft werden können.\n Zum Beispiel, wenn a=5 und b=0, wird die Funktion 2 zurückgeben, da das gesamte Geld 5 Yuan beträgt und zwei Stifte 3,8 Yuan kosten.",
      "ha": "Rubuta aikin Shell `calculate_max_pens() {` don warware matsalar mai zuwa: Wannan aikin yana ƙididdige adadin alkaluma mafi yawa da za a iya saya da wani adadin kuɗi da aka bayar.\n Farashin alkalami guda ɗaya shine 1 Yuan da 9 Jiao (1.9 Yuan).\n Aikin yana ɗaukar lambobi guda biyu, a da b, azaman shigarwa inda 'a' ke wakiltar Yuan kuma 'b' ke wakiltar ɓangaren Jiao na jimlar kuɗin da ake da shi.\n Yana mayar da adadin alkaluma mafi yawa da za a iya saya.\n Alal misali, idan a=5 da b=0, aikin zai mayar da 2, domin jimlar kuɗin shine 5 Yuan, kuma alkaluma biyu suna kashe 3.8 Yuan.",
      "hi": "Write a Shell function `calculate_max_pens() {` निम्नलिखित समस्या को हल करने के लिए: यह फ़ंक्शन दिए गए धनराशि के साथ खरीदे जा सकने वाले अधिकतम पेन की संख्या की गणना करता है। \n एक पेन की कीमत 1 युआन और 9 जिआओ (1.9 युआन) है। \n फ़ंक्शन दो पूर्णांक, a और b, को इनपुट के रूप में लेता है जहाँ 'a' कुल उपलब्ध धनराशि के युआन को दर्शाता है और 'b' जिआओ भाग को दर्शाता है।\n यह खरीदे जा सकने वाले पेन की अधिकतम संख्या लौटाता है।\n उदाहरण के लिए, यदि a=5 और b=0, तो फ़ंक्शन 2 लौटाएगा, क्योंकि कुल धनराशि 5 युआन है, और दो पेन की कीमत 3.8 युआन है।",
      "hu": "Írj egy Shell függvényt `calculate_max_pens() {` a következő probléma megoldására: Ez a függvény kiszámítja, hogy a rendelkezésre álló pénzösszegből hány toll vásárolható meg maximálisan.\n Egy toll ára 1 Yuan és 9 Jiao (1,9 Yuan).\n A függvény két egész számot vesz fel bemenetként, ahol 'a' a Yuan-t, 'b' pedig a Jiao-t jelenti a rendelkezésre álló összegből.\n Visszaadja a maximálisan megvásárolható tollak számát.\n Például, ha a=5 és b=0, a függvény 2-t ad vissza, mivel az összes pénz 5 Yuan, és két toll ára 3,8 Yuan."
    },
    "instruction_bertscore": {
      "sq": "0.9882168485362484",
      "hy": "0.9754155177393119",
      "bn": "0.9695302981796292",
      "bg": "0.986899730479606",
      "zh": "0.9578591742507813",
      "fr": "0.9820507656177824",
      "de": "0.9916904966397865",
      "ha": "0.9906081596935273",
      "hi": "0.9670398704622137",
      "hu": "0.9590505592762285"
    },
    "level": "easy",
    "test": "test_calculate_max_pens() {\n    local result\n\n    result=$(calculate_max_pens 5 5)\n    [[ \"$result\" -eq 2 ]] || { echo \"Test 1 failed: Expected 2, got $result\"; exit 1; }\n\n    result=$(calculate_max_pens 20 1)\n    [[ \"$result\" -eq 10 ]] || { echo \"Test 2 failed: Expected 10, got $result\"; exit 1; }\n\n    result=$(calculate_max_pens 3 8)\n    [[ \"$result\" -eq 2 ]] || { echo \"Test 3 failed: Expected 1, got $result\"; exit 1; }\n\n    result=$(calculate_max_pens 11 0)\n    [[ \"$result\" -eq 5 ]] || { echo \"Test 4 failed: Expected 5, got $result\"; exit 1; }\n\n    result=$(calculate_max_pens 100 5)\n    [[ \"$result\" -eq 52 ]] || { echo \"Test 5 failed: Expected 52, got $result\"; exit 1; }\n}\n\ntest_calculate_max_pens",
    "entry_point": "calculate_max_pens",
    "signature": "calculate_max_pens() {",
    "docstring": {
      "en": " This function calculates the maximum number of pens that can be bought with a given amount of money.\n The price of one pen is 1 Yuan and 9 Jiao (1.9 Yuan). \n The function takes two integers, a and b, as input where 'a' represents the Yuan and 'b' represents the Jiao part of the total money available.\n It returns the maximum number of pens that can be purchased.\n For example, if a=5 and b=0, the function will return 2, as the total money is 5 Yuan, and two pens cost 3.8 Yuan.",
      "sq": "Kjo funksion llogarit numrin maksimal të stilolapsave që mund të blihen me një shumë të caktuar parash. \nÇmimi i një stilolapsi është 1 Yuan dhe 9 Jiao (1.9 Yuan). \nFunksioni merr dy numra të plotë, a dhe b, si hyrje ku 'a' përfaqëson pjesën Yuan dhe 'b' përfaqëson pjesën Jiao të shumës totale të parave të disponueshme. \nKthen numrin maksimal të stilolapsave që mund të blihen. \nPër shembull, nëse a=5 dhe b=0, funksioni do të kthejë 2, pasi shuma totale e parave është 5 Yuan, dhe dy stilolapsa kushtojnë 3.8 Yuan.",
      "hy": "Այս ֆունկցիան հաշվում է առավելագույն գրիչների քանակը, որոնք կարելի է գնել տրված գումարով:\nՄեկ գրիչի գինը 1 յուան և 9 ջիաո է (1.9 յուան):\nՖունկցիան ընդունում է երկու ամբողջ թիվ՝ a և b, որպես մուտք, որտեղ 'a'-ն ներկայացնում է յուանների և 'b'-ն՝ ջիաոների մասը ընդհանուր հասանելի գումարի:\nԱյն վերադարձնում է առավելագույն գրիչների քանակը, որոնք կարելի է գնել:\nՕրինակ, եթե a=5 և b=0, ֆունկցիան կվերադարձնի 2, քանի որ ընդհանուր գումարը 5 յուան է, և երկու գրիչների գինը 3.8 յուան է:",
      "bn": " This function calculates the maximum number of pens that can be bought with a given amount of money.\n এই ফাংশনটি একটি নির্দিষ্ট পরিমাণ অর্থ দিয়ে সর্বাধিক সংখ্যক কলম কেনা যেতে পারে তা গণনা করে।\n The price of one pen is 1 Yuan and 9 Jiao (1.9 Yuan).\n একটি কলমের দাম ১ ইউয়ান এবং ৯ জিয়াও (১.৯ ইউয়ান)।\n The function takes two integers, a and b, as input where 'a' represents the Yuan and 'b' represents the Jiao part of the total money available.\n ফাংশনটি দুটি পূর্ণসংখ্যা, a এবং b, ইনপুট হিসাবে গ্রহণ করে যেখানে 'a' মোট উপলব্ধ অর্থের ইউয়ান অংশ এবং 'b' জিয়াও অংশকে উপস্থাপন করে।\n It returns the maximum number of pens that can be purchased.\n এটি সর্বাধিক সংখ্যক কলম ফেরত দেয় যা কেনা যেতে পারে।\n For example, if a=5 and b=0, the function will return 2, as the total money is 5 Yuan, and two pens cost 3.8 Yuan.\n উদাহরণস্বরূপ, যদি a=5 এবং b=0 হয়, ফাংশনটি ২ ফেরত দেবে, কারণ মোট অর্থ ৫ ইউয়ান, এবং দুটি কলমের দাম ৩.৮ ইউয়ান।",
      "bg": "Тази функция изчислява максималния брой химикалки, които могат да бъдат купени с дадена сума пари.\nЦената на една химикалка е 1 юан и 9 цзяо (1.9 юана).\nФункцията приема два цели числа, a и b, като вход, където 'a' представлява юаните, а 'b' представлява цзяо частта от общата налична сума.\nТя връща максималния брой химикалки, които могат да бъдат закупени.\nНапример, ако a=5 и b=0, функцията ще върне 2, тъй като общата сума е 5 юана, а две химикалки струват 3.8 юана.",
      "zh": " This function calculates the maximum number of pens that can be bought with a given amount of money.  \n此函数计算可以用给定金额购买的最多钢笔数量。\n The price of one pen is 1 Yuan and 9 Jiao (1.9 Yuan).  \n一支钢笔的价格是1元9角（1.9元）。\n The function takes two integers, a and b, as input where 'a' represents the Yuan and 'b' represents the Jiao part of the total money available.  \n函数接收两个整数a和b作为输入，其中'a'表示元，'b'表示可用总金额中的角部分。\n It returns the maximum number of pens that can be purchased.  \n它返回可以购买的最多钢笔数量。\n For example, if a=5 and b=0, the function will return 2, as the total money is 5 Yuan, and two pens cost 3.8 Yuan.  \n例如，如果a=5且b=0，函数将返回2，因为总金额是5元，而两支钢笔的价格是3.8元。",
      "fr": "Cette fonction calcule le nombre maximum de stylos qui peuvent être achetés avec un montant d'argent donné.  \nLe prix d'un stylo est de 1 Yuan et 9 Jiao (1,9 Yuan).  \nLa fonction prend deux entiers, a et b, en entrée où 'a' représente la partie en Yuan et 'b' représente la partie en Jiao du montant total d'argent disponible.  \nElle renvoie le nombre maximum de stylos qui peuvent être achetés.  \nPar exemple, si a=5 et b=0, la fonction renverra 2, car le montant total est de 5 Yuan, et deux stylos coûtent 3,8 Yuan.",
      "de": " This function calculates the maximum number of pens that can be bought with a given amount of money.\n Die Preis eines Stiftes beträgt 1 Yuan und 9 Jiao (1,9 Yuan).\n Die Funktion nimmt zwei ganze Zahlen, a und b, als Eingabe, wobei 'a' den Yuan- und 'b' den Jiao-Teil des insgesamt verfügbaren Geldes darstellt.\n Sie gibt die maximale Anzahl an Stiften zurück, die gekauft werden können.\n Zum Beispiel, wenn a=5 und b=0, wird die Funktion 2 zurückgeben, da das gesamte Geld 5 Yuan beträgt und zwei Stifte 3,8 Yuan kosten.",
      "ha": "Wannan aikin yana ƙididdige yawan alkaluma mafi yawa da za a iya saya da wani adadin kuɗi da aka bayar.\n Farashin alkalami ɗaya shine 1 Yuan da 9 Jiao (1.9 Yuan).\n Aikin yana ɗaukar lambobi guda biyu, a da b, a matsayin shigarwa inda 'a' ke wakiltar Yuan kuma 'b' ke wakiltar ɓangaren Jiao na jimlar kuɗin da ake da shi.\n Yana mayar da yawan alkaluma mafi yawa da za a iya saya.\n Alal misali, idan a=5 da b=0, aikin zai dawo da 2, saboda jimlar kuɗin shine 5 Yuan, kuma alkaluma biyu suna kashe 3.8 Yuan.",
      "hi": " This function calculates the maximum number of pens that can be bought with a given amount of money.\n यह फ़ंक्शन दिए गए पैसे की राशि के साथ खरीदे जा सकने वाले पेन की अधिकतम संख्या की गणना करता है।\n The price of one pen is 1 Yuan and 9 Jiao (1.9 Yuan). \n एक पेन की कीमत 1 युआन और 9 जिआओ (1.9 युआन) है।\n The function takes two integers, a and b, as input where 'a' represents the Yuan and 'b' represents the Jiao part of the total money available.\n फ़ंक्शन दो पूर्णांक, a और b, को इनपुट के रूप में लेता है जहाँ 'a' कुल उपलब्ध पैसे के युआन भाग का प्रतिनिधित्व करता है और 'b' जिआओ भाग का।\n It returns the maximum number of pens that can be purchased.\n यह खरीदे जा सकने वाले पेन की अधिकतम संख्या लौटाता है।\n For example, if a=5 and b=0, the function will return 2, as the total money is 5 Yuan, and two pens cost 3.8 Yuan.\n उदाहरण के लिए, यदि a=5 और b=0, तो फ़ंक्शन 2 लौटाएगा, क्योंकि कुल पैसे 5 युआन हैं, और दो पेन की कीमत 3.8 युआन है।",
      "hu": "Ez a függvény kiszámítja, hogy a rendelkezésre álló pénzösszegből hány tollat lehet maximálisan megvásárolni.  \nEgy toll ára 1 jüan és 9 jiao (1,9 jüan).  \nA függvény két egész számot vesz be, 'a' és 'b', ahol 'a' a jüan, 'b' pedig a jiao részét jelenti a rendelkezésre álló összes pénznek.  \nVisszaadja a megvásárolható tollak maximális számát.  \nPéldául, ha a=5 és b=0, a függvény 2-t ad vissza, mivel az összes pénz 5 jüan, és két toll 3,8 jüanba kerül."
    },
    "docstring_bertscore": {
      "sq": "0.9718598352884064",
      "hy": "0.9654317588973553",
      "bn": "0.999999801369619",
      "bg": "0.9766076972862833",
      "zh": "0.999999801369619",
      "fr": "0.9795142556519668",
      "de": "0.9860209896739077",
      "ha": "0.9822950809864552",
      "hi": "0.999999801369619",
      "hu": "0.9510749535865346"
    }
  },
  {
    "task_id": "Shell/41",
    "prompt": {
      "en": "calculate_expression() {\n    # Calculate the value of the expression (a+b)*c with given integers a, b, and c.\n    # Args:\n    #     a (int): The first integer.\n    #     b (int): The second integer.\n    #     c (int): The third integer.\n    #\n    # Returns:\n    #     The result of the expression (a+b)*c.\n    #\n    # Examples:\n    # >>> calculate_expression 1 2 3\n    # 9\n    # >>> calculate_expression -1 2 -3\n    # -3",
      "sq": "calculate_expression() {\n    # Llogarit vlerën e shprehjes (a+b)*c me numrat e dhënë të plotë a, b, dhe c.\n    # Argumentet:\n    #     a (int): Numri i parë i plotë.\n    #     b (int): Numri i dytë i plotë.\n    #     c (int): Numri i tretë i plotë.\n    #\n    # Kthen:\n    #     Rezultatin e shprehjes (a+b)*c.\n    #\n    # Shembuj:\n    # >>> calculate_expression 1 2 3\n    # 9\n    # >>> calculate_expression -1 2 -3\n    # -3",
      "hy": "calculate_expression() {\n    # Հաշվել արտահայտության (a+b)*c արժեքը տրված ամբողջ թվերով a, b և c:\n    # Արգումենտներ:\n    #     a (int): Առաջին ամբողջ թիվը:\n    #     b (int): Երկրորդ ամբողջ թիվը:\n    #     c (int): Երրորդ ամբողջ թիվը:\n    #\n    # Վերադարձնում է:\n    #     Արտահայտության (a+b)*c արդյունքը:\n    #\n    # Օրինակներ:\n    # >>> calculate_expression 1 2 3\n    # 9\n    # >>> calculate_expression -1 2 -3\n    # -3",
      "bn": "calculate_expression() {\n    # প্রদত্ত পূর্ণসংখ্যা a, b, এবং c এর সাথে অভিব্যক্তি (a+b)*c এর মান গণনা করুন।\n    # Args:\n    #     a (int): প্রথম পূর্ণসংখ্যা।\n    #     b (int): দ্বিতীয় পূর্ণসংখ্যা।\n    #     c (int): তৃতীয় পূর্ণসংখ্যা।\n    #\n    # Returns:\n    #     অভিব্যক্তি (a+b)*c এর ফলাফল।\n    #\n    # Examples:\n    # >>> calculate_expression 1 2 3\n    # 9\n    # >>> calculate_expression -1 2 -3\n    # -3",
      "bg": "calculate_expression() {\n    # Изчислява стойността на израза (a+b)*c с дадени цели числа a, b и c.\n    # Аргументи:\n    #     a (int): Първото цяло число.\n    #     b (int): Второто цяло число.\n    #     c (int): Третото цяло число.\n    #\n    # Връща:\n    #     Резултатът от израза (a+b)*c.\n    #\n    # Примери:\n    # >>> calculate_expression 1 2 3\n    # 9\n    # >>> calculate_expression -1 2 -3\n    # -3",
      "zh": "calculate_expression() {\n    # 计算表达式 (a+b)*c 的值，给定整数 a, b 和 c。\n    # 参数:\n    #     a (int): 第一个整数。\n    #     b (int): 第二个整数。\n    #     c (int): 第三个整数。\n    #\n    # 返回:\n    #     表达式 (a+b)*c 的结果。\n    #\n    # 示例:\n    # >>> calculate_expression 1 2 3\n    # 9\n    # >>> calculate_expression -1 2 -3\n    # -3",
      "fr": "calculate_expression() {\n    # Calculez la valeur de l'expression (a+b)*c avec les entiers donnés a, b et c.\n    # Args:\n    #     a (int): Le premier entier.\n    #     b (int): Le deuxième entier.\n    #     c (int): Le troisième entier.\n    #\n    # Retourne:\n    #     Le résultat de l'expression (a+b)*c.\n    #\n    # Exemples:\n    # >>> calculate_expression 1 2 3\n    # 9\n    # >>> calculate_expression -1 2 -3\n    # -3",
      "de": "calculate_expression() {\n    # Berechne den Wert des Ausdrucks (a+b)*c mit gegebenen ganzen Zahlen a, b und c.\n    # Argumente:\n    #     a (int): Die erste ganze Zahl.\n    #     b (int): Die zweite ganze Zahl.\n    #     c (int): Die dritte ganze Zahl.\n    #\n    # Rückgabewert:\n    #     Das Ergebnis des Ausdrucks (a+b)*c.\n    #\n    # Beispiele:\n    # >>> calculate_expression 1 2 3\n    # 9\n    # >>> calculate_expression -1 2 -3\n    # -3",
      "ha": "calculate_expression() {\n    # Lissafi darajar bayyana (a+b)*c tare da lambobin a, b, da c da aka bayar.\n    # Args:\n    #     a (int): Lamba ta farko.\n    #     b (int): Lamba ta biyu.\n    #     c (int): Lamba ta uku.\n    #\n    # Returns:\n    #     Sakamakon bayyana (a+b)*c.\n    #\n    # Misalai:\n    # >>> calculate_expression 1 2 3\n    # 9\n    # >>> calculate_expression -1 2 -3\n    # -3",
      "hi": "calculate_expression() {\n    # दिए गए पूर्णांक a, b, और c के साथ अभिव्यक्ति (a+b)*c का मान गणना करें।\n    # तर्क:\n    #     a (int): पहला पूर्णांक।\n    #     b (int): दूसरा पूर्णांक।\n    #     c (int): तीसरा पूर्णांक।\n    #\n    # वापसी:\n    #     अभिव्यक्ति (a+b)*c का परिणाम।\n    #\n    # उदाहरण:\n    # >>> calculate_expression 1 2 3\n    # 9\n    # >>> calculate_expression -1 2 -3\n    # -3",
      "hu": "calculate_expression() {\n    # Számítsa ki a (a+b)*c kifejezés értékét a megadott a, b és c egész számokkal.\n    # Argumentumok:\n    #     a (int): Az első egész szám.\n    #     b (int): A második egész szám.\n    #     c (int): A harmadik egész szám.\n    #\n    # Visszatér:\n    #     A (a+b)*c kifejezés eredménye.\n    #\n    # Példák:\n    # >>> calculate_expression 1 2 3\n    # 9\n    # >>> calculate_expression -1 2 -3\n    # -3"
    },
    "prompt_bertscore": {
      "sq": "0.9804337156857773",
      "hy": "0.984024357083745",
      "bn": "0.995986474520809",
      "bg": "0.9900225973302366",
      "zh": "0.9812167166478168",
      "fr": "0.995986474520809",
      "de": "0.986159236419108",
      "ha": "0.9763194846034017",
      "hi": "0.9676818438537185",
      "hu": "0.9869670661787768"
    },
    "canonical_solution": "    local a=$1\n    local b=$2\n    local c=$3\n\n    # Calculate (a+b)*c\n    local result=$(( (a + b) * c ))\n    echo \"$result\"\n}",
    "instruction": {
      "en": "Write a Shell function `calculate_expression() {` to solve the following problem: Calculate the value of the expression (a+b)*c with given integers a, b, and c.\n Args:\n a (int): The first integer.\n b (int): The second integer.\n c (int): The third integer.\n\n Returns:\n The result of the expression (a+b)*c.\n\n Examples:\n >>> calculate_expression 1 2 3\n 9\n >>> calculate_expression -1 2 -3\n -3",
      "sq": "Shkruani një funksion Shell `calculate_expression() {` për të zgjidhur problemin e mëposhtëm: Llogaritni vlerën e shprehjes (a+b)*c me numrat e dhënë të plotë a, b, dhe c.\n Args:\n a (int): Numri i parë i plotë.\n b (int): Numri i dytë i plotë.\n c (int): Numri i tretë i plotë.\n\n Kthen:\n Rezultatin e shprehjes (a+b)*c.\n\n Shembuj:\n >>> calculate_expression 1 2 3\n 9\n >>> calculate_expression -1 2 -3\n -3",
      "hy": "Գրեք Shell ֆունկցիա `calculate_expression() {` հետևյալ խնդիրը լուծելու համար: Հաշվեք արտահայտության (a+b)*c արժեքը տրված ամբողջ թվերի a, b և c համար:\n Արձանագրություններ:\n a (int): Առաջին ամբողջ թիվը:\n b (int): Երկրորդ ամբողջ թիվը:\n c (int): Երրորդ ամբողջ թիվը:\n\n Վերադարձնում է:\n Արտահայտության (a+b)*c արդյունքը:\n\n Օրինակներ:\n >>> calculate_expression 1 2 3\n 9\n >>> calculate_expression -1 2 -3\n -3",
      "bn": "একটি Shell ফাংশন `calculate_expression() {` লিখুন নিম্নলিখিত সমস্যার সমাধানের জন্য: প্রদত্ত পূর্ণসংখ্যা a, b, এবং c এর সাথে অভিব্যক্তি (a+b)*c এর মান গণনা করুন।\n Args:\n a (int): প্রথম পূর্ণসংখ্যা।\n b (int): দ্বিতীয় পূর্ণসংখ্যা।\n c (int): তৃতীয় পূর্ণসংখ্যা।\n\n Returns:\n অভিব্যক্তি (a+b)*c এর ফলাফল।\n\n Examples:\n >>> calculate_expression 1 2 3\n 9\n >>> calculate_expression -1 2 -3\n -3",
      "bg": "Напишете Shell функция `calculate_expression() {`, за да решите следния проблем: Изчислете стойността на израза (a+b)*c с дадени цели числа a, b и c.\n Args:\n a (int): Първото цяло число.\n b (int): Второто цяло число.\n c (int): Третото цяло число.\n\n Returns:\n Резултатът от израза (a+b)*c.\n\n Примери:\n >>> calculate_expression 1 2 3\n 9\n >>> calculate_expression -1 2 -3\n -3",
      "zh": "编写一个 Shell 函数 `calculate_expression() {` 来解决以下问题：计算表达式 (a+b)*c 的值，给定整数 a、b 和 c。\n 参数:\n a (int): 第一个整数。\n b (int): 第二个整数。\n c (int): 第三个整数。\n\n 返回:\n 表达式 (a+b)*c 的结果。\n\n 示例:\n >>> calculate_expression 1 2 3\n 9\n >>> calculate_expression -1 2 -3\n -3",
      "fr": "Écrire une fonction Shell `calculate_expression() {` pour résoudre le problème suivant : Calculer la valeur de l'expression (a+b)*c avec les entiers donnés a, b, et c.\n Args:\n a (int) : Le premier entier.\n b (int) : Le deuxième entier.\n c (int) : Le troisième entier.\n\n Returns:\n Le résultat de l'expression (a+b)*c.\n\n Exemples :\n >>> calculate_expression 1 2 3\n 9\n >>> calculate_expression -1 2 -3\n -3",
      "de": "Schreiben Sie eine Shell-Funktion `calculate_expression() {`, um das folgende Problem zu lösen: Berechnen Sie den Wert des Ausdrucks (a+b)*c mit gegebenen ganzen Zahlen a, b und c.\n Args:\n a (int): Die erste ganze Zahl.\n b (int): Die zweite ganze Zahl.\n c (int): Die dritte ganze Zahl.\n\n Rückgabe:\n Das Ergebnis des Ausdrucks (a+b)*c.\n\n Beispiele:\n >>> calculate_expression 1 2 3\n 9\n >>> calculate_expression -1 2 -3\n -3",
      "ha": "Rubuta aikin Shell `calculate_expression() {` don warware matsalar mai zuwa: Lissafa darajar bayanin (a+b)*c tare da lambobin cikakku a, b, da c da aka bayar.\n Args:\n a (int): Lamba ta farko.\n b (int): Lamba ta biyu.\n c (int): Lamba ta uku.\n\n Returns:\n Sakamakon bayanin (a+b)*c.\n\n Misalai:\n >>> calculate_expression 1 2 3\n 9\n >>> calculate_expression -1 2 -3\n -3",
      "hi": "शेल फ़ंक्शन `calculate_expression() {` लिखें ताकि निम्नलिखित समस्या का समाधान किया जा सके: दिए गए पूर्णांक a, b, और c के साथ अभिव्यक्ति (a+b)*c का मान गणना करें।\n \nआर्ग्स:\na (int): पहला पूर्णांक।\nb (int): दूसरा पूर्णांक।\nc (int): तीसरा पूर्णांक।\n\nवापसी:\nअभिव्यक्ति (a+b)*c का परिणाम।\n\nउदाहरण:\n>>> calculate_expression 1 2 3\n9\n>>> calculate_expression -1 2 -3\n-3",
      "hu": "Írj egy Shell függvényt `calculate_expression() {` a következő probléma megoldására: Számítsd ki a (a+b)*c kifejezés értékét a megadott a, b és c egész számokkal.\n Args:\n a (int): Az első egész szám.\n b (int): A második egész szám.\n c (int): A harmadik egész szám.\n\n Visszatér:\n A (a+b)*c kifejezés eredménye.\n\n Példák:\n >>> calculate_expression 1 2 3\n 9\n >>> calculate_expression -1 2 -3\n -3"
    },
    "instruction_bertscore": {
      "sq": "0.987127956787415",
      "hy": "0.9854497286980514",
      "bn": "1",
      "bg": "0.9966433451908914",
      "zh": "0.9847112209413637",
      "fr": "0.9749554897768351",
      "de": "0.9941916503977778",
      "ha": "0.9832862465878194",
      "hi": "0.9795462351433134",
      "hu": "0.9963537420953426"
    },
    "level": "easy",
    "test": "test_calculate_expression() {\n    local result\n\n    result=$(calculate_expression 1 2 3)\n    [[ \"$result\" -eq 9 ]] || { echo \"Test 1 failed: Expected 9, got $result\"; exit 1; }\n\n    result=$(calculate_expression -1 2 -3)\n    [[ \"$result\" -eq -3 ]] || { echo \"Test 2 failed: Expected -3, got $result\"; exit 1; }\n\n    result=$(calculate_expression 0 0 1)\n    [[ \"$result\" -eq 0 ]] || { echo \"Test 3 failed: Expected 0, got $result\"; exit 1; }\n\n    result=$(calculate_expression 10 -5 2)\n    [[ \"$result\" -eq 10 ]] || { echo \"Test 4 failed: Expected 10, got $result\"; exit 1; }\n\n    result=$(calculate_expression 100 200 -1)\n    [[ \"$result\" -eq -300 ]] || { echo \"Test 5 failed: Expected -300, got $result\"; exit 1; }\n}\n\ntest_calculate_expression",
    "entry_point": "calculate_expression",
    "signature": "calculate_expression() {",
    "docstring": {
      "en": " Calculate the value of the expression (a+b)*c with given integers a, b, and c.\n Args:\n a (int): The first integer.\n b (int): The second integer.\n c (int): The third integer.\n\n Returns:\n The result of the expression (a+b)*c.\n\n Examples:\n >>> calculate_expression 1 2 3\n 9\n >>> calculate_expression -1 2 -3\n -3",
      "sq": "Llogarit vlerën e shprehjes (a+b)*c me numrat e dhënë të plotë a, b, dhe c.\nArgs:\n a (int): Numri i parë i plotë.\n b (int): Numri i dytë i plotë.\n c (int): Numri i tretë i plotë.\n\nReturns:\n Rezultati i shprehjes (a+b)*c.\n\nExamples:\n >>> calculate_expression 1 2 3\n 9\n >>> calculate_expression -1 2 -3\n -3",
      "hy": "Հաշվարկել արտահայտության (a+b)*c արժեքը տրված ամբողջ թվերով a, b և c:\nԱրձագանքներ:\na (int): Առաջին ամբողջ թիվը:\nb (int): Երկրորդ ամբողջ թիվը:\nc (int): Երրորդ ամբողջ թիվը:\n\nՎերադարձնում է:\nԱրտահայտության (a+b)*c արդյունքը:\n\nՕրինակներ:\n>>> calculate_expression 1 2 3\n9\n>>> calculate_expression -1 2 -3\n-3",
      "bn": "Calculate the value of the expression (a+b)*c with given integers a, b, and c.  \nArgs:  \na (int): প্রথম পূর্ণসংখ্যা।  \nb (int): দ্বিতীয় পূর্ণসংখ্যা।  \nc (int): তৃতীয় পূর্ণসংখ্যা।  \n\nReturns:  \nপ্রকাশের ফলাফল (a+b)*c।  \n\nExamples:  \n>>> calculate_expression 1 2 3  \n9  \n>>> calculate_expression -1 2 -3  \n-3  ",
      "bg": "Изчислете стойността на израза (a+b)*c с дадени цели числа a, b и c.\nArgs:\n a (int): Първото цяло число.\n b (int): Второто цяло число.\n c (int): Третото цяло число.\n\nReturns:\n Резултатът от израза (a+b)*c.\n\nExamples:\n >>> calculate_expression 1 2 3\n 9\n >>> calculate_expression -1 2 -3\n -3",
      "zh": "计算表达式 (a+b)*c 的值，给定整数 a、b 和 c。\n\n参数：\na (int): 第一个整数。\nb (int): 第二个整数。\nc (int): 第三个整数。\n\n返回：\n表达式 (a+b)*c 的结果。\n\n示例：\n>>> calculate_expression 1 2 3\n9\n>>> calculate_expression -1 2 -3\n-3",
      "fr": " Calculer la valeur de l'expression (a+b)*c avec les entiers donnés a, b et c.\n Args:\n a (int): Le premier entier.\n b (int): Le deuxième entier.\n c (int): Le troisième entier.\n\n Returns:\n Le résultat de l'expression (a+b)*c.\n\n Examples:\n >>> calculate_expression 1 2 3\n 9\n >>> calculate_expression -1 2 -3\n -3",
      "de": "Berechne den Wert des Ausdrucks (a+b)*c mit gegebenen ganzen Zahlen a, b und c.\nArgs:\n a (int): Die erste ganze Zahl.\n b (int): Die zweite ganze Zahl.\n c (int): Die dritte ganze Zahl.\n\nReturns:\n Das Ergebnis des Ausdrucks (a+b)*c.\n\nExamples:\n >>> calculate_expression 1 2 3\n 9\n >>> calculate_expression -1 2 -3\n -3",
      "ha": "Calculate the value of the expression (a+b)*c with given integers a, b, and c.  \nArgs:  \na (int): Lamba na farko.  \nb (int): Lamba na biyu.  \nc (int): Lamba na uku.  \n\nReturns:  \nSakamakon bayyana (a+b)*c.  \n\nExamples:  \n>>> calculate_expression 1 2 3  \n9  \n>>> calculate_expression -1 2 -3  \n-3  ",
      "hi": "गणना करें कि अभिव्यक्ति (a+b)*c का मान दिए गए पूर्णांक a, b, और c के साथ क्या होगा।\nआर्ग्स:\na (int): पहला पूर्णांक।\nb (int): दूसरा पूर्णांक।\nc (int): तीसरा पूर्णांक।\n\nरिटर्न्स:\nअभिव्यक्ति (a+b)*c का परिणाम।\n\nउदाहरण:\n>>> calculate_expression 1 2 3\n9\n>>> calculate_expression -1 2 -3\n-3",
      "hu": "Számítsa ki a (a+b)*c kifejezés értékét a megadott egész számokkal: a, b és c.\nArgs:\n a (int): Az első egész szám.\n b (int): A második egész szám.\n c (int): A harmadik egész szám.\n\nReturns:\n A (a+b)*c kifejezés eredménye.\n\nExamples:\n >>> calculate_expression 1 2 3\n 9\n >>> calculate_expression -1 2 -3\n -3"
    },
    "docstring_bertscore": {
      "sq": "0.9956978645771654",
      "hy": "0.9825411840285575",
      "bn": "0.9739861735173848",
      "bg": "1",
      "zh": "0.9817875803629111",
      "fr": "0.9956978645771654",
      "de": "1",
      "ha": "0.9835351304552561",
      "hi": "0.9711622453902118",
      "hu": "0.9889416507966446"
    }
  },
  {
    "task_id": "Shell/42",
    "prompt": {
      "en": "print_ascii_code() {\n    # Prints the ASCII code of a given visible character (excluding space).\n    # Args:\n    #     char (string): A single character for which the ASCII code will be printed.\n    #\n    # Output:\n    #     Prints the ASCII code of the given character.\n    #\n    # Examples:\n    # >>> print_ascii_code 'B'\n    # 66\n    # >>> print_ascii_code 'z'\n    # 122",
      "sq": "print_ascii_code() {\n    # Printon kodin ASCII të një karakteri të dukshëm të dhënë (përjashtuar hapësirën).\n    # Argumentet:\n    #     char (string): Një karakter i vetëm për të cilin do të printohet kodi ASCII.\n    #\n    # Dalja:\n    #     Printon kodin ASCII të karakterit të dhënë.\n    #\n    # Shembuj:\n    # >>> print_ascii_code 'B'\n    # 66\n    # >>> print_ascii_code 'z'\n    # 122",
      "hy": "print_ascii_code() {\n    # Տպում է տրված տեսանելի սիմվոլի ASCII կոդը (բացառությամբ բացատանիշի):\n    # Արձանագրություններ:\n    #     char (string): Միայնակ սիմվոլ, որի համար տպվելու է ASCII կոդը:\n    #\n    # Ելք:\n    #     Տպում է տրված սիմվոլի ASCII կոդը:\n    #\n    # Օրինակներ:\n    # >>> print_ascii_code 'B'\n    # 66\n    # >>> print_ascii_code 'z'\n    # 122",
      "bn": "print_ascii_code() {\n    # প্রদত্ত দৃশ্যমান অক্ষরের ASCII কোড মুদ্রণ করে (স্পেস বাদে)।\n    # আর্গুমেন্ট:\n    #     char (string): একটি একক অক্ষর যার জন্য ASCII কোড মুদ্রণ করা হবে।\n    #\n    # আউটপুট:\n    #     প্রদত্ত অক্ষরের ASCII কোড মুদ্রণ করে।\n    #\n    # উদাহরণ:\n    # >>> print_ascii_code 'B'\n    # 66\n    # >>> print_ascii_code 'z'\n    # 122",
      "bg": "print_ascii_code() {\n    # Отпечатва ASCII кода на даден видим символ (без интервал).\n    # Args:\n    #     char (string): Един символ, за който ще бъде отпечатан ASCII кодът.\n    #\n    # Output:\n    #     Отпечатва ASCII кода на дадения символ.\n    #\n    # Примери:\n    # >>> print_ascii_code 'B'\n    # 66\n    # >>> print_ascii_code 'z'\n    # 122",
      "zh": "print_ascii_code() {\n    # 打印给定可见字符（不包括空格）的ASCII码。\n    # 参数:\n    #     char (string): 将打印其ASCII码的单个字符。\n    #\n    # 输出:\n    #     打印给定字符的ASCII码。\n    #\n    # 示例:\n    # >>> print_ascii_code 'B'\n    # 66\n    # >>> print_ascii_code 'z'\n    # 122",
      "fr": "print_ascii_code() {\n    # Imprime le code ASCII d'un caractère visible donné (à l'exclusion de l'espace).\n    # Args:\n    #     char (string): Un seul caractère pour lequel le code ASCII sera imprimé.\n    #\n    # Sortie:\n    #     Imprime le code ASCII du caractère donné.\n    #\n    # Exemples:\n    # >>> print_ascii_code 'B'\n    # 66\n    # >>> print_ascii_code 'z'\n    # 122",
      "de": "print_ascii_code() {\n    # Gibt den ASCII-Code eines angegebenen sichtbaren Zeichens aus (ohne Leerzeichen).\n    # Argumente:\n    #     char (string): Ein einzelnes Zeichen, für das der ASCII-Code ausgegeben wird.\n    #\n    # Ausgabe:\n    #     Gibt den ASCII-Code des angegebenen Zeichens aus.\n    #\n    # Beispiele:\n    # >>> print_ascii_code 'B'\n    # 66\n    # >>> print_ascii_code 'z'\n    # 122",
      "ha": "print_ascii_code() {\n    # Buga lambar ASCII na wata alamar gani da aka bayar (ba tare da sarari ba).\n    # Args:\n    #     char (string): Wata alama guda daya wanda za a buga lambar ASCII dinta.\n    #\n    # Fitarwa:\n    #     Buga lambar ASCII na alamar da aka bayar.\n    #\n    # Misalai:\n    # >>> print_ascii_code 'B'\n    # 66\n    # >>> print_ascii_code 'z'\n    # 122",
      "hi": "print_ascii_code() {\n    # दिए गए दृश्य वर्ण (स्पेस को छोड़कर) का ASCII कोड प्रिंट करता है।\n    # तर्क:\n    #     char (string): एकल वर्ण जिसके लिए ASCII कोड प्रिंट किया जाएगा।\n    #\n    # आउटपुट:\n    #     दिए गए वर्ण का ASCII कोड प्रिंट करता है।\n    #\n    # उदाहरण:\n    # >>> print_ascii_code 'B'\n    # 66\n    # >>> print_ascii_code 'z'\n    # 122",
      "hu": "print_ascii_code() {\n    # Kiírja egy adott látható karakter ASCII kódját (kivéve a szóközt).\n    # Argumentumok:\n    #     char (string): Egyetlen karakter, amelynek az ASCII kódját kiírjuk.\n    #\n    # Kimenet:\n    #     Kiírja a megadott karakter ASCII kódját.\n    #\n    # Példák:\n    # >>> print_ascii_code 'B'\n    # 66\n    # >>> print_ascii_code 'z'\n    # 122"
    },
    "prompt_bertscore": {
      "sq": "0.9879661769953824",
      "hy": "0.9802332976313131",
      "bn": "0.9827169719157733",
      "bg": "1",
      "zh": "0.9536142443776846",
      "fr": "1",
      "de": "0.9574035161566872",
      "ha": "0.9715585130003764",
      "hi": "0.9779236235606394",
      "hu": "0.9717625064016993"
    },
    "canonical_solution": "    local char=\"$1\"\n    # Print the ASCII code of the character\n    printf \"%d\\n\" \"'$char\"\n}",
    "instruction": {
      "en": "Write a Shell function `print_ascii_code() {` to solve the following problem: Prints the ASCII code of a given visible character (excluding space).\n Args:\n char (string): A single character for which the ASCII code will be printed.\n\n Output:\n Prints the ASCII code of the given character.\n\n Examples:\n >>> print_ascii_code 'B'\n 66\n >>> print_ascii_code 'z'\n 122",
      "sq": "Shkruani një funksion Shell `print_ascii_code() {` për të zgjidhur problemin e mëposhtëm: Printon kodin ASCII të një karakteri të dhënë të dukshëm (përjashtuar hapësirën).\n Args:\n char (string): Një karakter i vetëm për të cilin do të printohet kodi ASCII.\n\n Output:\n Printon kodin ASCII të karakterit të dhënë.\n\n Shembuj:\n >>> print_ascii_code 'B'\n 66\n >>> print_ascii_code 'z'\n 122",
      "hy": "Գրեք Shell ֆունկցիա `print_ascii_code() {` հետևյալ խնդիրը լուծելու համար. Տպում է տրված տեսանելի սիմվոլի ASCII կոդը (բացառությամբ բացատը):\n Արձանագրություններ:\n char (string): Միայնակ սիմվոլ, որի համար ASCII կոդը կտպվի:\n\n Արդյունք:\n Տպում է տրված սիմվոլի ASCII կոդը:\n\n Օրինակներ:\n >>> print_ascii_code 'B'\n 66\n >>> print_ascii_code 'z'\n 122",
      "bn": "একটি Shell ফাংশন `print_ascii_code() {` লিখুন নিম্নলিখিত সমস্যার সমাধানের জন্য: একটি প্রদত্ত দৃশ্যমান অক্ষরের (স্পেস বাদে) ASCII কোড প্রিন্ট করে।\n Args:\n char (string): একটি একক অক্ষর যার জন্য ASCII কোড প্রিন্ট করা হবে।\n\n Output:\n প্রদত্ত অক্ষরের ASCII কোড প্রিন্ট করে।\n\n Examples:\n >>> print_ascii_code 'B'\n 66\n >>> print_ascii_code 'z'\n 122",
      "bg": "Напишете Shell функция `print_ascii_code() {`, за да решите следния проблем: Отпечатва ASCII кода на даден видим символ (без интервал).\n Args:\n char (string): Един символ, за който ще бъде отпечатан ASCII кодът.\n\n Output:\n Отпечатва ASCII кода на дадения символ.\n\n Examples:\n >>> print_ascii_code 'B'\n 66\n >>> print_ascii_code 'z'\n 122",
      "zh": "编写一个 Shell 函数 `print_ascii_code() {` 来解决以下问题：打印给定可见字符（不包括空格）的 ASCII 码。\n 参数:\n char (string): 将打印其 ASCII 码的单个字符。\n\n 输出:\n 打印给定字符的 ASCII 码。\n\n 例子:\n >>> print_ascii_code 'B'\n 66\n >>> print_ascii_code 'z'\n 122",
      "fr": "Écrire une fonction Shell `print_ascii_code() {` pour résoudre le problème suivant : Affiche le code ASCII d'un caractère visible donné (à l'exclusion de l'espace).\n Args:\n char (string): Un seul caractère pour lequel le code ASCII sera affiché.\n\n Output:\n Affiche le code ASCII du caractère donné.\n\n Exemples :\n >>> print_ascii_code 'B'\n 66\n >>> print_ascii_code 'z'\n 122",
      "de": "Schreiben Sie eine Shell-Funktion `print_ascii_code() {`, um das folgende Problem zu lösen: Gibt den ASCII-Code eines gegebenen sichtbaren Zeichens (ohne Leerzeichen) aus.\n Args:\n char (string): Ein einzelnes Zeichen, für das der ASCII-Code ausgegeben wird.\n\n Ausgabe:\n Gibt den ASCII-Code des gegebenen Zeichens aus.\n\n Beispiele:\n >>> print_ascii_code 'B'\n 66\n >>> print_ascii_code 'z'\n 122",
      "ha": "Rubuta wani aikin Shell `print_ascii_code() {` don warware matsalar mai zuwa: Buga lambar ASCII na wata alamar da ake iya gani (ban da sarari).\n Args:\n char (string): Wata alama guda daya wadda za a buga lambar ASCII dinta.\n\n Fitarwa:\n Yana buga lambar ASCII na alamar da aka bayar.\n\n Misalai:\n >>> print_ascii_code 'B'\n 66\n >>> print_ascii_code 'z'\n 122",
      "hi": "एक Shell फ़ंक्शन `print_ascii_code() {` लिखें ताकि निम्नलिखित समस्या का समाधान किया जा सके: दिए गए दृश्य वर्ण (स्पेस को छोड़कर) का ASCII कोड प्रिंट करता है।\n \n तर्क:\n char (string): एकल वर्ण जिसके लिए ASCII कोड प्रिंट किया जाएगा।\n\n आउटपुट:\n दिए गए वर्ण का ASCII कोड प्रिंट करता है।\n\n उदाहरण:\n >>> print_ascii_code 'B'\n 66\n >>> print_ascii_code 'z'\n 122",
      "hu": "Írj egy Shell függvényt `print_ascii_code() {` a következő probléma megoldására: Kiírja egy adott látható karakter (kivéve a szóköz) ASCII kódját.\n Args:\n char (string): Egyetlen karakter, amelynek az ASCII kódját kiírjuk.\n\n Kimenet:\n Kiírja a megadott karakter ASCII kódját.\n\n Példák:\n >>> print_ascii_code 'B'\n 66\n >>> print_ascii_code 'z'\n 122"
    },
    "instruction_bertscore": {
      "sq": "1",
      "hy": "0.9815126759155588",
      "bn": "0.9957054125316447",
      "bg": "0.9970102155046628",
      "zh": "0.9648579157265456",
      "fr": "0.981627881536559",
      "de": "0.9743303999677183",
      "ha": "0.97164173913003",
      "hi": "0.9867898878788938",
      "hu": "0.9800600919390506"
    },
    "level": "easy",
    "test": "test_print_ascii_code() {\n    local result\n\n    result=$(print_ascii_code 'B')\n    [[ \"$result\" -eq 66 ]] || { echo \"Test 1 failed: Expected 66, got $result\"; exit 1; }\n\n    result=$(print_ascii_code 'z')\n    [[ \"$result\" -eq 122 ]] || { echo \"Test 2 failed: Expected 122, got $result\"; exit 1; }\n\n    result=$(print_ascii_code '1')\n    [[ \"$result\" -eq 49 ]] || { echo \"Test 3 failed: Expected 49, got $result\"; exit 1; }\n\n    result=$(print_ascii_code '%')\n    [[ \"$result\" -eq 37 ]] || { echo \"Test 4 failed: Expected 37, got $result\"; exit 1; }\n\n    result=$(print_ascii_code '?')\n    [[ \"$result\" -eq 63 ]] || { echo \"Test 5 failed: Expected 63, got $result\"; exit 1; }\n}\n\ntest_print_ascii_code",
    "entry_point": "print_ascii_code",
    "signature": "print_ascii_code() {",
    "docstring": {
      "en": " Prints the ASCII code of a given visible character (excluding space).\n Args:\n char (string): A single character for which the ASCII code will be printed.\n\n Output:\n Prints the ASCII code of the given character.\n\n Examples:\n >>> print_ascii_code 'B'\n 66\n >>> print_ascii_code 'z'\n 122",
      "sq": "Printon kodin ASCII të një karakteri të dhënë të dukshëm (duke përjashtuar hapësirën).\nArgs:\n char (string): Një karakter i vetëm për të cilin do të printohet kodi ASCII.\n\nOutput:\nPrinton kodin ASCII të karakterit të dhënë.\n\nExamples:\n>>> print_ascii_code 'B'\n66\n>>> print_ascii_code 'z'\n122",
      "hy": "Տպում է տրված տեսանելի սիմվոլի ASCII կոդը (բացառությամբ բացատը):\nԱրգումենտներ:\nchar (string): Միայնակ սիմվոլ, որի համար կտպվի ASCII կոդը:\n\nԵլք:\nՏպում է տրված սիմվոլի ASCII կոդը:\n\nՕրինակներ:\n>>> print_ascii_code 'B'\n66\n>>> print_ascii_code 'z'\n122",
      "bn": " প্রদত্ত দৃশ্যমান অক্ষরের ASCII কোড প্রিন্ট করে (স্পেস বাদে)।\n\n Args:\n char (string): একটি একক অক্ষর যার জন্য ASCII কোড প্রিন্ট করা হবে।\n\n Output:\n প্রদত্ত অক্ষরের ASCII কোড প্রিন্ট করে।\n\n Examples:\n >>> print_ascii_code 'B'\n 66\n >>> print_ascii_code 'z'\n 122",
      "bg": "Извежда ASCII кода на даден видим символ (без интервал).\n\nArgs:\n char (string): Един символ, за който ще бъде изведен ASCII кодът.\n\nOutput:\n Извежда ASCII кода на дадения символ.\n\nExamples:\n >>> print_ascii_code 'B'\n 66\n >>> print_ascii_code 'z'\n 122",
      "zh": " 打印给定可见字符（不包括空格）的ASCII码。\n Args:\n char (string): 要打印其ASCII码的单个字符。\n\n Output:\n 打印给定字符的ASCII码。\n\n Examples:\n >>> print_ascii_code 'B'\n 66\n >>> print_ascii_code 'z'\n 122",
      "fr": "Imprime le code ASCII d'un caractère visible donné (à l'exclusion de l'espace).\nArgs:\n char (string): Un seul caractère pour lequel le code ASCII sera imprimé.\n\nOutput:\n Imprime le code ASCII du caractère donné.\n\nExamples:\n >>> print_ascii_code 'B'\n 66\n >>> print_ascii_code 'z'\n 122",
      "de": "Gibt den ASCII-Code eines gegebenen sichtbaren Zeichens aus (ohne Leerzeichen).\nArgs:\n char (string): Ein einzelnes Zeichen, für das der ASCII-Code ausgegeben wird.\n\nOutput:\n Gibt den ASCII-Code des angegebenen Zeichens aus.\n\nExamples:\n >>> print_ascii_code 'B'\n 66\n >>> print_ascii_code 'z'\n 122",
      "ha": "Prints the ASCII code of a given visible character (excluding space).\n\nArgs:\n char (string): Wani harafi guda ɗaya wanda za a buga lambar ASCII ɗinsa.\n\nOutput:\n Yana buga lambar ASCII na harafin da aka bayar.\n\nExamples:\n >>> print_ascii_code 'B'\n 66\n >>> print_ascii_code 'z'\n 122",
      "hi": "दिए गए दृश्य वर्ण (स्पेस को छोड़कर) का ASCII कोड प्रिंट करता है।\nआर्ग्स:\nchar (string): एकल वर्ण जिसके लिए ASCII कोड प्रिंट किया जाएगा।\n\nआउटपुट:\nदिए गए वर्ण का ASCII कोड प्रिंट करता है।\n\nउदाहरण:\n>>> print_ascii_code 'B'\n66\n>>> print_ascii_code 'z'\n122",
      "hu": "Kiírja egy adott látható karakter ASCII kódját (kivéve a szóközt).\nArgs:\n char (string): Egyetlen karakter, amelynek az ASCII kódját kiírjuk.\n\nOutput:\n Kiírja a megadott karakter ASCII kódját.\n\nExamples:\n >>> print_ascii_code 'B'\n 66\n >>> print_ascii_code 'z'\n 122"
    },
    "docstring_bertscore": {
      "sq": "1",
      "hy": "0.9583491954007943",
      "bn": "0.9960542074807419",
      "bg": "0.9738008513718793",
      "zh": "0.9671238911133915",
      "fr": "0.99289459400962",
      "de": "0.9648334841896782",
      "ha": "0.9871452376305652",
      "hi": "0.988949596011886",
      "hu": "0.9830173010518981"
    }
  },
  {
    "task_id": "Shell/43",
    "prompt": {
      "en": "ascii_to_char() {\n    # Converts an ASCII code to its corresponding character.\n    # Args:\n    #     ascii_code (int): The ASCII code to be converted.\n    #\n    # Output:\n    #     Prints the character corresponding to the given ASCII code.\n    #\n    # Examples:\n    # >>> ascii_to_char 66\n    # B\n    # >>> ascii_to_char 97\n    # a",
      "sq": "ascii_to_char() {\n    # Konverton një kod ASCII në karakterin përkatës.\n    # Argumentet:\n    #     ascii_code (int): Kodi ASCII që do të konvertohet.\n    #\n    # Dalja:\n    #     Shtyp karakterin që korrespondon me kodin ASCII të dhënë.\n    #\n    # Shembuj:\n    # >>> ascii_to_char 66\n    # B\n    # >>> ascii_to_char 97\n    # a",
      "hy": "ascii_to_char() {\n    # Վերածում է ASCII կոդը համապատասխան նիշի:\n    # Արձանագրություններ:\n    #     ascii_code (int): ASCII կոդը, որը պետք է վերածվի:\n    #\n    # Ելք:\n    #     Տպում է տրված ASCII կոդին համապատասխան նիշը:\n    #\n    # Օրինակներ:\n    # >>> ascii_to_char 66\n    # B\n    # >>> ascii_to_char 97\n    # a",
      "bn": "ascii_to_char() {\n    # একটি ASCII কোডকে তার সংশ্লিষ্ট অক্ষরে রূপান্তর করে।\n    # আর্গুমেন্টসমূহ:\n    #     ascii_code (int): রূপান্তর করার জন্য ASCII কোড।\n    #\n    # আউটপুট:\n    #     প্রদত্ত ASCII কোডের সংশ্লিষ্ট অক্ষর প্রিন্ট করে।\n    #\n    # উদাহরণসমূহ:\n    # >>> ascii_to_char 66\n    # B\n    # >>> ascii_to_char 97\n    # a",
      "bg": "ascii_to_char() {\n    # Преобразува ASCII код в съответстващия му символ.\n    # Аргументи:\n    #     ascii_code (int): ASCII кодът, който ще бъде преобразуван.\n    #\n    # Изход:\n    #     Извежда символа, съответстващ на дадения ASCII код.\n    #\n    # Примери:\n    # >>> ascii_to_char 66\n    # B\n    # >>> ascii_to_char 97\n    # a",
      "zh": "ascii_to_char() {\n    # 将ASCII码转换为其对应的字符。\n    # 参数:\n    #     ascii_code (int): 要转换的ASCII码。\n    #\n    # 输出:\n    #     打印与给定ASCII码对应的字符。\n    #\n    # 示例:\n    # >>> ascii_to_char 66\n    # B\n    # >>> ascii_to_char 97\n    # a",
      "fr": "ascii_to_char() {\n    # Convertit un code ASCII en son caractère correspondant.\n    # Arguments:\n    #     ascii_code (int): Le code ASCII à convertir.\n    #\n    # Sortie:\n    #     Affiche le caractère correspondant au code ASCII donné.\n    #\n    # Exemples:\n    # >>> ascii_to_char 66\n    # B\n    # >>> ascii_to_char 97\n    # a",
      "de": "ascii_to_char() {\n    # Konvertiert einen ASCII-Code in das entsprechende Zeichen.\n    # Argumente:\n    #     ascii_code (int): Der zu konvertierende ASCII-Code.\n    #\n    # Ausgabe:\n    #     Gibt das Zeichen aus, das dem gegebenen ASCII-Code entspricht.\n    #\n    # Beispiele:\n    # >>> ascii_to_char 66\n    # B\n    # >>> ascii_to_char 97\n    # a",
      "ha": "ascii_to_char() {\n    # Canza lambar ASCII zuwa harafin da ya dace.\n    # Args:\n    #     ascii_code (int): Lambar ASCII da za a canza.\n    #\n    # Fitarwa:\n    #     Buga harafin da ya dace da lambar ASCII da aka bayar.\n    #\n    # Misalai:\n    # >>> ascii_to_char 66\n    # B\n    # >>> ascii_to_char 97\n    # a",
      "hi": "ascii_to_char() {\n    # एक ASCII कोड को उसके संबंधित वर्ण में परिवर्तित करता है।\n    # तर्क:\n    #     ascii_code (int): ASCII कोड जिसे परिवर्तित किया जाना है।\n    #\n    # आउटपुट:\n    #     दिए गए ASCII कोड के संबंधित वर्ण को प्रिंट करता है।\n    #\n    # उदाहरण:\n    # >>> ascii_to_char 66\n    # B\n    # >>> ascii_to_char 97\n    # a",
      "hu": "ascii_to_char() {\n    # Egy ASCII kódot alakít át a megfelelő karakterré.\n    # Argumentumok:\n    #     ascii_code (int): Az átalakítandó ASCII kód.\n    #\n    # Kimenet:\n    #     Kiírja a megadott ASCII kódnak megfelelő karaktert.\n    #\n    # Példák:\n    # >>> ascii_to_char 66\n    # B\n    # >>> ascii_to_char 97\n    # a"
    },
    "prompt_bertscore": {
      "sq": "0.9825975950567714",
      "hy": "0.977402814701566",
      "bn": "0.9664453697317763",
      "bg": "0.982452793508997",
      "zh": "0.9637122156887363",
      "fr": "0.9744336877658565",
      "de": "0.9723794523651936",
      "ha": "0.9673594667452989",
      "hi": "0.9803888252196634",
      "hu": "0.9825975950567714"
    },
    "canonical_solution": "    local ascii_code=$1\n    # Convert ASCII code to character\n    printf \"\\\\$(printf '%03o' \"$ascii_code\")\\n\"\n}",
    "instruction": {
      "en": "Write a Shell function `ascii_to_char() {` to solve the following problem: Converts an ASCII code to its corresponding character.\n Args:\n ascii_code (int): The ASCII code to be converted.\n\n Output:\n Prints the character corresponding to the given ASCII code.\n\n Examples:\n >>> ascii_to_char 66\n B\n >>> ascii_to_char 97\n a",
      "sq": "Shkruani një funksion Shell `ascii_to_char() {` për të zgjidhur problemin e mëposhtëm: Konverton një kod ASCII në karakterin përkatës.\n Args:\n ascii_code (int): Kodi ASCII që do të konvertohet.\n\n Output:\n Printon karakterin që korrespondon me kodin ASCII të dhënë.\n\n Shembuj:\n >>> ascii_to_char 66\n B\n >>> ascii_to_char 97\n a",
      "hy": "Գրեք Shell ֆունկցիա `ascii_to_char() {` հետևյալ խնդիրը լուծելու համար: Վերածում է ASCII կոդը համապատասխան նիշի:\n Արգումենտներ:\n ascii_code (int): Վերածվող ASCII կոդը:\n\n Ելք:\n Տպում է տրված ASCII կոդին համապատասխան նիշը:\n\n Օրինակներ:\n >>> ascii_to_char 66\n B\n >>> ascii_to_char 97\n a",
      "bn": "একটি Shell ফাংশন `ascii_to_char() {` লিখুন নিম্নলিখিত সমস্যার সমাধানের জন্য: একটি ASCII কোডকে তার সংশ্লিষ্ট অক্ষরে রূপান্তর করে।\n\nআর্গুমেন্টসমূহ:\nascii_code (int): রূপান্তর করার জন্য ASCII কোড।\n\nআউটপুট:\nপ্রদান করা ASCII কোডের সংশ্লিষ্ট অক্ষর মুদ্রণ করে।\n\nউদাহরণসমূহ:\n>>> ascii_to_char 66\nB\n>>> ascii_to_char 97\na",
      "bg": "Напишете Shell функция `ascii_to_char() {`, за да решите следния проблем: Преобразува ASCII код в съответстващия му символ.\n Аргументи:\n ascii_code (int): ASCII кодът, който ще бъде преобразуван.\n\n Изход:\n Отпечатва символа, съответстващ на дадения ASCII код.\n\n Примери:\n >>> ascii_to_char 66\n B\n >>> ascii_to_char 97\n a",
      "zh": "编写一个 Shell 函数 `ascii_to_char() {` 来解决以下问题：将 ASCII 代码转换为其对应的字符。\n 参数：\n ascii_code (int): 要转换的 ASCII 代码。\n\n 输出：\n 打印与给定 ASCII 代码对应的字符。\n\n 示例：\n >>> ascii_to_char 66\n B\n >>> ascii_to_char 97\n a",
      "fr": "Écrire une fonction Shell `ascii_to_char() {` pour résoudre le problème suivant : Convertit un code ASCII en son caractère correspondant.\n Args:\n ascii_code (int): Le code ASCII à convertir.\n\n Output:\n Affiche le caractère correspondant au code ASCII donné.\n\n Exemples :\n >>> ascii_to_char 66\n B\n >>> ascii_to_char 97\n a",
      "de": "Schreiben Sie eine Shell-Funktion `ascii_to_char() {`, um das folgende Problem zu lösen: Konvertiert einen ASCII-Code in das entsprechende Zeichen.\n Argumente:\n ascii_code (int): Der zu konvertierende ASCII-Code.\n\n Ausgabe:\n Gibt das Zeichen aus, das dem angegebenen ASCII-Code entspricht.\n\n Beispiele:\n >>> ascii_to_char 66\n B\n >>> ascii_to_char 97\n a",
      "ha": "Rubuta aikin Shell `ascii_to_char() {` don warware matsalar mai zuwa: Canza lambar ASCII zuwa harafin da ya dace.\n Args:\n ascii_code (int): Lambar ASCII da za a canza.\n\n Fitarwa:\n Yana buga harafin da ya dace da lambar ASCII da aka bayar.\n\n Misalai:\n >>> ascii_to_char 66\n B\n >>> ascii_to_char 97\n a",
      "hi": "एक Shell फ़ंक्शन `ascii_to_char() {` लिखें ताकि निम्नलिखित समस्या का समाधान किया जा सके: एक ASCII कोड को उसके संबंधित अक्षर में परिवर्तित करता है। \n तर्क:\n ascii_code (int): वह ASCII कोड जिसे परिवर्तित किया जाना है।\n\n आउटपुट:\n दिए गए ASCII कोड के संबंधित अक्षर को प्रिंट करता है।\n\n उदाहरण:\n >>> ascii_to_char 66\n B\n >>> ascii_to_char 97\n a",
      "hu": "Írj egy Shell függvényt `ascii_to_char() {` a következő probléma megoldására: Átalakít egy ASCII kódot a megfelelő karakterré.\n Args:\n ascii_code (int): Az átalakítandó ASCII kód.\n\n Kimenet:\n Kiírja a megadott ASCII kódnak megfelelő karaktert.\n\n Példák:\n >>> ascii_to_char 66\n B\n >>> ascii_to_char 97\n a"
    },
    "instruction_bertscore": {
      "sq": "0.9909998588049281",
      "hy": "0.983797322558222",
      "bn": "0.9552304997881655",
      "bg": "0.9853087011275166",
      "zh": "0.964980073410882",
      "fr": "0.986102626760513",
      "de": "0.9614708704691386",
      "ha": "0.9855397082606602",
      "hi": "0.977556951877249",
      "hu": "0.9947452332697221"
    },
    "level": "easy",
    "test": "test_ascii_to_char() {\n    local result\n\n    result=$(ascii_to_char 66)\n    [[ \"$result\" == \"B\" ]] || { echo \"Test 1 failed: Expected B, got $result\"; exit 1; }\n\n    result=$(ascii_to_char 97)\n    [[ \"$result\" == \"a\" ]] || { echo \"Test 2 failed: Expected a, got $result\"; exit 1; }\n\n    result=$(ascii_to_char 36)\n    [[ \"$result\" == \"$\" ]] || { echo \"Test 3 failed: Expected $, got $result\"; exit 1; }\n\n    result=$(ascii_to_char 57)\n    [[ \"$result\" == \"9\" ]] || { echo \"Test 4 failed: Expected 9, got $result\"; exit 1; }\n\n    result=$(ascii_to_char 32)\n    [[ \"$result\" == \" \" ]] || { echo \"Test 5 failed: Expected space, got $result\"; exit 1; }\n}\n\ntest_ascii_to_char",
    "entry_point": "ascii_to_char",
    "signature": "ascii_to_char() {",
    "docstring": {
      "en": " Converts an ASCII code to its corresponding character.\n Args:\n ascii_code (int): The ASCII code to be converted.\n\n Output:\n Prints the character corresponding to the given ASCII code.\n\n Examples:\n >>> ascii_to_char 66\n B\n >>> ascii_to_char 97\n a",
      "sq": "Konverton një kod ASCII në karakterin përkatës.\nArgs:\n ascii_code (int): Kodi ASCII që do të konvertohet.\n\nOutput:\nPrinton karakterin përkatës për kodin ASCII të dhënë.\n\nShembuj:\n>>> ascii_to_char 66\nB\n>>> ascii_to_char 97\na",
      "hy": "Վերածում է ASCII կոդը համապատասխանող նիշի:\nԱրգումենտներ:\nascii_code (int): Վերածվող ASCII կոդը:\n\nԵլք:\nՏպում է տրված ASCII կոդին համապատասխանող նիշը:\n\nՕրինակներ:\n>>> ascii_to_char 66\nB\n>>> ascii_to_char 97\na",
      "bn": "ASCII কোডকে এর সংশ্লিষ্ট অক্ষরে রূপান্তরিত করে।\nArgs:\n    ascii_code (int): রূপান্তরিত করার জন্য ASCII কোড।\n\nOutput:\n    প্রদত্ত ASCII কোডের সাথে সংশ্লিষ্ট অক্ষর মুদ্রণ করে।\n\nExamples:\n    >>> ascii_to_char 66\n    B\n    >>> ascii_to_char 97\n    a",
      "bg": "Преобразува ASCII код в съответния му символ.\nАргументи:\nascii_code (int): ASCII кодът, който ще бъде преобразуван.\n\nИзход:\nОтпечатва символа, съответстващ на дадения ASCII код.\n\nПримери:\n>>> ascii_to_char 66\nB\n>>> ascii_to_char 97\na",
      "zh": "将ASCII码转换为其对应的字符。\n参数：\nascii_code (int): 要转换的ASCII码。\n\n输出：\n打印与给定ASCII码对应的字符。\n\n示例：\n>>> ascii_to_char 66\nB\n>>> ascii_to_char 97\na",
      "fr": "Convertit un code ASCII en son caractère correspondant.\nArgs:\n ascii_code (int): Le code ASCII à convertir.\n\nOutput:\n Affiche le caractère correspondant au code ASCII donné.\n\nExamples:\n >>> ascii_to_char 66\n B\n >>> ascii_to_char 97\n a",
      "de": "Konvertiert einen ASCII-Code in das entsprechende Zeichen.\nArgs:\n ascii_code (int): Der zu konvertierende ASCII-Code.\n\n Output:\n Gibt das Zeichen aus, das dem angegebenen ASCII-Code entspricht.\n\n Beispiele:\n >>> ascii_to_char 66\n B\n >>> ascii_to_char 97\n a",
      "ha": "Converts an ASCII code to its corresponding character.\nArgs:\nascii_code (int): Lambar ASCII da za a canza.\n\nOutput:\nPrints harafin da ya dace da lambar ASCII da aka bayar.\n\nExamples:\n>>> ascii_to_char 66\nB\n>>> ascii_to_char 97\na",
      "hi": "Converts an ASCII code to its corresponding character.\nआर्ग्स:\nascii_code (int): वह ASCII कोड जिसे परिवर्तित किया जाना है।\n\nआउटपुट:\nदिए गए ASCII कोड के अनुरूप वर्ण को प्रिंट करता है।\n\nउदाहरण:\n>>> ascii_to_char 66\nB\n>>> ascii_to_char 97\na",
      "hu": "Átalakít egy ASCII kódot a megfelelő karakterré.\nArgs:\n ascii_code (int): Az átalakítandó ASCII kód.\n\nOutput:\n Kiírja a megadott ASCII kódnak megfelelő karaktert.\n\nPéldák:\n >>> ascii_to_char 66\n B\n >>> ascii_to_char 97\n a"
    },
    "docstring_bertscore": {
      "sq": "0.9781653567343589",
      "hy": "0.9783800761762576",
      "bn": "0.9696939696136019",
      "bg": "0.9857178797124484",
      "zh": "0.9582071746783544",
      "fr": "0.9818424023480767",
      "de": "0.9655517316475004",
      "ha": "0.9919910244062923",
      "hi": "0.9978784289001663",
      "hu": "0.9952759736478473"
    }
  },
  {
    "task_id": "Shell/44",
    "prompt": {
      "en": "int_to_bool_to_int() {\n    # Converts an integer to a boolean value, then converts this boolean back to an integer.\n    # The process involves assigning an integer value to a boolean variable and then\n    # assigning this boolean value back to an integer variable.\n    # Args:\n    #     initial_int (int): The initial integer value.\n    #\n    # Output:\n    #     Prints the integer value obtained after conversion from integer to boolean and back to integer.\n    #\n    # Examples:\n    # >>> int_to_bool_to_int 0\n    # 0\n    # >>> int_to_bool_to_int -5\n    # 1",
      "sq": "int_to_bool_to_int() {\n    # Konverton një numër të plotë në një vlerë boolean, pastaj e konverton këtë boolean përsëri në një numër të plotë.\n    # Procesi përfshin caktimin e një vlere të plotë një variabli boolean dhe pastaj\n    # caktimin e kësaj vlere boolean përsëri një variabli të plotë.\n    # Argumentet:\n    #     initial_int (int): Vlera fillestare e numrit të plotë.\n    #\n    # Dalja:\n    #     Printon vlerën e numrit të plotë të marrë pas konvertimit nga numri i plotë në boolean dhe përsëri në numër të plotë.\n    #\n    # Shembuj:\n    # >>> int_to_bool_to_int 0\n    # 0\n    # >>> int_to_bool_to_int -5\n    # 1",
      "hy": "int_to_bool_to_int() {\n    # Վերածում է ամբողջ թիվը բուլյան արժեքի, ապա այս բուլյանը վերածում է ամբողջ թվի:\n    # Գործընթացը ներառում է ամբողջ թվային արժեքի վերագրումը բուլյան փոփոխականին, ապա\n    # այս բուլյան արժեքի վերագրումը ամբողջ թվային փոփոխականին:\n    # Արձագանքներ:\n    #     initial_int (int): Սկզբնական ամբողջ թվային արժեքը:\n    #\n    # Արդյունք:\n    #     Տպում է ամբողջ թվային արժեքը, որը ստացվել է ամբողջ թվից բուլյան և հետ ամբողջ թվի վերածումից հետո:\n    #\n    # Օրինակներ:\n    # >>> int_to_bool_to_int 0\n    # 0\n    # >>> int_to_bool_to_int -5\n    # 1",
      "bn": "int_to_bool_to_int() {\n    # একটি পূর্ণসংখ্যাকে একটি বুলিয়ান মানে রূপান্তর করে, তারপর এই বুলিয়ানটিকে আবার একটি পূর্ণসংখ্যায় রূপান্তর করে।\n    # এই প্রক্রিয়াটিতে একটি পূর্ণসংখ্যার মানকে একটি বুলিয়ান ভেরিয়েবলে বরাদ্দ করা এবং তারপর\n    # এই বুলিয়ান মানটিকে আবার একটি পূর্ণসংখ্যার ভেরিয়েবলে বরাদ্দ করা জড়িত।\n    # আর্গস:\n    #     initial_int (int): প্রাথমিক পূর্ণসংখ্যার মান।\n    #\n    # আউটপুট:\n    #     পূর্ণসংখ্যার মান মুদ্রণ করে যা পূর্ণসংখ্যা থেকে বুলিয়ান এবং আবার পূর্ণসংখ্যায় রূপান্তরিত হওয়ার পরে প্রাপ্ত হয়।\n    #\n    # উদাহরণ:\n    # >>> int_to_bool_to_int 0\n    # 0\n    # >>> int_to_bool_to_int -5\n    # 1",
      "bg": "int_to_bool_to_int() {\n    # Преобразува цяло число в булева стойност, след което преобразува тази булева стойност обратно в цяло число.\n    # Процесът включва присвояване на цяло число на булева променлива и след това\n    # присвояване на тази булева стойност обратно на променлива от тип цяло число.\n    # Аргументи:\n    #     initial_int (int): Първоначалната стойност на цялото число.\n    #\n    # Изход:\n    #     Отпечатва стойността на цялото число, получена след преобразуването от цяло число в булева стойност и обратно в цяло число.\n    #\n    # Примери:\n    # >>> int_to_bool_to_int 0\n    # 0\n    # >>> int_to_bool_to_int -5\n    # 1",
      "zh": "int_to_bool_to_int() {\n    # 将整数转换为布尔值，然后将该布尔值转换回整数。\n    # 该过程涉及将一个整数值赋给一个布尔变量，然后\n    # 将该布尔值赋回给一个整数变量。\n    # 参数:\n    #     initial_int (int): 初始整数值。\n    #\n    # 输出:\n    #     打印从整数转换为布尔值再转换回整数后得到的整数值。\n    #\n    # 示例:\n    # >>> int_to_bool_to_int 0\n    # 0\n    # >>> int_to_bool_to_int -5\n    # 1",
      "fr": "int_to_bool_to_int() {\n    # Convertit un entier en une valeur booléenne, puis convertit ce booléen en un entier.\n    # Le processus implique d'assigner une valeur entière à une variable booléenne puis\n    # d'assigner cette valeur booléenne à une variable entière.\n    # Args:\n    #     initial_int (int): La valeur entière initiale.\n    #\n    # Sortie:\n    #     Affiche la valeur entière obtenue après conversion de l'entier en booléen puis en entier.\n    #\n    # Exemples:\n    # >>> int_to_bool_to_int 0\n    # 0\n    # >>> int_to_bool_to_int -5\n    # 1",
      "de": "int_to_bool_to_int() {\n    # Konvertiert eine ganze Zahl in einen booleschen Wert und dann diesen booleschen Wert zurück in eine ganze Zahl.\n    # Der Prozess beinhaltet das Zuweisen eines ganzzahligen Wertes zu einer booleschen Variablen und dann\n    # das Zuweisen dieses booleschen Wertes zurück zu einer ganzzahligen Variablen.\n    # Argumente:\n    #     initial_int (int): Der anfängliche ganzzahlige Wert.\n    #\n    # Ausgabe:\n    #     Gibt den ganzzahligen Wert aus, der nach der Umwandlung von Ganzzahl zu Booleschem und zurück zu Ganzzahl erhalten wird.\n    #\n    # Beispiele:\n    # >>> int_to_bool_to_int 0\n    # 0\n    # >>> int_to_bool_to_int -5\n    # 1",
      "ha": "int_to_bool_to_int() {\n    # Canza wani lamba zuwa wani darajar boolean, sannan ya canza wannan boolean din zuwa wani lamba.\n    # Tsarin yana dauke da sanya wani darajar lamba zuwa wani canji na boolean sannan\n    # sanya wannan darajar boolean din zuwa wani canji na lamba.\n    # Args:\n    #     initial_int (int): Darajar lamba ta farko.\n    #\n    # Fitarwa:\n    #     Buga darajar lamba da aka samu bayan canzawa daga lamba zuwa boolean sannan kuma zuwa lamba.\n    #\n    # Misalai:\n    # >>> int_to_bool_to_int 0\n    # 0\n    # >>> int_to_bool_to_int -5\n    # 1",
      "hi": "int_to_bool_to_int() {\n    # एक पूर्णांक को एक बूलियन मान में बदलता है, फिर इस बूलियन को वापस एक पूर्णांक में बदलता है।\n    # प्रक्रिया में एक पूर्णांक मान को एक बूलियन वेरिएबल में असाइन करना और फिर\n    # इस बूलियन मान को वापस एक पूर्णांक वेरिएबल में असाइन करना शामिल है।\n    # तर्क:\n    #     initial_int (int): प्रारंभिक पूर्णांक मान।\n    #\n    # आउटपुट:\n    #     पूर्णांक मान को प्रिंट करता है जो पूर्णांक से बूलियन और फिर से पूर्णांक में रूपांतरण के बाद प्राप्त होता है।\n    #\n    # उदाहरण:\n    # >>> int_to_bool_to_int 0\n    # 0\n    # >>> int_to_bool_to_int -5\n    # 1",
      "hu": "int_to_bool_to_int() {\n    # Egy egész számot logikai értékké alakít, majd ezt a logikai értéket visszaalakítja egész számmá.\n    # A folyamat magában foglalja egy egész szám értékének hozzárendelését egy logikai változóhoz, majd\n    # ennek a logikai értéknek a hozzárendelését egy egész változóhoz.\n    # Argumentumok:\n    #     initial_int (int): A kezdeti egész szám értéke.\n    #\n    # Kimenet:\n    #     Kiírja az egész szám értékét, amelyet az egész számról logikaira, majd vissza egész számra történő átalakítás után kapunk.\n    #\n    # Példák:\n    # >>> int_to_bool_to_int 0\n    # 0\n    # >>> int_to_bool_to_int -5\n    # 1"
    },
    "prompt_bertscore": {
      "sq": "0.9923590865023499",
      "hy": "0.9789543166078295",
      "bn": "0.9929931146786133",
      "bg": "0.9804386814453032",
      "zh": "0.9641666820005441",
      "fr": "0.9635614552295308",
      "de": "0.9778993906541532",
      "ha": "0.9676510561446581",
      "hi": "0.9880237798058824",
      "hu": "0.9773086639009554"
    },
    "canonical_solution": "    local initial_int=$1\n    local bool_val\n    local final_int\n\n    # Convert initial_int to boolean\n    if [[ initial_int -ne 0 ]]; then\n        bool_val=1\n    else\n        bool_val=0\n    fi\n\n    # Convert boolean back to integer\n    final_int=$bool_val\n\n    echo \"$final_int\"\n}",
    "instruction": {
      "en": "Write a Shell function `int_to_bool_to_int() {` to solve the following problem: Converts an integer to a boolean value, then converts this boolean back to an integer.\n The process involves assigning an integer value to a boolean variable and then\n assigning this boolean value back to an integer variable.\n Args:\n initial_int (int): The initial integer value.\n\n Output:\n Prints the integer value obtained after conversion from integer to boolean and back to integer.\n\n Examples:\n >>> int_to_bool_to_int 0\n 0\n >>> int_to_bool_to_int -5\n 1",
      "sq": "Shkruani një funksion Shell `int_to_bool_to_int() {` për të zgjidhur problemin e mëposhtëm: Konverton një numër të plotë në një vlerë boolean, pastaj konverton këtë boolean përsëri në një numër të plotë. \n Procesi përfshin caktimin e një vlere të plotë një variabli boolean dhe pastaj\n caktimin e kësaj vlere boolean përsëri një variabli të plotë.\n Args:\n initial_int (int): Vlera fillestare e numrit të plotë.\n\n Output:\n Printon vlerën e numrit të plotë të marrë pas konvertimit nga numri i plotë në boolean dhe përsëri në numër të plotë.\n\n Shembuj:\n >>> int_to_bool_to_int 0\n 0\n >>> int_to_bool_to_int -5\n 1",
      "hy": "Գրեք Shell ֆունկցիա `int_to_bool_to_int() {` հետևյալ խնդիրը լուծելու համար: Փոխակերպում է ամբողջ թիվը բուլյան արժեքի, ապա այս բուլյան արժեքը վերափոխում է ամբողջ թվի:\n Գործընթացը ներառում է ամբողջ թվային արժեքի վերագրումը բուլյան փոփոխականին, ապա\n այս բուլյան արժեքի վերագրումը ամբողջ թվային փոփոխականին:\n Արգումենտներ:\n initial_int (int): Սկզբնական ամբողջ թվային արժեքը:\n\n Արդյունք:\n Տպում է ամբողջ թվային արժեքը, որը ստացվել է ամբողջ թվից բուլյան և հետ ամբողջ թվի վերափոխումից հետո:\n\n Օրինակներ:\n >>> int_to_bool_to_int 0\n 0\n >>> int_to_bool_to_int -5\n 1",
      "bn": "একটি Shell ফাংশন `int_to_bool_to_int() {` লিখুন নিম্নলিখিত সমস্যার সমাধানের জন্য: একটি পূর্ণসংখ্যাকে একটি বুলিয়ান মানে রূপান্তর করে, তারপর এই বুলিয়ানকে আবার একটি পূর্ণসংখ্যায় রূপান্তর করে।\n এই প্রক্রিয়াটি একটি পূর্ণসংখ্যা মানকে একটি বুলিয়ান ভেরিয়েবলে নির্ধারণ করা এবং তারপর\n এই বুলিয়ান মানকে আবার একটি পূর্ণসংখ্যা ভেরিয়েবলে নির্ধারণ করার সাথে জড়িত।\n Args:\n initial_int (int): প্রাথমিক পূর্ণসংখ্যা মান।\n\n আউটপুট:\n পূর্ণসংখ্যা মান মুদ্রণ করে যা পূর্ণসংখ্যা থেকে বুলিয়ানে এবং আবার পূর্ণসংখ্যায় রূপান্তরের পর প্রাপ্ত হয়।\n\n উদাহরণ:\n >>> int_to_bool_to_int 0\n 0\n >>> int_to_bool_to_int -5\n 1",
      "bg": "Напишете Shell функция `int_to_bool_to_int() {` за решаване на следния проблем: Преобразува цяло число в булева стойност, след това преобразува тази булева стойност обратно в цяло число.\n Процесът включва присвояване на цяло число на булева променлива и след това\n присвояване на тази булева стойност обратно на променлива от тип цяло число.\n Args:\n initial_int (int): Първоначалната стойност на цялото число.\n\n Output:\n Извежда стойността на цялото число, получена след преобразуването от цяло число в булева стойност и обратно в цяло число.\n\n Примери:\n >>> int_to_bool_to_int 0\n 0\n >>> int_to_bool_to_int -5\n 1",
      "zh": "编写一个 Shell 函数 `int_to_bool_to_int() {` 来解决以下问题：将整数转换为布尔值，然后将此布尔值转换回整数。  \n该过程涉及将整数值赋给布尔变量，然后将此布尔值赋回整数变量。  \n参数:  \ninitial_int (int): 初始整数值。  \n\n输出:  \n打印从整数转换为布尔值再转换回整数后得到的整数值。  \n\n示例:  \n>>> int_to_bool_to_int 0  \n0  \n>>> int_to_bool_to_int -5  \n1  ",
      "fr": "Écrire une fonction Shell `int_to_bool_to_int() {` pour résoudre le problème suivant : Convertit un entier en une valeur booléenne, puis reconvertit ce booléen en un entier.\n Le processus implique d'assigner une valeur entière à une variable booléenne puis\n d'assigner cette valeur booléenne à une variable entière.\n Args:\n initial_int (int): La valeur entière initiale.\n\n Output:\n Affiche la valeur entière obtenue après conversion de l'entier en booléen puis de nouveau en entier.\n\n Exemples:\n >>> int_to_bool_to_int 0\n 0\n >>> int_to_bool_to_int -5\n 1",
      "de": "Schreiben Sie eine Shell-Funktion `int_to_bool_to_int() {`, um das folgende Problem zu lösen: Konvertiert eine Ganzzahl in einen booleschen Wert und konvertiert diesen booleschen Wert dann zurück in eine Ganzzahl.\n Der Prozess beinhaltet das Zuweisen eines Ganzzahlwertes zu einer booleschen Variablen und dann\n das Zuweisen dieses booleschen Wertes zurück zu einer Ganzzahlvariablen.\n Args:\n initial_int (int): Der anfängliche Ganzzahlwert.\n\n Ausgabe:\n Gibt den Ganzzahlwert aus, der nach der Konvertierung von Ganzzahl zu Boolean und zurück zu Ganzzahl erhalten wurde.\n\n Beispiele:\n >>> int_to_bool_to_int 0\n 0\n >>> int_to_bool_to_int -5\n 1",
      "ha": "Rubuta aikin Shell `int_to_bool_to_int() {` don warware matsalar mai zuwa: Canza integer zuwa boolean, sannan ya canza wannan boolean din zuwa integer.\n Tsarin yana dauke da sanya darajar integer zuwa wani bambance-bambancen boolean sannan\n sanya wannan darajar boolean din zuwa wani bambance-bambancen integer.\n Args:\n initial_int (int): Darajar integer na farko.\n\n Fitarwa:\n Yana buga darajar integer da aka samu bayan canzawa daga integer zuwa boolean sannan kuma zuwa integer.\n\n Misalai:\n >>> int_to_bool_to_int 0\n 0\n >>> int_to_bool_to_int -5\n 1",
      "hi": "Shell फ़ंक्शन `int_to_bool_to_int() {` लिखें ताकि निम्नलिखित समस्या का समाधान किया जा सके: एक पूर्णांक को एक बूलियन मान में परिवर्तित करता है, फिर इस बूलियन को वापस एक पूर्णांक में परिवर्तित करता है।\n प्रक्रिया में एक पूर्णांक मान को एक बूलियन वेरिएबल को असाइन करना और फिर\n इस बूलियन मान को वापस एक पूर्णांक वेरिएबल को असाइन करना शामिल है।\n Args:\n initial_int (int): प्रारंभिक पूर्णांक मान।\n\n Output:\n पूर्णांक मान को प्रिंट करता है जो पूर्णांक से बूलियन और फिर वापस पूर्णांक में रूपांतरण के बाद प्राप्त होता है।\n\n Examples:\n >>> int_to_bool_to_int 0\n 0\n >>> int_to_bool_to_int -5\n 1",
      "hu": "Írj egy Shell függvényt `int_to_bool_to_int() {` a következő probléma megoldására: Egész számot konvertál egy logikai értékre, majd ezt a logikai értéket visszakonvertálja egész számmá.\n A folyamat magában foglalja egy egész szám értékének hozzárendelését egy logikai változóhoz, majd\n ennek a logikai értéknek a hozzárendelését egy egész szám változóhoz.\n Args:\n initial_int (int): A kezdeti egész szám érték.\n\n Kimenet:\n Kiírja az egész szám értéket, amelyet az egész szám logikaivá, majd vissza egész számmá konvertálása után kapunk.\n\n Példák:\n >>> int_to_bool_to_int 0\n 0\n >>> int_to_bool_to_int -5\n 1"
    },
    "instruction_bertscore": {
      "sq": "0.9990682248825653",
      "hy": "0.9769807251418668",
      "bn": "0.9871078951189306",
      "bg": "0.9803614142270806",
      "zh": "0.973668364907729",
      "fr": "0.9776775205185372",
      "de": "0.985499584923691",
      "ha": "0.9710110876702442",
      "hi": "0.9739204268612622",
      "hu": "0.9763997312773398"
    },
    "level": "easy",
    "test": "test_int_to_bool_to_int() {\n    local result\n\n    result=$(int_to_bool_to_int 0)\n    [[ \"$result\" -eq 0 ]] || { echo \"Test 1 failed: Expected 0, got $result\"; exit 1; }\n\n    result=$(int_to_bool_to_int -5)\n    [[ \"$result\" -eq 1 ]] || { echo \"Test 2 failed: Expected 1, got $result\"; exit 1; }\n\n    result=$(int_to_bool_to_int 10)\n    [[ \"$result\" -eq 1 ]] || { echo \"Test 3 failed: Expected 1, got $result\"; exit 1; }\n\n    result=$(int_to_bool_to_int -1)\n    [[ \"$result\" -eq 1 ]] || { echo \"Test 4 failed: Expected 1, got $result\"; exit 1; }\n\n    result=$(int_to_bool_to_int 1)\n    [[ \"$result\" -eq 1 ]] || { echo \"Test 5 failed: Expected 1, got $result\"; exit 1; }\n}\n\ntest_int_to_bool_to_int",
    "entry_point": "int_to_bool_to_int",
    "signature": "int_to_bool_to_int() {",
    "docstring": {
      "en": " Converts an integer to a boolean value, then converts this boolean back to an integer.\n The process involves assigning an integer value to a boolean variable and then\n assigning this boolean value back to an integer variable.\n Args:\n initial_int (int): The initial integer value.\n\n Output:\n Prints the integer value obtained after conversion from integer to boolean and back to integer.\n\n Examples:\n >>> int_to_bool_to_int 0\n 0\n >>> int_to_bool_to_int -5\n 1",
      "sq": "Konverton një numër të plotë në një vlerë boolean, pastaj konverton këtë boolean përsëri në një numër të plotë. Procesi përfshin caktimin e një vlere të plotë në një variabël boolean dhe pastaj caktimin e kësaj vlere boolean përsëri në një variabël të plotë.\n\nArgs:\n initial_int (int): Vlera fillestare e numrit të plotë.\n\nOutput:\n Shtyp vlerën e numrit të plotë të marrë pas konvertimit nga numri i plotë në boolean dhe përsëri në numër të plotë.\n\nExamples:\n >>> int_to_bool_to_int 0\n 0\n >>> int_to_bool_to_int -5\n 1",
      "hy": "Վերածում է ամբողջ թիվը բուլյան արժեքի, ապա այս բուլյանը վերածում է ամբողջ թվի: Գործընթացը ներառում է ամբողջ թվային արժեքի վերագրումը բուլյան փոփոխականին, այնուհետև այս բուլյան արժեքի վերագրումը ամբողջ թվային փոփոխականին:\nԱրգումենտներ:\ninitial_int (int): Սկզբնական ամբողջ թվային արժեքը:\n\nԵլք:\nՏպում է ամբողջ թվային արժեքը, որը ստացվել է ամբողջ թվից բուլյան և հետ ամբողջ թվի վերածումից հետո:\n\nՕրինակներ:\n>>> int_to_bool_to_int 0\n0\n>>> int_to_bool_to_int -5\n1",
      "bn": "একটি পূর্ণসংখ্যাকে একটি বুলিয়ান মানে রূপান্তর করে, তারপর এই বুলিয়ানকে আবার একটি পূর্ণসংখ্যায় রূপান্তর করে। \nপ্রক্রিয়াটি একটি পূর্ণসংখ্যার মানকে একটি বুলিয়ান ভেরিয়েবলে বরাদ্দ করা এবং তারপর \nএই বুলিয়ান মানকে আবার একটি পূর্ণসংখ্যার ভেরিয়েবলে বরাদ্দ করার অন্তর্ভুক্ত।\nArgs:\n initial_int (int): প্রাথমিক পূর্ণসংখ্যার মান।\n\nOutput:\n পূর্ণসংখ্যার মান মুদ্রণ করে যা পূর্ণসংখ্যা থেকে বুলিয়ানে এবং আবার পূর্ণসংখ্যায় রূপান্তরের পর প্রাপ্ত হয়।\n\nExamples:\n >>> int_to_bool_to_int 0\n 0\n >>> int_to_bool_to_int -5\n 1",
      "bg": "Преобразува цяло число в булева стойност, след това преобразува тази булева стойност обратно в цяло число. Процесът включва присвояване на цяло число на булева променлива и след това присвояване на тази булева стойност обратно на променлива от тип цяло число.\nАргументи:\ninitial_int (int): Началната стойност от тип цяло число.\n\nИзход:\nОтпечатва стойността от тип цяло число, получена след преобразуване от цяло число в булева стойност и обратно в цяло число.\n\nПримери:\n>>> int_to_bool_to_int 0\n0\n>>> int_to_bool_to_int -5\n1",
      "zh": "将整数转换为布尔值，然后将该布尔值转换回整数。  \n该过程涉及将一个整数值赋给一个布尔变量，然后将该布尔值赋回给一个整数变量。  \n参数:  \ninitial_int (int): 初始整数值。  \n\n输出:  \n打印从整数转换为布尔值再转换回整数后获得的整数值。  \n\n示例:  \n>>> int_to_bool_to_int 0  \n0  \n>>> int_to_bool_to_int -5  \n1  ",
      "fr": "Convertit un entier en une valeur booléenne, puis reconvertit ce booléen en un entier. Le processus implique l'affectation d'une valeur entière à une variable booléenne, puis l'affectation de cette valeur booléenne à une variable entière.  \nArgs:  \ninitial_int (int): La valeur entière initiale.  \n\nOutput:  \nAffiche la valeur entière obtenue après conversion de l'entier en booléen et retour à l'entier.  \n\nExamples:  \n>>> int_to_bool_to_int 0  \n0  \n>>> int_to_bool_to_int -5  \n1  ",
      "de": "Konvertiert eine ganze Zahl in einen booleschen Wert und dann diesen booleschen Wert zurück in eine ganze Zahl.\n Der Prozess beinhaltet das Zuweisen eines ganzzahligen Wertes zu einer booleschen Variablen und dann\n das Zuweisen dieses booleschen Wertes zurück zu einer ganzzahligen Variablen.\n Args:\n initial_int (int): Der anfängliche ganzzahlige Wert.\n\n Output:\n Gibt den ganzzahligen Wert aus, der nach der Umwandlung von Ganzzahl zu Booleschem Wert und zurück zu Ganzzahl erhalten wurde.\n\n Examples:\n >>> int_to_bool_to_int 0\n 0\n >>> int_to_bool_to_int -5\n 1",
      "ha": "Converts an integer to a boolean value, then converts this boolean back to an integer.  \nTsarin ya haɗa da sanya ƙimar integer zuwa wani canjin boolean sannan kuma sanya wannan ƙimar boolean zuwa wani canjin integer.  \nArgs:  \ninitial_int (int): Ƙimar integer na farko.  \n\nOutput:  \nYana buga ƙimar integer da aka samu bayan jujjuyawa daga integer zuwa boolean kuma baya zuwa integer.  \n\nExamples:  \n>>> int_to_bool_to_int 0  \n0  \n>>> int_to_bool_to_int -5  \n1  ",
      "hi": "integer को boolean मान में बदलता है, फिर इस boolean को वापस integer में बदलता है। \nइस प्रक्रिया में एक integer मान को boolean चर में असाइन करना और फिर इस boolean मान को वापस integer चर में असाइन करना शामिल है।\nArgs:\ninitial_int (int): प्रारंभिक integer मान।\n\nOutput:\ninteger से boolean और फिर वापस integer में रूपांतरण के बाद प्राप्त integer मान को प्रिंट करता है।\n\nExamples:\n>>> int_to_bool_to_int 0\n0\n>>> int_to_bool_to_int -5\n1",
      "hu": "Átalakít egy egész számot logikai értékké, majd ezt a logikai értéket visszaalakítja egész számmá. A folyamat magában foglalja egy egész szám értékének hozzárendelését egy logikai változóhoz, majd ennek a logikai értéknek a hozzárendelését egy egész szám változóhoz.  \nArgs:  \ninitial_int (int): A kezdeti egész szám értéke.  \n\nOutput:  \nKiírja az egész szám értékét, amelyet az egész szám logikaivá, majd vissza egész számmá alakítása után kapunk.  \n\nExamples:  \n>>> int_to_bool_to_int 0  \n0  \n>>> int_to_bool_to_int -5  \n1  "
    },
    "docstring_bertscore": {
      "sq": "0.9989556014565185",
      "hy": "0.9816644295266694",
      "bn": "0.9820958547142773",
      "bg": "0.9752121202291322",
      "zh": "0.9721693014220587",
      "fr": "0.9681190293223763",
      "de": "0.9826913485966199",
      "ha": "0.9868077646131869",
      "hi": "0.9713970265005951",
      "hu": "0.9718850613467978"
    }
  },
  {
    "task_id": "Shell/45",
    "prompt": {
      "en": "reverse_number() {\n    # Reverses a three-digit number.\n    # This function takes a three-digit number as input and prints its reverse.\n    # The output maintains leading zeros if present.\n    # Args:\n    #     number (int): A three-digit number to be reversed.\n    #\n    # Output:\n    #     Prints the reversed number, maintaining any leading zeros.\n    #\n    # Examples:\n    # >>> reverse_number 123\n    # 321\n    # >>> reverse_number 040\n    # 040",
      "sq": "reverse_number() {\n    # Kthen një numër treshe në të kundërt.\n    # Kjo funksion merr një numër treshe si hyrje dhe printon të kundërtën e tij.\n    # Rezultati ruan zerot udhëheqëse nëse janë të pranishme.\n    # Args:\n    #     number (int): Një numër treshe që do të kthehet në të kundërt.\n    #\n    # Dalja:\n    #     Printon numrin e kthyer në të kundërt, duke ruajtur çdo zero udhëheqëse.\n    #\n    # Shembuj:\n    # >>> reverse_number 123\n    # 321\n    # >>> reverse_number 040\n    # 040",
      "hy": "reverse_number() {\n    # Շրջում է եռանիշ թիվը։\n    # Այս ֆունկցիան ընդունում է եռանիշ թիվ որպես մուտք և տպում է դրա շրջված տարբերակը։\n    # Ելքը պահպանում է առաջատար զրոները, եթե կան։\n    # Արգումենտներ:\n    #     number (int): Շրջելու ենթակա եռանիշ թիվ։\n    #\n    # Ելք:\n    #     Տպում է շրջված թիվը՝ պահպանելով առաջատար զրոները։\n    #\n    # Օրինակներ:\n    # >>> reverse_number 123\n    # 321\n    # >>> reverse_number 040\n    # 040",
      "bn": "reverse_number() {\n    # একটি তিন অঙ্কের সংখ্যা উল্টায়।\n    # এই ফাংশনটি একটি তিন অঙ্কের সংখ্যা ইনপুট হিসেবে নেয় এবং তার উল্টোটি প্রিন্ট করে।\n    # আউটপুটে যদি শূন্য দিয়ে শুরু হয় তবে তা বজায় থাকে।\n    # আর্গুমেন্টসমূহ:\n    #     number (int): একটি তিন অঙ্কের সংখ্যা যা উল্টানো হবে।\n    #\n    # আউটপুট:\n    #     উল্টানো সংখ্যাটি প্রিন্ট করে, যদি শূন্য দিয়ে শুরু হয় তবে তা বজায় থাকে।\n    #\n    # উদাহরণসমূহ:\n    # >>> reverse_number 123\n    # 321\n    # >>> reverse_number 040\n    # 040",
      "bg": "reverse_number() {\n    # Обръща трицифрено число.\n    # Тази функция приема трицифрено число като вход и отпечатва неговото обръщане.\n    # Изходът запазва водещите нули, ако има такива.\n    # Аргументи:\n    #     number (int): Трицифрено число, което да бъде обърнато.\n    #\n    # Изход:\n    #     Отпечатва обърнатото число, запазвайки всички водещи нули.\n    #\n    # Примери:\n    # >>> reverse_number 123\n    # 321\n    # >>> reverse_number 040\n    # 040",
      "zh": "reverse_number() {\n    # 反转一个三位数。\n    # 此函数接受一个三位数作为输入并打印其反转。\n    # 输出保留任何存在的前导零。\n    # 参数：\n    #     number (int): 要反转的三位数。\n    #\n    # 输出：\n    #     打印反转后的数字，保留任何前导零。\n    #\n    # 示例：\n    # >>> reverse_number 123\n    # 321\n    # >>> reverse_number 040\n    # 040",
      "fr": "reverse_number() {\n    # Inverse un nombre à trois chiffres.\n    # Cette fonction prend un nombre à trois chiffres en entrée et imprime son inverse.\n    # La sortie conserve les zéros initiaux s'ils sont présents.\n    # Args:\n    #     number (int): Un nombre à trois chiffres à inverser.\n    #\n    # Sortie:\n    #     Imprime le nombre inversé, en conservant les zéros initiaux.\n    #\n    # Exemples:\n    # >>> reverse_number 123\n    # 321\n    # >>> reverse_number 040\n    # 040",
      "de": "reverse_number() {\n    # Kehrt eine dreistellige Zahl um.\n    # Diese Funktion nimmt eine dreistellige Zahl als Eingabe und gibt deren Umkehrung aus.\n    # Die Ausgabe behält führende Nullen bei, falls vorhanden.\n    # Argumente:\n    #     number (int): Eine dreistellige Zahl, die umgekehrt werden soll.\n    #\n    # Ausgabe:\n    #     Gibt die umgekehrte Zahl aus und behält dabei alle führenden Nullen bei.\n    #\n    # Beispiele:\n    # >>> reverse_number 123\n    # 321\n    # >>> reverse_number 040\n    # 040",
      "ha": "reverse_number() {\n    # Juya lambar da ke da tsawon lambobi uku.\n    # Wannan aikin yana karɓar lambar da ke da tsawon lambobi uku a matsayin shigarwa kuma yana buga juyawarta.\n    # Fitarwa tana kiyaye sifili na farko idan akwai.\n    # Args:\n    #     number (int): Lamba mai tsawon lambobi uku da za a juyar.\n    #\n    # Fitarwa:\n    #     Yana buga lambar da aka juyar, yana kiyaye duk wani sifili na farko.\n    #\n    # Misalai:\n    # >>> reverse_number 123\n    # 321\n    # >>> reverse_number 040\n    # 040",
      "hi": "reverse_number() {\n    # एक तीन-अंकीय संख्या को उलट देता है।\n    # यह फ़ंक्शन एक तीन-अंकीय संख्या को इनपुट के रूप में लेता है और उसका उलटा प्रिंट करता है।\n    # आउटपुट में अग्रणी शून्य बनाए रखे जाते हैं यदि उपस्थित हों।\n    # तर्क:\n    #     number (int): उलटने के लिए एक तीन-अंकीय संख्या।\n    #\n    # आउटपुट:\n    #     उलटी संख्या प्रिंट करता है, किसी भी अग्रणी शून्य को बनाए रखते हुए।\n    #\n    # उदाहरण:\n    # >>> reverse_number 123\n    # 321\n    # >>> reverse_number 040\n    # 040",
      "hu": "reverse_number() {\n    # Megfordít egy háromjegyű számot.\n    # Ez a függvény egy háromjegyű számot vesz bemenetként, és kiírja a fordítottját.\n    # A kimenet megőrzi a vezető nullákat, ha vannak.\n    # Arg:\n    #     number (int): Egy háromjegyű szám, amelyet meg kell fordítani.\n    #\n    # Kimenet:\n    #     Kiírja a megfordított számot, megőrizve a vezető nullákat.\n    #\n    # Példák:\n    # >>> reverse_number 123\n    # 321\n    # >>> reverse_number 040\n    # 040"
    },
    "prompt_bertscore": {
      "sq": "0.9918758187852921",
      "hy": "0.9651441421056168",
      "bn": "0.9470940034898334",
      "bg": "0.9665073424106593",
      "zh": "0.951253323668704",
      "fr": "0.9811128329585356",
      "de": "0.9603639033556312",
      "ha": "0.9856334618005086",
      "hi": "0.9673705900466368",
      "hu": "0.9717813762878976"
    },
    "canonical_solution": "    local number=$1\n    # Reverse the number and maintain leading zeros\n    echo $number | rev\n}",
    "instruction": {
      "en": "Write a Shell function `reverse_number() {` to solve the following problem: Reverses a three-digit number.\n This function takes a three-digit number as input and prints its reverse.\n The output maintains leading zeros if present.\n Args:\n number (int): A three-digit number to be reversed.\n\n Output:\n Prints the reversed number, maintaining any leading zeros.\n\n Examples:\n >>> reverse_number 123\n 321\n >>> reverse_number 040\n 040",
      "sq": "Shkruani një funksion Shell `reverse_number() {` për të zgjidhur problemin e mëposhtëm: Kthen mbrapsht një numër me tre shifra.\n Ky funksion merr një numër me tre shifra si hyrje dhe printon kthimin e tij mbrapsht.\n Rezultati ruan zerot përpara nëse janë të pranishme.\n Argumentet:\n number (int): Një numër me tre shifra për t'u kthyer mbrapsht.\n\n Rezultati:\n Printon numrin e kthyer mbrapsht, duke ruajtur çdo zero përpara.\n\n Shembuj:\n >>> reverse_number 123\n 321\n >>> reverse_number 040\n 040",
      "hy": "Գրեք Shell ֆունկցիա `reverse_number() {` հետևյալ խնդիրը լուծելու համար՝ Շրջում է եռանիշ թիվը:\n Այս ֆունկցիան ընդունում է եռանիշ թիվ որպես մուտք և տպում է դրա շրջված տարբերակը:\n Արդյունքը պահպանում է առաջատար զրոները, եթե կան:\n Արգումենտներ:\n number (int): Եռանիշ թիվ, որը պետք է շրջվի:\n\n Արդյունք:\n Տպում է շրջված թիվը, պահպանելով առաջատար զրոները:\n\n Օրինակներ:\n >>> reverse_number 123\n 321\n >>> reverse_number 040\n 040",
      "bn": "একটি Shell ফাংশন `reverse_number() {` লিখুন নিম্নলিখিত সমস্যার সমাধানের জন্য: একটি তিন-অঙ্কের সংখ্যা উল্টানো।\n এই ফাংশনটি একটি তিন-অঙ্কের সংখ্যা ইনপুট হিসেবে গ্রহণ করে এবং তার উল্টোটি প্রিন্ট করে।\n আউটপুটে যদি শূন্য থাকে তবে তা বজায় থাকে।\n Args:\n number (int): উল্টানোর জন্য একটি তিন-অঙ্কের সংখ্যা।\n\n Output:\n উল্টানো সংখ্যা প্রিন্ট করে, কোনো শূন্য থাকলে তা বজায় রেখে।\n\n Examples:\n >>> reverse_number 123\n 321\n >>> reverse_number 040\n 040",
      "bg": "Напишете Shell функция `reverse_number() {`, за да решите следния проблем: Обръща трицифрено число. \nТази функция приема трицифрено число като вход и отпечатва неговото обърнато. \nИзходът запазва водещите нули, ако има такива.\nАргументи:\nnumber (int): Трицифрено число, което да бъде обърнато.\n\nИзход:\nОтпечатва обърнатото число, запазвайки всички водещи нули.\n\nПримери:\n>>> reverse_number 123\n321\n>>> reverse_number 040\n040",
      "zh": "编写一个 Shell 函数 `reverse_number() {` 来解决以下问题：反转一个三位数。\n此函数接受一个三位数作为输入并打印其反转结果。\n输出保留任何存在的前导零。\n参数：\nnumber (int): 要反转的三位数。\n\n输出：\n打印反转后的数字，保留任何前导零。\n\n示例：\n>>> reverse_number 123\n321\n>>> reverse_number 040\n040",
      "fr": "Écrire une fonction Shell `reverse_number() {` pour résoudre le problème suivant : Inverse un nombre à trois chiffres.\n Cette fonction prend un nombre à trois chiffres en entrée et imprime son inverse.\n La sortie conserve les zéros initiaux s'ils sont présents.\n Args:\n number (int): Un nombre à trois chiffres à inverser.\n\n Output:\n Imprime le nombre inversé, en conservant les zéros initiaux.\n\n Exemples:\n >>> reverse_number 123\n 321\n >>> reverse_number 040\n 040",
      "de": "Schreiben Sie eine Shell-Funktion `reverse_number() {`, um das folgende Problem zu lösen: Kehrt eine dreistellige Zahl um.\n Diese Funktion nimmt eine dreistellige Zahl als Eingabe und gibt deren Umkehrung aus.\n Die Ausgabe behält führende Nullen bei, falls vorhanden.\n Argumente:\n number (int): Eine dreistellige Zahl, die umgekehrt werden soll.\n\n Ausgabe:\n Gibt die umgekehrte Zahl aus und behält dabei alle führenden Nullen bei.\n\n Beispiele:\n >>> reverse_number 123\n 321\n >>> reverse_number 040\n 040",
      "ha": "Rubuta aikin Shell `reverse_number() {` don warware matsalar mai zuwa: Juya lambar mai tsawon uku.\n Wannan aikin yana karɓar lambar mai tsawon uku a matsayin shigarwa kuma yana buga juyawarta.\n Fitarwa tana kiyaye sifili na farko idan akwai.\n Args:\n number (int): Lambar mai tsawon uku da za a juya.\n\n Fitarwa:\n Yana buga lambar da aka juyar, yana kiyaye duk wani sifili na farko.\n\n Misalai:\n >>> reverse_number 123\n 321\n >>> reverse_number 040\n 040",
      "hi": "एक Shell फ़ंक्शन `reverse_number() {` लिखें ताकि निम्नलिखित समस्या का समाधान किया जा सके: एक तीन-अंकीय संख्या को उल्टा करें।\n यह फ़ंक्शन एक तीन-अंकीय संख्या को इनपुट के रूप में लेता है और उसका उल्टा प्रिंट करता है।\n आउटपुट में अग्रणी शून्य बनाए रखे जाते हैं यदि वे मौजूद हों।\n तर्क:\n number (int): एक तीन-अंकीय संख्या जिसे उल्टा करना है।\n\n आउटपुट:\n उल्टी संख्या प्रिंट करता है, किसी भी अग्रणी शून्य को बनाए रखते हुए।\n\n उदाहरण:\n >>> reverse_number 123\n 321\n >>> reverse_number 040\n 040",
      "hu": "Írj egy Shell függvényt `reverse_number() {` a következő probléma megoldására: Megfordít egy háromjegyű számot. \n Ez a függvény egy háromjegyű számot vesz be bemenetként, és kiírja annak fordítottját.\n A kimenet megtartja a vezető nullákat, ha vannak.\n Argok:\n number (int): Egy háromjegyű szám, amelyet meg kell fordítani.\n\n Kimenet:\n Kiírja a fordított számot, megtartva a vezető nullákat.\n\n Példák:\n >>> reverse_number 123\n 321\n >>> reverse_number 040\n 040"
    },
    "instruction_bertscore": {
      "sq": "0.9675727957745304",
      "hy": "0.9605704789519075",
      "bn": "0.9480521964479457",
      "bg": "0.9701438674266459",
      "zh": "0.9440897189766807",
      "fr": "0.9720364176971463",
      "de": "0.96654011642353",
      "ha": "0.9666046712973663",
      "hi": "0.9580909759054489",
      "hu": "0.9839021993994085"
    },
    "level": "easy",
    "test": "test_reverse_number() {\n    local result\n\n    result=$(reverse_number 123)\n    [[ \"$result\" == \"321\" ]] || { echo \"Test 1 failed: Expected 321, got $result\"; exit 1; }\n\n    result=$(reverse_number 040)\n    [[ \"$result\" == \"040\" ]] || { echo \"Test 2 failed: Expected 040, got $result\"; exit 1; }\n\n    result=$(reverse_number 500)\n    [[ \"$result\" == \"005\" ]] || { echo \"Test 3 failed: Expected 005, got $result\"; exit 1; }\n\n    result=$(reverse_number 999)\n    [[ \"$result\" == \"999\" ]] || { echo \"Test 4 failed: Expected 999, got $result\"; exit 1; }\n\n    result=$(reverse_number 100)\n    [[ \"$result\" == \"001\" ]] || { echo \"Test 5 failed: Expected 001, got $result\"; exit 1; }\n}\n\ntest_reverse_number",
    "entry_point": "reverse_number",
    "signature": "reverse_number() {",
    "docstring": {
      "en": " Reverses a three-digit number.\n This function takes a three-digit number as input and prints its reverse.\n The output maintains leading zeros if present.\n Args:\n number (int): A three-digit number to be reversed.\n\n Output:\n Prints the reversed number, maintaining any leading zeros.\n\n Examples:\n >>> reverse_number 123\n 321\n >>> reverse_number 040\n 040",
      "sq": "Kthen një numër tre-shifror.\nKjo funksion merr një numër tre-shifror si hyrje dhe printon kthimin e tij.\nDalja ruan zerot kryesuese nëse janë të pranishme.\nArgs:\nnumber (int): Një numër tre-shifror për t'u kthyer.\n\nOutput:\nPrinton numrin e kthyer, duke ruajtur çdo zero kryesuese.\n\nExamples:\n>>> reverse_number 123\n321\n>>> reverse_number 040\n040",
      "hy": "Եռանիշ թիվը շրջում է:\nԱյս ֆունկցիան ընդունում է եռանիշ թիվ որպես մուտք և տպում է դրա շրջված տարբերակը:\nԵլքը պահպանում է առաջատար զրոները, եթե կան:\nԱրձագանքներ:\nnumber (int): Եռանիշ թիվ, որը պետք է շրջվի:\n\nԵլք:\nՏպում է շրջված թիվը, պահելով ցանկացած առաջատար զրո:\n\nՕրինակներ:\n>>> reverse_number 123\n321\n>>> reverse_number 040\n040",
      "bn": "Reverses a three-digit number.  \nএই ফাংশনটি একটি তিন অঙ্কের সংখ্যা ইনপুট হিসেবে গ্রহণ করে এবং তার বিপরীত মুদ্রণ করে।  \nআউটপুটে যদি শূন্য থাকে তবে তা বজায় থাকে।  \nArgs:  \nnumber (int): একটি তিন অঙ্কের সংখ্যা যা উল্টানো হবে।  \n\nOutput:  \nউল্টানো সংখ্যা মুদ্রণ করে, যেকোনো শূন্য বজায় রেখে।  \n\nExamples:  \n>>> reverse_number 123  \n321  \n>>> reverse_number 040  \n040  ",
      "bg": "Обръща трицифрено число.  \nТази функция приема трицифрено число като вход и отпечатва неговото обръщане.  \nИзходът запазва водещите нули, ако има такива.  \nArgs:  \nnumber (int): Трицифрено число, което да бъде обърнато.  \n\nOutput:  \nОтпечатва обърнатото число, запазвайки всякакви водещи нули.  \n\nExamples:  \n>>> reverse_number 123  \n321  \n>>> reverse_number 040  \n040  ",
      "zh": "反转一个三位数。\n此函数接受一个三位数作为输入并打印其反转。\n输出保持任何存在的前导零。\n参数：\nnumber (int): 要反转的三位数。\n\n输出：\n打印反转后的数字，保持任何前导零。\n\n示例：\n>>> reverse_number 123\n321\n>>> reverse_number 040\n040",
      "fr": "Inverse un nombre à trois chiffres.\nCette fonction prend un nombre à trois chiffres en entrée et imprime son inverse.\nLa sortie conserve les zéros initiaux s'ils sont présents.\nArgs:\n    number (int): Un nombre à trois chiffres à inverser.\n\nOutput:\n    Imprime le nombre inversé, en conservant tous les zéros initiaux.\n\nExamples:\n    >>> reverse_number 123\n    321\n    >>> reverse_number 040\n    040",
      "de": "Kehrt eine dreistellige Zahl um.\nDiese Funktion nimmt eine dreistellige Zahl als Eingabe und gibt deren Umkehrung aus.\nDie Ausgabe behält führende Nullen bei, falls vorhanden.\nArgs:\n number (int): Eine dreistellige Zahl, die umgekehrt werden soll.\n\nOutput:\nGibt die umgekehrte Zahl aus und behält dabei alle führenden Nullen bei.\n\nExamples:\n>>> reverse_number 123\n321\n>>> reverse_number 040\n040",
      "ha": "Reverses lamba mai tsawon uku.\nWannan aikin yana karɓar lamba mai tsawon uku a matsayin shigarwa kuma yana buga juyawarta.\nFitarwa yana kiyaye sifili na farko idan akwai.\nArgs:\n    number (int): Lamba mai tsawon uku da za a juya.\n\nOutput:\n    Yana buga lamban da aka juya, yana kiyaye duk wani sifili na farko.\n\nExamples:\n    >>> reverse_number 123\n    321\n    >>> reverse_number 040\n    040",
      "hi": "तीन अंकों की संख्या को उलट देता है।\nयह फ़ंक्शन इनपुट के रूप में एक तीन अंकों की संख्या लेता है और उसका उल्टा प्रिंट करता है।\nआउटपुट में अग्रणी शून्य बनाए रखे जाते हैं यदि उपस्थित हों।\n\nआर्ग्स:\nnumber (int): एक तीन अंकों की संख्या जिसे उलटना है।\n\nआउटपुट:\nउलटी संख्या प्रिंट करता है, किसी भी अग्रणी शून्य को बनाए रखते हुए।\n\nउदाहरण:\n>>> reverse_number 123\n321\n>>> reverse_number 040\n040",
      "hu": "Megfordít egy háromjegyű számot.  \nEz a függvény egy háromjegyű számot vesz bemenetként, és kiírja annak fordítottját.  \nA kimenet megőrzi a vezető nullákat, ha vannak.  \nArgs:  \nnumber (int): Egy háromjegyű szám, amelyet meg kell fordítani.\n\nKimenet:  \nKiírja a fordított számot, megőrizve a vezető nullákat.\n\nPéldák:  \n>>> reverse_number 123  \n321  \n>>> reverse_number 040  \n040  "
    },
    "docstring_bertscore": {
      "sq": "0.974158187427361",
      "hy": "0.9448320007106081",
      "bn": "0.9548834925124976",
      "bg": "0.9758971964133215",
      "zh": "0.9403983719755283",
      "fr": "0.961979364244588",
      "de": "0.9688015233116122",
      "ha": "0.9855279890681791",
      "hi": "0.9799961329563575",
      "hu": "0.9835595619921234"
    }
  },
  {
    "task_id": "Shell/46",
    "prompt": {
      "en": "calculate_nth_term() {\n    # Calculates the nth term of an arithmetic sequence given the first two terms a1 and a2.\n    # The difference between any two consecutive terms is constant.\n    # Args:\n    #     a1 (int): The first term of the arithmetic sequence.\n    #     a2 (int): The second term of the arithmetic sequence.\n    #     n (int): The term number to calculate.\n    #\n    # Output:\n    #     Prints the value of the nth term in the arithmetic sequence.\n    #\n    # Examples:\n    # >>> calculate_nth_term 1 3 5\n    # 9",
      "sq": "calculate_nth_term() {\n    # Llogarit termin e n-të të një vargu aritmetik duke pasur parasysh dy termat e parë a1 dhe a2.\n    # Diferenca midis çdo dy termave të njëpasnjëshëm është konstante.\n    # Argumentet:\n    #     a1 (int): Termi i parë i vargut aritmetik.\n    #     a2 (int): Termi i dytë i vargut aritmetik.\n    #     n (int): Numri i termit për t'u llogaritur.\n    #\n    # Dalja:\n    #     Printon vlerën e termit të n-të në vargun aritmetik.\n    #\n    # Shembuj:\n    # >>> calculate_nth_term 1 3 5\n    # 9",
      "hy": "calculate_nth_term() {\n    # Հաշվում է թվաբանական հաջորդականության n-րդ անդամը՝ տրված առաջին երկու անդամները a1 և a2:\n    # Ցանկացած երկու հաջորդական անդամների տարբերությունը հաստատուն է:\n    # Արգումենտներ:\n    #     a1 (int): Թվաբանական հաջորդականության առաջին անդամը:\n    #     a2 (int): Թվաբանական հաջորդականության երկրորդ անդամը:\n    #     n (int): Հաշվվող անդամի համարը:\n    #\n    # Արդյունք:\n    #     Տպում է թվաբանական հաջորդականության n-րդ անդամի արժեքը:\n    #\n    # Օրինակներ:\n    # >>> calculate_nth_term 1 3 5\n    # 9",
      "bn": "calculate_nth_term() {\n    # একটি গাণিতিক ক্রমের n-তম পদ গণনা করে, যেখানে প্রথম দুটি পদ a1 এবং a2 দেওয়া আছে।\n    # যেকোনো দুটি পরপর পদের মধ্যে পার্থক্য ধ্রুবক।\n    # আর্গস:\n    #     a1 (int): গাণিতিক ক্রমের প্রথম পদ।\n    #     a2 (int): গাণিতিক ক্রমের দ্বিতীয় পদ।\n    #     n (int): যে পদের সংখ্যা গণনা করতে হবে।\n    #\n    # আউটপুট:\n    #     গাণিতিক ক্রমের n-তম পদের মান মুদ্রণ করে।\n    #\n    # উদাহরণ:\n    # >>> calculate_nth_term 1 3 5\n    # 9",
      "bg": "calculate_nth_term() {\n    # Изчислява n-тия член на аритметична прогресия, като са дадени първите два члена a1 и a2.\n    # Разликата между всеки два последователни члена е постоянна.\n    # Аргументи:\n    #     a1 (int): Първият член на аритметичната прогресия.\n    #     a2 (int): Вторият член на аритметичната прогресия.\n    #     n (int): Номерът на члена, който да се изчисли.\n    #\n    # Изход:\n    #     Отпечатва стойността на n-тия член в аритметичната прогресия.\n    #\n    # Примери:\n    # >>> calculate_nth_term 1 3 5\n    # 9",
      "zh": "calculate_nth_term() {\n    # 计算给定前两个项 a1 和 a2 的等差数列的第 n 项。\n    # 任意两个连续项之间的差是恒定的。\n    # 参数:\n    #     a1 (int): 等差数列的第一项。\n    #     a2 (int): 等差数列的第二项。\n    #     n (int): 要计算的项数。\n    #\n    # 输出:\n    #     打印等差数列中第 n 项的值。\n    #\n    # 示例:\n    # >>> calculate_nth_term 1 3 5\n    # 9",
      "fr": "calculate_nth_term() {\n    # Calcule le nième terme d'une suite arithmétique donnée les deux premiers termes a1 et a2.\n    # La différence entre deux termes consécutifs est constante.\n    # Args:\n    #     a1 (int): Le premier terme de la suite arithmétique.\n    #     a2 (int): Le deuxième terme de la suite arithmétique.\n    #     n (int): Le numéro du terme à calculer.\n    #\n    # Sortie:\n    #     Affiche la valeur du nième terme dans la suite arithmétique.\n    #\n    # Exemples:\n    # >>> calculate_nth_term 1 3 5\n    # 9",
      "de": "calculate_nth_term() {\n    # Berechnet das n-te Glied einer arithmetischen Folge, gegeben die ersten beiden Glieder a1 und a2.\n    # Der Unterschied zwischen zwei aufeinanderfolgenden Gliedern ist konstant.\n    # Argumente:\n    #     a1 (int): Das erste Glied der arithmetischen Folge.\n    #     a2 (int): Das zweite Glied der arithmetischen Folge.\n    #     n (int): Die zu berechnende Gliednummer.\n    #\n    # Ausgabe:\n    #     Gibt den Wert des n-ten Glieds in der arithmetischen Folge aus.\n    #\n    # Beispiele:\n    # >>> calculate_nth_term 1 3 5\n    # 9",
      "ha": "calculate_nth_term() {\n    # Lissafa kalmar nth na jerin lissafi da aka bayar da kalmomi na farko biyu a1 da a2.\n    # Bambanci tsakanin kowanne kalmomi biyu masu jere yana daidai.\n    # Args:\n    #     a1 (int): Kalma ta farko na jerin lissafi.\n    #     a2 (int): Kalma ta biyu na jerin lissafi.\n    #     n (int): Lambar kalma da za a lissafa.\n    #\n    # Fitarwa:\n    #     Buga ƙimar kalmar nth a cikin jerin lissafi.\n    #\n    # Misalai:\n    # >>> calculate_nth_term 1 3 5\n    # 9",
      "hi": "calculate_nth_term() {\n    # दिए गए पहले दो पदों a1 और a2 के साथ एक अंकगणितीय अनुक्रम का nth पद गणना करता है।\n    # किसी भी दो क्रमागत पदों के बीच का अंतर स्थिर होता है।\n    # तर्क:\n    #     a1 (int): अंकगणितीय अनुक्रम का पहला पद।\n    #     a2 (int): अंकगणितीय अनुक्रम का दूसरा पद।\n    #     n (int): गणना करने के लिए पद संख्या।\n    #\n    # आउटपुट:\n    #     अंकगणितीय अनुक्रम में nth पद का मान प्रिंट करता है।\n    #\n    # उदाहरण:\n    # >>> calculate_nth_term 1 3 5\n    # 9",
      "hu": "calculate_nth_term() {\n    # Kiszámítja egy számtani sorozat n-edik tagját az első két tag, a1 és a2 alapján.\n    # Az egymást követő tagok közötti különbség állandó.\n    # Argumentumok:\n    #     a1 (int): A számtani sorozat első tagja.\n    #     a2 (int): A számtani sorozat második tagja.\n    #     n (int): A kiszámítandó tag száma.\n    #\n    # Kimenet:\n    #     Kiírja a számtani sorozat n-edik tagjának értékét.\n    #\n    # Példák:\n    # >>> calculate_nth_term 1 3 5\n    # 9"
    },
    "prompt_bertscore": {
      "sq": "0.9760487513940511",
      "hy": "0.9508079943544238",
      "bn": "0.9650644913228218",
      "bg": "0.9563974532767455",
      "zh": "0.9834032398822489",
      "fr": "0.9836779456992202",
      "de": "0.9672245967165762",
      "ha": "0.9962442967553924",
      "hi": "0.9854060300142237",
      "hu": "0.9478849496671143"
    },
    "canonical_solution": "    local a1=$1\n    local a2=$2\n    local n=$3\n    local d=$((a2 - a1)) # Common difference\n    local nth_term=$((a1 + (n - 1) * d))\n    echo \"$nth_term\"\n}",
    "instruction": {
      "en": "Write a Shell function `calculate_nth_term() {` to solve the following problem: Calculates the nth term of an arithmetic sequence given the first two terms a1 and a2.\n The difference between any two consecutive terms is constant.\n Args:\n a1 (int): The first term of the arithmetic sequence.\n a2 (int): The second term of the arithmetic sequence.\n n (int): The term number to calculate.\n\n Output:\n Prints the value of the nth term in the arithmetic sequence.\n\n Examples:\n >>> calculate_nth_term 1 3 5\n 9",
      "sq": "Shkruani një funksion Shell `calculate_nth_term() {` për të zgjidhur problemin e mëposhtëm: Llogarit termin e n-të të një vargu aritmetik duke pasur parasysh dy termat e parë a1 dhe a2.\n Dallimi midis çdo dy termave të njëpasnjëshëm është konstant.\n Arg:\n a1 (int): Termi i parë i vargut aritmetik.\n a2 (int): Termi i dytë i vargut aritmetik.\n n (int): Numri i termit për t'u llogaritur.\n\n Dalja:\n Printon vlerën e termit të n-të në vargun aritmetik.\n\n Shembuj:\n >>> calculate_nth_term 1 3 5\n 9",
      "hy": "Գրեք Shell ֆունկցիա `calculate_nth_term() {` հետևյալ խնդիրը լուծելու համար: Հաշվարկում է թվաբանական հաջորդականության n-րդ անդամը՝ տրված առաջին երկու անդամները՝ a1 և a2:\n Ցանկացած երկու հաջորդական անդամների տարբերությունը հաստատուն է:\n Արգումենտներ:\n a1 (int): Թվաբանական հաջորդականության առաջին անդամը:\n a2 (int): Թվաբանական հաջորդականության երկրորդ անդամը:\n n (int): Հաշվարկվող անդամի համարը:\n\n Ելք:\n Տպում է թվաբանական հաջորդականության n-րդ անդամի արժեքը:\n\n Օրինակներ:\n >>> calculate_nth_term 1 3 5\n 9",
      "bn": "একটি Shell ফাংশন `calculate_nth_term() {` লিখুন নিম্নলিখিত সমস্যার সমাধানের জন্য: একটি গাণিতিক ক্রমের n-তম পদ গণনা করে যেখানে প্রথম দুটি পদ a1 এবং a2 দেওয়া আছে।\n যে কোনো দুটি পরপর পদের মধ্যে পার্থক্য ধ্রুবক।\n আর্গুমেন্টসমূহ:\n a1 (int): গাণিতিক ক্রমের প্রথম পদ।\n a2 (int): গাণিতিক ক্রমের দ্বিতীয় পদ।\n n (int): যে পদের সংখ্যা গণনা করতে হবে।\n\n আউটপুট:\n গাণিতিক ক্রমের n-তম পদের মান প্রিন্ট করে।\n\n উদাহরণ:\n >>> calculate_nth_term 1 3 5\n 9",
      "bg": "Напишете Shell функция `calculate_nth_term() {`, за да решите следния проблем: Изчислява n-тия член на аритметична прогресия, като са дадени първите два члена a1 и a2.\n Разликата между всеки два последователни члена е константна.\n Аргументи:\n a1 (int): Първият член на аритметичната прогресия.\n a2 (int): Вторият член на аритметичната прогресия.\n n (int): Номерът на члена, който трябва да се изчисли.\n\n Изход:\n Отпечатва стойността на n-тия член в аритметичната прогресия.\n\n Примери:\n >>> calculate_nth_term 1 3 5\n 9",
      "zh": "编写一个 Shell 函数 `calculate_nth_term() {` 来解决以下问题：计算给定前两个项 a1 和 a2 的等差数列的第 n 项。  \n任意两个连续项之间的差是恒定的。  \n参数：  \na1 (int): 等差数列的第一项。  \na2 (int): 等差数列的第二项。  \nn (int): 要计算的项的编号。  \n\n输出：  \n打印等差数列中第 n 项的值。  \n\n示例：  \n>>> calculate_nth_term 1 3 5  \n9",
      "fr": "Écrire une fonction Shell `calculate_nth_term() {` pour résoudre le problème suivant : Calcule le nième terme d'une suite arithmétique donnée les deux premiers termes a1 et a2.\n La différence entre deux termes consécutifs est constante.\n Args:\n a1 (int) : Le premier terme de la suite arithmétique.\n a2 (int) : Le deuxième terme de la suite arithmétique.\n n (int) : Le numéro du terme à calculer.\n\n Sortie :\n Affiche la valeur du nième terme de la suite arithmétique.\n\n Exemples :\n >>> calculate_nth_term 1 3 5\n 9",
      "de": "Schreiben Sie eine Shell-Funktion `calculate_nth_term() {`, um das folgende Problem zu lösen: Berechnet das n-te Glied einer arithmetischen Folge, gegeben die ersten beiden Glieder a1 und a2.\n Der Unterschied zwischen zwei aufeinanderfolgenden Gliedern ist konstant.\n Argumente:\n a1 (int): Das erste Glied der arithmetischen Folge.\n a2 (int): Das zweite Glied der arithmetischen Folge.\n n (int): Die Nummer des zu berechnenden Gliedes.\n\n Ausgabe:\n Gibt den Wert des n-ten Gliedes in der arithmetischen Folge aus.\n\n Beispiele:\n >>> calculate_nth_term 1 3 5\n 9",
      "ha": "Rubuta aikin Shell `calculate_nth_term() {` don warware matsalar mai zuwa: Lissafa tazara ta nth na jerin lissafi da aka bayar da farkon sharuɗɗa biyu a1 da a2.\n Bambanci tsakanin kowanne sharuɗɗa biyu masu jere yana daidai.\n Args:\n a1 (int): Farko sharaɗin jerin lissafi.\n a2 (int): Na biyu sharaɗin jerin lissafi.\n n (int): Lambar sharaɗin da za a lissafa.\n\n Fitarwa:\n Yana buga ƙimar sharaɗin nth a cikin jerin lissafi.\n\n Misalai:\n >>> calculate_nth_term 1 3 5\n 9",
      "hi": "Shell फ़ंक्शन `calculate_nth_term() {` लिखें ताकि निम्नलिखित समस्या का समाधान किया जा सके: पहले दो पद a1 और a2 दिए जाने पर एक अंकगणितीय अनुक्रम के nth पद की गणना करता है।\n किसी भी दो लगातार पदों के बीच का अंतर स्थिर होता है।\n तर्क:\n a1 (int): अंकगणितीय अनुक्रम का पहला पद।\n a2 (int): अंकगणितीय अनुक्रम का दूसरा पद।\n n (int): गणना करने के लिए पद संख्या।\n\n आउटपुट:\n अंकगणितीय अनुक्रम में nth पद का मान प्रिंट करता है।\n\n उदाहरण:\n >>> calculate_nth_term 1 3 5\n 9",
      "hu": "Írj egy Shell függvényt `calculate_nth_term() {` a következő probléma megoldására: Kiszámítja egy számtani sorozat n-edik tagját, ha adott az első két tag, a1 és a2.\n Két egymást követő tag közötti különbség állandó.\n Argumentumok:\n a1 (int): A számtani sorozat első tagja.\n a2 (int): A számtani sorozat második tagja.\n n (int): A kiszámítandó tag sorszáma.\n\n Kimenet:\n Kiírja a számtani sorozat n-edik tagjának értékét.\n\n Példák:\n >>> calculate_nth_term 1 3 5\n 9"
    },
    "instruction_bertscore": {
      "sq": "0.9876245327400023",
      "hy": "0.9755627028516587",
      "bn": "0.9591540457047477",
      "bg": "0.9511561934123779",
      "zh": "0.9728160419427083",
      "fr": "0.9858656607159384",
      "de": "0.9653346286410293",
      "ha": "0.9778896577654824",
      "hi": "0.9733215562624421",
      "hu": "0.950615918775963"
    },
    "level": "easy",
    "test": "test_calculate_nth_term() {\n    local result\n\n    result=$(calculate_nth_term 1 3 5)\n    [[ \"$result\" -eq 9 ]] || { echo \"Test 1 failed: Expected 9, got $result\"; exit 1; }\n\n    result=$(calculate_nth_term 2 5 10)\n    [[ \"$result\" -eq 29 ]] || { echo \"Test 2 failed: Expected 20, got $result\"; exit 1; }\n\n    result=$(calculate_nth_term -1 1 50)\n    [[ \"$result\" -eq 97 ]] || { echo \"Test 3 failed: Expected 97, got $result\"; exit 1; }\n\n    result=$(calculate_nth_term 100 -100 3)\n    [[ \"$result\" -eq -300 ]] || { echo \"Test 4 failed: Expected -300, got $result\"; exit 1; }\n\n}\n\ntest_calculate_nth_term",
    "entry_point": "calculate_nth_term",
    "signature": "calculate_nth_term() {",
    "docstring": {
      "en": " Calculates the nth term of an arithmetic sequence given the first two terms a1 and a2.\n The difference between any two consecutive terms is constant.\n Args:\n a1 (int): The first term of the arithmetic sequence.\n a2 (int): The second term of the arithmetic sequence.\n n (int): The term number to calculate.\n\n Output:\n Prints the value of the nth term in the arithmetic sequence.\n\n Examples:\n >>> calculate_nth_term 1 3 5\n 9",
      "sq": "Llogarit termin e n-të të një progresioni aritmetik duke dhënë dy termat e parë a1 dhe a2. Diferenca midis çdo dy termave radhazi është konstante.\nArgs:\n a1 (int): Termi i parë i progresionit aritmetik.\n a2 (int): Termi i dytë i progresionit aritmetik.\n n (int): Numri i termit për të llogaritur.\n\nOutput:\n Shtyp vlerën e termit të n-të në progresionin aritmetik.\n\nExamples:\n >>> calculate_nth_term 1 3 5\n 9",
      "hy": "Հաշվում է թվաբանական հաջորդականության n-րդ անդամը՝ հաշվի առնելով առաջին երկու անդամները՝ a1 և a2: \n Ցանկացած երկու հաջորդական անդամների միջև տարբերությունը հաստատուն է:\n Արձանագրումներ:\n a1 (int): Թվաբանական հաջորդականության առաջին անդամը:\n a2 (int): Թվաբանական հաջորդականության երկրորդ անդամը:\n n (int): Հաշվարկվող անդամի համարը:\n\n Ելք:\n Տպում է թվաբանական հաջորդականության n-րդ անդամի արժեքը:\n\n Օրինակներ:\n >>> calculate_nth_term 1 3 5\n 9",
      "bn": "nth পদ নির্ণয় করে একটি গাণিতিক ক্রমের, প্রথম দুটি পদ a1 এবং a2 দেওয়া হলে। \nযেকোনো দুটি পরপর পদের মধ্যে পার্থক্য ধ্রুবক হয়।\nArgs:\na1 (int): গাণিতিক ক্রমের প্রথম পদ।\na2 (int): গাণিতিক ক্রমের দ্বিতীয় পদ।\nn (int): যে পদটির সংখ্যা নির্ণয় করতে হবে।\n\nOutput:\nগাণিতিক ক্রমের nth পদের মান মুদ্রণ করে।\n\nExamples:\n>>> calculate_nth_term 1 3 5\n9",
      "bg": "Изчислява n-тия член на аритметична прогресия, като се дадат първите два члена a1 и a2. Разликата между всеки два последователни члена е постоянна.\nArgs:\n a1 (int): Първият член на аритметичната прогресия.\n a2 (int): Вторият член на аритметичната прогресия.\n n (int): Номерът на члена, който да се изчисли.\n\nOutput:\n Отпечатва стойността на n-тия член в аритметичната прогресия.\n\nExamples:\n >>> calculate_nth_term 1 3 5\n 9",
      "zh": "计算给定前两个项 a1 和 a2 的等差数列的第 n 项。  \n任何两个连续项之间的差是恒定的。  \n参数：  \na1 (int): 等差数列的第一项。  \na2 (int): 等差数列的第二项。  \nn (int): 要计算的项的编号。  \n\n输出：  \n打印等差数列中第 n 项的值。  \n\n示例：  \n>>> calculate_nth_term 1 3 5  \n9",
      "fr": "Calcule le nième terme d'une suite arithmétique donnée les deux premiers termes a1 et a2.  \nLa différence entre deux termes consécutifs quelconques est constante.  \nArgs:  \na1 (int): Le premier terme de la suite arithmétique.  \na2 (int): Le deuxième terme de la suite arithmétique.  \nn (int): Le numéro du terme à calculer.  \n\nOutput:  \nAffiche la valeur du nième terme dans la suite arithmétique.  \n\nExamples:  \n>>> calculate_nth_term 1 3 5  \n9",
      "de": "Berechnet das n-te Glied einer arithmetischen Folge, gegeben die ersten beiden Glieder a1 und a2.  \nDer Unterschied zwischen zwei aufeinanderfolgenden Gliedern ist konstant.  \nArgs:  \na1 (int): Das erste Glied der arithmetischen Folge.  \na2 (int): Das zweite Glied der arithmetischen Folge.  \nn (int): Die zu berechnende Gliednummer.  \n\nOutput:  \nGibt den Wert des n-ten Glieds in der arithmetischen Folge aus.  \n\nExamples:  \n>>> calculate_nth_term 1 3 5  \n9",
      "ha": "Yana lissafin kalmar n ta jerin lissafi idan aka ba da kalmomi na farko biyu a1 da a2. Bambanci tsakanin kowanne kalmomi biyu masu jere yana daidai.\n\nArgs:\n a1 (int): Kalmar farko ta jerin lissafi.\n a2 (int): Kalmar biyu ta jerin lissafi.\n n (int): Lambar kalmar da za a lissafa.\n\nOutput:\n Yana buga ƙimar kalmar n a cikin jerin lissafi.\n\nMisalai:\n >>> calculate_nth_term 1 3 5\n 9",
      "hi": "nth पद का मानांकित करता है जब पहले दो पद a1 और a2 दिए गए हों।\n किसी भी दो क्रमागत पदों के बीच का अंतर स्थिर होता है।\n Args:\n a1 (int): अंकगणितीय श्रेणी का पहला पद।\n a2 (int): अंकगणितीय श्रेणी का दूसरा पद।\n n (int): गणना करने के लिए पद संख्या।\n\n Output:\n अंकगणितीय श्रेणी में nth पद का मान प्रिंट करता है।\n\n Examples:\n >>> calculate_nth_term 1 3 5\n 9",
      "hu": "Kiszámítja egy számtani sorozat n-edik tagját, ha adott az első két tag, a1 és a2.  \nA különbség bármely két egymást követő tag között állandó.  \nArgs:  \na1 (int): A számtani sorozat első tagja.  \na2 (int): A számtani sorozat második tagja.  \nn (int): A kiszámítandó tag sorszáma.  \n\nOutput:  \nKiírja a számtani sorozat n-edik tagjának értékét.  \n\nExamples:  \n>>> calculate_nth_term 1 3 5  \n9"
    },
    "docstring_bertscore": {
      "sq": "0.959241641702784",
      "hy": "0.9800455919212351",
      "bn": "0.9668672606610944",
      "bg": "0.9555195069925713",
      "zh": "0.9611157193478482",
      "fr": "0.987463046240221",
      "de": "0.9678379673332119",
      "ha": "0.9873559844648432",
      "hi": "0.9751118118867096",
      "hu": "0.9544230672892587"
    }
  },
  {
    "task_id": "Shell/47",
    "prompt": {
      "en": "multiply_numbers() {\n    # Calculates the product of two positive integers A and B.\n    # Given two positive integers, this function computes their product.\n    # It is important to consider the range of the result to ensure that it does not exceed shell arithmetic limits.\n    # Args:\n    #     A (int): The first positive integer.\n    #     B (int): The second positive integer.\n    #\n    # Output:\n    #     Prints the product of A and B.\n    #\n    # Examples:\n    # >>> multiply_numbers 5 10\n    # 50\n    # >>> multiply_numbers 123 456\n    # 56088",
      "sq": "multiply_numbers() {\n    # Llogarit prodhimin e dy numrave të plotë pozitivë A dhe B.\n    # Duke pasur parasysh dy numra të plotë pozitivë, kjo funksion llogarit prodhimin e tyre.\n    # Është e rëndësishme të merret parasysh diapazoni i rezultatit për të siguruar që ai të mos tejkalojë kufijtë aritmetikë të shell-it.\n    # Argumentet:\n    #     A (int): Numri i parë i plotë pozitiv.\n    #     B (int): Numri i dytë i plotë pozitiv.\n    #\n    # Dalja:\n    #     Printon prodhimin e A dhe B.\n    #\n    # Shembuj:\n    # >>> multiply_numbers 5 10\n    # 50\n    # >>> multiply_numbers 123 456\n    # 56088",
      "hy": "multiply_numbers() {\n    # Հաշվում է երկու դրական ամբողջ թվերի A և B արտադրյալը։\n    # Տրված են երկու դրական ամբողջ թվեր, այս ֆունկցիան հաշվում է նրանց արտադրյալը։\n    # Կարևոր է հաշվի առնել արդյունքի տիրույթը՝ ապահովելու համար, որ այն չգերազանցի shell-ի թվաբանական սահմանները։\n    # Արձ:\n    #     A (int): Առաջին դրական ամբողջ թիվը։\n    #     B (int): Երկրորդ դրական ամբողջ թիվը։\n    #\n    # Արդյունք:\n    #     Տպում է A և B արտադրյալը։\n    #\n    # Օրինակներ:\n    # >>> multiply_numbers 5 10\n    # 50\n    # >>> multiply_numbers 123 456\n    # 56088",
      "bn": "multiply_numbers() {\n    # দুটি ধনাত্মক পূর্ণসংখ্যা A এবং B এর গুণফল গণনা করে।\n    # দুটি ধনাত্মক পূর্ণসংখ্যা দেওয়া হলে, এই ফাংশন তাদের গুণফল গণনা করে।\n    # ফলাফলের পরিসীমা বিবেচনা করা গুরুত্বপূর্ণ যাতে এটি shell এর গাণিতিক সীমা অতিক্রম না করে।\n    # Args:\n    #     A (int): প্রথম ধনাত্মক পূর্ণসংখ্যা।\n    #     B (int): দ্বিতীয় ধনাত্মক পূর্ণসংখ্যা।\n    #\n    # Output:\n    #     A এবং B এর গুণফল প্রিন্ট করে।\n    #\n    # Examples:\n    # >>> multiply_numbers 5 10\n    # 50\n    # >>> multiply_numbers 123 456\n    # 56088",
      "bg": "multiply_numbers() {\n    # Изчислява произведението на две положителни цели числа A и B.\n    # Дадени са две положителни цели числа, тази функция изчислява тяхното произведение.\n    # Важно е да се вземе предвид диапазонът на резултата, за да се гарантира, че не надвишава ограниченията на аритметиката на shell.\n    # Аргументи:\n    #     A (int): Първото положително цяло число.\n    #     B (int): Второто положително цяло число.\n    #\n    # Изход:\n    #     Отпечатва произведението на A и B.\n    #\n    # Примери:\n    # >>> multiply_numbers 5 10\n    # 50\n    # >>> multiply_numbers 123 456\n    # 56088",
      "zh": "multiply_numbers() {\n    # 计算两个正整数 A 和 B 的乘积。\n    # 给定两个正整数，此函数计算它们的乘积。\n    # 重要的是要考虑结果的范围，以确保它不会超过 shell 算术限制。\n    # 参数:\n    #     A (int): 第一个正整数。\n    #     B (int): 第二个正整数。\n    #\n    # 输出:\n    #     打印 A 和 B 的乘积。\n    #\n    # 示例:\n    # >>> multiply_numbers 5 10\n    # 50\n    # >>> multiply_numbers 123 456\n    # 56088",
      "fr": "multiply_numbers() {\n    # Calcule le produit de deux entiers positifs A et B.\n    # Étant donné deux entiers positifs, cette fonction calcule leur produit.\n    # Il est important de considérer la plage du résultat pour s'assurer qu'il ne dépasse pas les limites arithmétiques du shell.\n    # Args:\n    #     A (int): Le premier entier positif.\n    #     B (int): Le deuxième entier positif.\n    #\n    # Sortie:\n    #     Affiche le produit de A et B.\n    #\n    # Exemples:\n    # >>> multiply_numbers 5 10\n    # 50\n    # >>> multiply_numbers 123 456\n    # 56088",
      "de": "multiply_numbers() {\n    # Berechnet das Produkt von zwei positiven ganzen Zahlen A und B.\n    # Gegeben zwei positive ganze Zahlen, berechnet diese Funktion ihr Produkt.\n    # Es ist wichtig, den Bereich des Ergebnisses zu berücksichtigen, um sicherzustellen, dass es die Grenzen der Shell-Arithmetik nicht überschreitet.\n    # Argumente:\n    #     A (int): Die erste positive ganze Zahl.\n    #     B (int): Die zweite positive ganze Zahl.\n    #\n    # Ausgabe:\n    #     Gibt das Produkt von A und B aus.\n    #\n    # Beispiele:\n    # >>> multiply_numbers 5 10\n    # 50\n    # >>> multiply_numbers 123 456\n    # 56088",
      "ha": "multiply_numbers() {\n    # Lissafa samfurin lambobi masu kyau guda biyu A da B.\n    # An ba da lambobi masu kyau guda biyu, wannan aikin yana lissafa samfurinsu.\n    # Yana da mahimmanci a yi la'akari da kewayon sakamakon don tabbatar da cewa bai wuce iyakokin lissafin harsashi ba.\n    # Args:\n    #     A (int): Lamba ta farko mai kyau.\n    #     B (int): Lamba ta biyu mai kyau.\n    #\n    # Fitarwa:\n    #     Yana buga samfurin A da B.\n    #\n    # Misalai:\n    # >>> multiply_numbers 5 10\n    # 50\n    # >>> multiply_numbers 123 456\n    # 56088",
      "hi": "multiply_numbers() {\n    # दो धनात्मक पूर्णांकों A और B का गुणनफल गणना करता है।\n    # दिए गए दो धनात्मक पूर्णांकों का यह फ़ंक्शन उनका गुणनफल गणना करता है।\n    # यह सुनिश्चित करने के लिए परिणाम की सीमा पर विचार करना महत्वपूर्ण है कि यह शेल अंकगणित सीमाओं को पार न करे।\n    # तर्क:\n    #     A (int): पहला धनात्मक पूर्णांक।\n    #     B (int): दूसरा धनात्मक पूर्णांक।\n    #\n    # आउटपुट:\n    #     A और B का गुणनफल प्रिंट करता है।\n    #\n    # उदाहरण:\n    # >>> multiply_numbers 5 10\n    # 50\n    # >>> multiply_numbers 123 456\n    # 56088",
      "hu": "multiply_numbers() {\n    # Két pozitív egész szám, A és B szorzatát számítja ki.\n    # Két pozitív egész szám esetén ez a függvény kiszámítja a szorzatukat.\n    # Fontos figyelembe venni az eredmény tartományát, hogy ne lépje túl a shell aritmetikai korlátait.\n    # Argok:\n    #     A (int): Az első pozitív egész szám.\n    #     B (int): A második pozitív egész szám.\n    #\n    # Kimenet:\n    #     Kiírja A és B szorzatát.\n    #\n    # Példák:\n    # >>> multiply_numbers 5 10\n    # 50\n    # >>> multiply_numbers 123 456\n    # 56088"
    },
    "prompt_bertscore": {
      "sq": "0.9762716146815723",
      "hy": "0.9857133112136847",
      "bn": "0.9832028218277847",
      "bg": "0.9825421771804627",
      "zh": "0.9727723432588806",
      "fr": "0.9786464395172254",
      "de": "0.9748879554472832",
      "ha": "0.9598603753397077",
      "hi": "0.9697940793256435",
      "hu": "0.9710454507261633"
    },
    "canonical_solution": "    local A=$1\n    local B=$2\n    # Calculate and print the product of A and B\n    echo $((A * B))\n}",
    "instruction": {
      "en": "Write a Shell function `multiply_numbers() {` to solve the following problem: Calculates the product of two positive integers A and B.\n Given two positive integers, this function computes their product.\n It is important to consider the range of the result to ensure that it does not exceed shell arithmetic limits.\n Args:\n A (int): The first positive integer.\n B (int): The second positive integer.\n\n Output:\n Prints the product of A and B.\n\n Examples:\n >>> multiply_numbers 5 10\n 50\n >>> multiply_numbers 123 456\n 56088",
      "sq": "Shkruani një funksion Shell `multiply_numbers() {` për të zgjidhur problemin e mëposhtëm: Llogarit produktin e dy numrave të plotë pozitivë A dhe B.\n Duke pasur dy numra të plotë pozitivë, ky funksion llogarit produktin e tyre.\n Është e rëndësishme të merret parasysh diapazoni i rezultatit për të siguruar që ai të mos tejkalojë kufijtë aritmetikë të shell-it.\n Argumentet:\n A (int): Numri i parë i plotë pozitiv.\n B (int): Numri i dytë i plotë pozitiv.\n\n Dalja:\n Printon produktin e A dhe B.\n\n Shembuj:\n >>> multiply_numbers 5 10\n 50\n >>> multiply_numbers 123 456\n 56088",
      "hy": "Գրեք Shell ֆունկցիա `multiply_numbers() {` հետևյալ խնդիրը լուծելու համար: Հաշվում է երկու դրական ամբողջ թվերի A և B արտադրյալը։\n Տրված են երկու դրական ամբողջ թվեր, այս ֆունկցիան հաշվում է նրանց արտադրյալը։\n Կարևոր է հաշվի առնել արդյունքի միջակայքը, որպեսզի այն չգերազանցի shell-ի թվաբանական սահմանները։\n Արգումենտներ:\n A (int): Առաջին դրական ամբողջ թիվը։\n B (int): Երկրորդ դրական ամբողջ թիվը։\n\n Ելք:\n Տպում է A և B արտադրյալը։\n\n Օրինակներ:\n >>> multiply_numbers 5 10\n 50\n >>> multiply_numbers 123 456\n 56088",
      "bn": "একটি Shell ফাংশন `multiply_numbers() {` লিখুন নিম্নলিখিত সমস্যার সমাধানের জন্য: দুটি ধনাত্মক পূর্ণসংখ্যা A এবং B এর গুণফল গণনা করে।\n দুটি ধনাত্মক পূর্ণসংখ্যা দেওয়া হলে, এই ফাংশন তাদের গুণফল গণনা করে।\n ফলাফলের পরিসীমা বিবেচনা করা গুরুত্বপূর্ণ যাতে এটি shell গাণিতিক সীমা অতিক্রম না করে।\n Args:\n A (int): প্রথম ধনাত্মক পূর্ণসংখ্যা।\n B (int): দ্বিতীয় ধনাত্মক পূর্ণসংখ্যা।\n\n আউটপুট:\n A এবং B এর গুণফল মুদ্রণ করে।\n\n উদাহরণ:\n >>> multiply_numbers 5 10\n 50\n >>> multiply_numbers 123 456\n 56088",
      "bg": "Напишете Shell функция `multiply_numbers() {`, за да решите следния проблем: Изчислява произведението на две положителни цели числа A и B.\n Дадени са две положителни цели числа, тази функция изчислява тяхното произведение.\n Важно е да се вземе предвид диапазонът на резултата, за да се гарантира, че не надвишава ограниченията на аритметиката на shell.\n Args:\n A (int): Първото положително цяло число.\n B (int): Второто положително цяло число.\n\n Output:\n Отпечатва произведението на A и B.\n\n Примери:\n >>> multiply_numbers 5 10\n 50\n >>> multiply_numbers 123 456\n 56088",
      "zh": "编写一个 Shell 函数 `multiply_numbers() {` 来解决以下问题：计算两个正整数 A 和 B 的乘积。\n 给定两个正整数，此函数计算它们的乘积。\n 重要的是要考虑结果的范围，以确保它不会超过 shell 算术限制。\n 参数:\n A (int): 第一个正整数。\n B (int): 第二个正整数。\n\n 输出:\n 打印 A 和 B 的乘积。\n\n 示例:\n >>> multiply_numbers 5 10\n 50\n >>> multiply_numbers 123 456\n 56088",
      "fr": "Écrire une fonction Shell `multiply_numbers() {` pour résoudre le problème suivant : Calculer le produit de deux entiers positifs A et B.\n Étant donné deux entiers positifs, cette fonction calcule leur produit.\n Il est important de considérer la plage du résultat pour s'assurer qu'il ne dépasse pas les limites arithmétiques du shell.\n Args:\n A (int) : Le premier entier positif.\n B (int) : Le deuxième entier positif.\n\n Output:\n Affiche le produit de A et B.\n\n Exemples :\n >>> multiply_numbers 5 10\n 50\n >>> multiply_numbers 123 456\n 56088",
      "de": "Schreiben Sie eine Shell-Funktion `multiply_numbers() {`, um das folgende Problem zu lösen: Berechnet das Produkt von zwei positiven ganzen Zahlen A und B.\n Gegeben zwei positive ganze Zahlen, berechnet diese Funktion deren Produkt.\n Es ist wichtig, den Bereich des Ergebnisses zu berücksichtigen, um sicherzustellen, dass es die Grenzen der Shell-Arithmetik nicht überschreitet.\n Args:\n A (int): Die erste positive ganze Zahl.\n B (int): Die zweite positive ganze Zahl.\n\n Ausgabe:\n Gibt das Produkt von A und B aus.\n\n Beispiele:\n >>> multiply_numbers 5 10\n 50\n >>> multiply_numbers 123 456\n 56088",
      "ha": "Rubuta aikin Shell `multiply_numbers() {` don warware matsalar mai zuwa: Lissafa samfurin lambobi guda biyu masu kyau A da B.\n An ba da lambobi guda biyu masu kyau, wannan aikin yana lissafa samfurinsu.\n Yana da mahimmanci a yi la'akari da kewayon sakamakon don tabbatar da cewa bai wuce iyakokin lissafi na shell ba.\n Args:\n A (int): Lamba ta farko mai kyau.\n B (int): Lamba ta biyu mai kyau.\n\n Fitarwa:\n Yana buga samfurin A da B.\n\n Misalai:\n >>> multiply_numbers 5 10\n 50\n >>> multiply_numbers 123 456\n 56088",
      "hi": "शेल फ़ंक्शन `multiply_numbers() {` लिखें ताकि निम्नलिखित समस्या का समाधान किया जा सके: दो धनात्मक पूर्णांकों A और B का गुणनफल गणना करें।\n दिए गए दो धनात्मक पूर्णांकों के लिए, यह फ़ंक्शन उनका गुणनफल गणना करता है।\n यह सुनिश्चित करना महत्वपूर्ण है कि परिणाम की सीमा शेल अंकगणित सीमाओं से अधिक न हो।\n तर्क:\n A (int): पहला धनात्मक पूर्णांक।\n B (int): दूसरा धनात्मक पूर्णांक।\n\n आउटपुट:\n A और B का गुणनफल प्रिंट करता है।\n\n उदाहरण:\n >>> multiply_numbers 5 10\n 50\n >>> multiply_numbers 123 456\n 56088",
      "hu": "Írj egy Shell függvényt `multiply_numbers() {` a következő probléma megoldására: Két pozitív egész szám, A és B szorzatának kiszámítása.\n Két pozitív egész szám esetén ez a függvény kiszámítja a szorzatukat.\n Fontos figyelembe venni az eredmény tartományát, hogy ne lépje túl a shell aritmetikai korlátait.\n Args:\n A (int): Az első pozitív egész szám.\n B (int): A második pozitív egész szám.\n\n Kimenet:\n Kiírja A és B szorzatát.\n\n Példák:\n >>> multiply_numbers 5 10\n 50\n >>> multiply_numbers 123 456\n 56088"
    },
    "instruction_bertscore": {
      "sq": "0.9756937989031418",
      "hy": "0.9747648046110416",
      "bn": "0.9774981572844627",
      "bg": "0.9854962082072135",
      "zh": "0.972387397580435",
      "fr": "0.9759383129021957",
      "de": "0.9824786154585314",
      "ha": "0.9713712045510605",
      "hi": "0.9463688039686751",
      "hu": "0.9693841062191875"
    },
    "level": "easy",
    "test": "test_multiply_numbers() {\n    local result\n\n    result=$(multiply_numbers 5 10)\n    [[ \"$result\" -eq 50 ]] || { echo \"Test 1 failed: Expected 50, got $result\"; exit 1; }\n\n    result=$(multiply_numbers 123 456)\n    [[ \"$result\" -eq 56088 ]] || { echo \"Test 2 failed: Expected 56088, got $result\"; exit 1; }\n\n    result=$(multiply_numbers 1 50000)\n    [[ \"$result\" -eq 50000 ]] || { echo \"Test 3 failed: Expected 50000, got $result\"; exit 1; }\n\n    result=$(multiply_numbers 250 200)\n    [[ \"$result\" -eq 50000 ]] || { echo \"Test 4 failed: Expected 50000, got $result\"; exit 1; }\n\n    result=$(multiply_numbers 500 100)\n    [[ \"$result\" -eq 50000 ]] || { echo \"Test 5 failed: Expected 50000, got $result\"; exit 1; }\n}\n\ntest_multiply_numbers",
    "entry_point": "multiply_numbers",
    "signature": "multiply_numbers() {",
    "docstring": {
      "en": " Calculates the product of two positive integers A and B.\n Given two positive integers, this function computes their product.\n It is important to consider the range of the result to ensure that it does not exceed shell arithmetic limits.\n Args:\n A (int): The first positive integer.\n B (int): The second positive integer.\n\n Output:\n Prints the product of A and B.\n\n Examples:\n >>> multiply_numbers 5 10\n 50\n >>> multiply_numbers 123 456\n 56088",
      "sq": "Llogarit produktin e dy numrave të plotë pozitivë A dhe B.  \nDuke dhënë dy numra të plotë pozitivë, kjo funksion llogarit produktin e tyre.  \nËshtë e rëndësishme të merret parasysh diapazoni i rezultatit për të siguruar që ai të mos tejkalojë kufijtë e aritmetikës së shell-it.  \nArgs:  \nA (int): Numri i parë i plotë pozitiv.  \nB (int): Numri i dytë i plotë pozitiv.  \n\nOutput:  \nShton produktin e A dhe B.  \n\nShembuj:  \n>>> multiply_numbers 5 10  \n50  \n>>> multiply_numbers 123 456  \n56088  ",
      "hy": "Հաշվում է երկու դրական ամբողջ թվերի A և B արտադրյալը։\nԵրկու դրական ամբողջ թվերի դեպքում, այս ֆունկցիան հաշվում է նրանց արտադրյալը։\nԿարևոր է հաշվի առնել արդյունքի տիրույթը, որպեսզի այն չգերազանցի shell-ի թվաբանական սահմանները։\nԱրձագանքներ:\nA (int): Առաջին դրական ամբողջ թիվը։\nB (int): Երկրորդ դրական ամբողջ թիվը։\n\nԵլք:\nՏպում է A և B արտադրյալը։\n\nՕրինակներ:\n>>> multiply_numbers 5 10\n50\n>>> multiply_numbers 123 456\n56088",
      "bn": "দুটি ধনাত্মক পূর্ণসংখ্যা A এবং B এর গুণফল গণনা করে। \nদুটি ধনাত্মক পূর্ণসংখ্যা দেওয়া হলে, এই ফাংশন তাদের গুণফল গণনা করে। \nফলাফলের পরিসীমা বিবেচনা করা গুরুত্বপূর্ণ যাতে এটি শেল গণিতের সীমা অতিক্রম না করে।\n\nআর্গস:\nA (int): প্রথম ধনাত্মক পূর্ণসংখ্যা।\nB (int): দ্বিতীয় ধনাত্মক পূর্ণসংখ্যা।\n\nআউটপুট:\nA এবং B এর গুণফল মুদ্রণ করে।\n\nউদাহরণ:\n>>> multiply_numbers 5 10\n50\n>>> multiply_numbers 123 456\n56088",
      "bg": "Изчислява произведението на две положителни цели числа A и B.  \nДадени са две положителни цели числа, тази функция изчислява тяхното произведение.  \nВажно е да се вземе предвид обхватът на резултата, за да се гарантира, че не надвишава ограниченията на аритметиката на shell.  \nАргументи:  \nA (int): Първото положително цяло число.  \nB (int): Второто положително цяло число.  \n\nИзход:  \nОтпечатва произведението на A и B.  \n\nПримери:  \n>>> multiply_numbers 5 10  \n50  \n>>> multiply_numbers 123 456  \n56088  ",
      "zh": "计算两个正整数 A 和 B 的乘积。\n给定两个正整数，此函数计算它们的乘积。\n重要的是要考虑结果的范围，以确保它不会超过 shell 算术限制。\n参数：\nA (int): 第一个正整数。\nB (int): 第二个正整数。\n\n输出：\n打印 A 和 B 的乘积。\n\n示例：\n>>> multiply_numbers 5 10\n50\n>>> multiply_numbers 123 456\n56088",
      "fr": "Calcule le produit de deux entiers positifs A et B.  \nÉtant donné deux entiers positifs, cette fonction calcule leur produit.  \nIl est important de considérer la plage du résultat pour s'assurer qu'il ne dépasse pas les limites arithmétiques du shell.  \nArgs:  \nA (int): Le premier entier positif.  \nB (int): Le deuxième entier positif.  \n\nOutput:  \nImprime le produit de A et B.  \n\nExamples:  \n>>> multiply_numbers 5 10  \n50  \n>>> multiply_numbers 123 456  \n56088  ",
      "de": "Berechnet das Produkt von zwei positiven ganzen Zahlen A und B.\nGegeben zwei positive ganze Zahlen, berechnet diese Funktion deren Produkt.\nEs ist wichtig, den Bereich des Ergebnisses zu berücksichtigen, um sicherzustellen, dass es die Grenzen der Shell-Arithmetik nicht überschreitet.\nArgs:\nA (int): Die erste positive ganze Zahl.\nB (int): Die zweite positive ganze Zahl.\n\nOutput:\nGibt das Produkt von A und B aus.\n\nBeispiele:\n>>> multiply_numbers 5 10\n50\n>>> multiply_numbers 123 456\n56088",
      "ha": "Yana lissafin samfurin lambobi guda biyu masu kyau A da B.  \nAn ba da lambobi guda biyu masu kyau, wannan aikin yana lissafin samfurinsu.  \nYana da muhimmanci a yi la'akari da kewayon sakamakon don tabbatar da cewa ba ya wuce iyakar lissafin harsashi.  \nArgs:  \nA (int): Lamba ta farko mai kyau.  \nB (int): Lamba ta biyu mai kyau.  \n\nOutput:  \nYana buga samfurin A da B.  \n\nMisalai:  \n>>> multiply_numbers 5 10  \n50  \n>>> multiply_numbers 123 456  \n56088  ",
      "hi": "दो सकारात्मक पूर्णांकों A और B का गुणनफल गणना करता है। \nदिए गए दो सकारात्मक पूर्णांकों के लिए, यह फ़ंक्शन उनके गुणनफल की गणना करता है। \nयह सुनिश्चित करने के लिए परिणाम की सीमा पर विचार करना महत्वपूर्ण है कि यह शेल अंकगणित सीमाओं से अधिक न हो।\n\nआर्ग्स:\nA (int): पहला सकारात्मक पूर्णांक।\nB (int): दूसरा सकारात्मक पूर्णांक।\n\nआउटपुट:\nA और B के गुणनफल को प्रिंट करता है।\n\nउदाहरण:\n>>> multiply_numbers 5 10\n50\n>>> multiply_numbers 123 456\n56088",
      "hu": "Kiszámítja két pozitív egész szám, A és B szorzatát.  \nKét pozitív egész szám esetén ez a függvény kiszámítja azok szorzatát.  \nFontos figyelembe venni az eredmény tartományát annak biztosítása érdekében, hogy az ne lépje túl a shell aritmetikai korlátait.  \nArgs:  \nA (int): Az első pozitív egész szám.  \nB (int): A második pozitív egész szám.  \n\nOutput:  \nKiírja A és B szorzatát.  \n\nExamples:  \n>>> multiply_numbers 5 10  \n50  \n>>> multiply_numbers 123 456  \n56088  "
    },
    "docstring_bertscore": {
      "sq": "0.9732140972263023",
      "hy": "0.9494878968420659",
      "bn": "0.9742441943823491",
      "bg": "0.9719591504789238",
      "zh": "0.9627383309305222",
      "fr": "0.9784070899080783",
      "de": "0.9760932445994029",
      "ha": "0.9334981511687573",
      "hi": "0.9756294426596864",
      "hu": "0.980124646812887"
    }
  },
  {
    "task_id": "Shell/48",
    "prompt": {
      "en": "calculate_power_of_two() {\n    # Calculates 2 to the power of n.\n    # Given a non-negative integer n, this function computes 2^n.\n    # It is important to ensure that n is within the valid range to avoid arithmetic overflow in shell.\n    # Args:\n    #     n (int): The exponent to raise 2 to. Must be a non-negative integer.\n    #\n    # Output:\n    #     Prints the value of 2 raised to the power of n.\n    #\n    # Examples:\n    # >>> calculate_power_of_two 5\n    # 32\n    # >>> calculate_power_of_two 10\n    # 1024",
      "sq": "calculate_power_of_two() {\n    # Llogarit 2 në fuqinë e n.\n    # Duke pasur një numër të plotë jo-negativ n, kjo funksion llogarit 2^n.\n    # Është e rëndësishme të sigurohet që n është brenda diapazonit të vlefshëm për të shmangur mbingarkesën aritmetike në shell.\n    # Argumentet:\n    #     n (int): Eksponenti për të ngritur 2. Duhet të jetë një numër i plotë jo-negativ.\n    #\n    # Dalja:\n    #     Shtyp vlerën e 2 të ngritur në fuqinë e n.\n    #\n    # Shembuj:\n    # >>> calculate_power_of_two 5\n    # 32\n    # >>> calculate_power_of_two 10\n    # 1024",
      "hy": "calculate_power_of_two() {\n    # Հաշվում է 2-ի աստիճանը n-ով։\n    # Տրված է ոչ բացասական ամբողջ թիվ n, այս ֆունկցիան հաշվում է 2^n։\n    # Կարևոր է ապահովել, որ n-ը լինի վավեր տիրույթում՝ խուսափելու համար shell-ում թվաբանական գերահոսքից։\n    # Արգումենտներ:\n    #     n (int): Ցուցիչը, որով պետք է բարձրացնել 2-ը։ Պետք է լինի ոչ բացասական ամբողջ թիվ։\n    #\n    # Արդյունք:\n    #     Տպում է 2-ի արժեքը բարձրացված n աստիճանի։\n    #\n    # Օրինակներ:\n    # >>> calculate_power_of_two 5\n    # 32\n    # >>> calculate_power_of_two 10\n    # 1024",
      "bn": "calculate_power_of_two() {\n    # n এর ঘাত হিসাবে 2 এর মান গণনা করে।\n    # একটি অ-ঋণাত্মক পূর্ণসংখ্যা n দেওয়া হলে, এই ফাংশনটি 2^n গণনা করে।\n    # গাণিতিক ওভারফ্লো এড়াতে n কে বৈধ সীমার মধ্যে রাখা গুরুত্বপূর্ণ।\n    # আর্গুমেন্টসমূহ:\n    #     n (int): 2 এর ঘাত হিসাবে তোলার জন্য। অবশ্যই একটি অ-ঋণাত্মক পূর্ণসংখ্যা হতে হবে।\n    #\n    # আউটপুট:\n    #     n এর ঘাত হিসাবে 2 এর মান প্রিন্ট করে।\n    #\n    # উদাহরণসমূহ:\n    # >>> calculate_power_of_two 5\n    # 32\n    # >>> calculate_power_of_two 10\n    # 1024",
      "bg": "calculate_power_of_two() {\n    # Изчислява 2 на степен n.\n    # Дадено е неотрицателно цяло число n, тази функция изчислява 2^n.\n    # Важно е да се уверите, че n е в допустимия диапазон, за да се избегне аритметично препълване в shell.\n    # Аргументи:\n    #     n (int): Степента, на която да се повдигне 2. Трябва да бъде неотрицателно цяло число.\n    #\n    # Изход:\n    #     Отпечатва стойността на 2, повдигната на степен n.\n    #\n    # Примери:\n    # >>> calculate_power_of_two 5\n    # 32\n    # >>> calculate_power_of_two 10\n    # 1024",
      "zh": "calculate_power_of_two() {\n    # 计算2的n次幂。\n    # 给定一个非负整数n，此函数计算2^n。\n    # 确保n在有效范围内以避免shell中的算术溢出是很重要的。\n    # 参数:\n    #     n (int): 要将2提升到的指数。必须是非负整数。\n    #\n    # 输出:\n    #     打印2的n次幂的值。\n    #\n    # 示例:\n    # >>> calculate_power_of_two 5\n    # 32\n    # >>> calculate_power_of_two 10\n    # 1024",
      "fr": "calculate_power_of_two() {\n    # Calcule 2 à la puissance de n.\n    # Étant donné un entier non négatif n, cette fonction calcule 2^n.\n    # Il est important de s'assurer que n est dans la plage valide pour éviter un débordement arithmétique dans le shell.\n    # Arguments :\n    #     n (int) : L'exposant auquel élever 2. Doit être un entier non négatif.\n    #\n    # Sortie :\n    #     Affiche la valeur de 2 élevé à la puissance de n.\n    #\n    # Exemples :\n    # >>> calculate_power_of_two 5\n    # 32\n    # >>> calculate_power_of_two 10\n    # 1024",
      "de": "calculate_power_of_two() {\n    # Berechnet 2 hoch n.\n    # Gegeben eine nicht-negative ganze Zahl n, berechnet diese Funktion 2^n.\n    # Es ist wichtig sicherzustellen, dass n im gültigen Bereich liegt, um arithmetischen Überlauf in der Shell zu vermeiden.\n    # Argumente:\n    #     n (int): Der Exponent, auf den 2 erhöht werden soll. Muss eine nicht-negative ganze Zahl sein.\n    #\n    # Ausgabe:\n    #     Gibt den Wert von 2 hoch n aus.\n    #\n    # Beispiele:\n    # >>> calculate_power_of_two 5\n    # 32\n    # >>> calculate_power_of_two 10\n    # 1024",
      "ha": "calculate_power_of_two() {\n    # Lissafa 2 zuwa ikon n.\n    # An ba da lamba mara kyau n, wannan aikin yana lissafin 2^n.\n    # Yana da mahimmanci a tabbatar cewa n yana cikin sahihin kewayon don guje wa cikar lissafi a cikin harsashin.\n    # Args:\n    #     n (int): Matsayin da za a ɗaga 2 zuwa. Dole ne ya zama lamba mara kyau.\n    #\n    # Fitarwa:\n    #     Yana buga ƙimar 2 da aka ɗaga zuwa ikon n.\n    #\n    # Misalai:\n    # >>> calculate_power_of_two 5\n    # 32\n    # >>> calculate_power_of_two 10\n    # 1024",
      "hi": "calculate_power_of_two() {\n    # n का घातांक के रूप में 2 की गणना करता है।\n    # दिए गए एक गैर-ऋणात्मक पूर्णांक n के लिए, यह फ़ंक्शन 2^n की गणना करता है।\n    # यह सुनिश्चित करना महत्वपूर्ण है कि n वैध सीमा के भीतर है ताकि शेल में अंकगणितीय ओवरफ्लो से बचा जा सके।\n    # तर्क:\n    #     n (int): 2 को उठाने के लिए घातांक। एक गैर-ऋणात्मक पूर्णांक होना चाहिए।\n    #\n    # आउटपुट:\n    #     n के घातांक के रूप में 2 की गणना का मान प्रिंट करता है।\n    #\n    # उदाहरण:\n    # >>> calculate_power_of_two 5\n    # 32\n    # >>> calculate_power_of_two 10\n    # 1024",
      "hu": "calculate_power_of_two() {\n    # Kiszámítja a 2 n-edik hatványát.\n    # Adott egy nem negatív egész szám n, ez a függvény kiszámítja a 2^n értékét.\n    # Fontos biztosítani, hogy n a megengedett tartományon belül legyen, hogy elkerüljük az aritmetikai túlcsordulást a shellben.\n    # Args:\n    #     n (int): A kitevő, amelyre a 2-t emeljük. Nem negatív egész számnak kell lennie.\n    #\n    # Kimenet:\n    #     Kiírja a 2 n-edik hatványának értékét.\n    #\n    # Példák:\n    # >>> calculate_power_of_two 5\n    # 32\n    # >>> calculate_power_of_two 10\n    # 1024"
    },
    "prompt_bertscore": {
      "sq": "0.9809799492336232",
      "hy": "0.9590523469496578",
      "bn": "0.9380813485807564",
      "bg": "0.9788718849997",
      "zh": "0.9670484115685982",
      "fr": "0.9703963266409413",
      "de": "0.9645401071168896",
      "ha": "0.9643865658323497",
      "hi": "0.9667971441365891",
      "hu": "0.9381468966064979"
    },
    "canonical_solution": "    local n=$1\n    # Calculate 2^n using left shift operation ((2**n))\n    echo $((2**n))\n}",
    "instruction": {
      "en": "Write a Shell function `calculate_power_of_two() {` to solve the following problem: Calculates 2 to the power of n.\n Given a non-negative integer n, this function computes 2^n.\n It is important to ensure that n is within the valid range to avoid arithmetic overflow in shell.\n Args:\n n (int): The exponent to raise 2 to. Must be a non-negative integer.\n\n Output:\n Prints the value of 2 raised to the power of n.\n\n Examples:\n >>> calculate_power_of_two 5\n 32\n >>> calculate_power_of_two 10\n 1024",
      "sq": "Shkruani një funksion Shell `calculate_power_of_two() {` për të zgjidhur problemin e mëposhtëm: Llogarit 2 në fuqinë e n.\n Duke pasur një numër të plotë jo-negativ n, ky funksion llogarit 2^n.\n Është e rëndësishme të sigurohet që n është brenda diapazonit të vlefshëm për të shmangur mbingarkesën aritmetike në shell.\n Argumentet:\n n (int): Eksponenti për të ngritur 2. Duhet të jetë një numër i plotë jo-negativ.\n\n Dalja:\n Printon vlerën e 2 të ngritur në fuqinë e n.\n\n Shembuj:\n >>> calculate_power_of_two 5\n 32\n >>> calculate_power_of_two 10\n 1024",
      "hy": "Գրեք Shell ֆունկցիա `calculate_power_of_two() {` հետևյալ խնդիրը լուծելու համար: Հաշվարկում է 2-ի n աստիճանը:\n Տրված է ոչ բացասական ամբողջ թիվ n, այս ֆունկցիան հաշվում է 2^n:\n Կարևոր է ապահովել, որ n-ը գտնվի վավեր տիրույթում՝ shell-ում թվաբանական գերհոսքը կանխելու համար:\n Արգումենտներ:\n n (int): Ցուցիչը, որով պետք է բարձրացնել 2-ը: Պետք է լինի ոչ բացասական ամբողջ թիվ:\n\n Արդյունք:\n Տպում է 2-ի n աստիճանի արժեքը:\n\n Օրինակներ:\n >>> calculate_power_of_two 5\n 32\n >>> calculate_power_of_two 10\n 1024",
      "bn": "একটি Shell ফাংশন `calculate_power_of_two() {` লিখুন নিম্নলিখিত সমস্যার সমাধানের জন্য: n এর ঘাত হিসেবে 2 এর মান গণনা করে।\n একটি অ-ঋণাত্মক পূর্ণসংখ্যা n দেওয়া হলে, এই ফাংশনটি 2^n গণনা করে।\n এটি নিশ্চিত করা গুরুত্বপূর্ণ যে n বৈধ সীমার মধ্যে রয়েছে যাতে shell-এ গাণিতিক ওভারফ্লো এড়ানো যায়।\n আর্গুমেন্টসমূহ:\n n (int): 2 এর ঘাত হিসেবে তুলতে হবে। অবশ্যই একটি অ-ঋণাত্মক পূর্ণসংখ্যা হতে হবে।\n\n আউটপুট:\n n এর ঘাত হিসেবে 2 এর মান প্রিন্ট করে।\n\n উদাহরণসমূহ:\n >>> calculate_power_of_two 5\n 32\n >>> calculate_power_of_two 10\n 1024",
      "bg": "Напишете Shell функция `calculate_power_of_two() {`, за да решите следния проблем: Изчислява 2 на степен n.\n Дадено е неотрицателно цяло число n, тази функция изчислява 2^n.\n Важно е да се уверите, че n е в допустимия диапазон, за да избегнете аритметично препълване в shell.\n Аргументи:\n n (int): Степента, на която да се повдигне 2. Трябва да бъде неотрицателно цяло число.\n\n Изход:\n Извежда стойността на 2, повдигнато на степен n.\n\n Примери:\n >>> calculate_power_of_two 5\n 32\n >>> calculate_power_of_two 10\n 1024",
      "zh": "编写一个 Shell 函数 `calculate_power_of_two() {` 来解决以下问题：计算 2 的 n 次方。\n 给定一个非负整数 n，此函数计算 2^n。\n 重要的是要确保 n 在有效范围内，以避免 shell 中的算术溢出。\n 参数：\n n (int): 要将 2 提升到的指数。必须是非负整数。\n\n 输出：\n 打印 2 的 n 次方的值。\n\n 示例：\n >>> calculate_power_of_two 5\n 32\n >>> calculate_power_of_two 10\n 1024",
      "fr": "Écrire une fonction Shell `calculate_power_of_two() {` pour résoudre le problème suivant : Calcule 2 à la puissance de n.\n Étant donné un entier non négatif n, cette fonction calcule 2^n.\n Il est important de s'assurer que n est dans la plage valide pour éviter un dépassement arithmétique dans le shell.\n Args:\n n (int): L'exposant auquel élever 2. Doit être un entier non négatif.\n\n Sortie:\n Affiche la valeur de 2 élevé à la puissance de n.\n\n Exemples:\n >>> calculate_power_of_two 5\n 32\n >>> calculate_power_of_two 10\n 1024",
      "de": "Schreiben Sie eine Shell-Funktion `calculate_power_of_two() {`, um das folgende Problem zu lösen: Berechnet 2 hoch n.\n Gegeben eine nicht-negative ganze Zahl n, berechnet diese Funktion 2^n.\n Es ist wichtig sicherzustellen, dass n innerhalb des gültigen Bereichs liegt, um arithmetischen Überlauf in der Shell zu vermeiden.\n Args:\n n (int): Der Exponent, auf den 2 erhöht werden soll. Muss eine nicht-negative ganze Zahl sein.\n\n Ausgabe:\n Gibt den Wert von 2 hoch n aus.\n\n Beispiele:\n >>> calculate_power_of_two 5\n 32\n >>> calculate_power_of_two 10\n 1024",
      "ha": "Rubuta wani aikin Shell `calculate_power_of_two() {` don warware matsalar mai zuwa: Lissafa 2 zuwa ƙarfin n.\n An ba da wani cikakken lamba n wanda ba shi da tabbatacce, wannan aikin yana lissafin 2^n.\n Yana da muhimmanci a tabbatar cewa n yana cikin sahihin kewayo don guje wa cikar lissafi a cikin shell.\n Args:\n n (int): Matsayin da za a ɗaga 2 zuwa. Dole ne ya zama cikakken lamba mara tabbatacce.\n\n Fitarwa:\n Yana buga ƙimar 2 da aka ɗaga zuwa ƙarfin n.\n\n Misalai:\n >>> calculate_power_of_two 5\n 32\n >>> calculate_power_of_two 10\n 1024",
      "hi": "एक Shell फ़ंक्शन `calculate_power_of_two() {` लिखें ताकि निम्नलिखित समस्या का समाधान किया जा सके: n की शक्ति के लिए 2 की गणना करता है।\n दिए गए एक गैर-ऋणात्मक पूर्णांक n के लिए, यह फ़ंक्शन 2^n की गणना करता है।\n यह सुनिश्चित करना महत्वपूर्ण है कि n वैध सीमा के भीतर है ताकि shell में अंकगणितीय अतिप्रवाह से बचा जा सके।\n तर्क:\n n (int): वह घातांक जिसे 2 पर उठाना है। यह एक गैर-ऋणात्मक पूर्णांक होना चाहिए।\n\n आउटपुट:\n n की शक्ति के लिए 2 का मान प्रिंट करता है।\n\n उदाहरण:\n >>> calculate_power_of_two 5\n 32\n >>> calculate_power_of_two 10\n 1024",
      "hu": "Írj egy Shell függvényt `calculate_power_of_two() {` a következő probléma megoldására: Kiszámítja a 2 hatványát n-re.\n Adott egy nem negatív egész szám n, ez a függvény kiszámítja a 2^n értékét.\n Fontos biztosítani, hogy n az érvényes tartományon belül legyen, hogy elkerüljük az aritmetikai túlcsordulást a shellben.\n Args:\n n (int): A kitevő, amelyre a 2-t emeljük. Nem negatív egész számnak kell lennie.\n\n Kimenet:\n Kiírja a 2 n-edik hatványának értékét.\n\n Példák:\n >>> calculate_power_of_two 5\n 32\n >>> calculate_power_of_two 10\n 1024"
    },
    "instruction_bertscore": {
      "sq": "0.9823699646401054",
      "hy": "0.9632954891493251",
      "bn": "0.9561853160298002",
      "bg": "0.9721867808955897",
      "zh": "0.9648986349546577",
      "fr": "0.9803842567208996",
      "de": "0.9732222410719247",
      "ha": "0.9518307421863724",
      "hi": "0.9480676896176664",
      "hu": "0.956514247940794"
    },
    "level": "easy",
    "test": "test_calculate_power_of_two() {\n    local result\n\n    result=$(calculate_power_of_two 5)\n    [[ \"$result\" -eq 32 ]] || { echo \"Test 1 failed: Expected 32, got $result\"; exit 1; }\n\n    result=$(calculate_power_of_two 10)\n    [[ \"$result\" -eq 1024 ]] || { echo \"Test 2 failed: Expected 1024, got $result\"; exit 1; }\n\n    result=$(calculate_power_of_two 0)\n    [[ \"$result\" -eq 1 ]] || { echo \"Test 3 failed: Expected 1, got $result\"; exit 1; }\n\n    result=$(calculate_power_of_two 15)\n    [[ \"$result\" -eq 32768 ]] || { echo \"Test 4 failed: Expected 32768, got $result\"; exit 1; }\n\n    result=$(calculate_power_of_two 20)\n    [[ \"$result\" -eq 1048576 ]] || { echo \"Test 5 failed: Expected 1048576, got $result\"; exit 1; }\n}\n\ntest_calculate_power_of_two",
    "entry_point": "calculate_power_of_two",
    "signature": "calculate_power_of_two() {",
    "docstring": {
      "en": " Calculates 2 to the power of n.\n Given a non-negative integer n, this function computes 2^n.\n It is important to ensure that n is within the valid range to avoid arithmetic overflow in shell.\n Args:\n n (int): The exponent to raise 2 to. Must be a non-negative integer.\n\n Output:\n Prints the value of 2 raised to the power of n.\n\n Examples:\n >>> calculate_power_of_two 5\n 32\n >>> calculate_power_of_two 10\n 1024",
      "sq": "Llogarit 2 në fuqinë e n.\nDuke pasur një numër të plotë jo-negativ n, kjo funksion llogarit 2^n.\nËshtë e rëndësishme të sigurohet që n është brenda diapazonit të vlefshëm për të shmangur mbingarkesën aritmetike në shell.\nArgumentet:\nn (int): Eksponenti për të ngritur 2. Duhet të jetë një numër i plotë jo-negativ.\n\nDalja:\nShtyp vlerën e 2 të ngritur në fuqinë e n.\n\nShembuj:\n>>> calculate_power_of_two 5\n32\n>>> calculate_power_of_two 10\n1024",
      "hy": "Հաշվում է 2-ի աստիճանը n-ով։\nՏրված է n ոչ բացասական ամբողջ թիվ, այս ֆունկցիան հաշվում է 2^n։\nԿարևոր է ապահովել, որ n-ը լինի վավեր տիրույթում՝ խուսափելու համար shell-ում թվաբանական արտահոսքից։\nԱրձանագրություններ:\nn (int): Ցուցիչը, որով պետք է բարձրացնել 2-ը։ Պետք է լինի ոչ բացասական ամբողջ թիվ։\n\nԵլք:\nՏպում է 2-ի արժեքը բարձրացված n աստիճանի։\n\nՕրինակներ:\n>>> calculate_power_of_two 5\n32\n>>> calculate_power_of_two 10\n1024",
      "bn": "2 এর ঘাত n গণনা করে।  \nএকটি অ-ঋণাত্মক পূর্ণসংখ্যা n দেওয়া হলে, এই ফাংশনটি 2^n গণনা করে।  \nগুরুত্বপূর্ণ যে n বৈধ সীমার মধ্যে রয়েছে তা নিশ্চিত করা, যাতে shell-এ গাণিতিক ওভারফ্লো এড়ানো যায়।  \nArgs:  \nn (int): সূচক যা 2 এর উপর প্রয়োগ করা হবে। অবশ্যই একটি অ-ঋণাত্মক পূর্ণসংখ্যা হতে হবে।\n\nOutput:  \n2 এর ঘাত n এর মান মুদ্রণ করে।\n\nExamples:  \n>>> calculate_power_of_two 5  \n32  \n>>> calculate_power_of_two 10  \n1024  ",
      "bg": "Изчислява 2 на степен n.  \nДадено е неотрицателно цяло число n, тази функция изчислява 2^n.  \nВажно е да се уверите, че n е в допустимия диапазон, за да избегнете аритметично преливане в shell.  \nАргументи:  \nn (int): Степента, на която да се повдигне 2. Трябва да бъде неотрицателно цяло число.\n\nИзход:  \nОтпечатва стойността на 2, повдигнато на степен n.\n\nПримери:  \n>>> calculate_power_of_two 5  \n32  \n>>> calculate_power_of_two 10  \n1024  ",
      "zh": "计算2的n次方。  \n给定一个非负整数n，此函数计算2^n。  \n确保n在有效范围内以避免shell中的算术溢出是很重要的。  \n参数:  \nn (int): 要将2提升到的指数。必须是非负整数。\n\n输出:  \n打印2的n次方的值。\n\n示例:  \n>>> calculate_power_of_two 5  \n32  \n>>> calculate_power_of_two 10  \n1024  ",
      "fr": " Calcule 2 à la puissance de n.\n Étant donné un entier non négatif n, cette fonction calcule 2^n.\n Il est important de s'assurer que n est dans la plage valide pour éviter un débordement arithmétique dans le shell.\n Args:\n n (int): L'exposant auquel élever 2. Doit être un entier non négatif.\n\n Output:\n Affiche la valeur de 2 élevé à la puissance de n.\n\n Examples:\n >>> calculate_power_of_two 5\n 32\n >>> calculate_power_of_two 10\n 1024",
      "de": "Berechnet 2 hoch n.  \nAngenommen, n ist eine nicht-negative ganze Zahl, berechnet diese Funktion 2^n.  \nEs ist wichtig sicherzustellen, dass n innerhalb des gültigen Bereichs liegt, um einen arithmetischen Überlauf in der Shell zu vermeiden.  \nArgs:  \nn (int): Der Exponent, auf den 2 erhoben werden soll. Muss eine nicht-negative ganze Zahl sein.\n\nOutput:  \nGibt den Wert von 2 ausgegeben, der auf die Potenz n erhoben wurde.\n\nBeispiele:  \n>>> calculate_power_of_two 5  \n32  \n>>> calculate_power_of_two 10  \n1024  ",
      "ha": "Yana ƙididdige 2 zuwa ƙarfin n.  \nAn ba da cikakken lamba mara kyau n, wannan aikin yana ƙididdige 2^n.  \nYana da mahimmanci a tabbatar cewa n yana cikin kewayon da ya dace don guje wa cika lissafi a cikin harsashi.  \nArgs:  \nn (int): Ƙarfin da za a ɗaga 2 zuwa. Dole ne ya zama cikakken lamba mara kyau.  \n\nFitarwa:  \nYana buga ƙimar 2 da aka ɗaga zuwa ƙarfin n.  \n\nMisalai:  \n>>> calculate_power_of_two 5  \n32  \n>>> calculate_power_of_two 10  \n1024  ",
      "hi": "2 की घात n की गणना करता है।  \nदिए गए एक गैर-ऋणात्मक पूर्णांक n के लिए, यह फ़ंक्शन 2^n की गणना करता है।  \nयह सुनिश्चित करना महत्वपूर्ण है कि n मान्य सीमा के भीतर है ताकि शेल में अंकगणितीय ओवरफ्लो से बचा जा सके।  \nArgs:  \nn (int): वह घातांक जिसे 2 पर उठाना है। एक गैर-ऋणात्मक पूर्णांक होना चाहिए।  \n\nOutput:  \n2 को n की घात तक उठाए गए मान को प्रिंट करता है।  \n\nExamples:  \n>>> calculate_power_of_two 5  \n32  \n>>> calculate_power_of_two 10  \n1024  ",
      "hu": " Számítja 2-t az n-edik hatványra.\n Adott egy nem negatív egész szám n, ez a függvény kiszámítja 2^n.\n Fontos biztosítani, hogy n az érvényes tartományon belül legyen, hogy elkerüljük az aritmetikai túlcsordulást a shellben.\n Args:\n n (int): Az a kitevő, amelyre 2-t emelünk. Nem negatív egész számnak kell lennie.\n\n Kimenet:\n Kiírja a 2 n-edik hatványra emelt értékét.\n\n Példák:\n >>> calculate_power_of_two 5\n 32\n >>> calculate_power_of_two 10\n 1024"
    },
    "docstring_bertscore": {
      "sq": "0.9731719875855228",
      "hy": "0.9481465458789373",
      "bn": "0.9478752167784436",
      "bg": "0.9619072614162723",
      "zh": "0.9547859649954095",
      "fr": "0.9691072154680249",
      "de": "0.9565349055004216",
      "ha": "0.9214065267232585",
      "hi": "0.9599781631556614",
      "hu": "0.983085034011831"
    }
  },
  {
    "task_id": "Shell/49",
    "prompt": {
      "en": "check_sign() {\n    # Check the sign of a given integer.\n    # If the integer is greater than zero, return \"positive\".\n    # If the integer is zero, return \"zero\".\n    # If the integer is less than zero, return \"negative\".\n    #\n    # Example:\n    # >>> check_sign 95\n    # positive\n    # >>> check_sign 0\n    # zero\n    # >>> check_sign -95\n    # negative",
      "sq": "check_sign() {\n    # Kontrollo shenjën e një numri të plotë të dhënë.\n    # Nëse numri i plotë është më i madh se zero, kthe \"positive\".\n    # Nëse numri i plotë është zero, kthe \"zero\".\n    # Nëse numri i plotë është më i vogël se zero, kthe \"negative\".\n    #\n    # Shembull:\n    # >>> check_sign 95\n    # positive\n    # >>> check_sign 0\n    # zero\n    # >>> check_sign -95\n    # negative",
      "hy": "check_sign() {\n    # Ստուգել տրված ամբողջ թվի նշանը։\n    # Եթե ամբողջ թիվը մեծ է զրոյից, վերադարձնել \"positive\"։\n    # Եթե ամբողջ թիվը զրո է, վերադարձնել \"zero\"։\n    # Եթե ամբողջ թիվը փոքր է զրոյից, վերադարձնել \"negative\"։\n    #\n    # Օրինակ:\n    # >>> check_sign 95\n    # positive\n    # >>> check_sign 0\n    # zero\n    # >>> check_sign -95\n    # negative",
      "bn": "check_sign() {\n    # প্রদত্ত পূর্ণসংখ্যার চিহ্ন পরীক্ষা করুন।\n    # যদি পূর্ণসংখ্যাটি শূন্যের চেয়ে বড় হয়, তাহলে \"positive\" ফেরত দিন।\n    # যদি পূর্ণসংখ্যাটি শূন্য হয়, তাহলে \"zero\" ফেরত দিন।\n    # যদি পূর্ণসংখ্যাটি শূন্যের চেয়ে কম হয়, তাহলে \"negative\" ফেরত দিন।\n    #\n    # উদাহরণ:\n    # >>> check_sign 95\n    # positive\n    # >>> check_sign 0\n    # zero\n    # >>> check_sign -95\n    # negative",
      "bg": "check_sign() {\n    # Проверете знака на дадено цяло число.\n    # Ако числото е по-голямо от нула, върнете \"positive\".\n    # Ако числото е нула, върнете \"zero\".\n    # Ако числото е по-малко от нула, върнете \"negative\".\n    #\n    # Пример:\n    # >>> check_sign 95\n    # positive\n    # >>> check_sign 0\n    # zero\n    # >>> check_sign -95\n    # negative",
      "zh": "check_sign() {\n    # 检查给定整数的符号。\n    # 如果整数大于零，返回 \"positive\"。\n    # 如果整数为零，返回 \"zero\"。\n    # 如果整数小于零，返回 \"negative\"。\n    #\n    # 示例：\n    # >>> check_sign 95\n    # positive\n    # >>> check_sign 0\n    # zero\n    # >>> check_sign -95\n    # negative",
      "fr": "check_sign() {\n    # Vérifiez le signe d'un entier donné.\n    # Si l'entier est supérieur à zéro, renvoyez \"positive\".\n    # Si l'entier est zéro, renvoyez \"zero\".\n    # Si l'entier est inférieur à zéro, renvoyez \"negative\".\n    #\n    # Exemple :\n    # >>> check_sign 95\n    # positive\n    # >>> check_sign 0\n    # zero\n    # >>> check_sign -95\n    # negative",
      "de": "check_sign() {\n    # Überprüfen Sie das Vorzeichen einer gegebenen Ganzzahl.\n    # Wenn die Ganzzahl größer als null ist, geben Sie \"positive\" zurück.\n    # Wenn die Ganzzahl null ist, geben Sie \"zero\" zurück.\n    # Wenn die Ganzzahl kleiner als null ist, geben Sie \"negative\" zurück.\n    #\n    # Beispiel:\n    # >>> check_sign 95\n    # positive\n    # >>> check_sign 0\n    # zero\n    # >>> check_sign -95\n    # negative",
      "ha": "check_sign() {\n    # Duba alamar wani cikakken lamba.\n    # Idan cikakken lambar ya fi sifili girma, mayar da \"positive\".\n    # Idan cikakken lambar sifili ne, mayar da \"zero\".\n    # Idan cikakken lambar ya fi sifili ƙasa, mayar da \"negative\".\n    #\n    # Misali:\n    # >>> check_sign 95\n    # positive\n    # >>> check_sign 0\n    # zero\n    # >>> check_sign -95\n    # negative",
      "hi": "check_sign() {\n    # दिए गए पूर्णांक के चिह्न की जाँच करें।\n    # यदि पूर्णांक शून्य से अधिक है, तो \"positive\" लौटाएं।\n    # यदि पूर्णांक शून्य है, तो \"zero\" लौटाएं।\n    # यदि पूर्णांक शून्य से कम है, तो \"negative\" लौटाएं।\n    #\n    # उदाहरण:\n    # >>> check_sign 95\n    # positive\n    # >>> check_sign 0\n    # zero\n    # >>> check_sign -95\n    # negative",
      "hu": "check_sign() {\n    # Ellenőrzi egy adott egész szám előjelét.\n    # Ha az egész szám nagyobb, mint nulla, adja vissza a \"positive\" értéket.\n    # Ha az egész szám nulla, adja vissza a \"zero\" értéket.\n    # Ha az egész szám kisebb, mint nulla, adja vissza a \"negative\" értéket.\n    #\n    # Példa:\n    # >>> check_sign 95\n    # positive\n    # >>> check_sign 0\n    # zero\n    # >>> check_sign -95\n    # negative"
    },
    "prompt_bertscore": {
      "sq": "1",
      "hy": "0.9970002839856111",
      "bn": "0.9970002839856111",
      "bg": "0.9798465642794382",
      "zh": "0.9970002839856111",
      "fr": "1",
      "de": "1",
      "ha": "0.9932960260096915",
      "hi": "0.9970002839856111",
      "hu": "0.9683200432679836"
    },
    "canonical_solution": "    if [ $1 -gt 0 ]; then\n        echo \"positive\"\n    elif [ $1 -eq 0 ]; then\n        echo \"zero\"\n    else\n        echo \"negative\"\n    fi\n}",
    "instruction": {
      "en": "Write a Shell function `check_sign() {` to solve the following problem: Check the sign of a given integer.\n If the integer is greater than zero, return \"positive\".\n If the integer is zero, return \"zero\".\n If the integer is less than zero, return \"negative\".\n\n Example:\n >>> check_sign 95\n positive\n >>> check_sign 0\n zero\n >>> check_sign -95\n negative",
      "sq": "Shkruani një funksion Shell `check_sign() {` për të zgjidhur problemin e mëposhtëm: Kontrolloni shenjën e një numri të plotë të dhënë.\n Nëse numri i plotë është më i madh se zero, kthe \"positive\".\n Nëse numri i plotë është zero, kthe \"zero\".\n Nëse numri i plotë është më i vogël se zero, kthe \"negative\".\n\n Shembull:\n >>> check_sign 95\n positive\n >>> check_sign 0\n zero\n >>> check_sign -95\n negative",
      "hy": "Գրեք Shell ֆունկցիա `check_sign() {` հետևյալ խնդիրը լուծելու համար: Ստուգեք տրված ամբողջ թվի նշանը։\n Եթե ամբողջ թիվը մեծ է զրոյից, վերադարձնել \"positive\"։\n Եթե ամբողջ թիվը զրո է, վերադարձնել \"zero\"։\n Եթե ամբողջ թիվը փոքր է զրոյից, վերադարձնել \"negative\"։\n\n Օրինակ:\n >>> check_sign 95\n positive\n >>> check_sign 0\n zero\n >>> check_sign -95\n negative",
      "bn": "একটি Shell ফাংশন `check_sign() {` লিখুন নিম্নলিখিত সমস্যার সমাধানের জন্য: প্রদত্ত পূর্ণসংখ্যার চিহ্ন পরীক্ষা করুন।\n যদি পূর্ণসংখ্যাটি শূন্যের চেয়ে বড় হয়, তাহলে \"positive\" ফেরত দিন।\n যদি পূর্ণসংখ্যাটি শূন্য হয়, তাহলে \"zero\" ফেরত দিন।\n যদি পূর্ণসংখ্যাটি শূন্যের চেয়ে কম হয়, তাহলে \"negative\" ফেরত দিন।\n\n উদাহরণ:\n >>> check_sign 95\n positive\n >>> check_sign 0\n zero\n >>> check_sign -95\n negative",
      "bg": "Напишете Shell функция `check_sign() {`, за да решите следния проблем: Проверете знака на дадено цяло число.\n Ако числото е по-голямо от нула, върнете \"positive\".\n Ако числото е нула, върнете \"zero\".\n Ако числото е по-малко от нула, върнете \"negative\".\n\n Пример:\n >>> check_sign 95\n positive\n >>> check_sign 0\n zero\n >>> check_sign -95\n negative",
      "zh": "编写一个 Shell 函数 `check_sign() {` 来解决以下问题：检查给定整数的符号。\n如果整数大于零，返回 \"positive\"。\n如果整数等于零，返回 \"zero\"。\n如果整数小于零，返回 \"negative\"。\n\n示例：\n>>> check_sign 95\npositive\n>>> check_sign 0\nzero\n>>> check_sign -95\nnegative",
      "fr": "Écrire une fonction Shell `check_sign() {` pour résoudre le problème suivant : Vérifier le signe d'un entier donné.\n Si l'entier est supérieur à zéro, retourner \"positive\".\n Si l'entier est zéro, retourner \"zero\".\n Si l'entier est inférieur à zéro, retourner \"negative\".\n\n Exemple :\n >>> check_sign 95\n positive\n >>> check_sign 0\n zero\n >>> check_sign -95\n negative",
      "de": "Schreiben Sie eine Shell-Funktion `check_sign() {`, um das folgende Problem zu lösen: Überprüfen Sie das Vorzeichen einer gegebenen ganzen Zahl.\n Wenn die ganze Zahl größer als null ist, geben Sie \"positive\" zurück.\n Wenn die ganze Zahl null ist, geben Sie \"zero\" zurück.\n Wenn die ganze Zahl kleiner als null ist, geben Sie \"negative\" zurück.\n\n Beispiel:\n >>> check_sign 95\n positive\n >>> check_sign 0\n zero\n >>> check_sign -95\n negative",
      "ha": "Rubuta aikin Shell `check_sign() {` don warware matsalar mai zuwa: Duba alamar wani cikakken lamba da aka bayar.\n Idan lamban ya fi sifili, mayar da \"positive\".\n Idan lamban sifili ne, mayar da \"zero\".\n Idan lamban ya kasa sifili, mayar da \"negative\".\n\n Misali:\n >>> check_sign 95\n positive\n >>> check_sign 0\n zero\n >>> check_sign -95\n negative",
      "hi": "एक शेल फ़ंक्शन `check_sign() {` लिखें ताकि निम्नलिखित समस्या का समाधान किया जा सके: दिए गए पूर्णांक के चिन्ह की जाँच करें।\n यदि पूर्णांक शून्य से बड़ा है, तो \"positive\" लौटाएं।\n यदि पूर्णांक शून्य है, तो \"zero\" लौटाएं।\n यदि पूर्णांक शून्य से कम है, तो \"negative\" लौटाएं।\n\n उदाहरण:\n >>> check_sign 95\n positive\n >>> check_sign 0\n zero\n >>> check_sign -95\n negative",
      "hu": "Írj egy Shell függvényt `check_sign() {` a következő probléma megoldására: Ellenőrizze egy adott egész szám előjelét.\n Ha az egész szám nagyobb, mint nulla, adja vissza a \"positive\" értéket.\n Ha az egész szám nulla, adja vissza a \"zero\" értéket.\n Ha az egész szám kisebb, mint nulla, adja vissza a \"negative\" értéket.\n\n Példa:\n >>> check_sign 95\n positive\n >>> check_sign 0\n zero\n >>> check_sign -95\n negative"
    },
    "instruction_bertscore": {
      "sq": "1",
      "hy": "1",
      "bn": "1",
      "bg": "0.9778835002236703",
      "zh": "0.9898130422782447",
      "fr": "1",
      "de": "0.994289773806009",
      "ha": "0.9819059640700079",
      "hi": "0.998064346936815",
      "hu": "1"
    },
    "level": "easy",
    "test": "\ntest_check_sign() {\n    [[ $(check_sign 95) == \"positive\" ]] || { echo \"Test 1 failed\"; exit 1; }\n    [[ $(check_sign 0) == \"zero\" ]] || { echo \"Test 2 failed\"; exit 1; }\n    [[ $(check_sign -95) == \"negative\" ]] || { echo \"Test 3 failed\"; exit 1; }\n    [[ $(check_sign 1000000000) == \"positive\" ]] || { echo \"Test 4 failed\"; exit 1; }\n    [[ $(check_sign -1000000000) == \"negative\" ]] || { echo \"Test 5 failed\"; exit 1; }\n    [[ $(check_sign 1) == \"positive\" ]] || { echo \"Test 6 failed\"; exit 1; }\n    [[ $(check_sign -1) == \"negative\" ]] || { echo \"Test 7 failed\"; exit 1; }\n}\n\ntest_check_sign",
    "entry_point": "check_sign",
    "signature": "check_sign() {",
    "docstring": {
      "en": " Check the sign of a given integer.\n If the integer is greater than zero, return \"positive\".\n If the integer is zero, return \"zero\".\n If the integer is less than zero, return \"negative\".\n\n Example:\n >>> check_sign 95\n positive\n >>> check_sign 0\n zero\n >>> check_sign -95\n negative",
      "sq": " Kontrolloni shenjën e një numri të dhënë të plotë.\n Nëse numri i plotë është më i madh se zero, kthe \"pozitiv\".\n Nëse numri i plotë është zero, kthe \"zero\".\n Nëse numri i plotë është më i vogël se zero, kthe \"negativ\".\n\n Shembull:\n >>> check_sign 95\n positive\n >>> check_sign 0\n zero\n >>> check_sign -95\n negative",
      "hy": "Ստուգել տրված ամբողջ թվի նշանը։  \nԵթե ամբողջ թիվը մեծ է զրոյից, վերադարձնել \"դրական\"։  \nԵթե ամբողջ թիվը զրո է, վերադարձնել \"զրո\"։  \nԵթե ամբողջ թիվը փոքր է զրոյից, վերադարձնել \"բացասական\"։  \n\nՕրինակ:  \n>>> check_sign 95  \npositive  \n>>> check_sign 0  \nzero  \n>>> check_sign -95  \nnegative  ",
      "bn": " প্রদত্ত পূর্ণসংখ্যার চিহ্ন পরীক্ষা করুন। \n যদি পূর্ণসংখ্যাটি শূন্যের চেয়ে বড় হয়, তাহলে \"positive\" ফেরত দিন।\n যদি পূর্ণসংখ্যাটি শূন্য হয়, তাহলে \"zero\" ফেরত দিন।\n যদি পূর্ণসংখ্যাটি শূন্যের চেয়ে কম হয়, তাহলে \"negative\" ফেরত দিন।\n\n উদাহরণ:\n >>> check_sign 95\n positive\n >>> check_sign 0\n zero\n >>> check_sign -95\n negative",
      "bg": "Проверете знака на дадено цяло число.  \nАко цялото число е по-голямо от нула, върнете \"positive\".  \nАко цялото число е нула, върнете \"zero\".  \nАко цялото число е по-малко от нула, върнете \"negative\".  \n\nПример:  \n>>> check_sign 95  \npositive  \n>>> check_sign 0  \nzero  \n>>> check_sign -95  \nnegative  ",
      "zh": "检查给定整数的符号。\n如果整数大于零，返回“positive”。\n如果整数等于零，返回“zero”。\n如果整数小于零，返回“negative”。\n\n示例：\n>>> check_sign 95\npositive\n>>> check_sign 0\nzero\n>>> check_sign -95\nnegative",
      "fr": "Vérifiez le signe d'un entier donné.  \nSi l'entier est supérieur à zéro, renvoyez \"positive\".  \nSi l'entier est zéro, renvoyez \"zero\".  \nSi l'entier est inférieur à zéro, renvoyez \"negative\".  \n\nExemple :  \n>>> check_sign 95  \npositive  \n>>> check_sign 0  \nzero  \n>>> check_sign -95  \nnegative  ",
      "de": "Überprüfen Sie das Vorzeichen einer gegebenen ganzen Zahl.  \nWenn die ganze Zahl größer als null ist, geben Sie \"positive\" zurück.  \nWenn die ganze Zahl null ist, geben Sie \"zero\" zurück.  \nWenn die ganze Zahl kleiner als null ist, geben Sie \"negative\" zurück.  \n\nBeispiel:  \n>>> check_sign 95  \npositive  \n>>> check_sign 0  \nzero  \n>>> check_sign -95  \nnegative  ",
      "ha": "Duba alamar lamba mai cikakken adadi da aka bayar.\nIdan lambar ta fi sifili, dawo da \"positive\".\nIdan lambar sifili ce, dawo da \"zero\".\nIdan lambar ta fi karanci sifili, dawo da \"negative\".\n\nMisali:\n>>> check_sign 95\npositive\n>>> check_sign 0\nzero\n>>> check_sign -95\nnegative",
      "hi": "दिए गए पूर्णांक के चिह्न की जाँच करें।  \nयदि पूर्णांक शून्य से बड़ा है, तो \"positive\" लौटाएँ।  \nयदि पूर्णांक शून्य है, तो \"zero\" लौटाएँ।  \nयदि पूर्णांक शून्य से कम है, तो \"negative\" लौटाएँ।\n\nउदाहरण:  \n>>> check_sign 95  \npositive  \n>>> check_sign 0  \nzero  \n>>> check_sign -95  \nnegative  ",
      "hu": "Ellenőrizze egy adott egész szám előjelét.\nHa az egész szám nagyobb, mint nulla, térjen vissza a \"pozitív\" értékkel.\nHa az egész szám nulla, térjen vissza a \"nulla\" értékkel.\nHa az egész szám kisebb, mint nulla, térjen vissza a \"negatív\" értékkel.\n\nPélda:\n>>> check_sign 95\npositive\n>>> check_sign 0\nzero\n>>> check_sign -95\nnegative"
    },
    "docstring_bertscore": {
      "sq": "1",
      "hy": "0.9964071736678409",
      "bn": "0.9964071736678409",
      "bg": "1",
      "zh": "0.9870781005617754",
      "fr": "1",
      "de": "1",
      "ha": "0.9675443916300424",
      "hi": "0.9964071736678409",
      "hu": "1"
    }
  },
  {
    "task_id": "Shell/50",
    "prompt": {
      "en": "absolute_value() {\n    # Calculate the absolute value of a given integer.\n    # If the integer is positive, return the number as is.\n    # If the integer is negative, return the number multiplied by -1.\n    #\n    # Example:\n    # >>> absolute_value 95\n    # 95\n    # >>> absolute_value -95\n    # 95\n    # >>> absolute_value 0\n    # 0",
      "sq": "absolute_value() {\n    # Llogarit vlerën absolute të një numri të dhënë të plotë.\n    # Nëse numri i plotë është pozitiv, kthe numrin ashtu siç është.\n    # Nëse numri i plotë është negativ, kthe numrin e shumëzuar me -1.\n    #\n    # Shembull:\n    # >>> absolute_value 95\n    # 95\n    # >>> absolute_value -95\n    # 95\n    # >>> absolute_value 0\n    # 0",
      "hy": "absolute_value() {\n    # Հաշվել տրված ամբողջ թվի բացարձակ արժեքը։\n    # Եթե ամբողջ թիվը դրական է, վերադարձնել թիվը ինչպես կա։\n    # Եթե ամբողջ թիվը բացասական է, վերադարձնել թիվը բազմապատկված -1-ով։\n    #\n    # Օրինակ:\n    # >>> absolute_value 95\n    # 95\n    # >>> absolute_value -95\n    # 95\n    # >>> absolute_value 0\n    # 0",
      "bn": "absolute_value() {\n    # প্রদত্ত পূর্ণসংখ্যার পরম মান গণনা করুন।\n    # যদি পূর্ণসংখ্যাটি ধনাত্মক হয়, তাহলে সংখ্যা যেমন আছে তেমনই ফেরত দিন।\n    # যদি পূর্ণসংখ্যাটি ঋণাত্মক হয়, তাহলে সংখ্যাটিকে -1 দিয়ে গুণ করে ফেরত দিন।\n    #\n    # উদাহরণ:\n    # >>> absolute_value 95\n    # 95\n    # >>> absolute_value -95\n    # 95\n    # >>> absolute_value 0\n    # 0",
      "bg": "absolute_value() {\n    # Изчислява абсолютната стойност на дадено цяло число.\n    # Ако числото е положително, връща числото такова, каквото е.\n    # Ако числото е отрицателно, връща числото умножено по -1.\n    #\n    # Пример:\n    # >>> absolute_value 95\n    # 95\n    # >>> absolute_value -95\n    # 95\n    # >>> absolute_value 0\n    # 0",
      "zh": "absolute_value() {\n    # 计算给定整数的绝对值。\n    # 如果整数是正数，返回该数字本身。\n    # 如果整数是负数，返回该数字乘以 -1。\n    #\n    # 示例：\n    # >>> absolute_value 95\n    # 95\n    # >>> absolute_value -95\n    # 95\n    # >>> absolute_value 0\n    # 0",
      "fr": "absolute_value() {\n    # Calculer la valeur absolue d'un entier donné.\n    # Si l'entier est positif, retourner le nombre tel quel.\n    # Si l'entier est négatif, retourner le nombre multiplié par -1.\n    #\n    # Exemple:\n    # >>> absolute_value 95\n    # 95\n    # >>> absolute_value -95\n    # 95\n    # >>> absolute_value 0\n    # 0",
      "de": "absolute_value() {\n    # Berechne den Absolutwert einer gegebenen ganzen Zahl.\n    # Wenn die ganze Zahl positiv ist, gib die Zahl unverändert zurück.\n    # Wenn die ganze Zahl negativ ist, gib die Zahl multipliziert mit -1 zurück.\n    #\n    # Beispiel:\n    # >>> absolute_value 95\n    # 95\n    # >>> absolute_value -95\n    # 95\n    # >>> absolute_value 0\n    # 0",
      "ha": "absolute_value() {\n    # Lissafa darajar dangi na cikakken lamba da aka bayar.\n    # Idan cikakken lambar tana da kyau, dawo da lambar kamar yadda take.\n    # Idan cikakken lambar tana da mummuna, dawo da lambar da aka ninka da -1.\n    #\n    # Misali:\n    # >>> absolute_value 95\n    # 95\n    # >>> absolute_value -95\n    # 95\n    # >>> absolute_value 0\n    # 0",
      "hi": "absolute_value() {\n    # दिए गए पूर्णांक का परिमाण निकालें।\n    # यदि पूर्णांक धनात्मक है, तो संख्या को वैसे ही लौटाएं।\n    # यदि पूर्णांक ऋणात्मक है, तो संख्या को -1 से गुणा करके लौटाएं।\n    #\n    # उदाहरण:\n    # >>> absolute_value 95\n    # 95\n    # >>> absolute_value -95\n    # 95\n    # >>> absolute_value 0\n    # 0",
      "hu": "absolute_value() {\n    # Számítsa ki egy adott egész szám abszolút értékét.\n    # Ha az egész szám pozitív, adja vissza a számot változatlanul.\n    # Ha az egész szám negatív, adja vissza a számot -1-gyel megszorozva.\n    #\n    # Példa:\n    # >>> absolute_value 95\n    # 95\n    # >>> absolute_value -95\n    # 95\n    # >>> absolute_value 0\n    # 0"
    },
    "prompt_bertscore": {
      "sq": "0.9892068223553262",
      "hy": "0.9945783837496527",
      "bn": "0.987434840726114",
      "bg": "0.9747068045397794",
      "zh": "0.9842003436013419",
      "fr": "1",
      "de": "0.9857580030494175",
      "ha": "0.987434840726114",
      "hi": "0.9682344335737576",
      "hu": "0.9857580030494175"
    },
    "canonical_solution": "    if [ $1 -lt 0 ]; then\n        echo $((-$1))\n    else\n        echo $1\n    fi\n}",
    "instruction": {
      "en": "Write a Shell function `absolute_value() {` to solve the following problem: Calculate the absolute value of a given integer.\n If the integer is positive, return the number as is.\n If the integer is negative, return the number multiplied by -1.\n\n Example:\n >>> absolute_value 95\n 95\n >>> absolute_value -95\n 95\n >>> absolute_value 0\n 0",
      "sq": "Shkruani një funksion Shell `absolute_value() {` për të zgjidhur problemin e mëposhtëm: Llogaritni vlerën absolute të një numri të dhënë të plotë.\n Nëse numri i plotë është pozitiv, kthejeni numrin siç është.\n Nëse numri i plotë është negativ, kthejeni numrin shumëzuar me -1.\n\n Shembull:\n >>> absolute_value 95\n 95\n >>> absolute_value -95\n 95\n >>> absolute_value 0\n 0",
      "hy": "Գրեք Shell ֆունկցիա `absolute_value() {` հետևյալ խնդիրը լուծելու համար: Հաշվել տրված ամբողջ թվի բացարձակ արժեքը։\n Եթե ամբողջ թիվը դրական է, վերադարձնել թիվը ինչպես կա։\n Եթե ամբողջ թիվը բացասական է, վերադարձնել թիվը բազմապատկված -1-ով։\n\n Օրինակ:\n >>> absolute_value 95\n 95\n >>> absolute_value -95\n 95\n >>> absolute_value 0\n 0",
      "bn": "একটি Shell ফাংশন `absolute_value() {` লিখুন নিম্নলিখিত সমস্যার সমাধানের জন্য: একটি প্রদত্ত পূর্ণসংখ্যার পরম মান গণনা করুন।\n যদি পূর্ণসংখ্যাটি ধনাত্মক হয়, তাহলে সংখ্যা যেমন আছে তেমনই ফেরত দিন।\n যদি পূর্ণসংখ্যাটি ঋণাত্মক হয়, তাহলে সংখ্যা -1 দ্বারা গুণ করে ফেরত দিন।\n\n উদাহরণ:\n >>> absolute_value 95\n 95\n >>> absolute_value -95\n 95\n >>> absolute_value 0\n 0",
      "bg": "Напишете Shell функция `absolute_value() {`, за да решите следния проблем: Изчислете абсолютната стойност на дадено цяло число.\n Ако числото е положително, върнете числото такова, каквото е.\n Ако числото е отрицателно, върнете числото умножено по -1.\n\n Пример:\n >>> absolute_value 95\n 95\n >>> absolute_value -95\n 95\n >>> absolute_value 0\n 0",
      "zh": "编写一个 Shell 函数 `absolute_value() {` 来解决以下问题：计算给定整数的绝对值。\n如果整数是正数，则返回该数字本身。\n如果整数是负数，则返回该数字乘以 -1。\n\n示例：\n>>> absolute_value 95\n95\n>>> absolute_value -95\n95\n>>> absolute_value 0\n0",
      "fr": "Écrire une fonction Shell `absolute_value() {` pour résoudre le problème suivant : Calculer la valeur absolue d'un entier donné.\n Si l'entier est positif, retourner le nombre tel quel.\n Si l'entier est négatif, retourner le nombre multiplié par -1.\n\n Exemple :\n >>> absolute_value 95\n 95\n >>> absolute_value -95\n 95\n >>> absolute_value 0\n 0",
      "de": "Schreiben Sie eine Shell-Funktion `absolute_value() {`, um das folgende Problem zu lösen: Berechnen Sie den absoluten Wert einer gegebenen ganzen Zahl.\n Wenn die ganze Zahl positiv ist, geben Sie die Zahl unverändert zurück.\n Wenn die ganze Zahl negativ ist, geben Sie die Zahl multipliziert mit -1 zurück.\n\n Beispiel:\n >>> absolute_value 95\n 95\n >>> absolute_value -95\n 95\n >>> absolute_value 0\n 0",
      "ha": "Rubuta wani aikin Shell `absolute_value() {` don warware matsalar mai zuwa: Lissafa darajar ainihin wata lamba mai cikakken adadi da aka bayar.\n Idan lambar tana da kyau, mayar da lambar kamar yadda take.\n Idan lambar tana da mara kyau, mayar da lambar sau -1.\n\n Misali:\n >>> absolute_value 95\n 95\n >>> absolute_value -95\n 95\n >>> absolute_value 0\n 0",
      "hi": "`absolute_value() {` नामक एक शेल फ़ंक्शन लिखें ताकि निम्नलिखित समस्या का समाधान किया जा सके: दिए गए पूर्णांक का परिमाण निकालें।\n यदि पूर्णांक धनात्मक है, तो संख्या को वैसे ही लौटाएं।\n यदि पूर्णांक ऋणात्मक है, तो संख्या को -1 से गुणा करके लौटाएं।\n\n उदाहरण:\n >>> absolute_value 95\n 95\n >>> absolute_value -95\n 95\n >>> absolute_value 0\n 0",
      "hu": "Írj egy Shell függvényt `absolute_value() {` a következő probléma megoldására: Számítsd ki egy adott egész szám abszolút értékét.\n Ha az egész szám pozitív, add vissza a számot változatlanul.\n Ha az egész szám negatív, add vissza a számot -1-gyel szorozva.\n\n Példa:\n >>> absolute_value 95\n 95\n >>> absolute_value -95\n 95\n >>> absolute_value 0\n 0"
    },
    "instruction_bertscore": {
      "sq": "0.9934996221502522",
      "hy": "1",
      "bn": "0.9934996221502522",
      "bg": "0.9801681468663337",
      "zh": "0.9850427350473109",
      "fr": "1",
      "de": "0.984121685970452",
      "ha": "0.9845282823604304",
      "hi": "0.9589629632781921",
      "hu": "0.9862978804250703"
    },
    "level": "easy",
    "test": "test_absolute_value() {\n    [[ $(absolute_value 95) -eq 95 ]] || { echo \"Test 1 failed\"; exit 1; }\n    [[ $(absolute_value -95) -eq 95 ]] || { echo \"Test 2 failed\"; exit 1; }\n    [[ $(absolute_value 0) -eq 0 ]] || { echo \"Test 3 failed\"; exit 1; }\n    [[ $(absolute_value 10000) -eq 10000 ]] || { echo \"Test 4 failed\"; exit 1; }\n    [[ $(absolute_value -10000) -eq 10000 ]] || { echo \"Test 5 failed\"; exit 1; }\n    [[ $(absolute_value 1) -eq 1 ]] || { echo \"Test 6 failed\"; exit 1; }\n    [[ $(absolute_value -1) -eq 1 ]] || { echo \"Test 7 failed\"; exit 1; }\n}\n\ntest_absolute_value",
    "entry_point": "absolute_value",
    "signature": "absolute_value() {",
    "docstring": {
      "en": " Calculate the absolute value of a given integer.\n If the integer is positive, return the number as is.\n If the integer is negative, return the number multiplied by -1.\n\n Example:\n >>> absolute_value 95\n 95\n >>> absolute_value -95\n 95\n >>> absolute_value 0\n 0",
      "sq": "Llogaritni vlerën absolute të një numri të dhënë të plotë.  \nNëse numri i plotë është pozitiv, kthejeni numrin ashtu siç është.  \nNëse numri i plotë është negativ, kthejeni numrin të shumëzuar me -1.\n\nShembull:\n>>> absolute_value 95\n95\n>>> absolute_value -95\n95\n>>> absolute_value 0\n0",
      "hy": "Հաշվարկել տրված ամբողջ թվի բացարձակ արժեքը։  \nԵթե ամբողջ թիվը դրական է, վերադարձնել թիվը ինչպես կա։  \nԵթե ամբողջ թիվը բացասական է, վերադարձնել թիվը բազմապատկած -1-ով։  \n\nՕրինակ:  \n>>> absolute_value 95  \n95  \n>>> absolute_value -95  \n95  \n>>> absolute_value 0  \n0",
      "bn": " প্রদত্ত পূর্ণসংখ্যার মানের পরম মান গণনা করুন।\n যদি পূর্ণসংখ্যাটি ধনাত্মক হয়, তবে সংখ্যাটি যেমন আছে তেমনই ফেরত দিন।\n যদি পূর্ণসংখ্যাটি ঋণাত্মক হয়, তবে সংখ্যাটি -1 দ্বারা গুণ করে ফেরত দিন।\n\n উদাহরণ:\n >>> absolute_value 95\n 95\n >>> absolute_value -95\n 95\n >>> absolute_value 0\n 0",
      "bg": "Изчислява абсолютната стойност на дадено цяло число.  \nАко числото е положително, връща числото такова, каквото е.  \nАко числото е отрицателно, връща числото, умножено по -1.  \n\nПример:  \n>>> absolute_value 95  \n95  \n>>> absolute_value -95  \n95  \n>>> absolute_value 0  \n0",
      "zh": "计算给定整数的绝对值。  \n如果整数是正数，则按原样返回该数字。  \n如果整数是负数，则返回该数字乘以 -1。  \n\n示例：  \n>>> absolute_value 95  \n95  \n>>> absolute_value -95  \n95  \n>>> absolute_value 0  \n0  ",
      "fr": " Calculer la valeur absolue d'un entier donné.\n Si l'entier est positif, retourner le nombre tel quel.\n Si l'entier est négatif, retourner le nombre multiplié par -1.\n\n Exemple:\n >>> absolute_value 95\n 95\n >>> absolute_value -95\n 95\n >>> absolute_value 0\n 0",
      "de": "Berechne den absoluten Wert einer gegebenen ganzen Zahl.\nWenn die ganze Zahl positiv ist, gib die Zahl unverändert zurück.\nWenn die ganze Zahl negativ ist, gib die Zahl multipliziert mit -1 zurück.\n\nBeispiel:\n>>> absolute_value 95\n95\n>>> absolute_value -95\n95\n>>> absolute_value 0\n0",
      "ha": "Ƙididdige darajar da aka bayar na cikakken lamba.\n\nIdan lambar tana da kyau, dawo da lambar kamar yadda take.\n\nIdan lambar tana da mummuna, dawo da lambar da aka ninka da -1.\n\nMisali:\n>>> absolute_value 95\n95\n>>> absolute_value -95\n95\n>>> absolute_value 0\n0",
      "hi": "दिए गए पूर्णांक का परिमाण मान गणना करें।\nयदि पूर्णांक धनात्मक है, तो संख्या को जैसा है वैसा ही लौटाएं।\nयदि पूर्णांक ऋणात्मक है, तो संख्या को -1 से गुणा करके लौटाएं।\n\nउदाहरण:\n>>> absolute_value 95\n95\n>>> absolute_value -95\n95\n>>> absolute_value 0\n0",
      "hu": " Számítsa ki egy adott egész szám abszolút értékét.\n Ha az egész szám pozitív, adja vissza a számot változatlanul.\n Ha az egész szám negatív, adja vissza a számot -1-gyel megszorozva.\n\n Példa:\n >>> absolute_value 95\n 95\n >>> absolute_value -95\n 95\n >>> absolute_value 0\n 0"
    },
    "docstring_bertscore": {
      "sq": "0.9885590886827714",
      "hy": "1",
      "bn": "0.9809608807170439",
      "bg": "0.9527057090148311",
      "zh": "1",
      "fr": "1",
      "de": "0.9821276355752429",
      "ha": "0.9597974095089197",
      "hi": "0.9809608807170439",
      "hu": "0.9821276355752429"
    }
  }
]