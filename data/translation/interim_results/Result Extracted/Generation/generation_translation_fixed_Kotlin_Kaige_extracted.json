[
  {
    "task_id": "Kotlin/1",
    "prompt": {
      "en": "/**\n    * Check if in given list of numbers, any two numbers are closer to each other than\n    * given threshold.\n*/\nfun hasCloseElements(numbers: List<Double>, threshold: Double): Boolean",
      "sq": "/**\n    * Kontrolloni nëse në listën e dhënë të numrave, ndonjë dy numra janë më afër njëri-tjetrit\n    * sesa pragu i dhënë.\n*/ \nfun hasCloseElements(numbers: List<Double>, threshold: Double): Boolean",
      "hy": "/**\n    * Ստուգել, արդյոք տրված թվերի ցանկում որևէ երկու թիվ ավելի մոտ են միմյանց, քան\n    * տրված շեմը։\n*/ \nfun hasCloseElements(numbers: List<Double>, threshold: Double): Boolean",
      "bn": "/**\n    * প্রদত্ত সংখ্যার তালিকায়, কোনো দুটি সংখ্যা দেওয়া থ্রেশহোল্ডের চেয়ে কাছাকাছি আছে কিনা তা পরীক্ষা করুন।\n*/ \nfun hasCloseElements(numbers: List<Double>, threshold: Double): Boolean",
      "bg": "/**\n    * Проверете дали в дадения списък от числа, някои две числа са по-близо едно до друго от\n    * дадения праг.\n*/ \nfun hasCloseElements(numbers: List<Double>, threshold: Double): Boolean",
      "zh": "/**\n    * 检查在给定的数字列表中，是否有任意两个数字之间的距离小于给定的阈值。\n*/ \nfun hasCloseElements(numbers: List<Double>, threshold: Double): Boolean",
      "fr": "/**\n    * Vérifiez si, dans la liste donnée de nombres, deux nombres quelconques sont plus proches l'un de l'autre que le seuil donné.\n*/  \nfun hasCloseElements(numbers: List<Double>, threshold: Double): Boolean",
      "de": "/**\n    * Überprüfen, ob in der gegebenen Liste von Zahlen zwei Zahlen näher beieinander liegen als\n    * der gegebene Schwellenwert.\n*/ \nfun hasCloseElements(numbers: List<Double>, threshold: Double): Boolean",
      "ha": "/**\n    * Duba idan a cikin jerin lambobi da aka bayar, ko akwai wasu lambobi biyu da suka fi kusa da juna fiye da\n    * ƙayyadadden iyaka.\n*/\nfun hasCloseElements(numbers: List<Double>, threshold: Double): Boolean",
      "hi": "/**\n    * जाँचें कि दिए गए संख्याओं की सूची में, क्या कोई दो संख्याएँ एक-दूसरे के अधिक निकट हैं \n    * दिए गए सीमा से।\n*/\nfun hasCloseElements(numbers: List<Double>, threshold: Double): Boolean",
      "hu": "/**\n    * Ellenőrizze, hogy a megadott számok listájában bármely két szám közelebb van-e egymáshoz, mint\n    * a megadott küszöbérték.\n*/\nfun hasCloseElements(numbers: List<Double>, threshold: Double): Boolean"
    },
    "prompt_bertscore": {
      "sq": "0.9845185494717598",
      "hy": "0.9683065364020732",
      "bn": "0.94970559573968",
      "bg": "0.9879711427549082",
      "zh": "0.8954159399952245",
      "fr": "0.974453948064722",
      "de": "0.9722795412835331",
      "ha": "0.9646281003756881",
      "hi": "0.9845185494717598",
      "hu": "0.9611625961177724"
    },
    "canonical_solution": "{\n    for ((idx, elem) in numbers.withIndex()) {\n        for ((idx2, elem2) in numbers.withIndex()) {\n            if (idx != idx2) {\n                val distance = Math.abs(elem - elem2)\n                if (distance < threshold) {\n                    return true\n                }\n            }\n        }\n    }\n    return false\n}",
    "instruction": {
      "en": "Write a Kotlin function `fun hasCloseElements(numbers: List<Double>, threshold: Double): Boolean` to solve the following problem:\nCheck if in given list of numbers, any two numbers are closer to each other than\ngiven threshold.",
      "sq": "Shkruani një funksion Kotlin `fun hasCloseElements(numbers: List<Double>, threshold: Double): Boolean` për të zgjidhur problemin e mëposhtëm: Kontrolloni nëse në listën e dhënë të numrave, ndonjë dy numra janë më afër njëri-tjetrit sesa pragu i dhënë.",
      "hy": "Գրեք Kotlin ֆունկցիա `fun hasCloseElements(numbers: List<Double>, threshold: Double): Boolean` հետևյալ խնդիրը լուծելու համար:\nՍտուգեք, արդյոք տրված թվերի ցուցակում որևէ երկու թիվ ավելի մոտ են միմյանց, քան տրված շեմը:",
      "bn": "একটি Kotlin ফাংশন লিখুন `fun hasCloseElements(numbers: List<Double>, threshold: Double): Boolean` নিম্নলিখিত সমস্যার সমাধান করতে:\nযাচাই করুন যে প্রদত্ত সংখ্যার তালিকায়, কোনো দুটি সংখ্যা একে অপরের থেকে প্রদত্ত সীমার চেয়ে বেশি কাছাকাছি কিনা।",
      "bg": "Напишете функция на Kotlin `fun hasCloseElements(numbers: List<Double>, threshold: Double): Boolean`, за да решите следния проблем:  \nПроверете дали в дадения списък от числа, някои две числа са по-близо едно до друго от дадения праг.",
      "zh": "编写一个 Kotlin 函数 `fun hasCloseElements(numbers: List<Double>, threshold: Double): Boolean` 来解决以下问题：  \n检查在给定的数字列表中，是否有任意两个数字之间的距离小于给定的阈值。",
      "fr": "Écrire une fonction Kotlin `fun hasCloseElements(numbers: List<Double>, threshold: Double): Boolean` pour résoudre le problème suivant :  \nVérifiez si, dans la liste donnée de nombres, deux nombres quelconques sont plus proches l'un de l'autre que le seuil donné.",
      "de": "Schreiben Sie eine Kotlin-Funktion `fun hasCloseElements(numbers: List<Double>, threshold: Double): Boolean`, um das folgende Problem zu lösen:  \nÜberprüfen Sie, ob in der gegebenen Liste von Zahlen zwei Zahlen näher beieinander liegen als der gegebene Schwellenwert.",
      "ha": "Rubuta aikin Kotlin `fun hasCloseElements(numbers: List<Double>, threshold: Double): Boolean` don warware matsalar mai zuwa:\nDuba idan a cikin jerin lambobi da aka bayar, kowanne lambobi biyu suna kusa da juna fiye da\nmatakin da aka bayar.",
      "hi": "Kotlin फ़ंक्शन `fun hasCloseElements(numbers: List<Double>, threshold: Double): Boolean` लिखें ताकि निम्नलिखित समस्या का समाधान किया जा सके:\nजाँच करें कि दिए गए संख्याओं की सूची में, कोई दो संख्याएँ एक-दूसरे के कितनी निकट हैं, यह दिए गए सीमा से कम है या नहीं।",
      "hu": "Írj egy Kotlin függvényt `fun hasCloseElements(numbers: List<Double>, threshold: Double): Boolean` a következő probléma megoldására:  \nEllenőrizd, hogy a megadott számok listájában bármely két szám közelebb van-e egymáshoz, mint a megadott küszöbérték."
    },
    "instruction_bertscore": {
      "sq": "0.9921221204577753",
      "hy": "0.9737146457865101",
      "bn": "0.9845358303149098",
      "bg": "0.9852334202131043",
      "zh": "0.9349034611145792",
      "fr": "0.9855855918786792",
      "de": "0.9731721862159038",
      "ha": "0.9921221204577753",
      "hi": "0.9575121669751133",
      "hu": "0.9810331821757406"
    },
    "level": "easy",
    "test": "// Test cases\nfun main() {\n    println(\"start\")\n    assert(hasCloseElements(listOf(1.0, 2.0, 3.9, 4.0, 5.0, 2.2), 0.3) == true)\n    assert(hasCloseElements(listOf(1.0, 2.0, 3.9, 4.0, 5.0, 2.2), 0.05) == false)\n    assert(hasCloseElements(listOf(1.0, 2.0, 5.9, 4.0, 5.0), 0.95) == true)\n    assert(hasCloseElements(listOf(1.0, 2.0, 5.9, 4.0, 5.0), 0.8) == false)\n    assert(hasCloseElements(listOf(1.0, 2.0, 3.0, 4.0, 5.0, 2.0), 0.1) == true)\n    assert(hasCloseElements(listOf(1.1, 2.2, 3.1, 4.1, 5.1), 1.0) == true)\n    assert(hasCloseElements(listOf(1.1, 2.2, 3.1, 4.1, 5.1), 0.5) == false)\n\n}",
    "entry_point": "hasCloseElements",
    "signature": "fun hasCloseElements(numbers: List<Double>, threshold: Double): Boolean",
    "docstring": {
      "en": "Check if in given list of numbers, any two numbers are closer to each other than\ngiven threshold.",
      "sq": "Kontrolloni nëse në listën e dhënë të numrave, ndonjë dy numra janë më afër njëri-tjetrit se sa pragu i dhënë.",
      "hy": "Ստուգել, արդյոք տրված թվերի ցուցակում որևէ երկու թիվ ավելի մոտ են իրար, քան տրված շեմը:",
      "bn": "প্রদত্ত সংখ্যার তালিকায়, কোনো দুটি সংখ্যা প্রদত্ত সীমার চেয়ে একে অপরের কাছাকাছি আছে কিনা তা পরীক্ষা করুন।",
      "bg": "Проверете дали в дадения списък от числа, някои две числа са по-близо едно до друго от дадения праг.",
      "zh": "检查给定数字列表中，是否有任意两个数字之间的距离小于给定的阈值。",
      "fr": "Vérifiez si, dans une liste donnée de nombres, deux nombres quelconques sont plus proches l'un de l'autre que le seuil donné.",
      "de": "Überprüfen Sie, ob in der gegebenen Liste von Zahlen zwei beliebige Zahlen näher beieinander liegen als der angegebene Schwellenwert.",
      "ha": "Duba idan a cikin jerin lambobin da aka bayar, ko akwai wasu lambobi biyu da suka fi kusa da juna fiye da ƙayyadadden ƙimar ƙasa.",
      "hi": "दिए गए संख्याओं की सूची में जांचें कि क्या कोई दो संख्याएँ दी गई सीमा से अधिक निकट हैं।",
      "hu": "Ellenőrizze, hogy a megadott számok listájában bármely két szám közelebb van-e egymáshoz, mint a megadott küszöbérték."
    },
    "docstring_bertscore": {
      "sq": "0.9754973534562983",
      "hy": "0.913825599600681",
      "bn": "0.8882819312299755",
      "bg": "0.9754973534562983",
      "zh": "0.8307951208723822",
      "fr": "0.956388912170361",
      "de": "0.9282684118664898",
      "ha": "0.8993033351824583",
      "hi": "0.8477053197314064",
      "hu": "0.9409853247514864"
    }
  },
  {
    "task_id": "Kotlin/2",
    "prompt": {
      "en": "/**\n * Finds all Armstrong numbers within a specified range.\n * An Armstrong number is a number that is equal to the sum of its own digits each raised to the power of the number of 3.\n * For example, 153 is an Armstrong number because 1^3 + 5^3 + 3^3 = 153.\n    >>> findArmstrongNumbersInRange(1, 500)\n        listOf(1, 153, 370, 371, 407)\n    >>> findArmstrongNumbersInRange(500, 1000)\n         emptyList<Int>()\n */\n\nfun findArmstrongNumbersInRange(start: Int, end: Int): List<Int> ",
      "sq": "/**\n * Gjen të gjitha numrat Armstrong brenda një intervali të specifikuar.\n * Një numër Armstrong është një numër që është i barabartë me shumën e shifrave të tij, secila e ngritur në fuqinë e numrit 3.\n * Për shembull, 153 është një numër Armstrong sepse 1^3 + 5^3 + 3^3 = 153.\n    >>> findArmstrongNumbersInRange(1, 500)\n        listOf(1, 153, 370, 371, 407)\n    >>> findArmstrongNumbersInRange(500, 1000)\n         emptyList<Int>()\n */",
      "hy": "/**\n * Գտնում է բոլոր Արմսթրոնգի թվերը նշված միջակայքում:\n * Արմսթրոնգի թիվը թիվ է, որը հավասար է իր թվանշանների գումարին, որոնցից յուրաքանչյուրը բարձրացված է 3 աստիճանի:\n * Օրինակ, 153-ը Արմսթրոնգի թիվ է, քանի որ 1^3 + 5^3 + 3^3 = 153:\n    >>> findArmstrongNumbersInRange(1, 500)\n        listOf(1, 153, 370, 371, 407)\n    >>> findArmstrongNumbersInRange(500, 1000)\n         emptyList<Int>()\n */",
      "bn": "/**\n * নির্দিষ্ট সীমার মধ্যে সব আর্মস্ট্রং সংখ্যা খুঁজে বের করে।\n * একটি আর্মস্ট্রং সংখ্যা হল এমন একটি সংখ্যা যা তার নিজের অঙ্কগুলির সমষ্টির সমান, প্রতিটি অঙ্ককে ৩ এর ঘাতের সাথে উত্তোলিত করা হয়।\n * উদাহরণস্বরূপ, 153 একটি আর্মস্ট্রং সংখ্যা কারণ 1^3 + 5^3 + 3^3 = 153।\n    >>> findArmstrongNumbersInRange(1, 500)\n        listOf(1, 153, 370, 371, 407)\n    >>> findArmstrongNumbersInRange(500, 1000)\n         emptyList<Int>()\n */",
      "bg": "/**\n * Намира всички числа на Армстронг в даден диапазон.\n * Число на Армстронг е число, което е равно на сумата от собствените му цифри, всяка повдигната на степен равна на броя на цифрите.\n * Например, 153 е число на Армстронг, защото 1^3 + 5^3 + 3^3 = 153.\n    >>> findArmstrongNumbersInRange(1, 500)\n        listOf(1, 153, 370, 371, 407)\n    >>> findArmstrongNumbersInRange(500, 1000)\n         emptyList<Int>()\n */",
      "zh": "/**\n * 查找指定范围内的所有阿姆斯特朗数。\n * 阿姆斯特朗数是一个数字，其等于其各个数字的立方和。\n * 例如，153 是一个阿姆斯特朗数，因为 1^3 + 5^3 + 3^3 = 153。\n    >>> findArmstrongNumbersInRange(1, 500)\n        listOf(1, 153, 370, 371, 407)\n    >>> findArmstrongNumbersInRange(500, 1000)\n         emptyList<Int>()\n */",
      "fr": "/**\n * Trouve tous les nombres d'Armstrong dans une plage spécifiée.\n * Un nombre d'Armstrong est un nombre qui est égal à la somme de ses propres chiffres, chacun élevé à la puissance du nombre de 3.\n * Par exemple, 153 est un nombre d'Armstrong parce que 1^3 + 5^3 + 3^3 = 153.\n    >>> findArmstrongNumbersInRange(1, 500)\n        listOf(1, 153, 370, 371, 407)\n    >>> findArmstrongNumbersInRange(500, 1000)\n         emptyList<Int>()\n */",
      "de": "/**\n * Findet alle Armstrong-Zahlen innerhalb eines angegebenen Bereichs.\n * Eine Armstrong-Zahl ist eine Zahl, die gleich der Summe ihrer eigenen Ziffern ist, wobei jede Ziffer auf die Potenz der Zahl 3 erhoben wird.\n * Zum Beispiel ist 153 eine Armstrong-Zahl, weil 1^3 + 5^3 + 3^3 = 153.\n    >>> findArmstrongNumbersInRange(1, 500)\n        listOf(1, 153, 370, 371, 407)\n    >>> findArmstrongNumbersInRange(500, 1000)\n         emptyList<Int>()\n */ \n\nfun findArmstrongNumbersInRange(start: Int, end: Int): List<Int> ",
      "ha": "/**\n * Nemi duk lambobin Armstrong a cikin kewayon da aka ƙayyade.\n * Lambar Armstrong ita ce lamba da ta yi daidai da jumlar lambobinta da aka ɗaga kowanne zuwa ƙarfin lamba 3.\n * Alal misali, 153 lambar Armstrong ce domin 1^3 + 5^3 + 3^3 = 153.\n    >>> findArmstrongNumbersInRange(1, 500)\n        listOf(1, 153, 370, 371, 407)\n    >>> findArmstrongNumbersInRange(500, 1000)\n         emptyList<Int>()\n */ \n\nfun findArmstrongNumbersInRange(start: Int, end: Int): List<Int> ",
      "hi": "/**\n * निर्दिष्ट श्रेणी के भीतर सभी आर्मस्ट्रांग संख्याएँ खोजता है।\n * एक आर्मस्ट्रांग संख्या वह संख्या होती है जो अपने स्वयं के अंकों के योग के बराबर होती है, प्रत्येक अंक को 3 की घात तक उठाया जाता है।\n * उदाहरण के लिए, 153 एक आर्मस्ट्रांग संख्या है क्योंकि 1^3 + 5^3 + 3^3 = 153।\n    >>> findArmstrongNumbersInRange(1, 500)\n        listOf(1, 153, 370, 371, 407)\n    >>> findArmstrongNumbersInRange(500, 1000)\n         emptyList<Int>()\n */ \n\nfun findArmstrongNumbersInRange(start: Int, end: Int): List<Int> ",
      "hu": "/**\n * Megtalálja az összes Armstrong-számot egy megadott tartományon belül.\n * Egy Armstrong-szám olyan szám, amely egyenlő a saját számjegyeinek összegével, ahol minden számjegy a 3 hatványára van emelve.\n * Például a 153 egy Armstrong-szám, mert 1^3 + 5^3 + 3^3 = 153.\n    >>> findArmstrongNumbersInRange(1, 500)\n        listOf(1, 153, 370, 371, 407)\n    >>> findArmstrongNumbersInRange(500, 1000)\n         emptyList<Int>()\n */ \n\nfun findArmstrongNumbersInRange(start: Int, end: Int): List<Int> "
    },
    "prompt_bertscore": {
      "sq": "0.9497198971271146",
      "hy": "0.9420611068951714",
      "bn": "0.956713275582591",
      "bg": "0.9506701448699855",
      "zh": "0.9287955768977564",
      "fr": "0.9551993148183431",
      "de": "0.988163615594131",
      "ha": "0.9762604913802343",
      "hi": "0.9855490438885688",
      "hu": "0.9838402267205256"
    },
    "canonical_solution": "{\n    val armstrongNumbers = mutableListOf<Int>()\n\n    for (number in start..end) {\n        var sum = 0\n        var temp = number\n        val length = number.toString().length\n\n        while (temp != 0) {\n            val digit = temp % 10\n            sum += Math.pow(digit.toDouble(), 3.0).toInt()\n            temp /= 10\n        }\n\n        if (number == sum) {\n            armstrongNumbers.add(number)\n        }\n    }\n\n    return armstrongNumbers\n}",
    "instruction": {
      "en": "Write a Kotlin function `fun findArmstrongNumbersInRange(start: Int, end: Int): List<Int>` to solve the following problem:\nFinds all Armstrong numbers within a specified range.\nAn Armstrong number is a number that is equal to the sum of its own digits each raised to the power of the number of 3.\nFor example, 153 is an Armstrong number because 1^3 + 5^3 + 3^3 = 153.\n>>> findArmstrongNumbersInRange(1, 500)\nlistOf(1, 153, 370, 371, 407)\n>>> findArmstrongNumbersInRange(500, 1000)\nemptyList<Int>()",
      "sq": "Shkruani një funksion Kotlin `fun findArmstrongNumbersInRange(start: Int, end: Int): List<Int>` për të zgjidhur problemin e mëposhtëm:\nGjen të gjitha numrat Armstrong brenda një diapazoni të specifikuar.\nNjë numër Armstrong është një numër që është i barabartë me shumën e shifrave të tij, secila e ngritur në fuqinë e numrit 3.\nPër shembull, 153 është një numër Armstrong sepse 1^3 + 5^3 + 3^3 = 153.",
      "hy": "Գրեք Kotlin ֆունկցիա `fun findArmstrongNumbersInRange(start: Int, end: Int): List<Int>` հետևյալ խնդիրը լուծելու համար:\nԳտնում է բոլոր Արմսթրոնգի թվերը նշված միջակայքում:\nԱրմսթրոնգի թիվը թիվ է, որը հավասար է իր սեփական թվանշանների գումարին, որոնցից յուրաքանչյուրը բարձրացված է 3-ի աստիճանի:\nՕրինակ, 153-ը Արմսթրոնգի թիվ է, որովհետև 1^3 + 5^3 + 3^3 = 153:\n>>> findArmstrongNumbersInRange(1, 500)\nlistOf(1, 153, 370, 371, 407)\n>>> findArmstrongNumbersInRange(500, 1000)\nemptyList<Int>()",
      "bn": "একটি Kotlin ফাংশন `fun findArmstrongNumbersInRange(start: Int, end: Int): List<Int>` লিখুন নিম্নলিখিত সমস্যার সমাধানের জন্য:\nনির্দিষ্ট একটি পরিসরের মধ্যে সমস্ত আর্মস্ট্রং সংখ্যা খুঁজে বের করে।\nএকটি আর্মস্ট্রং সংখ্যা হল এমন একটি সংখ্যা যা তার নিজের অঙ্কগুলির সমান, প্রতিটি অঙ্কের ঘনফল যোগফল হিসাবে।\nউদাহরণস্বরূপ, 153 একটি আর্মস্ট্রং সংখ্যা কারণ 1^3 + 5^3 + 3^3 = 153।\n>>> findArmstrongNumbersInRange(1, 500)\nlistOf(1, 153, 370, 371, 407)\n>>> findArmstrongNumbersInRange(500, 1000)\nemptyList<Int>()",
      "bg": "Напишете Kotlin функция `fun findArmstrongNumbersInRange(start: Int, end: Int): List<Int>` за решаване на следния проблем:\nНамира всички числа на Армстронг в даден диапазон.\nЧисло на Армстронг е число, което е равно на сумата от собствените си цифри, всяка повдигната на степен броя на 3.\nНапример, 153 е число на Армстронг, защото 1^3 + 5^3 + 3^3 = 153.",
      "zh": "编写一个 Kotlin 函数 `fun findArmstrongNumbersInRange(start: Int, end: Int): List<Int>` 来解决以下问题：\n在指定范围内查找所有的阿姆斯特朗数。\n阿姆斯特朗数是指一个数等于其各个数字的立方和。\n例如，153 是一个阿姆斯特朗数，因为 1^3 + 5^3 + 3^3 = 153。",
      "fr": "Écrire une fonction Kotlin `fun findArmstrongNumbersInRange(start: Int, end: Int): List<Int>` pour résoudre le problème suivant :\nTrouve tous les nombres d'Armstrong dans une plage spécifiée.\nUn nombre d'Armstrong est un nombre qui est égal à la somme de ses propres chiffres chacun élevé à la puissance du nombre de 3.\nPar exemple, 153 est un nombre d'Armstrong parce que 1^3 + 5^3 + 3^3 = 153.",
      "de": "Schreiben Sie eine Kotlin-Funktion `fun findArmstrongNumbersInRange(start: Int, end: Int): List<Int>`, um das folgende Problem zu lösen:\nFindet alle Armstrong-Zahlen innerhalb eines angegebenen Bereichs.\nEine Armstrong-Zahl ist eine Zahl, die gleich der Summe ihrer eigenen Ziffern ist, wobei jede Ziffer auf die Potenz der Zahl 3 erhoben wird.\nZum Beispiel ist 153 eine Armstrong-Zahl, weil 1^3 + 5^3 + 3^3 = 153.",
      "ha": "Rubuta aikin Kotlin `fun findArmstrongNumbersInRange(start: Int, end: Int): List<Int>` don warware matsalar mai zuwa:\nNemo duk lambobin Armstrong a cikin kewayon da aka kayyade.\nLambar Armstrong ita ce lamba da ta yi daidai da jimillar lambobinta da aka ɗaga kowanne zuwa ƙarfin lamba 3.\nAlal misali, 153 lambar Armstrong ce saboda 1^3 + 5^3 + 3^3 = 153.",
      "hi": "Kotlin फ़ंक्शन `fun findArmstrongNumbersInRange(start: Int, end: Int): List<Int>` लिखें ताकि निम्नलिखित समस्या का समाधान किया जा सके:\nनिर्दिष्ट सीमा के भीतर सभी आर्मस्ट्रांग संख्याएँ खोजें।\nएक आर्मस्ट्रांग संख्या वह संख्या होती है जो अपने स्वयं के अंकों के योग के बराबर होती है, जहाँ प्रत्येक अंक को 3 की घात तक उठाया जाता है।\nउदाहरण के लिए, 153 एक आर्मस्ट्रांग संख्या है क्योंकि 1^3 + 5^3 + 3^3 = 153।\n>>> findArmstrongNumbersInRange(1, 500)\nlistOf(1, 153, 370, 371, 407)\n>>> findArmstrongNumbersInRange(500, 1000)\nemptyList<Int>()",
      "hu": "Írj egy Kotlin függvényt `fun findArmstrongNumbersInRange(start: Int, end: Int): List<Int>` a következő probléma megoldására:\nMegtalálja az összes Armstrong-számot egy megadott tartományon belül.\nEgy Armstrong-szám olyan szám, amely egyenlő a saját számjegyeinek összegével, ahol minden számjegy a számjegyek számának hatványára van emelve.\nPéldául, 153 egy Armstrong-szám, mert 1^3 + 5^3 + 3^3 = 153.\n>>> findArmstrongNumbersInRange(1, 500)\nlistOf(1, 153, 370, 371, 407)\n>>> findArmstrongNumbersInRange(500, 1000)\nemptyList<Int>()"
    },
    "instruction_bertscore": {
      "sq": "0.9087484084310482",
      "hy": "0.9830768901662086",
      "bn": "0.9115719392974592",
      "bg": "0.9199505660302728",
      "zh": "0.8884146163245067",
      "fr": "0.9152501766934632",
      "de": "0.9102446910913841",
      "ha": "0.9099574715604076",
      "hi": "0.9699096822074058",
      "hu": "0.9054396235437691"
    },
    "level": "middle",
    "test": "fun main() {\n    check(findArmstrongNumbersInRange(1, 500) == listOf(1, 153, 370, 371, 407))\n    check(findArmstrongNumbersInRange(500, 1000) == emptyList<Int>())\n    check(findArmstrongNumbersInRange(1, 100) == listOf(1))\n    check(findArmstrongNumbersInRange(100, 200) == listOf(153))\n    check(findArmstrongNumbersInRange(100, 1000) == listOf(153, 370, 371, 407))\n}\n\n\nmain()",
    "entry_point": "findArmstrongNumbersInRange",
    "signature": "fun findArmstrongNumbersInRange(start: Int, end: Int): List<Int>",
    "docstring": {
      "en": "Finds all Armstrong numbers within a specified range.\nAn Armstrong number is a number that is equal to the sum of its own digits each raised to the power of the number of 3.\nFor example, 153 is an Armstrong number because 1^3 + 5^3 + 3^3 = 153.\n>>> findArmstrongNumbersInRange(1, 500)\nlistOf(1, 153, 370, 371, 407)\n>>> findArmstrongNumbersInRange(500, 1000)\nemptyList<Int>()",
      "sq": "Gjen të gjitha numrat Armstrong brenda një intervali të specifikuar. Një numër Armstrong është një numër që është i barabartë me shumën e shifrave të tij, secila e ngritur në fuqinë e numrit 3. Për shembull, 153 është një numër Armstrong sepse 1^3 + 5^3 + 3^3 = 153.\n>>> findArmstrongNumbersInRange(1, 500)\nlistOf(1, 153, 370, 371, 407)\n>>> findArmstrongNumbersInRange(500, 1000)\nemptyList<Int>()",
      "hy": "Գտնում է բոլոր Արմսթրոնգի թվերը նշված միջակայքում:\nԱրմսթրոնգի թիվը թիվ է, որը հավասար է իր թվանշանների գումարին, որոնցից յուրաքանչյուրը բարձրացված է 3 աստիճանի:\nՕրինակ, 153-ը Արմսթրոնգի թիվ է, քանի որ 1^3 + 5^3 + 3^3 = 153:\n>>> findArmstrongNumbersInRange(1, 500)\nlistOf(1, 153, 370, 371, 407)\n>>> findArmstrongNumbersInRange(500, 1000)\nemptyList<Int>()",
      "bn": "নির্দিষ্ট পরিসরের মধ্যে সমস্ত আর্মস্ট্রং সংখ্যা খুঁজে বের করে।  \nএকটি আর্মস্ট্রং সংখ্যা হল এমন একটি সংখ্যা যা তার নিজের অঙ্কগুলির সমষ্টির সমান, প্রতিটি অঙ্ককে ৩ এর ঘাতের সাথে উত্তোলিত করে।  \nউদাহরণস্বরূপ, ১৫৩ একটি আর্মস্ট্রং সংখ্যা কারণ ১^৩ + ৫^৩ + ৩^৩ = ১৫৩।  \n>>> findArmstrongNumbersInRange(1, 500)  \nlistOf(1, 153, 370, 371, 407)  \n>>> findArmstrongNumbersInRange(500, 1000)  \nemptyList<Int>()  ",
      "bg": "Намира всички числа на Армстронг в определен диапазон.\nЧисло на Армстронг е число, което е равно на сумата от собствените си цифри, всяка повдигната на степен числото 3.\nНапример, 153 е число на Армстронг, защото 1^3 + 5^3 + 3^3 = 153.\n>>> findArmstrongNumbersInRange(1, 500)\nlistOf(1, 153, 370, 371, 407)\n>>> findArmstrongNumbersInRange(500, 1000)\nemptyList<Int>()",
      "zh": "在指定范围内查找所有阿姆斯特朗数。\n阿姆斯特朗数是指一个数等于其每个数字的立方和。\n例如，153 是一个阿姆斯特朗数，因为 1^3 + 5^3 + 3^3 = 153。\n>>> findArmstrongNumbersInRange(1, 500)\nlistOf(1, 153, 370, 371, 407)\n>>> findArmstrongNumbersInRange(500, 1000)\nemptyList<Int>()",
      "fr": "Trouve tous les nombres d'Armstrong dans une plage spécifiée.\nUn nombre d'Armstrong est un nombre qui est égal à la somme de ses propres chiffres chacun élevé à la puissance du nombre de 3.\nPar exemple, 153 est un nombre d'Armstrong parce que 1^3 + 5^3 + 3^3 = 153.\n>>> findArmstrongNumbersInRange(1, 500)\nlistOf(1, 153, 370, 371, 407)\n>>> findArmstrongNumbersInRange(500, 1000)\nemptyList<Int>()",
      "de": "Findet alle Armstrong-Zahlen innerhalb eines angegebenen Bereichs.\nEine Armstrong-Zahl ist eine Zahl, die gleich der Summe ihrer eigenen Ziffern ist, wobei jede Ziffer auf die Potenz der Zahl von 3 erhöht wird.\nZum Beispiel ist 153 eine Armstrong-Zahl, weil 1^3 + 5^3 + 3^3 = 153.\n>>> findArmstrongNumbersInRange(1, 500)\nlistOf(1, 153, 370, 371, 407)\n>>> findArmstrongNumbersInRange(500, 1000)\nemptyList<Int>()",
      "ha": "Yana nemo duk lambobin Armstrong a cikin kewayon da aka ayyana.\nLambar Armstrong ita ce lamba da ta yi daidai da jumlar lambobinta na kansu kowanne ya ɗaga zuwa ikon lamba 3.\nMisali, 153 lambar Armstrong ce saboda 1^3 + 5^3 + 3^3 = 153.\n>>> findArmstrongNumbersInRange(1, 500)\nlistOf(1, 153, 370, 371, 407)\n>>> findArmstrongNumbersInRange(500, 1000)\nemptyList<Int>()",
      "hi": "निर्दिष्ट सीमा के भीतर सभी आर्मस्ट्रांग संख्याएँ खोजता है।  \nएक आर्मस्ट्रांग संख्या वह संख्या होती है जो अपने स्वयं के अंकों के घन के योग के बराबर होती है।  \nउदाहरण के लिए, 153 एक आर्मस्ट्रांग संख्या है क्योंकि 1^3 + 5^3 + 3^3 = 153।  \n>>> findArmstrongNumbersInRange(1, 500)  \nlistOf(1, 153, 370, 371, 407)  \n>>> findArmstrongNumbersInRange(500, 1000)  \nemptyList<Int>()  ",
      "hu": "Megtalálja az összes Armstrong-számot egy megadott tartományon belül.  \nEgy Armstrong-szám olyan szám, amely egyenlő saját számjegyeinek összegével, mindegyik a számjegyek számának hatványára emelve.  \nPéldául, a 153 egy Armstrong-szám, mert 1^3 + 5^3 + 3^3 = 153.  \n>>> findArmstrongNumbersInRange(1, 500)  \nlistOf(1, 153, 370, 371, 407)  \n>>> findArmstrongNumbersInRange(500, 1000)  \nemptyList<Int>()"
    },
    "docstring_bertscore": {
      "sq": "0.9712422934337689",
      "hy": "0.9766851631348868",
      "bn": "0.9794729405327115",
      "bg": "0.9790534331679659",
      "zh": "0.9497085751953956",
      "fr": "0.9917044007664589",
      "de": "0.9836173634330045",
      "ha": "0.9841415490085555",
      "hi": "0.9546604305945954",
      "hu": "0.9764724299967985"
    }
  },
  {
    "task_id": "Kotlin/3",
    "prompt": {
      "en": "/**\n * Given a laboratory with N test tubes arranged in a straight line, you need to find the number of ways\n * to safely place chemicals in the test tubes. Placing chemicals in M consecutive test tubes will cause an explosion,\n * so you need to ensure that no M consecutive test tubes contain chemicals.\n *\n * Write a function that calculates the total number of safe placement options.\n *\n * Example:\n * >>> countSafePlacementOptions(4, 3)\n * 13\n *\n * Constraints:\n * 1 < N < 32\n * 2 <= M <= 5\n *\n * Note: The result can be a large number, so return it as a Long.\n */\n\n\nfun countSafePlacementOptions(N: Int, M: Int): Long",
      "sq": "/**\n * Duke pasur një laborator me N epruveta të renditura në një vijë të drejtë, ju duhet të gjeni numrin e mënyrave\n * për të vendosur në mënyrë të sigurt kimikatet në epruveta. Vendosja e kimikateve në M epruveta radhazi do të shkaktojë një shpërthim,\n * kështu që ju duhet të siguroheni që asnjë M epruveta radhazi të mos përmbajnë kimikate.\n *\n * Shkruani një funksion që llogarit numrin total të opsioneve të vendosjes së sigurt.\n *\n * Shembull:\n * >>> countSafePlacementOptions(4, 3)\n * 13\n *\n * Kufizimet:\n * 1 < N < 32\n * 2 <= M <= 5\n *\n * Shënim: Rezultati mund të jetë një numër i madh, prandaj kthejeni atë si një Long.\n */",
      "hy": "/**\n * Տրված է լաբորատորիա՝ N փորձանոթներով, որոնք դասավորված են ուղիղ գծով, դուք պետք է գտնեք քիմիկատները\n * փորձանոթներում անվտանգ տեղադրելու եղանակների քանակը։ M հաջորդական փորձանոթներում քիմիկատներ տեղադրելը\n * կպատճառի պայթյուն, ուստի դուք պետք է ապահովեք, որ ոչ մի M հաջորդական փորձանոթներում քիմիկատներ չլինեն։\n *\n * Գրել ֆունկցիա, որը կհաշվարկի անվտանգ տեղադրման տարբերակների ընդհանուր քանակը։\n *\n * Օրինակ:\n * >>> countSafePlacementOptions(4, 3)\n * 13\n *\n * Սահմանափակումներ:\n * 1 < N < 32\n * 2 <= M <= 5\n *\n * Նշում: Արդյունքը կարող է մեծ թիվ լինել, ուստի վերադարձնել այն որպես Long։\n */",
      "bn": "/**\n * একটি পরীক্ষাগারে N সংখ্যক টেস্ট টিউব সরল রেখায় সাজানো আছে, আপনাকে রাসায়নিকগুলি নিরাপদে স্থাপন করার উপায়গুলির সংখ্যা খুঁজে বের করতে হবে।\n * M সংখ্যক ধারাবাহিক টেস্ট টিউবে রাসায়নিক রাখলে বিস্ফোরণ ঘটবে, তাই আপনাকে নিশ্চিত করতে হবে যে কোনো M ধারাবাহিক টেস্ট টিউবে রাসায়নিক থাকবে না।\n *\n * একটি ফাংশন লিখুন যা নিরাপদ স্থাপনার মোট বিকল্পগুলির সংখ্যা গণনা করে।\n *\n * উদাহরণ:\n * >>> countSafePlacementOptions(4, 3)\n * 13\n *\n * শর্তাবলী:\n * 1 < N < 32\n * 2 <= M <= 5\n *\n * নোট: ফলাফল একটি বড় সংখ্যা হতে পারে, তাই এটি একটি Long হিসাবে ফেরত দিন।\n */",
      "bg": "/**\n * Дадена е лаборатория с N епруветки, подредени в права линия, трябва да намерите броя на начините\n * за безопасно поставяне на химикали в епруветките. Поставянето на химикали в M последователни епруветки ще предизвика експлозия,\n * така че трябва да се уверите, че няма M последователни епруветки, които съдържат химикали.\n *\n * Напишете функция, която изчислява общия брой на безопасните варианти за поставяне.\n *\n * Пример:\n * >>> countSafePlacementOptions(4, 3)\n * 13\n *\n * Ограничения:\n * 1 < N < 32\n * 2 <= M <= 5\n *\n * Забележка: Резултатът може да бъде голямо число, така че го върнете като Long.\n */",
      "zh": "/**\n * 给定一个实验室，其中有 N 个试管排成一条直线，你需要找到安全放置化学品的方法数。\n * 在 M 个连续的试管中放置化学品会导致爆炸，因此你需要确保没有 M 个连续的试管中含有化学品。\n *\n * 编写一个函数来计算安全放置选项的总数。\n *\n * 示例:\n * >>> countSafePlacementOptions(4, 3)\n * 13\n *\n * 约束条件:\n * 1 < N < 32\n * 2 <= M <= 5\n *\n * 注意: 结果可能是一个大数，因此返回时使用 Long 类型。\n */",
      "fr": "/**\n * Étant donné un laboratoire avec N tubes à essai disposés en ligne droite, vous devez trouver le nombre de façons\n * de placer en toute sécurité des produits chimiques dans les tubes à essai. Placer des produits chimiques dans M tubes à essai consécutifs provoquera une explosion,\n * vous devez donc vous assurer qu'aucun M tubes à essai consécutifs ne contiennent de produits chimiques.\n *\n * Écrivez une fonction qui calcule le nombre total d'options de placement sûres.\n *\n * Exemple:\n * >>> countSafePlacementOptions(4, 3)\n * 13\n *\n * Contraintes:\n * 1 < N < 32\n * 2 <= M <= 5\n *\n * Remarque: Le résultat peut être un grand nombre, donc retournez-le en tant que Long.\n */",
      "de": "/**\n * Gegeben ein Labor mit N Reagenzgläsern, die in einer geraden Linie angeordnet sind, müssen Sie die Anzahl der Möglichkeiten finden,\n * um Chemikalien sicher in den Reagenzgläsern zu platzieren. Das Platzieren von Chemikalien in M aufeinanderfolgenden Reagenzgläsern wird eine Explosion verursachen,\n * daher müssen Sie sicherstellen, dass keine M aufeinanderfolgenden Reagenzgläser Chemikalien enthalten.\n *\n * Schreiben Sie eine Funktion, die die Gesamtanzahl der sicheren Platzierungsoptionen berechnet.\n *\n * Beispiel:\n * >>> countSafePlacementOptions(4, 3)\n * 13\n *\n * Einschränkungen:\n * 1 < N < 32\n * 2 <= M <= 5\n *\n * Hinweis: Das Ergebnis kann eine große Zahl sein, daher geben Sie es als Long zurück.\n */",
      "ha": "/**\n * An ba da dakin gwaje-gwaje tare da N bututun gwaji da aka shirya a layi madaidaici, kana buƙatar nemo adadin hanyoyin\n * don sanya sinadarai cikin aminci a cikin bututun gwaji. Sanya sinadarai a cikin bututun gwaji M masu jere zai haifar da fashewa,\n * don haka kana buƙatar tabbatar da cewa babu bututun gwaji M masu jere da ke ɗauke da sinadarai.\n *\n * Rubuta wata aiki da ke ƙididdige jimillar adadin zaɓuɓɓukan sanya sinadarai cikin aminci.\n *\n * Misali:\n * >>> countSafePlacementOptions(4, 3)\n * 13\n *\n * Ƙuntatawa:\n * 1 < N < 32\n * 2 <= M <= 5\n *\n * Lura: Sakamakon na iya zama babban lamba, don haka dawo da shi azaman Long.\n */",
      "hi": "/**\n * दिए गए एक प्रयोगशाला में N टेस्ट ट्यूब्स को एक सीधी रेखा में व्यवस्थित किया गया है, आपको यह पता लगाना है कि \n * टेस्ट ट्यूब्स में रसायनों को सुरक्षित रूप से रखने के कितने तरीके हैं। M लगातार टेस्ट ट्यूब्स में रसायन रखने से विस्फोट होगा, \n * इसलिए आपको यह सुनिश्चित करना है कि कोई भी M लगातार टेस्ट ट्यूब्स में रसायन न हों।\n *\n * एक फ़ंक्शन लिखें जो सुरक्षित प्लेसमेंट विकल्पों की कुल संख्या की गणना करता है।\n *\n * उदाहरण:\n * >>> countSafePlacementOptions(4, 3)\n * 13\n *\n * बाधाएँ:\n * 1 < N < 32\n * 2 <= M <= 5\n *\n * नोट: परिणाम एक बड़ी संख्या हो सकती है, इसलिए इसे Long के रूप में लौटाएं।\n */",
      "hu": "/**\n * Adott egy laboratórium N kémcsővel, amelyek egy egyenes vonalban vannak elrendezve, meg kell találnod,\n * hányféleképpen lehet biztonságosan elhelyezni a vegyszereket a kémcsövekben. Ha M egymást követő kémcsőben\n * vegyszereket helyezel el, robbanás következik be, ezért biztosítanod kell, hogy ne legyen M egymást követő\n * kémcső, amely vegyszereket tartalmaz.\n *\n * Írj egy függvényt, amely kiszámítja a biztonságos elhelyezési lehetőségek teljes számát.\n *\n * Példa:\n * >>> countSafePlacementOptions(4, 3)\n * 13\n *\n * Korlátozások:\n * 1 < N < 32\n * 2 <= M <= 5\n *\n * Megjegyzés: Az eredmény nagy szám lehet, ezért Long típusban add vissza.\n */"
    },
    "prompt_bertscore": {
      "sq": "0.9556019386007008",
      "hy": "0.9471667022092921",
      "bn": "0.9198919700678675",
      "bg": "0.9575679821121841",
      "zh": "0.9254442851089357",
      "fr": "0.9593673747339792",
      "de": "0.9630543518667487",
      "ha": "0.9396876724721855",
      "hi": "0.9287155288541993",
      "hu": "0.9329237121068045"
    },
    "canonical_solution": "{\n    val dp = LongArray(N + 1)\n    dp[0] = 1\n    for (i in 1..N) {\n        if (i < M) {\n            dp[i] = 2 * dp[i - 1]\n        } else if (i == M) {\n            dp[i] = 2 * dp[i - 1] - 1\n        } else {\n            dp[i] = 2 * dp[i - 1] - dp[i - M - 1]\n        }\n    }\n    println(dp[N]);\n    return dp[N]\n}",
    "instruction": {
      "en": "Write a Kotlin function `fun countSafePlacementOptions(N: Int, M: Int): Long` to solve the following problem:\nGiven a laboratory with N test tubes arranged in a straight line, you need to find the number of ways\nto safely place chemicals in the test tubes. Placing chemicals in M consecutive test tubes will cause an explosion,\nso you need to ensure that no M consecutive test tubes contain chemicals.\n\nWrite a function that calculates the total number of safe placement options.\n\nExample:\n>>> countSafePlacementOptions(4, 3)\n13\n\nConstraints:\n1 < N < 32\n2 <= M <= 5\n\nNote: The result can be a large number, so return it as a Long.",
      "sq": "Shkruani një funksion Kotlin `fun countSafePlacementOptions(N: Int, M: Int): Long` për të zgjidhur problemin në vijim:  \nDuke pasur një laborator me N epruveta të renditura në një vijë të drejtë, ju duhet të gjeni numrin e mënyrave  \npër të vendosur në mënyrë të sigurt kimikatet në epruveta. Vendosja e kimikateve në M epruveta radhazi do të shkaktojë një shpërthim,  \nprandaj duhet të siguroheni që asnjë M epruveta radhazi të mos përmbajnë kimikate.\n\nShkruani një funksion që llogarit numrin total të opsioneve të vendosjes së sigurt.\n\nShembull:\n>>> countSafePlacementOptions(4, 3)\n13\n\nKufizimet:\n1 < N < 32\n2 <= M <= 5\n\nShënim: Rezultati mund të jetë një numër i madh, prandaj kthejeni atë si një Long.",
      "hy": "Գրեք Kotlin ֆունկցիա `fun countSafePlacementOptions(N: Int, M: Int): Long` հետևյալ խնդիրը լուծելու համար:\nՏրված է լաբորատորիա՝ N փորձանոթներով, որոնք դասավորված են ուղիղ գծով, դուք պետք է գտնեք քիմիկատները փորձանոթներում անվտանգ տեղադրելու եղանակների քանակը: Քիմիկատները M հաջորդական փորձանոթներում տեղադրելը կպատճառի պայթյուն, այնպես որ դուք պետք է ապահովեք, որ ոչ մի M հաջորդական փորձանոթներում քիմիկատներ չլինեն:\n\nԳրեք ֆունկցիա, որը կհաշվի անվտանգ տեղադրման տարբերակների ընդհանուր քանակը:\n\nՕրինակ:\n>>> countSafePlacementOptions(4, 3)\n13\n\nՊահանջներ:\n1 < N < 32\n2 <= M <= 5\n\nՆշում: Արդյունքը կարող է լինել մեծ թիվ, ուստի վերադարձնել այն որպես Long:",
      "bn": "Kotlin ফাংশন `fun countSafePlacementOptions(N: Int, M: Int): Long` লিখুন নিম্নলিখিত সমস্যার সমাধান করতে:\nএকটি পরীক্ষাগারে N টেস্ট টিউব সরলরেখায় সাজানো আছে, আপনাকে নিরাপদে রাসায়নিক পদার্থ রাখার উপায়গুলির সংখ্যা খুঁজে বের করতে হবে। M ধারাবাহিক টেস্ট টিউবে রাসায়নিক পদার্থ রাখলে বিস্ফোরণ ঘটবে, তাই আপনাকে নিশ্চিত করতে হবে যে কোনো M ধারাবাহিক টেস্ট টিউবে রাসায়নিক পদার্থ থাকবে না।\n\nএকটি ফাংশন লিখুন যা নিরাপদ স্থাপনার মোট বিকল্পের সংখ্যা গণনা করে।\n\nউদাহরণ:\n>>> countSafePlacementOptions(4, 3)\n13\n\nসীমাবদ্ধতা:\n1 < N < 32\n2 <= M <= 5\n\nদ্রষ্টব্য: ফলাফলটি একটি বড় সংখ্যা হতে পারে, তাই এটি Long হিসাবে ফেরত দিন।",
      "bg": "Напишете функция на Kotlin `fun countSafePlacementOptions(N: Int, M: Int): Long`, за да решите следния проблем:\nДадена е лаборатория с N епруветки, подредени в права линия, и трябва да намерите броя на начините\nза безопасно поставяне на химикали в епруветките. Поставянето на химикали в M последователни епруветки ще предизвика експлозия,\nтака че трябва да се уверите, че няма M последователни епруветки, които съдържат химикали.\n\nНапишете функция, която изчислява общия брой на безопасните варианти за поставяне.\n\nПример:\n>>> countSafePlacementOptions(4, 3)\n13\n\nОграничения:\n1 < N < 32\n2 <= M <= 5\n\nЗабележка: Резултатът може да бъде голямо число, затова го върнете като Long.",
      "zh": "编写一个 Kotlin 函数 `fun countSafePlacementOptions(N: Int, M: Int): Long` 来解决以下问题：\n给定一个实验室，其中有 N 个试管排列成一条直线，你需要找到安全放置化学品的方法数量。在 M 个连续的试管中放置化学品将导致爆炸，因此你需要确保没有 M 个连续的试管中含有化学品。\n\n编写一个函数来计算安全放置选项的总数。\n\n示例：\n>>> countSafePlacementOptions(4, 3)\n13\n\n约束条件：\n1 < N < 32\n2 <= M <= 5\n\n注意：结果可能是一个大数，因此返回值类型为 Long。",
      "fr": "Écrire une fonction Kotlin `fun countSafePlacementOptions(N: Int, M: Int): Long` pour résoudre le problème suivant :\nÉtant donné un laboratoire avec N tubes à essai disposés en ligne droite, vous devez trouver le nombre de façons\nde placer en toute sécurité des produits chimiques dans les tubes à essai. Placer des produits chimiques dans M tubes à essai consécutifs provoquera une explosion,\nvous devez donc vous assurer qu'aucun M tubes à essai consécutifs ne contiennent de produits chimiques.\n\nÉcrire une fonction qui calcule le nombre total d'options de placement sûr.\n\nExemple :\n>>> countSafePlacementOptions(4, 3)\n13\n\nContraintes :\n1 < N < 32\n2 <= M <= 5\n\nRemarque : Le résultat peut être un grand nombre, donc retournez-le sous forme de Long.",
      "de": "Schreiben Sie eine Kotlin-Funktion `fun countSafePlacementOptions(N: Int, M: Int): Long`, um das folgende Problem zu lösen:\nGegeben ist ein Labor mit N Reagenzgläsern, die in einer geraden Linie angeordnet sind. Sie müssen die Anzahl der Möglichkeiten finden,\nChemikalien sicher in den Reagenzgläsern zu platzieren. Das Platzieren von Chemikalien in M aufeinanderfolgenden Reagenzgläsern wird eine Explosion verursachen,\ndaher müssen Sie sicherstellen, dass keine M aufeinanderfolgenden Reagenzgläser Chemikalien enthalten.\n\nSchreiben Sie eine Funktion, die die Gesamtzahl der sicheren Platzierungsoptionen berechnet.\n\nBeispiel:\n>>> countSafePlacementOptions(4, 3)\n13\n\nEinschränkungen:\n1 < N < 32\n2 <= M <= 5\n\nHinweis: Das Ergebnis kann eine große Zahl sein, daher geben Sie es als Long zurück.",
      "ha": "Rubuta aikin Kotlin `fun countSafePlacementOptions(N: Int, M: Int): Long` don warware matsalar mai zuwa:\nAn ba da dakin gwaje-gwaje tare da N bututun gwaji da aka shirya a layi madaidaici, kana buƙatar nemo adadin hanyoyin\ndon sanya sinadarai cikin aminci a cikin bututun gwaji. Sanya sinadarai a cikin bututun gwaji M a jere zai haifar da fashewa,\ndon haka kana buƙatar tabbatar da cewa babu bututun gwaji M a jere da ke dauke da sinadarai.\n\nRubuta aiki wanda ke lissafin jimillar adadin zaɓuɓɓukan sanya sinadarai cikin aminci.\n\nMisali:\n>>> countSafePlacementOptions(4, 3)\n13\n\nƘuntatawa:\n1 < N < 32\n2 <= M <= 5\n\nLura: Sakamakon na iya zama babban adadi, don haka mayar da shi azaman Long.",
      "hi": "Kotlin फ़ंक्शन `fun countSafePlacementOptions(N: Int, M: Int): Long` लिखें ताकि निम्नलिखित समस्या का समाधान किया जा सके:\nदिए गए एक प्रयोगशाला में N टेस्ट ट्यूब्स एक सीधी रेखा में व्यवस्थित हैं, आपको उन तरीकों की संख्या खोजनी है\nजिनसे टेस्ट ट्यूब्स में रसायनों को सुरक्षित रूप से रखा जा सके। M लगातार टेस्ट ट्यूब्स में रसायन रखने से विस्फोट होगा,\nइसलिए आपको यह सुनिश्चित करना होगा कि कोई भी M लगातार टेस्ट ट्यूब्स में रसायन न हों।\n\nएक फ़ंक्शन लिखें जो सुरक्षित प्लेसमेंट विकल्पों की कुल संख्या की गणना करता है।\n\nउदाहरण:\n>>> countSafePlacementOptions(4, 3)\n13\n\nबाधाएं:\n1 < N < 32\n2 <= M <= 5\n\nनोट: परिणाम एक बड़ी संख्या हो सकती है, इसलिए इसे Long के रूप में लौटाएं।",
      "hu": "Írj egy Kotlin függvényt `fun countSafePlacementOptions(N: Int, M: Int): Long`, hogy megoldja a következő problémát:\nAdott egy laboratórium, ahol N kémcső van egyenes vonalban elrendezve, meg kell találni a módok számát,\nhogy biztonságosan helyezzünk el vegyszereket a kémcsövekben. Ha M egymást követő kémcsőben helyezünk el vegyszereket, az robbanást okoz,\nezért biztosítani kell, hogy ne legyen M egymást követő kémcső, amely vegyszereket tartalmaz.\n\nÍrj egy függvényt, amely kiszámítja a biztonságos elhelyezési lehetőségek összes számát.\n\nPélda:\n>>> countSafePlacementOptions(4, 3)\n13\n\nKorlátozások:\n1 < N < 32\n2 <= M <= 5\n\nMegjegyzés: Az eredmény lehet egy nagy szám, ezért Long típusban térjen vissza."
    },
    "instruction_bertscore": {
      "sq": "0.9974191954592136",
      "hy": "0.9757531893870712",
      "bn": "0.9533556276215772",
      "bg": "0.9865191546695432",
      "zh": "0.969876510933773",
      "fr": "0.9974191954592136",
      "de": "0.9908105640518019",
      "ha": "0.986996264844789",
      "hi": "0.9575137560181616",
      "hu": "0.9800068589969333"
    },
    "level": "easy",
    "test": "fun main() {\n    // Test cases\n    check(countSafePlacementOptions(4, 3) == 13L)\n    check(countSafePlacementOptions(3, 2) == 5L)\n    check(countSafePlacementOptions(5, 2) == 13L)\n    check(countSafePlacementOptions(7, 3) == 81L)\n    check(countSafePlacementOptions(10, 4) == 773L)\n    check(countSafePlacementOptions(12, 5) == 3525L)\n}\n\nmain()",
    "entry_point": "countSafePlacementOptions",
    "signature": "fun countSafePlacementOptions(N: Int, M: Int): Long",
    "docstring": {
      "en": "Given a laboratory with N test tubes arranged in a straight line, you need to find the number of ways\nto safely place chemicals in the test tubes. Placing chemicals in M consecutive test tubes will cause an explosion,\nso you need to ensure that no M consecutive test tubes contain chemicals.\n\nWrite a function that calculates the total number of safe placement options.\n\nExample:\n>>> countSafePlacementOptions(4, 3)\n13\n\nConstraints:\n1 < N < 32\n2 <= M <= 5\n\nNote: The result can be a large number, so return it as a Long.",
      "sq": "Duke pasur një laborator me N epruveta të renditura në një vijë të drejtë, ju duhet të gjeni numrin e mënyrave për të vendosur kimikate në mënyrë të sigurt në epruveta. Vendosja e kimikateve në M epruveta të njëpasnjëshme do të shkaktojë një shpërthim, kështu që ju duhet të siguroheni që asnjë M epruveta të njëpasnjëshme të mos përmbajnë kimikate.\n\nShkruani një funksion që llogarit numrin total të opsioneve të vendosjes së sigurt.\n\nShembull:\n>>> countSafePlacementOptions(4, 3)\n13\n\nKufizimet:\n1 < N < 32\n2 <= M <= 5\n\nShënim: Rezultati mund të jetë një numër i madh, kështu që kthejeni atë si një Long.",
      "hy": "Տրված է լաբորատորիա՝ N փորձանոթներով, որոնք դասավորված են ուղիղ գծով, դուք պետք է գտնեք քիմիկատները փորձանոթներում անվտանգ տեղադրելու եղանակների քանակը։ M հաջորդական փորձանոթներում քիմիկատներ տեղադրելը կպատճառի պայթյուն, ուստի պետք է ապահովեք, որ ոչ մի M հաջորդական փորձանոթներում քիմիկատներ չլինեն։\n\nԳրեք ֆունկցիա, որը կհաշվարկի անվտանգ տեղադրման տարբերակների ընդհանուր քանակը։\n\nՕրինակ:\n>>> countSafePlacementOptions(4, 3)\n13\n\nՊահանջներ:\n1 < N < 32\n2 <= M <= 5\n\nՆշում: Արդյունքը կարող է մեծ թիվ լինել, ուստի վերադարձնել այն որպես Long։",
      "bn": "একটি পরীক্ষাগারে N টি টেস্ট টিউব সোজা লাইনে সাজানো আছে, আপনাকে নিরাপদে রাসায়নিক পদার্থ রাখার উপায়ের সংখ্যা খুঁজে বের করতে হবে। M টি ধারাবাহিক টেস্ট টিউবে রাসায়নিক পদার্থ রাখলে বিস্ফোরণ ঘটবে, তাই আপনাকে নিশ্চিত করতে হবে যে কোনো M টি ধারাবাহিক টেস্ট টিউবে রাসায়নিক পদার্থ নেই।\n\nএকটি ফাংশন লিখুন যা নিরাপদ স্থাপনার মোট বিকল্পের সংখ্যা গণনা করে।\n\nউদাহরণ:\n>>> countSafePlacementOptions(4, 3)\n13\n\nসীমাবদ্ধতা:\n1 < N < 32\n2 <= M <= 5\n\nদ্রষ্টব্য: ফলাফল একটি বড় সংখ্যা হতে পারে, তাই এটি Long হিসেবে ফেরত দিন।",
      "bg": "Дадена е лаборатория с N епруветки, подредени в права линия, трябва да намерите броя на начините\nза безопасно поставяне на химикали в епруветките. Поставянето на химикали в M последователни епруветки ще предизвика експлозия,\nтака че трябва да се уверите, че няма M последователни епруветки, които съдържат химикали.\n\nНапишете функция, която изчислява общия брой на безопасните варианти за поставяне.\n\nПример:\n>>> countSafePlacementOptions(4, 3)\n13\n\nОграничения:\n1 < N < 32\n2 <= M <= 5\n\nЗабележка: Резултатът може да бъде голямо число, така че го върнете като Long.",
      "zh": "给定一个实验室，其中有 N 个试管排成一条直线，你需要找到安全放置化学品的方法数量。在 M 个连续的试管中放置化学品会导致爆炸，因此你需要确保没有 M 个连续的试管中含有化学品。\n\n编写一个函数来计算安全放置选项的总数。\n\n示例：\n>>> countSafePlacementOptions(4, 3)\n13\n\n约束条件：\n1 < N < 32\n2 <= M <= 5\n\n注意：结果可能是一个大数，因此返回时应为 Long 类型。",
      "fr": "Étant donné un laboratoire avec N tubes à essai disposés en ligne droite, vous devez trouver le nombre de façons de placer en toute sécurité des produits chimiques dans les tubes à essai. Placer des produits chimiques dans M tubes à essai consécutifs provoquera une explosion, vous devez donc vous assurer qu'aucun M tubes à essai consécutifs ne contiennent de produits chimiques.\n\nÉcrivez une fonction qui calcule le nombre total d'options de placement sûr.\n\nExemple :\n>>> countSafePlacementOptions(4, 3)\n13\n\nContraintes :\n1 < N < 32\n2 <= M <= 5\n\nRemarque : Le résultat peut être un nombre important, donc retournez-le en tant que Long.",
      "de": "Gegeben ist ein Labor mit N Reagenzgläsern, die in einer geraden Linie angeordnet sind. Sie müssen die Anzahl der Möglichkeiten finden,\nChemikalien sicher in den Reagenzgläsern zu platzieren. Das Platzieren von Chemikalien in M aufeinanderfolgenden Reagenzgläsern wird eine Explosion verursachen,\ndaher müssen Sie sicherstellen, dass keine M aufeinanderfolgenden Reagenzgläser Chemikalien enthalten.\n\nSchreiben Sie eine Funktion, die die Gesamtzahl der sicheren Platzierungsoptionen berechnet.\n\nBeispiel:\n>>> countSafePlacementOptions(4, 3)\n13\n\nEinschränkungen:\n1 < N < 32\n2 <= M <= 5\n\nHinweis: Das Ergebnis kann eine große Zahl sein, daher geben Sie es als Long zurück.",
      "ha": "An ba da dakin gwaje-gwaje tare da N na bututun gwaji da aka shirya a layi madaidaiciya, kuna buƙatar nemo yawan hanyoyin\nda za a sanya sinadarai cikin aminci a cikin bututun gwaji. Sanya sinadarai a cikin M na bututun gwaji masu jere zai haifar da fashewa,\ndon haka kuna buƙatar tabbatar da cewa babu M na bututun gwaji masu jere da ke dauke da sinadarai.\n\nRubuta wata aiki da ke ƙididdige jimillar adadin zaɓuɓɓukan sanya sinadarai cikin aminci.\n\nMisali:\n>>> countSafePlacementOptions(4, 3)\n13\n\nƘuntatawa:\n1 < N < 32\n2 <= M <= 5\n\nLura: Sakamakon na iya zama babban adadi, don haka ku mayar da shi a matsayin Long.",
      "hi": "एक प्रयोगशाला में N टेस्ट ट्यूब्स एक सीधी रेखा में व्यवस्थित हैं, आपको रसायनों को सुरक्षित रूप से रखने के तरीकों की संख्या खोजनी है। M लगातार टेस्ट ट्यूब्स में रसायन रखने से विस्फोट होगा, इसलिए आपको यह सुनिश्चित करना होगा कि कोई भी M लगातार टेस्ट ट्यूब्स में रसायन न हों।\n\nएक फ़ंक्शन लिखें जो सुरक्षित प्लेसमेंट विकल्पों की कुल संख्या की गणना करता है।\n\nउदाहरण:\n>>> countSafePlacementOptions(4, 3)\n13\n\nबाधाएं:\n1 < N < 32\n2 <= M <= 5\n\nध्यान दें: परिणाम एक बड़ी संख्या हो सकती है, इसलिए इसे Long के रूप में लौटाएं।",
      "hu": "Adott egy laboratórium N kémcsővel, amelyek egy egyenes vonalban vannak elrendezve. Meg kell találnod, hányféleképpen lehet biztonságosan elhelyezni a vegyszereket a kémcsövekben. Ha vegyszereket helyezel el M egymást követő kémcsőben, robbanás következik be, ezért biztosítanod kell, hogy ne legyen M egymást követő kémcső, amely vegyszereket tartalmaz.\n\nÍrj egy függvényt, amely kiszámítja a biztonságos elhelyezési lehetőségek összes számát.\n\nPélda:\n>>> countSafePlacementOptions(4, 3)\n13\n\nKorlátozások:\n1 < N < 32\n2 <= M <= 5\n\nMegjegyzés: Az eredmény lehet egy nagy szám, ezért Long típusban add vissza."
    },
    "docstring_bertscore": {
      "sq": "0.9967976809969555",
      "hy": "0.9711392042660117",
      "bn": "0.9650936899888339",
      "bg": "0.9928781076879941",
      "zh": "0.9636450786199465",
      "fr": "0.992883867969044",
      "de": "0.9966590369909932",
      "ha": "0.9708660874920888",
      "hi": "0.9594281556305758",
      "hu": "0.955170712043474"
    }
  },
  {
    "task_id": "Kotlin/4",
    "prompt": {
      "en": "/**\n * Given an integer 'n', find and return the count of numbers between 11 and 'n' (inclusive)\n * that are both prime and palindrome.\n *\n * Example:\n * >>> countPrimePalindromeNumbers(50)\n * 2 // Because there are two numbers, 11 and 22, that are prime and palindrome between 11 and 50.\n *\n * Note:\n * - A prime number is a positive integer greater than 1 that has no positive integer divisors other than 1 and itself.\n * - A palindrome number is a number that reads the same forwards and backwards.\n */\n\n\nfun countPrimePalindromeNumbers(n: Int): Int ",
      "sq": "/**\n * Duke pasur një numër të plotë 'n', gjeni dhe ktheni numrin e numrave midis 11 dhe 'n' (përfshirë)\n * që janë si numra të thjeshtë ashtu edhe palindrome.\n *\n * Shembull:\n * >>> countPrimePalindromeNumbers(50)\n * 2 // Sepse ka dy numra, 11 dhe 22, që janë numra të thjeshtë dhe palindrome midis 11 dhe 50.\n *\n * Shënim:\n * - Një numër i thjeshtë është një numër i plotë pozitiv më i madh se 1 që nuk ka ndarës pozitivë të tjerë përveç 1 dhe vetes.\n * - Një numër palindrome është një numër që lexohet njësoj përpara dhe prapa.\n */",
      "hy": "/**\n * Տրված է ամբողջ թիվ 'n', գտնել և վերադարձնել 11-ից 'n' (ներառյալ) թվերի քանակը,\n * որոնք և՛ պարզ են, և՛ պալինդրոմ:\n *\n * Օրինակ:\n * >>> countPrimePalindromeNumbers(50)\n * 2 // Քանի որ 11-ից 50 միջակայքում կան երկու թիվ՝ 11 և 22, որոնք պարզ են և պալինդրոմ:\n *\n * Նշում:\n * - Պարզ թիվը դրական ամբողջ թիվ է, որը մեծ է 1-ից և չունի դրական բաժանարարներ 1-ից և իրենից բացի:\n * - Պալինդրոմ թիվը թիվ է, որը նույնն է կարդացվում առաջ և հետ:\n */",
      "bn": "/**\n * একটি পূর্ণসংখ্যা 'n' দেওয়া হলে, 11 এবং 'n' (অন্তর্ভুক্ত) এর মধ্যে কতগুলি সংখ্যা আছে তা খুঁজে বের করুন এবং ফেরত দিন\n * যা উভয়ই মৌলিক সংখ্যা এবং প্যালিনড্রোম।\n *\n * উদাহরণ:\n * >>> countPrimePalindromeNumbers(50)\n * 2 // কারণ 11 এবং 22 দুটি সংখ্যা আছে, যা 11 এবং 50 এর মধ্যে মৌলিক সংখ্যা এবং প্যালিনড্রোম।\n *\n * নোট:\n * - একটি মৌলিক সংখ্যা হল 1 এর চেয়ে বড় একটি ধনাত্মক পূর্ণসংখ্যা যার 1 এবং তার নিজস্ব ছাড়া অন্য কোনো ধনাত্মক পূর্ণসংখ্যা বিভাজক নেই।\n * - একটি প্যালিনড্রোম সংখ্যা হল একটি সংখ্যা যা সামনের দিক থেকে এবং পিছনের দিক থেকে একইভাবে পড়া যায়।\n */",
      "bg": "/**\n * Дадено е цяло число 'n', намерете и върнете броя на числата между 11 и 'n' (включително),\n * които са едновременно прости и палиндроми.\n *\n * Пример:\n * >>> countPrimePalindromeNumbers(50)\n * 2 // Защото има две числа, 11 и 22, които са прости и палиндроми между 11 и 50.\n *\n * Забележка:\n * - Просто число е положително цяло число, по-голямо от 1, което няма положителни делители, различни от 1 и самото него.\n * - Палиндром е число, което се чете еднакво напред и назад.\n */",
      "zh": "/**\n * 给定一个整数 'n'，找到并返回在 11 和 'n'（包括 'n'）之间既是质数又是回文数的数量。\n *\n * 例子:\n * >>> countPrimePalindromeNumbers(50)\n * 2 // 因为在 11 和 50 之间有两个数，11 和 22，既是质数又是回文数。\n *\n * 注意:\n * - 质数是大于 1 的正整数，除了 1 和它本身外没有其他正整数因子。\n * - 回文数是指正反读都相同的数。\n */",
      "fr": "/**\n * Étant donné un entier 'n', trouver et retourner le nombre de nombres entre 11 et 'n' (inclus)\n * qui sont à la fois premiers et palindromes.\n *\n * Exemple:\n * >>> countPrimePalindromeNumbers(50)\n * 2 // Parce qu'il y a deux nombres, 11 et 22, qui sont premiers et palindromes entre 11 et 50.\n *\n * Remarque:\n * - Un nombre premier est un entier positif supérieur à 1 qui n'a pas de diviseurs entiers positifs autres que 1 et lui-même.\n * - Un nombre palindrome est un nombre qui se lit de la même manière à l'endroit et à l'envers.\n */",
      "de": "/**\n * Gegeben eine ganze Zahl 'n', finde und gib die Anzahl der Zahlen zwischen 11 und 'n' (einschließlich) zurück,\n * die sowohl prim als auch palindrom sind.\n *\n * Beispiel:\n * >>> countPrimePalindromeNumbers(50)\n * 2 // Weil es zwei Zahlen gibt, 11 und 22, die zwischen 11 und 50 prim und palindrom sind.\n *\n * Hinweis:\n * - Eine Primzahl ist eine positive ganze Zahl größer als 1, die keine positiven ganzzahligen Teiler außer 1 und sich selbst hat.\n * - Eine Palindromzahl ist eine Zahl, die vorwärts und rückwärts gleich gelesen wird.\n */",
      "ha": "/**\n * An ba da wata lamba 'n', nemo kuma dawo da adadin lambobin da ke tsakanin 11 da 'n' (ciki har da su)\n * waɗanda suke duka lambobin farko da palindrome.\n *\n * Misali:\n * >>> countPrimePalindromeNumbers(50)\n * 2 // Domin akwai lambobi biyu, 11 da 22, waɗanda suke lambobin farko da palindrome tsakanin 11 da 50.\n *\n * Lura:\n * - Lamba ta farko ita ce lamba mai kyau wadda ta fi 1 girma kuma ba ta da masu raba lamba masu kyau banda 1 da kanta.\n * - Lamba palindrome ita ce lamba da ake karantawa iri ɗaya a gaba da baya.\n */",
      "hi": "/**\n * दिए गए पूर्णांक 'n' के लिए, 11 और 'n' (समावेशी) के बीच उन संख्याओं की गिनती खोजें और लौटाएं\n * जो दोनों, अभाज्य और पालिंड्रोम हैं।\n *\n * उदाहरण:\n * >>> countPrimePalindromeNumbers(50)\n * 2 // क्योंकि 11 और 22 दो संख्याएँ हैं जो 11 और 50 के बीच अभाज्य और पालिंड्रोम हैं।\n *\n * नोट:\n * - एक अभाज्य संख्या एक धनात्मक पूर्णांक है जो 1 से बड़ा होता है और जिसका कोई धनात्मक पूर्णांक भाजक नहीं होता सिवाय 1 और स्वयं के।\n * - एक पालिंड्रोम संख्या वह संख्या होती है जो आगे और पीछे से समान पढ़ी जाती है।\n */",
      "hu": "/**\n * Adott egy egész szám 'n', keresse meg és adja vissza az 11 és 'n' közötti (beleértve)\n * számok számát, amelyek egyszerre prímek és palindromok.\n *\n * Példa:\n * >>> countPrimePalindromeNumbers(50)\n * 2 // Mert két szám van, 11 és 22, amelyek prímek és palindromok 11 és 50 között.\n *\n * Megjegyzés:\n * - A prímszám olyan pozitív egész szám, amely nagyobb, mint 1, és nincs más pozitív egész osztója, mint 1 és önmaga.\n * - A palindrom szám olyan szám, amely előre és hátra olvasva is ugyanaz.\n */"
    },
    "prompt_bertscore": {
      "sq": "0.946385886181444",
      "hy": "0.9310907509506146",
      "bn": "0.9361681407506284",
      "bg": "0.9475333738926826",
      "zh": "0.9271352255426858",
      "fr": "0.9576512082418377",
      "de": "0.9707282380076506",
      "ha": "0.9529573737076023",
      "hi": "0.954857869193344",
      "hu": "0.9596087106469365"
    },
    "canonical_solution": "{\n    var count = 0\n    for (i in 11..n) {\n        if (isPrime(i) && isPalindrome(i)) {\n            count++\n        }\n    }\n    return count\n}\n\nfun isPrime(x: Int): Boolean {\n    if (x <= 1) return false\n    for (i in 2..(x / 2)) {\n        if (x % i == 0) {\n            return false\n        }\n    }\n    return true\n}\n\nfun isPalindrome(x: Int): Boolean {\n    val strX = x.toString()\n    return strX == strX.reversed()\n}",
    "instruction": {
      "en": "Write a Kotlin function `fun countPrimePalindromeNumbers(n: Int): Int` to solve the following problem:\nGiven an integer 'n', find and return the count of numbers between 11 and 'n' (inclusive)\nthat are both prime and palindrome.\n\nExample:\n>>> countPrimePalindromeNumbers(50)\n2 // Because there are two numbers, 11 and 22, that are prime and palindrome between 11 and 50.\n\nNote:\n- A prime number is a positive integer greater than 1 that has no positive integer divisors other than 1 and itself.\n- A palindrome number is a number that reads the same forwards and backwards.",
      "sq": "Shkruani një funksion Kotlin `fun countPrimePalindromeNumbers(n: Int): Int` për të zgjidhur problemin e mëposhtëm:\nDuke pasur një numër të plotë 'n', gjeni dhe ktheni numrin e numrave midis 11 dhe 'n' (përfshirë)\nqë janë si numra të thjeshtë ashtu edhe palindromë.\n\nShembull:\n>>> countPrimePalindromeNumbers(50)\n2 // Sepse ka dy numra, 11 dhe 22, që janë numra të thjeshtë dhe palindromë midis 11 dhe 50.\n\nShënim:\n- Një numër i thjeshtë është një numër i plotë pozitiv më i madh se 1 që nuk ka ndarës pozitivë të tjerë përveç 1 dhe vetes.\n- Një numër palindromë është një numër që lexohet njësoj përpara dhe prapa.",
      "hy": "Գրեք Kotlin ֆունկցիա `fun countPrimePalindromeNumbers(n: Int): Int` հետևյալ խնդիրը լուծելու համար:\nՏրված է ամբողջ թիվ 'n', գտնել և վերադարձնել 11-ից մինչև 'n' (ներառյալ) այն թվերի քանակը,\nորոնք և՛ պարզ են, և՛ պալինդրոմ են:\n\nՕրինակ:\n>>> countPrimePalindromeNumbers(50)\n2 // Քանի որ 11-ից մինչև 50 երկու թիվ կա, 11 և 22, որոնք պարզ և պալինդրոմ են:\n\nՆշում:\n- Պարզ թիվը դրական ամբողջ թիվ է, որը մեծ է 1-ից և չունի դրական ամբողջ թվային բաժանարարներ 1-ից և իրենից բացի:\n- Պալինդրոմ թիվը թիվ է, որը ընթերցվում է նույնը թե՛ առաջ, թե՛ հետ:",
      "bn": "Kotlin ফাংশন `fun countPrimePalindromeNumbers(n: Int): Int` লিখুন নিম্নলিখিত সমস্যার সমাধানের জন্য:\nএকটি পূর্ণসংখ্যা 'n' দেওয়া আছে, 11 এবং 'n' (অন্তর্ভুক্ত) এর মধ্যে কতগুলি সংখ্যা আছে যা উভয়ই মৌলিক সংখ্যা এবং প্যালিনড্রোম তা খুঁজে বের করুন এবং ফেরত দিন।\n\nউদাহরণ:\n>>> countPrimePalindromeNumbers(50)\n2 // কারণ 11 এবং 22 এই দুটি সংখ্যা 11 এবং 50 এর মধ্যে মৌলিক সংখ্যা এবং প্যালিনড্রোম।\n\nনোট:\n- একটি মৌলিক সংখ্যা হল একটি ধনাত্মক পূর্ণসংখ্যা যা 1 এবং এর নিজস্ব ছাড়া অন্য কোনো ধনাত্মক পূর্ণসংখ্যা বিভাজক নেই।\n- একটি প্যালিনড্রোম সংখ্যা হল একটি সংখ্যা যা সামনে থেকে এবং পিছন থেকে একইভাবে পড়া যায়।",
      "bg": "Напишете функция на Kotlin `fun countPrimePalindromeNumbers(n: Int): Int`, за да решите следния проблем:\nДадено е цяло число 'n', намерете и върнете броя на числата между 11 и 'n' (включително), които са както прости, така и палиндроми.\n\nПример:\n>>> countPrimePalindromeNumbers(50)\n2 // Защото има две числа, 11 и 22, които са прости и палиндроми между 11 и 50.\n\nЗабележка:\n- Просто число е положително цяло число, по-голямо от 1, което няма положителни делители, различни от 1 и самото него.\n- Палиндром число е число, което се чете еднакво напред и назад.",
      "zh": "编写一个 Kotlin 函数 `fun countPrimePalindromeNumbers(n: Int): Int` 来解决以下问题：\n给定一个整数 'n'，查找并返回在 11 和 'n' 之间（包括 'n'）既是质数又是回文数的数字的数量。\n\n示例：\n>>> countPrimePalindromeNumbers(50)\n2 // 因为在 11 和 50 之间有两个数字，11 和 22，既是质数又是回文数。\n\n注意：\n- 质数是大于 1 的正整数，除了 1 和它本身之外没有其他正整数因子。\n- 回文数是指正反读都相同的数字。",
      "fr": "Écrire une fonction Kotlin `fun countPrimePalindromeNumbers(n: Int): Int` pour résoudre le problème suivant :\nÉtant donné un entier 'n', trouver et retourner le nombre de nombres entre 11 et 'n' (inclus)\nqui sont à la fois premiers et palindromes.\n\nExemple :\n>>> countPrimePalindromeNumbers(50)\n2 // Parce qu'il y a deux nombres, 11 et 22, qui sont premiers et palindromes entre 11 et 50.\n\nRemarque :\n- Un nombre premier est un entier positif supérieur à 1 qui n'a pas de diviseurs entiers positifs autres que 1 et lui-même.\n- Un nombre palindrome est un nombre qui se lit de la même manière dans les deux sens.",
      "de": "Schreiben Sie eine Kotlin-Funktion `fun countPrimePalindromeNumbers(n: Int): Int`, um das folgende Problem zu lösen:\nGegeben eine ganze Zahl 'n', finden und geben Sie die Anzahl der Zahlen zwischen 11 und 'n' (einschließlich) zurück,\ndie sowohl Primzahlen als auch Palindrome sind.\n\nBeispiel:\n>>> countPrimePalindromeNumbers(50)\n2 // Weil es zwei Zahlen gibt, 11 und 22, die zwischen 11 und 50 sowohl Primzahlen als auch Palindrome sind.\n\nHinweis:\n- Eine Primzahl ist eine positive ganze Zahl größer als 1, die keine positiven ganzzahligen Teiler außer 1 und sich selbst hat.\n- Eine Palindromzahl ist eine Zahl, die vorwärts und rückwärts gleich gelesen wird.",
      "ha": "Rubuta aikin Kotlin `fun countPrimePalindromeNumbers(n: Int): Int` don warware matsalar mai zuwa:\nAn ba da cikakken lamba 'n', nemo kuma dawo da adadin lambobin tsakanin 11 da 'n' (ciki har da)\nwadanda duka lambobi ne masu firamare kuma palindrome.\n\nMisali:\n>>> countPrimePalindromeNumbers(50)\n2 // Domin akwai lambobi biyu, 11 da 22, waɗanda lambobi ne masu firamare kuma palindrome tsakanin 11 da 50.\n\nLura:\n- Lamba mai firamare ita ce cikakken lamba mai kyau wanda ya fi 1 girma wanda ba shi da wani mai raba lamba mai kyau sai dai 1 da kanta.\n- Lamba palindrome ita ce lamba da ake karantawa iri ɗaya gaba da baya.",
      "hi": "Kotlin फ़ंक्शन `fun countPrimePalindromeNumbers(n: Int): Int` लिखें ताकि निम्नलिखित समस्या का समाधान किया जा सके:\nदिए गए पूर्णांक 'n' के लिए, 11 और 'n' (समावेशी) के बीच उन संख्याओं की गिनती खोजें और लौटाएं\nजो दोनों, अभाज्य और पालिंड्रोम हैं।\n\nउदाहरण:\n>>> countPrimePalindromeNumbers(50)\n2 // क्योंकि 11 और 22 दो संख्याएँ हैं, जो 11 और 50 के बीच अभाज्य और पालिंड्रोम हैं।\n\nध्यान दें:\n- एक अभाज्य संख्या एक धनात्मक पूर्णांक है जो 1 और स्वयं के अलावा अन्य कोई धनात्मक पूर्णांक भाजक नहीं रखती।\n- एक पालिंड्रोम संख्या वह संख्या है जो आगे और पीछे से पढ़ने पर समान होती है।",
      "hu": "Írj egy Kotlin függvényt `fun countPrimePalindromeNumbers(n: Int): Int` a következő probléma megoldására:\nAdott egy egész szám 'n', találd meg és add vissza azon számok számát 11 és 'n' között (beleértve),\namelyek egyszerre prímek és palindromok.\n\nPélda:\n>>> countPrimePalindromeNumbers(50)\n2 // Mert két szám van, 11 és 22, amelyek prímek és palindromok 11 és 50 között.\n\nMegjegyzés:\n- A prímszám olyan pozitív egész szám, amely nagyobb, mint 1, és nincsenek pozitív egész osztói 1-en és önmagán kívül.\n- A palindrom szám olyan szám, amely előre és hátrafelé olvasva is ugyanaz."
    },
    "instruction_bertscore": {
      "sq": "0.9922951275196567",
      "hy": "0.9657007044332765",
      "bn": "0.9218957533517474",
      "bg": "0.97722702681435",
      "zh": "0.9593943884657998",
      "fr": "0.9666116233607025",
      "de": "0.9736566457152479",
      "ha": "0.9724722127531369",
      "hi": "0.9596265873812296",
      "hu": "0.9831408491489018"
    },
    "level": "middle",
    "test": "fun main() {\n    check(countPrimePalindromeNumbers(50) == 1) // There are two prime palindrome numbers between 11 and 50 (11).\n    check(countPrimePalindromeNumbers(150) == 3) // There are three prime palindrome numbers between 11 and 100 (11, 101, 131).\n    check(countPrimePalindromeNumbers(200) == 6) // There are four prime palindrome numbers between 11 and 200 (11, 101, 131, 151, 181, 191).\n    check(countPrimePalindromeNumbers(11) == 1)  // The only prime palindrome number between 11 and 11 is 11 itself.\n}\n\nmain()",
    "entry_point": "countPrimePalindromeNumbers",
    "signature": "fun countPrimePalindromeNumbers(n: Int): Int",
    "docstring": {
      "en": "Given an integer 'n', find and return the count of numbers between 11 and 'n' (inclusive)\nthat are both prime and palindrome.\n\nExample:\n>>> countPrimePalindromeNumbers(50)\n2 // Because there are two numbers, 11 and 22, that are prime and palindrome between 11 and 50.\n\nNote:\n- A prime number is a positive integer greater than 1 that has no positive integer divisors other than 1 and itself.\n- A palindrome number is a number that reads the same forwards and backwards.",
      "sq": "Duke pasur një numër të plotë 'n', gjeni dhe kthejeni numrin e numrave midis 11 dhe 'n' (përfshirë) që janë njëkohësisht numra të thjeshtë dhe palindromë.\n\nShembull:\n>>> countPrimePalindromeNumbers(50)\n2 // Sepse ka dy numra, 11 dhe 22, që janë numra të thjeshtë dhe palindromë midis 11 dhe 50.\n\nShënim:\n- Një numër i thjeshtë është një numër i plotë pozitiv më i madh se 1 që nuk ka ndarës pozitivë të tjerë përveç 1 dhe vetes.\n- Një numër palindromë është një numër që lexohet njësoj përpara dhe mbrapa.",
      "hy": "Տրված է ամբողջ թիվ 'n', գտնել և վերադարձնել 11-ից 'n' (ներառյալ) թվերի քանակը, որոնք միաժամանակ պարզ և պալինդրոմ են:\n\nՕրինակ:\n>>> countPrimePalindromeNumbers(50)\n2 // Որովհետև կա երկու թիվ՝ 11 և 22, որոնք պարզ և պալինդրոմ են 11-ից 50 միջակայքում:\n\nՆշում:\n- Պարզ թիվը դրական ամբողջ թիվ է, որը մեծ է 1-ից և չունի դրական ամբողջ թվային բաժանարարներ, բացի 1-ից և իրենից:\n- Պալինդրոմ թիվը թիվ է, որը կարդացվում է նույն կերպ առաջ և հետ:",
      "bn": "একটি পূর্ণসংখ্যা 'n' দেওয়া হলে, 11 এবং 'n' (অন্তর্ভুক্ত) এর মধ্যে কতগুলি সংখ্যা উভয়ই মৌলিক এবং প্যালিনড্রোম তা খুঁজে বের করুন এবং ফেরত দিন।\n\nউদাহরণ:\n>>> countPrimePalindromeNumbers(50)\n2 // কারণ 11 এবং 22 দুটি সংখ্যা, যা 11 এবং 50 এর মধ্যে মৌলিক এবং প্যালিনড্রোম।\n\nনোট:\n- একটি মৌলিক সংখ্যা হল একটি ধনাত্মক পূর্ণসংখ্যা যা 1 এবং নিজে ছাড়া অন্য কোনো ধনাত্মক পূর্ণসংখ্যা দ্বারা বিভাজ্য নয়।\n- একটি প্যালিনড্রোম সংখ্যা হল একটি সংখ্যা যা সামনে এবং পেছনে একইভাবে পড়ে।",
      "bg": "Дадено е цяло число 'n', намерете и върнете броя на числата между 11 и 'n' (включително), които са едновременно прости и палиндроми.\n\nПример:\n>>> countPrimePalindromeNumbers(50)\n2 // Защото има две числа, 11 и 22, които са прости и палиндроми между 11 и 50.\n\nЗабележка:\n- Просто число е положително цяло число, по-голямо от 1, което няма положителни делители, различни от 1 и самото него.\n- Палиндромно число е число, което се чете еднакво напред и назад.",
      "zh": "给定一个整数 'n'，找到并返回在 11 和 'n'（包括 'n'）之间既是质数又是回文数的数字个数。\n\n示例：\n>>> countPrimePalindromeNumbers(50)\n2 // 因为在 11 和 50 之间有两个数字，11 和 22，它们既是质数又是回文数。\n\n注意：\n- 质数是大于 1 的正整数，除了 1 和它本身没有其他正整数因子。\n- 回文数是指正反读都相同的数字。",
      "fr": "Étant donné un entier 'n', trouvez et renvoyez le nombre de nombres entre 11 et 'n' (inclus) qui sont à la fois premiers et palindromes.\n\nExemple :\n>>> countPrimePalindromeNumbers(50)\n2 // Parce qu'il y a deux nombres, 11 et 22, qui sont premiers et palindromes entre 11 et 50.\n\nRemarque :\n- Un nombre premier est un entier positif supérieur à 1 qui n'a pas de diviseurs entiers positifs autres que 1 et lui-même.\n- Un nombre palindrome est un nombre qui se lit de la même façon à l'endroit et à l'envers.",
      "de": "Gegeben eine ganze Zahl 'n', finde und gib die Anzahl der Zahlen zwischen 11 und 'n' (einschließlich) zurück, die sowohl prim als auch palindrom sind.\n\nBeispiel:\n>>> countPrimePalindromeNumbers(50)\n2 // Weil es zwei Zahlen gibt, 11 und 22, die prim und palindrom zwischen 11 und 50 sind.\n\nHinweis:\n- Eine Primzahl ist eine positive ganze Zahl größer als 1, die keine positiven ganzzahligen Teiler außer 1 und sich selbst hat.\n- Eine Palindromzahl ist eine Zahl, die vorwärts und rückwärts gleich gelesen wird.",
      "ha": "An ba da wata lamba 'n', nemo kuma dawo da adadin lambobi tsakanin 11 da 'n' (ciki har da)\nwanda duka biyun lambobi ne masu lamba kuma palindrome.\n\nMisali:\n>>> countPrimePalindromeNumbers(50)\n2 // Saboda akwai lambobi biyu, 11 da 22, waɗanda lambobi ne masu lamba kuma palindrome tsakanin 11 da 50.\n\nLura:\n- Lamba mai lamba ita ce cikakken lamba mai kyau fiye da 1 wanda ba shi da masu raba lamba masu kyau banda 1 da kansa.\n- Lamba palindrome ita ce lamba da ke karanta iri ɗaya gaba da baya.",
      "hi": "दिए गए पूर्णांक 'n' के लिए, 11 और 'n' (समावेशी) के बीच उन संख्याओं की गिनती खोजें और लौटाएं जो दोनों ही अभाज्य और पालिंड्रोम हैं।\n\nउदाहरण:\n>>> countPrimePalindromeNumbers(50)\n2 // क्योंकि 11 और 22 दो संख्याएँ हैं जो 11 और 50 के बीच अभाज्य और पालिंड्रोम हैं।\n\nध्यान दें:\n- एक अभाज्य संख्या एक धनात्मक पूर्णांक है जो 1 और स्वयं के अलावा किसी अन्य धनात्मक पूर्णांक से विभाजित नहीं होता है।\n- एक पालिंड्रोम संख्या वह संख्या है जो आगे और पीछे से पढ़ने पर समान होती है।",
      "hu": "Adott egy egész szám, 'n', találja meg és adja vissza azoknak a számoknak a számát 11 és 'n' között (beleértve), amelyek egyszerre prímek és palindrómák.\n\nPélda:\n>>> countPrimePalindromeNumbers(50)\n2 // Mert két szám van, 11 és 22, amelyek prímek és palindrómák 11 és 50 között.\n\nMegjegyzés:\n- A prímszám egy olyan pozitív egész szám, amely nagyobb, mint 1, és nincs más pozitív egész osztója, mint 1 és önmaga.\n- Egy palindróm szám olyan szám, amely előre és hátrafelé olvasva is ugyanaz."
    },
    "docstring_bertscore": {
      "sq": "0.9659599170805271",
      "hy": "0.9852226941725285",
      "bn": "0.943698615756423",
      "bg": "0.9738326322328449",
      "zh": "0.9442023424027275",
      "fr": "0.9762670461828085",
      "de": "0.9948064114270808",
      "ha": "0.9543604987192327",
      "hi": "0.9483948338552308",
      "hu": "0.9734609947899285"
    }
  },
  {
    "task_id": "Kotlin/5",
    "prompt": {
      "en": "/**\n    * Given a limit, find all Pythagorean triplets (a, b, c) such that a < b < c and a + b + c <= limit.\n    * A Pythagorean triplet is a set of three positive integers a, b, and c, where a^2 + b^2 = c^2.\n    * The function returns a list of triples (a, b, c) that satisfy the conditions.\n    *\n    * Example:\n    * >>> findPythagoreanTriplets(30)\n    * [(3, 4, 5), (5, 12, 13), (6, 8, 10)]\n    *\n    * Explanation: For limit=30, the function finds Pythagorean triplets where a + b + c is less than or equal to 30.\n    * (3, 4, 5) is the first triplet with a^2 + b^2 = c^2 and a + b + c = 12, which is less than 30.\n    * (5, 12, 13) and (6, 8, 10) are other valid triplets.\n**/\n\n\nfun findPythagoreanTriplets(limit: Int): List<Triple<Int, Int, Int>> ",
      "sq": "/**\n    * Duke pasur një kufi, gjej të gjitha treshet Pitagoriane (a, b, c) të tilla që a < b < c dhe a + b + c <= kufi.\n    * Një treshe Pitagoriane është një grup prej tre numrash të plotë pozitivë a, b, dhe c, ku a^2 + b^2 = c^2.\n    * Funksioni kthen një listë treshe (a, b, c) që plotësojnë kushtet.\n    *\n    * Shembull:\n    * >>> findPythagoreanTriplets(30)\n    * [(3, 4, 5), (5, 12, 13), (6, 8, 10)]\n    *\n    * Shpjegim: Për kufi=30, funksioni gjen treshet Pitagoriane ku a + b + c është më pak ose e barabartë me 30.\n    * (3, 4, 5) është tresha e parë me a^2 + b^2 = c^2 dhe a + b + c = 12, që është më pak se 30.\n    * (5, 12, 13) dhe (6, 8, 10) janë treshe të tjera të vlefshme.\n**/",
      "hy": "/**\n    * Տրված սահմանաչափի դեպքում գտնել բոլոր Պյութագորասյան եռյակները (a, b, c), այնպես որ a < b < c և a + b + c <= սահմանաչափ:\n    * Պյութագորասյան եռյակն այնպիսի երեք դրական ամբողջ թվերի հավաքածու է a, b և c, որտեղ a^2 + b^2 = c^2:\n    * Ֆունկցիան վերադարձնում է եռյակների (a, b, c) ցուցակը, որոնք բավարարում են պայմանները:\n    *\n    * Օրինակ:\n    * >>> findPythagoreanTriplets(30)\n    * [(3, 4, 5), (5, 12, 13), (6, 8, 10)]\n    *\n    * Բացատրություն: limit=30-ի դեպքում ֆունկցիան գտնում է Պյութագորասյան եռյակներ, որտեղ a + b + c փոքր կամ հավասար է 30-ին:\n    * (3, 4, 5) առաջին եռյակն է, որտեղ a^2 + b^2 = c^2 և a + b + c = 12, որը փոքր է 30-ից:\n    * (5, 12, 13) և (6, 8, 10) այլ վավեր եռյակներ են:\n**/",
      "bn": "/**\n    * একটি সীমা দেওয়া হলে, সমস্ত পিথাগোরিয়ান ট্রিপলেট (a, b, c) খুঁজে বের করুন যেখানে a < b < c এবং a + b + c <= সীমা।\n    * একটি পিথাগোরিয়ান ট্রিপলেট হল তিনটি ধনাত্মক পূর্ণসংখ্যার সেট a, b, এবং c, যেখানে a^2 + b^2 = c^2।\n    * ফাংশনটি এমন ট্রিপলগুলির একটি তালিকা প্রদান করে যা শর্তগুলি পূরণ করে।\n    *\n    * উদাহরণ:\n    * >>> findPythagoreanTriplets(30)\n    * [(3, 4, 5), (5, 12, 13), (6, 8, 10)]\n    *\n    * ব্যাখ্যা: limit=30 এর জন্য, ফাংশনটি পিথাগোরিয়ান ট্রিপলেট খুঁজে পায় যেখানে a + b + c 30 এর চেয়ে কম বা সমান।\n    * (3, 4, 5) হল প্রথম ট্রিপলেট যেখানে a^2 + b^2 = c^2 এবং a + b + c = 12, যা 30 এর চেয়ে কম।\n    * (5, 12, 13) এবং (6, 8, 10) অন্যান্য বৈধ ট্রিপলেট।\n**/",
      "bg": "/**\n    * Дадена е граница, намерете всички Питагорови тройки (a, b, c) такива, че a < b < c и a + b + c <= границата.\n    * Питагорова тройка е набор от три положителни цели числа a, b и c, където a^2 + b^2 = c^2.\n    * Функцията връща списък от тройки (a, b, c), които удовлетворяват условията.\n    *\n    * Пример:\n    * >>> findPythagoreanTriplets(30)\n    * [(3, 4, 5), (5, 12, 13), (6, 8, 10)]\n    *\n    * Обяснение: За граница=30, функцията намира Питагорови тройки, където a + b + c е по-малко или равно на 30.\n    * (3, 4, 5) е първата тройка с a^2 + b^2 = c^2 и a + b + c = 12, което е по-малко от 30.\n    * (5, 12, 13) и (6, 8, 10) са други валидни тройки.\n**/",
      "zh": "/**\n    * 给定一个限制，找到所有的毕达哥拉斯三元组 (a, b, c)，使得 a < b < c 且 a + b + c <= 限制。\n    * 毕达哥拉斯三元组是一组三个正整数 a, b 和 c，其中 a^2 + b^2 = c^2。\n    * 该函数返回满足条件的三元组 (a, b, c) 的列表。\n    *\n    * 示例:\n    * >>> findPythagoreanTriplets(30)\n    * [(3, 4, 5), (5, 12, 13), (6, 8, 10)]\n    *\n    * 解释: 对于 limit=30，该函数找到 a + b + c 小于或等于 30 的毕达哥拉斯三元组。\n    * (3, 4, 5) 是第一个三元组，满足 a^2 + b^2 = c^2 且 a + b + c = 12，小于 30。\n    * (5, 12, 13) 和 (6, 8, 10) 是其他有效的三元组。\n**/",
      "fr": "/**\n    * Étant donné une limite, trouver tous les triplets pythagoriciens (a, b, c) tels que a < b < c et a + b + c <= limite.\n    * Un triplet pythagoricien est un ensemble de trois entiers positifs a, b et c, où a^2 + b^2 = c^2.\n    * La fonction retourne une liste de triplets (a, b, c) qui satisfont les conditions.\n    *\n    * Exemple :\n    * >>> findPythagoreanTriplets(30)\n    * [(3, 4, 5), (5, 12, 13), (6, 8, 10)]\n    *\n    * Explication : Pour limite=30, la fonction trouve des triplets pythagoriciens où a + b + c est inférieur ou égal à 30.\n    * (3, 4, 5) est le premier triplet avec a^2 + b^2 = c^2 et a + b + c = 12, ce qui est inférieur à 30.\n    * (5, 12, 13) et (6, 8, 10) sont d'autres triplets valides.\n**/",
      "de": "/**\n    * Gegeben ein Limit, finde alle pythagoreischen Tripel (a, b, c) so dass a < b < c und a + b + c <= Limit.\n    * Ein pythagoreisches Tripel ist eine Menge von drei positiven ganzen Zahlen a, b und c, wobei a^2 + b^2 = c^2.\n    * Die Funktion gibt eine Liste von Tripeln (a, b, c) zurück, die die Bedingungen erfüllen.\n    *\n    * Beispiel:\n    * >>> findPythagoreanTriplets(30)\n    * [(3, 4, 5), (5, 12, 13), (6, 8, 10)]\n    *\n    * Erklärung: Für Limit=30 findet die Funktion pythagoreische Tripel, bei denen a + b + c kleiner oder gleich 30 ist.\n    * (3, 4, 5) ist das erste Tripel mit a^2 + b^2 = c^2 und a + b + c = 12, was kleiner als 30 ist.\n    * (5, 12, 13) und (6, 8, 10) sind andere gültige Tripel.\n**/",
      "ha": "/**\n    * Idan aka ba da iyaka, nemo dukkan triplets na Pythagorean (a, b, c) inda a < b < c kuma a + b + c <= iyaka.\n    * Triplet na Pythagorean ya ƙunshi saitin lambobi guda uku masu kyau a, b, da c, inda a^2 + b^2 = c^2.\n    * Aikin yana mayar da jerin triples (a, b, c) waɗanda suka cika sharuɗɗan.\n    *\n    * Misali:\n    * >>> findPythagoreanTriplets(30)\n    * [(3, 4, 5), (5, 12, 13), (6, 8, 10)]\n    *\n    * Bayani: Don iyaka=30, aikin yana nemo triplets na Pythagorean inda a + b + c ya kasance ƙasa ko daidai da 30.\n    * (3, 4, 5) shine triplet na farko tare da a^2 + b^2 = c^2 kuma a + b + c = 12, wanda ya kasance ƙasa da 30.\n    * (5, 12, 13) da (6, 8, 10) su ne sauran triplets masu inganci.\n**/",
      "hi": "/**\n    * दिए गए सीमा के लिए, सभी पाइथागोरियन ट्रिपलेट्स (a, b, c) खोजें ताकि a < b < c और a + b + c <= सीमा हो।\n    * एक पाइथागोरियन ट्रिपलेट तीन धनात्मक पूर्णांकों का सेट होता है a, b, और c, जहाँ a^2 + b^2 = c^2 होता है।\n    * यह फ़ंक्शन उन ट्रिपल्स (a, b, c) की सूची लौटाता है जो शर्तों को पूरा करते हैं।\n    *\n    * उदाहरण:\n    * >>> findPythagoreanTriplets(30)\n    * [(3, 4, 5), (5, 12, 13), (6, 8, 10)]\n    *\n    * व्याख्या: सीमा=30 के लिए, फ़ंक्शन पाइथागोरियन ट्रिपलेट्स खोजता है जहाँ a + b + c 30 से कम या बराबर है।\n    * (3, 4, 5) पहला ट्रिपलेट है जिसमें a^2 + b^2 = c^2 और a + b + c = 12 है, जो 30 से कम है।\n    * (5, 12, 13) और (6, 8, 10) अन्य मान्य ट्रिपलेट्स हैं।\n**/",
      "hu": "/**\n    * Adott egy határérték, találja meg az összes Pitagoraszi számhármast (a, b, c), ahol a < b < c és a + b + c <= határérték.\n    * Egy Pitagoraszi számhármas három pozitív egész szám, a, b és c, ahol a^2 + b^2 = c^2.\n    * A függvény visszaad egy listát azokról a hármasokról (a, b, c), amelyek megfelelnek a feltételeknek.\n    *\n    * Példa:\n    * >>> findPythagoreanTriplets(30)\n    * [(3, 4, 5), (5, 12, 13), (6, 8, 10)]\n    *\n    * Magyarázat: Ha a határérték 30, a függvény megtalálja azokat a Pitagoraszi számhármasokat, ahol a + b + c kisebb vagy egyenlő 30-nál.\n    * (3, 4, 5) az első hármas, ahol a^2 + b^2 = c^2 és a + b + c = 12, ami kisebb mint 30.\n    * (5, 12, 13) és (6, 8, 10) más érvényes hármasok.\n**/"
    },
    "prompt_bertscore": {
      "sq": "0.9714568142452865",
      "hy": "0.9446870005324526",
      "bn": "0.9544318070260243",
      "bg": "0.9714568142452865",
      "zh": "0.9668696442256669",
      "fr": "0.9714568142452865",
      "de": "0.9714568142452865",
      "ha": "0.9649814638235492",
      "hi": "0.9618665421881601",
      "hu": "0.9534418332069463"
    },
    "canonical_solution": "{\n    val triplets = mutableListOf<Triple<Int, Int, Int>>()\n    \n    for (a in 3 until limit) {\n        for (b in a until limit) {\n            val cSquare = a * a + b * b\n            val c = kotlin.math.sqrt(cSquare.toDouble()).toInt()\n            if (a + b + c <= limit && a * a + b * b == c*c) {\n                triplets.add(Triple(a, b, c))\n            }\n        }\n    }\n    \n    return triplets\n}",
    "instruction": {
      "en": "Write a Kotlin function `fun findPythagoreanTriplets(limit: Int): List<Triple<Int, Int, Int>>` to solve the following problem:\nGiven a limit, find all Pythagorean triplets (a, b, c) such that a < b < c and a + b + c <= limit.\nA Pythagorean triplet is a set of three positive integers a, b, and c, where a^2 + b^2 = c^2.\nThe function returns a list of triples (a, b, c) that satisfy the conditions.\n\nExample:\n>>> findPythagoreanTriplets(30)\n[(3, 4, 5), (5, 12, 13), (6, 8, 10)]\n\nExplanation: For limit=30, the function finds Pythagorean triplets where a + b + c is less than or equal to 30.\n(3, 4, 5) is the first triplet with a^2 + b^2 = c^2 and a + b + c = 12, which is less than 30.\n(5, 12, 13) and (6, 8, 10) are other valid triplets.",
      "sq": "Shkruani një funksion Kotlin `fun findPythagoreanTriplets(limit: Int): List<Triple<Int, Int, Int>>` për të zgjidhur problemin e mëposhtëm:\nDuke pasur një kufi, gjeni të gjitha treshet Pitagoriane (a, b, c) të tilla që a < b < c dhe a + b + c <= kufi.\nNjë treshe Pitagoriane është një grup prej tre numrash të plotë pozitivë a, b, dhe c, ku a^2 + b^2 = c^2.\nFunksioni kthen një listë treshe (a, b, c) që plotësojnë kushtet.\n\nShembull:\n>>> findPythagoreanTriplets(30)\n[(3, 4, 5), (5, 12, 13), (6, 8, 10)]\n\nShpjegim: Për kufirin=30, funksioni gjen treshet Pitagoriane ku a + b + c është më pak ose e barabartë me 30.\n(3, 4, 5) është tresha e parë me a^2 + b^2 = c^2 dhe a + b + c = 12, që është më pak se 30.\n(5, 12, 13) dhe (6, 8, 10) janë treshe të tjera të vlefshme.",
      "hy": "Գրեք Kotlin ֆունկցիա `fun findPythagoreanTriplets(limit: Int): List<Triple<Int, Int, Int>>` հետևյալ խնդիրը լուծելու համար:\nՏրված սահմանաչափով գտնել բոլոր Պյութագորասյան եռյակները (a, b, c), այնպես, որ a < b < c և a + b + c <= սահմանաչափ:\nՊյութագորասյան եռյակն այնպիսի երեք դրական ամբողջ թվերի հավաքածու է a, b և c, որտեղ a^2 + b^2 = c^2:\nՖունկցիան վերադարձնում է եռյակների (a, b, c) ցուցակ, որոնք բավարարում են պայմանները:\n\nՕրինակ:\n>>> findPythagoreanTriplets(30)\n[(3, 4, 5), (5, 12, 13), (6, 8, 10)]\n\nԲացատրություն: Սահմանաչափ=30-ի համար ֆունկցիան գտնում է Պյութագորասյան եռյակներ, որտեղ a + b + c փոքր կամ հավասար է 30:\n(3, 4, 5) առաջին եռյակն է, որտեղ a^2 + b^2 = c^2 և a + b + c = 12, որը փոքր է 30-ից:\n(5, 12, 13) և (6, 8, 10) այլ վավեր եռյակներ են:",
      "bn": "Kotlin ফাংশন `fun findPythagoreanTriplets(limit: Int): List<Triple<Int, Int, Int>>` লিখুন নিম্নলিখিত সমস্যার সমাধানের জন্য:\nএকটি সীমা দেওয়া হলে, সমস্ত পিথাগোরিয়ান ট্রিপলেট (a, b, c) খুঁজে বের করুন যেখানে a < b < c এবং a + b + c <= limit।\nএকটি পিথাগোরিয়ান ট্রিপলেট হল তিনটি ধনাত্মক পূর্ণসংখ্যার সেট a, b, এবং c, যেখানে a^2 + b^2 = c^2।\nফাংশনটি এমন ট্রিপল (a, b, c) এর একটি তালিকা প্রদান করে যা শর্তগুলি পূরণ করে।\n\nউদাহরণ:\n>>> findPythagoreanTriplets(30)\n[(3, 4, 5), (5, 12, 13), (6, 8, 10)]\n\nব্যাখ্যা: limit=30 এর জন্য, ফাংশনটি পিথাগোরিয়ান ট্রিপলেট খুঁজে পায় যেখানে a + b + c 30 এর সমান বা তার চেয়ে কম।\n(3, 4, 5) হল প্রথম ট্রিপলেট যেখানে a^2 + b^2 = c^2 এবং a + b + c = 12, যা 30 এর চেয়ে কম।\n(5, 12, 13) এবং (6, 8, 10) অন্যান্য বৈধ ট্রিপলেট।",
      "bg": "Напишете функция на Kotlin `fun findPythagoreanTriplets(limit: Int): List<Triple<Int, Int, Int>>`, за да решите следния проблем:\nДаден е лимит, намерете всички Питагорови тройки (a, b, c), такива че a < b < c и a + b + c <= лимит.\nПитагорова тройка е набор от три положителни цели числа a, b и c, където a^2 + b^2 = c^2.\nФункцията връща списък от тройки (a, b, c), които удовлетворяват условията.\n\nПример:\n>>> findPythagoreanTriplets(30)\n[(3, 4, 5), (5, 12, 13), (6, 8, 10)]\n\nОбяснение: За лимит=30, функцията намира Питагорови тройки, където a + b + c е по-малко или равно на 30.\n(3, 4, 5) е първата тройка с a^2 + b^2 = c^2 и a + b + c = 12, което е по-малко от 30.\n(5, 12, 13) и (6, 8, 10) са други валидни тройки.",
      "zh": "编写一个 Kotlin 函数 `fun findPythagoreanTriplets(limit: Int): List<Triple<Int, Int, Int>>` 来解决以下问题：\n给定一个限制，找到所有的勾股数三元组 (a, b, c)，使得 a < b < c 且 a + b + c <= limit。\n勾股数三元组是一组三个正整数 a, b 和 c，其中 a^2 + b^2 = c^2。\n该函数返回满足条件的三元组 (a, b, c) 的列表。\n\n示例：\n>>> findPythagoreanTriplets(30)\n[(3, 4, 5), (5, 12, 13), (6, 8, 10)]\n\n解释：对于 limit=30，函数找到 a + b + c 小于或等于 30 的勾股数三元组。\n(3, 4, 5) 是第一个三元组，满足 a^2 + b^2 = c^2 且 a + b + c = 12，小于 30。\n(5, 12, 13) 和 (6, 8, 10) 是其他有效的三元组。",
      "fr": "Écrire une fonction Kotlin `fun findPythagoreanTriplets(limit: Int): List<Triple<Int, Int, Int>>` pour résoudre le problème suivant :\nÉtant donné une limite, trouver tous les triplets pythagoriciens (a, b, c) tels que a < b < c et a + b + c <= limite.\nUn triplet pythagoricien est un ensemble de trois entiers positifs a, b, et c, où a^2 + b^2 = c^2.\nLa fonction renvoie une liste de triplets (a, b, c) qui satisfont les conditions.\n\nExemple :\n>>> findPythagoreanTriplets(30)\n[(3, 4, 5), (5, 12, 13), (6, 8, 10)]\n\nExplication : Pour limite=30, la fonction trouve des triplets pythagoriciens où a + b + c est inférieur ou égal à 30.\n(3, 4, 5) est le premier triplet avec a^2 + b^2 = c^2 et a + b + c = 12, ce qui est inférieur à 30.\n(5, 12, 13) et (6, 8, 10) sont d'autres triplets valides.",
      "de": "Schreiben Sie eine Kotlin-Funktion `fun findPythagoreanTriplets(limit: Int): List<Triple<Int, Int, Int>>`, um das folgende Problem zu lösen:\nGegeben ein Limit, finden Sie alle pythagoreischen Tripel (a, b, c) derart, dass a < b < c und a + b + c <= Limit.\nEin pythagoreisches Tripel ist eine Menge von drei positiven ganzen Zahlen a, b und c, wobei a^2 + b^2 = c^2.\nDie Funktion gibt eine Liste von Tripeln (a, b, c) zurück, die die Bedingungen erfüllen.\n\nBeispiel:\n>>> findPythagoreanTriplets(30)\n[(3, 4, 5), (5, 12, 13), (6, 8, 10)]\n\nErläuterung: Für Limit=30 findet die Funktion pythagoreische Tripel, bei denen a + b + c kleiner oder gleich 30 ist.\n(3, 4, 5) ist das erste Tripel mit a^2 + b^2 = c^2 und a + b + c = 12, was kleiner als 30 ist.\n(5, 12, 13) und (6, 8, 10) sind weitere gültige Tripel.",
      "ha": "Rubuta wani aikin Kotlin `fun findPythagoreanTriplets(limit: Int): List<Triple<Int, Int, Int>>` don magance matsalar mai zuwa:\nAn ba da iyaka, nemo duk triplets na Pythagorean (a, b, c) inda a < b < c kuma a + b + c <= iyaka.\nTriplet na Pythagorean yana nufin saitin lambobi guda uku masu kyau a, b, da c, inda a^2 + b^2 = c^2.\nAikin yana dawowa da jerin triples (a, b, c) waɗanda suka cika sharuɗɗan.\n\nMisali:\n>>> findPythagoreanTriplets(30)\n[(3, 4, 5), (5, 12, 13), (6, 8, 10)]\n\nBayani: Don iyaka=30, aikin yana nemo triplets na Pythagorean inda a + b + c ya zama ƙasa ko daidai da 30.\n(3, 4, 5) shine triplet na farko tare da a^2 + b^2 = c^2 kuma a + b + c = 12, wanda ya zama ƙasa da 30.\n(5, 12, 13) da (6, 8, 10) su ne sauran triplets masu inganci.",
      "hi": "Kotlin फ़ंक्शन `fun findPythagoreanTriplets(limit: Int): List<Triple<Int, Int, Int>>` लिखें ताकि निम्नलिखित समस्या का समाधान किया जा सके:\nदिए गए सीमा के लिए, सभी पाइथागोरियन ट्रिपलेट्स (a, b, c) खोजें, ताकि a < b < c और a + b + c <= सीमा हो।\nएक पाइथागोरियन ट्रिपलेट तीन धनात्मक पूर्णांकों का सेट होता है a, b, और c, जहाँ a^2 + b^2 = c^2 होता है।\nफ़ंक्शन उन ट्रिपल्स (a, b, c) की सूची लौटाता है जो शर्तों को पूरा करते हैं।\n\nउदाहरण:\n>>> findPythagoreanTriplets(30)\n[(3, 4, 5), (5, 12, 13), (6, 8, 10)]\n\nव्याख्या: सीमा=30 के लिए, फ़ंक्शन पाइथागोरियन ट्रिपलेट्स खोजता है जहाँ a + b + c 30 से कम या बराबर है।\n(3, 4, 5) पहला ट्रिपलेट है जिसमें a^2 + b^2 = c^2 और a + b + c = 12 है, जो 30 से कम है।\n(5, 12, 13) और (6, 8, 10) अन्य मान्य ट्रिपलेट्स हैं।",
      "hu": "Írj egy Kotlin függvényt `fun findPythagoreanTriplets(limit: Int): List<Triple<Int, Int, Int>>` a következő probléma megoldására:\nAdott egy határérték, találd meg az összes Pitagoraszi számhármast (a, b, c), ahol a < b < c és a + b + c <= határérték.\nEgy Pitagoraszi számhármas három pozitív egész szám, a, b és c, ahol a^2 + b^2 = c^2.\nA függvény visszaad egy listát a feltételeknek megfelelő hármasokról (a, b, c).\n\nPélda:\n>>> findPythagoreanTriplets(30)\n[(3, 4, 5), (5, 12, 13), (6, 8, 10)]\n\nMagyarázat: Ha a határérték 30, a függvény megtalálja azokat a Pitagoraszi számhármasokat, ahol a + b + c kisebb vagy egyenlő 30-nál.\n(3, 4, 5) az első hármas, ahol a^2 + b^2 = c^2 és a + b + c = 12, ami kisebb, mint 30.\n(5, 12, 13) és (6, 8, 10) más érvényes hármasok."
    },
    "instruction_bertscore": {
      "sq": "0.9979858879363063",
      "hy": "0.9737976732857827",
      "bn": "0.9788250082297757",
      "bg": "0.9937222868073924",
      "zh": "0.9934771769171953",
      "fr": "0.9979858879363063",
      "de": "0.9979858879363063",
      "ha": "0.9924685318423001",
      "hi": "0.9906445090532567",
      "hu": "0.9798417971502933"
    },
    "level": "middle",
    "test": "fun main() {\n    val result1 = findPythagoreanTriplets(20)\n    val expected1 = listOf(Triple(3, 4, 5))\n    check(result1 == expected1) // Should print true\n\n    \n    val result2 = findPythagoreanTriplets(30)\n    val expected2 = listOf(Triple(3, 4, 5), Triple(5, 12, 13), Triple(6, 8, 10))\n    check(result2 == expected2) // Should print true\n \n}\n\n\nmain()",
    "entry_point": "findPythagoreanTriplets",
    "signature": "fun findPythagoreanTriplets(limit: Int): List<Triple<Int, Int, Int>>",
    "docstring": {
      "en": "Given a limit, find all Pythagorean triplets (a, b, c) such that a < b < c and a + b + c <= limit.\nA Pythagorean triplet is a set of three positive integers a, b, and c, where a^2 + b^2 = c^2.\nThe function returns a list of triples (a, b, c) that satisfy the conditions.\n\nExample:\n>>> findPythagoreanTriplets(30)\n[(3, 4, 5), (5, 12, 13), (6, 8, 10)]\n\nExplanation: For limit=30, the function finds Pythagorean triplets where a + b + c is less than or equal to 30.\n(3, 4, 5) is the first triplet with a^2 + b^2 = c^2 and a + b + c = 12, which is less than 30.\n(5, 12, 13) and (6, 8, 10) are other valid triplets.",
      "sq": "Duke pasur një kufi, gjeni të gjitha tripletet Pitagoriane (a, b, c) të tilla që a < b < c dhe a + b + c <= kufi.\nNjë triplet Pitagorian është një grup prej tre numrash të plotë pozitivë a, b, dhe c, ku a^2 + b^2 = c^2.\nFunksioni kthen një listë treshe (a, b, c) që plotësojnë kushtet.\n\nShembull:\n>>> findPythagoreanTriplets(30)\n[(3, 4, 5), (5, 12, 13), (6, 8, 10)]\n\nShpjegim: Për kufi=30, funksioni gjen tripletet Pitagoriane ku a + b + c është më pak ose e barabartë me 30.\n(3, 4, 5) është tripleti i parë me a^2 + b^2 = c^2 dhe a + b + c = 12, që është më pak se 30.\n(5, 12, 13) dhe (6, 8, 10) janë triplete të tjera të vlefshme.",
      "hy": "Տրված սահմանաչափի դեպքում գտնել բոլոր Պյութագորասյան եռյակները (a, b, c) այնպես, որ a < b < c և a + b + c <= սահմանաչափ:\nՊյութագորասյան եռյակն այնպիսի երեք դրական ամբողջ թվերի հավաքածու է a, b և c, որտեղ a^2 + b^2 = c^2:\nՖունկցիան վերադարձնում է եռյակների ցուցակ (a, b, c), որոնք բավարարում են պայմանները:\n\nՕրինակ:\n>>> findPythagoreanTriplets(30)\n[(3, 4, 5), (5, 12, 13), (6, 8, 10)]\n\nԲացատրություն: Սահմանաչափ=30-ի դեպքում ֆունկցիան գտնում է Պյութագորասյան եռյակներ, որտեղ a + b + c փոքր կամ հավասար է 30:\n(3, 4, 5) առաջին եռյակն է, որտեղ a^2 + b^2 = c^2 և a + b + c = 12, որը փոքր է 30-ից:\n(5, 12, 13) և (6, 8, 10) այլ վավեր եռյակներ են:",
      "bn": "একটি সীমা দেওয়া হলে, সমস্ত পিথাগোরিয়ান ট্রিপলেট (a, b, c) খুঁজে বের করুন যেখানে a < b < c এবং a + b + c <= সীমা।\nএকটি পিথাগোরিয়ান ট্রিপলেট হল তিনটি ধনাত্মক পূর্ণসংখ্যা a, b, এবং c এর একটি সেট, যেখানে a^2 + b^2 = c^2।\nফাংশনটি এমন ট্রিপলগুলির একটি তালিকা প্রদান করে যা শর্তগুলি পূরণ করে।\n\nউদাহরণ:\n>>> findPythagoreanTriplets(30)\n[(3, 4, 5), (5, 12, 13), (6, 8, 10)]\n\nব্যাখ্যা: সীমা=30 এর জন্য, ফাংশনটি এমন পিথাগোরিয়ান ট্রিপলেট খুঁজে পায় যেখানে a + b + c 30 এর সমান বা তার চেয়ে কম।\n(3, 4, 5) হল প্রথম ট্রিপলেট যেখানে a^2 + b^2 = c^2 এবং a + b + c = 12, যা 30 এর চেয়ে কম।\n(5, 12, 13) এবং (6, 8, 10) অন্যান্য বৈধ ট্রিপলেট।",
      "bg": "Дадена е граница, намерете всички Питагорови тройки (a, b, c), такива че a < b < c и a + b + c <= границата.\nПитагорова тройка е набор от три положителни цели числа a, b и c, където a^2 + b^2 = c^2.\nФункцията връща списък от тройки (a, b, c), които удовлетворяват условията.\n\nПример:\n>>> findPythagoreanTriplets(30)\n[(3, 4, 5), (5, 12, 13), (6, 8, 10)]\n\nОбяснение: За граница=30, функцията намира Питагорови тройки, където a + b + c е по-малко или равно на 30.\n(3, 4, 5) е първата тройка с a^2 + b^2 = c^2 и a + b + c = 12, което е по-малко от 30.\n(5, 12, 13) и (6, 8, 10) са други валидни тройки.",
      "zh": "给定一个限制，找到所有满足 a < b < c 且 a + b + c <= 限制的勾股数三元组 (a, b, c)。\n勾股数三元组是一组三个正整数 a, b 和 c，其中 a^2 + b^2 = c^2。\n该函数返回满足条件的三元组 (a, b, c) 的列表。\n\n示例:\n>>> findPythagoreanTriplets(30)\n[(3, 4, 5), (5, 12, 13), (6, 8, 10)]\n\n解释: 对于 limit=30，该函数找到 a + b + c 小于或等于 30 的勾股数三元组。\n(3, 4, 5) 是第一个三元组，满足 a^2 + b^2 = c^2 且 a + b + c = 12，小于 30。\n(5, 12, 13) 和 (6, 8, 10) 是其他有效的三元组。",
      "fr": "Étant donné une limite, trouvez tous les triplets pythagoriciens (a, b, c) tels que a < b < c et a + b + c <= limite.  \nUn triplet pythagoricien est un ensemble de trois entiers positifs a, b et c, où a^2 + b^2 = c^2.  \nLa fonction renvoie une liste de triplets (a, b, c) qui satisfont les conditions.\n\nExemple:\n>>> findPythagoreanTriplets(30)\n[(3, 4, 5), (5, 12, 13), (6, 8, 10)]\n\nExplication : Pour limite=30, la fonction trouve des triplets pythagoriciens où a + b + c est inférieur ou égal à 30.  \n(3, 4, 5) est le premier triplet avec a^2 + b^2 = c^2 et a + b + c = 12, ce qui est inférieur à 30.  \n(5, 12, 13) et (6, 8, 10) sont d'autres triplets valides.",
      "de": "Gegeben ein Limit, finden Sie alle pythagoreischen Tripel (a, b, c) derart, dass a < b < c und a + b + c <= Limit.\nEin pythagoreisches Tripel ist eine Menge von drei positiven ganzen Zahlen a, b und c, wobei a^2 + b^2 = c^2.  \nDie Funktion gibt eine Liste von Tripeln (a, b, c) zurück, die die Bedingungen erfüllen.\n\nBeispiel:  \n>>> findPythagoreanTriplets(30)  \n[(3, 4, 5), (5, 12, 13), (6, 8, 10)]\n\nErklärung: Für limit=30 findet die Funktion pythagoreische Tripel, bei denen a + b + c kleiner oder gleich 30 ist.  \n(3, 4, 5) ist das erste Tripel mit a^2 + b^2 = c^2 und a + b + c = 12, was kleiner als 30 ist.  \n(5, 12, 13) und (6, 8, 10) sind weitere gültige Tripel.",
      "ha": "An ba da iyaka, nemo dukkan triplets na Pythagorean (a, b, c) inda a < b < c kuma a + b + c <= iyaka. Triplet na Pythagorean saiti ne na lambobi masu kyau guda uku a, b, da c, inda a^2 + b^2 = c^2. Aikin yana mayar da jerin triples (a, b, c) waɗanda suka cika sharuɗɗan.\n\nMisali:\n>>> findPythagoreanTriplets(30)\n[(3, 4, 5), (5, 12, 13), (6, 8, 10)]\n\nBayani: Don iyaka=30, aikin yana nemo triplets na Pythagorean inda a + b + c ya kasance ƙasa da ko daidai da 30. (3, 4, 5) shine triplet na farko tare da a^2 + b^2 = c^2 kuma a + b + c = 12, wanda ya fi ƙasa da 30. (5, 12, 13) da (6, 8, 10) wasu triplets masu inganci ne.",
      "hi": "दिए गए सीमा के लिए, सभी पाइथागोरियन ट्रिपलेट्स (a, b, c) खोजें ताकि a < b < c और a + b + c <= सीमा हो। एक पाइथागोरियन ट्रिपलेट तीन धनात्मक पूर्णांकों a, b, और c का सेट होता है, जहाँ a^2 + b^2 = c^2 होता है। यह फ़ंक्शन उन ट्रिपल्स (a, b, c) की सूची लौटाता है जो शर्तों को पूरा करते हैं।\n\nउदाहरण:\n>>> findPythagoreanTriplets(30)\n[(3, 4, 5), (5, 12, 13), (6, 8, 10)]\n\nव्याख्या: सीमा=30 के लिए, फ़ंक्शन पाइथागोरियन ट्रिपलेट्स खोजता है जहाँ a + b + c 30 से कम या बराबर है।\n(3, 4, 5) पहला ट्रिपलेट है जिसमें a^2 + b^2 = c^2 और a + b + c = 12 है, जो 30 से कम है।\n(5, 12, 13) और (6, 8, 10) अन्य मान्य ट्रिपलेट्स हैं।",
      "hu": "Adott egy határ, találja meg az összes Pitagoraszi hármasokat (a, b, c), ahol a < b < c és a + b + c <= határ.\nEgy Pitagoraszi hármas három pozitív egész szám a, b és c, ahol a^2 + b^2 = c^2.\nA függvény visszaad egy listát a hármasokról (a, b, c), amelyek megfelelnek a feltételeknek.\n\nPélda:\n>>> findPythagoreanTriplets(30)\n[(3, 4, 5), (5, 12, 13), (6, 8, 10)]\n\nMagyarázat: Ha a határ=30, a függvény olyan Pitagoraszi hármasokat talál, ahol a + b + c kisebb vagy egyenlő, mint 30.\n(3, 4, 5) az első hármas, ahol a^2 + b^2 = c^2 és a + b + c = 12, ami kisebb, mint 30.\n(5, 12, 13) és (6, 8, 10) más érvényes hármasok."
    },
    "docstring_bertscore": {
      "sq": "0.9973063734027858",
      "hy": "0.9759663197859216",
      "bn": "0.9710172452120563",
      "bg": "0.9977874561856523",
      "zh": "0.9890262673389655",
      "fr": "0.9977874561856523",
      "de": "0.9977874561856523",
      "ha": "0.9957417618913741",
      "hi": "0.9865930451712881",
      "hu": "0.9794326185653615"
    }
  },
  {
    "task_id": "Kotlin/6",
    "prompt": {
      "en": "/**\n * Write a Kotlin function that takes a string as input (length not exceeding 80 characters)\n * and counts the number of words in it. Words in the input string are separated by spaces.\n *\n * Example:\n * >>> countWords(\"This is a book\")\n * 4\n * >>> countWords(\"   Hello   World!   \")\n * 2\n * >>> countWords(\"A  string  with  multiple  spaces\")\n * 5\n */\n\nfun countWords(inputString: String): Int",
      "sq": "/**\n * Shkruani një funksion në Kotlin që merr një varg si hyrje (gjatësia nuk tejkalon 80 karaktere)\n * dhe numëron numrin e fjalëve në të. Fjalët në vargun e hyrjes ndahen nga hapësirat.\n *\n * Shembull:\n * >>> countWords(\"This is a book\")\n * 4\n * >>> countWords(\"   Hello   World!   \")\n * 2\n * >>> countWords(\"A  string  with  multiple  spaces\")\n * 5\n */",
      "hy": "/**\n * Գրեք Kotlin ֆունկցիա, որը ընդունում է տող որպես մուտք (երկարությունը չգերազանցելով 80 նիշ)\n * և հաշվում է դրա մեջ բառերի քանակը։ Մուտքագրված տողի բառերը բաժանված են բացատներով։\n *\n * Օրինակ:\n * >>> countWords(\"This is a book\")\n * 4\n * >>> countWords(\"   Hello   World!   \")\n * 2\n * >>> countWords(\"A  string  with  multiple  spaces\")\n * 5\n */",
      "bn": "/**\n * একটি Kotlin ফাংশন লিখুন যা একটি স্ট্রিং ইনপুট হিসেবে গ্রহণ করে (দৈর্ঘ্য ৮০ অক্ষরের বেশি নয়)\n * এবং এতে থাকা শব্দের সংখ্যা গণনা করে। ইনপুট স্ট্রিংয়ে শব্দগুলি ফাঁকা স্থান দ্বারা পৃথক করা হয়।\n *\n * উদাহরণ:\n * >>> countWords(\"This is a book\")\n * 4\n * >>> countWords(\"   Hello   World!   \")\n * 2\n * >>> countWords(\"A  string  with  multiple  spaces\")\n * 5\n */ \n\nfun countWords(inputString: String): Int",
      "bg": "/**\n * Напишете функция на Kotlin, която приема низ като вход (дължина, която не надвишава 80 знака)\n * и преброява броя на думите в него. Думите в входния низ са разделени с интервали.\n *\n * Пример:\n * >>> countWords(\"This is a book\")\n * 4\n * >>> countWords(\"   Hello   World!   \")\n * 2\n * >>> countWords(\"A  string  with  multiple  spaces\")\n * 5\n */ \n\nfun countWords(inputString: String): Int",
      "zh": "/**\n * 编写一个Kotlin函数，该函数接受一个字符串作为输入（长度不超过80个字符），\n * 并计算其中的单词数量。输入字符串中的单词由空格分隔。\n *\n * 示例:\n * >>> countWords(\"This is a book\")\n * 4\n * >>> countWords(\"   Hello   World!   \")\n * 2\n * >>> countWords(\"A  string  with  multiple  spaces\")\n * 5\n */",
      "fr": "/**\n * Écrire une fonction Kotlin qui prend une chaîne de caractères en entrée (longueur ne dépassant pas 80 caractères)\n * et compte le nombre de mots qu'elle contient. Les mots dans la chaîne d'entrée sont séparés par des espaces.\n *\n * Exemple:\n * >>> countWords(\"This is a book\")\n * 4\n * >>> countWords(\"   Hello   World!   \")\n * 2\n * >>> countWords(\"A  string  with  multiple  spaces\")\n * 5\n */ \n\nfun countWords(inputString: String): Int",
      "de": "/**\n * Schreiben Sie eine Kotlin-Funktion, die einen String als Eingabe nimmt (Länge nicht mehr als 80 Zeichen)\n * und die Anzahl der Wörter darin zählt. Wörter im Eingabestring sind durch Leerzeichen getrennt.\n *\n * Beispiel:\n * >>> countWords(\"This is a book\")\n * 4\n * >>> countWords(\"   Hello   World!   \")\n * 2\n * >>> countWords(\"A  string  with  multiple  spaces\")\n * 5\n */",
      "ha": "/**\n * Rubuta aikin Kotlin wanda ke ɗaukar kirtani a matsayin shigarwa (tsawon ba zai wuce haruffa 80 ba)\n * kuma yana ƙididdige yawan kalmomi a ciki. Ana raba kalmomi a cikin kirtanin shigarwa ta wurin sarari.\n *\n * Misali:\n * >>> countWords(\"This is a book\")\n * 4\n * >>> countWords(\"   Hello   World!   \")\n * 2\n * >>> countWords(\"A  string  with  multiple  spaces\")\n * 5\n */",
      "hi": "/**\n * एक Kotlin फ़ंक्शन लिखें जो एक स्ट्रिंग को इनपुट के रूप में लेता है (लंबाई 80 वर्णों से अधिक नहीं)\n * और इसमें शब्दों की संख्या गिनता है। इनपुट स्ट्रिंग में शब्द स्पेस द्वारा अलग किए गए हैं।\n *\n * उदाहरण:\n * >>> countWords(\"This is a book\")\n * 4\n * >>> countWords(\"   Hello   World!   \")\n * 2\n * >>> countWords(\"A  string  with  multiple  spaces\")\n * 5\n */\n\nfun countWords(inputString: String): Int",
      "hu": "/**\n * Írj egy Kotlin függvényt, amely egy karakterláncot vesz bemenetként (hossza nem haladja meg a 80 karaktert),\n * és megszámolja benne a szavak számát. A bemeneti karakterláncban a szavakat szóközök választják el.\n *\n * Példa:\n * >>> countWords(\"This is a book\")\n * 4\n * >>> countWords(\"   Hello   World!   \")\n * 2\n * >>> countWords(\"A  string  with  multiple  spaces\")\n * 5\n */ \n\nfun countWords(inputString: String): Int"
    },
    "prompt_bertscore": {
      "sq": "0.9552662532567519",
      "hy": "0.9618351585879565",
      "bn": "0.9815849773742555",
      "bg": "0.9881600402472723",
      "zh": "0.9610845343780258",
      "fr": "0.9883441706104917",
      "de": "0.9591927786290495",
      "ha": "0.9577880645743707",
      "hi": "0.9955772959358772",
      "hu": "0.9809797506032422"
    },
    "canonical_solution": "{\n    // Trim the input string to remove leading and trailing spaces\n    val trimmedString = inputString.trim()\n    \n    // Split the trimmed string using spaces as the delimiter and filter out empty strings\n    val words = trimmedString.split(\" \").filter { it.isNotEmpty() }\n    \n    // Use a set to store unique words\n    val uniqueWords = mutableSetOf<String>()\n    \n    // Add non-duplicate words to the set\n    for (word in words) {\n        uniqueWords.add(word)\n    }\n    \n    // Return the count of unique words\n    return uniqueWords.size\n}",
    "instruction": {
      "en": "Write a Kotlin function `fun countWords(inputString: String): Int` to solve the following problem:\nWrite a Kotlin function that takes a string as input (length not exceeding 80 characters)\nand counts the number of words in it. Words in the input string are separated by spaces.\n\nExample:\n>>> countWords(\"This is a book\")\n4\n>>> countWords(\"   Hello   World!   \")\n2\n>>> countWords(\"A  string  with  multiple  spaces\")\n5",
      "sq": "Shkruani një funksion Kotlin `fun countWords(inputString: String): Int` për të zgjidhur problemin e mëposhtëm:  \nShkruani një funksion Kotlin që merr një varg si input (gjatësia nuk tejkalon 80 karaktere)  \ndhe numëron numrin e fjalëve në të. Fjalët në vargun e inputit ndahen me hapësira.  \n\nShembull:  \n>>> countWords(\"This is a book\")  \n4  \n>>> countWords(\"   Hello   World!   \")  \n2  \n>>> countWords(\"A  string  with  multiple  spaces\")  \n5",
      "hy": "Գրեք Kotlin ֆունկցիա `fun countWords(inputString: String): Int` հետևյալ խնդիրը լուծելու համար:\nԳրեք Kotlin ֆունկցիա, որը ստանում է տող որպես մուտք (երկարությունը չգերազանցող 80 նիշ)\nև հաշվում է դրա մեջ բառերի քանակը։ Մուտքային տողի բառերը բաժանված են բացատներով։\n\nՕրինակ:\n>>> countWords(\"This is a book\")\n4\n>>> countWords(\"   Hello   World!   \")\n2\n>>> countWords(\"A  string  with  multiple  spaces\")\n5",
      "bn": "Kotlin ফাংশন `fun countWords(inputString: String): Int` লিখুন নিম্নলিখিত সমস্যার সমাধানের জন্য:\nএকটি Kotlin ফাংশন লিখুন যা একটি স্ট্রিং ইনপুট হিসেবে গ্রহণ করে (দৈর্ঘ্য ৮০ অক্ষরের বেশি নয়)\nএবং এতে থাকা শব্দের সংখ্যা গণনা করে। ইনপুট স্ট্রিংয়ে শব্দগুলি স্পেস দ্বারা পৃথক করা হয়।\n\nউদাহরণ:\n>>> countWords(\"This is a book\")\n4\n>>> countWords(\"   Hello   World!   \")\n2\n>>> countWords(\"A  string  with  multiple  spaces\")\n5",
      "bg": "Напишете функция на Kotlin `fun countWords(inputString: String): Int`, за да решите следния проблем:\nНапишете функция на Kotlin, която приема низ като вход (дължина, която не надвишава 80 знака) и брои броя на думите в него. Думите във входния низ са разделени с интервали.\n\nПример:\n>>> countWords(\"This is a book\")\n4\n>>> countWords(\"   Hello   World!   \")\n2\n>>> countWords(\"A  string  with  multiple  spaces\")\n5",
      "zh": "编写一个 Kotlin 函数 `fun countWords(inputString: String): Int` 来解决以下问题：\n编写一个 Kotlin 函数，该函数接受一个字符串作为输入（长度不超过 80 个字符），并计算其中的单词数量。输入字符串中的单词由空格分隔。\n\n示例：\n>>> countWords(\"This is a book\")\n4\n>>> countWords(\"   Hello   World!   \")\n2\n>>> countWords(\"A  string  with  multiple  spaces\")\n5",
      "fr": "Écrire une fonction Kotlin `fun countWords(inputString: String): Int` pour résoudre le problème suivant :  \nÉcrire une fonction Kotlin qui prend une chaîne de caractères en entrée (longueur ne dépassant pas 80 caractères)  \net compte le nombre de mots qu'elle contient. Les mots dans la chaîne d'entrée sont séparés par des espaces.\n\nExemple :  \n>>> countWords(\"This is a book\")  \n4  \n>>> countWords(\"   Hello   World!   \")  \n2  \n>>> countWords(\"A  string  with  multiple  spaces\")  \n5",
      "de": "Schreiben Sie eine Kotlin-Funktion `fun countWords(inputString: String): Int`, um das folgende Problem zu lösen:\nSchreiben Sie eine Kotlin-Funktion, die einen String als Eingabe nimmt (Länge nicht mehr als 80 Zeichen) und die Anzahl der Wörter darin zählt. Wörter im Eingabestring sind durch Leerzeichen getrennt.\n\nBeispiel:\n>>> countWords(\"This is a book\")\n4\n>>> countWords(\"   Hello   World!   \")\n2\n>>> countWords(\"A  string  with  multiple  spaces\")\n5",
      "ha": "Rubuta wani aikin Kotlin `fun countWords(inputString: String): Int` don magance matsalar mai zuwa:\nRubuta wani aikin Kotlin wanda ke ɗaukar kirtani a matsayin shigarwa (tsawon ba zai wuce haruffa 80 ba)\nkuma yana ƙidaya adadin kalmomi a ciki. Kalmoni a cikin kirtanin shigarwa suna rabuwa da sarari.\n\nMisali:\n>>> countWords(\"This is a book\")\n4\n>>> countWords(\"   Hello   World!   \")\n2\n>>> countWords(\"A  string  with  multiple  spaces\")\n5",
      "hi": "Kotlin फ़ंक्शन `fun countWords(inputString: String): Int` लिखें ताकि निम्नलिखित समस्या का समाधान किया जा सके:\nएक Kotlin फ़ंक्शन लिखें जो एक स्ट्रिंग को इनपुट के रूप में लेता है (लंबाई 80 वर्णों से अधिक नहीं होनी चाहिए)\nऔर इसमें शब्दों की संख्या गिनता है। इनपुट स्ट्रिंग में शब्द स्पेस द्वारा अलग किए गए हैं।\n\nउदाहरण:\n>>> countWords(\"This is a book\")\n4\n>>> countWords(\"   Hello   World!   \")\n2\n>>> countWords(\"A  string  with  multiple  spaces\")\n5",
      "hu": "Írj egy Kotlin függvényt `fun countWords(inputString: String): Int` a következő probléma megoldására:\nÍrj egy Kotlin függvényt, amely egy karakterláncot vesz bemenetként (hossza nem haladja meg a 80 karaktert),\nés megszámolja benne a szavak számát. A bemeneti karakterláncban a szavakat szóközök választják el."
    },
    "instruction_bertscore": {
      "sq": "0.9968258865110625",
      "hy": "0.9889674727461792",
      "bn": "0.9776240889460388",
      "bg": "0.9861157363656613",
      "zh": "0.9794614199706115",
      "fr": "0.9912799276421874",
      "de": "0.9955657753737771",
      "ha": "0.9902269879923215",
      "hi": "0.9825632320008524",
      "hu": "0.8664935688431155"
    },
    "level": "hard",
    "test": "fun main() {\n    // Test cases\n    check(countWords(\"This is a book\") == 4)\n    check(countWords(\"   Hello   World!  World World \") == 3)\n    check(countWords(\"A  string  with  multiple  spaces\") == 5)\n    check(countWords(\"\") == 0) // Edge case: Empty string should have 0 words\n    check(countWords(\"SingleWord\") == 1) // Edge case: String with a single word\n    check(countWords(\"a a a a a a a a a a a a\") == 1) \n    check(countWords(\"a a a ab ab c c c c c c b a c\") == 4) \n}\n\n\nmain()",
    "entry_point": "countWords",
    "signature": "fun countWords(inputString: String): Int",
    "docstring": {
      "en": "Write a Kotlin function that takes a string as input (length not exceeding 80 characters)\nand counts the number of words in it. Words in the input string are separated by spaces.\n\nExample:\n>>> countWords(\"This is a book\")\n4\n>>> countWords(\"   Hello   World!   \")\n2\n>>> countWords(\"A  string  with  multiple  spaces\")\n5",
      "sq": "Shkruani një funksion Kotlin që merr një varg si hyrje (gjatësia nuk tejkalon 80 karaktere) dhe numëron numrin e fjalëve në të. Fjalët në vargun e hyrjes ndahen nga hapësirat.\n\nShembull:\n>>> countWords(\"This is a book\")\n4\n>>> countWords(\"   Hello   World!   \")\n2\n>>> countWords(\"A  string  with  multiple  spaces\")\n5",
      "hy": "Գրեք Kotlin ֆունկցիա, որը ընդունում է տող որպես մուտք (երկարությունը չպետք է գերազանցի 80 նիշը) և հաշվում է դրա մեջ բառերի քանակը։ Մուտքային տողի բառերը բաժանվում են բացատներով։\n\nՕրինակ:\n>>> countWords(\"This is a book\")\n4\n>>> countWords(\"   Hello   World!   \")\n2\n>>> countWords(\"A  string  with  multiple  spaces\")\n5",
      "bn": "একটি Kotlin ফাংশন লিখুন যা একটি স্ট্রিং ইনপুট হিসাবে গ্রহণ করে (দৈর্ঘ্য ৮০ অক্ষরের বেশি নয়) এবং এতে থাকা শব্দগুলির সংখ্যা গণনা করে। ইনপুট স্ট্রিংয়ে শব্দগুলি স্পেস দ্বারা পৃথক করা হয়।\n\nউদাহরণ:\n>>> countWords(\"This is a book\")\n4\n>>> countWords(\"   Hello   World!   \")\n2\n>>> countWords(\"A  string  with  multiple  spaces\")\n5",
      "bg": "Напишете функция на Kotlin, която приема низ като вход (дължина, която не надвишава 80 знака) и брои броя на думите в него. Думите в входния низ са разделени с интервали.\n\nПример:\n>>> countWords(\"This is a book\")\n4\n>>> countWords(\"   Hello   World!   \")\n2\n>>> countWords(\"A  string  with  multiple  spaces\")\n5",
      "zh": "编写一个 Kotlin 函数，该函数接受一个字符串作为输入（长度不超过 80 个字符），并计算其中的单词数量。输入字符串中的单词由空格分隔。\n\n示例：\n>>> countWords(\"This is a book\")\n4\n>>> countWords(\"   Hello   World!   \")\n2\n>>> countWords(\"A  string  with  multiple  spaces\")\n5",
      "fr": "Écrire une fonction Kotlin qui prend une chaîne de caractères en entrée (longueur ne dépassant pas 80 caractères) et compte le nombre de mots qu'elle contient. Les mots dans la chaîne d'entrée sont séparés par des espaces.\n\nExemple :\n>>> countWords(\"This is a book\")\n4\n>>> countWords(\"   Hello   World!   \")\n2\n>>> countWords(\"A  string  with  multiple  spaces\")\n5",
      "de": "Schreiben Sie eine Kotlin-Funktion, die einen String als Eingabe nimmt (Länge nicht mehr als 80 Zeichen) und die Anzahl der Wörter darin zählt. Wörter im Eingabestring sind durch Leerzeichen getrennt.\n\nBeispiel:\n>>> countWords(\"This is a book\")\n4\n>>> countWords(\"   Hello   World!   \")\n2\n>>> countWords(\"A  string  with  multiple  spaces\")\n5",
      "ha": "Rubuta wani aikin Kotlin wanda ke ɗaukar kirtani a matsayin shigarwa (tsawon ba zai wuce haruffa 80 ba) kuma yana ƙidaya adadin kalmomi a ciki. Kalmomi a cikin kirtani na shigarwa suna rabuwa da sarari.\n\nMisali:\n>>> countWords(\"This is a book\")\n4\n>>> countWords(\"   Hello   World!   \")\n2\n>>> countWords(\"A  string  with  multiple  spaces\")\n5",
      "hi": "Kotlin फ़ंक्शन लिखें जो एक स्ट्रिंग को इनपुट के रूप में लेता है (लंबाई 80 वर्णों से अधिक नहीं) और इसमें शब्दों की संख्या गिनता है। इनपुट स्ट्रिंग में शब्द स्पेस द्वारा अलग किए गए हैं।\n\nउदाहरण:\n>>> countWords(\"This is a book\")\n4\n>>> countWords(\"   Hello   World!   \")\n2\n>>> countWords(\"A  string  with  multiple  spaces\")\n5",
      "hu": "Írj egy Kotlin függvényt, amely egy karakterláncot vesz be bemenetként (hossza nem haladja meg a 80 karaktert), és megszámolja benne a szavak számát. A bemeneti karakterláncban a szavakat szóközök választják el.\n\nPélda:\n>>> countWords(\"This is a book\")\n4\n>>> countWords(\"   Hello   World!   \")\n2\n>>> countWords(\"A  string  with  multiple  spaces\")\n5"
    },
    "docstring_bertscore": {
      "sq": "0.9845985975153169",
      "hy": "0.9789666316914536",
      "bn": "0.9792266388602283",
      "bg": "0.994158081863383",
      "zh": "0.9756592372168417",
      "fr": "0.9869829566092596",
      "de": "0.993794191005327",
      "ha": "1",
      "hi": "0.9712226290260464",
      "hu": "0.982623417006306"
    }
  },
  {
    "task_id": "Kotlin/7",
    "prompt": {
      "en": "/**\n  * Generates a Pascal's Triangle up to the specified number of rows.\n  * In Pascal's Triangle, each number is the sum of the two numbers directly above it.\n  * The function returns a list of lists, where each inner list represents a row in the triangle.\n  *\n  * Example:\n  * >>> generatePascalsTriangle(3)\n  *     [[1], [1, 1], [1, 2, 1]]\n  * >>> generatePascalsTriangle(5)\n  *     [[1], [1, 1], [1, 2, 1], [1, 3, 3, 1], [1, 4, 6, 4, 1]]\n  **/\n\n\nfun generatePascalsTriangle(rows: Int): List<List<Int>> ",
      "sq": "/**\n  * Gjeneron një Trekëndësh të Pascal-it deri në numrin e specifikuar të rreshtave.\n  * Në Trekëndëshin e Pascal-it, çdo numër është shuma e dy numrave direkt mbi të.\n  * Funksioni kthen një listë listash, ku çdo listë e brendshme përfaqëson një rresht në trekëndësh.\n  *\n  * Shembull:\n  * >>> generatePascalsTriangle(3)\n  *     [[1], [1, 1], [1, 2, 1]]\n  * >>> generatePascalsTriangle(5)\n  *     [[1], [1, 1], [1, 2, 1], [1, 3, 3, 1], [1, 4, 6, 4, 1]]\n  **/",
      "hy": "/**\n  * Գեներացնում է Պասկալի եռանկյունի մինչև նշված տողերի քանակը:\n  * Պասկալի եռանկյունում յուրաքանչյուր թիվ հավասար է իր վերևում գտնվող երկու թվերի գումարին:\n  * Ֆունկցիան վերադարձնում է ցուցակ ցուցակների, որտեղ յուրաքանչյուր ներքին ցուցակ ներկայացնում է եռանկյունու տող:\n  *\n  * Օրինակ:\n  * >>> generatePascalsTriangle(3)\n  *     [[1], [1, 1], [1, 2, 1]]\n  * >>> generatePascalsTriangle(5)\n  *     [[1], [1, 1], [1, 2, 1], [1, 3, 3, 1], [1, 4, 6, 4, 1]]\n  **/",
      "bn": "/**\n  * নির্দিষ্ট সংখ্যক সারি পর্যন্ত প্যাসকেলের ত্রিভুজ তৈরি করে।\n  * প্যাসকেলের ত্রিভুজে, প্রতিটি সংখ্যা তার ঠিক উপরে থাকা দুটি সংখ্যার যোগফল।\n  * ফাংশনটি তালিকার একটি তালিকা প্রদান করে, যেখানে প্রতিটি অভ্যন্তরীণ তালিকা ত্রিভুজের একটি সারিকে উপস্থাপন করে।\n  *\n  * উদাহরণ:\n  * >>> generatePascalsTriangle(3)\n  *     [[1], [1, 1], [1, 2, 1]]\n  * >>> generatePascalsTriangle(5)\n  *     [[1], [1, 1], [1, 2, 1], [1, 3, 3, 1], [1, 4, 6, 4, 1]]\n  **/",
      "bg": "/**\n  * Генерира триъгълника на Паскал до посочения брой редове.\n  * В триъгълника на Паскал всяко число е сумата от двете числа директно над него.\n  * Функцията връща списък от списъци, където всеки вътрешен списък представлява ред в триъгълника.\n  *\n  * Пример:\n  * >>> generatePascalsTriangle(3)\n  *     [[1], [1, 1], [1, 2, 1]]\n  * >>> generatePascalsTriangle(5)\n  *     [[1], [1, 1], [1, 2, 1], [1, 3, 3, 1], [1, 4, 6, 4, 1]]\n  **/",
      "zh": "/**\n  * 生成一个指定行数的帕斯卡三角形。\n  * 在帕斯卡三角形中，每个数字是其正上方的两个数字之和。\n  * 该函数返回一个列表的列表，其中每个内部列表代表三角形中的一行。\n  *\n  * 示例:\n  * >>> generatePascalsTriangle(3)\n  *     [[1], [1, 1], [1, 2, 1]]\n  * >>> generatePascalsTriangle(5)\n  *     [[1], [1, 1], [1, 2, 1], [1, 3, 3, 1], [1, 4, 6, 4, 1]]\n  **/",
      "fr": "/**\n  * Génère un triangle de Pascal jusqu'au nombre spécifié de lignes.\n  * Dans le triangle de Pascal, chaque nombre est la somme des deux nombres directement au-dessus de lui.\n  * La fonction renvoie une liste de listes, où chaque liste interne représente une ligne du triangle.\n  *\n  * Exemple:\n  * >>> generatePascalsTriangle(3)\n  *     [[1], [1, 1], [1, 2, 1]]\n  * >>> generatePascalsTriangle(5)\n  *     [[1], [1, 1], [1, 2, 1], [1, 3, 3, 1], [1, 4, 6, 4, 1]]\n  **/",
      "de": "/**\n  * Generiert ein Pascalsches Dreieck bis zur angegebenen Anzahl von Zeilen.\n  * Im Pascalschen Dreieck ist jede Zahl die Summe der beiden Zahlen direkt über ihr.\n  * Die Funktion gibt eine Liste von Listen zurück, wobei jede innere Liste eine Zeile im Dreieck darstellt.\n  *\n  * Beispiel:\n  * >>> generatePascalsTriangle(3)\n  *     [[1], [1, 1], [1, 2, 1]]\n  * >>> generatePascalsTriangle(5)\n  *     [[1], [1, 1], [1, 2, 1], [1, 3, 3, 1], [1, 4, 6, 4, 1]]\n  **/",
      "ha": "/**\n  * Yana haifar da Triangle na Pascal har zuwa adadin layukan da aka ayyana.\n  * A cikin Triangle na Pascal, kowanne lamba yana zama jumlar lambobin biyu da suke kai tsaye a samansa.\n  * Aikin yana dawo da jerin jerin, inda kowanne jerin ciki yake wakiltar layi a cikin triangle.\n  *\n  * Misali:\n  * >>> generatePascalsTriangle(3)\n  *     [[1], [1, 1], [1, 2, 1]]\n  * >>> generatePascalsTriangle(5)\n  *     [[1], [1, 1], [1, 2, 1], [1, 3, 3, 1], [1, 4, 6, 4, 1]]\n  **/",
      "hi": "/**\n  * निर्दिष्ट पंक्तियों की संख्या तक पास्कल त्रिकोण उत्पन्न करता है।\n  * पास्कल त्रिकोण में, प्रत्येक संख्या उसके ठीक ऊपर की दो संख्याओं का योग होती है।\n  * यह फ़ंक्शन सूचियों की एक सूची लौटाता है, जहाँ प्रत्येक आंतरिक सूची त्रिकोण में एक पंक्ति का प्रतिनिधित्व करती है।\n  *\n  * उदाहरण:\n  * >>> generatePascalsTriangle(3)\n  *     [[1], [1, 1], [1, 2, 1]]\n  * >>> generatePascalsTriangle(5)\n  *     [[1], [1, 1], [1, 2, 1], [1, 3, 3, 1], [1, 4, 6, 4, 1]]\n  **/",
      "hu": "/**\n  * Generál egy Pascal háromszöget a megadott sorok számáig.\n  * A Pascal háromszögben minden szám az őt közvetlenül megelőző két szám összege.\n  * A függvény egy listák listáját ad vissza, ahol minden belső lista a háromszög egy sorát képviseli.\n  *\n  * Példa:\n  * >>> generatePascalsTriangle(3)\n  *     [[1], [1, 1], [1, 2, 1]]\n  * >>> generatePascalsTriangle(5)\n  *     [[1], [1, 1], [1, 2, 1], [1, 3, 3, 1], [1, 4, 6, 4, 1]]\n  **/"
    },
    "prompt_bertscore": {
      "sq": "0.9652299504302239",
      "hy": "0.9525632910316291",
      "bn": "0.9545517797761693",
      "bg": "0.9586544902964449",
      "zh": "0.9504949528739127",
      "fr": "0.9604699719791038",
      "de": "0.9624902415846096",
      "ha": "0.9613169319238366",
      "hi": "0.9573073790522663",
      "hu": "0.9604699719791038"
    },
    "canonical_solution": "{\n    val triangle = mutableListOf<List<Int>>()\n    for (row in 0 until rows) {\n        val currentRow = mutableListOf<Int>()\n        for (col in 0..row) {\n            if (col == 0 || col == row) {\n                currentRow.add(1)\n            } else {\n                val aboveLeft = triangle[row - 1][col - 1]\n                val aboveRight = triangle[row - 1][col]\n                currentRow.add(aboveLeft + aboveRight)\n            }\n        }\n        triangle.add(currentRow)\n    }\n    return triangle\n}",
    "instruction": {
      "en": "Write a Kotlin function `fun generatePascalsTriangle(rows: Int): List<List<Int>>` to solve the following problem:\nGenerates a Pascal's Triangle up to the specified number of rows.\nIn Pascal's Triangle, each number is the sum of the two numbers directly above it.\nThe function returns a list of lists, where each inner list represents a row in the triangle.\n\nExample:\n>>> generatePascalsTriangle(3)\n[[1], [1, 1], [1, 2, 1]]\n>>> generatePascalsTriangle(5)\n[[1], [1, 1], [1, 2, 1], [1, 3, 3, 1], [1, 4, 6, 4, 1]]",
      "sq": "Shkruani një funksion Kotlin `fun generatePascalsTriangle(rows: Int): List<List<Int>>` për të zgjidhur problemin e mëposhtëm:\nGjeneron një Trekëndësh të Pascal-it deri në numrin e specifikuar të rreshtave.\nNë Trekëndëshin e Pascal-it, çdo numër është shuma e dy numrave direkt mbi të.\nFunksioni kthen një listë listash, ku çdo listë e brendshme përfaqëson një rresht në trekëndësh.\n\nShembull:\n>>> generatePascalsTriangle(3)\n[[1], [1, 1], [1, 2, 1]]\n>>> generatePascalsTriangle(5)\n[[1], [1, 1], [1, 2, 1], [1, 3, 3, 1], [1, 4, 6, 4, 1]]",
      "hy": "Գրեք Kotlin ֆունկցիա `fun generatePascalsTriangle(rows: Int): List<List<Int>>` հետևյալ խնդիրը լուծելու համար:\nԳեներացնում է Պասկալի եռանկյունի մինչև նշված տողերի քանակը:\nՊասկալի եռանկյունում յուրաքանչյուր թիվ հավասար է իր վերևում գտնվող երկու թվերի գումարին:\nՖունկցիան վերադարձնում է ցուցակ ցուցակների, որտեղ յուրաքանչյուր ներքին ցուցակ ներկայացնում է եռանկյան տողը:\n\nՕրինակ:\n>>> generatePascalsTriangle(3)\n[[1], [1, 1], [1, 2, 1]]\n>>> generatePascalsTriangle(5)\n[[1], [1, 1], [1, 2, 1], [1, 3, 3, 1], [1, 4, 6, 4, 1]]",
      "bn": "একটি Kotlin ফাংশন `fun generatePascalsTriangle(rows: Int): List<List<Int>>` লিখুন নিম্নলিখিত সমস্যার সমাধানের জন্য:\nনির্দিষ্ট সংখ্যক সারি পর্যন্ত একটি প্যাসকেলের ত্রিভুজ তৈরি করে।\nপ্যাসকেলের ত্রিভুজে, প্রতিটি সংখ্যা তার উপরে সরাসরি অবস্থিত দুটি সংখ্যার যোগফল।\nফাংশনটি একটি তালিকার তালিকা ফেরত দেয়, যেখানে প্রতিটি অভ্যন্তরীণ তালিকা ত্রিভুজের একটি সারি উপস্থাপন করে।\n\nউদাহরণ:\n>>> generatePascalsTriangle(3)\n[[1], [1, 1], [1, 2, 1]]\n>>> generatePascalsTriangle(5)\n[[1], [1, 1], [1, 2, 1], [1, 3, 3, 1], [1, 4, 6, 4, 1]]",
      "bg": "Напишете Kotlin функция `fun generatePascalsTriangle(rows: Int): List<List<Int>>`, за да решите следния проблем:\nГенерира триъгълника на Паскал до зададения брой редове.\nВ триъгълника на Паскал всяко число е сумата от двете числа директно над него.\nФункцията връща списък от списъци, където всеки вътрешен списък представлява ред в триъгълника.\n\nПример:\n>>> generatePascalsTriangle(3)\n[[1], [1, 1], [1, 2, 1]]\n>>> generatePascalsTriangle(5)\n[[1], [1, 1], [1, 2, 1], [1, 3, 3, 1], [1, 4, 6, 4, 1]]",
      "zh": "编写一个 Kotlin 函数 `fun generatePascalsTriangle(rows: Int): List<List<Int>>` 来解决以下问题：\n生成一个直到指定行数的帕斯卡三角形。\n在帕斯卡三角形中，每个数字是其正上方两个数字之和。\n该函数返回一个列表的列表，其中每个内部列表表示三角形中的一行。\n\n示例:\n>>> generatePascalsTriangle(3)\n[[1], [1, 1], [1, 2, 1]]\n>>> generatePascalsTriangle(5)\n[[1], [1, 1], [1, 2, 1], [1, 3, 3, 1], [1, 4, 6, 4, 1]]",
      "fr": "Écrire une fonction Kotlin `fun generatePascalsTriangle(rows: Int): List<List<Int>>` pour résoudre le problème suivant :\nGénère un triangle de Pascal jusqu'au nombre de lignes spécifié.\nDans le triangle de Pascal, chaque nombre est la somme des deux nombres directement au-dessus de lui.\nLa fonction renvoie une liste de listes, où chaque liste interne représente une ligne du triangle.\n\nExemple :\n>>> generatePascalsTriangle(3)\n[[1], [1, 1], [1, 2, 1]]\n>>> generatePascalsTriangle(5)\n[[1], [1, 1], [1, 2, 1], [1, 3, 3, 1], [1, 4, 6, 4, 1]]",
      "de": "Schreiben Sie eine Kotlin-Funktion `fun generatePascalsTriangle(rows: Int): List<List<Int>>`, um das folgende Problem zu lösen:\nErzeugt ein Pascalsches Dreieck bis zur angegebenen Anzahl von Zeilen.\nIm Pascalschen Dreieck ist jede Zahl die Summe der beiden direkt darüber liegenden Zahlen.\nDie Funktion gibt eine Liste von Listen zurück, wobei jede innere Liste eine Zeile im Dreieck darstellt.\n\nBeispiel:\n>>> generatePascalsTriangle(3)\n[[1], [1, 1], [1, 2, 1]]\n>>> generatePascalsTriangle(5)\n[[1], [1, 1], [1, 2, 1], [1, 3, 3, 1], [1, 4, 6, 4, 1]]",
      "ha": "Rubuta aikin Kotlin `fun generatePascalsTriangle(rows: Int): List<List<Int>>` don warware matsalar mai zuwa:\nYana samar da Triangle na Pascal har zuwa adadin layuka da aka ayyana.\nA cikin Triangle na Pascal, kowace lamba ita ce jumlar lambobin biyu da ke kai tsaye a sama da ita.\nAikin yana dawowa da jerin jerin, inda kowace jerin ciki ke wakiltar layi a cikin triangle.\n\nMisali:\n>>> generatePascalsTriangle(3)\n[[1], [1, 1], [1, 2, 1]]\n>>> generatePascalsTriangle(5)\n[[1], [1, 1], [1, 2, 1], [1, 3, 3, 1], [1, 4, 6, 4, 1]]",
      "hi": "Kotlin फ़ंक्शन `fun generatePascalsTriangle(rows: Int): List<List<Int>>` लिखें ताकि निम्नलिखित समस्या का समाधान किया जा सके:\nनिर्दिष्ट पंक्तियों की संख्या तक एक Pascal's Triangle उत्पन्न करता है।\nPascal's Triangle में, प्रत्येक संख्या उसके सीधे ऊपर की दो संख्याओं का योग होता है।\nयह फ़ंक्शन सूचियों की एक सूची लौटाता है, जहाँ प्रत्येक आंतरिक सूची त्रिभुज में एक पंक्ति का प्रतिनिधित्व करती है।\n\nउदाहरण:\n>>> generatePascalsTriangle(3)\n[[1], [1, 1], [1, 2, 1]]\n>>> generatePascalsTriangle(5)\n[[1], [1, 1], [1, 2, 1], [1, 3, 3, 1], [1, 4, 6, 4, 1]]",
      "hu": "Írj egy Kotlin függvényt `fun generatePascalsTriangle(rows: Int): List<List<Int>>` a következő probléma megoldására:\nGenerál egy Pascal-háromszöget a megadott sorok számáig.\nA Pascal-háromszögben minden szám az őt közvetlenül megelőző két szám összege.\nA függvény egy listák listáját ad vissza, ahol minden belső lista a háromszög egy sorát képviseli.\n\nPélda:\n>>> generatePascalsTriangle(3)\n[[1], [1, 1], [1, 2, 1]]\n>>> generatePascalsTriangle(5)\n[[1], [1, 1], [1, 2, 1], [1, 3, 3, 1], [1, 4, 6, 4, 1]]"
    },
    "instruction_bertscore": {
      "sq": "1",
      "hy": "0.9899602273905915",
      "bn": "0.9844132753698113",
      "bg": "0.9915331813780068",
      "zh": "0.989729220257448",
      "fr": "0.9932286903105206",
      "de": "0.9970070374185663",
      "ha": "0.9904093306821115",
      "hi": "0.9821850397553619",
      "hu": "0.9954291176716251"
    },
    "level": "middle",
    "test": "fun main() {\n    check(generatePascalsTriangle(1) == listOf(listOf(1)))\n    check(generatePascalsTriangle(2) == listOf(listOf(1), listOf(1, 1)))\n    check(generatePascalsTriangle(3) == listOf(listOf(1), listOf(1, 1), listOf(1, 2, 1)))\n    check(generatePascalsTriangle(4) == listOf(listOf(1), listOf(1, 1), listOf(1, 2, 1), listOf(1, 3, 3, 1)))\n    check(generatePascalsTriangle(5) == listOf(listOf(1), listOf(1, 1), listOf(1, 2, 1), listOf(1, 3, 3, 1), listOf(1, 4, 6, 4, 1)))\n    check(generatePascalsTriangle(6) == listOf(listOf(1), listOf(1, 1), listOf(1, 2, 1), listOf(1, 3, 3, 1), listOf(1, 4, 6, 4, 1), listOf(1, 5, 10, 10, 5, 1)))\n\n}\n\nmain()",
    "entry_point": "generatePascalsTriangle",
    "signature": "fun generatePascalsTriangle(rows: Int): List<List<Int>>",
    "docstring": {
      "en": "Generates a Pascal's Triangle up to the specified number of rows.\nIn Pascal's Triangle, each number is the sum of the two numbers directly above it.\nThe function returns a list of lists, where each inner list represents a row in the triangle.\n\nExample:\n>>> generatePascalsTriangle(3)\n[[1], [1, 1], [1, 2, 1]]\n>>> generatePascalsTriangle(5)\n[[1], [1, 1], [1, 2, 1], [1, 3, 3, 1], [1, 4, 6, 4, 1]]",
      "sq": "Gjeneron një Trekëndësh të Pascal-it deri në numrin e specifikuar të rreshtave. Në Trekëndëshin e Pascal-it, secili numër është shuma e dy numrave direkt mbi të. Funksioni kthen një listë listash, ku secila listë e brendshme përfaqëson një rresht në trekëndësh.\n\nShembull:\n>>> generatePascalsTriangle(3)\n[[1], [1, 1], [1, 2, 1]]\n>>> generatePascalsTriangle(5)\n[[1], [1, 1], [1, 2, 1], [1, 3, 3, 1], [1, 4, 6, 4, 1]]",
      "hy": "Ստեղծում է Պասկալի եռանկյունի մինչև նշված տողերի քանակը:\nՊասկալի եռանկյունում յուրաքանչյուր թիվ հավասար է իր վերևում գտնվող երկու թվերի գումարին:\nՖունկցիան վերադարձնում է ցուցակների ցուցակ, որտեղ յուրաքանչյուր ներքին ցուցակը ներկայացնում է եռանկյունու մի տող:\n\nՕրինակ:\n>>> generatePascalsTriangle(3)\n[[1], [1, 1], [1, 2, 1]]\n>>> generatePascalsTriangle(5)\n[[1], [1, 1], [1, 2, 1], [1, 3, 3, 1], [1, 4, 6, 4, 1]]",
      "bn": "নির্দিষ্ট সংখ্যক সারি পর্যন্ত পাস্কালের ত্রিভুজ তৈরি করে। পাস্কালের ত্রিভুজে, প্রতিটি সংখ্যা তার সরাসরি উপরের দুটি সংখ্যার যোগফল। ফাংশনটি তালিকার একটি তালিকা প্রদান করে, যেখানে প্রতিটি অভ্যন্তরীণ তালিকা ত্রিভুজের একটি সারিকে উপস্থাপন করে।\n\nউদাহরণ:\n>>> generatePascalsTriangle(3)\n[[1], [1, 1], [1, 2, 1]]\n>>> generatePascalsTriangle(5)\n[[1], [1, 1], [1, 2, 1], [1, 3, 3, 1], [1, 4, 6, 4, 1]]",
      "bg": "Генерира Триъгълника на Паскал до зададения брой редове.  \nВ Триъгълника на Паскал всяко число е сумата на двете числа директно над него.  \nФункцията връща списък от списъци, където всеки вътрешен списък представлява ред в триъгълника.\n\nПример:  \n>>> generatePascalsTriangle(3)  \n[[1], [1, 1], [1, 2, 1]]  \n>>> generatePascalsTriangle(5)  \n[[1], [1, 1], [1, 2, 1], [1, 3, 3, 1], [1, 4, 6, 4, 1]]",
      "zh": "生成一个指定行数的帕斯卡三角形。  \n在帕斯卡三角形中，每个数字是其正上方两个数字之和。  \n该函数返回一个列表的列表，其中每个内部列表代表三角形中的一行。\n\n示例:\n>>> generatePascalsTriangle(3)\n[[1], [1, 1], [1, 2, 1]]\n>>> generatePascalsTriangle(5)\n[[1], [1, 1], [1, 2, 1], [1, 3, 3, 1], [1, 4, 6, 4, 1]]",
      "fr": "Génère un triangle de Pascal jusqu'au nombre spécifié de lignes.\nDans le triangle de Pascal, chaque nombre est la somme des deux nombres directement au-dessus de lui.\nLa fonction renvoie une liste de listes, où chaque liste interne représente une ligne dans le triangle.\n\nExemple :\n>>> generatePascalsTriangle(3)\n[[1], [1, 1], [1, 2, 1]]\n>>> generatePascalsTriangle(5)\n[[1], [1, 1], [1, 2, 1], [1, 3, 3, 1], [1, 4, 6, 4, 1]]",
      "de": "Erzeugt ein Pascalsches Dreieck bis zur angegebenen Anzahl von Zeilen.\nIn einem Pascalschen Dreieck ist jede Zahl die Summe der beiden Zahlen direkt darüber.\nDie Funktion gibt eine Liste von Listen zurück, wobei jede innere Liste eine Zeile im Dreieck darstellt.\n\nBeispiel:\n>>> generatePascalsTriangle(3)\n[[1], [1, 1], [1, 2, 1]]\n>>> generatePascalsTriangle(5)\n[[1], [1, 1], [1, 2, 1], [1, 3, 3, 1], [1, 4, 6, 4, 1]]",
      "ha": "Yana haifar da Triangle na Pascal har zuwa adadin layuka da aka ƙayyade.  \nA cikin Triangle na Pascal, kowanne lamba yana daidai da jumlar lambobi biyu da ke kai tsaye a sama da shi.  \nAikin yana dawowa da jerin jerin, inda kowanne jerin ciki ke wakiltar layi a cikin triangle.\n\nMisali:\n>>> generatePascalsTriangle(3)\n[[1], [1, 1], [1, 2, 1]]\n>>> generatePascalsTriangle(5)\n[[1], [1, 1], [1, 2, 1], [1, 3, 3, 1], [1, 4, 6, 4, 1]]",
      "hi": "दिए गए पंक्तियों की संख्या तक एक पास्कल त्रिकोण उत्पन्न करता है। पास्कल त्रिकोण में, प्रत्येक संख्या उसके ठीक ऊपर की दो संख्याओं का योग होती है। यह फ़ंक्शन सूचियों की एक सूची लौटाता है, जहाँ प्रत्येक आंतरिक सूची त्रिकोण में एक पंक्ति का प्रतिनिधित्व करती है।\n\nउदाहरण:\n>>> generatePascalsTriangle(3)\n[[1], [1, 1], [1, 2, 1]]\n>>> generatePascalsTriangle(5)\n[[1], [1, 1], [1, 2, 1], [1, 3, 3, 1], [1, 4, 6, 4, 1]]",
      "hu": "Generál egy Pascal háromszöget a megadott sorok számáig.\nA Pascal háromszögben minden szám az előtte lévő két szám összege.\nA függvény egy listák listáját ad vissza, ahol minden belső lista egy sort képvisel a háromszögben.\n\nPélda:\n>>> generatePascalsTriangle(3)\n[[1], [1, 1], [1, 2, 1]]\n>>> generatePascalsTriangle(5)\n[[1], [1, 1], [1, 2, 1], [1, 3, 3, 1], [1, 4, 6, 4, 1]]"
    },
    "docstring_bertscore": {
      "sq": "1",
      "hy": "0.9737682759893895",
      "bn": "0.9703993060966568",
      "bg": "0.993617608596587",
      "zh": "0.9807032571128417",
      "fr": "0.9964963587089256",
      "de": "0.9906594063318344",
      "ha": "0.9909768176807281",
      "hi": "0.9880241770666445",
      "hu": "0.9897240558675411"
    }
  },
  {
    "task_id": "Kotlin/8",
    "prompt": {
      "en": "/**\n * Calculates the bonus based on the given profit amount. The bonus is calculated on a tiered system:\n * - For profit up to 100,000, the bonus is 10%.\n * - For profit above 100,000 and up to 200,000, it's 10% for the first 100,000 and 7.5% for the rest.\n * - For profit between 200,000 and 400,000, it's 5% for the amount above 200,000.\n * - For profit between 400,000 and 600,000, it's 3% for the amount above 400,000.\n * - For profit between 600,000 and 1,000,000, it's 1.5% for the amount above 600,000.\n * - For profit above 1,000,000, it's 1% for the amount over 1,000,000. \n * The function returns the total bonus amount.\n * Example:\n * >>> calculateBonus(50_000.00)\n *     5000.00\n * >>> calculateBonus(150_000.00)\n *     13750.00\n */\nfun calculateBonus(profit: Double): Double ",
      "sq": "/**\n * Llogarit shpërblimin bazuar në shumën e fitimit të dhënë. Shpërblimi llogaritet mbi një sistem me nivele:\n * - Për fitimin deri në 100,000, shpërblimi është 10%.\n * - Për fitimin mbi 100,000 dhe deri në 200,000, është 10% për 100,000 e parë dhe 7.5% për pjesën tjetër.\n * - Për fitimin midis 200,000 dhe 400,000, është 5% për shumën mbi 200,000.\n * - Për fitimin midis 400,000 dhe 600,000, është 3% për shumën mbi 400,000.\n * - Për fitimin midis 600,000 dhe 1,000,000, është 1.5% për shumën mbi 600,000.\n * - Për fitimin mbi 1,000,000, është 1% për shumën mbi 1,000,000. \n * Funksioni kthen shumën totale të shpërblimit.\n * Shembull:\n * >>> calculateBonus(50_000.00)\n *     5000.00\n * >>> calculateBonus(150_000.00)\n *     13750.00\n */",
      "hy": "/**\n * Հաշվում է բոնուսը տրված շահույթի գումարի հիման վրա։ Բոնուսը հաշվարկվում է աստիճանավոր համակարգով.\n * - Շահույթի համար մինչև 100,000, բոնուսը 10% է։\n * - Շահույթի համար 100,000-ից բարձր և մինչև 200,000, այն 10% է առաջին 100,000-ի համար և 7.5% մնացածի համար։\n * - Շահույթի համար 200,000-ից 400,000-ի միջև, այն 5% է 200,000-ից բարձր գումարի համար։\n * - Շահույթի համար 400,000-ից 600,000-ի միջև, այն 3% է 400,000-ից բարձր գումարի համար։\n * - Շահույթի համար 600,000-ից 1,000,000-ի միջև, այն 1.5% է 600,000-ից բարձր գումարի համար։\n * - Շահույթի համար 1,000,000-ից բարձր, այն 1% է 1,000,000-ից բարձր գումարի համար։\n * Ֆունկցիան վերադարձնում է ընդհանուր բոնուսի գումարը։\n * Օրինակ:\n * >>> calculateBonus(50_000.00)\n *     5000.00\n * >>> calculateBonus(150_000.00)\n *     13750.00\n */",
      "bn": "/**\n * প্রদত্ত মুনাফার পরিমাণের উপর ভিত্তি করে বোনাস গণনা করে। বোনাসটি একটি স্তরভিত্তিক পদ্ধতিতে গণনা করা হয়:\n * - 100,000 পর্যন্ত মুনাফার জন্য, বোনাস 10%।\n * - 100,000 এর উপরে এবং 200,000 পর্যন্ত মুনাফার জন্য, প্রথম 100,000 এর জন্য 10% এবং বাকি অংশের জন্য 7.5%।\n * - 200,000 এবং 400,000 এর মধ্যে মুনাফার জন্য, 200,000 এর উপরে পরিমাণের জন্য 5%।\n * - 400,000 এবং 600,000 এর মধ্যে মুনাফার জন্য, 400,000 এর উপরে পরিমাণের জন্য 3%।\n * - 600,000 এবং 1,000,000 এর মধ্যে মুনাফার জন্য, 600,000 এর উপরে পরিমাণের জন্য 1.5%।\n * - 1,000,000 এর উপরে মুনাফার জন্য, 1,000,000 এর উপরে পরিমাণের জন্য 1%। \n * ফাংশনটি মোট বোনাস পরিমাণ ফেরত দেয়।\n * উদাহরণ:\n * >>> calculateBonus(50_000.00)\n *     5000.00\n * >>> calculateBonus(150_000.00)\n *     13750.00\n */",
      "bg": "/**\n * Изчислява бонуса на базата на дадената сума на печалбата. Бонусът се изчислява по система на нива:\n * - За печалба до 100,000, бонусът е 10%.\n * - За печалба над 100,000 и до 200,000, е 10% за първите 100,000 и 7.5% за останалото.\n * - За печалба между 200,000 и 400,000, е 5% за сумата над 200,000.\n * - За печалба между 400,000 и 600,000, е 3% за сумата над 400,000.\n * - За печалба между 600,000 и 1,000,000, е 1.5% за сумата над 600,000.\n * - За печалба над 1,000,000, е 1% за сумата над 1,000,000. \n * Функцията връща общата сума на бонуса.\n * Пример:\n * >>> calculateBonus(50_000.00)\n *     5000.00\n * >>> calculateBonus(150_000.00)\n *     13750.00\n */\nfun calculateBonus(profit: Double): Double ",
      "zh": "/**\n * 根据给定的利润金额计算奖金。奖金是根据分级系统计算的：\n * - 利润在100,000以内，奖金为10%。\n * - 利润超过100,000且不超过200,000，前100,000为10%，其余为7.5%。\n * - 利润在200,000到400,000之间，超过200,000的部分为5%。\n * - 利润在400,000到600,000之间，超过400,000的部分为3%。\n * - 利润在600,000到1,000,000之间，超过600,000的部分为1.5%。\n * - 利润超过1,000,000，超过1,000,000的部分为1%。\n * 该函数返回总奖金金额。\n * 示例:\n * >>> calculateBonus(50_000.00)\n *     5000.00\n * >>> calculateBonus(150_000.00)\n *     13750.00\n */",
      "fr": "/**\n * Calcule le bonus basé sur le montant du profit donné. Le bonus est calculé selon un système par paliers :\n * - Pour un profit jusqu'à 100 000, le bonus est de 10%.\n * - Pour un profit supérieur à 100 000 et jusqu'à 200 000, c'est 10% pour les premiers 100 000 et 7,5% pour le reste.\n * - Pour un profit entre 200 000 et 400 000, c'est 5% pour le montant au-dessus de 200 000.\n * - Pour un profit entre 400 000 et 600 000, c'est 3% pour le montant au-dessus de 400 000.\n * - Pour un profit entre 600 000 et 1 000 000, c'est 1,5% pour le montant au-dessus de 600 000.\n * - Pour un profit supérieur à 1 000 000, c'est 1% pour le montant au-dessus de 1 000 000. \n * La fonction renvoie le montant total du bonus.\n * Exemple:\n * >>> calculateBonus(50_000.00)\n *     5000.00\n * >>> calculateBonus(150_000.00)\n *     13750.00\n */",
      "de": "/**\n * Berechnet den Bonus basierend auf dem gegebenen Gewinnbetrag. Der Bonus wird nach einem gestaffelten System berechnet:\n * - Für Gewinn bis zu 100.000 beträgt der Bonus 10%.\n * - Für Gewinn über 100.000 und bis zu 200.000 sind es 10% für die ersten 100.000 und 7,5% für den Rest.\n * - Für Gewinn zwischen 200.000 und 400.000 sind es 5% für den Betrag über 200.000.\n * - Für Gewinn zwischen 400.000 und 600.000 sind es 3% für den Betrag über 400.000.\n * - Für Gewinn zwischen 600.000 und 1.000.000 sind es 1,5% für den Betrag über 600.000.\n * - Für Gewinn über 1.000.000 sind es 1% für den Betrag über 1.000.000. \n * Die Funktion gibt den gesamten Bonusbetrag zurück.\n * Beispiel:\n * >>> calculateBonus(50_000.00)\n *     5000.00\n * >>> calculateBonus(150_000.00)\n *     13750.00\n */",
      "ha": "/**\n * Yana lissafin kari bisa ga adadin riba da aka bayar. Ana lissafin karin ne bisa tsarin matakai:\n * - Don riba har zuwa 100,000, karin yana da 10%.\n * - Don riba sama da 100,000 kuma har zuwa 200,000, yana da 10% don farko 100,000 kuma 7.5% don sauran.\n * - Don riba tsakanin 200,000 da 400,000, yana da 5% don adadin da ya wuce 200,000.\n * - Don riba tsakanin 400,000 da 600,000, yana da 3% don adadin da ya wuce 400,000.\n * - Don riba tsakanin 600,000 da 1,000,000, yana da 1.5% don adadin da ya wuce 600,000.\n * - Don riba sama da 1,000,000, yana da 1% don adadin da ya wuce 1,000,000. \n * Aikin yana dawo da jimlar adadin karin.\n * Misali:\n * >>> calculateBonus(50_000.00)\n *     5000.00\n * >>> calculateBonus(150_000.00)\n *     13750.00\n */",
      "hi": "/**\n * दिए गए लाभ राशि के आधार पर बोनस की गणना करता है। बोनस एक स्तरीय प्रणाली पर गणना की जाती है:\n * - 100,000 तक के लाभ के लिए, बोनस 10% है।\n * - 100,000 से अधिक और 200,000 तक के लाभ के लिए, पहले 100,000 के लिए 10% और बाकी के लिए 7.5% है।\n * - 200,000 और 400,000 के बीच के लाभ के लिए, 200,000 से ऊपर की राशि के लिए 5% है।\n * - 400,000 और 600,000 के बीच के लाभ के लिए, 400,000 से ऊपर की राशि के लिए 3% है।\n * - 600,000 और 1,000,000 के बीच के लाभ के लिए, 600,000 से ऊपर की राशि के लिए 1.5% है।\n * - 1,000,000 से अधिक के लाभ के लिए, 1,000,000 से ऊपर की राशि के लिए 1% है।\n * फ़ंक्शन कुल बोनस राशि लौटाता है।\n * उदाहरण:\n * >>> calculateBonus(50_000.00)\n *     5000.00\n * >>> calculateBonus(150_000.00)\n *     13750.00\n */",
      "hu": "/**\n * Kiszámítja a bónuszt a megadott nyereség alapján. A bónusz egy lépcsőzetes rendszer szerint kerül kiszámításra:\n * - 100,000-ig terjedő nyereség esetén a bónusz 10%.\n * - 100,000 feletti és 200,000-ig terjedő nyereség esetén az első 100,000-re 10%, a fennmaradó részre 7,5%.\n * - 200,000 és 400,000 közötti nyereség esetén a 200,000 feletti összegre 5%.\n * - 400,000 és 600,000 közötti nyereség esetén a 400,000 feletti összegre 3%.\n * - 600,000 és 1,000,000 közötti nyereség esetén a 600,000 feletti összegre 1,5%.\n * - 1,000,000 feletti nyereség esetén az 1,000,000 feletti összegre 1%.\n * A függvény visszaadja a teljes bónusz összegét.\n * Példa:\n * >>> calculateBonus(50_000.00)\n *     5000.00\n * >>> calculateBonus(150_000.00)\n *     13750.00\n */\nfun calculateBonus(profit: Double): Double "
    },
    "prompt_bertscore": {
      "sq": "0.9766559644688748",
      "hy": "0.9773773900127934",
      "bn": "0.9573874270958234",
      "bg": "0.9922748672207912",
      "zh": "0.922968754670098",
      "fr": "0.9643821959639669",
      "de": "0.975296935401834",
      "ha": "0.9652293545390808",
      "hi": "0.9611049933072723",
      "hu": "0.9482977035989049"
    },
    "canonical_solution": "{\n    val x =  when {\n        profit <= 100_000 -> profit * 0.10\n        profit <= 200_000 -> 10_000 + (profit - 100_000) * 0.075\n        profit <= 400_000 -> 17_500 + (profit - 200_000) * 0.05\n        profit <= 600_000 -> 27_500 + (profit - 400_000) * 0.03\n        profit <= 1_000_000 -> 33_500 + (profit - 600_000) * 0.015\n        else -> 39_500 + (profit - 1_000_000) * 0.01\n    }\n    println(x)\n    return x\n}",
    "instruction": {
      "en": "Write a Kotlin function `fun calculateBonus(profit: Double): Double` to solve the following problem:\nCalculates the bonus based on the given profit amount. The bonus is calculated on a tiered system:\n- For profit up to 100,000, the bonus is 10%.\n- For profit above 100,000 and up to 200,000, it's 10% for the first 100,000 and 7.5% for the rest.\n- For profit between 200,000 and 400,000, it's 5% for the amount above 200,000.\n- For profit between 400,000 and 600,000, it's 3% for the amount above 400,000.\n- For profit between 600,000 and 1,000,000, it's 1.5% for the amount above 600,000.\n- For profit above 1,000,000, it's 1% for the amount over 1,000,000.\nThe function returns the total bonus amount.\nExample:\n>>> calculateBonus(50_000.00)\n5000.00\n>>> calculateBonus(150_000.00)\n13750.00",
      "sq": "Shkruani një funksion Kotlin `fun calculateBonus(profit: Double): Double` për të zgjidhur problemin e mëposhtëm:\nLlogarit bonusin bazuar në shumën e dhënë të fitimit. Bonusi llogaritet në një sistem të shkallëzuar:\n- Për fitim deri në 100,000, bonusi është 10%.\n- Për fitim mbi 100,000 dhe deri në 200,000, është 10% për 100,000 e parë dhe 7.5% për pjesën tjetër.\n- Për fitim midis 200,000 dhe 400,000, është 5% për shumën mbi 200,000.\n- Për fitim midis 400,000 dhe 600,000, është 3% për shumën mbi 400,000.\n- Për fitim midis 600,000 dhe 1,000,000, është 1.5% për shumën mbi 600,000.\n- Për fitim mbi 1,000,000, është 1% për shumën mbi 1,000,000.\nFunksioni kthen shumën totale të bonusit.\nShembull:\n>>> calculateBonus(50_000.00)\n5000.00\n>>> calculateBonus(150_000.00)\n13750.00",
      "hy": "Գրեք Kotlin ֆունկցիա `fun calculateBonus(profit: Double): Double` հետևյալ խնդիրը լուծելու համար:\nՀաշվում է բոնուսը տրված շահույթի գումարի հիման վրա։ Բոնուսը հաշվարկվում է աստիճանավոր համակարգով.\n- Շահույթի համար մինչև 100,000, բոնուսը կազմում է 10%:\n- Շահույթի համար 100,000-ից ավելի և մինչև 200,000, այն կազմում է 10% առաջին 100,000-ի համար և 7.5% մնացածի համար:\n- Շահույթի համար 200,000-ից մինչև 400,000, այն կազմում է 5% 200,000-ից ավելի գումարի համար:\n- Շահույթի համար 400,000-ից մինչև 600,000, այն կազմում է 3% 400,000-ից ավելի գումարի համար:\n- Շահույթի համար 600,000-ից մինչև 1,000,000, այն կազմում է 1.5% 600,000-ից ավելի գումարի համար:\n- Շահույթի համար 1,000,000-ից ավելի, այն կազմում է 1% 1,000,000-ից ավելի գումարի համար:\nՖունկցիան վերադարձնում է ընդհանուր բոնուսի գումարը:\nՕրինակ:\n>>> calculateBonus(50_000.00)\n5000.00\n>>> calculateBonus(150_000.00)\n13750.00",
      "bn": "Kotlin ফাংশন `fun calculateBonus(profit: Double): Double` লিখুন নিম্নলিখিত সমস্যার সমাধানের জন্য:\nপ্রদত্ত লাভের পরিমাণের উপর ভিত্তি করে বোনাস গণনা করে। বোনাস একটি স্তরভিত্তিক সিস্টেমে গণনা করা হয়:\n- লাভ 100,000 পর্যন্ত হলে, বোনাস 10%।\n- লাভ 100,000 এর উপরে এবং 200,000 পর্যন্ত হলে, প্রথম 100,000 এর জন্য 10% এবং বাকি অংশের জন্য 7.5%।\n- লাভ 200,000 এবং 400,000 এর মধ্যে হলে, 200,000 এর উপরে পরিমাণের জন্য 5%।\n- লাভ 400,000 এবং 600,000 এর মধ্যে হলে, 400,000 এর উপরে পরিমাণের জন্য 3%।\n- লাভ 600,000 এবং 1,000,000 এর মধ্যে হলে, 600,000 এর উপরে পরিমাণের জন্য 1.5%।\n- লাভ 1,000,000 এর উপরে হলে, 1,000,000 এর উপরে পরিমাণের জন্য 1%।\nফাংশনটি মোট বোনাস পরিমাণ ফেরত দেয়।\nউদাহরণ:\n>>> calculateBonus(50_000.00)\n5000.00\n>>> calculateBonus(150_000.00)\n13750.00",
      "bg": "Напишете Kotlin функция `fun calculateBonus(profit: Double): Double`, за да решите следния проблем:\nИзчислява бонуса на базата на дадената сума на печалбата. Бонусът се изчислява по система на нива:\n- За печалба до 100,000, бонусът е 10%.\n- За печалба над 100,000 и до 200,000, е 10% за първите 100,000 и 7.5% за останалото.\n- За печалба между 200,000 и 400,000, е 5% за сумата над 200,000.\n- За печалба между 400,000 и 600,000, е 3% за сумата над 400,000.\n- За печалба между 600,000 и 1,000,000, е 1.5% за сумата над 600,000.\n- За печалба над 1,000,000, е 1% за сумата над 1,000,000.\nФункцията връща общата сума на бонуса.\nПример:\n>>> calculateBonus(50_000.00)\n5000.00\n>>> calculateBonus(150_000.00)\n13750.00",
      "zh": "编写一个 Kotlin 函数 `fun calculateBonus(profit: Double): Double` 来解决以下问题：\n根据给定的利润金额计算奖金。奖金是基于分级系统计算的：\n- 利润最多为 100,000 时，奖金为 10%。\n- 利润超过 100,000 且最多为 200,000 时，前 100,000 的奖金为 10%，其余部分为 7.5%。\n- 利润在 200,000 到 400,000 之间时，超过 200,000 的部分为 5%。\n- 利润在 400,000 到 600,000 之间时，超过 400,000 的部分为 3%。\n- 利润在 600,000 到 1,000,000 之间时，超过 600,000 的部分为 1.5%。\n- 利润超过 1,000,000 时，超过 1,000,000 的部分为 1%。\n函数返回总奖金金额。\n示例：\n>>> calculateBonus(50_000.00)\n5000.00\n>>> calculateBonus(150_000.00)\n13750.00",
      "fr": "Écrire une fonction Kotlin `fun calculateBonus(profit: Double): Double` pour résoudre le problème suivant :\nCalcule le bonus basé sur le montant du profit donné. Le bonus est calculé selon un système par paliers :\n- Pour un profit jusqu'à 100 000, le bonus est de 10 %.\n- Pour un profit supérieur à 100 000 et jusqu'à 200 000, c'est 10 % pour les premiers 100 000 et 7,5 % pour le reste.\n- Pour un profit entre 200 000 et 400 000, c'est 5 % pour le montant au-dessus de 200 000.\n- Pour un profit entre 400 000 et 600 000, c'est 3 % pour le montant au-dessus de 400 000.\n- Pour un profit entre 600 000 et 1 000 000, c'est 1,5 % pour le montant au-dessus de 600 000.\n- Pour un profit supérieur à 1 000 000, c'est 1 % pour le montant au-dessus de 1 000 000.\nLa fonction retourne le montant total du bonus.\nExemple :\n>>> calculateBonus(50_000.00)\n5000.00\n>>> calculateBonus(150_000.00)\n13750.00",
      "de": "Schreiben Sie eine Kotlin-Funktion `fun calculateBonus(profit: Double): Double`, um das folgende Problem zu lösen:\nBerechnet den Bonus basierend auf dem gegebenen Gewinnbetrag. Der Bonus wird nach einem gestuften System berechnet:\n- Für Gewinn bis zu 100.000 beträgt der Bonus 10%.\n- Für Gewinn über 100.000 und bis zu 200.000 sind es 10% für die ersten 100.000 und 7,5% für den Rest.\n- Für Gewinn zwischen 200.000 und 400.000 sind es 5% für den Betrag über 200.000.\n- Für Gewinn zwischen 400.000 und 600.000 sind es 3% für den Betrag über 400.000.\n- Für Gewinn zwischen 600.000 und 1.000.000 sind es 1,5% für den Betrag über 600.000.\n- Für Gewinn über 1.000.000 sind es 1% für den Betrag über 1.000.000.\nDie Funktion gibt den gesamten Bonusbetrag zurück.\nBeispiel:\n>>> calculateBonus(50_000.00)\n5000.00\n>>> calculateBonus(150_000.00)\n13750.00",
      "ha": "Rubuta wani aikin Kotlin `fun calculateBonus(profit: Double): Double` don warware matsalar mai zuwa:\nYana ƙididdige kari bisa ga adadin riba da aka bayar. Ana ƙididdige kari akan tsarin matakai:\n- Don riba har zuwa 100,000, kari shine 10%.\n- Don riba sama da 100,000 kuma har zuwa 200,000, yana da 10% don farkon 100,000 da 7.5% don sauran.\n- Don riba tsakanin 200,000 da 400,000, yana da 5% don adadin sama da 200,000.\n- Don riba tsakanin 400,000 da 600,000, yana da 3% don adadin sama da 400,000.\n- Don riba tsakanin 600,000 da 1,000,000, yana da 1.5% don adadin sama da 600,000.\n- Don riba sama da 1,000,000, yana da 1% don adadin sama da 1,000,000.\nAikin yana dawo da jimlar adadin kari.\nMisali:\n>>> calculateBonus(50_000.00)\n5000.00\n>>> calculateBonus(150_000.00)\n13750.00",
      "hi": "Kotlin फ़ंक्शन `fun calculateBonus(profit: Double): Double` लिखें ताकि निम्नलिखित समस्या का समाधान किया जा सके:\nदिए गए लाभ राशि के आधार पर बोनस की गणना करता है। बोनस एक स्तरीय प्रणाली पर गणना की जाती है:\n- 100,000 तक के लाभ के लिए, बोनस 10% है।\n- 100,000 से अधिक और 200,000 तक के लाभ के लिए, पहले 100,000 के लिए 10% और बाकी के लिए 7.5% है।\n- 200,000 और 400,000 के बीच के लाभ के लिए, 200,000 से अधिक राशि के लिए 5% है।\n- 400,000 और 600,000 के बीच के लाभ के लिए, 400,000 से अधिक राशि के लिए 3% है।\n- 600,000 और 1,000,000 के बीच के लाभ के लिए, 600,000 से अधिक राशि के लिए 1.5% है।\n- 1,000,000 से अधिक के लाभ के लिए, 1,000,000 से अधिक राशि के लिए 1% है।\nफ़ंक्शन कुल बोनस राशि लौटाता है।\nउदाहरण:\n>>> calculateBonus(50_000.00)\n5000.00\n>>> calculateBonus(150_000.00)\n13750.00",
      "hu": "Írj egy Kotlin függvényt `fun calculateBonus(profit: Double): Double` a következő probléma megoldására:\nKiszámítja a bónuszt a megadott profit összeg alapján. A bónusz egy sávos rendszer szerint kerül kiszámításra:\n- 100,000-ig terjedő profit esetén a bónusz 10%.\n- 100,000 feletti és 200,000-ig terjedő profit esetén az első 100,000-re 10%, a fennmaradó részre 7,5%.\n- 200,000 és 400,000 közötti profit esetén a 200,000 feletti összegre 5%.\n- 400,000 és 600,000 közötti profit esetén a 400,000 feletti összegre 3%.\n- 600,000 és 1,000,000 közötti profit esetén a 600,000 feletti összegre 1,5%.\n- 1,000,000 feletti profit esetén az 1,000,000 feletti összegre 1%.\nA függvény visszaadja a teljes bónusz összegét.\nPélda:\n>>> calculateBonus(50_000.00)\n5000.00\n>>> calculateBonus(150_000.00)\n13750.00"
    },
    "instruction_bertscore": {
      "sq": "0.9876950465252697",
      "hy": "0.9827173691765354",
      "bn": "0.9512340565217435",
      "bg": "0.9906163035391499",
      "zh": "0.9227008022860819",
      "fr": "0.9785691722990028",
      "de": "0.9900218028087124",
      "ha": "0.9888258492845013",
      "hi": "0.9826081224669663",
      "hu": "0.9493339582967638"
    },
    "level": "middle",
    "test": "fun main(){\n    check(calculateBonus(50_000.00) == 5000.00)\n    check(calculateBonus(210_000.00) == 18000.00)\n    check(calculateBonus(150_000.00) == 13750.00)\n    check(calculateBonus(250_000.00) == 20000.00)\n    check(calculateBonus(450_000.00) == 29000.00)\n    check(calculateBonus(650_000.00) == 34250.00)\n    check(calculateBonus(1_050_000.00) == 40000.00)\n    check(calculateBonus(2_000_000.00) == 49500.00)\n}\n\nmain()",
    "entry_point": "calculateBonus",
    "signature": "fun calculateBonus(profit: Double): Double",
    "docstring": {
      "en": "Calculates the bonus based on the given profit amount. The bonus is calculated on a tiered system:\n- For profit up to 100,000, the bonus is 10%.\n- For profit above 100,000 and up to 200,000, it's 10% for the first 100,000 and 7.5% for the rest.\n- For profit between 200,000 and 400,000, it's 5% for the amount above 200,000.\n- For profit between 400,000 and 600,000, it's 3% for the amount above 400,000.\n- For profit between 600,000 and 1,000,000, it's 1.5% for the amount above 600,000.\n- For profit above 1,000,000, it's 1% for the amount over 1,000,000.\nThe function returns the total bonus amount.\nExample:\n>>> calculateBonus(50_000.00)\n5000.00\n>>> calculateBonus(150_000.00)\n13750.00",
      "sq": "Llogarit shpërblimin bazuar në shumën e fitimit të dhënë. Shpërblimi llogaritet sipas një sistemi të shkallëzuar:\n- Për fitim deri në 100,000, shpërblimi është 10%.\n- Për fitim mbi 100,000 dhe deri në 200,000, është 10% për 100,000 e parë dhe 7.5% për pjesën tjetër.\n- Për fitim midis 200,000 dhe 400,000, është 5% për shumën mbi 200,000.\n- Për fitim midis 400,000 dhe 600,000, është 3% për shumën mbi 400,000.\n- Për fitim midis 600,000 dhe 1,000,000, është 1.5% për shumën mbi 600,000.\n- Për fitim mbi 1,000,000, është 1% për shumën mbi 1,000,000.\nFunksioni kthen shumën totale të shpërblimit.\nShembull:\n>>> calculateBonus(50_000.00)\n5000.00\n>>> calculateBonus(150_000.00)\n13750.00",
      "hy": "Հաշվարկում է բոնուսը տրված շահույթի գումարի հիման վրա։ Բոնուսը հաշվարկվում է աստիճանավոր համակարգով.\n- Մինչև 100,000 շահույթի դեպքում բոնուսը կազմում է 10%:\n- 100,000-ից մինչև 200,000 շահույթի դեպքում՝ 10% առաջին 100,000-ի համար և 7.5% մնացածի համար:\n- 200,000-ից մինչև 400,000 շահույթի դեպքում՝ 5% 200,000-ից ավել գումարի համար:\n- 400,000-ից մինչև 600,000 շահույթի դեպքում՝ 3% 400,000-ից ավել գումարի համար:\n- 600,000-ից մինչև 1,000,000 շահույթի դեպքում՝ 1.5% 600,000-ից ավել գումարի համար:\n- 1,000,000-ից ավել շահույթի դեպքում՝ 1% 1,000,000-ից ավել գումարի համար:\nՖունկցիան վերադարձնում է ընդհանուր բոնուսի գումարը։\nՕրինակ:\n>>> calculateBonus(50_000.00)\n5000.00\n>>> calculateBonus(150_000.00)\n13750.00",
      "bn": "প্রদত্ত মুনাফার পরিমাণের উপর ভিত্তি করে বোনাস গণনা করে। বোনাসটি একটি স্তরভিত্তিক সিস্টেমে গণনা করা হয়:\n- মুনাফা 100,000 পর্যন্ত হলে, বোনাস 10%।\n- মুনাফা 100,000 এর উপরে এবং 200,000 পর্যন্ত হলে, প্রথম 100,000 এর জন্য 10% এবং বাকি অংশের জন্য 7.5%।\n- মুনাফা 200,000 এবং 400,000 এর মধ্যে হলে, 200,000 এর উপরে পরিমাণের জন্য 5%।\n- মুনাফা 400,000 এবং 600,000 এর মধ্যে হলে, 400,000 এর উপরে পরিমাণের জন্য 3%।\n- মুনাফা 600,000 এবং 1,000,000 এর মধ্যে হলে, 600,000 এর উপরে পরিমাণের জন্য 1.5%।\n- মুনাফা 1,000,000 এর উপরে হলে, 1,000,000 এর উপরে পরিমাণের জন্য 1%।\nফাংশনটি মোট বোনাসের পরিমাণ প্রদান করে।\nউদাহরণ:\n>>> calculateBonus(50_000.00)\n5000.00\n>>> calculateBonus(150_000.00)\n13750.00",
      "bg": "Изчислява бонуса на базата на дадената сума на печалбата. Бонусът се изчислява по система на нива:\n- За печалба до 100,000, бонусът е 10%.\n- За печалба над 100,000 и до 200,000, е 10% за първите 100,000 и 7.5% за останалото.\n- За печалба между 200,000 и 400,000, е 5% за сумата над 200,000.\n- За печалба между 400,000 и 600,000, е 3% за сумата над 400,000.\n- За печалба между 600,000 и 1,000,000, е 1.5% за сумата над 600,000.\n- За печалба над 1,000,000, е 1% за сумата над 1,000,000.\nФункцията връща общата сума на бонуса.\nПример:\n>>> calculateBonus(50_000.00)\n5000.00\n>>> calculateBonus(150_000.00)\n13750.00",
      "zh": "计算基于给定利润金额的奖金。奖金是根据分级系统计算的：\n- 对于利润不超过 100,000 的部分，奖金为 10%。\n- 对于利润超过 100,000 且不超过 200,000 的部分，前 100,000 的奖金为 10%，其余部分为 7.5%。\n- 对于利润在 200,000 到 400,000 之间的部分，超过 200,000 的部分奖金为 5%。\n- 对于利润在 400,000 到 600,000 之间的部分，超过 400,000 的部分奖金为 3%。\n- 对于利润在 600,000 到 1,000,000 之间的部分，超过 600,000 的部分奖金为 1.5%。\n- 对于利润超过 1,000,000 的部分，超过 1,000,000 的部分奖金为 1%。\n函数返回总奖金金额。\n例子：\n>>> calculateBonus(50_000.00)\n5000.00\n>>> calculateBonus(150_000.00)\n13750.00",
      "fr": "Calcule le bonus basé sur le montant du bénéfice donné. Le bonus est calculé selon un système par paliers :\n- Pour un bénéfice jusqu'à 100 000, le bonus est de 10 %.\n- Pour un bénéfice supérieur à 100 000 et jusqu'à 200 000, c'est 10 % pour les premiers 100 000 et 7,5 % pour le reste.\n- Pour un bénéfice entre 200 000 et 400 000, c'est 5 % pour le montant supérieur à 200 000.\n- Pour un bénéfice entre 400 000 et 600 000, c'est 3 % pour le montant supérieur à 400 000.\n- Pour un bénéfice entre 600 000 et 1 000 000, c'est 1,5 % pour le montant supérieur à 600 000.\n- Pour un bénéfice supérieur à 1 000 000, c'est 1 % pour le montant supérieur à 1 000 000.\nLa fonction retourne le montant total du bonus.\nExemple :\n>>> calculateBonus(50_000.00)\n5000.00\n>>> calculateBonus(150_000.00)\n13750.00",
      "de": "Berechnet den Bonus basierend auf dem gegebenen Gewinnbetrag. Der Bonus wird nach einem gestuften System berechnet:\n- Für Gewinne bis zu 100.000 beträgt der Bonus 10%.\n- Für Gewinne über 100.000 und bis zu 200.000 sind es 10% für die ersten 100.000 und 7,5% für den Rest.\n- Für Gewinne zwischen 200.000 und 400.000 sind es 5% für den Betrag über 200.000.\n- Für Gewinne zwischen 400.000 und 600.000 sind es 3% für den Betrag über 400.000.\n- Für Gewinne zwischen 600.000 und 1.000.000 sind es 1,5% für den Betrag über 600.000.\n- Für Gewinne über 1.000.000 sind es 1% für den Betrag über 1.000.000.\nDie Funktion gibt den gesamten Bonusbetrag zurück.\nBeispiel:\n>>> calculateBonus(50_000.00)\n5000.00\n>>> calculateBonus(150_000.00)\n13750.00",
      "ha": "Yana lissafin kari bisa ga adadin riba da aka bayar. Ana ƙididdige ƙarin akan tsarin matakai:\n- Don riba har zuwa 100,000, ƙarin yana da 10%.\n- Don riba sama da 100,000 kuma har zuwa 200,000, yana da 10% don farkon 100,000 da 7.5% don sauran.\n- Don riba tsakanin 200,000 da 400,000, yana da 5% don adadin da ya wuce 200,000.\n- Don riba tsakanin 400,000 da 600,000, yana da 3% don adadin da ya wuce 400,000.\n- Don riba tsakanin 600,000 da 1,000,000, yana da 1.5% don adadin da ya wuce 600,000.\n- Don riba sama da 1,000,000, yana da 1% don adadin da ya wuce 1,000,000.\nAikin yana dawowa da jimlar adadin ƙarin.\nMisali:\n>>> calculateBonus(50_000.00)\n5000.00\n>>> calculateBonus(150_000.00)\n13750.00",
      "hi": "दिए गए लाभ राशि के आधार पर बोनस की गणना करता है। बोनस दिए गए लाभ राशि के आधार पर गणना की जाती है। बोनस एक स्तरित प्रणाली पर आधारित है:\n- 100,000 तक के लाभ के लिए, बोनस 10% है।\n- 100,000 से अधिक और 200,000 तक के लाभ के लिए, पहले 100,000 के लिए 10% और बाकी के लिए 7.5% है।\n- 200,000 और 400,000 के बीच के लाभ के लिए, 200,000 से अधिक राशि के लिए 5% है।\n- 400,000 और 600,000 के बीच के लाभ के लिए, 400,000 से अधिक राशि के लिए 3% है।\n- 600,000 और 1,000,000 के बीच के लाभ के लिए, 600,000 से अधिक राशि के लिए 1.5% है।\n- 1,000,000 से अधिक लाभ के लिए, 1,000,000 से अधिक राशि के लिए 1% है।\nThe function returns the total bonus amount. यह फ़ंक्शन कुल बोनस राशि लौटाता है।\nउदाहरण:\n>>> calculateBonus(50_000.00)\n5000.00\n>>> calculateBonus(150_000.00)\n13750.00",
      "hu": "Kiszámítja a bónuszt a megadott nyereség alapján. A bónusz egy sávos rendszer szerint kerül kiszámításra:\n- 100,000-ig terjedő nyereség esetén a bónusz 10%.\n- 100,000 feletti és 200,000-ig terjedő nyereség esetén az első 100,000-re 10%, a fennmaradó részre 7,5%.\n- 200,000 és 400,000 közötti nyereség esetén a 200,000 feletti összegre 5%.\n- 400,000 és 600,000 közötti nyereség esetén a 400,000 feletti összegre 3%.\n- 600,000 és 1,000,000 közötti nyereség esetén a 600,000 feletti összegre 1,5%.\n- 1,000,000 feletti nyereség esetén az 1,000,000 feletti összegre 1%.\nA függvény visszaadja a teljes bónusz összegét.\nPélda:\n>>> calculateBonus(50_000.00)\n5000.00\n>>> calculateBonus(150_000.00)\n13750.00"
    },
    "docstring_bertscore": {
      "sq": "0.9815114841332726",
      "hy": "0.9556398770034784",
      "bn": "0.9505213707145904",
      "bg": "0.9828923625422271",
      "zh": "0.9014954200675593",
      "fr": "0.9743397355956269",
      "de": "0.9845976043634117",
      "ha": "0.9882752458682726",
      "hi": "0.9852580503803526",
      "hu": "0.9569542142347863"
    }
  },
  {
    "task_id": "Kotlin/9",
    "prompt": {
      "en": "/**\n    * Returns the top ten highest scores from a given list of scores, sorted in descending order.\n    * If there are fewer than ten scores in the list, all scores are returned.\n    * Example:\n    >>> topTenScores(listOf(12.5, 15.0, 9.5, 18.0, 22.0, 7.0, 14.5, 16.5, 17.5, 19.5, 20.5, 21.5))\n        [22.0, 21.5, 20.5, 19.5, 18.0, 17.5, 16.5, 15.0, 14.5, 12.5]\n    >>> topTenScores(listOf(5.0, 3.0, 4.0))\n        [5.0, 4.0, 3.0]\n**/\nfun topTenScores(scores: List<Double>): List<Double> ",
      "sq": "/**\n    * Kthen dhjetë rezultatet më të larta nga një listë e dhënë e rezultateve, të renditura në rend zbritës.\n    * Nëse ka më pak se dhjetë rezultate në listë, kthehen të gjitha rezultatet.\n    * Shembull:\n    >>> topTenScores(listOf(12.5, 15.0, 9.5, 18.0, 22.0, 7.0, 14.5, 16.5, 17.5, 19.5, 20.5, 21.5))\n        [22.0, 21.5, 20.5, 19.5, 18.0, 17.5, 16.5, 15.0, 14.5, 12.5]\n    >>> topTenScores(listOf(5.0, 3.0, 4.0))\n        [5.0, 4.0, 3.0]\n**/\nfun topTenScores(scores: List<Double>): List<Double> ",
      "hy": "/**\n    * Վերադարձնում է տասն ամենաբարձր միավորները տրված միավորների ցուցակից, դասավորված նվազման կարգով:\n    * Եթե ցուցակում տասից քիչ միավորներ կան, վերադարձվում են բոլոր միավորները:\n    * Օրինակ:\n    >>> topTenScores(listOf(12.5, 15.0, 9.5, 18.0, 22.0, 7.0, 14.5, 16.5, 17.5, 19.5, 20.5, 21.5))\n        [22.0, 21.5, 20.5, 19.5, 18.0, 17.5, 16.5, 15.0, 14.5, 12.5]\n    >>> topTenScores(listOf(5.0, 3.0, 4.0))\n        [5.0, 4.0, 3.0]\n**/\nfun topTenScores(scores: List<Double>): List<Double> ",
      "bn": "/**\n    * প্রদত্ত স্কোরের তালিকা থেকে শীর্ষ দশটি সর্বোচ্চ স্কোর ফেরত দেয়, অবনতিশীল ক্রমে সাজানো।\n    * যদি তালিকায় দশটির কম স্কোর থাকে, তবে সমস্ত স্কোর ফেরত দেওয়া হয়।\n    * উদাহরণ:\n    >>> topTenScores(listOf(12.5, 15.0, 9.5, 18.0, 22.0, 7.0, 14.5, 16.5, 17.5, 19.5, 20.5, 21.5))\n        [22.0, 21.5, 20.5, 19.5, 18.0, 17.5, 16.5, 15.0, 14.5, 12.5]\n    >>> topTenScores(listOf(5.0, 3.0, 4.0))\n        [5.0, 4.0, 3.0]\n**/\nfun topTenScores(scores: List<Double>): List<Double> ",
      "bg": "/**\n    * Връща десетте най-високи резултата от даден списък с резултати, сортирани в низходящ ред.\n    * Ако в списъка има по-малко от десет резултата, се връщат всички резултати.\n    * Пример:\n    >>> topTenScores(listOf(12.5, 15.0, 9.5, 18.0, 22.0, 7.0, 14.5, 16.5, 17.5, 19.5, 20.5, 21.5))\n        [22.0, 21.5, 20.5, 19.5, 18.0, 17.5, 16.5, 15.0, 14.5, 12.5]\n    >>> topTenScores(listOf(5.0, 3.0, 4.0))\n        [5.0, 4.0, 3.0]\n**/\nfun topTenScores(scores: List<Double>): List<Double> ",
      "zh": "/**\n    * 返回给定分数列表中最高的前十个分数，按降序排列。\n    * 如果列表中的分数少于十个，则返回所有分数。\n    * 示例:\n    >>> topTenScores(listOf(12.5, 15.0, 9.5, 18.0, 22.0, 7.0, 14.5, 16.5, 17.5, 19.5, 20.5, 21.5))\n        [22.0, 21.5, 20.5, 19.5, 18.0, 17.5, 16.5, 15.0, 14.5, 12.5]\n    >>> topTenScores(listOf(5.0, 3.0, 4.0))\n        [5.0, 4.0, 3.0]\n**/\nfun topTenScores(scores: List<Double>): List<Double> ",
      "fr": "/**\n    * Renvoie les dix meilleurs scores d'une liste donnée de scores, triés par ordre décroissant.\n    * S'il y a moins de dix scores dans la liste, tous les scores sont renvoyés.\n    * Exemple :\n    >>> topTenScores(listOf(12.5, 15.0, 9.5, 18.0, 22.0, 7.0, 14.5, 16.5, 17.5, 19.5, 20.5, 21.5))\n        [22.0, 21.5, 20.5, 19.5, 18.0, 17.5, 16.5, 15.0, 14.5, 12.5]\n    >>> topTenScores(listOf(5.0, 3.0, 4.0))\n        [5.0, 4.0, 3.0]\n**/\nfun topTenScores(scores: List<Double>): List<Double> ",
      "de": "/**\n    * Gibt die zehn höchsten Punktzahlen aus einer gegebenen Liste von Punktzahlen zurück, sortiert in absteigender Reihenfolge.\n    * Wenn es weniger als zehn Punktzahlen in der Liste gibt, werden alle Punktzahlen zurückgegeben.\n    * Beispiel:\n    >>> topTenScores(listOf(12.5, 15.0, 9.5, 18.0, 22.0, 7.0, 14.5, 16.5, 17.5, 19.5, 20.5, 21.5))\n        [22.0, 21.5, 20.5, 19.5, 18.0, 17.5, 16.5, 15.0, 14.5, 12.5]\n    >>> topTenScores(listOf(5.0, 3.0, 4.0))\n        [5.0, 4.0, 3.0]\n**/\nfun topTenScores(scores: List<Double>): List<Double> ",
      "ha": "/**\n    * Yana mayar da maki goma mafi girma daga jerin maki da aka bayar, an jera su a cikin tsari mai saukowa.\n    * Idan akwai maki kasa da goma a cikin jerin, duk maki za a mayar.\n    * Misali:\n    >>> topTenScores(listOf(12.5, 15.0, 9.5, 18.0, 22.0, 7.0, 14.5, 16.5, 17.5, 19.5, 20.5, 21.5))\n        [22.0, 21.5, 20.5, 19.5, 18.0, 17.5, 16.5, 15.0, 14.5, 12.5]\n    >>> topTenScores(listOf(5.0, 3.0, 4.0))\n        [5.0, 4.0, 3.0]\n**/\nfun topTenScores(scores: List<Double>): List<Double> ",
      "hi": "/**\n    * दिए गए अंकों की सूची से शीर्ष दस उच्चतम स्कोर लौटाता है, अवरोही क्रम में क्रमबद्ध।\n    * यदि सूची में दस से कम स्कोर हैं, तो सभी स्कोर लौटाए जाते हैं।\n    * उदाहरण:\n    >>> topTenScores(listOf(12.5, 15.0, 9.5, 18.0, 22.0, 7.0, 14.5, 16.5, 17.5, 19.5, 20.5, 21.5))\n        [22.0, 21.5, 20.5, 19.5, 18.0, 17.5, 16.5, 15.0, 14.5, 12.5]\n    >>> topTenScores(listOf(5.0, 3.0, 4.0))\n        [5.0, 4.0, 3.0]\n**/\nfun topTenScores(scores: List<Double>): List<Double> ",
      "hu": "/**\n    * Visszaadja a legmagasabb tíz pontszámot egy adott pontszámok listájából, csökkenő sorrendben rendezve.\n    * Ha kevesebb mint tíz pontszám van a listában, az összes pontszám visszaadásra kerül.\n    * Példa:\n    >>> topTenScores(listOf(12.5, 15.0, 9.5, 18.0, 22.0, 7.0, 14.5, 16.5, 17.5, 19.5, 20.5, 21.5))\n        [22.0, 21.5, 20.5, 19.5, 18.0, 17.5, 16.5, 15.0, 14.5, 12.5]\n    >>> topTenScores(listOf(5.0, 3.0, 4.0))\n        [5.0, 4.0, 3.0]\n**/\nfun topTenScores(scores: List<Double>): List<Double> "
    },
    "prompt_bertscore": {
      "sq": "0.9932443821106224",
      "hy": "0.9915218594462879",
      "bn": "0.9981225456384583",
      "bg": "0.9932443821106224",
      "zh": "0.9899365903752484",
      "fr": "0.9932443821106224",
      "de": "0.9935300125985506",
      "ha": "0.994774034674972",
      "hi": "0.9952114187740109",
      "hu": "0.9966904205911967"
    },
    "canonical_solution": "{\n    // Sort the scores in descending order and take the top ten\n    return scores.sortedDescending().take(10)\n}",
    "instruction": {
      "en": "Write a Kotlin function `fun topTenScores(scores: List<Double>): List<Double>` to solve the following problem:\nReturns the top ten highest scores from a given list of scores, sorted in descending order.\nIf there are fewer than ten scores in the list, all scores are returned.\nExample:\n>>> topTenScores(listOf(12.5, 15.0, 9.5, 18.0, 22.0, 7.0, 14.5, 16.5, 17.5, 19.5, 20.5, 21.5))\n[22.0, 21.5, 20.5, 19.5, 18.0, 17.5, 16.5, 15.0, 14.5, 12.5]\n>>> topTenScores(listOf(5.0, 3.0, 4.0))\n[5.0, 4.0, 3.0]",
      "sq": "Shkruani një funksion Kotlin `fun topTenScores(scores: List<Double>): List<Double>` për të zgjidhur problemin e mëposhtëm: \nKthen dhjetë rezultatet më të larta nga një listë e dhënë e rezultateve, të renditura në rend zbritës. \nNëse ka më pak se dhjetë rezultate në listë, të gjitha rezultatet kthehen. \nShembull: \n>>> topTenScores(listOf(12.5, 15.0, 9.5, 18.0, 22.0, 7.0, 14.5, 16.5, 17.5, 19.5, 20.5, 21.5)) \n[22.0, 21.5, 20.5, 19.5, 18.0, 17.5, 16.5, 15.0, 14.5, 12.5] \n>>> topTenScores(listOf(5.0, 3.0, 4.0)) \n[5.0, 4.0, 3.0]",
      "hy": "Գրեք Kotlin ֆունկցիա `fun topTenScores(scores: List<Double>): List<Double>` հետևյալ խնդիրը լուծելու համար:\nՎերադարձնում է տրված միավորների ցուցակից տասը ամենաբարձր միավորները՝ դասավորված նվազման կարգով:\nԵթե ցուցակում տասից պակաս միավորներ կան, վերադարձվում են բոլոր միավորները:\nՕրինակ:\n>>> topTenScores(listOf(12.5, 15.0, 9.5, 18.0, 22.0, 7.0, 14.5, 16.5, 17.5, 19.5, 20.5, 21.5))\n[22.0, 21.5, 20.5, 19.5, 18.0, 17.5, 16.5, 15.0, 14.5, 12.5]\n>>> topTenScores(listOf(5.0, 3.0, 4.0))\n[5.0, 4.0, 3.0]",
      "bn": "Kotlin ফাংশন `fun topTenScores(scores: List<Double>): List<Double>` লিখুন নিম্নলিখিত সমস্যার সমাধানের জন্য:\nপ্রদত্ত স্কোরের তালিকা থেকে সর্বোচ্চ দশটি স্কোর ফেরত দেয়, অবরোহ ক্রমে সাজানো।\nযদি তালিকায় দশটির কম স্কোর থাকে, তবে সমস্ত স্কোর ফেরত দেওয়া হয়।\nউদাহরণ:\n>>> topTenScores(listOf(12.5, 15.0, 9.5, 18.0, 22.0, 7.0, 14.5, 16.5, 17.5, 19.5, 20.5, 21.5))\n[22.0, 21.5, 20.5, 19.5, 18.0, 17.5, 16.5, 15.0, 14.5, 12.5]\n>>> topTenScores(listOf(5.0, 3.0, 4.0))\n[5.0, 4.0, 3.0]",
      "bg": "Напишете функция на Kotlin `fun topTenScores(scores: List<Double>): List<Double>` за решаване на следния проблем:\nВръща десетте най-високи резултата от даден списък с резултати, сортирани в низходящ ред.\nАко в списъка има по-малко от десет резултата, се връщат всички резултати.\nПример:\n>>> topTenScores(listOf(12.5, 15.0, 9.5, 18.0, 22.0, 7.0, 14.5, 16.5, 17.5, 19.5, 20.5, 21.5))\n[22.0, 21.5, 20.5, 19.5, 18.0, 17.5, 16.5, 15.0, 14.5, 12.5]\n>>> topTenScores(listOf(5.0, 3.0, 4.0))\n[5.0, 4.0, 3.0]",
      "zh": "编写一个 Kotlin 函数 `fun topTenScores(scores: List<Double>): List<Double>` 来解决以下问题：\n返回给定分数列表中最高的前十个分数，按降序排序。\n如果列表中的分数少于十个，则返回所有分数。\n示例:\n>>> topTenScores(listOf(12.5, 15.0, 9.5, 18.0, 22.0, 7.0, 14.5, 16.5, 17.5, 19.5, 20.5, 21.5))\n[22.0, 21.5, 20.5, 19.5, 18.0, 17.5, 16.5, 15.0, 14.5, 12.5]\n>>> topTenScores(listOf(5.0, 3.0, 4.0))\n[5.0, 4.0, 3.0]",
      "fr": "Écrire une fonction Kotlin `fun topTenScores(scores: List<Double>): List<Double>` pour résoudre le problème suivant :  \nRenvoie les dix scores les plus élevés d'une liste donnée de scores, triés par ordre décroissant.  \nS'il y a moins de dix scores dans la liste, tous les scores sont renvoyés.  \nExemple :  \n>>> topTenScores(listOf(12.5, 15.0, 9.5, 18.0, 22.0, 7.0, 14.5, 16.5, 17.5, 19.5, 20.5, 21.5))  \n[22.0, 21.5, 20.5, 19.5, 18.0, 17.5, 16.5, 15.0, 14.5, 12.5]  \n>>> topTenScores(listOf(5.0, 3.0, 4.0))  \n[5.0, 4.0, 3.0]",
      "de": "Schreiben Sie eine Kotlin-Funktion `fun topTenScores(scores: List<Double>): List<Double>`, um das folgende Problem zu lösen:\nGibt die zehn höchsten Punktzahlen aus einer gegebenen Liste von Punktzahlen zurück, sortiert in absteigender Reihenfolge.\nWenn es weniger als zehn Punktzahlen in der Liste gibt, werden alle Punktzahlen zurückgegeben.\nBeispiel:\n>>> topTenScores(listOf(12.5, 15.0, 9.5, 18.0, 22.0, 7.0, 14.5, 16.5, 17.5, 19.5, 20.5, 21.5))\n[22.0, 21.5, 20.5, 19.5, 18.0, 17.5, 16.5, 15.0, 14.5, 12.5]\n>>> topTenScores(listOf(5.0, 3.0, 4.0))\n[5.0, 4.0, 3.0]",
      "ha": "Rubuta aikin Kotlin `fun topTenScores(scores: List<Double>): List<Double>` don warware matsalar mai zuwa:  \nMayar da manyan maki goma daga jerin maki da aka bayar, an jera su cikin tsari mai sauka.  \nIdan akwai ƙasa da maki goma a cikin jerin, duk maki za a mayar da su.  \nMisali:  \n>>> topTenScores(listOf(12.5, 15.0, 9.5, 18.0, 22.0, 7.0, 14.5, 16.5, 17.5, 19.5, 20.5, 21.5))  \n[22.0, 21.5, 20.5, 19.5, 18.0, 17.5, 16.5, 15.0, 14.5, 12.5]  \n>>> topTenScores(listOf(5.0, 3.0, 4.0))  \n[5.0, 4.0, 3.0]",
      "hi": "Kotlin फ़ंक्शन `fun topTenScores(scores: List<Double>): List<Double>` लिखें ताकि निम्नलिखित समस्या का समाधान किया जा सके:\nदिए गए स्कोर की सूची से शीर्ष दस उच्चतम स्कोर लौटाता है, जो अवरोही क्रम में क्रमबद्ध होते हैं।\nयदि सूची में दस से कम स्कोर हैं, तो सभी स्कोर लौटाए जाते हैं।\nउदाहरण:\n>>> topTenScores(listOf(12.5, 15.0, 9.5, 18.0, 22.0, 7.0, 14.5, 16.5, 17.5, 19.5, 20.5, 21.5))\n[22.0, 21.5, 20.5, 19.5, 18.0, 17.5, 16.5, 15.0, 14.5, 12.5]\n>>> topTenScores(listOf(5.0, 3.0, 4.0))\n[5.0, 4.0, 3.0]",
      "hu": "Írj egy Kotlin függvényt `fun topTenScores(scores: List<Double>): List<Double>` a következő probléma megoldására:\nVisszaadja a tíz legmagasabb pontszámot a megadott pontszámok listájából, csökkenő sorrendben rendezve.\nHa kevesebb mint tíz pontszám van a listában, az összes pontszám visszaadásra kerül.\nPélda:\n>>> topTenScores(listOf(12.5, 15.0, 9.5, 18.0, 22.0, 7.0, 14.5, 16.5, 17.5, 19.5, 20.5, 21.5))\n[22.0, 21.5, 20.5, 19.5, 18.0, 17.5, 16.5, 15.0, 14.5, 12.5]\n>>> topTenScores(listOf(5.0, 3.0, 4.0))\n[5.0, 4.0, 3.0]"
    },
    "instruction_bertscore": {
      "sq": "0.9934805536336729",
      "hy": "0.9981759772109566",
      "bn": "0.9736866389027842",
      "bg": "0.9947349044899082",
      "zh": "0.9908804819459263",
      "fr": "0.9934805536336729",
      "de": "0.992541826452902",
      "ha": "0.9933476699087606",
      "hi": "0.9789318713747726",
      "hu": "0.9954320971273407"
    },
    "level": "easy",
    "test": "fun main(){\n    check(topTenScores(listOf(12.5, 15.0, 9.5, 18.0, 22.0, 7.0, 14.5, 16.5, 17.5, 19.5, 20.5, 21.5)) == listOf(22.0, 21.5, 20.5, 19.5, 18.0, 17.5, 16.5, 15.0, 14.5, 12.5))\n    check(topTenScores(listOf(5.0, 3.0, 4.0)) == listOf(5.0, 4.0, 3.0))\n    check(topTenScores(listOf(8.0, 7.5, 9.0, 10.0)) == listOf(10.0, 9.0, 8.0, 7.5))\n    check(topTenScores(listOf(1.0, 2.0, 3.0, 4.0, 5.0, 6.0, 7.0, 8.0, 9.0, 10.0, 11.0, 12.0)) == listOf(12.0, 11.0, 10.0, 9.0, 8.0, 7.0, 6.0, 5.0, 4.0, 3.0))\n    check(topTenScores(listOf(32.0, 31.5, 33.0, 30.0)) == listOf(33.0, 32.0, 31.5, 30.0))\n}\n\nmain()",
    "entry_point": "topTenScores",
    "signature": "fun topTenScores(scores: List<Double>): List<Double>",
    "docstring": {
      "en": "Returns the top ten highest scores from a given list of scores, sorted in descending order.\nIf there are fewer than ten scores in the list, all scores are returned.\nExample:\n>>> topTenScores(listOf(12.5, 15.0, 9.5, 18.0, 22.0, 7.0, 14.5, 16.5, 17.5, 19.5, 20.5, 21.5))\n[22.0, 21.5, 20.5, 19.5, 18.0, 17.5, 16.5, 15.0, 14.5, 12.5]\n>>> topTenScores(listOf(5.0, 3.0, 4.0))\n[5.0, 4.0, 3.0]",
      "sq": "Kthen dhjetë rezultatet më të larta nga një listë e dhënë e rezultateve, të renditura në rend zbritës. Nëse ka më pak se dhjetë rezultate në listë, kthehen të gjitha rezultatet.\nShembull:\n>>> topTenScores(listOf(12.5, 15.0, 9.5, 18.0, 22.0, 7.0, 14.5, 16.5, 17.5, 19.5, 20.5, 21.5))\n[22.0, 21.5, 20.5, 19.5, 18.0, 17.5, 16.5, 15.0, 14.5, 12.5]\n>>> topTenScores(listOf(5.0, 3.0, 4.0))\n[5.0, 4.0, 3.0]",
      "hy": "Վերադարձնում է տրված միավորների ցանկից տասը ամենաբարձր միավորները՝ դասավորված նվազման կարգով: Եթե ցանկում տասից պակաս միավորներ կան, վերադարձվում են բոլոր միավորները:\nՕրինակ:\n>>> topTenScores(listOf(12.5, 15.0, 9.5, 18.0, 22.0, 7.0, 14.5, 16.5, 17.5, 19.5, 20.5, 21.5))\n[22.0, 21.5, 20.5, 19.5, 18.0, 17.5, 16.5, 15.0, 14.5, 12.5]\n>>> topTenScores(listOf(5.0, 3.0, 4.0))\n[5.0, 4.0, 3.0]",
      "bn": "দেওয়া স্কোরের তালিকা থেকে শীর্ষ দশটি সর্বোচ্চ স্কোর ফেরত দেয়, অবতরণী ক্রমে সাজানো।\nযদি তালিকায় দশটির কম স্কোর থাকে, তবে সমস্ত স্কোর ফেরত দেওয়া হয়।\nউদাহরণ:  \n>>> topTenScores(listOf(12.5, 15.0, 9.5, 18.0, 22.0, 7.0, 14.5, 16.5, 17.5, 19.5, 20.5, 21.5))  \n[22.0, 21.5, 20.5, 19.5, 18.0, 17.5, 16.5, 15.0, 14.5, 12.5]  \n>>> topTenScores(listOf(5.0, 3.0, 4.0))  \n[5.0, 4.0, 3.0]  ",
      "bg": "Връща десетте най-високи резултата от даден списък с резултати, сортирани в низходящ ред. Ако в списъка има по-малко от десет резултата, се връщат всички резултати.  \nПример:  \n>>> topTenScores(listOf(12.5, 15.0, 9.5, 18.0, 22.0, 7.0, 14.5, 16.5, 17.5, 19.5, 20.5, 21.5))  \n[22.0, 21.5, 20.5, 19.5, 18.0, 17.5, 16.5, 15.0, 14.5, 12.5]  \n>>> topTenScores(listOf(5.0, 3.0, 4.0))  \n[5.0, 4.0, 3.0]",
      "zh": "返回给定分数列表中排名前十的最高分，按降序排列。\n如果列表中的分数少于十个，则返回所有分数。\n示例：\n>>> topTenScores(listOf(12.5, 15.0, 9.5, 18.0, 22.0, 7.0, 14.5, 16.5, 17.5, 19.5, 20.5, 21.5))\n[22.0, 21.5, 20.5, 19.5, 18.0, 17.5, 16.5, 15.0, 14.5, 12.5]\n>>> topTenScores(listOf(5.0, 3.0, 4.0))\n[5.0, 4.0, 3.0]",
      "fr": "Retourne les dix scores les plus élevés d'une liste donnée de scores, triés par ordre décroissant.  \nS'il y a moins de dix scores dans la liste, tous les scores sont retournés.  \nExemple:  \n>>> topTenScores(listOf(12.5, 15.0, 9.5, 18.0, 22.0, 7.0, 14.5, 16.5, 17.5, 19.5, 20.5, 21.5))  \n[22.0, 21.5, 20.5, 19.5, 18.0, 17.5, 16.5, 15.0, 14.5, 12.5]  \n>>> topTenScores(listOf(5.0, 3.0, 4.0))  \n[5.0, 4.0, 3.0]",
      "de": "Gibt die zehn höchsten Punktzahlen aus einer gegebenen Liste von Punktzahlen zurück, sortiert in absteigender Reihenfolge.\nWenn es weniger als zehn Punktzahlen in der Liste gibt, werden alle Punktzahlen zurückgegeben.\nBeispiel:\n>>> topTenScores(listOf(12.5, 15.0, 9.5, 18.0, 22.0, 7.0, 14.5, 16.5, 17.5, 19.5, 20.5, 21.5))\n[22.0, 21.5, 20.5, 19.5, 18.0, 17.5, 16.5, 15.0, 14.5, 12.5]\n>>> topTenScores(listOf(5.0, 3.0, 4.0))\n[5.0, 4.0, 3.0]",
      "ha": "Yana mayar da maki goma mafi girma daga jerin maki da aka bayar, an jera su a cikin tsari mai saukowa. Idan akwai maki kasa da goma a cikin jerin, duk maki za a mayar da su.\n\nMisali:\n>>> topTenScores(listOf(12.5, 15.0, 9.5, 18.0, 22.0, 7.0, 14.5, 16.5, 17.5, 19.5, 20.5, 21.5))\n[22.0, 21.5, 20.5, 19.5, 18.0, 17.5, 16.5, 15.0, 14.5, 12.5]\n>>> topTenScores(listOf(5.0, 3.0, 4.0))\n[5.0, 4.0, 3.0]",
      "hi": "दिए गए अंकों की सूची से शीर्ष दस उच्चतम स्कोर लौटाता है, जो अवरोही क्रम में क्रमबद्ध होते हैं। यदि सूची में दस से कम स्कोर हैं, तो सभी स्कोर लौटाए जाते हैं।  \nउदाहरण:\n>>> topTenScores(listOf(12.5, 15.0, 9.5, 18.0, 22.0, 7.0, 14.5, 16.5, 17.5, 19.5, 20.5, 21.5))\n[22.0, 21.5, 20.5, 19.5, 18.0, 17.5, 16.5, 15.0, 14.5, 12.5]\n>>> topTenScores(listOf(5.0, 3.0, 4.0))\n[5.0, 4.0, 3.0]",
      "hu": "Visszaadja a megadott pontszámok listájából a tíz legmagasabb pontszámot, csökkenő sorrendben rendezve.\nHa a listában kevesebb mint tíz pontszám van, az összes pontszám visszaadásra kerül.\nPélda:\n>>> topTenScores(listOf(12.5, 15.0, 9.5, 18.0, 22.0, 7.0, 14.5, 16.5, 17.5, 19.5, 20.5, 21.5))\n[22.0, 21.5, 20.5, 19.5, 18.0, 17.5, 16.5, 15.0, 14.5, 12.5]\n>>> topTenScores(listOf(5.0, 3.0, 4.0))\n[5.0, 4.0, 3.0]"
    },
    "docstring_bertscore": {
      "sq": "0.9929905324836599",
      "hy": "0.9908920025080262",
      "bn": "0.9029273464844398",
      "bg": "1",
      "zh": "0.9891325345928192",
      "fr": "0.9937931978534218",
      "de": "0.9937931978534218",
      "ha": "0.9917065857006503",
      "hi": "0.9938154444560977",
      "hu": "0.9972930651672566"
    }
  },
  {
    "task_id": "Kotlin/10",
    "prompt": {
      "en": "/**\n * Finds the element with the largest absolute value in a 3x4 matrix and returns its absolute value and indices.\n * If multiple elements have the same absolute value, the one with the smallest row index is returned,\n * and if there is still a tie, the one with the smallest column index is chosen.\n *\n * Example:\n * >>> findMaxAbsElement(arrayOf(arrayOf(-1, 2, 3, -4), arrayOf(5, -6, 7, 8), arrayOf(-9, 10, 11, 12)))\n *     Triple(12, 2, 3) // Absolute value 12 at row 2, column 3\n * >>> findMaxAbsElement(arrayOf(arrayOf(-4, -4, 3, 2), arrayOf(1, 0, -4, -4), arrayOf(2, 3, -4, 4)))\n *     Triple(4, 0, 0) // Absolute value 4 at row 0, column 0 (first occurrence)\n */\nfun findMaxAbsElement(matrix: Array<Array<Int>>): Triple<Int, Int, Int> ",
      "sq": "/**\n * Gjen elementin me vlerën absolute më të madhe në një matricë 3x4 dhe kthen vlerën e tij absolute dhe indekset.\n * Nëse disa elemente kanë të njëjtën vlerë absolute, kthehet ai me indeksin më të vogël të rreshtit,\n * dhe nëse ende ka barazim, zgjidhet ai me indeksin më të vogël të kolonës.\n *\n * Shembull:\n * >>> findMaxAbsElement(arrayOf(arrayOf(-1, 2, 3, -4), arrayOf(5, -6, 7, 8), arrayOf(-9, 10, 11, 12)))\n *     Triple(12, 2, 3) // Vlera absolute 12 në rreshtin 2, kolonën 3\n * >>> findMaxAbsElement(arrayOf(arrayOf(-4, -4, 3, 2), arrayOf(1, 0, -4, -4), arrayOf(2, 3, -4, 4)))\n *     Triple(4, 0, 0) // Vlera absolute 4 në rreshtin 0, kolonën 0 (para shfaqjes)\n */\nfun findMaxAbsElement(matrix: Array<Array<Int>>): Triple<Int, Int, Int> ",
      "hy": "/**\n * Գտնում է 3x4 մատրիցայում ամենամեծ բացարձակ արժեք ունեցող տարրը և վերադարձնում դրա բացարձակ արժեքը և ինդեքսները:\n * Եթե մի քանի տարրեր ունեն նույն բացարձակ արժեքը, վերադարձվում է այն, որը ունի ամենափոքր տողի ինդեքսը,\n * և եթե դեռ կա հավասարություն, ընտրվում է այն, որը ունի ամենափոքր սյունակի ինդեքսը:\n *\n * Օրինակ:\n * >>> findMaxAbsElement(arrayOf(arrayOf(-1, 2, 3, -4), arrayOf(5, -6, 7, 8), arrayOf(-9, 10, 11, 12)))\n *     Triple(12, 2, 3) // Բացարձակ արժեքը 12 է տող 2-ում, սյունակ 3-ում\n * >>> findMaxAbsElement(arrayOf(arrayOf(-4, -4, 3, 2), arrayOf(1, 0, -4, -4), arrayOf(2, 3, -4, 4)))\n *     Triple(4, 0, 0) // Բացարձակ արժեքը 4 է տող 0-ում, սյունակ 0-ում (առաջին հանդիպում)\n */\nfun findMaxAbsElement(matrix: Array<Array<Int>>): Triple<Int, Int, Int> ",
      "bn": "/**\n * একটি 3x4 ম্যাট্রিক্সে সর্বাধিক মানের উপাদান খুঁজে বের করে এবং এর পরম মান এবং সূচকগুলি প্রদান করে।\n * যদি একাধিক উপাদানের একই পরম মান থাকে, তাহলে যেটির সারির সূচক সবচেয়ে ছোট সেটি প্রদান করা হয়,\n * এবং যদি এখনও সমতা থাকে, তাহলে যেটির কলামের সূচক সবচেয়ে ছোট সেটি বেছে নেওয়া হয়।\n *\n * উদাহরণ:\n * >>> findMaxAbsElement(arrayOf(arrayOf(-1, 2, 3, -4), arrayOf(5, -6, 7, 8), arrayOf(-9, 10, 11, 12)))\n *     Triple(12, 2, 3) // পরম মান 12 সারি 2, কলাম 3-এ\n * >>> findMaxAbsElement(arrayOf(arrayOf(-4, -4, 3, 2), arrayOf(1, 0, -4, -4), arrayOf(2, 3, -4, 4)))\n *     Triple(4, 0, 0) // পরম মান 4 সারি 0, কলাম 0-এ (প্রথম উপস্থিতি)\n */\nfun findMaxAbsElement(matrix: Array<Array<Int>>): Triple<Int, Int, Int> ",
      "bg": "/**\n * Намира елемента с най-голяма абсолютна стойност в 3x4 матрица и връща неговата абсолютна стойност и индекси.\n * Ако няколко елемента имат една и съща абсолютна стойност, се връща този с най-малък индекс на ред,\n * и ако все още има равенство, се избира този с най-малък индекс на колона.\n *\n * Пример:\n * >>> findMaxAbsElement(arrayOf(arrayOf(-1, 2, 3, -4), arrayOf(5, -6, 7, 8), arrayOf(-9, 10, 11, 12)))\n *     Triple(12, 2, 3) // Абсолютна стойност 12 на ред 2, колона 3\n * >>> findMaxAbsElement(arrayOf(arrayOf(-4, -4, 3, 2), arrayOf(1, 0, -4, -4), arrayOf(2, 3, -4, 4)))\n *     Triple(4, 0, 0) // Абсолютна стойност 4 на ред 0, колона 0 (първо срещане)\n */\nfun findMaxAbsElement(matrix: Array<Array<Int>>): Triple<Int, Int, Int> ",
      "zh": "/**\n * 在一个3x4矩阵中找到绝对值最大的元素，并返回其绝对值和索引。\n * 如果多个元素具有相同的绝对值，则返回行索引最小的元素，\n * 如果仍然有平局，则选择列索引最小的元素。\n *\n * 示例:\n * >>> findMaxAbsElement(arrayOf(arrayOf(-1, 2, 3, -4), arrayOf(5, -6, 7, 8), arrayOf(-9, 10, 11, 12)))\n *     Triple(12, 2, 3) // 绝对值12在第2行，第3列\n * >>> findMaxAbsElement(arrayOf(arrayOf(-4, -4, 3, 2), arrayOf(1, 0, -4, -4), arrayOf(2, 3, -4, 4)))\n *     Triple(4, 0, 0) // 绝对值4在第0行，第0列（第一次出现）\n */\nfun findMaxAbsElement(matrix: Array<Array<Int>>): Triple<Int, Int, Int> ",
      "fr": "/**\n * Trouve l'élément avec la plus grande valeur absolue dans une matrice 3x4 et retourne sa valeur absolue et ses indices.\n * Si plusieurs éléments ont la même valeur absolue, celui avec le plus petit indice de ligne est retourné,\n * et s'il y a encore une égalité, celui avec le plus petit indice de colonne est choisi.\n *\n * Exemple :\n * >>> findMaxAbsElement(arrayOf(arrayOf(-1, 2, 3, -4), arrayOf(5, -6, 7, 8), arrayOf(-9, 10, 11, 12)))\n *     Triple(12, 2, 3) // Valeur absolue 12 à la ligne 2, colonne 3\n * >>> findMaxAbsElement(arrayOf(arrayOf(-4, -4, 3, 2), arrayOf(1, 0, -4, -4), arrayOf(2, 3, -4, 4)))\n *     Triple(4, 0, 0) // Valeur absolue 4 à la ligne 0, colonne 0 (première occurrence)\n */",
      "de": "/**\n * Findet das Element mit dem größten Absolutwert in einer 3x4-Matrix und gibt dessen Absolutwert und Indizes zurück.\n * Wenn mehrere Elemente denselben Absolutwert haben, wird das Element mit dem kleinsten Zeilenindex zurückgegeben,\n * und wenn es immer noch einen Gleichstand gibt, wird das Element mit dem kleinsten Spaltenindex gewählt.\n *\n * Beispiel:\n * >>> findMaxAbsElement(arrayOf(arrayOf(-1, 2, 3, -4), arrayOf(5, -6, 7, 8), arrayOf(-9, 10, 11, 12)))\n *     Triple(12, 2, 3) // Absolutwert 12 in Zeile 2, Spalte 3\n * >>> findMaxAbsElement(arrayOf(arrayOf(-4, -4, 3, 2), arrayOf(1, 0, -4, -4), arrayOf(2, 3, -4, 4)))\n *     Triple(4, 0, 0) // Absolutwert 4 in Zeile 0, Spalte 0 (erstes Vorkommen)\n */",
      "ha": "/**\n * Nemi abin da ke da mafi girman ƙimar duka a cikin matrix 3x4 kuma ya dawo da ƙimar duka da alamun.\n * Idan abubuwa da yawa suna da irin wannan ƙimar duka, wanda ke da ƙaramin alamar jere za a dawo da shi,\n * kuma idan har yanzu akwai daidaituwa, wanda ke da ƙaramin alamar ginshiƙi za a zaɓa.\n *\n * Misali:\n * >>> findMaxAbsElement(arrayOf(arrayOf(-1, 2, 3, -4), arrayOf(5, -6, 7, 8), arrayOf(-9, 10, 11, 12)))\n *     Triple(12, 2, 3) // Ƙimar duka 12 a jere na 2, ginshiƙi na 3\n * >>> findMaxAbsElement(arrayOf(arrayOf(-4, -4, 3, 2), arrayOf(1, 0, -4, -4), arrayOf(2, 3, -4, 4)))\n *     Triple(4, 0, 0) // Ƙimar duka 4 a jere na 0, ginshiƙi na 0 (farau)\n */\nfun findMaxAbsElement(matrix: Array<Array<Int>>): Triple<Int, Int, Int> ",
      "hi": "/**\n * 3x4 मैट्रिक्स में सबसे बड़े परिमाण मान वाले तत्व को खोजता है और उसके परिमाण मान और सूचकांक लौटाता है।\n * यदि कई तत्वों का परिमाण मान समान है, तो सबसे छोटे पंक्ति सूचकांक वाला तत्व लौटाया जाता है,\n * और यदि अभी भी टाई है, तो सबसे छोटे स्तंभ सूचकांक वाला तत्व चुना जाता है।\n *\n * उदाहरण:\n * >>> findMaxAbsElement(arrayOf(arrayOf(-1, 2, 3, -4), arrayOf(5, -6, 7, 8), arrayOf(-9, 10, 11, 12)))\n *     Triple(12, 2, 3) // पंक्ति 2, स्तंभ 3 पर परिमाण मान 12\n * >>> findMaxAbsElement(arrayOf(arrayOf(-4, -4, 3, 2), arrayOf(1, 0, -4, -4), arrayOf(2, 3, -4, 4)))\n *     Triple(4, 0, 0) // पंक्ति 0, स्तंभ 0 पर परिमाण मान 4 (पहली घटना)\n */\nfun findMaxAbsElement(matrix: Array<Array<Int>>): Triple<Int, Int, Int> ",
      "hu": "/**\n * Megkeresi a 3x4-es mátrixban a legnagyobb abszolút értékű elemet, és visszaadja annak abszolút értékét és indexeit.\n * Ha több elemnek azonos az abszolút értéke, akkor azt adja vissza, amelyiknek a sorindexe a legkisebb,\n * és ha még mindig döntetlen van, akkor azt, amelyiknek az oszlopindexe a legkisebb.\n *\n * Példa:\n * >>> findMaxAbsElement(arrayOf(arrayOf(-1, 2, 3, -4), arrayOf(5, -6, 7, 8), arrayOf(-9, 10, 11, 12)))\n *     Triple(12, 2, 3) // Abszolút érték 12 a 2. sorban, a 3. oszlopban\n * >>> findMaxAbsElement(arrayOf(arrayOf(-4, -4, 3, 2), arrayOf(1, 0, -4, -4), arrayOf(2, 3, -4, 4)))\n *     Triple(4, 0, 0) // Abszolút érték 4 a 0. sorban, a 0. oszlopban (első előfordulás)\n */\nfun findMaxAbsElement(matrix: Array<Array<Int>>): Triple<Int, Int, Int> "
    },
    "prompt_bertscore": {
      "sq": "0.998724395692994",
      "hy": "0.9944294109638766",
      "bn": "0.9905600911413169",
      "bg": "0.9995250747589456",
      "zh": "0.9784160282752249",
      "fr": "0.9628608858756208",
      "de": "0.9617155830985736",
      "ha": "0.9828623693546908",
      "hi": "0.9434485401067001",
      "hu": "0.9851454269543058"
    },
    "canonical_solution": "{\n    var maxVal = Int.MIN_VALUE\n    var maxRow = -1\n    var maxCol = -1\n\n    for (row in matrix.indices) {\n        for (col in matrix[row].indices) {\n            val absVal = Math.abs(matrix[row][col])\n            if (absVal > maxVal || (absVal == maxVal && (row < maxRow || (row == maxRow && col < maxCol)))) {\n                maxVal = absVal\n                maxRow = row\n                maxCol = col\n            }\n        }\n    }\n    return Triple(maxVal, maxRow, maxCol)\n}",
    "instruction": {
      "en": "Write a Kotlin function `fun findMaxAbsElement(matrix: Array<Array<Int>>): Triple<Int, Int, Int>` to solve the following problem:\nFinds the element with the largest absolute value in a 3x4 matrix and returns its absolute value and indices.\nIf multiple elements have the same absolute value, the one with the smallest row index is returned,\nand if there is still a tie, the one with the smallest column index is chosen.\n\nExample:\n>>> findMaxAbsElement(arrayOf(arrayOf(-1, 2, 3, -4), arrayOf(5, -6, 7, 8), arrayOf(-9, 10, 11, 12)))\nTriple(12, 2, 3) // Absolute value 12 at row 2, column 3\n>>> findMaxAbsElement(arrayOf(arrayOf(-4, -4, 3, 2), arrayOf(1, 0, -4, -4), arrayOf(2, 3, -4, 4)))\nTriple(4, 0, 0) // Absolute value 4 at row 0, column 0 (first occurrence)",
      "sq": "Shkruani një funksion Kotlin `fun findMaxAbsElement(matrix: Array<Array<Int>>): Triple<Int, Int, Int>` për të zgjidhur problemin në vijim:\nGjen elementin me vlerën më të madhe absolute në një matricë 3x4 dhe kthen vlerën e tij absolute dhe indeksat.\nNëse disa elemente kanë të njëjtën vlerë absolute, kthehet ai me indeksin më të vogël të rreshtit,\ndhe nëse ende ka barazim, zgjidhet ai me indeksin më të vogël të kolonës.\n\nShembull:\n>>> findMaxAbsElement(arrayOf(arrayOf(-1, 2, 3, -4), arrayOf(5, -6, 7, 8), arrayOf(-9, 10, 11, 12)))\nTriple(12, 2, 3) // Vlera absolute 12 në rreshtin 2, kolonën 3\n>>> findMaxAbsElement(arrayOf(arrayOf(-4, -4, 3, 2), arrayOf(1, 0, -4, -4), arrayOf(2, 3, -4, 4)))\nTriple(4, 0, 0) // Vlera absolute 4 në rreshtin 0, kolonën 0 (para shfaqjes)",
      "hy": "Գրեք Kotlin ֆունկցիա `fun findMaxAbsElement(matrix: Array<Array<Int>>): Triple<Int, Int, Int>` հետևյալ խնդիրը լուծելու համար:\nԳտնում է 3x4 մատրիցի ամենամեծ բացարձակ արժեքով տարրը և վերադարձնում դրա բացարձակ արժեքը և ինդեքսները։\nԵթե մի քանի տարր ունեն նույն բացարձակ արժեքը, վերադարձվում է այն, որը ունի ամենափոքր տողի ինդեքսը,\nև եթե դեռ կա հավասարություն, ընտրվում է այն, որը ունի ամենափոքր սյունակի ինդեքսը։\n\nՕրինակ:\n>>> findMaxAbsElement(arrayOf(arrayOf(-1, 2, 3, -4), arrayOf(5, -6, 7, 8), arrayOf(-9, 10, 11, 12)))\nTriple(12, 2, 3) // Բացարձակ արժեքը 12 տող 2, սյունակ 3\n>>> findMaxAbsElement(arrayOf(arrayOf(-4, -4, 3, 2), arrayOf(1, 0, -4, -4), arrayOf(2, 3, -4, 4)))\nTriple(4, 0, 0) // Բացարձակ արժեքը 4 տող 0, սյունակ 0 (առաջին հանդիպում)",
      "bn": "Kotlin ফাংশন `fun findMaxAbsElement(matrix: Array<Array<Int>>): Triple<Int, Int, Int>` লিখুন নিম্নলিখিত সমস্যার সমাধানের জন্য:\nএকটি 3x4 ম্যাট্রিক্সে সর্বাধিক মানের উপাদান খুঁজে বের করে এবং এর মান এবং সূচকগুলি ফেরত দেয়।\nযদি একাধিক উপাদানের একই মান থাকে, তবে ছোটতম সারি সূচক সহ উপাদানটি ফেরত দেওয়া হয়,\nএবং যদি এখনও সমতা থাকে, তবে ছোটতম কলাম সূচক সহ উপাদানটি বেছে নেওয়া হয়।\n\nউদাহরণ:\n>>> findMaxAbsElement(arrayOf(arrayOf(-1, 2, 3, -4), arrayOf(5, -6, 7, 8), arrayOf(-9, 10, 11, 12)))\nTriple(12, 2, 3) // সারি 2, কলাম 3 এ মান 12\n>>> findMaxAbsElement(arrayOf(arrayOf(-4, -4, 3, 2), arrayOf(1, 0, -4, -4), arrayOf(2, 3, -4, 4)))\nTriple(4, 0, 0) // সারি 0, কলাম 0 এ মান 4 (প্রথম উপস্থিতি)",
      "bg": "Напишете Kotlin функция `fun findMaxAbsElement(matrix: Array<Array<Int>>): Triple<Int, Int, Int>`, за да решите следния проблем:\nНамира елемента с най-голяма абсолютна стойност в 3x4 матрица и връща неговата абсолютна стойност и индекси.\nАко няколко елемента имат една и съща абсолютна стойност, се връща този с най-малък индекс на реда,\nи ако все още има равенство, се избира този с най-малък индекс на колоната.\n\nПример:\n>>> findMaxAbsElement(arrayOf(arrayOf(-1, 2, 3, -4), arrayOf(5, -6, 7, 8), arrayOf(-9, 10, 11, 12)))\nTriple(12, 2, 3) // Абсолютна стойност 12 на ред 2, колона 3\n>>> findMaxAbsElement(arrayOf(arrayOf(-4, -4, 3, 2), arrayOf(1, 0, -4, -4), arrayOf(2, 3, -4, 4)))\nTriple(4, 0, 0) // Абсолютна стойност 4 на ред 0, колона 0 (първо срещане)",
      "zh": "编写一个 Kotlin 函数 `fun findMaxAbsElement(matrix: Array<Array<Int>>): Triple<Int, Int, Int>` 来解决以下问题：\n在一个 3x4 矩阵中找到绝对值最大的元素，并返回其绝对值及其索引。\n如果多个元素具有相同的绝对值，则返回行索引最小的那个，\n如果仍然有平局，则选择列索引最小的那个。\n\n示例:\n>>> findMaxAbsElement(arrayOf(arrayOf(-1, 2, 3, -4), arrayOf(5, -6, 7, 8), arrayOf(-9, 10, 11, 12)))\nTriple(12, 2, 3) // 绝对值 12 在第 2 行，第 3 列\n>>> findMaxAbsElement(arrayOf(arrayOf(-4, -4, 3, 2), arrayOf(1, 0, -4, -4), arrayOf(2, 3, -4, 4)))\nTriple(4, 0, 0) // 绝对值 4 在第 0 行，第 0 列（首次出现）",
      "fr": "Écrire une fonction Kotlin `fun findMaxAbsElement(matrix: Array<Array<Int>>): Triple<Int, Int, Int>` pour résoudre le problème suivant :\nTrouve l'élément avec la plus grande valeur absolue dans une matrice 3x4 et renvoie sa valeur absolue et ses indices.\nSi plusieurs éléments ont la même valeur absolue, celui avec le plus petit indice de ligne est retourné,\net s'il y a encore une égalité, celui avec le plus petit indice de colonne est choisi.\n\nExemple :\n>>> findMaxAbsElement(arrayOf(arrayOf(-1, 2, 3, -4), arrayOf(5, -6, 7, 8), arrayOf(-9, 10, 11, 12)))\nTriple(12, 2, 3) // Valeur absolue 12 à la ligne 2, colonne 3\n>>> findMaxAbsElement(arrayOf(arrayOf(-4, -4, 3, 2), arrayOf(1, 0, -4, -4), arrayOf(2, 3, -4, 4)))\nTriple(4, 0, 0) // Valeur absolue 4 à la ligne 0, colonne 0 (première occurrence)",
      "de": "Schreiben Sie eine Kotlin-Funktion `fun findMaxAbsElement(matrix: Array<Array<Int>>): Triple<Int, Int, Int>`, um das folgende Problem zu lösen:\nFindet das Element mit dem größten absoluten Wert in einer 3x4-Matrix und gibt dessen absoluten Wert und Indizes zurück.\nWenn mehrere Elemente denselben absoluten Wert haben, wird das Element mit dem kleinsten Zeilenindex zurückgegeben,\nund wenn es immer noch ein Unentschieden gibt, wird das Element mit dem kleinsten Spaltenindex gewählt.\n\nBeispiel:\n>>> findMaxAbsElement(arrayOf(arrayOf(-1, 2, 3, -4), arrayOf(5, -6, 7, 8), arrayOf(-9, 10, 11, 12)))\nTriple(12, 2, 3) // Absoluter Wert 12 in Zeile 2, Spalte 3\n>>> findMaxAbsElement(arrayOf(arrayOf(-4, -4, 3, 2), arrayOf(1, 0, -4, -4), arrayOf(2, 3, -4, 4)))\nTriple(4, 0, 0) // Absoluter Wert 4 in Zeile 0, Spalte 0 (erstes Vorkommen)",
      "ha": "Rubuta aikin Kotlin `fun findMaxAbsElement(matrix: Array<Array<Int>>): Triple<Int, Int, Int>` don warware matsalar mai zuwa:\nNemi abin da ke da mafi girman ƙimar duka a cikin matrix 3x4 kuma mayar da ƙimar duka da alamun.\nIdan abubuwa da yawa suna da wannan ƙimar duka, wanda ke da ƙaramin index na layi za a mayar,\nkuma idan har yanzu akwai daidaituwa, wanda ke da ƙaramin index na ginshiƙi za a zaɓa.\n\nMisali:\n>>> findMaxAbsElement(arrayOf(arrayOf(-1, 2, 3, -4), arrayOf(5, -6, 7, 8), arrayOf(-9, 10, 11, 12)))\nTriple(12, 2, 3) // Mafi girman ƙimar duka 12 a layi na 2, ginshiƙi na 3\n>>> findMaxAbsElement(arrayOf(arrayOf(-4, -4, 3, 2), arrayOf(1, 0, -4, -4), arrayOf(2, 3, -4, 4)))\nTriple(4, 0, 0) // Mafi girman ƙimar duka 4 a layi na 0, ginshiƙi na 0 (farin faruwa)",
      "hi": "Kotlin फ़ंक्शन `fun findMaxAbsElement(matrix: Array<Array<Int>>): Triple<Int, Int, Int>` लिखें ताकि निम्नलिखित समस्या का समाधान किया जा सके:\n3x4 मैट्रिक्स में सबसे बड़े परिमाण वाले तत्व को खोजें और उसके परिमाण और सूचकांक लौटाएं।\nयदि कई तत्वों का परिमाण समान है, तो सबसे छोटे पंक्ति सूचकांक वाला तत्व लौटाया जाता है,\nऔर यदि अभी भी टाई है, तो सबसे छोटे स्तंभ सूचकांक वाला तत्व चुना जाता है।\n\nउदाहरण:\n>>> findMaxAbsElement(arrayOf(arrayOf(-1, 2, 3, -4), arrayOf(5, -6, 7, 8), arrayOf(-9, 10, 11, 12)))\nTriple(12, 2, 3) // परिमाण 12 पंक्ति 2, स्तंभ 3 पर\n>>> findMaxAbsElement(arrayOf(arrayOf(-4, -4, 3, 2), arrayOf(1, 0, -4, -4), arrayOf(2, 3, -4, 4)))\nTriple(4, 0, 0) // परिमाण 4 पंक्ति 0, स्तंभ 0 पर (पहली घटना)",
      "hu": "Írj egy Kotlin függvényt `fun findMaxAbsElement(matrix: Array<Array<Int>>): Triple<Int, Int, Int>` a következő probléma megoldására:\nMegkeresi a legnagyobb abszolút értékű elemet egy 3x4-es mátrixban, és visszaadja annak abszolút értékét és indexeit.\nHa több elemnek is ugyanaz az abszolút értéke, akkor azt adja vissza, amelyiknek a sorindexe a legkisebb,\nés ha még mindig döntetlen van, akkor azt, amelyiknek az oszlopindexe a legkisebb.\n\nPélda:\n>>> findMaxAbsElement(arrayOf(arrayOf(-1, 2, 3, -4), arrayOf(5, -6, 7, 8), arrayOf(-9, 10, 11, 12)))\nTriple(12, 2, 3) // Az abszolút érték 12 a 2. sorban, a 3. oszlopban\n>>> findMaxAbsElement(arrayOf(arrayOf(-4, -4, 3, 2), arrayOf(1, 0, -4, -4), arrayOf(2, 3, -4, 4)))\nTriple(4, 0, 0) // Az abszolút érték 4 a 0. sorban, a 0. oszlopban (első előfordulás)"
    },
    "instruction_bertscore": {
      "sq": "0.9986779161838318",
      "hy": "0.991636469176145",
      "bn": "0.9600027933229097",
      "bg": "0.9986135599403765",
      "zh": "0.9832544657268537",
      "fr": "0.9963670503308719",
      "de": "0.9944737055388473",
      "ha": "0.9679207962021035",
      "hi": "0.950576192699756",
      "hu": "0.9619418231025724"
    },
    "level": "middle",
    "test": "fun main() {\n    check(findMaxAbsElement(arrayOf(arrayOf(-1, 2, 3, -4), arrayOf(5, -6, 7, 8), arrayOf(-9, 10, 11, 12))) == Triple(12, 2, 3))\n    check(findMaxAbsElement(arrayOf(arrayOf(-4, -4, 3, 2), arrayOf(1, 0, -4, -4), arrayOf(2, 3, -4, 4))) == Triple(4, 0, 0))\n    check(findMaxAbsElement(arrayOf(arrayOf(1, -2, 3, -4), arrayOf(0, 6, -7, 8), arrayOf(9, -10, -11, -12))) == Triple(12, 2, 3))\n    check(findMaxAbsElement(arrayOf(arrayOf(4, 4, -3, -2), arrayOf(-1, 0, 4, 4), arrayOf(-2, -3, 4, -4))) == Triple(4, 0, 0))\n    check(findMaxAbsElement(arrayOf(arrayOf(0, 0, 0, 0), arrayOf(0, 0, 0, 0), arrayOf(0, 0, 0, 0))) == Triple(0, 0, 0))\n}\nmain()",
    "entry_point": "findMaxAbsElement",
    "signature": "fun findMaxAbsElement(matrix: Array<Array<Int>>): Triple<Int, Int, Int>",
    "docstring": {
      "en": "Finds the element with the largest absolute value in a 3x4 matrix and returns its absolute value and indices.\nIf multiple elements have the same absolute value, the one with the smallest row index is returned,\nand if there is still a tie, the one with the smallest column index is chosen.\n\nExample:\n>>> findMaxAbsElement(arrayOf(arrayOf(-1, 2, 3, -4), arrayOf(5, -6, 7, 8), arrayOf(-9, 10, 11, 12)))\nTriple(12, 2, 3) // Absolute value 12 at row 2, column 3\n>>> findMaxAbsElement(arrayOf(arrayOf(-4, -4, 3, 2), arrayOf(1, 0, -4, -4), arrayOf(2, 3, -4, 4)))\nTriple(4, 0, 0) // Absolute value 4 at row 0, column 0 (first occurrence)",
      "sq": "Gjen elementin me vlerën më të madhe absolute në një matricë 3x4 dhe kthen vlerën e tij absolute dhe indeksat.\nNëse disa elemente kanë të njëjtën vlerë absolute, kthehet ai me indeksin më të vogël të rreshtit,\ndhe nëse ende ka barazim, zgjidhet ai me indeksin më të vogël të kolonës.\n\nShembull:\n>>> findMaxAbsElement(arrayOf(arrayOf(-1, 2, 3, -4), arrayOf(5, -6, 7, 8), arrayOf(-9, 10, 11, 12)))\nTriple(12, 2, 3) // Vlera absolute 12 në rreshtin 2, kolona 3\n>>> findMaxAbsElement(arrayOf(arrayOf(-4, -4, 3, 2), arrayOf(1, 0, -4, -4), arrayOf(2, 3, -4, 4)))\nTriple(4, 0, 0) // Vlera absolute 4 në rreshtin 0, kolona 0 (para shfaqjes)",
      "hy": "Գտնում է 3x4 մատրիցայում ամենամեծ բացարձակ արժեք ունեցող տարրը և վերադարձնում դրա բացարձակ արժեքը և ինդեքսները։ Եթե մի քանի տարրեր ունեն նույն բացարձակ արժեքը, վերադարձվում է այն, որը ունի ամենափոքր տողի ինդեքսը, և եթե դեռ հավասարություն կա, ընտրվում է այն, որը ունի ամենափոքր սյունակի ինդեքսը։\n\nՕրինակ:\n>>> findMaxAbsElement(arrayOf(arrayOf(-1, 2, 3, -4), arrayOf(5, -6, 7, 8), arrayOf(-9, 10, 11, 12)))\nTriple(12, 2, 3) // Բացարձակ արժեքը 12 է տող 2-ում, սյունակ 3-ում\n>>> findMaxAbsElement(arrayOf(arrayOf(-4, -4, 3, 2), arrayOf(1, 0, -4, -4), arrayOf(2, 3, -4, 4)))\nTriple(4, 0, 0) // Բացարձակ արժեքը 4 է տող 0-ում, սյունակ 0-ում (առաջին հանդիպում)",
      "bn": "3x4 ম্যাট্রিক্সে সর্বাধিক মানের উপাদান খুঁজে বের করে এবং এর মান এবং সূচকগুলি প্রদান করে। \nযদি একাধিক উপাদানের একই মান থাকে, তবে যেটির সারি সূচক সবচেয়ে ছোট সেটি প্রদান করা হয়, \nএবং যদি এখনও সমতা থাকে, তবে যেটির কলাম সূচক সবচেয়ে ছোট সেটি বেছে নেওয়া হয়।\n\nউদাহরণ:\n>>> findMaxAbsElement(arrayOf(arrayOf(-1, 2, 3, -4), arrayOf(5, -6, 7, 8), arrayOf(-9, 10, 11, 12)))\nTriple(12, 2, 3) // সারি 2, কলাম 3 এ মান 12\n>>> findMaxAbsElement(arrayOf(arrayOf(-4, -4, 3, 2), arrayOf(1, 0, -4, -4), arrayOf(2, 3, -4, 4)))\nTriple(4, 0, 0) // সারি 0, কলাম 0 এ মান 4 (প্রথম উপস্থিতি)",
      "bg": "Намира елемента с най-голяма абсолютна стойност в 3x4 матрица и връща неговата абсолютна стойност и индекси. Ако няколко елемента имат една и съща абсолютна стойност, се връща този с най-малък индекс на реда, и ако все още има равенство, се избира този с най-малък индекс на колоната.\n\nПример:\n>>> findMaxAbsElement(arrayOf(arrayOf(-1, 2, 3, -4), arrayOf(5, -6, 7, 8), arrayOf(-9, 10, 11, 12)))\nTriple(12, 2, 3) // Абсолютна стойност 12 на ред 2, колона 3\n>>> findMaxAbsElement(arrayOf(arrayOf(-4, -4, 3, 2), arrayOf(1, 0, -4, -4), arrayOf(2, 3, -4, 4)))\nTriple(4, 0, 0) // Абсолютна стойност 4 на ред 0, колона 0 (първо срещане)",
      "zh": "在一个3x4矩阵中查找绝对值最大的元素，并返回其绝对值和索引。\n如果多个元素具有相同的绝对值，则返回行索引最小的那个，\n如果仍然有平局，则选择列索引最小的那个。\n\n示例：\n>>> findMaxAbsElement(arrayOf(arrayOf(-1, 2, 3, -4), arrayOf(5, -6, 7, 8), arrayOf(-9, 10, 11, 12)))\nTriple(12, 2, 3) // 绝对值12在第2行，第3列\n>>> findMaxAbsElement(arrayOf(arrayOf(-4, -4, 3, 2), arrayOf(1, 0, -4, -4), arrayOf(2, 3, -4, 4)))\nTriple(4, 0, 0) // 绝对值4在第0行，第0列（首次出现）",
      "fr": "Trouve l'élément avec la plus grande valeur absolue dans une matrice 3x4 et renvoie sa valeur absolue et ses indices.\nSi plusieurs éléments ont la même valeur absolue, celui avec le plus petit indice de ligne est renvoyé,\net s'il y a encore une égalité, celui avec le plus petit indice de colonne est choisi.\n\nExemple :\n>>> findMaxAbsElement(arrayOf(arrayOf(-1, 2, 3, -4), arrayOf(5, -6, 7, 8), arrayOf(-9, 10, 11, 12)))\nTriple(12, 2, 3) // Valeur absolue 12 à la ligne 2, colonne 3\n>>> findMaxAbsElement(arrayOf(arrayOf(-4, -4, 3, 2), arrayOf(1, 0, -4, -4), arrayOf(2, 3, -4, 4)))\nTriple(4, 0, 0) // Valeur absolue 4 à la ligne 0, colonne 0 (première occurrence)",
      "de": "Findet das Element mit dem größten Absolutwert in einer 3x4-Matrix und gibt dessen Absolutwert und Indizes zurück. Wenn mehrere Elemente den gleichen Absolutwert haben, wird das mit dem kleinsten Zeilenindex zurückgegeben, und wenn es immer noch einen Gleichstand gibt, wird das mit dem kleinsten Spaltenindex gewählt.\n\nBeispiel:\n>>> findMaxAbsElement(arrayOf(arrayOf(-1, 2, 3, -4), arrayOf(5, -6, 7, 8), arrayOf(-9, 10, 11, 12)))\nTriple(12, 2, 3) // Absolutwert 12 in Zeile 2, Spalte 3\n>>> findMaxAbsElement(arrayOf(arrayOf(-4, -4, 3, 2), arrayOf(1, 0, -4, -4), arrayOf(2, 3, -4, 4)))\nTriple(4, 0, 0) // Absolutwert 4 in Zeile 0, Spalte 0 (erstes Vorkommen)",
      "ha": "Nemo abin da ke da mafi girman darajar duka a cikin matrix 3x4 kuma ya dawo da darajar duka da alamun sa.\nIdan abubuwa da yawa suna da irin wannan darajar duka, wanda ke da ƙaramin alamar jere ake dawowa,\nkuma idan har yanzu akwai daidaito, wanda ke da ƙaramin alamar ginshiƙi ake zaɓa.\n\nMisali:\n>>> findMaxAbsElement(arrayOf(arrayOf(-1, 2, 3, -4), arrayOf(5, -6, 7, 8), arrayOf(-9, 10, 11, 12)))\nTriple(12, 2, 3) // Darajar duka 12 a jere na 2, ginshiƙi na 3\n>>> findMaxAbsElement(arrayOf(arrayOf(-4, -4, 3, 2), arrayOf(1, 0, -4, -4), arrayOf(2, 3, -4, 4)))\nTriple(4, 0, 0) // Darajar duka 4 a jere na 0, ginshiƙi na 0 (farawa)",
      "hi": "3x4 मैट्रिक्स में सबसे बड़े परिमाण वाले तत्व को खोजता है और उसके परिमाण और सूचकांक को लौटाता है। यदि कई तत्वों का परिमाण समान है, तो सबसे छोटे पंक्ति सूचकांक वाला तत्व लौटाया जाता है, और यदि अभी भी टाई है, तो सबसे छोटे स्तंभ सूचकांक वाला तत्व चुना जाता है।\n\nउदाहरण:\n>>> findMaxAbsElement(arrayOf(arrayOf(-1, 2, 3, -4), arrayOf(5, -6, 7, 8), arrayOf(-9, 10, 11, 12)))\nTriple(12, 2, 3) // पंक्ति 2, स्तंभ 3 पर परिमाण 12\n>>> findMaxAbsElement(arrayOf(arrayOf(-4, -4, 3, 2), arrayOf(1, 0, -4, -4), arrayOf(2, 3, -4, 4)))\nTriple(4, 0, 0) // पंक्ति 0, स्तंभ 0 पर परिमाण 4 (पहली घटना)",
      "hu": "Megkeresi a legnagyobb abszolút értékű elemet egy 3x4-es mátrixban, és visszaadja annak abszolút értékét és indexeit. Ha több elemnek azonos az abszolút értéke, akkor a legkisebb sorindexű kerül visszaadásra, és ha még mindig döntetlen van, akkor a legkisebb oszlopindexű kerül kiválasztásra.\n\nPélda:\n>>> findMaxAbsElement(arrayOf(arrayOf(-1, 2, 3, -4), arrayOf(5, -6, 7, 8), arrayOf(-9, 10, 11, 12)))\nTriple(12, 2, 3) // Abszolút érték 12 a 2. sorban, a 3. oszlopban\n>>> findMaxAbsElement(arrayOf(arrayOf(-4, -4, 3, 2), arrayOf(1, 0, -4, -4), arrayOf(2, 3, -4, 4)))\nTriple(4, 0, 0) // Abszolút érték 4 a 0. sorban, a 0. oszlopban (első előfordulás)"
    },
    "docstring_bertscore": {
      "sq": "0.9768673071942959",
      "hy": "0.9866282027487313",
      "bn": "0.9490612387836029",
      "bg": "0.999999801369619",
      "zh": "0.9769366291972771",
      "fr": "0.9948554731311964",
      "de": "0.9983781829388502",
      "ha": "0.9833154452538314",
      "hi": "0.9572644748899628",
      "hu": "0.9975218873662087"
    }
  },
  {
    "task_id": "Kotlin/11",
    "prompt": {
      "en": "/**\n    * Calculates the total savings accumulated over a period of months with monthly deposits and a fixed interest rate.\n    * The interest is compounded monthly based on the total amount in the account at the end of each month.\n    Example:\n    >>> calculateSavingsInterest(1000.0, 0.01, 6)  // 1000 monthly deposit, 1% monthly interest, over 6 months\n        6213.54\n    >>> calculateSavingsInterest(500.0, 0.02, 12)  // 500 monthly deposit, 2% monthly interest, over 12 months\n        6840.17\n**/\n\nfun calculateSavingsInterest(monthlyDeposit: Double, interestRate: Double, months: Int): Double ",
      "sq": "/**\n    * Llogarit kursimet totale të akumuluara gjatë një periudhe muajsh me depozita mujore dhe një normë interesi fikse.\n    * Interesi kapitalizohet çdo muaj bazuar në shumën totale në llogari në fund të çdo muaji.\n    Shembull:\n    >>> calculateSavingsInterest(1000.0, 0.01, 6)  // 1000 depozitë mujore, 1% interes mujor, për 6 muaj\n        6213.54\n    >>> calculateSavingsInterest(500.0, 0.02, 12)  // 500 depozitë mujore, 2% interes mujor, për 12 muaj\n        6840.17\n**/",
      "hy": "/**\n    * Հաշվում է ընդհանուր խնայողությունները, որոնք կուտակվել են ամիսների ընթացքում ամսական ավանդներով և ֆիքսված տոկոսադրույքով:\n    * Տոկոսադրույքը հաշվարկվում է ամսական՝ հաշվի վերջնական գումարի հիման վրա յուրաքանչյուր ամսվա վերջում:\n    Օրինակ:\n    >>> calculateSavingsInterest(1000.0, 0.01, 6)  // 1000 ամսական ավանդ, 1% ամսական տոկոսադրույք, 6 ամիսների ընթացքում\n        6213.54\n    >>> calculateSavingsInterest(500.0, 0.02, 12)  // 500 ամսական ավանդ, 2% ամսական տոկոսադրույք, 12 ամիսների ընթացքում\n        6840.17\n**/",
      "bn": "/**\n    * মাসিক আমানত এবং একটি নির্দিষ্ট সুদের হারের সাথে মাসগুলির একটি সময়কালে জমাকৃত মোট সঞ্চয় হিসাব করে।\n    * প্রতিটি মাসের শেষে অ্যাকাউন্টে থাকা মোট পরিমাণের ভিত্তিতে সুদ মাসিকভাবে যৌগিক হয়।\n    উদাহরণ:\n    >>> calculateSavingsInterest(1000.0, 0.01, 6)  // 1000 মাসিক আমানত, 1% মাসিক সুদ, 6 মাস ধরে\n        6213.54\n    >>> calculateSavingsInterest(500.0, 0.02, 12)  // 500 মাসিক আমানত, 2% মাসিক সুদ, 12 মাস ধরে\n        6840.17\n**/",
      "bg": "/**\n    * Изчислява общите спестявания, натрупани за период от месеци с месечни депозити и фиксиран лихвен процент.\n    * Лихвата се капитализира месечно въз основа на общата сума в сметката в края на всеки месец.\n    Пример:\n    >>> calculateSavingsInterest(1000.0, 0.01, 6)  // 1000 месечен депозит, 1% месечна лихва, за 6 месеца\n        6213.54\n    >>> calculateSavingsInterest(500.0, 0.02, 12)  // 500 месечен депозит, 2% месечна лихва, за 12 месеца\n        6840.17\n**/",
      "zh": "/**\n    * 计算在一段月份内通过每月存款和固定利率累积的总储蓄。\n    * 利息是基于每月底账户中的总金额按月复利计算的。\n    示例:\n    >>> calculateSavingsInterest(1000.0, 0.01, 6)  // 每月存款1000，月利率1%，持续6个月\n        6213.54\n    >>> calculateSavingsInterest(500.0, 0.02, 12)  // 每月存款500，月利率2%，持续12个月\n        6840.17\n**/",
      "fr": "/**\n    * Calcule l'épargne totale accumulée sur une période de mois avec des dépôts mensuels et un taux d'intérêt fixe.\n    * L'intérêt est composé mensuellement en fonction du montant total sur le compte à la fin de chaque mois.\n    Exemple :\n    >>> calculateSavingsInterest(1000.0, 0.01, 6)  // dépôt mensuel de 1000, intérêt mensuel de 1 %, sur 6 mois\n        6213.54\n    >>> calculateSavingsInterest(500.0, 0.02, 12)  // dépôt mensuel de 500, intérêt mensuel de 2 %, sur 12 mois\n        6840.17\n**/",
      "de": "/**\n    * Berechnet die gesamten Ersparnisse, die über einen Zeitraum von Monaten mit monatlichen Einzahlungen und einem festen Zinssatz angesammelt werden.\n    * Die Zinsen werden monatlich auf der Grundlage des Gesamtbetrags auf dem Konto am Ende jedes Monats aufgezinst.\n    Beispiel:\n    >>> calculateSavingsInterest(1000.0, 0.01, 6)  // 1000 monatliche Einzahlung, 1% monatliche Zinsen, über 6 Monate\n        6213.54\n    >>> calculateSavingsInterest(500.0, 0.02, 12)  // 500 monatliche Einzahlung, 2% monatliche Zinsen, über 12 Monate\n        6840.17\n**/\n\nfun calculateSavingsInterest(monthlyDeposit: Double, interestRate: Double, months: Int): Double ",
      "ha": "/**\n    * Lissafin jimillar ajiyar da aka tara a tsawon watanni tare da ajiyar kudi na wata-wata da kuma kudi mai tsayayyen riba.\n    * Ana tara ribar a kowane wata bisa ga jimillar adadin da ke cikin asusun a ƙarshen kowane wata.\n    Misali:\n    >>> calculateSavingsInterest(1000.0, 0.01, 6)  // 1000 ajiyar wata-wata, 1% ribar wata-wata, a tsawon watanni 6\n        6213.54\n    >>> calculateSavingsInterest(500.0, 0.02, 12)  // 500 ajiyar wata-wata, 2% ribar wata-wata, a tsawon watanni 12\n        6840.17\n**/",
      "hi": "/**\n    * मासिक जमा और एक निश्चित ब्याज दर के साथ महीनों की अवधि में संचित कुल बचत की गणना करता है।\n    * प्रत्येक महीने के अंत में खाते में कुल राशि के आधार पर ब्याज मासिक रूप से संयोजित होता है।\n    उदाहरण:\n    >>> calculateSavingsInterest(1000.0, 0.01, 6)  // 1000 मासिक जमा, 1% मासिक ब्याज, 6 महीनों में\n        6213.54\n    >>> calculateSavingsInterest(500.0, 0.02, 12)  // 500 मासिक जमा, 2% मासिक ब्याज, 12 महीनों में\n        6840.17\n**/ \n\nfun calculateSavingsInterest(monthlyDeposit: Double, interestRate: Double, months: Int): Double ",
      "hu": "/**\n    * Kiszámítja a teljes megtakarítást, amely hónapok során halmozódik fel havi befizetésekkel és fix kamatlábbal.\n    * A kamat havonta tőkésítődik a hónap végén a számlán lévő teljes összeg alapján.\n    Példa:\n    >>> calculateSavingsInterest(1000.0, 0.01, 6)  // 1000 havi befizetés, 1% havi kamat, 6 hónap alatt\n        6213.54\n    >>> calculateSavingsInterest(500.0, 0.02, 12)  // 500 havi befizetés, 2% havi kamat, 12 hónap alatt\n        6840.17\n**/\n\nfun calculateSavingsInterest(monthlyDeposit: Double, interestRate: Double, months: Int): Double "
    },
    "prompt_bertscore": {
      "sq": "0.9388657399554632",
      "hy": "0.9203533884430116",
      "bn": "0.9423199222816598",
      "bg": "0.945139281910069",
      "zh": "0.9186523178598288",
      "fr": "0.9293406186633161",
      "de": "0.951020131601369",
      "ha": "0.9234957210709835",
      "hi": "0.9946053974814735",
      "hu": "0.9322020879325047"
    },
    "canonical_solution": "{\n    var total = 0.0\n    for (i in 1..months) {\n        total += monthlyDeposit\n        total += total * interestRate\n    }\n    println(String.format(\"%.2f\", total).toDouble())\n    return String.format(\"%.2f\", total).toDouble()\n}",
    "instruction": {
      "en": "Write a Kotlin function `fun calculateSavingsInterest(monthlyDeposit: Double, interestRate: Double, months: Int): Double` to solve the following problem:\nCalculates the total savings accumulated over a period of months with monthly deposits and a fixed interest rate.\nThe interest is compounded monthly based on the total amount in the account at the end of each month.\nExample:\n>>> calculateSavingsInterest(1000.0, 0.01, 6)  // 1000 monthly deposit, 1% monthly interest, over 6 months\n6213.54\n>>> calculateSavingsInterest(500.0, 0.02, 12)  // 500 monthly deposit, 2% monthly interest, over 12 months\n6840.17",
      "sq": "Shkruani një funksion Kotlin `fun calculateSavingsInterest(monthlyDeposit: Double, interestRate: Double, months: Int): Double` për të zgjidhur problemin e mëposhtëm:\nLlogarit kursimet totale të akumuluara gjatë një periudhe muajsh me depozita mujore dhe një normë interesi fikse.\nInteresi përllogaritet çdo muaj bazuar në shumën totale në llogari në fund të çdo muaji.\nShembull:\n>>> calculateSavingsInterest(1000.0, 0.01, 6)  // 1000 depozitë mujore, 1% interes mujor, gjatë 6 muajve\n6213.54\n>>> calculateSavingsInterest(500.0, 0.02, 12)  // 500 depozitë mujore, 2% interes mujor, gjatë 12 muajve\n6840.17",
      "hy": "Գրեք Kotlin ֆունկցիա `fun calculateSavingsInterest(monthlyDeposit: Double, interestRate: Double, months: Int): Double` հետևյալ խնդիրը լուծելու համար:\nՀաշվում է ընդհանուր խնայողությունները, որոնք կուտակվում են ամիսների ընթացքում ամսական ավանդներով և հաստատուն տոկոսադրույքով:\nՏոկոսը հաշվարկվում է ամսական, հաշվի վերջում եղած ընդհանուր գումարի հիման վրա:\nՕրինակ:\n>>> calculateSavingsInterest(1000.0, 0.01, 6)  // 1000 ամսական ավանդ, 1% ամսական տոկոսադրույք, 6 ամիսների ընթացքում\n6213.54\n>>> calculateSavingsInterest(500.0, 0.02, 12)  // 500 ամսական ավանդ, 2% ամսական տոկոսադրույք, 12 ամիսների ընթացքում\n6840.17",
      "bn": "একটি Kotlin ফাংশন `fun calculateSavingsInterest(monthlyDeposit: Double, interestRate: Double, months: Int): Double` লিখুন নিম্নলিখিত সমস্যার সমাধানের জন্য:\nমাসিক আমানত এবং একটি নির্দিষ্ট সুদের হারের সাথে মাসের একটি নির্দিষ্ট সময়কালের উপর মোট সঞ্চয় হিসাব করে।\nসুদের হার প্রতি মাসের শেষে অ্যাকাউন্টে মোট পরিমাণের ভিত্তিতে মাসিক চক্রবৃদ্ধি করা হয়।\nউদাহরণ:\n>>> calculateSavingsInterest(1000.0, 0.01, 6)  // 1000 মাসিক আমানত, 1% মাসিক সুদ, 6 মাসের জন্য\n6213.54\n>>> calculateSavingsInterest(500.0, 0.02, 12)  // 500 মাসিক আমানত, 2% মাসিক সুদ, 12 মাসের জন্য\n6840.17",
      "bg": "Напишете Kotlin функция `fun calculateSavingsInterest(monthlyDeposit: Double, interestRate: Double, months: Int): Double`, за да решите следния проблем:\nИзчислява общите спестявания, натрупани за период от месеци с месечни вноски и фиксиран лихвен процент.\nЛихвата се капитализира месечно въз основа на общата сума в сметката в края на всеки месец.\nПример:\n>>> calculateSavingsInterest(1000.0, 0.01, 6)  // 1000 месечна вноска, 1% месечна лихва, за 6 месеца\n6213.54\n>>> calculateSavingsInterest(500.0, 0.02, 12)  // 500 месечна вноска, 2% месечна лихва, за 12 месеца\n6840.17",
      "zh": "编写一个 Kotlin 函数 `fun calculateSavingsInterest(monthlyDeposit: Double, interestRate: Double, months: Int): Double` 来解决以下问题：\n计算在一段时间内通过每月存款和固定利率累积的总储蓄。\n利息是基于每月末账户中的总金额按月复利计算的。\n示例:\n>>> calculateSavingsInterest(1000.0, 0.01, 6)  // 每月存款1000，月利率1%，持续6个月\n6213.54\n>>> calculateSavingsInterest(500.0, 0.02, 12)  // 每月存款500，月利率2%，持续12个月\n6840.17",
      "fr": "Écrire une fonction Kotlin `fun calculateSavingsInterest(monthlyDeposit: Double, interestRate: Double, months: Int): Double` pour résoudre le problème suivant :\nCalcule l'épargne totale accumulée sur une période de mois avec des dépôts mensuels et un taux d'intérêt fixe.\nL'intérêt est composé mensuellement en fonction du montant total sur le compte à la fin de chaque mois.\nExemple :\n>>> calculateSavingsInterest(1000.0, 0.01, 6)  // dépôt mensuel de 1000, intérêt mensuel de 1%, sur 6 mois\n6213.54\n>>> calculateSavingsInterest(500.0, 0.02, 12)  // dépôt mensuel de 500, intérêt mensuel de 2%, sur 12 mois\n6840.17",
      "de": "Schreiben Sie eine Kotlin-Funktion `fun calculateSavingsInterest(monthlyDeposit: Double, interestRate: Double, months: Int): Double`, um das folgende Problem zu lösen:\nBerechnet die gesamten Ersparnisse, die über einen Zeitraum von Monaten mit monatlichen Einzahlungen und einem festen Zinssatz angesammelt werden.\nDie Zinsen werden monatlich auf der Grundlage des Gesamtbetrags auf dem Konto am Ende jedes Monats berechnet.\nBeispiel:\n>>> calculateSavingsInterest(1000.0, 0.01, 6)  // 1000 monatliche Einzahlung, 1% monatliche Zinsen, über 6 Monate\n6213.54\n>>> calculateSavingsInterest(500.0, 0.02, 12)  // 500 monatliche Einzahlung, 2% monatliche Zinsen, über 12 Monate\n6840.17",
      "ha": "Rubuta wani aikin Kotlin `fun calculateSavingsInterest(monthlyDeposit: Double, interestRate: Double, months: Int): Double` don warware matsalar mai zuwa:\nYana ƙididdige jimlar adana kuɗi da aka tara a cikin watanni tare da ajiya na kowane wata da kuma ƙimar riba mai tsayi.\nAna haɗa ribar a kowane wata bisa ga jimlar adadin da ke cikin asusun a ƙarshen kowane wata.\nMisali:\n>>> calculateSavingsInterest(1000.0, 0.01, 6)  // 1000 ajiya na kowane wata, 1% riba na kowane wata, a cikin watanni 6\n6213.54\n>>> calculateSavingsInterest(500.0, 0.02, 12)  // 500 ajiya na kowane wata, 2% riba na kowane wata, a cikin watanni 12\n6840.17",
      "hi": "Kotlin फ़ंक्शन `fun calculateSavingsInterest(monthlyDeposit: Double, interestRate: Double, months: Int): Double` लिखें ताकि निम्नलिखित समस्या का समाधान किया जा सके:\nमासिक जमा और एक निश्चित ब्याज दर के साथ महीनों की अवधि में संचित कुल बचत की गणना करता है।\nब्याज प्रत्येक महीने के अंत में खाते में कुल राशि के आधार पर मासिक रूप से संयोजित होता है।\nउदाहरण:\n>>> calculateSavingsInterest(1000.0, 0.01, 6)  // 1000 मासिक जमा, 1% मासिक ब्याज, 6 महीनों में\n6213.54\n>>> calculateSavingsInterest(500.0, 0.02, 12)  // 500 मासिक जमा, 2% मासिक ब्याज, 12 महीनों में\n6840.17",
      "hu": "Írj egy Kotlin függvényt `fun calculateSavingsInterest(monthlyDeposit: Double, interestRate: Double, months: Int): Double` a következő probléma megoldására:\nKiszámítja a teljes megtakarítást, amely hónapokon keresztül halmozódik fel havi befizetésekkel és fix kamatlábbal.\nA kamat havonta tőkésedik a hónap végén a számlán lévő teljes összeg alapján.\nPélda:\n>>> calculateSavingsInterest(1000.0, 0.01, 6)  // 1000 havi befizetés, 1% havi kamat, 6 hónap alatt\n6213.54\n>>> calculateSavingsInterest(500.0, 0.02, 12)  // 500 havi befizetés, 2% havi kamat, 12 hónap alatt\n6840.17"
    },
    "instruction_bertscore": {
      "sq": "0.9900627206672056",
      "hy": "0.966950089529986",
      "bn": "0.9737917143743516",
      "bg": "0.9952118160347729",
      "zh": "0.9716532596921301",
      "fr": "0.977949644140555",
      "de": "0.9944502671538852",
      "ha": "0.9841510832668452",
      "hi": "0.9733453919081663",
      "hu": "0.9806535995175829"
    },
    "level": "easy",
    "test": "fun main(){\n    check(calculateSavingsInterest(1000.0, 0.01, 6) == 6213.54)\n    check(calculateSavingsInterest(500.0, 0.02, 12) == 6840.17)\n    check(calculateSavingsInterest(2000.0, 0.005, 3) == 6060.2)\n    check(calculateSavingsInterest(750.0, 0.01, 10) == 7925.13)\n}\nmain()",
    "entry_point": "calculateSavingsInterest",
    "signature": "fun calculateSavingsInterest(monthlyDeposit: Double, interestRate: Double, months: Int): Double",
    "docstring": {
      "en": "Calculates the total savings accumulated over a period of months with monthly deposits and a fixed interest rate.\nThe interest is compounded monthly based on the total amount in the account at the end of each month.\nExample:\n>>> calculateSavingsInterest(1000.0, 0.01, 6)  // 1000 monthly deposit, 1% monthly interest, over 6 months\n6213.54\n>>> calculateSavingsInterest(500.0, 0.02, 12)  // 500 monthly deposit, 2% monthly interest, over 12 months\n6840.17",
      "sq": "Llogarit kursimet totale të akumuluara gjatë një periudhe muajsh me depozita mujore dhe një normë fikse interesi.\nInteresi përpilohet çdo muaj bazuar në shumën totale në llogari në fund të çdo muaji.\nShembull:\n>>> calculateSavingsInterest(1000.0, 0.01, 6)  // 1000 depozitë mujore, 1% interes mujor, për 6 muaj\n6213.54\n>>> calculateSavingsInterest(500.0, 0.02, 12)  // 500 depozitë mujore, 2% interes mujor, për 12 muaj\n6840.17",
      "hy": "Հաշվում է կուտակված ընդհանուր խնայողությունները ամիսների ընթացքում ամսական ավանդներով և հաստատուն տոկոսադրույքով:\nՏոկոսադրույքը հաշվարկվում է ամսական՝ հաշվի վերջնական գումարի հիման վրա յուրաքանչյուր ամսվա վերջում:\nՕրինակ:\n>>> calculateSavingsInterest(1000.0, 0.01, 6)  // 1000 ամսական ավանդ, 1% ամսական տոկոսադրույք, 6 ամիսների ընթացքում\n6213.54\n>>> calculateSavingsInterest(500.0, 0.02, 12)  // 500 ամսական ավանդ, 2% ամսական տոկոսադրույք, 12 ամիսների ընթացքում\n6840.17",
      "bn": "মাসিক আমানত এবং একটি নির্দিষ্ট সুদের হারের সাথে মাসগুলির একটি সময়কালে জমাকৃত মোট সঞ্চয় গণনা করে। \nসুদের হার মাসিক ভিত্তিতে মাসের শেষে অ্যাকাউন্টে মোট পরিমাণের উপর চক্রবৃদ্ধি হয়। \nউদাহরণ:\n>>> calculateSavingsInterest(1000.0, 0.01, 6)  // 1000 মাসিক আমানত, 1% মাসিক সুদ, 6 মাসের জন্য\n6213.54\n>>> calculateSavingsInterest(500.0, 0.02, 12)  // 500 মাসিক আমানত, 2% মাসিক সুদ, 12 মাসের জন্য\n6840.17",
      "bg": "Изчислява общите спестявания, натрупани за период от месеци с месечни депозити и фиксиран лихвен процент. Лихвата се начислява месечно въз основа на общата сума в сметката в края на всеки месец. Пример:\n>>> calculateSavingsInterest(1000.0, 0.01, 6)  // 1000 месечен депозит, 1% месечна лихва, за 6 месеца\n6213.54\n>>> calculateSavingsInterest(500.0, 0.02, 12)  // 500 месечен депозит, 2% месечна лихва, за 12 месеца\n6840.17",
      "zh": "计算在一段月份内通过每月存款和固定利率累积的总储蓄。\n利息是基于每月底账户中的总金额按月复利计算的。\n示例：\n>>> calculateSavingsInterest(1000.0, 0.01, 6)  // 每月存款1000，月利率1%，持续6个月\n6213.54\n>>> calculateSavingsInterest(500.0, 0.02, 12)  // 每月存款500，月利率2%，持续12个月\n6840.17",
      "fr": "Calcule les économies totales accumulées sur une période de mois avec des dépôts mensuels et un taux d'intérêt fixe.  \nL'intérêt est composé mensuellement en fonction du montant total sur le compte à la fin de chaque mois.  \nExemple :  \n>>> calculateSavingsInterest(1000.0, 0.01, 6)  // dépôt mensuel de 1000, intérêt mensuel de 1%, sur 6 mois  \n6213.54  \n>>> calculateSavingsInterest(500.0, 0.02, 12)  // dépôt mensuel de 500, intérêt mensuel de 2%, sur 12 mois  \n6840.17  ",
      "de": "Berechnet die gesamten Ersparnisse, die über einen Zeitraum von Monaten mit monatlichen Einzahlungen und einem festen Zinssatz angesammelt werden.\nDie Zinsen werden monatlich auf der Grundlage des Gesamtbetrags auf dem Konto am Ende jedes Monats aufgezinst.\nBeispiel:\n>>> calculateSavingsInterest(1000.0, 0.01, 6)  // 1000 monatliche Einzahlung, 1% monatlicher Zins, über 6 Monate\n6213.54\n>>> calculateSavingsInterest(500.0, 0.02, 12)  // 500 monatliche Einzahlung, 2% monatlicher Zins, über 12 Monate\n6840.17",
      "ha": "Yana ƙididdige jimillar ajiyar da aka tara a tsawon watanni tare da ajiya na kowane wata da kuma ƙimar riba mai tsayi.\nAna haɗa ribar kowane wata bisa ga jimillar adadin da ke cikin asusun a ƙarshen kowane wata.\nMisali:\n>>> calculateSavingsInterest(1000.0, 0.01, 6)  // 1000 ajiya na kowane wata, 1% riba na kowane wata, a tsawon watanni 6\n6213.54\n>>> calculateSavingsInterest(500.0, 0.02, 12)  // 500 ajiya na kowane wata, 2% riba na kowane wata, a tsawon watanni 12\n6840.17",
      "hi": "महीनों की अवधि में मासिक जमा और एक निश्चित ब्याज दर के साथ संचित कुल बचत की गणना करता है।\nब्याज प्रत्येक महीने के अंत में खाते में कुल राशि के आधार पर मासिक रूप से संयोजित होता है।\nउदाहरण:\n>>> calculateSavingsInterest(1000.0, 0.01, 6)  // 1000 मासिक जमा, 1% मासिक ब्याज, 6 महीनों में\n6213.54\n>>> calculateSavingsInterest(500.0, 0.02, 12)  // 500 मासिक जमा, 2% मासिक ब्याज, 12 महीनों में\n6840.17",
      "hu": "Kiszámítja a hónapok során felhalmozott teljes megtakarítást havi befizetésekkel és fix kamatlábbal.\nA kamat havonta tőkésedik a hónap végén a számlán lévő teljes összeg alapján.\nPélda:\n>>> calculateSavingsInterest(1000.0, 0.01, 6)  // 1000 havi befizetés, 1% havi kamat, 6 hónap alatt\n6213.54\n>>> calculateSavingsInterest(500.0, 0.02, 12)  // 500 havi befizetés, 2% havi kamat, 12 hónap alatt\n6840.17"
    },
    "docstring_bertscore": {
      "sq": "0.9850955707286662",
      "hy": "0.9553784794220365",
      "bn": "0.9630239614184504",
      "bg": "0.9940033487965567",
      "zh": "0.9555485070282024",
      "fr": "0.9701752510268494",
      "de": "1",
      "ha": "0.9684964270463426",
      "hi": "0.9903004812333044",
      "hu": "0.9780402195943069"
    }
  },
  {
    "task_id": "Kotlin/12",
    "prompt": {
      "en": "/**\n * Generates and returns a list of integers within a specified range (inclusive of both ends) that are divisible by a given divisor.\n * \n * Example:\n * >>> printDivisibleNumbersInRange(1, 10, 2)\n *     [2, 4, 6, 8, 10]\n * >>> printDivisibleNumbersInRange(3, 15, 3)\n *     [3, 6, 9, 12, 15]\n * >>> printDivisibleNumbersInRange(5, 20, 5)\n *     [5, 10, 15, 20]\n */\n\nfun printDivisibleNumbersInRange(min: Int, max: Int, divisor: Int): List<Int> ",
      "sq": "/**\n * Gjeneron dhe kthen një listë të numrave të plotë brenda një intervali të caktuar (përfshirë të dy skajet) që janë të pjestueshëm me një pjestues të dhënë.\n * \n * Shembull:\n * >>> printDivisibleNumbersInRange(1, 10, 2)\n *     [2, 4, 6, 8, 10]\n * >>> printDivisibleNumbersInRange(3, 15, 3)\n *     [3, 6, 9, 12, 15]\n * >>> printDivisibleNumbersInRange(5, 20, 5)\n *     [5, 10, 15, 20]\n */",
      "hy": "/**\n * Գեներացնում և վերադարձնում է ամբողջ թվերի ցուցակ նշված միջակայքում (ներառյալ երկու ծայրերը), որոնք բաժանվում են տրված բաժանարարով:\n * \n * Օրինակ:\n * >>> printDivisibleNumbersInRange(1, 10, 2)\n *     [2, 4, 6, 8, 10]\n * >>> printDivisibleNumbersInRange(3, 15, 3)\n *     [3, 6, 9, 12, 15]\n * >>> printDivisibleNumbersInRange(5, 20, 5)\n *     [5, 10, 15, 20]\n */",
      "bn": "/**\n * একটি নির্দিষ্ট সীমার (উভয় প্রান্ত অন্তর্ভুক্ত) মধ্যে যে সমস্ত পূর্ণসংখ্যা একটি প্রদত্ত বিভাজক দ্বারা বিভাজ্য, তাদের একটি তালিকা তৈরি করে এবং ফেরত দেয়।\n * \n * উদাহরণ:\n * >>> printDivisibleNumbersInRange(1, 10, 2)\n *     [2, 4, 6, 8, 10]\n * >>> printDivisibleNumbersInRange(3, 15, 3)\n *     [3, 6, 9, 12, 15]\n * >>> printDivisibleNumbersInRange(5, 20, 5)\n *     [5, 10, 15, 20]\n */",
      "bg": "/**\n * Генерира и връща списък от цели числа в рамките на определен диапазон (включително и двата края), които са делими на даден делител.\n * \n * Пример:\n * >>> printDivisibleNumbersInRange(1, 10, 2)\n *     [2, 4, 6, 8, 10]\n * >>> printDivisibleNumbersInRange(3, 15, 3)\n *     [3, 6, 9, 12, 15]\n * >>> printDivisibleNumbersInRange(5, 20, 5)\n *     [5, 10, 15, 20]\n */ \n\nfun printDivisibleNumbersInRange(min: Int, max: Int, divisor: Int): List<Int> ",
      "zh": "/**\n * 生成并返回一个整数列表，该列表在指定范围内（包括两端）且可被给定除数整除。\n * \n * 示例:\n * >>> printDivisibleNumbersInRange(1, 10, 2)\n *     [2, 4, 6, 8, 10]\n * >>> printDivisibleNumbersInRange(3, 15, 3)\n *     [3, 6, 9, 12, 15]\n * >>> printDivisibleNumbersInRange(5, 20, 5)\n *     [5, 10, 15, 20]\n */",
      "fr": "/**\n * Génère et renvoie une liste d'entiers dans une plage spécifiée (inclusivement aux deux extrémités) qui sont divisibles par un diviseur donné.\n * \n * Exemple:\n * >>> printDivisibleNumbersInRange(1, 10, 2)\n *     [2, 4, 6, 8, 10]\n * >>> printDivisibleNumbersInRange(3, 15, 3)\n *     [3, 6, 9, 12, 15]\n * >>> printDivisibleNumbersInRange(5, 20, 5)\n *     [5, 10, 15, 20]\n */ \n\nfun printDivisibleNumbersInRange(min: Int, max: Int, divisor: Int): List<Int> ",
      "de": "/**\n * Generiert und gibt eine Liste von ganzen Zahlen innerhalb eines angegebenen Bereichs (einschließlich beider Enden) zurück, die durch einen gegebenen Divisor teilbar sind.\n * \n * Beispiel:\n * >>> printDivisibleNumbersInRange(1, 10, 2)\n *     [2, 4, 6, 8, 10]\n * >>> printDivisibleNumbersInRange(3, 15, 3)\n *     [3, 6, 9, 12, 15]\n * >>> printDivisibleNumbersInRange(5, 20, 5)\n *     [5, 10, 15, 20]\n */",
      "ha": "/**\n * Yana samarwa da dawowa da jerin lambobi a cikin kewayon da aka fayyace (ciki har da duka ƙarshen) waɗanda za a iya raba su da wani mai raba.\n * \n * Misali:\n * >>> printDivisibleNumbersInRange(1, 10, 2)\n *     [2, 4, 6, 8, 10]\n * >>> printDivisibleNumbersInRange(3, 15, 3)\n *     [3, 6, 9, 12, 15]\n * >>> printDivisibleNumbersInRange(5, 20, 5)\n *     [5, 10, 15, 20]\n */",
      "hi": "/**\n * एक निर्दिष्ट सीमा के भीतर (दोनों सिरों सहित) उन पूर्णांकों की सूची उत्पन्न करता है और लौटाता है जो एक दिए गए भाजक से विभाज्य होते हैं।\n * \n * उदाहरण:\n * >>> printDivisibleNumbersInRange(1, 10, 2)\n *     [2, 4, 6, 8, 10]\n * >>> printDivisibleNumbersInRange(3, 15, 3)\n *     [3, 6, 9, 12, 15]\n * >>> printDivisibleNumbersInRange(5, 20, 5)\n *     [5, 10, 15, 20]\n */",
      "hu": "/**\n * Generál és visszaad egy egész számokból álló listát egy megadott tartományon belül (mindkét végpontot beleértve), amelyek oszthatók egy adott osztóval.\n * \n * Példa:\n * >>> printDivisibleNumbersInRange(1, 10, 2)\n *     [2, 4, 6, 8, 10]\n * >>> printDivisibleNumbersInRange(3, 15, 3)\n *     [3, 6, 9, 12, 15]\n * >>> printDivisibleNumbersInRange(5, 20, 5)\n *     [5, 10, 15, 20]\n */"
    },
    "prompt_bertscore": {
      "sq": "0.9356681880815635",
      "hy": "0.9313167923242323",
      "bn": "0.9388850071024235",
      "bg": "0.9871658951901928",
      "zh": "0.9198911755463434",
      "fr": "0.9966332150414586",
      "de": "0.9356681880815635",
      "ha": "0.9288801934400772",
      "hi": "0.9460674816806451",
      "hu": "0.932641656965735"
    },
    "canonical_solution": "{\n    val divisibleNumbers = mutableListOf<Int>()\n    for (number in min..max) {\n        if (number % divisor == 0) {\n            divisibleNumbers.add(number)\n        }\n    }\n    return divisibleNumbers\n}",
    "instruction": {
      "en": "Write a Kotlin function `fun printDivisibleNumbersInRange(min: Int, max: Int, divisor: Int): List<Int>` to solve the following problem:\nGenerates and returns a list of integers within a specified range (inclusive of both ends) that are divisible by a given divisor.\n\nExample:\n>>> printDivisibleNumbersInRange(1, 10, 2)\n[2, 4, 6, 8, 10]\n>>> printDivisibleNumbersInRange(3, 15, 3)\n[3, 6, 9, 12, 15]\n>>> printDivisibleNumbersInRange(5, 20, 5)\n[5, 10, 15, 20]",
      "sq": "Shkruani një funksion Kotlin `fun printDivisibleNumbersInRange(min: Int, max: Int, divisor: Int): List<Int>` për të zgjidhur problemin vijues:\nGjeneron dhe kthen një listë të numrave të plotë brenda një intervali të specifikuar (përfshirë të dy skajet) që janë të pjestueshëm me një pjestues të dhënë.\n\nShembull:\n>>> printDivisibleNumbersInRange(1, 10, 2)\n[2, 4, 6, 8, 10]\n>>> printDivisibleNumbersInRange(3, 15, 3)\n[3, 6, 9, 12, 15]\n>>> printDivisibleNumbersInRange(5, 20, 5)\n[5, 10, 15, 20]",
      "hy": "Kotlin ֆունկցիա `fun printDivisibleNumbersInRange(min: Int, max: Int, divisor: Int): List<Int>` գրեք հետևյալ խնդիրը լուծելու համար:\nԳեներացնում և վերադարձնում է ամբողջ թվերի ցուցակ նշված միջակայքում (ներառյալ երկու ծայրերը), որոնք բաժանվում են տրված բաժանարարով:\n\nՕրինակ:\n>>> printDivisibleNumbersInRange(1, 10, 2)\n[2, 4, 6, 8, 10]\n>>> printDivisibleNumbersInRange(3, 15, 3)\n[3, 6, 9, 12, 15]\n>>> printDivisibleNumbersInRange(5, 20, 5)\n[5, 10, 15, 20]",
      "bn": "একটি Kotlin ফাংশন `fun printDivisibleNumbersInRange(min: Int, max: Int, divisor: Int): List<Int>` লিখুন নিম্নলিখিত সমস্যার সমাধানের জন্য:\nএকটি নির্দিষ্ট সীমার (উভয় প্রান্ত অন্তর্ভুক্ত) মধ্যে যে পূর্ণসংখ্যাগুলি একটি প্রদত্ত বিভাজক দ্বারা বিভাজ্য, সেগুলির একটি তালিকা তৈরি করে এবং ফেরত দেয়।\n\nউদাহরণ:\n>>> printDivisibleNumbersInRange(1, 10, 2)\n[2, 4, 6, 8, 10]\n>>> printDivisibleNumbersInRange(3, 15, 3)\n[3, 6, 9, 12, 15]\n>>> printDivisibleNumbersInRange(5, 20, 5)\n[5, 10, 15, 20]",
      "bg": "Напишете функция на Kotlin `fun printDivisibleNumbersInRange(min: Int, max: Int, divisor: Int): List<Int>` за решаване на следния проблем:\nГенерира и връща списък от цели числа в рамките на определен диапазон (включително и двата края), които са делими на даден делител.\n\nПример:\n>>> printDivisibleNumbersInRange(1, 10, 2)\n[2, 4, 6, 8, 10]\n>>> printDivisibleNumbersInRange(3, 15, 3)\n[3, 6, 9, 12, 15]\n>>> printDivisibleNumbersInRange(5, 20, 5)\n[5, 10, 15, 20]",
      "zh": "编写一个 Kotlin 函数 `fun printDivisibleNumbersInRange(min: Int, max: Int, divisor: Int): List<Int>` 来解决以下问题：\n生成并返回一个在指定范围内（包括两端）可被给定除数整除的整数列表。\n\n示例:\n>>> printDivisibleNumbersInRange(1, 10, 2)\n[2, 4, 6, 8, 10]\n>>> printDivisibleNumbersInRange(3, 15, 3)\n[3, 6, 9, 12, 15]\n>>> printDivisibleNumbersInRange(5, 20, 5)\n[5, 10, 15, 20]",
      "fr": "Écrire une fonction Kotlin `fun printDivisibleNumbersInRange(min: Int, max: Int, divisor: Int): List<Int>` pour résoudre le problème suivant :\nGénère et retourne une liste d'entiers dans une plage spécifiée (inclusivement aux deux extrémités) qui sont divisibles par un diviseur donné.\n\nExemple :\n>>> printDivisibleNumbersInRange(1, 10, 2)\n[2, 4, 6, 8, 10]\n>>> printDivisibleNumbersInRange(3, 15, 3)\n[3, 6, 9, 12, 15]\n>>> printDivisibleNumbersInRange(5, 20, 5)\n[5, 10, 15, 20]",
      "de": "Schreiben Sie eine Kotlin-Funktion `fun printDivisibleNumbersInRange(min: Int, max: Int, divisor: Int): List<Int>`, um das folgende Problem zu lösen:\nGeneriert und gibt eine Liste von ganzen Zahlen innerhalb eines angegebenen Bereichs (einschließlich beider Enden) zurück, die durch einen gegebenen Divisor teilbar sind.\n\nBeispiel:\n>>> printDivisibleNumbersInRange(1, 10, 2)\n[2, 4, 6, 8, 10]\n>>> printDivisibleNumbersInRange(3, 15, 3)\n[3, 6, 9, 12, 15]\n>>> printDivisibleNumbersInRange(5, 20, 5)\n[5, 10, 15, 20]",
      "ha": "Rubuta aikin Kotlin `fun printDivisibleNumbersInRange(min: Int, max: Int, divisor: Int): List<Int>` don warware matsalar mai zuwa: \nYana samarwa da dawowa da jerin lambobin cikakke a cikin kewayon da aka kayyade (ciki har da duka iyakoki) waɗanda za a iya raba su da wani mai raba.\n\nMisali:\n>>> printDivisibleNumbersInRange(1, 10, 2)\n[2, 4, 6, 8, 10]\n>>> printDivisibleNumbersInRange(3, 15, 3)\n[3, 6, 9, 12, 15]\n>>> printDivisibleNumbersInRange(5, 20, 5)\n[5, 10, 15, 20]",
      "hi": "Kotlin फ़ंक्शन `fun printDivisibleNumbersInRange(min: Int, max: Int, divisor: Int): List<Int>` लिखें ताकि निम्नलिखित समस्या का समाधान हो सके:\nएक निर्दिष्ट सीमा के भीतर (दोनों छोरों सहित) उन पूर्णांकों की एक सूची उत्पन्न करता है और लौटाता है जो एक दिए गए भाजक से विभाजित होते हैं।\n\nउदाहरण:\n>>> printDivisibleNumbersInRange(1, 10, 2)\n[2, 4, 6, 8, 10]\n>>> printDivisibleNumbersInRange(3, 15, 3)\n[3, 6, 9, 12, 15]\n>>> printDivisibleNumbersInRange(5, 20, 5)\n[5, 10, 15, 20]",
      "hu": "Írj egy Kotlin függvényt `fun printDivisibleNumbersInRange(min: Int, max: Int, divisor: Int): List<Int>` a következő probléma megoldására:\nGenerál és visszaad egy egész számokból álló listát egy megadott tartományon belül (mindkét végpontot beleértve), amelyek oszthatók egy adott osztóval.\n\nPélda:\n>>> printDivisibleNumbersInRange(1, 10, 2)\n[2, 4, 6, 8, 10]\n>>> printDivisibleNumbersInRange(3, 15, 3)\n[3, 6, 9, 12, 15]\n>>> printDivisibleNumbersInRange(5, 20, 5)\n[5, 10, 15, 20]"
    },
    "instruction_bertscore": {
      "sq": "0.9909204066525142",
      "hy": "0.9676379465395099",
      "bn": "0.9967067082824416",
      "bg": "0.9906862214332741",
      "zh": "0.9728581515834877",
      "fr": "0.9947613223305859",
      "de": "0.989751864120886",
      "ha": "0.9805068116659982",
      "hi": "0.9231565909393046",
      "hu": "0.9845376179883392"
    },
    "level": "easy",
    "test": "fun main() {\n    check(printDivisibleNumbersInRange(1, 10, 2) == listOf(2, 4, 6, 8, 10))\n    check(printDivisibleNumbersInRange(3, 15, 3) == listOf(3, 6, 9, 12, 15))\n    check(printDivisibleNumbersInRange(5, 20, 5) == listOf(5, 10, 15, 20))\n    check(printDivisibleNumbersInRange(7, 21, 7) == listOf(7, 14, 21))\n    check(printDivisibleNumbersInRange(10, 30, 10) == listOf(10, 20, 30))\n}\n\nmain()",
    "entry_point": "printDivisibleNumbersInRange",
    "signature": "fun printDivisibleNumbersInRange(min: Int, max: Int, divisor: Int): List<Int>",
    "docstring": {
      "en": "Generates and returns a list of integers within a specified range (inclusive of both ends) that are divisible by a given divisor.\n\nExample:\n>>> printDivisibleNumbersInRange(1, 10, 2)\n[2, 4, 6, 8, 10]\n>>> printDivisibleNumbersInRange(3, 15, 3)\n[3, 6, 9, 12, 15]\n>>> printDivisibleNumbersInRange(5, 20, 5)\n[5, 10, 15, 20]",
      "sq": "Gjeneron dhe kthen një listë të numrave të plotë brenda një diapazoni të specifikuar (përfshirë të dy skajet) që janë të pjestueshëm me një pjestues të dhënë.\n\nShembull:\n>>> printDivisibleNumbersInRange(1, 10, 2)\n[2, 4, 6, 8, 10]\n>>> printDivisibleNumbersInRange(3, 15, 3)\n[3, 6, 9, 12, 15]\n>>> printDivisibleNumbersInRange(5, 20, 5)\n[5, 10, 15, 20]",
      "hy": "Ստեղծում և վերադարձնում է ամբողջ թվերի ցուցակ նշված միջակայքում (ներառյալ երկու ծայրերը), որոնք բաժանվում են տրված բաժանարարի վրա:\n\nՕրինակ:\n>>> printDivisibleNumbersInRange(1, 10, 2)\n[2, 4, 6, 8, 10]\n>>> printDivisibleNumbersInRange(3, 15, 3)\n[3, 6, 9, 12, 15]\n>>> printDivisibleNumbersInRange(5, 20, 5)\n[5, 10, 15, 20]",
      "bn": "নির্দিষ্ট একটি পরিসরের (উভয় প্রান্ত সহ) মধ্যে যে সকল পূর্ণসংখ্যা একটি প্রদত্ত বিভাজক দ্বারা বিভাজ্য, সেগুলোর একটি তালিকা তৈরি করে এবং ফেরত দেয়।\n\nউদাহরণ:\n>>> printDivisibleNumbersInRange(1, 10, 2)\n[2, 4, 6, 8, 10]\n>>> printDivisibleNumbersInRange(3, 15, 3)\n[3, 6, 9, 12, 15]\n>>> printDivisibleNumbersInRange(5, 20, 5)\n[5, 10, 15, 20]",
      "bg": "Генерира и връща списък от цели числа в зададен диапазон (включително и двата края), които са делими на даден делител.\n\nПример:\n>>> printDivisibleNumbersInRange(1, 10, 2)\n[2, 4, 6, 8, 10]\n>>> printDivisibleNumbersInRange(3, 15, 3)\n[3, 6, 9, 12, 15]\n>>> printDivisibleNumbersInRange(5, 20, 5)\n[5, 10, 15, 20]",
      "zh": "生成并返回指定范围内（包括两端）可被给定除数整除的整数列表。\n\n示例：\n>>> printDivisibleNumbersInRange(1, 10, 2)\n[2, 4, 6, 8, 10]\n>>> printDivisibleNumbersInRange(3, 15, 3)\n[3, 6, 9, 12, 15]\n>>> printDivisibleNumbersInRange(5, 20, 5)\n[5, 10, 15, 20]",
      "fr": "Génère et retourne une liste d'entiers dans une plage spécifiée (inclusivement aux deux extrémités) qui sont divisibles par un diviseur donné.\n\nExemple :\n>>> printDivisibleNumbersInRange(1, 10, 2)\n[2, 4, 6, 8, 10]\n>>> printDivisibleNumbersInRange(3, 15, 3)\n[3, 6, 9, 12, 15]\n>>> printDivisibleNumbersInRange(5, 20, 5)\n[5, 10, 15, 20]",
      "de": "Erzeugt und gibt eine Liste von ganzen Zahlen innerhalb eines angegebenen Bereichs zurück (einschließlich beider Enden), die durch einen gegebenen Divisor teilbar sind.\n\nBeispiel:\n>>> printDivisibleNumbersInRange(1, 10, 2)\n[2, 4, 6, 8, 10]\n>>> printDivisibleNumbersInRange(3, 15, 3)\n[3, 6, 9, 12, 15]\n>>> printDivisibleNumbersInRange(5, 20, 5)\n[5, 10, 15, 20]",
      "ha": "Yana haifarwa da kuma dawowa da jerin lambobi masu cikakken lamba a cikin wani kewaye da aka fayyace (ciki har da duka iyakoki) waɗanda za a iya raba su da wani mai raba da aka bayar.\n\nMisali:\n>>> printDivisibleNumbersInRange(1, 10, 2)\n[2, 4, 6, 8, 10]\n>>> printDivisibleNumbersInRange(3, 15, 3)\n[3, 6, 9, 12, 15]\n>>> printDivisibleNumbersInRange(5, 20, 5)\n[5, 10, 15, 20]",
      "hi": "निर्दिष्ट सीमा के भीतर (दोनों सिरों सहित) उन पूर्णांकों की एक सूची उत्पन्न करता है और लौटाता है जो दिए गए भाजक से विभाज्य हैं।\n\nउदाहरण:\n>>> printDivisibleNumbersInRange(1, 10, 2)\n[2, 4, 6, 8, 10]\n>>> printDivisibleNumbersInRange(3, 15, 3)\n[3, 6, 9, 12, 15]\n>>> printDivisibleNumbersInRange(5, 20, 5)\n[5, 10, 15, 20]",
      "hu": "Generál és visszaad egy egész számokból álló listát egy megadott tartományon belül (mindkét végpontot beleértve), amelyek oszthatók egy adott osztóval.\n\nPélda:\n>>> printDivisibleNumbersInRange(1, 10, 2)\n[2, 4, 6, 8, 10]\n>>> printDivisibleNumbersInRange(3, 15, 3)\n[3, 6, 9, 12, 15]\n>>> printDivisibleNumbersInRange(5, 20, 5)\n[5, 10, 15, 20]"
    },
    "docstring_bertscore": {
      "sq": "0.9877808548498768",
      "hy": "0.9653471423550345",
      "bn": "0.9764162175989657",
      "bg": "0.9802537565605597",
      "zh": "0.9618186722663307",
      "fr": "0.995695679642974",
      "de": "0.9802855374215252",
      "ha": "0.9829128214714737",
      "hi": "0.9810423191732682",
      "hu": "0.9756816824498986"
    }
  },
  {
    "task_id": "Kotlin/13",
    "prompt": {
      "en": "/**\n * Converts a given integer to its octal, decimal, and hexadecimal representations.\n * Args:\n *   number: An integer number to be converted.\n * Returns:\n *   A Triple containing the octal, decimal, and hexadecimal representations of the number.\n * Examples:\n *   >>> convertNumberToDifferentBases(10)\n *       Triple(\"12\", \"10\", \"A\")\n *   >>> convertNumberToDifferentBases(255)\n *       Triple(\"377\", \"255\", \"FF\")\n *   >>> convertNumberToDifferentBases(16)\n *       Triple(\"20\", \"16\", \"10\")\n */\n\nfun convertNumberToDifferentBases(number: Int): Triple<String, String, String> ",
      "sq": "/**\n * Konverton një numër të dhënë të plotë në përfaqësimet e tij oktale, dhjetore dhe heksadecimale.\n * Argumentet:\n *   number: Një numër i plotë që do të konvertohet.\n * Kthen:\n *   Një Triple që përmban përfaqësimet oktale, dhjetore dhe heksadecimale të numrit.\n * Shembuj:\n *   >>> convertNumberToDifferentBases(10)\n *       Triple(\"12\", \"10\", \"A\")\n *   >>> convertNumberToDifferentBases(255)\n *       Triple(\"377\", \"255\", \"FF\")\n *   >>> convertNumberToDifferentBases(16)\n *       Triple(\"20\", \"16\", \"10\")\n */",
      "hy": "/**\n * Փոխակերպում է տրված ամբողջ թիվը նրա ութական, տասնորդական և տասնվեցական ներկայացումներին:\n * Պարամետրեր:\n *   number: Ամբողջ թիվ, որը պետք է փոխակերպվի:\n * Վերադարձնում է:\n *   Երեքյակ, որը պարունակում է թվի ութական, տասնորդական և տասնվեցական ներկայացումները:\n * Օրինակներ:\n *   >>> convertNumberToDifferentBases(10)\n *       Triple(\"12\", \"10\", \"A\")\n *   >>> convertNumberToDifferentBases(255)\n *       Triple(\"377\", \"255\", \"FF\")\n *   >>> convertNumberToDifferentBases(16)\n *       Triple(\"20\", \"16\", \"10\")\n */ \n\nfun convertNumberToDifferentBases(number: Int): Triple<String, String, String> ",
      "bn": "/**\n * একটি প্রদত্ত পূর্ণসংখ্যাকে তার অষ্টাদশ, দশমিক, এবং ষোলমিক উপস্থাপনায় রূপান্তর করে।\n * Args:\n *   number: একটি পূর্ণসংখ্যা যা রূপান্তর করা হবে।\n * Returns:\n *   একটি Triple যা সংখ্যার অষ্টাদশ, দশমিক, এবং ষোলমিক উপস্থাপনাগুলি ধারণ করে।\n * Examples:\n *   >>> convertNumberToDifferentBases(10)\n *       Triple(\"12\", \"10\", \"A\")\n *   >>> convertNumberToDifferentBases(255)\n *       Triple(\"377\", \"255\", \"FF\")\n *   >>> convertNumberToDifferentBases(16)\n *       Triple(\"20\", \"16\", \"10\")\n */\n\nfun convertNumberToDifferentBases(number: Int): Triple<String, String, String> ",
      "bg": "/**\n * Преобразува дадено цяло число в неговите осмична, десетична и шестнадесетична представяния.\n * Аргументи:\n *   number: Цяло число, което да бъде преобразувано.\n * Връща:\n *   Тройка, съдържаща осмичното, десетичното и шестнадесетичното представяне на числото.\n * Примери:\n *   >>> convertNumberToDifferentBases(10)\n *       Triple(\"12\", \"10\", \"A\")\n *   >>> convertNumberToDifferentBases(255)\n *       Triple(\"377\", \"255\", \"FF\")\n *   >>> convertNumberToDifferentBases(16)\n *       Triple(\"20\", \"16\", \"10\")\n */",
      "zh": "/**\n * 将给定的整数转换为其八进制、十进制和十六进制表示。\n * 参数:\n *   number: 要转换的整数。\n * 返回:\n *   包含该数字的八进制、十进制和十六进制表示的Triple。\n * 示例:\n *   >>> convertNumberToDifferentBases(10)\n *       Triple(\"12\", \"10\", \"A\")\n *   >>> convertNumberToDifferentBases(255)\n *       Triple(\"377\", \"255\", \"FF\")\n *   >>> convertNumberToDifferentBases(16)\n *       Triple(\"20\", \"16\", \"10\")\n */",
      "fr": "/**\n * Convertit un entier donné en ses représentations octale, décimale et hexadécimale.\n * Args:\n *   number: Un nombre entier à convertir.\n * Returns:\n *   Un Triple contenant les représentations octale, décimale et hexadécimale du nombre.\n * Examples:\n *   >>> convertNumberToDifferentBases(10)\n *       Triple(\"12\", \"10\", \"A\")\n *   >>> convertNumberToDifferentBases(255)\n *       Triple(\"377\", \"255\", \"FF\")\n *   >>> convertNumberToDifferentBases(16)\n *       Triple(\"20\", \"16\", \"10\")\n */",
      "de": "/**\n * Wandelt eine gegebene ganze Zahl in ihre oktale, dezimale und hexadezimale Darstellung um.\n * Argumente:\n *   number: Eine ganze Zahl, die umgewandelt werden soll.\n * Rückgabe:\n *   Ein Triple, das die oktale, dezimale und hexadezimale Darstellung der Zahl enthält.\n * Beispiele:\n *   >>> convertNumberToDifferentBases(10)\n *       Triple(\"12\", \"10\", \"A\")\n *   >>> convertNumberToDifferentBases(255)\n *       Triple(\"377\", \"255\", \"FF\")\n *   >>> convertNumberToDifferentBases(16)\n *       Triple(\"20\", \"16\", \"10\")\n */",
      "ha": "/**\n * Canza wani cikakken lamba zuwa wakilcinsa na octal, decimal, da hexadecimal.\n * Args:\n *   number: Wani cikakken lamba da za a canza.\n * Returns:\n *   A Triple mai ɗauke da wakilcin octal, decimal, da hexadecimal na lambar.\n * Examples:\n *   >>> convertNumberToDifferentBases(10)\n *       Triple(\"12\", \"10\", \"A\")\n *   >>> convertNumberToDifferentBases(255)\n *       Triple(\"377\", \"255\", \"FF\")\n *   >>> convertNumberToDifferentBases(16)\n *       Triple(\"20\", \"16\", \"10\")\n */",
      "hi": "/**\n * दिए गए पूर्णांक को उसके अष्टाधारी, दशमलव, और षोडशाधारी रूपांतरणों में परिवर्तित करता है।\n * Args:\n *   number: एक पूर्णांक संख्या जिसे परिवर्तित किया जाना है।\n * Returns:\n *   एक Triple जो संख्या के अष्टाधारी, दशमलव, और षोडशाधारी रूपांतरणों को समाहित करता है।\n * Examples:\n *   >>> convertNumberToDifferentBases(10)\n *       Triple(\"12\", \"10\", \"A\")\n *   >>> convertNumberToDifferentBases(255)\n *       Triple(\"377\", \"255\", \"FF\")\n *   >>> convertNumberToDifferentBases(16)\n *       Triple(\"20\", \"16\", \"10\")\n */ \n\nfun convertNumberToDifferentBases(number: Int): Triple<String, String, String> ",
      "hu": "/**\n * Egy adott egész számot átalakít oktális, decimális és hexadecimális reprezentációkra.\n * Args:\n *   number: Egy egész szám, amelyet át kell alakítani.\n * Returns:\n *   Egy Triple, amely tartalmazza a szám oktális, decimális és hexadecimális reprezentációit.\n * Példák:\n *   >>> convertNumberToDifferentBases(10)\n *       Triple(\"12\", \"10\", \"A\")\n *   >>> convertNumberToDifferentBases(255)\n *       Triple(\"377\", \"255\", \"FF\")\n *   >>> convertNumberToDifferentBases(16)\n *       Triple(\"20\", \"16\", \"10\")\n */"
    },
    "prompt_bertscore": {
      "sq": "0.9531975178382734",
      "hy": "0.9704253266765724",
      "bn": "0.9567464468562238",
      "bg": "0.948998670213577",
      "zh": "0.9395392955775524",
      "fr": "0.9544306152437381",
      "de": "0.9460942967820848",
      "ha": "0.9478450249605263",
      "hi": "0.9978849837027405",
      "hu": "0.9530058395205747"
    },
    "canonical_solution": "{\n    val octal = number.toString(8)\n    val decimal = number.toString(10)\n    val hexadecimal = number.toString(16).uppercase()\n    return Triple(octal, decimal, hexadecimal)\n}",
    "instruction": {
      "en": "Write a Kotlin function `fun convertNumberToDifferentBases(number: Int): Triple<String, String, String>` to solve the following problem:\nConverts a given integer to its octal, decimal, and hexadecimal representations.\nArgs:\nnumber: An integer number to be converted.\nReturns:\nA Triple containing the octal, decimal, and hexadecimal representations of the number.\nExamples:\n>>> convertNumberToDifferentBases(10)\nTriple(\"12\", \"10\", \"A\")\n>>> convertNumberToDifferentBases(255)\nTriple(\"377\", \"255\", \"FF\")\n>>> convertNumberToDifferentBases(16)\nTriple(\"20\", \"16\", \"10\")",
      "sq": "Shkruani një funksion Kotlin `fun convertNumberToDifferentBases(number: Int): Triple<String, String, String>` për të zgjidhur problemin e mëposhtëm:\nKonverton një numër të dhënë të plotë në përfaqësimet e tij oktale, dhjetore dhe heksadecimale.\nArgumentet:\nnumber: Një numër i plotë që do të konvertohet.\nKthen:\nNjë Triple që përmban përfaqësimet oktale, dhjetore dhe heksadecimale të numrit.\nShembuj:\n>>> convertNumberToDifferentBases(10)\nTriple(\"12\", \"10\", \"A\")\n>>> convertNumberToDifferentBases(255)\nTriple(\"377\", \"255\", \"FF\")\n>>> convertNumberToDifferentBases(16)\nTriple(\"20\", \"16\", \"10\")",
      "hy": "Գրեք Kotlin ֆունկցիա `fun convertNumberToDifferentBases(number: Int): Triple<String, String, String>` հետևյալ խնդիրը լուծելու համար:\nՓոխակերպում է տրված ամբողջ թիվը իր ութական, տասնորդական և տասնվեցական ներկայացումներին:\nԱրգումենտներ:\nnumber: Փոխակերպվող ամբողջ թիվ:\nՎերադարձնում է:\nTriple, որը պարունակում է թվի ութական, տասնորդական և տասնվեցական ներկայացումները:\nՕրինակներ:\n>>> convertNumberToDifferentBases(10)\nTriple(\"12\", \"10\", \"A\")\n>>> convertNumberToDifferentBases(255)\nTriple(\"377\", \"255\", \"FF\")\n>>> convertNumberToDifferentBases(16)\nTriple(\"20\", \"16\", \"10\")",
      "bn": "Kotlin ফাংশন `fun convertNumberToDifferentBases(number: Int): Triple<String, String, String>` লিখুন নিম্নলিখিত সমস্যার সমাধানের জন্য:\nএকটি প্রদত্ত পূর্ণসংখ্যাকে তার অষ্টম, দশম, এবং ষোড়শ ভিত্তির উপস্থাপনায় রূপান্তর করে।\nআর্গুমেন্টসমূহ:\nnumber: একটি পূর্ণসংখ্যা যা রূপান্তরিত হবে।\nরিটার্নস:\nএকটি Triple যা সংখ্যাটির অষ্টম, দশম, এবং ষোড়শ ভিত্তির উপস্থাপনা ধারণ করে।\nউদাহরণসমূহ:\n>>> convertNumberToDifferentBases(10)\nTriple(\"12\", \"10\", \"A\")\n>>> convertNumberToDifferentBases(255)\nTriple(\"377\", \"255\", \"FF\")\n>>> convertNumberToDifferentBases(16)\nTriple(\"20\", \"16\", \"10\")",
      "bg": "Напишете Kotlin функция `fun convertNumberToDifferentBases(number: Int): Triple<String, String, String>` за да решите следния проблем:\nПреобразува дадено цяло число в неговите осмична, десетична и шестнадесетична представяния.\nАргументи:\nnumber: Цяло число, което да бъде преобразувано.\nВръща:\nТроен кортеж, съдържащ осмичното, десетичното и шестнадесетичното представяне на числото.\nПримери:\n>>> convertNumberToDifferentBases(10)\nTriple(\"12\", \"10\", \"A\")\n>>> convertNumberToDifferentBases(255)\nTriple(\"377\", \"255\", \"FF\")\n>>> convertNumberToDifferentBases(16)\nTriple(\"20\", \"16\", \"10\")",
      "zh": "编写一个 Kotlin 函数 `fun convertNumberToDifferentBases(number: Int): Triple<String, String, String>` 来解决以下问题：\n将给定的整数转换为其八进制、十进制和十六进制表示。\n参数：\nnumber: 要转换的整数。\n返回：\n一个 Triple，包含该数字的八进制、十进制和十六进制表示。\n示例：\n>>> convertNumberToDifferentBases(10)\nTriple(\"12\", \"10\", \"A\")\n>>> convertNumberToDifferentBases(255)\nTriple(\"377\", \"255\", \"FF\")\n>>> convertNumberToDifferentBases(16)\nTriple(\"20\", \"16\", \"10\")",
      "fr": "Écrire une fonction Kotlin `fun convertNumberToDifferentBases(number: Int): Triple<String, String, String>` pour résoudre le problème suivant :\nConvertit un entier donné en ses représentations octale, décimale et hexadécimale.\nArgs:\nnumber: Un nombre entier à convertir.\nReturns:\nUn Triple contenant les représentations octale, décimale et hexadécimale du nombre.\nExemples:\n>>> convertNumberToDifferentBases(10)\nTriple(\"12\", \"10\", \"A\")\n>>> convertNumberToDifferentBases(255)\nTriple(\"377\", \"255\", \"FF\")\n>>> convertNumberToDifferentBases(16)\nTriple(\"20\", \"16\", \"10\")",
      "de": "Schreiben Sie eine Kotlin-Funktion `fun convertNumberToDifferentBases(number: Int): Triple<String, String, String>`, um das folgende Problem zu lösen:\nKonvertiert eine gegebene ganze Zahl in ihre oktale, dezimale und hexadezimale Darstellung.\nArgumente:\nnumber: Eine ganze Zahl, die konvertiert werden soll.\nRückgabewerte:\nEin Triple, das die oktale, dezimale und hexadezimale Darstellung der Zahl enthält.\nBeispiele:\n>>> convertNumberToDifferentBases(10)\nTriple(\"12\", \"10\", \"A\")\n>>> convertNumberToDifferentBases(255)\nTriple(\"377\", \"255\", \"FF\")\n>>> convertNumberToDifferentBases(16)\nTriple(\"20\", \"16\", \"10\")",
      "ha": "Rubuta aikin Kotlin `fun convertNumberToDifferentBases(number: Int): Triple<String, String, String>` don warware matsalar mai zuwa:\nYa canza wani cikakken lamba zuwa wakilcinsa na octal, decimal, da hexadecimal.\nArgs:\nnumber: Wani cikakken lamba da za a canza.\nReturns:\nWani Triple wanda ke dauke da wakilci na octal, decimal, da hexadecimal na lambar.\nMisalai:\n>>> convertNumberToDifferentBases(10)\nTriple(\"12\", \"10\", \"A\")\n>>> convertNumberToDifferentBases(255)\nTriple(\"377\", \"255\", \"FF\")\n>>> convertNumberToDifferentBases(16)\nTriple(\"20\", \"16\", \"10\")",
      "hi": "Kotlin फ़ंक्शन `fun convertNumberToDifferentBases(number: Int): Triple<String, String, String>` लिखें ताकि निम्नलिखित समस्या का समाधान किया जा सके:\nदिए गए पूर्णांक को इसके अष्टाधारी, दशमलव, और षोडशाधारी रूपांतरणों में परिवर्तित करता है।\nआर्ग्स:\nnumber: एक पूर्णांक संख्या जिसे परिवर्तित किया जाना है।\nरिटर्न्स:\nएक ट्रिपल जिसमें संख्या के अष्टाधारी, दशमलव, और षोडशाधारी रूपांतरण शामिल हैं।\nउदाहरण:\n>>> convertNumberToDifferentBases(10)\nTriple(\"12\", \"10\", \"A\")\n>>> convertNumberToDifferentBases(255)\nTriple(\"377\", \"255\", \"FF\")\n>>> convertNumberToDifferentBases(16)\nTriple(\"20\", \"16\", \"10\")",
      "hu": "Írj egy Kotlin függvényt `fun convertNumberToDifferentBases(number: Int): Triple<String, String, String>` a következő probléma megoldására:\nEgy adott egész számot átalakít oktális, decimális és hexadecimális reprezentációira.\nArgs:\nnumber: Egy egész szám, amelyet át kell alakítani.\nReturns:\nEgy Triple, amely tartalmazza a szám oktális, decimális és hexadecimális reprezentációit.\nPéldák:\n>>> convertNumberToDifferentBases(10)\nTriple(\"12\", \"10\", \"A\")\n>>> convertNumberToDifferentBases(255)\nTriple(\"377\", \"255\", \"FF\")\n>>> convertNumberToDifferentBases(16)\nTriple(\"20\", \"16\", \"10\")"
    },
    "instruction_bertscore": {
      "sq": "0.9896867133559065",
      "hy": "0.9872040322233515",
      "bn": "0.9680820840715039",
      "bg": "0.9799852082854005",
      "zh": "0.9767219097553783",
      "fr": "0.9910570643546662",
      "de": "0.9836638429421667",
      "ha": "0.9799599822270091",
      "hi": "0.973173179367809",
      "hu": "0.9904782554243305"
    },
    "level": "easy",
    "test": "fun main() {\n    check(convertNumberToDifferentBases(10) == Triple(\"12\", \"10\", \"A\"))\n    check(convertNumberToDifferentBases(255) == Triple(\"377\", \"255\", \"FF\"))\n    check(convertNumberToDifferentBases(16) == Triple(\"20\", \"16\", \"10\"))\n    check(convertNumberToDifferentBases(1) == Triple(\"1\", \"1\", \"1\"))\n    check(convertNumberToDifferentBases(0) == Triple(\"0\", \"0\", \"0\"))\n    check(convertNumberToDifferentBases(100) == Triple(\"144\", \"100\", \"64\"))\n    check(convertNumberToDifferentBases(500) == Triple(\"764\", \"500\", \"1F4\"))\n}\n\nmain()",
    "entry_point": "convertNumberToDifferentBases",
    "signature": "fun convertNumberToDifferentBases(number: Int): Triple<String, String, String>",
    "docstring": {
      "en": "Converts a given integer to its octal, decimal, and hexadecimal representations.\nArgs:\nnumber: An integer number to be converted.\nReturns:\nA Triple containing the octal, decimal, and hexadecimal representations of the number.\nExamples:\n>>> convertNumberToDifferentBases(10)\nTriple(\"12\", \"10\", \"A\")\n>>> convertNumberToDifferentBases(255)\nTriple(\"377\", \"255\", \"FF\")\n>>> convertNumberToDifferentBases(16)\nTriple(\"20\", \"16\", \"10\")",
      "sq": "Konverton një numër të dhënë të plotë në përfaqësimet e tij oktale, dhjetore dhe heksadecimale.\nArgumentet:\nnumber: Një numër i plotë që do të konvertohet.\nKthen:\nNjë Triple që përmban përfaqësimet oktale, dhjetore dhe heksadecimale të numrit.\nShembuj:\n>>> convertNumberToDifferentBases(10)\nTriple(\"12\", \"10\", \"A\")\n>>> convertNumberToDifferentBases(255)\nTriple(\"377\", \"255\", \"FF\")\n>>> convertNumberToDifferentBases(16)\nTriple(\"20\", \"16\", \"10\")",
      "hy": "Փոխակերպում է տրված ամբողջ թիվը նրա ութական, տասնորդական և տասնվեցական ներկայացումներին:\nԱրգումենտներ:\nnumber: Ամբողջ թիվ, որը պետք է փոխակերպվի:\nՎերադարձնում է:\nԵռյակ, որը պարունակում է թվի ութական, տասնորդական և տասնվեցական ներկայացումները:\nՕրինակներ:\n>>> convertNumberToDifferentBases(10)\nTriple(\"12\", \"10\", \"A\")\n>>> convertNumberToDifferentBases(255)\nTriple(\"377\", \"255\", \"FF\")\n>>> convertNumberToDifferentBases(16)\nTriple(\"20\", \"16\", \"10\")",
      "bn": "একটি প্রদত্ত পূর্ণসংখ্যাকে এর অক্টাল, দশমিক এবং হেক্সাডেসিমাল উপস্থাপনে রূপান্তর করে।\nআর্গস:\nnumber: একটি পূর্ণসংখ্যা যা রূপান্তরিত হবে।\nরিটার্নস:\nএকটি ট্রিপল যা সংখ্যার অক্টাল, দশমিক এবং হেক্সাডেসিমাল উপস্থাপন ধারণ করে।\nউদাহরণ:\n>>> convertNumberToDifferentBases(10)\nTriple(\"12\", \"10\", \"A\")\n>>> convertNumberToDifferentBases(255)\nTriple(\"377\", \"255\", \"FF\")\n>>> convertNumberToDifferentBases(16)\nTriple(\"20\", \"16\", \"10\")",
      "bg": "Преобразува дадено цяло число в неговите осмична, десетична и шестнадесетична представяния.\nАргументи:\nnumber: Цяло число, което да бъде преобразувано.\nВръща:\nТройка, съдържаща осмичното, десетичното и шестнадесетичното представяне на числото.\nПримери:\n>>> convertNumberToDifferentBases(10)\nTriple(\"12\", \"10\", \"A\")\n>>> convertNumberToDifferentBases(255)\nTriple(\"377\", \"255\", \"FF\")\n>>> convertNumberToDifferentBases(16)\nTriple(\"20\", \"16\", \"10\")",
      "zh": "将给定的整数转换为其八进制、十进制和十六进制表示形式。\n参数：\nnumber: 要转换的整数。\n返回：\n一个包含该数字的八进制、十进制和十六进制表示形式的Triple。\n示例：\n>>> convertNumberToDifferentBases(10)\nTriple(\"12\", \"10\", \"A\")\n>>> convertNumberToDifferentBases(255)\nTriple(\"377\", \"255\", \"FF\")\n>>> convertNumberToDifferentBases(16)\nTriple(\"20\", \"16\", \"10\")",
      "fr": "Convertit un entier donné en ses représentations octale, décimale et hexadécimale.\nArgs:\nnumber: Un nombre entier à convertir.\nReturns:\nUn Triple contenant les représentations octale, décimale et hexadécimale du nombre.\nExamples:\n>>> convertNumberToDifferentBases(10)\nTriple(\"12\", \"10\", \"A\")\n>>> convertNumberToDifferentBases(255)\nTriple(\"377\", \"255\", \"FF\")\n>>> convertNumberToDifferentBases(16)\nTriple(\"20\", \"16\", \"10\")",
      "de": "Konvertiert eine gegebene ganze Zahl in ihre oktale, dezimale und hexadezimale Darstellung.\nArgs:\nnumber: Eine ganze Zahl, die konvertiert werden soll.\nReturns:\nEin Triple, das die oktale, dezimale und hexadezimale Darstellung der Zahl enthält.\nExamples:\n>>> convertNumberToDifferentBases(10)\nTriple(\"12\", \"10\", \"A\")\n>>> convertNumberToDifferentBases(255)\nTriple(\"377\", \"255\", \"FF\")\n>>> convertNumberToDifferentBases(16)\nTriple(\"20\", \"16\", \"10\")",
      "ha": "Canza wani cikakken lamba zuwa wakilcinsa na octal, decimal, da hexadecimal.\nArgs:\nnumber: Wani lamba mai cikakken adadi da za a canza.\nReturns:\nA Triple containing the octal, decimal, and hexadecimal representations of the number.\nExamples:\n>>> convertNumberToDifferentBases(10)\nTriple(\"12\", \"10\", \"A\")\n>>> convertNumberToDifferentBases(255)\nTriple(\"377\", \"255\", \"FF\")\n>>> convertNumberToDifferentBases(16)\nTriple(\"20\", \"16\", \"10\")",
      "hi": "दिए गए पूर्णांक को इसके अष्टाधारी, दाशमिक, और षोडशाधारी रूपांतरणों में बदलता है।\nआर्ग्स:\nnumber: एक पूर्णांक संख्या जिसे रूपांतरित किया जाना है।\nरिटर्न्स:\nएक Triple जिसमें संख्या के अष्टाधारी, दाशमिक, और षोडशाधारी रूपांतरण शामिल हैं।\nउदाहरण:\n>>> convertNumberToDifferentBases(10)\nTriple(\"12\", \"10\", \"A\")\n>>> convertNumberToDifferentBases(255)\nTriple(\"377\", \"255\", \"FF\")\n>>> convertNumberToDifferentBases(16)\nTriple(\"20\", \"16\", \"10\")",
      "hu": "Átalakít egy adott egész számot annak oktális, decimális és hexadecimális reprezentációira.\nArgs:\nnumber: Egy egész szám, amelyet át kell alakítani.\nReturns:\nEgy Triple, amely tartalmazza a szám oktális, decimális és hexadecimális reprezentációit.\nExamples:\n>>> convertNumberToDifferentBases(10)\nTriple(\"12\", \"10\", \"A\")\n>>> convertNumberToDifferentBases(255)\nTriple(\"377\", \"255\", \"FF\")\n>>> convertNumberToDifferentBases(16)\nTriple(\"20\", \"16\", \"10\")"
    },
    "docstring_bertscore": {
      "sq": "0.9891438565245382",
      "hy": "0.980375119723372",
      "bn": "0.9847433990630913",
      "bg": "0.9839208706552258",
      "zh": "0.9710933206479927",
      "fr": "0.9885650475942025",
      "de": "0.9897639805741291",
      "ha": "0.9961598788434525",
      "hi": "0.9849195842110692",
      "hu": "0.9893635417259627"
    }
  },
  {
    "task_id": "Kotlin/14",
    "prompt": {
      "en": "/**\n * Returns a list of all factors of the given number, excluding the number itself.\n * A factor is a number that divides the given number without leaving a remainder.\n * Examples:\n * >>> listFactors(10)\n * [1, 2, 5]\n * >>> listFactors(15)\n * [1, 3, 5]\n * >>> listFactors(7)\n * [1]\n */\n\nfun listFactors(number: Int): List<Int> ",
      "sq": "/**\n * Kthen një listë të të gjithë faktorëve të numrit të dhënë, duke përjashtuar vetë numrin.\n * Një faktor është një numër që e ndan numrin e dhënë pa lënë mbetje.\n * Shembuj:\n * >>> listFactors(10)\n * [1, 2, 5]\n * >>> listFactors(15)\n * [1, 3, 5]\n * >>> listFactors(7)\n * [1]\n */ \n\nfun listFactors(number: Int): List<Int> ",
      "hy": "/**\n * Վերադարձնում է տրված թվի բոլոր գործոնների ցանկը, բացառությամբ ինքը՝ թիվը։\n * Գործոնը թիվ է, որը բաժանում է տրված թիվը առանց մնացորդի։\n * Օրինակներ:\n * >>> listFactors(10)\n * [1, 2, 5]\n * >>> listFactors(15)\n * [1, 3, 5]\n * >>> listFactors(7)\n * [1]\n */ \n\nfun listFactors(number: Int): List<Int> ",
      "bn": "/**\n * প্রদত্ত সংখ্যার সকল গুণনীয়কের একটি তালিকা প্রদান করে, সংখ্যাটি নিজেকে বাদ দিয়ে।\n * একটি গুণনীয়ক হল এমন একটি সংখ্যা যা প্রদত্ত সংখ্যাকে অবশিষ্টাংশ ছাড়া ভাগ করে।\n * উদাহরণস্বরূপ:\n * >>> listFactors(10)\n * [1, 2, 5]\n * >>> listFactors(15)\n * [1, 3, 5]\n * >>> listFactors(7)\n * [1]\n */ \n\nfun listFactors(number: Int): List<Int> ",
      "bg": "/**\n * Връща списък с всички делители на даденото число, без да включва самото число.\n * Делител е число, което дели даденото число без да оставя остатък.\n * Примери:\n * >>> listFactors(10)\n * [1, 2, 5]\n * >>> listFactors(15)\n * [1, 3, 5]\n * >>> listFactors(7)\n * [1]\n */ \n\nfun listFactors(number: Int): List<Int> ",
      "zh": "/**\n * 返回给定数字的所有因子的列表，不包括数字本身。\n * 因子是能够整除给定数字且不留余数的数字。\n * 例子:\n * >>> listFactors(10)\n * [1, 2, 5]\n * >>> listFactors(15)\n * [1, 3, 5]\n * >>> listFactors(7)\n * [1]\n */ \n\nfun listFactors(number: Int): List<Int> ",
      "fr": "/**\n * Retourne une liste de tous les facteurs du nombre donné, à l'exclusion du nombre lui-même.\n * Un facteur est un nombre qui divise le nombre donné sans laisser de reste.\n * Exemples :\n * >>> listFactors(10)\n * [1, 2, 5]\n * >>> listFactors(15)\n * [1, 3, 5]\n * >>> listFactors(7)\n * [1]\n */ \n\nfun listFactors(number: Int): List<Int> ",
      "de": "/**\n * Gibt eine Liste aller Faktoren der gegebenen Zahl zurück, ausgenommen die Zahl selbst.\n * Ein Faktor ist eine Zahl, die die gegebene Zahl ohne Rest teilt.\n * Beispiele:\n * >>> listFactors(10)\n * [1, 2, 5]\n * >>> listFactors(15)\n * [1, 3, 5]\n * >>> listFactors(7)\n * [1]\n */ \n\nfun listFactors(number: Int): List<Int> ",
      "ha": "/**\n * Yana dawo da jerin dukkan abubuwan da ke raba lambar da aka bayar, banda lambar kanta.\n * Abin raba shi ne lamba da ke raba lambar da aka bayar ba tare da saura ba.\n * Misalai:\n * >>> listFactors(10)\n * [1, 2, 5]\n * >>> listFactors(15)\n * [1, 3, 5]\n * >>> listFactors(7)\n * [1]\n */ \n\nfun listFactors(number: Int): List<Int> ",
      "hi": "/**\n * दिए गए संख्या के सभी गुणकों की सूची लौटाता है, स्वयं संख्या को छोड़कर।\n * एक गुणक वह संख्या है जो दिए गए संख्या को बिना शेष के विभाजित करती है।\n * उदाहरण:\n * >>> listFactors(10)\n * [1, 2, 5]\n * >>> listFactors(15)\n * [1, 3, 5]\n * >>> listFactors(7)\n * [1]\n */ \n\nfun listFactors(number: Int): List<Int> ",
      "hu": "/**\n * Visszaadja az adott szám összes osztójának listáját, kivéve magát a számot.\n * Egy osztó olyan szám, amely osztja az adott számot maradék nélkül.\n * Példák:\n * >>> listFactors(10)\n * [1, 2, 5]\n * >>> listFactors(15)\n * [1, 3, 5]\n * >>> listFactors(7)\n * [1]\n */ \n\nfun listFactors(number: Int): List<Int> "
    },
    "prompt_bertscore": {
      "sq": "1",
      "hy": "0.9939989789281739",
      "bn": "0.9493432939246724",
      "bg": "0.9641116613849975",
      "zh": "0.9863451544557567",
      "fr": "0.9968068179944831",
      "de": "0.9939989789281739",
      "ha": "0.9622491043020333",
      "hi": "0.992314196036236",
      "hu": "0.9622491043020333"
    },
    "canonical_solution": "{\n    val factors = mutableListOf<Int>()\n    for (i in 1 until number) {\n        if (number % i == 0) {\n            factors.add(i)\n        }\n    }\n    return factors\n}",
    "instruction": {
      "en": "Write a Kotlin function `fun listFactors(number: Int): List<Int>` to solve the following problem:\nReturns a list of all factors of the given number, excluding the number itself.\nA factor is a number that divides the given number without leaving a remainder.\nExamples:\n>>> listFactors(10)\n[1, 2, 5]\n>>> listFactors(15)\n[1, 3, 5]\n>>> listFactors(7)\n[1]",
      "sq": "Shkruani një funksion Kotlin `fun listFactors(number: Int): List<Int>` për të zgjidhur problemin e mëposhtëm:  \nKthen një listë të të gjithë faktorëve të numrit të dhënë, duke përjashtuar vetë numrin.  \nNjë faktor është një numër që e ndan numrin e dhënë pa lënë mbetje.  \nShembuj:  \n>>> listFactors(10)  \n[1, 2, 5]  \n>>> listFactors(15)  \n[1, 3, 5]  \n>>> listFactors(7)  \n[1]  ",
      "hy": "Գրեք Kotlin ֆունկցիա `fun listFactors(number: Int): List<Int>` հետևյալ խնդիրը լուծելու համար:\nՎերադարձնում է տրված թվի բոլոր գործոնների ցուցակը, բացառությամբ հենց այդ թվի:\nԳործոնը թիվ է, որը բաժանում է տրված թիվը առանց մնացորդի:\nՕրինակներ:\n>>> listFactors(10)\n[1, 2, 5]\n>>> listFactors(15)\n[1, 3, 5]\n>>> listFactors(7)\n[1]",
      "bn": "Kotlin ফাংশন `fun listFactors(number: Int): List<Int>` লিখুন নিম্নলিখিত সমস্যার সমাধানের জন্য:\nপ্রদত্ত সংখ্যার সমস্ত গুণনীয়কের একটি তালিকা ফেরত দেয়, সংখ্যা নিজে বাদে।\nএকটি গুণনীয়ক হল এমন একটি সংখ্যা যা প্রদত্ত সংখ্যাকে ভাগ করে কোনো অবশিষ্টাংশ ছাড়াই।\nউদাহরণ:\n>>> listFactors(10)\n[1, 2, 5]\n>>> listFactors(15)\n[1, 3, 5]\n>>> listFactors(7)\n[1]",
      "bg": "Напишете Kotlin функция `fun listFactors(number: Int): List<Int>` за решаване на следния проблем:\nВръща списък с всички делители на даденото число, с изключение на самото число.\nДелител е число, което дели даденото число без остатък.\nПримери:\n>>> listFactors(10)\n[1, 2, 5]\n>>> listFactors(15)\n[1, 3, 5]\n>>> listFactors(7)\n[1]",
      "zh": "编写一个 Kotlin 函数 `fun listFactors(number: Int): List<Int>` 来解决以下问题：\n返回给定数字的所有因子的列表，不包括数字本身。\n因子是指可以整除给定数字且不留余数的数字。\n示例：\n>>> listFactors(10)\n[1, 2, 5]\n>>> listFactors(15)\n[1, 3, 5]\n>>> listFactors(7)\n[1]",
      "fr": "Écrire une fonction Kotlin `fun listFactors(number: Int): List<Int>` pour résoudre le problème suivant :\nRenvoie une liste de tous les facteurs du nombre donné, à l'exclusion du nombre lui-même.\nUn facteur est un nombre qui divise le nombre donné sans laisser de reste.\nExemples:\n>>> listFactors(10)\n[1, 2, 5]\n>>> listFactors(15)\n[1, 3, 5]\n>>> listFactors(7)\n[1]",
      "de": "Schreiben Sie eine Kotlin-Funktion `fun listFactors(number: Int): List<Int>`, um das folgende Problem zu lösen:\nGibt eine Liste aller Faktoren der gegebenen Zahl zurück, ausgenommen die Zahl selbst.\nEin Faktor ist eine Zahl, die die gegebene Zahl ohne Rest teilt.\nBeispiele:\n>>> listFactors(10)\n[1, 2, 5]\n>>> listFactors(15)\n[1, 3, 5]\n>>> listFactors(7)\n[1]",
      "ha": "Rubuta wani aikin Kotlin `fun listFactors(number: Int): List<Int>` don warware matsalar mai zuwa:\nYa dawo da jerin dukkan abubuwan da suka dace da lambar da aka bayar, banda lambar kanta.\nAbu mai dacewa shi ne lamba da ke raba lambar da aka bayar ba tare da saura ba.\nMisalai:\n>>> listFactors(10)\n[1, 2, 5]\n>>> listFactors(15)\n[1, 3, 5]\n>>> listFactors(7)\n[1]",
      "hi": "Kotlin फ़ंक्शन `fun listFactors(number: Int): List<Int>` लिखें ताकि निम्नलिखित समस्या का समाधान किया जा सके:\nदिए गए संख्या के सभी गुणकों की एक सूची लौटाता है, जिसमें संख्या स्वयं शामिल नहीं होती।\nएक गुणक वह संख्या होती है जो बिना शेष के दिए गए संख्या को विभाजित करती है।\nउदाहरण:\n>>> listFactors(10)\n[1, 2, 5]\n>>> listFactors(15)\n[1, 3, 5]\n>>> listFactors(7)\n[1]",
      "hu": "Írj egy Kotlin függvényt `fun listFactors(number: Int): List<Int>` a következő probléma megoldására:\nVisszaadja a megadott szám összes osztójának listáját, kivéve magát a számot.\nEgy osztó olyan szám, amely maradék nélkül osztja a megadott számot.\nPéldák:\n>>> listFactors(10)\n[1, 2, 5]\n>>> listFactors(15)\n[1, 3, 5]\n>>> listFactors(7)\n[1]"
    },
    "instruction_bertscore": {
      "sq": "0.999999801369619",
      "hy": "0.9900239877429038",
      "bn": "0.9722235275160812",
      "bg": "0.9949601513420018",
      "zh": "0.980574147365169",
      "fr": "0.999999801369619",
      "de": "0.9922955247804187",
      "ha": "0.9934451974258487",
      "hi": "0.9750617570306888",
      "hu": "0.9616836036072269"
    },
    "level": "easy",
    "test": "fun main(){\n    check(listFactors(10) == listOf(1, 2, 5))\n    check(listFactors(15) == listOf(1, 3, 5))\n    check(listFactors(7) == listOf(1))\n    check(listFactors(12) == listOf(1, 2, 3, 4, 6))\n    check(listFactors(9) == listOf(1, 3))\n    check(listFactors(17) == listOf(1))\n    check(listFactors(20) == listOf(1, 2, 4, 5, 10))\n}\n\nmain()",
    "entry_point": "listFactors",
    "signature": "fun listFactors(number: Int): List<Int>",
    "docstring": {
      "en": "Returns a list of all factors of the given number, excluding the number itself.\nA factor is a number that divides the given number without leaving a remainder.\nExamples:\n>>> listFactors(10)\n[1, 2, 5]\n>>> listFactors(15)\n[1, 3, 5]\n>>> listFactors(7)\n[1]",
      "sq": "Kthen një listë të të gjithë faktorëve të numrit të dhënë, duke përjashtuar vetë numrin.\nNjë faktor është një numër që ndan numrin e dhënë pa lënë mbetje.\nShembuj:\n>>> listFactors(10)\n[1, 2, 5]\n>>> listFactors(15)\n[1, 3, 5]\n>>> listFactors(7)\n[1]",
      "hy": "Վերադարձնում է տրված թվի բոլոր գործակիցների ցանկը՝ բացառությամբ հենց այդ թվի։  \nԳործակիցը այն թիվն է, որը բաժանում է տրված թիվը առանց մնացորդի։  \nՕրինակներ:  \n>>> listFactors(10)  \n[1, 2, 5]  \n>>> listFactors(15)  \n[1, 3, 5]  \n>>> listFactors(7)  \n[1]",
      "bn": "প্রদত্ত সংখ্যার সকল গুণনীয়ক (ফ্যাক্টর) এর একটি তালিকা প্রদান করে, যা সংখ্যাটিকে বাদ দেয়। একটি গুণনীয়ক হল এমন একটি সংখ্যা যা প্রদত্ত সংখ্যাটিকে অবশিষ্টাংশ ছাড়াই ভাগ করে।\nউদাহরণসমূহ:\n>>> listFactors(10)\n[1, 2, 5]\n>>> listFactors(15)\n[1, 3, 5]\n>>> listFactors(7)\n[1]",
      "bg": "Връща списък с всички делители на даденото число, без самото число.\nДелител е число, което дели даденото число, без да оставя остатък.\nПримери:\n>>> listFactors(10)\n[1, 2, 5]\n>>> listFactors(15)\n[1, 3, 5]\n>>> listFactors(7)\n[1]",
      "zh": "返回给定数字的所有因子列表，不包括数字本身。  \n因子是能够整除给定数字且不留余数的数字。  \n示例:  \n>>> listFactors(10)  \n[1, 2, 5]  \n>>> listFactors(15)  \n[1, 3, 5]  \n>>> listFactors(7)  \n[1]",
      "fr": "Renvoie une liste de tous les facteurs du nombre donné, à l'exclusion du nombre lui-même.\nUn facteur est un nombre qui divise le nombre donné sans laisser de reste.\nExemples :\n>>> listFactors(10)\n[1, 2, 5]\n>>> listFactors(15)\n[1, 3, 5]\n>>> listFactors(7)\n[1]",
      "de": "Gibt eine Liste aller Faktoren der gegebenen Zahl zurück, wobei die Zahl selbst ausgeschlossen ist.\nEin Faktor ist eine Zahl, die die gegebene Zahl ohne Rest teilt.\nBeispiele:\n>>> listFactors(10)\n[1, 2, 5]\n>>> listFactors(15)\n[1, 3, 5]\n>>> listFactors(7)\n[1]",
      "ha": "Yana dawo da jerin dukkan abubuwan da ke cikin lambar da aka bayar, ban da lambar kanta.\nAbu ne wanda ke raba lambar da aka bayar ba tare da barin saura ba.\nMisalai:\n>>> listFactors(10)\n[1, 2, 5]\n>>> listFactors(15)\n[1, 3, 5]\n>>> listFactors(7)\n[1]",
      "hi": "दिए गए संख्या के सभी गुणकों की एक सूची लौटाता है, जिसमें संख्या स्वयं शामिल नहीं होती है। एक गुणक वह संख्या है जो दिए गए संख्या को बिना शेष के विभाजित करती है।\nउदाहरण:\n>>> listFactors(10)\n[1, 2, 5]\n>>> listFactors(15)\n[1, 3, 5]\n>>> listFactors(7)\n[1]",
      "hu": "Visszaadja a megadott szám összes osztójának listáját, a számot magát kivéve.\nEgy osztó olyan szám, amely maradék nélkül osztja a megadott számot.\nPéldák:\n>>> listFactors(10)\n[1, 2, 5]\n>>> listFactors(15)\n[1, 3, 5]\n>>> listFactors(7)\n[1]"
    },
    "docstring_bertscore": {
      "sq": "1",
      "hy": "0.9844178438685751",
      "bn": "0.9867998193979455",
      "bg": "0.9572845365584473",
      "zh": "0.976577902729128",
      "fr": "0.9960708924327488",
      "de": "0.9925130250476519",
      "ha": "0.9620985424732088",
      "hi": "0.9905585020982687",
      "hu": "0.9549093144620321"
    }
  },
  {
    "task_id": "Kotlin/15",
    "prompt": {
      "en": "import java.util.LinkedList\n\n/**\n    * Finds the last remaining number in a sequence of n numbers, where numbers are eliminated in a cycle of every third element.\n    * \n    * The process begins with the first element in a sequence from 1 to n, counting up to three. Each time the count reaches three,\n    * the current number is removed from the sequence. This process continues until only one number remains in the sequence.\n    *\n    * Examples:\n    * >>> findLastRemaining(5)\n        4\n    * >>> findLastRemaining(10)\n        4\n**/\n\n\nfun findLastRemaining(n: Int): Int ",
      "sq": "import java.util.LinkedList\n\n/**\n    * Gjen numrin e fundit të mbetur në një sekuencë prej n numrash, ku numrat eliminohen në një cikël të çdo elementi të tretë.\n    * \n    * Procesi fillon me elementin e parë në një sekuencë nga 1 deri në n, duke numëruar deri në tre. Sa herë që numërimi arrin tre,\n    * numri aktual hiqet nga sekuenca. Ky proces vazhdon derisa të mbetet vetëm një numër në sekuencë.\n    *\n    * Shembuj:\n    * >>> findLastRemaining(5)\n        4\n    * >>> findLastRemaining(10)\n        4\n**/\n\n\nfun findLastRemaining(n: Int): Int ",
      "hy": "import java.util.LinkedList\n\n/**\n    * Գտնում է n թվերի հաջորդականության մեջ վերջին մնացած թիվը, որտեղ թվերը վերացվում են յուրաքանչյուր երրորդ տարրի ցիկլով:\n    * \n    * Գործընթացը սկսվում է հաջորդականության առաջին տարրից 1-ից n, հաշվելով մինչև երեք: Ամեն անգամ, երբ հաշիվը հասնում է երեքի,\n    * ընթացիկ թիվը հեռացվում է հաջորդականությունից: Այս գործընթացը շարունակվում է, մինչև հաջորդականության մեջ մնա միայն մեկ թիվ:\n    *\n    * Օրինակներ:\n    * >>> findLastRemaining(5)\n        4\n    * >>> findLastRemaining(10)\n        4\n**/\n\n\nfun findLastRemaining(n: Int): Int ",
      "bn": "import java.util.LinkedList\n\n/**\n    * n সংখ্যার একটি ক্রমে শেষ অবশিষ্ট সংখ্যাটি খুঁজে বের করে, যেখানে প্রতিটি তৃতীয় উপাদানের একটি চক্রে সংখ্যা বাদ দেওয়া হয়।\n    * \n    * প্রক্রিয়াটি 1 থেকে n পর্যন্ত একটি ক্রমের প্রথম উপাদান দিয়ে শুরু হয়, তিন পর্যন্ত গণনা করা হয়। প্রতিবার গণনা তিনে পৌঁছালে,\n    * বর্তমান সংখ্যাটি ক্রম থেকে সরিয়ে ফেলা হয়। এই প্রক্রিয়াটি চলতে থাকে যতক্ষণ না ক্রমে শুধুমাত্র একটি সংখ্যা অবশিষ্ট থাকে।\n    *\n    * উদাহরণ:\n    * >>> findLastRemaining(5)\n        4\n    * >>> findLastRemaining(10)\n        4\n**/\n\n\nfun findLastRemaining(n: Int): Int ",
      "bg": "import java.util.LinkedList\n\n/**\n    * Намира последното останало число в последователност от n числа, където числата се елиминират в цикъл на всеки трети елемент.\n    * \n    * Процесът започва с първия елемент в последователност от 1 до n, като се брои до три. Всеки път, когато броенето достигне три,\n    * текущото число се премахва от последователността. Този процес продължава, докато в последователността остане само едно число.\n    *\n    * Примери:\n    * >>> findLastRemaining(5)\n        4\n    * >>> findLastRemaining(10)\n        4\n**/\n\n\nfun findLastRemaining(n: Int): Int ",
      "zh": "import java.util.LinkedList\n\n/**\n    * 找到 n 个数字序列中最后剩下的数字，其中数字以每第三个元素的循环方式被淘汰。\n    * \n    * 该过程从 1 到 n 的序列中的第一个元素开始，数到三。每次计数到三时，\n    * 当前数字从序列中移除。此过程持续进行，直到序列中只剩下一个数字。\n    *\n    * 示例:\n    * >>> findLastRemaining(5)\n        4\n    * >>> findLastRemaining(10)\n        4\n**/\n\n\nfun findLastRemaining(n: Int): Int ",
      "fr": "import java.util.LinkedList\n\n/**\n    * Trouve le dernier nombre restant dans une séquence de n nombres, où les nombres sont éliminés dans un cycle de chaque troisième élément.\n    * \n    * Le processus commence avec le premier élément d'une séquence de 1 à n, en comptant jusqu'à trois. Chaque fois que le compte atteint trois,\n    * le nombre actuel est retiré de la séquence. Ce processus continue jusqu'à ce qu'il ne reste qu'un seul nombre dans la séquence.\n    *\n    * Exemples :\n    * >>> findLastRemaining(5)\n        4\n    * >>> findLastRemaining(10)\n        4\n**/\n\n\nfun findLastRemaining(n: Int): Int ",
      "de": "import java.util.LinkedList\n\n/**\n    * Findet die letzte verbleibende Zahl in einer Sequenz von n Zahlen, wobei Zahlen in einem Zyklus von jedem dritten Element eliminiert werden.\n    * \n    * Der Prozess beginnt mit dem ersten Element in einer Sequenz von 1 bis n und zählt bis drei. Jedes Mal, wenn der Zähler drei erreicht,\n    * wird die aktuelle Zahl aus der Sequenz entfernt. Dieser Prozess wird fortgesetzt, bis nur noch eine Zahl in der Sequenz verbleibt.\n    *\n    * Beispiele:\n    * >>> findLastRemaining(5)\n        4\n    * >>> findLastRemaining(10)\n        4\n**/\n\n\nfun findLastRemaining(n: Int): Int ",
      "ha": "import java.util.LinkedList\n\n/**\n    * Nemi lambar da ta rage a ƙarshe a cikin jerin lambobi n, inda ake kawar da lambobi a cikin kewayawa na kowane abu na uku.\n    * \n    * Tsarin yana farawa da abu na farko a cikin jerin daga 1 zuwa n, yana ƙidaya har zuwa uku. Duk lokacin da ƙidayar ta kai uku,\n    * ana cire lambar yanzu daga jerin. Wannan tsarin yana ci gaba har sai lamba ɗaya kawai ta rage a cikin jerin.\n    *\n    * Misalai:\n    * >>> findLastRemaining(5)\n        4\n    * >>> findLastRemaining(10)\n        4\n**/\n\n\nfun findLastRemaining(n: Int): Int",
      "hi": "import java.util.LinkedList\n\n/**\n    * n संख्याओं के अनुक्रम में अंतिम शेष संख्या खोजता है, जहाँ संख्याएँ हर तीसरे तत्व के चक्र में समाप्त की जाती हैं।\n    * \n    * प्रक्रिया 1 से n तक के अनुक्रम में पहले तत्व से शुरू होती है, तीन तक गिनती करते हुए। हर बार जब गिनती तीन तक पहुँचती है,\n    * वर्तमान संख्या अनुक्रम से हटा दी जाती है। यह प्रक्रिया तब तक जारी रहती है जब तक अनुक्रम में केवल एक संख्या शेष नहीं रहती।\n    *\n    * उदाहरण:\n    * >>> findLastRemaining(5)\n        4\n    * >>> findLastRemaining(10)\n        4\n**/\n\n\nfun findLastRemaining(n: Int): Int ",
      "hu": "import java.util.LinkedList\n\n/**\n    * Megtalálja az utolsó megmaradó számot egy n számot tartalmazó sorozatban, ahol a számok minden harmadik elem ciklusában kerülnek eltávolításra.\n    * \n    * A folyamat az első elemmel kezdődik egy 1-től n-ig terjedő sorozatban, háromig számolva. Minden alkalommal, amikor a számolás eléri a hármat,\n    * az aktuális szám eltávolításra kerül a sorozatból. Ez a folyamat addig folytatódik, amíg csak egy szám marad a sorozatban.\n    *\n    * Példák:\n    * >>> findLastRemaining(5)\n        4\n    * >>> findLastRemaining(10)\n        4\n**/\n\n\nfun findLastRemaining(n: Int): Int "
    },
    "prompt_bertscore": {
      "sq": "0.994021821421993",
      "hy": "0.9881767251992793",
      "bn": "0.974613448260693",
      "bg": "0.9849438171175555",
      "zh": "0.9590098400481163",
      "fr": "0.9933198616554156",
      "de": "0.9832487054458038",
      "ha": "0.9548747527757321",
      "hi": "0.9917089692652228",
      "hu": "0.9760662308675822"
    },
    "canonical_solution": "{\n    val queue = LinkedList<Int>()\n    for (i in 1..n) {\n        queue.add(i)\n    }\n    var count = 0\n    while (queue.size > 1) {\n        val num = queue.poll()\n        count += 1\n        if (count % 3 != 0) {\n            queue.add(num)\n        }\n    }\n    return queue.poll()\n}",
    "instruction": {
      "en": "Write a Kotlin function `fun findLastRemaining(n: Int): Int` to solve the following problem:\nFinds the last remaining number in a sequence of n numbers, where numbers are eliminated in a cycle of every third element.\n\nThe process begins with the first element in a sequence from 1 to n, counting up to three. Each time the count reaches three,\nthe current number is removed from the sequence. This process continues until only one number remains in the sequence.\n\nExamples:\n>>> findLastRemaining(5)\n4\n>>> findLastRemaining(10)\n4",
      "sq": "Shkruani një funksion Kotlin `fun findLastRemaining(n: Int): Int` për të zgjidhur problemin e mëposhtëm:\nGjen numrin e fundit të mbetur në një sekuencë prej n numrash, ku numrat eliminohen në një cikël të çdo elementi të tretë.\n\nProcesi fillon me elementin e parë në një sekuencë nga 1 deri në n, duke numëruar deri në tre. Sa herë që numërimi arrin tre,\nnumri aktual hiqet nga sekuenca. Ky proces vazhdon derisa të mbetet vetëm një numër në sekuencë.\n\nShembuj:\n>>> findLastRemaining(5)\n4\n>>> findLastRemaining(10)\n4",
      "hy": "Գրեք Kotlin ֆունկցիա `fun findLastRemaining(n: Int): Int` հետևյալ խնդիրը լուծելու համար:\nԳտնում է վերջին մնացած թիվը n թվերի հաջորդականությունում, որտեղ թվերը հեռացվում են յուրաքանչյուր երրորդ տարրի ցիկլով:\n\nԳործընթացը սկսվում է հաջորդականության առաջին տարրից՝ 1-ից n, հաշվելով մինչև երեք: Ամեն անգամ, երբ հաշիվը հասնում է երեքի,\nընթացիկ թիվը հեռացվում է հաջորդականությունից: Այս գործընթացը շարունակվում է, մինչև հաջորդականությունում մնա միայն մեկ թիվ:\n\nՕրինակներ:\n>>> findLastRemaining(5)\n4\n>>> findLastRemaining(10)\n4",
      "bn": "Kotlin ফাংশন `fun findLastRemaining(n: Int): Int` লিখুন নিম্নলিখিত সমস্যার সমাধানের জন্য:\nএকটি n সংখ্যার ক্রমে শেষ অবশিষ্ট সংখ্যাটি খুঁজে বের করুন, যেখানে সংখ্যাগুলি প্রতি তৃতীয় উপাদানের একটি চক্রে বাদ দেওয়া হয়।\n\nপ্রক্রিয়াটি 1 থেকে n পর্যন্ত একটি ক্রমের প্রথম উপাদান দিয়ে শুরু হয়, তিন পর্যন্ত গণনা করে। প্রতিবার গণনা তিনে পৌঁছালে,\nবর্তমান সংখ্যাটি ক্রম থেকে সরিয়ে ফেলা হয়। এই প্রক্রিয়াটি চলতে থাকে যতক্ষণ না ক্রমে কেবল একটি সংখ্যা অবশিষ্ট থাকে।\n\nউদাহরণ:\n>>> findLastRemaining(5)\n4\n>>> findLastRemaining(10)\n4",
      "bg": "Напишете Kotlin функция `fun findLastRemaining(n: Int): Int`, за да решите следния проблем:  \nНамира последното останало число в последователност от n числа, където числата се елиминират в цикъл на всеки трети елемент.\n\nПроцесът започва с първия елемент в последователност от 1 до n, като се брои до три. Всеки път, когато броят достигне три, текущото число се премахва от последователността. Този процес продължава, докато в последователността остане само едно число.\n\nПримери:\n>>> findLastRemaining(5)\n4\n>>> findLastRemaining(10)\n4",
      "zh": "编写一个 Kotlin 函数 `fun findLastRemaining(n: Int): Int` 来解决以下问题：  \n在 n 个数字的序列中找到最后剩下的数字，其中数字以每三个元素为一个周期被淘汰。\n\n该过程从序列中的第一个元素开始，从 1 到 n 计数到三。每当计数到三时，当前数字就从序列中移除。这个过程持续进行，直到序列中只剩下一个数字。\n\n示例:  \n>>> findLastRemaining(5)  \n4  \n>>> findLastRemaining(10)  \n4  ",
      "fr": "Écrire une fonction Kotlin `fun findLastRemaining(n: Int): Int` pour résoudre le problème suivant :  \nTrouver le dernier numéro restant dans une séquence de n numéros, où les numéros sont éliminés dans un cycle de chaque troisième élément.\n\nLe processus commence avec le premier élément dans une séquence de 1 à n, en comptant jusqu'à trois. Chaque fois que le compte atteint trois, le numéro actuel est retiré de la séquence. Ce processus continue jusqu'à ce qu'il ne reste qu'un seul numéro dans la séquence.\n\nExemples :  \n>>> findLastRemaining(5)  \n4  \n>>> findLastRemaining(10)  \n4",
      "de": "Schreiben Sie eine Kotlin-Funktion `fun findLastRemaining(n: Int): Int`, um das folgende Problem zu lösen:\nFindet die zuletzt verbleibende Zahl in einer Sequenz von n Zahlen, wobei Zahlen in einem Zyklus jedes dritten Elements eliminiert werden.\n\nDer Prozess beginnt mit dem ersten Element in einer Sequenz von 1 bis n und zählt bis drei. Jedes Mal, wenn der Zähler drei erreicht, wird die aktuelle Zahl aus der Sequenz entfernt. Dieser Prozess wird fortgesetzt, bis nur noch eine Zahl in der Sequenz verbleibt.\n\nBeispiele:\n>>> findLastRemaining(5)\n4\n>>> findLastRemaining(10)\n4",
      "ha": "Rubuta aikin Kotlin `fun findLastRemaining(n: Int): Int` don warware matsalar mai zuwa:\nNemo lambar karshe da ta rage a cikin jerin lambobi n, inda ake cire lambobi a cikin kewayen kowane abu na uku.\n\nTsarin yana farawa da abu na farko a cikin jerin daga 1 zuwa n, yana kirga har zuwa uku. Duk lokacin da kidayar ta kai uku,\nana cire lambar yanzu daga jerin. Wannan tsari yana ci gaba har sai lamba daya ta rage a cikin jerin.\n\nMisalai:\n>>> findLastRemaining(5)\n4\n>>> findLastRemaining(10)\n4",
      "hi": "Kotlin फ़ंक्शन `fun findLastRemaining(n: Int): Int` लिखें ताकि निम्नलिखित समस्या का समाधान किया जा सके:\nn संख्याओं की एक अनुक्रम में अंतिम शेष संख्या खोजें, जहाँ संख्याएँ हर तीसरे तत्व के चक्र में समाप्त की जाती हैं।\n\nप्रक्रिया 1 से n तक के अनुक्रम में पहले तत्व के साथ शुरू होती है, तीन तक गिनती करते हुए। हर बार जब गिनती तीन तक पहुँचती है, तो वर्तमान संख्या अनुक्रम से हटा दी जाती है। यह प्रक्रिया तब तक जारी रहती है जब तक अनुक्रम में केवल एक संख्या शेष नहीं रहती।\n\nउदाहरण:\n>>> findLastRemaining(5)\n4\n>>> findLastRemaining(10)\n4",
      "hu": "Írj egy Kotlin függvényt `fun findLastRemaining(n: Int): Int` a következő probléma megoldására:\nMegtalálja az utoljára megmaradt számot egy n számot tartalmazó sorozatban, ahol a számok minden harmadik elem ciklusában kerülnek eltávolításra.\n\nA folyamat az első elemmel kezdődik egy 1-től n-ig terjedő sorozatban, hármasával számolva. Minden alkalommal, amikor a szám eléri a hármat, az aktuális szám eltávolításra kerül a sorozatból. Ez a folyamat addig folytatódik, amíg csak egy szám marad a sorozatban.\n\nPéldák:\n>>> findLastRemaining(5)\n4\n>>> findLastRemaining(10)\n4"
    },
    "instruction_bertscore": {
      "sq": "0.9948681854755826",
      "hy": "0.984809741610357",
      "bn": "0.9737672828374844",
      "bg": "0.9910812972611525",
      "zh": "0.9658772868420166",
      "fr": "0.9941342462176587",
      "de": "0.9820487793139719",
      "ha": "0.9481741555019011",
      "hi": "0.9752415175255253",
      "hu": "0.969238907410651"
    },
    "level": "easy",
    "test": "fun main(){\n    check(findLastRemaining(5) == 4)\n    check(findLastRemaining(10) == 4)\n    check(findLastRemaining(6) == 1)\n    check(findLastRemaining(7) == 4)\n    check(findLastRemaining(15) == 5)\n    check(findLastRemaining(20) == 20)\n    check(findLastRemaining(1) == 1)\n}\nmain()",
    "entry_point": "findLastRemaining",
    "signature": "fun findLastRemaining(n: Int): Int",
    "docstring": {
      "en": "Finds the last remaining number in a sequence of n numbers, where numbers are eliminated in a cycle of every third element.\n\nThe process begins with the first element in a sequence from 1 to n, counting up to three. Each time the count reaches three,\nthe current number is removed from the sequence. This process continues until only one number remains in the sequence.\n\nExamples:\n>>> findLastRemaining(5)\n4\n>>> findLastRemaining(10)\n4",
      "sq": "Gjen numrin e fundit të mbetur në një sekuencë prej n numrash, ku numrat eliminohen në një cikël të çdo elementi të tretë.\n\nProcesi fillon me elementin e parë në një sekuencë nga 1 deri në n, duke numëruar deri në tre. Sa herë që numërimi arrin tre,\nnumri aktual hiqet nga sekuenca. Ky proces vazhdon derisa të mbetet vetëm një numër në sekuencë.\n\nShembuj:\n>>> findLastRemaining(5)\n4\n>>> findLastRemaining(10)\n4",
      "hy": "Գտնում է n թվերի հաջորդականության մեջ վերջին մնացած թիվը, որտեղ թվերը վերացվում են յուրաքանչյուր երրորդ տարրի ցիկլով:\n\nԳործընթացը սկսվում է 1-ից n հաջորդականության առաջին տարրից, հաշվելով մինչև երեք: Ամեն անգամ, երբ հաշիվը հասնում է երեքի, ընթացիկ թիվը հեռացվում է հաջորդականությունից: Այս գործընթացը շարունակվում է, մինչև հաջորդականության մեջ մնա միայն մեկ թիվ:\n\nՕրինակներ:\n>>> findLastRemaining(5)\n4\n>>> findLastRemaining(10)\n4",
      "bn": "শেষ অবশিষ্ট সংখ্যাটি একটি n সংখ্যার ক্রমে খুঁজে বের করে, যেখানে প্রতিটি তৃতীয় উপাদান চক্রাকারে বাদ দেওয়া হয়।\n\nপ্রক্রিয়াটি 1 থেকে n পর্যন্ত একটি ক্রমের প্রথম উপাদান দিয়ে শুরু হয়, তিন পর্যন্ত গণনা করা হয়। প্রতিবার গণনা তিনে পৌঁছালে, বর্তমান সংখ্যাটি ক্রম থেকে সরিয়ে ফেলা হয়। এই প্রক্রিয়াটি চলতে থাকে যতক্ষণ না ক্রমে শুধুমাত্র একটি সংখ্যা অবশিষ্ট থাকে।\n\nউদাহরণ:\n>>> findLastRemaining(5)\n4\n>>> findLastRemaining(10)\n4",
      "bg": "Намира последното останало число в последователност от n числа, където числата се елиминират в цикъл на всеки трети елемент.\n\nПроцесът започва с първия елемент в последователност от 1 до n, като се брои до три. Всеки път, когато броят достигне три, текущото число се премахва от последователността. Този процес продължава, докато в последователността остане само едно число.\n\nПримери:\n>>> findLastRemaining(5)\n4\n>>> findLastRemaining(10)\n4",
      "zh": "找到一个由 n 个数字组成的序列中最后剩下的数字，其中数字以每第三个元素的循环方式被淘汰。\n\n该过程从序列中的第一个元素开始，从 1 数到 n，每次计数到三时，\n当前数字从序列中移除。此过程持续进行，直到序列中只剩下一个数字。\n\n示例：\n>>> findLastRemaining(5)\n4\n>>> findLastRemaining(10)\n4",
      "fr": "Trouve le dernier nombre restant dans une séquence de n nombres, où les nombres sont éliminés dans un cycle de chaque troisième élément.\n\nLe processus commence avec le premier élément dans une séquence de 1 à n, en comptant jusqu'à trois. Chaque fois que le compte atteint trois, le nombre actuel est retiré de la séquence. Ce processus continue jusqu'à ce qu'il ne reste qu'un seul nombre dans la séquence.\n\nExemples :\n>>> findLastRemaining(5)\n4\n>>> findLastRemaining(10)\n4",
      "de": "Findet die letzte verbleibende Zahl in einer Sequenz von n Zahlen, wobei Zahlen in einem Zyklus von jedem dritten Element eliminiert werden.\n\nDer Prozess beginnt mit dem ersten Element in einer Sequenz von 1 bis n und zählt bis drei. Jedes Mal, wenn der Zähler drei erreicht, wird die aktuelle Zahl aus der Sequenz entfernt. Dieser Prozess wird fortgesetzt, bis nur noch eine Zahl in der Sequenz verbleibt.\n\nBeispiele:\n>>> findLastRemaining(5)\n4\n>>> findLastRemaining(10)\n4",
      "ha": "Yana nemo lambar da ta rage a karshe a cikin jerin lambobi n, inda ake kawar da lambobi a cikin kewayen kowane abu na uku.\n\nTsarin yana farawa da abu na farko a cikin jerin daga 1 zuwa n, yana kirgawa har zuwa uku. Duk lokacin da ƙidayar ta kai uku,\nana cire lambar yanzu daga jerin. Wannan tsari yana ci gaba har sai lamba ɗaya kawai ta rage a cikin jerin.\n\nMisalai:\n>>> findLastRemaining(5)\n4\n>>> findLastRemaining(10)\n4",
      "hi": "आखिरी बचा हुआ संख्या n संख्याओं के अनुक्रम में खोजता है, जहाँ संख्याएँ हर तीसरे तत्व के चक्र में समाप्त की जाती हैं।\n\nप्रक्रिया 1 से n तक के अनुक्रम में पहले तत्व से शुरू होती है, तीन तक गिनती करते हुए। हर बार जब गिनती तीन तक पहुँचती है, वर्तमान संख्या को अनुक्रम से हटा दिया जाता है। यह प्रक्रिया तब तक जारी रहती है जब तक अनुक्रम में केवल एक संख्या नहीं बचती।\n\nउदाहरण:\n>>> findLastRemaining(5)\n4\n>>> findLastRemaining(10)\n4",
      "hu": "Megtalálja az utolsó megmaradó számot egy n számot tartalmazó sorozatban, ahol a számokat minden harmadik elem ciklusában távolítják el.\n\nA folyamat az 1-től n-ig terjedő sorozat első elemével kezdődik, hármasával számolva. Minden alkalommal, amikor a számolás eléri a hármat, az aktuális számot eltávolítják a sorozatból. Ez a folyamat addig folytatódik, amíg csak egy szám marad a sorozatban.\n\nPéldák:\n>>> findLastRemaining(5)\n4\n>>> findLastRemaining(10)\n4"
    },
    "docstring_bertscore": {
      "sq": "0.9892098018110418",
      "hy": "0.9771318828618344",
      "bn": "0.9632774137846509",
      "bg": "0.9822529713456758",
      "zh": "0.9432685809814825",
      "fr": "0.9903127963169285",
      "de": "0.9785272612886045",
      "ha": "0.9425050457967844",
      "hi": "0.9912799276421874",
      "hu": "0.9549557939711942"
    }
  },
  {
    "task_id": "Kotlin/16",
    "prompt": {
      "en": "/**\n    * Extracts a specific 4-bit sequence from the binary representation of a given positive decimal integer,\n    * starting from the 4th bit to the 7th bit (counting from 0 from the right), and then returns its decimal value.\n    Examples:\n    >>> extractAndConvertToDecimal(173) // Binary of 173 is 10101101, bits 4-7 are 1010\n        10\n    >>> extractAndConvertToDecimal(59) // Binary of 59 is 111011, bits 4-7 are 0011\n        3\n**/\n\nfun extractAndConvertToDecimal(number: Int): Int ",
      "sq": "/**\n    * Nxjerr një sekuencë specifike prej 4-bitësh nga paraqitja binare e një numri të dhënë të plotë pozitiv dhjetor,\n    * duke filluar nga biti i 4-t deri te biti i 7-të (duke numëruar nga 0 nga e djathta), dhe pastaj kthen vlerën e tij dhjetore.\n    Shembuj:\n    >>> extractAndConvertToDecimal(173) // Binar i 173 është 10101101, bitët 4-7 janë 1010\n        10\n    >>> extractAndConvertToDecimal(59) // Binar i 59 është 111011, bitët 4-7 janë 0011\n        3\n**/\n\nfun extractAndConvertToDecimal(number: Int): Int ",
      "hy": "/**\n    * Հանում է հատուկ 4-բիթանոց հաջորդականություն տրված դրական տասնորդական ամբողջ թվի բինար ներկայացումից,\n    * սկսած 4-րդ բիթից մինչև 7-րդ բիթը (հաշվելով 0-ից աջից), և ապա վերադարձնում է դրա տասնորդական արժեքը։\n    Օրինակներ:\n    >>> extractAndConvertToDecimal(173) // 173-ի բինարը 10101101 է, բիթերը 4-7 են 1010\n        10\n    >>> extractAndConvertToDecimal(59) // 59-ի բինարը 111011 է, բիթերը 4-7 են 0011\n        3\n**/",
      "bn": "/**\n    * একটি প্রদত্ত ধনাত্মক দশমিক পূর্ণসংখ্যার বাইনারি উপস্থাপন থেকে একটি নির্দিষ্ট 4-বিট সিকোয়েন্স বের করে,\n    * ডান দিক থেকে 0 থেকে গণনা করে 4র্থ বিট থেকে 7ম বিট পর্যন্ত, এবং তারপর এর দশমিক মান প্রদান করে।\n    উদাহরণসমূহ:\n    >>> extractAndConvertToDecimal(173) // 173 এর বাইনারি 10101101, বিট 4-7 হল 1010\n        10\n    >>> extractAndConvertToDecimal(59) // 59 এর বাইনারি 111011, বিট 4-7 হল 0011\n        3\n**/",
      "bg": "/**\n    * Извлича конкретна 4-битова последователност от двоичното представяне на дадено положително десетично число,\n    * започвайки от 4-тия бит до 7-мия бит (броейки от 0 отдясно наляво), и след това връща неговата десетична стойност.\n    Примери:\n    >>> extractAndConvertToDecimal(173) // Двоичното на 173 е 10101101, битове 4-7 са 1010\n        10\n    >>> extractAndConvertToDecimal(59) // Двоичното на 59 е 111011, битове 4-7 са 0011\n        3\n**/\n\nfun extractAndConvertToDecimal(number: Int): Int ",
      "zh": "/**\n    * 从给定正十进制整数的二进制表示中提取特定的4位序列，\n    * 从第4位到第7位开始（从右边算起，从0开始计数），然后返回其十进制值。\n    示例:\n    >>> extractAndConvertToDecimal(173) // Binary of 173 is 10101101, bits 4-7 are 1010\n        10\n    >>> extractAndConvertToDecimal(59) // Binary of 59 is 111011, bits 4-7 are 0011\n        3\n**/",
      "fr": "/**\n    * Extrait une séquence spécifique de 4 bits de la représentation binaire d'un entier décimal positif donné,\n    * en commençant du 4ème bit au 7ème bit (en comptant à partir de 0 depuis la droite), puis retourne sa valeur décimale.\n    Exemples :\n    >>> extractAndConvertToDecimal(173) // Binary of 173 is 10101101, bits 4-7 are 1010\n        10\n    >>> extractAndConvertToDecimal(59) // Binary of 59 is 111011, bits 4-7 are 0011\n        3\n**/\n\nfun extractAndConvertToDecimal(number: Int): Int ",
      "de": "/**\n    * Extrahiert eine spezifische 4-Bit-Sequenz aus der Binärdarstellung einer gegebenen positiven Dezimalzahl,\n    * beginnend vom 4. Bit bis zum 7. Bit (zählend von 0 von rechts), und gibt dann deren Dezimalwert zurück.\n    Beispiele:\n    >>> extractAndConvertToDecimal(173) // Binär von 173 ist 10101101, Bits 4-7 sind 1010\n        10\n    >>> extractAndConvertToDecimal(59) // Binär von 59 ist 111011, Bits 4-7 sind 0011\n        3\n**/\n\nfun extractAndConvertToDecimal(number: Int): Int ",
      "ha": "/**\n    * Yana cire takamaiman jerin bit guda 4 daga wakilcin binary na wani adadi mai kyau na decimal,\n    * yana farawa daga bit na 4 zuwa bit na 7 (ana kirga daga 0 daga dama), sannan yana mayar da darajar sa ta decimal.\n    Misalai:\n    >>> extractAndConvertToDecimal(173) // Binary na 173 shine 10101101, bits 4-7 sune 1010\n        10\n    >>> extractAndConvertToDecimal(59) // Binary na 59 shine 111011, bits 4-7 sune 0011\n        3\n**/",
      "hi": "/**\n    * दिए गए धनात्मक दशमलव पूर्णांक के द्विआधारी रूप से एक विशिष्ट 4-बिट अनुक्रम निकालता है,\n    * दाएँ से 0 से गिनते हुए 4वें बिट से 7वें बिट तक, और फिर उसके दशमलव मान को लौटाता है।\n    उदाहरण:\n    >>> extractAndConvertToDecimal(173) // 173 का द्विआधारी 10101101 है, बिट्स 4-7 हैं 1010\n        10\n    >>> extractAndConvertToDecimal(59) // 59 का द्विआधारी 111011 है, बिट्स 4-7 हैं 0011\n        3\n**/\n\nfun extractAndConvertToDecimal(number: Int): Int ",
      "hu": "/**\n    * Kivon egy adott 4 bites szekvenciát egy adott pozitív decimális egész szám bináris ábrázolásából,\n    * a 4. bittől a 7. bitig (jobbról számítva 0-tól kezdve), majd visszaadja annak decimális értékét.\n    Példák:\n    >>> extractAndConvertToDecimal(173) // Binary of 173 is 10101101, bits 4-7 are 1010\n        10\n    >>> extractAndConvertToDecimal(59) // Binary of 59 is 111011, bits 4-7 are 0011\n        3\n**/"
    },
    "prompt_bertscore": {
      "sq": "0.999999801369619",
      "hy": "0.9437137116653816",
      "bn": "0.9276439179485161",
      "bg": "0.9714272183185124",
      "zh": "0.9522150919736749",
      "fr": "0.9960263992273971",
      "de": "0.9955465082268168",
      "ha": "0.9357150648514877",
      "hi": "0.960482088432347",
      "hu": "0.9473293804913597"
    },
    "canonical_solution": "{\n    val binaryString = number.toString(2).padStart(8, '0') // Pad the binary string to ensure it has at least 8 bits\n    val extractedBits = binaryString.takeLast(8).take(4) // Extract the 4th to 7th bits from the right\n\n    return extractedBits.toInt(2)\n}",
    "instruction": {
      "en": "Write a Kotlin function `fun extractAndConvertToDecimal(number: Int): Int` to solve the following problem:\nExtracts a specific 4-bit sequence from the binary representation of a given positive decimal integer,\nstarting from the 4th bit to the 7th bit (counting from 0 from the right), and then returns its decimal value.\nExamples:\n>>> extractAndConvertToDecimal(173) // Binary of 173 is 10101101, bits 4-7 are 1010\n10\n>>> extractAndConvertToDecimal(59) // Binary of 59 is 111011, bits 4-7 are 0011\n3",
      "sq": "Shkruani një funksion Kotlin `fun extractAndConvertToDecimal(number: Int): Int` për të zgjidhur problemin e mëposhtëm:  \nEkstrakton një sekuencë specifike 4-bitëshe nga paraqitja binare e një numri të dhënë të plotë dhjetor pozitiv, duke filluar nga biti i 4-të deri te biti i 7-të (duke numëruar nga 0 nga e djathta), dhe pastaj kthen vlerën e tij dhjetore.  \nShembuj:  \n>>> extractAndConvertToDecimal(173) // Binari i 173 është 10101101, bitët 4-7 janë 1010  \n10  \n>>> extractAndConvertToDecimal(59) // Binari i 59 është 111011, bitët 4-7 janë 0011  \n3",
      "hy": "Գրեք Kotlin ֆունկցիա `fun extractAndConvertToDecimal(number: Int): Int` հետևյալ խնդիրը լուծելու համար:\nՀանում է կոնկրետ 4-բիթանոց հաջորդականությունը տրված դրական տասնորդական ամբողջ թվի բինար ներկայացումից, սկսած 4-րդ բիթից մինչև 7-րդ բիթը (հաշվելով 0-ից աջից), ապա վերադարձնում է դրա տասնորդական արժեքը։\nՕրինակներ:\n>>> extractAndConvertToDecimal(173) // Binary of 173 is 10101101, bits 4-7 are 1010\n10\n>>> extractAndConvertToDecimal(59) // Binary of 59 is 111011, bits 4-7 are 0011\n3",
      "bn": "একটি Kotlin ফাংশন `fun extractAndConvertToDecimal(number: Int): Int` লিখুন নিম্নলিখিত সমস্যার সমাধানের জন্য:\nএকটি প্রদত্ত ধনাত্মক দশমিক পূর্ণসংখ্যার বাইনারি উপস্থাপন থেকে একটি নির্দিষ্ট 4-বিট সিকোয়েন্স বের করে, ডান দিক থেকে গণনা করে 4র্থ বিট থেকে 7ম বিট পর্যন্ত, এবং তারপর এর দশমিক মান ফেরত দেয়।\nউদাহরণসমূহ:\n>>> extractAndConvertToDecimal(173) // 173 এর বাইনারি হল 10101101, বিট 4-7 হল 1010\n10\n>>> extractAndConvertToDecimal(59) // 59 এর বাইনারি হল 111011, বিট 4-7 হল 0011\n3",
      "bg": "Напишете Kotlin функция `fun extractAndConvertToDecimal(number: Int): Int`, за да решите следния проблем:\nИзвлича специфична 4-битова последователност от двоичното представяне на дадено положително десетично цяло число, започвайки от 4-тия бит до 7-мия бит (броейки от 0 отдясно), и след това връща неговата десетична стойност.\nПримери:\n>>> extractAndConvertToDecimal(173) // Binary of 173 is 10101101, bits 4-7 are 1010\n10\n>>> extractAndConvertToDecimal(59) // Binary of 59 is 111011, bits 4-7 are 0011\n3",
      "zh": "编写一个 Kotlin 函数 `fun extractAndConvertToDecimal(number: Int): Int` 来解决以下问题：\n从给定正十进制整数的二进制表示中提取特定的4位序列，从第4位开始到第7位（从右边算起，从0开始计数），然后返回其十进制值。\n示例：\n>>> extractAndConvertToDecimal(173) // Binary of 173 is 10101101, bits 4-7 are 1010\n10\n>>> extractAndConvertToDecimal(59) // Binary of 59 is 111011, bits 4-7 are 0011\n3",
      "fr": "Écrire une fonction Kotlin `fun extractAndConvertToDecimal(number: Int): Int` pour résoudre le problème suivant :  \nExtrait une séquence spécifique de 4 bits de la représentation binaire d'un entier décimal positif donné, en commençant du 4ème bit au 7ème bit (en comptant à partir de 0 depuis la droite), puis retourne sa valeur décimale.  \nExemples :  \n>>> extractAndConvertToDecimal(173) // Binary of 173 is 10101101, bits 4-7 are 1010  \n10  \n>>> extractAndConvertToDecimal(59) // Binary of 59 is 111011, bits 4-7 are 0011  \n3  ",
      "de": "Schreiben Sie eine Kotlin-Funktion `fun extractAndConvertToDecimal(number: Int): Int`, um das folgende Problem zu lösen:\nExtrahiert eine spezifische 4-Bit-Sequenz aus der Binärdarstellung einer gegebenen positiven Dezimalzahl,\nbeginnend vom 4. Bit bis zum 7. Bit (zählend von 0 von rechts), und gibt dann deren Dezimalwert zurück.\nBeispiele:\n>>> extractAndConvertToDecimal(173) // Binary of 173 is 10101101, bits 4-7 are 1010\n10\n>>> extractAndConvertToDecimal(59) // Binary of 59 is 111011, bits 4-7 are 0011\n3",
      "ha": "Rubuta aikin Kotlin `fun extractAndConvertToDecimal(number: Int): Int` don warware matsalar mai zuwa:\nYa fitar da takamaiman jerin 4-bit daga wakilcin binary na wani lamba mai kyau na decimal,\nfarawa daga bit na 4 zuwa bit na 7 (ana kirga daga 0 daga dama), sannan ya dawo da kimar decimal ɗin sa.\nMisalai:\n>>> extractAndConvertToDecimal(173) // Binary na 173 shine 10101101, bits 4-7 sune 1010\n10\n>>> extractAndConvertToDecimal(59) // Binary na 59 shine 111011, bits 4-7 sune 0011\n3",
      "hi": "Kotlin फ़ंक्शन `fun extractAndConvertToDecimal(number: Int): Int` लिखें ताकि निम्नलिखित समस्या का समाधान किया जा सके:\nदिए गए धनात्मक दशमलव पूर्णांक की बाइनरी अभ्यावेदन से एक विशिष्ट 4-बिट अनुक्रम निकालता है, 4वें बिट से 7वें बिट तक (दाएं से 0 से गिनते हुए), और फिर उसके दशमलव मान को लौटाता है।\nउदाहरण:\n>>> extractAndConvertToDecimal(173) // 173 का बाइनरी 10101101 है, बिट्स 4-7 हैं 1010\n10\n>>> extractAndConvertToDecimal(59) // 59 का बाइनरी 111011 है, बिट्स 4-7 हैं 0011\n3",
      "hu": "Írj egy Kotlin függvényt `fun extractAndConvertToDecimal(number: Int): Int`, hogy megoldja a következő problémát:\nKivon egy adott 4 bites szekvenciát egy adott pozitív decimális egész szám bináris ábrázolásából, a 4. bittől a 7. bitig (jobbról számítva 0-tól kezdve), majd visszaadja annak decimális értékét.\nPéldák:\n>>> extractAndConvertToDecimal(173) // 173 binárisan 10101101, a 4-7. bitek 1010\n10\n>>> extractAndConvertToDecimal(59) // 59 binárisan 111011, a 4-7. bitek 0011\n3"
    },
    "instruction_bertscore": {
      "sq": "1",
      "hy": "0.9935592112645627",
      "bn": "0.969215866286451",
      "bg": "1",
      "zh": "0.9865847026952846",
      "fr": "0.9918631064409058",
      "de": "0.9960820157340868",
      "ha": "0.9621464123950383",
      "hi": "0.9731876793856246",
      "hu": "0.9537844706142315"
    },
    "level": "easy",
    "test": "fun main(){\n    check(extractAndConvertToDecimal(217) == 13)  // 173 in binary is 10101101, bits 4-7 are 1101\n    check(extractAndConvertToDecimal(173) == 10)  // 173 in binary is 10101101, bits 4-7 are 1010\n    check(extractAndConvertToDecimal(59) == 3)    // 59 in binary is 111011, bits 4-7 are 0011\n    check(extractAndConvertToDecimal(32) == 2)    // 32 in binary is 100000, bits 4-7 are 0010\n    check(extractAndConvertToDecimal(255) == 15)  // 255 in binary is 11111111, bits 4-7 are 1111\n    check(extractAndConvertToDecimal(1) == 0)     // 1 in binary is 1, bits 4-7 are 0000\n\n}\n\nmain()",
    "entry_point": "extractAndConvertToDecimal",
    "signature": "fun extractAndConvertToDecimal(number: Int): Int",
    "docstring": {
      "en": "Extracts a specific 4-bit sequence from the binary representation of a given positive decimal integer,\nstarting from the 4th bit to the 7th bit (counting from 0 from the right), and then returns its decimal value.\nExamples:\n>>> extractAndConvertToDecimal(173) // Binary of 173 is 10101101, bits 4-7 are 1010\n10\n>>> extractAndConvertToDecimal(59) // Binary of 59 is 111011, bits 4-7 are 0011\n3",
      "sq": "Nxjerr një sekuencë specifike 4-bitëshe nga përfaqësimi binar i një numri të dhënë dhjetor pozitiv, duke filluar nga biti i 4-të deri te biti i 7-të (duke numëruar nga 0 nga e djathta), dhe pastaj kthen vlerën e tij dhjetore.\nShembuj:\n>>> extractAndConvertToDecimal(173) // Binar i 173 është 10101101, bitët 4-7 janë 1010\n10\n>>> extractAndConvertToDecimal(59) // Binar i 59 është 111011, bitët 4-7 janë 0011\n3",
      "hy": "Հատում է կոնկրետ 4-բիթանոց հաջորդականությունը տրված դրական տասնորդական ամբողջ թվի բինար ներկայացումից՝ սկսած 4-րդ բիթից մինչև 7-րդ բիթը (հաշվելով 0-ից աջից), և ապա վերադարձնում է դրա տասնորդական արժեքը։\nՕրինակներ:\n>>> extractAndConvertToDecimal(173) // 173-ի բինարը 10101101 է, բիթերը 4-7 են 1010\n10\n>>> extractAndConvertToDecimal(59) // 59-ի բինարը 111011 է, բիթերը 4-7 են 0011\n3",
      "bn": "একটি প্রদত্ত ধনাত্মক দশমিক পূর্ণসংখ্যার বাইনারি উপস্থাপন থেকে একটি নির্দিষ্ট ৪-বিটের ক্রম বের করে, ডান দিক থেকে ০ থেকে গণনা করে ৪র্থ বিট থেকে ৭ম বিট পর্যন্ত, এবং তারপর এর দশমিক মান ফেরত দেয়।\n\nউদাহরণসমূহ:\n>>> extractAndConvertToDecimal(173) // 173 এর বাইনারি হল 10101101, বিট 4-7 হল 1010\n10\n>>> extractAndConvertToDecimal(59) // 59 এর বাইনারি হল 111011, বিট 4-7 হল 0011\n3",
      "bg": "Извлича специфична 4-битова последователност от двоичното представяне на дадено положително десетично число, започвайки от 4-тия бит до 7-мия бит (броейки от 0 отдясно), и след това връща неговата десетична стойност.\nПримери:\n>>> extractAndConvertToDecimal(173) // Двоичното на 173 е 10101101, битове 4-7 са 1010\n10\n>>> extractAndConvertToDecimal(59) // Двоичното на 59 е 111011, битове 4-7 са 0011\n3",
      "zh": "从给定正十进制整数的二进制表示中提取特定的4位序列，从第4位到第7位（从右边算起，从0开始计数），然后返回其十进制值。\n示例：\n>>> extractAndConvertToDecimal(173) // 173的二进制是10101101，第4-7位是1010\n10\n>>> extractAndConvertToDecimal(59) // 59的二进制是111011，第4-7位是0011\n3",
      "fr": "Extrait une séquence spécifique de 4 bits de la représentation binaire d'un entier décimal positif donné, en commençant du 4ème bit au 7ème bit (en comptant à partir de 0 depuis la droite), puis retourne sa valeur décimale.\nExemples :\n>>> extractAndConvertToDecimal(173) // Binaire de 173 est 10101101, les bits 4-7 sont 1010\n10\n>>> extractAndConvertToDecimal(59) // Binaire de 59 est 111011, les bits 4-7 sont 0011\n3",
      "de": "Extrahiert eine spezifische 4-Bit-Sequenz aus der binären Darstellung einer gegebenen positiven Dezimalzahl, beginnend vom 4. Bit bis zum 7. Bit (von rechts aus gezählt, beginnend bei 0), und gibt dann deren Dezimalwert zurück.\nBeispiele:\n>>> extractAndConvertToDecimal(173) // Binär von 173 ist 10101101, Bits 4-7 sind 1010\n10\n>>> extractAndConvertToDecimal(59) // Binär von 59 ist 111011, Bits 4-7 sind 0011\n3",
      "ha": "Ya fitar da takamaiman jerin 4-bit daga wakilcin binary na wani lamba mai kyau na decimal da aka bayar, farawa daga bit na 4 zuwa bit na 7 (ana ƙidaya daga 0 daga dama), sannan ya mayar da darajarsa ta decimal.\n\nMisalai:\n>>> extractAndConvertToDecimal(173) // Binary na 173 shine 10101101, bits 4-7 sune 1010\n10\n>>> extractAndConvertToDecimal(59) // Binary na 59 shine 111011, bits 4-7 sune 0011\n3",
      "hi": "दिए गए सकारात्मक दशमलव पूर्णांक के द्विआधारी रूप से एक विशिष्ट 4-बिट अनुक्रम निकालता है, जो दाएँ से 0 से गिनते हुए 4वें बिट से 7वें बिट तक होता है, और फिर इसके दशमलव मान को लौटाता है। \n\nउदाहरण:\n>>> extractAndConvertToDecimal(173) // 173 का द्विआधारी 10101101 है, बिट्स 4-7 हैं 1010\n10\n>>> extractAndConvertToDecimal(59) // 59 का द्विआधारी 111011 है, बिट्स 4-7 हैं 0011\n3",
      "hu": "Kivon egy adott pozitív decimális egész szám bináris ábrázolásából egy adott 4 bites szekvenciát, a 4. bittől a 7. bitig (jobbról számolva 0-tól), majd visszaadja annak decimális értékét.  \nPéldák:  \n>>> extractAndConvertToDecimal(173) // A 173 binárisa 10101101, a 4-7. bitek 1010  \n10  \n>>> extractAndConvertToDecimal(59) // Az 59 binárisa 111011, a 4-7. bitek 0011  \n3"
    },
    "docstring_bertscore": {
      "sq": "0.9875138956177659",
      "hy": "0.9849618924822297",
      "bn": "0.9597131902273609",
      "bg": "0.9836004798506165",
      "zh": "0.9418845244864313",
      "fr": "0.9822638960166328",
      "de": "0.9799371397331901",
      "ha": "0.9590940593296752",
      "hi": "0.9316522790378001",
      "hu": "0.9531049560807112"
    }
  },
  {
    "task_id": "Kotlin/17",
    "prompt": {
      "en": "/**\n * Performs a right circular shift on a given unsigned 32-bit integer.\n * The function shifts the bits of the input number to the right by a specified number of positions.\n * The bits that are shifted out on the right are reinserted on the left side.\n * \n * Example:\n * >>> circularRightShift(1023u, 20)\n *     4190208u\n * >>> circularRightShift(15u, 2)\n *     3221225475u\n * >>> circularRightShift(256u, 8)\n *     1u\n */\nfun circularRightShift(num: UInt, shift: Int): UInt ",
      "sq": "/**\n * Kryen një zhvendosje rrethore djathtas në një numër të dhënë të plotë pa shenjë 32-bitësh.\n * Funksioni zhvendos bitet e numrit hyrës djathtas me një numër të specifikuar pozicionesh.\n * Bitet që zhvendosen jashtë në të djathtë rihyhen në anën e majtë.\n * \n * Shembull:\n * >>> circularRightShift(1023u, 20)\n *     4190208u\n * >>> circularRightShift(15u, 2)\n *     3221225475u\n * >>> circularRightShift(256u, 8)\n *     1u\n */",
      "hy": "/**\n * Կատարում է աջ շրջանաձև տեղաշարժ տրված 32-բիթանոց անստորագիր ամբողջ թվի վրա:\n * Ֆունկցիան տեղաշարժում է մուտքային թվի բիթերը աջ, որոշակի քանակությամբ դիրքերով:\n * Աջից դուրս եկած բիթերը վերատեղադրվում են ձախ կողմում:\n * \n * Օրինակ:\n * >>> circularRightShift(1023u, 20)\n *     4190208u\n * >>> circularRightShift(15u, 2)\n *     3221225475u\n * >>> circularRightShift(256u, 8)\n *     1u\n */\nfun circularRightShift(num: UInt, shift: Int): UInt ",
      "bn": "/**\n * একটি প্রদত্ত ৩২-বিট স্বাক্ষরবিহীন পূর্ণসংখ্যার উপর ডানদিকে বৃত্তাকার স্থানান্তর সম্পাদন করে।\n * ফাংশনটি ইনপুট সংখ্যার বিটগুলিকে নির্দিষ্ট সংখ্যক অবস্থানে ডানদিকে স্থানান্তর করে।\n * ডানদিকে স্থানান্তরিত বিটগুলি বাম পাশে পুনরায় সন্নিবেশিত হয়।\n * \n * উদাহরণ:\n * >>> circularRightShift(1023u, 20)\n *     4190208u\n * >>> circularRightShift(15u, 2)\n *     3221225475u\n * >>> circularRightShift(256u, 8)\n *     1u\n */",
      "bg": "/**\n * Извършва дясно кръгово преместване на дадено беззнаково 32-битово цяло число.\n * Функцията премества битовете на входното число надясно с определен брой позиции.\n * Битовете, които се изместват отдясно, се вмъкват отново отляво.\n * \n * Пример:\n * >>> circularRightShift(1023u, 20)\n *     4190208u\n * >>> circularRightShift(15u, 2)\n *     3221225475u\n * >>> circularRightShift(256u, 8)\n *     1u\n */",
      "zh": "/**\n * 对给定的无符号32位整数执行右循环移位。\n * 该函数将输入数字的位向右移动指定数量的位置。\n * 在右侧移出的位会重新插入到左侧。\n * \n * 示例:\n * >>> circularRightShift(1023u, 20)\n *     4190208u\n * >>> circularRightShift(15u, 2)\n *     3221225475u\n * >>> circularRightShift(256u, 8)\n *     1u\n */",
      "fr": "/**\n * Effectue une rotation circulaire à droite sur un entier non signé de 32 bits donné.\n * La fonction déplace les bits du nombre d'entrée vers la droite d'un nombre spécifié de positions.\n * Les bits qui sont décalés à droite sont réinsérés sur le côté gauche.\n * \n * Exemple :\n * >>> circularRightShift(1023u, 20)\n *     4190208u\n * >>> circularRightShift(15u, 2)\n *     3221225475u\n * >>> circularRightShift(256u, 8)\n *     1u\n */",
      "de": "/**\n * Führt eine Rechtsrotation bei einer gegebenen 32-Bit-Unsigned-Integer durch.\n * Die Funktion verschiebt die Bits der Eingabezahl um eine angegebene Anzahl von Positionen nach rechts.\n * Die Bits, die rechts herausgeschoben werden, werden auf der linken Seite wieder eingefügt.\n * \n * Beispiel:\n * >>> circularRightShift(1023u, 20)\n *     4190208u\n * >>> circularRightShift(15u, 2)\n *     3221225475u\n * >>> circularRightShift(256u, 8)\n *     1u\n */",
      "ha": "/**\n * Yana yin juyawa na dama a kan wani ba-ƙari 32-bit integer.\n * Aikin yana motsa bits na lambar shigarwa zuwa dama ta hanyar adadin matsayi da aka kayyade.\n * Bits da aka motsa daga dama suna sake shigowa daga hagu.\n * \n * Misali:\n * >>> circularRightShift(1023u, 20)\n *     4190208u\n * >>> circularRightShift(15u, 2)\n *     3221225475u\n * >>> circularRightShift(256u, 8)\n *     1u\n */",
      "hi": "/**\n * दिए गए बिना चिह्न वाले 32-बिट पूर्णांक पर दायां वृत्ताकार शिफ्ट करता है।\n * यह फ़ंक्शन इनपुट संख्या के बिट्स को निर्दिष्ट संख्या के स्थानों द्वारा दाईं ओर शिफ्ट करता है।\n * जो बिट्स दाईं ओर से बाहर शिफ्ट होते हैं, उन्हें बाईं ओर फिर से डाला जाता है।\n * \n * उदाहरण:\n * >>> circularRightShift(1023u, 20)\n *     4190208u\n * >>> circularRightShift(15u, 2)\n *     3221225475u\n * >>> circularRightShift(256u, 8)\n *     1u\n */",
      "hu": "/**\n * Egy adott előjelnélküli 32 bites egész szám jobbra körkörös eltolását hajtja végre.\n * A függvény az input szám bitjeit jobbra tolja el egy meghatározott pozíciószámmal.\n * A jobbra kitolt bitek a bal oldalon kerülnek visszaillesztésre.\n * \n * Példa:\n * >>> circularRightShift(1023u, 20)\n *     4190208u\n * >>> circularRightShift(15u, 2)\n *     3221225475u\n * >>> circularRightShift(256u, 8)\n *     1u\n */\nfun circularRightShift(num: UInt, shift: Int): UInt "
    },
    "prompt_bertscore": {
      "sq": "0.9447775759862045",
      "hy": "0.9795754338093255",
      "bn": "0.9370897857186302",
      "bg": "0.9478972647507384",
      "zh": "0.9351048723209485",
      "fr": "0.9417488599361845",
      "de": "0.9471375035432801",
      "ha": "0.9032376071396163",
      "hi": "0.9414107910276631",
      "hu": "0.9904808376192841"
    },
    "canonical_solution": "{\n    val bitSize = 32\n    val effectiveShift = shift % bitSize\n    if (effectiveShift == 0) return num\n    println((num shr effectiveShift) or (num shl (bitSize - effectiveShift)))\n    return (num shr effectiveShift) or (num shl (bitSize - effectiveShift))\n}",
    "instruction": {
      "en": "Write a Kotlin function `fun circularRightShift(num: UInt, shift: Int): UInt` to solve the following problem:\nPerforms a right circular shift on a given unsigned 32-bit integer.\nThe function shifts the bits of the input number to the right by a specified number of positions.\nThe bits that are shifted out on the right are reinserted on the left side.\n\nExample:\n>>> circularRightShift(1023u, 20)\n4190208u\n>>> circularRightShift(15u, 2)\n3221225475u\n>>> circularRightShift(256u, 8)\n1u",
      "sq": "Shkruani një funksion Kotlin `fun circularRightShift(num: UInt, shift: Int): UInt` për të zgjidhur problemin e mëposhtëm:\nKryen një zhvendosje rrethore djathtas në një numër të dhënë të pacaktuar 32-bitësh.\nFunksioni zhvendos bitët e numrit hyrës djathtas me një numër të specifikuar pozicionesh.\nBitët që zhvendosen jashtë në të djathtë ri-futen në anën e majtë.\n\nShembull:\n>>> circularRightShift(1023u, 20)\n4190208u\n>>> circularRightShift(15u, 2)\n3221225475u\n>>> circularRightShift(256u, 8)\n1u",
      "hy": "Գրեք Kotlin ֆունկցիա `fun circularRightShift(num: UInt, shift: Int): UInt` հետևյալ խնդիրը լուծելու համար:\nԿատարում է աջ շրջանաձև տեղաշարժ տրված անստորակետ 32-բիթանոց ամբողջ թվի վրա:\nՖունկցիան տեղաշարժում է մուտքագրված թվի բիթերը աջով որոշակի քանակությամբ դիրքերով:\nԱջից դուրս եկած բիթերը վերատեղադրվում են ձախ կողմում:\n\nՕրինակ:\n>>> circularRightShift(1023u, 20)\n4190208u\n>>> circularRightShift(15u, 2)\n3221225475u\n>>> circularRightShift(256u, 8)\n1u",
      "bn": "Kotlin ফাংশন `fun circularRightShift(num: UInt, shift: Int): UInt` লিখুন নিম্নলিখিত সমস্যার সমাধানের জন্য:\nএকটি প্রদত্ত 32-বিট স্বাক্ষরবিহীন পূর্ণসংখ্যার উপর ডানদিকে বৃত্তাকার স্থানান্তর সম্পাদন করে।\nফাংশনটি ইনপুট সংখ্যার বিটগুলিকে ডানদিকে নির্দিষ্ট সংখ্যক অবস্থানে স্থানান্তর করে।\nডানদিকে স্থানান্তরিত বিটগুলি বাম পাশে পুনরায় সন্নিবেশিত হয়।\n\nউদাহরণ:\n>>> circularRightShift(1023u, 20)\n4190208u\n>>> circularRightShift(15u, 2)\n3221225475u\n>>> circularRightShift(256u, 8)\n1u",
      "bg": "Напишете Kotlin функция `fun circularRightShift(num: UInt, shift: Int): UInt`, за да решите следния проблем:  \nИзвършва дясно кръгово изместване на дадено беззнаково 32-битово цяло число.  \nФункцията измества битовете на входното число надясно с определен брой позиции.  \nБитовете, които се изместват извън дясната страна, се вмъкват отново от лявата страна.\n\nПример:  \n>>> circularRightShift(1023u, 20)  \n4190208u  \n>>> circularRightShift(15u, 2)  \n3221225475u  \n>>> circularRightShift(256u, 8)  \n1u  ",
      "zh": "编写一个 Kotlin 函数 `fun circularRightShift(num: UInt, shift: Int): UInt` 来解决以下问题：\n对给定的无符号 32 位整数执行右循环移位。\n该函数将输入数字的位向右移动指定的位数。\n在右侧移出的位重新插入到左侧。\n\n示例:\n>>> circularRightShift(1023u, 20)\n4190208u\n>>> circularRightShift(15u, 2)\n3221225475u\n>>> circularRightShift(256u, 8)\n1u",
      "fr": "Écrire une fonction Kotlin `fun circularRightShift(num: UInt, shift: Int): UInt` pour résoudre le problème suivant :\nEffectue une rotation circulaire vers la droite sur un entier non signé de 32 bits donné.\nLa fonction décale les bits du nombre d'entrée vers la droite d'un nombre spécifié de positions.\nLes bits qui sont décalés à droite sont réinsérés sur le côté gauche.\n\nExemple :\n>>> circularRightShift(1023u, 20)\n4190208u\n>>> circularRightShift(15u, 2)\n3221225475u\n>>> circularRightShift(256u, 8)\n1u",
      "de": "Schreiben Sie eine Kotlin-Funktion `fun circularRightShift(num: UInt, shift: Int): UInt`, um das folgende Problem zu lösen:\nFührt eine zirkuläre Rechtsverschiebung auf einer gegebenen 32-Bit-Unsigned-Integer durch.\nDie Funktion verschiebt die Bits der Eingabezahl um eine angegebene Anzahl von Positionen nach rechts.\nDie Bits, die rechts herausgeschoben werden, werden auf der linken Seite wieder eingefügt.\n\nBeispiel:\n>>> circularRightShift(1023u, 20)\n4190208u\n>>> circularRightShift(15u, 2)\n3221225475u\n>>> circularRightShift(256u, 8)\n1u",
      "ha": "Rubuta aikin Kotlin `fun circularRightShift(num: UInt, shift: Int): UInt` don warware matsalar mai zuwa:\nYana yin juyawa na dama akan wani ba a sanya 32-bit integer.\nAikin yana motsa bits na lambar shigarwa zuwa dama ta wurin adadin wurare da aka fayyace.\nBits da aka motsa daga dama ana sake saka su a gefen hagu.\n\nMisali:\n>>> circularRightShift(1023u, 20)\n4190208u\n>>> circularRightShift(15u, 2)\n3221225475u\n>>> circularRightShift(256u, 8)\n1u",
      "hi": "Kotlin फ़ंक्शन `fun circularRightShift(num: UInt, shift: Int): UInt` लिखें ताकि निम्नलिखित समस्या का समाधान किया जा सके:\nएक दिए गए unsigned 32-बिट पूर्णांक पर दायें सर्कुलर शिफ्ट करता है।\nफ़ंक्शन इनपुट संख्या के बिट्स को निर्दिष्ट संख्या के स्थानों से दायें शिफ्ट करता है।\nजो बिट्स दायें से बाहर शिफ्ट होते हैं, उन्हें बायें तरफ पुनः डाला जाता है।\n\nउदाहरण:\n>>> circularRightShift(1023u, 20)\n4190208u\n>>> circularRightShift(15u, 2)\n3221225475u\n>>> circularRightShift(256u, 8)\n1u",
      "hu": "Írj egy Kotlin függvényt `fun circularRightShift(num: UInt, shift: Int): UInt` a következő probléma megoldására:\nVégrehajt egy jobbra körkörös eltolást egy adott előjelnélküli 32 bites egész számon.\nA függvény az input szám bitjeit jobbra tolja el egy megadott pozíciószámmal.\nA jobbra kitolt bitek visszaillesztésre kerülnek a bal oldalon.\n\nPélda:\n>>> circularRightShift(1023u, 20)\n4190208u\n>>> circularRightShift(15u, 2)\n3221225475u\n>>> circularRightShift(256u, 8)\n1u"
    },
    "instruction_bertscore": {
      "sq": "0.9827582870350287",
      "hy": "0.9801206742052663",
      "bn": "0.9673662201782541",
      "bg": "0.990850290128009",
      "zh": "0.9742725985268371",
      "fr": "0.9898918985395155",
      "de": "0.9971325718193803",
      "ha": "0.8421909430931158",
      "hi": "0.9740022625782486",
      "hu": "0.9880799922037153"
    },
    "level": "easy",
    "test": "fun main() {\n    check(circularRightShift(1023u, 20) == 4190208u)\n    check(circularRightShift(15u, 2) == 3221225475u)\n    check(circularRightShift(256u, 8) == 1u)\n    check(circularRightShift(123u, 5) == 3623878659u)\n    check(circularRightShift(4294967295u, 1) == 4294967295u)\n    check(circularRightShift(1024u, 10) == 1u)\n    check(circularRightShift(0u, 15) == 0u)\n}\nmain()",
    "entry_point": "circularRightShift",
    "signature": "fun circularRightShift(num: UInt, shift: Int): UInt",
    "docstring": {
      "en": "Performs a right circular shift on a given unsigned 32-bit integer.\nThe function shifts the bits of the input number to the right by a specified number of positions.\nThe bits that are shifted out on the right are reinserted on the left side.\n\nExample:\n>>> circularRightShift(1023u, 20)\n4190208u\n>>> circularRightShift(15u, 2)\n3221225475u\n>>> circularRightShift(256u, 8)\n1u",
      "sq": "Kryen një zhvendosje rrethore në të djathtë mbi një numër të dhënë të papërshkruar 32-bitësh.\nFunksioni zhvendos bitet e numrit të hyrjes në të djathtë nga një numër i specifikuar pozicionesh.\nBitët që zhvendosen jashtë në të djathtë ri-futen në anën e majtë.\n\nShembull:\n>>> circularRightShift(1023u, 20)\n4190208u\n>>> circularRightShift(15u, 2)\n3221225475u\n>>> circularRightShift(256u, 8)\n1u",
      "hy": "Կատարում է աջ շրջանաձև տեղաշարժ նշված 32-բիթանոց անստորակետ ամբողջ թվի վրա։\nՖունկցիան տեղաշարժում է մուտքային թվի բիթերը աջ՝ նշված քանակությամբ դիրքերի։\nԱջից դուրս եկած բիթերը վերատեղադրվում են ձախ կողմում։\n\nՕրինակ:\n>>> circularRightShift(1023u, 20)\n4190208u\n>>> circularRightShift(15u, 2)\n3221225475u\n>>> circularRightShift(256u, 8)\n1u",
      "bn": "একটি প্রদত্ত ৩২-বিট স্বাক্ষরহীন পূর্ণসংখ্যার উপর ডানদিকে বৃত্তাকার স্থানান্তর সম্পন্ন করে। ফাংশনটি ইনপুট সংখ্যার বিটগুলোকে নির্দিষ্ট সংখ্যক অবস্থানে ডানদিকে স্থানান্তর করে। ডানদিকে স্থানান্তরিত বিটগুলো বামদিকে পুনরায় প্রবেশ করানো হয়।\n\nউদাহরণ:\n>>> circularRightShift(1023u, 20)\n4190208u\n>>> circularRightShift(15u, 2)\n3221225475u\n>>> circularRightShift(256u, 8)\n1u",
      "bg": "Извършва дясно кръгово изместване на дадено беззнаково 32-битово цяло число.  \nФункцията измества битовете на входното число надясно с определен брой позиции.  \nБитовете, които се изместват извън дясната страна, се поставят отново от лявата страна.\n\nПример:\n>>> circularRightShift(1023u, 20)\n4190208u\n>>> circularRightShift(15u, 2)\n3221225475u\n>>> circularRightShift(256u, 8)\n1u",
      "zh": "对给定的无符号32位整数执行右循环移位。\n该函数将输入数字的位向右移动指定数量的位置。\n在右侧移出的位会重新插入到左侧。\n\n示例：\n>>> circularRightShift(1023u, 20)\n4190208u\n>>> circularRightShift(15u, 2)\n3221225475u\n>>> circularRightShift(256u, 8)\n1u",
      "fr": "Effectue une rotation circulaire à droite sur un entier non signé de 32 bits donné.  \nLa fonction déplace les bits du nombre d'entrée vers la droite d'un nombre spécifié de positions.  \nLes bits qui sont décalés à droite sont réinsérés sur le côté gauche.\n\nExemple :\n>>> circularRightShift(1023u, 20)\n4190208u\n>>> circularRightShift(15u, 2)\n3221225475u\n>>> circularRightShift(256u, 8)\n1u",
      "de": "Führt eine zyklische Rechtsverschiebung auf einer gegebenen 32-Bit-Unsigned-Integer durch.  \nDie Funktion verschiebt die Bits der Eingabezahl um eine angegebene Anzahl von Positionen nach rechts.  \nDie Bits, die rechts herausgeschoben werden, werden auf der linken Seite wieder eingefügt.\n\nBeispiel:\n>>> circularRightShift(1023u, 20)\n4190208u\n>>> circularRightShift(15u, 2)\n3221225475u\n>>> circularRightShift(256u, 8)\n1u",
      "ha": "Yana yin juyawar madauwari na dama akan wani baƙaƙen lamba 32-bit mara sa hannu.\nAikin yana juyar da bitocin lamban shigarwa zuwa dama ta wurin adadin matsayi da aka fayyace.\nBitocin da aka juyar daga dama ana sake saka su a gefen hagu.\n\nMisali:\n>>> circularRightShift(1023u, 20)\n4190208u\n>>> circularRightShift(15u, 2)\n3221225475u\n>>> circularRightShift(256u, 8)\n1u",
      "hi": "दिए गए बिना चिन्ह वाले 32-बिट पूर्णांक पर दाएं गोलाकार शिफ्ट करता है। \nयह फ़ंक्शन इनपुट संख्या के बिट्स को निर्दिष्ट संख्या के स्थानों से दाईं ओर शिफ्ट करता है। \nजो बिट्स दाईं ओर से बाहर शिफ्ट होते हैं, उन्हें बाईं ओर पुनः डाला जाता है।\n\nउदाहरण:\n>>> circularRightShift(1023u, 20)\n4190208u\n>>> circularRightShift(15u, 2)\n3221225475u\n>>> circularRightShift(256u, 8)\n1u",
      "hu": "Végrehajt egy jobbra körkörös eltolást egy adott előjel nélküli 32 bites egész számon.\nA függvény eltolja a bemeneti szám bitjeit jobbra egy megadott pozíciószámmal.\nA jobbról kitolt bitek visszaillesztésre kerülnek a bal oldalon.\n\nPélda:\n>>> circularRightShift(1023u, 20)\n4190208u\n>>> circularRightShift(15u, 2)\n3221225475u\n>>> circularRightShift(256u, 8)\n1u"
    },
    "docstring_bertscore": {
      "sq": "0.9823717523135347",
      "hy": "0.967701706891822",
      "bn": "0.9472610516402837",
      "bg": "0.9787098026087755",
      "zh": "0.9687145232047188",
      "fr": "0.9789672275825967",
      "de": "0.9885994106501216",
      "ha": "0.9626384198488617",
      "hi": "0.9561920694627554",
      "hu": "0.9843016450956696"
    }
  },
  {
    "task_id": "Kotlin/18",
    "prompt": {
      "en": "/**\n    * Determines if a given integer is a perfect number. A perfect number is one whose\n    * sum of all positive divisors (excluding itself) equals the number itself.\n    * \n    * Examples:\n    * - isPerfectNumber(6) returns true because 1 + 2 + 3 = 6\n    * - isPerfectNumber(28) returns true because 1 + 2 + 4 + 7 + 14 = 28\n    * - isPerfectNumber(10) returns false because 1 + 2 + 5 ≠ 10\n**/\n\n\nfun isPerfectNumber(number: Int): Boolean ",
      "sq": "/**\n    * Përcakton nëse një numër i dhënë është numër perfekt. Një numër perfekt është ai\n    * shuma e të gjithë pjesëtarëve pozitivë (përjashtuar vetveten) është e barabartë me vetë numrin.\n    * \n    * Shembuj:\n    * - isPerfectNumber(6) kthen true sepse 1 + 2 + 3 = 6\n    * - isPerfectNumber(28) kthen true sepse 1 + 2 + 4 + 7 + 14 = 28\n    * - isPerfectNumber(10) kthen false sepse 1 + 2 + 5 ≠ 10\n**/",
      "hy": "/**\n    * Սահմանում է, արդյոք տրված ամբողջ թիվը կատարյալ թիվ է։ Կատարյալ թիվը այն է,\n    * որի բոլոր դրական բաժանարարների գումարը (բացառությամբ իրեն) հավասար է ինքին։\n    * \n    * Օրինակներ:\n    * - isPerfectNumber(6) վերադարձնում է true, քանի որ 1 + 2 + 3 = 6\n    * - isPerfectNumber(28) վերադարձնում է true, քանի որ 1 + 2 + 4 + 7 + 14 = 28\n    * - isPerfectNumber(10) վերադարձնում է false, քանի որ 1 + 2 + 5 ≠ 10\n**/",
      "bn": "/**\n    * একটি প্রদত্ত পূর্ণসংখ্যা একটি নিখুঁত সংখ্যা কিনা তা নির্ধারণ করে। একটি নিখুঁত সংখ্যা হল এমন একটি সংখ্যা\n    * যার সমস্ত ধনাত্মক বিভাজকের (নিজেকে বাদ দিয়ে) যোগফল সংখ্যাটির সমান।\n    * \n    * উদাহরণ:\n    * - isPerfectNumber(6) সত্য ফেরত দেয় কারণ 1 + 2 + 3 = 6\n    * - isPerfectNumber(28) সত্য ফেরত দেয় কারণ 1 + 2 + 4 + 7 + 14 = 28\n    * - isPerfectNumber(10) মিথ্যা ফেরত দেয় কারণ 1 + 2 + 5 ≠ 10\n**/",
      "bg": "/**\n    * Определя дали дадено цяло число е перфектно число. Перфектно число е това, чиято\n    * сума на всички положителни делители (без самото число) е равна на самото число.\n    * \n    * Примери:\n    * - isPerfectNumber(6) връща true, защото 1 + 2 + 3 = 6\n    * - isPerfectNumber(28) връща true, защото 1 + 2 + 4 + 7 + 14 = 28\n    * - isPerfectNumber(10) връща false, защото 1 + 2 + 5 ≠ 10\n**/\n\n\nfun isPerfectNumber(number: Int): Boolean ",
      "zh": "/**\n    * 确定给定的整数是否为完全数。完全数是指其所有正除数（不包括自身）之和等于其本身的数。\n    * \n    * 示例:\n    * - isPerfectNumber(6) 返回 true，因为 1 + 2 + 3 = 6\n    * - isPerfectNumber(28) 返回 true，因为 1 + 2 + 4 + 7 + 14 = 28\n    * - isPerfectNumber(10) 返回 false，因为 1 + 2 + 5 ≠ 10\n**/\n\n\nfun isPerfectNumber(number: Int): Boolean ",
      "fr": "/**\n    * Détermine si un entier donné est un nombre parfait. Un nombre parfait est un nombre dont\n    * la somme de tous les diviseurs positifs (à l'exclusion de lui-même) est égale au nombre lui-même.\n    * \n    * Exemples :\n    * - isPerfectNumber(6) retourne true car 1 + 2 + 3 = 6\n    * - isPerfectNumber(28) retourne true car 1 + 2 + 4 + 7 + 14 = 28\n    * - isPerfectNumber(10) retourne false car 1 + 2 + 5 ≠ 10\n**/\n\n\nfun isPerfectNumber(number: Int): Boolean ",
      "de": "/**\n    * Bestimmt, ob eine gegebene ganze Zahl eine vollkommene Zahl ist. Eine vollkommene Zahl ist eine Zahl, deren\n    * Summe aller positiven Teiler (ohne sich selbst) der Zahl selbst entspricht.\n    * \n    * Beispiele:\n    * - isPerfectNumber(6) gibt true zurück, weil 1 + 2 + 3 = 6\n    * - isPerfectNumber(28) gibt true zurück, weil 1 + 2 + 4 + 7 + 14 = 28\n    * - isPerfectNumber(10) gibt false zurück, weil 1 + 2 + 5 ≠ 10\n**/",
      "ha": "/**\n    * Yana tantance idan wani lamba cikakke ne. Lamba cikakke ita ce wadda\n    * jimillar dukkan masu raba ta masu kyau (ba tare da hada kanta ba) ta yi daidai da lambarta.\n    * \n    * Misalai:\n    * - isPerfectNumber(6) yana dawowa gaskiya saboda 1 + 2 + 3 = 6\n    * - isPerfectNumber(28) yana dawowa gaskiya saboda 1 + 2 + 4 + 7 + 14 = 28\n    * - isPerfectNumber(10) yana dawowa ƙarya saboda 1 + 2 + 5 ≠ 10\n**/",
      "hi": "/**\n    * यह निर्धारित करता है कि दिया गया पूर्णांक एक परिपूर्ण संख्या है या नहीं। एक परिपूर्ण संख्या वह होती है \n    * जिसकी सभी सकारात्मक भाजकों (स्वयं को छोड़कर) का योग संख्या के बराबर होता है।\n    * \n    * उदाहरण:\n    * - isPerfectNumber(6) true लौटाता है क्योंकि 1 + 2 + 3 = 6\n    * - isPerfectNumber(28) true लौटाता है क्योंकि 1 + 2 + 4 + 7 + 14 = 28\n    * - isPerfectNumber(10) false लौटाता है क्योंकि 1 + 2 + 5 ≠ 10\n**/",
      "hu": "/**\n    * Meghatározza, hogy egy adott egész szám tökéletes szám-e. Egy tökéletes szám olyan szám,\n    * amelynek összes pozitív osztója (önmagát kivéve) összege megegyezik magával a számmal.\n    * \n    * Példák:\n    * - isPerfectNumber(6) igazat ad vissza, mert 1 + 2 + 3 = 6\n    * - isPerfectNumber(28) igazat ad vissza, mert 1 + 2 + 4 + 7 + 14 = 28\n    * - isPerfectNumber(10) hamisat ad vissza, mert 1 + 2 + 5 ≠ 10\n**/"
    },
    "prompt_bertscore": {
      "sq": "0.9502144867758915",
      "hy": "0.9434211291141172",
      "bn": "0.9548030472081784",
      "bg": "0.9769592730607151",
      "zh": "0.9857452907050313",
      "fr": "0.982879650197841",
      "de": "0.960317225216088",
      "ha": "0.9246495649544152",
      "hi": "0.9492074307440446",
      "hu": "0.9587524150742951"
    },
    "canonical_solution": "{\n    if (number == 1) return false\n    var sum = 0\n    for (i in 1 until number) {\n        if (number % i == 0) {\n            sum += i\n        }\n    }\n    return sum == number\n}",
    "instruction": {
      "en": "Write a Kotlin function `fun isPerfectNumber(number: Int): Boolean` to solve the following problem:\nDetermines if a given integer is a perfect number. A perfect number is one whose\nsum of all positive divisors (excluding itself) equals the number itself.\n\nExamples:\n- isPerfectNumber(6) returns true because 1 + 2 + 3 = 6\n- isPerfectNumber(28) returns true because 1 + 2 + 4 + 7 + 14 = 28\n- isPerfectNumber(10) returns false because 1 + 2 + 5 ≠ 10",
      "sq": "Shkruani një funksion Kotlin `fun isPerfectNumber(number: Int): Boolean` për të zgjidhur problemin e mëposhtëm:\nPërcakton nëse një numër i dhënë është numër perfekt. Një numër perfekt është ai numër, shuma e të gjithë divizorëve pozitivë (përveç vetes) është e barabartë me vetë numrin.\n\nShembuj:\n- isPerfectNumber(6) kthen true sepse 1 + 2 + 3 = 6\n- isPerfectNumber(28) kthen true sepse 1 + 2 + 4 + 7 + 14 = 28\n- isPerfectNumber(10) kthen false sepse 1 + 2 + 5 ≠ 10",
      "hy": "Գրեք Kotlin ֆունկցիա `fun isPerfectNumber(number: Int): Boolean` հետևյալ խնդիրը լուծելու համար:\nՈրոշում է, արդյոք տրված ամբողջ թիվը կատարյալ թիվ է։ Կատարյալ թիվը այն է, որի բոլոր դրական բաժանարարների գումարը (բացառությամբ իրեն) հավասար է հենց թվին։\n\nՕրինակներ:\n- isPerfectNumber(6) վերադարձնում է true, որովհետև 1 + 2 + 3 = 6\n- isPerfectNumber(28) վերադարձնում է true, որովհետև 1 + 2 + 4 + 7 + 14 = 28\n- isPerfectNumber(10) վերադարձնում է false, որովհետև 1 + 2 + 5 ≠ 10",
      "bn": "Kotlin ফাংশন `fun isPerfectNumber(number: Int): Boolean` লিখুন নিম্নলিখিত সমস্যার সমাধানের জন্য:\nনির্ধারণ করে একটি প্রদত্ত পূর্ণসংখ্যা একটি পারফেক্ট সংখ্যা কিনা। একটি পারফেক্ট সংখ্যা সেই সংখ্যা যার সব ধনাত্মক ভাজক (নিজেকে বাদ দিয়ে) এর সমষ্টি সংখ্যা নিজেই সমান হয়।\n\nউদাহরণসমূহ:\n- isPerfectNumber(6) true প্রদান করে কারণ 1 + 2 + 3 = 6\n- isPerfectNumber(28) true প্রদান করে কারণ 1 + 2 + 4 + 7 + 14 = 28\n- isPerfectNumber(10) false প্রদান করে কারণ 1 + 2 + 5 ≠ 10",
      "bg": "Напишете Kotlin функция `fun isPerfectNumber(number: Int): Boolean`, за да решите следния проблем:\nОпределя дали дадено цяло число е съвършено число. Съвършено число е такова, чиято\nсума на всички положителни делители (без да включва самото число) е равна на самото число.\n\nПримери:\n- isPerfectNumber(6) връща true, защото 1 + 2 + 3 = 6\n- isPerfectNumber(28) връща true, защото 1 + 2 + 4 + 7 + 14 = 28\n- isPerfectNumber(10) връща false, защото 1 + 2 + 5 ≠ 10",
      "zh": "编写一个 Kotlin 函数 `fun isPerfectNumber(number: Int): Boolean` 来解决以下问题：\n判断给定的整数是否是一个完全数。完全数是指其所有正因子（不包括自身）之和等于其本身的数。\n\n例子：\n- isPerfectNumber(6) 返回 true，因为 1 + 2 + 3 = 6\n- isPerfectNumber(28) 返回 true，因为 1 + 2 + 4 + 7 + 14 = 28\n- isPerfectNumber(10) 返回 false，因为 1 + 2 + 5 ≠ 10",
      "fr": "Écrire une fonction Kotlin `fun isPerfectNumber(number: Int): Boolean` pour résoudre le problème suivant :  \nDétermine si un entier donné est un nombre parfait. Un nombre parfait est un nombre dont la somme de tous les diviseurs positifs (à l'exclusion de lui-même) est égale au nombre lui-même.\n\nExemples :  \n- isPerfectNumber(6) retourne true parce que 1 + 2 + 3 = 6  \n- isPerfectNumber(28) retourne true parce que 1 + 2 + 4 + 7 + 14 = 28  \n- isPerfectNumber(10) retourne false parce que 1 + 2 + 5 ≠ 10  ",
      "de": "Schreiben Sie eine Kotlin-Funktion `fun isPerfectNumber(number: Int): Boolean`, um das folgende Problem zu lösen:\nBestimmt, ob eine gegebene ganze Zahl eine perfekte Zahl ist. Eine perfekte Zahl ist eine Zahl, deren Summe aller positiven Teiler (ohne sich selbst) der Zahl selbst entspricht.\n\nBeispiele:\n- isPerfectNumber(6) gibt true zurück, weil 1 + 2 + 3 = 6\n- isPerfectNumber(28) gibt true zurück, weil 1 + 2 + 4 + 7 + 14 = 28\n- isPerfectNumber(10) gibt false zurück, weil 1 + 2 + 5 ≠ 10",
      "ha": "Rubuta aikin Kotlin `fun isPerfectNumber(number: Int): Boolean` don warware matsalar mai zuwa:  \nYana tantance idan wani cikakken lamba ne. Cikakken lamba ita ce wadda jimillar duk masu rarrabawa masu kyau (ban da kanta) ta yi daidai da lambar kanta.\n\nMisalai:\n- isPerfectNumber(6) yana dawowa da true saboda 1 + 2 + 3 = 6\n- isPerfectNumber(28) yana dawowa da true saboda 1 + 2 + 4 + 7 + 14 = 28\n- isPerfectNumber(10) yana dawowa da false saboda 1 + 2 + 5 ≠ 10",
      "hi": "Kotlin फ़ंक्शन `fun isPerfectNumber(number: Int): Boolean` लिखें ताकि निम्नलिखित समस्या का समाधान हो सके:\nनिर्धारित करता है कि दिया गया पूर्णांक एक परफेक्ट नंबर है या नहीं। एक परफेक्ट नंबर वह होता है जिसका सभी सकारात्मक भाजकों (स्वयं को छोड़कर) का योग संख्या के बराबर होता है।\n\nउदाहरण:\n- isPerfectNumber(6) true लौटाता है क्योंकि 1 + 2 + 3 = 6\n- isPerfectNumber(28) true लौटाता है क्योंकि 1 + 2 + 4 + 7 + 14 = 28\n- isPerfectNumber(10) false लौटाता है क्योंकि 1 + 2 + 5 ≠ 10",
      "hu": "Írj egy Kotlin függvényt `fun isPerfectNumber(number: Int): Boolean` a következő probléma megoldására:\nMeghatározza, hogy egy adott egész szám tökéletes szám-e. Egy tökéletes szám olyan szám, amelynek összes pozitív osztója (önmagát kivéve) összege megegyezik magával a számmal.\n\nPéldák:\n- isPerfectNumber(6) visszaadja az igaz értéket, mert 1 + 2 + 3 = 6\n- isPerfectNumber(28) visszaadja az igaz értéket, mert 1 + 2 + 4 + 7 + 14 = 28\n- isPerfectNumber(10) visszaadja a hamis értéket, mert 1 + 2 + 5 ≠ 10"
    },
    "instruction_bertscore": {
      "sq": "0.9829388420513893",
      "hy": "0.9895327748106045",
      "bn": "0.9748708732345143",
      "bg": "0.9828808419801272",
      "zh": "0.9540591764312027",
      "fr": "0.9840607064434743",
      "de": "0.995035432256414",
      "ha": "0.9755118534741138",
      "hi": "0.97057648439654",
      "hu": "0.9861939967357891"
    },
    "level": "easy",
    "test": "fun main(){\n    check(isPerfectNumber(1) == false)  // 6 is a perfect number\n    check(isPerfectNumber(6) == true)  // 6 is a perfect number\n    check(isPerfectNumber(28) == true)  // 28 is a perfect number\n    check(isPerfectNumber(10) == false)  // 10 is not a perfect number\n    check(isPerfectNumber(496) == true)  // 496 is a perfect number\n    check(isPerfectNumber(8128) == true)  // 8128 is a perfect number\n    check(isPerfectNumber(15) == false)  // 15 is not a perfect number\n    check(isPerfectNumber(20) == false)  // 20 is not a perfect number\n\n\n}\nmain()",
    "entry_point": "isPerfectNumber",
    "signature": "fun isPerfectNumber(number: Int): Boolean",
    "docstring": {
      "en": "Determines if a given integer is a perfect number. A perfect number is one whose\nsum of all positive divisors (excluding itself) equals the number itself.\n\nExamples:\n- isPerfectNumber(6) returns true because 1 + 2 + 3 = 6\n- isPerfectNumber(28) returns true because 1 + 2 + 4 + 7 + 14 = 28\n- isPerfectNumber(10) returns false because 1 + 2 + 5 ≠ 10",
      "sq": "Përcakton nëse një numër i dhënë është numër perfekt. Një numër perfekt është ai, shuma e të gjithë ndarësve pozitivë (përjashtuar vetveten) e të cilit është e barabartë me vetë numrin.\n\nShembuj:\n- isPerfectNumber(6) kthen true sepse 1 + 2 + 3 = 6\n- isPerfectNumber(28) kthen true sepse 1 + 2 + 4 + 7 + 14 = 28\n- isPerfectNumber(10) kthen false sepse 1 + 2 + 5 ≠ 10",
      "hy": "Սահմանում է, արդյոք տրված ամբողջ թիվը կատարյալ թիվ է։ Կատարյալ թիվը այն է, որի բոլոր դրական բաժանարարների գումարը (բացառությամբ իրեն) հավասար է հենց այդ թվին։\n\nՕրինակներ:\n- isPerfectNumber(6) վերադարձնում է true, որովհետև 1 + 2 + 3 = 6\n- isPerfectNumber(28) վերադարձնում է true, որովհետև 1 + 2 + 4 + 7 + 14 = 28\n- isPerfectNumber(10) վերադարձնում է false, որովհետև 1 + 2 + 5 ≠ 10",
      "bn": "নির্ধারণ করে যে একটি প্রদত্ত পূর্ণসংখ্যা একটি নিখুঁত সংখ্যা কিনা। একটি নিখুঁত সংখ্যা হল এমন একটি সংখ্যা যার সমস্ত ধনাত্মক গুণনীয়কের (নিজেকে বাদ দিয়ে) যোগফল সংখ্যাটির সমান হয়।\n\nউদাহরণ:\n- isPerfectNumber(6) সত্য ফেরত দেয় কারণ 1 + 2 + 3 = 6\n- isPerfectNumber(28) সত্য ফেরত দেয় কারণ 1 + 2 + 4 + 7 + 14 = 28\n- isPerfectNumber(10) মিথ্যা ফেরত দেয় কারণ 1 + 2 + 5 ≠ 10",
      "bg": "Определя дали дадено цяло число е съвършено число. Съвършено число е такова, чиято сума от всички положителни делители (без самото число) е равна на самото число.\n\nПримери:\n- isPerfectNumber(6) връща true, защото 1 + 2 + 3 = 6\n- isPerfectNumber(28) връща true, защото 1 + 2 + 4 + 7 + 14 = 28\n- isPerfectNumber(10) връща false, защото 1 + 2 + 5 ≠ 10",
      "zh": "确定给定的整数是否是一个完全数。完全数是指其所有正因子（不包括其自身）的和等于该数本身的数。\n\n示例：\n- isPerfectNumber(6) 返回 true，因为 1 + 2 + 3 = 6\n- isPerfectNumber(28) 返回 true，因为 1 + 2 + 4 + 7 + 14 = 28\n- isPerfectNumber(10) 返回 false，因为 1 + 2 + 5 ≠ 10",
      "fr": "Détermine si un entier donné est un nombre parfait. Un nombre parfait est un nombre dont la somme de tous les diviseurs positifs (à l'exclusion de lui-même) est égale au nombre lui-même.\n\nExemples :\n- isPerfectNumber(6) retourne true parce que 1 + 2 + 3 = 6\n- isPerfectNumber(28) retourne true parce que 1 + 2 + 4 + 7 + 14 = 28\n- isPerfectNumber(10) retourne false parce que 1 + 2 + 5 ≠ 10",
      "de": "Bestimmt, ob eine gegebene ganze Zahl eine vollkommene Zahl ist. Eine vollkommene Zahl ist eine Zahl, deren Summe aller positiven Teiler (ohne sich selbst) der Zahl selbst entspricht.\n\nBeispiele:\n- isPerfectNumber(6) gibt true zurück, weil 1 + 2 + 3 = 6\n- isPerfectNumber(28) gibt true zurück, weil 1 + 2 + 4 + 7 + 14 = 28\n- isPerfectNumber(10) gibt false zurück, weil 1 + 2 + 5 ≠ 10",
      "ha": "Yana tantance idan wani cikakken lamba ne. Cikakken lamba ita ce wadda jimillar duk masu rarrabawa masu kyau (ban da kanta) ta yi daidai da lambar kanta.\n\nMisalai:\n- isPerfectNumber(6) returns true saboda 1 + 2 + 3 = 6\n- isPerfectNumber(28) returns true saboda 1 + 2 + 4 + 7 + 14 = 28\n- isPerfectNumber(10) returns false saboda 1 + 2 + 5 ≠ 10",
      "hi": "निर्धारित करता है कि दिया गया पूर्णांक एक परिपूर्ण संख्या है या नहीं। एक परिपूर्ण संख्या वह होती है जिसकी सभी धनात्मक भाजकों (स्वयं को छोड़कर) का योग संख्या के बराबर होता है।\n\nउदाहरण:\n- isPerfectNumber(6) true लौटाता है क्योंकि 1 + 2 + 3 = 6\n- isPerfectNumber(28) true लौटाता है क्योंकि 1 + 2 + 4 + 7 + 14 = 28\n- isPerfectNumber(10) false लौटाता है क्योंकि 1 + 2 + 5 ≠ 10",
      "hu": "Meghatározza, hogy egy adott egész szám tökéletes szám-e. Egy tökéletes szám olyan szám, amelynek összes pozitív osztója (kivéve önmagát) összege megegyezik magával a számmal.\n\nPéldák:\n- isPerfectNumber(6) igazat ad vissza, mert 1 + 2 + 3 = 6\n- isPerfectNumber(28) igazat ad vissza, mert 1 + 2 + 4 + 7 + 14 = 28\n- isPerfectNumber(10) hamisat ad vissza, mert 1 + 2 + 5 ≠ 10"
    },
    "docstring_bertscore": {
      "sq": "0.9856539207297552",
      "hy": "0.9863991819193981",
      "bn": "0.9702801278680359",
      "bg": "0.9709312382570683",
      "zh": "0.9646986141609555",
      "fr": "0.9759720800669717",
      "de": "0.9940172529232292",
      "ha": "1",
      "hi": "0.9701776345914219",
      "hu": "0.9794792967049046"
    }
  },
  {
    "task_id": "Kotlin/19",
    "prompt": {
      "en": "/**\n * Time passed quickly, and Wang Wang had reached the age of months for vaccination. Wang Wang came to the hospital and wanted to give himself a shot of rabies vaccine, but he couldn't resist the doctor's temptation. He needs a total of 4 injections. He first received three shots of Miao Sanduo, and then the rabies vaccine. A shot of Miao Sanduo costs 120 yuan, and a shot of rabies vaccine costs 100 yuan. However, Wang Wang only has a yuan of money and cannot take all the shots at once. At this time, the doctor said: \"How can we complete the injection at one time? There needs to be a month's interval between every two injections...\" So Wang Wang decided to save money while giving himself injections (because Wang Wang is a meow who loves injections), Wang Wang If I can save B yuan every month, how many vaccinations can Wangwang get on time?\n * Example:\n * >>> calculateMaxVaccinations(10, 200)\n *     0\n * >>> calculateMaxVaccinations(150, 100)\n *     2\n * >>> calculateMaxVaccinations(500, 100)\n *     4\n */\n\nfun calculateMaxVaccinations(\n    initialAmount: Int, \n    monthlySavings: Int, \n): Int ",
      "sq": "/**\n * Koha kaloi shpejt, dhe Wang Wang kishte arritur moshën e muajve për vaksinim. Wang Wang erdhi në spital dhe dëshironte t'i jepte vetes një injeksion të vaksinës kundër tërbimit, por nuk mundi t'i rezistonte tundimit të mjekut. Ai ka nevojë për gjithsej 4 injeksione. Ai fillimisht mori tre injeksione të Miao Sanduo, dhe pastaj vaksinën kundër tërbimit. Një injeksion i Miao Sanduo kushton 120 juan, dhe një injeksion i vaksinës kundër tërbimit kushton 100 juan. Megjithatë, Wang Wang ka vetëm një juan para dhe nuk mund t'i marrë të gjitha injeksionet menjëherë. Në këtë kohë, mjeku tha: \"Si mund ta përfundojmë injeksionin në një kohë? Duhet të ketë një interval prej një muaji midis çdo dy injeksioneve...\" Kështu që Wang Wang vendosi të kursejë para ndërsa i jep vetes injeksione (sepse Wang Wang është një meow që i pëlqen injeksionet), Wang Wang Nëse mund të kursej B juan çdo muaj, sa vaksinime mund të marrë Wangwang në kohë?\n * Shembull:\n * >>> calculateMaxVaccinations(10, 200)\n *     0\n * >>> calculateMaxVaccinations(150, 100)\n *     2\n * >>> calculateMaxVaccinations(500, 100)\n *     4\n */",
      "hy": "/**\n * Ժամանակը արագ անցավ, և Վանգ Վանգը հասավ պատվաստման ամիսների տարիքի։ Վանգ Վանգը եկավ հիվանդանոց և ուզում էր իրեն կատաղության դեմ պատվաստում անել, բայց նա չկարողացավ դիմադրել բժշկի գայթակղությանը։ Նա ընդհանուր առմամբ 4 ներարկում պետք է ստանա։ Սկզբում նա ստացավ Միաո Սանդուոյի երեք ներարկում, ապա կատաղության դեմ պատվաստում։ Միաո Սանդուոյի մեկ ներարկումը արժե 120 յուան, իսկ կատաղության դեմ պատվաստումը արժե 100 յուան։ Սակայն Վանգ Վանգը միայն ունի յուան գումար և չի կարող բոլոր ներարկումները միանգամից ստանալ։ Այդ ժամանակ բժիշկն ասաց. \"Ինչպե՞ս կարող ենք միանգամից կատարել ներարկումը։ Յուրաքանչյուր երկու ներարկումների միջև պետք է լինի մեկ ամսվա ընդմիջում...\" Այսպիսով, Վանգ Վանգը որոշեց գումար խնայել, մինչ ինքը ներարկումներ է անում (քանի որ Վանգ Վանգը մի մեաո է, ով սիրում է ներարկումներ), Վանգ Վանգ Եթե ես կարողանամ խնայել B յուան ամեն ամիս, քանի՞ պատվաստում կարող է Վանգվանգը ստանալ ժամանակին։\n * Օրինակ:\n * >>> calculateMaxVaccinations(10, 200)\n *     0\n * >>> calculateMaxVaccinations(150, 100)\n *     2\n * >>> calculateMaxVaccinations(500, 100)\n *     4\n */",
      "bn": "/**\n * সময় দ্রুত কেটে গেল, এবং ওয়াং ওয়াং টিকাদানের জন্য মাসের বয়সে পৌঁছেছিল। ওয়াং ওয়াং হাসপাতালে এসে নিজেকে জলাতঙ্কের টিকা দিতে চেয়েছিল, কিন্তু সে ডাক্তারের প্রলোভন প্রতিরোধ করতে পারেনি। তার মোট ৪টি ইনজেকশন প্রয়োজন। প্রথমে সে তিনটি মিয়াও সানডুওর শট নেয়, তারপর জলাতঙ্কের টিকা। একটি মিয়াও সানডুওর শটের খরচ ১২০ ইউয়ান, এবং একটি জলাতঙ্কের টিকার খরচ ১০০ ইউয়ান। তবে, ওয়াং ওয়াং-এর কাছে কেবল একটি ইউয়ান অর্থ আছে এবং সে একবারে সব শট নিতে পারে না। এই সময়, ডাক্তার বললেন: \"কিভাবে আমরা একবারে ইনজেকশন সম্পূর্ণ করতে পারি? প্রতিটি দুই ইনজেকশনের মধ্যে এক মাসের ব্যবধান থাকা প্রয়োজন...\" তাই ওয়াং ওয়াং ইনজেকশন দেওয়ার সময় অর্থ সঞ্চয় করার সিদ্ধান্ত নিল (কারণ ওয়াং ওয়াং একটি মিয়াও যে ইনজেকশন ভালোবাসে), ওয়াং ওয়াং যদি প্রতি মাসে বি ইউয়ান সঞ্চয় করতে পারে, তাহলে ওয়াংওয়াং কতগুলি টিকা সময়মতো পেতে পারে?\n * উদাহরণ:\n * >>> calculateMaxVaccinations(10, 200)\n *     0\n * >>> calculateMaxVaccinations(150, 100)\n *     2\n * >>> calculateMaxVaccinations(500, 100)\n *     4\n */",
      "bg": "/**\n * Времето мина бързо и Ванг Ванг достигна възрастта за ваксинация. Ванг Ванг дойде в болницата и искаше да си направи инжекция против бяс, но не можеше да устои на изкушението на лекаря. Той се нуждае от общо 4 инжекции. Първо получи три инжекции от Мяо Сандуо, а след това ваксината против бяс. Една инжекция от Мяо Сандуо струва 120 юана, а една инжекция против бяс струва 100 юана. Въпреки това, Ванг Ванг има само определена сума пари и не може да направи всички инжекции наведнъж. В този момент лекарят каза: \"Как можем да завършим инжекциите наведнъж? Трябва да има месечен интервал между всяка две инжекции...\" Така че Ванг Ванг реши да спестява пари, докато си прави инжекции (защото Ванг Ванг е коте, което обича инжекции), Ванг Ванг Ако може да спести B юана всеки месец, колко ваксинации може да получи Ванг Ванг навреме?\n * Пример:\n * >>> calculateMaxVaccinations(10, 200)\n *     0\n * >>> calculateMaxVaccinations(150, 100)\n *     2\n * >>> calculateMaxVaccinations(500, 100)\n *     4\n */",
      "zh": "/**\n * 时间过得很快，汪汪已经到了接种疫苗的月龄。汪汪来到医院，想给自己打一针狂犬疫苗，但他无法抵挡医生的诱惑。他总共需要打4针。他先接种了三针妙三多，然后是狂犬疫苗。一针妙三多的费用是120元，一针狂犬疫苗的费用是100元。然而，汪汪只有a元钱，无法一次性打完所有针。这时医生说：“怎么能一次性完成注射呢？每两针之间需要间隔一个月……”于是汪汪决定一边攒钱一边给自己打针（因为汪汪是个爱打针的喵），汪汪如果每个月能存B元，汪汪能按时打多少针？\n * 例子：\n * >>> calculateMaxVaccinations(10, 200)\n *     0\n * >>> calculateMaxVaccinations(150, 100)\n *     2\n * >>> calculateMaxVaccinations(500, 100)\n *     4\n */",
      "fr": "/**\n * Le temps a passé rapidement, et Wang Wang avait atteint l'âge de mois pour la vaccination. Wang Wang est venu à l'hôpital et voulait se faire une injection de vaccin contre la rage, mais il ne pouvait pas résister à la tentation du médecin. Il a besoin d'un total de 4 injections. Il a d'abord reçu trois injections de Miao Sanduo, puis le vaccin contre la rage. Une injection de Miao Sanduo coûte 120 yuans, et une injection de vaccin contre la rage coûte 100 yuans. Cependant, Wang Wang n'a qu'un yuan d'argent et ne peut pas prendre toutes les injections en une seule fois. À ce moment-là, le médecin a dit : \"Comment pouvons-nous compléter l'injection en une seule fois ? Il doit y avoir un intervalle d'un mois entre chaque deux injections...\" Alors Wang Wang a décidé d'économiser de l'argent tout en se faisant des injections (parce que Wang Wang est un chat qui aime les injections), Wang Wang Si je peux économiser B yuans chaque mois, combien de vaccinations Wang Wang peut-il obtenir à temps ?\n * Exemple:\n * >>> calculateMaxVaccinations(10, 200)\n *     0\n * >>> calculateMaxVaccinations(150, 100)\n *     2\n * >>> calculateMaxVaccinations(500, 100)\n *     4\n */",
      "de": "/**\n * Die Zeit verging schnell, und Wang Wang hatte das Alter von Monaten für die Impfung erreicht. Wang Wang kam ins Krankenhaus und wollte sich eine Tollwutimpfung geben lassen, konnte aber der Versuchung des Arztes nicht widerstehen. Er benötigt insgesamt 4 Injektionen. Zuerst erhielt er drei Spritzen von Miao Sanduo und dann die Tollwutimpfung. Eine Spritze Miao Sanduo kostet 120 Yuan, und eine Spritze Tollwutimpfung kostet 100 Yuan. Wang Wang hat jedoch nur einen Yuan Geld und kann nicht alle Spritzen auf einmal nehmen. Zu diesem Zeitpunkt sagte der Arzt: \"Wie können wir die Injektion auf einmal abschließen? Es muss ein Monat Abstand zwischen jeweils zwei Injektionen sein...\" Also entschied sich Wang Wang, Geld zu sparen, während er sich Injektionen gibt (weil Wang Wang eine Mieze ist, die Injektionen liebt), Wang Wang Wenn ich jeden Monat B Yuan sparen kann, wie viele Impfungen kann Wangwang rechtzeitig bekommen?\n * Beispiel:\n * >>> calculateMaxVaccinations(10, 200)\n *     0\n * >>> calculateMaxVaccinations(150, 100)\n *     2\n * >>> calculateMaxVaccinations(500, 100)\n *     4\n */",
      "ha": "/**\n * Lokaci ya wuce da sauri, kuma Wang Wang ya kai shekarun watanni don yin rigakafi. Wang Wang ya zo asibiti kuma yana son yi wa kansa allurar rigakafin cutar hauka, amma bai iya tsayayya da jarabar likita ba. Yana bukatar allurai guda 4 gaba daya. Da farko ya karbi allurai uku na Miao Sanduo, sannan rigakafin cutar hauka. Allura daya ta Miao Sanduo tana kashe yuan 120, kuma allura daya ta rigakafin cutar hauka tana kashe yuan 100. Duk da haka, Wang Wang yana da yuan na kudi kawai kuma ba zai iya daukar dukkan allurai a lokaci daya ba. A wannan lokacin, likita ya ce: \"Ta yaya za mu kammala allurar a lokaci daya? Dole ne a sami tazarar wata daya tsakanin kowane allurai biyu...\" Don haka Wang Wang ya yanke shawarar adana kudi yayin da yake yi wa kansa allurai (saboda Wang Wang meow ne wanda ke son allurai), Wang Wang Idan zan iya adana yuan B a kowane wata, nawa ne alluran rigakafin da Wangwang zai iya samu akan lokaci?\n * Misali:\n * >>> calculateMaxVaccinations(10, 200)\n *     0\n * >>> calculateMaxVaccinations(150, 100)\n *     2\n * >>> calculateMaxVaccinations(500, 100)\n *     4\n */",
      "hi": "/**\n * समय तेजी से बीत गया, और वांग वांग टीकाकरण के महीनों की उम्र तक पहुँच गया था। वांग वांग अस्पताल आया और खुद को रेबीज वैक्सीन का एक शॉट देना चाहता था, लेकिन वह डॉक्टर के प्रलोभन का विरोध नहीं कर सका। उसे कुल 4 इंजेक्शन की आवश्यकता है। उसने पहले मियाओ सानडुओ के तीन शॉट प्राप्त किए, और फिर रेबीज वैक्सीन। मियाओ सानडुओ का एक शॉट 120 युआन का होता है, और रेबीज वैक्सीन का एक शॉट 100 युआन का होता है। हालाँकि, वांग वांग के पास केवल एक युआन का पैसा है और वह सभी शॉट्स एक बार में नहीं ले सकता। इस समय, डॉक्टर ने कहा: \"हम एक बार में इंजेक्शन कैसे पूरा कर सकते हैं? हर दो इंजेक्शन के बीच एक महीने का अंतराल होना चाहिए...\" इसलिए वांग वांग ने इंजेक्शन लगाते हुए पैसे बचाने का फैसला किया (क्योंकि वांग वांग एक म्याऊ है जो इंजेक्शन से प्यार करता है), वांग वांग अगर मैं हर महीने B युआन बचा सकता हूँ, तो वांगवांग समय पर कितने टीकाकरण प्राप्त कर सकता है?\n * उदाहरण:\n * >>> calculateMaxVaccinations(10, 200)\n *     0\n * >>> calculateMaxVaccinations(150, 100)\n *     2\n * >>> calculateMaxVaccinations(500, 100)\n *     4\n */",
      "hu": "/**\n * Az idő gyorsan telt, és Wang Wang elérte a hónapokat az oltáshoz. Wang Wang elment a kórházba, és szeretett volna magának egy veszettség elleni oltást adni, de nem tudott ellenállni az orvos csábításának. Összesen 4 injekcióra van szüksége. Először három Miao Sanduo injekciót kapott, majd a veszettség elleni oltást. Egy Miao Sanduo injekció 120 jüanba kerül, és egy veszettség elleni oltás 100 jüanba kerül. Azonban Wang Wangnak csak egy jüan pénze van, és nem tudja egyszerre bevenni az összes injekciót. Ekkor az orvos azt mondta: \"Hogyan tudnánk egyszerre befejezni az injekciót? Két injekció között egy hónapos szünetnek kell lennie...\" Így Wang Wang úgy döntött, hogy pénzt takarít meg, miközben magának ad injekciókat (mert Wang Wang egy meow, aki szereti az injekciókat), Wang Wang Ha havonta B jüant tud megtakarítani, hány oltást kaphat Wangwang időben?\n * Példa:\n * >>> calculateMaxVaccinations(10, 200)\n *     0\n * >>> calculateMaxVaccinations(150, 100)\n *     2\n * >>> calculateMaxVaccinations(500, 100)\n *     4\n */"
    },
    "prompt_bertscore": {
      "sq": "0.9460072966751916",
      "hy": "0.9179620772857325",
      "bn": "0.9123924814015143",
      "bg": "0.9137203254987325",
      "zh": "0.8947775419505783",
      "fr": "0.9276504727510902",
      "de": "0.9284074531332143",
      "ha": "0.930335955502682",
      "hi": "0.94206468224203",
      "hu": "0.9195453600529616"
    },
    "canonical_solution": "{\n    var miaoSanDuoPrice  = 120\n    var rabiesVaccinePrice = 150\n    var totalAmount = initialAmount\n    var vaccinations = 0\n\n    for (i in 1..4) {\n        // Check if MiaoSanDuo vaccine can be administered\n        if (i != 4 && totalAmount >= miaoSanDuoPrice) {\n            totalAmount -= miaoSanDuoPrice\n            vaccinations++\n        }\n        // Check if rabies vaccine can be administered\n        else if (i == 4 && totalAmount >= rabiesVaccinePrice) {\n            totalAmount -= rabiesVaccinePrice\n            vaccinations++\n        }\n        else{\n            return vaccinations\n        }\n\n        // Add monthly savings\n        if (i != 4) {\n            totalAmount += monthlySavings\n        }\n    }\n\n    return vaccinations\n}",
    "instruction": {
      "en": "Write a Kotlin function `fun calculateMaxVaccinations(\n    initialAmount: Int, \n    monthlySavings: Int, \n): Int` to solve the following problem:\nTime passed quickly, and Wang Wang had reached the age of months for vaccination. Wang Wang came to the hospital and wanted to give himself a shot of rabies vaccine, but he couldn't resist the doctor's temptation. He needs a total of 4 injections. He first received three shots of Miao Sanduo, and then the rabies vaccine. A shot of Miao Sanduo costs 120 yuan, and a shot of rabies vaccine costs 100 yuan. However, Wang Wang only has a yuan of money and cannot take all the shots at once. At this time, the doctor said: \"How can we complete the injection at one time? There needs to be a month's interval between every two injections...\" So Wang Wang decided to save money while giving himself injections (because Wang Wang is a meow who loves injections), Wang Wang If I can save B yuan every month, how many vaccinations can Wangwang get on time?\nExample:\n>>> calculateMaxVaccinations(10, 200)\n0\n>>> calculateMaxVaccinations(150, 100)\n2\n>>> calculateMaxVaccinations(500, 100)\n4",
      "sq": "Shkruani një funksion Kotlin `fun calculateMaxVaccinations(\n    initialAmount: Int, \n    monthlySavings: Int, \n): Int` për të zgjidhur problemin e mëposhtëm:\nKoha kaloi shpejt dhe Wang Wang kishte arritur moshën e muajve për vaksinim. Wang Wang erdhi në spital dhe donte t'i jepte vetes një injeksion të vaksinës kundër tërbimit, por nuk mundi t'i rezistonte tundimit të mjekut. Ai ka nevojë për gjithsej 4 injeksione. Ai fillimisht mori tre injeksione të Miao Sanduo, dhe pastaj vaksinën kundër tërbimit. Një injeksion i Miao Sanduo kushton 120 juan, dhe një injeksion i vaksinës kundër tërbimit kushton 100 juan. Megjithatë, Wang Wang ka vetëm një juan para dhe nuk mund t'i marrë të gjitha injeksionet menjëherë. Në këtë kohë, mjeku tha: \"Si mund të përfundojmë injeksionin në një herë? Duhet të ketë një interval prej një muaji midis çdo dy injeksioneve...\" Kështu që Wang Wang vendosi të kursejë para ndërsa i jep vetes injeksione (sepse Wang Wang është një meow që i pëlqen injeksionet), Wang Wang Nëse mund të kursej B juan çdo muaj, sa vaksina mund të marrë Wangwang në kohë?\nShembull:\n>>> calculateMaxVaccinations(10, 200)\n0\n>>> calculateMaxVaccinations(150, 100)\n2\n>>> calculateMaxVaccinations(500, 100)\n4",
      "hy": "Գրեք Kotlin ֆունկցիա `fun calculateMaxVaccinations(\n    initialAmount: Int, \n    monthlySavings: Int, \n): Int` հետևյալ խնդիրը լուծելու համար:\nԺամանակը արագ անցավ, և Վանգ Վանգը հասել էր պատվաստման ամիսների տարիքի։ Վանգ Վանգը եկավ հիվանդանոց և ուզում էր իրեն կատաղության պատվաստանյութի ներարկում անել, բայց նա չկարողացավ դիմադրել բժշկի գայթակղությանը։ Նրան անհրաժեշտ է ընդհանուր 4 ներարկում։ Նա նախ ստացավ երեք ներարկում Միաո Սանդուո, ապա կատաղության պատվաստանյութը։ Միաո Սանդուոյի ներարկումը արժե 120 յուան, իսկ կատաղության պատվաստանյութի ներարկումը՝ 100 յուան։ Սակայն Վանգ Վանգը միայն ունի ա յուան գումար և չի կարող բոլոր ներարկումները միանգամից անել։ Այս պահին բժիշկն ասաց. «Ինչպե՞ս կարող ենք ներարկումը միանգամից ավարտել: Յուրաքանչյուր երկու ներարկումների միջև պետք է լինի մեկ ամսվա ընդմիջում...» Այսպիսով, Վանգ Վանգը որոշեց գումար խնայել՝ միաժամանակ իրեն ներարկումներ անելով (քանի որ Վանգ Վանգը ներարկումներ սիրող միաո է), Վանգ Վանգ Եթե ես կարող եմ խնայել B յուան ամեն ամիս, քանի՞ պատվաստում կարող է Վանգ Վանգը ստանալ ժամանակին:\nՕրինակ:\n>>> calculateMaxVaccinations(10, 200)\n0\n>>> calculateMaxVaccinations(150, 100)\n2\n>>> calculateMaxVaccinations(500, 100)\n4",
      "bn": "Kotlin ফাংশন `fun calculateMaxVaccinations(\n    initialAmount: Int, \n    monthlySavings: Int, \n): Int` লিখুন নিম্নলিখিত সমস্যার সমাধানের জন্য:\nসময় দ্রুত কেটে গেল, এবং ওয়াং ওয়াং টিকাদানের মাসের বয়সে পৌঁছেছিল। ওয়াং ওয়াং হাসপাতালে এসেছিল এবং নিজেকে জলাতঙ্কের টিকা দিতে চেয়েছিল, কিন্তু সে ডাক্তারদের প্রলোভন প্রতিরোধ করতে পারেনি। তার মোট ৪টি ইনজেকশন প্রয়োজন। প্রথমে সে মিয়াও সান্ডুর তিনটি শট নেয়, তারপর জলাতঙ্কের টিকা। একটি মিয়াও সান্ডুর শটের খরচ ১২০ ইউয়ান, এবং একটি জলাতঙ্কের টিকার খরচ ১০০ ইউয়ান। তবে, ওয়াং ওয়াং-এর কাছে মাত্র একটি ইউয়ান টাকা আছে এবং সে একবারে সব শট নিতে পারে না। এই সময়ে, ডাক্তার বললেন: \"কিভাবে আমরা একবারে ইনজেকশন সম্পূর্ণ করতে পারি? প্রতিটি দুটি ইনজেকশনের মধ্যে এক মাসের ব্যবধান থাকা দরকার...\" তাই ওয়াং ওয়াং ইনজেকশন দেওয়ার সময় অর্থ সঞ্চয় করার সিদ্ধান্ত নিল (কারণ ওয়াং ওয়াং একটি মিয়াও যে ইনজেকশন ভালোবাসে), ওয়াং ওয়াং যদি প্রতি মাসে বি ইউয়ান সঞ্চয় করতে পারে, তাহলে ওয়াংওয়াং কতগুলি টিকা সময়মতো পেতে পারে?\nউদাহরণ:\n>>> calculateMaxVaccinations(10, 200)\n0\n>>> calculateMaxVaccinations(150, 100)\n2\n>>> calculateMaxVaccinations(500, 100)\n4",
      "bg": "Напишете функция на Kotlin `fun calculateMaxVaccinations(\n    initialAmount: Int, \n    monthlySavings: Int, \n): Int`, за да решите следния проблем:\nВремето мина бързо и Ванг Ванг достигна възрастта за ваксинация. Ванг Ванг дойде в болницата и искаше да си направи инжекция с ваксина против бяс, но не можа да устои на изкушението на лекаря. Той се нуждае от общо 4 инжекции. Първо получи три инжекции от Мяо Сандуо, а след това ваксината против бяс. Една инжекция от Мяо Сандуо струва 120 юана, а една инжекция от ваксината против бяс струва 100 юана. Въпреки това, Ванг Ванг има само a юана и не може да направи всички инжекции наведнъж. В този момент лекарят каза: \"Как можем да завършим инжекцията наведнъж? Трябва да има месечен интервал между всяка две инжекции...\" Така че Ванг Ванг реши да спестява пари, докато си прави инжекции (защото Ванг Ванг е мяу, който обича инжекции), Ванг Ванг Ако може да спести B юана всеки месец, колко ваксинации може да получи Ванг Ванг навреме?\nПример:\n>>> calculateMaxVaccinations(10, 200)\n0\n>>> calculateMaxVaccinations(150, 100)\n2\n>>> calculateMaxVaccinations(500, 100)\n4",
      "zh": "编写一个 Kotlin 函数 `fun calculateMaxVaccinations(\n    initialAmount: Int, \n    monthlySavings: Int, \n): Int` 来解决以下问题：\n时间过得真快，汪汪到了打疫苗的月龄。汪汪来到医院，想给自己打一针狂犬疫苗，但抵挡不住医生的诱惑。他总共需要打4针。他先打了三针妙三多，然后是狂犬疫苗。一针妙三多需要120元，一针狂犬疫苗需要100元。然而，汪汪只有 A 元钱，不能一次打完所有针。这时医生说：“怎么能一次完成注射呢？每两针之间需要间隔一个月……”于是汪汪决定在给自己打针的同时存钱（因为汪汪是一个爱打针的喵），汪汪如果每个月能存 B 元，汪汪能按时打多少针？\n示例：\n>>> calculateMaxVaccinations(10, 200)\n0\n>>> calculateMaxVaccinations(150, 100)\n2\n>>> calculateMaxVaccinations(500, 100)\n4",
      "fr": "Écrire une fonction Kotlin `fun calculateMaxVaccinations(\n    initialAmount: Int, \n    monthlySavings: Int, \n): Int` pour résoudre le problème suivant :\nLe temps a passé rapidement, et Wang Wang avait atteint l'âge des mois pour la vaccination. Wang Wang est venu à l'hôpital et voulait se faire une injection de vaccin contre la rage, mais il ne pouvait pas résister à la tentation du médecin. Il a besoin d'un total de 4 injections. Il a d'abord reçu trois injections de Miao Sanduo, puis le vaccin contre la rage. Une injection de Miao Sanduo coûte 120 yuans, et une injection de vaccin contre la rage coûte 100 yuans. Cependant, Wang Wang n'a que A yuans d'argent et ne peut pas prendre toutes les injections à la fois. À ce moment, le médecin a dit : \"Comment pouvons-nous compléter l'injection en une seule fois ? Il doit y avoir un intervalle d'un mois entre chaque deux injections...\" Donc Wang Wang a décidé d'économiser de l'argent tout en se faisant des injections (parce que Wang Wang est un meow qui aime les injections), Wang Wang Si je peux économiser B yuans chaque mois, combien de vaccinations Wangwang peut-il obtenir à temps ?\nExemple :\n>>> calculateMaxVaccinations(10, 200)\n0\n>>> calculateMaxVaccinations(150, 100)\n2\n>>> calculateMaxVaccinations(500, 100)\n4",
      "de": "Schreiben Sie eine Kotlin-Funktion `fun calculateMaxVaccinations(\n    initialAmount: Int, \n    monthlySavings: Int, \n): Int`, um das folgende Problem zu lösen:\nDie Zeit verging schnell, und Wang Wang hatte das Alter von Monaten für die Impfung erreicht. Wang Wang kam ins Krankenhaus und wollte sich eine Tollwutimpfung geben lassen, aber er konnte der Versuchung des Arztes nicht widerstehen. Er benötigt insgesamt 4 Injektionen. Zuerst erhielt er drei Spritzen von Miao Sanduo und dann die Tollwutimpfung. Eine Spritze Miao Sanduo kostet 120 Yuan, und eine Spritze Tollwutimpfung kostet 100 Yuan. Wang Wang hat jedoch nur A Yuan Geld und kann nicht alle Spritzen auf einmal nehmen. Zu diesem Zeitpunkt sagte der Arzt: \"Wie können wir die Injektion auf einmal abschließen? Es muss ein Monat Abstand zwischen zwei Injektionen liegen...\" Also entschied sich Wang Wang, Geld zu sparen, während er sich Injektionen gibt (weil Wang Wang ein Miau ist, das Injektionen liebt), Wang Wang Wenn ich jeden Monat B Yuan sparen kann, wie viele Impfungen kann Wangwang rechtzeitig bekommen?\nBeispiel:\n>>> calculateMaxVaccinations(10, 200)\n0\n>>> calculateMaxVaccinations(150, 100)\n2\n>>> calculateMaxVaccinations(500, 100)\n4",
      "ha": "Rubuta aikin Kotlin `fun calculateMaxVaccinations(\n    initialAmount: Int, \n    monthlySavings: Int, \n): Int` don warware matsalar mai zuwa:\nLokaci ya wuce da sauri, kuma Wang Wang ya kai shekarun watanni don yin rigakafi. Wang Wang ya zo asibiti kuma yana so ya ba kansa allurar rigakafin cutar hauka, amma bai iya tsayayya da jarabar likita ba. Yana buƙatar allurai guda 4 gaba ɗaya. Da farko ya karɓi allurai uku na Miao Sanduo, sannan rigakafin cutar hauka. Allura ɗaya ta Miao Sanduo tana kashe yuan 120, kuma allura ɗaya ta rigakafin cutar hauka tana kashe yuan 100. Duk da haka, Wang Wang yana da yuan kaɗan kuma ba zai iya ɗaukar duk alluran a lokaci ɗaya ba. A wannan lokacin, likita ya ce: \"Ta yaya za mu kammala allurar a lokaci ɗaya? Dole ne a sami tazara na wata guda tsakanin kowanne allurai biyu...\" Don haka Wang Wang ya yanke shawarar adana kuɗi yayin da yake ba kansa allurai (saboda Wang Wang meow ne wanda ke son allurai), Wang Wang Idan zan iya adana yuan B a kowane wata, nawa ne alluran rigakafin da Wangwang zai iya samu akan lokaci?\nMisali:\n>>> calculateMaxVaccinations(10, 200)\n0\n>>> calculateMaxVaccinations(150, 100)\n2\n>>> calculateMaxVaccinations(500, 100)\n4",
      "hi": "Kotlin फ़ंक्शन `fun calculateMaxVaccinations(\n    initialAmount: Int, \n    monthlySavings: Int, \n): Int` लिखें ताकि निम्नलिखित समस्या का समाधान किया जा सके:\nसमय जल्दी बीत गया, और वांग वांग टीकाकरण के लिए महीनों की उम्र तक पहुँच गया था। वांग वांग अस्पताल आया और खुद को रेबीज वैक्सीन का एक शॉट देना चाहता था, लेकिन वह डॉक्टर के प्रलोभन का विरोध नहीं कर सका। उसे कुल 4 इंजेक्शन की आवश्यकता है। उसने पहले तीन शॉट मियाओ सैंडुओ के लिए प्राप्त किए, और फिर रेबीज वैक्सीन। मियाओ सैंडुओ का एक शॉट 120 युआन का होता है, और रेबीज वैक्सीन का एक शॉट 100 युआन का होता है। हालांकि, वांग वांग के पास केवल एक युआन का पैसा है और वह सभी शॉट्स एक साथ नहीं ले सकता। इस समय, डॉक्टर ने कहा: \"इंजेक्शन को एक बार में कैसे पूरा किया जा सकता है? हर दो इंजेक्शन के बीच एक महीने का अंतराल होना चाहिए...\" इसलिए वांग वांग ने खुद को इंजेक्शन देते समय पैसे बचाने का फैसला किया (क्योंकि वांग वांग एक ऐसा म्याऊ है जिसे इंजेक्शन पसंद है), वांग वांग अगर मैं हर महीने बी युआन बचा सकता हूँ, तो वांगवांग कितने टीकाकरण समय पर प्राप्त कर सकता है?\nउदाहरण:\n>>> calculateMaxVaccinations(10, 200)\n0\n>>> calculateMaxVaccinations(150, 100)\n2\n>>> calculateMaxVaccinations(500, 100)\n4",
      "hu": "Írj egy Kotlin függvényt `fun calculateMaxVaccinations(\n    initialAmount: Int, \n    monthlySavings: Int, \n): Int` a következő probléma megoldására:\nAz idő gyorsan telt, és Wang Wang elérte a hónapok szerinti oltási kort. Wang Wang elment a kórházba, és szeretett volna magának egy veszettség elleni oltást adni, de nem tudott ellenállni az orvos csábításának. Összesen 4 injekcióra van szüksége. Először három Miao Sanduo injekciót kapott, majd a veszettség elleni oltást. Egy Miao Sanduo injekció 120 jüanba kerül, és egy veszettség elleni oltás 100 jüanba kerül. Azonban Wang Wangnak csak a jüan pénze van, és nem tudja egyszerre megkapni az összes oltást. Ekkor az orvos azt mondta: \"Hogyan lehetne egyszerre befejezni az oltást? Minden két injekció között egy hónapos szünetnek kell lennie...\" Így Wang Wang úgy döntött, hogy pénzt takarít meg, miközben magának adja az injekciókat (mert Wang Wang egy macska, aki szereti az injekciókat), Wang Wang Ha havonta B jüant tud megtakarítani, hány oltást kaphat Wangwang időben?\nPélda:\n>>> calculateMaxVaccinations(10, 200)\n0\n>>> calculateMaxVaccinations(150, 100)\n2\n>>> calculateMaxVaccinations(500, 100)\n4"
    },
    "instruction_bertscore": {
      "sq": "0.9670543704800293",
      "hy": "0.9532527370842011",
      "bn": "0.9357102977223429",
      "bg": "0.9482800254949927",
      "zh": "0.9185093039854837",
      "fr": "0.9594281556305758",
      "de": "0.9553176985254398",
      "ha": "0.9628767763061036",
      "hi": "0.9632909206505613",
      "hu": "0.9411243660182108"
    },
    "level": "hard",
    "test": "fun main(){\n    check(calculateMaxVaccinations(10, 200) == 0)\n    check(calculateMaxVaccinations(150, 100) == 2)\n    check(calculateMaxVaccinations(500, 100) == 4)\n    check(calculateMaxVaccinations(300, 50) == 3)\n    check(calculateMaxVaccinations(0, 200) == 0)\n    check(calculateMaxVaccinations(100, 20) == 0)\n    check(calculateMaxVaccinations(120, 100) == 1)\n    check(calculateMaxVaccinations(400, 0) == 3)\n\n}\nmain()",
    "entry_point": "calculateMaxVaccinations",
    "signature": "fun calculateMaxVaccinations(\n    initialAmount: Int, \n    monthlySavings: Int, \n): Int",
    "docstring": {
      "en": "Time passed quickly, and Wang Wang had reached the age of months for vaccination. Wang Wang came to the hospital and wanted to give himself a shot of rabies vaccine, but he couldn't resist the doctor's temptation. He needs a total of 4 injections. He first received three shots of Miao Sanduo, and then the rabies vaccine. A shot of Miao Sanduo costs 120 yuan, and a shot of rabies vaccine costs 100 yuan. However, Wang Wang only has a yuan of money and cannot take all the shots at once. At this time, the doctor said: \"How can we complete the injection at one time? There needs to be a month's interval between every two injections...\" So Wang Wang decided to save money while giving himself injections (because Wang Wang is a meow who loves injections), Wang Wang If I can save B yuan every month, how many vaccinations can Wangwang get on time?\nExample:\n>>> calculateMaxVaccinations(10, 200)\n0\n>>> calculateMaxVaccinations(150, 100)\n2\n>>> calculateMaxVaccinations(500, 100)\n4",
      "sq": "Koha kaloi shpejt dhe Wang Wang kishte arritur moshën e muajve për vaksinim. Wang Wang shkoi në spital dhe donte t'i jepte vetes një injeksion të vaksinës kundër tërbimit, por nuk mundi t'i rezistonte tundimit të mjekut. Ai ka nevojë për gjithsej 4 injeksione. Ai fillimisht mori tre injeksione të Miao Sanduo, dhe pastaj vaksinën kundër tërbimit. Një injeksion i Miao Sanduo kushton 120 juan, dhe një injeksion i vaksinës kundër tërbimit kushton 100 juan. Megjithatë, Wang Wang ka vetëm një juan para dhe nuk mund t'i marrë të gjitha injeksionet menjëherë. Në këtë kohë, mjeku tha: \"Si mund ta përfundojmë injeksionin në një kohë? Duhet të ketë një interval prej një muaji midis çdo dy injeksioneve...\" Kështu që Wang Wang vendosi të kursejë para ndërsa i bën vetes injeksione (sepse Wang Wang është një meow që i pëlqen injeksionet), Wang Wang Nëse mund të kursej B juan çdo muaj, sa vaksina mund të marrë Wangwang në kohë?\nShembull:\n>>> calculateMaxVaccinations(10, 200)\n0\n>>> calculateMaxVaccinations(150, 100)\n2\n>>> calculateMaxVaccinations(500, 100)\n4",
      "hy": "Ժամանակը արագ անցավ, և Վանգ Վանգը հասել էր պատվաստման ամիսների տարիքին: Վանգ Վանգը եկավ հիվանդանոց և ցանկանում էր իրեն կատաղության դեմ պատվաստել, բայց նա չկարողացավ դիմակայել բժշկի գայթակղությանը: Նա ընդհանուր առմամբ պետք է ստանա 4 ներարկում: Սկզբում նա ստացավ երեք ներարկում Միաո Սանդուո, ապա կատաղության դեմ պատվաստանյութը: Միաո Սանդուոյի մեկ ներարկումը արժե 120 յուան, իսկ կատաղության դեմ պատվաստանյութի մեկ ներարկումը՝ 100 յուան: Սակայն Վանգ Վանգը միայն ունի յուան գումար և չի կարող բոլոր ներարկումները միանգամից ստանալ: Այդ պահին բժիշկն ասաց. «Ինչպե՞ս կարող ենք միանգամից ավարտել ներարկումը: Յուրաքանչյուր երկու ներարկումների միջև պետք է լինի մեկ ամսվա ընդմիջում...» Այսպիսով, Վանգ Վանգը որոշեց գումար խնայել, մինչ ինքն իրեն ներարկումներ էր անում (քանի որ Վանգ Վանգը մի մեաո է, ով սիրում է ներարկումներ), Վանգ Վանգ Եթե ես կարող եմ ամեն ամիս խնայել B յուան, քանի՞ պատվաստում կարող է Վանգվանգը ժամանակին ստանալ:\nՕրինակ:\n>>> calculateMaxVaccinations(10, 200)\n0\n>>> calculateMaxVaccinations(150, 100)\n2\n>>> calculateMaxVaccinations(500, 100)\n4",
      "bn": "সময় দ্রুত কেটে গেল, এবং ওয়াং ওয়াং টিকাদানের জন্য মাসের বয়সে পৌঁছেছিল। ওয়াং ওয়াং হাসপাতালে এসে নিজেকে জলাতঙ্কের টিকা দিতে চেয়েছিল, কিন্তু সে ডাক্তারদের প্রলোভন প্রতিরোধ করতে পারেনি। তার মোট ৪টি ইনজেকশন প্রয়োজন। প্রথমে সে তিনটি মিয়াও সানডু ইনজেকশন নেয়, তারপর জলাতঙ্কের টিকা। একটি মিয়াও সানডু ইনজেকশনের খরচ ১২০ ইউয়ান, এবং একটি জলাতঙ্কের টিকার খরচ ১০০ ইউয়ান। তবে, ওয়াং ওয়াং-এর কাছে কেবল একটি ইউয়ান টাকা আছে এবং সে একবারে সব ইনজেকশন নিতে পারে না। এই সময়, ডাক্তার বললেন: \"কীভাবে আমরা একবারে ইনজেকশন সম্পন্ন করতে পারি? প্রতিটি দুটি ইনজেকশনের মধ্যে এক মাসের ব্যবধান থাকতে হবে...\" তাই ওয়াং ওয়াং ইনজেকশন দেওয়ার সময় টাকা সঞ্চয় করার সিদ্ধান্ত নিল (কারণ ওয়াং ওয়াং একটি মিয়াও যে ইনজেকশন ভালোবাসে), ওয়াং ওয়াং যদি প্রতি মাসে বি ইউয়ান সঞ্চয় করতে পারে, তাহলে ওয়াংওয়াং কতগুলো টিকা সময়মতো পেতে পারে?\nউদাহরণ:\n>>> calculateMaxVaccinations(10, 200)\n0\n>>> calculateMaxVaccinations(150, 100)\n2\n>>> calculateMaxVaccinations(500, 100)\n4",
      "bg": "Времето мина бързо и Ванг Ванг достигна възрастта за ваксинация. Ванг Ванг отиде в болницата и искаше да си направи инжекция с ваксина против бяс, но не можа да устои на изкушението на лекаря. Той се нуждае от общо 4 инжекции. Първо получи три инжекции от Мяо Сандуо, а след това ваксината против бяс. Една инжекция от Мяо Сандуо струва 120 юана, а една инжекция с ваксина против бяс струва 100 юана. Въпреки това, Ванг Ванг има само определена сума пари и не може да си направи всички инжекции наведнъж. В този момент лекарят каза: \"Как можем да завършим инжекциите наведнъж? Трябва да има месечен интервал между всяка две инжекции...\" Така че Ванг Ванг реши да спестява пари, докато си прави инжекции (защото Ванг Ванг е коте, което обича инжекции), ако Ванг Ванг може да спести B юана всеки месец, колко ваксинации може да получи Ванг Ванг навреме?\nПример:\n>>> calculateMaxVaccinations(10, 200)\n0\n>>> calculateMaxVaccinations(150, 100)\n2\n>>> calculateMaxVaccinations(500, 100)\n4",
      "zh": "时间过得很快，汪汪已经到了接种疫苗的月份。汪汪来到医院，想给自己打一针狂犬疫苗，但他无法抵挡医生的诱惑。他总共需要打4针。他先接种了三针妙三多，然后是狂犬疫苗。一针妙三多的费用是120元，一针狂犬疫苗的费用是100元。然而，汪汪只有a元钱，无法一次性打完所有针。这时，医生说：“怎么能一次完成注射呢？每两次注射之间需要间隔一个月……”于是汪汪决定在给自己打针的同时存钱（因为汪汪是一个爱打针的喵），如果汪汪每个月能存B元，那么汪汪能按时打多少针？\n例子：\n>>> calculateMaxVaccinations(10, 200)\n0\n>>> calculateMaxVaccinations(150, 100)\n2\n>>> calculateMaxVaccinations(500, 100)\n4",
      "fr": "Le temps a passé rapidement, et Wang Wang avait atteint l'âge de mois pour la vaccination. Wang Wang est venu à l'hôpital et voulait se faire une injection de vaccin contre la rage, mais il n'a pas pu résister à la tentation du médecin. Il a besoin d'un total de 4 injections. Il a d'abord reçu trois injections de Miao Sanduo, puis le vaccin contre la rage. Une injection de Miao Sanduo coûte 120 yuans, et une injection de vaccin contre la rage coûte 100 yuans. Cependant, Wang Wang n'a qu'un yuan d'argent et ne peut pas prendre toutes les injections en une seule fois. À ce moment-là, le médecin a dit : \"Comment pouvons-nous compléter l'injection en une seule fois ? Il doit y avoir un intervalle d'un mois entre chaque deux injections...\" Donc Wang Wang a décidé d'économiser de l'argent tout en se faisant des injections (parce que Wang Wang est un meow qui aime les injections), Wang Wang Si je peux économiser B yuans chaque mois, combien de vaccinations Wangwang peut-il obtenir à temps ?\nExemple :\n>>> calculateMaxVaccinations(10, 200)\n0\n>>> calculateMaxVaccinations(150, 100)\n2\n>>> calculateMaxVaccinations(500, 100)\n4",
      "de": "Die Zeit verging schnell, und Wang Wang hatte das Alter für Impfungen erreicht. Wang Wang kam ins Krankenhaus und wollte sich eine Tollwutimpfung geben lassen, konnte jedoch der Versuchung des Arztes nicht widerstehen. Er benötigt insgesamt 4 Injektionen. Zuerst erhielt er drei Spritzen von Miao Sanduo und dann die Tollwutimpfung. Eine Spritze Miao Sanduo kostet 120 Yuan, und eine Tollwutimpfung kostet 100 Yuan. Wang Wang hat jedoch nur einen Yuan Geld und kann nicht alle Spritzen auf einmal nehmen. Zu diesem Zeitpunkt sagte der Arzt: \"Wie können wir die Injektion auf einmal abschließen? Es muss ein Monat Abstand zwischen zwei Injektionen liegen...\" Also entschied sich Wang Wang, Geld zu sparen, während er sich Injektionen gibt (weil Wang Wang ein Meow ist, der Injektionen liebt). Wenn Wang Wang jeden Monat B Yuan sparen kann, wie viele Impfungen kann Wang Wang rechtzeitig erhalten?\nBeispiel:\n>>> calculateMaxVaccinations(10, 200)\n0\n>>> calculateMaxVaccinations(150, 100)\n2\n>>> calculateMaxVaccinations(500, 100)\n4",
      "ha": "Lokaci ya wuce da sauri, kuma Wang Wang ya kai shekarun watanni don yin rigakafi. Wang Wang ya zo asibiti kuma yana son yi wa kansa allurar rigakafin cutar hauka, amma bai iya jure wa jarabar likita ba. Yana buƙatar allurai guda 4 gaba ɗaya. Da farko ya karɓi allurai uku na Miao Sanduo, sannan rigakafin cutar hauka. Allura ɗaya ta Miao Sanduo tana kashe yuan 120, kuma allura ɗaya ta rigakafin cutar hauka tana kashe yuan 100. Duk da haka, Wang Wang yana da yuan kaɗai na kuɗi kuma ba zai iya ɗaukar duk alluran a lokaci ɗaya ba. A wannan lokacin, likita ya ce: \"Ta yaya za mu kammala allurar a lokaci ɗaya? Dole ne a sami tazarar wata guda tsakanin kowane allurai biyu...\" Don haka Wang Wang ya yanke shawarar adana kuɗi yayin da yake yi wa kansa allurai (saboda Wang Wang meow ne wanda ke son allurai), Wang Wang Idan zan iya adana yuan B kowane wata, nawa daga cikin alluran rigakafin Wangwang zai iya samu akan lokaci?\n\nMisali:\n>>> calculateMaxVaccinations(10, 200)\n0\n>>> calculateMaxVaccinations(150, 100)\n2\n>>> calculateMaxVaccinations(500, 100)\n4",
      "hi": "समय तेजी से बीता, और वांग वांग टीकाकरण के महीनों की उम्र तक पहुँच गया था। वांग वांग अस्पताल आया और खुद को रेबीज वैक्सीन का एक शॉट देना चाहता था, लेकिन वह डॉक्टर के प्रलोभन का विरोध नहीं कर सका। उसे कुल 4 इंजेक्शन की आवश्यकता है। उसने पहले मियाओ सांडुओ के तीन शॉट्स प्राप्त किए, और फिर रेबीज वैक्सीन। मियाओ सांडुओ के एक शॉट की कीमत 120 युआन है, और रेबीज वैक्सीन के एक शॉट की कीमत 100 युआन है। हालाँकि, वांग वांग के पास केवल एक युआन का पैसा है और वह एक बार में सभी शॉट्स नहीं ले सकता। इस समय, डॉक्टर ने कहा: \"हम एक बार में इंजेक्शन कैसे पूरा कर सकते हैं? हर दो इंजेक्शन के बीच एक महीने का अंतराल होना चाहिए...\" इसलिए वांग वांग ने इंजेक्शन लगाते समय पैसे बचाने का फैसला किया (क्योंकि वांग वांग एक म्याऊ है जो इंजेक्शन पसंद करता है), वांग वांग अगर मैं हर महीने बी युआन बचा सकता हूँ, तो वांगवांग कितने टीकाकरण समय पर प्राप्त कर सकता है?\nउदाहरण:\n>>> calculateMaxVaccinations(10, 200)\n0\n>>> calculateMaxVaccinations(150, 100)\n2\n>>> calculateMaxVaccinations(500, 100)\n4",
      "hu": "Az idő gyorsan telt, és Wang Wang elérte a hónapos oltási kort. Wang Wang elment a kórházba, és szeretett volna magának egy veszettség elleni oltást adni, de nem tudott ellenállni az orvos csábításának. Összesen 4 injekcióra van szüksége. Először három Miao Sanduo injekciót kapott, majd a veszettség elleni oltást. Egy Miao Sanduo injekció 120 jüanba kerül, és egy veszettség elleni oltás 100 jüanba kerül. Azonban Wang Wangnak csak egy jüanja van, és nem tudja egyszerre megkapni az összes oltást. Ekkor az orvos azt mondta: \"Hogyan lehetne egyszerre befejezni az oltást? Minden két injekció között egy hónap szünetnek kell lennie...\" Így Wang Wang úgy döntött, hogy pénzt takarít meg, miközben magának adja az injekciókat (mert Wang Wang egy meow, aki szereti az injekciókat), Wang Wang Ha havonta B jüant tud megtakarítani, hány oltást kaphat Wangwang időben?\nPélda:\n>>> calculateMaxVaccinations(10, 200)\n0\n>>> calculateMaxVaccinations(150, 100)\n2\n>>> calculateMaxVaccinations(500, 100)\n4"
    },
    "docstring_bertscore": {
      "sq": "0.9697732231356349",
      "hy": "0.951190953729059",
      "bn": "0.9271185405906788",
      "bg": "0.9287540631481201",
      "zh": "0.9194577640549253",
      "fr": "0.9573147283763646",
      "de": "0.9358078252394311",
      "ha": "0.9525674622696307",
      "hi": "0.9602810744867396",
      "hu": "0.9301985032790058"
    }
  },
  {
    "task_id": "Kotlin/20",
    "prompt": {
      "en": "/**\n * Perform basic arithmetic operations (addition, subtraction, multiplication, division, and modulus)\n * on two integers based on a specified operation character. Illegal calculation returns \"invalid calcu\"\n * \n * Example:\n * >>> simpleCalculator(5, 3, '+')\n *     8\n * >>> simpleCalculator(5, 3, '-')\n *     2\n * >>> simpleCalculator(5, 3, '*')\n *     15\n * >>> simpleCalculator(5, 3, '/')\n *     1\n * >>> simpleCalculator(5, 3, '%')\n *     2\n **/\nfun simpleCalculator(a: Int, b: Int, operation: Char): Any ",
      "sq": "/**\n * Kryen operacione aritmetike bazë (mbledhje, zbritje, shumëzim, pjesëtim dhe modul)\n * mbi dy numra të plotë bazuar në një karakter operacioni të specifikuar. Llogaritja e paligjshme kthen \"invalid calcu\"\n * \n * Shembull:\n * >>> simpleCalculator(5, 3, '+')\n *     8\n * >>> simpleCalculator(5, 3, '-')\n *     2\n * >>> simpleCalculator(5, 3, '*')\n *     15\n * >>> simpleCalculator(5, 3, '/')\n *     1\n * >>> simpleCalculator(5, 3, '%')\n *     2\n **/",
      "hy": "/**\n * Կատարել հիմնական թվաբանական գործողություններ (գումարում, հանում, բազմապատկում, բաժանում և մնացորդ)\n * երկու ամբողջ թվերի վրա՝ հիմնված նշված գործողության սիմվոլի վրա: Անօրինական հաշվարկը վերադարձնում է \"invalid calcu\"\n * \n * Օրինակ:\n * >>> simpleCalculator(5, 3, '+')\n *     8\n * >>> simpleCalculator(5, 3, '-')\n *     2\n * >>> simpleCalculator(5, 3, '*')\n *     15\n * >>> simpleCalculator(5, 3, '/')\n *     1\n * >>> simpleCalculator(5, 3, '%')\n *     2\n **/",
      "bn": "/**\n * দুটি পূর্ণসংখ্যার উপর নির্দিষ্ট অপারেশন চরিত্রের ভিত্তিতে মৌলিক গাণিতিক ক্রিয়াকলাপ (যোগ, বিয়োগ, গুণ, ভাগ, এবং মডুলাস) সম্পাদন করুন। অবৈধ গণনা \"invalid calcu\" ফেরত দেয়\n * \n * উদাহরণ:\n * >>> simpleCalculator(5, 3, '+')\n *     8\n * >>> simpleCalculator(5, 3, '-')\n *     2\n * >>> simpleCalculator(5, 3, '*')\n *     15\n * >>> simpleCalculator(5, 3, '/')\n *     1\n * >>> simpleCalculator(5, 3, '%')\n *     2\n **/",
      "bg": "/**\n * Извършва основни аритметични операции (събиране, изваждане, умножение, деление и модул)\n * върху две цели числа въз основа на зададен символ за операция. Невалидно изчисление връща \"invalid calcu\"\n * \n * Пример:\n * >>> simpleCalculator(5, 3, '+')\n *     8\n * >>> simpleCalculator(5, 3, '-')\n *     2\n * >>> simpleCalculator(5, 3, '*')\n *     15\n * >>> simpleCalculator(5, 3, '/')\n *     1\n * >>> simpleCalculator(5, 3, '%')\n *     2\n **/",
      "zh": "/**\n * 对两个整数执行基本算术运算（加法、减法、乘法、除法和取模）\n * 根据指定的运算字符。非法计算返回 \"invalid calcu\"\n * \n * 示例:\n * >>> simpleCalculator(5, 3, '+')\n *     8\n * >>> simpleCalculator(5, 3, '-')\n *     2\n * >>> simpleCalculator(5, 3, '*')\n *     15\n * >>> simpleCalculator(5, 3, '/')\n *     1\n * >>> simpleCalculator(5, 3, '%')\n *     2\n **/",
      "fr": "/**\n * Effectuer des opérations arithmétiques de base (addition, soustraction, multiplication, division et modulo)\n * sur deux entiers en fonction d'un caractère d'opération spécifié. Un calcul illégal renvoie \"invalid calcu\"\n * \n * Exemple:\n * >>> simpleCalculator(5, 3, '+')\n *     8\n * >>> simpleCalculator(5, 3, '-')\n *     2\n * >>> simpleCalculator(5, 3, '*')\n *     15\n * >>> simpleCalculator(5, 3, '/')\n *     1\n * >>> simpleCalculator(5, 3, '%')\n *     2\n **/",
      "de": "/**\n * Führe grundlegende arithmetische Operationen (Addition, Subtraktion, Multiplikation, Division und Modulus)\n * auf zwei ganzen Zahlen basierend auf einem angegebenen Operationszeichen durch. Ungültige Berechnung gibt \"invalid calcu\" zurück\n * \n * Beispiel:\n * >>> simpleCalculator(5, 3, '+')\n *     8\n * >>> simpleCalculator(5, 3, '-')\n *     2\n * >>> simpleCalculator(5, 3, '*')\n *     15\n * >>> simpleCalculator(5, 3, '/')\n *     1\n * >>> simpleCalculator(5, 3, '%')\n *     2\n **/",
      "ha": "/**\n * Yi ayyukan lissafi na asali (ƙara, cirewa, ninka, rabawa, da modulus)\n * akan lambobi biyu bisa ga alamar aiki da aka ƙayyade. Lissafi mara kyau yana dawo da \"invalid calcu\"\n * \n * Misali:\n * >>> simpleCalculator(5, 3, '+')\n *     8\n * >>> simpleCalculator(5, 3, '-')\n *     2\n * >>> simpleCalculator(5, 3, '*')\n *     15\n * >>> simpleCalculator(5, 3, '/')\n *     1\n * >>> simpleCalculator(5, 3, '%')\n *     2\n **/ \nfun simpleCalculator(a: Int, b: Int, operation: Char): Any ",
      "hi": "/**\n * दो पूर्णांकों पर एक निर्दिष्ट ऑपरेशन कैरेक्टर के आधार पर बुनियादी अंकगणितीय संचालन (जोड़, घटाव, गुणा, भाग, और मापांक)\n * करें। अवैध गणना \"invalid calcu\" लौटाती है\n * \n * उदाहरण:\n * >>> simpleCalculator(5, 3, '+')\n *     8\n * >>> simpleCalculator(5, 3, '-')\n *     2\n * >>> simpleCalculator(5, 3, '*')\n *     15\n * >>> simpleCalculator(5, 3, '/')\n *     1\n * >>> simpleCalculator(5, 3, '%')\n *     2\n **/",
      "hu": "/**\n * Végezzen alapvető aritmetikai műveleteket (összeadás, kivonás, szorzás, osztás és modulus)\n * két egész számon egy megadott műveleti karakter alapján. Illegális számítás esetén \"invalid calcu\" értéket ad vissza\n * \n * Példa:\n * >>> simpleCalculator(5, 3, '+')\n *     8\n * >>> simpleCalculator(5, 3, '-')\n *     2\n * >>> simpleCalculator(5, 3, '*')\n *     15\n * >>> simpleCalculator(5, 3, '/')\n *     1\n * >>> simpleCalculator(5, 3, '%')\n *     2\n **/"
    },
    "prompt_bertscore": {
      "sq": "0.9434245058305949",
      "hy": "0.9374024299383791",
      "bn": "0.9335990554023231",
      "bg": "0.9355329207920787",
      "zh": "0.9459264541101103",
      "fr": "0.9452612409640245",
      "de": "0.944079588827248",
      "ha": "0.9867823399244144",
      "hi": "0.931770662744897",
      "hu": "0.9378100194802628"
    },
    "canonical_solution": "{\n    return when (operation) {\n        '+' -> a + b\n        '-' -> a - b\n        '*' -> a * b\n        '/' -> if (b != 0) a / b else \"invalid calc\"\n        '%' -> if (b != 0) a % b else \"invalid calc\"\n        else -> \"invalid calc\"\n    }\n}",
    "instruction": {
      "en": "Write a Kotlin function `fun simpleCalculator(a: Int, b: Int, operation: Char): Any` to solve the following problem:\nPerform basic arithmetic operations (addition, subtraction, multiplication, division, and modulus)\non two integers based on a specified operation character. Illegal calculation returns \"invalid calcu\"\n\nExample:\n>>> simpleCalculator(5, 3, '+')\n8\n>>> simpleCalculator(5, 3, '-')\n2\n>>> simpleCalculator(5, 3, '*')\n15\n>>> simpleCalculator(5, 3, '/')\n1\n>>> simpleCalculator(5, 3, '%')\n2",
      "sq": "Shkruani një funksion Kotlin `fun simpleCalculator(a: Int, b: Int, operation: Char): Any` për të zgjidhur problemin e mëposhtëm:\nKryeni operacione aritmetike bazë (mbledhje, zbritje, shumëzim, pjesëtim dhe modul)\nmbi dy numra të plotë bazuar në një karakter të specifikuar të operacionit. Llogaritja e paligjshme kthen \"invalid calcu\"\n\nShembull:\n>>> simpleCalculator(5, 3, '+')\n8\n>>> simpleCalculator(5, 3, '-')\n2\n>>> simpleCalculator(5, 3, '*')\n15\n>>> simpleCalculator(5, 3, '/')\n1\n>>> simpleCalculator(5, 3, '%')\n2",
      "hy": "Գրեք Kotlin ֆունկցիա `fun simpleCalculator(a: Int, b: Int, operation: Char): Any` հետևյալ խնդիրը լուծելու համար:\nԿատարել հիմնական թվաբանական գործողություններ (գումարում, հանում, բազմապատկում, բաժանում և մնացորդ)\nերկու ամբողջ թվերի վրա՝ հիմնվելով նշված գործողության սիմվոլի վրա։ Անօրինական հաշվարկը վերադարձնում է \"invalid calcu\"\n\nՕրինակ:\n>>> simpleCalculator(5, 3, '+')\n8\n>>> simpleCalculator(5, 3, '-')\n2\n>>> simpleCalculator(5, 3, '*')\n15\n>>> simpleCalculator(5, 3, '/')\n1\n>>> simpleCalculator(5, 3, '%')\n2",
      "bn": "Kotlin ফাংশন `fun simpleCalculator(a: Int, b: Int, operation: Char): Any` লিখুন নিম্নলিখিত সমস্যার সমাধানের জন্য:\nদুটি পূর্ণসংখ্যার উপর নির্দিষ্ট অপারেশন চরিত্রের ভিত্তিতে মৌলিক গাণিতিক ক্রিয়াকলাপ (যোগ, বিয়োগ, গুণ, ভাগ, এবং মডুলাস) সম্পাদন করুন। অবৈধ গণনা \"invalid calcu\" ফেরত দেয়\n\nউদাহরণ:\n>>> simpleCalculator(5, 3, '+')\n8\n>>> simpleCalculator(5, 3, '-')\n2\n>>> simpleCalculator(5, 3, '*')\n15\n>>> simpleCalculator(5, 3, '/')\n1\n>>> simpleCalculator(5, 3, '%')\n2",
      "bg": "Напишете функция на Kotlin `fun simpleCalculator(a: Int, b: Int, operation: Char): Any`, за да решите следния проблем:  \nИзвършете основни аритметични операции (събиране, изваждане, умножение, деление и модул) върху две цели числа въз основа на зададен символ за операция. Невалидно изчисление връща \"invalid calcu\"  \n\nПример:  \n>>> simpleCalculator(5, 3, '+')  \n8  \n>>> simpleCalculator(5, 3, '-')  \n2  \n>>> simpleCalculator(5, 3, '*')  \n15  \n>>> simpleCalculator(5, 3, '/')  \n1  \n>>> simpleCalculator(5, 3, '%')  \n2",
      "zh": "编写一个 Kotlin 函数 `fun simpleCalculator(a: Int, b: Int, operation: Char): Any` 来解决以下问题：\n根据指定的操作字符，对两个整数执行基本的算术运算（加法、减法、乘法、除法和取模）。非法计算返回 \"invalid calcu\"\n\n示例:\n>>> simpleCalculator(5, 3, '+')\n8\n>>> simpleCalculator(5, 3, '-')\n2\n>>> simpleCalculator(5, 3, '*')\n15\n>>> simpleCalculator(5, 3, '/')\n1\n>>> simpleCalculator(5, 3, '%')\n2",
      "fr": "Écrire une fonction Kotlin `fun simpleCalculator(a: Int, b: Int, operation: Char): Any` pour résoudre le problème suivant :\nEffectuer des opérations arithmétiques de base (addition, soustraction, multiplication, division et modulo) sur deux entiers en fonction d'un caractère d'opération spécifié. Un calcul illégal renvoie \"invalid calcu\"\n\nExemple :\n>>> simpleCalculator(5, 3, '+')\n8\n>>> simpleCalculator(5, 3, '-')\n2\n>>> simpleCalculator(5, 3, '*')\n15\n>>> simpleCalculator(5, 3, '/')\n1\n>>> simpleCalculator(5, 3, '%')\n2",
      "de": "Schreiben Sie eine Kotlin-Funktion `fun simpleCalculator(a: Int, b: Int, operation: Char): Any`, um das folgende Problem zu lösen:\nFühren Sie grundlegende arithmetische Operationen (Addition, Subtraktion, Multiplikation, Division und Modulus) auf zwei ganzen Zahlen basierend auf einem angegebenen Operationszeichen durch. Ungültige Berechnung gibt \"invalid calcu\" zurück.\n\nBeispiel:\n>>> simpleCalculator(5, 3, '+')\n8\n>>> simpleCalculator(5, 3, '-')\n2\n>>> simpleCalculator(5, 3, '*')\n15\n>>> simpleCalculator(5, 3, '/')\n1\n>>> simpleCalculator(5, 3, '%')\n2",
      "ha": "Rubuta wani aikin Kotlin `fun simpleCalculator(a: Int, b: Int, operation: Char): Any` don warware matsalar mai zuwa:\nYi ayyukan lissafi na asali (haɗawa, cirewa, ninkawa, rabawa, da modulus)\nakan lambobi guda biyu bisa ga alamar aiki da aka fayyace. Lissafi mara kyau yana dawowa \"invalid calcu\"\n\nMisali:\n>>> simpleCalculator(5, 3, '+')\n8\n>>> simpleCalculator(5, 3, '-')\n2\n>>> simpleCalculator(5, 3, '*')\n15\n>>> simpleCalculator(5, 3, '/')\n1\n>>> simpleCalculator(5, 3, '%')\n2",
      "hi": "Kotlin फ़ंक्शन `fun simpleCalculator(a: Int, b: Int, operation: Char): Any` लिखें ताकि निम्नलिखित समस्या का समाधान किया जा सके:\nदो पूर्णांकों पर एक निर्दिष्ट ऑपरेशन कैरेक्टर के आधार पर बुनियादी अंकगणितीय संचालन (जोड़, घटाव, गुणा, भाग, और मापांक) करें। अवैध गणना \"invalid calcu\" लौटाती है\n\nउदाहरण:\n>>> simpleCalculator(5, 3, '+')\n8\n>>> simpleCalculator(5, 3, '-')\n2\n>>> simpleCalculator(5, 3, '*')\n15\n>>> simpleCalculator(5, 3, '/')\n1\n>>> simpleCalculator(5, 3, '%')\n2",
      "hu": "Írj egy Kotlin függvényt `fun simpleCalculator(a: Int, b: Int, operation: Char): Any` a következő probléma megoldására:\nVégezzen el alapvető aritmetikai műveleteket (összeadás, kivonás, szorzás, osztás és modulus) két egész számon egy megadott műveleti karakter alapján. Érvénytelen számítás esetén \"invalid calcu\" értéket ad vissza. \n\nPélda:\n>>> simpleCalculator(5, 3, '+')\n8\n>>> simpleCalculator(5, 3, '-')\n2\n>>> simpleCalculator(5, 3, '*')\n15\n>>> simpleCalculator(5, 3, '/')\n1\n>>> simpleCalculator(5, 3, '%')\n2"
    },
    "instruction_bertscore": {
      "sq": "1",
      "hy": "0.9843703712075077",
      "bn": "0.9697277367783779",
      "bg": "0.9816832994128678",
      "zh": "0.9834574659762714",
      "fr": "0.992666566332192",
      "de": "0.9901250906068505",
      "ha": "0.9826122937049679",
      "hi": "0.975375990293486",
      "hu": "0.9767586563758698"
    },
    "level": "easy",
    "test": "fun main(){\n    check(simpleCalculator(10, 5, '+') == 15)\n    check(simpleCalculator(10, 5, '-') == 5)\n    check(simpleCalculator(10, 5, '*') == 50)\n    check(simpleCalculator(10, 5, '/') == 2)\n    check(simpleCalculator(10, 5, '%') == 0)\n    check(simpleCalculator(15, 4, '/') == 3)\n    check(simpleCalculator(15, 4, '%') == 3)\n    check(simpleCalculator(15, 0, '/') == \"invalid calc\")\n    check(simpleCalculator(15, 0, '%') == \"invalid calc\")\n\n}\nmain()",
    "entry_point": "simpleCalculator",
    "signature": "fun simpleCalculator(a: Int, b: Int, operation: Char): Any",
    "docstring": {
      "en": "Perform basic arithmetic operations (addition, subtraction, multiplication, division, and modulus)\non two integers based on a specified operation character. Illegal calculation returns \"invalid calcu\"\n\nExample:\n>>> simpleCalculator(5, 3, '+')\n8\n>>> simpleCalculator(5, 3, '-')\n2\n>>> simpleCalculator(5, 3, '*')\n15\n>>> simpleCalculator(5, 3, '/')\n1\n>>> simpleCalculator(5, 3, '%')\n2",
      "sq": "Kryeni operacione aritmetike bazë (mbledhje, zbritje, shumëzim, pjesëtim dhe modulus)\nmbi dy numra të plotë bazuar në një karakter të specifikuar operacioni. Llogaritja e paligjshme kthen \"invalid calcu\"\n\nShembull:\n>>> simpleCalculator(5, 3, '+')\n8\n>>> simpleCalculator(5, 3, '-')\n2\n>>> simpleCalculator(5, 3, '*')\n15\n>>> simpleCalculator(5, 3, '/')\n1\n>>> simpleCalculator(5, 3, '%')\n2",
      "hy": "Կատարել հիմնական թվաբանական գործողություններ (գումարում, հանում, բազմապատկում, բաժանում և մնացորդ)\nերկու ամբողջ թվերի վրա՝ հիմնվելով նշված գործողության սիմվոլի վրա։ Անօրինական հաշվարկը վերադարձնում է \"invalid calcu\"\n\nՕրինակ:\n>>> simpleCalculator(5, 3, '+')\n8\n>>> simpleCalculator(5, 3, '-')\n2\n>>> simpleCalculator(5, 3, '*')\n15\n>>> simpleCalculator(5, 3, '/')\n1\n>>> simpleCalculator(5, 3, '%')\n2",
      "bn": "দুটি পূর্ণসংখ্যার উপর নির্ধারিত অপারেশন চরিত্রের ভিত্তিতে মৌলিক গাণিতিক অপারেশন (যোগ, বিয়োগ, গুণ, ভাগ, এবং মডুলাস) সম্পাদন করুন। অবৈধ গণনা \"invalid calcu\" ফেরত দেয়।\n\nউদাহরণ:\n>>> simpleCalculator(5, 3, '+')\n8\n>>> simpleCalculator(5, 3, '-')\n2\n>>> simpleCalculator(5, 3, '*')\n15\n>>> simpleCalculator(5, 3, '/')\n1\n>>> simpleCalculator(5, 3, '%')\n2",
      "bg": "Извършване на основни аритметични операции (събиране, изваждане, умножение, деление и модул)\nвърху две цели числа въз основа на зададен символ за операция. Невалидно изчисление връща \"invalid calcu\"\n\nПример:\n>>> simpleCalculator(5, 3, '+')\n8\n>>> simpleCalculator(5, 3, '-')\n2\n>>> simpleCalculator(5, 3, '*')\n15\n>>> simpleCalculator(5, 3, '/')\n1\n>>> simpleCalculator(5, 3, '%')\n2",
      "zh": "执行基本的算术运算（加法、减法、乘法、除法和取模）在两个整数上，基于指定的运算符字符。不合法的计算返回“invalid calcu”\n\n示例：\n>>> simpleCalculator(5, 3, '+')\n8\n>>> simpleCalculator(5, 3, '-')\n2\n>>> simpleCalculator(5, 3, '*')\n15\n>>> simpleCalculator(5, 3, '/')\n1\n>>> simpleCalculator(5, 3, '%')\n2",
      "fr": "Effectuer des opérations arithmétiques de base (addition, soustraction, multiplication, division et modulo) sur deux entiers en fonction d'un caractère d'opération spécifié. Un calcul illégal retourne \"invalid calcu\"\n\nExemple :\n>>> simpleCalculator(5, 3, '+')\n8\n>>> simpleCalculator(5, 3, '-')\n2\n>>> simpleCalculator(5, 3, '*')\n15\n>>> simpleCalculator(5, 3, '/')\n1\n>>> simpleCalculator(5, 3, '%')\n2",
      "de": "Führen Sie grundlegende arithmetische Operationen (Addition, Subtraktion, Multiplikation, Division und Modulus) auf zwei ganzen Zahlen basierend auf einem angegebenen Operationszeichen durch. Ungültige Berechnung gibt \"invalid calcu\" zurück.\n\nBeispiel:\n>>> simpleCalculator(5, 3, '+')\n8\n>>> simpleCalculator(5, 3, '-')\n2\n>>> simpleCalculator(5, 3, '*')\n15\n>>> simpleCalculator(5, 3, '/')\n1\n>>> simpleCalculator(5, 3, '%')\n2",
      "ha": "Ai aikace-aikacen lissafi na asali (ƙara, cirewa, ninka, raba, da kuma modulus) akan lambobi guda biyu bisa ga alamar aikin da aka ƙayyade. Lissafin da ba bisa ka'ida ba yana dawowa da \"invalid calcu\"\n\nMisali:\n>>> simpleCalculator(5, 3, '+')\n8\n>>> simpleCalculator(5, 3, '-')\n2\n>>> simpleCalculator(5, 3, '*')\n15\n>>> simpleCalculator(5, 3, '/')\n1\n>>> simpleCalculator(5, 3, '%')\n2",
      "hi": "दो पूर्णांकों पर निर्दिष्ट ऑपरेशन कैरेक्टर के आधार पर बुनियादी अंकगणितीय संचालन (जोड़, घटाव, गुणा, भाग, और मापांक) करें। अवैध गणना \"invalid calcu\" लौटाती है।\n\nउदाहरण:\n>>> simpleCalculator(5, 3, '+')\n8\n>>> simpleCalculator(5, 3, '-')\n2\n>>> simpleCalculator(5, 3, '*')\n15\n>>> simpleCalculator(5, 3, '/')\n1\n>>> simpleCalculator(5, 3, '%')\n2",
      "hu": "Végezzen el alapvető aritmetikai műveleteket (összeadás, kivonás, szorzás, osztás és modulusz) két egész számon egy megadott műveleti karakter alapján. Érvénytelen számítás esetén \"invalid calcu\" értéket ad vissza.\n\nPélda:\n>>> simpleCalculator(5, 3, '+')\n8\n>>> simpleCalculator(5, 3, '-')\n2\n>>> simpleCalculator(5, 3, '*')\n15\n>>> simpleCalculator(5, 3, '/')\n1\n>>> simpleCalculator(5, 3, '%')\n2"
    },
    "docstring_bertscore": {
      "sq": "0.999999801369619",
      "hy": "0.9791209674975178",
      "bn": "0.9763542449200828",
      "bg": "0.9798308724793364",
      "zh": "0.9877105396949905",
      "fr": "0.9898930903218018",
      "de": "0.9874954229923296",
      "ha": "0.9810143122895423",
      "hi": "0.9885606777258198",
      "hu": "0.9590684360105216"
    }
  },
  {
    "task_id": "Kotlin/21",
    "prompt": {
      "en": "/**\n * Calculates the number of passengers on a bus at a specific station.\n * \n * The bus starts at the first station with 'a' passengers. At the second station, an equal number of passengers get on and off, \n * so the count remains 'a'. From the third station onwards, the number of passengers getting on is the sum of the passengers \n * that got on at the last two stations, and the number of passengers getting off is the same as the number that got on at the \n * previous station. The process continues until the second-to-last station. The last station sees all passengers ('m') getting off.\n *\n * @param a The number of passengers boarding at the first station.\n * @param n The total number of stations.\n * @param m The number of passengers who get off at the last station.\n * @param x The station number for which the passenger count is required.\n * @return The number of passengers on the bus as it leaves station 'x'.\n *\n * Example:\n * >>> busStationPassengers(5, 7, 32, 4)\n *     13\n */\n\nfun busStationPassengers(a: Int, n: Int, m: Int, x: Int): Int ",
      "sq": "/**\n * Llogarit numrin e pasagjerëve në një autobus në një stacion specifik.\n * \n * Autobusi fillon në stacionin e parë me 'a' pasagjerë. Në stacionin e dytë, një numër i barabartë pasagjerësh hipin dhe zbresin,\n * kështu që numri mbetet 'a'. Nga stacioni i tretë e tutje, numri i pasagjerëve që hipin është shuma e pasagjerëve\n * që hipën në dy stacionet e fundit, dhe numri i pasagjerëve që zbresin është i njëjtë me numrin që hipi në\n * stacionin e mëparshëm. Procesi vazhdon deri në stacionin e parafundit. Në stacionin e fundit të gjithë pasagjerët ('m') zbresin.\n *\n * @param a Numri i pasagjerëve që hipin në stacionin e parë.\n * @param n Numri total i stacioneve.\n * @param m Numri i pasagjerëve që zbresin në stacionin e fundit.\n * @param x Numri i stacionit për të cilin kërkohet numri i pasagjerëve.\n * @return Numri i pasagjerëve në autobus ndërsa largohet nga stacioni 'x'.\n *\n * Shembull:\n * >>> busStationPassengers(5, 7, 32, 4)\n *     13\n */",
      "hy": "/**\n * Հաշվում է ավտոբուսի ուղևորների քանակը կոնկրետ կայարանում։\n * \n * Ավտոբուսը սկսում է առաջին կայարանում 'a' ուղևորներով։ Երկրորդ կայարանում նույն քանակի ուղևորներ են նստում և իջնում,\n * ուստի քանակը մնում է 'a'։ Երրորդ կայարանից սկսած, նստող ուղևորների քանակը վերջին երկու կայարաններում նստած ուղևորների \n * գումարն է, իսկ իջնող ուղևորների քանակը նույնն է, ինչ նախորդ կայարանում նստածների քանակը։ Գործընթացը շարունակվում է մինչև \n * նախավերջին կայարանը։ Վերջին կայարանում բոլոր ուղևորները ('m') իջնում են։\n *\n * @param a Ուղևորների քանակը, ովքեր նստում են առաջին կայարանում։\n * @param n Կայարանների ընդհանուր քանակը։\n * @param m Ուղևորների քանակը, ովքեր իջնում են վերջին կայարանում։\n * @param x Կայարանի համարը, որի համար անհրաժեշտ է ուղևորների քանակը։\n * @return Ուղևորների քանակը ավտոբուսում, երբ այն հեռանում է 'x' կայարանից։\n *\n * Օրինակ:\n * >>> busStationPassengers(5, 7, 32, 4)\n *     13\n */",
      "bn": "/**\n * একটি নির্দিষ্ট স্টেশনে একটি বাসে যাত্রীদের সংখ্যা গণনা করে।\n * \n * বাসটি প্রথম স্টেশনে 'a' যাত্রী নিয়ে শুরু হয়। দ্বিতীয় স্টেশনে, সমান সংখ্যক যাত্রী ওঠে এবং নামে, \n * তাই গণনা 'a' থাকে। তৃতীয় স্টেশন থেকে শুরু করে, যাত্রীদের ওঠার সংখ্যা শেষ দুটি স্টেশনে ওঠা যাত্রীদের \n * যোগফল হয়, এবং নামার সংখ্যা আগের স্টেশনে ওঠা যাত্রীদের সমান হয়। প্রক্রিয়াটি শেষ থেকে দ্বিতীয় স্টেশন পর্যন্ত \n * চলতে থাকে। শেষ স্টেশনে সব যাত্রী ('m') নেমে যায়।\n *\n * @param a প্রথম স্টেশনে ওঠা যাত্রীদের সংখ্যা।\n * @param n মোট স্টেশনের সংখ্যা।\n * @param m শেষ স্টেশনে নামা যাত্রীদের সংখ্যা।\n * @param x যে স্টেশনের জন্য যাত্রী সংখ্যা প্রয়োজন তার স্টেশন নম্বর।\n * @return স্টেশন 'x' ছাড়ার সময় বাসে যাত্রীদের সংখ্যা।\n *\n * উদাহরণ:\n * >>> busStationPassengers(5, 7, 32, 4)\n *     13\n */",
      "bg": "/**\n * Изчислява броя на пътниците в автобус на определена спирка.\n * \n * Автобусът започва от първата спирка с 'a' пътници. На втората спирка, равен брой пътници се качват и слизат,\n * така че броят остава 'a'. От третата спирка нататък, броят на пътниците, които се качват, е сумата от пътниците,\n * които са се качили на последните две спирки, а броят на пътниците, които слизат, е същият като броя на тези, които са се качили\n * на предишната спирка. Процесът продължава до предпоследната спирка. На последната спирка всички пътници ('m') слизат.\n *\n * @param a Броят на пътниците, които се качват на първата спирка.\n * @param n Общият брой на спирките.\n * @param m Броят на пътниците, които слизат на последната спирка.\n * @param x Номерът на спирката, за която е необходим броят на пътниците.\n * @return Броят на пътниците в автобуса, когато той напуска спирка 'x'.\n *\n * Пример:\n * >>> busStationPassengers(5, 7, 32, 4)\n *     13\n */",
      "zh": "/**\n * 计算特定车站的公交车乘客数量。\n * \n * 公交车在第一个车站有 'a' 名乘客。第二个车站时，上下车人数相等，因此乘客数量保持为 'a'。从第三个车站开始，上车人数为前两个车站上车人数之和，下车人数与前一个车站上车人数相同。该过程持续到倒数第二个车站。最后一个车站所有乘客 ('m') 下车。\n *\n * @param a 第一个车站上车的乘客数量。\n * @param n 车站总数。\n * @param m 最后一个车站下车的乘客数量。\n * @param x 需要获取乘客数量的车站编号。\n * @return 公交车离开车站 'x' 时的乘客数量。\n *\n * 示例:\n * >>> busStationPassengers(5, 7, 32, 4)\n *     13\n */",
      "fr": "/**\n * Calcule le nombre de passagers dans un bus à une station spécifique.\n * \n * Le bus commence à la première station avec 'a' passagers. À la deuxième station, un nombre égal de passagers monte et descend,\n * donc le compte reste 'a'. À partir de la troisième station, le nombre de passagers qui montent est la somme des passagers\n * qui sont montés aux deux dernières stations, et le nombre de passagers qui descendent est le même que le nombre qui est monté à la\n * station précédente. Le processus continue jusqu'à l'avant-dernière station. La dernière station voit tous les passagers ('m') descendre.\n *\n * @param a Le nombre de passagers montant à la première station.\n * @param n Le nombre total de stations.\n * @param m Le nombre de passagers qui descendent à la dernière station.\n * @param x Le numéro de la station pour laquelle le nombre de passagers est requis.\n * @return Le nombre de passagers dans le bus lorsqu'il quitte la station 'x'.\n *\n * Exemple:\n * >>> busStationPassengers(5, 7, 32, 4)\n *     13\n */",
      "de": "/**\n * Berechnet die Anzahl der Passagiere in einem Bus an einer bestimmten Haltestelle.\n * \n * Der Bus startet an der ersten Haltestelle mit 'a' Passagieren. An der zweiten Haltestelle steigen gleich viele Passagiere ein und aus,\n * sodass die Anzahl 'a' bleibt. Ab der dritten Haltestelle ist die Anzahl der einsteigenden Passagiere die Summe der Passagiere,\n * die an den letzten beiden Haltestellen eingestiegen sind, und die Anzahl der aussteigenden Passagiere ist dieselbe wie die Anzahl,\n * die an der vorherigen Haltestelle eingestiegen ist. Der Prozess setzt sich bis zur vorletzten Haltestelle fort. An der letzten Haltestelle steigen alle Passagiere ('m') aus.\n *\n * @param a Die Anzahl der Passagiere, die an der ersten Haltestelle einsteigen.\n * @param n Die Gesamtanzahl der Haltestellen.\n * @param m Die Anzahl der Passagiere, die an der letzten Haltestelle aussteigen.\n * @param x Die Haltestellennummer, für die die Passagieranzahl benötigt wird.\n * @return Die Anzahl der Passagiere im Bus, wenn er die Haltestelle 'x' verlässt.\n *\n * Beispiel:\n * >>> busStationPassengers(5, 7, 32, 4)\n *     13\n */",
      "ha": "/**\n * Lissafa adadin fasinjoji a kan bas a tashar mota ta musamman.\n * \n * Bas din yana farawa a tashar mota ta farko tare da fasinjoji 'a'. A tashar mota ta biyu, adadin fasinjoji da suka hau da suka sauka \n * suna daidai, don haka adadin ya kasance 'a'. Daga tashar mota ta uku zuwa gaba, adadin fasinjoji da ke hawa shine jimillar fasinjojin \n * da suka hau a tashoshin biyu na baya, kuma adadin fasinjoji da ke sauka yana daidai da adadin da suka hau a tashar mota ta baya. \n * Tsarin yana ci gaba har zuwa tashar mota ta biyu daga karshe. Tashar mota ta karshe tana ganin duk fasinjoji ('m') suna sauka.\n *\n * @param a Adadin fasinjoji da suka hau a tashar mota ta farko.\n * @param n Jimillar adadin tashoshin mota.\n * @param m Adadin fasinjoji da suka sauka a tashar mota ta karshe.\n * @param x Lambar tashar mota da ake bukatar adadin fasinjoji.\n * @return Adadin fasinjoji a kan bas yayin da yake barin tashar mota 'x'.\n *\n * Misali:\n * >>> busStationPassengers(5, 7, 32, 4)\n *     13\n */",
      "hi": "/**\n * एक विशिष्ट स्टेशन पर बस में यात्रियों की संख्या की गणना करता है।\n * \n * बस पहले स्टेशन पर 'a' यात्रियों के साथ शुरू होती है। दूसरे स्टेशन पर, समान संख्या में यात्री चढ़ते और उतरते हैं,\n * इसलिए संख्या 'a' बनी रहती है। तीसरे स्टेशन से, चढ़ने वाले यात्रियों की संख्या पिछले दो स्टेशनों पर चढ़े यात्रियों \n * का योग होती है, और उतरने वाले यात्रियों की संख्या पिछले स्टेशन पर चढ़े यात्रियों के बराबर होती है। यह प्रक्रिया \n * दूसरे-से-अंतिम स्टेशन तक जारी रहती है। अंतिम स्टेशन पर सभी यात्री ('m') उतर जाते हैं।\n *\n * @param a पहले स्टेशन पर चढ़ने वाले यात्रियों की संख्या।\n * @param n कुल स्टेशनों की संख्या।\n * @param m अंतिम स्टेशन पर उतरने वाले यात्रियों की संख्या।\n * @param x वह स्टेशन संख्या जिसके लिए यात्री संख्या की आवश्यकता है।\n * @return जब बस स्टेशन 'x' छोड़ती है तो बस में यात्रियों की संख्या।\n *\n * उदाहरण:\n * >>> busStationPassengers(5, 7, 32, 4)\n *     13\n */",
      "hu": "/**\n * Kiszámítja az utasok számát egy buszon egy adott állomáson.\n * \n * A busz az első állomáson 'a' utassal indul. A második állomáson ugyanannyi utas száll fel és le, \n * így a szám 'a' marad. A harmadik állomástól kezdve a felszálló utasok száma az előző két állomáson \n * felszállt utasok összege, és a leszálló utasok száma megegyezik az előző állomáson felszállt utasok számával. \n * A folyamat az utolsó előtti állomásig folytatódik. Az utolsó állomáson minden utas ('m') leszáll.\n *\n * @param a Az első állomáson felszálló utasok száma.\n * @param n Az állomások összes száma.\n * @param m Az utolsó állomáson leszálló utasok száma.\n * @param x Az állomás száma, amelyre az utasszám szükséges.\n * @return Az utasok száma a buszon, amikor elhagyja az 'x' állomást.\n *\n * Példa:\n * >>> busStationPassengers(5, 7, 32, 4)\n *     13\n */"
    },
    "prompt_bertscore": {
      "sq": "0.9137624351395119",
      "hy": "0.9071784338993485",
      "bn": "0.8989793690309904",
      "bg": "0.9141606890534869",
      "zh": "0.8921325797967178",
      "fr": "0.954453060476795",
      "de": "0.8931720125806734",
      "ha": "0.8884428218386137",
      "hi": "0.9004494324810296",
      "hu": "0.9085899013869824"
    },
    "canonical_solution": "{\n    val siteNumber = IntArray(n + 1)  // Array to store the number of passengers at each station\n    val onPerson = IntArray(n + 1)    // Array to store the number of passengers getting on at each station\n    val downPerson = IntArray(n + 1)  // Array to store the number of passengers getting off at each station\n\n    siteNumber[1] = a  // At the first and second station, 'a' passengers are on the bus\n    siteNumber[2] = a\n    onPerson[1] = a    // 'a' passengers get on at the first station\n    downPerson[1] = 0  // No passengers get off at the first station\n\n    for (i in 1 until n) {\n        onPerson[2] = i\n        downPerson[2] = i\n\n        for (j in 3 until n) {\n            onPerson[j] = onPerson[j - 1] + onPerson[j - 2]\n            downPerson[j] = onPerson[j - 1]\n\n            siteNumber[j] = siteNumber[j - 1] + onPerson[j] - downPerson[j]\n        }\n\n        if (siteNumber[n - 1] == m) {\n            return siteNumber[x]\n        }\n    }\n\n    throw IllegalArgumentException(\"No valid solution found for the given input.\")\n}",
    "instruction": {
      "en": "Write a Kotlin function `fun busStationPassengers(a: Int, n: Int, m: Int, x: Int): Int` to solve the following problem:\nCalculates the number of passengers on a bus at a specific station.\n\nThe bus starts at the first station with 'a' passengers. At the second station, an equal number of passengers get on and off,\nso the count remains 'a'. From the third station onwards, the number of passengers getting on is the sum of the passengers\nthat got on at the last two stations, and the number of passengers getting off is the same as the number that got on at the\nprevious station. The process continues until the second-to-last station. The last station sees all passengers ('m') getting off.\n\n@param a The number of passengers boarding at the first station.\n@param n The total number of stations.\n@param m The number of passengers who get off at the last station.\n@param x The station number for which the passenger count is required.\n@return The number of passengers on the bus as it leaves station 'x'.\n\nExample:\n>>> busStationPassengers(5, 7, 32, 4)\n13",
      "sq": "Shkruani një funksion Kotlin `fun busStationPassengers(a: Int, n: Int, m: Int, x: Int): Int` për të zgjidhur problemin e mëposhtëm:\nLlogarit numrin e pasagjerëve në një autobus në një stacion specifik.\n\nAutobusi fillon në stacionin e parë me 'a' pasagjerë. Në stacionin e dytë, një numër i barabartë pasagjerësh hipin dhe zbresin,\nkështu që numri mbetet 'a'. Nga stacioni i tretë e tutje, numri i pasagjerëve që hipin është shuma e pasagjerëve\nqë hipën në dy stacionet e fundit, dhe numri i pasagjerëve që zbresin është i njëjtë me numrin që hipi në\nstacionin e mëparshëm. Procesi vazhdon deri në stacionin e parafundit. Në stacionin e fundit të gjithë pasagjerët ('m') zbresin.\n\n@param a Numri i pasagjerëve që hipin në stacionin e parë.\n@param n Numri total i stacioneve.\n@param m Numri i pasagjerëve që zbresin në stacionin e fundit.\n@param x Numri i stacionit për të cilin kërkohet numri i pasagjerëve.\n@return Numri i pasagjerëve në autobus ndërsa largohet nga stacioni 'x'.\n\nShembull:\n>>> busStationPassengers(5, 7, 32, 4)\n13",
      "hy": "Գրեք Kotlin ֆունկցիա `fun busStationPassengers(a: Int, n: Int, m: Int, x: Int): Int` հետևյալ խնդիրը լուծելու համար:\nՀաշվում է ավտոբուսում գտնվող ուղևորների քանակը կոնկրետ կայարանում:\n\nԱվտոբուսը սկսում է առաջին կայարանից 'a' ուղևորներով: Երկրորդ կայարանում նույն քանակությամբ ուղևորներ են նստում և իջնում,\nայդպիսով քանակը մնում է 'a': Երրորդ կայարանից սկսած, նստող ուղևորների քանակը հավասար է նախորդ երկու կայարաններում\nնստած ուղևորների գումարին, իսկ իջնող ուղևորների քանակը նույնն է, ինչ նախորդ կայարանում նստածների քանակը: Գործընթացը շարունակվում է մինչև նախավերջին կայարանը: Վերջին կայարանում բոլոր ուղևորները ('m') իջնում են:\n\n@param a Ուղևորների քանակը, որոնք նստում են առաջին կայարանում:\n@param n Կայարանների ընդհանուր քանակը:\n@param m Ուղևորների քանակը, որոնք իջնում են վերջին կայարանում:\n@param x Կայարանի համարը, որի համար անհրաժեշտ է ուղևորների քանակը:\n@return Ուղևորների քանակը ավտոբուսում, երբ այն հեռանում է 'x' կայարանից:\n\nՕրինակ:\n>>> busStationPassengers(5, 7, 32, 4)\n13",
      "bn": "Kotlin ফাংশন `fun busStationPassengers(a: Int, n: Int, m: Int, x: Int): Int` লিখুন নিম্নলিখিত সমস্যার সমাধানের জন্য:\nএকটি নির্দিষ্ট স্টেশনে বাসে যাত্রীদের সংখ্যা গণনা করে।\n\nবাসটি প্রথম স্টেশনে 'a' যাত্রী নিয়ে শুরু হয়। দ্বিতীয় স্টেশনে, সমান সংখ্যক যাত্রী ওঠে এবং নামে,\nতাই গণনা 'a' থাকে। তৃতীয় স্টেশন থেকে শুরু করে, যাত্রী ওঠার সংখ্যা আগের দুই স্টেশনে ওঠা যাত্রীদের\nযোগফল, এবং নামার সংখ্যা আগের স্টেশনে ওঠা যাত্রীদের সমান। এই প্রক্রিয়া দ্বিতীয়-শেষ স্টেশন পর্যন্ত চলতে থাকে। শেষ স্টেশনে সব যাত্রী ('m') নেমে যায়।\n\n@param a প্রথম স্টেশনে ওঠা যাত্রীদের সংখ্যা।\n@param n মোট স্টেশনের সংখ্যা।\n@param m শেষ স্টেশনে নামা যাত্রীদের সংখ্যা।\n@param x যে স্টেশনের জন্য যাত্রী সংখ্যা প্রয়োজন তার স্টেশন নম্বর।\n@return স্টেশন 'x' ছাড়ার সময় বাসে থাকা যাত্রীদের সংখ্যা।\n\nউদাহরণ:\n>>> busStationPassengers(5, 7, 32, 4)\n13",
      "bg": "Напишете функция на Kotlin `fun busStationPassengers(a: Int, n: Int, m: Int, x: Int): Int`, за да решите следния проблем:\nИзчислява броя на пътниците в автобус на определена спирка.\n\nАвтобусът започва от първата спирка с 'a' пътници. На втората спирка равен брой пътници се качват и слизат,\nтака че броят остава 'a'. От третата спирка нататък броят на пътниците, които се качват, е сумата от пътниците,\nкоито са се качили на последните две спирки, а броят на пътниците, които слизат, е същият като броя, който се е качил на\nпредишната спирка. Процесът продължава до предпоследната спирка. На последната спирка всички пътници ('m') слизат.\n\n@param a Броят на пътниците, които се качват на първата спирка.\n@param n Общият брой на спирките.\n@param m Броят на пътниците, които слизат на последната спирка.\n@param x Номерът на спирката, за която е необходим броят на пътниците.\n@return Броят на пътниците в автобуса, когато той напуска спирка 'x'.\n\nПример:\n>>> busStationPassengers(5, 7, 32, 4)\n13",
      "zh": "编写一个 Kotlin 函数 `fun busStationPassengers(a: Int, n: Int, m: Int, x: Int): Int` 来解决以下问题：\n计算在特定车站的公交车上的乘客数量。\n\n公交车在第一个车站有 'a' 名乘客。第二个车站时，上下车的乘客数量相等，所以人数保持为 'a'。从第三个车站开始，上车的乘客数量是前两个车站上车乘客数量的总和，而下车的乘客数量与前一个车站上车的乘客数量相同。该过程一直持续到倒数第二个车站。最后一个车站所有乘客 ('m') 都下车。\n\n@param a 在第一个车站上车的乘客数量。\n@param n 车站总数。\n@param m 在最后一个车站下车的乘客数量。\n@param x 需要获取乘客数量的车站编号。\n@return 公交车离开车站 'x' 时的乘客数量。\n\n示例:\n>>> busStationPassengers(5, 7, 32, 4)\n13",
      "fr": "Écrire une fonction Kotlin `fun busStationPassengers(a: Int, n: Int, m: Int, x: Int): Int` pour résoudre le problème suivant :\nCalcule le nombre de passagers dans un bus à une station spécifique.\n\nLe bus commence à la première station avec 'a' passagers. À la deuxième station, un nombre égal de passagers monte et descend,\ndonc le compte reste 'a'. À partir de la troisième station, le nombre de passagers qui montent est la somme des passagers\nqui sont montés aux deux dernières stations, et le nombre de passagers qui descendent est le même que le nombre qui est monté à la\nstation précédente. Le processus continue jusqu'à l'avant-dernière station. La dernière station voit tous les passagers ('m') descendre.\n\n@param a Le nombre de passagers montant à la première station.\n@param n Le nombre total de stations.\n@param m Le nombre de passagers qui descendent à la dernière station.\n@param x Le numéro de la station pour laquelle le nombre de passagers est requis.\n@return Le nombre de passagers dans le bus lorsqu'il quitte la station 'x'.\n\nExemple :\n>>> busStationPassengers(5, 7, 32, 4)\n13",
      "de": "Schreiben Sie eine Kotlin-Funktion `fun busStationPassengers(a: Int, n: Int, m: Int, x: Int): Int`, um das folgende Problem zu lösen:\nBerechnet die Anzahl der Passagiere in einem Bus an einer bestimmten Station.\n\nDer Bus startet an der ersten Station mit 'a' Passagieren. An der zweiten Station steigen gleich viele Passagiere ein und aus,\nsodass die Anzahl 'a' bleibt. Ab der dritten Station ist die Anzahl der einsteigenden Passagiere die Summe der Passagiere,\ndie an den letzten zwei Stationen eingestiegen sind, und die Anzahl der aussteigenden Passagiere ist dieselbe wie die Anzahl,\ndie an der vorherigen Station eingestiegen ist. Der Prozess setzt sich bis zur vorletzten Station fort. An der letzten Station steigen alle Passagiere ('m') aus.\n\n@param a Die Anzahl der Passagiere, die an der ersten Station einsteigen.\n@param n Die Gesamtanzahl der Stationen.\n@param m Die Anzahl der Passagiere, die an der letzten Station aussteigen.\n@param x Die Stationsnummer, für die die Anzahl der Passagiere benötigt wird.\n@return Die Anzahl der Passagiere im Bus, wenn er die Station 'x' verlässt.\n\nBeispiel:\n>>> busStationPassengers(5, 7, 32, 4)\n13",
      "ha": "Rubuta aikin Kotlin `fun busStationPassengers(a: Int, n: Int, m: Int, x: Int): Int` don warware matsalar mai zuwa:\nLissafa yawan fasinjoji a kan bas a tashar musamman.\n\nBas din yana farawa a tashar farko da fasinjoji 'a'. A tashar ta biyu, adadin fasinjoji da suka hau da suka sauka suna daidai,\nsaboda haka adadin yana nan 'a'. Daga tashar ta uku zuwa gaba, yawan fasinjojin da ke hawa shine jimlar fasinjojin\nda suka hau a tashoshin biyu na baya, kuma yawan fasinjojin da ke sauka yana daidai da yawan da suka hau a\ntashar da ta gabata. Tsarin yana ci gaba har zuwa tashar ta biyu daga karshe. Tashar karshe tana ganin duk fasinjoji ('m') suna sauka.\n\n@param a Yawan fasinjojin da ke hawa a tashar farko.\n@param n Jimlar yawan tashoshi.\n@param m Yawan fasinjojin da ke sauka a tashar karshe.\n@param x Lambar tashar da ake bukatar yawan fasinjoji.\n@return Yawan fasinjoji a kan bas yayin da yake barin tashar 'x'.\n\nMisali:\n>>> busStationPassengers(5, 7, 32, 4)\n13",
      "hi": "Kotlin फ़ंक्शन `fun busStationPassengers(a: Int, n: Int, m: Int, x: Int): Int` लिखें ताकि निम्नलिखित समस्या का समाधान हो सके:\nएक विशिष्ट स्टेशन पर बस में यात्रियों की संख्या की गणना करता है।\n\nबस पहले स्टेशन पर 'a' यात्रियों के साथ शुरू होती है। दूसरे स्टेशन पर, समान संख्या में यात्री चढ़ते और उतरते हैं,\nइसलिए गिनती 'a' रहती है। तीसरे स्टेशन से आगे, चढ़ने वाले यात्रियों की संख्या पिछले दो स्टेशनों पर चढ़े यात्रियों का योग होती है,\nऔर उतरने वाले यात्रियों की संख्या पिछले स्टेशन पर चढ़े यात्रियों के समान होती है। यह प्रक्रिया दूसरे-आखिरी स्टेशन तक जारी रहती है। आखिरी स्टेशन पर सभी यात्री ('m') उतर जाते हैं।\n\n@param a पहले स्टेशन पर चढ़ने वाले यात्रियों की संख्या।\n@param n कुल स्टेशनों की संख्या।\n@param m आखिरी स्टेशन पर उतरने वाले यात्रियों की संख्या।\n@param x वह स्टेशन संख्या जिसके लिए यात्री संख्या की आवश्यकता है।\n@return बस में यात्रियों की संख्या जब यह स्टेशन 'x' छोड़ती है।\n\nउदाहरण:\n>>> busStationPassengers(5, 7, 32, 4)\n13",
      "hu": "Írj egy Kotlin függvényt `fun busStationPassengers(a: Int, n: Int, m: Int, x: Int): Int` a következő probléma megoldására:\nKiszámítja az utasok számát egy buszon egy adott állomáson.\n\nA busz az első állomáson 'a' utassal indul. A második állomáson ugyanannyi utas száll fel és le, így a szám 'a' marad. A harmadik állomástól kezdve az utasok száma, akik felszállnak, az utolsó két állomáson felszállt utasok összege, és az utasok száma, akik leszállnak, ugyanannyi, mint amennyi az előző állomáson felszállt. A folyamat az utolsó előtti állomásig folytatódik. Az utolsó állomáson az összes utas ('m') leszáll.\n\n@param a Az első állomáson felszálló utasok száma.\n@param n Az állomások teljes száma.\n@param m Az utolsó állomáson leszálló utasok száma.\n@param x Az állomás száma, amelynél az utasszám szükséges.\n@return Az utasok száma a buszon, amikor elhagyja az 'x' állomást.\n\nPélda:\n>>> busStationPassengers(5, 7, 32, 4)\n13"
    },
    "instruction_bertscore": {
      "sq": "0.9507704532124082",
      "hy": "0.9335209936625763",
      "bn": "0.9212069031903185",
      "bg": "0.945856138955224",
      "zh": "0.9571564199626797",
      "fr": "0.9851027214223834",
      "de": "0.9512485565395591",
      "ha": "0.9422986688308891",
      "hi": "0.9337281651499958",
      "hu": "0.9625408923317735"
    },
    "level": "hard",
    "test": "fun main() {\n    check(busStationPassengers(5, 7, 32, 5) == 21)\n    check(busStationPassengers(5, 7, 32, 4) == 13)\n    check(busStationPassengers(5, 7, 32, 3) == 10)\n    check(busStationPassengers(5, 7, 32, 2) == 5)\n    \n\n}\nmain()",
    "entry_point": "busStationPassengers",
    "signature": "fun busStationPassengers(a: Int, n: Int, m: Int, x: Int): Int",
    "docstring": {
      "en": "Calculates the number of passengers on a bus at a specific station.\n\nThe bus starts at the first station with 'a' passengers. At the second station, an equal number of passengers get on and off,\nso the count remains 'a'. From the third station onwards, the number of passengers getting on is the sum of the passengers\nthat got on at the last two stations, and the number of passengers getting off is the same as the number that got on at the\nprevious station. The process continues until the second-to-last station. The last station sees all passengers ('m') getting off.\n\n@param a The number of passengers boarding at the first station.\n@param n The total number of stations.\n@param m The number of passengers who get off at the last station.\n@param x The station number for which the passenger count is required.\n@return The number of passengers on the bus as it leaves station 'x'.\n\nExample:\n>>> busStationPassengers(5, 7, 32, 4)\n13",
      "sq": "Llogarit numrin e pasagjerëve në një autobus në një stacion specifik.\n\nAutobusi fillon në stacionin e parë me 'a' pasagjerë. Në stacionin e dytë, një numër i barabartë pasagjerësh hipin dhe zbresin,\nkështu që numri mbetet 'a'. Nga stacioni i tretë e tutje, numri i pasagjerëve që hipin është shuma e pasagjerëve\nqë hipën në dy stacionet e fundit, dhe numri i pasagjerëve që zbresin është i njëjtë me numrin që hipën në\nstacionin e mëparshëm. Procesi vazhdon deri në stacionin e parafundit. Në stacionin e fundit të gjithë pasagjerët ('m') zbresin.\n\n@param a Numri i pasagjerëve që hipin në stacionin e parë.\n@param n Numri total i stacioneve.\n@param m Numri i pasagjerëve që zbresin në stacionin e fundit.\n@param x Numri i stacionit për të cilin kërkohet numri i pasagjerëve.\n@return Numri i pasagjerëve në autobus ndërsa largohet nga stacioni 'x'.\n\nShembull:\n>>> busStationPassengers(5, 7, 32, 4)\n13",
      "hy": "Հաշվում է ավտոբուսի ուղևորների քանակը որոշակի կայարանում:\n\nԱվտոբուսը սկսում է առաջին կայարանում 'a' ուղևորներով: Երկրորդ կայարանում նույն քանակի ուղևորներ են նստում և իջնում, այնպես որ քանակը մնում է 'a': Երրորդ կայարանից սկսած, նստող ուղևորների քանակը հավասար է վերջին երկու կայարաններում նստած ուղևորների գումարին, իսկ իջնող ուղևորների քանակը նույնն է, ինչ նախորդ կայարանում նստած ուղևորների քանակը: Գործընթացը շարունակվում է մինչև նախավերջին կայարանը: Վերջին կայարանում բոլոր ուղևորները ('m') իջնում են:\n\n@param a Ուղևորների քանակը, ովքեր նստում են առաջին կայարանում:\n@param n Կայարանների ընդհանուր քանակը:\n@param m Ուղևորների քանակը, ովքեր իջնում են վերջին կայարանում:\n@param x Կայարանի համարը, որի համար պահանջվում է ուղևորների քանակը:\n@return Ուղևորների քանակը ավտոբուսում, երբ այն հեռանում է 'x' կայարանից:\n\nՕրինակ:\n>>> busStationPassengers(5, 7, 32, 4)\n13",
      "bn": "বাসের একটি নির্দিষ্ট স্টেশনে যাত্রীদের সংখ্যা গণনা করে।\n\nবাসটি প্রথম স্টেশনে 'a' সংখ্যক যাত্রী নিয়ে শুরু হয়। দ্বিতীয় স্টেশনে, সমান সংখ্যক যাত্রী ওঠে এবং নামে, তাই সংখ্যা 'a' থাকে। তৃতীয় স্টেশন থেকে শুরু করে, যাত্রীদের ওঠার সংখ্যা শেষ দুই স্টেশনে ওঠা যাত্রীদের যোগফল, এবং নামার সংখ্যা আগের স্টেশনে ওঠা যাত্রীদের সমান। এই প্রক্রিয়া শেষের আগের স্টেশন পর্যন্ত চলতে থাকে। শেষ স্টেশনে সব যাত্রী ('m') নেমে যায়।\n\n@param a প্রথম স্টেশনে ওঠা যাত্রীদের সংখ্যা।\n@param n মোট স্টেশনের সংখ্যা।\n@param m শেষ স্টেশনে নামা যাত্রীদের সংখ্যা।\n@param x যে স্টেশনের জন্য যাত্রী সংখ্যা প্রয়োজন তার স্টেশন নম্বর।\n@return স্টেশন 'x' ছাড়ার সময় বাসে থাকা যাত্রীদের সংখ্যা।\n\nউদাহরণ:\n>>> busStationPassengers(5, 7, 32, 4)\n13",
      "bg": "Изчислява броя на пътниците в автобус на определена спирка.\n\nАвтобусът започва от първата спирка с 'a' пътници. На втората спирка равен брой пътници се качват и слизат,\nтака че броят остава 'a'. От третата спирка нататък броят на качващите се пътници е сумата от пътниците,\nкоито са се качили на последните две спирки, а броят на слизащите пътници е същият като броя на качилите се на\nпредишната спирка. Процесът продължава до предпоследната спирка. На последната спирка всички пътници ('m') слизат.\n\n@param a Броят на пътниците, които се качват на първата спирка.\n@param n Общият брой на спирките.\n@param m Броят на пътниците, които слизат на последната спирка.\n@param x Номерът на спирката, за която е необходим броят на пътниците.\n@return Броят на пътниците в автобуса, когато напуска спирка 'x'.\n\nПример:\n>>> busStationPassengers(5, 7, 32, 4)\n13",
      "zh": "计算特定车站公交车上的乘客数量。\n\n公交车在第一站有 'a' 名乘客。第二站时，上下车的乘客数量相等，因此乘客数量保持为 'a'。从第三站开始，上车的乘客数量是前两站上车乘客数量的总和，而下车的乘客数量与前一站上车的乘客数量相同。这个过程持续到倒数第二站。最后一站所有乘客 ('m') 下车。\n\n@param a 第一站上车的乘客数量。\n@param n 车站总数。\n@param m 最后一站下车的乘客数量。\n@param x 需要计算乘客数量的车站编号。\n@return 公交车离开车站 'x' 时的乘客数量。\n\n示例：\n>>> busStationPassengers(5, 7, 32, 4)\n13",
      "fr": "Calcule le nombre de passagers dans un bus à une station spécifique.\n\nLe bus commence à la première station avec 'a' passagers. À la deuxième station, un nombre égal de passagers monte et descend, donc le compte reste 'a'. À partir de la troisième station, le nombre de passagers montant est la somme des passagers qui sont montés aux deux dernières stations, et le nombre de passagers descendant est le même que le nombre qui est monté à la station précédente. Le processus continue jusqu'à l'avant-dernière station. La dernière station voit tous les passagers ('m') descendre.\n\n@param a Le nombre de passagers montant à la première station.\n@param n Le nombre total de stations.\n@param m Le nombre de passagers qui descendent à la dernière station.\n@param x Le numéro de la station pour laquelle le nombre de passagers est requis.\n@return Le nombre de passagers dans le bus lorsqu'il quitte la station 'x'.\n\nExemple:\n>>> busStationPassengers(5, 7, 32, 4)\n13",
      "de": "Berechnet die Anzahl der Passagiere in einem Bus an einer bestimmten Station.\n\nDer Bus startet an der ersten Station mit 'a' Passagieren. An der zweiten Station steigen gleich viele Passagiere ein und aus, sodass die Anzahl 'a' bleibt. Ab der dritten Station ist die Anzahl der einsteigenden Passagiere die Summe der Passagiere, die an den letzten beiden Stationen eingestiegen sind, und die Anzahl der aussteigenden Passagiere ist die gleiche wie die Anzahl, die an der vorherigen Station eingestiegen ist. Der Prozess setzt sich bis zur vorletzten Station fort. An der letzten Station steigen alle Passagiere ('m') aus.\n\n@param a Die Anzahl der Passagiere, die an der ersten Station einsteigen.\n@param n Die Gesamtzahl der Stationen.\n@param m Die Anzahl der Passagiere, die an der letzten Station aussteigen.\n@param x Die Stationsnummer, für die die Anzahl der Passagiere benötigt wird.\n@return Die Anzahl der Passagiere im Bus, wenn er die Station 'x' verlässt.\n\nBeispiel:\n>>> busStationPassengers(5, 7, 32, 4)\n13",
      "ha": "Lissafa adadin fasinjoji a kan bas a wani tashar musamman.\n\n# Bas din yana farawa a tashar farko tare da fasinjoji 'a'. A tashar ta biyu, adadin fasinjoji da suka hau da suka sauka\n# ya yi daidai, don haka adadin ya kasance 'a'. Daga tashar ta uku zuwa gaba, adadin fasinjoji da ke hawa shine jumlar fasinjojin\n# da suka hau a tashoshin biyu da suka gabata, kuma adadin fasinjoji da ke sauka ya yi daidai da adadin da suka hau a\n# tashar da ta gabata. Tsarin yana ci gaba har zuwa tashar ta biyu daga karshe. Tashar karshe tana ganin duk fasinjoji ('m') suna sauka.\n\n@param a Adadin fasinjojin da ke hawa a tashar farko.\n@param n Jimlar adadin tashoshi.\n@param m Adadin fasinjojin da ke sauka a tashar karshe.\n@param x Lambar tashar da ake bukatar adadin fasinjoji.\n@return Adadin fasinjoji a kan bas din yayin da yake barin tashar 'x'.\n\nExample:\n>>> busStationPassengers(5, 7, 32, 4)\n13",
      "hi": "बस में एक विशिष्ट स्टेशन पर यात्रियों की संख्या की गणना करता है।\n\nबस पहले स्टेशन पर 'a' यात्रियों के साथ शुरू होती है। दूसरे स्टेशन पर, समान संख्या में यात्री चढ़ते और उतरते हैं, इसलिए संख्या 'a' बनी रहती है। तीसरे स्टेशन से आगे, चढ़ने वाले यात्रियों की संख्या पिछले दो स्टेशनों पर चढ़े यात्रियों का योग होती है, और उतरने वाले यात्रियों की संख्या पिछले स्टेशन पर चढ़े यात्रियों के बराबर होती है। यह प्रक्रिया दूसरे-से-अंतिम स्टेशन तक जारी रहती है। अंतिम स्टेशन पर सभी यात्री ('m') उतर जाते हैं।\n\n@param a पहले स्टेशन पर चढ़ने वाले यात्रियों की संख्या।\n@param n कुल स्टेशनों की संख्या।\n@param m अंतिम स्टेशन पर उतरने वाले यात्रियों की संख्या।\n@param x वह स्टेशन संख्या जिसके लिए यात्री संख्या की आवश्यकता है।\n@return बस में यात्रियों की संख्या जब वह स्टेशन 'x' छोड़ती है।\n\nउदाहरण:\n>>> busStationPassengers(5, 7, 32, 4)\n13",
      "hu": "Számítja az utasok számát egy buszon egy adott állomáson.\n\nA busz az első állomáson 'a' utassal indul. A második állomáson ugyanannyi utas száll fel és le, így a szám 'a' marad. A harmadik állomástól kezdve a felszálló utasok száma az előző két állomáson felszállt utasok összege, és a leszálló utasok száma megegyezik az előző állomáson felszállt utasok számával. A folyamat az utolsó előtti állomásig folytatódik. Az utolsó állomáson minden utas ('m') leszáll.\n\n@param a Az első állomáson felszálló utasok száma.\n@param n Az állomások összes száma.\n@param m Az utolsó állomáson leszálló utasok száma.\n@param x Az állomás száma, amelyhez az utasszám szükséges.\n@return Az utasok száma a buszon, amikor elhagyja az 'x' állomást.\n\nPélda:\n>>> busStationPassengers(5, 7, 32, 4)\n13"
    },
    "docstring_bertscore": {
      "sq": "0.9407449819904342",
      "hy": "0.9316727379670467",
      "bn": "0.911280945789243",
      "bg": "0.9174601383128574",
      "zh": "0.9339994942504894",
      "fr": "0.9463775437054406",
      "de": "0.9392630007175329",
      "ha": "0.9048681639375317",
      "hi": "0.9188066536658929",
      "hu": "0.9346011456746441"
    }
  },
  {
    "task_id": "Kotlin/22",
    "prompt": {
      "en": "/**\n    * Calculate the number of ways a person can mistakenly put letters in envelopes\n    * such that each letter ends up in the wrong envelope.\n    *\n    * This is based on a derangement problem where each item (letter) must not be\n    * in its original position (envelope).\n    *\n    * Parameters:\n    * n - the number of letters and envelopes.\n    *\n    * Returns:\n    * The total number of ways to wrongly place all the letters.\n    *\n    * Examples:\n    * >>> countWrongEnvelopeCombinations(2)\n    *     1\n    * >>> countWrongEnvelopeCombinations(3)\n    *     2\n**/\nfun countWrongEnvelopeCombinations(n: Int): Long ",
      "sq": "/**\n    * Llogarit numrin e mënyrave që një person mund të vendosë gabimisht letra në zarfe\n    * në mënyrë që secila letër të përfundojë në zarfin e gabuar.\n    *\n    * Kjo bazohet në një problem të çrregullimit ku secili artikull (letër) nuk duhet të jetë\n    * në pozicionin e tij origjinal (zarf).\n    *\n    * Parametrat:\n    * n - numri i letrave dhe zarfeve.\n    *\n    * Kthen:\n    * Numri total i mënyrave për të vendosur gabimisht të gjitha letrat.\n    *\n    * Shembuj:\n    * >>> countWrongEnvelopeCombinations(2)\n    *     1\n    * >>> countWrongEnvelopeCombinations(3)\n    *     2\n**/",
      "hy": "/**\n    * Հաշվել, թե քանի եղանակով կարող է մարդ սխալմամբ տեղադրել նամակները ծրարների մեջ\n    * այնպես, որ յուրաքանչյուր նամակ հայտնվի սխալ ծրարում:\n    *\n    * Սա հիմնված է տեղաշարժման խնդրի վրա, որտեղ յուրաքանչյուր տարր (նամակ) չպետք է լինի\n    * իր սկզբնական դիրքում (ծրար):\n    *\n    * Պարամետրեր:\n    * n - նամակների և ծրարների քանակը:\n    *\n    * Վերադարձնում է:\n    * Նամակները սխալ տեղադրելու եղանակների ընդհանուր քանակը:\n    *\n    * Օրինակներ:\n    * >>> countWrongEnvelopeCombinations(2)\n    *     1\n    * >>> countWrongEnvelopeCombinations(3)\n    *     2\n**/",
      "bn": "/**\n    * একজন ব্যক্তি কীভাবে ভুল করে চিঠিগুলি খামগুলিতে রাখতে পারে তার সংখ্যা গণনা করুন\n    * যাতে প্রতিটি চিঠি ভুল খামে শেষ হয়।\n    *\n    * এটি একটি ডিরেঞ্জমেন্ট সমস্যার উপর ভিত্তি করে যেখানে প্রতিটি আইটেম (চিঠি) তার\n    * মূল অবস্থানে (খাম) থাকা উচিত নয়।\n    *\n    * প্যারামিটার:\n    * n - চিঠি এবং খামের সংখ্যা।\n    *\n    * রিটার্ন:\n    * সমস্ত চিঠি ভুলভাবে রাখার মোট উপায়ের সংখ্যা।\n    *\n    * উদাহরণ:\n    * >>> countWrongEnvelopeCombinations(2)\n    *     1\n    * >>> countWrongEnvelopeCombinations(3)\n    *     2\n**/",
      "bg": "/**\n    * Изчислява броя на начините, по които човек може погрешно да постави писма в пликове\n    * така че всяко писмо да се окаже в грешен плик.\n    *\n    * Това се основава на задача за деренжиране, където всеки елемент (писмо) не трябва да бъде\n    * на оригиналната си позиция (плик).\n    *\n    * Параметри:\n    * n - броят на писмата и пликовете.\n    *\n    * Връща:\n    * Общият брой начини за неправилно поставяне на всички писма.\n    *\n    * Примери:\n    * >>> countWrongEnvelopeCombinations(2)\n    *     1\n    * >>> countWrongEnvelopeCombinations(3)\n    *     2\n**/",
      "zh": "/**\n    * 计算一个人错误地将信件放入信封的方式数量，\n    * 使得每封信都放入错误的信封中。\n    *\n    * 这是基于一个错排问题，其中每个项目（信件）都不能在其原始位置（信封）中。\n    *\n    * 参数：\n    * n - 信件和信封的数量。\n    *\n    * 返回：\n    * 错误放置所有信件的总方式数量。\n    *\n    * 示例：\n    * >>> countWrongEnvelopeCombinations(2)\n    *     1\n    * >>> countWrongEnvelopeCombinations(3)\n    *     2\n**/",
      "fr": "/**\n    * Calculer le nombre de façons dont une personne peut placer par erreur des lettres dans des enveloppes\n    * de sorte que chaque lettre se retrouve dans la mauvaise enveloppe.\n    *\n    * Ceci est basé sur un problème de dérangement où chaque élément (lettre) ne doit pas être\n    * dans sa position d'origine (enveloppe).\n    *\n    * Paramètres :\n    * n - le nombre de lettres et d'enveloppes.\n    *\n    * Renvoie :\n    * Le nombre total de façons de placer incorrectement toutes les lettres.\n    *\n    * Exemples :\n    * >>> countWrongEnvelopeCombinations(2)\n    *     1\n    * >>> countWrongEnvelopeCombinations(3)\n    *     2\n**/",
      "de": "/**\n    * Berechne die Anzahl der Möglichkeiten, wie eine Person Briefe fälschlicherweise in Umschläge stecken kann,\n    * sodass jeder Brief im falschen Umschlag landet.\n    *\n    * Dies basiert auf einem Problem der Fehlanordnung, bei dem jedes Element (Brief) nicht an seinem ursprünglichen\n    * Platz (Umschlag) sein darf.\n    *\n    * Parameter:\n    * n - die Anzahl der Briefe und Umschläge.\n    *\n    * Rückgabe:\n    * Die Gesamtanzahl der Möglichkeiten, alle Briefe falsch zu platzieren.\n    *\n    * Beispiele:\n    * >>> countWrongEnvelopeCombinations(2)\n    *     1\n    * >>> countWrongEnvelopeCombinations(3)\n    *     2\n**/",
      "ha": "/**\n    * Lissafa yawan hanyoyin da mutum zai iya kuskure wajen sanya wasiku a cikin kwantena\n    * ta yadda kowace wasika za ta kare a cikin kwantena mara kyau.\n    *\n    * Wannan yana dogara ne akan matsalar derangement inda kowace abu (wasika) ba dole ba ne\n    * ta kasance a matsayin ta na asali (kwantena).\n    *\n    * Sigogi:\n    * n - yawan wasiku da kwantena.\n    *\n    * Komawa:\n    * Jimillar yawan hanyoyin da za a iya sanya dukkan wasikun a cikin kwantena mara kyau.\n    *\n    * Misalai:\n    * >>> countWrongEnvelopeCombinations(2)\n    *     1\n    * >>> countWrongEnvelopeCombinations(3)\n    *     2\n**/",
      "hi": "/**\n    * गणना करें कि कितने तरीकों से एक व्यक्ति गलती से पत्रों को लिफाफों में डाल सकता है\n    * ताकि प्रत्येक पत्र गलत लिफाफे में समाप्त हो जाए।\n    *\n    * यह एक अव्यवस्था समस्या पर आधारित है जहाँ प्रत्येक वस्तु (पत्र) को\n    * उसकी मूल स्थिति (लिफाफा) में नहीं होना चाहिए।\n    *\n    * पैरामीटर्स:\n    * n - पत्रों और लिफाफों की संख्या।\n    *\n    * रिटर्न करता है:\n    * सभी पत्रों को गलत तरीके से रखने के कुल तरीकों की संख्या।\n    *\n    * उदाहरण:\n    * >>> countWrongEnvelopeCombinations(2)\n    *     1\n    * >>> countWrongEnvelopeCombinations(3)\n    *     2\n**/",
      "hu": "/**\n    * Számolja ki, hányféleképpen lehet egy személynek tévesen leveleket borítékokba helyezni\n    * úgy, hogy minden levél rossz borítékba kerüljön.\n    *\n    * Ez egy elrendezési probléma, ahol minden elemnek (levélnek) nem szabad\n    * az eredeti helyén (borítékban) lennie.\n    *\n    * Paraméterek:\n    * n - a levelek és borítékok száma.\n    *\n    * Visszatér:\n    * Az összes lehetséges mód, ahogyan helytelenül lehet elhelyezni az összes levelet.\n    *\n    * Példák:\n    * >>> countWrongEnvelopeCombinations(2)\n    *     1\n    * >>> countWrongEnvelopeCombinations(3)\n    *     2\n**/"
    },
    "prompt_bertscore": {
      "sq": "0.9660852528509601",
      "hy": "0.9582204829138837",
      "bn": "0.9448095554775512",
      "bg": "0.9587843945656417",
      "zh": "0.9460716529186468",
      "fr": "0.9639875173968506",
      "de": "0.9427398269071676",
      "ha": "0.9501046441751791",
      "hi": "0.9550821228935324",
      "hu": "0.9196526204587205"
    },
    "canonical_solution": "{\n    if (n == 1) return 0\n    if (n == 2) return 1\n\n    var a = 0L\n    var b = 1L\n    for (i in 3..n) {\n        val temp = (i - 1) * (a + b)\n        a = b\n        b = temp\n    }\n    return b\n}",
    "instruction": {
      "en": "Write a Kotlin function `fun countWrongEnvelopeCombinations(n: Int): Long` to solve the following problem:\nCalculate the number of ways a person can mistakenly put letters in envelopes\nsuch that each letter ends up in the wrong envelope.\n\nThis is based on a derangement problem where each item (letter) must not be\nin its original position (envelope).\n\nParameters:\nn - the number of letters and envelopes.\n\nReturns:\nThe total number of ways to wrongly place all the letters.\n\nExamples:\n>>> countWrongEnvelopeCombinations(2)\n1\n>>> countWrongEnvelopeCombinations(3)\n2",
      "sq": "Shkruani një funksion Kotlin `fun countWrongEnvelopeCombinations(n: Int): Long` për të zgjidhur problemin e mëposhtëm:\nLlogaritni numrin e mënyrave se si një person mund të vendosë gabimisht letra në zarfe\nnë mënyrë që secila letër të përfundojë në zarfin e gabuar.\n\nKjo bazohet në një problem të çrregullimit ku secili artikull (letër) nuk duhet të jetë\nnë pozicionin e tij origjinal (zarf).\n\nParametrat:\nn - numri i letrave dhe zarfeve.\n\nKthen:\nNumri total i mënyrave për të vendosur gabimisht të gjitha letrat.\n\nShembuj:\n>>> countWrongEnvelopeCombinations(2)\n1\n>>> countWrongEnvelopeCombinations(3)\n2",
      "hy": "Գրեք Kotlin ֆունկցիա `fun countWrongEnvelopeCombinations(n: Int): Long` հետևյալ խնդիրը լուծելու համար:\nՀաշվեք այն եղանակների քանակը, որոնց միջոցով մարդը կարող է սխալմամբ նամակները տեղադրել ծրարների մեջ այնպես, որ յուրաքանչյուր նամակ հայտնվի սխալ ծրարում:\n\nՍա հիմնված է անկարգության խնդրի վրա, որտեղ յուրաքանչյուր տարր (նամակ) չպետք է լինի իր սկզբնական դիրքում (ծրար):\n\nՊարամետրեր:\nn - նամակների և ծրարների քանակը:\n\nՎերադարձնում է:\nԱյն եղանակների ընդհանուր քանակը, որոնցով կարելի է սխալ տեղադրել բոլոր նամակները:\n\nՕրինակներ:\n>>> countWrongEnvelopeCombinations(2)\n1\n>>> countWrongEnvelopeCombinations(3)\n2",
      "bn": "Kotlin ফাংশন `fun countWrongEnvelopeCombinations(n: Int): Long` লিখুন নিম্নলিখিত সমস্যার সমাধানের জন্য:\nকতভাবে একজন ব্যক্তি ভুল করে চিঠিগুলি খামে রাখতে পারে তা গণনা করুন\nযাতে প্রতিটি চিঠি ভুল খামে শেষ হয়।\n\nএটি একটি ডিরেঞ্জমেন্ট সমস্যার উপর ভিত্তি করে যেখানে প্রতিটি আইটেম (চিঠি) অবশ্যই\nতার মূল অবস্থানে (খাম) থাকতে পারবে না।\n\nপ্যারামিটার:\nn - চিঠি এবং খামের সংখ্যা।\n\nরিটার্নস:\nসব চিঠি ভুলভাবে রাখার মোট সংখ্যা।\n\nউদাহরণ:\n>>> countWrongEnvelopeCombinations(2)\n1\n>>> countWrongEnvelopeCombinations(3)\n2",
      "bg": "Напишете функция на Kotlin `fun countWrongEnvelopeCombinations(n: Int): Long`, за да решите следния проблем:\nИзчислете броя на начините, по които човек може погрешно да постави писма в пликове,\nтака че всяко писмо да се окаже в грешен плик.\n\nТова се основава на проблем с дерaнгемент, при който всеки елемент (писмо) не трябва да бъде\nв първоначалната си позиция (плик).\n\nПараметри:\nn - броят на писмата и пликовете.\n\nВръща:\nОбщият брой начини за неправилно поставяне на всички писма.\n\nПримери:\n>>> countWrongEnvelopeCombinations(2)\n1\n>>> countWrongEnvelopeCombinations(3)\n2",
      "zh": "编写一个 Kotlin 函数 `fun countWrongEnvelopeCombinations(n: Int): Long` 来解决以下问题：  \n计算一个人错误地将信件放入信封的方式数量，使得每封信都放错信封。\n\n这是基于一个错排问题，其中每个项目（信件）都不能在其原始位置（信封）中。\n\n参数：  \nn - 信件和信封的数量。\n\n返回：  \n错误放置所有信件的总方式数量。\n\n示例：  \n>>> countWrongEnvelopeCombinations(2)  \n1  \n>>> countWrongEnvelopeCombinations(3)  \n2",
      "fr": "Écrire une fonction Kotlin `fun countWrongEnvelopeCombinations(n: Int): Long` pour résoudre le problème suivant :  \nCalculer le nombre de façons dont une personne peut mettre par erreur des lettres dans des enveloppes  \nde telle sorte que chaque lettre se retrouve dans la mauvaise enveloppe.\n\nCeci est basé sur un problème de dérangement où chaque élément (lettre) ne doit pas être  \ndans sa position d'origine (enveloppe).\n\nParamètres :  \nn - le nombre de lettres et d'enveloppes.\n\nRenvoie :  \nLe nombre total de façons de mal placer toutes les lettres.\n\nExemples :  \n>>> countWrongEnvelopeCombinations(2)  \n1  \n>>> countWrongEnvelopeCombinations(3)  \n2  ",
      "de": "Schreiben Sie eine Kotlin-Funktion `fun countWrongEnvelopeCombinations(n: Int): Long`, um das folgende Problem zu lösen:\nBerechnen Sie die Anzahl der Möglichkeiten, wie eine Person Briefe fälschlicherweise in Umschläge stecken kann,\nsodass jeder Brief im falschen Umschlag landet.\n\nDies basiert auf einem Problem der Fehlanordnung, bei dem jedes Element (Brief) nicht\nin seiner ursprünglichen Position (Umschlag) sein darf.\n\nParameter:\nn - die Anzahl der Briefe und Umschläge.\n\nRückgabe:\nDie Gesamtanzahl der Möglichkeiten, alle Briefe falsch zu platzieren.\n\nBeispiele:\n>>> countWrongEnvelopeCombinations(2)\n1\n>>> countWrongEnvelopeCombinations(3)\n2",
      "ha": "Rubuta aikin Kotlin `fun countWrongEnvelopeCombinations(n: Int): Long` don warware matsalar mai zuwa:  \nƘididdige yawan hanyoyin da mutum zai iya kuskuren sanya wasiƙu a cikin kwantena  \nta yadda kowace wasiƙa za ta ƙare a cikin kwantena mara kyau.\n\nWannan yana dogara ne akan matsalar derangement inda dole ne kowane abu (wasiƙa)  \nya kasance ba a matsayinsa na asali (kwantena).\n\nSigogi:  \nn - adadin wasiƙu da kwantena.\n\nDawowa:  \nJimlar yawan hanyoyin da za a sanya duk wasiƙun ba daidai ba.\n\nMisalai:  \n>>> countWrongEnvelopeCombinations(2)  \n1  \n>>> countWrongEnvelopeCombinations(3)  \n2  ",
      "hi": "Kotlin फ़ंक्शन `fun countWrongEnvelopeCombinations(n: Int): Long` लिखें ताकि निम्नलिखित समस्या का समाधान किया जा सके:\nगणना करें कि कितने तरीकों से एक व्यक्ति गलती से पत्रों को लिफाफों में डाल सकता है\nताकि प्रत्येक पत्र गलत लिफाफे में समाप्त हो जाए।\n\nयह एक विस्थापन समस्या पर आधारित है जहाँ प्रत्येक वस्तु (पत्र) को\nउसकी मूल स्थिति (लिफाफा) में नहीं होना चाहिए।\n\nपैरामीटर्स:\nn - पत्रों और लिफाफों की संख्या।\n\nवापसी:\nकुल तरीकों की संख्या जिससे सभी पत्रों को गलत तरीके से रखा जा सकता है।\n\nउदाहरण:\n>>> countWrongEnvelopeCombinations(2)\n1\n>>> countWrongEnvelopeCombinations(3)\n2",
      "hu": "Írj egy Kotlin függvényt `fun countWrongEnvelopeCombinations(n: Int): Long` a következő probléma megoldására:\nSzámítsd ki, hányféleképpen lehet egy személynek tévesen betenni a leveleket a borítékokba úgy, hogy minden levél rossz borítékba kerüljön.\n\nEz egy elrendezési probléma, ahol minden elemnek (levél) nem szabad az eredeti helyén (boríték) lennie.\n\nParaméterek:\nn - a levelek és borítékok száma.\n\nVisszatér:\nA levelek helytelen elhelyezésének összes lehetséges módja.\n\nPéldák:\n>>> countWrongEnvelopeCombinations(2)\n1\n>>> countWrongEnvelopeCombinations(3)\n2"
    },
    "instruction_bertscore": {
      "sq": "0.9942663354210469",
      "hy": "0.982316731697988",
      "bn": "0.9716977528974818",
      "bg": "0.9805560720004948",
      "zh": "0.9807515242954331",
      "fr": "0.9900668919052074",
      "de": "0.9744030986871771",
      "ha": "0.935591516754484",
      "hi": "0.9620459054222346",
      "hu": "0.9316649913821864"
    },
    "level": "easy",
    "test": "fun main() {\n    check(countWrongEnvelopeCombinations(2) == 1L)\n    check(countWrongEnvelopeCombinations(3) == 2L)\n    check(countWrongEnvelopeCombinations(4) == 9L) // Additional test case for 4 letters\n    check(countWrongEnvelopeCombinations(5) == 44L) // Additional test case for 5 letters\n    check(countWrongEnvelopeCombinations(15) == 481066515734L) // Additional test case for 15 letters\n}\nmain()",
    "entry_point": "countWrongEnvelopeCombinations",
    "signature": "fun countWrongEnvelopeCombinations(n: Int): Long",
    "docstring": {
      "en": "Calculate the number of ways a person can mistakenly put letters in envelopes\nsuch that each letter ends up in the wrong envelope.\n\nThis is based on a derangement problem where each item (letter) must not be\nin its original position (envelope).\n\nParameters:\nn - the number of letters and envelopes.\n\nReturns:\nThe total number of ways to wrongly place all the letters.\n\nExamples:\n>>> countWrongEnvelopeCombinations(2)\n1\n>>> countWrongEnvelopeCombinations(3)\n2",
      "sq": "Llogarit numrin e mënyrave se si një person mund të vendosë gabimisht letra në zarfe\nnë mënyrë që secila letër të përfundojë në zarfin e gabuar.\n\nKjo bazohet në një problem të çrregullimit ku secili artikull (letër) nuk duhet të jetë\nnë pozicionin e tij origjinal (zarf).\n\nParametrat:\nn - numri i letrave dhe zarfeve.\n\nKthen:\nNumri total i mënyrave për të vendosur gabimisht të gjitha letrat.\n\nShembuj:\n>>> countWrongEnvelopeCombinations(2)\n1\n>>> countWrongEnvelopeCombinations(3)\n2",
      "hy": "Հաշվել, թե քանի եղանակով մարդը կարող է սխալմամբ նամակները տեղադրել ծրարների մեջ այնպես, որ յուրաքանչյուր նամակ հայտնվի սխալ ծրարում:\n\nՍա հիմնված է դերանգման խնդրի վրա, որտեղ յուրաքանչյուր տարր (նամակ) չպետք է լինի իր սկզբնական դիրքում (ծրար):\n\nՊարամետրեր:\nn - նամակների և ծրարների քանակը:\n\nՎերադարձնում է:\nԲոլոր նամակները սխալ տեղադրելու եղանակների ընդհանուր քանակը:\n\nՕրինակներ:\n>>> countWrongEnvelopeCombinations(2)\n1\n>>> countWrongEnvelopeCombinations(3)\n2",
      "bn": "খামগুলিতে চিঠি ভুলভাবে রাখার উপায়ের সংখ্যা গণনা করুন\nযাতে প্রতিটি চিঠি ভুল খামে শেষ হয়।\n\nএটি একটি অব্যবস্থা সমস্যার উপর ভিত্তি করে যেখানে প্রতিটি আইটেম (চিঠি) অবশ্যই তার মূল অবস্থানে (খাম) থাকা উচিত নয়।\n\nপ্যারামিটার:\nn - চিঠি এবং খামের সংখ্যা।\n\nফেরত দেয়:\nসব চিঠি ভুলভাবে রাখার মোট উপায়ের সংখ্যা।\n\nউদাহরণ:\n>>> countWrongEnvelopeCombinations(2)\n1\n>>> countWrongEnvelopeCombinations(3)\n2",
      "bg": "Изчислете броя на начините, по които човек може погрешно да постави писма в пликове така, че всяко писмо да се окаже в грешен плик.\n\nТова се основава на задача за разместване, където всеки елемент (писмо) не трябва да бъде в първоначалната си позиция (плик).\n\nПараметри:\nn - броят на писмата и пликовете.\n\nВръща:\nОбщият брой начини за неправилно поставяне на всички писма.\n\nПримери:\n>>> countWrongEnvelopeCombinations(2)\n1\n>>> countWrongEnvelopeCombinations(3)\n2",
      "zh": "计算一个人错误地将信件放入信封的方式数量，使得每封信都放错信封。\n\n这是基于一个错排问题，其中每个项目（信件）都不能在其原始位置（信封）中。\n\n参数：\nn - 信件和信封的数量。\n\n返回：\n错误放置所有信件的总方式数量。\n\n示例：\n>>> countWrongEnvelopeCombinations(2)\n1\n>>> countWrongEnvelopeCombinations(3)\n2",
      "fr": "Calculer le nombre de façons dont une personne peut mettre par erreur des lettres dans des enveloppes\nde telle sorte que chaque lettre se retrouve dans la mauvaise enveloppe.\n\nCeci est basé sur un problème de dérangement où chaque élément (lettre) ne doit pas être\ndans sa position d'origine (enveloppe).\n\nParamètres:\nn - le nombre de lettres et d'enveloppes.\n\nRenvoie:\nLe nombre total de façons de placer incorrectement toutes les lettres.\n\nExemples:\n>>> countWrongEnvelopeCombinations(2)\n1\n>>> countWrongEnvelopeCombinations(3)\n2",
      "de": "Berechne die Anzahl der Möglichkeiten, wie eine Person fälschlicherweise Briefe in Umschläge stecken kann, sodass jeder Brief im falschen Umschlag landet.\n\nDies basiert auf einem Problem der Fehlanordnung, bei dem jedes Element (Brief) nicht an seiner ursprünglichen Position (Umschlag) sein darf.\n\nParameter:\nn - die Anzahl der Briefe und Umschläge.\n\nRückgabewert:\nDie Gesamtanzahl der Möglichkeiten, alle Briefe falsch zu platzieren.\n\nBeispiele:\n>>> countWrongEnvelopeCombinations(2)\n1\n>>> countWrongEnvelopeCombinations(3)\n2",
      "ha": "Ƙididdige yawan hanyoyin da mutum zai iya kuskure wajen sanya wasiƙu a cikin ambulan\nta yadda kowace wasiƙa za ta ƙare a cikin ambulan da ba daidai ba.\n\nWannan yana dogara ne akan matsalar derangement inda dole ne kowace abu (wasiƙa) ba za ta kasance a cikin matsayinta na asali ba (ambulan).\n\nSigogi:\nn - yawan wasiƙu da ambulan.\n\nDawowa:\nJimillar yawan hanyoyin da za a sanya duk wasiƙun da ba daidai ba.\n\nMisalai:\n>>> countWrongEnvelopeCombinations(2)\n1\n>>> countWrongEnvelopeCombinations(3)\n2",
      "hi": "गणना करें कि कितने तरीकों से एक व्यक्ति गलती से पत्रों को लिफाफों में डाल सकता है\nताकि प्रत्येक पत्र गलत लिफाफे में समाप्त हो जाए।\n\nयह एक विस्थापन समस्या पर आधारित है जहाँ प्रत्येक वस्तु (पत्र) अपने मूल स्थान (लिफाफा) में नहीं होनी चाहिए।\n\nParameters:\nn - पत्रों और लिफाफों की संख्या।\n\nReturns:\nसभी पत्रों को गलत तरीके से रखने के कुल तरीके।\n\nExamples:\n>>> countWrongEnvelopeCombinations(2)\n1\n>>> countWrongEnvelopeCombinations(3)\n2",
      "hu": "Számítsa ki, hányféleképpen tehet egy személy hibásan leveleket borítékokba úgy, hogy minden levél rossz borítékba kerüljön.\n\nEz egy elrendezési probléma, ahol minden elemnek (levélnek) nem szabad az eredeti helyén (borítékban) lennie.\n\nParaméterek:\nn - a levelek és borítékok száma.\n\nVisszatér:\nA levelek hibás elhelyezésének összes lehetséges módja.\n\nPéldák:\n>>> countWrongEnvelopeCombinations(2)\n1\n>>> countWrongEnvelopeCombinations(3)\n2"
    },
    "docstring_bertscore": {
      "sq": "0.9932024711002241",
      "hy": "0.983591938744232",
      "bn": "0.9554088698703348",
      "bg": "0.9866331685082572",
      "zh": "0.971151717980017",
      "fr": "0.9933554164936209",
      "de": "0.9812894153672757",
      "ha": "0.9748939143587143",
      "hi": "0.9727389733548668",
      "hu": "0.9310516207655507"
    }
  },
  {
    "task_id": "Kotlin/23",
    "prompt": {
      "en": "/**\n * Calculates the number of ways to exchange a given amount of money (more than 10 units) into 5, 2, and 1 unit denominations.\n * It is required that all three denominations are used in the exchange.\n * Example:\n * >>> countExchangeWays(50)\n *     106\n * >>> countExchangeWays(20)\n *     13\n */\n\nfun countExchangeWays(amount: Int): Int ",
      "sq": "/**\n * Llogarit numrin e mënyrave për të shkëmbyer një shumë të caktuar parash (më shumë se 10 njësi) në denominime prej 5, 2, dhe 1 njësi.\n * Kërkohet që të përdoren të tre denominimet në shkëmbim.\n * Shembull:\n * >>> countExchangeWays(50)\n *     106\n * >>> countExchangeWays(20)\n *     13\n */",
      "hy": "/**\n * Հաշվում է գումարի փոխանակման եղանակների քանակը (ավելի քան 10 միավոր) 5, 2 և 1 միավորանոց անվանական արժեքներով:\n * Պահանջվում է, որ փոխանակման մեջ օգտագործվեն բոլոր երեք անվանական արժեքները:\n * Օրինակ:\n * >>> countExchangeWays(50)\n *     106\n * >>> countExchangeWays(20)\n *     13\n */",
      "bn": "/**\n * একটি নির্দিষ্ট পরিমাণ অর্থ (১০ ইউনিটের বেশি) ৫, ২, এবং ১ ইউনিটের মুদ্রায় বিনিময় করার উপায়ের সংখ্যা গণনা করে।\n * এটি প্রয়োজন যে বিনিময়ে সব তিনটি মুদ্রা ব্যবহার করা হয়।\n * উদাহরণ:\n * >>> countExchangeWays(50)\n *     106\n * >>> countExchangeWays(20)\n *     13\n */",
      "bg": "/**\n * Изчислява броя начини за обмен на дадена сума пари (повече от 10 единици) в номинали от 5, 2 и 1 единица.\n * Изисква се всички три номинала да бъдат използвани в обмена.\n * Пример:\n * >>> countExchangeWays(50)\n *     106\n * >>> countExchangeWays(20)\n *     13\n */",
      "zh": "/**\n * 计算将给定金额（超过10单位）兑换为5、2和1单位面额的方法数量。\n * 要求在兑换中使用所有三种面额。\n * 示例：\n * >>> countExchangeWays(50)\n *     106\n * >>> countExchangeWays(20)\n *     13\n */",
      "fr": "/**\n * Calcule le nombre de façons d'échanger un montant donné d'argent (plus de 10 unités) en dénominations de 5, 2 et 1 unité.\n * Il est requis que les trois dénominations soient utilisées dans l'échange.\n * Exemple:\n * >>> countExchangeWays(50)\n *     106\n * >>> countExchangeWays(20)\n *     13\n */",
      "de": "/**\n * Berechnet die Anzahl der Möglichkeiten, einen gegebenen Geldbetrag (mehr als 10 Einheiten) in 5-, 2- und 1-Einheiten umzutauschen.\n * Es ist erforderlich, dass alle drei Stückelungen im Umtausch verwendet werden.\n * Beispiel:\n * >>> countExchangeWays(50)\n *     106\n * >>> countExchangeWays(20)\n *     13\n */",
      "ha": "/**\n * Lissafa yawan hanyoyin da za a iya musanya wani adadin kudi (fiye da raka'a 10) zuwa cikin raka'a 5, 2, da 1.\n * Ana bukatar a yi amfani da dukkanin raka'o'i uku a cikin musayar.\n * Misali:\n * >>> countExchangeWays(50)\n *     106\n * >>> countExchangeWays(20)\n *     13\n */",
      "hi": "/**\n * एक दिए गए राशि (10 इकाइयों से अधिक) को 5, 2, और 1 इकाई के मूल्यवर्ग में बदलने के तरीकों की संख्या की गणना करता है।\n * यह आवश्यक है कि विनिमय में सभी तीन मूल्यवर्गों का उपयोग किया जाए।\n * उदाहरण:\n * >>> countExchangeWays(50)\n *     106\n * >>> countExchangeWays(20)\n *     13\n */",
      "hu": "/**\n * Kiszámítja, hogy hányféleképpen lehet egy adott pénzösszeget (több mint 10 egység) 5, 2 és 1 egységnyi címletekre váltani.\n * Szükséges, hogy mindhárom címletet használjuk a váltás során.\n * Példa:\n * >>> countExchangeWays(50)\n *     106\n * >>> countExchangeWays(20)\n *     13\n */\n\nfun countExchangeWays(amount: Int): Int "
    },
    "prompt_bertscore": {
      "sq": "0.9317231900838296",
      "hy": "0.918767324850448",
      "bn": "0.910580575065714",
      "bg": "0.9453798233015023",
      "zh": "0.9310393056819265",
      "fr": "0.9453798233015023",
      "de": "0.944871329526053",
      "ha": "0.90065680259883",
      "hi": "0.9425703951921448",
      "hu": "0.9412908182775181"
    },
    "canonical_solution": "{\n    var ways = 0\n    for (fives in 1..amount / 5) {\n        for (twos in 1..amount / 2) {\n            for (ones in 1..amount) {\n                if (fives * 5 + twos * 2 + ones == amount) {\n                    ways++\n                }\n            }\n        }\n    }\n    return ways\n}",
    "instruction": {
      "en": "Write a Kotlin function `fun countExchangeWays(amount: Int): Int` to solve the following problem:\nCalculates the number of ways to exchange a given amount of money (more than 10 units) into 5, 2, and 1 unit denominations.\nIt is required that all three denominations are used in the exchange.\nExample:\n>>> countExchangeWays(50)\n106\n>>> countExchangeWays(20)\n13",
      "sq": "Shkruani një funksion Kotlin `fun countExchangeWays(amount: Int): Int` për të zgjidhur problemin e mëposhtëm:  \nLlogarit numrin e mënyrave për të shkëmbyer një shumë të caktuar parash (më shumë se 10 njësi) në denominime prej 5, 2, dhe 1 njësi.  \nKërkohet që të përdoren të tre denominimet në shkëmbim.  \nShembull:  \n>>> countExchangeWays(50)  \n106  \n>>> countExchangeWays(20)  \n13",
      "hy": "Գրեք Kotlin ֆունկցիա `fun countExchangeWays(amount: Int): Int` հետևյալ խնդիրը լուծելու համար:\nՀաշվում է, թե քանի եղանակով կարելի է փոխանակել տրված գումարը (ավելի քան 10 միավոր) 5, 2 և 1 միավոր անվանական արժեքներով:\nՊահանջվում է, որ փոխանակման մեջ օգտագործվեն բոլոր երեք անվանական արժեքները:\nՕրինակ:\n>>> countExchangeWays(50)\n106\n>>> countExchangeWays(20)\n13",
      "bn": "একটি Kotlin ফাংশন `fun countExchangeWays(amount: Int): Int` লিখুন নিম্নলিখিত সমস্যার সমাধানের জন্য:\nএকটি নির্দিষ্ট পরিমাণ অর্থ (১০ ইউনিটের বেশি) ৫, ২, এবং ১ ইউনিটের মুদ্রায় বিনিময় করার উপায়ের সংখ্যা গণনা করে।\nএটি প্রয়োজন যে বিনিময়ে সব তিনটি মুদ্রা ব্যবহার করা হয়।\nউদাহরণ:\n>>> countExchangeWays(50)\n106\n>>> countExchangeWays(20)\n13",
      "bg": "Напишете Kotlin функция `fun countExchangeWays(amount: Int): Int`, за да решите следния проблем:\nИзчислява броя на начините за обмен на дадена сума пари (повече от 10 единици) в номинали от 5, 2 и 1 единици.\nИзисква се всички три номинала да бъдат използвани в обмена.\nПример:\n>>> countExchangeWays(50)\n106\n>>> countExchangeWays(20)\n13",
      "zh": "编写一个 Kotlin 函数 `fun countExchangeWays(amount: Int): Int` 来解决以下问题：\n计算将给定金额（超过 10 单位）兑换成 5、2 和 1 单位面额的方法数。\n要求在兑换中使用所有三种面额。\n示例:",
      "fr": "Écrire une fonction Kotlin `fun countExchangeWays(amount: Int): Int` pour résoudre le problème suivant :\nCalcule le nombre de façons d'échanger un montant donné d'argent (plus de 10 unités) en dénominations de 5, 2 et 1 unité.\nIl est requis que les trois dénominations soient utilisées dans l'échange.\nExemple :",
      "de": "Schreiben Sie eine Kotlin-Funktion `fun countExchangeWays(amount: Int): Int`, um das folgende Problem zu lösen:\nBerechnet die Anzahl der Möglichkeiten, einen gegebenen Geldbetrag (mehr als 10 Einheiten) in 5-, 2- und 1-Einheiten-Stückelungen zu tauschen.\nEs ist erforderlich, dass alle drei Stückelungen im Austausch verwendet werden.\nBeispiel:\n>>> countExchangeWays(50)\n106\n>>> countExchangeWays(20)\n13",
      "ha": "Rubuta aikin Kotlin `fun countExchangeWays(amount: Int): Int` don warware matsalar mai zuwa:\nLissafa yawan hanyoyin musayar adadin kudi da aka bayar (fiye da raka'a 10) cikin rabe-raben raka'a 5, 2, da 1.\nAna buƙatar cewa a yi amfani da dukkan rabe-raben uku a cikin musayar.\nMisali:\n>>> countExchangeWays(50)\n106\n>>> countExchangeWays(20)\n13",
      "hi": "Kotlin फ़ंक्शन `fun countExchangeWays(amount: Int): Int` लिखें ताकि निम्नलिखित समस्या का समाधान किया जा सके:\nदिए गए धनराशि (10 इकाइयों से अधिक) को 5, 2, और 1 इकाई के मूल्यवर्ग में बदलने के तरीकों की संख्या की गणना करता है।\nयह आवश्यक है कि विनिमय में सभी तीन मूल्यवर्ग का उपयोग किया जाए।\nउदाहरण:\n>>> countExchangeWays(50)\n106\n>>> countExchangeWays(20)\n13",
      "hu": "Írj egy Kotlin függvényt `fun countExchangeWays(amount: Int): Int` a következő probléma megoldására:\nKiszámítja, hogy hányféleképpen lehet egy adott pénzösszeget (több mint 10 egység) 5, 2 és 1 egységnyi címletekre váltani.\nSzükséges, hogy mindhárom címletet használjuk a váltás során.\nPélda:\n>>> countExchangeWays(50)\n106\n>>> countExchangeWays(20)\n13"
    },
    "instruction_bertscore": {
      "sq": "0.9715316978989367",
      "hy": "0.9550286913210341",
      "bn": "0.955079540698579",
      "bg": "0.9878181973615113",
      "zh": "0.9120013781812566",
      "fr": "0.9208581082412213",
      "de": "0.9926335936889401",
      "ha": "0.9105074790854932",
      "hi": "0.9602908073754103",
      "hu": "0.9702606620906945"
    },
    "level": "easy",
    "test": "fun main(){\n\n    check(countExchangeWays(50) == 106)\n    check(countExchangeWays(20) == 13)\n    check(countExchangeWays(15) == 6)\n    check(countExchangeWays(12) == 3)\n\n}\n\nmain()",
    "entry_point": "countExchangeWays",
    "signature": "fun countExchangeWays(amount: Int): Int",
    "docstring": {
      "en": "Calculates the number of ways to exchange a given amount of money (more than 10 units) into 5, 2, and 1 unit denominations.\nIt is required that all three denominations are used in the exchange.\nExample:\n>>> countExchangeWays(50)\n106\n>>> countExchangeWays(20)\n13",
      "sq": "Llogarit numrin e mënyrave për të shkëmbyer një shumë të caktuar parash (më shumë se 10 njësi) në denominime prej 5, 2 dhe 1 njësi. \nKërkohet që të përdoren të tre denominimet në shkëmbim.\nShembull:\n>>> countExchangeWays(50)\n106\n>>> countExchangeWays(20)\n13",
      "hy": "Հաշվում է, թե քանի եղանակով կարելի է փոխանակել տրված գումարը (ավելի քան 10 միավոր) 5, 2 և 1 միավոր անվանական արժեքներով:\nՊահանջվում է, որ փոխանակման մեջ օգտագործվեն բոլոր երեք անվանական արժեքները:\nՕրինակ:\n>>> countExchangeWays(50)\n106\n>>> countExchangeWays(20)\n13",
      "bn": "একটি নির্দিষ্ট পরিমাণ অর্থ (১০ ইউনিটের বেশি) ৫, ২, এবং ১ ইউনিটের মুদ্রায় বিনিময় করার উপায়গুলির সংখ্যা গণনা করে। বিনিময়ে সমস্ত তিনটি মুদ্রার ব্যবহার প্রয়োজন।\n\nউদাহরণ:\n>>> countExchangeWays(50)\n106\n>>> countExchangeWays(20)\n13",
      "bg": "Изчислява броя на начините за обмен на дадена сума пари (повече от 10 единици) в номинали от 5, 2 и 1 единица. Изисква се и трите номинала да бъдат използвани в обмена.\nПример:\n>>> countExchangeWays(50)\n106\n>>> countExchangeWays(20)\n13",
      "zh": "计算将给定金额（超过10个单位）兑换成5、2和1单位面额的方法数。要求在兑换中使用所有三种面额。\n\n示例：\n>>> countExchangeWays(50)\n106\n>>> countExchangeWays(20)\n13",
      "fr": "Calcule le nombre de façons d'échanger une somme d'argent donnée (plus de 10 unités) en dénominations de 5, 2 et 1 unité.\nIl est nécessaire que les trois dénominations soient utilisées dans l'échange.\nExemple :\n>>> countExchangeWays(50)\n106\n>>> countExchangeWays(20)\n13",
      "de": "Berechnet die Anzahl der Möglichkeiten, einen gegebenen Geldbetrag (mehr als 10 Einheiten) in 5-, 2- und 1-Einheiten-Denominationen zu tauschen.\nEs ist erforderlich, dass alle drei Denominationen im Austausch verwendet werden.\nBeispiel:\n>>> countExchangeWays(50)\n106\n>>> countExchangeWays(20)\n13",
      "ha": "Yana ƙididdige adadin hanyoyin musayar adadin kuɗi da aka bayar (fiye da raka'a 10) zuwa cikin raka'a 5, 2, da 1.\nAna buƙatar a yi amfani da dukkanin raka'a uku a cikin musayar.\nMisali:\n>>> countExchangeWays(50)\n106\n>>> countExchangeWays(20)\n13",
      "hi": "दिए गए धनराशि (10 इकाइयों से अधिक) को 5, 2, और 1 इकाई के मूल्यवर्ग में बदलने के तरीकों की संख्या की गणना करता है। यह आवश्यक है कि विनिमय में सभी तीन मूल्यवर्गों का उपयोग किया जाए।\n\nउदाहरण:\n>>> countExchangeWays(50)\n106\n>>> countExchangeWays(20)\n13",
      "hu": "Kiszámítja, hányféleképpen lehet egy adott pénzösszeget (több mint 10 egység) 5, 2 és 1 egységnyi címletekre váltani.\nSzükséges, hogy mindhárom címletet használják a váltás során.\nPélda:\n>>> countExchangeWays(50)\n106\n>>> countExchangeWays(20)\n13"
    },
    "docstring_bertscore": {
      "sq": "0.9631778999637525",
      "hy": "0.9642858602291651",
      "bn": "0.8842872756369827",
      "bg": "0.9820283203847254",
      "zh": "0.9598091287014007",
      "fr": "0.9742912697826545",
      "de": "0.97584316894968",
      "ha": "0.9261192311436923",
      "hi": "0.9663168558752467",
      "hu": "0.9868022029625179"
    }
  },
  {
    "task_id": "Kotlin/24",
    "prompt": {
      "en": "/**\n    * Adds two times together. Each time is represented as a Triple of hours, minutes, and seconds.\n    * Hours, minutes, and seconds are normalized to ensure minutes and seconds are within 0 to 59.\n    * \n    * Example:\n    * >>> addTimes(Triple(1, 2, 3), Triple(4, 5, 6))\n    *     Triple(5, 7, 9)\n    * >>> addTimes(Triple(23, 59, 59), Triple(0, 0, 1))\n    *     Triple(24, 0, 0)\n**/\nfun addTimes(timeA: Triple<Int, Int, Int>, timeB: Triple<Int, Int, Int>): Triple<Int, Int, Int> ",
      "sq": "/**\n    * Shton dy kohëra së bashku. Çdo kohë përfaqësohet si një Triple e orëve, minutave dhe sekondave.\n    * Orët, minutat dhe sekondat janë të normalizuara për të siguruar që minutat dhe sekondat janë brenda 0 deri në 59.\n    * \n    * Shembull:\n    * >>> addTimes(Triple(1, 2, 3), Triple(4, 5, 6))\n    *     Triple(5, 7, 9)\n    * >>> addTimes(Triple(23, 59, 59), Triple(0, 0, 1))\n    *     Triple(24, 0, 0)\n**/",
      "hy": "/**\n    * Գումարում է երկու ժամանակներ: Յուրաքանչյուր ժամանակ ներկայացված է ժամերի, րոպեների և վայրկյանների եռյակով:\n    * Ժամերը, րոպեները և վայրկյանները նորմալացվում են՝ ապահովելու համար, որ րոպեները և վայրկյանները լինեն 0-ից 59-ի սահմաններում:\n    * \n    * Օրինակ:\n    * >>> addTimes(Triple(1, 2, 3), Triple(4, 5, 6))\n    *     Triple(5, 7, 9)\n    * >>> addTimes(Triple(23, 59, 59), Triple(0, 0, 1))\n    *     Triple(24, 0, 0)\n**/",
      "bn": "/**\n    * দুটি সময় একসাথে যোগ করে। প্রতিটি সময় ঘন্টা, মিনিট এবং সেকেন্ডের Triple হিসেবে উপস্থাপিত হয়।\n    * ঘন্টা, মিনিট এবং সেকেন্ডকে স্বাভাবিকীকৃত করা হয় যাতে মিনিট এবং সেকেন্ড 0 থেকে 59 এর মধ্যে থাকে।\n    * \n    * উদাহরণ:\n    * >>> addTimes(Triple(1, 2, 3), Triple(4, 5, 6))\n    *     Triple(5, 7, 9)\n    * >>> addTimes(Triple(23, 59, 59), Triple(0, 0, 1))\n    *     Triple(24, 0, 0)\n**/",
      "bg": "/**\n    * Събира две времена. Всяко време е представено като Triple от часове, минути и секунди.\n    * Часовете, минутите и секундите са нормализирани, за да се гарантира, че минутите и секундите са в диапазона от 0 до 59.\n    * \n    * Пример:\n    * >>> addTimes(Triple(1, 2, 3), Triple(4, 5, 6))\n    *     Triple(5, 7, 9)\n    * >>> addTimes(Triple(23, 59, 59), Triple(0, 0, 1))\n    *     Triple(24, 0, 0)\n**/",
      "zh": "/**\n    * 将两个时间相加。每个时间表示为小时、分钟和秒的三元组。\n    * 小时、分钟和秒被规范化以确保分钟和秒在0到59之间。\n    * \n    * 示例:\n    * >>> addTimes(Triple(1, 2, 3), Triple(4, 5, 6))\n    *     Triple(5, 7, 9)\n    * >>> addTimes(Triple(23, 59, 59), Triple(0, 0, 1))\n    *     Triple(24, 0, 0)\n**/",
      "fr": "/**\n    * Ajoute deux temps ensemble. Chaque temps est représenté comme un Triple d'heures, de minutes et de secondes.\n    * Les heures, minutes et secondes sont normalisées pour s'assurer que les minutes et les secondes sont comprises entre 0 et 59.\n    * \n    * Exemple:\n    * >>> addTimes(Triple(1, 2, 3), Triple(4, 5, 6))\n    *     Triple(5, 7, 9)\n    * >>> addTimes(Triple(23, 59, 59), Triple(0, 0, 1))\n    *     Triple(24, 0, 0)\n**/",
      "de": "/**\n    * Addiert zwei Zeiten miteinander. Jede Zeit wird als Triple von Stunden, Minuten und Sekunden dargestellt.\n    * Stunden, Minuten und Sekunden werden normalisiert, um sicherzustellen, dass Minuten und Sekunden zwischen 0 und 59 liegen.\n    * \n    * Beispiel:\n    * >>> addTimes(Triple(1, 2, 3), Triple(4, 5, 6))\n    *     Triple(5, 7, 9)\n    * >>> addTimes(Triple(23, 59, 59), Triple(0, 0, 1))\n    *     Triple(24, 0, 0)\n**/",
      "ha": "/**\n    * Ƙara lokuta biyu tare. Kowane lokaci ana wakilta shi azaman Triple na awanni, mintuna, da dakiku.\n    * Ana daidaita awanni, mintuna, da dakiku don tabbatar da cewa mintuna da dakiku suna tsakanin 0 zuwa 59.\n    * \n    * Misali:\n    * >>> addTimes(Triple(1, 2, 3), Triple(4, 5, 6))\n    *     Triple(5, 7, 9)\n    * >>> addTimes(Triple(23, 59, 59), Triple(0, 0, 1))\n    *     Triple(24, 0, 0)\n**/",
      "hi": "/**\n    * दो समयों को एक साथ जोड़ता है। प्रत्येक समय को घंटों, मिनटों और सेकंडों के Triple के रूप में दर्शाया गया है।\n    * घंटों, मिनटों और सेकंडों को सामान्यीकृत किया जाता है ताकि मिनट और सेकंड 0 से 59 के बीच हों।\n    * \n    * उदाहरण:\n    * >>> addTimes(Triple(1, 2, 3), Triple(4, 5, 6))\n    *     Triple(5, 7, 9)\n    * >>> addTimes(Triple(23, 59, 59), Triple(0, 0, 1))\n    *     Triple(24, 0, 0)\n**/",
      "hu": "/**\n    * Két időpontot ad össze. Minden időpont egy órákból, percekből és másodpercekből álló Triple-ként van ábrázolva.\n    * Az órák, percek és másodpercek normalizálva vannak annak biztosítására, hogy a percek és másodpercek 0 és 59 között legyenek.\n    * \n    * Példa:\n    * >>> addTimes(Triple(1, 2, 3), Triple(4, 5, 6))\n    *     Triple(5, 7, 9)\n    * >>> addTimes(Triple(23, 59, 59), Triple(0, 0, 1))\n    *     Triple(24, 0, 0)\n**/"
    },
    "prompt_bertscore": {
      "sq": "0.9260614297028111",
      "hy": "0.8985606561877688",
      "bn": "0.9185589615807424",
      "bg": "0.9009557413222875",
      "zh": "0.9127678928216703",
      "fr": "0.9214675062502362",
      "de": "0.9192470172206473",
      "ha": "0.9142828467378233",
      "hi": "0.9185589615807424",
      "hu": "0.8910558045011276"
    },
    "canonical_solution": "{\n    var (hours, minutes, seconds) = timeA\n\n    seconds += timeB.third\n    if (seconds >= 60) {\n        minutes += 1\n        seconds -= 60\n    }\n\n    minutes += timeB.second\n    if (minutes >= 60) {\n        hours += 1\n        minutes -= 60\n    }\n\n    hours += timeB.first\n\n    return Triple(hours, minutes, seconds)\n}",
    "instruction": {
      "en": "Write a Kotlin function `fun addTimes(timeA: Triple<Int, Int, Int>, timeB: Triple<Int, Int, Int>): Triple<Int, Int, Int>` to solve the following problem:\nAdds two times together. Each time is represented as a Triple of hours, minutes, and seconds.\nHours, minutes, and seconds are normalized to ensure minutes and seconds are within 0 to 59.\n\nExample:\n>>> addTimes(Triple(1, 2, 3), Triple(4, 5, 6))\nTriple(5, 7, 9)\n>>> addTimes(Triple(23, 59, 59), Triple(0, 0, 1))\nTriple(24, 0, 0)",
      "sq": "Shkruani një funksion Kotlin `fun addTimes(timeA: Triple<Int, Int, Int>, timeB: Triple<Int, Int, Int>): Triple<Int, Int, Int>` për të zgjidhur problemin e mëposhtëm:\nShton dy kohë së bashku. Çdo kohë përfaqësohet si një Triple e orëve, minutave dhe sekondave.\nOrët, minutat dhe sekondat janë të normalizuara për të siguruar që minutat dhe sekondat të jenë brenda 0 deri në 59.\n\nShembull:\n>>> addTimes(Triple(1, 2, 3), Triple(4, 5, 6))\nTriple(5, 7, 9)\n>>> addTimes(Triple(23, 59, 59), Triple(0, 0, 1))\nTriple(24, 0, 0)",
      "hy": "Գրեք Kotlin ֆունկցիա `fun addTimes(timeA: Triple<Int, Int, Int>, timeB: Triple<Int, Int, Int>): Triple<Int, Int, Int>` հետևյալ խնդիրը լուծելու համար:\nԱվելացնում է երկու ժամանակներ իրար: Յուրաքանչյուր ժամանակ ներկայացված է որպես ժամերի, րոպեների և վայրկյանների Triple:\nԺամերը, րոպեները և վայրկյանները նորմալացվում են, որպեսզի րոպեները և վայրկյանները լինեն 0-ից 59 միջակայքում:\n\nՕրինակ:\n>>> addTimes(Triple(1, 2, 3), Triple(4, 5, 6))\nTriple(5, 7, 9)\n>>> addTimes(Triple(23, 59, 59), Triple(0, 0, 1))\nTriple(24, 0, 0)",
      "bn": "একটি Kotlin ফাংশন `fun addTimes(timeA: Triple<Int, Int, Int>, timeB: Triple<Int, Int, Int>): Triple<Int, Int, Int>` লিখুন নিম্নলিখিত সমস্যার সমাধানের জন্য:\nদুটি সময় একত্রিত করে যোগ করে। প্রতিটি সময় ঘন্টা, মিনিট এবং সেকেন্ডের Triple হিসাবে উপস্থাপিত হয়।\nঘন্টা, মিনিট এবং সেকেন্ডকে স্বাভাবিকীকরণ করা হয় যাতে মিনিট এবং সেকেন্ড 0 থেকে 59 এর মধ্যে থাকে।",
      "bg": "Напишете Kotlin функция `fun addTimes(timeA: Triple<Int, Int, Int>, timeB: Triple<Int, Int, Int>): Triple<Int, Int, Int>` за решаване на следния проблем:\nСъбира два момента във времето. Всеки момент е представен като Triple от часове, минути и секунди.\nЧасовете, минутите и секундите са нормализирани, за да се гарантира, че минутите и секундите са в диапазона от 0 до 59.\n\nПример:\n>>> addTimes(Triple(1, 2, 3), Triple(4, 5, 6))\nTriple(5, 7, 9)\n>>> addTimes(Triple(23, 59, 59), Triple(0, 0, 1))\nTriple(24, 0, 0)",
      "zh": "编写一个 Kotlin 函数 `fun addTimes(timeA: Triple<Int, Int, Int>, timeB: Triple<Int, Int, Int>): Triple<Int, Int, Int>` 来解决以下问题：\n将两个时间相加。每个时间表示为一个包含小时、分钟和秒的 Triple。\n小时、分钟和秒被规范化以确保分钟和秒在 0 到 59 之间。\n\n示例:\n>>> addTimes(Triple(1, 2, 3), Triple(4, 5, 6))\nTriple(5, 7, 9)\n>>> addTimes(Triple(23, 59, 59), Triple(0, 0, 1))\nTriple(24, 0, 0)",
      "fr": "Écrire une fonction Kotlin `fun addTimes(timeA: Triple<Int, Int, Int>, timeB: Triple<Int, Int, Int>): Triple<Int, Int, Int>` pour résoudre le problème suivant :\nAjoute deux temps ensemble. Chaque temps est représenté comme un Triple d'heures, de minutes et de secondes.\nLes heures, minutes et secondes sont normalisées pour s'assurer que les minutes et secondes sont comprises entre 0 et 59.\n\nExemple :\n>>> addTimes(Triple(1, 2, 3), Triple(4, 5, 6))\nTriple(5, 7, 9)\n>>> addTimes(Triple(23, 59, 59), Triple(0, 0, 1))\nTriple(24, 0, 0)",
      "de": "Schreiben Sie eine Kotlin-Funktion `fun addTimes(timeA: Triple<Int, Int, Int>, timeB: Triple<Int, Int, Int>): Triple<Int, Int, Int>`, um das folgende Problem zu lösen:\nAddiert zwei Zeiten miteinander. Jede Zeit wird als Triple von Stunden, Minuten und Sekunden dargestellt.\nStunden, Minuten und Sekunden werden normalisiert, um sicherzustellen, dass Minuten und Sekunden im Bereich von 0 bis 59 liegen.\n\nBeispiel:\n>>> addTimes(Triple(1, 2, 3), Triple(4, 5, 6))\nTriple(5, 7, 9)\n>>> addTimes(Triple(23, 59, 59), Triple(0, 0, 1))\nTriple(24, 0, 0)",
      "ha": "Rubuta wani aikin Kotlin `fun addTimes(timeA: Triple<Int, Int, Int>, timeB: Triple<Int, Int, Int>): Triple<Int, Int, Int>` don warware matsalar mai zuwa:\nƘara lokuta biyu tare. Kowanne lokaci an wakilta shi azaman Triple na awanni, mintuna, da dakiku.\nAwanni, mintuna, da dakiku an daidaita su don tabbatar da cewa mintuna da dakiku suna tsakanin 0 zuwa 59.\n\nMisali:\n>>> addTimes(Triple(1, 2, 3), Triple(4, 5, 6))\nTriple(5, 7, 9)\n>>> addTimes(Triple(23, 59, 59), Triple(0, 0, 1))\nTriple(24, 0, 0)",
      "hi": "Kotlin फ़ंक्शन `fun addTimes(timeA: Triple<Int, Int, Int>, timeB: Triple<Int, Int, Int>): Triple<Int, Int, Int>` लिखें ताकि निम्नलिखित समस्या का समाधान किया जा सके:\nदो समय को एक साथ जोड़ता है। प्रत्येक समय को घंटों, मिनटों और सेकंडों के Triple के रूप में दर्शाया गया है।\nघंटे, मिनट और सेकंड को सामान्यीकृत किया जाता है ताकि मिनट और सेकंड 0 से 59 के भीतर हों।\n\nउदाहरण:\n>>> addTimes(Triple(1, 2, 3), Triple(4, 5, 6))\nTriple(5, 7, 9)\n>>> addTimes(Triple(23, 59, 59), Triple(0, 0, 1))\nTriple(24, 0, 0)",
      "hu": "Írj egy Kotlin függvényt `fun addTimes(timeA: Triple<Int, Int, Int>, timeB: Triple<Int, Int, Int>): Triple<Int, Int, Int>` a következő probléma megoldására:\nKét időpontot ad össze. Minden időpont egy órákból, percekből és másodpercekből álló Triple-ként van ábrázolva.\nAz órák, percek és másodpercek normalizálva vannak annak biztosítására, hogy a percek és másodpercek 0 és 59 között legyenek.\n\nPélda:\n>>> addTimes(Triple(1, 2, 3), Triple(4, 5, 6))\nTriple(5, 7, 9)\n>>> addTimes(Triple(23, 59, 59), Triple(0, 0, 1))\nTriple(24, 0, 0)"
    },
    "instruction_bertscore": {
      "sq": "0.9973500720866135",
      "hy": "0.9782523568412521",
      "bn": "0.8541184988438798",
      "bg": "0.9665051574764678",
      "zh": "0.9877492726192922",
      "fr": "0.9812089700629565",
      "de": "0.9826015676643921",
      "ha": "0.9871134567695996",
      "hi": "0.9812544564202135",
      "hu": "0.9804496061162601"
    },
    "level": "easy",
    "test": "fun main(){\n\n\ncheck(addTimes(Triple(1, 2, 3), Triple(4, 5, 6)) == Triple(5, 7, 9))\ncheck(addTimes(Triple(23, 59, 59), Triple(0, 0, 1)) == Triple(24, 0, 0))\ncheck(addTimes(Triple(10, 30, 30), Triple(2, 35, 40)) == Triple(13, 6, 10))\ncheck(addTimes(Triple(0, 0, 0), Triple(0, 0, 0)) == Triple(0, 0, 0))\n\n}\n\nmain()",
    "entry_point": "addTimes",
    "signature": "fun addTimes(timeA: Triple<Int, Int, Int>, timeB: Triple<Int, Int, Int>): Triple<Int, Int, Int>",
    "docstring": {
      "en": "Adds two times together. Each time is represented as a Triple of hours, minutes, and seconds.\nHours, minutes, and seconds are normalized to ensure minutes and seconds are within 0 to 59.\n\nExample:\n>>> addTimes(Triple(1, 2, 3), Triple(4, 5, 6))\nTriple(5, 7, 9)\n>>> addTimes(Triple(23, 59, 59), Triple(0, 0, 1))\nTriple(24, 0, 0)",
      "sq": "Shton dy kohë së bashku. Çdo kohë përfaqësohet si një Treshe e orëve, minutave dhe sekondave. Orët, minutat dhe sekondat janë normalizuar për të siguruar që minutat dhe sekondat janë brenda 0 deri në 59.\n\nShembull:\n>>> addTimes(Triple(1, 2, 3), Triple(4, 5, 6))\nTriple(5, 7, 9)\n>>> addTimes(Triple(23, 59, 59), Triple(0, 0, 1))\nTriple(24, 0, 0)",
      "hy": "Երկու ժամանակներ գումարում է իրար: Յուրաքանչյուր ժամանակ ներկայացված է որպես ժամերի, րոպեների և վայրկյանների եռյակ:\nԺամերը, րոպեները և վայրկյանները նորմալացվում են, որպեսզի րոպեները և վայրկյանները լինեն 0-ից 59-ի սահմաններում:\n\nՕրինակ:\n>>> addTimes(Triple(1, 2, 3), Triple(4, 5, 6))\nTriple(5, 7, 9)\n>>> addTimes(Triple(23, 59, 59), Triple(0, 0, 1))\nTriple(24, 0, 0)",
      "bn": "দুটি সময় একত্রিত করে। প্রতিটি সময় ঘন্টা, মিনিট এবং সেকেন্ডের একটি Triple হিসাবে উপস্থাপিত হয়। ঘন্টা, মিনিট এবং সেকেন্ডকে স্বাভাবিকীকরণ করা হয় যাতে মিনিট এবং সেকেন্ড 0 থেকে 59 এর মধ্যে থাকে।\n\nউদাহরণ:\n>>> addTimes(Triple(1, 2, 3), Triple(4, 5, 6))\nTriple(5, 7, 9)\n>>> addTimes(Triple(23, 59, 59), Triple(0, 0, 1))\nTriple(24, 0, 0)",
      "bg": "Събира две времена заедно. Всяко време е представено като Тройка от часове, минути и секунди. Часовете, минутите и секундите са нормализирани, за да се гарантира, че минутите и секундите са в диапазона от 0 до 59.\n\nПример:\n>>> addTimes(Triple(1, 2, 3), Triple(4, 5, 6))\nTriple(5, 7, 9)\n>>> addTimes(Triple(23, 59, 59), Triple(0, 0, 1))\nTriple(24, 0, 0)",
      "zh": "将两个时间相加。每个时间表示为一个包含小时、分钟和秒的三元组。  \n小时、分钟和秒被标准化，以确保分钟和秒在0到59之间。\n\n示例：\n>>> addTimes(Triple(1, 2, 3), Triple(4, 5, 6))\nTriple(5, 7, 9)\n>>> addTimes(Triple(23, 59, 59), Triple(0, 0, 1))\nTriple(24, 0, 0)",
      "fr": "Ajoute deux temps ensemble. Chaque temps est représenté comme un Triple d'heures, minutes et secondes. Les heures, minutes et secondes sont normalisées pour garantir que les minutes et secondes sont comprises entre 0 et 59.\n\nExemple :\n>>> addTimes(Triple(1, 2, 3), Triple(4, 5, 6))\nTriple(5, 7, 9)\n>>> addTimes(Triple(23, 59, 59), Triple(0, 0, 1))\nTriple(24, 0, 0)",
      "de": "Addiert zwei Zeiten zusammen. Jede Zeit wird als Triple von Stunden, Minuten und Sekunden dargestellt. Stunden, Minuten und Sekunden werden normalisiert, um sicherzustellen, dass Minuten und Sekunden im Bereich von 0 bis 59 liegen.\n\nBeispiel:\n>>> addTimes(Triple(1, 2, 3), Triple(4, 5, 6))\nTriple(5, 7, 9)\n>>> addTimes(Triple(23, 59, 59), Triple(0, 0, 1))\nTriple(24, 0, 0)",
      "ha": "Ƙara lokuta biyu tare. Kowanne lokaci ana wakilta shi azaman Triple na awanni, mintuna, da dakiku. Ana daidaita awanni, mintuna, da dakiku don tabbatar da cewa mintuna da dakiku suna tsakanin 0 zuwa 59.\n\nMisali:\n>>> addTimes(Triple(1, 2, 3), Triple(4, 5, 6))\nTriple(5, 7, 9)\n>>> addTimes(Triple(23, 59, 59), Triple(0, 0, 1))\nTriple(24, 0, 0)",
      "hi": "दो समयों को एक साथ जोड़ता है। प्रत्येक समय घंटों, मिनटों, और सेकंडों के त्रिक के रूप में दर्शाया गया है। घंटों, मिनटों, और सेकंडों को सामान्यीकृत किया जाता है ताकि मिनट और सेकंड 0 से 59 के बीच हों।\n\nउदाहरण:\n>>> addTimes(Triple(1, 2, 3), Triple(4, 5, 6))\nTriple(5, 7, 9)\n>>> addTimes(Triple(23, 59, 59), Triple(0, 0, 1))\nTriple(24, 0, 0)",
      "hu": "Két időpontot ad össze. Minden időpont egy hármas formájában van megadva, amely órákból, percekből és másodpercekből áll. Az órák, percek és másodpercek normalizálva vannak annak biztosítására, hogy a percek és másodpercek 0 és 59 között legyenek.\n\nPélda:\n>>> addTimes(Triple(1, 2, 3), Triple(4, 5, 6))\nTriple(5, 7, 9)\n>>> addTimes(Triple(23, 59, 59), Triple(0, 0, 1))\nTriple(24, 0, 0)"
    },
    "docstring_bertscore": {
      "sq": "0.9886677395011976",
      "hy": "0.9546226908221987",
      "bn": "0.9709135601531561",
      "bg": "0.9674442819180008",
      "zh": "0.9811356754523546",
      "fr": "0.9739142693194502",
      "de": "0.9744263384417582",
      "ha": "0.9811487850575029",
      "hi": "0.9774131434813798",
      "hu": "0.9495049790548349"
    }
  },
  {
    "task_id": "Kotlin/25",
    "prompt": {
      "en": "/**\n    * Finds the mode (most frequent element) and its count in a given list of integers.\n    * If there are multiple modes, the smallest one is returned.\n    *\n    * Example:\n    * >>> findModeAndCount(listOf(1, 2, 2, 2, 3, 5))\n    *     Pair(2, 3) // 2 is the mode and it appears 3 times\n    * >>> findModeAndCount(listOf(1, 1, 2, 3, 3))\n    *     Pair(1, 2) // Both 1 and 3 are modes but 1 is smaller\n**/\n\nfun findModeAndCount(numbers: List<Int>): Pair<Int, Int> ",
      "sq": "/**\n    * Gjen modalitetin (elementin më të shpeshtë) dhe numrin e tij në një listë të dhënë të numrave të plotë.\n    * Nëse ka modalitete të shumta, kthehet më i vogli.\n    *\n    * Shembull:\n    * >>> findModeAndCount(listOf(1, 2, 2, 2, 3, 5))\n    *     Pair(2, 3) // 2 është modaliteti dhe shfaqet 3 herë\n    * >>> findModeAndCount(listOf(1, 1, 2, 3, 3))\n    *     Pair(1, 2) // Të dy 1 dhe 3 janë modalitete por 1 është më i vogël\n**/ \n\nfun findModeAndCount(numbers: List<Int>): Pair<Int, Int> ",
      "hy": "/**\n    * Գտնում է մոդան (ամենահաճախ հանդիպող տարրը) և դրա քանակը տրված ամբողջ թվերի ցուցակում:\n    * Եթե կան բազմաթիվ մոդաներ, վերադարձվում է ամենափոքրը:\n    *\n    * Օրինակ:\n    * >>> findModeAndCount(listOf(1, 2, 2, 2, 3, 5))\n    *     Pair(2, 3) // 2-ը մոդան է և այն հանդիպում է 3 անգամ\n    * >>> findModeAndCount(listOf(1, 1, 2, 3, 3))\n    *     Pair(1, 2) // 1 և 3 երկուսն էլ մոդաներ են, բայց 1-ը փոքր է\n**/ \n\nfun findModeAndCount(numbers: List<Int>): Pair<Int, Int> ",
      "bn": "/**\n    * একটি প্রদত্ত পূর্ণসংখ্যার তালিকায় মোড (সবচেয়ে ঘন ঘন উপাদান) এবং এর গণনা খুঁজে বের করে।\n    * যদি একাধিক মোড থাকে, তবে সবচেয়ে ছোটটি ফেরত দেওয়া হয়।\n    *\n    * উদাহরণ:\n    * >>> findModeAndCount(listOf(1, 2, 2, 2, 3, 5))\n    *     Pair(2, 3) // 2 হল মোড এবং এটি 3 বার প্রদর্শিত হয়\n    * >>> findModeAndCount(listOf(1, 1, 2, 3, 3))\n    *     Pair(1, 2) // উভয় 1 এবং 3 মোড কিন্তু 1 ছোট\n**/ \n\nfun findModeAndCount(numbers: List<Int>): Pair<Int, Int> ",
      "bg": "/**\n    * Намира модата (най-често срещания елемент) и броя му в даден списък от цели числа.\n    * Ако има няколко моди, се връща най-малката.\n    *\n    * Пример:\n    * >>> findModeAndCount(listOf(1, 2, 2, 2, 3, 5))\n    *     Pair(2, 3) // 2 е модата и се появява 3 пъти\n    * >>> findModeAndCount(listOf(1, 1, 2, 3, 3))\n    *     Pair(1, 2) // И 1, и 3 са моди, но 1 е по-малка\n**/ \n\nfun findModeAndCount(numbers: List<Int>): Pair<Int, Int> ",
      "zh": "/**\n    * 查找给定整数列表中出现频率最高的元素（众数）及其出现次数。\n    * 如果有多个众数，返回最小的那个。\n    *\n    * 例子:\n    * >>> findModeAndCount(listOf(1, 2, 2, 2, 3, 5))\n    *     Pair(2, 3) // 2 是众数，出现了 3 次\n    * >>> findModeAndCount(listOf(1, 1, 2, 3, 3))\n    *     Pair(1, 2) // 1 和 3 都是众数，但 1 更小\n**/",
      "fr": "/**\n    * Trouve la mode (élément le plus fréquent) et son nombre d'occurrences dans une liste donnée d'entiers.\n    * S'il y a plusieurs modes, le plus petit est retourné.\n    *\n    * Exemple :\n    * >>> findModeAndCount(listOf(1, 2, 2, 2, 3, 5))\n    *     Pair(2, 3) // 2 est la mode et il apparaît 3 fois\n    * >>> findModeAndCount(listOf(1, 1, 2, 3, 3))\n    *     Pair(1, 2) // 1 et 3 sont tous deux des modes mais 1 est plus petit\n**/ \n\nfun findModeAndCount(numbers: List<Int>): Pair<Int, Int> ",
      "de": "/**\n    * Findet den Modus (häufigstes Element) und dessen Anzahl in einer gegebenen Liste von ganzen Zahlen.\n    * Wenn es mehrere Modi gibt, wird der kleinste zurückgegeben.\n    *\n    * Beispiel:\n    * >>> findModeAndCount(listOf(1, 2, 2, 2, 3, 5))\n    *     Pair(2, 3) // 2 ist der Modus und erscheint 3 Mal\n    * >>> findModeAndCount(listOf(1, 1, 2, 3, 3))\n    *     Pair(1, 2) // Sowohl 1 als auch 3 sind Modi, aber 1 ist kleiner\n**/ \n\nfun findModeAndCount(numbers: List<Int>): Pair<Int, Int> ",
      "ha": "/**\n    * Nemo yanayin (abin da aka fi maimaitawa) da adadinsa a cikin jerin lambobi na integers.\n    * Idan akwai yanayi da dama, mafi ƙanƙanta za a dawo da shi.\n    *\n    * Misali:\n    * >>> findModeAndCount(listOf(1, 2, 2, 2, 3, 5))\n    *     Pair(2, 3) // 2 shine yanayi kuma ya bayyana sau 3\n    * >>> findModeAndCount(listOf(1, 1, 2, 3, 3))\n    *     Pair(1, 2) // Duka 1 da 3 yanayi ne amma 1 ya fi ƙanƙanta\n**/",
      "hi": "/**\n    * दिए गए पूर्णांकों की सूची में मोड (सबसे अधिक बार आने वाला तत्व) और उसकी गिनती पाता है।\n    * यदि एक से अधिक मोड हैं, तो सबसे छोटा मोड लौटाया जाता है।\n    *\n    * उदाहरण:\n    * >>> findModeAndCount(listOf(1, 2, 2, 2, 3, 5))\n    *     Pair(2, 3) // 2 मोड है और यह 3 बार आता है\n    * >>> findModeAndCount(listOf(1, 1, 2, 3, 3))\n    *     Pair(1, 2) // 1 और 3 दोनों मोड हैं लेकिन 1 छोटा है\n**/ \n\nfun findModeAndCount(numbers: List<Int>): Pair<Int, Int> ",
      "hu": "/**\n    * Megkeresi a móduszt (leggyakrabban előforduló elemet) és annak számát egy adott egész számokat tartalmazó listában.\n    * Ha több módusz van, a legkisebbet adja vissza.\n    *\n    * Példa:\n    * >>> findModeAndCount(listOf(1, 2, 2, 2, 3, 5))\n    *     Pair(2, 3) // 2 a módusz és 3-szor fordul elő\n    * >>> findModeAndCount(listOf(1, 1, 2, 3, 3))\n    *     Pair(1, 2) // Mind az 1, mind a 3 módusz, de az 1 kisebb\n**/"
    },
    "prompt_bertscore": {
      "sq": "0.9951399118368384",
      "hy": "0.9847036729868843",
      "bn": "0.9991462866223121",
      "bg": "0.9932261081155672",
      "zh": "0.915994643361582",
      "fr": "0.9829690338693066",
      "de": "0.9927148335147834",
      "ha": "0.9407712012007309",
      "hi": "0.9782875144186953",
      "hu": "0.9438680474714458"
    },
    "canonical_solution": "{\n    val frequencyMap = numbers.groupingBy { it }.eachCount()\n    val maxCount = frequencyMap.maxOf { it.value }\n    val mode = frequencyMap.filter { it.value == maxCount }.minByOrNull { it.key }!!.key\n    return Pair(mode, maxCount)\n}",
    "instruction": {
      "en": "Write a Kotlin function `fun findModeAndCount(numbers: List<Int>): Pair<Int, Int>` to solve the following problem:\nFinds the mode (most frequent element) and its count in a given list of integers.\nIf there are multiple modes, the smallest one is returned.\n\nExample:\n>>> findModeAndCount(listOf(1, 2, 2, 2, 3, 5))\nPair(2, 3) // 2 is the mode and it appears 3 times\n>>> findModeAndCount(listOf(1, 1, 2, 3, 3))\nPair(1, 2) // Both 1 and 3 are modes but 1 is smaller",
      "sq": "Shkruani një funksion Kotlin `fun findModeAndCount(numbers: List<Int>): Pair<Int, Int>` për të zgjidhur problemin e mëposhtëm:\nGjen modën (elementin më të shpeshtë) dhe numrin e tij në një listë të dhënë të numrave të plotë.\nNëse ka disa moda, kthehet më i vogli.\n\nShembull:\n>>> findModeAndCount(listOf(1, 2, 2, 2, 3, 5))\nPair(2, 3) // 2 është moda dhe shfaqet 3 herë\n>>> findModeAndCount(listOf(1, 1, 2, 3, 3))\nPair(1, 2) // Të dy 1 dhe 3 janë moda, por 1 është më i vogël",
      "hy": "Գրեք Kotlin ֆունկցիա `fun findModeAndCount(numbers: List<Int>): Pair<Int, Int>` հետևյալ խնդիրը լուծելու համար:\nԳտնում է ռեժիմը (ամենահաճախ հանդիպող տարրը) և նրա քանակը տրված ամբողջ թվերի ցուցակում:\nԵթե կան բազմաթիվ ռեժիմներ, վերադարձվում է ամենափոքրն։\n\nՕրինակ:\n>>> findModeAndCount(listOf(1, 2, 2, 2, 3, 5))\nPair(2, 3) // 2-ը ռեժիմն է և այն հանդիպում է 3 անգամ\n>>> findModeAndCount(listOf(1, 1, 2, 3, 3))\nPair(1, 2) // 1 և 3-ը երկուսն էլ ռեժիմներ են, բայց 1-ը փոքր է",
      "bn": "একটি Kotlin ফাংশন `fun findModeAndCount(numbers: List<Int>): Pair<Int, Int>` লিখুন নিম্নলিখিত সমস্যার সমাধানের জন্য:\nপ্রদত্ত পূর্ণসংখ্যার তালিকায় মোড (সবচেয়ে ঘন ঘন উপাদান) এবং এর গণনা খুঁজে বের করে।\nযদি একাধিক মোড থাকে, তবে সবচেয়ে ছোটটি ফেরত দেওয়া হয়।\n\nউদাহরণ:\n>>> findModeAndCount(listOf(1, 2, 2, 2, 3, 5))\nPair(2, 3) // 2 হল মোড এবং এটি 3 বার প্রদর্শিত হয়\n>>> findModeAndCount(listOf(1, 1, 2, 3, 3))\nPair(1, 2) // উভয় 1 এবং 3 মোড কিন্তু 1 ছোট",
      "bg": "Напишете функция на Kotlin `fun findModeAndCount(numbers: List<Int>): Pair<Int, Int>` за решаване на следния проблем:\nНамира модата (най-често срещания елемент) и неговата честота в даден списък от цели числа.\nАко има няколко моди, връща се най-малката.\n\nПример:\n>>> findModeAndCount(listOf(1, 2, 2, 2, 3, 5))\nPair(2, 3) // 2 е модата и се появява 3 пъти\n>>> findModeAndCount(listOf(1, 1, 2, 3, 3))\nPair(1, 2) // И 1, и 3 са моди, но 1 е по-малка",
      "zh": "编写一个 Kotlin 函数 `fun findModeAndCount(numbers: List<Int>): Pair<Int, Int>` 来解决以下问题：\n在给定的整数列表中，找到众数（出现频率最高的元素）及其出现次数。\n如果有多个众数，返回最小的一个。\n\n示例：\n>>> findModeAndCount(listOf(1, 2, 2, 2, 3, 5))\nPair(2, 3) // 2 是众数，出现了 3 次\n>>> findModeAndCount(listOf(1, 1, 2, 3, 3))\nPair(1, 2) // 1 和 3 都是众数，但 1 更小",
      "fr": "Écrire une fonction Kotlin `fun findModeAndCount(numbers: List<Int>): Pair<Int, Int>` pour résoudre le problème suivant :\nTrouve la mode (élément le plus fréquent) et son nombre d'occurrences dans une liste donnée d'entiers.\nS'il y a plusieurs modes, le plus petit est retourné.\n\nExemple :\n>>> findModeAndCount(listOf(1, 2, 2, 2, 3, 5))\nPair(2, 3) // 2 est la mode et il apparaît 3 fois\n>>> findModeAndCount(listOf(1, 1, 2, 3, 3))\nPair(1, 2) // 1 et 3 sont tous deux des modes mais 1 est plus petit",
      "de": "Schreiben Sie eine Kotlin-Funktion `fun findModeAndCount(numbers: List<Int>): Pair<Int, Int>`, um das folgende Problem zu lösen:\nFindet den Modus (das am häufigsten vorkommende Element) und dessen Anzahl in einer gegebenen Liste von ganzen Zahlen.\nWenn es mehrere Modi gibt, wird der kleinste zurückgegeben.\n\nBeispiel:\n>>> findModeAndCount(listOf(1, 2, 2, 2, 3, 5))\nPair(2, 3) // 2 ist der Modus und erscheint 3 Mal\n>>> findModeAndCount(listOf(1, 1, 2, 3, 3))\nPair(1, 2) // Sowohl 1 als auch 3 sind Modi, aber 1 ist kleiner",
      "ha": "Rubuta aikin Kotlin `fun findModeAndCount(numbers: List<Int>): Pair<Int, Int>` don warware matsalar mai zuwa:\nNemo yanayin (abu mafi yawan faruwa) da adadinsa a cikin jerin lambobin integers da aka bayar.\nIdan akwai yanayi da yawa, ana mayar da mafi ƙanƙanta.\n\nMisali:\n>>> findModeAndCount(listOf(1, 2, 2, 2, 3, 5))\nPair(2, 3) // 2 shine yanayin kuma yana bayyana sau 3\n>>> findModeAndCount(listOf(1, 1, 2, 3, 3))\nPair(1, 2) // Duk 1 da 3 yanayi ne amma 1 yafi ƙanƙanta",
      "hi": "Kotlin फ़ंक्शन `fun findModeAndCount(numbers: List<Int>): Pair<Int, Int>` लिखें ताकि निम्नलिखित समस्या का समाधान किया जा सके:\nदिए गए पूर्णांकों की सूची में मोड (सबसे अधिक बार आने वाला तत्व) और उसकी गिनती खोजें।\nयदि कई मोड हैं, तो सबसे छोटा लौटाया जाता है।\n\nउदाहरण:\n>>> findModeAndCount(listOf(1, 2, 2, 2, 3, 5))\nPair(2, 3) // 2 मोड है और यह 3 बार आता है\n>>> findModeAndCount(listOf(1, 1, 2, 3, 3))\nPair(1, 2) // 1 और 3 दोनों मोड हैं लेकिन 1 छोटा है",
      "hu": "Írj egy Kotlin függvényt `fun findModeAndCount(numbers: List<Int>): Pair<Int, Int>` a következő probléma megoldására:\nMegtalálja a móduszt (leggyakoribb elem) és annak előfordulási számát egy adott egész számokat tartalmazó listában.\nHa több módusz van, a legkisebbet adja vissza.\n\nPélda:\n>>> findModeAndCount(listOf(1, 2, 2, 2, 3, 5))\nPair(2, 3) // 2 a módusz és 3-szor fordul elő\n>>> findModeAndCount(listOf(1, 1, 2, 3, 3))\nPair(1, 2) // Mind az 1, mind a 3 módusz, de az 1 a kisebb"
    },
    "instruction_bertscore": {
      "sq": "0.9882102937336742",
      "hy": "0.9811851344172323",
      "bn": "0.9888608082315634",
      "bg": "0.9792069744525058",
      "zh": "0.961068842577924",
      "fr": "0.9866470726349297",
      "de": "0.9889370822978809",
      "ha": "0.9787364190798342",
      "hi": "0.9759673129378268",
      "hu": "0.9881904306955708"
    },
    "level": "easy",
    "test": "fun main() {\n    check(findModeAndCount(listOf(1, 2, 2, 2, 3, 5)) == Pair(2, 3))\n    check(findModeAndCount(listOf(1, 1, 2, 3, 3)) == Pair(1, 2))\n    check(findModeAndCount(listOf(4, 4, 4, 5, 5, 6, 6, 6)) == Pair(4, 3))\n    check(findModeAndCount(listOf(7, 7, 8, 9, 9, 9)) == Pair(9, 3))\n    check(findModeAndCount(listOf(7, 7, 8, 9, 9, 9, 1, 1, 1, 1, 1)) == Pair(1, 5))\n}\n\nmain()",
    "entry_point": "findModeAndCount",
    "signature": "fun findModeAndCount(numbers: List<Int>): Pair<Int, Int>",
    "docstring": {
      "en": "Finds the mode (most frequent element) and its count in a given list of integers.\nIf there are multiple modes, the smallest one is returned.\n\nExample:\n>>> findModeAndCount(listOf(1, 2, 2, 2, 3, 5))\nPair(2, 3) // 2 is the mode and it appears 3 times\n>>> findModeAndCount(listOf(1, 1, 2, 3, 3))\nPair(1, 2) // Both 1 and 3 are modes but 1 is smaller",
      "sq": "Gjen modën (elementin më të shpeshtë) dhe numrin e saj në një listë të dhënë të numrave të plotë.\nNëse ka disa modë, kthehet më e vogla.\n\nShembull:\n>>> findModeAndCount(listOf(1, 2, 2, 2, 3, 5))\nPair(2, 3) // 2 është moda dhe shfaqet 3 herë\n>>> findModeAndCount(listOf(1, 1, 2, 3, 3))\nPair(1, 2) // Të dy 1 dhe 3 janë modë por 1 është më i vogël",
      "hy": "Գտնում է ռեժիմը (ամենահաճախ հանդիպող տարրը) և դրա քանակը տրված ամբողջ թվերի ցուցակում:\nԵթե կան բազմաթիվ ռեժիմներ, վերադարձվում է ամենափոքրը:\n\nՕրինակ:\n>>> findModeAndCount(listOf(1, 2, 2, 2, 3, 5))\nPair(2, 3) // 2-ը ռեժիմն է և այն հանդիպում է 3 անգամ\n>>> findModeAndCount(listOf(1, 1, 2, 3, 3))\nPair(1, 2) // 1-ը և 3-ը երկուսն էլ ռեժիմներ են, բայց 1-ը փոքր է",
      "bn": "প্রদত্ত পূর্ণসংখ্যার তালিকায় মোড (সবচেয়ে ঘন ঘন উপাদান) এবং এর গণনা খুঁজে বের করে।\nযদি একাধিক মোড থাকে, তবে সবচেয়ে ছোটটি ফেরত দেওয়া হয়।\n\nউদাহরণ:\n>>> findModeAndCount(listOf(1, 2, 2, 2, 3, 5))\nPair(2, 3) // 2 হল মোড এবং এটি 3 বার উপস্থিত হয়\n>>> findModeAndCount(listOf(1, 1, 2, 3, 3))\nPair(1, 2) // 1 এবং 3 উভয়ই মোড কিন্তু 1 ছোট",
      "bg": "Намира модата (най-често срещания елемент) и неговата честота в даден списък от цели числа. Ако има няколко моди, се връща най-малката.\n\nПример:\n>>> findModeAndCount(listOf(1, 2, 2, 2, 3, 5))\nPair(2, 3) // 2 е модата и се появява 3 пъти\n>>> findModeAndCount(listOf(1, 1, 2, 3, 3))\nPair(1, 2) // Както 1, така и 3 са моди, но 1 е по-малка",
      "zh": "找到给定整数列表中出现次数最多的元素（众数）及其出现次数。\n如果有多个众数，则返回最小的一个。\n\n示例：\n>>> findModeAndCount(listOf(1, 2, 2, 2, 3, 5))\nPair(2, 3) // 2 是众数，出现了 3 次\n>>> findModeAndCount(listOf(1, 1, 2, 3, 3))\nPair(1, 2) // 1 和 3 都是众数，但 1 更小",
      "fr": "Trouve la mode (élément le plus fréquent) et son nombre dans une liste donnée d'entiers.\nS'il y a plusieurs modes, le plus petit est retourné.\n\nExemple :\n>>> findModeAndCount(listOf(1, 2, 2, 2, 3, 5))\nPair(2, 3) // 2 est la mode et il apparaît 3 fois\n>>> findModeAndCount(listOf(1, 1, 2, 3, 3))\nPair(1, 2) // Les deux 1 et 3 sont des modes mais 1 est plus petit",
      "de": "Findet den Modus (häufigstes Element) und dessen Anzahl in einer gegebenen Liste von ganzen Zahlen.\nWenn es mehrere Modi gibt, wird der kleinste zurückgegeben.\n\nBeispiel:\n>>> findModeAndCount(listOf(1, 2, 2, 2, 3, 5))\nPair(2, 3) // 2 ist der Modus und erscheint 3 Mal\n>>> findModeAndCount(listOf(1, 1, 2, 3, 3))\nPair(1, 2) // Sowohl 1 als auch 3 sind Modi, aber 1 ist kleiner",
      "ha": "Yana nemo yanayin (abin da yafi yawan faruwa) da adadinsa a cikin jerin lambobin tsari da aka bayar.\nIdan akwai yanayi da yawa, mafi ƙanƙanta za a dawo da shi.\n\nMisali:\n>>> findModeAndCount(listOf(1, 2, 2, 2, 3, 5))\nPair(2, 3) // 2 shine yanayin kuma ya bayyana sau 3\n>>> findModeAndCount(listOf(1, 1, 2, 3, 3))\nPair(1, 2) // Duka 1 da 3 suna da yanayi amma 1 yafi ƙanƙanta",
      "hi": "दिए गए पूर्णांकों की सूची में मोड (सबसे अधिक बार आने वाला तत्व) और उसकी गिनती खोजता है।  \nयदि कई मोड हैं, तो सबसे छोटा लौटाया जाता है।\n\nउदाहरण:\n>>> findModeAndCount(listOf(1, 2, 2, 2, 3, 5))\nPair(2, 3) // 2 मोड है और यह 3 बार आता है\n>>> findModeAndCount(listOf(1, 1, 2, 3, 3))\nPair(1, 2) // 1 और 3 दोनों मोड हैं लेकिन 1 छोटा है",
      "hu": "Megkeresi a móduszt (leggyakrabban előforduló elemet) és annak számát egy adott egész számokat tartalmazó listában. Ha több módusz is van, a legkisebbet adja vissza.\n\nPélda:\n>>> findModeAndCount(listOf(1, 2, 2, 2, 3, 5))\nPair(2, 3) // 2 a módusz és 3-szor fordul elő\n>>> findModeAndCount(listOf(1, 1, 2, 3, 3))\nPair(1, 2) // Mind az 1, mind a 3 módusz, de az 1 kisebb"
    },
    "docstring_bertscore": {
      "sq": "0.9820672519394082",
      "hy": "0.9786396860842702",
      "bn": "0.9945533563216423",
      "bg": "0.986694346665616",
      "zh": "0.9527070994274983",
      "fr": "0.9944063698396766",
      "de": "0.9909267628247074",
      "ha": "0.9795573584446514",
      "hi": "0.9895875967957701",
      "hu": "0.9854558862398635"
    }
  },
  {
    "task_id": "Kotlin/26",
    "prompt": {
      "en": "/**\n * Processes a given 2D array representing an image, applying a series of operations.\n * Each operation is represented by a character:\n * 'A' - Rotate the image 90 degrees clockwise.\n * 'B' - Rotate the image 90 degrees counterclockwise.\n * 'C' - Flip the image horizontally.\n * 'D' - Flip the image vertically.\n *\n * @param image A 2D array of integers representing the image's pixel grayscale values.\n * @param operations A string of characters representing the operations to be applied in sequence.\n * @return A 2D array of integers representing the processed image.\n *\n * Example:\n * >>> processImage(arrayOf(arrayOf(10, 0, 10), arrayOf(100, 100, 10)), \"AC\")\n *     arrayOf(arrayOf(10, 100), arrayOf(0, 100), arrayOf(10, 10))\n */\nfun processImage(image: Array<Array<Int>>, operations: String): Array<Array<Int>> ",
      "sq": "/**\n * Përpunon një varg 2D të dhënë që përfaqëson një imazh, duke aplikuar një seri operacionesh.\n * Çdo operacion përfaqësohet nga një karakter:\n * 'A' - Rrotullo imazhin 90 gradë në drejtim të akrepave të orës.\n * 'B' - Rrotullo imazhin 90 gradë në drejtim të kundërt të akrepave të orës.\n * 'C' - Përmbys imazhin horizontalisht.\n * 'D' - Përmbys imazhin vertikalisht.\n *\n * @param image Një varg 2D i numrave të plotë që përfaqëson vlerat e shkallës gri të pikselëve të imazhit.\n * @param operations Një varg karakteresh që përfaqëson operacionet që do të aplikohen në sekuencë.\n * @return Një varg 2D i numrave të plotë që përfaqëson imazhin e përpunuar.\n *\n * Shembull:\n * >>> processImage(arrayOf(arrayOf(10, 0, 10), arrayOf(100, 100, 10)), \"AC\")\n *     arrayOf(arrayOf(10, 100), arrayOf(0, 100), arrayOf(10, 10))\n */",
      "hy": "/**\n * Կատարում է տրված 2D զանգվածի մշակում, որը ներկայացնում է պատկեր, կիրառելով գործողությունների շարք:\n * Յուրաքանչյուր գործողություն ներկայացված է սիմվոլով:\n * 'A' - Պտտել պատկերը 90 աստիճան ժամացույցի սլաքի ուղղությամբ:\n * 'B' - Պտտել պատկերը 90 աստիճան հակառակ ժամացույցի սլաքի ուղղությամբ:\n * 'C' - Հորիզոնական շրջել պատկերը:\n * 'D' - Ուղղահայաց շրջել պատկերը:\n *\n * @param image Պատկերի պիքսելների մոխրագույն արժեքները ներկայացնող ամբողջ թվերի 2D զանգված:\n * @param operations Սիմվոլների տող, որը ներկայացնում է հերթականությամբ կիրառվող գործողությունները:\n * @return Ամբողջ թվերի 2D զանգված, որը ներկայացնում է մշակված պատկերը:\n *\n * Օրինակ:\n * >>> processImage(arrayOf(arrayOf(10, 0, 10), arrayOf(100, 100, 10)), \"AC\")\n *     arrayOf(arrayOf(10, 100), arrayOf(0, 100), arrayOf(10, 10))\n */",
      "bn": "/**\n * একটি প্রদত্ত 2D অ্যারে প্রক্রিয়া করে যা একটি চিত্র উপস্থাপন করে, একটি সিরিজ অপারেশন প্রয়োগ করে।\n * প্রতিটি অপারেশন একটি অক্ষর দ্বারা উপস্থাপিত হয়:\n * 'A' - চিত্রটি 90 ডিগ্রি ঘড়ির কাঁটার দিকে ঘোরান।\n * 'B' - চিত্রটি 90 ডিগ্রি ঘড়ির কাঁটার বিপরীতে ঘোরান।\n * 'C' - চিত্রটি অনুভূমিকভাবে উল্টান।\n * 'D' - চিত্রটি উল্লম্বভাবে উল্টান।\n *\n * @param image একটি 2D পূর্ণসংখ্যার অ্যারে যা চিত্রের পিক্সেলের গ্রেস্কেল মানগুলি উপস্থাপন করে।\n * @param operations একটি অক্ষরের স্ট্রিং যা ক্রমানুসারে প্রয়োগ করার জন্য অপারেশনগুলি উপস্থাপন করে।\n * @return একটি 2D পূর্ণসংখ্যার অ্যারে যা প্রক্রিয়াকৃত চিত্র উপস্থাপন করে।\n *\n * উদাহরণ:\n * >>> processImage(arrayOf(arrayOf(10, 0, 10), arrayOf(100, 100, 10)), \"AC\")\n *     arrayOf(arrayOf(10, 100), arrayOf(0, 100), arrayOf(10, 10))\n */",
      "bg": "/**\n * Обработва даден 2D масив, представляващ изображение, прилагайки серия от операции.\n * Всяка операция е представена от символ:\n * 'A' - Завърта изображението на 90 градуса по часовниковата стрелка.\n * 'B' - Завърта изображението на 90 градуса обратно на часовниковата стрелка.\n * 'C' - Обръща изображението хоризонтално.\n * 'D' - Обръща изображението вертикално.\n *\n * @param image 2D масив от цели числа, представляващ стойностите на сивото на пикселите на изображението.\n * @param operations Низ от символи, представляващ операциите, които трябва да се приложат последователно.\n * @return 2D масив от цели числа, представляващ обработеното изображение.\n *\n * Пример:\n * >>> processImage(arrayOf(arrayOf(10, 0, 10), arrayOf(100, 100, 10)), \"AC\")\n *     arrayOf(arrayOf(10, 100), arrayOf(0, 100), arrayOf(10, 10))\n */ \nfun processImage(image: Array<Array<Int>>, operations: String): Array<Array<Int>> ",
      "zh": "/**\n * 处理给定的表示图像的二维数组，应用一系列操作。\n * 每个操作由一个字符表示：\n * 'A' - 将图像顺时针旋转90度。\n * 'B' - 将图像逆时针旋转90度。\n * 'C' - 水平翻转图像。\n * 'D' - 垂直翻转图像。\n *\n * @param image 一个整数的二维数组，表示图像的像素灰度值。\n * @param operations 一个字符字符串，表示要按顺序应用的操作。\n * @return 一个整数的二维数组，表示处理后的图像。\n *\n * 例子:\n * >>> processImage(arrayOf(arrayOf(10, 0, 10), arrayOf(100, 100, 10)), \"AC\")\n *     arrayOf(arrayOf(10, 100), arrayOf(0, 100), arrayOf(10, 10))\n */",
      "fr": "/**\n * Traite un tableau 2D donné représentant une image, en appliquant une série d'opérations.\n * Chaque opération est représentée par un caractère :\n * 'A' - Tourner l'image de 90 degrés dans le sens des aiguilles d'une montre.\n * 'B' - Tourner l'image de 90 degrés dans le sens inverse des aiguilles d'une montre.\n * 'C' - Retourner l'image horizontalement.\n * 'D' - Retourner l'image verticalement.\n *\n * @param image Un tableau 2D d'entiers représentant les valeurs de gris des pixels de l'image.\n * @param operations Une chaîne de caractères représentant les opérations à appliquer en séquence.\n * @return Un tableau 2D d'entiers représentant l'image traitée.\n *\n * Exemple :\n * >>> processImage(arrayOf(arrayOf(10, 0, 10), arrayOf(100, 100, 10)), \"AC\")\n *     arrayOf(arrayOf(10, 100), arrayOf(0, 100), arrayOf(10, 10))\n */ \nfun processImage(image: Array<Array<Int>>, operations: String): Array<Array<Int>> ",
      "de": "/**\n * Verarbeitet ein gegebenes 2D-Array, das ein Bild darstellt, und wendet eine Reihe von Operationen an.\n * Jede Operation wird durch ein Zeichen dargestellt:\n * 'A' - Dreht das Bild um 90 Grad im Uhrzeigersinn.\n * 'B' - Dreht das Bild um 90 Grad gegen den Uhrzeigersinn.\n * 'C' - Spiegelt das Bild horizontal.\n * 'D' - Spiegelt das Bild vertikal.\n *\n * @param image Ein 2D-Array von Ganzzahlen, das die Graustufenwerte der Bildpixel darstellt.\n * @param operations Ein String von Zeichen, der die in Folge anzuwendenden Operationen darstellt.\n * @return Ein 2D-Array von Ganzzahlen, das das verarbeitete Bild darstellt.\n *\n * Beispiel:\n * >>> processImage(arrayOf(arrayOf(10, 0, 10), arrayOf(100, 100, 10)), \"AC\")\n *     arrayOf(arrayOf(10, 100), arrayOf(0, 100), arrayOf(10, 10))\n */",
      "ha": "/**\n * Yana sarrafa wani tsararren 2D da aka bayar wanda ke wakiltar hoto, yana amfani da jerin ayyuka.\n * Kowane aiki yana wakilta da wata alama:\n * 'A' - Juya hoton digiri 90 a agogo.\n * 'B' - Juya hoton digiri 90 ba a agogo ba.\n * 'C' - Juya hoton a kwance.\n * 'D' - Juya hoton a tsaye.\n *\n * @param image Tsararren 2D na lambobi wanda ke wakiltar ƙimar launin toka na hoton.\n * @param operations Wani jeren haruffa da ke wakiltar ayyukan da za a yi a jere.\n * @return Tsararren 2D na lambobi wanda ke wakiltar hoton da aka sarrafa.\n *\n * Misali:\n * >>> processImage(arrayOf(arrayOf(10, 0, 10), arrayOf(100, 100, 10)), \"AC\")\n *     arrayOf(arrayOf(10, 100), arrayOf(0, 100), arrayOf(10, 10))\n */",
      "hi": "/**\n * एक दिए गए 2D array को प्रोसेस करता है जो एक छवि का प्रतिनिधित्व करता है, और उस पर कई ऑपरेशन्स लागू करता है।\n * प्रत्येक ऑपरेशन एक कैरेक्टर द्वारा दर्शाया गया है:\n * 'A' - छवि को 90 डिग्री क्लॉकवाइज़ घुमाएँ।\n * 'B' - छवि को 90 डिग्री एंटी-क्लॉकवाइज़ घुमाएँ।\n * 'C' - छवि को क्षैतिज रूप से पलटें।\n * 'D' - छवि को लंबवत रूप से पलटें।\n *\n * @param image पूर्णांकों की 2D array जो छवि के पिक्सेल ग्रेस्केल मानों का प्रतिनिधित्व करती है।\n * @param operations कैरेक्टर्स की एक स्ट्रिंग जो क्रम में लागू किए जाने वाले ऑपरेशन्स का प्रतिनिधित्व करती है।\n * @return पूर्णांकों की 2D array जो प्रोसेस की गई छवि का प्रतिनिधित्व करती है।\n *\n * उदाहरण:\n * >>> processImage(arrayOf(arrayOf(10, 0, 10), arrayOf(100, 100, 10)), \"AC\")\n *     arrayOf(arrayOf(10, 100), arrayOf(0, 100), arrayOf(10, 10))\n */ \nfun processImage(image: Array<Array<Int>>, operations: String): Array<Array<Int>> ",
      "hu": "/**\n * Feldolgozza a megadott 2D tömböt, amely egy képet ábrázol, és egy sor műveletet alkalmaz.\n * Minden műveletet egy karakter jelöl:\n * 'A' - A képet 90 fokkal az óramutató járásával megegyező irányba forgatja.\n * 'B' - A képet 90 fokkal az óramutató járásával ellentétes irányba forgatja.\n * 'C' - A képet vízszintesen tükrözi.\n * 'D' - A képet függőlegesen tükrözi.\n *\n * @param image Egy 2D tömb egész számokkal, amely a kép pixel szürkeárnyalatos értékeit ábrázolja.\n * @param operations Egy karakterlánc, amely a sorban alkalmazandó műveleteket jelöli.\n * @return Egy 2D tömb egész számokkal, amely a feldolgozott képet ábrázolja.\n *\n * Példa:\n * >>> processImage(arrayOf(arrayOf(10, 0, 10), arrayOf(100, 100, 10)), \"AC\")\n *     arrayOf(arrayOf(10, 100), arrayOf(0, 100), arrayOf(10, 10))\n */"
    },
    "prompt_bertscore": {
      "sq": "0.9534821551742965",
      "hy": "0.9483505392802601",
      "bn": "0.9493707049172553",
      "bg": "0.9677670562871825",
      "zh": "0.9547309443798627",
      "fr": "0.9858320921815434",
      "de": "0.9384533832844347",
      "ha": "0.9380892937959978",
      "hi": "0.9818676284064681",
      "hu": "0.9360144008357073"
    },
    "canonical_solution": "{\n    var processedImage = image\n\n    for (operation in operations) {\n        processedImage = when (operation) {\n            'A' -> rotateClockwise(processedImage)\n            'B' -> rotateCounterClockwise(processedImage)\n            'C' -> flipHorizontally(processedImage)\n            'D' -> flipVertically(processedImage)\n            else -> processedImage\n        }\n    }\n    return processedImage\n}\n\nprivate fun rotateClockwise(image: Array<Array<Int>>): Array<Array<Int>> {\n    val rows = image.size\n    val cols = image[0].size\n    val rotatedImage = Array(cols) { Array(rows) { 0 } }\n\n    for (i in 0 until rows) {\n        for (j in 0 until cols) {\n            rotatedImage[j][rows - 1 - i] = image[i][j]\n        }\n    }\n\n    return rotatedImage\n}\n\nprivate fun rotateCounterClockwise(image: Array<Array<Int>>): Array<Array<Int>> {\n    val rows = image.size\n    val cols = image[0].size\n    val rotatedImage = Array(cols) { Array(rows) { 0 } }\n\n    for (i in 0 until rows) {\n        for (j in 0 until cols) {\n            rotatedImage[cols - 1 - j][i] = image[i][j]\n        }\n    }\n\n    return rotatedImage\n}\n\nprivate fun flipHorizontally(image: Array<Array<Int>>): Array<Array<Int>> {\n    return image.map { it.reversed().toTypedArray() }.toTypedArray()\n}\n\nprivate fun flipVertically(image: Array<Array<Int>>): Array<Array<Int>> {\n    return image.reversed().toTypedArray()\n}",
    "instruction": {
      "en": "Write a Kotlin function `fun processImage(image: Array<Array<Int>>, operations: String): Array<Array<Int>>` to solve the following problem:\nProcesses a given 2D array representing an image, applying a series of operations.\nEach operation is represented by a character:\n'A' - Rotate the image 90 degrees clockwise.\n'B' - Rotate the image 90 degrees counterclockwise.\n'C' - Flip the image horizontally.\n'D' - Flip the image vertically.\n\n@param image A 2D array of integers representing the image's pixel grayscale values.\n@param operations A string of characters representing the operations to be applied in sequence.\n@return A 2D array of integers representing the processed image.\n\nExample:\n>>> processImage(arrayOf(arrayOf(10, 0, 10), arrayOf(100, 100, 10)), \"AC\")\narrayOf(arrayOf(10, 100), arrayOf(0, 100), arrayOf(10, 10))",
      "sq": "Shkruani një funksion Kotlin `fun processImage(image: Array<Array<Int>>, operations: String): Array<Array<Int>>` për të zgjidhur problemin në vijim:\nPërpunon një varg 2D të dhënë që përfaqëson një imazh, duke aplikuar një seri operacionesh.\nÇdo operacion përfaqësohet nga një karakter:\n'A' - Rrotullon imazhin 90 gradë në drejtim të akrepave të orës.\n'B' - Rrotullon imazhin 90 gradë kundër drejtimit të akrepave të orës.\n'C' - Pasqyrimi horizontal i imazhit.\n'D' - Pasqyrimi vertikal i imazhit.\n\n@param image Një varg 2D i numrave të plotë që përfaqëson vlerat e hirit të pikselëve të imazhit.\n@param operations Një varg karakteresh që përfaqëson operacionet që do të aplikohen në rend.\n@return Një varg 2D i numrave të plotë që përfaqëson imazhin e përpunuar.\n\nShembull:\n>>> processImage(arrayOf(arrayOf(10, 0, 10), arrayOf(100, 100, 10)), \"AC\")\narrayOf(arrayOf(10, 100), arrayOf(0, 100), arrayOf(10, 10))",
      "hy": "Գրեք Kotlin ֆունկցիա `fun processImage(image: Array<Array<Int>>, operations: String): Array<Array<Int>>` հետևյալ խնդիրը լուծելու համար:\nՄշակում է տրված 2D զանգվածը, որը ներկայացնում է պատկերը, կիրառելով գործողությունների շարք:\nՅուրաքանչյուր գործողություն ներկայացվում է սիմվոլով:\n'A' - Պատկերը պտտել 90 աստիճան ժամացույցի սլաքի ուղղությամբ:\n'B' - Պատկերը պտտել 90 աստիճան ժամացույցի սլաքի հակառակ ուղղությամբ:\n'C' - Պատկերը հորիզոնական շրջել:\n'D' - Պատկերը ուղղահայաց շրջել:\n\n@param image 2D ամբողջ թվերի զանգված, որը ներկայացնում է պատկերի պիքսելների մոխրագույնի արժեքները:\n@param operations Սիմվոլների տող, որը ներկայացնում է հերթականությամբ կիրառվող գործողությունները:\n@return 2D ամբողջ թվերի զանգված, որը ներկայացնում է մշակված պատկերը:\n\nՕրինակ:\n>>> processImage(arrayOf(arrayOf(10, 0, 10), arrayOf(100, 100, 10)), \"AC\")\narrayOf(arrayOf(10, 100), arrayOf(0, 100), arrayOf(10, 10))",
      "bn": "Kotlin ফাংশন `fun processImage(image: Array<Array<Int>>, operations: String): Array<Array<Int>>` লিখুন নিম্নলিখিত সমস্যার সমাধানের জন্য:\nএকটি প্রদত্ত 2D অ্যারে প্রক্রিয়া করে যা একটি চিত্র উপস্থাপন করে, একাধিক অপারেশন প্রয়োগ করে।\nপ্রতিটি অপারেশন একটি অক্ষর দ্বারা উপস্থাপিত হয়:\n'A' - চিত্রটিকে 90 ডিগ্রি ঘড়ির কাঁটার দিকে ঘোরান।\n'B' - চিত্রটিকে 90 ডিগ্রি ঘড়ির কাঁটার বিপরীতে ঘোরান।\n'C' - চিত্রটিকে অনুভূমিকভাবে উল্টান।\n'D' - চিত্রটিকে উল্লম্বভাবে উল্টান।\n\n@param image পূর্ণসংখ্যার একটি 2D অ্যারে যা চিত্রের পিক্সেলের গ্রেস্কেল মানগুলি উপস্থাপন করে।\n@param operations একটি অক্ষরের স্ট্রিং যা ক্রমানুসারে প্রয়োগ করার জন্য অপারেশনগুলি উপস্থাপন করে।\n@return পূর্ণসংখ্যার একটি 2D অ্যারে যা প্রক্রিয়াজাত চিত্র উপস্থাপন করে।\n\nউদাহরণ:\n>>> processImage(arrayOf(arrayOf(10, 0, 10), arrayOf(100, 100, 10)), \"AC\")\narrayOf(arrayOf(10, 100), arrayOf(0, 100), arrayOf(10, 10))",
      "bg": "Напишете Kotlin функция `fun processImage(image: Array<Array<Int>>, operations: String): Array<Array<Int>>`, за да решите следния проблем:\nОбработва даден 2D масив, представляващ изображение, прилагайки серия от операции.\nВсяка операция е представена с характер:\n'A' - Завъртете изображението на 90 градуса по часовниковата стрелка.\n'B' - Завъртете изображението на 90 градуса обратно на часовниковата стрелка.\n'C' - Обърнете изображението хоризонтално.\n'D' - Обърнете изображението вертикално.\n\n@param image 2D масив от цели числа, представляващи стойностите на сивото на пикселите на изображението.\n@param operations Низ от символи, представляващи операциите, които трябва да бъдат приложени последователно.\n@return 2D масив от цели числа, представляващи обработеното изображение.\n\nПример:\n>>> processImage(arrayOf(arrayOf(10, 0, 10), arrayOf(100, 100, 10)), \"AC\")\narrayOf(arrayOf(10, 100), arrayOf(0, 100), arrayOf(10, 10))",
      "zh": "编写一个 Kotlin 函数 `fun processImage(image: Array<Array<Int>>, operations: String): Array<Array<Int>>` 来解决以下问题：\n处理给定的二维数组表示的图像，应用一系列操作。\n每个操作由一个字符表示：\n'A' - 将图像顺时针旋转90度。\n'B' - 将图像逆时针旋转90度。\n'C' - 水平翻转图像。\n'D' - 垂直翻转图像。\n\n@param image 一个二维整数数组，表示图像的像素灰度值。\n@param operations 一个字符串，表示要按顺序应用的操作。\n@return 一个二维整数数组，表示处理后的图像。\n\n示例：\n>>> processImage(arrayOf(arrayOf(10, 0, 10), arrayOf(100, 100, 10)), \"AC\")\narrayOf(arrayOf(10, 100), arrayOf(0, 100), arrayOf(10, 10))",
      "fr": "Écrire une fonction Kotlin `fun processImage(image: Array<Array<Int>>, operations: String): Array<Array<Int>>` pour résoudre le problème suivant :  \nTraite un tableau 2D donné représentant une image, en appliquant une série d'opérations.  \nChaque opération est représentée par un caractère :  \n'A' - Faire pivoter l'image de 90 degrés dans le sens des aiguilles d'une montre.  \n'B' - Faire pivoter l'image de 90 degrés dans le sens inverse des aiguilles d'une montre.  \n'C' - Retourner l'image horizontalement.  \n'D' - Retourner l'image verticalement.  \n\n@param image Un tableau 2D d'entiers représentant les valeurs de niveaux de gris des pixels de l'image.  \n@param operations Une chaîne de caractères représentant les opérations à appliquer en séquence.  \n@return Un tableau 2D d'entiers représentant l'image traitée.  \n\nExemple :  \n>>> processImage(arrayOf(arrayOf(10, 0, 10), arrayOf(100, 100, 10)), \"AC\")  \narrayOf(arrayOf(10, 100), arrayOf(0, 100), arrayOf(10, 10))",
      "de": "Schreiben Sie eine Kotlin-Funktion `fun processImage(image: Array<Array<Int>>, operations: String): Array<Array<Int>>`, um das folgende Problem zu lösen:\nVerarbeitet ein gegebenes 2D-Array, das ein Bild darstellt, und wendet eine Reihe von Operationen an.\nJede Operation wird durch ein Zeichen dargestellt:\n'A' - Dreht das Bild um 90 Grad im Uhrzeigersinn.\n'B' - Dreht das Bild um 90 Grad gegen den Uhrzeigersinn.\n'C' - Spiegelt das Bild horizontal.\n'D' - Spiegelt das Bild vertikal.\n\n@param image Ein 2D-Array von Ganzzahlen, das die Graustufenwerte der Bildpixel darstellt.\n@param operations Ein Zeichenstring, der die in Reihenfolge anzuwendenden Operationen darstellt.\n@return Ein 2D-Array von Ganzzahlen, das das verarbeitete Bild darstellt.\n\nBeispiel:\n>>> processImage(arrayOf(arrayOf(10, 0, 10), arrayOf(100, 100, 10)), \"AC\")\narrayOf(arrayOf(10, 100), arrayOf(0, 100), arrayOf(10, 10))",
      "ha": "Rubuta aikin Kotlin `fun processImage(image: Array<Array<Int>>, operations: String): Array<Array<Int>>` don warware matsalar mai zuwa:\nYana aiwatar da wani 2D array da ke wakiltar hoto, yana amfani da jerin ayyuka.\nKowane aiki yana wakiltar wata alama:\n'A' - Juya hoton digiri 90 a agogo.\n'B' - Juya hoton digiri 90 ba tare da agogo ba.\n'C' - Juya hoton a kwance.\n'D' - Juya hoton a tsaye.\n\n@param image Wani 2D array na lambobi da ke wakiltar ƙimar launin toka na pixel na hoton.\n@param operations Wani jeri na haruffa da ke wakiltar ayyukan da za a yi amfani da su a jere.\n@return Wani 2D array na lambobi da ke wakiltar hoton da aka aiwatar.\n\nMisali:\n>>> processImage(arrayOf(arrayOf(10, 0, 10), arrayOf(100, 100, 10)), \"AC\")\narrayOf(arrayOf(10, 100), arrayOf(0, 100), arrayOf(10, 10))",
      "hi": "Kotlin फ़ंक्शन `fun processImage(image: Array<Array<Int>>, operations: String): Array<Array<Int>>` लिखें ताकि निम्नलिखित समस्या का समाधान किया जा सके:\nएक दिए गए 2D array को प्रोसेस करता है जो एक छवि का प्रतिनिधित्व करता है, और एक श्रृंखला में दिए गए ऑपरेशनों को लागू करता है।\nप्रत्येक ऑपरेशन को एक वर्ण द्वारा दर्शाया जाता है:\n'A' - छवि को 90 डिग्री क्लॉकवाइज़ घुमाएं।\n'B' - छवि को 90 डिग्री एंटी-क्लॉकवाइज़ घुमाएं।\n'C' - छवि को क्षैतिज रूप से पलटें।\n'D' - छवि को लंबवत रूप से पलटें।\n\n@param image पूर्णांकों का एक 2D array जो छवि के पिक्सेल ग्रेस्केल मानों का प्रतिनिधित्व करता है।\n@param operations वर्णों की एक स्ट्रिंग जो अनुक्रम में लागू किए जाने वाले ऑपरेशनों का प्रतिनिधित्व करती है।\n@return पूर्णांकों का एक 2D array जो प्रोसेस की गई छवि का प्रतिनिधित्व करता है।\n\nउदाहरण:\n>>> processImage(arrayOf(arrayOf(10, 0, 10), arrayOf(100, 100, 10)), \"AC\")\narrayOf(arrayOf(10, 100), arrayOf(0, 100), arrayOf(10, 10))",
      "hu": "Írj egy Kotlin függvényt `fun processImage(image: Array<Array<Int>>, operations: String): Array<Array<Int>>` a következő probléma megoldására:\nEgy adott 2D tömböt, amely egy képet ábrázol, feldolgoz, alkalmazva egy sor műveletet.\nMinden műveletet egy karakter képvisel:\n'A' - Forgassa el a képet 90 fokkal az óramutató járásával megegyező irányba.\n'B' - Forgassa el a képet 90 fokkal az óramutató járásával ellentétes irányba.\n'C' - Fordítsa meg a képet vízszintesen.\n'D' - Fordítsa meg a képet függőlegesen.\n\n@param image Egy 2D tömb egész számokkal, amely a kép pixeleinek szürkeárnyalatos értékeit ábrázolja.\n@param operations Egy karakterlánc, amely a sorban alkalmazandó műveleteket képviseli.\n@return Egy 2D tömb egész számokkal, amely a feldolgozott képet ábrázolja.\n\nPélda:\n>>> processImage(arrayOf(arrayOf(10, 0, 10), arrayOf(100, 100, 10)), \"AC\")\narrayOf(arrayOf(10, 100), arrayOf(0, 100), arrayOf(10, 10))"
    },
    "instruction_bertscore": {
      "sq": "0.9645101139293534",
      "hy": "0.9746754209395759",
      "bn": "0.9728748365354947",
      "bg": "0.9722584864631434",
      "zh": "0.970725258551935",
      "fr": "0.9909960848276885",
      "de": "0.9744632836926307",
      "ha": "0.9712333550666223",
      "hi": "0.9784414529639974",
      "hu": "0.9909960848276885"
    },
    "level": "hard",
    "test": "fun main() {\n    val image1 = arrayOf(arrayOf(10, 0, 10), arrayOf(100, 100, 10))\n    val result1 = processImage(image1, \"AC\")\n    check(result1.contentDeepEquals(arrayOf(arrayOf(10, 100), arrayOf(0, 100), arrayOf(10, 10))))\n\n    val image2 = arrayOf(arrayOf(1, 2), arrayOf(3, 4))\n    val result2 = processImage(image2, \"A\")\n    check(result2.contentDeepEquals(arrayOf(arrayOf(3, 1), arrayOf(4, 2))))\n\n    val result3 = processImage(image2, \"B\")\n    check(result3.contentDeepEquals(arrayOf(arrayOf(2, 4), arrayOf(1, 3))))\n\n    val result4 = processImage(image2, \"BD\")\n    check(result4.contentDeepEquals(arrayOf(arrayOf(1, 3), arrayOf(2, 4))))\n\n}\n\nmain()",
    "entry_point": "processImage",
    "signature": "fun processImage(image: Array<Array<Int>>, operations: String): Array<Array<Int>>",
    "docstring": {
      "en": "Processes a given 2D array representing an image, applying a series of operations.\nEach operation is represented by a character:\n'A' - Rotate the image 90 degrees clockwise.\n'B' - Rotate the image 90 degrees counterclockwise.\n'C' - Flip the image horizontally.\n'D' - Flip the image vertically.\n\n@param image A 2D array of integers representing the image's pixel grayscale values.\n@param operations A string of characters representing the operations to be applied in sequence.\n@return A 2D array of integers representing the processed image.\n\nExample:\n>>> processImage(arrayOf(arrayOf(10, 0, 10), arrayOf(100, 100, 10)), \"AC\")\narrayOf(arrayOf(10, 100), arrayOf(0, 100), arrayOf(10, 10))",
      "sq": "Përpunon një varg 2D të dhënë që përfaqëson një imazh, duke aplikuar një seri operacionesh. \nÇdo operacion përfaqësohet nga një karakter: \n'A' - Rrotullo imazhin 90 gradë në drejtim të akrepave të orës. \n'B' - Rrotullo imazhin 90 gradë kundër akrepave të orës. \n'C' - Përmbys imazhin horizontalisht. \n'D' - Përmbys imazhin vertikalisht.\n\n@param image Një varg 2D i numrave të plotë që përfaqëson vlerat e shkallës gri të pikselave të imazhit.\n@param operations Një varg karakteresh që përfaqësojnë operacionet që do të aplikohen në sekuencë.\n@return Një varg 2D i numrave të plotë që përfaqëson imazhin e përpunuar.\n\nShembull:\n>>> processImage(arrayOf(arrayOf(10, 0, 10), arrayOf(100, 100, 10)), \"AC\")\narrayOf(arrayOf(10, 100), arrayOf(0, 100), arrayOf(10, 10))",
      "hy": "Տվյալ 2D զանգվածը, որը ներկայացնում է պատկերը, մշակում է գործողությունների շարք կիրառելով: \nՅուրաքանչյուր գործողություն ներկայացված է սիմվոլով:\n'A' - Պատկերը պտտել 90 աստիճան ժամացույցի սլաքի ուղղությամբ:\n'B' - Պատկերը պտտել 90 աստիճան ժամացույցի սլաքի հակառակ ուղղությամբ:\n'C' - Պատկերը հորիզոնական շրջել:\n'D' - Պատկերը ուղղահայաց շրջել:\n\n@param image Միջակայքի ամբողջ թվերի 2D զանգված, որը ներկայացնում է պատկերի պիքսելների մոխրագույնի արժեքները:\n@param operations Սիմվոլների տող, որը ներկայացնում է հերթականությամբ կիրառվելիք գործողությունները:\n@return Միջակայքի ամբողջ թվերի 2D զանգված, որը ներկայացնում է մշակված պատկերը:\n\nՕրինակ:\n>>> processImage(arrayOf(arrayOf(10, 0, 10), arrayOf(100, 100, 10)), \"AC\")\narrayOf(arrayOf(10, 100), arrayOf(0, 100), arrayOf(10, 10))",
      "bn": "একটি প্রদত্ত 2D অ্যারে প্রক্রিয়াকরণ করে যা একটি চিত্রকে উপস্থাপন করে, একটি সিরিজ অপারেশন প্রয়োগ করে। প্রতিটি অপারেশন একটি অক্ষর দ্বারা উপস্থাপিত হয়:\n'A' - চিত্রটিকে ৯০ ডিগ্রি ঘড়ির কাঁটার দিকে ঘোরান।\n'B' - চিত্রটিকে ৯০ ডিগ্রি ঘড়ির কাঁটার বিপরীতে ঘোরান।\n'C' - চিত্রটিকে অনুভূমিকভাবে উল্টান।\n'D' - চিত্রটিকে উল্লম্বভাবে উল্টান।\n\n@param image একটি 2D পূর্ণসংখ্যার অ্যারে যা চিত্রের পিক্সেলের গ্রেস্কেল মানগুলি উপস্থাপন করে।\n@param operations একটি অক্ষরের স্ট্রিং যা ক্রমানুসারে প্রয়োগ করার জন্য অপারেশনগুলি উপস্থাপন করে।\n@return একটি 2D পূর্ণসংখ্যার অ্যারে যা প্রক্রিয়াকৃত চিত্রকে উপস্থাপন করে।\n\nউদাহরণ:\n>>> processImage(arrayOf(arrayOf(10, 0, 10), arrayOf(100, 100, 10)), \"AC\")\narrayOf(arrayOf(10, 100), arrayOf(0, 100), arrayOf(10, 10))",
      "bg": "Обработва даден 2D масив, представляващ изображение, прилагайки серия от операции. Всяка операция е представена от символ: 'A' - Завърта изображението на 90 градуса по часовниковата стрелка. 'B' - Завърта изображението на 90 градуса обратно на часовниковата стрелка. 'C' - Обръща изображението хоризонтално. 'D' - Обръща изображението вертикално.\n\n@param image 2D масив от цели числа, представляващ стойностите на сивото на пикселите на изображението. @param operations Низ от символи, представляващ операциите, които трябва да бъдат приложени последователно. @return 2D масив от цели числа, представляващ обработеното изображение.\n\nПример:\n>>> processImage(arrayOf(arrayOf(10, 0, 10), arrayOf(100, 100, 10)), \"AC\")\narrayOf(arrayOf(10, 100), arrayOf(0, 100), arrayOf(10, 10))",
      "zh": "处理给定的表示图像的二维数组，应用一系列操作。\n每个操作由一个字符表示：\n'A' - 将图像顺时针旋转90度。  \n'B' - 将图像逆时针旋转90度。  \n'C' - 水平翻转图像。  \n'D' - 垂直翻转图像。\n\n@param image 一个整数的二维数组，表示图像的像素灰度值。  \n@param operations 一个字符字符串，表示按顺序应用的操作。  \n@return 一个整数的二维数组，表示处理后的图像。\n\n示例：\n>>> processImage(arrayOf(arrayOf(10, 0, 10), arrayOf(100, 100, 10)), \"AC\")\narrayOf(arrayOf(10, 100), arrayOf(0, 100), arrayOf(10, 10))",
      "fr": "Traite un tableau 2D donné représentant une image, en appliquant une série d'opérations.  \nChaque opération est représentée par un caractère :  \n'A' - Tourner l'image de 90 degrés dans le sens des aiguilles d'une montre.  \n'B' - Tourner l'image de 90 degrés dans le sens inverse des aiguilles d'une montre.  \n'C' - Retourner l'image horizontalement.  \n'D' - Retourner l'image verticalement.  \n\n@param image Un tableau 2D d'entiers représentant les valeurs de gris des pixels de l'image.  \n@param operations Une chaîne de caractères représentant les opérations à appliquer en séquence.  \n@return Un tableau 2D d'entiers représentant l'image traitée.  \n\nExemple :  \n>>> processImage(arrayOf(arrayOf(10, 0, 10), arrayOf(100, 100, 10)), \"AC\")  \narrayOf(arrayOf(10, 100), arrayOf(0, 100), arrayOf(10, 10))",
      "de": "Verarbeitet ein gegebenes 2D-Array, das ein Bild darstellt, und wendet eine Reihe von Operationen an.  \nJede Operation wird durch ein Zeichen dargestellt:  \n'A' - Dreht das Bild um 90 Grad im Uhrzeigersinn.  \n'B' - Dreht das Bild um 90 Grad gegen den Uhrzeigersinn.  \n'C' - Spiegelt das Bild horizontal.  \n'D' - Spiegelt das Bild vertikal.  \n\n@param image Ein 2D-Array von Ganzzahlen, das die Graustufenwerte der Bildpixel darstellt.  \n@param operations Ein String von Zeichen, der die in Reihenfolge anzuwendenden Operationen darstellt.  \n@return Ein 2D-Array von Ganzzahlen, das das verarbeitete Bild darstellt.  \n\nBeispiel:  \n>>> processImage(arrayOf(arrayOf(10, 0, 10), arrayOf(100, 100, 10)), \"AC\")  \narrayOf(arrayOf(10, 100), arrayOf(0, 100), arrayOf(10, 10))  ",
      "ha": "Yana sarrafa wani tsararren 2D da aka bayar wanda ke wakiltar hoto, yana amfani da jerin ayyuka.\nKowane aiki yana wakilta ta wata alama:  \n'A' - Juya hoton digiri 90 a agogo.  \n'B' - Juya hoton digiri 90 ba a agogo ba.  \n'C' - Juya hoton a kwance.  \n'D' - Juya hoton a tsaye.  \n\n@param image Wani tsari na 2D na lambobi da ke wakiltar ƙimar launin toka na pixel na hoton.  \n@param operations Wani jeren haruffa da ke wakiltar ayyukan da za a yi a jere.  \n@return Wani tsari na 2D na lambobi da ke wakiltar hoton da aka sarrafa.  \n\nExample:  \n>>> processImage(arrayOf(arrayOf(10, 0, 10), arrayOf(100, 100, 10)), \"AC\")  \narrayOf(arrayOf(10, 100), arrayOf(0, 100), arrayOf(10, 10))  ",
      "hi": "दिए गए 2D एरे को प्रोसेस करता है जो एक छवि का प्रतिनिधित्व करता है, और एक श्रृंखला में संचालन लागू करता है। \nप्रत्येक ऑपरेशन को एक अक्षर द्वारा दर्शाया जाता है:\n'A' - छवि को 90 डिग्री घड़ी की दिशा में घुमाएँ।\n'B' - छवि को 90 डिग्री घड़ी की विपरीत दिशा में घुमाएँ।\n'C' - छवि को क्षैतिज रूप से पलटें।\n'D' - छवि को लंबवत रूप से पलटें।\n\n@param image पूर्णांकों का एक 2D एरे जो छवि के पिक्सेल ग्रेस्केल मानों का प्रतिनिधित्व करता है।\n@param operations अक्षरों की एक स्ट्रिंग जो अनुक्रम में लागू किए जाने वाले ऑपरेशनों का प्रतिनिधित्व करती है।\n@return पूर्णांकों का एक 2D एरे जो प्रोसेस की गई छवि का प्रतिनिधित्व करता है।\n\nउदाहरण:\n>>> processImage(arrayOf(arrayOf(10, 0, 10), arrayOf(100, 100, 10)), \"AC\")\narrayOf(arrayOf(10, 100), arrayOf(0, 100), arrayOf(10, 10))",
      "hu": "Egy adott 2D-s tömböt dolgoz fel, amely egy képet ábrázol, és egy sor műveletet alkalmaz.\nMinden műveletet egy karakter képvisel:\n'A' - A képet 90 fokkal az óramutató járásával megegyező irányba forgatja.\n'B' - A képet 90 fokkal az óramutató járásával ellentétes irányba forgatja.\n'C' - A képet vízszintesen tükrözi.\n'D' - A képet függőlegesen tükrözi.\n\n@param image Egy 2D-s tömb, amely a kép pixeleinek szürkeárnyalatos értékeit ábrázolja.\n@param operations Egy karakterlánc, amely a sorban alkalmazandó műveleteket képviseli.\n@return Egy 2D-s tömb, amely a feldolgozott képet ábrázolja.\n\nPélda:\n>>> processImage(arrayOf(arrayOf(10, 0, 10), arrayOf(100, 100, 10)), \"AC\")\narrayOf(arrayOf(10, 100), arrayOf(0, 100), arrayOf(10, 10))"
    },
    "docstring_bertscore": {
      "sq": "0.9907466050691087",
      "hy": "0.9815381006043313",
      "bn": "0.9791239469532332",
      "bg": "0.9538587583767386",
      "zh": "0.9701992853029547",
      "fr": "0.9885763695259215",
      "de": "0.9686318929662084",
      "ha": "0.9802702428821856",
      "hi": "0.9858744004527039",
      "hu": "0.9591421278818856"
    }
  },
  {
    "task_id": "Kotlin/27",
    "prompt": {
      "en": "/**\n    * Finds all prime pairs where each prime is less than or equal to a given number and the pair differs by 2.\n    * A prime pair is defined as two prime numbers where the difference between them is exactly 2.\n    * Example:\n    * >>> findPrimePairs(10)\n        [(3, 5), (5, 7)]\n    * >>> findPrimePairs(100)\n        [(3, 5), (5, 7), (11, 13), (17, 19), (29, 31), (41, 43), (59, 61), (71, 73)]\n**/\n\nfun findPrimePairs(maxNumber: Int): List<Pair<Int, Int>> ",
      "sq": "/**\n    * Gjen të gjitha çiftet e numrave të thjeshtë ku secili numër i thjeshtë është më i vogël ose i barabartë me një numër të dhënë dhe çifti ndryshon me 2.\n    * Një çift numrash të thjeshtë përcaktohet si dy numra të thjeshtë ku diferenca midis tyre është saktësisht 2.\n    * Shembull:\n    * >>> findPrimePairs(10)\n        [(3, 5), (5, 7)]\n    * >>> findPrimePairs(100)\n        [(3, 5), (5, 7), (11, 13), (17, 19), (29, 31), (41, 43), (59, 61), (71, 73)]\n**/",
      "hy": "/**\n    * Գտնում է բոլոր պարզ թվերի զույգերը, որտեղ յուրաքանչյուր պարզ թիվ փոքր կամ հավասար է տրված թվին, և զույգը տարբերվում է 2-ով:\n    * Պարզ թվերի զույգը սահմանվում է որպես երկու պարզ թվեր, որոնց միջև տարբերությունը հենց 2 է:\n    * Օրինակ:\n    * >>> findPrimePairs(10)\n        [(3, 5), (5, 7)]\n    * >>> findPrimePairs(100)\n        [(3, 5), (5, 7), (11, 13), (17, 19), (29, 31), (41, 43), (59, 61), (71, 73)]\n**/",
      "bn": "/**\n    * প্রতিটি মৌলিক সংখ্যা একটি প্রদত্ত সংখ্যার চেয়ে কম বা সমান যেখানে প্রতিটি জোড়া 2 দ্বারা পৃথক হয় এমন সমস্ত মৌলিক জোড়া খুঁজে বের করে।\n    * একটি মৌলিক জোড়া হল দুটি মৌলিক সংখ্যা যেখানে তাদের মধ্যে পার্থক্য ঠিক 2।\n    * উদাহরণ:\n    * >>> findPrimePairs(10)\n        [(3, 5), (5, 7)]\n    * >>> findPrimePairs(100)\n        [(3, 5), (5, 7), (11, 13), (17, 19), (29, 31), (41, 43), (59, 61), (71, 73)]\n**/",
      "bg": "/**\n    * Намира всички двойки прости числа, където всяко просто число е по-малко или равно на дадено число и двойката се различава с 2.\n    * Двойка прости числа се определя като две прости числа, където разликата между тях е точно 2.\n    * Пример:\n    * >>> findPrimePairs(10)\n        [(3, 5), (5, 7)]\n    * >>> findPrimePairs(100)\n        [(3, 5), (5, 7), (11, 13), (17, 19), (29, 31), (41, 43), (59, 61), (71, 73)]\n**/",
      "zh": "/**\n    * 查找所有素数对，其中每个素数小于或等于给定的数字，并且该对相差2。\n    * 素数对被定义为两个素数，其中它们之间的差恰好为2。\n    * 示例：\n    * >>> findPrimePairs(10)\n        [(3, 5), (5, 7)]\n    * >>> findPrimePairs(100)\n        [(3, 5), (5, 7), (11, 13), (17, 19), (29, 31), (41, 43), (59, 61), (71, 73)]\n**/",
      "fr": "/**\n    * Trouve toutes les paires de nombres premiers où chaque nombre premier est inférieur ou égal à un nombre donné et où la paire diffère de 2.\n    * Une paire de nombres premiers est définie comme deux nombres premiers dont la différence est exactement de 2.\n    * Exemple :\n    * >>> findPrimePairs(10)\n        [(3, 5), (5, 7)]\n    * >>> findPrimePairs(100)\n        [(3, 5), (5, 7), (11, 13), (17, 19), (29, 31), (41, 43), (59, 61), (71, 73)]\n**/",
      "de": "/**\n    * Findet alle Primzahlpaare, bei denen jede Primzahl kleiner oder gleich einer gegebenen Zahl ist und das Paar sich um 2 unterscheidet.\n    * Ein Primzahlpaar wird definiert als zwei Primzahlen, bei denen der Unterschied genau 2 beträgt.\n    * Beispiel:\n    * >>> findPrimePairs(10)\n        [(3, 5), (5, 7)]\n    * >>> findPrimePairs(100)\n        [(3, 5), (5, 7), (11, 13), (17, 19), (29, 31), (41, 43), (59, 61), (71, 73)]\n**/",
      "ha": "/**\n    * Nemi duk ma'auratan lambobin farko inda kowanne lamba na farko ya kasance ƙasa ko daidai da wata lamba da aka bayar kuma bambancin ma'auratan ya zama 2.\n    * An ayyana ma'auratan lambobin farko a matsayin lambobi biyu na farko inda bambancin tsakanin su yake daidai da 2.\n    * Misali:\n    * >>> findPrimePairs(10)\n        [(3, 5), (5, 7)]\n    * >>> findPrimePairs(100)\n        [(3, 5), (5, 7), (11, 13), (17, 19), (29, 31), (41, 43), (59, 61), (71, 73)]\n**/",
      "hi": "/**\n    * सभी अभाज्य युग्मों को खोजता है जहाँ प्रत्येक अभाज्य संख्या एक दिए गए संख्या से कम या उसके बराबर होती है और युग्म में 2 का अंतर होता है।\n    * एक अभाज्य युग्म को दो अभाज्य संख्याओं के रूप में परिभाषित किया जाता है जहाँ उनके बीच का अंतर ठीक 2 होता है।\n    * उदाहरण:\n    * >>> findPrimePairs(10)\n        [(3, 5), (5, 7)]\n    * >>> findPrimePairs(100)\n        [(3, 5), (5, 7), (11, 13), (17, 19), (29, 31), (41, 43), (59, 61), (71, 73)]\n**/",
      "hu": "/**\n    * Megtalálja az összes prímszám párt, ahol minden prímszám kisebb vagy egyenlő egy adott számnál, és a pár különbsége 2.\n    * Egy prímszám pár két prímszámból áll, ahol a különbség pontosan 2.\n    * Példa:\n    * >>> findPrimePairs(10)\n        [(3, 5), (5, 7)]\n    * >>> findPrimePairs(100)\n        [(3, 5), (5, 7), (11, 13), (17, 19), (29, 31), (41, 43), (59, 61), (71, 73)]\n**/"
    },
    "prompt_bertscore": {
      "sq": "0.9235298854965215",
      "hy": "0.9203917241065513",
      "bn": "0.9327842735793179",
      "bg": "0.9235298854965215",
      "zh": "0.9441401710934636",
      "fr": "0.9252770383281044",
      "de": "0.9451319325859707",
      "ha": "0.9201631005379801",
      "hi": "0.9303580034749768",
      "hu": "0.9194782229841718"
    },
    "canonical_solution": "{\n    fun isPrime(num: Int): Boolean {\n        if (num <= 1) return false\n        for (i in 2 until num) {\n            if (num % i == 0) return false\n        }\n        return true\n    }\n\n    val pairs = mutableListOf<Pair<Int, Int>>()\n    for (i in 2..maxNumber - 2) {\n        if (isPrime(i) && isPrime(i + 2)) {\n            pairs.add(Pair(i, i + 2))\n        }\n    }\n    return pairs\n}",
    "instruction": {
      "en": "Write a Kotlin function `fun findPrimePairs(maxNumber: Int): List<Pair<Int, Int>>` to solve the following problem:\nFinds all prime pairs where each prime is less than or equal to a given number and the pair differs by 2.\nA prime pair is defined as two prime numbers where the difference between them is exactly 2.\nExample:\n>>> findPrimePairs(10)\n[(3, 5), (5, 7)]\n>>> findPrimePairs(100)\n[(3, 5), (5, 7), (11, 13), (17, 19), (29, 31), (41, 43), (59, 61), (71, 73)]",
      "sq": "Shkruani një funksion Kotlin `fun findPrimePairs(maxNumber: Int): List<Pair<Int, Int>>` për të zgjidhur problemin në vijim:\nGjen të gjitha çiftet prime ku çdo numër prim është më i vogël ose i barabartë me një numër të dhënë dhe çifti ndryshon me 2.\nNjë çift prim është i përcaktuar si dy numra primë ku diferenca midis tyre është saktësisht 2.\nShembull:\n>>> findPrimePairs(10)\n[(3, 5), (5, 7)]\n>>> findPrimePairs(100)\n[(3, 5), (5, 7), (11, 13), (17, 19), (29, 31), (41, 43), (59, 61), (71, 73)]",
      "hy": "Գրեք Kotlin ֆունկցիա `fun findPrimePairs(maxNumber: Int): List<Pair<Int, Int>>` հետևյալ խնդիրը լուծելու համար:\nԳտնում է բոլոր պարզ զույգերը, որտեղ յուրաքանչյուր պարզ թիվ փոքր կամ հավասար է տրված թվին, և զույգը տարբերվում է 2-ով:\nՊարզ զույգը սահմանվում է որպես երկու պարզ թվեր, որոնց միջև տարբերությունը ճիշտ 2 է:\nՕրինակ:\n>>> findPrimePairs(10)\n[(3, 5), (5, 7)]\n>>> findPrimePairs(100)\n[(3, 5), (5, 7), (11, 13), (17, 19), (29, 31), (41, 43), (59, 61), (71, 73)]",
      "bn": "একটি Kotlin ফাংশন `fun findPrimePairs(maxNumber: Int): List<Pair<Int, Int>>` লিখুন নিম্নলিখিত সমস্যার সমাধানের জন্য:\nসকল মৌলিক জোড়া খুঁজে বের করে যেখানে প্রতিটি মৌলিক সংখ্যা একটি প্রদত্ত সংখ্যার চেয়ে কম বা সমান এবং জোড়ার পার্থক্য ২।\nএকটি মৌলিক জোড়া সংজ্ঞায়িত হয় দুটি মৌলিক সংখ্যা হিসেবে যেখানে তাদের মধ্যে পার্থক্য ঠিক ২।\nউদাহরণ:\n>>> findPrimePairs(10)\n[(3, 5), (5, 7)]\n>>> findPrimePairs(100)\n[(3, 5), (5, 7), (11, 13), (17, 19), (29, 31), (41, 43), (59, 61), (71, 73)]",
      "bg": "Напишете Kotlin функция `fun findPrimePairs(maxNumber: Int): List<Pair<Int, Int>>`, за да решите следния проблем:\nНамира всички двойки прости числа, където всяко просто число е по-малко или равно на дадено число и двойката се различава с 2.\nДвойка прости числа е дефинирана като две прости числа, където разликата между тях е точно 2.\nПример:\n>>> findPrimePairs(10)\n[(3, 5), (5, 7)]\n>>> findPrimePairs(100)\n[(3, 5), (5, 7), (11, 13), (17, 19), (29, 31), (41, 43), (59, 61), (71, 73)]",
      "zh": "编写一个 Kotlin 函数 `fun findPrimePairs(maxNumber: Int): List<Pair<Int, Int>>` 来解决以下问题：\n查找所有素数对，其中每个素数小于或等于给定的数字，并且这对素数相差为 2。\n素数对被定义为两个素数，它们之间的差正好为 2。\n示例:\n>>> findPrimePairs(10)\n[(3, 5), (5, 7)]\n>>> findPrimePairs(100)\n[(3, 5), (5, 7), (11, 13), (17, 19), (29, 31), (41, 43), (59, 61), (71, 73)]",
      "fr": "Écrire une fonction Kotlin `fun findPrimePairs(maxNumber: Int): List<Pair<Int, Int>>` pour résoudre le problème suivant :\nTrouve toutes les paires de nombres premiers où chaque nombre premier est inférieur ou égal à un nombre donné et où la paire diffère de 2.\nUne paire de nombres premiers est définie comme deux nombres premiers dont la différence est exactement de 2.\nExemple :\n>>> findPrimePairs(10)\n[(3, 5), (5, 7)]\n>>> findPrimePairs(100)\n[(3, 5), (5, 7), (11, 13), (17, 19), (29, 31), (41, 43), (59, 61), (71, 73)]",
      "de": "Schreiben Sie eine Kotlin-Funktion `fun findPrimePairs(maxNumber: Int): List<Pair<Int, Int>>`, um das folgende Problem zu lösen:\nFindet alle Primzahlpaare, bei denen jede Primzahl kleiner oder gleich einer gegebenen Zahl ist und das Paar sich um 2 unterscheidet.\nEin Primzahlpaar ist definiert als zwei Primzahlen, bei denen der Unterschied zwischen ihnen genau 2 beträgt.\nBeispiel:\n>>> findPrimePairs(10)\n[(3, 5), (5, 7)]\n>>> findPrimePairs(100)\n[(3, 5), (5, 7), (11, 13), (17, 19), (29, 31), (41, 43), (59, 61), (71, 73)]",
      "ha": "Rubuta aikin Kotlin `fun findPrimePairs(maxNumber: Int): List<Pair<Int, Int>>` don warware matsalar mai zuwa:\nNemo duk ma'auratan lambobi masu lamba inda kowanne lamba bai wuce wani adadi da aka bayar ba kuma bambancin ma'auratan ya kasance 2.\nAn ayyana ma'auratan lambobi masu lamba a matsayin lambobi masu lamba biyu inda bambancin tsakaninsu yake daidai 2.\nMisali:\n>>> findPrimePairs(10)\n[(3, 5), (5, 7)]\n>>> findPrimePairs(100)\n[(3, 5), (5, 7), (11, 13), (17, 19), (29, 31), (41, 43), (59, 61), (71, 73)]",
      "hi": "Kotlin फ़ंक्शन `fun findPrimePairs(maxNumber: Int): List<Pair<Int, Int>>` लिखें ताकि निम्नलिखित समस्या का समाधान किया जा सके:\nसभी अभाज्य युग्मों को खोजें जहाँ प्रत्येक अभाज्य एक दिए गए संख्या से कम या उसके बराबर है और युग्म में 2 का अंतर है।\nएक अभाज्य युग्म को दो अभाज्य संख्याओं के रूप में परिभाषित किया जाता है जहाँ उनके बीच का अंतर ठीक 2 होता है।\nउदाहरण:\n>>> findPrimePairs(10)\n[(3, 5), (5, 7)]\n>>> findPrimePairs(100)\n[(3, 5), (5, 7), (11, 13), (17, 19), (29, 31), (41, 43), (59, 61), (71, 73)]",
      "hu": "Írj egy Kotlin függvényt `fun findPrimePairs(maxNumber: Int): List<Pair<Int, Int>>` a következő probléma megoldására:\nMegtalálja az összes prímpárt, ahol minden prímszám kisebb vagy egyenlő egy adott számnál, és a pár különbsége 2.\nEgy prímpárt két prímszámként definiálunk, ahol a különbség pontosan 2.\nPélda:\n>>> findPrimePairs(10)\n[(3, 5), (5, 7)]\n>>> findPrimePairs(100)\n[(3, 5), (5, 7), (11, 13), (17, 19), (29, 31), (41, 43), (59, 61), (71, 73)]"
    },
    "instruction_bertscore": {
      "sq": "0.9959344333609779",
      "hy": "0.9862839762983978",
      "bn": "0.9850032076014849",
      "bg": "0.9767244919503318",
      "zh": "0.9683728789493389",
      "fr": "0.9758060250684265",
      "de": "0.9961841117499388",
      "ha": "0.9607903627837131",
      "hi": "0.9814514977582001",
      "hu": "0.9806698872088278"
    },
    "level": "easy",
    "test": "fun main(){\n    check(findPrimePairs(10) == listOf(Pair(3, 5), Pair(5, 7)))\n    check(findPrimePairs(100) == listOf(Pair(3, 5), Pair(5, 7), Pair(11, 13), Pair(17, 19), Pair(29, 31), Pair(41, 43), Pair(59, 61), Pair(71, 73)))\n    check(findPrimePairs(15) == listOf(Pair(3, 5), Pair(5, 7), Pair(11, 13)))\n    check(findPrimePairs(1) == emptyList<Pair<Int, Int>>())\n}\n\n\nmain()",
    "entry_point": "findPrimePairs",
    "signature": "fun findPrimePairs(maxNumber: Int): List<Pair<Int, Int>>",
    "docstring": {
      "en": "Finds all prime pairs where each prime is less than or equal to a given number and the pair differs by 2.\nA prime pair is defined as two prime numbers where the difference between them is exactly 2.\nExample:\n>>> findPrimePairs(10)\n[(3, 5), (5, 7)]\n>>> findPrimePairs(100)\n[(3, 5), (5, 7), (11, 13), (17, 19), (29, 31), (41, 43), (59, 61), (71, 73)]",
      "sq": "Gjen të gjitha çiftet prime ku secili numër prim është më i vogël ose i barabartë me një numër të dhënë dhe çifti ndryshon me 2. Një çift prim përcaktohet si dy numra primë ku diferenca midis tyre është saktësisht 2.\nShembull:\n>>> findPrimePairs(10)\n[(3, 5), (5, 7)]\n>>> findPrimePairs(100)\n[(3, 5), (5, 7), (11, 13), (17, 19), (29, 31), (41, 43), (59, 61), (71, 73)]",
      "hy": "Գտնում է բոլոր պարզ թվերի զույգերը, որտեղ յուրաքանչյուր պարզ թիվ փոքր կամ հավասար է տրված թվին, և զույգի տարբերությունը 2 է:\nՊարզ թվերի զույգը սահմանվում է որպես երկու պարզ թվեր, որոնց միջև տարբերությունը ճիշտ 2 է:\nՕրինակ:\n>>> findPrimePairs(10)\n[(3, 5), (5, 7)]\n>>> findPrimePairs(100)\n[(3, 5), (5, 7), (11, 13), (17, 19), (29, 31), (41, 43), (59, 61), (71, 73)]",
      "bn": "প্রতিটি মৌলিক সংখ্যা একটি প্রদত্ত সংখ্যার চেয়ে কম বা সমান যেখানে এবং জোড়ার পার্থক্য 2 দ্বারা হয় এমন সমস্ত মৌলিক জোড়া খুঁজে বের করে। একটি মৌলিক জোড়া হল দুটি মৌলিক সংখ্যা যেখানে তাদের মধ্যে পার্থক্য ঠিক 2 হয়।\nউদাহরণ:\n>>> findPrimePairs(10)\n[(3, 5), (5, 7)]\n>>> findPrimePairs(100)\n[(3, 5), (5, 7), (11, 13), (17, 19), (29, 31), (41, 43), (59, 61), (71, 73)]",
      "bg": "Намира всички двойки прости числа, където всяко просто число е по-малко или равно на дадено число и двойката се различава с 2. Двойка прости числа е дефинирана като две прости числа, където разликата между тях е точно 2.\nПример:\n>>> findPrimePairs(10)\n[(3, 5), (5, 7)]\n>>> findPrimePairs(100)\n[(3, 5), (5, 7), (11, 13), (17, 19), (29, 31), (41, 43), (59, 61), (71, 73)]",
      "zh": "查找所有素数对，其中每个素数小于或等于给定的数字，并且这对素数相差2。\n素数对被定义为两个素数，它们之间的差恰好为2。\n示例：\n>>> findPrimePairs(10)\n[(3, 5), (5, 7)]\n>>> findPrimePairs(100)\n[(3, 5), (5, 7), (11, 13), (17, 19), (29, 31), (41, 43), (59, 61), (71, 73)]",
      "fr": "Trouve toutes les paires de nombres premiers où chaque nombre premier est inférieur ou égal à un nombre donné et la paire diffère de 2.  \nUne paire de nombres premiers est définie comme deux nombres premiers où la différence entre eux est exactement de 2.  \nExemple :  \n>>> findPrimePairs(10)  \n[(3, 5), (5, 7)]  \n>>> findPrimePairs(100)  \n[(3, 5), (5, 7), (11, 13), (17, 19), (29, 31), (41, 43), (59, 61), (71, 73)]",
      "de": "Findet alle Primzahlpaare, bei denen jede Primzahl kleiner oder gleich einer gegebenen Zahl ist und das Paar sich um 2 unterscheidet. Ein Primzahlpaar wird definiert als zwei Primzahlen, bei denen der Unterschied genau 2 beträgt.\nBeispiel:\n>>> findPrimePairs(10)\n[(3, 5), (5, 7)]\n>>> findPrimePairs(100)\n[(3, 5), (5, 7), (11, 13), (17, 19), (29, 31), (41, 43), (59, 61), (71, 73)]",
      "ha": "Nemo dukkan ma'aurata masu lamba masu farko inda kowanne lamba mai farko ya kasance ƙasa ko daidai da wani adadi kuma bambancin ma'auratan ya kasance 2. \nAna ayyana ma'aurata masu lamba masu farko a matsayin lambobi biyu masu farko inda bambanci tsakanin su yake daidai da 2.\nMisali:\n>>> findPrimePairs(10)\n[(3, 5), (5, 7)]\n>>> findPrimePairs(100)\n[(3, 5), (5, 7), (11, 13), (17, 19), (29, 31), (41, 43), (59, 61), (71, 73)]",
      "hi": "दिए गए संख्या से कम या उसके बराबर सभी अभाज्य युग्मों को खोजता है और युग्म में 2 का अंतर होता है।  \nएक अभाज्य युग्म को दो अभाज्य संख्याओं के रूप में परिभाषित किया जाता है जहाँ उनके बीच का अंतर ठीक 2 होता है।  \nउदाहरण:  \n>>> findPrimePairs(10)  \n[(3, 5), (5, 7)]  \n>>> findPrimePairs(100)  \n[(3, 5), (5, 7), (11, 13), (17, 19), (29, 31), (41, 43), (59, 61), (71, 73)]  ",
      "hu": "Megtalálja az összes prímszám párt, ahol minden prímszám kisebb vagy egyenlő egy adott számnál, és a pár különbsége 2.\nEgy prímszám pár két prímszámból áll, ahol a különbség pontosan 2.\nPélda:\n>>> findPrimePairs(10)\n[(3, 5), (5, 7)]\n>>> findPrimePairs(100)\n[(3, 5), (5, 7), (11, 13), (17, 19), (29, 31), (41, 43), (59, 61), (71, 73)]"
    },
    "docstring_bertscore": {
      "sq": "0.9925583127745279",
      "hy": "0.9513816388948525",
      "bn": "0.9745796810959171",
      "bg": "0.9682930295361629",
      "zh": "0.9695364557214413",
      "fr": "0.9659773965540581",
      "de": "0.9896918777458135",
      "ha": "0.9754184971950274",
      "hi": "0.9648515595543524",
      "hu": "0.9615054321554387"
    }
  },
  {
    "task_id": "Kotlin/28",
    "prompt": {
      "en": "/**\n * Converts a number from one base to another.\n * The function takes an input number as a string (which can include digits and letters),\n * the base of this number, and the target base for conversion. The bases can range from 2 to 16.\n * The output is the converted number as a string in the target base, using uppercase letters for bases above 10.\n *\n * Examples:\n * >>> convertBase(\"Aab3\", 15, 7)\n *     \"210306\"\n * >>> convertBase(\"101\", 2, 10)\n *     \"5\"\n * >>> convertBase(\"FF\", 16, 2)\n *     \"11111111\"\n */\n\nfun convertBase(inputNumber: String, fromBase: Int, toBase: Int): String ",
      "sq": "/**\n * Konverton një numër nga një bazë në një tjetër.\n * Funksioni merr një numër hyrës si një varg (i cili mund të përfshijë shifra dhe shkronja),\n * bazën e këtij numri, dhe bazën e synuar për konvertim. Bazat mund të variojnë nga 2 deri në 16.\n * Rezultati është numri i konvertuar si një varg në bazën e synuar, duke përdorur shkronja të mëdha për bazat mbi 10.\n *\n * Shembuj:\n * >>> convertBase(\"Aab3\", 15, 7)\n *     \"210306\"\n * >>> convertBase(\"101\", 2, 10)\n *     \"5\"\n * >>> convertBase(\"FF\", 16, 2)\n *     \"11111111\"\n */",
      "hy": "/**\n * Թվին փոխակերպում է մի հիմքից մյուսը:\n * Ֆունկցիան ընդունում է մուտքային թիվը որպես տող (որը կարող է ներառել թվանշաններ և տառեր),\n * այս թվի հիմքը և նպատակային հիմքը փոխակերպման համար: Հիմքերը կարող են տատանվել 2-ից 16:\n * Արդյունքը փոխակերպված թիվն է որպես տող նպատակային հիմքում՝ օգտագործելով մեծատառեր 10-ից բարձր հիմքերի համար:\n *\n * Օրինակներ:\n * >>> convertBase(\"Aab3\", 15, 7)\n *     \"210306\"\n * >>> convertBase(\"101\", 2, 10)\n *     \"5\"\n * >>> convertBase(\"FF\", 16, 2)\n *     \"11111111\"\n */",
      "bn": "/**\n * একটি সংখ্যা এক ভিত্তি থেকে অন্য ভিত্তিতে রূপান্তর করে।\n * ফাংশনটি একটি ইনপুট সংখ্যা স্ট্রিং হিসেবে গ্রহণ করে (যা সংখ্যা এবং অক্ষর অন্তর্ভুক্ত করতে পারে),\n * এই সংখ্যার ভিত্তি, এবং রূপান্তরের জন্য লক্ষ্য ভিত্তি। ভিত্তিগুলি 2 থেকে 16 পর্যন্ত হতে পারে।\n * আউটপুটটি লক্ষ্য ভিত্তিতে একটি স্ট্রিং হিসেবে রূপান্তরিত সংখ্যা, 10 এর উপরে ভিত্তির জন্য বড় হাতের অক্ষর ব্যবহার করে।\n *\n * উদাহরণ:\n * >>> convertBase(\"Aab3\", 15, 7)\n *     \"210306\"\n * >>> convertBase(\"101\", 2, 10)\n *     \"5\"\n * >>> convertBase(\"FF\", 16, 2)\n *     \"11111111\"\n */",
      "bg": "/**\n * Преобразува число от една база в друга.\n * Функцията приема входно число като низ (което може да включва цифри и букви),\n * базата на това число и целевата база за преобразуване. Базите могат да варират от 2 до 16.\n * Изходът е преобразуваното число като низ в целевата база, използвайки главни букви за бази над 10.\n *\n * Примери:\n * >>> convertBase(\"Aab3\", 15, 7)\n *     \"210306\"\n * >>> convertBase(\"101\", 2, 10)\n *     \"5\"\n * >>> convertBase(\"FF\", 16, 2)\n *     \"11111111\"\n */",
      "zh": "/**\n * 将数字从一个进制转换为另一个进制。\n * 该函数接收一个作为字符串的输入数字（可以包含数字和字母），\n * 该数字的进制，以及要转换的目标进制。进制范围可以从2到16。\n * 输出是转换后的数字，以目标进制的字符串形式表示，对于大于10的进制使用大写字母。\n *\n * 例子:\n * >>> convertBase(\"Aab3\", 15, 7)\n *     \"210306\"\n * >>> convertBase(\"101\", 2, 10)\n *     \"5\"\n * >>> convertBase(\"FF\", 16, 2)\n *     \"11111111\"\n */",
      "fr": "/**\n * Convertit un nombre d'une base à une autre.\n * La fonction prend un nombre d'entrée sous forme de chaîne (qui peut inclure des chiffres et des lettres),\n * la base de ce nombre, et la base cible pour la conversion. Les bases peuvent aller de 2 à 16.\n * La sortie est le nombre converti sous forme de chaîne dans la base cible, en utilisant des lettres majuscules pour les bases supérieures à 10.\n *\n * Exemples :\n * >>> convertBase(\"Aab3\", 15, 7)\n *     \"210306\"\n * >>> convertBase(\"101\", 2, 10)\n *     \"5\"\n * >>> convertBase(\"FF\", 16, 2)\n *     \"11111111\"\n */",
      "de": "/**\n * Konvertiert eine Zahl von einer Basis in eine andere.\n * Die Funktion nimmt eine Eingabezahlnummer als Zeichenkette (die Ziffern und Buchstaben enthalten kann),\n * die Basis dieser Zahl und die Zielbasis für die Konvertierung. Die Basen können von 2 bis 16 reichen.\n * Die Ausgabe ist die konvertierte Zahl als Zeichenkette in der Zielbasis, wobei Großbuchstaben für Basen über 10 verwendet werden.\n *\n * Beispiele:\n * >>> convertBase(\"Aab3\", 15, 7)\n *     \"210306\"\n * >>> convertBase(\"101\", 2, 10)\n *     \"5\"\n * >>> convertBase(\"FF\", 16, 2)\n *     \"11111111\"\n */",
      "ha": "/**\n * Canza lamba daga wata tushe zuwa wata.\n * Aikin yana karɓar lamba a matsayin rubutu (wanda zai iya haɗawa da lambobi da haruffa),\n * tushen wannan lambar, da kuma tushen da ake nufi don canzawa. Tushen na iya zama daga 2 zuwa 16.\n * Fitarwa ita ce lambar da aka canza a matsayin rubutu a cikin tushen da ake nufi, ta amfani da manyan haruffa don tushen sama da 10.\n *\n * Misalai:\n * >>> convertBase(\"Aab3\", 15, 7)\n *     \"210306\"\n * >>> convertBase(\"101\", 2, 10)\n *     \"5\"\n * >>> convertBase(\"FF\", 16, 2)\n *     \"11111111\"\n */",
      "hi": "/**\n * एक संख्या को एक आधार से दूसरे आधार में परिवर्तित करता है।\n * फ़ंक्शन एक इनपुट संख्या को एक स्ट्रिंग के रूप में लेता है (जिसमें अंक और अक्षर शामिल हो सकते हैं),\n * इस संख्या का आधार, और परिवर्तन के लिए लक्ष्य आधार। आधार 2 से 16 तक हो सकते हैं।\n * आउटपुट लक्ष्य आधार में परिवर्तित संख्या को एक स्ट्रिंग के रूप में होता है, 10 से ऊपर के आधारों के लिए अपरकेस अक्षरों का उपयोग करते हुए।\n *\n * उदाहरण:\n * >>> convertBase(\"Aab3\", 15, 7)\n *     \"210306\"\n * >>> convertBase(\"101\", 2, 10)\n *     \"5\"\n * >>> convertBase(\"FF\", 16, 2)\n *     \"11111111\"\n */",
      "hu": "/**\n * Egy szám átalakítása egyik számrendszerből a másikba.\n * A függvény egy bemeneti számot vesz fel sztringként (amely tartalmazhat számjegyeket és betűket),\n * ennek a számnak az alapját, és a cél alapot az átalakításhoz. Az alapok 2-től 16-ig terjedhetnek.\n * A kimenet az átalakított szám sztringként a cél alapban, nagybetűk használatával a 10 feletti alapok esetén.\n *\n * Példák:\n * >>> convertBase(\"Aab3\", 15, 7)\n *     \"210306\"\n * >>> convertBase(\"101\", 2, 10)\n *     \"5\"\n * >>> convertBase(\"FF\", 16, 2)\n *     \"11111111\"\n */"
    },
    "prompt_bertscore": {
      "sq": "0.9569601731462173",
      "hy": "0.9432789097612962",
      "bn": "0.956331905251004",
      "bg": "0.9592912992980428",
      "zh": "0.9243480440360042",
      "fr": "0.954647122359066",
      "de": "0.9578452701241088",
      "ha": "0.9453637342406385",
      "hi": "0.9511667208225727",
      "hu": "0.9420470041381179"
    },
    "canonical_solution": "{\n    val number = inputNumber.toLong(fromBase)\n    return number.toString(toBase).toUpperCase()\n}",
    "instruction": {
      "en": "Write a Kotlin function `fun convertBase(inputNumber: String, fromBase: Int, toBase: Int): String` to solve the following problem:\nConverts a number from one base to another.\nThe function takes an input number as a string (which can include digits and letters),\nthe base of this number, and the target base for conversion. The bases can range from 2 to 16.\nThe output is the converted number as a string in the target base, using uppercase letters for bases above 10.\n\nExamples:\n>>> convertBase(\"Aab3\", 15, 7)\n\"210306\"\n>>> convertBase(\"101\", 2, 10)\n\"5\"\n>>> convertBase(\"FF\", 16, 2)\n\"11111111\"",
      "sq": "Shkruani një funksion Kotlin `fun convertBase(inputNumber: String, fromBase: Int, toBase: Int): String` për të zgjidhur problemin në vijim:\nKonverton një numër nga një bazë në një tjetër.\nFunksioni merr një numër hyrës si një varg (i cili mund të përfshijë shifra dhe shkronja),\nbazën e këtij numri dhe bazën e synuar për konvertim. Bazat mund të variojnë nga 2 deri në 16.\nDalja është numri i konvertuar si një varg në bazën e synuar, duke përdorur shkronja të mëdha për bazat mbi 10.\n\nShembuj:\n>>> convertBase(\"Aab3\", 15, 7)\n\"210306\"\n>>> convertBase(\"101\", 2, 10)\n\"5\"\n>>> convertBase(\"FF\", 16, 2)\n\"11111111\"",
      "hy": "Գրեք Kotlin ֆունկցիա `fun convertBase(inputNumber: String, fromBase: Int, toBase: Int): String` հետևյալ խնդիրը լուծելու համար:\nՓոխակերպում է թիվը մի հիմքից մյուսը:\nՖունկցիան ընդունում է մուտքային թիվը որպես տող (որը կարող է ներառել թվեր և տառեր),\nայս թվի հիմքը և նպատակային հիմքը փոխակերպման համար: Հիմքերը կարող են տատանվել 2-ից մինչև 16:\nԵլքը նպատակային հիմքում փոխակերպված թիվն է որպես տող, օգտագործելով մեծատառեր 10-ից բարձր հիմքերի համար:\n\nՕրինակներ:\n>>> convertBase(\"Aab3\", 15, 7)\n\"210306\"\n>>> convertBase(\"101\", 2, 10)\n\"5\"\n>>> convertBase(\"FF\", 16, 2)\n\"11111111\"",
      "bn": "Kotlin ফাংশন `fun convertBase(inputNumber: String, fromBase: Int, toBase: Int): String` লিখুন নিম্নলিখিত সমস্যার সমাধানের জন্য:\nএকটি সংখ্যা এক ভিত্তি থেকে অন্য ভিত্তিতে রূপান্তর করে।\nফাংশনটি একটি ইনপুট সংখ্যা নেয় একটি স্ট্রিং হিসাবে (যা সংখ্যা এবং অক্ষর অন্তর্ভুক্ত করতে পারে),\nএই সংখ্যার ভিত্তি, এবং রূপান্তরের জন্য লক্ষ্য ভিত্তি। ভিত্তিগুলি 2 থেকে 16 পর্যন্ত হতে পারে।\nআউটপুটটি লক্ষ্য ভিত্তিতে একটি স্ট্রিং হিসাবে রূপান্তরিত সংখ্যা, 10 এর উপরে ভিত্তির জন্য বড় হাতের অক্ষর ব্যবহার করে।\n\nউদাহরণ:\n>>> convertBase(\"Aab3\", 15, 7)\n\"210306\"\n>>> convertBase(\"101\", 2, 10)\n\"5\"\n>>> convertBase(\"FF\", 16, 2)\n\"11111111\"",
      "bg": "Напишете функция на Kotlin `fun convertBase(inputNumber: String, fromBase: Int, toBase: Int): String`, за да решите следния проблем:\nКонвертира число от една база в друга.\nФункцията приема входно число като низ (което може да включва цифри и букви),\nбазата на това число и целевата база за конвертиране. Базите могат да варират от 2 до 16.\nИзходът е конвертираното число като низ в целевата база, използвайки главни букви за бази над 10.\n\nПримери:\n>>> convertBase(\"Aab3\", 15, 7)\n\"210306\"\n>>> convertBase(\"101\", 2, 10)\n\"5\"\n>>> convertBase(\"FF\", 16, 2)\n\"11111111\"",
      "zh": "编写一个 Kotlin 函数 `fun convertBase(inputNumber: String, fromBase: Int, toBase: Int): String` 来解决以下问题：\n将一个数字从一个进制转换为另一个进制。\n该函数接受一个作为字符串的输入数字（可以包含数字和字母），\n该数字的进制，以及转换的目标进制。进制可以从 2 到 16。\n输出是转换后的目标进制数字，作为字符串，使用大写字母表示大于 10 的进制。\n\n示例：\n>>> convertBase(\"Aab3\", 15, 7)\n\"210306\"\n>>> convertBase(\"101\", 2, 10)\n\"5\"\n>>> convertBase(\"FF\", 16, 2)\n\"11111111\"",
      "fr": "Écrire une fonction Kotlin `fun convertBase(inputNumber: String, fromBase: Int, toBase: Int): String` pour résoudre le problème suivant :\nConvertit un nombre d'une base à une autre.\nLa fonction prend un nombre d'entrée sous forme de chaîne (qui peut inclure des chiffres et des lettres),\nla base de ce nombre, et la base cible pour la conversion. Les bases peuvent aller de 2 à 16.\nLa sortie est le nombre converti sous forme de chaîne dans la base cible, en utilisant des lettres majuscules pour les bases supérieures à 10.\n\nExemples :\n>>> convertBase(\"Aab3\", 15, 7)\n\"210306\"\n>>> convertBase(\"101\", 2, 10)\n\"5\"\n>>> convertBase(\"FF\", 16, 2)\n\"11111111\"",
      "de": "Schreiben Sie eine Kotlin-Funktion `fun convertBase(inputNumber: String, fromBase: Int, toBase: Int): String`, um das folgende Problem zu lösen:\nKonvertiert eine Zahl von einer Basis in eine andere.\nDie Funktion nimmt eine Eingabezahl als Zeichenkette (die Ziffern und Buchstaben enthalten kann),\ndie Basis dieser Zahl und die Zielbasis für die Konvertierung. Die Basen können von 2 bis 16 reichen.\nDie Ausgabe ist die konvertierte Zahl als Zeichenkette in der Zielbasis, wobei Großbuchstaben für Basen über 10 verwendet werden.\n\nBeispiele:\n>>> convertBase(\"Aab3\", 15, 7)\n\"210306\"\n>>> convertBase(\"101\", 2, 10)\n\"5\"\n>>> convertBase(\"FF\", 16, 2)\n\"11111111\"",
      "ha": "Rubuta wani aikin Kotlin `fun convertBase(inputNumber: String, fromBase: Int, toBase: Int): String` don warware matsalar mai zuwa:\nYana canza lamba daga wata tushe zuwa wata.\nAikin yana karɓar lamba a matsayin kirtani (wanda zai iya haɗawa da lambobi da haruffa),\ntushen wannan lambar, da kuma tushen da ake nufi don canzawa. Tushen na iya zama daga 2 zuwa 16.\nFitarwa ita ce lambar da aka canza a matsayin kirtani a cikin tushen da ake nufi, ta amfani da manyan haruffa don tushen sama da 10.\n\nMisalai:\n>>> convertBase(\"Aab3\", 15, 7)\n\"210306\"\n>>> convertBase(\"101\", 2, 10)\n\"5\"\n>>> convertBase(\"FF\", 16, 2)\n\"11111111\"",
      "hi": "Kotlin फ़ंक्शन `fun convertBase(inputNumber: String, fromBase: Int, toBase: Int): String` लिखें ताकि निम्नलिखित समस्या का समाधान किया जा सके:\nएक संख्या को एक आधार से दूसरे आधार में परिवर्तित करता है।\nफ़ंक्शन एक इनपुट संख्या को एक स्ट्रिंग के रूप में लेता है (जिसमें अंक और अक्षर शामिल हो सकते हैं),\nइस संख्या का आधार, और परिवर्तन के लिए लक्ष्य आधार। आधार 2 से 16 तक हो सकते हैं।\nआउटपुट लक्ष्य आधार में एक स्ट्रिंग के रूप में परिवर्तित संख्या है, जो 10 से ऊपर के आधारों के लिए अपरकेस अक्षरों का उपयोग करता है।\n\nउदाहरण:\n>>> convertBase(\"Aab3\", 15, 7)\n\"210306\"\n>>> convertBase(\"101\", 2, 10)\n\"5\"\n>>> convertBase(\"FF\", 16, 2)\n\"11111111\"",
      "hu": "Írj egy Kotlin függvényt `fun convertBase(inputNumber: String, fromBase: Int, toBase: Int): String` a következő probléma megoldására:\nEgy szám átalakítása egyik számrendszerből a másikba.\nA függvény egy bemeneti számot vesz fel sztringként (amely tartalmazhat számjegyeket és betűket),\nennek a számnak a számrendszerét, valamint a cél számrendszert az átalakításhoz. A számrendszerek 2-től 16-ig terjedhetnek.\nA kimenet a konvertált szám sztringként a cél számrendszerben, nagybetűket használva a 10 feletti számrendszerek esetén.\n\nPéldák:\n>>> convertBase(\"Aab3\", 15, 7)\n\"210306\"\n>>> convertBase(\"101\", 2, 10)\n\"5\"\n>>> convertBase(\"FF\", 16, 2)\n\"11111111\""
    },
    "instruction_bertscore": {
      "sq": "0.9957375906533723",
      "hy": "0.9819840258097546",
      "bn": "0.9764509779156467",
      "bg": "0.9922677165270739",
      "zh": "0.9686503655916446",
      "fr": "0.9937445334100683",
      "de": "0.9950608569451864",
      "ha": "0.9790349605425296",
      "hi": "0.983204808131595",
      "hu": "0.9385767327510574"
    },
    "level": "easy",
    "test": "fun main() {\n    check(convertBase(\"Aab3\", 15, 7) == \"210306\")\n    check(convertBase(\"101\", 2, 10) == \"5\")\n    check(convertBase(\"FF\", 16, 2) == \"11111111\")\n    check(convertBase(\"123\", 10, 16) == \"7B\")\n}\n\nmain()",
    "entry_point": "convertBase",
    "signature": "fun convertBase(inputNumber: String, fromBase: Int, toBase: Int): String",
    "docstring": {
      "en": "Converts a number from one base to another.\nThe function takes an input number as a string (which can include digits and letters),\nthe base of this number, and the target base for conversion. The bases can range from 2 to 16.\nThe output is the converted number as a string in the target base, using uppercase letters for bases above 10.\n\nExamples:\n>>> convertBase(\"Aab3\", 15, 7)\n\"210306\"\n>>> convertBase(\"101\", 2, 10)\n\"5\"\n>>> convertBase(\"FF\", 16, 2)\n\"11111111\"",
      "sq": "Konverton një numër nga një bazë në një tjetër. Funksioni merr një numër hyrës si një varg (i cili mund të përfshijë shifra dhe shkronja), bazën e këtij numri dhe bazën e synuar për konvertim. Bazat mund të variojnë nga 2 deri në 16. Rezultati është numri i konvertuar si një varg në bazën e synuar, duke përdorur shkronja të mëdha për bazat mbi 10.\n\nShembuj:\n>>> convertBase(\"Aab3\", 15, 7)\n\"210306\"\n>>> convertBase(\"101\", 2, 10)\n\"5\"\n>>> convertBase(\"FF\", 16, 2)\n\"11111111\"",
      "hy": "Վերածում է թիվը մի հիմքից մյուսը: \nՖունկցիան ընդունում է մուտքային թիվը որպես տող (որը կարող է ներառել թվանշաններ և տառեր), \nայս թվի հիմքը և նպատակային հիմքը վերածման համար: Հիմքերը կարող են տատանվել 2-ից մինչև 16: \nԵլքը հանդիսանում է վերածված թիվը որպես տող նպատակային հիմքում, օգտագործելով մեծատառեր 10-ից բարձր հիմքերի համար:\n\nՕրինակներ:\n>>> convertBase(\"Aab3\", 15, 7)\n\"210306\"\n>>> convertBase(\"101\", 2, 10)\n\"5\"\n>>> convertBase(\"FF\", 16, 2)\n\"11111111\"",
      "bn": "একটি সংখ্যা এক ভিত্তি থেকে অন্য ভিত্তিতে রূপান্তর করে। \nফাংশনটি একটি ইনপুট সংখ্যা নেয় একটি স্ট্রিং হিসেবে (যা সংখ্যা এবং অক্ষর অন্তর্ভুক্ত করতে পারে), \nএই সংখ্যার ভিত্তি, এবং রূপান্তরের জন্য লক্ষ্য ভিত্তি। ভিত্তিগুলি 2 থেকে 16 পর্যন্ত হতে পারে। \nআউটপুটটি লক্ষ্য ভিত্তিতে একটি স্ট্রিং হিসেবে রূপান্তরিত সংখ্যা, 10 এর উপরে ভিত্তির জন্য বড় হাতের অক্ষর ব্যবহার করে।\n\nউদাহরণ:\n>>> convertBase(\"Aab3\", 15, 7)\n\"210306\"\n>>> convertBase(\"101\", 2, 10)\n\"5\"\n>>> convertBase(\"FF\", 16, 2)\n\"11111111\"",
      "bg": "Преобразува число от една база в друга.  \nФункцията приема входно число като низ (което може да включва цифри и букви),  \nбазата на това число и целевата база за преобразуване. Базите могат да варират от 2 до 16.  \nИзходът е преобразуваното число като низ в целевата база, използвайки главни букви за бази над 10.\n\nПримери:\n>>> convertBase(\"Aab3\", 15, 7)\n\"210306\"\n>>> convertBase(\"101\", 2, 10)\n\"5\"\n>>> convertBase(\"FF\", 16, 2)\n\"11111111\"",
      "zh": "将一个数字从一个进制转换为另一个进制。  \n该函数接受一个作为字符串的输入数字（可以包含数字和字母），该数字的进制，以及用于转换的目标进制。进制范围可以从2到16。  \n输出是转换后的目标进制数字字符串，对于大于10的进制，使用大写字母。\n\n示例：\n>>> convertBase(\"Aab3\", 15, 7)\n\"210306\"\n>>> convertBase(\"101\", 2, 10)\n\"5\"\n>>> convertBase(\"FF\", 16, 2)\n\"11111111\"",
      "fr": "Convertit un nombre d'une base à une autre.  \nLa fonction prend un nombre d'entrée sous forme de chaîne (qui peut inclure des chiffres et des lettres),  \nla base de ce nombre, et la base cible pour la conversion. Les bases peuvent aller de 2 à 16.  \nLa sortie est le nombre converti sous forme de chaîne dans la base cible, en utilisant des lettres majuscules pour les bases supérieures à 10.\n\nExemples :\n>>> convertBase(\"Aab3\", 15, 7)\n\"210306\"\n>>> convertBase(\"101\", 2, 10)\n\"5\"\n>>> convertBase(\"FF\", 16, 2)\n\"11111111\"",
      "de": "Konvertiert eine Zahl von einer Basis in eine andere.\nDie Funktion nimmt eine Eingabezahl als Zeichenkette (die Ziffern und Buchstaben enthalten kann),\ndie Basis dieser Zahl und die Zielbasis für die Konvertierung. Die Basen können von 2 bis 16 reichen.\nDie Ausgabe ist die konvertierte Zahl als Zeichenkette in der Zielbasis, wobei Großbuchstaben für Basen über 10 verwendet werden.\n\nBeispiele:\n>>> convertBase(\"Aab3\", 15, 7)\n\"210306\"\n>>> convertBase(\"101\", 2, 10)\n\"5\"\n>>> convertBase(\"FF\", 16, 2)\n\"11111111\"",
      "ha": "Yana canza lamba daga wata tushe zuwa wata.\nAikin yana karɓar lamba a matsayin kirtani (wanda zai iya haɗawa da lambobi da haruffa),\ntushen wannan lambar, da kuma tushen da ake nufi don canji. Tushen na iya zama daga 2 zuwa 16.\nFitarwa ita ce lambar da aka canza a matsayin kirtani a cikin tushen da ake nufi, ta amfani da manyan haruffa don tushen sama da 10.\n\nMisalai:\n>>> convertBase(\"Aab3\", 15, 7)\n\"210306\"\n>>> convertBase(\"101\", 2, 10)\n\"5\"\n>>> convertBase(\"FF\", 16, 2)\n\"11111111\"",
      "hi": "एक संख्या को एक आधार से दूसरे आधार में परिवर्तित करता है। \nयह फ़ंक्शन एक इनपुट संख्या को एक स्ट्रिंग के रूप में लेता है (जो अंक और अक्षर शामिल कर सकता है),\nइस संख्या का आधार, और रूपांतरण के लिए लक्ष्य आधार। आधार 2 से 16 तक हो सकते हैं।\nआउटपुट लक्ष्य आधार में परिवर्तित संख्या है, जो 10 से ऊपर के आधारों के लिए अपरकेस अक्षरों का उपयोग करता है।\n\nउदाहरण:\n>>> convertBase(\"Aab3\", 15, 7)\n\"210306\"\n>>> convertBase(\"101\", 2, 10)\n\"5\"\n>>> convertBase(\"FF\", 16, 2)\n\"11111111\"",
      "hu": "Átkonvertál egy számot egyik számrendszerből a másikba.  \nA függvény bemeneti számként egy karakterláncot vesz (ami tartalmazhat számjegyeket és betűket),  \nennek a számnak az alapját, valamint a cél alapot a konverzióhoz. Az alapok 2-től 16-ig terjedhetnek.  \nA kimenet a konvertált szám karakterláncként a cél alapban, nagybetűket használva a 10 feletti alapokhoz.\n\nPéldák:\n>>> convertBase(\"Aab3\", 15, 7)\n\"210306\"\n>>> convertBase(\"101\", 2, 10)\n\"5\"\n>>> convertBase(\"FF\", 16, 2)\n\"11111111\""
    },
    "docstring_bertscore": {
      "sq": "0.9906635775698361",
      "hy": "0.985157543407549",
      "bn": "0.9831338970855655",
      "bg": "0.990964502597104",
      "zh": "0.9591443128160769",
      "fr": "0.9923976207962707",
      "de": "0.9937983622433287",
      "ha": "0.9859792772938903",
      "hi": "0.9662983832498105",
      "hu": "0.9641088805596629"
    }
  },
  {
    "task_id": "Kotlin/29",
    "prompt": {
      "en": "/**\n * Determines whether a given number string is a cyclic number.\n * A cyclic number is one where multiplying it by any number from 1 to its length,\n * results in a permutation of the original number.\n *\n * Examples:\n * >>> isCyclicNumber(\"142857\")\n *     1 // since 142857 is a cyclic number\n * >>> isCyclicNumber(\"123456\")\n *     0 // since 123456 is not a cyclic number\n */\n\nfun isCyclicNumber(numberString: String): Int ",
      "sq": "/**\n * Përcakton nëse një varg numrash i dhënë është një numër ciklik.\n * Një numër ciklik është ai ku shumëzimi i tij me çdo numër nga 1 deri në gjatësinë e tij,\n * rezulton në një permutacion të numrit origjinal.\n *\n * Shembuj:\n * >>> isCyclicNumber(\"142857\")\n *     1 // pasi 142857 është një numër ciklik\n * >>> isCyclicNumber(\"123456\")\n *     0 // pasi 123456 nuk është një numër ciklik\n */ \n\nfun isCyclicNumber(numberString: String): Int ",
      "hy": "/**\n * Սահմանում է՝ արդյոք տրված թվային տողը ցիկլիկ թիվ է:\n * Ցիկլիկ թիվը այն է, երբ այն բազմապատկելով 1-ից մինչև իր երկարությունը ցանկացած թվով,\n * ստացվում է սկզբնական թվի պերմուտացիա:\n *\n * Օրինակներ:\n * >>> isCyclicNumber(\"142857\")\n *     1 // քանի որ 142857-ը ցիկլիկ թիվ է\n * >>> isCyclicNumber(\"123456\")\n *     0 // քանի որ 123456-ը ցիկլիկ թիվ չէ\n */",
      "bn": "/**\n * নির্ধারণ করে একটি প্রদত্ত সংখ্যা স্ট্রিং একটি চক্রাকার সংখ্যা কিনা।\n * একটি চক্রাকার সংখ্যা হল এমন একটি সংখ্যা যা 1 থেকে তার দৈর্ঘ্য পর্যন্ত যেকোন সংখ্যার সাথে গুণ করলে,\n * মূল সংখ্যার একটি বিন্যাস পাওয়া যায়।\n *\n * উদাহরণ:\n * >>> isCyclicNumber(\"142857\")\n *     1 // যেহেতু 142857 একটি চক্রাকার সংখ্যা\n * >>> isCyclicNumber(\"123456\")\n *     0 // যেহেতু 123456 একটি চক্রাকার সংখ্যা নয়\n */",
      "bg": "/**\n * Определя дали даден низ от числа е циклично число.\n * Циклично число е такова, при което умножаването му с което и да е число от 1 до неговата дължина,\n * води до пермутация на оригиналното число.\n *\n * Примери:\n * >>> isCyclicNumber(\"142857\")\n *     1 // тъй като 142857 е циклично число\n * >>> isCyclicNumber(\"123456\")\n *     0 // тъй като 123456 не е циклично число\n */",
      "zh": "/**\n * 确定给定的数字字符串是否为循环数。\n * 循环数是指将其乘以从1到其长度的任何数字，\n * 结果是原始数字的一个排列。\n *\n * 例子:\n * >>> isCyclicNumber(\"142857\")\n *     1 // 因为142857是一个循环数\n * >>> isCyclicNumber(\"123456\")\n *     0 // 因为123456不是一个循环数\n */",
      "fr": "/**\n * Détermine si une chaîne de chiffres donnée est un nombre cyclique.\n * Un nombre cyclique est un nombre tel que le multiplier par n'importe quel nombre de 1 à sa longueur,\n * résulte en une permutation du nombre original.\n *\n * Exemples :\n * >>> isCyclicNumber(\"142857\")\n *     1 // puisque 142857 est un nombre cyclique\n * >>> isCyclicNumber(\"123456\")\n *     0 // puisque 123456 n'est pas un nombre cyclique\n */",
      "de": "/**\n * Bestimmt, ob eine gegebene Zahlenfolge eine zyklische Zahl ist.\n * Eine zyklische Zahl ist eine, bei der das Multiplizieren mit einer beliebigen Zahl von 1 bis zu ihrer Länge\n * zu einer Permutation der ursprünglichen Zahl führt.\n *\n * Beispiele:\n * >>> isCyclicNumber(\"142857\")\n *     1 // da 142857 eine zyklische Zahl ist\n * >>> isCyclicNumber(\"123456\")\n *     0 // da 123456 keine zyklische Zahl ist\n */",
      "ha": "/**\n * Yana tantance ko wata lamba a matsayin igiyar lamba.\n * Igiyar lamba ita ce wadda idan an ninka ta da kowace lamba daga 1 zuwa tsawonta,\n * sakamakon zai zama jujjuyawar lambar asali.\n *\n * Misalai:\n * >>> isCyclicNumber(\"142857\")\n *     1 // domin 142857 igiyar lamba ce\n * >>> isCyclicNumber(\"123456\")\n *     0 // domin 123456 ba igiyar lamba ba ce\n */",
      "hi": "/**\n * यह निर्धारित करता है कि दिया गया संख्या स्ट्रिंग एक चक्रीय संख्या है या नहीं।\n * एक चक्रीय संख्या वह होती है जिसे 1 से उसकी लंबाई तक किसी भी संख्या से गुणा करने पर,\n * मूल संख्या का एक क्रमपरिवर्तन प्राप्त होता है।\n *\n * उदाहरण:\n * >>> isCyclicNumber(\"142857\")\n *     1 // क्योंकि 142857 एक चक्रीय संख्या है\n * >>> isCyclicNumber(\"123456\")\n *     0 // क्योंकि 123456 एक चक्रीय संख्या नहीं है\n */\n\nfun isCyclicNumber(numberString: String): Int ",
      "hu": "/**\n * Meghatározza, hogy egy adott számsorozat ciklikus szám-e.\n * Egy ciklikus szám olyan, amelyet ha megszorzunk bármely számmal 1-től a hosszáig,\n * az eredeti szám permutációját kapjuk.\n *\n * Példák:\n * >>> isCyclicNumber(\"142857\")\n *     1 // mivel a 142857 egy ciklikus szám\n * >>> isCyclicNumber(\"123456\")\n *     0 // mivel a 123456 nem ciklikus szám\n */"
    },
    "prompt_bertscore": {
      "sq": "0.9821367725727704",
      "hy": "0.9529325449099729",
      "bn": "0.9407974204110274",
      "bg": "0.9566727549848598",
      "zh": "0.9385266778950366",
      "fr": "0.9405723721893149",
      "de": "0.9446985210945527",
      "ha": "0.9212619238058651",
      "hi": "0.9827449787994993",
      "hu": "0.9300270852601727"
    },
    "canonical_solution": "{\n    val number = numberString.toInt()\n    val length = numberString.length\n\n    for (i in 1..length) {\n        val multiplied = number * i\n        val multipliedString = multiplied.toString().padStart(length, '0')\n\n        if (!isPermutation(numberString, multipliedString)) {\n            return 0\n        }\n    }\n    return 1\n}\n\nfun isPermutation(str1: String, str2: String): Boolean {\n    return str1.toCharArray().sorted() == str2.toCharArray().sorted()\n}",
    "instruction": {
      "en": "Write a Kotlin function `fun isCyclicNumber(numberString: String): Int` to solve the following problem:\nDetermines whether a given number string is a cyclic number.\nA cyclic number is one where multiplying it by any number from 1 to its length,\nresults in a permutation of the original number.\n\nExamples:\n>>> isCyclicNumber(\"142857\")\n1 // since 142857 is a cyclic number\n>>> isCyclicNumber(\"123456\")\n0 // since 123456 is not a cyclic number",
      "sq": "Shkruani një funksion Kotlin `fun isCyclicNumber(numberString: String): Int` për të zgjidhur problemin në vijim:\nPërcakton nëse një varg numrash i dhënë është një numër ciklik.\nNjë numër ciklik është ai ku duke e shumëzuar me çdo numër nga 1 deri te gjatësia e tij,\nrezulton në një permutacion të numrit origjinal.\n\nShembuj:\n>>> isCyclicNumber(\"142857\")\n1 // pasi 142857 është një numër ciklik\n>>> isCyclicNumber(\"123456\")\n0 // pasi 123456 nuk është një numër ciklik",
      "hy": "Գրեք Kotlin ֆունկցիա `fun isCyclicNumber(numberString: String): Int`՝ հետևյալ խնդիրը լուծելու համար:\nՈրոշում է, արդյոք տրված թվային տողը ցիկլիկ թիվ է:\nՑիկլիկ թիվը այն է, որի բազմապատկումը 1-ից մինչև իր երկարությունը ցանկացած թվով,\nհանգեցնում է սկզբնական թվի վերադասավորման:\n\nՕրինակներ:\n>>> isCyclicNumber(\"142857\")\n1 // քանի որ 142857-ը ցիկլիկ թիվ է\n>>> isCyclicNumber(\"123456\")\n0 // քանի որ 123456-ը ցիկլիկ թիվ չէ",
      "bn": "Kotlin ফাংশন `fun isCyclicNumber(numberString: String): Int` লিখুন নিম্নলিখিত সমস্যার সমাধান করতে:\nনির্ধারণ করে যে প্রদত্ত সংখ্যা স্ট্রিংটি একটি চক্রাকার সংখ্যা কিনা।\nএকটি চক্রাকার সংখ্যা এমন একটি যেখানে এটিকে 1 থেকে এর দৈর্ঘ্য পর্যন্ত যে কোনো সংখ্যার সাথে গুণ করলে,\nমূল সংখ্যার একটি বিন্যাসের ফলাফল হয়।\n\nউদাহরণ:\n>>> isCyclicNumber(\"142857\")\n1 // যেহেতু 142857 একটি চক্রাকার সংখ্যা\n>>> isCyclicNumber(\"123456\")\n0 // যেহেতু 123456 একটি চক্রাকার সংখ্যা নয়",
      "bg": "Напишете Kotlin функция `fun isCyclicNumber(numberString: String): Int`, за да решите следния проблем:  \nОпределя дали даден низ от числа е циклично число.  \nЦиклично число е такова, при което умножаването му с което и да е число от 1 до неговата дължина,  \nводи до пермутация на оригиналното число.\n\nПримери:  \n>>> isCyclicNumber(\"142857\")  \n1 // тъй като 142857 е циклично число  \n>>> isCyclicNumber(\"123456\")  \n0 // тъй като 123456 не е циклично число",
      "zh": "编写一个 Kotlin 函数 `fun isCyclicNumber(numberString: String): Int` 来解决以下问题：\n确定给定的数字字符串是否为循环数。\n循环数是指将其乘以从 1 到其长度的任何数字，\n结果是原始数字的一个排列。\n\n示例：\n>>> isCyclicNumber(\"142857\")\n1 // 因为 142857 是一个循环数\n>>> isCyclicNumber(\"123456\")\n0 // 因为 123456 不是一个循环数",
      "fr": "Écrire une fonction Kotlin `fun isCyclicNumber(numberString: String): Int` pour résoudre le problème suivant :\nDétermine si une chaîne de chiffres donnée est un nombre cyclique.\nUn nombre cyclique est un nombre tel que le multiplier par n'importe quel nombre de 1 à sa longueur,\nrésulte en une permutation du nombre original.\n\nExemples :\n>>> isCyclicNumber(\"142857\")\n1 // puisque 142857 est un nombre cyclique\n>>> isCyclicNumber(\"123456\")\n0 // puisque 123456 n'est pas un nombre cyclique",
      "de": "Schreiben Sie eine Kotlin-Funktion `fun isCyclicNumber(numberString: String): Int`, um das folgende Problem zu lösen:\nBestimmt, ob eine gegebene Zahlenfolge eine zyklische Zahl ist.\nEine zyklische Zahl ist eine, bei der die Multiplikation mit einer beliebigen Zahl von 1 bis zu ihrer Länge\neine Permutation der ursprünglichen Zahl ergibt.\n\nBeispiele:\n>>> isCyclicNumber(\"142857\")\n1 // da 142857 eine zyklische Zahl ist\n>>> isCyclicNumber(\"123456\")\n0 // da 123456 keine zyklische Zahl ist",
      "ha": "Rubuta wani aikin Kotlin `fun isCyclicNumber(numberString: String): Int` don warware matsalar mai zuwa:\nYana tantance ko wani lambar da aka bayar yana da yanayin cyclic.\nWani lamba mai yanayin cyclic shine wanda idan aka ninka shi da kowace lamba daga 1 zuwa tsawonsa,\nyana haifar da permutation na lambar asali.\n\nMisalai:\n>>> isCyclicNumber(\"142857\")\n1 // saboda 142857 yana da yanayin cyclic\n>>> isCyclicNumber(\"123456\")\n0 // saboda 123456 ba yana da yanayin cyclic ba",
      "hi": "Kotlin फ़ंक्शन `fun isCyclicNumber(numberString: String): Int` लिखें ताकि निम्नलिखित समस्या का समाधान किया जा सके:\nनिर्धारित करता है कि दिया गया संख्या स्ट्रिंग एक चक्रीय संख्या है या नहीं।\nएक चक्रीय संख्या वह होती है जहां इसे 1 से लेकर इसकी लंबाई तक किसी भी संख्या से गुणा करने पर,\nमूल संख्या का एक क्रमचय प्राप्त होता है।\n\nउदाहरण:\n>>> isCyclicNumber(\"142857\")\n1 // क्योंकि 142857 एक चक्रीय संख्या है\n>>> isCyclicNumber(\"123456\")\n0 // क्योंकि 123456 एक चक्रीय संख्या नहीं है",
      "hu": "Írj egy Kotlin függvényt `fun isCyclicNumber(numberString: String): Int` a következő probléma megoldására:\nMeghatározza, hogy egy adott szám string ciklikus szám-e.\nEgy ciklikus szám olyan, ahol ha megszorozzuk bármely számmal 1-től a hosszáig,\naz eredmény az eredeti szám egy permutációja.\n\nPéldák:\n>>> isCyclicNumber(\"142857\")\n1 // mivel a 142857 egy ciklikus szám\n>>> isCyclicNumber(\"123456\")\n0 // mivel a 123456 nem ciklikus szám"
    },
    "instruction_bertscore": {
      "sq": "0.9873458543154103",
      "hy": "0.9693878801964272",
      "bn": "0.9700614358185164",
      "bg": "0.9925579155137658",
      "zh": "0.9757327304578246",
      "fr": "0.97417526964013",
      "de": "0.9829352667045307",
      "ha": "0.9358638390068829",
      "hi": "0.96287419411115",
      "hu": "0.9797613518459742"
    },
    "level": "middle",
    "test": "fun main(){\n    check(isCyclicNumber(\"142857\") == 1)\n    check(isCyclicNumber(\"123456\") == 0)\n    check(isCyclicNumber(\"076923\") == 0)\n    check(isCyclicNumber(\"1\") == 1)\n    check(isCyclicNumber(\"0\") == 1)\n\n}\n\nmain()",
    "entry_point": "isCyclicNumber",
    "signature": "fun isCyclicNumber(numberString: String): Int",
    "docstring": {
      "en": "Determines whether a given number string is a cyclic number.\nA cyclic number is one where multiplying it by any number from 1 to its length,\nresults in a permutation of the original number.\n\nExamples:\n>>> isCyclicNumber(\"142857\")\n1 // since 142857 is a cyclic number\n>>> isCyclicNumber(\"123456\")\n0 // since 123456 is not a cyclic number",
      "sq": "Përcakton nëse një varg numrash i dhënë është një numër ciklik. Një numër ciklik është ai ku shumëzimi i tij me çdo numër nga 1 deri te gjatësia e tij, rezulton në një permutacion të numrit origjinal.\n\nShembuj:\n>>> isCyclicNumber(\"142857\")\n1 // pasi 142857 është një numër ciklik\n>>> isCyclicNumber(\"123456\")\n0 // pasi 123456 nuk është një numër ciklik",
      "hy": "Սահմանում է, արդյոք տրված թվային տողը ցիկլիկ թիվ է:\nՑիկլիկ թիվը այն է, երբ այն բազմապատկելով 1-ից մինչև իր երկարությունը ցանկացած թվով,\nստացվում է սկզբնական թվի փոխատեղում:\n\nՕրինակներ:\n>>> isCyclicNumber(\"142857\")\n1 // քանի որ 142857-ը ցիկլիկ թիվ է\n>>> isCyclicNumber(\"123456\")\n0 // քանի որ 123456-ը ցիկլիկ թիվ չէ",
      "bn": "একটি প্রদত্ত সংখ্যা স্ট্রিং একটি চক্রাকার সংখ্যা কিনা তা নির্ধারণ করে। \nএকটি চক্রাকার সংখ্যা হল এমন একটি সংখ্যা যেখানে এটিকে ১ থেকে এর দৈর্ঘ্য পর্যন্ত যেকোনো সংখ্যার সাথে গুণ করলে, মূল সংখ্যার একটি বিন্যাস পাওয়া যায়।\n\nউদাহরণ:\n>>> isCyclicNumber(\"142857\")\n1 // কারণ 142857 একটি চক্রাকার সংখ্যা\n>>> isCyclicNumber(\"123456\")\n0 // কারণ 123456 একটি চক্রাকার সংখ্যা নয়",
      "bg": "Определя дали даден низ от числа е циклично число. Циклично число е такова, при което умножаването му с което и да е число от 1 до неговата дължина, води до пермутация на оригиналното число.\n\nПримери:\n>>> isCyclicNumber(\"142857\")\n1 // тъй като 142857 е циклично число\n>>> isCyclicNumber(\"123456\")\n0 // тъй като 123456 не е циклично число",
      "zh": "确定给定的数字字符串是否是循环数。\n循环数是指将其乘以从1到其长度的任何数字，结果是原始数字的一个排列。\n\n示例：\n>>> isCyclicNumber(\"142857\")\n1 // 因为142857是一个循环数\n>>> isCyclicNumber(\"123456\")\n0 // 因为123456不是一个循环数",
      "fr": "Détermine si une chaîne de chiffres donnée est un nombre cyclique.\nUn nombre cyclique est un nombre tel que le multiplier par n'importe quel nombre de 1 à sa longueur,  \nrésulte en une permutation du nombre original.\n\nExemples :  \n>>> isCyclicNumber(\"142857\")  \n1 // puisque 142857 est un nombre cyclique  \n>>> isCyclicNumber(\"123456\")  \n0 // puisque 123456 n'est pas un nombre cyclique  ",
      "de": "Bestimmt, ob eine gegebene Zahlenfolge eine zyklische Zahl ist.\nEine zyklische Zahl ist eine, bei der das Multiplizieren mit einer beliebigen Zahl von 1 bis zu ihrer Länge zu einer Permutation der ursprünglichen Zahl führt.\n\nBeispiele:\n>>> isCyclicNumber(\"142857\")\n1 // da 142857 eine zyklische Zahl ist\n>>> isCyclicNumber(\"123456\")\n0 // da 123456 keine zyklische Zahl ist",
      "ha": "Yana tantance ko wani lambar da aka bayar yana da yanayin cyclic.\nWani lamba mai zagaye shine wanda idan aka ninka shi da kowace lamba daga 1 zuwa tsawonsa,\nzai haifar da permutation na lambar asali.\n\nMisalai:\n>>> isCyclicNumber(\"142857\")\n1 // domin 142857 lamba ce mai zagaye\n>>> isCyclicNumber(\"123456\")\n0 // domin 123456 ba lamba ce mai zagaye ba",
      "hi": "निर्धारित करता है कि दिया गया संख्या स्ट्रिंग एक चक्रीय संख्या है या नहीं।  \nएक चक्रीय संख्या वह होती है जहाँ इसे 1 से लेकर इसकी लंबाई तक किसी भी संख्या से गुणा करने पर,  \nमूल संख्या का एक क्रमपरिवर्तन प्राप्त होता है।\n\nउदाहरण:\n>>> isCyclicNumber(\"142857\")\n1 // क्योंकि 142857 एक चक्रीय संख्या है\n>>> isCyclicNumber(\"123456\")\n0 // क्योंकि 123456 एक चक्रीय संख्या नहीं है",
      "hu": "Meghatározza, hogy egy adott számsorozat ciklikus szám-e.  \nEgy ciklikus szám olyan, amelyet ha megszorzunk bármely számmal 1-től a hosszáig, az eredeti szám egy permutációját kapjuk.\n\nPéldák:\n>>> isCyclicNumber(\"142857\")\n1 // mivel a 142857 egy ciklikus szám\n>>> isCyclicNumber(\"123456\")\n0 // mivel a 123456 nem ciklikus szám"
    },
    "docstring_bertscore": {
      "sq": "0.9764257518572553",
      "hy": "0.9823920126124003",
      "bn": "0.9730130832806949",
      "bg": "0.9910701739598146",
      "zh": "0.9698747232603436",
      "fr": "0.9653644231981845",
      "de": "0.9712577866034896",
      "ha": "0.9700326344132664",
      "hi": "0.9793966664663941",
      "hu": "0.9680904265475073"
    }
  },
  {
    "task_id": "Kotlin/30",
    "prompt": {
      "en": "/**\n    * Sum the given list of fractions and simplify the resulting fraction.\n    * The simplification process involves finding the greatest common divisor (GCD)\n    * of the numerator and the denominator and dividing both by this GCD. \n    * If the denominator after simplification is 1, only the numerator is returned.\n    *\n    * Example:\n    * >>> sumAndSimplifyFractions(listOf(\"1/2\", \"1/3\"))\n        \"5/6\"\n    * >>> sumAndSimplifyFractions(listOf(\"1/6\", \"1/4\", \"1/3\"))\n        \"3/4\"\n**/\n\n\n\nfun sumAndSimplifyFractions(fractions: List<String>): String",
      "sq": "/**\n    * Mbledh listën e dhënë të thyesave dhe thjeshton thyesën që rezulton.\n    * Procesi i thjeshtimit përfshin gjetjen e pjestuesit më të madh të përbashkët (GCD)\n    * të numëruesit dhe emëruesit dhe pjesëtimin e të dyve me këtë GCD.\n    * Nëse emëruesi pas thjeshtimit është 1, vetëm numëruesi kthehet.\n    *\n    * Shembull:\n    * >>> sumAndSimplifyFractions(listOf(\"1/2\", \"1/3\"))\n        \"5/6\"\n    * >>> sumAndSimplifyFractions(listOf(\"1/6\", \"1/4\", \"1/3\"))\n        \"3/4\"\n**/\n\n\n\nfun sumAndSimplifyFractions(fractions: List<String>): String",
      "hy": "/**\n    * Գումարել տրված կոտորակների ցանկը և պարզեցնել ստացված կոտորակը։\n    * Պարզեցման գործընթացը ներառում է համարիչի և հայտարարիչի \n    * ամենամեծ ընդհանուր բաժանարարը (GCD) գտնելը և երկուսն էլ բաժանել այդ GCD-ի վրա։\n    * Եթե պարզեցումից հետո հայտարարիչը 1 է, վերադարձվում է միայն համարիչը։\n    *\n    * Օրինակ:\n    * >>> sumAndSimplifyFractions(listOf(\"1/2\", \"1/3\"))\n        \"5/6\"\n    * >>> sumAndSimplifyFractions(listOf(\"1/6\", \"1/4\", \"1/3\"))\n        \"3/4\"\n**/\n\n\n\nfun sumAndSimplifyFractions(fractions: List<String>): String",
      "bn": "/**\n    * প্রদত্ত ভগ্নাংশের তালিকার যোগফল নির্ণয় করুন এবং ফলাফলকে সরলীকৃত করুন।\n    * সরলীকরণের প্রক্রিয়ায় লব ও হর এর সর্বাধিক সাধারণ গুণনীয়ক (GCD) খুঁজে বের করা\n    * এবং উভয়কেই এই GCD দ্বারা ভাগ করা অন্তর্ভুক্ত। \n    * যদি সরলীকরণের পরে হর 1 হয়, তবে শুধুমাত্র লব ফেরত দেওয়া হয়।\n    *\n    * উদাহরণ:\n    * >>> sumAndSimplifyFractions(listOf(\"1/2\", \"1/3\"))\n        \"5/6\"\n    * >>> sumAndSimplifyFractions(listOf(\"1/6\", \"1/4\", \"1/3\"))\n        \"3/4\"\n**/\n\n\n\nfun sumAndSimplifyFractions(fractions: List<String>): String",
      "bg": "/**\n    * Сумиране на дадения списък от дроби и опростяване на получената дроб.\n    * Процесът на опростяване включва намиране на най-големия общ делител (НОД)\n    * на числителя и знаменателя и делене на двата с този НОД.\n    * Ако знаменателят след опростяване е 1, се връща само числителят.\n    *\n    * Пример:\n    * >>> sumAndSimplifyFractions(listOf(\"1/2\", \"1/3\"))\n        \"5/6\"\n    * >>> sumAndSimplifyFractions(listOf(\"1/6\", \"1/4\", \"1/3\"))\n        \"3/4\"\n**/\n\n\n\nfun sumAndSimplifyFractions(fractions: List<String>): String",
      "zh": "/**\n    * 对给定的分数列表求和并简化结果分数。\n    * 简化过程涉及找到分子和分母的最大公约数 (GCD)，并将两者都除以这个 GCD。\n    * 如果简化后的分母为 1，则仅返回分子。\n    *\n    * 示例:\n    * >>> sumAndSimplifyFractions(listOf(\"1/2\", \"1/3\"))\n        \"5/6\"\n    * >>> sumAndSimplifyFractions(listOf(\"1/6\", \"1/4\", \"1/3\"))\n        \"3/4\"\n**/\n\n\n\nfun sumAndSimplifyFractions(fractions: List<String>): String",
      "fr": "/**\n    * Additionner la liste donnée de fractions et simplifier la fraction résultante.\n    * Le processus de simplification implique de trouver le plus grand commun diviseur (PGCD)\n    * du numérateur et du dénominateur et de diviser les deux par ce PGCD.\n    * Si le dénominateur après simplification est 1, seul le numérateur est retourné.\n    *\n    * Exemple :\n    * >>> sumAndSimplifyFractions(listOf(\"1/2\", \"1/3\"))\n        \"5/6\"\n    * >>> sumAndSimplifyFractions(listOf(\"1/6\", \"1/4\", \"1/3\"))\n        \"3/4\"\n**/\n\n\n\nfun sumAndSimplifyFractions(fractions: List<String>): String",
      "de": "/**\n    * Summiere die gegebene Liste von Brüchen und vereinfache den resultierenden Bruch.\n    * Der Vereinfachungsprozess beinhaltet das Finden des größten gemeinsamen Teilers (GGT)\n    * des Zählers und des Nenners und das Teilen beider durch diesen GGT.\n    * Wenn der Nenner nach der Vereinfachung 1 ist, wird nur der Zähler zurückgegeben.\n    *\n    * Beispiel:\n    * >>> sumAndSimplifyFractions(listOf(\"1/2\", \"1/3\"))\n        \"5/6\"\n    * >>> sumAndSimplifyFractions(listOf(\"1/6\", \"1/4\", \"1/3\"))\n        \"3/4\"\n**/\n\n\n\nfun sumAndSimplifyFractions(fractions: List<String>): String",
      "ha": "/**\n    * Tara jerin kason da aka bayar kuma saukaka sakamakon kaso.\n    * Tsarin saukakewa yana da nasaba da nemo babbar mai raba kashi (GCD)\n    * na mai nuni da mai kasa kuma a raba duka biyun da wannan GCD.\n    * Idan mai kasa bayan saukakewa ya zama 1, ana mayar da mai nuni kawai.\n    *\n    * Misali:\n    * >>> sumAndSimplifyFractions(listOf(\"1/2\", \"1/3\"))\n        \"5/6\"\n    * >>> sumAndSimplifyFractions(listOf(\"1/6\", \"1/4\", \"1/3\"))\n        \"3/4\"\n**/\n\n\n\nfun sumAndSimplifyFractions(fractions: List<String>): String",
      "hi": "/**\n    * दिए गए भिन्नों की सूची का योग करें और परिणामी भिन्न को सरल बनाएं।\n    * सरलीकरण प्रक्रिया में अंश और हर के महत्तम समापवर्तक (GCD) को खोजना शामिल है\n    * और दोनों को इस GCD से विभाजित करना। \n    * यदि सरलीकरण के बाद हर 1 है, तो केवल अंश लौटाया जाता है।\n    *\n    * उदाहरण:\n    * >>> sumAndSimplifyFractions(listOf(\"1/2\", \"1/3\"))\n        \"5/6\"\n    * >>> sumAndSimplifyFractions(listOf(\"1/6\", \"1/4\", \"1/3\"))\n        \"3/4\"\n**/\n\n\n\nfun sumAndSimplifyFractions(fractions: List<String>): String",
      "hu": "/**\n    * Adja össze a megadott tört listát, és egyszerűsítse az eredményül kapott törtet.\n    * Az egyszerűsítési folyamat magában foglalja a számláló és a nevező legnagyobb közös osztójának (GCD) megtalálását,\n    * és mindkettőt elosztjuk ezzel a GCD-vel.\n    * Ha az egyszerűsítés után a nevező 1, csak a számláló kerül visszaadásra.\n    *\n    * Példa:\n    * >>> sumAndSimplifyFractions(listOf(\"1/2\", \"1/3\"))\n        \"5/6\"\n    * >>> sumAndSimplifyFractions(listOf(\"1/6\", \"1/4\", \"1/3\"))\n        \"3/4\"\n**/\n\n\n\nfun sumAndSimplifyFractions(fractions: List<String>): String"
    },
    "prompt_bertscore": {
      "sq": "0.9861721473938753",
      "hy": "0.9899864466008882",
      "bn": "0.9800980303418283",
      "bg": "0.990173159159061",
      "zh": "0.9735243578814787",
      "fr": "0.9942635545957125",
      "de": "0.9980411071822339",
      "ha": "0.9977264766586746",
      "hi": "0.9946546578159702",
      "hu": "0.9832397670786571"
    },
    "canonical_solution": "{\n    val numerators = fractions.map { it.substringBefore('/').toInt() }\n    val denominators = fractions.map { it.substringAfter('/').toInt() }\n\n    val commonDenominator = denominators.reduce { acc, d -> lcm(acc, d) }\n    val sumNumerator = numerators.zip(denominators).sumOf { (numerator, denominator) ->\n        numerator * (commonDenominator / denominator)\n    }\n\n    val divisor = gcd(sumNumerator, commonDenominator)\n    val simplifiedNumerator = sumNumerator / divisor\n    val simplifiedDenominator = commonDenominator / divisor\n\n    return if (simplifiedDenominator == 1) simplifiedNumerator.toString() else \"$simplifiedNumerator/$simplifiedDenominator\"\n}\n\nfun gcd(a: Int, b: Int): Int = if (b == 0) a else gcd(b, a % b)\n\nfun lcm(a: Int, b: Int): Int = a / gcd(a, b) * b",
    "instruction": {
      "en": "Write a Kotlin function `fun sumAndSimplifyFractions(fractions: List<String>): String` to solve the following problem:\nSum the given list of fractions and simplify the resulting fraction.\nThe simplification process involves finding the greatest common divisor (GCD)\nof the numerator and the denominator and dividing both by this GCD.\nIf the denominator after simplification is 1, only the numerator is returned.\n\nExample:\n>>> sumAndSimplifyFractions(listOf(\"1/2\", \"1/3\"))\n\"5/6\"\n>>> sumAndSimplifyFractions(listOf(\"1/6\", \"1/4\", \"1/3\"))\n\"3/4\"",
      "sq": "Shkruani një funksion Kotlin `fun sumAndSimplifyFractions(fractions: List<String>): String` për të zgjidhur problemin në vijim:\nMblidhni listën e dhënë të thyesave dhe thjeshtoni thyesën që rezulton.\nProcesi i thjeshtimit përfshin gjetjen e pjesëtuesit më të madh të përbashkët (GCD)\ntë numëruesit dhe emëruesit dhe ndarjen e të dyve me këtë GCD.\nNëse emëruesi pas thjeshtimit është 1, kthehet vetëm numëruesi.\n\nShembull:\n>>> sumAndSimplifyFractions(listOf(\"1/2\", \"1/3\"))\n\"5/6\"\n>>> sumAndSimplifyFractions(listOf(\"1/6\", \"1/4\", \"1/3\"))\n\"3/4\"",
      "hy": "Գրեք Kotlin ֆունկցիա `fun sumAndSimplifyFractions(fractions: List<String>): String` հետևյալ խնդիրը լուծելու համար:\nԳումարեք տրված կոտորակների ցուցակը և պարզեցրեք ստացված կոտորակը:\nՊարզեցման գործընթացը ներառում է համարիչի և հայտարիչի մեծագույն ընդհանուր բաժանարարի (GCD) գտնումը\nև երկուսն էլ բաժանելը այդ GCD-ով:\nԵթե պարզեցումից հետո հայտարիչը 1 է, վերադարձվում է միայն համարիչը:\n\nՕրինակ:\n>>> sumAndSimplifyFractions(listOf(\"1/2\", \"1/3\"))\n\"5/6\"\n>>> sumAndSimplifyFractions(listOf(\"1/6\", \"1/4\", \"1/3\"))\n\"3/4\"",
      "bn": "Kotlin ফাংশন `fun sumAndSimplifyFractions(fractions: List<String>): String` লিখুন নিম্নলিখিত সমস্যার সমাধানের জন্য:\nপ্রদত্ত ভগ্নাংশের তালিকার যোগফল নির্ণয় করুন এবং ফলাফলকে সরলীকৃত করুন।\nসরলীকরণের প্রক্রিয়ায় লব এবং হরের সর্বাধিক সাধারণ গুণনীয়ক (GCD) খুঁজে বের করা এবং উভয়কেই এই GCD দ্বারা ভাগ করা জড়িত।\nযদি সরলীকরণের পরে হর 1 হয়, তাহলে শুধুমাত্র লব ফেরত দেওয়া হয়।\n\nউদাহরণ:\n>>> sumAndSimplifyFractions(listOf(\"1/2\", \"1/3\"))\n\"5/6\"\n>>> sumAndSimplifyFractions(listOf(\"1/6\", \"1/4\", \"1/3\"))\n\"3/4\"",
      "bg": "Напишете Kotlin функция `fun sumAndSimplifyFractions(fractions: List<String>): String`, за да решите следния проблем:\nСумирайте дадения списък от дроби и опростете получената дроб.\nПроцесът на опростяване включва намиране на най-големия общ делител (НОД)\nна числителя и знаменателя и делене на двата с този НОД.\nАко знаменателят след опростяване е 1, се връща само числителят.\n\nПример:\n>>> sumAndSimplifyFractions(listOf(\"1/2\", \"1/3\"))\n\"5/6\"\n>>> sumAndSimplifyFractions(listOf(\"1/6\", \"1/4\", \"1/3\"))\n\"3/4\"",
      "zh": "编写一个 Kotlin 函数 `fun sumAndSimplifyFractions(fractions: List<String>): String` 来解决以下问题：\n对给定的分数列表求和，并简化所得的分数。\n简化过程涉及找到分子和分母的最大公约数 (GCD)，并将两者都除以这个 GCD。\n如果简化后的分母为 1，则只返回分子。\n\n示例：\n>>> sumAndSimplifyFractions(listOf(\"1/2\", \"1/3\"))\n\"5/6\"\n>>> sumAndSimplifyFractions(listOf(\"1/6\", \"1/4\", \"1/3\"))\n\"3/4\"",
      "fr": "Écrire une fonction Kotlin `fun sumAndSimplifyFractions(fractions: List<String>): String` pour résoudre le problème suivant :\nAdditionner la liste donnée de fractions et simplifier la fraction résultante.\nLe processus de simplification implique de trouver le plus grand commun diviseur (PGCD)\ndu numérateur et du dénominateur et de diviser les deux par ce PGCD.\nSi le dénominateur après simplification est 1, seul le numérateur est retourné.\n\nExemple :\n>>> sumAndSimplifyFractions(listOf(\"1/2\", \"1/3\"))\n\"5/6\"\n>>> sumAndSimplifyFractions(listOf(\"1/6\", \"1/4\", \"1/3\"))\n\"3/4\"",
      "de": "Schreiben Sie eine Kotlin-Funktion `fun sumAndSimplifyFractions(fractions: List<String>): String`, um das folgende Problem zu lösen:\nSummieren Sie die gegebene Liste von Brüchen und vereinfachen Sie den resultierenden Bruch.\nDer Vereinfachungsprozess beinhaltet das Finden des größten gemeinsamen Teilers (GGT)\ndes Zählers und des Nenners und das Dividieren beider durch diesen GGT.\nWenn der Nenner nach der Vereinfachung 1 ist, wird nur der Zähler zurückgegeben.\n\nBeispiel:\n>>> sumAndSimplifyFractions(listOf(\"1/2\", \"1/3\"))\n\"5/6\"\n>>> sumAndSimplifyFractions(listOf(\"1/6\", \"1/4\", \"1/3\"))\n\"3/4\"",
      "ha": "Rubuta aikin Kotlin `fun sumAndSimplifyFractions(fractions: List<String>): String` don warware matsalar mai zuwa:\nƘara jerin kason da aka bayar kuma sauƙaƙe sakamakon kaso.\nTsarin sauƙaƙewa ya ƙunshi nemo babbar mai raba kowa da kowa (GCD)\nna mai ƙididdigewa da mai kasawa kuma a raba duka biyun da wannan GCD.\nIdan mai kasawa bayan sauƙaƙewa ya zama 1, ana mayar da mai ƙididdigewa kawai.\n\nMisali:\n>>> sumAndSimplifyFractions(listOf(\"1/2\", \"1/3\"))\n\"5/6\"\n>>> sumAndSimplifyFractions(listOf(\"1/6\", \"1/4\", \"1/3\"))\n\"3/4\"",
      "hi": "Kotlin फ़ंक्शन `fun sumAndSimplifyFractions(fractions: List<String>): String` लिखें ताकि निम्नलिखित समस्या का समाधान किया जा सके:\nदिए गए भिन्नों की सूची का योग करें और परिणामी भिन्न को सरल बनाएं।\nसरलीकरण प्रक्रिया में अंश और हर के महत्तम समापवर्तक (GCD) को खोजना और दोनों को इस GCD से विभाजित करना शामिल है।\nयदि सरलीकरण के बाद हर 1 है, तो केवल अंश लौटाया जाता है।\n\nउदाहरण:\n>>> sumAndSimplifyFractions(listOf(\"1/2\", \"1/3\"))\n\"5/6\"\n>>> sumAndSimplifyFractions(listOf(\"1/6\", \"1/4\", \"1/3\"))\n\"3/4\"",
      "hu": "Írj egy Kotlin függvényt `fun sumAndSimplifyFractions(fractions: List<String>): String` a következő probléma megoldására:\nAdd össze a megadott tört listát, és egyszerűsítsd az eredményül kapott törtet.\nAz egyszerűsítési folyamat magában foglalja a számláló és a nevező legnagyobb közös osztójának (GCD) megtalálását, és mindkettő osztását ezzel a GCD-vel.\nHa az egyszerűsítés után a nevező 1, csak a számláló kerül visszaadásra.\n\nPélda:\n>>> sumAndSimplifyFractions(listOf(\"1/2\", \"1/3\"))\n\"5/6\"\n>>> sumAndSimplifyFractions(listOf(\"1/6\", \"1/4\", \"1/3\"))\n\"3/4\""
    },
    "instruction_bertscore": {
      "sq": "0.9899471177854433",
      "hy": "0.9955951726701703",
      "bn": "0.9744038932087012",
      "bg": "0.999999801369619",
      "zh": "0.9823985674149744",
      "fr": "0.9950535076210881",
      "de": "0.9973806611652929",
      "ha": "0.9928026281432009",
      "hi": "0.9800902837569679",
      "hu": "0.9820340806657754"
    },
    "level": "hard",
    "test": "fun main() {\n    check(sumAndSimplifyFractions(listOf(\"1/2\", \"1/3\")) == \"5/6\")\n    check(sumAndSimplifyFractions(listOf(\"1/6\", \"1/4\", \"1/3\")) == \"3/4\")\n    check(sumAndSimplifyFractions(listOf(\"1/8\", \"3/8\")) == \"1/2\")\n    check(sumAndSimplifyFractions(listOf(\"2/3\", \"1/3\")) == \"1\")\n}\n\n\nmain()",
    "entry_point": "sumAndSimplifyFractions",
    "signature": "fun sumAndSimplifyFractions(fractions: List<String>): String",
    "docstring": {
      "en": "Sum the given list of fractions and simplify the resulting fraction.\nThe simplification process involves finding the greatest common divisor (GCD)\nof the numerator and the denominator and dividing both by this GCD.\nIf the denominator after simplification is 1, only the numerator is returned.\n\nExample:\n>>> sumAndSimplifyFractions(listOf(\"1/2\", \"1/3\"))\n\"5/6\"\n>>> sumAndSimplifyFractions(listOf(\"1/6\", \"1/4\", \"1/3\"))\n\"3/4\"",
      "sq": "Mbledhni listën e dhënë të thyesave dhe thjeshtoni thyesën e përftuar. Procesi i thjeshtimit përfshin gjetjen e përbashkëtit më të madh (GCD) të numëruesit dhe emëruesit dhe ndarjen e të dyve me këtë GCD. Nëse emëruesi pas thjeshtimit është 1, vetëm numëruesi kthehet.\n\nShembull:\n>>> sumAndSimplifyFractions(listOf(\"1/2\", \"1/3\"))\n\"5/6\"\n>>> sumAndSimplifyFractions(listOf(\"1/6\", \"1/4\", \"1/3\"))\n\"3/4\"",
      "hy": "Գումարեք տրված կոտորակների ցանկը և պարզեցրեք ստացված կոտորակը։ Պարզեցման գործընթացը ներառում է համարիչի և հայտարարիչի ամենամեծ ընդհանուր բաժանարարի (GCD) գտնումը և երկուսն էլ այդ GCD-ով բաժանելը։ Եթե պարզեցումից հետո հայտարարիչը 1 է, վերադարձվում է միայն համարիչը։\n\nՕրինակ:\n>>> sumAndSimplifyFractions(listOf(\"1/2\", \"1/3\"))\n\"5/6\"\n>>> sumAndSimplifyFractions(listOf(\"1/6\", \"1/4\", \"1/3\"))\n\"3/4\"",
      "bn": "প্রদত্ত ভগ্নাংশের তালিকা যোগ করুন এবং ফলাফল ভগ্নাংশ সরলীকরণ করুন। সরলীকরণ প্রক্রিয়াটি গাণিতিক গরিষ্ঠ সাধারণ গুণনীয়ক (GCD) খুঁজে বের করে এবং উভয়কে এই GCD দ্বারা ভাগ করার মাধ্যমে সম্পন্ন হয়। যদি সরলীকরণের পরে হর 1 হয়, তবে শুধুমাত্র লব্ধাংশ ফেরত দেওয়া হয়।\n\nউদাহরণ:\n>>> sumAndSimplifyFractions(listOf(\"1/2\", \"1/3\"))\n\"5/6\"\n>>> sumAndSimplifyFractions(listOf(\"1/6\", \"1/4\", \"1/3\"))\n\"3/4\"",
      "bg": "Сумирайте дадения списък от дроби и опростете получената дроб.\nПроцесът на опростяване включва намиране на най-големия общ делител (НОД)\nна числителя и знаменателя и делене на двата с този НОД.\nАко знаменателят след опростяването е 1, се връща само числителят.\n\nПример:\n>>> sumAndSimplifyFractions(listOf(\"1/2\", \"1/3\"))\n\"5/6\"\n>>> sumAndSimplifyFractions(listOf(\"1/6\", \"1/4\", \"1/3\"))\n\"3/4\"",
      "zh": "将给定的分数列表相加并简化所得分数。  \n简化过程涉及找到分子和分母的最大公约数 (GCD)，并将两者都除以这个 GCD。  \n如果简化后的分母为 1，则仅返回分子。\n\n示例：\n>>> sumAndSimplifyFractions(listOf(\"1/2\", \"1/3\"))\n\"5/6\"\n>>> sumAndSimplifyFractions(listOf(\"1/6\", \"1/4\", \"1/3\"))\n\"3/4\"",
      "fr": "Additionnez la liste donnée de fractions et simplifiez la fraction résultante. Le processus de simplification implique de trouver le plus grand commun diviseur (PGCD) du numérateur et du dénominateur et de diviser les deux par ce PGCD. Si le dénominateur après simplification est 1, seul le numérateur est renvoyé.\n\nExemple :\n>>> sumAndSimplifyFractions(listOf(\"1/2\", \"1/3\"))\n\"5/6\"\n>>> sumAndSimplifyFractions(listOf(\"1/6\", \"1/4\", \"1/3\"))\n\"3/4\"",
      "de": "Summiere die gegebene Liste von Brüchen und vereinfache den resultierenden Bruch. Der Vereinfachungsprozess beinhaltet das Finden des größten gemeinsamen Teilers (GGT) des Zählers und des Nenners und das Teilen beider durch diesen GGT. Wenn der Nenner nach der Vereinfachung 1 ist, wird nur der Zähler zurückgegeben.\n\nBeispiel:\n>>> sumAndSimplifyFractions(listOf(\"1/2\", \"1/3\"))\n\"5/6\"\n>>> sumAndSimplifyFractions(listOf(\"1/6\", \"1/4\", \"1/3\"))\n\"3/4\"",
      "ha": "Tara jerin kaso da aka bayar kuma sauƙaƙe sakamakon kaso. Tsarin sauƙaƙe yana haɗa da nemo mafi girman abin da za a iya raba shi (GCD) na mai lamba da mai kasa kuma a raba duka biyu da wannan GCD. Idan mai kasa bayan sauƙaƙe ya zama 1, ana mayar da mai lamba kawai.\n\nMisali:\n>>> sumAndSimplifyFractions(listOf(\"1/2\", \"1/3\"))\n\"5/6\"\n>>> sumAndSimplifyFractions(listOf(\"1/6\", \"1/4\", \"1/3\"))\n\"3/4\"",
      "hi": "दिए गए भिन्नों की सूची का योग करें और परिणामी भिन्न को सरल करें। सरलीकरण प्रक्रिया में अंश और हर के महत्तम समापवर्तक (GCD) को खोजना और दोनों को इस GCD से विभाजित करना शामिल है। यदि सरलीकरण के बाद हर 1 है, तो केवल अंश लौटाया जाता है।\n\nउदाहरण:\n>>> sumAndSimplifyFractions(listOf(\"1/2\", \"1/3\"))\n\"5/6\"\n>>> sumAndSimplifyFractions(listOf(\"1/6\", \"1/4\", \"1/3\"))\n\"3/4\"",
      "hu": "Add össze a megadott tört listát, és egyszerűsítsd az eredményül kapott törtet. Az egyszerűsítési folyamat magában foglalja a számláló és a nevező legnagyobb közös osztójának (GCD) megtalálását, majd mindkettő osztását ezzel a GCD-vel. Ha az egyszerűsítés után a nevező 1, csak a számláló kerül visszaadásra.\n\nPélda:\n>>> sumAndSimplifyFractions(listOf(\"1/2\", \"1/3\"))\n\"5/6\"\n>>> sumAndSimplifyFractions(listOf(\"1/6\", \"1/4\", \"1/3\"))\n\"3/4\""
    },
    "docstring_bertscore": {
      "sq": "0.9930217174534823",
      "hy": "0.9878541494604787",
      "bn": "0.94868066297354",
      "bg": "0.9950731720288106",
      "zh": "0.9715410335268454",
      "fr": "0.9930217174534823",
      "de": "0.9970618594037319",
      "ha": "0.9823399714525691",
      "hi": "0.9936591223462232",
      "hu": "0.9869819634573544"
    }
  },
  {
    "task_id": "Kotlin/31",
    "prompt": {
      "en": "/**\n    * Calculate the number of various denominations of currency required to make up a given amount.\n    * The function takes an integer representing the total amount and returns a list of integers.\n    * The list contains the number of 100, 50, 20, 10, 5, and 1 yuan notes needed, in that order.\n    * The goal is to minimize the total number of notes by using larger denominations where possible.\n    *\n    * Example:\n    * >>> calculateCurrency(735)\n    * [7, 0, 1, 1, 1, 0]  // 7*100 + 1*20 + 1*10 + 1*5 = 735\n    * >>> calculateCurrency(123)\n    * [1, 0, 1, 0, 0, 3]  // 1*100 + 1*20 + 3*1 = 123\n**/\nfun calculateCurrency(amount: Int): List<Int> ",
      "sq": "/**\n    * Llogarit numrin e denominimeve të ndryshme të monedhës të nevojshme për të arritur një shumë të caktuar.\n    * Funksioni merr një numër të plotë që përfaqëson shumën totale dhe kthen një listë të numrave të plotë.\n    * Lista përmban numrin e kartëmonedhave prej 100, 50, 20, 10, 5, dhe 1 juan të nevojshme, në atë renditje.\n    * Qëllimi është të minimizohet numri total i kartëmonedhave duke përdorur denominime më të mëdha kur është e mundur.\n    *\n    * Shembull:\n    * >>> calculateCurrency(735)\n    * [7, 0, 1, 1, 1, 0]  // 7*100 + 1*20 + 1*10 + 1*5 = 735\n    * >>> calculateCurrency(123)\n    * [1, 0, 1, 0, 0, 3]  // 1*100 + 1*20 + 3*1 = 123\n**/\nfun calculateCurrency(amount: Int): List<Int> ",
      "hy": "/**\n    * Հաշվել տարբեր անվանական արժեքների արժույթների քանակը, որոնք անհրաժեշտ են տրված գումարը կազմելու համար։\n    * Ֆունկցիան ընդունում է ամբողջ թիվ, որը ներկայացնում է ընդհանուր գումարը և վերադարձնում է ամբողջ թվերի ցուցակ։\n    * Ցուցակը պարունակում է 100, 50, 20, 10, 5 և 1 յուան արժողությամբ թղթադրամների քանակը՝ այդ կարգով։\n    * Նպատակն է նվազեցնել թղթադրամների ընդհանուր քանակը՝ հնարավորության դեպքում օգտագործելով մեծ անվանական արժեքներ։\n    *\n    * Օրինակ:\n    * >>> calculateCurrency(735)\n    * [7, 0, 1, 1, 1, 0]  // 7*100 + 1*20 + 1*10 + 1*5 = 735\n    * >>> calculateCurrency(123)\n    * [1, 0, 1, 0, 0, 3]  // 1*100 + 1*20 + 3*1 = 123\n**/",
      "bn": "/**\n    * প্রদত্ত পরিমাণ তৈরি করতে বিভিন্ন মুদ্রার নোটের সংখ্যা গণনা করুন।\n    * ফাংশনটি মোট পরিমাণকে উপস্থাপনকারী একটি পূর্ণসংখ্যা গ্রহণ করে এবং পূর্ণসংখ্যার একটি তালিকা প্রদান করে।\n    * তালিকাটি ১০০, ৫০, ২০, ১০, ৫, এবং ১ ইউয়ান নোটের সংখ্যা ধারণ করে, এই ক্রমে।\n    * লক্ষ্য হল বড় মুদ্রার নোট ব্যবহার করে মোট নোটের সংখ্যা কমানো।\n    *\n    * উদাহরণ:\n    * >>> calculateCurrency(735)\n    * [7, 0, 1, 1, 1, 0]  // 7*100 + 1*20 + 1*10 + 1*5 = 735\n    * >>> calculateCurrency(123)\n    * [1, 0, 1, 0, 0, 3]  // 1*100 + 1*20 + 3*1 = 123\n**/\nfun calculateCurrency(amount: Int): List<Int> ",
      "bg": "/**\n    * Изчисляване на броя на различните номинали валута, необходими за съставяне на дадена сума.\n    * Функцията приема цяло число, представляващо общата сума, и връща списък от цели числа.\n    * Списъкът съдържа броя на банкнотите от 100, 50, 20, 10, 5 и 1 юан, в този ред.\n    * Целта е да се минимизира общият брой банкноти, като се използват по-големи номинали, където е възможно.\n    *\n    * Пример:\n    * >>> calculateCurrency(735)\n    * [7, 0, 1, 1, 1, 0]  // 7*100 + 1*20 + 1*10 + 1*5 = 735\n    * >>> calculateCurrency(123)\n    * [1, 0, 1, 0, 0, 3]  // 1*100 + 1*20 + 3*1 = 123\n**/",
      "zh": "/**\n    * 计算需要多少种不同面额的货币来凑成给定的金额。\n    * 该函数接受一个表示总金额的整数，并返回一个整数列表。\n    * 列表包含所需的100、50、20、10、5和1元纸币的数量，按此顺序排列。\n    * 目标是通过尽可能使用较大面额来最小化纸币的总数量。\n    *\n    * 示例:\n    * >>> calculateCurrency(735)\n    * [7, 0, 1, 1, 1, 0]  // 7*100 + 1*20 + 1*10 + 1*5 = 735\n    * >>> calculateCurrency(123)\n    * [1, 0, 1, 0, 0, 3]  // 1*100 + 1*20 + 3*1 = 123\n**/\nfun calculateCurrency(amount: Int): List<Int> ",
      "fr": "/**\n    * Calculer le nombre de diverses dénominations de monnaie nécessaires pour constituer un montant donné.\n    * La fonction prend un entier représentant le montant total et renvoie une liste d'entiers.\n    * La liste contient le nombre de billets de 100, 50, 20, 10, 5 et 1 yuan nécessaires, dans cet ordre.\n    * L'objectif est de minimiser le nombre total de billets en utilisant des dénominations plus grandes lorsque c'est possible.\n    *\n    * Exemple :\n    * >>> calculateCurrency(735)\n    * [7, 0, 1, 1, 1, 0]  // 7*100 + 1*20 + 1*10 + 1*5 = 735\n    * >>> calculateCurrency(123)\n    * [1, 0, 1, 0, 0, 3]  // 1*100 + 1*20 + 3*1 = 123\n**/",
      "de": "/**\n    * Berechne die Anzahl der verschiedenen Währungsdenominationen, die erforderlich sind, um einen gegebenen Betrag zu erreichen.\n    * Die Funktion nimmt eine ganze Zahl, die den Gesamtbetrag darstellt, und gibt eine Liste von ganzen Zahlen zurück.\n    * Die Liste enthält die Anzahl der 100, 50, 20, 10, 5 und 1 Yuan-Scheine, die benötigt werden, in dieser Reihenfolge.\n    * Das Ziel ist es, die Gesamtanzahl der Scheine zu minimieren, indem größere Denominationen verwendet werden, wo möglich.\n    *\n    * Beispiel:\n    * >>> calculateCurrency(735)\n    * [7, 0, 1, 1, 1, 0]  // 7*100 + 1*20 + 1*10 + 1*5 = 735\n    * >>> calculateCurrency(123)\n    * [1, 0, 1, 0, 0, 3]  // 1*100 + 1*20 + 3*1 = 123\n**/",
      "ha": "/**\n    * Lissafa adadin nau'ikan kudade daban-daban da ake bukata don samar da wani adadi.\n    * Aikin yana karɓar lamba mai nuna jimillar adadin kuma yana mayar da jerin lambobi.\n    * Jerin yana ƙunshe da adadin takardun kudi na 100, 50, 20, 10, 5, da 1 yuan da ake bukata, a wannan tsari.\n    * Manufar ita ce rage jimillar adadin takardun kudi ta amfani da manyan nau'ikan idan zai yiwu.\n    *\n    * Misali:\n    * >>> calculateCurrency(735)\n    * [7, 0, 1, 1, 1, 0]  // 7*100 + 1*20 + 1*10 + 1*5 = 735\n    * >>> calculateCurrency(123)\n    * [1, 0, 1, 0, 0, 3]  // 1*100 + 1*20 + 3*1 = 123\n**/\nfun calculateCurrency(amount: Int): List<Int> ",
      "hi": "/**\n    * दिए गए राशि को बनाने के लिए आवश्यक विभिन्न मूल्यवर्ग की मुद्रा की संख्या की गणना करें।\n    * फ़ंक्शन एक पूर्णांक लेता है जो कुल राशि का प्रतिनिधित्व करता है और पूर्णांकों की एक सूची लौटाता है।\n    * सूची में 100, 50, 20, 10, 5, और 1 युआन नोटों की संख्या होती है, इसी क्रम में।\n    * लक्ष्य कुल नोटों की संख्या को कम करना है, जहाँ संभव हो बड़े मूल्यवर्ग का उपयोग करके।\n    *\n    * उदाहरण:\n    * >>> calculateCurrency(735)\n    * [7, 0, 1, 1, 1, 0]  // 7*100 + 1*20 + 1*10 + 1*5 = 735\n    * >>> calculateCurrency(123)\n    * [1, 0, 1, 0, 0, 3]  // 1*100 + 1*20 + 3*1 = 123\n**/",
      "hu": "/**\n    * Számítsa ki, hogy egy adott összeghez hány különböző címletű bankjegyre van szükség.\n    * A függvény egy egész számot vesz át, amely a teljes összeget jelenti, és egy egész számokat tartalmazó listát ad vissza.\n    * A lista tartalmazza a szükséges 100, 50, 20, 10, 5 és 1 jüan címletek számát, ebben a sorrendben.\n    * A cél az, hogy minimalizáljuk a bankjegyek teljes számát azáltal, hogy lehetőség szerint nagyobb címleteket használunk.\n    *\n    * Példa:\n    * >>> calculateCurrency(735)\n    * [7, 0, 1, 1, 1, 0]  // 7*100 + 1*20 + 1*10 + 1*5 = 735\n    * >>> calculateCurrency(123)\n    * [1, 0, 1, 0, 0, 3]  // 1*100 + 1*20 + 3*1 = 123\n**/"
    },
    "prompt_bertscore": {
      "sq": "0.9538672994831231",
      "hy": "0.9563787820209282",
      "bn": "0.9541765669863944",
      "bg": "0.9563531587017747",
      "zh": "0.972671836286077",
      "fr": "0.9669574388540843",
      "de": "0.9500851783978378",
      "ha": "0.9660322185392237",
      "hi": "0.9614059183345401",
      "hu": "0.9427575050110797"
    },
    "canonical_solution": "{\n    val denominations = listOf(100, 50, 20, 10, 5, 1)\n    var remainingAmount = amount\n    val result = mutableListOf<Int>()\n\n    for (denomination in denominations) {\n        val count = remainingAmount / denomination\n        remainingAmount -= count * denomination\n        result.add(count)\n    }\n\n    return result\n}",
    "instruction": {
      "en": "Write a Kotlin function `fun calculateCurrency(amount: Int): List<Int>` to solve the following problem:\nCalculate the number of various denominations of currency required to make up a given amount.\nThe function takes an integer representing the total amount and returns a list of integers.\nThe list contains the number of 100, 50, 20, 10, 5, and 1 yuan notes needed, in that order.\nThe goal is to minimize the total number of notes by using larger denominations where possible.\n\nExample:\n>>> calculateCurrency(735)\n[7, 0, 1, 1, 1, 0]  // 7*100 + 1*20 + 1*10 + 1*5 = 735\n>>> calculateCurrency(123)\n[1, 0, 1, 0, 0, 3]  // 1*100 + 1*20 + 3*1 = 123",
      "sq": "Shkruani një funksion Kotlin `fun calculateCurrency(amount: Int): List<Int>` për të zgjidhur problemin e mëposhtëm:\nLlogaritni numrin e denominimeve të ndryshme të monedhës të nevojshme për të përbërë një shumë të caktuar.\nFunksioni merr një numër të plotë që përfaqëson shumën totale dhe kthen një listë të numrave të plotë.\nLista përmban numrin e kartëmonedhave prej 100, 50, 20, 10, 5, dhe 1 juan të nevojshme, në atë renditje.\nQëllimi është të minimizohet numri total i kartëmonedhave duke përdorur denominime më të mëdha kur është e mundur.\n\nShembull:\n>>> calculateCurrency(735)\n[7, 0, 1, 1, 1, 0]  // 7*100 + 1*20 + 1*10 + 1*5 = 735\n>>> calculateCurrency(123)\n[1, 0, 1, 0, 0, 3]  // 1*100 + 1*20 + 3*1 = 123",
      "hy": "Գրեք Kotlin ֆունկցիա `fun calculateCurrency(amount: Int): List<Int>` հետևյալ խնդիրը լուծելու համար:\nՀաշվել տարբեր անվանական արժեքների արժույթների քանակը, որոնք անհրաժեշտ են տրված գումարը կազմելու համար:\nՖունկցիան ընդունում է ամբողջ թիվ, որը ներկայացնում է ընդհանուր գումարը և վերադարձնում է ամբողջ թվերի ցուցակ:\nՑուցակը պարունակում է 100, 50, 20, 10, 5 և 1 յուանների թղթադրամների քանակը, այդ կարգով:\nՆպատակն է նվազեցնել թղթադրամների ընդհանուր քանակը՝ հնարավորության դեպքում օգտագործելով մեծ անվանական արժեքներ:\n\nՕրինակ:\n>>> calculateCurrency(735)\n[7, 0, 1, 1, 1, 0]  // 7*100 + 1*20 + 1*10 + 1*5 = 735\n>>> calculateCurrency(123)\n[1, 0, 1, 0, 0, 3]  // 1*100 + 1*20 + 3*1 = 123",
      "bn": "Kotlin ফাংশন `fun calculateCurrency(amount: Int): List<Int>` লিখুন নিম্নলিখিত সমস্যার সমাধানের জন্য:\nএকটি নির্দিষ্ট পরিমাণ তৈরি করতে প্রয়োজনীয় বিভিন্ন মুদ্রার মানের সংখ্যা গণনা করুন।\nফাংশনটি মোট পরিমাণের প্রতিনিধিত্বকারী একটি পূর্ণসংখ্যা গ্রহণ করে এবং পূর্ণসংখ্যার একটি তালিকা প্রদান করে।\nতালিকায় 100, 50, 20, 10, 5, এবং 1 ইউয়ান নোটের সংখ্যা রয়েছে, সেই ক্রমে।\nলক্ষ্য হল বড় মুদ্রার মান ব্যবহার করে মোট নোটের সংখ্যা কমানো।\n\nউদাহরণ:\n>>> calculateCurrency(735)\n[7, 0, 1, 1, 1, 0]  // 7*100 + 1*20 + 1*10 + 1*5 = 735\n>>> calculateCurrency(123)\n[1, 0, 1, 0, 0, 3]  // 1*100 + 1*20 + 3*1 = 123",
      "bg": "Напишете функция на Kotlin `fun calculateCurrency(amount: Int): List<Int>`, за да решите следния проблем:\nИзчислете броя на различните деноминации на валута, необходими за съставяне на дадена сума.\nФункцията приема цяло число, представляващо общата сума, и връща списък от цели числа.\nСписъкът съдържа броя на банкнотите от 100, 50, 20, 10, 5 и 1 юан, необходими в този ред.\nЦелта е да се минимизира общият брой на банкнотите, като се използват по-големи деноминации, където е възможно.\n\nПример:\n>>> calculateCurrency(735)\n[7, 0, 1, 1, 1, 0]  // 7*100 + 1*20 + 1*10 + 1*5 = 735\n>>> calculateCurrency(123)\n[1, 0, 1, 0, 0, 3]  // 1*100 + 1*20 + 3*1 = 123",
      "zh": "编写一个 Kotlin 函数 `fun calculateCurrency(amount: Int): List<Int>` 来解决以下问题：\n计算需要多少种不同面额的货币来组成给定金额。\n该函数接受一个表示总金额的整数，并返回一个整数列表。\n列表包含需要的100、50、20、10、5和1元纸币的数量，按此顺序排列。\n目标是通过尽可能使用较大面额的纸币来最小化纸币的总数量。\n\n示例:\n>>> calculateCurrency(735)\n[7, 0, 1, 1, 1, 0]  // 7*100 + 1*20 + 1*10 + 1*5 = 735\n>>> calculateCurrency(123)\n[1, 0, 1, 0, 0, 3]  // 1*100 + 1*20 + 3*1 = 123",
      "fr": "Écrire une fonction Kotlin `fun calculateCurrency(amount: Int): List<Int>` pour résoudre le problème suivant :\nCalculer le nombre de diverses dénominations de monnaie nécessaires pour constituer un montant donné.\nLa fonction prend un entier représentant le montant total et renvoie une liste d'entiers.\nLa liste contient le nombre de billets de 100, 50, 20, 10, 5 et 1 yuan nécessaires, dans cet ordre.\nL'objectif est de minimiser le nombre total de billets en utilisant des dénominations plus grandes lorsque c'est possible.\n\nExemple :\n>>> calculateCurrency(735)\n[7, 0, 1, 1, 1, 0]  // 7*100 + 1*20 + 1*10 + 1*5 = 735\n>>> calculateCurrency(123)\n[1, 0, 1, 0, 0, 3]  // 1*100 + 1*20 + 3*1 = 123",
      "de": "Schreiben Sie eine Kotlin-Funktion `fun calculateCurrency(amount: Int): List<Int>`, um das folgende Problem zu lösen:\nBerechnen Sie die Anzahl der verschiedenen Währungsstücke, die erforderlich sind, um einen gegebenen Betrag zu bilden.\nDie Funktion nimmt eine ganze Zahl, die den Gesamtbetrag darstellt, und gibt eine Liste von ganzen Zahlen zurück.\nDie Liste enthält die Anzahl der 100, 50, 20, 10, 5 und 1 Yuan-Scheine, die benötigt werden, in dieser Reihenfolge.\nDas Ziel ist es, die Gesamtanzahl der Scheine zu minimieren, indem größere Stückelungen, wo möglich, verwendet werden.\n\nBeispiel:\n>>> calculateCurrency(735)\n[7, 0, 1, 1, 1, 0]  // 7*100 + 1*20 + 1*10 + 1*5 = 735\n>>> calculateCurrency(123)\n[1, 0, 1, 0, 0, 3]  // 1*100 + 1*20 + 3*1 = 123",
      "ha": "Rubuta aikin Kotlin `fun calculateCurrency(amount: Int): List<Int>` don warware matsalar mai zuwa:\nƘididdige adadin nau'ikan kuɗi daban-daban da ake buƙata don samar da adadin da aka bayar.\nAikin yana ɗaukar cikakken lamba wanda ke wakiltar jimillar adadin kuma yana mayar da jerin lambobi.  \nJerin yana ƙunshe da adadin takardun kuɗi na 100, 50, 20, 10, 5, da 1 yuan da ake buƙata, a wannan tsari.  \nManufar ita ce rage jimillar adadin takardun kuɗi ta amfani da manyan nau'ikan inda ya yiwu.  \n\nMisali:  \n>>> calculateCurrency(735)  \n[7, 0, 1, 1, 1, 0]  // 7*100 + 1*20 + 1*10 + 1*5 = 735  \n>>> calculateCurrency(123)  \n[1, 0, 1, 0, 0, 3]  // 1*100 + 1*20 + 3*1 = 123  ",
      "hi": "Kotlin फ़ंक्शन `fun calculateCurrency(amount: Int): List<Int>` लिखें ताकि निम्नलिखित समस्या का समाधान किया जा सके:\nकिसी दिए गए राशि को बनाने के लिए आवश्यक विभिन्न मुद्रा मूल्यवर्गों की संख्या की गणना करें।\nफ़ंक्शन एक पूर्णांक लेता है जो कुल राशि का प्रतिनिधित्व करता है और पूर्णांकों की एक सूची लौटाता है।\nसूची में 100, 50, 20, 10, 5, और 1 युआन नोटों की संख्या होती है, उसी क्रम में।\nलक्ष्य यह है कि जहाँ संभव हो बड़े मूल्यवर्ग का उपयोग करके कुल नोटों की संख्या को न्यूनतम किया जाए।\n\nउदाहरण:\n>>> calculateCurrency(735)\n[7, 0, 1, 1, 1, 0]  // 7*100 + 1*20 + 1*10 + 1*5 = 735\n>>> calculateCurrency(123)\n[1, 0, 1, 0, 0, 3]  // 1*100 + 1*20 + 3*1 = 123",
      "hu": "Írj egy Kotlin függvényt `fun calculateCurrency(amount: Int): List<Int>` a következő probléma megoldására:\nSzámítsd ki, hogy egy adott összeghez hány különböző címletű bankjegyre van szükség.\nA függvény egy egész számot vesz át, amely a teljes összeget jelöli, és egy egész számokat tartalmazó listát ad vissza.\nA lista tartalmazza a szükséges 100, 50, 20, 10, 5 és 1 jüan címletű bankjegyek számát, ebben a sorrendben.\nA cél az, hogy minimalizáljuk a bankjegyek teljes számát azáltal, hogy ahol lehet, nagyobb címleteket használunk.\n\nPélda:\n>>> calculateCurrency(735)\n[7, 0, 1, 1, 1, 0]  // 7*100 + 1*20 + 1*10 + 1*5 = 735\n>>> calculateCurrency(123)\n[1, 0, 1, 0, 0, 3]  // 1*100 + 1*20 + 3*1 = 123"
    },
    "instruction_bertscore": {
      "sq": "0.9938885404363186",
      "hy": "0.9825515128083713",
      "bn": "0.9634444619351012",
      "bg": "0.9793855431650562",
      "zh": "0.9693628527684168",
      "fr": "0.9901596522931506",
      "de": "0.9762318886053653",
      "ha": "0.9770395197346531",
      "hi": "0.9675062545968837",
      "hu": "0.9634333386337633"
    },
    "level": "easy",
    "test": "fun main() {\n    check(calculateCurrency(735) == listOf(7, 0, 1, 1, 1, 0))\n    check(calculateCurrency(123) == listOf(1, 0, 1, 0, 0, 3))\n    check(calculateCurrency(980) == listOf(9, 1, 1, 1, 0, 0))\n    check(calculateCurrency(50) == listOf(0, 1, 0, 0, 0, 0))\n}\n\nmain()",
    "entry_point": "calculateCurrency",
    "signature": "fun calculateCurrency(amount: Int): List<Int>",
    "docstring": {
      "en": "Calculate the number of various denominations of currency required to make up a given amount.\nThe function takes an integer representing the total amount and returns a list of integers.\nThe list contains the number of 100, 50, 20, 10, 5, and 1 yuan notes needed, in that order.\nThe goal is to minimize the total number of notes by using larger denominations where possible.\n\nExample:\n>>> calculateCurrency(735)\n[7, 0, 1, 1, 1, 0]  // 7*100 + 1*20 + 1*10 + 1*5 = 735\n>>> calculateCurrency(123)\n[1, 0, 1, 0, 0, 3]  // 1*100 + 1*20 + 3*1 = 123",
      "sq": "Llogarit numrin e denominimeve të ndryshme të monedhës të nevojshme për të arritur një shumë të caktuar.\nFunksioni merr një numër të plotë që përfaqëson shumën totale dhe kthen një listë me numra të plotë.\nLista përmban numrin e kartëmonedhave prej 100, 50, 20, 10, 5 dhe 1 yuan të nevojshme, në atë renditje.\nQëllimi është të minimizohet numri total i kartëmonedhave duke përdorur denominime më të mëdha kur është e mundur.\n\nShembull:\n>>> calculateCurrency(735)\n[7, 0, 1, 1, 1, 0]  // 7*100 + 1*20 + 1*10 + 1*5 = 735\n>>> calculateCurrency(123)\n[1, 0, 1, 0, 0, 3]  // 1*100 + 1*20 + 3*1 = 123",
      "hy": "Հաշվել անհրաժեշտ տարադրամի տարբեր անվանական արժեքների քանակը՝ տրված գումարը կազմելու համար։\nՖունկցիան ընդունում է ամբողջ թիվ, որը ներկայացնում է ընդհանուր գումարը և վերադարձնում է ամբողջ թվերի ցուցակ։\nՑուցակը պարունակում է 100, 50, 20, 10, 5 և 1 յուանանոց թղթադրամների քանակը՝ այդ կարգով։\nՆպատակն է նվազեցնել թղթադրամների ընդհանուր քանակը՝ հնարավորինս օգտագործելով ավելի մեծ անվանական արժեքներ։\n\nՕրինակ:\n>>> calculateCurrency(735)\n[7, 0, 1, 1, 1, 0]  // 7*100 + 1*20 + 1*10 + 1*5 = 735\n>>> calculateCurrency(123)\n[1, 0, 1, 0, 0, 3]  // 1*100 + 1*20 + 3*1 = 123",
      "bn": "বিভিন্ন মুদ্রার মানের সংখ্যা গণনা করুন যা একটি নির্দিষ্ট পরিমাণ তৈরি করতে প্রয়োজন। \nফাংশনটি একটি পূর্ণসংখ্যা নেয় যা মোট পরিমাণকে প্রতিনিধিত্ব করে এবং পূর্ণসংখ্যার একটি তালিকা প্রদান করে। \nতালিকাটি ১০০, ৫০, ২০, ১০, ৫, এবং ১ ইউয়ান নোটের সংখ্যা ধারণ করে, সেই ক্রমে। \nলক্ষ্য হল বড় মুদ্রার মান ব্যবহার করে মোট নোটের সংখ্যা কমানো।\n\nউদাহরণ:\n>>> calculateCurrency(735)\n[7, 0, 1, 1, 1, 0]  // 7*100 + 1*20 + 1*10 + 1*5 = 735\n>>> calculateCurrency(123)\n[1, 0, 1, 0, 0, 3]  // 1*100 + 1*20 + 3*1 = 123",
      "bg": "Изчислява броя на различните номинали на валута, необходими за съставяне на дадена сума. Функцията приема цяло число, представляващо общата сума, и връща списък от цели числа. Списъкът съдържа броя на банкнотите от 100, 50, 20, 10, 5 и 1 юан, необходими в този ред. Целта е да се минимизира общият брой банкноти, като се използват по-големи номинали, когато е възможно.\n\nПример:\n>>> calculateCurrency(735)\n[7, 0, 1, 1, 1, 0]  // 7*100 + 1*20 + 1*10 + 1*5 = 735\n>>> calculateCurrency(123)\n[1, 0, 1, 0, 0, 3]  // 1*100 + 1*20 + 3*1 = 123",
      "zh": "计算所需的各种面额的货币数量以组成给定金额。\n该函数接受一个表示总金额的整数，并返回一个整数列表。\n列表包含所需的100、50、20、10、5和1元纸币的数量，按此顺序排列。\n目标是通过尽可能使用较大面额来最小化纸币的总数量。\n\n示例：\n>>> calculateCurrency(735)\n[7, 0, 1, 1, 1, 0]  // 7*100 + 1*20 + 1*10 + 1*5 = 735\n>>> calculateCurrency(123)\n[1, 0, 1, 0, 0, 3]  // 1*100 + 1*20 + 3*1 = 123",
      "fr": "Calculer le nombre de diverses dénominations de monnaie nécessaires pour constituer un montant donné.  \nLa fonction prend un entier représentant le montant total et renvoie une liste d'entiers.  \nLa liste contient le nombre de billets de 100, 50, 20, 10, 5 et 1 yuan nécessaires, dans cet ordre.  \nL'objectif est de minimiser le nombre total de billets en utilisant des dénominations plus grandes lorsque c'est possible.\n\nExemple:\n>>> calculateCurrency(735)\n[7, 0, 1, 1, 1, 0]  // 7*100 + 1*20 + 1*10 + 1*5 = 735\n>>> calculateCurrency(123)\n[1, 0, 1, 0, 0, 3]  // 1*100 + 1*20 + 3*1 = 123",
      "de": "Berechne die Anzahl der verschiedenen Währungsdenominationen, die benötigt werden, um einen gegebenen Betrag zu bilden.\nDie Funktion nimmt eine ganze Zahl, die den Gesamtbetrag darstellt, und gibt eine Liste von ganzen Zahlen zurück.\nDie Liste enthält die Anzahl der 100, 50, 20, 10, 5 und 1 Yuan-Scheine, die benötigt werden, in dieser Reihenfolge.\nDas Ziel ist es, die Gesamtanzahl der Scheine zu minimieren, indem größere Denominationen, wo möglich, verwendet werden.\n\nBeispiel:\n>>> calculateCurrency(735)\n[7, 0, 1, 1, 1, 0]  // 7*100 + 1*20 + 1*10 + 1*5 = 735\n>>> calculateCurrency(123)\n[1, 0, 1, 0, 0, 3]  // 1*100 + 1*20 + 3*1 = 123",
      "ha": "Ƙididdige adadin nau'ikan kuɗi daban-daban da ake buƙata don samar da adadin da aka bayar.\nAikin yana daukar lamba mai nuna jimillar adadin kuma yana mayar da jerin lambobi.\nJerin yana dauke da adadin takardun kudi na 100, 50, 20, 10, 5, da 1 yuan da ake bukata, a wannan tsari.\nManufar ita ce rage adadin takardun kudi ta hanyar amfani da manyan nau'ikan kudade idan zai yiwu.\n\nMisali:\n>>> calculateCurrency(735)\n[7, 0, 1, 1, 1, 0]  // 7*100 + 1*20 + 1*10 + 1*5 = 735\n>>> calculateCurrency(123)\n[1, 0, 1, 0, 0, 3]  // 1*100 + 1*20 + 3*1 = 123",
      "hi": "दी गई राशि को बनाने के लिए विभिन्न मुद्रा मूल्यवर्गों की संख्या की गणना करें।\nयह फ़ंक्शन कुल राशि का प्रतिनिधित्व करने वाले एक पूर्णांक को लेता है और पूर्णांकों की एक सूची लौटाता है।\nसूची में 100, 50, 20, 10, 5, और 1 युआन नोटों की संख्या होती है, इसी क्रम में।\nलक्ष्य बड़े मूल्यवर्गों का उपयोग करके नोटों की कुल संख्या को कम करना है।\n\nउदाहरण:\n>>> calculateCurrency(735)\n[7, 0, 1, 1, 1, 0]  // 7*100 + 1*20 + 1*10 + 1*5 = 735\n>>> calculateCurrency(123)\n[1, 0, 1, 0, 0, 3]  // 1*100 + 1*20 + 3*1 = 123",
      "hu": "Számítsa ki a különböző címletek számát, amelyek szükségesek egy adott összeg eléréséhez.\nA függvény egy egész számot vesz át, amely a teljes összeget jelöli, és egy egész számokból álló listát ad vissza.\nA lista tartalmazza a szükséges 100, 50, 20, 10, 5 és 1 jüan bankjegyek számát, ebben a sorrendben.\nA cél az, hogy minimalizáljuk a bankjegyek teljes számát azáltal, hogy lehetőség szerint nagyobb címleteket használunk.\n\nPélda:\n>>> calculateCurrency(735)\n[7, 0, 1, 1, 1, 0]  // 7*100 + 1*20 + 1*10 + 1*5 = 735\n>>> calculateCurrency(123)\n[1, 0, 1, 0, 0, 3]  // 1*100 + 1*20 + 3*1 = 123"
    },
    "docstring_bertscore": {
      "sq": "0.9741045572244816",
      "hy": "0.9878366699869476",
      "bn": "0.9563297203168126",
      "bg": "0.9840372680585122",
      "zh": "0.981012921876875",
      "fr": "0.9890453358555449",
      "de": "0.9764944779690934",
      "ha": "0.9614516033221782",
      "hi": "0.9602723347499741",
      "hu": "0.9748951061410005"
    }
  },
  {
    "task_id": "Kotlin/32",
    "prompt": {
      "en": "/**\n * Finds the n-th three-digit number that is a perfect square and has at least two identical digits.\n * The search is conducted in ascending order.\n *\n * Example:\n * >>> findNthSquareNumberWithDuplicateDigits(1)\n *     100\n * >>> findNthSquareNumberWithDuplicateDigits(2)\n *     121\n */\n\nfun findNthSquareNumberWithDuplicateDigits(n: Int): Int ",
      "sq": "/**\n * Gjen numrin e n-të me tre shifra që është një katror perfekt dhe ka të paktën dy shifra identike.\n * Kërkimi kryhet në rend rritës.\n *\n * Shembull:\n * >>> findNthSquareNumberWithDuplicateDigits(1)\n *     100\n * >>> findNthSquareNumberWithDuplicateDigits(2)\n *     121\n */",
      "hy": "/**\n * Գտնում է n-րդ երեքանիշ թիվը, որը կատարյալ քառակուսի է և ունի առնվազն երկու նույնական թվանշան:\n * Որոնումը կատարվում է աճման կարգով:\n *\n * Օրինակ:\n * >>> findNthSquareNumberWithDuplicateDigits(1)\n *     100\n * >>> findNthSquareNumberWithDuplicateDigits(2)\n *     121\n */",
      "bn": "/**\n * n-তম তিন অঙ্কের সংখ্যা খুঁজে বের করে যা একটি পূর্ণবর্গ সংখ্যা এবং যার অন্তত দুটি অভিন্ন অঙ্ক রয়েছে।\n * অনুসন্ধান ঊর্ধ্বক্রমে পরিচালিত হয়।\n *\n * উদাহরণ:\n * >>> findNthSquareNumberWithDuplicateDigits(1)\n *     100\n * >>> findNthSquareNumberWithDuplicateDigits(2)\n *     121\n */ \n\nfun findNthSquareNumberWithDuplicateDigits(n: Int): Int ",
      "bg": "/**\n * Намира n-тото трицифрено число, което е точен квадрат и има поне две еднакви цифри.\n * Търсенето се извършва във възходящ ред.\n *\n * Пример:\n * >>> findNthSquareNumberWithDuplicateDigits(1)\n *     100\n * >>> findNthSquareNumberWithDuplicateDigits(2)\n *     121\n */",
      "zh": "/**\n * 查找第n个三位数，它是一个完全平方数，并且至少有两个相同的数字。\n * 搜索按升序进行。\n *\n * 示例:\n * >>> findNthSquareNumberWithDuplicateDigits(1)\n *     100\n * >>> findNthSquareNumberWithDuplicateDigits(2)\n *     121\n */",
      "fr": "/**\n * Trouve le n-ième nombre à trois chiffres qui est un carré parfait et qui a au moins deux chiffres identiques.\n * La recherche est effectuée dans l'ordre croissant.\n *\n * Exemple:\n * >>> findNthSquareNumberWithDuplicateDigits(1)\n *     100\n * >>> findNthSquareNumberWithDuplicateDigits(2)\n *     121\n */",
      "de": "/**\n * Findet die n-te dreistellige Zahl, die ein perfektes Quadrat ist und mindestens zwei identische Ziffern hat.\n * Die Suche wird in aufsteigender Reihenfolge durchgeführt.\n *\n * Beispiel:\n * >>> findNthSquareNumberWithDuplicateDigits(1)\n *     100\n * >>> findNthSquareNumberWithDuplicateDigits(2)\n *     121\n */",
      "ha": "/**\n * Nemi lamba ta uku mai tsari mai cikakken murabba'i wanda ke da aƙalla lambobi biyu masu kama.\n * Ana gudanar da binciken a cikin tsari mai hawa.\n *\n * Misali:\n * >>> findNthSquareNumberWithDuplicateDigits(1)\n *     100\n * >>> findNthSquareNumberWithDuplicateDigits(2)\n *     121\n */ \n\nfun findNthSquareNumberWithDuplicateDigits(n: Int): Int",
      "hi": "/**\n * वह n-वां तीन-अंकीय संख्या खोजता है जो एक पूर्ण वर्ग है और जिसमें कम से कम दो समान अंक होते हैं।\n * खोज आरोही क्रम में की जाती है।\n *\n * उदाहरण:\n * >>> findNthSquareNumberWithDuplicateDigits(1)\n *     100\n * >>> findNthSquareNumberWithDuplicateDigits(2)\n *     121\n */ \n\nfun findNthSquareNumberWithDuplicateDigits(n: Int): Int ",
      "hu": "/**\n * Megkeresi az n-edik háromjegyű számot, amely tökéletes négyzet és legalább két azonos számjeggyel rendelkezik.\n * A keresés növekvő sorrendben történik.\n *\n * Példa:\n * >>> findNthSquareNumberWithDuplicateDigits(1)\n *     100\n * >>> findNthSquareNumberWithDuplicateDigits(2)\n *     121\n */"
    },
    "prompt_bertscore": {
      "sq": "0.9560063500564878",
      "hy": "0.9560063500564878",
      "bn": "0.9909287491285177",
      "bg": "0.9560063500564878",
      "zh": "0.9395835901525232",
      "fr": "0.9560063500564878",
      "de": "0.9577262905258689",
      "ha": "0.9568284812035912",
      "hi": "0.9867724084053626",
      "hu": "0.9577262905258689"
    },
    "canonical_solution": "{\n    val threeDigitSquares = (10..31).map { it * it }.filter { it >= 100 && it < 1000 }\n    val withDuplicateDigits = threeDigitSquares.filter { number ->\n        val digits = number.toString().toCharArray()\n        digits.distinct().size < 3\n    }\n    return withDuplicateDigits[n - 1]\n}",
    "instruction": {
      "en": "Write a Kotlin function `fun findNthSquareNumberWithDuplicateDigits(n: Int): Int` to solve the following problem:\nFinds the n-th three-digit number that is a perfect square and has at least two identical digits.\nThe search is conducted in ascending order.\n\nExample:\n>>> findNthSquareNumberWithDuplicateDigits(1)\n100\n>>> findNthSquareNumberWithDuplicateDigits(2)\n121",
      "sq": "Shkruani një funksion Kotlin `fun findNthSquareNumberWithDuplicateDigits(n: Int): Int` për të zgjidhur problemin në vijim:  \nGjen numrin e n-të me tre shifra që është një katror i përsosur dhe ka të paktën dy shifra identike.  \nKërkimi kryhet në rend rritës.\n\nShembull:  \n>>> findNthSquareNumberWithDuplicateDigits(1)  \n100  \n>>> findNthSquareNumberWithDuplicateDigits(2)  \n121",
      "hy": "Գրեք Kotlin ֆունկցիա `fun findNthSquareNumberWithDuplicateDigits(n: Int): Int` հետևյալ խնդիրը լուծելու համար:\nԳտնում է n-րդ երեքանիշ թիվը, որը կատարյալ քառակուսի է և ունի առնվազն երկու նույնական թվանշան:\nՈրոնումը կատարվում է աճման կարգով:\n\nՕրինակ:\n>>> findNthSquareNumberWithDuplicateDigits(1)\n100\n>>> findNthSquareNumberWithDuplicateDigits(2)\n121",
      "bn": "Kotlin ফাংশন `fun findNthSquareNumberWithDuplicateDigits(n: Int): Int` লিখুন নিম্নলিখিত সমস্যার সমাধানের জন্য:\nn-তম তিন-অঙ্কের সংখ্যা খুঁজে বের করুন যা একটি পূর্ণ বর্গ এবং যার অন্তত দুটি অভিন্ন সংখ্যা রয়েছে।\nঅনুসন্ধানটি ঊর্ধ্বক্রমে পরিচালিত হয়।\n\nউদাহরণ:\n>>> findNthSquareNumberWithDuplicateDigits(1)\n100\n>>> findNthSquareNumberWithDuplicateDigits(2)\n121",
      "bg": "Напишете Kotlin функция `fun findNthSquareNumberWithDuplicateDigits(n: Int): Int`, за да решите следния проблем:\nНамира n-тото трицифрено число, което е точен квадрат и има поне две еднакви цифри.\nТърсенето се извършва във възходящ ред.\n\nПример:\n>>> findNthSquareNumberWithDuplicateDigits(1)\n100\n>>> findNthSquareNumberWithDuplicateDigits(2)\n121",
      "zh": "编写一个 Kotlin 函数 `fun findNthSquareNumberWithDuplicateDigits(n: Int): Int` 来解决以下问题：\n查找第 n 个三位数的完全平方数，并且至少有两个相同的数字。\n搜索按升序进行。\n\n示例:\n>>> findNthSquareNumberWithDuplicateDigits(1)\n100\n>>> findNthSquareNumberWithDuplicateDigits(2)\n121",
      "fr": "Écrire une fonction Kotlin `fun findNthSquareNumberWithDuplicateDigits(n: Int): Int` pour résoudre le problème suivant :\nTrouve le n-ième nombre à trois chiffres qui est un carré parfait et qui a au moins deux chiffres identiques.\nLa recherche est effectuée dans l'ordre croissant.\n\nExemple :\n>>> findNthSquareNumberWithDuplicateDigits(1)\n100\n>>> findNthSquareNumberWithDuplicateDigits(2)\n121",
      "de": "Schreiben Sie eine Kotlin-Funktion `fun findNthSquareNumberWithDuplicateDigits(n: Int): Int`, um das folgende Problem zu lösen:\nFindet die n-te dreistellige Zahl, die ein perfektes Quadrat ist und mindestens zwei identische Ziffern hat.\nDie Suche wird in aufsteigender Reihenfolge durchgeführt.\n\nBeispiel:\n>>> findNthSquareNumberWithDuplicateDigits(1)\n100\n>>> findNthSquareNumberWithDuplicateDigits(2)\n121",
      "ha": "Rubuta aikin Kotlin `fun findNthSquareNumberWithDuplicateDigits(n: Int): Int` don warware matsalar mai zuwa:\nNemo lamba ta n-ta mai tsawon lamba uku wadda cikakkiyar murabba'i ce kuma tana da aƙalla lambobi biyu masu kama.\nAna gudanar da binciken a cikin tsari mai hawa.\n\nMisali:\n>>> findNthSquareNumberWithDuplicateDigits(1)\n100\n>>> findNthSquareNumberWithDuplicateDigits(2)\n121",
      "hi": "Kotlin फ़ंक्शन `fun findNthSquareNumberWithDuplicateDigits(n: Int): Int` लिखें ताकि निम्नलिखित समस्या का समाधान किया जा सके:\nऐसे n-वें तीन-अंकीय संख्या को खोजें जो एक पूर्ण वर्ग है और जिसमें कम से कम दो समान अंक हैं।\nखोज आरोही क्रम में की जाती है।\n\nउदाहरण:\n>>> findNthSquareNumberWithDuplicateDigits(1)\n100\n>>> findNthSquareNumberWithDuplicateDigits(2)\n121",
      "hu": "Írj egy Kotlin függvényt `fun findNthSquareNumberWithDuplicateDigits(n: Int): Int`, hogy megoldja a következő problémát:\nMegtalálja az n-edik háromjegyű számot, amely tökéletes négyzet és legalább két azonos számjegyet tartalmaz.\nA keresés növekvő sorrendben történik.\n\nPélda:\n>>> findNthSquareNumberWithDuplicateDigits(1)\n100\n>>> findNthSquareNumberWithDuplicateDigits(2)\n121"
    },
    "instruction_bertscore": {
      "sq": "0.9978017575730869",
      "hy": "0.9978017575730869",
      "bn": "0.9736181114213271",
      "bg": "0.9936615059107957",
      "zh": "0.9668481921445151",
      "fr": "0.9936615059107957",
      "de": "0.993356211015145",
      "ha": "0.9958235976083605",
      "hi": "0.9738373993619897",
      "hu": "0.9854388040270944"
    },
    "level": "easy",
    "test": "fun main() {\n    check(findNthSquareNumberWithDuplicateDigits(1) == 100)\n    check(findNthSquareNumberWithDuplicateDigits(2) == 121)\n    check(findNthSquareNumberWithDuplicateDigits(3) == 144)  // Example of another test case\n    check(findNthSquareNumberWithDuplicateDigits(4) == 225)  // Example of another test case\n}\n\n\nmain()",
    "entry_point": "findNthSquareNumberWithDuplicateDigits",
    "signature": "fun findNthSquareNumberWithDuplicateDigits(n: Int): Int",
    "docstring": {
      "en": "Finds the n-th three-digit number that is a perfect square and has at least two identical digits.\nThe search is conducted in ascending order.\n\nExample:\n>>> findNthSquareNumberWithDuplicateDigits(1)\n100\n>>> findNthSquareNumberWithDuplicateDigits(2)\n121",
      "sq": "Gjen numrin e tretë me tre shifra që është një katror perfekt dhe ka të paktën dy shifra identike. Kërkimi kryhet në rend rritës.\n\nShembull:\n>>> findNthSquareNumberWithDuplicateDigits(1)\n100\n>>> findNthSquareNumberWithDuplicateDigits(2)\n121",
      "hy": "Գտնում է n-րդ եռանիշ թիվը, որը կատարյալ քառակուսի է և ունի առնվազն երկու նույնական թվանշան:\nՈրոնումը կատարվում է աճման կարգով:\n\nՕրինակ:\n>>> findNthSquareNumberWithDuplicateDigits(1)\n100\n>>> findNthSquareNumberWithDuplicateDigits(2)\n121",
      "bn": "n-তম তিন অঙ্কের সংখ্যা খুঁজে বের করে যা একটি পূর্ণ বর্গ এবং যার অন্তত দুটি অভিন্ন অঙ্ক রয়েছে। অনুসন্ধানটি ঊর্ধ্বক্রমে পরিচালিত হয়।\n\nউদাহরণ:\n>>> findNthSquareNumberWithDuplicateDigits(1)\n100\n>>> findNthSquareNumberWithDuplicateDigits(2)\n121",
      "bg": "Намира n-тото трицифрено число, което е точен квадрат и има поне две еднакви цифри. Търсенето се извършва във възходящ ред.\n\nПример:\n>>> findNthSquareNumberWithDuplicateDigits(1)\n100\n>>> findNthSquareNumberWithDuplicateDigits(2)\n121",
      "zh": "找到第 n 个三位数的完全平方数，并且至少有两个相同的数字。搜索按升序进行。\n\n示例：\n>>> findNthSquareNumberWithDuplicateDigits(1)\n100\n>>> findNthSquareNumberWithDuplicateDigits(2)\n121",
      "fr": "Trouve le n-ième nombre à trois chiffres qui est un carré parfait et qui a au moins deux chiffres identiques.  \nLa recherche est effectuée dans l'ordre croissant.\n\nExemple :\n>>> findNthSquareNumberWithDuplicateDigits(1)\n100\n>>> findNthSquareNumberWithDuplicateDigits(2)\n121",
      "de": "Findet die n-te dreistellige Zahl, die eine perfekte Quadratzahl ist und mindestens zwei identische Ziffern hat. Die Suche erfolgt in aufsteigender Reihenfolge.\n\nBeispiel:\n>>> findNthSquareNumberWithDuplicateDigits(1)\n100\n>>> findNthSquareNumberWithDuplicateDigits(2)\n121",
      "ha": "Yana nemo lamba ta uku mai lamba uku wanda yake cikakken murabba'i kuma yana da aƙalla lambobi biyu masu kama.\nAna gudanar da binciken a cikin tsari mai hawa.\n\nMisali:\n>>> findNthSquareNumberWithDuplicateDigits(1)\n100\n>>> findNthSquareNumberWithDuplicateDigits(2)\n121",
      "hi": "n-वां तीन-अंकीय संख्या खोजता है जो एक पूर्ण वर्ग है और जिसमें कम से कम दो समान अंक हैं। खोज आरोही क्रम में की जाती है।\n\nउदाहरण:\n>>> findNthSquareNumberWithDuplicateDigits(1)\n100\n>>> findNthSquareNumberWithDuplicateDigits(2)\n121",
      "hu": "Megkeresi az n-edik háromjegyű számot, amely tökéletes négyzet és legalább két azonos számjegyet tartalmaz. A keresés növekvő sorrendben történik.\n\nPélda:\n>>> findNthSquareNumberWithDuplicateDigits(1)\n100\n>>> findNthSquareNumberWithDuplicateDigits(2)\n121"
    },
    "docstring_bertscore": {
      "sq": "0.9572593105000559",
      "hy": "0.9972718117164858",
      "bn": "0.9672027473746624",
      "bg": "0.9893049457635574",
      "zh": "0.9483576899739774",
      "fr": "0.9914634621142636",
      "de": "1",
      "ha": "0.9754322026913188",
      "hi": "0.9613735415824315",
      "hu": "0.9840622954865227"
    }
  },
  {
    "task_id": "Kotlin/33",
    "prompt": {
      "en": "/**\n    * Finds the longest word in a given simple English sentence. The sentence ends with a period,\n    * and words are separated by spaces. It assumes no abbreviations or special forms are present.\n    * If there are multiple longest words of the same length, the first one is returned.\n    *\n    * Example:\n    * >>> findLongestWord(\"I am a student of Peking University.\")\n    *     \"University\"\n    * >>> findLongestWord(\"Hello world.\")\n    *     \"Hello\"\n**/\n\nfun findLongestWord(sentence: String): String ",
      "sq": "/**\n    * Gjen fjalën më të gjatë në një fjali të thjeshtë në anglisht. Fjalija përfundon me një pikë,\n    * dhe fjalët ndahen me hapësira. Supozohet se nuk ka shkurtore ose forma të veçanta.\n    * Nëse ka disa fjalë më të gjata me të njëjtën gjatësi, kthehet e para.\n    *\n    * Shembull:\n    * >>> findLongestWord(\"I am a student of Peking University.\")\n    *     \"University\"\n    * >>> findLongestWord(\"Hello world.\")\n    *     \"Hello\"\n**/",
      "hy": "/**\n    * Գտնում է ամենաերկար բառը տրված պարզ անգլերեն նախադասության մեջ։ Նախադասությունը ավարտվում է կետով,\n    * և բառերը բաժանված են բացատներով։ Ենթադրվում է, որ չկան հապավումներ կամ հատուկ ձևեր։\n    * Եթե կան նույն երկարությամբ մի քանի ամենաերկար բառեր, վերադարձվում է առաջինը։\n    *\n    * Օրինակ:\n    * >>> findLongestWord(\"I am a student of Peking University.\")\n    *     \"University\"\n    * >>> findLongestWord(\"Hello world.\")\n    *     \"Hello\"\n**/",
      "bn": "/**\n    * একটি প্রদত্ত সাধারণ ইংরেজি বাক্যে সবচেয়ে দীর্ঘ শব্দটি খুঁজে বের করে। বাক্যটি একটি পূর্ণবিরাম দিয়ে শেষ হয়,\n    * এবং শব্দগুলি স্পেস দ্বারা পৃথক করা হয়। এটি ধরে নেয় যে কোন সংক্ষিপ্ত রূপ বা বিশেষ ফর্ম উপস্থিত নেই।\n    * যদি একই দৈর্ঘ্যের একাধিক দীর্ঘতম শব্দ থাকে, তবে প্রথমটি ফেরত দেওয়া হয়।\n    *\n    * উদাহরণ:\n    * >>> findLongestWord(\"I am a student of Peking University.\")\n    *     \"University\"\n    * >>> findLongestWord(\"Hello world.\")\n    *     \"Hello\"\n**/",
      "bg": "/**\n    * Намира най-дългата дума в дадено просто английско изречение. Изречението завършва с точка,\n    * а думите са разделени с интервали. Предполага се, че няма съкращения или специални форми.\n    * Ако има няколко най-дълги думи с еднаква дължина, се връща първата.\n    *\n    * Пример:\n    * >>> findLongestWord(\"I am a student of Peking University.\")\n    *     \"University\"\n    * >>> findLongestWord(\"Hello world.\")\n    *     \"Hello\"\n**/",
      "zh": "/**\n    * 找出给定简单英语句子中最长的单词。句子以句号结束，单词之间用空格分隔。假设不存在缩写或特殊形式。\n    * 如果有多个长度相同的最长单词，则返回第一个。\n    *\n    * 示例：\n    * >>> findLongestWord(\"I am a student of Peking University.\")\n    *     \"University\"\n    * >>> findLongestWord(\"Hello world.\")\n    *     \"Hello\"\n**/",
      "fr": "/**\n    * Trouve le mot le plus long dans une phrase simple en anglais donnée. La phrase se termine par un point,\n    * et les mots sont séparés par des espaces. Il est supposé qu'il n'y a pas d'abréviations ou de formes spéciales présentes.\n    * S'il y a plusieurs mots les plus longs de la même longueur, le premier est retourné.\n    *\n    * Exemple :\n    * >>> findLongestWord(\"I am a student of Peking University.\")\n    *     \"University\"\n    * >>> findLongestWord(\"Hello world.\")\n    *     \"Hello\"\n**/",
      "de": "/**\n    * Findet das längste Wort in einem gegebenen einfachen englischen Satz. Der Satz endet mit einem Punkt,\n    * und Wörter sind durch Leerzeichen getrennt. Es wird angenommen, dass keine Abkürzungen oder Sonderformen vorhanden sind.\n    * Wenn es mehrere längste Wörter mit derselben Länge gibt, wird das erste zurückgegeben.\n    *\n    * Beispiel:\n    * >>> findLongestWord(\"I am a student of Peking University.\")\n    *     \"University\"\n    * >>> findLongestWord(\"Hello world.\")\n    *     \"Hello\"\n**/ \n\nfun findLongestWord(sentence: String): String ",
      "ha": "/**\n    * Nemi mafi tsayin kalma a cikin jumla mai sauƙi ta Turanci da aka bayar. Jumlar tana ƙarewa da aya,\n    * kuma kalmomi suna rabuwa da sarari. Ana ɗauka babu gajerun kalmomi ko siffofin musamman.\n    * Idan akwai kalmomi masu tsawo iri ɗaya, na farko ake dawowa da shi.\n    *\n    * Misali:\n    * >>> findLongestWord(\"I am a student of Peking University.\")\n    *     \"University\"\n    * >>> findLongestWord(\"Hello world.\")\n    *     \"Hello\"\n**/",
      "hi": "/**\n    * दिए गए सरल अंग्रेजी वाक्य में सबसे लंबा शब्द खोजता है। वाक्य एक पूर्ण विराम के साथ समाप्त होता है,\n    * और शब्दों को रिक्त स्थानों द्वारा अलग किया जाता है। यह मानता है कि कोई संक्षिप्त रूप या विशेष रूप नहीं हैं।\n    * यदि समान लंबाई के कई सबसे लंबे शब्द हैं, तो पहला लौटाया जाता है।\n    *\n    * उदाहरण:\n    * >>> findLongestWord(\"I am a student of Peking University.\")\n    *     \"University\"\n    * >>> findLongestWord(\"Hello world.\")\n    *     \"Hello\"\n**/",
      "hu": "/**\n    * Megkeresi a leghosszabb szót egy adott egyszerű angol mondatban. A mondat ponttal végződik,\n    * és a szavak szóközökkel vannak elválasztva. Feltételezi, hogy nincsenek rövidítések vagy speciális formák jelen.\n    * Ha több azonos hosszúságú leghosszabb szó van, az elsőt adja vissza.\n    *\n    * Példa:\n    * >>> findLongestWord(\"I am a student of Peking University.\")\n    *     \"University\"\n    * >>> findLongestWord(\"Hello world.\")\n    *     \"Hello\"\n**/"
    },
    "prompt_bertscore": {
      "sq": "0.9388476645907889",
      "hy": "0.9370738952881474",
      "bn": "0.9518102832571258",
      "bg": "0.9370738952881474",
      "zh": "0.9323018003837842",
      "fr": "0.9388325686818303",
      "de": "0.9812586276582151",
      "ha": "0.9201146347250077",
      "hi": "0.9515584199339735",
      "hu": "0.9382545542730188"
    },
    "canonical_solution": "{\n    val words = sentence.dropLast(1).split(\" \") // Drop the period and split into words\n    var longestWord = \"\"\n    for (word in words) {\n        if (word.length > longestWord.length) {\n            longestWord = word\n        }\n    }\n    return longestWord\n}",
    "instruction": {
      "en": "Write a Kotlin function `fun findLongestWord(sentence: String): String` to solve the following problem:\nFinds the longest word in a given simple English sentence. The sentence ends with a period,\nand words are separated by spaces. It assumes no abbreviations or special forms are present.\nIf there are multiple longest words of the same length, the first one is returned.\n\nExample:\n>>> findLongestWord(\"I am a student of Peking University.\")\n\"University\"\n>>> findLongestWord(\"Hello world.\")\n\"Hello\"",
      "sq": "Shkruani një funksion Kotlin `fun findLongestWord(sentence: String): String` për të zgjidhur problemin e mëposhtëm:\nGjen fjalën më të gjatë në një fjali të thjeshtë në anglisht. Fjalitë përfundojnë me një pikë, dhe fjalët ndahen me hapësira. Supozohet se nuk ka shkurtesa apo forma speciale të pranishme. Nëse ka disa fjalë më të gjata me të njëjtën gjatësi, kthehet e para.\n\nShembull:\n>>> findLongestWord(\"I am a student of Peking University.\")\n\"University\"\n>>> findLongestWord(\"Hello world.\")\n\"Hello\"",
      "hy": "Գրեք Kotlin ֆունկցիա `fun findLongestWord(sentence: String): String` հետևյալ խնդիրը լուծելու համար:\nԳտնում է ամենաերկար բառը տրված պարզ անգլերեն նախադասության մեջ: Նախադասությունը ավարտվում է կետով,\nև բառերը բաժանված են բացատներով: Ենթադրվում է, որ կրճատումներ կամ հատուկ ձևեր չկան:\nԵթե կան մի քանի ամենաերկար բառեր նույն երկարությամբ, վերադարձվում է առաջինը:\n\nՕրինակ:\n>>> findLongestWord(\"I am a student of Peking University.\")\n\"University\"\n>>> findLongestWord(\"Hello world.\")\n\"Hello\"",
      "bn": "Kotlin ফাংশন `fun findLongestWord(sentence: String): String` লিখুন নিম্নলিখিত সমস্যার সমাধানের জন্য:\nএকটি প্রদত্ত সাধারণ ইংরেজি বাক্যে সবচেয়ে দীর্ঘ শব্দটি খুঁজে বের করে। বাক্যটি একটি পূর্ণবিরতিতে শেষ হয়, এবং শব্দগুলি স্পেস দ্বারা পৃথক হয়। এটি ধরে নেয় যে কোনো সংক্ষিপ্ত রূপ বা বিশেষ ফর্ম নেই। যদি একই দৈর্ঘ্যের একাধিক দীর্ঘতম শব্দ থাকে, তবে প্রথমটি ফেরত দেওয়া হয়।\n\nউদাহরণ:\n>>> findLongestWord(\"I am a student of Peking University.\")\n\"University\"\n>>> findLongestWord(\"Hello world.\")\n\"Hello\"",
      "bg": "Напишете Kotlin функция `fun findLongestWord(sentence: String): String`, за да решите следния проблем:\nНамира най-дългата дума в дадено просто изречение на английски език. Изречението завършва с точка,\nа думите са разделени с интервали. Предполага се, че няма съкращения или специални форми.\nАко има няколко най-дълги думи с еднаква дължина, се връща първата.\n\nПример:\n>>> findLongestWord(\"I am a student of Peking University.\")\n\"University\"\n>>> findLongestWord(\"Hello world.\")\n\"Hello\"",
      "zh": "编写一个 Kotlin 函数 `fun findLongestWord(sentence: String): String` 来解决以下问题：\n找到给定简单英文句子中最长的单词。句子以句号结束，单词之间用空格分隔。假设不存在缩写或特殊形式。\n如果有多个长度相同的最长单词，则返回第一个。\n\n示例:\n>>> findLongestWord(\"I am a student of Peking University.\")\n\"University\"\n>>> findLongestWord(\"Hello world.\")\n\"Hello\"",
      "fr": "Écrire une fonction Kotlin `fun findLongestWord(sentence: String): String` pour résoudre le problème suivant :\nTrouve le mot le plus long dans une phrase simple en anglais donnée. La phrase se termine par un point, et les mots sont séparés par des espaces. Elle suppose qu'il n'y a pas d'abréviations ou de formes spéciales présentes. S'il y a plusieurs mots les plus longs de la même longueur, le premier est retourné.\n\nExemple :\n>>> findLongestWord(\"I am a student of Peking University.\")\n\"University\"\n>>> findLongestWord(\"Hello world.\")\n\"Hello\"",
      "de": "Schreiben Sie eine Kotlin-Funktion `fun findLongestWord(sentence: String): String`, um das folgende Problem zu lösen:\nFindet das längste Wort in einem gegebenen einfachen englischen Satz. Der Satz endet mit einem Punkt, und die Wörter sind durch Leerzeichen getrennt. Es wird angenommen, dass keine Abkürzungen oder Sonderformen vorhanden sind. Wenn es mehrere längste Wörter mit derselben Länge gibt, wird das erste zurückgegeben.\n\nBeispiel:\n>>> findLongestWord(\"I am a student of Peking University.\")\n\"University\"\n>>> findLongestWord(\"Hello world.\")\n\"Hello\"",
      "ha": "Rubuta aikin Kotlin `fun findLongestWord(sentence: String): String` don warware matsalar mai zuwa:  \nNemo mafi tsawon kalma a cikin wata jumla mai sauƙi ta Ingilishi. Jumlar tana ƙarewa da aya,  \nkuma kalmomi suna rabuwa da sarari. Ana ɗauka babu gajerun kalmomi ko siffofi na musamman.\nIdan akwai kalmomi masu tsawo iri ɗaya, na farko ake dawowa da shi.\n\nMisali:  \n>>> findLongestWord(\"I am a student of Peking University.\")  \n\"University\"  \n>>> findLongestWord(\"Hello world.\")  \n\"Hello\"",
      "hi": "Kotlin फ़ंक्शन `fun findLongestWord(sentence: String): String` लिखें ताकि निम्नलिखित समस्या का समाधान किया जा सके:\nदिए गए सरल अंग्रेजी वाक्य में सबसे लंबे शब्द को खोजें। वाक्य एक बिंदु के साथ समाप्त होता है, और शब्दों को रिक्त स्थान द्वारा अलग किया जाता है। यह मान लिया जाता है कि कोई संक्षेप या विशेष रूप नहीं हैं।\nयदि समान लंबाई के कई सबसे लंबे शब्द हैं, तो पहला लौटाया जाता है।\n\nउदाहरण:\n>>> findLongestWord(\"I am a student of Peking University.\")\n\"University\"\n>>> findLongestWord(\"Hello world.\")\n\"Hello\"",
      "hu": "Írj egy Kotlin függvényt `fun findLongestWord(sentence: String): String` a következő probléma megoldására:\nMegkeresi a leghosszabb szót egy adott egyszerű angol mondatban. A mondat ponttal végződik, és a szavak szóközökkel vannak elválasztva. Feltételezi, hogy nincsenek rövidítések vagy speciális formák jelen. Ha több azonos hosszúságú leghosszabb szó van, az első kerül visszaadásra.\n\nPélda:\n>>> findLongestWord(\"I am a student of Peking University.\")\n\"University\"\n>>> findLongestWord(\"Hello world.\")\n\"Hello\""
    },
    "instruction_bertscore": {
      "sq": "0.9705613884875813",
      "hy": "0.9722024726956915",
      "bn": "0.9711451631774428",
      "bg": "0.9737756253134878",
      "zh": "0.9779140893023498",
      "fr": "0.9881902320651896",
      "de": "0.9784672749135319",
      "ha": "0.9492632458811154",
      "hi": "0.9673797270441644",
      "hu": "0.9858058729712469"
    },
    "level": "easy",
    "test": "fun main() {\n    check(findLongestWord(\"I am a student of Peking University.\") == \"University\")\n    check(findLongestWord(\"Hello world.\") == \"Hello\")\n    check(findLongestWord(\"Short sentences are sweet.\") == \"sentences\")\n    check(findLongestWord(\"Each word has its own length.\") == \"length\")\n}\n\n\nmain()",
    "entry_point": "findLongestWord",
    "signature": "fun findLongestWord(sentence: String): String",
    "docstring": {
      "en": "Finds the longest word in a given simple English sentence. The sentence ends with a period,\nand words are separated by spaces. It assumes no abbreviations or special forms are present.\nIf there are multiple longest words of the same length, the first one is returned.\n\nExample:\n>>> findLongestWord(\"I am a student of Peking University.\")\n\"University\"\n>>> findLongestWord(\"Hello world.\")\n\"Hello\"",
      "sq": "Gjen fjalën më të gjatë në një fjali të thjeshtë në anglisht. Fjalitë përfundojnë me një pikë, dhe fjalët ndahen nga hapësira. Supozohet se nuk ka shkurtore ose forma të veçanta. Nëse ka disa fjalë më të gjata me të njëjtën gjatësi, kthehet e para.\n\nShembull:\n>>> findLongestWord(\"I am a student of Peking University.\")\n\"University\"\n>>> findLongestWord(\"Hello world.\")\n\"Hello\"",
      "hy": "Գտնում է ամենաերկար բառը տրված պարզ անգլերեն նախադասության մեջ։ Նախադասությունը ավարտվում է կետով, և բառերը բաժանված են բացատներով։ Ենթադրվում է, որ չկան կրճատումներ կամ հատուկ ձևեր։ Եթե կան մի քանի ամենաերկար բառեր նույն երկարությամբ, վերադարձվում է առաջինը։\n\nՕրինակ:\n>>> findLongestWord(\"I am a student of Peking University.\")\n\"University\"\n>>> findLongestWord(\"Hello world.\")\n\"Hello\"",
      "bn": "একটি প্রদত্ত সাধারণ ইংরেজি বাক্যে সবচেয়ে দীর্ঘ শব্দটি খুঁজে বের করে। বাক্যটি একটি পূর্ণবিরাম দিয়ে শেষ হয়, এবং শব্দগুলি ফাঁক দ্বারা পৃথক করা হয়। এটি ধরে নেয় যে কোন সংক্ষিপ্ত রূপ বা বিশেষ ফর্ম উপস্থিত নেই। যদি একই দৈর্ঘ্যের একাধিক দীর্ঘতম শব্দ থাকে, তবে প্রথমটি ফেরত দেওয়া হয়।\n\nউদাহরণ:\n>>> findLongestWord(\"I am a student of Peking University.\")\n\"University\"\n>>> findLongestWord(\"Hello world.\")\n\"Hello\"",
      "bg": "Намира най-дългата дума в дадено просто английско изречение. Изречението завършва с точка, а думите са разделени с интервали. Предполага се, че няма съкращения или специални форми. Ако има няколко най-дълги думи с еднаква дължина, връща се първата.\n\nПример:\n>>> findLongestWord(\"I am a student of Peking University.\")\n\"University\"\n>>> findLongestWord(\"Hello world.\")\n\"Hello\"",
      "zh": "找到给定简单英文句子中最长的单词。句子以句号结束，单词由空格分隔。假设没有缩写或特殊形式存在。如果有多个长度相同的最长单词，则返回第一个。\n\n示例：\n>>> findLongestWord(\"I am a student of Peking University.\")\n\"University\"\n>>> findLongestWord(\"Hello world.\")\n\"Hello\"",
      "fr": "Trouve le mot le plus long dans une phrase simple en anglais donnée. La phrase se termine par un point, et les mots sont séparés par des espaces. On suppose qu'il n'y a pas d'abréviations ou de formes spéciales présentes. S'il y a plusieurs mots les plus longs de la même longueur, le premier est retourné.\n\nExemple :\n>>> findLongestWord(\"I am a student of Peking University.\")\n\"University\"\n>>> findLongestWord(\"Hello world.\")\n\"Hello\"",
      "de": "Findet das längste Wort in einem gegebenen einfachen englischen Satz. Der Satz endet mit einem Punkt, und die Wörter sind durch Leerzeichen getrennt. Es wird angenommen, dass keine Abkürzungen oder Sonderformen vorhanden sind. Wenn es mehrere längste Wörter mit derselben Länge gibt, wird das erste zurückgegeben.\n\nBeispiel:\n>>> findLongestWord(\"I am a student of Peking University.\")\n\"University\"\n>>> findLongestWord(\"Hello world.\")\n\"Hello\"",
      "ha": "Nemo mafi tsawon kalma a cikin wata jumla mai sauƙi ta Ingilishi. Jumlar tana ƙarewa da aya,\nkuma kalmomi suna rabuwa da sarari. Ana ɗauka babu gajerun kalmomi ko siffofi na musamman.\nIdan akwai kalmomi masu tsawo iri ɗaya, na farko za a mayar.\n\nMisali:\n>>> findLongestWord(\"I am a student of Peking University.\")\n\"University\"\n>>> findLongestWord(\"Hello world.\")\n\"Hello\"",
      "hi": "दिए गए सरल अंग्रेजी वाक्य में सबसे लंबा शब्द खोजता है। वाक्य एक पूर्णविराम के साथ समाप्त होता है, और शब्दों को रिक्त स्थान से अलग किया जाता है। यह मानता है कि कोई संक्षिप्त रूप या विशेष रूप नहीं हैं। यदि समान लंबाई के कई सबसे लंबे शब्द हैं, तो पहला लौटाया जाता है।\n\nउदाहरण:\n>>> findLongestWord(\"I am a student of Peking University.\")\n\"University\"\n>>> findLongestWord(\"Hello world.\")\n\"Hello\"",
      "hu": "Megkeresi a leghosszabb szót egy adott egyszerű angol mondatban. A mondat ponttal végződik, és a szavakat szóközök választják el. Feltételezi, hogy nincsenek rövidítések vagy speciális formák jelen. Ha több azonos hosszúságú leghosszabb szó van, az első kerül visszaadásra.\n\nPélda:\n>>> findLongestWord(\"I am a student of Peking University.\")\n\"University\"\n>>> findLongestWord(\"Hello world.\")\n\"Hello\""
    },
    "docstring_bertscore": {
      "sq": "0.9540587791704407",
      "hy": "0.9682113924495576",
      "bn": "0.9618681312312084",
      "bg": "0.972592384133663",
      "zh": "0.9741514339944058",
      "fr": "0.9713277044976139",
      "de": "0.9715525540889454",
      "ha": "0.9829585064591118",
      "hi": "0.9829908832112204",
      "hu": "0.9823632112071502"
    }
  },
  {
    "task_id": "Kotlin/34",
    "prompt": {
      "en": "/**\n    * Calculates the date of the next day based on a given date in the format yyyy-mm-dd.\n    * Assumes valid input dates ranging from 1600-01-01 to 2999-12-30.\n    *\n    * Example:\n    * >>> getNextDayDate(\"2010-07-05\")\n    *     \"2010-07-06\"\n    * >>> getNextDayDate(\"2020-02-28\")\n    *     \"2020-02-29\"  // For a leap year\n    * >>> getNextDayDate(\"2020-12-31\")\n    *     \"2021-01-01\"  // For end of the year\n**/\n\nfun getNextDayDate(currentDate: String): String ",
      "sq": "/**\n    * Llogarit datën e ditës së ardhshme bazuar në një datë të dhënë në formatin vvvv-mm-dd.\n    * Supozon data hyrëse të vlefshme që variojnë nga 1600-01-01 deri në 2999-12-30.\n    *\n    * Shembull:\n    * >>> getNextDayDate(\"2010-07-05\")\n    *     \"2010-07-06\"\n    * >>> getNextDayDate(\"2020-02-28\")\n    *     \"2020-02-29\"  // Për një vit të brishtë\n    * >>> getNextDayDate(\"2020-12-31\")\n    *     \"2021-01-01\"  // Për fundin e vitit\n**/ \n\nfun getNextDayDate(currentDate: String): String ",
      "hy": "/**\n    * Հաշվում է հաջորդ օրվա ամսաթիվը տրված ամսաթվի հիման վրա yyyy-mm-dd ձևաչափով:\n    * Ենթադրում է վավեր մուտքային ամսաթվեր 1600-01-01-ից մինչև 2999-12-30:\n    *\n    * Օրինակ:\n    * >>> getNextDayDate(\"2010-07-05\")\n    *     \"2010-07-06\"\n    * >>> getNextDayDate(\"2020-02-28\")\n    *     \"2020-02-29\"  // Նահանջ տարի\n    * >>> getNextDayDate(\"2020-12-31\")\n    *     \"2021-01-01\"  // Տարվա վերջ\n**/ \n\nfun getNextDayDate(currentDate: String): String",
      "bn": "/**\n    * প্রদত্ত তারিখের উপর ভিত্তি করে yyyy-mm-dd বিন্যাসে পরবর্তী দিনের তারিখ গণনা করে।\n    * 1600-01-01 থেকে 2999-12-30 পর্যন্ত বৈধ ইনপুট তারিখ অনুমান করে।\n    *\n    * উদাহরণ:\n    * >>> getNextDayDate(\"2010-07-05\")\n    *     \"2010-07-06\"\n    * >>> getNextDayDate(\"2020-02-28\")\n    *     \"2020-02-29\"  // একটি অধিবর্ষের জন্য\n    * >>> getNextDayDate(\"2020-12-31\")\n    *     \"2021-01-01\"  // বছরের শেষের জন্য\n**/ \n\nfun getNextDayDate(currentDate: String): String ",
      "bg": "/**\n    * Изчислява датата на следващия ден въз основа на дадена дата във формат yyyy-mm-dd.\n    * Предполага валидни входни дати в диапазона от 1600-01-01 до 2999-12-30.\n    *\n    * Пример:\n    * >>> getNextDayDate(\"2010-07-05\")\n    *     \"2010-07-06\"\n    * >>> getNextDayDate(\"2020-02-28\")\n    *     \"2020-02-29\"  // За високосна година\n    * >>> getNextDayDate(\"2020-12-31\")\n    *     \"2021-01-01\"  // За край на годината\n**/ \n\nfun getNextDayDate(currentDate: String): String ",
      "zh": "/**\n    * 根据格式为 yyyy-mm-dd 的给定日期计算下一天的日期。\n    * 假设输入日期有效，范围从 1600-01-01 到 2999-12-30。\n    *\n    * 示例:\n    * >>> getNextDayDate(\"2010-07-05\")\n    *     \"2010-07-06\"\n    * >>> getNextDayDate(\"2020-02-28\")\n    *     \"2020-02-29\"  // 对于闰年\n    * >>> getNextDayDate(\"2020-12-31\")\n    *     \"2021-01-01\"  // 对于年末\n**/",
      "fr": "/**\n    * Calcule la date du jour suivant en fonction d'une date donnée au format aaaa-mm-jj.\n    * Suppose des dates d'entrée valides allant de 1600-01-01 à 2999-12-30.\n    *\n    * Exemple :\n    * >>> getNextDayDate(\"2010-07-05\")\n    *     \"2010-07-06\"\n    * >>> getNextDayDate(\"2020-02-28\")\n    *     \"2020-02-29\"  // Pour une année bissextile\n    * >>> getNextDayDate(\"2020-12-31\")\n    *     \"2021-01-01\"  // Pour la fin de l'année\n**/ \n\nfun getNextDayDate(currentDate: String): String ",
      "de": "/**\n    * Berechnet das Datum des nächsten Tages basierend auf einem gegebenen Datum im Format yyyy-mm-dd.\n    * Geht von gültigen Eingabedaten im Bereich von 1600-01-01 bis 2999-12-30 aus.\n    *\n    * Beispiel:\n    * >>> getNextDayDate(\"2010-07-05\")\n    *     \"2010-07-06\"\n    * >>> getNextDayDate(\"2020-02-28\")\n    *     \"2020-02-29\"  // Für ein Schaltjahr\n    * >>> getNextDayDate(\"2020-12-31\")\n    *     \"2021-01-01\"  // Für das Jahresende\n**/ \n\nfun getNextDayDate(currentDate: String): String ",
      "ha": "/**\n    * Lissafa ranar gobe bisa ga wata ranar da aka bayar a tsarin yyyy-mm-dd.\n    * Yana ɗaukar kwanakin shigar da suka dace daga 1600-01-01 zuwa 2999-12-30.\n    *\n    * Misali:\n    * >>> getNextDayDate(\"2010-07-05\")\n    *     \"2010-07-06\"\n    * >>> getNextDayDate(\"2020-02-28\")\n    *     \"2020-02-29\"  // Don shekara mai tsallakewa\n    * >>> getNextDayDate(\"2020-12-31\")\n    *     \"2021-01-01\"  // Don ƙarshen shekara\n**/",
      "hi": "/**\n    * दिए गए दिनांक के आधार पर अगले दिन की तिथि की गणना करता है, प्रारूप yyyy-mm-dd में।\n    * 1600-01-01 से 2999-12-30 तक की मान्य इनपुट तिथियों को मानता है।\n    *\n    * उदाहरण:\n    * >>> getNextDayDate(\"2010-07-05\")\n    *     \"2010-07-06\"\n    * >>> getNextDayDate(\"2020-02-28\")\n    *     \"2020-02-29\"  // एक लीप वर्ष के लिए\n    * >>> getNextDayDate(\"2020-12-31\")\n    *     \"2021-01-01\"  // वर्ष के अंत के लिए\n**/\n\nfun getNextDayDate(currentDate: String): String ",
      "hu": "/**\n    * Kiszámítja a következő nap dátumát egy megadott dátum alapján az yyyy-mm-dd formátumban.\n    * Feltételezi az érvényes dátumokat, amelyek 1600-01-01 és 2999-12-30 között vannak.\n    *\n    * Példa:\n    * >>> getNextDayDate(\"2010-07-05\")\n    *     \"2010-07-06\"\n    * >>> getNextDayDate(\"2020-02-28\")\n    *     \"2020-02-29\"  // Szökőév esetén\n    * >>> getNextDayDate(\"2020-12-31\")\n    *     \"2021-01-01\"  // Az év végén\n**/\n\nfun getNextDayDate(currentDate: String): String "
    },
    "prompt_bertscore": {
      "sq": "0.9964886121240653",
      "hy": "0.9616597679615028",
      "bn": "0.9848433101447518",
      "bg": "0.9891762332766468",
      "zh": "0.945178412095133",
      "fr": "0.9973266337016514",
      "de": "0.9832800890460073",
      "ha": "0.9548910404669769",
      "hi": "0.9903799333857183",
      "hu": "0.9746809825902448"
    },
    "canonical_solution": "{\n    val (year, month, day) = currentDate.split(\"-\").map { it.toInt() }\n\n    val isLeapYear = (year % 4 == 0 && year % 100 != 0) || (year % 400 == 0)\n    val daysInMonth = when (month) {\n        1, 3, 5, 7, 8, 10, 12 -> 31\n        4, 6, 9, 11 -> 30\n        2 -> if (isLeapYear) 29 else 28\n        else -> throw IllegalArgumentException(\"Invalid month\")\n    }\n\n    var newDay = day\n    var newMonth = month\n    var newYear = year\n\n    newDay++\n    if (newDay > daysInMonth) {\n        newDay = 1\n        newMonth++\n        if (newMonth > 12) {\n            newMonth = 1\n            newYear++\n        }\n    }\n\n    return \"%04d-%02d-%02d\".format(newYear, newMonth, newDay)\n}",
    "instruction": {
      "en": "Write a Kotlin function `fun getNextDayDate(currentDate: String): String` to solve the following problem:\nCalculates the date of the next day based on a given date in the format yyyy-mm-dd.\nAssumes valid input dates ranging from 1600-01-01 to 2999-12-30.\n\nExample:\n>>> getNextDayDate(\"2010-07-05\")\n\"2010-07-06\"\n>>> getNextDayDate(\"2020-02-28\")\n\"2020-02-29\"  // For a leap year\n>>> getNextDayDate(\"2020-12-31\")\n\"2021-01-01\"  // For end of the year",
      "sq": "Shkruani një funksion Kotlin `fun getNextDayDate(currentDate: String): String` për të zgjidhur problemin e mëposhtëm:\nLlogarit datën e ditës së ardhshme bazuar në një datë të dhënë në formatin vvvv-mm-dd.\nSupozon data hyrëse të vlefshme që variojnë nga 1600-01-01 deri në 2999-12-30.\n\nShembull:\n>>> getNextDayDate(\"2010-07-05\")\n\"2010-07-06\"\n>>> getNextDayDate(\"2020-02-28\")\n\"2020-02-29\"  // Për një vit të brishtë\n>>> getNextDayDate(\"2020-12-31\")\n\"2021-01-01\"  // Për fundin e vitit",
      "hy": "Գրեք Kotlin ֆունկցիա `fun getNextDayDate(currentDate: String): String` հետևյալ խնդիրը լուծելու համար:\nՀաշվում է հաջորդ օրվա ամսաթիվը՝ հիմնված տրված ամսաթվի վրա yyyy-mm-dd ձևաչափով:\nԵնթադրում է վավեր մուտքային ամսաթվեր՝ սկսած 1600-01-01-ից մինչև 2999-12-30:\n\nՕրինակ:\n>>> getNextDayDate(\"2010-07-05\")\n\"2010-07-06\"\n>>> getNextDayDate(\"2020-02-28\")\n\"2020-02-29\"  // Նահանջ տարի\n>>> getNextDayDate(\"2020-12-31\")\n\"2021-01-01\"  // Տարվա վերջի համար",
      "bn": "Kotlin ফাংশন `fun getNextDayDate(currentDate: String): String` লিখুন নিম্নলিখিত সমস্যার সমাধানের জন্য:\nপ্রদত্ত yyyy-mm-dd বিন্যাসের তারিখের উপর ভিত্তি করে পরবর্তী দিনের তারিখ গণনা করে।\n1600-01-01 থেকে 2999-12-30 পর্যন্ত বৈধ ইনপুট তারিখ অনুমান করে।\n\nউদাহরণ:\n>>> getNextDayDate(\"2010-07-05\")\n\"2010-07-06\"\n>>> getNextDayDate(\"2020-02-28\")\n\"2020-02-29\"  // একটি অধিবর্ষের জন্য\n>>> getNextDayDate(\"2020-12-31\")\n\"2021-01-01\"  // বছরের শেষের জন্য",
      "bg": "Напишете функция на Kotlin `fun getNextDayDate(currentDate: String): String`, за да решите следния проблем:\nИзчислява датата на следващия ден въз основа на дадена дата във формат yyyy-mm-dd.\nПредполага валидни входни дати в диапазона от 1600-01-01 до 2999-12-30.\n\nПример:\n>>> getNextDayDate(\"2010-07-05\")\n\"2010-07-06\"\n>>> getNextDayDate(\"2020-02-28\")\n\"2020-02-29\"  // За високосна година\n>>> getNextDayDate(\"2020-12-31\")\n\"2021-01-01\"  // За края на годината",
      "zh": "编写一个 Kotlin 函数 `fun getNextDayDate(currentDate: String): String` 来解决以下问题：\n根据给定的日期计算下一天的日期，格式为 yyyy-mm-dd。\n假设输入的日期范围为 1600-01-01 到 2999-12-30。\n\n示例：\n>>> getNextDayDate(\"2010-07-05\")\n\"2010-07-06\"\n>>> getNextDayDate(\"2020-02-28\")\n\"2020-02-29\"  // 对于闰年\n>>> getNextDayDate(\"2020-12-31\")\n\"2021-01-01\"  // 对于年末",
      "fr": "Écrire une fonction Kotlin `fun getNextDayDate(currentDate: String): String` pour résoudre le problème suivant :\nCalcule la date du jour suivant basée sur une date donnée au format aaaa-mm-jj.\nSuppose des dates d'entrée valides allant de 1600-01-01 à 2999-12-30.\n\nExemple :\n>>> getNextDayDate(\"2010-07-05\")\n\"2010-07-06\"\n>>> getNextDayDate(\"2020-02-28\")\n\"2020-02-29\"  // Pour une année bissextile\n>>> getNextDayDate(\"2020-12-31\")\n\"2021-01-01\"  // Pour la fin de l'année",
      "de": "Schreiben Sie eine Kotlin-Funktion `fun getNextDayDate(currentDate: String): String`, um das folgende Problem zu lösen:\nBerechnet das Datum des nächsten Tages basierend auf einem gegebenen Datum im Format yyyy-mm-dd.\nGeht von gültigen Eingabedaten im Bereich von 1600-01-01 bis 2999-12-30 aus.\n\nBeispiel:\n>>> getNextDayDate(\"2010-07-05\")\n\"2010-07-06\"\n>>> getNextDayDate(\"2020-02-28\")\n\"2020-02-29\"  // Für ein Schaltjahr\n>>> getNextDayDate(\"2020-12-31\")\n\"2021-01-01\"  // Für das Jahresende",
      "ha": "Rubuta wani aikin Kotlin `fun getNextDayDate(currentDate: String): String` don warware matsalar mai zuwa:\nLissafa kwanan wata na rana mai zuwa bisa ga wata kwanan wata da aka bayar a cikin tsarin yyyy-mm-dd.\nYana ɗauka ingantattun kwanakin shigarwa daga 1600-01-01 zuwa 2999-12-30.\n\nMisali:\n>>> getNextDayDate(\"2010-07-05\")\n\"2010-07-06\"\n>>> getNextDayDate(\"2020-02-28\")\n\"2020-02-29\"  // Don shekara mai tsalle\n>>> getNextDayDate(\"2020-12-31\")\n\"2021-01-01\"  // Don ƙarshen shekara",
      "hi": "Kotlin फ़ंक्शन `fun getNextDayDate(currentDate: String): String` लिखें ताकि निम्नलिखित समस्या का समाधान किया जा सके:\nदिए गए दिनांक के आधार पर अगले दिन की तिथि की गणना करता है, जो प्रारूप yyyy-mm-dd में होती है।\n1600-01-01 से 2999-12-30 तक की मान्य इनपुट तिथियों को मानता है।\n\nउदाहरण:\n>>> getNextDayDate(\"2010-07-05\")\n\"2010-07-06\"\n>>> getNextDayDate(\"2020-02-28\")\n\"2020-02-29\"  // एक लीप वर्ष के लिए\n>>> getNextDayDate(\"2020-12-31\")\n\"2021-01-01\"  // वर्ष के अंत के लिए",
      "hu": "Írj egy Kotlin függvényt `fun getNextDayDate(currentDate: String): String` a következő probléma megoldására:\nKiszámítja a következő nap dátumát egy adott dátum alapján, az yyyy-mm-dd formátumban.\nFeltételezi, hogy az érvényes bemeneti dátumok 1600-01-01 és 2999-12-30 között vannak.\n\nPélda:\n>>> getNextDayDate(\"2010-07-05\")\n\"2010-07-06\"\n>>> getNextDayDate(\"2020-02-28\")\n\"2020-02-29\"  // Szökőév esetén\n>>> getNextDayDate(\"2020-12-31\")\n\"2021-01-01\"  // Az év vége esetén"
    },
    "instruction_bertscore": {
      "sq": "0.9967792083715193",
      "hy": "0.9725602060119354",
      "bn": "0.9658232593783751",
      "bg": "0.9839719186631518",
      "zh": "0.9729068160268413",
      "fr": "0.9967792083715193",
      "de": "0.9861361952949079",
      "ha": "0.991266420776277",
      "hi": "0.9777106917921701",
      "hu": "0.9701810113078995"
    },
    "level": "hard",
    "test": "fun main() {\n    check(getNextDayDate(\"2010-07-05\") == \"2010-07-06\")\n    check(getNextDayDate(\"2020-02-28\") == \"2020-02-29\") // Leap year case\n    check(getNextDayDate(\"2020-12-31\") == \"2021-01-01\") // End of the year case\n    check(getNextDayDate(\"2019-02-28\") == \"2019-03-01\") // Non-leap year February case\n}\n\nmain()",
    "entry_point": "getNextDayDate",
    "signature": "fun getNextDayDate(currentDate: String): String",
    "docstring": {
      "en": "Calculates the date of the next day based on a given date in the format yyyy-mm-dd.\nAssumes valid input dates ranging from 1600-01-01 to 2999-12-30.\n\nExample:\n>>> getNextDayDate(\"2010-07-05\")\n\"2010-07-06\"\n>>> getNextDayDate(\"2020-02-28\")\n\"2020-02-29\"  // For a leap year\n>>> getNextDayDate(\"2020-12-31\")\n\"2021-01-01\"  // For end of the year",
      "sq": "Llogarit datën e ditës së ardhshme bazuar në një datë të dhënë në formatin vvvv-mm-dd. Supozon data hyrëse të vlefshme që variojnë nga 1600-01-01 deri në 2999-12-30.\n\nShembull:\n>>> getNextDayDate(\"2010-07-05\")\n\"2010-07-06\"\n>>> getNextDayDate(\"2020-02-28\")\n\"2020-02-29\"  // Për një vit të brishtë\n>>> getNextDayDate(\"2020-12-31\")\n\"2021-01-01\"  // Për fundin e vitit",
      "hy": "Հաշվում է հաջորդ օրվա ամսաթիվը՝ հիմնված տրված ամսաթվի վրա yyyy-mm-dd ձևաչափով: \nԵնթադրում է վավեր մուտքային ամսաթվեր՝ 1600-01-01-ից մինչև 2999-12-30:\n\nՕրինակ:\n>>> getNextDayDate(\"2010-07-05\")\n\"2010-07-06\"\n>>> getNextDayDate(\"2020-02-28\")\n\"2020-02-29\"  // Նահանջ տարի համար\n>>> getNextDayDate(\"2020-12-31\")\n\"2021-01-01\"  // Տարվա վերջի համար",
      "bn": "প্রদত্ত তারিখের উপর ভিত্তি করে yyyy-mm-dd ফরম্যাটে পরবর্তী দিনের তারিখ গণনা করে। বৈধ ইনপুট তারিখগুলি 1600-01-01 থেকে 2999-12-30 পর্যন্ত ধরে নেয়।\n\nউদাহরণ:\n>>> getNextDayDate(\"2010-07-05\")\n\"2010-07-06\"\n>>> getNextDayDate(\"2020-02-28\")\n\"2020-02-29\"  // একটি অধিবর্ষের জন্য\n>>> getNextDayDate(\"2020-12-31\")\n\"2021-01-01\"  // বছরের শেষের জন্য",
      "bg": "Изчислява датата на следващия ден въз основа на дадена дата във формат гггг-мм-дд. Предполага валидни входни дати в диапазона от 1600-01-01 до 2999-12-30.\n\nПример:\n>>> getNextDayDate(\"2010-07-05\")\n\"2010-07-06\"\n>>> getNextDayDate(\"2020-02-28\")\n\"2020-02-29\"  // За високосна година\n>>> getNextDayDate(\"2020-12-31\")\n\"2021-01-01\"  // За края на годината",
      "zh": "计算基于给定日期的下一天日期，格式为 yyyy-mm-dd。假设输入日期有效，范围从 1600-01-01 到 2999-12-30。\n\n示例：\n>>> getNextDayDate(\"2010-07-05\")\n\"2010-07-06\"\n>>> getNextDayDate(\"2020-02-28\")\n\"2020-02-29\"  // 对于闰年\n>>> getNextDayDate(\"2020-12-31\")\n\"2021-01-01\"  // 对于年末",
      "fr": "Calcule la date du jour suivant basée sur une date donnée au format aaaa-mm-jj.  \nSuppose des dates d'entrée valides allant du 1600-01-01 au 2999-12-30.\n\nExemple :\n>>> getNextDayDate(\"2010-07-05\")\n\"2010-07-06\"\n>>> getNextDayDate(\"2020-02-28\")\n\"2020-02-29\"  // Pour une année bissextile\n>>> getNextDayDate(\"2020-12-31\")\n\"2021-01-01\"  // Pour la fin de l'année",
      "de": "Berechnet das Datum des nächsten Tages basierend auf einem gegebenen Datum im Format yyyy-mm-dd. Geht von gültigen Eingabedaten im Bereich von 1600-01-01 bis 2999-12-30 aus.\n\nBeispiel:\n>>> getNextDayDate(\"2010-07-05\")\n\"2010-07-06\"\n>>> getNextDayDate(\"2020-02-28\")\n\"2020-02-29\"  // Für ein Schaltjahr\n>>> getNextDayDate(\"2020-12-31\")\n\"2021-01-01\"  // Für das Jahresende",
      "ha": "Yana ƙididdige ranar gobe bisa ga wata rana da aka bayar a cikin tsarin yyyy-mm-dd. \nYana ɗaukar shigarwar kwanan wata masu inganci daga 1600-01-01 zuwa 2999-12-30.\n\nMisali:\n>>> getNextDayDate(\"2010-07-05\")\n\"2010-07-06\"\n>>> getNextDayDate(\"2020-02-28\")\n\"2020-02-29\"  // Don shekara mai ƙabari\n>>> getNextDayDate(\"2020-12-31\")\n\"2021-01-01\"  // Don ƙarshen shekara",
      "hi": "दिए गए दिनांक के आधार पर अगले दिन की तिथि की गणना करता है, प्रारूप yyyy-mm-dd में।\n1600-01-01 से 2999-12-30 तक की मान्य इनपुट तिथियों को मानता है।\n\nउदाहरण:\n>>> getNextDayDate(\"2010-07-05\")\n\"2010-07-06\"\n>>> getNextDayDate(\"2020-02-28\")\n\"2020-02-29\"  // एक लीप वर्ष के लिए\n>>> getNextDayDate(\"2020-12-31\")\n\"2021-01-01\"  // वर्ष के अंत के लिए",
      "hu": "Kiszámítja a következő nap dátumát egy adott dátum alapján az yyyy-mm-dd formátumban. Feltételezi, hogy az érvényes bemeneti dátumok 1600-01-01 és 2999-12-30 között vannak.\n\nPélda:\n>>> getNextDayDate(\"2010-07-05\")\n\"2010-07-06\"\n>>> getNextDayDate(\"2020-02-28\")\n\"2020-02-29\"  // Szökőév esetén\n>>> getNextDayDate(\"2020-12-31\")\n\"2021-01-01\"  // Az év végén"
    },
    "docstring_bertscore": {
      "sq": "0.9957769194688172",
      "hy": "0.9662006571023414",
      "bn": "0.9484413133643931",
      "bg": "0.9866347575513055",
      "zh": "0.9629061736024968",
      "fr": "0.9920651135384183",
      "de": "0.9817468611347989",
      "ha": "0.9744628864318685",
      "hi": "0.990753557132445",
      "hu": "0.9707900120561525"
    }
  },
  {
    "task_id": "Kotlin/35",
    "prompt": {
      "en": "/**\n    * Calculates the number of days between two given dates.\n    * The dates are provided as year, month, and day.\n    * Accounts for leap years in the calculation.\n    *\n    * Example:\n    * >>> daysBetweenDates(2008, 1, 1, 2009, 1, 1)\n    *     366\n    * >>> daysBetweenDates(2010, 1, 1, 2010, 1, 3)\n    *     2\n**/\n\n\n\nfun daysBetweenDates(startYear: Int, startMonth: Int, startDay: Int, endYear: Int, endMonth: Int, endDay: Int): Int",
      "sq": "/**\n    * Llogarit numrin e ditëve midis dy datave të dhëna.\n    * Datat jepen si vit, muaj dhe ditë.\n    * Merr parasysh vitet e brishtë në llogaritje.\n    *\n    * Shembull:\n    * >>> daysBetweenDates(2008, 1, 1, 2009, 1, 1)\n    *     366\n    * >>> daysBetweenDates(2010, 1, 1, 2010, 1, 3)\n    *     2\n**/\n\n\n\nfun daysBetweenDates(startYear: Int, startMonth: Int, startDay: Int, endYear: Int, endMonth: Int, endDay: Int): Int",
      "hy": "/**\n    * Հաշվարկում է օրերի քանակը երկու տրված ամսաթվերի միջև։\n    * Ամսաթվերը տրվում են որպես տարի, ամիս և օր։\n    * Հաշվի է առնում նահանջ տարիները հաշվարկի մեջ։\n    *\n    * Օրինակ:\n    * >>> daysBetweenDates(2008, 1, 1, 2009, 1, 1)\n    *     366\n    * >>> daysBetweenDates(2010, 1, 1, 2010, 1, 3)\n    *     2\n**/\n\n\n\nfun daysBetweenDates(startYear: Int, startMonth: Int, startDay: Int, endYear: Int, endMonth: Int, endDay: Int): Int",
      "bn": "/**\n    * দুটি প্রদত্ত তারিখের মধ্যে দিনের সংখ্যা গণনা করে।\n    * তারিখগুলি বছর, মাস এবং দিন হিসাবে প্রদান করা হয়।\n    * গণনায় অধিবর্ষের হিসাব করে।\n    *\n    * উদাহরণ:\n    * >>> daysBetweenDates(2008, 1, 1, 2009, 1, 1)\n    *     366\n    * >>> daysBetweenDates(2010, 1, 1, 2010, 1, 3)\n    *     2\n**/\n\n\n\nfun daysBetweenDates(startYear: Int, startMonth: Int, startDay: Int, endYear: Int, endMonth: Int, endDay: Int): Int",
      "bg": "/**\n    * Изчислява броя на дните между две дадени дати.\n    * Датите са предоставени като година, месец и ден.\n    * Взема предвид високосните години в изчислението.\n    *\n    * Пример:\n    * >>> daysBetweenDates(2008, 1, 1, 2009, 1, 1)\n    *     366\n    * >>> daysBetweenDates(2010, 1, 1, 2010, 1, 3)\n    *     2\n**/\n\n\n\nfun daysBetweenDates(startYear: Int, startMonth: Int, startDay: Int, endYear: Int, endMonth: Int, endDay: Int): Int",
      "zh": "/**\n    * 计算两个给定日期之间的天数。\n    * 日期以年、月和日的形式提供。\n    * 在计算中考虑闰年。\n    *\n    * 示例:\n    * >>> daysBetweenDates(2008, 1, 1, 2009, 1, 1)\n    *     366\n    * >>> daysBetweenDates(2010, 1, 1, 2010, 1, 3)\n    *     2\n**/\n\n\n\nfun daysBetweenDates(startYear: Int, startMonth: Int, startDay: Int, endYear: Int, endMonth: Int, endDay: Int): Int",
      "fr": "/**\n    * Calcule le nombre de jours entre deux dates données.\n    * Les dates sont fournies sous forme d'année, mois et jour.\n    * Prend en compte les années bissextiles dans le calcul.\n    *\n    * Exemple :\n    * >>> daysBetweenDates(2008, 1, 1, 2009, 1, 1)\n    *     366\n    * >>> daysBetweenDates(2010, 1, 1, 2010, 1, 3)\n    *     2\n**/\n\n\n\nfun daysBetweenDates(startYear: Int, startMonth: Int, startDay: Int, endYear: Int, endMonth: Int, endDay: Int): Int",
      "de": "/**\n    * Berechnet die Anzahl der Tage zwischen zwei gegebenen Daten.\n    * Die Daten werden als Jahr, Monat und Tag angegeben.\n    * Berücksichtigt Schaltjahre in der Berechnung.\n    *\n    * Beispiel:\n    * >>> daysBetweenDates(2008, 1, 1, 2009, 1, 1)\n    *     366\n    * >>> daysBetweenDates(2010, 1, 1, 2010, 1, 3)\n    *     2\n**/\n\n\n\nfun daysBetweenDates(startYear: Int, startMonth: Int, startDay: Int, endYear: Int, endMonth: Int, endDay: Int): Int",
      "ha": "/**\n    * Lissafa yawan kwanaki tsakanin kwanan wata guda biyu da aka bayar.\n    * Ana bayar da kwanakin a matsayin shekara, wata, da rana.\n    * Ya haɗa da shekarun ƙabis a cikin lissafin.\n    *\n    * Misali:\n    * >>> daysBetweenDates(2008, 1, 1, 2009, 1, 1)\n    *     366\n    * >>> daysBetweenDates(2010, 1, 1, 2010, 1, 3)\n    *     2\n**/\n\n\n\nfun daysBetweenDates(startYear: Int, startMonth: Int, startDay: Int, endYear: Int, endMonth: Int, endDay: Int): Int",
      "hi": "/**\n    * दो दिए गए तारीखों के बीच के दिनों की संख्या की गणना करता है।\n    * तारीखें वर्ष, माह, और दिन के रूप में प्रदान की जाती हैं।\n    * गणना में लीप वर्षों का ध्यान रखता है।\n    *\n    * उदाहरण:\n    * >>> daysBetweenDates(2008, 1, 1, 2009, 1, 1)\n    *     366\n    * >>> daysBetweenDates(2010, 1, 1, 2010, 1, 3)\n    *     2\n**/\n\n\n\nfun daysBetweenDates(startYear: Int, startMonth: Int, startDay: Int, endYear: Int, endMonth: Int, endDay: Int): Int",
      "hu": "/**\n    * Kiszámítja a napok számát két megadott dátum között.\n    * A dátumok év, hónap és nap formátumban vannak megadva.\n    * Figyelembe veszi a szökőéveket a számítás során.\n    *\n    * Példa:\n    * >>> daysBetweenDates(2008, 1, 1, 2009, 1, 1)\n    *     366\n    * >>> daysBetweenDates(2010, 1, 1, 2010, 1, 3)\n    *     2\n**/\n\n\n\nfun daysBetweenDates(startYear: Int, startMonth: Int, startDay: Int, endYear: Int, endMonth: Int, endDay: Int): Int"
    },
    "prompt_bertscore": {
      "sq": "0.9833796028669057",
      "hy": "0.9900686795786366",
      "bn": "0.9859018114452868",
      "bg": "0.9909633108148178",
      "zh": "0.9848051731115931",
      "fr": "0.9713378346470467",
      "de": "0.9887259382028408",
      "ha": "0.9916144212038501",
      "hi": "0.9744338863962375",
      "hu": "0.9798433861933417"
    },
    "canonical_solution": "{\n    return daysFromStart(endYear, endMonth, endDay) - daysFromStart(startYear, startMonth, startDay)\n}\nfun isLeapYear(year: Int): Boolean = (year % 4 == 0 && year % 100 != 0) || year % 400 == 0\n\nfun dayOfYear(year: Int, month: Int, day: Int): Int {\n    val daysInMonth = arrayOf(31, 28, 31, 30, 31, 30, 31, 31, 30, 31, 30, 31)\n    var totalDays = day\n    for (i in 0 until month - 1) {\n        totalDays += daysInMonth[i]\n    }\n    if (month > 2 && isLeapYear(year)) totalDays++\n    return totalDays\n}\n\nfun daysFromStart(year: Int, month: Int, day: Int): Int {\n    var days = 0\n    for (y in 1 until year) {\n        days += if (isLeapYear(y)) 366 else 365\n    }\n    days += dayOfYear(year, month, day)\n    return days\n}",
    "instruction": {
      "en": "Write a Kotlin function `fun daysBetweenDates(startYear: Int, startMonth: Int, startDay: Int, endYear: Int, endMonth: Int, endDay: Int): Int` to solve the following problem:\nCalculates the number of days between two given dates.\nThe dates are provided as year, month, and day.\nAccounts for leap years in the calculation.\n\nExample:\n>>> daysBetweenDates(2008, 1, 1, 2009, 1, 1)\n366\n>>> daysBetweenDates(2010, 1, 1, 2010, 1, 3)\n2",
      "sq": "Shkruani një funksion Kotlin `fun daysBetweenDates(startYear: Int, startMonth: Int, startDay: Int, endYear: Int, endMonth: Int, endDay: Int): Int` për të zgjidhur problemin në vijim:\nLlogarit numrin e ditëve midis dy datave të dhëna.\nDatat jepen si vit, muaj dhe ditë.\nLlogarit për vitet e brishta në llogaritje.\n\nShembull:\n>>> daysBetweenDates(2008, 1, 1, 2009, 1, 1)\n366\n>>> daysBetweenDates(2010, 1, 1, 2010, 1, 3)\n2",
      "hy": "Գրեք Kotlin ֆունկցիա `fun daysBetweenDates(startYear: Int, startMonth: Int, startDay: Int, endYear: Int, endMonth: Int, endDay: Int): Int` հետևյալ խնդիրը լուծելու համար:\nՀաշվում է օրերի քանակը երկու տրված ամսաթվերի միջև:\nԱմսաթվերը տրված են որպես տարի, ամիս և օր:\nՀաշվի է առնում նահանջ տարիները հաշվարկի մեջ:\n\nՕրինակ:\n>>> daysBetweenDates(2008, 1, 1, 2009, 1, 1)\n366\n>>> daysBetweenDates(2010, 1, 1, 2010, 1, 3)\n2",
      "bn": "একটি Kotlin ফাংশন `fun daysBetweenDates(startYear: Int, startMonth: Int, startDay: Int, endYear: Int, endMonth: Int, endDay: Int): Int` লিখুন নিম্নলিখিত সমস্যার সমাধানের জন্য:\nদেওয়া দুটি তারিখের মধ্যে দিনের সংখ্যা গণনা করে।\nতারিখগুলি বছর, মাস এবং দিন হিসাবে প্রদান করা হয়।\nগণনায় অধিবর্ষের হিসাব রাখে।\n\nউদাহরণ:\n>>> daysBetweenDates(2008, 1, 1, 2009, 1, 1)\n366\n>>> daysBetweenDates(2010, 1, 1, 2010, 1, 3)\n2",
      "bg": "Напишете Kotlin функция `fun daysBetweenDates(startYear: Int, startMonth: Int, startDay: Int, endYear: Int, endMonth: Int, endDay: Int): Int`, за да решите следния проблем:\nИзчислява броя на дните между две дадени дати.\nДатите са предоставени като година, месец и ден.\nВключва високосните години в изчислението.\n\nПример:\n>>> daysBetweenDates(2008, 1, 1, 2009, 1, 1)\n366\n>>> daysBetweenDates(2010, 1, 1, 2010, 1, 3)\n2",
      "zh": "编写一个 Kotlin 函数 `fun daysBetweenDates(startYear: Int, startMonth: Int, startDay: Int, endYear: Int, endMonth: Int, endDay: Int): Int` 来解决以下问题：\n计算两个给定日期之间的天数。\n日期以年、月、日的形式提供。\n在计算中考虑闰年。\n\n示例:\n>>> daysBetweenDates(2008, 1, 1, 2009, 1, 1)\n366\n>>> daysBetweenDates(2010, 1, 1, 2010, 1, 3)\n2",
      "fr": "Écrire une fonction Kotlin `fun daysBetweenDates(startYear: Int, startMonth: Int, startDay: Int, endYear: Int, endMonth: Int, endDay: Int): Int` pour résoudre le problème suivant :\nCalcule le nombre de jours entre deux dates données.\nLes dates sont fournies sous forme d'année, mois et jour.\nPrend en compte les années bissextiles dans le calcul.\n\nExemple :\n>>> daysBetweenDates(2008, 1, 1, 2009, 1, 1)\n366\n>>> daysBetweenDates(2010, 1, 1, 2010, 1, 3)\n2",
      "de": "Schreiben Sie eine Kotlin-Funktion `fun daysBetweenDates(startYear: Int, startMonth: Int, startDay: Int, endYear: Int, endMonth: Int, endDay: Int): Int`, um das folgende Problem zu lösen:\nBerechnet die Anzahl der Tage zwischen zwei gegebenen Daten.\nDie Daten werden als Jahr, Monat und Tag angegeben.\nBerücksichtigt Schaltjahre in der Berechnung.\n\nBeispiel:\n>>> daysBetweenDates(2008, 1, 1, 2009, 1, 1)\n366\n>>> daysBetweenDates(2010, 1, 1, 2010, 1, 3)\n2",
      "ha": "Rubuta aikin Kotlin `fun daysBetweenDates(startYear: Int, startMonth: Int, startDay: Int, endYear: Int, endMonth: Int, endDay: Int): Int` don warware matsalar mai zuwa:\nLissafa yawan kwanaki tsakanin kwanan wata guda biyu da aka bayar.\nAna bayar da kwanakin a matsayin shekara, wata, da rana.\nYana la'akari da shekaru masu tsalle a cikin lissafin.\n\nMisali:\n>>> daysBetweenDates(2008, 1, 1, 2009, 1, 1)\n366\n>>> daysBetweenDates(2010, 1, 1, 2010, 1, 3)\n2",
      "hi": "Kotlin फ़ंक्शन `fun daysBetweenDates(startYear: Int, startMonth: Int, startDay: Int, endYear: Int, endMonth: Int, endDay: Int): Int` लिखें ताकि निम्नलिखित समस्या का समाधान किया जा सके:\nदो दिए गए तारीखों के बीच के दिनों की संख्या की गणना करता है।\nतारीखें वर्ष, माह, और दिन के रूप में प्रदान की जाती हैं।\nगणना में लीप वर्षों का ध्यान रखता है।\n\nउदाहरण:\n>>> daysBetweenDates(2008, 1, 1, 2009, 1, 1)\n366\n>>> daysBetweenDates(2010, 1, 1, 2010, 1, 3)\n2",
      "hu": "Írj egy Kotlin függvényt `fun daysBetweenDates(startYear: Int, startMonth: Int, startDay: Int, endYear: Int, endMonth: Int, endDay: Int): Int` a következő probléma megoldására:\nKiszámítja a napok számát két adott dátum között.\nA dátumok év, hónap és nap formátumban vannak megadva.\nFigyelembe veszi a szökőéveket a számítás során.\n\nPélda:\n>>> daysBetweenDates(2008, 1, 1, 2009, 1, 1)\n366\n>>> daysBetweenDates(2010, 1, 1, 2010, 1, 3)\n2"
    },
    "instruction_bertscore": {
      "sq": "0.992763497958137",
      "hy": "0.990218844146699",
      "bn": "0.9983243541055897",
      "bg": "0.9937822731824649",
      "zh": "0.9840217748887915",
      "fr": "0.9766680809221179",
      "de": "0.9914318798836791",
      "ha": "0.9817873817325301",
      "hi": "0.9716173075931628",
      "hu": "0.9822436357177672"
    },
    "level": "hard",
    "test": "fun main() {\n    check(daysBetweenDates(2008, 1, 1, 2009, 1, 1) == 366)\n    check(daysBetweenDates(2010, 1, 1, 2010, 1, 3) == 2)\n    check(daysBetweenDates(2020, 5, 15, 2020, 5, 20) == 5)\n    check(daysBetweenDates(2019, 12, 31, 2020, 1, 1) == 1)\n}\n\n\nmain()",
    "entry_point": "daysBetweenDates",
    "signature": "fun daysBetweenDates(startYear: Int, startMonth: Int, startDay: Int, endYear: Int, endMonth: Int, endDay: Int): Int",
    "docstring": {
      "en": "Calculates the number of days between two given dates.\nThe dates are provided as year, month, and day.\nAccounts for leap years in the calculation.\n\nExample:\n>>> daysBetweenDates(2008, 1, 1, 2009, 1, 1)\n366\n>>> daysBetweenDates(2010, 1, 1, 2010, 1, 3)\n2",
      "sq": "Llogarit numrin e ditëve midis dy datave të dhëna.  \nDatat jepen si vit, muaj dhe ditë.  \nMerr parasysh vitet e brishta në llogaritje.\n\nShembull:\n>>> daysBetweenDates(2008, 1, 1, 2009, 1, 1)\n366\n>>> daysBetweenDates(2010, 1, 1, 2010, 1, 3)\n2",
      "hy": "Հաշվում է երկու տրված ամսաթվերի միջև օրերի քանակը։  \nԱմսաթվերը տրվում են որպես տարի, ամիս և օր։  \nՀաշվարկում հաշվի է առնում նահանջ տարիները։\n\nՕրինակ:  \n>>> daysBetweenDates(2008, 1, 1, 2009, 1, 1)  \n366  \n>>> daysBetweenDates(2010, 1, 1, 2010, 1, 3)  \n2",
      "bn": "দুটি প্রদত্ত তারিখের মধ্যে দিনের সংখ্যা গণনা করে।  \nতারিখগুলি বছর, মাস এবং দিন হিসাবে প্রদান করা হয়।  \nলিপ বছরের জন্য গণনায় হিসাব করে।\n\nউদাহরণ:\n>>> daysBetweenDates(2008, 1, 1, 2009, 1, 1)\n366\n>>> daysBetweenDates(2010, 1, 1, 2010, 1, 3)\n2",
      "bg": "Изчислява броя на дните между две дадени дати. Датите са предоставени като година, месец и ден. Включва високосните години в изчислението.\n\nПример:\n>>> daysBetweenDates(2008, 1, 1, 2009, 1, 1)\n366\n>>> daysBetweenDates(2010, 1, 1, 2010, 1, 3)\n2",
      "zh": "计算两个给定日期之间的天数。\n日期以年、月和日的形式提供。\n在计算中考虑闰年。\n\n示例：\n>>> daysBetweenDates(2008, 1, 1, 2009, 1, 1)\n366\n>>> daysBetweenDates(2010, 1, 1, 2010, 1, 3)\n2",
      "fr": "Calcule le nombre de jours entre deux dates données.  \nLes dates sont fournies sous forme d'année, mois et jour.  \nPrend en compte les années bissextiles dans le calcul.  \n\nExemple :  \n>>> daysBetweenDates(2008, 1, 1, 2009, 1, 1)  \n366  \n>>> daysBetweenDates(2010, 1, 1, 2010, 1, 3)  \n2",
      "de": "Berechnet die Anzahl der Tage zwischen zwei angegebenen Daten.\nDie Daten werden als Jahr, Monat und Tag angegeben.\nBerücksichtigt Schaltjahre bei der Berechnung.\n\nBeispiel:\n>>> daysBetweenDates(2008, 1, 1, 2009, 1, 1)\n366\n>>> daysBetweenDates(2010, 1, 1, 2010, 1, 3)\n2",
      "ha": "Yana ƙididdige yawan kwanaki tsakanin kwanan wata biyu da aka bayar.\nAna bayar da kwanakin a matsayin shekara, wata, da rana.\nYana la'akari da shekarun tsalle a cikin ƙididdigar.\n\nMisali:\n>>> daysBetweenDates(2008, 1, 1, 2009, 1, 1)\n366\n>>> daysBetweenDates(2010, 1, 1, 2010, 1, 3)\n2",
      "hi": "दो दिए गए तारीखों के बीच दिनों की संख्या की गणना करता है।  \nतारीखें वर्ष, माह, और दिन के रूप में दी जाती हैं।  \nलीप वर्षों को गणना में शामिल करता है।\n\nउदाहरण:\n>>> daysBetweenDates(2008, 1, 1, 2009, 1, 1)\n366\n>>> daysBetweenDates(2010, 1, 1, 2010, 1, 3)\n2",
      "hu": "Számítja a napok számát két megadott dátum között.  \nA dátumok év, hónap és nap formátumban vannak megadva.  \nFigyelembe veszi a szökőéveket a számítás során.\n\nPélda:\n>>> daysBetweenDates(2008, 1, 1, 2009, 1, 1)\n366\n>>> daysBetweenDates(2010, 1, 1, 2010, 1, 3)\n2"
    },
    "docstring_bertscore": {
      "sq": "0.9791972415638351",
      "hy": "0.9823894304174469",
      "bn": "0.9943056642364918",
      "bg": "0.9840158159773604",
      "zh": "0.9745882222023016",
      "fr": "0.9594086898532344",
      "de": "0.9809960382944871",
      "ha": "0.9754234629545533",
      "hi": "0.982549725134942",
      "hu": "0.9722282946452261"
    }
  },
  {
    "task_id": "Kotlin/36",
    "prompt": {
      "en": "/**\n * Finds the most frequent n-grams (substrings of length n) in the given text and their frequency.\n * An n-gram is a contiguous sequence of n characters from the text.\n * \n * Args:\n * n (Int): The length of each n-gram.\n * text (String): The text to analyze for n-grams.\n * \n * Returns:\n * Pair<Int, List<String>>: A pair where the first element is the highest frequency of any n-gram,\n * and the second element is a list of n-grams with that frequency, in the order they first appear in the text.\n * If the highest frequency is not greater than 1, returns \"NO\" as the only element in the list.\n * \n * Examples:\n * >>> findMostFrequentNGrams(3, \"abcdefabcd\")\n * Pair(2, listOf(\"abc\", \"bcd\"))\n * \n * >>> findMostFrequentNGrams(2, \"abcabc\")\n * Pair(2, listOf(\"ab\", \"bc\"))\n * \n * >>> findMostFrequentNGrams(4, \"abcdefg\")\n * Pair(1, listOf(\"NO\"))\n */\n\nfun findMostFrequentNGrams(n: Int, text: String): Pair<Int, List<String>> ",
      "sq": "/**\n * Gjen n-gramet (nënvargjet me gjatësi n) më të shpeshta në tekstin e dhënë dhe frekuencën e tyre.\n * Një n-gram është një sekuencë e pandërprerë e n karaktereve nga teksti.\n * \n * Argumentet:\n * n (Int): Gjatësia e secilit n-gram.\n * text (String): Teksti për të analizuar për n-grame.\n * \n * Kthen:\n * Pair<Int, List<String>>: Një çift ku elementi i parë është frekuenca më e lartë e çdo n-grame,\n * dhe elementi i dytë është një listë e n-grameve me atë frekuencë, në rendin që ato shfaqen së pari në tekst.\n * Nëse frekuenca më e lartë nuk është më e madhe se 1, kthen \"NO\" si elementi i vetëm në listë.\n * \n * Shembuj:\n * >>> findMostFrequentNGrams(3, \"abcdefabcd\")\n * Pair(2, listOf(\"abc\", \"bcd\"))\n * \n * >>> findMostFrequentNGrams(2, \"abcabc\")\n * Pair(2, listOf(\"ab\", \"bc\"))\n * \n * >>> findMostFrequentNGrams(4, \"abcdefg\")\n * Pair(1, listOf(\"NO\"))\n */",
      "hy": "/**\n * Գտնում է տրված տեքստում ամենահաճախ հանդիպող n-գրամները (n երկարությամբ ենթատողեր) և դրանց հաճախականությունը։\n * N-գրամը տեքստից n սիմվոլների անընդմեջ հաջորդականություն է։\n * \n * Արգումենտներ:\n * n (Int): Յուրաքանչյուր n-գրամի երկարությունը։\n * text (String): Տեքստը, որը պետք է վերլուծել n-գրամների համար։\n * \n * Վերադարձնում է:\n * Pair<Int, List<String>>: Զույգ, որտեղ առաջին տարրը ցանկացած n-գրամի ամենաբարձր հաճախականությունն է,\n * իսկ երկրորդ տարրը n-գրամների ցուցակ է այդ հաճախականությամբ, ըստ տեքստում առաջին անգամ հայտնվելու կարգի։\n * Եթե ամենաբարձր հաճախականությունը մեծ չէ 1-ից, վերադարձնում է \"NO\" որպես ցուցակի միակ տարր։\n * \n * Օրինակներ:\n * >>> findMostFrequentNGrams(3, \"abcdefabcd\")\n * Pair(2, listOf(\"abc\", \"bcd\"))\n * \n * >>> findMostFrequentNGrams(2, \"abcabc\")\n * Pair(2, listOf(\"ab\", \"bc\"))\n * \n * >>> findMostFrequentNGrams(4, \"abcdefg\")\n * Pair(1, listOf(\"NO\"))\n */",
      "bn": "/**\n * প্রদত্ত টেক্সটে সবচেয়ে ঘন ঘন n-grams (n দৈর্ঘ্যের সাবস্ট্রিং) এবং তাদের ফ্রিকোয়েন্সি খুঁজে বের করে।\n * একটি n-gram হল টেক্সট থেকে n অক্ষরের একটি ধারাবাহিক ক্রম।\n * \n * আর্গুমেন্টসমূহ:\n * n (Int): প্রতিটি n-gram এর দৈর্ঘ্য।\n * text (String): n-grams বিশ্লেষণের জন্য টেক্সট।\n * \n * রিটার্নস:\n * Pair<Int, List<String>>: একটি জোড়া যেখানে প্রথম উপাদানটি যেকোনো n-gram এর সর্বোচ্চ ফ্রিকোয়েন্সি,\n * এবং দ্বিতীয় উপাদানটি সেই ফ্রিকোয়েন্সির সাথে n-grams এর একটি তালিকা, টেক্সটে তারা প্রথম যে ক্রমে উপস্থিত হয় সেই ক্রমে।\n * যদি সর্বোচ্চ ফ্রিকোয়েন্সি 1 এর চেয়ে বেশি না হয়, তাহলে \"NO\" কে তালিকার একমাত্র উপাদান হিসেবে ফেরত দেয়।\n * \n * উদাহরণসমূহ:\n * >>> findMostFrequentNGrams(3, \"abcdefabcd\")\n * Pair(2, listOf(\"abc\", \"bcd\"))\n * \n * >>> findMostFrequentNGrams(2, \"abcabc\")\n * Pair(2, listOf(\"ab\", \"bc\"))\n * \n * >>> findMostFrequentNGrams(4, \"abcdefg\")\n * Pair(1, listOf(\"NO\"))\n */",
      "bg": "/**\n * Намира най-често срещаните n-грамове (поднизове с дължина n) в дадения текст и тяхната честота.\n * N-грам е последователност от n символа от текста.\n * \n * Аргументи:\n * n (Int): Дължината на всеки n-грам.\n * text (String): Текстът, който да се анализира за n-грамове.\n * \n * Връща:\n * Pair<Int, List<String>>: Двойка, където първият елемент е най-високата честота на който и да е n-грам,\n * а вторият елемент е списък от n-грамове с тази честота, в реда, в който се появяват за първи път в текста.\n * Ако най-високата честота не е по-голяма от 1, връща \"NO\" като единствения елемент в списъка.\n * \n * Примери:\n * >>> findMostFrequentNGrams(3, \"abcdefabcd\")\n * Pair(2, listOf(\"abc\", \"bcd\"))\n * \n * >>> findMostFrequentNGrams(2, \"abcabc\")\n * Pair(2, listOf(\"ab\", \"bc\"))\n * \n * >>> findMostFrequentNGrams(4, \"abcdefg\")\n * Pair(1, listOf(\"NO\"))\n */",
      "zh": "/**\n * 查找给定文本中最频繁的n-gram（长度为n的子字符串）及其频率。\n * n-gram是文本中连续的n个字符序列。\n * \n * 参数:\n * n (Int): 每个n-gram的长度。\n * text (String): 要分析n-gram的文本。\n * \n * 返回:\n * Pair<Int, List<String>>: 一个对，其中第一个元素是任何n-gram的最高频率，\n * 第二个元素是具有该频率的n-gram列表，按它们在文本中首次出现的顺序。\n * 如果最高频率不大于1，则返回\"NO\"作为列表中的唯一元素。\n * \n * 示例:\n * >>> findMostFrequentNGrams(3, \"abcdefabcd\")\n * Pair(2, listOf(\"abc\", \"bcd\"))\n * \n * >>> findMostFrequentNGrams(2, \"abcabc\")\n * Pair(2, listOf(\"ab\", \"bc\"))\n * \n * >>> findMostFrequentNGrams(4, \"abcdefg\")\n * Pair(1, listOf(\"NO\"))\n */\n\nfun findMostFrequentNGrams(n: Int, text: String): Pair<Int, List<String>> ",
      "fr": "/**\n * Trouve les n-grammes les plus fréquents (sous-chaînes de longueur n) dans le texte donné et leur fréquence.\n * Un n-gramme est une séquence contiguë de n caractères du texte.\n * \n * Args:\n * n (Int): La longueur de chaque n-gramme.\n * text (String): Le texte à analyser pour les n-grammes.\n * \n * Returns:\n * Pair<Int, List<String>>: Une paire où le premier élément est la fréquence la plus élevée de n'importe quel n-gramme,\n * et le second élément est une liste de n-grammes avec cette fréquence, dans l'ordre où ils apparaissent pour la première fois dans le texte.\n * Si la fréquence la plus élevée n'est pas supérieure à 1, retourne \"NO\" comme seul élément de la liste.\n * \n * Examples:\n * >>> findMostFrequentNGrams(3, \"abcdefabcd\")\n * Pair(2, listOf(\"abc\", \"bcd\"))\n * \n * >>> findMostFrequentNGrams(2, \"abcabc\")\n * Pair(2, listOf(\"ab\", \"bc\"))\n * \n * >>> findMostFrequentNGrams(4, \"abcdefg\")\n * Pair(1, listOf(\"NO\"))\n */",
      "de": "/**\n * Findet die häufigsten n-Gramme (Teilstrings der Länge n) im gegebenen Text und deren Häufigkeit.\n * Ein n-Gramm ist eine zusammenhängende Folge von n Zeichen aus dem Text.\n * \n * Argumente:\n * n (Int): Die Länge jedes n-Gramms.\n * text (String): Der Text, der auf n-Gramme analysiert werden soll.\n * \n * Rückgabewerte:\n * Pair<Int, List<String>>: Ein Paar, bei dem das erste Element die höchste Häufigkeit eines n-Gramms ist,\n * und das zweite Element eine Liste von n-Grammen mit dieser Häufigkeit, in der Reihenfolge, in der sie zuerst im Text erscheinen.\n * Wenn die höchste Häufigkeit nicht größer als 1 ist, wird \"NO\" als einziges Element in der Liste zurückgegeben.\n * \n * Beispiele:\n * >>> findMostFrequentNGrams(3, \"abcdefabcd\")\n * Pair(2, listOf(\"abc\", \"bcd\"))\n * \n * >>> findMostFrequentNGrams(2, \"abcabc\")\n * Pair(2, listOf(\"ab\", \"bc\"))\n * \n * >>> findMostFrequentNGrams(4, \"abcdefg\")\n * Pair(1, listOf(\"NO\"))\n */",
      "ha": "/**\n * Yana nemo n-grams (ƙananan rubutu masu tsawon n) da suka fi yawan maimaituwa a cikin rubutun da aka bayar da kuma yawan maimaituwarsu.\n * N-gram jerin haruffa ne masu jere na n daga cikin rubutun.\n * \n * Args:\n * n (Int): Tsawon kowane n-gram.\n * text (String): Rubutun da za a yi nazari don n-grams.\n * \n * Returns:\n * Pair<Int, List<String>>: Wani nau'i biyu inda na farko shine mafi girman yawan maimaituwar kowane n-gram,\n * kuma na biyu jerin n-grams ne tare da wannan yawan maimaituwar, a cikin tsarin da suka fara bayyana a cikin rubutun.\n * Idan mafi girman yawan maimaituwa bai fi 1 ba, yana mayar da \"NO\" a matsayin abu ɗaya a cikin jerin.\n * \n * Misalai:\n * >>> findMostFrequentNGrams(3, \"abcdefabcd\")\n * Pair(2, listOf(\"abc\", \"bcd\"))\n * \n * >>> findMostFrequentNGrams(2, \"abcabc\")\n * Pair(2, listOf(\"ab\", \"bc\"))\n * \n * >>> findMostFrequentNGrams(4, \"abcdefg\")\n * Pair(1, listOf(\"NO\"))\n */",
      "hi": "/**\n * दिए गए पाठ में सबसे अधिक बार आने वाले n-ग्राम (लंबाई n के उपस्ट्रिंग्स) और उनकी आवृत्ति खोजता है।\n * एक n-ग्राम पाठ से n वर्णों का एक सतत अनुक्रम होता है।\n * \n * आर्ग्स:\n * n (Int): प्रत्येक n-ग्राम की लंबाई।\n * text (String): n-ग्राम के लिए विश्लेषण करने के लिए पाठ।\n * \n * रिटर्न्स:\n * Pair<Int, List<String>>: एक जोड़ी जहां पहला तत्व किसी भी n-ग्राम की उच्चतम आवृत्ति है,\n * और दूसरा तत्व n-ग्राम की एक सूची है जो उस आवृत्ति के साथ है, जिस क्रम में वे पाठ में पहले दिखाई देते हैं।\n * यदि उच्चतम आवृत्ति 1 से अधिक नहीं है, तो सूची में \"NO\" को एकमात्र तत्व के रूप में लौटाता है।\n * \n * उदाहरण:\n * >>> findMostFrequentNGrams(3, \"abcdefabcd\")\n * Pair(2, listOf(\"abc\", \"bcd\"))\n * \n * >>> findMostFrequentNGrams(2, \"abcabc\")\n * Pair(2, listOf(\"ab\", \"bc\"))\n * \n * >>> findMostFrequentNGrams(4, \"abcdefg\")\n * Pair(1, listOf(\"NO\"))\n */",
      "hu": "/**\n * Megkeresi a leggyakoribb n-grammákat (n hosszúságú részsztringeket) a megadott szövegben és azok gyakoriságát.\n * Egy n-gramma a szöveg n egymást követő karakterének sorozata.\n * \n * Args:\n * n (Int): Az egyes n-grammák hossza.\n * text (String): A szöveg, amelyben az n-grammákat elemezzük.\n * \n * Returns:\n * Pair<Int, List<String>>: Egy pár, ahol az első elem bármely n-gramma legmagasabb gyakorisága,\n * a második elem pedig az ilyen gyakoriságú n-grammák listája, a szövegben való első megjelenésük sorrendjében.\n * Ha a legmagasabb gyakoriság nem nagyobb, mint 1, akkor \"NO\"-t ad vissza az egyetlen elemként a listában.\n * \n * Példák:\n * >>> findMostFrequentNGrams(3, \"abcdefabcd\")\n * Pair(2, listOf(\"abc\", \"bcd\"))\n * \n * >>> findMostFrequentNGrams(2, \"abcabc\")\n * Pair(2, listOf(\"ab\", \"bc\"))\n * \n * >>> findMostFrequentNGrams(4, \"abcdefg\")\n * Pair(1, listOf(\"NO\"))\n */"
    },
    "prompt_bertscore": {
      "sq": "0.972962631163912",
      "hy": "0.9648958541293232",
      "bn": "0.9656572043798299",
      "bg": "0.9694903734730411",
      "zh": "0.9561471789966415",
      "fr": "0.9774763079425488",
      "de": "0.9614659047096127",
      "ha": "0.9540454709349113",
      "hi": "0.9670428499179293",
      "hu": "0.9538007583054764"
    },
    "canonical_solution": "{\n    val nGrams = mutableMapOf<String, Int>()\n\n    for (i in 0..text.length - n) {\n        val nGram = text.substring(i, i + n)\n        nGrams[nGram] = nGrams.getOrDefault(nGram, 0) + 1\n    }\n\n    val maxFreq = nGrams.values.maxOrNull() ?: 0\n    if (maxFreq <= 1) return Pair(1, listOf(\"NO\"))\n\n    val frequentNGrams = nGrams.filter { it.value == maxFreq }.keys.toList()\n    val orderedFrequentNGrams = text.windowed(n).filter { it in frequentNGrams }.distinct()\n\n    return Pair(maxFreq, orderedFrequentNGrams)\n}",
    "instruction": {
      "en": "Write a Kotlin function `fun findMostFrequentNGrams(n: Int, text: String): Pair<Int, List<String>>` to solve the following problem:\nFinds the most frequent n-grams (substrings of length n) in the given text and their frequency.\nAn n-gram is a contiguous sequence of n characters from the text.\n\nArgs:\nn (Int): The length of each n-gram.\ntext (String): The text to analyze for n-grams.\n\nReturns:\nPair<Int, List<String>>: A pair where the first element is the highest frequency of any n-gram,\nand the second element is a list of n-grams with that frequency, in the order they first appear in the text.\nIf the highest frequency is not greater than 1, returns \"NO\" as the only element in the list.\n\nExamples:\n>>> findMostFrequentNGrams(3, \"abcdefabcd\")\nPair(2, listOf(\"abc\", \"bcd\"))\n\n>>> findMostFrequentNGrams(2, \"abcabc\")\nPair(2, listOf(\"ab\", \"bc\"))\n\n>>> findMostFrequentNGrams(4, \"abcdefg\")\nPair(1, listOf(\"NO\"))",
      "sq": "Shkruani një funksion Kotlin `fun findMostFrequentNGrams(n: Int, text: String): Pair<Int, List<String>>` për të zgjidhur problemin në vijim:\nGjen n-gramet (nënvargjet me gjatësi n) më të shpeshta në tekstin e dhënë dhe frekuencën e tyre.\nNjë n-gram është një sekuencë e pandërprerë prej n karakteresh nga teksti.\n\nArgumentet:\nn (Int): Gjatësia e secilit n-gram.\ntext (String): Teksti për t'u analizuar për n-gramet.\n\nKthen:\nPair<Int, List<String>>: Një çift ku elementi i parë është frekuenca më e lartë e ndonjë n-grame,\ndhe elementi i dytë është një listë e n-grameve me atë frekuencë, në rendin që shfaqen së pari në tekst.\nNëse frekuenca më e lartë nuk është më e madhe se 1, kthen \"NO\" si elementi i vetëm në listë.\n\nShembuj:\n>>> findMostFrequentNGrams(3, \"abcdefabcd\")\nPair(2, listOf(\"abc\", \"bcd\"))\n\n>>> findMostFrequentNGrams(2, \"abcabc\")\nPair(2, listOf(\"ab\", \"bc\"))\n\n>>> findMostFrequentNGrams(4, \"abcdefg\")\nPair(1, listOf(\"NO\"))",
      "hy": "Գրեք Kotlin ֆունկցիա `fun findMostFrequentNGrams(n: Int, text: String): Pair<Int, List<String>>` հետևյալ խնդիրը լուծելու համար:\nԳտնում է տրված տեքստում ամենահաճախ հանդիպող n-գրամները (n երկարությամբ ենթատողեր) և դրանց հաճախականությունը։\nN-գրամը տեքստից n սիմվոլների շարունակական հաջորդականություն է։\n\nԱրգումենտներ:\nn (Int): Յուրաքանչյուր n-գրամի երկարությունը։\ntext (String): Տեքստը, որը պետք է վերլուծել n-գրամների համար։\n\nՎերադարձնում է:\nPair<Int, List<String>>: Զույգ, որտեղ առաջին էլեմենտը ցանկացած n-գրամի ամենաբարձր հաճախականությունն է,\nիսկ երկրորդ էլեմենտը n-գրամների ցանկն է այդ հաճախականությամբ, այն հերթականությամբ, որով նրանք առաջին անգամ հայտնվում են տեքստում։\nԵթե ամենաբարձր հաճախականությունը 1-ից մեծ չէ, վերադարձնում է \"NO\" որպես ցանկի միակ էլեմենտ։\n\nՕրինակներ:\n>>> findMostFrequentNGrams(3, \"abcdefabcd\")\nPair(2, listOf(\"abc\", \"bcd\"))\n\n>>> findMostFrequentNGrams(2, \"abcabc\")\nPair(2, listOf(\"ab\", \"bc\"))\n\n>>> findMostFrequentNGrams(4, \"abcdefg\")\nPair(1, listOf(\"NO\"))",
      "bn": "Kotlin ফাংশন `fun findMostFrequentNGrams(n: Int, text: String): Pair<Int, List<String>>` লিখুন নিম্নলিখিত সমস্যার সমাধানের জন্য:\nপ্রদত্ত টেক্সটে সবচেয়ে ঘন ঘন n-গ্রাম (n দৈর্ঘ্যের সাবস্ট্রিং) এবং তাদের ফ্রিকোয়েন্সি খুঁজে বের করে।\nএকটি n-গ্রাম হল টেক্সট থেকে n অক্ষরের একটি ধারাবাহিক ক্রম।\n\nআর্গুমেন্টসমূহ:\nn (Int): প্রতিটি n-গ্রামের দৈর্ঘ্য।\ntext (String): n-গ্রামের জন্য বিশ্লেষণ করার টেক্সট।\n\nরিটার্নস:\nPair<Int, List<String>>: একটি পেয়ার যেখানে প্রথম উপাদানটি যেকোনো n-গ্রামের সর্বোচ্চ ফ্রিকোয়েন্সি,\nএবং দ্বিতীয় উপাদানটি সেই ফ্রিকোয়েন্সির সাথে n-গ্রামের একটি তালিকা, যেভাবে তারা প্রথমে টেক্সটে উপস্থিত হয় সেই ক্রমে।\nযদি সর্বোচ্চ ফ্রিকোয়েন্সি 1 এর চেয়ে বেশি না হয়, তাহলে \"NO\" কে তালিকার একমাত্র উপাদান হিসেবে রিটার্ন করে।\n\nউদাহরণসমূহ:\n>>> findMostFrequentNGrams(3, \"abcdefabcd\")\nPair(2, listOf(\"abc\", \"bcd\"))\n\n>>> findMostFrequentNGrams(2, \"abcabc\")\nPair(2, listOf(\"ab\", \"bc\"))\n\n>>> findMostFrequentNGrams(4, \"abcdefg\")\nPair(1, listOf(\"NO\"))",
      "bg": "Напишете функция на Kotlin `fun findMostFrequentNGrams(n: Int, text: String): Pair<Int, List<String>>`, за да решите следния проблем:\nНамира най-често срещаните n-грамове (поднизове с дължина n) в дадения текст и тяхната честота.\nN-грам е последователност от n съседни символа от текста.\n\nАргументи:\nn (Int): Дължината на всеки n-грам.\ntext (String): Текстът, който да се анализира за n-грамове.\n\nВръща:\nPair<Int, List<String>>: Двойка, където първият елемент е най-високата честота на който и да е n-грам,\nа вторият елемент е списък от n-грамове с тази честота, в реда, в който се появяват за първи път в текста.\nАко най-високата честота не е по-голяма от 1, връща \"NO\" като единствен елемент в списъка.\n\nПримери:\n>>> findMostFrequentNGrams(3, \"abcdefabcd\")\nPair(2, listOf(\"abc\", \"bcd\"))\n\n>>> findMostFrequentNGrams(2, \"abcabc\")\nPair(2, listOf(\"ab\", \"bc\"))\n\n>>> findMostFrequentNGrams(4, \"abcdefg\")\nPair(1, listOf(\"NO\"))",
      "zh": "编写一个 Kotlin 函数 `fun findMostFrequentNGrams(n: Int, text: String): Pair<Int, List<String>>` 来解决以下问题：\n找到给定文本中最频繁的 n-gram（长度为 n 的子字符串）及其频率。\nn-gram 是文本中 n 个字符的连续序列。\n\n参数：\nn (Int): 每个 n-gram 的长度。\ntext (String): 要分析 n-gram 的文本。\n\n返回：\nPair<Int, List<String>>: 一个对，其中第一个元素是任何 n-gram 的最高频率，\n第二个元素是具有该频率的 n-gram 列表，按它们在文本中首次出现的顺序排列。\n如果最高频率不大于 1，则返回列表中唯一的元素 \"NO\"。\n\n示例：\n>>> findMostFrequentNGrams(3, \"abcdefabcd\")\nPair(2, listOf(\"abc\", \"bcd\"))\n\n>>> findMostFrequentNGrams(2, \"abcabc\")\nPair(2, listOf(\"ab\", \"bc\"))\n\n>>> findMostFrequentNGrams(4, \"abcdefg\")\nPair(1, listOf(\"NO\"))",
      "fr": "Écrire une fonction Kotlin `fun findMostFrequentNGrams(n: Int, text: String): Pair<Int, List<String>>` pour résoudre le problème suivant :\nTrouve les n-grams (sous-chaînes de longueur n) les plus fréquents dans le texte donné et leur fréquence.\nUn n-gram est une séquence contiguë de n caractères du texte.\n\nArgs:\nn (Int): La longueur de chaque n-gram.\ntext (String): Le texte à analyser pour les n-grams.\n\nRenvoie:\nPair<Int, List<String>>: Une paire où le premier élément est la fréquence la plus élevée de n'importe quel n-gram,\net le second élément est une liste de n-grams avec cette fréquence, dans l'ordre où ils apparaissent d'abord dans le texte.\nSi la fréquence la plus élevée n'est pas supérieure à 1, renvoie \"NO\" comme seul élément de la liste.\n\nExemples:\n>>> findMostFrequentNGrams(3, \"abcdefabcd\")\nPair(2, listOf(\"abc\", \"bcd\"))\n\n>>> findMostFrequentNGrams(2, \"abcabc\")\nPair(2, listOf(\"ab\", \"bc\"))\n\n>>> findMostFrequentNGrams(4, \"abcdefg\")\nPair(1, listOf(\"NO\"))",
      "de": "Schreiben Sie eine Kotlin-Funktion `fun findMostFrequentNGrams(n: Int, text: String): Pair<Int, List<String>>`, um das folgende Problem zu lösen:\nFindet die häufigsten n-Gramme (Teilstrings der Länge n) im gegebenen Text und deren Häufigkeit.\nEin n-Gramm ist eine zusammenhängende Sequenz von n Zeichen aus dem Text.\n\nArgumente:\nn (Int): Die Länge jedes n-Gramms.\ntext (String): Der Text, der auf n-Gramme analysiert werden soll.\n\nRückgabewert:\nPair<Int, List<String>>: Ein Paar, bei dem das erste Element die höchste Häufigkeit eines n-Gramms ist,\nund das zweite Element ist eine Liste von n-Grammen mit dieser Häufigkeit, in der Reihenfolge, in der sie zuerst im Text erscheinen.\nWenn die höchste Häufigkeit nicht größer als 1 ist, wird \"NO\" als einziges Element in der Liste zurückgegeben.\n\nBeispiele:\n>>> findMostFrequentNGrams(3, \"abcdefabcd\")\nPair(2, listOf(\"abc\", \"bcd\"))\n\n>>> findMostFrequentNGrams(2, \"abcabc\")\nPair(2, listOf(\"ab\", \"bc\"))\n\n>>> findMostFrequentNGrams(4, \"abcdefg\")\nPair(1, listOf(\"NO\"))",
      "ha": "Rubuta aikin Kotlin `fun findMostFrequentNGrams(n: Int, text: String): Pair<Int, List<String>>` don warware matsalar mai zuwa:\nNemo mafi yawan n-grams (ƙananan rubutu masu tsawon n) a cikin rubutun da aka bayar da kuma yawan su.\nN-gram tsari ne na n haruffa masu jere daga rubutun.\n\nArgs:\nn (Int): Tsawon kowane n-gram.\ntext (String): Rubutun da za a bincika don n-grams.\n\nReturns:\nPair<Int, List<String>>: Wani nau'i biyu inda na farko shine mafi girman yawan kowane n-gram,\nkuma na biyu jerin n-grams tare da wannan yawan, a cikin tsari da suka fara bayyana a cikin rubutun.\nIdan mafi girman yawan bai fi 1 ba, yana mayar da \"NO\" a matsayin kadai abu a cikin jerin.\n\nMisalai:\n>>> findMostFrequentNGrams(3, \"abcdefabcd\")\nPair(2, listOf(\"abc\", \"bcd\"))\n\n>>> findMostFrequentNGrams(2, \"abcabc\")\nPair(2, listOf(\"ab\", \"bc\"))\n\n>>> findMostFrequentNGrams(4, \"abcdefg\")\nPair(1, listOf(\"NO\"))",
      "hi": "Kotlin फ़ंक्शन `fun findMostFrequentNGrams(n: Int, text: String): Pair<Int, List<String>>` लिखें ताकि निम्नलिखित समस्या का समाधान हो सके:\nदिए गए टेक्स्ट में सबसे अधिक बार आने वाले n-ग्राम (लंबाई n के उपस्ट्रिंग्स) और उनकी आवृत्ति को खोजें।\nएक n-ग्राम टेक्स्ट से n वर्णों का एक निरंतर अनुक्रम होता है।\n\nआर्ग्स:\nn (Int): प्रत्येक n-ग्राम की लंबाई।\ntext (String): n-ग्राम के लिए विश्लेषण करने के लिए टेक्स्ट।\n\nरिटर्न्स:\nPair<Int, List<String>>: एक जोड़ी जहां पहला तत्व किसी भी n-ग्राम की उच्चतम आवृत्ति है,\nऔर दूसरा तत्व उन n-ग्राम की सूची है जिनकी वह आवृत्ति है, जिस क्रम में वे टेक्स्ट में पहले दिखाई देते हैं।\nयदि उच्चतम आवृत्ति 1 से अधिक नहीं है, तो सूची में \"NO\" को एकमात्र तत्व के रूप में लौटाता है।\n\nउदाहरण:\n>>> findMostFrequentNGrams(3, \"abcdefabcd\")\nPair(2, listOf(\"abc\", \"bcd\"))\n\n>>> findMostFrequentNGrams(2, \"abcabc\")\nPair(2, listOf(\"ab\", \"bc\"))\n\n>>> findMostFrequentNGrams(4, \"abcdefg\")\nPair(1, listOf(\"NO\"))",
      "hu": "Írj egy Kotlin függvényt `fun findMostFrequentNGrams(n: Int, text: String): Pair<Int, List<String>>` a következő probléma megoldására:\nMegtalálja a leggyakoribb n-gramokat (n hosszúságú részsztringeket) a megadott szövegben és azok gyakoriságát.\nEgy n-gram egy n hosszúságú összefüggő karaktersorozat a szövegből.\n\nArgs:\nn (Int): Az egyes n-gramok hossza.\ntext (String): A szöveg, amelyet n-gramokra kell elemezni.\n\nVisszatér:\nPair<Int, List<String>>: Egy pár, ahol az első elem bármely n-gram legnagyobb gyakorisága,\na második elem pedig az ilyen gyakoriságú n-gramok listája, abban a sorrendben, ahogy először megjelennek a szövegben.\nHa a legnagyobb gyakoriság nem nagyobb, mint 1, akkor \"NO\"-t ad vissza az egyetlen elemként a listában.\n\nPéldák:\n>>> findMostFrequentNGrams(3, \"abcdefabcd\")\nPair(2, listOf(\"abc\", \"bcd\"))\n\n>>> findMostFrequentNGrams(2, \"abcabc\")\nPair(2, listOf(\"ab\", \"bc\"))\n\n>>> findMostFrequentNGrams(4, \"abcdefg\")\nPair(1, listOf(\"NO\"))"
    },
    "instruction_bertscore": {
      "sq": "0.9921876684835168",
      "hy": "0.9886891915823494",
      "bn": "0.9786639189907564",
      "bg": "0.9831346916070897",
      "zh": "0.9759677101985889",
      "fr": "0.9942750751578124",
      "de": "0.9852234886940526",
      "ha": "0.9662042324492",
      "hi": "0.9749660171870299",
      "hu": "0.9893260005839472"
    },
    "level": "middle",
    "test": "fun main() {\n    check(findMostFrequentNGrams(3, \"abcdefabcd\") == Pair(2, listOf(\"abc\", \"bcd\")))\n    check(findMostFrequentNGrams(2, \"abcabc\") == Pair(2, listOf(\"ab\", \"bc\")))\n    check(findMostFrequentNGrams(4, \"abcdefg\") == Pair(1, listOf(\"NO\")))\n    check(findMostFrequentNGrams(2, \"abcdabcd\") == Pair(2, listOf(\"ab\", \"bc\", \"cd\")))\n}\n\n\nmain()",
    "entry_point": "findMostFrequentNGrams",
    "signature": "fun findMostFrequentNGrams(n: Int, text: String): Pair<Int, List<String>>",
    "docstring": {
      "en": "Finds the most frequent n-grams (substrings of length n) in the given text and their frequency.\nAn n-gram is a contiguous sequence of n characters from the text.\n\nArgs:\nn (Int): The length of each n-gram.\ntext (String): The text to analyze for n-grams.\n\nReturns:\nPair<Int, List<String>>: A pair where the first element is the highest frequency of any n-gram,\nand the second element is a list of n-grams with that frequency, in the order they first appear in the text.\nIf the highest frequency is not greater than 1, returns \"NO\" as the only element in the list.\n\nExamples:\n>>> findMostFrequentNGrams(3, \"abcdefabcd\")\nPair(2, listOf(\"abc\", \"bcd\"))\n\n>>> findMostFrequentNGrams(2, \"abcabc\")\nPair(2, listOf(\"ab\", \"bc\"))\n\n>>> findMostFrequentNGrams(4, \"abcdefg\")\nPair(1, listOf(\"NO\"))",
      "sq": "Gjen n-gramet më të shpeshta (nënvargje me gjatësi n) në tekstin e dhënë dhe frekuencën e tyre. Një n-gram është një sekuencë e pandërprerë e n karaktereve nga teksti.\n\nArgs:\nn (Int): Gjatësia e secilit n-gram.\ntext (String): Teksti për t'u analizuar për n-gramet.\n\nReturns:\nPair<Int, List<String>>: Një çift ku elementi i parë është frekuenca më e lartë e çdo n-grame,\ndhe elementi i dytë është një listë e n-grameve me atë frekuencë, në rendin që shfaqen së pari në tekst.\nNëse frekuenca më e lartë nuk është më e madhe se 1, kthen \"NO\" si elementi i vetëm në listë.\n\nExamples:\n>>> findMostFrequentNGrams(3, \"abcdefabcd\")\nPair(2, listOf(\"abc\", \"bcd\"))\n\n>>> findMostFrequentNGrams(2, \"abcabc\")\nPair(2, listOf(\"ab\", \"bc\"))\n\n>>> findMostFrequentNGrams(4, \"abcdefg\")\nPair(1, listOf(\"NO\"))",
      "hy": "Գտնում է տրված տեքստում ամենահաճախ հանդիպող n-գրամները (n երկարության ենթատողերը) և դրանց հաճախականությունը։  \nN-գրամը տեքստից n սիմվոլների հարակից հաջորդականություն է։\n\nԱրգումենտներ:\nn (Int): Յուրաքանչյուր n-գրամի երկարությունը։\ntext (String): Տեքստը, որը պետք է վերլուծել n-գրամների համար։\n\nՎերադարձնում է:\nPair<Int, List<String>>: Զույգ, որտեղ առաջին էլեմենտը ցանկացած n-գրամի ամենաբարձր հաճախականությունն է,  \nիսկ երկրորդ էլեմենտը n-գրամների ցուցակն է այդ հաճախականությամբ, այն հերթականությամբ, որով դրանք առաջին անգամ հայտնվում են տեքստում։  \nԵթե ամենաբարձր հաճախականությունը 1-ից մեծ չէ, վերադարձնում է \"NO\" որպես ցուցակի միակ էլեմենտ։\n\nՕրինակներ:\n>>> findMostFrequentNGrams(3, \"abcdefabcd\")\nPair(2, listOf(\"abc\", \"bcd\"))\n\n>>> findMostFrequentNGrams(2, \"abcabc\")\nPair(2, listOf(\"ab\", \"bc\"))\n\n>>> findMostFrequentNGrams(4, \"abcdefg\")\nPair(1, listOf(\"NO\"))",
      "bn": "প্রদত্ত টেক্সটে সবচেয়ে ঘন ঘন n-grams (n দৈর্ঘ্যের সাবস্ট্রিং) এবং তাদের ফ্রিকোয়েন্সি খুঁজে বের করে।\nএকটি n-gram হল টেক্সট থেকে n অক্ষরের একটি ধারাবাহিক ক্রম।\n\nArgs:\nn (Int): প্রতিটি n-gram এর দৈর্ঘ্য।\ntext (String): n-grams বিশ্লেষণের জন্য টেক্সট।\n\nReturns:\nPair<Int, List<String>>: একটি জোড়া যেখানে প্রথম উপাদানটি যে কোনো n-gram এর সর্বোচ্চ ফ্রিকোয়েন্সি,\nএবং দ্বিতীয় উপাদানটি সেই ফ্রিকোয়েন্সির সাথে n-grams এর একটি তালিকা, টেক্সটে তারা প্রথম যে ক্রমে উপস্থিত হয় সেই ক্রমে।\nযদি সর্বোচ্চ ফ্রিকোয়েন্সি 1 এর বেশি না হয়, তাহলে \"NO\" কে তালিকার একমাত্র উপাদান হিসেবে ফেরত দেয়।\n\nExamples:\n>>> findMostFrequentNGrams(3, \"abcdefabcd\")\nPair(2, listOf(\"abc\", \"bcd\"))\n\n>>> findMostFrequentNGrams(2, \"abcabc\")\nPair(2, listOf(\"ab\", \"bc\"))\n\n>>> findMostFrequentNGrams(4, \"abcdefg\")\nPair(1, listOf(\"NO\"))",
      "bg": "Намира най-честите n-грамове (поднизове с дължина n) в дадения текст и тяхната честота. Един n-грам е непрекъсната последователност от n символа от текста.\n\nАргументи:\nn (Int): Дължината на всеки n-грам.\ntext (String): Текстът, който да се анализира за n-грамове.\n\nВръща:\nPair<Int, List<String>>: Двойка, където първият елемент е най-високата честота на който и да е n-грам,\nа вторият елемент е списък от n-грамове с тази честота, в реда, в който се появяват за първи път в текста.\nАко най-високата честота не е по-голяма от 1, връща \"NO\" като единствен елемент в списъка.\n\nПримери:\n>>> findMostFrequentNGrams(3, \"abcdefabcd\")\nPair(2, listOf(\"abc\", \"bcd\"))\n\n>>> findMostFrequentNGrams(2, \"abcabc\")\nPair(2, listOf(\"ab\", \"bc\"))\n\n>>> findMostFrequentNGrams(4, \"abcdefg\")\nPair(1, listOf(\"NO\"))",
      "zh": "找到给定文本中最频繁的n-gram（长度为n的子串）及其频率。\nn-gram是文本中连续的n个字符序列。\n\n参数:\nn (Int): 每个n-gram的长度。\ntext (String): 要分析n-gram的文本。\n\n返回:\nPair<Int, List<String>>: 一个对，其中第一个元素是任何n-gram的最高频率，\n第二个元素是具有该频率的n-gram列表，按它们在文本中首次出现的顺序排列。\n如果最高频率不大于1，则返回列表中唯一的元素为\"NO\"。\n\n示例:\n>>> findMostFrequentNGrams(3, \"abcdefabcd\")\nPair(2, listOf(\"abc\", \"bcd\"))\n\n>>> findMostFrequentNGrams(2, \"abcabc\")\nPair(2, listOf(\"ab\", \"bc\"))\n\n>>> findMostFrequentNGrams(4, \"abcdefg\")\nPair(1, listOf(\"NO\"))",
      "fr": "Trouve les n-grammes les plus fréquents (sous-chaînes de longueur n) dans le texte donné et leur fréquence. Un n-gramme est une séquence contiguë de n caractères du texte.\n\nArgs:\nn (Int): La longueur de chaque n-gramme.\ntext (String): Le texte à analyser pour les n-grammes.\n\nReturns:\nPair<Int, List<String>>: Une paire où le premier élément est la fréquence la plus élevée de n'importe quel n-gramme, et le second élément est une liste de n-grammes avec cette fréquence, dans l'ordre où ils apparaissent pour la première fois dans le texte. Si la fréquence la plus élevée n'est pas supérieure à 1, retourne \"NO\" comme seul élément de la liste.\n\nExamples:\n>>> findMostFrequentNGrams(3, \"abcdefabcd\")\nPair(2, listOf(\"abc\", \"bcd\"))\n\n>>> findMostFrequentNGrams(2, \"abcabc\")\nPair(2, listOf(\"ab\", \"bc\"))\n\n>>> findMostFrequentNGrams(4, \"abcdefg\")\nPair(1, listOf(\"NO\"))",
      "de": "Findet die häufigsten n-Gramme (Teilstrings der Länge n) im gegebenen Text und deren Häufigkeit.\nEin n-Gramm ist eine zusammenhängende Sequenz von n Zeichen aus dem Text.\n\nArgs:\nn (Int): Die Länge jedes n-Gramms.\ntext (String): Der Text, der auf n-Gramme analysiert werden soll.\n\nReturns:\nPair<Int, List<String>>: Ein Paar, bei dem das erste Element die höchste Häufigkeit eines n-Gramms ist,\nund das zweite Element eine Liste von n-Grammen mit dieser Häufigkeit ist, in der Reihenfolge, in der sie zuerst im Text erscheinen.\nWenn die höchste Häufigkeit nicht größer als 1 ist, wird \"NO\" als einziges Element in der Liste zurückgegeben.\n\nExamples:\n>>> findMostFrequentNGrams(3, \"abcdefabcd\")\nPair(2, listOf(\"abc\", \"bcd\"))\n\n>>> findMostFrequentNGrams(2, \"abcabc\")\nPair(2, listOf(\"ab\", \"bc\"))\n\n>>> findMostFrequentNGrams(4, \"abcdefg\")\nPair(1, listOf(\"NO\"))",
      "ha": "Nemo mafi yawan n-grams (ƙananan rubutu masu tsawon n) a cikin rubutun da aka bayar da kuma yawan su.\nn-gram yana nufin jere na haruffa n daga cikin rubutun.\n\nArgs:  \nn (Int): Tsawon kowanne n-gram.  \ntext (String): Rubutun da za a bincika don n-grams.\n\nReturns:  \nPair<Int, List<String>>: Wani nau'i inda abu na farko shine mafi girman yawan wani n-gram,  \nkuma abu na biyu shine jerin n-grams da wannan yawan, a cikin tsarin da suka fara bayyana a cikin rubutun.  \nIdan mafi girman yawan bai fi 1 ba, yana dawowa da \"NO\" a matsayin abu daya tilo a cikin jerin.\n\nExamples:  \n>>> findMostFrequentNGrams(3, \"abcdefabcd\")  \nPair(2, listOf(\"abc\", \"bcd\"))\n\n>>> findMostFrequentNGrams(2, \"abcabc\")  \nPair(2, listOf(\"ab\", \"bc\"))\n\n>>> findMostFrequentNGrams(4, \"abcdefg\")  \nPair(1, listOf(\"NO\"))",
      "hi": "दिए गए पाठ में सबसे अधिक बार आने वाले n-ग्राम (लंबाई n के उपस्ट्रिंग्स) और उनकी आवृत्ति खोजता है। एक n-ग्राम पाठ से n वर्णों का एक सतत अनुक्रम होता है।\n\nआर्ग्स:\nn (Int): प्रत्येक n-ग्राम की लंबाई।\ntext (String): n-ग्राम के लिए विश्लेषण करने के लिए पाठ।\n\nरिटर्न्स:\nPair<Int, List<String>>: एक जोड़ी जहां पहला तत्व किसी भी n-ग्राम की उच्चतम आवृत्ति है,\nऔर दूसरा तत्व उस आवृत्ति के साथ n-ग्राम की सूची है, जिस क्रम में वे पाठ में पहली बार आते हैं।\nयदि उच्चतम आवृत्ति 1 से अधिक नहीं है, तो सूची में \"NO\" को एकमात्र तत्व के रूप में लौटाता है।\n\nउदाहरण:\n>>> findMostFrequentNGrams(3, \"abcdefabcd\")\nPair(2, listOf(\"abc\", \"bcd\"))\n\n>>> findMostFrequentNGrams(2, \"abcabc\")\nPair(2, listOf(\"ab\", \"bc\"))\n\n>>> findMostFrequentNGrams(4, \"abcdefg\")\nPair(1, listOf(\"NO\"))",
      "hu": "Megtalálja a leggyakoribb n-grammákat (n hosszúságú részsztringeket) a megadott szövegben és azok gyakoriságát. \nEgy n-gramma a szöveg n karakterből álló összefüggő sorozata.\n\nArgs:\nn (Int): Az egyes n-grammák hossza.\ntext (String): A szöveg, amelyet n-grammákra kell elemezni.\n\nReturns:\nPair<Int, List<String>>: Egy pár, ahol az első elem bármely n-gramma legmagasabb gyakorisága,\na második elem pedig az ilyen gyakoriságú n-grammák listája, a szövegben való első megjelenésük sorrendjében.\nHa a legmagasabb gyakoriság nem nagyobb, mint 1, akkor \"NO\"-t ad vissza az egyetlen elemként a listában.\n\nExamples:\n>>> findMostFrequentNGrams(3, \"abcdefabcd\")\nPair(2, listOf(\"abc\", \"bcd\"))\n\n>>> findMostFrequentNGrams(2, \"abcabc\")\nPair(2, listOf(\"ab\", \"bc\"))\n\n>>> findMostFrequentNGrams(4, \"abcdefg\")\nPair(1, listOf(\"NO\"))"
    },
    "docstring_bertscore": {
      "sq": "0.9944182876625386",
      "hy": "0.9860019211573283",
      "bn": "0.977545431315149",
      "bg": "0.9886292052072768",
      "zh": "0.9631920027208059",
      "fr": "0.9930604503777841",
      "de": "0.9899943918161296",
      "ha": "0.9732432958923144",
      "hi": "0.9835055345284819",
      "hu": "0.9768150674040837"
    }
  },
  {
    "task_id": "Kotlin/37",
    "prompt": {
      "en": "/**\n * Divide a large number (as a string) by 13 and return the quotient and remainder.\n * The input number can be up to 100 digits long.\n *\n * Example:\n * >>> divideByThirteen(\"2132104848488485\")\n *   (\"164008065268345\", \"0\")\n * >>> divideByThirteen(\"169\")\n *   (\"13\", \"0\")\n * >>> divideByThirteen(\"20\")\n *   (\"1\", \"7\")\n */\n\nfun divideByThirteen(number: String): Pair<String, String> ",
      "sq": "/**\n * Ndaj një numër të madh (si varg) me 13 dhe kthe koeficientin dhe mbetjen.\n * Numri i futur mund të jetë deri në 100 shifra i gjatë.\n *\n * Shembull:\n * >>> divideByThirteen(\"2132104848488485\")\n *   (\"164008065268345\", \"0\")\n * >>> divideByThirteen(\"169\")\n *   (\"13\", \"0\")\n * >>> divideByThirteen(\"20\")\n *   (\"1\", \"7\")\n */ \n\nfun divideByThirteen(number: String): Pair<String, String> ",
      "hy": "/**\n * Մեծ թիվը (որպես տող) բաժանել 13-ի և վերադարձնել քանորդը և մնացորդը:\n * Մուտքային թիվը կարող է լինել մինչև 100 նիշ երկարությամբ:\n *\n * Օրինակ:\n * >>> divideByThirteen(\"2132104848488485\")\n *   (\"164008065268345\", \"0\")\n * >>> divideByThirteen(\"169\")\n *   (\"13\", \"0\")\n * >>> divideByThirteen(\"20\")\n *   (\"1\", \"7\")\n */\n\nfun divideByThirteen(number: String): Pair<String, String> ",
      "bn": "/**\n * একটি বড় সংখ্যা (স্ট্রিং হিসেবে) 13 দ্বারা ভাগ করুন এবং ভাগফল ও অবশিষ্টাংশ ফেরত দিন।\n * ইনপুট সংখ্যা সর্বাধিক 100 অঙ্ক দীর্ঘ হতে পারে।\n *\n * উদাহরণ:\n * >>> divideByThirteen(\"2132104848488485\")\n *   (\"164008065268345\", \"0\")\n * >>> divideByThirteen(\"169\")\n *   (\"13\", \"0\")\n * >>> divideByThirteen(\"20\")\n *   (\"1\", \"7\")\n */",
      "bg": "/**\n * Разделете голямо число (като низ) на 13 и върнете частното и остатъка.\n * Входното число може да бъде до 100 цифри дълго.\n *\n * Пример:\n * >>> divideByThirteen(\"2132104848488485\")\n *   (\"164008065268345\", \"0\")\n * >>> divideByThirteen(\"169\")\n *   (\"13\", \"0\")\n * >>> divideByThirteen(\"20\")\n *   (\"1\", \"7\")\n */ \n\nfun divideByThirteen(number: String): Pair<String, String> ",
      "zh": "/**\n * 将一个大数字（作为字符串）除以13，并返回商和余数。\n * 输入数字可以长达100位。\n *\n * 例子:\n * >>> divideByThirteen(\"2132104848488485\")\n *   (\"164008065268345\", \"0\")\n * >>> divideByThirteen(\"169\")\n *   (\"13\", \"0\")\n * >>> divideByThirteen(\"20\")\n *   (\"1\", \"7\")\n */ \n\nfun divideByThirteen(number: String): Pair<String, String> ",
      "fr": "/**\n * Diviser un grand nombre (sous forme de chaîne) par 13 et retourner le quotient et le reste.\n * Le nombre d'entrée peut comporter jusqu'à 100 chiffres.\n *\n * Exemple:\n * >>> divideByThirteen(\"2132104848488485\")\n *   (\"164008065268345\", \"0\")\n * >>> divideByThirteen(\"169\")\n *   (\"13\", \"0\")\n * >>> divideByThirteen(\"20\")\n *   (\"1\", \"7\")\n */",
      "de": "/**\n * Teile eine große Zahl (als String) durch 13 und gib den Quotienten und den Rest zurück.\n * Die Eingabeziffer kann bis zu 100 Stellen lang sein.\n *\n * Beispiel:\n * >>> divideByThirteen(\"2132104848488485\")\n *   (\"164008065268345\", \"0\")\n * >>> divideByThirteen(\"169\")\n *   (\"13\", \"0\")\n * >>> divideByThirteen(\"20\")\n *   (\"1\", \"7\")\n */",
      "ha": "/**\n * Raba babbar lamba (a matsayin kirtani) da 13 kuma mayar da sakamakon da saura.\n * Lambar da aka shigar na iya kaiwa har zuwa tsawon adadin 100.\n *\n * Misali:\n * >>> divideByThirteen(\"2132104848488485\")\n *   (\"164008065268345\", \"0\")\n * >>> divideByThirteen(\"169\")\n *   (\"13\", \"0\")\n * >>> divideByThirteen(\"20\")\n *   (\"1\", \"7\")\n */ \n\nfun divideByThirteen(number: String): Pair<String, String> ",
      "hi": "/**\n * एक बड़े संख्या (एक स्ट्रिंग के रूप में) को 13 से विभाजित करें और भागफल और शेषफल लौटाएं।\n * इनपुट संख्या 100 अंकों तक लंबी हो सकती है।\n *\n * उदाहरण:\n * >>> divideByThirteen(\"2132104848488485\")\n *   (\"164008065268345\", \"0\")\n * >>> divideByThirteen(\"169\")\n *   (\"13\", \"0\")\n * >>> divideByThirteen(\"20\")\n *   (\"1\", \"7\")\n */",
      "hu": "/**\n * Osszunk el egy nagy számot (sztringként) 13-mal, és adjuk vissza a hányadost és a maradékot.\n * A bemeneti szám akár 100 számjegy hosszú is lehet.\n *\n * Példa:\n * >>> divideByThirteen(\"2132104848488485\")\n *   (\"164008065268345\", \"0\")\n * >>> divideByThirteen(\"169\")\n *   (\"13\", \"0\")\n * >>> divideByThirteen(\"20\")\n *   (\"1\", \"7\")\n */"
    },
    "prompt_bertscore": {
      "sq": "1",
      "hy": "0.9978778330090232",
      "bn": "0.9577066261181464",
      "bg": "1",
      "zh": "0.9986608339710628",
      "fr": "0.946618879618398",
      "de": "0.9502494457229537",
      "ha": "0.9881028346975343",
      "hi": "0.9577066261181464",
      "hu": "0.9548109924234198"
    },
    "canonical_solution": "{\n    var quotient = \"\"\n    var remainder = 0\n    for (digit in number) {\n        val current = remainder * 10 + digit.toString().toInt()\n        quotient += (current / 13).toString()\n        remainder = current % 13\n    }\n    // Remove leading zeros from quotient\n    quotient = quotient.trimStart('0')\n    return Pair(quotient.ifEmpty { \"0\" }, remainder.toString())\n}",
    "instruction": {
      "en": "Write a Kotlin function `fun divideByThirteen(number: String): Pair<String, String>` to solve the following problem:\nDivide a large number (as a string) by 13 and return the quotient and remainder.\nThe input number can be up to 100 digits long.\n\nExample:\n>>> divideByThirteen(\"2132104848488485\")\n(\"164008065268345\", \"0\")\n>>> divideByThirteen(\"169\")\n(\"13\", \"0\")\n>>> divideByThirteen(\"20\")\n(\"1\", \"7\")",
      "sq": "Shkruani një funksion Kotlin `fun divideByThirteen(number: String): Pair<String, String>` për të zgjidhur problemin e mëposhtëm:  \nNdani një numër të madh (si një varg) me 13 dhe ktheni kuotën dhe mbetjen.  \nNumri i futur mund të jetë deri në 100 shifra i gjatë.\n\nShembull:  \n>>> divideByThirteen(\"2132104848488485\")  \n(\"164008065268345\", \"0\")  \n>>> divideByThirteen(\"169\")  \n(\"13\", \"0\")  \n>>> divideByThirteen(\"20\")  \n(\"1\", \"7\")",
      "hy": "Գրեք Kotlin ֆունկցիա `fun divideByThirteen(number: String): Pair<String, String>` հետևյալ խնդիրը լուծելու համար:\nԲաժանեք մեծ թիվը (որպես տող) 13-ի վրա և վերադարձրեք քանորդը և մնացորդը։\nՄուտքային թիվը կարող է լինել մինչև 100 նիշ երկարությամբ։\n\nՕրինակ:\n>>> divideByThirteen(\"2132104848488485\")\n(\"164008065268345\", \"0\")\n>>> divideByThirteen(\"169\")\n(\"13\", \"0\")\n>>> divideByThirteen(\"20\")\n(\"1\", \"7\")",
      "bn": "একটি Kotlin ফাংশন `fun divideByThirteen(number: String): Pair<String, String>` লিখুন নিম্নলিখিত সমস্যার সমাধানের জন্য:\nএকটি বড় সংখ্যা (স্ট্রিং হিসাবে) 13 দ্বারা ভাগ করুন এবং ভাগফল এবং অবশিষ্টাংশ ফেরত দিন।\nইনপুট সংখ্যা সর্বাধিক 100 অঙ্কের দীর্ঘ হতে পারে।\n\nউদাহরণ:\n>>> divideByThirteen(\"2132104848488485\")\n(\"164008065268345\", \"0\")\n>>> divideByThirteen(\"169\")\n(\"13\", \"0\")\n>>> divideByThirteen(\"20\")\n(\"1\", \"7\")",
      "bg": "Напишете Kotlin функция `fun divideByThirteen(number: String): Pair<String, String>` за решаване на следния проблем:  \nРазделете голямо число (като низ) на 13 и върнете частното и остатъка.  \nВходното число може да бъде до 100 цифри дълго.  \n\nПример:  \n>>> divideByThirteen(\"2132104848488485\")  \n(\"164008065268345\", \"0\")  \n>>> divideByThirteen(\"169\")  \n(\"13\", \"0\")  \n>>> divideByThirteen(\"20\")  \n(\"1\", \"7\")",
      "zh": "编写一个 Kotlin 函数 `fun divideByThirteen(number: String): Pair<String, String>` 来解决以下问题：  \n将一个大数字（作为字符串）除以 13，并返回商和余数。  \n输入数字可以长达 100 位。  \n\n示例:  \n>>> divideByThirteen(\"2132104848488485\")  \n(\"164008065268345\", \"0\")  \n>>> divideByThirteen(\"169\")  \n(\"13\", \"0\")  \n>>> divideByThirteen(\"20\")  \n(\"1\", \"7\")",
      "fr": "Écrire une fonction Kotlin `fun divideByThirteen(number: String): Pair<String, String>` pour résoudre le problème suivant :\nDiviser un grand nombre (sous forme de chaîne) par 13 et retourner le quotient et le reste.\nLe nombre d'entrée peut comporter jusqu'à 100 chiffres.\n\nExemple :\n>>> divideByThirteen(\"2132104848488485\")\n(\"164008065268345\", \"0\")\n>>> divideByThirteen(\"169\")\n(\"13\", \"0\")\n>>> divideByThirteen(\"20\")\n(\"1\", \"7\")",
      "de": "Schreiben Sie eine Kotlin-Funktion `fun divideByThirteen(number: String): Pair<String, String>`, um das folgende Problem zu lösen:\nTeilen Sie eine große Zahl (als String) durch 13 und geben Sie den Quotienten und den Rest zurück.\nDie Eingabezahl kann bis zu 100 Ziffern lang sein.\n\nBeispiel:\n>>> divideByThirteen(\"2132104848488485\")\n(\"164008065268345\", \"0\")\n>>> divideByThirteen(\"169\")\n(\"13\", \"0\")\n>>> divideByThirteen(\"20\")\n(\"1\", \"7\")",
      "ha": "Rubuta aikin Kotlin `fun divideByThirteen(number: String): Pair<String, String>` don warware matsalar mai zuwa:  \nRaba babbar lamba (a matsayin kirtani) da 13 kuma dawo da sakamakon kason da saura.  \nLambar shigarwa na iya zama har zuwa adadin 100.  \n\nMisali:  \n>>> divideByThirteen(\"2132104848488485\")  \n(\"164008065268345\", \"0\")  \n>>> divideByThirteen(\"169\")  \n(\"13\", \"0\")  \n>>> divideByThirteen(\"20\")  \n(\"1\", \"7\")",
      "hi": "Kotlin फ़ंक्शन `fun divideByThirteen(number: String): Pair<String, String>` लिखें ताकि निम्नलिखित समस्या का समाधान किया जा सके:\n13 से एक बड़े संख्या (एक स्ट्रिंग के रूप में) को विभाजित करें और भागफल और शेषफल लौटाएं।\nइनपुट संख्या 100 अंकों तक लंबी हो सकती है।\n\nउदाहरण:\n>>> divideByThirteen(\"2132104848488485\")\n(\"164008065268345\", \"0\")\n>>> divideByThirteen(\"169\")\n(\"13\", \"0\")\n>>> divideByThirteen(\"20\")\n(\"1\", \"7\")",
      "hu": "Írj egy Kotlin függvényt `fun divideByThirteen(number: String): Pair<String, String>` a következő probléma megoldására:\nOssz el egy nagy számot (stringként) 13-mal, és add vissza a hányadost és a maradékot.\nA bemeneti szám akár 100 számjegy hosszú is lehet.\n\nPélda:\n>>> divideByThirteen(\"2132104848488485\")\n(\"164008065268345\", \"0\")\n>>> divideByThirteen(\"169\")\n(\"13\", \"0\")\n>>> divideByThirteen(\"20\")\n(\"1\", \"7\")"
    },
    "instruction_bertscore": {
      "sq": "1",
      "hy": "0.9238470301437818",
      "bn": "1",
      "bg": "1",
      "zh": "1",
      "fr": "0.9881318347331655",
      "de": "0.9954356724741993",
      "ha": "0.9956625083693411",
      "hi": "0.9820815533268428",
      "hu": "0.9923149905577602"
    },
    "level": "easy",
    "test": "fun main() {\n    check(divideByThirteen(\"2132104848488485\") == Pair(\"164008065268345\", \"0\"))\n    check(divideByThirteen(\"169\") == Pair(\"13\", \"0\"))\n    check(divideByThirteen(\"20\") == Pair(\"1\", \"7\"))\n    check(divideByThirteen(\"130\") == Pair(\"10\", \"0\"))\n    check(divideByThirteen(\"0\") == Pair(\"0\", \"0\"))\n}\n\n\nmain()",
    "entry_point": "divideByThirteen",
    "signature": "fun divideByThirteen(number: String): Pair<String, String>",
    "docstring": {
      "en": "Divide a large number (as a string) by 13 and return the quotient and remainder.\nThe input number can be up to 100 digits long.\n\nExample:\n>>> divideByThirteen(\"2132104848488485\")\n(\"164008065268345\", \"0\")\n>>> divideByThirteen(\"169\")\n(\"13\", \"0\")\n>>> divideByThirteen(\"20\")\n(\"1\", \"7\")",
      "sq": "Ndaj një numër të madh (si një varg) me 13 dhe kthe koeficientin dhe mbetjen. Numri i futur mund të jetë deri në 100 shifra i gjatë.\n\nShembull:\n>>> divideByThirteen(\"2132104848488485\")\n(\"164008065268345\", \"0\")\n>>> divideByThirteen(\"169\")\n(\"13\", \"0\")\n>>> divideByThirteen(\"20\")\n(\"1\", \"7\")",
      "hy": "Մեծ թիվը (որպես տող) բաժանել 13-ի և վերադարձնել քանորդը և մնացորդը։ Մուտքային թիվը կարող է լինել մինչև 100 նիշ երկարությամբ։\n\nՕրինակ:\n>>> divideByThirteen(\"2132104848488485\")\n(\"164008065268345\", \"0\")\n>>> divideByThirteen(\"169\")\n(\"13\", \"0\")\n>>> divideByThirteen(\"20\")\n(\"1\", \"7\")",
      "bn": "একটি বড় সংখ্যা (স্ট্রিং হিসাবে) 13 দ্বারা ভাগ করুন এবং ভাগফল এবং অবশিষ্টাংশ ফেরত দিন। ইনপুট সংখ্যা সর্বাধিক 100 অঙ্ক দীর্ঘ হতে পারে।\n\nউদাহরণ:\n>>> divideByThirteen(\"2132104848488485\")\n(\"164008065268345\", \"0\")\n>>> divideByThirteen(\"169\")\n(\"13\", \"0\")\n>>> divideByThirteen(\"20\")\n(\"1\", \"7\")",
      "bg": "Разделете голямо число (като низ) на 13 и върнете частното и остатъка. Входното число може да бъде до 100 цифри дълго.\n\nПример:\n>>> divideByThirteen(\"2132104848488485\")\n(\"164008065268345\", \"0\")\n>>> divideByThirteen(\"169\")\n(\"13\", \"0\")\n>>> divideByThirteen(\"20\")\n(\"1\", \"7\")",
      "zh": "将一个大数字（作为字符串）除以13，并返回商和余数。  \n输入的数字可以长达100位。\n\n示例：\n>>> divideByThirteen(\"2132104848488485\")\n(\"164008065268345\", \"0\")\n>>> divideByThirteen(\"169\")\n(\"13\", \"0\")\n>>> divideByThirteen(\"20\")\n(\"1\", \"7\")",
      "fr": "Diviser un grand nombre (sous forme de chaîne) par 13 et retourner le quotient et le reste. Le nombre d'entrée peut comporter jusqu'à 100 chiffres.\n\nExemple :\n>>> divideByThirteen(\"2132104848488485\")\n(\"164008065268345\", \"0\")\n>>> divideByThirteen(\"169\")\n(\"13\", \"0\")\n>>> divideByThirteen(\"20\")\n(\"1\", \"7\")",
      "de": "Teile eine große Zahl (als String) durch 13 und gib den Quotienten und den Rest zurück. Die Eingabezahl kann bis zu 100 Stellen lang sein.\n\nBeispiel:\n>>> divideByThirteen(\"2132104848488485\")\n(\"164008065268345\", \"0\")\n>>> divideByThirteen(\"169\")\n(\"13\", \"0\")\n>>> divideByThirteen(\"20\")\n(\"1\", \"7\")",
      "ha": "Raba wata babbar lamba (a matsayin kirtani) da 13 kuma dawo da sakamakon rabo da saura. \nLambar shigarwa na iya zama har zuwa tsawon lambobi 100.\n\nMisali:\n>>> divideByThirteen(\"2132104848488485\")\n(\"164008065268345\", \"0\")\n>>> divideByThirteen(\"169\")\n(\"13\", \"0\")\n>>> divideByThirteen(\"20\")\n(\"1\", \"7\")",
      "hi": "एक बड़े संख्या (एक स्ट्रिंग के रूप में) को 13 से विभाजित करें और भागफल और शेषफल लौटाएं। \nइनपुट संख्या 100 अंकों तक लंबी हो सकती है।\n\nउदाहरण:\n>>> divideByThirteen(\"2132104848488485\")\n(\"164008065268345\", \"0\")\n>>> divideByThirteen(\"169\")\n(\"13\", \"0\")\n>>> divideByThirteen(\"20\")\n(\"1\", \"7\")",
      "hu": "Osszon el egy nagy számot (sztringként) 13-mal, és adja vissza a hányadost és a maradékot.  \nA bemeneti szám legfeljebb 100 számjegyű lehet.\n\nPélda:\n>>> divideByThirteen(\"2132104848488485\")\n(\"164008065268345\", \"0\")\n>>> divideByThirteen(\"169\")\n(\"13\", \"0\")\n>>> divideByThirteen(\"20\")\n(\"1\", \"7\")"
    },
    "docstring_bertscore": {
      "sq": "1",
      "hy": "0.9966673794669967",
      "bn": "0.9849813582595711",
      "bg": "1",
      "zh": "1",
      "fr": "0.9847904744633965",
      "de": "0.995855179838945",
      "ha": "1",
      "hi": "1",
      "hu": "0.995855179838945"
    }
  },
  {
    "task_id": "Kotlin/38",
    "prompt": {
      "en": "/**\n    * Extracts all integer numbers from a given string and returns them as a sorted list.\n    * The integers in the string are assumed to be non-negative and separated by non-digit characters.\n    * If no integers are found, returns a list containing only zero.\n    *\n    * Example:\n    * >>> extractAndSortIntegers(\"*1234.345#6781ad9jk81-11101?aght88ir09kp\")\n    *     [9, 9, 81, 88, 345, 1234, 6781, 11101]\n    * >>> extractAndSortIntegers(\"no numbers\")\n    *     [0]\n**/\n\nfun extractAndSortIntegers(input: String): List<Int> ",
      "sq": "/**\n    * Nxjerr të gjitha numrat e plotë nga një varg i dhënë dhe i kthen ato si një listë të renditur.\n    * Numrat e plotë në varg supozohet të jenë jo-negativë dhe të ndarë nga karaktere jo-numrike.\n    * Nëse nuk gjenden numra të plotë, kthen një listë që përmban vetëm zero.\n    *\n    * Shembull:\n    * >>> extractAndSortIntegers(\"*1234.345#6781ad9jk81-11101?aght88ir09kp\")\n    *     [9, 9, 81, 88, 345, 1234, 6781, 11101]\n    * >>> extractAndSortIntegers(\"no numbers\")\n    *     [0]\n**/",
      "hy": "/**\n    * Հանում է բոլոր ամբողջ թվերը տրված տողից և վերադարձնում դրանք դասավորված ցուցակի տեսքով:\n    * Տողում գտնվող ամբողջ թվերը ենթադրվում են ոչ բացասական և բաժանված ոչ թվանշանային սիմվոլներով:\n    * Եթե ամբողջ թվեր չեն գտնվել, վերադարձնում է ցուցակ, որը պարունակում է միայն զրո:\n    *\n    * Օրինակ:\n    * >>> extractAndSortIntegers(\"*1234.345#6781ad9jk81-11101?aght88ir09kp\")\n    *     [9, 9, 81, 88, 345, 1234, 6781, 11101]\n    * >>> extractAndSortIntegers(\"no numbers\")\n    *     [0]\n**/",
      "bn": "/**\n    * প্রদত্ত স্ট্রিং থেকে সমস্ত পূর্ণসংখ্যা বের করে এবং সেগুলিকে একটি সাজানো তালিকা হিসাবে ফেরত দেয়।\n    * স্ট্রিংয়ের পূর্ণসংখ্যাগুলি অ-ঋণাত্মক এবং অ-সংখ্যা অক্ষর দ্বারা পৃথক বলে মনে করা হয়।\n    * যদি কোনো পূর্ণসংখ্যা পাওয়া না যায়, তাহলে শুধুমাত্র শূন্য ধারণকারী একটি তালিকা ফেরত দেয়।\n    *\n    * উদাহরণ:\n    * >>> extractAndSortIntegers(\"*1234.345#6781ad9jk81-11101?aght88ir09kp\")\n    *     [9, 9, 81, 88, 345, 1234, 6781, 11101]\n    * >>> extractAndSortIntegers(\"no numbers\")\n    *     [0]\n**/",
      "bg": "/**\n    * Извлича всички цели числа от даден низ и ги връща като сортиран списък.\n    * Предполага се, че целите числа в низа са неотрицателни и разделени с недигитални символи.\n    * Ако не се намерят цели числа, връща списък, съдържащ само нула.\n    *\n    * Пример:\n    * >>> extractAndSortIntegers(\"*1234.345#6781ad9jk81-11101?aght88ir09kp\")\n    *     [9, 9, 81, 88, 345, 1234, 6781, 11101]\n    * >>> extractAndSortIntegers(\"no numbers\")\n    *     [0]\n**/",
      "zh": "/**\n    * 从给定字符串中提取所有整数，并将它们作为排序列表返回。\n    * 假设字符串中的整数是非负的，并由非数字字符分隔。\n    * 如果未找到整数，则返回仅包含零的列表。\n    *\n    * 示例:\n    * >>> extractAndSortIntegers(\"*1234.345#6781ad9jk81-11101?aght88ir09kp\")\n    *     [9, 9, 81, 88, 345, 1234, 6781, 11101]\n    * >>> extractAndSortIntegers(\"no numbers\")\n    *     [0]\n**/",
      "fr": "/**\n    * Extrait tous les nombres entiers d'une chaîne donnée et les renvoie sous forme de liste triée.\n    * Les entiers dans la chaîne sont supposés être non négatifs et séparés par des caractères non numériques.\n    * Si aucun entier n'est trouvé, renvoie une liste contenant uniquement zéro.\n    *\n    * Exemple :\n    * >>> extractAndSortIntegers(\"*1234.345#6781ad9jk81-11101?aght88ir09kp\")\n    *     [9, 9, 81, 88, 345, 1234, 6781, 11101]\n    * >>> extractAndSortIntegers(\"no numbers\")\n    *     [0]\n**/",
      "de": "/**\n    * Extrahiert alle ganzen Zahlen aus einem gegebenen String und gibt sie als sortierte Liste zurück.\n    * Es wird angenommen, dass die ganzen Zahlen im String nicht negativ sind und durch Nicht-Ziffern-Zeichen getrennt sind.\n    * Wenn keine ganzen Zahlen gefunden werden, wird eine Liste zurückgegeben, die nur Null enthält.\n    *\n    * Beispiel:\n    * >>> extractAndSortIntegers(\"*1234.345#6781ad9jk81-11101?aght88ir09kp\")\n    *     [9, 9, 81, 88, 345, 1234, 6781, 11101]\n    * >>> extractAndSortIntegers(\"no numbers\")\n    *     [0]\n**/",
      "ha": "/**\n    * Yana cire duk lambobin cikakku daga wani rubutu kuma yana mayar da su a matsayin jerin da aka tsara.\n    * Ana ɗauka lambobin cikakku a cikin rubutun ba su da alama kuma an raba su da haruffa marasa lambobi.\n    * Idan ba a sami lambobi ba, yana mayar da jerin da ke ɗauke da sifili kawai.\n    *\n    * Misali:\n    * >>> extractAndSortIntegers(\"*1234.345#6781ad9jk81-11101?aght88ir09kp\")\n    *     [9, 9, 81, 88, 345, 1234, 6781, 11101]\n    * >>> extractAndSortIntegers(\"no numbers\")\n    *     [0]\n**/",
      "hi": "/**\n    * दिए गए स्ट्रिंग से सभी पूर्णांक संख्याओं को निकालता है और उन्हें एक क्रमबद्ध सूची के रूप में लौटाता है।\n    * स्ट्रिंग में पूर्णांक गैर-ऋणात्मक माने जाते हैं और गैर-अंक वर्णों द्वारा अलग होते हैं।\n    * यदि कोई पूर्णांक नहीं मिलता है, तो केवल शून्य वाली एक सूची लौटाता है।\n    *\n    * उदाहरण:\n    * >>> extractAndSortIntegers(\"*1234.345#6781ad9jk81-11101?aght88ir09kp\")\n    *     [9, 9, 81, 88, 345, 1234, 6781, 11101]\n    * >>> extractAndSortIntegers(\"no numbers\")\n    *     [0]\n**/",
      "hu": "/**\n    * Kivonja az összes egész számot egy adott szövegből, és rendezett listaként adja vissza őket.\n    * Feltételezzük, hogy a szövegben lévő egész számok nem negatívak, és nem számjegy karakterek választják el őket.\n    * Ha nem található egész szám, akkor egy listát ad vissza, amely csak nullát tartalmaz.\n    *\n    * Példa:\n    * >>> extractAndSortIntegers(\"*1234.345#6781ad9jk81-11101?aght88ir09kp\")\n    *     [9, 9, 81, 88, 345, 1234, 6781, 11101]\n    * >>> extractAndSortIntegers(\"no numbers\")\n    *     [0]\n**/"
    },
    "prompt_bertscore": {
      "sq": "0.9611975550648346",
      "hy": "0.9617708023445013",
      "bn": "0.9547813964966456",
      "bg": "0.9582854350484821",
      "zh": "0.9434066290963017",
      "fr": "0.9611975550648346",
      "de": "0.9572813584723507",
      "ha": "0.9204097994712255",
      "hi": "0.9475248327862981",
      "hu": "0.9427745872238487"
    },
    "canonical_solution": "{\n    val numberRegex = \"\\\\d+\".toRegex()\n    val numbers = numberRegex.findAll(input).map { it.value.toInt() }.toList()\n    return if (numbers.isEmpty()) listOf(0) else numbers.sorted()\n}",
    "instruction": {
      "en": "Write a Kotlin function `fun extractAndSortIntegers(input: String): List<Int>` to solve the following problem:\nExtracts all integer numbers from a given string and returns them as a sorted list.\nThe integers in the string are assumed to be non-negative and separated by non-digit characters.\nIf no integers are found, returns a list containing only zero.\n\nExample:\n>>> extractAndSortIntegers(\"*1234.345#6781ad9jk81-11101?aght88ir09kp\")\n[9, 9, 81, 88, 345, 1234, 6781, 11101]\n>>> extractAndSortIntegers(\"no numbers\")\n[0]",
      "sq": "Shkruani një funksion Kotlin `fun extractAndSortIntegers(input: String): List<Int>` për të zgjidhur problemin e mëposhtëm:  \nEkstrakton të gjitha numrat e plotë nga një varg i dhënë dhe i kthen ato si një listë të renditur.  \nNumrat e plotë në varg supozohet të jenë jo-negativë dhe të ndarë nga karaktere jo-shifrore.  \nNëse nuk gjenden numra të plotë, kthen një listë që përmban vetëm zero.  \n\nShembull:  \n>>> extractAndSortIntegers(\"*1234.345#6781ad9jk81-11101?aght88ir09kp\")  \n[9, 9, 81, 88, 345, 1234, 6781, 11101]  \n>>> extractAndSortIntegers(\"no numbers\")  \n[0]",
      "hy": "Գրեք Kotlin ֆունկցիա `fun extractAndSortIntegers(input: String): List<Int>` հետևյալ խնդիրը լուծելու համար:\nՀանում է բոլոր ամբողջ թվերը տրված տողից և վերադարձնում դրանք որպես սորտավորված ցուցակ:\nԵնթադրվում է, որ տողի ամբողջ թվերը ոչ բացասական են և բաժանված են ոչ թվանշանային նիշերով:\nԵթե ամբողջ թվեր չեն գտնվել, վերադարձնում է ցուցակ, որը պարունակում է միայն զրո:\n\nՕրինակ:\n>>> extractAndSortIntegers(\"*1234.345#6781ad9jk81-11101?aght88ir09kp\")\n[9, 9, 81, 88, 345, 1234, 6781, 11101]\n>>> extractAndSortIntegers(\"no numbers\")\n[0]",
      "bn": "Kotlin ফাংশন `fun extractAndSortIntegers(input: String): List<Int>` লিখুন নিম্নলিখিত সমস্যার সমাধানের জন্য:\nএকটি প্রদত্ত স্ট্রিং থেকে সমস্ত পূর্ণসংখ্যা বের করে এবং সেগুলিকে একটি সাজানো তালিকা হিসাবে ফেরত দেয়।\nস্ট্রিংয়ের পূর্ণসংখ্যাগুলি অ-ঋণাত্মক এবং অ-অঙ্ক অক্ষর দ্বারা পৃথক করা হয়েছে বলে মনে করা হয়।\nযদি কোনো পূর্ণসংখ্যা পাওয়া না যায়, তাহলে শুধুমাত্র শূন্য ধারণকারী একটি তালিকা ফেরত দেয়।\n\nউদাহরণ:\n>>> extractAndSortIntegers(\"*1234.345#6781ad9jk81-11101?aght88ir09kp\")\n[9, 9, 81, 88, 345, 1234, 6781, 11101]\n>>> extractAndSortIntegers(\"no numbers\")\n[0]",
      "bg": "Напишете Kotlin функция `fun extractAndSortIntegers(input: String): List<Int>` за решаване на следния проблем:\nИзвлича всички цели числа от даден низ и ги връща като сортиран списък.\nЦелите числа в низа се предполага, че са неотрицателни и разделени от символи, които не са цифри.\nАко не бъдат намерени цели числа, връща списък, съдържащ само нула.\n\nПример:\n>>> extractAndSortIntegers(\"*1234.345#6781ad9jk81-11101?aght88ir09kp\")\n[9, 9, 81, 88, 345, 1234, 6781, 11101]\n>>> extractAndSortIntegers(\"no numbers\")\n[0]",
      "zh": "编写一个 Kotlin 函数 `fun extractAndSortIntegers(input: String): List<Int>` 来解决以下问题：\n从给定的字符串中提取所有整数，并将它们作为排序列表返回。\n假设字符串中的整数是非负的，并由非数字字符分隔。\n如果未找到整数，则返回仅包含零的列表。\n\n示例：\n>>> extractAndSortIntegers(\"*1234.345#6781ad9jk81-11101?aght88ir09kp\")\n[9, 9, 81, 88, 345, 1234, 6781, 11101]\n>>> extractAndSortIntegers(\"no numbers\")\n[0]",
      "fr": "Écrire une fonction Kotlin `fun extractAndSortIntegers(input: String): List<Int>` pour résoudre le problème suivant :\nExtrait tous les nombres entiers d'une chaîne donnée et les renvoie sous forme de liste triée.\nLes entiers dans la chaîne sont supposés être non négatifs et séparés par des caractères non numériques.\nSi aucun entier n'est trouvé, renvoie une liste contenant uniquement zéro.\n\nExemple :\n>>> extractAndSortIntegers(\"*1234.345#6781ad9jk81-11101?aght88ir09kp\")\n[9, 9, 81, 88, 345, 1234, 6781, 11101]\n>>> extractAndSortIntegers(\"no numbers\")\n[0]",
      "de": "Schreiben Sie eine Kotlin-Funktion `fun extractAndSortIntegers(input: String): List<Int>`, um das folgende Problem zu lösen:\nExtrahiert alle ganzen Zahlen aus einem gegebenen String und gibt sie als sortierte Liste zurück.\nDie Ganzzahlen im String werden als nicht-negativ angenommen und sind durch Nicht-Ziffern-Zeichen getrennt.\nWenn keine Ganzzahlen gefunden werden, wird eine Liste zurückgegeben, die nur Null enthält.\n\nBeispiel:\n>>> extractAndSortIntegers(\"*1234.345#6781ad9jk81-11101?aght88ir09kp\")\n[9, 9, 81, 88, 345, 1234, 6781, 11101]\n>>> extractAndSortIntegers(\"no numbers\")\n[0]",
      "ha": "Rubuta aikin Kotlin `fun extractAndSortIntegers(input: String): List<Int>` don warware matsalar mai zuwa:\nYana cire duk lambobin cikakken adadi daga wani baƙaƙen rubutu kuma ya mayar da su a matsayin jerin da aka tsara.\nAna ɗauka cewa lambobin cikakken adadi a cikin baƙaƙen rubutu ba su da tabbatacce kuma an raba su da haruffan da ba su da lamba.\nIdan ba a sami lambobi ba, yana mayar da jerin da ke ɗauke da sifili kawai.\n\nMisali:\n>>> extractAndSortIntegers(\"*1234.345#6781ad9jk81-11101?aght88ir09kp\")\n[9, 9, 81, 88, 345, 1234, 6781, 11101]\n>>> extractAndSortIntegers(\"no numbers\")\n[0]",
      "hi": "Kotlin फ़ंक्शन `fun extractAndSortIntegers(input: String): List<Int>` लिखें ताकि निम्नलिखित समस्या का समाधान किया जा सके:\nदिए गए स्ट्रिंग से सभी पूर्णांक संख्याओं को निकालता है और उन्हें एक क्रमबद्ध सूची के रूप में वापस करता है।\nस्ट्रिंग में पूर्णांक संख्याएँ गैर-ऋणात्मक मानी जाती हैं और गैर-अंक वर्णों द्वारा अलग की जाती हैं।\nयदि कोई पूर्णांक नहीं मिलता है, तो केवल शून्य वाली एक सूची लौटाता है।\n\nउदाहरण:\n>>> extractAndSortIntegers(\"*1234.345#6781ad9jk81-11101?aght88ir09kp\")\n[9, 9, 81, 88, 345, 1234, 6781, 11101]\n>>> extractAndSortIntegers(\"no numbers\")\n[0]",
      "hu": "Írj egy Kotlin függvényt `fun extractAndSortIntegers(input: String): List<Int>` a következő probléma megoldására:\nKivonja az összes egész számot egy adott szövegből, és rendezett listaként adja vissza őket.\nA szövegben lévő egész számok feltételezhetően nem negatívak, és nem számjegy karakterek választják el őket.\nHa nem található egész szám, akkor egy listát ad vissza, amely csak nullát tartalmaz.\n\nPélda:\n>>> extractAndSortIntegers(\"*1234.345#6781ad9jk81-11101?aght88ir09kp\")\n[9, 9, 81, 88, 345, 1234, 6781, 11101]\n>>> extractAndSortIntegers(\"no numbers\")\n[0]"
    },
    "instruction_bertscore": {
      "sq": "0.9937967732002805",
      "hy": "0.9865278944063087",
      "bn": "0.9767409782719577",
      "bg": "0.9944131232726316",
      "zh": "0.975103469410706",
      "fr": "0.9835174523513439",
      "de": "0.9912457632166494",
      "ha": "0.9710309507083478",
      "hi": "0.963830599395833",
      "hu": "0.9835099043968646"
    },
    "level": "easy",
    "test": "check(extractAndSortIntegers(\"*1234.345#6781ad9jk81-11101?aght88ir09kp\") == listOf(9, 9, 81, 88, 345, 1234, 6781, 11101))\ncheck(extractAndSortIntegers(\"no numbers\") == listOf(0))\ncheck(extractAndSortIntegers(\"123&456*789\") == listOf(123, 456, 789))\ncheck(extractAndSortIntegers(\"abc\") == listOf(0))",
    "entry_point": "extractAndSortIntegers",
    "signature": "fun extractAndSortIntegers(input: String): List<Int>",
    "docstring": {
      "en": "Extracts all integer numbers from a given string and returns them as a sorted list.\nThe integers in the string are assumed to be non-negative and separated by non-digit characters.\nIf no integers are found, returns a list containing only zero.\n\nExample:\n>>> extractAndSortIntegers(\"*1234.345#6781ad9jk81-11101?aght88ir09kp\")\n[9, 9, 81, 88, 345, 1234, 6781, 11101]\n>>> extractAndSortIntegers(\"no numbers\")\n[0]",
      "sq": "Ekstrakton të gjitha numrat e plotë nga një varg i dhënë dhe i kthen ato si një listë të renditur.\nNumrat e plotë në varg supozohet të jenë jo-negativë dhe të ndarë nga karaktere jo-shifrore.\nNëse nuk gjenden numra të plotë, kthen një listë që përmban vetëm zero.\n\nShembull:\n>>> extractAndSortIntegers(\"*1234.345#6781ad9jk81-11101?aght88ir09kp\")\n[9, 9, 81, 88, 345, 1234, 6781, 11101]\n>>> extractAndSortIntegers(\"no numbers\")\n[0]",
      "hy": "Տողից դուրս է բերում բոլոր ամբողջ թվերը և վերադարձնում դրանք որպես դասավորված ցուցակ։  \nԵնթադրվում է, որ տողի ամբողջ թվերը ոչ բացասական են և բաժանված են ոչ թվանշանային նիշերով։  \nԵթե ամբողջ թվեր չեն գտնվել, վերադարձնում է ցուցակ, որը պարունակում է միայն զրո։\n\nՕրինակ:\n>>> extractAndSortIntegers(\"*1234.345#6781ad9jk81-11101?aght88ir09kp\")\n[9, 9, 81, 88, 345, 1234, 6781, 11101]\n>>> extractAndSortIntegers(\"no numbers\")\n[0]",
      "bn": "প্রদত্ত স্ট্রিং থেকে সমস্ত পূর্ণসংখ্যা বের করে একটি সাজানো তালিকা হিসাবে ফেরত দেয়। স্ট্রিংয়ের পূর্ণসংখ্যাগুলি অ-ঋণাত্মক এবং অ-সংখ্যা অক্ষর দ্বারা পৃথক বলে মনে করা হয়। যদি কোনো পূর্ণসংখ্যা পাওয়া না যায়, তাহলে শুধুমাত্র শূন্য ধারণকারী একটি তালিকা ফেরত দেয়।\n\nউদাহরণ:\n>>> extractAndSortIntegers(\"*1234.345#6781ad9jk81-11101?aght88ir09kp\")\n[9, 9, 81, 88, 345, 1234, 6781, 11101]\n>>> extractAndSortIntegers(\"no numbers\")\n[0]",
      "bg": "Извлича всички цели числа от даден низ и ги връща като сортиран списък. Целите числа в низа се приемат за неотрицателни и разделени от символи, които не са цифри. Ако не бъдат намерени цели числа, връща списък, съдържащ само нула.\n\nПример:\n>>> extractAndSortIntegers(\"*1234.345#6781ad9jk81-11101?aght88ir09kp\")\n[9, 9, 81, 88, 345, 1234, 6781, 11101]\n>>> extractAndSortIntegers(\"no numbers\")\n[0]",
      "zh": "从给定的字符串中提取所有整数，并将它们作为排序后的列表返回。  \n假设字符串中的整数是非负的，并且由非数字字符分隔。  \n如果没有找到整数，则返回一个只包含零的列表。\n\n示例：\n>>> extractAndSortIntegers(\"*1234.345#6781ad9jk81-11101?aght88ir09kp\")\n[9, 9, 81, 88, 345, 1234, 6781, 11101]\n>>> extractAndSortIntegers(\"no numbers\")\n[0]",
      "fr": "Extrait tous les nombres entiers d'une chaîne donnée et les renvoie sous forme de liste triée.\nLes entiers dans la chaîne sont supposés être non négatifs et séparés par des caractères non numériques.\nSi aucun entier n'est trouvé, renvoie une liste contenant uniquement zéro.\n\nExemple :\n>>> extractAndSortIntegers(\"*1234.345#6781ad9jk81-11101?aght88ir09kp\")\n[9, 9, 81, 88, 345, 1234, 6781, 11101]\n>>> extractAndSortIntegers(\"no numbers\")\n[0]",
      "de": "Extrahiert alle ganzen Zahlen aus einem gegebenen String und gibt sie als sortierte Liste zurück.\nDie Ganzzahlen im String werden als nicht-negativ angenommen und sind durch Nicht-Ziffern-Zeichen getrennt.\nWenn keine Ganzzahlen gefunden werden, wird eine Liste zurückgegeben, die nur Null enthält.\n\nBeispiel:\n>>> extractAndSortIntegers(\"*1234.345#6781ad9jk81-11101?aght88ir09kp\")\n[9, 9, 81, 88, 345, 1234, 6781, 11101]\n>>> extractAndSortIntegers(\"no numbers\")\n[0]",
      "ha": "Fitar da duk lambobin cikakke daga wani kirtani da aka bayar kuma ya dawo da su a matsayin jerin da aka tsara.\nAna tsammanin lambobin cikakke a cikin kirtani suna da rashin tabbatacce kuma an raba su ta hanyar haruffa marasa lambobi.\nIdan ba a sami lambobi ba, yana dawo da jerin da ke dauke da sifili kawai.\n\nMisali:\n>>> extractAndSortIntegers(\"*1234.345#6781ad9jk81-11101?aght88ir09kp\")\n[9, 9, 81, 88, 345, 1234, 6781, 11101]\n>>> extractAndSortIntegers(\"no numbers\")\n[0]",
      "hi": "दिए गए स्ट्रिंग से सभी पूर्णांक संख्याएँ निकालता है और उन्हें एक क्रमबद्ध सूची के रूप में लौटाता है। स्ट्रिंग में पूर्णांक संख्याएँ गैर-ऋणात्मक मानी जाती हैं और गैर-अंक वर्णों द्वारा अलग की जाती हैं। यदि कोई पूर्णांक नहीं मिलता है, तो केवल शून्य वाली सूची लौटाता है।\n\nउदाहरण:\n>>> extractAndSortIntegers(\"*1234.345#6781ad9jk81-11101?aght88ir09kp\")\n[9, 9, 81, 88, 345, 1234, 6781, 11101]\n>>> extractAndSortIntegers(\"no numbers\")\n[0]",
      "hu": "Kivonja az összes egész számot egy adott szövegből, és rendezett listaként adja vissza őket. A szövegben lévő egész számok nem negatívak, és nem számjegy karakterek választják el őket. Ha nem található egész szám, egyetlen nullát tartalmazó listát ad vissza.\n\nPélda:\n>>> extractAndSortIntegers(\"*1234.345#6781ad9jk81-11101?aght88ir09kp\")\n[9, 9, 81, 88, 345, 1234, 6781, 11101]\n>>> extractAndSortIntegers(\"no numbers\")\n[0]"
    },
    "docstring_bertscore": {
      "sq": "0.9950098089372605",
      "hy": "0.983523808523537",
      "bn": "0.9845463577251047",
      "bg": "0.9914090373898601",
      "zh": "0.974396543884603",
      "fr": "0.9889990549767638",
      "de": "0.9864603600767569",
      "ha": "0.9701196345201597",
      "hi": "0.9810274218946906",
      "hu": "0.9660933966965826"
    }
  },
  {
    "task_id": "Kotlin/39",
    "prompt": {
      "en": "/**\n * Determines whether a given number x is an element of a set M generated from a starting number k.\n * The set M is generated as follows:\n *   (1) k is an element of M.\n *   (2) If y is an element of M, then both (2y + 1) and (3y + 1) are elements of M.\n *   (3) No other elements are in M except those generated by the above rules.\n * \n * Example:\n * >>> isElementOfGeneratedSet(0, 22)\n *     \"YES\"\n * >>> isElementOfGeneratedSet(1, 10)\n *     \"NO\"\n */\n\n\n\nfun isElementOfGeneratedSet(k: Int, x: Int): String ",
      "sq": "/**\n * Përcakton nëse një numër i dhënë x është një element i një bashkësie M e gjeneruar nga një numër fillestar k.\n * Bashkësia M gjenerohet si më poshtë:\n *   (1) k është një element i M.\n *   (2) Nëse y është një element i M, atëherë si (2y + 1) ashtu edhe (3y + 1) janë elemente të M.\n *   (3) Nuk ka elemente të tjera në M përveç atyre të gjeneruara nga rregullat e mësipërme.\n * \n * Shembull:\n * >>> isElementOfGeneratedSet(0, 22)\n *     \"PO\"\n * >>> isElementOfGeneratedSet(1, 10)\n *     \"JO\"\n */\n\n\n\nfun isElementOfGeneratedSet(k: Int, x: Int): String ",
      "hy": "/**\n * Որոշում է, արդյոք տրված թիվը x հանդիսանում է M բազմության տարր, որը գեներացվել է k սկզբնական թվից:\n * M բազմությունը գեներացվում է հետևյալ կերպ.\n *   (1) k-ն M-ի տարր է:\n *   (2) Եթե y-ն M-ի տարր է, ապա և՛ (2y + 1)-ը, և՛ (3y + 1)-ը M-ի տարրեր են:\n *   (3) M-ում այլ տարրեր չկան, բացի վերը նշված կանոններով գեներացվածներից:\n * \n * Օրինակ:\n * >>> isElementOfGeneratedSet(0, 22)\n *     \"YES\"\n * >>> isElementOfGeneratedSet(1, 10)\n *     \"NO\"\n */\n\n\n\nfun isElementOfGeneratedSet(k: Int, x: Int): String ",
      "bn": "/**\n * নির্ধারণ করে যে প্রদত্ত সংখ্যা x একটি সেট M এর উপাদান কিনা যা একটি প্রারম্ভিক সংখ্যা k থেকে উৎপন্ন হয়।\n * সেট M নিম্নলিখিতভাবে উৎপন্ন হয়:\n *   (1) k হল M এর একটি উপাদান।\n *   (2) যদি y M এর একটি উপাদান হয়, তাহলে (2y + 1) এবং (3y + 1) উভয়ই M এর উপাদান।\n *   (3) উপরের নিয়ম দ্বারা উৎপন্ন ছাড়া অন্য কোন উপাদান M এ নেই।\n * \n * উদাহরণ:\n * >>> isElementOfGeneratedSet(0, 22)\n *     \"YES\"\n * >>> isElementOfGeneratedSet(1, 10)\n *     \"NO\"\n */\n\n\n\nfun isElementOfGeneratedSet(k: Int, x: Int): String ",
      "bg": "/**\n * Определя дали дадено число x е елемент от множество M, генерирано от начално число k.\n * Множеството M се генерира по следния начин:\n *   (1) k е елемент на M.\n *   (2) Ако y е елемент на M, тогава и (2y + 1), и (3y + 1) са елементи на M.\n *   (3) Няма други елементи в M, освен тези, генерирани от горните правила.\n * \n * Пример:\n * >>> isElementOfGeneratedSet(0, 22)\n *     \"YES\"\n * >>> isElementOfGeneratedSet(1, 10)\n *     \"NO\"\n */\n\n\n\nfun isElementOfGeneratedSet(k: Int, x: Int): String ",
      "zh": "/**\n * 确定给定数字 x 是否是从起始数字 k 生成的集合 M 的元素。\n * 集合 M 的生成规则如下：\n *   (1) k 是 M 的一个元素。\n *   (2) 如果 y 是 M 的一个元素，那么 (2y + 1) 和 (3y + 1) 也是 M 的元素。\n *   (3) 除了通过上述规则生成的元素外，M 中没有其他元素。\n * \n * 示例:\n * >>> isElementOfGeneratedSet(0, 22)\n *     \"YES\"\n * >>> isElementOfGeneratedSet(1, 10)\n *     \"NO\"\n */\n\n\n\nfun isElementOfGeneratedSet(k: Int, x: Int): String ",
      "fr": "/**\n * Détermine si un nombre donné x est un élément d'un ensemble M généré à partir d'un nombre de départ k.\n * L'ensemble M est généré comme suit :\n *   (1) k est un élément de M.\n *   (2) Si y est un élément de M, alors (2y + 1) et (3y + 1) sont des éléments de M.\n *   (3) Aucun autre élément n'est dans M sauf ceux générés par les règles ci-dessus.\n * \n * Exemple :\n * >>> isElementOfGeneratedSet(0, 22)\n *     \"YES\"\n * >>> isElementOfGeneratedSet(1, 10)\n *     \"NO\"\n */\n\n\n\nfun isElementOfGeneratedSet(k: Int, x: Int): String ",
      "de": "/**\n * Bestimmt, ob eine gegebene Zahl x ein Element einer Menge M ist, die aus einer Startzahl k generiert wird.\n * Die Menge M wird wie folgt generiert:\n *   (1) k ist ein Element von M.\n *   (2) Wenn y ein Element von M ist, dann sind sowohl (2y + 1) als auch (3y + 1) Elemente von M.\n *   (3) Keine anderen Elemente sind in M außer denen, die durch die obigen Regeln generiert werden.\n * \n * Beispiel:\n * >>> isElementOfGeneratedSet(0, 22)\n *     \"YES\"\n * >>> isElementOfGeneratedSet(1, 10)\n *     \"NO\"\n */\n\n\n\nfun isElementOfGeneratedSet(k: Int, x: Int): String ",
      "ha": "/**\n * Tabbatar ko wani lamba x yana cikin wani saitin M da aka samar daga wata lamba farawa k.\n * Ana samar da saitin M kamar haka:\n *   (1) k yana cikin M.\n *   (2) Idan y yana cikin M, to duka (2y + 1) da (3y + 1) suna cikin M.\n *   (3) Babu wasu abubuwa a cikin M sai waɗanda aka samar ta hanyar ƙa'idodin da ke sama.\n * \n * Misali:\n * >>> isElementOfGeneratedSet(0, 22)\n *     \"YES\"\n * >>> isElementOfGeneratedSet(1, 10)\n *     \"NO\"\n */\n\n\n\nfun isElementOfGeneratedSet(k: Int, x: Int): String ",
      "hi": "/**\n * निर्धारित करता है कि दिया गया संख्या x एक सेट M का तत्व है जो एक प्रारंभिक संख्या k से उत्पन्न होता है।\n * सेट M निम्नलिखित तरीके से उत्पन्न होता है:\n *   (1) k, M का एक तत्व है।\n *   (2) यदि y, M का एक तत्व है, तो (2y + 1) और (3y + 1) दोनों M के तत्व हैं।\n *   (3) उपरोक्त नियमों द्वारा उत्पन्न तत्वों के अलावा M में कोई अन्य तत्व नहीं हैं।\n * \n * उदाहरण:\n * >>> isElementOfGeneratedSet(0, 22)\n *     \"YES\"\n * >>> isElementOfGeneratedSet(1, 10)\n *     \"NO\"\n */\n\n\n\nfun isElementOfGeneratedSet(k: Int, x: Int): String ",
      "hu": "/**\n * Meghatározza, hogy egy adott x szám eleme-e egy M halmaznak, amelyet egy kezdő k számból generálunk.\n * Az M halmaz a következőképpen generálódik:\n *   (1) k eleme M-nek.\n *   (2) Ha y eleme M-nek, akkor mind (2y + 1), mind (3y + 1) elemei M-nek.\n *   (3) Nincsenek más elemek M-ben, csak az előző szabályok által generáltak.\n * \n * Példa:\n * >>> isElementOfGeneratedSet(0, 22)\n *     \"YES\"\n * >>> isElementOfGeneratedSet(1, 10)\n *     \"NO\"\n */\n\n\n\nfun isElementOfGeneratedSet(k: Int, x: Int): String "
    },
    "prompt_bertscore": {
      "sq": "0.9644672097670499",
      "hy": "0.9719702737802618",
      "bn": "0.9962065569829957",
      "bg": "0.9762976352614878",
      "zh": "0.9699629151495232",
      "fr": "0.9942204518030279",
      "de": "1",
      "ha": "0.961268466110864",
      "hi": "0.9832423492736106",
      "hu": "0.9811960590881892"
    },
    "canonical_solution": "{\n    val setM = mutableSetOf(k)\n    val queue = ArrayDeque<Int>()\n    queue.add(k)\n\n    while (queue.isNotEmpty()) {\n        val current = queue.removeFirst()\n        if (current == x) return \"YES\"\n        if (current < x) {\n            val next1 = 2 * current + 1\n            val next2 = 3 * current + 1\n            if (setM.add(next1)) queue.add(next1)\n            if (setM.add(next2)) queue.add(next2)\n        }\n    }\n\n    return \"NO\"\n}",
    "instruction": {
      "en": "Write a Kotlin function `fun isElementOfGeneratedSet(k: Int, x: Int): String` to solve the following problem:\nDetermines whether a given number x is an element of a set M generated from a starting number k.\nThe set M is generated as follows:\n(1) k is an element of M.\n(2) If y is an element of M, then both (2y + 1) and (3y + 1) are elements of M.\n(3) No other elements are in M except those generated by the above rules.\n\nExample:\n>>> isElementOfGeneratedSet(0, 22)\n\"YES\"\n>>> isElementOfGeneratedSet(1, 10)\n\"NO\"",
      "sq": "Shkruani një funksion Kotlin `fun isElementOfGeneratedSet(k: Int, x: Int): String` për të zgjidhur problemin e mëposhtëm:\nPërcakton nëse një numër i dhënë x është një element i një bashkësie M të gjeneruar nga një numër fillestar k.\nBashkësia M gjenerohet si më poshtë:\n(1) k është një element i M.\n(2) Nëse y është një element i M, atëherë të dy (2y + 1) dhe (3y + 1) janë elementë të M.\n(3) Asnjë element tjetër nuk është në M përveç atyre të gjeneruar nga rregullat e mësipërme.\n\nShembull:\n>>> isElementOfGeneratedSet(0, 22)\n\"YES\"\n>>> isElementOfGeneratedSet(1, 10)\n\"NO\"",
      "hy": "Գրեք Kotlin ֆունկցիա `fun isElementOfGeneratedSet(k: Int, x: Int): String`՝ հետևյալ խնդիրը լուծելու համար: \nՈրոշում է, արդյոք տրված թիվը x հանդիսանում է M բազմության տարր, որը գեներացվել է k սկզբնական թվից: \nM բազմությունը գեներացվում է հետևյալ կերպ. \n(1) k-ն M-ի տարր է: \n(2) Եթե y-ն M-ի տարր է, ապա (2y + 1) և (3y + 1) նույնպես M-ի տարրեր են: \n(3) M-ում չկան այլ տարրեր, բացի վերը նշված կանոններով գեներացվածներից:\n\nՕրինակ:\n>>> isElementOfGeneratedSet(0, 22)\n\"YES\"\n>>> isElementOfGeneratedSet(1, 10)\n\"NO\"",
      "bn": "Kotlin ফাংশন `fun isElementOfGeneratedSet(k: Int, x: Int): String` লিখুন নিম্নলিখিত সমস্যার সমাধানের জন্য:\nনির্ধারণ করে যে প্রদত্ত সংখ্যা x একটি সেট M এর উপাদান কিনা যা একটি প্রারম্ভিক সংখ্যা k থেকে উৎপন্ন হয়।\nসেট M নিম্নরূপ উৎপন্ন হয়:\n(1) k হল M এর একটি উপাদান।\n(2) যদি y M এর একটি উপাদান হয়, তাহলে (2y + 1) এবং (3y + 1) উভয়ই M এর উপাদান।\n(3) উপরোক্ত নিয়ম দ্বারা উৎপন্ন ছাড়া অন্য কোন উপাদান M এ নেই।\n\nউদাহরণ:\n>>> isElementOfGeneratedSet(0, 22)\n\"YES\"\n>>> isElementOfGeneratedSet(1, 10)\n\"NO\"",
      "bg": "Напишете Kotlin функция `fun isElementOfGeneratedSet(k: Int, x: Int): String`, за да решите следния проблем:\nОпределя дали дадено число x е елемент на множество M, генерирано от начално число k.\nМножеството M се генерира по следния начин:\n(1) k е елемент на M.\n(2) Ако y е елемент на M, тогава и (2y + 1), и (3y + 1) са елементи на M.\n(3) Няма други елементи в M, освен тези, генерирани от горните правила.\n\nПример:\n>>> isElementOfGeneratedSet(0, 22)\n\"YES\"\n>>> isElementOfGeneratedSet(1, 10)\n\"NO\"",
      "zh": "编写一个 Kotlin 函数 `fun isElementOfGeneratedSet(k: Int, x: Int): String` 来解决以下问题：\n确定给定数字 x 是否为从起始数字 k 生成的集合 M 的元素。\n集合 M 的生成规则如下：\n(1) k 是 M 的一个元素。\n(2) 如果 y 是 M 的一个元素，那么 (2y + 1) 和 (3y + 1) 也是 M 的元素。\n(3) 除了通过上述规则生成的元素外，M 中没有其他元素。\n\n示例：\n>>> isElementOfGeneratedSet(0, 22)\n\"YES\"\n>>> isElementOfGeneratedSet(1, 10)\n\"NO\"",
      "fr": "Écrire une fonction Kotlin `fun isElementOfGeneratedSet(k: Int, x: Int): String` pour résoudre le problème suivant :\nDétermine si un nombre donné x est un élément d'un ensemble M généré à partir d'un nombre de départ k.\nL'ensemble M est généré comme suit :\n(1) k est un élément de M.\n(2) Si y est un élément de M, alors (2y + 1) et (3y + 1) sont des éléments de M.\n(3) Aucun autre élément n'est dans M sauf ceux générés par les règles ci-dessus.\n\nExemple :\n>>> isElementOfGeneratedSet(0, 22)\n\"YES\"\n>>> isElementOfGeneratedSet(1, 10)\n\"NO\"",
      "de": "Schreiben Sie eine Kotlin-Funktion `fun isElementOfGeneratedSet(k: Int, x: Int): String`, um das folgende Problem zu lösen:\nBestimmt, ob eine gegebene Zahl x ein Element einer Menge M ist, die von einer Startzahl k erzeugt wird.\nDie Menge M wird wie folgt erzeugt:\n(1) k ist ein Element von M.\n(2) Wenn y ein Element von M ist, dann sind sowohl (2y + 1) als auch (3y + 1) Elemente von M.\n(3) Keine anderen Elemente sind in M außer denen, die durch die obigen Regeln erzeugt werden.\n\nBeispiel:\n>>> isElementOfGeneratedSet(0, 22)\n\"YES\"\n>>> isElementOfGeneratedSet(1, 10)\n\"NO\"",
      "ha": "Rubuta aikin Kotlin `fun isElementOfGeneratedSet(k: Int, x: Int): String` don warware matsalar mai zuwa: \n\nYana tantance ko wani adadi x yana cikin wani saitin M wanda aka samar daga wani adadi farawa k. \n\nSaitin M ana samar da shi kamar haka: \n(1) k yana cikin M. \n(2) Idan y yana cikin M, to duka (2y + 1) da (3y + 1) suna cikin M. \n(3) Babu wasu abubuwa a cikin M sai waɗanda aka samar ta hanyar dokokin da ke sama.\n\nMisali:\n>>> isElementOfGeneratedSet(0, 22)\n\"YES\"\n>>> isElementOfGeneratedSet(1, 10)\n\"NO\"",
      "hi": "Kotlin फ़ंक्शन `fun isElementOfGeneratedSet(k: Int, x: Int): String` लिखें ताकि निम्नलिखित समस्या का समाधान हो सके:\nनिर्धारित करता है कि दिया गया संख्या x सेट M का तत्व है या नहीं, जो प्रारंभिक संख्या k से उत्पन्न होता है।\nसेट M निम्नलिखित रूप से उत्पन्न होता है:\n(1) k, M का एक तत्व है।\n(2) यदि y, M का एक तत्व है, तो (2y + 1) और (3y + 1) दोनों M के तत्व हैं।\n(3) उपरोक्त नियमों द्वारा उत्पन्न तत्वों के अलावा M में कोई अन्य तत्व नहीं है।\n\nउदाहरण:\n>>> isElementOfGeneratedSet(0, 22)\n\"YES\"\n>>> isElementOfGeneratedSet(1, 10)\n\"NO\"",
      "hu": "Írj egy Kotlin függvényt `fun isElementOfGeneratedSet(k: Int, x: Int): String` a következő probléma megoldására:\nMegállapítja, hogy egy adott x szám eleme-e egy M halmaznak, amely egy k kezdőszámból van generálva.\nAz M halmaz a következőképpen van generálva:\n(1) k eleme M-nek.\n(2) Ha y eleme M-nek, akkor mind (2y + 1), mind (3y + 1) elemei M-nek.\n(3) Nincsenek más elemek M-ben, csak azok, amelyeket a fenti szabályok generálnak.\n\nPélda:\n>>> isElementOfGeneratedSet(0, 22)\n\"YES\"\n>>> isElementOfGeneratedSet(1, 10)\n\"NO\""
    },
    "instruction_bertscore": {
      "sq": "0.9920100929228717",
      "hy": "0.9760380253534753",
      "bn": "0.9886794586936786",
      "bg": "0.9794429473451752",
      "zh": "0.9701982921510495",
      "fr": "0.9885521366194353",
      "de": "1",
      "ha": "0.965811540185894",
      "hi": "0.9719595477396858",
      "hu": "0.9869209839303767"
    },
    "level": "middle",
    "test": "fun main() {\n    check(isElementOfGeneratedSet(0, 22) == \"YES\")\n    check(isElementOfGeneratedSet(1, 10) == \"YES\")\n    check(isElementOfGeneratedSet(2, 13) == \"NO\")\n    check(isElementOfGeneratedSet(3, 30) == \"NO\")\n}\n\n\nmain()",
    "entry_point": "isElementOfGeneratedSet",
    "signature": "fun isElementOfGeneratedSet(k: Int, x: Int): String",
    "docstring": {
      "en": "Determines whether a given number x is an element of a set M generated from a starting number k.\nThe set M is generated as follows:\n(1) k is an element of M.\n(2) If y is an element of M, then both (2y + 1) and (3y + 1) are elements of M.\n(3) No other elements are in M except those generated by the above rules.\n\nExample:\n>>> isElementOfGeneratedSet(0, 22)\n\"YES\"\n>>> isElementOfGeneratedSet(1, 10)\n\"NO\"",
      "sq": "Përcakton nëse një numër i dhënë x është një element i një bashkësie M të gjeneruar nga një numër fillestar k.\nBashkësia M gjenerohet si më poshtë:\n(1) k është një element i M.\n(2) Nëse y është një element i M, atëherë të dy (2y + 1) dhe (3y + 1) janë elementë të M.\n(3) Asnjë element tjetër nuk është në M përveç atyre të gjeneruar nga rregullat e mësipërme.\n\nShembull:\n>>> isElementOfGeneratedSet(0, 22)\n\"PO\"\n>>> isElementOfGeneratedSet(1, 10)\n\"JO\"",
      "hy": "Սահմանում է՝ արդյոք տրված x թիվը M բազմության տարր է, որը գեներացվում է k սկզբնական թվից։\nM բազմությունը գեներացվում է հետևյալ կերպ.\n(1) k-ն M-ի տարր է։\n(2) Եթե y-ն M-ի տարր է, ապա և՛ (2y + 1)-ը, և՛ (3y + 1)-ը M-ի տարրեր են։\n(3) M-ում այլ տարրեր չկան, բացի վերոնշյալ կանոններով գեներացվածներից։\n\nՕրինակ:\n>>> isElementOfGeneratedSet(0, 22)\n\"YES\"\n>>> isElementOfGeneratedSet(1, 10)\n\"NO\"",
      "bn": "একটি প্রদত্ত সংখ্যা x একটি সেট M এর উপাদান কিনা তা নির্ধারণ করে যা একটি প্রারম্ভিক সংখ্যা k থেকে তৈরি করা হয়। \nসেট M নিম্নলিখিতভাবে তৈরি করা হয়:\n(১) k হল M এর একটি উপাদান।\n(২) যদি y M এর একটি উপাদান হয়, তাহলে (2y + 1) এবং (3y + 1) উভয়ই M এর উপাদান।\n(৩) উপরের নিয়ম দ্বারা তৈরি উপাদান ছাড়া অন্য কোনো উপাদান M এ নেই।\n\nউদাহরণ:\n>>> isElementOfGeneratedSet(0, 22)\n\"YES\"\n>>> isElementOfGeneratedSet(1, 10)\n\"NO\"",
      "bg": "Определя дали дадено число x е елемент на множество M, генерирано от начално число k.  \nМножеството M се генерира по следния начин:  \n(1) k е елемент на M.  \n(2) Ако y е елемент на M, тогава и (2y + 1) и (3y + 1) са елементи на M.  \n(3) Няма други елементи в M, освен тези, генерирани от горните правила.\n\nПример:\n>>> isElementOfGeneratedSet(0, 22)\n\"YES\"\n>>> isElementOfGeneratedSet(1, 10)\n\"NO\"",
      "zh": "确定给定数字 x 是否是从起始数字 k 生成的集合 M 的元素。  \n集合 M 的生成规则如下：  \n(1) k 是 M 的元素。  \n(2) 如果 y 是 M 的元素，那么 (2y + 1) 和 (3y + 1) 也是 M 的元素。  \n(3) 除了通过上述规则生成的元素外，M 中没有其他元素。\n\n示例：\n>>> isElementOfGeneratedSet(0, 22)\n\"YES\"\n>>> isElementOfGeneratedSet(1, 10)\n\"NO\"",
      "fr": "Détermine si un nombre donné x est un élément d'un ensemble M généré à partir d'un nombre de départ k.  \nL'ensemble M est généré comme suit :  \n(1) k est un élément de M.  \n(2) Si y est un élément de M, alors (2y + 1) et (3y + 1) sont également des éléments de M.  \n(3) Aucun autre élément n'est dans M, sauf ceux générés par les règles ci-dessus.  \n\nExemple :  \n>>> isElementOfGeneratedSet(0, 22)  \n\"YES\"  \n>>> isElementOfGeneratedSet(1, 10)  \n\"NO\"  ",
      "de": "Bestimmt, ob eine gegebene Zahl x ein Element einer Menge M ist, die von einer Startzahl k erzeugt wird. \nDie Menge M wird wie folgt erzeugt: \n(1) k ist ein Element von M. \n(2) Wenn y ein Element von M ist, dann sind sowohl (2y + 1) als auch (3y + 1) Elemente von M. \n(3) Keine anderen Elemente sind in M außer denen, die durch die obigen Regeln erzeugt werden.\n\nBeispiel:\n>>> isElementOfGeneratedSet(0, 22)\n\"YES\"\n>>> isElementOfGeneratedSet(1, 10)\n\"NO\"",
      "ha": "Yana tantance ko wani adadi x yana cikin wani saitin M da aka samar daga wani adadi farawa k. \nAn samar da saitin M kamar haka:\n(1) k yana cikin M.\n(2) Idan y yana cikin M, to duka (2y + 1) da (3y + 1) suna cikin M.\n(3) Babu wasu abubuwa a cikin M sai waɗanda aka samar da dokokin da ke sama.\n\nMisali:\n>>> isElementOfGeneratedSet(0, 22)\n\"YES\"\n>>> isElementOfGeneratedSet(1, 10)\n\"NO\"",
      "hi": "यह निर्धारित करता है कि दिया गया संख्या x, प्रारंभिक संख्या k से उत्पन्न सेट M का एक तत्व है या नहीं।  \nसेट M निम्नलिखित तरीके से उत्पन्न होता है:  \n(1) k, M का एक तत्व है।  \n(2) यदि y, M का एक तत्व है, तो (2y + 1) और (3y + 1) दोनों M के तत्व हैं।  \n(3) उपरोक्त नियमों द्वारा उत्पन्न तत्वों के अलावा M में कोई अन्य तत्व नहीं हैं।\n\nउदाहरण:\n>>> isElementOfGeneratedSet(0, 22)\n\"YES\"\n>>> isElementOfGeneratedSet(1, 10)\n\"NO\"",
      "hu": "Meghatározza, hogy egy adott x szám eleme-e egy M halmaznak, amelyet egy k kezdőszámból generálnak.  \nAz M halmaz a következőképpen generálódik:  \n(1) k eleme M-nek.  \n(2) Ha y eleme M-nek, akkor mind (2y + 1), mind (3y + 1) elemei M-nek.  \n(3) Nincsenek más elemek M-ben, csak azokat, amelyeket a fenti szabályok generálnak.  \n\nPélda:  \n>>> isElementOfGeneratedSet(0, 22)  \n\"YES\"  \n>>> isElementOfGeneratedSet(1, 10)  \n\"NO\"  "
    },
    "docstring_bertscore": {
      "sq": "0.9976863533217056",
      "hy": "0.9847326730225154",
      "bn": "0.9840253502356502",
      "bg": "0.9852592421626388",
      "zh": "0.9638502638035555",
      "fr": "0.9827336568677802",
      "de": "1",
      "ha": "0.956468960213918",
      "hi": "0.975553168593369",
      "hu": "0.9780285004018259"
    }
  },
  {
    "task_id": "Kotlin/40",
    "prompt": {
      "en": "/**\n    * Find the author who has published the most books and return the author's initial along with the IDs of books they've contributed to.\n    * The input is a list of pairs, where each pair consists of a book ID (Int) and a string of unique uppercase letters representing authors.\n    * The function returns a pair with the most published author's initial (Char) and a list of book IDs (List<Int>) they've contributed to.\n    Example:\n\n    >>> findMostPublishedAuthor(listOf(Pair(410, \"GPKCV\"), Pair(567, \"SPIM\"), Pair(822, \"YSHDLPM\")))\n        Pair('P', listOf(410, 567, 822))\n**/\n\n\nfun findMostPublishedAuthor(books: List<Pair<Int, String>>): Pair<Char, List<Int>> ",
      "sq": "/**\n    * Gjeni autorin që ka botuar më shumë libra dhe ktheni inicialet e autorit së bashku me ID-të e librave ku kanë kontribuar.\n    * Hyrja është një listë çiftesh, ku secili çift përbëhet nga një ID libri (Int) dhe një varg shkronjash të mëdha unike që përfaqësojnë autorët.\n    * Funksioni kthen një çift me inicialet e autorit më të botuar (Char) dhe një listë të ID-ve të librave (List<Int>) ku kanë kontribuar.\n    Shembull:\n\n    >>> findMostPublishedAuthor(listOf(Pair(410, \"GPKCV\"), Pair(567, \"SPIM\"), Pair(822, \"YSHDLPM\")))\n        Pair('P', listOf(410, 567, 822))\n**/",
      "hy": "/**\n    * Գտնել այն հեղինակին, ով հրապարակել է ամենաշատ գրքերը և վերադարձնել հեղինակի սկզբնատառը և այն գրքերի ID-ները, որոնց նրանք մասնակցել են:\n    * Մուտքը զույգերի ցուցակ է, որտեղ յուրաքանչյուր զույգ բաղկացած է գրքի ID-ից (Int) և հեղինակների եզակի մեծատառերի տողից:\n    * Ֆունկցիան վերադարձնում է զույգ՝ ամենաշատ հրապարակված հեղինակի սկզբնատառով (Char) և այն գրքերի ID-ների ցուցակով (List<Int>), որոնց նրանք մասնակցել են:\n    Օրինակ:\n\n    >>> findMostPublishedAuthor(listOf(Pair(410, \"GPKCV\"), Pair(567, \"SPIM\"), Pair(822, \"YSHDLPM\")))\n        Pair('P', listOf(410, 567, 822))\n**/",
      "bn": "/**\n    * সর্বাধিক বই প্রকাশিত হয়েছে এমন লেখককে খুঁজুন এবং লেখকের প্রাথমিক অক্ষর সহ তাদের অবদান রাখা বইয়ের আইডিগুলি ফেরত দিন।\n    * ইনপুটটি একটি জোড়ার তালিকা, যেখানে প্রতিটি জোড়া একটি বইয়ের আইডি (Int) এবং লেখকদের প্রতিনিধিত্বকারী অনন্য বড় হাতের অক্ষরের একটি স্ট্রিং নিয়ে গঠিত।\n    * ফাংশনটি সর্বাধিক প্রকাশিত লেখকের প্রাথমিক অক্ষর (Char) এবং তারা অবদান রাখা বইয়ের আইডিগুলির একটি তালিকা (List<Int>) সহ একটি জোড়া ফেরত দেয়।\n    উদাহরণ:\n\n    >>> findMostPublishedAuthor(listOf(Pair(410, \"GPKCV\"), Pair(567, \"SPIM\"), Pair(822, \"YSHDLPM\")))\n        Pair('P', listOf(410, 567, 822))\n**/",
      "bg": "/**\n    * Намерете автора, който е публикувал най-много книги, и върнете инициалите на автора заедно с ID-тата на книгите, към които е допринесъл.\n    * Входът е списък от двойки, където всяка двойка се състои от ID на книга (Int) и низ от уникални главни букви, представляващи автори.\n    * Функцията връща двойка с инициалите на автора с най-много публикации (Char) и списък от ID-та на книги (List<Int>), към които е допринесъл.\n    Пример:\n\n    >>> findMostPublishedAuthor(listOf(Pair(410, \"GPKCV\"), Pair(567, \"SPIM\"), Pair(822, \"YSHDLPM\")))\n        Pair('P', listOf(410, 567, 822))\n**/",
      "zh": "/**\n    * 找到出版书籍最多的作者，并返回作者的首字母以及他们贡献的书籍ID。\n    * 输入是一个对的列表，每个对由一个书籍ID（Int）和一个表示作者的唯一大写字母字符串组成。\n    * 该函数返回一个对，其中包含出版最多书籍的作者的首字母（Char）和他们贡献的书籍ID列表（List<Int>）。\n    示例:\n\n    >>> findMostPublishedAuthor(listOf(Pair(410, \"GPKCV\"), Pair(567, \"SPIM\"), Pair(822, \"YSHDLPM\")))\n        Pair('P', listOf(410, 567, 822))\n**/",
      "fr": "/**\n    * Trouver l'auteur qui a publié le plus de livres et retourner l'initiale de l'auteur ainsi que les IDs des livres auxquels il a contribué.\n    * L'entrée est une liste de paires, où chaque paire se compose d'un ID de livre (Int) et d'une chaîne de lettres majuscules uniques représentant les auteurs.\n    * La fonction retourne une paire avec l'initiale de l'auteur le plus publié (Char) et une liste d'IDs de livres (List<Int>) auxquels il a contribué.\n    Exemple:\n\n    >>> findMostPublishedAuthor(listOf(Pair(410, \"GPKCV\"), Pair(567, \"SPIM\"), Pair(822, \"YSHDLPM\")))\n        Pair('P', listOf(410, 567, 822))\n**/",
      "de": "/**\n    * Finde den Autor, der die meisten Bücher veröffentlicht hat, und gib das Initial des Autors zusammen mit den IDs der Bücher zurück, zu denen er beigetragen hat.\n    * Die Eingabe ist eine Liste von Paaren, wobei jedes Paar aus einer Buch-ID (Int) und einer Zeichenkette aus einzigartigen Großbuchstaben besteht, die Autoren darstellen.\n    * Die Funktion gibt ein Paar mit dem Initial des am meisten veröffentlichten Autors (Char) und einer Liste von Buch-IDs (List<Int>) zurück, zu denen er beigetragen hat.\n    Beispiel:\n\n    >>> findMostPublishedAuthor(listOf(Pair(410, \"GPKCV\"), Pair(567, \"SPIM\"), Pair(822, \"YSHDLPM\")))\n        Pair('P', listOf(410, 567, 822))\n**/",
      "ha": "/**\n    * Nemo marubucin da ya wallafa mafi yawan littattafai kuma mayar da farkon sunan marubucin tare da IDs na littattafan da suka ba da gudummawa.\n    * Shigarwar ita ce jerin ma'aurata, inda kowace ma'aurata ta ƙunshi ID na littafi (Int) da igiyar haruffa na musamman manyan haruffa da ke wakiltar marubuta.\n    * Aikin yana mayar da ma'aurata tare da farkon sunan marubucin da ya fi wallafa (Char) da jerin IDs na littattafai (List<Int>) da suka ba da gudummawa.\n    Misali:\n\n    >>> findMostPublishedAuthor(listOf(Pair(410, \"GPKCV\"), Pair(567, \"SPIM\"), Pair(822, \"YSHDLPM\")))\n        Pair('P', listOf(410, 567, 822))\n**/",
      "hi": "/**\n    * उस लेखक को खोजें जिसने सबसे अधिक पुस्तकें प्रकाशित की हैं और लेखक के प्रारंभिक अक्षर के साथ उन पुस्तकों के IDs लौटाएं जिनमें उन्होंने योगदान दिया है।\n    * इनपुट एक जोड़े की सूची है, जहां प्रत्येक जोड़ा एक पुस्तक ID (Int) और अद्वितीय बड़े अक्षरों की स्ट्रिंग से बना होता है जो लेखकों का प्रतिनिधित्व करती है।\n    * फ़ंक्शन सबसे अधिक प्रकाशित लेखक के प्रारंभिक अक्षर (Char) और उन पुस्तकों के IDs की सूची (List<Int>) लौटाता है जिनमें उन्होंने योगदान दिया है।\n    उदाहरण:\n\n    >>> findMostPublishedAuthor(listOf(Pair(410, \"GPKCV\"), Pair(567, \"SPIM\"), Pair(822, \"YSHDLPM\")))\n        Pair('P', listOf(410, 567, 822))\n**/",
      "hu": "/**\n    * Találd meg azt a szerzőt, aki a legtöbb könyvet publikálta, és add vissza a szerző kezdőbetűjét, valamint azoknak a könyveknek az azonosítóit, amelyekhez hozzájárult.\n    * A bemenet egy párokból álló lista, ahol minden pár egy könyvazonosítóból (Int) és egy egyedi nagybetűkből álló karakterláncból áll, amely a szerzőket jelöli.\n    * A függvény visszaad egy párt a legtöbbet publikáló szerző kezdőbetűjével (Char) és egy listát a könyvazonosítókról (List<Int>), amelyekhez hozzájárult.\n    Példa:\n\n    >>> findMostPublishedAuthor(listOf(Pair(410, \"GPKCV\"), Pair(567, \"SPIM\"), Pair(822, \"YSHDLPM\")))\n        Pair('P', listOf(410, 567, 822))\n**/"
    },
    "prompt_bertscore": {
      "sq": "0.934338556310916",
      "hy": "0.9473524216155598",
      "bn": "0.9384738422136814",
      "bg": "0.9305363735571461",
      "zh": "0.9269036225183991",
      "fr": "0.9496225682404075",
      "de": "0.9524411333472926",
      "ha": "0.9340014805542998",
      "hi": "0.9296592217944961",
      "hu": "0.9470888390999265"
    },
    "canonical_solution": "{\n    // Map to hold the count of each author's initial\n    val authorCount = mutableMapOf<Char, Int>()\n\n    // Map to hold the book IDs for each author\n    val booksByAuthor = mutableMapOf<Char, MutableList<Int>>()\n\n    // Iterate through the list and update the maps\n    for (book in books) {\n        val bookId = book.first\n        val authors = book.second\n\n        for (author in authors) {\n            authorCount[author] = authorCount.getOrDefault(author, 0) + 1\n            booksByAuthor.getOrPut(author) { mutableListOf() }.add(bookId)\n        }\n    }\n\n    // Find the author with the most publications\n    val mostPublishedAuthor = authorCount.maxByOrNull { it.value }?.key ?: return Pair(' ', listOf())\n\n    // Return the pair of the most published author and their book IDs\n    return Pair(mostPublishedAuthor, booksByAuthor[mostPublishedAuthor] ?: listOf())\n}",
    "instruction": {
      "en": "Write a Kotlin function `fun findMostPublishedAuthor(books: List<Pair<Int, String>>): Pair<Char, List<Int>>` to solve the following problem:\nFind the author who has published the most books and return the author's initial along with the IDs of books they've contributed to.\nThe input is a list of pairs, where each pair consists of a book ID (Int) and a string of unique uppercase letters representing authors.\nThe function returns a pair with the most published author's initial (Char) and a list of book IDs (List<Int>) they've contributed to.\nExample:\n\n>>> findMostPublishedAuthor(listOf(Pair(410, \"GPKCV\"), Pair(567, \"SPIM\"), Pair(822, \"YSHDLPM\")))\nPair('P', listOf(410, 567, 822))",
      "sq": "Shkruani një funksion Kotlin `fun findMostPublishedAuthor(books: List<Pair<Int, String>>): Pair<Char, List<Int>>` për të zgjidhur problemin e mëposhtëm:\nGjeni autorin që ka botuar më shumë libra dhe ktheni inicialin e autorit së bashku me ID-të e librave të cilëve ata kanë kontribuar.\nHyrja është një listë çiftesh, ku çdo çift përbëhet nga një ID libri (Int) dhe një varg me shkronja unike të mëdha që përfaqësojnë autorët.\nFunksioni kthen një çift me inicialin e autorit më të botuar (Char) dhe një listë të ID-ve të librave (List<Int>) të cilëve ata kanë kontribuar.\nShembull:\n\n>>> findMostPublishedAuthor(listOf(Pair(410, \"GPKCV\"), Pair(567, \"SPIM\"), Pair(822, \"YSHDLPM\")))\nPair('P', listOf(410, 567, 822))",
      "hy": "Գրեք Kotlin ֆունկցիա `fun findMostPublishedAuthor(books: List<Pair<Int, String>>): Pair<Char, List<Int>>` հետևյալ խնդիրը լուծելու համար:\nԳտեք այն հեղինակը, ով հրատարակել է ամենաշատ գրքերը և վերադարձեք հեղինակի սկզբնատառը և այն գրքերի ID-ները, որոնց նրանք մասնակցել են:\nՄուտքը զույգերի ցուցակ է, որտեղ յուրաքանչյուր զույգ բաղկացած է գրքի ID-ից (Int) և հեղինակների եզակի մեծատառերի տողից:\nՖունկցիան վերադարձնում է զույգ՝ ամենաշատ հրատարակված հեղինակի սկզբնատառով (Char) և այն գրքերի ID-ների ցուցակով (List<Int>), որոնց նրանք մասնակցել են:\nՕրինակ:\n\n>>> findMostPublishedAuthor(listOf(Pair(410, \"GPKCV\"), Pair(567, \"SPIM\"), Pair(822, \"YSHDLPM\")))\nPair('P', listOf(410, 567, 822))",
      "bn": "Kotlin ফাংশন `fun findMostPublishedAuthor(books: List<Pair<Int, String>>): Pair<Char, List<Int>>` লিখুন নিম্নলিখিত সমস্যার সমাধানের জন্য:\nযে লেখক সবচেয়ে বেশি বই প্রকাশ করেছেন তাকে খুঁজে বের করুন এবং লেখকের প্রাথমিক অক্ষর এবং তারা যে বইগুলিতে অবদান রেখেছেন তার আইডিগুলি ফেরত দিন।\nইনপুটটি একটি জোড়ার তালিকা, যেখানে প্রতিটি জোড়া একটি বইয়ের আইডি (Int) এবং লেখকদের প্রতিনিধিত্বকারী অনন্য বড় হাতের অক্ষরের একটি স্ট্রিং নিয়ে গঠিত।\nফাংশনটি সবচেয়ে বেশি প্রকাশিত লেখকের প্রাথমিক অক্ষর (Char) এবং তারা যে বইগুলিতে অবদান রেখেছেন তার আইডিগুলির একটি তালিকা (List<Int>) সহ একটি জোড়া ফেরত দেয়।\nউদাহরণ:\n\n>>> findMostPublishedAuthor(listOf(Pair(410, \"GPKCV\"), Pair(567, \"SPIM\"), Pair(822, \"YSHDLPM\")))\nPair('P', listOf(410, 567, 822))",
      "bg": "Напишете функция на Kotlin `fun findMostPublishedAuthor(books: List<Pair<Int, String>>): Pair<Char, List<Int>>`, за да решите следния проблем:\nНамерете автора, който е публикувал най-много книги и върнете инициалите на автора заедно с ID-тата на книгите, към които е допринесъл.\nВходът е списък от двойки, където всяка двойка се състои от ID на книга (Int) и низ от уникални главни букви, представляващи автори.\nФункцията връща двойка с инициалите на най-много публикувания автор (Char) и списък с ID-та на книгите (List<Int>), към които е допринесъл.\nПример:\n\n>>> findMostPublishedAuthor(listOf(Pair(410, \"GPKCV\"), Pair(567, \"SPIM\"), Pair(822, \"YSHDLPM\")))\nPair('P', listOf(410, 567, 822))",
      "zh": "编写一个 Kotlin 函数 `fun findMostPublishedAuthor(books: List<Pair<Int, String>>): Pair<Char, List<Int>>` 来解决以下问题：\n找出出版书籍最多的作者，并返回作者的首字母以及他们所贡献的书籍的 ID。\n输入是一个对的列表，其中每个对由一个书籍 ID (Int) 和一个表示作者的唯一大写字母字符串组成。\n函数返回一个对，其中包含出版最多书籍的作者的首字母 (Char) 和他们所贡献的书籍 ID 列表 (List<Int>)。\n示例：\n\n>>> findMostPublishedAuthor(listOf(Pair(410, \"GPKCV\"), Pair(567, \"SPIM\"), Pair(822, \"YSHDLPM\")))\nPair('P', listOf(410, 567, 822))",
      "fr": "Écrire une fonction Kotlin `fun findMostPublishedAuthor(books: List<Pair<Int, String>>): Pair<Char, List<Int>>` pour résoudre le problème suivant :\nTrouver l'auteur qui a publié le plus de livres et retourner l'initiale de l'auteur ainsi que les identifiants des livres auxquels il a contribué.\nL'entrée est une liste de paires, où chaque paire se compose d'un identifiant de livre (Int) et d'une chaîne de lettres majuscules uniques représentant les auteurs.\nLa fonction retourne une paire avec l'initiale de l'auteur le plus publié (Char) et une liste des identifiants de livres (List<Int>) auxquels il a contribué.\nExemple :",
      "de": "Schreiben Sie eine Kotlin-Funktion `fun findMostPublishedAuthor(books: List<Pair<Int, String>>): Pair<Char, List<Int>>`, um das folgende Problem zu lösen:\nFinden Sie den Autor, der die meisten Bücher veröffentlicht hat, und geben Sie das Initial des Autors zusammen mit den IDs der Bücher zurück, zu denen er beigetragen hat.\nDie Eingabe ist eine Liste von Paaren, wobei jedes Paar aus einer Buch-ID (Int) und einer Zeichenkette aus einzigartigen Großbuchstaben besteht, die Autoren darstellen.\nDie Funktion gibt ein Paar mit dem Initial des am meisten veröffentlichten Autors (Char) und einer Liste von Buch-IDs (List<Int>) zurück, zu denen er beigetragen hat.\nBeispiel:\n\n>>> findMostPublishedAuthor(listOf(Pair(410, \"GPKCV\"), Pair(567, \"SPIM\"), Pair(822, \"YSHDLPM\")))\nPair('P', listOf(410, 567, 822))",
      "ha": "Rubuta aikin Kotlin `fun findMostPublishedAuthor(books: List<Pair<Int, String>>): Pair<Char, List<Int>>` don warware matsalar mai zuwa:\nNemo marubucin da ya fi wallafa mafi yawan littattafai kuma dawo da farkon sunan marubucin tare da lambobin ID na littattafan da suka ba da gudummawa a kai.\nShigarwar jerin ma'aurata ne, inda kowanne ma'aurata ya ƙunshi ID na littafi (Int) da igiyar haruffa na musamman manyan haruffa da ke wakiltar marubuta.\nAikin yana dawo da ma'aurata tare da farkon sunan marubucin da ya fi wallafa (Char) da jerin lambobin ID na littattafan (List<Int>) da suka ba da gudummawa a kai.\nMisali:\n\n>>> findMostPublishedAuthor(listOf(Pair(410, \"GPKCV\"), Pair(567, \"SPIM\"), Pair(822, \"YSHDLPM\")))\nPair('P', listOf(410, 567, 822))",
      "hi": "Kotlin फ़ंक्शन `fun findMostPublishedAuthor(books: List<Pair<Int, String>>): Pair<Char, List<Int>>` लिखें ताकि निम्नलिखित समस्या का समाधान किया जा सके:\nउस लेखक को खोजें जिसने सबसे अधिक पुस्तकें प्रकाशित की हैं और लेखक के प्रारंभिक अक्षर के साथ उन पुस्तकों के आईडी लौटाएं जिनमें उन्होंने योगदान दिया है।\nइनपुट एक जोड़े की सूची है, जहाँ प्रत्येक जोड़ा एक पुस्तक आईडी (Int) और अद्वितीय अपरकेस अक्षरों की एक स्ट्रिंग से बना होता है जो लेखकों का प्रतिनिधित्व करता है।\nफ़ंक्शन एक जोड़ा लौटाता है जिसमें सबसे अधिक प्रकाशित लेखक का प्रारंभिक अक्षर (Char) और उन पुस्तकों के आईडी की सूची (List<Int>) होती है जिनमें उन्होंने योगदान दिया है।\nउदाहरण:\n\n>>> findMostPublishedAuthor(listOf(Pair(410, \"GPKCV\"), Pair(567, \"SPIM\"), Pair(822, \"YSHDLPM\")))\nPair('P', listOf(410, 567, 822))",
      "hu": "Írj egy Kotlin függvényt `fun findMostPublishedAuthor(books: List<Pair<Int, String>>): Pair<Char, List<Int>>` a következő probléma megoldására:\nTaláld meg azt a szerzőt, aki a legtöbb könyvet publikálta, és add vissza a szerző kezdőbetűjét, valamint azoknak a könyveknek az azonosítóit, amelyekhez hozzájárult.\nA bemenet egy párokból álló lista, ahol minden pár egy könyvazonosítóból (Int) és egy egyedi nagybetűkből álló karakterláncból áll, amely a szerzőket képviseli.\nA függvény visszaad egy párt a legtöbbet publikáló szerző kezdőbetűjével (Char) és azoknak a könyveknek az azonosítóival (List<Int>), amelyekhez hozzájárult.\nPélda:\n\n>>> findMostPublishedAuthor(listOf(Pair(410, \"GPKCV\"), Pair(567, \"SPIM\"), Pair(822, \"YSHDLPM\")))\nPair('P', listOf(410, 567, 822))"
    },
    "instruction_bertscore": {
      "sq": "0.9788975083188535",
      "hy": "0.983762562241541",
      "bn": "0.9724688360366593",
      "bg": "0.9774628010766385",
      "zh": "0.9710293616652995",
      "fr": "0.8771846504719373",
      "de": "0.9798159752007588",
      "ha": "0.9734427207948734",
      "hi": "0.9652231969972687",
      "hu": "0.9680010428760416"
    },
    "level": "hard",
    "test": "fun main() {\n    check(findMostPublishedAuthor(listOf(Pair(307, \"F\"), Pair(895, \"HF\"))) == Pair('F', listOf(307,895)))\n    check(findMostPublishedAuthor(listOf(Pair(307, \"F\"), Pair(895, \"H\"), Pair(410, \"GPKCV\"), Pair(567, \"SPIM\"), Pair(822, \"YSHDLPM\"), Pair(834, \"BXPRD\"), Pair(872, \"LJU\"), Pair(791, \"BPJWIA\"), Pair(580, \"AGMVY\"), Pair(619, \"NAFL\"), Pair(233, \"PDJWXK\"))) == Pair('P', listOf(410,567,822,834,791,233)))\n\n \n}\nmain()",
    "entry_point": "findMostPublishedAuthor",
    "signature": "fun findMostPublishedAuthor(books: List<Pair<Int, String>>): Pair<Char, List<Int>>",
    "docstring": {
      "en": "Find the author who has published the most books and return the author's initial along with the IDs of books they've contributed to.\nThe input is a list of pairs, where each pair consists of a book ID (Int) and a string of unique uppercase letters representing authors.\nThe function returns a pair with the most published author's initial (Char) and a list of book IDs (List<Int>) they've contributed to.\nExample:\n\n>>> findMostPublishedAuthor(listOf(Pair(410, \"GPKCV\"), Pair(567, \"SPIM\"), Pair(822, \"YSHDLPM\")))\nPair('P', listOf(410, 567, 822))",
      "sq": "Gjeni autorin që ka botuar më shumë libra dhe ktheni inicialin e autorit së bashku me ID-të e librave ku ata kanë kontribuar.\nHyrja është një listë çiftesh, ku çdo çift përbëhet nga një ID libri (Int) dhe një varg shkronjash unike me shkronja të mëdha që përfaqësojnë autorët.\nFunksioni kthen një çift me inicialin e autorit më të botuar (Char) dhe një listë ID-sh librash (List<Int>) ku ata kanë kontribuar.\nShembull:\n\n>>> findMostPublishedAuthor(listOf(Pair(410, \"GPKCV\"), Pair(567, \"SPIM\"), Pair(822, \"YSHDLPM\")))\nPair('P', listOf(410, 567, 822))",
      "hy": "Գտնել այն հեղինակին, ով հրատարակել է ամենաշատ գրքերը և վերադարձնել հեղինակի սկզբնատառը և այն գրքերի ID-ները, որոնց նրանք մասնակցել են:\nՄուտքը զույգերի ցուցակ է, որտեղ յուրաքանչյուր զույգ բաղկացած է գրքի ID-ից (Int) և հեղինակներին ներկայացնող եզակի մեծատառերի տողից:\nՖունկցիան վերադարձնում է զույգ՝ ամենաշատ հրատարակված հեղինակի սկզբնատառով (Char) և այն գրքերի ID-ների ցուցակով (List<Int>), որոնց նրանք մասնակցել են:\nՕրինակ:\n\n>>> findMostPublishedAuthor(listOf(Pair(410, \"GPKCV\"), Pair(567, \"SPIM\"), Pair(822, \"YSHDLPM\")))\nPair('P', listOf(410, 567, 822))",
      "bn": "সর্বাধিক বই প্রকাশিত হয়েছে এমন লেখককে খুঁজুন এবং লেখকের প্রাথমিক অক্ষর সহ তাদের অবদান রাখা বইয়ের আইডিগুলি ফেরত দিন।\nইনপুট হল একটি জোড়ার তালিকা, যেখানে প্রতিটি জোড়া একটি বইয়ের আইডি (Int) এবং লেখকদের প্রতিনিধিত্বকারী অনন্য বড় হাতের অক্ষরের একটি স্ট্রিং নিয়ে গঠিত।\nফাংশনটি সর্বাধিক প্রকাশিত লেখকের প্রাথমিক (Char) এবং তারা যে বইগুলিতে অবদান রেখেছেন সেই বইয়ের আইডির একটি তালিকা (List<Int>) সহ একটি জোড়া ফেরত দেয়।\nউদাহরণ:\n\n>>> findMostPublishedAuthor(listOf(Pair(410, \"GPKCV\"), Pair(567, \"SPIM\"), Pair(822, \"YSHDLPM\")))\nPair('P', listOf(410, 567, 822))",
      "bg": "Намерете автора, който е публикувал най-много книги и върнете инициалите на автора заедно с идентификаторите на книгите, към които е допринесъл.\nВходът е списък от двойки, където всяка двойка се състои от идентификатор на книга (Int) и низ от уникални главни букви, представляващи автори.\nФункцията връща двойка с инициалите на автора с най-много публикации (Char) и списък от идентификатори на книги (List<Int>), към които е допринесъл.\nПример:\n\n>>> findMostPublishedAuthor(listOf(Pair(410, \"GPKCV\"), Pair(567, \"SPIM\"), Pair(822, \"YSHDLPM\")))\nPair('P', listOf(410, 567, 822))",
      "zh": "找到出版最多书籍的作者，并返回作者的首字母以及他们参与的书籍ID。\n输入是一个对的列表，其中每对由一本书的ID（整数）和一个表示作者的唯一大写字母字符串组成。\n函数返回一个对，其中包含出版最多书籍的作者的首字母（字符）和他们参与的书籍ID列表（列表<整数>）。\n示例：\n\n>>> findMostPublishedAuthor(listOf(Pair(410, \"GPKCV\"), Pair(567, \"SPIM\"), Pair(822, \"YSHDLPM\")))\nPair('P', listOf(410, 567, 822))",
      "fr": "Trouver l'auteur qui a publié le plus de livres et retourner l'initiale de l'auteur ainsi que les IDs des livres auxquels il a contribué.  \nL'entrée est une liste de paires, où chaque paire se compose d'un ID de livre (Int) et d'une chaîne de lettres majuscules uniques représentant les auteurs.  \nLa fonction retourne une paire avec l'initiale de l'auteur le plus publié (Char) et une liste des IDs de livres (List<Int>) auxquels il a contribué.  \nExemple :\n\n>>> findMostPublishedAuthor(listOf(Pair(410, \"GPKCV\"), Pair(567, \"SPIM\"), Pair(822, \"YSHDLPM\")))  \nPair('P', listOf(410, 567, 822))",
      "de": "Finde den Autor, der die meisten Bücher veröffentlicht hat, und gib das Initial des Autors zusammen mit den IDs der Bücher zurück, zu denen er beigetragen hat. Die Eingabe ist eine Liste von Paaren, wobei jedes Paar aus einer Buch-ID (Int) und einer Zeichenkette aus einzigartigen Großbuchstaben besteht, die Autoren darstellen. Die Funktion gibt ein Paar mit dem Initial (Char) des am meisten veröffentlichten Autors und einer Liste von Buch-IDs (List<Int>) zurück, zu denen er beigetragen hat. Beispiel:\n\n>>> findMostPublishedAuthor(listOf(Pair(410, \"GPKCV\"), Pair(567, \"SPIM\"), Pair(822, \"YSHDLPM\")))\nPair('P', listOf(410, 567, 822))",
      "ha": "Nemo marubucin da ya fi wallafa mafi yawan littattafai kuma dawo da farkon sunan marubucin tare da lambobin ID na littattafan da suka ba da gudummawa a kai.\nShigarwa jerin ma'aurata ne, inda kowace ma'aurata ta ƙunshi ID na littafi (Int) da igiyar haruffa na musamman masu manyan baƙaƙe suna wakiltar marubuta.\nAikin yana dawo da ma'aurata tare da farkon sunan marubucin da ya fi wallafa (Char) da jerin IDs na littattafai (List<Int>) da suka ba da gudummawa a kai.\nMisali:\n\n>>> findMostPublishedAuthor(listOf(Pair(410, \"GPKCV\"), Pair(567, \"SPIM\"), Pair(822, \"YSHDLPM\")))\nPair('P', listOf(410, 567, 822))",
      "hi": "उस लेखक को खोजें जिसने सबसे अधिक पुस्तकें प्रकाशित की हैं और लेखक के प्रारंभिक अक्षर के साथ उन पुस्तकों के IDs लौटाएं जिनमें उन्होंने योगदान दिया है।\nइनपुट एक जोड़ों की सूची है, जहाँ प्रत्येक जोड़ा एक पुस्तक आईडी (Int) और अद्वितीय अपरकेस अक्षरों की एक स्ट्रिंग होती है जो लेखकों का प्रतिनिधित्व करती है।\nयह फ़ंक्शन सबसे अधिक प्रकाशित लेखक के प्रारंभिक (Char) और पुस्तक आईडी की एक सूची (List<Int>) लौटाता है जिनमें उन्होंने योगदान दिया है।\nउदाहरण:\n\n>>> findMostPublishedAuthor(listOf(Pair(410, \"GPKCV\"), Pair(567, \"SPIM\"), Pair(822, \"YSHDLPM\")))\nPair('P', listOf(410, 567, 822))",
      "hu": "Találd meg azt a szerzőt, aki a legtöbb könyvet publikálta, és add vissza a szerző kezdőbetűjét, valamint azoknak a könyveknek az azonosítóit, amelyekhez hozzájárult.\nA bemenet egy párokból álló lista, ahol minden pár egy könyvazonosítóból (Int) és egy egyedi nagybetűs betűkből álló karakterláncból áll, amely a szerzőket jelöli.\nA függvény visszaad egy párt a legtöbbet publikáló szerző kezdőbetűjével (Char) és egy listát a könyvazonosítókkal (List<Int>), amelyekhez hozzájárult.\nPélda:\n\n>>> findMostPublishedAuthor(listOf(Pair(410, \"GPKCV\"), Pair(567, \"SPIM\"), Pair(822, \"YSHDLPM\")))\nPair('P', listOf(410, 567, 822))"
    },
    "docstring_bertscore": {
      "sq": "0.9827650404679837",
      "hy": "0.9814638128418243",
      "bn": "0.977579993001449",
      "bg": "0.9585756340351741",
      "zh": "0.945167686054557",
      "fr": "0.9827954309162821",
      "de": "0.9851990571571853",
      "ha": "0.9745665714907688",
      "hi": "0.9802617017758011",
      "hu": "0.9818259160264509"
    }
  },
  {
    "task_id": "Kotlin/41",
    "prompt": {
      "en": "/**\n * Counts the number of pairs of students who are considered \"equal competitors\".\n * Two students are considered equal competitors if the difference in their scores for each subject (Math, English, and Chinese)\n * is not greater than 5, and the difference in their total scores is not greater than 10.\n * \n * @param scores A list of triples, each representing the Math, English, and Chinese scores of a student.\n * @return The number of pairs of students who are considered equal competitors.\n * \n * Example:\n * >>> countEqualCompetitors(listOf(Triple(90, 90, 90), Triple(85, 95, 90), Triple(80, 100, 91)))\n *     2\n */\n\nfun countEqualCompetitors(scores: List<Triple<Int, Int, Int>>): Int ",
      "sq": "/**\n * Numëron numrin e çifteve të studentëve që konsiderohen \"konkurrentë të barabartë\".\n * Dy studentë konsiderohen konkurrentë të barabartë nëse diferenca në pikët e tyre për secilin lëndë (Matematikë, Anglisht dhe Kinezisht)\n * nuk është më e madhe se 5, dhe diferenca në pikët e tyre totale nuk është më e madhe se 10.\n * \n * @param scores Një listë treshe, secila që përfaqëson pikët në Matematikë, Anglisht dhe Kinezisht të një studenti.\n * @return Numri i çifteve të studentëve që konsiderohen konkurrentë të barabartë.\n * \n * Shembull:\n * >>> countEqualCompetitors(listOf(Triple(90, 90, 90), Triple(85, 95, 90), Triple(80, 100, 91)))\n *     2\n */",
      "hy": "/**\n * Հաշվում է ուսանողների զույգերի քանակը, ովքեր համարվում են \"հավասար մրցակիցներ\":\n * Երկու ուսանող համարվում են հավասար մրցակիցներ, եթե նրանց միավորների տարբերությունը յուրաքանչյուր առարկայի (Մաթեմատիկա, Անգլերեն և Չինարեն)\n * համար չի գերազանցում 5-ը, և նրանց ընդհանուր միավորների տարբերությունը չի գերազանցում 10-ը:\n * \n * @param scores Երեքյակների ցուցակ, որոնցից յուրաքանչյուրը ներկայացնում է ուսանողի Մաթեմատիկայի, Անգլերենի և Չինարենի միավորները:\n * @return Ուսանողների զույգերի քանակը, ովքեր համարվում են հավասար մրցակիցներ:\n * \n * Օրինակ:\n * >>> countEqualCompetitors(listOf(Triple(90, 90, 90), Triple(85, 95, 90), Triple(80, 100, 91)))\n *     2\n */",
      "bn": "/**\n * \"সমান প্রতিযোগী\" হিসেবে বিবেচিত ছাত্রদের জোড়ার সংখ্যা গণনা করে।\n * দুটি ছাত্রকে সমান প্রতিযোগী হিসেবে বিবেচনা করা হয় যদি তাদের প্রতিটি বিষয়ের (গণিত, ইংরেজি এবং চীনা) স্কোরের মধ্যে পার্থক্য 5 এর বেশি না হয়,\n * এবং তাদের মোট স্কোরের মধ্যে পার্থক্য 10 এর বেশি না হয়।\n * \n * @param scores একটি ট্রিপলগুলির তালিকা, প্রতিটি ছাত্রের গণিত, ইংরেজি এবং চীনা স্কোর উপস্থাপন করে।\n * @return সমান প্রতিযোগী হিসেবে বিবেচিত ছাত্রদের জোড়ার সংখ্যা।\n * \n * উদাহরণ:\n * >>> countEqualCompetitors(listOf(Triple(90, 90, 90), Triple(85, 95, 90), Triple(80, 100, 91)))\n *     2\n */",
      "bg": "/**\n * Брои броя на двойките ученици, които се считат за \"равни съперници\".\n * Двама ученици се считат за равни съперници, ако разликата в техните оценки за всеки предмет (Математика, Английски и Китайски)\n * не е по-голяма от 5, и разликата в техните общи оценки не е по-голяма от 10.\n * \n * @param scores Списък от тройки, всяка представляваща оценките по Математика, Английски и Китайски на ученик.\n * @return Броят на двойките ученици, които се считат за равни съперници.\n * \n * Пример:\n * >>> countEqualCompetitors(listOf(Triple(90, 90, 90), Triple(85, 95, 90), Triple(80, 100, 91)))\n *     2\n */",
      "zh": "/**\n * 计算被认为是“平等竞争者”的学生对数。\n * 如果两个学生在每个科目（数学、英语和语文）的分数差不大于5，并且总分差不大于10，则被认为是平等竞争者。\n * \n * @param scores 一个三元组的列表，每个三元组代表一个学生的数学、英语和语文成绩。\n * @return 被认为是平等竞争者的学生对数。\n * \n * 示例:\n * >>> countEqualCompetitors(listOf(Triple(90, 90, 90), Triple(85, 95, 90), Triple(80, 100, 91)))\n *     2\n */",
      "fr": "/**\n * Compte le nombre de paires d'étudiants considérés comme \"concurrents égaux\".\n * Deux étudiants sont considérés comme concurrents égaux si la différence de leurs scores pour chaque matière (Mathématiques, Anglais et Chinois)\n * n'est pas supérieure à 5, et si la différence de leurs scores totaux n'est pas supérieure à 10.\n * \n * @param scores Une liste de triplets, chacun représentant les scores en Mathématiques, Anglais et Chinois d'un étudiant.\n * @return Le nombre de paires d'étudiants considérés comme concurrents égaux.\n * \n * Exemple:\n * >>> countEqualCompetitors(listOf(Triple(90, 90, 90), Triple(85, 95, 90), Triple(80, 100, 91)))\n *     2\n */",
      "de": "/**\n * Zählt die Anzahl der Paare von Schülern, die als \"gleichwertige Konkurrenten\" gelten.\n * Zwei Schüler gelten als gleichwertige Konkurrenten, wenn der Unterschied in ihren Punktzahlen für jedes Fach (Mathematik, Englisch und Chinesisch)\n * nicht größer als 5 ist und der Unterschied in ihren Gesamtpunktzahlen nicht größer als 10 ist.\n * \n * @param scores Eine Liste von Tripeln, die jeweils die Mathematik-, Englisch- und Chinesisch-Punktzahlen eines Schülers darstellen.\n * @return Die Anzahl der Paare von Schülern, die als gleichwertige Konkurrenten gelten.\n * \n * Beispiel:\n * >>> countEqualCompetitors(listOf(Triple(90, 90, 90), Triple(85, 95, 90), Triple(80, 100, 91)))\n *     2\n */",
      "ha": "/**\n * Yana ƙidaya adadin ma'aurata na ɗalibai waɗanda ake ɗauka \"kama da juna masu fafatawa\".\n * Ana ɗaukar ɗalibai biyu a matsayin kama da juna masu fafatawa idan bambancin maki a kowanne fanni (Lissafi, Turanci, da Sinanci)\n * bai wuce 5 ba, kuma bambancin jimillar maki bai wuce 10 ba.\n * \n * @param scores Jerin na uku-uku, kowanne yana wakiltar maki na Lissafi, Turanci, da Sinanci na ɗalibi.\n * @return Adadin ma'aurata na ɗalibai waɗanda ake ɗauka kama da juna masu fafatawa.\n * \n * Misali:\n * >>> countEqualCompetitors(listOf(Triple(90, 90, 90), Triple(85, 95, 90), Triple(80, 100, 91)))\n *     2\n */",
      "hi": "/**\n * उन छात्रों की जोड़ी की संख्या गिनता है जिन्हें \"समान प्रतियोगी\" माना जाता है।\n * दो छात्रों को समान प्रतियोगी माना जाता है यदि उनके प्रत्येक विषय (गणित, अंग्रेजी, और चीनी) के अंकों में अंतर 5 से अधिक नहीं है,\n * और उनके कुल अंकों में अंतर 10 से अधिक नहीं है।\n * \n * @param scores तीनों का एक सूची, प्रत्येक छात्र के गणित, अंग्रेजी, और चीनी अंकों का प्रतिनिधित्व करता है।\n * @return उन छात्रों की जोड़ी की संख्या जो समान प्रतियोगी माने जाते हैं।\n * \n * उदाहरण:\n * >>> countEqualCompetitors(listOf(Triple(90, 90, 90), Triple(85, 95, 90), Triple(80, 100, 91)))\n *     2\n */",
      "hu": "/**\n * Megszámolja azon diákpárok számát, akiket \"egyenlő versenytársaknak\" tekintünk.\n * Két diákot akkor tekintünk egyenlő versenytársnak, ha az egyes tantárgyakban (Matematika, Angol, Kínai)\n * elért pontszámaik közötti különbség nem nagyobb, mint 5, és az összpontszámuk közötti különbség nem nagyobb, mint 10.\n * \n * @param scores Hármasok listája, amelyek mindegyike egy diák Matematika, Angol és Kínai pontszámát képviseli.\n * @return Azon diákpárok száma, akiket egyenlő versenytársaknak tekintünk.\n * \n * Példa:\n * >>> countEqualCompetitors(listOf(Triple(90, 90, 90), Triple(85, 95, 90), Triple(80, 100, 91)))\n *     2\n */"
    },
    "prompt_bertscore": {
      "sq": "0.9490507113734081",
      "hy": "0.9428719161105558",
      "bn": "0.9385187326797952",
      "bg": "0.9484921627419379",
      "zh": "0.9194645174878805",
      "fr": "0.9427658474870831",
      "de": "0.9525660718569635",
      "ha": "0.9434237113090708",
      "hi": "0.9343260425969108",
      "hu": "0.932044772670725"
    },
    "canonical_solution": "{\n    var count = 0\n    for (i in scores.indices) {\n        for (j in i + 1 until scores.size) {\n            val (mathI, englishI, chineseI) = scores[i]\n            val (mathJ, englishJ, chineseJ) = scores[j]\n            val totalDiff = Math.abs((mathI + englishI + chineseI) - (mathJ + englishJ + chineseJ))\n            if (Math.abs(mathI - mathJ) <= 5 &&\n                Math.abs(englishI - englishJ) <= 5 &&\n                Math.abs(chineseI - chineseJ) <= 5 &&\n                totalDiff <= 10) {\n                count++\n            }\n        }\n    }\n    return count\n}",
    "instruction": {
      "en": "Write a Kotlin function `fun countEqualCompetitors(scores: List<Triple<Int, Int, Int>>): Int` to solve the following problem:\nCounts the number of pairs of students who are considered \"equal competitors\".\n  Two students are considered equal competitors if the difference in their scores for each subject (Math, English, and Chinese)\n  is not greater than 5, and the difference in their total scores is not greater than 10.\n  \n  @param scores A list of triples, each representing the Math, English, and Chinese scores of a student.\n  @return The number of pairs of students who are considered equal competitors.\n  \n  Example:\n  >>> countEqualCompetitors(listOf(Triple(90, 90, 90), Triple(85, 95, 90), Triple(80, 100, 91)))\n      2",
      "sq": "Shkruani një funksion Kotlin `fun countEqualCompetitors(scores: List<Triple<Int, Int, Int>>): Int` për të zgjidhur problemin e mëposhtëm:\nNumëroni numrin e çifteve të studentëve që konsiderohen \"konkurrentë të barabartë\".\n  Dy studentë konsiderohen konkurrentë të barabartë nëse diferenca në notat e tyre për secilin lëndë (Matematikë, Anglisht dhe Kinezisht)\n  nuk është më e madhe se 5, dhe diferenca në totalin e notave të tyre nuk është më e madhe se 10.\n  \n  @param scores Një listë treshe, secila që përfaqëson notat e Matematikës, Anglishtes dhe Kinezishtes të një studenti.\n  @return Numri i çifteve të studentëve që konsiderohen konkurrentë të barabartë.\n  \n  Shembull:\n  >>> countEqualCompetitors(listOf(Triple(90, 90, 90), Triple(85, 95, 90), Triple(80, 100, 91)))\n      2",
      "hy": "Գրեք Kotlin ֆունկցիա `fun countEqualCompetitors(scores: List<Triple<Int, Int, Int>>): Int` հետևյալ խնդիրը լուծելու համար:\nՀաշվում է այն զույգ ուսանողների քանակը, որոնք համարվում են \"հավասար մրցակիցներ\":\n  Երկու ուսանող համարվում են հավասար մրցակիցներ, եթե նրանց միավորների տարբերությունը յուրաքանչյուր առարկայի համար (Մաթեմատիկա, Անգլերեն և Չինարեն)\n  չի գերազանցում 5-ը, իսկ ընդհանուր միավորների տարբերությունը չի գերազանցում 10-ը:\n  \n  @param scores Երեքյակների ցուցակ, որոնցից յուրաքանչյուրը ներկայացնում է ուսանողի Մաթեմատիկայի, Անգլերենի և Չինարենի միավորները:\n  @return Զույգ ուսանողների քանակը, որոնք համարվում են հավասար մրցակիցներ:\n  \n  Օրինակ:\n  >>> countEqualCompetitors(listOf(Triple(90, 90, 90), Triple(85, 95, 90), Triple(80, 100, 91)))\n      2",
      "bn": "একটি Kotlin ফাংশন `fun countEqualCompetitors(scores: List<Triple<Int, Int, Int>>): Int` লিখুন নিম্নলিখিত সমস্যার সমাধানের জন্য:\nযে সংখ্যক ছাত্র জোড়া \"সমান প্রতিযোগী\" হিসাবে বিবেচিত হয় তা গণনা করে।\n  দুটি ছাত্রকে সমান প্রতিযোগী হিসাবে বিবেচনা করা হয় যদি তাদের প্রতিটি বিষয়ের (গণিত, ইংরেজি এবং চীনা) স্কোরের পার্থক্য 5 এর বেশি না হয়, এবং তাদের মোট স্কোরের পার্থক্য 10 এর বেশি না হয়।\n\n  @param scores একটি ট্রিপল-এর তালিকা, প্রতিটি একটি ছাত্রের গণিত, ইংরেজি এবং চীনা স্কোর উপস্থাপন করে।\n  @return যে সংখ্যক ছাত্র জোড়া সমান প্রতিযোগী হিসাবে বিবেচিত হয়।\n\n  উদাহরণ:\n  >>> countEqualCompetitors(listOf(Triple(90, 90, 90), Triple(85, 95, 90), Triple(80, 100, 91)))\n      2",
      "bg": "Напишете Kotlin функция `fun countEqualCompetitors(scores: List<Triple<Int, Int, Int>>): Int`, за да решите следния проблем:\nБрои броя на двойките ученици, които се считат за \"равни конкуренти\".\n  Двама ученици се считат за равни конкуренти, ако разликата в техните оценки по всеки предмет (Математика, Английски и Китайски)\n  не е по-голяма от 5, и разликата в техните общи оценки не е по-голяма от 10.\n  \n  @param scores Списък от тройки, всяка представляваща оценките по Математика, Английски и Китайски на ученик.\n  @return Броят на двойките ученици, които се считат за равни конкуренти.\n  \n  Пример:\n  >>> countEqualCompetitors(listOf(Triple(90, 90, 90), Triple(85, 95, 90), Triple(80, 100, 91)))\n      2",
      "zh": "编写一个 Kotlin 函数 `fun countEqualCompetitors(scores: List<Triple<Int, Int, Int>>): Int` 来解决以下问题：\n计算被认为是“平等竞争者”的学生对的数量。\n如果两名学生在每个科目（数学、英语和语文）的分数差不大于 5，并且总分差不大于 10，则认为他们是平等竞争者。\n\n@param scores 一个三元组的列表，每个三元组代表一名学生的数学、英语和语文成绩。\n@return 被认为是平等竞争者的学生对的数量。\n\n示例：\n>>> countEqualCompetitors(listOf(Triple(90, 90, 90), Triple(85, 95, 90), Triple(80, 100, 91)))\n    2",
      "fr": "Écrire une fonction Kotlin `fun countEqualCompetitors(scores: List<Triple<Int, Int, Int>>): Int` pour résoudre le problème suivant :\nCompte le nombre de paires d'étudiants qui sont considérés comme \"concurrents égaux\".\n  Deux étudiants sont considérés comme des concurrents égaux si la différence de leurs scores pour chaque matière (Mathématiques, Anglais et Chinois)\n  n'est pas supérieure à 5, et si la différence de leurs scores totaux n'est pas supérieure à 10.\n  \n  @param scores Une liste de triplets, chacun représentant les scores en Mathématiques, Anglais et Chinois d'un étudiant.\n  @return Le nombre de paires d'étudiants qui sont considérés comme des concurrents égaux.\n  \n  Exemple :\n  >>> countEqualCompetitors(listOf(Triple(90, 90, 90), Triple(85, 95, 90), Triple(80, 100, 91)))\n      2",
      "de": "Schreiben Sie eine Kotlin-Funktion `fun countEqualCompetitors(scores: List<Triple<Int, Int, Int>>): Int`, um das folgende Problem zu lösen:\nZählt die Anzahl der Paare von Schülern, die als \"gleichwertige Konkurrenten\" gelten.\n  Zwei Schüler gelten als gleichwertige Konkurrenten, wenn der Unterschied in ihren Punktzahlen für jedes Fach (Mathematik, Englisch und Chinesisch)\n  nicht größer als 5 ist und der Unterschied in ihren Gesamtpunktzahlen nicht größer als 10 ist.\n  \n  @param scores Eine Liste von Tripeln, die jeweils die Mathematik-, Englisch- und Chinesisch-Punktzahlen eines Schülers darstellen.\n  @return Die Anzahl der Paare von Schülern, die als gleichwertige Konkurrenten gelten.\n  \n  Beispiel:\n  >>> countEqualCompetitors(listOf(Triple(90, 90, 90), Triple(85, 95, 90), Triple(80, 100, 91)))\n      2",
      "ha": "Rubuta wani aikin Kotlin `fun countEqualCompetitors(scores: List<Triple<Int, Int, Int>>): Int` don warware matsalar mai zuwa:\nYana ƙidaya adadin ma'aurata na ɗalibai waɗanda ake ɗauka \"gasa iri ɗaya\".\n  Ana ɗaukar ɗalibai biyu a matsayin masu gasa iri ɗaya idan bambancin maki a kowace darasi (Lissafi, Turanci, da Sinanci)\n  bai fi 5 ba, kuma bambancin jimillar maki bai fi 10 ba.\n  \n  @param scores Jerin triples ne, kowanne yana wakiltar maki na Lissafi, Turanci, da Sinanci na ɗalibi.\n  @return Adadin ma'aurata na ɗalibai waɗanda ake ɗauka a matsayin masu gasa iri ɗaya.\n  \n  Misali:\n  >>> countEqualCompetitors(listOf(Triple(90, 90, 90), Triple(85, 95, 90), Triple(80, 100, 91)))\n      2",
      "hi": "Kotlin फ़ंक्शन `fun countEqualCompetitors(scores: List<Triple<Int, Int, Int>>): Int` लिखें ताकि निम्नलिखित समस्या का समाधान किया जा सके:\nउन छात्रों की जोड़ी की संख्या गिनें जिन्हें \"समान प्रतियोगी\" माना जाता है।\n  दो छात्रों को समान प्रतियोगी माना जाता है यदि उनके प्रत्येक विषय (गणित, अंग्रेजी, और चीनी) के अंकों में अंतर 5 से अधिक नहीं है, और उनके कुल अंकों में अंतर 10 से अधिक नहीं है।\n\n  @param scores त्रिकों की एक सूची, प्रत्येक एक छात्र के गणित, अंग्रेजी, और चीनी अंकों का प्रतिनिधित्व करता है।\n  @return उन छात्रों की जोड़ी की संख्या जो समान प्रतियोगी माने जाते हैं।\n\n  उदाहरण:\n  >>> countEqualCompetitors(listOf(Triple(90, 90, 90), Triple(85, 95, 90), Triple(80, 100, 91)))\n      2",
      "hu": "Írj egy Kotlin függvényt `fun countEqualCompetitors(scores: List<Triple<Int, Int, Int>>): Int` a következő probléma megoldására:\nSzámolja meg azon diákpárok számát, akiket \"egyenlő versenytársaknak\" tekintünk.\n  Két diákot akkor tekintünk egyenlő versenytársaknak, ha a pontszámuk közötti különbség minden tantárgyban (matek, angol és kínai)\n  nem nagyobb, mint 5, és az összpontszámuk közötti különbség nem nagyobb, mint 10.\n  \n  @param scores Egy hármasok listája, amelyek mindegyike egy diák matek, angol és kínai pontszámát képviseli.\n  @return Azon diákpárok száma, akiket egyenlő versenytársaknak tekintünk.\n  \n  Példa:\n  >>> countEqualCompetitors(listOf(Triple(90, 90, 90), Triple(85, 95, 90), Triple(80, 100, 91)))\n      2"
    },
    "instruction_bertscore": {
      "sq": "0.9904945431155754",
      "hy": "0.9845014672589908",
      "bn": "0.9799393246673814",
      "bg": "0.9881469306421241",
      "zh": "0.9602737251626413",
      "fr": "0.9838898843157844",
      "de": "0.9839878090936346",
      "ha": "0.9820537450734979",
      "hi": "0.9687333930909172",
      "hu": "0.9748889485991884"
    },
    "level": "hard",
    "test": "fun main() {\n    check(countEqualCompetitors(listOf(Triple(90, 90, 90), Triple(85, 95, 90), Triple(80, 100, 91))) == 2)\n    check(countEqualCompetitors(listOf(Triple(100, 100, 100), Triple(92, 93, 95), Triple(101, 102, 103))) == 1)\n    check(countEqualCompetitors(listOf(Triple(90, 91, 92), Triple(86, 87, 88), Triple(93, 94, 95))) == 1)\n    check(countEqualCompetitors(listOf(Triple(100, 100, 100), Triple(105, 105, 105), Triple(100, 100, 100))) == 1)\n}\n\n\nmain()",
    "entry_point": "countEqualCompetitors",
    "signature": "fun countEqualCompetitors(scores: List<Triple<Int, Int, Int>>): Int",
    "docstring": {
      "en": "Counts the number of pairs of students who are considered \"equal competitors\".\n  Two students are considered equal competitors if the difference in their scores for each subject (Math, English, and Chinese)\n  is not greater than 5, and the difference in their total scores is not greater than 10.\n  \n  @param scores A list of triples, each representing the Math, English, and Chinese scores of a student.\n  @return The number of pairs of students who are considered equal competitors.\n  \n  Example:\n  >>> countEqualCompetitors(listOf(Triple(90, 90, 90), Triple(85, 95, 90), Triple(80, 100, 91)))\n      2",
      "sq": "Numëron numrin e çifteve të studentëve që konsiderohen \"konkurrentë të barabartë\".\nDy studentë konsiderohen konkurrentë të barabartë nëse diferenca në pikët e tyre për secilin lëndë (Matematikë, Anglisht dhe Kinezisht)\nnuk është më e madhe se 5, dhe diferenca në pikët e tyre totale nuk është më e madhe se 10.\n\n@param scores Një listë treshe, secila që përfaqëson pikët e Matematikës, Anglishtes dhe Kinezishtes të një studenti.\n@return Numri i çifteve të studentëve që konsiderohen konkurrentë të barabartë.\n\nShembull:\n>>> countEqualCompetitors(listOf(Triple(90, 90, 90), Triple(85, 95, 90), Triple(80, 100, 91)))\n    2",
      "hy": "Հաշվում է ուսանողների զույգերի քանակը, ովքեր համարվում են \"հավասար մրցակիցներ\":\n  Երկու ուսանող համարվում են հավասար մրցակիցներ, եթե նրանց միավորների տարբերությունը յուրաքանչյուր առարկայի (Մաթեմատիկա, Անգլերեն և Չինարեն)\n  համար չի գերազանցում 5-ը, և նրանց ընդհանուր միավորների տարբերությունը չի գերազանցում 10-ը:\n  \n  @param scores Երեքյակների ցուցակ, որոնցից յուրաքանչյուրը ներկայացնում է ուսանողի Մաթեմատիկայի, Անգլերենի և Չինարենի միավորները:\n  @return Ուսանողների զույգերի քանակը, ովքեր համարվում են հավասար մրցակիցներ:\n  \n  Օրինակ:\n  >>> countEqualCompetitors(listOf(Triple(90, 90, 90), Triple(85, 95, 90), Triple(80, 100, 91)))\n      2",
      "bn": "সমান প্রতিযোগী হিসাবে বিবেচিত শিক্ষার্থীদের জোড়ার সংখ্যা গণনা করে।\n  দুটি শিক্ষার্থীকে সমান প্রতিযোগী হিসাবে বিবেচনা করা হয় যদি তাদের প্রতিটি বিষয়ের (গণিত, ইংরেজি এবং চীনা) স্কোরের পার্থক্য ৫ এর বেশি না হয় এবং তাদের মোট স্কোরের পার্থক্য ১০ এর বেশি না হয়।\n\n  @param scores একটি ত্রয়ীর তালিকা, প্রতিটি শিক্ষার্থীর গণিত, ইংরেজি এবং চীনা স্কোর উপস্থাপন করে।\n  @return শিক্ষার্থীদের জোড়ার সংখ্যা যারা সমান প্রতিযোগী হিসাবে বিবেচিত হয়।\n\n  উদাহরণ:\n  >>> countEqualCompetitors(listOf(Triple(90, 90, 90), Triple(85, 95, 90), Triple(80, 100, 91)))\n      2",
      "bg": "Брои броя на двойките ученици, които се считат за \"равни състезатели\".\n  Двама ученици се считат за равни състезатели, ако разликата в техните оценки по всеки предмет (Математика, Английски и Китайски)\n  не е по-голяма от 5, и разликата в техните общи оценки не е по-голяма от 10.\n  \n  @param scores Списък от тройки, всяка представляваща оценките по Математика, Английски и Китайски на ученик.\n  @return Броят на двойките ученици, които се считат за равни състезатели.\n  \n  Пример:\n  >>> countEqualCompetitors(listOf(Triple(90, 90, 90), Triple(85, 95, 90), Triple(80, 100, 91)))\n      2",
      "zh": "计算被认为是“平等竞争者”的学生对数。\n两个学生被认为是平等竞争者，如果他们在每个科目（数学、英语和语文）上的分数差不大于5，并且他们的总分差不大于10。\n\n@param scores 一个三元组的列表，每个三元组代表一个学生的数学、英语和语文成绩。\n@return 被认为是平等竞争者的学生对数。\n\n例子：\n>>> countEqualCompetitors(listOf(Triple(90, 90, 90), Triple(85, 95, 90), Triple(80, 100, 91)))\n    2",
      "fr": "Compte le nombre de paires d'étudiants qui sont considérés comme \"compétiteurs égaux\".\n  Deux étudiants sont considérés comme compétiteurs égaux si la différence de leurs scores pour chaque matière (Mathématiques, Anglais et Chinois)\n  n'est pas supérieure à 5, et si la différence de leurs scores totaux n'est pas supérieure à 10.\n  \n  @param scores Une liste de triplets, chacun représentant les scores en Mathématiques, Anglais et Chinois d'un étudiant.\n  @return Le nombre de paires d'étudiants qui sont considérés comme compétiteurs égaux.\n  \n  Exemple :\n  >>> countEqualCompetitors(listOf(Triple(90, 90, 90), Triple(85, 95, 90), Triple(80, 100, 91)))\n      2",
      "de": "Zählt die Anzahl der Paare von Schülern, die als \"gleichwertige Konkurrenten\" gelten.\n  Zwei Schüler gelten als gleichwertige Konkurrenten, wenn der Unterschied in ihren Punktzahlen für jedes Fach (Mathematik, Englisch und Chinesisch)\n  nicht größer als 5 ist und der Unterschied in ihren Gesamtpunktzahlen nicht größer als 10 ist.\n  \n  @param scores Eine Liste von Tripeln, die jeweils die Mathematik-, Englisch- und Chinesisch-Punktzahlen eines Schülers darstellen.\n  @return Die Anzahl der Paare von Schülern, die als gleichwertige Konkurrenten gelten.\n  \n  Beispiel:\n  >>> countEqualCompetitors(listOf(Triple(90, 90, 90), Triple(85, 95, 90), Triple(80, 100, 91)))\n      2",
      "ha": "Yana ƙidaya adadin ma'aurata na ɗalibai waɗanda ake ɗauka \"gasa iri ɗaya\".\n  Ana ɗaukar ɗalibai biyu a matsayin masu fafatawa daidai idan bambanci a cikin maki nasu na kowanne fanni (Lissafi, Turanci, da Sinanci)\n  bai fi 5 ba, kuma bambanci a cikin jimillar maki nasu bai fi 10 ba.\n  \n  @param scores Jerin uku-uku, kowanne yana wakiltar maki na Lissafi, Turanci, da Sinanci na ɗalibi.\n  @return Yawan ma'aurata na ɗalibai da ake ɗauka a matsayin masu fafatawa daidai.\n  \n  Misali:\n  >>> countEqualCompetitors(listOf(Triple(90, 90, 90), Triple(85, 95, 90), Triple(80, 100, 91)))\n      2",
      "hi": "समान प्रतिस्पर्धियों के रूप में माने जाने वाले छात्रों की जोड़ों की संख्या की गणना करता है।\n  दो छात्रों को समान प्रतिस्पर्धी माना जाता है यदि उनके प्रत्येक विषय (गणित, अंग्रेजी, और चीनी) के अंकों में अंतर 5 से अधिक नहीं है, और उनके कुल अंकों में अंतर 10 से अधिक नहीं है।\n  \n  @param scores त्रिकों की एक सूची, प्रत्येक छात्र के गणित, अंग्रेजी, और चीनी अंकों का प्रतिनिधित्व करती है।\n  @return उन छात्रों के जोड़ों की संख्या जो समान प्रतिस्पर्धी माने जाते हैं।\n  \n  उदाहरण:\n  >>> countEqualCompetitors(listOf(Triple(90, 90, 90), Triple(85, 95, 90), Triple(80, 100, 91)))\n      2",
      "hu": "Számolja meg azon diákpárok számát, akiket \"egyenlő versenytársaknak\" tekintünk.\n  Két diákot akkor tekintünk egyenlő versenytársnak, ha a pontszámaik közötti különbség minden tantárgyban (matek, angol és kínai)\n  nem nagyobb, mint 5, és az összpontszámuk közötti különbség nem nagyobb, mint 10.\n  \n  @param scores Egy hármasokból álló lista, amelyek mindegyike egy diák matek, angol és kínai pontszámait képviseli.\n  @return Azon diákpárok száma, akiket egyenlő versenytársaknak tekintünk.\n  \n  Példa:\n  >>> countEqualCompetitors(listOf(Triple(90, 90, 90), Triple(85, 95, 90), Triple(80, 100, 91)))\n      2"
    },
    "docstring_bertscore": {
      "sq": "0.9957079947265981",
      "hy": "0.9777470411518994",
      "bn": "0.9718530818554512",
      "bg": "0.984195179211435",
      "zh": "0.936735627749245",
      "fr": "0.9728007474033686",
      "de": "0.9780487607006914",
      "ha": "0.9870429429843322",
      "hi": "0.9666902809915924",
      "hu": "0.968744119131493"
    }
  },
  {
    "task_id": "Kotlin/42",
    "prompt": {
      "en": "/**\n * Calculate the total number of cigarettes Peter can smoke given an initial number of cigarettes and a ratio of cigarette butts to new cigarettes.\n * Peter saves butts from smoked cigarettes and exchanges them for new ones at a given rate.\n * \n * Example:\n * >>> totalCigarettesSmoked(4, 3)\n *     5\n * >>> totalCigarettesSmoked(10, 3)\n *     14\n */\nfun totalCigarettesSmoked(initialCigarettes: Int, buttsForNew: Int): Int ",
      "sq": "/**\n * Llogarit numrin total të cigareve që Pjetri mund të pijë duke pasur një numër fillestar të cigareve dhe një raport të bishtave të cigareve për cigare të reja.\n * Pjetri ruan bishtat nga cigaret e tymosura dhe i shkëmben ato për të reja me një normë të caktuar.\n * \n * Shembull:\n * >>> totalCigarettesSmoked(4, 3)\n *     5\n * >>> totalCigarettesSmoked(10, 3)\n *     14\n */",
      "hy": "/**\n * Հաշվել ընդհանուր ծխախոտների քանակը, որը Պետերը կարող է ծխել տրված սկզբնական ծխախոտների քանակով և ծխախոտի մնացորդների փոխանակման հարաբերակցությամբ:\n * Պետերը պահպանում է ծխված ծխախոտների մնացորդները և փոխանակում է դրանք նորերի հետ տրված հարաբերակցությամբ:\n * \n * Օրինակ:\n * >>> totalCigarettesSmoked(4, 3)\n *     5\n * >>> totalCigarettesSmoked(10, 3)\n *     14\n */",
      "bn": "/**\n * প্রদত্ত প্রাথমিক সিগারেটের সংখ্যা এবং সিগারেটের বাট থেকে নতুন সিগারেটের অনুপাতের ভিত্তিতে পিটার মোট কত সিগারেট খেতে পারে তা গণনা করুন।\n * পিটার ধূমপান করা সিগারেটের বাট সংরক্ষণ করে এবং একটি নির্দিষ্ট হারে সেগুলি নতুন সিগারেটের জন্য বিনিময় করে।\n * \n * উদাহরণ:\n * >>> totalCigarettesSmoked(4, 3)\n *     5\n * >>> totalCigarettesSmoked(10, 3)\n *     14\n */",
      "bg": "/**\n * Изчислява общия брой цигари, които Петър може да изпуши, като се има предвид началния брой цигари и съотношението на фасове към нови цигари.\n * Петър събира фасове от изпушени цигари и ги обменя за нови по даден курс.\n * \n * Пример:\n * >>> totalCigarettesSmoked(4, 3)\n *     5\n * >>> totalCigarettesSmoked(10, 3)\n *     14\n */\nfun totalCigarettesSmoked(initialCigarettes: Int, buttsForNew: Int): Int ",
      "zh": "/**\n * 计算 Peter 可以抽的香烟总数，给定初始香烟数量和烟蒂换新香烟的比例。\n * Peter 保存抽过的香烟的烟蒂，并以给定的比例将它们兑换成新的香烟。\n * \n * 示例:\n * >>> totalCigarettesSmoked(4, 3)\n *     5\n * >>> totalCigarettesSmoked(10, 3)\n *     14\n */\nfun totalCigarettesSmoked(initialCigarettes: Int, buttsForNew: Int): Int ",
      "fr": "/**\n * Calculer le nombre total de cigarettes que Peter peut fumer étant donné un nombre initial de cigarettes et un ratio de mégots de cigarettes pour de nouvelles cigarettes.\n * Peter garde les mégots des cigarettes fumées et les échange contre de nouvelles à un taux donné.\n * \n * Exemple :\n * >>> totalCigarettesSmoked(4, 3)\n *     5\n * >>> totalCigarettesSmoked(10, 3)\n *     14\n */",
      "de": "/**\n * Berechne die Gesamtanzahl der Zigaretten, die Peter rauchen kann, gegeben eine anfängliche Anzahl von Zigaretten und ein Verhältnis von Zigarettenstummeln zu neuen Zigaretten.\n * Peter spart Stummel von gerauchten Zigaretten und tauscht sie zu einem gegebenen Kurs gegen neue ein.\n * \n * Beispiel:\n * >>> totalCigarettesSmoked(4, 3)\n *     5\n * >>> totalCigarettesSmoked(10, 3)\n *     14\n */",
      "ha": "/**\n * Lissafa jimlar adadin sigari da Peter zai iya sha idan aka ba shi adadin farko na sigari da kuma rabo na bututun sigari zuwa sabbin sigari.\n * Peter yana adana bututun sigari da ya sha kuma yana musanya su da sabbin sigari a wani kudi da aka bayar.\n * \n * Misali:\n * >>> totalCigarettesSmoked(4, 3)\n *     5\n * >>> totalCigarettesSmoked(10, 3)\n *     14\n */",
      "hi": "/**\n * दिए गए प्रारंभिक सिगरेटों की संख्या और सिगरेट के बट्स को नए सिगरेटों में बदलने के अनुपात को देखते हुए पीटर कुल कितनी सिगरेटें पी सकता है, की गणना करें।\n * पीटर पी गई सिगरेटों के बट्स को बचाता है और उन्हें एक दिए गए दर पर नए सिगरेटों के लिए बदलता है।\n * \n * उदाहरण:\n * >>> totalCigarettesSmoked(4, 3)\n *     5\n * >>> totalCigarettesSmoked(10, 3)\n *     14\n */\nfun totalCigarettesSmoked(initialCigarettes: Int, buttsForNew: Int): Int ",
      "hu": "/**\n * Számítsd ki, hogy összesen hány cigarettát tud elszívni Péter egy kezdeti cigarettaszám és a csikkek új cigarettára váltásának aránya alapján.\n * Péter megőrzi az elszívott cigaretták csikkjeit, és egy adott arányban új cigarettákra cseréli őket.\n * \n * Példa:\n * >>> totalCigarettesSmoked(4, 3)\n *     5\n * >>> totalCigarettesSmoked(10, 3)\n *     14\n */\nfun totalCigarettesSmoked(initialCigarettes: Int, buttsForNew: Int): Int "
    },
    "prompt_bertscore": {
      "sq": "0.9308563671009934",
      "hy": "0.9051816026788048",
      "bn": "0.9074630712353715",
      "bg": "0.9305476954888652",
      "zh": "0.9789549124989726",
      "fr": "0.9320169644173802",
      "de": "0.9356103866406824",
      "ha": "0.9203057171515632",
      "hi": "0.9073403176598919",
      "hu": "0.9462126804891816"
    },
    "canonical_solution": "{\n    var totalSmoked = initialCigarettes\n    var currentButts = initialCigarettes\n    while (currentButts >= buttsForNew) {\n        val newCigarettes = currentButts / buttsForNew\n        totalSmoked += newCigarettes\n        currentButts = currentButts % buttsForNew + newCigarettes\n    }\n    return totalSmoked\n}",
    "instruction": {
      "en": "Write a Kotlin function `fun totalCigarettesSmoked(initialCigarettes: Int, buttsForNew: Int): Int` to solve the following problem:\nCalculate the total number of cigarettes Peter can smoke given an initial number of cigarettes and a ratio of cigarette butts to new cigarettes.\n  Peter saves butts from smoked cigarettes and exchanges them for new ones at a given rate.\n  \n  Example:\n  >>> totalCigarettesSmoked(4, 3)\n      5\n  >>> totalCigarettesSmoked(10, 3)\n      14",
      "sq": "Shkruani një funksion Kotlin `fun totalCigarettesSmoked(initialCigarettes: Int, buttsForNew: Int): Int` për të zgjidhur problemin e mëposhtëm:\nLlogaritni numrin total të cigareve që Peter mund të pijë duke pasur parasysh një numër fillestar të cigareve dhe një raport të bishtave të cigareve për cigare të reja.\n  Peter ruan bishtat nga cigaret e pira dhe i shkëmben ato për të reja me një normë të caktuar.\n  \n  Shembull:\n  >>> totalCigarettesSmoked(4, 3)\n      5\n  >>> totalCigarettesSmoked(10, 3)\n      14",
      "hy": "Գրեք Kotlin ֆունկցիա `fun totalCigarettesSmoked(initialCigarettes: Int, buttsForNew: Int): Int` հետևյալ խնդիրը լուծելու համար:\nՀաշվեք ընդհանուր քանակը սիգարետների, որոնք Պետերը կարող է ծխել՝ հաշվի առնելով սկզբնական սիգարետների քանակը և ծխած սիգարետների մնացորդների փոխանակման հարաբերակցությունը նոր սիգարետների հետ:\n  Պետերը պահպանում է ծխած սիգարետների մնացորդները և փոխանակում է դրանք նորերի հետ տրված հարաբերակցությամբ:\n  \n  Օրինակ:\n  >>> totalCigarettesSmoked(4, 3)\n      5\n  >>> totalCigarettesSmoked(10, 3)\n      14",
      "bn": "কোনো Kotlin ফাংশন `fun totalCigarettesSmoked(initialCigarettes: Int, buttsForNew: Int): Int` লিখুন নিম্নলিখিত সমস্যার সমাধানের জন্য:\nপিটার কতগুলি সিগারেট খেতে পারে তা গণনা করুন একটি প্রাথমিক সিগারেটের সংখ্যা এবং সিগারেটের বাট থেকে নতুন সিগারেটের অনুপাত দেওয়া হলে।\n  পিটার ধূমপান করা সিগারেটের বাট সংগ্রহ করে এবং একটি নির্দিষ্ট হারে সেগুলি নতুন সিগারেটের জন্য বিনিময় করে।\n\n  উদাহরণ:\n  >>> totalCigarettesSmoked(4, 3)\n      5\n  >>> totalCigarettesSmoked(10, 3)\n      14",
      "bg": "Напишете Kotlin функция `fun totalCigarettesSmoked(initialCigarettes: Int, buttsForNew: Int): Int`, за да решите следния проблем:  \nИзчислете общия брой цигари, които Петър може да изпуши, като се има предвид началният брой цигари и съотношението на фасове към нови цигари.  \nПетър събира фасове от изпушени цигари и ги обменя за нови при даден курс.",
      "zh": "编写一个 Kotlin 函数 `fun totalCigarettesSmoked(initialCigarettes: Int, buttsForNew: Int): Int` 来解决以下问题：\n计算彼得可以抽的香烟总数，给定初始香烟数量和烟头兑换新香烟的比例。\n彼得保存抽过的香烟的烟头，并以给定的比例将它们兑换成新的香烟。",
      "fr": "Écrire une fonction Kotlin `fun totalCigarettesSmoked(initialCigarettes: Int, buttsForNew: Int): Int` pour résoudre le problème suivant :\nCalculer le nombre total de cigarettes que Peter peut fumer étant donné un nombre initial de cigarettes et un ratio de mégots de cigarettes pour de nouvelles cigarettes.\n  Peter garde les mégots des cigarettes fumées et les échange contre de nouvelles à un taux donné.\n  \n  Exemple :\n  >>> totalCigarettesSmoked(4, 3)\n      5\n  >>> totalCigarettesSmoked(10, 3)\n      14",
      "de": "Schreiben Sie eine Kotlin-Funktion `fun totalCigarettesSmoked(initialCigarettes: Int, buttsForNew: Int): Int`, um das folgende Problem zu lösen:\nBerechnen Sie die Gesamtanzahl der Zigaretten, die Peter rauchen kann, gegeben eine anfängliche Anzahl von Zigaretten und ein Verhältnis von Zigarettenstummeln zu neuen Zigaretten.\n  Peter spart Stummel von gerauchten Zigaretten und tauscht sie zu einem gegebenen Kurs gegen neue ein.\n  \n  Beispiel:\n  >>> totalCigarettesSmoked(4, 3)\n      5\n  >>> totalCigarettesSmoked(10, 3)\n      14",
      "ha": "Rubuta aikin Kotlin `fun totalCigarettesSmoked(initialCigarettes: Int, buttsForNew: Int): Int` don warware matsalar mai zuwa:\nƘididdige jimillar adadin sigari da Peter zai iya sha idan aka ba da adadin farko na sigari da kuma adadin ƙwanƙolin sigari zuwa sabbin sigari.\n  Peter yana adana ƙwanƙolin sigari daga sigari da ya sha kuma yana musanya su da sababbi a wani ƙimar musanya.\n\n  Misali:\n  >>> totalCigarettesSmoked(4, 3)\n      5\n  >>> totalCigarettesSmoked(10, 3)\n      14",
      "hi": "Kotlin फ़ंक्शन `fun totalCigarettesSmoked(initialCigarettes: Int, buttsForNew: Int): Int` लिखें ताकि निम्नलिखित समस्या को हल किया जा सके:\nपीटर द्वारा धूम्रपान की जा सकने वाली कुल सिगरेटों की संख्या की गणना करें, जब प्रारंभिक सिगरेटों की संख्या और सिगरेट के बचे हुए टुकड़ों का नए सिगरेटों के लिए अनुपात दिया गया हो।\n  पीटर धूम्रपान की गई सिगरेटों के बचे हुए टुकड़ों को बचाता है और उन्हें एक दिए गए दर पर नए सिगरेटों के लिए बदलता है।",
      "hu": "Írj egy Kotlin függvényt `fun totalCigarettesSmoked(initialCigarettes: Int, buttsForNew: Int): Int` a következő probléma megoldására:\nSzámítsd ki, hogy Péter összesen hány cigarettát tud elszívni, ha adott egy kezdeti számú cigaretta és egy arány a cigarettacsikkek új cigarettákra történő cseréjére.\n  Péter a szívott cigaretták csikkjeit gyűjti, és azokat egy adott arányban új cigarettákra cseréli."
    },
    "instruction_bertscore": {
      "sq": "0.9874650325440313",
      "hy": "0.9601797729924119",
      "bn": "0.9736345977429531",
      "bg": "0.9157809170715885",
      "zh": "0.8996521301315555",
      "fr": "0.9863795175116756",
      "de": "0.996395653105741",
      "ha": "0.9619614875102948",
      "hi": "0.8935315335703464",
      "hu": "0.8729810357180959"
    },
    "level": "easy",
    "test": "fun main() {\n    check(totalCigarettesSmoked(4, 3) == 5)\n    check(totalCigarettesSmoked(10, 3) == 14)\n    check(totalCigarettesSmoked(1, 2) == 1) // Edge case: Not enough cigarettes to exchange\n    check(totalCigarettesSmoked(20, 5) == 24) // More cigarettes, different exchange rate\n}\n\nmain()",
    "entry_point": "totalCigarettesSmoked",
    "signature": "fun totalCigarettesSmoked(initialCigarettes: Int, buttsForNew: Int): Int",
    "docstring": {
      "en": "Calculate the total number of cigarettes Peter can smoke given an initial number of cigarettes and a ratio of cigarette butts to new cigarettes.\n  Peter saves butts from smoked cigarettes and exchanges them for new ones at a given rate.\n  \n  Example:\n  >>> totalCigarettesSmoked(4, 3)\n      5\n  >>> totalCigarettesSmoked(10, 3)\n      14",
      "sq": "Llogaritni numrin total të cigareve që Peter mund të pijë duke pasur parasysh një numër fillestar të cigareve dhe një raport të bishtave të cigareve për cigare të reja.\n  Peter ruan bishtat nga cigaret e pira dhe i shkëmben ato për të reja me një normë të caktuar.\n  \n  Shembull:\n  >>> totalCigarettesSmoked(4, 3)\n      5\n  >>> totalCigarettesSmoked(10, 3)\n      14",
      "hy": "Հաշվարկել ընդհանուր ծխախոտների քանակը, որոնք կարող է ծխել Պետերը՝ հաշվի առնելով սկզբնական ծխախոտների քանակը և ծխախոտի մնացորդների փոխանակման հարաբերակցությունը:\n  Պետերը պահպանում է ծխված ծխախոտների մնացորդները և փոխանակում է դրանք նորերի հետ՝ տրված հարաբերակցությամբ:\n  \n  Օրինակ:\n  >>> totalCigarettesSmoked(4, 3)\n      5\n  >>> totalCigarettesSmoked(10, 3)\n      14",
      "bn": "সিগারেটের প্রাথমিক সংখ্যা এবং সিগারেটের বাট থেকে নতুন সিগারেট পাওয়ার অনুপাত দেওয়া হলে পিটার মোট কতটি সিগারেট খেতে পারে তা গণনা করুন।\n  পিটার ধূমপান করা সিগারেটের বাট সংগ্রহ করে এবং নির্দিষ্ট হারে সেগুলো নতুন সিগারেটের জন্য বিনিময় করে।\n\n  উদাহরণ:\n  >>> totalCigarettesSmoked(4, 3)\n      5\n  >>> totalCigarettesSmoked(10, 3)\n      14",
      "bg": "Изчислете общия брой цигари, които Петър може да изпуши, като се има предвид началния брой цигари и съотношението на фасове към нови цигари.\nПетър събира фасове от изпушените цигари и ги обменя за нови при даден курс.\n\nПример:\n>>> totalCigarettesSmoked(4, 3)\n    5\n>>> totalCigarettesSmoked(10, 3)\n    14",
      "zh": "计算彼得可以抽的香烟总数，给定初始香烟数量和烟蒂兑换新香烟的比例。\n彼得保存抽过的香烟的烟蒂，并以给定的比例将它们兑换为新的香烟。\n\n示例：\n>>> totalCigarettesSmoked(4, 3)\n    5\n>>> totalCigarettesSmoked(10, 3)\n    14",
      "fr": "Calculer le nombre total de cigarettes que Peter peut fumer étant donné un nombre initial de cigarettes et un ratio de mégots de cigarettes pour de nouvelles cigarettes.\n  Peter garde les mégots des cigarettes fumées et les échange contre de nouvelles à un taux donné.\n  \n  Exemple :\n  >>> totalCigarettesSmoked(4, 3)\n      5\n  >>> totalCigarettesSmoked(10, 3)\n      14",
      "de": "Berechnen Sie die Gesamtanzahl der Zigaretten, die Peter rauchen kann, gegeben eine anfängliche Anzahl von Zigaretten und ein Verhältnis von Zigarettenstummeln zu neuen Zigaretten.\n  Peter spart Stummel von gerauchten Zigaretten und tauscht sie zu einem gegebenen Kurs gegen neue ein.\n  \n  Beispiel:\n  >>> totalCigarettesSmoked(4, 3)\n      5\n  >>> totalCigarettesSmoked(10, 3)\n      14",
      "ha": "Ƙididdige jimlar adadin sigari da Peter zai iya sha la'akari da adadin sigari na farko da kuma rabo na bututun sigari zuwa sabbin sigari. \n  Peter yana adana bututun daga sigarin da ya sha kuma yana musanya su da sabbi a wani kudi da aka bayar.\n\n  Misali:\n  >>> totalCigarettesSmoked(4, 3)\n      5\n  >>> totalCigarettesSmoked(10, 3)\n      14",
      "hi": "कुल सिगरेट की संख्या की गणना करें जो पीटर पी सकता है, दिए गए प्रारंभिक सिगरेट की संख्या और सिगरेट के बट्स को नई सिगरेट में बदलने के अनुपात के आधार पर।\n  पीटर पी गई सिगरेट के बट्स को बचाता है और उन्हें एक निश्चित दर पर नई सिगरेट के लिए बदलता है।\n  \n  उदाहरण:\n  >>> totalCigarettesSmoked(4, 3)\n      5\n  >>> totalCigarettesSmoked(10, 3)\n      14",
      "hu": "Számítsd ki, hány cigarettát tud Péter elszívni, ha adott számú cigarettával kezd és van egy arány a cigarettacsikkek és az új cigaretták között. \n  Péter megőrzi az elszívott cigaretták csikkjeit, és egy adott arányban új cigarettákra cseréli őket.\n  \n  Példa:\n  >>> totalCigarettesSmoked(4, 3)\n      5\n  >>> totalCigarettesSmoked(10, 3)\n      14"
    },
    "docstring_bertscore": {
      "sq": "0.9829205680563341",
      "hy": "0.9447028909629354",
      "bn": "0.9611004248085085",
      "bg": "0.97990257804689",
      "zh": "0.9505388501881215",
      "fr": "0.9721923425462587",
      "de": "0.9923408125072947",
      "ha": "0.9648944637166559",
      "hi": "0.9457911868206256",
      "hu": "0.9177012755954338"
    }
  },
  {
    "task_id": "Kotlin/43",
    "prompt": {
      "en": "/**\n * Finds the length of the longest consecutive sequence in a given list of integers.\n * Consecutive sequence means numbers that come sequentially without any gap.\n * \n * Example:\n * >>> longestConsecutiveSequence(listOf(1, 5, 6, 2, 3, 4, 5, 6, 8, 9))\n *     6\n * >>> longestConsecutiveSequence(listOf(10, 4, 20, 1, 3, 2))\n *     4\n**/\nfun longestConsecutiveSequence(numbers: List<Int>): Int ",
      "sq": "/**\n * Gjen gjatësinë e sekuencës më të gjatë të njëpasnjëshme në një listë të dhënë të numrave të plotë.\n * Sekuenca e njëpasnjëshme do të thotë numra që vijnë në mënyrë të njëpasnjëshme pa asnjë ndërprerje.\n * \n * Shembull:\n * >>> longestConsecutiveSequence(listOf(1, 5, 6, 2, 3, 4, 5, 6, 8, 9))\n *     6\n * >>> longestConsecutiveSequence(listOf(10, 4, 20, 1, 3, 2))\n *     4\n**/\nfun longestConsecutiveSequence(numbers: List<Int>): Int ",
      "hy": "/**\n * Գտնում է ամենաերկար հաջորդական հաջորդականության երկարությունը տրված ամբողջ թվերի ցուցակում:\n * Հաջորդական հաջորդականություն նշանակում է թվեր, որոնք գալիս են հաջորդաբար առանց որևէ բացի:\n * \n * Օրինակ:\n * >>> longestConsecutiveSequence(listOf(1, 5, 6, 2, 3, 4, 5, 6, 8, 9))\n *     6\n * >>> longestConsecutiveSequence(listOf(10, 4, 20, 1, 3, 2))\n *     4\n**/ \nfun longestConsecutiveSequence(numbers: List<Int>): Int ",
      "bn": "/**\n * একটি প্রদত্ত পূর্ণসংখ্যার তালিকায় দীর্ঘতম ধারাবাহিক ক্রমের দৈর্ঘ্য খুঁজে বের করে।\n * ধারাবাহিক ক্রম মানে এমন সংখ্যা যা কোন ফাঁক ছাড়াই ধারাবাহিকভাবে আসে।\n * \n * উদাহরণ:\n * >>> longestConsecutiveSequence(listOf(1, 5, 6, 2, 3, 4, 5, 6, 8, 9))\n *     6\n * >>> longestConsecutiveSequence(listOf(10, 4, 20, 1, 3, 2))\n *     4\n**/ \nfun longestConsecutiveSequence(numbers: List<Int>): Int ",
      "bg": "/**\n * Намира дължината на най-дългата последователна поредица в даден списък от цели числа.\n * Последователна поредица означава числа, които идват последователно без никаква празнина.\n * \n * Пример:\n * >>> longestConsecutiveSequence(listOf(1, 5, 6, 2, 3, 4, 5, 6, 8, 9))\n *     6\n * >>> longestConsecutiveSequence(listOf(10, 4, 20, 1, 3, 2))\n *     4\n**/ \nfun longestConsecutiveSequence(numbers: List<Int>): Int ",
      "zh": "/**\n * 查找给定整数列表中最长连续序列的长度。\n * 连续序列意味着数字按顺序排列且没有间隔。\n * \n * 示例:\n * >>> longestConsecutiveSequence(listOf(1, 5, 6, 2, 3, 4, 5, 6, 8, 9))\n *     6\n * >>> longestConsecutiveSequence(listOf(10, 4, 20, 1, 3, 2))\n *     4\n**/\nfun longestConsecutiveSequence(numbers: List<Int>): Int ",
      "fr": "/**\n * Trouve la longueur de la plus longue séquence consécutive dans une liste donnée d'entiers.\n * Séquence consécutive signifie des nombres qui viennent séquentiellement sans aucun écart.\n * \n * Exemple :\n * >>> longestConsecutiveSequence(listOf(1, 5, 6, 2, 3, 4, 5, 6, 8, 9))\n *     6\n * >>> longestConsecutiveSequence(listOf(10, 4, 20, 1, 3, 2))\n *     4\n**/ \nfun longestConsecutiveSequence(numbers: List<Int>): Int ",
      "de": "/**\n * Findet die Länge der längsten aufeinanderfolgenden Sequenz in einer gegebenen Liste von ganzen Zahlen.\n * Aufeinanderfolgende Sequenz bedeutet Zahlen, die ohne Lücke nacheinander kommen.\n * \n * Beispiel:\n * >>> longestConsecutiveSequence(listOf(1, 5, 6, 2, 3, 4, 5, 6, 8, 9))\n *     6\n * >>> longestConsecutiveSequence(listOf(10, 4, 20, 1, 3, 2))\n *     4\n**/ \nfun longestConsecutiveSequence(numbers: List<Int>): Int ",
      "ha": "/**\n * Nemi tsawon jerin lambobi mafi tsawo a cikin jerin lambobi da aka bayar.\n * Jerin lambobi na jere yana nufin lambobi da ke zuwa a jere ba tare da wata tazara ba.\n * \n * Misali:\n * >>> longestConsecutiveSequence(listOf(1, 5, 6, 2, 3, 4, 5, 6, 8, 9))\n *     6\n * >>> longestConsecutiveSequence(listOf(10, 4, 20, 1, 3, 2))\n *     4\n**/ \nfun longestConsecutiveSequence(numbers: List<Int>): Int ",
      "hi": "/**\n * दिए गए पूर्णांकों की सूची में सबसे लंबे लगातार अनुक्रम की लंबाई खोजता है।\n * लगातार अनुक्रम का मतलब है ऐसे नंबर जो बिना किसी अंतराल के क्रमिक रूप से आते हैं।\n * \n * उदाहरण:\n * >>> longestConsecutiveSequence(listOf(1, 5, 6, 2, 3, 4, 5, 6, 8, 9))\n *     6\n * >>> longestConsecutiveSequence(listOf(10, 4, 20, 1, 3, 2))\n *     4\n**/\nfun longestConsecutiveSequence(numbers: List<Int>): Int ",
      "hu": "/**\n * Megkeresi a leghosszabb egymást követő sorozat hosszát egy adott egész számokat tartalmazó listában.\n * Egymást követő sorozat azt jelenti, hogy a számok megszakítás nélkül, sorban következnek.\n * \n * Példa:\n * >>> longestConsecutiveSequence(listOf(1, 5, 6, 2, 3, 4, 5, 6, 8, 9))\n *     6\n * >>> longestConsecutiveSequence(listOf(10, 4, 20, 1, 3, 2))\n *     4\n**/\nfun longestConsecutiveSequence(numbers: List<Int>): Int "
    },
    "prompt_bertscore": {
      "sq": "0.9795647077687497",
      "hy": "0.9857701195026606",
      "bn": "0.9909247765208969",
      "bg": "0.9868528537096818",
      "zh": "0.9582538528178975",
      "fr": "1",
      "de": "0.9826665197989904",
      "ha": "0.9669187059297825",
      "hi": "0.9886160956021285",
      "hu": "0.9183547695490385"
    },
    "canonical_solution": "{\n    if (numbers.isEmpty()) return 0\n    val sortedNumbers = numbers.distinct().sorted()\n    var longestStreak = 1\n    var currentStreak = 1\n\n    for (i in 1 until sortedNumbers.size) {\n        if (sortedNumbers[i] == sortedNumbers[i - 1] + 1) {\n            currentStreak += 1\n        } else {\n            longestStreak = maxOf(longestStreak, currentStreak)\n            currentStreak = 1\n        }\n    }\n\n    return maxOf(longestStreak, currentStreak)\n}",
    "instruction": {
      "en": "Write a Kotlin function `fun longestConsecutiveSequence(numbers: List<Int>): Int` to solve the following problem:\nFinds the length of the longest consecutive sequence in a given list of integers.\n  Consecutive sequence means numbers that come sequentially without any gap.\n  \n  Example:\n  >>> longestConsecutiveSequence(listOf(1, 5, 6, 2, 3, 4, 5, 6, 8, 9))\n      6\n  >>> longestConsecutiveSequence(listOf(10, 4, 20, 1, 3, 2))\n      4",
      "sq": "Shkruani një funksion Kotlin `fun longestConsecutiveSequence(numbers: List<Int>): Int` për të zgjidhur problemin në vijim:\nGjen gjatësinë e sekuencës më të gjatë radhazi në një listë të dhënë të numrave të plotë.\n  Sekuenca radhazi do të thotë numra që vijnë njëri pas tjetrit pa ndonjë ndërprerje.\n  \n  Shembull:\n  >>> longestConsecutiveSequence(listOf(1, 5, 6, 2, 3, 4, 5, 6, 8, 9))\n      6\n  >>> longestConsecutiveSequence(listOf(10, 4, 20, 1, 3, 2))\n      4",
      "hy": "Գրեք Kotlin ֆունկցիա `fun longestConsecutiveSequence(numbers: List<Int>): Int` հետևյալ խնդիրը լուծելու համար:\nԳտնում է ամենաերկար հաջորդական հաջորդականության երկարությունը տրված ամբողջ թվերի ցուցակում:\n  Հաջորդական հաջորդականություն նշանակում է թվեր, որոնք հաջորդաբար են գալիս առանց որևէ բացի:\n  \n  Օրինակ:\n  >>> longestConsecutiveSequence(listOf(1, 5, 6, 2, 3, 4, 5, 6, 8, 9))\n      6\n  >>> longestConsecutiveSequence(listOf(10, 4, 20, 1, 3, 2))\n      4",
      "bn": "একটি Kotlin ফাংশন `fun longestConsecutiveSequence(numbers: List<Int>): Int` লিখুন নিম্নলিখিত সমস্যার সমাধানের জন্য:\nএকটি প্রদত্ত পূর্ণসংখ্যার তালিকায় দীর্ঘতম ধারাবাহিক অনুক্রমের দৈর্ঘ্য খুঁজে বের করে।\n  ধারাবাহিক অনুক্রম মানে এমন সংখ্যা যা কোনো ফাঁক ছাড়াই ধারাবাহিকভাবে আসে।\n  \n  উদাহরণ:\n  >>> longestConsecutiveSequence(listOf(1, 5, 6, 2, 3, 4, 5, 6, 8, 9))\n      6\n  >>> longestConsecutiveSequence(listOf(10, 4, 20, 1, 3, 2))\n      4",
      "bg": "Напишете Kotlin функция `fun longestConsecutiveSequence(numbers: List<Int>): Int`, за да решите следния проблем:\nНамира дължината на най-дългата последователна редица в даден списък от цели числа.\n  Последователна редица означава числа, които идват последователно без никаква празнина.\n  \n  Пример:\n  >>> longestConsecutiveSequence(listOf(1, 5, 6, 2, 3, 4, 5, 6, 8, 9))\n      6\n  >>> longestConsecutiveSequence(listOf(10, 4, 20, 1, 3, 2))\n      4",
      "zh": "编写一个 Kotlin 函数 `fun longestConsecutiveSequence(numbers: List<Int>): Int` 来解决以下问题：\n找到给定整数列表中最长连续序列的长度。\n连续序列是指没有间隔顺序出现的数字。\n\n例子:\n>>> longestConsecutiveSequence(listOf(1, 5, 6, 2, 3, 4, 5, 6, 8, 9))\n    6\n>>> longestConsecutiveSequence(listOf(10, 4, 20, 1, 3, 2))\n    4",
      "fr": "Écrire une fonction Kotlin `fun longestConsecutiveSequence(numbers: List<Int>): Int` pour résoudre le problème suivant :\nTrouver la longueur de la plus longue séquence consécutive dans une liste donnée d'entiers.\n  Une séquence consécutive signifie des nombres qui viennent séquentiellement sans aucun écart.\n  \n  Exemple :\n  >>> longestConsecutiveSequence(listOf(1, 5, 6, 2, 3, 4, 5, 6, 8, 9))\n      6\n  >>> longestConsecutiveSequence(listOf(10, 4, 20, 1, 3, 2))\n      4",
      "de": "Schreiben Sie eine Kotlin-Funktion `fun longestConsecutiveSequence(numbers: List<Int>): Int`, um das folgende Problem zu lösen:\nFindet die Länge der längsten aufeinanderfolgenden Sequenz in einer gegebenen Liste von ganzen Zahlen.\n  Eine aufeinanderfolgende Sequenz bedeutet Zahlen, die ohne Lücke nacheinander kommen.\n  \n  Beispiel:\n  >>> longestConsecutiveSequence(listOf(1, 5, 6, 2, 3, 4, 5, 6, 8, 9))\n      6\n  >>> longestConsecutiveSequence(listOf(10, 4, 20, 1, 3, 2))\n      4",
      "ha": "Rubuta wani aikin Kotlin `fun longestConsecutiveSequence(numbers: List<Int>): Int` don warware matsalar mai zuwa:\nNemo tsawon jerin lambobi mafi tsawo a cikin jerin lambobi da aka bayar.\n  Jeri na lambobi yana nufin lambobi da ke zuwa a jere ba tare da wani tazara ba.\n  \n  Misali:\n  >>> longestConsecutiveSequence(listOf(1, 5, 6, 2, 3, 4, 5, 6, 8, 9))\n      6\n  >>> longestConsecutiveSequence(listOf(10, 4, 20, 1, 3, 2))\n      4",
      "hi": "Kotlin फ़ंक्शन `fun longestConsecutiveSequence(numbers: List<Int>): Int` लिखें ताकि निम्नलिखित समस्या का समाधान किया जा सके:\nदिए गए पूर्णांकों की सूची में सबसे लंबे लगातार अनुक्रम की लंबाई खोजें।\n  लगातार अनुक्रम का अर्थ है कि संख्या बिना किसी अंतराल के क्रमिक रूप से आती हैं।\n  \n  उदाहरण:\n  >>> longestConsecutiveSequence(listOf(1, 5, 6, 2, 3, 4, 5, 6, 8, 9))\n      6\n  >>> longestConsecutiveSequence(listOf(10, 4, 20, 1, 3, 2))\n      4",
      "hu": "Írj egy Kotlin függvényt `fun longestConsecutiveSequence(numbers: List<Int>): Int` a következő probléma megoldására:\nMegtalálja a leghosszabb egymást követő sorozat hosszát egy adott egész számokat tartalmazó listában.\n  Egymást követő sorozat olyan számokat jelent, amelyek megszakítás nélkül követik egymást.\n  \n  Példa:\n  >>> longestConsecutiveSequence(listOf(1, 5, 6, 2, 3, 4, 5, 6, 8, 9))\n      6\n  >>> longestConsecutiveSequence(listOf(10, 4, 20, 1, 3, 2))\n      4"
    },
    "instruction_bertscore": {
      "sq": "0.9784601242198147",
      "hy": "0.985801105842102",
      "bn": "0.978929090549438",
      "bg": "0.9861787021964494",
      "zh": "0.9626314677855254",
      "fr": "0.9848041799596879",
      "de": "0.9792331936628025",
      "ha": "0.9639082638748178",
      "hi": "0.9585025380549532",
      "hu": "0.9611467056872897"
    },
    "level": "middle",
    "test": "fun main() {\n    check(longestConsecutiveSequence(listOf(1, 5, 6, 2, 3, 4, 5, 6, 8, 9)) == 6)\n    check(longestConsecutiveSequence(listOf(10, 4, 20, 1, 3, 2)) == 4)\n    check(longestConsecutiveSequence(listOf(1, 2, 3, 4, 5, 6)) == 6)\n    check(longestConsecutiveSequence(listOf(100, 4, 200, 1, 3, 2)) == 4)\n}\n\n\nmain()",
    "entry_point": "longestConsecutiveSequence",
    "signature": "fun longestConsecutiveSequence(numbers: List<Int>): Int",
    "docstring": {
      "en": "Finds the length of the longest consecutive sequence in a given list of integers.\n  Consecutive sequence means numbers that come sequentially without any gap.\n  \n  Example:\n  >>> longestConsecutiveSequence(listOf(1, 5, 6, 2, 3, 4, 5, 6, 8, 9))\n      6\n  >>> longestConsecutiveSequence(listOf(10, 4, 20, 1, 3, 2))\n      4",
      "sq": "Gjen gjatësinë e sekuencës më të gjatë të njëpasnjëshme në një listë të dhënë të numrave të plotë.\n  Sekuenca e njëpasnjëshme do të thotë numra që vijnë në mënyrë sekuenciale pa asnjë hendek.\n  \n  Shembull:\n  >>> longestConsecutiveSequence(listOf(1, 5, 6, 2, 3, 4, 5, 6, 8, 9))\n      6\n  >>> longestConsecutiveSequence(listOf(10, 4, 20, 1, 3, 2))\n      4",
      "hy": "Գտնում է տրված ամբողջ թվերի ցուցակում ամենաերկար հաջորդական հաջորդականության երկարությունը։  \n  Հաջորդական հաջորդականություն նշանակում է թվեր, որոնք գալիս են հաջորդաբար առանց որևէ բացի։\n  \n  Օրինակ:\n  >>> longestConsecutiveSequence(listOf(1, 5, 6, 2, 3, 4, 5, 6, 8, 9))\n      6\n  >>> longestConsecutiveSequence(listOf(10, 4, 20, 1, 3, 2))\n      4",
      "bn": "দেওয়া পূর্ণসংখ্যার তালিকায় দীর্ঘতম ধারাবাহিক ক্রমের দৈর্ঘ্য খুঁজে বের করে। ধারাবাহিক ক্রম মানে এমন সংখ্যা যা কোনো ফাঁক ছাড়াই ধারাবাহিকভাবে আসে।\n\nউদাহরণ:\n>>> longestConsecutiveSequence(listOf(1, 5, 6, 2, 3, 4, 5, 6, 8, 9))\n    6\n>>> longestConsecutiveSequence(listOf(10, 4, 20, 1, 3, 2))\n    4",
      "bg": "Намира дължината на най-дългата последователна поредица в даден списък от цели числа.\n  Последователна поредица означава числа, които идват последователно без никаква празнина.\n  \n  Пример:\n  >>> longestConsecutiveSequence(listOf(1, 5, 6, 2, 3, 4, 5, 6, 8, 9))\n      6\n  >>> longestConsecutiveSequence(listOf(10, 4, 20, 1, 3, 2))\n      4",
      "zh": "找到给定整数列表中最长连续序列的长度。  \n连续序列意味着数字按顺序排列且没有间隔。\n\n示例：\n>>> longestConsecutiveSequence(listOf(1, 5, 6, 2, 3, 4, 5, 6, 8, 9))\n    6\n>>> longestConsecutiveSequence(listOf(10, 4, 20, 1, 3, 2))\n    4",
      "fr": "Trouve la longueur de la plus longue séquence consécutive dans une liste donnée d'entiers.\n  Séquence consécutive signifie des nombres qui viennent séquentiellement sans aucun écart.\n  \n  Exemple :\n  >>> longestConsecutiveSequence(listOf(1, 5, 6, 2, 3, 4, 5, 6, 8, 9))\n      6\n  >>> longestConsecutiveSequence(listOf(10, 4, 20, 1, 3, 2))\n      4",
      "de": "Findet die Länge der längsten aufeinanderfolgenden Sequenz in einer gegebenen Liste von ganzen Zahlen.\n  Eine aufeinanderfolgende Sequenz bedeutet Zahlen, die ohne Lücke nacheinander kommen.\n  \n  Beispiel:\n  >>> longestConsecutiveSequence(listOf(1, 5, 6, 2, 3, 4, 5, 6, 8, 9))\n      6\n  >>> longestConsecutiveSequence(listOf(10, 4, 20, 1, 3, 2))\n      4",
      "ha": "Yana nemo tsawon jerin lambobi masu jere mafi tsawo a cikin wata takamaiman jerin lambobi.\n  Jerin lambobi masu jere yana nufin lambobi da suke zuwa a jere ba tare da wata tazara ba.\n  \n  Misali:\n  >>> longestConsecutiveSequence(listOf(1, 5, 6, 2, 3, 4, 5, 6, 8, 9))\n      6\n  >>> longestConsecutiveSequence(listOf(10, 4, 20, 1, 3, 2))\n      4",
      "hi": "दिए गए पूर्णांकों की सूची में सबसे लंबे लगातार अनुक्रम की लंबाई खोजता है।  \n  लगातार अनुक्रम का मतलब है कि संख्याएँ बिना किसी अंतराल के क्रमिक रूप से आती हैं।\n  \n  उदाहरण:\n  >>> longestConsecutiveSequence(listOf(1, 5, 6, 2, 3, 4, 5, 6, 8, 9))\n      6\n  >>> longestConsecutiveSequence(listOf(10, 4, 20, 1, 3, 2))\n      4",
      "hu": "Megkeresi a leghosszabb egymást követő sorozat hosszát egy adott egész számokat tartalmazó listában.\n  Egymást követő sorozat olyan számokat jelent, amelyek megszakítás nélkül követik egymást.\n  \n  Példa:\n  >>> longestConsecutiveSequence(listOf(1, 5, 6, 2, 3, 4, 5, 6, 8, 9))\n      6\n  >>> longestConsecutiveSequence(listOf(10, 4, 20, 1, 3, 2))\n      4"
    },
    "docstring_bertscore": {
      "sq": "0.9804748321746515",
      "hy": "0.9818149913554939",
      "bn": "0.9721927398070208",
      "bg": "0.9831555477970984",
      "zh": "0.9522856057589423",
      "fr": "0.9925920799393039",
      "de": "0.9700739495325217",
      "ha": "0.9512966250917696",
      "hi": "0.9815255868903261",
      "hu": "0.9591604018769407"
    }
  },
  {
    "task_id": "Kotlin/44",
    "prompt": {
      "en": "/**\n * Compares the area of a square with side length 'a' to the area of a rectangle with sides 'b' and 'c'.\n * Returns \"Alice\" if the area of the square is larger, and \"Bob\" if the area of the rectangle is larger.\n * \n * Example:\n * >>> compareAreas(5, 4, 6)\n *     \"Alice\"\n * >>> compareAreas(7, 5, 10)\n *     \"Bob\"\n */\nfun compareAreas(a: Int, b: Int, c: Int): String ",
      "sq": "/**\n * Krahason sipërfaqen e një katrori me gjatësi brinje 'a' me sipërfaqen e një drejtkëndëshi me brinjë 'b' dhe 'c'.\n * Kthen \"Alice\" nëse sipërfaqja e katrorit është më e madhe, dhe \"Bob\" nëse sipërfaqja e drejtkëndëshit është më e madhe.\n * \n * Shembull:\n * >>> compareAreas(5, 4, 6)\n *     \"Alice\"\n * >>> compareAreas(7, 5, 10)\n *     \"Bob\"\n */\nfun compareAreas(a: Int, b: Int, c: Int): String ",
      "hy": "/**\n * Համեմատում է կողմի երկարությունը 'a' ունեցող քառակուսու մակերեսը կողմերը 'b' և 'c' ունեցող ուղղանկյան մակերեսի հետ:\n * Վերադարձնում է \"Alice\", եթե քառակուսու մակերեսը մեծ է, և \"Bob\", եթե ուղղանկյան մակերեսը մեծ է:\n * \n * Օրինակ:\n * >>> compareAreas(5, 4, 6)\n *     \"Alice\"\n * >>> compareAreas(7, 5, 10)\n *     \"Bob\"\n */\nfun compareAreas(a: Int, b: Int, c: Int): String ",
      "bn": "/**\n * একটি বর্গক্ষেত্রের বাহুর দৈর্ঘ্য 'a' এর ক্ষেত্রফলকে একটি আয়তক্ষেত্রের বাহু 'b' এবং 'c' এর ক্ষেত্রফলের সাথে তুলনা করে।\n * যদি বর্গক্ষেত্রের ক্ষেত্রফল বড় হয় তাহলে \"Alice\" ফেরত দেয়, এবং যদি আয়তক্ষেত্রের ক্ষেত্রফল বড় হয় তাহলে \"Bob\" ফেরত দেয়।\n * \n * উদাহরণ:\n * >>> compareAreas(5, 4, 6)\n *     \"Alice\"\n * >>> compareAreas(7, 5, 10)\n *     \"Bob\"\n */\nfun compareAreas(a: Int, b: Int, c: Int): String ",
      "bg": "/**\n * Сравнява площта на квадрат със страна 'a' с площта на правоъгълник със страни 'b' и 'c'.\n * Връща \"Alice\", ако площта на квадрата е по-голяма, и \"Bob\", ако площта на правоъгълника е по-голяма.\n * \n * Пример:\n * >>> compareAreas(5, 4, 6)\n *     \"Alice\"\n * >>> compareAreas(7, 5, 10)\n *     \"Bob\"\n */\nfun compareAreas(a: Int, b: Int, c: Int): String ",
      "zh": "/**\n * 比较边长为 'a' 的正方形的面积与边长为 'b' 和 'c' 的矩形的面积。\n * 如果正方形的面积更大，则返回 \"Alice\"；如果矩形的面积更大，则返回 \"Bob\"。\n * \n * 示例:\n * >>> compareAreas(5, 4, 6)\n *     \"Alice\"\n * >>> compareAreas(7, 5, 10)\n *     \"Bob\"\n */",
      "fr": "/**\n * Compare la surface d'un carré avec une longueur de côté 'a' à la surface d'un rectangle avec les côtés 'b' et 'c'.\n * Retourne \"Alice\" si la surface du carré est plus grande, et \"Bob\" si la surface du rectangle est plus grande.\n * \n * Exemple :\n * >>> compareAreas(5, 4, 6)\n *     \"Alice\"\n * >>> compareAreas(7, 5, 10)\n *     \"Bob\"\n */\nfun compareAreas(a: Int, b: Int, c: Int): String ",
      "de": "/**\n * Vergleicht die Fläche eines Quadrats mit Seitenlänge 'a' mit der Fläche eines Rechtecks mit den Seiten 'b' und 'c'.\n * Gibt \"Alice\" zurück, wenn die Fläche des Quadrats größer ist, und \"Bob\", wenn die Fläche des Rechtecks größer ist.\n * \n * Beispiel:\n * >>> compareAreas(5, 4, 6)\n *     \"Alice\"\n * >>> compareAreas(7, 5, 10)\n *     \"Bob\"\n */\nfun compareAreas(a: Int, b: Int, c: Int): String ",
      "ha": "/**\n * Kwatanta yankin murabba'i mai gefen tsawo 'a' da yankin murabba'in mai gefuna 'b' da 'c'.\n * Mayar da \"Alice\" idan yankin murabba'i ya fi girma, da \"Bob\" idan yankin murabba'in ya fi girma.\n * \n * Misali:\n * >>> compareAreas(5, 4, 6)\n *     \"Alice\"\n * >>> compareAreas(7, 5, 10)\n *     \"Bob\"\n */\nfun compareAreas(a: Int, b: Int, c: Int): String ",
      "hi": "/**\n * एक वर्ग के क्षेत्रफल की तुलना 'a' भुजा लंबाई वाले वर्ग के साथ एक आयत के क्षेत्रफल से 'b' और 'c' भुजाओं के साथ करता है।\n * \"Alice\" लौटाता है यदि वर्ग का क्षेत्रफल बड़ा है, और \"Bob\" लौटाता है यदि आयत का क्षेत्रफल बड़ा है।\n * \n * उदाहरण:\n * >>> compareAreas(5, 4, 6)\n *     \"Alice\"\n * >>> compareAreas(7, 5, 10)\n *     \"Bob\"\n */\nfun compareAreas(a: Int, b: Int, c: Int): String ",
      "hu": "/**\n * Összehasonlítja az 'a' oldalhosszúságú négyzet területét a 'b' és 'c' oldalú téglalap területével.\n * \"Alice\"-t ad vissza, ha a négyzet területe nagyobb, és \"Bob\"-ot, ha a téglalap területe nagyobb.\n * \n * Példa:\n * >>> compareAreas(5, 4, 6)\n *     \"Alice\"\n * >>> compareAreas(7, 5, 10)\n *     \"Bob\"\n */\nfun compareAreas(a: Int, b: Int, c: Int): String "
    },
    "prompt_bertscore": {
      "sq": "1",
      "hy": "1",
      "bn": "0.9858223592928728",
      "bg": "0.9909662902705333",
      "zh": "0.8997907741375178",
      "fr": "0.9948062127966998",
      "de": "0.9992644716990278",
      "ha": "0.9367368195315312",
      "hi": "1",
      "hu": "1"
    },
    "canonical_solution": "{\n    val squareArea = a * a\n    val rectangleArea = b * c\n    return if (squareArea > rectangleArea) \"Alice\" else \"Bob\"\n}",
    "instruction": {
      "en": "Write a Kotlin function `fun compareAreas(a: Int, b: Int, c: Int): String` to solve the following problem:\nCompares the area of a square with side length 'a' to the area of a rectangle with sides 'b' and 'c'.\n  Returns \"Alice\" if the area of the square is larger, and \"Bob\" if the area of the rectangle is larger.\n  \n  Example:\n  >>> compareAreas(5, 4, 6)\n      \"Alice\"\n  >>> compareAreas(7, 5, 10)\n      \"Bob\"",
      "sq": "Shkruani një funksion Kotlin `fun compareAreas(a: Int, b: Int, c: Int): String` për të zgjidhur problemin e mëposhtëm:\nKrahason sipërfaqen e një katrori me gjatësi brinje 'a' me sipërfaqen e një drejtkëndëshi me brinjë 'b' dhe 'c'.\nKthen \"Alice\" nëse sipërfaqja e katrorit është më e madhe, dhe \"Bob\" nëse sipërfaqja e drejtkëndëshit është më e madhe.\n\nShembull:\n>>> compareAreas(5, 4, 6)\n    \"Alice\"\n>>> compareAreas(7, 5, 10)\n    \"Bob\"",
      "hy": "Գրեք Kotlin ֆունկցիա `fun compareAreas(a: Int, b: Int, c: Int): String` հետևյալ խնդիրը լուծելու համար:\nՀամեմատում է կողքի երկարությունը 'a' ունեցող քառակուսի մակերեսը 'b' և 'c' կողքերով ուղղանկյան մակերեսի հետ:\n  Վերադարձնում է \"Alice\", եթե քառակուսու մակերեսը մեծ է, և \"Bob\", եթե ուղղանկյան մակերեսը մեծ է:\n  \n  Օրինակ:\n  >>> compareAreas(5, 4, 6)\n      \"Alice\"\n  >>> compareAreas(7, 5, 10)\n      \"Bob\"",
      "bn": "Kotlin ফাংশন `fun compareAreas(a: Int, b: Int, c: Int): String` লিখুন নিম্নলিখিত সমস্যার সমাধানের জন্য:\nএকটি বর্গক্ষেত্রের বাহুর দৈর্ঘ্য 'a' এর ক্ষেত্রফল এবং একটি আয়তক্ষেত্রের বাহুগুলি 'b' এবং 'c' এর ক্ষেত্রফলের তুলনা করে।\n  বর্গক্ষেত্রের ক্ষেত্রফল বড় হলে \"Alice\" এবং আয়তক্ষেত্রের ক্ষেত্রফল বড় হলে \"Bob\" রিটার্ন করে।\n  \n  উদাহরণ:\n  >>> compareAreas(5, 4, 6)\n      \"Alice\"\n  >>> compareAreas(7, 5, 10)\n      \"Bob\"",
      "bg": "Напишете функция на Kotlin `fun compareAreas(a: Int, b: Int, c: Int): String`, за да решите следния проблем:\nСравнява площта на квадрат със страна 'a' с площта на правоъгълник със страни 'b' и 'c'.\nВръща \"Alice\", ако площта на квадрата е по-голяма, и \"Bob\", ако площта на правоъгълника е по-голяма.\n\nПример:\n>>> compareAreas(5, 4, 6)\n    \"Alice\"\n>>> compareAreas(7, 5, 10)\n    \"Bob\"",
      "zh": "编写一个 Kotlin 函数 `fun compareAreas(a: Int, b: Int, c: Int): String` 来解决以下问题：\n比较边长为 'a' 的正方形的面积与边长为 'b' 和 'c' 的矩形的面积。\n如果正方形的面积较大，则返回 \"Alice\"，如果矩形的面积较大，则返回 \"Bob\"。\n\n示例:\n>>> compareAreas(5, 4, 6)\n    \"Alice\"\n>>> compareAreas(7, 5, 10)\n    \"Bob\"",
      "fr": "Écrire une fonction Kotlin `fun compareAreas(a: Int, b: Int, c: Int): String` pour résoudre le problème suivant :  \nCompare l'aire d'un carré de côté 'a' à l'aire d'un rectangle avec les côtés 'b' et 'c'.  \nRetourne \"Alice\" si l'aire du carré est plus grande, et \"Bob\" si l'aire du rectangle est plus grande.  \n  \nExemple:  \n>>> compareAreas(5, 4, 6)  \n    \"Alice\"  \n>>> compareAreas(7, 5, 10)  \n    \"Bob\"",
      "de": "Schreiben Sie eine Kotlin-Funktion `fun compareAreas(a: Int, b: Int, c: Int): String`, um das folgende Problem zu lösen:\nVergleicht die Fläche eines Quadrats mit Seitenlänge 'a' mit der Fläche eines Rechtecks mit den Seiten 'b' und 'c'.\nGibt \"Alice\" zurück, wenn die Fläche des Quadrats größer ist, und \"Bob\", wenn die Fläche des Rechtecks größer ist.\n\nBeispiel:\n>>> compareAreas(5, 4, 6)\n    \"Alice\"\n>>> compareAreas(7, 5, 10)\n    \"Bob\"",
      "ha": "Rubuta wani aikin Kotlin `fun compareAreas(a: Int, b: Int, c: Int): String` don warware matsalar mai zuwa:\nKwatanta yankin wani murabba'i mai gefen tsayi 'a' da yankin wani murabba'i mai bangarori 'b' da 'c'.\n  Mayar da \"Alice\" idan yankin murabba'in ya fi girma, da \"Bob\" idan yankin murabba'in ya fi girma.\n  \n  Misali:\n  >>> compareAreas(5, 4, 6)\n      \"Alice\"\n  >>> compareAreas(7, 5, 10)\n      \"Bob\"",
      "hi": "Kotlin फ़ंक्शन `fun compareAreas(a: Int, b: Int, c: Int): String` लिखें ताकि निम्नलिखित समस्या का समाधान किया जा सके:\nएक वर्ग जिसका भुजा लंबाई 'a' है, उसके क्षेत्रफल की तुलना एक आयत के क्षेत्रफल से करें जिसकी भुजाएँ 'b' और 'c' हैं।\n  \"Alice\" लौटाएं यदि वर्ग का क्षेत्रफल बड़ा है, और \"Bob\" लौटाएं यदि आयत का क्षेत्रफल बड़ा है।\n\n  उदाहरण:\n  >>> compareAreas(5, 4, 6)\n      \"Alice\"\n  >>> compareAreas(7, 5, 10)\n      \"Bob\"",
      "hu": "Írj egy Kotlin függvényt `fun compareAreas(a: Int, b: Int, c: Int): String`, hogy megoldja a következő problémát:\nÖsszehasonlítja egy 'a' oldalhosszúságú négyzet területét egy 'b' és 'c' oldalhosszúságú téglalap területével.\n  \"Alice\"-t ad vissza, ha a négyzet területe nagyobb, és \"Bob\"-ot, ha a téglalap területe nagyobb.\n  \n  Példa:\n  >>> compareAreas(5, 4, 6)\n      \"Alice\"\n  >>> compareAreas(7, 5, 10)\n      \"Bob\""
    },
    "instruction_bertscore": {
      "sq": "0.9999996027392379",
      "hy": "0.998348587012076",
      "bn": "0.9682904473412094",
      "bg": "0.9905416185158807",
      "zh": "0.954265156136336",
      "fr": "0.9856910646110087",
      "de": "0.998348587012076",
      "ha": "0.9937699580988407",
      "hi": "0.973600234687034",
      "hu": "0.9933031767034087"
    },
    "level": "easy",
    "test": "fun main() {\n    check(compareAreas(5, 4, 6) == \"Alice\")\n    check(compareAreas(7, 5, 10) == \"Bob\")\n    // Additional test cases for edge cases\n    check(compareAreas(1, 1, 1) == \"Bob\") // Edge case where all sides are equal\n    check(compareAreas(10, 5, 20) == \"Bob\") // Test case where rectangle is clearly larger\n}\n\n\nmain()",
    "entry_point": "compareAreas",
    "signature": "fun compareAreas(a: Int, b: Int, c: Int): String",
    "docstring": {
      "en": "Compares the area of a square with side length 'a' to the area of a rectangle with sides 'b' and 'c'.\n  Returns \"Alice\" if the area of the square is larger, and \"Bob\" if the area of the rectangle is larger.\n  \n  Example:\n  >>> compareAreas(5, 4, 6)\n      \"Alice\"\n  >>> compareAreas(7, 5, 10)\n      \"Bob\"",
      "sq": "Krahason sipërfaqen e një katrori me gjatësi brinje 'a' me sipërfaqen e një drejtkëndëshi me brinjë 'b' dhe 'c'.\nKthen \"Alice\" nëse sipërfaqja e katrorit është më e madhe, dhe \"Bob\" nëse sipërfaqja e drejtkëndëshit është më e madhe.\n\nShembull:\n>>> compareAreas(5, 4, 6)\n    \"Alice\"\n>>> compareAreas(7, 5, 10)\n    \"Bob\"",
      "hy": "Համեմատում է կողքի երկարությունը 'a' ունեցող քառակուսու մակերեսը 'b' և 'c' կողմերով ուղղանկյան մակերեսի հետ: \nՎերադարձնում է \"Alice\", եթե քառակուսու մակերեսը մեծ է, և \"Bob\", եթե ուղղանկյան մակերեսը մեծ է:\n\nՕրինակ:\n>>> compareAreas(5, 4, 6)\n    \"Alice\"\n>>> compareAreas(7, 5, 10)\n    \"Bob\"",
      "bn": "একটি বর্গক্ষেত্রের বাহুর দৈর্ঘ্য 'a' এর ক্ষেত্রফল তুলনা করে একটি আয়তক্ষেত্রের বাহুর দৈর্ঘ্য 'b' এবং 'c' এর ক্ষেত্রফলের সাথে।  \n  যদি বর্গক্ষেত্রের ক্ষেত্রফল বড় হয়, তাহলে \"Alice\" ফেরত দেয়, এবং যদি আয়তক্ষেত্রের ক্ষেত্রফল বড় হয়, তাহলে \"Bob\" ফেরত দেয়।\n\n  উদাহরণ:\n  >>> compareAreas(5, 4, 6)\n      \"Alice\"\n  >>> compareAreas(7, 5, 10)\n      \"Bob\"",
      "bg": "Сравнява площта на квадрат със страна 'a' с площта на правоъгълник със страни 'b' и 'c'. Връща \"Alice\", ако площта на квадрата е по-голяма, и \"Bob\", ако площта на правоъгълника е по-голяма.\n\nПример:\n>>> compareAreas(5, 4, 6)\n    \"Alice\"\n>>> compareAreas(7, 5, 10)\n    \"Bob\"",
      "zh": "比较边长为 'a' 的正方形的面积与边长为 'b' 和 'c' 的矩形的面积。\n返回 \"Alice\" 如果正方形的面积更大，返回 \"Bob\" 如果矩形的面积更大。\n\n例子：\n>>> compareAreas(5, 4, 6)\n    \"Alice\"\n>>> compareAreas(7, 5, 10)\n    \"Bob\"",
      "fr": "Compare l'aire d'un carré avec une longueur de côté 'a' à l'aire d'un rectangle avec les côtés 'b' et 'c'.\n  Retourne \"Alice\" si l'aire du carré est plus grande, et \"Bob\" si l'aire du rectangle est plus grande.\n  \n  Exemple:\n  >>> compareAreas(5, 4, 6)\n      \"Alice\"\n  >>> compareAreas(7, 5, 10)\n      \"Bob\"",
      "de": "Vergleicht die Fläche eines Quadrats mit Seitenlänge 'a' mit der Fläche eines Rechtecks mit den Seiten 'b' und 'c'.\nGibt \"Alice\" zurück, wenn die Fläche des Quadrats größer ist, und \"Bob\", wenn die Fläche des Rechtecks größer ist.\n\nBeispiel:\n>>> compareAreas(5, 4, 6)\n    \"Alice\"\n>>> compareAreas(7, 5, 10)\n    \"Bob\"",
      "ha": "Yana kwatanta yanki na murabba'i tare da tsawon gefe 'a' da yanki na rectangle tare da gefuna 'b' da 'c'.\n  Yana dawowa \"Alice\" idan yanki na murabba'i ya fi girma, kuma \"Bob\" idan yanki na rectangle ya fi girma.\n  \n  Misali:\n  >>> compareAreas(5, 4, 6)\n      \"Alice\"\n  >>> compareAreas(7, 5, 10)\n      \"Bob\"",
      "hi": "वर्ग जिसकी भुजा लंबाई 'a' है, के क्षेत्रफल की तुलना आयत जिसकी भुजाएँ 'b' और 'c' हैं, के क्षेत्रफल से करता है। यदि वर्ग का क्षेत्रफल बड़ा है तो \"Alice\" लौटाता है, और यदि आयत का क्षेत्रफल बड़ा है तो \"Bob\" लौटाता है।\n\nउदाहरण:\n>>> compareAreas(5, 4, 6)\n    \"Alice\"\n>>> compareAreas(7, 5, 10)\n    \"Bob\"",
      "hu": "Összehasonlítja az 'a' oldalhosszúságú négyzet területét a 'b' és 'c' oldalhosszúságú téglalap területével. \n\"Alíz\"-t ad vissza, ha a négyzet területe nagyobb, és \"Bob\"-ot, ha a téglalap területe nagyobb.\n\nPélda:\n>>> compareAreas(5, 4, 6)\n    \"Alíz\"\n>>> compareAreas(7, 5, 10)\n    \"Bob\""
    },
    "docstring_bertscore": {
      "sq": "0.9943600889608953",
      "hy": "1",
      "bn": "0.9105033078474914",
      "bg": "0.9896185831352116",
      "zh": "0.9704010937700861",
      "fr": "0.9886091435387923",
      "de": "0.9984947789725176",
      "ha": "0.9782263362613366",
      "hi": "0.9427189707171589",
      "hu": "0.9770069443521634"
    }
  },
  {
    "task_id": "Kotlin/45",
    "prompt": {
      "en": "/**\n    * Finds M positive integers whose sum is N and their product is as large as possible.\n    * Outputs the lexicographically smallest sequence of these M integers.\n    * \n    * Example:\n    * >>> maxProductPartition(6, 3)\n    *     [2, 2, 2]\n    * >>> maxProductPartition(8, 3)\n    *     [2, 3, 3]\n**/\nfun maxProductPartition(N: Int, M: Int): List<Int> ",
      "sq": "/**\n    * Gjen M numra të plotë pozitivë, shuma e të cilëve është N dhe prodhimi i tyre është sa më i madh të jetë e mundur.\n    * Jep si rezultat sekuencën leksikografikisht më të vogël të këtyre M numrave të plotë.\n    * \n    * Shembull:\n    * >>> maxProductPartition(6, 3)\n    *     [2, 2, 2]\n    * >>> maxProductPartition(8, 3)\n    *     [2, 3, 3]\n**/",
      "hy": "/**\n    * Գտնում է M դրական ամբողջ թվեր, որոնց գումարը N է, և նրանց արտադրյալը հնարավորինս մեծ է:\n    * Արդյունքում տալիս է այս M թվերի լեքսիկոգրաֆիկորեն ամենափոքր հաջորդականությունը:\n    * \n    * Օրինակ:\n    * >>> maxProductPartition(6, 3)\n    *     [2, 2, 2]\n    * >>> maxProductPartition(8, 3)\n    *     [2, 3, 3]\n**/ \nfun maxProductPartition(N: Int, M: Int): List<Int> ",
      "bn": "/**\n    * এমন M ধনাত্মক পূর্ণসংখ্যা খুঁজে বের করে যাদের যোগফল N এবং তাদের গুণফল যতটা সম্ভব বড় হয়।\n    * এই M পূর্ণসংখ্যার লেক্সিকোগ্রাফিকভাবে ক্ষুদ্রতম ক্রম আউটপুট করে।\n    * \n    * উদাহরণ:\n    * >>> maxProductPartition(6, 3)\n    *     [2, 2, 2]\n    * >>> maxProductPartition(8, 3)\n    *     [2, 3, 3]\n**/",
      "bg": "/**\n    * Намира M положителни цели числа, чиято сума е N и произведението им е възможно най-голямо.\n    * Извежда лексикографски най-малката последователност от тези M числа.\n    * \n    * Пример:\n    * >>> maxProductPartition(6, 3)\n    *     [2, 2, 2]\n    * >>> maxProductPartition(8, 3)\n    *     [2, 3, 3]\n**/\nfun maxProductPartition(N: Int, M: Int): List<Int> ",
      "zh": "/**\n    * 找到 M 个正整数，它们的和为 N，并且它们的乘积尽可能大。\n    * 输出这些 M 个整数的字典序最小的序列。\n    * \n    * 示例:\n    * >>> maxProductPartition(6, 3)\n    *     [2, 2, 2]\n    * >>> maxProductPartition(8, 3)\n    *     [2, 3, 3]\n**/\nfun maxProductPartition(N: Int, M: Int): List<Int> ",
      "fr": "/**\n    * Trouve M entiers positifs dont la somme est N et dont le produit est le plus grand possible.\n    * Renvoie la séquence lexicographiquement la plus petite de ces M entiers.\n    * \n    * Exemple :\n    * >>> maxProductPartition(6, 3)\n    *     [2, 2, 2]\n    * >>> maxProductPartition(8, 3)\n    *     [2, 3, 3]\n**/\nfun maxProductPartition(N: Int, M: Int): List<Int> ",
      "de": "/**\n    * Findet M positive ganze Zahlen, deren Summe N ist und deren Produkt so groß wie möglich ist.\n    * Gibt die lexikographisch kleinste Sequenz dieser M ganzen Zahlen aus.\n    * \n    * Beispiel:\n    * >>> maxProductPartition(6, 3)\n    *     [2, 2, 2]\n    * >>> maxProductPartition(8, 3)\n    *     [2, 3, 3]\n**/\nfun maxProductPartition(N: Int, M: Int): List<Int> ",
      "ha": "/**\n    * Nemo lambobi masu kyau M waɗanda jimlarsu ita ce N kuma samfurin su ya kasance mafi girma yadda zai yiwu.\n    * Fitar da jerin mafi ƙarancin tsari na waɗannan lambobi M.\n    * \n    * Misali:\n    * >>> maxProductPartition(6, 3)\n    *     [2, 2, 2]\n    * >>> maxProductPartition(8, 3)\n    *     [2, 3, 3]\n**/\nfun maxProductPartition(N: Int, M: Int): List<Int> ",
      "hi": "/**\n    * ऐसे M धनात्मक पूर्णांक खोजता है जिनका योग N है और उनका गुणनफल यथासंभव बड़ा है।\n    * इन M पूर्णांकों के शब्दकोशानुक्रम में सबसे छोटे अनुक्रम को आउटपुट करता है।\n    * \n    * उदाहरण:\n    * >>> maxProductPartition(6, 3)\n    *     [2, 2, 2]\n    * >>> maxProductPartition(8, 3)\n    *     [2, 3, 3]\n**/\nfun maxProductPartition(N: Int, M: Int): List<Int> ",
      "hu": "/**\n    * Megkeresi azt az M pozitív egész számot, amelyek összege N és szorzatuk a lehető legnagyobb.\n    * Kimenetként az M egész szám lexicoográfiailag legkisebb sorozatát adja vissza.\n    * \n    * Példa:\n    * >>> maxProductPartition(6, 3)\n    *     [2, 2, 2]\n    * >>> maxProductPartition(8, 3)\n    *     [2, 3, 3]\n**/ \nfun maxProductPartition(N: Int, M: Int): List<Int> "
    },
    "prompt_bertscore": {
      "sq": "0.911479576170278",
      "hy": "0.9873357241659776",
      "bn": "0.9169748842919891",
      "bg": "0.9955220766899495",
      "zh": "0.9865425930545053",
      "fr": "0.9681591526593454",
      "de": "0.9950096103068795",
      "ha": "0.936154633884718",
      "hi": "0.9938531842284943",
      "hu": "0.9553133286570571"
    },
    "canonical_solution": "{\n    val base = N / M\n    val remainder = N % M\n    val result = MutableList(M) { base }\n    for (i in 0 until remainder) {\n        result[i] += 1\n    }\n    result.sort() // Ensures lexicographically smallest sequence\n    return result\n}",
    "instruction": {
      "en": "Write a Kotlin function `fun maxProductPartition(N: Int, M: Int): List<Int>` to solve the following problem:\nFinds M positive integers whose sum is N and their product is as large as possible.\n     Outputs the lexicographically smallest sequence of these M integers.\n     \n     Example:\n     >>> maxProductPartition(6, 3)\n         [2, 2, 2]\n     >>> maxProductPartition(8, 3)\n         [2, 3, 3]",
      "sq": "Shkruani një funksion Kotlin `fun maxProductPartition(N: Int, M: Int): List<Int>` për të zgjidhur problemin e mëposhtëm:\nGjen M numra të plotë pozitivë, shuma e të cilëve është N dhe prodhimi i tyre është sa më i madh të jetë e mundur.\n     Jep sekuencën leksikografikisht më të vogël të këtyre M numrave.\n     \n     Shembull:\n     >>> maxProductPartition(6, 3)\n         [2, 2, 2]\n     >>> maxProductPartition(8, 3)\n         [2, 3, 3]",
      "hy": "Գրեք Kotlin ֆունկցիա `fun maxProductPartition(N: Int, M: Int): List<Int>` հետևյալ խնդիրը լուծելու համար:\nԳտնում է M դրական ամբողջ թվեր, որոնց գումարը N է և նրանց արտադրյալը հնարավորինս մեծ է:\n     Արդյունքում տալիս է այս M թվերի լեքսիկոգրաֆիկորեն ամենափոքր հաջորդականությունը.\n     \n     Օրինակ:\n     >>> maxProductPartition(6, 3)\n         [2, 2, 2]\n     >>> maxProductPartition(8, 3)\n         [2, 3, 3]",
      "bn": "একটি Kotlin ফাংশন `fun maxProductPartition(N: Int, M: Int): List<Int>` লিখুন নিম্নলিখিত সমস্যার সমাধানের জন্য:\nM টি ধনাত্মক পূর্ণসংখ্যা খুঁজে বের করুন যাদের যোগফল N এবং তাদের গুণফল যত বড় সম্ভব হয়।\n     এই M পূর্ণসংখ্যার লেক্সিকোগ্রাফিকভাবে ক্ষুদ্রতম ক্রম আউটপুট করে।\n     \n     উদাহরণ:\n     >>> maxProductPartition(6, 3)\n         [2, 2, 2]\n     >>> maxProductPartition(8, 3)\n         [2, 3, 3]",
      "bg": "Напишете Kotlin функция `fun maxProductPartition(N: Int, M: Int): List<Int>` за решаване на следния проблем:\nНамира M положителни цели числа, чиято сума е N и произведението им е възможно най-голямо.\n     Извежда лексикографски най-малката последователност от тези M цели числа.\n     \n     Пример:\n     >>> maxProductPartition(6, 3)\n         [2, 2, 2]\n     >>> maxProductPartition(8, 3)\n         [2, 3, 3]",
      "zh": "编写一个 Kotlin 函数 `fun maxProductPartition(N: Int, M: Int): List<Int>` 来解决以下问题：\n寻找 M 个正整数，它们的和为 N，并且它们的乘积尽可能大。\n     输出这些 M 个整数的字典序最小序列。\n     \n     示例：\n     >>> maxProductPartition(6, 3)\n         [2, 2, 2]\n     >>> maxProductPartition(8, 3)\n         [2, 3, 3]",
      "fr": "Écrire une fonction Kotlin `fun maxProductPartition(N: Int, M: Int): List<Int>` pour résoudre le problème suivant :\nTrouver M entiers positifs dont la somme est N et dont le produit est aussi grand que possible.\n     Produit la séquence lexicographiquement la plus petite de ces M entiers.\n     \n     Exemple:\n     >>> maxProductPartition(6, 3)\n         [2, 2, 2]\n     >>> maxProductPartition(8, 3)\n         [2, 3, 3]",
      "de": "Schreiben Sie eine Kotlin-Funktion `fun maxProductPartition(N: Int, M: Int): List<Int>`, um das folgende Problem zu lösen:\nFindet M positive ganze Zahlen, deren Summe N ist und deren Produkt so groß wie möglich ist.\n     Gibt die lexikographisch kleinste Sequenz dieser M Zahlen aus.\n     \n     Beispiel:\n     >>> maxProductPartition(6, 3)\n         [2, 2, 2]\n     >>> maxProductPartition(8, 3)\n         [2, 3, 3]",
      "ha": "Rubuta aikin Kotlin `fun maxProductPartition(N: Int, M: Int): List<Int>` don warware matsalar mai zuwa:  \nNemo lambobi M masu kyau waɗanda jimlarsu ita ce N kuma samfurinsu ya kasance mafi girma gwargwadon yiwuwa.  \n     Fitar da jerin mafi ƙarancin jerin waɗannan lambobin M.",
      "hi": "Kotlin फ़ंक्शन `fun maxProductPartition(N: Int, M: Int): List<Int>` लिखें ताकि निम्नलिखित समस्या का समाधान किया जा सके:\nऐसे M धनात्मक पूर्णांक खोजें जिनका योग N हो और उनका गुणनफल यथासंभव बड़ा हो।\n     इन M पूर्णांकों का शब्दकोश क्रम में सबसे छोटा अनुक्रम आउटपुट करें।\n     \n     उदाहरण:\n     >>> maxProductPartition(6, 3)\n         [2, 2, 2]\n     >>> maxProductPartition(8, 3)\n         [2, 3, 3]",
      "hu": "Írj egy Kotlin függvényt `fun maxProductPartition(N: Int, M: Int): List<Int>` a következő probléma megoldására:\nM pozitív egész számot talál, amelyek összege N, és szorzatuk a lehető legnagyobb.\n     A kimenet ezeknek az M egész számnak a lexikografikusan legkisebb sorozata.\n     \n     Példa:\n     >>> maxProductPartition(6, 3)\n         [2, 2, 2]\n     >>> maxProductPartition(8, 3)\n         [2, 3, 3]"
    },
    "instruction_bertscore": {
      "sq": "0.9745898112453498",
      "hy": "0.9792494813540473",
      "bn": "0.9858042839281986",
      "bg": "0.9954072683297113",
      "zh": "0.9865388190772656",
      "fr": "0.9843515013213094",
      "de": "0.9788200424702499",
      "ha": "0.8490877871834092",
      "hi": "0.9561968365919002",
      "hu": "0.9849025019983002"
    },
    "level": "easy",
    "test": "fun main() {\n    check(maxProductPartition(6, 3) == listOf(2, 2, 2))\n    check(maxProductPartition(8, 3) == listOf(2, 3, 3))\n    check(maxProductPartition(10, 2) == listOf(5, 5))\n    check(maxProductPartition(7, 3) == listOf(2, 2, 3))\n}\n\nmain()",
    "entry_point": "maxProductPartition",
    "signature": "fun maxProductPartition(N: Int, M: Int): List<Int>",
    "docstring": {
      "en": "Finds M positive integers whose sum is N and their product is as large as possible.\n     Outputs the lexicographically smallest sequence of these M integers.\n     \n     Example:\n     >>> maxProductPartition(6, 3)\n         [2, 2, 2]\n     >>> maxProductPartition(8, 3)\n         [2, 3, 3]",
      "sq": "Gjen M numra të plotë pozitivë, shuma e të cilëve është N dhe prodhimi i tyre është sa më i madh që të jetë e mundur.\n     Jep sekuencën më të vogël leksikografike të këtyre M numrave.\n     \n     Shembull:\n     >>> maxProductPartition(6, 3)\n         [2, 2, 2]\n     >>> maxProductPartition(8, 3)\n         [2, 3, 3]",
      "hy": "Գտնում է M դրական ամբողջ թվեր, որոնց գումարը N է և նրանց արտադրյալը հնարավորինս մեծ է:\n     Արդյունքում տալիս է այս M թվերի լեքսիկոգրաֆիկորեն ամենափոքր հաջորդականությունը:\n     \n     Օրինակ:\n     >>> maxProductPartition(6, 3)\n         [2, 2, 2]\n     >>> maxProductPartition(8, 3)\n         [2, 3, 3]",
      "bn": "M টি ধনাত্মক পূর্ণসংখ্যা খুঁজে বের করে যাদের যোগফল N এবং তাদের গুণফল যতটা সম্ভব বড় হয়। \n     এই M সংখ্যার লেক্সিকোগ্রাফিক্যালি ক্ষুদ্রতম ক্রম আউটপুট করে।\n\n     উদাহরণ:\n     >>> maxProductPartition(6, 3)\n         [2, 2, 2]\n     >>> maxProductPartition(8, 3)\n         [2, 3, 3]",
      "bg": "Намира M положителни цели числа, чиято сума е N и чийто произведение е възможно най-голямо.\n     Извежда лексикографски най-малката последователност от тези M числа.\n     \n     Пример:\n     >>> maxProductPartition(6, 3)\n         [2, 2, 2]\n     >>> maxProductPartition(8, 3)\n         [2, 3, 3]",
      "zh": "找到 M 个正整数，它们的和为 N，并且它们的乘积尽可能大。\n     输出这些 M 个整数的字典序最小的序列。\n     \n     示例：\n     >>> maxProductPartition(6, 3)\n         [2, 2, 2]\n     >>> maxProductPartition(8, 3)\n         [2, 3, 3]",
      "fr": "Trouve M entiers positifs dont la somme est N et dont le produit est aussi grand que possible.\n     Renvoie la plus petite séquence lexicographique de ces M entiers.\n     \n     Exemple :\n     >>> maxProductPartition(6, 3)\n         [2, 2, 2]\n     >>> maxProductPartition(8, 3)\n         [2, 3, 3]",
      "de": "Findet M positive ganze Zahlen, deren Summe N ist und deren Produkt so groß wie möglich ist.\n     Gibt die lexikografisch kleinste Sequenz dieser M ganzen Zahlen aus.\n     \n     Beispiel:\n     >>> maxProductPartition(6, 3)\n         [2, 2, 2]\n     >>> maxProductPartition(8, 3)\n         [2, 3, 3]",
      "ha": "Yana nemo lambobi masu kyau M waɗanda jimlarsu ita ce N kuma samfurinsu yana da girma sosai.\n     Yana fitar da jerin mafi ƙarancin tsari na waɗannan lambobin M.\n     \n     Misali:\n     >>> maxProductPartition(6, 3)\n         [2, 2, 2]\n     >>> maxProductPartition(8, 3)\n         [2, 3, 3]",
      "hi": "M सकारात्मक पूर्णांकों को खोजता है जिनका योग N है और उनका गुणनफल यथासंभव बड़ा है।\n     इन M पूर्णांकों के अनुक्रम को शब्दकोशीय रूप से सबसे छोटा आउटपुट करता है।\n     \n     उदाहरण:\n     >>> maxProductPartition(6, 3)\n         [2, 2, 2]\n     >>> maxProductPartition(8, 3)\n         [2, 3, 3]",
      "hu": "Megkeresi azt az M pozitív egész számot, amelyek összege N, és amelyek szorzata a lehető legnagyobb.\n     A kimenet ezeknek az M egész számoknak a lexikografikusan legkisebb sorozata.\n     \n     Példa:\n     >>> maxProductPartition(6, 3)\n         [2, 2, 2]\n     >>> maxProductPartition(8, 3)\n         [2, 3, 3]"
    },
    "docstring_bertscore": {
      "sq": "0.9593026212297617",
      "hy": "0.9708492039097009",
      "bn": "0.975985388302501",
      "bg": "0.9761472720630444",
      "zh": "0.9836106100000493",
      "fr": "0.9648259362351989",
      "de": "0.9554811713290315",
      "ha": "0.8803494283329661",
      "hi": "0.9539769434534543",
      "hu": "0.9474795450594221"
    }
  },
  {
    "task_id": "Kotlin/46",
    "prompt": {
      "en": "/**\n * Calculates the number of characters in the essay title, excluding spaces and newline characters.\n * \n * Example:\n * >>> countTitleCharacters(\"234\")\n *     3\n * >>> countTitleCharacters(\"Ca 45\")\n *     4\n * \n * The function counts uppercase and lowercase English letters, digits, but ignores spaces and newline characters.\n */\nfun countTitleCharacters(title: String): Int ",
      "sq": "/**\n * Llogarit numrin e karaktereve në titullin e esesë, duke përjashtuar hapësirat dhe karakteret e reja rresht.\n * \n * Shembull:\n * >>> countTitleCharacters(\"234\")\n *     3\n * >>> countTitleCharacters(\"Ca 45\")\n *     4\n * \n * Funksioni numëron shkronjat e mëdha dhe të vogla të anglishtes, shifrat, por injoron hapësirat dhe karakteret e reja rresht.\n */\nfun countTitleCharacters(title: String): Int ",
      "hy": "/**\n * Հաշվում է շարադրանքի վերնագրում գտնվող սիմվոլների քանակը՝ բացի բացատներից և նոր տողի սիմվոլներից։\n * \n * Օրինակ:\n * >>> countTitleCharacters(\"234\")\n *     3\n * >>> countTitleCharacters(\"Ca 45\")\n *     4\n * \n * Ֆունկցիան հաշվում է մեծատառ և փոքրատառ անգլերեն տառերը, թվանշանները, բայց անտեսում է բացատները և նոր տողի սիմվոլները։\n */",
      "bn": "/**\n * প্রবন্ধের শিরোনামে কতগুলি অক্ষর আছে তা গণনা করে, স্পেস এবং নতুন লাইন অক্ষর বাদ দিয়ে।\n * \n * উদাহরণ:\n * >>> countTitleCharacters(\"234\")\n *     3\n * >>> countTitleCharacters(\"Ca 45\")\n *     4\n * \n * ফাংশনটি বড় হাতের এবং ছোট হাতের ইংরেজি অক্ষর, সংখ্যা গণনা করে, কিন্তু স্পেস এবং নতুন লাইন অক্ষর উপেক্ষা করে।\n */\nfun countTitleCharacters(title: String): Int ",
      "bg": "/**\n * Изчислява броя на символите в заглавието на есето, без да включва интервали и знаци за нов ред.\n * \n * Пример:\n * >>> countTitleCharacters(\"234\")\n *     3\n * >>> countTitleCharacters(\"Ca 45\")\n *     4\n * \n * Функцията брои главни и малки английски букви, цифри, но игнорира интервали и знаци за нов ред.\n */\nfun countTitleCharacters(title: String): Int ",
      "zh": "/**\n * 计算文章标题中的字符数，不包括空格和换行符。\n * \n * 示例:\n * >>> countTitleCharacters(\"234\")\n *     3\n * >>> countTitleCharacters(\"Ca 45\")\n *     4\n * \n * 该函数计算大写和小写的英文字母、数字，但忽略空格和换行符。\n */ \nfun countTitleCharacters(title: String): Int ",
      "fr": "/**\n * Calcule le nombre de caractères dans le titre de l'essai, à l'exclusion des espaces et des caractères de nouvelle ligne.\n * \n * Exemple :\n * >>> countTitleCharacters(\"234\")\n *     3\n * >>> countTitleCharacters(\"Ca 45\")\n *     4\n * \n * La fonction compte les lettres anglaises majuscules et minuscules, les chiffres, mais ignore les espaces et les caractères de nouvelle ligne.\n */\nfun countTitleCharacters(title: String): Int ",
      "de": "/**\n * Berechnet die Anzahl der Zeichen im Aufsatztitel, ohne Leerzeichen und Zeilenumbrüche.\n * \n * Beispiel:\n * >>> countTitleCharacters(\"234\")\n *     3\n * >>> countTitleCharacters(\"Ca 45\")\n *     4\n * \n * Die Funktion zählt Groß- und Kleinbuchstaben des englischen Alphabets, Ziffern, ignoriert jedoch Leerzeichen und Zeilenumbrüche.\n */ \nfun countTitleCharacters(title: String): Int ",
      "ha": "/**\n * Lissafa yawan haruffa a cikin taken rubutu, ba tare da ƙidaya sarari da haruffan sabon layi ba.\n * \n * Misali:\n * >>> countTitleCharacters(\"234\")\n *     3\n * >>> countTitleCharacters(\"Ca 45\")\n *     4\n * \n * Aikin yana ƙidaya manyan da ƙananan haruffan Ingilishi, lambobi, amma yana watsi da sarari da haruffan sabon layi.\n */",
      "hi": "/**\n * निबंध शीर्षक में वर्णों की संख्या की गणना करता है, जिसमें स्पेस और नई पंक्ति के वर्ण शामिल नहीं होते हैं।\n * \n * उदाहरण:\n * >>> countTitleCharacters(\"234\")\n *     3\n * >>> countTitleCharacters(\"Ca 45\")\n *     4\n * \n * यह फ़ंक्शन अपरकेस और लोअरकेस अंग्रेजी अक्षरों, अंकों की गणना करता है, लेकिन स्पेस और नई पंक्ति के वर्णों को अनदेखा करता है।\n */",
      "hu": "/**\n * Kiszámítja az esszé címében található karakterek számát, a szóközök és az új sor karakterek kivételével.\n * \n * Példa:\n * >>> countTitleCharacters(\"234\")\n *     3\n * >>> countTitleCharacters(\"Ca 45\")\n *     4\n * \n * A függvény számolja a nagy- és kisbetűs angol betűket, számjegyeket, de figyelmen kívül hagyja a szóközöket és az új sor karaktereket.\n */\nfun countTitleCharacters(title: String): Int "
    },
    "prompt_bertscore": {
      "sq": "0.9956434398527618",
      "hy": "0.9475790588803206",
      "bn": "0.9407286942991894",
      "bg": "1",
      "zh": "0.9828931570637512",
      "fr": "1",
      "de": "0.9614835828135249",
      "ha": "0.9258949774435039",
      "hi": "0.9529822025052316",
      "hu": "1"
    },
    "canonical_solution": "{\n    return title.count { it != ' ' && it != '\\n' }\n}",
    "instruction": {
      "en": "Write a Kotlin function `fun countTitleCharacters(title: String): Int` to solve the following problem:\nCalculates the number of characters in the essay title, excluding spaces and newline characters.\n  \n  Example:\n  >>> countTitleCharacters(\"234\")\n      3\n  >>> countTitleCharacters(\"Ca 45\")\n      4\n  \n  The function counts uppercase and lowercase English letters, digits, but ignores spaces and newline characters.",
      "sq": "Shkruani një funksion Kotlin `fun countTitleCharacters(title: String): Int` për të zgjidhur problemin e mëposhtëm:\nLlogarit numrin e karaktereve në titullin e esesë, duke përjashtuar hapësirat dhe karakteret e reja të rreshtit.\n  \n  Shembull:\n  >>> countTitleCharacters(\"234\")\n      3\n  >>> countTitleCharacters(\"Ca 45\")\n      4\n  \n  Funksioni numëron shkronjat e mëdha dhe të vogla të anglishtes, shifrat, por injoron hapësirat dhe karakteret e reja të rreshtit.",
      "hy": "Գրեք Kotlin ֆունկցիա `fun countTitleCharacters(title: String): Int` հետևյալ խնդիրը լուծելու համար:\nՀաշվում է շարադրության վերնագրի մեջ գտնվող սիմվոլների քանակը, բացառելով բացատներն ու նոր տողերը։\n\n  Օրինակ:\n  >>> countTitleCharacters(\"234\")\n      3\n  >>> countTitleCharacters(\"Ca 45\")\n      4\n  \n  Ֆունկցիան հաշվում է մեծատառ և փոքրատառ անգլերեն տառերը, թվանշանները, բայց անտեսում է բացատներն ու նոր տողերը։",
      "bn": "Kotlin ফাংশন `fun countTitleCharacters(title: String): Int` লিখুন নিম্নলিখিত সমস্যার সমাধানের জন্য:\nপ্রবন্ধের শিরোনামে কতগুলি অক্ষর আছে তা গণনা করে, স্পেস এবং নতুন লাইন অক্ষর বাদ দিয়ে।\n\n  উদাহরণ:\n  >>> countTitleCharacters(\"234\")\n      3\n  >>> countTitleCharacters(\"Ca 45\")\n      4\n  \n  ফাংশনটি বড় হাতের এবং ছোট হাতের ইংরেজি অক্ষর, সংখ্যা গণনা করে, কিন্তু স্পেস এবং নতুন লাইন অক্ষর উপেক্ষা করে।",
      "bg": "Напишете Kotlin функция `fun countTitleCharacters(title: String): Int`, за да решите следния проблем:  \nИзчислява броя на символите в заглавието на есето, като изключва интервалите и символите за нов ред.\n\n  Пример:\n  >>> countTitleCharacters(\"234\")\n      3\n  >>> countTitleCharacters(\"Ca 45\")\n      4\n\n  Функцията брои главни и малки английски букви, цифри, но игнорира интервалите и символите за нов ред.",
      "zh": "编写一个 Kotlin 函数 `fun countTitleCharacters(title: String): Int` 来解决以下问题：\n计算文章标题中的字符数量，排除空格和换行符。\n\n例子:\n>>> countTitleCharacters(\"234\")\n    3\n>>> countTitleCharacters(\"Ca 45\")\n    4\n\n该函数计算大写和小写的英文字母、数字，但忽略空格和换行符。",
      "fr": "Écrire une fonction Kotlin `fun countTitleCharacters(title: String): Int` pour résoudre le problème suivant :  \nCalcule le nombre de caractères dans le titre de l'essai, en excluant les espaces et les caractères de nouvelle ligne.\n\n  Exemple :\n  >>> countTitleCharacters(\"234\")\n      3\n  >>> countTitleCharacters(\"Ca 45\")\n      4\n  \n  La fonction compte les lettres majuscules et minuscules anglaises, les chiffres, mais ignore les espaces et les caractères de nouvelle ligne.",
      "de": "Schreiben Sie eine Kotlin-Funktion `fun countTitleCharacters(title: String): Int`, um das folgende Problem zu lösen:\nBerechnet die Anzahl der Zeichen im Aufsatztitel, ohne Leerzeichen und Zeilenumbrüche zu berücksichtigen.\n  \n  Beispiel:\n  >>> countTitleCharacters(\"234\")\n      3\n  >>> countTitleCharacters(\"Ca 45\")\n      4\n  \n  Die Funktion zählt Groß- und Kleinbuchstaben des englischen Alphabets, Ziffern, ignoriert jedoch Leerzeichen und Zeilenumbrüche.",
      "ha": "Rubuta aikin Kotlin `fun countTitleCharacters(title: String): Int` don warware matsalar mai zuwa:\nƘididdige yawan haruffa a cikin taken rubutun, banda sarari da haruffan sabon layi.\n\n  Misali:\n  >>> countTitleCharacters(\"234\")\n      3\n  >>> countTitleCharacters(\"Ca 45\")\n      4\n  \n  Aikin yana ƙididdige manyan da ƙananan haruffan Ingilishi, lambobi, amma yana watsi da sarari da haruffan sabon layi.",
      "hi": "Kotlin फ़ंक्शन `fun countTitleCharacters(title: String): Int` लिखें ताकि निम्नलिखित समस्या का समाधान किया जा सके:\nनिबंध शीर्षक में वर्णों की संख्या की गणना करता है, जिसमें रिक्त स्थान और नई पंक्ति के वर्ण शामिल नहीं होते।\n\n  उदाहरण:\n  >>> countTitleCharacters(\"234\")\n      3\n  >>> countTitleCharacters(\"Ca 45\")\n      4\n  \n  फ़ंक्शन अपरकेस और लोअरकेस अंग्रेजी अक्षरों, अंकों की गणना करता है, लेकिन रिक्त स्थान और नई पंक्ति के वर्णों को अनदेखा करता है।",
      "hu": "Írj egy Kotlin függvényt `fun countTitleCharacters(title: String): Int` a következő probléma megoldására:\nKiszámítja az esszé címében lévő karakterek számát, a szóközök és az új sor karakterek kivételével.\n  \n  Példa:\n  >>> countTitleCharacters(\"234\")\n      3\n  >>> countTitleCharacters(\"Ca 45\")\n      4\n  \n  A függvény számolja a nagy- és kisbetűs angol betűket, számjegyeket, de figyelmen kívül hagyja a szóközöket és az új sor karaktereket."
    },
    "instruction_bertscore": {
      "sq": "0.998143600458848",
      "hy": "0.960248896365012",
      "bn": "0.9558105005007874",
      "bg": "0.9999996027392379",
      "zh": "0.9819188750447752",
      "fr": "0.9893265964750902",
      "de": "0.9625941252738909",
      "ha": "0.9735255496637649",
      "hi": "0.9713000948746501",
      "hu": "0.9999996027392379"
    },
    "level": "easy",
    "test": "fun main() {\n    check(countTitleCharacters(\"234\") == 3)\n    check(countTitleCharacters(\"Ca\\n45\") == 4)\n    check(countTitleCharacters(\"Hello, World!\") == 12) // Assuming \",\" is considered a valid character\n    check(countTitleCharacters(\"A B C D E\") == 5)\n    check(countTitleCharacters(\"\\n\\n\\n\\n\") == 0)\n}\n\n\nmain()",
    "entry_point": "countTitleCharacters",
    "signature": "fun countTitleCharacters(title: String): Int",
    "docstring": {
      "en": "Calculates the number of characters in the essay title, excluding spaces and newline characters.\n  \n  Example:\n  >>> countTitleCharacters(\"234\")\n      3\n  >>> countTitleCharacters(\"Ca 45\")\n      4\n  \n  The function counts uppercase and lowercase English letters, digits, but ignores spaces and newline characters.",
      "sq": "Llogarit numrin e karaktereve në titullin e esesë, duke përjashtuar hapësirat dhe karakteret e rreshtave të rinj.\n\n  Shembull:\n  >>> countTitleCharacters(\"234\")\n      3\n  >>> countTitleCharacters(\"Ca 45\")\n      4\n  \n  Funksioni numëron shkronjat e mëdha dhe të vogla të anglishtes, shifrat, por injoron hapësirat dhe karakteret e rreshtave të rinj.",
      "hy": "Հաշվում է շարադրանքի վերնագրի նիշերի քանակը՝ բացի բացատներից և նոր տողերի նիշերից։\n\n  Օրինակ:\n  >>> countTitleCharacters(\"234\")\n      3\n  >>> countTitleCharacters(\"Ca 45\")\n      4\n  \n  Ֆունկցիան հաշվում է մեծատառ և փոքրատառ անգլերեն տառերը, թվերը, բայց անտեսում է բացատներն ու նոր տողերի նիշերը։",
      "bn": "অ্যাসে শিরোনামের অক্ষরের সংখ্যা গণনা করে, ফাঁকা স্থান এবং নতুন লাইন অক্ষর বাদ দিয়ে।\n\nউদাহরণ:\n>>> countTitleCharacters(\"234\")\n    3\n>>> countTitleCharacters(\"Ca 45\")\n    4\n\nফাংশনটি বড় হাতের এবং ছোট হাতের ইংরেজি অক্ষর, সংখ্যা গণনা করে, কিন্তু ফাঁকা স্থান এবং নতুন লাইন অক্ষর উপেক্ষা করে।",
      "bg": "Изчислява броя на символите в заглавието на есето, без да включва интервали и нови редове.\n\n  Пример:\n  >>> countTitleCharacters(\"234\")\n      3\n  >>> countTitleCharacters(\"Ca 45\")\n      4\n  \n  Функцията брои главни и малки английски букви, цифри, но игнорира интервали и нови редове.",
      "zh": "计算文章标题中的字符数，不包括空格和换行符。\n\n示例：\n>>> countTitleCharacters(\"234\")\n    3\n>>> countTitleCharacters(\"Ca 45\")\n    4\n\n该函数计算大写和小写的英文字母、数字，但忽略空格和换行符。",
      "fr": "Calcule le nombre de caractères dans le titre de l'essai, à l'exclusion des espaces et des caractères de nouvelle ligne.\n\n  Exemple :\n  >>> countTitleCharacters(\"234\")\n      3\n  >>> countTitleCharacters(\"Ca 45\")\n      4\n  \n  La fonction compte les lettres majuscules et minuscules anglaises, les chiffres, mais ignore les espaces et les caractères de nouvelle ligne.",
      "de": "Berechnet die Anzahl der Zeichen im Aufsatztitel, ohne Leerzeichen und Zeilenumbrüche.\n\n  Beispiel:\n  >>> countTitleCharacters(\"234\")\n      3\n  >>> countTitleCharacters(\"Ca 45\")\n      4\n  \n  Die Funktion zählt Groß- und Kleinbuchstaben des englischen Alphabets, Ziffern, ignoriert jedoch Leerzeichen und Zeilenumbrüche.",
      "ha": "Yana ƙididdige yawan haruffa a cikin taken rubutu, ba tare da haɗa sarari da haruffan sabon layi ba.\n\n  Misali:\n  >>> countTitleCharacters(\"234\")\n      3\n  >>> countTitleCharacters(\"Ca 45\")\n      4\n  \n  Aikin yana ƙididdige manyan da ƙananan haruffan Ingilishi, lambobi, amma yana watsi da sarari da haruffan sabon layi.",
      "hi": "किसी निबंध के शीर्षक में वर्णों की संख्या की गणना करता है, जिसमें रिक्त स्थान और नई पंक्ति के वर्ण शामिल नहीं होते।\n\n  उदाहरण:\n  >>> countTitleCharacters(\"234\")\n      3\n  >>> countTitleCharacters(\"Ca 45\")\n      4\n\n  यह फ़ंक्शन बड़े और छोटे अंग्रेजी अक्षरों, अंकों की गणना करता है, लेकिन रिक्त स्थान और नई पंक्ति के वर्णों को अनदेखा करता है।",
      "hu": "Számolja ki az esszé címében lévő karakterek számát, a szóközök és az új sor karakterek kivételével.\n\nPélda:\n>>> countTitleCharacters(\"234\")\n    3\n>>> countTitleCharacters(\"Ca 45\")\n    4\n\nA függvény számolja a nagy- és kisbetűs angol betűket, számjegyeket, de figyelmen kívül hagyja a szóközöket és az új sor karaktereket."
    },
    "docstring_bertscore": {
      "sq": "0.9956402617666652",
      "hy": "0.9651042173990287",
      "bn": "0.9644417850782774",
      "bg": "0.9724539387580817",
      "zh": "0.9644803193721981",
      "fr": "0.9917929899164005",
      "de": "0.9480436553415612",
      "ha": "0.9605249925946504",
      "hi": "0.9722858974557262",
      "hu": "0.9956402617666652"
    }
  },
  {
    "task_id": "Kotlin/47",
    "prompt": {
      "en": "/**\n * Counts the number of students who have enrolled in both courses A and B.\n * The function takes two lists as arguments: the first list contains the IDs of students enrolled in course A,\n * and the second list contains the IDs of students enrolled in course B.\n * \n * Example:\n * >>> countCommonStudents(listOf(1, 2, 3, 4, 5), listOf(1, 3, 4, 5, 6))\n *     4\n * >>> countCommonStudents(listOf(10, 11, 12), listOf(12, 13, 14))\n *     1\n */\nfun countCommonStudents(aStudents: List<Int>, bStudents: List<Int>): Int ",
      "sq": "/**\n * Numëron numrin e studentëve që janë regjistruar në të dyja kurset A dhe B.\n * Funksioni merr dy lista si argumente: lista e parë përmban ID-të e studentëve të regjistruar në kursin A,\n * dhe lista e dytë përmban ID-të e studentëve të regjistruar në kursin B.\n * \n * Shembull:\n * >>> countCommonStudents(listOf(1, 2, 3, 4, 5), listOf(1, 3, 4, 5, 6))\n *     4\n * >>> countCommonStudents(listOf(10, 11, 12), listOf(12, 13, 14))\n *     1\n */",
      "hy": "/**\n * Հաշվում է այն ուսանողների քանակը, ովքեր գրանցվել են և՛ A, և՛ B դասընթացներում:\n * Ֆունկցիան ընդունում է երկու ցուցակ որպես արգումենտներ՝ առաջին ցուցակը պարունակում է A դասընթացում գրանցված ուսանողների ID-ները,\n * իսկ երկրորդ ցուցակը պարունակում է B դասընթացում գրանցված ուսանողների ID-ները:\n * \n * Օրինակ:\n * >>> countCommonStudents(listOf(1, 2, 3, 4, 5), listOf(1, 3, 4, 5, 6))\n *     4\n * >>> countCommonStudents(listOf(10, 11, 12), listOf(12, 13, 14))\n *     1\n */",
      "bn": "/**\n * কতজন ছাত্র উভয় কোর্স A এবং B-তে ভর্তি হয়েছে তা গণনা করে।\n * ফাংশনটি দুটি তালিকা আর্গুমেন্ট হিসাবে নেয়: প্রথম তালিকায় কোর্স A-তে ভর্তি হওয়া ছাত্রদের আইডি রয়েছে,\n * এবং দ্বিতীয় তালিকায় কোর্স B-তে ভর্তি হওয়া ছাত্রদের আইডি রয়েছে।\n * \n * উদাহরণ:\n * >>> countCommonStudents(listOf(1, 2, 3, 4, 5), listOf(1, 3, 4, 5, 6))\n *     4\n * >>> countCommonStudents(listOf(10, 11, 12), listOf(12, 13, 14))\n *     1\n */",
      "bg": "/**\n * Брои броя на студентите, които са записани и в двата курса A и B.\n * Функцията приема два списъка като аргументи: първият списък съдържа ID-тата на студентите, записани в курс A,\n * а вторият списък съдържа ID-тата на студентите, записани в курс B.\n * \n * Пример:\n * >>> countCommonStudents(listOf(1, 2, 3, 4, 5), listOf(1, 3, 4, 5, 6))\n *     4\n * >>> countCommonStudents(listOf(10, 11, 12), listOf(12, 13, 14))\n *     1\n */",
      "zh": "/**\n * 计算同时注册了课程A和课程B的学生人数。\n * 该函数接受两个列表作为参数：第一个列表包含注册课程A的学生ID，\n * 第二个列表包含注册课程B的学生ID。\n * \n * 示例:\n * >>> countCommonStudents(listOf(1, 2, 3, 4, 5), listOf(1, 3, 4, 5, 6))\n *     4\n * >>> countCommonStudents(listOf(10, 11, 12), listOf(12, 13, 14))\n *     1\n */",
      "fr": "/**\n * Compte le nombre d'étudiants qui se sont inscrits aux deux cours A et B.\n * La fonction prend deux listes comme arguments : la première liste contient les IDs des étudiants inscrits au cours A,\n * et la deuxième liste contient les IDs des étudiants inscrits au cours B.\n * \n * Exemple:\n * >>> countCommonStudents(listOf(1, 2, 3, 4, 5), listOf(1, 3, 4, 5, 6))\n *     4\n * >>> countCommonStudents(listOf(10, 11, 12), listOf(12, 13, 14))\n *     1\n */",
      "de": "/**\n * Zählt die Anzahl der Studenten, die sich in beiden Kursen A und B eingeschrieben haben.\n * Die Funktion nimmt zwei Listen als Argumente: die erste Liste enthält die IDs der in Kurs A eingeschriebenen Studenten,\n * und die zweite Liste enthält die IDs der in Kurs B eingeschriebenen Studenten.\n * \n * Beispiel:\n * >>> countCommonStudents(listOf(1, 2, 3, 4, 5), listOf(1, 3, 4, 5, 6))\n *     4\n * >>> countCommonStudents(listOf(10, 11, 12), listOf(12, 13, 14))\n *     1\n */",
      "ha": "/**\n * Yana ƙididdige yawan ɗaliban da suka yi rijista a duka darussa A da B.\n * Aikin yana ɗaukar jerin abubuwa guda biyu a matsayin hujjoji: jerin farko yana ɗauke da lambar ID na ɗaliban da suka yi rijista a darasi A,\n * kuma jerin na biyu yana ɗauke da lambar ID na ɗaliban da suka yi rijista a darasi B.\n * \n * Misali:\n * >>> countCommonStudents(listOf(1, 2, 3, 4, 5), listOf(1, 3, 4, 5, 6))\n *     4\n * >>> countCommonStudents(listOf(10, 11, 12), listOf(12, 13, 14))\n *     1\n */\nfun countCommonStudents(aStudents: List<Int>, bStudents: List<Int>): Int ",
      "hi": "/**\n * गणना करता है कि कितने छात्र दोनों पाठ्यक्रम A और B में नामांकित हैं।\n * यह फ़ंक्शन दो सूचियों को तर्क के रूप में लेता है: पहली सूची में पाठ्यक्रम A में नामांकित छात्रों के आईडी होते हैं,\n * और दूसरी सूची में पाठ्यक्रम B में नामांकित छात्रों के आईडी होते हैं।\n * \n * उदाहरण:\n * >>> countCommonStudents(listOf(1, 2, 3, 4, 5), listOf(1, 3, 4, 5, 6))\n *     4\n * >>> countCommonStudents(listOf(10, 11, 12), listOf(12, 13, 14))\n *     1\n */\nfun countCommonStudents(aStudents: List<Int>, bStudents: List<Int>): Int ",
      "hu": "/**\n * Megszámolja azoknak a diákoknak a számát, akik mindkét A és B kurzusra beiratkoztak.\n * A függvény két listát vesz át argumentumként: az első lista az A kurzusra beiratkozott diákok azonosítóit tartalmazza,\n * a második lista pedig a B kurzusra beiratkozott diákok azonosítóit.\n * \n * Példa:\n * >>> countCommonStudents(listOf(1, 2, 3, 4, 5), listOf(1, 3, 4, 5, 6))\n *     4\n * >>> countCommonStudents(listOf(10, 11, 12), listOf(12, 13, 14))\n *     1\n */"
    },
    "prompt_bertscore": {
      "sq": "0.9582602089900907",
      "hy": "0.9554708425492178",
      "bn": "0.9404490227226923",
      "bg": "0.9582602089900907",
      "zh": "0.9213191293556032",
      "fr": "0.9595934161075969",
      "de": "0.9582602089900907",
      "ha": "0.9773142255516244",
      "hi": "0.982111546514379",
      "hu": "0.9582602089900907"
    },
    "canonical_solution": "{\n    val aSet = aStudents.toSet()\n    val bSet = bStudents.toSet()\n    return aSet.intersect(bSet).size\n}",
    "instruction": {
      "en": "Write a Kotlin function `fun countCommonStudents(aStudents: List<Int>, bStudents: List<Int>): Int` to solve the following problem:\nCounts the number of students who have enrolled in both courses A and B.\n  The function takes two lists as arguments: the first list contains the IDs of students enrolled in course A,\n  and the second list contains the IDs of students enrolled in course B.\n  \n  Example:\n  >>> countCommonStudents(listOf(1, 2, 3, 4, 5), listOf(1, 3, 4, 5, 6))\n      4\n  >>> countCommonStudents(listOf(10, 11, 12), listOf(12, 13, 14))\n      1",
      "sq": "Shkruani një funksion Kotlin `fun countCommonStudents(aStudents: List<Int>, bStudents: List<Int>): Int` për të zgjidhur problemin e mëposhtëm:\nNumëron numrin e studentëve që janë regjistruar në të dyja kurset A dhe B.\n  Funksioni merr dy lista si argumente: lista e parë përmban ID-të e studentëve të regjistruar në kursin A,\n  dhe lista e dytë përmban ID-të e studentëve të regjistruar në kursin B.\n  \n  Shembull:\n  >>> countCommonStudents(listOf(1, 2, 3, 4, 5), listOf(1, 3, 4, 5, 6))\n      4\n  >>> countCommonStudents(listOf(10, 11, 12), listOf(12, 13, 14))\n      1",
      "hy": "Գրեք Kotlin ֆունկցիա `fun countCommonStudents(aStudents: List<Int>, bStudents: List<Int>): Int` հետևյալ խնդիրը լուծելու համար:\nՀաշվում է այն ուսանողների քանակը, ովքեր գրանցվել են և՛ A, և՛ B դասընթացներում:\n  Ֆունկցիան ընդունում է երկու ցուցակ որպես արգումենտներ: Առաջին ցուցակը պարունակում է A դասընթացում գրանցված ուսանողների ID-ները,\n  իսկ երկրորդ ցուցակը պարունակում է B դասընթացում գրանցված ուսանողների ID-ները:\n  \n  Օրինակ:\n  >>> countCommonStudents(listOf(1, 2, 3, 4, 5), listOf(1, 3, 4, 5, 6))\n      4\n  >>> countCommonStudents(listOf(10, 11, 12), listOf(12, 13, 14))\n      1",
      "bn": "Kotlin ফাংশন `fun countCommonStudents(aStudents: List<Int>, bStudents: List<Int>): Int` লিখুন নিম্নলিখিত সমস্যার সমাধানের জন্য:\nগণনা করে কতজন ছাত্র উভয় কোর্স A এবং B-তে ভর্তি হয়েছে।\n  ফাংশনটি দুটি তালিকা আর্গুমেন্ট হিসেবে নেয়: প্রথম তালিকায় কোর্স A-তে ভর্তি হওয়া ছাত্রদের আইডি থাকে,\n  এবং দ্বিতীয় তালিকায় কোর্স B-তে ভর্তি হওয়া ছাত্রদের আইডি থাকে।\n  \n  উদাহরণ:\n  >>> countCommonStudents(listOf(1, 2, 3, 4, 5), listOf(1, 3, 4, 5, 6))\n      4\n  >>> countCommonStudents(listOf(10, 11, 12), listOf(12, 13, 14))\n      1",
      "bg": "Напишете функция на Kotlin `fun countCommonStudents(aStudents: List<Int>, bStudents: List<Int>): Int`, за да решите следния проблем:\nБрои броя на студентите, които са записани и в двата курса A и B.\nФункцията приема два списъка като аргументи: първият списък съдържа идентификаторите на студентите, записани в курс A,\nа вторият списък съдържа идентификаторите на студентите, записани в курс B.\n\nПример:\n>>> countCommonStudents(listOf(1, 2, 3, 4, 5), listOf(1, 3, 4, 5, 6))\n    4\n>>> countCommonStudents(listOf(10, 11, 12), listOf(12, 13, 14))\n    1",
      "zh": "编写一个 Kotlin 函数 `fun countCommonStudents(aStudents: List<Int>, bStudents: List<Int>): Int` 来解决以下问题：\n计算同时注册了课程 A 和课程 B 的学生人数。\n函数接受两个列表作为参数：第一个列表包含注册课程 A 的学生 ID，第二个列表包含注册课程 B 的学生 ID。\n\n例子:\n>>> countCommonStudents(listOf(1, 2, 3, 4, 5), listOf(1, 3, 4, 5, 6))\n    4\n>>> countCommonStudents(listOf(10, 11, 12), listOf(12, 13, 14))\n    1",
      "fr": "Écrire une fonction Kotlin `fun countCommonStudents(aStudents: List<Int>, bStudents: List<Int>): Int` pour résoudre le problème suivant :  \nCompte le nombre d'étudiants qui se sont inscrits aux deux cours A et B.  \nLa fonction prend deux listes comme arguments : la première liste contient les IDs des étudiants inscrits au cours A,  \net la deuxième liste contient les IDs des étudiants inscrits au cours B.  \n  \nExemple :  \n>>> countCommonStudents(listOf(1, 2, 3, 4, 5), listOf(1, 3, 4, 5, 6))  \n    4  \n>>> countCommonStudents(listOf(10, 11, 12), listOf(12, 13, 14))  \n    1",
      "de": "Schreiben Sie eine Kotlin-Funktion `fun countCommonStudents(aStudents: List<Int>, bStudents: List<Int>): Int`, um das folgende Problem zu lösen:\nZählt die Anzahl der Studenten, die sich sowohl in Kurs A als auch in Kurs B eingeschrieben haben.\n  Die Funktion nimmt zwei Listen als Argumente: Die erste Liste enthält die IDs der Studenten, die in Kurs A eingeschrieben sind,\n  und die zweite Liste enthält die IDs der Studenten, die in Kurs B eingeschrieben sind.\n  \n  Beispiel:\n  >>> countCommonStudents(listOf(1, 2, 3, 4, 5), listOf(1, 3, 4, 5, 6))\n      4\n  >>> countCommonStudents(listOf(10, 11, 12), listOf(12, 13, 14))\n      1",
      "ha": "Rubuta aikin Kotlin `fun countCommonStudents(aStudents: List<Int>, bStudents: List<Int>): Int` don warware matsalar mai zuwa:\nƘididdige yawan ɗaliban da suka yi rajista a duka darussan A da B.\n  Aikin yana ɗaukar jerin abubuwa guda biyu a matsayin hujjoji: jerin farko yana ɗauke da ID na ɗaliban da suka yi rajista a darasin A,\n  kuma jerin na biyu yana ɗauke da ID na ɗaliban da suka yi rajista a darasin B.\n  \n  Misali:\n  >>> countCommonStudents(listOf(1, 2, 3, 4, 5), listOf(1, 3, 4, 5, 6))\n      4\n  >>> countCommonStudents(listOf(10, 11, 12), listOf(12, 13, 14))\n      1",
      "hi": "Kotlin फ़ंक्शन `fun countCommonStudents(aStudents: List<Int>, bStudents: List<Int>): Int` लिखें ताकि निम्नलिखित समस्या का समाधान किया जा सके:\nउन छात्रों की संख्या गिनें जिन्होंने दोनों पाठ्यक्रम A और B में नामांकन किया है।\n  फ़ंक्शन दो सूचियों को तर्क के रूप में लेता है: पहली सूची में पाठ्यक्रम A में नामांकित छात्रों की IDs होती हैं,\n  और दूसरी सूची में पाठ्यक्रम B में नामांकित छात्रों की IDs होती हैं।\n  \n  उदाहरण:\n  >>> countCommonStudents(listOf(1, 2, 3, 4, 5), listOf(1, 3, 4, 5, 6))\n      4\n  >>> countCommonStudents(listOf(10, 11, 12), listOf(12, 13, 14))\n      1",
      "hu": "Írj egy Kotlin függvényt `fun countCommonStudents(aStudents: List<Int>, bStudents: List<Int>): Int` a következő probléma megoldására:\nMegszámolja azon diákok számát, akik mindkét A és B kurzusra beiratkoztak.\n  A függvény két listát vesz át argumentumként: az első lista az A kurzusra beiratkozott diákok azonosítóit tartalmazza,\n  a második lista pedig a B kurzusra beiratkozott diákok azonosítóit tartalmazza.\n  \n  Példa:\n  >>> countCommonStudents(listOf(1, 2, 3, 4, 5), listOf(1, 3, 4, 5, 6))\n      4\n  >>> countCommonStudents(listOf(10, 11, 12), listOf(12, 13, 14))\n      1"
    },
    "instruction_bertscore": {
      "sq": "0.9948900348174965",
      "hy": "0.993042772273872",
      "bn": "0.9704769705756414",
      "bg": "0.9829527461780617",
      "zh": "0.972711959623046",
      "fr": "0.9918921064765369",
      "de": "0.9844432685573475",
      "ha": "0.969216263547213",
      "hi": "0.9807610585537228",
      "hu": "0.9984246624480123"
    },
    "level": "easy",
    "test": "fun main() {\n    check(countCommonStudents(listOf(1, 2, 3, 4, 5), listOf(1, 3, 4, 5, 6)) == 4)\n    check(countCommonStudents(listOf(10, 11, 12), listOf(12, 13, 14)) == 1)\n    check(countCommonStudents(listOf(1, 2, 3), listOf(4, 5, 6)) == 0)\n    check(countCommonStudents(listOf(1, 2, 3, 4), listOf(2, 4)) == 2)\n}\n\n\nmain()",
    "entry_point": "countCommonStudents",
    "signature": "fun countCommonStudents(aStudents: List<Int>, bStudents: List<Int>): Int",
    "docstring": {
      "en": "Counts the number of students who have enrolled in both courses A and B.\n  The function takes two lists as arguments: the first list contains the IDs of students enrolled in course A,\n  and the second list contains the IDs of students enrolled in course B.\n  \n  Example:\n  >>> countCommonStudents(listOf(1, 2, 3, 4, 5), listOf(1, 3, 4, 5, 6))\n      4\n  >>> countCommonStudents(listOf(10, 11, 12), listOf(12, 13, 14))\n      1",
      "sq": "Numëron numrin e studentëve që janë regjistruar në të dy kurset A dhe B. Funksioni merr dy lista si argumente: lista e parë përmban ID-të e studentëve të regjistruar në kursin A, dhe lista e dytë përmban ID-të e studentëve të regjistruar në kursin B.\n\nShembull:\n>>> countCommonStudents(listOf(1, 2, 3, 4, 5), listOf(1, 3, 4, 5, 6))\n    4\n>>> countCommonStudents(listOf(10, 11, 12), listOf(12, 13, 14))\n    1",
      "hy": "Հաշվում է այն ուսանողների քանակը, ովքեր գրանցվել են և՛ Ա, և՛ Բ դասընթացներում:\n  Ֆունկցիան ընդունում է երկու ցուցակ որպես արգումենտներ. առաջին ցուցակը պարունակում է Ա դասընթացում գրանցված ուսանողների ID-ները,\n  իսկ երկրորդ ցուցակը պարունակում է Բ դասընթացում գրանցված ուսանողների ID-ները:\n  \n  Օրինակ:\n  >>> countCommonStudents(listOf(1, 2, 3, 4, 5), listOf(1, 3, 4, 5, 6))\n      4\n  >>> countCommonStudents(listOf(10, 11, 12), listOf(12, 13, 14))\n      1",
      "bn": "কতজন ছাত্র উভয় কোর্স A এবং B-তে ভর্তি হয়েছে তা গণনা করে।\nফাংশনটি দুটি তালিকা আর্গুমেন্ট হিসেবে গ্রহণ করে: প্রথম তালিকায় কোর্স A-তে ভর্তি হওয়া শিক্ষার্থীদের আইডি থাকে, এবং দ্বিতীয় তালিকায় কোর্স B-তে ভর্তি হওয়া শিক্ষার্থীদের আইডি থাকে।\n\nউদাহরণ:\n>>> countCommonStudents(listOf(1, 2, 3, 4, 5), listOf(1, 3, 4, 5, 6))\n      4\n>>> countCommonStudents(listOf(10, 11, 12), listOf(12, 13, 14))\n      1",
      "bg": "Брои броя на студентите, които са записани и в двата курса A и B. \nФункцията приема два списъка като аргументи: първият списък съдържа ID-та на студентите, записани в курс A, \nа вторият списък съдържа ID-та на студентите, записани в курс B.\n\nПример:\n>>> countCommonStudents(listOf(1, 2, 3, 4, 5), listOf(1, 3, 4, 5, 6))\n    4\n>>> countCommonStudents(listOf(10, 11, 12), listOf(12, 13, 14))\n    1",
      "zh": "计算同时注册了课程A和课程B的学生人数。\n该函数接受两个列表作为参数：第一个列表包含注册课程A的学生ID，第二个列表包含注册课程B的学生ID。\n\n示例：\n>>> countCommonStudents(listOf(1, 2, 3, 4, 5), listOf(1, 3, 4, 5, 6))\n    4\n>>> countCommonStudents(listOf(10, 11, 12), listOf(12, 13, 14))\n    1",
      "fr": "Compte le nombre d'étudiants qui se sont inscrits à la fois aux cours A et B.\n  La fonction prend deux listes comme arguments : la première liste contient les identifiants des étudiants inscrits au cours A,\n  et la deuxième liste contient les identifiants des étudiants inscrits au cours B.\n  \n  Exemple :\n  >>> countCommonStudents(listOf(1, 2, 3, 4, 5), listOf(1, 3, 4, 5, 6))\n      4\n  >>> countCommonStudents(listOf(10, 11, 12), listOf(12, 13, 14))\n      1",
      "de": "Zählt die Anzahl der Studenten, die sich in beide Kurse A und B eingeschrieben haben.  \nDie Funktion nimmt zwei Listen als Argumente: die erste Liste enthält die IDs der Studenten, die in Kurs A eingeschrieben sind,  \nund die zweite Liste enthält die IDs der Studenten, die in Kurs B eingeschrieben sind.\n\nBeispiel:\n>>> countCommonStudents(listOf(1, 2, 3, 4, 5), listOf(1, 3, 4, 5, 6))\n    4\n>>> countCommonStudents(listOf(10, 11, 12), listOf(12, 13, 14))\n    1",
      "ha": "Yana ƙidaya yawan ɗaliban da suka yi rajista a cikin duka darussan A da B. \n  Aikin yana ɗaukar jerin abubuwa biyu a matsayin hujjoji: jerin farko yana ƙunshe da ID na ɗaliban da suka yi rajista a darasi A, \n  kuma jerin na biyu yana ƙunshe da ID na ɗaliban da suka yi rajista a darasi B.\n\n  Misali:\n  >>> countCommonStudents(listOf(1, 2, 3, 4, 5), listOf(1, 3, 4, 5, 6))\n      4\n  >>> countCommonStudents(listOf(10, 11, 12), listOf(12, 13, 14))\n      1",
      "hi": "दोनों पाठ्यक्रम A और B में नामांकित छात्रों की संख्या गिनता है। \nयह फ़ंक्शन दो सूचियों को तर्क के रूप में लेता है: पहली सूची में पाठ्यक्रम A में नामांकित छात्रों की ID होती है, \nऔर दूसरी सूची में पाठ्यक्रम B में नामांकित छात्रों की ID होती है।\n\nउदाहरण:\n>>> countCommonStudents(listOf(1, 2, 3, 4, 5), listOf(1, 3, 4, 5, 6))\n    4\n>>> countCommonStudents(listOf(10, 11, 12), listOf(12, 13, 14))\n    1",
      "hu": "Számolja meg azon diákok számát, akik mindkét A és B kurzusra beiratkoztak.\n  A függvény két listát vesz át argumentumként: az első lista az A kurzusra beiratkozott diákok azonosítóit tartalmazza,\n  a második lista pedig a B kurzusra beiratkozott diákok azonosítóit.\n\n  Példa:\n  >>> countCommonStudents(listOf(1, 2, 3, 4, 5), listOf(1, 3, 4, 5, 6))\n      4\n  >>> countCommonStudents(listOf(10, 11, 12), listOf(12, 13, 14))\n      1"
    },
    "docstring_bertscore": {
      "sq": "0.9977060177294281",
      "hy": "0.9977060177294281",
      "bn": "0.9928457309358854",
      "bg": "0.9977060177294281",
      "zh": "0.9559825144107637",
      "fr": "0.999999801369619",
      "de": "0.9910153519746489",
      "ha": "0.9688762083348813",
      "hi": "0.9889215891281602",
      "hu": "0.9926312101243677"
    }
  },
  {
    "task_id": "Kotlin/48",
    "prompt": {
      "en": "/**\n * Calculates the number of whole apples left after a given time has passed, \n * assuming each apple is eaten one after another and each takes a certain amount of time to eat.\n * \n * @param appleCount The total number of apples initially available.\n * @param timePerApple The time in minutes it takes to eat a single apple.\n * @param timePassed The time in minutes that has elapsed.\n * @return The number of whole apples remaining.\n * \n * Example:\n * >>> remainingApples(50, 10, 200)\n *     30\n * >>> remainingApples(5, 5, 3)\n *     4\n */\nfun remainingApples(appleCount: Int, timePerApple: Int, timePassed: Int): Int ",
      "sq": "/**\n * Llogarit numrin e mollëve të plota të mbetura pasi ka kaluar një kohë e caktuar,\n * duke supozuar se çdo mollë hahet njëra pas tjetrës dhe secila merr një kohë të caktuar për t'u ngrënë.\n * \n * @param appleCount Numri total i mollëve fillimisht të disponueshme.\n * @param timePerApple Koha në minuta që duhet për të ngrënë një mollë të vetme.\n * @param timePassed Koha në minuta që ka kaluar.\n * @return Numri i mollëve të plota të mbetura.\n * \n * Shembull:\n * >>> remainingApples(50, 10, 200)\n *     30\n * >>> remainingApples(5, 5, 3)\n *     4\n */\nfun remainingApples(appleCount: Int, timePerApple: Int, timePassed: Int): Int ",
      "hy": "/**\n * Հաշվում է ամբողջ խնձորների քանակը, որոնք մնացել են որոշակի ժամանակ անց, \n * ենթադրելով, որ յուրաքանչյուր խնձոր ուտվում է մեկը մյուսի հետևից, և յուրաքանչյուրի ուտելու համար պահանջվում է որոշակի ժամանակ:\n * \n * @param appleCount Սկզբում առկա խնձորների ընդհանուր քանակը:\n * @param timePerApple Ժամանակը րոպեներով, որը պահանջվում է մեկ խնձոր ուտելու համար:\n * @param timePassed Ժամանակը րոպեներով, որը անցել է:\n * @return Մնացած ամբողջ խնձորների քանակը:\n * \n * Օրինակ:\n * >>> remainingApples(50, 10, 200)\n *     30\n * >>> remainingApples(5, 5, 3)\n *     4\n */",
      "bn": "/**\n * একটি নির্দিষ্ট সময় অতিবাহিত হওয়ার পরে কতগুলি সম্পূর্ণ আপেল অবশিষ্ট থাকবে তা গণনা করে,\n * ধরে নেওয়া হয় যে প্রতিটি আপেল একের পর এক খাওয়া হয় এবং প্রতিটি আপেল খেতে একটি নির্দিষ্ট সময় লাগে।\n * \n * @param appleCount প্রাথমিকভাবে উপলব্ধ আপেলের মোট সংখ্যা।\n * @param timePerApple একটি আপেল খেতে যে সময় লাগে তা মিনিটে।\n * @param timePassed যে সময়টি অতিবাহিত হয়েছে তা মিনিটে।\n * @return অবশিষ্ট সম্পূর্ণ আপেলের সংখ্যা।\n * \n * উদাহরণ:\n * >>> remainingApples(50, 10, 200)\n *     30\n * >>> remainingApples(5, 5, 3)\n *     4\n */",
      "bg": "/**\n * Изчислява броя на целите ябълки, останали след изтичане на дадено време,\n * като се предполага, че всяка ябълка се изяжда една след друга и всяка отнема определено време за ядене.\n * \n * @param appleCount Общият брой ябълки, налични първоначално.\n * @param timePerApple Времето в минути, необходимо за изяждане на една ябълка.\n * @param timePassed Времето в минути, което е изминало.\n * @return Броят на останалите цели ябълки.\n * \n * Пример:\n * >>> remainingApples(50, 10, 200)\n *     30\n * >>> remainingApples(5, 5, 3)\n *     4\n */",
      "zh": "/**\n * 计算在给定时间过去后剩余的整个苹果数量，\n * 假设每个苹果一个接一个被吃掉，并且每个苹果需要一定的时间来吃。\n * \n * @param appleCount 初始可用的苹果总数。\n * @param timePerApple 吃一个苹果所需的时间（分钟）。\n * @param timePassed 已经过的时间（分钟）。\n * @return 剩余的整个苹果数量。\n * \n * 示例:\n * >>> remainingApples(50, 10, 200)\n *     30\n * >>> remainingApples(5, 5, 3)\n *     4\n */",
      "fr": "/**\n * Calcule le nombre de pommes entières restantes après qu'un certain temps se soit écoulé,\n * en supposant que chaque pomme est mangée l'une après l'autre et que chacune prend un certain temps à manger.\n * \n * @param appleCount Le nombre total de pommes initialement disponibles.\n * @param timePerApple Le temps en minutes qu'il faut pour manger une seule pomme.\n * @param timePassed Le temps en minutes qui s'est écoulé.\n * @return Le nombre de pommes entières restantes.\n * \n * Exemple:\n * >>> remainingApples(50, 10, 200)\n *     30\n * >>> remainingApples(5, 5, 3)\n *     4\n */",
      "de": "/**\n * Berechnet die Anzahl der ganzen Äpfel, die nach einer bestimmten Zeit übrig sind,\n * wobei angenommen wird, dass jeder Apfel nacheinander gegessen wird und das Essen eines jeden eine bestimmte Zeit dauert.\n * \n * @param appleCount Die anfängliche Gesamtanzahl der verfügbaren Äpfel.\n * @param timePerApple Die Zeit in Minuten, die benötigt wird, um einen einzelnen Apfel zu essen.\n * @param timePassed Die Zeit in Minuten, die vergangen ist.\n * @return Die Anzahl der verbleibenden ganzen Äpfel.\n * \n * Beispiel:\n * >>> remainingApples(50, 10, 200)\n *     30\n * >>> remainingApples(5, 5, 3)\n *     4\n */\nfun remainingApples(appleCount: Int, timePerApple: Int, timePassed: Int): Int",
      "ha": "/**\n * Lissafa adadin tuffaɗi cikakku da suka rage bayan wani lokaci ya wuce,\n * ana ɗauka kowanne tuffaɗi ana ci ɗaya bayan ɗaya kuma kowanne yana ɗaukar wani lokaci don ci.\n * \n * @param appleCount Jimillar adadin tuffaɗi da ake da su a farko.\n * @param timePerApple Lokacin a cikin mintuna da ake ɗauka don cin tuffaɗi guda ɗaya.\n * @param timePassed Lokacin a cikin mintuna da ya wuce.\n * @return Adadin tuffaɗi cikakku da suka rage.\n * \n * Misali:\n * >>> remainingApples(50, 10, 200)\n *     30\n * >>> remainingApples(5, 5, 3)\n *     4\n */\nfun remainingApples(appleCount: Int, timePerApple: Int, timePassed: Int): Int ",
      "hi": "/**\n * यह गणना करता है कि दिए गए समय के बाद कितने पूरे सेब बचे हैं,\n * यह मानते हुए कि प्रत्येक सेब एक के बाद एक खाया जाता है और प्रत्येक को खाने में एक निश्चित समय लगता है।\n * \n * @param appleCount प्रारंभ में उपलब्ध सेबों की कुल संख्या।\n * @param timePerApple एक सेब को खाने में लगने वाला समय (मिनटों में)।\n * @param timePassed वह समय (मिनटों में) जो बीत चुका है।\n * @return बचे हुए पूरे सेबों की संख्या।\n * \n * उदाहरण:\n * >>> remainingApples(50, 10, 200)\n *     30\n * >>> remainingApples(5, 5, 3)\n *     4\n */",
      "hu": "/**\n * Kiszámítja, hogy hány egész alma marad egy adott idő elteltével, \n * feltételezve, hogy minden almát egymás után esznek meg, és mindegyik elfogyasztása bizonyos időt vesz igénybe.\n * \n * @param appleCount Az eredetileg rendelkezésre álló almák teljes száma.\n * @param timePerApple Az idő percben, amennyi egyetlen alma elfogyasztásához szükséges.\n * @param timePassed Az eltelt idő percben.\n * @return A megmaradt egész almák száma.\n * \n * Példa:\n * >>> remainingApples(50, 10, 200)\n *     30\n * >>> remainingApples(5, 5, 3)\n *     4\n */"
    },
    "prompt_bertscore": {
      "sq": "0.9811273329763511",
      "hy": "0.9213548828241894",
      "bn": "0.9236280089047527",
      "bg": "0.9331517397842325",
      "zh": "0.8928951218295107",
      "fr": "0.9392419458971433",
      "de": "0.9723659454992832",
      "ha": "0.8966093113244821",
      "hi": "0.9021874483150848",
      "hu": "0.9263430875831187"
    },
    "canonical_solution": "{\n    if (timePerApple == 0) return 0\n    // Calculate the number of apples that have been eaten\n    val applesEaten = timePassed / timePerApple\n\n    // If there is a partially eaten apple, adjust the count of eaten apples\n    val isPartialApple = timePassed % timePerApple != 0\n\n    // Calculate the number of whole apples remaining, considering partial apple if any\n    val remaining = if (isPartialApple) appleCount - applesEaten - 1 else appleCount - applesEaten\n\n    // Return the remaining apples, ensuring the result is not negative\n    return if (remaining >= 0) remaining else 0\n}",
    "instruction": {
      "en": "Write a Kotlin function `fun remainingApples(appleCount: Int, timePerApple: Int, timePassed: Int): Int` to solve the following problem:\nCalculates the number of whole apples left after a given time has passed, \n  assuming each apple is eaten one after another and each takes a certain amount of time to eat.\n  \n  @param appleCount The total number of apples initially available.\n  @param timePerApple The time in minutes it takes to eat a single apple.\n  @param timePassed The time in minutes that has elapsed.\n  @return The number of whole apples remaining.\n  \n  Example:\n  >>> remainingApples(50, 10, 200)\n      30\n  >>> remainingApples(5, 5, 3)\n      4",
      "sq": "Shkruani një funksion Kotlin `fun remainingApples(appleCount: Int, timePerApple: Int, timePassed: Int): Int` për të zgjidhur problemin e mëposhtëm:  \nLlogarit numrin e mollëve të plota të mbetura pasi ka kaluar një kohë e caktuar,  \nduke supozuar se secila mollë hahet njëra pas tjetrës dhe secila merr një kohë të caktuar për t'u ngrënë.\n\n@param appleCount Numri total i mollëve fillimisht të disponueshme.  \n@param timePerApple Koha në minuta që duhet për të ngrënë një mollë të vetme.  \n@param timePassed Koha në minuta që ka kaluar.  \n@return Numri i mollëve të plota të mbetura.  \n\nShembull:  \n>>> remainingApples(50, 10, 200)  \n      30  \n>>> remainingApples(5, 5, 3)  \n      4  ",
      "hy": "Գրեք Kotlin ֆունկցիա `fun remainingApples(appleCount: Int, timePerApple: Int, timePassed: Int): Int` հետևյալ խնդիրը լուծելու համար:\nՀաշվում է ամբողջ խնձորների քանակը, որոնք մնացել են որոշակի ժամանակ անց, \n  ենթադրելով, որ յուրաքանչյուր խնձոր ուտվում է մեկը մյուսի հետևից և յուրաքանչյուրը ուտելու համար պահանջվում է որոշակի ժամանակ:\n  \n  @param appleCount Սկզբում առկա խնձորների ընդհանուր քանակը:\n  @param timePerApple Ժամանակը րոպեներով, որը պահանջվում է մեկ խնձոր ուտելու համար:\n  @param timePassed Ժամանակը րոպեներով, որը անցել է:\n  @return Մնացած ամբողջ խնձորների քանակը:\n  \n  Օրինակ:\n  >>> remainingApples(50, 10, 200)\n      30\n  >>> remainingApples(5, 5, 3)\n      4",
      "bn": "Kotlin ফাংশন `fun remainingApples(appleCount: Int, timePerApple: Int, timePassed: Int): Int` লিখুন নিম্নলিখিত সমস্যার সমাধানের জন্য:\nযে সময় পেরিয়ে গেছে তার পরে কতগুলি সম্পূর্ণ আপেল অবশিষ্ট রয়েছে তা গণনা করে, \n  ধরে নেওয়া হয় যে প্রতিটি আপেল একের পর এক খাওয়া হয় এবং প্রতিটি আপেল খেতে নির্দিষ্ট পরিমাণ সময় লাগে।\n  \n  @param appleCount প্রাথমিকভাবে উপলব্ধ আপেলের মোট সংখ্যা।\n  @param timePerApple একটি আপেল খেতে যে সময় লাগে তা মিনিটে।\n  @param timePassed যে সময় পেরিয়ে গেছে তা মিনিটে।\n  @return অবশিষ্ট সম্পূর্ণ আপেলের সংখ্যা।\n  \n  উদাহরণ:\n  >>> remainingApples(50, 10, 200)\n      30\n  >>> remainingApples(5, 5, 3)\n      4",
      "bg": "Напишете функция на Kotlin `fun remainingApples(appleCount: Int, timePerApple: Int, timePassed: Int): Int`, за да решите следния проблем:\nИзчислява броя на целите ябълки, останали след като е изминало определено време, \n  като се предполага, че всяка ябълка се изяжда една след друга и всяка отнема определено време за ядене.\n  \n  @param appleCount Общият брой на ябълките, които първоначално са налични.\n  @param timePerApple Времето в минути, необходимо за изяждане на една ябълка.\n  @param timePassed Времето в минути, което е изминало.\n  @return Броят на останалите цели ябълки.\n  \n  Пример:\n  >>> remainingApples(50, 10, 200)\n      30\n  >>> remainingApples(5, 5, 3)\n      4",
      "zh": "编写一个 Kotlin 函数 `fun remainingApples(appleCount: Int, timePerApple: Int, timePassed: Int): Int` 来解决以下问题：\n计算经过给定时间后剩余的完整苹果数量，假设每个苹果一个接一个地吃，每个苹果需要一定的时间来吃。\n\n@param appleCount 初始可用的苹果总数。\n@param timePerApple 吃一个苹果所需的时间（分钟）。\n@param timePassed 已经过的时间（分钟）。\n@return 剩余的完整苹果数量。\n\n示例:\n>>> remainingApples(50, 10, 200)\n    30\n>>> remainingApples(5, 5, 3)\n    4",
      "fr": "Écrivez une fonction Kotlin `fun remainingApples(appleCount: Int, timePerApple: Int, timePassed: Int): Int` pour résoudre le problème suivant :\nCalcule le nombre de pommes entières restantes après qu'un certain temps s'est écoulé,\n  en supposant que chaque pomme est mangée l'une après l'autre et que chacune prend un certain temps à manger.\n  \n  @param appleCount Le nombre total de pommes initialement disponibles.\n  @param timePerApple Le temps en minutes qu'il faut pour manger une seule pomme.\n  @param timePassed Le temps en minutes qui s'est écoulé.\n  @return Le nombre de pommes entières restantes.\n  \n  Exemple :\n  >>> remainingApples(50, 10, 200)\n      30\n  >>> remainingApples(5, 5, 3)\n      4",
      "de": "Schreiben Sie eine Kotlin-Funktion `fun remainingApples(appleCount: Int, timePerApple: Int, timePassed: Int): Int`, um das folgende Problem zu lösen:\nBerechnet die Anzahl der ganzen Äpfel, die übrig sind, nachdem eine bestimmte Zeit vergangen ist,\n  wobei angenommen wird, dass jeder Apfel nacheinander gegessen wird und jeder eine bestimmte Zeit zum Essen benötigt.\n  \n  @param appleCount Die anfängliche Gesamtanzahl der verfügbaren Äpfel.\n  @param timePerApple Die Zeit in Minuten, die benötigt wird, um einen einzelnen Apfel zu essen.\n  @param timePassed Die Zeit in Minuten, die vergangen ist.\n  @return Die Anzahl der verbleibenden ganzen Äpfel.\n  \n  Beispiel:\n  >>> remainingApples(50, 10, 200)\n      30\n  >>> remainingApples(5, 5, 3)\n      4",
      "ha": "Rubuta aikin Kotlin `fun remainingApples(appleCount: Int, timePerApple: Int, timePassed: Int): Int` don warware matsalar mai zuwa:\nYana ƙididdige adadin cikakkun tuffa da suka rage bayan wani lokaci ya wuce, \n  yana ɗauka kowanne tuffa ana ci ɗaya bayan ɗaya kuma kowanne yana ɗaukar wani lokaci don ci.\n  \n  @param appleCount Jimillar adadin tuffa da ake da su a farko.\n  @param timePerApple Lokacin a mintuna da ake ɗauka don cin tuffa guda ɗaya.\n  @param timePassed Lokacin a mintuna da ya shude.\n  @return Adadin cikakkun tuffa da suka rage.\n  \n  Misali:\n  >>> remainingApples(50, 10, 200)\n      30\n  >>> remainingApples(5, 5, 3)\n      4",
      "hi": "Kotlin फ़ंक्शन `fun remainingApples(appleCount: Int, timePerApple: Int, timePassed: Int): Int` लिखें ताकि निम्नलिखित समस्या का समाधान किया जा सके:\nसमय बीत जाने के बाद बचे हुए पूरे सेबों की संख्या की गणना करता है, \n  यह मानते हुए कि प्रत्येक सेब एक के बाद एक खाया जाता है और प्रत्येक को खाने में निश्चित समय लगता है।\n  \n  @param appleCount प्रारंभ में उपलब्ध सेबों की कुल संख्या।\n  @param timePerApple एक सेब को खाने में लगने वाला समय मिनटों में।\n  @param timePassed बीत चुका समय मिनटों में।\n  @return बचे हुए पूरे सेबों की संख्या।\n  \n  उदाहरण:\n  >>> remainingApples(50, 10, 200)\n      30\n  >>> remainingApples(5, 5, 3)\n      4",
      "hu": "Írj egy Kotlin függvényt `fun remainingApples(appleCount: Int, timePerApple: Int, timePassed: Int): Int` a következő probléma megoldására:\nKiszámítja, hogy hány egész alma marad egy adott idő elteltével, feltételezve, hogy minden almát egymás után esznek meg, és mindegyik elfogyasztása bizonyos időt vesz igénybe.\n\n@param appleCount Az eredetileg rendelkezésre álló almák teljes száma.\n@param timePerApple Az idő percekben, amely egyetlen alma elfogyasztásához szükséges.\n@param timePassed Az eltelt idő percekben.\n@return A megmaradt egész almák száma.\n\nPélda:\n>>> remainingApples(50, 10, 200)\n    30\n>>> remainingApples(5, 5, 3)\n    4"
    },
    "instruction_bertscore": {
      "sq": "0.9822106630745154",
      "hy": "0.9700447508665095",
      "bn": "0.9490568689152201",
      "bg": "0.9721877740474949",
      "zh": "0.9685095366514909",
      "fr": "0.9874813202352761",
      "de": "0.9800308932730386",
      "ha": "0.9695080515769533",
      "hi": "0.9352000162734643",
      "hu": "0.9729989805236414"
    },
    "level": "hard",
    "test": "fun main() {\n    check(remainingApples(50, 10, 200) == 30) // Test case based on example 1\n    check(remainingApples(5, 5, 3) == 4) // Test case based on example 2\n    check(remainingApples(10, 0, 100) == 0) // Test for edge case where timePerApple is 0\n    check(remainingApples(100, 1, 10000) == 0) // Test for case where all apples can be eaten\n}\n\n\nmain()",
    "entry_point": "remainingApples",
    "signature": "fun remainingApples(appleCount: Int, timePerApple: Int, timePassed: Int): Int",
    "docstring": {
      "en": "Calculates the number of whole apples left after a given time has passed, \n  assuming each apple is eaten one after another and each takes a certain amount of time to eat.\n  \n  @param appleCount The total number of apples initially available.\n  @param timePerApple The time in minutes it takes to eat a single apple.\n  @param timePassed The time in minutes that has elapsed.\n  @return The number of whole apples remaining.\n  \n  Example:\n  >>> remainingApples(50, 10, 200)\n      30\n  >>> remainingApples(5, 5, 3)\n      4",
      "sq": "Llogarit numrin e mollëve të plota të mbetura pasi ka kaluar një kohë e caktuar, \nduke supozuar se secila mollë hahet njëra pas tjetrës dhe secila merr një kohë të caktuar për t'u ngrënë.\n\n@param appleCount Numri total i mollëve fillimisht në dispozicion.\n@param timePerApple Koha në minuta që duhet për të ngrënë një mollë të vetme.\n@param timePassed Koha në minuta që ka kaluar.\n@return Numri i mollëve të plota të mbetura.\n\nShembull:\n>>> remainingApples(50, 10, 200)\n    30\n>>> remainingApples(5, 5, 3)\n    4",
      "hy": "Հաշվում է ամբողջ խնձորների քանակը, որոնք մնացել են որոշակի ժամանակ անց, \nենթադրելով, որ յուրաքանչյուր խնձոր ուտվում է մեկը մյուսի հետևից և յուրաքանչյուրի ուտելը տևում է որոշակի ժամանակ։\n\n@param appleCount Սկզբում առկա խնձորների ընդհանուր քանակը։\n@param timePerApple Ժամանակը րոպեներով, որը պահանջվում է մեկ խնձոր ուտելու համար։\n@param timePassed Ժամանակը րոպեներով, որը անցել է։\n@return Մնացած ամբողջ խնձորների քանակը։\n\nՕրինակ:\n>>> remainingApples(50, 10, 200)\n    30\n>>> remainingApples(5, 5, 3)\n    4",
      "bn": "পুরো আপেলগুলির সংখ্যা গণনা করে যা একটি নির্দিষ্ট সময় পার হওয়ার পরে অবশিষ্ট থাকে, \n  ধরে নিয়ে যে প্রতিটি আপেল একের পর এক খাওয়া হয় এবং প্রতিটি আপেল খেতে নির্দিষ্ট সময় লাগে।\n  \n  @param appleCount প্রাথমিকভাবে উপলব্ধ আপেলগুলির মোট সংখ্যা।\n  @param timePerApple একটি আপেল খেতে যে সময় লাগে তা মিনিটে।\n  @param timePassed যে সময়টি মিনিটে অতিক্রান্ত হয়েছে।\n  @return অবশিষ্ট পুরো আপেলগুলির সংখ্যা।\n  \n  উদাহরণ:\n  >>> remainingApples(50, 10, 200)\n      30\n  >>> remainingApples(5, 5, 3)\n      4",
      "bg": "Изчислява броя на целите ябълки, останали след изтичането на дадено време, \n  като се предполага, че всяка ябълка се изяжда една след друга и всяка отнема определено време за ядене.\n  \n  @param appleCount Общият брой на ябълките, налични първоначално.\n  @param timePerApple Времето в минути, необходимо за изяждане на една ябълка.\n  @param timePassed Времето в минути, което е изминало.\n  @return Броят на останалите цели ябълки.\n  \n  Пример:\n  >>> remainingApples(50, 10, 200)\n      30\n  >>> remainingApples(5, 5, 3)\n      4",
      "zh": "计算在给定时间过去后剩余的完整苹果数量，\n假设每个苹果一个接一个地被吃掉，并且每个苹果需要一定的时间来吃。\n\n@param appleCount 初始可用的苹果总数。\n@param timePerApple 吃一个苹果所需的时间（分钟）。\n@param timePassed 已经过的时间（分钟）。\n@return 剩余的完整苹果数量。\n\n示例：\n>>> remainingApples(50, 10, 200)\n    30\n>>> remainingApples(5, 5, 3)\n    4",
      "fr": "Calcule le nombre de pommes entières restantes après qu'un certain temps se soit écoulé, \n  en supposant que chaque pomme est mangée l'une après l'autre et que chacune prend un certain temps à être mangée.\n  \n  @param appleCount Le nombre total de pommes initialement disponibles.\n  @param timePerApple Le temps en minutes qu'il faut pour manger une seule pomme.\n  @param timePassed Le temps en minutes qui s'est écoulé.\n  @return Le nombre de pommes entières restantes.\n  \n  Exemple:\n  >>> remainingApples(50, 10, 200)\n      30\n  >>> remainingApples(5, 5, 3)\n      4",
      "de": "Berechnet die Anzahl der ganzen Äpfel, die übrig sind, nachdem eine bestimmte Zeit vergangen ist, \n  wobei angenommen wird, dass jeder Apfel nacheinander gegessen wird und jeder eine bestimmte Zeit zum Essen benötigt.\n  \n  @param appleCount Die anfängliche Gesamtanzahl der verfügbaren Äpfel.\n  @param timePerApple Die Zeit in Minuten, die benötigt wird, um einen einzelnen Apfel zu essen.\n  @param timePassed Die Zeit in Minuten, die vergangen ist.\n  @return Die Anzahl der verbleibenden ganzen Äpfel.\n  \n  Beispiel:\n  >>> remainingApples(50, 10, 200)\n      30\n  >>> remainingApples(5, 5, 3)\n      4",
      "ha": "Yana ƙididdige adadin cikakkun tuffa da suka rage bayan wani lokaci ya wuce, \n  yana ɗauka kowanne tuffa ana ci ɗaya bayan ɗaya kuma kowanne yana ɗaukar wani lokaci don ci.\n\n  @param appleCount Jimlar adadin tuffa da ake da su a farko.\n  @param timePerApple Lokacin a mintuna da ake ɗauka don cin tuffa guda.\n  @param timePassed Lokacin a mintuna da ya wuce.\n  @return Adadin tuffa cikakku da suka rage.\n\n  Misali:\n  >>> remainingApples(50, 10, 200)\n      30\n  >>> remainingApples(5, 5, 3)\n      4",
      "hi": "समय बीत जाने के बाद बचे हुए पूरे सेबों की संख्या की गणना करता है, \n  यह मानते हुए कि प्रत्येक सेब एक के बाद एक खाया जाता है और प्रत्येक को खाने में एक निश्चित समय लगता है।\n\n  @param appleCount प्रारंभ में उपलब्ध सेबों की कुल संख्या।\n  @param timePerApple एक सेब को खाने में लगने वाला समय (मिनटों में)।\n  @param timePassed वह समय (मिनटों में) जो बीत चुका है।\n  @return शेष पूरे सेबों की संख्या।\n\n  उदाहरण:\n  >>> remainingApples(50, 10, 200)\n      30\n  >>> remainingApples(5, 5, 3)\n      4",
      "hu": "Számítja ki a megmaradt egész almák számát egy adott idő elteltével, \n  feltételezve, hogy minden almát egymás után esznek meg, és mindegyik elfogyasztása bizonyos időt vesz igénybe.\n  \n  @param appleCount Az eredetileg rendelkezésre álló almák teljes száma.\n  @param timePerApple Az idő percben, amely egyetlen alma elfogyasztásához szükséges.\n  @param timePassed Az eltelt idő percben.\n  @return A megmaradt egész almák száma.\n  \n  Példa:\n  >>> remainingApples(50, 10, 200)\n      30\n  >>> remainingApples(5, 5, 3)\n      4"
    },
    "docstring_bertscore": {
      "sq": "0.9734657619190734",
      "hy": "0.9730545970303313",
      "bn": "0.9497268491904508",
      "bg": "0.9832268561038899",
      "zh": "0.9241214067712434",
      "fr": "0.9734657619190734",
      "de": "0.9666875001662578",
      "ha": "0.9565768165108199",
      "hi": "0.9610303082840033",
      "hu": "0.9760801349942546"
    }
  },
  {
    "task_id": "Kotlin/49",
    "prompt": {
      "en": "/**\n * Finds the missing (discontinuous) and duplicate ID numbers from a list of lists of ID numbers.\n * IDs are expected to be continuous but due to an error, one is missing and another is duplicated.\n * \n * Example:\n * >>> findMissingAndDuplicateIds(listOf(listOf(5, 6, 8, 11, 9), listOf(10, 12, 9)))\n *     Pair(7, 9)\n * \n * Note:\n * - The function assumes ID numbers are positive integers and the list contains at least one duplicate and one missing ID.\n * - The discontinuous ID cannot be the minimum or maximum of the entire ID set.\n */\nfun findMissingAndDuplicateIds(ids: List<List<Int>>): Pair<Int, Int> ",
      "sq": "/**\n * Gjen numrat e ID-ve që mungojnë (jokontinuues) dhe ato të dyfishta nga një listë listash të numrave të ID-ve.\n * ID-të pritet të jenë të pandërprera, por për shkak të një gabimi, një mungon dhe një tjetër është i dyfishtë.\n * \n * Shembull:\n * >>> findMissingAndDuplicateIds(listOf(listOf(5, 6, 8, 11, 9), listOf(10, 12, 9)))\n *     Pair(7, 9)\n * \n * Shënim:\n * - Funksioni supozon që numrat e ID-ve janë numra të plotë pozitivë dhe lista përmban të paktën një ID të dyfishtë dhe një që mungon.\n * - ID-ja jokontinuese nuk mund të jetë minimumi ose maksimumi i të gjithë grupit të ID-ve.\n */",
      "hy": "/**\n * Գտնում է բացակայող (ընդհատվող) և կրկնվող ID համարները ID համարների ցուցակների ցուցակից:\n * ID-ները ենթադրվում են, որ շարունակական են, բայց սխալի պատճառով մեկը բացակայում է, իսկ մյուսը կրկնվում է:\n * \n * Օրինակ:\n * >>> findMissingAndDuplicateIds(listOf(listOf(5, 6, 8, 11, 9), listOf(10, 12, 9)))\n *     Pair(7, 9)\n * \n * Նշում:\n * - Ֆունկցիան ենթադրում է, որ ID համարները դրական ամբողջ թվեր են և ցուցակը պարունակում է առնվազն մեկ կրկնվող և մեկ բացակայող ID:\n * - Ընդհատվող ID-ը չի կարող լինել ամբողջ ID հավաքածուի նվազագույնը կամ առավելագույնը:\n */",
      "bn": "/**\n * একটি তালিকার তালিকা থেকে অনুপস্থিত (অবিচ্ছিন্ন) এবং সদৃশ আইডি নম্বর খুঁজে বের করে।\n * আইডিগুলি ধারাবাহিক হওয়ার কথা কিন্তু একটি ত্রুটির কারণে একটি অনুপস্থিত এবং অন্যটি সদৃশ হয়েছে।\n * \n * উদাহরণ:\n * >>> findMissingAndDuplicateIds(listOf(listOf(5, 6, 8, 11, 9), listOf(10, 12, 9)))\n *     Pair(7, 9)\n * \n * নোট:\n * - ফাংশনটি ধরে নেয় যে আইডি নম্বরগুলি ধনাত্মক পূর্ণসংখ্যা এবং তালিকায় অন্তত একটি সদৃশ এবং একটি অনুপস্থিত আইডি রয়েছে।\n * - অবিচ্ছিন্ন আইডি পুরো আইডি সেটের সর্বনিম্ন বা সর্বাধিক হতে পারে না।\n */",
      "bg": "/**\n * Намира липсващите (несвързани) и дублирани ID номера от списък от списъци с ID номера.\n * Очаква се ID-тата да са свързани, но поради грешка едно липсва и друго е дублирано.\n * \n * Пример:\n * >>> findMissingAndDuplicateIds(listOf(listOf(5, 6, 8, 11, 9), listOf(10, 12, 9)))\n *     Pair(7, 9)\n * \n * Забележка:\n * - Функцията предполага, че ID номерата са положителни цели числа и списъкът съдържа поне едно дублирано и едно липсващо ID.\n * - Несвързаното ID не може да бъде минималното или максималното от целия набор от ID-та.\n */",
      "zh": "/**\n * 查找列表中的列表中缺失（不连续）和重复的ID号码。\n * ID预计是连续的，但由于错误，一个ID缺失，另一个ID重复。\n * \n * 示例:\n * >>> findMissingAndDuplicateIds(listOf(listOf(5, 6, 8, 11, 9), listOf(10, 12, 9)))\n *     Pair(7, 9)\n * \n * 注意:\n * - 该函数假设ID号码是正整数，并且列表中至少包含一个重复和一个缺失的ID。\n * - 不连续的ID不能是整个ID集合的最小值或最大值。\n */",
      "fr": "/**\n * Trouve les numéros d'identification manquants (discontinus) et en double à partir d'une liste de listes de numéros d'identification.\n * Les identifiants sont censés être continus mais en raison d'une erreur, l'un est manquant et un autre est dupliqué.\n * \n * Exemple :\n * >>> findMissingAndDuplicateIds(listOf(listOf(5, 6, 8, 11, 9), listOf(10, 12, 9)))\n *     Pair(7, 9)\n * \n * Remarque :\n * - La fonction suppose que les numéros d'identification sont des entiers positifs et que la liste contient au moins un doublon et un identifiant manquant.\n * - L'identifiant discontinu ne peut pas être le minimum ou le maximum de l'ensemble entier des identifiants.\n */",
      "de": "/**\n * Findet die fehlenden (diskontinuierlichen) und doppelten ID-Nummern aus einer Liste von Listen von ID-Nummern.\n * IDs sollen kontinuierlich sein, aber aufgrund eines Fehlers fehlt eine und eine andere ist dupliziert.\n * \n * Beispiel:\n * >>> findMissingAndDuplicateIds(listOf(listOf(5, 6, 8, 11, 9), listOf(10, 12, 9)))\n *     Pair(7, 9)\n * \n * Hinweis:\n * - Die Funktion geht davon aus, dass ID-Nummern positive Ganzzahlen sind und die Liste mindestens eine doppelte und eine fehlende ID enthält.\n * - Die diskontinuierliche ID kann nicht das Minimum oder Maximum des gesamten ID-Sets sein.\n */",
      "ha": "/**\n * Nemi ID lambobin da suka ɓace (wanda ba su ci gaba ba) da kuma lambobin ID masu maimaitawa daga jerin jerin lambobin ID.\n * Ana sa ran ID ɗin su kasance masu ci gaba amma saboda kuskure, ɗaya ya ɓace kuma wani ya maimaita.\n * \n * Misali:\n * >>> findMissingAndDuplicateIds(listOf(listOf(5, 6, 8, 11, 9), listOf(10, 12, 9)))\n *     Pair(7, 9)\n * \n * Lura:\n * - Aikin yana ɗauka lambobin ID lambobi ne masu kyau kuma jerin yana ƙunshe da aƙalla ɗaya mai maimaitawa da ɗaya da ya ɓace.\n * - ID ɗin da ba ya ci gaba ba zai iya zama mafi ƙaranci ko mafi girma na dukkan saitin ID ba.\n */",
      "hi": "/**\n * एक सूची की सूचियों से गायब (अविरल) और डुप्लिकेट आईडी नंबरों को खोजता है।\n * आईडी निरंतर होने की उम्मीद की जाती हैं लेकिन एक त्रुटि के कारण, एक गायब है और दूसरा डुप्लिकेट है।\n * \n * उदाहरण:\n * >>> findMissingAndDuplicateIds(listOf(listOf(5, 6, 8, 11, 9), listOf(10, 12, 9)))\n *     Pair(7, 9)\n * \n * नोट:\n * - यह फ़ंक्शन मानता है कि आईडी नंबर सकारात्मक पूर्णांक हैं और सूची में कम से कम एक डुप्लिकेट और एक गायब आईडी है।\n * - अविरल आईडी पूरे आईडी सेट का न्यूनतम या अधिकतम नहीं हो सकता।\n */",
      "hu": "/**\n * Megkeresi a hiányzó (folytonos) és duplikált azonosító számokat az azonosító számok listáinak listájából.\n * Az azonosítók várhatóan folytonosak, de egy hiba miatt egy hiányzik és egy másik duplikált.\n * \n * Példa:\n * >>> findMissingAndDuplicateIds(listOf(listOf(5, 6, 8, 11, 9), listOf(10, 12, 9)))\n *     Pair(7, 9)\n * \n * Megjegyzés:\n * - A függvény feltételezi, hogy az azonosító számok pozitív egész számok, és a lista tartalmaz legalább egy duplikált és egy hiányzó azonosítót.\n * - A nem folytonos azonosító nem lehet az egész azonosító halmaz minimuma vagy maximuma.\n */"
    },
    "prompt_bertscore": {
      "sq": "0.9289707688938291",
      "hy": "0.9211212934960924",
      "bn": "0.9180252417469017",
      "bg": "0.9161551367094581",
      "zh": "0.9192047089494868",
      "fr": "0.9275398356288538",
      "de": "0.9510966042980674",
      "ha": "0.8690221335936895",
      "hi": "0.9226626652529232",
      "hu": "0.9124187006118109"
    },
    "canonical_solution": "{\n    val flatIds = ids.flatten().sorted()\n    var duplicateId = -1\n    var missingId = -1\n    \n    for (i in 1 until flatIds.size) {\n        if (flatIds[i] == flatIds[i - 1]) {\n            duplicateId = flatIds[i]\n        } else if (flatIds[i] - flatIds[i - 1] > 1) {\n            missingId = flatIds[i - 1] + 1\n        }\n    }\n    \n    return Pair(missingId, duplicateId)\n}",
    "instruction": {
      "en": "Write a Kotlin function `fun findMissingAndDuplicateIds(ids: List<List<Int>>): Pair<Int, Int>` to solve the following problem:\nFinds the missing (discontinuous) and duplicate ID numbers from a list of lists of ID numbers.\n  IDs are expected to be continuous but due to an error, one is missing and another is duplicated.\n  \n  Example:\n  >>> findMissingAndDuplicateIds(listOf(listOf(5, 6, 8, 11, 9), listOf(10, 12, 9)))\n      Pair(7, 9)\n  \n  Note:\n  - The function assumes ID numbers are positive integers and the list contains at least one duplicate and one missing ID.\n  - The discontinuous ID cannot be the minimum or maximum of the entire ID set.",
      "sq": "Shkruani një funksion Kotlin `fun findMissingAndDuplicateIds(ids: List<List<Int>>): Pair<Int, Int>` për të zgjidhur problemin në vijim:\nGjen numrat e ID-ve që mungojnë (jo të vazhdueshëm) dhe që janë të dyfishuar nga një listë e listave të numrave të ID-ve.\n  ID-të pritet të jenë të vazhdueshme, por për shkak të një gabimi, një mungon dhe një tjetër është i dyfishuar.\n  \n  Shembull:\n  >>> findMissingAndDuplicateIds(listOf(listOf(5, 6, 8, 11, 9), listOf(10, 12, 9)))\n      Pair(7, 9)\n  \n  Shënim:\n  - Funksioni supozon që numrat e ID-ve janë numra të plotë pozitivë dhe lista përmban të paktën një ID të dyfishuar dhe një ID që mungon.\n  - ID-ja jo e vazhdueshme nuk mund të jetë minimumi ose maksimumi i të gjithë grupit të ID-ve.",
      "hy": "Գրեք Kotlin ֆունկցիա `fun findMissingAndDuplicateIds(ids: List<List<Int>>): Pair<Int, Int>` հետևյալ խնդիրը լուծելու համար:\nԳտնում է բացակայող (ընդհատվող) և կրկնվող ID համարները ID համարների ցուցակների ցուցակից:\n  ID-ները ենթադրվում են, որ պետք է լինեն շարունակական, բայց սխալի պատճառով մեկը բացակայում է, իսկ մյուսը կրկնվում է:\n  \n  Օրինակ:\n  >>> findMissingAndDuplicateIds(listOf(listOf(5, 6, 8, 11, 9), listOf(10, 12, 9)))\n      Pair(7, 9)\n  \n  Նշում:\n  - Ֆունկցիան ենթադրում է, որ ID համարները դրական ամբողջ թվեր են և ցուցակը պարունակում է առնվազն մեկ կրկնվող և մեկ բացակայող ID:\n  - Ընդհատվող ID-ն չի կարող լինել ամբողջ ID հավաքածուի նվազագույնը կամ առավելագույնը:",
      "bn": "একটি Kotlin ফাংশন `fun findMissingAndDuplicateIds(ids: List<List<Int>>): Pair<Int, Int>` লিখুন নিম্নলিখিত সমস্যার সমাধানের জন্য:\nএকটি আইডি নম্বরের তালিকার তালিকা থেকে অনুপস্থিত (অবিচ্ছিন্ন) এবং সদৃশ আইডি নম্বরগুলি খুঁজে বের করে।\n  আইডি গুলি ধারাবাহিক হওয়ার কথা কিন্তু একটি ত্রুটির কারণে একটি অনুপস্থিত এবং অন্যটি সদৃশ হয়েছে।\n  \n  উদাহরণ:\n  >>> findMissingAndDuplicateIds(listOf(listOf(5, 6, 8, 11, 9), listOf(10, 12, 9)))\n      Pair(7, 9)\n  \n  নোট:\n  - ফাংশনটি ধরে নেয় যে আইডি নম্বরগুলি ধনাত্মক পূর্ণসংখ্যা এবং তালিকায় অন্তত একটি সদৃশ এবং একটি অনুপস্থিত আইডি রয়েছে।\n  - অবিচ্ছিন্ন আইডি পুরো আইডি সেটের সর্বনিম্ন বা সর্বাধিক হতে পারে না।",
      "bg": "Напишете Kotlin функция `fun findMissingAndDuplicateIds(ids: List<List<Int>>): Pair<Int, Int>`, за да решите следния проблем:\nНамира липсващите (несвързани) и дублиращите се ID номера от списък от списъци с ID номера.\n  Очаква се ID-тата да са непрекъснати, но поради грешка едно липсва, а друго е дублирано.\n  \n  Пример:\n  >>> findMissingAndDuplicateIds(listOf(listOf(5, 6, 8, 11, 9), listOf(10, 12, 9)))\n      Pair(7, 9)\n  \n  Забележка:\n  - Функцията предполага, че ID номерата са положителни цели числа и списъкът съдържа поне едно дублирано и едно липсващо ID.\n  - Несвързаното ID не може да бъде минималното или максималното от целия набор ID-та.",
      "zh": "编写一个 Kotlin 函数 `fun findMissingAndDuplicateIds(ids: List<List<Int>>): Pair<Int, Int>` 来解决以下问题：\n查找来自 ID 号码列表的缺失（不连续）和重复的 ID 号码。\n  ID 应该是连续的，但由于错误，一个 ID 缺失，另一个重复。\n  \n  示例：\n  >>> findMissingAndDuplicateIds(listOf(listOf(5, 6, 8, 11, 9), listOf(10, 12, 9)))\n      Pair(7, 9)\n  \n  注意：\n  - 函数假设 ID 号码是正整数，并且列表中至少包含一个重复和一个缺失的 ID。\n  - 不连续的 ID 不能是整个 ID 集合的最小值或最大值。",
      "fr": "Écrire une fonction Kotlin `fun findMissingAndDuplicateIds(ids: List<List<Int>>): Pair<Int, Int>` pour résoudre le problème suivant :  \nTrouve les numéros d'identification manquants (discontinus) et dupliqués à partir d'une liste de listes de numéros d'identification.  \nLes identifiants sont censés être continus mais en raison d'une erreur, l'un est manquant et un autre est dupliqué.\n\nExemple :\n>>> findMissingAndDuplicateIds(listOf(listOf(5, 6, 8, 11, 9), listOf(10, 12, 9)))\n    Pair(7, 9)\n\nRemarque :\n- La fonction suppose que les numéros d'identification sont des entiers positifs et que la liste contient au moins un identifiant dupliqué et un identifiant manquant.\n- L'identifiant discontinu ne peut pas être le minimum ou le maximum de l'ensemble entier des identifiants.",
      "de": "Schreiben Sie eine Kotlin-Funktion `fun findMissingAndDuplicateIds(ids: List<List<Int>>): Pair<Int, Int>`, um das folgende Problem zu lösen:\nFindet die fehlenden (diskontinuierlichen) und doppelten ID-Nummern aus einer Liste von Listen von ID-Nummern.\n  IDs sollen kontinuierlich sein, aber aufgrund eines Fehlers fehlt eine und eine andere ist dupliziert.\n  \n  Beispiel:\n  >>> findMissingAndDuplicateIds(listOf(listOf(5, 6, 8, 11, 9), listOf(10, 12, 9)))\n      Pair(7, 9)\n  \n  Hinweis:\n  - Die Funktion geht davon aus, dass ID-Nummern positive ganze Zahlen sind und die Liste mindestens eine doppelte und eine fehlende ID enthält.\n  - Die diskontinuierliche ID kann nicht das Minimum oder Maximum der gesamten ID-Menge sein.",
      "ha": "Rubuta aikin Kotlin `fun findMissingAndDuplicateIds(ids: List<List<Int>>): Pair<Int, Int>` don warware matsalar mai zuwa:\nNemo lambobin ID da suka bata (wanda ba su ci gaba ba) da kuma lambobin ID da aka maimaita daga jerin jerin lambobin ID.\n  Ana sa ran IDs su kasance masu ci gaba amma saboda kuskure, daya ya bata kuma wani ya maimaita.\n  \n  Misali:\n  >>> findMissingAndDuplicateIds(listOf(listOf(5, 6, 8, 11, 9), listOf(10, 12, 9)))\n      Pair(7, 9)\n  \n  Lura:\n  - Aikin yana ɗauka lambobin ID lambobi ne masu kyau kuma jerin yana ƙunshe da aƙalla daya da aka maimaita da daya da ya bata.\n  - ID da ba ya ci gaba ba zai iya zama mafi ƙaranci ko mafi girma na duk saitin ID ba.",
      "hi": "Kotlin फ़ंक्शन `fun findMissingAndDuplicateIds(ids: List<List<Int>>): Pair<Int, Int>` लिखें ताकि निम्नलिखित समस्या का समाधान किया जा सके:\nID नंबरों की सूचियों की सूची से गायब (अविरल) और डुप्लिकेट ID नंबरों को खोजें।\n  IDs को अविरल रूप से होना अपेक्षित है लेकिन एक त्रुटि के कारण, एक गायब है और दूसरा डुप्लिकेट है।\n  \n  उदाहरण:\n  >>> findMissingAndDuplicateIds(listOf(listOf(5, 6, 8, 11, 9), listOf(10, 12, 9)))\n      Pair(7, 9)\n  \n  ध्यान दें:\n  - फ़ंक्शन मानता है कि ID नंबर सकारात्मक पूर्णांक हैं और सूची में कम से कम एक डुप्लिकेट और एक गायब ID है।\n  - अविरल ID पूरे ID सेट का न्यूनतम या अधिकतम नहीं हो सकता।",
      "hu": "Írj egy Kotlin függvényt `fun findMissingAndDuplicateIds(ids: List<List<Int>>): Pair<Int, Int>` a következő probléma megoldására:\nMegtalálja a hiányzó (folytonosság nélküli) és a duplikált azonosító számokat az azonosító számok listáinak listájából.\n  Az azonosítók várhatóan folytonosak, de egy hiba miatt az egyik hiányzik, és egy másik duplikálva van.\n  \n  Példa:\n  >>> findMissingAndDuplicateIds(listOf(listOf(5, 6, 8, 11, 9), listOf(10, 12, 9)))\n      Pair(7, 9)\n  \n  Megjegyzés:\n  - A függvény feltételezi, hogy az azonosító számok pozitív egész számok, és a lista legalább egy duplikált és egy hiányzó azonosítót tartalmaz.\n  - A folytonosság nélküli azonosító nem lehet az egész azonosító halmaz minimuma vagy maximuma."
    },
    "instruction_bertscore": {
      "sq": "0.9653117861472102",
      "hy": "0.9611880208065449",
      "bn": "0.9678921934272344",
      "bg": "0.9630926875302884",
      "zh": "0.9576653109988912",
      "fr": "0.9660971706738222",
      "de": "0.9846712962347756",
      "ha": "0.9303069554670509",
      "hi": "0.9533512577531944",
      "hu": "0.9543843343649568"
    },
    "level": "easy",
    "test": "fun main() {\n    check(findMissingAndDuplicateIds(listOf(listOf(5, 6, 8, 11, 9), listOf(10, 12, 9))) == Pair(7, 9))\n    // Add more tests to ensure robustness\n    check(findMissingAndDuplicateIds(listOf(listOf(1, 2, 4,7), listOf(3, 5, 5))) == Pair(6, 5))\n    check(findMissingAndDuplicateIds(listOf(listOf(10, 11,17, 12, 14), listOf(13, 15, 12))) == Pair(16, 12))\n}\n\n\nmain()",
    "entry_point": "findMissingAndDuplicateIds",
    "signature": "fun findMissingAndDuplicateIds(ids: List<List<Int>>): Pair<Int, Int>",
    "docstring": {
      "en": "Finds the missing (discontinuous) and duplicate ID numbers from a list of lists of ID numbers.\n  IDs are expected to be continuous but due to an error, one is missing and another is duplicated.\n  \n  Example:\n  >>> findMissingAndDuplicateIds(listOf(listOf(5, 6, 8, 11, 9), listOf(10, 12, 9)))\n      Pair(7, 9)\n  \n  Note:\n  - The function assumes ID numbers are positive integers and the list contains at least one duplicate and one missing ID.\n  - The discontinuous ID cannot be the minimum or maximum of the entire ID set.",
      "sq": "Gjen ID-të që mungojnë (të ndërprera) dhe ID-të e dyfishta nga një listë listash të numrave të ID-ve. \n  ID-të pritet të jenë të vazhdueshme por për shkak të një gabimi, një mungon dhe një tjetër është e dyfishtë.\n  \n  Shembull:\n  >>> findMissingAndDuplicateIds(listOf(listOf(5, 6, 8, 11, 9), listOf(10, 12, 9)))\n      Pair(7, 9)\n  \n  Shënim:\n  - Funksioni supozon që numrat e ID-ve janë numra të plotë pozitivë dhe lista përmban të paktën një ID të dyfishtë dhe një ID që mungon.\n  - ID-ja e ndërprerë nuk mund të jetë minimumi ose maksimumi i të gjithë grupit të ID-ve.",
      "hy": "Գտնում է բացակայող (ընդհատվող) և կրկնվող ID համարները ID համարների ցուցակների ցուցակից:\n  ID-ները սպասվում է, որ կլինեն շարունակական, բայց սխալի պատճառով մեկը բացակայում է, իսկ մյուսը կրկնվում է:\n  \n  Օրինակ:\n  >>> findMissingAndDuplicateIds(listOf(listOf(5, 6, 8, 11, 9), listOf(10, 12, 9)))\n      Pair(7, 9)\n  \n  Նշում:\n  - Ֆունկցիան ենթադրում է, որ ID համարները դրական ամբողջ թվեր են և ցուցակը պարունակում է առնվազն մեկ կրկնվող և մեկ բացակայող ID:\n  - Ընդհատվող ID-ն չի կարող լինել ամբողջ ID հավաքածուի նվազագույնը կամ առավելագույնը:",
      "bn": "ডিসকন্টিনিউয়াস এবং সদৃশ আইডি নম্বরগুলি একটি আইডি নম্বরের তালিকার তালিকা থেকে খুঁজে বের করে।\n  আইডিগুলি ধারাবাহিক হওয়ার কথা, কিন্তু একটি ত্রুটির কারণে একটি অনুপস্থিত এবং অন্যটি সদৃশ হয়েছে।\n  \n  উদাহরণ:\n  >>> findMissingAndDuplicateIds(listOf(listOf(5, 6, 8, 11, 9), listOf(10, 12, 9)))\n      Pair(7, 9)\n  \n  নোট:\n  - ফাংশনটি ধরে নেয় যে আইডি নম্বরগুলি ধনাত্মক পূর্ণসংখ্যা এবং তালিকায় অন্তত একটি সদৃশ এবং একটি অনুপস্থিত আইডি রয়েছে।\n  - ডিসকন্টিনিউয়াস আইডিটি সম্পূর্ণ আইডি সেটের সর্বনিম্ন বা সর্বাধিক হতে পারে না।",
      "bg": "Намира липсващите (несвързани) и дублирани ID номера от списък от списъци с ID номера. \n  Очаква се ID номерата да са непрекъснати, но поради грешка един липсва, а друг се дублира.\n  \n  Пример:\n  >>> findMissingAndDuplicateIds(listOf(listOf(5, 6, 8, 11, 9), listOf(10, 12, 9)))\n      Pair(7, 9)\n  \n  Забележка:\n  - Функцията приема, че ID номерата са положителни цели числа и списъкът съдържа поне един дублиран и един липсващ ID.\n  - Несвързаният ID не може да бъде минималният или максималният от целия набор от ID.",
      "zh": "查找列表中缺失（不连续）和重复的ID号。\n  ID号应该是连续的，但由于错误，一个ID号缺失，另一个ID号重复。\n  \n  示例：\n  >>> findMissingAndDuplicateIds(listOf(listOf(5, 6, 8, 11, 9), listOf(10, 12, 9)))\n      Pair(7, 9)\n  \n  注意：\n  - 该函数假设ID号是正整数，并且列表中至少包含一个重复和一个缺失的ID号。\n  - 不连续的ID号不能是整个ID集合中的最小值或最大值。",
      "fr": "Trouve les numéros d'identification manquants (discontinus) et en double à partir d'une liste de listes de numéros d'identification.\n  Les identifiants sont censés être continus mais en raison d'une erreur, l'un est manquant et un autre est dupliqué.\n  \n  Exemple:\n  >>> findMissingAndDuplicateIds(listOf(listOf(5, 6, 8, 11, 9), listOf(10, 12, 9)))\n      Pair(7, 9)\n  \n  Remarque:\n  - La fonction suppose que les numéros d'identification sont des entiers positifs et que la liste contient au moins un doublon et un identifiant manquant.\n  - L'identifiant discontinu ne peut pas être le minimum ou le maximum de l'ensemble entier des identifiants.",
      "de": "Findet die fehlenden (diskontinuierlichen) und doppelten ID-Nummern aus einer Liste von Listen von ID-Nummern.\n  Es wird erwartet, dass die IDs kontinuierlich sind, aber aufgrund eines Fehlers fehlt eine und eine andere ist dupliziert.\n  \n  Beispiel:\n  >>> findMissingAndDuplicateIds(listOf(listOf(5, 6, 8, 11, 9), listOf(10, 12, 9)))\n      Pair(7, 9)\n  \n  Hinweis:\n  - Die Funktion geht davon aus, dass ID-Nummern positive ganze Zahlen sind und die Liste mindestens eine doppelte und eine fehlende ID enthält.\n  - Die diskontinuierliche ID kann nicht das Minimum oder Maximum des gesamten ID-Sets sein.",
      "ha": "Nemo ID lambobi da suka ɓace (wanda ba su ci gaba ba) da kuma lambobin ID masu maimaitawa daga jerin jerin lambobin ID.\n  Ana tsammanin ID ɗin su kasance masu ci gaba amma saboda kuskure, ɗaya ya ɓace kuma wani ya maimaita.\n\n  Misali:\n  >>> findMissingAndDuplicateIds(listOf(listOf(5, 6, 8, 11, 9), listOf(10, 12, 9)))\n      Pair(7, 9)\n\n  Lura:\n  - Aikin yana ɗauka cewa lambobin ID lambobi ne masu kyau kuma jerin yana ɗauke da aƙalla ɗaya mai maimaitawa da ɗaya da ya ɓace.\n  - ID wanda ba ya ci gaba ba zai iya zama mafi ƙaranci ko mafi girma na dukkan saitin ID ba.",
      "hi": "लापता (अविरल) और डुप्लिकेट ID नंबरों को ID नंबरों की सूचियों की सूची से खोजता है।  \n  IDs को अविरल होने की उम्मीद होती है लेकिन एक त्रुटि के कारण, एक गायब है और दूसरा डुप्लिकेट है।\n\n  उदाहरण:\n  >>> findMissingAndDuplicateIds(listOf(listOf(5, 6, 8, 11, 9), listOf(10, 12, 9)))\n      Pair(7, 9)\n\n  नोट:\n  - फ़ंक्शन मानता है कि ID नंबर सकारात्मक पूर्णांक हैं और सूची में कम से कम एक डुप्लिकेट और एक लापता ID है।\n  - अविरल ID पूरे ID सेट का न्यूनतम या अधिकतम नहीं हो सकता।",
      "hu": "Megkeresi a hiányzó (folytonossági hiányos) és duplikált azonosító számokat az azonosító számok listáinak listájából.\nAz azonosítók folyamatosak kellene, hogy legyenek, de egy hiba miatt egy hiányzik és egy másik duplikálva van.\n\nPélda:\n>>> findMissingAndDuplicateIds(listOf(listOf(5, 6, 8, 11, 9), listOf(10, 12, 9)))\n    Pair(7, 9)\n\nMegjegyzés:\n- A függvény feltételezi, hogy az azonosító számok pozitív egész számok, és a lista legalább egy duplikált és egy hiányzó azonosítót tartalmaz.\n- A folytonossági hiányos azonosító nem lehet az egész azonosító halmaz minimuma vagy maximuma."
    },
    "docstring_bertscore": {
      "sq": "0.9539622448052577",
      "hy": "0.9664531163166367",
      "bn": "0.9482172582945857",
      "bg": "0.9435593758593176",
      "zh": "0.9253278877056493",
      "fr": "0.9661821844769051",
      "de": "0.9836288839951045",
      "ha": "0.9121588920734173",
      "hi": "0.9530566888981197",
      "hu": "0.9373764093584636"
    }
  },
  {
    "task_id": "Kotlin/50",
    "prompt": {
      "en": "/**\n * Counts the number of digits, lowercase letters, and uppercase letters in a given string of length 8.\n * \n * @param s The input string of length 8.\n * @return A Triple of integers where the first element is the count of digits,\n * the second element is the count of lowercase letters, and the third element\n * is the count of uppercase letters in the string.\n * \n * Example:\n * >>> countCharacters(\"yLOI2022\")\n * Triple(4, 1, 3)\n * >>> countCharacters(\"IAKIOIOI\")\n * Triple(0, 0, 8)\n * >>> countCharacters(\"1n2s0e1s\")\n * Triple(4, 4, 0)\n */\nfun countCharacters(s: String): Triple<Int, Int, Int> ",
      "sq": "/**\n * Numëron numrin e shifrave, shkronjave të vogla dhe shkronjave të mëdha në një varg të dhënë me gjatësi 8.\n * \n * @param s Vargu hyrës me gjatësi 8.\n * @return Një Triple i numrave të plotë ku elementi i parë është numri i shifrave,\n * elementi i dytë është numri i shkronjave të vogla, dhe elementi i tretë\n * është numri i shkronjave të mëdha në varg.\n * \n * Shembull:\n * >>> countCharacters(\"yLOI2022\")\n * Triple(4, 1, 3)\n * >>> countCharacters(\"IAKIOIOI\")\n * Triple(0, 0, 8)\n * >>> countCharacters(\"1n2s0e1s\")\n * Triple(4, 4, 0)\n */ \nfun countCharacters(s: String): Triple<Int, Int, Int> ",
      "hy": "/**\n * Հաշվում է թվանշանների, փոքրատառերի և մեծատառերի քանակը տրված 8 երկարությամբ տողում:\n * \n * @param s Մուտքային տողը 8 երկարությամբ:\n * @return Երեք թվերի տրիպլետ, որտեղ առաջին տարրը թվանշանների քանակն է,\n * երկրորդ տարրը փոքրատառերի քանակն է, և երրորդ տարրը մեծատառերի քանակն է տողում:\n * \n * Օրինակ:\n * >>> countCharacters(\"yLOI2022\")\n * Triple(4, 1, 3)\n * >>> countCharacters(\"IAKIOIOI\")\n * Triple(0, 0, 8)\n * >>> countCharacters(\"1n2s0e1s\")\n * Triple(4, 4, 0)\n */\nfun countCharacters(s: String): Triple<Int, Int, Int> ",
      "bn": "/**\n * একটি প্রদত্ত দৈর্ঘ্য 8 এর স্ট্রিং-এ সংখ্যা, ছোট হাতের অক্ষর, এবং বড় হাতের অক্ষর গণনা করে।\n * \n * @param s দৈর্ঘ্য 8 এর ইনপুট স্ট্রিং।\n * @return একটি Triple পূর্ণসংখ্যার যেখানে প্রথম উপাদানটি সংখ্যার গণনা,\n * দ্বিতীয় উপাদানটি ছোট হাতের অক্ষরের গণনা, এবং তৃতীয় উপাদানটি\n * বড় হাতের অক্ষরের গণনা স্ট্রিং-এ।\n * \n * উদাহরণ:\n * >>> countCharacters(\"yLOI2022\")\n * Triple(4, 1, 3)\n * >>> countCharacters(\"IAKIOIOI\")\n * Triple(0, 0, 8)\n * >>> countCharacters(\"1n2s0e1s\")\n * Triple(4, 4, 0)\n */",
      "bg": "/**\n * Брои броя на цифрите, малките букви и главните букви в даден низ с дължина 8.\n * \n * @param s Входният низ с дължина 8.\n * @return Тройка от цели числа, където първият елемент е броят на цифрите,\n * вторият елемент е броят на малките букви, а третият елемент\n * е броят на главните букви в низа.\n * \n * Пример:\n * >>> countCharacters(\"yLOI2022\")\n * Triple(4, 1, 3)\n * >>> countCharacters(\"IAKIOIOI\")\n * Triple(0, 0, 8)\n * >>> countCharacters(\"1n2s0e1s\")\n * Triple(4, 4, 0)\n */",
      "zh": "/**\n * 计算给定长度为8的字符串中的数字、小写字母和大写字母的数量。\n * \n * @param s 长度为8的输入字符串。\n * @return 一个整数的Triple，其中第一个元素是数字的数量，\n * 第二个元素是小写字母的数量，第三个元素是字符串中大写字母的数量。\n * \n * 示例:\n * >>> countCharacters(\"yLOI2022\")\n * Triple(4, 1, 3)\n * >>> countCharacters(\"IAKIOIOI\")\n * Triple(0, 0, 8)\n * >>> countCharacters(\"1n2s0e1s\")\n * Triple(4, 4, 0)\n */",
      "fr": "/**\n * Compte le nombre de chiffres, de lettres minuscules et de lettres majuscules dans une chaîne donnée de longueur 8.\n * \n * @param s La chaîne d'entrée de longueur 8.\n * @return Un Triple d'entiers où le premier élément est le compte des chiffres,\n * le deuxième élément est le compte des lettres minuscules, et le troisième élément\n * est le compte des lettres majuscules dans la chaîne.\n * \n * Exemple:\n * >>> countCharacters(\"yLOI2022\")\n * Triple(4, 1, 3)\n * >>> countCharacters(\"IAKIOIOI\")\n * Triple(0, 0, 8)\n * >>> countCharacters(\"1n2s0e1s\")\n * Triple(4, 4, 0)\n */",
      "de": "/**\n * Zählt die Anzahl der Ziffern, Kleinbuchstaben und Großbuchstaben in einem gegebenen String der Länge 8.\n * \n * @param s Der Eingabestring der Länge 8.\n * @return Ein Triple von Ganzzahlen, wobei das erste Element die Anzahl der Ziffern ist,\n * das zweite Element die Anzahl der Kleinbuchstaben und das dritte Element\n * die Anzahl der Großbuchstaben im String.\n * \n * Beispiel:\n * >>> countCharacters(\"yLOI2022\")\n * Triple(4, 1, 3)\n * >>> countCharacters(\"IAKIOIOI\")\n * Triple(0, 0, 8)\n * >>> countCharacters(\"1n2s0e1s\")\n * Triple(4, 4, 0)\n */",
      "ha": "/**\n * Yana ƙididdige yawan lambobi, ƙananan haruffa, da manyan haruffa a cikin wani igiyar rubutu mai tsawon haruffa 8.\n * \n * @param s Igiyar rubutu mai shigarwa mai tsawon haruffa 8.\n * @return Wani Triple na lambobi inda na farko shine adadin lambobi,\n * na biyu shine adadin ƙananan haruffa, kuma na uku shine adadin manyan haruffa a cikin igiyar rubutu.\n * \n * Misali:\n * >>> countCharacters(\"yLOI2022\")\n * Triple(4, 1, 3)\n * >>> countCharacters(\"IAKIOIOI\")\n * Triple(0, 0, 8)\n * >>> countCharacters(\"1n2s0e1s\")\n * Triple(4, 4, 0)\n */",
      "hi": "/**\n * एक दिए गए 8 अक्षरों की लंबाई वाले स्ट्रिंग में अंकों, छोटे अक्षरों, और बड़े अक्षरों की संख्या गिनता है।\n * \n * @param s इनपुट स्ट्रिंग जिसकी लंबाई 8 है।\n * @return पूर्णांकों का एक ट्रिपल जहां पहला तत्व अंकों की गिनती है,\n * दूसरा तत्व छोटे अक्षरों की गिनती है, और तीसरा तत्व\n * स्ट्रिंग में बड़े अक्षरों की गिनती है।\n * \n * उदाहरण:\n * >>> countCharacters(\"yLOI2022\")\n * Triple(4, 1, 3)\n * >>> countCharacters(\"IAKIOIOI\")\n * Triple(0, 0, 8)\n * >>> countCharacters(\"1n2s0e1s\")\n * Triple(4, 4, 0)\n */ \nfun countCharacters(s: String): Triple<Int, Int, Int> ",
      "hu": "/**\n * Megszámolja a számjegyek, kisbetűk és nagybetűk számát egy adott, 8 karakter hosszú sztringben.\n * \n * @param s A bemeneti sztring, amely 8 karakter hosszú.\n * @return Egy egész számokból álló Triple, ahol az első elem a számjegyek száma,\n * a második elem a kisbetűk száma, és a harmadik elem a nagybetűk száma a sztringben.\n * \n * Példa:\n * >>> countCharacters(\"yLOI2022\")\n * Triple(4, 1, 3)\n * >>> countCharacters(\"IAKIOIOI\")\n * Triple(0, 0, 8)\n * >>> countCharacters(\"1n2s0e1s\")\n * Triple(4, 4, 0)\n */"
    },
    "prompt_bertscore": {
      "sq": "0.9821631904134481",
      "hy": "0.9706607036780988",
      "bn": "0.9472096063715957",
      "bg": "0.9535077784934499",
      "zh": "0.9457012072580168",
      "fr": "0.9706807653465832",
      "de": "0.957169132307066",
      "ha": "0.9339538092628514",
      "hi": "0.9848375498637018",
      "hu": "0.9320121972882354"
    },
    "canonical_solution": "{\n    var digits = 0\n    var lowerCaseLetters = 0\n    var upperCaseLetters = 0\n    \n    for (char in s) {\n        when {\n            char.isDigit() -> digits++\n            char.isLowerCase() -> lowerCaseLetters++\n            char.isUpperCase() -> upperCaseLetters++\n        }\n    }\n    \n    return Triple(digits, lowerCaseLetters, upperCaseLetters)\n}",
    "instruction": {
      "en": "Write a Kotlin function `fun countCharacters(s: String): Triple<Int, Int, Int>` to solve the following problem:\nCounts the number of digits, lowercase letters, and uppercase letters in a given string of length 8.\n  \n  @param s The input string of length 8.\n  @return A Triple of integers where the first element is the count of digits,\n  the second element is the count of lowercase letters, and the third element\n  is the count of uppercase letters in the string.\n  \n  Example:\n  >>> countCharacters(\"yLOI2022\")\n  Triple(4, 1, 3)\n  >>> countCharacters(\"IAKIOIOI\")\n  Triple(0, 0, 8)\n  >>> countCharacters(\"1n2s0e1s\")\n  Triple(4, 4, 0)",
      "sq": "Shkruani një funksion Kotlin `fun countCharacters(s: String): Triple<Int, Int, Int>` për të zgjidhur problemin në vijim: Numëron numrin e shifrave, shkronjave të vogla dhe shkronjave të mëdha në një varg të dhënë me gjatësi 8.\n\n@param s Vargu hyrës me gjatësi 8.\n@return Një Triple e numrave të plotë ku elementi i parë është numri i shifrave, elementi i dytë është numri i shkronjave të vogla, dhe elementi i tretë është numri i shkronjave të mëdha në varg.\n\nShembull:\n>>> countCharacters(\"yLOI2022\")\nTriple(4, 1, 3)\n>>> countCharacters(\"IAKIOIOI\")\nTriple(0, 0, 8)\n>>> countCharacters(\"1n2s0e1s\")\nTriple(4, 4, 0)",
      "hy": "Գրեք Kotlin ֆունկցիա `fun countCharacters(s: String): Triple<Int, Int, Int>` հետևյալ խնդիրը լուծելու համար:\nՀաշվում է թվանշանների, փոքրատառերի և մեծատառերի քանակը տրված 8 երկարությամբ տողում։\n\n  @param s Մուտքային տողը 8 երկարությամբ։\n  @return Երեքական ամբողջ թվերի, որտեղ առաջին տարրը թվանշանների քանակն է,\n  երկրորդ տարրը փոքրատառերի քանակն է, և երրորդ տարրը մեծատառերի քանակն է տողի մեջ։\n\n  Օրինակ:\n  >>> countCharacters(\"yLOI2022\")\n  Triple(4, 1, 3)\n  >>> countCharacters(\"IAKIOIOI\")\n  Triple(0, 0, 8)\n  >>> countCharacters(\"1n2s0e1s\")\n  Triple(4, 4, 0)",
      "bn": "Kotlin ফাংশন `fun countCharacters(s: String): Triple<Int, Int, Int>` লিখুন নিম্নলিখিত সমস্যার সমাধানের জন্য:\nএকটি প্রদত্ত ৮ অক্ষরের স্ট্রিং-এ সংখ্যার সংখ্যা, ছোট হাতের অক্ষরের সংখ্যা এবং বড় হাতের অক্ষরের সংখ্যা গণনা করে।\n\n  @param s ৮ অক্ষরের ইনপুট স্ট্রিং।\n  @return পূর্ণসংখ্যার একটি Triple যেখানে প্রথম উপাদানটি সংখ্যার সংখ্যা,\n  দ্বিতীয় উপাদানটি ছোট হাতের অক্ষরের সংখ্যা, এবং তৃতীয় উপাদানটি\n  স্ট্রিং-এ বড় হাতের অক্ষরের সংখ্যা।\n\n  উদাহরণ:\n  >>> countCharacters(\"yLOI2022\")\n  Triple(4, 1, 3)\n  >>> countCharacters(\"IAKIOIOI\")\n  Triple(0, 0, 8)\n  >>> countCharacters(\"1n2s0e1s\")\n  Triple(4, 4, 0)",
      "bg": "Напишете Kotlin функция `fun countCharacters(s: String): Triple<Int, Int, Int>` за решаване на следния проблем:\nБрои броя на цифрите, малките букви и главните букви в даден низ с дължина 8.\n  \n  @param s Входният низ с дължина 8.\n  @return Троен кортеж от цели числа, където първият елемент е броят на цифрите,\n  вторият елемент е броят на малките букви, а третият елемент\n  е броят на главните букви в низа.\n  \n  Пример:\n  >>> countCharacters(\"yLOI2022\")\n  Triple(4, 1, 3)\n  >>> countCharacters(\"IAKIOIOI\")\n  Triple(0, 0, 8)\n  >>> countCharacters(\"1n2s0e1s\")\n  Triple(4, 4, 0)",
      "zh": "编写一个 Kotlin 函数 `fun countCharacters(s: String): Triple<Int, Int, Int>` 来解决以下问题：\n统计给定长度为 8 的字符串中数字、小写字母和大写字母的数量。\n\n@param s 长度为 8 的输入字符串。\n@return 一个整数的 Triple，其中第一个元素是数字的数量，第二个元素是小写字母的数量，第三个元素是字符串中大写字母的数量。\n\n示例:\n>>> countCharacters(\"yLOI2022\")\nTriple(4, 1, 3)\n>>> countCharacters(\"IAKIOIOI\")\nTriple(0, 0, 8)\n>>> countCharacters(\"1n2s0e1s\")\nTriple(4, 4, 0)",
      "fr": "Écrire une fonction Kotlin `fun countCharacters(s: String): Triple<Int, Int, Int>` pour résoudre le problème suivant :\nCompte le nombre de chiffres, de lettres minuscules et de lettres majuscules dans une chaîne donnée de longueur 8.\n\n  @param s La chaîne d'entrée de longueur 8.\n  @return Un Triple d'entiers où le premier élément est le compte des chiffres,\n  le deuxième élément est le compte des lettres minuscules, et le troisième élément\n  est le compte des lettres majuscules dans la chaîne.\n  \n  Exemple :\n  >>> countCharacters(\"yLOI2022\")\n  Triple(4, 1, 3)\n  >>> countCharacters(\"IAKIOIOI\")\n  Triple(0, 0, 8)\n  >>> countCharacters(\"1n2s0e1s\")\n  Triple(4, 4, 0)",
      "de": "Schreiben Sie eine Kotlin-Funktion `fun countCharacters(s: String): Triple<Int, Int, Int>`, um das folgende Problem zu lösen:\nZählt die Anzahl der Ziffern, Kleinbuchstaben und Großbuchstaben in einem gegebenen String der Länge 8.\n\n@param s Der Eingabestring der Länge 8.\n@return Ein Triple von ganzen Zahlen, wobei das erste Element die Anzahl der Ziffern ist,\ndas zweite Element die Anzahl der Kleinbuchstaben und das dritte Element\ndie Anzahl der Großbuchstaben im String.\n\nBeispiel:\n>>> countCharacters(\"yLOI2022\")\nTriple(4, 1, 3)\n>>> countCharacters(\"IAKIOIOI\")\nTriple(0, 0, 8)\n>>> countCharacters(\"1n2s0e1s\")\nTriple(4, 4, 0)",
      "ha": "Rubuta aikin Kotlin `fun countCharacters(s: String): Triple<Int, Int, Int>` don warware matsalar mai zuwa:\nYa ƙididdige adadin lambobi, ƙananan haruffa, da manyan haruffa a cikin wani baƙaƙen rubutu mai tsawon haruffa 8.\n\n  @param s Baƙaƙen rubutu na shigarwa mai tsawon haruffa 8.\n  @return Triple na lambobi inda na farko shine adadin lambobi,\n  na biyu shine adadin ƙananan haruffa, kuma na uku shine adadin manyan haruffa a cikin baƙaƙen rubutu.\n\n  Misali:\n  >>> countCharacters(\"yLOI2022\")\n  Triple(4, 1, 3)\n  >>> countCharacters(\"IAKIOIOI\")\n  Triple(0, 0, 8)\n  >>> countCharacters(\"1n2s0e1s\")\n  Triple(4, 4, 0)",
      "hi": "Kotlin फ़ंक्शन `fun countCharacters(s: String): Triple<Int, Int, Int>` लिखें ताकि निम्नलिखित समस्या का समाधान किया जा सके:\nदिए गए 8 अक्षरों की लंबाई वाले स्ट्रिंग में अंकों, छोटे अक्षरों और बड़े अक्षरों की संख्या की गणना करें।\n\n@param s इनपुट स्ट्रिंग जिसकी लंबाई 8 है।\n@return पूर्णांकों का एक Triple जहाँ पहला तत्व अंकों की गिनती है,\nदूसरा तत्व छोटे अक्षरों की गिनती है, और तीसरा तत्व\nस्ट्रिंग में बड़े अक्षरों की गिनती है।\n\nउदाहरण:\n>>> countCharacters(\"yLOI2022\")\nTriple(4, 1, 3)\n>>> countCharacters(\"IAKIOIOI\")\nTriple(0, 0, 8)\n>>> countCharacters(\"1n2s0e1s\")\nTriple(4, 4, 0)",
      "hu": "Írj egy Kotlin függvényt `fun countCharacters(s: String): Triple<Int, Int, Int>` a következő probléma megoldására:\nSzámolja meg a számjegyek, kisbetűk és nagybetűk számát egy adott, 8 hosszúságú sztringben.\n  \n  @param s A bemeneti sztring, amelynek hossza 8.\n  @return Egy egész számokat tartalmazó Triple, ahol az első elem a számjegyek száma,\n  a második elem a kisbetűk száma, és a harmadik elem a nagybetűk száma a sztringben.\n  \n  Példa:\n  >>> countCharacters(\"yLOI2022\")\n  Triple(4, 1, 3)\n  >>> countCharacters(\"IAKIOIOI\")\n  Triple(0, 0, 8)\n  >>> countCharacters(\"1n2s0e1s\")\n  Triple(4, 4, 0)"
    },
    "instruction_bertscore": {
      "sq": "0.8634151951978367",
      "hy": "0.9847666388176723",
      "bn": "0.9500013563770411",
      "bg": "0.9833069041474469",
      "zh": "0.9780769662147983",
      "fr": "0.9964745093670118",
      "de": "0.9835105002880077",
      "ha": "0.963733469139507",
      "hi": "0.9717337049964492",
      "hu": "0.9682330431610904"
    },
    "level": "easy",
    "test": "fun main() {\n    check(countCharacters(\"yLOI2022\") == Triple(4, 1, 3))\n    check(countCharacters(\"IAKIOIOI\") == Triple(0, 0, 8))\n    check(countCharacters(\"1n2s0e1s\") == Triple(4, 4, 0))\n}\n\n\nmain()",
    "entry_point": "countCharacters",
    "signature": "fun countCharacters(s: String): Triple<Int, Int, Int>",
    "docstring": {
      "en": "Counts the number of digits, lowercase letters, and uppercase letters in a given string of length 8.\n  \n  @param s The input string of length 8.\n  @return A Triple of integers where the first element is the count of digits,\n  the second element is the count of lowercase letters, and the third element\n  is the count of uppercase letters in the string.\n  \n  Example:\n  >>> countCharacters(\"yLOI2022\")\n  Triple(4, 1, 3)\n  >>> countCharacters(\"IAKIOIOI\")\n  Triple(0, 0, 8)\n  >>> countCharacters(\"1n2s0e1s\")\n  Triple(4, 4, 0)",
      "sq": "Numëron numrin e shifrave, shkronjave të vogla dhe shkronjave të mëdha në një varg të dhënë me gjatësi 8.\n\n@param s Vargu hyrës me gjatësi 8.\n@return Një Tresh i numrave të plotë ku elementi i parë është numri i shifrave,\nelementi i dytë është numri i shkronjave të vogla, dhe elementi i tretë\nështë numri i shkronjave të mëdha në varg.\n\nShembull:\n>>> countCharacters(\"yLOI2022\")\nTriple(4, 1, 3)\n>>> countCharacters(\"IAKIOIOI\")\nTriple(0, 0, 8)\n>>> countCharacters(\"1n2s0e1s\")\nTriple(4, 4, 0)",
      "hy": "Հաշվում է թվանշանների, փոքրատառերի և մեծատառերի քանակը տրված 8 երկարությամբ տողում։\n  \n  @param s Մուտքային տողը 8 երկարությամբ։\n  @return Երեք թվերի տիպ, որտեղ առաջին տարրը թվանշանների քանակն է,\n  երկրորդ տարրը փոքրատառերի քանակն է, և երրորդ տարրը մեծատառերի քանակն է տողում։\n  \n  Օրինակ:\n  >>> countCharacters(\"yLOI2022\")\n  Triple(4, 1, 3)\n  >>> countCharacters(\"IAKIOIOI\")\n  Triple(0, 0, 8)\n  >>> countCharacters(\"1n2s0e1s\")\n  Triple(4, 4, 0)",
      "bn": "একটি প্রদত্ত দৈর্ঘ্য 8 এর স্ট্রিং-এ সংখ্যা, ছোট হাতের অক্ষর, এবং বড় হাতের অক্ষর গণনা করে।\n\n@param s দৈর্ঘ্য 8 এর ইনপুট স্ট্রিং।\n@return পূর্ণসংখ্যার একটি Triple যেখানে প্রথম উপাদানটি সংখ্যা গণনা, দ্বিতীয় উপাদানটি ছোট হাতের অক্ষর গণনা, এবং তৃতীয় উপাদানটি বড় হাতের অক্ষর গণনা করে স্ট্রিং এ।\n\nউদাহরণ:\n>>> countCharacters(\"yLOI2022\")\nTriple(4, 1, 3)\n>>> countCharacters(\"IAKIOIOI\")\nTriple(0, 0, 8)\n>>> countCharacters(\"1n2s0e1s\")\nTriple(4, 4, 0)",
      "bg": "Брои броя на цифрите, малките букви и главните букви в даден низ с дължина 8.\n  \n  @param s Входният низ с дължина 8.\n  @return Тройка от цели числа, където първият елемент е броят на цифрите,\n  вторият елемент е броят на малките букви, а третият елемент\n  е броят на главните букви в низа.\n  \n  Пример:\n  >>> countCharacters(\"yLOI2022\")\n  Triple(4, 1, 3)\n  >>> countCharacters(\"IAKIOIOI\")\n  Triple(0, 0, 8)\n  >>> countCharacters(\"1n2s0e1s\")\n  Triple(4, 4, 0)",
      "zh": "计算给定长度为8的字符串中的数字、小写字母和大写字母的数量。\n\n@param s 长度为8的输入字符串。\n@return 一个整数三元组，其中第一个元素是数字的数量，第二个元素是小写字母的数量，第三个元素是字符串中大写字母的数量。\n\n示例：\n>>> countCharacters(\"yLOI2022\")\nTriple(4, 1, 3)\n>>> countCharacters(\"IAKIOIOI\")\nTriple(0, 0, 8)\n>>> countCharacters(\"1n2s0e1s\")\nTriple(4, 4, 0)",
      "fr": "Compte le nombre de chiffres, de lettres minuscules et de lettres majuscules dans une chaîne donnée de longueur 8.\n  \n  @param s La chaîne d'entrée de longueur 8.\n  @return Un Triple d'entiers où le premier élément est le compte des chiffres,\n  le deuxième élément est le compte des lettres minuscules, et le troisième élément\n  est le compte des lettres majuscules dans la chaîne.\n  \n  Exemple:\n  >>> countCharacters(\"yLOI2022\")\n  Triple(4, 1, 3)\n  >>> countCharacters(\"IAKIOIOI\")\n  Triple(0, 0, 8)\n  >>> countCharacters(\"1n2s0e1s\")\n  Triple(4, 4, 0)",
      "de": "Zählt die Anzahl der Ziffern, Kleinbuchstaben und Großbuchstaben in einem gegebenen String der Länge 8.\n  \n  @param s Der Eingabestring der Länge 8.\n  @return Ein Triple von ganzen Zahlen, wobei das erste Element die Anzahl der Ziffern ist,\n  das zweite Element die Anzahl der Kleinbuchstaben und das dritte Element\n  die Anzahl der Großbuchstaben im String.\n  \n  Beispiel:\n  >>> countCharacters(\"yLOI2022\")\n  Triple(4, 1, 3)\n  >>> countCharacters(\"IAKIOIOI\")\n  Triple(0, 0, 8)\n  >>> countCharacters(\"1n2s0e1s\")\n  Triple(4, 4, 0)",
      "ha": "Ya ƙididdige adadin lambobi, ƙananan haruffa, da manyan haruffa a cikin wani baƙaƙen rubutu mai tsawon haruffa 8.\n\n  @param s Baƙaƙen rubutu na shigarwa mai tsawon haruffa 8.\n  @return Triple na lambobi inda na farko shine adadin lambobi,\n  na biyu shine adadin ƙananan haruffa, kuma na uku shine adadin manyan haruffa a cikin baƙaƙen rubutu.\n\nMisali:  \n>>> countCharacters(\"yLOI2022\")  \nTriple(4, 1, 3)  \n>>> countCharacters(\"IAKIOIOI\")  \nTriple(0, 0, 8)  \n>>> countCharacters(\"1n2s0e1s\")  \nTriple(4, 4, 0)",
      "hi": "एक दिए गए 8 अक्षरों की लंबाई वाले स्ट्रिंग में अंकों, छोटे अक्षरों, और बड़े अक्षरों की संख्या गिनता है।\n\n@param s लंबाई 8 की इनपुट स्ट्रिंग।\n@return पूर्णांकों का एक Triple जहाँ पहला तत्व अंकों की गिनती है, दूसरा तत्व छोटे अक्षरों की गिनती है, और तीसरा तत्व बड़े अक्षरों की गिनती है।\n\nउदाहरण:\n>>> countCharacters(\"yLOI2022\")\nTriple(4, 1, 3)\n>>> countCharacters(\"IAKIOIOI\")\nTriple(0, 0, 8)\n>>> countCharacters(\"1n2s0e1s\")\nTriple(4, 4, 0)",
      "hu": "Számolja meg a számjegyek, kisbetűk és nagybetűk számát egy adott, 8 karakter hosszú sztringben.\n\n@param s A bemeneti sztring, amely 8 karakter hosszú.\n@return Egy három egész számot tartalmazó Triple, ahol az első elem a számjegyek száma,\na második elem a kisbetűk száma, és a harmadik elem a nagybetűk száma a sztringben.\n\nPélda:\n>>> countCharacters(\"yLOI2022\")\nTriple(4, 1, 3)\n>>> countCharacters(\"IAKIOIOI\")\nTriple(0, 0, 8)\n>>> countCharacters(\"1n2s0e1s\")\nTriple(4, 4, 0)"
    },
    "docstring_bertscore": {
      "sq": "0.9798223313729519",
      "hy": "0.9646833196216158",
      "bn": "0.9582669624230459",
      "bg": "0.9912004754897734",
      "zh": "0.9618581997121566",
      "fr": "1",
      "de": "0.9834556783028421",
      "ha": "1",
      "hi": "0.9792159128196524",
      "hu": "0.9441632122176636"
    }
  }
]