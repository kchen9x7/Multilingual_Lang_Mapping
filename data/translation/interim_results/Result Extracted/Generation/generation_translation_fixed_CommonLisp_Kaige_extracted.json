[
  {
    "task_id": "Common Lisp/1",
    "prompt": {
      "en": "(defun has-close-elements (numbers threshold)\n;;Check if in given list of numbers, are any two numbers closer to each other than\n;;given threshold.\n;;>>> has_close_elements([1.0, 2.0, 3.0], 0.5)\n;;nil\n;;>>> has_close_elements([1.0, 2.8, 3.0, 4.0, 5.0, 2.0], 0.3)\n;;t",
      "sq": "(defun has-close-elements (numbers threshold)\n;;Kontrollo nëse në listën e dhënë të numrave, ndonjë dy numra janë më afër njëri-tjetrit se\n;;pragu i dhënë.\n;;>>> has_close_elements([1.0, 2.0, 3.0], 0.5)\n;;nil\n;;>>> has_close_elements([1.0, 2.8, 3.0, 4.0, 5.0, 2.0], 0.3)\n;;t",
      "hy": "(defun has-close-elements (numbers threshold)\n;;Ստուգել, արդյոք տրված թվերի ցանկում կան երկու թվեր, որոնք միմյանցից ավելի մոտ են, քան\n;;տրված շեմը։\n;;>>> has_close_elements([1.0, 2.0, 3.0], 0.5)\n;;nil\n;;>>> has_close_elements([1.0, 2.8, 3.0, 4.0, 5.0, 2.0], 0.3)\n;;t",
      "bn": "(defun has-close-elements (numbers threshold)\n;;প্রদত্ত সংখ্যার তালিকায়, কোনো দুটি সংখ্যা কি একে অপরের থেকে প্রদত্ত থ্রেশহোল্ডের চেয়ে কাছাকাছি আছে কিনা তা পরীক্ষা করুন।\n;;>>> has_close_elements([1.0, 2.0, 3.0], 0.5)\n;;nil\n;;>>> has_close_elements([1.0, 2.8, 3.0, 4.0, 5.0, 2.0], 0.3)\n;;t",
      "bg": "(defun has-close-elements (numbers threshold)\n;;Проверете дали в дадения списък от числа има две числа, които са по-близо едно до друго от\n;;дадения праг.\n;;>>> has_close_elements([1.0, 2.0, 3.0], 0.5)\n;;nil\n;;>>> has_close_elements([1.0, 2.8, 3.0, 4.0, 5.0, 2.0], 0.3)\n;;t",
      "zh": "(defun has-close-elements (numbers threshold)\n;;检查在给定的数字列表中，是否有任意两个数字之间的距离小于给定的阈值。\n;;>>> has_close_elements([1.0, 2.0, 3.0], 0.5)\n;;nil\n;;>>> has_close_elements([1.0, 2.8, 3.0, 4.0, 5.0, 2.0], 0.3)\n;;t",
      "fr": "(defun has-close-elements (numbers threshold)\n;;Vérifier si, dans la liste donnée de nombres, il y a deux nombres plus proches l'un de l'autre que\n;;le seuil donné.\n;;>>> has_close_elements([1.0, 2.0, 3.0], 0.5)\n;;nil\n;;>>> has_close_elements([1.0, 2.8, 3.0, 4.0, 5.0, 2.0], 0.3)\n;;t",
      "de": "(defun has-close-elements (numbers threshold)\n;;Überprüfen, ob in der gegebenen Liste von Zahlen zwei Zahlen näher beieinander liegen als\n;;der gegebene Schwellenwert.\n;;>>> has_close_elements([1.0, 2.0, 3.0], 0.5)\n;;nil\n;;>>> has_close_elements([1.0, 2.8, 3.0, 4.0, 5.0, 2.0], 0.3)\n;;t",
      "ha": "(defun has-close-elements (numbers threshold)\n;; Duba idan a cikin jerin lambobin da aka bayar, akwai kowanne lambobi biyu da suka fi kusa da juna fiye da\n;; iyakar da aka bayar.\n;;>>> has_close_elements([1.0, 2.0, 3.0], 0.5)\n;;nil\n;;>>> has_close_elements([1.0, 2.8, 3.0, 4.0, 5.0, 2.0], 0.3)\n;;t",
      "hi": "(defun has-close-elements (numbers threshold)\n;;जाँचें कि दिए गए संख्याओं की सूची में, क्या कोई दो संख्याएँ एक-दूसरे के जितनी निकट हैं\n;;दिए गए सीमा से।\n;;>>> has_close_elements([1.0, 2.0, 3.0], 0.5)\n;;nil\n;;>>> has_close_elements([1.0, 2.8, 3.0, 4.0, 5.0, 2.0], 0.3)\n;;t",
      "hu": "(defun has-close-elements (numbers threshold)\n;;Ellenőrzi, hogy a megadott számok listájában van-e bármely két szám, amelyek közelebb vannak egymáshoz, mint a megadott küszöbérték.\n;;>>> has_close_elements([1.0, 2.0, 3.0], 0.5)\n;;nil\n;;>>> has_close_elements([1.0, 2.8, 3.0, 4.0, 5.0, 2.0], 0.3)\n;;t"
    },
    "prompt_bertscore": {
      "sq": "0.9815456485588107",
      "hy": "0.9573224749612249",
      "bn": "0.9696778805527381",
      "bg": "0.9706595118958126",
      "zh": "0.9562063708501899",
      "fr": "0.9732363438289782",
      "de": "0.9731626519576142",
      "ha": "0.9658578210646751",
      "hi": "0.9579308798183348",
      "hu": "0.9579298866664296"
    },
    "canonical_solution": "(loop for i from 0 below (length numbers)\ndo (loop for j from 0 below (length numbers)\ndo (when (and (/= i j)\n(< (abs (- (nth i numbers) (nth j numbers))) threshold))\n(return-from has-close-elements t))))\nnil)",
    "instruction": {
      "en": "Write a Common Lisp function `(defun has-close-elements (numbers threshold)` to solve the following problem:\nCheck if in given list of numbers, are any two numbers closer to each other than\ngiven threshold.\n>>> has_close_elements([1.0, 2.0, 3.0], 0.5)\n'nil\n>>> has_close_elements([1.0, 2.8, 3.0, 4.0, 5.0, 2.0], 0.3)\nt'",
      "sq": "Shkruani një funksion në Common Lisp `(defun has-close-elements (numbers threshold)` për të zgjidhur problemin e mëposhtëm:\nKontrolloni nëse në listën e dhënë të numrave, ndonjë dy numra janë më afër njëri-tjetrit sesa pragu i dhënë.\n>>> has_close_elements([1.0, 2.0, 3.0], 0.5)\n'nil\n>>> has_close_elements([1.0, 2.8, 3.0, 4.0, 5.0, 2.0], 0.3)\nt'",
      "hy": "Գրեք Common Lisp ֆունկցիա `(defun has-close-elements (numbers threshold)` հետևյալ խնդիրը լուծելու համար:\nՍտուգել, արդյոք տրված թվերի ցանկում կան երկու թվեր, որոնք ավելի մոտ են միմյանց, քան տրված շեմը։\n>>> has_close_elements([1.0, 2.0, 3.0], 0.5)\n'nil\n>>> has_close_elements([1.0, 2.8, 3.0, 4.0, 5.0, 2.0], 0.3)\nt'",
      "bn": "একটি Common Lisp ফাংশন `(defun has-close-elements (numbers threshold)` লিখুন নিম্নলিখিত সমস্যার সমাধানের জন্য:\nযাচাই করুন যে প্রদত্ত সংখ্যার তালিকায়, কোনো দুটি সংখ্যা কি একে অপরের থেকে প্রদত্ত সীমার চেয়ে কাছাকাছি আছে কিনা।\n>>> has_close_elements([1.0, 2.0, 3.0], 0.5)\n'nil\n>>> has_close_elements([1.0, 2.8, 3.0, 4.0, 5.0, 2.0], 0.3)\nt'",
      "bg": "Напишете функция на Common Lisp `(defun has-close-elements (numbers threshold)` за решаване на следния проблем:\nПроверете дали в даден списък от числа, има ли две числа, които са по-близо едно до друго от дадения праг.\n>>> has_close_elements([1.0, 2.0, 3.0], 0.5)\n'nil\n>>> has_close_elements([1.0, 2.8, 3.0, 4.0, 5.0, 2.0], 0.3)\nt'",
      "zh": "编写一个 Common Lisp 函数 `(defun has-close-elements (numbers threshold)` 来解决以下问题：\n检查在给定的数字列表中，是否有任意两个数字之间的距离小于给定的阈值。\n>>> has_close_elements([1.0, 2.0, 3.0], 0.5)\n'nil\n>>> has_close_elements([1.0, 2.8, 3.0, 4.0, 5.0, 2.0], 0.3)\nt'",
      "fr": "Écrire une fonction Common Lisp `(defun has-close-elements (numbers threshold)` pour résoudre le problème suivant:\nVérifiez si, dans une liste donnée de nombres, il y a deux nombres plus proches l'un de l'autre que le seuil donné.\n>>> has_close_elements([1.0, 2.0, 3.0], 0.5)\n'nil\n>>> has_close_elements([1.0, 2.8, 3.0, 4.0, 5.0, 2.0], 0.3)\nt'",
      "de": "Schreiben Sie eine Common Lisp-Funktion `(defun has-close-elements (numbers threshold)` um das folgende Problem zu lösen:\nÜberprüfen Sie, ob in der gegebenen Liste von Zahlen zwei Zahlen näher beieinander liegen als der gegebene Schwellenwert.\n>>> has_close_elements([1.0, 2.0, 3.0], 0.5)\n'nil\n>>> has_close_elements([1.0, 2.8, 3.0, 4.0, 5.0, 2.0], 0.3)\nt'",
      "ha": "Rubuta wani aikin Common Lisp `(defun has-close-elements (numbers threshold)` don warware matsalar mai zuwa:\nDuba idan a cikin jerin lambobin da aka bayar, akwai wasu lambobi biyu da suka fi kusa da juna fiye da\nmatsayin da aka bayar.\n>>> has_close_elements([1.0, 2.0, 3.0], 0.5)\n'nil\n>>> has_close_elements([1.0, 2.8, 3.0, 4.0, 5.0, 2.0], 0.3)\nt'",
      "hi": "एक Common Lisp फ़ंक्शन `(defun has-close-elements (numbers threshold)` लिखें ताकि निम्नलिखित समस्या का समाधान किया जा सके:\nजांचें कि दिए गए संख्याओं की सूची में, क्या कोई दो संख्याएं एक-दूसरे के करीब हैं दिए गए सीमा से।\n>>> has_close_elements([1.0, 2.0, 3.0], 0.5)\n'nil\n>>> has_close_elements([1.0, 2.8, 3.0, 4.0, 5.0, 2.0], 0.3)\nt'",
      "hu": "Írj egy Common Lisp függvényt `(defun has-close-elements (numbers threshold)` a következő probléma megoldására:\nEllenőrizd, hogy a megadott számok listájában van-e bármely két szám, amelyek közelebb vannak egymáshoz, mint a megadott küszöbérték.\n>>> has_close_elements([1.0, 2.0, 3.0], 0.5)\n'nil\n>>> has_close_elements([1.0, 2.8, 3.0, 4.0, 5.0, 2.0], 0.3)\nt'"
    },
    "instruction_bertscore": {
      "sq": "0.9775565546164869",
      "hy": "0.9654977666717352",
      "bn": "0.9787700501021053",
      "bg": "0.9647737589328629",
      "zh": "0.9495346374694853",
      "fr": "0.9739688926742348",
      "de": "0.9745592846545467",
      "ha": "0.9739941812205025",
      "hi": "0.9717868017960617",
      "hu": "0.9683599679745716"
    },
    "level": "middle",
    "test": "(defun check-has-close-elements ()\n(assert (equal (has-close-elements '(1.0 2.0 3.9 4.0 5.0 2.2) 0.3) t))\n(assert (equal (has-close-elements '(1.0 2.0 3.9 4.0 5.0 2.2) 0.05) nil))\n(assert (equal (has-close-elements '(1.0 2.0 5.9 4.0 5.0) 0.95) t))\n(assert (equal (has-close-elements '(1.0 2.0 5.9 4.0 5.0) 0.8) nil))\n(assert (equal (has-close-elements '(1.0 2.0 3.0 4.0 5.0 2.0) 0.1) t))\n(assert (equal (has-close-elements '(1.1 2.2 3.1 4.1 5.1) 1.0) t))\n(assert (equal (has-close-elements '(1.1 2.2 3.1 4.1 5.1) 0.5) nil)))\n\n(check-has-close-elements)",
    "entry_point": "has-close-elements",
    "signature": "(defun has-close-elements (numbers threshold)",
    "docstring": {
      "en": "Check if in given list of numbers, are any two numbers closer to each other than\ngiven threshold.\n>>> has_close_elements([1.0, 2.0, 3.0], 0.5)\n'nil\n>>> has_close_elements([1.0, 2.8, 3.0, 4.0, 5.0, 2.0], 0.3)\nt'",
      "sq": "Kontrollo nëse në listën e dhënë të numrave, ndonjë dy numra janë më afër njëri-tjetrit sesa pragu i dhënë.\n>>> has_close_elements([1.0, 2.0, 3.0], 0.5)\n'nil\n>>> has_close_elements([1.0, 2.8, 3.0, 4.0, 5.0, 2.0], 0.3)\nt'",
      "hy": "Ստուգեք, արդյոք տրված թվերի ցանկում կան երկու թվեր, որոնք միմյանցից ավելի մոտ են, քան տրված շեմը:\n>>> has_close_elements([1.0, 2.0, 3.0], 0.5)\n'nil\n>>> has_close_elements([1.0, 2.8, 3.0, 4.0, 5.0, 2.0], 0.3)\nt'",
      "bn": "প্রদত্ত সংখ্যার তালিকায়, কোনো দুটি সংখ্যা নির্দিষ্ট সীমার চেয়ে কাছাকাছি আছে কিনা তা পরীক্ষা করুন।\n>>> has_close_elements([1.0, 2.0, 3.0], 0.5)\n'nil\n>>> has_close_elements([1.0, 2.8, 3.0, 4.0, 5.0, 2.0], 0.3)\nt'",
      "bg": "Проверете дали в даден списък от числа има две числа, които са по-близо едно до друго от дадения праг.\n>>> has_close_elements([1.0, 2.0, 3.0], 0.5)\n'nil\n>>> has_close_elements([1.0, 2.8, 3.0, 4.0, 5.0, 2.0], 0.3)\nt'",
      "zh": "检查给定数字列表中是否有任意两个数字之间的距离小于给定的阈值。\n>>> has_close_elements([1.0, 2.0, 3.0], 0.5)\n'nil\n>>> has_close_elements([1.0, 2.8, 3.0, 4.0, 5.0, 2.0], 0.3)\nt'",
      "fr": "Vérifiez si, dans une liste donnée de nombres, deux nombres sont plus proches l'un de l'autre que le seuil donné.\n>>> has_close_elements([1.0, 2.0, 3.0], 0.5)\n'nil\n>>> has_close_elements([1.0, 2.8, 3.0, 4.0, 5.0, 2.0], 0.3)\nt'",
      "de": "Überprüfen Sie, ob in der gegebenen Liste von Zahlen zwei Zahlen näher beieinander liegen als der angegebene Schwellenwert.\n>>> has_close_elements([1.0, 2.0, 3.0], 0.5)\n'nil\n>>> has_close_elements([1.0, 2.8, 3.0, 4.0, 5.0, 2.0], 0.3)\nt'",
      "ha": "Duba idan a cikin jerin lambobi da aka bayar, akwai kowanne lambobi biyu da ke kusa da juna fiye da\nmatakin da aka bayar.\n>>> has_close_elements([1.0, 2.0, 3.0], 0.5)\n'nil\n>>> has_close_elements([1.0, 2.8, 3.0, 4.0, 5.0, 2.0], 0.3)\nt'",
      "hi": "दिए गए संख्याओं की सूची में जाँच करें कि क्या कोई दो संख्याएँ दी गई सीमा से अधिक निकट हैं।\n>>> has_close_elements([1.0, 2.0, 3.0], 0.5)\n'nil\n>>> has_close_elements([1.0, 2.8, 3.0, 4.0, 5.0, 2.0], 0.3)\nt'",
      "hu": "Ellenőrizze, hogy a megadott számok listájában van-e bármely két szám, amely közelebb van egymáshoz, mint a megadott küszöb.\n>>> has_close_elements([1.0, 2.0, 3.0], 0.5)\n'nil\n>>> has_close_elements([1.0, 2.8, 3.0, 4.0, 5.0, 2.0], 0.3)\nt'"
    },
    "docstring_bertscore": {
      "sq": "0.9796161530374377",
      "hy": "0.958967730407337",
      "bn": "0.9366623331386431",
      "bg": "0.9575783108919979",
      "zh": "0.9426480596711295",
      "fr": "0.9708134504411146",
      "de": "0.9646414086112175",
      "ha": "0.962839433794469",
      "hi": "0.9501499319020551",
      "hu": "0.9521864891988059"
    }
  },
  {
    "task_id": "Common Lisp/2",
    "prompt": {
      "en": "(defun bin-search (obj vec)\n;; Binary search for 'obj' in sorted vector 'vec'.\n;; Returns 't' if 'obj' is found, 'nil' otherwise.\n;; Example:\n;; >>> bin-search 3 '#(1 2 3 4 5)\n;; t",
      "sq": "(defun bin-search (obj vec)\n;; Kërkimi binar për 'obj' në vektorin e renditur 'vec'.\n;; Kthen 't' nëse 'obj' gjendet, 'nil' përndryshe.\n;; Shembull:\n;; >>> bin-search 3 '#(1 2 3 4 5)\n;; t",
      "hy": "(defun bin-search (obj vec)\n;; Երկվորյակ որոնում 'obj'-ի համար դասավորված վեկտորում 'vec'.\n;; Վերադարձնում է 't', եթե 'obj'-ը գտնվել է, 'nil' հակառակ դեպքում.\n;; Օրինակ:\n;; >>> bin-search 3 '#(1 2 3 4 5)\n;; t",
      "bn": "(defun bin-search (obj vec)\n;; সাজানো ভেক্টর 'vec' এ 'obj' এর জন্য বাইনারি অনুসন্ধান।\n;; 'obj' পাওয়া গেলে 't' ফেরত দেয়, অন্যথায় 'nil'।\n;; উদাহরণ:\n;; >>> bin-search 3 '#(1 2 3 4 5)\n;; t",
      "bg": "(defun bin-search (obj vec)\n;; Двоично търсене на 'obj' в сортиран вектор 'vec'.\n;; Връща 't', ако 'obj' е намерен, 'nil' в противен случай.\n;; Пример:\n;; >>> bin-search 3 '#(1 2 3 4 5)\n;; t",
      "zh": "(defun bin-search (obj vec)\n;; 在排序向量 'vec' 中进行二分查找 'obj'。\n;; 如果找到 'obj'，返回 't'，否则返回 'nil'。\n;; 示例:\n;; >>> bin-search 3 '#(1 2 3 4 5)\n;; t",
      "fr": "(defun bin-search (obj vec)\n;; Recherche binaire pour 'obj' dans le vecteur trié 'vec'.\n;; Renvoie 't' si 'obj' est trouvé, 'nil' sinon.\n;; Exemple:\n;; >>> bin-search 3 '#(1 2 3 4 5)\n;; t",
      "de": "(defun bin-search (obj vec)\n;; Binäre Suche nach 'obj' im sortierten Vektor 'vec'.\n;; Gibt 't' zurück, wenn 'obj' gefunden wird, 'nil' andernfalls.\n;; Beispiel:\n;; >>> bin-search 3 '#(1 2 3 4 5)\n;; t",
      "ha": "(defun bin-search (obj vec)\n;; Bincike na binary don 'obj' a cikin jere mai tsari 'vec'.\n;; Ya dawo da 't' idan an sami 'obj', 'nil' in ba haka ba.\n;; Misali:\n;; >>> bin-search 3 '#(1 2 3 4 5)\n;; t",
      "hi": "(defun bin-search (obj vec)\n;; क्रमबद्ध वेक्टर 'vec' में 'obj' के लिए बाइनरी खोज।\n;; यदि 'obj' पाया जाता है तो 't' लौटाता है, अन्यथा 'nil'।\n;; उदाहरण:\n;; >>> bin-search 3 '#(1 2 3 4 5)\n;; t",
      "hu": "(defun bin-search (obj vec)\n;; Bináris keresés 'obj' elemre a rendezett 'vec' vektorban.\n;; 't' értéket ad vissza, ha az 'obj' megtalálható, különben 'nil'-t.\n;; Példa:\n;; >>> bin-search 3 '#(1 2 3 4 5)\n;; t"
    },
    "prompt_bertscore": {
      "sq": "0.9954579190768752",
      "hy": "0.9954579190768752",
      "bn": "0.9707796832763387",
      "bg": "0.9951560008977022",
      "zh": "0.9340318710025981",
      "fr": "0.9954579190768752",
      "de": "0.9954579190768752",
      "ha": "0.9827531226451217",
      "hi": "0.9640824627189853",
      "hu": "0.9655239233941555"
    },
    "canonical_solution": "(let ((low 0)\n(high (1- (length vec))))\n(loop while (<= low high)\nfor mid = (floor (+ low high) 2)\nfor mid-val = (aref vec mid)\ndo (cond ((= obj mid-val) (return-from bin-search t))\n((< obj mid-val) (setf high (1- mid)))\n((> obj mid-val) (setf low (1+ mid)))))\nnil))",
    "instruction": {
      "en": "Write a Common Lisp function `(defun bin-search (obj vec)` to solve the following problem:\nBinary search for 'obj' in sorted vector 'vec'.\nReturns 't' if 'obj' is found, 'nil' otherwise.\nExample:\n>>> bin-search 3 '#(1 2 3 4 5)\nt",
      "sq": "Shkruani një funksion Common Lisp `(defun bin-search (obj vec)` për të zgjidhur problemin e mëposhtëm:  \nKërkimi binar për 'obj' në vektorin e renditur 'vec'.  \nKthen 't' nëse 'obj' gjendet, 'nil' përndryshe.  \nShembull:  \n>>> bin-search 3 '#(1 2 3 4 5)  \nt",
      "hy": "Գրեք Common Lisp ֆունկցիա `(defun bin-search (obj vec)` հետևյալ խնդիրը լուծելու համար:\nԲինար որոնում 'obj'-ի համար դասավորված վեկտոր 'vec'-ում:\nՎերադարձնում է 't', եթե 'obj'-ն գտնվել է, 'nil' հակառակ դեպքում:\nՕրինակ:\n>>> bin-search 3 '#(1 2 3 4 5)\nt",
      "bn": "বাংলায় নিম্নলিখিত সমস্যার সমাধান করতে একটি কমন লিস্প ফাংশন `(defun bin-search (obj vec)` লিখুন:\nসাজানো ভেক্টর 'vec' এ 'obj' এর জন্য বাইনারি অনুসন্ধান।\n'obj' পাওয়া গেলে 't' রিটার্ন করে, অন্যথায় 'nil' রিটার্ন করে।\nউদাহরণ:\n>>> bin-search 3 '#(1 2 3 4 5)\nt",
      "bg": "Напишете функция на Common Lisp `(defun bin-search (obj vec)` за решаване на следния проблем:\nДвоично търсене на 'obj' в сортиран вектор 'vec'.\nВръща 't', ако 'obj' е намерен, 'nil' в противен случай.\nПример:\n>>> bin-search 3 '#(1 2 3 4 5)\nt",
      "zh": "编写一个 Common Lisp 函数 `(defun bin-search (obj vec)` 来解决以下问题：  \n在排序向量 'vec' 中进行二分搜索 'obj'。  \n如果找到 'obj'，返回 't'，否则返回 'nil'。  \n示例:  \n>>> bin-search 3 '#(1 2 3 4 5)  \nt",
      "fr": "Écrire une fonction Common Lisp `(defun bin-search (obj vec)` pour résoudre le problème suivant :  \nRecherche binaire de 'obj' dans le vecteur trié 'vec'.  \nRenvoie 't' si 'obj' est trouvé, 'nil' sinon.  \nExemple :  \n>>> bin-search 3 '#(1 2 3 4 5)  \nt",
      "de": "Schreiben Sie eine Common Lisp-Funktion `(defun bin-search (obj vec)` um das folgende Problem zu lösen:\nBinäre Suche nach 'obj' im sortierten Vektor 'vec'.\nGibt 't' zurück, wenn 'obj' gefunden wird, 'nil' andernfalls.\nBeispiel:\n>>> bin-search 3 '#(1 2 3 4 5)\nt",
      "ha": "Rubuta aikin Common Lisp `(defun bin-search (obj vec)` don warware matsalar mai zuwa:\nBinciken binary don 'obj' a cikin vector mai tsari 'vec'.\nYana dawowa 't' idan an samo 'obj', 'nil' in ba haka ba.\nMisali:\n>>> bin-search 3 '#(1 2 3 4 5)\nt",
      "hi": "एक Common Lisp फ़ंक्शन `(defun bin-search (obj vec)` लिखें ताकि निम्नलिखित समस्या का समाधान किया जा सके:\nसॉर्टेड वेक्टर 'vec' में 'obj' के लिए बाइनरी खोज।\nयदि 'obj' पाया जाता है तो 't' लौटाता है, अन्यथा 'nil'।\nउदाहरण:\n>>> bin-search 3 '#(1 2 3 4 5)\nt",
      "hu": "Írj egy Common Lisp függvényt `(defun bin-search (obj vec)` a következő probléma megoldására:  \nBináris keresés 'obj' elemre a rendezett 'vec' vektorban.  \n't' értéket ad vissza, ha 'obj' megtalálható, különben 'nil'-t.  \nPélda:  \n>>> bin-search 3 '#(1 2 3 4 5)  \nt"
    },
    "instruction_bertscore": {
      "sq": "0.9943100341048746",
      "hy": "0.9943100341048746",
      "bn": "0.8887997606333333",
      "bg": "0.9872399843223187",
      "zh": "0.9414926267446495",
      "fr": "0.9943100341048746",
      "de": "0.9943100341048746",
      "ha": "0.9841193024058796",
      "hi": "0.9763355736642655",
      "hu": "0.9668758017674789"
    },
    "level": "middle",
    "test": "(defun check-bin-search ()\n;; Test the 'bin-search' function with various cases.\n(assert (equal (bin-search 3 '#(1 2 3 4 5)) t))\n(assert (equal (bin-search 6 '#(1 2 3 4 5)) nil))\n(assert (equal (bin-search 1 '#(1)) t))\n(assert (equal (bin-search 2 '#(1)) nil))\n(assert (equal (bin-search 0 '#()) nil))\n(assert (equal (bin-search 5 '#(2 4 6 8 10)) nil))\n(assert (equal (bin-search 4 '#(2 4 6 8 10)) t)))\n\n(check-bin-search)",
    "entry_point": "bin-search",
    "signature": "(defun bin-search (obj vec)",
    "docstring": {
      "en": "Binary search for 'obj' in sorted vector 'vec'.\nReturns 't' if 'obj' is found, 'nil' otherwise.\nExample:\n>>> bin-search 3 '#(1 2 3 4 5)\nt",
      "sq": "Kërkimi binar për 'obj' në vektorin e renditur 'vec'. \nKthen 't' nëse 'obj' gjendet, 'nil' përndryshe. \nShembull: \n>>> bin-search 3 '#(1 2 3 4 5) \nt",
      "hy": "Բինար որոնում 'obj'-ի համար սորտավորված վեկտոր 'vec'-ում: \nՎերադարձնում է 't', եթե 'obj'-ը գտնվել է, 'nil' հակառակ դեպքում: \nՕրինակ:\n>>> bin-search 3 '#(1 2 3 4 5)\nt",
      "bn": "সাজানো ভেক্টর 'vec'-এ 'obj' এর জন্য বাইনারি অনুসন্ধান। \n'obj' পাওয়া গেলে 't' ফেরত দেয়, অন্যথায় 'nil' ফেরত দেয়।\nউদাহরণ:\n>>> bin-search 3 '#(1 2 3 4 5)\nt",
      "bg": "Двоично търсене за 'obj' в сортиран вектор 'vec'.  \nВръща 't', ако 'obj' е намерен, 'nil' в противен случай.  \nПример:  \n>>> bin-search 3 '#(1 2 3 4 5)  \nt",
      "zh": "在已排序的向量 'vec' 中进行 'obj' 的二分查找。\n如果找到 'obj'，则返回 't'，否则返回 'nil'。\n示例:\n>>> bin-search 3 '#(1 2 3 4 5)\nt",
      "fr": "Recherche binaire pour 'obj' dans le vecteur trié 'vec'.  \nRenvoie 't' si 'obj' est trouvé, 'nil' sinon.  \nExemple :  \n>>> bin-search 3 '#(1 2 3 4 5)  \nt",
      "de": "Binäre Suche nach 'obj' im sortierten Vektor 'vec'.\nGibt 't' zurück, wenn 'obj' gefunden wird, andernfalls 'nil'.\nBeispiel:\n>>> bin-search 3 '#(1 2 3 4 5)\nt",
      "ha": "Binciken binary don 'obj' a cikin vector da aka tsara 'vec'. \nYa dawo da 't' idan an sami 'obj', 'nil' in ba haka ba. \nMisali: \n>>> bin-search 3 '#(1 2 3 4 5) \nt",
      "hi": "सॉर्ट किए गए वेक्टर 'vec' में 'obj' के लिए बाइनरी खोज।  \n'obj' मिलने पर 't' लौटाता है, अन्यथा 'nil'।  \nउदाहरण:  \n>>> bin-search 3 '#(1 2 3 4 5)  \nt",
      "hu": "Bináris keresés az 'obj' elemre a rendezett 'vec' vektorban.\n't' értéket ad vissza, ha az 'obj' megtalálható, különben 'nil'-t.\nPélda:\n>>> bin-search 3 '#(1 2 3 4 5)\nt"
    },
    "docstring_bertscore": {
      "sq": "0.9936078757079163",
      "hy": "1",
      "bn": "0.9631286396292558",
      "bg": "0.9931643340670654",
      "zh": "0.8934773074763239",
      "fr": "0.9936078757079163",
      "de": "0.9683651323644785",
      "ha": "0.9936078757079163",
      "hi": "0.9683651323644785",
      "hu": "0.942952957306018"
    }
  },
  {
    "task_id": "Common Lisp/3",
    "prompt": {
      "en": "(defun parse-date (date-str)\n\"Parse a date string in the format 'DD MMM YYYY' and return a list (day month year).\"\n;; Example:\n;; >>> parse-date \"16 Aug 1980\"\n;; 16 8 1980",
      "sq": "(defun parse-date (date-str)\n\"Analizo një varg date në formatin 'DD MMM YYYY' dhe kthe një listë (ditë muaj vit).\"\n;; Shembull:\n;; >>> parse-date \"16 Aug 1980\"\n;; 16 8 1980",
      "hy": "(defun parse-date (date-str)\n\"Վերլուծել ամսաթվի տողը 'DD MMM YYYY' ձևաչափով և վերադարձնել ցուցակ (օր ամիս տարի):\"\n;; Օրինակ:\n;; >>> parse-date \"16 Aug 1980\"\n;; 16 8 1980",
      "bn": "(defun parse-date (date-str)\n\"তারিখের স্ট্রিং 'DD MMM YYYY' বিন্যাসে পার্স করুন এবং একটি তালিকা (দিন মাস বছর) ফেরত দিন।\"\n;; উদাহরণ:\n;; >>> parse-date \"16 Aug 1980\"\n;; 16 8 1980",
      "bg": "(defun parse-date (date-str)\n\"Парсирайте низ за дата във формат 'DD MMM YYYY' и върнете списък (ден месец година).\"\n;; Пример:\n;; >>> parse-date \"16 Aug 1980\"\n;; 16 8 1980",
      "zh": "(defun parse-date (date-str)\n\"解析格式为 'DD MMM YYYY' 的日期字符串，并返回一个列表 (day month year)。\"\n;; 示例:\n;; >>> parse-date \"16 Aug 1980\"\n;; 16 8 1980",
      "fr": "(defun parse-date (date-str)\n\"Analyser une chaîne de date au format 'JJ MMM AAAA' et retourner une liste (jour mois année).\"\n;; Exemple :\n;; >>> parse-date \"16 Aug 1980\"\n;; 16 8 1980",
      "de": "(defun parse-date (date-str)\n\"Analysiere einen Datumsstring im Format 'DD MMM YYYY' und gebe eine Liste (Tag Monat Jahr) zurück.\"\n;; Beispiel:\n;; >>> parse-date \"16 Aug 1980\"\n;; 16 8 1980",
      "ha": "(defun parse-date (date-str)\n\"Fassara wata ƙirar kwanan wata a cikin tsarin 'DD MMM YYYY' kuma dawo da jerin (rana wata shekara).\"\n;; Misali:\n;; >>> parse-date \"16 Aug 1980\"\n;; 16 8 1980",
      "hi": "(defun parse-date (date-str)\n\"तारीख स्ट्रिंग को 'DD MMM YYYY' प्रारूप में पार्स करें और एक सूची (दिन महीना वर्ष) लौटाएं।\"\n;; उदाहरण:\n;; >>> parse-date \"16 Aug 1980\"\n;; 16 8 1980",
      "hu": "(defun parse-date (date-str)\n\"Parsoljon egy dátum karakterláncot a 'NN HHH ÉÉÉÉ' formátumban, és adjon vissza egy listát (nap hónap év).\"\n;; Példa:\n;; >>> parse-date \"16 Aug 1980\"\n;; 16 8 1980"
    },
    "prompt_bertscore": {
      "sq": "1",
      "hy": "0.9740652284090368",
      "bn": "0.984695926402024",
      "bg": "1",
      "zh": "1",
      "fr": "1",
      "de": "1",
      "ha": "1",
      "hi": "0.984695926402024",
      "hu": "1"
    },
    "canonical_solution": "(let ((toks (tokens date-str #'constituent 0)))\n(list (parse-integer (first toks):junk-allowed t)\n(parse-month (second toks))\n(parse-integer (third toks)))))\n\n(defun tokens (str test start)\n(let ((p1 (position-if test str :start start)))\n(if p1\n(let ((p2 (position-if #'(lambda (c)\n(not (funcall test c)))\nstr :start p1)))\n(cons (subseq str p1 p2)\n(if p2\n(tokens str test p2)\nnil)))\nnil)))\n(defun constituent (c)\n(and (graphic-char-p c)\n(not (char= c #\\ ))))\n\n(defconstant month-names\n'(\"jan\" \"feb\" \"mar\" \"apr\" \"may\" \"jun\"\n\"jul\" \"aug\" \"sep\" \"oct\" \"nov\" \"dec\"))\n\n(defun parse-month (str)\n\"Parse the month string and return the month number.\"\n(let ((p (position (string-downcase str) month-names :test #'string-equal)))\n(if p\n(1+ p)\n(error \"Invalid month string: ~A\" str))))",
    "instruction": {
      "en": "Write a Common Lisp function `(defun parse-date (date-str)` to solve the following problem:\n\"Parse a date string in the format 'DD MMM YYYY' and return a list (day month year).\"\nExample:\n>>> parse-date \"16 Aug 1980\"\n16 8 1980",
      "sq": "Shkruani një funksion Common Lisp `(defun parse-date (date-str)` për të zgjidhur problemin e mëposhtëm:  \n\"Analizoni një varg date në formatin 'DD MMM YYYY' dhe ktheni një listë (dita muaji viti).\"  \nShembull:  \n>>> parse-date \"16 Aug 1980\"  \n16 8 1980",
      "hy": "Գրեք Common Lisp ֆունկցիա `(defun parse-date (date-str)` հետևյալ խնդիրը լուծելու համար:\n\"Վերլուծել ամսաթվի տողը 'DD MMM YYYY' ձևաչափով և վերադարձնել ցուցակ (օր ամիս տարի):\"\nՕրինակ:\n>>> parse-date \"16 Aug 1980\"\n16 8 1980",
      "bn": "একটি Common Lisp ফাংশন `(defun parse-date (date-str)` লিখুন নিম্নলিখিত সমস্যার সমাধান করতে: \"একটি তারিখ স্ট্রিং 'DD MMM YYYY' ফরম্যাটে পার্স করুন এবং একটি তালিকা (day month year) রিটার্ন করুন।\" উদাহরণ: >>> parse-date \"16 Aug 1980\" 16 8 1980",
      "bg": "Напишете функция на Common Lisp `(defun parse-date (date-str)` за решаване на следния проблем:  \n„Анализирайте низ за дата във формат 'DD MMM YYYY' и върнете списък (ден месец година).“  \nПример:  \n>>> parse-date \"16 Aug 1980\"  \n16 8 1980",
      "zh": "编写一个 Common Lisp 函数 `(defun parse-date (date-str)` 来解决以下问题：  \n“解析格式为 'DD MMM YYYY' 的日期字符串，并返回一个列表 (day month year)。”  \n示例：  \n>>> parse-date \"16 Aug 1980\"  \n16 8 1980",
      "fr": "Écrire une fonction Common Lisp `(defun parse-date (date-str)` pour résoudre le problème suivant :\n\"Analyser une chaîne de date au format 'DD MMM YYYY' et retourner une liste (jour mois année).\"",
      "de": "Schreiben Sie eine Common Lisp Funktion `(defun parse-date (date-str)` um das folgende Problem zu lösen:\n\"Analysieren Sie einen Datumsstring im Format 'DD MMM YYYY' und geben Sie eine Liste (Tag Monat Jahr) zurück.\"\nBeispiel:\n>>> parse-date \"16 Aug 1980\"\n16 8 1980",
      "ha": "Rubuta aikin Common Lisp `(defun parse-date (date-str)` don warware matsalar mai zuwa:\n\"Fassara rubutun kwanan wata a cikin tsarin 'DD MMM YYYY' kuma mayar da jerin (rana wata shekara).\"",
      "hi": "एक Common Lisp फ़ंक्शन `(defun parse-date (date-str)` लिखें ताकि निम्नलिखित समस्या का समाधान किया जा सके:\n\"एक दिनांक स्ट्रिंग को 'DD MMM YYYY' प्रारूप में पार्स करें और एक सूची (day month year) लौटाएं।\"\nउदाहरण:\n>>> parse-date \"16 Aug 1980\"\n16 8 1980",
      "hu": "Írj egy Common Lisp függvényt `(defun parse-date (date-str)` a következő probléma megoldására:\n\"Parsolj egy dátum stringet a 'DD MMM YYYY' formátumban, és adj vissza egy listát (nap hónap év).\""
    },
    "instruction_bertscore": {
      "sq": "1",
      "hy": "1",
      "bn": "0.9937868416812287",
      "bg": "1",
      "zh": "1",
      "fr": "0.9234885703772663",
      "de": "1",
      "ha": "0.8835861103919296",
      "hi": "0.9937868416812287",
      "hu": "0.9171876174300775"
    },
    "level": "hard",
    "test": "(defun check-parse-date ()\n;; Test the 'parse-date' function with various date strings.\n(assert (equal (parse-date \"16 Aug 1980\") '(16 8 1980)))\n(assert (equal (parse-date \"1 Jan 2023\") '(1 1 2023)))\n(assert (equal (parse-date \"25 Dec 1999\") '(25 12 1999)))\n(assert (equal (parse-date \"31 Oct 2025\") '(31 10 2025)))\n(assert (equal (parse-date \"20 Feb 2010\") '(20 2 2010))))\n\n(check-parse-date)",
    "entry_point": "parse-date",
    "signature": "(defun parse-date (date-str)",
    "docstring": {
      "en": "\"Parse a date string in the format 'DD MMM YYYY' and return a list (day month year).\"\nExample:\n>>> parse-date \"16 Aug 1980\"\n16 8 1980",
      "sq": "\"Analizo një varg date në formatin 'DD MMM YYYY' dhe kthe një listë (dita muaji viti).\"\nShembull:\n>>> parse-date \"16 Aug 1980\"\n16 8 1980",
      "hy": "\"Վերլուծել ամսաթվի տողը 'DD MMM YYYY' ձևաչափով և վերադարձնել ցուցակ (օր ամիս տարի):\"\nՕրինակ:\n>>> parse-date \"16 Aug 1980\"\n16 8 1980",
      "bn": "\"একটি তারিখ স্ট্রিং 'DD MMM YYYY' বিন্যাসে পার্স করুন এবং একটি তালিকা (দিন মাস বছর) রিটার্ন করুন।\"\nউদাহরণ:\n>>> parse-date \"16 Aug 1980\"\n16 8 1980",
      "bg": "\"Парсирайте низ за дата във формат 'DD MMM YYYY' и върнете списък (ден месец година).\"\nПример:\n>>> parse-date \"16 Aug 1980\"\n16 8 1980",
      "zh": "\"解析格式为 'DD MMM YYYY' 的日期字符串，并返回一个列表（天 月 年）。\"\n示例：\n>>> parse-date \"16 Aug 1980\"\n16 8 1980",
      "fr": "\"Analyser une chaîne de date au format 'JJ MMM AAAA' et retourner une liste (jour mois année).\"\nExemple:\n>>> parse-date \"16 Aug 1980\"\n16 8 1980",
      "de": "\"Analysiere einen Datumsstring im Format 'DD MMM YYYY' und gib eine Liste (Tag Monat Jahr) zurück.\"\nBeispiel:\n>>> parse-date \"16 Aug 1980\"\n16 8 1980",
      "ha": "\"Fassara wani jeren kwanan wata a cikin tsarin 'DD MMM YYYY' kuma dawo da jerin (rana wata shekara).\"\n\nMisali:\n>>> parse-date \"16 Aug 1980\"\n16 8 1980",
      "hi": "\"तारीख स्ट्रिंग को 'DD MMM YYYY' प्रारूप में पार्स करें और एक सूची (दिन माह वर्ष) लौटाएं।\"\nउदाहरण:\n>>> parse-date \"16 Aug 1980\"\n16 8 1980",
      "hu": "\"Elemezzen egy dátum karakterláncot a 'NN HHH ÉÉÉÉ' formátumban, és adjon vissza egy listát (nap hónap év).\"\nPélda:\n>>> parse-date \"16 Aug 1980\"\n16 8 1980"
    },
    "docstring_bertscore": {
      "sq": "0.9749199349386298",
      "hy": "0.9394083981564505",
      "bn": "0.9880654921858998",
      "bg": "0.9570225430858623",
      "zh": "0.9767236974288077",
      "fr": "0.9749199349386298",
      "de": "0.9749199349386298",
      "ha": "0.953178250691313",
      "hi": "0.9827729856832251",
      "hu": "0.9388808358644218"
    }
  },
  {
    "task_id": "Common Lisp/4",
    "prompt": {
      "en": "(defun fourth-element (lst)\n;; use car and cdr to return the fourth element in list\n;; Example:\n;; >>> fourth-element '(a b c d e f)\n;; 'd",
      "sq": "(defun fourth-element (lst)\n;; përdor car dhe cdr për të kthyer elementin e katërt në listë\n;; Shembull:\n;; >>> fourth-element '(a b c d e f)\n;; 'd",
      "hy": "(defun fourth-element (lst)\n;; օգտագործեք car և cdr՝ ցուցակի չորրորդ տարրը վերադարձնելու համար\n;; Օրինակ:\n;; >>> fourth-element '(a b c d e f)\n;; 'd",
      "bn": "(defun fourth-element (lst)\n;; car এবং cdr ব্যবহার করে তালিকার চতুর্থ উপাদান ফেরত দিন\n;; উদাহরণ:\n;; >>> fourth-element '(a b c d e f)\n;; 'd",
      "bg": "(defun fourth-element (lst)\n;; използвайте car и cdr, за да върнете четвъртия елемент в списъка\n;; Пример:\n;; >>> fourth-element '(a b c d e f)\n;; 'd",
      "zh": "(defun fourth-element (lst)\n;; 使用 car 和 cdr 返回列表中的第四个元素\n;; 示例:\n;; >>> fourth-element '(a b c d e f)\n;; 'd",
      "fr": "(defun fourth-element (lst)\n;; utiliser car et cdr pour retourner le quatrième élément dans la liste\n;; Exemple:\n;; >>> fourth-element '(a b c d e f)\n;; 'd",
      "de": "(defun fourth-element (lst)\n;; Verwenden Sie car und cdr, um das vierte Element in der Liste zurückzugeben\n;; Beispiel:\n;; >>> fourth-element '(a b c d e f)\n;; 'd",
      "ha": "(defun fourth-element (lst)\n;; yi amfani da car da cdr don dawo da abu na huɗu a cikin jerin\n;; Misali:\n;; >>> fourth-element '(a b c d e f)\n;; 'd",
      "hi": "(defun fourth-element (lst)\n;; car और cdr का उपयोग करके सूची में चौथा तत्व लौटाएं\n;; उदाहरण:\n;; >>> fourth-element '(a b c d e f)\n;; 'd",
      "hu": "(defun fourth-element (lst)\n;; használd a car és cdr függvényeket a negyedik elem visszaadására a listában\n;; Példa:\n;; >>> fourth-element '(a b c d e f)\n;; 'd"
    },
    "prompt_bertscore": {
      "sq": "0.9862629214780082",
      "hy": "0.9813053057977584",
      "bn": "0.9667347741969442",
      "bg": "0.9862629214780082",
      "zh": "0.9845104056261373",
      "fr": "0.9862629214780082",
      "de": "0.9845104056261373",
      "ha": "0.9752027846012236",
      "hi": "0.969204544354732",
      "hu": "0.9628533379211415"
    },
    "canonical_solution": "(car (cdr (cdr (cdr lst)))))",
    "instruction": {
      "en": "Write a Common Lisp function `(defun fourth-element (lst)` to solve the following problem:\nuse car and cdr to return the fourth element in list\nExample:\n>>> fourth-element '(a b c d e f)\n'd",
      "sq": "Shkruani një funksion Common Lisp `(defun fourth-element (lst)` për të zgjidhur problemin e mëposhtëm: përdorni car dhe cdr për të kthyer elementin e katërt në listë Shembull: >>> fourth-element '(a b c d e f) 'd",
      "hy": "Գրեք Common Lisp ֆունկցիա `(defun fourth-element (lst)` հետևյալ խնդիրը լուծելու համար:\nօգտագործեք car և cdr՝ ցուցակի չորրորդ տարրը վերադարձնելու համար\nՕրինակ:\n>>> fourth-element '(a b c d e f)\n'd",
      "bn": "Common Lisp ফাংশন `(defun fourth-element (lst)` লিখুন নিম্নলিখিত সমস্যার সমাধানের জন্য:\ncar এবং cdr ব্যবহার করে তালিকার চতুর্থ উপাদান ফেরত দিন\nউদাহরণ:\n>>> fourth-element '(a b c d e f)\n'd",
      "bg": "Напишете функция на Common Lisp `(defun fourth-element (lst)` за решаване на следния проблем:\nизползвайте car и cdr, за да върнете четвъртия елемент в списъка\nПример:\n>>> fourth-element '(a b c d e f)\n'd",
      "zh": "编写一个 Common Lisp 函数 `(defun fourth-element (lst)` 来解决以下问题：\n使用 car 和 cdr 返回列表中的第四个元素\n示例：\n>>> fourth-element '(a b c d e f)\n'd",
      "fr": "Écrire une fonction Common Lisp `(defun fourth-element (lst)` pour résoudre le problème suivant :  \nutiliser car et cdr pour retourner le quatrième élément dans la liste  \nExemple :  \n>>> fourth-element '(a b c d e f)  \n'd",
      "de": "Schreiben Sie eine Common Lisp-Funktion `(defun fourth-element (lst)` um das folgende Problem zu lösen:  \nVerwenden Sie car und cdr, um das vierte Element in der Liste zurückzugeben  \nBeispiel:  \n>>> fourth-element '(a b c d e f)  \n'd",
      "ha": "Rubuta wani aikin Common Lisp `(defun fourth-element (lst)` don magance matsalar mai zuwa:\nyi amfani da car da cdr don dawo da abu na huɗu a cikin jerin\nMisali:\n>>> fourth-element '(a b c d e f)\n'd",
      "hi": "एक Common Lisp फ़ंक्शन `(defun fourth-element (lst)` लिखें ताकि निम्नलिखित समस्या का समाधान किया जा सके:\nकार और सीडीआर का उपयोग करके सूची में चौथा तत्व लौटाएं\nउदाहरण:\n>>> fourth-element '(a b c d e f)\n'd",
      "hu": "Írj egy Common Lisp függvényt `(defun fourth-element (lst)` a következő probléma megoldására:\nhasználd a car és cdr függvényeket, hogy visszaadja a lista negyedik elemét\nPélda:\n>>> fourth-element '(a b c d e f)\n'd"
    },
    "instruction_bertscore": {
      "sq": "0.9945640823622182",
      "hy": "0.9891549798258762",
      "bn": "0.9518039270849327",
      "bg": "0.9945640823622182",
      "zh": "0.9925193812198451",
      "fr": "0.9945640823622182",
      "de": "0.9925193812198451",
      "ha": "0.9929712653366994",
      "hi": "0.9795315364951168",
      "hu": "0.9729711722702965"
    },
    "level": "easy",
    "test": "(defun check-fourth-element ()\n(assert (equal (fourth-element '(a b c d e f)) 'd))\n(assert (equal (fourth-element '(1 2 3 4 5 6)) 4))\n(assert (equal (fourth-element '(\"one\" \"two\" \"three\" \"four\" \"five\")) \"four\")))\n\n(check-fourth-element)",
    "entry_point": "fourth-element",
    "signature": "(defun fourth-element (lst)",
    "docstring": {
      "en": "use car and cdr to return the fourth element in list\nExample:\n>>> fourth-element '(a b c d e f)\n'd",
      "sq": "përdor car dhe cdr për të kthyer elementin e katërt në listë\nShembull:\n>>> fourth-element '(a b c d e f)\n'd",
      "hy": "օգտագործեք car և cdr՝ ցուցակի չորրորդ տարրը վերադարձնելու համար\nՕրինակ:\n>>> fourth-element '(a b c d e f)\n'd",
      "bn": "car এবং cdr ব্যবহার করে তালিকার চতুর্থ উপাদান ফেরত দিন\nউদাহরণ:\n>>> fourth-element '(a b c d e f)\n'd",
      "bg": "използвайте car и cdr, за да върнете четвъртия елемент в списъка\nПример:\n>>> fourth-element '(a b c d e f)\n'd",
      "zh": "使用 car 和 cdr 返回列表中的第四个元素\n示例:\n>>> fourth-element '(a b c d e f)\n'd",
      "fr": "utiliser car et cdr pour retourner le quatrième élément dans la liste\nExemple:\n>>> fourth-element '(a b c d e f)\n'd",
      "de": "Verwenden Sie car und cdr, um das vierte Element in der Liste zurückzugeben\nBeispiel:\n>>> fourth-element '(a b c d e f)\n'd",
      "ha": "yi amfani da car da cdr don dawo da abu na huɗu a cikin jerin\nMisali:\n>>> fourth-element '(a b c d e f)\n'd'",
      "hi": "सूची में चौथे तत्व को लौटाने के लिए car और cdr का उपयोग करें\nउदाहरण:\n>>> fourth-element '(a b c d e f)\n'd",
      "hu": "használja a car és cdr függvényeket a negyedik elem visszaadásához a listában\nPélda:\n>>> fourth-element '(a b c d e f)\n'd"
    },
    "docstring_bertscore": {
      "sq": "0.9929210118502976",
      "hy": "0.986740428914016",
      "bn": "0.986740428914016",
      "bg": "0.9929210118502976",
      "zh": "0.9919358051603646",
      "fr": "0.9929210118502976",
      "de": "0.9929210118502976",
      "ha": "0.9526753185665328",
      "hi": "0.9919358051603646",
      "hu": "0.9607752668747545"
    }
  },
  {
    "task_id": "Common Lisp/5",
    "prompt": {
      "en": "(defun count-a-in-list (lst)\n;; Calculate the number of times' a 'appears in the list.\n;; Example:\n;; >>> count-a-in-list '(a b c d a e f a)\n;; 3",
      "sq": "(defun count-a-in-list (lst)\n;; Llogarit numrin e herëve që 'a' shfaqet në listë.\n;; Shembull:\n;; >>> count-a-in-list '(a b c d a e f a)\n;; 3",
      "hy": "(defun count-a-in-list (lst)\n;; Հաշվել, թե քանի անգամ է 'a' հայտնվում ցուցակում:\n;; Օրինակ:\n;; >>> count-a-in-list '(a b c d a e f a)\n;; 3",
      "bn": "(defun count-a-in-list (lst)\n;; তালিকায় 'a' কতবার উপস্থিত হয়েছে তা গণনা করুন।\n;; উদাহরণ:\n;; >>> count-a-in-list '(a b c d a e f a)\n;; 3",
      "bg": "(defun count-a-in-list (lst)\n;; Изчислява броя на появите на 'a' в списъка.\n;; Пример:\n;; >>> count-a-in-list '(a b c d a e f a)\n;; 3",
      "zh": "(defun count-a-in-list (lst)\n;; 计算列表中'a'出现的次数。\n;; 例子:\n;; >>> count-a-in-list '(a b c d a e f a)\n;; 3",
      "fr": "(defun count-a-in-list (lst)\n;; Calculer le nombre de fois où 'a' apparaît dans la liste.\n;; Exemple:\n;; >>> count-a-in-list '(a b c d a e f a)\n;; 3",
      "de": "(defun count-a-in-list (lst)\n;; Berechne die Anzahl der Vorkommen von 'a' in der Liste.\n;; Beispiel:\n;; >>> count-a-in-list '(a b c d a e f a)\n;; 3",
      "ha": "(defun count-a-in-list (lst)\n;; Lissafi yawan lokutan da 'a' ya bayyana a cikin jerin.\n;; Misali:\n;; >>> count-a-in-list '(a b c d a e f a)\n;; 3",
      "hi": "(defun count-a-in-list (lst)\n;; सूची में 'a' कितनी बार आता है, इसकी गणना करें।\n;; उदाहरण:\n;; >>> count-a-in-list '(a b c d a e f a)\n;; 3",
      "hu": "(defun count-a-in-list (lst)\n;; Számolja meg, hogy hányszor fordul elő az 'a' a listában.\n;; Példa:\n;; >>> count-a-in-list '(a b c d a e f a)\n;; 3"
    },
    "prompt_bertscore": {
      "sq": "0.9671864596834175",
      "hy": "0.93614351058338",
      "bn": "0.9474996067279067",
      "bg": "0.9537540801659332",
      "zh": "0.9692977020034373",
      "fr": "0.9692977020034373",
      "de": "0.9566389878200839",
      "ha": "0.9586519081014915",
      "hi": "0.9474996067279067",
      "hu": "0.9420493877026903"
    },
    "canonical_solution": "(loop for item in lst\ncounting (eql item 'a)))",
    "instruction": {
      "en": "Write a Common Lisp function `(defun count-a-in-list (lst)` to solve the following problem:\nCalculate the number of times' a 'appears in the list.\nExample:\n>>> count-a-in-list '(a b c d a e f a)\n3",
      "sq": "Shkruani një funksion në Common Lisp `(defun count-a-in-list (lst)` për të zgjidhur problemin e mëposhtëm:  \nLlogaritni sa herë 'a' shfaqet në listë.  \nShembull:  \n>>> count-a-in-list '(a b c d a e f a)  \n3",
      "hy": "Գրեք Common Lisp ֆունկցիա `(defun count-a-in-list (lst)` հետևյալ խնդիրը լուծելու համար: \nՀաշվեք, թե քանի անգամ է 'a' հայտնվում ցուցակում: \nՕրինակ:\n>>> count-a-in-list '(a b c d a e f a)\n3",
      "bn": "একটি Common Lisp ফাংশন `(defun count-a-in-list (lst)` লিখুন নিম্নলিখিত সমস্যার সমাধানের জন্য:\nতালিকায় 'a' কতবার উপস্থিত হয়েছে তা গণনা করুন।\nউদাহরণ:\n>>> count-a-in-list '(a b c d a e f a)\n3",
      "bg": "Напишете функция на Common Lisp `(defun count-a-in-list (lst)` за решаване на следния проблем:\nИзчислете колко пъти 'a' се появява в списъка.\nПример:\n>>> count-a-in-list '(a b c d a e f a)\n3",
      "zh": "编写一个 Common Lisp 函数 `(defun count-a-in-list (lst)` 来解决以下问题：\n计算列表中出现 'a' 的次数。\n示例：\n>>> count-a-in-list '(a b c d a e f a)\n3",
      "fr": "Écrire une fonction Common Lisp `(defun count-a-in-list (lst)` pour résoudre le problème suivant :  \nCalculer le nombre de fois que 'a' apparaît dans la liste.  \nExemple :  \n>>> count-a-in-list '(a b c d a e f a)  \n3",
      "de": "Schreiben Sie eine Common Lisp-Funktion `(defun count-a-in-list (lst)` um das folgende Problem zu lösen:\nBerechnen Sie, wie oft 'a' in der Liste vorkommt.\nBeispiel:\n>>> count-a-in-list '(a b c d a e f a)\n3",
      "ha": "Rubuta aikin Common Lisp `(defun count-a-in-list (lst)` don warware matsalar mai zuwa: \nƘididdige yawan lokutan da 'a' ya bayyana a cikin jerin. \nMisali: \n>>> count-a-in-list '(a b c d a e f a) \n3",
      "hi": "एक Common Lisp फ़ंक्शन `(defun count-a-in-list (lst)` लिखें ताकि निम्नलिखित समस्या का समाधान किया जा सके:\nसूची में 'a' कितनी बार प्रकट होता है, इसकी गणना करें।\nउदाहरण:\n>>> count-a-in-list '(a b c d a e f a)\n3",
      "hu": "Írj egy Common Lisp függvényt `(defun count-a-in-list (lst)` a következő probléma megoldására:  \nSzámítsd ki, hogy az 'a' hányszor fordul elő a listában.  \nPélda:  \n>>> count-a-in-list '(a b c d a e f a)  \n3"
    },
    "instruction_bertscore": {
      "sq": "0.9646799429051383",
      "hy": "0.9568354332669274",
      "bn": "0.9568354332669274",
      "bg": "0.9646799429051383",
      "zh": "0.9652500120987084",
      "fr": "0.9745115508752221",
      "de": "0.9603158348034208",
      "ha": "0.9652500120987084",
      "hi": "0.9568354332669274",
      "hu": "0.966198273537769"
    },
    "level": "easy",
    "test": "(defun check-count-a-in-list ()\n(assert (equal (count-a-in-list '(a b c d a e f a)) 3))\n(assert (equal (count-a-in-list '(1 2 3 4 5)) 0))\n(assert (equal (count-a-in-list '(a a a a)) 4))\n(assert (equal (count-a-in-list '(b c d)) 0)))\n\n(check-count-a-in-list)",
    "entry_point": "count-a-in-list",
    "signature": "(defun count-a-in-list (lst)",
    "docstring": {
      "en": "Calculate the number of times' a 'appears in the list.\nExample:\n>>> count-a-in-list '(a b c d a e f a)\n3",
      "sq": "Llogarit numrin e herëve që 'a' shfaqet në listë.\nShembull:\n>>> count-a-in-list '(a b c d a e f a)\n3",
      "hy": "Հաշվեք, թե քանի անգամ է 'a' հայտնվում ցուցակում:  \nՕրինակ:  \n>>> count-a-in-list '(a b c d a e f a)  \n3",
      "bn": "তালিকায় 'a' কতবার উপস্থিত হয়েছে তা গণনা করুন।\nউদাহরণ:  \n>>> count-a-in-list '(a b c d a e f a)  \n3",
      "bg": "Изчислете колко пъти 'a' се появява в списъка.\nПример:  \n>>> count-a-in-list '(a b c d a e f a)  \n3",
      "zh": "计算列表中'a'出现的次数。\n示例：\n>>> count-a-in-list '(a b c d a e f a)  \n3",
      "fr": "Calculer le nombre de fois où 'a' apparaît dans la liste.\nExemple:\n>>> count-a-in-list '(a b c d a e f a)  \n3",
      "de": "Berechne, wie oft 'a' in der Liste vorkommt.\nBeispiel:\n>>> count-a-in-list '(a b c d a e f a)\n3",
      "ha": "Ƙididdige yawan lokutan da 'a' ya bayyana a cikin jerin.\nMisali:\n>>> count-a-in-list '(a b c d a e f a)\n3",
      "hi": "सूची में 'a' कितनी बार आता है, इसकी गणना करें।\nउदाहरण:\n>>> count-a-in-list '(a b c d a e f a)  \n3",
      "hu": "Számolja ki, hányszor fordul elő az 'a' a listában.\nPélda:\n>>> count-a-in-list '(a b c d a e f a)  \n3"
    },
    "docstring_bertscore": {
      "sq": "0.9596760463461074",
      "hy": "0.9129464615342205",
      "bn": "0.9197620657986707",
      "bg": "0.93954843257508",
      "zh": "0.9359806336709314",
      "fr": "0.9596760463461074",
      "de": "0.9267403483451884",
      "ha": "0.9374385806677275",
      "hi": "0.9197620657986707",
      "hu": "0.9361236475452765"
    }
  },
  {
    "task_id": "Common Lisp/6",
    "prompt": {
      "en": "(defun ordered-union (list1 list2)\n;; Write a version of union that preserves the order of the elements in the original lists:\n;; Example:\n;; >>> ordered-union '(1 2 3) '(4 5 6)\n;; 1 2 3 4 5 6",
      "sq": "(defun ordered-union (list1 list2)\n;; Shkruani një version të union që ruan rendin e elementeve në listat origjinale:\n;; Shembull:\n;; >>> ordered-union '(1 2 3) '(4 5 6)\n;; 1 2 3 4 5 6",
      "hy": "(defun ordered-union (list1 list2)\n;; Գրել միության տարբերակ, որը պահպանում է սկզբնական ցուցակների տարրերի կարգը:\n;; Օրինակ:\n;; >>> ordered-union '(1 2 3) '(4 5 6)\n;; 1 2 3 4 5 6",
      "bn": "(defun ordered-union (list1 list2)\n;; একটি ইউনিয়নের এমন একটি সংস্করণ লিখুন যা মূল তালিকাগুলির উপাদানগুলির ক্রম সংরক্ষণ করে:\n;; উদাহরণ:\n;; >>> ordered-union '(1 2 3) '(4 5 6)\n;; 1 2 3 4 5 6",
      "bg": "(defun ordered-union (list1 list2)\n;; Напишете версия на union, която запазва реда на елементите в оригиналните списъци:\n;; Пример:\n;; >>> ordered-union '(1 2 3) '(4 5 6)\n;; 1 2 3 4 5 6",
      "zh": "(defun ordered-union (list1 list2)\n;; 编写一个版本的union，保留原始列表中元素的顺序：\n;; 例子:\n;; >>> ordered-union '(1 2 3) '(4 5 6)\n;; 1 2 3 4 5 6",
      "fr": "(defun ordered-union (list1 list2)\n;; Écrire une version de union qui préserve l'ordre des éléments dans les listes originales :\n;; Exemple:\n;; >>> ordered-union '(1 2 3) '(4 5 6)\n;; 1 2 3 4 5 6",
      "de": "(defun ordered-union (list1 list2)\n;; Schreiben Sie eine Version von Union, die die Reihenfolge der Elemente in den ursprünglichen Listen beibehält:\n;; Beispiel:\n;; >>> ordered-union '(1 2 3) '(4 5 6)\n;; 1 2 3 4 5 6",
      "ha": "(defun ordered-union (list1 list2)\n;; Rubuta wata sigar union da ke kiyaye tsarin abubuwan da ke cikin jerin asali:\n;; Misali:\n;; >>> ordered-union '(1 2 3) '(4 5 6)\n;; 1 2 3 4 5 6",
      "hi": "(defun ordered-union (list1 list2)\n;; तत्वों के क्रम को मूल सूचियों में संरक्षित करने वाला संघ का एक संस्करण लिखें:\n;; उदाहरण:\n;; >>> ordered-union '(1 2 3) '(4 5 6)\n;; 1 2 3 4 5 6",
      "hu": "(defun ordered-union (list1 list2)\n;; Írj egy olyan unió verziót, amely megőrzi az elemek sorrendjét az eredeti listákban:\n;; Példa:\n;; >>> ordered-union '(1 2 3) '(4 5 6)\n;; 1 2 3 4 5 6"
    },
    "prompt_bertscore": {
      "sq": "0.9952354530501162",
      "hy": "0.9916062773582277",
      "bn": "0.9916062773582277",
      "bg": "0.9952354530501162",
      "zh": "0.9952354530501162",
      "fr": "0.9952354530501162",
      "de": "0.9930527037929238",
      "ha": "0.9952354530501162",
      "hi": "0.9896736037507582",
      "hu": "0.9952354530501162"
    },
    "canonical_solution": "(let ((result nil))\n(loop for item in list1\nunless (member item list2)\ndo (push item result))\n(loop for item in list2\ndo (push item result))\n(nreverse result)))",
    "instruction": {
      "en": "Write a Common Lisp function `(defun ordered-union (list1 list2)` to solve the following problem:\nWrite a version of union that preserves the order of the elements in the original lists:\nExample:\n>>> ordered-union '(1 2 3) '(4 5 6)\n1 2 3 4 5 6",
      "sq": "Shkruani një funksion Common Lisp `(defun ordered-union (list1 list2)` për të zgjidhur problemin e mëposhtëm:\nShkruani një version të union që ruan rendin e elementeve në listat origjinale:\nShembull:\n>>> ordered-union '(1 2 3) '(4 5 6)\n1 2 3 4 5 6",
      "hy": "Գրեք Common Lisp ֆունկցիա `(defun ordered-union (list1 list2)` հետևյալ խնդիրը լուծելու համար:\nԳրեք միության տարբերակ, որը պահպանում է սկզբնական ցուցակների տարրերի կարգը:\nՕրինակ:\n>>> ordered-union '(1 2 3) '(4 5 6)\n1 2 3 4 5 6",
      "bn": "Common Lisp ফাংশন `(defun ordered-union (list1 list2)` লিখুন নিম্নলিখিত সমস্যার সমাধানের জন্য:\nএকটি union এর এমন একটি সংস্করণ লিখুন যা মূল তালিকাগুলির উপাদানগুলির ক্রম সংরক্ষণ করে:\nউদাহরণ:\n>>> ordered-union '(1 2 3) '(4 5 6)\n1 2 3 4 5 6",
      "bg": "Напишете функция на Common Lisp `(defun ordered-union (list1 list2)` за решаване на следния проблем: Напишете версия на union, която запазва реда на елементите в оригиналните списъци: Пример: >>> ordered-union '(1 2 3) '(4 5 6) 1 2 3 4 5 6",
      "zh": "编写一个 Common Lisp 函数 `(defun ordered-union (list1 list2)` 来解决以下问题：\n编写一个保留原始列表中元素顺序的 union 版本：\n示例：\n>>> ordered-union '(1 2 3) '(4 5 6)\n1 2 3 4 5 6",
      "fr": "Écrire une fonction Common Lisp `(defun ordered-union (list1 list2)` pour résoudre le problème suivant :  \nÉcrire une version de union qui préserve l'ordre des éléments dans les listes originales :  \nExemple :  \n>>> ordered-union '(1 2 3) '(4 5 6)  \n1 2 3 4 5 6",
      "de": "Schreiben Sie eine Common Lisp-Funktion `(defun ordered-union (list1 list2)` um das folgende Problem zu lösen:\nSchreiben Sie eine Version von Union, die die Reihenfolge der Elemente in den ursprünglichen Listen beibehält:\nBeispiel:\n>>> ordered-union '(1 2 3) '(4 5 6)\n1 2 3 4 5 6",
      "ha": "Rubuta wani aikin Common Lisp `(defun ordered-union (list1 list2)` don warware matsalar mai zuwa:\nRubuta wani sigar haɗin kai wanda ke kiyaye tsarin abubuwan cikin jerin asali:\nMisali:\n>>> ordered-union '(1 2 3) '(4 5 6)\n1 2 3 4 5 6",
      "hi": "लिखें एक Common Lisp फ़ंक्शन `(defun ordered-union (list1 list2)` निम्नलिखित समस्या को हल करने के लिए:\nएक union का संस्करण लिखें जो मूल सूचियों में तत्वों के क्रम को बनाए रखता है:\nउदाहरण:\n>>> ordered-union '(1 2 3) '(4 5 6)\n1 2 3 4 5 6",
      "hu": "Írj egy Common Lisp függvényt `(defun ordered-union (list1 list2)` a következő probléma megoldására:\nÍrj egy unió verziót, amely megőrzi az elemek sorrendjét az eredeti listákban:\nPélda:\n>>> ordered-union '(1 2 3) '(4 5 6)\n1 2 3 4 5 6"
    },
    "instruction_bertscore": {
      "sq": "0.9958752415074296",
      "hy": "0.9840863297626279",
      "bn": "0.9760775527993012",
      "bg": "0.9913202496095375",
      "zh": "0.9958752415074296",
      "fr": "0.9958752415074296",
      "de": "0.9958752415074296",
      "ha": "0.9958752415074296",
      "hi": "0.9958752415074296",
      "hu": "0.9958752415074296"
    },
    "level": "easy",
    "test": "(defun check-ordered-union ()\n(assert (equal (ordered-union '(1 2 3) '(4 5 6)) '(1 2 3 4 5 6)))\n(assert (equal (ordered-union '(1 2 3) '(3 4 5)) '(1 2 3 4 5)))\n(assert (equal (ordered-union '(a b c) '(b c d)) '(a b c d)))\n(assert (equal (ordered-union '() '(1 2 3)) '(1 2 3)))\n(assert (equal (ordered-union '(1 2 3) '()) '(1 2 3))))\n\n(check-ordered-union)",
    "entry_point": "ordered-union",
    "signature": "(defun ordered-union (list1 list2)",
    "docstring": {
      "en": "Write a version of union that preserves the order of the elements in the original lists:\nExample:\n>>> ordered-union '(1 2 3) '(4 5 6)\n1 2 3 4 5 6",
      "sq": "Shkruani një version të union që ruan rendin e elementeve në listat origjinale:\nShembull:\n>>> ordered-union '(1 2 3) '(4 5 6)\n1 2 3 4 5 6",
      "hy": "Գրեք union-ի մի տարբերակ, որը պահպանում է սկզբնական ցուցակների տարրերի կարգը:\nՕրինակ:\n>>> ordered-union '(1 2 3) '(4 5 6)\n1 2 3 4 5 6",
      "bn": "মূল তালিকার উপাদানগুলোর ক্রম সংরক্ষণ করে এমন একটি union এর সংস্করণ লিখুন:\nউদাহরণ:\n>>> ordered-union '(1 2 3) '(4 5 6)\n1 2 3 4 5 6",
      "bg": "Напишете версия на union, която запазва реда на елементите в оригиналните списъци:\nПример:\n>>> ordered-union '(1 2 3) '(4 5 6)\n1 2 3 4 5 6",
      "zh": "编写一个版本的 union，保留原始列表中元素的顺序：\n示例：\n>>> ordered-union '(1 2 3) '(4 5 6)\n1 2 3 4 5 6",
      "fr": "Écrire une version de union qui préserve l'ordre des éléments dans les listes originales :\nExemple :\n>>> ordered-union '(1 2 3) '(4 5 6)\n1 2 3 4 5 6",
      "de": "Schreiben Sie eine Version von union, die die Reihenfolge der Elemente in den ursprünglichen Listen beibehält:\nBeispiel:\n>>> ordered-union '(1 2 3) '(4 5 6)\n1 2 3 4 5 6",
      "ha": "Rubuta wata sigar haɗin da ke kiyaye tsarin abubuwan da ke cikin jerin asali:\n\nMisali:\n>>> ordered-union '(1 2 3) '(4 5 6)\n1 2 3 4 5 6",
      "hi": "मूल सूचियों में तत्वों के क्रम को बनाए रखने वाला संघ का एक संस्करण लिखें:\nउदाहरण:\n>>> ordered-union '(1 2 3) '(4 5 6)\n1 2 3 4 5 6",
      "hu": "Írj egy olyan unió verziót, amely megőrzi az elemek sorrendjét az eredeti listákban:  \nPélda:  \n>>> ordered-union '(1 2 3) '(4 5 6)  \n1 2 3 4 5 6"
    },
    "docstring_bertscore": {
      "sq": "0.9951204460594969",
      "hy": "0.9839264323058948",
      "bn": "0.9897683504425119",
      "bg": "0.9951204460594969",
      "zh": "0.9951204460594969",
      "fr": "0.9951204460594969",
      "de": "0.9926945732159178",
      "ha": "0.980306592241915",
      "hi": "0.9926945732159178",
      "hu": "0.9772000130825294"
    }
  },
  {
    "task_id": "Common Lisp/7",
    "prompt": {
      "en": "(defun occurrences (lst)\n;; takes a list and returns a list indicating the number of times each (eql) element appears, sorted from most common element to least common\n;; Example:\n;; >>> occurrences '(a b a d a c d c a)\n;; (a . 4) (c . 2) (d . 2) (b . 1)",
      "sq": "(defun occurrences (lst)\n;; merr një listë dhe kthen një listë që tregon numrin e herëve që çdo element (eql) shfaqet, të renditur nga elementi më i zakonshëm te elementi më pak i zakonshëm\n;; Shembull:\n;; >>> occurrences '(a b a d a c d c a)\n;; (a . 4) (c . 2) (d . 2) (b . 1)",
      "hy": "(defun occurrences (lst)\n;; ընդունում է ցուցակ և վերադարձնում ցուցակ, որը ցույց է տալիս, թե քանի անգամ է յուրաքանչյուր (eql) տարր հանդիպում, դասավորված ամենահաճախ հանդիպող տարրից մինչև ամենաքիչ հանդիպողը\n;; Օրինակ:\n;; >>> occurrences '(a b a d a c d c a)\n;; (a . 4) (c . 2) (d . 2) (b . 1)",
      "bn": "(defun occurrences (lst)\n;; একটি তালিকা নেয় এবং একটি তালিকা প্রদান করে যা প্রতিটি (eql) উপাদান কতবার উপস্থিত হয়েছে তা নির্দেশ করে, সবচেয়ে সাধারণ উপাদান থেকে সবচেয়ে কম সাধারণ উপাদান পর্যন্ত সাজানো\n;; উদাহরণ:\n;; >>> occurrences '(a b a d a c d c a)\n;; (a . 4) (c . 2) (d . 2) (b . 1)",
      "bg": "(defun occurrences (lst)\n;; приема списък и връща списък, който показва колко пъти се появява всеки елемент (eql), подреден от най-често срещания елемент до най-рядко срещания\n;; Пример:\n;; >>> occurrences '(a b a d a c d c a)\n;; (a . 4) (c . 2) (d . 2) (b . 1)",
      "zh": "(defun occurrences (lst)\n;; 接受一个列表并返回一个列表，指示每个 (eql) 元素出现的次数，从最常见的元素到最不常见的元素排序\n;; 例子:\n;; >>> occurrences '(a b a d a c d c a)\n;; (a . 4) (c . 2) (d . 2) (b . 1)",
      "fr": "(defun occurrences (lst)\n;; prend une liste et renvoie une liste indiquant le nombre de fois que chaque élément (eql) apparaît, triée de l'élément le plus commun à l'élément le moins commun\n;; Exemple:\n;; >>> occurrences '(a b a d a c d c a)\n;; (a . 4) (c . 2) (d . 2) (b . 1)",
      "de": "(defun occurrences (lst)\n;; nimmt eine Liste und gibt eine Liste zurück, die angibt, wie oft jedes (eql) Element vorkommt, sortiert vom häufigsten zum seltensten Element\n;; Beispiel:\n;; >>> occurrences '(a b a d a c d c a)\n;; (a . 4) (c . 2) (d . 2) (b . 1)",
      "ha": "(defun occurrences (lst)\n;; yana ɗaukar jerin kuma yana dawowa da jerin da ke nuna adadin lokutan da kowane abu (eql) ya bayyana, an jera daga mafi yawan abu zuwa mafi ƙarancin abu\n;; Misali:\n;; >>> occurrences '(a b a d a c d c a)\n;; (a . 4) (c . 2) (d . 2) (b . 1)",
      "hi": "(defun occurrences (lst)\n;; एक सूची लेता है और एक सूची लौटाता है जो यह दर्शाता है कि प्रत्येक (eql) तत्व कितनी बार प्रकट होता है, सबसे सामान्य तत्व से लेकर सबसे कम सामान्य तत्व तक क्रमबद्ध\n;; उदाहरण:\n;; >>> occurrences '(a b a d a c d c a)\n;; (a . 4) (c . 2) (d . 2) (b . 1)",
      "hu": "(defun occurrences (lst)\n;; vesz egy listát, és visszaad egy listát, amely jelzi, hogy az egyes (eql) elemek hányszor fordulnak elő, a leggyakoribb elemtől a legkevésbé gyakoriig rendezve\n;; Példa:\n;; >>> occurrences '(a b a d a c d c a)\n;; (a . 4) (c . 2) (d . 2) (b . 1)"
    },
    "prompt_bertscore": {
      "sq": "0.9741536189285972",
      "hy": "0.9545108619176761",
      "bn": "0.9642928122925013",
      "bg": "0.9650525734999597",
      "zh": "0.953690717074383",
      "fr": "0.9766017383748522",
      "de": "0.9770989102185825",
      "ha": "0.9473373257066011",
      "hi": "0.9807074283508433",
      "hu": "0.9869497853356268"
    },
    "canonical_solution": "(let ((result nil))\n(dolist (obj lst)\n(if (null (assoc obj result))\n(push (cons obj 1) result)\n(incf (cdr (assoc obj result)))\n))\n(sort result #'(lambda (a b) (if (> (cdr a) (cdr b)) t nil)))))",
    "instruction": {
      "en": "Write a Common Lisp function `(defun occurrences (lst)` to solve the following problem:\ntakes a list and returns a list indicating the number of times each (eql) element appears, sorted from most common element to least common\nExample:\n>>> occurrences '(a b a d a c d c a)\n(a . 4) (c . 2) (d . 2) (b . 1)",
      "sq": "Shkruani një funksion Common Lisp `(defun occurrences (lst)` për të zgjidhur problemin e mëposhtëm:  \nmerr një listë dhe kthen një listë që tregon numrin e herëve që çdo element (eql) shfaqet, të renditur nga elementi më i zakonshëm te elementi më pak i zakonshëm  \nShembull:  \n>>> occurrences '(a b a d a c d c a)  \n(a . 4) (c . 2) (d . 2) (b . 1)",
      "hy": "Գրեք Common Lisp ֆունկցիա `(defun occurrences (lst)` հետևյալ խնդիրը լուծելու համար:\nընդունում է ցուցակ և վերադարձնում է ցուցակ, որը ցույց է տալիս, թե քանի անգամ է յուրաքանչյուր (eql) տարր հանդիպում, դասավորված ամենահաճախ հանդիպող տարրից մինչև ամենաքիչ հանդիպող տարրը\nՕրինակ:\n>>> occurrences '(a b a d a c d c a)\n(a . 4) (c . 2) (d . 2) (b . 1)",
      "bn": "একটি Common Lisp ফাংশন `(defun occurrences (lst)` লিখুন নিম্নলিখিত সমস্যার সমাধানের জন্য: একটি তালিকা নেয় এবং একটি তালিকা প্রদান করে যা প্রতিটি (eql) উপাদান কতবার উপস্থিত হয়েছে তা নির্দেশ করে, সবচেয়ে সাধারণ উপাদান থেকে সবচেয়ে কম সাধারণ উপাদান পর্যন্ত সাজানো অবস্থায়\nউদাহরণ:\n>>> occurrences '(a b a d a c d c a)\n(a . 4) (c . 2) (d . 2) (b . 1)",
      "bg": "Напишете функция на Common Lisp `(defun occurrences (lst)` за решаване на следния проблем:  \nвзема списък и връща списък, показващ броя на пъти, в които всеки (eql) елемент се появява, сортиран от най-често срещания елемент до най-рядко срещания  \nПример:  \n>>> occurrences '(a b a d a c d c a)  \n(a . 4) (c . 2) (d . 2) (b . 1)",
      "zh": "编写一个 Common Lisp 函数 `(defun occurrences (lst)` 来解决以下问题：  \n接收一个列表并返回一个列表，指示每个 (eql) 元素出现的次数，从最常见的元素到最不常见的元素排序  \n示例：  \n>>> occurrences '(a b a d a c d c a)  \n(a . 4) (c . 2) (d . 2) (b . 1)",
      "fr": "Écrire une fonction Common Lisp `(defun occurrences (lst)` pour résoudre le problème suivant :  \nprend une liste et renvoie une liste indiquant le nombre de fois que chaque élément (eql) apparaît, triée de l'élément le plus commun à l'élément le moins commun  \nExemple :  \n>>> occurrences '(a b a d a c d c a)  \n(a . 4) (c . 2) (d . 2) (b . 1)",
      "de": "Schreiben Sie eine Common Lisp-Funktion `(defun occurrences (lst)`, um das folgende Problem zu lösen: nimmt eine Liste und gibt eine Liste zurück, die angibt, wie oft jedes (eql) Element vorkommt, sortiert vom häufigsten zum seltensten Element. Beispiel: >>> occurrences '(a b a d a c d c a) (a . 4) (c . 2) (d . 2) (b . 1)",
      "ha": "Rubuta aikin Common Lisp `(defun occurrences (lst)` don warware matsalar mai zuwa:  \nyana ɗaukar jerin kuma yana dawowa da jerin da ke nuna adadin lokutan da kowane abu (eql) ya bayyana, an jera daga mafi yawan abu zuwa mafi ƙarancin abu  \nMisali:  \n>>> occurrences '(a b a d a c d c a)  \n(a . 4) (c . 2) (d . 2) (b . 1)",
      "hi": "एक Common Lisp फ़ंक्शन `(defun occurrences (lst)` लिखें ताकि निम्नलिखित समस्या का समाधान किया जा सके:\nएक सूची लेता है और एक सूची लौटाता है जो दिखाती है कि प्रत्येक (eql) तत्व कितनी बार प्रकट होता है, सबसे सामान्य तत्व से लेकर सबसे कम सामान्य तत्व तक क्रमबद्ध\nउदाहरण:\n>>> occurrences '(a b a d a c d c a)\n(a . 4) (c . 2) (d . 2) (b . 1)",
      "hu": "Írj egy Common Lisp függvényt `(defun occurrences (lst)` a következő probléma megoldására:\nvesz egy listát, és visszaad egy listát, amely jelzi, hogy az egyes (eql) elemek hányszor fordulnak elő, a leggyakoribb elemtől a legkevésbé gyakoriig rendezve\nPélda:\n>>> occurrences '(a b a d a c d c a)\n(a . 4) (c . 2) (d . 2) (b . 1)"
    },
    "instruction_bertscore": {
      "sq": "0.9791579127483903",
      "hy": "0.9574402627771786",
      "bn": "0.9775581436595352",
      "bg": "0.9775063011300851",
      "zh": "0.9575091875193977",
      "fr": "0.9816626418532401",
      "de": "0.9684982147197719",
      "ha": "0.9398267137389099",
      "hi": "0.9742072491314767",
      "hu": "0.9736846525989739"
    },
    "level": "easy",
    "test": "(defun check-occurrences ()\n;; Test 'occurrences' function.\n(assert (equal (occurrences '(a b a d a c d c a)) '((a . 4) (c . 2) (d . 2) (b . 1))))\n(assert (equal (occurrences '(1 2 2 3 3 3)) '((3 . 3) (2 . 2) (1 . 1))))\n(assert (equal (occurrences '(a b a)) '((a . 2) (b . 1)))))\n\n(check-occurrences)",
    "entry_point": "occurrences",
    "signature": "(defun occurrences (lst)",
    "docstring": {
      "en": "takes a list and returns a list indicating the number of times each (eql) element appears, sorted from most common element to least common\nExample:\n>>> occurrences '(a b a d a c d c a)\n(a . 4) (c . 2) (d . 2) (b . 1)",
      "sq": "merr një listë dhe kthen një listë që tregon numrin e herëve që çdo element (eql) shfaqet, të renditur nga elementi më i zakonshëm tek ai më pak i zakonshëm\nShembull:\n>>> occurrences '(a b a d a c d c a)\n(a . 4) (c . 2) (d . 2) (b . 1)",
      "hy": "վերցնում է ցուցակ և վերադարձնում ցուցակ, որը ցույց է տալիս, թե քանի անգամ է յուրաքանչյուր (eql) տարրը հանդիպում, դասավորված ամենահաճախ հանդիպող տարրից մինչև ամենաքիչ հանդիպողը\nՕրինակ:\n>>> occurrences '(a b a d a c d c a)\n(a . 4) (c . 2) (d . 2) (b . 1)",
      "bn": "একটি তালিকা নেয় এবং প্রতিটি (eql) উপাদান কতবার প্রদর্শিত হয় তা নির্দেশ করে একটি তালিকা ফেরত দেয়, সবচেয়ে সাধারণ উপাদান থেকে সবচেয়ে কম সাধারণ উপাদান পর্যন্ত সাজানো\nউদাহরণ:  \n\n>>> occurrences '(a b a d a c d c a)  \n(a . 4) (c . 2) (d . 2) (b . 1)",
      "bg": "взема списък и връща списък, показващ броя пъти, когато всеки (eql) елемент се появява, сортиран от най-често срещания елемент към най-рядко срещания\nПример:\n>>> occurrences '(a b a d a c d c a)\n(a . 4) (c . 2) (d . 2) (b . 1)",
      "zh": "接收一个列表并返回一个列表，指示每个（eql）元素出现的次数，从最常见的元素到最不常见的元素排序\n示例:\n>>> occurrences '(a b a d a c d c a)  \n(a . 4) (c . 2) (d . 2) (b . 1)",
      "fr": "prend une liste et renvoie une liste indiquant le nombre de fois que chaque élément (eql) apparaît, triée de l'élément le plus commun à l'élément le moins commun\nExemple :\n>>> occurrences '(a b a d a c d c a)\n(a . 4) (c . 2) (d . 2) (b . 1)",
      "de": "nimmt eine Liste und gibt eine Liste zurück, die angibt, wie oft jedes (eql) Element vorkommt, sortiert vom häufigsten zum seltensten Element\nBeispiel:\n>>> occurrences '(a b a d a c d c a)\n(a . 4) (c . 2) (d . 2) (b . 1)",
      "ha": "yana ɗaukar jerin kuma yana dawowa da jeri wanda ke nuna adadin lokutan da kowane (eql) abu ya bayyana, an jera daga abu mafi yawan zuwa wanda yafi ƙaranci\nMisali:\n>>> occurrences '(a b a d a c d c a)\n(a . 4) (c . 2) (d . 2) (b . 1)",
      "hi": "एक सूची लेता है और एक सूची लौटाता है जो यह दर्शाता है कि प्रत्येक (eql) तत्व कितनी बार प्रकट होता है, सबसे सामान्य तत्व से लेकर सबसे कम सामान्य तत्व तक क्रमबद्ध\n\nउदाहरण:\n>>> occurrences '(a b a d a c d c a)\n(a . 4) (c . 2) (d . 2) (b . 1)",
      "hu": "vesz egy listát, és visszaad egy listát, amely jelzi, hogy az egyes (eql) elemek hányszor fordulnak elő, a leggyakoribb elemtől a legkevésbé gyakoriig rendezve\nPélda:\n>>> occurrences '(a b a d a c d c a)\n(a . 4) (c . 2) (d . 2) (b . 1)"
    },
    "docstring_bertscore": {
      "sq": "0.97396988582614",
      "hy": "0.9524566265170133",
      "bn": "0.9120965221337723",
      "bg": "0.979776845015695",
      "zh": "1",
      "fr": "0.9770029717445428",
      "de": "0.9738948035421088",
      "ha": "0.9644125864122652",
      "hi": "0.9817595734791852",
      "hu": "0.9862941064478307"
    }
  },
  {
    "task_id": "Common Lisp/8",
    "prompt": {
      "en": "(defun list-to-dots (lst)\n;; takes a list and prints it in dot natation\n;; Example:\n;; >>> list-to-dots '(a b c)\n;; (a . (b . (c . nil)))",
      "sq": "(defun list-to-dots (lst)\n;; merr një listë dhe e shtyp atë në notacion me pika\n;; Shembull:\n;; >>> list-to-dots '(a b c)\n;; (a . (b . (c . nil)))",
      "hy": "(defun list-to-dots (lst)\n;; վերցնում է ցուցակ և տպում այն կետային նշումով\n;; Օրինակ:\n;; >>> list-to-dots '(a b c)\n;; (a . (b . (c . nil)))",
      "bn": "(defun list-to-dots (lst)\n;; একটি তালিকা নেয় এবং এটি ডট নোটেশনে প্রিন্ট করে\n;; উদাহরণ:\n;; >>> list-to-dots '(a b c)\n;; (a . (b . (c . nil)))",
      "bg": "(defun list-to-dots (lst)\n;; приема списък и го отпечатва в точкова нотация\n;; Пример:\n;; >>> list-to-dots '(a b c)\n;; (a . (b . (c . nil)))",
      "zh": "(defun list-to-dots (lst)\n;; 接受一个列表并以点表示法打印\n;; 例子:\n;; >>> list-to-dots '(a b c)\n;; (a . (b . (c . nil)))",
      "fr": "(defun list-to-dots (lst)\n;; prend une liste et l'imprime en notation pointée\n;; Exemple:\n;; >>> list-to-dots '(a b c)\n;; (a . (b . (c . nil)))",
      "de": "(defun list-to-dots (lst)\n;; nimmt eine Liste und gibt sie in Punktnotation aus\n;; Beispiel:\n;; >>> list-to-dots '(a b c)\n;; (a . (b . (c . nil)))",
      "ha": "(defun list-to-dots (lst)\n;; yana ɗaukar jeri kuma yana buga shi a cikin tsarin dige-dige\n;; Misali:\n;; >>> list-to-dots '(a b c)\n;; (a . (b . (c . nil)))",
      "hi": "(defun list-to-dots (lst)\n;; एक सूची लेता है और इसे डॉट नोटेशन में प्रिंट करता है\n;; उदाहरण:\n;; >>> list-to-dots '(a b c)\n;; (a . (b . (c . nil)))",
      "hu": "(defun list-to-dots (lst)\n;; egy listát vesz át és pont jelöléssel írja ki\n;; Példa:\n;; >>> list-to-dots '(a b c)\n;; (a . (b . (c . nil)))"
    },
    "prompt_bertscore": {
      "sq": "0.9730200353440311",
      "hy": "0.9730200353440311",
      "bn": "0.9756920112297125",
      "bg": "0.9656689235723109",
      "zh": "0.9652964916078706",
      "fr": "0.9730200353440311",
      "de": "0.9694297912068255",
      "ha": "0.9626014745979892",
      "hi": "0.9756920112297125",
      "hu": "0.9785060078378337"
    },
    "canonical_solution": "(if (null lst)\n'nil\n(cons (car lst) (list-to-dots (cdr lst)))))",
    "instruction": {
      "en": "Write a Common Lisp function `(defun list-to-dots (lst)` to solve the following problem:\ntakes a list and prints it in dot natation\nExample:\n>>> list-to-dots '(a b c)\n(a . (b . (c . nil)))",
      "sq": "Shkruani një funksion Common Lisp `(defun list-to-dots (lst)` për të zgjidhur problemin e mëposhtëm: \nmerr një listë dhe e printon atë në notacion pikash\nShembull:\n>>> list-to-dots '(a b c)\n(a . (b . (c . nil)))",
      "hy": "Գրեք Common Lisp ֆունկցիա `(defun list-to-dots (lst)` հետևյալ խնդիրը լուծելու համար:\nընդունում է ցուցակ և տպում է այն կետային նշումով\nՕրինակ:\n>>> list-to-dots '(a b c)\n(a . (b . (c . nil)))",
      "bn": "একটি Common Lisp ফাংশন `(defun list-to-dots (lst)` লিখুন নিম্নলিখিত সমস্যার সমাধানের জন্য:\nএকটি তালিকা নেয় এবং এটি ডট নোটেশনে প্রিন্ট করে\nউদাহরণ:\n>>> list-to-dots '(a b c)\n(a . (b . (c . nil)))",
      "bg": "Напишете функция на Common Lisp `(defun list-to-dots (lst)` за решаване на следния проблем:\nвзема списък и го отпечатва в точкова нотация\nПример:\n>>> list-to-dots '(a b c)\n(a . (b . (c . nil)))",
      "zh": "编写一个 Common Lisp 函数 `(defun list-to-dots (lst)` 来解决以下问题：  \n接收一个列表并以点表示法打印  \n示例:  \n>>> list-to-dots '(a b c)  \n(a . (b . (c . nil)))",
      "fr": "Écrire une fonction Common Lisp `(defun list-to-dots (lst)` pour résoudre le problème suivant :\nprend une liste et l'imprime en notation pointée\nExemple :\n>>> list-to-dots '(a b c)\n(a . (b . (c . nil)))",
      "de": "Schreiben Sie eine Common Lisp-Funktion `(defun list-to-dots (lst)`, um das folgende Problem zu lösen:\nnimmt eine Liste und gibt sie in Punktnotation aus\nBeispiel:\n>>> list-to-dots '(a b c)\n(a . (b . (c . nil)))",
      "ha": "Rubuta aikin Common Lisp `(defun list-to-dots (lst)` don warware matsalar mai zuwa:  \nyana karɓar jeri kuma yana bugawa a cikin tsarin dige-dige  \nMisali:  \n>>> list-to-dots '(a b c)  \n(a . (b . (c . nil)))",
      "hi": "Common Lisp फ़ंक्शन `(defun list-to-dots (lst)` लिखें ताकि निम्नलिखित समस्या का समाधान किया जा सके:\nएक सूची लेता है और इसे डॉट नोटेशन में प्रिंट करता है\nउदाहरण:\n>>> list-to-dots '(a b c)\n(a . (b . (c . nil)))",
      "hu": "Írj egy Common Lisp függvényt `(defun list-to-dots (lst)` a következő probléma megoldására:\nvesz egy listát és pontozott jelöléssel nyomtatja ki\nPélda:\n>>> list-to-dots '(a b c)\n(a . (b . (c . nil)))"
    },
    "instruction_bertscore": {
      "sq": "0.9756290453989244",
      "hy": "0.9686213655560135",
      "bn": "0.9790393304109124",
      "bg": "0.9810206684617354",
      "zh": "0.9659205882650822",
      "fr": "0.9756290453989244",
      "de": "0.8445699391667707",
      "ha": "0.9582971542409632",
      "hi": "0.9603678759632519",
      "hu": "0.9756290453989244"
    },
    "level": "easy",
    "test": "(defun check-list-to-dots ()\n;; Test 'list-to-dots' function.\n(assert (equal (list-to-dots '(a b c)) '(a . (b . (c . nil)))))\n(assert (equal (list-to-dots '(1 2 3)) '(1 . (2 . (3 . nil)))))\n(assert (equal (list-to-dots '(x y)) '(x . (y . nil))))\n(assert (equal (list-to-dots '()) 'nil)))\n\n(check-list-to-dots)",
    "entry_point": "list-to-dots",
    "signature": "(defun list-to-dots (lst)",
    "docstring": {
      "en": "takes a list and prints it in dot natation\nExample:\n>>> list-to-dots '(a b c)\n(a . (b . (c . nil)))",
      "sq": "merr një listë dhe e printon atë në notacion me pika\nShembull:\n>>> list-to-dots '(a b c)\n(a . (b . (c . nil)))",
      "hy": "վերցնում է ցուցակ և տպում այն կետային նշումով\nՕրինակ:\n>>> list-to-dots '(a b c)\n(a . (b . (c . nil)))",
      "bn": "একটি তালিকা নেয় এবং এটি ডট নোটেশনে প্রিন্ট করে\nউদাহরণ:\n>>> list-to-dots '(a b c)\n(a . (b . (c . nil)))",
      "bg": "взема списък и го отпечатва в точкова нотация\nПример:\n>>> list-to-dots '(a b c)\n(a . (b . (c . nil)))",
      "zh": "将列表转换为点表示法并打印\n示例:\n>>> list-to-dots '(a b c)\n(a . (b . (c . nil)))",
      "fr": "prend une liste et l'imprime en notation par points\nExemple :\n>>> list-to-dots '(a b c)\n(a . (b . (c . nil)))",
      "de": "nimmt eine Liste und gibt sie in Punktnotation aus\nBeispiel:\n>>> list-to-dots '(a b c)\n(a . (b . (c . nil)))",
      "ha": "yana ɗaukar jeri kuma yana buga shi a cikin tsarin dige-dige\nMisali:\n>>> list-to-dots '(a b c)\n(a . (b . (c . nil)))",
      "hi": "एक सूची लेता है और इसे डॉट नोटेशन में प्रिंट करता है\nउदाहरण:  \n>>> list-to-dots '(a b c)  \n(a . (b . (c . nil)))",
      "hu": "vesz egy listát, és pontozott jelöléssel nyomtatja ki\nPélda:\n>>> list-to-dots '(a b c)\n(a . (b . (c . nil)))"
    },
    "docstring_bertscore": {
      "sq": "0.9561745899892243",
      "hy": "0.9669024182385376",
      "bn": "0.9710319438602529",
      "bg": "0.9624105908018147",
      "zh": "0.9191155239084021",
      "fr": "0.9624105908018147",
      "de": "0.9570857075470314",
      "ha": "0.9710319438602529",
      "hi": "0.9710319438602529",
      "hu": "0.9624105908018147"
    }
  },
  {
    "task_id": "Common Lisp/9",
    "prompt": {
      "en": "(defun contains-nil? (lst)\n;; Check if the list contains nil elements\n;; Example:\n;; >>> contains-nil? '(1 2 3 nil 4 5)\n;; t",
      "sq": "(defun contains-nil? (lst)\n;; Kontrollo nëse lista përmban elemente nil\n;; Shembull:\n;; >>> contains-nil? '(1 2 3 nil 4 5)\n;; t",
      "hy": "(defun contains-nil? (lst)\n;; Ստուգել, արդյոք ցուցակը պարունակում է nil տարրեր\n;; Օրինակ:\n;; >>> contains-nil? '(1 2 3 nil 4 5)\n;; t",
      "bn": "(defun contains-nil? (lst)\n;; তালিকায় nil উপাদান আছে কিনা তা পরীক্ষা করুন\n;; উদাহরণ:\n;; >>> contains-nil? '(1 2 3 nil 4 5)\n;; t",
      "bg": "(defun contains-nil? (lst)\n;; Проверка дали списъкът съдържа nil елементи\n;; Пример:\n;; >>> contains-nil? '(1 2 3 nil 4 5)\n;; t",
      "zh": "(defun contains-nil? (lst)\n;; 检查列表中是否包含 nil 元素\n;; 示例:\n;; >>> contains-nil? '(1 2 3 nil 4 5)\n;; t",
      "fr": "(defun contains-nil? (lst)\n;; Vérifie si la liste contient des éléments nil\n;; Exemple:\n;; >>> contains-nil? '(1 2 3 nil 4 5)\n;; t",
      "de": "(defun contains-nil? (lst)\n;; Überprüfen, ob die Liste nil-Elemente enthält\n;; Beispiel:\n;; >>> contains-nil? '(1 2 3 nil 4 5)\n;; t",
      "ha": "(defun contains-nil? (lst)\n;; Duba idan jerin yana dauke da abubuwan nil\n;; Misali:\n;; >>> contains-nil? '(1 2 3 nil 4 5)\n;; t",
      "hi": "(defun contains-nil? (lst)\n;; जाँचें कि सूची में nil तत्व शामिल हैं\n;; उदाहरण:\n;; >>> contains-nil? '(1 2 3 nil 4 5)\n;; t",
      "hu": "(defun contains-nil? (lst)\n;; Ellenőrzi, hogy a lista tartalmaz-e nil elemeket\n;; Példa:\n;; >>> contains-nil? '(1 2 3 nil 4 5)\n;; t"
    },
    "prompt_bertscore": {
      "sq": "1",
      "hy": "1",
      "bn": "0.9894795418684872",
      "bg": "1",
      "zh": "0.9894795418684872",
      "fr": "0.9950765487452883",
      "de": "1",
      "ha": "1",
      "hi": "1",
      "hu": "0.9950765487452883"
    },
    "canonical_solution": "(loop for item in lst\nthereis (null item)))",
    "instruction": {
      "en": "Write a Common Lisp function `(defun contains-nil? (lst)` to solve the following problem:\nCheck if the list contains nil elements\nExample:\n>>> contains-nil? '(1 2 3 nil 4 5)\nt",
      "sq": "Shkruani një funksion në Common Lisp `(defun contains-nil? (lst)` për të zgjidhur problemin e mëposhtëm:  \nKontrolloni nëse lista përmban elemente nil  \nShembull:  \n>>> contains-nil? '(1 2 3 nil 4 5)  \nt",
      "hy": "Գրեք Common Lisp ֆունկցիա `(defun contains-nil? (lst)` հետևյալ խնդիրը լուծելու համար:\nՍտուգեք, արդյոք ցուցակը պարունակում է nil տարրեր\nՕրինակ:\n>>> contains-nil? '(1 2 3 nil 4 5)\nt",
      "bn": "একটি Common Lisp ফাংশন `(defun contains-nil? (lst)` লিখুন নিম্নলিখিত সমস্যার সমাধানের জন্য:\nপরীক্ষা করুন যে তালিকায় nil উপাদান রয়েছে কিনা\nউদাহরণ:\n>>> contains-nil? '(1 2 3 nil 4 5)\nt",
      "bg": "Напишете функция на Common Lisp `(defun contains-nil? (lst)` за решаване на следния проблем:  \nПроверете дали списъкът съдържа nil елементи  \nПример:  \n>>> contains-nil? '(1 2 3 nil 4 5)  \nt",
      "zh": "编写一个 Common Lisp 函数 `(defun contains-nil? (lst)` 来解决以下问题：\n检查列表是否包含 nil 元素\n示例：\n>>> contains-nil? '(1 2 3 nil 4 5)\nt",
      "fr": "Écrire une fonction Common Lisp `(defun contains-nil? (lst)` pour résoudre le problème suivant :  \nVérifier si la liste contient des éléments nil  \nExemple :  \n>>> contains-nil? '(1 2 3 nil 4 5)  \nt",
      "de": "Schreiben Sie eine Common Lisp-Funktion `(defun contains-nil? (lst)`, um das folgende Problem zu lösen:  \nÜberprüfen Sie, ob die Liste nil-Elemente enthält  \nBeispiel:  \n>>> contains-nil? '(1 2 3 nil 4 5)  \nt",
      "ha": "Rubuta aikin Common Lisp `(defun contains-nil? (lst)` don warware matsalar mai zuwa:  \nDuba idan jerin yana dauke da abubuwan nil  \nMisali:  \n>>> contains-nil? '(1 2 3 nil 4 5)  \nt",
      "hi": "एक Common Lisp फ़ंक्शन `(defun contains-nil? (lst)` लिखें ताकि निम्नलिखित समस्या का समाधान किया जा सके:\nजांचें कि सूची में nil तत्व हैं या नहीं\nउदाहरण:\n>>> contains-nil? '(1 2 3 nil 4 5)\nt",
      "hu": "Írj egy Common Lisp függvényt `(defun contains-nil? (lst)` a következő probléma megoldására:\nEllenőrizd, hogy a lista tartalmaz-e nil elemeket\nPélda:\n>>> contains-nil? '(1 2 3 nil 4 5)\nt"
    },
    "instruction_bertscore": {
      "sq": "0.9919161407526421",
      "hy": "0.9999996027392379",
      "bn": "0.9918778050891024",
      "bg": "0.9919161407526421",
      "zh": "0.9918778050891024",
      "fr": "0.9999996027392379",
      "de": "0.996207748765282",
      "ha": "0.9816630391140022",
      "hi": "0.9854254957915651",
      "hu": "0.9999996027392379"
    },
    "level": "easy",
    "test": "(defun check-contains-nil? ()\n(assert (equal (contains-nil? '(1 2 3 nil 4 5)) t))\n(assert (equal (contains-nil? '(1 2 3 4 5)) nil))\n(assert (equal (contains-nil? '(nil 1 2 3)) t))\n(assert (equal (contains-nil? '()) nil))\n(assert (equal (contains-nil? '(nil)) t)))\n\n(check-contains-nil?)",
    "entry_point": "contains-nil?",
    "signature": "(defun contains-nil? (lst)",
    "docstring": {
      "en": "Check if the list contains nil elements\nExample:\n>>> contains-nil? '(1 2 3 nil 4 5)\nt",
      "sq": "Kontrolloni nëse lista përmban elemente nil\nShembull:\n>>> contains-nil? '(1 2 3 nil 4 5)  \nt",
      "hy": "Ստուգել, արդյոք ցուցակը պարունակում է nil տարրեր\nՕրինակ:\n>>> contains-nil? '(1 2 3 nil 4 5)  \nt",
      "bn": "তালিকায় nil উপাদান রয়েছে কিনা তা পরীক্ষা করুন\nউদাহরণ:\n>>> contains-nil? '(1 2 3 nil 4 5)\nt",
      "bg": "Проверете дали списъкът съдържа nil елементи\nПример:\n>>> contains-nil? '(1 2 3 nil 4 5)  \nt",
      "zh": "检查列表是否包含 nil 元素\n示例：\n>>> contains-nil? '(1 2 3 nil 4 5)  \nt",
      "fr": "Vérifiez si la liste contient des éléments nil\nExemple:\n>>> contains-nil? '(1 2 3 nil 4 5)  \nt",
      "de": "Überprüfen Sie, ob die Liste nil-Elemente enthält\nBeispiel:\n>>> contains-nil? '(1 2 3 nil 4 5)  \nt",
      "ha": "Duba idan jerin yana dauke da abubuwan nil\nMisali:\n>>> contains-nil? '(1 2 3 nil 4 5)  \nt",
      "hi": "सूची में nil तत्व हैं या नहीं, यह जाँचें\nउदाहरण:\n>>> contains-nil? '(1 2 3 nil 4 5)  \nt",
      "hu": "Ellenőrizze, hogy a lista tartalmaz-e nil elemeket\nPélda:\n>>> contains-nil? '(1 2 3 nil 4 5)  \nt"
    },
    "docstring_bertscore": {
      "sq": "1",
      "hy": "1",
      "bn": "0.9842603299764144",
      "bg": "1",
      "zh": "0.9842603299764144",
      "fr": "1",
      "de": "1",
      "ha": "0.975302099791741",
      "hi": "0.958552592910974",
      "hu": "1"
    }
  },
  {
    "task_id": "Common Lisp/10",
    "prompt": {
      "en": "(defun index-of-element (element lst)\n;; Returns the index of the element in the list, or nil if the element is not in the list.\n;; Example:\n;; >>> index-of-element 'a '(a b c d e)\n;; 0",
      "sq": "(defun index-of-element (element lst)\n;; Kthen indeksin e elementit në listë, ose nil nëse elementi nuk është në listë.\n;; Shembull:\n;; >>> index-of-element 'a '(a b c d e)\n;; 0",
      "hy": "(defun index-of-element (element lst)\n;; Վերադարձնում է տարրի ինդեքսը ցուցակում, կամ nil, եթե տարրը ցուցակում չկա։\n;; Օրինակ:\n;; >>> index-of-element 'a '(a b c d e)\n;; 0",
      "bn": "(defun index-of-element (element lst)\n;; তালিকায় উপাদানের সূচক প্রদান করে, অথবা তালিকায় উপাদান না থাকলে nil প্রদান করে।\n;; উদাহরণ:\n;; >>> index-of-element 'a '(a b c d e)\n;; 0",
      "bg": "(defun index-of-element (element lst)\n;; Връща индекса на елемента в списъка или nil, ако елементът не е в списъка.\n;; Пример:\n;; >>> index-of-element 'a '(a b c d e)\n;; 0",
      "zh": "(defun index-of-element (element lst)\n;; 返回列表中元素的索引，如果元素不在列表中则返回nil。\n;; 示例:\n;; >>> index-of-element 'a '(a b c d e)\n;; 0",
      "fr": "(defun index-of-element (element lst)\n;; Renvoie l'indice de l'élément dans la liste, ou nil si l'élément n'est pas dans la liste.\n;; Exemple:\n;; >>> index-of-element 'a '(a b c d e)\n;; 0",
      "de": "(defun index-of-element (element lst)\n;; Gibt den Index des Elements in der Liste zurück oder nil, wenn das Element nicht in der Liste ist.\n;; Beispiel:\n;; >>> index-of-element 'a '(a b c d e)\n;; 0",
      "ha": "(defun index-of-element (element lst)\n;; Yana dawo da lambar inda aka samu abin a cikin jerin, ko kuma nil idan ba a sami abin a cikin jerin ba.\n;; Misali:\n;; >>> index-of-element 'a '(a b c d e)\n;; 0",
      "hi": "(defun index-of-element (element lst)\n;; सूची में तत्व का सूचकांक लौटाता है, या यदि तत्व सूची में नहीं है तो nil लौटाता है।\n;; उदाहरण:\n;; >>> index-of-element 'a '(a b c d e)\n;; 0",
      "hu": "(defun index-of-element (element lst)\n;; Visszaadja az elem indexét a listában, vagy nil-t, ha az elem nincs a listában.\n;; Példa:\n;; >>> index-of-element 'a '(a b c d e)\n;; 0"
    },
    "prompt_bertscore": {
      "sq": "1",
      "hy": "1",
      "bn": "0.980272030555615",
      "bg": "0.9875919573575126",
      "zh": "1",
      "fr": "1",
      "de": "0.9875919573575126",
      "ha": "0.9643780247259652",
      "hi": "0.9921104012652943",
      "hu": "1"
    },
    "canonical_solution": "(loop for item in lst\nfor index from 0\nwhen (eql item element)\ndo (return index)))",
    "instruction": {
      "en": "Write a Common Lisp function `(defun index-of-element (element lst)` to solve the following problem:\nReturns the index of the element in the list, or nil if the element is not in the list.\nExample:\n>>> index-of-element 'a '(a b c d e)\n0",
      "sq": "Shkruani një funksion Common Lisp `(defun index-of-element (element lst)` për të zgjidhur problemin e mëposhtëm:  \nKthen indeksin e elementit në listë, ose nil nëse elementi nuk është në listë.  \nShembull:  \n>>> index-of-element 'a '(a b c d e)  \n0",
      "hy": "Գրեք Common Lisp ֆունկցիա `(defun index-of-element (element lst)` հետևյալ խնդիրը լուծելու համար:\nՎերադարձնում է տարրի ինդեքսը ցուցակում, կամ nil, եթե տարրը ցուցակում չէ:\nՕրինակ:\n>>> index-of-element 'a '(a b c d e)\n0",
      "bn": "লিখুন একটি Common Lisp ফাংশন `(defun index-of-element (element lst)` নিম্নলিখিত সমস্যার সমাধানের জন্য:\nতালিকায় উপাদানের সূচক ফেরত দেয়, অথবা যদি উপাদানটি তালিকায় না থাকে তবে nil ফেরত দেয়।\nউদাহরণ:\n>>> index-of-element 'a '(a b c d e)\n0",
      "bg": "Напишете функция на Common Lisp `(defun index-of-element (element lst)` за решаване на следния проблем:\nВръща индекса на елемента в списъка или nil, ако елементът не е в списъка.\nПример:\n>>> index-of-element 'a '(a b c d e)\n0",
      "zh": "编写一个 Common Lisp 函数 `(defun index-of-element (element lst)` 来解决以下问题：\n返回列表中元素的索引，如果元素不在列表中则返回 nil。\n示例：\n>>> index-of-element 'a '(a b c d e)\n0",
      "fr": "Écrire une fonction Common Lisp `(defun index-of-element (element lst)` pour résoudre le problème suivant :  \nRenvoie l'index de l'élément dans la liste, ou nil si l'élément n'est pas dans la liste.  \nExemple :  \n>>> index-of-element 'a '(a b c d e)  \n0",
      "de": "Schreiben Sie eine Common Lisp-Funktion `(defun index-of-element (element lst)` um das folgende Problem zu lösen:\nGibt den Index des Elements in der Liste zurück oder nil, wenn das Element nicht in der Liste ist.\nBeispiel:\n>>> index-of-element 'a '(a b c d e)\n0",
      "ha": "Rubuta wani aikin Common Lisp `(defun index-of-element (element lst)` don warware matsalar mai zuwa:\nDawo da ma'aunin abin a cikin jerin, ko kuma nil idan abin ba ya cikin jerin.\nMisali:\n>>> index-of-element 'a '(a b c d e)\n0",
      "hi": "लिखें एक Common Lisp फ़ंक्शन `(defun index-of-element (element lst)` निम्नलिखित समस्या को हल करने के लिए:\nसूची में तत्व का सूचकांक लौटाता है, या nil अगर तत्व सूची में नहीं है।\nउदाहरण:\n>>> index-of-element 'a '(a b c d e)\n0",
      "hu": "Írj egy Common Lisp függvényt `(defun index-of-element (element lst)` a következő probléma megoldására:\nVisszaadja az elem indexét a listában, vagy nil-t, ha az elem nincs a listában.\nPélda:\n>>> index-of-element 'a '(a b c d e)\n0"
    },
    "instruction_bertscore": {
      "sq": "0.999999801369619",
      "hy": "0.999999801369619",
      "bn": "0.9906427213798275",
      "bg": "0.9915582088060173",
      "zh": "0.9889233768015895",
      "fr": "0.9972648596531496",
      "de": "0.9929208132199165",
      "ha": "0.9972648596531496",
      "hi": "0.999999801369619",
      "hu": "0.999999801369619"
    },
    "level": "easy",
    "test": "(defun check-index-of-element ()\n;; Test 'index-of-element' function.\n(assert (equal (index-of-element 'a '(a b c d e)) 0))\n(assert (equal (index-of-element 'c '(a b c d e)) 2))\n(assert (equal (index-of-element 'e '(a b c d e)) 4))\n(assert (equal (index-of-element 'f '(a b c d e)) nil))\n(assert (equal (index-of-element 3 '(1 2 3 4 5)) 2)))\n\n(check-index-of-element)",
    "entry_point": "index-of-element",
    "signature": "(defun index-of-element (element lst)",
    "docstring": {
      "en": "Returns the index of the element in the list, or nil if the element is not in the list.\nExample:\n>>> index-of-element 'a '(a b c d e)\n0",
      "sq": "Kthen indeksin e elementit në listë, ose nil nëse elementi nuk është në listë.\nShembull:\n>>> index-of-element 'a '(a b c d e)\n0",
      "hy": "Վերադարձնում է տարրի ինդեքսը ցանկում, կամ nil, եթե տարրը ցանկում չէ:\nՕրինակ:\n>>> index-of-element 'a '(a b c d e)\n0",
      "bn": "তালিকায় উপাদানের সূচক প্রদান করে, অথবা তালিকায় উপাদান না থাকলে nil প্রদান করে।\nউদাহরণ:\n>>> index-of-element 'a '(a b c d e)\n0",
      "bg": "Връща индекса на елемента в списъка или nil, ако елементът не е в списъка.\nПример:\n>>> index-of-element 'a '(a b c d e)\n0",
      "zh": "返回列表中元素的索引，如果元素不在列表中，则返回nil。\n示例：\n>>> index-of-element 'a '(a b c d e)\n0",
      "fr": "Renvoie l'indice de l'élément dans la liste, ou nil si l'élément n'est pas dans la liste.\nExemple:\n>>> index-of-element 'a '(a b c d e)\n0",
      "de": "Gibt den Index des Elements in der Liste zurück oder nil, wenn das Element nicht in der Liste ist.\nBeispiel:\n>>> index-of-element 'a '(a b c d e)\n0",
      "ha": "Yana dawo da lambar inda aka samu abin a cikin jerin, ko kuma nil idan ba a sami abin a cikin jerin ba.\nMisali:\n>>> index-of-element 'a '(a b c d e)\n0",
      "hi": "सूची में तत्व का सूचकांक लौटाता है, या यदि तत्व सूची में नहीं है तो nil लौटाता है।\nउदाहरण:\n>>> index-of-element 'a '(a b c d e)\n0",
      "hu": "Visszaadja az elem indexét a listában, vagy nil értéket, ha az elem nincs a listában.\nPélda:\n>>> index-of-element 'a '(a b c d e)\n0"
    },
    "docstring_bertscore": {
      "sq": "1",
      "hy": "1",
      "bn": "0.9572640776292007",
      "bg": "0.9878795741492511",
      "zh": "0.9614873567907645",
      "fr": "1",
      "de": "0.9878795741492511",
      "ha": "0.9479834703361076",
      "hi": "0.9883608555624986",
      "hu": "1"
    }
  },
  {
    "task_id": "Common Lisp/11",
    "prompt": {
      "en": "(defun contains-list? (lst)\n;; Check if the list contains a list element.\n;; Example:\n;; >>> ontains-list? '(1 2 (3 4) 5)\n;; t",
      "sq": "(defun contains-list? (lst)\n;; Kontrolloni nëse lista përmban një element liste.\n;; Shembull:\n;; >>> ontains-list? '(1 2 (3 4) 5)\n;; t",
      "hy": "(defun contains-list? (lst)\n;; Ստուգել, արդյոք ցուցակը պարունակում է ցուցակի տարր։\n;; Օրինակ:\n;; >>> ontains-list? '(1 2 (3 4) 5)\n;; t",
      "bn": "(defun contains-list? (lst)\n;; তালিকায় কোনো তালিকা উপাদান আছে কিনা তা পরীক্ষা করুন।\n;; উদাহরণ:\n;; >>> contains-list? '(1 2 (3 4) 5)\n;; t",
      "bg": "(defun contains-list? (lst)\n;; Проверете дали списъкът съдържа елемент, който е списък.\n;; Пример:\n;; >>> contains-list? '(1 2 (3 4) 5)\n;; t",
      "zh": "(defun contains-list? (lst)\n;; 检查列表是否包含列表元素。\n;; 示例:\n;; >>> contains-list? '(1 2 (3 4) 5)\n;; t",
      "fr": "(defun contains-list? (lst)\n;; Vérifie si la liste contient un élément de type liste.\n;; Exemple:\n;; >>> contains-list? '(1 2 (3 4) 5)\n;; t",
      "de": "(defun contains-list? (lst)\n;; Überprüfen, ob die Liste ein Listenelement enthält.\n;; Beispiel:\n;; >>> contains-list? '(1 2 (3 4) 5)\n;; t",
      "ha": "(defun contains-list? (lst)\n;; Duba idan jerin yana dauke da wani abu jerin.\n;; Misali:\n;; >>> contains-list? '(1 2 (3 4) 5)\n;; t",
      "hi": "(defun contains-list? (lst)\n;; जाँचें कि सूची में कोई सूची तत्व है या नहीं।\n;; उदाहरण:\n;; >>> ontains-list? '(1 2 (3 4) 5)\n;; t",
      "hu": "(defun contains-list? (lst)\n;; Ellenőrzi, hogy a lista tartalmaz-e lista elemet.\n;; Példa:\n;; >>> contains-list? '(1 2 (3 4) 5)\n;; t"
    },
    "prompt_bertscore": {
      "sq": "0.9707580325648059",
      "hy": "0.9707580325648059",
      "bn": "0.940362419876561",
      "bg": "0.951993817729202",
      "zh": "0.9614392882385541",
      "fr": "0.9472566817719009",
      "de": "0.9707580325648059",
      "ha": "0.9448963569540634",
      "hi": "0.9570660431393089",
      "hu": "0.9655845056603711"
    },
    "canonical_solution": "(loop for item in lst\nthereis (listp item)))",
    "instruction": {
      "en": "Write a Common Lisp function `(defun contains-list? (lst)` to solve the following problem:\nCheck if the list contains a list element.\nExample:\n>>> ontains-list? '(1 2 (3 4) 5)\nt",
      "sq": "Shkruani një funksion Common Lisp `(defun contains-list? (lst)` për të zgjidhur problemin e mëposhtëm:  \nKontrolloni nëse lista përmban një element liste.  \nShembull:  \n>>> contains-list? '(1 2 (3 4) 5)  \nt",
      "hy": "Գրեք Common Lisp ֆունկցիա `(defun contains-list? (lst)` հետևյալ խնդիրը լուծելու համար:\nՍտուգեք՝ արդյոք ցուցակը պարունակում է ցուցակ տարր։\nՕրինակ:\n>>> contains-list? '(1 2 (3 4) 5)\nt",
      "bn": "একটি Common Lisp ফাংশন লিখুন `(defun contains-list? (lst)` নিম্নলিখিত সমস্যার সমাধান করতে:\nপরীক্ষা করুন যে তালিকায় একটি তালিকা উপাদান রয়েছে কিনা।\nউদাহরণ:\n>>> ontains-list? '(1 2 (3 4) 5)\nt",
      "bg": "Напишете функция на Common Lisp `(defun contains-list? (lst)` за решаване на следния проблем:\nПроверете дали списъкът съдържа елемент, който е списък.\nПример:\n>>> ontains-list? '(1 2 (3 4) 5)\nt",
      "zh": "编写一个 Common Lisp 函数 `(defun contains-list? (lst)` 来解决以下问题：\n检查列表中是否包含列表元素。\n示例：\n>>> contains-list? '(1 2 (3 4) 5)\nt",
      "fr": "Écrire une fonction Common Lisp `(defun contains-list? (lst)` pour résoudre le problème suivant :\nVérifier si la liste contient un élément qui est une liste.\nExemple :\n>>> ontains-list? '(1 2 (3 4) 5)\nt",
      "de": "Schreiben Sie eine Common Lisp-Funktion `(defun contains-list? (lst)` um das folgende Problem zu lösen:  \nÜberprüfen Sie, ob die Liste ein Listenelement enthält.  \nBeispiel:  \n>>> contains-list? '(1 2 (3 4) 5)  \nt",
      "ha": "Rubuta wani aikin Common Lisp `(defun contains-list? (lst)` don warware matsalar mai zuwa:\nDuba ko jerin yana dauke da wani jeri.\nMisali:\n>>> contains-list? '(1 2 (3 4) 5)\nt",
      "hi": "एक Common Lisp फ़ंक्शन `(defun contains-list? (lst)` लिखें ताकि निम्नलिखित समस्या का समाधान किया जा सके:\nजाँच करें कि सूची में कोई सूची तत्व है या नहीं।\nउदाहरण:\n>>> contains-list? '(1 2 (3 4) 5)\nt",
      "hu": "Írj egy Common Lisp függvényt `(defun contains-list? (lst)` a következő probléma megoldására:\nEllenőrizd, hogy a lista tartalmaz-e listaelemet.\nPélda:\n>>> ontains-list? '(1 2 (3 4) 5)\nt"
    },
    "instruction_bertscore": {
      "sq": "0.9741921532225181",
      "hy": "0.9741921532225181",
      "bn": "0.9741921532225181",
      "bg": "0.951640851542103",
      "zh": "0.9741921532225181",
      "fr": "0.9594410666053431",
      "de": "0.9741921532225181",
      "ha": "0.9489291495802147",
      "hi": "0.9512872894638609",
      "hu": "0.9741921532225181"
    },
    "level": "easy",
    "test": "(defun check-contains-list? ()\n;; Test 'contains-list?' function.\n(assert (equal (contains-list? '(1 2 (3 4) 5)) t))\n(assert (equal (contains-list? '(1 2 3 4 5)) nil))\n(assert (equal (contains-list? '((1 2) 3 4 5)) t))\n(assert (equal (contains-list? '()) nil))\n(assert (equal (contains-list? '(\"string\" 123 (a b))) t)))\n\n(check-contains-list?)",
    "entry_point": "contains-list?",
    "signature": "(defun contains-list? (lst)",
    "docstring": {
      "en": "Check if the list contains a list element.\nExample:\n>>> ontains-list? '(1 2 (3 4) 5)\nt",
      "sq": "Kontrollo nëse lista përmban një element liste.\nShembull:\n>>> ontains-list? '(1 2 (3 4) 5)\nt",
      "hy": "Ստուգեք, արդյոք ցուցակը պարունակում է ցուցակի տարր։  \nՕրինակ:  \n>>> ontains-list? '(1 2 (3 4) 5)  \nt",
      "bn": "তালিকায় একটি তালিকা উপাদান আছে কিনা তা পরীক্ষা করুন।\nউদাহরণ:\n>>> ontains-list? '(1 2 (3 4) 5)\nt",
      "bg": "Проверете дали списъкът съдържа елемент, който е списък.\nПример:\n>>> ontains-list? '(1 2 (3 4) 5)\nt",
      "zh": "检查列表是否包含列表元素。\n\n示例：\n>>> ontains-list? '(1 2 (3 4) 5)\nt",
      "fr": "Vérifiez si la liste contient un élément de liste.  \nExemple :  \n>>> ontains-list? '(1 2 (3 4) 5)  \nt",
      "de": "Überprüfen Sie, ob die Liste ein Listenelement enthält.  \nBeispiel:  \n>>> ontains-list? '(1 2 (3 4) 5)  \nt",
      "ha": "Duba idan jerin yana dauke da wani abu jerin.\nMisali:\n>>> ontains-list? '(1 2 (3 4) 5)\nt",
      "hi": "सूची में एक सूची तत्व है या नहीं, इसकी जाँच करें।\nउदाहरण:\n>>> ontains-list? '(1 2 (3 4) 5)\nt",
      "hu": "Ellenőrizze, hogy a lista tartalmaz-e listaelemet.  \nPélda:  \n>>> ontains-list? '(1 2 (3 4) 5)  \nt"
    },
    "docstring_bertscore": {
      "sq": "0.9613834731014832",
      "hy": "1",
      "bn": "0.9651216968725599",
      "bg": "0.9665053561068488",
      "zh": "0.98666633978189",
      "fr": "1",
      "de": "0.9613834731014832",
      "ha": "0.9217952463789438",
      "hi": "0.9651216968725599",
      "hu": "1"
    }
  },
  {
    "task_id": "Common Lisp/12",
    "prompt": {
      "en": "(defun sum-non-nil-elements (lst)\n;; Calculate the sum of all non nil elements in the list.\n;; Example:\n;; >>> sum-non-nil-elements '(1 2 nil 4 5)\n;; 12",
      "sq": "(defun sum-non-nil-elements (lst)\n;; Llogarit shumën e të gjitha elementeve që nuk janë nil në listë.\n;; Shembull:\n;; >>> sum-non-nil-elements '(1 2 nil 4 5)\n;; 12",
      "hy": "(defun sum-non-nil-elements (lst)\n;; Հաշվարկել ցուցակի բոլոր ոչ nil տարրերի գումարը։\n;; Օրինակ:\n;; >>> sum-non-nil-elements '(1 2 nil 4 5)\n;; 12",
      "bn": "(defun sum-non-nil-elements (lst)\n;; তালিকার সমস্ত নন-নিল উপাদানের যোগফল গণনা করুন।\n;; উদাহরণ:\n;; >>> sum-non-nil-elements '(1 2 nil 4 5)\n;; 12",
      "bg": "(defun sum-non-nil-elements (lst)\n;; Изчислете сумата на всички елементи, които не са nil в списъка.\n;; Пример:\n;; >>> sum-non-nil-elements '(1 2 nil 4 5)\n;; 12",
      "zh": "(defun sum-non-nil-elements (lst)\n;; 计算列表中所有非 nil 元素的和。\n;; 例子:\n;; >>> sum-non-nil-elements '(1 2 nil 4 5)\n;; 12",
      "fr": "(defun sum-non-nil-elements (lst)\n;; Calculer la somme de tous les éléments non nuls dans la liste.\n;; Exemple:\n;; >>> sum-non-nil-elements '(1 2 nil 4 5)\n;; 12",
      "de": "(defun sum-non-nil-elements (lst)\n;; Berechne die Summe aller nicht-nil Elemente in der Liste.\n;; Beispiel:\n;; >>> sum-non-nil-elements '(1 2 nil 4 5)\n;; 12",
      "ha": "(defun sum-non-nil-elements (lst)\n;; Lissafi jimillar dukkan abubuwan da ba su daidai da nil a cikin jerin.\n;; Misali:\n;; >>> sum-non-nil-elements '(1 2 nil 4 5)\n;; 12",
      "hi": "(defun sum-non-nil-elements (lst)\n;; सूची में सभी गैर-शून्य तत्वों का योग गणना करें।\n;; उदाहरण:\n;; >>> sum-non-nil-elements '(1 2 nil 4 5)\n;; 12",
      "hu": "(defun sum-non-nil-elements (lst)\n;; Számítsa ki a lista összes nem nil elemének összegét.\n;; Példa:\n;; >>> sum-non-nil-elements '(1 2 nil 4 5)\n;; 12"
    },
    "prompt_bertscore": {
      "sq": "0.9742535300102578",
      "hy": "0.9900831795964522",
      "bn": "0.9900831795964522",
      "bg": "0.9742535300102578",
      "zh": "0.9900831795964522",
      "fr": "0.9900831795964522",
      "de": "0.9900831795964522",
      "ha": "0.953029675166299",
      "hi": "0.9900831795964522",
      "hu": "0.9900831795964522"
    },
    "canonical_solution": "(loop for item in lst\nwhen (not (null item))\nsum item))",
    "instruction": {
      "en": "Write a Common Lisp function `(defun sum-non-nil-elements (lst)` to solve the following problem:\nCalculate the sum of all non nil elements in the list.\nExample:\n>>> sum-non-nil-elements '(1 2 nil 4 5)\n12",
      "sq": "Shkruani një funksion Common Lisp `(defun sum-non-nil-elements (lst)` për të zgjidhur problemin e mëposhtëm:  \nLlogaritni shumën e të gjitha elementeve që nuk janë nil në listë.  \nShembull:  \n>>> sum-non-nil-elements '(1 2 nil 4 5)  \n12",
      "hy": "Գրեք Common Lisp ֆունկցիա `(defun sum-non-nil-elements (lst)` հետևյալ խնդիրը լուծելու համար:\nՀաշվեք ցուցակի բոլոր ոչ nil տարրերի գումարը:\nՕրինակ:\n>>> sum-non-nil-elements '(1 2 nil 4 5)\n12",
      "bn": "একটি Common Lisp ফাংশন `(defun sum-non-nil-elements (lst)` লিখুন নিম্নলিখিত সমস্যার সমাধানের জন্য:\nতালিকায় সমস্ত nil নয় এমন উপাদানের যোগফল গণনা করুন।\nউদাহরণ:\n>>> sum-non-nil-elements '(1 2 nil 4 5)\n12",
      "bg": "Напишете функция на Common Lisp `(defun sum-non-nil-elements (lst)` за решаване на следния проблем:  \nИзчислете сумата на всички елементи в списъка, които не са nil.  \nПример:  \n>>> sum-non-nil-elements '(1 2 nil 4 5)  \n12",
      "zh": "编写一个 Common Lisp 函数 `(defun sum-non-nil-elements (lst)` 来解决以下问题：  \n计算列表中所有非 nil 元素的和。  \n例子：  \n>>> sum-non-nil-elements '(1 2 nil 4 5)  \n12",
      "fr": "Écrire une fonction Common Lisp `(defun sum-non-nil-elements (lst)` pour résoudre le problème suivant :  \nCalculer la somme de tous les éléments non nil dans la liste.  \nExemple :  \n>>> sum-non-nil-elements '(1 2 nil 4 5)  \n12",
      "de": "Schreiben Sie eine Common Lisp Funktion `(defun sum-non-nil-elements (lst)` um das folgende Problem zu lösen:\nBerechnen Sie die Summe aller nicht-nil Elemente in der Liste.\nBeispiel:\n>>> sum-non-nil-elements '(1 2 nil 4 5)\n12",
      "ha": "Rubuta aikin Common Lisp `(defun sum-non-nil-elements (lst)` don warware matsalar mai zuwa: \nLissafa jimillar dukkan abubuwan da ba su da nil a cikin jerin. \nMisali: \n>>> sum-non-nil-elements '(1 2 nil 4 5) \n12",
      "hi": "लिखें एक Common Lisp फ़ंक्शन `(defun sum-non-nil-elements (lst)` निम्नलिखित समस्या को हल करने के लिए:\nसूची में सभी non nil तत्वों का योग गणना करें।\nउदाहरण:\n>>> sum-non-nil-elements '(1 2 nil 4 5)\n12",
      "hu": "Írj egy Common Lisp függvényt `(defun sum-non-nil-elements (lst)` a következő probléma megoldására:\nSzámítsd ki az összes nem nil elem összegét a listában.\nPélda:\n>>> sum-non-nil-elements '(1 2 nil 4 5)\n12"
    },
    "instruction_bertscore": {
      "sq": "0.9785336174607976",
      "hy": "0.9924013947735103",
      "bn": "0.9924013947735103",
      "bg": "0.9726543568125459",
      "zh": "0.9924013947735103",
      "fr": "0.9924013947735103",
      "de": "0.9924013947735103",
      "ha": "0.9870677717819616",
      "hi": "0.9924013947735103",
      "hu": "0.9924013947735103"
    },
    "level": "easy",
    "test": "(defun check-sum-non-nil-elements ()\n(assert (equal (sum-non-nil-elements '(1 2 nil 4 5)) 12))\n(assert (equal (sum-non-nil-elements '(nil nil nil)) 0))\n(assert (equal (sum-non-nil-elements '(3 4 nil 6)) 13))\n(assert (equal (sum-non-nil-elements '()) 0))\n(assert (equal (sum-non-nil-elements '(nil 7 8)) 15)))\n\n(check-sum-non-nil-elements)",
    "entry_point": "sum-non-nil-elements",
    "signature": "(defun sum-non-nil-elements (lst)",
    "docstring": {
      "en": "Calculate the sum of all non nil elements in the list.\nExample:\n>>> sum-non-nil-elements '(1 2 nil 4 5)\n12",
      "sq": "Llogarit shumën e të gjitha elementeve që nuk janë nil në listë.\nShembull:\n>>> sum-non-nil-elements '(1 2 nil 4 5)\n12",
      "hy": "Հաշվարկել ցուցակի բոլոր ոչ nil տարրերի գումարը։\nՕրինակ:\n>>> sum-non-nil-elements '(1 2 nil 4 5)  \n12",
      "bn": "তালিকার সমস্ত নন-নিল উপাদানের যোগফল গণনা করুন।\nউদাহরণ:\n>>> sum-non-nil-elements '(1 2 nil 4 5)  \n12",
      "bg": "Изчислете сумата на всички ненулеви елементи в списъка.\nПример:\n>>> sum-non-nil-elements '(1 2 nil 4 5)  \n12",
      "zh": "计算列表中所有非 nil 元素的和。\n示例：\n>>> sum-non-nil-elements '(1 2 nil 4 5)  \n12",
      "fr": "Calculer la somme de tous les éléments non nuls dans la liste.\nExemple:\n>>> sum-non-nil-elements '(1 2 nil 4 5)  \n12",
      "de": "Berechne die Summe aller nicht-nil Elemente in der Liste.\nBeispiel:\n>>> sum-non-nil-elements '(1 2 nil 4 5)  \n12",
      "ha": "Ƙididdige jimillar dukkan abubuwan da ba su da ƙima a cikin jerin.\nMisali:\n>>> sum-non-nil-elements '(1 2 nil 4 5)  \n12",
      "hi": "सभी गैर-शून्य तत्वों का सूची में योग गणना करें।\nउदाहरण:\n>>> sum-non-nil-elements '(1 2 nil 4 5)  \n12",
      "hu": "Számítsa ki az összes nem nil elemek összegét a listában.\nPélda:\n>>> sum-non-nil-elements '(1 2 nil 4 5)  \n12"
    },
    "docstring_bertscore": {
      "sq": "0.9646710045379917",
      "hy": "0.9849612965910866",
      "bn": "1",
      "bg": "0.9812594221797394",
      "zh": "0.9849612965910866",
      "fr": "0.9812594221797394",
      "de": "0.9849612965910866",
      "ha": "0.9439459105808115",
      "hi": "0.9258238677670935",
      "hu": "0.9849612965910866"
    }
  },
  {
    "task_id": "Common Lisp/13",
    "prompt": {
      "en": "(defun conditional-square (x)\n;; If x is a positive integer less than or equal to 5, return x; otherwise, return the square of x.\n;; Example:\n;; >>> conditional-square 3\n;; 3",
      "sq": "(defun conditional-square (x)\n;; Nëse x është një numër i plotë pozitiv më i vogël ose i barabartë me 5, kthe x; përndryshe, kthe katrorin e x.\n;; Shembull:\n;; >>> conditional-square 3\n;; 3",
      "hy": "(defun conditional-square (x)\n;; Եթե x-ը դրական ամբողջ թիվ է, որը փոքր կամ հավասար է 5-ի, վերադարձնել x; հակառակ դեպքում վերադարձնել x-ի քառակուսին։\n;; Օրինակ:\n;; >>> conditional-square 3\n;; 3",
      "bn": "(defun conditional-square (x)\n;; যদি x একটি ধনাত্মক পূর্ণসংখ্যা হয় যা 5 এর সমান বা তার চেয়ে কম, তাহলে x ফেরত দিন; অন্যথায়, x এর বর্গফল ফেরত দিন।\n;; উদাহরণ:\n;; >>> conditional-square 3\n;; 3",
      "bg": "(defun conditional-square (x)\n;; Ако x е положително цяло число, по-малко или равно на 5, върни x; в противен случай върни квадрата на x.\n;; Пример:\n;; >>> conditional-square 3\n;; 3",
      "zh": "(defun conditional-square (x)\n;; 如果 x 是小于或等于 5 的正整数，则返回 x；否则，返回 x 的平方。\n;; 示例:\n;; >>> conditional-square 3\n;; 3",
      "fr": "(defun conditional-square (x)\n;; Si x est un entier positif inférieur ou égal à 5, retourner x ; sinon, retourner le carré de x.\n;; Exemple:\n;; >>> conditional-square 3\n;; 3",
      "de": "(defun conditional-square (x)\n;; Wenn x eine positive ganze Zahl kleiner oder gleich 5 ist, gib x zurück; andernfalls gib das Quadrat von x zurück.\n;; Beispiel:\n;; >>> conditional-square 3\n;; 3",
      "ha": "(defun conditional-square (x)\n;; Idan x lamba ce mai kyau ƙasa ko daidai da 5, dawo da x; in ba haka ba, dawo da murabba'in x.\n;; Misali:\n;; >>> conditional-square 3\n;; 3",
      "hi": "(defun conditional-square (x)\n;; यदि x एक धनात्मक पूर्णांक है जो 5 से कम या बराबर है, तो x लौटाएं; अन्यथा, x का वर्ग लौटाएं।\n;; उदाहरण:\n;; >>> conditional-square 3\n;; 3",
      "hu": "(defun conditional-square (x)\n;; Ha x egy pozitív egész szám, amely kisebb vagy egyenlő 5-tel, akkor térjen vissza x; különben térjen vissza x négyzetével.\n;; Példa:\n;; >>> conditional-square 3\n;; 3"
    },
    "prompt_bertscore": {
      "sq": "1",
      "hy": "0.9867745933395541",
      "bn": "0.9684431941042252",
      "bg": "0.9914267154937721",
      "zh": "1",
      "fr": "1",
      "de": "1",
      "ha": "0.9745699482072464",
      "hi": "0.9867745933395541",
      "hu": "0.9600353687053995"
    },
    "canonical_solution": "(if (and (integerp x) (<= x 5) (> x 0))\nx\n(* x x)))",
    "instruction": {
      "en": "Write a Common Lisp function `(defun conditional-square (x)` to solve the following problem:\nIf x is a positive integer less than or equal to 5, return x; otherwise, return the square of x.\nExample:\n>>> conditional-square 3\n3",
      "sq": "Shkruani një funksion Common Lisp `(defun conditional-square (x)` për të zgjidhur problemin e mëposhtëm: Nëse x është një numër i plotë pozitiv më i vogël ose i barabartë me 5, kthe x; përndryshe, kthe katrorin e x. Shembull: >>> conditional-square 3 3",
      "hy": "Common Lisp ֆունկցիա գրեք `(defun conditional-square (x)` հետևյալ խնդիրը լուծելու համար:\nԵթե x-ը դրական ամբողջ թիվ է, որը փոքր կամ հավասար է 5-ին, վերադարձնել x; հակառակ դեպքում, վերադարձնել x-ի քառակուսին։\nՕրինակ:\n>>> conditional-square 3\n3",
      "bn": "একটি Common Lisp ফাংশন `(defun conditional-square (x)` লিখুন নিম্নলিখিত সমস্যার সমাধানের জন্য:\nযদি x একটি ধনাত্মক পূর্ণসংখ্যা হয় যা 5 এর সমান বা তার চেয়ে কম, তাহলে x ফেরত দিন; অন্যথায়, x এর বর্গ ফেরত দিন।\nউদাহরণ:\n>>> conditional-square 3\n3",
      "bg": "Напишете функция на Common Lisp `(defun conditional-square (x)` за решаване на следния проблем:  \nАко x е положително цяло число, по-малко или равно на 5, върнете x; в противен случай върнете квадрата на x.  \nПример:  \n>>> conditional-square 3  \n3",
      "zh": "编写一个 Common Lisp 函数 `(defun conditional-square (x)` 来解决以下问题：  \n如果 x 是小于或等于 5 的正整数，则返回 x；否则，返回 x 的平方。  \n示例：  \n>>> conditional-square 3  \n3",
      "fr": "Écrire une fonction Common Lisp `(defun conditional-square (x)` pour résoudre le problème suivant :  \nSi x est un entier positif inférieur ou égal à 5, retourner x ; sinon, retourner le carré de x.  \nExemple :  \n>>> conditional-square 3  \n3",
      "de": "Schreiben Sie eine Common Lisp-Funktion `(defun conditional-square (x)` um das folgende Problem zu lösen:\nWenn x eine positive ganze Zahl kleiner oder gleich 5 ist, geben Sie x zurück; andernfalls geben Sie das Quadrat von x zurück.\nBeispiel:\n>>> conditional-square 3\n3",
      "ha": "Rubuta aikin Common Lisp `(defun conditional-square (x)` don warware matsalar mai zuwa:  \nIdan x lamba ce mai kyau ƙasa da ko daidai da 5, mayar da x; in ba haka ba, mayar da murabba'in x.  \nMisali:  \n>>> conditional-square 3  \n3",
      "hi": "Common Lisp फ़ंक्शन `(defun conditional-square (x)` लिखें ताकि निम्नलिखित समस्या का समाधान हो सके:\nयदि x एक धनात्मक पूर्णांक है जो 5 से कम या उसके बराबर है, तो x लौटाएं; अन्यथा, x का वर्ग लौटाएं।\nउदाहरण:\n>>> conditional-square 3\n3",
      "hu": "Írj egy Common Lisp függvényt `(defun conditional-square (x)` a következő probléma megoldására:\nHa x egy pozitív egész szám, amely kisebb vagy egyenlő 5-tel, akkor térjen vissza x-szel; különben térjen vissza x négyzetével.\nPélda:\n>>> conditional-square 3\n3"
    },
    "instruction_bertscore": {
      "sq": "1",
      "hy": "0.9884293830439557",
      "bn": "0.9733646590551267",
      "bg": "1",
      "zh": "1",
      "fr": "1",
      "de": "1",
      "ha": "0.9899028232104725",
      "hi": "0.9528457434334606",
      "hu": "0.9660902186104859"
    },
    "level": "easy",
    "test": "(defun check-conditional-square ()\n;; Test 'conditional-square' function.\n(assert (equal (conditional-square 3) 3))\n(assert (equal (conditional-square 5) 5))\n(assert (equal (conditional-square 6) 36))\n(assert (equal (conditional-square -3) 9))\n(assert (equal (conditional-square 2.5) 6.25)))\n\n(check-conditional-square)",
    "entry_point": "conditional-square",
    "signature": "(defun conditional-square (x)",
    "docstring": {
      "en": "If x is a positive integer less than or equal to 5, return x; otherwise, return the square of x.\nExample:\n>>> conditional-square 3\n3",
      "sq": "Nëse x është një numër i plotë pozitiv më i vogël ose i barabartë me 5, kthe x; përndryshe, kthe katrorin e x. \nShembull:\n>>> conditional-square 3\n3",
      "hy": "Եթե x-ը դրական ամբողջ թիվ է, որը փոքր կամ հավասար է 5-ի, վերադարձնել x-ը; հակառակ դեպքում, վերադարձնել x-ի քառակուսին:\nՕրինակ:\n>>> conditional-square 3\n3",
      "bn": "যদি x একটি ধনাত্মক পূর্ণসংখ্যা হয় যা ৫ এর সমান বা কম, তাহলে x ফেরত দিন; অন্যথায়, x এর বর্গফল ফেরত দিন।\nউদাহরণ:\n>>> conditional-square 3\n3",
      "bg": "Ако x е положително цяло число, по-малко или равно на 5, върнете x; в противен случай върнете квадрата на x.\nПример:\n>>> conditional-square 3\n3",
      "zh": "如果 x 是小于或等于 5 的正整数，则返回 x；否则，返回 x 的平方。\n示例：\n>>> conditional-square 3\n3",
      "fr": "Si x est un entier positif inférieur ou égal à 5, renvoyez x ; sinon, renvoyez le carré de x.\nExemple :\n>>> conditional-square 3\n3",
      "de": "Wenn x eine positive ganze Zahl kleiner oder gleich 5 ist, gib x zurück; andernfalls gib das Quadrat von x zurück.\nBeispiel:\n>>> conditional-square 3\n3",
      "ha": "Idan x lamba ce mai kyau ƙasa ko daidai da 5, dawo da x; in ba haka ba, dawo da murabba'in x. Misali: >>> conditional-square 3 3",
      "hi": "यदि x एक सकारात्मक पूर्णांक है जो 5 के बराबर या उससे कम है, तो x लौटाएं; अन्यथा, x का वर्ग लौटाएं।  \nउदाहरण:  \n>>> conditional-square 3  \n3",
      "hu": "Ha x egy pozitív egész szám, amely kisebb vagy egyenlő 5-tel, akkor térj vissza x-szel; ellenkező esetben térj vissza x négyzetével.\nPélda:\n>>> conditional-square 3\n3"
    },
    "docstring_bertscore": {
      "sq": "1",
      "hy": "0.9803334073433547",
      "bn": "0.95725434474053",
      "bg": "0.9845409947048167",
      "zh": "1",
      "fr": "1",
      "de": "1",
      "ha": "0.9639539488624558",
      "hi": "0.95725434474053",
      "hu": "0.9439826572013029"
    }
  },
  {
    "task_id": "Common Lisp/14",
    "prompt": {
      "en": "(defun lines-from-file (filename)\n;; Read each line from the file and return them as a string list.",
      "sq": "(defun lines-from-file (filename)\n;; Lexo çdo rresht nga skedari dhe ktheji ato si një listë me stringje.",
      "hy": "(defun lines-from-file (filename)\n;; Կարդացեք ֆայլից յուրաքանչյուր տող և վերադարձեք դրանք որպես տողերի ցուցակ։",
      "bn": "(defun lines-from-file (filename)\n;; ফাইল থেকে প্রতিটি লাইন পড়ুন এবং সেগুলিকে একটি স্ট্রিং তালিকা হিসাবে ফেরত দিন।",
      "bg": "(defun lines-from-file (filename)\n;; Прочетете всеки ред от файла и ги върнете като списък от низове.",
      "zh": "(defun lines-from-file (filename)\n;; 从文件中读取每一行，并将它们作为字符串列表返回。",
      "fr": "(defun lines-from-file (filename)\n;; Lire chaque ligne du fichier et les retourner sous forme de liste de chaînes.",
      "de": "(defun lines-from-file (filename)\n;; Lies jede Zeile aus der Datei und gib sie als Stringliste zurück.",
      "ha": "(defun lines-from-file (filename)\n;; Karanta kowace layi daga fayil ɗin kuma mayar da su a matsayin jerin kirtani.",
      "hi": "(defun lines-from-file (filename)\n;; फ़ाइल से प्रत्येक पंक्ति पढ़ें और उन्हें एक स्ट्रिंग सूची के रूप में लौटाएं।",
      "hu": "(defun lines-from-file (filename)\n;; Olvassa be a fájl minden sorát, és adja vissza őket egy karakterlánc listaként."
    },
    "prompt_bertscore": {
      "sq": "0.9849328924465985",
      "hy": "0.9849328924465985",
      "bn": "0.9849328924465985",
      "bg": "0.9849328924465985",
      "zh": "0.9849328924465985",
      "fr": "0.9849328924465985",
      "de": "0.9849328924465985",
      "ha": "0.9849328924465985",
      "hi": "0.9849328924465985",
      "hu": "0.9554329041464401"
    },
    "canonical_solution": "(with-open-file (stream filename)\n(loop for line = (read-line stream nil nil)\nwhile line\ncollect line)))",
    "instruction": {
      "en": "Write a Common Lisp function `(defun lines-from-file (filename)` to solve the following problem:\nRead each line from the file and return them as a string list.",
      "sq": "Shkruani një funksion në Common Lisp `(defun lines-from-file (filename)` për të zgjidhur problemin e mëposhtëm:\nLexoni çdo rresht nga skedari dhe kthejini ato si një listë me vargje.",
      "hy": "Գրեք Common Lisp ֆունկցիա `(defun lines-from-file (filename)` հետևյալ խնդիրը լուծելու համար: Կարդացեք յուրաքանչյուր տող ֆայլից և վերադարձեք դրանք որպես տողերի ցուցակ:",
      "bn": "একটি Common Lisp ফাংশন `(defun lines-from-file (filename)` লিখুন নিম্নলিখিত সমস্যার সমাধানের জন্য:\nফাইল থেকে প্রতিটি লাইন পড়ুন এবং সেগুলিকে একটি স্ট্রিং তালিকা হিসাবে ফেরত দিন।",
      "bg": "Напишете функция на Common Lisp `(defun lines-from-file (filename)` за решаване на следния проблем:  \nПрочетете всеки ред от файла и ги върнете като списък от низове.",
      "zh": "编写一个 Common Lisp 函数 `(defun lines-from-file (filename)` 来解决以下问题：  \n从文件中读取每一行并将其作为字符串列表返回。",
      "fr": "Écrire une fonction Common Lisp `(defun lines-from-file (filename)` pour résoudre le problème suivant :  \nLire chaque ligne du fichier et les retourner sous forme de liste de chaînes.",
      "de": "Schreiben Sie eine Common Lisp-Funktion `(defun lines-from-file (filename)` um das folgende Problem zu lösen:\nJede Zeile aus der Datei lesen und sie als String-Liste zurückgeben.",
      "ha": "Rubuta aikin Common Lisp `(defun lines-from-file (filename)` don warware matsalar mai zuwa: Karanta kowace layi daga fayil ɗin kuma mayar da su azaman jerin kirtani.",
      "hi": "Common Lisp फ़ंक्शन `(defun lines-from-file (filename)` लिखें ताकि निम्नलिखित समस्या का समाधान किया जा सके:\nफ़ाइल से प्रत्येक पंक्ति पढ़ें और उन्हें एक स्ट्रिंग सूची के रूप में लौटाएं।",
      "hu": "Írj egy Common Lisp függvényt `(defun lines-from-file (filename)` a következő probléma megoldására:  \nOlvassa be a fájl minden sorát, és adja vissza őket egy karakterlánc listaként."
    },
    "instruction_bertscore": {
      "sq": "0.9816473473139005",
      "hy": "0.9900059123782295",
      "bn": "0.9900059123782295",
      "bg": "0.9816473473139005",
      "zh": "0.9900059123782295",
      "fr": "0.9900059123782295",
      "de": "0.9864349353879844",
      "ha": "0.9839627816656241",
      "hi": "0.9653850807578122",
      "hu": "0.9822307247429999"
    },
    "level": "easy",
    "test": "(defun check-lines-from-file ()\n(let ((lines (lines-from-file \"../data/Common Lisp/file.txt\")))\n(assert (equal (first lines) \"First line of the file\"))\n(assert (equal (second lines) \"Second line of the file\"))))\n\n(check-lines-from-file)",
    "entry_point": "lines-from-file",
    "signature": "(defun lines-from-file (filename)",
    "docstring": {
      "en": "Read each line from the file and return them as a string list.",
      "sq": "Lexoni secilën rresht nga skedari dhe kthejini ato si një listë me vargje.",
      "hy": "Ֆայլից կարդացեք յուրաքանչյուր տողը և վերադարձեք դրանք որպես տողերի ցուցակ։",
      "bn": "ফাইল থেকে প্রতিটি লাইন পড়ুন এবং সেগুলোকে একটি স্ট্রিং তালিকা হিসেবে ফেরত দিন।",
      "bg": "Прочетете всеки ред от файла и ги върнете като списък от низове.",
      "zh": "将文件中的每一行读取并作为字符串列表返回。",
      "fr": "Lire chaque ligne du fichier et les retourner sous forme de liste de chaînes.",
      "de": "Lies jede Zeile aus der Datei und gib sie als String-Liste zurück.",
      "ha": "Karanta kowace layi daga fayil ɗin kuma mayar da su a matsayin jerin kirtani.",
      "hi": "फाइल से प्रत्येक पंक्ति पढ़ें और उन्हें एक स्ट्रिंग सूची के रूप में लौटाएं।",
      "hu": "Olvassa be a fájl minden sorát, és adja vissza őket karakterlánc listaként."
    },
    "docstring_bertscore": {
      "sq": "0.9725437196903095",
      "hy": "0.9725437196903095",
      "bn": "0.9725437196903095",
      "bg": "0.9725437196903095",
      "zh": "0.9487605123867161",
      "fr": "0.9548777322314476",
      "de": "0.9649490870714406",
      "ha": "0.9725437196903095",
      "hi": "0.9725437196903095",
      "hu": "0.9548777322314476"
    }
  },
  {
    "task_id": "Common Lisp/15",
    "prompt": {
      "en": "(defun nondecreasing? (numbers)\n;; Check if the real number list is in non decreasing order.\n;; Example:\n;; >>> nondecreasing? '(1.0 2.0 2.0 3.0 4.0)\n;; t",
      "sq": "(defun nondecreasing? (numbers)\n;; Kontrolloni nëse lista e numrave realë është në rend jo-zbritës.\n;; Shembull:\n;; >>> nondecreasing? '(1.0 2.0 2.0 3.0 4.0)\n;; t",
      "hy": "(defun nondecreasing? (numbers)\n;; Ստուգել, արդյոք իրական թվերի ցուցակը աճման կարգով է։\n;; Օրինակ:\n;; >>> nondecreasing? '(1.0 2.0 2.0 3.0 4.0)\n;; t",
      "bn": "(defun nondecreasing? (numbers)\n;; পরীক্ষা করুন যে প্রকৃত সংখ্যার তালিকাটি অ-হ্রাসমান ক্রমে আছে কিনা।\n;; উদাহরণ:\n;; >>> nondecreasing? '(1.0 2.0 2.0 3.0 4.0)\n;; t",
      "bg": "(defun nondecreasing? (numbers)\n;; Проверете дали списъкът с реални числа е в ненамаляващ ред.\n;; Пример:\n;; >>> nondecreasing? '(1.0 2.0 2.0 3.0 4.0)\n;; t",
      "zh": "(defun nondecreasing? (numbers)\n;; 检查实数列表是否为非递减顺序。\n;; 例子:\n;; >>> nondecreasing? '(1.0 2.0 2.0 3.0 4.0)\n;; t",
      "fr": "(defun nondecreasing? (numbers)\n;; Vérifier si la liste de nombres réels est dans un ordre non décroissant.\n;; Exemple:\n;; >>> nondecreasing? '(1.0 2.0 2.0 3.0 4.0)\n;; t",
      "de": "(defun nondecreasing? (numbers)\n;; Überprüfen, ob die Liste der reellen Zahlen in nicht abnehmender Reihenfolge ist.\n;; Beispiel:\n;; >>> nondecreasing? '(1.0 2.0 2.0 3.0 4.0)\n;; t",
      "ha": "(defun nondecreasing? (numbers)\n;; Duba idan jerin lambobin ainihi suna cikin tsari mai ƙaruwa ba tare da raguwa ba.\n;; Misali:\n;; >>> nondecreasing? '(1.0 2.0 2.0 3.0 4.0)\n;; t",
      "hi": "(defun nondecreasing? (numbers)\n;; जाँचें कि वास्तविक संख्या सूची गैर-घटते क्रम में है या नहीं।\n;; उदाहरण:\n;; >>> nondecreasing? '(1.0 2.0 2.0 3.0 4.0)\n;; t",
      "hu": "(defun nondecreasing? (numbers)\n;; Ellenőrzi, hogy a valós számok listája nem csökkenő sorrendben van-e.\n;; Példa:\n;; >>> nondecreasing? '(1.0 2.0 2.0 3.0 4.0)\n;; t"
    },
    "prompt_bertscore": {
      "sq": "0.9662519037406484",
      "hy": "0.9662519037406484",
      "bn": "0.9662519037406484",
      "bg": "0.9662519037406484",
      "zh": "0.9662519037406484",
      "fr": "0.962731577497567",
      "de": "0.9662519037406484",
      "ha": "0.9619879053509724",
      "hi": "0.956907536095243",
      "hu": "0.9601658688657394"
    },
    "canonical_solution": "(loop for i from 0 below (1- (length numbers))\nalways (<= (nth i numbers) (nth (1+ i) numbers))))",
    "instruction": {
      "en": "Write a Common Lisp function `(defun nondecreasing? (numbers)` to solve the following problem:\nCheck if the real number list is in non decreasing order.\nExample:\n>>> nondecreasing? '(1.0 2.0 2.0 3.0 4.0)\nt",
      "sq": "Shkruani një funksion në Common Lisp `(defun nondecreasing? (numbers)` për të zgjidhur problemin e mëposhtëm:  \nKontrolloni nëse lista e numrave realë është në rend jo-zbritës.  \nShembull:  \n>>> nondecreasing? '(1.0 2.0 2.0 3.0 4.0)  \nt",
      "hy": "Գրեք Common Lisp ֆունկցիա `(defun nondecreasing? (numbers)` հետևյալ խնդիրը լուծելու համար:\nՍտուգեք, արդյոք իրական թվերի ցուցակը ոչ նվազող կարգով է:\nՕրինակ:\n>>> nondecreasing? '(1.0 2.0 2.0 3.0 4.0)\nt",
      "bn": "একটি Common Lisp ফাংশন `(defun nondecreasing? (numbers)` লিখুন নিম্নলিখিত সমস্যার সমাধানের জন্য: \nযাচাই করুন যে প্রকৃত সংখ্যার তালিকা অ-হ্রাসমান ক্রমে রয়েছে কিনা। \nউদাহরণ: \n>>> nondecreasing? '(1.0 2.0 2.0 3.0 4.0) \nt",
      "bg": "Напишете функция на Common Lisp `(defun nondecreasing? (numbers)` за решаване на следния проблем:  \nПроверете дали списъкът от реални числа е в не намаляващ ред.  \nПример:  \n>>> nondecreasing? '(1.0 2.0 2.0 3.0 4.0)  \nt",
      "zh": "编写一个 Common Lisp 函数 `(defun nondecreasing? (numbers)` 来解决以下问题：\n检查实数列表是否为非递减顺序。\n例子：\n>>> nondecreasing? '(1.0 2.0 2.0 3.0 4.0)\nt",
      "fr": "Écrire une fonction Common Lisp `(defun nondecreasing? (numbers)` pour résoudre le problème suivant :\nVérifier si la liste de nombres réels est dans un ordre non décroissant.\nExemple :\n>>> nondecreasing? '(1.0 2.0 2.0 3.0 4.0)\nt",
      "de": "Schreiben Sie eine Common Lisp Funktion `(defun nondecreasing? (numbers)` um das folgende Problem zu lösen:\nÜberprüfen Sie, ob die Liste der reellen Zahlen in nicht abnehmender Reihenfolge ist.\nBeispiel:\n>>> nondecreasing? '(1.0 2.0 2.0 3.0 4.0)\nt",
      "ha": "Rubuta aikin Common Lisp `(defun nondecreasing? (numbers)` don warware matsalar mai zuwa:\nDuba idan jerin lambobin gaske suna cikin tsari mara raguwa.\nMisali:\n>>> nondecreasing? '(1.0 2.0 2.0 3.0 4.0)\nt",
      "hi": "एक Common Lisp फ़ंक्शन `(defun nondecreasing? (numbers)` लिखें ताकि निम्नलिखित समस्या का समाधान किया जा सके:\nजाँच करें कि वास्तविक संख्या सूची गैर-घटते क्रम में है या नहीं।\nउदाहरण:\n>>> nondecreasing? '(1.0 2.0 2.0 3.0 4.0)\nt",
      "hu": "Írj egy Common Lisp függvényt `(defun nondecreasing? (numbers)` a következő probléma megoldására:\nEllenőrizd, hogy a valós számok listája nem csökkenő sorrendben van-e.\nPélda:\n>>> nondecreasing? '(1.0 2.0 2.0 3.0 4.0)\nt"
    },
    "instruction_bertscore": {
      "sq": "0.9666875001662578",
      "hy": "0.9691721676026233",
      "bn": "0.9676478780585616",
      "bg": "0.9666875001662578",
      "zh": "0.9691721676026233",
      "fr": "0.9725645758803182",
      "de": "0.9725645758803182",
      "ha": "0.9691721676026233",
      "hi": "0.9725645758803182",
      "hu": "0.9725645758803182"
    },
    "level": "easy",
    "test": "(defun check-nondecreasing? ()\n(assert (equal (nondecreasing? '(1.0 2.0 2.0 3.0 4.0)) t))\n(assert (equal (nondecreasing? '(1.0 2.0 3.0 3.9 4.0)) t))\n(assert (equal (nondecreasing? '(1.0 2.0 1.0 4.0 5.0)) nil))\n(assert (equal (nondecreasing? '(5.0 5.0 5.0 5.0)) t))\n(assert (equal (nondecreasing? '(1.0)) t))\n(assert (equal (nondecreasing? '()) t)))\n\n(check-nondecreasing?)",
    "entry_point": "nondecreasing?",
    "signature": "(defun nondecreasing? (numbers)",
    "docstring": {
      "en": "Check if the real number list is in non decreasing order.\nExample:\n>>> nondecreasing? '(1.0 2.0 2.0 3.0 4.0)\nt",
      "sq": "Kontrolloni nëse lista e numrave realë është në rend jo-zbritës. Shembull: >>> nondecreasing? '(1.0 2.0 2.0 3.0 4.0) t",
      "hy": "Ստուգեք՝ արդյոք իրական թվերի ցուցակը աճման կարգով է:\nՕրինակ:\n>>> nondecreasing? '(1.0 2.0 2.0 3.0 4.0)\nt",
      "bn": "বাস্তব সংখ্যা তালিকা অ-হ্রাসমান ক্রমে আছে কিনা তা পরীক্ষা করুন।  \nউদাহরণ:  \n>>> nondecreasing? '(1.0 2.0 2.0 3.0 4.0)  \nt",
      "bg": "Проверете дали списъкът от реални числа е в ненамаляващ ред.  \nПример:  \n>>> nondecreasing? '(1.0 2.0 2.0 3.0 4.0)  \nt",
      "zh": "检查实数列表是否按非递减顺序排列。\n示例：\n>>> nondecreasing? '(1.0 2.0 2.0 3.0 4.0)\nt",
      "fr": "Vérifiez si la liste de nombres réels est dans un ordre non décroissant.\nExemple:\n>>> nondecreasing? '(1.0 2.0 2.0 3.0 4.0)\nt",
      "de": "Überprüfen Sie, ob die Liste der reellen Zahlen in nicht absteigender Reihenfolge ist.  \nBeispiel:  \n>>> nondecreasing? '(1.0 2.0 2.0 3.0 4.0)  \nt",
      "ha": "Duba idan jerin lambobin ainihi suna cikin tsari mai ƙaruwa ba tare da raguwa ba.\nMisali:\n>>> nondecreasing? '(1.0 2.0 2.0 3.0 4.0)\nt",
      "hi": "गैर-घटते क्रम में वास्तविक संख्या सूची की जाँच करें।  \nउदाहरण:  \n>>> nondecreasing? '(1.0 2.0 2.0 3.0 4.0)  \nt",
      "hu": "Ellenőrizze, hogy a valós számok listája nem csökkenő sorrendben van-e.  \nPélda:  \n>>> nondecreasing? '(1.0 2.0 2.0 3.0 4.0)  \nt"
    },
    "docstring_bertscore": {
      "sq": "0.9575278587752151",
      "hy": "0.9575278587752151",
      "bn": "0.9575278587752151",
      "bg": "0.9575278587752151",
      "zh": "0.9421169220322422",
      "fr": "0.9508868506156946",
      "de": "0.9575278587752151",
      "ha": "0.9522458796827353",
      "hi": "0.9447424184087614",
      "hu": "0.9575278587752151"
    }
  },
  {
    "task_id": "Common Lisp/16",
    "prompt": {
      "en": "(defun make-change (cents)\n;; Define a function that accepts an integer cents and returns four values, displaying the numbers as 25-, 10-, 5-, 1-, using the minimum number of coins. (Translation: 25- is 25 cents, and so on)\n;; Example:\n;; multiple-value-bind (quarters dimes nickels pennies) (make-change 98\n;; quarters 3\n;; dimes 2\n;; nickels 0\n;; pennies 3",
      "sq": "(defun make-change (cents)\n;; Përkufizo një funksion që pranon një numër të plotë cents dhe kthen katër vlera, duke shfaqur numrat si 25-, 10-, 5-, 1-, duke përdorur numrin minimal të monedhave. (Përkthim: 25- është 25 cent, dhe kështu me radhë)\n;; Shembull:\n;; multiple-value-bind (quarters dimes nickels pennies) (make-change 98\n;; quarters 3\n;; dimes 2\n;; nickels 0\n;; pennies 3",
      "hy": "(defun make-change (cents)\n;; Սահմանել ֆունկցիա, որը ընդունում է ամբողջ թիվ cents և վերադարձնում է չորս արժեք՝ ցուցադրելով թվերը որպես 25-, 10-, 5-, 1-, օգտագործելով մետաղադրամների նվազագույն քանակը։ (Թարգմանություն՝ 25- նշանակում է 25 ցենտ, և այլն)\n;; Օրինակ:\n;; multiple-value-bind (quarters dimes nickels pennies) (make-change 98\n;; quarters 3\n;; dimes 2\n;; nickels 0\n;; pennies 3",
      "bn": "(defun make-change (cents)\n;; একটি ফাংশন সংজ্ঞায়িত করুন যা একটি পূর্ণসংখ্যা cents গ্রহণ করে এবং চারটি মান ফেরত দেয়, সংখ্যাগুলি 25-, 10-, 5-, 1- হিসাবে প্রদর্শন করে, সর্বনিম্ন সংখ্যক কয়েন ব্যবহার করে। (অনুবাদ: 25- হল 25 সেন্ট, এবং এভাবে চলতে থাকে)\n;; উদাহরণ:\n;; multiple-value-bind (quarters dimes nickels pennies) (make-change 98\n;; quarters 3\n;; dimes 2\n;; nickels 0\n;; pennies 3",
      "bg": "(defun make-change (cents)\n;; Дефинирайте функция, която приема цяло число cents и връща четири стойности, показвайки числата като 25-, 10-, 5-, 1-, използвайки минималния брой монети. (Превод: 25- е 25 цента и така нататък)\n;; Пример:\n;; multiple-value-bind (quarters dimes nickels pennies) (make-change 98\n;; quarters 3\n;; dimes 2\n;; nickels 0\n;; pennies 3",
      "zh": "(defun make-change (cents)\n;; 定义一个函数，接受一个整数cents，并返回四个值，显示为25-、10-、5-、1-，使用最少数量的硬币。（翻译：25-是25美分，依此类推）\n;; 示例：\n;; multiple-value-bind (quarters dimes nickels pennies) (make-change 98\n;; quarters 3\n;; dimes 2\n;; nickels 0\n;; pennies 3",
      "fr": "(defun make-change (cents)\n;; Définir une fonction qui accepte un entier cents et renvoie quatre valeurs, affichant les nombres comme 25-, 10-, 5-, 1-, en utilisant le nombre minimum de pièces. (Traduction : 25- est 25 cents, et ainsi de suite)\n;; Exemple :\n;; multiple-value-bind (quarters dimes nickels pennies) (make-change 98\n;; quarters 3\n;; dimes 2\n;; nickels 0\n;; pennies 3",
      "de": "(defun make-change (cents)\n;; Definiere eine Funktion, die eine ganze Zahl cents akzeptiert und vier Werte zurückgibt, wobei die Zahlen als 25-, 10-, 5-, 1- angezeigt werden, unter Verwendung der minimalen Anzahl von Münzen. (Übersetzung: 25- sind 25 Cent, und so weiter)\n;; Beispiel:\n;; multiple-value-bind (quarters dimes nickels pennies) (make-change 98\n;; quarters 3\n;; dimes 2\n;; nickels 0\n;; pennies 3",
      "ha": "(defun make-change (cents)\n;; Ƙirƙiri wata aiki da ke karɓar lamba mai cikakken adadi cents kuma tana mayar da ƙima guda huɗu, tana nuna lambobin a matsayin 25-, 10-, 5-, 1-, ta amfani da mafi ƙarancin adadin tsabar kuɗi. (Fassara: 25- yana nufin 25 cents, da sauransu)\n;; Misali:\n;; multiple-value-bind (quarters dimes nickels pennies) (make-change 98\n;; quarters 3\n;; dimes 2\n;; nickels 0\n;; pennies 3",
      "hi": "(defun make-change (cents)\n;; एक फ़ंक्शन परिभाषित करें जो एक पूर्णांक cents को स्वीकार करता है और चार मान लौटाता है, जो 25-, 10-, 5-, 1- के रूप में संख्याएँ प्रदर्शित करता है, सिक्कों की न्यूनतम संख्या का उपयोग करते हुए। (अनुवाद: 25- का मतलब है 25 सेंट, और इसी तरह)\n;; उदाहरण:\n;; multiple-value-bind (quarters dimes nickels pennies) (make-change 98\n;; quarters 3\n;; dimes 2\n;; nickels 0\n;; pennies 3",
      "hu": "(defun make-change (cents)\n;; Definiálj egy függvényt, amely egy egész számot, cents-et fogad el, és négy értéket ad vissza, megjelenítve a számokat 25-, 10-, 5-, 1-ként, a lehető legkevesebb érmét használva. (Fordítás: 25- az 25 cent, és így tovább)\n;; Példa:\n;; multiple-value-bind (quarters dimes nickels pennies) (make-change 98\n;; quarters 3\n;; dimes 2\n;; nickels 0\n;; pennies 3"
    },
    "prompt_bertscore": {
      "sq": "0.9946361851905339",
      "hy": "0.9828578008559271",
      "bn": "0.996498940903879",
      "bg": "0.9903578854134234",
      "zh": "0.974032653026547",
      "fr": "0.999999801369619",
      "de": "0.9847604812758602",
      "ha": "0.9632521877262594",
      "hi": "0.9757952990278506",
      "hu": "0.9456644606375253"
    },
    "canonical_solution": "(let ((quarters (floor cents 25))\n(remaining-after-quarters (mod cents 25)))\n(let ((dimes (floor remaining-after-quarters 10))\n(remaining-after-dimes (mod remaining-after-quarters 10)))\n(let ((nickels (floor remaining-after-dimes 5))\n(pennies (mod remaining-after-dimes 5)))\n(values quarters dimes nickels pennies)))))",
    "instruction": {
      "en": "Write a Common Lisp function `(defun make-change (cents)` to solve the following problem:\nDefine a function that accepts an integer cents and returns four values, displaying the numbers as 25-, 10-, 5-, 1-, using the minimum number of coins. (Translation: 25- is 25 cents, and so on)\nExample:\nmultiple-value-bind (quarters dimes nickels pennies) (make-change 98\nquarters 3\ndimes 2\nnickels 0\npennies 3",
      "sq": "Shkruani një funksion Common Lisp `(defun make-change (cents)` për të zgjidhur problemin e mëposhtëm:\nPërcaktoni një funksion që pranon një numër të plotë cents dhe kthen katër vlera, duke shfaqur numrat si 25-, 10-, 5-, 1-, duke përdorur numrin minimal të monedhave. (Përkthimi: 25- është 25 cent, dhe kështu me radhë)\nShembull:\nmultiple-value-bind (quarters dimes nickels pennies) (make-change 98\nquarters 3\ndimes 2\nnickels 0\npennies 3",
      "hy": "Գրեք Common Lisp ֆունկցիա `(defun make-change (cents)`՝ հետևյալ խնդիրը լուծելու համար:  \nՍահմանեք ֆունկցիա, որը ընդունում է ամբողջ թիվ `cents` և վերադարձնում է չորս արժեքներ՝ ցուցադրելով թվերը որպես 25-, 10-, 5-, 1-, օգտագործելով մետաղադրամների նվազագույն քանակը։ (Թարգմանություն՝ 25- նշանակում է 25 ցենտ, և այլն)  \nՕրինակ:  \nmultiple-value-bind (quarters dimes nickels pennies) (make-change 98  \nquarters 3  \ndimes 2  \nnickels 0  \npennies 3",
      "bn": "একটি Common Lisp ফাংশন `(defun make-change (cents)` লিখুন নিম্নলিখিত সমস্যার সমাধানের জন্য:\nএকটি ফাংশন সংজ্ঞায়িত করুন যা একটি পূর্ণসংখ্যা cents গ্রহণ করে এবং চারটি মান ফেরত দেয়, ২৫-, ১০-, ৫-, ১- সংখ্যা প্রদর্শন করে, সর্বনিম্ন সংখ্যক কয়েন ব্যবহার করে। (অনুবাদ: ২৫- হল ২৫ সেন্ট, এবং এভাবে)\nউদাহরণ:\nmultiple-value-bind (quarters dimes nickels pennies) (make-change 98\nquarters 3\ndimes 2\nnickels 0\npennies 3",
      "bg": "Напишете функция на Common Lisp `(defun make-change (cents)` за решаване на следния проблем:\nДефинирайте функция, която приема цяло число cents и връща четири стойности, показвайки числата като 25-, 10-, 5-, 1-, използвайки минималния брой монети. (Превод: 25- е 25 цента и така нататък)\nПример:\nmultiple-value-bind (quarters dimes nickels pennies) (make-change 98\nquarters 3\ndimes 2\nnickels 0\npennies 3",
      "zh": "编写一个 Common Lisp 函数 `(defun make-change (cents)` 来解决以下问题：\n定义一个函数，该函数接受一个整数 cents 并返回四个值，显示为 25-，10-，5-，1-，使用最少数量的硬币。（翻译：25- 是 25 美分，依此类推）\n示例：\nmultiple-value-bind (quarters dimes nickels pennies) (make-change 98\nquarters 3\ndimes 2\nnickels 0\npennies 3",
      "fr": "Écrire une fonction Common Lisp `(defun make-change (cents)` pour résoudre le problème suivant :  \nDéfinir une fonction qui accepte un entier cents et retourne quatre valeurs, affichant les nombres comme 25-, 10-, 5-, 1-, en utilisant le nombre minimum de pièces. (Traduction : 25- est 25 cents, et ainsi de suite)  \nExemple :  \nmultiple-value-bind (quarters dimes nickels pennies) (make-change 98  \nquarters 3  \ndimes 2  \nnickels 0  \npennies 3",
      "de": "Schreiben Sie eine Common Lisp-Funktion `(defun make-change (cents)`, um das folgende Problem zu lösen:  \nDefinieren Sie eine Funktion, die eine ganze Zahl cents akzeptiert und vier Werte zurückgibt, wobei die Zahlen als 25-, 10-, 5-, 1- angezeigt werden, unter Verwendung der minimalen Anzahl von Münzen. (Übersetzung: 25- sind 25 Cents, und so weiter)  \nBeispiel:  \nmultiple-value-bind (quarters dimes nickels pennies) (make-change 98  \nquarters 3  \ndimes 2  \nnickels 0  \npennies 3",
      "ha": "Rubuta aikin Common Lisp `(defun make-change (cents)` don warware matsalar mai zuwa:\nAyyana wata aiki da ke karɓar cikakken lamba cents kuma tana mayar da ƙima guda huɗu, tana nuna lambobin a matsayin 25-, 10-, 5-, 1-, ta amfani da mafi ƙarancin adadin tsabar kuɗi. (Fassara: 25- yana nufin 25 cents, da sauransu)\nMisali:\nmultiple-value-bind (quarters dimes nickels pennies) (make-change 98\nquarters 3\ndimes 2\nnickels 0\npennies 3",
      "hi": "लिखें एक Common Lisp फ़ंक्शन `(defun make-change (cents)` निम्नलिखित समस्या को हल करने के लिए:\nएक फ़ंक्शन परिभाषित करें जो एक पूर्णांक cents को स्वीकार करता है और चार मान लौटाता है, 25-, 10-, 5-, 1- के रूप में संख्याएँ प्रदर्शित करते हुए, सिक्कों की न्यूनतम संख्या का उपयोग करते हुए। (अनुवाद: 25- का अर्थ है 25 सेंट, और इसी प्रकार)\nउदाहरण:\nmultiple-value-bind (quarters dimes nickels pennies) (make-change 98\nquarters 3\ndimes 2\nnickels 0\npennies 3",
      "hu": "Írj egy Common Lisp függvényt `(defun make-change (cents)`, hogy megoldja a következő problémát:\nHatározz meg egy függvényt, amely elfogad egy egész számot, mint cents, és négy értéket ad vissza, megjelenítve a számokat 25-, 10-, 5-, 1-, a minimális számú érmét használva. (Fordítás: 25- az 25 cent, és így tovább)\nPélda:\nmultiple-value-bind (quarters dimes nickels pennies) (make-change 98\nquarters 3\ndimes 2\nnickels 0\npennies 3"
    },
    "instruction_bertscore": {
      "sq": "1",
      "hy": "0.9668885141118652",
      "bn": "0.9781323840911071",
      "bg": "0.9901054261991281",
      "zh": "0.9710702795237927",
      "fr": "1",
      "de": "0.9897496791866945",
      "ha": "0.9646318743529279",
      "hi": "0.9630781875124729",
      "hu": "0.9656999099117524"
    },
    "level": "middle",
    "test": "(defun check-make-change ()\n;; Test 'make-change' function.\n(multiple-value-bind (quarters dimes nickels pennies) (make-change 98)\n(assert (equal quarters 3))\n(assert (equal dimes 2))\n(assert (equal nickels 0))\n(assert (equal pennies 3)))\n(multiple-value-bind (quarters dimes nickels pennies) (make-change 41)\n(assert (equal quarters 1))\n(assert (equal dimes 1))\n(assert (equal nickels 1))\n(assert (equal pennies 1)))\n(multiple-value-bind (quarters dimes nickels pennies) (make-change 3)\n(assert (equal quarters 0))\n(assert (equal dimes 0))\n(assert (equal nickels 0))\n(assert (equal pennies 3))))\n\n(check-make-change)",
    "entry_point": "make-change",
    "signature": "(defun make-change (cents)",
    "docstring": {
      "en": "Define a function that accepts an integer cents and returns four values, displaying the numbers as 25-, 10-, 5-, 1-, using the minimum number of coins. (Translation: 25- is 25 cents, and so on)\nExample:\nmultiple-value-bind (quarters dimes nickels pennies) (make-change 98\nquarters 3\ndimes 2\nnickels 0\npennies 3",
      "sq": "Përcaktoni një funksion që pranon një numër të plotë centësh dhe kthen katër vlera, duke shfaqur numrat si 25-, 10-, 5-, 1-, duke përdorur numrin minimal të monedhave. (Përkthim: 25- është 25 centë, e kështu me radhë)\nShembull:\nmultiple-value-bind (quarters dimes nickels pennies) (make-change 98\nquarters 3\ndimes 2\nnickels 0\npennies 3",
      "hy": "Սահմանեք ֆունկցիա, որը ընդունում է ամբողջ թիվ `cents` և վերադարձնում է չորս արժեքներ՝ ցուցադրելով թվերը որպես 25-, 10-, 5-, 1-, օգտագործելով մետաղադրամների նվազագույն քանակը։ (Թարգմանություն՝ 25- նշանակում է 25 ցենտ, և այլն)\nՕրինակ:\nmultiple-value-bind (quarters dimes nickels pennies) (make-change 98\nquarters 3\ndimes 2\nnickels 0\npennies 3",
      "bn": "একটি ফাংশন সংজ্ঞায়িত করুন যা একটি পূর্ণসংখ্যা সেন্ট গ্রহণ করে এবং চারটি মান ফেরত দেয়, সংখ্যাগুলি ২৫-, ১০-, ৫-, ১- হিসাবে প্রদর্শন করে, সর্বনিম্ন সংখ্যক কয়েন ব্যবহার করে। (অনুবাদ: ২৫- হল ২৫ সেন্ট, এবং এভাবে চলতে থাকে)\n\nউদাহরণ:\nmultiple-value-bind (quarters dimes nickels pennies) (make-change 98\nquarters 3\ndimes 2\nnickels 0\npennies 3",
      "bg": "Определете функция, която приема цяло число центове и връща четири стойности, показвайки числата като 25-, 10-, 5-, 1-, използвайки минималния брой монети. (Превод: 25- е 25 цента и така нататък)\nПример:\nmultiple-value-bind (quarters dimes nickels pennies) (make-change 98\nquarters 3\ndimes 2\nnickels 0\npennies 3",
      "zh": "定义一个函数，该函数接受一个整数cents并返回四个值，显示为25-、10-、5-、1-的数量，使用最少数量的硬币。（翻译：25-是25美分，以此类推）\n\n示例：\nmultiple-value-bind (quarters dimes nickels pennies) (make-change 98\nquarters 3\ndimes 2\nnickels 0\npennies 3",
      "fr": "Définir une fonction qui accepte un entier cents et retourne quatre valeurs, affichant les nombres comme 25-, 10-, 5-, 1-, en utilisant le nombre minimum de pièces. (Traduction : 25- est 25 cents, et ainsi de suite)\nExemple :\nmultiple-value-bind (quarters dimes nickels pennies) (make-change 98\nquarters 3\ndimes 2\nnickels 0\npennies 3",
      "de": "Definieren Sie eine Funktion, die einen ganzzahligen Wert in Cents akzeptiert und vier Werte zurückgibt, die die Anzahl der 25-, 10-, 5-, 1-Cent-Münzen mit der minimalen Anzahl von Münzen anzeigen. (Übersetzung: 25- sind 25 Cents, und so weiter)\nBeispiel:\nmultiple-value-bind (quarters dimes nickels pennies) (make-change 98\nquarters 3\ndimes 2\nnickels 0\npennies 3",
      "ha": "Ƙayyade wata aiki wadda take karɓar lamba mai cikakken adadi cents kuma tana mayar da ƙima huɗu, tana nuna lambobin a matsayin 25-, 10-, 5-, 1-, ta amfani da mafi ƙarancin adadin tsabar kudi. (Fassara: 25- yana nufin 25 cents, da sauransu)\n\nMisali:\nmultiple-value-bind (quarters dimes nickels pennies) (make-change 98\nquarters 3\ndimes 2\nnickels 0\npennies 3",
      "hi": "एक फ़ंक्शन परिभाषित करें जो एक पूर्णांक cents को स्वीकार करता है और चार मान लौटाता है, जो 25-, 10-, 5-, 1- के रूप में संख्याएँ प्रदर्शित करता है, सिक्कों की न्यूनतम संख्या का उपयोग करते हुए। (अनुवाद: 25- का अर्थ है 25 सेंट, और इसी प्रकार)\n\nउदाहरण:\nmultiple-value-bind (quarters dimes nickels pennies) (make-change 98\nquarters 3\ndimes 2\nnickels 0\npennies 3",
      "hu": "Határozz meg egy függvényt, amely egy egész számú centet fogad el, és négy értéket ad vissza, megjelenítve a számokat 25-, 10-, 5-, 1-, a lehető legkevesebb érme használatával. (Fordítás: 25- az 25 cent, és így tovább)\nPélda:\nmultiple-value-bind (quarters dimes nickels pennies) (make-change 98\nquarters 3\ndimes 2\nnickels 0\npennies 3"
    },
    "docstring_bertscore": {
      "sq": "0.9869082715859905",
      "hy": "0.9624822963693682",
      "bn": "0.993008607848334",
      "bg": "0.977278273452657",
      "zh": "0.9314043883222686",
      "fr": "1",
      "de": "0.9264348548191568",
      "ha": "0.9288019330699495",
      "hi": "0.979071111271878",
      "hu": "0.9374661902906913"
    }
  },
  {
    "task_id": "Common Lisp/17",
    "prompt": {
      "en": "(defun segments-intersect? (x1 y1 x2 y2 x3 y3 x4 y4)\n;; Define a function that accepts 8 real numbers representing the endpoints of two line segments in two-dimensional space. If the line segments do not intersect, return false, or return two values representing the x and y coordinates of the intersection point\n;; Example:\n;; >>> segments-intersect? 0 0 1 1 1 0 0 1\n;; x 0.5\n;; y 0.5",
      "sq": "(defun segments-intersect? (x1 y1 x2 y2 x3 y3 x4 y4)\n;; Përkufizo një funksion që pranon 8 numra realë që përfaqësojnë pikat fundore të dy segmenteve të vijave në hapësirën dy-dimensionale. Nëse segmentet e vijave nuk ndërpriten, kthe false, ose kthe dy vlera që përfaqësojnë koordinatat x dhe y të pikës së ndërprerjes\n;; Shembull:\n;; >>> segments-intersect? 0 0 1 1 1 0 0 1\n;; x 0.5\n;; y 0.5",
      "hy": "(defun segments-intersect? (x1 y1 x2 y2 x3 y3 x4 y4)\n;; Սահմանեք ֆունկցիա, որը ընդունում է 8 իրական թիվ, որոնք ներկայացնում են երկչափ տարածության երկու գծային հատվածների վերջնակետերը։ Եթե գծային հատվածները չեն հատվում, վերադարձնել false, կամ վերադարձնել երկու արժեք, որոնք ներկայացնում են հատման կետի x և y կոորդինատները\n;; Օրինակ:\n;; >>> segments-intersect? 0 0 1 1 1 0 0 1\n;; x 0.5\n;; y 0.5",
      "bn": "(defun segments-intersect? (x1 y1 x2 y2 x3 y3 x4 y4)\n;; একটি ফাংশন সংজ্ঞায়িত করুন যা দুটি মাত্রিক স্থানে দুটি রেখা খণ্ডের প্রান্তবিন্দু উপস্থাপনকারী ৮টি বাস্তব সংখ্যা গ্রহণ করে। যদি রেখা খণ্ডগুলি ছেদ না করে, তাহলে false ফেরত দিন, অথবা ছেদ বিন্দুর x এবং y স্থানাঙ্ক উপস্থাপনকারী দুটি মান ফেরত দিন\n;; উদাহরণ:\n;; >>> segments-intersect? 0 0 1 1 1 0 0 1\n;; x 0.5\n;; y 0.5",
      "bg": "(defun segments-intersect? (x1 y1 x2 y2 x3 y3 x4 y4)\n;; Дефинирайте функция, която приема 8 реални числа, представляващи крайните точки на два линейни сегмента в двумерното пространство. Ако линейните сегменти не се пресичат, върнете false, или върнете две стойности, представляващи x и y координатите на точката на пресичане\n;; Пример:\n;; >>> segments-intersect? 0 0 1 1 1 0 0 1\n;; x 0.5\n;; y 0.5",
      "zh": "(defun segments-intersect? (x1 y1 x2 y2 x3 y3 x4 y4)\n;; 定义一个函数，接受8个实数，表示二维空间中两条线段的端点。如果线段不相交，返回false，否则返回两个值，表示交点的x和y坐标\n;; 例子:\n;; >>> segments-intersect? 0 0 1 1 1 0 0 1\n;; x 0.5\n;; y 0.5",
      "fr": "(defun segments-intersect? (x1 y1 x2 y2 x3 y3 x4 y4)\n;; Définir une fonction qui accepte 8 nombres réels représentant les extrémités de deux segments de ligne dans un espace bidimensionnel. Si les segments de ligne ne se croisent pas, retourner faux, ou retourner deux valeurs représentant les coordonnées x et y du point d'intersection\n;; Exemple:\n;; >>> segments-intersect? 0 0 1 1 1 0 0 1\n;; x 0.5\n;; y 0.5",
      "de": "(defun segments-intersect? (x1 y1 x2 y2 x3 y3 x4 y4)\n;; Definiere eine Funktion, die 8 reelle Zahlen akzeptiert, die die Endpunkte von zwei Liniensegmenten im zweidimensionalen Raum darstellen. Wenn die Liniensegmente sich nicht schneiden, gib false zurück, oder gib zwei Werte zurück, die die x- und y-Koordinaten des Schnittpunkts darstellen\n;; Beispiel:\n;; >>> segments-intersect? 0 0 1 1 1 0 0 1\n;; x 0.5\n;; y 0.5",
      "ha": "(defun segments-intersect? (x1 y1 x2 y2 x3 y3 x4 y4)\n;; Ƙirƙiri wata aiki da ke karɓar lambobi 8 na ainihi da ke wakiltar ƙarshen layuka biyu a cikin sarari mai girma biyu. Idan layukan ba su haɗu ba, dawo da ƙarya, ko kuma dawo da ƙimar x da y da ke wakiltar wurin haɗuwar\n;; Misali:\n;; >>> segments-intersect? 0 0 1 1 1 0 0 1\n;; x 0.5\n;; y 0.5",
      "hi": "(defun segments-intersect? (x1 y1 x2 y2 x3 y3 x4 y4)\n;; एक फ़ंक्शन परिभाषित करें जो दो-आयामी स्थान में दो रेखा खंडों के सिरों का प्रतिनिधित्व करने वाले 8 वास्तविक संख्याएँ स्वीकार करता है। यदि रेखा खंड एक-दूसरे को प्रतिच्छेदित नहीं करते हैं, तो false लौटाएँ, या प्रतिच्छेदन बिंदु के x और y निर्देशांक का प्रतिनिधित्व करने वाले दो मान लौटाएँ\n;; उदाहरण:\n;; >>> segments-intersect? 0 0 1 1 1 0 0 1\n;; x 0.5\n;; y 0.5",
      "hu": "(defun segments-intersect? (x1 y1 x2 y2 x3 y3 x4 y4)\n;; Definiáljon egy függvényt, amely 8 valós számot fogad el, amelyek két vonalszakasz végpontjait képviselik a kétdimenziós térben. Ha a vonalszakaszok nem metszik egymást, térjen vissza hamissal, vagy térjen vissza két értékkel, amelyek a metszéspont x és y koordinátáit képviselik\n;; Példa:\n;; >>> segments-intersect? 0 0 1 1 1 0 0 1\n;; x 0.5\n;; y 0.5"
    },
    "prompt_bertscore": {
      "sq": "0.999999801369619",
      "hy": "0.9871565595622841",
      "bn": "0.9861344076214786",
      "bg": "0.9904889814649065",
      "zh": "0.9766939028716525",
      "fr": "0.996214104937475",
      "de": "0.999999801369619",
      "ha": "0.9487968617464455",
      "hi": "0.9850459131334074",
      "hu": "0.9937729375545562"
    },
    "canonical_solution": "(let ((denom (- (* (- x2 x1) (- y4 y3)) (* (- y2 y1) (- x4 x3)))))\n(unless (zerop denom)\n(let* ((ua (/ (- (* (- x4 x3) (- y1 y3)) (* (- y4 y3) (- x1 x3))) denom))\n(ub (/ (- (* (- x2 x1) (- y1 y3)) (* (- y2 y1) (- x1 x3))) denom))\n(x-on-segment (+ x1 (* ua (- x2 x1))))\n(y-on-segment (+ y1 (* ua (- y2 y1)))))\n(when (and (>= ua 0) (<= ua 1) (>= ub 0) (<= ub 1))\n(values x-on-segment y-on-segment))))))\n\n(defun float-near-equal (a b &optional (tolerance 1e-5))\n(<= (abs (- a b)) tolerance))",
    "instruction": {
      "en": "Write a Common Lisp function `(defun segments-intersect? (x1 y1 x2 y2 x3 y3 x4 y4)` to solve the following problem:\nDefine a function that accepts 8 real numbers representing the endpoints of two line segments in two-dimensional space. If the line segments do not intersect, return false, or return two values representing the x and y coordinates of the intersection point\nExample:\n>>> segments-intersect? 0 0 1 1 1 0 0 1\nx 0.5\ny 0.5",
      "sq": "Shkruani një funksion në Common Lisp `(defun segments-intersect? (x1 y1 x2 y2 x3 y3 x4 y4)` për të zgjidhur problemin e mëposhtëm: \nPërcaktoni një funksion që pranon 8 numra realë që përfaqësojnë pikat fundore të dy segmenteve të vijës në hapësirën dy-dimensionale. Nëse segmentet e vijës nuk ndërpriten, ktheni false, ose ktheni dy vlera që përfaqësojnë koordinatat x dhe y të pikës së ndërprerjes\nShembull:\n>>> segments-intersect? 0 0 1 1 1 0 0 1\nx 0.5\ny 0.5",
      "hy": "Գրեք Common Lisp ֆունկցիա `(defun segments-intersect? (x1 y1 x2 y2 x3 y3 x4 y4)` հետևյալ խնդիրը լուծելու համար:\nՍահմանեք ֆունկցիա, որը ընդունում է 8 իրական թիվ, որոնք ներկայացնում են երկու գծային հատվածների վերջնակետերը երկչափ տարածությունում: Եթե գծային հատվածները չեն հատվում, վերադարձնել false, կամ վերադարձնել երկու արժեք, որոնք ներկայացնում են հատման կետի x և y կոորդինատները:\nՕրինակ:\n>>> segments-intersect? 0 0 1 1 1 0 0 1\nx 0.5\ny 0.5",
      "bn": "একটি Common Lisp ফাংশন `(defun segments-intersect? (x1 y1 x2 y2 x3 y3 x4 y4)` লিখুন নিম্নলিখিত সমস্যার সমাধানের জন্য:\nএকটি ফাংশন সংজ্ঞায়িত করুন যা দুই-মাত্রিক স্থানে দুটি রেখা খণ্ডের প্রান্তবিন্দু হিসাবে ৮টি বাস্তব সংখ্যা গ্রহণ করে। যদি রেখা খণ্ডগুলি ছেদ না করে, তাহলে false ফেরত দিন, অথবা ছেদ বিন্দুর x এবং y স্থানাঙ্ক দুটি মান হিসাবে ফেরত দিন\nউদাহরণ:\n>>> segments-intersect? 0 0 1 1 1 0 0 1\nx 0.5\ny 0.5",
      "bg": "Напишете функция на Common Lisp `(defun segments-intersect? (x1 y1 x2 y2 x3 y3 x4 y4)` за решаване на следния проблем:\nДефинирайте функция, която приема 8 реални числа, представляващи крайните точки на два отсечки в двумерното пространство. Ако отсечките не се пресичат, върнете false, или върнете две стойности, представляващи x и y координатите на точката на пресичане.\nПример:\n>>> segments-intersect? 0 0 1 1 1 0 0 1\nx 0.5\ny 0.5",
      "zh": "编写一个 Common Lisp 函数 `(defun segments-intersect? (x1 y1 x2 y2 x3 y3 x4 y4)` 来解决以下问题：  \n定义一个函数，该函数接受 8 个实数，表示二维空间中两条线段的端点。如果线段不相交，则返回 false，或者返回两个值，表示交点的 x 和 y 坐标  \n示例:  \n>>> segments-intersect? 0 0 1 1 1 0 0 1  \nx 0.5  \ny 0.5",
      "fr": "Écrire une fonction Common Lisp `(defun segments-intersect? (x1 y1 x2 y2 x3 y3 x4 y4)` pour résoudre le problème suivant :\nDéfinir une fonction qui accepte 8 nombres réels représentant les extrémités de deux segments de ligne dans un espace bidimensionnel. Si les segments de ligne ne se croisent pas, retourner faux, ou retourner deux valeurs représentant les coordonnées x et y du point d'intersection.\nExemple :\n>>> segments-intersect? 0 0 1 1 1 0 0 1\nx 0.5\ny 0.5",
      "de": "Schreiben Sie eine Common Lisp-Funktion `(defun segments-intersect? (x1 y1 x2 y2 x3 y3 x4 y4)`, um das folgende Problem zu lösen:\nDefinieren Sie eine Funktion, die 8 reelle Zahlen akzeptiert, die die Endpunkte von zwei Liniensegmenten im zweidimensionalen Raum darstellen. Wenn die Liniensegmente sich nicht schneiden, geben Sie false zurück, oder geben Sie zwei Werte zurück, die die x- und y-Koordinaten des Schnittpunkts darstellen.\nBeispiel:\n>>> segments-intersect? 0 0 1 1 1 0 0 1\nx 0.5\ny 0.5",
      "ha": "Rubuta aikin Common Lisp `(defun segments-intersect? (x1 y1 x2 y2 x3 y3 x4 y4)` don warware matsalar mai zuwa: \nƘayyade wani aiki da ke karɓar lambobi guda 8 na ainihi waɗanda ke wakiltar ƙarshen sassan layuka guda biyu a cikin sararin samaniya mai girma biyu. Idan sassan layukan ba su haɗu ba, dawo da ƙarya, ko kuma dawo da ƙimar x da y waɗanda ke wakiltar wurin haɗuwar.\nMisali:\n>>> segments-intersect? 0 0 1 1 1 0 0 1\nx 0.5\ny 0.5",
      "hi": "एक Common Lisp फ़ंक्शन `(defun segments-intersect? (x1 y1 x2 y2 x3 y3 x4 y4)` लिखें ताकि निम्नलिखित समस्या का समाधान किया जा सके:\nएक फ़ंक्शन परिभाषित करें जो दो-आयामी स्थान में दो रेखा खंडों के सिरों का प्रतिनिधित्व करने वाले 8 वास्तविक संख्याएँ स्वीकार करता है। यदि रेखा खंड प्रतिच्छेद नहीं करते हैं, तो false लौटाएँ, या प्रतिच्छेदन बिंदु के x और y निर्देशांक का प्रतिनिधित्व करने वाले दो मान लौटाएँ\nउदाहरण:\n>>> segments-intersect? 0 0 1 1 1 0 0 1\nx 0.5\ny 0.5",
      "hu": "Írj egy Common Lisp függvényt `(defun segments-intersect? (x1 y1 x2 y2 x3 y3 x4 y4)` a következő probléma megoldására:\nDefiniálj egy függvényt, amely 8 valós számot fogad el, amelyek két vonalszakasz végpontjait képviselik kétdimenziós térben. Ha a vonalszakaszok nem metszik egymást, adjon vissza hamisat, vagy adjon vissza két értéket, amelyek a metszéspont x és y koordinátáit képviselik\nPélda:\n>>> segments-intersect? 0 0 1 1 1 0 0 1\nx 0.5\ny 0.5"
    },
    "instruction_bertscore": {
      "sq": "0.9898299258606327",
      "hy": "0.988203540300719",
      "bn": "0.9685687285050393",
      "bg": "0.988146533381362",
      "zh": "0.9870061963638407",
      "fr": "0.9913828181795634",
      "de": "0.9938253759751494",
      "ha": "0.9680413648433916",
      "hi": "0.9882124786678655",
      "hu": "0.9958996730442968"
    },
    "level": "hard",
    "test": "(defun check-segments-intersect? ()\n(multiple-value-bind (x y) (segments-intersect? 0 0 1 1 1 0 0 1)\n(assert (and (float-near-equal x 0.5) (float-near-equal y 0.5))))\n(assert (null (segments-intersect? 0 0 1 1 2 2 3 3))))\n\n(check-segments-intersect?)",
    "entry_point": "segments-intersect?",
    "signature": "(defun segments-intersect? (x1 y1 x2 y2 x3 y3 x4 y4)",
    "docstring": {
      "en": "Define a function that accepts 8 real numbers representing the endpoints of two line segments in two-dimensional space. If the line segments do not intersect, return false, or return two values representing the x and y coordinates of the intersection point\nExample:\n>>> segments-intersect? 0 0 1 1 1 0 0 1\nx 0.5\ny 0.5",
      "sq": "Përcaktoni një funksion që pranon 8 numra realë që përfaqësojnë pikat fundore të dy segmenteve të vijave në hapësirën dy-dimensionale. Nëse segmentet e vijave nuk ndërpriten, kthe false, ose ktheni dy vlera që përfaqësojnë koordinatat x dhe y të pikës së ndërprerjes.\nShembull:\n>>> segments-intersect? 0 0 1 1 1 0 0 1\nx 0.5\ny 0.5",
      "hy": "Սահմանեք ֆունկցիա, որը ընդունում է 8 իրական թվեր, որոնք ներկայացնում են երկու գծային հատվածների վերջնակետերը երկչափ տարածությունում։ Եթե գծային հատվածները չեն հատվում, վերադարձնել false, կամ վերադարձնել երկու արժեք, որոնք ներկայացնում են հատման կետի x և y կոորդինատները։\nՕրինակ:\n>>> segments-intersect? 0 0 1 1 1 0 0 1\nx 0.5\ny 0.5",
      "bn": "একটি ফাংশন সংজ্ঞায়িত করুন যা দুই মাত্রিক স্থানে দুটি রেখা খণ্ডের প্রান্তবিন্দুগুলিকে উপস্থাপনকারী ৮টি বাস্তব সংখ্যা গ্রহণ করে। যদি রেখা খণ্ডগুলি ছেদ না করে, তবে false ফেরত দিন, অথবা ছেদ বিন্দুর x এবং y স্থানাঙ্ক উপস্থাপনকারী দুটি মান ফেরত দিন। \nউদাহরণ:\n>>> segments-intersect? 0 0 1 1 1 0 0 1\nx 0.5\ny 0.5",
      "bg": "Определете функция, която приема 8 реални числа, представляващи краищата на два линейни сегмента в двумерно пространство. Ако линейните сегменти не се пресичат, върнете false, или върнете две стойности, представляващи x и y координатите на точката на пресичане.\nПример:\n>>> segments-intersect? 0 0 1 1 1 0 0 1\nx 0.5\ny 0.5",
      "zh": "定义一个函数，该函数接受8个实数，表示二维空间中两条线段的端点。如果线段不相交，则返回false，否则返回两个值，表示交点的x和y坐标。\n示例：\n>>> segments-intersect? 0 0 1 1 1 0 0 1\nx 0.5\ny 0.5",
      "fr": "Définir une fonction qui accepte 8 nombres réels représentant les extrémités de deux segments de ligne dans un espace bidimensionnel. Si les segments de ligne ne se croisent pas, retourner faux, ou retourner deux valeurs représentant les coordonnées x et y du point d'intersection.\n\nExemple:\n>>> segments-intersect? 0 0 1 1 1 0 0 1\nx 0.5\ny 0.5",
      "de": "Definieren Sie eine Funktion, die 8 reelle Zahlen akzeptiert, die die Endpunkte von zwei Liniensegmenten im zweidimensionalen Raum darstellen. Wenn die Liniensegmente sich nicht schneiden, geben Sie false zurück, oder geben Sie zwei Werte zurück, die die x- und y-Koordinaten des Schnittpunkts darstellen.\nBeispiel:\n>>> segments-intersect? 0 0 1 1 1 0 0 1\nx 0.5\ny 0.5",
      "ha": "Ƙirƙiri wata hanya wadda ke karɓar lambobi 8 na gaske da ke wakiltar ƙarshen sassan layi guda biyu a sararin samaniya mai girma biyu. Idan sassan layin ba su haɗu ba, dawo da ƙarya, ko kuma dawo da ƙimar x da y da ke wakiltar inda sassan suka haɗu.\n\nMisali:\n>>> segments-intersect? 0 0 1 1 1 0 0 1\nx 0.5\ny 0.5",
      "hi": "एक फ़ंक्शन परिभाषित करें जो दो-आयामी स्थान में दो रेखा खंडों के अंतिम बिंदुओं का प्रतिनिधित्व करने वाले 8 वास्तविक संख्याएँ स्वीकार करता है। यदि रेखा खंड परस्पर नहीं काटते हैं, तो false लौटाएँ, या दो मान लौटाएँ जो प्रतिच्छेदन बिंदु के x और y निर्देशांक का प्रतिनिधित्व करते हैं।\n\nउदाहरण:\n>>> segments-intersect? 0 0 1 1 1 0 0 1\nx 0.5\ny 0.5",
      "hu": "Definiáljon egy függvényt, amely 8 valós számot fogad el, amelyek két szakasz végpontjait képviselik a kétdimenziós térben. Ha a szakaszok nem metszik egymást, adjon vissza hamisat, vagy adjon vissza két értéket, amelyek a metszéspont x és y koordinátáit képviselik.\nPélda:\n>>> segments-intersect? 0 0 1 1 1 0 0 1\nx 0.5\ny 0.5"
    },
    "docstring_bertscore": {
      "sq": "0.99496174038505",
      "hy": "0.9824492181621383",
      "bn": "0.9815812033970158",
      "bg": "0.9824492181621383",
      "zh": "0.9699092849466437",
      "fr": "0.9875504436078764",
      "de": "0.99496174038505",
      "ha": "0.9445175688174299",
      "hi": "0.9875504436078764",
      "hu": "0.9793184060962664"
    }
  },
  {
    "task_id": "Common Lisp/18",
    "prompt": {
      "en": "(defun quicksort (list)\n;; Quickly sort the list\n;; Example:\n;; quicksort '(3 1 4 1 5 9 2 6 5 3 5)v\n;; 1 1 2 3 3 4 5 5 5 6 9",
      "sq": "(defun quicksort (list)\n;; Rendit shpejt listën\n;; Shembull:\n;; quicksort '(3 1 4 1 5 9 2 6 5 3 5)v\n;; 1 1 2 3 3 4 5 5 5 6 9",
      "hy": "(defun quicksort (list)\n;; Արագ տեսակավորել ցուցակը\n;; Օրինակ:\n;; quicksort '(3 1 4 1 5 9 2 6 5 3 5)v\n;; 1 1 2 3 3 4 5 5 5 6 9",
      "bn": "(defun quicksort (list)\n;; তালিকাটি দ্রুত সাজান\n;; উদাহরণ:\n;; quicksort '(3 1 4 1 5 9 2 6 5 3 5)v\n;; 1 1 2 3 3 4 5 5 5 6 9",
      "bg": "(defun quicksort (list)\n;; Бързо сортиране на списъка\n;; Пример:\n;; quicksort '(3 1 4 1 5 9 2 6 5 3 5)v\n;; 1 1 2 3 3 4 5 5 5 6 9",
      "zh": "(defun quicksort (list)\n;; 快速排序列表\n;; 示例:\n;; quicksort '(3 1 4 1 5 9 2 6 5 3 5)\n;; 1 1 2 3 3 4 5 5 5 6 9",
      "fr": "(defun quicksort (list)\n;; Trier rapidement la liste\n;; Exemple:\n;; quicksort '(3 1 4 1 5 9 2 6 5 3 5)\n;; 1 1 2 3 3 4 5 5 5 6 9",
      "de": "(defun quicksort (list)\n;; Schnelles Sortieren der Liste\n;; Beispiel:\n;; quicksort '(3 1 4 1 5 9 2 6 5 3 5)\n;; 1 1 2 3 3 4 5 5 5 6 9",
      "ha": "(defun quicksort (list)\n;; Yi saurin jera jerin\n;; Misali:\n;; quicksort '(3 1 4 1 5 9 2 6 5 3 5)v\n;; 1 1 2 3 3 4 5 5 5 6 9",
      "hi": "(defun quicksort (list)\n;; सूची को तेजी से सॉर्ट करें\n;; उदाहरण:\n;; quicksort '(3 1 4 1 5 9 2 6 5 3 5)\n;; 1 1 2 3 3 4 5 5 5 6 9",
      "hu": "(defun quicksort (list)\n;; Gyorsan rendezze a listát\n;; Példa:\n;; quicksort '(3 1 4 1 5 9 2 6 5 3 5)\n;; 1 1 2 3 3 4 5 5 5 6 9"
    },
    "prompt_bertscore": {
      "sq": "0.9859099552909092",
      "hy": "0.9859099552909092",
      "bn": "0.9657100400611852",
      "bg": "0.9680747347474056",
      "zh": "0.9499795070351272",
      "fr": "0.9859099552909092",
      "de": "0.9680747347474056",
      "ha": "0.9859099552909092",
      "hi": "0.9859099552909092",
      "hu": "0.9859099552909092"
    },
    "canonical_solution": "(if (null list)\nnil\n(let ((pivot (first list))\n(rest (rest list)))\n(append (quicksort (remove-if-not #'(lambda (x) (< x pivot)) rest))\n(list pivot)\n(quicksort (remove-if #'(lambda (x) (< x pivot)) rest))))))",
    "instruction": {
      "en": "Write a Common Lisp function `(defun quicksort (list)` to solve the following problem:\nQuickly sort the list\nExample:\nquicksort '(3 1 4 1 5 9 2 6 5 3 5)v\n1 1 2 3 3 4 5 5 5 6 9",
      "sq": "Shkruani një funksion Common Lisp `(defun quicksort (list)` për të zgjidhur problemin e mëposhtëm: \nRenditni shpejt listën \nShembull: \nquicksort '(3 1 4 1 5 9 2 6 5 3 5) \n1 1 2 3 3 4 5 5 5 6 9",
      "hy": "Գրեք Common Lisp ֆունկցիա `(defun quicksort (list)` հետևյալ խնդիրը լուծելու համար:\nԱրագ տեսակավորել ցուցակը\nՕրինակ:\nquicksort '(3 1 4 1 5 9 2 6 5 3 5)\n1 1 2 3 3 4 5 5 5 6 9",
      "bn": "একটি Common Lisp ফাংশন `(defun quicksort (list)` লিখুন নিম্নলিখিত সমস্যার সমাধানের জন্য:\nতালিকাটি দ্রুত সাজান\nউদাহরণ:\nquicksort '(3 1 4 1 5 9 2 6 5 3 5)\n1 1 2 3 3 4 5 5 5 6 9",
      "bg": "Напишете функция на Common Lisp `(defun quicksort (list)` за решаване на следния проблем:  \nБързо сортиране на списъка  \nПример:  \nquicksort '(3 1 4 1 5 9 2 6 5 3 5)  \n1 1 2 3 3 4 5 5 5 6 9",
      "zh": "编写一个 Common Lisp 函数 `(defun quicksort (list)` 来解决以下问题：\n快速排序列表\n示例：\nquicksort '(3 1 4 1 5 9 2 6 5 3 5)\n1 1 2 3 3 4 5 5 5 6 9",
      "fr": "Écrire une fonction Common Lisp `(defun quicksort (list)` pour résoudre le problème suivant :  \nTrier rapidement la liste  \nExemple :  \nquicksort '(3 1 4 1 5 9 2 6 5 3 5)  \n1 1 2 3 3 4 5 5 5 6 9",
      "de": "Schreiben Sie eine Common Lisp-Funktion `(defun quicksort (list)` um das folgende Problem zu lösen:\nDie Liste schnell sortieren\nBeispiel:\nquicksort '(3 1 4 1 5 9 2 6 5 3 5)\n1 1 2 3 3 4 5 5 5 6 9",
      "ha": "Rubuta aikin Common Lisp `(defun quicksort (list)` don warware matsalar mai zuwa:\nSaurin jera jerin\nMisali:\nquicksort '(3 1 4 1 5 9 2 6 5 3 5)\n1 1 2 3 3 4 5 5 5 6 9",
      "hi": "एक Common Lisp फ़ंक्शन `(defun quicksort (list)` लिखें ताकि निम्नलिखित समस्या का समाधान किया जा सके:\nसूची को तेजी से छांटें\nउदाहरण:\nquicksort '(3 1 4 1 5 9 2 6 5 3 5)\n1 1 2 3 3 4 5 5 5 6 9",
      "hu": "Írj egy Common Lisp függvényt `(defun quicksort (list)` a következő probléma megoldására: Gyorsan rendezd a listát Példa: quicksort '(3 1 4 1 5 9 2 6 5 3 5) 1 1 2 3 3 4 5 5 5 6 9"
    },
    "instruction_bertscore": {
      "sq": "0.9842565559991747",
      "hy": "0.9842565559991747",
      "bn": "0.9716256500691662",
      "bg": "0.9643827918551101",
      "zh": "0.9842565559991747",
      "fr": "0.9842565559991747",
      "de": "0.9716256500691662",
      "ha": "0.9532032781193235",
      "hi": "0.9716256500691662",
      "hu": "0.9842565559991747"
    },
    "level": "middle",
    "test": "(defun check-quicksort ()\n;; Test 'quicksort' function.\n(assert (equal (quicksort '(3 1 4 1 5 9 2 6 5 3 5)) '(1 1 2 3 3 4 5 5 5 6 9)))\n(assert (equal (quicksort '(5 4 3 2 1)) '(1 2 3 4 5)))\n(assert (equal (quicksort '()) '()))\n(assert (equal (quicksort '(1)) '(1))))\n\n(check-quicksort)",
    "entry_point": "quicksort",
    "signature": "(defun quicksort (list)",
    "docstring": {
      "en": "Quickly sort the list\nExample:\nquicksort '(3 1 4 1 5 9 2 6 5 3 5)v\n1 1 2 3 3 4 5 5 5 6 9",
      "sq": "Rendit shpejt listën\nShembull:\nquicksort '(3 1 4 1 5 9 2 6 5 3 5)v\n1 1 2 3 3 4 5 5 5 6 9",
      "hy": "Արագ տեսակավորել ցուցակը  \nՕրինակ:  \nquicksort '(3 1 4 1 5 9 2 6 5 3 5)  \n1 1 2 3 3 4 5 5 5 6 9",
      "bn": "তালিকাটি দ্রুত সাজান\nউদাহরণ:\nquicksort '(3 1 4 1 5 9 2 6 5 3 5)v\n1 1 2 3 3 4 5 5 5 6 9",
      "bg": "Бързо сортиране на списъка  \nПример:  \nquicksort '(3 1 4 1 5 9 2 6 5 3 5)  \n1 1 2 3 3 4 5 5 5 6 9",
      "zh": "快速排序列表  \n示例：  \nquicksort '(3 1 4 1 5 9 2 6 5 3 5)  \n1 1 2 3 3 4 5 5 5 6 9",
      "fr": "Trier rapidement la liste  \nExemple:  \nquicksort '(3 1 4 1 5 9 2 6 5 3 5)  \n1 1 2 3 3 4 5 5 5 6 9",
      "de": "Schnelles Sortieren der Liste  \nBeispiel:  \nquicksort '(3 1 4 1 5 9 2 6 5 3 5)  \n1 1 2 3 3 4 5 5 5 6 9",
      "ha": "Saurin tsara jerin\n\nMisali:\nquicksort '(3 1 4 1 5 9 2 6 5 3 5)v\n1 1 2 3 3 4 5 5 5 6 9",
      "hi": "सूची को तेजी से छांटें  \nउदाहरण:  \nquicksort '(3 1 4 1 5 9 2 6 5 3 5)  \n1 1 2 3 3 4 5 5 5 6 9",
      "hu": "Gyorsan rendezze a listát  \nPélda:  \nquicksort '(3 1 4 1 5 9 2 6 5 3 5)v  \n1 1 2 3 3 4 5 5 5 6 9"
    },
    "docstring_bertscore": {
      "sq": "0.9572060775579385",
      "hy": "0.9773452118910658",
      "bn": "0.9831472053210949",
      "bg": "0.9320469576049165",
      "zh": "0.9269493075060371",
      "fr": "0.9572060775579385",
      "de": "0.9506395557913061",
      "ha": "0.9686438107890705",
      "hi": "0.9572060775579385",
      "hu": "1"
    }
  },
  {
    "task_id": "Common Lisp/19",
    "prompt": {
      "en": "(defun enqueue-front (object queue)\n;; Define a function that accepts two input parameters, object and queue, and can insert the object into the beginning of the queue\n;; Example:\n;; >>> let ((queue '(2 3 4)) enqueue-front 1 queue\n;; 1 2 3 4",
      "sq": "(defun enqueue-front (object queue)\n;; Përkufizo një funksion që pranon dy parametra hyrës, object dhe queue, dhe mund të fusë objektin në fillim të queue\n;; Shembull:\n;; >>> let ((queue '(2 3 4)) enqueue-front 1 queue\n;; 1 2 3 4",
      "hy": "(defun enqueue-front (object queue)\n;; Սահմանեք ֆունկցիա, որը ընդունում է երկու մուտքային պարամետր՝ օբյեկտ և հերթ, և կարող է օբյեկտը տեղադրել հերթի սկզբում\n;; Օրինակ:\n;; >>> let ((queue '(2 3 4)) enqueue-front 1 queue\n;; 1 2 3 4",
      "bn": "(defun enqueue-front (object queue)\n;; একটি ফাংশন সংজ্ঞায়িত করুন যা দুটি ইনপুট প্যারামিটার গ্রহণ করে, object এবং queue, এবং queue এর শুরুতে object প্রবেশ করাতে পারে\n;; উদাহরণ:\n;; >>> let ((queue '(2 3 4)) enqueue-front 1 queue\n;; 1 2 3 4",
      "bg": "(defun enqueue-front (object queue)\n;; Дефинирайте функция, която приема два входни параметъра, object и queue, и може да вмъкне object в началото на queue\n;; Пример:\n;; >>> let ((queue '(2 3 4)) enqueue-front 1 queue\n;; 1 2 3 4",
      "zh": "(defun enqueue-front (object queue)\n;; 定义一个函数，接受两个输入参数，object 和 queue，可以将 object 插入到 queue 的开头\n;; 例子:\n;; >>> let ((queue '(2 3 4)) enqueue-front 1 queue\n;; 1 2 3 4",
      "fr": "(defun enqueue-front (object queue)\n;; Définir une fonction qui accepte deux paramètres d'entrée, object et queue, et peut insérer l'objet au début de la queue\n;; Exemple:\n;; >>> let ((queue '(2 3 4)) enqueue-front 1 queue\n;; 1 2 3 4",
      "de": "(defun enqueue-front (object queue)\n;; Definieren Sie eine Funktion, die zwei Eingabeparameter akzeptiert, object und queue, und das Objekt am Anfang der Warteschlange einfügen kann\n;; Beispiel:\n;; >>> let ((queue '(2 3 4)) enqueue-front 1 queue\n;; 1 2 3 4",
      "ha": "(defun enqueue-front (object queue)\n;; Ƙirƙiri wata aiki da ke karɓar abubuwa biyu na shigarwa, object da queue, kuma za ta iya saka object ɗin a farkon queue\n;; Misali:\n;; >>> let ((queue '(2 3 4)) enqueue-front 1 queue\n;; 1 2 3 4",
      "hi": "(defun enqueue-front (object queue)\n;; एक फ़ंक्शन परिभाषित करें जो दो इनपुट पैरामीटर, object और queue को स्वीकार करता है, और object को queue की शुरुआत में डाल सकता है\n;; उदाहरण:\n;; >>> let ((queue '(2 3 4)) enqueue-front 1 queue\n;; 1 2 3 4",
      "hu": "(defun enqueue-front (object queue)\n;; Definiálj egy függvényt, amely két bemeneti paramétert fogad, object és queue, és képes az objektumot a sor elejére beszúrni\n;; Példa:\n;; >>> let ((queue '(2 3 4)) enqueue-front 1 queue\n;; 1 2 3 4"
    },
    "prompt_bertscore": {
      "sq": "0.993475587874147",
      "hy": "0.9700086001371612",
      "bn": "0.9905797555490394",
      "bg": "0.9760002855810787",
      "zh": "0.9760002855810787",
      "fr": "0.993475587874147",
      "de": "0.993475587874147",
      "ha": "0.9669081785195877",
      "hi": "0.993475587874147",
      "hu": "0.9733132137864386"
    },
    "canonical_solution": "(cons object queue))",
    "instruction": {
      "en": "Write a Common Lisp function `(defun enqueue-front (object queue)` to solve the following problem:\nDefine a function that accepts two input parameters, object and queue, and can insert the object into the beginning of the queue\nExample:\n>>> let ((queue '(2 3 4)) enqueue-front 1 queue\n1 2 3 4",
      "sq": "Shkruani një funksion Common Lisp `(defun enqueue-front (object queue)` për të zgjidhur problemin e mëposhtëm:  \nPërcaktoni një funksion që pranon dy parametra hyrës, object dhe queue, dhe mund të fusë objektin në fillim të radhës  \nShembull:  \n>>> let ((queue '(2 3 4)) enqueue-front 1 queue  \n1 2 3 4",
      "hy": "Գրեք Common Lisp ֆունկցիա `(defun enqueue-front (object queue)` հետևյալ խնդիրը լուծելու համար: \nՍահմանեք ֆունկցիա, որը ընդունում է երկու մուտքային պարամետր՝ object և queue, և կարող է տեղադրել object-ը queue-ի սկզբում։\nՕրինակ:\n>>> let ((queue '(2 3 4)) enqueue-front 1 queue\n1 2 3 4",
      "bn": "একটি Common Lisp ফাংশন `(defun enqueue-front (object queue)` লিখুন নিম্নলিখিত সমস্যার সমাধানের জন্য:\nএকটি ফাংশন সংজ্ঞায়িত করুন যা দুটি ইনপুট প্যারামিটার গ্রহণ করে, object এবং queue, এবং queue-এর শুরুতে object সন্নিবেশ করতে পারে\nউদাহরণ:\n>>> let ((queue '(2 3 4)) enqueue-front 1 queue\n1 2 3 4",
      "bg": "Напишете функция на Common Lisp `(defun enqueue-front (object queue)` за решаване на следния проблем:  \nДефинирайте функция, която приема два входни параметъра, object и queue, и може да вмъкне обекта в началото на опашката  \nПример:  \n>>> let ((queue '(2 3 4)) enqueue-front 1 queue  \n1 2 3 4",
      "zh": "编写一个 Common Lisp 函数 `(defun enqueue-front (object queue)` 来解决以下问题：  \n定义一个函数，该函数接受两个输入参数，object 和 queue，并可以将 object 插入到 queue 的开头  \n示例:  \n>>> let ((queue '(2 3 4)) enqueue-front 1 queue  \n1 2 3 4  ",
      "fr": "Écrire une fonction Common Lisp `(defun enqueue-front (object queue)` pour résoudre le problème suivant :  \nDéfinir une fonction qui accepte deux paramètres d'entrée, object et queue, et peut insérer l'objet au début de la queue  \nExemple :  \n>>> let ((queue '(2 3 4)) enqueue-front 1 queue  \n1 2 3 4",
      "de": "Schreiben Sie eine Common Lisp-Funktion `(defun enqueue-front (object queue)`, um das folgende Problem zu lösen:  \nDefinieren Sie eine Funktion, die zwei Eingabeparameter akzeptiert, object und queue, und das Objekt am Anfang der Warteschlange einfügen kann.  \nBeispiel:  \n>>> let ((queue '(2 3 4)) enqueue-front 1 queue  \n1 2 3 4",
      "ha": "Rubuta wani aikin Common Lisp `(defun enqueue-front (object queue)` don warware matsalar mai zuwa: \n\nAyyana wata hanya da ke karɓar sigogi biyu na shigarwa, object da queue, kuma za ta iya saka object a farkon queue. \n\nMisali: \n>>> let ((queue '(2 3 4)) enqueue-front 1 queue \n1 2 3 4",
      "hi": "Common Lisp फ़ंक्शन `(defun enqueue-front (object queue)` लिखें ताकि निम्नलिखित समस्या का समाधान किया जा सके:\nएक फ़ंक्शन परिभाषित करें जो दो इनपुट पैरामीटर स्वीकार करता है, object और queue, और object को queue की शुरुआत में डाल सकता है\nउदाहरण:\n>>> let ((queue '(2 3 4)) enqueue-front 1 queue\n1 2 3 4",
      "hu": "Írj egy Common Lisp függvényt `(defun enqueue-front (object queue)` a következő probléma megoldására:  \nHatározz meg egy függvényt, amely két bemeneti paramétert fogad el, object és queue, és képes az objektumot a sor elejére beszúrni  \nPélda:  \n>>> let ((queue '(2 3 4)) enqueue-front 1 queue  \n1 2 3 4"
    },
    "instruction_bertscore": {
      "sq": "0.9857877976065728",
      "hy": "0.9683671186682888",
      "bn": "0.991984072342956",
      "bg": "0.9763758956316155",
      "zh": "0.991984072342956",
      "fr": "0.994409150665011",
      "de": "0.9808051544983125",
      "ha": "0.9681303512540953",
      "hi": "0.9791493716420058",
      "hu": "0.9742038724149991"
    },
    "level": "easy",
    "test": "(defun check-enqueue-front ()\n(let ((queue '(2 3 4)))\n(setq queue (enqueue-front 1 queue))\n(assert (equal queue '(1 2 3 4))))\n(let ((queue '()))\n(setq queue (enqueue-front 'a queue))\n(assert (equal queue '(a)))))\n\n(check-enqueue-front)",
    "entry_point": "enqueue-front",
    "signature": "(defun enqueue-front (object queue)",
    "docstring": {
      "en": "Define a function that accepts two input parameters, object and queue, and can insert the object into the beginning of the queue\nExample:\n>>> let ((queue '(2 3 4)) enqueue-front 1 queue\n1 2 3 4",
      "sq": "Përcaktoni një funksion që pranon dy parametra hyrës, objektin dhe radhën, dhe mund të fusë objektin në fillim të radhës\nShembull:\n>>> let ((queue '(2 3 4)) enqueue-front 1 queue\n1 2 3 4",
      "hy": "Սահմանեք ֆունկցիա, որը ընդունում է երկու մուտքային պարամետր՝ օբյեկտ և հերթ, և կարող է օբյեկտը տեղադրել հերթի սկզբում։\nՕրինակ:\n>>> let ((queue '(2 3 4)) enqueue-front 1 queue  \n1 2 3 4",
      "bn": "একটি ফাংশন সংজ্ঞায়িত করুন যা দুটি ইনপুট প্যারামিটার গ্রহণ করে, অবজেক্ট এবং কিউ, এবং কিউয়ের শুরুতে অবজেক্টটি সন্নিবেশ করতে পারে\n\nউদাহরণ:\n>>> let ((queue '(2 3 4)) enqueue-front 1 queue\n1 2 3 4",
      "bg": "Дефинирайте функция, която приема два входни параметъра, object и queue, и може да вмъкне object в началото на queue\nПример:\n>>> let ((queue '(2 3 4)) enqueue-front 1 queue  \n1 2 3 4",
      "zh": "定义一个函数，该函数接受两个输入参数，object 和 queue，并可以将 object 插入到 queue 的开头  \n示例：  \n>>> let ((queue '(2 3 4)) enqueue-front 1 queue  \n1 2 3 4",
      "fr": "Définir une fonction qui accepte deux paramètres d'entrée, objet et queue, et peut insérer l'objet au début de la queue\nExemple:\n>>> let ((queue '(2 3 4)) enqueue-front 1 queue  \n1 2 3 4",
      "de": "Definieren Sie eine Funktion, die zwei Eingabeparameter akzeptiert, Objekt und Warteschlange, und das Objekt am Anfang der Warteschlange einfügen kann\nBeispiel:\n>>> let ((queue '(2 3 4)) enqueue-front 1 queue  \n1 2 3 4",
      "ha": "Ƙirƙiri wata aiki da ke karɓar abubuwa biyu na shigarwa, object da queue, kuma za ta iya saka object ɗin a farkon queue\nMisali:\n>>> let ((queue '(2 3 4)) enqueue-front 1 queue\n1 2 3 4",
      "hi": "एक फ़ंक्शन परिभाषित करें जो दो इनपुट पैरामीटर स्वीकार करता है, object और queue, और object को queue की शुरुआत में डाल सकता है।\nउदाहरण:\n>>> let ((queue '(2 3 4)) enqueue-front 1 queue\n1 2 3 4",
      "hu": "Definiáljon egy függvényt, amely két bemeneti paramétert fogad, objektumot és sort, és képes az objektumot a sor elejére beszúrni.\nPélda:\n>>> let ((queue '(2 3 4)) enqueue-front 1 queue\n1 2 3 4"
    },
    "docstring_bertscore": {
      "sq": "0.9782726171401177",
      "hy": "0.9538889501946559",
      "bn": "0.9747395785526501",
      "bg": "1",
      "zh": "0.9918849557828197",
      "fr": "0.9918849557828197",
      "de": "0.9918849557828197",
      "ha": "1",
      "hi": "0.9804913184962775",
      "hu": "0.9438072665748491"
    }
  },
  {
    "task_id": "Common Lisp/20",
    "prompt": {
      "en": "(defun move-first-instance-to-front (object queue)\n;; Define a function that takes two input parameters, object and queue, and can destructively move the first instance of object (eql equivalently) to the beginning of the queue\n;; Example:\n;; >>> move-first-instance-to-front 'b '(a b c d)\n;; b a c d",
      "sq": "(defun move-first-instance-to-front (object queue)\n;; Përkufizo një funksion që merr dy parametra hyrës, object dhe queue, dhe mund të lëvizë në mënyrë destruktive instancën e parë të object (eql ekuivalent) në fillim të queue\n;; Shembull:\n;; >>> move-first-instance-to-front 'b '(a b c d)\n;; b a c d",
      "hy": "(defun move-first-instance-to-front (object queue)\n;; Սահմանել ֆունկցիա, որը ընդունում է երկու մուտքային պարամետր՝ object և queue, և կարող է կործանարար կերպով տեղափոխել object-ի առաջին օրինակը (eql համարժեքությամբ) դեպի queue-ի սկիզբ\n;; Օրինակ:\n;; >>> move-first-instance-to-front 'b '(a b c d)\n;; b a c d",
      "bn": "(defun move-first-instance-to-front (object queue)\n;; একটি ফাংশন সংজ্ঞায়িত করুন যা দুটি ইনপুট প্যারামিটার, object এবং queue গ্রহণ করে এবং queue এর শুরুতে object এর প্রথম instance (eql সমতুল্য) ধ্বংসাত্মকভাবে সরাতে পারে\n;; উদাহরণ:\n;; >>> move-first-instance-to-front 'b '(a b c d)\n;; b a c d",
      "bg": "(defun move-first-instance-to-front (object queue)\n;; Определете функция, която приема два входни параметъра, object и queue, и може разрушително да премести първия екземпляр на object (еквивалентно на eql) в началото на queue\n;; Пример:\n;; >>> move-first-instance-to-front 'b '(a b c d)\n;; b a c d",
      "zh": "(defun move-first-instance-to-front (object queue)\n;; 定义一个函数，该函数接受两个输入参数，object 和 queue，并且可以破坏性地将 object 的第一个实例（等价于 eql）移动到 queue 的开头\n;; 例子:\n;; >>> move-first-instance-to-front 'b '(a b c d)\n;; b a c d",
      "fr": "(defun move-first-instance-to-front (object queue)\n;; Définir une fonction qui prend deux paramètres d'entrée, object et queue, et peut déplacer de manière destructive la première instance de object (équivalent eql) au début de la queue\n;; Exemple:\n;; >>> move-first-instance-to-front 'b '(a b c d)\n;; b a c d",
      "de": "(defun move-first-instance-to-front (object queue)\n;; Definiere eine Funktion, die zwei Eingabeparameter, object und queue, nimmt und die erste Instanz von object (eql äquivalent) destruktiv an den Anfang der queue verschieben kann\n;; Beispiel:\n;; >>> move-first-instance-to-front 'b '(a b c d)\n;; b a c d",
      "ha": "(defun move-first-instance-to-front (object queue)\n;; Ƙirƙiri wata aiki da ke ɗaukar sigogi biyu na shigarwa, object da queue, kuma zai iya motsa farkon samfurin object (eql daidai) zuwa farkon queue cikin lalacewa\n;; Misali:\n;; >>> move-first-instance-to-front 'b '(a b c d)\n;; b a c d",
      "hi": "(defun move-first-instance-to-front (object queue)\n;; एक फ़ंक्शन परिभाषित करें जो दो इनपुट पैरामीटर लेता है, object और queue, और विनाशकारी रूप से object के पहले उदाहरण (eql समकक्ष) को queue की शुरुआत में ले जा सकता है\n;; उदाहरण:\n;; >>> move-first-instance-to-front 'b '(a b c d)\n;; b a c d",
      "hu": "(defun move-first-instance-to-front (object queue)\n;; Definiálj egy függvényt, amely két bemeneti paramétert vesz, object és queue, és képes romboló módon az object első példányát (eql egyenértékűen) a sor elejére mozgatni\n;; Példa:\n;; >>> move-first-instance-to-front 'b '(a b c d)\n;; b a c d"
    },
    "prompt_bertscore": {
      "sq": "0.9795231940191134",
      "hy": "0.9719084997317599",
      "bn": "0.967940659240207",
      "bg": "0.9683037555767388",
      "zh": "0.9663456572804968",
      "fr": "0.9825948142314369",
      "de": "0.9825948142314369",
      "ha": "0.9517858517202585",
      "hi": "0.9674017750164593",
      "hu": "0.9551186708836429"
    },
    "canonical_solution": "(cond ((null queue) nil) \n((eql (first queue) object) queue) \n(t \n(let ((prev nil)\n(current queue))\n(loop while (and current (not (eql (first current) object)))\ndo (setq prev current)\n(setq current (rest current)))\n(if current \n(progn\n(when prev (setf (rest prev) (rest current))) \n(cons object (if prev queue (rest current)))) \nqueue)))))",
    "instruction": {
      "en": "Write a Common Lisp function `(defun move-first-instance-to-front (object queue)` to solve the following problem:\nDefine a function that takes two input parameters, object and queue, and can destructively move the first instance of object (eql equivalently) to the beginning of the queue\nExample:\n>>> move-first-instance-to-front 'b '(a b c d)\nb a c d",
      "sq": "Shkruani një funksion Common Lisp `(defun move-first-instance-to-front (object queue)` për të zgjidhur problemin e mëposhtëm: \nPërcaktoni një funksion që merr dy parametra hyrës, object dhe queue, dhe mund të lëvizë në mënyrë destruktive instancën e parë të object (eql ekuivalent) në fillim të queue \nShembull: \n>>> move-first-instance-to-front 'b '(a b c d) \nb a c d",
      "hy": "Գրեք Common Lisp ֆունկցիա `(defun move-first-instance-to-front (object queue)` հետևյալ խնդիրը լուծելու համար:\nՍահմանեք ֆունկցիա, որը ընդունում է երկու մուտքային պարամետր՝ object և queue, և կարող է քայքայիչ կերպով տեղափոխել object-ի առաջին instance-ը (eql համարժեք) queue-ի սկիզբ:\nՕրինակ:\n>>> move-first-instance-to-front 'b '(a b c d)\nb a c d",
      "bn": "একটি Common Lisp ফাংশন `(defun move-first-instance-to-front (object queue)` লিখুন নিম্নলিখিত সমস্যার সমাধানের জন্য:\nএকটি ফাংশন সংজ্ঞায়িত করুন যা দুটি ইনপুট প্যারামিটার গ্রহণ করে, object এবং queue, এবং queue এর শুরুতে object এর প্রথম instance (eql সমতুল্য) ধ্বংসাত্মকভাবে সরাতে সক্ষম\nউদাহরণ:\n>>> move-first-instance-to-front 'b '(a b c d)\nb a c d",
      "bg": "Напишете функция на Common Lisp `(defun move-first-instance-to-front (object queue)` за решаване на следния проблем:  \nДефинирайте функция, която приема два входни параметъра, object и queue, и може разрушително да премести първия екземпляр на object (еквивалентно на eql) в началото на queue  \nПример:  \n>>> move-first-instance-to-front 'b '(a b c d)  \nb a c d",
      "zh": "编写一个 Common Lisp 函数 `(defun move-first-instance-to-front (object queue)` 来解决以下问题：\n定义一个函数，该函数接受两个输入参数，object 和 queue，并且可以破坏性地将 object 的第一个实例（等价于 eql）移动到队列的开头\n示例:\n>>> move-first-instance-to-front 'b '(a b c d)\nb a c d",
      "fr": "Écrire une fonction Common Lisp `(defun move-first-instance-to-front (object queue)` pour résoudre le problème suivant :  \nDéfinir une fonction qui prend deux paramètres d'entrée, object et queue, et peut déplacer de manière destructive la première instance de object (équivalent à eql) au début de la queue  \nExemple :  \n>>> move-first-instance-to-front 'b '(a b c d)  \nb a c d",
      "de": "Schreiben Sie eine Common Lisp-Funktion `(defun move-first-instance-to-front (object queue)`, um das folgende Problem zu lösen:\nDefinieren Sie eine Funktion, die zwei Eingabeparameter, object und queue, nimmt und die erste Instanz von object (eql äquivalent) destruktiv an den Anfang der queue verschieben kann.\nBeispiel:\n>>> move-first-instance-to-front 'b '(a b c d)\nb a c d",
      "ha": "Rubuta aikin Common Lisp `(defun move-first-instance-to-front (object queue)` don warware matsalar mai zuwa: Fayyace wani aiki wanda ke ɗaukar sigogi biyu na shigarwa, object da queue, kuma zai iya motsa farkon samfurin object (eql daidai) zuwa farkon queue din cikin lalata. Misali: >>> move-first-instance-to-front 'b '(a b c d) b a c d",
      "hi": "कॉमन लिस्प फ़ंक्शन `(defun move-first-instance-to-front (object queue)` लिखें ताकि निम्नलिखित समस्या का समाधान किया जा सके:\nएक फ़ंक्शन परिभाषित करें जो दो इनपुट पैरामीटर लेता है, object और queue, और विनाशकारी रूप से object का पहला उदाहरण (eql समकक्ष) को queue की शुरुआत में ले जा सकता है\nउदाहरण:\n>>> move-first-instance-to-front 'b '(a b c d)\nb a c d",
      "hu": "Írj egy Common Lisp függvényt `(defun move-first-instance-to-front (object queue)` a következő probléma megoldására:\nHatározz meg egy függvényt, amely két bemeneti paramétert vesz fel, object és queue, és képes destruktívan az object első példányát (eql ekvivalensen) a sor elejére mozgatni\nPélda:\n>>> move-first-instance-to-front 'b '(a b c d)\nb a c d"
    },
    "instruction_bertscore": {
      "sq": "0.9715406362660833",
      "hy": "0.9737503992550964",
      "bn": "0.9634394961755753",
      "bg": "0.9688235712839071",
      "zh": "0.9580019894947454",
      "fr": "0.97074154624318",
      "de": "0.9716967597455767",
      "ha": "0.9529972984141902",
      "hi": "0.9652468340126118",
      "hu": "0.9632460301844474"
    },
    "level": "hard",
    "test": "(defun check-move-first-instance-to-front ()\n(assert (equal (move-first-instance-to-front 'b '(a b c d)) '(b a c d)))\n(assert (equal (move-first-instance-to-front 'a '(a b c d)) '(a b c d)))\n(assert (equal (move-first-instance-to-front 'e '(a b c d)) '(a b c d)))\n(assert (equal (move-first-instance-to-front 'd '(a b c d)) '(d a b c))))\n\n(check-move-first-instance-to-front)",
    "entry_point": "move-first-instance-to-front",
    "signature": "(defun move-first-instance-to-front (object queue)",
    "docstring": {
      "en": "Define a function that takes two input parameters, object and queue, and can destructively move the first instance of object (eql equivalently) to the beginning of the queue\nExample:\n>>> move-first-instance-to-front 'b '(a b c d)\nb a c d",
      "sq": "Përcaktoni një funksion që merr dy parametra hyrës, objektin dhe radhën, dhe mund të zhvendosë në mënyrë destruktive instancën e parë të objektit (ekuivalent me eql) në fillim të radhës.\nShembull:\n>>> move-first-instance-to-front 'b '(a b c d)\nb a c d",
      "hy": "Սահմանեք ֆունկցիա, որը ընդունում է երկու մուտքային պարամետր՝ օբյեկտ և հերթ, և կարող է կործանարար կերպով տեղափոխել օբյեկտի առաջին օրինակը (հավասարապես eql) հերթի սկիզբ:\nՕրինակ:\n>>> move-first-instance-to-front 'b '(a b c d)\nb a c d",
      "bn": "একটি ফাংশন সংজ্ঞায়িত করুন যা দুটি ইনপুট প্যারামিটার গ্রহণ করে, object এবং queue, এবং queue-এর শুরুতে object-এর প্রথম instance (eql সমতুল্য) ধ্বংসাত্মকভাবে সরাতে পারে।\n\nউদাহরণ:\n>>> move-first-instance-to-front 'b '(a b c d)\nb a c d",
      "bg": "Определете функция, която приема два входни параметъра, обект и опашка, и може разрушително да премести първия екземпляр на обекта (еквивалентен на eql) в началото на опашката.\nПример:\n>>> move-first-instance-to-front 'b '(a b c d)\nb a c d",
      "zh": "定义一个函数，该函数接受两个输入参数，object 和 queue，并且可以破坏性地将 object 的第一个实例（等价于 eql）移动到队列的开头。\n示例：\n>>> move-first-instance-to-front 'b '(a b c d)\nb a c d",
      "fr": "Définir une fonction qui prend deux paramètres d'entrée, objet et queue, et peut déplacer de manière destructive la première instance de l'objet (équivalent eql) au début de la queue.\nExemple:\n>>> move-first-instance-to-front 'b '(a b c d)  \nb a c d",
      "de": "Definieren Sie eine Funktion, die zwei Eingabeparameter, object und queue, übernimmt und die erste Instanz von object (äquivalent zu eql) destruktiv an den Anfang der queue verschieben kann.\nBeispiel:\n>>> move-first-instance-to-front 'b '(a b c d)  \nb a c d",
      "ha": "Ƙirƙiri wata aiki da ke ɗaukar sigogi biyu na shigarwa, object da queue, kuma zai iya motsa farkon samfurin object (eql daidai) zuwa farkon queue cikin lalacewa\nMisali:\n>>> move-first-instance-to-front 'b '(a b c d)\nb a c d",
      "hi": "एक फ़ंक्शन परिभाषित करें जो दो इनपुट पैरामीटर लेता है, object और queue, और object के पहले उदाहरण को (eql के समकक्ष) queue की शुरुआत में विनाशकारी रूप से स्थानांतरित कर सकता है।\n\nउदाहरण:\n>>> move-first-instance-to-front 'b '(a b c d)\nb a c d",
      "hu": "Határozz meg egy függvényt, amely két bemeneti paramétert vesz, objektumot és sort, és képes az objektum első példányát (eql egyenértékűen) romboló módon a sor elejére mozgatni.\nPélda:\n>>> move-first-instance-to-front 'b '(a b c d)\nb a c d"
    },
    "docstring_bertscore": {
      "sq": "0.9166010619148814",
      "hy": "0.9055810483750659",
      "bn": "0.9438473899118182",
      "bg": "0.9155435537662517",
      "zh": "0.9441236847718377",
      "fr": "0.9527760241697174",
      "de": "0.9513669402466559",
      "ha": "1",
      "hi": "0.9384080955575588",
      "hu": "0.9104167050013603"
    }
  },
  {
    "task_id": "Common Lisp/21",
    "prompt": {
      "en": "(defun find-substring-index (haystack needle)\n;; Finds the first occurrence of the substring 'needle' within the string 'haystack'.\n;; Returns the index of the first character of the first occurrence of 'needle'.\n;; If 'needle' is not a part of 'haystack', returns -1.\n;; Example:\n;; (find-substring-index \"apple pie\" \"pie\") ;; Returns 6\n;; (find-substring-index \"hello world\" \"bye\") ;; Returns -1",
      "sq": "(defun find-substring-index (haystack needle)\n;; Gjen ndodhjen e parë të nënvargut 'needle' brenda vargut 'haystack'.\n;; Kthen indeksin e karakterit të parë të ndodhjes së parë të 'needle'.\n;; Nëse 'needle' nuk është pjesë e 'haystack', kthen -1.\n;; Shembull:\n;; (find-substring-index \"apple pie\" \"pie\") ;; Kthen 6\n;; (find-substring-index \"hello world\" \"bye\") ;; Kthen -1",
      "hy": "(defun find-substring-index (haystack needle)\n;; Գտնում է 'needle' ենթատողի առաջին հանդիպումը 'haystack' տողի մեջ:\n;; Վերադարձնում է 'needle'-ի առաջին հանդիպման առաջին սիմվոլի ինդեքսը:\n;; Եթե 'needle'-ը մաս չէ 'haystack'-ի, վերադարձնում է -1:\n;; Օրինակ:\n;; (find-substring-index \"apple pie\" \"pie\") ;; Վերադարձնում է 6\n;; (find-substring-index \"hello world\" \"bye\") ;; Վերադարձնում է -1",
      "bn": "(defun find-substring-index (haystack needle)\n;; স্ট্রিং 'haystack' এর মধ্যে সাবস্ট্রিং 'needle' এর প্রথম অবস্থান খুঁজে বের করে।\n;; 'needle' এর প্রথম অবস্থানের প্রথম অক্ষরের সূচক প্রদান করে।\n;; যদি 'needle' 'haystack' এর অংশ না হয়, তাহলে -1 প্রদান করে।\n;; উদাহরণ:\n;; (find-substring-index \"apple pie\" \"pie\") ;; 6 প্রদান করে\n;; (find-substring-index \"hello world\" \"bye\") ;; -1 প্রদান করে",
      "bg": "(defun find-substring-index (haystack needle)\n;; Намира първото появяване на подниз 'needle' в низа 'haystack'.\n;; Връща индекса на първия символ от първото появяване на 'needle'.\n;; Ако 'needle' не е част от 'haystack', връща -1.\n;; Пример:\n;; (find-substring-index \"apple pie\" \"pie\") ;; Връща 6\n;; (find-substring-index \"hello world\" \"bye\") ;; Връща -1",
      "zh": "(defun find-substring-index (haystack needle)\n;; 查找字符串 'haystack' 中子字符串 'needle' 的第一次出现。\n;; 返回 'needle' 第一次出现的第一个字符的索引。\n;; 如果 'needle' 不是 'haystack' 的一部分，则返回 -1。\n;; 示例:\n;; (find-substring-index \"apple pie\" \"pie\") ;; 返回 6\n;; (find-substring-index \"hello world\" \"bye\") ;; 返回 -1",
      "fr": "(defun find-substring-index (haystack needle)\n;; Trouve la première occurrence de la sous-chaîne 'needle' dans la chaîne 'haystack'.\n;; Renvoie l'index du premier caractère de la première occurrence de 'needle'.\n;; Si 'needle' ne fait pas partie de 'haystack', renvoie -1.\n;; Exemple:\n;; (find-substring-index \"apple pie\" \"pie\") ;; Renvoie 6\n;; (find-substring-index \"hello world\" \"bye\") ;; Renvoie -1",
      "de": "(defun find-substring-index (haystack needle)\n;; Findet das erste Vorkommen des Teilstrings 'needle' innerhalb des Strings 'haystack'.\n;; Gibt den Index des ersten Zeichens des ersten Vorkommens von 'needle' zurück.\n;; Wenn 'needle' kein Teil von 'haystack' ist, wird -1 zurückgegeben.\n;; Beispiel:\n;; (find-substring-index \"apple pie\" \"pie\") ;; Gibt 6 zurück\n;; (find-substring-index \"hello world\" \"bye\") ;; Gibt -1 zurück",
      "ha": "(defun find-substring-index (haystack needle)\n;; Nemi farkon bayyanar substring 'needle' a cikin igiyar 'haystack'.\n;; Mayar da index na farkon hali na farkon bayyanar 'needle'.\n;; Idan 'needle' ba wani ɓangare ne na 'haystack', zai mayar da -1.\n;; Misali:\n;; (find-substring-index \"apple pie\" \"pie\") ;; Mayar da 6\n;; (find-substring-index \"hello world\" \"bye\") ;; Mayar da -1",
      "hi": "(defun find-substring-index (haystack needle)\n;; स्ट्रिंग 'haystack' के भीतर सबस्ट्रिंग 'needle' की पहली उपस्थिति को खोजता है।\n;; 'needle' की पहली उपस्थिति के पहले अक्षर का इंडेक्स लौटाता है।\n;; यदि 'needle' 'haystack' का हिस्सा नहीं है, तो -1 लौटाता है।\n;; उदाहरण:\n;; (find-substring-index \"apple pie\" \"pie\") ;; 6 लौटाता है\n;; (find-substring-index \"hello world\" \"bye\") ;; -1 लौटाता है",
      "hu": "(defun find-substring-index (haystack needle)\n;; Megkeresi a 'needle' részsztring első előfordulását a 'haystack' sztringben.\n;; Visszaadja a 'needle' első előfordulásának első karakterének indexét.\n;; Ha a 'needle' nem része a 'haystack'-nek, -1-et ad vissza.\n;; Példa:\n;; (find-substring-index \"apple pie\" \"pie\") ;; Visszaadja: 6\n;; (find-substring-index \"hello world\" \"bye\") ;; Visszaadja: -1"
    },
    "prompt_bertscore": {
      "sq": "0.9965891190968689",
      "hy": "0.984611309859703",
      "bn": "0.987503368207571",
      "bg": "0.9948513018931947",
      "zh": "0.9846194537053256",
      "fr": "0.9948513018931947",
      "de": "0.9928971762045734",
      "ha": "0.9889058973280583",
      "hi": "0.9825336360740782",
      "hu": "0.9789320700051536"
    },
    "canonical_solution": "(let ((hay-len (length haystack))\n(need-len (length needle)))\n(if (zerop need-len)\n0\n(if (> need-len hay-len)\n-1\n(loop for i below (1+ (- hay-len need-len)) ;; Adjusted loop condition\nwhen (string= (subseq haystack i (min (+ i need-len) hay-len)) needle) ;; Ensure subseq does not exceed bounds\nreturn i\nfinally (return -1))))))",
    "instruction": {
      "en": "Write a Common Lisp function `(defun find-substring-index (haystack needle)` to solve the following problem:\nFinds the first occurrence of the substring 'needle' within the string 'haystack'.\nReturns the index of the first character of the first occurrence of 'needle'.\nIf 'needle' is not a part of 'haystack', returns -1.\nExample:\n(find-substring-index \"apple pie\" \"pie\") Returns 6\n(find-substring-index \"hello world\" \"bye\") Returns -1",
      "sq": "Shkruani një funksion Common Lisp `(defun find-substring-index (haystack needle)` për të zgjidhur problemin e mëposhtëm:\nGjen paraqitjen e parë të nënvargut 'needle' brenda vargut 'haystack'.\nKthen indeksin e karakterit të parë të paraqitjes së parë të 'needle'.\nNëse 'needle' nuk është pjesë e 'haystack', kthen -1.\nShembull:\n(find-substring-index \"apple pie\" \"pie\") Kthen 6\n(find-substring-index \"hello world\" \"bye\") Kthen -1",
      "hy": "Գրեք Common Lisp ֆունկցիա `(defun find-substring-index (haystack needle)` հետևյալ խնդիրը լուծելու համար:\nԳտնում է 'needle' ենթատողի առաջին հանդիպումը 'haystack' տողի մեջ:\nՎերադարձնում է 'needle'-ի առաջին հանդիպման առաջին սիմվոլի ինդեքսը:\nԵթե 'needle'-ը 'haystack'-ի մաս չէ, վերադարձնում է -1:\nՕրինակ:\n(find-substring-index \"apple pie\" \"pie\") Վերադարձնում է 6\n(find-substring-index \"hello world\" \"bye\") Վերադարձնում է -1",
      "bn": "একটি Common Lisp ফাংশন `(defun find-substring-index (haystack needle)` লিখুন নিম্নলিখিত সমস্যার সমাধান করতে:\nস্ট্রিং 'haystack' এর মধ্যে সাবস্ট্রিং 'needle' এর প্রথম উপস্থিতি খুঁজে বের করে।\n'needle' এর প্রথম উপস্থিতির প্রথম অক্ষরের সূচক প্রদান করে।\nযদি 'needle' 'haystack' এর অংশ না হয়, তাহলে -1 প্রদান করে।\nউদাহরণ:\n(find-substring-index \"apple pie\" \"pie\") প্রদান করে 6\n(find-substring-index \"hello world\" \"bye\") প্রদান করে -1",
      "bg": "Напишете функция на Common Lisp `(defun find-substring-index (haystack needle)` за решаване на следния проблем:\nНамира първото срещане на подниз 'needle' в низа 'haystack'.\nВръща индекса на първия символ от първото срещане на 'needle'.\nАко 'needle' не е част от 'haystack', връща -1.\nПример:\n(find-substring-index \"apple pie\" \"pie\") Връща 6\n(find-substring-index \"hello world\" \"bye\") Връща -1",
      "zh": "编写一个 Common Lisp 函数 `(defun find-substring-index (haystack needle)` 来解决以下问题：\n查找字符串 'haystack' 中子字符串 'needle' 的第一次出现。\n返回 'needle' 第一次出现的第一个字符的索引。\n如果 'needle' 不是 'haystack' 的一部分，则返回 -1。\n示例：\n(find-substring-index \"apple pie\" \"pie\") 返回 6\n(find-substring-index \"hello world\" \"bye\") 返回 -1",
      "fr": "Écrire une fonction Common Lisp `(defun find-substring-index (haystack needle)` pour résoudre le problème suivant :\nTrouve la première occurrence de la sous-chaîne 'needle' dans la chaîne 'haystack'.\nRenvoie l'index du premier caractère de la première occurrence de 'needle'.\nSi 'needle' ne fait pas partie de 'haystack', renvoie -1.\nExemple :\n(find-substring-index \"apple pie\" \"pie\") Renvoie 6\n(find-substring-index \"hello world\" \"bye\") Renvoie -1",
      "de": "Schreiben Sie eine Common Lisp-Funktion `(defun find-substring-index (haystack needle)` um das folgende Problem zu lösen:\nFindet das erste Vorkommen des Teilstrings 'needle' innerhalb des Strings 'haystack'.\nGibt den Index des ersten Zeichens des ersten Vorkommens von 'needle' zurück.\nWenn 'needle' kein Teil von 'haystack' ist, wird -1 zurückgegeben.\nBeispiel:\n(find-substring-index \"apple pie\" \"pie\") Gibt 6 zurück\n(find-substring-index \"hello world\" \"bye\") Gibt -1 zurück",
      "ha": "Rubuta aikin Common Lisp `(defun find-substring-index (haystack needle)` don warware matsalar mai zuwa:\nNemo bayyanar farko na ƙaramin rubutu 'needle' a cikin rubutu 'haystack'.\nDawo da lambar adireshin harafin farko na bayyanar farko na 'needle'.\nIdan 'needle' ba ya cikin 'haystack', dawo da -1.\nMisali:\n(find-substring-index \"apple pie\" \"pie\") Dawo da 6\n(find-substring-index \"hello world\" \"bye\") Dawo da -1",
      "hi": "कॉमन लिस्प फ़ंक्शन `(defun find-substring-index (haystack needle)` लिखें ताकि निम्नलिखित समस्या का समाधान किया जा सके:\nस्ट्रिंग 'haystack' के भीतर सबस्ट्रिंग 'needle' की पहली उपस्थिति को खोजता है।\n'needle' की पहली उपस्थिति के पहले वर्ण का इंडेक्स लौटाता है।\nयदि 'needle' 'haystack' का हिस्सा नहीं है, तो -1 लौटाता है।\nउदाहरण:\n(find-substring-index \"apple pie\" \"pie\") 6 लौटाता है\n(find-substring-index \"hello world\" \"bye\") -1 लौटाता है",
      "hu": "Írj egy Common Lisp függvényt `(defun find-substring-index (haystack needle)` a következő probléma megoldására:\nMegkeresi a 'needle' részsztring első előfordulását a 'haystack' sztringben.\nVisszaadja a 'needle' első előfordulásának első karakterének indexét.\nHa a 'needle' nem része a 'haystack'-nek, akkor -1-et ad vissza.\nPélda:\n(find-substring-index \"apple pie\" \"pie\") Visszaadja 6\n(find-substring-index \"hello world\" \"bye\") Visszaadja -1"
    },
    "instruction_bertscore": {
      "sq": "0.9976909218204695",
      "hy": "0.9816689980254333",
      "bn": "0.9850683583664643",
      "bg": "0.9933758754228675",
      "zh": "0.985908763508623",
      "fr": "0.9880013345728255",
      "de": "0.9920621340827027",
      "ha": "0.9808210449287953",
      "hi": "0.9942883833933418",
      "hu": "0.978251363689347"
    },
    "level": "middle",
    "test": "(defun test-find-substring-index ()\n(assert (equal (find-substring-index \"apple pie\" \"pie\") 6))\n(assert (equal (find-substring-index \"hello world\" \"bye\") -1))\n(assert (equal (find-substring-index \"common lisp\" \"lisp\") 7))\n(assert (equal (find-substring-index \"quick brown fox\" \"brown\") 6))\n(assert (equal (find-substring-index \"abcdef\" \"de\") 3))\n(assert (equal (find-substring-index \"abcdef\" \"xyz\") -1)))\n\n(test-find-substring-index)",
    "entry_point": "find-substring-index",
    "signature": "(defun find-substring-index (haystack needle)",
    "docstring": {
      "en": "Finds the first occurrence of the substring 'needle' within the string 'haystack'.\nReturns the index of the first character of the first occurrence of 'needle'.\nIf 'needle' is not a part of 'haystack', returns -1.\nExample:\n(find-substring-index \"apple pie\" \"pie\") Returns 6\n(find-substring-index \"hello world\" \"bye\") Returns -1",
      "sq": "Gjen ndodhjen e parë të nënvargut 'needle' brenda vargut 'haystack'.\nKthen indeksin e karakterit të parë të ndodhjes së parë të 'needle'.\nNëse 'needle' nuk është pjesë e 'haystack', kthen -1.\nShembull:\n(find-substring-index \"apple pie\" \"pie\") Kthen 6\n(find-substring-index \"hello world\" \"bye\") Kthen -1",
      "hy": "Գտնում է 'needle' ենթատողի առաջին հանդիպումը 'haystack' տողի մեջ: Վերադարձնում է 'needle'-ի առաջին հանդիպման առաջին սիմվոլի ինդեքսը: Եթե 'needle'-ը 'haystack'-ի մաս չէ, վերադարձնում է -1: Օրինակ: (find-substring-index \"apple pie\" \"pie\") Վերադարձնում է 6 (find-substring-index \"hello world\" \"bye\") Վերադարձնում է -1",
      "bn": "স্ট্রিং 'haystack' এর মধ্যে 'needle' সাবস্ট্রিং এর প্রথম উপস্থিতি খুঁজে বের করে।\n'needle' এর প্রথম উপস্থিতির প্রথম অক্ষরের সূচক প্রদান করে।\nযদি 'needle' 'haystack' এর অংশ না হয়, তাহলে -1 প্রদান করে।\nউদাহরণ:\n(find-substring-index \"apple pie\" \"pie\") Returns 6  \n(find-substring-index \"hello world\" \"bye\") Returns -1",
      "bg": "Намира първото срещане на подниз 'needle' в низа 'haystack'.\nВръща индекса на първия символ от първото срещане на 'needle'.\nАко 'needle' не е част от 'haystack', връща -1.\nПример:\n(find-substring-index \"apple pie\" \"pie\") Връща 6\n(find-substring-index \"hello world\" \"bye\") Връща -1",
      "zh": "查找字符串 'haystack' 中子字符串 'needle' 的第一次出现。\n返回 'needle' 第一次出现的第一个字符的索引。\n如果 'needle' 不是 'haystack' 的一部分，则返回 -1。\n示例：\n(find-substring-index \"apple pie\" \"pie\") 返回 6\n(find-substring-index \"hello world\" \"bye\") 返回 -1",
      "fr": "Trouve la première occurrence de la sous-chaîne 'needle' dans la chaîne 'haystack'.\nRenvoie l'indice du premier caractère de la première occurrence de 'needle'.\nSi 'needle' ne fait pas partie de 'haystack', renvoie -1.\nExemple :\n(find-substring-index \"apple pie\" \"pie\") Renvoie 6\n(find-substring-index \"hello world\" \"bye\") Renvoie -1",
      "de": "Findet das erste Vorkommen des Teilstrings 'needle' innerhalb des Strings 'haystack'.\nGibt den Index des ersten Zeichens des ersten Vorkommens von 'needle' zurück.\nWenn 'needle' kein Teil von 'haystack' ist, wird -1 zurückgegeben.\nBeispiel:\n(find-substring-index \"apple pie\" \"pie\") Gibt 6 zurück\n(find-substring-index \"hello world\" \"bye\") Gibt -1 zurück",
      "ha": "Yana samun bayyanar farko na ƙaramin kirtani 'needle' a cikin kirtani 'haystack'.\nYana mayar da lambar adireshin harafin farko na bayyanar farko na 'needle'.\nIdan 'needle' ba ya cikin 'haystack', yana mayar da -1.\nMisali:\n(find-substring-index \"apple pie\" \"pie\") Yana mayar da 6\n(find-substring-index \"hello world\" \"bye\") Yana mayar da -1",
      "hi": "पहली बार 'haystack' स्ट्रिंग के भीतर 'needle' सबस्ट्रिंग की उपस्थिति को खोजता है।\n'needle' की पहली उपस्थिति के पहले अक्षर का इंडेक्स लौटाता है।\nयदि 'needle', 'haystack' का हिस्सा नहीं है, तो -1 लौटाता है।\nउदाहरण:\n(find-substring-index \"apple pie\" \"pie\") 6 लौटाता है\n(find-substring-index \"hello world\" \"bye\") -1 लौटाता है",
      "hu": "Megkeresi a 'needle' részsztring első előfordulását a 'haystack' sztringben.\nVisszaadja a 'needle' első előfordulásának első karakterének indexét.\nHa a 'needle' nem része a 'haystack'-nek, -1-et ad vissza.\nPélda:\n(find-substring-index \"apple pie\" \"pie\") Visszaadja 6\n(find-substring-index \"hello world\" \"bye\") Visszaadja -1"
    },
    "docstring_bertscore": {
      "sq": "0.9822259576138551",
      "hy": "0.9808405107061368",
      "bn": "0.8806575040539513",
      "bg": "0.9930987860413238",
      "zh": "0.9745894139845878",
      "fr": "0.9793899130334389",
      "de": "0.9885008899811283",
      "ha": "0.9810768808595682",
      "hi": "0.9754095588278808",
      "hu": "0.9493879857604053"
    }
  },
  {
    "task_id": "Common Lisp/22",
    "prompt": {
      "en": "(defun min-n-for-sum-greater-than-k (k)\n;; Calculates the smallest integer n such that the sum S_n = 1 + 1/2 + 1/3 + ... + 1/n\n;; is greater than a given integer k.\n;; The function returns the smallest such n.\n;; Example:\n;; (min-n-for-sum-greater-than-k 2) ;; Returns 4\n;; (min-n-for-sum-greater-than-k 3) ;; Returns 11",
      "sq": "(defun min-n-for-sum-greater-than-k (k)\n;; Llogarit numrin më të vogël n të tillë që shuma S_n = 1 + 1/2 + 1/3 + ... + 1/n\n;; është më e madhe se një numër i dhënë k.\n;; Funksioni kthen numrin më të vogël të tillë n.\n;; Shembull:\n;; (min-n-for-sum-greater-than-k 2) ;; Kthen 4\n;; (min-n-for-sum-greater-than-k 3) ;; Kthen 11",
      "hy": "(defun min-n-for-sum-greater-than-k (k)\n;; Հաշվում է ամենափոքր ամբողջ թիվը n, այնպես, որ գումարը S_n = 1 + 1/2 + 1/3 + ... + 1/n\n;; մեծ լինի տրված ամբողջ թիվ k-ից։\n;; Ֆունկցիան վերադարձնում է ամենափոքր այդպիսի n-ը։\n;; Օրինակ:\n;; (min-n-for-sum-greater-than-k 2) ;; Վերադարձնում է 4\n;; (min-n-for-sum-greater-than-k 3) ;; Վերադարձնում է 11",
      "bn": "(defun min-n-for-sum-greater-than-k (k)\n;; এমন একটি ক্ষুদ্রতম পূর্ণসংখ্যা n গণনা করে যার জন্য যোগফল S_n = 1 + 1/2 + 1/3 + ... + 1/n\n;; একটি প্রদত্ত পূর্ণসংখ্যা k এর চেয়ে বড় হয়।\n;; ফাংশনটি সেই ক্ষুদ্রতম n প্রদান করে।\n;; উদাহরণ:\n;; (min-n-for-sum-greater-than-k 2) ;; 4 প্রদান করে\n;; (min-n-for-sum-greater-than-k 3) ;; 11 প্রদান করে",
      "bg": "(defun min-n-for-sum-greater-than-k (k)\n;; Изчислява най-малкото цяло число n, такова че сумата S_n = 1 + 1/2 + 1/3 + ... + 1/n\n;; е по-голяма от даденото цяло число k.\n;; Функцията връща най-малкото такова n.\n;; Пример:\n;; (min-n-for-sum-greater-than-k 2) ;; Връща 4\n;; (min-n-for-sum-greater-than-k 3) ;; Връща 11",
      "zh": "(defun min-n-for-sum-greater-than-k (k)\n;; 计算最小的整数 n，使得和 S_n = 1 + 1/2 + 1/3 + ... + 1/n\n;; 大于给定的整数 k。\n;; 该函数返回满足条件的最小 n。\n;; 示例:\n;; (min-n-for-sum-greater-than-k 2) ;; 返回 4\n;; (min-n-for-sum-greater-than-k 3) ;; 返回 11",
      "fr": "(defun min-n-for-sum-greater-than-k (k)\n;; Calcule le plus petit entier n tel que la somme S_n = 1 + 1/2 + 1/3 + ... + 1/n\n;; soit supérieure à un entier donné k.\n;; La fonction renvoie le plus petit n tel.\n;; Exemple :\n;; (min-n-for-sum-greater-than-k 2) ;; Renvoie 4\n;; (min-n-for-sum-greater-than-k 3) ;; Renvoie 11",
      "de": "(defun min-n-for-sum-greater-than-k (k)\n;; Berechnet die kleinste ganze Zahl n, sodass die Summe S_n = 1 + 1/2 + 1/3 + ... + 1/n\n;; größer als eine gegebene ganze Zahl k ist.\n;; Die Funktion gibt das kleinste solche n zurück.\n;; Beispiel:\n;; (min-n-for-sum-greater-than-k 2) ;; Gibt 4 zurück\n;; (min-n-for-sum-greater-than-k 3) ;; Gibt 11 zurück",
      "ha": "(defun min-n-for-sum-greater-than-k (k)\n;; Lissafi mafi ƙarancin cikakken lamba n inda jumla S_n = 1 + 1/2 + 1/3 + ... + 1/n\n;; ya fi wani cikakken lamba k da aka bayar.\n;; Aikin yana dawowa da mafi ƙarancin irin wannan n.\n;; Misali:\n;; (min-n-for-sum-greater-than-k 2) ;; Yana dawowa da 4\n;; (min-n-for-sum-greater-than-k 3) ;; Yana dawowa da 11",
      "hi": "(defun min-n-for-sum-greater-than-k (k)\n;; ऐसा सबसे छोटा पूर्णांक n गणना करता है जिसके लिए योग S_n = 1 + 1/2 + 1/3 + ... + 1/n\n;; दिए गए पूर्णांक k से अधिक है।\n;; फ़ंक्शन ऐसा सबसे छोटा n लौटाता है।\n;; उदाहरण:\n;; (min-n-for-sum-greater-than-k 2) ;; 4 लौटाता है\n;; (min-n-for-sum-greater-than-k 3) ;; 11 लौटाता है",
      "hu": "(defun min-n-for-sum-greater-than-k (k)\n;; Kiszámítja a legkisebb n egész számot, amelyre az S_n = 1 + 1/2 + 1/3 + ... + 1/n összeg\n;; nagyobb, mint egy adott k egész szám.\n;; A függvény visszaadja a legkisebb ilyen n értéket.\n;; Példa:\n;; (min-n-for-sum-greater-than-k 2) ;; Visszaadja: 4\n;; (min-n-for-sum-greater-than-k 3) ;; Visszaadja: 11"
    },
    "prompt_bertscore": {
      "sq": "0.9864832025705759",
      "hy": "0.9973073665546911",
      "bn": "0.9827680199236993",
      "bg": "0.9973073665546911",
      "zh": "0.9711253001393393",
      "fr": "1",
      "de": "1",
      "ha": "0.9908818723585935",
      "hi": "0.9821548479374446",
      "hu": "0.9791849264802109"
    },
    "canonical_solution": "(let ((sum 0.0) (n 0))\n(loop do\n(incf n)\n(incf sum (/ 1 n))\n(when (> sum k)\n(return n)))))",
    "instruction": {
      "en": "Write a Common Lisp function `(defun min-n-for-sum-greater-than-k (k)` to solve the following problem:\nCalculates the smallest integer n such that the sum S_n = 1 + 1/2 + 1/3 + ... + 1/n\nis greater than a given integer k.\nThe function returns the smallest such n.\nExample:\n(min-n-for-sum-greater-than-k 2) Returns 4\n(min-n-for-sum-greater-than-k 3) Returns 11",
      "sq": "Shkruani një funksion Common Lisp `(defun min-n-for-sum-greater-than-k (k)` për të zgjidhur problemin e mëposhtëm:  \nLlogarit numrin më të vogël të plotë n të tillë që shuma S_n = 1 + 1/2 + 1/3 + ... + 1/n  \nështë më e madhe se një numër i plotë i dhënë k.  \nFunksioni kthen numrin më të vogël të tillë n.  \nShembull:  \n(min-n-for-sum-greater-than-k 2) Kthen 4  \n(min-n-for-sum-greater-than-k 3) Kthen 11",
      "hy": "Գրեք Common Lisp ֆունկցիա `(defun min-n-for-sum-greater-than-k (k)` հետևյալ խնդիրը լուծելու համար:\nՀաշվարկում է ամենափոքր ամբողջ թիվը n, որպեսզի S_n = 1 + 1/2 + 1/3 + ... + 1/n գումարը մեծ լինի տրված ամբողջ թիվ k-ից:\nՖունկցիան վերադարձնում է այդպիսի ամենափոքր n-ը:\nՕրինակ:\n(min-n-for-sum-greater-than-k 2) Վերադարձնում է 4\n(min-n-for-sum-greater-than-k 3) Վերադարձնում է 11",
      "bn": "একটি Common Lisp ফাংশন `(defun min-n-for-sum-greater-than-k (k)` লিখুন নিম্নলিখিত সমস্যাটি সমাধান করতে:\nএটি ক্ষুদ্রতম পূর্ণসংখ্যা n গণনা করে যাতে S_n = 1 + 1/2 + 1/3 + ... + 1/n এর যোগফল একটি প্রদত্ত পূর্ণসংখ্যা k এর চেয়ে বড় হয়।\nফাংশনটি ক্ষুদ্রতম n ফেরত দেয়।\nউদাহরণ:\n(min-n-for-sum-greater-than-k 2) 4 ফেরত দেয়\n(min-n-for-sum-greater-than-k 3) 11 ফেরত দেয়",
      "bg": "Напишете функция на Common Lisp `(defun min-n-for-sum-greater-than-k (k)` за решаване на следния проблем:\nИзчислява най-малкото цяло число n, такова че сумата S_n = 1 + 1/2 + 1/3 + ... + 1/n\nе по-голяма от дадено цяло число k.\nФункцията връща най-малкото такова n.\nПример:\n(min-n-for-sum-greater-than-k 2) Връща 4\n(min-n-for-sum-greater-than-k 3) Връща 11",
      "zh": "编写一个 Common Lisp 函数 `(defun min-n-for-sum-greater-than-k (k)` 来解决以下问题：\n计算最小整数 n，使得和 S_n = 1 + 1/2 + 1/3 + ... + 1/n\n大于给定整数 k。\n该函数返回最小的这样的 n。\n示例:\n(min-n-for-sum-greater-than-k 2) 返回 4\n(min-n-for-sum-greater-than-k 3) 返回 11",
      "fr": "Écrire une fonction Common Lisp `(defun min-n-for-sum-greater-than-k (k)` pour résoudre le problème suivant :  \nCalcule le plus petit entier n tel que la somme S_n = 1 + 1/2 + 1/3 + ... + 1/n  \nsoit supérieure à un entier donné k.  \nLa fonction renvoie le plus petit tel n.  \nExemple :  \n(min-n-for-sum-greater-than-k 2) Renvoie 4  \n(min-n-for-sum-greater-than-k 3) Renvoie 11",
      "de": "Schreiben Sie eine Common Lisp-Funktion `(defun min-n-for-sum-greater-than-k (k)` um das folgende Problem zu lösen:\nBerechnet die kleinste ganze Zahl n, so dass die Summe S_n = 1 + 1/2 + 1/3 + ... + 1/n\ngrößer als eine gegebene ganze Zahl k ist.\nDie Funktion gibt das kleinste solche n zurück.\nBeispiel:\n(min-n-for-sum-greater-than-k 2) Gibt 4 zurück\n(min-n-for-sum-greater-than-k 3) Gibt 11 zurück",
      "ha": "Rubuta aikin Common Lisp `(defun min-n-for-sum-greater-than-k (k)` don warware matsalar mai zuwa:\nLissafa ƙaramin cikakken lamba n wanda yake cewa jumlar S_n = 1 + 1/2 + 1/3 + ... + 1/n\nya fi wani cikakken lamba k da aka bayar.\nAikin yana dawowa da ƙaramin irin wannan n.\nMisali:\n(min-n-for-sum-greater-than-k 2) Yana dawowa 4\n(min-n-for-sum-greater-than-k 3) Yana dawowa 11",
      "hi": "एक Common Lisp फ़ंक्शन `(defun min-n-for-sum-greater-than-k (k)` लिखें ताकि निम्नलिखित समस्या का समाधान किया जा सके:\nसबसे छोटा पूर्णांक n की गणना करता है ताकि योग S_n = 1 + 1/2 + 1/3 + ... + 1/n\nदिए गए पूर्णांक k से अधिक हो।\nफ़ंक्शन सबसे छोटा ऐसा n लौटाता है।\nउदाहरण:\n(min-n-for-sum-greater-than-k 2) 4 लौटाता है\n(min-n-for-sum-greater-than-k 3) 11 लौटाता है",
      "hu": "Írj egy Common Lisp függvényt `(defun min-n-for-sum-greater-than-k (k)` a következő probléma megoldására:\nKiszámítja a legkisebb n egész számot úgy, hogy az S_n összeg = 1 + 1/2 + 1/3 + ... + 1/n\nnagyobb legyen, mint egy adott k egész szám.\nA függvény visszaadja a legkisebb ilyen n értéket.\nPélda:\n(min-n-for-sum-greater-than-k 2) Visszaadja 4\n(min-n-for-sum-greater-than-k 3) Visszaadja 11"
    },
    "instruction_bertscore": {
      "sq": "0.9921252985438719",
      "hy": "0.9974368735631258",
      "bn": "0.9842954875538577",
      "bg": "0.9889281439307342",
      "zh": "0.9864128874156896",
      "fr": "0.998531128332247",
      "de": "1",
      "ha": "0.9816948199749678",
      "hi": "0.992957162579646",
      "hu": "0.9929486214732615"
    },
    "level": "easy",
    "test": "(defun test-min-n-for-sum-greater-than-k ()\n(assert (equal (min-n-for-sum-greater-than-k 1) 2))\n(assert (equal (min-n-for-sum-greater-than-k 2) 4))\n(assert (equal (min-n-for-sum-greater-than-k 3) 11))\n(assert (equal (min-n-for-sum-greater-than-k 4) 31))\n(assert (equal (min-n-for-sum-greater-than-k 5) 83))\n(assert (equal (min-n-for-sum-greater-than-k 0) 1)))\n\n(test-min-n-for-sum-greater-than-k)",
    "entry_point": "min-n-for-sum-greater-than-k",
    "signature": "(defun min-n-for-sum-greater-than-k (k)",
    "docstring": {
      "en": "Calculates the smallest integer n such that the sum S_n = 1 + 1/2 + 1/3 + ... + 1/n\nis greater than a given integer k.\nThe function returns the smallest such n.\nExample:\n(min-n-for-sum-greater-than-k 2) Returns 4\n(min-n-for-sum-greater-than-k 3) Returns 11",
      "sq": "Llogarit numrin më të vogël të plotë n të tillë që shuma S_n = 1 + 1/2 + 1/3 + ... + 1/n\nështë më e madhe se një numër i dhënë i plotë k.\nFunksioni kthen n më të vogël të tillë.\nShembull:\n(min-n-for-sum-greater-than-k 2) Kthen 4\n(min-n-for-sum-greater-than-k 3) Kthen 11",
      "hy": "Հաշվում է ամենափոքր ամբողջ թիվը n, այնպես որ գումարը S_n = 1 + 1/2 + 1/3 + ... + 1/n\nլինի մեծ տրված ամբողջ թիվ k-ից։\nՖունկցիան վերադարձնում է այդպիսի ամենափոքր n-ը։\nՕրինակ:\n(min-n-for-sum-greater-than-k 2) Վերադարձնում է 4\n(min-n-for-sum-greater-than-k 3) Վերադարձնում է 11",
      "bn": "সর্বনিম্ন পূর্ণসংখ্যা n গণনা করে যা S_n = 1 + 1/2 + 1/3 + ... + 1/n এর যোগফল একটি প্রদত্ত পূর্ণসংখ্যা k এর চেয়ে বড় হয়। \nফাংশনটি সর্বনিম্ন এমন n প্রদান করে। \nউদাহরণ: \n(min-n-for-sum-greater-than-k 2) প্রদান করে 4 \n(min-n-for-sum-greater-than-k 3) প্রদান করে 11",
      "bg": "Изчислява най-малкото цяло число n, такова че сумата S_n = 1 + 1/2 + 1/3 + ... + 1/n е по-голяма от дадено цяло число k. Функцията връща най-малкото такова n. Пример: (min-n-for-sum-greater-than-k 2) Връща 4 (min-n-for-sum-greater-than-k 3) Връща 11",
      "zh": "计算最小整数 n，使得和 S_n = 1 + 1/2 + 1/3 + ... + 1/n 大于给定整数 k。\n该函数返回最小的此类 n。\n示例：\n(min-n-for-sum-greater-than-k 2) 返回 4\n(min-n-for-sum-greater-than-k 3) 返回 11",
      "fr": "Calcule le plus petit entier n tel que la somme S_n = 1 + 1/2 + 1/3 + ... + 1/n\nsoit supérieure à un entier donné k.\nLa fonction renvoie le plus petit tel n.\nExemple:\n(min-n-for-sum-greater-than-k 2) Renvoie 4\n(min-n-for-sum-greater-than-k 3) Renvoie 11",
      "de": "Berechnet die kleinste ganze Zahl n, so dass die Summe S_n = 1 + 1/2 + 1/3 + ... + 1/n\ngrößer als eine gegebene ganze Zahl k ist.\nDie Funktion gibt das kleinste solche n zurück.\nBeispiel:\n(min-n-for-sum-greater-than-k 2) Gibt 4 zurück\n(min-n-for-sum-greater-than-k 3) Gibt 11 zurück",
      "ha": "Yana lissafin ƙaramar cikakken lamba n wanda hakan yana nufin jumlar S_n = 1 + 1/2 + 1/3 + ... + 1/n\nya fi girma fiye da wata cikakkiyar lamba k da aka bayar.\nAikin yana mayar da ƙaramar irin wannan n.\nMisali:\n(min-n-for-sum-greater-than-k 2) Yana Mayar da 4\n(min-n-for-sum-greater-than-k 3) Yana Mayar da 11",
      "hi": "सबसे छोटा पूर्णांक n की गणना करता है ताकि योग S_n = 1 + 1/2 + 1/3 + ... + 1/n\nएक दिए गए पूर्णांक k से अधिक हो।\nयह फ़ंक्शन सबसे छोटा ऐसा n लौटाता है।\nउदाहरण:\n(min-n-for-sum-greater-than-k 2) 4 लौटाता है\n(min-n-for-sum-greater-than-k 3) 11 लौटाता है",
      "hu": "Kiszámítja a legkisebb egész számot n, amelyre az S_n = 1 + 1/2 + 1/3 + ... + 1/n összeg nagyobb, mint egy adott k egész szám.\nA függvény visszaadja a legkisebb ilyen n értéket.\nPélda:\n(min-n-for-sum-greater-than-k 2) Visszaadja 4\n(min-n-for-sum-greater-than-k 3) Visszaadja 11"
    },
    "docstring_bertscore": {
      "sq": "0.9977423670891574",
      "hy": "0.9871190184202685",
      "bn": "0.9852916189147476",
      "bg": "0.999999801369619",
      "zh": "0.985253879142351",
      "fr": "0.9977423670891574",
      "de": "0.999999801369619",
      "ha": "0.999999801369619",
      "hi": "0.9908632011027761",
      "hu": "0.9835446647135457"
    }
  },
  {
    "task_id": "Common Lisp/23",
    "prompt": {
      "en": "(defun count-reachable-apples (apple-heights fengfeng-height)\n;; Counts the number of apples that Fengfeng can reach.\n;; 'apple-heights' is a list of integers representing the heights of apples.\n;; 'fengfeng-height' is an integer representing Fengfeng's maximum reach height.\n;; Fengfeng can reach apples at or below her maximum height.\n;; Example:\n;; (count-reachable-apples '(120 130 140 150 160 170 180 190 200 210) 150) ;; Returns 4\n;; (count-reachable-apples '(100 101 102 103 104 105 106 107 108 109) 110) ;; Returns 10",
      "sq": "(defun count-reachable-apples (apple-heights fengfeng-height)\n;; Numëron numrin e mollëve që Fengfeng mund të arrijë.\n;; 'apple-heights' është një listë e numrave të plotë që përfaqësojnë lartësitë e mollëve.\n;; 'fengfeng-height' është një numër i plotë që përfaqëson lartësinë maksimale të arritjes së Fengfeng.\n;; Fengfeng mund të arrijë mollët në ose nën lartësinë e saj maksimale.\n;; Shembull:\n;; (count-reachable-apples '(120 130 140 150 160 170 180 190 200 210) 150) ;; Kthen 4\n;; (count-reachable-apples '(100 101 102 103 104 105 106 107 108 109) 110) ;; Kthen 10",
      "hy": "(defun count-reachable-apples (apple-heights fengfeng-height)\n;; Հաշվում է խնձորների քանակը, որոնք Ֆենգֆենգը կարող է հասնել։\n;; 'apple-heights' ցուցակ է, որը ներկայացնում է խնձորների բարձրությունները։\n;; 'fengfeng-height' ամբողջ թիվ է, որը ներկայացնում է Ֆենգֆենգի առավելագույն հասանելի բարձրությունը։\n;; Ֆենգֆենգը կարող է հասնել խնձորներին, որոնք գտնվում են իր առավելագույն բարձրության վրա կամ ցածր։\n;; Օրինակ:\n;; (count-reachable-apples '(120 130 140 150 160 170 180 190 200 210) 150) ;; Վերադարձնում է 4\n;; (count-reachable-apples '(100 101 102 103 104 105 106 107 108 109) 110) ;; Վերադարձնում է 10",
      "bn": "(defun count-reachable-apples (apple-heights fengfeng-height)\n;; ফেংফেং কতগুলি আপেল পৌঁছাতে পারে তা গণনা করে।\n;; 'apple-heights' হল আপেলের উচ্চতা প্রতিনিধিত্বকারী পূর্ণসংখ্যার একটি তালিকা।\n;; 'fengfeng-height' হল ফেংফেং-এর সর্বাধিক পৌঁছানোর উচ্চতা প্রতিনিধিত্বকারী একটি পূর্ণসংখ্যা।\n;; ফেংফেং তার সর্বাধিক উচ্চতা বা তার নিচে থাকা আপেল পৌঁছাতে পারে।\n;; উদাহরণ:\n;; (count-reachable-apples '(120 130 140 150 160 170 180 190 200 210) 150) ;; 4 প্রদান করে\n;; (count-reachable-apples '(100 101 102 103 104 105 106 107 108 109) 110) ;; 10 প্রদান করে",
      "bg": "(defun count-reachable-apples (apple-heights fengfeng-height)\n;; Брои броя на ябълките, които Фенгфенг може да достигне.\n;; 'apple-heights' е списък от цели числа, представляващи височините на ябълките.\n;; 'fengfeng-height' е цяло число, представляващо максималната височина, която Фенгфенг може да достигне.\n;; Фенгфенг може да достигне ябълки на или под нейната максимална височина.\n;; Пример:\n;; (count-reachable-apples '(120 130 140 150 160 170 180 190 200 210) 150) ;; Връща 4\n;; (count-reachable-apples '(100 101 102 103 104 105 106 107 108 109) 110) ;; Връща 10",
      "zh": "(defun count-reachable-apples (apple-heights fengfeng-height)\n;; 计算凤凤可以够到的苹果数量。\n;; 'apple-heights' 是一个整数列表，表示苹果的高度。\n;; 'fengfeng-height' 是一个整数，表示凤凤的最大够到高度。\n;; 凤凤可以够到她最大高度或以下的苹果。\n;; 例子:\n;; (count-reachable-apples '(120 130 140 150 160 170 180 190 200 210) 150) ;; 返回 4\n;; (count-reachable-apples '(100 101 102 103 104 105 106 107 108 109) 110) ;; 返回 10",
      "fr": "(defun count-reachable-apples (apple-heights fengfeng-height)\n;; Compte le nombre de pommes que Fengfeng peut atteindre.\n;; 'apple-heights' est une liste d'entiers représentant les hauteurs des pommes.\n;; 'fengfeng-height' est un entier représentant la hauteur maximale que Fengfeng peut atteindre.\n;; Fengfeng peut atteindre les pommes à ou en dessous de sa hauteur maximale.\n;; Exemple:\n;; (count-reachable-apples '(120 130 140 150 160 170 180 190 200 210) 150) ;; Retourne 4\n;; (count-reachable-apples '(100 101 102 103 104 105 106 107 108 109) 110) ;; Retourne 10",
      "de": "(defun count-reachable-apples (apple-heights fengfeng-height)\n;; Zählt die Anzahl der Äpfel, die Fengfeng erreichen kann.\n;; 'apple-heights' ist eine Liste von ganzen Zahlen, die die Höhen der Äpfel darstellen.\n;; 'fengfeng-height' ist eine ganze Zahl, die die maximale Reichhöhe von Fengfeng darstellt.\n;; Fengfeng kann Äpfel in oder unter ihrer maximalen Höhe erreichen.\n;; Beispiel:\n;; (count-reachable-apples '(120 130 140 150 160 170 180 190 200 210) 150) ;; Gibt 4 zurück\n;; (count-reachable-apples '(100 101 102 103 104 105 106 107 108 109) 110) ;; Gibt 10 zurück",
      "ha": "(defun count-reachable-apples (apple-heights fengfeng-height)\n;; Yana ƙididdige yawan tuffa da Fengfeng za ta iya kaiwa.\n;; 'apple-heights' jerin lambobi ne da ke wakiltar tsayin tuffa.\n;; 'fengfeng-height' lamba ce da ke wakiltar tsayin kaiwa mafi girma na Fengfeng.\n;; Fengfeng za ta iya kaiwa tuffa a ko ƙasa da tsayin ta mafi girma.\n;; Misali:\n;; (count-reachable-apples '(120 130 140 150 160 170 180 190 200 210) 150) ;; Yana dawowa 4\n;; (count-reachable-apples '(100 101 102 103 104 105 106 107 108 109) 110) ;; Yana dawowa 10",
      "hi": "(defun count-reachable-apples (apple-heights fengfeng-height)\n;; गिनती करता है कि फेंगफेंग कितने सेब तक पहुँच सकती है।\n;; 'apple-heights' संख्याओं की एक सूची है जो सेबों की ऊँचाई का प्रतिनिधित्व करती है।\n;; 'fengfeng-height' एक पूर्णांक है जो फेंगफेंग की अधिकतम पहुँच ऊँचाई का प्रतिनिधित्व करता है।\n;; फेंगफेंग उन सेबों तक पहुँच सकती है जो उसकी अधिकतम ऊँचाई पर या उससे नीचे हैं।\n;; उदाहरण:\n;; (count-reachable-apples '(120 130 140 150 160 170 180 190 200 210) 150) ;; 4 लौटाता है\n;; (count-reachable-apples '(100 101 102 103 104 105 106 107 108 109) 110) ;; 10 लौटाता है",
      "hu": "(defun count-reachable-apples (apple-heights fengfeng-height)\n;; Megszámolja, hány almát ér el Fengfeng.\n;; Az 'apple-heights' egy egész számokat tartalmazó lista, amely az almák magasságát jelzi.\n;; A 'fengfeng-height' egy egész szám, amely Fengfeng maximális elérési magasságát jelzi.\n;; Fengfeng eléri az almákat, amelyek az ő maximális magasságán vagy az alatt vannak.\n;; Példa:\n;; (count-reachable-apples '(120 130 140 150 160 170 180 190 200 210) 150) ;; Visszaadja: 4\n;; (count-reachable-apples '(100 101 102 103 104 105 106 107 108 109) 110) ;; Visszaadja: 10"
    },
    "prompt_bertscore": {
      "sq": "0.9860700513780233",
      "hy": "0.9763431216187448",
      "bn": "0.9861761200014959",
      "bg": "0.9843010492045265",
      "zh": "0.9801429208079422",
      "fr": "0.977004759417972",
      "de": "0.9905839267870411",
      "ha": "0.9783741172648266",
      "hi": "0.9772558282196001",
      "hu": "0.9644576755087602"
    },
    "canonical_solution": "(count-if (lambda (height) (<= height fengfeng-height)) apple-heights))",
    "instruction": {
      "en": "Write a Common Lisp function `(defun count-reachable-apples (apple-heights fengfeng-height)` to solve the following problem:\nCounts the number of apples that Fengfeng can reach.\n'apple-heights' is a list of integers representing the heights of apples.\n'fengfeng-height' is an integer representing Fengfeng's maximum reach height.\nFengfeng can reach apples at or below her maximum height.\nExample:\n(count-reachable-apples '(120 130 140 150 160 170 180 190 200 210) 150) Returns 4\n(count-reachable-apples '(100 101 102 103 104 105 106 107 108 109) 110) Returns 10",
      "sq": "Shkruani një funksion Common Lisp `(defun count-reachable-apples (apple-heights fengfeng-height)` për të zgjidhur problemin në vijim:\nNumëron numrin e mollëve që Fengfeng mund të arrijë.\n'apple-heights' është një listë e numrave të plotë që përfaqësojnë lartësitë e mollëve.\n'fengfeng-height' është një numër i plotë që përfaqëson lartësinë maksimale të arritshme të Fengfeng.\nFengfeng mund të arrijë mollët në ose nën lartësinë e saj maksimale.\nShembull:\n(count-reachable-apples '(120 130 140 150 160 170 180 190 200 210) 150) Kthen 4\n(count-reachable-apples '(100 101 102 103 104 105 106 107 108 109) 110) Kthen 10",
      "hy": "Գրեք Common Lisp ֆունկցիա `(defun count-reachable-apples (apple-heights fengfeng-height)` հետևյալ խնդիրը լուծելու համար:\nՀաշվում է այն խնձորների քանակը, որոնք Ֆենգֆենգը կարող է հասնել:\n'apple-heights' -ը ամբողջ թվերի ցուցակ է, որը ներկայացնում է խնձորների բարձրությունները:\n'fengfeng-height' -ը ամբողջ թիվ է, որը ներկայացնում է Ֆենգֆենգի առավելագույն հասանելի բարձրությունը:\nՖենգֆենգը կարող է հասնել խնձորներին, որոնք գտնվում են իր առավելագույն բարձրության վրա կամ ներքև:\nՕրինակ:\n(count-reachable-apples '(120 130 140 150 160 170 180 190 200 210) 150) Վերադարձնում է 4\n(count-reachable-apples '(100 101 102 103 104 105 106 107 108 109) 110) Վերադարձնում է 10",
      "bn": "একটি Common Lisp ফাংশন `(defun count-reachable-apples (apple-heights fengfeng-height)` লিখুন নিম্নলিখিত সমস্যার সমাধানের জন্য:\nফেংফেং কতগুলি আপেল পৌঁছাতে পারে তা গণনা করে।\n'apple-heights' হল আপেলের উচ্চতাগুলির একটি তালিকা যা পূর্ণসংখ্যা হিসাবে উপস্থাপিত।\n'fengfeng-height' হল ফেংফেং-এর সর্বাধিক পৌঁছানোর উচ্চতা যা একটি পূর্ণসংখ্যা হিসাবে উপস্থাপিত।\nফেংফেং তার সর্বাধিক উচ্চতা বা তার নিচে থাকা আপেলগুলিতে পৌঁছাতে পারে।\nউদাহরণ:\n(count-reachable-apples '(120 130 140 150 160 170 180 190 200 210) 150) 4 ফেরত দেয়\n(count-reachable-apples '(100 101 102 103 104 105 106 107 108 109) 110) 10 ফেরত দেয়",
      "bg": "Напишете функция на Common Lisp `(defun count-reachable-apples (apple-heights fengfeng-height)` за решаване на следния проблем:\nБрои броя на ябълките, които Fengfeng може да достигне.\n'apple-heights' е списък от цели числа, представляващи височините на ябълките.\n'fengfeng-height' е цяло число, представляващо максималната височина, до която Fengfeng може да достигне.\nFengfeng може да достигне ябълки на или под нейната максимална височина.\nПример:\n(count-reachable-apples '(120 130 140 150 160 170 180 190 200 210) 150) Връща 4\n(count-reachable-apples '(100 101 102 103 104 105 106 107 108 109) 110) Връща 10",
      "zh": "编写一个 Common Lisp 函数 `(defun count-reachable-apples (apple-heights fengfeng-height)` 来解决以下问题：\n计算凤凤可以够到的苹果数量。\n'apple-heights' 是一个整数列表，表示苹果的高度。\n'fengfeng-height' 是一个整数，表示凤凤的最大够高。\n凤凤可以够到她最大高度或以下的苹果。\n示例：\n(count-reachable-apples '(120 130 140 150 160 170 180 190 200 210) 150) 返回 4\n(count-reachable-apples '(100 101 102 103 104 105 106 107 108 109) 110) 返回 10",
      "fr": "Écrire une fonction Common Lisp `(defun count-reachable-apples (apple-heights fengfeng-height)` pour résoudre le problème suivant :\nCompte le nombre de pommes que Fengfeng peut atteindre.\n'apple-heights' est une liste d'entiers représentant les hauteurs des pommes.\n'fengfeng-height' est un entier représentant la hauteur maximale que Fengfeng peut atteindre.\nFengfeng peut atteindre les pommes à ou en dessous de sa hauteur maximale.\nExemple :\n(count-reachable-apples '(120 130 140 150 160 170 180 190 200 210) 150) Retourne 4\n(count-reachable-apples '(100 101 102 103 104 105 106 107 108 109) 110) Retourne 10",
      "de": "Schreiben Sie eine Common Lisp-Funktion `(defun count-reachable-apples (apple-heights fengfeng-height)`, um das folgende Problem zu lösen:\nZählt die Anzahl der Äpfel, die Fengfeng erreichen kann.\n'apple-heights' ist eine Liste von ganzen Zahlen, die die Höhen der Äpfel darstellen.\n'fengfeng-height' ist eine ganze Zahl, die die maximale Reichhöhe von Fengfeng darstellt.\nFengfeng kann Äpfel in oder unter ihrer maximalen Höhe erreichen.\nBeispiel:\n(count-reachable-apples '(120 130 140 150 160 170 180 190 200 210) 150) gibt 4 zurück\n(count-reachable-apples '(100 101 102 103 104 105 106 107 108 109) 110) gibt 10 zurück",
      "ha": "Rubuta aikin Common Lisp `(defun count-reachable-apples (apple-heights fengfeng-height)` don warware matsalar mai zuwa:\nYana ƙididdige yawan tuffa da Fengfeng za ta iya kaiwa.\n'apple-heights' jerin lambobi ne da ke wakiltar tsayin tuffa.\n'fengfeng-height' lamba ce da ke wakiltar iyakar tsayin da Fengfeng za ta iya kaiwa.\nFengfeng na iya kaiwa tuffa a ko ƙasa da iyakar tsayinta.\nMisali:\n(count-reachable-apples '(120 130 140 150 160 170 180 190 200 210) 150) Yana dawowa 4\n(count-reachable-apples '(100 101 102 103 104 105 106 107 108 109) 110) Yana dawowa 10",
      "hi": "एक Common Lisp फ़ंक्शन `(defun count-reachable-apples (apple-heights fengfeng-height)` लिखें ताकि निम्नलिखित समस्या का समाधान किया जा सके:\nगिनती करें कि फेंगफेंग कितने सेब तक पहुँच सकती है।\n'apple-heights' पूर्णांकों की एक सूची है जो सेबों की ऊँचाई का प्रतिनिधित्व करती है।\n'fengfeng-height' एक पूर्णांक है जो फेंगफेंग की अधिकतम पहुँच ऊँचाई का प्रतिनिधित्व करता है।\nफेंगफेंग उन सेबों तक पहुँच सकती है जो उसकी अधिकतम ऊँचाई पर या उससे नीचे हैं।\nउदाहरण:\n(count-reachable-apples '(120 130 140 150 160 170 180 190 200 210) 150) 4 लौटाता है\n(count-reachable-apples '(100 101 102 103 104 105 106 107 108 109) 110) 10 लौटाता है",
      "hu": "Írj egy Common Lisp függvényt `(defun count-reachable-apples (apple-heights fengfeng-height)` a következő probléma megoldására:\nMegszámolja, hogy hány almát ér el Fengfeng.\n'apple-heights' egy egész számokat tartalmazó lista, amely az almák magasságát jelöli.\n'fengfeng-height' egy egész szám, amely Fengfeng maximális elérési magasságát jelöli.\nFengfeng eléri az almákat, amelyek az ő maximális magasságán vagy az alatt vannak.\nPélda:\n(count-reachable-apples '(120 130 140 150 160 170 180 190 200 210) 150) Visszaadja: 4\n(count-reachable-apples '(100 101 102 103 104 105 106 107 108 109) 110) Visszaadja: 10"
    },
    "instruction_bertscore": {
      "sq": "0.9912646331028477",
      "hy": "0.9772590063056967",
      "bn": "0.9653836903451448",
      "bg": "0.9783000281327006",
      "zh": "0.9815907376553056",
      "fr": "0.9760612651080564",
      "de": "0.9796928243645172",
      "ha": "0.9692035512028268",
      "hi": "0.9797128860330017",
      "hu": "0.9685728997430411"
    },
    "level": "easy",
    "test": "(defun test-count-reachable-apples ()\n(assert (equal (count-reachable-apples '(120 130 140 150 160 170 180 190 200 210) 150) 4))\n(assert (equal (count-reachable-apples '(100 101 102 103 104 105 106 107 108 109) 110) 10))\n(assert (equal (count-reachable-apples '(110 115 120 125 130 135 140 145 150 155) 120) 3))\n(assert (equal (count-reachable-apples '(200 199 198 197 196 195 194 193 192 191) 190) 0))\n(assert (equal (count-reachable-apples '(101 102 103 104 105 106 107 108 109 110) 105) 5)))\n\n(test-count-reachable-apples)",
    "entry_point": "count-reachable-apples",
    "signature": "(defun count-reachable-apples (apple-heights fengfeng-height)",
    "docstring": {
      "en": "Counts the number of apples that Fengfeng can reach.\n'apple-heights' is a list of integers representing the heights of apples.\n'fengfeng-height' is an integer representing Fengfeng's maximum reach height.\nFengfeng can reach apples at or below her maximum height.\nExample:\n(count-reachable-apples '(120 130 140 150 160 170 180 190 200 210) 150) Returns 4\n(count-reachable-apples '(100 101 102 103 104 105 106 107 108 109) 110) Returns 10",
      "sq": "Numëron numrin e mollëve që Fengfeng mund të arrijë. 'apple-heights' është një listë e numrave të plotë që përfaqësojnë lartësitë e mollëve. 'fengfeng-height' është një numër i plotë që përfaqëson lartësinë maksimale që Fengfeng mund të arrijë. Fengfeng mund të arrijë mollët që janë në ose nën lartësinë e saj maksimale. Shembull: (count-reachable-apples '(120 130 140 150 160 170 180 190 200 210) 150) Kthen 4 (count-reachable-apples '(100 101 102 103 104 105 106 107 108 109) 110) Kthen 10",
      "hy": "Հաշվում է խնձորների քանակը, որոնք Ֆենգֆենգը կարող է հասնել։  \n'apple-heights' ցուցակ է, որը պարունակում է ամբողջ թվեր, որոնք ներկայացնում են խնձորների բարձրությունները։  \n'fengfeng-height' ամբողջ թիվ է, որը ներկայացնում է Ֆենգֆենգի առավելագույն հասանելի բարձրությունը։  \nՖենգֆենգը կարող է հասնել խնձորներին, որոնք գտնվում են իր առավելագույն բարձրության վրա կամ դրանից ցածր։  \nՕրինակ՝  \n(count-reachable-apples '(120 130 140 150 160 170 180 190 200 210) 150) Վերադարձնում է 4  \n(count-reachable-apples '(100 101 102 103 104 105 106 107 108 109) 110) Վերադարձնում է 10",
      "bn": "Fengfeng কতগুলি আপেল পৌঁছাতে পারে তা গণনা করে।\n'apple-heights' একটি পূর্ণসংখ্যার তালিকা যা আপেলের উচ্চতাকে উপস্থাপন করে।\n'fengfeng-height' একটি পূর্ণসংখ্যা যা Fengfeng-এর সর্বাধিক পৌঁছানোর উচ্চতাকে উপস্থাপন করে।\nFengfeng তার সর্বাধিক উচ্চতার সমান বা তার নিচে থাকা আপেলগুলো পৌঁছাতে পারে।\nউদাহরণ:\n(count-reachable-apples '(120 130 140 150 160 170 180 190 200 210) 150) Returns 4\n(count-reachable-apples '(100 101 102 103 104 105 106 107 108 109) 110) Returns 10",
      "bg": "Брои броя на ябълките, които Фенгфенг може да достигне.\n'apple-heights' е списък от цели числа, представляващи височините на ябълките.\n'fengfeng-height' е цяло число, представляващо максималната височина на достигане на Фенгфенг.\nФенгфенг може да достигне ябълки на или под нейната максимална височина.\nПример:\n(count-reachable-apples '(120 130 140 150 160 170 180 190 200 210) 150) Връща 4\n(count-reachable-apples '(100 101 102 103 104 105 106 107 108 109) 110) Връща 10",
      "zh": "计算凤凤可以够到的苹果数量。  \n'apple-heights' 是一个整数列表，表示苹果的高度。  \n'fengfeng-height' 是一个整数，表示凤凤的最大够到高度。  \n凤凤可以够到高度不超过她最大高度的苹果。  \n示例：  \n(count-reachable-apples '(120 130 140 150 160 170 180 190 200 210) 150) 返回 4  \n(count-reachable-apples '(100 101 102 103 104 105 106 107 108 109) 110) 返回 10",
      "fr": "Compte le nombre de pommes que Fengfeng peut atteindre.\n'apple-heights' est une liste d'entiers représentant les hauteurs des pommes.\n'fengfeng-height' est un entier représentant la hauteur maximale que Fengfeng peut atteindre.\nFengfeng peut atteindre les pommes à ou en dessous de sa hauteur maximale.\nExemple :\n(count-reachable-apples '(120 130 140 150 160 170 180 190 200 210) 150) Retourne 4\n(count-reachable-apples '(100 101 102 103 104 105 106 107 108 109) 110) Retourne 10",
      "de": "Zählt die Anzahl der Äpfel, die Fengfeng erreichen kann.\n'apple-heights' ist eine Liste von ganzen Zahlen, die die Höhen der Äpfel darstellen.\n'fengfeng-height' ist eine ganze Zahl, die die maximale Reichhöhe von Fengfeng darstellt.\nFengfeng kann Äpfel in oder unter ihrer maximalen Höhe erreichen.\nBeispiel:\n(count-reachable-apples '(120 130 140 150 160 170 180 190 200 210) 150) Gibt 4 zurück\n(count-reachable-apples '(100 101 102 103 104 105 106 107 108 109) 110) Gibt 10 zurück",
      "ha": "Yana ƙididdige yawan tuffa da Fengfeng za ta iya kaiwa. \n'apple-heights' jerin lambobi ne da ke wakiltar tsayin tuffa. \n'fengfeng-height' lamba ce da ke wakiltar tsayin kai na Fengfeng. \nFengfeng na iya kaiwa tuffa a ko ƙasa da tsayin kai nata. \nMisali:\n(count-reachable-apples '(120 130 140 150 160 170 180 190 200 210) 150) Returns 4\n(count-reachable-apples '(100 101 102 103 104 105 106 107 108 109) 110) Returns 10",
      "hi": "सेबों की संख्या गिनता है जिन्हें फेंगफेंग पहुंच सकती है।  \n'apple-heights' पूर्णांकों की एक सूची है जो सेबों की ऊंचाई का प्रतिनिधित्व करती है।  \n'fengfeng-height' एक पूर्णांक है जो फेंगफेंग की अधिकतम पहुंच ऊंचाई का प्रतिनिधित्व करता है।  \nफेंगफेंग अपनी अधिकतम ऊंचाई पर या उससे नीचे के सेबों तक पहुंच सकती है।  \nउदाहरण:  \n(count-reachable-apples '(120 130 140 150 160 170 180 190 200 210) 150) Returns 4  \n(count-reachable-apples '(100 101 102 103 104 105 106 107 108 109) 110) Returns 10  ",
      "hu": "Számolja meg, hány almát ér el Fengfeng.  \n'apple-heights' egy egész számokat tartalmazó lista, amely az almák magasságát jelképezi.  \n'fengfeng-height' egy egész szám, amely Fengfeng maximális elérési magasságát jelenti.  \nFengfeng eléri az almákat, amelyek az ő maximális magasságán vagy az alatt vannak.  \nPélda:  \n(count-reachable-apples '(120 130 140 150 160 170 180 190 200 210) 150) Visszaadja: 4  \n(count-reachable-apples '(100 101 102 103 104 105 106 107 108 109) 110) Visszaadja: 10"
    },
    "docstring_bertscore": {
      "sq": "0.9665705068718283",
      "hy": "0.9529317503884488",
      "bn": "0.9401540566068555",
      "bg": "0.985840434657547",
      "zh": "0.9589576002579041",
      "fr": "0.9688037082458035",
      "de": "0.9860990514136544",
      "ha": "0.9513488648819818",
      "hi": "1",
      "hu": "0.9661198145372601"
    }
  },
  {
    "task_id": "Common Lisp/24",
    "prompt": {
      "en": "(defun count-remaining-trees (road-length regions)\n;; Counts the number of trees remaining on a road of length 'road-length' after removing trees in specified 'regions'.\n;; Each region is a list of two integers representing the start and end points on the road.\n;; The function returns the number of trees remaining after the removal.\n;; Example:\n;; (count-remaining-trees 10 '((2 5) (7 9))) ;; Returns 4\n;; (count-remaining-trees 15 '((1 3) (5 10))) ;; Returns 7",
      "sq": "(defun count-remaining-trees (road-length regions)\n;; Numëron numrin e pemëve të mbetura në një rrugë me gjatësi 'road-length' pasi të hiqen pemët në 'regions' e specifikuara.\n;; Secila rajon është një listë me dy numra të plotë që përfaqësojnë pikat e fillimit dhe të mbarimit në rrugë.\n;; Funksioni kthen numrin e pemëve të mbetura pas heqjes.\n;; Shembull:\n;; (count-remaining-trees 10 '((2 5) (7 9))) ;; Kthen 4\n;; (count-remaining-trees 15 '((1 3) (5 10))) ;; Kthen 7",
      "hy": "(defun count-remaining-trees (road-length regions)\n;; Հաշվում է ճանապարհի 'road-length' երկարությամբ մնացած ծառերի քանակը՝ 'regions' նշված տարածքներում ծառերը հեռացնելուց հետո:\n;; Յուրաքանչյուր տարածք ցուցակ է, որը պարունակում է երկու ամբողջ թիվ, որոնք ներկայացնում են ճանապարհի վրա սկիզբն ու վերջը:\n;; Ֆունկցիան վերադարձնում է հեռացումից հետո մնացած ծառերի քանակը:\n;; Օրինակ:\n;; (count-remaining-trees 10 '((2 5) (7 9))) ;; Վերադարձնում է 4\n;; (count-remaining-trees 15 '((1 3) (5 10))) ;; Վերադարձնում է 7",
      "bn": "(defun count-remaining-trees (road-length regions)\n;; নির্দিষ্ট 'regions' থেকে গাছ অপসারণের পর 'road-length' দৈর্ঘ্যের একটি রাস্তার উপর অবশিষ্ট গাছের সংখ্যা গণনা করে।\n;; প্রতিটি অঞ্চল রাস্তার শুরু এবং শেষ বিন্দু প্রতিনিধিত্বকারী দুটি পূর্ণসংখ্যার একটি তালিকা।\n;; ফাংশনটি অপসারণের পর অবশিষ্ট গাছের সংখ্যা প্রদান করে।\n;; উদাহরণ:\n;; (count-remaining-trees 10 '((2 5) (7 9))) ;; 4 প্রদান করে\n;; (count-remaining-trees 15 '((1 3) (5 10))) ;; 7 প্রদান করে",
      "bg": "(defun count-remaining-trees (road-length regions)\n;; Брои броя на останалите дървета по път с дължина 'road-length' след премахване на дървета в определените 'regions'.\n;; Всяка област е списък от две цели числа, представляващи началната и крайната точка на пътя.\n;; Функцията връща броя на останалите дървета след премахването.\n;; Пример:\n;; (count-remaining-trees 10 '((2 5) (7 9))) ;; Връща 4\n;; (count-remaining-trees 15 '((1 3) (5 10))) ;; Връща 7",
      "zh": "(defun count-remaining-trees (road-length regions)\n;; 计算在长度为 'road-length' 的道路上，在指定的 'regions' 中移除树木后剩余的树木数量。\n;; 每个区域是一个由两个整数表示的列表，代表道路上的起始和结束点。\n;; 该函数返回移除后剩余的树木数量。\n;; 示例:\n;; (count-remaining-trees 10 '((2 5) (7 9))) ;; 返回 4\n;; (count-remaining-trees 15 '((1 3) (5 10))) ;; 返回 7",
      "fr": "(defun count-remaining-trees (road-length regions)\n;; Compte le nombre d'arbres restants sur une route de longueur 'road-length' après avoir enlevé les arbres dans les 'regions' spécifiées.\n;; Chaque région est une liste de deux entiers représentant les points de début et de fin sur la route.\n;; La fonction retourne le nombre d'arbres restants après le retrait.\n;; Exemple:\n;; (count-remaining-trees 10 '((2 5) (7 9))) ;; Retourne 4\n;; (count-remaining-trees 15 '((1 3) (5 10))) ;; Retourne 7",
      "de": "(defun count-remaining-trees (road-length regions)\n;; Zählt die Anzahl der verbleibenden Bäume auf einer Straße der Länge 'road-length', nachdem Bäume in angegebenen 'regions' entfernt wurden.\n;; Jede Region ist eine Liste von zwei ganzen Zahlen, die die Start- und Endpunkte auf der Straße darstellen.\n;; Die Funktion gibt die Anzahl der verbleibenden Bäume nach der Entfernung zurück.\n;; Beispiel:\n;; (count-remaining-trees 10 '((2 5) (7 9))) ;; Gibt 4 zurück\n;; (count-remaining-trees 15 '((1 3) (5 10))) ;; Gibt 7 zurück",
      "ha": "(defun count-remaining-trees (road-length regions)\n;; Yana ƙididdige adadin itatuwan da suka rage akan hanya mai tsawon 'road-length' bayan cire itatuwa a wuraren da aka fayyace 'regions'.\n;; Kowanne yanki jerin lambobi biyu ne da ke wakiltar wuraren farawa da ƙarewa akan hanya.\n;; Aikin yana dawowa da adadin itatuwan da suka rage bayan cirewa.\n;; Misali:\n;; (count-remaining-trees 10 '((2 5) (7 9))) ;; Yana dawowa 4\n;; (count-remaining-trees 15 '((1 3) (5 10))) ;; Yana dawowa 7",
      "hi": "(defun count-remaining-trees (road-length regions)\n;; 'road-length' लंबाई की सड़क पर शेष पेड़ों की संख्या की गणना करता है, निर्दिष्ट 'regions' में पेड़ों को हटाने के बाद।\n;; प्रत्येक क्षेत्र दो पूर्णांकों की सूची है जो सड़क पर प्रारंभ और अंत बिंदुओं का प्रतिनिधित्व करती है।\n;; फ़ंक्शन हटाने के बाद शेष पेड़ों की संख्या लौटाता है।\n;; उदाहरण:\n;; (count-remaining-trees 10 '((2 5) (7 9))) ;; 4 लौटाता है\n;; (count-remaining-trees 15 '((1 3) (5 10))) ;; 7 लौटाता है",
      "hu": "(defun count-remaining-trees (road-length regions)\n;; Megszámolja a megmaradt fák számát egy 'road-length' hosszúságú úton, miután eltávolította a fákat a megadott 'regions' területeken.\n;; Minden terület egy két egész számot tartalmazó lista, amely az út kezdő és végpontját jelöli.\n;; A függvény visszaadja a megmaradt fák számát az eltávolítás után.\n;; Példa:\n;; (count-remaining-trees 10 '((2 5) (7 9))) ;; Visszaadja 4\n;; (count-remaining-trees 15 '((1 3) (5 10))) ;; Visszaadja 7"
    },
    "prompt_bertscore": {
      "sq": "0.988562068138487",
      "hy": "0.9534773880451516",
      "bn": "0.9703655389318809",
      "bg": "0.9883485404788745",
      "zh": "0.9714282114704176",
      "fr": "0.989717898325729",
      "de": "0.9838018910569859",
      "ha": "0.970291847060517",
      "hi": "0.9808943395393972",
      "hu": "0.9786796107908582"
    },
    "canonical_solution": "(let ((tree-map (make-array (1+ road-length) :initial-element t)))\n(dolist (region regions)\n(loop for i from (first region) to (second region)\ndo (setf (aref tree-map i) nil)))\n(count t tree-map)))",
    "instruction": {
      "en": "Write a Common Lisp function `(defun count-remaining-trees (road-length regions)` to solve the following problem:\nCounts the number of trees remaining on a road of length 'road-length' after removing trees in specified 'regions'.\nEach region is a list of two integers representing the start and end points on the road.\nThe function returns the number of trees remaining after the removal.\nExample:\n(count-remaining-trees 10 '((2 5) (7 9))) Returns 4\n(count-remaining-trees 15 '((1 3) (5 10))) Returns 7",
      "sq": "Shkruani një funksion Common Lisp `(defun count-remaining-trees (road-length regions)` për të zgjidhur problemin e mëposhtëm:\nNumëron numrin e pemëve të mbetura në një rrugë me gjatësi 'road-length' pas heqjes së pemëve në 'regions' të specifikuara.\nÇdo rajon është një listë me dy numra të plotë që përfaqësojnë pikat e fillimit dhe të mbarimit në rrugë.\nFunksioni kthen numrin e pemëve të mbetura pas heqjes.\nShembull:\n(count-remaining-trees 10 '((2 5) (7 9))) Kthen 4\n(count-remaining-trees 15 '((1 3) (5 10))) Kthen 7",
      "hy": "Գրեք Common Lisp ֆունկցիա `(defun count-remaining-trees (road-length regions)` հետևյալ խնդիրը լուծելու համար:\nՀաշվում է ճանապարհի վրա մնացած ծառերի քանակը 'road-length' երկարությամբ ճանապարհի վրա, այն բանից հետո, երբ ծառերը հեռացվում են նշված 'regions' տարածքներում:\nՅուրաքանչյուր տարածք ցուցակ է երկու ամբողջ թվերով, որոնք ներկայացնում են ճանապարհի վրա սկիզբն ու վերջը:\nՖունկցիան վերադարձնում է մնացած ծառերի քանակը հեռացումից հետո:\nՕրինակ:\n(count-remaining-trees 10 '((2 5) (7 9))) Վերադարձնում է 4\n(count-remaining-trees 15 '((1 3) (5 10))) Վերադարձնում է 7",
      "bn": "একটি Common Lisp ফাংশন `(defun count-remaining-trees (road-length regions)` লিখুন নিম্নলিখিত সমস্যার সমাধানের জন্য:\nএকটি রাস্তার দৈর্ঘ্য 'road-length' এ নির্দিষ্ট 'regions' থেকে গাছ অপসারণের পর অবশিষ্ট গাছের সংখ্যা গণনা করে।\nপ্রতিটি অঞ্চল রাস্তার শুরু এবং শেষ বিন্দু নির্দেশ করে এমন দুটি পূর্ণসংখ্যার একটি তালিকা।\nফাংশনটি অপসারণের পর অবশিষ্ট গাছের সংখ্যা প্রদান করে।\nউদাহরণ:\n(count-remaining-trees 10 '((2 5) (7 9))) 4 প্রদান করে\n(count-remaining-trees 15 '((1 3) (5 10))) 7 প্রদান করে",
      "bg": "Напишете функция на Common Lisp `(defun count-remaining-trees (road-length regions)` за решаване на следния проблем:  \nБрои броя на останалите дървета на път с дължина 'road-length' след премахване на дървета в определени 'regions'.  \nВсеки регион е списък от две цели числа, представляващи началната и крайната точка на пътя.  \nФункцията връща броя на останалите дървета след премахването.  \nПример:  \n(count-remaining-trees 10 '((2 5) (7 9))) Връща 4  \n(count-remaining-trees 15 '((1 3) (5 10))) Връща 7",
      "zh": "编写一个 Common Lisp 函数 `(defun count-remaining-trees (road-length regions)` 来解决以下问题：\n计算在长度为 'road-length' 的道路上，在指定的 'regions' 中移除树木后剩余的树木数量。\n每个区域是一个由两个整数表示的列表，代表道路上的起点和终点。\n该函数返回移除后的剩余树木数量。\n示例：\n(count-remaining-trees 10 '((2 5) (7 9))) 返回 4\n(count-remaining-trees 15 '((1 3) (5 10))) 返回 7",
      "fr": "Écrire une fonction Common Lisp `(defun count-remaining-trees (road-length regions)` pour résoudre le problème suivant :\nCompte le nombre d'arbres restants sur une route de longueur 'road-length' après avoir enlevé des arbres dans les 'regions' spécifiées.\nChaque région est une liste de deux entiers représentant les points de début et de fin sur la route.\nLa fonction retourne le nombre d'arbres restants après le retrait.\nExemple :\n(count-remaining-trees 10 '((2 5) (7 9))) Retourne 4\n(count-remaining-trees 15 '((1 3) (5 10))) Retourne 7",
      "de": "Schreiben Sie eine Common Lisp-Funktion `(defun count-remaining-trees (road-length regions)`, um das folgende Problem zu lösen:\nZählt die Anzahl der verbleibenden Bäume auf einer Straße der Länge 'road-length', nachdem Bäume in angegebenen 'regions' entfernt wurden.\nJede Region ist eine Liste von zwei ganzen Zahlen, die die Start- und Endpunkte auf der Straße darstellen.\nDie Funktion gibt die Anzahl der verbleibenden Bäume nach der Entfernung zurück.\nBeispiel:\n(count-remaining-trees 10 '((2 5) (7 9))) Gibt 4 zurück\n(count-remaining-trees 15 '((1 3) (5 10))) Gibt 7 zurück",
      "ha": "Rubuta aikin Common Lisp `(defun count-remaining-trees (road-length regions)` don warware matsalar mai zuwa:\nYana ƙididdige yawan bishiyoyin da suka rage a kan hanya mai tsawon 'road-length' bayan cire bishiyoyi a cikin 'regions' da aka fayyace.\nKowane yanki jerin lambobi biyu ne da ke wakiltar wuraren farawa da ƙarewa a kan hanya.\nAikin yana dawowa da yawan bishiyoyin da suka rage bayan cirewa.\nMisali:\n(count-remaining-trees 10 '((2 5) (7 9))) Yana dawowa 4\n(count-remaining-trees 15 '((1 3) (5 10))) Yana dawowa 7",
      "hi": "लिखें एक Common Lisp फ़ंक्शन `(defun count-remaining-trees (road-length regions)` निम्नलिखित समस्या को हल करने के लिए:\nगणना करता है सड़क की लंबाई 'road-length' पर बचे हुए पेड़ों की संख्या को, जब निर्दिष्ट 'regions' में पेड़ों को हटा दिया जाता है।\nप्रत्येक क्षेत्र दो पूर्णांकों की सूची है जो सड़क पर आरंभ और अंत बिंदुओं का प्रतिनिधित्व करती है।\nफ़ंक्शन हटाने के बाद बचे हुए पेड़ों की संख्या लौटाता है।\nउदाहरण:\n(count-remaining-trees 10 '((2 5) (7 9))) 4 लौटाता है\n(count-remaining-trees 15 '((1 3) (5 10))) 7 लौटाता है",
      "hu": "Írj egy Common Lisp függvényt `(defun count-remaining-trees (road-length regions)` a következő probléma megoldására:\nMegszámolja az 'road-length' hosszúságú úton megmaradó fák számát, miután eltávolította a fákat a megadott 'regions' régiókban.\nMinden régió egy két egész számot tartalmazó lista, amely az út kezdő és végpontját jelöli.\nA függvény visszaadja az eltávolítás után megmaradt fák számát.\nPélda:\n(count-remaining-trees 10 '((2 5) (7 9))) Visszaadja 4\n(count-remaining-trees 15 '((1 3) (5 10))) Visszaadja 7"
    },
    "instruction_bertscore": {
      "sq": "0.9924484701738157",
      "hy": "0.9792739128909146",
      "bn": "0.9637894829069589",
      "bg": "0.9847900772026345",
      "zh": "0.9732651452342281",
      "fr": "0.9933969302432573",
      "de": "0.983961788513719",
      "ha": "0.9712073344867067",
      "hi": "0.9872894432871965",
      "hu": "0.9846311728978066"
    },
    "level": "easy",
    "test": "(defun test-count-remaining-trees ()\n(assert (equal (count-remaining-trees 10 '((2 5) (7 9))) 4))\n(assert (equal (count-remaining-trees 15 '((1 3) (5 10))) 7))\n(assert (equal (count-remaining-trees 20 '((0 5) (10 15))) 9))\n(assert (equal (count-remaining-trees 30 '((3 6) (8 10) (15 20))) 18))\n(assert (equal (count-remaining-trees 50 '((0 10) (20 30) (40 50))) 18)))\n\n(test-count-remaining-trees)",
    "entry_point": "count-remaining-trees",
    "signature": "(defun count-remaining-trees (road-length regions)",
    "docstring": {
      "en": "Counts the number of trees remaining on a road of length 'road-length' after removing trees in specified 'regions'.\nEach region is a list of two integers representing the start and end points on the road.\nThe function returns the number of trees remaining after the removal.\nExample:\n(count-remaining-trees 10 '((2 5) (7 9))) Returns 4\n(count-remaining-trees 15 '((1 3) (5 10))) Returns 7",
      "sq": "Numëron numrin e pemëve të mbetura në një rrugë me gjatësi 'road-length' pasi të hiqen pemët në 'regions' të specifikuara. Çdo rajon është një listë me dy numra të plotë që përfaqësojnë pikat e fillimit dhe të mbarimit në rrugë. Funksioni kthen numrin e pemëve të mbetura pas heqjes. Shembull: (count-remaining-trees 10 '((2 5) (7 9))) Kthen 4 (count-remaining-trees 15 '((1 3) (5 10))) Kthen 7",
      "hy": "Հաշվում է ճանապարհի վրա մնացած ծառերի քանակը, որի երկարությունը 'road-length' է՝ որոշակի 'regions'-ներում ծառերը հեռացնելուց հետո:\nՅուրաքանչյուր շրջան ցուցակ է՝ բաղկացած երկու ամբողջ թվերից, որոնք ներկայացնում են ճանապարհի վրա սկիզբն ու վերջը:\nՖունկցիան վերադարձնում է հեռացումից հետո մնացած ծառերի քանակը:\nՕրինակ:\n(count-remaining-trees 10 '((2 5) (7 9))) Վերադարձնում է 4\n(count-remaining-trees 15 '((1 3) (5 10))) Վերադարձնում է 7",
      "bn": "গণনা করে কতগুলি গাছ একটি 'road-length' দৈর্ঘ্যের রাস্তায় অবশিষ্ট রয়েছে নির্দিষ্ট 'regions' থেকে গাছ অপসারণের পর। \nপ্রতিটি অঞ্চল রাস্তার শুরু এবং শেষ পয়েন্ট প্রতিনিধিত্বকারী দুটি পূর্ণসংখ্যার একটি তালিকা। \nফাংশনটি অপসারণের পর অবশিষ্ট গাছের সংখ্যা প্রদান করে। \nউদাহরণ:\n(count-remaining-trees 10 '((2 5) (7 9))) Returns 4\n(count-remaining-trees 15 '((1 3) (5 10))) Returns 7",
      "bg": "Брои броя на дърветата, останали на път с дължина 'road-length', след премахване на дървета в определени 'regions'.\nВсеки регион е списък от две цели числа, представляващи началната и крайната точка на пътя.\nФункцията връща броя на дърветата, останали след премахването.\nПример:\n(count-remaining-trees 10 '((2 5) (7 9))) Връща 4\n(count-remaining-trees 15 '((1 3) (5 10))) Връща 7",
      "zh": "计算在移除指定“区域”中的树木后，长度为“road-length”的道路上剩余的树木数量。  \n每个区域是一个由两个整数组成的列表，表示道路上的起始和结束点。  \n该函数返回移除后的剩余树木数量。  \n示例：  \n(count-remaining-trees 10 '((2 5) (7 9))) 返回 4  \n(count-remaining-trees 15 '((1 3) (5 10))) 返回 7  ",
      "fr": "Compte le nombre d'arbres restants sur une route de longueur 'road-length' après avoir retiré les arbres dans les 'regions' spécifiées.  \nChaque région est une liste de deux entiers représentant les points de début et de fin sur la route.  \nLa fonction renvoie le nombre d'arbres restants après le retrait.  \nExemple:  \n(count-remaining-trees 10 '((2 5) (7 9))) Renvoie 4  \n(count-remaining-trees 15 '((1 3) (5 10))) Renvoie 7  ",
      "de": "Zählt die Anzahl der verbleibenden Bäume auf einer Straße der Länge 'road-length', nachdem Bäume in angegebenen 'regions' entfernt wurden.  \nJede Region ist eine Liste von zwei ganzen Zahlen, die die Start- und Endpunkte auf der Straße darstellen.  \nDie Funktion gibt die Anzahl der verbleibenden Bäume nach der Entfernung zurück.  \nBeispiel:  \n(count-remaining-trees 10 '((2 5) (7 9))) Gibt 4 zurück  \n(count-remaining-trees 15 '((1 3) (5 10))) Gibt 7 zurück  ",
      "ha": "Yana ƙididdige adadin itatuwa da suka rage a kan hanya mai tsawon 'road-length' bayan cire itatuwa a wuraren da aka fayyace 'regions'.\nKowane yanki jerin lambobi biyu ne da ke wakiltar wuraren farawa da ƙarewa a kan hanya.\nAikin yana dawo da adadin itatuwa da suka rage bayan cirewa.\nMisali:\n(count-remaining-trees 10 '((2 5) (7 9))) Yana dawowa 4\n(count-remaining-trees 15 '((1 3) (5 10))) Yana dawowa 7",
      "hi": "सड़क की लंबाई 'road-length' पर शेष पेड़ों की संख्या की गणना करता है, निर्दिष्ट 'regions' में पेड़ों को हटाने के बाद।\nप्रत्येक क्षेत्र सड़क पर प्रारंभ और अंत बिंदुओं का प्रतिनिधित्व करने वाले दो पूर्णांकों की एक सूची है।\nयह फ़ंक्शन हटाने के बाद शेष पेड़ों की संख्या लौटाता है।\nउदाहरण:\n(count-remaining-trees 10 '((2 5) (7 9))) 4 लौटाता है\n(count-remaining-trees 15 '((1 3) (5 10))) 7 लौटाता है",
      "hu": "Számolja meg a megmaradt fák számát egy 'road-length' hosszúságú úton, miután eltávolította a fákat a megadott 'regions' területeken.\nMinden régió két egész számot tartalmazó lista, amely az út kezdő- és végpontját jelöli.\nA függvény visszaadja az eltávolítás után megmaradt fák számát.\nPélda:\n(count-remaining-trees 10 '((2 5) (7 9))) Visszaadja: 4\n(count-remaining-trees 15 '((1 3) (5 10))) Visszaadja: 7"
    },
    "docstring_bertscore": {
      "sq": "0.9885765681563026",
      "hy": "0.968851578167633",
      "bn": "0.9541543203837185",
      "bg": "0.9834648153003697",
      "zh": "0.9560409117427878",
      "fr": "0.986563250614133",
      "de": "0.9873792242194243",
      "ha": "0.9624880566504183",
      "hi": "0.9490409784847373",
      "hu": "0.9526193047990809"
    }
  },
  {
    "task_id": "Common Lisp/25",
    "prompt": {
      "en": "(defun larger-prime-factor (n)\n;; Finds the larger prime factor of a positive integer 'n', which is known to be the product of two distinct prime numbers.\n;; The function returns the larger of the two prime factors.\n;; Example:\n;; (larger-prime-factor 15) ;; Returns 5\n;; (larger-prime-factor 33) ;; Returns 11",
      "sq": "(defun larger-prime-factor (n)\n;; Gjen faktorin më të madh prim të një numri të plotë pozitiv 'n', i cili dihet se është prodhimi i dy numrave të ndryshëm prim.\n;; Funksioni kthen më të madhin nga dy faktorët prim.\n;; Shembull:\n;; (larger-prime-factor 15) ;; Kthen 5\n;; (larger-prime-factor 33) ;; Kthen 11",
      "hy": "(defun larger-prime-factor (n)\n;; Գտնում է դրական ամբողջ թիվ 'n'-ի ավելի մեծ պարզ գործակիցը, որը հայտնի է որպես երկու տարբեր պարզ թվերի արտադրյալ:\n;; Ֆունկցիան վերադարձնում է երկու պարզ գործակիցներից մեծը:\n;; Օրինակ:\n;; (larger-prime-factor 15) ;; Վերադարձնում է 5\n;; (larger-prime-factor 33) ;; Վերադարձնում է 11",
      "bn": "(defun larger-prime-factor (n)\n;; একটি ধনাত্মক পূর্ণসংখ্যা 'n' এর বৃহত্তর মৌলিক গুণক খুঁজে বের করে, যা দুটি পৃথক মৌলিক সংখ্যার গুণফল হিসেবে পরিচিত।\n;; ফাংশনটি দুটি মৌলিক গুণকের মধ্যে বৃহত্তরটি ফেরত দেয়।\n;; উদাহরণ:\n;; (larger-prime-factor 15) ;; 5 ফেরত দেয়\n;; (larger-prime-factor 33) ;; 11 ফেরত দেয়",
      "bg": "(defun larger-prime-factor (n)\n;; Намира по-големия прост множител на положително цяло число 'n', което е известно като произведение на две различни прости числа.\n;; Функцията връща по-големия от двата прости множителя.\n;; Пример:\n;; (larger-prime-factor 15) ;; Връща 5\n;; (larger-prime-factor 33) ;; Връща 11",
      "zh": "(defun larger-prime-factor (n)\n;; 查找正整数 'n' 的较大质因数，'n' 已知是两个不同质数的乘积。\n;; 该函数返回两个质因数中较大的一个。\n;; 示例:\n;; (larger-prime-factor 15) ;; 返回 5\n;; (larger-prime-factor 33) ;; 返回 11",
      "fr": "(defun larger-prime-factor (n)\n;; Trouve le plus grand facteur premier d'un entier positif 'n', qui est connu pour être le produit de deux nombres premiers distincts.\n;; La fonction renvoie le plus grand des deux facteurs premiers.\n;; Exemple:\n;; (larger-prime-factor 15) ;; Renvoie 5\n;; (larger-prime-factor 33) ;; Renvoie 11",
      "de": "(defun larger-prime-factor (n)\n;; Findet den größeren Primfaktor einer positiven ganzen Zahl 'n', die als Produkt von zwei verschiedenen Primzahlen bekannt ist.\n;; Die Funktion gibt den größeren der beiden Primfaktoren zurück.\n;; Beispiel:\n;; (larger-prime-factor 15) ;; Gibt 5 zurück\n;; (larger-prime-factor 33) ;; Gibt 11 zurück",
      "ha": "(defun larger-prime-factor (n)\n;; Nemi babbar lamba mai farko daga cikin lambobi masu farko na lamba mai kyau 'n', wanda aka sani yana da samfurin lambobi biyu masu farko daban-daban.\n;; Aikin yana dawo da babbar daga cikin lambobi masu farko biyu.\n;; Misali:\n;; (larger-prime-factor 15) ;; Yana dawowa 5\n;; (larger-prime-factor 33) ;; Yana dawowa 11",
      "hi": "(defun larger-prime-factor (n)\n;; एक धनात्मक पूर्णांक 'n' का बड़ा अभाज्य गुणक खोजता है, जो दो भिन्न अभाज्य संख्याओं का गुणनफल होता है।\n;; यह फ़ंक्शन दोनों अभाज्य गुणकों में से बड़े को लौटाता है।\n;; उदाहरण:\n;; (larger-prime-factor 15) ;; 5 लौटाता है\n;; (larger-prime-factor 33) ;; 11 लौटाता है",
      "hu": "(defun larger-prime-factor (n)\n;; Megkeresi egy pozitív egész szám 'n' nagyobb prímtényezőjét, amelyről ismert, hogy két különböző prímszám szorzata.\n;; A függvény visszaadja a két prímtényező közül a nagyobbat.\n;; Példa:\n;; (larger-prime-factor 15) ;; Visszaadja: 5\n;; (larger-prime-factor 33) ;; Visszaadja: 11"
    },
    "prompt_bertscore": {
      "sq": "0.9916732157966365",
      "hy": "0.98848778037598",
      "bn": "0.98580070858134",
      "bg": "0.984389042463325",
      "zh": "0.970189751044665",
      "fr": "0.9951432885533159",
      "de": "0.9965207902457929",
      "ha": "0.9435365333654986",
      "hi": "0.9809326752029369",
      "hu": "0.9850065843179625"
    },
    "canonical_solution": "(let ((factor 2))\n(loop while (> n factor)\nif (zerop (mod n factor))\ndo (setq n (/ n factor))\nelse\ndo (incf factor))\nn))",
    "instruction": {
      "en": "Write a Common Lisp function `(defun larger-prime-factor (n)` to solve the following problem:\nFinds the larger prime factor of a positive integer 'n', which is known to be the product of two distinct prime numbers.\nThe function returns the larger of the two prime factors.\nExample:\n(larger-prime-factor 15) Returns 5\n(larger-prime-factor 33) Returns 11",
      "sq": "Shkruani një funksion në Common Lisp `(defun larger-prime-factor (n)` për të zgjidhur problemin e mëposhtëm:\nGjen faktorin më të madh kryesor të një numri të plotë pozitiv 'n', i cili dihet se është prodhimi i dy numrave të ndryshëm kryesorë.\nFunksioni kthen më të madhin nga dy faktorët kryesorë.\nShembull:\n(larger-prime-factor 15) Kthen 5\n(larger-prime-factor 33) Kthen 11",
      "hy": "Գրեք Common Lisp ֆունկցիա `(defun larger-prime-factor (n)` հետևյալ խնդիրը լուծելու համար:\nԳտնում է դրական ամբողջ թիվ 'n'-ի ավելի մեծ պարզ գործակիցը, որը հայտնի է, որ երկու տարբեր պարզ թվերի արտադրյալն է:\nՖունկցիան վերադարձնում է երկու պարզ գործակիցներից ավելի մեծը:\nՕրինակ:\n(larger-prime-factor 15) Վերադարձնում է 5\n(larger-prime-factor 33) Վերադարձնում է 11",
      "bn": "একটি Common Lisp ফাংশন `(defun larger-prime-factor (n)` লিখুন নিম্নলিখিত সমস্যার সমাধানের জন্য:\nএকটি ধনাত্মক পূর্ণসংখ্যা 'n'-এর বড় মৌলিক গুণক খুঁজে বের করে, যা দুটি ভিন্ন মৌলিক সংখ্যার গুণফল হিসাবে পরিচিত।\nফাংশনটি দুটি মৌলিক গুণকের মধ্যে বড়টি ফেরত দেয়।\nউদাহরণ:\n(larger-prime-factor 15) 5 ফেরত দেয়\n(larger-prime-factor 33) 11 ফেরত দেয়",
      "bg": "Напишете функция на Common Lisp `(defun larger-prime-factor (n)` за решаване на следния проблем:\nНамира по-големия прост множител на положително цяло число 'n', което е известно, че е произведение на два различни прости числа.\nФункцията връща по-големия от двата прости множителя.\nПример:\n(larger-prime-factor 15) Връща 5\n(larger-prime-factor 33) Връща 11",
      "zh": "编写一个 Common Lisp 函数 `(defun larger-prime-factor (n)` 来解决以下问题：\n找到正整数 'n' 的较大质因数，该整数已知是两个不同质数的乘积。\n函数返回两个质因数中较大的一个。\n示例：\n(larger-prime-factor 15) 返回 5\n(larger-prime-factor 33) 返回 11",
      "fr": "Écrire une fonction Common Lisp `(defun larger-prime-factor (n)` pour résoudre le problème suivant :  \nTrouve le plus grand facteur premier d'un entier positif 'n', qui est connu pour être le produit de deux nombres premiers distincts.  \nLa fonction renvoie le plus grand des deux facteurs premiers.  \nExemple :  \n(larger-prime-factor 15) Renvoie 5  \n(larger-prime-factor 33) Renvoie 11",
      "de": "Schreiben Sie eine Common Lisp-Funktion `(defun larger-prime-factor (n)` um das folgende Problem zu lösen:\nFindet den größeren Primfaktor einer positiven ganzen Zahl 'n', die als Produkt von zwei verschiedenen Primzahlen bekannt ist.\nDie Funktion gibt den größeren der beiden Primfaktoren zurück.\nBeispiel:\n(larger-prime-factor 15) Gibt 5 zurück\n(larger-prime-factor 33) Gibt 11 zurück",
      "ha": "Rubuta wani aikin Common Lisp `(defun larger-prime-factor (n)` don warware matsalar mai zuwa:\nNemo babbar lambar firam na wani cikakken lamba 'n', wanda aka sani cewa shi ne samfurin lambobi biyu na firam daban-daban.\nAikin yana mayar da babbar daga cikin lambobin firam biyu.\nMisali:\n(larger-prime-factor 15) Yana mayar da 5\n(larger-prime-factor 33) Yana mayar da 11",
      "hi": "एक Common Lisp फ़ंक्शन `(defun larger-prime-factor (n)` लिखें ताकि निम्नलिखित समस्या का समाधान किया जा सके:\nएक धनात्मक पूर्णांक 'n' का बड़ा अभाज्य गुणक खोजें, जो दो भिन्न अभाज्य संख्याओं का गुणनफल है।\nफ़ंक्शन दो अभाज्य गुणकों में से बड़े को लौटाता है।\nउदाहरण:\n(larger-prime-factor 15) 5 लौटाता है\n(larger-prime-factor 33) 11 लौटाता है",
      "hu": "Írj egy Common Lisp függvényt `(defun larger-prime-factor (n)` a következő probléma megoldására:\nMegtalálja egy pozitív egész szám 'n' nagyobb prímtényezőjét, amelyről ismert, hogy két különböző prímszám szorzata.\nA függvény visszaadja a két prímtényező közül a nagyobbat.\nPélda:\n(larger-prime-factor 15) Visszaadja 5\n(larger-prime-factor 33) Visszaadja 11"
    },
    "instruction_bertscore": {
      "sq": "0.984389042463325",
      "hy": "0.9966516876668949",
      "bn": "0.9788200424702499",
      "bg": "0.9920190312900182",
      "zh": "0.9871271622658909",
      "fr": "0.985862879890604",
      "de": "0.9966516876668949",
      "ha": "0.9740521188038884",
      "hi": "0.9761782584024858",
      "hu": "0.9966516876668949"
    },
    "level": "easy",
    "test": "(defun test-larger-prime-factor ()\n(assert (equal (larger-prime-factor 21) 7))\n(assert (equal (larger-prime-factor 15) 5))\n(assert (equal (larger-prime-factor 33) 11))\n(assert (equal (larger-prime-factor 35) 7))\n(assert (equal (larger-prime-factor 77) 11))\n(assert (equal (larger-prime-factor 26) 13)))\n\n(test-larger-prime-factor)",
    "entry_point": "larger-prime-factor",
    "signature": "(defun larger-prime-factor (n)",
    "docstring": {
      "en": "Finds the larger prime factor of a positive integer 'n', which is known to be the product of two distinct prime numbers.\nThe function returns the larger of the two prime factors.\nExample:\n(larger-prime-factor 15) Returns 5\n(larger-prime-factor 33) Returns 11",
      "sq": "Gjen faktorin më të madh prim të një numri të plotë pozitiv 'n', i cili dihet se është prodhimi i dy numrave të ndryshëm prim.\nFunksioni kthen më të madhin nga dy faktorët prim.\nShembull:\n(larger-prime-factor 15) Kthen 5\n(larger-prime-factor 33) Kthen 11",
      "hy": "Գտնում է դրական ամբողջ թիվ 'n'-ի մեծագույն պարզ գործակիցը, որը հայտնի է որպես երկու տարբեր պարզ թվերի արտադրյալ։\nՖունկցիան վերադարձնում է երկու պարզ գործակիցներից մեծագույնը։\nՕրինակ:\n(larger-prime-factor 15) Վերադարձնում է 5\n(larger-prime-factor 33) Վերադարձնում է 11",
      "bn": "একটি ধনাত্মক পূর্ণসংখ্যা 'n' এর বৃহত্তর মৌলিক গুণক খুঁজে বের করে, যা দুটি ভিন্ন মৌলিক সংখ্যার গুণফল হিসেবে পরিচিত।\nফাংশনটি দুটি মৌলিক গুণকের মধ্যে বড়টি ফেরত দেয়।\nউদাহরণ:\n(larger-prime-factor 15) 5 ফেরত দেয়\n(larger-prime-factor 33) 11 ফেরত দেয়",
      "bg": "Намира по-големия прост множител на положително цяло число 'n', което е известно, че е произведение на две различни прости числа.\nФункцията връща по-големия от двата прости множителя.\nПример:\n(larger-prime-factor 15) Връща 5\n(larger-prime-factor 33) Връща 11",
      "zh": "找到一个正整数 'n' 的较大质因数，该整数已知是两个不同质数的乘积。\n该函数返回两个质因数中较大的一个。\n示例：\n(larger-prime-factor 15) 返回 5\n(larger-prime-factor 33) 返回 11",
      "fr": "Trouve le plus grand facteur premier d'un entier positif 'n', qui est connu pour être le produit de deux nombres premiers distincts.\nLa fonction renvoie le plus grand des deux facteurs premiers.\nExemple :\n(larger-prime-factor 15) Renvoie 5\n(larger-prime-factor 33) Renvoie 11",
      "de": "Findet den größeren Primfaktor einer positiven ganzen Zahl 'n', die als Produkt von zwei verschiedenen Primzahlen bekannt ist. Die Funktion gibt den größeren der beiden Primfaktoren zurück. \n\nBeispiel:\n(larger-prime-factor 15) Gibt 5 zurück\n(larger-prime-factor 33) Gibt 11 zurück",
      "ha": "Yana nemo babbar abin da ke ninka lamba mai kyau na 'n', wanda aka sani cewa yana samuwa daga ninkin lambobi biyu masu kyau daban-daban.\nAikin yana dawo da babbar daga cikin lambobin ninkin guda biyu.\nMisali:\n(larger-prime-factor 15) Yana dawowa 5\n(larger-prime-factor 33) Yana dawowa 11",
      "hi": "दो भिन्न अभाज्य संख्याओं के गुणनफल के रूप में ज्ञात एक धनात्मक पूर्णांक 'n' के बड़े अभाज्य गुणक को खोजता है। \nयह फ़ंक्शन दो अभाज्य गुणकों में से बड़े को लौटाता है।\n\nउदाहरण:\n(larger-prime-factor 15) 5 लौटाता है\n(larger-prime-factor 33) 11 लौटाता है",
      "hu": "Megkeresi egy pozitív egész szám 'n' nagyobb prímtényezőjét, amelyről ismert, hogy két különböző prímszám szorzata.\nA függvény visszaadja a két prímtényező közül a nagyobbat.\nPélda:\n(larger-prime-factor 15) Visszaadja 5\n(larger-prime-factor 33) Visszaadja 11"
    },
    "docstring_bertscore": {
      "sq": "0.9776258766194681",
      "hy": "0.9649282308814319",
      "bn": "0.9766025328963763",
      "bg": "1",
      "zh": "0.9773479927164003",
      "fr": "0.9820660601571221",
      "de": "0.9951985077992437",
      "ha": "0.9923394220946274",
      "hi": "0.9587645315275383",
      "hu": "0.9951985077992437"
    }
  },
  {
    "task_id": "Common Lisp/26",
    "prompt": {
      "en": "(defun day-of-max-unhappiness (weekly-schedule)\n;; Analyzes a weekly schedule to find out the day when Binbin will be most unhappy.\n;; 'weekly-schedule' is a list of seven pairs (one for each day) representing school hours and extra class hours.\n;; The function returns the day of the week (1-7) on which Binbin is most unhappy, or 0 if she is not unhappy any day.\n;; Example:\n;; (day-of-max-unhappiness '((5 3) (6 2) (7 1) (5 3) (5 4) (0 4) (0 3))) ;; Returns 3\n;; (day-of-max-unhappiness '((4 3) (4 3) (4 3) (4 3) (4 3) (2 4) (2 4))) ;; Returns 0",
      "sq": "(defun day-of-max-unhappiness (weekly-schedule)\n;; Analizon një orar javor për të gjetur ditën kur Binbin do të jetë më e pakënaqur.\n;; 'weekly-schedule' është një listë me shtatë çifte (një për çdo ditë) që përfaqësojnë orët e shkollës dhe orët e klasave shtesë.\n;; Funksioni kthen ditën e javës (1-7) në të cilën Binbin është më e pakënaqur, ose 0 nëse ajo nuk është e pakënaqur asnjë ditë.\n;; Shembull:\n;; (day-of-max-unhappiness '((5 3) (6 2) (7 1) (5 3) (5 4) (0 4) (0 3))) ;; Kthen 3\n;; (day-of-max-unhappiness '((4 3) (4 3) (4 3) (4 3) (4 3) (2 4) (2 4))) ;; Kthen 0",
      "hy": "(defun day-of-max-unhappiness (weekly-schedule)\n;; Վերլուծում է շաբաթական գրաֆիկը՝ պարզելու համար, թե որ օրն է Բինբինը ամենից դժգոհ:\n;; 'weekly-schedule'-ը յոթ զույգերի ցուցակ է (յուրաքանչյուր օրվա համար մեկ), որոնք ներկայացնում են դպրոցական ժամերը և լրացուցիչ դասերի ժամերը:\n;; Ֆունկցիան վերադարձնում է շաբաթվա օրը (1-7), երբ Բինբինը ամենից դժգոհ է, կամ 0, եթե նա ոչ մի օր դժգոհ չէ:\n;; Օրինակ:\n;; (day-of-max-unhappiness '((5 3) (6 2) (7 1) (5 3) (5 4) (0 4) (0 3))) ;; Վերադարձնում է 3\n;; (day-of-max-unhappiness '((4 3) (4 3) (4 3) (4 3) (4 3) (2 4) (2 4))) ;; Վերադարձնում է 0",
      "bn": "(defun day-of-max-unhappiness (weekly-schedule)\n;; একটি সাপ্তাহিক সময়সূচী বিশ্লেষণ করে বের করা যে দিন বিনবিন সবচেয়ে বেশি অসুখী হবে।\n;; 'weekly-schedule' হল সাতটি জোড়ার একটি তালিকা (প্রতিটি দিনের জন্য একটি) যা স্কুলের ঘন্টা এবং অতিরিক্ত ক্লাসের ঘন্টা উপস্থাপন করে।\n;; ফাংশনটি সেই সপ্তাহের দিনটি (১-৭) ফেরত দেয় যেদিন বিনবিন সবচেয়ে বেশি অসুখী, অথবা 0 যদি সে কোনো দিনই অসুখী না হয়।\n;; উদাহরণ:\n;; (day-of-max-unhappiness '((5 3) (6 2) (7 1) (5 3) (5 4) (0 4) (0 3))) ;; 3 ফেরত দেয়\n;; (day-of-max-unhappiness '((4 3) (4 3) (4 3) (4 3) (4 3) (2 4) (2 4))) ;; 0 ফেরত দেয়",
      "bg": "(defun day-of-max-unhappiness (weekly-schedule)\n;; Анализира седмичен график, за да открие деня, в който Бинбин ще бъде най-нещастна.\n;; 'weekly-schedule' е списък от седем двойки (по една за всеки ден), представляващи учебни часове и часове за допълнителни класове.\n;; Функцията връща деня от седмицата (1-7), в който Бинбин е най-нещастна, или 0, ако тя не е нещастна нито един ден.\n;; Пример:\n;; (day-of-max-unhappiness '((5 3) (6 2) (7 1) (5 3) (5 4) (0 4) (0 3))) ;; Връща 3\n;; (day-of-max-unhappiness '((4 3) (4 3) (4 3) (4 3) (4 3) (2 4) (2 4))) ;; Връща 0",
      "zh": "(defun day-of-max-unhappiness (weekly-schedule)\n;; 分析每周的日程安排，以找出彬彬最不开心的那一天。\n;; 'weekly-schedule' 是一个包含七对元素的列表（每一天对应一个），表示上学时间和课外班时间。\n;; 该函数返回彬彬最不开心的那一天（1-7），如果她没有任何一天不开心，则返回0。\n;; 示例:\n;; (day-of-max-unhappiness '((5 3) (6 2) (7 1) (5 3) (5 4) (0 4) (0 3))) ;; 返回 3\n;; (day-of-max-unhappiness '((4 3) (4 3) (4 3) (4 3) (4 3) (2 4) (2 4))) ;; 返回 0",
      "fr": "(defun day-of-max-unhappiness (weekly-schedule)\n;; Analyse un emploi du temps hebdomadaire pour déterminer le jour où Binbin sera le plus malheureux.\n;; 'weekly-schedule' est une liste de sept paires (une pour chaque jour) représentant les heures d'école et les heures de cours supplémentaires.\n;; La fonction renvoie le jour de la semaine (1-7) où Binbin est le plus malheureux, ou 0 si elle n'est pas malheureuse un jour quelconque.\n;; Exemple :\n;; (day-of-max-unhappiness '((5 3) (6 2) (7 1) (5 3) (5 4) (0 4) (0 3))) ;; Renvoie 3\n;; (day-of-max-unhappiness '((4 3) (4 3) (4 3) (4 3) (4 3) (2 4) (2 4))) ;; Renvoie 0",
      "de": "(defun day-of-max-unhappiness (weekly-schedule)\n;; Analysiert einen Wochenplan, um herauszufinden, an welchem Tag Binbin am unglücklichsten sein wird.\n;; 'weekly-schedule' ist eine Liste von sieben Paaren (eines für jeden Tag), die Schulstunden und zusätzliche Unterrichtsstunden darstellen.\n;; Die Funktion gibt den Wochentag (1-7) zurück, an dem Binbin am unglücklichsten ist, oder 0, wenn sie an keinem Tag unglücklich ist.\n;; Beispiel:\n;; (day-of-max-unhappiness '((5 3) (6 2) (7 1) (5 3) (5 4) (0 4) (0 3))) ;; Gibt 3 zurück\n;; (day-of-max-unhappiness '((4 3) (4 3) (4 3) (4 3) (4 3) (2 4) (2 4))) ;; Gibt 0 zurück",
      "ha": "(defun day-of-max-unhappiness (weekly-schedule)\n;; Nazarin jadawalin mako-mako don gano ranar da Binbin za ta fi rashin jin daɗi.\n;; 'weekly-schedule' jerin ma'aurata guda bakwai ne (daya don kowace rana) suna wakiltar awanni makaranta da awanni karin aji.\n;; Aikin yana dawo da ranar mako (1-7) a kan wacce Binbin za ta fi rashin jin daɗi, ko 0 idan ba ta ji rashin jin daɗi a kowace rana ba.\n;; Misali:\n;; (day-of-max-unhappiness '((5 3) (6 2) (7 1) (5 3) (5 4) (0 4) (0 3))) ;; Yana dawo da 3\n;; (day-of-max-unhappiness '((4 3) (4 3) (4 3) (4 3) (4 3) (2 4) (2 4))) ;; Yana dawo da 0",
      "hi": "(defun day-of-max-unhappiness (weekly-schedule)\n;; एक साप्ताहिक कार्यक्रम का विश्लेषण करता है ताकि यह पता लगाया जा सके कि बिनबिन किस दिन सबसे अधिक दुखी होगी।\n;; 'weekly-schedule' सात जोड़ों की एक सूची है (प्रत्येक दिन के लिए एक) जो स्कूल के घंटे और अतिरिक्त कक्षा के घंटे दर्शाती है।\n;; फ़ंक्शन उस सप्ताह के दिन (1-7) को लौटाता है जिस दिन बिनबिन सबसे अधिक दुखी होती है, या 0 यदि वह किसी दिन दुखी नहीं होती है।\n;; उदाहरण:\n;; (day-of-max-unhappiness '((5 3) (6 2) (7 1) (5 3) (5 4) (0 4) (0 3))) ;; 3 लौटाता है\n;; (day-of-max-unhappiness '((4 3) (4 3) (4 3) (4 3) (4 3) (2 4) (2 4))) ;; 0 लौटाता है",
      "hu": "(defun day-of-max-unhappiness (weekly-schedule)\n;; Elemzi a heti beosztást, hogy megtudja, melyik napon lesz Binbin a legboldogtalanabb.\n;; A 'weekly-schedule' egy hét párból álló lista (egy minden napra), amely az iskolai órákat és a plusz órákat képviseli.\n;; A függvény visszaadja a hét napját (1-7), amelyen Binbin a legboldogtalanabb, vagy 0-t, ha egyetlen napon sem boldogtalan.\n;; Példa:\n;; (day-of-max-unhappiness '((5 3) (6 2) (7 1) (5 3) (5 4) (0 4) (0 3))) ;; Visszaadja 3\n;; (day-of-max-unhappiness '((4 3) (4 3) (4 3) (4 3) (4 3) (2 4) (2 4))) ;; Visszaadja 0"
    },
    "prompt_bertscore": {
      "sq": "0.9949174458100792",
      "hy": "0.9591592100946545",
      "bn": "0.9826724787104215",
      "bg": "0.9870856485162547",
      "zh": "0.9587532095958192",
      "fr": "0.9889873357842827",
      "de": "0.9798864889860261",
      "ha": "0.9876451902996299",
      "hi": "0.9886762806075821",
      "hu": "0.9620836451946312"
    },
    "canonical_solution": "(let ((max-unhappiness 0)\n(most-unhappy-day 0))\n(loop for day from 1 to 7\nfor hours in weekly-schedule\ndo (let ((total-hours (+ (first hours) (second hours))))\n(when (> total-hours max-unhappiness)\n(setq max-unhappiness total-hours)\n(setq most-unhappy-day day))))\n(if (> max-unhappiness 8) most-unhappy-day 0)))",
    "instruction": {
      "en": "Write a Common Lisp function `(defun day-of-max-unhappiness (weekly-schedule)` to solve the following problem:\nAnalyzes a weekly schedule to find out the day when Binbin will be most unhappy.\n'weekly-schedule' is a list of seven pairs (one for each day) representing school hours and extra class hours.\nThe function returns the day of the week (1-7) on which Binbin is most unhappy, or 0 if she is not unhappy any day.\nExample:\n(day-of-max-unhappiness '((5 3) (6 2) (7 1) (5 3) (5 4) (0 4) (0 3))) Returns 3\n(day-of-max-unhappiness '((4 3) (4 3) (4 3) (4 3) (4 3) (2 4) (2 4))) Returns 0",
      "sq": "Shkruani një funksion në Common Lisp `(defun day-of-max-unhappiness (weekly-schedule)` për të zgjidhur problemin e mëposhtëm:\nAnalizon një orar javor për të gjetur ditën kur Binbin do të jetë më e pakënaqur.\n'weekly-schedule' është një listë me shtatë çifte (një për çdo ditë) që përfaqësojnë orët e shkollës dhe orët e klasave shtesë.\nFunksioni kthen ditën e javës (1-7) në të cilën Binbin është më e pakënaqur, ose 0 nëse ajo nuk është e pakënaqur asnjë ditë.\nShembull:\n(day-of-max-unhappiness '((5 3) (6 2) (7 1) (5 3) (5 4) (0 4) (0 3))) Kthen 3\n(day-of-max-unhappiness '((4 3) (4 3) (4 3) (4 3) (4 3) (2 4) (2 4))) Kthen 0",
      "hy": "Գրեք Common Lisp ֆունկցիա `(defun day-of-max-unhappiness (weekly-schedule)` հետևյալ խնդիրը լուծելու համար:\nՎերլուծում է շաբաթական ժամանակացույցը՝ պարզելու համար, թե որ օրը Բինբինը ամենից դժբախտ կլինի:\n'weekly-schedule' ցուցակ է յոթ զույգերով (յուրաքանչյուր օրվա համար մեկ) ներկայացնող դպրոցական ժամերը և լրացուցիչ դասերի ժամերը:\nՖունկցիան վերադարձնում է շաբաթվա օրը (1-7), երբ Բինբինը ամենից դժբախտ է, կամ 0, եթե նա ոչ մի օր դժբախտ չէ:\nՕրինակ:\n(day-of-max-unhappiness '((5 3) (6 2) (7 1) (5 3) (5 4) (0 4) (0 3))) Վերադարձնում է 3\n(day-of-max-unhappiness '((4 3) (4 3) (4 3) (4 3) (4 3) (2 4) (2 4))) Վերադարձնում է 0",
      "bn": "একটি Common Lisp ফাংশন `(defun day-of-max-unhappiness (weekly-schedule)` লিখুন নিম্নলিখিত সমস্যার সমাধানের জন্য:\nএকটি সাপ্তাহিক সময়সূচী বিশ্লেষণ করে বের করুন যে দিন বিনবিন সবচেয়ে বেশি অসুখী হবে।\n'weekly-schedule' হল সাতটি জোড়ার একটি তালিকা (প্রতিটি দিনের জন্য একটি) যা স্কুলের ঘন্টা এবং অতিরিক্ত ক্লাসের ঘন্টা উপস্থাপন করে।\nফাংশনটি সপ্তাহের দিন (১-৭) ফেরত দেয় যেদিন বিনবিন সবচেয়ে বেশি অসুখী, অথবা ০ যদি সে কোনো দিন অসুখী না হয়।\nউদাহরণ:\n(day-of-max-unhappiness '((5 3) (6 2) (7 1) (5 3) (5 4) (0 4) (0 3))) 3 ফেরত দেয়\n(day-of-max-unhappiness '((4 3) (4 3) (4 3) (4 3) (4 3) (2 4) (2 4))) 0 ফেরত দেয়",
      "bg": "Напишете функция на Common Lisp `(defun day-of-max-unhappiness (weekly-schedule)` за решаване на следния проблем:\nАнализира седмичен график, за да открие деня, в който Бинбин ще бъде най-нещастна.\n'weekly-schedule' е списък от седем двойки (по една за всеки ден), представляващи учебни часове и часове за допълнителни класове.\nФункцията връща деня от седмицата (1-7), в който Бинбин е най-нещастна, или 0, ако тя не е нещастна нито един ден.\nПример:\n(day-of-max-unhappiness '((5 3) (6 2) (7 1) (5 3) (5 4) (0 4) (0 3))) Връща 3\n(day-of-max-unhappiness '((4 3) (4 3) (4 3) (4 3) (4 3) (2 4) (2 4))) Връща 0",
      "zh": "编写一个 Common Lisp 函数 `(defun day-of-max-unhappiness (weekly-schedule)` 来解决以下问题：\n分析每周的日程安排，以找出彬彬最不开心的那一天。\n'weekly-schedule' 是一个包含七对（每一天一个）表示学校时间和额外课程时间的列表。\n该函数返回彬彬最不开心的星期几（1-7），如果她没有一天不开心，则返回0。\n例子：\n(day-of-max-unhappiness '((5 3) (6 2) (7 1) (5 3) (5 4) (0 4) (0 3))) 返回 3\n(day-of-max-unhappiness '((4 3) (4 3) (4 3) (4 3) (4 3) (2 4) (2 4))) 返回 0",
      "fr": "Écrire une fonction Common Lisp `(defun day-of-max-unhappiness (weekly-schedule)` pour résoudre le problème suivant :\nAnalyse un emploi du temps hebdomadaire pour déterminer le jour où Binbin sera le plus malheureuse.\n'weekly-schedule' est une liste de sept paires (une pour chaque jour) représentant les heures d'école et les heures de cours supplémentaires.\nLa fonction renvoie le jour de la semaine (1-7) où Binbin est le plus malheureuse, ou 0 si elle n'est pas malheureuse n'importe quel jour.\nExemple :\n(day-of-max-unhappiness '((5 3) (6 2) (7 1) (5 3) (5 4) (0 4) (0 3))) Renvoie 3\n(day-of-max-unhappiness '((4 3) (4 3) (4 3) (4 3) (4 3) (2 4) (2 4))) Renvoie 0",
      "de": "Schreiben Sie eine Common Lisp-Funktion `(defun day-of-max-unhappiness (weekly-schedule)` um das folgende Problem zu lösen:\nAnalysiert einen Wochenplan, um herauszufinden, an welchem Tag Binbin am unglücklichsten sein wird.\n'weekly-schedule' ist eine Liste von sieben Paaren (eines für jeden Tag), die Schulstunden und zusätzliche Klassenstunden darstellen.\nDie Funktion gibt den Wochentag (1-7) zurück, an dem Binbin am unglücklichsten ist, oder 0, wenn sie an keinem Tag unglücklich ist.\nBeispiel:\n(day-of-max-unhappiness '((5 3) (6 2) (7 1) (5 3) (5 4) (0 4) (0 3))) Gibt 3 zurück\n(day-of-max-unhappiness '((4 3) (4 3) (4 3) (4 3) (4 3) (2 4) (2 4))) Gibt 0 zurück",
      "ha": "Rubuta wani aikin Common Lisp `(defun day-of-max-unhappiness (weekly-schedule)` don warware matsalar mai zuwa:  \nNazarin jadawalin mako-mako don gano ranar da Binbin zai fi rashin jin daɗi.  \n'weekly-schedule' jerin ma'aurata bakwai ne (daya don kowace rana) da ke wakiltar awannin makaranta da awannin karin aji.  \nAikin yana dawo da ranar mako (1-7) a kan wanda Binbin zai fi rashin jin daɗi, ko 0 idan ba ta ji rashin jin daɗi a kowace rana ba.  \nMisali:  \n(day-of-max-unhappiness '((5 3) (6 2) (7 1) (5 3) (5 4) (0 4) (0 3))) Yana dawowa 3  \n(day-of-max-unhappiness '((4 3) (4 3) (4 3) (4 3) (4 3) (2 4) (2 4))) Yana dawowa 0",
      "hi": "Common Lisp फ़ंक्शन `(defun day-of-max-unhappiness (weekly-schedule)` लिखें ताकि निम्नलिखित समस्या का समाधान किया जा सके:\nएक साप्ताहिक शेड्यूल का विश्लेषण करता है ताकि यह पता लगाया जा सके कि कौन से दिन बिनबिन सबसे अधिक दुखी होगी।\n'weekly-schedule' सात जोड़ों की एक सूची है (प्रत्येक दिन के लिए एक) जो स्कूल के घंटे और अतिरिक्त कक्षा के घंटे दर्शाते हैं।\nफ़ंक्शन उस सप्ताह के दिन (1-7) को लौटाता है जिस दिन बिनबिन सबसे अधिक दुखी होती है, या 0 अगर वह किसी भी दिन दुखी नहीं होती है।\nउदाहरण:\n(day-of-max-unhappiness '((5 3) (6 2) (7 1) (5 3) (5 4) (0 4) (0 3))) 3 लौटाता है\n(day-of-max-unhappiness '((4 3) (4 3) (4 3) (4 3) (4 3) (2 4) (2 4))) 0 लौटाता है",
      "hu": "Írj egy Common Lisp függvényt `(defun day-of-max-unhappiness (weekly-schedule)` a következő probléma megoldására:\nElemzi a heti beosztást, hogy kiderítse, melyik napon lesz Binbin a legboldogtalanabb.\nA 'weekly-schedule' egy hét párból álló lista (minden napra egy), amely az iskolai órákat és a plusz órákat jelenti.\nA függvény visszaadja a hét napját (1-7), amikor Binbin a legboldogtalanabb, vagy 0-t, ha egyik nap sem boldogtalan.\nPélda:\n(day-of-max-unhappiness '((5 3) (6 2) (7 1) (5 3) (5 4) (0 4) (0 3))) Visszaadja 3\n(day-of-max-unhappiness '((4 3) (4 3) (4 3) (4 3) (4 3) (2 4) (2 4))) Visszaadja 0"
    },
    "instruction_bertscore": {
      "sq": "0.9907642831730208",
      "hy": "0.9832413561217055",
      "bn": "0.9789447823495397",
      "bg": "0.973554351069015",
      "zh": "0.9696840380945502",
      "fr": "0.9909615231413884",
      "de": "0.9840162132381225",
      "ha": "0.9845531111580599",
      "hi": "0.977551191596199",
      "hu": "0.9661948968212913"
    },
    "level": "middle",
    "test": "(defun test-day-of-max-unhappiness ()\n(assert (equal (day-of-max-unhappiness '((5 3) (6 2) (7 2) (5 3) (5 4) (0 4) (0 6))) 3))\n(assert (equal (day-of-max-unhappiness '((4 4) (4 4) (4 4) (4 4) (4 4) (4 4) (4 4))) 0))\n(assert (equal (day-of-max-unhappiness '((3 3) (3 3) (3 3) (3 3) (3 3) (3 3) (3 3))) 0))\n(assert (equal (day-of-max-unhappiness '((2 6) (3 5) (4 4) (5 3) (6 2) (7 1) (1 7))) 0))\n(assert (equal (day-of-max-unhappiness '((5 0) (0 5) (6 3) (3 6) (2 7) (7 2) (4 4))) 3)))\n(test-day-of-max-unhappiness)",
    "entry_point": "day-of-max-unhappiness",
    "signature": "(defun day-of-max-unhappiness (weekly-schedule)",
    "docstring": {
      "en": "Analyzes a weekly schedule to find out the day when Binbin will be most unhappy.\n'weekly-schedule' is a list of seven pairs (one for each day) representing school hours and extra class hours.\nThe function returns the day of the week (1-7) on which Binbin is most unhappy, or 0 if she is not unhappy any day.\nExample:\n(day-of-max-unhappiness '((5 3) (6 2) (7 1) (5 3) (5 4) (0 4) (0 3))) Returns 3\n(day-of-max-unhappiness '((4 3) (4 3) (4 3) (4 3) (4 3) (2 4) (2 4))) Returns 0",
      "sq": "Analizon një orar javor për të gjetur ditën kur Binbin do të jetë më e pakënaqur.\n'orar-javor' është një listë me shtatë çifte (një për çdo ditë) që përfaqësojnë orët e shkollës dhe orët e klasave shtesë.\nFunksioni kthen ditën e javës (1-7) në të cilën Binbin është më e pakënaqur, ose 0 nëse ajo nuk është e pakënaqur asnjë ditë.\nShembull:\n(day-of-max-unhappiness '((5 3) (6 2) (7 1) (5 3) (5 4) (0 4) (0 3))) Kthen 3\n(day-of-max-unhappiness '((4 3) (4 3) (4 3) (4 3) (4 3) (2 4) (2 4))) Kthen 0",
      "hy": "Վերլուծում է շաբաթական ժամանակացույցը՝ պարզելու համար այն օրը, երբ Բինբինը կլինի ամենաանհաճույքով:\n'weekly-schedule'-ը յոթ զույգերի ցուցակ է (յուրաքանչյուր օրվա համար մեկ)՝ ներկայացնելով դպրոցի ժամերը և լրացուցիչ դասերի ժամերը:\nՖունկցիան վերադարձնում է շաբաթվա օրը (1-7), երբ Բինբինը ամենաանհաճույքով է, կամ 0, եթե նա ոչ մի օր անհաճույքով չէ:\nՕրինակ:\n(day-of-max-unhappiness '((5 3) (6 2) (7 1) (5 3) (5 4) (0 4) (0 3))) Վերադարձնում է 3\n(day-of-max-unhappiness '((4 3) (4 3) (4 3) (4 3) (4 3) (2 4) (2 4))) Վերադարձնում է 0",
      "bn": "সাপ্তাহিক সময়সূচী বিশ্লেষণ করে বের করা হয় যে দিনটি বিনবিন সবচেয়ে অসুখী হবে।\n'weekly-schedule' হল সাতটি জোড়ার একটি তালিকা (প্রতিটি দিনের জন্য একটি) যা স্কুলের ঘন্টা এবং অতিরিক্ত ক্লাসের ঘন্টা উপস্থাপন করে।\nফাংশনটি সপ্তাহের দিন (১-৭) ফেরত দেয় যেদিন বিনবিন সবচেয়ে অসুখী, অথবা ০ যদি সে কোনো দিন অসুখী না হয়।\nউদাহরণ:\n(day-of-max-unhappiness '((5 3) (6 2) (7 1) (5 3) (5 4) (0 4) (0 3))) ফেরত দেয় 3\n(day-of-max-unhappiness '((4 3) (4 3) (4 3) (4 3) (4 3) (2 4) (2 4))) ফেরত দেয় 0",
      "bg": "Анализира седмичен график, за да открие деня, в който Бинбин ще бъде най-нещастна.\n'weekly-schedule' е списък от седем двойки (по една за всеки ден), представляващи учебни часове и часове за допълнителни класове.\nФункцията връща деня от седмицата (1-7), в който Бинбин е най-нещастна, или 0, ако тя не е нещастна нито един ден.\nПример:\n(day-of-max-unhappiness '((5 3) (6 2) (7 1) (5 3) (5 4) (0 4) (0 3))) Връща 3\n(day-of-max-unhappiness '((4 3) (4 3) (4 3) (4 3) (4 3) (2 4) (2 4))) Връща 0",
      "zh": "分析每周的日程安排，以找出彬彬最不开心的那一天。\n'weekly-schedule' 是一个包含七对元素的列表（每一天对应一对），表示学校时间和额外课程时间。\n该函数返回彬彬最不开心的那一天（1-7），如果她没有任何一天不开心，则返回0。\n示例：\n(day-of-max-unhappiness '((5 3) (6 2) (7 1) (5 3) (5 4) (0 4) (0 3))) 返回 3\n(day-of-max-unhappiness '((4 3) (4 3) (4 3) (4 3) (4 3) (2 4) (2 4))) 返回 0",
      "fr": "Analyse un emploi du temps hebdomadaire pour déterminer le jour où Binbin sera le plus mécontente.\n'weekly-schedule' est une liste de sept paires (une pour chaque jour) représentant les heures d'école et les heures de cours supplémentaires.\nLa fonction renvoie le jour de la semaine (1-7) où Binbin est le plus mécontente, ou 0 si elle n'est mécontente aucun jour.\nExemple :\n(day-of-max-unhappiness '((5 3) (6 2) (7 1) (5 3) (5 4) (0 4) (0 3))) Renvoie 3\n(day-of-max-unhappiness '((4 3) (4 3) (4 3) (4 3) (4 3) (2 4) (2 4))) Renvoie 0",
      "de": "Analysiert einen Wochenplan, um herauszufinden, an welchem Tag Binbin am unglücklichsten sein wird.\n'weekly-schedule' ist eine Liste von sieben Paaren (eines für jeden Tag), die die Schulstunden und die Stunden für Zusatzunterricht darstellen.\nDie Funktion gibt den Wochentag (1-7) zurück, an dem Binbin am unglücklichsten ist, oder 0, wenn sie an keinem Tag unglücklich ist.\nBeispiel:\n(day-of-max-unhappiness '((5 3) (6 2) (7 1) (5 3) (5 4) (0 4) (0 3))) Gibt 3 zurück\n(day-of-max-unhappiness '((4 3) (4 3) (4 3) (4 3) (4 3) (2 4) (2 4))) Gibt 0 zurück",
      "ha": "Yana nazarin jadawalin mako don gano ranar da Binbin za ta fi rashin jin daɗi.\n'weekly-schedule' jerin ma'aurata bakwai ne (daya don kowace rana) suna wakiltar awanni makaranta da awanni karin aji.\nAikin yana dawo da ranar mako (1-7) a kan wacce Binbin za ta fi rashin jin daɗi, ko 0 idan ba ta jin rashin jin daɗi a kowane rana.\n\nMisali:\n(day-of-max-unhappiness '((5 3) (6 2) (7 1) (5 3) (5 4) (0 4) (0 3))) Yana dawowa 3\n(day-of-max-unhappiness '((4 3) (4 3) (4 3) (4 3) (4 3) (2 4) (2 4))) Yana dawowa 0",
      "hi": "साप्ताहिक अनुसूची का विश्लेषण करता है ताकि यह पता लगाया जा सके कि बिनबिन किस दिन सबसे अधिक नाखुश होगी। 'weekly-schedule' सात जोड़ों की एक सूची है (प्रत्येक दिन के लिए एक) जो स्कूल के घंटे और अतिरिक्त कक्षा के घंटे दर्शाती है। यह फ़ंक्शन उस सप्ताह के दिन (1-7) को लौटाता है जिस दिन बिनबिन सबसे अधिक नाखुश होती है, या 0 यदि वह किसी भी दिन नाखुश नहीं होती है।\n\nउदाहरण:\n(day-of-max-unhappiness '((5 3) (6 2) (7 1) (5 3) (5 4) (0 4) (0 3))) Returns 3\n(day-of-max-unhappiness '((4 3) (4 3) (4 3) (4 3) (4 3) (2 4) (2 4))) Returns 0",
      "hu": "Elemzi a heti időbeosztást, hogy megtudja, melyik napon lesz Binbin a legboldogtalanabb.\nA 'weekly-schedule' egy hét párból álló lista (minden napra egy), amely az iskolai órákat és az extra órákat képviseli.\nA függvény visszaadja a hét azon napját (1-7), amelyen Binbin a legboldogtalanabb, vagy 0-t, ha egyetlen napon sem boldogtalan.\nPélda:\n(day-of-max-unhappiness '((5 3) (6 2) (7 1) (5 3) (5 4) (0 4) (0 3))) Visszaadja: 3\n(day-of-max-unhappiness '((4 3) (4 3) (4 3) (4 3) (4 3) (2 4) (2 4))) Visszaadja: 0"
    },
    "docstring_bertscore": {
      "sq": "0.992706888299542",
      "hy": "0.9838354595913807",
      "bn": "0.9794860501378598",
      "bg": "0.9860702500084043",
      "zh": "0.9252023533048352",
      "fr": "0.9842511929788869",
      "de": "0.9600605947637909",
      "ha": "0.982339176931045",
      "hi": "0.9850365775054988",
      "hu": "0.948367025601886"
    }
  },
  {
    "task_id": "Common Lisp/27",
    "prompt": {
      "en": "(defun calculate-year-end-amount (monthly-budgets)\n;; Calculates whether Jinjin can follow her savings plan without running out of money in any month.\n;; 'monthly-budgets' is a list of 12 integers representing Jinjin's monthly budget.\n;; If successful, returns the total amount of money Jinjin will have by year-end, including 20% interest on savings.\n;; Otherwise, returns -X, where X is the first month Jinjin runs out of money.\n;; Example:\n;; (calculate-year-end-amount '(290 230 280 200 300 170 340 50 90 80 200 60)) ;; Returns -7",
      "sq": "(defun calculate-year-end-amount (monthly-budgets)\n;; Llogarit nëse Jinjin mund të ndjekë planin e saj të kursimeve pa mbetur pa para në asnjë muaj.\n;; 'monthly-budgets' është një listë me 12 numra të plotë që përfaqësojnë buxhetin mujor të Jinjin.\n;; Nëse është e suksesshme, kthen shumën totale të parave që Jinjin do të ketë deri në fund të vitit, duke përfshirë 20% interes mbi kursimet.\n;; Përndryshe, kthen -X, ku X është muaji i parë kur Jinjin mbetet pa para.\n;; Shembull:\n;; (calculate-year-end-amount '(290 230 280 200 300 170 340 50 90 80 200 60)) ;; Kthen -7",
      "hy": "(defun calculate-year-end-amount (monthly-budgets)\n;; Հաշվում է՝ արդյոք Ջինջինը կարող է հետևել իր խնայողությունների պլանին՝ առանց որևէ ամսում գումարից դուրս գալու:\n;; 'monthly-budgets'-ը 12 ամբողջ թվերի ցուցակ է, որը ներկայացնում է Ջինջինի ամսական բյուջեն:\n;; Եթե հաջողվում է, վերադարձնում է տարվա վերջում Ջինջինի ունեցած գումարի ընդհանուր գումարը՝ ներառյալ խնայողությունների 20% տոկոսադրույքը:\n;; Հակառակ դեպքում, վերադարձնում է -X, որտեղ X-ը այն առաջին ամիսն է, երբ Ջինջինը գումարից դուրս է գալիս:\n;; Օրինակ:\n;; (calculate-year-end-amount '(290 230 280 200 300 170 340 50 90 80 200 60)) ;; Վերադարձնում է -7",
      "bn": "(defun calculate-year-end-amount (monthly-budgets)\n;; হিসাব করে যে জিনজিন তার সঞ্চয় পরিকল্পনা অনুসরণ করতে পারে কিনা মাসের মধ্যে টাকা শেষ না করে।\n;; 'monthly-budgets' হল ১২টি পূর্ণসংখ্যার একটি তালিকা যা জিনজিনের মাসিক বাজেট উপস্থাপন করে।\n;; যদি সফল হয়, তাহলে বছরের শেষে জিনজিনের মোট টাকা ফেরত দেয়, যার মধ্যে সঞ্চয়ের উপর ২০% সুদ অন্তর্ভুক্ত।\n;; অন্যথায়, -X ফেরত দেয়, যেখানে X হল প্রথম মাস যখন জিনজিনের টাকা শেষ হয়ে যায়।\n;; উদাহরণ:\n;; (calculate-year-end-amount '(290 230 280 200 300 170 340 50 90 80 200 60)) ;; -7 ফেরত দেয়",
      "bg": "(defun calculate-year-end-amount (monthly-budgets)\n;; Изчислява дали Джинджин може да следва своя план за спестявания, без да остане без пари в някой месец.\n;; 'monthly-budgets' е списък от 12 цели числа, представляващи месечния бюджет на Джинджин.\n;; Ако е успешно, връща общата сума пари, която Джинджин ще има до края на годината, включително 20% лихва върху спестяванията.\n;; В противен случай, връща -X, където X е първият месец, в който Джинджин остава без пари.\n;; Пример:\n;; (calculate-year-end-amount '(290 230 280 200 300 170 340 50 90 80 200 60)) ;; Връща -7",
      "zh": "(defun calculate-year-end-amount (monthly-budgets)\n;; 计算金金是否可以按照她的储蓄计划而不在任何一个月用完钱。\n;; 'monthly-budgets' 是一个包含12个整数的列表，代表金金每个月的预算。\n;; 如果成功，返回金金到年底时拥有的总金额，包括储蓄的20%利息。\n;; 否则，返回 -X，其中 X 是金金用完钱的第一个月。\n;; 示例:\n;; (calculate-year-end-amount '(290 230 280 200 300 170 340 50 90 80 200 60)) ;; 返回 -7",
      "fr": "(defun calculate-year-end-amount (monthly-budgets)\n;; Calcule si Jinjin peut suivre son plan d'épargne sans manquer d'argent au cours d'un mois.\n;; 'monthly-budgets' est une liste de 12 entiers représentant le budget mensuel de Jinjin.\n;; Si réussi, retourne le montant total d'argent que Jinjin aura à la fin de l'année, y compris 20% d'intérêt sur les économies.\n;; Sinon, retourne -X, où X est le premier mois où Jinjin manque d'argent.\n;; Exemple:\n;; (calculate-year-end-amount '(290 230 280 200 300 170 340 50 90 80 200 60)) ;; Retourne -7",
      "de": "(defun calculate-year-end-amount (monthly-budgets)\n;; Berechnet, ob Jinjin ihren Sparplan einhalten kann, ohne in einem Monat kein Geld mehr zu haben.\n;; 'monthly-budgets' ist eine Liste von 12 ganzen Zahlen, die Jinjin's monatliches Budget darstellen.\n;; Bei Erfolg wird der Gesamtbetrag an Geld zurückgegeben, den Jinjin bis zum Jahresende haben wird, einschließlich 20% Zinsen auf die Ersparnisse.\n;; Andernfalls wird -X zurückgegeben, wobei X der erste Monat ist, in dem Jinjin kein Geld mehr hat.\n;; Beispiel:\n;; (calculate-year-end-amount '(290 230 280 200 300 170 340 50 90 80 200 60)) ;; Gibt -7 zurück",
      "ha": "(defun calculate-year-end-amount (monthly-budgets)\n;; Yana ƙididdige ko Jinjin za ta iya bin shirin ajiyarta ba tare da ta ƙare da kuɗi a kowane wata ba.\n;; 'monthly-budgets' jerin lambobi 12 ne da ke wakiltar kasafin kuɗin wata-wata na Jinjin.\n;; Idan ya yi nasara, yana mayar da jimillar kuɗin da Jinjin za ta samu zuwa ƙarshen shekara, tare da ƙarin riba na 20% akan ajiyar.\n;; In ba haka ba, yana mayar da -X, inda X shine watan farko da Jinjin ta ƙare da kuɗi.\n;; Misali:\n;; (calculate-year-end-amount '(290 230 280 200 300 170 340 50 90 80 200 60)) ;; Yana mayar da -7",
      "hi": "(defun calculate-year-end-amount (monthly-budgets)\n;; गणना करता है कि क्या जिनजिन अपनी बचत योजना का पालन कर सकती है बिना किसी महीने में पैसे खत्म किए।\n;; 'monthly-budgets' 12 पूर्णांकों की एक सूची है जो जिनजिन के मासिक बजट का प्रतिनिधित्व करती है।\n;; यदि सफल होता है, तो वर्ष के अंत तक जिनजिन के पास कुल कितनी राशि होगी, जिसमें बचत पर 20% ब्याज शामिल है, उसे लौटाता है।\n;; अन्यथा, -X लौटाता है, जहाँ X वह पहला महीना है जब जिनजिन के पैसे खत्म हो जाते हैं।\n;; उदाहरण:\n;; (calculate-year-end-amount '(290 230 280 200 300 170 340 50 90 80 200 60)) ;; -7 लौटाता है",
      "hu": "(defun calculate-year-end-amount (monthly-budgets)\n;; Kiszámítja, hogy Jinjin tudja-e követni a megtakarítási tervét anélkül, hogy bármelyik hónapban kifogyna a pénzből.\n;; A 'monthly-budgets' egy lista 12 egész számmal, amelyek Jinjin havi költségvetését képviselik.\n;; Ha sikeres, visszaadja az év végére Jinjin által megtakarított teljes összeget, beleértve a megtakarításokra járó 20%-os kamatot.\n;; Ellenkező esetben visszaadja -X-et, ahol X az első hónap, amikor Jinjin kifogy a pénzből.\n;; Példa:\n;; (calculate-year-end-amount '(290 230 280 200 300 170 340 50 90 80 200 60)) ;; Visszaadja: -7"
    },
    "prompt_bertscore": {
      "sq": "0.9852653997044509",
      "hy": "0.9466669481706084",
      "bn": "0.9676550287522788",
      "bg": "0.9824917250636798",
      "zh": "0.9706966557770661",
      "fr": "0.9816781350229609",
      "de": "0.9709554711635545",
      "ha": "0.966437821777297",
      "hi": "0.9868341824538646",
      "hu": "0.9652257791922221"
    },
    "canonical_solution": "(let ((current-amount 0)\n(total-saved 0))\n(loop for month from 1 to 12\nfor budget in monthly-budgets\ndo (progn\n(incf current-amount 300) ;; Add monthly allowance\n(decf current-amount budget) ;; Subtract monthly budget\n(when (< current-amount 0)\n(return-from calculate-year-end-amount (- month))) ;; Check if Jinjin runs out of money\n(let ((savings (floor current-amount 100)))\n(decf current-amount (* 100 savings))\n(incf total-saved (* 100 savings))))\nfinally (return (+ current-amount (* total-saved 1.2)))))) ;; Calculate total with interest",
    "instruction": {
      "en": "Write a Common Lisp function `(defun calculate-year-end-amount (monthly-budgets)` to solve the following problem:\nCalculates whether Jinjin can follow her savings plan without running out of money in any month.\n'monthly-budgets' is a list of 12 integers representing Jinjin's monthly budget.\nIf successful, returns the total amount of money Jinjin will have by year-end, including 20% interest on savings.\nOtherwise, returns -X, where X is the first month Jinjin runs out of money.\nExample:\n(calculate-year-end-amount '(290 230 280 200 300 170 340 50 90 80 200 60)) Returns -7",
      "sq": "Shkruani një funksion Common Lisp `(defun calculate-year-end-amount (monthly-budgets)` për të zgjidhur problemin e mëposhtëm:  \nLlogarit nëse Jinjin mund të ndjekë planin e saj të kursimeve pa mbetur pa para në asnjë muaj.  \n'monthly-budgets' është një listë me 12 numra të plotë që përfaqësojnë buxhetin mujor të Jinjin.  \nNëse është e suksesshme, kthen shumën totale të parave që Jinjin do të ketë deri në fund të vitit, duke përfshirë 20% interes mbi kursimet.  \nPërndryshe, kthen -X, ku X është muaji i parë kur Jinjin mbetet pa para.  \nShembull:  \n(calculate-year-end-amount '(290 230 280 200 300 170 340 50 90 80 200 60)) Kthen -7",
      "hy": "Գրեք Common Lisp ֆունկցիա `(defun calculate-year-end-amount (monthly-budgets)` հետևյալ խնդիրը լուծելու համար:\nՀաշվում է՝ արդյոք Ջինջինը կարող է հետևել իր խնայողությունների պլանին՝ առանց որևէ ամսում գումարից դուրս մնալու:\n'monthly-budgets' ցուցակն է 12 ամբողջ թվերի, որոնք ներկայացնում են Ջինջինի ամսական բյուջեն:\nԵթե հաջող է, վերադարձնում է գումարի ընդհանուր չափը, որը Ջինջինը կունենա տարվա վերջում՝ ներառյալ խնայողությունների 20% տոկոսադրույքը:\nՀակառակ դեպքում վերադարձնում է -X, որտեղ X-ը այն առաջին ամիսն է, երբ Ջինջինը գումարից դուրս է մնում:\nՕրինակ:\n(calculate-year-end-amount '(290 230 280 200 300 170 340 50 90 80 200 60)) Վերադարձնում է -7",
      "bn": "Common Lisp ফাংশন `(defun calculate-year-end-amount (monthly-budgets)` লিখুন নিম্নলিখিত সমস্যার সমাধানের জন্য:\nহিসাব করে যে জিনজিন তার সঞ্চয় পরিকল্পনা অনুসরণ করতে পারে কিনা কোনো মাসে টাকা শেষ না করে।\n'monthly-budgets' হল ১২টি পূর্ণসংখ্যার একটি তালিকা যা জিনজিনের মাসিক বাজেট উপস্থাপন করে।\nযদি সফল হয়, তাহলে বছরের শেষে জিনজিনের মোট টাকার পরিমাণ ফেরত দেয়, সঞ্চয়ে ২০% সুদ সহ।\nঅন্যথায়, -X ফেরত দেয়, যেখানে X হল প্রথম মাস যখন জিনজিনের টাকা শেষ হয়ে যায়।\nউদাহরণ:\n(calculate-year-end-amount '(290 230 280 200 300 170 340 50 90 80 200 60)) -7 ফেরত দেয়",
      "bg": "Напишете функция на Common Lisp `(defun calculate-year-end-amount (monthly-budgets)` за решаване на следния проблем:\nИзчислява дали Джинджин може да следва своя план за спестявания, без да остане без пари през който и да е месец.\n'monthly-budgets' е списък от 12 цели числа, представляващи месечния бюджет на Джинджин.\nАко е успешно, връща общата сума пари, която Джинджин ще има до края на годината, включително 20% лихва върху спестяванията.\nВ противен случай връща -X, където X е първият месец, в който Джинджин остава без пари.\nПример:\n(calculate-year-end-amount '(290 230 280 200 300 170 340 50 90 80 200 60)) Връща -7",
      "zh": "编写一个 Common Lisp 函数 `(defun calculate-year-end-amount (monthly-budgets)` 来解决以下问题：\n计算金金是否可以按照她的储蓄计划在任何月份不缺钱。\n'monthly-budgets' 是一个包含 12 个整数的列表，表示金金的每月预算。\n如果成功，返回金金到年底时将拥有的总金额，包括储蓄的 20% 利息。\n否则，返回 -X，其中 X 是金金资金不足的第一个月份。\n例子：\n(calculate-year-end-amount '(290 230 280 200 300 170 340 50 90 80 200 60)) 返回 -7",
      "fr": "Écrire une fonction Common Lisp `(defun calculate-year-end-amount (monthly-budgets)` pour résoudre le problème suivant :\nCalcule si Jinjin peut suivre son plan d'épargne sans manquer d'argent au cours d'un mois quelconque.\n'monthly-budgets' est une liste de 12 entiers représentant le budget mensuel de Jinjin.\nSi elle réussit, retourne le montant total d'argent que Jinjin aura à la fin de l'année, y compris 20% d'intérêt sur les économies.\nSinon, retourne -X, où X est le premier mois où Jinjin manque d'argent.\nExemple :\n(calculate-year-end-amount '(290 230 280 200 300 170 340 50 90 80 200 60)) Retourne -7",
      "de": "Schreiben Sie eine Common Lisp-Funktion `(defun calculate-year-end-amount (monthly-budgets)` um das folgende Problem zu lösen:\nBerechnet, ob Jinjin ihren Sparplan einhalten kann, ohne in einem Monat kein Geld mehr zu haben.\n'monthly-budgets' ist eine Liste von 12 ganzen Zahlen, die Jinjin's monatliches Budget darstellen.\nWenn erfolgreich, wird der Gesamtbetrag an Geld zurückgegeben, den Jinjin bis zum Jahresende haben wird, einschließlich 20% Zinsen auf die Ersparnisse.\nAndernfalls wird -X zurückgegeben, wobei X der erste Monat ist, in dem Jinjin kein Geld mehr hat.\nBeispiel:\n(calculate-year-end-amount '(290 230 280 200 300 170 340 50 90 80 200 60)) Gibt -7 zurück",
      "ha": "Rubuta aikin Common Lisp `(defun calculate-year-end-amount (monthly-budgets)` don warware matsalar mai zuwa:\nYana lissafin ko Jinjin za ta iya bin shirin ajiyarta ba tare da ta kare da kudi a kowane wata ba.\n'monthly-budgets' jerin lambobi 12 ne da ke wakiltar kasafin kudin wata-wata na Jinjin.\nIdan ya yi nasara, yana mayar da jimillar kudin da Jinjin za ta samu zuwa ƙarshen shekara, ciki har da riba 20% akan ajiyar.\nIn ba haka ba, yana mayar da -X, inda X shine watan farko da Jinjin ta kare da kudi.\nMisali:\n(calculate-year-end-amount '(290 230 280 200 300 170 340 50 90 80 200 60)) Yana Mayar da -7",
      "hi": "Common Lisp फ़ंक्शन `(defun calculate-year-end-amount (monthly-budgets)` लिखें ताकि निम्नलिखित समस्या का समाधान किया जा सके:\nयह गणना करता है कि क्या जिनजिन अपनी बचत योजना का पालन कर सकती है बिना किसी महीने में पैसे खत्म हुए।\n'monthly-budgets' 12 पूर्णांकों की एक सूची है जो जिनजिन के मासिक बजट का प्रतिनिधित्व करती है।\nयदि सफल होता है, तो यह वर्ष के अंत तक जिनजिन के पास कुल राशि लौटाता है, जिसमें बचत पर 20% ब्याज शामिल है।\nअन्यथा, -X लौटाता है, जहाँ X वह पहला महीना है जब जिनजिन के पैसे खत्म हो जाते हैं।\nउदाहरण:\n(calculate-year-end-amount '(290 230 280 200 300 170 340 50 90 80 200 60)) -7 लौटाता है",
      "hu": "Írj egy Common Lisp függvényt `(defun calculate-year-end-amount (monthly-budgets)` a következő probléma megoldására:\nKiszámítja, hogy Jinjin követheti-e a megtakarítási tervét anélkül, hogy bármelyik hónapban kifogyna a pénzből.\nA 'monthly-budgets' egy 12 egész számot tartalmazó lista, amely Jinjin havi költségvetését képviseli.\nHa sikeres, visszaadja az év végére Jinjin rendelkezésére álló teljes pénzösszeget, beleértve a megtakarításokra kapott 20%-os kamatot.\nEllenkező esetben visszaadja -X-et, ahol X az első hónap, amikor Jinjin kifogy a pénzből.\nPélda:\n(calculate-year-end-amount '(290 230 280 200 300 170 340 50 90 80 200 60)) Visszaadja -7"
    },
    "instruction_bertscore": {
      "sq": "0.9771670404392775",
      "hy": "0.9635886675917326",
      "bn": "0.9775531779000094",
      "bg": "0.9804166334730083",
      "zh": "0.9854550917183392",
      "fr": "0.9718316297742994",
      "de": "0.9685341668187393",
      "ha": "0.9658159100542768",
      "hi": "0.9782539458843005",
      "hu": "0.9585651066249792"
    },
    "level": "hard",
    "test": "(defun test-calculate-year-end-amount ()\n(assert (equal (calculate-year-end-amount '(290 230 280 200 300 170 340 50 90 80 200 60)) -7))\n(assert (equal (calculate-year-end-amount '(100 100 100 100 100 100 100 100 100 100 100 100)) 2880.0)) ;; Assuming all savings\n(assert (equal (calculate-year-end-amount '(300 300 300 300 300 300 300 300 300 300 300 300)) 0.0)) ;; No savings\n(assert (equal (calculate-year-end-amount '(150 150 150 150 150 150 150 150 150 150 150 150)) 2160.0)) ;; Half savings\n(assert (equal (calculate-year-end-amount '(250 250 250 250 250 250 250 250 250 250 250 250)) 720.0))) ;; Runs out first month\n(test-calculate-year-end-amount)",
    "entry_point": "calculate-year-end-amount",
    "signature": "(defun calculate-year-end-amount (monthly-budgets)",
    "docstring": {
      "en": "Calculates whether Jinjin can follow her savings plan without running out of money in any month.\n'monthly-budgets' is a list of 12 integers representing Jinjin's monthly budget.\nIf successful, returns the total amount of money Jinjin will have by year-end, including 20% interest on savings.\nOtherwise, returns -X, where X is the first month Jinjin runs out of money.\nExample:\n(calculate-year-end-amount '(290 230 280 200 300 170 340 50 90 80 200 60)) Returns -7",
      "sq": "Llogarit nëse Jinjin mund të ndjekë planin e saj të kursimeve pa mbetur pa para në asnjë muaj.\n'monthly-budgets' është një listë me 12 numra të plotë që përfaqësojnë buxhetin mujor të Jinjin.\nNëse është e suksesshme, kthen shumën totale të parave që Jinjin do të ketë deri në fund të vitit, duke përfshirë 20% interes mbi kursimet.\nPërndryshe, kthen -X, ku X është muaji i parë kur Jinjin mbetet pa para.\nShembull:\n(calculate-year-end-amount '(290 230 280 200 300 170 340 50 90 80 200 60)) Kthen -7",
      "hy": "Հաշվում է՝ արդյոք Ջինջինը կարող է հետևել իր խնայողությունների պլանին՝ առանց որևէ ամսում գումարը սպառելու։\n'monthly-budgets'-ը 12 ամբողջ թվերի ցուցակ է, որը ներկայացնում է Ջինջինի ամսական բյուջեն։\nԵթե հաջողվում է, վերադարձնում է այն գումարի ընդհանուր քանակը, որը Ջինջինը կունենա տարվա վերջում՝ ներառյալ խնայողությունների 20% տոկոսադրույքը։\nՀակառակ դեպքում, վերադարձնում է -X, որտեղ X-ը այն առաջին ամիսն է, երբ Ջինջինը սպառվում է գումարից։\nՕրինակ:\n(calculate-year-end-amount '(290 230 280 200 300 170 340 50 90 80 200 60)) Վերադարձնում է -7",
      "bn": "Jinjin তার সঞ্চয়ের পরিকল্পনা অনুসরণ করতে পারে কিনা তা গণনা করে, কোন মাসে টাকা শেষ হয়ে যাবে না।\n'monthly-budgets' হল ১২টি পূর্ণসংখ্যার একটি তালিকা যা Jinjin এর মাসিক বাজেট উপস্থাপন করে।\nযদি সফল হয়, তাহলে বছরের শেষে Jinjin এর মোট কত টাকা থাকবে তা ফেরত দেয়, সঞ্চয়ের উপর ২০% সুদ সহ।\nঅন্যথায়, -X ফেরত দেয়, যেখানে X হল প্রথম মাস যখন Jinjin এর টাকা শেষ হয়ে যায়।\nউদাহরণ:\n(calculate-year-end-amount '(290 230 280 200 300 170 340 50 90 80 200 60)) ফেরত দেয় -7",
      "bg": "Изчислява дали Джинджин може да следва своя план за спестявания, без да остане без пари през който и да е месец.\n'monthly-budgets' е списък от 12 цели числа, представляващи месечния бюджет на Джинджин.\nАко е успешно, връща общата сума пари, която Джинджин ще има до края на годината, включително 20% лихва върху спестяванията.\nВ противен случай, връща -X, където X е първият месец, в който Джинджин остава без пари.\nПример:\n(calculate-year-end-amount '(290 230 280 200 300 170 340 50 90 80 200 60)) Връща -7",
      "zh": "计算金金是否可以在不在任何一个月用完钱的情况下遵循她的储蓄计划。\n'monthly-budgets' 是一个包含12个整数的列表，表示金金每个月的预算。\n如果成功，返回金金在年底时拥有的总金额，包括储蓄的20%利息。\n否则，返回 -X，其中 X 是金金第一次用完钱的月份。\n示例：\n(calculate-year-end-amount '(290 230 280 200 300 170 340 50 90 80 200 60)) 返回 -7",
      "fr": "Calcule si Jinjin peut suivre son plan d'épargne sans manquer d'argent au cours d'un mois quelconque.\n'monthly-budgets' est une liste de 12 entiers représentant le budget mensuel de Jinjin.\nSi réussi, retourne le montant total d'argent que Jinjin aura à la fin de l'année, y compris 20% d'intérêt sur les économies.\nSinon, retourne -X, où X est le premier mois où Jinjin manque d'argent.\nExemple:\n(calculate-year-end-amount '(290 230 280 200 300 170 340 50 90 80 200 60)) Retourne -7",
      "de": "Berechnet, ob Jinjin ihren Sparplan einhalten kann, ohne in einem Monat kein Geld mehr zu haben.\n'monthly-budgets' ist eine Liste von 12 ganzen Zahlen, die Jinjin's monatliches Budget darstellen.\nWenn erfolgreich, gibt den Gesamtbetrag des Geldes zurück, den Jinjin bis zum Jahresende haben wird, einschließlich 20% Zinsen auf Ersparnisse.\nAndernfalls wird -X zurückgegeben, wobei X der erste Monat ist, in dem Jinjin kein Geld mehr hat.\nBeispiel:\n(calculate-year-end-amount '(290 230 280 200 300 170 340 50 90 80 200 60)) Gibt -7 zurück",
      "ha": "Yana lissafin ko Jinjin za ta iya bin shirin ajiyarta ba tare da ta kare da kudi a kowane wata ba.\n'monthly-budgets' jerin lambobi ne guda 12 da ke wakiltar kasafin kudin wata-wata na Jinjin.\nIdan ya yi nasara, yana dawo da jimillar adadin kudin da Jinjin za ta samu a karshen shekara, ciki har da riba 20% akan ajiyar.\nIn ba haka ba, yana dawo da -X, inda X shine watan farko da Jinjin ta kare da kudi.\nMisali:\n(calculate-year-end-amount '(290 230 280 200 300 170 340 50 90 80 200 60)) Yana dawowa -7",
      "hi": "Jinjin यह गणना करता है कि क्या वह अपनी बचत योजना का पालन कर सकती है बिना किसी महीने में पैसे खत्म किए।\n'monthly-budgets' 12 पूर्णांकों की एक सूची है जो Jinjin के मासिक बजट का प्रतिनिधित्व करती है।\nयदि सफल होता है, तो वर्ष के अंत तक Jinjin के पास कुल कितनी राशि होगी, जिसमें बचत पर 20% ब्याज शामिल है, यह लौटाता है।\nअन्यथा, -X लौटाता है, जहाँ X वह पहला महीना है जब Jinjin के पैसे खत्म हो जाते हैं।\nउदाहरण:\n(calculate-year-end-amount '(290 230 280 200 300 170 340 50 90 80 200 60)) -7 लौटाता है।",
      "hu": "Kiszámítja, hogy Jinjin követheti-e a megtakarítási tervét anélkül, hogy bármelyik hónapban kifogyna a pénzből.\nA 'monthly-budgets' egy 12 egész számot tartalmazó lista, amely Jinjin havi költségvetését jelképezi.\nHa sikeres, visszaadja azt a teljes összeget, amellyel Jinjin az év végére rendelkezni fog, beleértve a megtakarításokra kapott 20%-os kamatot.\nEllenkező esetben visszaadja -X-et, ahol X az első hónap, amikor Jinjin kifogy a pénzből.\nPélda:\n(calculate-year-end-amount '(290 230 280 200 300 170 340 50 90 80 200 60)) Visszaadja: -7"
    },
    "docstring_bertscore": {
      "sq": "0.9809118190129282",
      "hy": "0.9688470096688692",
      "bn": "0.9288299399536755",
      "bg": "0.979850934147821",
      "zh": "0.9699116685112161",
      "fr": "0.9825608484362799",
      "de": "0.9776471300702388",
      "ha": "0.9669806786086653",
      "hi": "0.9611616029658673",
      "hu": "0.9561304940446346"
    }
  },
  {
    "task_id": "Common Lisp/28",
    "prompt": {
      "en": "(defun total-cigarettes-smoked (initial-cigarettes butt-to-cigarette-ratio)\n;; Calculates the total number of cigarettes Peter can smoke.\n;; 'initial-cigarettes' is the starting number of cigarettes.\n;; 'butt-to-cigarette-ratio' is the number of cigarette butts required to get a new cigarette.\n;; The function returns the total number of cigarettes Peter can smoke.\n;; Example:\n;; (total-cigarettes-smoked 4 3) ;; Returns 5\n;; (total-cigarettes-smoked 10 4) ;; Returns 13",
      "sq": "(defun total-cigarettes-smoked (initial-cigarettes butt-to-cigarette-ratio)\n;; Llogarit numrin total të cigareve që Pjetri mund të pijë.\n;; 'initial-cigarettes' është numri fillestar i cigareve.\n;; 'butt-to-cigarette-ratio' është numri i bishtave të cigareve të nevojshme për të marrë një cigare të re.\n;; Funksioni kthen numrin total të cigareve që Pjetri mund të pijë.\n;; Shembull:\n;; (total-cigarettes-smoked 4 3) ;; Kthen 5\n;; (total-cigarettes-smoked 10 4) ;; Kthen 13",
      "hy": "(defun total-cigarettes-smoked (initial-cigarettes butt-to-cigarette-ratio)\n;; Հաշվում է ընդհանուր սիգարետների քանակը, որ Պետերը կարող է ծխել։\n;; 'initial-cigarettes' մեկնարկային սիգարետների քանակն է։\n;; 'butt-to-cigarette-ratio' սիգարետի մնացորդների քանակն է, որը պահանջվում է նոր սիգարետ ստանալու համար։\n;; Ֆունկցիան վերադարձնում է ընդհանուր սիգարետների քանակը, որ Պետերը կարող է ծխել։\n;; Օրինակ:\n;; (total-cigarettes-smoked 4 3) ;; Վերադարձնում է 5\n;; (total-cigarettes-smoked 10 4) ;; Վերադարձնում է 13",
      "bn": "(defun total-cigarettes-smoked (initial-cigarettes butt-to-cigarette-ratio)\n;; পিটার মোট কতগুলো সিগারেট খেতে পারে তা গণনা করে।\n;; 'initial-cigarettes' হল শুরুতে থাকা সিগারেটের সংখ্যা।\n;; 'butt-to-cigarette-ratio' হল নতুন সিগারেট পাওয়ার জন্য প্রয়োজনীয় সিগারেটের অবশিষ্টাংশের সংখ্যা।\n;; ফাংশনটি পিটার মোট কতগুলো সিগারেট খেতে পারে তা ফেরত দেয়।\n;; উদাহরণ:\n;; (total-cigarettes-smoked 4 3) ;; 5 ফেরত দেয়\n;; (total-cigarettes-smoked 10 4) ;; 13 ফেরত দেয়",
      "bg": "(defun total-cigarettes-smoked (initial-cigarettes butt-to-cigarette-ratio)\n;; Изчислява общия брой цигари, които Петър може да изпуши.\n;; 'initial-cigarettes' е началният брой цигари.\n;; 'butt-to-cigarette-ratio' е броят на фасовете, необходими за получаване на нова цигара.\n;; Функцията връща общия брой цигари, които Петър може да изпуши.\n;; Пример:\n;; (total-cigarettes-smoked 4 3) ;; Връща 5\n;; (total-cigarettes-smoked 10 4) ;; Връща 13",
      "zh": "(defun total-cigarettes-smoked (initial-cigarettes butt-to-cigarette-ratio)\n;; 计算彼得可以抽的香烟总数。\n;; 'initial-cigarettes' 是初始的香烟数量。\n;; 'butt-to-cigarette-ratio' 是获得一支新香烟所需的烟蒂数量。\n;; 该函数返回彼得可以抽的香烟总数。\n;; 例子:\n;; (total-cigarettes-smoked 4 3) ;; 返回 5\n;; (total-cigarettes-smoked 10 4) ;; 返回 13",
      "fr": "(defun total-cigarettes-smoked (initial-cigarettes butt-to-cigarette-ratio)\n;; Calcule le nombre total de cigarettes que Peter peut fumer.\n;; 'initial-cigarettes' est le nombre initial de cigarettes.\n;; 'butt-to-cigarette-ratio' est le nombre de mégots de cigarette nécessaires pour obtenir une nouvelle cigarette.\n;; La fonction renvoie le nombre total de cigarettes que Peter peut fumer.\n;; Exemple:\n;; (total-cigarettes-smoked 4 3) ;; Renvoie 5\n;; (total-cigarettes-smoked 10 4) ;; Renvoie 13",
      "de": "(defun total-cigarettes-smoked (initial-cigarettes butt-to-cigarette-ratio)\n;; Berechnet die Gesamtanzahl der Zigaretten, die Peter rauchen kann.\n;; 'initial-cigarettes' ist die Anfangsanzahl der Zigaretten.\n;; 'butt-to-cigarette-ratio' ist die Anzahl der Zigarettenstummel, die benötigt werden, um eine neue Zigarette zu bekommen.\n;; Die Funktion gibt die Gesamtanzahl der Zigaretten zurück, die Peter rauchen kann.\n;; Beispiel:\n;; (total-cigarettes-smoked 4 3) ;; Gibt 5 zurück\n;; (total-cigarettes-smoked 10 4) ;; Gibt 13 zurück",
      "ha": "(defun total-cigarettes-smoked (initial-cigarettes butt-to-cigarette-ratio)\n;; Lissafa jimillar adadin sigari da Peter zai iya sha.\n;; 'initial-cigarettes' shine adadin sigari na farko.\n;; 'butt-to-cigarette-ratio' shine adadin bututun sigari da ake bukata don samun sabuwar sigari.\n;; Aikin yana dawowa da jimillar adadin sigari da Peter zai iya sha.\n;; Misali:\n;; (total-cigarettes-smoked 4 3) ;; Yana dawowa 5\n;; (total-cigarettes-smoked 10 4) ;; Yana dawowa 13",
      "hi": "(defun total-cigarettes-smoked (initial-cigarettes butt-to-cigarette-ratio)\n;; गणना करता है कि पीटर कुल कितनी सिगरेट पी सकता है।\n;; 'initial-cigarettes' सिगरेट की प्रारंभिक संख्या है।\n;; 'butt-to-cigarette-ratio' वह संख्या है जितने सिगरेट के टुकड़े एक नई सिगरेट पाने के लिए आवश्यक होते हैं।\n;; यह फ़ंक्शन कुल सिगरेट की संख्या लौटाता है जो पीटर पी सकता है।\n;; उदाहरण:\n;; (total-cigarettes-smoked 4 3) ;; 5 लौटाता है\n;; (total-cigarettes-smoked 10 4) ;; 13 लौटाता है",
      "hu": "(defun total-cigarettes-smoked (initial-cigarettes butt-to-cigarette-ratio)\n;; Kiszámítja a teljes cigarettaszámot, amit Péter elszívhat.\n;; 'initial-cigarettes' a kezdő cigaretták száma.\n;; 'butt-to-cigarette-ratio' az új cigaretta megszerzéséhez szükséges csikkek száma.\n;; A függvény visszaadja a teljes cigarettaszámot, amit Péter elszívhat.\n;; Példa:\n;; (total-cigarettes-smoked 4 3) ;; Visszaadja 5\n;; (total-cigarettes-smoked 10 4) ;; Visszaadja 13"
    },
    "prompt_bertscore": {
      "sq": "0.9887591094764736",
      "hy": "0.9886083490172681",
      "bn": "0.9792397484653765",
      "bg": "0.9705558268369123",
      "zh": "0.9860553527298267",
      "fr": "0.9875295874178677",
      "de": "0.9887591094764736",
      "ha": "0.9864694970742844",
      "hi": "0.9862454420044771",
      "hu": "0.986296092751641"
    },
    "canonical_solution": "(let ((total-smoked initial-cigarettes)\n(butts initial-cigarettes))\n(loop while (>= butts butt-to-cigarette-ratio)\ndo (let ((new-cigarettes (floor butts butt-to-cigarette-ratio)))\n(incf total-smoked new-cigarettes)\n(decf butts (* new-cigarettes butt-to-cigarette-ratio))\n(incf butts new-cigarettes)))\ntotal-smoked))",
    "instruction": {
      "en": "Write a Common Lisp function `(defun total-cigarettes-smoked (initial-cigarettes butt-to-cigarette-ratio)` to solve the following problem:\nCalculates the total number of cigarettes Peter can smoke.\n'initial-cigarettes' is the starting number of cigarettes.\n'butt-to-cigarette-ratio' is the number of cigarette butts required to get a new cigarette.\nThe function returns the total number of cigarettes Peter can smoke.\nExample:\n(total-cigarettes-smoked 4 3) Returns 5\n(total-cigarettes-smoked 10 4) Returns 13",
      "sq": "Shkruani një funksion në Common Lisp `(defun total-cigarettes-smoked (initial-cigarettes butt-to-cigarette-ratio)` për të zgjidhur problemin e mëposhtëm:  \nLlogarit numrin total të cigareve që Pjetri mund të pijë.  \n'initial-cigarettes' është numri fillestar i cigareve.  \n'butt-to-cigarette-ratio' është numri i bishtave të cigareve të nevojshme për të marrë një cigare të re.  \nFunksioni kthen numrin total të cigareve që Pjetri mund të pijë.  \nShembull:  \n(total-cigarettes-smoked 4 3) Kthen 5  \n(total-cigarettes-smoked 10 4) Kthen 13  ",
      "hy": "Գրեք Common Lisp ֆունկցիա `(defun total-cigarettes-smoked (initial-cigarettes butt-to-cigarette-ratio)` հետևյալ խնդիրը լուծելու համար:\nՀաշվում է ընդհանուր ծխախոտների քանակը, որ Պետրոսը կարող է ծխել։\n'initial-cigarettes' մեկնարկային ծխախոտների քանակն է։\n'butt-to-cigarette-ratio' ծխախոտի մնացորդների քանակն է, որը պահանջվում է նոր ծխախոտ ստանալու համար։\nՖունկցիան վերադարձնում է ընդհանուր ծխախոտների քանակը, որ Պետրոսը կարող է ծխել։\nՕրինակ:\n(total-cigarettes-smoked 4 3) Վերադարձնում է 5\n(total-cigarettes-smoked 10 4) Վերադարձնում է 13",
      "bn": "একটি Common Lisp ফাংশন `(defun total-cigarettes-smoked (initial-cigarettes butt-to-cigarette-ratio)` লিখুন নিম্নলিখিত সমস্যার সমাধানের জন্য:\nপিটার মোট কতগুলো সিগারেট খেতে পারে তা গণনা করে।\n'initial-cigarettes' হল সিগারেটের প্রাথমিক সংখ্যা।\n'butt-to-cigarette-ratio' হল নতুন একটি সিগারেট পাওয়ার জন্য প্রয়োজনীয় সিগারেটের বাটের সংখ্যা।\nফাংশনটি পিটার মোট কতগুলো সিগারেট খেতে পারে তা ফেরত দেয়।\nউদাহরণ:\n(total-cigarettes-smoked 4 3) 5 ফেরত দেয়\n(total-cigarettes-smoked 10 4) 13 ফেরত দেয়",
      "bg": "Напишете функция на Common Lisp `(defun total-cigarettes-smoked (initial-cigarettes butt-to-cigarette-ratio)` за решаване на следния проблем:\nИзчислява общия брой цигари, които Петър може да изпуши.\n'initial-cigarettes' е началният брой цигари.\n'butt-to-cigarette-ratio' е броят на фасовете, необходими за получаване на нова цигара.\nФункцията връща общия брой цигари, които Петър може да изпуши.\nПример:\n(total-cigarettes-smoked 4 3) Връща 5\n(total-cigarettes-smoked 10 4) Връща 13",
      "zh": "编写一个 Common Lisp 函数 `(defun total-cigarettes-smoked (initial-cigarettes butt-to-cigarette-ratio)` 来解决以下问题：\n计算 Peter 可以抽的香烟总数。\n'initial-cigarettes' 是初始的香烟数量。\n'butt-to-cigarette-ratio' 是获得一支新香烟所需的烟蒂数量。\n该函数返回 Peter 可以抽的香烟总数。\n示例：\n(total-cigarettes-smoked 4 3) 返回 5\n(total-cigarettes-smoked 10 4) 返回 13",
      "fr": "Écrire une fonction Common Lisp `(defun total-cigarettes-smoked (initial-cigarettes butt-to-cigarette-ratio)` pour résoudre le problème suivant :\nCalcule le nombre total de cigarettes que Peter peut fumer.\n'initial-cigarettes' est le nombre initial de cigarettes.\n'butt-to-cigarette-ratio' est le nombre de mégots de cigarettes nécessaires pour obtenir une nouvelle cigarette.\nLa fonction renvoie le nombre total de cigarettes que Peter peut fumer.\nExemple :\n(total-cigarettes-smoked 4 3) Renvoie 5\n(total-cigarettes-smoked 10 4) Renvoie 13",
      "de": "Schreiben Sie eine Common Lisp-Funktion `(defun total-cigarettes-smoked (initial-cigarettes butt-to-cigarette-ratio)` um das folgende Problem zu lösen:\nBerechnet die Gesamtzahl der Zigaretten, die Peter rauchen kann.\n'initial-cigarettes' ist die Anfangsanzahl der Zigaretten.\n'butt-to-cigarette-ratio' ist die Anzahl der Zigarettenstummel, die benötigt werden, um eine neue Zigarette zu erhalten.\nDie Funktion gibt die Gesamtzahl der Zigaretten zurück, die Peter rauchen kann.\nBeispiel:\n(total-cigarettes-smoked 4 3) Gibt 5 zurück\n(total-cigarettes-smoked 10 4) Gibt 13 zurück",
      "ha": "Rubuta wani aikin Common Lisp `(defun total-cigarettes-smoked (initial-cigarettes butt-to-cigarette-ratio)` don warware matsalar mai zuwa:\nLissafa jimillar adadin sigari da Peter zai iya sha.\n'initial-cigarettes' shine adadin sigari na farko.\n'butt-to-cigarette-ratio' shine adadin bututun sigari da ake bukata don samun sabon sigari.\nAikin yana dawowa da jimillar adadin sigari da Peter zai iya sha.\nMisali:\n(total-cigarettes-smoked 4 3) Yana dawowa da 5\n(total-cigarettes-smoked 10 4) Yana dawowa da 13",
      "hi": "एक Common Lisp फ़ंक्शन `(defun total-cigarettes-smoked (initial-cigarettes butt-to-cigarette-ratio)` निम्नलिखित समस्या को हल करने के लिए:\nकुल सिगरेटों की संख्या की गणना करता है जो पीटर पी सकता है।\n'initial-cigarettes' सिगरेटों की प्रारंभिक संख्या है।\n'butt-to-cigarette-ratio' वह संख्या है जो एक नई सिगरेट प्राप्त करने के लिए आवश्यक सिगरेट बट्स की होती है।\nयह फ़ंक्शन कुल सिगरेटों की संख्या लौटाता है जो पीटर पी सकता है।\nउदाहरण:\n(total-cigarettes-smoked 4 3) 5 लौटाता है\n(total-cigarettes-smoked 10 4) 13 लौटाता है",
      "hu": "Írj egy Common Lisp függvényt `(defun total-cigarettes-smoked (initial-cigarettes butt-to-cigarette-ratio)` a következő probléma megoldására:\nKiszámítja a teljes cigarettaszámot, amit Péter elszívhat.\n'initial-cigarettes' a kezdő cigaretták száma.\n'butt-to-cigarette-ratio' az új cigaretta megszerzéséhez szükséges cigarettacsikkek száma.\nA függvény visszaadja a teljes cigarettaszámot, amit Péter elszívhat.\nPélda:\n(total-cigarettes-smoked 4 3) Visszaadja 5\n(total-cigarettes-smoked 10 4) Visszaadja 13"
    },
    "instruction_bertscore": {
      "sq": "0.9832260615823658",
      "hy": "0.975200003775889",
      "bn": "0.9764601149131744",
      "bg": "0.9828558145521167",
      "zh": "0.9882426704857828",
      "fr": "0.987759402768725",
      "de": "0.9938208074763857",
      "ha": "0.9862611338045788",
      "hi": "0.9851376803694455",
      "hu": "0.9880599305352308"
    },
    "level": "middle",
    "test": "(defun test-total-cigarettes-smoked ()\n(assert (equal (total-cigarettes-smoked 4 3) 5))\n(assert (equal (total-cigarettes-smoked 10 4) 13))\n(assert (equal (total-cigarettes-smoked 20 5) 24))\n(assert (equal (total-cigarettes-smoked 15 3) 22))\n(assert (equal (total-cigarettes-smoked 7 2) 13))\n(assert (equal (total-cigarettes-smoked 5 5) 6))\n(assert (equal (total-cigarettes-smoked 0 3) 0)))\n\n(test-total-cigarettes-smoked)",
    "entry_point": "total-cigarettes-smoked",
    "signature": "(defun total-cigarettes-smoked (initial-cigarettes butt-to-cigarette-ratio)",
    "docstring": {
      "en": "Calculates the total number of cigarettes Peter can smoke.\n'initial-cigarettes' is the starting number of cigarettes.\n'butt-to-cigarette-ratio' is the number of cigarette butts required to get a new cigarette.\nThe function returns the total number of cigarettes Peter can smoke.\nExample:\n(total-cigarettes-smoked 4 3) Returns 5\n(total-cigarettes-smoked 10 4) Returns 13",
      "sq": "Llogarit numrin total të cigareve që Peter mund të pijë.\n'initial-cigarettes' është numri fillestar i cigareve.\n'butt-to-cigarette-ratio' është numri i bishtave të cigareve të nevojshme për të marrë një cigare të re.\nFunksioni kthen numrin total të cigareve që Peter mund të pijë.\nShembull:\n(total-cigarettes-smoked 4 3) Kthen 5\n(total-cigarettes-smoked 10 4) Kthen 13",
      "hy": "Հաշվում է ընդհանուր ծխախոտների քանակը, որոնք Պետերը կարող է ծխել։  \n'initial-cigarettes' -ը մեկնարկային ծխախոտների քանակն է։  \n'butt-to-cigarette-ratio' -ը ծխախոտի մնացորդների քանակն է, որոնք անհրաժեշտ են նոր ծխախոտ ստանալու համար։  \nՖունկցիան վերադարձնում է ընդհանուր ծխախոտների քանակը, որոնք Պետերը կարող է ծխել։  \nՕրինակ:  \n(total-cigarettes-smoked 4 3) Վերադարձնում է 5  \n(total-cigarettes-smoked 10 4) Վերադարձնում է 13",
      "bn": "মোট কতগুলি সিগারেট পিটার ধূমপান করতে পারে তা গণনা করে।  \n'initial-cigarettes' হল সিগারেটের প্রাথমিক সংখ্যা।  \n'butt-to-cigarette-ratio' হল নতুন সিগারেট পেতে যতগুলি সিগারেটের বাট প্রয়োজন।  \nফাংশনটি পিটার মোট কতগুলি সিগারেট ধূমপান করতে পারে তা ফেরত দেয়।  \nউদাহরণ:  \n(total-cigarettes-smoked 4 3) Returns 5  \n(total-cigarettes-smoked 10 4) Returns 13  ",
      "bg": "Изчислява общия брой цигари, които Петър може да изпуши.  \n'initial-cigarettes' е началният брой цигари.  \n'butt-to-cigarette-ratio' е броят на фасовете, необходими за получаване на нова цигара.  \nФункцията връща общия брой цигари, които Петър може да изпуши.  \nПример:  \n(total-cigarettes-smoked 4 3) Връща 5  \n(total-cigarettes-smoked 10 4) Връща 13",
      "zh": "计算彼得可以抽的香烟总数。  \n'initial-cigarettes' 是起始的香烟数量。  \n'butt-to-cigarette-ratio' 是获得一支新香烟所需的烟头数量。  \n该函数返回彼得可以抽的香烟总数。  \n示例：  \n(total-cigarettes-smoked 4 3) 返回 5  \n(total-cigarettes-smoked 10 4) 返回 13  ",
      "fr": "Calcule le nombre total de cigarettes que Peter peut fumer.\n'initial-cigarettes' est le nombre initial de cigarettes.\n'butt-to-cigarette-ratio' est le nombre de mégots de cigarettes nécessaires pour obtenir une nouvelle cigarette.\nLa fonction renvoie le nombre total de cigarettes que Peter peut fumer.\nExemple :\n(total-cigarettes-smoked 4 3) Renvoie 5\n(total-cigarettes-smoked 10 4) Renvoie 13",
      "de": "Berechnet die Gesamtzahl der Zigaretten, die Peter rauchen kann.\n'initial-cigarettes' ist die anfängliche Anzahl der Zigaretten.\n'butt-to-cigarette-ratio' ist die Anzahl der Zigarettenstummel, die benötigt werden, um eine neue Zigarette zu erhalten.\nDie Funktion gibt die Gesamtzahl der Zigaretten zurück, die Peter rauchen kann.\nBeispiel:\n(total-cigarettes-smoked 4 3) Gibt 5 zurück\n(total-cigarettes-smoked 10 4) Gibt 13 zurück",
      "ha": "Yana ƙididdige jimlar adadin sigari da Peter zai iya sha.\n'initial-cigarettes' shine adadin sigari na farko.\n'butt-to-cigarette-ratio' shine adadin bututun sigari da ake buƙata don samun sabon sigari.\nAiki yana mayar da jimlar adadin sigari da Peter zai iya sha.\nMisali:\n(total-cigarettes-smoked 4 3) Yana Mayar da 5\n(total-cigarettes-smoked 10 4) Yana Mayar da 13",
      "hi": "कुल सिगरेटों की संख्या की गणना करता है जो पीटर पी सकता है।  \n'initial-cigarettes' सिगरेटों की प्रारंभिक संख्या है।  \n'butt-to-cigarette-ratio' वह संख्या है जो एक नई सिगरेट प्राप्त करने के लिए सिगरेट के बट्स की आवश्यकता होती है।  \nयह फ़ंक्शन कुल सिगरेटों की संख्या लौटाता है जो पीटर पी सकता है।  \nउदाहरण:  \n(total-cigarettes-smoked 4 3) 5 लौटाता है  \n(total-cigarettes-smoked 10 4) 13 लौटाता है  ",
      "hu": "Kiszámítja, hogy Péter összesen hány cigarettát tud elszívni.\n'initial-cigarettes' a kezdő cigaretták száma.\n'butt-to-cigarette-ratio' az a cigarettacsikkek száma, amely szükséges egy új cigaretta megszerzéséhez.\nA függvény visszaadja az összes cigaretta számát, amit Péter el tud szívni.\nPélda:\n(total-cigarettes-smoked 4 3) Visszaadja 5\n(total-cigarettes-smoked 10 4) Visszaadja 13"
    },
    "docstring_bertscore": {
      "sq": "0.983272541091528",
      "hy": "0.9785050146859285",
      "bn": "0.9939862665837877",
      "bg": "0.9825964032744852",
      "zh": "0.9815035389180312",
      "fr": "0.9814441484341018",
      "de": "0.9911406877450819",
      "ha": "0.9828911707599409",
      "hi": "0.9787133779556342",
      "hu": "0.9813476140689188"
    }
  },
  {
    "task_id": "Common Lisp/29",
    "prompt": {
      "en": "(defun divisible-five-digit-numbers (k)\n;; Finds all five-digit numbers between 10000 and 30000 where three sub-numbers \n;; (formed by consecutive digits) are divisible by 'k'.\n;; Each sub-number consists of three consecutive digits from the original number.\n;; The function returns a list of such five-digit numbers.\n;; Example:\n;; (divisible-five-digit-numbers 15) ;; Returns (22555 25555 28555 30000)\n;; (divisible-five-digit-numbers 7) ;; Returns a list of numbers or 'No' if no such numbers exist",
      "sq": "(defun divisible-five-digit-numbers (k)\n;; Gjen të gjitha numrat pesë-shifrorë midis 10000 dhe 30000 ku tre nën-numra\n;; (të formuar nga shifrat e njëpasnjëshme) janë të pjestueshëm me 'k'.\n;; Çdo nën-numër përbëhet nga tre shifra të njëpasnjëshme nga numri origjinal.\n;; Funksioni kthen një listë të tillë numrash pesë-shifrorë.\n;; Shembull:\n;; (divisible-five-digit-numbers 15) ;; Kthen (22555 25555 28555 30000)\n;; (divisible-five-digit-numbers 7) ;; Kthen një listë numrash ose 'Jo' nëse nuk ekzistojnë numra të tillë",
      "hy": "(defun divisible-five-digit-numbers (k)\n;; Գտնում է բոլոր հնգանիշ թվերը 10000-ից 30000-ի միջև, որտեղ երեք ենթաթվերը \n;; (կազմված հաջորդական թվանշաններից) բաժանվում են 'k'-ի վրա:\n;; Յուրաքանչյուր ենթաթիվ կազմված է սկզբնական թվի երեք հաջորդական թվանշաններից:\n;; Ֆունկցիան վերադարձնում է այդպիսի հնգանիշ թվերի ցուցակը:\n;; Օրինակ:\n;; (divisible-five-digit-numbers 15) ;; Վերադարձնում է (22555 25555 28555 30000)\n;; (divisible-five-digit-numbers 7) ;; Վերադարձնում է թվերի ցուցակ կամ 'Ոչ' եթե այդպիսի թվեր չկան",
      "bn": "(defun divisible-five-digit-numbers (k)\n;; 10000 এবং 30000 এর মধ্যে সমস্ত পাঁচ-অঙ্কের সংখ্যা খুঁজে বের করে যেখানে তিনটি উপ-সংখ্যা \n;; (ক্রমাগত অঙ্ক দ্বারা গঠিত) 'k' দ্বারা বিভাজ্য।\n;; প্রতিটি উপ-সংখ্যা মূল সংখ্যার তিনটি ক্রমাগত অঙ্ক নিয়ে গঠিত।\n;; ফাংশনটি এমন পাঁচ-অঙ্কের সংখ্যার একটি তালিকা প্রদান করে।\n;; উদাহরণ:\n;; (divisible-five-digit-numbers 15) ;; (22555 25555 28555 30000) প্রদান করে\n;; (divisible-five-digit-numbers 7) ;; সংখ্যার একটি তালিকা প্রদান করে বা 'No' প্রদান করে যদি এমন কোনো সংখ্যা না থাকে",
      "bg": "(defun divisible-five-digit-numbers (k)\n;; Намира всички петцифрени числа между 10000 и 30000, при които три подчисла\n;; (образувани от последователни цифри) са делими на 'k'.\n;; Всяко подчисло се състои от три последователни цифри от оригиналното число.\n;; Функцията връща списък с такива петцифрени числа.\n;; Пример:\n;; (divisible-five-digit-numbers 15) ;; Връща (22555 25555 28555 30000)\n;; (divisible-five-digit-numbers 7) ;; Връща списък с числа или 'No', ако няма такива числа",
      "zh": "(defun divisible-five-digit-numbers (k)\n;; 查找所有介于 10000 和 30000 之间的五位数，其中三个子数字\n;; （由连续数字组成）可被 'k' 整除。\n;; 每个子数字由原始数字中的三个连续数字组成。\n;; 该函数返回这样的五位数的列表。\n;; 示例：\n;; (divisible-five-digit-numbers 15) ;; 返回 (22555 25555 28555 30000)\n;; (divisible-five-digit-numbers 7) ;; 返回一个数字列表或 'No' 如果不存在这样的数字",
      "fr": "(defun divisible-five-digit-numbers (k)\n;; Trouve tous les nombres à cinq chiffres entre 10000 et 30000 où trois sous-nombres\n;; (formés par des chiffres consécutifs) sont divisibles par 'k'.\n;; Chaque sous-nombre se compose de trois chiffres consécutifs du nombre original.\n;; La fonction renvoie une liste de ces nombres à cinq chiffres.\n;; Exemple :\n;; (divisible-five-digit-numbers 15) ;; Renvoie (22555 25555 28555 30000)\n;; (divisible-five-digit-numbers 7) ;; Renvoie une liste de nombres ou 'No' si aucun de ces nombres n'existe",
      "de": "(defun divisible-five-digit-numbers (k)\n;; Findet alle fünfstelligen Zahlen zwischen 10000 und 30000, bei denen drei Teilzahlen \n;; (gebildet durch aufeinanderfolgende Ziffern) durch 'k' teilbar sind.\n;; Jede Teilzahl besteht aus drei aufeinanderfolgenden Ziffern der ursprünglichen Zahl.\n;; Die Funktion gibt eine Liste solcher fünfstelligen Zahlen zurück.\n;; Beispiel:\n;; (divisible-five-digit-numbers 15) ;; Gibt (22555 25555 28555 30000) zurück\n;; (divisible-five-digit-numbers 7) ;; Gibt eine Liste von Zahlen oder 'No' zurück, wenn keine solchen Zahlen existieren",
      "ha": "(defun divisible-five-digit-numbers (k)\n;; Yana nemo duk lambobin da ke da tsawon lamba biyar tsakanin 10000 da 30000 inda lambobi uku \n;; (wanda aka kafa ta lambobi masu jere) suna raba 'k'.\n;; Kowane ƙaramin lamba yana ƙunshe da lambobi uku masu jere daga lambar asali.\n;; Aikin yana dawowa da jerin irin waɗannan lambobin da ke da tsawon lamba biyar.\n;; Misali:\n;; (divisible-five-digit-numbers 15) ;; Yana dawowa (22555 25555 28555 30000)\n;; (divisible-five-digit-numbers 7) ;; Yana dawowa da jerin lambobi ko 'No' idan babu irin waɗannan lambobin da suke akwai",
      "hi": "(defun divisible-five-digit-numbers (k)\n;; उन सभी पाँच-अंकीय संख्याओं को खोजता है जो 10000 और 30000 के बीच हैं जहाँ तीन उप-संख्याएँ \n;; (लगातार अंकों द्वारा बनाई गई) 'k' से विभाज्य हैं।\n;; प्रत्येक उप-संख्या मूल संख्या से लगातार तीन अंकों से बनी होती है।\n;; यह फ़ंक्शन ऐसी पाँच-अंकीय संख्याओं की एक सूची लौटाता है।\n;; उदाहरण:\n;; (divisible-five-digit-numbers 15) ;; (22555 25555 28555 30000) लौटाता है\n;; (divisible-five-digit-numbers 7) ;; संख्याओं की एक सूची लौटाता है या 'No' अगर ऐसी कोई संख्या मौजूद नहीं है",
      "hu": "(defun divisible-five-digit-numbers (k)\n;; Megkeresi az összes ötjegyű számot 10000 és 30000 között, ahol három részszám \n;; (amelyeket egymást követő számjegyek alkotnak) osztható 'k'-val.\n;; Minden részszám az eredeti szám három egymást követő számjegyéből áll.\n;; A függvény visszaad egy listát az ilyen ötjegyű számokról.\n;; Példa:\n;; (divisible-five-digit-numbers 15) ;; Visszaadja (22555 25555 28555 30000)\n;; (divisible-five-digit-numbers 7) ;; Visszaad egy számokból álló listát vagy 'No'-t, ha nem léteznek ilyen számok"
    },
    "prompt_bertscore": {
      "sq": "0.9978671069684474",
      "hy": "0.9600671495663651",
      "bn": "0.9927054978868748",
      "bg": "0.9925382511060434",
      "zh": "0.98157047735644",
      "fr": "0.9905545294906479",
      "de": "0.9937705539899838",
      "ha": "0.970263442916029",
      "hi": "0.9862480241994306",
      "hu": "1"
    },
    "canonical_solution": "(let ((results '()))\n(loop for num from 10000 to 30000\nwhen (and (zerop (mod (parse-integer (subseq (write-to-string num) 0 3)) k))\n(zerop (mod (parse-integer (subseq (write-to-string num) 1 4)) k))\n(zerop (mod (parse-integer (subseq (write-to-string num) 2 5)) k)))\ndo (push num results))\n(if (null results)\n'No\n(nreverse results))))",
    "instruction": {
      "en": "Write a Common Lisp function `(defun divisible-five-digit-numbers (k)` to solve the following problem:\nFinds all five-digit numbers between 10000 and 30000 where three sub-numbers \n(formed by consecutive digits) are divisible by 'k'.\nEach sub-number consists of three consecutive digits from the original number.\nThe function returns a list of such five-digit numbers.\nExample:\n(divisible-five-digit-numbers 15) Returns (22555 25555 28555 30000)\n(divisible-five-digit-numbers 7) Returns a list of numbers or 'No' if no such numbers exist",
      "sq": "Shkruani një funksion Common Lisp `(defun divisible-five-digit-numbers (k)` për të zgjidhur problemin e mëposhtëm:\nGjen të gjitha numrat pesë-shifrorë midis 10000 dhe 30000 ku tre nën-numra \n(të formuar nga shifra të njëpasnjëshme) janë të pjestueshëm me 'k'.\nÇdo nën-numër përbëhet nga tre shifra të njëpasnjëshme nga numri origjinal.\nFunksioni kthen një listë të tillë numrash pesë-shifrorë.\nShembull:\n(divisible-five-digit-numbers 15) Kthen (22555 25555 28555 30000)\n(divisible-five-digit-numbers 7) Kthen një listë numrash ose 'Jo' nëse nuk ekzistojnë numra të tillë",
      "hy": "Գրեք Common Lisp ֆունկցիա `(defun divisible-five-digit-numbers (k)` հետևյալ խնդիրը լուծելու համար:\nԳտնում է բոլոր հնգանիշ թվերը 10000-ից մինչև 30000, որտեղ երեք ենթաթվեր \n(կազմված հաջորդական թվանշաններից) բաժանվում են 'k'-ի վրա:\nՅուրաքանչյուր ենթաթիվ բաղկացած է սկզբնական թվի երեք հաջորդական թվանշաններից:\nՖունկցիան վերադարձնում է այդպիսի հնգանիշ թվերի ցուցակը:\nՕրինակ:\n(divisible-five-digit-numbers 15) Վերադարձնում է (22555 25555 28555 30000)\n(divisible-five-digit-numbers 7) Վերադարձնում է թվերի ցուցակ կամ 'Ոչ' եթե այդպիսի թվեր չկան",
      "bn": "একটি Common Lisp ফাংশন `(defun divisible-five-digit-numbers (k)` লিখুন নিম্নলিখিত সমস্যার সমাধানের জন্য:\n১০০০০ এবং ৩০০০০ এর মধ্যে সমস্ত পাঁচ-অঙ্কের সংখ্যা খুঁজে বের করে যেখানে তিনটি উপ-সংখ্যা (ক্রমাগত অঙ্ক দ্বারা গঠিত) 'k' দ্বারা বিভাজ্য।\nপ্রতিটি উপ-সংখ্যা মূল সংখ্যার তিনটি ক্রমাগত অঙ্ক নিয়ে গঠিত।\nফাংশনটি এমন পাঁচ-অঙ্কের সংখ্যার একটি তালিকা প্রদান করে।\nউদাহরণ:\n(divisible-five-digit-numbers 15) প্রদান করে (22555 25555 28555 30000)\n(divisible-five-digit-numbers 7) সংখ্যা বা 'No' প্রদান করে যদি এমন কোনো সংখ্যা না থাকে",
      "bg": "Напишете функция на Common Lisp `(defun divisible-five-digit-numbers (k)` за решаване на следния проблем:\nНамира всички петцифрени числа между 10000 и 30000, където три под-числа \n(образувани от последователни цифри) са делими на 'k'.\nВсяко под-число се състои от три последователни цифри от оригиналното число.\nФункцията връща списък от такива петцифрени числа.\nПример:\n(divisible-five-digit-numbers 15) Връща (22555 25555 28555 30000)\n(divisible-five-digit-numbers 7) Връща списък от числа или 'No', ако такива числа не съществуват.",
      "zh": "编写一个 Common Lisp 函数 `(defun divisible-five-digit-numbers (k)` 来解决以下问题：\n找到所有在 10000 到 30000 之间的五位数，其中三个子数字（由连续的数字组成）可以被 'k' 整除。\n每个子数字由原始数字中的三个连续数字组成。\n该函数返回这样的五位数的列表。\n示例：\n(divisible-five-digit-numbers 15) 返回 (22555 25555 28555 30000)\n(divisible-five-digit-numbers 7) 返回一个数字列表或 'No' 如果不存在这样的数字",
      "fr": "Écrire une fonction Common Lisp `(defun divisible-five-digit-numbers (k)` pour résoudre le problème suivant :  \nTrouver tous les nombres à cinq chiffres entre 10000 et 30000 où trois sous-nombres (formés par des chiffres consécutifs) sont divisibles par 'k'.  \nChaque sous-nombre est composé de trois chiffres consécutifs du nombre original.  \nLa fonction renvoie une liste de ces nombres à cinq chiffres.  \nExemple :  \n(divisible-five-digit-numbers 15) Renvoie (22555 25555 28555 30000)  \n(divisible-five-digit-numbers 7) Renvoie une liste de nombres ou 'No' si aucun de ces nombres n'existe  ",
      "de": "Schreiben Sie eine Common Lisp-Funktion `(defun divisible-five-digit-numbers (k)`, um das folgende Problem zu lösen:\nFindet alle fünfstelligen Zahlen zwischen 10000 und 30000, bei denen drei Teilzahlen \n(gebildet durch aufeinanderfolgende Ziffern) durch 'k' teilbar sind.\nJede Teilzahl besteht aus drei aufeinanderfolgenden Ziffern der ursprünglichen Zahl.\nDie Funktion gibt eine Liste solcher fünfstelligen Zahlen zurück.\nBeispiel:\n(divisible-five-digit-numbers 15) Gibt (22555 25555 28555 30000) zurück\n(divisible-five-digit-numbers 7) Gibt eine Liste von Zahlen oder 'No' zurück, wenn keine solchen Zahlen existieren",
      "ha": "Rubuta aikin Common Lisp `(defun divisible-five-digit-numbers (k)` don warware matsalar mai zuwa:\nNemo duk lambobin da ke da tsawon lamba biyar tsakanin 10000 da 30000 inda lambobi uku (wanda aka kafa ta lambobi masu jere) suna raba 'k'.\nKowane ƙaramin lamba yana ƙunshe da lambobi uku masu jere daga asalin lambar.\nAikin yana dawowa da jerin irin waɗannan lambobin da ke da tsawon lamba biyar.\nMisali:\n(divisible-five-digit-numbers 15) Yana dawowa (22555 25555 28555 30000)\n(divisible-five-digit-numbers 7) Yana dawowa da jerin lambobi ko 'A'a' idan babu irin waɗannan lambobin da suka wanzu",
      "hi": "एक Common Lisp फ़ंक्शन `(defun divisible-five-digit-numbers (k)` लिखें ताकि निम्नलिखित समस्या का समाधान किया जा सके:\nउन सभी पाँच-अंकीय संख्याओं को खोजें जो 10000 और 30000 के बीच हैं, जहाँ तीन उप-संख्याएँ \n(लगातार अंकों द्वारा बनाई गई) 'k' द्वारा विभाज्य हैं।\nप्रत्येक उप-संख्या मूल संख्या से लगातार तीन अंकों से बनी होती है।\nफ़ंक्शन ऐसी पाँच-अंकीय संख्याओं की एक सूची लौटाता है।\nउदाहरण:\n(divisible-five-digit-numbers 15) (22555 25555 28555 30000) लौटाता है\n(divisible-five-digit-numbers 7) संख्याओं की एक सूची लौटाता है या 'No' यदि ऐसी कोई संख्या मौजूद नहीं है",
      "hu": "Írj egy Common Lisp függvényt `(defun divisible-five-digit-numbers (k)` a következő probléma megoldására:\nMegtalálja az összes ötjegyű számot 10000 és 30000 között, ahol három részszám (egymást követő számjegyekből képzett) osztható 'k'-val.\nMinden részszám az eredeti szám három egymást követő számjegyéből áll.\nA függvény visszaad egy listát az ilyen ötjegyű számokról.\nPélda:\n(divisible-five-digit-numbers 15) Visszaadja (22555 25555 28555 30000)\n(divisible-five-digit-numbers 7) Visszaad egy számokból álló listát vagy 'No'-t, ha nem léteznek ilyen számok"
    },
    "instruction_bertscore": {
      "sq": "0.9884645406213989",
      "hy": "0.9754232643241723",
      "bn": "0.9705367583203329",
      "bg": "0.9847465771491878",
      "zh": "0.967781357674617",
      "fr": "0.9859266402429161",
      "de": "0.9914306881013929",
      "ha": "0.9700366070208871",
      "hi": "0.9867477782381143",
      "hu": "0.9926163128457901"
    },
    "level": "middle",
    "test": "(defun test-divisible-five-digit-numbers ()\n(assert (equal (divisible-five-digit-numbers 15) '(22555 25555 28555 30000)))\n(assert (equal (divisible-five-digit-numbers 31) '(15589 18682))) ;; No such numbers exist\n(assert (equal (divisible-five-digit-numbers 999) 'No))) ;; No such numbers exist for a large divisor\n\n(test-divisible-five-digit-numbers)",
    "entry_point": "divisible-five-digit-numbers",
    "signature": "(defun divisible-five-digit-numbers (k)",
    "docstring": {
      "en": "Finds all five-digit numbers between 10000 and 30000 where three sub-numbers \n(formed by consecutive digits) are divisible by 'k'.\nEach sub-number consists of three consecutive digits from the original number.\nThe function returns a list of such five-digit numbers.\nExample:\n(divisible-five-digit-numbers 15) Returns (22555 25555 28555 30000)\n(divisible-five-digit-numbers 7) Returns a list of numbers or 'No' if no such numbers exist",
      "sq": "Gjen të gjitha numrat pesë-shifrorë midis 10000 dhe 30000 ku tre nën-numra \n(të formuar nga shifra të njëpasnjëshme) janë të pjestueshëm me 'k'.\nÇdo nën-numër përbëhet nga tre shifra të njëpasnjëshme nga numri origjinal.\nFunksioni kthen një listë të tillë numrash pesë-shifrorë.\nShembull:\n(divisible-five-digit-numbers 15) Kthen (22555 25555 28555 30000)\n(divisible-five-digit-numbers 7) Kthen një listë numrash ose 'Jo' nëse nuk ekzistojnë numra të tillë",
      "hy": "Գտնում է բոլոր հնգանիշ թվերը 10000-ից 30000 միջակայքում, որտեղ երեք ենթաթվերը \n(կազմված հաջորդական թվանշաններից) բաժանվում են 'k'-ի վրա:\nՅուրաքանչյուր ենթաթիվ կազմված է սկզբնական թվի երեք հաջորդական թվանշաններից:\nՖունկցիան վերադարձնում է նման հնգանիշ թվերի ցուցակը:\nՕրինակ:\n(divisible-five-digit-numbers 15) Վերադարձնում է (22555 25555 28555 30000)\n(divisible-five-digit-numbers 7) Վերադարձնում է թվերի ցուցակ կամ 'Ոչ' եթե նման թվեր չկան",
      "bn": "10000 এবং 30000 এর মধ্যে সমস্ত পাঁচ-অঙ্কের সংখ্যা খুঁজে বের করে যেখানে তিনটি উপ-সংখ্যা (ক্রমাগত অঙ্ক দ্বারা গঠিত) 'k' দ্বারা বিভাজ্য। \nপ্রতিটি উপ-সংখ্যা মূল সংখ্যার তিনটি ক্রমাগত অঙ্ক নিয়ে গঠিত। \nফাংশনটি এই ধরনের পাঁচ-অঙ্কের সংখ্যার একটি তালিকা প্রদান করে। \nউদাহরণ:\n(divisible-five-digit-numbers 15) প্রদান করে (22555 25555 28555 30000)\n(divisible-five-digit-numbers 7) সংখ্যা বা 'No' প্রদান করে যদি এমন কোনো সংখ্যা না থাকে",
      "bg": "Намира всички петцифрени числа между 10000 и 30000, където три под-числа (образувани от последователни цифри) са делими на 'k'. Всяко под-число се състои от три последователни цифри от оригиналното число. Функцията връща списък с такива петцифрени числа. Пример: (divisible-five-digit-numbers 15) Връща (22555 25555 28555 30000) (divisible-five-digit-numbers 7) Връща списък с числа или 'No', ако такива числа не съществуват.",
      "zh": "查找10000到30000之间的所有五位数，其中三个子数字（由连续数字组成）可以被 'k' 整除。\n每个子数字由原始数字中的三个连续数字组成。\n该函数返回这样五位数的列表。\n示例：\n(divisible-five-digit-numbers 15) 返回 (22555 25555 28555 30000)\n(divisible-five-digit-numbers 7) 返回一个数字列表或 'No' 如果不存在这样的数字",
      "fr": "Trouve tous les nombres à cinq chiffres entre 10000 et 30000 où trois sous-nombres (formés par des chiffres consécutifs) sont divisibles par 'k'. Chaque sous-nombre se compose de trois chiffres consécutifs du nombre original. La fonction renvoie une liste de ces nombres à cinq chiffres. Exemple : (divisible-five-digit-numbers 15) Renvoie (22555 25555 28555 30000) (divisible-five-digit-numbers 7) Renvoie une liste de nombres ou 'No' si aucun de ces nombres n'existe.",
      "de": "Findet alle fünfstelligen Zahlen zwischen 10000 und 30000, bei denen drei Teilzahlen (gebildet durch aufeinanderfolgende Ziffern) durch 'k' teilbar sind. Jede Teilzahl besteht aus drei aufeinanderfolgenden Ziffern der ursprünglichen Zahl. Die Funktion gibt eine Liste solcher fünfstelligen Zahlen zurück. Beispiel: (divisible-five-digit-numbers 15) Gibt (22555 25555 28555 30000) zurück (divisible-five-digit-numbers 7) Gibt eine Liste von Zahlen oder 'Nein' zurück, wenn keine solchen Zahlen existieren.",
      "ha": "Nemo duk lambobin da suka ƙunshi haruffa biyar tsakanin 10000 da 30000 inda lambobi uku (wanda aka samar da su ta hanyar lambobi masu jere) suna raba 'k'. Kowanne lamba uku ya ƙunshi lambobi uku masu jere daga asalin lambar. Aikin yana dawowa da jerin irin waɗannan lambobin da suka ƙunshi haruffa biyar. Misali: (divisible-five-digit-numbers 15) Yana dawowa (22555 25555 28555 30000) (divisible-five-digit-numbers 7) Yana dawowa da jerin lambobi ko 'A'a' idan babu irin waɗannan lambobin da suke akwai",
      "hi": "10000 और 30000 के बीच सभी पाँच-अंकीय संख्याएँ खोजता है जहाँ तीन उप-संख्याएँ \n(लगातार अंकों द्वारा बनाई गई) 'k' द्वारा विभाज्य हैं।\nप्रत्येक उप-संख्या मूल संख्या से लगातार तीन अंकों से बनी होती है।\nयह फ़ंक्शन ऐसी पाँच-अंकीय संख्याओं की एक सूची लौटाता है।\nउदाहरण:\n(divisible-five-digit-numbers 15) लौटाता है (22555 25555 28555 30000)\n(divisible-five-digit-numbers 7) संख्याओं की एक सूची लौटाता है या 'No' यदि ऐसी कोई संख्या मौजूद नहीं है",
      "hu": "Megtalálja az összes ötjegyű számot 10000 és 30000 között, ahol három részszám \n(egymást követő számjegyekből képzett) osztható 'k'-val.\nMinden részszám az eredeti szám három egymást követő számjegyéből áll.\nA függvény visszaad egy listát az ilyen ötjegyű számokról.\nPélda:\n(divisible-five-digit-numbers 15) Visszaadja (22555 25555 28555 30000)\n(divisible-five-digit-numbers 7) Visszaad egy számokból álló listát vagy 'No'-t, ha nem léteznek ilyen számok."
    },
    "docstring_bertscore": {
      "sq": "0.9835949181999476",
      "hy": "0.958814586383559",
      "bn": "0.9243236124991369",
      "bg": "0.985920284070723",
      "zh": "0.9586566752306364",
      "fr": "0.980210256507113",
      "de": "0.990350138828563",
      "ha": "0.9161682463146065",
      "hi": "0.9762320872357463",
      "hu": "0.9877272246469974"
    }
  },
  {
    "task_id": "Common Lisp/30",
    "prompt": {
      "en": "(defun count-digit-two (L R)\n;; This function counts the occurrences of the digit '2' in all integers within a given range [L, R].\n;; Both L and R are inclusive.\n;; It iterates through each number in the range and counts how many times '2' appears in each number.\n;; Example:\n;; >>> count-digit-two 2 22\n;; 6\n;; >>> count-digit-two 10 25\n;; 9",
      "sq": "(defun count-digit-two (L R)\n;; Kjo funksion numëron shfaqjet e shifrës '2' në të gjitha numrat brenda një intervali të dhënë [L, R].\n;; Të dy L dhe R janë përfshirës.\n;; Ai iteron nëpër secilin numër në interval dhe numëron sa herë shfaqet '2' në secilin numër.\n;; Shembull:\n;; >>> count-digit-two 2 22\n;; 6\n;; >>> count-digit-two 10 25\n;; 9",
      "hy": "(defun count-digit-two (L R)\n;; Այս ֆունկցիան հաշվում է '2' թվանշանի հանդիպումների քանակը տրված [L, R] միջակայքում գտնվող բոլոր ամբողջ թվերում:\n;; Ե՛վ L, և՛ R ներառյալ են:\n;; Այն անցնում է միջակայքի յուրաքանչյուր թվով և հաշվում, թե քանի անգամ է '2' հայտնվում յուրաքանչյուր թվի մեջ:\n;; Օրինակ:\n;; >>> count-digit-two 2 22\n;; 6\n;; >>> count-digit-two 10 25\n;; 9",
      "bn": "(defun count-digit-two (L R)\n;; এই ফাংশনটি একটি নির্দিষ্ট পরিসীমা [L, R] এর মধ্যে সমস্ত পূর্ণসংখ্যায় '2' অঙ্কটির উপস্থিতি গণনা করে।\n;; উভয় L এবং R অন্তর্ভুক্ত।\n;; এটি পরিসীমার প্রতিটি সংখ্যার মাধ্যমে পুনরাবৃত্তি করে এবং প্রতিটি সংখ্যায় '2' কতবার উপস্থিত হয়েছে তা গণনা করে।\n;; উদাহরণ:\n;; >>> count-digit-two 2 22\n;; 6\n;; >>> count-digit-two 10 25\n;; 9",
      "bg": "(defun count-digit-two (L R)\n;; Тази функция брои появяванията на цифрата '2' във всички цели числа в даден диапазон [L, R].\n;; И L, и R са включени.\n;; Тя преминава през всяко число в диапазона и брои колко пъти '2' се появява във всяко число.\n;; Пример:\n;; >>> count-digit-two 2 22\n;; 6\n;; >>> count-digit-two 10 25\n;; 9",
      "zh": "(defun count-digit-two (L R)\n;; 此函数计算给定范围 [L, R] 内所有整数中数字 '2' 出现的次数。\n;; L 和 R 都是包含在内的。\n;; 它遍历范围内的每个数字，并计算每个数字中 '2' 出现的次数。\n;; 示例:\n;; >>> count-digit-two 2 22\n;; 6\n;; >>> count-digit-two 10 25\n;; 9",
      "fr": "(defun count-digit-two (L R)\n;; Cette fonction compte les occurrences du chiffre '2' dans tous les entiers d'un intervalle donné [L, R].\n;; L et R sont tous deux inclusifs.\n;; Elle parcourt chaque nombre de l'intervalle et compte combien de fois '2' apparaît dans chaque nombre.\n;; Exemple:\n;; >>> count-digit-two 2 22\n;; 6\n;; >>> count-digit-two 10 25\n;; 9",
      "de": "(defun count-digit-two (L R)\n;; Diese Funktion zählt die Vorkommen der Ziffer '2' in allen ganzen Zahlen innerhalb eines gegebenen Bereichs [L, R].\n;; Sowohl L als auch R sind inklusive.\n;; Sie iteriert durch jede Zahl im Bereich und zählt, wie oft '2' in jeder Zahl erscheint.\n;; Beispiel:\n;; >>> count-digit-two 2 22\n;; 6\n;; >>> count-digit-two 10 25\n;; 9",
      "ha": "(defun count-digit-two (L R)\n;; Wannan aikin yana ƙirga yawan bayyanar lamba '2' a duk lambobin cikinsu a cikin kewayon da aka bayar [L, R].\n;; Duk L da R suna ciki.\n;; Yana zagayawa ta kowace lamba a cikin kewayon kuma yana ƙirga sau nawa '2' ya bayyana a kowace lamba.\n;; Misali:\n;; >>> count-digit-two 2 22\n;; 6\n;; >>> count-digit-two 10 25\n;; 9",
      "hi": "(defun count-digit-two (L R)\n;; यह फ़ंक्शन दिए गए सीमा [L, R] के भीतर सभी पूर्णांकों में अंक '2' की घटनाओं की गणना करता है।\n;; दोनों L और R शामिल हैं।\n;; यह सीमा में प्रत्येक संख्या के माध्यम से पुनरावृत्ति करता है और प्रत्येक संख्या में '2' कितनी बार दिखाई देता है, इसकी गणना करता है।\n;; उदाहरण:\n;; >>> count-digit-two 2 22\n;; 6\n;; >>> count-digit-two 10 25\n;; 9",
      "hu": "(defun count-digit-two (L R)\n;; Ez a függvény megszámolja a '2' számjegy előfordulásait az összes egész szám között egy adott [L, R] tartományban.\n;; Mind L, mind R beleértendő.\n;; Végigmegy a tartomány minden számán, és megszámolja, hogy hányszor jelenik meg a '2' minden egyes számban.\n;; Példa:\n;; >>> count-digit-two 2 22\n;; 6\n;; >>> count-digit-two 10 25\n;; 9"
    },
    "prompt_bertscore": {
      "sq": "0.994864610128724",
      "hy": "0.9966536739707053",
      "bn": "0.9957723509700535",
      "bg": "0.9913552085565996",
      "zh": "0.9780227401207758",
      "fr": "0.9898195970808189",
      "de": "0.995536179447003",
      "ha": "0.9797172559013845",
      "hi": "0.9966536739707053",
      "hu": "0.9822629028647276"
    },
    "canonical_solution": "(let ((count 0))\n(loop for i from L to R do\n(loop for char across (write-to-string i) do\n(when (char= char #\\2) (incf count))))\ncount))",
    "instruction": {
      "en": "Write a Common Lisp function `(defun count-digit-two (L R)` to solve the following problem:\nThis function counts the occurrences of the digit '2' in all integers within a given range [L, R].\nBoth L and R are inclusive.\nIt iterates through each number in the range and counts how many times '2' appears in each number.\nExample:\n>>> count-digit-two 2 22\n6\n>>> count-digit-two 10 25\n9",
      "sq": "Shkruani një funksion Common Lisp `(defun count-digit-two (L R)` për të zgjidhur problemin e mëposhtëm:\nKy funksion numëron sa herë shfaqet shifra '2' në të gjitha numrat brenda një intervali të dhënë [L, R].\nTë dy L dhe R janë përfshirës.\nAi iteron nëpër secilin numër në interval dhe numëron sa herë shfaqet '2' në secilin numër.\nShembull:\n>>> count-digit-two 2 22\n6\n>>> count-digit-two 10 25\n9",
      "hy": "Գրեք Common Lisp ֆունկցիա `(defun count-digit-two (L R)` հետևյալ խնդիրը լուծելու համար:\nԱյս ֆունկցիան հաշվում է '2' թվանշանի հանդիպումների քանակը տրված միջակայքում [L, R] գտնվող բոլոր ամբողջ թվերի մեջ:\nԵ՛վ L, և՛ R ներառյալ են:\nԱյն անցնում է միջակայքում գտնվող յուրաքանչյուր թվի միջով և հաշվում, թե քանի անգամ է '2'-ը հանդիպում յուրաքանչյուր թվի մեջ:\nՕրինակ:\n>>> count-digit-two 2 22\n6\n>>> count-digit-two 10 25\n9",
      "bn": "একটি Common Lisp ফাংশন `(defun count-digit-two (L R)` লিখুন নিম্নলিখিত সমস্যার সমাধানের জন্য:\nএই ফাংশনটি একটি নির্দিষ্ট পরিসর [L, R] এর মধ্যে সমস্ত পূর্ণসংখ্যায় অঙ্ক '2' এর উপস্থিতি গণনা করে।\nL এবং R উভয়ই অন্তর্ভুক্ত।\nএটি পরিসরের প্রতিটি সংখ্যার মাধ্যমে পুনরাবৃত্তি করে এবং প্রতিটি সংখ্যায় কতবার '2' উপস্থিত হয়েছে তা গণনা করে।\nউদাহরণ:\n>>> count-digit-two 2 22\n6\n>>> count-digit-two 10 25\n9",
      "bg": "Напишете функция на Common Lisp `(defun count-digit-two (L R)` за решаване на следния проблем:\nТази функция брои появяванията на цифрата '2' във всички цели числа в даден диапазон [L, R].\nИ L, и R са включени.\nТя преминава през всяко число в диапазона и брои колко пъти '2' се появява във всяко число.\nПример:\n>>> count-digit-two 2 22\n6\n>>> count-digit-two 10 25\n9",
      "zh": "编写一个 Common Lisp 函数 `(defun count-digit-two (L R)` 来解决以下问题：\n此函数计算给定范围 [L, R] 内所有整数中数字 '2' 出现的次数。\nL 和 R 都是包含在内的。\n它遍历范围内的每个数字，并计算每个数字中出现 '2' 的次数。\n示例:\n>>> count-digit-two 2 22\n6\n>>> count-digit-two 10 25\n9",
      "fr": "Écrire une fonction Common Lisp `(defun count-digit-two (L R)` pour résoudre le problème suivant :  \nCette fonction compte les occurrences du chiffre '2' dans tous les entiers d'un intervalle donné [L, R].  \nL et R sont tous deux inclusifs.  \nElle parcourt chaque nombre de l'intervalle et compte combien de fois '2' apparaît dans chaque nombre.  \nExemple :  \n>>> count-digit-two 2 22  \n6  \n>>> count-digit-two 10 25  \n9",
      "de": "Schreiben Sie eine Common Lisp-Funktion `(defun count-digit-two (L R)` um das folgende Problem zu lösen:\nDiese Funktion zählt die Vorkommen der Ziffer '2' in allen ganzen Zahlen innerhalb eines gegebenen Bereichs [L, R].\nSowohl L als auch R sind inklusive.\nSie iteriert durch jede Zahl im Bereich und zählt, wie oft '2' in jeder Zahl erscheint.\nBeispiel:\n>>> count-digit-two 2 22\n6\n>>> count-digit-two 10 25\n9",
      "ha": "Rubuta aikin Common Lisp `(defun count-digit-two (L R)` don warware matsalar mai zuwa:\nWannan aikin yana ƙidaya yawan fitowar lamba '2' a cikin dukkan lambobi a cikin kewayon da aka bayar [L, R].\nDuka L da R suna ciki.\nYana zagayawa ta kowace lamba a cikin kewayon kuma yana ƙidaya sau nawa '2' ya bayyana a kowace lamba.\nMisali:\n>>> count-digit-two 2 22\n6\n>>> count-digit-two 10 25\n9",
      "hi": "एक Common Lisp फ़ंक्शन `(defun count-digit-two (L R)` लिखें ताकि निम्नलिखित समस्या का समाधान किया जा सके:\nयह फ़ंक्शन दिए गए रेंज [L, R] के सभी पूर्णांकों में अंक '2' की घटनाओं की गिनती करता है।\nदोनों L और R सम्मिलित हैं।\nयह रेंज में प्रत्येक संख्या के माध्यम से इटरेट करता है और गिनता है कि प्रत्येक संख्या में '2' कितनी बार आता है।\nउदाहरण:\n>>> count-digit-two 2 22\n6\n>>> count-digit-two 10 25\n9",
      "hu": "Írj egy Common Lisp függvényt `(defun count-digit-two (L R)` a következő probléma megoldására:\nEz a függvény megszámolja a '2' számjegy előfordulásait az összes egész szám között egy adott [L, R] tartományban.\nMind L, mind R beleértendő.\nVégigmegy a tartomány minden számán, és megszámolja, hányszor jelenik meg a '2' az egyes számokban.\nPélda:\n>>> count-digit-two 2 22\n6\n>>> count-digit-two 10 25\n9"
    },
    "instruction_bertscore": {
      "sq": "0.9821983479908912",
      "hy": "0.9930417791219668",
      "bn": "0.9938881431755565",
      "bg": "0.9421115590119542",
      "zh": "0.9721496370143362",
      "fr": "0.9896316927403599",
      "de": "0.9946679660514994",
      "ha": "0.9915206676640017",
      "hi": "0.9966590369909932",
      "hu": "0.9872957994593896"
    },
    "level": "easy",
    "test": "(defun test-count-digit-two ()\n(assert (equal (count-digit-two 2 22) 6))\n(assert (equal (count-digit-two 10 25) 8))\n(assert (equal (count-digit-two 1 100) 20))\n(assert (equal (count-digit-two 29 55) 4))\n(assert (equal (count-digit-two 200 250) 66)))\n\n(test-count-digit-two)",
    "entry_point": "count-digit-two",
    "signature": "(defun count-digit-two (L R)",
    "docstring": {
      "en": "This function counts the occurrences of the digit '2' in all integers within a given range [L, R].\nBoth L and R are inclusive.\nIt iterates through each number in the range and counts how many times '2' appears in each number.\nExample:\n>>> count-digit-two 2 22\n6\n>>> count-digit-two 10 25\n9",
      "sq": "Kjo funksion numëron shfaqjet e shifrës '2' në të gjitha numrat e plotë brenda një intervali të dhënë [L, R]. \nTë dy L dhe R janë përfshirës. \nAi iteron nëpër secilin numër në interval dhe numëron sa herë '2' shfaqet në secilin numër. \nShembull:\n>>> count-digit-two 2 22\n6\n>>> count-digit-two 10 25\n9",
      "hy": "Այս ֆունկցիան հաշվում է '2' թվանշանի հանդիպումները տրված [L, R] միջակայքում գտնվող բոլոր ամբողջ թվերի մեջ: \nԵ՛վ L, և՛ R ներառական են: \nԱյն շրջում է միջակայքի յուրաքանչյուր թվի վրա և հաշվում, թե քանի անգամ '2' է հայտնվում յուրաքանչյուր թվի մեջ:\nՕրինակ:\n>>> count-digit-two 2 22\n6\n>>> count-digit-two 10 25\n9",
      "bn": "এই ফাংশনটি একটি নির্দিষ্ট পরিসীমা [L, R] এর মধ্যে সমস্ত পূর্ণসংখ্যায় '2' অঙ্কটির উপস্থিতি গণনা করে। \nL এবং R উভয়ই অন্তর্ভুক্ত। \nএটি পরিসীমার প্রতিটি সংখ্যার মধ্য দিয়ে পুনরাবৃত্তি করে এবং প্রতিটি সংখ্যায় '2' কতবার উপস্থিত হয়েছে তা গণনা করে। \nউদাহরণ:\n>>> count-digit-two 2 22\n6\n>>> count-digit-two 10 25\n9",
      "bg": "Тази функция брои появяванията на цифрата '2' във всички цели числа в даден диапазон [L, R].  \nИ L, и R са включени.  \nТя преминава през всяко число в диапазона и брои колко пъти '2' се появява във всяко число.  \nПример:  \n>>> count-digit-two 2 22  \n6  \n>>> count-digit-two 10 25  \n9  ",
      "zh": "该函数计算给定范围 [L, R] 内所有整数中数字 '2' 出现的次数。  \nL 和 R 都是包含在内的。  \n它遍历范围内的每个数字，并计算每个数字中 '2' 出现的次数。  \n示例：  \n>>> count-digit-two 2 22  \n6  \n>>> count-digit-two 10 25  \n9  ",
      "fr": "Cette fonction compte les occurrences du chiffre '2' dans tous les entiers d'un intervalle donné [L, R].\nL et R sont tous deux inclusifs.\nElle parcourt chaque nombre de l'intervalle et compte combien de fois '2' apparaît dans chaque nombre.\nExemple :\n>>> count-digit-two 2 22\n6\n>>> count-digit-two 10 25\n9",
      "de": "Diese Funktion zählt die Vorkommen der Ziffer '2' in allen ganzen Zahlen innerhalb eines gegebenen Bereichs [L, R].\nSowohl L als auch R sind inklusive.\nSie iteriert durch jede Zahl im Bereich und zählt, wie oft '2' in jeder Zahl erscheint.\nBeispiel:\n>>> count-digit-two 2 22\n6\n>>> count-digit-two 10 25\n9",
      "ha": "Wannan aikin yana ƙirga yawan fitowar lamba '2' a cikin dukkan lambobi a cikin kewayon da aka bayar [L, R]. \nDuka L da R suna ciki. \nYana zagayawa ta kowanne lamba a cikin kewayon kuma yana ƙirga sau nawa '2' ya bayyana a kowanne lamba.\n\nMisali:\n>>> count-digit-two 2 22\n6\n>>> count-digit-two 10 25\n9",
      "hi": "यह फ़ंक्शन दिए गए सीमा [L, R] के भीतर सभी पूर्णांकों में अंक '2' की घटनाओं की गणना करता है।  \nदोनों L और R सम्मिलित हैं।  \nयह सीमा में प्रत्येक संख्या के माध्यम से पुनरावृत्ति करता है और गणना करता है कि प्रत्येक संख्या में '2' कितनी बार प्रकट होता है।  \nउदाहरण:  \n>>> count-digit-two 2 22  \n6  \n>>> count-digit-two 10 25  \n9  ",
      "hu": "Ez a függvény megszámolja a '2' számjegy előfordulásait az összes egész szám között egy adott [L, R] tartományban.  \nMind L, mind R beleértendő.  \nVégigmegy a tartomány minden számán, és megszámolja, hogy hányszor jelenik meg a '2' az egyes számokban.  \nPélda:  \n>>> count-digit-two 2 22  \n6  \n>>> count-digit-two 10 25  \n9  "
    },
    "docstring_bertscore": {
      "sq": "1",
      "hy": "0.9865270998847846",
      "bn": "0.9938782116565047",
      "bg": "1",
      "zh": "0.9700616344488975",
      "fr": "0.983995754308876",
      "de": "0.9921642300985547",
      "ha": "0.9628038789562637",
      "hi": "0.9961870912056543",
      "hu": "0.9797929340765588"
    }
  },
  {
    "task_id": "Common Lisp/31",
    "prompt": {
      "en": "(defun represent-as-powers-of-two (n)\n;; This function takes a positive integer 'n' and returns its representation as a sum of powers of two. \n;; The powers are expressed in a specific format where a^b is represented as a(b), and terms are summed without spaces.\n;; Specifically, 2^0 is represented as 2()\n;; Example:\n;; >>> represent-as-powers-of-two(10)\n;; \"2+2(2()+2)\"\n;; >>> represent-as-powers-of-two(26)\n;; \"2+2(2()+2)+2(2(2))\"",
      "sq": "(defun represent-as-powers-of-two (n)\n;; Kjo funksion merr një numër të plotë pozitiv 'n' dhe kthen përfaqësimin e tij si një shumë e fuqive të dyshit.\n;; Fuqitë shprehen në një format specifik ku a^b përfaqësohet si a(b), dhe termat mblidhen pa hapësira.\n;; Konkretisht, 2^0 përfaqësohet si 2()\n;; Shembull:\n;; >>> represent-as-powers-of-two(10)\n;; \"2+2(2()+2)\"\n;; >>> represent-as-powers-of-two(26)\n;; \"2+2(2()+2)+2(2(2))\"",
      "hy": "(defun represent-as-powers-of-two (n)\n;; Այս ֆունկցիան ընդունում է դրական ամբողջ թիվ 'n' և վերադարձնում է դրա ներկայացումը որպես երկուսի աստիճանների գումար։ \n;; Աստիճանները արտահայտվում են հատուկ ձևաչափով, որտեղ a^b արտահայտվում է որպես a(b), և տերմինները գումարվում են առանց բացատների։\n;; Մասնավորապես, 2^0 արտահայտվում է որպես 2()\n;; Օրինակ:\n;; >>> represent-as-powers-of-two(10)\n;; \"2+2(2()+2)\"\n;; >>> represent-as-powers-of-two(26)\n;; \"2+2(2()+2)+2(2(2))\"",
      "bn": "(defun represent-as-powers-of-two (n)\n;; এই ফাংশনটি একটি ধনাত্মক পূর্ণসংখ্যা 'n' গ্রহণ করে এবং এটিকে দুইয়ের ঘাতের যোগফল হিসেবে উপস্থাপন করে ফেরত দেয়।\n;; ঘাতগুলি একটি নির্দিষ্ট ফরম্যাটে প্রকাশ করা হয় যেখানে a^b কে a(b) হিসেবে উপস্থাপন করা হয়, এবং পদগুলি ফাঁকা স্থান ছাড়া যোগ করা হয়।\n;; বিশেষভাবে, 2^0 কে 2() হিসেবে উপস্থাপন করা হয়।\n;; উদাহরণ:\n;; >>> represent-as-powers-of-two(10)\n;; \"2+2(2()+2)\"\n;; >>> represent-as-powers-of-two(26)\n;; \"2+2(2()+2)+2(2(2))\"",
      "bg": "(defun represent-as-powers-of-two (n)\n;; Тази функция приема положително цяло число 'n' и връща неговото представяне като сума от степени на две.\n;; Степените са изразени в специфичен формат, където a^b е представено като a(b), а членовете се сумират без интервали.\n;; По-специално, 2^0 е представено като 2()\n;; Пример:\n;; >>> represent-as-powers-of-two(10)\n;; \"2+2(2()+2)\"\n;; >>> represent-as-powers-of-two(26)\n;; \"2+2(2()+2)+2(2(2))\"",
      "zh": "(defun represent-as-powers-of-two (n)\n;; 此函数接受一个正整数 'n' 并返回其作为二的幂之和的表示。\n;; 幂以特定格式表示，其中 a^b 表示为 a(b)，各项之间无空格相加。\n;; 特别地，2^0 表示为 2()\n;; 示例：\n;; >>> represent-as-powers-of-two(10)\n;; \"2+2(2()+2)\"\n;; >>> represent-as-powers-of-two(26)\n;; \"2+2(2()+2)+2(2(2))\"",
      "fr": "(defun represent-as-powers-of-two (n)\n;; Cette fonction prend un entier positif 'n' et renvoie sa représentation comme une somme de puissances de deux.\n;; Les puissances sont exprimées dans un format spécifique où a^b est représenté comme a(b), et les termes sont additionnés sans espaces.\n;; Plus précisément, 2^0 est représenté comme 2()\n;; Exemple:\n;; >>> represent-as-powers-of-two(10)\n;; \"2+2(2()+2)\"\n;; >>> represent-as-powers-of-two(26)\n;; \"2+2(2()+2)+2(2(2))\"",
      "de": "(defun represent-as-powers-of-two (n)\n;; Diese Funktion nimmt eine positive ganze Zahl 'n' und gibt deren Darstellung als Summe von Zweierpotenzen zurück.\n;; Die Potenzen werden in einem spezifischen Format ausgedrückt, wobei a^b als a(b) dargestellt wird, und die Terme ohne Leerzeichen summiert werden.\n;; Insbesondere wird 2^0 als 2() dargestellt.\n;; Beispiel:\n;; >>> represent-as-powers-of-two(10)\n;; \"2+2(2()+2)\"\n;; >>> represent-as-powers-of-two(26)\n;; \"2+2(2()+2)+2(2(2))\"",
      "ha": "(defun represent-as-powers-of-two (n)\n;; Wannan aiki yana ɗaukar lamba mai kyau 'n' kuma yana mayar da ita a matsayin wakilci a matsayin jumlar ƙarfi na biyu.\n;; Ana bayyana ƙarfafan a cikin takamaiman tsari inda a^b ake wakilta a matsayin a(b), kuma ana haɗa sharuɗɗan ba tare da sarari ba.\n;; Musamman, 2^0 ana wakilta shi a matsayin 2()\n;; Misali:\n;; >>> represent-as-powers-of-two(10)\n;; \"2+2(2()+2)\"\n;; >>> represent-as-powers-of-two(26)\n;; \"2+2(2()+2)+2(2(2))\"",
      "hi": "(defun represent-as-powers-of-two (n)\n;; यह फ़ंक्शन एक धनात्मक पूर्णांक 'n' लेता है और इसे दो की शक्तियों के योग के रूप में दर्शाता है।\n;; शक्तियों को एक विशिष्ट प्रारूप में व्यक्त किया जाता है जहाँ a^b को a(b) के रूप में दर्शाया जाता है, और शब्दों को बिना स्पेस के जोड़ा जाता है।\n;; विशेष रूप से, 2^0 को 2() के रूप में दर्शाया जाता है।\n;; उदाहरण:\n;; >>> represent-as-powers-of-two(10)\n;; \"2+2(2()+2)\"\n;; >>> represent-as-powers-of-two(26)\n;; \"2+2(2()+2)+2(2(2))\"",
      "hu": "(defun represent-as-powers-of-two (n)\n;; Ez a függvény egy pozitív egész számot, 'n'-t vesz át, és visszaadja annak reprezentációját kettő hatványainak összegeként.\n;; A hatványok egy speciális formátumban vannak kifejezve, ahol a^b-t a(b) formában ábrázoljuk, és a tagokat szóközök nélkül összegezzük.\n;; Különösen, a 2^0-t 2() formában ábrázoljuk.\n;; Példa:\n;; >>> represent-as-powers-of-two(10)\n;; \"2+2(2()+2)\"\n;; >>> represent-as-powers-of-two(26)\n;; \"2+2(2()+2)+2(2(2))\""
    },
    "prompt_bertscore": {
      "sq": "0.9925199771109882",
      "hy": "0.9851279474807748",
      "bn": "0.9756105727734882",
      "bg": "0.9970656333809716",
      "zh": "0.9829879037555049",
      "fr": "0.9889519795764585",
      "de": "0.9896616859278962",
      "ha": "0.9739351255094588",
      "hi": "0.9788871795390397",
      "hu": "0.9905845226781842"
    },
    "canonical_solution": "(let ((result '()) (power 0))\n(loop while (> n 0)\ndo (progn\n(when (> (logand n 1) 0)\n(push (if (= power 1) \"2\" (format nil \"2(~a)\" (represent-as-powers-of-two power))) result))\n(setq power (+ power 1))\n(setq n (ash n -1))))\n(string-join (reverse result) \"+\")))\n(defun string-join (list separator)\n;; This function joins a list of strings with a given separator.\n(with-output-to-string (stream)\n(when list\n(write-string (first list) stream)\n(dolist (item (rest list))\n(write-string separator stream)\n(write-string item stream)))))",
    "instruction": {
      "en": "Write a Common Lisp function `(defun represent-as-powers-of-two (n)` to solve the following problem:\nThis function takes a positive integer 'n' and returns its representation as a sum of powers of two. \nThe powers are expressed in a specific format where a^b is represented as a(b), and terms are summed without spaces.\nSpecifically, 2^0 is represented as 2()\nExample:\n>>> represent-as-powers-of-two(10)\n\"2+2(2()+2)\"\n>>> represent-as-powers-of-two(26)\n\"2+2(2()+2)+2(2(2))\"",
      "sq": "Shkruani një funksion Common Lisp `(defun represent-as-powers-of-two (n)` për të zgjidhur problemin e mëposhtëm:\nKy funksion merr një numër të plotë pozitiv 'n' dhe kthen përfaqësimin e tij si një shumë e fuqive të dyshit. \nFuqitë shprehen në një format specifik ku a^b përfaqësohet si a(b), dhe termat mblidhen pa hapësira.\nSpecifikisht, 2^0 përfaqësohet si 2()\nShembull:\n>>> represent-as-powers-of-two(10)\n\"2+2(2()+2)\"\n>>> represent-as-powers-of-two(26)\n\"2+2(2()+2)+2(2(2))\"",
      "hy": "Գրեք Common Lisp ֆունկցիա `(defun represent-as-powers-of-two (n)` հետևյալ խնդիրը լուծելու համար:\nԱյս ֆունկցիան ընդունում է դրական ամբողջ թիվ 'n' և վերադարձնում է դրա ներկայացումը որպես երկուի աստիճանների գումար: \nԱստիճանները արտահայտվում են հատուկ ձևաչափով, որտեղ a^b արտահայտվում է որպես a(b), և անդամները գումարվում են առանց բացատների:\nՄասնավորապես, 2^0 արտահայտվում է որպես 2()\nՕրինակ:\n>>> represent-as-powers-of-two(10)\n\"2+2(2()+2)\"\n>>> represent-as-powers-of-two(26)\n\"2+2(2()+2)+2(2(2))\"",
      "bn": "একটি Common Lisp ফাংশন `(defun represent-as-powers-of-two (n)` লিখুন নিম্নলিখিত সমস্যার সমাধানের জন্য:\nএই ফাংশনটি একটি ধনাত্মক পূর্ণসংখ্যা 'n' গ্রহণ করে এবং এটি দুইয়ের ঘাতের সমষ্টি হিসাবে উপস্থাপন করে ফেরত দেয়।\nঘাতগুলি একটি নির্দিষ্ট ফরম্যাটে প্রকাশ করা হয় যেখানে a^b কে a(b) হিসাবে উপস্থাপন করা হয়, এবং পদগুলি কোনো ফাঁকা স্থান ছাড়াই যোগ করা হয়।\nবিশেষভাবে, 2^0 কে 2() হিসাবে উপস্থাপন করা হয়\nউদাহরণ:\n>>> represent-as-powers-of-two(10)\n\"2+2(2()+2)\"\n>>> represent-as-powers-of-two(26)\n\"2+2(2()+2)+2(2(2))\"",
      "bg": "Напишете функция на Common Lisp `(defun represent-as-powers-of-two (n)` за решаване на следния проблем:\nТази функция приема положително цяло число 'n' и връща неговото представяне като сума от степени на две.\nСтепените са изразени в специфичен формат, където a^b е представено като a(b), а членовете се сумират без интервали.\nПо-специално, 2^0 е представено като 2()\nПример:\n>>> represent-as-powers-of-two(10)\n\"2+2(2()+2)\"\n>>> represent-as-powers-of-two(26)\n\"2+2(2()+2)+2(2(2))\"",
      "zh": "编写一个 Common Lisp 函数 `(defun represent-as-powers-of-two (n)` 来解决以下问题：\n该函数接受一个正整数 'n' 并返回其作为二的幂之和的表示。\n幂以特定格式表示，其中 a^b 表示为 a(b)，并且项之间没有空格。\n具体来说，2^0 表示为 2()\n示例：\n>>> represent-as-powers-of-two(10)\n\"2+2(2()+2)\"\n>>> represent-as-powers-of-two(26)\n\"2+2(2()+2)+2(2(2))\"",
      "fr": "Écrire une fonction Common Lisp `(defun represent-as-powers-of-two (n)` pour résoudre le problème suivant :\nCette fonction prend un entier positif 'n' et renvoie sa représentation comme une somme de puissances de deux. \nLes puissances sont exprimées dans un format spécifique où a^b est représenté comme a(b), et les termes sont additionnés sans espaces.\nSpécifiquement, 2^0 est représenté comme 2()\nExemple :\n>>> represent-as-powers-of-two(10)\n\"2+2(2()+2)\"\n>>> represent-as-powers-of-two(26)\n\"2+2(2()+2)+2(2(2))\"",
      "de": "Schreiben Sie eine Common Lisp-Funktion `(defun represent-as-powers-of-two (n)`, um das folgende Problem zu lösen:\nDiese Funktion nimmt eine positive ganze Zahl 'n' und gibt deren Darstellung als Summe von Zweierpotenzen zurück.\nDie Potenzen werden in einem spezifischen Format ausgedrückt, bei dem a^b als a(b) dargestellt wird, und die Terme ohne Leerzeichen summiert werden.\nSpeziell wird 2^0 als 2() dargestellt.\nBeispiel:\n>>> represent-as-powers-of-two(10)\n\"2+2(2()+2)\"\n>>> represent-as-powers-of-two(26)\n\"2+2(2()+2)+2(2(2))\"",
      "ha": "Rubuta aikin Common Lisp `(defun represent-as-powers-of-two (n)` don warware matsalar mai zuwa:\nWannan aikin yana ɗaukar lamba mai kyau 'n' kuma yana mayar da wakilcinsa a matsayin jumlar ƙarfi na biyu.\nAna bayyana ƙarfafa a cikin takamaiman tsari inda a^b ake wakilta a matsayin a(b), kuma ana tara sharuɗɗa ba tare da sarari ba.\nMusamman, 2^0 ana wakilta shi a matsayin 2()\nMisali:\n>>> represent-as-powers-of-two(10)\n\"2+2(2()+2)\"\n>>> represent-as-powers-of-two(26)\n\"2+2(2()+2)+2(2(2))\"",
      "hi": "एक Common Lisp फ़ंक्शन `(defun represent-as-powers-of-two (n)` लिखें ताकि निम्नलिखित समस्या का समाधान किया जा सके:\nयह फ़ंक्शन एक धनात्मक पूर्णांक 'n' लेता है और इसे दो के घातों के योग के रूप में प्रस्तुत करता है। \nघातों को एक विशिष्ट प्रारूप में व्यक्त किया जाता है जहाँ a^b को a(b) के रूप में दर्शाया जाता है, और पदों को बिना स्पेस के जोड़ा जाता है।\nविशेष रूप से, 2^0 को 2() के रूप में दर्शाया जाता है\nउदाहरण:\n>>> represent-as-powers-of-two(10)\n\"2+2(2()+2)\"\n>>> represent-as-powers-of-two(26)\n\"2+2(2()+2)+2(2(2))\"",
      "hu": "Írj egy Common Lisp függvényt `(defun represent-as-powers-of-two (n)` a következő probléma megoldására:\nEz a függvény egy pozitív egész számot 'n' vesz át, és visszaadja annak reprezentációját kettő hatványainak összegként. \nA hatványok egy adott formátumban vannak kifejezve, ahol a^b a(b)-ként van reprezentálva, és a tagok szóközök nélkül vannak összegezve.\nKülönösen, 2^0 2()-ként van reprezentálva.\nPélda:\n>>> represent-as-powers-of-two(10)\n\"2+2(2()+2)\"\n>>> represent-as-powers-of-two(26)\n\"2+2(2()+2)+2(2(2))\""
    },
    "instruction_bertscore": {
      "sq": "0.9928846624905683",
      "hy": "0.9898625012431224",
      "bn": "0.9775406641860042",
      "bg": "0.987127559526653",
      "zh": "0.9828111227163839",
      "fr": "0.9928846624905683",
      "de": "0.9924385386547638",
      "ha": "0.9834435618495989",
      "hi": "0.9718501023997357",
      "hu": "0.9937922047015166"
    },
    "level": "hard",
    "test": "(defun test-represent-as-powers-of-two ()\n(assert (equal (represent-as-powers-of-two 10) \"2+2(2()+2)\"))\n(assert (equal (represent-as-powers-of-two 26) \"2+2(2()+2)+2(2(2))\"))\n(assert (equal (represent-as-powers-of-two 1) \"2()\"))\n(assert (equal (represent-as-powers-of-two 31) \"2()+2+2(2)+2(2()+2)+2(2(2))\"))\n(assert (equal (represent-as-powers-of-two 100) \"2(2)+2(2()+2(2))+2(2+2(2))\")))\n\n(test-represent-as-powers-of-two)",
    "entry_point": "represent-as-powers-of-two",
    "signature": "(defun represent-as-powers-of-two (n)",
    "docstring": {
      "en": "This function takes a positive integer 'n' and returns its representation as a sum of powers of two. \nThe powers are expressed in a specific format where a^b is represented as a(b), and terms are summed without spaces.\nSpecifically, 2^0 is represented as 2()\nExample:\n>>> represent-as-powers-of-two(10)\n\"2+2(2()+2)\"\n>>> represent-as-powers-of-two(26)\n\"2+2(2()+2)+2(2(2))\"",
      "sq": "Kjo funksion merr një numër të plotë pozitiv 'n' dhe kthen përfaqësimin e tij si një shumë e fuqive të dyshit. \nFuqitë shprehen në një format specifik ku a^b përfaqësohet si a(b), dhe termat mblidhen pa hapësira.\nNë veçanti, 2^0 përfaqësohet si 2()\nShembull:\n>>> represent-as-powers-of-two(10)\n\"2+2(2()+2)\"\n>>> represent-as-powers-of-two(26)\n\"2+2(2()+2)+2(2(2))\"",
      "hy": "Այս ֆունկցիան ընդունում է դրական ամբողջ թիվ 'n' և վերադարձնում դրա ներկայացումը որպես երկուի աստիճանների գումար: \nԱստիճանները արտահայտվում են հատուկ ձևաչափով, որտեղ a^b արտահայտվում է որպես a(b), և տերմինները գումարվում են առանց բացատների:\nՄասնավորապես, 2^0 արտահայտվում է որպես 2()\nՕրինակ:\n>>> represent-as-powers-of-two(10)\n\"2+2(2()+2)\"\n>>> represent-as-powers-of-two(26)\n\"2+2(2()+2)+2(2(2))\"",
      "bn": "এই ফাংশনটি একটি ধনাত্মক পূর্ণসংখ্যা 'n' গ্রহণ করে এবং এটিকে দুইয়ের ঘাতের যোগফল হিসাবে উপস্থাপন করে। ঘাতগুলি একটি নির্দিষ্ট বিন্যাসে প্রকাশ করা হয় যেখানে a^b কে a(b) হিসাবে উপস্থাপন করা হয়, এবং পদগুলি কোনো ফাঁকা স্থান ছাড়াই যোগ করা হয়। বিশেষভাবে, 2^0 কে 2() হিসাবে উপস্থাপন করা হয়। উদাহরণ:\n>>> represent-as-powers-of-two(10)\n\"2+2(2()+2)\"\n>>> represent-as-powers-of-two(26)\n\"2+2(2()+2)+2(2(2))\"",
      "bg": "Тази функция приема положително цяло число 'n' и връща неговото представяне като сума от степени на две. Степените са изразени в специфичен формат, където a^b е представено като a(b), а членовете се сумират без интервали. По-специално, 2^0 е представено като 2().\n\nПример:\n>>> represent-as-powers-of-two(10)\n\"2+2(2()+2)\"\n>>> represent-as-powers-of-two(26)\n\"2+2(2()+2)+2(2(2))\"",
      "zh": "这个函数接受一个正整数 'n' 并返回其作为二的幂的和的表示形式。\n幂以特定格式表示，其中 a^b 表示为 a(b)，并且各项之间没有空格。\n具体来说，2^0 表示为 2()\n例子：\n>>> represent-as-powers-of-two(10)\n\"2+2(2()+2)\"\n>>> represent-as-powers-of-two(26)\n\"2+2(2()+2)+2(2(2))\"",
      "fr": "Cette fonction prend un entier positif 'n' et renvoie sa représentation comme une somme de puissances de deux. \nLes puissances sont exprimées dans un format spécifique où a^b est représenté comme a(b), et les termes sont additionnés sans espaces.\nSpécifiquement, 2^0 est représenté comme 2()\nExemple:\n>>> represent-as-powers-of-two(10)\n\"2+2(2()+2)\"\n>>> represent-as-powers-of-two(26)\n\"2+2(2()+2)+2(2(2))\"",
      "de": "Diese Funktion nimmt eine positive ganze Zahl 'n' und gibt deren Darstellung als Summe von Zweierpotenzen zurück. \nDie Potenzen werden in einem speziellen Format ausgedrückt, wobei a^b als a(b) dargestellt wird, und die Terme ohne Leerzeichen summiert werden.\nSpeziell wird 2^0 als 2() dargestellt.\nBeispiel:\n>>> represent-as-powers-of-two(10)\n\"2+2(2()+2)\"\n>>> represent-as-powers-of-two(26)\n\"2+2(2()+2)+2(2(2))\"",
      "ha": "Wannan aikin yana ɗaukar cikakken lamba mai kyau 'n' kuma yana mayar da wakilarsa a matsayin jumlar ikon biyu. \nAna bayyana ikon a cikin takamaiman tsari inda a^b aka wakilta a matsayin a(b), kuma ana tara sharuɗɗan ba tare da sarari ba.\nMusamman, 2^0 ana wakilta shi a matsayin 2()\nMisali:\n>>> represent-as-powers-of-two(10)\n\"2+2(2()+2)\"\n>>> represent-as-powers-of-two(26)\n\"2+2(2()+2)+2(2(2))\"",
      "hi": "यह फ़ंक्शन एक धनात्मक पूर्णांक 'n' लेता है और इसे दो की शक्तियों के योग के रूप में प्रस्तुत करता है। \nशक्तियों को एक विशेष प्रारूप में व्यक्त किया जाता है जहाँ a^b को a(b) के रूप में दर्शाया जाता है, और पदों को बिना स्पेस के जोड़ा जाता है।\nविशेष रूप से, 2^0 को 2() के रूप में दर्शाया जाता है।\nउदाहरण:\n>>> represent-as-powers-of-two(10)\n\"2+2(2()+2)\"\n>>> represent-as-powers-of-two(26)\n\"2+2(2()+2)+2(2(2))\"",
      "hu": "Ez a függvény egy pozitív egész számot, 'n'-t vesz át, és visszaadja annak ábrázolását kettő hatványainak összegeként. \nA hatványok egy specifikus formátumban vannak kifejezve, ahol a^b-t a(b)-ként ábrázoljuk, és a tagokat szóközök nélkül összegezzük.\nKonkrétan, 2^0-t 2()-ként ábrázoljuk.\nPélda:\n>>> represent-as-powers-of-two(10)\n\"2+2(2()+2)\"\n>>> represent-as-powers-of-two(26)\n\"2+2(2()+2)+2(2(2))\""
    },
    "docstring_bertscore": {
      "sq": "0.9840771927651003",
      "hy": "0.9822660809508241",
      "bn": "0.968128166319904",
      "bg": "0.9851635023189801",
      "zh": "0.9838074527076549",
      "fr": "0.9913867907871842",
      "de": "0.9847124127236498",
      "ha": "0.977215307621869",
      "hi": "0.9737589403614809",
      "hu": "0.9916791747080675"
    }
  },
  {
    "task_id": "Common Lisp/32",
    "prompt": {
      "en": "(defun create-largest-number (numbers)\n;; This function takes a list of positive integers and rearranges them to form the largest possible number. \n;; It does this by concatenating the integers in an order such that their digit-wise combination yields the maximum value.\n;; Example:\n;; >>> create-largest-number '(56 9 45)\n;; \"95645\"\n;; >>> create-largest-number '(5 50 56)\n;; \"56550\"",
      "sq": "(defun create-largest-number (numbers)\n;; Kjo funksion merr një listë të numrave të plotë pozitivë dhe i riorganizon ato për të formuar numrin më të madh të mundshëm.\n;; E bën këtë duke bashkuar numrat në një renditje të tillë që kombinimi i tyre sipas shifrave jep vlerën maksimale.\n;; Shembull:\n;; >>> create-largest-number '(56 9 45)\n;; \"95645\"\n;; >>> create-largest-number '(5 50 56)\n;; \"56550\"",
      "hy": "(defun create-largest-number (numbers)\n;; Այս ֆունկցիան ընդունում է դրական ամբողջ թվերի ցուցակ և վերադասավորում է դրանք՝ կազմելով հնարավոր ամենամեծ թիվը։ \n;; Դա անում է այնպես, որ թվերի համակցումը թվանշանային մակարդակում ապահովի առավելագույն արժեք։\n;; Օրինակ:\n;; >>> create-largest-number '(56 9 45)\n;; \"95645\"\n;; >>> create-largest-number '(5 50 56)\n;; \"56550\"",
      "bn": "(defun create-largest-number (numbers)\n;; এই ফাংশনটি একটি ধনাত্মক পূর্ণসংখ্যার তালিকা গ্রহণ করে এবং সেগুলিকে পুনর্বিন্যাস করে সবচেয়ে বড় সম্ভব সংখ্যা তৈরি করে।\n;; এটি এমনভাবে পূর্ণসংখ্যাগুলিকে একত্রিত করে যে তাদের অঙ্ক-ভিত্তিক সংমিশ্রণ সর্বাধিক মান প্রদান করে।\n;; উদাহরণ:\n;; >>> create-largest-number '(56 9 45)\n;; \"95645\"\n;; >>> create-largest-number '(5 50 56)\n;; \"56550\"",
      "bg": "(defun create-largest-number (numbers)\n;; Тази функция приема списък от положителни цели числа и ги пренарежда, за да образува най-голямото възможно число.\n;; Това се постига чрез конкатенация на числата в ред, така че тяхната комбинация по цифри дава максималната стойност.\n;; Пример:\n;; >>> create-largest-number '(56 9 45)\n;; \"95645\"\n;; >>> create-largest-number '(5 50 56)\n;; \"56550\"",
      "zh": "(defun create-largest-number (numbers)\n;; 此函数接受一个正整数列表，并重新排列它们以形成可能的最大数字。\n;; 它通过以一种顺序连接整数来实现，使得它们的数字组合产生最大值。\n;; 示例:\n;; >>> create-largest-number '(56 9 45)\n;; \"95645\"\n;; >>> create-largest-number '(5 50 56)\n;; \"56550\"",
      "fr": "(defun create-largest-number (numbers)\n;; Cette fonction prend une liste d'entiers positifs et les réarrange pour former le plus grand nombre possible.\n;; Elle le fait en concaténant les entiers dans un ordre tel que leur combinaison chiffre par chiffre donne la valeur maximale.\n;; Exemple:\n;; >>> create-largest-number '(56 9 45)\n;; \"95645\"\n;; >>> create-largest-number '(5 50 56)\n;; \"56550\"",
      "de": "(defun create-largest-number (numbers)\n;; Diese Funktion nimmt eine Liste von positiven ganzen Zahlen und ordnet sie so an, dass die größtmögliche Zahl gebildet wird.\n;; Dies geschieht, indem die Zahlen in einer Reihenfolge verkettet werden, die bei ihrer ziffernweisen Kombination den maximalen Wert ergibt.\n;; Beispiel:\n;; >>> create-largest-number '(56 9 45)\n;; \"95645\"\n;; >>> create-largest-number '(5 50 56)\n;; \"56550\"",
      "ha": "(defun create-largest-number (numbers)\n;; Wannan aiki yana ɗaukar jerin lambobi masu kyau kuma yana sake tsara su don ƙirƙirar mafi girman yuwuwar lamba.\n;; Yana yin wannan ta hanyar haɗa lambobin a cikin tsari wanda haɗin su na digit-wise zai ba da mafi girman ƙima.\n;; Misali:\n;; >>> create-largest-number '(56 9 45)\n;; \"95645\"\n;; >>> create-largest-number '(5 50 56)\n;; \"56550\"",
      "hi": "(defun create-largest-number (numbers)\n;; यह फ़ंक्शन सकारात्मक पूर्णांकों की एक सूची लेता है और उन्हें पुनर्व्यवस्थित करता है ताकि सबसे बड़ा संभव संख्या बन सके।\n;; यह ऐसा इस प्रकार करता है कि अंकों के संयोजन से अधिकतम मान प्राप्त हो सके।\n;; उदाहरण:\n;; >>> create-largest-number '(56 9 45)\n;; \"95645\"\n;; >>> create-largest-number '(5 50 56)\n;; \"56550\"",
      "hu": "(defun create-largest-number (numbers)\n;; Ez a függvény egy pozitív egész számokat tartalmazó listát vesz át, és úgy rendezi át őket, hogy a lehető legnagyobb számot alkossák.\n;; Ezt úgy éri el, hogy az egész számokat olyan sorrendben fűzi össze, hogy a számjegyenkénti kombinációjuk a maximális értéket adja.\n;; Példa:\n;; >>> create-largest-number '(56 9 45)\n;; \"95645\"\n;; >>> create-largest-number '(5 50 56)\n;; \"56550\""
    },
    "prompt_bertscore": {
      "sq": "0.9672966995448918",
      "hy": "0.9443546919049812",
      "bn": "0.958302120000489",
      "bg": "0.9761309843717996",
      "zh": "0.9664074313289986",
      "fr": "0.9832407602305624",
      "de": "0.9498511918089787",
      "ha": "0.9630889135530488",
      "hi": "0.9549861844194926",
      "hu": "0.9781437060228261"
    },
    "canonical_solution": "(let ((str-numbers (mapcar #'number-to-string numbers)))\n(setf str-numbers (sort str-numbers #'larger-when-concatenated))\n(reduce (lambda (acc x) (concatenate 'string acc x)) str-numbers :initial-value \"\")))\n\n(defun number-to-string (number)\n;; Converts a number to its string representation.\n(write-to-string number))\n\n(defun larger-when-concatenated (a b)\n;; Custom comparison function for sorting.\n;; Returns T if AB is greater than BA.\n(string> (concatenate 'string a b) (concatenate 'string b a)))",
    "instruction": {
      "en": "Write a Common Lisp function `(defun create-largest-number (numbers)` to solve the following problem:\nThis function takes a list of positive integers and rearranges them to form the largest possible number. \nIt does this by concatenating the integers in an order such that their digit-wise combination yields the maximum value.\nExample:\n>>> create-largest-number '(56 9 45)\n\"95645\"\n>>> create-largest-number '(5 50 56)\n\"56550\"",
      "sq": "Shkruani një funksion në Common Lisp `(defun create-largest-number (numbers)` për të zgjidhur problemin e mëposhtëm:\nKy funksion merr një listë të numrave të plotë pozitivë dhe i riorganizon ata për të formuar numrin më të madh të mundshëm.\nE bën këtë duke bashkuar numrat në një renditje të tillë që kombinimi i tyre sipas shifrave të japë vlerën maksimale.\nShembull:\n>>> create-largest-number '(56 9 45)\n\"95645\"\n>>> create-largest-number '(5 50 56)\n\"56550\"",
      "hy": "Գրեք Common Lisp ֆունկցիա `(defun create-largest-number (numbers)` հետևյալ խնդիրը լուծելու համար:\nԱյս ֆունկցիան ընդունում է դրական ամբողջ թվերի ցուցակ և վերադասավորում է դրանք, որպեսզի կազմի հնարավոր ամենամեծ թիվը։ \nԱյն դա անում է՝ ամբողջ թվերը միացնելով այնպիսի կարգով, որ նրանց թվանշանային համադրությունը տա առավելագույն արժեք։\nՕրինակ:\n>>> create-largest-number '(56 9 45)\n\"95645\"\n>>> create-largest-number '(5 50 56)\n\"56550\"",
      "bn": "একটি Common Lisp ফাংশন `(defun create-largest-number (numbers)` লিখুন নিম্নলিখিত সমস্যার সমাধানের জন্য:\nএই ফাংশনটি ধনাত্মক পূর্ণসংখ্যার একটি তালিকা নেয় এবং সেগুলিকে পুনর্বিন্যাস করে সবচেয়ে বড় সম্ভাব্য সংখ্যা তৈরি করে। \nএটি এমন একটি ক্রমে পূর্ণসংখ্যাগুলিকে সংযুক্ত করে যা তাদের অঙ্ক-ভিত্তিক সংমিশ্রণ সর্বাধিক মান প্রদান করে।\nউদাহরণ:\n>>> create-largest-number '(56 9 45)\n\"95645\"\n>>> create-largest-number '(5 50 56)\n\"56550\"",
      "bg": "Напишете функция на Common Lisp `(defun create-largest-number (numbers)` за решаване на следния проблем:\nТази функция приема списък от положителни цели числа и ги пренарежда, за да образува най-голямото възможно число.\nТя прави това, като конкатенира числата в такъв ред, че тяхната комбинация по цифри дава максималната стойност.\nПример:\n>>> create-largest-number '(56 9 45)\n\"95645\"\n>>> create-largest-number '(5 50 56)\n\"56550\"",
      "zh": "编写一个 Common Lisp 函数 `(defun create-largest-number (numbers)` 来解决以下问题：\n该函数接受一个正整数列表，并重新排列它们以形成可能的最大数字。\n它通过以某种顺序连接整数来实现，使得它们的数字组合产生最大值。\n示例：\n>>> create-largest-number '(56 9 45)\n\"95645\"\n>>> create-largest-number '(5 50 56)\n\"56550\"",
      "fr": "Écrire une fonction Common Lisp `(defun create-largest-number (numbers)` pour résoudre le problème suivant :  \nCette fonction prend une liste d'entiers positifs et les réorganise pour former le plus grand nombre possible.  \nElle le fait en concaténant les entiers dans un ordre tel que leur combinaison chiffre par chiffre donne la valeur maximale.  \nExemple :  \n>>> create-largest-number '(56 9 45)  \n\"95645\"  \n>>> create-largest-number '(5 50 56)  \n\"56550\"",
      "de": "Schreiben Sie eine Common Lisp-Funktion `(defun create-largest-number (numbers)` um das folgende Problem zu lösen:\nDiese Funktion nimmt eine Liste von positiven ganzen Zahlen und ordnet sie neu an, um die größtmögliche Zahl zu bilden. \nDies geschieht, indem die ganzen Zahlen in einer Reihenfolge verkettet werden, sodass ihre ziffernweise Kombination den maximalen Wert ergibt.\nBeispiel:\n>>> create-largest-number '(56 9 45)\n\"95645\"\n>>> create-largest-number '(5 50 56)\n\"56550\"",
      "ha": "Rubuta aikin Common Lisp `(defun create-largest-number (numbers)` don magance matsalar mai zuwa:\nWannan aikin yana ɗaukar jerin lambobi masu kyau kuma yana sake tsara su don samar da mafi girman adadi mai yiwuwa.\nYana yin wannan ta hanyar haɗa lambobin a cikin tsari wanda haɗin gwiwar lambobinsu zai samar da mafi girman ƙima.\nMisali:\n>>> create-largest-number '(56 9 45)\n\"95645\"\n>>> create-largest-number '(5 50 56)\n\"56550\"",
      "hi": "Common Lisp फ़ंक्शन `(defun create-largest-number (numbers)` लिखें ताकि निम्नलिखित समस्या का समाधान किया जा सके:\nयह फ़ंक्शन सकारात्मक पूर्णांकों की एक सूची लेता है और उन्हें पुनर्व्यवस्थित करता है ताकि सबसे बड़ा संभव संख्या बन सके।\nयह ऐसा इस तरह से करता है कि पूर्णांकों को इस क्रम में जोड़ता है कि उनके अंक-वार संयोजन से अधिकतम मान प्राप्त हो।\nउदाहरण:\n>>> create-largest-number '(56 9 45)\n\"95645\"\n>>> create-largest-number '(5 50 56)\n\"56550\"",
      "hu": "Írj egy Common Lisp függvényt `(defun create-largest-number (numbers)` a következő probléma megoldására:\nEz a függvény egy pozitív egész számokat tartalmazó listát vesz át, és úgy rendezi át őket, hogy a lehető legnagyobb számot alkossák. \nEzt úgy teszi, hogy az egész számokat olyan sorrendben fűzi össze, hogy a számjegyek szerinti kombinációjuk a maximális értéket adja.\nPélda:\n>>> create-largest-number '(56 9 45)\n\"95645\"\n>>> create-largest-number '(5 50 56)\n\"56550\""
    },
    "instruction_bertscore": {
      "sq": "0.9719990751855118",
      "hy": "0.97751682854028",
      "bn": "0.9791753922219213",
      "bg": "0.9849732144139486",
      "zh": "0.9838261239634721",
      "fr": "0.9834536919990318",
      "de": "0.9944727123869421",
      "ha": "0.961199938629407",
      "hi": "0.9833905275378626",
      "hu": "0.9875472655217797"
    },
    "level": "hard",
    "test": "(defun test-create-largest-number ()\n(assert (string= (create-largest-number '(56 9 45)) \"95645\"))\n(assert (string= (create-largest-number '(5 50 56)) \"56550\"))\n(assert (string= (create-largest-number '(3 34 302 50)) \"50343302\"))\n(assert (string= (create-largest-number '(10 2 23)) \"23210\"))\n(assert (string= (create-largest-number '(4 42 40 400)) \"44240400\")))\n\n(test-create-largest-number)",
    "entry_point": "create-largest-number",
    "signature": "(defun create-largest-number (numbers)",
    "docstring": {
      "en": "This function takes a list of positive integers and rearranges them to form the largest possible number. \nIt does this by concatenating the integers in an order such that their digit-wise combination yields the maximum value.\nExample:\n>>> create-largest-number '(56 9 45)\n\"95645\"\n>>> create-largest-number '(5 50 56)\n\"56550\"",
      "sq": "Kjo funksion merr një listë të numrave të plotë pozitivë dhe i riorganizon ata për të formuar numrin më të madh të mundshëm. \nE bën këtë duke bashkuar numrat në një renditje të tillë që kombinimi i tyre shifror jep vlerën maksimale.\nShembull:\n>>> create-largest-number '(56 9 45)\n\"95645\"\n>>> create-largest-number '(5 50 56)\n\"56550\"",
      "hy": "Այս ֆունկցիան ընդունում է դրական ամբողջ թվերի ցուցակ և վերադասավորում է դրանք՝ կազմելու համար հնարավոր ամենամեծ թիվը։  \nԱյն դա անում է՝ ամբողջ թվերը միացնելով այնպիսի կարգով, որ նրանց թվանշանային համադրությունը տա առավելագույն արժեքը։  \nՕրինակ:  \n>>> create-largest-number '(56 9 45)  \n\"95645\"  \n>>> create-largest-number '(5 50 56)  \n\"56550\"",
      "bn": "এই ফাংশনটি ধনাত্মক পূর্ণসংখ্যার একটি তালিকা গ্রহণ করে এবং সেগুলিকে পুনর্বিন্যাস করে সর্বাধিক সম্ভাব্য সংখ্যা তৈরি করে। এটি এমন একটি ক্রমে পূর্ণসংখ্যাগুলিকে সংযুক্ত করে যা তাদের অঙ্ক-ভিত্তিক সংমিশ্রণ সর্বাধিক মান প্রদান করে।\n\nউদাহরণ:\n>>> create-largest-number '(56 9 45)\n\"95645\"\n>>> create-largest-number '(5 50 56)\n\"56550\"",
      "bg": "Тази функция приема списък от положителни цели числа и ги пренарежда, за да образува най-голямото възможно число. \nТова се постига чрез конкатенация на числата в такъв ред, че тяхната комбинация по цифри дава максималната стойност.\nПример:\n>>> create-largest-number '(56 9 45)\n\"95645\"\n>>> create-largest-number '(5 50 56)\n\"56550\"",
      "zh": "该函数接受一个正整数列表，并重新排列它们以形成可能的最大数字。  \n它通过以某种顺序连接整数，使得它们的数字组合产生最大值。\n\n示例：\n>>> create-largest-number '(56 9 45)\n\"95645\"\n>>> create-largest-number '(5 50 56)\n\"56550\"",
      "fr": "Cette fonction prend une liste d'entiers positifs et les réorganise pour former le plus grand nombre possible. \nElle le fait en concaténant les entiers dans un ordre tel que leur combinaison chiffre par chiffre donne la valeur maximale.\nExemple :\n>>> create-largest-number '(56 9 45)\n\"95645\"\n>>> create-largest-number '(5 50 56)\n\"56550\"",
      "de": "Diese Funktion nimmt eine Liste positiver Ganzzahlen und ordnet sie so an, dass die größtmögliche Zahl entsteht. \nDies geschieht, indem die Ganzzahlen in einer Reihenfolge verkettet werden, sodass ihre ziffernweise Kombination den maximalen Wert ergibt.\nBeispiel:\n>>> create-largest-number '(56 9 45)\n\"95645\"\n>>> create-largest-number '(5 50 56)\n\"56550\"",
      "ha": "Wannan aikin yana ɗaukar jerin lambobi masu kyau kuma yana sake tsara su don ƙirƙirar babbar lamba da zai yiwu. \nYana yin wannan ta hanyar haɗa lambobin cikin tsari irin wanda haɗin lambobinsu zai ba da mafi girman ƙima.\n\nMisali:\n>>> create-largest-number '(56 9 45)\n\"95645\"\n>>> create-largest-number '(5 50 56)\n\"56550\"",
      "hi": "यह फ़ंक्शन सकारात्मक पूर्णांकों की एक सूची लेता है और उन्हें पुनर्व्यवस्थित करता है ताकि सबसे बड़ा संभव संख्या बन सके। \nयह ऐसा इस तरह से करता है कि पूर्णांकों को इस क्रम में जोड़कर रखा जाता है जिससे उनकी अंक-वार संयोजन अधिकतम मान देता है।\nउदाहरण:\n>>> create-largest-number '(56 9 45)\n\"95645\"\n>>> create-largest-number '(5 50 56)\n\"56550\"",
      "hu": "Ez a függvény pozitív egész számok listáját veszi, és úgy rendezi át őket, hogy a lehető legnagyobb számot alkossa meg. \nEzt úgy éri el, hogy az egész számokat olyan sorrendben fűzi össze, hogy számjegyenkénti kombinációjuk a maximális értéket adja.\nPélda:\n>>> create-largest-number '(56 9 45)\n\"95645\"\n>>> create-largest-number '(5 50 56)\n\"56550\""
    },
    "docstring_bertscore": {
      "sq": "0.9657501633981542",
      "hy": "0.9820809574356997",
      "bn": "0.972096999963362",
      "bg": "0.970149627707696",
      "zh": "0.9771281088845947",
      "fr": "0.9770611704461859",
      "de": "0.9884955269608403",
      "ha": "0.9379349579899336",
      "hi": "0.9729668024019138",
      "hu": "0.9789114124455259"
    }
  },
  {
    "task_id": "Common Lisp/33",
    "prompt": {
      "en": "(defun add-numbers (a b)\n\"Add two numbers together.\"\n;; Example:\n;; >>> add-numbers 1 2\n;; 3",
      "sq": "(defun add-numbers (a b)\n\"Shto dy numra së bashku.\"\n;; Shembull:\n;; >>> add-numbers 1 2\n;; 3",
      "hy": "(defun add-numbers (a b)\n\"Երկու թվերը իրար գումարել:\"\n;; Օրինակ:\n;; >>> add-numbers 1 2\n;; 3",
      "bn": "(defun add-numbers (a b)\n\"দুটি সংখ্যাকে একসাথে যোগ করুন।\"\n;; উদাহরণ:\n;; >>> add-numbers 1 2\n;; 3",
      "bg": "(defun add-numbers (a b)\n\"Събира две числа заедно.\"\n;; Пример:\n;; >>> add-numbers 1 2\n;; 3",
      "zh": "(defun add-numbers (a b)\n\"将两个数字相加。\"\n;; 示例:\n;; >>> add-numbers 1 2\n;; 3",
      "fr": "(defun add-numbers (a b)\n\"Ajouter deux nombres ensemble.\"\n;; Exemple:\n;; >>> add-numbers 1 2\n;; 3",
      "de": "(defun add-numbers (a b)\n\"Zwei Zahlen zusammen addieren.\"\n;; Beispiel:\n;; >>> add-numbers 1 2\n;; 3",
      "ha": "(defun add-numbers (a b)\n\"Ƙara lambobi biyu tare.\"\n;; Misali:\n;; >>> add-numbers 1 2\n;; 3",
      "hi": "(defun add-numbers (a b)\n\"दो संख्याओं को एक साथ जोड़ें।\"\n;; उदाहरण:\n;; >>> add-numbers 1 2\n;; 3",
      "hu": "(defun add-numbers (a b)\n\"Két szám összeadása.\"\n;; Példa:\n;; >>> add-numbers 1 2\n;; 3"
    },
    "prompt_bertscore": {
      "sq": "1",
      "hy": "0.9840843434588176",
      "bn": "1",
      "bg": "0.995149048834366",
      "zh": "0.9832947876942039",
      "fr": "1",
      "de": "1",
      "ha": "1",
      "hi": "1",
      "hu": "0.9808967231039696"
    },
    "canonical_solution": "(+ a b))",
    "instruction": {
      "en": "Write a Common Lisp function `(defun add-numbers (a b)` to solve the following problem:\n\"Add two numbers together.\"\nExample:\n>>> add-numbers 1 2\n3",
      "sq": "Shkruani një funksion Common Lisp `(defun add-numbers (a b)` për të zgjidhur problemin e mëposhtëm:  \n\"Shto dy numra së bashku.\"  \nShembull:  \n>>> add-numbers 1 2  \n3",
      "hy": "Գրեք Common Lisp ֆունկցիա `(defun add-numbers (a b)` հետևյալ խնդիրը լուծելու համար: \n«Երկու թվերը իրար գումարել»:\nՕրինակ:\n>>> add-numbers 1 2\n3",
      "bn": "একটি Common Lisp ফাংশন `(defun add-numbers (a b)` লিখুন নিম্নলিখিত সমস্যার সমাধানের জন্য:\n\"দুটি সংখ্যা একসাথে যোগ করুন।\"\nউদাহরণ:\n>>> add-numbers 1 2\n3",
      "bg": "Напишете функция на Common Lisp `(defun add-numbers (a b)` за решаване на следния проблем:\n„Съберете две числа заедно.“\nПример:\n>>> add-numbers 1 2\n3",
      "zh": "编写一个 Common Lisp 函数 `(defun add-numbers (a b)` 来解决以下问题：  \n“将两个数字相加。”  \n示例：  \n>>> add-numbers 1 2  \n3",
      "fr": "Écrire une fonction Common Lisp `(defun add-numbers (a b)` pour résoudre le problème suivant :\n\"Ajouter deux nombres ensemble.\"\nExemple :\n>>> add-numbers 1 2\n3",
      "de": "Schreiben Sie eine Common Lisp-Funktion `(defun add-numbers (a b)` um das folgende Problem zu lösen:\n\"Zwei Zahlen zusammen addieren.\"\nBeispiel:\n>>> add-numbers 1 2\n3",
      "ha": "Rubuta aikin Common Lisp `(defun add-numbers (a b)` don warware matsalar mai zuwa:  \n\"Ƙara lambobi biyu tare.\"  \nMisali:  \n>>> add-numbers 1 2  \n3",
      "hi": "लिखें एक Common Lisp फ़ंक्शन `(defun add-numbers (a b)` निम्नलिखित समस्या को हल करने के लिए:\n\"दो संख्याओं को एक साथ जोड़ें।\"\nउदाहरण:\n>>> add-numbers 1 2\n3",
      "hu": "Írj egy Common Lisp függvényt `(defun add-numbers (a b)` a következő probléma megoldására:\n\"Adj össze két számot.\"\nPélda:\n>>> add-numbers 1 2\n3"
    },
    "instruction_bertscore": {
      "sq": "1",
      "hy": "0.9704553198641087",
      "bn": "1",
      "bg": "0.9914529347040688",
      "zh": "0.9889188083028256",
      "fr": "1",
      "de": "1",
      "ha": "1",
      "hi": "1",
      "hu": "0.9889188083028256"
    },
    "level": "easy",
    "test": "(defun test_add()\n(assert (equal (add-numbers 1 2) 3))\n(assert (equal (add-numbers 20 10) 30))\n(assert (equal (add-numbers -1 -2) -3))\n)\n;; Execute test\n(test_add)",
    "entry_point": "add-numbers",
    "signature": "(defun add-numbers (a b)",
    "docstring": {
      "en": "\"Add two numbers together.\"\nExample:\n>>> add-numbers 1 2\n3",
      "sq": "\"Shto dy numra së bashku.\"\nShembull:\n>>> add-numbers 1 2\n3",
      "hy": "\"Երկու թվերի գումարումը։\"\nՕրինակ:\n>>> add-numbers 1 2\n3",
      "bn": "\"দুটি সংখ্যা একসাথে যোগ করে।\"\nউদাহরণ:\n>>> add-numbers 1 2\n3",
      "bg": "\"Съберете две числа заедно.\"\nПример:\n>>> add-numbers 1 2\n3",
      "zh": "\"将两个数字相加。\"\n示例：\n>>> add-numbers 1 2\n3",
      "fr": "\"Ajouter deux nombres ensemble.\"\nExemple :\n>>> add-numbers 1 2\n3",
      "de": "\"Addiere zwei Zahlen zusammen.\"\nBeispiel:\n>>> add-numbers 1 2\n3",
      "ha": "\"Ƙara lambobi biyu tare.\"\n\nMisali:\n>>> add-numbers 1 2\n3",
      "hi": "\"दो संख्याओं को जोड़ें।\"\nउदाहरण:\n>>> add-numbers 1 2\n3",
      "hu": "\"Adjunk össze két számot.\"\nPélda:\n>>> add-numbers 1 2\n3"
    },
    "docstring_bertscore": {
      "sq": "1",
      "hy": "0.9522419070751146",
      "bn": "1",
      "bg": "1",
      "zh": "0.9674897682752578",
      "fr": "0.9477331960560037",
      "de": "1",
      "ha": "1",
      "hi": "0.9674897682752578",
      "hu": "0.9674897682752578"
    }
  },
  {
    "task_id": "Common Lisp/34",
    "prompt": {
      "en": "(defun count-valid-sequences (n)\n;; This function calculates the number of valid sequences that can be formed from a given positive integer 'n'.\n;; A valid sequence is one that starts with 'n' and can have additional numbers appended, each no more than half of the last number in the sequence.\n;; Example:\n;; >>> count-valid-sequences 6\n;; 6\n;; >>> count-valid-sequences 4\n;; 4",
      "sq": "(defun count-valid-sequences (n)\n;; Kjo funksion llogarit numrin e sekuencave të vlefshme që mund të formohen nga një numër i dhënë pozitiv 'n'.\n;; Një sekuencë e vlefshme është ajo që fillon me 'n' dhe mund të ketë numra shtesë të bashkangjitur, secili jo më shumë se gjysma e numrit të fundit në sekuencë.\n;; Shembull:\n;; >>> count-valid-sequences 6\n;; 6\n;; >>> count-valid-sequences 4\n;; 4",
      "hy": "(defun count-valid-sequences (n)\n;; Այս ֆունկցիան հաշվում է վավեր հաջորդականությունների քանակը, որոնք կարող են ձևավորվել տրված դրական ամբողջ թիվ 'n'-ից:\n;; Վավեր հաջորդականությունը այն է, որը սկսվում է 'n'-ով և կարող է ունենալ հավելյալ թվեր, որոնցից յուրաքանչյուրը չի գերազանցում հաջորդականության վերջին թվի կեսը:\n;; Օրինակ:\n;; >>> count-valid-sequences 6\n;; 6\n;; >>> count-valid-sequences 4\n;; 4",
      "bn": "(defun count-valid-sequences (n)\n;; এই ফাংশনটি একটি প্রদত্ত ধনাত্মক পূর্ণসংখ্যা 'n' থেকে গঠিত বৈধ সিকোয়েন্সের সংখ্যা গণনা করে।\n;; একটি বৈধ সিকোয়েন্স হল এমন একটি যা 'n' দিয়ে শুরু হয় এবং এতে অতিরিক্ত সংখ্যা যোগ করা যায়, প্রতিটি সংখ্যা সিকোয়েন্সের শেষ সংখ্যার অর্ধেকের বেশি নয়।\n;; উদাহরণ:\n;; >>> count-valid-sequences 6\n;; 6\n;; >>> count-valid-sequences 4\n;; 4",
      "bg": "(defun count-valid-sequences (n)\n;; Тази функция изчислява броя на валидните последователности, които могат да бъдат формирани от дадено положително цяло число 'n'.\n;; Валидна последователност е такава, която започва с 'n' и може да има добавени допълнителни числа, всяко не повече от половината на последното число в последователността.\n;; Пример:\n;; >>> count-valid-sequences 6\n;; 6\n;; >>> count-valid-sequences 4\n;; 4",
      "zh": "(defun count-valid-sequences (n)\n;; 此函数计算可以从给定正整数 'n' 形成的有效序列的数量。\n;; 有效序列是以 'n' 开头的序列，可以附加其他数字，每个数字不超过序列中最后一个数字的一半。\n;; 例子:\n;; >>> count-valid-sequences 6\n;; 6\n;; >>> count-valid-sequences 4\n;; 4",
      "fr": "(defun count-valid-sequences (n)\n;; Cette fonction calcule le nombre de séquences valides qui peuvent être formées à partir d'un entier positif 'n' donné.\n;; Une séquence valide est celle qui commence par 'n' et peut avoir des nombres supplémentaires ajoutés, chacun ne dépassant pas la moitié du dernier nombre de la séquence.\n;; Exemple:\n;; >>> count-valid-sequences 6\n;; 6\n;; >>> count-valid-sequences 4\n;; 4",
      "de": "(defun count-valid-sequences (n)\n;; Diese Funktion berechnet die Anzahl der gültigen Sequenzen, die aus einer gegebenen positiven Ganzzahl 'n' gebildet werden können.\n;; Eine gültige Sequenz beginnt mit 'n' und kann zusätzliche Zahlen angehängt haben, die jeweils nicht mehr als die Hälfte der letzten Zahl in der Sequenz betragen.\n;; Beispiel:\n;; >>> count-valid-sequences 6\n;; 6\n;; >>> count-valid-sequences 4\n;; 4",
      "ha": "(defun count-valid-sequences (n)\n;; Wannan aikin yana ƙididdige adadin jerin sahihai da za a iya samarwa daga wani lamba mai kyau 'n'.\n;; Jeri mai kyau shine wanda ke farawa da 'n' kuma zai iya samun ƙarin lambobi da aka makala, kowanne ba fiye da rabin lambar ƙarshe a cikin jerin ba.\n;; Misali:\n;; >>> count-valid-sequences 6\n;; 6\n;; >>> count-valid-sequences 4\n;; 4",
      "hi": "(defun count-valid-sequences (n)\n;; यह फ़ंक्शन दिए गए धनात्मक पूर्णांक 'n' से बनने वाले मान्य अनुक्रमों की संख्या की गणना करता है।\n;; एक मान्य अनुक्रम वह है जो 'n' से शुरू होता है और इसमें अतिरिक्त संख्याएँ जोड़ी जा सकती हैं, प्रत्येक संख्या अनुक्रम में अंतिम संख्या के आधे से अधिक नहीं होनी चाहिए।\n;; उदाहरण:\n;; >>> count-valid-sequences 6\n;; 6\n;; >>> count-valid-sequences 4\n;; 4",
      "hu": "(defun count-valid-sequences (n)\n;; Ez a függvény kiszámítja a megadott pozitív egész 'n' számból képezhető érvényes sorozatok számát.\n;; Egy érvényes sorozat olyan, amely 'n'-nel kezdődik, és további számok fűzhetők hozzá, amelyek mindegyike legfeljebb a sorozat utolsó számának fele lehet.\n;; Példa:\n;; >>> count-valid-sequences 6\n;; 6\n;; >>> count-valid-sequences 4\n;; 4"
    },
    "prompt_bertscore": {
      "sq": "0.9886444997466165",
      "hy": "0.9701863743281874",
      "bn": "0.9691429689366111",
      "bg": "0.9928618199967493",
      "zh": "0.9626012759676081",
      "fr": "0.9825759443452385",
      "de": "0.9785562613242356",
      "ha": "0.9837037676487547",
      "hi": "0.9704294979145741",
      "hu": "0.9525738184418239"
    },
    "canonical_solution": "(if (= n 1) \n1 \n(1+ (reduce #'+ (mapcar #'count-valid-sequences (loop for i from 1 to (/ n 2) collect i))))))",
    "instruction": {
      "en": "Write a Common Lisp function `(defun count-valid-sequences (n)` to solve the following problem:\nThis function calculates the number of valid sequences that can be formed from a given positive integer 'n'.\nA valid sequence is one that starts with 'n' and can have additional numbers appended, each no more than half of the last number in the sequence.\nExample:\n>>> count-valid-sequences 6\n6\n>>> count-valid-sequences 4\n4",
      "sq": "Shkruani një funksion Common Lisp `(defun count-valid-sequences (n)` për të zgjidhur problemin e mëposhtëm:  \nKy funksion llogarit numrin e sekuencave të vlefshme që mund të formohen nga një numër i dhënë pozitiv 'n'.  \nNjë sekuencë e vlefshme është ajo që fillon me 'n' dhe mund të ketë numra shtesë të bashkangjitur, secili jo më shumë se gjysma e numrit të fundit në sekuencë.  \nShembull:  \n>>> count-valid-sequences 6  \n6  \n>>> count-valid-sequences 4  \n4",
      "hy": "Գրեք Common Lisp ֆունկցիա `(defun count-valid-sequences (n)` հետևյալ խնդիրը լուծելու համար:\nԱյս ֆունկցիան հաշվում է վավեր հաջորդականությունների քանակը, որոնք կարող են կազմվել տրված դրական ամբողջ թիվ 'n'-ից:\nՎավեր հաջորդականությունը այն է, որը սկսվում է 'n'-ով և կարող է ունենալ հավելյալ թվեր, որոնցից յուրաքանչյուրը չի գերազանցում հաջորդականության վերջին թվի կեսը:\nՕրինակ:\n>>> count-valid-sequences 6\n6\n>>> count-valid-sequences 4\n4",
      "bn": "একটি Common Lisp ফাংশন `(defun count-valid-sequences (n)` লিখুন নিম্নলিখিত সমস্যার সমাধানের জন্য:\nএই ফাংশনটি একটি প্রদত্ত ধনাত্মক পূর্ণসংখ্যা 'n' থেকে গঠিত বৈধ সিকোয়েন্সের সংখ্যা গণনা করে।\nএকটি বৈধ সিকোয়েন্স হল এমন একটি যা 'n' দিয়ে শুরু হয় এবং এতে অতিরিক্ত সংখ্যা যোগ করা যেতে পারে, প্রতিটি সংখ্যা সিকোয়েন্সের শেষ সংখ্যার অর্ধেকের বেশি নয়।\nউদাহরণ:\n>>> count-valid-sequences 6\n6\n>>> count-valid-sequences 4\n4",
      "bg": "Напишете функция на Common Lisp `(defun count-valid-sequences (n)` за решаване на следния проблем:\nТази функция изчислява броя на валидните последователности, които могат да бъдат формирани от дадено положително цяло число 'n'.\nВалидна последователност е такава, която започва с 'n' и може да има добавени допълнителни числа, всяко не повече от половината на последното число в последователността.\nПример:\n>>> count-valid-sequences 6\n6\n>>> count-valid-sequences 4\n4",
      "zh": "编写一个 Common Lisp 函数 `(defun count-valid-sequences (n)` 来解决以下问题：\n此函数计算可以从给定正整数 'n' 形成的有效序列的数量。\n有效序列是以 'n' 开头的序列，可以附加其他数字，每个数字不超过序列中最后一个数字的一半。\n示例:\n>>> count-valid-sequences 6\n6\n>>> count-valid-sequences 4\n4",
      "fr": "Écrire une fonction Common Lisp `(defun count-valid-sequences (n)` pour résoudre le problème suivant :\nCette fonction calcule le nombre de séquences valides pouvant être formées à partir d'un entier positif 'n'.\nUne séquence valide est celle qui commence par 'n' et peut avoir des nombres supplémentaires ajoutés, chacun ne dépassant pas la moitié du dernier nombre dans la séquence.\nExemple :\n>>> count-valid-sequences 6\n6\n>>> count-valid-sequences 4\n4",
      "de": "Schreiben Sie eine Common Lisp-Funktion `(defun count-valid-sequences (n)` um das folgende Problem zu lösen:\nDiese Funktion berechnet die Anzahl der gültigen Sequenzen, die aus einer gegebenen positiven ganzen Zahl 'n' gebildet werden können.\nEine gültige Sequenz beginnt mit 'n' und kann zusätzliche Zahlen angehängt haben, wobei jede Zahl nicht mehr als die Hälfte der letzten Zahl in der Sequenz beträgt.\nBeispiel:\n>>> count-valid-sequences 6\n6\n>>> count-valid-sequences 4\n4",
      "ha": "Rubuta wani aikin Common Lisp `(defun count-valid-sequences (n)` don warware matsalar mai zuwa:\nWannan aikin yana ƙididdige adadin jerin sahihai waɗanda za a iya samarwa daga wani adadi mai kyau 'n'.\nJerin sahihi shine wanda ya fara da 'n' kuma zai iya samun ƙarin lambobi da aka makala, kowanne ba fiye da rabin lambar ƙarshe a cikin jerin ba.\nMisali:\n>>> count-valid-sequences 6\n6\n>>> count-valid-sequences 4\n4",
      "hi": "एक Common Lisp फ़ंक्शन `(defun count-valid-sequences (n)` लिखें ताकि निम्नलिखित समस्या का समाधान किया जा सके:\nयह फ़ंक्शन उस मान्य अनुक्रमों की संख्या की गणना करता है जो दिए गए धनात्मक पूर्णांक 'n' से बनाए जा सकते हैं।\nएक मान्य अनुक्रम वह है जो 'n' से शुरू होता है और उसमें अतिरिक्त संख्याएँ जोड़ी जा सकती हैं, प्रत्येक संख्या अनुक्रम में अंतिम संख्या के आधे से अधिक नहीं हो सकती।\nउदाहरण:\n>>> count-valid-sequences 6\n6\n>>> count-valid-sequences 4\n4",
      "hu": "Írj egy Common Lisp függvényt `(defun count-valid-sequences (n)` a következő probléma megoldására:\nEz a függvény kiszámítja, hogy hány érvényes sorozat képezhető egy adott pozitív egész 'n' számból.\nEgy érvényes sorozat olyan, amely 'n'-nel kezdődik, és további számok fűzhetők hozzá, amelyek mindegyike legfeljebb a sorozat utolsó számának fele lehet.\nPélda:\n>>> count-valid-sequences 6\n6\n>>> count-valid-sequences 4\n4"
    },
    "instruction_bertscore": {
      "sq": "0.9872626281857567",
      "hy": "0.971072265827603",
      "bn": "0.9635531127535273",
      "bg": "0.9944977398149526",
      "zh": "0.9629681462813796",
      "fr": "0.9770055539394962",
      "de": "0.9787078163049652",
      "ha": "0.9842843642525196",
      "hi": "0.9287502891708804",
      "hu": "0.9496682532280455"
    },
    "level": "easy",
    "test": "(defun test-count-valid-sequences ()\n(assert (equal (count-valid-sequences 6) 6))\n(assert (equal (count-valid-sequences 4) 4))\n(assert (equal (count-valid-sequences 10) 14))\n(assert (equal (count-valid-sequences 2) 2))\n(assert (equal (count-valid-sequences 1) 1)))\n\n(test-count-valid-sequences)",
    "entry_point": "count-valid-sequences",
    "signature": "(defun count-valid-sequences (n)",
    "docstring": {
      "en": "This function calculates the number of valid sequences that can be formed from a given positive integer 'n'.\nA valid sequence is one that starts with 'n' and can have additional numbers appended, each no more than half of the last number in the sequence.\nExample:\n>>> count-valid-sequences 6\n6\n>>> count-valid-sequences 4\n4",
      "sq": "Kjo funksion llogarit numrin e sekuencave të vlefshme që mund të formohen nga një numër i dhënë pozitiv 'n'.\nNjë sekuencë e vlefshme është ajo që fillon me 'n' dhe mund të ketë numra shtesë të bashkangjitur, secili jo më shumë se gjysma e numrit të fundit në sekuencë.\nShembull:\n>>> count-valid-sequences 6\n6\n>>> count-valid-sequences 4\n4",
      "hy": "Այս ֆունկցիան հաշվում է վավեր հաջորդականությունների քանակը, որոնք կարող են կազմվել տրված դրական ամբողջ թիվ 'n'-ից:\nՎավեր հաջորդականություն է այն, որը սկսվում է 'n'-ով և կարող է ունենալ լրացուցիչ թվեր, որոնցից յուրաքանչյուրը չի գերազանցում հաջորդականության վերջին թվի կեսը:\nՕրինակ:\n>>> count-valid-sequences 6\n6\n>>> count-valid-sequences 4\n4",
      "bn": "এই ফাংশনটি প্রদত্ত ধনাত্মক পূর্ণসংখ্যা 'n' থেকে গঠিত হতে পারে এমন বৈধ ক্রমের সংখ্যা গণনা করে। একটি বৈধ ক্রম হল এমন একটি যা 'n' দিয়ে শুরু হয় এবং এতে অতিরিক্ত সংখ্যা যোগ করা যেতে পারে, প্রতিটি সংখ্যা ক্রমের শেষ সংখ্যার অর্ধেকের বেশি নয়।\nউদাহরণ:\n>>> count-valid-sequences 6\n6\n>>> count-valid-sequences 4\n4",
      "bg": "Тази функция изчислява броя на валидните последователности, които могат да бъдат формирани от дадено положително цяло число 'n'. Валидна последователност е такава, която започва с 'n' и може да има добавени допълнителни числа, всяко от които не е повече от половината на последното число в последователността.\nПример:\n>>> count-valid-sequences 6\n6\n>>> count-valid-sequences 4\n4",
      "zh": "该函数计算可以从给定正整数 'n' 形成的有效序列的数量。  \n有效序列是以 'n' 开头的序列，可以附加其他数字，每个数字不超过序列中最后一个数字的一半。  \n示例：  \n>>> count-valid-sequences 6  \n6  \n>>> count-valid-sequences 4  \n4  ",
      "fr": "Cette fonction calcule le nombre de séquences valides qui peuvent être formées à partir d'un entier positif 'n' donné. Une séquence valide est celle qui commence par 'n' et peut avoir des nombres supplémentaires ajoutés, chacun ne dépassant pas la moitié du dernier nombre de la séquence.\nExemple :\n>>> count-valid-sequences 6\n6\n>>> count-valid-sequences 4\n4",
      "de": "Diese Funktion berechnet die Anzahl der gültigen Sequenzen, die aus einer gegebenen positiven Ganzzahl 'n' gebildet werden können. Eine gültige Sequenz beginnt mit 'n' und kann zusätzliche Zahlen angehängt haben, wobei jede nicht mehr als die Hälfte der letzten Zahl in der Sequenz beträgt.\nBeispiel:\n>>> count-valid-sequences 6\n6\n>>> count-valid-sequences 4\n4",
      "ha": "Wannan aikin yana ƙididdige adadin jerin sahihan jerin da za a iya ƙirƙira daga wani adadi mai kyau 'n'.\nSahihin jeri shine wanda ya fara da 'n' kuma zai iya samun ƙarin lambobi da aka haɗa, kowanne bai fi rabin lambar ƙarshe a cikin jerin ba.\nMisali:\n>>> count-valid-sequences 6\n6\n>>> count-valid-sequences 4\n4",
      "hi": "यह फ़ंक्शन उन मान्य अनुक्रमों की संख्या की गणना करता है जो दिए गए धनात्मक पूर्णांक 'n' से बनाए जा सकते हैं। एक मान्य अनुक्रम वह है जो 'n' से शुरू होता है और इसमें अतिरिक्त संख्याएँ जोड़ी जा सकती हैं, प्रत्येक संख्या अनुक्रम में अंतिम संख्या के आधे से अधिक नहीं हो सकती।\n\nउदाहरण:\n>>> count-valid-sequences 6\n6\n>>> count-valid-sequences 4\n4",
      "hu": "Ez a függvény kiszámítja a megadott pozitív egész 'n' számból képezhető érvényes sorozatok számát. \nEgy érvényes sorozat olyan, amely 'n'-nel kezdődik, és további számok fűzhetők hozzá, amelyek mindegyike legfeljebb a sorozat utolsó számának fele lehet. \nPélda:\n>>> count-valid-sequences 6\n6\n>>> count-valid-sequences 4\n4"
    },
    "docstring_bertscore": {
      "sq": "0.9845600632213961",
      "hy": "0.9700278672841216",
      "bn": "0.9676536383396116",
      "bg": "0.976816457816751",
      "zh": "0.9573767010552475",
      "fr": "0.9790667414034953",
      "de": "0.9740737695154212",
      "ha": "0.9606314584788852",
      "hi": "0.9708688683174233",
      "hu": "0.9436157868875314"
    }
  },
  {
    "task_id": "Common Lisp/35",
    "prompt": {
      "en": "(defun construct-preorder (inorder postorder)\n;; This function reconstructs the preorder traversal of a binary tree from its inorder and postorder traversals.\n;; The nodes of the binary tree are represented by distinct uppercase letters.\n;; It is assumed that the tree has no more than 8 nodes.\n;; Example:\n;; >>> construct-preorder \"DBEAC\" \"DEBCA\"\n;; \"ABCDE\"\n;; >>> construct-preorder \"HGFEIDBA\" \"HGFIEDBA\"\n;; \"ABDEFGHI\"",
      "sq": "(defun construct-preorder (inorder postorder)\n;; Kjo funksion rindërton renditjen paraprake të një peme binare nga renditjet e saj në rend dhe pas rendit.\n;; Nyjet e pemës binare përfaqësohen nga shkronja të mëdha të dallueshme.\n;; Supozohet se pema nuk ka më shumë se 8 nyje.\n;; Shembull:\n;; >>> construct-preorder \"DBEAC\" \"DEBCA\"\n;; \"ABCDE\"\n;; >>> construct-preorder \"HGFEIDBA\" \"HGFIEDBA\"\n;; \"ABDEFGHI\"",
      "hy": "(defun construct-preorder (inorder postorder)\n;; Այս ֆունկցիան վերակառուցում է բինար ծառի նախորդող անցումը իր ներթափանցման և հետընթաց անցումներից։\n;; Բինար ծառի հանգույցները ներկայացված են տարբեր մեծատառերով։\n;; Ենթադրվում է, որ ծառը ունի ոչ ավելի, քան 8 հանգույց։\n;; Օրինակ:\n;; >>> construct-preorder \"DBEAC\" \"DEBCA\"\n;; \"ABCDE\"\n;; >>> construct-preorder \"HGFEIDBA\" \"HGFIEDBA\"\n;; \"ABDEFGHI\"",
      "bn": "(defun construct-preorder (inorder postorder)\n;; এই ফাংশনটি একটি বাইনারি গাছের প্রি-অর্ডার ট্র্যাভার্সাল পুনর্গঠন করে তার ইন-অর্ডার এবং পোস্ট-অর্ডার ট্র্যাভার্সাল থেকে।\n;; বাইনারি গাছের নোডগুলি পৃথক বড় হাতের অক্ষর দ্বারা উপস্থাপিত হয়।\n;; অনুমান করা হয় যে গাছটিতে ৮টির বেশি নোড নেই।\n;; উদাহরণ:\n;; >>> construct-preorder \"DBEAC\" \"DEBCA\"\n;; \"ABCDE\"\n;; >>> construct-preorder \"HGFEIDBA\" \"HGFIEDBA\"\n;; \"ABDEFGHI\"",
      "bg": "(defun construct-preorder (inorder postorder)\n;; Тази функция реконструира предварителното обхождане на двоично дърво от неговите обходи по ред и по постред.\n;; Възлите на двоичното дърво са представени чрез различни главни букви.\n;; Предполага се, че дървото има не повече от 8 възела.\n;; Пример:\n;; >>> construct-preorder \"DBEAC\" \"DEBCA\"\n;; \"ABCDE\"\n;; >>> construct-preorder \"HGFEIDBA\" \"HGFIEDBA\"\n;; \"ABDEFGHI\"",
      "zh": "(defun construct-preorder (inorder postorder)\n;; 此函数从中序遍历和后序遍历重建二叉树的前序遍历。\n;; 二叉树的节点由不同的大写字母表示。\n;; 假设树不超过8个节点。\n;; 示例:\n;; >>> construct-preorder \"DBEAC\" \"DEBCA\"\n;; \"ABCDE\"\n;; >>> construct-preorder \"HGFEIDBA\" \"HGFIEDBA\"\n;; \"ABDEFGHI\"",
      "fr": "(defun construct-preorder (inorder postorder)\n;; Cette fonction reconstruit le parcours en pré-ordre d'un arbre binaire à partir de ses parcours en ordre et en post-ordre.\n;; Les nœuds de l'arbre binaire sont représentés par des lettres majuscules distinctes.\n;; Il est supposé que l'arbre n'a pas plus de 8 nœuds.\n;; Exemple:\n;; >>> construct-preorder \"DBEAC\" \"DEBCA\"\n;; \"ABCDE\"\n;; >>> construct-preorder \"HGFEIDBA\" \"HGFIEDBA\"\n;; \"ABDEFGHI\"",
      "de": "(defun construct-preorder (inorder postorder)\n;; Diese Funktion rekonstruiert die Preorder-Traversierung eines Binärbaums aus seinen Inorder- und Postorder-Traversierungen.\n;; Die Knoten des Binärbaums werden durch unterschiedliche Großbuchstaben dargestellt.\n;; Es wird angenommen, dass der Baum nicht mehr als 8 Knoten hat.\n;; Beispiel:\n;; >>> construct-preorder \"DBEAC\" \"DEBCA\"\n;; \"ABCDE\"\n;; >>> construct-preorder \"HGFEIDBA\" \"HGFIEDBA\"\n;; \"ABDEFGHI\"",
      "ha": "(defun construct-preorder (inorder postorder)\n;; Wannan aiki yana sake gina hanyar preorder na itacen binary daga hanyoyin inorder da postorder.\n;; Ana wakiltar gungun itacen binary ta hanyar manyan haruffa daban-daban.\n;; Ana tsammanin cewa itacen ba shi da fiye da gungun 8.\n;; Misali:\n;; >>> construct-preorder \"DBEAC\" \"DEBCA\"\n;; \"ABCDE\"\n;; >>> construct-preorder \"HGFEIDBA\" \"HGFIEDBA\"\n;; \"ABDEFGHI\"",
      "hi": "(defun construct-preorder (inorder postorder)\n;; यह फ़ंक्शन एक बाइनरी ट्री के प्रीऑर्डर ट्रैवर्सल को उसके इनऑर्डर और पोस्टऑर्डर ट्रैवर्सल से पुनर्निर्मित करता है।\n;; बाइनरी ट्री के नोड्स को भिन्न अपरकेस अक्षरों द्वारा दर्शाया जाता है।\n;; यह माना जाता है कि ट्री में 8 से अधिक नोड्स नहीं हैं।\n;; उदाहरण:\n;; >>> construct-preorder \"DBEAC\" \"DEBCA\"\n;; \"ABCDE\"\n;; >>> construct-preorder \"HGFEIDBA\" \"HGFIEDBA\"\n;; \"ABDEFGHI\"",
      "hu": "(defun construct-preorder (inorder postorder)\n;; Ez a függvény egy bináris fa preorder bejárását rekonstruálja az inorder és postorder bejárásokból.\n;; A bináris fa csomópontjait különálló nagybetűk képviselik.\n;; Feltételezzük, hogy a fának legfeljebb 8 csomópontja van.\n;; Példa:\n;; >>> construct-preorder \"DBEAC\" \"DEBCA\"\n;; \"ABCDE\"\n;; >>> construct-preorder \"HGFEIDBA\" \"HGFIEDBA\"\n;; \"ABDEFGHI\""
    },
    "prompt_bertscore": {
      "sq": "1",
      "hy": "0.9961088308355266",
      "bn": "0.9950258979981244",
      "bg": "0.9831442258653794",
      "zh": "0.9804478184428308",
      "fr": "0.9872880528745293",
      "de": "0.9961088308355266",
      "ha": "0.9656834235901265",
      "hi": "0.9912280851127373",
      "hu": "0.986136393925289"
    },
    "canonical_solution": "(when (and inorder postorder (not (zerop (length postorder))))\n(let* ((root (char postorder (1- (length postorder))))\n(root-pos (position root inorder)))\n(concatenate 'string\n(string root)\n(construct-preorder (subseq inorder 0 root-pos)\n(subseq postorder 0 root-pos))\n(construct-preorder (subseq inorder (1+ root-pos))\n(subseq postorder root-pos (1- (length postorder))))))))",
    "instruction": {
      "en": "Write a Common Lisp function `(defun construct-preorder (inorder postorder)` to solve the following problem:\nThis function reconstructs the preorder traversal of a binary tree from its inorder and postorder traversals.\nThe nodes of the binary tree are represented by distinct uppercase letters.\nIt is assumed that the tree has no more than 8 nodes.\nExample:\n>>> construct-preorder \"DBEAC\" \"DEBCA\"\n\"ABCDE\"\n>>> construct-preorder \"HGFEIDBA\" \"HGFIEDBA\"\n\"ABDEFGHI\"",
      "sq": "Shkruani një funksion Common Lisp `(defun construct-preorder (inorder postorder)` për të zgjidhur problemin e mëposhtëm:  \nKy funksion rindërton kalimin preorder të një peme binare nga kalimet e saj inorder dhe postorder.  \nNyjet e pemës binare përfaqësohen nga shkronja të mëdha të dallueshme.  \nSupozohen që pema nuk ka më shumë se 8 nyje.  \nShembull:  \n>>> construct-preorder \"DBEAC\" \"DEBCA\"  \n\"ABCDE\"  \n>>> construct-preorder \"HGFEIDBA\" \"HGFIEDBA\"  \n\"ABDEFGHI\"",
      "hy": "Գրեք Common Lisp ֆունկցիա `(defun construct-preorder (inorder postorder)` հետևյալ խնդիրը լուծելու համար:\nԱյս ֆունկցիան վերակառուցում է բինար ծառի նախորդական շրջանցումը նրա ներմուծման և հետմուտքի շրջանցումներից:\nԲինար ծառի հանգույցները ներկայացված են տարբեր մեծատառերով:\nԵնթադրվում է, որ ծառը ունի ոչ ավելի, քան 8 հանգույց:\nՕրինակ:\n>>> construct-preorder \"DBEAC\" \"DEBCA\"\n\"ABCDE\"\n>>> construct-preorder \"HGFEIDBA\" \"HGFIEDBA\"\n\"ABDEFGHI\"",
      "bn": "লিখুন একটি Common Lisp ফাংশন `(defun construct-preorder (inorder postorder)` নিম্নলিখিত সমস্যার সমাধানের জন্য:\nএই ফাংশনটি একটি বাইনারি গাছের প্রি-অর্ডার ট্র্যাভার্সাল পুনর্গঠন করে তার ইন-অর্ডার এবং পোস্ট-অর্ডার ট্র্যাভার্সাল থেকে।\nবাইনারি গাছের নোডগুলি স্বতন্ত্র বড় হাতের অক্ষর দ্বারা উপস্থাপিত হয়।\nধরা হয়েছে যে গাছটির সর্বাধিক ৮টি নোড রয়েছে।\nউদাহরণ:\n>>> construct-preorder \"DBEAC\" \"DEBCA\"\n\"ABCDE\"\n>>> construct-preorder \"HGFEIDBA\" \"HGFIEDBA\"\n\"ABDEFGHI\"",
      "bg": "Напишете функция на Common Lisp `(defun construct-preorder (inorder postorder)` за решаване на следния проблем:\nТази функция реконструира предредовото обхождане на двоично дърво от неговите междинно и постредово обхождания.\nВъзлите на двоичното дърво са представени чрез различни главни букви.\nПредполага се, че дървото има не повече от 8 възела.\nПример:\n>>> construct-preorder \"DBEAC\" \"DEBCA\"\n\"ABCDE\"\n>>> construct-preorder \"HGFEIDBA\" \"HGFIEDBA\"\n\"ABDEFGHI\"",
      "zh": "编写一个 Common Lisp 函数 `(defun construct-preorder (inorder postorder)` 来解决以下问题：\n此函数从中序遍历和后序遍历重建二叉树的前序遍历。\n二叉树的节点由不同的大写字母表示。\n假设树不超过 8 个节点。\n示例:",
      "fr": "Écrire une fonction Common Lisp `(defun construct-preorder (inorder postorder)` pour résoudre le problème suivant :\nCette fonction reconstruit le parcours en préordre d'un arbre binaire à partir de ses parcours en ordre et en postordre.\nLes nœuds de l'arbre binaire sont représentés par des lettres majuscules distinctes.\nIl est supposé que l'arbre a au plus 8 nœuds.\nExemple :\n>>> construct-preorder \"DBEAC\" \"DEBCA\"\n\"ABCDE\"\n>>> construct-preorder \"HGFEIDBA\" \"HGFIEDBA\"\n\"ABDEFGHI\"",
      "de": "Schreiben Sie eine Common Lisp-Funktion `(defun construct-preorder (inorder postorder)` um das folgende Problem zu lösen:\nDiese Funktion rekonstruiert die Preorder-Traversierung eines Binärbaums aus seinen Inorder- und Postorder-Traversierungen.\nDie Knoten des Binärbaums werden durch unterschiedliche Großbuchstaben dargestellt.\nEs wird angenommen, dass der Baum nicht mehr als 8 Knoten hat.\nBeispiel:\n>>> construct-preorder \"DBEAC\" \"DEBCA\"\n\"ABCDE\"\n>>> construct-preorder \"HGFEIDBA\" \"HGFIEDBA\"\n\"ABDEFGHI\"",
      "ha": "Rubuta aikin Common Lisp `(defun construct-preorder (inorder postorder)` don magance matsalar mai zuwa:\nWannan aikin yana sake gina bin diddigin preorder na itacen binary daga bin diddigin inorder da postorder.\nAna wakiltar gungun itacen binary ta hanyar manyan haruffa daban-daban.\nAna tsammanin cewa itacen ba shi da fiye da nodes 8.\nMisali:\n>>> construct-preorder \"DBEAC\" \"DEBCA\"\n\"ABCDE\"\n>>> construct-preorder \"HGFEIDBA\" \"HGFIEDBA\"\n\"ABDEFGHI\"",
      "hi": "एक Common Lisp फ़ंक्शन `(defun construct-preorder (inorder postorder)` लिखें ताकि निम्नलिखित समस्या का समाधान किया जा सके:\nयह फ़ंक्शन एक बाइनरी वृक्ष के प्रीऑर्डर ट्रैवर्सल का पुनर्निर्माण करता है उसके इनऑर्डर और पोस्टऑर्डर ट्रैवर्सल से।\nबाइनरी वृक्ष के नोड्स को विशिष्ट अपरकेस अक्षरों द्वारा दर्शाया जाता है।\nयह माना जाता है कि वृक्ष में 8 से अधिक नोड्स नहीं हैं।\nउदाहरण:\n>>> construct-preorder \"DBEAC\" \"DEBCA\"\n\"ABCDE\"\n>>> construct-preorder \"HGFEIDBA\" \"HGFIEDBA\"\n\"ABDEFGHI\"",
      "hu": "Írj egy Common Lisp függvényt `(defun construct-preorder (inorder postorder)` a következő probléma megoldására:\nEz a függvény újraépíti egy bináris fa preorder bejárását az inorder és postorder bejárásokból.\nA bináris fa csomópontjai különböző nagybetűkkel vannak ábrázolva.\nFeltételezhető, hogy a fának legfeljebb 8 csomópontja van.\nPélda:\n>>> construct-preorder \"DBEAC\" \"DEBCA\"\n\"ABCDE\"\n>>> construct-preorder \"HGFEIDBA\" \"HGFIEDBA\"\n\"ABDEFGHI\""
    },
    "instruction_bertscore": {
      "sq": "1",
      "hy": "0.9963662558093478",
      "bn": "0.9775211984086627",
      "bg": "0.9963662558093478",
      "zh": "0.8502380557199822",
      "fr": "0.9893156718041334",
      "de": "0.9963662558093478",
      "ha": "0.9787560834875566",
      "hi": "0.9910008519568334",
      "hu": "0.9792200840576541"
    },
    "level": "hard",
    "test": "(defun test-construct-preorder ()\n(assert (string= (construct-preorder \"DBEAC\" \"DEBCA\") \"ABDEC\"))\n(assert (string= (construct-preorder \"HGFEIDBA\" \"HGFIEDBA\") \"ABDEFGHI\"))\n(assert (string= (construct-preorder \"BADC\" \"BDCA\") \"ABCD\"))\n(assert (string= (construct-preorder \"FBAEDC\" \"FBEADC\") \"CDABFE\"))\n(assert (string= (construct-preorder \"A\" \"A\") \"A\")))\n\n(test-construct-preorder)",
    "entry_point": "construct-preorder",
    "signature": "(defun construct-preorder (inorder postorder)",
    "docstring": {
      "en": "This function reconstructs the preorder traversal of a binary tree from its inorder and postorder traversals.\nThe nodes of the binary tree are represented by distinct uppercase letters.\nIt is assumed that the tree has no more than 8 nodes.\nExample:\n>>> construct-preorder \"DBEAC\" \"DEBCA\"\n\"ABCDE\"\n>>> construct-preorder \"HGFEIDBA\" \"HGFIEDBA\"\n\"ABDEFGHI\"",
      "sq": "Kjo funksion rindërton kalimin preorder të një peme binare nga kalimet e saj inorder dhe postorder. Nyjet e pemës binare përfaqësohen nga shkronja të mëdha të dallueshme. Supozohet se pema nuk ka më shumë se 8 nyje. Shembull:\n>>> construct-preorder \"DBEAC\" \"DEBCA\"\n\"ABCDE\"\n>>> construct-preorder \"HGFEIDBA\" \"HGFIEDBA\"\n\"ABDEFGHI\"",
      "hy": "Այս ֆունկցիան վերակառուցում է բինար ծառի նախնական շրջանցումը նրա ներսի և հետին շրջանցումներից:\nԲինար ծառի հանգույցները ներկայացված են տարբեր մեծատառերով:\nԵնթադրվում է, որ ծառը ունի ոչ ավելի, քան 8 հանգույց:\nՕրինակ:\n>>> construct-preorder \"DBEAC\" \"DEBCA\"\n\"ABCDE\"\n>>> construct-preorder \"HGFEIDBA\" \"HGFIEDBA\"\n\"ABDEFGHI\"",
      "bn": "এই ফাংশনটি একটি বাইনারি ট্রি-এর প্রি-অর্ডার ট্রাভার্সাল পুনর্গঠন করে তার ইন-অর্ডার এবং পোস্ট-অর্ডার ট্রাভার্সাল থেকে। বাইনারি ট্রি-এর নোডগুলি স্বতন্ত্র বড় হাতের অক্ষর দ্বারা উপস্থাপিত হয়। অনুমান করা হয় যে ট্রি-তে ৮টির বেশি নোড নেই।\n\nউদাহরণ:\n>>> construct-preorder \"DBEAC\" \"DEBCA\"\n\"ABCDE\"\n>>> construct-preorder \"HGFEIDBA\" \"HGFIEDBA\"\n\"ABDEFGHI\"",
      "bg": "Тази функция реконструира предредовото обхождане на двоично дърво от неговите обхождания по ред и следредово обхождане. Възлите на двоичното дърво са представени чрез различни главни букви. Предполага се, че дървото има не повече от 8 възела. Пример:\n>>> construct-preorder \"DBEAC\" \"DEBCA\"\n\"ABCDE\"\n>>> construct-preorder \"HGFEIDBA\" \"HGFIEDBA\"\n\"ABDEFGHI\"",
      "zh": "此函数从中序遍历和后序遍历重建二叉树的前序遍历。  \n二叉树的节点由不同的大写字母表示。  \n假设树最多有8个节点。  \n示例:  \n>>> construct-preorder \"DBEAC\" \"DEBCA\"  \n\"ABCDE\"  \n>>> construct-preorder \"HGFEIDBA\" \"HGFIEDBA\"  \n\"ABDEFGHI\"  ",
      "fr": "Cette fonction reconstruit le parcours préfixe d'un arbre binaire à partir de ses parcours infixe et postfixe.  \nLes nœuds de l'arbre binaire sont représentés par des lettres majuscules distinctes.  \nIl est supposé que l'arbre n'a pas plus de 8 nœuds.  \nExemple:  \n>>> construct-preorder \"DBEAC\" \"DEBCA\"  \n\"ABCDE\"  \n>>> construct-preorder \"HGFEIDBA\" \"HGFIEDBA\"  \n\"ABDEFGHI\"",
      "de": "Diese Funktion rekonstruiert die Preorder-Traversierung eines Binärbaums aus seinen Inorder- und Postorder-Traversierungen.\nDie Knoten des Binärbaums werden durch unterschiedliche Großbuchstaben dargestellt.\nEs wird angenommen, dass der Baum nicht mehr als 8 Knoten hat.\nBeispiel:\n>>> construct-preorder \"DBEAC\" \"DEBCA\"\n\"ABCDE\"\n>>> construct-preorder \"HGFEIDBA\" \"HGFIEDBA\"\n\"ABDEFGHI\"",
      "ha": "Wannan aikin yana sake gina bin diddigin preorder na itacen binary daga bin diddigin inorder da postorder.\nAna wakiltar nodes na itacen binary da manyan haruffa daban-daban.\nAna tsammanin cewa itacen ba shi da fiye da nodes 8.\nMisali:\n>>> construct-preorder \"DBEAC\" \"DEBCA\"\n\"ABCDE\"\n>>> construct-preorder \"HGFEIDBA\" \"HGFIEDBA\"\n\"ABDEFGHI\"",
      "hi": "यह फ़ंक्शन एक बाइनरी ट्री के प्रीऑर्डर ट्रैवर्सल को उसके इनऑर्डर और पोस्टऑर्डर ट्रैवर्सल से पुनर्निर्मित करता है।  \nबाइनरी ट्री के नोड्स को विशिष्ट अपरकेस अक्षरों द्वारा दर्शाया जाता है।  \nयह माना जाता है कि ट्री में 8 से अधिक नोड्स नहीं हैं।  \nउदाहरण:  \n>>> construct-preorder \"DBEAC\" \"DEBCA\"  \n\"ABCDE\"  \n>>> construct-preorder \"HGFEIDBA\" \"HGFIEDBA\"  \n\"ABDEFGHI\"  ",
      "hu": "Ez a függvény rekonstruálja egy bináris fa pre-order bejárását az inorder és postorder bejárásokból.\nA bináris fa csomópontjait különböző nagybetűk képviselik.\nFeltételezzük, hogy a fának legfeljebb 8 csomópontja van.\nPélda:\n>>> construct-preorder \"DBEAC\" \"DEBCA\"\n\"ABCDE\"\n>>> construct-preorder \"HGFEIDBA\" \"HGFIEDBA\"\n\"ABDEFGHI\""
    },
    "docstring_bertscore": {
      "sq": "0.999999801369619",
      "hy": "0.995497049261939",
      "bn": "0.986967860700301",
      "bg": "0.9809473738511335",
      "zh": "0.9678125426444395",
      "fr": "0.999999801369619",
      "de": "0.995497049261939",
      "ha": "0.9781307950480588",
      "hi": "0.9901064193510333",
      "hu": "0.9790790564871193"
    }
  },
  {
    "task_id": "Common Lisp/36",
    "prompt": {
      "en": "(defun count-prime-sums (numbers k)\n;; This function counts the number of ways to select 'k' integers from a list of 'n' integers such that their sum is a prime number.\n;; It considers all possible combinations of 'k' integers from the list and checks if their sum is prime.\n;; Example:\n;; >>> count-prime-sums '(1 2 3 4) 2\n;; 2 ; (1+2) and (3+4) are prime\n;; >>> count-prime-sums '(1 2 3 4 5 6) 3\n;; 1 ; Only (1+2+5) is prime",
      "sq": "(defun count-prime-sums (numbers k)\n;; Kjo funksion numëron numrin e mënyrave për të zgjedhur 'k' numra të plotë nga një listë prej 'n' numrash të plotë të tillë që shuma e tyre të jetë një numër i thjeshtë.\n;; Ai konsideron të gjitha kombinimet e mundshme të 'k' numrave të plotë nga lista dhe kontrollon nëse shuma e tyre është e thjeshtë.\n;; Shembull:\n;; >>> count-prime-sums '(1 2 3 4) 2\n;; 2 ; (1+2) dhe (3+4) janë të thjeshtë\n;; >>> count-prime-sums '(1 2 3 4 5 6) 3\n;; 1 ; Vetëm (1+2+5) është i thjeshtë",
      "hy": "(defun count-prime-sums (numbers k)\n;; Այս ֆունկցիան հաշվում է այն եղանակների քանակը, որոնցով կարելի է ընտրել 'k' ամբողջ թիվ 'n' ամբողջ թվերի ցուցակից այնպես, որ դրանց գումարը լինի պարզ թիվ:\n;; Այն դիտարկում է ցուցակից 'k' ամբողջ թվերի բոլոր հնարավոր կոմբինացիաները և ստուգում, արդյոք դրանց գումարը պարզ է:\n;; Օրինակ:\n;; >>> count-prime-sums '(1 2 3 4) 2\n;; 2 ; (1+2) և (3+4) պարզ են\n;; >>> count-prime-sums '(1 2 3 4 5 6) 3\n;; 1 ; Միայն (1+2+5) պարզ է",
      "bn": "(defun count-prime-sums (numbers k)\n;; এই ফাংশনটি 'n' পূর্ণসংখ্যার একটি তালিকা থেকে 'k' পূর্ণসংখ্যা নির্বাচন করার উপায়গুলির সংখ্যা গণনা করে যাতে তাদের যোগফল একটি মৌলিক সংখ্যা হয়।\n;; এটি তালিকা থেকে 'k' পূর্ণসংখ্যার সমস্ত সম্ভাব্য সংমিশ্রণ বিবেচনা করে এবং তাদের যোগফল মৌলিক কিনা তা পরীক্ষা করে।\n;; উদাহরণ:\n;; >>> count-prime-sums '(1 2 3 4) 2\n;; 2 ; (1+2) এবং (3+4) মৌলিক\n;; >>> count-prime-sums '(1 2 3 4 5 6) 3\n;; 1 ; শুধুমাত্র (1+2+5) মৌলিক",
      "bg": "(defun count-prime-sums (numbers k)\n;; Тази функция брои броя на начините за избор на 'k' цели числа от списък от 'n' цели числа, така че тяхната сума да е просто число.\n;; Тя разглежда всички възможни комбинации от 'k' цели числа от списъка и проверява дали тяхната сума е просто число.\n;; Пример:\n;; >>> count-prime-sums '(1 2 3 4) 2\n;; 2 ; (1+2) и (3+4) са прости\n;; >>> count-prime-sums '(1 2 3 4 5 6) 3\n;; 1 ; Само (1+2+5) е просто",
      "zh": "(defun count-prime-sums (numbers k)\n;; 此函数计算从'n'个整数的列表中选择'k'个整数，使它们的和为质数的方法数。\n;; 它考虑列表中所有可能的'k'个整数的组合，并检查它们的和是否为质数。\n;; 例子:\n;; >>> count-prime-sums '(1 2 3 4) 2\n;; 2 ; (1+2) 和 (3+4) 是质数\n;; >>> count-prime-sums '(1 2 3 4 5 6) 3\n;; 1 ; 只有 (1+2+5) 是质数",
      "fr": "(defun count-prime-sums (numbers k)\n;; Cette fonction compte le nombre de façons de sélectionner 'k' entiers d'une liste de 'n' entiers de sorte que leur somme soit un nombre premier.\n;; Elle considère toutes les combinaisons possibles de 'k' entiers de la liste et vérifie si leur somme est un nombre premier.\n;; Exemple:\n;; >>> count-prime-sums '(1 2 3 4) 2\n;; 2 ; (1+2) et (3+4) sont premiers\n;; >>> count-prime-sums '(1 2 3 4 5 6) 3\n;; 1 ; Seul (1+2+5) est premier",
      "de": "(defun count-prime-sums (numbers k)\n;; Diese Funktion zählt die Anzahl der Möglichkeiten, 'k' ganze Zahlen aus einer Liste von 'n' ganzen Zahlen auszuwählen, sodass ihre Summe eine Primzahl ist.\n;; Sie berücksichtigt alle möglichen Kombinationen von 'k' ganzen Zahlen aus der Liste und überprüft, ob ihre Summe eine Primzahl ist.\n;; Beispiel:\n;; >>> count-prime-sums '(1 2 3 4) 2\n;; 2 ; (1+2) und (3+4) sind prim\n;; >>> count-prime-sums '(1 2 3 4 5 6) 3\n;; 1 ; Nur (1+2+5) ist prim",
      "ha": "(defun count-prime-sums (numbers k)\n;; Wannan aikin yana ƙirga yawan hanyoyin zaɓar 'k' lambobi daga jerin 'n' lambobi ta yadda jimlar su za ta zama lamba mai lamba.\n;; Yana la'akari da dukkan yiwuwar haɗuwa na 'k' lambobi daga jerin kuma yana duba idan jimlar su lamba ce mai lamba.\n;; Misali:\n;; >>> count-prime-sums '(1 2 3 4) 2\n;; 2 ; (1+2) da (3+4) lambobi ne masu lamba\n;; >>> count-prime-sums '(1 2 3 4 5 6) 3\n;; 1 ; Kawai (1+2+5) lamba ce mai lamba",
      "hi": "(defun count-prime-sums (numbers k)\n;; यह फ़ंक्शन 'n' पूर्णांकों की सूची से 'k' पूर्णांकों का चयन करने के तरीकों की संख्या गिनता है ताकि उनका योग एक अभाज्य संख्या हो।\n;; यह सूची से 'k' पूर्णांकों के सभी संभावित संयोजनों पर विचार करता है और जांचता है कि उनका योग अभाज्य है या नहीं।\n;; उदाहरण:\n;; >>> count-prime-sums '(1 2 3 4) 2\n;; 2 ; (1+2) और (3+4) अभाज्य हैं\n;; >>> count-prime-sums '(1 2 3 4 5 6) 3\n;; 1 ; केवल (1+2+5) अभाज्य है",
      "hu": "(defun count-prime-sums (numbers k)\n;; Ez a függvény megszámolja, hányféleképpen lehet kiválasztani 'k' egész számot egy 'n' egész számot tartalmazó listából úgy, hogy összegük prímszám legyen.\n;; Minden lehetséges 'k' egész szám kombinációját figyelembe veszi a listából, és ellenőrzi, hogy összegük prímszám-e.\n;; Példa:\n;; >>> count-prime-sums '(1 2 3 4) 2\n;; 2 ; (1+2) és (3+4) prímek\n;; >>> count-prime-sums '(1 2 3 4 5 6) 3\n;; 1 ; Csak (1+2+5) prím"
    },
    "prompt_bertscore": {
      "sq": "0.9984641898938382",
      "hy": "0.9923680248694965",
      "bn": "0.9984486967241175",
      "bg": "0.9927913062114818",
      "zh": "0.9802940785279097",
      "fr": "0.9942764655704797",
      "de": "0.9942764655704797",
      "ha": "0.9775140477149454",
      "hi": "0.9908538654748675",
      "hu": "0.9770528279701824"
    },
    "canonical_solution": "(count t (mapcar (lambda (comb) (is-prime (reduce '+ comb)))\n(sum-combinations numbers k))))\n(defun is-prime (n)\n(cond ((<= n 1) nil)\n((= n 2) t)\n(t (loop for i from 2 to (isqrt n) never (zerop (mod n i))))))\n\n(defun sum-combinations (lst k)\n(if (= k 0)\n'(())\n(loop for i from 0 below (length lst)\nnconc (mapcar (lambda (x) (cons (nth i lst) x))\n(sum-combinations (subseq lst (1+ i)) (1- k))))))",
    "instruction": {
      "en": "Write a Common Lisp function `(defun count-prime-sums (numbers k)` to solve the following problem:\nThis function counts the number of ways to select 'k' integers from a list of 'n' integers such that their sum is a prime number.\nIt considers all possible combinations of 'k' integers from the list and checks if their sum is prime.\nExample:\n>>> count-prime-sums '(1 2 3 4) 2\n2 ; (1+2) and (3+4) are prime\n>>> count-prime-sums '(1 2 3 4 5 6) 3\n1 ; Only (1+2+5) is prime",
      "sq": "Shkruani një funksion Common Lisp `(defun count-prime-sums (numbers k)` për të zgjidhur problemin e mëposhtëm:\nKy funksion numëron numrin e mënyrave për të zgjedhur 'k' numra të plotë nga një listë prej 'n' numrash të plotë të tillë që shuma e tyre të jetë një numër i thjeshtë.\nAi konsideron të gjitha kombinimet e mundshme të 'k' numrave të plotë nga lista dhe kontrollon nëse shuma e tyre është e thjeshtë.\nShembull:\n>>> count-prime-sums '(1 2 3 4) 2\n2 ; (1+2) dhe (3+4) janë të thjeshtë\n>>> count-prime-sums '(1 2 3 4 5 6) 3\n1 ; Vetëm (1+2+5) është i thjeshtë",
      "hy": "Գրեք Common Lisp ֆունկցիա `(defun count-prime-sums (numbers k)` հետևյալ խնդիրը լուծելու համար:\nԱյս ֆունկցիան հաշվում է 'k' ամբողջ թվերի ընտրության եղանակների քանակը 'n' ամբողջ թվերի ցուցակից այնպես, որ նրանց գումարը լինի պարզ թիվ:\nԱյն դիտարկում է ցուցակից 'k' ամբողջ թվերի բոլոր հնարավոր կոմբինացիաները և ստուգում, արդյոք նրանց գումարը պարզ է:\nՕրինակ:\n>>> count-prime-sums '(1 2 3 4) 2\n2 ; (1+2) և (3+4) պարզ են\n>>> count-prime-sums '(1 2 3 4 5 6) 3\n1 ; Միայն (1+2+5) պարզ է",
      "bn": "একটি Common Lisp ফাংশন `(defun count-prime-sums (numbers k)` লিখুন নিম্নলিখিত সমস্যার সমাধানের জন্য:\nএই ফাংশনটি 'n' পূর্ণসংখ্যার একটি তালিকা থেকে 'k' পূর্ণসংখ্যা বেছে নেওয়ার উপায়ের সংখ্যা গণনা করে যাতে তাদের যোগফল একটি মৌলিক সংখ্যা হয়।\nএটি তালিকা থেকে 'k' পূর্ণসংখ্যার সমস্ত সম্ভাব্য সংমিশ্রণ বিবেচনা করে এবং তাদের যোগফল মৌলিক কিনা তা পরীক্ষা করে।\nউদাহরণ:\n>>> count-prime-sums '(1 2 3 4) 2\n2 ; (1+2) এবং (3+4) মৌলিক\n>>> count-prime-sums '(1 2 3 4 5 6) 3\n1 ; শুধুমাত্র (1+2+5) মৌলিক",
      "bg": "Напишете функция на Common Lisp `(defun count-prime-sums (numbers k)` за решаване на следния проблем:\nТази функция брои броя на начините за избор на 'k' цели числа от списък с 'n' цели числа, така че тяхната сума да е просто число.\nТя разглежда всички възможни комбинации от 'k' цели числа от списъка и проверява дали тяхната сума е просто число.\nПример:\n>>> count-prime-sums '(1 2 3 4) 2\n2 ; (1+2) и (3+4) са прости\n>>> count-prime-sums '(1 2 3 4 5 6) 3\n1 ; Само (1+2+5) е просто",
      "zh": "编写一个 Common Lisp 函数 `(defun count-prime-sums (numbers k)` 来解决以下问题：\n该函数计算从'n'个整数的列表中选择'k'个整数，使其和为质数的方式数量。\n它考虑列表中所有可能的'k'个整数组合，并检查它们的和是否为质数。\n示例：\n>>> count-prime-sums '(1 2 3 4) 2\n2 ; (1+2) 和 (3+4) 是质数\n>>> count-prime-sums '(1 2 3 4 5 6) 3\n1 ; 只有 (1+2+5) 是质数",
      "fr": "Écrire une fonction Common Lisp `(defun count-prime-sums (numbers k)` pour résoudre le problème suivant :\nCette fonction compte le nombre de façons de sélectionner 'k' entiers à partir d'une liste de 'n' entiers de sorte que leur somme soit un nombre premier.\nElle considère toutes les combinaisons possibles de 'k' entiers de la liste et vérifie si leur somme est un nombre premier.\nExemple :\n>>> count-prime-sums '(1 2 3 4) 2\n2 ; (1+2) et (3+4) sont premiers\n>>> count-prime-sums '(1 2 3 4 5 6) 3\n1 ; Seul (1+2+5) est premier",
      "de": "Schreiben Sie eine Common Lisp-Funktion `(defun count-prime-sums (numbers k)`, um das folgende Problem zu lösen:\nDiese Funktion zählt die Anzahl der Möglichkeiten, 'k' ganze Zahlen aus einer Liste von 'n' ganzen Zahlen auszuwählen, sodass ihre Summe eine Primzahl ist.\nSie berücksichtigt alle möglichen Kombinationen von 'k' ganzen Zahlen aus der Liste und prüft, ob ihre Summe eine Primzahl ist.\nBeispiel:\n>>> count-prime-sums '(1 2 3 4) 2\n2 ; (1+2) und (3+4) sind prim\n>>> count-prime-sums '(1 2 3 4 5 6) 3\n1 ; Nur (1+2+5) ist prim",
      "ha": "Rubuta aikin Common Lisp `(defun count-prime-sums (numbers k)` don warware matsalar mai zuwa:\nWannan aikin yana ƙididdige yawan hanyoyin zaɓar lambobi 'k' daga jerin lambobi 'n' ta yadda jimlar su ta zama lamba mai firam.\nYana la'akari da dukkan yiwuwar haɗuwa na lambobi 'k' daga jerin kuma yana duba idan jimlarsu ta zama firam.\nMisali:\n>>> count-prime-sums '(1 2 3 4) 2\n2 ; (1+2) da (3+4) suna da firam\n>>> count-prime-sums '(1 2 3 4 5 6) 3\n1 ; Sai dai (1+2+5) ne mai firam",
      "hi": "कॉमन लिस्प फ़ंक्शन `(defun count-prime-sums (numbers k)` लिखें ताकि निम्नलिखित समस्या का समाधान किया जा सके:\nयह फ़ंक्शन 'n' पूर्णांकों की सूची से 'k' पूर्णांकों का चयन करने के तरीकों की संख्या गिनता है ताकि उनका योग एक अभाज्य संख्या हो।\nयह सूची से 'k' पूर्णांकों के सभी संभावित संयोजनों पर विचार करता है और जांचता है कि उनका योग अभाज्य है या नहीं।\nउदाहरण:\n>>> count-prime-sums '(1 2 3 4) 2\n2 ; (1+2) और (3+4) अभाज्य हैं\n>>> count-prime-sums '(1 2 3 4 5 6) 3\n1 ; केवल (1+2+5) अभाज्य है",
      "hu": "Írj egy Common Lisp függvényt `(defun count-prime-sums (numbers k)` a következő probléma megoldására:\nEz a függvény megszámolja, hányféleképpen lehet kiválasztani 'k' egész számot egy 'n' egész számot tartalmazó listából úgy, hogy összegük prímszám legyen.\nFigyelembe veszi az összes lehetséges 'k' egész szám kombinációját a listából, és ellenőrzi, hogy összegük prímszám-e.\nPélda:\n>>> count-prime-sums '(1 2 3 4) 2\n2 ; (1+2) és (3+4) prímek\n>>> count-prime-sums '(1 2 3 4 5 6) 3\n1 ; Csak (1+2+5) prím"
    },
    "instruction_bertscore": {
      "sq": "0.9983974500858105",
      "hy": "0.9983974500858105",
      "bn": "0.9976545724607401",
      "bg": "0.9877190808013749",
      "zh": "0.9792226662526076",
      "fr": "0.9945827536180355",
      "de": "0.9933170808300812",
      "ha": "0.9898392614885413",
      "hi": "0.9960625499567454",
      "hu": "0.9798598725149675"
    },
    "level": "hard",
    "test": "(defun test-count-prime-sums ()\n(assert (equal (count-prime-sums '(3 7 12 19) 3) 1))\n(assert (equal (count-prime-sums '(1 2 3 4) 2) 4))\n(assert (equal (count-prime-sums '(1 2 3 4 5 6) 3) 6))\n(assert (equal (count-prime-sums '(10 20 30 40) 2) 0))\n(assert (equal (count-prime-sums '(11 13 17 19 23 29) 3) 12))) \n\n(test-count-prime-sums)",
    "entry_point": "count-prime-sums",
    "signature": "(defun count-prime-sums (numbers k)",
    "docstring": {
      "en": "This function counts the number of ways to select 'k' integers from a list of 'n' integers such that their sum is a prime number.\nIt considers all possible combinations of 'k' integers from the list and checks if their sum is prime.\nExample:\n>>> count-prime-sums '(1 2 3 4) 2\n2 ; (1+2) and (3+4) are prime\n>>> count-prime-sums '(1 2 3 4 5 6) 3\n1 ; Only (1+2+5) is prime",
      "sq": "Kjo funksion numëron numrin e mënyrave për të zgjedhur 'k' numra të plotë nga një listë prej 'n' numrash të plotë në mënyrë që shuma e tyre të jetë një numër i thjeshtë.\nAi konsideron të gjitha kombinimet e mundshme të 'k' numrave të plotë nga lista dhe kontrollon nëse shuma e tyre është e thjeshtë.\nShembull:\n>>> count-prime-sums '(1 2 3 4) 2\n2 ; (1+2) dhe (3+4) janë të thjeshtë\n>>> count-prime-sums '(1 2 3 4 5 6) 3\n1 ; Vetëm (1+2+5) është i thjeshtë",
      "hy": "Այս ֆունկցիան հաշվում է, թե քանի եղանակով կարելի է ընտրել 'k' ամբողջ թվեր 'n' ամբողջ թվերի ցուցակից այնպես, որ դրանց գումարը լինի պարզ թիվ:\nԱյն դիտարկում է ցուցակից 'k' ամբողջ թվերի բոլոր հնարավոր համակցությունները և ստուգում, արդյոք դրանց գումարը պարզ է:\nՕրինակ:\n>>> count-prime-sums '(1 2 3 4) 2\n2 ; (1+2) և (3+4) պարզ են\n>>> count-prime-sums '(1 2 3 4 5 6) 3\n1 ; Միայն (1+2+5) պարզ է",
      "bn": "এই ফাংশনটি 'n' পূর্ণসংখ্যার একটি তালিকা থেকে 'k' পূর্ণসংখ্যা নির্বাচন করার উপায়গুলির সংখ্যা গণনা করে যাতে তাদের যোগফল একটি মৌলিক সংখ্যা হয়। এটি তালিকা থেকে 'k' পূর্ণসংখ্যার সমস্ত সম্ভাব্য সমন্বয় বিবেচনা করে এবং তাদের যোগফল মৌলিক কিনা তা পরীক্ষা করে।\n\nউদাহরণ:\n>>> count-prime-sums '(1 2 3 4) 2\n2 ; (1+2) এবং (3+4) মৌলিক\n>>> count-prime-sums '(1 2 3 4 5 6) 3\n1 ; শুধুমাত্র (1+2+5) মৌলিক",
      "bg": "Тази функция брои броя на начините за избиране на 'k' цели числа от списък с 'n' цели числа, така че тяхната сума да е просто число. Тя разглежда всички възможни комбинации от 'k' цели числа от списъка и проверява дали тяхната сума е просто число.\nПример:\n>>> count-prime-sums '(1 2 3 4) 2\n2 ; (1+2) и (3+4) са прости\n>>> count-prime-sums '(1 2 3 4 5 6) 3\n1 ; Само (1+2+5) е просто",
      "zh": "此函数计算从'n'个整数的列表中选择'k'个整数，使其和为质数的方式数量。\n它考虑列表中所有可能的'k'个整数组合，并检查它们的和是否为质数。\n示例：\n>>> count-prime-sums '(1 2 3 4) 2\n2 ; (1+2) 和 (3+4) 是质数\n>>> count-prime-sums '(1 2 3 4 5 6) 3\n1 ; 只有 (1+2+5) 是质数",
      "fr": "Cette fonction compte le nombre de façons de sélectionner 'k' entiers à partir d'une liste de 'n' entiers de telle sorte que leur somme soit un nombre premier.\nElle considère toutes les combinaisons possibles de 'k' entiers de la liste et vérifie si leur somme est un nombre premier.\nExemple :\n>>> count-prime-sums '(1 2 3 4) 2\n2 ; (1+2) et (3+4) sont premiers\n>>> count-prime-sums '(1 2 3 4 5 6) 3\n1 ; Seul (1+2+5) est premier",
      "de": "Diese Funktion zählt die Anzahl der Möglichkeiten, 'k' ganze Zahlen aus einer Liste von 'n' ganzen Zahlen auszuwählen, sodass ihre Summe eine Primzahl ist. Sie berücksichtigt alle möglichen Kombinationen von 'k' ganzen Zahlen aus der Liste und prüft, ob ihre Summe prim ist.\nBeispiel:\n>>> count-prime-sums '(1 2 3 4) 2\n2 ; (1+2) und (3+4) sind prim\n>>> count-prime-sums '(1 2 3 4 5 6) 3\n1 ; Nur (1+2+5) ist prim",
      "ha": "Wannan aikin yana ƙirga yawan hanyoyin zaɓar 'k' lambobi daga jerin lambobi 'n' ta yadda jimlar su ta zama lamba mai kyau.\nYana la'akari da dukkan yiwuwar haɗuwa na 'k' lambobi daga jerin kuma yana duba idan jimlar su lamba mai kyau ce.\nMisali:\n>>> count-prime-sums '(1 2 3 4) 2\n2 ; (1+2) da (3+4) lambobi masu kyau ne\n>>> count-prime-sums '(1 2 3 4 5 6) 3\n1 ; Kawai (1+2+5) lamba mai kyau ce",
      "hi": "यह फ़ंक्शन 'n' पूर्णांकों की सूची से 'k' पूर्णांकों का चयन करने के तरीकों की संख्या की गणना करता है ताकि उनका योग एक अभाज्य संख्या हो।\nयह सूची से 'k' पूर्णांकों के सभी संभावित संयोजनों पर विचार करता है और जांचता है कि उनका योग अभाज्य है या नहीं।\nउदाहरण:\n>>> count-prime-sums '(1 2 3 4) 2\n2 ; (1+2) और (3+4) अभाज्य हैं\n>>> count-prime-sums '(1 2 3 4 5 6) 3\n1 ; केवल (1+2+5) अभाज्य है",
      "hu": "Ez a függvény megszámolja, hányféleképpen lehet kiválasztani 'k' egész számot egy 'n' egész számot tartalmazó listából úgy, hogy összegük prímszám legyen. Figyelembe veszi az összes lehetséges 'k' egész szám kombinációját a listából, és ellenőrzi, hogy összegük prímszám-e.\nPélda:\n>>> count-prime-sums '(1 2 3 4) 2\n2 ; (1+2) és (3+4) prímszámok\n>>> count-prime-sums '(1 2 3 4 5 6) 3\n1 ; Csak (1+2+5) prímszám"
    },
    "docstring_bertscore": {
      "sq": "0.9982325868695515",
      "hy": "0.9937727389241752",
      "bn": "0.9990072453555876",
      "bg": "0.9915993252948915",
      "zh": "0.9759484430516285",
      "fr": "0.9934044781977366",
      "de": "0.9992503689419744",
      "ha": "0.9650793886013994",
      "hi": "0.9945622946887889",
      "hu": "0.9729056242445551"
    }
  },
  {
    "task_id": "Common Lisp/37",
    "prompt": {
      "en": "(defun calculate-table-tennis-scores (record)\n;; This function takes a string of table tennis match records (composed of 'W', 'L', and 'E') \n;; and calculates the scores under 11-point and 21-point systems.\n;; 'W' indicates a point won by the player, 'L' indicates a point won by the opponent, and 'E' marks the end of the record.\n;; The function returns two lists: the first list contains the scores under the 11-point system, \n;; and the second list contains the scores under the 21-point system.\n;; Example:\n;; >>> calculate-table-tennis-scores \"WWLLWE\"\n;; ((\"2:2\") (\"2:2\"))\n;; >>> calculate-table-tennis-scores \"WWWWWWWWWWWWLWE\"\n;; ((\"11:0\" \"1:1\") (\"12:1\"))",
      "sq": "(defun calculate-table-tennis-scores (record)\n;; Kjo funksion merr një varg të regjistrimeve të ndeshjeve të pingpongut (të përbëra nga 'W', 'L', dhe 'E') \n;; dhe llogarit pikët sipas sistemeve me 11 pikë dhe 21 pikë.\n;; 'W' tregon një pikë të fituar nga lojtari, 'L' tregon një pikë të fituar nga kundërshtari, dhe 'E' shënon fundin e regjistrimit.\n;; Funksioni kthen dy lista: lista e parë përmban pikët sipas sistemit me 11 pikë, \n;; dhe lista e dytë përmban pikët sipas sistemit me 21 pikë.\n;; Shembull:\n;; >>> calculate-table-tennis-scores \"WWLLWE\"\n;; ((\"2:2\") (\"2:2\"))\n;; >>> calculate-table-tennis-scores \"WWWWWWWWWWWWLWE\"\n;; ((\"11:0\" \"1:1\") (\"12:1\"))",
      "hy": "(defun calculate-table-tennis-scores (record)\n;; Այս ֆունկցիան ընդունում է սեղանի թենիսի խաղերի գրառումների տող (կազմված 'W', 'L' և 'E') \n;; և հաշվարկում է միավորները 11-միավորային և 21-միավորային համակարգերով:\n;; 'W' նշում է խաղացողի հաղթած միավորը, 'L' նշում է մրցակցի հաղթած միավորը, իսկ 'E' նշում է գրառման ավարտը:\n;; Ֆունկցիան վերադարձնում է երկու ցուցակներ. առաջին ցուցակը պարունակում է միավորները 11-միավորային համակարգով, \n;; իսկ երկրորդ ցուցակը պարունակում է միավորները 21-միավորային համակարգով:\n;; Օրինակ:\n;; >>> calculate-table-tennis-scores \"WWLLWE\"\n;; ((\"2:2\") (\"2:2\"))\n;; >>> calculate-table-tennis-scores \"WWWWWWWWWWWWLWE\"\n;; ((\"11:0\" \"1:1\") (\"12:1\"))",
      "bn": "(defun calculate-table-tennis-scores (record)\n;; এই ফাংশনটি টেবিল টেনিস ম্যাচের রেকর্ডের একটি স্ট্রিং গ্রহণ করে (যা 'W', 'L', এবং 'E' নিয়ে গঠিত)\n;; এবং ১১-পয়েন্ট এবং ২১-পয়েন্ট সিস্টেমের অধীনে স্কোর গণনা করে।\n;; 'W' নির্দেশ করে যে খেলোয়াড় একটি পয়েন্ট জিতেছে, 'L' নির্দেশ করে যে প্রতিপক্ষ একটি পয়েন্ট জিতেছে, এবং 'E' রেকর্ডের শেষ নির্দেশ করে।\n;; ফাংশনটি দুটি তালিকা প্রদান করে: প্রথম তালিকায় ১১-পয়েন্ট সিস্টেমের অধীনে স্কোর থাকে,\n;; এবং দ্বিতীয় তালিকায় ২১-পয়েন্ট সিস্টেমের অধীনে স্কোর থাকে।\n;; উদাহরণ:\n;; >>> calculate-table-tennis-scores \"WWLLWE\"\n;; ((\"2:2\") (\"2:2\"))\n;; >>> calculate-table-tennis-scores \"WWWWWWWWWWWWLWE\"\n;; ((\"11:0\" \"1:1\") (\"12:1\"))",
      "bg": "(defun calculate-table-tennis-scores (record)\n;; Тази функция приема низ от записи на мачове по тенис на маса (съставени от 'W', 'L' и 'E') \n;; и изчислява резултатите по системите за 11 точки и 21 точки.\n;; 'W' означава точка, спечелена от играча, 'L' означава точка, спечелена от противника, а 'E' маркира края на записа.\n;; Функцията връща два списъка: първият списък съдържа резултатите по системата за 11 точки, \n;; а вторият списък съдържа резултатите по системата за 21 точки.\n;; Пример:\n;; >>> calculate-table-tennis-scores \"WWLLWE\"\n;; ((\"2:2\") (\"2:2\"))\n;; >>> calculate-table-tennis-scores \"WWWWWWWWWWWWLWE\"\n;; ((\"11:0\" \"1:1\") (\"12:1\"))",
      "zh": "(defun calculate-table-tennis-scores (record)\n;; 此函数接受一个乒乓球比赛记录的字符串（由 'W', 'L', 和 'E' 组成）\n;; 并计算在11分制和21分制下的分数。\n;; 'W' 表示玩家赢得的分数，'L' 表示对手赢得的分数，'E' 标记记录的结束。\n;; 函数返回两个列表：第一个列表包含11分制下的分数，\n;; 第二个列表包含21分制下的分数。\n;; 例子:\n;; >>> calculate-table-tennis-scores \"WWLLWE\"\n;; ((\"2:2\") (\"2:2\"))\n;; >>> calculate-table-tennis-scores \"WWWWWWWWWWWWLWE\"\n;; ((\"11:0\" \"1:1\") (\"12:1\"))",
      "fr": "(defun calculate-table-tennis-scores (record)\n;; Cette fonction prend une chaîne de caractères des enregistrements de matchs de tennis de table (composée de 'W', 'L' et 'E') \n;; et calcule les scores selon les systèmes de 11 points et de 21 points.\n;; 'W' indique un point gagné par le joueur, 'L' indique un point gagné par l'adversaire, et 'E' marque la fin de l'enregistrement.\n;; La fonction renvoie deux listes : la première liste contient les scores selon le système de 11 points, \n;; et la deuxième liste contient les scores selon le système de 21 points.\n;; Exemple :\n;; >>> calculate-table-tennis-scores \"WWLLWE\"\n;; ((\"2:2\") (\"2:2\"))\n;; >>> calculate-table-tennis-scores \"WWWWWWWWWWWWLWE\"\n;; ((\"11:0\" \"1:1\") (\"12:1\"))",
      "de": "(defun calculate-table-tennis-scores (record)\n;; Diese Funktion nimmt einen String von Tischtennis-Matchaufzeichnungen (bestehend aus 'W', 'L' und 'E') \n;; und berechnet die Punktzahlen nach dem 11-Punkte- und 21-Punkte-System.\n;; 'W' zeigt einen vom Spieler gewonnenen Punkt an, 'L' zeigt einen vom Gegner gewonnenen Punkt an, und 'E' markiert das Ende der Aufzeichnung.\n;; Die Funktion gibt zwei Listen zurück: die erste Liste enthält die Punktzahlen nach dem 11-Punkte-System, \n;; und die zweite Liste enthält die Punktzahlen nach dem 21-Punkte-System.\n;; Beispiel:\n;; >>> calculate-table-tennis-scores \"WWLLWE\"\n;; ((\"2:2\") (\"2:2\"))\n;; >>> calculate-table-tennis-scores \"WWWWWWWWWWWWLWE\"\n;; ((\"11:0\" \"1:1\") (\"12:1\"))",
      "ha": "(defun calculate-table-tennis-scores (record)\n;; Wannan aiki yana ɗaukar wani rubutu na rikodin wasannin tebur na tennis (wanda aka haɗa da 'W', 'L', da 'E') \n;; kuma yana ƙididdige maki a ƙarƙashin tsarin maki na 11-point da 21-point.\n;; 'W' yana nufin maki da ɗan wasa ya ci, 'L' yana nufin maki da abokin hamayya ya ci, kuma 'E' yana nuna ƙarshen rikodin.\n;; Aikin yana dawo da jerin biyu: jerin farko yana ɗauke da maki a ƙarƙashin tsarin maki na 11-point, \n;; kuma jerin na biyu yana ɗauke da maki a ƙarƙashin tsarin maki na 21-point.\n;; Misali:\n;; >>> calculate-table-tennis-scores \"WWLLWE\"\n;; ((\"2:2\") (\"2:2\"))\n;; >>> calculate-table-tennis-scores \"WWWWWWWWWWWWLWE\"\n;; ((\"11:0\" \"1:1\") (\"12:1\"))",
      "hi": "(defun calculate-table-tennis-scores (record)\n;; यह फ़ंक्शन टेबल टेनिस मैच रिकॉर्ड की एक स्ट्रिंग लेता है (जो 'W', 'L', और 'E' से बनी होती है)\n;; और 11-बिंदु और 21-बिंदु प्रणालियों के तहत स्कोर की गणना करता है।\n;; 'W' खिलाड़ी द्वारा जीता गया एक बिंदु दर्शाता है, 'L' प्रतिद्वंद्वी द्वारा जीता गया एक बिंदु दर्शाता है, और 'E' रिकॉर्ड के अंत को चिह्नित करता है।\n;; फ़ंक्शन दो सूचियाँ लौटाता है: पहली सूची 11-बिंदु प्रणाली के तहत स्कोर को समाहित करती है,\n;; और दूसरी सूची 21-बिंदु प्रणाली के तहत स्कोर को समाहित करती है।\n;; उदाहरण:\n;; >>> calculate-table-tennis-scores \"WWLLWE\"\n;; ((\"2:2\") (\"2:2\"))\n;; >>> calculate-table-tennis-scores \"WWWWWWWWWWWWLWE\"\n;; ((\"11:0\" \"1:1\") (\"12:1\"))",
      "hu": "(defun calculate-table-tennis-scores (record)\n;; Ez a függvény egy asztalitenisz mérkőzés feljegyzéseit tartalmazó karakterláncot vesz (amely 'W', 'L' és 'E' karakterekből áll), \n;; és kiszámítja a pontszámokat a 11 pontos és a 21 pontos rendszerek szerint.\n;; A 'W' azt jelzi, hogy a játékos nyert egy pontot, az 'L' azt jelzi, hogy az ellenfél nyert egy pontot, és az 'E' jelzi a feljegyzés végét.\n;; A függvény két listát ad vissza: az első lista a 11 pontos rendszer szerinti pontszámokat tartalmazza, \n;; a második lista pedig a 21 pontos rendszer szerinti pontszámokat.\n;; Példa:\n;; >>> calculate-table-tennis-scores \"WWLLWE\"\n;; ((\"2:2\") (\"2:2\"))\n;; >>> calculate-table-tennis-scores \"WWWWWWWWWWWWLWE\"\n;; ((\"11:0\" \"1:1\") (\"12:1\"))"
    },
    "prompt_bertscore": {
      "sq": "0.9818886832268579",
      "hy": "0.9871325252861789",
      "bn": "0.9822267521353792",
      "bg": "0.9818350530239784",
      "zh": "0.978211836243521",
      "fr": "0.984195179211435",
      "de": "0.9818886832268579",
      "ha": "0.9885890818703077",
      "hi": "0.9926341895800832",
      "hu": "0.963471475666922"
    },
    "canonical_solution": "(let ((scores-11 '()) (scores-21 '()) (score-11 (cons 0 0)) (score-21 (cons 0 0)))\n(loop for char across record do\n(cond ((char= char #\\W) (incf (car score-11)) (incf (car score-21)))\n((char= char #\\L) (incf (cdr score-11)) (incf (cdr score-21)))\n((char= char #\\E)\n(progn\n(push (format nil \"~A:~A\" (car score-11) (cdr score-11)) scores-11)\n(push (format nil \"~A:~A\" (car score-21) (cdr score-21)) scores-21)\n(return))))\n(when (or (and (>= (car score-11) 11) (>= (abs (- (car score-11) (cdr score-11))) 2))\n(and (>= (cdr score-11) 11) (>= (abs (- (car score-11) (cdr score-11))) 2)))\n(push (format nil \"~A:~A\" (car score-11) (cdr score-11)) scores-11)\n(setf score-11 (cons 0 0)))\n(when (or (and (>= (car score-21) 21) (>= (abs (- (car score-21) (cdr score-21))) 2))\n(and (>= (cdr score-21) 21) (>= (abs (- (car score-21) (cdr score-21))) 2)))\n(push (format nil \"~A:~A\" (car score-21) (cdr score-21)) scores-21)\n(setf score-21 (cons 0 0))))\n(list (reverse scores-11) (reverse scores-21))))",
    "instruction": {
      "en": "Write a Common Lisp function `(defun calculate-table-tennis-scores (record)` to solve the following problem:\nThis function takes a string of table tennis match records (composed of 'W', 'L', and 'E') \nand calculates the scores under 11-point and 21-point systems.\n'W' indicates a point won by the player, 'L' indicates a point won by the opponent, and 'E' marks the end of the record.\nThe function returns two lists: the first list contains the scores under the 11-point system, \nand the second list contains the scores under the 21-point system.\nExample:\n>>> calculate-table-tennis-scores \"WWLLWE\"\n((\"2:2\") (\"2:2\"))\n>>> calculate-table-tennis-scores \"WWWWWWWWWWWWLWE\"\n((\"11:0\" \"1:1\") (\"12:1\"))",
      "sq": "Shkruani një funksion Common Lisp `(defun calculate-table-tennis-scores (record)` për të zgjidhur problemin e mëposhtëm:\nKy funksion merr një varg të regjistrimeve të ndeshjeve të pingpongut (të përbërë nga 'W', 'L', dhe 'E') \ndhe llogarit pikët sipas sistemeve me 11 pikë dhe 21 pikë.\n'W' tregon një pikë të fituar nga lojtari, 'L' tregon një pikë të fituar nga kundërshtari, dhe 'E' shënon fundin e regjistrimit.\nFunksioni kthen dy lista: lista e parë përmban pikët sipas sistemit me 11 pikë, \ndhe lista e dytë përmban pikët sipas sistemit me 21 pikë.\nShembull:\n>>> calculate-table-tennis-scores \"WWLLWE\"\n((\"2:2\") (\"2:2\"))\n>>> calculate-table-tennis-scores \"WWWWWWWWWWWWLWE\"\n((\"11:0\" \"1:1\") (\"12:1\"))",
      "hy": "Գրեք Common Lisp ֆունկցիա `(defun calculate-table-tennis-scores (record)` հետևյալ խնդիրը լուծելու համար:\nԱյս ֆունկցիան ընդունում է սեղանի թենիսի խաղերի գրառումների տող (կազմված 'W', 'L' և 'E'-ից) \nև հաշվարկում է միավորները 11-միավորային և 21-միավորային համակարգերով:\n'W' նշում է խաղացողի հաղթած միավորը, 'L' նշում է մրցակցի հաղթած միավորը, իսկ 'E' նշում է գրառման ավարտը:\nՖունկցիան վերադարձնում է երկու ցուցակներ. առաջին ցուցակը պարունակում է 11-միավորային համակարգով միավորները, \nիսկ երկրորդ ցուցակը պարունակում է 21-միավորային համակարգով միավորները:\nՕրինակ:\n>>> calculate-table-tennis-scores \"WWLLWE\"\n((\"2:2\") (\"2:2\"))\n>>> calculate-table-tennis-scores \"WWWWWWWWWWWWLWE\"\n((\"11:0\" \"1:1\") (\"12:1\"))",
      "bn": "একটি Common Lisp ফাংশন `(defun calculate-table-tennis-scores (record)` লিখুন নিম্নলিখিত সমস্যার সমাধানের জন্য:\nএই ফাংশনটি টেবিল টেনিস ম্যাচের রেকর্ডের একটি স্ট্রিং গ্রহণ করে (যা 'W', 'L', এবং 'E' নিয়ে গঠিত) \nএবং ১১-পয়েন্ট এবং ২১-পয়েন্ট সিস্টেমের অধীনে স্কোরগুলি গণনা করে।\n'W' নির্দেশ করে যে খেলোয়াড় একটি পয়েন্ট জিতেছে, 'L' নির্দেশ করে যে প্রতিপক্ষ একটি পয়েন্ট জিতেছে, এবং 'E' রেকর্ডের শেষ নির্দেশ করে।\nফাংশনটি দুটি তালিকা ফেরত দেয়: প্রথম তালিকায় ১১-পয়েন্ট সিস্টেমের অধীনে স্কোরগুলি থাকে, \nএবং দ্বিতীয় তালিকায় ২১-পয়েন্ট সিস্টেমের অধীনে স্কোরগুলি থাকে।\nউদাহরণ:\n>>> calculate-table-tennis-scores \"WWLLWE\"\n((\"2:2\") (\"2:2\"))\n>>> calculate-table-tennis-scores \"WWWWWWWWWWWWLWE\"\n((\"11:0\" \"1:1\") (\"12:1\"))",
      "bg": "Напишете функция на Common Lisp `(defun calculate-table-tennis-scores (record)` за решаване на следния проблем:\nТази функция приема низ от записи на мачове по тенис на маса (съставен от 'W', 'L' и 'E') \nи изчислява резултатите по системите с 11 точки и 21 точки.\n'W' означава точка, спечелена от играча, 'L' означава точка, спечелена от противника, а 'E' отбелязва края на записа.\nФункцията връща два списъка: първият списък съдържа резултатите по системата с 11 точки, \nа вторият списък съдържа резултатите по системата с 21 точки.\nПример:\n>>> calculate-table-tennis-scores \"WWLLWE\"\n((\"2:2\") (\"2:2\"))\n>>> calculate-table-tennis-scores \"WWWWWWWWWWWWLWE\"\n((\"11:0\" \"1:1\") (\"12:1\"))",
      "zh": "编写一个 Common Lisp 函数 `(defun calculate-table-tennis-scores (record)` 来解决以下问题：\n此函数接收一个乒乓球比赛记录的字符串（由 'W'、'L' 和 'E' 组成），\n并计算在 11 分制和 21 分制下的得分。\n'W' 表示玩家赢得的分数，'L' 表示对手赢得的分数，'E' 表示记录的结束。\n函数返回两个列表：第一个列表包含 11 分制下的得分，\n第二个列表包含 21 分制下的得分。\n示例:\n>>> calculate-table-tennis-scores \"WWLLWE\"\n((\"2:2\") (\"2:2\"))\n>>> calculate-table-tennis-scores \"WWWWWWWWWWWWLWE\"\n((\"11:0\" \"1:1\") (\"12:1\"))",
      "fr": "Écrire une fonction Common Lisp `(defun calculate-table-tennis-scores (record)` pour résoudre le problème suivant :\nCette fonction prend une chaîne de caractères des enregistrements de matchs de tennis de table (composée de 'W', 'L' et 'E') \net calcule les scores selon les systèmes de 11 points et de 21 points.\n'W' indique un point gagné par le joueur, 'L' indique un point gagné par l'adversaire, et 'E' marque la fin de l'enregistrement.\nLa fonction renvoie deux listes : la première liste contient les scores selon le système de 11 points, \net la deuxième liste contient les scores selon le système de 21 points.\nExemple :\n>>> calculate-table-tennis-scores \"WWLLWE\"\n((\"2:2\") (\"2:2\"))\n>>> calculate-table-tennis-scores \"WWWWWWWWWWWWLWE\"\n((\"11:0\" \"1:1\") (\"12:1\"))",
      "de": "Schreiben Sie eine Common Lisp-Funktion `(defun calculate-table-tennis-scores (record)` um das folgende Problem zu lösen:\nDiese Funktion nimmt einen String von Tischtennis-Spielaufzeichnungen (bestehend aus 'W', 'L' und 'E') \nund berechnet die Punktzahlen nach dem 11-Punkte- und 21-Punkte-System.\n'W' zeigt einen vom Spieler gewonnenen Punkt an, 'L' zeigt einen vom Gegner gewonnenen Punkt an, und 'E' markiert das Ende der Aufzeichnung.\nDie Funktion gibt zwei Listen zurück: Die erste Liste enthält die Punktzahlen nach dem 11-Punkte-System, \nund die zweite Liste enthält die Punktzahlen nach dem 21-Punkte-System.\nBeispiel:\n>>> calculate-table-tennis-scores \"WWLLWE\"\n((\"2:2\") (\"2:2\"))\n>>> calculate-table-tennis-scores \"WWWWWWWWWWWWLWE\"\n((\"11:0\" \"1:1\") (\"12:1\"))",
      "ha": "Rubuta aikin Common Lisp `(defun calculate-table-tennis-scores (record)` don warware matsalar mai zuwa:\nWannan aikin yana ɗaukar kirtani na rikodin wasannin tebur na tennis (wanda aka haɗa da 'W', 'L', da 'E') \nkuma yana ƙididdige maki a ƙarƙashin tsarin maki na maki 11 da maki 21.\n'W' yana nuna maki da ɗan wasa ya ci, 'L' yana nuna maki da abokin hamayya ya ci, kuma 'E' yana nuna ƙarshen rikodin.\nAikin yana dawowa da jerin biyu: jerin na farko yana ɗauke da maki a ƙarƙashin tsarin maki na 11, \nkuma jerin na biyu yana ɗauke da maki a ƙarƙashin tsarin maki na 21.\nMisali:\n>>> calculate-table-tennis-scores \"WWLLWE\"\n((\"2:2\") (\"2:2\"))\n>>> calculate-table-tennis-scores \"WWWWWWWWWWWWLWE\"\n((\"11:0\" \"1:1\") (\"12:1\"))",
      "hi": "एक Common Lisp फ़ंक्शन `(defun calculate-table-tennis-scores (record)` लिखें ताकि निम्नलिखित समस्या का समाधान किया जा सके:\nयह फ़ंक्शन टेबल टेनिस मैच रिकॉर्ड की एक स्ट्रिंग लेता है (जो 'W', 'L', और 'E' से बना होता है) \nऔर 11-बिंदु और 21-बिंदु प्रणालियों के अंतर्गत स्कोर की गणना करता है।\n'W' खिलाड़ी द्वारा जीता गया एक अंक इंगित करता है, 'L' प्रतिद्वंद्वी द्वारा जीता गया एक अंक इंगित करता है, और 'E' रिकॉर्ड के अंत को चिह्नित करता है।\nफ़ंक्शन दो सूचियाँ लौटाता है: पहली सूची 11-बिंदु प्रणाली के अंतर्गत स्कोर को शामिल करती है, \nऔर दूसरी सूची 21-बिंदु प्रणाली के अंतर्गत स्कोर को शामिल करती है।\nउदाहरण:\n>>> calculate-table-tennis-scores \"WWLLWE\"\n((\"2:2\") (\"2:2\"))\n>>> calculate-table-tennis-scores \"WWWWWWWWWWWWLWE\"\n((\"11:0\" \"1:1\") (\"12:1\"))",
      "hu": "Írj egy Common Lisp függvényt `(defun calculate-table-tennis-scores (record)` a következő probléma megoldására:\nEz a függvény egy asztalitenisz mérkőzés eredményeit tartalmazó karakterláncot vesz át (amely 'W', 'L' és 'E' karakterekből áll), \nés kiszámítja a pontszámokat a 11 pontos és a 21 pontos rendszerek szerint.\nA 'W' azt jelzi, hogy a játékos nyert egy pontot, az 'L' azt jelzi, hogy az ellenfél nyert egy pontot, és az 'E' jelzi a rekord végét.\nA függvény két listát ad vissza: az első lista a 11 pontos rendszer szerinti pontszámokat tartalmazza, \na második lista pedig a 21 pontos rendszer szerinti pontszámokat tartalmazza.\nPélda:\n>>> calculate-table-tennis-scores \"WWLLWE\"\n((\"2:2\") (\"2:2\"))\n>>> calculate-table-tennis-scores \"WWWWWWWWWWWWLWE\"\n((\"11:0\" \"1:1\") (\"12:1\"))"
    },
    "instruction_bertscore": {
      "sq": "0.9840561379447106",
      "hy": "0.985055447391697",
      "bn": "0.9892882608115505",
      "bg": "0.9889271507788291",
      "zh": "0.8771582326312596",
      "fr": "0.9840561379447106",
      "de": "0.9811191891307287",
      "ha": "0.9833986713834851",
      "hi": "0.9927136417324972",
      "hu": "0.9594418611268672"
    },
    "level": "hard",
    "test": "(defun test-calculate-table-tennis-scores ()\n(assert (equal (calculate-table-tennis-scores \"WWLLWE\") '((\"3:2\") (\"3:2\"))))\n(assert (equal (calculate-table-tennis-scores \"WWWWWWWWWWWWLWE\") '((\"11:0\" \"2:1\") (\"13:1\"))))\n(assert (equal (calculate-table-tennis-scores \"WLWLWLWLWLE\") '((\"5:5\") (\"5:5\"))))\n(assert (equal (calculate-table-tennis-scores \"LWE\") '((\"1:1\") (\"1:1\")))))\n\n(test-calculate-table-tennis-scores)",
    "entry_point": "calculate-table-tennis-scores",
    "signature": "(defun calculate-table-tennis-scores (record)",
    "docstring": {
      "en": "This function takes a string of table tennis match records (composed of 'W', 'L', and 'E') \nand calculates the scores under 11-point and 21-point systems.\n'W' indicates a point won by the player, 'L' indicates a point won by the opponent, and 'E' marks the end of the record.\nThe function returns two lists: the first list contains the scores under the 11-point system, \nand the second list contains the scores under the 21-point system.\nExample:\n>>> calculate-table-tennis-scores \"WWLLWE\"\n((\"2:2\") (\"2:2\"))\n>>> calculate-table-tennis-scores \"WWWWWWWWWWWWLWE\"\n((\"11:0\" \"1:1\") (\"12:1\"))",
      "sq": "Kjo funksion merr një varg të regjistrimeve të ndeshjeve të pingpongut (të përbëra nga 'W', 'L', dhe 'E') dhe llogarit pikët sipas sistemeve me 11 pikë dhe 21 pikë. 'W' tregon një pikë të fituar nga lojtari, 'L' tregon një pikë të fituar nga kundërshtari, dhe 'E' shënon fundin e regjistrimit. Funksioni kthen dy lista: lista e parë përmban pikët sipas sistemit me 11 pikë, dhe lista e dytë përmban pikët sipas sistemit me 21 pikë. Shembull:\n>>> calculate-table-tennis-scores \"WWLLWE\"\n((\"2:2\") (\"2:2\"))\n>>> calculate-table-tennis-scores \"WWWWWWWWWWWWLWE\"\n((\"11:0\" \"1:1\") (\"12:1\"))",
      "hy": "Այս ֆունկցիան ընդունում է սեղանի թենիսի խաղերի գրառումների տող (կազմված 'W', 'L' և 'E' տառերից) և հաշվարկում է միավորները 11 միավորի և 21 միավորի համակարգերով: 'W' նշում է խաղացողի կողմից հաղթած միավոր, 'L' նշում է մրցակցի կողմից հաղթած միավոր, իսկ 'E' նշում է գրառման ավարտը: Ֆունկցիան վերադարձնում է երկու ցուցակներ. առաջին ցուցակը պարունակում է միավորները 11 միավորի համակարգով, իսկ երկրորդ ցուցակը պարունակում է միավորները 21 միավորի համակարգով:\nՕրինակ:\n>>> calculate-table-tennis-scores \"WWLLWE\"\n((\"2:2\") (\"2:2\"))\n>>> calculate-table-tennis-scores \"WWWWWWWWWWWWLWE\"\n((\"11:0\" \"1:1\") (\"12:1\"))",
      "bn": "এই ফাংশনটি টেবিল টেনিস ম্যাচের রেকর্ডের একটি স্ট্রিং (যা 'W', 'L', এবং 'E' দ্বারা গঠিত) গ্রহণ করে এবং ১১-পয়েন্ট এবং ২১-পয়েন্ট সিস্টেমের অধীনে স্কোরগুলি গণনা করে। 'W' নির্দেশ করে যে খেলোয়াড় একটি পয়েন্ট জিতেছে, 'L' নির্দেশ করে যে প্রতিপক্ষ একটি পয়েন্ট জিতেছে, এবং 'E' রেকর্ডের শেষ চিহ্নিত করে। ফাংশনটি দুটি তালিকা প্রদান করে: প্রথম তালিকায় ১১-পয়েন্ট সিস্টেমের অধীনে স্কোরগুলি রয়েছে এবং দ্বিতীয় তালিকায় ২১-পয়েন্ট সিস্টেমের অধীনে স্কোরগুলি রয়েছে।\n\nউদাহরণ:\n>>> calculate-table-tennis-scores \"WWLLWE\"\n((\"2:2\") (\"2:2\"))\n>>> calculate-table-tennis-scores \"WWWWWWWWWWWWLWE\"\n((\"11:0\" \"1:1\") (\"12:1\"))",
      "bg": "Тази функция приема низ от записи на мачове по тенис на маса (съставен от 'W', 'L' и 'E') и изчислява резултатите по системите с 11 точки и 21 точки. 'W' означава точка, спечелена от играча, 'L' означава точка, спечелена от противника, а 'E' отбелязва края на записа. Функцията връща два списъка: първият списък съдържа резултатите по системата с 11 точки, а вторият списък съдържа резултатите по системата с 21 точки.\nПример:\n>>> calculate-table-tennis-scores \"WWLLWE\"\n((\"2:2\") (\"2:2\"))\n>>> calculate-table-tennis-scores \"WWWWWWWWWWWWLWE\"\n((\"11:0\" \"1:1\") (\"12:1\"))",
      "zh": "此函数接收一个由乒乓球比赛记录（由 'W'、'L' 和 'E' 组成）的字符串，并计算在11分制和21分制下的得分。  \n'W' 表示玩家赢得的分数，'L' 表示对手赢得的分数，'E' 标志着记录的结束。  \n函数返回两个列表：第一个列表包含11分制下的得分，第二个列表包含21分制下的得分。  \n示例：  \n>>> calculate-table-tennis-scores \"WWLLWE\"  \n((\"2:2\") (\"2:2\"))  \n>>> calculate-table-tennis-scores \"WWWWWWWWWWWWLWE\"  \n((\"11:0\" \"1:1\") (\"12:1\"))  ",
      "fr": "Cette fonction prend une chaîne d'enregistrements de matchs de tennis de table (composée de 'W', 'L' et 'E') et calcule les scores selon les systèmes de 11 points et de 21 points. 'W' indique un point gagné par le joueur, 'L' indique un point gagné par l'adversaire, et 'E' marque la fin de l'enregistrement. La fonction renvoie deux listes : la première liste contient les scores selon le système de 11 points, et la deuxième liste contient les scores selon le système de 21 points.\nExemple :\n>>> calculate-table-tennis-scores \"WWLLWE\"\n((\"2:2\") (\"2:2\"))\n>>> calculate-table-tennis-scores \"WWWWWWWWWWWWLWE\"\n((\"11:0\" \"1:1\") (\"12:1\"))",
      "de": "Diese Funktion nimmt einen String von Tischtennis-Spielaufzeichnungen (bestehend aus 'W', 'L' und 'E') und berechnet die Punktzahlen nach dem 11-Punkte- und 21-Punkte-System. 'W' zeigt einen Punktgewinn des Spielers an, 'L' zeigt einen Punktgewinn des Gegners an, und 'E' markiert das Ende der Aufzeichnung. Die Funktion gibt zwei Listen zurück: Die erste Liste enthält die Punktzahlen nach dem 11-Punkte-System, und die zweite Liste enthält die Punktzahlen nach dem 21-Punkte-System.\nBeispiel:\n>>> calculate-table-tennis-scores \"WWLLWE\"\n((\"2:2\") (\"2:2\"))\n>>> calculate-table-tennis-scores \"WWWWWWWWWWWWLWE\"\n((\"11:0\" \"1:1\") (\"12:1\"))",
      "ha": "Wannan aikin yana daukar wani igiyar rubutu na rikodin wasan kwallon tebur (wanda aka hada da 'W', 'L', da 'E') kuma yana lissafa maki a karkashin tsarin maki na 11 da 21. 'W' yana nuna maki da dan wasan ya ci, 'L' yana nuna maki da abokin hamayya ya ci, kuma 'E' yana nuna karshen rikodin. Aikin yana dawowa da jerin biyu: jerin farko yana dauke da maki a karkashin tsarin maki na 11, kuma jerin na biyu yana dauke da maki a karkashin tsarin maki na 21. Misali:\n>>> calculate-table-tennis-scores \"WWLLWE\"\n((\"2:2\") (\"2:2\"))\n>>> calculate-table-tennis-scores \"WWWWWWWWWWWWLWE\"\n((\"11:0\" \"1:1\") (\"12:1\"))",
      "hi": "यह फ़ंक्शन टेबल टेनिस मैच रिकॉर्ड की एक स्ट्रिंग लेता है (जो 'W', 'L', और 'E' से बनी होती है) और 11-पॉइंट और 21-पॉइंट सिस्टम के अंतर्गत स्कोर की गणना करता है। 'W' खिलाड़ी द्वारा जीता गया एक पॉइंट दर्शाता है, 'L' प्रतिद्वंद्वी द्वारा जीता गया एक पॉइंट दर्शाता है, और 'E' रिकॉर्ड के अंत को चिह्नित करता है। फ़ंक्शन दो सूचियाँ लौटाता है: पहली सूची 11-पॉइंट सिस्टम के अंतर्गत स्कोर को शामिल करती है, और दूसरी सूची 21-पॉइंट सिस्टम के अंतर्गत स्कोर को शामिल करती है।\nउदाहरण:\n>>> calculate-table-tennis-scores \"WWLLWE\"\n((\"2:2\") (\"2:2\"))\n>>> calculate-table-tennis-scores \"WWWWWWWWWWWWLWE\"\n((\"11:0\" \"1:1\") (\"12:1\"))",
      "hu": "Ez a függvény egy asztalitenisz mérkőzésrekordokból álló karakterláncot vesz (amely 'W', 'L' és 'E' karakterekből áll), és kiszámítja a pontszámokat a 11 pontos és a 21 pontos rendszerek szerint. A 'W' jelzi a játékos által nyert pontot, az 'L' jelzi az ellenfél által nyert pontot, és az 'E' jelzi a rekord végét. A függvény két listát ad vissza: az első lista a 11 pontos rendszer szerinti pontszámokat tartalmazza, a második lista pedig a 21 pontos rendszer szerinti pontszámokat tartalmazza.\n\nPélda:\n>>> calculate-table-tennis-scores \"WWLLWE\"\n((\"2:2\") (\"2:2\"))\n>>> calculate-table-tennis-scores \"WWWWWWWWWWWWLWE\"\n((\"11:0\" \"1:1\") (\"12:1\"))"
    },
    "docstring_bertscore": {
      "sq": "0.9810210657224975",
      "hy": "0.9725492813409784",
      "bn": "0.9853380984239097",
      "bg": "0.9781248361366278",
      "zh": "0.9874014708221002",
      "fr": "0.9810210657224975",
      "de": "0.9778405960613669",
      "ha": "0.9785848640991046",
      "hi": "0.990383508732577",
      "hu": "0.9664922465017006"
    }
  },
  {
    "task_id": "Common Lisp/38",
    "prompt": {
      "en": "(defun count-output-sequences (n)\n;; This function calculates the total number of different output sequences that can be obtained by using a stack \n;; with operations push and pop on a sequence of numbers from 1 to n.\n;; The operations are: \n;; 1. Push the next number from the input sequence onto the stack.\n;; 2. Pop the top number from the stack and add it to the output sequence.\n;; It counts all the possible sequences of these operations that result in all numbers being moved from the input sequence to the output sequence.\n;; Example:\n;; >>> count-output-sequences 3\n;; 5\n;; >>> count-output-sequences 4\n;; 14",
      "sq": "(defun count-output-sequences (n)\n;; Kjo funksion llogarit numrin total të sekuencave të ndryshme të daljes që mund të merren duke përdorur një grumbull \n;; me operacionet shto dhe hiq në një sekuencë numrash nga 1 deri në n.\n;; Operacionet janë: \n;; 1. Shto numrin e radhës nga sekuenca hyrëse në grumbull.\n;; 2. Hiq numrin në krye të grumbullit dhe shtoje atë në sekuencën e daljes.\n;; Ai numëron të gjitha sekuencat e mundshme të këtyre operacioneve që rezultojnë në të gjitha numrat që kalojnë nga sekuenca hyrëse në sekuencën e daljes.\n;; Shembull:\n;; >>> count-output-sequences 3\n;; 5\n;; >>> count-output-sequences 4\n;; 14",
      "hy": "(defun count-output-sequences (n)\n;; Այս ֆունկցիան հաշվում է տարբեր ելքային հաջորդականությունների ընդհանուր թիվը, որոնք կարող են ստացվել օգտագործելով push և pop գործողություններով stack \n;; 1-ից n թվերի հաջորդականության վրա։\n;; Գործողությունները հետևյալն են՝ \n;; 1. Push գործողությամբ հաջորդ թիվը մուտքային հաջորդականությունից տեղադրել stack-ի վրա։\n;; 2. Pop գործողությամբ stack-ի վերին թիվը հանել և ավելացնել ելքային հաջորդականությանը։\n;; Այն հաշվում է բոլոր հնարավոր հաջորդականությունները այս գործողությունների, որոնք բերում են բոլոր թվերի տեղափոխմանը մուտքային հաջորդականությունից ելքային հաջորդականություն։\n;; Օրինակ:\n;; >>> count-output-sequences 3\n;; 5\n;; >>> count-output-sequences 4\n;; 14",
      "bn": "(defun count-output-sequences (n)\n;; এই ফাংশনটি স্ট্যাক ব্যবহার করে বিভিন্ন আউটপুট সিকোয়েন্সের মোট সংখ্যা গণনা করে \n;; যেখানে অপারেশনগুলি হল পুশ এবং পপ, যা 1 থেকে n পর্যন্ত সংখ্যার একটি সিকোয়েন্সে প্রয়োগ করা হয়।\n;; অপারেশনগুলি হল:\n;; 1. ইনপুট সিকোয়েন্স থেকে পরবর্তী সংখ্যাটি স্ট্যাকে পুশ করা।\n;; 2. স্ট্যাকের শীর্ষ সংখ্যাটি পপ করে আউটপুট সিকোয়েন্সে যোগ করা।\n;; এটি এই অপারেশনগুলির সমস্ত সম্ভাব্য সিকোয়েন্স গণনা করে যা সমস্ত সংখ্যা ইনপুট সিকোয়েন্স থেকে আউটপুট সিকোয়েন্সে স্থানান্তরিত হয়।\n;; উদাহরণ:\n;; >>> count-output-sequences 3\n;; 5\n;; >>> count-output-sequences 4\n;; 14",
      "bg": "(defun count-output-sequences (n)\n;; Тази функция изчислява общия брой различни изходни последователности, които могат да бъдат получени чрез използване на стек \n;; с операции push и pop върху последователност от числа от 1 до n.\n;; Операциите са: \n;; 1. Поставяне на следващото число от входната последователност върху стека.\n;; 2. Изваждане на горното число от стека и добавянето му към изходната последователност.\n;; Тя брои всички възможни последователности от тези операции, които водят до преместване на всички числа от входната последователност към изходната последователност.\n;; Пример:\n;; >>> count-output-sequences 3\n;; 5\n;; >>> count-output-sequences 4\n;; 14",
      "zh": "(defun count-output-sequences (n)\n;; 此函数计算通过对从1到n的数字序列使用堆栈操作（push和pop）可以获得的不同输出序列的总数。\n;; 操作包括：\n;; 1. 将输入序列中的下一个数字推入堆栈。\n;; 2. 从堆栈中弹出顶部数字并将其添加到输出序列。\n;; 它计算所有可能的操作序列，这些操作序列导致所有数字从输入序列移动到输出序列。\n;; 示例：\n;; >>> count-output-sequences 3\n;; 5\n;; >>> count-output-sequences 4\n;; 14",
      "fr": "(defun count-output-sequences (n)\n;; Cette fonction calcule le nombre total de séquences de sortie différentes qui peuvent être obtenues en utilisant une pile \n;; avec les opérations push et pop sur une séquence de nombres de 1 à n.\n;; Les opérations sont : \n;; 1. Empiler le nombre suivant de la séquence d'entrée sur la pile.\n;; 2. Dépiler le nombre du sommet de la pile et l'ajouter à la séquence de sortie.\n;; Elle compte toutes les séquences possibles de ces opérations qui aboutissent à ce que tous les nombres soient déplacés de la séquence d'entrée à la séquence de sortie.\n;; Exemple:\n;; >>> count-output-sequences 3\n;; 5\n;; >>> count-output-sequences 4\n;; 14",
      "de": "(defun count-output-sequences (n)\n;; Diese Funktion berechnet die Gesamtanzahl der verschiedenen Ausgabesequenzen, die durch die Verwendung eines Stacks \n;; mit den Operationen Push und Pop auf einer Zahlenfolge von 1 bis n erhalten werden können.\n;; Die Operationen sind: \n;; 1. Die nächste Zahl aus der Eingabesequenz auf den Stack schieben.\n;; 2. Die oberste Zahl vom Stack nehmen und zur Ausgabesequenz hinzufügen.\n;; Sie zählt alle möglichen Sequenzen dieser Operationen, die dazu führen, dass alle Zahlen von der Eingabesequenz zur Ausgabesequenz verschoben werden.\n;; Beispiel:\n;; >>> count-output-sequences 3\n;; 5\n;; >>> count-output-sequences 4\n;; 14",
      "ha": "(defun count-output-sequences (n)\n;; Wannan aikin yana ƙididdige jimillar adadin jerin fitarwa daban-daban da za a iya samu ta amfani da sito\n;; tare da ayyuka na tura da cirewa akan jerin lambobi daga 1 zuwa n.\n;; Ayyukan sune:\n;; 1. Tura lamba ta gaba daga jerin shigarwa zuwa sito.\n;; 2. Cire lambar da ke saman sito kuma ƙara ta zuwa jerin fitarwa.\n;; Yana ƙididdige dukkan yiwuwar jerin waɗannan ayyukan da ke haifar da duk lambobi suna motsawa daga jerin shigarwa zuwa jerin fitarwa.\n;; Misali:\n;; >>> count-output-sequences 3\n;; 5\n;; >>> count-output-sequences 4\n;; 14",
      "hi": "(defun count-output-sequences (n)\n;; यह फ़ंक्शन उन सभी विभिन्न आउटपुट अनुक्रमों की कुल संख्या की गणना करता है जो एक स्टैक का उपयोग करके प्राप्त किए जा सकते हैं \n;; जिसमें 1 से n तक की संख्याओं के अनुक्रम पर पुश और पॉप ऑपरेशन्स होते हैं।\n;; ऑपरेशन्स हैं: \n;; 1. इनपुट अनुक्रम से अगली संख्या को स्टैक पर पुश करें।\n;; 2. स्टैक से शीर्ष संख्या को पॉप करें और इसे आउटपुट अनुक्रम में जोड़ें।\n;; यह इन ऑपरेशन्स के सभी संभावित अनुक्रमों की गणना करता है जो सभी संख्याओं को इनपुट अनुक्रम से आउटपुट अनुक्रम में स्थानांतरित करने का परिणाम देते हैं।\n;; उदाहरण:\n;; >>> count-output-sequences 3\n;; 5\n;; >>> count-output-sequences 4\n;; 14",
      "hu": "(defun count-output-sequences (n)\n;; Ez a függvény kiszámítja a különböző kimeneti sorozatok teljes számát, amelyeket egy verem használatával lehet elérni \n;; a push és pop műveletekkel egy 1-től n-ig terjedő számsorozaton.\n;; A műveletek a következők: \n;; 1. A következő számot a bemeneti sorozatból a verembe helyezzük.\n;; 2. A verem tetején lévő számot kivesszük és hozzáadjuk a kimeneti sorozathoz.\n;; Megszámolja az összes lehetséges műveletsorozatot, amelyek eredményeként az összes szám átkerül a bemeneti sorozatból a kimeneti sorozatba.\n;; Példa:\n;; >>> count-output-sequences 3\n;; 5\n;; >>> count-output-sequences 4\n;; 14"
    },
    "prompt_bertscore": {
      "sq": "0.9734496728582096",
      "hy": "0.9449863365166722",
      "bn": "0.960112040032479",
      "bg": "0.9841312202287418",
      "zh": "0.9642654012999184",
      "fr": "0.9855834069444878",
      "de": "0.9858958525338557",
      "ha": "0.9547877526688388",
      "hi": "0.9777518082810442",
      "hu": "0.957044193797395"
    },
    "canonical_solution": "(let ((dp (make-array (1+ n) :initial-element 0)))\n(setf (aref dp 0) 1)\n(loop for i from 1 to n do\n(loop for j from 0 to (1- i) do\n(incf (aref dp i) (* (aref dp j) (aref dp (1- (- i j)))))))\n(aref dp n)))",
    "instruction": {
      "en": "Write a Common Lisp function `(defun count-output-sequences (n)` to solve the following problem:\nThis function calculates the total number of different output sequences that can be obtained by using a stack \nwith operations push and pop on a sequence of numbers from 1 to n.\nThe operations are: \n1. Push the next number from the input sequence onto the stack.\n2. Pop the top number from the stack and add it to the output sequence.\nIt counts all the possible sequences of these operations that result in all numbers being moved from the input sequence to the output sequence.\nExample:\n>>> count-output-sequences 3\n5\n>>> count-output-sequences 4\n14",
      "sq": "Shkruani një funksion Common Lisp `(defun count-output-sequences (n)` për të zgjidhur problemin e mëposhtëm:\nKy funksion llogarit numrin total të sekuencave të ndryshme të daljes që mund të merren duke përdorur një stack me operacionet shto dhe hiq në një sekuencë numrash nga 1 në n.\nOperacionet janë:\n1. Shto numrin e radhës nga sekuenca e hyrjes në stack.\n2. Hiq numrin në majë të stack-ut dhe shtoje atë në sekuencën e daljes.\nAi numëron të gjitha sekuencat e mundshme të këtyre operacioneve që rezultojnë në të gjithë numrat që lëvizin nga sekuenca e hyrjes në sekuencën e daljes.\nShembull:\n>>> count-output-sequences 3\n5\n>>> count-output-sequences 4\n14",
      "hy": "Գրեք Common Lisp ֆունկցիա `(defun count-output-sequences (n)` հետևյալ խնդիրը լուծելու համար:\nԱյս ֆունկցիան հաշվում է տարբեր ելքային հաջորդականությունների ընդհանուր քանակը, որոնք կարող են ստացվել օգտագործելով push և pop գործողությունները 1-ից n թվերի հաջորդականության վրա:\nԳործողությունները հետևյալն են:\n1. Հաջորդ թիվը մուտքային հաջորդականությունից դնել stack-ի վրա:\n2. Stack-ի վերևի թիվը հանել և ավելացնել ելքային հաջորդականությանը:\nԱյն հաշվում է բոլոր հնարավոր հաջորդականությունները այս գործողությունների, որոնք հանգեցնում են բոլոր թվերի տեղափոխմանը մուտքային հաջորդականությունից ելքային հաջորդականություն:\nՕրինակ:\n>>> count-output-sequences 3\n5\n>>> count-output-sequences 4\n14",
      "bn": "Common Lisp ফাংশন `(defun count-output-sequences (n)` লিখুন নিম্নলিখিত সমস্যার সমাধানের জন্য:\nএই ফাংশনটি একটি স্ট্যাক ব্যবহার করে পুশ এবং পপ অপারেশনগুলির মাধ্যমে 1 থেকে n পর্যন্ত সংখ্যার একটি সিকোয়েন্সের বিভিন্ন আউটপুট সিকোয়েন্সের মোট সংখ্যা গণনা করে।\nঅপারেশনগুলি হল:\n1. ইনপুট সিকোয়েন্স থেকে পরবর্তী সংখ্যা স্ট্যাকে পুশ করুন।\n2. স্ট্যাকের উপরের সংখ্যা পপ করুন এবং এটি আউটপুট সিকোয়েন্সে যোগ করুন।\nএটি এই অপারেশনগুলির সমস্ত সম্ভাব্য সিকোয়েন্স গণনা করে যা সমস্ত সংখ্যা ইনপুট সিকোয়েন্স থেকে আউটপুট সিকোয়েন্সে স্থানান্তরিত হওয়ার ফলাফল দেয়।\nউদাহরণ:\n>>> count-output-sequences 3\n5\n>>> count-output-sequences 4\n14",
      "bg": "Напишете функция на Common Lisp `(defun count-output-sequences (n)` за решаване на следния проблем:\nТази функция изчислява общия брой различни изходни последователности, които могат да бъдат получени чрез използване на стек с операции push и pop върху последователност от числа от 1 до n.\nОперациите са:\n1. Поставете следващото число от входната последователност в стека.\n2. Извадете най-горното число от стека и го добавете към изходната последователност.\nТя брои всички възможни последователности от тези операции, които водят до преместване на всички числа от входната последователност към изходната последователност.\nПример:\n>>> count-output-sequences 3\n5\n>>> count-output-sequences 4\n14",
      "zh": "编写一个 Common Lisp 函数 `(defun count-output-sequences (n)` 来解决以下问题：\n此函数计算通过对从 1 到 n 的数字序列使用栈操作（push 和 pop）可以获得的不同输出序列的总数。\n操作是：\n1. 将输入序列中的下一个数字推入栈中。\n2. 将栈顶数字弹出并添加到输出序列中。\n它计算所有可能的操作序列，这些操作序列导致所有数字从输入序列移动到输出序列。\n示例:\n>>> count-output-sequences 3\n5\n>>> count-output-sequences 4\n14",
      "fr": "Écrire une fonction Common Lisp `(defun count-output-sequences (n)` pour résoudre le problème suivant :  \nCette fonction calcule le nombre total de séquences de sortie différentes qui peuvent être obtenues en utilisant une pile avec les opérations push et pop sur une séquence de nombres de 1 à n.  \nLes opérations sont :  \n1. Empiler le prochain nombre de la séquence d'entrée sur la pile.  \n2. Dépiler le nombre du haut de la pile et l'ajouter à la séquence de sortie.  \nElle compte toutes les séquences possibles de ces opérations qui aboutissent à ce que tous les nombres soient déplacés de la séquence d'entrée à la séquence de sortie.  \nExemple :  \n>>> count-output-sequences 3  \n5  \n>>> count-output-sequences 4  \n14",
      "de": "Schreiben Sie eine Common Lisp-Funktion `(defun count-output-sequences (n)`, um das folgende Problem zu lösen:\nDiese Funktion berechnet die Gesamtanzahl der verschiedenen Ausgabesequenzen, die durch die Verwendung eines Stacks mit den Operationen Push und Pop auf einer Zahlenfolge von 1 bis n erhalten werden können.\nDie Operationen sind: \n1. Die nächste Zahl aus der Eingabesequenz auf den Stack schieben.\n2. Die oberste Zahl vom Stack nehmen und zur Ausgabesequenz hinzufügen.\nSie zählt alle möglichen Sequenzen dieser Operationen, die dazu führen, dass alle Zahlen von der Eingabesequenz zur Ausgabesequenz verschoben werden.\nBeispiel:\n>>> count-output-sequences 3\n5\n>>> count-output-sequences 4\n14",
      "ha": "Rubuta aikin Common Lisp `(defun count-output-sequences (n)` don warware matsalar mai zuwa:\nWannan aikin yana ƙididdige jimlar adadin jerin fitarwa daban-daban da za a iya samu ta amfani da stack tare da ayyuka na turawa da cirewa akan jerin lambobi daga 1 zuwa n.\nAyyukan sune:\n1. Turawa lambar gaba daga jerin shigarwa zuwa stack.\n2. Cire lambar saman daga stack kuma ƙara ta zuwa jerin fitarwa.\nYana ƙididdige dukkan yiwuwar jerin waɗannan ayyukan da ke haifar da duk lambobi ana motsa su daga jerin shigarwa zuwa jerin fitarwa.\nMisali:\n>>> count-output-sequences 3\n5\n>>> count-output-sequences 4\n14",
      "hi": "एक Common Lisp फ़ंक्शन `(defun count-output-sequences (n)` लिखें ताकि निम्नलिखित समस्या को हल किया जा सके:\nयह फ़ंक्शन उन सभी विभिन्न आउटपुट अनुक्रमों की कुल संख्या की गणना करता है जो 1 से n तक की संख्याओं के अनुक्रम पर पुश और पॉप ऑपरेशनों के साथ एक स्टैक का उपयोग करके प्राप्त किए जा सकते हैं।\nऑपरेशन्स हैं: \n1. इनपुट अनुक्रम से अगली संख्या को स्टैक पर पुश करें।\n2. स्टैक से शीर्ष संख्या को पॉप करें और इसे आउटपुट अनुक्रम में जोड़ें।\nयह उन सभी संभावित अनुक्रमों की गणना करता है जो इन ऑपरेशनों के माध्यम से इनपुट अनुक्रम से सभी संख्याओं को आउटपुट अनुक्रम में स्थानांतरित करते हैं।\nउदाहरण:\n>>> count-output-sequences 3\n5\n>>> count-output-sequences 4\n14",
      "hu": "Írj egy Common Lisp függvényt `(defun count-output-sequences (n)` a következő probléma megoldására:\nEz a függvény kiszámítja a különböző kimeneti sorozatok teljes számát, amelyeket egy verem használatával lehet elérni, a push és pop műveletekkel egy 1-től n-ig terjedő számsorozaton.\nA műveletek a következők:\n1. A következő számot a bemeneti sorozatból a verembe helyezzük.\n2. A verem tetején lévő számot kivesszük és hozzáadjuk a kimeneti sorozathoz.\nMegszámolja az összes lehetséges műveletsorozatot, amelyek eredményeként az összes szám a bemeneti sorozatból a kimeneti sorozatba kerül.\nPélda:\n>>> count-output-sequences 3\n5\n>>> count-output-sequences 4\n14"
    },
    "instruction_bertscore": {
      "sq": "0.984417446607813",
      "hy": "0.9689735372215884",
      "bn": "0.952608578758505",
      "bg": "0.9833037260613504",
      "zh": "0.9739424748335571",
      "fr": "0.9874541078730744",
      "de": "0.9864549970564689",
      "ha": "0.9804442430959721",
      "hi": "0.9682552897637663",
      "hu": "0.9539040461036146"
    },
    "level": "easy",
    "test": "(defun test-count-output-sequences ()\n(assert (equal (count-output-sequences 3) 5))\n(assert (equal (count-output-sequences 4) 14))\n(assert (equal (count-output-sequences 5) 42))\n(assert (equal (count-output-sequences 6) 132))\n(assert (equal (count-output-sequences 7) 429)))\n\n(test-count-output-sequences)",
    "entry_point": "count-output-sequences",
    "signature": "(defun count-output-sequences (n)",
    "docstring": {
      "en": "This function calculates the total number of different output sequences that can be obtained by using a stack \nwith operations push and pop on a sequence of numbers from 1 to n.\nThe operations are: \n1. Push the next number from the input sequence onto the stack.\n2. Pop the top number from the stack and add it to the output sequence.\nIt counts all the possible sequences of these operations that result in all numbers being moved from the input sequence to the output sequence.\nExample:\n>>> count-output-sequences 3\n5\n>>> count-output-sequences 4\n14",
      "sq": "Kjo funksion llogarit numrin total të sekuencave të ndryshme të daljes që mund të merren duke përdorur një grumbull me operacionet shto dhe hiq në një sekuencë numrash nga 1 deri në n.  \nOperacionet janë:  \n1. Shto numrin tjetër nga sekuenca hyrëse në grumbull.  \n2. Hiq numrin në krye të grumbullit dhe shtoje atë në sekuencën e daljes.  \nAi numëron të gjitha sekuencat e mundshme të këtyre operacioneve që rezultojnë në të gjitha numrat që lëvizin nga sekuenca hyrëse në sekuencën e daljes.  \nShembull:  \n>>> count-output-sequences 3  \n5  \n>>> count-output-sequences 4  \n14",
      "hy": "Այս ֆունկցիան հաշվարկում է տարբեր ելքային հաջորդականությունների ընդհանուր քանակը, որոնք կարող են ստացվել օգտագործելով push և pop գործողություններով stack-ի վրա 1-ից n թվերի հաջորդականության համար:\nԳործողությունները հետևյալն են:\n1. Մուտքային հաջորդականությունից հաջորդ թիվը դնել stack-ի վրա:\n2. Stack-ի վերևի թիվը հանել և ավելացնել ելքային հաջորդականությանը:\nԱյն հաշվում է բոլոր հնարավոր հաջորդականությունները այս գործողությունների, որոնք հանգեցնում են բոլոր թվերի տեղափոխմանը մուտքային հաջորդականությունից ելքային հաջորդականություն:\nՕրինակ:\n>>> count-output-sequences 3\n5\n>>> count-output-sequences 4\n14",
      "bn": "এই ফাংশনটি একটি স্ট্যাক ব্যবহার করে পুশ এবং পপ অপারেশনগুলির মাধ্যমে 1 থেকে n পর্যন্ত সংখ্যার একটি সিকোয়েন্স থেকে প্রাপ্ত বিভিন্ন আউটপুট সিকোয়েন্সের মোট সংখ্যা গণনা করে। \nঅপারেশনগুলি হল:\n1. ইনপুট সিকোয়েন্স থেকে পরবর্তী সংখ্যা স্ট্যাকে পুশ করুন।\n2. স্ট্যাকের শীর্ষ সংখ্যা পপ করুন এবং এটি আউটপুট সিকোয়েন্সে যোগ করুন।\nএটি এই অপারেশনগুলির সমস্ত সম্ভাব্য সিকোয়েন্স গণনা করে যা ইনপুট সিকোয়েন্স থেকে আউটপুট সিকোয়েন্সে সমস্ত সংখ্যা স্থানান্তরিত হওয়ার ফলাফল।\nউদাহরণ:\n>>> count-output-sequences 3\n5\n>>> count-output-sequences 4\n14",
      "bg": "Тази функция изчислява общия брой различни изходни последователности, които могат да бъдат получени чрез използване на стек с операции push и pop върху последователност от числа от 1 до n. \nОперациите са: \n1. Поставете следващото число от входната последователност върху стека.\n2. Извадете горното число от стека и го добавете към изходната последователност.\nТя преброява всички възможни последователности от тези операции, които водят до преместване на всички числа от входната последователност към изходната последователност.\nПример:\n>>> count-output-sequences 3\n5\n>>> count-output-sequences 4\n14",
      "zh": "此函数计算通过对从1到n的数字序列使用栈操作（push和pop）可以获得的不同输出序列的总数。  \n操作包括：  \n1. 将输入序列中的下一个数字推入栈中。  \n2. 从栈中弹出顶部数字并将其添加到输出序列中。  \n它计算所有可能的操作序列，这些操作将所有数字从输入序列移动到输出序列。  \n示例：  \n>>> count-output-sequences 3  \n5  \n>>> count-output-sequences 4  \n14  ",
      "fr": "Cette fonction calcule le nombre total de séquences de sortie différentes qui peuvent être obtenues en utilisant une pile avec les opérations push et pop sur une séquence de nombres de 1 à n.  \nLes opérations sont :  \n1. Empiler le nombre suivant de la séquence d'entrée sur la pile.  \n2. Dépiler le nombre en haut de la pile et l'ajouter à la séquence de sortie.  \nElle compte toutes les séquences possibles de ces opérations qui aboutissent à ce que tous les nombres soient déplacés de la séquence d'entrée à la séquence de sortie.  \nExemple :  \n>>> count-output-sequences 3  \n5  \n>>> count-output-sequences 4  \n14  ",
      "de": "Diese Funktion berechnet die Gesamtanzahl der verschiedenen Ausgabesequenzen, die durch die Verwendung eines Stacks mit den Operationen push und pop auf einer Zahlenfolge von 1 bis n erhalten werden können.  \nDie Operationen sind:  \n1. Die nächste Zahl aus der Eingabesequenz auf den Stack schieben.  \n2. Die oberste Zahl vom Stack entfernen und zur Ausgabesequenz hinzufügen.  \nSie zählt alle möglichen Sequenzen dieser Operationen, die dazu führen, dass alle Zahlen von der Eingabesequenz zur Ausgabesequenz verschoben werden.  \nBeispiel:  \n>>> count-output-sequences 3  \n5  \n>>> count-output-sequences 4  \n14  ",
      "ha": "Wannan aikin yana ƙididdige jimillar adadin jerin fitarwa daban-daban da za a iya samu ta amfani da tari \ntare da ayyuka na turawa da cirewa akan jerin lambobi daga 1 zuwa n.\nAyyukan sune: \n1. Turawa lamba ta gaba daga jerin shigarwa zuwa cikin tari.\n2. Cire lamba ta sama daga tari kuma ƙara ta zuwa jerin fitarwa.\nYana ƙididdige dukkan yiwuwar jerin waɗannan ayyukan da ke haifar da duk lambobi ana motsa su daga jerin shigarwa zuwa jerin fitarwa.\nMisali:\n>>> count-output-sequences 3\n5\n>>> count-output-sequences 4\n14",
      "hi": "यह फ़ंक्शन उन सभी विभिन्न आउटपुट अनुक्रमों की कुल संख्या की गणना करता है जो 1 से n तक की संख्याओं के अनुक्रम पर पुश और पॉप ऑपरेशन्स का उपयोग करके एक स्टैक द्वारा प्राप्त किए जा सकते हैं।  \nऑपरेशन्स हैं:  \n1. इनपुट अनुक्रम से अगली संख्या को स्टैक पर पुश करें।  \n2. स्टैक से शीर्ष संख्या को पॉप करें और इसे आउटपुट अनुक्रम में जोड़ें।  \nयह उन सभी संभावित अनुक्रमों की गणना करता है जो इन ऑपरेशन्स के परिणामस्वरूप सभी संख्याओं को इनपुट अनुक्रम से आउटपुट अनुक्रम में स्थानांतरित करते हैं।  \nउदाहरण:  \n>>> count-output-sequences 3  \n5  \n>>> count-output-sequences 4  \n14  ",
      "hu": "Ez a függvény kiszámítja a különböző kimeneti sorozatok összes számát, amelyeket egy verem használatával lehet elérni, a push és pop műveletekkel egy 1-től n-ig terjedő számsoron.\nA műveletek a következők:\n1. A bemeneti sorozat következő számát a verembe helyezzük.\n2. A verem tetején lévő számot kivesszük és hozzáadjuk a kimeneti sorozathoz.\nSzámolja az összes lehetséges műveletsorozatot, amelyek eredményeként az összes szám a bemeneti sorozatból a kimeneti sorozatba kerül.\nPélda:\n>>> count-output-sequences 3\n5\n>>> count-output-sequences 4\n14"
    },
    "docstring_bertscore": {
      "sq": "0.9800304960122764",
      "hy": "0.9662181365758724",
      "bn": "0.9560387268085965",
      "bg": "0.9885918626956423",
      "zh": "0.9547516019394904",
      "fr": "0.9795512009028393",
      "de": "0.9821260465321946",
      "ha": "0.9568872757963776",
      "hi": "0.9558818088075789",
      "hu": "0.9370578062272836"
    }
  },
  {
    "task_id": "Common Lisp/39",
    "prompt": {
      "en": "(defun max-herb-value (time-limit herb-info)\n;; This function calculates the maximum total value of herbs that can be collected within a given time limit.\n;; 'time-limit' is the total time available for collecting herbs.\n;; 'herb-info' is a list of pairs, each pair containing two integers: the time required to collect a herb and its value.\n;; The function uses a dynamic programming approach to determine the maximum value that can be obtained.\n;; Example:\n;; >>> max-herb-value 70 '((71 100) (69 1) (1 2))\n;; 3\n;; >>> max-herb-value 10 '((5 5) (4 7) (3 4) (2 3))\n;; 14",
      "sq": "(defun max-herb-value (time-limit herb-info)\n;; Kjo funksion llogarit vlerën maksimale totale të bimëve që mund të mblidhen brenda një kufiri të caktuar kohor.\n;; 'time-limit' është koha totale e disponueshme për mbledhjen e bimëve.\n;; 'herb-info' është një listë çiftesh, ku çdo çift përmban dy numra të plotë: koha e kërkuar për të mbledhur një bimë dhe vlera e saj.\n;; Funksioni përdor një qasje të programimit dinamik për të përcaktuar vlerën maksimale që mund të merret.\n;; Shembull:\n;; >>> max-herb-value 70 '((71 100) (69 1) (1 2))\n;; 3\n;; >>> max-herb-value 10 '((5 5) (4 7) (3 4) (2 3))\n;; 14",
      "hy": "(defun max-herb-value (time-limit herb-info)\n;; Այս ֆունկցիան հաշվում է խոտաբույսերի առավելագույն ընդհանուր արժեքը, որը հնարավոր է հավաքել տրված ժամանակի սահմաններում:\n;; 'time-limit' - խոտաբույսեր հավաքելու համար հասանելի ընդհանուր ժամանակը:\n;; 'herb-info' - զույգերի ցուցակ է, որտեղ յուրաքանչյուր զույգ պարունակում է երկու ամբողջ թիվ՝ խոտաբույս հավաքելու համար անհրաժեշտ ժամանակը և դրա արժեքը:\n;; Ֆունկցիան օգտագործում է դինամիկ ծրագրավորման մոտեցում՝ որոշելու համար առավելագույն արժեքը, որը կարող է ստացվել:\n;; Օրինակ:\n;; >>> max-herb-value 70 '((71 100) (69 1) (1 2))\n;; 3\n;; >>> max-herb-value 10 '((5 5) (4 7) (3 4) (2 3))\n;; 14",
      "bn": "(defun max-herb-value (time-limit herb-info)\n;; এই ফাংশনটি একটি নির্দিষ্ট সময়সীমার মধ্যে কতগুলি ভেষজ সর্বাধিক মোট মূল্য সংগ্রহ করা যেতে পারে তা গণনা করে।\n;; 'time-limit' হল ভেষজ সংগ্রহের জন্য উপলব্ধ মোট সময়।\n;; 'herb-info' হল জোড়ার একটি তালিকা, প্রতিটি জোড়ায় দুটি পূর্ণসংখ্যা রয়েছে: একটি ভেষজ সংগ্রহের জন্য প্রয়োজনীয় সময় এবং এর মূল্য।\n;; ফাংশনটি সর্বাধিক মূল্য নির্ধারণ করতে একটি গতিশীল প্রোগ্রামিং পদ্ধতি ব্যবহার করে যা প্রাপ্ত করা যেতে পারে।\n;; উদাহরণ:\n;; >>> max-herb-value 70 '((71 100) (69 1) (1 2))\n;; 3\n;; >>> max-herb-value 10 '((5 5) (4 7) (3 4) (2 3))\n;; 14",
      "bg": "(defun max-herb-value (time-limit herb-info)\n;; Тази функция изчислява максималната обща стойност на билките, които могат да бъдат събрани в рамките на даден времеви лимит.\n;; 'time-limit' е общото време, налично за събиране на билки.\n;; 'herb-info' е списък от двойки, като всяка двойка съдържа две цели числа: времето, необходимо за събиране на билка и нейната стойност.\n;; Функцията използва подход на динамично програмиране, за да определи максималната стойност, която може да бъде получена.\n;; Пример:\n;; >>> max-herb-value 70 '((71 100) (69 1) (1 2))\n;; 3\n;; >>> max-herb-value 10 '((5 5) (4 7) (3 4) (2 3))\n;; 14",
      "zh": "(defun max-herb-value (time-limit herb-info)\n;; 此函数计算在给定时间限制内可以收集的草药的最大总价值。\n;; 'time-limit' 是收集草药的总可用时间。\n;; 'herb-info' 是一个对的列表，每对包含两个整数：收集一种草药所需的时间及其价值。\n;; 该函数使用动态规划方法来确定可以获得的最大价值。\n;; 例子:\n;; >>> max-herb-value 70 '((71 100) (69 1) (1 2))\n;; 3\n;; >>> max-herb-value 10 '((5 5) (4 7) (3 4) (2 3))\n;; 14",
      "fr": "(defun max-herb-value (time-limit herb-info)\n;; Cette fonction calcule la valeur totale maximale des herbes qui peuvent être collectées dans une limite de temps donnée.\n;; 'time-limit' est le temps total disponible pour collecter des herbes.\n;; 'herb-info' est une liste de paires, chaque paire contenant deux entiers : le temps requis pour collecter une herbe et sa valeur.\n;; La fonction utilise une approche de programmation dynamique pour déterminer la valeur maximale qui peut être obtenue.\n;; Exemple:\n;; >>> max-herb-value 70 '((71 100) (69 1) (1 2))\n;; 3\n;; >>> max-herb-value 10 '((5 5) (4 7) (3 4) (2 3))\n;; 14",
      "de": "(defun max-herb-value (time-limit herb-info)\n;; Diese Funktion berechnet den maximalen Gesamtwert von Kräutern, die innerhalb eines gegebenen Zeitlimits gesammelt werden können.\n;; 'time-limit' ist die insgesamt verfügbare Zeit zum Sammeln von Kräutern.\n;; 'herb-info' ist eine Liste von Paaren, wobei jedes Paar zwei ganze Zahlen enthält: die zum Sammeln eines Krauts benötigte Zeit und dessen Wert.\n;; Die Funktion verwendet einen dynamischen Programmierungsansatz, um den maximal erreichbaren Wert zu bestimmen.\n;; Beispiel:\n;; >>> max-herb-value 70 '((71 100) (69 1) (1 2))\n;; 3\n;; >>> max-herb-value 10 '((5 5) (4 7) (3 4) (2 3))\n;; 14",
      "ha": "(defun max-herb-value (time-limit herb-info)\n;; Wannan aikin yana ƙididdige mafi girman jimillar ƙimar ganyayyaki da za a iya tattarawa a cikin iyakar lokaci da aka bayar.\n;; 'time-limit' shine jimillar lokacin da ake da shi don tattara ganyayyaki.\n;; 'herb-info' jerin ma'aurata ne, kowanne ma'aurata suna ɗauke da lambobi biyu: lokacin da ake buƙata don tattara ganye da ƙimarsa.\n;; Aikin yana amfani da hanyar shirye-shiryen motsi don ƙayyade mafi girman ƙimar da za a iya samu.\n;; Misali:\n;; >>> max-herb-value 70 '((71 100) (69 1) (1 2))\n;; 3\n;; >>> max-herb-value 10 '((5 5) (4 7) (3 4) (2 3))\n;; 14",
      "hi": "(defun max-herb-value (time-limit herb-info)\n;; यह फ़ंक्शन जड़ी-बूटियों के अधिकतम कुल मूल्य की गणना करता है जो दिए गए समय सीमा के भीतर एकत्र किया जा सकता है।\n;; 'time-limit' जड़ी-बूटियों को इकट्ठा करने के लिए उपलब्ध कुल समय है।\n;; 'herb-info' जोड़ों की एक सूची है, प्रत्येक जोड़े में दो पूर्णांक होते हैं: एक जड़ी-बूटी को इकट्ठा करने के लिए आवश्यक समय और उसका मूल्य।\n;; फ़ंक्शन अधिकतम मूल्य निर्धारित करने के लिए एक गतिशील प्रोग्रामिंग दृष्टिकोण का उपयोग करता है जो प्राप्त किया जा सकता है।\n;; उदाहरण:\n;; >>> max-herb-value 70 '((71 100) (69 1) (1 2))\n;; 3\n;; >>> max-herb-value 10 '((5 5) (4 7) (3 4) (2 3))\n;; 14",
      "hu": "(defun max-herb-value (time-limit herb-info)\n;; Ez a függvény kiszámítja a gyógynövények maximális összértékét, amely egy adott időkorláton belül gyűjthető.\n;; 'time-limit' az összes rendelkezésre álló idő a gyógynövények gyűjtésére.\n;; 'herb-info' egy párokból álló lista, ahol minden pár két egész számot tartalmaz: a gyógynövény gyűjtéséhez szükséges időt és annak értékét.\n;; A függvény dinamikus programozási megközelítést alkalmaz a maximális érték meghatározására, amely elérhető.\n;; Példa:\n;; >>> max-herb-value 70 '((71 100) (69 1) (1 2))\n;; 3\n;; >>> max-herb-value 10 '((5 5) (4 7) (3 4) (2 3))\n;; 14"
    },
    "prompt_bertscore": {
      "sq": "0.9941841024432985",
      "hy": "0.9878650741314355",
      "bn": "0.9987734573971095",
      "bg": "0.9950088157853554",
      "zh": "0.9906796666307",
      "fr": "0.9991023893081034",
      "de": "0.9863687914710998",
      "ha": "0.9906178925821981",
      "hi": "0.9959119881279209",
      "hu": "0.9918146406279333"
    },
    "canonical_solution": "(let ((dp (make-array (1+ time-limit) :initial-element 0)))\n(loop for (time value) in herb-info do\n(loop for current-time from time-limit downto time do\n(setf (aref dp current-time) \n(max (aref dp current-time) \n(+ value (aref dp (- current-time time)))))))\n(aref dp time-limit)))",
    "instruction": {
      "en": "Write a Common Lisp function `(defun max-herb-value (time-limit herb-info)` to solve the following problem:\nThis function calculates the maximum total value of herbs that can be collected within a given time limit.\n'time-limit' is the total time available for collecting herbs.\n'herb-info' is a list of pairs, each pair containing two integers: the time required to collect a herb and its value.\nThe function uses a dynamic programming approach to determine the maximum value that can be obtained.\nExample:\n>>> max-herb-value 70 '((71 100) (69 1) (1 2))\n3\n>>> max-herb-value 10 '((5 5) (4 7) (3 4) (2 3))\n14",
      "sq": "Shkruani një funksion Common Lisp `(defun max-herb-value (time-limit herb-info)` për të zgjidhur problemin në vijim:\nKy funksion llogarit vlerën maksimale totale të bimëve që mund të mblidhen brenda një kufiri të caktuar kohe.\n'time-limit' është koha totale e disponueshme për mbledhjen e bimëve.\n'herb-info' është një listë çiftesh, ku çdo çift përmban dy numra të plotë: koha e kërkuar për të mbledhur një bimë dhe vlera e saj.\nFunksioni përdor një qasje të programimit dinamik për të përcaktuar vlerën maksimale që mund të merret.\nShembull:\n>>> max-herb-value 70 '((71 100) (69 1) (1 2))\n3\n>>> max-herb-value 10 '((5 5) (4 7) (3 4) (2 3))\n14",
      "hy": "Գրեք Common Lisp ֆունկցիա `(defun max-herb-value (time-limit herb-info)` հետևյալ խնդիրը լուծելու համար:\nԱյս ֆունկցիան հաշվում է խոտաբույսերի առավելագույն ընդհանուր արժեքը, որը կարելի է հավաքել տրված ժամանակային սահմանափակման շրջանակներում:\n'time-limit' հանդիսանում է խոտաբույսեր հավաքելու համար հասանելի ընդհանուր ժամանակը:\n'herb-info' ցուցակ է զույգերի, որոնցից յուրաքանչյուր զույգ պարունակում է երկու ամբողջ թիվ՝ խոտաբույս հավաքելու համար պահանջվող ժամանակը և դրա արժեքը:\nՖունկցիան օգտագործում է դինամիկ ծրագրավորման մոտեցում՝ որոշելու համար առավելագույն արժեքը, որը կարելի է ստանալ:\nՕրինակ:\n>>> max-herb-value 70 '((71 100) (69 1) (1 2))\n3\n>>> max-herb-value 10 '((5 5) (4 7) (3 4) (2 3))\n14",
      "bn": "একটি Common Lisp ফাংশন `(defun max-herb-value (time-limit herb-info)` লিখুন নিম্নলিখিত সমস্যার সমাধানের জন্য:\nএই ফাংশনটি প্রদত্ত সময়সীমার মধ্যে সর্বাধিক মোট মূল্যমানের ভেষজ সংগ্রহের হিসাব করে।\n'time-limit' হল ভেষজ সংগ্রহের জন্য উপলব্ধ মোট সময়।\n'herb-info' হল জোড়াগুলির একটি তালিকা, প্রতিটি জোড়ায় দুটি পূর্ণসংখ্যা থাকে: একটি ভেষজ সংগ্রহের জন্য প্রয়োজনীয় সময় এবং এর মূল্যমান।\nফাংশনটি সর্বাধিক মূল্যমান নির্ধারণের জন্য একটি গতিশীল প্রোগ্রামিং পদ্ধতি ব্যবহার করে।\nউদাহরণ:\n>>> max-herb-value 70 '((71 100) (69 1) (1 2))\n3\n>>> max-herb-value 10 '((5 5) (4 7) (3 4) (2 3))\n14",
      "bg": "Напишете функция на Common Lisp `(defun max-herb-value (time-limit herb-info)` за решаване на следния проблем:\nТази функция изчислява максималната обща стойност на билките, които могат да бъдат събрани в рамките на даден времеви лимит.\n'time-limit' е общото време, налично за събиране на билки.\n'herb-info' е списък от двойки, всяка двойка съдържаща две цели числа: времето, необходимо за събиране на билка и нейната стойност.\nФункцията използва подход на динамично програмиране, за да определи максималната стойност, която може да бъде получена.\nПример:\n>>> max-herb-value 70 '((71 100) (69 1) (1 2))\n3\n>>> max-herb-value 10 '((5 5) (4 7) (3 4) (2 3))\n14",
      "zh": "编写一个 Common Lisp 函数 `(defun max-herb-value (time-limit herb-info)` 来解决以下问题：\n此函数计算在给定时间限制内可以收集的草药的最大总价值。\n'time-limit' 是收集草药的可用总时间。\n'herb-info' 是一个对的列表，每对包含两个整数：收集一种草药所需的时间及其价值。\n该函数使用动态规划方法来确定可以获得的最大价值。\n示例:",
      "fr": "Écrire une fonction Common Lisp `(defun max-herb-value (time-limit herb-info)` pour résoudre le problème suivant :  \nCette fonction calcule la valeur totale maximale des herbes qui peuvent être collectées dans une limite de temps donnée.  \n'time-limit' est le temps total disponible pour collecter des herbes.  \n'herb-info' est une liste de paires, chaque paire contenant deux entiers : le temps nécessaire pour collecter une herbe et sa valeur.  \nLa fonction utilise une approche de programmation dynamique pour déterminer la valeur maximale qui peut être obtenue.  \nExemple :  \n>>> max-herb-value 70 '((71 100) (69 1) (1 2))  \n3  \n>>> max-herb-value 10 '((5 5) (4 7) (3 4) (2 3))  \n14",
      "de": "Schreiben Sie eine Common Lisp-Funktion `(defun max-herb-value (time-limit herb-info)`, um das folgende Problem zu lösen:\nDiese Funktion berechnet den maximalen Gesamtwert von Kräutern, die innerhalb eines gegebenen Zeitlimits gesammelt werden können.\n'time-limit' ist die insgesamt verfügbare Zeit zum Sammeln von Kräutern.\n'herb-info' ist eine Liste von Paaren, wobei jedes Paar zwei ganze Zahlen enthält: die Zeit, die benötigt wird, um ein Kraut zu sammeln, und dessen Wert.\nDie Funktion verwendet einen dynamischen Programmieransatz, um den maximalen Wert zu bestimmen, der erreicht werden kann.\nBeispiel:\n>>> max-herb-value 70 '((71 100) (69 1) (1 2))\n3\n>>> max-herb-value 10 '((5 5) (4 7) (3 4) (2 3))\n14",
      "ha": "Rubuta aikin Common Lisp `(defun max-herb-value (time-limit herb-info)` don warware matsalar mai zuwa:\nWannan aikin yana ƙididdige mafi girman jimillar ƙimar ganyayyaki da za a iya tattarawa a cikin iyakar lokaci da aka bayar.\n'time-limit' shine jimillar lokacin da ake da shi don tattara ganyayyaki.\n'herb-info' jerin ma'aurata ne, kowanne ma'aurata yana ɗauke da lambobi biyu: lokacin da ake buƙata don tattara ganye da ƙimarsa.\nAikin yana amfani da hanyar shirye-shiryen motsa jiki don ƙayyade mafi girman ƙimar da za a iya samu.\nMisali:\n>>> max-herb-value 70 '((71 100) (69 1) (1 2))\n3\n>>> max-herb-value 10 '((5 5) (4 7) (3 4) (2 3))\n14",
      "hi": "एक Common Lisp फ़ंक्शन `(defun max-herb-value (time-limit herb-info)` लिखें ताकि निम्नलिखित समस्या का समाधान किया जा सके:\nयह फ़ंक्शन उन जड़ी-बूटियों के अधिकतम कुल मूल्य की गणना करता है जिन्हें एक दिए गए समय सीमा के भीतर एकत्र किया जा सकता है।\n'time-limit' जड़ी-बूटियों को एकत्र करने के लिए उपलब्ध कुल समय है।\n'herb-info' जोड़ों की एक सूची है, प्रत्येक जोड़े में दो पूर्णांक होते हैं: एक जड़ी-बूटी को एकत्र करने के लिए आवश्यक समय और उसका मूल्य।\nफ़ंक्शन यह निर्धारित करने के लिए एक डायनामिक प्रोग्रामिंग दृष्टिकोण का उपयोग करता है कि अधिकतम मूल्य क्या प्राप्त किया जा सकता है।\nउदाहरण:\n>>> max-herb-value 70 '((71 100) (69 1) (1 2))\n3\n>>> max-herb-value 10 '((5 5) (4 7) (3 4) (2 3))\n14",
      "hu": "Írj egy Common Lisp függvényt `(defun max-herb-value (time-limit herb-info)` a következő probléma megoldására:\nEz a függvény kiszámítja a gyógynövények maximális összértékét, amely egy adott időkorláton belül gyűjthető.\nA 'time-limit' az összes rendelkezésre álló idő a gyógynövények gyűjtésére.\nA 'herb-info' egy párokból álló lista, ahol minden pár két egész számot tartalmaz: a gyógynövény gyűjtéséhez szükséges időt és annak értékét.\nA függvény dinamikus programozási megközelítést alkalmaz a maximális érték meghatározására, amely elérhető.\nPélda:\n>>> max-herb-value 70 '((71 100) (69 1) (1 2))\n3\n>>> max-herb-value 10 '((5 5) (4 7) (3 4) (2 3))\n14"
    },
    "instruction_bertscore": {
      "sq": "0.9931891628646947",
      "hy": "0.9922192507141013",
      "bn": "0.9774681640969264",
      "bg": "0.999999801369619",
      "zh": "0.8905665778726387",
      "fr": "0.9990459782798894",
      "de": "0.9909229888474677",
      "ha": "0.9906594063318344",
      "hi": "0.9920825930119493",
      "hu": "0.9795738447662773"
    },
    "level": "middle",
    "test": "(defun test-max-herb-value ()\n(assert (equal (max-herb-value 70 '((71 100) (69 1) (1 2))) 3))\n(assert (equal (max-herb-value 10 '((5 5) (4 7) (3 4) (2 3))) 14))\n(assert (equal (max-herb-value 15 '((5 10) (10 15) (20 25))) 25))\n(assert (equal (max-herb-value 100 '((50 60) (50 70))) 130))\n(assert (equal (max-herb-value 5 '((2 3) (2 4) (1 1))) 8)))\n\n(test-max-herb-value)",
    "entry_point": "max-herb-value",
    "signature": "(defun max-herb-value (time-limit herb-info)",
    "docstring": {
      "en": "This function calculates the maximum total value of herbs that can be collected within a given time limit.\n'time-limit' is the total time available for collecting herbs.\n'herb-info' is a list of pairs, each pair containing two integers: the time required to collect a herb and its value.\nThe function uses a dynamic programming approach to determine the maximum value that can be obtained.\nExample:\n>>> max-herb-value 70 '((71 100) (69 1) (1 2))\n3\n>>> max-herb-value 10 '((5 5) (4 7) (3 4) (2 3))\n14",
      "sq": "Kjo funksion llogarit vlerën maksimale totale të bimëve që mund të mblidhen brenda një kufiri të caktuar kohor.\n'time-limit' është koha totale e disponueshme për mbledhjen e bimëve.\n'herb-info' është një listë çiftesh, ku çdo çift përmban dy numra të plotë: koha e nevojshme për të mbledhur një bimë dhe vlera e saj.\nFunksioni përdor një qasje të programimit dinamik për të përcaktuar vlerën maksimale që mund të merret.\nShembull:\n>>> max-herb-value 70 '((71 100) (69 1) (1 2))\n3\n>>> max-herb-value 10 '((5 5) (4 7) (3 4) (2 3))\n14",
      "hy": "Այս ֆունկցիան հաշվարկում է խոտաբույսերի առավելագույն ընդհանուր արժեքը, որը կարելի է հավաքել տրված ժամանակային սահմանափակման շրջանակներում։  \n'time-limit' -ը խոտաբույսեր հավաքելու համար հասանելի ընդհանուր ժամանակն է։  \n'herb-info' -ն զույգերի ցուցակ է, որտեղ յուրաքանչյուր զույգ պարունակում է երկու ամբողջ թիվ՝ խոտաբույս հավաքելու համար պահանջվող ժամանակը և դրա արժեքը։  \nՖունկցիան օգտագործում է դինամիկ ծրագրավորման մոտեցում՝ որոշելու համար, թե ինչ առավելագույն արժեք կարելի է ստանալ։  \nՕրինակ:  \n>>> max-herb-value 70 '((71 100) (69 1) (1 2))  \n3  \n>>> max-herb-value 10 '((5 5) (4 7) (3 4) (2 3))  \n14",
      "bn": "এই ফাংশনটি একটি নির্দিষ্ট সময়সীমার মধ্যে যতটা সম্ভব সর্বাধিক মূল্যবান ভেষজ সংগ্রহ করা যায় তা গণনা করে।\n'time-limit' হল ভেষজ সংগ্রহের জন্য উপলব্ধ মোট সময়।\n'herb-info' হল জোড়ার একটি তালিকা, প্রতিটি জোড়ায় দুটি পূর্ণসংখ্যা থাকে: একটি ভেষজ সংগ্রহের জন্য প্রয়োজনীয় সময় এবং এর মূল্য।\nফাংশনটি সর্বাধিক মূল্য নির্ধারণের জন্য একটি গতিশীল প্রোগ্রামিং পদ্ধতি ব্যবহার করে যা প্রাপ্ত করা যেতে পারে।\nউদাহরণ:\n>>> max-herb-value 70 '((71 100) (69 1) (1 2))\n3\n>>> max-herb-value 10 '((5 5) (4 7) (3 4) (2 3))\n14",
      "bg": "Тази функция изчислява максималната обща стойност на билките, които могат да бъдат събрани в рамките на даден времеви лимит.\n'time-limit' е общото време, налично за събиране на билки.\n'herb-info' е списък от двойки, като всяка двойка съдържа два цели числа: времето, необходимо за събиране на билка, и нейната стойност.\nФункцията използва подход на динамично програмиране, за да определи максималната стойност, която може да бъде получена.\nПример:\n>>> max-herb-value 70 '((71 100) (69 1) (1 2))\n3\n>>> max-herb-value 10 '((5 5) (4 7) (3 4) (2 3))\n14",
      "zh": "此函数计算在给定时间限制内可以收集的草药的最大总价值。\n'time-limit' 是收集草药的总可用时间。\n'herb-info' 是一个对的列表，每对包含两个整数：收集一种草药所需的时间及其价值。\n该函数使用动态规划方法来确定可以获得的最大价值。\n示例：\n>>> max-herb-value 70 '((71 100) (69 1) (1 2))\n3\n>>> max-herb-value 10 '((5 5) (4 7) (3 4) (2 3))\n14",
      "fr": "Cette fonction calcule la valeur totale maximale des herbes qui peuvent être collectées dans une limite de temps donnée.\n'time-limit' est le temps total disponible pour collecter des herbes.\n'herb-info' est une liste de paires, chaque paire contenant deux entiers : le temps nécessaire pour collecter une herbe et sa valeur.\nLa fonction utilise une approche de programmation dynamique pour déterminer la valeur maximale qui peut être obtenue.\nExemple :\n>>> max-herb-value 70 '((71 100) (69 1) (1 2))\n3\n>>> max-herb-value 10 '((5 5) (4 7) (3 4) (2 3))\n14",
      "de": "Diese Funktion berechnet den maximalen Gesamtwert von Kräutern, die innerhalb eines gegebenen Zeitlimits gesammelt werden können. 'time-limit' ist die insgesamt verfügbare Zeit zum Sammeln von Kräutern. 'herb-info' ist eine Liste von Paaren, wobei jedes Paar zwei ganze Zahlen enthält: die zum Sammeln eines Krauts benötigte Zeit und dessen Wert. Die Funktion verwendet einen dynamischen Programmieransatz, um den maximal erreichbaren Wert zu bestimmen.\nBeispiel:\n>>> max-herb-value 70 '((71 100) (69 1) (1 2))\n3\n>>> max-herb-value 10 '((5 5) (4 7) (3 4) (2 3))\n14",
      "ha": "Wannan aikin yana ƙididdige jimillar ƙimar ganye mafi girma da za a iya tattarawa a cikin iyakar lokaci da aka bayar.\n'time-limit' shine jimillar lokacin da ake da shi don tattara ganye.\n'herb-info' jerin ma'aurata ne, kowanne ma'aurata yana ɗauke da lambobi biyu: lokacin da ake buƙata don tattara ganye da ƙimarsa.\nAikin yana amfani da hanyar shirye-shiryen motsi don ƙayyade ƙimar da za a iya samu.\nMisali:\n>>> max-herb-value 70 '((71 100) (69 1) (1 2))\n3\n>>> max-herb-value 10 '((5 5) (4 7) (3 4) (2 3))\n14",
      "hi": "यह फ़ंक्शन दिए गए समय सीमा के भीतर एकत्र किए जा सकने वाले जड़ी-बूटियों के अधिकतम कुल मूल्य की गणना करता है।  \n'time-limit' जड़ी-बूटियों को एकत्र करने के लिए उपलब्ध कुल समय है।  \n'herb-info' जोड़ों की एक सूची है, प्रत्येक जोड़े में दो पूर्णांक होते हैं: एक जड़ी-बूटी को एकत्र करने के लिए आवश्यक समय और उसका मूल्य।  \nफ़ंक्शन अधिकतम मूल्य निर्धारित करने के लिए एक गतिशील प्रोग्रामिंग दृष्टिकोण का उपयोग करता है।  \nउदाहरण:  \n>>> max-herb-value 70 '((71 100) (69 1) (1 2))  \n3  \n>>> max-herb-value 10 '((5 5) (4 7) (3 4) (2 3))  \n14  ",
      "hu": "Ez a függvény kiszámítja a maximálisan összegyűjthető gyógynövények összértékét egy adott időkorláton belül.\nA 'time-limit' az összes rendelkezésre álló idő a gyógynövények gyűjtésére.\nA 'herb-info' egy párok listája, ahol minden pár két egész számot tartalmaz: az első a gyógynövény gyűjtéséhez szükséges idő, a második pedig annak értéke.\nA függvény dinamikus programozási megközelítést alkalmaz a maximálisan elérhető érték meghatározására.\nPélda:\n>>> max-herb-value 70 '((71 100) (69 1) (1 2))\n3\n>>> max-herb-value 10 '((5 5) (4 7) (3 4) (2 3))\n14"
    },
    "docstring_bertscore": {
      "sq": "0.994870569040155",
      "hy": "0.9899959808591778",
      "bn": "0.9821717315198326",
      "bg": "0.9904341594797408",
      "zh": "0.9899816794717433",
      "fr": "0.9991011975258172",
      "de": "0.9868723194870233",
      "ha": "0.9822124507479447",
      "hi": "0.9848514539903742",
      "hu": "0.9617781516685996"
    }
  },
  {
    "task_id": "Common Lisp/40",
    "prompt": {
      "en": "(defun min-box-space (box-capacity item-volumes)\n;; This function calculates the minimum remaining space in a box after optimally packing a given set of items.\n;; Each item has a specific volume, and the box has a fixed capacity.\n;; The function returns the smallest possible remaining space in the box.\n;; Example:\n;; >>> min-box-space 10 '(2 3 4)\n;; 1\n;; >>> min-box-space 15 '(5 5 6)\n;; 0",
      "sq": "(defun min-box-space (box-capacity item-volumes)\n;; Kjo funksion llogarit hapësirën minimale të mbetur në një kuti pas paketimit optimal të një grupi të dhënë artikujsh.\n;; Çdo artikull ka një vëllim specifik, dhe kutia ka një kapacitet të caktuar.\n;; Funksioni kthen hapësirën më të vogël të mundshme të mbetur në kuti.\n;; Shembull:\n;; >>> min-box-space 10 '(2 3 4)\n;; 1\n;; >>> min-box-space 15 '(5 5 6)\n;; 0",
      "hy": "(defun min-box-space (box-capacity item-volumes)\n;; Այս ֆունկցիան հաշվարկում է տուփում մնացած նվազագույն ազատ տարածությունը՝ տրված իրերի օպտիմալ փաթեթավորումից հետո։\n;; Յուրաքանչյուր իր ունի որոշակի ծավալ, իսկ տուփը ունի ֆիքսված տարողություն։\n;; Ֆունկցիան վերադարձնում է տուփում մնացած հնարավոր նվազագույն տարածությունը։\n;; Օրինակ:\n;; >>> min-box-space 10 '(2 3 4)\n;; 1\n;; >>> min-box-space 15 '(5 5 6)\n;; 0",
      "bn": "(defun min-box-space (box-capacity item-volumes)\n;; এই ফাংশনটি একটি নির্দিষ্ট সেটের আইটেমগুলি সর্বোত্তমভাবে প্যাক করার পরে একটি বাক্সে ন্যূনতম অবশিষ্ট স্থান গণনা করে।\n;; প্রতিটি আইটেমের একটি নির্দিষ্ট ভলিউম থাকে, এবং বাক্সের একটি নির্দিষ্ট ক্ষমতা থাকে।\n;; ফাংশনটি বাক্সে সম্ভাব্য সবচেয়ে ছোট অবশিষ্ট স্থান ফেরত দেয়।\n;; উদাহরণ:\n;; >>> min-box-space 10 '(2 3 4)\n;; 1\n;; >>> min-box-space 15 '(5 5 6)\n;; 0",
      "bg": "(defun min-box-space (box-capacity item-volumes)\n;; Тази функция изчислява минималното оставащо пространство в кутия след оптимално опаковане на даден набор от предмети.\n;; Всеки предмет има определен обем, а кутията има фиксиран капацитет.\n;; Функцията връща най-малкото възможно оставащо пространство в кутията.\n;; Пример:\n;; >>> min-box-space 10 '(2 3 4)\n;; 1\n;; >>> min-box-space 15 '(5 5 6)\n;; 0",
      "zh": "(defun min-box-space (box-capacity item-volumes)\n;; 此函数计算在最佳地包装给定物品集后，箱子中剩余的最小空间。\n;; 每个物品都有一个特定的体积，箱子有一个固定的容量。\n;; 该函数返回箱子中可能剩余的最小空间。\n;; 示例:\n;; >>> min-box-space 10 '(2 3 4)\n;; 1\n;; >>> min-box-space 15 '(5 5 6)\n;; 0",
      "fr": "(defun min-box-space (box-capacity item-volumes)\n;; Cette fonction calcule l'espace restant minimum dans une boîte après avoir emballé de manière optimale un ensemble donné d'articles.\n;; Chaque article a un volume spécifique, et la boîte a une capacité fixe.\n;; La fonction retourne le plus petit espace restant possible dans la boîte.\n;; Exemple:\n;; >>> min-box-space 10 '(2 3 4)\n;; 1\n;; >>> min-box-space 15 '(5 5 6)\n;; 0",
      "de": "(defun min-box-space (box-capacity item-volumes)\n;; Diese Funktion berechnet den minimalen verbleibenden Platz in einer Box nach optimalem Packen einer gegebenen Menge von Gegenständen.\n;; Jeder Gegenstand hat ein bestimmtes Volumen, und die Box hat eine feste Kapazität.\n;; Die Funktion gibt den kleinstmöglichen verbleibenden Platz in der Box zurück.\n;; Beispiel:\n;; >>> min-box-space 10 '(2 3 4)\n;; 1\n;; >>> min-box-space 15 '(5 5 6)\n;; 0",
      "ha": "(defun min-box-space (box-capacity item-volumes)\n;; Wannan aikin yana lissafin ƙaramin sarari da ya rage a cikin akwati bayan an cika shi da wasu kayayyaki yadda ya kamata.\n;; Kowane kaya yana da takamaiman girma, kuma akwatin yana da iyaka dindindin.\n;; Aikin yana dawowa da ƙaramin yuwuwar sarari da ya rage a cikin akwatin.\n;; Misali:\n;; >>> min-box-space 10 '(2 3 4)\n;; 1\n;; >>> min-box-space 15 '(5 5 6)\n;; 0",
      "hi": "(defun min-box-space (box-capacity item-volumes)\n;; यह फ़ंक्शन एक दिए गए सेट के आइटम्स को अनुकूल रूप से पैक करने के बाद बॉक्स में न्यूनतम शेष स्थान की गणना करता है।\n;; प्रत्येक आइटम का एक विशिष्ट आयतन होता है, और बॉक्स की एक निश्चित क्षमता होती है।\n;; फ़ंक्शन बॉक्स में सबसे छोटे संभव शेष स्थान को लौटाता है।\n;; उदाहरण:\n;; >>> min-box-space 10 '(2 3 4)\n;; 1\n;; >>> min-box-space 15 '(5 5 6)\n;; 0",
      "hu": "(defun min-box-space (box-capacity item-volumes)\n;; Ez a függvény kiszámítja a minimális megmaradó helyet egy dobozban, miután optimálisan bepakoltunk egy adott halmaz elemeit.\n;; Minden elemnek van egy meghatározott térfogata, és a doboznak van egy rögzített kapacitása.\n;; A függvény visszaadja a lehető legkisebb megmaradó helyet a dobozban.\n;; Példa:\n;; >>> min-box-space 10 '(2 3 4)\n;; 1\n;; >>> min-box-space 15 '(5 5 6)\n;; 0"
    },
    "prompt_bertscore": {
      "sq": "0.9881191223887792",
      "hy": "0.971316779826657",
      "bn": "0.994249849099421",
      "bg": "1",
      "zh": "0.9915705238896414",
      "fr": "1",
      "de": "0.9937749238583666",
      "ha": "0.9635370236926635",
      "hi": "1",
      "hu": "0.9967488179232209"
    },
    "canonical_solution": "(let ((dp (make-array (1+ box-capacity) :initial-element 0)))\n(loop for item in item-volumes do\n(loop for v from box-capacity downto item do\n(setf (aref dp v) (max (aref dp v) (+ (aref dp (- v item)) item)))))\n(- box-capacity (reduce 'max dp))))",
    "instruction": {
      "en": "Write a Common Lisp function `(defun min-box-space (box-capacity item-volumes)` to solve the following problem:\nThis function calculates the minimum remaining space in a box after optimally packing a given set of items.\nEach item has a specific volume, and the box has a fixed capacity.\nThe function returns the smallest possible remaining space in the box.\nExample:\n>>> min-box-space 10 '(2 3 4)\n1\n>>> min-box-space 15 '(5 5 6)\n0",
      "sq": "Shkruani një funksion Common Lisp `(defun min-box-space (box-capacity item-volumes)` për të zgjidhur problemin e mëposhtëm:\nKy funksion llogarit hapësirën minimale të mbetur në një kuti pas paketimit optimal të një grupi të dhënë artikujsh.\nÇdo artikull ka një vëllim specifik, dhe kutia ka një kapacitet të caktuar.\nFunksioni kthen hapësirën më të vogël të mundshme të mbetur në kuti.\nShembull:\n>>> min-box-space 10 '(2 3 4)\n1\n>>> min-box-space 15 '(5 5 6)\n0",
      "hy": "Գրեք Common Lisp ֆունկցիա `(defun min-box-space (box-capacity item-volumes)` հետևյալ խնդիրը լուծելու համար:\nԱյս ֆունկցիան հաշվում է արկղում մնացած նվազագույն ազատ տարածքը՝ տրված իրերը օպտիմալ կերպով դասավորելուց հետո:\nՅուրաքանչյուր իր ունի որոշակի ծավալ, իսկ արկղը ունի ֆիքսված տարողություն:\nՖունկցիան վերադարձնում է արկղում մնացած հնարավոր նվազագույն տարածքը:\nՕրինակ:\n>>> min-box-space 10 '(2 3 4)\n1\n>>> min-box-space 15 '(5 5 6)\n0",
      "bn": "একটি Common Lisp ফাংশন `(defun min-box-space (box-capacity item-volumes)` লিখুন নিম্নলিখিত সমস্যার সমাধানের জন্য:\nএই ফাংশনটি একটি নির্দিষ্ট সেটের আইটেমগুলি সঠিকভাবে প্যাক করার পরে একটি বাক্সে ন্যূনতম অবশিষ্ট স্থান গণনা করে।\nপ্রতিটি আইটেমের একটি নির্দিষ্ট ভলিউম আছে, এবং বাক্সের একটি নির্দিষ্ট ক্ষমতা আছে।\nফাংশনটি বাক্সে সম্ভাব্য ন্যূনতম অবশিষ্ট স্থান প্রদান করে।\nউদাহরণ:\n>>> min-box-space 10 '(2 3 4)\n1\n>>> min-box-space 15 '(5 5 6)\n0",
      "bg": "Напишете функция на Common Lisp `(defun min-box-space (box-capacity item-volumes)` за решаване на следния проблем:\nТази функция изчислява минималното оставащо пространство в кутия след оптимално опаковане на даден набор от предмети.\nВсеки предмет има специфичен обем, а кутията има фиксиран капацитет.\nФункцията връща най-малкото възможно оставащо пространство в кутията.\nПример:\n>>> min-box-space 10 '(2 3 4)\n1\n>>> min-box-space 15 '(5 5 6)\n0",
      "zh": "编写一个 Common Lisp 函数 `(defun min-box-space (box-capacity item-volumes)` 来解决以下问题：\n此函数计算在最佳方式包装给定物品集后，盒子中剩余的最小空间。\n每个物品都有特定的体积，盒子有固定的容量。\n函数返回盒子中可能的最小剩余空间。\n示例:",
      "fr": "Écrire une fonction Common Lisp `(defun min-box-space (box-capacity item-volumes)` pour résoudre le problème suivant :\nCette fonction calcule l'espace restant minimum dans une boîte après avoir emballé de manière optimale un ensemble donné d'articles.\nChaque article a un volume spécifique, et la boîte a une capacité fixe.\nLa fonction renvoie le plus petit espace restant possible dans la boîte.\nExemple:\n>>> min-box-space 10 '(2 3 4)\n1\n>>> min-box-space 15 '(5 5 6)\n0",
      "de": "Schreiben Sie eine Common Lisp-Funktion `(defun min-box-space (box-capacity item-volumes)` um das folgende Problem zu lösen:\nDiese Funktion berechnet den minimalen verbleibenden Raum in einer Box, nachdem eine gegebene Menge von Gegenständen optimal verpackt wurde.\nJeder Gegenstand hat ein spezifisches Volumen, und die Box hat eine feste Kapazität.\nDie Funktion gibt den kleinstmöglichen verbleibenden Raum in der Box zurück.\nBeispiel:\n>>> min-box-space 10 '(2 3 4)\n1\n>>> min-box-space 15 '(5 5 6)\n0",
      "ha": "Rubuta aikin Common Lisp `(defun min-box-space (box-capacity item-volumes)` don warware matsalar da ke gaba:\nWannan aikin yana ƙididdige ƙaramin sarari da ya rage a cikin akwati bayan an cika shi da kayan da aka bayar yadda ya kamata.\nKowane abu yana da takamaiman girma, kuma akwatin yana da iyaka dindindin.\nAikin yana mayar da ƙaramin yuwuwar sarari da ya rage a cikin akwatin.\nMisali:\n>>> min-box-space 10 '(2 3 4)\n1\n>>> min-box-space 15 '(5 5 6)\n0",
      "hi": "एक Common Lisp फ़ंक्शन `(defun min-box-space (box-capacity item-volumes)` लिखें ताकि निम्नलिखित समस्या का समाधान हो सके:\nयह फ़ंक्शन दिए गए वस्तुओं के सेट को अनुकूल रूप से पैक करने के बाद बॉक्स में न्यूनतम शेष स्थान की गणना करता है।\nप्रत्येक वस्तु का एक विशिष्ट आयतन होता है, और बॉक्स की एक निश्चित क्षमता होती है।\nफ़ंक्शन बॉक्स में सबसे छोटा संभव शेष स्थान लौटाता है।\nउदाहरण:\n>>> min-box-space 10 '(2 3 4)\n1\n>>> min-box-space 15 '(5 5 6)\n0",
      "hu": "Írj egy Common Lisp függvényt `(defun min-box-space (box-capacity item-volumes)` a következő probléma megoldására:\nEz a függvény kiszámítja a minimális fennmaradó helyet egy dobozban, miután optimálisan bepakoltuk a megadott tárgyakat.\nMinden tárgynak van egy adott térfogata, és a doboznak van egy fix kapacitása.\nA függvény visszaadja a dobozban maradó legkisebb lehetséges helyet.\nPélda:\n>>> min-box-space 10 '(2 3 4)\n1\n>>> min-box-space 15 '(5 5 6)\n0"
    },
    "instruction_bertscore": {
      "sq": "0.9942887806541039",
      "hy": "0.8902271185514501",
      "bn": "0.9739281734461226",
      "bg": "0.9189292086109914",
      "zh": "0.9119596658012392",
      "fr": "1",
      "de": "0.9888375684769823",
      "ha": "0.9674383230065697",
      "hi": "0.9213435608924705",
      "hu": "0.9906653652432654"
    },
    "level": "middle",
    "test": "(defun test-min-box-space ()\n(assert (equal (min-box-space 20 '(5 5 10 6)) 0))\n(assert (equal (min-box-space 25 '(7 8 5 10)) 0))\n(assert (equal (min-box-space 12 '(3 2 2 5)) 0))\n(assert (equal (min-box-space 30 '(10 10 12)) 8))\n(assert (equal (min-box-space 8 '(1 2 3 4)) 0))\n(assert (equal (min-box-space 18 '(2 5 6 8)) 2))\n(assert (equal (min-box-space 11 '(1 2 3)) 5)))\n\n(test-min-box-space)",
    "entry_point": "min-box-space",
    "signature": "(defun min-box-space (box-capacity item-volumes)",
    "docstring": {
      "en": "This function calculates the minimum remaining space in a box after optimally packing a given set of items.\nEach item has a specific volume, and the box has a fixed capacity.\nThe function returns the smallest possible remaining space in the box.\nExample:\n>>> min-box-space 10 '(2 3 4)\n1\n>>> min-box-space 15 '(5 5 6)\n0",
      "sq": "Kjo funksion llogarit hapësirën minimale të mbetur në një kuti pas paketimit optimal të një grupi të dhënë sendesh. \nÇdo send ka një vëllim specifik, dhe kutia ka një kapacitet të caktuar. \nFunksioni kthen hapësirën më të vogël të mundshme të mbetur në kuti. \nShembull:\n>>> min-box-space 10 '(2 3 4)\n1\n>>> min-box-space 15 '(5 5 6)\n0",
      "hy": "Այս ֆունկցիան հաշվարկում է արկղում մնացած նվազագույն տարածքը՝ տրված իրերի հավաքածուն օպտիմալ կերպով փաթեթավորելուց հետո: \nՅուրաքանչյուր իր ունի որոշակի ծավալ, և արկղը ունի ֆիքսված տարողություն: \nՖունկցիան վերադարձնում է արկղում հնարավոր ամենափոքր մնացած տարածքը:\nՕրինակ:\n>>> min-box-space 10 '(2 3 4)\n1\n>>> min-box-space 15 '(5 5 6)\n0",
      "bn": "এই ফাংশনটি একটি নির্দিষ্ট সেটের আইটেমগুলি সর্বোত্তমভাবে প্যাক করার পরে একটি বাক্সে অবশিষ্ট সর্বনিম্ন স্থান গণনা করে। \nপ্রতিটি আইটেমের একটি নির্দিষ্ট আয়তন থাকে, এবং বাক্সটির একটি নির্দিষ্ট ক্ষমতা থাকে। \nফাংশনটি বাক্সে সম্ভাব্য সবচেয়ে ছোট অবশিষ্ট স্থানটি ফেরত দেয়। \nউদাহরণ:\n>>> min-box-space 10 '(2 3 4)\n1\n>>> min-box-space 15 '(5 5 6)\n0",
      "bg": "Тази функция изчислява минималното оставащо пространство в кутия след оптимално опаковане на даден набор от предмети. Всеки предмет има определен обем, а кутията има фиксиран капацитет. Функцията връща най-малкото възможно оставащо пространство в кутията. Пример:\n>>> min-box-space 10 '(2 3 4)\n1\n>>> min-box-space 15 '(5 5 6)\n0",
      "zh": "该函数计算在最优地包装给定物品集后，箱子中剩余的最小空间。  \n每个物品都有特定的体积，箱子有固定的容量。  \n该函数返回箱子中可能的最小剩余空间。  \n示例：  \n>>> min-box-space 10 '(2 3 4)  \n1  \n>>> min-box-space 15 '(5 5 6)  \n0  ",
      "fr": "Cette fonction calcule l'espace restant minimum dans une boîte après avoir emballé de manière optimale un ensemble donné d'articles.\nChaque article a un volume spécifique, et la boîte a une capacité fixe.\nLa fonction renvoie le plus petit espace restant possible dans la boîte.\nExemple :\n>>> min-box-space 10 '(2 3 4)\n1\n>>> min-box-space 15 '(5 5 6)\n0",
      "de": "Diese Funktion berechnet den minimal verbleibenden Platz in einer Box, nachdem eine gegebene Menge von Gegenständen optimal verpackt wurde. Jeder Gegenstand hat ein bestimmtes Volumen, und die Box hat eine feste Kapazität. Die Funktion gibt den kleinstmöglichen verbleibenden Platz in der Box zurück. Beispiel:\n>>> min-box-space 10 '(2 3 4)\n1\n>>> min-box-space 15 '(5 5 6)\n0",
      "ha": "Wannan aikin yana ƙididdige ƙaramin sararin da ya rage a cikin akwati bayan an cika shi da kyau da wasu abubuwa da aka bayar.\nKowane abu yana da takamaiman girma, kuma akwatin yana da iyakar ƙarfin da aka kafa.\nAikin yana dawowa da ƙaramin yuwuwar sararin da ya rage a cikin akwatin.\n\nMisali:\n>>> min-box-space 10 '(2 3 4)\n1\n>>> min-box-space 15 '(5 5 6)\n0",
      "hi": "यह फ़ंक्शन दिए गए आइटम्स के सेट को सबसे अच्छे तरीके से पैक करने के बाद बॉक्स में बची हुई न्यूनतम जगह की गणना करता है। \nप्रत्येक आइटम का एक विशिष्ट आयतन होता है, और बॉक्स की एक निश्चित क्षमता होती है। \nफ़ंक्शन बॉक्स में बची हुई सबसे छोटी संभव जगह को लौटाता है। \nउदाहरण:\n>>> min-box-space 10 '(2 3 4)\n1\n>>> min-box-space 15 '(5 5 6)\n0",
      "hu": "Ez a függvény kiszámítja a minimális fennmaradó helyet egy dobozban, miután optimálisan bepakoltuk a megadott tárgyakat.\nMinden tárgynak van egy adott térfogata, és a doboznak van egy rögzített kapacitása.\nA függvény visszaadja a lehető legkisebb fennmaradó helyet a dobozban.\nPélda:\n>>> min-box-space 10 '(2 3 4)\n1\n>>> min-box-space 15 '(5 5 6)\n0"
    },
    "docstring_bertscore": {
      "sq": "0.9930509161194945",
      "hy": "1",
      "bn": "0.9879451221749926",
      "bg": "1",
      "zh": "0.9834975893132405",
      "fr": "1",
      "de": "0.977067129357617",
      "ha": "0.9249224830979571",
      "hi": "0.993987855626836",
      "hu": "0.9865004834137259"
    }
  },
  {
    "task_id": "Common Lisp/41",
    "prompt": {
      "en": "(defun calculate-expression (a b c)\n  ;; Computes the value of the expression (a+b)*c for given integers a, b, and c.\n  ;; Returns the result of the computation.\n  ;; Example:\n  ;; >>> (calculate-expression 1 2 3)\n  ;; 9\n  ;; >>> (calculate-expression -1 2 3)\n  ;; 3\n  ;; >>> (calculate-expression 0 0 0)\n  ;; 0",
      "sq": "(defun calculate-expression (a b c)\n  ;; Llogarit vlerën e shprehjes (a+b)*c për numrat e dhënë të plotë a, b, dhe c.\n  ;; Kthen rezultatin e llogaritjes.\n  ;; Shembull:\n  ;; >>> (calculate-expression 1 2 3)\n  ;; 9\n  ;; >>> (calculate-expression -1 2 3)\n  ;; 3\n  ;; >>> (calculate-expression 0 0 0)\n  ;; 0",
      "hy": "(defun calculate-expression (a b c)\n  ;; Հաշվում է արտահայտության (a+b)*c արժեքը տրված ամբողջ թվերի a, b և c համար:\n  ;; Վերադարձնում է հաշվարկի արդյունքը:\n  ;; Օրինակ:\n  ;; >>> (calculate-expression 1 2 3)\n  ;; 9\n  ;; >>> (calculate-expression -1 2 3)\n  ;; 3\n  ;; >>> (calculate-expression 0 0 0)\n  ;; 0",
      "bn": "(defun calculate-expression (a b c)\n  ;; প্রদত্ত পূর্ণসংখ্যা a, b, এবং c এর জন্য (a+b)*c অভিব্যক্তির মান গণনা করে।\n  ;; গণনার ফলাফল প্রদান করে।\n  ;; উদাহরণ:\n  ;; >>> (calculate-expression 1 2 3)\n  ;; 9\n  ;; >>> (calculate-expression -1 2 3)\n  ;; 3\n  ;; >>> (calculate-expression 0 0 0)\n  ;; 0",
      "bg": "(defun calculate-expression (a b c)\n  ;; Изчислява стойността на израза (a+b)*c за дадени цели числа a, b и c.\n  ;; Връща резултата от изчислението.\n  ;; Пример:\n  ;; >>> (calculate-expression 1 2 3)\n  ;; 9\n  ;; >>> (calculate-expression -1 2 3)\n  ;; 3\n  ;; >>> (calculate-expression 0 0 0)\n  ;; 0",
      "zh": "(defun calculate-expression (a b c)\n  ;; 计算表达式 (a+b)*c 的值，给定整数 a, b 和 c。\n  ;; 返回计算结果。\n  ;; 例子:\n  ;; >>> (calculate-expression 1 2 3)\n  ;; 9\n  ;; >>> (calculate-expression -1 2 3)\n  ;; 3\n  ;; >>> (calculate-expression 0 0 0)\n  ;; 0",
      "fr": "(defun calculate-expression (a b c)\n  ;; Calcule la valeur de l'expression (a+b)*c pour les entiers donnés a, b, et c.\n  ;; Renvoie le résultat du calcul.\n  ;; Exemple:\n  ;; >>> (calculate-expression 1 2 3)\n  ;; 9\n  ;; >>> (calculate-expression -1 2 3)\n  ;; 3\n  ;; >>> (calculate-expression 0 0 0)\n  ;; 0",
      "de": "(defun calculate-expression (a b c)\n  ;; Berechnet den Wert des Ausdrucks (a+b)*c für gegebene ganze Zahlen a, b und c.\n  ;; Gibt das Ergebnis der Berechnung zurück.\n  ;; Beispiel:\n  ;; >>> (calculate-expression 1 2 3)\n  ;; 9\n  ;; >>> (calculate-expression -1 2 3)\n  ;; 3\n  ;; >>> (calculate-expression 0 0 0)\n  ;; 0",
      "ha": "(defun calculate-expression (a b c)\n  ;; Lissafi darajar bayyana (a+b)*c don lambobin a, b, da c da aka bayar.\n  ;; Mayar da sakamakon lissafin.\n  ;; Misali:\n  ;; >>> (calculate-expression 1 2 3)\n  ;; 9\n  ;; >>> (calculate-expression -1 2 3)\n  ;; 3\n  ;; >>> (calculate-expression 0 0 0)\n  ;; 0",
      "hi": "(defun calculate-expression (a b c)\n  ;; दिए गए पूर्णांक a, b, और c के लिए अभिव्यक्ति (a+b)*c का मान गणना करता है।\n  ;; गणना के परिणाम को लौटाता है।\n  ;; उदाहरण:\n  ;; >>> (calculate-expression 1 2 3)\n  ;; 9\n  ;; >>> (calculate-expression -1 2 3)\n  ;; 3\n  ;; >>> (calculate-expression 0 0 0)\n  ;; 0",
      "hu": "(defun calculate-expression (a b c)\n  ;; Kiszámítja a (a+b)*c kifejezés értékét a megadott egész számok a, b és c esetén.\n  ;; Visszaadja a számítás eredményét.\n  ;; Példa:\n  ;; >>> (calculate-expression 1 2 3)\n  ;; 9\n  ;; >>> (calculate-expression -1 2 3)\n  ;; 3\n  ;; >>> (calculate-expression 0 0 0)\n  ;; 0"
    },
    "prompt_bertscore": {
      "sq": "0.9867950522688006",
      "hy": "0.9886105339514595",
      "bn": "0.9886105339514595",
      "bg": "0.9926906006082972",
      "zh": "0.9753642711010049",
      "fr": "0.9886105339514595",
      "de": "0.9926906006082972",
      "ha": "0.979276296455487",
      "hi": "0.9886105339514595",
      "hu": "0.9886105339514595"
    },
    "canonical_solution": "  (* (+ a b) c))",
    "instruction": {
      "en": "Write a Common Lisp function `(defun calculate-expression (a b c)` to solve the following problem:   Computes the value of the expression (a+b)*c for given integers a, b, and c.\n   Returns the result of the computation.\n   Example:\n   >>> (calculate-expression 1 2 3)\n   9\n   >>> (calculate-expression -1 2 3)\n   3\n   >>> (calculate-expression 0 0 0)\n   0",
      "sq": "Shkruani një funksion Common Lisp `(defun calculate-expression (a b c)` për të zgjidhur problemin në vijim: Llogarit vlerën e shprehjes (a+b)*c për numrat e plotë të dhënë a, b, dhe c.\n   Kthen rezultatin e llogaritjes.\n   Shembull:\n   >>> (calculate-expression 1 2 3)\n   9\n   >>> (calculate-expression -1 2 3)\n   3\n   >>> (calculate-expression 0 0 0)\n   0",
      "hy": "Գրեք Common Lisp ֆունկցիա `(defun calculate-expression (a b c)` հետևյալ խնդիրը լուծելու համար:   Հաշվում է արտահայտության (a+b)*c արժեքը տրված ամբողջ թվերի a, b և c համար:\n   Վերադարձնում է հաշվարկի արդյունքը:\n   Օրինակ:\n   >>> (calculate-expression 1 2 3)\n   9\n   >>> (calculate-expression -1 2 3)\n   3\n   >>> (calculate-expression 0 0 0)\n   0",
      "bn": "একটি Common Lisp ফাংশন `(defun calculate-expression (a b c)` লিখুন নিম্নলিখিত সমস্যার সমাধানের জন্য: প্রদত্ত পূর্ণসংখ্যা a, b, এবং c এর জন্য অভিব্যক্তি (a+b)*c এর মান গণনা করে। \n   গণনার ফলাফল প্রদান করে।\n   উদাহরণ:\n   >>> (calculate-expression 1 2 3)\n   9\n   >>> (calculate-expression -1 2 3)\n   3\n   >>> (calculate-expression 0 0 0)\n   0",
      "bg": "Напишете функция на Common Lisp `(defun calculate-expression (a b c)` за решаване на следния проблем:   Изчислява стойността на израза (a+b)*c за дадени цели числа a, b и c.\n   Връща резултата от изчислението.\n   Пример:\n   >>> (calculate-expression 1 2 3)\n   9\n   >>> (calculate-expression -1 2 3)\n   3\n   >>> (calculate-expression 0 0 0)\n   0",
      "zh": "编写一个 Common Lisp 函数 `(defun calculate-expression (a b c)` 来解决以下问题：计算给定整数 a、b 和 c 的表达式 (a+b)*c 的值。\n返回计算结果。\n示例:\n>>> (calculate-expression 1 2 3)\n9\n>>> (calculate-expression -1 2 3)\n3\n>>> (calculate-expression 0 0 0)\n0",
      "fr": "Écrire une fonction Common Lisp `(defun calculate-expression (a b c)` pour résoudre le problème suivant :   Calcule la valeur de l'expression (a+b)*c pour des entiers donnés a, b, et c.\n   Retourne le résultat du calcul.\n   Exemple:\n   >>> (calculate-expression 1 2 3)\n   9\n   >>> (calculate-expression -1 2 3)\n   3\n   >>> (calculate-expression 0 0 0)\n   0",
      "de": "Schreiben Sie eine Common Lisp-Funktion `(defun calculate-expression (a b c)` um das folgende Problem zu lösen: Berechnet den Wert des Ausdrucks (a+b)*c für gegebene ganze Zahlen a, b und c.\n   Gibt das Ergebnis der Berechnung zurück.\n   Beispiel:\n   >>> (calculate-expression 1 2 3)\n   9\n   >>> (calculate-expression -1 2 3)\n   3\n   >>> (calculate-expression 0 0 0)\n   0",
      "ha": "Rubuta aikin Common Lisp `(defun calculate-expression (a b c)` don warware matsalar mai zuwa:   Lissafa ƙimar abin da aka faɗa (a+b)*c don lambobin cikakku a, b, da c da aka bayar.\n   Mayar da sakamakon lissafin.\n   Misali:\n   >>> (calculate-expression 1 2 3)\n   9\n   >>> (calculate-expression -1 2 3)\n   3\n   >>> (calculate-expression 0 0 0)\n   0",
      "hi": "एक Common Lisp फ़ंक्शन `(defun calculate-expression (a b c)` लिखें ताकि निम्नलिखित समस्या का समाधान हो सके:   दिए गए पूर्णांक a, b, और c के लिए अभिव्यक्ति (a+b)*c का मान गणना करता है।\n   गणना के परिणाम को लौटाता है।\n   उदाहरण:\n   >>> (calculate-expression 1 2 3)\n   9\n   >>> (calculate-expression -1 2 3)\n   3\n   >>> (calculate-expression 0 0 0)\n   0",
      "hu": "Írj egy Common Lisp függvényt `(defun calculate-expression (a b c)` a következő probléma megoldására:   Számítsa ki a kifejezés (a+b)*c értékét adott egész számok a, b és c esetén.\n   Visszaadja a számítás eredményét.\n   Példa:\n   >>> (calculate-expression 1 2 3)\n   9\n   >>> (calculate-expression -1 2 3)\n   3\n   >>> (calculate-expression 0 0 0)\n   0"
    },
    "instruction_bertscore": {
      "sq": "0.9841985559279126",
      "hy": "0.9900353096746227",
      "bn": "0.9841985559279126",
      "bg": "0.9852445435144424",
      "zh": "0.9798298793274313",
      "fr": "0.9841340010540762",
      "de": "0.9900353096746227",
      "ha": "0.9720141710944704",
      "hi": "0.9865261067328794",
      "hu": "0.9877077588696559"
    },
    "level": "easy",
    "test": "(defun check-calculate-expression ()\n  (assert (= (calculate-expression 1 2 3) 9))\n  (assert (= (calculate-expression -1 2 3) 3))\n  (assert (= (calculate-expression 0 0 0) 0))\n  (assert (= (calculate-expression 100 -100 1) 0))\n  (assert (= (calculate-expression -5 -5 -5) 50))\n  (assert (= (calculate-expression 10 20 30) 900))\n  (assert (= (calculate-expression 0 10 -2) -20)))",
    "entry_point": "calculate-expression",
    "signature": "(defun calculate-expression (a b c)",
    "docstring": {
      "en": "   Computes the value of the expression (a+b)*c for given integers a, b, and c.\n   Returns the result of the computation.\n   Example:\n   >>> (calculate-expression 1 2 3)\n   9\n   >>> (calculate-expression -1 2 3)\n   3\n   >>> (calculate-expression 0 0 0)\n   0",
      "sq": "   Llogarit vlerën e shprehjes (a+b)*c për numrat e dhënë të plotë a, b, dhe c.\n   Kthen rezultatin e llogaritjes.\n   Shembull:\n   >>> (calculate-expression 1 2 3)\n   9\n   >>> (calculate-expression -1 2 3)\n   3\n   >>> (calculate-expression 0 0 0)\n   0",
      "hy": "   Հաշվում է արտահայտության (a+b)*c արժեքը տրված ամբողջ թվերի a, b և c համար:\n   Վերադարձնում է հաշվարկի արդյունքը:\n   Օրինակ:\n   >>> (calculate-expression 1 2 3)\n   9\n   >>> (calculate-expression -1 2 3)\n   3\n   >>> (calculate-expression 0 0 0)\n   0",
      "bn": "   প্রদত্ত পূর্ণসংখ্যা a, b, এবং c এর জন্য (a+b)*c প্রকাশের মান গণনা করে।\n   গণনার ফলাফল প্রদান করে।\n   উদাহরণ:\n   >>> (calculate-expression 1 2 3)\n   9\n   >>> (calculate-expression -1 2 3)\n   3\n   >>> (calculate-expression 0 0 0)\n   0",
      "bg": "   Изчислява стойността на израза (a+b)*c за дадени цели числа a, b и c.  \nВръща резултата от изчислението.  \nПример:  \n>>> (calculate-expression 1 2 3)  \n9  \n>>> (calculate-expression -1 2 3)  \n3  \n>>> (calculate-expression 0 0 0)  \n0",
      "zh": "   计算给定整数 a、b 和 c 的表达式 (a+b)*c 的值。  \n返回计算结果。  \n示例：  \n>>> (calculate-expression 1 2 3)  \n9  \n>>> (calculate-expression -1 2 3)  \n3  \n>>> (calculate-expression 0 0 0)  \n0",
      "fr": "   Calcule la valeur de l'expression (a+b)*c pour des entiers donnés a, b et c.\nRenvoie le résultat du calcul.\nExemple :\n>>> (calculate-expression 1 2 3)\n9\n>>> (calculate-expression -1 2 3)\n3\n>>> (calculate-expression 0 0 0)\n0",
      "de": "   Berechnet den Wert des Ausdrucks (a+b)*c für gegebene ganze Zahlen a, b und c.\nGibt das Ergebnis der Berechnung zurück.\nBeispiel:\n>>> (calculate-expression 1 2 3)\n9\n>>> (calculate-expression -1 2 3)\n3\n>>> (calculate-expression 0 0 0)\n0",
      "ha": "   Lissafi darajar bayyana (a+b)*c don lambobin a, b, da c da aka bayar.\n   Mayar da sakamakon lissafin.\n   Misali:\n   >>> (calculate-expression 1 2 3)\n   9\n   >>> (calculate-expression -1 2 3)\n   3\n   >>> (calculate-expression 0 0 0)\n   0",
      "hi": "   दिए गए पूर्णांक a, b, और c के लिए अभिव्यक्ति (a+b)*c का मान गणना करता है।\n   गणना के परिणाम को लौटाता है।\n   उदाहरण:\n   >>> (calculate-expression 1 2 3)\n   9\n   >>> (calculate-expression -1 2 3)\n   3\n   >>> (calculate-expression 0 0 0)\n   0",
      "hu": "   Számítja a kifejezés értékét (a+b)*c adott egész számok a, b és c esetén. Visszaadja a számítás eredményét. Példa: >>> (calculate-expression 1 2 3) 9 >>> (calculate-expression -1 2 3) 3 >>> (calculate-expression 0 0 0) 0"
    },
    "docstring_bertscore": {
      "sq": "0.9749109965714833",
      "hy": "0.985066173432273",
      "bn": "0.9386818082226248",
      "bg": "0.985066173432273",
      "zh": "0.9717778009410389",
      "fr": "0.9809408190485593",
      "de": "0.985066173432273",
      "ha": "0.9655884782679919",
      "hi": "0.97820011705104",
      "hu": "0.985066173432273"
    }
  },
  {
    "task_id": "Common Lisp/42",
    "prompt": {
      "en": "(defun char-to-ascii (char)\n  ;; Converts a single visible character (excluding space) to its ASCII code.\n  ;; Input: A character (not a string) that is visible and not a space.\n  ;; Output: An integer representing the ASCII code of the input character.\n  ;; Example:\n  ;; >>> (char-to-ascii #\\A)\n  ;; 65\n  ;; >>> (char-to-ascii #\\!)\n  ;; 33",
      "sq": "(defun char-to-ascii (char)\n  ;; Konverton një karakter të vetëm të dukshëm (përveç hapësirës) në kodin e tij ASCII.\n  ;; Hyrja: Një karakter (jo një varg) që është i dukshëm dhe jo një hapësirë.\n  ;; Dalja: Një numër i plotë që përfaqëson kodin ASCII të karakterit të dhënë.\n  ;; Shembull:\n  ;; >>> (char-to-ascii #\\A)\n  ;; 65\n  ;; >>> (char-to-ascii #\\!)\n  ;; 33",
      "hy": "(defun char-to-ascii (char)\n  ;; Վերածում է մեկ տեսանելի սիմվոլը (բացառությամբ բացատ) իր ASCII կոդին։\n  ;; Մուտք: Սիմվոլ (ոչ տող), որը տեսանելի է և ոչ բացատ։\n  ;; Ելք: Թիվ, որը ներկայացնում է մուտքագրված սիմվոլի ASCII կոդը։\n  ;; Օրինակ:\n  ;; >>> (char-to-ascii #\\A)\n  ;; 65\n  ;; >>> (char-to-ascii #\\!)\n  ;; 33",
      "bn": "(defun char-to-ascii (char)\n  ;; একটি একক দৃশ্যমান অক্ষর (স্পেস বাদে) এর ASCII কোডে রূপান্তর করে।\n  ;; ইনপুট: একটি অক্ষর (স্ট্রিং নয়) যা দৃশ্যমান এবং স্পেস নয়।\n  ;; আউটপুট: ইনপুট অক্ষরের ASCII কোডের প্রতিনিধিত্বকারী একটি পূর্ণসংখ্যা।\n  ;; উদাহরণ:\n  ;; >>> (char-to-ascii #\\A)\n  ;; 65\n  ;; >>> (char-to-ascii #\\!)\n  ;; 33",
      "bg": "(defun char-to-ascii (char)\n  ;; Преобразува един видим символ (без интервал) в неговия ASCII код.\n  ;; Вход: Символ (не низ), който е видим и не е интервал.\n  ;; Изход: Цяло число, представляващо ASCII кода на входния символ.\n  ;; Пример:\n  ;; >>> (char-to-ascii #\\A)\n  ;; 65\n  ;; >>> (char-to-ascii #\\!)\n  ;; 33",
      "zh": "(defun char-to-ascii (char)\n  ;; 将单个可见字符（不包括空格）转换为其 ASCII 码。\n  ;; 输入：一个可见且不是空格的字符（不是字符串）。\n  ;; 输出：一个整数，表示输入字符的 ASCII 码。\n  ;; 示例:\n  ;; >>> (char-to-ascii #\\A)\n  ;; 65\n  ;; >>> (char-to-ascii #\\!)\n  ;; 33",
      "fr": "(defun char-to-ascii (char)\n  ;; Convertit un seul caractère visible (à l'exclusion de l'espace) en son code ASCII.\n  ;; Entrée : Un caractère (pas une chaîne) qui est visible et n'est pas un espace.\n  ;; Sortie : Un entier représentant le code ASCII du caractère d'entrée.\n  ;; Exemple :\n  ;; >>> (char-to-ascii #\\A)\n  ;; 65\n  ;; >>> (char-to-ascii #\\!)\n  ;; 33",
      "de": "(defun char-to-ascii (char)\n  ;; Konvertiert ein einzelnes sichtbares Zeichen (ohne Leerzeichen) in seinen ASCII-Code.\n  ;; Eingabe: Ein Zeichen (kein String), das sichtbar ist und kein Leerzeichen.\n  ;; Ausgabe: Eine ganze Zahl, die den ASCII-Code des Eingabezeichens darstellt.\n  ;; Beispiel:\n  ;; >>> (char-to-ascii #\\A)\n  ;; 65\n  ;; >>> (char-to-ascii #\\!)\n  ;; 33",
      "ha": "(defun char-to-ascii (char)\n  ;; Canza wata harafi mai gani guda daya (ban da sarari) zuwa lambar ASCII dinta.\n  ;; Shigarwa: Wata harafi (ba kirtani ba) wanda ake gani kuma ba sarari ba.\n  ;; Fitarwa: Wani lamba wanda yake wakiltar lambar ASCII na harafin da aka shigar.\n  ;; Misali:\n  ;; >>> (char-to-ascii #\\A)\n  ;; 65\n  ;; >>> (char-to-ascii #\\!)\n  ;; 33",
      "hi": "(defun char-to-ascii (char)\n  ;; एकल दृश्य वर्ण (स्पेस को छोड़कर) को उसके ASCII कोड में परिवर्तित करता है।\n  ;; इनपुट: एक वर्ण (स्ट्रिंग नहीं) जो दृश्य है और स्पेस नहीं है।\n  ;; आउटपुट: इनपुट वर्ण के ASCII कोड का प्रतिनिधित्व करने वाला एक पूर्णांक।\n  ;; उदाहरण:\n  ;; >>> (char-to-ascii #\\A)\n  ;; 65\n  ;; >>> (char-to-ascii #\\!)\n  ;; 33",
      "hu": "(defun char-to-ascii (char)\n  ;; Egyetlen látható karaktert (kivéve a szóközt) alakít át ASCII kóddá.\n  ;; Bemenet: Egy karakter (nem egy string), amely látható és nem szóköz.\n  ;; Kimenet: Egy egész szám, amely a bemeneti karakter ASCII kódját képviseli.\n  ;; Példa:\n  ;; >>> (char-to-ascii #\\A)\n  ;; 65\n  ;; >>> (char-to-ascii #\\!)\n  ;; 33"
    },
    "prompt_bertscore": {
      "sq": "0.9893639389867248",
      "hy": "0.9937061977465286",
      "bn": "1",
      "bg": "0.9948610347818654",
      "zh": "0.9655525261690245",
      "fr": "1",
      "de": "0.9971464759460528",
      "ha": "0.9615600555102233",
      "hi": "1",
      "hu": "0.9988550944837149"
    },
    "canonical_solution": "  (char-code char))",
    "instruction": {
      "en": "Write a Common Lisp function `defun char-to-ascii (char)` to solve the following problem: Converts a single visible character (excluding space) to its ASCII code.\n Input: A character (not a string) that is visible and not a space.\n Output: An integer representing the ASCII code of the input character.\n Example:\n >>> (char-to-ascii #\\A)\n 65\n >>> (char-to-ascii #\\!)\n 33",
      "sq": "Shkruani një funksion Common Lisp `defun char-to-ascii (char)` për të zgjidhur problemin e mëposhtëm: Konverton një karakter të vetëm të dukshëm (përjashtuar hapësirën) në kodin e tij ASCII.\n Hyrja: Një karakter (jo një varg) që është i dukshëm dhe jo një hapësirë.\n Dalja: Një numër i plotë që përfaqëson kodin ASCII të karakterit të hyrjes.\n Shembull:\n >>> (char-to-ascii #\\A)\n 65\n >>> (char-to-ascii #\\!)\n 33",
      "hy": "Գրեք Common Lisp ֆունկցիա `defun char-to-ascii (char)` հետևյալ խնդիրը լուծելու համար՝ Փոխակերպում է մեկ տեսանելի սիմվոլ (բացառությամբ բացատ) իր ASCII կոդին:\n Մուտք՝ Սիմվոլ (ոչ տող), որը տեսանելի է և ոչ բացատ:\n Ելք՝ Թիվ, որը ներկայացնում է մուտքային սիմվոլի ASCII կոդը:\n Օրինակ:\n >>> (char-to-ascii #\\A)\n 65\n >>> (char-to-ascii #\\!)\n 33",
      "bn": "Common Lisp ফাংশন `defun char-to-ascii (char)` লিখুন নিম্নলিখিত সমস্যার সমাধানের জন্য: একটি একক দৃশ্যমান অক্ষর (স্পেস বাদে) এর ASCII কোডে রূপান্তর করে।\n ইনপুট: একটি অক্ষর (স্ট্রিং নয়) যা দৃশ্যমান এবং স্পেস নয়।\n আউটপুট: ইনপুট অক্ষরের ASCII কোডের একটি পূর্ণসংখ্যা।\n উদাহরণ:\n >>> (char-to-ascii #\\A)\n 65\n >>> (char-to-ascii #\\!)\n 33",
      "bg": "Напишете функция на Common Lisp `defun char-to-ascii (char)` за решаване на следния проблем: Преобразува един видим символ (с изключение на интервал) в неговия ASCII код.\n Вход: Символ (не низ), който е видим и не е интервал.\n Изход: Цяло число, представляващо ASCII кода на входния символ.\n Пример:\n >>> (char-to-ascii #\\A)\n 65\n >>> (char-to-ascii #\\!)\n 33",
      "zh": "编写一个 Common Lisp 函数 `defun char-to-ascii (char)` 来解决以下问题：将单个可见字符（不包括空格）转换为其 ASCII 码。\n 输入：一个可见且不是空格的字符（不是字符串）。\n 输出：一个整数，表示输入字符的 ASCII 码。\n 示例:\n >>> (char-to-ascii #\\A)\n 65\n >>> (char-to-ascii #\\!)\n 33",
      "fr": "Écrire une fonction Common Lisp `defun char-to-ascii (char)` pour résoudre le problème suivant : Convertit un seul caractère visible (à l'exclusion de l'espace) en son code ASCII.\n Entrée : Un caractère (pas une chaîne) qui est visible et n'est pas un espace.\n Sortie : Un entier représentant le code ASCII du caractère d'entrée.\n Exemple :\n >>> (char-to-ascii #\\A)\n 65\n >>> (char-to-ascii #\\!)\n 33",
      "de": "Schreiben Sie eine Common Lisp-Funktion `defun char-to-ascii (char)`, um das folgende Problem zu lösen: Wandelt ein einzelnes sichtbares Zeichen (ohne Leerzeichen) in seinen ASCII-Code um.\n Eingabe: Ein Zeichen (kein String), das sichtbar ist und kein Leerzeichen.\n Ausgabe: Eine ganze Zahl, die den ASCII-Code des Eingabezeichens darstellt.\n Beispiel:\n >>> (char-to-ascii #\\A)\n 65\n >>> (char-to-ascii #\\!)\n 33",
      "ha": "Rubuta aikin Common Lisp `defun char-to-ascii (char)` don warware matsalar mai zuwa: Canza alamar gani guda ɗaya (ban da sarari) zuwa lambar ASCII ɗinta. \n Shigarwa: Wata alama (ba igiya ba) wadda ake iya gani kuma ba sarari ba.\n Fitarwa: Lamba mai wakiltar lambar ASCII na alamar da aka shigar.\n Misali:\n >>> (char-to-ascii #\\A)\n 65\n >>> (char-to-ascii #\\!)\n 33",
      "hi": "एक Common Lisp फ़ंक्शन `defun char-to-ascii (char)` लिखें ताकि निम्नलिखित समस्या का समाधान किया जा सके: एकल दृश्य वर्ण (स्पेस को छोड़कर) को उसके ASCII कोड में परिवर्तित करता है।\n इनपुट: एक वर्ण (स्ट्रिंग नहीं) जो दृश्य है और स्पेस नहीं है।\n आउटपुट: इनपुट वर्ण के ASCII कोड का प्रतिनिधित्व करने वाला एक पूर्णांक।\n उदाहरण:\n >>> (char-to-ascii #\\A)\n 65\n >>> (char-to-ascii #\\!)\n 33",
      "hu": "Írj egy Common Lisp függvényt `defun char-to-ascii (char)` a következő probléma megoldására: Egyetlen látható karaktert (kivéve a szóközt) alakít át annak ASCII kódjává.\n Bemenet: Egy karakter (nem egy string), amely látható és nem szóköz.\n Kimenet: Egy egész szám, amely a bemeneti karakter ASCII kódját képviseli.\n Példa:\n >>> (char-to-ascii #\\A)\n 65\n >>> (char-to-ascii #\\!)\n 33"
    },
    "instruction_bertscore": {
      "sq": "1",
      "hy": "0.9942055545244503",
      "bn": "0.9736639950393462",
      "bg": "0.9910252834937007",
      "zh": "0.9687999342685639",
      "fr": "0.9958005564841604",
      "de": "0.993492471456535",
      "ha": "0.9622981660061489",
      "hi": "1",
      "hu": "0.9954696382693563"
    },
    "level": "easy",
    "test": "(defun check-char-to-ascii ()\n  (assert (= (char-to-ascii #\\A) 65))\n  (assert (= (char-to-ascii #\\!) 33))\n  (assert (= (char-to-ascii #\\~) 126))\n  (assert (= (char-to-ascii #\\0) 48))\n  (assert (= (char-to-ascii #\\Z) 90)))\n\n(check-char-to-ascii)",
    "entry_point": "char-to-ascii",
    "signature": "defun char-to-ascii (char)",
    "docstring": {
      "en": "Converts a single visible character (excluding space) to its ASCII code.\n Input: A character (not a string) that is visible and not a space.\n Output: An integer representing the ASCII code of the input character.\n Example:\n >>> (char-to-ascii #\\A)\n 65\n >>> (char-to-ascii #\\!)\n 33",
      "sq": "Konverton një karakter të vetëm të dukshëm (përjashtuar hapësirën) në kodin e tij ASCII.  \nHyrja: Një karakter (jo një varg) që është i dukshëm dhe jo një hapësirë.  \nDalja: Një numër i plotë që përfaqëson kodin ASCII të karakterit të hyrjes.  \nShembull:  \n>>> (char-to-ascii #\\A)  \n65  \n>>> (char-to-ascii #\\!)  \n33",
      "hy": "Վերածում է մեկ տեսանելի սիմվոլը (բացառությամբ բացատանիշի) իր ASCII կոդին:\nՄուտք: Սիմվոլ (ոչ տող), որը տեսանելի է և ոչ բացատանիշ:\nԵլք: Թիվ, որը ներկայացնում է մուտքագրված սիմվոլի ASCII կոդը:\nՕրինակ:\n>>> (char-to-ascii #\\A)\n65\n>>> (char-to-ascii #\\!)\n33",
      "bn": "একটি একক দৃশ্যমান অক্ষর (স্পেস বাদে) তার ASCII কোডে রূপান্তর করে।\nইনপুট: একটি অক্ষর (স্ট্রিং নয়) যা দৃশ্যমান এবং স্পেস নয়।\nআউটপুট: ইনপুট অক্ষরের ASCII কোড উপস্থাপনকারী একটি পূর্ণসংখ্যা।\nউদাহরণ:\n>>> (char-to-ascii #\\A)\n65\n>>> (char-to-ascii #\\!)\n33",
      "bg": "Преобразува един видим символ (с изключение на интервал) в неговия ASCII код.  \nВход: Символ (не низ), който е видим и не е интервал.  \nИзход: Цяло число, представляващо ASCII кода на входния символ.  \nПример:  \n>>> (char-to-ascii #\\A)  \n65  \n>>> (char-to-ascii #\\!)  \n33",
      "zh": "将单个可见字符（不包括空格）转换为其ASCII码。  \n输入：一个可见且不是空格的字符（不是字符串）。  \n输出：一个整数，表示输入字符的ASCII码。  \n示例：  \n>>> (char-to-ascii #\\A)  \n65  \n>>> (char-to-ascii #\\!)  \n33  ",
      "fr": "Convertit un seul caractère visible (à l'exclusion de l'espace) en son code ASCII.\nEntrée : Un caractère (pas une chaîne) qui est visible et n'est pas un espace.\nSortie : Un entier représentant le code ASCII du caractère d'entrée.\nExemple :\n>>> (char-to-ascii #\\A)\n65\n>>> (char-to-ascii #\\!)\n33",
      "de": "Konvertiert ein einzelnes sichtbares Zeichen (außer Leerzeichen) in seinen ASCII-Code.\nEingabe: Ein Zeichen (kein String), das sichtbar ist und kein Leerzeichen ist.\nAusgabe: Eine Ganzzahl, die den ASCII-Code des Eingabezeichens darstellt.\nBeispiel:\n>>> (char-to-ascii #\\A)\n65\n>>> (char-to-ascii #\\!)\n33",
      "ha": "Canza wata harafi mai gani guda daya (ban da sarari) zuwa lambar ASCII dinta.\nShigarwa: Wani hali guda (ba kirtani ba) wanda ake iya gani kuma ba sarari ba.\nFitarwa: Lamba mai lamba wadda ke wakiltar lambar ASCII na halin da aka shigar.\nMisali:\n>>> (char-to-ascii #\\A)\n65\n>>> (char-to-ascii #\\!)\n33",
      "hi": "एकल दृश्य वर्ण (स्पेस को छोड़कर) को इसके ASCII कोड में परिवर्तित करता है।\n इनपुट: एक वर्ण (स्टリング नहीं) जो दृश्य है और स्पेस नहीं है।\n आउटपुट: इनपुट वर्ण के ASCII कोड का एक पूर्णांक।\n उदाहरण:\n >>> (char-to-ascii #\\A)\n 65\n >>> (char-to-ascii #\\!)\n 33",
      "hu": "Egyetlen látható karaktert (a szóköz kivételével) alakít át ASCII kóddá.\nBemenet: Egy karakter (nem egy string), amely látható és nem szóköz.\nKimenet: Egy egész szám, amely a bemeneti karakter ASCII kódját képviseli.\nPélda:\n>>> (char-to-ascii #\\A)\n65\n>>> (char-to-ascii #\\!)\n33"
    },
    "docstring_bertscore": {
      "sq": "1",
      "hy": "0.9765355944579677",
      "bn": "0.9875351490685367",
      "bg": "0.9770985129578205",
      "zh": "0.9603049101324638",
      "fr": "0.9943418149658402",
      "de": "0.9933115191794122",
      "ha": "0.994887452622543",
      "hi": "0.9706912927567781",
      "hu": "1"
    }
  },
  {
    "task_id": "Common Lisp/43",
    "prompt": {
      "en": "(defun ascii-to-char (code)\n  ;; Converts an ASCII code to its corresponding character.\n  ;; Input: An integer representing the ASCII code, guaranteed to be within the range of visible characters (<128 and >0).\n  ;; Output: The character corresponding to the ASCII code.\n  ;; Example:\n  ;; >>> (ascii-to-char 65)\n  ;; #\\A\n  ;; >>> (ascii-to-char 33)\n  ;; #\\!",
      "sq": "(defun ascii-to-char (code)\n  ;; Konverton një kod ASCII në karakterin përkatës.\n  ;; Hyrja: Një numër i plotë që përfaqëson kodin ASCII, i garantuar të jetë brenda intervalit të karaktereve të dukshme (<128 dhe >0).\n  ;; Dalja: Karakteri që korrespondon me kodin ASCII.\n  ;; Shembull:\n  ;; >>> (ascii-to-char 65)\n  ;; #\\A\n  ;; >>> (ascii-to-char 33)\n  ;; #\\!",
      "hy": "(defun ascii-to-char (code)\n  ;; Վերածում է ASCII կոդը համապատասխան նիշի։\n  ;; Մուտք: Թիվ, որը ներկայացնում է ASCII կոդը, երաշխավորված է, որ գտնվում է տեսանելի նիշերի տիրույթում (<128 և >0)։\n  ;; Ելք: Նիշը, որը համապատասխանում է ASCII կոդին։\n  ;; Օրինակ:\n  ;; >>> (ascii-to-char 65)\n  ;; #\\A\n  ;; >>> (ascii-to-char 33)\n  ;; #\\!",
      "bn": "(defun ascii-to-char (code)\n  ;; একটি ASCII কোডকে তার সংশ্লিষ্ট অক্ষরে রূপান্তর করে।\n  ;; ইনপুট: একটি পূর্ণসংখ্যা যা ASCII কোডকে উপস্থাপন করে, দৃশ্যমান অক্ষরের সীমার মধ্যে থাকার নিশ্চয়তা রয়েছে (<128 এবং >0)।\n  ;; আউটপুট: ASCII কোডের সাথে সম্পর্কিত অক্ষর।\n  ;; উদাহরণ:\n  ;; >>> (ascii-to-char 65)\n  ;; #\\A\n  ;; >>> (ascii-to-char 33)\n  ;; #\\!",
      "bg": "(defun ascii-to-char (code)\n  ;; Преобразува ASCII код в съответстващия му символ.\n  ;; Вход: Цяло число, представляващо ASCII кода, гарантирано е в диапазона на видимите символи (<128 и >0).\n  ;; Изход: Символът, съответстващ на ASCII кода.\n  ;; Пример:\n  ;; >>> (ascii-to-char 65)\n  ;; #\\A\n  ;; >>> (ascii-to-char 33)\n  ;; #\\!",
      "zh": "(defun ascii-to-char (code)\n  ;; 将ASCII码转换为其对应的字符。\n  ;; 输入：一个表示ASCII码的整数，保证在可见字符范围内（<128 且 >0）。\n  ;; 输出：与ASCII码对应的字符。\n  ;; 示例:\n  ;; >>> (ascii-to-char 65)\n  ;; #\\A\n  ;; >>> (ascii-to-char 33)\n  ;; #\\!",
      "fr": "(defun ascii-to-char (code)\n  ;; Convertit un code ASCII en son caractère correspondant.\n  ;; Entrée : Un entier représentant le code ASCII, garanti d'être dans la plage des caractères visibles (<128 et >0).\n  ;; Sortie : Le caractère correspondant au code ASCII.\n  ;; Exemple:\n  ;; >>> (ascii-to-char 65)\n  ;; #\\A\n  ;; >>> (ascii-to-char 33)\n  ;; #\\!",
      "de": "(defun ascii-to-char (code)\n  ;; Konvertiert einen ASCII-Code in das entsprechende Zeichen.\n  ;; Eingabe: Eine ganze Zahl, die den ASCII-Code darstellt, garantiert im Bereich der sichtbaren Zeichen (<128 und >0).\n  ;; Ausgabe: Das Zeichen, das dem ASCII-Code entspricht.\n  ;; Beispiel:\n  ;; >>> (ascii-to-char 65)\n  ;; #\\A\n  ;; >>> (ascii-to-char 33)\n  ;; #\\!",
      "ha": "(defun ascii-to-char (code)\n  ;; Canza lambar ASCII zuwa harafin da ya dace.\n  ;; Shigarwa: Lamba mai nuna lambar ASCII, tabbatacce yana cikin kewayon haruffa masu gani (<128 da >0).\n  ;; Fitarwa: Harafin da ya dace da lambar ASCII.\n  ;; Misali:\n  ;; >>> (ascii-to-char 65)\n  ;; #\\A\n  ;; >>> (ascii-to-char 33)\n  ;; #\\!",
      "hi": "(defun ascii-to-char (code)\n  ;; एक ASCII कोड को उसके संबंधित वर्ण में परिवर्तित करता है।\n  ;; इनपुट: एक पूर्णांक जो ASCII कोड का प्रतिनिधित्व करता है, जो दृश्यमान वर्णों की सीमा के भीतर होने की गारंटी है (<128 और >0)।\n  ;; आउटपुट: ASCII कोड के अनुरूप वर्ण।\n  ;; उदाहरण:\n  ;; >>> (ascii-to-char 65)\n  ;; #\\A\n  ;; >>> (ascii-to-char 33)\n  ;; #\\!",
      "hu": "(defun ascii-to-char (code)\n  ;; Egy ASCII kódot alakít át a megfelelő karakterré.\n  ;; Bemenet: Egy egész szám, amely az ASCII kódot jelöli, garantáltan a látható karakterek tartományában van (<128 és >0).\n  ;; Kimenet: Az ASCII kódnak megfelelő karakter.\n  ;; Példa:\n  ;; >>> (ascii-to-char 65)\n  ;; #\\A\n  ;; >>> (ascii-to-char 33)\n  ;; #\\!"
    },
    "prompt_bertscore": {
      "sq": "0.9931444710289619",
      "hy": "0.9902853853243457",
      "bn": "0.9932016765787",
      "bg": "0.9975635997462261",
      "zh": "0.9789396179596329",
      "fr": "0.996601235550112",
      "de": "0.9937268553061561",
      "ha": "0.954845752740101",
      "hi": "0.9925664566201503",
      "hu": "0.9945837467699407"
    },
    "canonical_solution": "  (code-char code))",
    "instruction": {
      "en": "Write a Common Lisp function `defun ascii-to-char (code)` to solve the following problem: Converts an ASCII code to its corresponding character.\n Input: An integer representing the ASCII code, guaranteed to be within the range of visible characters (<128 and >0).\n Output: The character corresponding to the ASCII code.\n Example:\n >>> (ascii-to-char 65)\n #\\A\n >>> (ascii-to-char 33)\n #\\!",
      "sq": "Shkruani një funksion Common Lisp `defun ascii-to-char (code)` për të zgjidhur problemin e mëposhtëm: Konverton një kod ASCII në karakterin përkatës.\n Hyrja: Një numër i plotë që përfaqëson kodin ASCII, i garantuar të jetë brenda intervalit të karaktereve të dukshme (<128 dhe >0).\n Dalja: Karakteri që korrespondon me kodin ASCII.\n Shembull:\n >>> (ascii-to-char 65)\n #\\A\n >>> (ascii-to-char 33)\n #\\!",
      "hy": "Գրեք Common Lisp ֆունկցիա `defun ascii-to-char (code)` հետևյալ խնդիրը լուծելու համար՝ Վերածում է ASCII կոդը համապատասխանող սիմվոլի:\n Մուտք: Թիվ, որը ներկայացնում է ASCII կոդը, երաշխավորված է, որ գտնվում է տեսանելի սիմվոլների տիրույթում (<128 և >0):\n Ելք: Սիմվոլը, որը համապատասխանում է ASCII կոդին:\n Օրինակ:\n >>> (ascii-to-char 65)\n #\\A\n >>> (ascii-to-char 33)\n #\\!",
      "bn": "একটি Common Lisp ফাংশন `defun ascii-to-char (code)` লিখুন নিম্নলিখিত সমস্যার সমাধানের জন্য: একটি ASCII কোডকে তার সংশ্লিষ্ট অক্ষরে রূপান্তর করে।  \n ইনপুট: একটি পূর্ণসংখ্যা যা ASCII কোডকে উপস্থাপন করে, দৃশ্যমান অক্ষরের সীমার মধ্যে থাকার নিশ্চয়তা দেওয়া হয়েছে (<128 এবং >0)।  \n আউটপুট: ASCII কোডের সাথে সংশ্লিষ্ট অক্ষর।  \n উদাহরণ:  \n >>> (ascii-to-char 65)  \n #\\A  \n >>> (ascii-to-char 33)  \n #\\!",
      "bg": "Напишете функция на Common Lisp `defun ascii-to-char (code)`, за да решите следния проблем: Преобразува ASCII код в съответстващия му символ.\n Вход: Цяло число, представляващо ASCII кода, гарантирано в диапазона на видимите символи (<128 и >0).\n Изход: Символът, съответстващ на ASCII кода.\n Пример:\n >>> (ascii-to-char 65)\n #\\A\n >>> (ascii-to-char 33)\n #\\!",
      "zh": "编写一个 Common Lisp 函数 `defun ascii-to-char (code)` 来解决以下问题：将 ASCII 码转换为其对应的字符。\n 输入：一个表示 ASCII 码的整数，保证在可见字符范围内（<128 且 >0）。\n 输出：与 ASCII 码对应的字符。\n 示例：\n >>> (ascii-to-char 65)\n #\\A\n >>> (ascii-to-char 33)\n #\\!",
      "fr": "Écrire une fonction Common Lisp `defun ascii-to-char (code)` pour résoudre le problème suivant : Convertit un code ASCII en son caractère correspondant.\n Entrée : Un entier représentant le code ASCII, garanti d'être dans la plage des caractères visibles (<128 et >0).\n Sortie : Le caractère correspondant au code ASCII.\n Exemple :\n >>> (ascii-to-char 65)\n #\\A\n >>> (ascii-to-char 33)\n #\\!",
      "de": "Schreiben Sie eine Common Lisp Funktion `defun ascii-to-char (code)`, um das folgende Problem zu lösen: Wandelt einen ASCII-Code in das entsprechende Zeichen um.\n Eingabe: Eine ganze Zahl, die den ASCII-Code darstellt, garantiert im Bereich der sichtbaren Zeichen (<128 und >0).\n Ausgabe: Das Zeichen, das dem ASCII-Code entspricht.\n Beispiel:\n >>> (ascii-to-char 65)\n #\\A\n >>> (ascii-to-char 33)\n #\\!",
      "ha": "Rubuta aikin Common Lisp `defun ascii-to-char (code)` don magance matsalar mai zuwa: Canza lambar ASCII zuwa harafin da ya dace da ita. \n Shigarwa: Lamba mai wakiltar lambar ASCII, wanda aka tabbatar yana cikin kewayon haruffan da ake iya gani (<128 da >0).\n Fitarwa: Harafin da ya dace da lambar ASCII.\n Misali:\n >>> (ascii-to-char 65)\n #\\A\n >>> (ascii-to-char 33)\n #\\!",
      "hi": "एक Common Lisp फ़ंक्शन `defun ascii-to-char (code)` लिखें ताकि निम्नलिखित समस्या का समाधान हो सके: एक ASCII कोड को उसके संबंधित वर्ण में परिवर्तित करता है।\n इनपुट: एक पूर्णांक जो ASCII कोड का प्रतिनिधित्व करता है, यह सुनिश्चित किया गया है कि यह दृश्य वर्णों की श्रेणी में है (<128 और >0)।\n आउटपुट: ASCII कोड के अनुरूप वर्ण।\n उदाहरण:\n >>> (ascii-to-char 65)\n #\\A\n >>> (ascii-to-char 33)\n #\\!",
      "hu": "Írj egy Common Lisp függvényt `defun ascii-to-char (code)` a következő probléma megoldására: Átalakít egy ASCII kódot a megfelelő karakterré.\n Bemenet: Egy egész szám, amely az ASCII kódot képviseli, garantáltan a látható karakterek tartományán belül van (<128 és >0).\n Kimenet: Az ASCII kódnak megfelelő karakter.\n Példa:\n >>> (ascii-to-char 65)\n #\\A\n >>> (ascii-to-char 33)\n #\\!"
    },
    "instruction_bertscore": {
      "sq": "0.9934775741779573",
      "hy": "0.9914557155294033",
      "bn": "0.9915337772691499",
      "bg": "0.9900053164870865",
      "zh": "0.9915337772691499",
      "fr": "0.9967222014521623",
      "de": "0.9909996601745471",
      "ha": "0.9791801593510662",
      "hi": "0.9917778940074419",
      "hu": "0.9966306328465052"
    },
    "level": "easy",
    "test": "(defun check-ascii-to-char ()\n  (assert (char= (ascii-to-char 65) #\\A))\n  (assert (char= (ascii-to-char 33) #\\!))\n  (assert (char= (ascii-to-char 126) #\\~))\n  (assert (char= (ascii-to-char 48) #\\0))\n  (assert (char= (ascii-to-char 90) #\\Z)))\n\n(check-ascii-to-char)",
    "entry_point": "ascii-to-char",
    "signature": "defun ascii-to-char (code)",
    "docstring": {
      "en": "Converts an ASCII code to its corresponding character.\n Input: An integer representing the ASCII code, guaranteed to be within the range of visible characters (<128 and >0).\n Output: The character corresponding to the ASCII code.\n Example:\n >>> (ascii-to-char 65)\n #\\A\n >>> (ascii-to-char 33)\n #\\!",
      "sq": "Kthen një kod ASCII në karakterin përkatës.\nHyrja: Një numër i plotë që përfaqëson kodin ASCII, i garantuar të jetë brenda intervalit të karaktereve të dukshme (<128 dhe >0).\nDalja: Karakteri që korrespondon me kodin ASCII.\nShembull:\n>>> (ascii-to-char 65)\n#\\A\n>>> (ascii-to-char 33)\n#\\!",
      "hy": "Վերափոխում է ASCII կոդը նրա համապատասխան նիշին:\nՄուտք: Թիվ, որը ներկայացնում է ASCII կոդը, երաշխավորված է, որ գտնվում է տեսանելի նիշերի տիրույթում (<128 և >0):\nԵլք: Նիշ, որը համապատասխանում է ASCII կոդին:\nՕրինակ:\n>>> (ascii-to-char 65)\n#\\A\n>>> (ascii-to-char 33)\n#\\!",
      "bn": "ASCII কোডকে এর সংশ্লিষ্ট অক্ষরে রূপান্তর করে।\nইনপুট: একটি পূর্ণসংখ্যা যা ASCII কোডকে উপস্থাপন করে, দৃশ্যমান অক্ষরের সীমার মধ্যে থাকার নিশ্চয়তা রয়েছে (<128 এবং >0)।  \nআউটপুট: ASCII কোডের সাথে সম্পর্কিত অক্ষর।  \nউদাহরণ:  \n>>> (ascii-to-char 65)  \n#\\A  \n>>> (ascii-to-char 33)  \n#\\!  ",
      "bg": "Преобразува ASCII код в съответстващия му символ.\nВход: Цяло число, представляващо ASCII кода, гарантирано в диапазона на видимите символи (<128 и >0).  \nИзход: Символът, съответстващ на ASCII кода.  \nПример:  \n>>> (ascii-to-char 65)  \n#\\A  \n>>> (ascii-to-char 33)  \n#\\!",
      "zh": "将 ASCII 码转换为其对应的字符。\n输入：一个表示 ASCII 码的整数，保证在可见字符范围内（<128 且 >0）。  \n输出：与 ASCII 码对应的字符。  \n示例：  \n>>> (ascii-to-char 65)  \n#\\A  \n>>> (ascii-to-char 33)  \n#\\!",
      "fr": "Convertit un code ASCII en son caractère correspondant.\nEntrée : Un entier représentant le code ASCII, garanti d'être dans la plage des caractères visibles (<128 et >0).  \nSortie : Le caractère correspondant au code ASCII.  \nExemple :  \n>>> (ascii-to-char 65)  \n#\\A  \n>>> (ascii-to-char 33)  \n#\\!",
      "de": "Konvertiert einen ASCII-Code in das entsprechende Zeichen.\nEingabe: Eine ganze Zahl, die den ASCII-Code darstellt, garantiert im Bereich der sichtbaren Zeichen (<128 und >0).\nAusgabe: Das Zeichen, das dem ASCII-Code entspricht.\nBeispiel:\n>>> (ascii-to-char 65)\n#\\A\n>>> (ascii-to-char 33)\n#\\!",
      "ha": "Canza lambar ASCII zuwa harafin da ya dace.\n Shigarwa: Wani lamba da ke wakiltar lambar ASCII, wanda aka tabbatar da cewa yana cikin kewayon haruffan da ake iya gani (<128 da >0).\n Fitarwa: Harafin da ya dace da lambar ASCII.\n Misali:\n >>> (ascii-to-char 65)\n #\\A\n >>> (ascii-to-char 33)\n #\\!",
      "hi": "ASCII कोड को उसके संबंधित वर्ण में परिवर्तित करता है।\nइनपुट: ASCII कोड का प्रतिनिधित्व करने वाला एक पूर्णांक, जो दृश्यमान वर्णों की सीमा के भीतर होने की गारंटी है (<128 और >0)।  \nआउटपुट: ASCII कोड के अनुरूप वर्ण।  \nउदाहरण:  \n>>> (ascii-to-char 65)  \n#\\A  \n>>> (ascii-to-char 33)  \n#\\!  ",
      "hu": "Átalakít egy ASCII kódot a megfelelő karakterré.\n Bemenet: Egy egész szám, amely az ASCII kódot képviseli, garantáltan a látható karakterek tartományán belül van (<128 és >0).\n Kimenet: Az ASCII kódnak megfelelő karakter.\n Példa:\n >>> (ascii-to-char 65)\n #\\A\n >>> (ascii-to-char 33)\n #\\!"
    },
    "docstring_bertscore": {
      "sq": "0.9686450025713567",
      "hy": "0.9921366204755908",
      "bn": "0.9696300106309087",
      "bg": "0.9794655912086132",
      "zh": "0.9720179450717101",
      "fr": "0.9947041167808478",
      "de": "0.9913285920855409",
      "ha": "0.9735070770383287",
      "hi": "0.9827282938474924",
      "hu": "0.9956694604326773"
    }
  },
  {
    "task_id": "Common Lisp/44",
    "prompt": {
      "en": "(defun reverse-three-digit (num)\n  ;; Reverses a three-digit number.\n  ;; Input: A three-digit integer 'num'.\n  ;; Output: The three-digit integer in reverse order. Leading zeros are preserved in the output.\n  ;; Example:\n  ;; >>> (reverse-three-digit 123)\n  ;; 321\n  ;; >>> (reverse-three-digit 100)\n  ;; 1 ;; For Common Lisp, leading zeros are not typically displayed in integer output.",
      "sq": "(defun reverse-three-digit (num)\n  ;; Kthen një numër treshe në rend të kundërt.\n  ;; Hyrja: Një numër i plotë treshe 'num'.\n  ;; Dalja: Numri i plotë treshe në rend të kundërt. Zerosat para ruhet në dalje.\n  ;; Shembull:\n  ;; >>> (reverse-three-digit 123)\n  ;; 321\n  ;; >>> (reverse-three-digit 100)\n  ;; 1 ;; Për Common Lisp, zerosat para zakonisht nuk shfaqen në daljen e numrave të plotë.",
      "hy": "(defun reverse-three-digit (num)\n  ;; Շրջում է եռանիշ թիվը։\n  ;; Մուտք: Եռանիշ ամբողջ թիվ 'num'։\n  ;; Ելք: Եռանիշ ամբողջ թիվը շրջված կարգով։ Առաջատար զրոները պահպանվում են ելքում։\n  ;; Օրինակ:\n  ;; >>> (reverse-three-digit 123)\n  ;; 321\n  ;; >>> (reverse-three-digit 100)\n  ;; 1 ;; Common Lisp-ի համար, առաջատար զրոները սովորաբար չեն ցուցադրվում ամբողջ թվերի ելքում։",
      "bn": "(defun reverse-three-digit (num)\n  ;; একটি তিন অঙ্কের সংখ্যা উল্টায়।\n  ;; ইনপুট: একটি তিন অঙ্কের পূর্ণসংখ্যা 'num'।\n  ;; আউটপুট: উল্টো ক্রমে তিন অঙ্কের পূর্ণসংখ্যা। আউটপুটে শূন্যের পূর্ববর্তী সংখ্যা সংরক্ষিত থাকে।\n  ;; উদাহরণ:\n  ;; >>> (reverse-three-digit 123)\n  ;; 321\n  ;; >>> (reverse-three-digit 100)\n  ;; 1 ;; Common Lisp-এর জন্য, পূর্ণসংখ্যার আউটপুটে সাধারণত শূন্যের পূর্ববর্তী সংখ্যা প্রদর্শিত হয় না।",
      "bg": "(defun reverse-three-digit (num)\n  ;; Обръща трицифрено число.\n  ;; Вход: Трицифрено цяло число 'num'.\n  ;; Изход: Трицифреното цяло число в обратен ред. Водещите нули се запазват в изхода.\n  ;; Пример:\n  ;; >>> (reverse-three-digit 123)\n  ;; 321\n  ;; >>> (reverse-three-digit 100)\n  ;; 1 ;; За Common Lisp, водещите нули обикновено не се показват в изхода на цяло число.",
      "zh": "(defun reverse-three-digit (num)\n  ;; 反转一个三位数。\n  ;; 输入：一个三位整数 'num'。\n  ;; 输出：反转顺序的三位整数。输出中保留前导零。\n  ;; 示例：\n  ;; >>> (reverse-three-digit 123)\n  ;; 321\n  ;; >>> (reverse-three-digit 100)\n  ;; 1 ;; 对于Common Lisp，整数输出中通常不显示前导零。",
      "fr": "(defun reverse-three-digit (num)\n  ;; Inverse un nombre à trois chiffres.\n  ;; Entrée : Un entier à trois chiffres 'num'.\n  ;; Sortie : L'entier à trois chiffres dans l'ordre inverse. Les zéros initiaux sont préservés dans la sortie.\n  ;; Exemple :\n  ;; >>> (reverse-three-digit 123)\n  ;; 321\n  ;; >>> (reverse-three-digit 100)\n  ;; 1 ;; Pour Common Lisp, les zéros initiaux ne sont généralement pas affichés dans la sortie des entiers.",
      "de": "(defun reverse-three-digit (num)\n  ;; Kehrt eine dreistellige Zahl um.\n  ;; Eingabe: Eine dreistellige Ganzzahl 'num'.\n  ;; Ausgabe: Die dreistellige Ganzzahl in umgekehrter Reihenfolge. Führende Nullen bleiben in der Ausgabe erhalten.\n  ;; Beispiel:\n  ;; >>> (reverse-three-digit 123)\n  ;; 321\n  ;; >>> (reverse-three-digit 100)\n  ;; 1 ;; In Common Lisp werden führende Nullen in der Ganzzahlausgabe normalerweise nicht angezeigt.",
      "ha": "(defun reverse-three-digit (num)\n  ;; Juya lamba mai tsawon uku.\n  ;; Shigarwa: Lamba mai tsawon uku 'num'.\n  ;; Fitarwa: Lamba mai tsawon uku a jujjuyawar tsari. Ana kiyaye sifili na gaba a cikin fitarwa.\n  ;; Misali:\n  ;; >>> (reverse-three-digit 123)\n  ;; 321\n  ;; >>> (reverse-three-digit 100)\n  ;; 1 ;; A cikin Common Lisp, ba a nuna sifili na gaba a cikin fitarwar lamba ba.",
      "hi": "(defun reverse-three-digit (num)\n  ;; एक तीन-अंकीय संख्या को उलट देता है।\n  ;; इनपुट: एक तीन-अंकीय पूर्णांक 'num'।\n  ;; आउटपुट: उल्टे क्रम में तीन-अंकीय पूर्णांक। आउटपुट में अग्रणी शून्य संरक्षित रहते हैं।\n  ;; उदाहरण:\n  ;; >>> (reverse-three-digit 123)\n  ;; 321\n  ;; >>> (reverse-three-digit 100)\n  ;; 1 ;; कॉमन लिस्प के लिए, अग्रणी शून्य आमतौर पर पूर्णांक आउटपुट में प्रदर्शित नहीं होते।",
      "hu": "(defun reverse-three-digit (num)\n  ;; Megfordít egy háromjegyű számot.\n  ;; Bemenet: Egy háromjegyű egész szám 'num'.\n  ;; Kimenet: A háromjegyű egész szám fordított sorrendben. A kezdő nullák megmaradnak a kimenetben.\n  ;; Példa:\n  ;; >>> (reverse-three-digit 123)\n  ;; 321\n  ;; >>> (reverse-three-digit 100)\n  ;; 1 ;; A Common Lisp esetében a kezdő nullák általában nem jelennek meg az egész szám kimenetében."
    },
    "prompt_bertscore": {
      "sq": "0.9736705498419204",
      "hy": "0.9968298591186832",
      "bn": "0.9862871543844944",
      "bg": "0.9841935901683867",
      "zh": "0.9791980360853593",
      "fr": "0.9805125719470481",
      "de": "0.9961952350512767",
      "ha": "0.9576446534392635",
      "hi": "0.9924627715612502",
      "hu": "0.9867620796255488"
    },
    "canonical_solution": "  (+ (* (mod num 10) 100)\n     (* (mod (floor num 10) 10) 10)\n     (floor num 100)))",
    "instruction": {
      "en": "Write a Common Lisp function `(defun reverse-three-digit (num)` to solve the following problem: Reverses a three-digit number.\n Input: A three-digit integer 'num'.\n Output: The three-digit integer in reverse order. Leading zeros are preserved in the output.\n Example:\n >>> (reverse-three-digit 123)\n 321\n >>> (reverse-three-digit 100)\n 1 ;; For Common Lisp, leading zeros are not typically displayed in integer output.",
      "sq": "Shkruani një funksion Common Lisp `(defun reverse-three-digit (num)` për të zgjidhur problemin e mëposhtëm: Përmbys një numër treshe.\n Hyrja: Një numër i plotë treshe 'num'.\n Dalja: Numri i plotë treshe në rend të kundërt. Zerot udhëheqëse ruhen në dalje.\n Shembull:\n >>> (reverse-three-digit 123)\n 321\n >>> (reverse-three-digit 100)\n 1 ;; Për Common Lisp, zerot udhëheqëse zakonisht nuk shfaqen në daljen e numrave të plotë.",
      "hy": "Գրեք Common Lisp ֆունկցիա `(defun reverse-three-digit (num)` հետևյալ խնդիրը լուծելու համար՝ Հակադարձում է եռանիշ թիվը։ \n Մուտքագրում՝ եռանիշ ամբողջ թիվ 'num'։ \n Ելք՝ եռանիշ ամբողջ թիվը հակադարձ կարգով։ Առաջատար զրոները պահպանվում են ելքում։ \n Օրինակ:\n >>> (reverse-three-digit 123)\n 321\n >>> (reverse-three-digit 100)\n 1 ;; Common Lisp-ի համար, առաջատար զրոները սովորաբար չեն ցուցադրվում ամբողջ թվերի ելքում։",
      "bn": "একটি Common Lisp ফাংশন `(defun reverse-three-digit (num)` লিখুন নিম্নলিখিত সমস্যার সমাধানের জন্য: একটি তিন-অঙ্কের সংখ্যা উল্টানো।  \nইনপুট: একটি তিন-অঙ্কের পূর্ণসংখ্যা 'num'।  \nআউটপুট: উল্টানো ক্রমে তিন-অঙ্কের পূর্ণসংখ্যা। আউটপুটে শূন্যের পূর্ববর্তী অবস্থান সংরক্ষিত থাকে।  \nউদাহরণ:  \n>>> (reverse-three-digit 123)  \n321  \n>>> (reverse-three-digit 100)  \n1 ;; Common Lisp-এর জন্য, পূর্ণসংখ্যার আউটপুটে সাধারণত শূন্যের পূর্ববর্তী অবস্থান প্রদর্শিত হয় না।",
      "bg": "Напишете функция на Common Lisp `(defun reverse-three-digit (num)` за решаване на следния проблем: Обръща трицифрено число.\n Вход: Трицифрено цяло число 'num'.\n Изход: Трицифреното цяло число в обратен ред. Водещите нули се запазват в изхода.\n Пример:\n >>> (reverse-three-digit 123)\n 321\n >>> (reverse-three-digit 100)\n 1 ;; За Common Lisp, водещите нули обикновено не се показват в изхода за цели числа.",
      "zh": "编写一个 Common Lisp 函数 `(defun reverse-three-digit (num)` 来解决以下问题：反转一个三位数。\n 输入：一个三位整数 'num'。\n 输出：反转后的三位整数。输出中保留前导零。\n 示例：\n >>> (reverse-three-digit 123)\n 321\n >>> (reverse-three-digit 100)\n 1 ;; 对于 Common Lisp，整数输出中通常不显示前导零。",
      "fr": "Écrire une fonction Common Lisp `(defun reverse-three-digit (num)` pour résoudre le problème suivant : Inverse un nombre à trois chiffres.  \nEntrée : Un entier à trois chiffres 'num'.  \nSortie : L'entier à trois chiffres dans l'ordre inverse. Les zéros en tête sont préservés dans la sortie.  \nExemple :  \n>>> (reverse-three-digit 123)  \n321  \n>>> (reverse-three-digit 100)  \n1 ;; Pour Common Lisp, les zéros en tête ne sont généralement pas affichés dans la sortie des entiers.",
      "de": "Schreiben Sie eine Common Lisp-Funktion `(defun reverse-three-digit (num)` um das folgende Problem zu lösen: Kehrt eine dreistellige Zahl um.\n Eingabe: Eine dreistellige ganze Zahl 'num'.\n Ausgabe: Die dreistellige ganze Zahl in umgekehrter Reihenfolge. Führende Nullen bleiben in der Ausgabe erhalten.\n Beispiel:\n >>> (reverse-three-digit 123)\n 321\n >>> (reverse-three-digit 100)\n 1 ;; In Common Lisp werden führende Nullen in der Ganzzahlausgabe normalerweise nicht angezeigt.",
      "ha": "Rubuta aikin Common Lisp `(defun reverse-three-digit (num)` don warware matsalar mai zuwa: Juya lambar mai tsawon uku. \n Shigarwa: Lamba mai tsawon uku 'num'. \n Fitarwa: Lamba mai tsawon uku a cikin tsari na baya. Ana kiyaye sifili na farko a fitarwa. \n Misali:\n >>> (reverse-three-digit 123)\n 321\n >>> (reverse-three-digit 100)\n 1 ;; A cikin Common Lisp, ba a nuna sifili na farko a cikin fitarwar lamba ba.",
      "hi": "एक Common Lisp फ़ंक्शन `(defun reverse-three-digit (num)` लिखें ताकि निम्नलिखित समस्या का समाधान किया जा सके: एक तीन-अंकीय संख्या को उलटता है।\nइनपुट: एक तीन-अंकीय पूर्णांक 'num'।\nआउटपुट: उल्टे क्रम में तीन-अंकीय पूर्णांक। आउटपुट में अग्रणी शून्य संरक्षित रहते हैं।\nउदाहरण:\n>>> (reverse-three-digit 123)\n321\n>>> (reverse-three-digit 100)\n1 ;; Common Lisp के लिए, अग्रणी शून्य आमतौर पर पूर्णांक आउटपुट में प्रदर्शित नहीं होते हैं।",
      "hu": "Írj egy Common Lisp függvényt `(defun reverse-three-digit (num)` a következő probléma megoldására: Megfordít egy háromjegyű számot.  \n Bemenet: Egy háromjegyű egész szám 'num'.  \n Kimenet: A háromjegyű egész szám fordított sorrendben. A kimenetben a vezető nullák megmaradnak.  \n Példa:  \n >>> (reverse-three-digit 123)  \n 321  \n >>> (reverse-three-digit 100)  \n 1 ;; A Common Lisp esetében a vezető nullák általában nem jelennek meg az egész számok kimenetében."
    },
    "instruction_bertscore": {
      "sq": "0.9834642194092266",
      "hy": "0.9875605737573091",
      "bn": "0.9807944284577367",
      "bg": "0.9879784920790065",
      "zh": "0.9696298120005277",
      "fr": "0.981854916062082",
      "de": "0.9941882736813002",
      "ha": "0.9499403768500634",
      "hi": "0.9945841440307027",
      "hu": "0.9767977865609336"
    },
    "level": "easy",
    "test": "(defun check-reverse-three-digit ()\n  (assert (= (reverse-three-digit 123) 321))\n  (assert (= (reverse-three-digit 100) 1)) ;; Note: Leading zeros are not displayed in integers.\n  (assert (= (reverse-three-digit 250) 52))\n  (assert (= (reverse-three-digit 999) 999))\n  (assert (= (reverse-three-digit 500) 5)))\n\n(check-reverse-three-digit)",
    "entry_point": "reverse-three-digit",
    "signature": "(defun reverse-three-digit (num)",
    "docstring": {
      "en": "Reverses a three-digit number.\n Input: A three-digit integer 'num'.\n Output: The three-digit integer in reverse order. Leading zeros are preserved in the output.\n Example:\n >>> (reverse-three-digit 123)\n 321\n >>> (reverse-three-digit 100)\n 1 ;; For Common Lisp, leading zeros are not typically displayed in integer output.",
      "sq": "Kthen një numër tre-shifror.\nHyrja: Një numër i plotë tre-shifror 'num'.\nDalja: Numri i plotë tre-shifror në rend të kundërt. Zerot përpara ruhen në dalje.\nShembull:\n>>> (reverse-three-digit 123)\n321\n>>> (reverse-three-digit 100)\n1 ;; Për Common Lisp, zerot përpara zakonisht nuk shfaqen në daljen e numrave të plotë.",
      "hy": "Եռանիշ թիվը շրջում է:\nՄուտք: Եռանիշ ամբողջ թիվ 'num':\nԵլք: Եռանիշ ամբողջ թիվը հակառակ կարգով: Առաջատար զրոները պահպանվում են ելքում:\nՕրինակ:\n>>> (reverse-three-digit 123)\n321\n>>> (reverse-three-digit 100)\n1 ;; Common Lisp-ի դեպքում, առաջատար զրոները սովորաբար չեն ցուցադրվում ամբողջ թվի ելքում:",
      "bn": "তিন অঙ্কের একটি সংখ্যা উল্টো করে।\nইনপুট: একটি তিন অঙ্কের পূর্ণসংখ্যা 'num'।\nআউটপুট: উল্টো ক্রমে তিন অঙ্কের পূর্ণসংখ্যা। আউটপুটে শূন্যের পূর্ববর্তী অবস্থান সংরক্ষিত থাকে।\nউদাহরণ:\n>>> (reverse-three-digit 123)\n321\n>>> (reverse-three-digit 100)\n1 ;; কমন লিস্পের জন্য, পূর্ণসংখ্যার আউটপুটে সাধারণত শূন্যের পূর্ববর্তী অবস্থান প্রদর্শিত হয় না।",
      "bg": "Обръща трицифрено число.\nВход: Трицифрено цяло число 'num'.  \nИзход: Трицифреното цяло число в обратен ред. Водещите нули се запазват в изхода.  \nПример:  \n>>> (reverse-three-digit 123)  \n321  \n>>> (reverse-three-digit 100)  \n1 ;; За Common Lisp, водещите нули обикновено не се показват в изхода за цели числа.",
      "zh": "反转一个三位数。\n输入：一个三位整数 'num'。\n输出：反转顺序的三位整数。输出中保留前导零。\n示例：\n>>> (reverse-three-digit 123)\n321\n>>> (reverse-three-digit 100)\n1 ;; 对于 Common Lisp，前导零通常不会在整数输出中显示。",
      "fr": "Renverse un nombre à trois chiffres.\nEntrée : Un entier à trois chiffres 'num'.\nSortie : L'entier à trois chiffres dans l'ordre inverse. Les zéros initiaux sont préservés dans la sortie.\nExemple :\n>>> (reverse-three-digit 123)\n321\n>>> (reverse-three-digit 100)\n1 ;; Pour Common Lisp, les zéros initiaux ne sont généralement pas affichés dans la sortie des entiers.",
      "de": "Kehrt eine dreistellige Zahl um.\nEingabe: Eine dreistellige ganze Zahl 'num'.\nAusgabe: Die dreistellige ganze Zahl in umgekehrter Reihenfolge. Führende Nullen bleiben in der Ausgabe erhalten.\nBeispiel:\n>>> (reverse-three-digit 123)\n321\n>>> (reverse-three-digit 100)\n1 ;; In Common Lisp werden führende Nullen in der Ganzzahlausgabe normalerweise nicht angezeigt.",
      "ha": "Juya lamba mai tsawon uku.\nInput: Lamba mai tsawon uku 'num'.  \nOutput: Lambar mai tsawon uku a jujjuyawar tsari. Ana kiyaye sifili na farko a cikin fitarwa.  \nMisali:  \n>>> (reverse-three-digit 123)  \n321  \n>>> (reverse-three-digit 100)  \n1 ;; A cikin Common Lisp, ba a nuna sifili na farko a cikin fitarwar lambobi.",
      "hi": "तीन अंकों की संख्या को उलटता है।\nइनपुट: एक तीन अंकों की पूर्णांक 'num'।\nआउटपुट: उल्टे क्रम में तीन अंकों की पूर्णांक। आउटपुट में अग्रणी शून्य संरक्षित रहते हैं।\nउदाहरण:\n>>> (reverse-three-digit 123)\n321\n>>> (reverse-three-digit 100)\n1 ;; कॉमन लिस्प के लिए, अग्रणी शून्य आमतौर पर पूर्णांक आउटपुट में प्रदर्शित नहीं होते।",
      "hu": "Megfordít egy háromjegyű számot.\nBemenet: Egy háromjegyű egész szám 'num'.\nKimenet: A háromjegyű egész szám fordított sorrendben. A kezdő nullák megmaradnak a kimenetben.\nPélda:\n>>> (reverse-three-digit 123)\n321\n>>> (reverse-three-digit 100)\n1 ;; A Common Lisp-ben a kezdő nullák általában nem jelennek meg az egész szám kimenetében."
    },
    "docstring_bertscore": {
      "sq": "0.9637062567773053",
      "hy": "0.9734842345445097",
      "bn": "0.9708486080185578",
      "bg": "0.9855174616579843",
      "zh": "0.9749920377669455",
      "fr": "0.9739613447197555",
      "de": "0.9918835653701524",
      "ha": "0.9608831231716564",
      "hi": "0.9898420423138758",
      "hu": "0.9833577535249919"
    }
  },
  {
    "task_id": "Common Lisp/45",
    "prompt": {
      "en": "(defun int-bool-int-conversion (int)\n  ;; Converts an integer to a boolean and then back to an integer.\n  ;; Input: An integer within the range of integer values.\n  ;; Output: An integer resulting from the conversion of the initial integer to a boolean and then back to an integer.\n  ;; The output is 1 for any non-zero input integer, and 0 for an input of 0.\n  ;; Example:\n  ;; >>> (int-bool-int-conversion 3)\n  ;; 1\n  ;; >>> (int-bool-int-conversion 0)\n  ;; 0\n  ;; >>> (int-bool-int-conversion -5)\n  ;; 1",
      "sq": "(defun int-bool-int-conversion (int)\n  ;; Konverton një numër të plotë në një boolean dhe pastaj përsëri në një numër të plotë.\n  ;; Hyrja: Një numër i plotë brenda intervalit të vlerave të numrave të plotë.\n  ;; Dalja: Një numër i plotë që rezulton nga konvertimi i numrit fillestar të plotë në një boolean dhe pastaj përsëri në një numër të plotë.\n  ;; Dalja është 1 për çdo hyrje të numrit të plotë që nuk është zero, dhe 0 për një hyrje prej 0.\n  ;; Shembull:\n  ;; >>> (int-bool-int-conversion 3)\n  ;; 1\n  ;; >>> (int-bool-int-conversion 0)\n  ;; 0\n  ;; >>> (int-bool-int-conversion -5)\n  ;; 1",
      "hy": "(defun int-bool-int-conversion (int)\n  ;; Փոխակերպում է ամբողջ թիվը բուլյանի, ապա նորից ամբողջ թվի։\n  ;; Մուտքագրում: Ամբողջ թիվ, որը գտնվում է ամբողջ թվերի տիրույթում։\n  ;; Ելք: Ամբողջ թիվ, որը ստացվել է սկզբնական ամբողջ թիվը բուլյանի փոխակերպելուց և ապա նորից ամբողջ թվի։\n  ;; Ելքը 1 է ցանկացած ոչ զրո մուտքային ամբողջ թվի համար, և 0՝ 0 մուտքագրման դեպքում։\n  ;; Օրինակ:\n  ;; >>> (int-bool-int-conversion 3)\n  ;; 1\n  ;; >>> (int-bool-int-conversion 0)\n  ;; 0\n  ;; >>> (int-bool-int-conversion -5)\n  ;; 1",
      "bn": "(defun int-bool-int-conversion (int)\n  ;; একটি পূর্ণসংখ্যাকে একটি বুলিয়ানে রূপান্তর করে তারপর আবার একটি পূর্ণসংখ্যায় রূপান্তর করে।\n  ;; ইনপুট: পূর্ণসংখ্যার মানগুলির পরিসরের মধ্যে একটি পূর্ণসংখ্যা।\n  ;; আউটপুট: প্রাথমিক পূর্ণসংখ্যাটিকে একটি বুলিয়ানে রূপান্তর করে তারপর আবার একটি পূর্ণসংখ্যায় রূপান্তরের ফলে প্রাপ্ত পূর্ণসংখ্যা।\n  ;; আউটপুটটি যেকোনো শূন্য ব্যতীত ইনপুট পূর্ণসংখ্যার জন্য 1 এবং 0 ইনপুটের জন্য 0।\n  ;; উদাহরণ:\n  ;; >>> (int-bool-int-conversion 3)\n  ;; 1\n  ;; >>> (int-bool-int-conversion 0)\n  ;; 0\n  ;; >>> (int-bool-int-conversion -5)\n  ;; 1",
      "bg": "(defun int-bool-int-conversion (int)\n  ;; Преобразува цяло число в булева стойност и след това обратно в цяло число.\n  ;; Вход: Цяло число в рамките на диапазона от стойности на целите числа.\n  ;; Изход: Цяло число, получено от преобразуването на първоначалното цяло число в булева стойност и след това обратно в цяло число.\n  ;; Изходът е 1 за всяко ненулево входно цяло число и 0 за входно число 0.\n  ;; Пример:\n  ;; >>> (int-bool-int-conversion 3)\n  ;; 1\n  ;; >>> (int-bool-int-conversion 0)\n  ;; 0\n  ;; >>> (int-bool-int-conversion -5)\n  ;; 1",
      "zh": "(defun int-bool-int-conversion (int)\n  ;; 将整数转换为布尔值，然后再转换回整数。\n  ;; 输入：一个在整数值范围内的整数。\n  ;; 输出：从初始整数转换为布尔值再转换回整数的结果。\n  ;; 对于任何非零输入整数，输出为1，对于输入为0，输出为0。\n  ;; 示例:\n  ;; >>> (int-bool-int-conversion 3)\n  ;; 1\n  ;; >>> (int-bool-int-conversion 0)\n  ;; 0\n  ;; >>> (int-bool-int-conversion -5)\n  ;; 1",
      "fr": "(defun int-bool-int-conversion (int)\n  ;; Convertit un entier en un booléen puis de nouveau en un entier.\n  ;; Entrée : Un entier dans la plage des valeurs entières.\n  ;; Sortie : Un entier résultant de la conversion de l'entier initial en un booléen puis de nouveau en un entier.\n  ;; La sortie est 1 pour tout entier d'entrée non nul, et 0 pour une entrée de 0.\n  ;; Exemple :\n  ;; >>> (int-bool-int-conversion 3)\n  ;; 1\n  ;; >>> (int-bool-int-conversion 0)\n  ;; 0\n  ;; >>> (int-bool-int-conversion -5)\n  ;; 1",
      "de": "(defun int-bool-int-conversion (int)\n  ;; Konvertiert eine ganze Zahl in einen booleschen Wert und dann zurück in eine ganze Zahl.\n  ;; Eingabe: Eine ganze Zahl innerhalb des Bereichs von Ganzzahlen.\n  ;; Ausgabe: Eine ganze Zahl, die aus der Umwandlung der ursprünglichen ganzen Zahl in einen booleschen Wert und dann zurück in eine ganze Zahl resultiert.\n  ;; Die Ausgabe ist 1 für jede von null verschiedene Eingabeganzzahl und 0 für eine Eingabe von 0.\n  ;; Beispiel:\n  ;; >>> (int-bool-int-conversion 3)\n  ;; 1\n  ;; >>> (int-bool-int-conversion 0)\n  ;; 0\n  ;; >>> (int-bool-int-conversion -5)\n  ;; 1",
      "ha": "(defun int-bool-int-conversion (int)\n  ;; Yana canza lamba mai lamba zuwa boolean sannan kuma ya mayar da ita zuwa lamba mai lamba.\n  ;; Shigarwa: Lamba mai lamba a cikin kewayon ƙimar lamba mai lamba.\n  ;; Fitarwa: Lamba mai lamba wanda ya samo asali daga canza lamba mai lamba na farko zuwa boolean sannan kuma ya mayar da ita zuwa lamba mai lamba.\n  ;; Fitarwa shine 1 don kowace lamba mai lamba da ba ta zama sifili ba, kuma 0 don shigarwa na 0.\n  ;; Misali:\n  ;; >>> (int-bool-int-conversion 3)\n  ;; 1\n  ;; >>> (int-bool-int-conversion 0)\n  ;; 0\n  ;; >>> (int-bool-int-conversion -5)\n  ;; 1",
      "hi": "(defun int-bool-int-conversion (int)\n  ;; एक पूर्णांक को एक बूलियन में परिवर्तित करता है और फिर वापस एक पूर्णांक में।\n  ;; इनपुट: पूर्णांक मानों की सीमा के भीतर एक पूर्णांक।\n  ;; आउटपुट: प्रारंभिक पूर्णांक को बूलियन में और फिर वापस पूर्णांक में परिवर्तित करने से प्राप्त एक पूर्णांक।\n  ;; आउटपुट किसी भी गैर-शून्य इनपुट पूर्णांक के लिए 1 है, और 0 के इनपुट के लिए 0 है।\n  ;; उदाहरण:\n  ;; >>> (int-bool-int-conversion 3)\n  ;; 1\n  ;; >>> (int-bool-int-conversion 0)\n  ;; 0\n  ;; >>> (int-bool-int-conversion -5)\n  ;; 1",
      "hu": "(defun int-bool-int-conversion (int)\n  ;; Egy egész számot átalakít logikai értékké, majd vissza egész számmá.\n  ;; Bemenet: Egy egész szám az egész számok tartományán belül.\n  ;; Kimenet: Egy egész szám, amely az eredeti egész szám logikai értékké, majd vissza egész számmá történő átalakításából származik.\n  ;; A kimenet 1 bármely nem nulla bemeneti egész szám esetén, és 0, ha a bemenet 0.\n  ;; Példa:\n  ;; >>> (int-bool-int-conversion 3)\n  ;; 1\n  ;; >>> (int-bool-int-conversion 0)\n  ;; 0\n  ;; >>> (int-bool-int-conversion -5)\n  ;; 1"
    },
    "prompt_bertscore": {
      "sq": "0.9886548285264303",
      "hy": "0.9785334188304166",
      "bn": "0.9766597384461144",
      "bg": "0.9749860788555145",
      "zh": "0.9572855297103525",
      "fr": "0.9933323753694209",
      "de": "0.9785409667848959",
      "ha": "0.9886548285264303",
      "hi": "0.9888157191350686",
      "hu": "0.974613448260693"
    },
    "canonical_solution": "  (if (= int 0) 0 1))",
    "instruction": {
      "en": "Write a Common Lisp function `(defun int-bool-int-conversion (int)` to solve the following problem: Converts an integer to a boolean and then back to an integer.\n Input: An integer within the range of integer values.\n Output: An integer resulting from the conversion of the initial integer to a boolean and then back to an integer.\n The output is 1 for any non-zero input integer, and 0 for an input of 0.\n Example:\n >>> (int-bool-int-conversion 3)\n 1\n >>> (int-bool-int-conversion 0)\n 0\n >>> (int-bool-int-conversion -5)\n 1",
      "sq": "Shkruani një funksion Common Lisp `(defun int-bool-int-conversion (int)` për të zgjidhur problemin e mëposhtëm: Konverton një numër të plotë në një boolean dhe pastaj përsëri në një numër të plotë.\n Hyrja: Një numër i plotë brenda intervalit të vlerave të numrave të plotë.\n Dalja: Një numër i plotë që rezulton nga konvertimi i numrit fillestar të plotë në një boolean dhe pastaj përsëri në një numër të plotë.\n Dalja është 1 për çdo numër të plotë hyrës që nuk është zero, dhe 0 për një hyrje prej 0.\n Shembull:\n >>> (int-bool-int-conversion 3)\n 1\n >>> (int-bool-int-conversion 0)\n 0\n >>> (int-bool-int-conversion -5)\n 1",
      "hy": "Գրեք Common Lisp ֆունկցիա `(defun int-bool-int-conversion (int)` հետևյալ խնդիրը լուծելու համար: Վերափոխում է ամբողջ թիվը բուլյան արժեքի, ապա հետ վերածում ամբողջ թվի:\n Մուտք: Ամբողջ թիվ, որը գտնվում է ամբողջ թվերի տիրույթում:\n Ելք: Ամբողջ թիվ, որը ստացվում է սկզբնական ամբողջ թիվը բուլյան արժեքի վերափոխելուց և ապա հետ ամբողջ թվի վերածելուց:\n Ելքը 1 է ցանկացած ոչ-զրո մուտքային ամբողջ թվի համար, և 0՝ 0 մուտքի համար:\n Օրինակ:\n >>> (int-bool-int-conversion 3)\n 1\n >>> (int-bool-int-conversion 0)\n 0\n >>> (int-bool-int-conversion -5)\n 1",
      "bn": "একটি Common Lisp ফাংশন `(defun int-bool-int-conversion (int)` লিখুন নিম্নলিখিত সমস্যার সমাধান করতে: একটি পূর্ণসংখ্যাকে একটি বুলিয়ানে রূপান্তর করে তারপর আবার একটি পূর্ণসংখ্যায় রূপান্তর করে।\n ইনপুট: পূর্ণসংখ্যার মানের সীমার মধ্যে একটি পূর্ণসংখ্যা।\n আউটপুট: প্রাথমিক পূর্ণসংখ্যাকে একটি বুলিয়ানে রূপান্তর করে তারপর আবার একটি পূর্ণসংখ্যায় রূপান্তর করার ফলে প্রাপ্ত একটি পূর্ণসংখ্যা।\n আউটপুটটি যেকোনো শূন্য ব্যতীত ইনপুট পূর্ণসংখ্যার জন্য 1, এবং 0 এর ইনপুটের জন্য 0।\n উদাহরণ:\n >>> (int-bool-int-conversion 3)\n 1\n >>> (int-bool-int-conversion 0)\n 0\n >>> (int-bool-int-conversion -5)\n 1",
      "bg": "Напишете функция на Common Lisp `(defun int-bool-int-conversion (int)` за решаване на следния проблем: Преобразува цяло число в булева стойност и след това обратно в цяло число.\n Вход: Цяло число в рамките на диапазона от стойности на целите числа.\n Изход: Цяло число, получено от преобразуването на първоначалното цяло число в булева стойност и след това обратно в цяло число.\n Изходът е 1 за всяко ненулево входно цяло число и 0 за вход от 0.\n Пример:\n >>> (int-bool-int-conversion 3)\n 1\n >>> (int-bool-int-conversion 0)\n 0\n >>> (int-bool-int-conversion -5)\n 1",
      "zh": "编写一个 Common Lisp 函数 `(defun int-bool-int-conversion (int)` 来解决以下问题：将整数转换为布尔值，然后再转换回整数。\n 输入：一个在整数值范围内的整数。\n 输出：一个整数，结果是将初始整数转换为布尔值然后再转换回整数。\n 对于任何非零输入整数，输出为 1，对于输入为 0，输出为 0。\n 示例:\n >>> (int-bool-int-conversion 3)\n 1\n >>> (int-bool-int-conversion 0)\n 0\n >>> (int-bool-int-conversion -5)\n 1",
      "fr": "Écrire une fonction Common Lisp `(defun int-bool-int-conversion (int)` pour résoudre le problème suivant : Convertit un entier en un booléen, puis de nouveau en un entier.\n Entrée : Un entier dans la plage des valeurs entières.\n Sortie : Un entier résultant de la conversion de l'entier initial en un booléen, puis de nouveau en un entier.\n La sortie est 1 pour toute entrée entière non nulle, et 0 pour une entrée de 0.\n Exemple:\n >>> (int-bool-int-conversion 3)\n 1\n >>> (int-bool-int-conversion 0)\n 0\n >>> (int-bool-int-conversion -5)\n 1",
      "de": "Schreiben Sie eine Common Lisp-Funktion `(defun int-bool-int-conversion (int)` um das folgende Problem zu lösen: Konvertiert eine ganze Zahl in einen Booleschen Wert und dann zurück in eine ganze Zahl.\n Eingabe: Eine ganze Zahl innerhalb des Bereichs von Ganzzahlen.\n Ausgabe: Eine ganze Zahl, die aus der Umwandlung der ursprünglichen ganzen Zahl in einen Booleschen Wert und dann zurück in eine ganze Zahl resultiert.\n Die Ausgabe ist 1 für jede von Null verschiedene Eingabeganzzahl und 0 für eine Eingabe von 0.\n Beispiel:\n >>> (int-bool-int-conversion 3)\n 1\n >>> (int-bool-int-conversion 0)\n 0\n >>> (int-bool-int-conversion -5)\n 1",
      "ha": "Rubuta aikin Common Lisp `(defun int-bool-int-conversion (int)` don warware matsalar mai zuwa: Canza cikakken lamba zuwa boolean sannan kuma koma zuwa cikakken lamba.\n Shigarwa: Cikakken lamba a cikin kewayon ƙimar cikakken lamba.\n Fitarwa: Cikakken lamba sakamakon canjin cikakken lamba na farko zuwa boolean sannan kuma koma zuwa cikakken lamba.\n Fitarwa yana da 1 don kowace cikakken lamba mara sifili, kuma 0 don shigarwa na 0.\n Misali:\n >>> (int-bool-int-conversion 3)\n 1\n >>> (int-bool-int-conversion 0)\n 0\n >>> (int-bool-int-conversion -5)\n 1",
      "hi": "एक Common Lisp फ़ंक्शन `(defun int-bool-int-conversion (int)` लिखें ताकि निम्नलिखित समस्या का समाधान हो सके: एक पूर्णांक को एक boolean में और फिर वापस एक पूर्णांक में परिवर्तित करता है।\n इनपुट: पूर्णांक मानों की सीमा के भीतर एक पूर्णांक।\n आउटपुट: प्रारंभिक पूर्णांक को एक boolean में और फिर वापस एक पूर्णांक में परिवर्तित करने से प्राप्त पूर्णांक।\n आउटपुट किसी भी गैर-शून्य इनपुट पूर्णांक के लिए 1 है, और 0 के इनपुट के लिए 0 है।\n उदाहरण:\n >>> (int-bool-int-conversion 3)\n 1\n >>> (int-bool-int-conversion 0)\n 0\n >>> (int-bool-int-conversion -5)\n 1",
      "hu": "Írj egy Common Lisp függvényt `(defun int-bool-int-conversion (int)` a következő probléma megoldására: Egész számot konvertál egy logikai értékre, majd vissza egész számra.\n Bemenet: Egy egész szám az egész számok tartományán belül.\n Kimenet: Egy egész szám, amely az eredeti egész szám logikai értékké, majd vissza egész számmá történő konvertálásából származik.\n A kimenet 1 bármely nem nulla bemeneti egész szám esetén, és 0, ha a bemenet 0.\n Példa:\n >>> (int-bool-int-conversion 3)\n 1\n >>> (int-bool-int-conversion 0)\n 0\n >>> (int-bool-int-conversion -5)\n 1"
    },
    "instruction_bertscore": {
      "sq": "0.9924852167943071",
      "hy": "0.9837820280188824",
      "bn": "0.9857605852443709",
      "bg": "0.9768134783610354",
      "zh": "0.957191974800885",
      "fr": "0.9893863842197818",
      "de": "0.9780549182425035",
      "ha": "0.9741546120805025",
      "hi": "0.9865372300342173",
      "hu": "0.9771968349964327"
    },
    "level": "easy",
    "test": "(defun check-int-bool-int-conversion ()\n  (assert (= (int-bool-int-conversion 3) 1))\n  (assert (= (int-bool-int-conversion 0) 0))\n  (assert (= (int-bool-int-conversion -5) 1))\n  (assert (= (int-bool-int-conversion 1) 1))\n  (assert (= (int-bool-int-conversion 100) 1)))\n\n(check-int-bool-int-conversion)",
    "entry_point": "int-bool-int-conversion",
    "signature": "(defun int-bool-int-conversion (int)",
    "docstring": {
      "en": "Converts an integer to a boolean and then back to an integer.\n Input: An integer within the range of integer values.\n Output: An integer resulting from the conversion of the initial integer to a boolean and then back to an integer.\n The output is 1 for any non-zero input integer, and 0 for an input of 0.\n Example:\n >>> (int-bool-int-conversion 3)\n 1\n >>> (int-bool-int-conversion 0)\n 0\n >>> (int-bool-int-conversion -5)\n 1",
      "sq": "Konverton një numër të plotë në një boolean dhe pastaj përsëri në një numër të plotë.  \nHyrja: Një numër i plotë brenda intervalit të vlerave të numrave të plotë.  \nDalja: Një numër i plotë që rezulton nga konvertimi i numrit fillestar të plotë në një boolean dhe pastaj përsëri në një numër të plotë.  \nDalja është 1 për çdo hyrje të numrit të plotë që nuk është zero, dhe 0 për një hyrje prej 0.  \nShembull:  \n>>> (int-bool-int-conversion 3)  \n1  \n>>> (int-bool-int-conversion 0)  \n0  \n>>> (int-bool-int-conversion -5)  \n1  ",
      "hy": "Փոխակերպում է ամբողջ թիվը տրամաբանական արժեքի և ապա հետ ամբողջ թվի:\nՄուտք: Ամբողջ թիվ, որը գտնվում է ամբողջ թվերի արժեքների տիրույթում:\nԵլք: Ամբողջ թիվ, որը ստացվում է սկզբնական ամբողջ թիվը տրամաբանական արժեքի և ապա հետ ամբողջ թվի փոխակերպումից:\nԵլքը 1 է ցանկացած ոչ զրո մուտքային ամբողջ թվի համար, և 0՝ 0 մուտքի համար:\nՕրինակ:\n>>> (int-bool-int-conversion 3)\n1\n>>> (int-bool-int-conversion 0)\n0\n>>> (int-bool-int-conversion -5)\n1",
      "bn": "একটি পূর্ণসংখ্যাকে একটি বুলিয়ানে রূপান্তর করে তারপর আবার একটি পূর্ণসংখ্যায় রূপান্তর করে।\nইনপুট: পূর্ণসংখ্যার মানের পরিসরের মধ্যে একটি পূর্ণসংখ্যা।\nআউটপুট: প্রাথমিক পূর্ণসংখ্যাকে একটি বুলিয়ানে রূপান্তর করে তারপর আবার একটি পূর্ণসংখ্যায় রূপান্তরের ফলে প্রাপ্ত একটি পূর্ণসংখ্যা।\nআউটপুটটি যেকোনো শূন্য ব্যতীত ইনপুট পূর্ণসংখ্যার জন্য 1 এবং 0 এর জন্য 0 হয়।\nউদাহরণ:\n>>> (int-bool-int-conversion 3)\n1\n>>> (int-bool-int-conversion 0)\n0\n>>> (int-bool-int-conversion -5)\n1",
      "bg": "Преобразува цяло число в булева стойност и след това обратно в цяло число.  \nВход: Цяло число в рамките на диапазона на целочислените стойности.  \nИзход: Цяло число, получено от преобразуването на първоначалното цяло число в булева стойност и след това обратно в цяло число.  \nИзходът е 1 за всяко ненулево входно цяло число и 0 за входно число 0.  \nПример:  \n>>> (int-bool-int-conversion 3)  \n1  \n>>> (int-bool-int-conversion 0)  \n0  \n>>> (int-bool-int-conversion -5)  \n1  ",
      "zh": "将整数转换为布尔值，然后再转换回整数。\n输入：一个在整数值范围内的整数。\n输出：将初始整数转换为布尔值然后再转换回整数的结果整数。  \n对于任何非零输入整数，输出为1；对于输入为0，输出为0。  \n示例：  \n>>> (int-bool-int-conversion 3)  \n1  \n>>> (int-bool-int-conversion 0)  \n0  \n>>> (int-bool-int-conversion -5)  \n1  ",
      "fr": "Convertit un entier en un booléen puis de nouveau en un entier.\nEntrée : Un entier dans la plage des valeurs entières.  \nSortie : Un entier résultant de la conversion de l'entier initial en un booléen puis de nouveau en un entier.  \nLa sortie est 1 pour toute entrée entière non nulle, et 0 pour une entrée de 0.  \nExemple :  \n>>> (int-bool-int-conversion 3)  \n1  \n>>> (int-bool-int-conversion 0)  \n0  \n>>> (int-bool-int-conversion -5)  \n1",
      "de": "Konvertiert eine Ganzzahl in einen Booleschen Wert und dann zurück in eine Ganzzahl.  \nEingabe: Eine Ganzzahl innerhalb des Bereichs von Ganzzahlwerten.  \nAusgabe: Eine Ganzzahl, die aus der Umwandlung der ursprünglichen Ganzzahl in einen Booleschen Wert und dann zurück in eine Ganzzahl resultiert.  \nDie Ausgabe ist 1 für jede von null verschiedene Eingabeganzzahl und 0 für eine Eingabe von 0.  \nBeispiel:  \n>>> (int-bool-int-conversion 3)  \n1  \n>>> (int-bool-int-conversion 0)  \n0  \n>>> (int-bool-int-conversion -5)  \n1  ",
      "ha": "Yana canza lamba mai lamba zuwa boolean sannan kuma ya mayar da ita zuwa lamba mai lamba.  \nShigarwa: Lamba cikin kewayon ƙimar lamba.  \nFitarwa: Lamba da aka samu daga jujjuyawar lambar farko zuwa boolean sannan kuma zuwa lamba.  \nFitarwar ita ce 1 don kowace lamba mai shigarwa da ba ta zama sifili ba, kuma 0 don shigarwa na 0.  \nMisali:  \n>>> (int-bool-int-conversion 3)  \n1  \n>>> (int-bool-int-conversion 0)  \n0  \n>>> (int-bool-int-conversion -5)  \n1  ",
      "hi": "पूर्णांक को बूलियन में और फिर वापस पूर्णांक में परिवर्तित करता है।\nइनपुट: पूर्णांक मानों की सीमा के भीतर एक पूर्णांक।  \nआउटपुट: प्रारंभिक पूर्णांक को बूलियन में और फिर वापस पूर्णांक में परिवर्तित करने से प्राप्त पूर्णांक।  \nआउटपुट किसी भी गैर-शून्य इनपुट पूर्णांक के लिए 1 होता है, और 0 के इनपुट के लिए 0 होता है।  \nउदाहरण:  \n>>> (int-bool-int-conversion 3)  \n1  \n>>> (int-bool-int-conversion 0)  \n0  \n>>> (int-bool-int-conversion -5)  \n1  ",
      "hu": "Egy egész számot logikai értékké, majd vissza egész számmá alakít.\nBemenet: Egy egész szám az egész számok tartományán belül.  \nKimenet: Egy egész szám, amely az eredeti egész szám logikai értékké, majd vissza egész számmá történő átalakításából származik.  \nA kimenet 1 bármely nem nulla bemeneti egész szám esetén, és 0, ha a bemenet 0.  \nPélda:  \n>>> (int-bool-int-conversion 3)  \n1  \n>>> (int-bool-int-conversion 0)  \n0  \n>>> (int-bool-int-conversion -5)  \n1  "
    },
    "docstring_bertscore": {
      "sq": "0.9908320161329537",
      "hy": "0.9854775369513962",
      "bn": "0.9741101188751506",
      "bg": "0.9617789461901237",
      "zh": "0.9481048334989199",
      "fr": "0.9822585329963448",
      "de": "0.9817099158839264",
      "ha": "0.9888578287758479",
      "hi": "0.9853748450444012",
      "hu": "0.9621291315518882"
    }
  },
  {
    "task_id": "Common Lisp/46",
    "prompt": {
      "en": "(defun nth-term-arithmetic-sequence (a1 a2 n)\n  ;; Calculates the nth term of an arithmetic sequence given the first two terms.\n  ;; Input: Three integers 'a1' and 'a2' representing the first two terms of the sequence, and 'n' the term number to find.\n  ;; Output: The value of the nth term in the arithmetic sequence.\n  ;; Example:\n  ;; >>> (nth-term-arithmetic-sequence 1 4 100)\n  ;; 298\n  ;; >>> (nth-term-arithmetic-sequence 2 5 10)\n  ;; 29",
      "sq": "(defun nth-term-arithmetic-sequence (a1 a2 n)\n  ;; Llogarit termin e n-të të një vargu aritmetik duke dhënë dy termat e parë.\n  ;; Input: Tre numra të plotë 'a1' dhe 'a2' që përfaqësojnë dy termat e parë të vargut, dhe 'n' numri i termit për të gjetur.\n  ;; Output: Vlera e termit të n-të në vargun aritmetik.\n  ;; Shembull:\n  ;; >>> (nth-term-arithmetic-sequence 1 4 100)\n  ;; 298\n  ;; >>> (nth-term-arithmetic-sequence 2 5 10)\n  ;; 29",
      "hy": "(defun nth-term-arithmetic-sequence (a1 a2 n)\n  ;; Հաշվում է թվաբանական հաջորդականության n-րդ անդամը՝ հաշվի առնելով առաջին երկու անդամները։\n  ;; Մուտքագրում: Երեք ամբողջ թիվ 'a1' և 'a2', որոնք ներկայացնում են հաջորդականության առաջին երկու անդամները, և 'n'՝ գտնվելիք անդամի համարը։\n  ;; Ելք: Թվաբանական հաջորդականության n-րդ անդամի արժեքը։\n  ;; Օրինակ:\n  ;; >>> (nth-term-arithmetic-sequence 1 4 100)\n  ;; 298\n  ;; >>> (nth-term-arithmetic-sequence 2 5 10)\n  ;; 29",
      "bn": "(defun nth-term-arithmetic-sequence (a1 a2 n)\n  ;; একটি গাণিতিক ক্রমের n তম পদ গণনা করে যখন প্রথম দুটি পদ দেওয়া হয়।\n  ;; ইনপুট: তিনটি পূর্ণসংখ্যা 'a1' এবং 'a2' যা ক্রমের প্রথম দুটি পদকে উপস্থাপন করে, এবং 'n' যা খুঁজতে হবে এমন পদ সংখ্যা।\n  ;; আউটপুট: গাণিতিক ক্রমের n তম পদের মান।\n  ;; উদাহরণ:\n  ;; >>> (nth-term-arithmetic-sequence 1 4 100)\n  ;; 298\n  ;; >>> (nth-term-arithmetic-sequence 2 5 10)\n  ;; 29",
      "bg": "(defun nth-term-arithmetic-sequence (a1 a2 n)\n  ;; Изчислява n-тия член на аритметична прогресия, като са дадени първите два члена.\n  ;; Вход: Три цели числа 'a1' и 'a2', представляващи първите два члена на прогресията, и 'n' номерът на члена, който трябва да се намери.\n  ;; Изход: Стойността на n-тия член в аритметичната прогресия.\n  ;; Пример:\n  ;; >>> (nth-term-arithmetic-sequence 1 4 100)\n  ;; 298\n  ;; >>> (nth-term-arithmetic-sequence 2 5 10)\n  ;; 29",
      "zh": "(defun nth-term-arithmetic-sequence (a1 a2 n)\n  ;; 计算等差数列的第n项，给定前两项。\n  ;; 输入：三个整数 'a1' 和 'a2' 表示数列的前两项，'n' 表示要查找的项数。\n  ;; 输出：等差数列中第n项的值。\n  ;; 示例:\n  ;; >>> (nth-term-arithmetic-sequence 1 4 100)\n  ;; 298\n  ;; >>> (nth-term-arithmetic-sequence 2 5 10)\n  ;; 29",
      "fr": "(defun nth-term-arithmetic-sequence (a1 a2 n)\n  ;; Calcule le nième terme d'une suite arithmétique étant donné les deux premiers termes.\n  ;; Entrée : Trois entiers 'a1' et 'a2' représentant les deux premiers termes de la suite, et 'n' le numéro du terme à trouver.\n  ;; Sortie : La valeur du nième terme dans la suite arithmétique.\n  ;; Exemple :\n  ;; >>> (nth-term-arithmetic-sequence 1 4 100)\n  ;; 298\n  ;; >>> (nth-term-arithmetic-sequence 2 5 10)\n  ;; 29",
      "de": "(defun nth-term-arithmetic-sequence (a1 a2 n)\n  ;; Berechnet das n-te Glied einer arithmetischen Folge, gegeben die ersten beiden Glieder.\n  ;; Eingabe: Drei ganze Zahlen 'a1' und 'a2', die die ersten beiden Glieder der Folge darstellen, und 'n', die Nummer des zu findenden Glieds.\n  ;; Ausgabe: Der Wert des n-ten Glieds in der arithmetischen Folge.\n  ;; Beispiel:\n  ;; >>> (nth-term-arithmetic-sequence 1 4 100)\n  ;; 298\n  ;; >>> (nth-term-arithmetic-sequence 2 5 10)\n  ;; 29",
      "ha": "(defun nth-term-arithmetic-sequence (a1 a2 n)\n  ;; Lissafi na n na jere na lissafi da aka bayar da farkon sharuɗɗa biyu.\n  ;; Shigarwa: Lambobi guda uku 'a1' da 'a2' suna wakiltar farkon sharuɗɗa biyu na jeren, da 'n' lambar sharadi da za a samu.\n  ;; Fitarwa: Darajar na n na jere na lissafi.\n  ;; Misali:\n  ;; >>> (nth-term-arithmetic-sequence 1 4 100)\n  ;; 298\n  ;; >>> (nth-term-arithmetic-sequence 2 5 10)\n  ;; 29",
      "hi": "(defun nth-term-arithmetic-sequence (a1 a2 n)\n  ;; एक अंकगणितीय अनुक्रम के nth पद की गणना करता है जब पहले दो पद दिए गए हों।\n  ;; इनपुट: तीन पूर्णांक 'a1' और 'a2' जो अनुक्रम के पहले दो पदों का प्रतिनिधित्व करते हैं, और 'n' वह पद संख्या है जिसे खोजना है।\n  ;; आउटपुट: अंकगणितीय अनुक्रम में nth पद का मान।\n  ;; उदाहरण:\n  ;; >>> (nth-term-arithmetic-sequence 1 4 100)\n  ;; 298\n  ;; >>> (nth-term-arithmetic-sequence 2 5 10)\n  ;; 29",
      "hu": "(defun nth-term-arithmetic-sequence (a1 a2 n)\n  ;; Kiszámítja egy számtani sorozat n-edik tagját az első két tag alapján.\n  ;; Bemenet: Három egész szám 'a1' és 'a2', amelyek a sorozat első két tagját képviselik, valamint 'n', amely a keresett tag sorszáma.\n  ;; Kimenet: Az n-edik tag értéke a számtani sorozatban.\n  ;; Példa:\n  ;; >>> (nth-term-arithmetic-sequence 1 4 100)\n  ;; 298\n  ;; >>> (nth-term-arithmetic-sequence 2 5 10)\n  ;; 29"
    },
    "prompt_bertscore": {
      "sq": "1",
      "hy": "0.9753924766151119",
      "bn": "0.9732456794568868",
      "bg": "0.9791958511511679",
      "zh": "0.9866798466478004",
      "fr": "1",
      "de": "0.9717674721612252",
      "ha": "0.9837081375171375",
      "hi": "0.9820209710606271",
      "hu": "0.9521096192413454"
    },
    "canonical_solution": "  (+ a1 (* (1- n) (- a2 a1))))",
    "instruction": {
      "en": "Write a Common Lisp function `(defun nth-term-arithmetic-sequence (a1 a2 n)` to solve the following problem: Calculates the nth term of an arithmetic sequence given the first two terms.\n Input: Three integers 'a1' and 'a2' representing the first two terms of the sequence, and 'n' the term number to find.\n Output: The value of the nth term in the arithmetic sequence.\n Example:\n >>> (nth-term-arithmetic-sequence 1 4 100)\n 298\n >>> (nth-term-arithmetic-sequence 2 5 10)\n 29",
      "sq": "Shkruani një funksion Common Lisp `(defun nth-term-arithmetic-sequence (a1 a2 n)` për të zgjidhur problemin e mëposhtëm: Llogarit termin e n-të të një sekuence aritmetike duke pasur parasysh dy termat e parë.\n Hyrja: Tre numra të plotë 'a1' dhe 'a2' që përfaqësojnë dy termat e parë të sekuencës, dhe 'n' numri i termit që do të gjendet.\n Dalja: Vlera e termit të n-të në sekuencën aritmetike.\n Shembull:\n >>> (nth-term-arithmetic-sequence 1 4 100)\n 298\n >>> (nth-term-arithmetic-sequence 2 5 10)\n 29",
      "hy": "Գրեք Common Lisp ֆունկցիա `(defun nth-term-arithmetic-sequence (a1 a2 n)` հետևյալ խնդիրը լուծելու համար: Հաշվում է թվաբանական հաջորդականության n-րդ անդամը՝ հաշվի առնելով առաջին երկու անդամները:\n Մուտք: Երեք ամբողջ թիվ՝ 'a1' և 'a2', որոնք ներկայացնում են հաջորդականության առաջին երկու անդամները, և 'n'՝ այն անդամի համարը, որը պետք է գտնել:\n Ելք: Թվաբանական հաջորդականության n-րդ անդամի արժեքը:\n Օրինակ:\n >>> (nth-term-arithmetic-sequence 1 4 100)\n 298\n >>> (nth-term-arithmetic-sequence 2 5 10)\n 29",
      "bn": "Common Lisp ফাংশন `(defun nth-term-arithmetic-sequence (a1 a2 n)` লিখুন নিম্নলিখিত সমস্যার সমাধানের জন্য: প্রথম দুটি পদ দেওয়া থাকলে একটি গাণিতিক ক্রমের nতম পদ গণনা করে।\n ইনপুট: তিনটি পূর্ণসংখ্যা 'a1' এবং 'a2' ক্রমের প্রথম দুটি পদ উপস্থাপন করে, এবং 'n' সেই পদটির সংখ্যা যা খুঁজে বের করতে হবে।\n আউটপুট: গাণিতিক ক্রমের nতম পদের মান।\n উদাহরণ:\n >>> (nth-term-arithmetic-sequence 1 4 100)\n 298\n >>> (nth-term-arithmetic-sequence 2 5 10)\n 29",
      "bg": "Напишете функция на Common Lisp `(defun nth-term-arithmetic-sequence (a1 a2 n)` за решаване на следния проблем: Изчислява n-тия член на аритметична прогресия, като са дадени първите два члена.\n Вход: Три цели числа 'a1' и 'a2', представляващи първите два члена на прогресията, и 'n', номерът на члена, който трябва да се намери.\n Изход: Стойността на n-тия член в аритметичната прогресия.\n Пример:\n >>> (nth-term-arithmetic-sequence 1 4 100)\n 298\n >>> (nth-term-arithmetic-sequence 2 5 10)\n 29",
      "zh": "编写一个 Common Lisp 函数 `(defun nth-term-arithmetic-sequence (a1 a2 n)` 来解决以下问题：计算给定前两个项的等差数列的第 n 项。\n 输入：三个整数 'a1' 和 'a2' 表示数列的前两个项，'n' 表示要查找的项数。\n 输出：等差数列中第 n 项的值。\n 示例:\n >>> (nth-term-arithmetic-sequence 1 4 100)\n 298\n >>> (nth-term-arithmetic-sequence 2 5 10)\n 29",
      "fr": "Écrire une fonction Common Lisp `(defun nth-term-arithmetic-sequence (a1 a2 n)` pour résoudre le problème suivant : Calcule le nième terme d'une suite arithmétique étant donné les deux premiers termes.\n Entrée : Trois entiers 'a1' et 'a2' représentant les deux premiers termes de la suite, et 'n' le numéro du terme à trouver.\n Sortie : La valeur du nième terme dans la suite arithmétique.\n Exemple :\n >>> (nth-term-arithmetic-sequence 1 4 100)\n 298\n >>> (nth-term-arithmetic-sequence 2 5 10)\n 29",
      "de": "Schreiben Sie eine Common Lisp-Funktion `(defun nth-term-arithmetic-sequence (a1 a2 n)`, um das folgende Problem zu lösen: Berechnet das n-te Glied einer arithmetischen Folge, gegeben die ersten beiden Glieder.\n Eingabe: Drei ganze Zahlen 'a1' und 'a2', die die ersten beiden Glieder der Folge darstellen, und 'n', die Nummer des zu findenden Glieds.\n Ausgabe: Der Wert des n-ten Glieds in der arithmetischen Folge.\n Beispiel:\n >>> (nth-term-arithmetic-sequence 1 4 100)\n 298\n >>> (nth-term-arithmetic-sequence 2 5 10)\n 29",
      "ha": "Rubuta aikin Common Lisp `(defun nth-term-arithmetic-sequence (a1 a2 n)` don warware matsalar mai zuwa: Lissafi na n na jerin lissafi idan aka ba da farkon kalmomi biyu.\n Shigarwa: Lambobi guda uku 'a1' da 'a2' suna wakiltar farkon kalmomi biyu na jerin, da 'n' lambar kalmar da za a samu.\n Fitarwa: Darajar kalma ta n a cikin jerin lissafi.\n Misali:\n >>> (nth-term-arithmetic-sequence 1 4 100)\n 298\n >>> (nth-term-arithmetic-sequence 2 5 10)\n 29",
      "hi": "एक Common Lisp फ़ंक्शन `(defun nth-term-arithmetic-sequence (a1 a2 n)` लिखें ताकि निम्नलिखित समस्या का समाधान किया जा सके: दिए गए पहले दो पदों के आधार पर एक अंकगणितीय अनुक्रम के nth पद की गणना करता है।\n इनपुट: तीन पूर्णांक 'a1' और 'a2' जो अनुक्रम के पहले दो पदों का प्रतिनिधित्व करते हैं, और 'n' वह पद संख्या है जिसे खोजना है।\n आउटपुट: अंकगणितीय अनुक्रम में nth पद का मान।\n उदाहरण:\n >>> (nth-term-arithmetic-sequence 1 4 100)\n 298\n >>> (nth-term-arithmetic-sequence 2 5 10)\n 29",
      "hu": "Írj egy Common Lisp függvényt `(defun nth-term-arithmetic-sequence (a1 a2 n)` a következő probléma megoldására: Kiszámítja egy számtani sorozat n-edik tagját az első két tag alapján.\n Bemenet: Három egész szám 'a1' és 'a2', amelyek a sorozat első két tagját képviselik, és 'n', amely a keresett tag sorszáma.\n Kimenet: Az n-edik tag értéke a számtani sorozatban.\n Példa:\n >>> (nth-term-arithmetic-sequence 1 4 100)\n 298\n >>> (nth-term-arithmetic-sequence 2 5 10)\n 29"
    },
    "instruction_bertscore": {
      "sq": "0.9766621220106868",
      "hy": "0.9794038171601114",
      "bn": "0.9791092483050367",
      "bg": "0.979497967960722",
      "zh": "0.9930103955217633",
      "fr": "0.9906415295975413",
      "de": "0.9711954166638447",
      "ha": "0.9729656106196276",
      "hi": "0.9827052527232922",
      "hu": "0.9629498722863243"
    },
    "level": "easy",
    "test": "(defun check-nth-term-arithmetic-sequence ()\n  (assert (= (nth-term-arithmetic-sequence 1 4 100) 298))\n  (assert (= (nth-term-arithmetic-sequence 2 5 10) 29))\n  (assert (= (nth-term-arithmetic-sequence 0 3 4) 9))\n  (assert (= (nth-term-arithmetic-sequence -3 1 5) 13))\n  (assert (= (nth-term-arithmetic-sequence 100 -100 50) -9700)))\n\n(check-nth-term-arithmetic-sequence)",
    "entry_point": "nth-term-arithmetic-sequence",
    "signature": "(defun nth-term-arithmetic-sequence (a1 a2 n)",
    "docstring": {
      "en": "Calculates the nth term of an arithmetic sequence given the first two terms.\n Input: Three integers 'a1' and 'a2' representing the first two terms of the sequence, and 'n' the term number to find.\n Output: The value of the nth term in the arithmetic sequence.\n Example:\n >>> (nth-term-arithmetic-sequence 1 4 100)\n 298\n >>> (nth-term-arithmetic-sequence 2 5 10)\n 29",
      "sq": "Llogarit termin e n-të të një vargu aritmetik duke dhënë dy termat e parë.\nHyrja: Tre numra të plotë 'a1' dhe 'a2' që përfaqësojnë dy termat e parë të vargut, dhe 'n' numri i termit që do të gjendet.\nDalja: Vlera e termit të n-të në vargun aritmetik.\nShembull:\n>>> (nth-term-arithmetic-sequence 1 4 100)\n298\n>>> (nth-term-arithmetic-sequence 2 5 10)\n29",
      "hy": "Հաշվում է թվաբանական հաջորդականության n-րդ անդամը՝ տրված առաջին երկու անդամները։  \nՄուտք: Երեք ամբողջ թիվ՝ 'a1' և 'a2', որոնք ներկայացնում են հաջորդականության առաջին երկու անդամները, և 'n'՝ այն անդամի համարը, որը պետք է գտնել։  \nԵլք: Թվաբանական հաջորդականության n-րդ անդամի արժեքը։  \nՕրինակ:  \n>>> (nth-term-arithmetic-sequence 1 4 100)  \n298  \n>>> (nth-term-arithmetic-sequence 2 5 10)  \n29  ",
      "bn": "nth পদ নির্ণয় করে একটি গাণিতিক ক্রমের, প্রথম দুটি পদ দেওয়া হলে।  \nইনপুট: তিনটি পূর্ণসংখ্যা 'a1' এবং 'a2' যা ক্রমের প্রথম দুটি পদ নির্দেশ করে, এবং 'n' যা খুঁজতে চাওয়া পদের সংখ্যা।  \nআউটপুট: গাণিতিক ক্রমের nth পদের মান।  \nউদাহরণ:  \n>>> (nth-term-arithmetic-sequence 1 4 100)  \n298  \n>>> (nth-term-arithmetic-sequence 2 5 10)  \n29",
      "bg": "Изчислява n-тия член на аритметична прогресия, като се дадат първите два члена.\nВход: Три цели числа 'a1' и 'a2', представляващи първите два члена на прогресията, и 'n' - номерът на члена, който трябва да се намери.\nИзход: Стойността на n-тия член в аритметичната прогресия.\nПример:\n>>> (nth-term-arithmetic-sequence 1 4 100)\n298\n>>> (nth-term-arithmetic-sequence 2 5 10)\n29",
      "zh": "计算给定前两个项的等差数列的第 n 项。  \n输入：三个整数 'a1' 和 'a2' 表示数列的前两个项，以及 'n' 表示要查找的项的编号。  \n输出：等差数列中第 n 项的值。  \n示例：  \n>>> (nth-term-arithmetic-sequence 1 4 100)  \n298  \n>>> (nth-term-arithmetic-sequence 2 5 10)  \n29  ",
      "fr": "Calcule le nième terme d'une suite arithmétique donnée par les deux premiers termes.  \nEntrée : Trois entiers 'a1' et 'a2' représentant les deux premiers termes de la suite, et 'n' le numéro du terme à trouver.  \nSortie : La valeur du nième terme dans la suite arithmétique.  \nExemple :  \n>>> (nth-term-arithmetic-sequence 1 4 100)  \n298  \n>>> (nth-term-arithmetic-sequence 2 5 10)  \n29",
      "de": "Berechnet das n-te Glied einer arithmetischen Folge, gegeben die ersten beiden Glieder.\nEingabe: Drei ganze Zahlen 'a1' und 'a2', die die ersten beiden Glieder der Folge darstellen, und 'n', die Nummer des zu findenden Gliedes.\nAusgabe: Der Wert des n-ten Gliedes in der arithmetischen Folge.\nBeispiel:\n>>> (nth-term-arithmetic-sequence 1 4 100)\n298\n>>> (nth-term-arithmetic-sequence 2 5 10)\n29",
      "ha": "Yana ƙididdige sharadi na nth na jere na lissafi idan aka ba da sharuddan farko biyu.\nShigarwa: Lambobi guda uku 'a1' da 'a2' suna wakiltar sharuddan farko biyu na jerin, da 'n' lambar sharadi don samu.\nFitarwa: Darajar sharadi na nth a cikin jere na lissafi.\nMisali:\n>>> (nth-term-arithmetic-sequence 1 4 100)\n298\n>>> (nth-term-arithmetic-sequence 2 5 10)\n29",
      "hi": "nth पद का मान निकालता है एक अंकगणितीय अनुक्रम का, जब पहले दो पद दिए गए हों।\nइनपुट: तीन पूर्णांक 'a1' और 'a2' जो अनुक्रम के पहले दो पदों का प्रतिनिधित्व करते हैं, और 'n' वह पद संख्या है जिसे खोजना है।\nआउटपुट: अंकगणितीय अनुक्रम में nth पद का मान।\nउदाहरण:\n>>> (nth-term-arithmetic-sequence 1 4 100)\n298\n>>> (nth-term-arithmetic-sequence 2 5 10)\n29",
      "hu": "Kiszámítja egy számtani sorozat n-edik tagját az első két tag alapján.  \nBemenet: Három egész szám, 'a1' és 'a2', amelyek a sorozat első két tagját jelölik, valamint 'n', amely a keresett tag sorszáma.  \nKimenet: Az n-edik tag értéke a számtani sorozatban.  \nPélda:  \n>>> (nth-term-arithmetic-sequence 1 4 100)  \n298  \n>>> (nth-term-arithmetic-sequence 2 5 10)  \n29  "
    },
    "docstring_bertscore": {
      "sq": "0.9698226821005126",
      "hy": "0.9771076499553482",
      "bn": "0.9344589263218231",
      "bg": "0.9621257548354106",
      "zh": "0.9722868906076314",
      "fr": "0.9790697208592107",
      "de": "0.9634381057629081",
      "ha": "0.9738777213293398",
      "hi": "0.9547551772863491",
      "hu": "0.9471108870722214"
    }
  },
  {
    "task_id": "Common Lisp/47",
    "prompt": {
      "en": "(defun multiply-a-b (a b)\n  ;; Multiplies two positive integers A and B and returns the product.\n  ;; Input: Two positive integers 'a' and 'b', where 1 <= a, b <= 50000.\n  ;; Output: The product of 'a' and 'b'.\n  ;; Example:\n  ;; >>> (multiply-a-b 3 4)\n  ;; 12\n  ;; >>> (multiply-a-b 36 18)\n  ;; 648",
      "sq": "(defun multiply-a-b (a b)\n  ;; Shumzon dy numra të plotë pozitivë A dhe B dhe kthen produktin.\n  ;; Hyrja: Dy numra të plotë pozitivë 'a' dhe 'b', ku 1 <= a, b <= 50000.\n  ;; Dalja: Produkti i 'a' dhe 'b'.\n  ;; Shembull:\n  ;; >>> (multiply-a-b 3 4)\n  ;; 12\n  ;; >>> (multiply-a-b 36 18)\n  ;; 648",
      "hy": "(defun multiply-a-b (a b)\n  ;; Երկու դրական ամբողջ թիվ A և B բազմապատկում է և վերադարձնում արդյունքը։\n  ;; Մուտք: Երկու դրական ամբողջ թիվ 'a' և 'b', որտեղ 1 <= a, b <= 50000։\n  ;; Ելք: 'a' և 'b' թվերի արտադրյալը։\n  ;; Օրինակ:\n  ;; >>> (multiply-a-b 3 4)\n  ;; 12\n  ;; >>> (multiply-a-b 36 18)\n  ;; 648",
      "bn": "(defun multiply-a-b (a b)\n  ;; দুটি ধনাত্মক পূর্ণসংখ্যা A এবং B গুণ করে গুণফল প্রদান করে।\n  ;; ইনপুট: দুটি ধনাত্মক পূর্ণসংখ্যা 'a' এবং 'b', যেখানে 1 <= a, b <= 50000।\n  ;; আউটপুট: 'a' এবং 'b' এর গুণফল।\n  ;; উদাহরণ:\n  ;; >>> (multiply-a-b 3 4)\n  ;; 12\n  ;; >>> (multiply-a-b 36 18)\n  ;; 648",
      "bg": "(defun multiply-a-b (a b)\n  ;; Умножава две положителни цели числа A и B и връща произведението.\n  ;; Вход: Две положителни цели числа 'a' и 'b', където 1 <= a, b <= 50000.\n  ;; Изход: Произведението на 'a' и 'b'.\n  ;; Пример:\n  ;; >>> (multiply-a-b 3 4)\n  ;; 12\n  ;; >>> (multiply-a-b 36 18)\n  ;; 648",
      "zh": "(defun multiply-a-b (a b)\n  ;; 乘以两个正整数 A 和 B 并返回乘积。\n  ;; 输入：两个正整数 'a' 和 'b'，其中 1 <= a, b <= 50000。\n  ;; 输出：'a' 和 'b' 的乘积。\n  ;; 示例:\n  ;; >>> (multiply-a-b 3 4)\n  ;; 12\n  ;; >>> (multiply-a-b 36 18)\n  ;; 648",
      "fr": "(defun multiply-a-b (a b)\n  ;; Multiplie deux entiers positifs A et B et renvoie le produit.\n  ;; Entrée : Deux entiers positifs 'a' et 'b', où 1 <= a, b <= 50000.\n  ;; Sortie : Le produit de 'a' et 'b'.\n  ;; Exemple :\n  ;; >>> (multiply-a-b 3 4)\n  ;; 12\n  ;; >>> (multiply-a-b 36 18)\n  ;; 648",
      "de": "(defun multiply-a-b (a b)\n  ;; Multipliziert zwei positive ganze Zahlen A und B und gibt das Produkt zurück.\n  ;; Eingabe: Zwei positive ganze Zahlen 'a' und 'b', wobei 1 <= a, b <= 50000.\n  ;; Ausgabe: Das Produkt von 'a' und 'b'.\n  ;; Beispiel:\n  ;; >>> (multiply-a-b 3 4)\n  ;; 12\n  ;; >>> (multiply-a-b 36 18)\n  ;; 648",
      "ha": "(defun multiply-a-b (a b)\n  ;; Ninka lambobi guda biyu masu kyau A da B kuma ya dawo da sakamakon.\n  ;; Shigarwa: Lambobi guda biyu masu kyau 'a' da 'b', inda 1 <= a, b <= 50000.\n  ;; Fitarwa: Sakamakon ninkewar 'a' da 'b'.\n  ;; Misali:\n  ;; >>> (multiply-a-b 3 4)\n  ;; 12\n  ;; >>> (multiply-a-b 36 18)\n  ;; 648",
      "hi": "(defun multiply-a-b (a b)\n  ;; दो धनात्मक पूर्णांकों A और B को गुणा करता है और गुणनफल लौटाता है।\n  ;; इनपुट: दो धनात्मक पूर्णांक 'a' और 'b', जहाँ 1 <= a, b <= 50000।\n  ;; आउटपुट: 'a' और 'b' का गुणनफल।\n  ;; उदाहरण:\n  ;; >>> (multiply-a-b 3 4)\n  ;; 12\n  ;; >>> (multiply-a-b 36 18)\n  ;; 648",
      "hu": "(defun multiply-a-b (a b)\n  ;; Két pozitív egész számot, A-t és B-t szoroz meg, és visszaadja a szorzatot.\n  ;; Bemenet: Két pozitív egész szám 'a' és 'b', ahol 1 <= a, b <= 50000.\n  ;; Kimenet: Az 'a' és 'b' szorzata.\n  ;; Példa:\n  ;; >>> (multiply-a-b 3 4)\n  ;; 12\n  ;; >>> (multiply-a-b 36 18)\n  ;; 648"
    },
    "prompt_bertscore": {
      "sq": "0.999999801369619",
      "hy": "0.9849565294619417",
      "bn": "0.9781864115547486",
      "bg": "0.999999801369619",
      "zh": "0.9910135643012196",
      "fr": "0.999999801369619",
      "de": "0.999999801369619",
      "ha": "0.9635576812522911",
      "hi": "0.996202385744994",
      "hu": "0.98853386262438"
    },
    "canonical_solution": "  (* a b))",
    "instruction": {
      "en": "Write a Common Lisp function `(defun multiply-a-b (a b)` to solve the following problem: Multiplies two positive integers A and B and returns the product.\n Input: Two positive integers 'a' and 'b', where 1 <= a, b <= 50000.\n Output: The product of 'a' and 'b'.\n Example:\n >>> (multiply-a-b 3 4)\n 12\n >>> (multiply-a-b 36 18)\n 648",
      "sq": "Shkruani një funksion Common Lisp `(defun multiply-a-b (a b)` për të zgjidhur problemin e mëposhtëm: Shumzon dy numra të plotë pozitivë A dhe B dhe kthen produktin.\n Hyrja: Dy numra të plotë pozitivë 'a' dhe 'b', ku 1 <= a, b <= 50000.\n Dalja: Produkti i 'a' dhe 'b'.\n Shembull:\n >>> (multiply-a-b 3 4)\n 12\n >>> (multiply-a-b 36 18)\n 648",
      "hy": "Գրեք Common Lisp ֆունկցիա `(defun multiply-a-b (a b)` հետևյալ խնդիրը լուծելու համար: Բազմապատկում է երկու դրական ամբողջ թիվ A և B և վերադարձնում արդյունքը։\n Մուտք: Երկու դրական ամբողջ թիվ 'a' և 'b', որտեղ 1 <= a, b <= 50000։\n Ելք: 'a' և 'b' թվերի արտադրյալը։\n Օրինակ:\n >>> (multiply-a-b 3 4)\n 12\n >>> (multiply-a-b 36 18)\n 648",
      "bn": "একটি Common Lisp ফাংশন `(defun multiply-a-b (a b)` লিখুন নিম্নলিখিত সমস্যার সমাধানের জন্য: দুটি ধনাত্মক পূর্ণসংখ্যা A এবং B গুণ করে গুণফল প্রদান করে।\n ইনপুট: দুটি ধনাত্মক পূর্ণসংখ্যা 'a' এবং 'b', যেখানে 1 <= a, b <= 50000।\n আউটপুট: 'a' এবং 'b' এর গুণফল।\n উদাহরণ:\n >>> (multiply-a-b 3 4)\n 12\n >>> (multiply-a-b 36 18)\n 648",
      "bg": "Напишете функция на Common Lisp `(defun multiply-a-b (a b)` за решаване на следния проблем: Умножава две положителни цели числа A и B и връща произведението.\n Вход: Две положителни цели числа 'a' и 'b', където 1 <= a, b <= 50000.\n Изход: Произведението на 'a' и 'b'.\n Пример:\n >>> (multiply-a-b 3 4)\n 12\n >>> (multiply-a-b 36 18)\n 648",
      "zh": "编写一个 Common Lisp 函数 `(defun multiply-a-b (a b)` 来解决以下问题：将两个正整数 A 和 B 相乘并返回乘积。\n 输入：两个正整数 'a' 和 'b'，其中 1 <= a, b <= 50000。\n 输出：'a' 和 'b' 的乘积。\n 示例:\n >>> (multiply-a-b 3 4)\n 12\n >>> (multiply-a-b 36 18)\n 648",
      "fr": "Écrire une fonction Common Lisp `(defun multiply-a-b (a b)` pour résoudre le problème suivant : Multiplie deux entiers positifs A et B et retourne le produit.\n Entrée : Deux entiers positifs 'a' et 'b', où 1 <= a, b <= 50000.\n Sortie : Le produit de 'a' et 'b'.\n Exemple:\n >>> (multiply-a-b 3 4)\n 12\n >>> (multiply-a-b 36 18)\n 648",
      "de": "Schreiben Sie eine Common Lisp-Funktion `(defun multiply-a-b (a b)` um das folgende Problem zu lösen: Multipliziert zwei positive ganze Zahlen A und B und gibt das Produkt zurück.\n Eingabe: Zwei positive ganze Zahlen 'a' und 'b', wobei 1 <= a, b <= 50000.\n Ausgabe: Das Produkt von 'a' und 'b'.\n Beispiel:\n >>> (multiply-a-b 3 4)\n 12\n >>> (multiply-a-b 36 18)\n 648",
      "ha": "Rubuta aikin Common Lisp `(defun multiply-a-b (a b)` don warware matsalar mai zuwa: Ninka lambobi guda biyu masu kyau A da B kuma ya dawo da samfurin.\n Shigarwa: Lambobi guda biyu masu kyau 'a' da 'b', inda 1 <= a, b <= 50000.\n Fitarwa: Samfurin 'a' da 'b'.\n Misali:\n >>> (multiply-a-b 3 4)\n 12\n >>> (multiply-a-b 36 18)\n 648",
      "hi": "एक Common Lisp फ़ंक्शन `(defun multiply-a-b (a b)` लिखें ताकि निम्नलिखित समस्या का समाधान किया जा सके: दो धनात्मक पूर्णांक A और B को गुणा करता है और गुणनफल लौटाता है।\n इनपुट: दो धनात्मक पूर्णांक 'a' और 'b', जहाँ 1 <= a, b <= 50000।\n आउटपुट: 'a' और 'b' का गुणनफल।\n उदाहरण:\n >>> (multiply-a-b 3 4)\n 12\n >>> (multiply-a-b 36 18)\n 648",
      "hu": "Írj egy Common Lisp függvényt `(defun multiply-a-b (a b)` a következő probléma megoldására: Két pozitív egész szám A és B összeszorzása és a szorzat visszaadása.\n Bemenet: Két pozitív egész szám 'a' és 'b', ahol 1 <= a, b <= 50000.\n Kimenet: 'a' és 'b' szorzata.\n Példa:\n >>> (multiply-a-b 3 4)\n 12\n >>> (multiply-a-b 36 18)\n 648"
    },
    "instruction_bertscore": {
      "sq": "1",
      "hy": "0.9938231910409581",
      "bn": "0.9718707599593632",
      "bg": "0.9938635130083082",
      "zh": "0.9928336144826423",
      "fr": "0.9928336144826423",
      "de": "1",
      "ha": "0.9817361350942231",
      "hi": "1",
      "hu": "0.990742831091869"
    },
    "level": "easy",
    "test": "(defun check-multiply-a-b ()\n  (assert (= (multiply-a-b 3 4) 12))\n  (assert (= (multiply-a-b 36 18) 648))\n  (assert (= (multiply-a-b 1 50000) 50000))\n  (assert (= (multiply-a-b 50000 50000) 2500000000))\n  (assert (= (multiply-a-b 123 456) 56088)))\n\n(check-multiply-a-b)",
    "entry_point": "multiply-a-b",
    "signature": "(defun multiply-a-b (a b)",
    "docstring": {
      "en": "Multiplies two positive integers A and B and returns the product.\n Input: Two positive integers 'a' and 'b', where 1 <= a, b <= 50000.\n Output: The product of 'a' and 'b'.\n Example:\n >>> (multiply-a-b 3 4)\n 12\n >>> (multiply-a-b 36 18)\n 648",
      "sq": "Shumëzon dy numra të plotë pozitivë A dhe B dhe kthen produktin. \nHyrja: Dy numra të plotë pozitivë 'a' dhe 'b', ku 1 <= a, b <= 50000.  \nDalja: Produkti i 'a' dhe 'b'.  \nShembull:  \n>>> (multiply-a-b 3 4)  \n12  \n>>> (multiply-a-b 36 18)  \n648  ",
      "hy": "Բազմապատկում է երկու դրական ամբողջ թիվ A-ն և B-ն և վերադարձնում է արդյունքը։\nՄուտք: Երկու դրական ամբողջ թվեր 'a' և 'b', որտեղ 1 <= a, b <= 50000։\nԵլք: 'a' և 'b' թվերի արտադրյալը։\nՕրինակ:\n>>> (multiply-a-b 3 4)\n12\n>>> (multiply-a-b 36 18)\n648",
      "bn": "দুটি ধনাত্মক পূর্ণসংখ্যা A এবং B গুণ করে গুণফল প্রদান করে।\nইনপুট: দুটি ধনাত্মক পূর্ণসংখ্যা 'a' এবং 'b', যেখানে 1 <= a, b <= 50000।\nআউটপুট: 'a' এবং 'b' এর গুণফল।\nউদাহরণ:\n>>> (multiply-a-b 3 4)\n12\n>>> (multiply-a-b 36 18)\n648",
      "bg": "Умножава две положителни цели числа A и B и връща произведението.\nВход: Две положителни цели числа 'a' и 'b', където 1 <= a, b <= 50000.\nИзход: Произведението на 'a' и 'b'.\nПример:\n>>> (multiply-a-b 3 4)\n12\n>>> (multiply-a-b 36 18)\n648",
      "zh": "将两个正整数 A 和 B 相乘并返回乘积。\n输入：两个正整数 'a' 和 'b'，其中 1 <= a, b <= 50000。\n输出：'a' 和 'b' 的乘积。\n示例：\n>>> (multiply-a-b 3 4)\n12\n>>> (multiply-a-b 36 18)\n648",
      "fr": "Multiplie deux entiers positifs A et B et renvoie le produit.\nEntrée : Deux entiers positifs 'a' et 'b', où 1 <= a, b <= 50000.\nSortie : Le produit de 'a' et 'b'.\nExemple :\n>>> (multiply-a-b 3 4)\n12\n>>> (multiply-a-b 36 18)\n648",
      "de": "Multipliziert zwei positive ganze Zahlen A und B und gibt das Produkt zurück.\nEingabe: Zwei positive ganze Zahlen 'a' und 'b', wobei 1 <= a, b <= 50000.\nAusgabe: Das Produkt von 'a' und 'b'.\nBeispiel:\n>>> (multiply-a-b 3 4)\n12\n>>> (multiply-a-b 36 18)\n648",
      "ha": "Ninka lambobi guda biyu masu kyau A da B kuma ya dawo da sakamakon.\n Shigarwa: Lambobi guda biyu masu kyau 'a' da 'b', inda 1 <= a, b <= 50000.\n Fitarwa: Samfurin 'a' da 'b'.\n Misali:\n >>> (multiply-a-b 3 4)\n 12\n >>> (multiply-a-b 36 18)\n 648",
      "hi": "दो सकारात्मक पूर्णांकों A और B को गुणा करता है और गुणनफल लौटाता है।\nइनपुट: दो सकारात्मक पूर्णांक 'a' और 'b', जहाँ 1 <= a, b <= 50000।  \nआउटपुट: 'a' और 'b' का गुणनफल।  \nउदाहरण:  \n>>> (multiply-a-b 3 4)  \n12  \n>>> (multiply-a-b 36 18)  \n648  ",
      "hu": "Két pozitív egész számot, A-t és B-t szoroz össze, és visszaadja a szorzatot.\n Bemenet: Két pozitív egész szám 'a' és 'b', ahol 1 <= a, b <= 50000.\n Kimenet: 'a' és 'b' szorzata.\n Példa:\n >>> (multiply-a-b 3 4)\n 12\n >>> (multiply-a-b 36 18)\n 648"
    },
    "docstring_bertscore": {
      "sq": "1",
      "hy": "0.9907877215579829",
      "bn": "0.967764871352991",
      "bg": "1",
      "zh": "0.9874088201461985",
      "fr": "0.9874088201461985",
      "de": "1",
      "ha": "0.9863689901014808",
      "hi": "1",
      "hu": "0.9604246842522278"
    }
  },
  {
    "task_id": "Common Lisp/48",
    "prompt": {
      "en": "(defun power-of-two (n)\n  ;; Calculates 2 raised to the power of n, where n is a non-negative integer.\n  ;; Input: A non-negative integer 'n' (0 <= n < 31).\n  ;; Output: An integer representing 2^n.\n  ;; Example:\n  ;; >>> (power-of-two 3)\n  ;; 8\n  ;; >>> (power-of-two 10)\n  ;; 1024",
      "sq": "(defun power-of-two (n)\n  ;; Llogarit 2 të ngritur në fuqinë e n, ku n është një numër i plotë jo-negativ.\n  ;; Hyrja: Një numër i plotë jo-negativ 'n' (0 <= n < 31).\n  ;; Dalja: Një numër i plotë që përfaqëson 2^n.\n  ;; Shembull:\n  ;; >>> (power-of-two 3)\n  ;; 8\n  ;; >>> (power-of-two 10)\n  ;; 1024",
      "hy": "(defun power-of-two (n)\n  ;; Հաշվում է 2-ի աստիճանը n-ով, որտեղ n-ը ոչ բացասական ամբողջ թիվ է։\n  ;; Մուտք: Ոչ բացասական ամբողջ թիվ 'n' (0 <= n < 31)։\n  ;; Ելք: Ամբողջ թիվ, որը ներկայացնում է 2^n։\n  ;; Օրինակ:\n  ;; >>> (power-of-two 3)\n  ;; 8\n  ;; >>> (power-of-two 10)\n  ;; 1024",
      "bn": "(defun power-of-two (n)\n  ;; n এর ঘাত হিসাবে 2 এর মান গণনা করে, যেখানে n একটি অ-ঋণাত্মক পূর্ণসংখ্যা।\n  ;; ইনপুট: একটি অ-ঋণাত্মক পূর্ণসংখ্যা 'n' (0 <= n < 31)।\n  ;; আউটপুট: একটি পূর্ণসংখ্যা যা 2^n উপস্থাপন করে।\n  ;; উদাহরণ:\n  ;; >>> (power-of-two 3)\n  ;; 8\n  ;; >>> (power-of-two 10)\n  ;; 1024",
      "bg": "(defun power-of-two (n)\n  ;; Изчислява 2 на степен n, където n е неотрицателно цяло число.\n  ;; Вход: Неотрицателно цяло число 'n' (0 <= n < 31).\n  ;; Изход: Цяло число, представляващо 2^n.\n  ;; Пример:\n  ;; >>> (power-of-two 3)\n  ;; 8\n  ;; >>> (power-of-two 10)\n  ;; 1024",
      "zh": "(defun power-of-two (n)\n  ;; 计算2的n次方，其中n是一个非负整数。\n  ;; 输入: 一个非负整数 'n' (0 <= n < 31)。\n  ;; 输出: 一个整数，表示2^n。\n  ;; 示例:\n  ;; >>> (power-of-two 3)\n  ;; 8\n  ;; >>> (power-of-two 10)\n  ;; 1024",
      "fr": "(defun power-of-two (n)\n  ;; Calcule 2 élevé à la puissance de n, où n est un entier non négatif.\n  ;; Entrée : Un entier non négatif 'n' (0 <= n < 31).\n  ;; Sortie : Un entier représentant 2^n.\n  ;; Exemple :\n  ;; >>> (power-of-two 3)\n  ;; 8\n  ;; >>> (power-of-two 10)\n  ;; 1024",
      "de": "(defun power-of-two (n)\n  ;; Berechnet 2 hoch n, wobei n eine nicht-negative ganze Zahl ist.\n  ;; Eingabe: Eine nicht-negative ganze Zahl 'n' (0 <= n < 31).\n  ;; Ausgabe: Eine ganze Zahl, die 2^n darstellt.\n  ;; Beispiel:\n  ;; >>> (power-of-two 3)\n  ;; 8\n  ;; >>> (power-of-two 10)\n  ;; 1024",
      "ha": "(defun power-of-two (n)\n  ;; Lissafa 2 da aka ɗaga zuwa ƙarfin n, inda n yake zama cikakken lamba mara kyau.\n  ;; Shigarwa: Cikakken lamba mara kyau 'n' (0 <= n < 31).\n  ;; Fitarwa: Cikakken lamba da ke wakiltar 2^n.\n  ;; Misali:\n  ;; >>> (power-of-two 3)\n  ;; 8\n  ;; >>> (power-of-two 10)\n  ;; 1024",
      "hi": "(defun power-of-two (n)\n  ;; n की घात में 2 की गणना करता है, जहाँ n एक गैर-ऋणात्मक पूर्णांक है।\n  ;; इनपुट: एक गैर-ऋणात्मक पूर्णांक 'n' (0 <= n < 31)।\n  ;; आउटपुट: 2^n का प्रतिनिधित्व करने वाला एक पूर्णांक।\n  ;; उदाहरण:\n  ;; >>> (power-of-two 3)\n  ;; 8\n  ;; >>> (power-of-two 10)\n  ;; 1024",
      "hu": "(defun power-of-two (n)\n  ;; Kiszámítja a 2-t az n hatványára emelve, ahol n egy nem negatív egész szám.\n  ;; Bemenet: Egy nem negatív egész szám 'n' (0 <= n < 31).\n  ;; Kimenet: Egy egész szám, amely 2^n-t képvisel.\n  ;; Példa:\n  ;; >>> (power-of-two 3)\n  ;; 8\n  ;; >>> (power-of-two 10)\n  ;; 1024"
    },
    "prompt_bertscore": {
      "sq": "1",
      "hy": "0.9733638645336026",
      "bn": "0.9817838063856714",
      "bg": "0.9766631151625921",
      "zh": "0.9866230383588244",
      "fr": "1",
      "de": "0.9883902528588918",
      "ha": "0.9835160619386767",
      "hi": "1",
      "hu": "1"
    },
    "canonical_solution": "  (expt 2 n))",
    "instruction": {
      "en": "Write a Common Lisp function `(defun power-of-two (n)` to solve the following problem: Calculates 2 raised to the power of n, where n is a non-negative integer.\n Input: A non-negative integer 'n' (0 <= n < 31).\n Output: An integer representing 2^n.\n Example:\n >>> (power-of-two 3)\n 8\n >>> (power-of-two 10)\n 1024",
      "sq": "Shkruani një funksion në Common Lisp `(defun power-of-two (n)` për të zgjidhur problemin e mëposhtëm: Llogarit 2 ngritur në fuqinë e n, ku n është një numër i plotë jo-negativ.\n Hyrja: Një numër i plotë jo-negativ 'n' (0 <= n < 31).\n Dalja: Një numër i plotë që përfaqëson 2^n.\n Shembull:\n >>> (power-of-two 3)\n 8\n >>> (power-of-two 10)\n 1024",
      "hy": "Գրեք Common Lisp ֆունկցիա `(defun power-of-two (n)` հետևյալ խնդիրը լուծելու համար: Հաշվում է 2-ի աստիճանը n-ի, որտեղ n-ը ոչ բացասական ամբողջ թիվ է:\n Մուտք: Ոչ բացասական ամբողջ թիվ 'n' (0 <= n < 31):\n Ելք: Ամբողջ թիվ, որը ներկայացնում է 2^n:\n Օրինակ:\n >>> (power-of-two 3)\n 8\n >>> (power-of-two 10)\n 1024",
      "bn": "একটি Common Lisp ফাংশন `(defun power-of-two (n)` লিখুন নিম্নলিখিত সমস্যার সমাধানের জন্য: 2 এর n তম ঘাত নির্ণয় করে, যেখানে n একটি অ-ঋণাত্মক পূর্ণসংখ্যা।\n ইনপুট: একটি অ-ঋণাত্মক পূর্ণসংখ্যা 'n' (0 <= n < 31)।\n আউটপুট: একটি পূর্ণসংখ্যা যা 2^n উপস্থাপন করে।\n উদাহরণ:\n >>> (power-of-two 3)\n 8\n >>> (power-of-two 10)\n 1024",
      "bg": "Напишете функция на Common Lisp `(defun power-of-two (n)` за решаване на следния проблем: Изчислява 2 на степен n, където n е неотрицателно цяло число.\n Вход: Неотрицателно цяло число 'n' (0 <= n < 31).\n Изход: Цяло число, представляващо 2^n.\n Пример:\n >>> (power-of-two 3)\n 8\n >>> (power-of-two 10)\n 1024",
      "zh": "编写一个 Common Lisp 函数 `(defun power-of-two (n)` 来解决以下问题：计算 2 的 n 次方，其中 n 是一个非负整数。\n 输入：一个非负整数 'n' (0 <= n < 31)。\n 输出：一个整数，表示 2^n。\n 示例:\n >>> (power-of-two 3)\n 8\n >>> (power-of-two 10)\n 1024",
      "fr": "Écrire une fonction Common Lisp `(defun power-of-two (n)` pour résoudre le problème suivant : Calcule 2 élevé à la puissance de n, où n est un entier non négatif.\n Entrée : Un entier non négatif 'n' (0 <= n < 31).\n Sortie : Un entier représentant 2^n.\n Exemple :\n >>> (power-of-two 3)\n 8\n >>> (power-of-two 10)\n 1024",
      "de": "Schreiben Sie eine Common Lisp-Funktion `(defun power-of-two (n)` um das folgende Problem zu lösen: Berechnet 2 hoch n, wobei n eine nicht-negative ganze Zahl ist.\n Eingabe: Eine nicht-negative ganze Zahl 'n' (0 <= n < 31).\n Ausgabe: Eine ganze Zahl, die 2^n darstellt.\n Beispiel:\n >>> (power-of-two 3)\n 8\n >>> (power-of-two 10)\n 1024",
      "ha": "Rubuta aikin Common Lisp `(defun power-of-two (n)` don warware matsalar mai zuwa: Lissafi 2 da aka ɗaga zuwa ikon n, inda n ba shi da ƙima mara kyau.\n Shigarwa: Lamba mara kyau 'n' (0 <= n < 31).\n Fitarwa: Lamba mai wakiltar 2^n.\n Misali:\n >>> (power-of-two 3)\n 8\n >>> (power-of-two 10)\n 1024",
      "hi": "एक Common Lisp फ़ंक्शन `(defun power-of-two (n)` लिखें ताकि निम्नलिखित समस्या का समाधान किया जा सके: n की शक्ति पर 2 की गणना करता है, जहाँ n एक गैर-ऋणात्मक पूर्णांक है।\n इनपुट: एक गैर-ऋणात्मक पूर्णांक 'n' (0 <= n < 31)।\n आउटपुट: एक पूर्णांक जो 2^n का प्रतिनिधित्व करता है।\n उदाहरण:\n >>> (power-of-two 3)\n 8\n >>> (power-of-two 10)\n 1024",
      "hu": "Írj egy Common Lisp függvényt `(defun power-of-two (n)` a következő probléma megoldására: Kiszámítja a 2 n-edik hatványát, ahol n egy nem negatív egész szám.\n Bemenet: Egy nem negatív egész szám 'n' (0 <= n < 31).\n Kimenet: Egy egész szám, amely 2^n-et reprezentál.\n Példa:\n >>> (power-of-two 3)\n 8\n >>> (power-of-two 10)\n 1024"
    },
    "instruction_bertscore": {
      "sq": "0.9932376286776672",
      "hy": "0.9519276738123174",
      "bn": "0.9691352223517508",
      "bg": "0.9851728379468887",
      "zh": "0.9749731678807472",
      "fr": "0.9982774773356654",
      "de": "0.9855228246782721",
      "ha": "0.9982774773356654",
      "hi": "0.9798350437173382",
      "hu": "0.9787314533203083"
    },
    "level": "easy",
    "test": "(defun check-power-of-two ()\n  (assert (= (power-of-two 3) 8))\n  (assert (= (power-of-two 10) 1024))\n  (assert (= (power-of-two 0) 1))\n  (assert (= (power-of-two 5) 32))\n  (assert (= (power-of-two 15) 32768)))\n\n(check-power-of-two)",
    "entry_point": "power-of-two",
    "signature": "(defun power-of-two (n)",
    "docstring": {
      "en": "Calculates 2 raised to the power of n, where n is a non-negative integer.\n Input: A non-negative integer 'n' (0 <= n < 31).\n Output: An integer representing 2^n.\n Example:\n >>> (power-of-two 3)\n 8\n >>> (power-of-two 10)\n 1024",
      "sq": "Llogarit 2 të ngritur në fuqinë e n, ku n është një numër i plotë jo-negativ.\nInput: Një numër i plotë jo-negativ 'n' (0 <= n < 31).\nOutput: Një numër i plotë që përfaqëson 2^n.\nShembull:\n>>> (power-of-two 3)\n8\n>>> (power-of-two 10)\n1024",
      "hy": "Հաշվարկում է 2-ը n աստիճանի, որտեղ n-ը ոչ բացասական ամբողջ թիվ է։\nՄուտք: Ոչ բացասական ամբողջ թիվ 'n' (0 <= n < 31)։\nԵլք: Ամբողջ թիվ, որը ներկայացնում է 2^n։\nՕրինակ:\n>>> (power-of-two 3)\n8\n>>> (power-of-two 10)\n1024",
      "bn": "2 কে n এর ঘাত হিসাবে গণনা করে, যেখানে n একটি অ-ঋণাত্মক পূর্ণসংখ্যা।\nInput: একটি অ-ঋণাত্মক পূর্ণসংখ্যা 'n' (0 <= n < 31)।\nOutput: একটি পূর্ণসংখ্যা যা 2^n উপস্থাপন করে।\nউদাহরণ:\n>>> (power-of-two 3)\n8\n>>> (power-of-two 10)\n1024",
      "bg": "Изчислява 2 на степен n, където n е неотрицателно цяло число.\nВход: Неотрицателно цяло число 'n' (0 <= n < 31).\nИзход: Цяло число, представляващо 2^n.\nПример:\n>>> (power-of-two 3)\n8\n>>> (power-of-two 10)\n1024",
      "zh": "计算2的n次幂，其中n是非负整数。\n输入：一个非负整数'n' (0 <= n < 31)。\n输出：一个整数，表示2^n。\n示例：\n>>> (power-of-two 3)\n8\n>>> (power-of-two 10)\n1024",
      "fr": " Calcule 2 élevé à la puissance de n, où n est un entier non négatif.\n Entrée : Un entier non négatif 'n' (0 <= n < 31).\n Sortie : Un entier représentant 2^n.\n Exemple :\n >>> (power-of-two 3)\n 8\n >>> (power-of-two 10)\n 1024",
      "de": "Berechnet 2 hoch n, wobei n eine nicht-negative ganze Zahl ist.\nEingabe: Eine nicht-negative ganze Zahl 'n' (0 <= n < 31).\nAusgabe: Eine ganze Zahl, die 2^n darstellt.\nBeispiel:\n>>> (power-of-two 3)\n8\n>>> (power-of-two 10)\n1024",
      "ha": "Yana lissafin 2 da aka ɗaga zuwa ikon n, inda n ba shi da ƙima mara kyau.\n Shigarwa: Lamba mai kyau mara kyau 'n' (0 <= n < 31).\n Fitarwa: Lamba mai wakiltar 2^n.\n Misali:\n >>> (power-of-two 3)\n 8\n >>> (power-of-two 10)\n 1024",
      "hi": "गणना करता है 2 को n की शक्ति तक, जहाँ n एक गैर-ऋणात्मक पूर्णांक है।\n इनपुट: एक गैर-ऋणात्मक पूर्णांक 'n' (0 <= n < 31)।\n आउटपुट: एक पूर्णांक जो 2^n का प्रतिनिधित्व करता है।\n उदाहरण:\n >>> (power-of-two 3)\n 8\n >>> (power-of-two 10)\n 1024",
      "hu": "Számítja a 2-t az n-edik hatványra emelve, ahol n egy nem negatív egész szám.\n Bemenet: Egy nem negatív egész szám 'n' (0 <= n < 31).\n Kimenet: Egy egész szám, amely a 2^n-et képviseli.\n Példa:\n >>> (power-of-two 3)\n 8\n >>> (power-of-two 10)\n 1024"
    },
    "docstring_bertscore": {
      "sq": "0.9972056677996012",
      "hy": "0.9738747418736242",
      "bn": "0.9742426053393008",
      "bg": "0.9738747418736242",
      "zh": "0.9972056677996012",
      "fr": "0.9972056677996012",
      "de": "0.9873681009180862",
      "ha": "1",
      "hi": "0.9873681009180862",
      "hu": "1"
    }
  },
  {
    "task_id": "Common Lisp/49",
    "prompt": {
      "en": "(defun judge-sign (n)\n  ;; Determines if an integer N is positive, negative, or zero.\n  ;; Input: An integer 'N' (-10^9 <= N <= 10^9).\n  ;; Output: A string \"positive\" if N > 0, \"zero\" if N = 0, or \"negative\" if N < 0.\n  ;; Example:\n  ;; >>> (judge-sign 95)\n  ;; \"positive\"\n  ;; >>> (judge-sign 0)\n  ;; \"zero\"\n  ;; >>> (judge-sign -3)\n  ;; \"negative\"",
      "sq": "(defun judge-sign (n)\n  ;; Përcakton nëse një numër i plotë N është pozitiv, negativ, apo zero.\n  ;; Hyrja: Një numër i plotë 'N' (-10^9 <= N <= 10^9).\n  ;; Dalja: Një varg \"positive\" nëse N > 0, \"zero\" nëse N = 0, ose \"negative\" nëse N < 0.\n  ;; Shembull:\n  ;; >>> (judge-sign 95)\n  ;; \"positive\"\n  ;; >>> (judge-sign 0)\n  ;; \"zero\"\n  ;; >>> (judge-sign -3)\n  ;; \"negative\"",
      "hy": "(defun judge-sign (n)\n  ;; Որոշում է, արդյոք ամբողջ թիվ N-ը դրական է, բացասական, թե զրո:\n  ;; Մուտք: Ամբողջ թիվ 'N' (-10^9 <= N <= 10^9):\n  ;; Ելք: Տող \"positive\", եթե N > 0, \"zero\", եթե N = 0, կամ \"negative\", եթե N < 0:\n  ;; Օրինակ:\n  ;; >>> (judge-sign 95)\n  ;; \"positive\"\n  ;; >>> (judge-sign 0)\n  ;; \"zero\"\n  ;; >>> (judge-sign -3)\n  ;; \"negative\"",
      "bn": "(defun judge-sign (n)\n  ;; একটি পূর্ণসংখ্যা N ধনাত্মক, ঋণাত্মক, বা শূন্য কিনা তা নির্ধারণ করে।\n  ;; ইনপুট: একটি পূর্ণসংখ্যা 'N' (-10^9 <= N <= 10^9)।\n  ;; আউটপুট: একটি স্ট্রিং \"positive\" যদি N > 0, \"zero\" যদি N = 0, অথবা \"negative\" যদি N < 0।\n  ;; উদাহরণ:\n  ;; >>> (judge-sign 95)\n  ;; \"positive\"\n  ;; >>> (judge-sign 0)\n  ;; \"zero\"\n  ;; >>> (judge-sign -3)\n  ;; \"negative\"",
      "bg": "(defun judge-sign (n)\n  ;; Определя дали цяло число N е положително, отрицателно или нула.\n  ;; Вход: Цяло число 'N' (-10^9 <= N <= 10^9).\n  ;; Изход: Низ \"positive\" ако N > 0, \"zero\" ако N = 0, или \"negative\" ако N < 0.\n  ;; Пример:\n  ;; >>> (judge-sign 95)\n  ;; \"positive\"\n  ;; >>> (judge-sign 0)\n  ;; \"zero\"\n  ;; >>> (judge-sign -3)\n  ;; \"negative\"",
      "zh": "(defun judge-sign (n)\n  ;; 确定整数 N 是正数、负数还是零。\n  ;; 输入: 一个整数 'N' (-10^9 <= N <= 10^9)。\n  ;; 输出: 如果 N > 0，返回字符串 \"positive\"；如果 N = 0，返回 \"zero\"；如果 N < 0，返回 \"negative\"。\n  ;; 示例:\n  ;; >>> (judge-sign 95)\n  ;; \"positive\"\n  ;; >>> (judge-sign 0)\n  ;; \"zero\"\n  ;; >>> (judge-sign -3)\n  ;; \"negative\"",
      "fr": "(defun judge-sign (n)\n  ;; Détermine si un entier N est positif, négatif ou zéro.\n  ;; Entrée : Un entier 'N' (-10^9 <= N <= 10^9).\n  ;; Sortie : Une chaîne \"positive\" si N > 0, \"zero\" si N = 0, ou \"negative\" si N < 0.\n  ;; Exemple :\n  ;; >>> (judge-sign 95)\n  ;; \"positive\"\n  ;; >>> (judge-sign 0)\n  ;; \"zero\"\n  ;; >>> (judge-sign -3)\n  ;; \"negative\"",
      "de": "(defun judge-sign (n)\n  ;; Bestimmt, ob eine ganze Zahl N positiv, negativ oder null ist.\n  ;; Eingabe: Eine ganze Zahl 'N' (-10^9 <= N <= 10^9).\n  ;; Ausgabe: Ein String \"positive\" wenn N > 0, \"zero\" wenn N = 0, oder \"negative\" wenn N < 0.\n  ;; Beispiel:\n  ;; >>> (judge-sign 95)\n  ;; \"positive\"\n  ;; >>> (judge-sign 0)\n  ;; \"zero\"\n  ;; >>> (judge-sign -3)\n  ;; \"negative\"",
      "ha": "(defun judge-sign (n)\n  ;; Yana tantance idan lamba N tana da alamar mai kyau, mara kyau, ko sifili.\n  ;; Shigarwa: Lamba 'N' (-10^9 <= N <= 10^9).\n  ;; Fitarwa: Kirtani \"positive\" idan N > 0, \"zero\" idan N = 0, ko \"negative\" idan N < 0.\n  ;; Misali:\n  ;; >>> (judge-sign 95)\n  ;; \"positive\"\n  ;; >>> (judge-sign 0)\n  ;; \"zero\"\n  ;; >>> (judge-sign -3)\n  ;; \"negative\"",
      "hi": "(defun judge-sign (n)\n  ;; यह निर्धारित करता है कि एक पूर्णांक N धनात्मक, ऋणात्मक, या शून्य है।\n  ;; इनपुट: एक पूर्णांक 'N' (-10^9 <= N <= 10^9)।\n  ;; आउटपुट: एक स्ट्रिंग \"positive\" यदि N > 0, \"zero\" यदि N = 0, या \"negative\" यदि N < 0।\n  ;; उदाहरण:\n  ;; >>> (judge-sign 95)\n  ;; \"positive\"\n  ;; >>> (judge-sign 0)\n  ;; \"zero\"\n  ;; >>> (judge-sign -3)\n  ;; \"negative\"",
      "hu": "(defun judge-sign (n)\n  ;; Meghatározza, hogy egy egész szám N pozitív, negatív vagy nulla.\n  ;; Bemenet: Egy egész szám 'N' (-10^9 <= N <= 10^9).\n  ;; Kimenet: Egy \"positive\" sztring, ha N > 0, \"zero\" ha N = 0, vagy \"negative\" ha N < 0.\n  ;; Példa:\n  ;; >>> (judge-sign 95)\n  ;; \"positive\"\n  ;; >>> (judge-sign 0)\n  ;; \"zero\"\n  ;; >>> (judge-sign -3)\n  ;; \"negative\""
    },
    "prompt_bertscore": {
      "sq": "0.9994108622898505",
      "hy": "0.9737952897212103",
      "bn": "0.9994108622898505",
      "bg": "0.9891504113271123",
      "zh": "0.9453180492530004",
      "fr": "1",
      "de": "0.9994108622898505",
      "ha": "0.9778217261751685",
      "hi": "0.9994108622898505",
      "hu": "0.9947104729530409"
    },
    "canonical_solution": "  (cond ((> n 0) \"positive\")\n        ((< n 0) \"negative\")\n        (t \"zero\")))",
    "instruction": {
      "en": "Write a Common Lisp function `(defun judge-sign (n)` to solve the following problem: Determines if an integer N is positive, negative, or zero.\n Input: An integer 'N' (-10^9 <= N <= 10^9).\n Output: A string \"positive\" if N > 0, \"zero\" if N = 0, or \"negative\" if N < 0.\n Example:\n >>> (judge-sign 95)\n \"positive\"\n >>> (judge-sign 0)\n \"zero\"\n >>> (judge-sign -3)\n \"negative\"",
      "sq": "Shkruani një funksion Common Lisp `(defun judge-sign (n)` për të zgjidhur problemin e mëposhtëm: Përcakton nëse një numër i plotë N është pozitiv, negativ, apo zero.\n Hyrja: Një numër i plotë 'N' (-10^9 <= N <= 10^9).\n Dalja: Një varg \"positive\" nëse N > 0, \"zero\" nëse N = 0, ose \"negative\" nëse N < 0.\n Shembull:\n >>> (judge-sign 95)\n \"positive\"\n >>> (judge-sign 0)\n \"zero\"\n >>> (judge-sign -3)\n \"negative\"",
      "hy": "Գրեք Common Lisp ֆունկցիա `(defun judge-sign (n)` հետևյալ խնդիրը լուծելու համար: Որոշում է, արդյոք ամբողջ թիվ N-ը դրական է, բացասական, թե զրո:\n Մուտք: Ամբողջ թիվ 'N' (-10^9 <= N <= 10^9):\n Ելք: Տող \"positive\", եթե N > 0, \"zero\", եթե N = 0, կամ \"negative\", եթե N < 0:\n Օրինակ:\n >>> (judge-sign 95)\n \"positive\"\n >>> (judge-sign 0)\n \"zero\"\n >>> (judge-sign -3)\n \"negative\"",
      "bn": "একটি Common Lisp ফাংশন `(defun judge-sign (n)` লিখুন নিম্নলিখিত সমস্যার সমাধানের জন্য: একটি পূর্ণসংখ্যা N ধনাত্মক, ঋণাত্মক, বা শূন্য কিনা তা নির্ধারণ করে।\n ইনপুট: একটি পূর্ণসংখ্যা 'N' (-10^9 <= N <= 10^9)।\n আউটপুট: একটি স্ট্রিং \"positive\" যদি N > 0, \"zero\" যদি N = 0, অথবা \"negative\" যদি N < 0।\n উদাহরণ:\n >>> (judge-sign 95)\n \"positive\"\n >>> (judge-sign 0)\n \"zero\"\n >>> (judge-sign -3)\n \"negative\"",
      "bg": "Напишете функция на Common Lisp `(defun judge-sign (n)` за решаване на следния проблем: Определя дали цяло число N е положително, отрицателно или нула.  \n Вход: Цяло число 'N' (-10^9 <= N <= 10^9).  \n Изход: Низ \"positive\" ако N > 0, \"zero\" ако N = 0, или \"negative\" ако N < 0.  \n Пример:  \n >>> (judge-sign 95)  \n \"positive\"  \n >>> (judge-sign 0)  \n \"zero\"  \n >>> (judge-sign -3)  \n \"negative\"",
      "zh": "编写一个 Common Lisp 函数 `(defun judge-sign (n)` 来解决以下问题：判断一个整数 N 是正数、负数还是零。\n 输入：一个整数 'N' (-10^9 <= N <= 10^9)。\n 输出：如果 N > 0，返回字符串 \"positive\"；如果 N = 0，返回 \"zero\"；如果 N < 0，返回 \"negative\"。\n 示例:\n >>> (judge-sign 95)\n \"positive\"\n >>> (judge-sign 0)\n \"zero\"\n >>> (judge-sign -3)\n \"negative\"",
      "fr": "Écrire une fonction Common Lisp `(defun judge-sign (n)` pour résoudre le problème suivant : Détermine si un entier N est positif, négatif ou zéro.\n Entrée : Un entier 'N' (-10^9 <= N <= 10^9).\n Sortie : Une chaîne de caractères \"positive\" si N > 0, \"zero\" si N = 0, ou \"negative\" si N < 0.\n Exemple :\n >>> (judge-sign 95)\n \"positive\"\n >>> (judge-sign 0)\n \"zero\"\n >>> (judge-sign -3)\n \"negative\"",
      "de": "Schreiben Sie eine Common Lisp Funktion `(defun judge-sign (n)` um das folgende Problem zu lösen: Bestimmt, ob eine ganze Zahl N positiv, negativ oder null ist.\nEingabe: Eine ganze Zahl 'N' (-10^9 <= N <= 10^9).\nAusgabe: Ein String \"positive\", wenn N > 0, \"zero\", wenn N = 0, oder \"negative\", wenn N < 0.\nBeispiel:\n>>> (judge-sign 95)\n\"positive\"\n>>> (judge-sign 0)\n\"zero\"\n>>> (judge-sign -3)\n\"negative\"",
      "ha": "Rubuta aikin Common Lisp `(defun judge-sign (n)` don warware matsalar mai zuwa: Tabbatar idan lambar cikakke N tana da kyau, mara kyau, ko sifili.\n Shigarwa: Lambar cikakke 'N' (-10^9 <= N <= 10^9).\n Fitarwa: Jeren haruffa \"positive\" idan N > 0, \"zero\" idan N = 0, ko \"negative\" idan N < 0.\n Misali:\n >>> (judge-sign 95)\n \"positive\"\n >>> (judge-sign 0)\n \"zero\"\n >>> (judge-sign -3)\n \"negative\"",
      "hi": "एक Common Lisp फ़ंक्शन `(defun judge-sign (n)` लिखें ताकि निम्नलिखित समस्या का समाधान किया जा सके: यह निर्धारित करता है कि एक पूर्णांक N धनात्मक, ऋणात्मक, या शून्य है।\n इनपुट: एक पूर्णांक 'N' (-10^9 <= N <= 10^9)।\n आउटपुट: एक स्ट्रिंग \"positive\" यदि N > 0 है, \"zero\" यदि N = 0 है, या \"negative\" यदि N < 0 है।\n उदाहरण:\n >>> (judge-sign 95)\n \"positive\"\n >>> (judge-sign 0)\n \"zero\"\n >>> (judge-sign -3)\n \"negative\"",
      "hu": "Írj egy Common Lisp függvényt `(defun judge-sign (n)` a következő probléma megoldására: Meghatározza, hogy egy egész szám N pozitív, negatív vagy nulla.\n Bemenet: Egy egész szám 'N' (-10^9 <= N <= 10^9).\n Kimenet: Egy sztring \"positive\", ha N > 0, \"zero\", ha N = 0, vagy \"negative\", ha N < 0.\n Példa:\n >>> (judge-sign 95)\n \"positive\"\n >>> (judge-sign 0)\n \"zero\"\n >>> (judge-sign -3)\n \"negative\""
    },
    "instruction_bertscore": {
      "sq": "0.9994243691557609",
      "hy": "0.976030874659758",
      "bn": "0.9930513133802565",
      "bg": "0.9994243691557609",
      "zh": "0.946647283762886",
      "fr": "0.9935657660671369",
      "de": "0.9994243691557609",
      "ha": "0.9896352680872185",
      "hi": "0.9934338754941296",
      "hu": "0.9994243691557609"
    },
    "level": "easy",
    "test": "(defun check-judge-sign ()\n  (assert (string= (judge-sign 95) \"positive\"))\n  (assert (string= (judge-sign 0) \"zero\"))\n  (assert (string= (judge-sign -3) \"negative\"))\n  (assert (string= (judge-sign 1) \"positive\"))\n  (assert (string= (judge-sign -1000000) \"negative\")))\n\n(check-judge-sign)",
    "entry_point": "judge-sign",
    "signature": "(defun judge-sign (n)",
    "docstring": {
      "en": "Determines if an integer N is positive, negative, or zero.\n Input: An integer 'N' (-10^9 <= N <= 10^9).\n Output: A string \"positive\" if N > 0, \"zero\" if N = 0, or \"negative\" if N < 0.\n Example:\n >>> (judge-sign 95)\n \"positive\"\n >>> (judge-sign 0)\n \"zero\"\n >>> (judge-sign -3)\n \"negative\"",
      "sq": "Përcakton nëse një numër i plotë N është pozitiv, negativ, apo zero.\nInput: Një numër i plotë 'N' (-10^9 <= N <= 10^9).\nOutput: Një varg \"positive\" nëse N > 0, \"zero\" nëse N = 0, ose \"negative\" nëse N < 0.\nShembull:\n>>> (judge-sign 95)\n\"positive\"\n>>> (judge-sign 0)\n\"zero\"\n>>> (judge-sign -3)\n\"negative\"",
      "hy": "Սահմանում է, արդյոք ամբողջ թիվ N-ը դրական է, բացասական, թե զրո։  \nՄուտք: Ամբողջ թիվ 'N' (-10^9 <= N <= 10^9)։  \nԵլք: Տող \"positive\", եթե N > 0, \"zero\", եթե N = 0, կամ \"negative\", եթե N < 0։  \nՕրինակ:  \n>>> (judge-sign 95)  \n\"positive\"  \n>>> (judge-sign 0)  \n\"zero\"  \n>>> (judge-sign -3)  \n\"negative\"  ",
      "bn": "নির্ধারণ করে একটি পূর্ণসংখ্যা N ধনাত্মক, ঋণাত্মক, বা শূন্য কিনা।\nইনপুট: একটি পূর্ণসংখ্যা 'N' (-10^9 <= N <= 10^9)।\nআউটপুট: একটি স্ট্রিং \"positive\" যদি N > 0, \"zero\" যদি N = 0, অথবা \"negative\" যদি N < 0।\nউদাহরণ:\n>>> (judge-sign 95)\n\"positive\"\n>>> (judge-sign 0)\n\"zero\"\n>>> (judge-sign -3)\n\"negative\"",
      "bg": "Определя дали цяло число N е положително, отрицателно или нула.\nВход: Цяло число 'N' (-10^9 <= N <= 10^9).\nИзход: Низ \"positive\" ако N > 0, \"zero\" ако N = 0, или \"negative\" ако N < 0.\nПример:\n>>> (judge-sign 95)\n\"positive\"\n>>> (judge-sign 0)\n\"zero\"\n>>> (judge-sign -3)\n\"negative\"",
      "zh": "确定整数 N 是正数、负数还是零。  \n输入：一个整数 'N' (-10^9 <= N <= 10^9)。  \n输出：如果 N > 0，返回字符串 \"positive\"；如果 N = 0，返回 \"zero\"；如果 N < 0，返回 \"negative\"。  \n示例：  \n>>> (judge-sign 95)  \n\"positive\"  \n>>> (judge-sign 0)  \n\"zero\"  \n>>> (judge-sign -3)  \n\"negative\"  ",
      "fr": "Détermine si un entier N est positif, négatif ou zéro.\nEntrée : Un entier 'N' (-10^9 <= N <= 10^9).\nSortie : Une chaîne de caractères \"positive\" si N > 0, \"zero\" si N = 0, ou \"negative\" si N < 0.\nExemple :\n>>> (judge-sign 95)\n\"positive\"\n>>> (judge-sign 0)\n\"zero\"\n>>> (judge-sign -3)\n\"negative\"",
      "de": "Bestimmt, ob eine ganze Zahl N positiv, negativ oder null ist.  \nEingabe: Eine ganze Zahl 'N' (-10^9 <= N <= 10^9).  \nAusgabe: Ein String \"positive\", wenn N > 0, \"zero\", wenn N = 0, oder \"negative\", wenn N < 0.  \nBeispiel:  \n>>> (judge-sign 95)  \n\"positive\"  \n>>> (judge-sign 0)  \n\"zero\"  \n>>> (judge-sign -3)  \n\"negative\"  ",
      "ha": "Yana tantance ko wani lamba N yana da kyau, mara kyau, ko kuma sifili.  \nShigarwa: Wani lamba 'N' (-10^9 <= N <= 10^9).  \nFitarwa: Wani rubutu \"positive\" idan N > 0, \"zero\" idan N = 0, ko \"negative\" idan N < 0.  \nMisali:  \n>>> (judge-sign 95)  \n\"positive\"  \n>>> (judge-sign 0)  \n\"zero\"  \n>>> (judge-sign -3)  \n\"negative\"  ",
      "hi": "निर्धारित करता है कि कोई पूर्णांक N धनात्मक, ऋणात्मक, या शून्य है।\nइनपुट: एक पूर्णांक 'N' (-10^9 <= N <= 10^9)।\nआउटपुट: एक स्ट्रिंग \"positive\" यदि N > 0, \"zero\" यदि N = 0, या \"negative\" यदि N < 0।\nउदाहरण:\n>>> (judge-sign 95)\n\"positive\"\n>>> (judge-sign 0)\n\"zero\"\n>>> (judge-sign -3)\n\"negative\"",
      "hu": "Meghatározza, hogy egy egész szám N pozitív, negatív vagy nulla-e.\n Bemenet: Egy egész szám 'N' (-10^9 <= N <= 10^9).\n Kimenet: Egy \"positive\" sztring, ha N > 0, \"zero\" ha N = 0, vagy \"negative\" ha N < 0.\n Példa:\n >>> (judge-sign 95)\n \"positive\"\n >>> (judge-sign 0)\n \"zero\"\n >>> (judge-sign -3)\n \"negative\""
    },
    "docstring_bertscore": {
      "sq": "0.9993768964946935",
      "hy": "0.9859143251592919",
      "bn": "0.9922996960184205",
      "bg": "0.9947784045433549",
      "zh": "0.9353912973304009",
      "fr": "0.992672922504385",
      "de": "0.9993768964946935",
      "ha": "0.9724714182316128",
      "hi": "0.9993768964946935",
      "hu": "0.9936879237514733"
    }
  },
  {
    "task_id": "Common Lisp/50",
    "prompt": {
      "en": "(defun abs-value (n)\n  ;; Outputs the absolute value of an integer n.\n  ;; Input: An integer 'n', where the absolute value of n does not exceed 10000.\n  ;; Output: The absolute value of 'n'.\n  ;; Example:\n  ;; >>> (abs-value -3)\n  ;; 3\n  ;; >>> (abs-value 5)\n  ;; 5\n  ;; >>> (abs-value 0)\n  ;; 0",
      "sq": "(defun abs-value (n)\n  ;; Jep vlerën absolute të një numri të plotë n.\n  ;; Hyrja: Një numër i plotë 'n', ku vlera absolute e n nuk e kalon 10000.\n  ;; Dalja: Vlera absolute e 'n'.\n  ;; Shembull:\n  ;; >>> (abs-value -3)\n  ;; 3\n  ;; >>> (abs-value 5)\n  ;; 5\n  ;; >>> (abs-value 0)\n  ;; 0",
      "hy": "(defun abs-value (n)\n  ;; Վերադարձնում է n ամբողջ թվի բացարձակ արժեքը:\n  ;; Մուտք: Ամբողջ թիվ 'n', որի բացարձակ արժեքը չի գերազանցում 10000-ը:\n  ;; Ելք: 'n'-ի բացարձակ արժեքը:\n  ;; Օրինակ:\n  ;; >>> (abs-value -3)\n  ;; 3\n  ;; >>> (abs-value 5)\n  ;; 5\n  ;; >>> (abs-value 0)\n  ;; 0",
      "bn": "(defun abs-value (n)\n  ;; একটি পূর্ণসংখ্যা n এর পরম মান আউটপুট করে।\n  ;; ইনপুট: একটি পূর্ণসংখ্যা 'n', যেখানে n এর পরম মান 10000 অতিক্রম করে না।\n  ;; আউটপুট: 'n' এর পরম মান।\n  ;; উদাহরণ:\n  ;; >>> (abs-value -3)\n  ;; 3\n  ;; >>> (abs-value 5)\n  ;; 5\n  ;; >>> (abs-value 0)\n  ;; 0",
      "bg": "(defun abs-value (n)\n  ;; Извежда абсолютната стойност на цяло число n.\n  ;; Вход: Цяло число 'n', където абсолютната стойност на n не надвишава 10000.\n  ;; Изход: Абсолютната стойност на 'n'.\n  ;; Пример:\n  ;; >>> (abs-value -3)\n  ;; 3\n  ;; >>> (abs-value 5)\n  ;; 5\n  ;; >>> (abs-value 0)\n  ;; 0",
      "zh": "(defun abs-value (n)\n  ;; 输出整数 n 的绝对值。\n  ;; 输入: 一个整数 'n'，其中 n 的绝对值不超过 10000。\n  ;; 输出: 'n' 的绝对值。\n  ;; 示例:\n  ;; >>> (abs-value -3)\n  ;; 3\n  ;; >>> (abs-value 5)\n  ;; 5\n  ;; >>> (abs-value 0)\n  ;; 0",
      "fr": "(defun abs-value (n)\n  ;; Renvoie la valeur absolue d'un entier n.\n  ;; Entrée : Un entier 'n', où la valeur absolue de n ne dépasse pas 10000.\n  ;; Sortie : La valeur absolue de 'n'.\n  ;; Exemple :\n  ;; >>> (abs-value -3)\n  ;; 3\n  ;; >>> (abs-value 5)\n  ;; 5\n  ;; >>> (abs-value 0)\n  ;; 0",
      "de": "(defun abs-value (n)\n  ;; Gibt den Absolutwert einer Ganzzahl n aus.\n  ;; Eingabe: Eine Ganzzahl 'n', wobei der Absolutwert von n 10000 nicht überschreitet.\n  ;; Ausgabe: Der Absolutwert von 'n'.\n  ;; Beispiel:\n  ;; >>> (abs-value -3)\n  ;; 3\n  ;; >>> (abs-value 5)\n  ;; 5\n  ;; >>> (abs-value 0)\n  ;; 0",
      "ha": "(defun abs-value (n)\n  ;; Fitar da ƙimar lamba mai kyau na cikakken lamba n.\n  ;; Shigarwa: Cikakken lamba 'n', inda ƙimar lamba mai kyau na n ba ya wuce 10000.\n  ;; Fitarwa: Ƙimar lamba mai kyau na 'n'.\n  ;; Misali:\n  ;; >>> (abs-value -3)\n  ;; 3\n  ;; >>> (abs-value 5)\n  ;; 5\n  ;; >>> (abs-value 0)\n  ;; 0",
      "hi": "(defun abs-value (n)\n  ;; एक पूर्णांक n का परिमाण मान आउटपुट करता है।\n  ;; इनपुट: एक पूर्णांक 'n', जहाँ n का परिमाण मान 10000 से अधिक नहीं होता।\n  ;; आउटपुट: 'n' का परिमाण मान।\n  ;; उदाहरण:\n  ;; >>> (abs-value -3)\n  ;; 3\n  ;; >>> (abs-value 5)\n  ;; 5\n  ;; >>> (abs-value 0)\n  ;; 0",
      "hu": "(defun abs-value (n)\n  ;; Kiírja egy egész szám n abszolút értékét.\n  ;; Bemenet: Egy 'n' egész szám, ahol n abszolút értéke nem haladja meg a 10000-et.\n  ;; Kimenet: 'n' abszolút értéke.\n  ;; Példa:\n  ;; >>> (abs-value -3)\n  ;; 3\n  ;; >>> (abs-value 5)\n  ;; 5\n  ;; >>> (abs-value 0)\n  ;; 0"
    },
    "prompt_bertscore": {
      "sq": "0.9882557800909312",
      "hy": "0.9706899023441109",
      "bn": "0.999999801369619",
      "bg": "0.999999801369619",
      "zh": "0.9876294984995282",
      "fr": "0.9875673271902643",
      "de": "0.9875673271902643",
      "ha": "0.9862194214245615",
      "hi": "0.999999801369619",
      "hu": "0.9904669334926116"
    },
    "canonical_solution": "  (abs n))",
    "instruction": {
      "en": "Write a Common Lisp function `(defun abs-value (n)` to solve the following problem: Outputs the absolute value of an integer n.\n Input: An integer 'n', where the absolute value of n does not exceed 10000.\n Output: The absolute value of 'n'.\n Example:\n >>> (abs-value -3)\n 3\n >>> (abs-value 5)\n 5\n >>> (abs-value 0)\n 0",
      "sq": "Shkruani një funksion Common Lisp `(defun abs-value (n)` për të zgjidhur problemin në vijim: Jep vlerën absolute të një numri të plotë n.\n Hyrja: Një numër i plotë 'n', ku vlera absolute e n nuk tejkalon 10000.\n Dalja: Vlera absolute e 'n'.\n Shembull:\n >>> (abs-value -3)\n 3\n >>> (abs-value 5)\n 5\n >>> (abs-value 0)\n 0",
      "hy": "Գրեք Common Lisp ֆունկցիա `(defun abs-value (n)` հետևյալ խնդիրը լուծելու համար՝ Վերադարձնում է ամբողջ թիվ n-ի բացարձակ արժեքը։ \n Մուտք՝ Ամբողջ թիվ 'n', որտեղ n-ի բացարձակ արժեքը չի գերազանցում 10000-ը։ \n Ելք՝ 'n'-ի բացարձակ արժեքը։ \n Օրինակ՝ \n >>> (abs-value -3)\n 3\n >>> (abs-value 5)\n 5\n >>> (abs-value 0)\n 0",
      "bn": "একটি Common Lisp ফাংশন `(defun abs-value (n)` লিখুন নিম্নলিখিত সমস্যার সমাধানের জন্য: একটি পূর্ণসংখ্যা n এর পরম মান আউটপুট করে।\n ইনপুট: একটি পূর্ণসংখ্যা 'n', যেখানে n এর পরম মান 10000 অতিক্রম করে না।\n আউটপুট: 'n' এর পরম মান।\n উদাহরণ:\n >>> (abs-value -3)\n 3\n >>> (abs-value 5)\n 5\n >>> (abs-value 0)\n 0",
      "bg": "Напишете функция на Common Lisp `(defun abs-value (n)` за решаване на следния проблем: Извежда абсолютната стойност на цяло число n.\n Вход: Цяло число 'n', където абсолютната стойност на n не надвишава 10000.\n Изход: Абсолютната стойност на 'n'.\n Пример:\n >>> (abs-value -3)\n 3\n >>> (abs-value 5)\n 5\n >>> (abs-value 0)\n 0",
      "zh": "编写一个 Common Lisp 函数 `(defun abs-value (n)` 来解决以下问题：输出整数 n 的绝对值。\n 输入：一个整数 'n'，其中 n 的绝对值不超过 10000。\n 输出：'n' 的绝对值。\n 示例:\n >>> (abs-value -3)\n 3\n >>> (abs-value 5)\n 5\n >>> (abs-value 0)\n 0",
      "fr": "Écrire une fonction Common Lisp `(defun abs-value (n)` pour résoudre le problème suivant : Renvoie la valeur absolue d'un entier n.  \nEntrée : Un entier 'n', où la valeur absolue de n ne dépasse pas 10000.  \nSortie : La valeur absolue de 'n'.  \nExemple :  \n>>> (abs-value -3)  \n3  \n>>> (abs-value 5)  \n5  \n>>> (abs-value 0)  \n0  ",
      "de": "Schreiben Sie eine Common Lisp-Funktion `(defun abs-value (n)` um das folgende Problem zu lösen: Gibt den Absolutwert einer Ganzzahl n aus.\n Eingabe: Eine Ganzzahl 'n', wobei der Absolutwert von n 10000 nicht überschreitet.\n Ausgabe: Der Absolutwert von 'n'.\n Beispiel:\n >>> (abs-value -3)\n 3\n >>> (abs-value 5)\n 5\n >>> (abs-value 0)\n 0",
      "ha": "Rubuta aikin Common Lisp `(defun abs-value (n)` don warware matsalar mai zuwa: Fitar da ƙimar cikakkiyar lamba n.\n Shigarwa: Cikakkiyar lamba 'n', inda ƙimar cikakkiyar n ba ta wuce 10000.\n Fitarwa: Ƙimar cikakkiyar 'n'.\n Misali:\n >>> (abs-value -3)\n 3\n >>> (abs-value 5)\n 5\n >>> (abs-value 0)\n 0",
      "hi": "एक Common Lisp फ़ंक्शन `(defun abs-value (n)` लिखें ताकि निम्नलिखित समस्या का समाधान किया जा सके: एक पूर्णांक n का परिमाणात्मक मान आउटपुट करता है।\n इनपुट: एक पूर्णांक 'n', जहाँ n का परिमाणात्मक मान 10000 से अधिक नहीं होता।\n आउटपुट: 'n' का परिमाणात्मक मान।\n उदाहरण:\n >>> (abs-value -3)\n 3\n >>> (abs-value 5)\n 5\n >>> (abs-value 0)\n 0",
      "hu": "Írj egy Common Lisp függvényt `(defun abs-value (n)` a következő probléma megoldására: Kimenetként adja vissza egy egész szám n abszolút értékét.\n Bemenet: Egy 'n' egész szám, ahol n abszolút értéke nem haladja meg a 10000-et.\n Kimenet: 'n' abszolút értéke.\n Példa:\n >>> (abs-value -3)\n 3\n >>> (abs-value 5)\n 5\n >>> (abs-value 0)\n 0"
    },
    "instruction_bertscore": {
      "sq": "0.9872008541372549",
      "hy": "0.9893883705235922",
      "bn": "0.9952181722069661",
      "bg": "0.9952936517517593",
      "zh": "0.989871439610269",
      "fr": "0.9893883705235922",
      "de": "0.9893883705235922",
      "ha": "0.9952181722069661",
      "hi": "1",
      "hu": "0.9832826712409607"
    },
    "level": "easy",
    "test": "(defun check-abs-value ()\n  (assert (= (abs-value -3) 3))\n  (assert (= (abs-value 5) 5))\n  (assert (= (abs-value 0) 0))\n  (assert (= (abs-value -10000) 10000))\n  (assert (= (abs-value 9999) 9999)))\n\n(check-abs-value)",
    "entry_point": "abs-value",
    "signature": "(defun abs-value (n)",
    "docstring": {
      "en": "Outputs the absolute value of an integer n.\n Input: An integer 'n', where the absolute value of n does not exceed 10000.\n Output: The absolute value of 'n'.\n Example:\n >>> (abs-value -3)\n 3\n >>> (abs-value 5)\n 5\n >>> (abs-value 0)\n 0",
      "sq": "Kthen vlerën absolute të një numri të plotë n.  \nHyrja: Një numër i plotë 'n', ku vlera absolute e n nuk e kalon 10000.  \nDalja: Vlera absolute e 'n'.  \nShembull:  \n>>> (abs-value -3)  \n3  \n>>> (abs-value 5)  \n5  \n>>> (abs-value 0)  \n0  ",
      "hy": "Արտածում է n ամբողջ թվի բացարձակ արժեքը։  \nՄուտք: Ամբողջ թիվ 'n', որտեղ n-ի բացարձակ արժեքը չի գերազանցում 10000-ը։  \nԵլք: 'n'-ի բացարձակ արժեքը։  \nՕրինակ:  \n>>> (abs-value -3)  \n3  \n>>> (abs-value 5)  \n5  \n>>> (abs-value 0)  \n0  ",
      "bn": "একটি পূর্ণসংখ্যা n এর পরম মান আউটপুট করে।\n Input: একটি পূর্ণসংখ্যা 'n', যেখানে n এর পরম মান 10000 অতিক্রম করে না।  \n Output: 'n' এর পরম মান।  \n Example:  \n >>> (abs-value -3)  \n 3  \n >>> (abs-value 5)  \n 5  \n >>> (abs-value 0)  \n 0  ",
      "bg": "Извежда абсолютната стойност на цяло число n.\nВход: Цяло число 'n', където абсолютната стойност на n не надвишава 10000.  \nИзход: Абсолютната стойност на 'n'.  \nПример:  \n>>> (abs-value -3)  \n3  \n>>> (abs-value 5)  \n5  \n>>> (abs-value 0)  \n0  ",
      "zh": "输出整数 n 的绝对值。\n 输入: 一个整数 'n'，其中 n 的绝对值不超过 10000。\n 输出: 'n' 的绝对值。\n 示例:\n >>> (abs-value -3)\n 3\n >>> (abs-value 5)\n 5\n >>> (abs-value 0)\n 0",
      "fr": "Renvoie la valeur absolue d'un entier n.\n Entrée : Un entier 'n', où la valeur absolue de n ne dépasse pas 10000.\n Sortie : La valeur absolue de 'n'.\n Exemple :\n >>> (abs-value -3)\n 3\n >>> (abs-value 5)\n 5\n >>> (abs-value 0)\n 0",
      "de": "Gibt den absoluten Wert einer Ganzzahl n aus.\nEingabe: Eine Ganzzahl 'n', wobei der absolute Wert von n 10000 nicht überschreitet.  \nAusgabe: Der absolute Wert von 'n'.  \nBeispiel:  \n>>> (abs-value -3)  \n3  \n>>> (abs-value 5)  \n5  \n>>> (abs-value 0)  \n0  ",
      "ha": "Fitar da ƙimar lamba mai kyau na cikakken lamba n.\n Input: Wani cikakken lamba 'n', inda darajar da ba ta da alama ta n ba ta wuce 10000.\n Output: Darajar da ba ta da alama ta 'n'.\n Misali:\n >>> (abs-value -3)\n 3\n >>> (abs-value 5)\n 5\n >>> (abs-value 0)\n 0",
      "hi": "एक पूर्णांक n का परिमाण मान आउटपुट करता है।\nInput: एक पूर्णांक 'n', जहाँ n का परिमाण मान 10000 से अधिक नहीं होता है।  \nOutput: 'n' का परिमाण मान।  \nExample:  \n>>> (abs-value -3)  \n3  \n>>> (abs-value 5)  \n5  \n>>> (abs-value 0)  \n0  ",
      "hu": "Kiírja egy egész szám n abszolút értékét.\n Bemenet: Egy egész szám 'n', ahol n abszolút értéke nem haladja meg a 10000-et.\n Kimenet: 'n' abszolút értéke.\n Példa:\n >>> (abs-value -3)\n 3\n >>> (abs-value 5)\n 5\n >>> (abs-value 0)\n 0"
    },
    "docstring_bertscore": {
      "sq": "0.985584201466012",
      "hy": "0.9929374981719236",
      "bn": "1",
      "bg": "1",
      "zh": "0.9845407960744357",
      "fr": "0.985584201466012",
      "de": "0.985584201466012",
      "ha": "1",
      "hi": "1",
      "hu": "0.9902365222506111"
    }
  }
]