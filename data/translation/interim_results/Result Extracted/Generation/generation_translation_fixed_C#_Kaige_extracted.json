[
  {
    "task_id": "C#/1",
    "prompt": {
      "en": "using System;\nusing System.Collections.Generic;\n\nclass Program\n{\n    /* Check if in given list of numbers, any two numbers are closer to each other than\n   the given threshold.\n   >>> hasCloseElements([1.0, 2.0, 3.0], 0.5)\n   false\n   >>> hasCloseElements([1.0, 2.8, 3.0, 4.0, 5.0, 2.0], 0.3)\n   true\n    */\n    static bool HasCloseElements(List<double> numbers, double threshold)",
      "sq": "using System;\nusing System.Collections.Generic;\n\nclass Program\n{\n    /* Kontrolloni nëse në listën e dhënë të numrave, ndonjë dy numra janë më afër njëri-tjetrit sesa\n   pragu i dhënë.\n   >>> hasCloseElements([1.0, 2.0, 3.0], 0.5)\n   false\n   >>> hasCloseElements([1.0, 2.8, 3.0, 4.0, 5.0, 2.0], 0.3)\n   true\n    */\n    static bool HasCloseElements(List<double> numbers, double threshold)",
      "hy": "using System;\nusing System.Collections.Generic;\n\nclass Program\n{\n    /* Ստուգել, արդյոք տրված թվերի ցուցակում որևէ երկու թիվ միմյանց ավելի մոտ են, քան\n   տրված շեմը:\n   >>> hasCloseElements([1.0, 2.0, 3.0], 0.5)\n   false\n   >>> hasCloseElements([1.0, 2.8, 3.0, 4.0, 5.0, 2.0], 0.3)\n   true\n    */\n    static bool HasCloseElements(List<double> numbers, double threshold)",
      "bn": "using System;\nusing System.Collections.Generic;\n\nclass Program\n{\n    /* প্রদত্ত সংখ্যার তালিকায়, কোনো দুটি সংখ্যা একে অপরের থেকে প্রদত্ত সীমার চেয়ে কাছাকাছি আছে কিনা তা পরীক্ষা করুন।\n   >>> hasCloseElements([1.0, 2.0, 3.0], 0.5)\n   false\n   >>> hasCloseElements([1.0, 2.8, 3.0, 4.0, 5.0, 2.0], 0.3)\n   true\n    */\n    static bool HasCloseElements(List<double> numbers, double threshold)",
      "bg": "using System;\nusing System.Collections.Generic;\n\nclass Program\n{\n    /* Проверете дали в даден списък от числа, някои две числа са по-близо едно до друго от\n   дадения праг.\n   >>> hasCloseElements([1.0, 2.0, 3.0], 0.5)\n   false\n   >>> hasCloseElements([1.0, 2.8, 3.0, 4.0, 5.0, 2.0], 0.3)\n   true\n    */\n    static bool HasCloseElements(List<double> numbers, double threshold)",
      "zh": "using System;\nusing System.Collections.Generic;\n\nclass Program\n{\n    /* 检查在给定的数字列表中，是否有任意两个数字之间的距离小于给定的阈值。\n   >>> hasCloseElements([1.0, 2.0, 3.0], 0.5)\n   false\n   >>> hasCloseElements([1.0, 2.8, 3.0, 4.0, 5.0, 2.0], 0.3)\n   true\n    */\n    static bool HasCloseElements(List<double> numbers, double threshold)",
      "fr": "using System;\nusing System.Collections.Generic;\n\nclass Program\n{\n    /* Vérifiez si dans une liste donnée de nombres, deux nombres quelconques sont plus proches l'un de l'autre que\n   le seuil donné.\n   >>> hasCloseElements([1.0, 2.0, 3.0], 0.5)\n   false\n   >>> hasCloseElements([1.0, 2.8, 3.0, 4.0, 5.0, 2.0], 0.3)\n   true\n    */\n    static bool HasCloseElements(List<double> numbers, double threshold)",
      "de": "using System;\nusing System.Collections.Generic;\n\nclass Program\n{\n    /* Überprüfen, ob in der gegebenen Liste von Zahlen zwei beliebige Zahlen näher beieinander liegen als\n   der gegebene Schwellenwert.\n   >>> hasCloseElements([1.0, 2.0, 3.0], 0.5)\n   false\n   >>> hasCloseElements([1.0, 2.8, 3.0, 4.0, 5.0, 2.0], 0.3)\n   true\n    */\n    static bool HasCloseElements(List<double> numbers, double threshold)",
      "ha": "using System;\nusing System.Collections.Generic;\n\nclass Program\n{\n    /* Duba idan a cikin jerin lambobi da aka bayar, akwai kowanne lambobi biyu da suka fi kusa da juna fiye da\n   iyakar da aka bayar.\n   >>> hasCloseElements([1.0, 2.0, 3.0], 0.5)\n   false\n   >>> hasCloseElements([1.0, 2.8, 3.0, 4.0, 5.0, 2.0], 0.3)\n   true\n    */\n    static bool HasCloseElements(List<double> numbers, double threshold)",
      "hi": "using System;\nusing System.Collections.Generic;\n\nclass Program\n{\n    /* जाँचें कि दिए गए संख्याओं की सूची में, क्या कोई दो संख्याएँ दी गई सीमा से अधिक निकट हैं।\n   >>> hasCloseElements([1.0, 2.0, 3.0], 0.5)\n   false\n   >>> hasCloseElements([1.0, 2.8, 3.0, 4.0, 5.0, 2.0], 0.3)\n   true\n    */\n    static bool HasCloseElements(List<double> numbers, double threshold)",
      "hu": "using System;\nusing System.Collections.Generic;\n\nclass Program\n{\n    /* Ellenőrizzük, hogy a megadott számok listájában bármely két szám közelebb van-e egymáshoz\n   mint a megadott küszöbérték.\n   >>> hasCloseElements([1.0, 2.0, 3.0], 0.5)\n   false\n   >>> hasCloseElements([1.0, 2.8, 3.0, 4.0, 5.0, 2.0], 0.3)\n   true\n    */\n    static bool HasCloseElements(List<double> numbers, double threshold)"
    },
    "prompt_bertscore": {
      "sq": "0.9934283138434608",
      "hy": "0.9781170895517673",
      "bn": "0.9760930459690219",
      "bg": "0.9927913062114818",
      "zh": "0.958751819183152",
      "fr": "0.9927913062114818",
      "de": "0.9906417282279223",
      "ha": "0.9762410256028928",
      "hi": "0.9827261089133009",
      "hu": "0.9870904156453996"
    },
    "canonical_solution": "    {\n        for (int i = 0; i < numbers.Count; i++)\n        {\n            for (int j = 0; j < numbers.Count; j++)\n            {\n                if (i != j)\n                {\n                    double distance = Math.Abs(numbers[i] - numbers[j]);\n                    if (distance < threshold)\n                    {\n                        return true;\n                    }\n                }\n            }\n        }\n        return false;\n    }",
    "instruction": {
      "en": "Write a C# function `static bool HasCloseElements(List<double> numbers, double threshold)` to solve the following problem:\nCheck if in given list of numbers, any two numbers are closer to each other than\n   the given threshold.\n   >>> hasCloseElements([1.0, 2.0, 3.0], 0.5)\n   false\n   >>> hasCloseElements([1.0, 2.8, 3.0, 4.0, 5.0, 2.0], 0.3)\n   true",
      "sq": "Shkruani një funksion në C# `static bool HasCloseElements(List<double> numbers, double threshold)` për të zgjidhur problemin në vijim:  \nKontrolloni nëse në listën e dhënë të numrave, ndonjë dy numra janë më afër njëri-tjetrit sesa pragu i dhënë.  \n   >>> hasCloseElements([1.0, 2.0, 3.0], 0.5)  \n   false  \n   >>> hasCloseElements([1.0, 2.8, 3.0, 4.0, 5.0, 2.0], 0.3)  \n   true",
      "hy": "Գրեք C# ֆունկցիա `static bool HasCloseElements(List<double> numbers, double threshold)` հետևյալ խնդիրը լուծելու համար:\nՍտուգեք, արդյոք տրված թվերի ցանկում որևէ երկու թիվ միմյանց ավելի մոտ են, քան տրված շեմը:\n   >>> hasCloseElements([1.0, 2.0, 3.0], 0.5)\n   false\n   >>> hasCloseElements([1.0, 2.8, 3.0, 4.0, 5.0, 2.0], 0.3)\n   true",
      "bn": "একটি C# ফাংশন `static bool HasCloseElements(List<double> numbers, double threshold)` লিখুন নিম্নলিখিত সমস্যার সমাধানের জন্য:\nযাচাই করুন যে প্রদত্ত সংখ্যার তালিকায় কোনো দুটি সংখ্যা পরস্পরের চেয়ে প্রদত্ত সীমার চেয়ে কাছাকাছি কিনা।\n   >>> hasCloseElements([1.0, 2.0, 3.0], 0.5)\n   false\n   >>> hasCloseElements([1.0, 2.8, 3.0, 4.0, 5.0, 2.0], 0.3)\n   true",
      "bg": "Напишете C# функция `static bool HasCloseElements(List<double> numbers, double threshold)` за решаване на следния проблем:\nПроверете дали в даден списък от числа, някои две числа са по-близо едно до друго от дадения праг.\n   >>> hasCloseElements([1.0, 2.0, 3.0], 0.5)\n   false\n   >>> hasCloseElements([1.0, 2.8, 3.0, 4.0, 5.0, 2.0], 0.3)\n   true",
      "zh": "编写一个 C# 函数 `static bool HasCloseElements(List<double> numbers, double threshold)` 来解决以下问题：  \n检查在给定的数字列表中，是否有任意两个数字彼此之间的距离小于给定的阈值。  \n   >>> hasCloseElements([1.0, 2.0, 3.0], 0.5)  \n   false  \n   >>> hasCloseElements([1.0, 2.8, 3.0, 4.0, 5.0, 2.0], 0.3)  \n   true  ",
      "fr": "Écrire une fonction C# `static bool HasCloseElements(List<double> numbers, double threshold)` pour résoudre le problème suivant :\nVérifier si, dans une liste donnée de nombres, deux nombres quelconques sont plus proches l'un de l'autre que le seuil donné.\n   >>> hasCloseElements([1.0, 2.0, 3.0], 0.5)\n   false\n   >>> hasCloseElements([1.0, 2.8, 3.0, 4.0, 5.0, 2.0], 0.3)\n   true",
      "de": "Schreiben Sie eine C#-Funktion `static bool HasCloseElements(List<double> numbers, double threshold)`, um das folgende Problem zu lösen:\nÜberprüfen Sie, ob in der gegebenen Liste von Zahlen zwei beliebige Zahlen näher beieinander liegen als der angegebene Schwellenwert.\n   >>> hasCloseElements([1.0, 2.0, 3.0], 0.5)\n   false\n   >>> hasCloseElements([1.0, 2.8, 3.0, 4.0, 5.0, 2.0], 0.3)\n   true",
      "ha": "Rubuta aikin C# `static bool HasCloseElements(List<double> numbers, double threshold)` don warware matsalar mai zuwa:\nDuba idan a cikin jerin lambobi da aka bayar, kowanne lambobi biyu sun fi kusa da juna fiye da \n   ƙayyadadden tazara.\n   >>> hasCloseElements([1.0, 2.0, 3.0], 0.5)\n   false\n   >>> hasCloseElements([1.0, 2.8, 3.0, 4.0, 5.0, 2.0], 0.3)\n   true",
      "hi": "C# फ़ंक्शन `static bool HasCloseElements(List<double> numbers, double threshold)` लिखें ताकि निम्नलिखित समस्या का समाधान किया जा सके:\nजाँच करें कि दिए गए संख्याओं की सूची में, कोई भी दो संख्याएँ एक-दूसरे के जितना करीब हैं, वह दिए गए सीमा से कम है या नहीं।\n   >>> hasCloseElements([1.0, 2.0, 3.0], 0.5)\n   false\n   >>> hasCloseElements([1.0, 2.8, 3.0, 4.0, 5.0, 2.0], 0.3)\n   true",
      "hu": "Írj egy C# függvényt `static bool HasCloseElements(List<double> numbers, double threshold)` a következő probléma megoldására:\nEllenőrizd, hogy a megadott számok listájában bármely két szám közelebb van-e egymáshoz, mint a megadott küszöbérték.\n   >>> hasCloseElements([1.0, 2.0, 3.0], 0.5)\n   false\n   >>> hasCloseElements([1.0, 2.8, 3.0, 4.0, 5.0, 2.0], 0.3)\n   true"
    },
    "instruction_bertscore": {
      "sq": "0.9863882572484411",
      "hy": "0.984394206853232",
      "bn": "0.9787825013282343",
      "bg": "0.9930225119750065",
      "zh": "0.9682566801764335",
      "fr": "0.9874878750378503",
      "de": "0.988078005899905",
      "ha": "0.9741049544852437",
      "hi": "0.9739021528662071",
      "hu": "0.9926131347596936"
    },
    "level": "easy",
    "test": "static void Main()\n    {\n\n        // Test cases\n        Console.WriteLine(HasCloseElements(new List<double> { 1.0, 2.0, 3.9, 4.0, 5.0, 2.2 }, 0.3) == true);\n        Console.WriteLine(HasCloseElements(new List<double> { 1.0, 2.0, 3.9, 4.0, 5.0, 2.2 }, 0.05) == false);\n        Console.WriteLine(HasCloseElements(new List<double> { 1.0, 2.0, 5.9, 4.0, 5.0 }, 0.95) == true);\n        Console.WriteLine(HasCloseElements(new List<double> { 1.0, 2.0, 5.9, 4.0, 5.0 }, 0.8) == false);\n        Console.WriteLine(HasCloseElements(new List<double> { 1.0, 2.0, 3.0, 4.0, 5.0, 2.0 }, 0.1) == true);\n        Console.WriteLine(HasCloseElements(new List<double> { 1.1, 2.2, 3.1, 4.1, 5.1 }, 1.0) == true);\n        Console.WriteLine(HasCloseElements(new List<double> { 1.1, 2.2, 3.1, 4.1, 5.1 }, 0.5) == false);\n    }\n}",
    "entry_point": "HasCloseElements",
    "signature": "static bool HasCloseElements(List<double> numbers, double threshold)",
    "docstring": {
      "en": "Check if in given list of numbers, any two numbers are closer to each other than\n   the given threshold.\n   >>> hasCloseElements([1.0, 2.0, 3.0], 0.5)\n   false\n   >>> hasCloseElements([1.0, 2.8, 3.0, 4.0, 5.0, 2.0], 0.3)\n   true",
      "sq": "Kontrolloni nëse në listën e dhënë të numrave, ndonjë dy numra janë më afër njëri-tjetrit sesa pragu i dhënë.\n   >>> hasCloseElements([1.0, 2.0, 3.0], 0.5)\n   false\n   >>> hasCloseElements([1.0, 2.8, 3.0, 4.0, 5.0, 2.0], 0.3)\n   true",
      "hy": "Ստուգեք, արդյոք տրված թվերի ցանկում որևէ երկու թիվ միմյանց ավելի մոտ են, քան տրված շեմը։\n   >>> hasCloseElements([1.0, 2.0, 3.0], 0.5)\n   false\n   >>> hasCloseElements([1.0, 2.8, 3.0, 4.0, 5.0, 2.0], 0.3)\n   true",
      "bn": "প্রদত্ত সংখ্যার তালিকায়, কোনো দুটি সংখ্যা দেওয়া থ্রেশহোল্ডের চেয়ে কাছাকাছি আছে কিনা তা পরীক্ষা করুন।\n   >>> hasCloseElements([1.0, 2.0, 3.0], 0.5)\n   false\n   >>> hasCloseElements([1.0, 2.8, 3.0, 4.0, 5.0, 2.0], 0.3)\n   true",
      "bg": "Проверете дали в даден списък от числа, някои две числа са по-близо едно до друго от дадения праг.\n   >>> hasCloseElements([1.0, 2.0, 3.0], 0.5)\n   false\n   >>> hasCloseElements([1.0, 2.8, 3.0, 4.0, 5.0, 2.0], 0.3)\n   true",
      "zh": "检查给定数字列表中是否有任意两个数字之间的距离小于给定的阈值。\n   >>> hasCloseElements([1.0, 2.0, 3.0], 0.5)\n   false\n   >>> hasCloseElements([1.0, 2.8, 3.0, 4.0, 5.0, 2.0], 0.3)\n   true",
      "fr": "Vérifiez si, dans une liste donnée de nombres, deux nombres quelconques sont plus proches l'un de l'autre que le seuil donné.\n   >>> hasCloseElements([1.0, 2.0, 3.0], 0.5)\n   false\n   >>> hasCloseElements([1.0, 2.8, 3.0, 4.0, 5.0, 2.0], 0.3)\n   true",
      "de": "Überprüfen Sie, ob in der gegebenen Liste von Zahlen zwei beliebige Zahlen näher beieinander liegen als der angegebene Schwellenwert.\n   >>> hasCloseElements([1.0, 2.0, 3.0], 0.5)\n   false\n   >>> hasCloseElements([1.0, 2.8, 3.0, 4.0, 5.0, 2.0], 0.3)\n   true",
      "ha": "Duba idan a cikin jerin lambobin da aka bayar, ko wani lambobi biyu sun fi kusa da juna fiye da\n   iyakar da aka bayar.\n   >>> hasCloseElements([1.0, 2.0, 3.0], 0.5)\n   false\n   >>> hasCloseElements([1.0, 2.8, 3.0, 4.0, 5.0, 2.0], 0.3)\n   true",
      "hi": "जाँचें कि दिए गए संख्याओं की सूची में, कोई दो संख्याएँ दी गई सीमा से अधिक निकट हैं या नहीं।  \n>>> hasCloseElements([1.0, 2.0, 3.0], 0.5)  \nfalse  \n>>> hasCloseElements([1.0, 2.8, 3.0, 4.0, 5.0, 2.0], 0.3)  \ntrue",
      "hu": "Ellenőrizze, hogy a megadott számok listájában bármelyik két szám közelebb van-e egymáshoz, mint a megadott küszöbérték.\n   >>> hasCloseElements([1.0, 2.0, 3.0], 0.5)\n   false\n   >>> hasCloseElements([1.0, 2.8, 3.0, 4.0, 5.0, 2.0], 0.3)\n   true"
    },
    "docstring_bertscore": {
      "sq": "0.9912743659915184",
      "hy": "0.9674289873786611",
      "bn": "0.9482951214039513",
      "bg": "0.9889523768372206",
      "zh": "0.944774596530489",
      "fr": "0.9802690510998994",
      "de": "0.9609468835239685",
      "ha": "0.9835210276982026",
      "hi": "0.9680852621576004",
      "hu": "0.9732135013351592"
    }
  },
  {
    "task_id": "C#/2",
    "prompt": {
      "en": "using System;\nusing System.Collections.Generic;\nusing System.Diagnostics;\n\nclass Program\n{\n /* Converts a given Fahrenheit temperature to Celsius and returns the result as a string formatted to two decimal places.\n    The formula used is: Celsius = 5/9 * (Fahrenheit - 32).\n    Example usage:\n    >>> ConvertFahrenheitToCelsius(32)\n    \"c=0.00\"\n    >>> ConvertFahrenheitToCelsius(212)\n    \"c=100.00\"\n*/  \nstatic string ConvertFahrenheitToCelsius(double fahrenheitTemperature)",
      "sq": "using System;\nusing System.Collections.Generic;\nusing System.Diagnostics;\n\nclass Program\n{\n /* Konverton një temperaturë të dhënë në Fahrenheit në Celsius dhe kthen rezultatin si një varg i formatuar në dy vende dhjetore.\n    Formula e përdorur është: Celsius = 5/9 * (Fahrenheit - 32).\n    Shembull përdorimi:\n    >>> ConvertFahrenheitToCelsius(32)\n    \"c=0.00\"\n    >>> ConvertFahrenheitToCelsius(212)\n    \"c=100.00\"\n*/  \nstatic string ConvertFahrenheitToCelsius(double fahrenheitTemperature)",
      "hy": "using System;\nusing System.Collections.Generic;\nusing System.Diagnostics;\n\nclass Program\n{\n /* Տրված Ֆարենհայթի ջերմաստիճանը փոխակերպում է Ցելսիուսի և վերադարձնում արդյունքը որպես տող՝ ձևաչափված երկու տասնորդական թվանշաններով:\n    Օգտագործվող բանաձևն է՝ Ցելսիուս = 5/9 * (Ֆարենհայթ - 32):\n    Օրինակ օգտագործում:\n    >>> ConvertFahrenheitToCelsius(32)\n    \"c=0.00\"\n    >>> ConvertFahrenheitToCelsius(212)\n    \"c=100.00\"\n*/  \nstatic string ConvertFahrenheitToCelsius(double fahrenheitTemperature)",
      "bn": "using System;\nusing System.Collections.Generic;\nusing System.Diagnostics;\n\nclass Program\n{\n /* একটি প্রদত্ত ফারেনহাইট তাপমাত্রাকে সেলসিয়াসে রূপান্তর করে এবং ফলাফলটি দুটি দশমিক স্থান পর্যন্ত ফরম্যাট করা একটি স্ট্রিং হিসাবে ফেরত দেয়।\n    ব্যবহৃত সূত্র হল: সেলসিয়াস = 5/9 * (ফারেনহাইট - 32)।\n    উদাহরণ ব্যবহার:\n    >>> ConvertFahrenheitToCelsius(32)\n    \"c=0.00\"\n    >>> ConvertFahrenheitToCelsius(212)\n    \"c=100.00\"\n*/  \nstatic string ConvertFahrenheitToCelsius(double fahrenheitTemperature)",
      "bg": "using System;\nusing System.Collections.Generic;\nusing System.Diagnostics;\n\nclass Program\n{\n /* Преобразува дадена температура по Фаренхайт в Целзий и връща резултата като низ, форматиран до два знака след десетичната запетая.\n    Използваната формула е: Целзий = 5/9 * (Фаренхайт - 32).\n    Пример за използване:\n    >>> ConvertFahrenheitToCelsius(32)\n    \"c=0.00\"\n    >>> ConvertFahrenheitToCelsius(212)\n    \"c=100.00\"\n*/  \nstatic string ConvertFahrenheitToCelsius(double fahrenheitTemperature)",
      "zh": "using System;\nusing System.Collections.Generic;\nusing System.Diagnostics;\n\nclass Program\n{\n /* 将给定的华氏温度转换为摄氏温度，并将结果作为格式化为两位小数的字符串返回。\n    使用的公式是：摄氏温度 = 5/9 * (华氏温度 - 32)。\n    示例用法：\n    >>> ConvertFahrenheitToCelsius(32)\n    \"c=0.00\"\n    >>> ConvertFahrenheitToCelsius(212)\n    \"c=100.00\"\n*/  \nstatic string ConvertFahrenheitToCelsius(double fahrenheitTemperature)",
      "fr": "using System;\nusing System.Collections.Generic;\nusing System.Diagnostics;\n\nclass Program\n{\n /* Convertit une température donnée en Fahrenheit en Celsius et renvoie le résultat sous forme de chaîne formatée à deux décimales.\n    La formule utilisée est : Celsius = 5/9 * (Fahrenheit - 32).\n    Exemple d'utilisation :\n    >>> ConvertFahrenheitToCelsius(32)\n    \"c=0.00\"\n    >>> ConvertFahrenheitToCelsius(212)\n    \"c=100.00\"\n*/  \nstatic string ConvertFahrenheitToCelsius(double fahrenheitTemperature)",
      "de": "using System;\nusing System.Collections.Generic;\nusing System.Diagnostics;\n\nclass Program\n{\n /* Konvertiert eine gegebene Fahrenheit-Temperatur in Celsius und gibt das Ergebnis als Zeichenkette formatiert auf zwei Dezimalstellen zurück.\n    Die verwendete Formel ist: Celsius = 5/9 * (Fahrenheit - 32).\n    Beispielverwendung:\n    >>> ConvertFahrenheitToCelsius(32)\n    \"c=0.00\"\n    >>> ConvertFahrenheitToCelsius(212)\n    \"c=100.00\"\n*/  \nstatic string ConvertFahrenheitToCelsius(double fahrenheitTemperature)",
      "ha": "using System;\nusing System.Collections.Generic;\nusing System.Diagnostics;\n\nclass Program\n{\n /* Ya canza zafin Fahrenheit da aka bayar zuwa Celsius kuma ya dawo da sakamakon a matsayin kirtani da aka tsara zuwa wurare biyu na goma.\n    Ana amfani da tsarin: Celsius = 5/9 * (Fahrenheit - 32).\n    Misalin amfani:\n    >>> ConvertFahrenheitToCelsius(32)\n    \"c=0.00\"\n    >>> ConvertFahrenheitToCelsius(212)\n    \"c=100.00\"\n*/  \nstatic string ConvertFahrenheitToCelsius(double fahrenheitTemperature)",
      "hi": "using System;\nusing System.Collections.Generic;\nusing System.Diagnostics;\n\nclass Program\n{\n /* एक दिए गए फ़ारेनहाइट तापमान को सेल्सियस में परिवर्तित करता है और परिणाम को दो दशमलव स्थानों तक स्वरूपित स्ट्रिंग के रूप में लौटाता है।\n    उपयोग किया गया सूत्र है: सेल्सियस = 5/9 * (फ़ारेनहाइट - 32)।\n    उदाहरण उपयोग:\n    >>> ConvertFahrenheitToCelsius(32)\n    \"c=0.00\"\n    >>> ConvertFahrenheitToCelsius(212)\n    \"c=100.00\"\n*/  \nstatic string ConvertFahrenheitToCelsius(double fahrenheitTemperature)",
      "hu": "using System;\nusing System.Collections.Generic;\nusing System.Diagnostics;\n\nclass Program\n{\n /* Átkonvertál egy adott Fahrenheit hőmérsékletet Celsiusra, és az eredményt két tizedesjegyre formázott sztringként adja vissza.\n    Az alkalmazott képlet: Celsius = 5/9 * (Fahrenheit - 32).\n    Példa használat:\n    >>> ConvertFahrenheitToCelsius(32)\n    \"c=0.00\"\n    >>> ConvertFahrenheitToCelsius(212)\n    \"c=100.00\"\n*/  \nstatic string ConvertFahrenheitToCelsius(double fahrenheitTemperature)"
    },
    "prompt_bertscore": {
      "sq": "0.9930765394386479",
      "hy": "0.9923586892415879",
      "bn": "1",
      "bg": "0.9922951275196567",
      "zh": "0.9877087520215612",
      "fr": "0.9899892274262226",
      "de": "1",
      "ha": "0.9985917105984626",
      "hi": "0.9973514624992807",
      "hu": "0.9968248933591574"
    },
    "canonical_solution": "{\n    double celsiusTemperature = 5.0 / 9.0 * (fahrenheitTemperature - 32);\n    return $\"c={celsiusTemperature:F2}\";\n}",
    "instruction": {
      "en": "Write a C# function `static string ConvertFahrenheitToCelsius(double fahrenheitTemperature)` to solve the following problem:\nConverts a given Fahrenheit temperature to Celsius and returns the result as a string formatted to two decimal places.\n    The formula used is: Celsius = 5/9 * (Fahrenheit - 32).\n    Example usage:\n    >>> ConvertFahrenheitToCelsius(32)\n    \"c=0.00\"\n    >>> ConvertFahrenheitToCelsius(212)\n    \"c=100.00\"",
      "sq": "Shkruani një funksion C# `static string ConvertFahrenheitToCelsius(double fahrenheitTemperature)` për të zgjidhur problemin e mëposhtëm:\nKonverton një temperaturë të dhënë në Fahrenheit në Celsius dhe kthen rezultatin si një varg i formatuar në dy vende dhjetore.\n    Formula e përdorur është: Celsius = 5/9 * (Fahrenheit - 32).\n    Shembull përdorimi:\n    >>> ConvertFahrenheitToCelsius(32)\n    \"c=0.00\"\n    >>> ConvertFahrenheitToCelsius(212)\n    \"c=100.00\"",
      "hy": "Գրեք C# ֆունկցիա `static string ConvertFahrenheitToCelsius(double fahrenheitTemperature)`՝ հետևյալ խնդիրը լուծելու համար:\nՓոխակերպում է տրված Ֆարենհայթի ջերմաստիճանը Ցելսիուսի և վերադարձնում արդյունքը որպես տող, ձևաչափված երկու տասնորդական թվանշանով:\n    Օգտագործվող բանաձևն է՝ Ցելսիուս = 5/9 * (Ֆարենհայթ - 32):\n    Օրինակ օգտագործում:\n    >>> ConvertFahrenheitToCelsius(32)\n    \"c=0.00\"\n    >>> ConvertFahrenheitToCelsius(212)\n    \"c=100.00\"",
      "bn": "C# ফাংশন `static string ConvertFahrenheitToCelsius(double fahrenheitTemperature)` লিখুন নিম্নলিখিত সমস্যার সমাধানের জন্য:\nএকটি প্রদত্ত ফারেনহাইট তাপমাত্রাকে সেলসিয়াসে রূপান্তর করে এবং ফলাফলটি একটি স্ট্রিং হিসাবে ফেরত দেয় যা দুই দশমিক স্থান পর্যন্ত বিন্যাসিত।\n    ব্যবহৃত সূত্র হল: Celsius = 5/9 * (Fahrenheit - 32)।\n    উদাহরণ ব্যবহার:\n    >>> ConvertFahrenheitToCelsius(32)\n    \"c=0.00\"\n    >>> ConvertFahrenheitToCelsius(212)\n    \"c=100.00\"",
      "bg": "Напишете C# функция `static string ConvertFahrenheitToCelsius(double fahrenheitTemperature)`, за да решите следния проблем:\nПреобразува дадена температура по Фаренхайт в Целзий и връща резултата като низ, форматиран до два знака след десетичната запетая.\n    Формулата, която се използва, е: Celsius = 5/9 * (Fahrenheit - 32).\n    Пример за използване:\n    >>> ConvertFahrenheitToCelsius(32)\n    \"c=0.00\"\n    >>> ConvertFahrenheitToCelsius(212)\n    \"c=100.00\"",
      "zh": "编写一个 C# 函数 `static string ConvertFahrenheitToCelsius(double fahrenheitTemperature)` 来解决以下问题：\n将给定的华氏温度转换为摄氏温度，并将结果格式化为两位小数的字符串返回。\n    使用的公式是：Celsius = 5/9 * (Fahrenheit - 32)。\n    示例用法:\n    >>> ConvertFahrenheitToCelsius(32)\n    \"c=0.00\"\n    >>> ConvertFahrenheitToCelsius(212)\n    \"c=100.00\"",
      "fr": "Écrire une fonction C# `static string ConvertFahrenheitToCelsius(double fahrenheitTemperature)` pour résoudre le problème suivant :\nConvertit une température donnée en Fahrenheit en Celsius et renvoie le résultat sous forme de chaîne formatée à deux décimales.\n    La formule utilisée est : Celsius = 5/9 * (Fahrenheit - 32).\n    Exemple d'utilisation :\n    >>> ConvertFahrenheitToCelsius(32)\n    \"c=0.00\"\n    >>> ConvertFahrenheitToCelsius(212)\n    \"c=100.00\"",
      "de": "Schreiben Sie eine C#-Funktion `static string ConvertFahrenheitToCelsius(double fahrenheitTemperature)`, um das folgende Problem zu lösen:\nKonvertiert eine gegebene Fahrenheit-Temperatur in Celsius und gibt das Ergebnis als String formatiert auf zwei Dezimalstellen zurück.\n    Die verwendete Formel ist: Celsius = 5/9 * (Fahrenheit - 32).\n    Beispielverwendung:\n    >>> ConvertFahrenheitToCelsius(32)\n    \"c=0.00\"\n    >>> ConvertFahrenheitToCelsius(212)\n    \"c=100.00\"",
      "ha": "Rubuta aikin C# `static string ConvertFahrenheitToCelsius(double fahrenheitTemperature)` don magance matsalar mai zuwa:\nCanza zazzabi na Fahrenheit da aka bayar zuwa Celsius kuma ya dawo da sakamakon a matsayin kirtani da aka tsara zuwa wurare biyu na goma.\n    Ana amfani da tsarin: Celsius = 5/9 * (Fahrenheit - 32).\n    Misalin amfani:\n    >>> ConvertFahrenheitToCelsius(32)\n    \"c=0.00\"\n    >>> ConvertFahrenheitToCelsius(212)\n    \"c=100.00\"",
      "hi": "C# फ़ंक्शन `static string ConvertFahrenheitToCelsius(double fahrenheitTemperature)` लिखें ताकि निम्नलिखित समस्या का समाधान किया जा सके:\nदिए गए फ़ारेनहाइट तापमान को सेल्सियस में परिवर्तित करता है और परिणाम को दो दशमलव स्थानों तक स्वरूपित स्ट्रिंग के रूप में लौटाता है।\n    उपयोग किया गया सूत्र है: Celsius = 5/9 * (Fahrenheit - 32).\n    उदाहरण उपयोग:\n    >>> ConvertFahrenheitToCelsius(32)\n    \"c=0.00\"\n    >>> ConvertFahrenheitToCelsius(212)\n    \"c=100.00\"",
      "hu": "Írj egy C# függvényt `static string ConvertFahrenheitToCelsius(double fahrenheitTemperature)` a következő probléma megoldására:\nÁtalakít egy adott Fahrenheit hőmérsékletet Celsiusra, és visszaadja az eredményt egy két tizedesjegyre formázott karakterláncként.\n    Az alkalmazott képlet: Celsius = 5/9 * (Fahrenheit - 32).\n    Példa használat:\n    >>> ConvertFahrenheitToCelsius(32)\n    \"c=0.00\"\n    >>> ConvertFahrenheitToCelsius(212)\n    \"c=100.00\""
    },
    "instruction_bertscore": {
      "sq": "0.9951885762801919",
      "hy": "0.9088469291000415",
      "bn": "0.9860688595957371",
      "bg": "0.9937872389419907",
      "zh": "0.9877576150952957",
      "fr": "0.9951885762801919",
      "de": "0.9951317679912159",
      "ha": "0.9857973318648624",
      "hi": "0.9732230355934488",
      "hu": "0.9967950988020021"
    },
    "level": "easy",
    "test": "    static void Main()\n    {\n        Debug.Assert(ConvertFahrenheitToCelsius(32) == \"c=0.00\");\n        Debug.Assert(ConvertFahrenheitToCelsius(212) == \"c=100.00\");\n        Debug.Assert(ConvertFahrenheitToCelsius(-40) == \"c=-40.00\");\n        Debug.Assert(ConvertFahrenheitToCelsius(98.6) == \"c=37.00\");\n        Debug.Assert(ConvertFahrenheitToCelsius(0) == \"c=-17.78\");\n\n    }\n}",
    "entry_point": "ConvertFahrenheitToCelsius",
    "signature": "static string ConvertFahrenheitToCelsius(double fahrenheitTemperature)",
    "docstring": {
      "en": "Converts a given Fahrenheit temperature to Celsius and returns the result as a string formatted to two decimal places.\n    The formula used is: Celsius = 5/9 * (Fahrenheit - 32).\n    Example usage:\n    >>> ConvertFahrenheitToCelsius(32)\n    \"c=0.00\"\n    >>> ConvertFahrenheitToCelsius(212)\n    \"c=100.00\"",
      "sq": "Konverton një temperaturë të dhënë në Fahrenheit në Celsius dhe kthen rezultatin si një varg i formatuar me dy vende dhjetore.\n    Formula e përdorur është: Celsius = 5/9 * (Fahrenheit - 32).\n    Shembull përdorimi:\n    >>> ConvertFahrenheitToCelsius(32)\n    \"c=0.00\"\n    >>> ConvertFahrenheitToCelsius(212)\n    \"c=100.00\"",
      "hy": "Փոխակերպում է տրված Ֆարենհայթի ջերմաստիճանը Ցելսիուսի և վերադարձնում արդյունքը որպես տող, ձևաչափված մինչև երկու տասնորդական նշան:\n    Օգտագործվող բանաձևն է՝ Ցելսիուս = 5/9 * (Ֆարենհայթ - 32):\n    Օգտագործման օրինակ:\n    >>> ConvertFahrenheitToCelsius(32)\n    \"c=0.00\"\n    >>> ConvertFahrenheitToCelsius(212)\n    \"c=100.00\"",
      "bn": "একটি প্রদত্ত ফারেনহাইট তাপমাত্রাকে সেলসিয়াসে রূপান্তর করে এবং ফলাফলটি একটি স্ট্রিং হিসাবে ফেরত দেয় যা দুই দশমিক স্থানে ফরম্যাট করা হয়। \n    ব্যবহৃত সূত্রটি হল: সেলসিয়াস = 5/9 * (ফারেনহাইট - 32)।\n    উদাহরণ ব্যবহার:\n    >>> ConvertFahrenheitToCelsius(32)\n    \"c=0.00\"\n    >>> ConvertFahrenheitToCelsius(212)\n    \"c=100.00\"",
      "bg": "Преобразува дадена температура във Фаренхайт в Целзий и връща резултата като низ, форматиран до два знака след десетичната запетая.\n    Формулата, която се използва, е: Целзий = 5/9 * (Фаренхайт - 32).\n    Пример за използване:\n    >>> ConvertFahrenheitToCelsius(32)\n    \"c=0.00\"\n    >>> ConvertFahrenheitToCelsius(212)\n    \"c=100.00\"",
      "zh": "将给定的华氏温度转换为摄氏温度，并将结果以格式化为两位小数的字符串返回。\n    使用的公式是：Celsius = 5/9 * (Fahrenheit - 32)。\n    示例用法：\n    >>> ConvertFahrenheitToCelsius(32)\n    \"c=0.00\"\n    >>> ConvertFahrenheitToCelsius(212)\n    \"c=100.00\"",
      "fr": "Convertit une température donnée en Fahrenheit en Celsius et renvoie le résultat sous forme de chaîne formatée à deux décimales.\n    La formule utilisée est : Celsius = 5/9 * (Fahrenheit - 32).\n    Exemple d'utilisation :\n    >>> ConvertFahrenheitToCelsius(32)\n    \"c=0.00\"\n    >>> ConvertFahrenheitToCelsius(212)\n    \"c=100.00\"",
      "de": "Konvertiert eine gegebene Fahrenheit-Temperatur in Celsius und gibt das Ergebnis als Zeichenfolge formatiert auf zwei Dezimalstellen zurück.\n    Die verwendete Formel ist: Celsius = 5/9 * (Fahrenheit - 32).\n    Beispielverwendung:\n    >>> ConvertFahrenheitToCelsius(32)\n    \"c=0.00\"\n    >>> ConvertFahrenheitToCelsius(212)\n    \"c=100.00\"",
      "ha": "Yana canza zazzabi na Fahrenheit da aka bayar zuwa Celsius kuma yana mayar da sakamakon a matsayin kirtani da aka tsara zuwa wurare biyu na goma.\n    Ana amfani da wannan dabara: Celsius = 5/9 * (Fahrenheit - 32).\n    Misalin amfani:\n    >>> ConvertFahrenheitToCelsius(32)\n    \"c=0.00\"\n    >>> ConvertFahrenheitToCelsius(212)\n    \"c=100.00\"",
      "hi": "दिए गए फ़ारेनहाइट तापमान को सेल्सियस में परिवर्तित करता है और परिणाम को दो दशमलव स्थानों तक स्वरूपित स्ट्रिंग के रूप में लौटाता है।  \n    उपयोग किया गया सूत्र है: Celsius = 5/9 * (Fahrenheit - 32)।  \n    उदाहरण उपयोग:  \n    >>> ConvertFahrenheitToCelsius(32)  \n    \"c=0.00\"  \n    >>> ConvertFahrenheitToCelsius(212)  \n    \"c=100.00\"  ",
      "hu": "Átalakít egy adott Fahrenheit hőmérsékletet Celsiusra, és visszaadja az eredményt két tizedesjegyre formázott sztringként.\n    Az alkalmazott képlet: Celsius = 5/9 * (Fahrenheit - 32).\n    Példa használat:\n    >>> ConvertFahrenheitToCelsius(32)\n    \"c=0.00\"\n    >>> ConvertFahrenheitToCelsius(212)\n    \"c=100.00\""
    },
    "docstring_bertscore": {
      "sq": "0.987258258317374",
      "hy": "0.992712449950211",
      "bn": "0.9917135377639865",
      "bg": "0.9934736015703367",
      "zh": "0.9895458844157528",
      "fr": "0.9859083662478609",
      "de": "0.9943638629381351",
      "ha": "0.9839929734835414",
      "hi": "0.9681146594539936",
      "hu": "0.9960305704653988"
    }
  },
  {
    "task_id": "C#/3",
    "prompt": {
      "en": "using System;\nusing System.Collections.Generic;\nusing System.Diagnostics;\n\nclass Program\n{\n   /*\n    Encodes the given string by shifting each letter by a specified number of places in the alphabet.\n    If the shift takes the letter beyond 'z', it wraps around to the beginning of the alphabet.\n    \n    Examples:\n    >>> EncodeString(\"apple\", 2)\n    \"crrng\"\n    \n    >>> EncodeString(\"hello\", 5)\n    \"mjqqt\"\n*/\n   static string EncodeString(string input, int shift)",
      "sq": "using System;\nusing System.Collections.Generic;\nusing System.Diagnostics;\n\nclass Program\n{\n   /*\n    Kodon vargun e dhënë duke zhvendosur secilën shkronjë me një numër të caktuar vendesh në alfabet.\n    Nëse zhvendosja e çon shkronjën përtej 'z', ajo kthehet në fillim të alfabetit.\n    \n    Shembuj:\n    >>> EncodeString(\"apple\", 2)\n    \"crrng\"\n    \n    >>> EncodeString(\"hello\", 5)\n    \"mjqqt\"\n*/\n   static string EncodeString(string input, int shift)",
      "hy": "using System;\nusing System.Collections.Generic;\nusing System.Diagnostics;\n\nclass Program\n{\n   /*\n    Տրված տողը կոդավորում է՝ այբուբենում յուրաքանչյուր տառը որոշակի քանակով տեղաշարժելով:\n    Եթե տեղաշարժը տառը տանում է 'z'-ից այն կողմ, այն վերադառնում է այբուբենի սկզբին:\n    \n    Օրինակներ:\n    >>> EncodeString(\"apple\", 2)\n    \"crrng\"\n    \n    >>> EncodeString(\"hello\", 5)\n    \"mjqqt\"\n*/\n   static string EncodeString(string input, int shift)",
      "bn": "using System;\nusing System.Collections.Generic;\nusing System.Diagnostics;\n\nclass Program\n{\n   /*\n    প্রদত্ত স্ট্রিংটি এনকোড করে প্রতিটি অক্ষরকে বর্ণমালায় নির্দিষ্ট সংখ্যক স্থান সরিয়ে।\n    যদি সরানোটি অক্ষরকে 'z' এর বাইরে নিয়ে যায়, তবে এটি বর্ণমালার শুরুতে ফিরে আসে।\n    \n    উদাহরণ:\n    >>> EncodeString(\"apple\", 2)\n    \"crrng\"\n    \n    >>> EncodeString(\"hello\", 5)\n    \"mjqqt\"\n*/\n   static string EncodeString(string input, int shift)",
      "bg": "using System;\nusing System.Collections.Generic;\nusing System.Diagnostics;\n\nclass Program\n{\n   /*\n    Кодира дадения низ, като измества всяка буква с определен брой места в азбуката.\n    Ако изместването отведе буквата отвъд 'z', то се връща в началото на азбуката.\n    \n    Примери:\n    >>> EncodeString(\"apple\", 2)\n    \"crrng\"\n    \n    >>> EncodeString(\"hello\", 5)\n    \"mjqqt\"\n*/\n   static string EncodeString(string input, int shift)",
      "zh": "using System;\nusing System.Collections.Generic;\nusing System.Diagnostics;\n\nclass Program\n{\n   /*\n    通过在字母表中将每个字母移动指定数量的位置来编码给定的字符串。\n    如果移动使字母超出 'z'，则从字母表的开头重新开始。\n    \n    例子:\n    >>> EncodeString(\"apple\", 2)\n    \"crrng\"\n    \n    >>> EncodeString(\"hello\", 5)\n    \"mjqqt\"\n*/\n   static string EncodeString(string input, int shift)",
      "fr": "using System;\nusing System.Collections.Generic;\nusing System.Diagnostics;\n\nclass Program\n{\n   /*\n    Encode la chaîne donnée en décalant chaque lettre d'un nombre spécifié de places dans l'alphabet.\n    Si le décalage dépasse 'z', il revient au début de l'alphabet.\n    \n    Exemples :\n    >>> EncodeString(\"apple\", 2)\n    \"crrng\"\n    \n    >>> EncodeString(\"hello\", 5)\n    \"mjqqt\"\n*/\n   static string EncodeString(string input, int shift)",
      "de": "using System;\nusing System.Collections.Generic;\nusing System.Diagnostics;\n\nclass Program\n{\n   /*\n    Kodiert den gegebenen String, indem jeder Buchstabe um eine angegebene Anzahl von Stellen im Alphabet verschoben wird.\n    Wenn die Verschiebung den Buchstaben über 'z' hinausführt, wird sie zum Anfang des Alphabets zurückgeführt.\n    \n    Beispiele:\n    >>> EncodeString(\"apple\", 2)\n    \"crrng\"\n    \n    >>> EncodeString(\"hello\", 5)\n    \"mjqqt\"\n*/\n   static string EncodeString(string input, int shift)",
      "ha": "using System;\nusing System.Collections.Generic;\nusing System.Diagnostics;\n\nclass Program\n{\n   /*\n    Yana loda kirtani da aka bayar ta hanyar matsar da kowane harafi da adadin wurare da aka kayyade a cikin haruffa.\n    Idan matsawar ta kai harafin bayan 'z', yana komawa zuwa farkon haruffa.\n    \n    Misalai:\n    >>> EncodeString(\"apple\", 2)\n    \"crrng\"\n    \n    >>> EncodeString(\"hello\", 5)\n    \"mjqqt\"\n*/\n   static string EncodeString(string input, int shift)",
      "hi": "using System;\nusing System.Collections.Generic;\nusing System.Diagnostics;\n\nclass Program\n{\n   /*\n    दिए गए स्ट्रिंग को वर्णमाला में निर्दिष्ट संख्या स्थानों द्वारा प्रत्येक अक्षर को शिफ्ट करके एन्कोड करता है।\n    यदि शिफ्ट अक्षर को 'z' से आगे ले जाता है, तो यह वर्णमाला की शुरुआत में लपेटता है।\n    \n    उदाहरण:\n    >>> EncodeString(\"apple\", 2)\n    \"crrng\"\n    \n    >>> EncodeString(\"hello\", 5)\n    \"mjqqt\"\n*/\n   static string EncodeString(string input, int shift)",
      "hu": "using System;\nusing System.Collections.Generic;\nusing System.Diagnostics;\n\nclass Program\n{\n   /*\n    Kódolja a megadott karakterláncot azáltal, hogy az ábécében minden betűt egy meghatározott számú hellyel eltol.\n    Ha az eltolás a betűt túlviszi a 'z'-n, akkor az ábécé elejére kerül vissza.\n    \n    Példák:\n    >>> EncodeString(\"apple\", 2)\n    \"crrng\"\n    \n    >>> EncodeString(\"hello\", 5)\n    \"mjqqt\"\n*/\n   static string EncodeString(string input, int shift)"
    },
    "prompt_bertscore": {
      "sq": "0.9934412248182279",
      "hy": "0.9911432699400353",
      "bn": "0.97749954769713",
      "bg": "0.9934412248182279",
      "zh": "0.9563424326611988",
      "fr": "0.9885020817634145",
      "de": "0.9929551762758356",
      "ha": "0.980073598804961",
      "hi": "0.9964600093491962",
      "hu": "0.9901254878676126"
    },
    "canonical_solution": "{\n    char[] encodedChars = new char[input.Length];\n    for (int i = 0; i < input.Length; i++)\n    {\n        char letter = input[i];\n        if (char.IsLetter(letter))\n        {\n            char baseChar = char.IsUpper(letter) ? 'A' : 'a';\n            encodedChars[i] = (char)(((letter + shift - baseChar) % 26) + baseChar);\n        }\n        else\n        {\n            encodedChars[i] = letter;\n        }\n    }\n    return new string(encodedChars);\n}",
    "instruction": {
      "en": "Write a C# function `static string EncodeString(string input, int shift)` to solve the following problem:\nEncodes the given string by shifting each letter by a specified number of places in the alphabet.\n    If the shift takes the letter beyond 'z', it wraps around to the beginning of the alphabet.\n    \n    Examples:\n    >>> EncodeString(\"apple\", 2)\n    \"crrng\"\n    \n    >>> EncodeString(\"hello\", 5)\n    \"mjqqt\"",
      "sq": "Shkruani një funksion në C# `static string EncodeString(string input, int shift)` për të zgjidhur problemin e mëposhtëm:\nKodifikon vargun e dhënë duke zhvendosur secilën shkronjë me një numër të caktuar vendesh në alfabet.\n    Nëse zhvendosja e çon shkronjën përtej 'z', ajo kthehet në fillim të alfabetit.\n    \n    Shembuj:\n    >>> EncodeString(\"apple\", 2)\n    \"crrng\"\n    \n    >>> EncodeString(\"hello\", 5)\n    \"mjqqt\"",
      "hy": "Գրեք C# ֆունկցիա `static string EncodeString(string input, int shift)` հետևյալ խնդիրը լուծելու համար:\nԿոդավորում է տրված տողը՝ այբուբենի յուրաքանչյուր տառը որոշակի քանակով տեղաշարժելով:\n    Եթե տեղաշարժը տառը տանում է 'z'-ից այն կողմ, այն շրջվում է այբուբենի սկզբին:\n    \n    Օրինակներ:\n    >>> EncodeString(\"apple\", 2)\n    \"crrng\"\n    \n    >>> EncodeString(\"hello\", 5)\n    \"mjqqt\"",
      "bn": "C# ফাংশন `static string EncodeString(string input, int shift)` লিখুন নিম্নলিখিত সমস্যার সমাধানের জন্য:\nপ্রদত্ত স্ট্রিং এনকোড করে প্রতিটি অক্ষরকে বর্ণমালায় নির্দিষ্ট সংখ্যক স্থান সরিয়ে।\n    যদি সরানোর ফলে অক্ষরটি 'z' এর বাইরে চলে যায়, তবে এটি বর্ণমালার শুরুতে ফিরে আসে।\n    \n    উদাহরণ:\n    >>> EncodeString(\"apple\", 2)\n    \"crrng\"\n    \n    >>> EncodeString(\"hello\", 5)\n    \"mjqqt\"",
      "bg": "Напишете C# функция `static string EncodeString(string input, int shift)` за решаване на следния проблем:\nКодира дадения низ, като измества всяка буква с определен брой позиции в азбуката.\n    Ако изместването премине отвъд 'z', то се завърта към началото на азбуката.\n    \n    Примери:\n    >>> EncodeString(\"apple\", 2)\n    \"crrng\"\n    \n    >>> EncodeString(\"hello\", 5)\n    \"mjqqt\"",
      "zh": "编写一个 C# 函数 `static string EncodeString(string input, int shift)` 来解决以下问题：\n对给定字符串进行编码，通过在字母表中将每个字母移动指定的位数来实现。\n如果移动使字母超出 'z'，则从字母表的开头重新开始。\n\n示例：\n>>> EncodeString(\"apple\", 2)\n\"crrng\"\n\n>>> EncodeString(\"hello\", 5)\n\"mjqqt\"",
      "fr": "Écrire une fonction C# `static string EncodeString(string input, int shift)` pour résoudre le problème suivant :\nEncode la chaîne donnée en décalant chaque lettre d'un nombre spécifié de places dans l'alphabet.\n    Si le décalage emmène la lettre au-delà de 'z', il revient au début de l'alphabet.\n    \n    Exemples :\n    >>> EncodeString(\"apple\", 2)\n    \"crrng\"\n    \n    >>> EncodeString(\"hello\", 5)\n    \"mjqqt\"",
      "de": "Schreiben Sie eine C#-Funktion `static string EncodeString(string input, int shift)`, um das folgende Problem zu lösen:  \nKodiert die gegebene Zeichenkette, indem jeder Buchstabe um eine angegebene Anzahl von Stellen im Alphabet verschoben wird.  \n    Wenn die Verschiebung den Buchstaben über 'z' hinausführt, wird sie am Anfang des Alphabets fortgesetzt.\n    \n    Beispiele:\n    >>> EncodeString(\"apple\", 2)\n    \"crrng\"\n    \n    >>> EncodeString(\"hello\", 5)\n    \"mjqqt\"",
      "ha": "Rubuta aikin C# `static string EncodeString(string input, int shift)` don warware matsalar mai zuwa:\nYana loda kirtani da aka bayar ta hanyar matsar da kowace harafi da adadin wurare da aka fayyace a cikin haruffa.\n    Idan matsawar ta kai harafin bayan 'z', yana komawa zuwa farkon haruffa.\n    \n    Misalai:\n    >>> EncodeString(\"apple\", 2)\n    \"crrng\"\n    \n    >>> EncodeString(\"hello\", 5)\n    \"mjqqt\"",
      "hi": "C# फ़ंक्शन `static string EncodeString(string input, int shift)` लिखें ताकि निम्नलिखित समस्या का समाधान किया जा सके:\nदिए गए स्ट्रिंग को एन्कोड करता है, प्रत्येक अक्षर को वर्णमाला में निर्दिष्ट संख्या स्थानों द्वारा शिफ्ट करके।\n    यदि शिफ्ट अक्षर को 'z' से आगे ले जाता है, तो यह वर्णमाला की शुरुआत में लपेटता है।\n    \n    उदाहरण:\n    >>> EncodeString(\"apple\", 2)\n    \"crrng\"\n    \n    >>> EncodeString(\"hello\", 5)\n    \"mjqqt\"",
      "hu": "Írj egy C# függvényt `static string EncodeString(string input, int shift)` a következő probléma megoldására:\nA megadott karakterláncot úgy kódolja, hogy az ábécében minden betűt egy meghatározott számú hellyel eltol.\n    Ha az eltolás a betűt 'z' utánra viszi, akkor visszatér az ábécé elejére.\n    \n    Példák:\n    >>> EncodeString(\"apple\", 2)\n    \"crrng\"\n    \n    >>> EncodeString(\"hello\", 5)\n    \"mjqqt\""
    },
    "instruction_bertscore": {
      "sq": "0.9947706579584945",
      "hy": "0.9739357214006019",
      "bn": "0.9479046140748367",
      "bg": "0.9851778037064146",
      "zh": "0.9574049065693544",
      "fr": "0.9935629852418024",
      "de": "0.9816968062787782",
      "ha": "0.9764104573179156",
      "hi": "0.9808834148684403",
      "hu": "0.9881421635129792"
    },
    "level": "middle",
    "test": "    static void Main()\n    {\n        Debug.Assert(EncodeString(\"China\", 4) == \"Glmre\");\n        Debug.Assert(EncodeString(\"apple\", 2) == \"crrng\");\n        Debug.Assert(EncodeString(\"hello\", 5) == \"mjqqt\");\n        Debug.Assert(EncodeString(\"xyz\", 3) == \"abc\");\n        Debug.Assert(EncodeString(\"AbCdE\", 1) == \"BcDeF\");\n        Debug.Assert(EncodeString(\"Java\", 10) == \"Tkfk\");\n        Debug.Assert(EncodeString(\"OpenAI\", 4) == \"StirEM\");\n        Debug.Assert(EncodeString(\"\", 5) == \"\");\n\n    }\n}\n",
    "entry_point": "EncodeString",
    "signature": "static string EncodeString(string input, int shift)",
    "docstring": {
      "en": "Encodes the given string by shifting each letter by a specified number of places in the alphabet.\n    If the shift takes the letter beyond 'z', it wraps around to the beginning of the alphabet.\n    \n    Examples:\n    >>> EncodeString(\"apple\", 2)\n    \"crrng\"\n    \n    >>> EncodeString(\"hello\", 5)\n    \"mjqqt\"",
      "sq": "Kodi fjalën e dhënë duke zhvendosur secilën shkronjë me një numër të caktuar vendesh në alfabet.\n    Nëse zhvendosja e çon shkronjën përtej 'z', ajo kthehet në fillim të alfabetit.\n    \n    Shembuj:\n    >>> EncodeString(\"apple\", 2)\n    \"crrng\"\n    \n    >>> EncodeString(\"hello\", 5)\n    \"mjqqt\"",
      "hy": "Տրված տողը կոդավորում է՝ այբուբենում յուրաքանչյուր տառը որոշակի քանակով տեղաշարժելով:\n    Եթե տեղաշարժը տառը տանում է 'z'-ից այն կողմ, այն փաթաթվում է այբուբենի սկզբին:\n    \n    Օրինակներ:\n    >>> EncodeString(\"apple\", 2)\n    \"crrng\"\n    \n    >>> EncodeString(\"hello\", 5)\n    \"mjqqt\"",
      "bn": "প্রদত্ত স্ট্রিং এনকোড করে প্রতিটি অক্ষরকে বর্ণমালায় নির্দিষ্ট সংখ্যক স্থানে সরিয়ে দেয়। \n    যদি সরানোটি অক্ষরকে 'z' এর বাইরে নিয়ে যায়, তবে এটি বর্ণমালার শুরুতে ফিরে আসে।\n    \n    উদাহরণ:\n    >>> EncodeString(\"apple\", 2)\n    \"crrng\"\n    \n    >>> EncodeString(\"hello\", 5)\n    \"mjqqt\"",
      "bg": "Кодира дадения низ, като измества всяка буква с определен брой позиции в азбуката. Ако изместването премине отвъд 'z', то се завърта в началото на азбуката.\n\nПримери:\n>>> EncodeString(\"apple\", 2)\n\"crrng\"\n\n>>> EncodeString(\"hello\", 5)\n\"mjqqt\"",
      "zh": "通过在字母表中将每个字母移动指定数量的位置来编码给定的字符串。\n    如果移动使字母超过'z'，则会回绕到字母表的开头。\n    \n    示例：\n    >>> EncodeString(\"apple\", 2)\n    \"crrng\"\n    \n    >>> EncodeString(\"hello\", 5)\n    \"mjqqt\"",
      "fr": "Encode la chaîne donnée en décalant chaque lettre d'un nombre spécifié de places dans l'alphabet. Si le décalage dépasse 'z', il revient au début de l'alphabet.\n\n    Exemples :\n    >>> EncodeString(\"apple\", 2)\n    \"crrng\"\n    \n    >>> EncodeString(\"hello\", 5)\n    \"mjqqt\"",
      "de": "Kodiert den gegebenen String, indem jeder Buchstabe um eine bestimmte Anzahl von Stellen im Alphabet verschoben wird. Wenn die Verschiebung den Buchstaben über 'z' hinausführt, wird sie zum Anfang des Alphabets zurückgesetzt.\n\nBeispiele:\n>>> EncodeString(\"apple\", 2)\n\"crrng\"\n\n>>> EncodeString(\"hello\", 5)\n\"mjqqt\"",
      "ha": "Encodes da aka bayar yana jujjuya kowane harafi ta hanyar da aka fayyace yawan wurare a cikin haruffa.\n    Idan jujjuyawar ta dauki harafin bayan 'z', yana komawa farkon haruffa.\n\n    Misalai:\n    >>> EncodeString(\"apple\", 2)\n    \"crrng\"\n    \n    >>> EncodeString(\"hello\", 5)\n    \"mjqqt\"",
      "hi": "दिए गए स्ट्रिंग को एन्कोड करता है प्रत्येक अक्षर को वर्णमाला में निर्दिष्ट संख्या स्थानों द्वारा स्थानांतरित करके।\n    यदि शिफ्ट अक्षर को 'z' से आगे ले जाता है, तो यह वर्णमाला की शुरुआत में लपेटता है।\n    \n    उदाहरण:\n    >>> EncodeString(\"apple\", 2)\n    \"crrng\"\n    \n    >>> EncodeString(\"hello\", 5)\n    \"mjqqt\"",
      "hu": "Kódolja a megadott sztringet azáltal, hogy az ábécében meghatározott számú helyet eltol minden betűn.\n    Ha az eltolás a betűt 'z' utánra viszi, akkor visszateker az ábécé elejére.\n    \n    Példák:\n    >>> EncodeString(\"apple\", 2)\n    \"crrng\"\n    \n    >>> EncodeString(\"hello\", 5)\n    \"mjqqt\""
    },
    "docstring_bertscore": {
      "sq": "0.9662733558218001",
      "hy": "0.9539850872990767",
      "bn": "0.9481886555197166",
      "bg": "0.9631872355916611",
      "zh": "0.9439484927757649",
      "fr": "0.9298268658360895",
      "de": "0.9893546033588162",
      "ha": "0.9426571966686571",
      "hi": "0.9727048089293288",
      "hu": "0.9795641118776066"
    }
  },
  {
    "task_id": "C#/4",
    "prompt": {
      "en": "using System;\nusing System.Collections.Generic;\nusing System.Diagnostics;\n\nclass Program\n{\n/* Computes a value based on the input x according to specified linear functions.\n   The function applies different formulas based on the value of x:\n   - For x less than 1, returns x.\n   - For x between 1 and 10, returns 2x - 1.\n   - For x greater than or equal to 10, returns 3x - 11.\n   Example cases:\n   >>> ComputeValue(0.5)\n   0.5\n   >>> ComputeValue(5)\n   9\n   >>> ComputeValue(10)\n   19\n*/\nstatic double ComputeValue(double x)",
      "sq": "using System;\nusing System.Collections.Generic;\nusing System.Diagnostics;\n\nclass Program\n{\n/* Llogarit një vlerë bazuar në hyrjen x sipas funksioneve lineare të specifikuara.\n   Funksioni zbaton formula të ndryshme bazuar në vlerën e x:\n   - Për x më pak se 1, kthen x.\n   - Për x midis 1 dhe 10, kthen 2x - 1.\n   - Për x më të madh ose të barabartë me 10, kthen 3x - 11.\n   Shembuj rastesh:\n   >>> ComputeValue(0.5)\n   0.5\n   >>> ComputeValue(5)\n   9\n   >>> ComputeValue(10)\n   19\n*/\nstatic double ComputeValue(double x)",
      "hy": "using System;\nusing System.Collections.Generic;\nusing System.Diagnostics;\n\nclass Program\n{\n/* Հաշվում է արժեքը մուտքագրված x-ի հիման վրա՝ ըստ նշված գծային ֆունկցիաների:\n   Ֆունկցիան կիրառում է տարբեր բանաձևեր՝ հիմնված x-ի արժեքի վրա.\n   - Եթե x-ն փոքր է 1-ից, վերադարձնում է x:\n   - Եթե x-ն 1-ից և 10-ից միջև է, վերադարձնում է 2x - 1:\n   - Եթե x-ն մեծ կամ հավասար է 10-ին, վերադարձնում է 3x - 11:\n   Օրինակ դեպքեր:\n   >>> ComputeValue(0.5)\n   0.5\n   >>> ComputeValue(5)\n   9\n   >>> ComputeValue(10)\n   19\n*/\nstatic double ComputeValue(double x)",
      "bn": "using System;\nusing System.Collections.Generic;\nusing System.Diagnostics;\n\nclass Program\n{\n/* নির্দিষ্ট লিনিয়ার ফাংশন অনুযায়ী ইনপুট x এর উপর ভিত্তি করে একটি মান গণনা করে।\n   ফাংশনটি x এর মানের উপর ভিত্তি করে বিভিন্ন সূত্র প্রয়োগ করে:\n   - x যদি 1 এর কম হয়, তাহলে x ফেরত দেয়।\n   - x যদি 1 এবং 10 এর মধ্যে হয়, তাহলে 2x - 1 ফেরত দেয়।\n   - x যদি 10 এর সমান বা তার বেশি হয়, তাহলে 3x - 11 ফেরত দেয়।\n   উদাহরণ কেস:\n   >>> ComputeValue(0.5)\n   0.5\n   >>> ComputeValue(5)\n   9\n   >>> ComputeValue(10)\n   19\n*/\nstatic double ComputeValue(double x)",
      "bg": "using System;\nusing System.Collections.Generic;\nusing System.Diagnostics;\n\nclass Program\n{\n/* Изчислява стойност на базата на входа x според зададените линейни функции.\n   Функцията прилага различни формули в зависимост от стойността на x:\n   - За x по-малко от 1, връща x.\n   - За x между 1 и 10, връща 2x - 1.\n   - За x по-голямо или равно на 10, връща 3x - 11.\n   Примерни случаи:\n   >>> ComputeValue(0.5)\n   0.5\n   >>> ComputeValue(5)\n   9\n   >>> ComputeValue(10)\n   19\n*/\nstatic double ComputeValue(double x)",
      "zh": "using System;\nusing System.Collections.Generic;\nusing System.Diagnostics;\n\nclass Program\n{\n/* 根据指定的线性函数根据输入 x 计算一个值。\n   该函数根据 x 的值应用不同的公式：\n   - 对于小于 1 的 x，返回 x。\n   - 对于 1 到 10 之间的 x，返回 2x - 1。\n   - 对于大于或等于 10 的 x，返回 3x - 11。\n   示例案例：\n   >>> ComputeValue(0.5)\n   0.5\n   >>> ComputeValue(5)\n   9\n   >>> ComputeValue(10)\n   19\n*/\nstatic double ComputeValue(double x)",
      "fr": "using System;\nusing System.Collections.Generic;\nusing System.Diagnostics;\n\nclass Program\n{\n/* Calcule une valeur basée sur l'entrée x selon des fonctions linéaires spécifiées.\n   La fonction applique différentes formules en fonction de la valeur de x :\n   - Pour x inférieur à 1, retourne x.\n   - Pour x entre 1 et 10, retourne 2x - 1.\n   - Pour x supérieur ou égal à 10, retourne 3x - 11.\n   Cas d'exemple :\n   >>> ComputeValue(0.5)\n   0.5\n   >>> ComputeValue(5)\n   9\n   >>> ComputeValue(10)\n   19\n*/\nstatic double ComputeValue(double x)",
      "de": "using System;\nusing System.Collections.Generic;\nusing System.Diagnostics;\n\nclass Program\n{\n/* Berechnet einen Wert basierend auf der Eingabe x gemäß den angegebenen linearen Funktionen.\n   Die Funktion wendet je nach Wert von x unterschiedliche Formeln an:\n   - Für x kleiner als 1, gibt x zurück.\n   - Für x zwischen 1 und 10, gibt 2x - 1 zurück.\n   - Für x größer oder gleich 10, gibt 3x - 11 zurück.\n   Beispielhafte Fälle:\n   >>> ComputeValue(0.5)\n   0.5\n   >>> ComputeValue(5)\n   9\n   >>> ComputeValue(10)\n   19\n*/\nstatic double ComputeValue(double x)",
      "ha": "using System;\nusing System.Collections.Generic;\nusing System.Diagnostics;\n\nclass Program\n{\n/* Lissafi wani ƙima bisa ga shigarwa x bisa ga takamaiman ayyukan layi.\n   Aikin yana amfani da daban-daban dabaru bisa ga ƙimar x:\n   - Ga x ƙasa da 1, yana mayar da x.\n   - Ga x tsakanin 1 da 10, yana mayar da 2x - 1.\n   - Ga x mafi girma ko daidai da 10, yana mayar da 3x - 11.\n   Misalan lokuta:\n   >>> ComputeValue(0.5)\n   0.5\n   >>> ComputeValue(5)\n   9\n   >>> ComputeValue(10)\n   19\n*/\nstatic double ComputeValue(double x)",
      "hi": "using System;\nusing System.Collections.Generic;\nusing System.Diagnostics;\n\nclass Program\n{\n/* इनपुट x के आधार पर निर्दिष्ट रैखिक कार्यों के अनुसार एक मान की गणना करता है।\n   यह फ़ंक्शन x के मान के आधार पर विभिन्न सूत्र लागू करता है:\n   - x के लिए जो 1 से कम है, x लौटाता है।\n   - x के लिए जो 1 और 10 के बीच है, 2x - 1 लौटाता है।\n   - x के लिए जो 10 के बराबर या उससे अधिक है, 3x - 11 लौटाता है।\n   उदाहरण मामले:\n   >>> ComputeValue(0.5)\n   0.5\n   >>> ComputeValue(5)\n   9\n   >>> ComputeValue(10)\n   19\n*/\nstatic double ComputeValue(double x)",
      "hu": "using System;\nusing System.Collections.Generic;\nusing System.Diagnostics;\n\nclass Program\n{\n/* Értéket számít a bemeneti x alapján a megadott lineáris függvények szerint.\n   A függvény különböző képleteket alkalmaz x értékétől függően:\n   - Ha x kisebb, mint 1, akkor x-et ad vissza.\n   - Ha x 1 és 10 között van, akkor 2x - 1-et ad vissza.\n   - Ha x nagyobb vagy egyenlő, mint 10, akkor 3x - 11-et ad vissza.\n   Példa esetek:\n   >>> ComputeValue(0.5)\n   0.5\n   >>> ComputeValue(5)\n   9\n   >>> ComputeValue(10)\n   19\n*/\nstatic double ComputeValue(double x)"
    },
    "prompt_bertscore": {
      "sq": "0.9931265942946688",
      "hy": "0.9587261958639985",
      "bn": "0.9644713810050516",
      "bg": "0.9874088201461985",
      "zh": "0.9810141136591612",
      "fr": "0.9919185243172145",
      "de": "0.9902774401091043",
      "ha": "0.9692009690078733",
      "hi": "0.9820855259344634",
      "hu": "0.9693995993889082"
    },
    "canonical_solution": "{\n    if (x < 1)\n    {\n        return x;\n    }\n    else if (x < 10)\n    {\n        return 2 * x - 1;\n    }\n    else\n    {\n        return 3 * x - 11;\n    }\n}",
    "instruction": {
      "en": "Write a C# function `static double ComputeValue(double x)` to solve the following problem:\nComputes a value based on the input x according to specified linear functions.\n   The function applies different formulas based on the value of x:\n   - For x less than 1, returns x.\n   - For x between 1 and 10, returns 2x - 1.\n   - For x greater than or equal to 10, returns 3x - 11.\n   Example cases:\n   >>> ComputeValue(0.5)\n   0.5\n   >>> ComputeValue(5)\n   9\n   >>> ComputeValue(10)\n   19",
      "sq": "Shkruani një funksion në C# `static double ComputeValue(double x)` për të zgjidhur problemin e mëposhtëm:\nLlogarit një vlerë bazuar në hyrjen x sipas funksioneve lineare të specifikuara.\n   Funksioni aplikon formula të ndryshme bazuar në vlerën e x:\n   - Për x më pak se 1, kthen x.\n   - Për x midis 1 dhe 10, kthen 2x - 1.\n   - Për x më të madh ose të barabartë me 10, kthen 3x - 11.\n   Shembuj të rasteve:\n   >>> ComputeValue(0.5)\n   0.5\n   >>> ComputeValue(5)\n   9\n   >>> ComputeValue(10)\n   19",
      "hy": "Գրեք C# ֆունկցիա `static double ComputeValue(double x)` լուծելու համար հետևյալ խնդիրը:\nՀաշվում է արժեքը x մուտքի հիման վրա ըստ նշված գծային ֆունկցիաների:\n   Ֆունկցիան կիրառվում է տարբեր բանաձևեր x-ի արժեքի հիման վրա:\n   - Եթե x-ն փոքր է 1-ից, վերադարձնում է x:\n   - Եթե x-ն գտնվում է 1-ից 10 միջակայքում, վերադարձնում է 2x - 1:\n   - Եթե x-ն մեծ կամ հավասար է 10-ին, վերադարձնում է 3x - 11:\n   Օրինակային դեպքեր:\n   >>> ComputeValue(0.5)\n   0.5\n   >>> ComputeValue(5)\n   9\n   >>> ComputeValue(10)\n   19",
      "bn": "C# ফাংশন `static double ComputeValue(double x)` লিখুন নিম্নলিখিত সমস্যার সমাধানের জন্য:\nনির্দিষ্ট রৈখিক ফাংশন অনুযায়ী ইনপুট x এর উপর ভিত্তি করে একটি মান গণনা করে।\n   ফাংশনটি x এর মানের উপর ভিত্তি করে বিভিন্ন সূত্র প্রয়োগ করে:\n   - x যদি 1 এর চেয়ে কম হয়, তাহলে x ফেরত দেয়।\n   - x যদি 1 এবং 10 এর মধ্যে হয়, তাহলে 2x - 1 ফেরত দেয়।\n   - x যদি 10 এর সমান বা তার চেয়ে বড় হয়, তাহলে 3x - 11 ফেরত দেয়।\n   উদাহরণ কেস:\n   >>> ComputeValue(0.5)\n   0.5\n   >>> ComputeValue(5)\n   9\n   >>> ComputeValue(10)\n   19",
      "bg": "Напишете C# функция `static double ComputeValue(double x)`, за да решите следния проблем:\nИзчислява стойност на базата на входа x според определени линейни функции.\n   Функцията прилага различни формули в зависимост от стойността на x:\n   - За x по-малко от 1, връща x.\n   - За x между 1 и 10, връща 2x - 1.\n   - За x по-голямо или равно на 10, връща 3x - 11.\n   Примерни случаи:\n   >>> ComputeValue(0.5)\n   0.5\n   >>> ComputeValue(5)\n   9\n   >>> ComputeValue(10)\n   19",
      "zh": "编写一个 C# 函数 `static double ComputeValue(double x)` 来解决以下问题：\n根据指定的线性函数计算基于输入 x 的值。\n函数根据 x 的值应用不同的公式：\n- 对于 x 小于 1，返回 x。\n- 对于 x 在 1 和 10 之间，返回 2x - 1。\n- 对于 x 大于或等于 10，返回 3x - 11。\n示例案例：\n>>> ComputeValue(0.5)\n0.5\n>>> ComputeValue(5)\n9\n>>> ComputeValue(10)\n19",
      "fr": "Écrire une fonction C# `static double ComputeValue(double x)` pour résoudre le problème suivant :\nCalcule une valeur basée sur l'entrée x selon des fonctions linéaires spécifiées.\n   La fonction applique différentes formules en fonction de la valeur de x :\n   - Pour x inférieur à 1, retourne x.\n   - Pour x entre 1 et 10, retourne 2x - 1.\n   - Pour x supérieur ou égal à 10, retourne 3x - 11.\n   Cas d'exemple :\n   >>> ComputeValue(0.5)\n   0.5\n   >>> ComputeValue(5)\n   9\n   >>> ComputeValue(10)\n   19",
      "de": "Schreiben Sie eine C#-Funktion `static double ComputeValue(double x)`, um das folgende Problem zu lösen:\nBerechnet einen Wert basierend auf der Eingabe x gemäß den angegebenen linearen Funktionen.\n   Die Funktion wendet je nach Wert von x unterschiedliche Formeln an:\n   - Für x kleiner als 1, gibt x zurück.\n   - Für x zwischen 1 und 10, gibt 2x - 1 zurück.\n   - Für x größer oder gleich 10, gibt 3x - 11 zurück.\n   Beispielhafte Fälle:\n   >>> ComputeValue(0.5)\n   0.5\n   >>> ComputeValue(5)\n   9\n   >>> ComputeValue(10)\n   19",
      "ha": "Rubuta aikin C# `static double ComputeValue(double x)` don warware matsalar mai zuwa:\n   Lissafi darajar bisa ga shigarwar x bisa ga takamaiman ayyukan layi.\n   Aikin yana amfani da daban-daban dabaru bisa ga darajar x:\n   - Don x ƙasa da 1, yana mayar da x.\n   - Don x tsakanin 1 da 10, yana mayar da 2x - 1.\n   - Don x mafi girma ko daidai da 10, yana mayar da 3x - 11.\n   Misalan lokuta:\n   >>> ComputeValue(0.5)\n   0.5\n   >>> ComputeValue(5)\n   9\n   >>> ComputeValue(10)\n   19",
      "hi": "C# फ़ंक्शन `static double ComputeValue(double x)` लिखें ताकि निम्नलिखित समस्या का समाधान किया जा सके:\nनिर्दिष्ट रैखिक फ़ंक्शनों के अनुसार इनपुट x के आधार पर एक मान की गणना करता है।\n   फ़ंक्शन x के मान के आधार पर विभिन्न सूत्र लागू करता है:\n   - x के लिए जो 1 से कम है, x लौटाता है।\n   - x के लिए जो 1 और 10 के बीच है, 2x - 1 लौटाता है।\n   - x के लिए जो 10 के बराबर या उससे अधिक है, 3x - 11 लौटाता है।\n   उदाहरण मामले:\n   >>> ComputeValue(0.5)\n   0.5\n   >>> ComputeValue(5)\n   9\n   >>> ComputeValue(10)\n   19",
      "hu": "Írj egy C# függvényt `static double ComputeValue(double x)` a következő probléma megoldására:\nSzámít egy értéket az x bemenet alapján a megadott lineáris függvények szerint.\n   A függvény különböző képleteket alkalmaz az x értékétől függően:\n   - Ha x kisebb, mint 1, akkor x-et ad vissza.\n   - Ha x 1 és 10 között van, akkor 2x - 1-et ad vissza.\n   - Ha x nagyobb vagy egyenlő, mint 10, akkor 3x - 11-et ad vissza.\n   Példa esetek:\n   >>> ComputeValue(0.5)\n   0.5\n   >>> ComputeValue(5)\n   9\n   >>> ComputeValue(10)\n   19"
    },
    "instruction_bertscore": {
      "sq": "0.9823008412675053",
      "hy": "0.9640169146932438",
      "bn": "0.9628668447870518",
      "bg": "0.989393336283118",
      "zh": "0.9833948974062454",
      "fr": "0.9873526077483655",
      "de": "0.9872272719779326",
      "ha": "0.9614821924008576",
      "hi": "0.9613103771212624",
      "hu": "0.9617715968660254"
    },
    "level": "easy",
    "test": "    static void Main()\n    {\n        Debug.Assert(ComputeValue(0.5) == 0.5);\n        Debug.Assert(ComputeValue(2) == 3);\n        Debug.Assert(ComputeValue(5) == 9);\n        Debug.Assert(ComputeValue(10) == 19);\n        Debug.Assert(ComputeValue(15) == 34);\n        Debug.Assert(ComputeValue(0) == 0);\n        Debug.Assert(ComputeValue(1) == 1);\n\n    }\n}",
    "entry_point": "ComputeValue",
    "signature": "static double ComputeValue(double x)",
    "docstring": {
      "en": "Computes a value based on the input x according to specified linear functions.\n   The function applies different formulas based on the value of x:\n   - For x less than 1, returns x.\n   - For x between 1 and 10, returns 2x - 1.\n   - For x greater than or equal to 10, returns 3x - 11.\n   Example cases:\n   >>> ComputeValue(0.5)\n   0.5\n   >>> ComputeValue(5)\n   9\n   >>> ComputeValue(10)\n   19",
      "sq": "Llogarit një vlerë bazuar në hyrjen x sipas funksioneve lineare të specifikuara. Funksioni zbaton formula të ndryshme bazuar në vlerën e x: - Për x më pak se 1, kthen x. - Për x midis 1 dhe 10, kthen 2x - 1. - Për x më të madh ose të barabartë me 10, kthen 3x - 11. Rastet e shembullit: >>> ComputeValue(0.5) 0.5 >>> ComputeValue(5) 9 >>> ComputeValue(10) 19",
      "hy": "Հաշվում է արժեքը մուտքային x-ի հիման վրա՝ համաձայն որոշված գծային ֆունկցիաների: \n   Ֆունկցիան կիրառում է տարբեր բանաձևեր՝ հիմնված x-ի արժեքի վրա:\n   - Եթե x-ն փոքր է 1-ից, վերադարձնում է x:\n   - Եթե x-ն գտնվում է 1 և 10 միջակայքում, վերադարձնում է 2x - 1:\n   - Եթե x-ն մեծ կամ հավասար է 10-ին, վերադարձնում է 3x - 11:\n   Օրինակային դեպքեր:\n   >>> ComputeValue(0.5)\n   0.5\n   >>> ComputeValue(5)\n   9\n   >>> ComputeValue(10)\n   19",
      "bn": "একটি নির্দিষ্ট রৈখিক ফাংশন অনুযায়ী ইনপুট x এর উপর ভিত্তি করে একটি মান গণনা করে।\n   ফাংশনটি x এর মানের উপর ভিত্তি করে বিভিন্ন সূত্র প্রয়োগ করে:\n   - x যদি 1 এর চেয়ে কম হয়, তাহলে x ফেরত দেয়।\n   - x যদি 1 এবং 10 এর মধ্যে হয়, তাহলে 2x - 1 ফেরত দেয়।\n   - x যদি 10 এর সমান বা তার চেয়ে বড় হয়, তাহলে 3x - 11 ফেরত দেয়।\n   উদাহরণ কেস:\n   >>> ComputeValue(0.5)\n   0.5\n   >>> ComputeValue(5)\n   9\n   >>> ComputeValue(10)\n   19",
      "bg": "Изчислява стойност на базата на входа x според определени линейни функции. \n   Функцията прилага различни формули в зависимост от стойността на x:\n   - За x по-малко от 1, връща x.\n   - За x между 1 и 10, връща 2x - 1.\n   - За x по-голямо или равно на 10, връща 3x - 11.\n   Примерни случаи:\n   >>> ComputeValue(0.5)\n   0.5\n   >>> ComputeValue(5)\n   9\n   >>> ComputeValue(10)\n   19",
      "zh": "根据指定的线性函数根据输入 x 计算一个值。\n   该函数根据 x 的值应用不同的公式：\n   - 对于 x 小于 1，返回 x。\n   - 对于 x 在 1 和 10 之间，返回 2x - 1。\n   - 对于 x 大于或等于 10，返回 3x - 11。\n   示例案例：\n   >>> ComputeValue(0.5)\n   0.5\n   >>> ComputeValue(5)\n   9\n   >>> ComputeValue(10)\n   19",
      "fr": "Calcule une valeur basée sur l'entrée x selon des fonctions linéaires spécifiées.\n   La fonction applique différentes formules en fonction de la valeur de x :\n   - Pour x inférieur à 1, retourne x.\n   - Pour x entre 1 et 10, retourne 2x - 1.\n   - Pour x supérieur ou égal à 10, retourne 3x - 11.\n   Cas d'exemple :\n   >>> ComputeValue(0.5)\n   0.5\n   >>> ComputeValue(5)\n   9\n   >>> ComputeValue(10)\n   19",
      "de": "Berechnet einen Wert basierend auf der Eingabe x gemäß den angegebenen linearen Funktionen.\n   Die Funktion wendet unterschiedliche Formeln basierend auf dem Wert von x an:\n   - Für x kleiner als 1, wird x zurückgegeben.\n   - Für x zwischen 1 und 10, wird 2x - 1 zurückgegeben.\n   - Für x größer oder gleich 10, wird 3x - 11 zurückgegeben.\n   Beispielhafte Fälle:\n   >>> ComputeValue(0.5)\n   0.5\n   >>> ComputeValue(5)\n   9\n   >>> ComputeValue(10)\n   19",
      "ha": "Yana lissafin wata kima bisa ga shigar x bisa ga takamaiman ayyukan layi.\n   Aikin yana amfani da daban-daban ka'idoji bisa ga kima ta x:\n   - Don x kasa da 1, yana dawowa da x.\n   - Don x tsakanin 1 da 10, yana dawowa da 2x - 1.\n   - Don x mafi girma ko dai dai da 10, yana dawowa da 3x - 11.\n   Misalan lokuta:\n   >>> ComputeValue(0.5)\n   0.5\n   >>> ComputeValue(5)\n   9\n   >>> ComputeValue(10)\n   19",
      "hi": "इनपुट x के आधार पर निर्दिष्ट रैखिक कार्यों के अनुसार एक मान की गणना करता है। \n   फ़ंक्शन x के मान के आधार पर विभिन्न सूत्र लागू करता है:\n   - x के 1 से कम होने पर, x लौटाता है।\n   - x के 1 और 10 के बीच होने पर, 2x - 1 लौटाता है।\n   - x के 10 या उससे अधिक होने पर, 3x - 11 लौटाता है।\n   उदाहरण मामले:\n   >>> ComputeValue(0.5)\n   0.5\n   >>> ComputeValue(5)\n   9\n   >>> ComputeValue(10)\n   19",
      "hu": "Számít egy értéket az x bemenet alapján a megadott lineáris függvények szerint.\n   A függvény különböző képleteket alkalmaz az x értékétől függően:\n   - Ha x kisebb, mint 1, visszaadja x-et.\n   - Ha x 1 és 10 között van, visszaadja 2x - 1-et.\n   - Ha x nagyobb vagy egyenlő, mint 10, visszaadja 3x - 11-et.\n   Példa esetek:\n   >>> ComputeValue(0.5)\n   0.5\n   >>> ComputeValue(5)\n   9\n   >>> ComputeValue(10)\n   19"
    },
    "docstring_bertscore": {
      "sq": "0.9868778811376921",
      "hy": "0.9507418504375391",
      "bn": "0.9501125893904205",
      "bg": "0.9831539587540501",
      "zh": "0.9721389109737604",
      "fr": "0.982669300624325",
      "de": "0.96471867582944",
      "ha": "0.9617702064533582",
      "hi": "0.928708179530101",
      "hu": "0.952762715934188"
    }
  },
  {
    "task_id": "C#/5",
    "prompt": {
      "en": "using System;\nusing System.Collections.Generic;\nusing System.Diagnostics;\n\nclass Program\n{\n/* This function finds all narcissistic numbers within a given range.\n   A narcissistic number is a number that is the sum of its own digits each raised to the power of the number of digits.\n   For example, 153 is a narcissistic number because 153 = 1^3 + 5^3 + 3^3.\n   \n   Examples:\n   >>> FindNarcissisticNumbers(100, 170)\n   [153]\n   >>> FindNarcissisticNumbers(100, 500)\n   [153, 370, 371, 407]\n*/\n   static List<int> FindNarcissisticNumbers(int start, int end)",
      "sq": "using System;\nusing System.Collections.Generic;\nusing System.Diagnostics;\n\nclass Program\n{\n/* Kjo funksion gjen të gjitha numrat narcisistë brenda një intervali të dhënë.\n   Një numër narcisist është një numër që është shuma e vetë shifrave të tij, secila e ngritur në fuqinë e numrit të shifrave.\n   Për shembull, 153 është një numër narcisist sepse 153 = 1^3 + 5^3 + 3^3.\n   \n   Shembuj:\n   >>> FindNarcissisticNumbers(100, 170)\n   [153]\n   >>> FindNarcissisticNumbers(100, 500)\n   [153, 370, 371, 407]\n*/\n   static List<int> FindNarcissisticNumbers(int start, int end)",
      "hy": "using System;\nusing System.Collections.Generic;\nusing System.Diagnostics;\n\nclass Program\n{\n/* Այս ֆունկցիան գտնում է բոլոր նարցիսիստական թվերը տրված միջակայքում:\n   Նարցիսիստական թիվը թիվ է, որը հավասար է իր թվանշանների գումարին, որոնցից յուրաքանչյուրը բարձրացված է թվանշանների քանակի աստիճանի:\n   Օրինակ, 153-ը նարցիսիստական թիվ է, որովհետև 153 = 1^3 + 5^3 + 3^3:\n   \n   Օրինակներ:\n   >>> FindNarcissisticNumbers(100, 170)\n   [153]\n   >>> FindNarcissisticNumbers(100, 500)\n   [153, 370, 371, 407]\n*/\n   static List<int> FindNarcissisticNumbers(int start, int end)",
      "bn": "using System;\nusing System.Collections.Generic;\nusing System.Diagnostics;\n\nclass Program\n{\n/* এই ফাংশনটি একটি নির্দিষ্ট সীমার মধ্যে সমস্ত নার্সিসিস্টিক সংখ্যা খুঁজে বের করে।\n   একটি নার্সিসিস্টিক সংখ্যা হল এমন একটি সংখ্যা যা তার নিজস্ব অঙ্কগুলোর যোগফল, প্রতিটি অঙ্কের সংখ্যা অনুযায়ী ঘাতসংখ্যায়িত।\n   উদাহরণস্বরূপ, 153 একটি নার্সিসিস্টিক সংখ্যা কারণ 153 = 1^3 + 5^3 + 3^3।\n   \n   উদাহরণসমূহ:\n   >>> FindNarcissisticNumbers(100, 170)\n   [153]\n   >>> FindNarcissisticNumbers(100, 500)\n   [153, 370, 371, 407]\n*/\n   static List<int> FindNarcissisticNumbers(int start, int end)",
      "bg": "using System;\nusing System.Collections.Generic;\nusing System.Diagnostics;\n\nclass Program\n{\n/* Тази функция намира всички нарцистични числа в даден диапазон.\n   Нарцистично число е число, което е сумата от своите собствени цифри, всяка повдигната на степента на броя на цифрите.\n   Например, 153 е нарцистично число, защото 153 = 1^3 + 5^3 + 3^3.\n   \n   Примери:\n   >>> FindNarcissisticNumbers(100, 170)\n   [153]\n   >>> FindNarcissisticNumbers(100, 500)\n   [153, 370, 371, 407]\n*/\n   static List<int> FindNarcissisticNumbers(int start, int end)",
      "zh": "using System;\nusing System.Collections.Generic;\nusing System.Diagnostics;\n\nclass Program\n{\n/* 此函数在给定范围内查找所有水仙花数。\n   水仙花数是指其自身数字的每个数字的幂次之和等于该数字的数字。\n   例如，153 是一个水仙花数，因为 153 = 1^3 + 5^3 + 3^3。\n   \n   示例:\n   >>> FindNarcissisticNumbers(100, 170)\n   [153]\n   >>> FindNarcissisticNumbers(100, 500)\n   [153, 370, 371, 407]\n*/\n   static List<int> FindNarcissisticNumbers(int start, int end)",
      "fr": "using System;\nusing System.Collections.Generic;\nusing System.Diagnostics;\n\nclass Program\n{\n/* Cette fonction trouve tous les nombres narcissiques dans une plage donnée.\n   Un nombre narcissique est un nombre qui est la somme de ses propres chiffres chacun élevé à la puissance du nombre de chiffres.\n   Par exemple, 153 est un nombre narcissique car 153 = 1^3 + 5^3 + 3^3.\n   \n   Exemples :\n   >>> FindNarcissisticNumbers(100, 170)\n   [153]\n   >>> FindNarcissisticNumbers(100, 500)\n   [153, 370, 371, 407]\n*/\n   static List<int> FindNarcissisticNumbers(int start, int end)",
      "de": "using System;\nusing System.Collections.Generic;\nusing System.Diagnostics;\n\nclass Program\n{\n/* Diese Funktion findet alle narzisstischen Zahlen innerhalb eines gegebenen Bereichs.\n   Eine narzisstische Zahl ist eine Zahl, die die Summe ihrer eigenen Ziffern ist, wobei jede Ziffer auf die Potenz der Anzahl der Ziffern erhoben wird.\n   Zum Beispiel ist 153 eine narzisstische Zahl, weil 153 = 1^3 + 5^3 + 3^3.\n   \n   Beispiele:\n   >>> FindNarcissisticNumbers(100, 170)\n   [153]\n   >>> FindNarcissisticNumbers(100, 500)\n   [153, 370, 371, 407]\n*/\n   static List<int> FindNarcissisticNumbers(int start, int end)",
      "ha": "using System;\nusing System.Collections.Generic;\nusing System.Diagnostics;\n\nclass Program\n{\n/* Wannan aiki yana nemo duk lambobin narcissistic a cikin kewayon da aka bayar.\n   Lambar narcissistic ita ce lamba wadda ta kasance jumlar lambobinta na kansu kowanne an ɗaga shi zuwa ƙarfin yawan lambobin.\n   Alal misali, 153 lamba ce ta narcissistic saboda 153 = 1^3 + 5^3 + 3^3.\n   \n   Misalai:\n   >>> FindNarcissisticNumbers(100, 170)\n   [153]\n   >>> FindNarcissisticNumbers(100, 500)\n   [153, 370, 371, 407]\n*/\n   static List<int> FindNarcissisticNumbers(int start, int end)",
      "hi": "using System;\nusing System.Collections.Generic;\nusing System.Diagnostics;\n\nclass Program\n{\n/* यह फ़ंक्शन एक दिए गए सीमा के भीतर सभी नार्सिसिस्टिक संख्याएँ खोजता है।\n   एक नार्सिसिस्टिक संख्या वह संख्या होती है जो अपने स्वयं के अंकों का योग होती है, प्रत्येक अंक को अंकों की संख्या की शक्ति तक उठाया जाता है।\n   उदाहरण के लिए, 153 एक नार्सिसिस्टिक संख्या है क्योंकि 153 = 1^3 + 5^3 + 3^3 है।\n   \n   उदाहरण:\n   >>> FindNarcissisticNumbers(100, 170)\n   [153]\n   >>> FindNarcissisticNumbers(100, 500)\n   [153, 370, 371, 407]\n*/\n   static List<int> FindNarcissisticNumbers(int start, int end)",
      "hu": "using System;\nusing System.Collections.Generic;\nusing System.Diagnostics;\n\nclass Program\n{\n/* Ez a függvény megtalálja az összes nárcisztikus számot egy adott tartományon belül.\n   Egy nárcisztikus szám olyan szám, amely saját számjegyeinek összegével egyenlő, ahol minden számjegy a számjegyek számának hatványára van emelve.\n   Például, a 153 egy nárcisztikus szám, mert 153 = 1^3 + 5^3 + 3^3.\n   \n   Példák:\n   >>> FindNarcissisticNumbers(100, 170)\n   [153]\n   >>> FindNarcissisticNumbers(100, 500)\n   [153, 370, 371, 407]\n*/\n   static List<int> FindNarcissisticNumbers(int start, int end)"
    },
    "prompt_bertscore": {
      "sq": "0.9962790570720734",
      "hy": "0.9773013145768571",
      "bn": "0.9949559801040001",
      "bg": "0.9948803019288257",
      "zh": "0.9991254304323034",
      "fr": "0.9986304435227644",
      "de": "0.9876187724589524",
      "ha": "0.9927545595909903",
      "hi": "0.9991254304323034",
      "hu": "0.977784582293915"
    },
    "canonical_solution": "{\n    List<int> narcissisticNumbers = new List<int>();\n    for (int i = start; i <= end; i++)\n    {\n        if (i < 100) continue;\n        int sum = 0;\n        int number = i;\n        int digits = (int)Math.Floor(Math.Log10(i) + 1);\n        while (number > 0)\n        {\n            int digit = number % 10;\n            sum += (int)Math.Pow(digit, 3);\n            number /= 10;\n        }\n        if (sum == i)\n        {\n            narcissisticNumbers.Add(i);\n        }\n    }\n    return narcissisticNumbers;\n}",
    "instruction": {
      "en": "Write a C# function `static List<int> FindNarcissisticNumbers(int start, int end)` to solve the following problem:\nThis function finds all narcissistic numbers within a given range.\n   A narcissistic number is a number that is the sum of its own digits each raised to the power of the number of digits.\n   For example, 153 is a narcissistic number because 153 = 1^3 + 5^3 + 3^3.\n   \n   Examples:\n   >>> FindNarcissisticNumbers(100, 170)\n   [153]\n   >>> FindNarcissisticNumbers(100, 500)\n   [153, 370, 371, 407]",
      "sq": "Shkruani një funksion në C# `static List<int> FindNarcissisticNumbers(int start, int end)` për të zgjidhur problemin e mëposhtëm: Ky funksion gjen të gjitha numrat narcisistë brenda një intervali të dhënë. Një numër narcisist është një numër që është shuma e vetë shifrave të tij, secila e ngritur në fuqinë e numrit të shifrave. Për shembull, 153 është një numër narcisist sepse 153 = 1^3 + 5^3 + 3^3.\n\nShembuj:\n>>> FindNarcissisticNumbers(100, 170)\n[153]\n>>> FindNarcissisticNumbers(100, 500)\n[153, 370, 371, 407]",
      "hy": "C# ֆունկցիա `static List<int> FindNarcissisticNumbers(int start, int end)` գրեք հետևյալ խնդիրը լուծելու համար:\nԱյս ֆունկցիան գտնում է բոլոր նարցիսիստական թվերը տրված միջակայքում:\n   Նարցիսիստական թիվը թիվ է, որը հավասար է իր թվանշանների գումարին, որոնցից յուրաքանչյուրը բարձրացված է թվանշանների քանակի աստիճանի:\n   Օրինակ, 153-ը նարցիսիստական թիվ է, որովհետև 153 = 1^3 + 5^3 + 3^3:\n\n   Օրինակներ:\n   >>> FindNarcissisticNumbers(100, 170)\n   [153]\n   >>> FindNarcissisticNumbers(100, 500)\n   [153, 370, 371, 407]",
      "bn": "C# ফাংশন `static List<int> FindNarcissisticNumbers(int start, int end)` লিখুন নিম্নলিখিত সমস্যার সমাধানের জন্য:\nএই ফাংশনটি একটি নির্দিষ্ট সীমার মধ্যে সমস্ত নার্সিসিস্টিক সংখ্যা খুঁজে বের করে।\n   একটি নার্সিসিস্টিক সংখ্যা হল এমন একটি সংখ্যা যা তার নিজের অঙ্কগুলির যোগফল, প্রতিটি অঙ্কের সংখ্যা দ্বারা ঘাতিত।\n   উদাহরণস্বরূপ, 153 একটি নার্সিসিস্টিক সংখ্যা কারণ 153 = 1^3 + 5^3 + 3^3।\n\n   উদাহরণ:\n   >>> FindNarcissisticNumbers(100, 170)\n   [153]\n   >>> FindNarcissisticNumbers(100, 500)\n   [153, 370, 371, 407]",
      "bg": "Напишете C# функция `static List<int> FindNarcissisticNumbers(int start, int end)`, за да решите следния проблем:\nТази функция намира всички нарцистични числа в даден диапазон.\n   Нарцистично число е число, което е сумата от собствените си цифри, всяка повдигната на степента на броя на цифрите.\n   Например, 153 е нарцистично число, защото 153 = 1^3 + 5^3 + 3^3.\n   \n   Примери:\n   >>> FindNarcissisticNumbers(100, 170)\n   [153]\n   >>> FindNarcissisticNumbers(100, 500)\n   [153, 370, 371, 407]",
      "zh": "编写一个 C# 函数 `static List<int> FindNarcissisticNumbers(int start, int end)` 来解决以下问题：\n此函数查找给定范围内的所有水仙花数。\n水仙花数是指其自身数字的每个数字的幂次和等于该数字的数字。\n例如，153 是一个水仙花数，因为 153 = 1^3 + 5^3 + 3^3。\n\n示例：\n>>> FindNarcissisticNumbers(100, 170)\n[153]\n>>> FindNarcissisticNumbers(100, 500)\n[153, 370, 371, 407]",
      "fr": "Écrire une fonction C# `static List<int> FindNarcissisticNumbers(int start, int end)` pour résoudre le problème suivant :\nCette fonction trouve tous les nombres narcissiques dans une plage donnée.\n   Un nombre narcissique est un nombre qui est la somme de ses propres chiffres, chacun élevé à la puissance du nombre de chiffres.\n   Par exemple, 153 est un nombre narcissique parce que 153 = 1^3 + 5^3 + 3^3.\n   \n   Exemples :\n   >>> FindNarcissisticNumbers(100, 170)\n   [153]\n   >>> FindNarcissisticNumbers(100, 500)\n   [153, 370, 371, 407]",
      "de": "Schreiben Sie eine C#-Funktion `static List<int> FindNarcissisticNumbers(int start, int end)`, um das folgende Problem zu lösen:\nDiese Funktion findet alle narzisstischen Zahlen innerhalb eines gegebenen Bereichs.\n   Eine narzisstische Zahl ist eine Zahl, die die Summe ihrer eigenen Ziffern ist, wobei jede Ziffer auf die Potenz der Anzahl der Ziffern erhoben wird.\n   Zum Beispiel ist 153 eine narzisstische Zahl, weil 153 = 1^3 + 5^3 + 3^3.\n   \n   Beispiele:\n   >>> FindNarcissisticNumbers(100, 170)\n   [153]\n   >>> FindNarcissisticNumbers(100, 500)\n   [153, 370, 371, 407]",
      "ha": "Rubuta aikin C# `static List<int> FindNarcissisticNumbers(int start, int end)` don warware matsalar mai zuwa:\nWannan aikin yana gano duk lambobin narcissistic a cikin kewayon da aka bayar.\n   Lamba narcissistic ita ce lamba wadda ta zama jumlar lambobinta da aka ɗaga kowanne zuwa ikon adadin lambobin.\n   Alal misali, 153 lamba narcissistic ce saboda 153 = 1^3 + 5^3 + 3^3.\n\n   Misalai:\n   >>> FindNarcissisticNumbers(100, 170)\n   [153]\n   >>> FindNarcissisticNumbers(100, 500)\n   [153, 370, 371, 407]",
      "hi": "C# फ़ंक्शन `static List<int> FindNarcissisticNumbers(int start, int end)` लिखें ताकि निम्नलिखित समस्या का समाधान किया जा सके:\nयह फ़ंक्शन दिए गए सीमा के भीतर सभी narcissistic संख्याओं को खोजता है।\n   एक narcissistic संख्या वह संख्या होती है जो अपने स्वयं के अंकों के योग के बराबर होती है, प्रत्येक अंक को अंकों की संख्या की शक्ति तक उठाया जाता है।\n   उदाहरण के लिए, 153 एक narcissistic संख्या है क्योंकि 153 = 1^3 + 5^3 + 3^3।\n\n   उदाहरण:\n   >>> FindNarcissisticNumbers(100, 170)\n   [153]\n   >>> FindNarcissisticNumbers(100, 500)\n   [153, 370, 371, 407]",
      "hu": "Írj egy C# függvényt `static List<int> FindNarcissisticNumbers(int start, int end)` a következő probléma megoldására:\nEz a függvény megtalálja az összes nárcisztikus számot egy adott tartományon belül.\n   Egy nárcisztikus szám olyan szám, amely saját számjegyeinek összegével egyenlő, ahol minden számjegy a számjegyek számának hatványára van emelve.\n   Például, 153 egy nárcisztikus szám, mert 153 = 1^3 + 5^3 + 3^3.\n   \n   Példák:\n   >>> FindNarcissisticNumbers(100, 170)\n   [153]\n   >>> FindNarcissisticNumbers(100, 500)\n   [153, 370, 371, 407]"
    },
    "instruction_bertscore": {
      "sq": "0.9899526794361122",
      "hy": "0.9716322048717404",
      "bn": "0.9876972314594611",
      "bg": "0.9968942153621385",
      "zh": "0.9989540124134703",
      "fr": "0.9939769309558791",
      "de": "0.9878748070201063",
      "ha": "0.9892348292390521",
      "hi": "0.9794020294866821",
      "hu": "0.9769380196099443"
    },
    "level": "middle",
    "test": "    static void Main()\n    {\n \n        Debug.Assert(FindNarcissisticNumbers(100, 170).SequenceEqual(new List<int> { 153 }));\n        Debug.Assert(FindNarcissisticNumbers(100, 500).SequenceEqual(new List<int> { 153, 370, 371, 407 }));\n        Debug.Assert(FindNarcissisticNumbers(1, 100).SequenceEqual(new List<int> { }));\n        Debug.Assert(FindNarcissisticNumbers(370, 380).SequenceEqual(new List<int> { 370, 371 }));\n        Debug.Assert(FindNarcissisticNumbers(0, 999).SequenceEqual(new List<int> { 153, 370, 371, 407 }));\n        Debug.Assert(FindNarcissisticNumbers(900, 1000).SequenceEqual(new List<int> { }));\n        Debug.Assert(FindNarcissisticNumbers(10, 15).SequenceEqual(new List<int> { }));\n\n    }\n}",
    "entry_point": "FindNarcissisticNumbers",
    "signature": "static List<int> FindNarcissisticNumbers(int start, int end)",
    "docstring": {
      "en": "This function finds all narcissistic numbers within a given range.\n   A narcissistic number is a number that is the sum of its own digits each raised to the power of the number of digits.\n   For example, 153 is a narcissistic number because 153 = 1^3 + 5^3 + 3^3.\n   \n   Examples:\n   >>> FindNarcissisticNumbers(100, 170)\n   [153]\n   >>> FindNarcissisticNumbers(100, 500)\n   [153, 370, 371, 407]",
      "sq": "Kjo funksion gjen të gjitha numrat narcisistë brenda një intervali të caktuar. Një numër narcisist është një numër që është shuma e shifrave të tij, secila e ngritur në fuqinë e numrit të shifrave. Për shembull, 153 është një numër narcisist sepse 153 = 1^3 + 5^3 + 3^3.\n\nShembuj:\n>>> FindNarcissisticNumbers(100, 170)\n[153]\n>>> FindNarcissisticNumbers(100, 500)\n[153, 370, 371, 407]",
      "hy": "Այս ֆունկցիան գտնում է բոլոր նարցիսիստական թվերը տրված միջակայքում:\n   Նարցիսիստական թիվը այն թիվն է, որը հավասար է իր թվանշանների գումարին, որոնցից յուրաքանչյուրը բարձրացված է թվանշանների քանակի աստիճանի:\n   Օրինակ, 153-ը նարցիսիստական թիվ է, որովհետև 153 = 1^3 + 5^3 + 3^3:\n   \n   Օրինակներ:\n   >>> FindNarcissisticNumbers(100, 170)\n   [153]\n   >>> FindNarcissisticNumbers(100, 500)\n   [153, 370, 371, 407]",
      "bn": "এই ফাংশনটি একটি নির্দিষ্ট সীমার মধ্যে সমস্ত নার্সিসিস্টিক সংখ্যা খুঁজে পায়।\n   একটি নার্সিসিস্টিক সংখ্যা হল এমন একটি সংখ্যা যা তার নিজস্ব অঙ্কগুলির যোগফল, প্রতিটি অঙ্কের সংখ্যা অনুযায়ী ঘাতের সাথে তুল্য।\n   উদাহরণস্বরূপ, 153 একটি নার্সিসিস্টিক সংখ্যা কারণ 153 = 1^3 + 5^3 + 3^3।\n\n   উদাহরণসমূহ:\n   >>> FindNarcissisticNumbers(100, 170)\n   [153]\n   >>> FindNarcissisticNumbers(100, 500)\n   [153, 370, 371, 407]",
      "bg": "Тази функция намира всички нарцистични числа в даден диапазон. Нарцистично число е число, което е сумата от собствените си цифри, всяка повдигната на степента на броя на цифрите. Например, 153 е нарцистично число, защото 153 = 1^3 + 5^3 + 3^3.\n\nПримери:\n>>> FindNarcissisticNumbers(100, 170)\n[153]\n>>> FindNarcissisticNumbers(100, 500)\n[153, 370, 371, 407]",
      "zh": "此函数在给定范围内查找所有水仙花数。\n   一个水仙花数是一个数字，它是其自身数字的每个数字的幂次之和。  \n例如，153 是一个水仙花数，因为 153 = 1^3 + 5^3 + 3^3。  \n\n示例:  \n>>> FindNarcissisticNumbers(100, 170)  \n[153]  \n>>> FindNarcissisticNumbers(100, 500)  \n[153, 370, 371, 407]  ",
      "fr": "Cette fonction trouve tous les nombres narcissiques dans une plage donnée.\n   Un nombre narcissique est un nombre qui est la somme de ses propres chiffres, chacun élevé à la puissance du nombre de chiffres.  \n   Par exemple, 153 est un nombre narcissique car 153 = 1^3 + 5^3 + 3^3.\n   \n   Exemples :\n   >>> FindNarcissisticNumbers(100, 170)\n   [153]\n   >>> FindNarcissisticNumbers(100, 500)\n   [153, 370, 371, 407]",
      "de": "This function findet alle narzisstischen Zahlen innerhalb eines gegebenen Bereichs.\n   Eine narzisstische Zahl ist eine Zahl, die die Summe ihrer eigenen Ziffern ist, wobei jede Ziffer auf die Potenz der Anzahl der Ziffern erhoben wird.\n   Zum Beispiel ist 153 eine narzisstische Zahl, weil 153 = 1^3 + 5^3 + 3^3.\n   \n   Beispiele:\n   >>> FindNarcissisticNumbers(100, 170)\n   [153]\n   >>> FindNarcissisticNumbers(100, 500)\n   [153, 370, 371, 407]",
      "ha": "Wannan aikin yana nemo duk lambobin narcissistic a cikin kewayon da aka bayar.\n   Lambar narcissistic ita ce lamba da ke daidai da jumlar lambobinta na kansu kowanne ya ɗaga zuwa ikon yawan lambobin. \n   Misali, 153 lamba ce ta narcissistic saboda 153 = 1^3 + 5^3 + 3^3.\n   \n   Misalai:\n   >>> FindNarcissisticNumbers(100, 170)\n   [153]\n   >>> FindNarcissisticNumbers(100, 500)\n   [153, 370, 371, 407]",
      "hi": "यह फ़ंक्शन एक दिए गए सीमा के भीतर सभी नार्सिसिस्टिक संख्याएँ खोजता है।\n   एक नार्सिसिस्टिक संख्या वह संख्या होती है जो अपने स्वयं के अंकों का योग होती है, प्रत्येक अंक को अंकों की संख्या की शक्ति तक उठाया जाता है।\n   उदाहरण के लिए, 153 एक narcissistic संख्या है क्योंकि 153 = 1^3 + 5^3 + 3^3।  \n   \n   उदाहरण:\n   >>> FindNarcissisticNumbers(100, 170)\n   [153]\n   >>> FindNarcissisticNumbers(100, 500)\n   [153, 370, 371, 407]",
      "hu": "Ez a függvény megtalálja az összes nárcisztikus számot egy adott tartományon belül.\n   Egy nárcisztikus szám olyan szám, amely a saját számjegyeinek összegével egyenlő, mindegyik számjegy a számjegyek számának hatványára emelve.\n   Például, 153 egy nárcisztikus szám, mert 153 = 1^3 + 5^3 + 3^3.\n   \n   Példák:\n   >>> FindNarcissisticNumbers(100, 170)\n   [153]\n   >>> FindNarcissisticNumbers(100, 500)\n   [153, 370, 371, 407]"
    },
    "docstring_bertscore": {
      "sq": "0.9904329676974546",
      "hy": "0.9787131793252531",
      "bn": "0.981815984507399",
      "bg": "0.9980977168408289",
      "zh": "0.998587539360461",
      "fr": "0.9951587817230366",
      "de": "0.9837754732163083",
      "ha": "0.9807112023280831",
      "hi": "0.9641694628258786",
      "hu": "0.9878597111111477"
    }
  },
  {
    "task_id": "C#/6",
    "prompt": {
      "en": "using System;\nusing System.Collections.Generic;\nusing System.Diagnostics;\n\nclass Program\n{\n/* Sorts three given integers in ascending order and returns the sorted list.\n    Example usage:\n    >>> SortIntegersAscending(3, 1, 2)\n    [1, 2, 3]\n    >>> SortIntegersAscending(5, 7, 2)\n    [2, 5, 7]\n    >>> SortIntegersAscending(-1, 0, -3)\n    [-3, -1, 0]\n*/\nstatic List<int> SortIntegersAscending(int num1, int num2, int num3)",
      "sq": "using System;\nusing System.Collections.Generic;\nusing System.Diagnostics;\n\nclass Program\n{\n/* Rendit tre numra të plotë të dhënë në rend rritës dhe kthen listën e renditur.\n    Shembull përdorimi:\n    >>> SortIntegersAscending(3, 1, 2)\n    [1, 2, 3]\n    >>> SortIntegersAscending(5, 7, 2)\n    [2, 5, 7]\n    >>> SortIntegersAscending(-1, 0, -3)\n    [-3, -1, 0]\n*/\nstatic List<int> SortIntegersAscending(int num1, int num2, int num3)",
      "hy": "using System;\nusing System.Collections.Generic;\nusing System.Diagnostics;\n\nclass Program\n{\n/* Տրված երեք ամբողջ թվերը դասավորում է աճման կարգով և վերադարձնում դասավորված ցուցակը:\n    Օրինակ օգտագործում:\n    >>> SortIntegersAscending(3, 1, 2)\n    [1, 2, 3]\n    >>> SortIntegersAscending(5, 7, 2)\n    [2, 5, 7]\n    >>> SortIntegersAscending(-1, 0, -3)\n    [-3, -1, 0]\n*/\nstatic List<int> SortIntegersAscending(int num1, int num2, int num3)",
      "bn": "using System;\nusing System.Collections.Generic;\nusing System.Diagnostics;\n\nclass Program\n{\n/* তিনটি প্রদত্ত পূর্ণসংখ্যা ক্রমবর্ধমান ক্রমে সাজায় এবং সাজানো তালিকা ফেরত দেয়।\n    উদাহরণ ব্যবহার:\n    >>> SortIntegersAscending(3, 1, 2)\n    [1, 2, 3]\n    >>> SortIntegersAscending(5, 7, 2)\n    [2, 5, 7]\n    >>> SortIntegersAscending(-1, 0, -3)\n    [-3, -1, 0]\n*/\nstatic List<int> SortIntegersAscending(int num1, int num2, int num3)",
      "bg": "using System;\nusing System.Collections.Generic;\nusing System.Diagnostics;\n\nclass Program\n{\n/* Сортира три дадени цели числа във възходящ ред и връща сортирания списък.\n    Пример за използване:\n    >>> SortIntegersAscending(3, 1, 2)\n    [1, 2, 3]\n    >>> SortIntegersAscending(5, 7, 2)\n    [2, 5, 7]\n    >>> SortIntegersAscending(-1, 0, -3)\n    [-3, -1, 0]\n*/\nstatic List<int> SortIntegersAscending(int num1, int num2, int num3)",
      "zh": "using System;\nusing System.Collections.Generic;\nusing System.Diagnostics;\n\nclass Program\n{\n/* 对三个给定的整数进行升序排序并返回排序后的列表。\n    示例用法:\n    >>> SortIntegersAscending(3, 1, 2)\n    [1, 2, 3]\n    >>> SortIntegersAscending(5, 7, 2)\n    [2, 5, 7]\n    >>> SortIntegersAscending(-1, 0, -3)\n    [-3, -1, 0]\n*/\nstatic List<int> SortIntegersAscending(int num1, int num2, int num3)",
      "fr": "using System;\nusing System.Collections.Generic;\nusing System.Diagnostics;\n\nclass Program\n{\n/* Trie trois entiers donnés par ordre croissant et renvoie la liste triée.\n    Exemple d'utilisation :\n    >>> SortIntegersAscending(3, 1, 2)\n    [1, 2, 3]\n    >>> SortIntegersAscending(5, 7, 2)\n    [2, 5, 7]\n    >>> SortIntegersAscending(-1, 0, -3)\n    [-3, -1, 0]\n*/\nstatic List<int> SortIntegersAscending(int num1, int num2, int num3)",
      "de": "using System;\nusing System.Collections.Generic;\nusing System.Diagnostics;\n\nclass Program\n{\n/* Sortiert drei gegebene ganze Zahlen in aufsteigender Reihenfolge und gibt die sortierte Liste zurück.\n    Beispielverwendung:\n    >>> SortIntegersAscending(3, 1, 2)\n    [1, 2, 3]\n    >>> SortIntegersAscending(5, 7, 2)\n    [2, 5, 7]\n    >>> SortIntegersAscending(-1, 0, -3)\n    [-3, -1, 0]\n*/\nstatic List<int> SortIntegersAscending(int num1, int num2, int num3)",
      "ha": "using System;\nusing System.Collections.Generic;\nusing System.Diagnostics;\n\nclass Program\n{\n/* Yana tsara lambobi guda uku da aka bayar a cikin tsari mai hawa kuma yana dawo da jerin da aka tsara.\n    Misalin amfani:\n    >>> SortIntegersAscending(3, 1, 2)\n    [1, 2, 3]\n    >>> SortIntegersAscending(5, 7, 2)\n    [2, 5, 7]\n    >>> SortIntegersAscending(-1, 0, -3)\n    [-3, -1, 0]\n*/\nstatic List<int> SortIntegersAscending(int num1, int num2, int num3)",
      "hi": "using System;\nusing System.Collections.Generic;\nusing System.Diagnostics;\n\nclass Program\n{\n/* तीन दिए गए पूर्णांकों को आरोही क्रम में क्रमबद्ध करता है और क्रमबद्ध सूची लौटाता है।\n    उदाहरण उपयोग:\n    >>> SortIntegersAscending(3, 1, 2)\n    [1, 2, 3]\n    >>> SortIntegersAscending(5, 7, 2)\n    [2, 5, 7]\n    >>> SortIntegersAscending(-1, 0, -3)\n    [-3, -1, 0]\n*/\nstatic List<int> SortIntegersAscending(int num1, int num2, int num3)",
      "hu": "using System;\nusing System.Collections.Generic;\nusing System.Diagnostics;\n\nclass Program\n{\n/* Három megadott egész számot növekvő sorrendbe rendez, és visszaadja a rendezett listát.\n    Példa használat:\n    >>> SortIntegersAscending(3, 1, 2)\n    [1, 2, 3]\n    >>> SortIntegersAscending(5, 7, 2)\n    [2, 5, 7]\n    >>> SortIntegersAscending(-1, 0, -3)\n    [-3, -1, 0]\n*/\nstatic List<int> SortIntegersAscending(int num1, int num2, int num3)"
    },
    "prompt_bertscore": {
      "sq": "0.998001778366789",
      "hy": "0.9951528228116057",
      "bn": "1",
      "bg": "1",
      "zh": "0.9944739041692284",
      "fr": "0.9945380617823026",
      "de": "1",
      "ha": "0.979464598056708",
      "hi": "0.9954195834133355",
      "hu": "1"
    },
    "canonical_solution": "{\n    List<int> numbers = new List<int> { num1, num2, num3 };\n    numbers.Sort();\n    return numbers;\n}",
    "instruction": {
      "en": "Write a C# function `static List<int> SortIntegersAscending(int num1, int num2, int num3)` to solve the following problem:\nSorts three given integers in ascending order and returns the sorted list.\n    Example usage:\n    >>> SortIntegersAscending(3, 1, 2)\n    [1, 2, 3]\n    >>> SortIntegersAscending(5, 7, 2)\n    [2, 5, 7]\n    >>> SortIntegersAscending(-1, 0, -3)\n    [-3, -1, 0]",
      "sq": "Shkruani një funksion në C# `static List<int> SortIntegersAscending(int num1, int num2, int num3)` për të zgjidhur problemin në vijim: \nRendit tre numra të plotë të dhënë në rend rritës dhe kthen listën e renditur.\n    Shembull përdorimi:\n    >>> SortIntegersAscending(3, 1, 2)\n    [1, 2, 3]\n    >>> SortIntegersAscending(5, 7, 2)\n    [2, 5, 7]\n    >>> SortIntegersAscending(-1, 0, -3)\n    [-3, -1, 0]",
      "hy": "Գրեք C# ֆունկցիա `static List<int> SortIntegersAscending(int num1, int num2, int num3)` հետևյալ խնդիրը լուծելու համար:\nՏրված երեք ամբողջ թվերը դասավորում է աճման կարգով և վերադարձնում դասավորված ցուցակը:\n    Օրինակ օգտագործում:\n    >>> SortIntegersAscending(3, 1, 2)\n    [1, 2, 3]\n    >>> SortIntegersAscending(5, 7, 2)\n    [2, 5, 7]\n    >>> SortIntegersAscending(-1, 0, -3)\n    [-3, -1, 0]",
      "bn": "একটি C# ফাংশন `static List<int> SortIntegersAscending(int num1, int num2, int num3)` লিখুন নিম্নলিখিত সমস্যার সমাধানের জন্য:\nতিনটি প্রদত্ত পূর্ণসংখ্যাকে ঊর্ধ্বক্রমে সাজায় এবং সাজানো তালিকা ফেরত দেয়।\n    উদাহরণ ব্যবহার:\n    >>> SortIntegersAscending(3, 1, 2)\n    [1, 2, 3]\n    >>> SortIntegersAscending(5, 7, 2)\n    [2, 5, 7]\n    >>> SortIntegersAscending(-1, 0, -3)\n    [-3, -1, 0]",
      "bg": "Напишете C# функция `static List<int> SortIntegersAscending(int num1, int num2, int num3)`, за да решите следния проблем:\nСортира три дадени цели числа във възходящ ред и връща сортирания списък.\n    Пример за използване:\n    >>> SortIntegersAscending(3, 1, 2)\n    [1, 2, 3]\n    >>> SortIntegersAscending(5, 7, 2)\n    [2, 5, 7]\n    >>> SortIntegersAscending(-1, 0, -3)\n    [-3, -1, 0]",
      "zh": "编写一个 C# 函数 `static List<int> SortIntegersAscending(int num1, int num2, int num3)` 来解决以下问题：\n将三个给定的整数按升序排序并返回排序后的列表。\n    示例用法:\n    >>> SortIntegersAscending(3, 1, 2)\n    [1, 2, 3]\n    >>> SortIntegersAscending(5, 7, 2)\n    [2, 5, 7]\n    >>> SortIntegersAscending(-1, 0, -3)\n    [-3, -1, 0]",
      "fr": "Écrire une fonction C# `static List<int> SortIntegersAscending(int num1, int num2, int num3)` pour résoudre le problème suivant :\nTrie trois entiers donnés par ordre croissant et renvoie la liste triée.\n    Exemple d'utilisation :\n    >>> SortIntegersAscending(3, 1, 2)\n    [1, 2, 3]\n    >>> SortIntegersAscending(5, 7, 2)\n    [2, 5, 7]\n    >>> SortIntegersAscending(-1, 0, -3)\n    [-3, -1, 0]",
      "de": "Schreiben Sie eine C#-Funktion `static List<int> SortIntegersAscending(int num1, int num2, int num3)`, um das folgende Problem zu lösen:\nSortiert drei gegebene ganze Zahlen in aufsteigender Reihenfolge und gibt die sortierte Liste zurück.\n    Beispielverwendung:\n    >>> SortIntegersAscending(3, 1, 2)\n    [1, 2, 3]\n    >>> SortIntegersAscending(5, 7, 2)\n    [2, 5, 7]\n    >>> SortIntegersAscending(-1, 0, -3)\n    [-3, -1, 0]",
      "ha": "Rubuta aikin C# `static List<int> SortIntegersAscending(int num1, int num2, int num3)` don warware matsalar mai zuwa:\nTana tsara lambobi guda uku da aka bayar a cikin tsari mai tashi kuma tana mayar da jerin da aka tsara.\n    Misalin amfani:\n    >>> SortIntegersAscending(3, 1, 2)\n    [1, 2, 3]\n    >>> SortIntegersAscending(5, 7, 2)\n    [2, 5, 7]\n    >>> SortIntegersAscending(-1, 0, -3)\n    [-3, -1, 0]",
      "hi": "C# फ़ंक्शन `static List<int> SortIntegersAscending(int num1, int num2, int num3)` लिखें ताकि निम्नलिखित समस्या का समाधान हो सके:\nतीन दिए गए पूर्णांकों को आरोही क्रम में क्रमबद्ध करता है और क्रमबद्ध सूची को लौटाता है।\n    उदाहरण उपयोग:\n    >>> SortIntegersAscending(3, 1, 2)\n    [1, 2, 3]\n    >>> SortIntegersAscending(5, 7, 2)\n    [2, 5, 7]\n    >>> SortIntegersAscending(-1, 0, -3)\n    [-3, -1, 0]",
      "hu": "Írj egy C# függvényt `static List<int> SortIntegersAscending(int num1, int num2, int num3)` a következő probléma megoldására:\nHárom adott egész számot növekvő sorrendbe rendez, és visszaadja a rendezett listát.\n    Példa használat:\n    >>> SortIntegersAscending(3, 1, 2)\n    [1, 2, 3]\n    >>> SortIntegersAscending(5, 7, 2)\n    [2, 5, 7]\n    >>> SortIntegersAscending(-1, 0, -3)\n    [-3, -1, 0]"
    },
    "instruction_bertscore": {
      "sq": "0.985385372454596",
      "hy": "0.9928067993812025",
      "bn": "0.9931887656039327",
      "bg": "0.9924601893662967",
      "zh": "0.99287731316647",
      "fr": "0.9940829995793518",
      "de": "0.9940829995793518",
      "ha": "0.9778251028916461",
      "hi": "0.9851650913620283",
      "hu": "0.9940829995793518"
    },
    "level": "easy",
    "test": "    static void Main()\n    {\n        Debug.Assert(SortIntegersAscending(3, 1, 2).SequenceEqual(new List<int> { 1, 2, 3 }));\n        Debug.Assert(SortIntegersAscending(5, 7, 2).SequenceEqual(new List<int> { 2, 5, 7 }));\n        Debug.Assert(SortIntegersAscending(-1, 0, -3).SequenceEqual(new List<int> { -3, -1, 0 }));\n        Debug.Assert(SortIntegersAscending(10, 10, 10).SequenceEqual(new List<int> { 10, 10, 10 }));\n        Debug.Assert(SortIntegersAscending(0, -1, 1).SequenceEqual(new List<int> { -1, 0, 1 }));\n        Debug.Assert(SortIntegersAscending(100, 50, 75).SequenceEqual(new List<int> { 50, 75, 100 }));\n        Debug.Assert(SortIntegersAscending(-5, -10, -7).SequenceEqual(new List<int> { -10, -7, -5 }));\n\n\n    }\n}",
    "entry_point": "SortIntegersAscending",
    "signature": "static List<int> SortIntegersAscending(int num1, int num2, int num3)",
    "docstring": {
      "en": "Sorts three given integers in ascending order and returns the sorted list.\n    Example usage:\n    >>> SortIntegersAscending(3, 1, 2)\n    [1, 2, 3]\n    >>> SortIntegersAscending(5, 7, 2)\n    [2, 5, 7]\n    >>> SortIntegersAscending(-1, 0, -3)\n    [-3, -1, 0]",
      "sq": "Rendit tre numra të plotë të dhënë në rend rritës dhe kthen listën e renditur.\n    Shembull përdorimi:\n    >>> SortIntegersAscending(3, 1, 2)\n    [1, 2, 3]\n    >>> SortIntegersAscending(5, 7, 2)\n    [2, 5, 7]\n    >>> SortIntegersAscending(-1, 0, -3)\n    [-3, -1, 0]",
      "hy": "Տրամադրում է երեք տրված ամբողջ թվերը աճման կարգով և վերադարձնում է դասավորված ցուցակը:\n    Օրինակ օգտագործում:\n    >>> SortIntegersAscending(3, 1, 2)\n    [1, 2, 3]\n    >>> SortIntegersAscending(5, 7, 2)\n    [2, 5, 7]\n    >>> SortIntegersAscending(-1, 0, -3)\n    [-3, -1, 0]",
      "bn": "তিনটি প্রদত্ত পূর্ণসংখ্যাকে ঊর্ধ্বক্রমে সাজায় এবং সাজানো তালিকাটি ফেরত দেয়।\n    উদাহরণ ব্যবহার:\n    >>> SortIntegersAscending(3, 1, 2)\n    [1, 2, 3]\n    >>> SortIntegersAscending(5, 7, 2)\n    [2, 5, 7]\n    >>> SortIntegersAscending(-1, 0, -3)\n    [-3, -1, 0]",
      "bg": "Сортира три дадени цели числа във възходящ ред и връща сортирания списък.\n    Пример за използване:\n    >>> SortIntegersAscending(3, 1, 2)\n    [1, 2, 3]\n    >>> SortIntegersAscending(5, 7, 2)\n    [2, 5, 7]\n    >>> SortIntegersAscending(-1, 0, -3)\n    [-3, -1, 0]",
      "zh": "将三个给定的整数按升序排序并返回排序后的列表。\n    示例用法：\n    >>> SortIntegersAscending(3, 1, 2)\n    [1, 2, 3]\n    >>> SortIntegersAscending(5, 7, 2)\n    [2, 5, 7]\n    >>> SortIntegersAscending(-1, 0, -3)\n    [-3, -1, 0]",
      "fr": "Trie trois entiers donnés par ordre croissant et renvoie la liste triée.\n    Exemple d'utilisation :\n    >>> SortIntegersAscending(3, 1, 2)\n    [1, 2, 3]\n    >>> SortIntegersAscending(5, 7, 2)\n    [2, 5, 7]\n    >>> SortIntegersAscending(-1, 0, -3)\n    [-3, -1, 0]",
      "de": "Sortiert drei gegebene ganze Zahlen in aufsteigender Reihenfolge und gibt die sortierte Liste zurück.\n    Beispielverwendung:\n    >>> SortIntegersAscending(3, 1, 2)\n    [1, 2, 3]\n    >>> SortIntegersAscending(5, 7, 2)\n    [2, 5, 7]\n    >>> SortIntegersAscending(-1, 0, -3)\n    [-3, -1, 0]",
      "ha": "Tace lambobi guda uku da aka bayar a cikin tsari mai hawa kuma ya dawo da jerin da aka tace.\n    Misali amfani:\n    >>> SortIntegersAscending(3, 1, 2)\n    [1, 2, 3]\n    >>> SortIntegersAscending(5, 7, 2)\n    [2, 5, 7]\n    >>> SortIntegersAscending(-1, 0, -3)\n    [-3, -1, 0]",
      "hi": "तीन दिए गए पूर्णांकों को आरोही क्रम में छांटता है और छांटी गई सूची को लौटाता है।\n    उदाहरण उपयोग:\n    >>> SortIntegersAscending(3, 1, 2)\n    [1, 2, 3]\n    >>> SortIntegersAscending(5, 7, 2)\n    [2, 5, 7]\n    >>> SortIntegersAscending(-1, 0, -3)\n    [-3, -1, 0]",
      "hu": "Három megadott egész számot növekvő sorrendbe rendez, és visszaadja a rendezett listát.\n    Példa használat:\n    >>> SortIntegersAscending(3, 1, 2)\n    [1, 2, 3]\n    >>> SortIntegersAscending(5, 7, 2)\n    [2, 5, 7]\n    >>> SortIntegersAscending(-1, 0, -3)\n    [-3, -1, 0]"
    },
    "docstring_bertscore": {
      "sq": "0.9908635983635382",
      "hy": "0.98769127254803",
      "bn": "1",
      "bg": "1",
      "zh": "0.9886742943037717",
      "fr": "0.9908097695302778",
      "de": "1",
      "ha": "0.9717370817129268",
      "hi": "0.992638559448466",
      "hu": "1"
    }
  },
  {
    "task_id": "C#/7",
    "prompt": {
      "en": "using System;\nusing System.Collections.Generic;\nusing System.Diagnostics;\n\nclass Program\n{\n/* Copies a substring from the specified start index in the input string to the end of the string.\n   If the start index is greater than the string's length, returns an empty string.\n   Examples:\n   >>> CopySubstringFromIndex(\"Hello World\", 6)\n   \"World\"\n   >>> CopySubstringFromIndex(\"Example\", 3)\n   \"mple\"\n   >>> CopySubstringFromIndex(\"Short\", 10)\n   \"\"\n*/   \n   static string CopySubstringFromIndex(string input, int startIndex)",
      "sq": "using System;\nusing System.Collections.Generic;\nusing System.Diagnostics;\n\nclass Program\n{\n/* Kopjon një nënvarg nga indeksi i specifikuar i fillimit në vargun hyrës deri në fund të vargut.\n   Nëse indeksi i fillimit është më i madh se gjatësia e vargut, kthen një varg bosh.\n   Shembuj:\n   >>> CopySubstringFromIndex(\"Hello World\", 6)\n   \"World\"\n   >>> CopySubstringFromIndex(\"Example\", 3)\n   \"mple\"\n   >>> CopySubstringFromIndex(\"Short\", 10)\n   \"\"\n*/   \n   static string CopySubstringFromIndex(string input, int startIndex)",
      "hy": "using System;\nusing System.Collections.Generic;\nusing System.Diagnostics;\n\nclass Program\n{\n/* Պատճենում է ենթատողը մուտքային տողի նշված մեկնարկային ինդեքսից մինչև տողի վերջը:\n   Եթե մեկնարկային ինդեքսը մեծ է տողի երկարությունից, վերադարձնում է դատարկ տող:\n   Օրինակներ:\n   >>> CopySubstringFromIndex(\"Hello World\", 6)\n   \"World\"\n   >>> CopySubstringFromIndex(\"Example\", 3)\n   \"mple\"\n   >>> CopySubstringFromIndex(\"Short\", 10)\n   \"\"\n*/   \n   static string CopySubstringFromIndex(string input, int startIndex)",
      "bn": "using System;\nusing System.Collections.Generic;\nusing System.Diagnostics;\n\nclass Program\n{\n/* নির্দিষ্ট শুরুর সূচক থেকে ইনপুট স্ট্রিংয়ের শেষে একটি সাবস্ট্রিং কপি করে।\n   যদি শুরুর সূচক স্ট্রিংয়ের দৈর্ঘ্যের চেয়ে বড় হয়, তাহলে একটি খালি স্ট্রিং ফেরত দেয়।\n   উদাহরণ:\n   >>> CopySubstringFromIndex(\"Hello World\", 6)\n   \"World\"\n   >>> CopySubstringFromIndex(\"Example\", 3)\n   \"mple\"\n   >>> CopySubstringFromIndex(\"Short\", 10)\n   \"\"\n*/   \n   static string CopySubstringFromIndex(string input, int startIndex)",
      "bg": "using System;\nusing System.Collections.Generic;\nusing System.Diagnostics;\n\nclass Program\n{\n/* Копира подниз от зададения начален индекс в входния низ до края на низа.\n   Ако началният индекс е по-голям от дължината на низа, връща празен низ.\n   Примери:\n   >>> CopySubstringFromIndex(\"Hello World\", 6)\n   \"World\"\n   >>> CopySubstringFromIndex(\"Example\", 3)\n   \"mple\"\n   >>> CopySubstringFromIndex(\"Short\", 10)\n   \"\"\n*/   \n   static string CopySubstringFromIndex(string input, int startIndex)",
      "zh": "using System;\nusing System.Collections.Generic;\nusing System.Diagnostics;\n\nclass Program\n{\n/* 从输入字符串中指定的起始索引复制子字符串到字符串的末尾。\n   如果起始索引大于字符串的长度，则返回一个空字符串。\n   示例:\n   >>> CopySubstringFromIndex(\"Hello World\", 6)\n   \"World\"\n   >>> CopySubstringFromIndex(\"Example\", 3)\n   \"mple\"\n   >>> CopySubstringFromIndex(\"Short\", 10)\n   \"\"\n*/   \n   static string CopySubstringFromIndex(string input, int startIndex)",
      "fr": "using System;\nusing System.Collections.Generic;\nusing System.Diagnostics;\n\nclass Program\n{\n/* Copie une sous-chaîne à partir de l'index de départ spécifié dans la chaîne d'entrée jusqu'à la fin de la chaîne.\n   Si l'index de départ est supérieur à la longueur de la chaîne, retourne une chaîne vide.\n   Exemples :\n   >>> CopySubstringFromIndex(\"Hello World\", 6)\n   \"World\"\n   >>> CopySubstringFromIndex(\"Example\", 3)\n   \"mple\"\n   >>> CopySubstringFromIndex(\"Short\", 10)\n   \"\"\n*/   \n   static string CopySubstringFromIndex(string input, int startIndex)",
      "de": "using System;\nusing System.Collections.Generic;\nusing System.Diagnostics;\n\nclass Program\n{\n/* Kopiert einen Teilstring vom angegebenen Startindex im Eingabestring bis zum Ende des Strings.\n   Wenn der Startindex größer als die Länge des Strings ist, wird ein leerer String zurückgegeben.\n   Beispiele:\n   >>> CopySubstringFromIndex(\"Hello World\", 6)\n   \"World\"\n   >>> CopySubstringFromIndex(\"Example\", 3)\n   \"mple\"\n   >>> CopySubstringFromIndex(\"Short\", 10)\n   \"\"\n*/   \n   static string CopySubstringFromIndex(string input, int startIndex)",
      "ha": "using System;\nusing System.Collections.Generic;\nusing System.Diagnostics;\n\nclass Program\n{\n/* Kwafi wani ɓangare na rubutu daga takamaiman farawa a cikin rubutun shigarwa zuwa ƙarshen rubutun.\n   Idan farawa ya fi tsawon rubutun, zai dawo da rubutu mara komai.\n   Misalai:\n   >>> CopySubstringFromIndex(\"Hello World\", 6)\n   \"World\"\n   >>> CopySubstringFromIndex(\"Example\", 3)\n   \"mple\"\n   >>> CopySubstringFromIndex(\"Short\", 10)\n   \"\"\n*/   \n   static string CopySubstringFromIndex(string input, int startIndex)",
      "hi": "using System;\nusing System.Collections.Generic;\nusing System.Diagnostics;\n\nclass Program\n{\n/* इनपुट स्ट्रिंग में निर्दिष्ट प्रारंभिक इंडेक्स से स्ट्रिंग के अंत तक एक उपस्ट्रिंग की प्रतिलिपि बनाता है।\n   यदि प्रारंभिक इंडेक्स स्ट्रिंग की लंबाई से अधिक है, तो एक खाली स्ट्रिंग लौटाता है।\n   उदाहरण:\n   >>> CopySubstringFromIndex(\"Hello World\", 6)\n   \"World\"\n   >>> CopySubstringFromIndex(\"Example\", 3)\n   \"mple\"\n   >>> CopySubstringFromIndex(\"Short\", 10)\n   \"\"\n*/   \n   static string CopySubstringFromIndex(string input, int startIndex)",
      "hu": "using System;\nusing System.Collections.Generic;\nusing System.Diagnostics;\n\nclass Program\n{\n/* Egy részsztringet másol a megadott kezdőindextől a bemeneti sztring végéig.\n   Ha a kezdőindex nagyobb, mint a sztring hossza, üres sztringet ad vissza.\n   Példák:\n   >>> CopySubstringFromIndex(\"Hello World\", 6)\n   \"World\"\n   >>> CopySubstringFromIndex(\"Example\", 3)\n   \"mple\"\n   >>> CopySubstringFromIndex(\"Short\", 10)\n   \"\"\n*/   \n   static string CopySubstringFromIndex(string input, int startIndex)"
    },
    "prompt_bertscore": {
      "sq": "0.9917375720400917",
      "hy": "0.9878831494961098",
      "bn": "0.9723856099070057",
      "bg": "0.9877603959206301",
      "zh": "0.9826969102472888",
      "fr": "0.9917375720400917",
      "de": "0.9849938719735762",
      "ha": "0.9409654617133829",
      "hi": "0.9804156403211032",
      "hu": "0.9764575327182209"
    },
    "canonical_solution": "{\n    if (startIndex >= input.Length)\n    {\n        return \"\";\n    }\n    return input.Substring(startIndex);\n}",
    "instruction": {
      "en": "Write a C# function `static string CopySubstringFromIndex(string input, int startIndex)` to solve the following problem:\nCopies a substring from the specified start index in the input string to the end of the string.\n   If the start index is greater than the string's length, returns an empty string.\n   Examples:\n   >>> CopySubstringFromIndex(\"Hello World\", 6)\n   \"World\"\n   >>> CopySubstringFromIndex(\"Example\", 3)\n   \"mple\"\n   >>> CopySubstringFromIndex(\"Short\", 10)\n   \"\"",
      "sq": "Shkruani një funksion në C# `static string CopySubstringFromIndex(string input, int startIndex)` për të zgjidhur problemin e mëposhtëm:\nKopjon një nënvarg nga indeksi i specifikuar i fillimit në vargun hyrës deri në fund të vargut.\n   Nëse indeksi i fillimit është më i madh se gjatësia e vargut, kthen një varg bosh.\n   Shembuj:\n   >>> CopySubstringFromIndex(\"Hello World\", 6)\n   \"World\"\n   >>> CopySubstringFromIndex(\"Example\", 3)\n   \"mple\"\n   >>> CopySubstringFromIndex(\"Short\", 10)\n   \"\"",
      "hy": "Գրեք C# ֆունկցիա `static string CopySubstringFromIndex(string input, int startIndex)` հետևյալ խնդիրը լուծելու համար:\nՊատճենում է ենթատողը մուտքագրված տողի նշված սկզբնական ինդեքսից մինչև տողի վերջը:\n   Եթե սկզբնական ինդեքսը մեծ է տողի երկարությունից, վերադարձնում է դատարկ տող:\n   Օրինակներ:\n   >>> CopySubstringFromIndex(\"Hello World\", 6)\n   \"World\"\n   >>> CopySubstringFromIndex(\"Example\", 3)\n   \"mple\"\n   >>> CopySubstringFromIndex(\"Short\", 10)\n   \"\"",
      "bn": "একটি C# ফাংশন `static string CopySubstringFromIndex(string input, int startIndex)` লিখুন নিম্নলিখিত সমস্যার সমাধানের জন্য:\nনির্দিষ্ট শুরু সূচক থেকে ইনপুট স্ট্রিংয়ের শেষে পর্যন্ত একটি সাবস্ট্রিং কপি করে।\n   যদি শুরু সূচক স্ট্রিংয়ের দৈর্ঘ্যের চেয়ে বড় হয়, তাহলে একটি খালি স্ট্রিং ফেরত দেয়।\n   উদাহরণসমূহ:\n   >>> CopySubstringFromIndex(\"Hello World\", 6)\n   \"World\"\n   >>> CopySubstringFromIndex(\"Example\", 3)\n   \"mple\"\n   >>> CopySubstringFromIndex(\"Short\", 10)\n   \"\"",
      "bg": "Напишете C# функция `static string CopySubstringFromIndex(string input, int startIndex)` за решаване на следния проблем:\nКопира подниз от зададения начален индекс в входния низ до края на низа.\n   Ако началният индекс е по-голям от дължината на низа, връща празен низ.\n   Примери:\n   >>> CopySubstringFromIndex(\"Hello World\", 6)\n   \"World\"\n   >>> CopySubstringFromIndex(\"Example\", 3)\n   \"mple\"\n   >>> CopySubstringFromIndex(\"Short\", 10)\n   \"\"",
      "zh": "编写一个 C# 函数 `static string CopySubstringFromIndex(string input, int startIndex)` 来解决以下问题：\n从输入字符串中指定的起始索引复制子字符串到字符串的末尾。\n如果起始索引大于字符串的长度，则返回一个空字符串。\n例子:\n>>> CopySubstringFromIndex(\"Hello World\", 6)\n\"World\"\n>>> CopySubstringFromIndex(\"Example\", 3)\n\"mple\"\n>>> CopySubstringFromIndex(\"Short\", 10)\n\"\"",
      "fr": "Écrire une fonction C# `static string CopySubstringFromIndex(string input, int startIndex)` pour résoudre le problème suivant :\nCopie une sous-chaîne à partir de l'index de départ spécifié dans la chaîne d'entrée jusqu'à la fin de la chaîne.\n   Si l'index de départ est supérieur à la longueur de la chaîne, retourne une chaîne vide.\n   Exemples :\n   >>> CopySubstringFromIndex(\"Hello World\", 6)\n   \"World\"\n   >>> CopySubstringFromIndex(\"Example\", 3)\n   \"mple\"\n   >>> CopySubstringFromIndex(\"Short\", 10)\n   \"\"",
      "de": "Schreiben Sie eine C#-Funktion `static string CopySubstringFromIndex(string input, int startIndex)`, um das folgende Problem zu lösen:\nKopiert einen Teilstring vom angegebenen Startindex im Eingabestring bis zum Ende des Strings.\n   Wenn der Startindex größer als die Länge des Strings ist, wird ein leerer String zurückgegeben.\n   Beispiele:\n   >>> CopySubstringFromIndex(\"Hello World\", 6)\n   \"World\"\n   >>> CopySubstringFromIndex(\"Example\", 3)\n   \"mple\"\n   >>> CopySubstringFromIndex(\"Short\", 10)\n   \"\"",
      "ha": "Rubuta aikin C# `static string CopySubstringFromIndex(string input, int startIndex)` don warware matsalar mai zuwa:\nKwafi wani ɓangare na rubutu daga wurin da aka ayyana a cikin rubutun shigarwa zuwa ƙarshen rubutun.\n   Idan wurin da aka fara ya fi tsayin rubutun, zai dawo da rubutu mara komai.\n   Misalai:\n   >>> CopySubstringFromIndex(\"Hello World\", 6)\n   \"World\"\n   >>> CopySubstringFromIndex(\"Example\", 3)\n   \"mple\"\n   >>> CopySubstringFromIndex(\"Short\", 10)\n   \"\"",
      "hi": "C# फ़ंक्शन `static string CopySubstringFromIndex(string input, int startIndex)` लिखें ताकि निम्नलिखित समस्या का समाधान किया जा सके:\nनिर्दिष्ट प्रारंभिक इंडेक्स से इनपुट स्ट्रिंग के अंत तक एक उपस्ट्रिंग की प्रतिलिपि बनाता है।\n   यदि प्रारंभिक इंडेक्स स्ट्रिंग की लंबाई से अधिक है, तो एक खाली स्ट्रिंग लौटाता है।\n   उदाहरण:\n   >>> CopySubstringFromIndex(\"Hello World\", 6)\n   \"World\"\n   >>> CopySubstringFromIndex(\"Example\", 3)\n   \"mple\"\n   >>> CopySubstringFromIndex(\"Short\", 10)\n   \"\"",
      "hu": "Írj egy C# függvényt `static string CopySubstringFromIndex(string input, int startIndex)` a következő probléma megoldására:\nEgy részszöveget másol a megadott kezdő indextől a bemeneti szöveg végéig.\n   Ha a kezdő index nagyobb, mint a szöveg hossza, üres sztringet ad vissza.\n   Példák:\n   >>> CopySubstringFromIndex(\"Hello World\", 6)\n   \"World\"\n   >>> CopySubstringFromIndex(\"Example\", 3)\n   \"mple\"\n   >>> CopySubstringFromIndex(\"Short\", 10)\n   \"\""
    },
    "instruction_bertscore": {
      "sq": "0.9906147144961015",
      "hy": "0.9848302005396036",
      "bn": "0.9867308946557264",
      "bg": "0.9865880794117623",
      "zh": "0.978183630729414",
      "fr": "0.9941648352963381",
      "de": "0.9889555549233171",
      "ha": "0.9322372455099479",
      "hi": "0.9688871330058382",
      "hu": "0.9825910402541972"
    },
    "level": "easy",
    "test": "static void Main()\n    {\n        Debug.Assert(CopySubstringFromIndex(\"Hello World\", 6) == \"World\");\n        Debug.Assert(CopySubstringFromIndex(\"Example\", 3) == \"mple\");\n        Debug.Assert(CopySubstringFromIndex(\"Short\", 10) == \"\");\n        Debug.Assert(CopySubstringFromIndex(\"AnotherExample\", 0) == \"AnotherExample\");\n        Debug.Assert(CopySubstringFromIndex(\"Test\", 4) == \"\");\n        Debug.Assert(CopySubstringFromIndex(\"\", 0) == \"\");\n        Debug.Assert(CopySubstringFromIndex(\"LastOne\", 7) == \"\");\n\n    }\n}",
    "entry_point": "CopySubstringFromIndex",
    "signature": "static string CopySubstringFromIndex(string input, int startIndex)",
    "docstring": {
      "en": "Copies a substring from the specified start index in the input string to the end of the string.\n   If the start index is greater than the string's length, returns an empty string.\n   Examples:\n   >>> CopySubstringFromIndex(\"Hello World\", 6)\n   \"World\"\n   >>> CopySubstringFromIndex(\"Example\", 3)\n   \"mple\"\n   >>> CopySubstringFromIndex(\"Short\", 10)\n   \"\"",
      "sq": "Kopjon një nënvarg nga indeksi i specifikuar i fillimit në vargun hyrës deri në fund të vargut.\n   Nëse indeksi i fillimit është më i madh se gjatësia e vargut, kthen një varg bosh.\n   Shembuj:\n   >>> CopySubstringFromIndex(\"Hello World\", 6)\n   \"World\"\n   >>> CopySubstringFromIndex(\"Example\", 3)\n   \"mple\"\n   >>> CopySubstringFromIndex(\"Short\", 10)\n   \"\"",
      "hy": "Պատճենում է ենթատողը մուտքային տողի նշված մեկնարկային ինդեքսից մինչև տողի վերջը:\n   Եթե մեկնարկային ինդեքսը մեծ է տողի երկարությունից, վերադարձնում է դատարկ տող:\n   Օրինակներ:\n   >>> CopySubstringFromIndex(\"Hello World\", 6)\n   \"World\"\n   >>> CopySubstringFromIndex(\"Example\", 3)\n   \"mple\"\n   >>> CopySubstringFromIndex(\"Short\", 10)\n   \"\"",
      "bn": "নির্দিষ্ট শুরু সূচক থেকে ইনপুট স্ট্রিংয়ের শেষ পর্যন্ত একটি উপস্ট্রিং কপি করে।  \nযদি শুরু সূচক স্ট্রিংয়ের দৈর্ঘ্যের চেয়ে বেশি হয়, তাহলে একটি খালি স্ট্রিং ফেরত দেয়।  \nউদাহরণসমূহ:  \n>>> CopySubstringFromIndex(\"Hello World\", 6)  \n\"World\"  \n>>> CopySubstringFromIndex(\"Example\", 3)  \n\"mple\"  \n>>> CopySubstringFromIndex(\"Short\", 10)  \n\"\"  ",
      "bg": "Копира подниз от посочения начален индекс в входния низ до края на низа.\n   Ако началният индекс е по-голям от дължината на низа, връща празен низ.\n   Примери:\n   >>> CopySubstringFromIndex(\"Hello World\", 6)\n   \"World\"\n   >>> CopySubstringFromIndex(\"Example\", 3)\n   \"mple\"\n   >>> CopySubstringFromIndex(\"Short\", 10)\n   \"\"",
      "zh": "从输入字符串的指定起始索引复制子字符串到字符串的结尾。\n如果起始索引大于字符串的长度，则返回一个空字符串。\n示例：\n>>> CopySubstringFromIndex(\"Hello World\", 6)\n\"World\"\n>>> CopySubstringFromIndex(\"Example\", 3)\n\"mple\"\n>>> CopySubstringFromIndex(\"Short\", 10)\n\"\"",
      "fr": "Copie une sous-chaîne à partir de l'indice de départ spécifié dans la chaîne d'entrée jusqu'à la fin de la chaîne.\n   Si l'indice de départ est supérieur à la longueur de la chaîne, retourne une chaîne vide.\n   Exemples :\n   >>> CopySubstringFromIndex(\"Hello World\", 6)\n   \"World\"\n   >>> CopySubstringFromIndex(\"Example\", 3)\n   \"mple\"\n   >>> CopySubstringFromIndex(\"Short\", 10)\n   \"\"",
      "de": "Kopiert einen Teilstring vom angegebenen Startindex im Eingabestring bis zum Ende des Strings.\n   Wenn der Startindex größer als die Länge des Strings ist, wird ein leerer String zurückgegeben.\n   Beispiele:\n   >>> CopySubstringFromIndex(\"Hello World\", 6)\n   \"World\"\n   >>> CopySubstringFromIndex(\"Example\", 3)\n   \"mple\"\n   >>> CopySubstringFromIndex(\"Short\", 10)\n   \"\"",
      "ha": "Kwafi wani ɓangare na rubutu daga takamaiman farawa a cikin rubutun shigarwa zuwa ƙarshen rubutun.\n   Idan farawa ya fi tsawon rubutun, zai dawo da rubutu mara komai.\n   Misalai:\n   >>> CopySubstringFromIndex(\"Hello World\", 6)\n   \"World\"\n   >>> CopySubstringFromIndex(\"Example\", 3)\n   \"mple\"\n   >>> CopySubstringFromIndex(\"Short\", 10)\n   \"\"",
      "hi": "निर्दिष्ट प्रारंभ इंडेक्स से इनपुट स्ट्रिंग के अंत तक एक उपस्ट्रिंग की प्रतिलिपि बनाता है। यदि प्रारंभ इंडेक्स स्ट्रिंग की लंबाई से अधिक है, तो एक खाली स्ट्रिंग लौटाता है।\nउदाहरण:\n>>> CopySubstringFromIndex(\"Hello World\", 6)\n\"World\"\n>>> CopySubstringFromIndex(\"Example\", 3)\n\"mple\"\n>>> CopySubstringFromIndex(\"Short\", 10)\n\"\"",
      "hu": "Lemásol egy részsztringet a megadott kezdő indextől a bemeneti sztring végéig.\n   Ha a kezdő index nagyobb, mint a sztring hossza, üres sztringet ad vissza.\n   Példák:\n   >>> CopySubstringFromIndex(\"Hello World\", 6)\n   \"World\"\n   >>> CopySubstringFromIndex(\"Example\", 3)\n   \"mple\"\n   >>> CopySubstringFromIndex(\"Short\", 10)\n   \"\""
    },
    "docstring_bertscore": {
      "sq": "0.9931657244797326",
      "hy": "0.9804362978807307",
      "bn": "0.9805338253978189",
      "bg": "0.981849553041794",
      "zh": "0.977727178113796",
      "fr": "0.9931657244797326",
      "de": "0.9870600251971011",
      "ha": "0.9316816763341933",
      "hi": "0.9619926724801172",
      "hu": "0.9775595340722024"
    }
  },
  {
    "task_id": "C#/8",
    "prompt": {
      "en": "using System;\nusing System.Collections.Generic;\nusing System.Diagnostics;\n\nclass Program\n{\n/* Converts a given number of seconds into a formatted time string without leading zeros.\n    The format of the output is \"<Hours>:<Minutes>:<Seconds>\". Each component is an integer without leading zeros.\n    Examples:\n    >>> FormatTime(0)\n    \"0:0:0\"\n    >>> FormatTime(3661)\n    \"1:1:1\"\n    >>> FormatTime(5436)\n    \"1:30:36\"\n*/\n   static string FormatTime(int seconds)",
      "sq": "using System;\nusing System.Collections.Generic;\nusing System.Diagnostics;\n\nclass Program\n{\n/* Konverton një numër të dhënë sekondash në një varg kohe të formatuar pa zero në fillim.\n    Formati i daljes është \"<Orë>:<Minuta>:<Sekonda>\". Çdo komponent është një numër i plotë pa zero në fillim.\n    Shembuj:\n    >>> FormatTime(0)\n    \"0:0:0\"\n    >>> FormatTime(3661)\n    \"1:1:1\"\n    >>> FormatTime(5436)\n    \"1:30:36\"\n*/\n   static string FormatTime(int seconds)",
      "hy": "using System;\nusing System.Collections.Generic;\nusing System.Diagnostics;\n\nclass Program\n{\n/* Տրված վայրկյանների քանակը վերածում է ձևաչափված ժամանակի տողի առանց առաջատար զրոների:\n    Արդյունքի ձևաչափը \"<Hours>:<Minutes>:<Seconds>\" է: Յուրաքանչյուր բաղադրիչ ամբողջ թիվ է առանց առաջատար զրոների:\n    Օրինակներ:\n    >>> FormatTime(0)\n    \"0:0:0\"\n    >>> FormatTime(3661)\n    \"1:1:1\"\n    >>> FormatTime(5436)\n    \"1:30:36\"\n*/\n   static string FormatTime(int seconds)",
      "bn": "using System;\nusing System.Collections.Generic;\nusing System.Diagnostics;\n\nclass Program\n{\n/* প্রদত্ত সেকেন্ডের সংখ্যা একটি বিন্যাসিত সময় স্ট্রিংয়ে রূপান্তর করে যা শূন্য দিয়ে শুরু হয় না।\n    আউটপুটের বিন্যাস \"<ঘন্টা>:<মিনিট>:<সেকেন্ড>\"। প্রতিটি উপাদান একটি পূর্ণসংখ্যা যা শূন্য দিয়ে শুরু হয় না।\n    উদাহরণ:\n    >>> FormatTime(0)\n    \"0:0:0\"\n    >>> FormatTime(3661)\n    \"1:1:1\"\n    >>> FormatTime(5436)\n    \"1:30:36\"\n*/\n   static string FormatTime(int seconds)",
      "bg": "using System;\nusing System.Collections.Generic;\nusing System.Diagnostics;\n\nclass Program\n{\n/* Преобразува даден брой секунди в форматиран низ за време без водещи нули.\n    Форматът на изхода е \"<Часове>:<Минути>:<Секунди>\". Всеки компонент е цяло число без водещи нули.\n    Примери:\n    >>> FormatTime(0)\n    \"0:0:0\"\n    >>> FormatTime(3661)\n    \"1:1:1\"\n    >>> FormatTime(5436)\n    \"1:30:36\"\n*/\n   static string FormatTime(int seconds)",
      "zh": "using System;\nusing System.Collections.Generic;\nusing System.Diagnostics;\n\nclass Program\n{\n/* 将给定的秒数转换为无前导零的格式化时间字符串。\n    输出格式为\"<小时>:<分钟>:<秒>\"。每个部分都是没有前导零的整数。\n    例子:\n    >>> FormatTime(0)\n    \"0:0:0\"\n    >>> FormatTime(3661)\n    \"1:1:1\"\n    >>> FormatTime(5436)\n    \"1:30:36\"\n*/\n   static string FormatTime(int seconds)",
      "fr": "using System;\nusing System.Collections.Generic;\nusing System.Diagnostics;\n\nclass Program\n{\n/* Convertit un nombre donné de secondes en une chaîne de temps formatée sans zéros initiaux.\n    Le format de la sortie est \"<Heures>:<Minutes>:<Secondes>\". Chaque composant est un entier sans zéros initiaux.\n    Exemples :\n    >>> FormatTime(0)\n    \"0:0:0\"\n    >>> FormatTime(3661)\n    \"1:1:1\"\n    >>> FormatTime(5436)\n    \"1:30:36\"\n*/\n   static string FormatTime(int seconds)",
      "de": "using System;\nusing System.Collections.Generic;\nusing System.Diagnostics;\n\nclass Program\n{\n/* Konvertiert eine gegebene Anzahl von Sekunden in einen formatierten Zeitstring ohne führende Nullen.\n    Das Format der Ausgabe ist \"<Stunden>:<Minuten>:<Sekunden>\". Jede Komponente ist eine ganze Zahl ohne führende Nullen.\n    Beispiele:\n    >>> FormatTime(0)\n    \"0:0:0\"\n    >>> FormatTime(3661)\n    \"1:1:1\"\n    >>> FormatTime(5436)\n    \"1:30:36\"\n*/\n   static string FormatTime(int seconds)",
      "ha": "using System;\nusing System.Collections.Generic;\nusing System.Diagnostics;\n\nclass Program\n{\n/* Canza adadin da aka bayar na daƙiƙoƙi zuwa tsari na lokaci ba tare da sifili na farko ba.\n    Tsarin fitarwa shine \"<Hours>:<Minutes>:<Seconds>\". Kowanne bangare lamba ce ba tare da sifili na farko ba.\n    Misalai:\n    >>> FormatTime(0)\n    \"0:0:0\"\n    >>> FormatTime(3661)\n    \"1:1:1\"\n    >>> FormatTime(5436)\n    \"1:30:36\"\n*/\n   static string FormatTime(int seconds)",
      "hi": "using System;\nusing System.Collections.Generic;\nusing System.Diagnostics;\n\nclass Program\n{\n/* दिए गए सेकंड की संख्या को अग्रणी शून्य के बिना एक स्वरूपित समय स्ट्रिंग में परिवर्तित करता है।\n    आउटपुट का प्रारूप \"<घंटे>:<मिनट>:<सेकंड>\" है। प्रत्येक घटक अग्रणी शून्य के बिना एक पूर्णांक है।\n    उदाहरण:\n    >>> FormatTime(0)\n    \"0:0:0\"\n    >>> FormatTime(3661)\n    \"1:1:1\"\n    >>> FormatTime(5436)\n    \"1:30:36\"\n*/\n   static string FormatTime(int seconds)",
      "hu": "using System;\nusing System.Collections.Generic;\nusing System.Diagnostics;\n\nclass Program\n{\n/* Átkonvertálja a megadott másodpercek számát egy formázott idő stringgé vezető nullák nélkül.\n    A kimenet formátuma \"<Órák>:<Percek>:<Másodpercek>\". Minden komponens egy egész szám vezető nullák nélkül.\n    Példák:\n    >>> FormatTime(0)\n    \"0:0:0\"\n    >>> FormatTime(3661)\n    \"1:1:1\"\n    >>> FormatTime(5436)\n    \"1:30:36\"\n*/\n   static string FormatTime(int seconds)"
    },
    "prompt_bertscore": {
      "sq": "0.9919175311653093",
      "hy": "0.9906218651898188",
      "bn": "0.9581946609643491",
      "bg": "0.9919175311653093",
      "zh": "0.9735734195855943",
      "fr": "0.9919175311653093",
      "de": "0.9951887749105729",
      "ha": "0.9647667443816506",
      "hi": "0.9834735550371352",
      "hu": "0.9903257072916958"
    },
    "canonical_solution": "{\n    int hours = seconds / 3600;\n    int minutes = (seconds % 3600) / 60;\n    int remainingSeconds = seconds % 60;\n\n    return $\"{hours}:{minutes}:{remainingSeconds}\";\n}",
    "instruction": {
      "en": "Write a C# function `static string FormatTime(int seconds)` to solve the following problem:\nConverts a given number of seconds into a formatted time string without leading zeros.\n    The format of the output is \"<Hours>:<Minutes>:<Seconds>\". Each component is an integer without leading zeros.\n    Examples:\n    >>> FormatTime(0)\n    \"0:0:0\"\n    >>> FormatTime(3661)\n    \"1:1:1\"\n    >>> FormatTime(5436)\n    \"1:30:36\"",
      "sq": "Shkruani një funksion në C# `static string FormatTime(int seconds)` për të zgjidhur problemin e mëposhtëm:\nKonverton një numër të dhënë sekondash në një varg kohe të formatuar pa zero në fillim.\n    Formati i daljes është \"<Orë>:<Minuta>:<Sekonda>\". Çdo komponent është një numër i plotë pa zero në fillim.\n    Shembuj:\n    >>> FormatTime(0)\n    \"0:0:0\"\n    >>> FormatTime(3661)\n    \"1:1:1\"\n    >>> FormatTime(5436)\n    \"1:30:36\"",
      "hy": "Գրեք C# ֆունկցիա `static string FormatTime(int seconds)`՝ հետևյալ խնդիրը լուծելու համար:\nՓոխակերպում է տրված վայրկյանների քանակը ձևավորված ժամանակի տողի՝ առանց զրոյականների:\n    Արդյունքի ձևաչափը \"<Hours>:<Minutes>:<Seconds>\" է: Յուրաքանչյուր բաղադրիչ ամբողջ թիվ է՝ առանց զրոյականների:\n    Օրինակներ:\n    >>> FormatTime(0)\n    \"0:0:0\"\n    >>> FormatTime(3661)\n    \"1:1:1\"\n    >>> FormatTime(5436)\n    \"1:30:36\"",
      "bn": "C# ফাংশন `static string FormatTime(int seconds)` লিখুন নিম্নলিখিত সমস্যার সমাধানের জন্য:\nপ্রদত্ত সেকেন্ডের সংখ্যা একটি বিন্যাসিত সময় স্ট্রিংয়ে রূপান্তর করে যা শূন্য দিয়ে শুরু হয় না।\n    আউটপুটের বিন্যাস \"<Hours>:<Minutes>:<Seconds>\"। প্রতিটি উপাদান শূন্য দিয়ে শুরু ছাড়া একটি পূর্ণসংখ্যা।\n    উদাহরণ:\n    >>> FormatTime(0)\n    \"0:0:0\"\n    >>> FormatTime(3661)\n    \"1:1:1\"\n    >>> FormatTime(5436)\n    \"1:30:36\"",
      "bg": "Напишете C# функция `static string FormatTime(int seconds)`, за да решите следния проблем:\nПреобразува даден брой секунди във форматиран низ за време без водещи нули.\n    Форматът на изхода е \"<Часове>:<Минути>:<Секунди>\". Всеки компонент е цяло число без водещи нули.\n    Примери:\n    >>> FormatTime(0)\n    \"0:0:0\"\n    >>> FormatTime(3661)\n    \"1:1:1\"\n    >>> FormatTime(5436)\n    \"1:30:36\"",
      "zh": "编写一个 C# 函数 `static string FormatTime(int seconds)` 来解决以下问题：\n将给定的秒数转换为没有前导零的格式化时间字符串。\n    输出的格式为 \"<Hours>:<Minutes>:<Seconds>\"。每个部分都是没有前导零的整数。\n    示例：\n    >>> FormatTime(0)\n    \"0:0:0\"\n    >>> FormatTime(3661)\n    \"1:1:1\"\n    >>> FormatTime(5436)\n    \"1:30:36\"",
      "fr": "Écrire une fonction C# `static string FormatTime(int seconds)` pour résoudre le problème suivant :\nConvertit un nombre donné de secondes en une chaîne de temps formatée sans zéros initiaux.\n    Le format de la sortie est \"<Heures>:<Minutes>:<Secondes>\". Chaque composant est un entier sans zéros initiaux.\n    Exemples :\n    >>> FormatTime(0)\n    \"0:0:0\"\n    >>> FormatTime(3661)\n    \"1:1:1\"\n    >>> FormatTime(5436)\n    \"1:30:36\"",
      "de": "Schreiben Sie eine C#-Funktion `static string FormatTime(int seconds)`, um das folgende Problem zu lösen:\nKonvertiert eine gegebene Anzahl von Sekunden in einen formatierten Zeitstring ohne führende Nullen.\n    Das Format der Ausgabe ist \"<Stunden>:<Minuten>:<Sekunden>\". Jede Komponente ist eine Ganzzahl ohne führende Nullen.\n    Beispiele:\n    >>> FormatTime(0)\n    \"0:0:0\"\n    >>> FormatTime(3661)\n    \"1:1:1\"\n    >>> FormatTime(5436)\n    \"1:30:36\"",
      "ha": "Rubuta aikin C# `static string FormatTime(int seconds)` don warware matsalar mai zuwa:  \nCanza adadin da aka bayar na daƙiƙoƙi zuwa tsari na lokaci ba tare da sifili na farko ba.  \nTsarin fitarwa shine \"<Hours>:<Minutes>:<Seconds>\". Kowanne bangare yana da adadi ba tare da sifili na farko ba.  \nMisalai:  \n>>> FormatTime(0)  \n\"0:0:0\"  \n>>> FormatTime(3661)  \n\"1:1:1\"  \n>>> FormatTime(5436)  \n\"1:30:36\"",
      "hi": "C# फ़ंक्शन `static string FormatTime(int seconds)` लिखें ताकि निम्नलिखित समस्या का समाधान किया जा सके:\nदिए गए सेकंड की संख्या को अग्रणी शून्य के बिना एक स्वरूपित समय स्ट्रिंग में परिवर्तित करता है।\n    आउटपुट का प्रारूप \"<Hours>:<Minutes>:<Seconds>\" है। प्रत्येक घटक अग्रणी शून्य के बिना एक पूर्णांक है।\n    उदाहरण:\n    >>> FormatTime(0)\n    \"0:0:0\"\n    >>> FormatTime(3661)\n    \"1:1:1\"\n    >>> FormatTime(5436)\n    \"1:30:36\"",
      "hu": "Írj egy C# függvényt `static string FormatTime(int seconds)` a következő probléma megoldására:\nÁtalakítja a megadott másodpercek számát egy formázott idő stringgé vezető nullák nélkül.\n    A kimenet formátuma \"<Órák>:<Percek>:<Másodpercek>\". Minden összetevő egy egész szám vezető nullák nélkül.\n    Példák:\n    >>> FormatTime(0)\n    \"0:0:0\"\n    >>> FormatTime(3661)\n    \"1:1:1\"\n    >>> FormatTime(5436)\n    \"1:30:36\""
    },
    "instruction_bertscore": {
      "sq": "0.9916076677708949",
      "hy": "0.9936972593793819",
      "bn": "0.9647840252248006",
      "bg": "0.9836457675774924",
      "zh": "0.9798696054036382",
      "fr": "0.992946039278308",
      "de": "0.9950040486562105",
      "ha": "0.9531564013493992",
      "hi": "0.975416113630455",
      "hu": "0.9913101194601047"
    },
    "level": "easy",
    "test": "    static void Main()\n    {\n        Debug.Assert(FormatTime(0) == \"0:0:0\");\n        Debug.Assert(FormatTime(3661) == \"1:1:1\");\n        Debug.Assert(FormatTime(5436) == \"1:30:36\");\n        Debug.Assert(FormatTime(3600) == \"1:0:0\");\n        Debug.Assert(FormatTime(7200) == \"2:0:0\");\n        Debug.Assert(FormatTime(86399) == \"23:59:59\");\n        Debug.Assert(FormatTime(12345) == \"3:25:45\");\n\n    }\n}",
    "entry_point": "FormatTime",
    "signature": "static string FormatTime(int seconds)",
    "docstring": {
      "en": "Converts a given number of seconds into a formatted time string without leading zeros.\n    The format of the output is \"<Hours>:<Minutes>:<Seconds>\". Each component is an integer without leading zeros.\n    Examples:\n    >>> FormatTime(0)\n    \"0:0:0\"\n    >>> FormatTime(3661)\n    \"1:1:1\"\n    >>> FormatTime(5436)\n    \"1:30:36\"",
      "sq": "Konverton një numër të dhënë sekondash në një varg kohe të formatuar pa zero udhëheqëse.  \n    Formati i daljes është \"<Orë>:<Minuta>:<Sekonda>\". Çdo komponent është një numër i plotë pa zero udhëheqëse.  \n    Shembuj:  \n    >>> FormatTime(0)  \n    \"0:0:0\"  \n    >>> FormatTime(3661)  \n    \"1:1:1\"  \n    >>> FormatTime(5436)  \n    \"1:30:36\"",
      "hy": "Վերափոխում է տրված վայրկյանների քանակը ձևաչափված ժամանակի տողի՝ առանց առաջատար զրոների:\n    Արդյունքի ձևաչափը \"<Ժամեր>:<Րոպեներ>:<Վայրկյաններ>\" է: Յուրաքանչյուր բաղադրիչ ամբողջ թիվ է՝ առանց առաջատար զրոների:\n    Օրինակներ:\n    >>> FormatTime(0)\n    \"0:0:0\"\n    >>> FormatTime(3661)\n    \"1:1:1\"\n    >>> FormatTime(5436)\n    \"1:30:36\"",
      "bn": "একটি প্রদত্ত সেকেন্ডের সংখ্যা একটি বিন্যাসিত সময় স্ট্রিংয়ে রূপান্তর করে যা শূন্য দিয়ে শুরু হয় না।\n    আউটপুটের বিন্যাস \"<ঘণ্টা>:<মিনিট>:<সেকেন্ড>\"। প্রতিটি উপাদান একটি পূর্ণসংখ্যা যা শূন্য দিয়ে শুরু হয় না।\n    উদাহরণ:\n    >>> FormatTime(0)\n    \"0:0:0\"\n    >>> FormatTime(3661)\n    \"1:1:1\"\n    >>> FormatTime(5436)\n    \"1:30:36\"",
      "bg": "Преобразува даден брой секунди в форматиран низ за време без водещи нули.\nФорматът на изхода е \"<Часове>:<Минути>:<Секунди>\". Всеки компонент е цяло число без водещи нули.\nПримери:\n>>> FormatTime(0)\n\"0:0:0\"\n>>> FormatTime(3661)\n\"1:1:1\"\n>>> FormatTime(5436)\n\"1:30:36\"",
      "zh": "将给定的秒数转换为无前导零的格式化时间字符串。  \n输出格式为 \"<小时>:<分钟>:<秒>\"。每个部分都是没有前导零的整数。  \n示例：  \n>>> FormatTime(0)  \n\"0:0:0\"  \n>>> FormatTime(3661)  \n\"1:1:1\"  \n>>> FormatTime(5436)  \n\"1:30:36\"  ",
      "fr": "Convertit un nombre donné de secondes en une chaîne de temps formatée sans zéros initiaux.\n    Le format de la sortie est \"<Heures>:<Minutes>:<Secondes>\". Chaque composant est un entier sans zéros initiaux.\n    Exemples :\n    >>> FormatTime(0)\n    \"0:0:0\"\n    >>> FormatTime(3661)\n    \"1:1:1\"\n    >>> FormatTime(5436)\n    \"1:30:36\"",
      "de": "Konvertiert eine gegebene Anzahl von Sekunden in einen formatierten Zeitstring ohne führende Nullen.\n    Das Format der Ausgabe ist \"<Stunden>:<Minuten>:<Sekunden>\". Jede Komponente ist eine ganze Zahl ohne führende Nullen.\n    Beispiele:\n    >>> FormatTime(0)\n    \"0:0:0\"\n    >>> FormatTime(3661)\n    \"1:1:1\"\n    >>> FormatTime(5436)\n    \"1:30:36\"",
      "ha": "Canza adadin da aka bayar na daƙiƙoƙi zuwa tsari na lokaci ba tare da sifili na farko ba.\n    Tsarin fitarwa shine \"<Hours>:<Minutes>:<Seconds>\". Kowanne bangare yana da adadi ba tare da sifili a gaba ba.  \n    Misalai:  \n    >>> FormatTime(0)  \n    \"0:0:0\"  \n    >>> FormatTime(3661)  \n    \"1:1:1\"  \n    >>> FormatTime(5436)  \n    \"1:30:36\"",
      "hi": "दिए गए सेकंड की संख्या को बिना अग्रणी शून्य के एक स्वरूपित समय स्ट्रिंग में परिवर्तित करता है।\n    आउटपुट का प्रारूप \"<घंटे>:<मिनट>:<सेकंड>\" है। प्रत्येक घटक अग्रणी शून्य के बिना एक पूर्णांक है।  \n    उदाहरण:  \n    >>> FormatTime(0)  \n    \"0:0:0\"  \n    >>> FormatTime(3661)  \n    \"1:1:1\"  \n    >>> FormatTime(5436)  \n    \"1:30:36\"  ",
      "hu": "Átalakít egy adott számú másodpercet egy formázott idő karakterlánccá vezető nullák nélkül.\n    A kimenet formátuma \"<Órák>:<Percek>:<Másodpercek>\". Minden összetevő egy egész szám vezető nullák nélkül.\n    Példák:\n    >>> FormatTime(0)\n    \"0:0:0\"\n    >>> FormatTime(3661)\n    \"1:1:1\"\n    >>> FormatTime(5436)\n    \"1:30:36\""
    },
    "docstring_bertscore": {
      "sq": "0.9910993726258267",
      "hy": "0.9913923524378532",
      "bn": "0.9478748195176815",
      "bg": "0.9810160999629716",
      "zh": "0.9575304409701685",
      "fr": "0.999999801369619",
      "de": "0.9940190405966585",
      "ha": "0.9769191497237459",
      "hi": "0.9906486802912585",
      "hu": "0.9910993726258267"
    }
  },
  {
    "task_id": "C#/9",
    "prompt": {
      "en": "using System;\nusing System.Collections.Generic;\nusing System.Diagnostics;\n\n\nclass Program\n{\n/* Calculates the area of intersection between two rectangles.\n   Each rectangle is defined by the coordinates of its top-left (x1, y1) and bottom-right (x2, y2) corners.\n   \n   Examples:\n   >>> CalculateIntersectionArea(0, 0, 2, 2, 1, 1, 3, 3)\n   1.00\n   >>> CalculateIntersectionArea(1, 1, 3, 4, 2, 2, 5, 5)\n   2.00\n   >>> CalculateIntersectionArea(0, 0, 1, 1, 2, 2, 3, 3)\n   0.00 (No Intersection)\n*/\nstatic double CalculateIntersectionArea(int x1Rect1, int y1Rect1, int x2Rect1, int y2Rect1, int x1Rect2, int y1Rect2, int x2Rect2, int y2Rect2)",
      "sq": "using System;\nusing System.Collections.Generic;\nusing System.Diagnostics;\n\n\nclass Program\n{\n/* Llogarit sipërfaqen e ndërprerjes midis dy drejtkëndëshave.\n   Çdo drejtkëndësh përcaktohet nga koordinatat e këndeve të tij të sipërme-majtas (x1, y1) dhe të poshtme-djathtas (x2, y2).\n   \n   Shembuj:\n   >>> CalculateIntersectionArea(0, 0, 2, 2, 1, 1, 3, 3)\n   1.00\n   >>> CalculateIntersectionArea(1, 1, 3, 4, 2, 2, 5, 5)\n   2.00\n   >>> CalculateIntersectionArea(0, 0, 1, 1, 2, 2, 3, 3)\n   0.00 (Pa Ndërprerje)\n*/\nstatic double CalculateIntersectionArea(int x1Rect1, int y1Rect1, int x2Rect1, int y2Rect1, int x1Rect2, int y1Rect2, int x2Rect2, int y2Rect2)",
      "hy": "using System;\nusing System.Collections.Generic;\nusing System.Diagnostics;\n\n\nclass Program\n{\n/* Հաշվարկում է երկու ուղղանկյունների հատման մակերեսը։\n   Յուրաքանչյուր ուղղանկյուն սահմանվում է իր վերևի ձախ (x1, y1) և ներքևի աջ (x2, y2) անկյունների կոորդինատներով։\n   \n   Օրինակներ:\n   >>> CalculateIntersectionArea(0, 0, 2, 2, 1, 1, 3, 3)\n   1.00\n   >>> CalculateIntersectionArea(1, 1, 3, 4, 2, 2, 5, 5)\n   2.00\n   >>> CalculateIntersectionArea(0, 0, 1, 1, 2, 2, 3, 3)\n   0.00 (Հատում չկա)\n*/\nstatic double CalculateIntersectionArea(int x1Rect1, int y1Rect1, int x2Rect1, int y2Rect1, int x1Rect2, int y1Rect2, int x2Rect2, int y2Rect2)",
      "bn": "using System;\nusing System.Collections.Generic;\nusing System.Diagnostics;\n\n\nclass Program\n{\n/* দুটি আয়তক্ষেত্রের মধ্যে ছেদ এলাকার হিসাব করে।\n   প্রতিটি আয়তক্ষেত্র তার উপরের-বাম (x1, y1) এবং নিচের-ডান (x2, y2) কোণের স্থানাঙ্ক দ্বারা সংজ্ঞায়িত হয়।\n   \n   উদাহরণ:\n   >>> CalculateIntersectionArea(0, 0, 2, 2, 1, 1, 3, 3)\n   1.00\n   >>> CalculateIntersectionArea(1, 1, 3, 4, 2, 2, 5, 5)\n   2.00\n   >>> CalculateIntersectionArea(0, 0, 1, 1, 2, 2, 3, 3)\n   0.00 (কোনো ছেদ নেই)\n*/\nstatic double CalculateIntersectionArea(int x1Rect1, int y1Rect1, int x2Rect1, int y2Rect1, int x1Rect2, int y1Rect2, int x2Rect2, int y2Rect2)",
      "bg": "using System;\nusing System.Collections.Generic;\nusing System.Diagnostics;\n\n\nclass Program\n{\n/* Изчислява площта на пресичане между два правоъгълника.\n   Всеки правоъгълник е определен чрез координатите на горния ляв (x1, y1) и долния десен (x2, y2) ъгъл.\n   \n   Примери:\n   >>> CalculateIntersectionArea(0, 0, 2, 2, 1, 1, 3, 3)\n   1.00\n   >>> CalculateIntersectionArea(1, 1, 3, 4, 2, 2, 5, 5)\n   2.00\n   >>> CalculateIntersectionArea(0, 0, 1, 1, 2, 2, 3, 3)\n   0.00 (Няма пресичане)\n*/\nstatic double CalculateIntersectionArea(int x1Rect1, int y1Rect1, int x2Rect1, int y2Rect1, int x1Rect2, int y1Rect2, int x2Rect2, int y2Rect2)",
      "zh": "using System;\nusing System.Collections.Generic;\nusing System.Diagnostics;\n\n\nclass Program\n{\n/* 计算两个矩形之间的交集面积。\n   每个矩形由其左上角 (x1, y1) 和右下角 (x2, y2) 的坐标定义。\n   \n   示例:\n   >>> CalculateIntersectionArea(0, 0, 2, 2, 1, 1, 3, 3)\n   1.00\n   >>> CalculateIntersectionArea(1, 1, 3, 4, 2, 2, 5, 5)\n   2.00\n   >>> CalculateIntersectionArea(0, 0, 1, 1, 2, 2, 3, 3)\n   0.00 (无交集)\n*/\nstatic double CalculateIntersectionArea(int x1Rect1, int y1Rect1, int x2Rect1, int y2Rect1, int x1Rect2, int y1Rect2, int x2Rect2, int y2Rect2)",
      "fr": "using System;\nusing System.Collections.Generic;\nusing System.Diagnostics;\n\n\nclass Program\n{\n/* Calcule la surface d'intersection entre deux rectangles.\n   Chaque rectangle est défini par les coordonnées de son coin supérieur gauche (x1, y1) et de son coin inférieur droit (x2, y2).\n   \n   Exemples :\n   >>> CalculateIntersectionArea(0, 0, 2, 2, 1, 1, 3, 3)\n   1.00\n   >>> CalculateIntersectionArea(1, 1, 3, 4, 2, 2, 5, 5)\n   2.00\n   >>> CalculateIntersectionArea(0, 0, 1, 1, 2, 2, 3, 3)\n   0.00 (Pas d'intersection)\n*/\nstatic double CalculateIntersectionArea(int x1Rect1, int y1Rect1, int x2Rect1, int y2Rect1, int x1Rect2, int y1Rect2, int x2Rect2, int y2Rect2)",
      "de": "using System;\nusing System.Collections.Generic;\nusing System.Diagnostics;\n\n\nclass Program\n{\n/* Berechnet die Schnittfläche zwischen zwei Rechtecken.\n   Jedes Rechteck wird durch die Koordinaten seiner oberen linken (x1, y1) und unteren rechten (x2, y2) Ecken definiert.\n   \n   Beispiele:\n   >>> CalculateIntersectionArea(0, 0, 2, 2, 1, 1, 3, 3)\n   1.00\n   >>> CalculateIntersectionArea(1, 1, 3, 4, 2, 2, 5, 5)\n   2.00\n   >>> CalculateIntersectionArea(0, 0, 1, 1, 2, 2, 3, 3)\n   0.00 (Keine Schnittmenge)\n*/\nstatic double CalculateIntersectionArea(int x1Rect1, int y1Rect1, int x2Rect1, int y2Rect1, int x1Rect2, int y1Rect2, int x2Rect2, int y2Rect2)",
      "ha": "using System;\nusing System.Collections.Generic;\nusing System.Diagnostics;\n\n\nclass Program\n{\n/* Lissafi yankin da ya ratsa tsakanin murabba'i biyu.\n   Ana bayyana kowane murabba'i ta hanyar daidaitattun kusurwar sama-hagu (x1, y1) da ƙasa-dama (x2, y2).\n   \n   Misalai:\n   >>> CalculateIntersectionArea(0, 0, 2, 2, 1, 1, 3, 3)\n   1.00\n   >>> CalculateIntersectionArea(1, 1, 3, 4, 2, 2, 5, 5)\n   2.00\n   >>> CalculateIntersectionArea(0, 0, 1, 1, 2, 2, 3, 3)\n   0.00 (Babu Ratsa)\n*/\nstatic double CalculateIntersectionArea(int x1Rect1, int y1Rect1, int x2Rect1, int y2Rect1, int x1Rect2, int y1Rect2, int x2Rect2, int y2Rect2)",
      "hi": "using System;\nusing System.Collections.Generic;\nusing System.Diagnostics;\n\n\nclass Program\n{\n/* दो आयतों के बीच प्रतिच्छेदन का क्षेत्रफल गणना करता है।\n   प्रत्येक आयत को इसके शीर्ष-बाएँ (x1, y1) और नीचे-दाएँ (x2, y2) कोनों के निर्देशांक द्वारा परिभाषित किया गया है।\n   \n   उदाहरण:\n   >>> CalculateIntersectionArea(0, 0, 2, 2, 1, 1, 3, 3)\n   1.00\n   >>> CalculateIntersectionArea(1, 1, 3, 4, 2, 2, 5, 5)\n   2.00\n   >>> CalculateIntersectionArea(0, 0, 1, 1, 2, 2, 3, 3)\n   0.00 (कोई प्रतिच्छेदन नहीं)\n*/\nstatic double CalculateIntersectionArea(int x1Rect1, int y1Rect1, int x2Rect1, int y2Rect1, int x1Rect2, int y1Rect2, int x2Rect2, int y2Rect2)",
      "hu": "using System;\nusing System.Collections.Generic;\nusing System.Diagnostics;\n\n\nclass Program\n{\n/* Két téglalap metszetének területét számítja ki.\n   Minden téglalap a bal felső (x1, y1) és a jobb alsó (x2, y2) sarkok koordinátáival van meghatározva.\n   \n   Példák:\n   >>> CalculateIntersectionArea(0, 0, 2, 2, 1, 1, 3, 3)\n   1.00\n   >>> CalculateIntersectionArea(1, 1, 3, 4, 2, 2, 5, 5)\n   2.00\n   >>> CalculateIntersectionArea(0, 0, 1, 1, 2, 2, 3, 3)\n   0.00 (Nincs metszet)\n*/\nstatic double CalculateIntersectionArea(int x1Rect1, int y1Rect1, int x2Rect1, int y2Rect1, int x1Rect2, int y1Rect2, int x2Rect2, int y2Rect2)"
    },
    "prompt_bertscore": {
      "sq": "0.9939495199632963",
      "hy": "0.9808274011009884",
      "bn": "0.9905007006573875",
      "bg": "0.9819254298473493",
      "zh": "0.9705818474168278",
      "fr": "0.9722102192805518",
      "de": "0.9746285441696516",
      "ha": "0.9942069449371175",
      "hi": "0.9964355778123289",
      "hu": "0.9868955592416043"
    },
    "canonical_solution": "{\n    int xOverlap = Math.Max(0, Math.Min(x2Rect1, x2Rect2) - Math.Max(x1Rect1, x1Rect2));\n    int yOverlap = Math.Max(0, Math.Min(y2Rect1, y2Rect2) - Math.Max(y1Rect1, y1Rect2));\n    return xOverlap * yOverlap;\n}",
    "instruction": {
      "en": "Write a C# function `static double CalculateIntersectionArea(int x1Rect1, int y1Rect1, int x2Rect1, int y2Rect1, int x1Rect2, int y1Rect2, int x2Rect2, int y2Rect2)` to solve the following problem:\nCalculates the area of intersection between two rectangles.\n   Each rectangle is defined by the coordinates of its top-left (x1, y1) and bottom-right (x2, y2) corners.\n   \n   Examples:\n   >>> CalculateIntersectionArea(0, 0, 2, 2, 1, 1, 3, 3)\n   1.00\n   >>> CalculateIntersectionArea(1, 1, 3, 4, 2, 2, 5, 5)\n   2.00\n   >>> CalculateIntersectionArea(0, 0, 1, 1, 2, 2, 3, 3)\n   0.00 (No Intersection)",
      "sq": "Shkruani një funksion në C# `static double CalculateIntersectionArea(int x1Rect1, int y1Rect1, int x2Rect1, int y2Rect1, int x1Rect2, int y1Rect2, int x2Rect2, int y2Rect2)` për të zgjidhur problemin e mëposhtëm:\nLlogarit sipërfaqen e ndërprerjes midis dy drejtkëndëshave.\n   Çdo drejtkëndësh përcaktohet nga koordinatat e këndit të sipërm të majtë (x1, y1) dhe këndit të poshtëm të djathtë (x2, y2).\n   \n   Shembuj:\n   >>> CalculateIntersectionArea(0, 0, 2, 2, 1, 1, 3, 3)\n   1.00\n   >>> CalculateIntersectionArea(1, 1, 3, 4, 2, 2, 5, 5)\n   2.00\n   >>> CalculateIntersectionArea(0, 0, 1, 1, 2, 2, 3, 3)\n   0.00 (Pa Ndërprerje)",
      "hy": "Գրեք C# ֆունկցիա `static double CalculateIntersectionArea(int x1Rect1, int y1Rect1, int x2Rect1, int y2Rect1, int x1Rect2, int y1Rect2, int x2Rect2, int y2Rect2)` հետևյալ խնդիրը լուծելու համար:\nՀաշվարկում է երկու ուղղանկյունների հատման մակերեսը:\n   Յուրաքանչյուր ուղղանկյուն սահմանվում է իր վերին ձախ (x1, y1) և ներքևի աջ (x2, y2) անկյունների կոորդինատներով։\n   \n   Օրինակներ:\n   >>> CalculateIntersectionArea(0, 0, 2, 2, 1, 1, 3, 3)\n   1.00\n   >>> CalculateIntersectionArea(1, 1, 3, 4, 2, 2, 5, 5)\n   2.00\n   >>> CalculateIntersectionArea(0, 0, 1, 1, 2, 2, 3, 3)\n   0.00 (Ոչ մի հատում)",
      "bn": "একটি C# ফাংশন `static double CalculateIntersectionArea(int x1Rect1, int y1Rect1, int x2Rect1, int y2Rect1, int x1Rect2, int y1Rect2, int x2Rect2, int y2Rect2)` লিখুন নিম্নলিখিত সমস্যার সমাধানের জন্য:\nদুটি আয়তক্ষেত্রের মধ্যে ছেদ ক্ষেত্রফল গণনা করে।\n   প্রতিটি আয়তক্ষেত্র তার উপরের-বাম (x1, y1) এবং নিচের-ডান (x2, y2) কোণের স্থানাঙ্ক দ্বারা সংজ্ঞায়িত হয়।\n   \n   উদাহরণ:\n   >>> CalculateIntersectionArea(0, 0, 2, 2, 1, 1, 3, 3)\n   1.00\n   >>> CalculateIntersectionArea(1, 1, 3, 4, 2, 2, 5, 5)\n   2.00\n   >>> CalculateIntersectionArea(0, 0, 1, 1, 2, 2, 3, 3)\n   0.00 (কোনো ছেদ নেই)",
      "bg": "Напишете C# функция `static double CalculateIntersectionArea(int x1Rect1, int y1Rect1, int x2Rect1, int y2Rect1, int x1Rect2, int y1Rect2, int x2Rect2, int y2Rect2)`, за да решите следния проблем:\nИзчислява площта на пресичане между два правоъгълника.\n   Всеки правоъгълник е определен от координатите на горния ляв (x1, y1) и долния десен (x2, y2) ъгъл.\n   \n   Примери:\n   >>> CalculateIntersectionArea(0, 0, 2, 2, 1, 1, 3, 3)\n   1.00\n   >>> CalculateIntersectionArea(1, 1, 3, 4, 2, 2, 5, 5)\n   2.00\n   >>> CalculateIntersectionArea(0, 0, 1, 1, 2, 2, 3, 3)\n   0.00 (Няма пресичане)",
      "zh": "编写一个 C# 函数 `static double CalculateIntersectionArea(int x1Rect1, int y1Rect1, int x2Rect1, int y2Rect1, int x1Rect2, int y1Rect2, int x2Rect2, int y2Rect2)` 来解决以下问题：\n计算两个矩形之间的交集面积。\n每个矩形由其左上角 (x1, y1) 和右下角 (x2, y2) 的坐标定义。\n\n示例：\n>>> CalculateIntersectionArea(0, 0, 2, 2, 1, 1, 3, 3)\n1.00\n>>> CalculateIntersectionArea(1, 1, 3, 4, 2, 2, 5, 5)\n2.00\n>>> CalculateIntersectionArea(0, 0, 1, 1, 2, 2, 3, 3)\n0.00 (无交集)",
      "fr": "Écrire une fonction C# `static double CalculateIntersectionArea(int x1Rect1, int y1Rect1, int x2Rect1, int y2Rect1, int x1Rect2, int y1Rect2, int x2Rect2, int y2Rect2)` pour résoudre le problème suivant :\nCalcule la surface d'intersection entre deux rectangles.\n   Chaque rectangle est défini par les coordonnées de son coin supérieur gauche (x1, y1) et de son coin inférieur droit (x2, y2).\n   \n   Exemples :\n   >>> CalculateIntersectionArea(0, 0, 2, 2, 1, 1, 3, 3)\n   1.00\n   >>> CalculateIntersectionArea(1, 1, 3, 4, 2, 2, 5, 5)\n   2.00\n   >>> CalculateIntersectionArea(0, 0, 1, 1, 2, 2, 3, 3)\n   0.00 (Pas d'intersection)",
      "de": "Schreiben Sie eine C#-Funktion `static double CalculateIntersectionArea(int x1Rect1, int y1Rect1, int x2Rect1, int y2Rect1, int x1Rect2, int y1Rect2, int x2Rect2, int y2Rect2)`, um das folgende Problem zu lösen:\nBerechnet die Fläche des Schnittbereichs zwischen zwei Rechtecken.\n   Jedes Rechteck wird durch die Koordinaten seiner oberen linken (x1, y1) und unteren rechten (x2, y2) Ecken definiert.\n   \n   Beispiele:\n   >>> CalculateIntersectionArea(0, 0, 2, 2, 1, 1, 3, 3)\n   1.00\n   >>> CalculateIntersectionArea(1, 1, 3, 4, 2, 2, 5, 5)\n   2.00\n   >>> CalculateIntersectionArea(0, 0, 1, 1, 2, 2, 3, 3)\n   0.00 (Keine Schnittmenge)",
      "ha": "Rubuta wani aikin C# `static double CalculateIntersectionArea(int x1Rect1, int y1Rect1, int x2Rect1, int y2Rect1, int x1Rect2, int y1Rect2, int x2Rect2, int y2Rect2)` don warware matsalar mai zuwa:\nYana ƙididdige yanki na haɗuwa tsakanin murabba'i biyu.\n   Kowane murabba'i an ayyana shi ta hanyar daidaitattun kusurwarsa ta sama-hagu (x1, y1) da ƙasa-dama (x2, y2).\n   \n   Misalai:\n   >>> CalculateIntersectionArea(0, 0, 2, 2, 1, 1, 3, 3)\n   1.00\n   >>> CalculateIntersectionArea(1, 1, 3, 4, 2, 2, 5, 5)\n   2.00\n   >>> CalculateIntersectionArea(0, 0, 1, 1, 2, 2, 3, 3)\n   0.00 (Babu Haɗuwa)",
      "hi": "C# फ़ंक्शन `static double CalculateIntersectionArea(int x1Rect1, int y1Rect1, int x2Rect1, int y2Rect1, int x1Rect2, int y1Rect2, int x2Rect2, int y2Rect2)` लिखें ताकि निम्नलिखित समस्या का समाधान हो सके:\nदो आयतों के बीच प्रतिच्छेदन का क्षेत्रफल गणना करता है।\n   प्रत्येक आयत को उसके शीर्ष-बाएँ (x1, y1) और निचले-दाएँ (x2, y2) कोनों के निर्देशांक द्वारा परिभाषित किया गया है।\n   \n   उदाहरण:\n   >>> CalculateIntersectionArea(0, 0, 2, 2, 1, 1, 3, 3)\n   1.00\n   >>> CalculateIntersectionArea(1, 1, 3, 4, 2, 2, 5, 5)\n   2.00\n   >>> CalculateIntersectionArea(0, 0, 1, 1, 2, 2, 3, 3)\n   0.00 (कोई प्रतिच्छेदन नहीं)",
      "hu": "Írj egy C# függvényt `static double CalculateIntersectionArea(int x1Rect1, int y1Rect1, int x2Rect1, int y2Rect1, int x1Rect2, int y1Rect2, int x2Rect2, int y2Rect2)` a következő probléma megoldására:\nKiszámítja a metszet területét két téglalap között.\n   Minden téglalap a bal felső (x1, y1) és a jobb alsó (x2, y2) sarkok koordinátáival van meghatározva.\n   \n   Példák:\n   >>> CalculateIntersectionArea(0, 0, 2, 2, 1, 1, 3, 3)\n   1.00\n   >>> CalculateIntersectionArea(1, 1, 3, 4, 2, 2, 5, 5)\n   2.00\n   >>> CalculateIntersectionArea(0, 0, 1, 1, 2, 2, 3, 3)\n   0.00 (Nincs metszet)"
    },
    "instruction_bertscore": {
      "sq": "0.9782322951727677",
      "hy": "0.9809958396641061",
      "bn": "0.9921252985438719",
      "bg": "0.9859850375749404",
      "zh": "0.9838813432093999",
      "fr": "0.9840875215449141",
      "de": "0.9909742354857747",
      "ha": "0.9866967302301883",
      "hi": "0.9830500750647688",
      "hu": "0.9809819355374336"
    },
    "level": "easy",
    "test": "    static void Main()\n    {\n\n        Debug.Assert(Math.Abs(CalculateIntersectionArea(0, 0, 2, 2, 1, 1, 3, 3) - 1.00) < 0.01);\n        Debug.Assert(Math.Abs(CalculateIntersectionArea(1, 1, 3, 4, 2, 2, 5, 5) - 2.00) < 0.01);\n        Debug.Assert(Math.Abs(CalculateIntersectionArea(0, 0, 1, 1, 2, 2, 3, 3) - 0.00) < 0.01);\n        Debug.Assert(Math.Abs(CalculateIntersectionArea(1, 1, 4, 4, 3, 3, 6, 6) - 1.00) < 0.01);\n        Debug.Assert(Math.Abs(CalculateIntersectionArea(0, 0, 3, 3, 1, 1, 2, 2) - 1.00) < 0.01);\n        Debug.Assert(Math.Abs(CalculateIntersectionArea(2, 2, 5, 5, 3, 3, 6, 6) - 4.00) < 0.01);\n        Debug.Assert(Math.Abs(CalculateIntersectionArea(0, 0, 2, 2, 3, 3, 5, 5) - 0.00) < 0.01);\n\n    }\n}",
    "entry_point": "CalculateIntersectionArea",
    "signature": "static double CalculateIntersectionArea(int x1Rect1, int y1Rect1, int x2Rect1, int y2Rect1, int x1Rect2, int y1Rect2, int x2Rect2, int y2Rect2)",
    "docstring": {
      "en": "Calculates the area of intersection between two rectangles.\n   Each rectangle is defined by the coordinates of its top-left (x1, y1) and bottom-right (x2, y2) corners.\n   \n   Examples:\n   >>> CalculateIntersectionArea(0, 0, 2, 2, 1, 1, 3, 3)\n   1.00\n   >>> CalculateIntersectionArea(1, 1, 3, 4, 2, 2, 5, 5)\n   2.00\n   >>> CalculateIntersectionArea(0, 0, 1, 1, 2, 2, 3, 3)\n   0.00 (No Intersection)",
      "sq": "Llogarit sipërfaqen e ndërprerjes midis dy drejtkëndëshave. \n   Secili drejtkëndësh përcaktohet nga koordinatat e këndit të sipërm të majtë (x1, y1) dhe këndit të poshtëm të djathtë (x2, y2).\n   \n   Shembuj:\n   >>> CalculateIntersectionArea(0, 0, 2, 2, 1, 1, 3, 3)\n   1.00\n   >>> CalculateIntersectionArea(1, 1, 3, 4, 2, 2, 5, 5)\n   2.00\n   >>> CalculateIntersectionArea(0, 0, 1, 1, 2, 2, 3, 3)\n   0.00 (Pa Ndërprerje)",
      "hy": "Հաշվում է երկու ուղղանկյունների հատման մակերեսը:\n   Յուրաքանչյուր ուղղանկյուն սահմանվում է իր վերին ձախ (x1, y1) և ներքևի աջ (x2, y2) անկյունների կոորդինատներով:\n   \n   Օրինակներ:\n   >>> CalculateIntersectionArea(0, 0, 2, 2, 1, 1, 3, 3)\n   1.00\n   >>> CalculateIntersectionArea(1, 1, 3, 4, 2, 2, 5, 5)\n   2.00\n   >>> CalculateIntersectionArea(0, 0, 1, 1, 2, 2, 3, 3)\n   0.00 (Հատում չկա)",
      "bn": "দুটি আয়তক্ষেত্রের মধ্যে ছেদ এলাকার হিসাব করে।  \nপ্রতিটি আয়তক্ষেত্র তার উপরের-বাম (x1, y1) এবং নিচের-ডান (x2, y2) কোণের স্থানাঙ্ক দ্বারা সংজ্ঞায়িত হয়।\n\nউদাহরণসমূহ:\n>>> CalculateIntersectionArea(0, 0, 2, 2, 1, 1, 3, 3)\n1.00\n>>> CalculateIntersectionArea(1, 1, 3, 4, 2, 2, 5, 5)\n2.00\n>>> CalculateIntersectionArea(0, 0, 1, 1, 2, 2, 3, 3)\n0.00 (কোনও ছেদ নেই)",
      "bg": "Изчислява площта на пресичане между два правоъгълника.  \n   Всеки правоъгълник е определен от координатите на горния ляв (x1, y1) и долния десен (x2, y2) ъгъл.\n   \n   Примери:\n   >>> CalculateIntersectionArea(0, 0, 2, 2, 1, 1, 3, 3)\n   1.00\n   >>> CalculateIntersectionArea(1, 1, 3, 4, 2, 2, 5, 5)\n   2.00\n   >>> CalculateIntersectionArea(0, 0, 1, 1, 2, 2, 3, 3)\n   0.00 (Няма пресичане)",
      "zh": "计算两个矩形之间的交集面积。  \n每个矩形由其左上角 (x1, y1) 和右下角 (x2, y2) 的坐标定义。\n\n示例：\n>>> CalculateIntersectionArea(0, 0, 2, 2, 1, 1, 3, 3)\n1.00\n>>> CalculateIntersectionArea(1, 1, 3, 4, 2, 2, 5, 5)\n2.00\n>>> CalculateIntersectionArea(0, 0, 1, 1, 2, 2, 3, 3)\n0.00 (无交集)",
      "fr": "Calcule la surface d'intersection entre deux rectangles.  \n   Chaque rectangle est défini par les coordonnées de son coin supérieur gauche (x1, y1) et de son coin inférieur droit (x2, y2).\n   \n   Exemples :\n   >>> CalculateIntersectionArea(0, 0, 2, 2, 1, 1, 3, 3)\n   1.00\n   >>> CalculateIntersectionArea(1, 1, 3, 4, 2, 2, 5, 5)\n   2.00\n   >>> CalculateIntersectionArea(0, 0, 1, 1, 2, 2, 3, 3)\n   0.00 (Pas d'intersection)",
      "de": "Berechnet die Schnittfläche zwischen zwei Rechtecken.\n   Jedes Rechteck wird durch die Koordinaten seiner oberen linken (x1, y1) und unteren rechten (x2, y2) Ecken definiert.\n   \n   Beispiele:\n   >>> CalculateIntersectionArea(0, 0, 2, 2, 1, 1, 3, 3)\n   1.00\n   >>> CalculateIntersectionArea(1, 1, 3, 4, 2, 2, 5, 5)\n   2.00\n   >>> CalculateIntersectionArea(0, 0, 1, 1, 2, 2, 3, 3)\n   0.00 (Keine Schnittmenge)",
      "ha": "Lissafi yankin da ya ratsa tsakanin murabba'i biyu.\n   Kowane rectangle an ayyana shi ta hanyar daidaitattun wuraren saman hagu (x1, y1) da ƙasan dama (x2, y2).\n\n   Misalai:\n   >>> CalculateIntersectionArea(0, 0, 2, 2, 1, 1, 3, 3)\n   1.00\n   >>> CalculateIntersectionArea(1, 1, 3, 4, 2, 2, 5, 5)\n   2.00\n   >>> CalculateIntersectionArea(0, 0, 1, 1, 2, 2, 3, 3)\n   0.00 (Babu Sadarwa)",
      "hi": "दो आयतों के बीच के प्रतिच्छेदन क्षेत्र की गणना करता है।  \nप्रत्येक आयत को इसके शीर्ष-बाएँ (x1, y1) और नीचे-दाएँ (x2, y2) कोनों के निर्देशांक द्वारा परिभाषित किया जाता है।\n\nउदाहरण:\n>>> CalculateIntersectionArea(0, 0, 2, 2, 1, 1, 3, 3)\n1.00\n>>> CalculateIntersectionArea(1, 1, 3, 4, 2, 2, 5, 5)\n2.00\n>>> CalculateIntersectionArea(0, 0, 1, 1, 2, 2, 3, 3)\n0.00 (कोई प्रतिच्छेदन नहीं)",
      "hu": "Kiszámítja a két téglalap metszetének területét.  \n   Minden téglalapot a bal felső (x1, y1) és a jobb alsó (x2, y2) sarok koordinátái határoznak meg.\n   \n   Példák:\n   >>> CalculateIntersectionArea(0, 0, 2, 2, 1, 1, 3, 3)\n   1.00\n   >>> CalculateIntersectionArea(1, 1, 3, 4, 2, 2, 5, 5)\n   2.00\n   >>> CalculateIntersectionArea(0, 0, 1, 1, 2, 2, 3, 3)\n   0.00 (Nincs metszet)"
    },
    "docstring_bertscore": {
      "sq": "0.9786722614667599",
      "hy": "0.9693606678342254",
      "bn": "0.9890787057595587",
      "bg": "0.9798995985911745",
      "zh": "0.9752925655334513",
      "fr": "0.9649256486864785",
      "de": "0.9716192938969731",
      "ha": "0.963687784151869",
      "hi": "0.9880059030715893",
      "hu": "0.9855264000251308"
    }
  },
  {
    "task_id": "C#/10",
    "prompt": {
      "en": "using System;\nusing System.Collections.Generic;\nusing System.Diagnostics;\n\nclass Program\n{\n/*\n    Solves a linear equation of the form ax + b = 0.\n    The function returns the solution as a double with two decimal places precision.\n    Assumes that 'a' is not zero.\n\n    Examples:\n    >>> SolveLinearEquation(2, -4)\n    2.00\n    >>> SolveLinearEquation(5, 10)\n    -2.00\n*/\n    static double SolveLinearEquation(double a, double b)",
      "sq": "using System;\nusing System.Collections.Generic;\nusing System.Diagnostics;\n\nclass Program\n{\n/*\n    Zgjidh një ekuacion linear të formës ax + b = 0.\n    Funksioni kthen zgjidhjen si një numër me presje dhjetore me saktësi dy shifra dhjetore.\n    Supozohet që 'a' nuk është zero.\n\n    Shembuj:\n    >>> SolveLinearEquation(2, -4)\n    2.00\n    >>> SolveLinearEquation(5, 10)\n    -2.00\n*/\n    static double SolveLinearEquation(double a, double b)",
      "hy": "using System;\nusing System.Collections.Generic;\nusing System.Diagnostics;\n\nclass Program\n{\n/*\n    Լուծում է գծային հավասարում ax + b = 0 ձևով:\n    Ֆունկցիան վերադարձնում է լուծումը որպես double երկու տասնորդական թվանշան ճշգրտությամբ:\n    Ենթադրվում է, որ 'a'-ն զրո չէ:\n\n    Օրինակներ:\n    >>> SolveLinearEquation(2, -4)\n    2.00\n    >>> SolveLinearEquation(5, 10)\n    -2.00\n*/\n    static double SolveLinearEquation(double a, double b)",
      "bn": "using System;\nusing System.Collections.Generic;\nusing System.Diagnostics;\n\nclass Program\n{\n/*\n    ax + b = 0 আকারের একটি সরল সমীকরণ সমাধান করে।\n    ফাংশনটি সমাধানটি একটি ডাবল হিসাবে দুই দশমিক স্থান নির্ভুলতা সহ ফেরত দেয়।\n    ধরে নেওয়া হয় যে 'a' শূন্য নয়।\n\n    উদাহরণ:\n    >>> SolveLinearEquation(2, -4)\n    2.00\n    >>> SolveLinearEquation(5, 10)\n    -2.00\n*/\n    static double SolveLinearEquation(double a, double b)",
      "bg": "using System;\nusing System.Collections.Generic;\nusing System.Diagnostics;\n\nclass Program\n{\n/*\n    Решава линейно уравнение от вида ax + b = 0.\n    Функцията връща решението като число с плаваща запетая с точност до два знака след десетичната запетая.\n    Предполага се, че 'a' не е нула.\n\n    Примери:\n    >>> SolveLinearEquation(2, -4)\n    2.00\n    >>> SolveLinearEquation(5, 10)\n    -2.00\n*/\n    static double SolveLinearEquation(double a, double b)",
      "zh": "using System;\nusing System.Collections.Generic;\nusing System.Diagnostics;\n\nclass Program\n{\n/*\n    求解形如 ax + b = 0 的线性方程。\n    该函数返回一个双精度数，精确到小数点后两位。\n    假设 'a' 不为零。\n\n    示例:\n    >>> SolveLinearEquation(2, -4)\n    2.00\n    >>> SolveLinearEquation(5, 10)\n    -2.00\n*/\n    static double SolveLinearEquation(double a, double b)",
      "fr": "using System;\nusing System.Collections.Generic;\nusing System.Diagnostics;\n\nclass Program\n{\n/*\n    Résout une équation linéaire de la forme ax + b = 0.\n    La fonction retourne la solution sous forme de double avec une précision de deux décimales.\n    Suppose que 'a' n'est pas zéro.\n\n    Exemples :\n    >>> SolveLinearEquation(2, -4)\n    2.00\n    >>> SolveLinearEquation(5, 10)\n    -2.00\n*/\n    static double SolveLinearEquation(double a, double b)",
      "de": "using System;\nusing System.Collections.Generic;\nusing System.Diagnostics;\n\nclass Program\n{\n/*\n    Löst eine lineare Gleichung der Form ax + b = 0.\n    Die Funktion gibt die Lösung als double mit zwei Dezimalstellen zurück.\n    Geht davon aus, dass 'a' nicht null ist.\n\n    Beispiele:\n    >>> SolveLinearEquation(2, -4)\n    2.00\n    >>> SolveLinearEquation(5, 10)\n    -2.00\n*/\n    static double SolveLinearEquation(double a, double b)",
      "ha": "using System;\nusing System.Collections.Generic;\nusing System.Diagnostics;\n\nclass Program\n{\n/*\n    Yana warware wata daidaituwar layi mai siffa ax + b = 0.\n    Aikin yana dawo da mafita a matsayin lamba mai tsawon wurare biyu na adadi.\n    Yana ɗauka cewa 'a' ba sifili ba ne.\n\n    Misalai:\n    >>> SolveLinearEquation(2, -4)\n    2.00\n    >>> SolveLinearEquation(5, 10)\n    -2.00\n*/\n    static double SolveLinearEquation(double a, double b)",
      "hi": "using System;\nusing System.Collections.Generic;\nusing System.Diagnostics;\n\nclass Program\n{\n/*\n    ax + b = 0 के रूप में एक रैखिक समीकरण को हल करता है।\n    फ़ंक्शन समाधान को दो दशमलव स्थानों की सटीकता के साथ एक डबल के रूप में लौटाता है।\n    मान लें कि 'a' शून्य नहीं है।\n\n    उदाहरण:\n    >>> SolveLinearEquation(2, -4)\n    2.00\n    >>> SolveLinearEquation(5, 10)\n    -2.00\n*/\n    static double SolveLinearEquation(double a, double b)",
      "hu": "using System;\nusing System.Collections.Generic;\nusing System.Diagnostics;\n\nclass Program\n{\n/*\n    Megold egy ax + b = 0 alakú lineáris egyenletet.\n    A függvény visszaadja a megoldást double típusban, két tizedesjegy pontossággal.\n    Feltételezi, hogy 'a' nem nulla.\n\n    Példák:\n    >>> SolveLinearEquation(2, -4)\n    2.00\n    >>> SolveLinearEquation(5, 10)\n    -2.00\n*/\n    static double SolveLinearEquation(double a, double b)"
    },
    "prompt_bertscore": {
      "sq": "0.9717859447866614",
      "hy": "0.9865326615354535",
      "bn": "0.9777579658228563",
      "bg": "0.9611022124819378",
      "zh": "0.9618850148135963",
      "fr": "0.9908014270542743",
      "de": "0.989051890658119",
      "ha": "0.9794123582664959",
      "hi": "0.975484641111912",
      "hu": "0.993122621687048"
    },
    "canonical_solution": "{\n    if (a == 0) throw new ArgumentException(\"Coefficient 'a' cannot be zero.\");\n    double solution = -b / a;\n    return Math.Round(solution, 2);\n}",
    "instruction": {
      "en": "Write a C# function `static double SolveLinearEquation(double a, double b)` to solve the following problem:\nSolves a linear equation of the form ax + b = 0.\n    The function returns the solution as a double with two decimal places precision.\n    Assumes that 'a' is not zero.\n\n    Examples:\n    >>> SolveLinearEquation(2, -4)\n    2.00\n    >>> SolveLinearEquation(5, 10)\n    -2.00",
      "sq": "Shkruani një funksion në C# `static double SolveLinearEquation(double a, double b)` për të zgjidhur problemin e mëposhtëm:\nZgjidh një ekuacion linear të formës ax + b = 0.\n    Funksioni kthen zgjidhjen si një numër me presje dhjetore me dy shifra precizion.\n    Supozohet që 'a' nuk është zero.\n\n    Shembuj:\n    >>> SolveLinearEquation(2, -4)\n    2.00\n    >>> SolveLinearEquation(5, 10)\n    -2.00",
      "hy": "Գրեք C# ֆունկցիա `static double SolveLinearEquation(double a, double b)՝ հետևյալ խնդիրը լուծելու համար:\nԼուծում է գծային հավասարում ax + b = 0 տեսքով:\n    Ֆունկցիան վերադարձնում է լուծումը որպես double երկու տասնորդական նշաններով:\n    Ենթադրվում է, որ 'a'-ն զրո չէ:\n\n    Օրինակներ:\n    >>> SolveLinearEquation(2, -4)\n    2.00\n    >>> SolveLinearEquation(5, 10)\n    -2.00",
      "bn": "C# ফাংশন `static double SolveLinearEquation(double a, double b)` লিখুন নিম্নলিখিত সমস্যার সমাধানের জন্য:\nax + b = 0 আকারের একটি লিনিয়ার সমীকরণ সমাধান করে।\n    ফাংশনটি সমাধানটি একটি double হিসাবে দুই দশমিক স্থান নির্ভুলতা সহ ফেরত দেয়।\n    ধরে নেওয়া হয় যে 'a' শূন্য নয়।\n\n    উদাহরণ:\n    >>> SolveLinearEquation(2, -4)\n    2.00\n    >>> SolveLinearEquation(5, 10)\n    -2.00",
      "bg": "Напишете C# функция `static double SolveLinearEquation(double a, double b)` за решаване на следния проблем:\nРешава линейно уравнение от вида ax + b = 0.\n    Функцията връща решението като число с плаваща запетая с точност до два знака след десетичната запетая.\n    Приема се, че 'a' не е нула.\n\n    Примери:\n    >>> SolveLinearEquation(2, -4)\n    2.00\n    >>> SolveLinearEquation(5, 10)\n    -2.00",
      "zh": "编写一个 C# 函数 `static double SolveLinearEquation(double a, double b)` 来解决以下问题：\n解决形如 ax + b = 0 的线性方程。\n函数返回一个双精度数作为解，精确到小数点后两位。\n假设 'a' 不为零。\n\n示例：\n>>> SolveLinearEquation(2, -4)\n2.00\n>>> SolveLinearEquation(5, 10)\n-2.00",
      "fr": "Écrire une fonction C# `static double SolveLinearEquation(double a, double b)` pour résoudre le problème suivant :\nRésout une équation linéaire de la forme ax + b = 0.\n    La fonction renvoie la solution sous forme de double avec une précision de deux décimales.\n    Suppose que 'a' n'est pas zéro.\n\n    Exemples :\n    >>> SolveLinearEquation(2, -4)\n    2.00\n    >>> SolveLinearEquation(5, 10)\n    -2.00",
      "de": "Schreiben Sie eine C#-Funktion `static double SolveLinearEquation(double a, double b)`, um das folgende Problem zu lösen:\nLöst eine lineare Gleichung der Form ax + b = 0.\n    Die Funktion gibt die Lösung als double mit einer Genauigkeit von zwei Dezimalstellen zurück.\n    Geht davon aus, dass 'a' nicht null ist.\n\n    Beispiele:\n    >>> SolveLinearEquation(2, -4)\n    2.00\n    >>> SolveLinearEquation(5, 10)\n    -2.00",
      "ha": "Rubuta aikin C# `static double SolveLinearEquation(double a, double b)` don warware matsalar mai zuwa:\nYana warware wata hanyar lissafi mai layi na nau'in ax + b = 0.\n    Aikin yana mayar da mafita a matsayin lamba mai lamba biyu na wuri mai daraja.\n    Yana dauka cewa 'a' ba sifili ba ne.\n\n    Misalai:\n    >>> SolveLinearEquation(2, -4)\n    2.00\n    >>> SolveLinearEquation(5, 10)\n    -2.00",
      "hi": "C# फ़ंक्शन `static double SolveLinearEquation(double a, double b)` लिखें ताकि निम्नलिखित समस्या का समाधान किया जा सके:\nax + b = 0 के रूप में एक रैखिक समीकरण को हल करता है।\n    फ़ंक्शन समाधान को दो दशमलव स्थानों की सटीकता के साथ एक डबल के रूप में लौटाता है।\n    मानता है कि 'a' शून्य नहीं है।\n\n    उदाहरण:\n    >>> SolveLinearEquation(2, -4)\n    2.00\n    >>> SolveLinearEquation(5, 10)\n    -2.00",
      "hu": "Írj egy C# függvényt `static double SolveLinearEquation(double a, double b)` a következő probléma megoldására:\nMegold egy ax + b = 0 alakú lineáris egyenletet.\n    A függvény visszaadja a megoldást double típusként, két tizedesjegy pontossággal.\n    Feltételezi, hogy 'a' nem nulla.\n\n    Példák:\n    >>> SolveLinearEquation(2, -4)\n    2.00\n    >>> SolveLinearEquation(5, 10)\n    -2.00"
    },
    "instruction_bertscore": {
      "sq": "0.9651866490071582",
      "hy": "0.9815462444499538",
      "bn": "0.9792484882021422",
      "bg": "0.9626145842031375",
      "zh": "0.9736312210264755",
      "fr": "0.991101557560018",
      "de": "0.9914855100865585",
      "ha": "0.9409640713007157",
      "hi": "0.9717805817663734",
      "hu": "0.9945563357773578"
    },
    "level": "easy",
    "test": "    static void Main()\n    {\n        Debug.Assert(SolveLinearEquation(1, -3) == 3.00);\n        Debug.Assert(SolveLinearEquation(4, 8) == -2.00);\n        Debug.Assert(SolveLinearEquation(-2, 6) == 3.00);\n        Debug.Assert(SolveLinearEquation(3, -9) == 3.00);\n        Debug.Assert(SolveLinearEquation(0.5, -1.5) == 3.00);\n        Debug.Assert(SolveLinearEquation(-5, 10) == 2.00);\n        Debug.Assert(SolveLinearEquation(10, -20) == 2.00);\n\n    }\n}",
    "entry_point": "SolveLinearEquation",
    "signature": "static double SolveLinearEquation(double a, double b)",
    "docstring": {
      "en": "Solves a linear equation of the form ax + b = 0.\n    The function returns the solution as a double with two decimal places precision.\n    Assumes that 'a' is not zero.\n\n    Examples:\n    >>> SolveLinearEquation(2, -4)\n    2.00\n    >>> SolveLinearEquation(5, 10)\n    -2.00",
      "sq": "Zgjidh një ekuacion linear të formës ax + b = 0.\n    Funksioni kthen zgjidhjen si një numër me presje dhjetore me saktësi prej dy vendesh dhjetore.\n    Supozohet që 'a' nuk është zero.\n\n    Shembuj:\n    >>> SolveLinearEquation(2, -4)\n    2.00\n    >>> SolveLinearEquation(5, 10)\n    -2.00",
      "hy": "Գտնում է գծային հավասարման լուծումը ax + b = 0 ձևով:\n    Ֆունկցիան վերադարձնում է լուծումը որպես double տիպի երկու տասնորդական թվանշան ճշտությամբ:\n    Ենթադրվում է, որ 'a'-ն զրո չէ:\n\n    Օրինակներ:\n    >>> SolveLinearEquation(2, -4)\n    2.00\n    >>> SolveLinearEquation(5, 10)\n    -2.00",
      "bn": "একটি সরল সমীকরণ ax + b = 0 সমাধান করে।\n    ফাংশনটি সমাধানটি একটি ডাবল হিসাবে ফেরত দেয় যা দুই দশমিক স্থান পর্যন্ত সঠিক। \n    ধরে নেওয়া হয় যে 'a' শূন্য নয়।\n\n    উদাহরণ:\n    >>> SolveLinearEquation(2, -4)\n    2.00\n    >>> SolveLinearEquation(5, 10)\n    -2.00",
      "bg": "Решава линейно уравнение от вида ax + b = 0. Функцията връща решението като число с плаваща запетая с точност до два десетични знака. Предполага се, че 'a' не е нула.\n\n    Примери:\n    >>> SolveLinearEquation(2, -4)\n    2.00\n    >>> SolveLinearEquation(5, 10)\n    -2.00",
      "zh": "求解形如 ax + b = 0 的线性方程。\n    该函数返回一个双精度数的解，精确到小数点后两位。\n    假设 'a' 不为零。\n\n    示例：\n    >>> SolveLinearEquation(2, -4)\n    2.00\n    >>> SolveLinearEquation(5, 10)\n    -2.00",
      "fr": "Résout une équation linéaire de la forme ax + b = 0.\n    La fonction renvoie la solution sous forme de double avec une précision de deux décimales.\n    Suppose que 'a' n'est pas zéro.\n\n    Exemples :\n    >>> SolveLinearEquation(2, -4)\n    2.00\n    >>> SolveLinearEquation(5, 10)\n    -2.00",
      "de": "Löst eine lineare Gleichung der Form ax + b = 0.\n    Die Funktion gibt die Lösung als Double mit einer Genauigkeit von zwei Dezimalstellen zurück.\n    Geht davon aus, dass 'a' nicht null ist.\n\n    Beispiele:\n    >>> SolveLinearEquation(2, -4)\n    2.00\n    >>> SolveLinearEquation(5, 10)\n    -2.00",
      "ha": "Yana warware wata daidaituwar layi mai siffa ax + b = 0.\n    Aikin yana dawowa da mafita a matsayin lamba mai tsayi tare da madaidaicin wurare guda biyu bayan maki.\n    Yana ɗauka cewa 'a' ba sifili ba ne.\n\n    Misalai:\n    >>> SolveLinearEquation(2, -4)\n    2.00\n    >>> SolveLinearEquation(5, 10)\n    -2.00",
      "hi": "एक रैखिक समीकरण ax + b = 0 के रूप में हल करता है।\n    फ़ंक्शन समाधान को दो दशमलव स्थानों की सटीकता के साथ डबल के रूप में लौटाता है।\n    मानता है कि 'a' शून्य नहीं है।\n\n    उदाहरण:\n    >>> SolveLinearEquation(2, -4)\n    2.00\n    >>> SolveLinearEquation(5, 10)\n    -2.00",
      "hu": "Megold egy ax + b = 0 alakú lineáris egyenletet.\n    A függvény a megoldást két tizedesjegy pontosságú lebegőpontos számként adja vissza.\n    Feltételezi, hogy 'a' nem nulla.\n\n    Példák:\n    >>> SolveLinearEquation(2, -4)\n    2.00\n    >>> SolveLinearEquation(5, 10)\n    -2.00"
    },
    "docstring_bertscore": {
      "sq": "0.9539719776939285",
      "hy": "0.9526304281004189",
      "bn": "0.9458430293500757",
      "bg": "0.9454149808789455",
      "zh": "0.9468365785160122",
      "fr": "0.9905793582882774",
      "de": "0.9905793582882774",
      "ha": "0.9591365662312166",
      "hi": "0.9595234982134726",
      "hu": "0.9555961783196507"
    }
  },
  {
    "task_id": "C#/11",
    "prompt": {
      "en": "using System;\nusing System.Collections.Generic;\nusing System.Diagnostics;\n\nclass Program\n{\n   /* Calculates the total number of cows after a given number of years, following the rule that each cow gives birth to another cow every year from its fourth year.\n    Example cases:\n    >>> TotalCows(1)\n    1\n    >>> TotalCows(4)\n    2\n    >>> TotalCows(5)\n    3\n    >>> TotalCows(6)\n    4\n*/\n   static int TotalCows(int years)",
      "sq": "using System;\nusing System.Collections.Generic;\nusing System.Diagnostics;\n\nclass Program\n{\n   /* Llogarit numrin total të lopëve pas një numri të caktuar vitesh, duke ndjekur rregullin që çdo lopë lind një lopë tjetër çdo vit nga viti i katërt.\n    Shembuj rastesh:\n    >>> TotalCows(1)\n    1\n    >>> TotalCows(4)\n    2\n    >>> TotalCows(5)\n    3\n    >>> TotalCows(6)\n    4\n*/\n   static int TotalCows(int years)",
      "hy": "using System;\nusing System.Collections.Generic;\nusing System.Diagnostics;\n\nclass Program\n{\n   /* Հաշվում է կովերի ընդհանուր քանակը որոշակի տարիների անց, հետևելով կանոնին, որ յուրաքանչյուր կով իր չորրորդ տարուց սկսած ամեն տարի ծնում է մեկ այլ կով:\n    Օրինակ դեպքեր:\n    >>> TotalCows(1)\n    1\n    >>> TotalCows(4)\n    2\n    >>> TotalCows(5)\n    3\n    >>> TotalCows(6)\n    4\n*/\n   static int TotalCows(int years)",
      "bn": "using System;\nusing System.Collections.Generic;\nusing System.Diagnostics;\n\nclass Program\n{\n   /* প্রদত্ত বছর পর গরুর মোট সংখ্যা গণনা করে, নিয়ম অনুসারে যে প্রতিটি গরু তার চতুর্থ বছর থেকে প্রতি বছর আরেকটি গরুর জন্ম দেয়।\n    উদাহরণ কেস:\n    >>> TotalCows(1)\n    1\n    >>> TotalCows(4)\n    2\n    >>> TotalCows(5)\n    3\n    >>> TotalCows(6)\n    4\n*/\n   static int TotalCows(int years)",
      "bg": "using System;\nusing System.Collections.Generic;\nusing System.Diagnostics;\n\nclass Program\n{\n   /* Изчислява общия брой крави след даден брой години, следвайки правилото, че всяка крава ражда друга крава всяка година от четвъртата си година.\n    Примерни случаи:\n    >>> TotalCows(1)\n    1\n    >>> TotalCows(4)\n    2\n    >>> TotalCows(5)\n    3\n    >>> TotalCows(6)\n    4\n*/\n   static int TotalCows(int years)",
      "zh": "using System;\nusing System.Collections.Generic;\nusing System.Diagnostics;\n\nclass Program\n{\n   /* 计算给定年数后的牛总数，遵循的规则是每头牛从第四年开始每年生一头小牛。\n    示例案例:\n    >>> TotalCows(1)\n    1\n    >>> TotalCows(4)\n    2\n    >>> TotalCows(5)\n    3\n    >>> TotalCows(6)\n    4\n*/\n   static int TotalCows(int years)",
      "fr": "using System;\nusing System.Collections.Generic;\nusing System.Diagnostics;\n\nclass Program\n{\n   /* Calcule le nombre total de vaches après un certain nombre d'années, en suivant la règle selon laquelle chaque vache donne naissance à une autre vache chaque année à partir de sa quatrième année.\n    Cas d'exemple :\n    >>> TotalCows(1)\n    1\n    >>> TotalCows(4)\n    2\n    >>> TotalCows(5)\n    3\n    >>> TotalCows(6)\n    4\n*/\n   static int TotalCows(int years)",
      "de": "using System;\nusing System.Collections.Generic;\nusing System.Diagnostics;\n\nclass Program\n{\n   /* Berechnet die Gesamtzahl der Kühe nach einer bestimmten Anzahl von Jahren, gemäß der Regel, dass jede Kuh jedes Jahr ab ihrem vierten Jahr ein weiteres Kalb zur Welt bringt.\n    Beispielhafte Fälle:\n    >>> TotalCows(1)\n    1\n    >>> TotalCows(4)\n    2\n    >>> TotalCows(5)\n    3\n    >>> TotalCows(6)\n    4\n*/\n   static int TotalCows(int years)",
      "ha": "using System;\nusing System.Collections.Generic;\nusing System.Diagnostics;\n\nclass Program\n{\n   /* Lissafa jimillar adadin shanu bayan wani adadin shekaru, bisa ƙa'idar cewa kowace saniya tana haifar da wata saniya kowace shekara daga shekararta ta huɗu.\n    Misalan lamura:\n    >>> TotalCows(1)\n    1\n    >>> TotalCows(4)\n    2\n    >>> TotalCows(5)\n    3\n    >>> TotalCows(6)\n    4\n*/\n   static int TotalCows(int years)",
      "hi": "using System;\nusing System.Collections.Generic;\nusing System.Diagnostics;\n\nclass Program\n{\n   /* दिए गए वर्षों की संख्या के बाद कुल गायों की संख्या की गणना करता है, इस नियम का पालन करते हुए कि प्रत्येक गाय अपने चौथे वर्ष से हर साल एक और गाय को जन्म देती है।\n    उदाहरण मामले:\n    >>> TotalCows(1)\n    1\n    >>> TotalCows(4)\n    2\n    >>> TotalCows(5)\n    3\n    >>> TotalCows(6)\n    4\n*/\n   static int TotalCows(int years)",
      "hu": "using System;\nusing System.Collections.Generic;\nusing System.Diagnostics;\n\nclass Program\n{\n   /* Kiszámítja a tehenek teljes számát egy adott év után, azzal a szabállyal, hogy minden tehén minden évben szül egy másik tehenet a negyedik évétől kezdve.\n    Példa esetek:\n    >>> TotalCows(1)\n    1\n    >>> TotalCows(4)\n    2\n    >>> TotalCows(5)\n    3\n    >>> TotalCows(6)\n    4\n*/\n   static int TotalCows(int years)"
    },
    "prompt_bertscore": {
      "sq": "0.9887106436635011",
      "hy": "0.9893710896804421",
      "bn": "0.9871780116434359",
      "bg": "1",
      "zh": "0.9778932331123411",
      "fr": "0.988015834590641",
      "de": "0.9847328716528965",
      "ha": "0.9827795404857993",
      "hi": "0.9976700656304608",
      "hu": "0.9804994623418999"
    },
    "canonical_solution": "{\n        if (years <= 0)\n        {\n            return 0;\n        }\n        else if (years <= 3)\n        {\n            return 1;\n        }\n        else\n        {\n            return TotalCows(years - 1) + TotalCows(years - 3);\n        }\n}",
    "instruction": {
      "en": "Write a C# function `static int TotalCows(int years)` to solve the following problem:\nCalculates the total number of cows after a given number of years, following the rule that each cow gives birth to another cow every year from its fourth year.\n    Example cases:\n    >>> TotalCows(1)\n    1\n    >>> TotalCows(4)\n    2\n    >>> TotalCows(5)\n    3\n    >>> TotalCows(6)\n    4",
      "sq": "Shkruani një funksion C# `static int TotalCows(int years)` për të zgjidhur problemin e mëposhtëm:  \nLlogarit numrin total të lopëve pas një numri të caktuar vitesh, duke ndjekur rregullin që çdo lopë lind një lopë tjetër çdo vit nga viti i katërt i saj.  \n    Shembuj rastesh:  \n    >>> TotalCows(1)  \n    1  \n    >>> TotalCows(4)  \n    2  \n    >>> TotalCows(5)  \n    3  \n    >>> TotalCows(6)  \n    4  ",
      "hy": "Գրեք C# ֆունկցիա `static int TotalCows(int years)` հետևյալ խնդիրը լուծելու համար:\nՀաշվարկում է կովերի ընդհանուր քանակը տրված տարիների քանակից հետո՝ հետևելով այն կանոնին, որ յուրաքանչյուր կով ծնվում է մեկ այլ կով ամեն տարի իր չորրորդ տարուց սկսած:\n    Օրինակներ:\n    >>> TotalCows(1)\n    1\n    >>> TotalCows(4)\n    2\n    >>> TotalCows(5)\n    3\n    >>> TotalCows(6)\n    4",
      "bn": "C# ফাংশন `static int TotalCows(int years)` লিখুন নিম্নলিখিত সমস্যার সমাধানের জন্য:\nএকটি নির্দিষ্ট সংখ্যক বছরের পরে মোট গরুর সংখ্যা গণনা করে, এই নিয়ম অনুসরণ করে যে প্রতিটি গরু তার চতুর্থ বছর থেকে প্রতি বছর আরেকটি গরুর জন্ম দেয়।\n    উদাহরণ কেস:\n    >>> TotalCows(1)\n    1\n    >>> TotalCows(4)\n    2\n    >>> TotalCows(5)\n    3\n    >>> TotalCows(6)\n    4",
      "bg": "Напишете C# функция `static int TotalCows(int years)` за решаване на следния проблем:\nИзчислява общия брой крави след даден брой години, следвайки правилото, че всяка крава ражда друга крава всяка година от четвъртата си година.\n    Примерни случаи:\n    >>> TotalCows(1)\n    1\n    >>> TotalCows(4)\n    2\n    >>> TotalCows(5)\n    3\n    >>> TotalCows(6)\n    4",
      "zh": "编写一个 C# 函数 `static int TotalCows(int years)` 来解决以下问题：\n计算给定年数后的牛的总数，遵循的规则是每头牛从第四年开始每年生一头小牛。\n    示例案例：\n    >>> TotalCows(1)\n    1\n    >>> TotalCows(4)\n    2\n    >>> TotalCows(5)\n    3\n    >>> TotalCows(6)\n    4",
      "fr": "Écrire une fonction C# `static int TotalCows(int years)` pour résoudre le problème suivant :\nCalcule le nombre total de vaches après un certain nombre d'années, en suivant la règle selon laquelle chaque vache donne naissance à une autre vache chaque année à partir de sa quatrième année.\n    Cas d'exemple :\n    >>> TotalCows(1)\n    1\n    >>> TotalCows(4)\n    2\n    >>> TotalCows(5)\n    3\n    >>> TotalCows(6)\n    4",
      "de": "Schreiben Sie eine C#-Funktion `static int TotalCows(int years)`, um das folgende Problem zu lösen:\nBerechnet die Gesamtanzahl der Kühe nach einer bestimmten Anzahl von Jahren, gemäß der Regel, dass jede Kuh ab ihrem vierten Jahr jedes Jahr ein weiteres Kalb zur Welt bringt.\n    Beispielhafte Fälle:\n    >>> TotalCows(1)\n    1\n    >>> TotalCows(4)\n    2\n    >>> TotalCows(5)\n    3\n    >>> TotalCows(6)\n    4",
      "ha": "Rubuta aikin C# `static int TotalCows(int years)` don warware matsalar mai zuwa:  \nLissafa yawan shanu bayan wani adadin shekaru, bisa ga doka cewa kowace saniya tana haifar da wata saniya a kowace shekara daga shekara ta hudu.  \n    Misalan lokuta:  \n    >>> TotalCows(1)  \n    1  \n    >>> TotalCows(4)  \n    2  \n    >>> TotalCows(5)  \n    3  \n    >>> TotalCows(6)  \n    4  ",
      "hi": "C# फ़ंक्शन `static int TotalCows(int years)` लिखें ताकि निम्नलिखित समस्या का समाधान किया जा सके:\nदिए गए वर्षों की संख्या के बाद कुल गायों की संख्या की गणना करें, इस नियम का पालन करते हुए कि प्रत्येक गाय अपने चौथे वर्ष से हर वर्ष एक और गाय को जन्म देती है।\n    उदाहरण मामले:\n    >>> TotalCows(1)\n    1\n    >>> TotalCows(4)\n    2\n    >>> TotalCows(5)\n    3\n    >>> TotalCows(6)\n    4",
      "hu": "Írj egy C# függvényt `static int TotalCows(int years)` a következő probléma megoldására:  \nKiszámítja a tehenek összes számát egy adott évek száma után, azzal a szabállyal, hogy minden tehén minden évben szül egy másik tehenet a negyedik évétől kezdve.  \n    Példa esetek:  \n    >>> TotalCows(1)  \n    1  \n    >>> TotalCows(4)  \n    2  \n    >>> TotalCows(5)  \n    3  \n    >>> TotalCows(6)  \n    4  "
    },
    "instruction_bertscore": {
      "sq": "0.988243266376926",
      "hy": "0.981024641069356",
      "bn": "0.9764573340878399",
      "bg": "1",
      "zh": "0.9706189912980814",
      "fr": "0.9844238027800062",
      "de": "0.9759132854741853",
      "ha": "0.9664137875011918",
      "hi": "0.9694830241489428",
      "hu": "0.9869360798393354"
    },
    "level": "easy",
    "test": "    static void Main()\n    {\n        Debug.Assert(TotalCows(1) == 1);\n        Debug.Assert(TotalCows(2) == 1);\n        Debug.Assert(TotalCows(3) == 1);\n        Debug.Assert(TotalCows(4) == 2);\n        Debug.Assert(TotalCows(5) == 3);\n        Debug.Assert(TotalCows(6) == 4);\n        Debug.Assert(TotalCows(7) == 6);\n        Debug.Assert(TotalCows(8) == 9);\n        Debug.Assert(TotalCows(10) == 19);\n    }\n}\n",
    "entry_point": "TotalCows",
    "signature": "static int TotalCows(int years)",
    "docstring": {
      "en": "Calculates the total number of cows after a given number of years, following the rule that each cow gives birth to another cow every year from its fourth year.\n    Example cases:\n    >>> TotalCows(1)\n    1\n    >>> TotalCows(4)\n    2\n    >>> TotalCows(5)\n    3\n    >>> TotalCows(6)\n    4",
      "sq": "Llogarit numrin total të lopëve pas një numri të caktuar vitesh, duke ndjekur rregullin që çdo lopë lind një tjetër lopë çdo vit nga viti i saj i katërt.\n    Shembuj të rasteve:\n    >>> TotalCows(1)\n    1\n    >>> TotalCows(4)\n    2\n    >>> TotalCows(5)\n    3\n    >>> TotalCows(6)\n    4",
      "hy": "Հաշվում է կովերի ընդհանուր քանակը որոշակի տարիների անց, հետևելով այն կանոնին, որ յուրաքանչյուր կով իր չորրորդ տարուց սկսած ամեն տարի ծնում է մեկ այլ կով:\n    Օրինակ դեպքեր:\n    >>> TotalCows(1)\n    1\n    >>> TotalCows(4)\n    2\n    >>> TotalCows(5)\n    3\n    >>> TotalCows(6)\n    4",
      "bn": "গণনা করে মোট গরুর সংখ্যা নির্দিষ্ট বছরের পরে, এই নিয়ম অনুসারে যে প্রতিটি গরু তার চতুর্থ বছর থেকে প্রতি বছর আরেকটি গরুর জন্ম দেয়।\n    উদাহরণ কেস:\n    >>> TotalCows(1)\n    1\n    >>> TotalCows(4)\n    2\n    >>> TotalCows(5)\n    3\n    >>> TotalCows(6)\n    4",
      "bg": "Изчислява общия брой крави след даден брой години, следвайки правилото, че всяка крава ражда друга крава всяка година от четвъртата си година.\n    Примерни случаи:\n    >>> TotalCows(1)\n    1\n    >>> TotalCows(4)\n    2\n    >>> TotalCows(5)\n    3\n    >>> TotalCows(6)\n    4",
      "zh": "计算给定年份后的牛的总数，遵循的规则是每头牛从第四年开始每年生下一头牛。\n    示例案例：\n    >>> TotalCows(1)\n    1\n    >>> TotalCows(4)\n    2\n    >>> TotalCows(5)\n    3\n    >>> TotalCows(6)\n    4",
      "fr": "Calcule le nombre total de vaches après un certain nombre d'années, en suivant la règle selon laquelle chaque vache donne naissance à une autre vache chaque année à partir de sa quatrième année.\n    Cas d'exemple :\n    >>> TotalCows(1)\n    1\n    >>> TotalCows(4)\n    2\n    >>> TotalCows(5)\n    3\n    >>> TotalCows(6)\n    4",
      "de": "Berechnet die Gesamtanzahl der Kühe nach einer bestimmten Anzahl von Jahren, gemäß der Regel, dass jede Kuh jedes Jahr ab ihrem vierten Jahr ein weiteres Kalb zur Welt bringt.\n    Beispielhafte Fälle:\n    >>> TotalCows(1)\n    1\n    >>> TotalCows(4)\n    2\n    >>> TotalCows(5)\n    3\n    >>> TotalCows(6)\n    4",
      "ha": "Yana lissafin jimillar adadin shanu bayan wani adadin shekaru, bisa ga ƙa'ida cewa kowace saniya tana haifar da wata saniya a kowace shekara daga shekararta ta huɗu.\n    Misalan lokuta:\n    >>> TotalCows(1)\n    1\n    >>> TotalCows(4)\n    2\n    >>> TotalCows(5)\n    3\n    >>> TotalCows(6)\n    4",
      "hi": "गिनती करता है कि दिए गए वर्षों की संख्या के बाद कुल गायों की संख्या कितनी होगी, इस नियम का पालन करते हुए कि प्रत्येक गाय अपने चौथे वर्ष से हर साल एक और गाय को जन्म देती है। \n    उदाहरण मामले:\n    >>> TotalCows(1)\n    1\n    >>> TotalCows(4)\n    2\n    >>> TotalCows(5)\n    3\n    >>> TotalCows(6)\n    4",
      "hu": "Kiszámítja a tehenek teljes számát egy adott év után, azzal a szabállyal, hogy minden tehén minden évben szül egy másik tehenet a negyedik évétől kezdve.\n    Példa esetek:\n    >>> TotalCows(1)\n    1\n    >>> TotalCows(4)\n    2\n    >>> TotalCows(5)\n    3\n    >>> TotalCows(6)\n    4"
    },
    "docstring_bertscore": {
      "sq": "0.9837488567452496",
      "hy": "0.982692143118144",
      "bn": "0.9676184807621684",
      "bg": "0.9999996027392379",
      "zh": "0.963522722305229",
      "fr": "0.976936231936515",
      "de": "0.9622157343980194",
      "ha": "0.980505818514093",
      "hi": "0.9741242216322041",
      "hu": "0.9700536892336561"
    }
  },
  {
    "task_id": "C#/12",
    "prompt": {
      "en": "using System;\nusing System.Collections.Generic;\nusing System.Diagnostics;\n\nclass Program\n{\n/* This function counts how many apples are reachable.\n    It takes a list of integers representing the heights of apples from the ground and an integer representing the maximum height that can be reached (with or without a stool).\n    An apple is considered reachable if its height is less than or equal to the maximum reachable height.\n    Example:\n    >>> CountReachableApples(new List<int> {150, 200, 160, 310, 220}, 210)\n    3\n    >>> CountReachableApples(new List<int> {100, 180, 250, 300, 320}, 200)\n    2\n*/\nstatic int CountReachableApples(List<int> appleHeights, int maxReachHeight)",
      "sq": "using System;\nusing System.Collections.Generic;\nusing System.Diagnostics;\n\nclass Program\n{\n/* Kjo funksion numëron sa mollë janë të arritshme.\n    Merr një listë të numrave të plotë që përfaqësojnë lartësitë e mollëve nga toka dhe një numër të plotë që përfaqëson lartësinë maksimale që mund të arrihet (me ose pa një stol).\n    Një mollë konsiderohet e arritshme nëse lartësia e saj është më e vogël ose e barabartë me lartësinë maksimale të arritshme.\n    Shembull:\n    >>> CountReachableApples(new List<int> {150, 200, 160, 310, 220}, 210)\n    3\n    >>> CountReachableApples(new List<int> {100, 180, 250, 300, 320}, 200)\n    2\n*/\nstatic int CountReachableApples(List<int> appleHeights, int maxReachHeight)",
      "hy": "using System;\nusing System.Collections.Generic;\nusing System.Diagnostics;\n\nclass Program\n{\n/* Այս ֆունկցիան հաշվում է, թե քանի խնձոր է հասանելի:\n    Այն ընդունում է ամբողջ թվերի ցուցակ, որը ներկայացնում է խնձորների բարձրությունները գետնից և ամբողջ թիվ, որը ներկայացնում է առավելագույն հասանելի բարձրությունը (սանդուղքով կամ առանց դրա):\n    Խնձորը համարվում է հասանելի, եթե նրա բարձրությունը փոքր է կամ հավասար առավելագույն հասանելի բարձրությանը:\n    Օրինակ:\n    >>> CountReachableApples(new List<int> {150, 200, 160, 310, 220}, 210)\n    3\n    >>> CountReachableApples(new List<int> {100, 180, 250, 300, 320}, 200)\n    2\n*/\nstatic int CountReachableApples(List<int> appleHeights, int maxReachHeight)",
      "bn": "using System;\nusing System.Collections.Generic;\nusing System.Diagnostics;\n\nclass Program\n{\n/* এই ফাংশনটি কতগুলি আপেল পৌঁছানো যায় তা গণনা করে।\n    এটি মাটির থেকে আপেলের উচ্চতা প্রতিনিধিত্বকারী পূর্ণসংখ্যার একটি তালিকা এবং একটি পূর্ণসংখ্যা গ্রহণ করে যা পৌঁছানোর সর্বাধিক উচ্চতা প্রতিনিধিত্ব করে (স্টুল সহ বা ছাড়া)।\n    একটি আপেলকে পৌঁছানো যায় বলে মনে করা হয় যদি এর উচ্চতা সর্বাধিক পৌঁছানো উচ্চতার চেয়ে কম বা সমান হয়।\n    উদাহরণ:\n    >>> CountReachableApples(new List<int> {150, 200, 160, 310, 220}, 210)\n    3\n    >>> CountReachableApples(new List<int> {100, 180, 250, 300, 320}, 200)\n    2\n*/\nstatic int CountReachableApples(List<int> appleHeights, int maxReachHeight)",
      "bg": "using System;\nusing System.Collections.Generic;\nusing System.Diagnostics;\n\nclass Program\n{\n/* Тази функция брои колко ябълки са достижими.\n    Тя приема списък от цели числа, представляващи височините на ябълките от земята, и цяло число, представляващо максималната височина, която може да бъде достигната (със или без стол).\n    Ябълката се счита за достижима, ако нейната височина е по-малка или равна на максималната достижима височина.\n    Пример:\n    >>> CountReachableApples(new List<int> {150, 200, 160, 310, 220}, 210)\n    3\n    >>> CountReachableApples(new List<int> {100, 180, 250, 300, 320}, 200)\n    2\n*/\nstatic int CountReachableApples(List<int> appleHeights, int maxReachHeight)",
      "zh": "using System;\nusing System.Collections.Generic;\nusing System.Diagnostics;\n\nclass Program\n{\n/* 此函数计算可以够到多少个苹果。\n    它接受一个整数列表，表示苹果距离地面的高度，以及一个整数，表示可以达到的最大高度（无论是否使用凳子）。\n    如果苹果的高度小于或等于最大可达高度，则认为该苹果是可以够到的。\n    示例：\n    >>> CountReachableApples(new List<int> {150, 200, 160, 310, 220}, 210)\n    3\n    >>> CountReachableApples(new List<int> {100, 180, 250, 300, 320}, 200)\n    2\n*/\nstatic int CountReachableApples(List<int> appleHeights, int maxReachHeight)",
      "fr": "using System;\nusing System.Collections.Generic;\nusing System.Diagnostics;\n\nclass Program\n{\n/* Cette fonction compte combien de pommes sont accessibles.\n    Elle prend une liste d'entiers représentant les hauteurs des pommes depuis le sol et un entier représentant la hauteur maximale qui peut être atteinte (avec ou sans tabouret).\n    Une pomme est considérée comme accessible si sa hauteur est inférieure ou égale à la hauteur maximale atteignable.\n    Exemple :\n    >>> CountReachableApples(new List<int> {150, 200, 160, 310, 220}, 210)\n    3\n    >>> CountReachableApples(new List<int> {100, 180, 250, 300, 320}, 200)\n    2\n*/\nstatic int CountReachableApples(List<int> appleHeights, int maxReachHeight)",
      "de": "using System;\nusing System.Collections.Generic;\nusing System.Diagnostics;\n\nclass Program\n{\n/* Diese Funktion zählt, wie viele Äpfel erreichbar sind.\n    Sie nimmt eine Liste von ganzen Zahlen, die die Höhen der Äpfel vom Boden darstellen, und eine ganze Zahl, die die maximale Höhe darstellt, die erreicht werden kann (mit oder ohne Hocker).\n    Ein Apfel gilt als erreichbar, wenn seine Höhe kleiner oder gleich der maximal erreichbaren Höhe ist.\n    Beispiel:\n    >>> CountReachableApples(new List<int> {150, 200, 160, 310, 220}, 210)\n    3\n    >>> CountReachableApples(new List<int> {100, 180, 250, 300, 320}, 200)\n    2\n*/\nstatic int CountReachableApples(List<int> appleHeights, int maxReachHeight)",
      "ha": "using System;\nusing System.Collections.Generic;\nusing System.Diagnostics;\n\nclass Program\n{\n/* Wannan aikin yana ƙirga yawan tuffa da za a iya kaiwa.\n    Yana ɗaukar jerin lambobi masu nuni da tsayin tuffa daga ƙasa da kuma lamba mai nuni da tsayin da za a iya kaiwa (tare da ko ba tare da kujera ba).\n    Ana ɗaukar tuffa a matsayin wanda za a iya kaiwa idan tsayinsa ya yi ƙasa ko dai daidai da tsayin da za a iya kaiwa.\n    Misali:\n    >>> CountReachableApples(new List<int> {150, 200, 160, 310, 220}, 210)\n    3\n    >>> CountReachableApples(new List<int> {100, 180, 250, 300, 320}, 200)\n    2\n*/\nstatic int CountReachableApples(List<int> appleHeights, int maxReachHeight)",
      "hi": "using System;\nusing System.Collections.Generic;\nusing System.Diagnostics;\n\nclass Program\n{\n/* यह फ़ंक्शन गिनता है कि कितने सेब पहुँच योग्य हैं।\n    यह जमीन से सेबों की ऊँचाईयों का प्रतिनिधित्व करने वाली पूर्णांकों की एक सूची और एक पूर्णांक लेता है जो अधिकतम ऊँचाई का प्रतिनिधित्व करता है जिसे (स्टूल के साथ या बिना) पहुँचा जा सकता है।\n    एक सेब को पहुँच योग्य माना जाता है यदि उसकी ऊँचाई अधिकतम पहुँच योग्य ऊँचाई के बराबर या उससे कम है।\n    उदाहरण:\n    >>> CountReachableApples(new List<int> {150, 200, 160, 310, 220}, 210)\n    3\n    >>> CountReachableApples(new List<int> {100, 180, 250, 300, 320}, 200)\n    2\n*/\nstatic int CountReachableApples(List<int> appleHeights, int maxReachHeight)",
      "hu": "using System;\nusing System.Collections.Generic;\nusing System.Diagnostics;\n\nclass Program\n{\n/* Ez a függvény megszámolja, hány alma érhető el.\n    Egy egész számokat tartalmazó listát vesz át, amely az almák magasságát jelöli a földtől, valamint egy egész számot, amely a maximálisan elérhető magasságot jelöli (akár sámlival, akár anélkül).\n    Egy alma akkor tekinthető elérhetőnek, ha a magassága kisebb vagy egyenlő a maximálisan elérhető magassággal.\n    Példa:\n    >>> CountReachableApples(new List<int> {150, 200, 160, 310, 220}, 210)\n    3\n    >>> CountReachableApples(new List<int> {100, 180, 250, 300, 320}, 200)\n    2\n*/\nstatic int CountReachableApples(List<int> appleHeights, int maxReachHeight)"
    },
    "prompt_bertscore": {
      "sq": "0.9962703173353079",
      "hy": "0.9815067170041277",
      "bn": "0.9935061769528264",
      "bg": "0.9889086781533929",
      "zh": "0.9617926516864151",
      "fr": "0.9924526414118173",
      "de": "0.9926266416256039",
      "ha": "0.984223980616685",
      "hi": "0.9941519243215708",
      "hu": "0.9900325288492883"
    },
    "canonical_solution": "{\n    int reachableApples = 0;\n    foreach (int height in appleHeights)\n    {\n        if (height <= maxReachHeight)\n        {\n            reachableApples++;\n        }\n    }\n    return reachableApples;\n}",
    "instruction": {
      "en": "Write a C# function `static int CountReachableApples(List<int> appleHeights, int maxReachHeight)` to solve the following problem:\nThis function counts how many apples are reachable.\n    It takes a list of integers representing the heights of apples from the ground and an integer representing the maximum height that can be reached (with or without a stool).\n    An apple is considered reachable if its height is less than or equal to the maximum reachable height.\n    Example:\n    >>> CountReachableApples(new List<int> {150, 200, 160, 310, 220}, 210)\n    3\n    >>> CountReachableApples(new List<int> {100, 180, 250, 300, 320}, 200)\n    2",
      "sq": "Shkruani një funksion në C# `static int CountReachableApples(List<int> appleHeights, int maxReachHeight)` për të zgjidhur problemin në vijim:\nKy funksion numëron sa mollë janë të arritshme.\n    Ai merr një listë të numrave të plotë që përfaqësojnë lartësitë e mollëve nga toka dhe një numër të plotë që përfaqëson lartësinë maksimale që mund të arrihet (me ose pa një stol).\n    Një mollë konsiderohet e arritshme nëse lartësia e saj është më e vogël ose e barabartë me lartësinë maksimale të arritshme.\n    Shembull:\n    >>> CountReachableApples(new List<int> {150, 200, 160, 310, 220}, 210)\n    3\n    >>> CountReachableApples(new List<int> {100, 180, 250, 300, 320}, 200)\n    2",
      "hy": "Գրեք C# ֆունկցիա `static int CountReachableApples(List<int> appleHeights, int maxReachHeight)` հետևյալ խնդիրը լուծելու համար:\nԱյս ֆունկցիան հաշվում է, թե քանի խնձոր է հասանելի:\n    Այն ընդունում է ամբողջ թվերի ցուցակ, որը ներկայացնում է խնձորների բարձրությունները գետնից և ամբողջ թիվ, որը ներկայացնում է առավելագույն հասանելի բարձրությունը (սանդուղքով կամ առանց դրա):\n    Խնձորը համարվում է հասանելի, եթե նրա բարձրությունը փոքր է կամ հավասար առավելագույն հասանելի բարձրությանը:\n    Օրինակ:\n    >>> CountReachableApples(new List<int> {150, 200, 160, 310, 220}, 210)\n    3\n    >>> CountReachableApples(new List<int> {100, 180, 250, 300, 320}, 200)\n    2",
      "bn": "C# ফাংশন `static int CountReachableApples(List<int> appleHeights, int maxReachHeight)` লিখুন নিম্নলিখিত সমস্যার সমাধানের জন্য:\nএই ফাংশনটি কতগুলি আপেল পৌঁছানো যায় তা গণনা করে।\n    এটি মাটির থেকে আপেলের উচ্চতা প্রতিনিধিত্বকারী পূর্ণসংখ্যার একটি তালিকা এবং পৌঁছানোর সর্বাধিক উচ্চতা প্রতিনিধিত্বকারী একটি পূর্ণসংখ্যা গ্রহণ করে (স্টুল সহ বা ছাড়া)।\n    একটি আপেল পৌঁছানো যায় বলে বিবেচিত হয় যদি তার উচ্চতা পৌঁছানোর সর্বাধিক উচ্চতার চেয়ে কম বা সমান হয়।\n    উদাহরণ:\n    >>> CountReachableApples(new List<int> {150, 200, 160, 310, 220}, 210)\n    3\n    >>> CountReachableApples(new List<int> {100, 180, 250, 300, 320}, 200)\n    2",
      "bg": "Напишете C# функция `static int CountReachableApples(List<int> appleHeights, int maxReachHeight)`, за да решите следния проблем:\nТази функция брои колко ябълки са достижими.\n    Тя приема списък от цели числа, представляващи височините на ябълките от земята, и цяло число, представляващо максималната височина, която може да бъде достигната (със или без стол).\n    Ябълката се счита за достижима, ако нейната височина е по-малка или равна на максималната достижима височина.\n    Пример:\n    >>> CountReachableApples(new List<int> {150, 200, 160, 310, 220}, 210)\n    3\n    >>> CountReachableApples(new List<int> {100, 180, 250, 300, 320}, 200)\n    2",
      "zh": "编写一个 C# 函数 `static int CountReachableApples(List<int> appleHeights, int maxReachHeight)` 来解决以下问题：\n此函数计算可以够到的苹果数量。\n它接受一个整数列表，表示苹果离地面的高度，以及一个整数，表示可以达到的最大高度（无论是否使用凳子）。\n如果苹果的高度小于或等于最大可达高度，则认为该苹果是可够到的。\n示例：\n>>> CountReachableApples(new List<int> {150, 200, 160, 310, 220}, 210)\n3\n>>> CountReachableApples(new List<int> {100, 180, 250, 300, 320}, 200)\n2",
      "fr": "Écrire une fonction C# `static int CountReachableApples(List<int> appleHeights, int maxReachHeight)` pour résoudre le problème suivant :\nCette fonction compte combien de pommes sont accessibles.\n    Elle prend une liste d'entiers représentant les hauteurs des pommes à partir du sol et un entier représentant la hauteur maximale qui peut être atteinte (avec ou sans tabouret).\n    Une pomme est considérée comme accessible si sa hauteur est inférieure ou égale à la hauteur maximale atteignable.\n    Exemple :\n    >>> CountReachableApples(new List<int> {150, 200, 160, 310, 220}, 210)\n    3\n    >>> CountReachableApples(new List<int> {100, 180, 250, 300, 320}, 200)\n    2",
      "de": "Schreiben Sie eine C#-Funktion `static int CountReachableApples(List<int> appleHeights, int maxReachHeight)`, um das folgende Problem zu lösen:\nDiese Funktion zählt, wie viele Äpfel erreichbar sind.\n    Sie nimmt eine Liste von ganzen Zahlen, die die Höhen der Äpfel vom Boden darstellen, und eine ganze Zahl, die die maximale erreichbare Höhe darstellt (mit oder ohne Hocker).\n    Ein Apfel gilt als erreichbar, wenn seine Höhe kleiner oder gleich der maximal erreichbaren Höhe ist.\n    Beispiel:\n    >>> CountReachableApples(new List<int> {150, 200, 160, 310, 220}, 210)\n    3\n    >>> CountReachableApples(new List<int> {100, 180, 250, 300, 320}, 200)\n    2",
      "ha": "Rubuta aikin C# `static int CountReachableApples(List<int> appleHeights, int maxReachHeight)` don warware matsalar mai zuwa:\nWannan aikin yana ƙirga yawan tuffa da za a iya kaiwa.\n    Yana ɗaukar jerin lambobi waɗanda ke wakiltar tsayin tuffa daga ƙasa da kuma lamba mai wakiltar mafi girman tsayin da za a iya kaiwa (tare da ko ba tare da kujera ba).\n    Ana ɗaukar tuffa a matsayin wanda za a iya kaiwa idan tsayinsa ya yi ƙasa ko daidai da mafi girman tsayin da za a iya kaiwa.\n    Misali:\n    >>> CountReachableApples(new List<int> {150, 200, 160, 310, 220}, 210)\n    3\n    >>> CountReachableApples(new List<int> {100, 180, 250, 300, 320}, 200)\n    2",
      "hi": "C# फ़ंक्शन `static int CountReachableApples(List<int> appleHeights, int maxReachHeight)` लिखें ताकि निम्नलिखित समस्या का समाधान किया जा सके:\nयह फ़ंक्शन गिनता है कि कितने सेब पहुंच योग्य हैं।\n    यह जमीन से सेबों की ऊंचाईयों का प्रतिनिधित्व करने वाली पूर्णांकों की एक सूची और एक पूर्णांक लेता है जो अधिकतम ऊंचाई का प्रतिनिधित्व करता है जिसे (स्टूल के साथ या बिना) पहुंचा जा सकता है।\n    एक सेब को पहुंच योग्य माना जाता है यदि उसकी ऊंचाई अधिकतम पहुंच योग्य ऊंचाई से कम या उसके बराबर है।\n    उदाहरण:\n    >>> CountReachableApples(new List<int> {150, 200, 160, 310, 220}, 210)\n    3\n    >>> CountReachableApples(new List<int> {100, 180, 250, 300, 320}, 200)\n    2",
      "hu": "Írj egy C# függvényt `static int CountReachableApples(List<int> appleHeights, int maxReachHeight)` a következő probléma megoldására:\nEz a függvény megszámolja, hány alma érhető el.\n    Egy olyan egész számokat tartalmazó listát vesz át, amely az almák talajtól mért magasságát jelenti, és egy egész számot, amely a maximálisan elérhető magasságot jelenti (székkel vagy anélkül).\n    Egy alma elérhetőnek tekinthető, ha a magassága kisebb vagy egyenlő a maximálisan elérhető magassággal.\n    Példa:\n    >>> CountReachableApples(new List<int> {150, 200, 160, 310, 220}, 210)\n    3\n    >>> CountReachableApples(new List<int> {100, 180, 250, 300, 320}, 200)\n    2"
    },
    "instruction_bertscore": {
      "sq": "0.988544390034575",
      "hy": "0.9847312826098481",
      "bn": "0.971550170524373",
      "bg": "0.98886398631766",
      "zh": "0.9707038064707834",
      "fr": "0.9967359069484537",
      "de": "0.9899550630006847",
      "ha": "0.9776824862780631",
      "hi": "0.9886905819950166",
      "hu": "0.985824146966302"
    },
    "level": "easy",
    "test": "    static void Main()\n    {\n        Debug.Assert(CountReachableApples(new List<int> {150, 190, 300, 210, 220}, 200) == 2);\n        Debug.Assert(CountReachableApples(new List<int> {120, 180, 260, 310, 150}, 250) == 3);\n        Debug.Assert(CountReachableApples(new List<int> {100, 200, 300, 400, 500}, 350) == 3);\n\n    }\n}",
    "entry_point": "CountReachableApples",
    "signature": "static int CountReachableApples(List<int> appleHeights, int maxReachHeight)",
    "docstring": {
      "en": "This function counts how many apples are reachable.\n    It takes a list of integers representing the heights of apples from the ground and an integer representing the maximum height that can be reached (with or without a stool).\n    An apple is considered reachable if its height is less than or equal to the maximum reachable height.\n    Example:\n    >>> CountReachableApples(new List<int> {150, 200, 160, 310, 220}, 210)\n    3\n    >>> CountReachableApples(new List<int> {100, 180, 250, 300, 320}, 200)\n    2",
      "sq": "Kjo funksion numëron sa mollë janë të arritshme.\n    Merr një listë të numrave të plotë që përfaqësojnë lartësitë e mollëve nga toka dhe një numër të plotë që përfaqëson lartësinë maksimale që mund të arrihet (me ose pa një stol).\n    Një mollë konsiderohet e arritshme nëse lartësia e saj është më e vogël ose e barabartë me lartësinë maksimale të arritshme.\n    Shembull:\n    >>> CountReachableApples(new List<int> {150, 200, 160, 310, 220}, 210)\n    3\n    >>> CountReachableApples(new List<int> {100, 180, 250, 300, 320}, 200)\n    2",
      "hy": "Այս ֆունկցիան հաշվում է, թե քանի խնձոր կարելի է հասնել:  \n    Այն ընդունում է ամբողջ թվերի ցուցակ, որը ներկայացնում է խնձորների բարձրությունները գետնից և ամբողջ թիվ, որը ներկայացնում է առավելագույն բարձրությունը, որին կարելի է հասնել (սանդուղքով կամ առանց դրա):  \n    Խնձորը համարվում է հասանելի, եթե նրա բարձրությունը փոքր է կամ հավասար առավելագույն հասանելի բարձրությանը:  \n    Օրինակ:  \n    >>> CountReachableApples(new List<int> {150, 200, 160, 310, 220}, 210)  \n    3  \n    >>> CountReachableApples(new List<int> {100, 180, 250, 300, 320}, 200)  \n    2  ",
      "bn": "এই ফাংশনটি কতগুলি আপেল পৌঁছানো যায় তা গণনা করে।\n    এটি মাটির থেকে আপেলের উচ্চতাগুলির একটি তালিকা এবং একটি পূর্ণসংখ্যা নেয় যা পৌঁছানোর সর্বাধিক উচ্চতা নির্দেশ করে (স্টুল সহ বা ছাড়া)।\n    একটি আপেল পৌঁছানো যায় বলে বিবেচিত হয় যদি এর উচ্চতা পৌঁছানোর সর্বাধিক উচ্চতার চেয়ে কম বা সমান হয়।\n    উদাহরণ:\n    >>> CountReachableApples(new List<int> {150, 200, 160, 310, 220}, 210)\n    3\n    >>> CountReachableApples(new List<int> {100, 180, 250, 300, 320}, 200)\n    2",
      "bg": "Тази функция брои колко ябълки са достижими. \n    Тя приема списък от цели числа, представляващи височините на ябълките от земята, и цяло число, представляващо максималната височина, която може да бъде достигната (със или без столче). \n    Ябълката се счита за достижима, ако нейната височина е по-малка или равна на максималната достижима височина.\n    Пример:\n    >>> CountReachableApples(new List<int> {150, 200, 160, 310, 220}, 210)\n    3\n    >>> CountReachableApples(new List<int> {100, 180, 250, 300, 320}, 200)\n    2",
      "zh": "这个函数计算可以够到的苹果数量。\n它接受一个整数列表，表示苹果距离地面的高度，以及一个整数，表示可以达到的最大高度（无论是否使用凳子）。\n如果苹果的高度小于或等于最大可达到的高度，则认为该苹果是可以够到的。\n示例：\n>>> CountReachableApples(new List<int> {150, 200, 160, 310, 220}, 210)\n3\n>>> CountReachableApples(new List<int> {100, 180, 250, 300, 320}, 200)\n2",
      "fr": "Cette fonction compte combien de pommes sont atteignables.\n    Elle prend une liste d'entiers représentant les hauteurs des pommes à partir du sol et un entier représentant la hauteur maximale qui peut être atteinte (avec ou sans tabouret).\n    Une pomme est considérée comme atteignable si sa hauteur est inférieure ou égale à la hauteur maximale atteignable.\n    Exemple :\n    >>> CountReachableApples(new List<int> {150, 200, 160, 310, 220}, 210)\n    3\n    >>> CountReachableApples(new List<int> {100, 180, 250, 300, 320}, 200)\n    2",
      "de": "Diese Funktion zählt, wie viele Äpfel erreichbar sind.\n    Sie nimmt eine Liste von ganzen Zahlen, die die Höhen der Äpfel vom Boden darstellen, und eine ganze Zahl, die die maximale erreichbare Höhe (mit oder ohne Hocker) darstellt.\n    Ein Apfel gilt als erreichbar, wenn seine Höhe kleiner oder gleich der maximal erreichbaren Höhe ist.\n    Beispiel:\n    >>> CountReachableApples(new List<int> {150, 200, 160, 310, 220}, 210)\n    3\n    >>> CountReachableApples(new List<int> {100, 180, 250, 300, 320}, 200)\n    2",
      "ha": "Wannan aikin yana ƙirga yawan tuffa da za a iya kaiwa.\n    Yana ɗaukar jerin lambobi masu wakiltar tsayin tuffa daga ƙasa da lamba mai wakiltar tsayin da za a iya kaiwa (tare ko ba tare da tabarma ba).\n    Ana ɗaukar tuffa a matsayin mai iya kaiwa idan tsayinsa ya yi ƙasa ko daidai da tsayin da za a iya kaiwa.\n    Misali:\n    >>> CountReachableApples(new List<int> {150, 200, 160, 310, 220}, 210)\n    3\n    >>> CountReachableApples(new List<int> {100, 180, 250, 300, 320}, 200)\n    2",
      "hi": "This function गिनता है कि कितने सेब पहुंच योग्य हैं।\n    यह जमीन से सेबों की ऊंचाईयों का प्रतिनिधित्व करने वाली पूर्णांकों की एक सूची और एक पूर्णांक लेता है जो अधिकतम ऊंचाई का प्रतिनिधित्व करता है जिसे (स्टूल के साथ या बिना) पहुंचा जा सकता है।\n    एक सेब को पहुंच योग्य माना जाता है यदि उसकी ऊंचाई अधिकतम पहुंच योग्य ऊंचाई से कम या बराबर है।\n    उदाहरण:\n    >>> CountReachableApples(new List<int> {150, 200, 160, 310, 220}, 210)\n    3\n    >>> CountReachableApples(new List<int> {100, 180, 250, 300, 320}, 200)\n    2",
      "hu": "Ez a függvény megszámolja, hány alma érhető el.\n    Ez a függvény megszámolja, hány alma érhető el.\n    It takes a list of integers representing the heights of apples from the ground and an integer representing the maximum height that can be reached (with or without a stool).\n    Egy egész számokból álló listát vesz át, amely az almák magasságát jelöli a talajtól, valamint egy egész számot, amely a maximálisan elérhető magasságot jelöli (székkel vagy anélkül).\n    An apple is considered reachable if its height is less than or equal to the maximum reachable height.\n    Egy almát elérhetőnek tekintünk, ha a magassága kisebb vagy egyenlő a maximálisan elérhető magassággal.\n    Example:\n    Példa:\n    >>> CountReachableApples(new List<int> {150, 200, 160, 310, 220}, 210)\n    3\n    >>> CountReachableApples(new List<int> {100, 180, 250, 300, 320}, 200)\n    2"
    },
    "docstring_bertscore": {
      "sq": "0.9957437481951844",
      "hy": "0.9798016738133243",
      "bn": "0.9608499518980236",
      "bg": "0.9922450726636359",
      "zh": "0.9560005897754378",
      "fr": "0.9967077014343467",
      "de": "0.9899600287602105",
      "ha": "0.955944576007986",
      "hi": "1",
      "hu": "1"
    }
  },
  {
    "task_id": "C#/13",
    "prompt": {
      "en": "using System;\nusing System.Collections.Generic;\nusing System.Diagnostics;\n\nclass Program\n{\n   /*\n    Calculates the maximum total value of herbs that can be collected within a given time.\n    The function takes the total time available for collecting herbs, the number of different herbs,\n    an array of time costs for each herb, and an array of values for each herb.\n\n    Parameters:\n    totalMinutes - the total time available for collecting herbs.\n    herbCount - the number of different herbs available.\n    timeCosts - an array where timeCosts[i] represents the time required to collect the i-th herb.\n    values - an array where values[i] represents the value of the i-th herb.\n\n    Returns:\n    The maximum total value of the herbs that can be collected within the given time.\n\n    Examples:\n    >>> MaxHerbValue(10, 3, new int[] {3, 4, 5}, new int[] {200, 300, 350})\n    550\n    >>> MaxHerbValue(5, 2, new int[] {1, 4}, new int[] {150, 300})\n    450\n*/\n   static int MaxHerbValue(int totalMinutes, int herbCount, int[] timeCosts, int[] values)",
      "sq": "using System;\nusing System.Collections.Generic;\nusing System.Diagnostics;\n\nclass Program\n{\n   /*\n    Llogarit vlerën maksimale totale të bimëve që mund të mblidhen brenda një kohe të caktuar.\n    Funksioni merr kohën totale të disponueshme për mbledhjen e bimëve, numrin e bimëve të ndryshme,\n    një varg të kostove të kohës për secilën bimë dhe një varg të vlerave për secilën bimë.\n\n    Parametrat:\n    totalMinutes - koha totale e disponueshme për mbledhjen e bimëve.\n    herbCount - numri i bimëve të ndryshme të disponueshme.\n    timeCosts - një varg ku timeCosts[i] përfaqëson kohën e kërkuar për të mbledhur bimën e i-të.\n    values - një varg ku values[i] përfaqëson vlerën e bimës së i-të.\n\n    Kthen:\n    Vlera maksimale totale e bimëve që mund të mblidhen brenda kohës së dhënë.\n\n    Shembuj:\n    >>> MaxHerbValue(10, 3, new int[] {3, 4, 5}, new int[] {200, 300, 350})\n    550\n    >>> MaxHerbValue(5, 2, new int[] {1, 4}, new int[] {150, 300})\n    450\n*/\n   static int MaxHerbValue(int totalMinutes, int herbCount, int[] timeCosts, int[] values)",
      "hy": "using System;\nusing System.Collections.Generic;\nusing System.Diagnostics;\n\nclass Program\n{\n   /*\n    Հաշվարկում է խոտաբույսերի առավելագույն ընդհանուր արժեքը, որը կարող է հավաքվել տրված ժամանակի ընթացքում:\n    Ֆունկցիան ընդունում է խոտաբույսեր հավաքելու համար հասանելի ընդհանուր ժամանակը, տարբեր խոտաբույսերի քանակը,\n    յուրաքանչյուր խոտաբույսի համար ժամանակի ծախսերի զանգվածը և յուրաքանչյուր խոտաբույսի արժեքների զանգվածը:\n\n    Պարամետրեր:\n    totalMinutes - խոտաբույսեր հավաքելու համար հասանելի ընդհանուր ժամանակը:\n    herbCount - հասանելի տարբեր խոտաբույսերի քանակը:\n    timeCosts - զանգված, որտեղ timeCosts[i]-ն ներկայացնում է i-րդ խոտաբույսը հավաքելու համար պահանջվող ժամանակը:\n    values - զանգված, որտեղ values[i]-ն ներկայացնում է i-րդ խոտաբույսի արժեքը:\n\n    Վերադարձնում է:\n    Խոտաբույսերի առավելագույն ընդհանուր արժեքը, որը կարող է հավաքվել տրված ժամանակի ընթացքում:\n\n    Օրինակներ:\n    >>> MaxHerbValue(10, 3, new int[] {3, 4, 5}, new int[] {200, 300, 350})\n    550\n    >>> MaxHerbValue(5, 2, new int[] {1, 4}, new int[] {150, 300})\n    450\n*/\n   static int MaxHerbValue(int totalMinutes, int herbCount, int[] timeCosts, int[] values)",
      "bn": "using System;\nusing System.Collections.Generic;\nusing System.Diagnostics;\n\nclass Program\n{\n   /*\n    প্রদত্ত সময়ের মধ্যে যতটা সম্ভব সর্বাধিক মূল্যবান ভেষজ সংগ্রহের মান গণনা করে।\n    ফাংশনটি ভেষজ সংগ্রহের জন্য উপলব্ধ মোট সময়, বিভিন্ন ভেষজের সংখ্যা,\n    প্রতিটি ভেষজের জন্য সময় খরচের একটি অ্যারে এবং প্রতিটি ভেষজের জন্য মানের একটি অ্যারে নেয়।\n\n    প্যারামিটার:\n    totalMinutes - ভেষজ সংগ্রহের জন্য উপলব্ধ মোট সময়।\n    herbCount - উপলব্ধ বিভিন্ন ভেষজের সংখ্যা।\n    timeCosts - একটি অ্যারে যেখানে timeCosts[i] i-তম ভেষজ সংগ্রহের জন্য প্রয়োজনীয় সময় উপস্থাপন করে।\n    values - একটি অ্যারে যেখানে values[i] i-তম ভেষজের মান উপস্থাপন করে।\n\n    রিটার্ন:\n    প্রদত্ত সময়ের মধ্যে সংগ্রহ করা যেতে পারে এমন ভেষজের সর্বাধিক মোট মান।\n\n    উদাহরণ:\n    >>> MaxHerbValue(10, 3, new int[] {3, 4, 5}, new int[] {200, 300, 350})\n    550\n    >>> MaxHerbValue(5, 2, new int[] {1, 4}, new int[] {150, 300})\n    450\n*/\n   static int MaxHerbValue(int totalMinutes, int herbCount, int[] timeCosts, int[] values)",
      "bg": "using System;\nusing System.Collections.Generic;\nusing System.Diagnostics;\n\nclass Program\n{\n   /*\n    Изчислява максималната обща стойност на билките, които могат да бъдат събрани в рамките на дадено време.\n    Функцията приема общото време, налично за събиране на билки, броя на различните билки,\n    масив от времеви разходи за всяка билка и масив от стойности за всяка билка.\n\n    Параметри:\n    totalMinutes - общото време, налично за събиране на билки.\n    herbCount - броят на различните налични билки.\n    timeCosts - масив, където timeCosts[i] представлява времето, необходимо за събиране на i-тата билка.\n    values - масив, където values[i] представлява стойността на i-тата билка.\n\n    Връща:\n    Максималната обща стойност на билките, които могат да бъдат събрани в рамките на даденото време.\n\n    Примери:\n    >>> MaxHerbValue(10, 3, new int[] {3, 4, 5}, new int[] {200, 300, 350})\n    550\n    >>> MaxHerbValue(5, 2, new int[] {1, 4}, new int[] {150, 300})\n    450\n*/\n   static int MaxHerbValue(int totalMinutes, int herbCount, int[] timeCosts, int[] values)",
      "zh": "using System;\nusing System.Collections.Generic;\nusing System.Diagnostics;\n\nclass Program\n{\n   /*\n    计算在给定时间内可以收集的草药的最大总价值。\n    该函数接受用于收集草药的总时间、不同草药的数量、\n    每种草药的时间成本数组，以及每种草药的价值数组。\n\n    参数:\n    totalMinutes - 收集草药的总可用时间。\n    herbCount - 可用的不同草药的数量。\n    timeCosts - 一个数组，其中 timeCosts[i] 表示收集第 i 种草药所需的时间。\n    values - 一个数组，其中 values[i] 表示第 i 种草药的价值。\n\n    返回:\n    在给定时间内可以收集的草药的最大总价值。\n\n    示例:\n    >>> MaxHerbValue(10, 3, new int[] {3, 4, 5}, new int[] {200, 300, 350})\n    550\n    >>> MaxHerbValue(5, 2, new int[] {1, 4}, new int[] {150, 300})\n    450\n*/\n   static int MaxHerbValue(int totalMinutes, int herbCount, int[] timeCosts, int[] values)",
      "fr": "using System;\nusing System.Collections.Generic;\nusing System.Diagnostics;\n\nclass Program\n{\n   /*\n    Calcule la valeur totale maximale des herbes qui peuvent être collectées dans un temps donné.\n    La fonction prend le temps total disponible pour collecter les herbes, le nombre d'herbes différentes,\n    un tableau des coûts en temps pour chaque herbe, et un tableau des valeurs pour chaque herbe.\n\n    Paramètres:\n    totalMinutes - le temps total disponible pour collecter les herbes.\n    herbCount - le nombre d'herbes différentes disponibles.\n    timeCosts - un tableau où timeCosts[i] représente le temps requis pour collecter la i-ème herbe.\n    values - un tableau où values[i] représente la valeur de la i-ème herbe.\n\n    Renvoie:\n    La valeur totale maximale des herbes qui peuvent être collectées dans le temps donné.\n\n    Exemples:\n    >>> MaxHerbValue(10, 3, new int[] {3, 4, 5}, new int[] {200, 300, 350})\n    550\n    >>> MaxHerbValue(5, 2, new int[] {1, 4}, new int[] {150, 300})\n    450\n*/\n   static int MaxHerbValue(int totalMinutes, int herbCount, int[] timeCosts, int[] values)",
      "de": "using System;\nusing System.Collections.Generic;\nusing System.Diagnostics;\n\nclass Program\n{\n   /*\n    Berechnet den maximalen Gesamtwert von Kräutern, die innerhalb einer bestimmten Zeit gesammelt werden können.\n    Die Funktion nimmt die insgesamt verfügbare Zeit zum Sammeln von Kräutern, die Anzahl der verschiedenen Kräuter,\n    ein Array von Zeitkosten für jedes Kraut und ein Array von Werten für jedes Kraut.\n\n    Parameter:\n    totalMinutes - die insgesamt verfügbare Zeit zum Sammeln von Kräutern.\n    herbCount - die Anzahl der verfügbaren verschiedenen Kräuter.\n    timeCosts - ein Array, in dem timeCosts[i] die Zeit darstellt, die benötigt wird, um das i-te Kraut zu sammeln.\n    values - ein Array, in dem values[i] den Wert des i-ten Krauts darstellt.\n\n    Rückgabewert:\n    Der maximale Gesamtwert der Kräuter, die innerhalb der gegebenen Zeit gesammelt werden können.\n\n    Beispiele:\n    >>> MaxHerbValue(10, 3, new int[] {3, 4, 5}, new int[] {200, 300, 350})\n    550\n    >>> MaxHerbValue(5, 2, new int[] {1, 4}, new int[] {150, 300})\n    450\n*/\n   static int MaxHerbValue(int totalMinutes, int herbCount, int[] timeCosts, int[] values)",
      "ha": "using System;\nusing System.Collections.Generic;\nusing System.Diagnostics;\n\nclass Program\n{\n   /*\n    Lissafa mafi girman jimillar ƙimar ganyayyaki da za a iya tattarawa a cikin wani lokaci da aka bayar.\n    Aikin yana ɗaukar jimillar lokacin da ake da shi don tattara ganyayyaki, adadin ganyayyaki daban-daban,\n    jerin tsadar lokaci don kowane ganye, da jerin ƙimomi don kowane ganye.\n\n    Sigogi:\n    totalMinutes - jimillar lokacin da ake da shi don tattara ganyayyaki.\n    herbCount - adadin ganyayyaki daban-daban da ake da su.\n    timeCosts - jerin inda timeCosts[i] ke wakiltar lokacin da ake buƙata don tattara ganye na i.\n    values - jerin inda values[i] ke wakiltar ƙimar ganye na i.\n\n    Mayarwa:\n    Mafi girman jimillar ƙimar ganyayyaki da za a iya tattarawa a cikin lokacin da aka bayar.\n\n    Misalai:\n    >>> MaxHerbValue(10, 3, new int[] {3, 4, 5}, new int[] {200, 300, 350})\n    550\n    >>> MaxHerbValue(5, 2, new int[] {1, 4}, new int[] {150, 300})\n    450\n*/\n   static int MaxHerbValue(int totalMinutes, int herbCount, int[] timeCosts, int[] values)",
      "hi": "using System;\nusing System.Collections.Generic;\nusing System.Diagnostics;\n\nclass Program\n{\n   /*\n    दिए गए समय के भीतर एकत्र किए जा सकने वाले जड़ी-बूटियों के अधिकतम कुल मूल्य की गणना करता है।\n    यह फ़ंक्शन जड़ी-बूटियों को एकत्र करने के लिए उपलब्ध कुल समय, विभिन्न जड़ी-बूटियों की संख्या,\n    प्रत्येक जड़ी-बूटी के लिए समय लागत की एक सरणी, और प्रत्येक जड़ी-बूटी के लिए मूल्यों की एक सरणी लेता है।\n\n    पैरामीटर्स:\n    totalMinutes - जड़ी-बूटियों को एकत्र करने के लिए उपलब्ध कुल समय।\n    herbCount - उपलब्ध विभिन्न जड़ी-बूटियों की संख्या।\n    timeCosts - एक सरणी जहां timeCosts[i] i-वीं जड़ी-बूटी को एकत्र करने के लिए आवश्यक समय का प्रतिनिधित्व करता है।\n    values - एक सरणी जहां values[i] i-वीं जड़ी-बूटी के मूल्य का प्रतिनिधित्व करता है।\n\n    रिटर्न करता है:\n    दिए गए समय के भीतर एकत्र की जा सकने वाली जड़ी-बूटियों का अधिकतम कुल मूल्य।\n\n    उदाहरण:\n    >>> MaxHerbValue(10, 3, new int[] {3, 4, 5}, new int[] {200, 300, 350})\n    550\n    >>> MaxHerbValue(5, 2, new int[] {1, 4}, new int[] {150, 300})\n    450\n*/\n   static int MaxHerbValue(int totalMinutes, int herbCount, int[] timeCosts, int[] values)",
      "hu": "using System;\nusing System.Collections.Generic;\nusing System.Diagnostics;\n\nclass Program\n{\n   /*\n    Kiszámítja a maximális összértéket, amit a gyógynövényekből lehet begyűjteni adott időn belül.\n    A függvény megkapja a gyógynövények gyűjtésére rendelkezésre álló teljes időt, a különböző gyógynövények számát,\n    egy tömböt az egyes gyógynövények gyűjtéséhez szükséges időkről, és egy tömböt az egyes gyógynövények értékeiről.\n\n    Paraméterek:\n    totalMinutes - a gyógynövények gyűjtésére rendelkezésre álló teljes idő.\n    herbCount - a rendelkezésre álló különböző gyógynövények száma.\n    timeCosts - egy tömb, ahol a timeCosts[i] az i-edik gyógynövény gyűjtéséhez szükséges időt jelenti.\n    values - egy tömb, ahol a values[i] az i-edik gyógynövény értékét jelenti.\n\n    Visszatér:\n    A gyógynövények maximális összértéke, amit az adott időn belül lehet begyűjteni.\n\n    Példák:\n    >>> MaxHerbValue(10, 3, new int[] {3, 4, 5}, new int[] {200, 300, 350})\n    550\n    >>> MaxHerbValue(5, 2, new int[] {1, 4}, new int[] {150, 300})\n    450\n*/\n   static int MaxHerbValue(int totalMinutes, int herbCount, int[] timeCosts, int[] values)"
    },
    "prompt_bertscore": {
      "sq": "0.9963136187583735",
      "hy": "0.9818692174495165",
      "bn": "0.9797939272284639",
      "bg": "0.9994883281384541",
      "zh": "0.9854300642903289",
      "fr": "0.9935447112467471",
      "de": "0.9951673228294212",
      "ha": "0.9584391749634031",
      "hi": "0.9890276577516328",
      "hu": "0.987264018598424"
    },
    "canonical_solution": "{\n    int[,] dp = new int[herbCount + 1, totalMinutes + 1];\n\n    for (int i = 1; i <= herbCount; i++)\n    {\n        for (int j = 1; j <= totalMinutes; j++)\n        {\n            if (j < timeCosts[i - 1])\n                dp[i, j] = dp[i - 1, j];\n            else\n                dp[i, j] = Math.Max(dp[i - 1, j], dp[i - 1, j - timeCosts[i - 1]] + values[i - 1]);\n        }\n    }\n    Console.WriteLine(dp[herbCount, totalMinutes]);\n    return dp[herbCount, totalMinutes];\n}",
    "instruction": {
      "en": "Write a C# function `static int MaxHerbValue(int totalMinutes, int herbCount, int[] timeCosts, int[] values)` to solve the following problem:\nCalculates the maximum total value of herbs that can be collected within a given time.\n    The function takes the total time available for collecting herbs, the number of different herbs,\n    an array of time costs for each herb, and an array of values for each herb.\n\n    Parameters:\n    totalMinutes - the total time available for collecting herbs.\n    herbCount - the number of different herbs available.\n    timeCosts - an array where timeCosts[i] represents the time required to collect the i-th herb.\n    values - an array where values[i] represents the value of the i-th herb.\n\n    Returns:\n    The maximum total value of the herbs that can be collected within the given time.\n\n    Examples:\n    >>> MaxHerbValue(10, 3, new int[] {3, 4, 5}, new int[] {200, 300, 350})\n    550\n    >>> MaxHerbValue(5, 2, new int[] {1, 4}, new int[] {150, 300})\n    450",
      "sq": "Shkruani një funksion në C# `static int MaxHerbValue(int totalMinutes, int herbCount, int[] timeCosts, int[] values)` për të zgjidhur problemin në vijim:\nLlogarit vlerën maksimale totale të bimëve që mund të mblidhen brenda një kohe të caktuar.\n    Funksioni merr kohën totale të disponueshme për mbledhjen e bimëve, numrin e bimëve të ndryshme,\n    një varg të kostove të kohës për secilën bimë, dhe një varg të vlerave për secilën bimë.\n\n    Parametrat:\n    totalMinutes - koha totale e disponueshme për mbledhjen e bimëve.\n    herbCount - numri i bimëve të ndryshme të disponueshme.\n    timeCosts - një varg ku timeCosts[i] përfaqëson kohën e kërkuar për të mbledhur bimën e i-të.\n    values - një varg ku values[i] përfaqëson vlerën e bimës së i-të.\n\n    Kthen:\n    Vlera maksimale totale e bimëve që mund të mblidhen brenda kohës së dhënë.\n\n    Shembuj:\n    >>> MaxHerbValue(10, 3, new int[] {3, 4, 5}, new int[] {200, 300, 350})\n    550\n    >>> MaxHerbValue(5, 2, new int[] {1, 4}, new int[] {150, 300})\n    450",
      "hy": "Գրեք C# ֆունկցիա `static int MaxHerbValue(int totalMinutes, int herbCount, int[] timeCosts, int[] values)` հետևյալ խնդիրը լուծելու համար:\nՀաշվում է խոտաբույսերի առավելագույն ընդհանուր արժեքը, որը կարող է հավաքվել տրված ժամանակահատվածում:\n    Ֆունկցիան ընդունում է խոտաբույսեր հավաքելու համար հասանելի ընդհանուր ժամանակը, տարբեր խոտաբույսերի քանակը,\n    խոտաբույսերից յուրաքանչյուրի համար ժամանակի ծախսերի զանգվածը և խոտաբույսերից յուրաքանչյուրի արժեքների զանգվածը:\n\n    Պարամետրեր:\n    totalMinutes - խոտաբույսեր հավաքելու համար հասանելի ընդհանուր ժամանակը:\n    herbCount - հասանելի տարբեր խոտաբույսերի քանակը:\n    timeCosts - զանգված, որտեղ timeCosts[i]-ն ներկայացնում է i-րդ խոտաբույսը հավաքելու համար պահանջվող ժամանակը:\n    values - զանգված, որտեղ values[i]-ն ներկայացնում է i-րդ խոտաբույսի արժեքը:\n\n    Վերադարձնում է:\n    Խոտաբույսերի առավելագույն ընդհանուր արժեքը, որը կարող է հավաքվել տրված ժամանակահատվածում:\n\n    Օրինակներ:\n    >>> MaxHerbValue(10, 3, new int[] {3, 4, 5}, new int[] {200, 300, 350})\n    550\n    >>> MaxHerbValue(5, 2, new int[] {1, 4}, new int[] {150, 300})\n    450",
      "bn": "C# ফাংশন `static int MaxHerbValue(int totalMinutes, int herbCount, int[] timeCosts, int[] values)` লিখুন নিম্নলিখিত সমস্যার সমাধানের জন্য:\nএকটি নির্দিষ্ট সময়ের মধ্যে যতটা সম্ভব সর্বাধিক মোট মূল্যমানের ভেষজ সংগ্রহ করা যায় তা গণনা করে।\n    ফাংশনটি ভেষজ সংগ্রহের জন্য উপলব্ধ মোট সময়, বিভিন্ন ভেষজের সংখ্যা,\n    প্রতিটি ভেষজের জন্য সময় ব্যয়ের একটি অ্যারে, এবং প্রতিটি ভেষজের জন্য মানের একটি অ্যারে গ্রহণ করে।\n\n    প্যারামিটারসমূহ:\n    totalMinutes - ভেষজ সংগ্রহের জন্য উপলব্ধ মোট সময়।\n    herbCount - উপলব্ধ বিভিন্ন ভেষজের সংখ্যা।\n    timeCosts - একটি অ্যারে যেখানে timeCosts[i] i-তম ভেষজ সংগ্রহের জন্য প্রয়োজনীয় সময় নির্দেশ করে।\n    values - একটি অ্যারে যেখানে values[i] i-তম ভেষজের মূল্য নির্দেশ করে।\n\n    রিটার্নস:\n    নির্দিষ্ট সময়ের মধ্যে সংগ্রহ করা যেতে পারে এমন ভেষজের সর্বাধিক মোট মূল্য।\n\n    উদাহরণ:\n    >>> MaxHerbValue(10, 3, new int[] {3, 4, 5}, new int[] {200, 300, 350})\n    550\n    >>> MaxHerbValue(5, 2, new int[] {1, 4}, new int[] {150, 300})\n    450",
      "bg": "Напишете C# функция `static int MaxHerbValue(int totalMinutes, int herbCount, int[] timeCosts, int[] values)` за решаване на следния проблем:\nИзчислява максималната обща стойност на билките, които могат да бъдат събрани в рамките на дадено време.\nФункцията приема общото време, налично за събиране на билки, броя на различните билки,\nмасив от времеви разходи за всяка билка и масив от стойности за всяка билка.\n\nПараметри:\ntotalMinutes - общото време, налично за събиране на билки.\nherbCount - броят на различните налични билки.\ntimeCosts - масив, където timeCosts[i] представлява времето, необходимо за събиране на i-тата билка.\nvalues - масив, където values[i] представлява стойността на i-тата билка.\n\nВръща:\nМаксималната обща стойност на билките, които могат да бъдат събрани в рамките на даденото време.\n\nПримери:\n>>> MaxHerbValue(10, 3, new int[] {3, 4, 5}, new int[] {200, 300, 350})\n550\n>>> MaxHerbValue(5, 2, new int[] {1, 4}, new int[] {150, 300})\n450",
      "zh": "编写一个 C# 函数 `static int MaxHerbValue(int totalMinutes, int herbCount, int[] timeCosts, int[] values)` 来解决以下问题：\n计算在给定时间内可以收集的草药的最大总价值。\n函数接受用于收集草药的总时间、不同草药的数量、每种草药的时间成本数组和每种草药的价值数组。\n\n参数：\ntotalMinutes - 收集草药的可用总时间。\nherbCount - 可用的不同草药的数量。\ntimeCosts - 一个数组，其中 timeCosts[i] 表示收集第 i 种草药所需的时间。\nvalues - 一个数组，其中 values[i] 表示第 i 种草药的价值。\n\n返回：\n在给定时间内可以收集的草药的最大总价值。\n\n示例：\n>>> MaxHerbValue(10, 3, new int[] {3, 4, 5}, new int[] {200, 300, 350})\n550\n>>> MaxHerbValue(5, 2, new int[] {1, 4}, new int[] {150, 300})\n450",
      "fr": "Écrire une fonction C# `static int MaxHerbValue(int totalMinutes, int herbCount, int[] timeCosts, int[] values)` pour résoudre le problème suivant :\nCalcule la valeur totale maximale des herbes qui peuvent être collectées dans un temps donné.\n    La fonction prend le temps total disponible pour collecter les herbes, le nombre d'herbes différentes,\n    un tableau des coûts en temps pour chaque herbe, et un tableau des valeurs pour chaque herbe.\n\n    Paramètres :\n    totalMinutes - le temps total disponible pour collecter les herbes.\n    herbCount - le nombre d'herbes différentes disponibles.\n    timeCosts - un tableau où timeCosts[i] représente le temps nécessaire pour collecter la i-ème herbe.\n    values - un tableau où values[i] représente la valeur de la i-ème herbe.\n\n    Renvoie :\n    La valeur totale maximale des herbes qui peuvent être collectées dans le temps donné.\n\n    Exemples :\n    >>> MaxHerbValue(10, 3, new int[] {3, 4, 5}, new int[] {200, 300, 350})\n    550\n    >>> MaxHerbValue(5, 2, new int[] {1, 4}, new int[] {150, 300})\n    450",
      "de": "Schreiben Sie eine C#-Funktion `static int MaxHerbValue(int totalMinutes, int herbCount, int[] timeCosts, int[] values)`, um das folgende Problem zu lösen:\nBerechnet den maximalen Gesamtwert der Kräuter, die innerhalb einer bestimmten Zeit gesammelt werden können.\n    Die Funktion nimmt die insgesamt verfügbare Zeit zum Sammeln von Kräutern, die Anzahl der verschiedenen Kräuter,\n    ein Array von Zeitkosten für jedes Kraut und ein Array von Werten für jedes Kraut.\n\n    Parameter:\n    totalMinutes - die insgesamt verfügbare Zeit zum Sammeln von Kräutern.\n    herbCount - die Anzahl der verfügbaren verschiedenen Kräuter.\n    timeCosts - ein Array, wobei timeCosts[i] die Zeit darstellt, die benötigt wird, um das i-te Kraut zu sammeln.\n    values - ein Array, wobei values[i] den Wert des i-ten Krauts darstellt.\n\n    Rückgabe:\n    Der maximale Gesamtwert der Kräuter, die innerhalb der gegebenen Zeit gesammelt werden können.\n\n    Beispiele:\n    >>> MaxHerbValue(10, 3, new int[] {3, 4, 5}, new int[] {200, 300, 350})\n    550\n    >>> MaxHerbValue(5, 2, new int[] {1, 4}, new int[] {150, 300})\n    450",
      "ha": "Rubuta aikin C# `static int MaxHerbValue(int totalMinutes, int herbCount, int[] timeCosts, int[] values)` don warware matsalar mai zuwa:\nƘididdige jimillar ƙimar ganyayyaki mafi girma da za a iya tattarawa a cikin wani lokaci da aka bayar.\n    Aikin yana ɗaukar jimillar lokacin da ake da shi don tattara ganyayyaki, adadin ganyayyaki daban-daban,\n    jerin tsadar lokaci don kowane ganye, da jerin ƙimomi don kowane ganye.\n\n    Sigogi:\n    totalMinutes - jimillar lokacin da ake da shi don tattara ganyayyaki.\n    herbCount - adadin ganyayyaki daban-daban da ake da su.\n    timeCosts - jerin inda timeCosts[i] ke wakiltar lokacin da ake buƙata don tattara ganye na i-th.\n    values - jerin inda values[i] ke wakiltar ƙimar ganye na i-th.\n\n    Mayar da:\n    Jimillar ƙimar ganyayyaki mafi girma da za a iya tattarawa a cikin lokacin da aka bayar.\n\n    Misalai:\n    >>> MaxHerbValue(10, 3, new int[] {3, 4, 5}, new int[] {200, 300, 350})\n    550\n    >>> MaxHerbValue(5, 2, new int[] {1, 4}, new int[] {150, 300})\n    450",
      "hi": "C# फ़ंक्शन `static int MaxHerbValue(int totalMinutes, int herbCount, int[] timeCosts, int[] values)` लिखें ताकि निम्नलिखित समस्या का समाधान किया जा सके:\nदिए गए समय के भीतर एकत्र किए जा सकने वाले जड़ी-बूटियों के अधिकतम कुल मूल्य की गणना करता है।\n    फ़ंक्शन जड़ी-बूटियों को एकत्र करने के लिए उपलब्ध कुल समय, विभिन्न जड़ी-बूटियों की संख्या,\n    प्रत्येक जड़ी-बूटी के लिए समय लागत का एक सरणी, और प्रत्येक जड़ी-बूटी के लिए मूल्यों का एक सरणी लेता है।\n\n    पैरामीटर्स:\n    totalMinutes - जड़ी-बूटियों को एकत्र करने के लिए उपलब्ध कुल समय।\n    herbCount - उपलब्ध विभिन्न जड़ी-बूटियों की संख्या।\n    timeCosts - एक सरणी जहां timeCosts[i] i-वीं जड़ी-बूटी को एकत्र करने के लिए आवश्यक समय का प्रतिनिधित्व करता है।\n    values - एक सरणी जहां values[i] i-वीं जड़ी-बूटी के मूल्य का प्रतिनिधित्व करता है।\n\n    रिटर्न्स:\n    दिए गए समय के भीतर एकत्र किए जा सकने वाले जड़ी-बूटियों का अधिकतम कुल मूल्य।\n\n    उदाहरण:\n    >>> MaxHerbValue(10, 3, new int[] {3, 4, 5}, new int[] {200, 300, 350})\n    550\n    >>> MaxHerbValue(5, 2, new int[] {1, 4}, new int[] {150, 300})\n    450",
      "hu": "Írj egy C# függvényt `static int MaxHerbValue(int totalMinutes, int herbCount, int[] timeCosts, int[] values)` a következő probléma megoldására:\nKiszámítja a maximális összértéket, amit a gyógynövényekből lehet begyűjteni adott időn belül.\n    A függvény megkapja a gyógynövények gyűjtésére rendelkezésre álló teljes időt, a különböző gyógynövények számát,\n    egy tömböt az egyes gyógynövények időigényéről, és egy tömböt az egyes gyógynövények értékéről.\n\n    Paraméterek:\n    totalMinutes - a gyógynövények gyűjtésére rendelkezésre álló teljes idő.\n    herbCount - a rendelkezésre álló különböző gyógynövények száma.\n    timeCosts - egy tömb, ahol a timeCosts[i] az i-edik gyógynövény gyűjtéséhez szükséges időt jelenti.\n    values - egy tömb, ahol a values[i] az i-edik gyógynövény értékét jelenti.\n\n    Visszatérési érték:\n    A gyógynövényekből adott időn belül begyűjthető maximális összérték.\n\n    Példák:\n    >>> MaxHerbValue(10, 3, new int[] {3, 4, 5}, new int[] {200, 300, 350})\n    550\n    >>> MaxHerbValue(5, 2, new int[] {1, 4}, new int[] {150, 300})\n    450"
    },
    "instruction_bertscore": {
      "sq": "0.9905064609384375",
      "hy": "0.9881024374367723",
      "bn": "0.9764213819888725",
      "bg": "0.9994380746520523",
      "zh": "0.9910419684457076",
      "fr": "0.9912864824447615",
      "de": "0.9950177541525019",
      "ha": "0.987167086972479",
      "hi": "0.9798938383101244",
      "hu": "0.976105162422265"
    },
    "level": "middle",
    "test": "static void Main()\n    {\n        Debug.Assert(MaxHerbValue(10, 3, new int[] {3, 4, 5}, new int[] {200, 300, 350}) == 650);\n        Debug.Assert(MaxHerbValue(5, 2, new int[] {1, 4}, new int[] {150, 300}) == 450);\n        Debug.Assert(MaxHerbValue(7, 3, new int[] {2, 3, 5}, new int[] {100, 200, 300}) == 400);\n        Debug.Assert(MaxHerbValue(12, 4, new int[] {2, 4, 6, 3}, new int[] {100, 200, 300, 150}) == 600);\n        Debug.Assert(MaxHerbValue(8, 3, new int[] {1, 3, 4}, new int[] {150, 250, 350}) == 750);\n        Debug.Assert(MaxHerbValue(15, 5, new int[] {3, 5, 7, 4, 2}, new int[] {120, 280, 350, 220, 180}) == 810);\n\n\n    }\n}",
    "entry_point": "MaxHerbValue",
    "signature": "static int MaxHerbValue(int totalMinutes, int herbCount, int[] timeCosts, int[] values)",
    "docstring": {
      "en": "Calculates the maximum total value of herbs that can be collected within a given time.\n    The function takes the total time available for collecting herbs, the number of different herbs,\n    an array of time costs for each herb, and an array of values for each herb.\n\n    Parameters:\n    totalMinutes - the total time available for collecting herbs.\n    herbCount - the number of different herbs available.\n    timeCosts - an array where timeCosts[i] represents the time required to collect the i-th herb.\n    values - an array where values[i] represents the value of the i-th herb.\n\n    Returns:\n    The maximum total value of the herbs that can be collected within the given time.\n\n    Examples:\n    >>> MaxHerbValue(10, 3, new int[] {3, 4, 5}, new int[] {200, 300, 350})\n    550\n    >>> MaxHerbValue(5, 2, new int[] {1, 4}, new int[] {150, 300})\n    450",
      "sq": "Llogarit vlerën maksimale totale të bimëve që mund të mblidhen brenda një kohe të caktuar.\n    Funksioni merr kohën totale të disponueshme për mbledhjen e bimëve, numrin e bimëve të ndryshme,\n    një varg me koston e kohës për secilën bimë, dhe një varg me vlerat për secilën bimë.\n\n    Parametrat:\n    totalMinutes - koha totale e disponueshme për mbledhjen e bimëve.\n    herbCount - numri i bimëve të ndryshme të disponueshme.\n    timeCosts - një varg ku timeCosts[i] përfaqëson kohën e nevojshme për të mbledhur bimën e i-të.\n    values - një varg ku values[i] përfaqëson vlerën e bimës së i-të.\n\n    Kthen:\n    Vlera maksimale totale e bimëve që mund të mblidhen brenda kohës së dhënë.\n\n    Shembuj:\n    >>> MaxHerbValue(10, 3, new int[] {3, 4, 5}, new int[] {200, 300, 350})\n    550\n    >>> MaxHerbValue(5, 2, new int[] {1, 4}, new int[] {150, 300})\n    450",
      "hy": "Հաշվում է խոտաբույսերի առավելագույն ընդհանուր արժեքը, որը կարելի է հավաքել տրված ժամանակում:\n    Ֆունկցիան ընդունում է խոտաբույսերի հավաքման համար հասանելի ընդհանուր ժամանակը, տարբեր խոտաբույսերի քանակը,\n    ժամանակի ծախսերի զանգվածը յուրաքանչյուր խոտաբույսի համար և արժեքների զանգվածը յուրաքանչյուր խոտաբույսի համար:\n\n    Պարամետրեր:\n    totalMinutes - խոտաբույսերի հավաքման համար հասանելի ընդհանուր ժամանակը:\n    herbCount - հասանելի տարբեր խոտաբույսերի քանակը:\n    timeCosts - զանգված, որտեղ timeCosts[i]-ն ներկայացնում է i-րդ խոտաբույսի հավաքման համար պահանջվող ժամանակը:\n    values - զանգված, որտեղ values[i]-ն ներկայացնում է i-րդ խոտաբույսի արժեքը:\n\n    Վերադարձնում է:\n    Խոտաբույսերի առավելագույն ընդհանուր արժեքը, որը կարելի է հավաքել տրված ժամանակում:\n\n    Օրինակներ:\n    >>> MaxHerbValue(10, 3, new int[] {3, 4, 5}, new int[] {200, 300, 350})\n    550\n    >>> MaxHerbValue(5, 2, new int[] {1, 4}, new int[] {150, 300})\n    450",
      "bn": "হিসাব করে সর্বাধিক মোট মূল্য যা নির্দিষ্ট সময়ের মধ্যে সংগ্রহ করা যেতে পারে।\n    ফাংশনটি মোট সময় নেয় যা ভেষজ সংগ্রহের জন্য উপলব্ধ, বিভিন্ন ভেষজের সংখ্যা,\n    প্রতিটি ভেষজের জন্য সময় খরচের একটি অ্যারে, এবং প্রতিটি ভেষজের জন্য মানের একটি অ্যারে।\n\n    Args:\n    totalMinutes - ভেষজ সংগ্রহের জন্য উপলব্ধ মোট সময়।\n    herbCount - উপলব্ধ বিভিন্ন ভেষজের সংখ্যা।\n    timeCosts - একটি অ্যারে যেখানে timeCosts[i] i-তম ভেষজ সংগ্রহের জন্য প্রয়োজনীয় সময়কে উপস্থাপন করে।\n    values - একটি অ্যারে যেখানে values[i] i-তম ভেষজের মানকে উপস্থাপন করে।\n\n    Returns:\n    নির্দিষ্ট সময়ের মধ্যে সংগ্রহ করা যেতে পারে এমন ভেষজের সর্বাধিক মোট মূল্য।\n\n    Examples:\n    >>> MaxHerbValue(10, 3, new int[] {3, 4, 5}, new int[] {200, 300, 350})\n    550\n    >>> MaxHerbValue(5, 2, new int[] {1, 4}, new int[] {150, 300})\n    450",
      "bg": "Изчислява максималната обща стойност на билките, които могат да бъдат събрани в рамките на дадено време.\n    Функцията приема общото време, налично за събиране на билки, броя на различните билки,\n    масив от времеви разходи за всяка билка и масив от стойности за всяка билка.\n\n    Параметри:\n    totalMinutes - общото време, налично за събиране на билки.\n    herbCount - броят на различните налични билки.\n    timeCosts - масив, където timeCosts[i] представлява времето, необходимо за събиране на i-тата билка.\n    values - масив, където values[i] представлява стойността на i-тата билка.\n\n    Връща:\n    Максималната обща стойност на билките, които могат да бъдат събрани в рамките на даденото време.\n\n    Примери:\n    >>> MaxHerbValue(10, 3, new int[] {3, 4, 5}, new int[] {200, 300, 350})\n    550\n    >>> MaxHerbValue(5, 2, new int[] {1, 4}, new int[] {150, 300})\n    450",
      "zh": "计算在给定时间内可以收集的草药的最大总价值。\n函数接收用于收集草药的总时间、不同草药的数量、每种草药的时间成本数组以及每种草药的价值数组。\n\n参数：\ntotalMinutes - 收集草药的可用总时间。\nherbCount - 可用的不同草药的数量。\ntimeCosts - 一个数组，其中 timeCosts[i] 表示收集第 i 种草药所需的时间。\nvalues - 一个数组，其中 values[i] 表示第 i 种草药的价值。\n\n返回：\n在给定时间内可以收集的草药的最大总价值。\n\n示例：\n>>> MaxHerbValue(10, 3, new int[] {3, 4, 5}, new int[] {200, 300, 350})\n550\n>>> MaxHerbValue(5, 2, new int[] {1, 4}, new int[] {150, 300})\n450",
      "fr": "Calcule la valeur totale maximale des herbes qui peuvent être collectées dans un temps donné. La fonction prend le temps total disponible pour collecter les herbes, le nombre de différentes herbes, un tableau des coûts en temps pour chaque herbe, et un tableau des valeurs pour chaque herbe.\n\nParamètres :\ntotalMinutes - le temps total disponible pour collecter les herbes.\nherbCount - le nombre de différentes herbes disponibles.\ntimeCosts - un tableau où timeCosts[i] représente le temps requis pour collecter la i-ème herbe.\nvalues - un tableau où values[i] représente la valeur de la i-ème herbe.\n\nRenvoie :\nLa valeur totale maximale des herbes qui peuvent être collectées dans le temps donné.\n\nExemples :\n>>> MaxHerbValue(10, 3, new int[] {3, 4, 5}, new int[] {200, 300, 350})\n550\n>>> MaxHerbValue(5, 2, new int[] {1, 4}, new int[] {150, 300})\n450",
      "de": "Berechnet den maximalen Gesamtwert der Kräuter, die innerhalb einer bestimmten Zeit gesammelt werden können.\n    Die Funktion nimmt die insgesamt verfügbare Zeit zum Sammeln von Kräutern, die Anzahl der verschiedenen Kräuter,\n    ein Array von Zeitkosten für jedes Kraut und ein Array von Werten für jedes Kraut.\n\n    Parameter:\n    totalMinutes - die insgesamt verfügbare Zeit zum Sammeln von Kräutern.\n    herbCount - die Anzahl der verfügbaren verschiedenen Kräuter.\n    timeCosts - ein Array, wobei timeCosts[i] die Zeit darstellt, die benötigt wird, um das i-te Kraut zu sammeln.\n    values - ein Array, wobei values[i] den Wert des i-ten Krauts darstellt.\n\n    Rückgabewert:\n    Der maximale Gesamtwert der Kräuter, die innerhalb der gegebenen Zeit gesammelt werden können.\n\n    Beispiele:\n    >>> MaxHerbValue(10, 3, new int[] {3, 4, 5}, new int[] {200, 300, 350})\n    550\n    >>> MaxHerbValue(5, 2, new int[] {1, 4}, new int[] {150, 300})\n    450",
      "ha": "Lissafa mafi girman jimillar ƙimar ganyayyaki da za a iya tattarawa a cikin wani lokaci da aka bayar.\n    Aikin yana ɗaukar jimillar lokacin da ake da shi don tattara ganyayyaki, adadin nau'ikan ganyayyaki daban-daban,\n    jerin farashin lokaci don kowane ganye, da jerin ƙimar kowane ganye.\n\n    Parameters:\n    totalMinutes - jimillar lokacin da ake da shi don tattara ganyayyaki.\n    herbCount - adadin nau'ikan ganyayyaki daban-daban da ake da su.\n    timeCosts - jerin inda timeCosts[i] ke wakiltar lokacin da ake bukata don tattara i-th ganye.\n    values - jerin inda values[i] ke wakiltar ƙimar i-th ganye.\n\n    Returns:\n    Mafi girman jimillar ƙimar ganyayyakin da za a iya tattarawa a cikin lokacin da aka bayar.\n\n    Examples:\n    >>> MaxHerbValue(10, 3, new int[] {3, 4, 5}, new int[] {200, 300, 350})\n    550\n    >>> MaxHerbValue(5, 2, new int[] {1, 4}, new int[] {150, 300})\n    450",
      "hi": "दिए गए समय के भीतर एकत्र किए जा सकने वाले जड़ी-बूटियों के अधिकतम कुल मूल्य की गणना करता है।\n    यह फ़ंक्शन जड़ी-बूटियों को इकट्ठा करने के लिए उपलब्ध कुल समय, विभिन्न जड़ी-बूटियों की संख्या,\n    प्रत्येक जड़ी-बूटी के लिए समय लागत का एक सरणी, और प्रत्येक जड़ी-बूटी के लिए मूल्यों का एक सरणी लेता है।\n\n    Parameters:\n    totalMinutes - जड़ी-बूटियों को इकट्ठा करने के लिए उपलब्ध कुल समय।\n    herbCount - उपलब्ध विभिन्न जड़ी-बूटियों की संख्या।\n    timeCosts - एक सरणी जहाँ timeCosts[i] i-वीं जड़ी-बूटी को इकट्ठा करने के लिए आवश्यक समय को दर्शाता है।\n    values - एक सरणी जहाँ values[i] i-वीं जड़ी-बूटी के मूल्य को दर्शाता है।\n\n    Returns:\n    दिए गए समय के भीतर इकट्ठा की जा सकने वाली जड़ी-बूटियों का अधिकतम कुल मूल्य।\n\n    Examples:\n    >>> MaxHerbValue(10, 3, new int[] {3, 4, 5}, new int[] {200, 300, 350})\n    550\n    >>> MaxHerbValue(5, 2, new int[] {1, 4}, new int[] {150, 300})\n    450",
      "hu": "Kiszámítja a maximálisan összegyűjthető gyógynövények összértékét adott időn belül. \n    A függvény megkapja az összes rendelkezésre álló időt a gyógynövények gyűjtésére, a különböző gyógynövények számát,\n    egy tömböt az egyes gyógynövények időigényével, és egy tömböt az egyes gyógynövények értékével.\n\n    Paraméterek:\n    totalMinutes - az összes rendelkezésre álló idő a gyógynövények gyűjtésére.\n    herbCount - a rendelkezésre álló különböző gyógynövények száma.\n    timeCosts - egy tömb, ahol a timeCosts[i] az i-edik gyógynövény gyűjtéséhez szükséges időt jelenti.\n    values - egy tömb, ahol a values[i] az i-edik gyógynövény értékét jelenti.\n\n    Visszatérési érték:\n    A maximálisan összegyűjthető gyógynövények összértéke az adott időn belül.\n\n    Példák:\n    >>> MaxHerbValue(10, 3, new int[] {3, 4, 5}, new int[] {200, 300, 350})\n    550\n    >>> MaxHerbValue(5, 2, new int[] {1, 4}, new int[] {150, 300})\n    450"
    },
    "docstring_bertscore": {
      "sq": "0.9845761522822599",
      "hy": "0.9922148808457186",
      "bn": "0.9683126939438853",
      "bg": "0.9963088516292287",
      "zh": "0.9830463010875292",
      "fr": "0.9907805708642656",
      "de": "0.9929732516405098",
      "ha": "0.9689804892849246",
      "hi": "0.9862297502043753",
      "hu": "0.9742052628276663"
    }
  },
  {
    "task_id": "C#/14",
    "prompt": {
      "en": "using System;\nusing System.Collections.Generic;\nusing System.Diagnostics;\n\nclass Program\n{\n/* \n    This function takes a list of integers and performs two operations. Firstly, it removes any duplicate numbers, ensuring each number is unique. Secondly, it sorts the remaining numbers in ascending order.\n    Example usage:\n    >>> UniqueAndSorted(new List<int> {4, 2, 2, 5, 1})\n    [1, 2, 4, 5]\n    >>> UniqueAndSorted(new List<int> {10, 9, 8, 7, 8, 9, 10})\n    [7, 8, 9, 10]\n*/\n   static List<int> UniqueAndSorted(List<int> numbers)",
      "sq": "using System;\nusing System.Collections.Generic;\nusing System.Diagnostics;\n\nclass Program\n{\n/* \n    Kjo funksion merr një listë të numrave të plotë dhe kryen dy operacione. Së pari, heq çdo numër të dyfishtë, duke siguruar që çdo numër të jetë unik. Së dyti, rendit numrat e mbetur në rend rritës.\n    Shembull përdorimi:\n    >>> UniqueAndSorted(new List<int> {4, 2, 2, 5, 1})\n    [1, 2, 4, 5]\n    >>> UniqueAndSorted(new List<int> {10, 9, 8, 7, 8, 9, 10})\n    [7, 8, 9, 10]\n*/\n   static List<int> UniqueAndSorted(List<int> numbers)",
      "hy": "using System;\nusing System.Collections.Generic;\nusing System.Diagnostics;\n\nclass Program\n{\n/* \n    Այս ֆունկցիան ընդունում է ամբողջ թվերի ցուցակ և կատարում է երկու գործողություն։ Նախ, այն հեռացնում է կրկնվող թվերը՝ ապահովելով, որ յուրաքանչյուր թիվ լինի եզակի։ Երկրորդ, այն դասավորում է մնացած թվերը աճման կարգով։\n    Օգտագործման օրինակ:\n    >>> UniqueAndSorted(new List<int> {4, 2, 2, 5, 1})\n    [1, 2, 4, 5]\n    >>> UniqueAndSorted(new List<int> {10, 9, 8, 7, 8, 9, 10})\n    [7, 8, 9, 10]\n*/\n   static List<int> UniqueAndSorted(List<int> numbers)",
      "bn": "using System;\nusing System.Collections.Generic;\nusing System.Diagnostics;\n\nclass Program\n{\n/* \n    এই ফাংশনটি পূর্ণসংখ্যার একটি তালিকা গ্রহণ করে এবং দুটি অপারেশন সম্পন্ন করে। প্রথমত, এটি যেকোনও সদৃশ সংখ্যা সরিয়ে দেয়, প্রতিটি সংখ্যা অনন্য হওয়া নিশ্চিত করে। দ্বিতীয়ত, এটি অবশিষ্ট সংখ্যাগুলিকে ঊর্ধ্বক্রমে সাজায়।\n    উদাহরণ ব্যবহার:\n    >>> UniqueAndSorted(new List<int> {4, 2, 2, 5, 1})\n    [1, 2, 4, 5]\n    >>> UniqueAndSorted(new List<int> {10, 9, 8, 7, 8, 9, 10})\n    [7, 8, 9, 10]\n*/\n   static List<int> UniqueAndSorted(List<int> numbers)",
      "bg": "using System;\nusing System.Collections.Generic;\nusing System.Diagnostics;\n\nclass Program\n{\n/* \n    Тази функция приема списък от цели числа и извършва две операции. Първо, премахва всички дублиращи се числа, като гарантира, че всяко число е уникално. Второ, сортира останалите числа във възходящ ред.\n    Пример за използване:\n    >>> UniqueAndSorted(new List<int> {4, 2, 2, 5, 1})\n    [1, 2, 4, 5]\n    >>> UniqueAndSorted(new List<int> {10, 9, 8, 7, 8, 9, 10})\n    [7, 8, 9, 10]\n*/\n   static List<int> UniqueAndSorted(List<int> numbers)",
      "zh": "using System;\nusing System.Collections.Generic;\nusing System.Diagnostics;\n\nclass Program\n{\n/* \n    此函数接受一个整数列表并执行两个操作。首先，它删除任何重复的数字，确保每个数字都是唯一的。其次，它按升序对剩余的数字进行排序。\n    示例用法:\n    >>> UniqueAndSorted(new List<int> {4, 2, 2, 5, 1})\n    [1, 2, 4, 5]\n    >>> UniqueAndSorted(new List<int> {10, 9, 8, 7, 8, 9, 10})\n    [7, 8, 9, 10]\n*/\n   static List<int> UniqueAndSorted(List<int> numbers)",
      "fr": "using System;\nusing System.Collections.Generic;\nusing System.Diagnostics;\n\nclass Program\n{\n/* \n    Cette fonction prend une liste d'entiers et effectue deux opérations. Premièrement, elle supprime tous les nombres en double, garantissant que chaque nombre est unique. Deuxièmement, elle trie les nombres restants par ordre croissant.\n    Exemple d'utilisation :\n    >>> UniqueAndSorted(new List<int> {4, 2, 2, 5, 1})\n    [1, 2, 4, 5]\n    >>> UniqueAndSorted(new List<int> {10, 9, 8, 7, 8, 9, 10})\n    [7, 8, 9, 10]\n*/\n   static List<int> UniqueAndSorted(List<int> numbers)",
      "de": "using System;\nusing System.Collections.Generic;\nusing System.Diagnostics;\n\nclass Program\n{\n/* \n    Diese Funktion nimmt eine Liste von ganzen Zahlen und führt zwei Operationen aus. Erstens entfernt sie alle doppelten Zahlen, sodass jede Zahl einzigartig ist. Zweitens sortiert sie die verbleibenden Zahlen in aufsteigender Reihenfolge.\n    Beispielverwendung:\n    >>> UniqueAndSorted(new List<int> {4, 2, 2, 5, 1})\n    [1, 2, 4, 5]\n    >>> UniqueAndSorted(new List<int> {10, 9, 8, 7, 8, 9, 10})\n    [7, 8, 9, 10]\n*/\n   static List<int> UniqueAndSorted(List<int> numbers)",
      "ha": "using System;\nusing System.Collections.Generic;\nusing System.Diagnostics;\n\nclass Program\n{\n/* \n    Wannan aikin yana ɗaukar jerin lambobi kuma yana aiwatar da ayyuka biyu. Da farko, yana cire duk wani lamba mai maimaituwa, yana tabbatar da cewa kowace lamba ta kasance ta musamman. Na biyu, yana tsara lambobin da suka rage cikin tsari mai hawa.\n    Misalin amfani:\n    >>> UniqueAndSorted(new List<int> {4, 2, 2, 5, 1})\n    [1, 2, 4, 5]\n    >>> UniqueAndSorted(new List<int> {10, 9, 8, 7, 8, 9, 10})\n    [7, 8, 9, 10]\n*/\n   static List<int> UniqueAndSorted(List<int> numbers)",
      "hi": "using System;\nusing System.Collections.Generic;\nusing System.Diagnostics;\n\nclass Program\n{\n/* \n    यह फ़ंक्शन पूर्णांकों की एक सूची लेता है और दो कार्य करता है। सबसे पहले, यह किसी भी डुप्लिकेट नंबर को हटा देता है, जिससे यह सुनिश्चित होता है कि प्रत्येक नंबर अद्वितीय है। दूसरे, यह शेष संख्याओं को आरोही क्रम में व्यवस्थित करता है।\n    उदाहरण उपयोग:\n    >>> UniqueAndSorted(new List<int> {4, 2, 2, 5, 1})\n    [1, 2, 4, 5]\n    >>> UniqueAndSorted(new List<int> {10, 9, 8, 7, 8, 9, 10})\n    [7, 8, 9, 10]\n*/\n   static List<int> UniqueAndSorted(List<int> numbers)",
      "hu": "using System;\nusing System.Collections.Generic;\nusing System.Diagnostics;\n\nclass Program\n{\n/* \n    Ez a függvény egy egész számokat tartalmazó listát vesz át, és két műveletet hajt végre. Először eltávolítja az ismétlődő számokat, biztosítva, hogy minden szám egyedi legyen. Másodszor, a megmaradt számokat növekvő sorrendbe rendezi.\n    Példa használat:\n    >>> UniqueAndSorted(new List<int> {4, 2, 2, 5, 1})\n    [1, 2, 4, 5]\n    >>> UniqueAndSorted(new List<int> {10, 9, 8, 7, 8, 9, 10})\n    [7, 8, 9, 10]\n*/\n   static List<int> UniqueAndSorted(List<int> numbers)"
    },
    "prompt_bertscore": {
      "sq": "0.9916040924240364",
      "hy": "0.9891156510104312",
      "bn": "0.9953993231144699",
      "bg": "0.9927382718997455",
      "zh": "0.9930439640561582",
      "fr": "0.9858533456323142",
      "de": "0.9906919817143242",
      "ha": "0.9869595182242975",
      "hi": "0.9827274993259681",
      "hu": "0.9922361342964894"
    },
    "canonical_solution": "{\n    HashSet<int> uniqueNumbers = new HashSet<int>(numbers);\n    List<int> sortedNumbers = new List<int>(uniqueNumbers);\n    sortedNumbers.Sort();\n    return sortedNumbers;\n}",
    "instruction": {
      "en": "Write a C# function `static List<int> UniqueAndSorted(List<int> numbers)` to solve the following problem:\nThis function takes a list of integers and performs two operations. Firstly, it removes any duplicate numbers, ensuring each number is unique. Secondly, it sorts the remaining numbers in ascending order.\n    Example usage:\n    >>> UniqueAndSorted(new List<int> {4, 2, 2, 5, 1})\n    [1, 2, 4, 5]\n    >>> UniqueAndSorted(new List<int> {10, 9, 8, 7, 8, 9, 10})\n    [7, 8, 9, 10]",
      "sq": "Shkruani një funksion C# `static List<int> UniqueAndSorted(List<int> numbers)` për të zgjidhur problemin e mëposhtëm: Ky funksion merr një listë të numrave të plotë dhe kryen dy operacione. Së pari, ai heq çdo numër të dyfishtë, duke siguruar që çdo numër të jetë unik. Së dyti, ai rendit numrat e mbetur në rend rritës.\n    Shembull përdorimi:\n    >>> UniqueAndSorted(new List<int> {4, 2, 2, 5, 1})\n    [1, 2, 4, 5]\n    >>> UniqueAndSorted(new List<int> {10, 9, 8, 7, 8, 9, 10})\n    [7, 8, 9, 10]",
      "hy": "Գրեք C# ֆունկցիա `static List<int> UniqueAndSorted(List<int> numbers)`՝ հետևյալ խնդիրը լուծելու համար:\nԱյս ֆունկցիան ընդունում է ամբողջ թվերի ցուցակ և կատարում է երկու գործողություն։ Նախ, այն հեռացնում է կրկնվող թվերը, ապահովելով, որ յուրաքանչյուր թիվ լինի եզակի։ Երկրորդ, այն դասավորում է մնացած թվերը աճման կարգով։\n    Օրինակ օգտագործում:\n    >>> UniqueAndSorted(new List<int> {4, 2, 2, 5, 1})\n    [1, 2, 4, 5]\n    >>> UniqueAndSorted(new List<int> {10, 9, 8, 7, 8, 9, 10})\n    [7, 8, 9, 10]",
      "bn": "C# ফাংশন `static List<int> UniqueAndSorted(List<int> numbers)` লিখুন নিম্নলিখিত সমস্যার সমাধানের জন্য:\nএই ফাংশনটি পূর্ণসংখ্যার একটি তালিকা গ্রহণ করে এবং দুটি অপারেশন সম্পাদন করে। প্রথমত, এটি কোনো সদৃশ সংখ্যা সরিয়ে দেয়, প্রতিটি সংখ্যা অনন্য হওয়া নিশ্চিত করে। দ্বিতীয়ত, এটি অবশিষ্ট সংখ্যাগুলিকে ঊর্ধ্বক্রমে সাজায়।\n    উদাহরণ ব্যবহার:\n    >>> UniqueAndSorted(new List<int> {4, 2, 2, 5, 1})\n    [1, 2, 4, 5]\n    >>> UniqueAndSorted(new List<int> {10, 9, 8, 7, 8, 9, 10})\n    [7, 8, 9, 10]",
      "bg": "Напишете C# функция `static List<int> UniqueAndSorted(List<int> numbers)`, за да решите следния проблем:\nТази функция приема списък от цели числа и извършва две операции. Първо, премахва всички дублиращи се числа, като гарантира, че всяко число е уникално. Второ, сортира останалите числа във възходящ ред.\n    Пример за използване:\n    >>> UniqueAndSorted(new List<int> {4, 2, 2, 5, 1})\n    [1, 2, 4, 5]\n    >>> UniqueAndSorted(new List<int> {10, 9, 8, 7, 8, 9, 10})\n    [7, 8, 9, 10]",
      "zh": "编写一个 C# 函数 `static List<int> UniqueAndSorted(List<int> numbers)` 来解决以下问题：\n该函数接受一个整数列表并执行两个操作。首先，它移除任何重复的数字，确保每个数字都是唯一的。其次，它将剩余的数字按升序排序。\n    示例用法:\n    >>> UniqueAndSorted(new List<int> {4, 2, 2, 5, 1})\n    [1, 2, 4, 5]\n    >>> UniqueAndSorted(new List<int> {10, 9, 8, 7, 8, 9, 10})\n    [7, 8, 9, 10]",
      "fr": "Écrire une fonction C# `static List<int> UniqueAndSorted(List<int> numbers)` pour résoudre le problème suivant :  \nCette fonction prend une liste d'entiers et effectue deux opérations. Premièrement, elle supprime tous les nombres en double, s'assurant que chaque nombre est unique. Deuxièmement, elle trie les nombres restants par ordre croissant.  \n    Exemple d'utilisation :  \n    >>> UniqueAndSorted(new List<int> {4, 2, 2, 5, 1})  \n    [1, 2, 4, 5]  \n    >>> UniqueAndSorted(new List<int> {10, 9, 8, 7, 8, 9, 10})  \n    [7, 8, 9, 10]",
      "de": "Schreiben Sie eine C#-Funktion `static List<int> UniqueAndSorted(List<int> numbers)`, um das folgende Problem zu lösen:\nDiese Funktion nimmt eine Liste von ganzen Zahlen und führt zwei Operationen durch. Erstens entfernt sie alle doppelten Zahlen, sodass jede Zahl einzigartig ist. Zweitens sortiert sie die verbleibenden Zahlen in aufsteigender Reihenfolge.\n    Beispielverwendung:\n    >>> UniqueAndSorted(new List<int> {4, 2, 2, 5, 1})\n    [1, 2, 4, 5]\n    >>> UniqueAndSorted(new List<int> {10, 9, 8, 7, 8, 9, 10})\n    [7, 8, 9, 10]",
      "ha": "Rubuta aikin C# `static List<int> UniqueAndSorted(List<int> numbers)` don warware matsalar mai zuwa:\nWannan aikin yana karɓar jerin lambobi na integers kuma yana aiwatar da ayyuka biyu. Da fari, yana cire duk wani lambobi masu maimaituwa, yana tabbatar da cewa kowanne lamba ya zama na musamman. Na biyu, yana tsara sauran lambobin cikin tsari mai ƙaruwa.\n    Misalin amfani:\n    >>> UniqueAndSorted(new List<int> {4, 2, 2, 5, 1})\n    [1, 2, 4, 5]\n    >>> UniqueAndSorted(new List<int> {10, 9, 8, 7, 8, 9, 10})\n    [7, 8, 9, 10]",
      "hi": "C# फ़ंक्शन `static List<int> UniqueAndSorted(List<int> numbers)` लिखें ताकि निम्नलिखित समस्या का समाधान किया जा सके:\nयह फ़ंक्शन पूर्णांकों की एक सूची लेता है और दो कार्य करता है। सबसे पहले, यह किसी भी डुप्लिकेट संख्या को हटा देता है, यह सुनिश्चित करते हुए कि प्रत्येक संख्या अद्वितीय है। दूसरे, यह शेष संख्याओं को आरोही क्रम में क्रमबद्ध करता है।\n    उदाहरण उपयोग:\n    >>> UniqueAndSorted(new List<int> {4, 2, 2, 5, 1})\n    [1, 2, 4, 5]\n    >>> UniqueAndSorted(new List<int> {10, 9, 8, 7, 8, 9, 10})\n    [7, 8, 9, 10]",
      "hu": "Írj egy C# függvényt `static List<int> UniqueAndSorted(List<int> numbers)` a következő probléma megoldására:\nEz a függvény egy egész számokat tartalmazó listát vesz át, és két műveletet hajt végre. Először eltávolítja az ismétlődő számokat, biztosítva, hogy minden szám egyedi legyen. Másodszor, a megmaradt számokat növekvő sorrendbe rendezi.\n    Példa használat:\n    >>> UniqueAndSorted(new List<int> {4, 2, 2, 5, 1})\n    [1, 2, 4, 5]\n    >>> UniqueAndSorted(new List<int> {10, 9, 8, 7, 8, 9, 10})\n    [7, 8, 9, 10]"
    },
    "instruction_bertscore": {
      "sq": "0.9978269836314784",
      "hy": "0.9951742748927573",
      "bn": "0.9840938777171072",
      "bg": "0.9965313176559878",
      "zh": "0.9943044724542056",
      "fr": "0.9914751813067447",
      "de": "0.9906707282635534",
      "ha": "0.9950328500614606",
      "hi": "0.9832608218990468",
      "hu": "0.994312417669447"
    },
    "level": "easy",
    "test": "static void Main()\n    {\n        Debug.Assert(UniqueAndSorted(new List<int> { 3, 1, 2, 1 }) .SequenceEqual(new List<int> { 1, 2, 3 }));\n        Debug.Assert(UniqueAndSorted(new List<int> { 5, 4, 5, 4, 5 }) .SequenceEqual(new List<int> { 4, 5 }));\n        Debug.Assert(UniqueAndSorted(new List<int> { 8, 7, 9, 6, 10 }) .SequenceEqual(new List<int> { 6, 7, 8, 9, 10 }));\n        Debug.Assert(UniqueAndSorted(new List<int> { 11, 11, 11 }) .SequenceEqual(new List<int> { 11 }));\n        Debug.Assert(UniqueAndSorted(new List<int> { 15, 14, 13, 12, 11, 15, 14 }) .SequenceEqual(new List<int> { 11, 12, 13, 14, 15 }));\n\n    }\n}",
    "entry_point": "UniqueAndSorted",
    "signature": "static List<int> UniqueAndSorted(List<int> numbers)",
    "docstring": {
      "en": "This function takes a list of integers and performs two operations. Firstly, it removes any duplicate numbers, ensuring each number is unique. Secondly, it sorts the remaining numbers in ascending order.\n    Example usage:\n    >>> UniqueAndSorted(new List<int> {4, 2, 2, 5, 1})\n    [1, 2, 4, 5]\n    >>> UniqueAndSorted(new List<int> {10, 9, 8, 7, 8, 9, 10})\n    [7, 8, 9, 10]",
      "sq": "Kjo funksion merr një listë të numrave të plotë dhe kryen dy operacione. Së pari, heq çdo numër të përsëritur, duke siguruar që çdo numër të jetë unik. Së dyti, rendit numrat e mbetur në rritje.\n    Shembull përdorimi:\n    >>> UniqueAndSorted(new List<int> {4, 2, 2, 5, 1})\n    [1, 2, 4, 5]\n    >>> UniqueAndSorted(new List<int> {10, 9, 8, 7, 8, 9, 10})\n    [7, 8, 9, 10]",
      "hy": "Այս ֆունկցիան ընդունում է ամբողջ թվերի ցուցակ և կատարում է երկու գործողություն։ Նախ, այն հեռացնում է կրկնվող թվերը, ապահովելով, որ յուրաքանչյուր թիվ լինի եզակի։ Երկրորդ, այն տեսակավորում է մնացած թվերը աճման կարգով։\n    Օրինակ օգտագործում:\n    >>> UniqueAndSorted(new List<int> {4, 2, 2, 5, 1})\n    [1, 2, 4, 5]\n    >>> UniqueAndSorted(new List<int> {10, 9, 8, 7, 8, 9, 10})\n    [7, 8, 9, 10]",
      "bn": "এই ফাংশনটি পূর্ণসংখ্যার একটি তালিকা গ্রহণ করে এবং দুটি অপারেশন সম্পাদন করে। প্রথমত, এটি কোনো সদৃশ সংখ্যা সরিয়ে দেয়, প্রতিটি সংখ্যাকে অনন্য করে তোলে। দ্বিতীয়ত, এটি অবশিষ্ট সংখ্যাগুলিকে ঊর্ধ্বক্রমে সাজায়।\n    উদাহরণ ব্যবহার:\n    >>> UniqueAndSorted(new List<int> {4, 2, 2, 5, 1})\n    [1, 2, 4, 5]\n    >>> UniqueAndSorted(new List<int> {10, 9, 8, 7, 8, 9, 10})\n    [7, 8, 9, 10]",
      "bg": "Тази функция приема списък от цели числа и извършва две операции. Първо, премахва всички дублиращи се числа, като гарантира, че всяко число е уникално. Второ, сортира останалите числа във възходящ ред.\n    Пример за използване:\n    >>> UniqueAndSorted(new List<int> {4, 2, 2, 5, 1})\n    [1, 2, 4, 5]\n    >>> UniqueAndSorted(new List<int> {10, 9, 8, 7, 8, 9, 10})\n    [7, 8, 9, 10]",
      "zh": "这个函数接受一个整数列表并执行两个操作。首先，它移除任何重复的数字，确保每个数字都是唯一的。其次，它将剩余的数字按升序排序。\n    示例用法:\n    >>> UniqueAndSorted(new List<int> {4, 2, 2, 5, 1})\n    [1, 2, 4, 5]\n    >>> UniqueAndSorted(new List<int> {10, 9, 8, 7, 8, 9, 10})\n    [7, 8, 9, 10]",
      "fr": "Cette fonction prend une liste d'entiers et effectue deux opérations. Premièrement, elle supprime tous les nombres en double, garantissant que chaque nombre est unique. Deuxièmement, elle trie les nombres restants par ordre croissant.\n    Exemple d'utilisation :\n    >>> UniqueAndSorted(new List<int> {4, 2, 2, 5, 1})\n    [1, 2, 4, 5]\n    >>> UniqueAndSorted(new List<int> {10, 9, 8, 7, 8, 9, 10})\n    [7, 8, 9, 10]",
      "de": "Diese Funktion nimmt eine Liste von ganzen Zahlen und führt zwei Operationen durch. Erstens entfernt sie alle doppelten Zahlen, sodass jede Zahl einzigartig ist. Zweitens sortiert sie die verbleibenden Zahlen in aufsteigender Reihenfolge.\n    Beispielverwendung:\n    >>> UniqueAndSorted(new List<int> {4, 2, 2, 5, 1})\n    [1, 2, 4, 5]\n    >>> UniqueAndSorted(new List<int> {10, 9, 8, 7, 8, 9, 10})\n    [7, 8, 9, 10]",
      "ha": "Wannan aikin yana karɓar jerin lambobi masu cikakken lamba kuma yana aiwatar da ayyuka guda biyu. Da farko, yana cire duk lambobi masu maimaitawa, yana tabbatar da cewa kowace lamba ta kasance ta musamman. Na biyu, yana tsara lambobin da suka rage a cikin tsari mai hawa sama.\n    Misalin amfani:\n    >>> UniqueAndSorted(new List<int> {4, 2, 2, 5, 1})\n    [1, 2, 4, 5]\n    >>> UniqueAndSorted(new List<int> {10, 9, 8, 7, 8, 9, 10})\n    [7, 8, 9, 10]",
      "hi": "यह फ़ंक्शन पूर्णांकों की एक सूची लेता है और दो संचालन करता है। सबसे पहले, यह किसी भी डुप्लिकेट संख्याओं को हटा देता है, यह सुनिश्चित करते हुए कि प्रत्येक संख्या अद्वितीय है। दूसरे, यह शेष संख्याओं को आरोही क्रम में क्रमबद्ध करता है।\n    उदाहरण उपयोग:\n    >>> UniqueAndSorted(new List<int> {4, 2, 2, 5, 1})\n    [1, 2, 4, 5]\n    >>> UniqueAndSorted(new List<int> {10, 9, 8, 7, 8, 9, 10})\n    [7, 8, 9, 10]",
      "hu": "Ez a függvény egy egész számokat tartalmazó listát vesz át, és két műveletet hajt végre. Először eltávolítja az ismétlődő számokat, biztosítva, hogy minden szám egyedi legyen. Másodszor, a megmaradt számokat növekvő sorrendbe rendezi.\n    Példa használat:\n    >>> UniqueAndSorted(new List<int> {4, 2, 2, 5, 1})\n    [1, 2, 4, 5]\n    >>> UniqueAndSorted(new List<int> {10, 9, 8, 7, 8, 9, 10})\n    [7, 8, 9, 10]"
    },
    "docstring_bertscore": {
      "sq": "0.9909698656173919",
      "hy": "0.9888971575912928",
      "bn": "0.9877784712853044",
      "bg": "0.9895099323167855",
      "zh": "0.9966626123378518",
      "fr": "0.9815563745993865",
      "de": "0.9905249335638737",
      "ha": "0.9883106020760968",
      "hi": "0.9909698656173919",
      "hu": "0.9924196687685656"
    }
  },
  {
    "task_id": "C#/15",
    "prompt": {
      "en": "using System;\nusing System.Collections.Generic;\nusing System.Diagnostics;\n\nclass Program\n{\n/* This function awards the top 5 students based on their total scores. Students are sorted first by their total score (Chinese, Mathematics, English),\n   then by their Chinese score, and finally by their student ID if there is a tie. The function returns a list of the top 5 students with their IDs and total scores.\n   Example:\n   >>> AwardTopStudents([(1, 80, 90, 85), (2, 85, 80, 90), (3, 90, 85, 80)])\n   [(3, 255), (2, 255), (1, 255)]\n   >>> AwardTopStudents([(4, 88, 75, 95), (5, 95, 88, 75)])\n   [(4, 258), (5, 258)]\n*/\n   static List<(int, int)> AwardTopStudents(List<(int, int, int, int)> students)",
      "sq": "using System;\nusing System.Collections.Generic;\nusing System.Diagnostics;\n\nclass Program\n{\n/* Kjo funksion shpërblen 5 studentët më të mirë bazuar në totalin e pikëve të tyre. Studentët renditen fillimisht sipas totalit të pikëve (Kinezisht, Matematikë, Anglisht),\n   pastaj sipas pikëve të tyre në Kinezisht, dhe përfundimisht sipas ID-së së studentit nëse ka barazim. Funksioni kthen një listë të 5 studentëve më të mirë me ID-të dhe totalin e pikëve të tyre.\n   Shembull:\n   >>> AwardTopStudents([(1, 80, 90, 85), (2, 85, 80, 90), (3, 90, 85, 80)])\n   [(3, 255), (2, 255), (1, 255)]\n   >>> AwardTopStudents([(4, 88, 75, 95), (5, 95, 88, 75)])\n   [(4, 258), (5, 258)]\n*/\n   static List<(int, int)> AwardTopStudents(List<(int, int, int, int)> students)",
      "hy": "using System;\nusing System.Collections.Generic;\nusing System.Diagnostics;\n\nclass Program\n{\n/* Այս ֆունկցիան պարգևատրում է լավագույն 5 ուսանողներին՝ հիմնված նրանց ընդհանուր միավորների վրա։ Ուսանողները դասակարգվում են նախ իրենց ընդհանուր միավորներով (չինարեն, մաթեմատիկա, անգլերեն),\n   ապա՝ չինարենի միավորներով, և վերջապես՝ ուսանողի ID-ով, եթե կա հավասարություն։ Ֆունկցիան վերադարձնում է լավագույն 5 ուսանողների ցուցակը՝ նրանց ID-ներով և ընդհանուր միավորներով։\n   Օրինակ:\n   >>> AwardTopStudents([(1, 80, 90, 85), (2, 85, 80, 90), (3, 90, 85, 80)])\n   [(3, 255), (2, 255), (1, 255)]\n   >>> AwardTopStudents([(4, 88, 75, 95), (5, 95, 88, 75)])\n   [(4, 258), (5, 258)]\n*/\n   static List<(int, int)> AwardTopStudents(List<(int, int, int, int)> students)",
      "bn": "using System;\nusing System.Collections.Generic;\nusing System.Diagnostics;\n\nclass Program\n{\n/* এই ফাংশনটি মোট স্কোরের ভিত্তিতে শীর্ষ ৫ জন ছাত্রকে পুরস্কৃত করে। ছাত্রদের প্রথমে তাদের মোট স্কোর (চীনা, গণিত, ইংরেজি) দ্বারা সাজানো হয়,\n   তারপর তাদের চীনা স্কোর দ্বারা, এবং অবশেষে যদি টাই হয় তবে তাদের ছাত্র আইডি দ্বারা। ফাংশনটি শীর্ষ ৫ জন ছাত্রের আইডি এবং মোট স্কোরের একটি তালিকা প্রদান করে।\n   উদাহরণ:\n   >>> AwardTopStudents([(1, 80, 90, 85), (2, 85, 80, 90), (3, 90, 85, 80)])\n   [(3, 255), (2, 255), (1, 255)]\n   >>> AwardTopStudents([(4, 88, 75, 95), (5, 95, 88, 75)])\n   [(4, 258), (5, 258)]\n*/\n   static List<(int, int)> AwardTopStudents(List<(int, int, int, int)> students)",
      "bg": "using System;\nusing System.Collections.Generic;\nusing System.Diagnostics;\n\nclass Program\n{\n/* Тази функция награждава топ 5 студенти въз основа на техните общи резултати. Студентите се сортират първо по общия им резултат (Китайски, Математика, Английски),\n   след това по резултата им по Китайски, и накрая по техния студентски ID в случай на равенство. Функцията връща списък с топ 5 студенти с техните ID и общи резултати.\n   Пример:\n   >>> AwardTopStudents([(1, 80, 90, 85), (2, 85, 80, 90), (3, 90, 85, 80)])\n   [(3, 255), (2, 255), (1, 255)]\n   >>> AwardTopStudents([(4, 88, 75, 95), (5, 95, 88, 75)])\n   [(4, 258), (5, 258)]\n*/\n   static List<(int, int)> AwardTopStudents(List<(int, int, int, int)> students)",
      "zh": "using System;\nusing System.Collections.Generic;\nusing System.Diagnostics;\n\nclass Program\n{\n/* 此函数根据学生的总成绩奖励前5名学生。学生首先根据他们的总成绩（语文、数学、英语）排序，然后根据他们的语文成绩排序，如果有平局，则根据他们的学生ID排序。该函数返回前5名学生的ID和总成绩的列表。\n   示例:\n   >>> AwardTopStudents([(1, 80, 90, 85), (2, 85, 80, 90), (3, 90, 85, 80)])\n   [(3, 255), (2, 255), (1, 255)]\n   >>> AwardTopStudents([(4, 88, 75, 95), (5, 95, 88, 75)])\n   [(4, 258), (5, 258)]\n*/\n   static List<(int, int)> AwardTopStudents(List<(int, int, int, int)> students)",
      "fr": "using System;\nusing System.Collections.Generic;\nusing System.Diagnostics;\n\nclass Program\n{\n/* Cette fonction récompense les 5 meilleurs étudiants en fonction de leurs scores totaux. Les étudiants sont triés d'abord par leur score total (Chinois, Mathématiques, Anglais),\n   puis par leur score en Chinois, et enfin par leur ID étudiant en cas d'égalité. La fonction renvoie une liste des 5 meilleurs étudiants avec leurs IDs et scores totaux.\n   Exemple :\n   >>> AwardTopStudents([(1, 80, 90, 85), (2, 85, 80, 90), (3, 90, 85, 80)])\n   [(3, 255), (2, 255), (1, 255)]\n   >>> AwardTopStudents([(4, 88, 75, 95), (5, 95, 88, 75)])\n   [(4, 258), (5, 258)]\n*/\n   static List<(int, int)> AwardTopStudents(List<(int, int, int, int)> students)",
      "de": "using System;\nusing System.Collections.Generic;\nusing System.Diagnostics;\n\nclass Program\n{\n/* Diese Funktion zeichnet die Top-5-Studenten basierend auf ihren Gesamtergebnissen aus. Die Studenten werden zuerst nach ihrem Gesamtergebnis (Chinesisch, Mathematik, Englisch) sortiert,\n   dann nach ihrem Chinesisch-Ergebnis und schließlich nach ihrer Studenten-ID, falls es einen Gleichstand gibt. Die Funktion gibt eine Liste der Top-5-Studenten mit ihren IDs und Gesamtergebnissen zurück.\n   Beispiel:\n   >>> AwardTopStudents([(1, 80, 90, 85), (2, 85, 80, 90), (3, 90, 85, 80)])\n   [(3, 255), (2, 255), (1, 255)]\n   >>> AwardTopStudents([(4, 88, 75, 95), (5, 95, 88, 75)])\n   [(4, 258), (5, 258)]\n*/\n   static List<(int, int)> AwardTopStudents(List<(int, int, int, int)> students)",
      "ha": "using System;\nusing System.Collections.Generic;\nusing System.Diagnostics;\n\nclass Program\n{\n/* Wannan aikin yana ba da kyauta ga ɗalibai 5 mafiya kyau bisa jimillar maki nasu. Ana tsara ɗalibai da farko ta hanyar jimillar maki nasu (Sinanci, Lissafi, Turanci),\n   sannan ta hanyar maki nasu na Sinanci, kuma a ƙarshe ta hanyar ID ɗin ɗalibai idan akwai daidaito. Aikin yana dawowa da jerin ɗalibai 5 mafiya kyau tare da ID ɗinsu da jimillar maki.\n   Misali:\n   >>> AwardTopStudents([(1, 80, 90, 85), (2, 85, 80, 90), (3, 90, 85, 80)])\n   [(3, 255), (2, 255), (1, 255)]\n   >>> AwardTopStudents([(4, 88, 75, 95), (5, 95, 88, 75)])\n   [(4, 258), (5, 258)]\n*/\n   static List<(int, int)> AwardTopStudents(List<(int, int, int, int)> students)",
      "hi": "using System;\nusing System.Collections.Generic;\nusing System.Diagnostics;\n\nclass Program\n{\n/* यह फ़ंक्शन उनके कुल अंकों के आधार पर शीर्ष 5 छात्रों को पुरस्कृत करता है। छात्रों को पहले उनके कुल अंक (चीनी, गणित, अंग्रेजी) के आधार पर क्रमबद्ध किया जाता है,\n   फिर उनके चीनी अंकों के आधार पर, और अंत में यदि टाई हो तो उनके छात्र आईडी के आधार पर। फ़ंक्शन शीर्ष 5 छात्रों की सूची उनके आईडी और कुल अंकों के साथ लौटाता है।\n   उदाहरण:\n   >>> AwardTopStudents([(1, 80, 90, 85), (2, 85, 80, 90), (3, 90, 85, 80)])\n   [(3, 255), (2, 255), (1, 255)]\n   >>> AwardTopStudents([(4, 88, 75, 95), (5, 95, 88, 75)])\n   [(4, 258), (5, 258)]\n*/\n   static List<(int, int)> AwardTopStudents(List<(int, int, int, int)> students)",
      "hu": "using System;\nusing System.Collections.Generic;\nusing System.Diagnostics;\n\nclass Program\n{\n/* Ez a függvény a legjobb 5 diákot díjazza az összpontszámuk alapján. A diákokat először az összpontszámuk (kínai, matematika, angol) szerint rendezi,\n   majd a kínai pontszámuk, végül a diákazonosítójuk alapján, ha holtverseny van. A függvény visszaadja a legjobb 5 diák listáját azonosítóikkal és összpontszámaikkal.\n   Példa:\n   >>> AwardTopStudents([(1, 80, 90, 85), (2, 85, 80, 90), (3, 90, 85, 80)])\n   [(3, 255), (2, 255), (1, 255)]\n   >>> AwardTopStudents([(4, 88, 75, 95), (5, 95, 88, 75)])\n   [(4, 258), (5, 258)]\n*/\n   static List<(int, int)> AwardTopStudents(List<(int, int, int, int)> students)"
    },
    "prompt_bertscore": {
      "sq": "0.9670478156774551",
      "hy": "0.9830472942394344",
      "bn": "0.9894477610075215",
      "bg": "0.9961310774382024",
      "zh": "0.9855845987267741",
      "fr": "0.9863497229545204",
      "de": "0.9924872030981174",
      "ha": "0.9797325504407242",
      "hi": "0.9767576632239646",
      "hu": "0.9870520799818597"
    },
    "canonical_solution": "{\n    List<(int, int)> res = students\n        .Select(s => (s.Item1, TotalScore: s.Item2 + s.Item3 + s.Item4))\n        .OrderByDescending(s => s.TotalScore)\n        .ThenByDescending(s => students.First(st => st.Item1 == s.Item1).Item2)\n        .ThenBy(s => s.Item1)\n        .Take(5)\n        .ToList();\n\n    return res;\n}",
    "instruction": {
      "en": "Write a C# function `static List<(int, int)> AwardTopStudents(List<(int, int, int, int)> students)` to solve the following problem:\nThis function awards the top 5 students based on their total scores. Students are sorted first by their total score (Chinese, Mathematics, English),\n   then by their Chinese score, and finally by their student ID if there is a tie. The function returns a list of the top 5 students with their IDs and total scores.\n   Example:\n   >>> AwardTopStudents([(1, 80, 90, 85), (2, 85, 80, 90), (3, 90, 85, 80)])\n   [(3, 255), (2, 255), (1, 255)]\n   >>> AwardTopStudents([(4, 88, 75, 95), (5, 95, 88, 75)])\n   [(4, 258), (5, 258)]",
      "sq": "Shkruani një funksion në C# `static List<(int, int)> AwardTopStudents(List<(int, int, int, int)> students)` për të zgjidhur problemin në vijim:\nKy funksion shpërblen 5 studentët më të mirë bazuar në totalin e pikëve të tyre. Studentët renditen fillimisht sipas totalit të pikëve të tyre (Kinezisht, Matematikë, Anglisht),\npastaj sipas pikëve të tyre në Kinezisht, dhe përfundimisht sipas ID-së së studentit nëse ka barazim. Funksioni kthen një listë të 5 studentëve më të mirë me ID-të dhe totalin e pikëve të tyre.\nShembull:\n>>> AwardTopStudents([(1, 80, 90, 85), (2, 85, 80, 90), (3, 90, 85, 80)])\n[(3, 255), (2, 255), (1, 255)]\n>>> AwardTopStudents([(4, 88, 75, 95), (5, 95, 88, 75)])\n[(4, 258), (5, 258)]",
      "hy": "Գրեք C# ֆունկցիա `static List<(int, int)> AwardTopStudents(List<(int, int, int, int)> students)` հետևյալ խնդիրը լուծելու համար:\nԱյս ֆունկցիան պարգևատրում է լավագույն 5 ուսանողներին ըստ նրանց ընդհանուր միավորների: Ուսանողները դասակարգվում են նախ իրենց ընդհանուր միավորներով (չինարեն, մաթեմատիկա, անգլերեն),\n   ապա՝ չինարենի միավորով, և վերջապես՝ ուսանողի ID-ով, եթե կա հավասարություն: Ֆունկցիան վերադարձնում է լավագույն 5 ուսանողների ցուցակը՝ նրանց ID-ներով և ընդհանուր միավորներով:\n   Օրինակ:\n   >>> AwardTopStudents([(1, 80, 90, 85), (2, 85, 80, 90), (3, 90, 85, 80)])\n   [(3, 255), (2, 255), (1, 255)]\n   >>> AwardTopStudents([(4, 88, 75, 95), (5, 95, 88, 75)])\n   [(4, 258), (5, 258)]",
      "bn": "C# ফাংশন `static List<(int, int)> AwardTopStudents(List<(int, int, int, int)> students)` লিখুন নিম্নলিখিত সমস্যার সমাধানের জন্য:\nএই ফাংশনটি মোট স্কোরের ভিত্তিতে শীর্ষ ৫ জন ছাত্রকে পুরস্কৃত করে। ছাত্রদের প্রথমে তাদের মোট স্কোর (চীনা, গণিত, ইংরেজি) দ্বারা সাজানো হয়, তারপর তাদের চীনা স্কোর দ্বারা, এবং যদি টাই হয় তবে তাদের ছাত্র আইডি দ্বারা। ফাংশনটি শীর্ষ ৫ জন ছাত্রের আইডি এবং মোট স্কোরের একটি তালিকা প্রদান করে।\nউদাহরণ:\n>>> AwardTopStudents([(1, 80, 90, 85), (2, 85, 80, 90), (3, 90, 85, 80)])\n[(3, 255), (2, 255), (1, 255)]\n>>> AwardTopStudents([(4, 88, 75, 95), (5, 95, 88, 75)])\n[(4, 258), (5, 258)]",
      "bg": "Напишете C# функция `static List<(int, int)> AwardTopStudents(List<(int, int, int, int)> students)`, за да решите следния проблем:\nТази функция награждава топ 5 студенти въз основа на техните общи резултати. Студентите се сортират първо по техния общ резултат (Китайски, Математика, Английски),\nслед това по резултата им по Китайски, и накрая по студентския им ID, ако има равенство. Функцията връща списък с топ 5 студенти с техните ID и общи резултати.\nПример:\n>>> AwardTopStudents([(1, 80, 90, 85), (2, 85, 80, 90), (3, 90, 85, 80)])\n[(3, 255), (2, 255), (1, 255)]\n>>> AwardTopStudents([(4, 88, 75, 95), (5, 95, 88, 75)])\n[(4, 258), (5, 258)]",
      "zh": "编写一个 C# 函数 `static List<(int, int)> AwardTopStudents(List<(int, int, int, int)> students)` 来解决以下问题：\n该函数根据学生的总成绩奖励前 5 名学生。学生首先根据他们的总成绩（语文、数学、英语）排序，\n然后按语文成绩排序，最后在总成绩相同的情况下按学生 ID 排序。该函数返回前 5 名学生的 ID 和总成绩的列表。\n示例:",
      "fr": "Écrire une fonction C# `static List<(int, int)> AwardTopStudents(List<(int, int, int, int)> students)` pour résoudre le problème suivant :\nCette fonction récompense les 5 meilleurs étudiants en fonction de leurs scores totaux. Les étudiants sont triés d'abord par leur score total (Chinois, Mathématiques, Anglais),\npuis par leur score en Chinois, et enfin par leur ID étudiant en cas d'égalité. La fonction renvoie une liste des 5 meilleurs étudiants avec leurs IDs et scores totaux.\nExemple :\n>>> AwardTopStudents([(1, 80, 90, 85), (2, 85, 80, 90), (3, 90, 85, 80)])\n[(3, 255), (2, 255), (1, 255)]\n>>> AwardTopStudents([(4, 88, 75, 95), (5, 95, 88, 75)])\n[(4, 258), (5, 258)]",
      "de": "Schreiben Sie eine C#-Funktion `static List<(int, int)> AwardTopStudents(List<(int, int, int, int)> students)`, um das folgende Problem zu lösen:\nDiese Funktion zeichnet die Top 5 Studenten basierend auf ihren Gesamtpunktzahlen aus. Die Studenten werden zuerst nach ihrer Gesamtpunktzahl (Chinesisch, Mathematik, Englisch) sortiert,\ndann nach ihrer Chinesisch-Punktzahl und schließlich nach ihrer Studenten-ID, falls es einen Gleichstand gibt. Die Funktion gibt eine Liste der Top 5 Studenten mit ihren IDs und Gesamtpunktzahlen zurück.\nBeispiel:",
      "ha": "Rubuta aikin C# `static List<(int, int)> AwardTopStudents(List<(int, int, int, int)> students)` don warware matsalar mai zuwa:\nWannan aikin yana ba da kyauta ga ɗalibai 5 mafi kyau bisa ga jimillar maki nasu. Ana tsara ɗalibai da farko bisa ga jimillar maki nasu (Sinanci, Lissafi, Turanci),\nsannan bisa ga maki na Sinanci, kuma a ƙarshe bisa ga lambar ID ɗin ɗalibi idan akwai daidaito. Aikin yana dawowa da jerin ɗalibai 5 mafi kyau tare da ID ɗin su da jimillar maki nasu.\nMisali:\n>>> AwardTopStudents([(1, 80, 90, 85), (2, 85, 80, 90), (3, 90, 85, 80)])\n[(3, 255), (2, 255), (1, 255)]\n>>> AwardTopStudents([(4, 88, 75, 95), (5, 95, 88, 75)])\n[(4, 258), (5, 258)]",
      "hi": "C# फ़ंक्शन `static List<(int, int)> AwardTopStudents(List<(int, int, int, int)> students)` लिखें ताकि निम्नलिखित समस्या का समाधान किया जा सके:\nयह फ़ंक्शन उनके कुल अंकों के आधार पर शीर्ष 5 छात्रों को पुरस्कृत करता है। छात्रों को पहले उनके कुल अंक (चीनी, गणित, अंग्रेजी) के आधार पर क्रमबद्ध किया जाता है, फिर उनके चीनी अंक के आधार पर, और अंत में यदि टाई होती है तो उनके छात्र आईडी के आधार पर। यह फ़ंक्शन शीर्ष 5 छात्रों की सूची उनके आईडी और कुल अंकों के साथ लौटाता है।\nउदाहरण:\n>>> AwardTopStudents([(1, 80, 90, 85), (2, 85, 80, 90), (3, 90, 85, 80)])\n[(3, 255), (2, 255), (1, 255)]\n>>> AwardTopStudents([(4, 88, 75, 95), (5, 95, 88, 75)])\n[(4, 258), (5, 258)]",
      "hu": "Írj egy C# függvényt `static List<(int, int)> AwardTopStudents(List<(int, int, int, int)> students)` a következő probléma megoldására:\nEz a függvény a legjobb 5 diákot jutalmazza a teljes pontszámuk alapján. A diákok először a teljes pontszámuk (kínai, matematika, angol) alapján kerülnek sorba,\n   majd a kínai pontszámuk alapján, végül pedig a diákazonosítójuk alapján, ha holtverseny van. A függvény visszaadja a legjobb 5 diák listáját azonosítóikkal és teljes pontszámaikkal.\n   Példa:\n   >>> AwardTopStudents([(1, 80, 90, 85), (2, 85, 80, 90), (3, 90, 85, 80)])\n   [(3, 255), (2, 255), (1, 255)]\n   >>> AwardTopStudents([(4, 88, 75, 95), (5, 95, 88, 75)])\n   [(4, 258), (5, 258)]"
    },
    "instruction_bertscore": {
      "sq": "0.9761703131872445",
      "hy": "0.9893373225156662",
      "bn": "0.9713006907657932",
      "bg": "0.9949690897091483",
      "zh": "0.8320234046155005",
      "fr": "0.9916005170771777",
      "de": "0.8413368324546658",
      "ha": "0.8411475377015396",
      "hi": "0.9833156438842124",
      "hu": "0.9878352795742803"
    },
    "level": "easy",
    "test": "    static void Main()\n    {\n        // Test Case 1\n        Debug.Assert(AwardTopStudents(new List<(int, int, int, int)> { (1, 80, 90, 85), (2, 85, 80, 90), (3, 90, 85, 80) }).SequenceEqual(new List<(int, int)> { (3, 255), (2, 255), (1, 255) }));\n\n        // Test Case 2\n        Debug.Assert(AwardTopStudents(new List<(int, int, int, int)> { (4, 88, 75, 95), (5, 95, 88, 75) }).SequenceEqual(new List<(int, int)> { (5, 258), (4, 258) }));\n\n        // Test Case 3\n        Debug.Assert(AwardTopStudents(new List<(int, int, int, int)> { (6, 75, 85, 90), (7, 90, 75, 85) }).SequenceEqual(new List<(int, int)> { (7, 250), (6, 250) }));\n\n        // Test Case 4\n        Debug.Assert(AwardTopStudents(new List<(int, int, int, int)> { (8, 80, 90, 80), (9, 90, 80, 80) }).SequenceEqual(new List<(int, int)> { (9, 250), (8, 250) }));\n\n        // Test Case 5\n        Debug.Assert(AwardTopStudents(new List<(int, int, int, int)> { (10, 85, 85, 85), (11, 86, 85, 84), (12, 84, 86, 85) }).SequenceEqual(new List<(int, int)> { (11, 255), (10, 255), (12, 255) }));\n        }\n}\n",
    "entry_point": "AwardTopStudents",
    "signature": "static List<(int, int)> AwardTopStudents(List<(int, int, int, int)> students)",
    "docstring": {
      "en": "This function awards the top 5 students based on their total scores. Students are sorted first by their total score (Chinese, Mathematics, English),\n   then by their Chinese score, and finally by their student ID if there is a tie. The function returns a list of the top 5 students with their IDs and total scores.\n   Example:\n   >>> AwardTopStudents([(1, 80, 90, 85), (2, 85, 80, 90), (3, 90, 85, 80)])\n   [(3, 255), (2, 255), (1, 255)]\n   >>> AwardTopStudents([(4, 88, 75, 95), (5, 95, 88, 75)])\n   [(4, 258), (5, 258)]",
      "sq": "Kjo funksion shpërblen 5 studentët më të mirë bazuar në totalin e pikëve të tyre. Studentët renditen fillimisht sipas totalit të pikëve (Kinezisht, Matematikë, Anglisht), pastaj sipas pikëve në Kinezisht, dhe së fundi sipas ID-së së studentit nëse ka barazim. Funksioni kthen një listë të 5 studentëve më të mirë me ID-të dhe totalin e pikëve të tyre.\nShembull:\n>>> AwardTopStudents([(1, 80, 90, 85), (2, 85, 80, 90), (3, 90, 85, 80)])\n[(3, 255), (2, 255), (1, 255)]\n>>> AwardTopStudents([(4, 88, 75, 95), (5, 95, 88, 75)])\n[(4, 258), (5, 258)]",
      "hy": "Այս ֆունկցիան պարգևատրում է լավագույն 5 ուսանողներին՝ հիմնվելով նրանց ընդհանուր միավորների վրա։ Ուսանողները դասավորվում են նախ իրենց ընդհանուր միավորներով (չինարեն, մաթեմատիկա, անգլերեն), ապա՝ չինարենի միավորներով, և վերջապես՝ ուսանողի ID-ով, եթե կա հավասարություն։ Ֆունկցիան վերադարձնում է լավագույն 5 ուսանողների ցուցակը՝ նրանց ID-ներով և ընդհանուր միավորներով։\n   Օրինակ:\n   >>> AwardTopStudents([(1, 80, 90, 85), (2, 85, 80, 90), (3, 90, 85, 80)])\n   [(3, 255), (2, 255), (1, 255)]\n   >>> AwardTopStudents([(4, 88, 75, 95), (5, 95, 88, 75)])\n   [(4, 258), (5, 258)]",
      "bn": "এই ফাংশনটি তাদের মোট স্কোরের ভিত্তিতে শীর্ষ ৫ জন ছাত্রকে পুরস্কৃত করে। ছাত্রদের প্রথমে তাদের মোট স্কোর (চীনা, গণিত, ইংরেজি) দ্বারা সাজানো হয়, তারপর তাদের চীনা স্কোর দ্বারা এবং অবশেষে যদি সমতা থাকে তবে তাদের ছাত্র আইডি দ্বারা। ফাংশনটি শীর্ষ ৫ জন ছাত্রের আইডি এবং মোট স্কোরের একটি তালিকা প্রদান করে।\n   উদাহরণ:\n   >>> AwardTopStudents([(1, 80, 90, 85), (2, 85, 80, 90), (3, 90, 85, 80)])\n   [(3, 255), (2, 255), (1, 255)]\n   >>> AwardTopStudents([(4, 88, 75, 95), (5, 95, 88, 75)])\n   [(4, 258), (5, 258)]",
      "bg": "Тази функция награждава първите 5 студенти на базата на техните общи резултати. Студентите се сортират първо по техния общ резултат (Китайски, Математика, Английски), след това по резултата им по Китайски, и накрая по техния студентски ID в случай на равенство. Функцията връща списък с първите 5 студенти с техните ID и общи резултати.\nПример:\n>>> AwardTopStudents([(1, 80, 90, 85), (2, 85, 80, 90), (3, 90, 85, 80)])\n[(3, 255), (2, 255), (1, 255)]\n>>> AwardTopStudents([(4, 88, 75, 95), (5, 95, 88, 75)])\n[(4, 258), (5, 258)]",
      "zh": "此函数根据学生的总分奖励前5名学生。学生首先根据总分（语文、数学、英语）排序，然后根据语文成绩排序，最后在分数相同的情况下根据学生ID排序。函数返回前5名学生的ID和总分的列表。\n示例：\n>>> AwardTopStudents([(1, 80, 90, 85), (2, 85, 80, 90), (3, 90, 85, 80)])\n[(3, 255), (2, 255), (1, 255)]\n>>> AwardTopStudents([(4, 88, 75, 95), (5, 95, 88, 75)])\n[(4, 258), (5, 258)]",
      "fr": "Cette fonction récompense les 5 meilleurs étudiants en fonction de leurs scores totaux. Les étudiants sont triés d'abord par leur score total (Chinois, Mathématiques, Anglais), puis par leur score en Chinois, et enfin par leur ID étudiant en cas d'égalité. La fonction renvoie une liste des 5 meilleurs étudiants avec leurs IDs et scores totaux.\nExemple :\n>>> AwardTopStudents([(1, 80, 90, 85), (2, 85, 80, 90), (3, 90, 85, 80)])\n[(3, 255), (2, 255), (1, 255)]\n>>> AwardTopStudents([(4, 88, 75, 95), (5, 95, 88, 75)])\n[(4, 258), (5, 258)]",
      "de": "Diese Funktion zeichnet die besten 5 Studenten basierend auf ihren Gesamtergebnissen aus. Die Studenten werden zuerst nach ihrem Gesamtergebnis (Chinesisch, Mathematik, Englisch) sortiert, dann nach ihrem Chinesisch-Ergebnis und schließlich nach ihrer Studenten-ID im Falle eines Gleichstands. Die Funktion gibt eine Liste der Top-5-Studenten mit ihren IDs und Gesamtergebnissen zurück.\nBeispiel:\n>>> AwardTopStudents([(1, 80, 90, 85), (2, 85, 80, 90), (3, 90, 85, 80)])\n[(3, 255), (2, 255), (1, 255)]\n>>> AwardTopStudents([(4, 88, 75, 95), (5, 95, 88, 75)])\n[(4, 258), (5, 258)]",
      "ha": "Wannan aikin yana ba da lambar yabo ga dalibai 5 na farko bisa jimillar maki nasu. Ana tsara dalibai da farko ta jimillar maki nasu (Sinanci, Lissafi, Turanci), sannan ta maki nasu na Sinanci, kuma a ƙarshe ta ID ɗin dalibi idan akwai daidaito. Aikin yana dawowa da jerin dalibai 5 na farko tare da ID ɗinsu da jimillar maki nasu.\n\nMisali:\n>>> AwardTopStudents([(1, 80, 90, 85), (2, 85, 80, 90), (3, 90, 85, 80)])\n[(3, 255), (2, 255), (1, 255)]\n>>> AwardTopStudents([(4, 88, 75, 95), (5, 95, 88, 75)])\n[(4, 258), (5, 258)]",
      "hi": "यह फ़ंक्शन उनके कुल अंकों के आधार पर शीर्ष 5 छात्रों को पुरस्कृत करता है। छात्रों को पहले उनके कुल अंकों (चीनी, गणित, अंग्रेजी) के आधार पर क्रमबद्ध किया जाता है, फिर उनके चीनी अंकों के आधार पर, और अंत में यदि टाई होती है तो उनके छात्र आईडी के आधार पर। फ़ंक्शन शीर्ष 5 छात्रों की सूची उनके आईडी और कुल अंकों के साथ लौटाता है।\n\nExample:\nउदाहरण:\n>>> AwardTopStudents([(1, 80, 90, 85), (2, 85, 80, 90), (3, 90, 85, 80)])\n[(3, 255), (2, 255), (1, 255)]\n>>> AwardTopStudents([(4, 88, 75, 95), (5, 95, 88, 75)])\n[(4, 258), (5, 258)]",
      "hu": "Ez a függvény a legjobb 5 diákot jutalmazza az összpontszámuk alapján. A diákok először az összpontszámuk (kínai, matematika, angol) szerint vannak sorba rendezve, majd a kínai pontszámuk, végül pedig a diákazonosítójuk alapján, ha holtverseny van. A függvény visszaadja a legjobb 5 diák listáját azonosítóikkal és összpontszámaikkal.\nPélda:\n>>> AwardTopStudents([(1, 80, 90, 85), (2, 85, 80, 90), (3, 90, 85, 80)])\n[(3, 255), (2, 255), (1, 255)]\n>>> AwardTopStudents([(4, 88, 75, 95), (5, 95, 88, 75)])\n[(4, 258), (5, 258)]"
    },
    "docstring_bertscore": {
      "sq": "0.9765991561798988",
      "hy": "0.9820998273218979",
      "bn": "0.9754041958075929",
      "bg": "0.9924935592703106",
      "zh": "0.9752425106774305",
      "fr": "0.9897508709689808",
      "de": "0.9912978043764805",
      "ha": "0.9875850052941764",
      "hi": "1",
      "hu": "0.9875238271368176"
    }
  },
  {
    "task_id": "C#/16",
    "prompt": {
      "en": "using System;\nusing System.Collections.Generic;\nusing System.Diagnostics;\n\nclass Program\n{\n/* \n    Determine the minimum number of groups needed to distribute souvenirs where each group can have at most two souvenirs and the total price of souvenirs in a group cannot exceed a specified limit.\n    Example:\n    >>> MinimumGroups(new List<int> { 15, 20, 10, 30, 40 }, 50)\n    3\n    >>> MinimumGroups(new List<int> { 5, 20, 25, 10 }, 30)\n    2\n*/\n   \nstatic int MinimumGroups(List<int> souvenirPrices, int maxPriceSum)",
      "sq": "using System;\nusing System.Collections.Generic;\nusing System.Diagnostics;\n\nclass Program\n{\n/* \n    Përcaktoni numrin minimal të grupeve të nevojshme për të shpërndarë suveniret ku çdo grup mund të ketë maksimumi dy suvenire dhe çmimi total i suvenireve në një grup nuk mund të kalojë një kufi të specifikuar.\n    Shembull:\n    >>> MinimumGroups(new List<int> { 15, 20, 10, 30, 40 }, 50)\n    3\n    >>> MinimumGroups(new List<int> { 5, 20, 25, 10 }, 30)\n    2\n*/\n   \nstatic int MinimumGroups(List<int> souvenirPrices, int maxPriceSum)",
      "hy": "using System;\nusing System.Collections.Generic;\nusing System.Diagnostics;\n\nclass Program\n{\n/* \n    Որոշեք անհրաժեշտ խմբերի նվազագույն քանակը հուշանվերներ բաշխելու համար, որտեղ յուրաքանչյուր խումբ կարող է ունենալ առավելագույնը երկու հուշանվեր, և խմբում հուշանվերների ընդհանուր գինը չի կարող գերազանցել նշված սահմանը:\n    Օրինակ:\n    >>> MinimumGroups(new List<int> { 15, 20, 10, 30, 40 }, 50)\n    3\n    >>> MinimumGroups(new List<int> { 5, 20, 25, 10 }, 30)\n    2\n*/\n   \nstatic int MinimumGroups(List<int> souvenirPrices, int maxPriceSum)",
      "bn": "using System;\nusing System.Collections.Generic;\nusing System.Diagnostics;\n\nclass Program\n{\n/* \n    স্মৃতিচিহ্ন বিতরণের জন্য প্রয়োজনীয় সর্বনিম্ন সংখ্যক গ্রুপ নির্ধারণ করুন যেখানে প্রতিটি গ্রুপে সর্বাধিক দুটি স্মৃতিচিহ্ন থাকতে পারে এবং একটি গ্রুপে স্মৃতিচিহ্নের মোট মূল্য নির্দিষ্ট সীমা অতিক্রম করতে পারবে না।\n    উদাহরণ:\n    >>> MinimumGroups(new List<int> { 15, 20, 10, 30, 40 }, 50)\n    3\n    >>> MinimumGroups(new List<int> { 5, 20, 25, 10 }, 30)\n    2\n*/\n   \nstatic int MinimumGroups(List<int> souvenirPrices, int maxPriceSum)",
      "bg": "using System;\nusing System.Collections.Generic;\nusing System.Diagnostics;\n\nclass Program\n{\n/* \n    Определете минималния брой групи, необходими за разпределяне на сувенири, където всяка група може да има най-много два сувенира и общата цена на сувенирите в група не може да надвишава определен лимит.\n    Пример:\n    >>> MinimumGroups(new List<int> { 15, 20, 10, 30, 40 }, 50)\n    3\n    >>> MinimumGroups(new List<int> { 5, 20, 25, 10 }, 30)\n    2\n*/\n   \nstatic int MinimumGroups(List<int> souvenirPrices, int maxPriceSum)",
      "zh": "using System;\nusing System.Collections.Generic;\nusing System.Diagnostics;\n\nclass Program\n{\n/* \n    确定分配纪念品所需的最小组数，其中每组最多可以有两个纪念品，并且组内纪念品的总价格不能超过指定的限制。\n    例子:\n    >>> MinimumGroups(new List<int> { 15, 20, 10, 30, 40 }, 50)\n    3\n    >>> MinimumGroups(new List<int> { 5, 20, 25, 10 }, 30)\n    2\n*/\n   \nstatic int MinimumGroups(List<int> souvenirPrices, int maxPriceSum)",
      "fr": "using System;\nusing System.Collections.Generic;\nusing System.Diagnostics;\n\nclass Program\n{\n/* \n    Déterminer le nombre minimum de groupes nécessaires pour distribuer des souvenirs où chaque groupe peut avoir au maximum deux souvenirs et le prix total des souvenirs dans un groupe ne peut pas dépasser une limite spécifiée.\n    Exemple :\n    >>> MinimumGroups(new List<int> { 15, 20, 10, 30, 40 }, 50)\n    3\n    >>> MinimumGroups(new List<int> { 5, 20, 25, 10 }, 30)\n    2\n*/\n   \nstatic int MinimumGroups(List<int> souvenirPrices, int maxPriceSum)",
      "de": "using System;\nusing System.Collections.Generic;\nusing System.Diagnostics;\n\nclass Program\n{\n/* \n    Bestimme die minimale Anzahl von Gruppen, die benötigt werden, um Souvenirs zu verteilen, wobei jede Gruppe höchstens zwei Souvenirs haben kann und der Gesamtpreis der Souvenirs in einer Gruppe ein festgelegtes Limit nicht überschreiten darf.\n    Beispiel:\n    >>> MinimumGroups(new List<int> { 15, 20, 10, 30, 40 }, 50)\n    3\n    >>> MinimumGroups(new List<int> { 5, 20, 25, 10 }, 30)\n    2\n*/\n   \nstatic int MinimumGroups(List<int> souvenirPrices, int maxPriceSum)",
      "ha": "using System;\nusing System.Collections.Generic;\nusing System.Diagnostics;\n\nclass Program\n{\n/* \n    Ƙayyade mafi ƙarancin adadin ƙungiyoyi da ake buƙata don rarraba kayan kyauta inda kowace ƙungiya za ta iya samun a kalla kayan kyauta biyu kuma jimlar farashin kayan kyauta a cikin ƙungiya ba zai wuce iyaka da aka ƙayyade ba.\n    Misali:\n    >>> MinimumGroups(new List<int> { 15, 20, 10, 30, 40 }, 50)\n    3\n    >>> MinimumGroups(new List<int> { 5, 20, 25, 10 }, 30)\n    2\n*/\n   \nstatic int MinimumGroups(List<int> souvenirPrices, int maxPriceSum)",
      "hi": "using System;\nusing System.Collections.Generic;\nusing System.Diagnostics;\n\nclass Program\n{\n/* \n    न्यूनतम समूहों की संख्या निर्धारित करें जिनकी आवश्यकता है ताकि स्मृति चिन्ह वितरित किए जा सकें, जहां प्रत्येक समूह में अधिकतम दो स्मृति चिन्ह हो सकते हैं और समूह में स्मृति चिन्ह की कुल कीमत निर्दिष्ट सीमा से अधिक नहीं हो सकती।\n    उदाहरण:\n    >>> MinimumGroups(new List<int> { 15, 20, 10, 30, 40 }, 50)\n    3\n    >>> MinimumGroups(new List<int> { 5, 20, 25, 10 }, 30)\n    2\n*/\n   \nstatic int MinimumGroups(List<int> souvenirPrices, int maxPriceSum)",
      "hu": "using System;\nusing System.Collections.Generic;\nusing System.Diagnostics;\n\nclass Program\n{\n/* \n    Határozza meg a szükséges csoportok minimális számát az ajándéktárgyak elosztásához, ahol minden csoportban legfeljebb két ajándéktárgy lehet, és a csoportban lévő ajándéktárgyak összára nem haladhat meg egy megadott határt.\n    Példa:\n    >>> MinimumGroups(new List<int> { 15, 20, 10, 30, 40 }, 50)\n    3\n    >>> MinimumGroups(new List<int> { 5, 20, 25, 10 }, 30)\n    2\n*/\n   \nstatic int MinimumGroups(List<int> souvenirPrices, int maxPriceSum)"
    },
    "prompt_bertscore": {
      "sq": "0.9890383837922087",
      "hy": "0.9809799492336232",
      "bn": "0.9864877710693397",
      "bg": "0.9893389115587145",
      "zh": "0.9852717558766441",
      "fr": "0.9973447090663257",
      "de": "0.9874682106301279",
      "ha": "0.9868844359402663",
      "hi": "0.9677634809403238",
      "hu": "0.9826438759355525"
    },
    "canonical_solution": "{\n    souvenirPrices.Sort();\n    int i = 0, j = souvenirPrices.Count - 1, groups = 0;\n    while (i <= j)\n    {\n        if (souvenirPrices[i] + souvenirPrices[j] <= maxPriceSum)\n        {\n            i++; \n        }\n        j--;\n        groups++;\n    }\n    return groups;\n}",
    "instruction": {
      "en": "Write a C# function `static int MinimumGroups(List<int> souvenirPrices, int maxPriceSum)` to solve the following problem:\nDetermine the minimum number of groups needed to distribute souvenirs where each group can have at most two souvenirs and the total price of souvenirs in a group cannot exceed a specified limit.\n    Example:\n    >>> MinimumGroups(new List<int> { 15, 20, 10, 30, 40 }, 50)\n    3\n    >>> MinimumGroups(new List<int> { 5, 20, 25, 10 }, 30)\n    2",
      "sq": "Shkruani një funksion C# `static int MinimumGroups(List<int> souvenirPrices, int maxPriceSum)` për të zgjidhur problemin e mëposhtëm:\nPërcaktoni numrin minimal të grupeve të nevojshme për të shpërndarë suveniret ku secili grup mund të ketë maksimumi dy suvenire dhe çmimi total i suvenireve në një grup nuk mund të kalojë një kufi të specifikuar.\n    Shembull:\n    >>> MinimumGroups(new List<int> { 15, 20, 10, 30, 40 }, 50)\n    3\n    >>> MinimumGroups(new List<int> { 5, 20, 25, 10 }, 30)\n    2",
      "hy": "Գրեք C# ֆունկցիա `static int MinimumGroups(List<int> souvenirPrices, int maxPriceSum)` հետևյալ խնդիրը լուծելու համար:\nՈրոշեք խմբերի նվազագույն քանակը, որոնք անհրաժեշտ են հուշանվերները բաշխելու համար, որտեղ յուրաքանչյուր խումբ կարող է ունենալ առավելագույնը երկու հուշանվեր, և խմբում հուշանվերների ընդհանուր գինը չի կարող գերազանցել նշված սահմանը:\n    Օրինակ:\n    >>> MinimumGroups(new List<int> { 15, 20, 10, 30, 40 }, 50)\n    3\n    >>> MinimumGroups(new List<int> { 5, 20, 25, 10 }, 30)\n    2",
      "bn": "একটি C# ফাংশন `static int MinimumGroups(List<int> souvenirPrices, int maxPriceSum)` লিখুন নিম্নলিখিত সমস্যার সমাধান করতে:\nস্মারক বিতরণের জন্য প্রয়োজনীয় সর্বনিম্ন সংখ্যক গ্রুপ নির্ধারণ করুন যেখানে প্রতিটি গ্রুপে সর্বাধিক দুটি স্মারক থাকতে পারে এবং একটি গ্রুপে স্মারকের মোট মূল্য একটি নির্দিষ্ট সীমা অতিক্রম করতে পারবে না।\n    উদাহরণ:\n    >>> MinimumGroups(new List<int> { 15, 20, 10, 30, 40 }, 50)\n    3\n    >>> MinimumGroups(new List<int> { 5, 20, 25, 10 }, 30)\n    2",
      "bg": "Напишете C# функция `static int MinimumGroups(List<int> souvenirPrices, int maxPriceSum)`, за да решите следния проблем:\nОпределете минималния брой групи, необходими за разпределение на сувенири, където всяка група може да има най-много два сувенира и общата цена на сувенирите в група не може да надвишава определен лимит.\n    Пример:\n    >>> MinimumGroups(new List<int> { 15, 20, 10, 30, 40 }, 50)\n    3\n    >>> MinimumGroups(new List<int> { 5, 20, 25, 10 }, 30)\n    2",
      "zh": "编写一个 C# 函数 `static int MinimumGroups(List<int> souvenirPrices, int maxPriceSum)` 来解决以下问题：\n确定分配纪念品所需的最小组数，其中每组最多可以有两个纪念品，并且每组中纪念品的总价格不能超过指定的限制。\n    示例:\n    >>> MinimumGroups(new List<int> { 15, 20, 10, 30, 40 }, 50)\n    3\n    >>> MinimumGroups(new List<int> { 5, 20, 25, 10 }, 30)\n    2",
      "fr": "Écrire une fonction C# `static int MinimumGroups(List<int> souvenirPrices, int maxPriceSum)` pour résoudre le problème suivant :\nDéterminer le nombre minimum de groupes nécessaires pour distribuer des souvenirs où chaque groupe peut avoir au maximum deux souvenirs et le prix total des souvenirs dans un groupe ne peut pas dépasser une limite spécifiée.\n    Exemple :\n    >>> MinimumGroups(new List<int> { 15, 20, 10, 30, 40 }, 50)\n    3\n    >>> MinimumGroups(new List<int> { 5, 20, 25, 10 }, 30)\n    2",
      "de": "Schreiben Sie eine C#-Funktion `static int MinimumGroups(List<int> souvenirPrices, int maxPriceSum)`, um das folgende Problem zu lösen:\nBestimmen Sie die minimale Anzahl von Gruppen, die benötigt werden, um Souvenirs zu verteilen, wobei jede Gruppe höchstens zwei Souvenirs haben kann und der Gesamtpreis der Souvenirs in einer Gruppe ein angegebenes Limit nicht überschreiten darf.\n    Beispiel:\n    >>> MinimumGroups(new List<int> { 15, 20, 10, 30, 40 }, 50)\n    3\n    >>> MinimumGroups(new List<int> { 5, 20, 25, 10 }, 30)\n    2",
      "ha": "Rubuta aikin C# `static int MinimumGroups(List<int> souvenirPrices, int maxPriceSum)` don warware matsalar mai zuwa:\nKayyade mafi ƙarancin adadin ƙungiyoyi da ake buƙata don rarraba kayan kyauta inda kowace ƙungiya za ta iya samun akalla kayan kyauta biyu kuma jimlar farashin kayan kyauta a cikin ƙungiya ba zai wuce iyaka da aka kayyade ba.\n    Misali:\n    >>> MinimumGroups(new List<int> { 15, 20, 10, 30, 40 }, 50)\n    3\n    >>> MinimumGroups(new List<int> { 5, 20, 25, 10 }, 30)\n    2",
      "hi": "C# फ़ंक्शन `static int MinimumGroups(List<int> souvenirPrices, int maxPriceSum)` लिखें ताकि निम्नलिखित समस्या का समाधान किया जा सके:\nयह निर्धारित करें कि स्मृति चिन्हों को वितरित करने के लिए न्यूनतम कितने समूहों की आवश्यकता है, जहाँ प्रत्येक समूह में अधिकतम दो स्मृति चिन्ह हो सकते हैं और समूह में स्मृति चिन्हों की कुल कीमत निर्दिष्ट सीमा से अधिक नहीं हो सकती।\n    उदाहरण:\n    >>> MinimumGroups(new List<int> { 15, 20, 10, 30, 40 }, 50)\n    3\n    >>> MinimumGroups(new List<int> { 5, 20, 25, 10 }, 30)\n    2",
      "hu": "Írj egy C# függvényt `static int MinimumGroups(List<int> souvenirPrices, int maxPriceSum)` a következő probléma megoldására:\nHatározd meg a szükséges minimum csoportok számát az ajándéktárgyak elosztásához, ahol minden csoportban legfeljebb két ajándéktárgy lehet, és a csoportban lévő ajándéktárgyak összára nem haladhat meg egy megadott határt.\n    Példa:\n    >>> MinimumGroups(new List<int> { 15, 20, 10, 30, 40 }, 50)\n    3\n    >>> MinimumGroups(new List<int> { 5, 20, 25, 10 }, 30)\n    2"
    },
    "instruction_bertscore": {
      "sq": "0.9848623786613312",
      "hy": "0.9851907146811818",
      "bn": "0.9978500247556784",
      "bg": "0.9879119509013599",
      "zh": "0.9820213683213892",
      "fr": "0.9974344899985533",
      "de": "0.9817794365172887",
      "ha": "0.9760414020699528",
      "hi": "0.9675590902782389",
      "hu": "0.9764195943154432"
    },
    "level": "easy",
    "test": "    static void Main()\n    {\n        Debug.Assert(MinimumGroups(new List<int> { 15, 20, 10, 30, 40 }, 50) == 3);\n        Debug.Assert(MinimumGroups(new List<int> { 5, 20, 25, 10 }, 30) == 2);\n        Debug.Assert(MinimumGroups(new List<int> { 10, 20, 30, 40, 50 }, 60) == 3);\n        Debug.Assert(MinimumGroups(new List<int> { 25, 30, 35, 5, 15, 20 }, 40) == 4);\n        Debug.Assert(MinimumGroups(new List<int> { 32, 42, 52, 12, 22 }, 70) == 3);\n        Debug.Assert(MinimumGroups(new List<int> { 30, 35, 40, 10, 15, 20, 25}, 45) == 4);\n        Debug.Assert(MinimumGroups(new List<int> { 5, 10, 15, 20, 25 }, 30) == 3);\n\n    }\n}\n",
    "entry_point": "MinimumGroups",
    "signature": "static int MinimumGroups(List<int> souvenirPrices, int maxPriceSum)",
    "docstring": {
      "en": "Determine the minimum number of groups needed to distribute souvenirs where each group can have at most two souvenirs and the total price of souvenirs in a group cannot exceed a specified limit.\n    Example:\n    >>> MinimumGroups(new List<int> { 15, 20, 10, 30, 40 }, 50)\n    3\n    >>> MinimumGroups(new List<int> { 5, 20, 25, 10 }, 30)\n    2",
      "sq": "Përcaktoni numrin minimal të grupeve të nevojshme për të shpërndarë suveniret ku secili grup mund të ketë maksimumi dy suvenire dhe çmimi total i suvenireve në një grup nuk mund të kalojë një kufi të specifikuar.\n    Shembull:\n    >>> MinimumGroups(new List<int> { 15, 20, 10, 30, 40 }, 50)\n    3\n    >>> MinimumGroups(new List<int> { 5, 20, 25, 10 }, 30)\n    2",
      "hy": "Սահմանել նվազագույն խմբերի քանակը, որոնք անհրաժեշտ են հուշանվերների բաշխման համար, որտեղ յուրաքանչյուր խումբ կարող է ունենալ առավելագույնը երկու հուշանվեր, և խմբում հուշանվերների ընդհանուր գինը չի կարող գերազանցել նշված սահմանը:\n    Օրինակ:\n    >>> MinimumGroups(new List<int> { 15, 20, 10, 30, 40 }, 50)\n    3\n    >>> MinimumGroups(new List<int> { 5, 20, 25, 10 }, 30)\n    2",
      "bn": "স্মারক বিতরণের জন্য প্রয়োজনীয় সর্বনিম্ন সংখ্যক গ্রুপ নির্ধারণ করুন যেখানে প্রতিটি গ্রুপে সর্বাধিক দুটি স্মারক থাকতে পারে এবং একটি গ্রুপে স্মারকের মোট মূল্য নির্দিষ্ট সীমা অতিক্রম করতে পারবে না।\n    উদাহরণ:\n    >>> MinimumGroups(new List<int> { 15, 20, 10, 30, 40 }, 50)\n    3\n    >>> MinimumGroups(new List<int> { 5, 20, 25, 10 }, 30)\n    2",
      "bg": "Определете минималния брой групи, необходими за разпределяне на сувенири, където всяка група може да има най-много два сувенира и общата цена на сувенирите в една група не може да надвишава определен лимит.\n    Пример:\n    >>> MinimumGroups(new List<int> { 15, 20, 10, 30, 40 }, 50)\n    3\n    >>> MinimumGroups(new List<int> { 5, 20, 25, 10 }, 30)\n    2",
      "zh": "确定分配纪念品所需的最小组数，其中每组最多可以有两个纪念品，并且每组中纪念品的总价格不能超过指定的限制。\n    示例：\n    >>> MinimumGroups(new List<int> { 15, 20, 10, 30, 40 }, 50)\n    3\n    >>> MinimumGroups(new List<int> { 5, 20, 25, 10 }, 30)\n    2",
      "fr": "Déterminer le nombre minimum de groupes nécessaires pour distribuer des souvenirs où chaque groupe peut avoir au maximum deux souvenirs et le prix total des souvenirs dans un groupe ne peut pas dépasser une limite spécifiée.\n    Exemple :\n    >>> MinimumGroups(new List<int> { 15, 20, 10, 30, 40 }, 50)\n    3\n    >>> MinimumGroups(new List<int> { 5, 20, 25, 10 }, 30)\n    2",
      "de": "Bestimmen Sie die minimale Anzahl von Gruppen, die benötigt werden, um Souvenirs zu verteilen, wobei jede Gruppe höchstens zwei Souvenirs haben kann und der Gesamtpreis der Souvenirs in einer Gruppe ein angegebenes Limit nicht überschreiten darf.\n    Beispiel:\n    >>> MinimumGroups(new List<int> { 15, 20, 10, 30, 40 }, 50)\n    3\n    >>> MinimumGroups(new List<int> { 5, 20, 25, 10 }, 30)\n    2",
      "ha": "Kayyade mafi ƙarancin adadin ƙungiyoyi da ake buƙata don rarraba kayan kyauta inda kowace ƙungiya za ta iya samun aƙalla kayan kyauta biyu kuma jimillar farashin kayan kyauta a cikin ƙungiya ba zai wuce iyaka da aka ƙayyade ba.\n    Misali:\n    >>> MinimumGroups(new List<int> { 15, 20, 10, 30, 40 }, 50)\n    3\n    >>> MinimumGroups(new List<int> { 5, 20, 25, 10 }, 30)\n    2",
      "hi": "स्मृति चिह्नों को वितरित करने के लिए आवश्यक न्यूनतम समूहों की संख्या निर्धारित करें जहाँ प्रत्येक समूह में अधिकतम दो स्मृति चिह्न हो सकते हैं और समूह में स्मृति चिह्नों की कुल कीमत निर्दिष्ट सीमा से अधिक नहीं हो सकती।\n\nउदाहरण:\n>>> MinimumGroups(new List<int> { 15, 20, 10, 30, 40 }, 50)\n3\n>>> MinimumGroups(new List<int> { 5, 20, 25, 10 }, 30)\n2",
      "hu": "Határozza meg a szükséges minimális csoportok számát, hogy elossza az ajándéktárgyakat, ahol minden csoportban legfeljebb két ajándéktárgy lehet, és a csoportban lévő ajándéktárgyak összára nem haladhat meg egy megadott határt.\n    Példa:\n    >>> MinimumGroups(new List<int> { 15, 20, 10, 30, 40 }, 50)\n    3\n    >>> MinimumGroups(new List<int> { 5, 20, 25, 10 }, 30)\n    2"
    },
    "docstring_bertscore": {
      "sq": "0.9846216386395169",
      "hy": "0.9606102050281144",
      "bn": "0.972091239682312",
      "bg": "0.9775033216743696",
      "zh": "0.9779861921306654",
      "fr": "0.989637651651791",
      "de": "0.9809666409980939",
      "ha": "0.9397893712272753",
      "hi": "0.9757672921441247",
      "hu": "0.9561291036319673"
    }
  },
  {
    "task_id": "C#/17",
    "prompt": {
      "en": "using System;\nusing System.Collections.Generic;\nusing System.Diagnostics;\n\nclass Program\n{\n/* Calculate the initial number of peaches a monkey had, given that each day it eats half of the peaches plus one more, and on the Nth day only one peach is left.\n    Examples:\n    >>> InitialPeachesCount(1)\n    1\n    >>> InitialPeachesCount(2)\n    4\n    >>> InitialPeachesCount(3)\n    10\n*/\n   \n   static int InitialPeachesCount(int days)",
      "sq": "using System;\nusing System.Collections.Generic;\nusing System.Diagnostics;\n\nclass Program\n{\n/* Llogarit numrin fillestar të pjeshkëve që kishte një majmun, duke pasur parasysh që çdo ditë ai ha gjysmën e pjeshkëve plus edhe një tjetër, dhe në ditën e N-të mbetet vetëm një pjeshkë.\n    Shembuj:\n    >>> InitialPeachesCount(1)\n    1\n    >>> InitialPeachesCount(2)\n    4\n    >>> InitialPeachesCount(3)\n    10\n*/\n   \n   static int InitialPeachesCount(int days)",
      "hy": "using System;\nusing System.Collections.Generic;\nusing System.Diagnostics;\n\nclass Program\n{\n/* Հաշվել կապիկի ունեցած դեղձերի սկզբնական քանակը, եթե ամեն օր այն ուտում է դեղձերի կեսը գումարած ևս մեկ դեղձ, և N-րդ օրը միայն մեկ դեղձ է մնում:\n    Օրինակներ:\n    >>> InitialPeachesCount(1)\n    1\n    >>> InitialPeachesCount(2)\n    4\n    >>> InitialPeachesCount(3)\n    10\n*/\n   \n   static int InitialPeachesCount(int days)",
      "bn": "using System;\nusing System.Collections.Generic;\nusing System.Diagnostics;\n\nclass Program\n{\n/* একটি বাঁদর কতগুলো পীচ ছিল তা গণনা করুন, যদি প্রতিদিন এটি পীচের অর্ধেক এবং আরও একটি খায়, এবং N তম দিনে কেবল একটি পীচ অবশিষ্ট থাকে।\n    উদাহরণ:\n    >>> InitialPeachesCount(1)\n    1\n    >>> InitialPeachesCount(2)\n    4\n    >>> InitialPeachesCount(3)\n    10\n*/\n   \n   static int InitialPeachesCount(int days)",
      "bg": "using System;\nusing System.Collections.Generic;\nusing System.Diagnostics;\n\nclass Program\n{\n/* Изчислете първоначалния брой праскови, които маймуната е имала, като се има предвид, че всеки ден тя изяжда половината от прасковите плюс още една, и на N-тия ден остава само една праскова.\n    Примери:\n    >>> InitialPeachesCount(1)\n    1\n    >>> InitialPeachesCount(2)\n    4\n    >>> InitialPeachesCount(3)\n    10\n*/\n   \n   static int InitialPeachesCount(int days)",
      "zh": "using System;\nusing System.Collections.Generic;\nusing System.Diagnostics;\n\nclass Program\n{\n/* 计算猴子最初有多少个桃子，已知它每天吃掉一半的桃子加上一个，并且在第 N 天只剩下一个桃子。\n    示例：\n    >>> InitialPeachesCount(1)\n    1\n    >>> InitialPeachesCount(2)\n    4\n    >>> InitialPeachesCount(3)\n    10\n*/\n   \n   static int InitialPeachesCount(int days)",
      "fr": "using System;\nusing System.Collections.Generic;\nusing System.Diagnostics;\n\nclass Program\n{\n/* Calculer le nombre initial de pêches qu'un singe avait, étant donné que chaque jour il mange la moitié des pêches plus une de plus, et que le Nème jour il ne reste qu'une pêche.\n    Exemples :\n    >>> InitialPeachesCount(1)\n    1\n    >>> InitialPeachesCount(2)\n    4\n    >>> InitialPeachesCount(3)\n    10\n*/\n   \n   static int InitialPeachesCount(int days)",
      "de": "using System;\nusing System.Collections.Generic;\nusing System.Diagnostics;\n\nclass Program\n{\n/* Berechne die anfängliche Anzahl an Pfirsichen, die ein Affe hatte, gegeben, dass er jeden Tag die Hälfte der Pfirsiche plus einen weiteren isst und am N-ten Tag nur noch ein Pfirsich übrig ist.\n    Beispiele:\n    >>> InitialPeachesCount(1)\n    1\n    >>> InitialPeachesCount(2)\n    4\n    >>> InitialPeachesCount(3)\n    10\n*/\n   \n   static int InitialPeachesCount(int days)",
      "ha": "using System;\nusing System.Collections.Generic;\nusing System.Diagnostics;\n\nclass Program\n{\n/* Lissafi nawa ne adadin ayaba da biri ya fara da shi, la'akari da cewa kowace rana yana cin rabin ayabar tare da ƙara ɗaya, kuma a rana ta N sai dai ayaba ɗaya ta rage.\n    Misalai:\n    >>> InitialPeachesCount(1)\n    1\n    >>> InitialPeachesCount(2)\n    4\n    >>> InitialPeachesCount(3)\n    10\n*/\n   \n   static int InitialPeachesCount(int days)",
      "hi": "using System;\nusing System.Collections.Generic;\nusing System.Diagnostics;\n\nclass Program\n{\n/* यह गणना करें कि एक बंदर के पास शुरू में कितने आड़ू थे, यह दिया गया है कि वह प्रत्येक दिन आधे आड़ू खाता है और एक और खाता है, और Nवें दिन केवल एक आड़ू बचा होता है।\n    उदाहरण:\n    >>> InitialPeachesCount(1)\n    1\n    >>> InitialPeachesCount(2)\n    4\n    >>> InitialPeachesCount(3)\n    10\n*/\n   \n   static int InitialPeachesCount(int days)",
      "hu": "using System;\nusing System.Collections.Generic;\nusing System.Diagnostics;\n\nclass Program\n{\n/* Számítsuk ki, hogy hány őszibarackja volt kezdetben egy majomnak, ha minden nap megeszi a barackok felét plusz még egyet, és az N. napon csak egy barack marad.\n    Példák:\n    >>> InitialPeachesCount(1)\n    1\n    >>> InitialPeachesCount(2)\n    4\n    >>> InitialPeachesCount(3)\n    10\n*/\n   \n   static int InitialPeachesCount(int days)"
    },
    "prompt_bertscore": {
      "sq": "0.9885181708242783",
      "hy": "0.9776312396397561",
      "bn": "0.9595727585479692",
      "bg": "0.9870401621589977",
      "zh": "0.9581630787337646",
      "fr": "0.99596939230804",
      "de": "0.9803812772651841",
      "ha": "0.9681575636162971",
      "hi": "0.9804903253443722",
      "hu": "0.9704586965805863"
    },
    "canonical_solution": "{\n    int peaches = 1; // Start with 1 peach on the last day\n    for (int day = 1; day < days; day++)\n    {\n        peaches = 2 * (peaches + 1); // Double and add two for each previous day\n    }\n    return peaches;\n}",
    "instruction": {
      "en": "Write a C# function `static int InitialPeachesCount(int days)` to solve the following problem:\nCalculate the initial number of peaches a monkey had, given that each day it eats half of the peaches plus one more, and on the Nth day only one peach is left.\n    Examples:\n    >>> InitialPeachesCount(1)\n    1\n    >>> InitialPeachesCount(2)\n    4\n    >>> InitialPeachesCount(3)\n    10",
      "sq": "Shkruani një funksion në C# `static int InitialPeachesCount(int days)` për të zgjidhur problemin e mëposhtëm:\nLlogaritni numrin fillestar të pjeshkëve që kishte një majmun, duke pasur parasysh që çdo ditë ha gjysmën e pjeshkëve plus edhe një tjetër, dhe në ditën e N-të mbetet vetëm një pjeshkë.\n    Shembuj:\n    >>> InitialPeachesCount(1)\n    1\n    >>> InitialPeachesCount(2)\n    4\n    >>> InitialPeachesCount(3)\n    10",
      "hy": "Գրեք C# ֆունկցիա `static int InitialPeachesCount(int days)`՝ լուծելու հետևյալ խնդիրը:\nՀաշվարկել կապիկի սկզբնական դեղձերի քանակը, եթե ամեն օր այն ուտում է դեղձերի կեսը գումարած ևս մեկ, և N-րդ օրը մնում է միայն մեկ դեղձ:\n    Օրինակներ:\n    >>> InitialPeachesCount(1)\n    1\n    >>> InitialPeachesCount(2)\n    4\n    >>> InitialPeachesCount(3)\n    10",
      "bn": "C# ফাংশন `static int InitialPeachesCount(int days)` লিখুন নিম্নলিখিত সমস্যার সমাধানের জন্য:\nএকটি বাঁদর কতগুলো পীচ শুরুতে ছিল তা গণনা করুন, দেওয়া হয়েছে যে প্রতিদিন এটি পীচের অর্ধেক এবং আরও একটি খায়, এবং N-তম দিনে শুধুমাত্র একটি পীচ অবশিষ্ট থাকে।\n    উদাহরণ:\n    >>> InitialPeachesCount(1)\n    1\n    >>> InitialPeachesCount(2)\n    4\n    >>> InitialPeachesCount(3)\n    10",
      "bg": "Напишете C# функция `static int InitialPeachesCount(int days)`, за да решите следния проблем:  \nИзчислете първоначалния брой праскови, които една маймуна е имала, като се има предвид, че всеки ден тя изяжда половината от прасковите плюс още една, и на N-тия ден остава само една праскова.  \n    Примери:  \n    >>> InitialPeachesCount(1)  \n    1  \n    >>> InitialPeachesCount(2)  \n    4  \n    >>> InitialPeachesCount(3)  \n    10  ",
      "zh": "编写一个 C# 函数 `static int InitialPeachesCount(int days)` 来解决以下问题：  \n计算猴子最初有多少个桃子，已知它每天吃掉一半的桃子加上一个，并且在第 N 天只剩下一个桃子。  \n    示例：  \n    >>> InitialPeachesCount(1)  \n    1  \n    >>> InitialPeachesCount(2)  \n    4  \n    >>> InitialPeachesCount(3)  \n    10  ",
      "fr": "Écrire une fonction C# `static int InitialPeachesCount(int days)` pour résoudre le problème suivant :  \nCalculer le nombre initial de pêches qu'un singe avait, étant donné que chaque jour il mange la moitié des pêches plus une de plus, et que le Nème jour, il ne reste qu'une pêche.  \n    Exemples :  \n    >>> InitialPeachesCount(1)  \n    1  \n    >>> InitialPeachesCount(2)  \n    4  \n    >>> InitialPeachesCount(3)  \n    10  ",
      "de": "Schreiben Sie eine C#-Funktion `static int InitialPeachesCount(int days)`, um das folgende Problem zu lösen:\nBerechnen Sie die anfängliche Anzahl der Pfirsiche, die ein Affe hatte, gegeben, dass er jeden Tag die Hälfte der Pfirsiche plus einen weiteren isst und am N-ten Tag nur noch ein Pfirsich übrig ist.\n    Beispiele:\n    >>> InitialPeachesCount(1)\n    1\n    >>> InitialPeachesCount(2)\n    4\n    >>> InitialPeachesCount(3)\n    10",
      "ha": "Rubuta aikin C# `static int InitialPeachesCount(int days)` don warware matsalar mai zuwa:  \nƘididdige adadin farko na ayaba da biri ya mallaka, la'akari da cewa kowace rana yana cin rabin ayaba tare da ƙarin guda ɗaya, kuma a rana ta N guda ɗaya kawai ya rage.  \n    Misalai:  \n    >>> InitialPeachesCount(1)  \n    1  \n    >>> InitialPeachesCount(2)  \n    4  \n    >>> InitialPeachesCount(3)  \n    10  ",
      "hi": "C# फ़ंक्शन `static int InitialPeachesCount(int days)` लिखें ताकि निम्नलिखित समस्या का समाधान किया जा सके:\nबंदर के पास प्रारंभ में कितने आड़ू थे, यह गणना करें, यह दिया गया है कि हर दिन वह आड़ू का आधा खा लेता है और एक और खा लेता है, और Nवें दिन केवल एक आड़ू बचा होता है।\n    उदाहरण:\n    >>> InitialPeachesCount(1)\n    1\n    >>> InitialPeachesCount(2)\n    4\n    >>> InitialPeachesCount(3)\n    10",
      "hu": "Írj egy C# függvényt `static int InitialPeachesCount(int days)` a következő probléma megoldására:\nSzámítsd ki, hogy hány barackja volt kezdetben a majomnak, ha minden nap megeszi a barackok felét plusz még egyet, és az N-edik napon csak egy barack marad.\n    Példák:\n    >>> InitialPeachesCount(1)\n    1\n    >>> InitialPeachesCount(2)\n    4\n    >>> InitialPeachesCount(3)\n    10"
    },
    "instruction_bertscore": {
      "sq": "0.983273136982671",
      "hy": "0.9749574760806454",
      "bn": "0.9614996718743887",
      "bg": "0.9884101158969953",
      "zh": "0.9716459103680318",
      "fr": "0.9931132860591394",
      "de": "0.9826442731963145",
      "ha": "0.9619354669303792",
      "hi": "0.9665875890845973",
      "hu": "0.9642554697808667"
    },
    "level": "easy",
    "test": "    static void Main()\n    {\n        Debug.Assert(InitialPeachesCount(1) == 1);\n        Debug.Assert(InitialPeachesCount(2) == 4);\n        Debug.Assert(InitialPeachesCount(3) == 10);\n        Debug.Assert(InitialPeachesCount(4) == 22);\n\n\n    }\n}",
    "entry_point": "InitialPeachesCount",
    "signature": "static int InitialPeachesCount(int days)",
    "docstring": {
      "en": "Calculate the initial number of peaches a monkey had, given that each day it eats half of the peaches plus one more, and on the Nth day only one peach is left.\n    Examples:\n    >>> InitialPeachesCount(1)\n    1\n    >>> InitialPeachesCount(2)\n    4\n    >>> InitialPeachesCount(3)\n    10",
      "sq": "Llogarit numrin fillestar të pjeshkëve që një majmun kishte, duke pasur parasysh që çdo ditë ai ha gjysmën e pjeshkëve plus edhe një tjetër, dhe në ditën e N-të mbetet vetëm një pjeshkë.\n    Shembuj:\n    >>> InitialPeachesCount(1)\n    1\n    >>> InitialPeachesCount(2)\n    4\n    >>> InitialPeachesCount(3)\n    10",
      "hy": "Հաշվարկել, թե քանի դեղձ ուներ կապիկը սկզբում, եթե ամեն օր այն ուտում է դեղձերի կեսը գումարած ևս մեկը, և N-րդ օրը միայն մեկ դեղձ է մնում:\n    Օրինակներ:\n    >>> InitialPeachesCount(1)\n    1\n    >>> InitialPeachesCount(2)\n    4\n    >>> InitialPeachesCount(3)\n    10",
      "bn": "প্রাথমিকভাবে একটি বানরের কাছে কতগুলো পীচ ছিল তা গণনা করুন, এটি প্রতিদিন পীচের অর্ধেক এবং আরও একটি খায়, এবং N-তম দিনে কেবল একটি পীচ অবশিষ্ট থাকে।\n    উদাহরণ:\n    >>> InitialPeachesCount(1)\n    1\n    >>> InitialPeachesCount(2)\n    4\n    >>> InitialPeachesCount(3)\n    10",
      "bg": "Изчислете първоначалния брой праскови, които маймуната е имала, като се има предвид, че всеки ден тя изяжда половината от прасковите плюс още една, и на N-ия ден остава само една праскова.\n    Примери:\n    >>> InitialPeachesCount(1)\n    1\n    >>> InitialPeachesCount(2)\n    4\n    >>> InitialPeachesCount(3)\n    10",
      "zh": "计算猴子最初有多少桃子，已知每天它吃掉一半的桃子加上一个，并且在第N天只剩下一个桃子。\n    示例：\n    >>> InitialPeachesCount(1)\n    1\n    >>> InitialPeachesCount(2)\n    4\n    >>> InitialPeachesCount(3)\n    10",
      "fr": "Calculer le nombre initial de pêches qu'un singe avait, étant donné que chaque jour il mange la moitié des pêches plus une de plus, et que le Nème jour il ne reste qu'une pêche.\n    Exemples :\n    >>> InitialPeachesCount(1)\n    1\n    >>> InitialPeachesCount(2)\n    4\n    >>> InitialPeachesCount(3)\n    10",
      "de": "Berechne die anfängliche Anzahl der Pfirsiche, die ein Affe hatte, gegeben, dass er jeden Tag die Hälfte der Pfirsiche plus einen weiteren isst, und am N-ten Tag nur noch ein Pfirsich übrig ist.\n    Beispiele:\n    >>> InitialPeachesCount(1)\n    1\n    >>> InitialPeachesCount(2)\n    4\n    >>> InitialPeachesCount(3)\n    10",
      "ha": "Ƙididdige adadin ayaba da biri ya fara da shi, la'akari da cewa kowace rana yana cin rabin ayabar da ƙari ɗaya, kuma a rana ta N sai dai ayaba ɗaya ce ta rage. \n    Misalai:\n    >>> InitialPeachesCount(1)\n    1\n    >>> InitialPeachesCount(2)\n    4\n    >>> InitialPeachesCount(3)\n    10",
      "hi": "शुरुआती संख्या की गणना करें कि एक बंदर के पास कितने आड़ू थे, यह दिया गया है कि हर दिन वह आधे आड़ू खा लेता है और एक और खा लेता है, और Nवें दिन केवल एक आड़ू बचा होता है।\n    उदाहरण:\n    >>> InitialPeachesCount(1)\n    1\n    >>> InitialPeachesCount(2)\n    4\n    >>> InitialPeachesCount(3)\n    10",
      "hu": "Számítsuk ki, hogy hány barackja volt kezdetben egy majomnak, ha minden nap megeszi a barackok felét plusz még egyet, és az N-edik napon már csak egy barack marad.\n    Példák:\n    >>> InitialPeachesCount(1)\n    1\n    >>> InitialPeachesCount(2)\n    4\n    >>> InitialPeachesCount(3)\n    10"
    },
    "docstring_bertscore": {
      "sq": "0.9876958410467939",
      "hy": "0.9559759596081895",
      "bn": "0.9257513676780157",
      "bg": "0.979845372497152",
      "zh": "0.968897263155271",
      "fr": "0.9906161049087687",
      "de": "0.9818992106370527",
      "ha": "0.9724181852894954",
      "hi": "0.9906023994124774",
      "hu": "0.953160771217782"
    }
  },
  {
    "task_id": "C#/18",
    "prompt": {
      "en": "using System;\nusing System.Collections.Generic;\nusing System.Diagnostics;\n\nclass Program\n{\n    /* \n    FindAmicableNumbers - Finds all amicable number pairs within a specified limit.\n    Amicable numbers are two different numbers so related that the sum of the proper divisors of each is equal to the other number.\n\n    Example usage:\n    >>> FindAmicableNumbers(300)\n    >>> (220, 284)\n    */\nstatic List<(int, int)> FindAmicableNumbers(int limit)",
      "sq": "using System;\nusing System.Collections.Generic;\nusing System.Diagnostics;\n\nclass Program\n{\n    /* \n    FindAmicableNumbers - Gjen të gjitha çiftet e numrave miqësorë brenda një kufiri të specifikuar.\n    Numrat miqësorë janë dy numra të ndryshëm të tillë që shuma e ndarësve të duhur të secilit është e barabartë me numrin tjetër.\n\n    Shembull përdorimi:\n    >>> FindAmicableNumbers(300)\n    >>> (220, 284)\n    */\nstatic List<(int, int)> FindAmicableNumbers(int limit)",
      "hy": "using System;\nusing System.Collections.Generic;\nusing System.Diagnostics;\n\nclass Program\n{\n    /* \n    FindAmicableNumbers - Գտնում է բոլոր բարեկամական թվերի զույգերը նշված սահմանաչափի սահմաններում:\n    Բարեկամական թվերը երկու տարբեր թվեր են, որոնք այնպես են կապված, որ յուրաքանչյուրի ճիշտ բաժանարարների գումարը հավասար է մյուս թվին:\n\n    Օրինակ օգտագործում:\n    >>> FindAmicableNumbers(300)\n    >>> (220, 284)\n    */\nstatic List<(int, int)> FindAmicableNumbers(int limit)",
      "bn": "using System;\nusing System.Collections.Generic;\nusing System.Diagnostics;\n\nclass Program\n{\n    /* \n    FindAmicableNumbers - নির্দিষ্ট সীমার মধ্যে সমস্ত বন্ধুত্বপূর্ণ সংখ্যা জোড়া খুঁজে বের করে।\n    বন্ধুত্বপূর্ণ সংখ্যা হল দুটি ভিন্ন সংখ্যা যা এমনভাবে সম্পর্কিত যে প্রতিটির যথাযথ বিভাজকের যোগফল অন্য সংখ্যার সমান হয়।\n\n    উদাহরণ ব্যবহার:\n    >>> FindAmicableNumbers(300)\n    >>> (220, 284)\n    */\nstatic List<(int, int)> FindAmicableNumbers(int limit)",
      "bg": "using System;\nusing System.Collections.Generic;\nusing System.Diagnostics;\n\nclass Program\n{\n    /* \n    FindAmicableNumbers - Намира всички двойки приятелски числа в рамките на определен лимит.\n    Приятелските числа са две различни числа, които са свързани така, че сумата от собствените делители на всяко от тях е равна на другото число.\n\n    Пример за използване:\n    >>> FindAmicableNumbers(300)\n    >>> (220, 284)\n    */\nstatic List<(int, int)> FindAmicableNumbers(int limit)",
      "zh": "using System;\nusing System.Collections.Generic;\nusing System.Diagnostics;\n\nclass Program\n{\n    /* \n    FindAmicableNumbers - 查找指定范围内的所有亲和数对。\n    亲和数是这样的一对不同的数字：每个数字的适当除数之和等于另一个数字。\n\n    示例用法:\n    >>> FindAmicableNumbers(300)\n    >>> (220, 284)\n    */\nstatic List<(int, int)> FindAmicableNumbers(int limit)",
      "fr": "using System;\nusing System.Collections.Generic;\nusing System.Diagnostics;\n\nclass Program\n{\n    /* \n    FindAmicableNumbers - Trouve toutes les paires de nombres amicaux dans une limite spécifiée.\n    Les nombres amicaux sont deux nombres différents tels que la somme des diviseurs propres de chacun est égale à l'autre nombre.\n\n    Exemple d'utilisation :\n    >>> FindAmicableNumbers(300)\n    >>> (220, 284)\n    */\nstatic List<(int, int)> FindAmicableNumbers(int limit)",
      "de": "using System;\nusing System.Collections.Generic;\nusing System.Diagnostics;\n\nclass Program\n{\n    /* \n    FindAmicableNumbers - Findet alle befreundeten Zahlenpaare innerhalb eines angegebenen Limits.\n    Befreundete Zahlen sind zwei verschiedene Zahlen, die so miteinander verbunden sind, dass die Summe der echten Teiler jeder Zahl gleich der anderen Zahl ist.\n\n    Beispielverwendung:\n    >>> FindAmicableNumbers(300)\n    >>> (220, 284)\n    */\nstatic List<(int, int)> FindAmicableNumbers(int limit)",
      "ha": "using System;\nusing System.Collections.Generic;\nusing System.Diagnostics;\n\nclass Program\n{\n    /* \n    FindAmicableNumbers - Nemi dukkan lambobin abokantaka a cikin iyaka da aka fayyace.\n    Lambobin abokantaka su ne lambobi biyu daban-daban da suka danganta da cewa jumlar masu rarraba da suka dace na kowanne ya yi daidai da dayan lambar.\n\n    Misalin amfani:\n    >>> FindAmicableNumbers(300)\n    >>> (220, 284)\n    */\nstatic List<(int, int)> FindAmicableNumbers(int limit)",
      "hi": "using System;\nusing System.Collections.Generic;\nusing System.Diagnostics;\n\nclass Program\n{\n    /* \n    FindAmicableNumbers - निर्दिष्ट सीमा के भीतर सभी मित्रवत संख्या युग्मों को खोजता है।\n    मित्रवत संख्याएँ दो अलग-अलग संख्याएँ होती हैं जो इस प्रकार संबंधित होती हैं कि प्रत्येक के उचित भाजकों का योग दूसरी संख्या के बराबर होता है।\n\n    उदाहरण उपयोग:\n    >>> FindAmicableNumbers(300)\n    >>> (220, 284)\n    */\nstatic List<(int, int)> FindAmicableNumbers(int limit)",
      "hu": "using System;\nusing System.Collections.Generic;\nusing System.Diagnostics;\n\nclass Program\n{\n    /* \n    FindAmicableNumbers - Megtalálja az összes barátságos szám párt egy megadott határon belül.\n    A barátságos számok két különböző szám, amelyek úgy kapcsolódnak egymáshoz, hogy mindegyiknek a valódi osztóinak összege egyenlő a másik számmal.\n\n    Példa használat:\n    >>> FindAmicableNumbers(300)\n    >>> (220, 284)\n    */\nstatic List<(int, int)> FindAmicableNumbers(int limit)"
    },
    "prompt_bertscore": {
      "sq": "0.9844392959497269",
      "hy": "0.9825320470310298",
      "bn": "0.9797154682279552",
      "bg": "0.9768049372546509",
      "zh": "0.9629256393798381",
      "fr": "0.9793489951749458",
      "de": "0.970070374185663",
      "ha": "0.9725331922801146",
      "hi": "0.9823898276782089",
      "hu": "0.9725439183206905"
    },
    "canonical_solution": "{\n    List<(int, int)> amicablePairs = new List<(int, int)>();\n    for (int i = 1; i <= limit; i++)\n    {\n        int sumOfDivisors = SumProperDivisors(i);\n        if (sumOfDivisors > i && sumOfDivisors <= limit)\n        {\n            if (SumProperDivisors(sumOfDivisors) == i)\n            {\n                amicablePairs.Add((i, sumOfDivisors));\n            }\n        }\n    }\n    return amicablePairs;\n}\n\nstatic int SumProperDivisors(int number)\n{\n    int sum = 0;\n    for (int i = 1; i <= number / 2; i++)\n    {\n        if (number % i == 0)\n        {\n            sum += i;\n        }\n    }\n    return sum;\n}",
    "instruction": {
      "en": "Write a C# function `static List<(int, int)> FindAmicableNumbers(int limit)` to solve the following problem:\nFindAmicableNumbers - Finds all amicable number pairs within a specified limit.\n    Amicable numbers are two different numbers so related that the sum of the proper divisors of each is equal to the other number.\n\n    Example usage:\n    >>> FindAmicableNumbers(300)\n    >>> (220, 284)",
      "sq": "Shkruani një funksion në C# `static List<(int, int)> FindAmicableNumbers(int limit)` për të zgjidhur problemin e mëposhtëm:\nFindAmicableNumbers - Gjen të gjitha çiftet e numrave miqësorë brenda një kufiri të specifikuar.\n    Numrat miqësorë janë dy numra të ndryshëm të tillë që shuma e pjesëtorëve të duhur të secilit është e barabartë me numrin tjetër.\n\n    Shembull përdorimi:\n    >>> FindAmicableNumbers(300)\n    >>> (220, 284)",
      "hy": "Գրեք C# ֆունկցիա `static List<(int, int)> FindAmicableNumbers(int limit)` հետևյալ խնդիրը լուծելու համար:\nFindAmicableNumbers - Գտնում է բոլոր ընկերական թվերի զույգերը նշված սահմաններում:\n    Ընկերական թվերը երկու տարբեր թվեր են, որոնք այնպես են կապված, որ յուրաքանչյուրի ճիշտ բաժանարարների գումարը հավասար է մյուս թվին:\n\n    Օրինակ օգտագործում:\n    >>> FindAmicableNumbers(300)\n    >>> (220, 284)",
      "bn": "C# ফাংশন `static List<(int, int)> FindAmicableNumbers(int limit)` লিখুন নিম্নলিখিত সমস্যার সমাধানের জন্য:\nFindAmicableNumbers - নির্দিষ্ট সীমার মধ্যে সমস্ত বন্ধুত্বপূর্ণ সংখ্যা জোড়া খুঁজে বের করে।\n    বন্ধুত্বপূর্ণ সংখ্যা হল দুটি ভিন্ন সংখ্যা যেগুলি এমনভাবে সম্পর্কিত যে প্রতিটির যথাযথ বিভাজকের যোগফল অন্য সংখ্যার সমান হয়।\n\n    উদাহরণ ব্যবহার:\n    >>> FindAmicableNumbers(300)\n    >>> (220, 284)",
      "bg": "Напишете C# функция `static List<(int, int)> FindAmicableNumbers(int limit)` за решаване на следния проблем:\nFindAmicableNumbers - Намира всички двойки приятелски числа в рамките на определен лимит.\n    Приятелски числа са две различни числа, така свързани, че сумата от собствените им делители е равна на другото число.\n\n    Пример за използване:\n    >>> FindAmicableNumbers(300)\n    >>> (220, 284)",
      "zh": "编写一个 C# 函数 `static List<(int, int)> FindAmicableNumbers(int limit)` 来解决以下问题：\n在指定的限制内查找所有友好数对。\n    友好数是两个不同的数字，它们之间的关系是每个数字的适当除数之和等于另一个数字。\n\n    示例用法:\n    >>> FindAmicableNumbers(300)\n    >>> (220, 284)",
      "fr": "Écrire une fonction C# `static List<(int, int)> FindAmicableNumbers(int limit)` pour résoudre le problème suivant :\nFindAmicableNumbers - Trouve toutes les paires de nombres amicaux dans une limite spécifiée.\n    Les nombres amicaux sont deux nombres différents tels que la somme des diviseurs propres de chacun est égale à l'autre nombre.\n\n    Exemple d'utilisation :\n    >>> FindAmicableNumbers(300)\n    >>> (220, 284)",
      "de": "Schreiben Sie eine C#-Funktion `static List<(int, int)> FindAmicableNumbers(int limit)`, um das folgende Problem zu lösen:\nFindAmicableNumbers - Findet alle befreundeten Zahlenpaare innerhalb eines angegebenen Limits.\n    Befreundete Zahlen sind zwei verschiedene Zahlen, die so miteinander verbunden sind, dass die Summe der echten Teiler jeder Zahl der anderen Zahl entspricht.\n\n    Beispielverwendung:\n    >>> FindAmicableNumbers(300)\n    >>> (220, 284)",
      "ha": "Rubuta aikin C# `static List<(int, int)> FindAmicableNumbers(int limit)` don warware matsalar mai zuwa:\nFindAmicableNumbers - Nemi duk ma'auratan lambobi masu aminci a cikin iyaka da aka kayyade.\n    Lambobin aminci su ne lambobi biyu daban-daban da suka danganta da cewa jumlar masu raba su daidai na kowane ɗayan su daidai yake da ɗayan lambar.\n\n    Misalin amfani:\n    >>> FindAmicableNumbers(300)\n    >>> (220, 284)",
      "hi": "C# फ़ंक्शन `static List<(int, int)> FindAmicableNumbers(int limit)` लिखें ताकि निम्नलिखित समस्या का समाधान किया जा सके:\nFindAmicableNumbers - निर्दिष्ट सीमा के भीतर सभी मित्रवत संख्या युग्मों को खोजता है।\n    मित्रवत संख्याएँ दो अलग-अलग संख्याएँ होती हैं जो इस प्रकार संबंधित होती हैं कि प्रत्येक के उचित भाजकों का योग दूसरी संख्या के बराबर होता है।\n\n    उदाहरण उपयोग:\n    >>> FindAmicableNumbers(300)\n    >>> (220, 284)",
      "hu": "Írj egy C# függvényt `static List<(int, int)> FindAmicableNumbers(int limit)` a következő probléma megoldására:\nFindAmicableNumbers - Megtalálja az összes barátságos szám párt egy megadott határon belül.\n    A barátságos számok két különböző szám, amelyek úgy kapcsolódnak egymáshoz, hogy mindegyik szám megfelelő osztóinak összege egyenlő a másik számmal.\n\n    Példa használat:\n    >>> FindAmicableNumbers(300)\n    >>> (220, 284)"
    },
    "instruction_bertscore": {
      "sq": "0.9788937343416139",
      "hy": "0.9891748428639796",
      "bn": "0.9714339717514675",
      "bg": "0.9786146586562599",
      "zh": "0.9516279405673358",
      "fr": "0.9799498520775763",
      "de": "0.9667059727916941",
      "ha": "0.9646592853455106",
      "hi": "0.9765737314911264",
      "hu": "0.974112105178961"
    },
    "level": "hard",
    "test": "    static void Main()\n    {\n        Debug.Assert(FindAmicableNumbers(300).SequenceEqual(new List<(int, int)> { (220, 284) }));\n        Debug.Assert(FindAmicableNumbers(2000).SequenceEqual(new List<(int, int)> { (220, 284), (1184, 1210) }));\n        Debug.Assert(FindAmicableNumbers(500).Count == 1);\n        Debug.Assert(FindAmicableNumbers(100).Count == 0);\n        Debug.Assert(FindAmicableNumbers(3000).SequenceEqual(new List<(int, int)> { (220, 284), (1184, 1210) ,(2620,2924)}));\n\n    }\n}\n\n\n\n",
    "entry_point": "FindAmicableNumbers",
    "signature": "static List<(int, int)> FindAmicableNumbers(int limit)",
    "docstring": {
      "en": "FindAmicableNumbers - Finds all amicable number pairs within a specified limit.\n    Amicable numbers are two different numbers so related that the sum of the proper divisors of each is equal to the other number.\n\n    Example usage:\n    >>> FindAmicableNumbers(300)\n    >>> (220, 284)",
      "sq": "FindAmicableNumbers - Gjen të gjitha çiftet e numrave miqësorë brenda një kufiri të specifikuar.\n    Numrat miqësorë janë dy numra të ndryshëm të lidhur në atë mënyrë që shuma e ndarësve të duhur të secilit është e barabartë me numrin tjetër.\n\n    Shembull përdorimi:\n    >>> FindAmicableNumbers(300)\n    >>> (220, 284)",
      "hy": "FindAmicableNumbers - Գտնում է բոլոր բարեկամական թվերի զույգերը նշված սահմաններում:\n    Բարեկամական թվերը երկու տարբեր թվեր են, որոնք այնպես են կապված, որ յուրաքանչյուրի ճիշտ բաժանարարների գումարը հավասար է մյուս թվին:\n\n    Օգտագործման օրինակ:\n    >>> FindAmicableNumbers(300)\n    >>> (220, 284)",
      "bn": "FindAmicableNumbers - নির্দিষ্ট সীমার মধ্যে সমস্ত বন্ধুত্বপূর্ণ সংখ্যা জোড়া খুঁজে বের করে।\n    বন্ধুত্বপূর্ণ সংখ্যা হল দুটি ভিন্ন সংখ্যা যা এমনভাবে সম্পর্কিত যে প্রতিটির সঠিক গুণনীয়কের যোগফল অন্য সংখ্যার সমান হয়।\n\n    উদাহরণ ব্যবহার:\n    >>> FindAmicableNumbers(300)\n    >>> (220, 284)",
      "bg": "FindAmicableNumbers - Намира всички двойки приятелски числа в рамките на определен лимит.\n    Приятелските числа са две различни числа, свързани така, че сумата от собствените им делители е равна на другото число.\n\n    Пример за използване:\n    >>> FindAmicableNumbers(300)\n    >>> (220, 284)",
      "zh": "FindAmicableNumbers - 查找指定范围内的所有亲和数对。\n    亲和数是两个不同的数字，它们的特性是每个数字的适当除数之和等于另一个数字。\n\n    示例用法:\n    >>> FindAmicableNumbers(300)\n    >>> (220, 284)",
      "fr": "FindAmicableNumbers - Trouve toutes les paires de nombres amicaux dans une limite spécifiée.\n    Les nombres amicaux sont deux nombres différents tels que la somme des diviseurs propres de chacun est égale à l'autre nombre.\n\n    Exemple d'utilisation :\n    >>> FindAmicableNumbers(300)\n    >>> (220, 284)",
      "de": "FindAmicableNumbers - Findet alle befreundeten Zahlenpaare innerhalb eines angegebenen Limits.\n    Befreundete Zahlen sind zwei verschiedene Zahlen, die so miteinander verbunden sind, dass die Summe der echten Teiler jeder Zahl der anderen Zahl entspricht.\n\n    Beispielverwendung:\n    >>> FindAmicableNumbers(300)\n    >>> (220, 284)",
      "ha": "FindAmicableNumbers - Nemi duk ma'auratan lambobi masu aminci a cikin iyaka da aka kayyade.\n    Lambobin aminci su ne lambobi biyu daban-daban da suka danganta da cewa jumlar masu rarraba daidai na kowanne ya yi daidai da dayan lambar.\n\n    Misalin amfani:\n    >>> FindAmicableNumbers(300)\n    >>> (220, 284)",
      "hi": "FindAmicableNumbers - निर्दिष्ट सीमा के भीतर सभी मैत्रीपूर्ण संख्या युग्मों को खोजता है।  \n    मैत्रीपूर्ण संख्याएँ दो अलग-अलग संख्याएँ होती हैं जो इस प्रकार संबंधित होती हैं कि प्रत्येक के उचित भाजकों का योग दूसरी संख्या के बराबर होता है।\n\n    उदाहरण उपयोग:\n    >>> FindAmicableNumbers(300)\n    >>> (220, 284)",
      "hu": "FindAmicableNumbers - Megkeresi az összes barátságos szám párt egy megadott határon belül.\n    A barátságos számok két különböző szám, amelyek úgy kapcsolódnak egymáshoz, hogy mindegyik szám megfelelő osztóinak összege egyenlő a másik számmal.\n\n    Példa használat:\n    >>> FindAmicableNumbers(300)\n    >>> (220, 284)"
    },
    "docstring_bertscore": {
      "sq": "0.9685762764595186",
      "hy": "0.9537461349506918",
      "bn": "0.9759788334999269",
      "bg": "0.9579815305654987",
      "zh": "0.9447249389352302",
      "fr": "0.9692635375778993",
      "de": "0.9517135502615618",
      "ha": "0.9651010393129322",
      "hi": "0.9673354324691936",
      "hu": "0.9683760570354355"
    }
  },
  {
    "task_id": "C#/19",
    "prompt": {
      "en": "using System;\nusing System.Collections.Generic;\nusing System.Diagnostics;\n\nclass Program\n{\n/* This function takes a string, reverses it, and then concatenates it with the original string.\n    Example usage:\n    >>> ReverseAndConcatenate(\"hello\")\n    \"helloolleh\"\n    >>> ReverseAndConcatenate(\"123\")\n    \"123321\"\n*/\nstatic string ReverseAndConcatenate(string input)",
      "sq": "using System;\nusing System.Collections.Generic;\nusing System.Diagnostics;\n\nclass Program\n{\n/* Kjo funksion merr një varg, e kthen atë dhe pastaj e bashkon me vargun origjinal.\n    Shembull përdorimi:\n    >>> ReverseAndConcatenate(\"hello\")\n    \"helloolleh\"\n    >>> ReverseAndConcatenate(\"123\")\n    \"123321\"\n*/\nstatic string ReverseAndConcatenate(string input)",
      "hy": "using System;\nusing System.Collections.Generic;\nusing System.Diagnostics;\n\nclass Program\n{\n/* Այս ֆունկցիան ստանում է տող, շրջում է այն, ապա միացնում է այն սկզբնական տողի հետ։\n    Օրինակ օգտագործում՝\n    >>> ReverseAndConcatenate(\"hello\")\n    \"helloolleh\"\n    >>> ReverseAndConcatenate(\"123\")\n    \"123321\"\n*/\nstatic string ReverseAndConcatenate(string input)",
      "bn": "using System;\nusing System.Collections.Generic;\nusing System.Diagnostics;\n\nclass Program\n{\n/* এই ফাংশনটি একটি স্ট্রিং নেয়, এটিকে উল্টায় এবং তারপর মূল স্ট্রিংটির সাথে সংযুক্ত করে।\n    উদাহরণ ব্যবহার:\n    >>> ReverseAndConcatenate(\"hello\")\n    \"helloolleh\"\n    >>> ReverseAndConcatenate(\"123\")\n    \"123321\"\n*/\nstatic string ReverseAndConcatenate(string input)",
      "bg": "using System;\nusing System.Collections.Generic;\nusing System.Diagnostics;\n\nclass Program\n{\n/* Тази функция приема низ, обръща го и след това го конкатенира с оригиналния низ.\n    Пример за използване:\n    >>> ReverseAndConcatenate(\"hello\")\n    \"helloolleh\"\n    >>> ReverseAndConcatenate(\"123\")\n    \"123321\"\n*/\nstatic string ReverseAndConcatenate(string input)",
      "zh": "using System;\nusing System.Collections.Generic;\nusing System.Diagnostics;\n\nclass Program\n{\n/* 此函数接收一个字符串，将其反转，然后与原始字符串连接。\n    示例用法:\n    >>> ReverseAndConcatenate(\"hello\")\n    \"helloolleh\"\n    >>> ReverseAndConcatenate(\"123\")\n    \"123321\"\n*/\nstatic string ReverseAndConcatenate(string input)",
      "fr": "using System;\nusing System.Collections.Generic;\nusing System.Diagnostics;\n\nclass Program\n{\n/* Cette fonction prend une chaîne, la renverse, puis la concatène avec la chaîne originale.\n    Exemple d'utilisation :\n    >>> ReverseAndConcatenate(\"hello\")\n    \"helloolleh\"\n    >>> ReverseAndConcatenate(\"123\")\n    \"123321\"\n*/\nstatic string ReverseAndConcatenate(string input)",
      "de": "using System;\nusing System.Collections.Generic;\nusing System.Diagnostics;\n\nclass Program\n{\n/* Diese Funktion nimmt einen String, kehrt ihn um und verkettet ihn dann mit dem ursprünglichen String.\n    Beispielverwendung:\n    >>> ReverseAndConcatenate(\"hello\")\n    \"helloolleh\"\n    >>> ReverseAndConcatenate(\"123\")\n    \"123321\"\n*/\nstatic string ReverseAndConcatenate(string input)",
      "ha": "using System;\nusing System.Collections.Generic;\nusing System.Diagnostics;\n\nclass Program\n{\n/* Wannan aikin yana karɓar wani rubutu, yana jujjuya shi, sannan yana haɗa shi da rubutun asali.\n    Misalin amfani:\n    >>> ReverseAndConcatenate(\"hello\")\n    \"helloolleh\"\n    >>> ReverseAndConcatenate(\"123\")\n    \"123321\"\n*/\nstatic string ReverseAndConcatenate(string input)",
      "hi": "using System;\nusing System.Collections.Generic;\nusing System.Diagnostics;\n\nclass Program\n{\n/* यह फ़ंक्शन एक स्ट्रिंग लेता है, उसे उलटता है, और फिर उसे मूल स्ट्रिंग के साथ जोड़ता है।\n    उदाहरण उपयोग:\n    >>> ReverseAndConcatenate(\"hello\")\n    \"helloolleh\"\n    >>> ReverseAndConcatenate(\"123\")\n    \"123321\"\n*/\nstatic string ReverseAndConcatenate(string input)",
      "hu": "using System;\nusing System.Collections.Generic;\nusing System.Diagnostics;\n\nclass Program\n{\n/* Ez a függvény egy karakterláncot vesz, megfordítja, majd összefűzi az eredeti karakterlánccal.\n    Példa használat:\n    >>> ReverseAndConcatenate(\"hello\")\n    \"helloolleh\"\n    >>> ReverseAndConcatenate(\"123\")\n    \"123321\"\n*/\nstatic string ReverseAndConcatenate(string input)"
    },
    "prompt_bertscore": {
      "sq": "0.999999801369619",
      "hy": "0.999999801369619",
      "bn": "0.999999801369619",
      "bg": "0.999999801369619",
      "zh": "0.9951420967710297",
      "fr": "0.9929396831061149",
      "de": "0.999999801369619",
      "ha": "0.999999801369619",
      "hi": "0.999999801369619",
      "hu": "0.999999801369619"
    },
    "canonical_solution": "{\n    char[] charArray = input.ToCharArray();\n    Array.Reverse(charArray);\n    return input + new string(charArray);\n}",
    "instruction": {
      "en": "Write a C# function `static string ReverseAndConcatenate(string input)` to solve the following problem:\nThis function takes a string, reverses it, and then concatenates it with the original string.\n    Example usage:\n    >>> ReverseAndConcatenate(\"hello\")\n    \"helloolleh\"\n    >>> ReverseAndConcatenate(\"123\")\n    \"123321\"",
      "sq": "Shkruani një funksion në C# `static string ReverseAndConcatenate(string input)` për të zgjidhur problemin e mëposhtëm: Ky funksion merr një varg, e kthen atë mbrapsht dhe pastaj e bashkon me vargun origjinal. \n    Shembull përdorimi:\n    >>> ReverseAndConcatenate(\"hello\")\n    \"helloolleh\"\n    >>> ReverseAndConcatenate(\"123\")\n    \"123321\"",
      "hy": "Գրեք C# ֆունկցիա `static string ReverseAndConcatenate(string input)` հետևյալ խնդիրը լուծելու համար:\nԱյս ֆունկցիան ընդունում է տող, շրջում այն, և հետո միացնում այն սկզբնական տողի հետ։\n    Օրինակ օգտագործում:\n    >>> ReverseAndConcatenate(\"hello\")\n    \"helloolleh\"\n    >>> ReverseAndConcatenate(\"123\")\n    \"123321\"",
      "bn": "C# ফাংশন `static string ReverseAndConcatenate(string input)` লিখুন নিম্নলিখিত সমস্যার সমাধানের জন্য:\nএই ফাংশনটি একটি স্ট্রিং গ্রহণ করে, সেটিকে উল্টায়, এবং তারপর মূল স্ট্রিংটির সাথে সংযুক্ত করে।\n    উদাহরণ ব্যবহার:\n    >>> ReverseAndConcatenate(\"hello\")\n    \"helloolleh\"\n    >>> ReverseAndConcatenate(\"123\")\n    \"123321\"",
      "bg": "Напишете C# функция `static string ReverseAndConcatenate(string input)`, за да решите следния проблем:  \nТази функция приема низ, обръща го и след това го конкатенира с оригиналния низ.  \n    Пример за използване:  \n    >>> ReverseAndConcatenate(\"hello\")  \n    \"helloolleh\"  \n    >>> ReverseAndConcatenate(\"123\")  \n    \"123321\"",
      "zh": "编写一个 C# 函数 `static string ReverseAndConcatenate(string input)` 来解决以下问题：  \n该函数接受一个字符串，将其反转，然后与原始字符串连接。  \n    示例用法:  \n    >>> ReverseAndConcatenate(\"hello\")  \n    \"helloolleh\"  \n    >>> ReverseAndConcatenate(\"123\")  \n    \"123321\"",
      "fr": "Écrire une fonction C# `static string ReverseAndConcatenate(string input)` pour résoudre le problème suivant :  \nCette fonction prend une chaîne, la renverse, puis la concatène avec la chaîne originale.  \n    Exemple d'utilisation :  \n    >>> ReverseAndConcatenate(\"hello\")  \n    \"helloolleh\"  \n    >>> ReverseAndConcatenate(\"123\")  \n    \"123321\"",
      "de": "Schreiben Sie eine C#-Funktion `static string ReverseAndConcatenate(string input)`, um das folgende Problem zu lösen:\nDiese Funktion nimmt einen String, kehrt ihn um und hängt ihn dann an den Originalstring an.\n    Beispielverwendung:\n    >>> ReverseAndConcatenate(\"hello\")\n    \"helloolleh\"\n    >>> ReverseAndConcatenate(\"123\")\n    \"123321\"",
      "ha": "Rubuta aikin C# `static string ReverseAndConcatenate(string input)` don warware matsalar mai zuwa:\nWannan aikin yana ɗaukar igiyar rubutu, yana juyawa, sannan yana haɗawa da igiyar rubutu ta asali.\n    Misalin amfani:\n    >>> ReverseAndConcatenate(\"hello\")\n    \"helloolleh\"\n    >>> ReverseAndConcatenate(\"123\")\n    \"123321\"",
      "hi": "C# फ़ंक्शन `static string ReverseAndConcatenate(string input)` लिखें ताकि निम्नलिखित समस्या का समाधान किया जा सके:\nयह फ़ंक्शन एक स्ट्रिंग लेता है, उसे उलटता है, और फिर उसे मूल स्ट्रिंग के साथ जोड़ता है।\n    उदाहरण उपयोग:\n    >>> ReverseAndConcatenate(\"hello\")\n    \"helloolleh\"\n    >>> ReverseAndConcatenate(\"123\")\n    \"123321\"",
      "hu": "Írj egy C# függvényt `static string ReverseAndConcatenate(string input)` a következő probléma megoldására: Ez a függvény egy karakterláncot vesz, megfordítja, majd összefűzi az eredeti karakterlánccal.  \n    Példa használat:  \n    >>> ReverseAndConcatenate(\"hello\")  \n    \"helloolleh\"  \n    >>> ReverseAndConcatenate(\"123\")  \n    \"123321\""
    },
    "instruction_bertscore": {
      "sq": "0.9937578416455976",
      "hy": "1",
      "bn": "0.9853365093808615",
      "bg": "0.9976172299491055",
      "zh": "0.9938142526738115",
      "fr": "0.992017839507732",
      "de": "0.9760380253534753",
      "ha": "1",
      "hi": "0.9851760160329852",
      "hu": "1"
    },
    "level": "easy",
    "test": "    static void Main()\n    {\n        Debug.Assert(ReverseAndConcatenate(\"abc\") == \"abccba\");\n        Debug.Assert(ReverseAndConcatenate(\"test\") == \"testtset\");\n        Debug.Assert(ReverseAndConcatenate(\"\") == \"\");\n        Debug.Assert(ReverseAndConcatenate(\"12345\") == \"1234554321\");\n\n    }\n}",
    "entry_point": "ReverseAndConcatenate",
    "signature": "static string ReverseAndConcatenate(string input)",
    "docstring": {
      "en": "This function takes a string, reverses it, and then concatenates it with the original string.\n    Example usage:\n    >>> ReverseAndConcatenate(\"hello\")\n    \"helloolleh\"\n    >>> ReverseAndConcatenate(\"123\")\n    \"123321\"",
      "sq": "Kjo funksion merr një varg, e kthen atë mbrapsht dhe pastaj e bashkon me vargun origjinal.\n    Shembull përdorimi:\n    >>> ReverseAndConcatenate(\"hello\")\n    \"helloolleh\"\n    >>> ReverseAndConcatenate(\"123\")\n    \"123321\"",
      "hy": "Այս ֆունկցիան ստանում է տող, շրջում այն, ապա միացնում այն սկզբնական տողի հետ:\n    Օրինակ օգտագործում:\n    >>> ReverseAndConcatenate(\"hello\")\n    \"helloolleh\"\n    >>> ReverseAndConcatenate(\"123\")\n    \"123321\"",
      "bn": "এই ফাংশনটি একটি স্ট্রিং নেয়, সেটিকে উল্টায় এবং তারপর মূল স্ট্রিংটির সাথে সংযুক্ত করে।\n    উদাহরণ ব্যবহার:\n    >>> ReverseAndConcatenate(\"hello\")\n    \"helloolleh\"\n    >>> ReverseAndConcatenate(\"123\")\n    \"123321\"",
      "bg": "Тази функция приема низ, обръща го и след това го конкатенира с оригиналния низ.\n    Пример за използване:\n    >>> ReverseAndConcatenate(\"hello\")\n    \"helloolleh\"\n    >>> ReverseAndConcatenate(\"123\")\n    \"123321\"",
      "zh": "这个函数接受一个字符串，将其反转，然后与原始字符串连接。  \nExample usage:  \n示例用法：  \n>>> ReverseAndConcatenate(\"hello\")  \n\"helloolleh\"  \n>>> ReverseAndConcatenate(\"123\")  \n\"123321\"",
      "fr": "Cette fonction prend une chaîne de caractères, la renverse, puis la concatène avec la chaîne originale.\n    Exemple d'utilisation :\n    >>> ReverseAndConcatenate(\"hello\")\n    \"helloolleh\"\n    >>> ReverseAndConcatenate(\"123\")\n    \"123321\"",
      "de": "Diese Funktion nimmt einen String, kehrt ihn um und verknüpft ihn dann mit dem ursprünglichen String.\n    Beispielverwendung:\n    >>> ReverseAndConcatenate(\"hello\")\n    \"helloolleh\"\n    >>> ReverseAndConcatenate(\"123\")\n    \"123321\"",
      "ha": "Wannan aikin yana karɓar kirtani, yana juyawa, sannan yana haɗa shi da kirtanin asali.\n    Misalin amfani:\n    >>> ReverseAndConcatenate(\"hello\")\n    \"helloolleh\"\n    >>> ReverseAndConcatenate(\"123\")\n    \"123321\"",
      "hi": "यह फ़ंक्शन एक स्ट्रिंग लेता है, उसे उलटता है, और फिर उसे मूल स्ट्रिंग के साथ जोड़ता है।\n    उदाहरण उपयोग:\n    >>> ReverseAndConcatenate(\"hello\")\n    \"helloolleh\"\n    >>> ReverseAndConcatenate(\"123\")\n    \"123321\"",
      "hu": "Ez a függvény egy karakterláncot vesz, megfordítja, majd összefűzi az eredeti karakterlánccal.\n    Példa használat:\n    >>> ReverseAndConcatenate(\"hello\")\n    \"helloolleh\"\n    >>> ReverseAndConcatenate(\"123\")\n    \"123321\""
    },
    "docstring_bertscore": {
      "sq": "1",
      "hy": "1",
      "bn": "1",
      "bg": "1",
      "zh": "1",
      "fr": "0.9896142132668287",
      "de": "1",
      "ha": "0.9872824912238602",
      "hi": "1",
      "hu": "1"
    }
  },
  {
    "task_id": "C#/20",
    "prompt": {
      "en": "using System;\nusing System.Collections.Generic;\nusing System.Diagnostics;\n\nclass Program\n{\n/* Calculates the number of unique postage values that can be created using a given number of 3-cent and 5-cent stamps.\n        Parameters:\n        threeCentStamps - the number of 3-cent stamps available\n        fiveCentStamps - the number of 5-cent stamps available\n\n        Returns:\n        The number of unique postage values that can be created.\n\n        Example:\n        >>> CountUniquePostageCombinations(4, 3)\n        19\n\n        >>> CountUniquePostageCombinations(2, 2)\n        8\n    */\n    static int CountUniquePostageCombinations(int threeCentStamps, int fiveCentStamps)",
      "sq": "using System;\nusing System.Collections.Generic;\nusing System.Diagnostics;\n\nclass Program\n{\n/* Llogarit numrin e vlerave unike të pullave postare që mund të krijohen duke përdorur një numër të caktuar pullash prej 3-cent dhe 5-cent.\n        Parametrat:\n        threeCentStamps - numri i pullave prej 3-cent në dispozicion\n        fiveCentStamps - numri i pullave prej 5-cent në dispozicion\n\n        Kthen:\n        Numri i vlerave unike të pullave postare që mund të krijohen.\n\n        Shembull:\n        >>> CountUniquePostageCombinations(4, 3)\n        19\n\n        >>> CountUniquePostageCombinations(2, 2)\n        8\n    */\n    static int CountUniquePostageCombinations(int threeCentStamps, int fiveCentStamps)",
      "hy": "using System;\nusing System.Collections.Generic;\nusing System.Diagnostics;\n\nclass Program\n{\n/* Հաշվում է եզակի փոստային արժեքների քանակը, որոնք կարող են ստեղծվել օգտագործելով 3 ցենտանոց և 5 ցենտանոց դրոշմանիշների տրված քանակը:\n        Պարամետրեր:\n        threeCentStamps - 3 ցենտանոց դրոշմանիշների քանակը\n        fiveCentStamps - 5 ցենտանոց դրոշմանիշների քանակը\n\n        Վերադարձնում է:\n        Եզակի փոստային արժեքների քանակը, որոնք կարող են ստեղծվել:\n\n        Օրինակ:\n        >>> CountUniquePostageCombinations(4, 3)\n        19\n\n        >>> CountUniquePostageCombinations(2, 2)\n        8\n    */\n    static int CountUniquePostageCombinations(int threeCentStamps, int fiveCentStamps)",
      "bn": "using System;\nusing System.Collections.Generic;\nusing System.Diagnostics;\n\nclass Program\n{\n/* প্রদত্ত সংখ্যক 3-সেন্ট এবং 5-সেন্ট স্ট্যাম্প ব্যবহার করে কতগুলো অনন্য ডাকমাশুল মান তৈরি করা যেতে পারে তা গণনা করে।\n        প্যারামিটার:\n        threeCentStamps - উপলব্ধ 3-সেন্ট স্ট্যাম্পের সংখ্যা\n        fiveCentStamps - উপলব্ধ 5-সেন্ট স্ট্যাম্পের সংখ্যা\n\n        রিটার্নস:\n        কতগুলো অনন্য ডাকমাশুল মান তৈরি করা যেতে পারে।\n\n        উদাহরণ:\n        >>> CountUniquePostageCombinations(4, 3)\n        19\n\n        >>> CountUniquePostageCombinations(2, 2)\n        8\n    */\n    static int CountUniquePostageCombinations(int threeCentStamps, int fiveCentStamps)",
      "bg": "using System;\nusing System.Collections.Generic;\nusing System.Diagnostics;\n\nclass Program\n{\n/* Изчислява броя на уникалните стойности на пощенски марки, които могат да бъдат създадени с даден брой 3-центови и 5-центови марки.\n        Параметри:\n        threeCentStamps - броят на наличните 3-центови марки\n        fiveCentStamps - броят на наличните 5-центови марки\n\n        Връща:\n        Броят на уникалните стойности на пощенски марки, които могат да бъдат създадени.\n\n        Пример:\n        >>> CountUniquePostageCombinations(4, 3)\n        19\n\n        >>> CountUniquePostageCombinations(2, 2)\n        8\n    */\n    static int CountUniquePostageCombinations(int threeCentStamps, int fiveCentStamps)",
      "zh": "using System;\nusing System.Collections.Generic;\nusing System.Diagnostics;\n\nclass Program\n{\n/* 计算使用给定数量的3美分和5美分邮票可以创建的唯一邮资值的数量。\n        参数:\n        threeCentStamps - 可用的3美分邮票数量\n        fiveCentStamps - 可用的5美分邮票数量\n\n        返回:\n        可以创建的唯一邮资值的数量。\n\n        示例:\n        >>> CountUniquePostageCombinations(4, 3)\n        19\n\n        >>> CountUniquePostageCombinations(2, 2)\n        8\n    */\n    static int CountUniquePostageCombinations(int threeCentStamps, int fiveCentStamps)",
      "fr": "using System;\nusing System.Collections.Generic;\nusing System.Diagnostics;\n\nclass Program\n{\n/* Calcule le nombre de valeurs d'affranchissement uniques qui peuvent être créées en utilisant un nombre donné de timbres de 3 cents et de 5 cents.\n        Paramètres:\n        threeCentStamps - le nombre de timbres de 3 cents disponibles\n        fiveCentStamps - le nombre de timbres de 5 cents disponibles\n\n        Retourne:\n        Le nombre de valeurs d'affranchissement uniques qui peuvent être créées.\n\n        Exemple:\n        >>> CountUniquePostageCombinations(4, 3)\n        19\n\n        >>> CountUniquePostageCombinations(2, 2)\n        8\n    */\n    static int CountUniquePostageCombinations(int threeCentStamps, int fiveCentStamps)",
      "de": "using System;\nusing System.Collections.Generic;\nusing System.Diagnostics;\n\nclass Program\n{\n/* Berechnet die Anzahl der einzigartigen Portowerte, die mit einer bestimmten Anzahl von 3-Cent- und 5-Cent-Briefmarken erstellt werden können.\n        Parameter:\n        threeCentStamps - die Anzahl der verfügbaren 3-Cent-Briefmarken\n        fiveCentStamps - die Anzahl der verfügbaren 5-Cent-Briefmarken\n\n        Rückgabe:\n        Die Anzahl der einzigartigen Portowerte, die erstellt werden können.\n\n        Beispiel:\n        >>> CountUniquePostageCombinations(4, 3)\n        19\n\n        >>> CountUniquePostageCombinations(2, 2)\n        8\n    */\n    static int CountUniquePostageCombinations(int threeCentStamps, int fiveCentStamps)",
      "ha": "using System;\nusing System.Collections.Generic;\nusing System.Diagnostics;\n\nclass Program\n{\n/* Lissafa adadin ƙimar wasiku na musamman da za a iya ƙirƙira ta amfani da adadin tambarin wasiku na 3-cent da 5-cent da aka bayar.\n        Sigogi:\n        threeCentStamps - adadin tambarin wasiku na 3-cent da ake da su\n        fiveCentStamps - adadin tambarin wasiku na 5-cent da ake da su\n\n        Komawa:\n        Adadin ƙimar wasiku na musamman da za a iya ƙirƙira.\n\n        Misali:\n        >>> CountUniquePostageCombinations(4, 3)\n        19\n\n        >>> CountUniquePostageCombinations(2, 2)\n        8\n    */\n    static int CountUniquePostageCombinations(int threeCentStamps, int fiveCentStamps)",
      "hi": "using System;\nusing System.Collections.Generic;\nusing System.Diagnostics;\n\nclass Program\n{\n/* यह गणना करता है कि 3-सेंट और 5-सेंट डाक टिकटों की एक निश्चित संख्या का उपयोग करके कितने अद्वितीय डाक मूल्य बनाए जा सकते हैं।\n        पैरामीटर्स:\n        threeCentStamps - उपलब्ध 3-सेंट डाक टिकटों की संख्या\n        fiveCentStamps - उपलब्ध 5-सेंट डाक टिकटों की संख्या\n\n        रिटर्न करता है:\n        अद्वितीय डाक मूल्यों की संख्या जो बनाई जा सकती है।\n\n        उदाहरण:\n        >>> CountUniquePostageCombinations(4, 3)\n        19\n\n        >>> CountUniquePostageCombinations(2, 2)\n        8\n    */\n    static int CountUniquePostageCombinations(int threeCentStamps, int fiveCentStamps)",
      "hu": "using System;\nusing System.Collections.Generic;\nusing System.Diagnostics;\n\nclass Program\n{\n/* Kiszámítja az egyedi postai értékek számát, amelyeket adott számú 3 centes és 5 centes bélyeggel lehet létrehozni.\n        Paraméterek:\n        threeCentStamps - a rendelkezésre álló 3 centes bélyegek száma\n        fiveCentStamps - a rendelkezésre álló 5 centes bélyegek száma\n\n        Visszatérési érték:\n        Az egyedi postai értékek száma, amelyeket létre lehet hozni.\n\n        Példa:\n        >>> CountUniquePostageCombinations(4, 3)\n        19\n\n        >>> CountUniquePostageCombinations(2, 2)\n        8\n    */\n    static int CountUniquePostageCombinations(int threeCentStamps, int fiveCentStamps)"
    },
    "prompt_bertscore": {
      "sq": "0.988470896793592",
      "hy": "0.9814924156166932",
      "bn": "0.9731950287097229",
      "bg": "0.9874791353010848",
      "zh": "0.9873164570190173",
      "fr": "1",
      "de": "0.9906923789750862",
      "ha": "0.9898235696884395",
      "hi": "0.968111878628659",
      "hu": "0.9902750565445319"
    },
    "canonical_solution": "   {\n\n        HashSet<int> uniqueValues = new HashSet<int>();\n\n        for (int i = 0; i <= threeCentStamps; i++)\n        {\n            for (int j = 0; j <= fiveCentStamps; j++)\n            {\n                int postageValue = 3 * i + 5 * j;\n                uniqueValues.Add(postageValue);\n            }\n        }\n\n        // Subtract 1 to exclude the value 0 (no stamps used)\n        return uniqueValues.Count - 1;\n    }",
    "instruction": {
      "en": "Write a C# function `static int CountUniquePostageCombinations(int threeCentStamps, int fiveCentStamps)` to solve the following problem:\nCalculates the number of unique postage values that can be created using a given number of 3-cent and 5-cent stamps.\n        Parameters:\n        threeCentStamps - the number of 3-cent stamps available\n        fiveCentStamps - the number of 5-cent stamps available\n\n        Returns:\n        The number of unique postage values that can be created.\n\n        Example:\n        >>> CountUniquePostageCombinations(4, 3)\n        19\n\n        >>> CountUniquePostageCombinations(2, 2)\n        8",
      "sq": "Shkruani një funksion në C# `static int CountUniquePostageCombinations(int threeCentStamps, int fiveCentStamps)` për të zgjidhur problemin në vijim:\nLlogarit numrin e vlerave unike të pullave postare që mund të krijohen duke përdorur një numër të caktuar pullash prej 3-cent dhe 5-cent.\n        \n        Parametrat:\n        threeCentStamps - numri i pullave prej 3-cent në dispozicion\n        fiveCentStamps - numri i pullave prej 5-cent në dispozicion\n\n        Kthen:\n        Numri i vlerave unike të pullave postare që mund të krijohen.\n\n        Shembull:\n        >>> CountUniquePostageCombinations(4, 3)\n        19\n\n        >>> CountUniquePostageCombinations(2, 2)\n        8",
      "hy": "C# ֆունկցիա `static int CountUniquePostageCombinations(int threeCentStamps, int fiveCentStamps)` գրեք հետևյալ խնդիրը լուծելու համար:\nՀաշվում է եզակի փոստային արժեքների քանակը, որոնք կարող են ստեղծվել 3-ցենտանոց և 5-ցենտանոց նամականիշների տրված քանակով:\n        Պարամետրեր:\n        threeCentStamps - առկա 3-ցենտանոց նամականիշների քանակը\n        fiveCentStamps - առկա 5-ցենտանոց նամականիշների քանակը\n\n        Վերադարձնում է:\n        Եզակի փոստային արժեքների քանակը, որոնք կարող են ստեղծվել:\n\n        Օրինակ:\n        >>> CountUniquePostageCombinations(4, 3)\n        19\n\n        >>> CountUniquePostageCombinations(2, 2)\n        8",
      "bn": "C# ফাংশন `static int CountUniquePostageCombinations(int threeCentStamps, int fiveCentStamps)` লিখুন নিম্নলিখিত সমস্যার সমাধানের জন্য:\nএকটি প্রদত্ত সংখ্যক 3-সেন্ট এবং 5-সেন্ট স্ট্যাম্প ব্যবহার করে তৈরি করা যেতে পারে এমন অনন্য ডাকমূল্যের সংখ্যা গণনা করে।\n        প্যারামিটারসমূহ:\n        threeCentStamps - উপলব্ধ 3-সেন্ট স্ট্যাম্পের সংখ্যা\n        fiveCentStamps - উপলব্ধ 5-সেন্ট স্ট্যাম্পের সংখ্যা\n\n        রিটার্ন করে:\n        তৈরি করা যেতে পারে এমন অনন্য ডাকমূল্যের সংখ্যা।\n\n        উদাহরণ:\n        >>> CountUniquePostageCombinations(4, 3)\n        19\n\n        >>> CountUniquePostageCombinations(2, 2)\n        8",
      "bg": "Напишете C# функция `static int CountUniquePostageCombinations(int threeCentStamps, int fiveCentStamps)` за решаване на следния проблем:\nИзчислява броя на уникалните стойности за пощенски марки, които могат да бъдат създадени с даден брой 3-центови и 5-центови марки.\n        Параметри:\n        threeCentStamps - броят на наличните 3-центови марки\n        fiveCentStamps - броят на наличните 5-центови марки\n\n        Връща:\n        Броят на уникалните стойности за пощенски марки, които могат да бъдат създадени.\n\n        Пример:\n        >>> CountUniquePostageCombinations(4, 3)\n        19\n\n        >>> CountUniquePostageCombinations(2, 2)\n        8",
      "zh": "编写一个 C# 函数 `static int CountUniquePostageCombinations(int threeCentStamps, int fiveCentStamps)` 来解决以下问题：\n计算使用给定数量的3美分和5美分邮票可以创建的唯一邮资值的数量。\n        \n        参数：\n        threeCentStamps - 可用的3美分邮票数量\n        fiveCentStamps - 可用的5美分邮票数量\n\n        返回：\n        可以创建的唯一邮资值的数量。\n\n        示例：\n        >>> CountUniquePostageCombinations(4, 3)\n        19\n\n        >>> CountUniquePostageCombinations(2, 2)\n        8",
      "fr": "Écrire une fonction C# `static int CountUniquePostageCombinations(int threeCentStamps, int fiveCentStamps)` pour résoudre le problème suivant :\nCalcule le nombre de valeurs d'affranchissement uniques qui peuvent être créées en utilisant un nombre donné de timbres de 3 cents et de 5 cents.\n        Paramètres :\n        threeCentStamps - le nombre de timbres de 3 cents disponibles\n        fiveCentStamps - le nombre de timbres de 5 cents disponibles\n\n        Renvoie :\n        Le nombre de valeurs d'affranchissement uniques qui peuvent être créées.\n\n        Exemple :\n        >>> CountUniquePostageCombinations(4, 3)\n        19\n\n        >>> CountUniquePostageCombinations(2, 2)\n        8",
      "de": "Schreiben Sie eine C#-Funktion `static int CountUniquePostageCombinations(int threeCentStamps, int fiveCentStamps)`, um das folgende Problem zu lösen:\nBerechnet die Anzahl der einzigartigen Portowerte, die mit einer gegebenen Anzahl von 3-Cent- und 5-Cent-Briefmarken erstellt werden können.\n        \n        Parameter:\n        threeCentStamps - die Anzahl der verfügbaren 3-Cent-Briefmarken\n        fiveCentStamps - die Anzahl der verfügbaren 5-Cent-Briefmarken\n\n        Rückgabe:\n        Die Anzahl der einzigartigen Portowerte, die erstellt werden können.\n\n        Beispiel:\n        >>> CountUniquePostageCombinations(4, 3)\n        19\n\n        >>> CountUniquePostageCombinations(2, 2)\n        8",
      "ha": "Rubuta aikin C# `static int CountUniquePostageCombinations(int threeCentStamps, int fiveCentStamps)` don warware matsalar mai zuwa:\nƘididdige adadin ƙimar hatimi na musamman da za a iya ƙirƙira ta amfani da adadin hatimi na 3-cent da 5-cent da aka bayar.\n        \n        Sigogi:\n        threeCentStamps - adadin hatimi na 3-cent da ake da su\n        fiveCentStamps - adadin hatimi na 5-cent da ake da su\n\n        Dawowa:\n        Adadin ƙimar hatimi na musamman da za a iya ƙirƙira.\n\n        Misali:\n        >>> CountUniquePostageCombinations(4, 3)\n        19\n\n        >>> CountUniquePostageCombinations(2, 2)\n        8",
      "hi": "C# फ़ंक्शन `static int CountUniquePostageCombinations(int threeCentStamps, int fiveCentStamps)` लिखें ताकि निम्नलिखित समस्या का समाधान किया जा सके:\nयह गणना करता है कि दिए गए 3-सेंट और 5-सेंट टिकटों की संख्या का उपयोग करके कितने अद्वितीय डाक मूल्य बनाए जा सकते हैं।\n        पैरामीटर्स:\n        threeCentStamps - उपलब्ध 3-सेंट टिकटों की संख्या\n        fiveCentStamps - उपलब्ध 5-सेंट टिकटों की संख्या\n\n        रिटर्न करता है:\n        अद्वितीय डाक मूल्यों की संख्या जो बनाए जा सकते हैं।\n\n        उदाहरण:\n        >>> CountUniquePostageCombinations(4, 3)\n        19\n\n        >>> CountUniquePostageCombinations(2, 2)\n        8",
      "hu": "Írj egy C# függvényt `static int CountUniquePostageCombinations(int threeCentStamps, int fiveCentStamps)` a következő probléma megoldására:\nKiszámítja az egyedi postai értékek számát, amelyeket meg lehet alkotni adott számú 3-centes és 5-centes bélyeggel.\n        \n        Paraméterek:\n        threeCentStamps - a rendelkezésre álló 3-centes bélyegek száma\n        fiveCentStamps - a rendelkezésre álló 5-centes bélyegek száma\n\n        Visszatérési érték:\n        Az egyedi postai értékek száma, amelyeket létre lehet hozni.\n\n        Példa:\n        >>> CountUniquePostageCombinations(4, 3)\n        19\n\n        >>> CountUniquePostageCombinations(2, 2)\n        8"
    },
    "instruction_bertscore": {
      "sq": "0.9902609537874784",
      "hy": "0.9681047279349418",
      "bn": "0.9809767711475267",
      "bg": "0.994397828733292",
      "zh": "0.9868014084409937",
      "fr": "0.9988264917088459",
      "de": "0.9920277710267837",
      "ha": "0.9829269242285272",
      "hi": "0.9715603006738057",
      "hu": "0.9895772680159564"
    },
    "level": "easy",
    "test": "    static void Main()\n    {\n        Debug.Assert(CountUniquePostageCombinations(4, 3) == 19); \n        Debug.Assert(CountUniquePostageCombinations(2, 2) == 8); \n        Debug.Assert(CountUniquePostageCombinations(3, 1) == 7);\n        Debug.Assert(CountUniquePostageCombinations(1, 3) == 7); \n\n    }\n}\n",
    "entry_point": "CountUniquePostageCombinations",
    "signature": "static int CountUniquePostageCombinations(int threeCentStamps, int fiveCentStamps)",
    "docstring": {
      "en": "Calculates the number of unique postage values that can be created using a given number of 3-cent and 5-cent stamps.\n        Parameters:\n        threeCentStamps - the number of 3-cent stamps available\n        fiveCentStamps - the number of 5-cent stamps available\n\n        Returns:\n        The number of unique postage values that can be created.\n\n        Example:\n        >>> CountUniquePostageCombinations(4, 3)\n        19\n\n        >>> CountUniquePostageCombinations(2, 2)\n        8",
      "sq": "Llogarit numrin e vlerave unike të pullave që mund të krijohen duke përdorur një numër të caktuar pullash prej 3 cent dhe 5 cent.\n        Parametrat:\n        threeCentStamps - numri i pullave prej 3 cent që janë në dispozicion\n        fiveCentStamps - numri i pullave prej 5 cent që janë në dispozicion\n\n        Kthen:\n        Numri i vlerave unike të pullave që mund të krijohen.\n\n        Shembull:\n        >>> CountUniquePostageCombinations(4, 3)\n        19\n\n        >>> CountUniquePostageCombinations(2, 2)\n        8",
      "hy": "Հաշվում է եզակի փոստային արժեքների քանակը, որոնք կարող են ստեղծվել օգտագործելով տրված քանակությամբ 3-ցենտանոց և 5-ցենտանոց նամականիշներ:\n        \n        Պարամետրեր:\n        threeCentStamps - առկա 3-ցենտանոց նամականիշների քանակը\n        fiveCentStamps - առկա 5-ցենտանոց նամականիշների քանակը\n\n        Վերադարձնում է:\n        Եզակի փոստային արժեքների քանակը, որոնք կարող են ստեղծվել:\n\n        Օրինակ:\n        >>> CountUniquePostageCombinations(4, 3)\n        19\n\n        >>> CountUniquePostageCombinations(2, 2)\n        8",
      "bn": "অনন্য ডাকমাশুল মানের সংখ্যা গণনা করে যা একটি প্রদত্ত সংখ্যক ৩-সেন্ট এবং ৫-সেন্ট স্ট্যাম্প ব্যবহার করে তৈরি করা যেতে পারে।\n        প্যারামিটারসমূহ:\n        threeCentStamps - উপলব্ধ ৩-সেন্ট স্ট্যাম্পের সংখ্যা\n        fiveCentStamps - উপলব্ধ ৫-সেন্ট স্ট্যাম্পের সংখ্যা\n\n        রিটার্নস:\n        অনন্য ডাকমাশুল মানের সংখ্যা যা তৈরি করা যেতে পারে।\n\n        উদাহরণ:\n        >>> CountUniquePostageCombinations(4, 3)\n        19\n\n        >>> CountUniquePostageCombinations(2, 2)\n        8",
      "bg": "Изчислява броя на уникалните стойности на пощенски марки, които могат да бъдат създадени с даден брой 3-центови и 5-центови марки.\n        Параметри:\n        threeCentStamps - броят на наличните 3-центови марки\n        fiveCentStamps - броят на наличните 5-центови марки\n\n        Връща:\n        Броят на уникалните стойности на пощенски марки, които могат да бъдат създадени.\n\n        Пример:\n        >>> CountUniquePostageCombinations(4, 3)\n        19\n\n        >>> CountUniquePostageCombinations(2, 2)\n        8",
      "zh": "计算可以使用给定数量的3美分和5美分邮票创建的唯一邮资值的数量。\n        参数：\n        threeCentStamps - 可用的3美分邮票的数量\n        fiveCentStamps - 可用的5美分邮票的数量\n\n        返回：\n        可以创建的唯一邮资值的数量。\n\n        示例：\n        >>> CountUniquePostageCombinations(4, 3)\n        19\n\n        >>> CountUniquePostageCombinations(2, 2)\n        8",
      "fr": "Calcule le nombre de valeurs d'affranchissement uniques qui peuvent être créées en utilisant un nombre donné de timbres de 3 cents et de 5 cents.\n        Paramètres:\n        threeCentStamps - le nombre de timbres de 3 cents disponibles\n        fiveCentStamps - le nombre de timbres de 5 cents disponibles\n\n        Renvoie:\n        Le nombre de valeurs d'affranchissement uniques qui peuvent être créées.\n\n        Exemple:\n        >>> CountUniquePostageCombinations(4, 3)\n        19\n\n        >>> CountUniquePostageCombinations(2, 2)\n        8",
      "de": "Berechnet die Anzahl der einzigartigen Portowerte, die mit einer gegebenen Anzahl von 3-Cent- und 5-Cent-Briefmarken erstellt werden können.\n        \n        Parameter:\n        threeCentStamps - die Anzahl der verfügbaren 3-Cent-Briefmarken\n        fiveCentStamps - die Anzahl der verfügbaren 5-Cent-Briefmarken\n\n        Rückgabewert:\n        Die Anzahl der einzigartigen Portowerte, die erstellt werden können.\n\n        Beispiel:\n        >>> CountUniquePostageCombinations(4, 3)\n        19\n\n        >>> CountUniquePostageCombinations(2, 2)\n        8",
      "ha": "Yana lissafin adadin ƙimar wasiƙa na musamman da za a iya ƙirƙira ta amfani da adadin tambarin wasiƙa na kudi 3 da 5 da aka bayar.\n        \nArgs:\n        threeCentStamps - adadin tambarin wasiƙa na kudi 3 da ake da su\n        fiveCentStamps - adadin tambarin wasiƙa na kudi 5 da ake da su\n\nReturns:\n        Adadin ƙimar wasiƙa na musamman da za a iya ƙirƙira.\n\nExample:\n        >>> CountUniquePostageCombinations(4, 3)\n        19\n\n        >>> CountUniquePostageCombinations(2, 2)\n        8",
      "hi": "यह गणना करता है कि 3-सेंट और 5-सेंट डाक टिकटों की एक निश्चित संख्या का उपयोग करके कितने अद्वितीय डाक मूल्य बनाए जा सकते हैं।\n        पैरामीटर्स:\n        threeCentStamps - उपलब्ध 3-सेंट टिकटों की संख्या\n        fiveCentStamps - उपलब्ध 5-सेंट टिकटों की संख्या\n\n        रिटर्न्स:\n        अद्वितीय डाक मूल्य की संख्या जो बनाई जा सकती है।\n\n        उदाहरण:\n        >>> CountUniquePostageCombinations(4, 3)\n        19\n\n        >>> CountUniquePostageCombinations(2, 2)\n        8",
      "hu": "Számítja az egyedi postai értékek számát, amelyeket létre lehet hozni adott számú 3 centes és 5 centes bélyeggel.\n        \n        Paraméterek:\n        threeCentStamps - a rendelkezésre álló 3 centes bélyegek száma\n        fiveCentStamps - a rendelkezésre álló 5 centes bélyegek száma\n\n        Visszatér:\n        Az egyedi postai értékek száma, amelyeket létre lehet hozni.\n\n        Példa:\n        >>> CountUniquePostageCombinations(4, 3)\n        19\n\n        >>> CountUniquePostageCombinations(2, 2)\n        8"
    },
    "docstring_bertscore": {
      "sq": "0.981707532319354",
      "hy": "0.987668430054211",
      "bn": "0.9710232041234874",
      "bg": "0.9830480887609585",
      "zh": "0.9831646847946259",
      "fr": "0.9972247363161806",
      "de": "0.986489558742769",
      "ha": "0.9856449823626087",
      "hi": "0.9840944736082503",
      "hu": "0.9923000932791826"
    }
  },
  {
    "task_id": "C#/21",
    "prompt": {
      "en": "using System;\nusing System.Collections.Generic;\nusing System.Diagnostics;\n\nclass Program\n{\n/* Determines if a sequence has \"Jolly Jumps\" where the absolute differences between adjacent elements, \n   when sorted, form a continuous sequence from 1 to (length of sequence - 1).\n   A sequence with a single element is always considered jolly.\n   \n        Examples:\n        >>> IsSequenceJolly(new int[] {1, 4, 2, 3})\n        \"Jolly\"\n        \n        >>> IsSequenceJolly(new int[] {1, 3})\n        \"Not Jolly\"\n\n        >>> IsSequenceJolly(new int[] {5})\n        \"Jolly\"\n    */\n    static string IsSequenceJolly(int[] sequence)",
      "sq": "using System;\nusing System.Collections.Generic;\nusing System.Diagnostics;\n\nclass Program\n{\n/* Përcakton nëse një sekuencë ka \"Jolly Jumps\" ku diferencat absolute midis elementeve ngjitur, \n   kur janë të renditura, formojnë një sekuencë të vazhdueshme nga 1 deri te (gjatësia e sekuencës - 1).\n   Një sekuencë me një element të vetëm gjithmonë konsiderohet jolly.\n   \n        Shembuj:\n        >>> IsSequenceJolly(new int[] {1, 4, 2, 3})\n        \"Jolly\"\n        \n        >>> IsSequenceJolly(new int[] {1, 3})\n        \"Not Jolly\"\n\n        >>> IsSequenceJolly(new int[] {5})\n        \"Jolly\"\n    */\n    static string IsSequenceJolly(int[] sequence)",
      "hy": "using System;\nusing System.Collections.Generic;\nusing System.Diagnostics;\n\nclass Program\n{\n/* Որոշում է՝ արդյոք հաջորդականությունը ունի \"Jolly Jumps\", որտեղ հարևան տարրերի միջև բացարձակ տարբերությունները,\n   երբ դասավորված են, ձևավորում են շարունակական հաջորդականություն 1-ից մինչև (հաջորդականության երկարությունը - 1):\n   Միայն մեկ տարր պարունակող հաջորդականությունը միշտ համարվում է jolly:\n   \n        Օրինակներ:\n        >>> IsSequenceJolly(new int[] {1, 4, 2, 3})\n        \"Jolly\"\n        \n        >>> IsSequenceJolly(new int[] {1, 3})\n        \"Not Jolly\"\n\n        >>> IsSequenceJolly(new int[] {5})\n        \"Jolly\"\n    */\n    static string IsSequenceJolly(int[] sequence)",
      "bn": "using System;\nusing System.Collections.Generic;\nusing System.Diagnostics;\n\nclass Program\n{\n/* নির্ধারণ করে যে একটি সিকোয়েন্সে \"Jolly Jumps\" আছে কিনা যেখানে সংলগ্ন উপাদানগুলির মধ্যে পার্থক্যগুলির মান,\n   যখন সাজানো হয়, একটি ধারাবাহিক সিকোয়েন্স তৈরি করে 1 থেকে (সিকোয়েন্সের দৈর্ঘ্য - 1) পর্যন্ত।\n   একটি উপাদান বিশিষ্ট সিকোয়েন্স সর্বদা জলি হিসাবে বিবেচিত হয়।\n   \n        উদাহরণ:\n        >>> IsSequenceJolly(new int[] {1, 4, 2, 3})\n        \"Jolly\"\n        \n        >>> IsSequenceJolly(new int[] {1, 3})\n        \"Not Jolly\"\n\n        >>> IsSequenceJolly(new int[] {5})\n        \"Jolly\"\n    */\n    static string IsSequenceJolly(int[] sequence)",
      "bg": "using System;\nusing System.Collections.Generic;\nusing System.Diagnostics;\n\nclass Program\n{\n/* Определя дали една последователност има \"Jolly Jumps\", където абсолютните разлики между съседни елементи,\n   когато са сортирани, образуват непрекъсната последователност от 1 до (дължината на последователността - 1).\n   Последователност с един елемент винаги се счита за jolly.\n   \n        Примери:\n        >>> IsSequenceJolly(new int[] {1, 4, 2, 3})\n        \"Jolly\"\n        \n        >>> IsSequenceJolly(new int[] {1, 3})\n        \"Not Jolly\"\n\n        >>> IsSequenceJolly(new int[] {5})\n        \"Jolly\"\n    */\n    static string IsSequenceJolly(int[] sequence)",
      "zh": "using System;\nusing System.Collections.Generic;\nusing System.Diagnostics;\n\nclass Program\n{\n/* 判断一个序列是否具有“Jolly Jumps”特性，即相邻元素之间的绝对差值在排序后形成一个从1到（序列长度-1）的连续序列。\n   只有一个元素的序列总是被认为是jolly。\n   \n        例子：\n        >>> IsSequenceJolly(new int[] {1, 4, 2, 3})\n        \"Jolly\"\n        \n        >>> IsSequenceJolly(new int[] {1, 3})\n        \"Not Jolly\"\n\n        >>> IsSequenceJolly(new int[] {5})\n        \"Jolly\"\n    */\n    static string IsSequenceJolly(int[] sequence)",
      "fr": "using System;\nusing System.Collections.Generic;\nusing System.Diagnostics;\n\nclass Program\n{\n/* Détermine si une séquence a des \"Jolly Jumps\" où les différences absolues entre les éléments adjacents, \n   une fois triées, forment une séquence continue de 1 à (longueur de la séquence - 1).\n   Une séquence avec un seul élément est toujours considérée comme jolly.\n   \n        Exemples :\n        >>> IsSequenceJolly(new int[] {1, 4, 2, 3})\n        \"Jolly\"\n        \n        >>> IsSequenceJolly(new int[] {1, 3})\n        \"Not Jolly\"\n\n        >>> IsSequenceJolly(new int[] {5})\n        \"Jolly\"\n    */\n    static string IsSequenceJolly(int[] sequence)",
      "de": "using System;\nusing System.Collections.Generic;\nusing System.Diagnostics;\n\nclass Program\n{\n/* Bestimmt, ob eine Sequenz \"Jolly Jumps\" hat, wobei die absoluten Unterschiede zwischen benachbarten Elementen,\n   wenn sortiert, eine kontinuierliche Sequenz von 1 bis (Länge der Sequenz - 1) bilden.\n   Eine Sequenz mit einem einzigen Element wird immer als jolly betrachtet.\n   \n        Beispiele:\n        >>> IsSequenceJolly(new int[] {1, 4, 2, 3})\n        \"Jolly\"\n        \n        >>> IsSequenceJolly(new int[] {1, 3})\n        \"Not Jolly\"\n\n        >>> IsSequenceJolly(new int[] {5})\n        \"Jolly\"\n    */\n    static string IsSequenceJolly(int[] sequence)",
      "ha": "using System;\nusing System.Collections.Generic;\nusing System.Diagnostics;\n\nclass Program\n{\n/* Yana tantancewa idan jerin yana da \"Jolly Jumps\" inda bambance-bambancen darajoji tsakanin abubuwan dake makwabtaka, \n   idan an jera su, suna samar da jere mai ci gaba daga 1 zuwa (tsawon jerin - 1).\n   Jerin da ke da abu guda ana ɗauka koyaushe a matsayin jolly.\n   \n        Misalai:\n        >>> IsSequenceJolly(new int[] {1, 4, 2, 3})\n        \"Jolly\"\n        \n        >>> IsSequenceJolly(new int[] {1, 3})\n        \"Not Jolly\"\n\n        >>> IsSequenceJolly(new int[] {5})\n        \"Jolly\"\n    */\n    static string IsSequenceJolly(int[] sequence)",
      "hi": "using System;\nusing System.Collections.Generic;\nusing System.Diagnostics;\n\nclass Program\n{\n/* यह निर्धारित करता है कि क्या एक अनुक्रम में \"Jolly Jumps\" हैं जहाँ आसन्न तत्वों के बीच के परिमाणात्मक अंतर, \n   जब क्रमबद्ध होते हैं, तो 1 से (अनुक्रम की लंबाई - 1) तक का एक सतत अनुक्रम बनाते हैं।\n   एकल तत्व वाला अनुक्रम हमेशा जॉली माना जाता है।\n   \n        उदाहरण:\n        >>> IsSequenceJolly(new int[] {1, 4, 2, 3})\n        \"Jolly\"\n        \n        >>> IsSequenceJolly(new int[] {1, 3})\n        \"Not Jolly\"\n\n        >>> IsSequenceJolly(new int[] {5})\n        \"Jolly\"\n    */\n    static string IsSequenceJolly(int[] sequence)",
      "hu": "using System;\nusing System.Collections.Generic;\nusing System.Diagnostics;\n\nclass Program\n{\n/* Meghatározza, hogy egy sorozat \"Jolly Jumps\"-t tartalmaz-e, ahol a szomszédos elemek közötti abszolút különbségek, \n   ha sorba rendezzük őket, egy folytonos sorozatot alkotnak 1-től (a sorozat hossza - 1)-ig.\n   Egyetlen elemből álló sorozat mindig jolly-nak tekintendő.\n   \n        Példák:\n        >>> IsSequenceJolly(new int[] {1, 4, 2, 3})\n        \"Jolly\"\n        \n        >>> IsSequenceJolly(new int[] {1, 3})\n        \"Not Jolly\"\n\n        >>> IsSequenceJolly(new int[] {5})\n        \"Jolly\"\n    */\n    static string IsSequenceJolly(int[] sequence)"
    },
    "prompt_bertscore": {
      "sq": "0.9971462773156717",
      "hy": "0.9873051350872982",
      "bn": "0.9930137722382409",
      "bg": "0.9898686587849345",
      "zh": "0.9704537308210603",
      "fr": "0.994898575923881",
      "de": "0.9928536761511267",
      "ha": "0.9894952336685889",
      "hi": "0.9901322413005678",
      "hu": "0.9811875179818047"
    },
    "canonical_solution": "{\n        if (sequence.Length == 1) return \"Jolly\";\n\n        int[] differences = new int[sequence.Length - 1];\n        for (int i = 0; i < sequence.Length - 1; i++)\n        {\n            differences[i] = Math.Abs(sequence[i] - sequence[i + 1]);\n        }\n\n        Array.Sort(differences);\n        for (int i = 0; i < differences.Length; i++)\n        {\n            if (differences[i] != i + 1) return \"Not Jolly\";\n        }\n\n        return \"Jolly\";\n    }",
    "instruction": {
      "en": "Write a C# function `static string IsSequenceJolly(int[] sequence)` to solve the following problem:\nDetermines if a sequence has \"Jolly Jumps\" where the absolute differences between adjacent elements, \n   when sorted, form a continuous sequence from 1 to (length of sequence - 1).\n   A sequence with a single element is always considered jolly.\n   \n        Examples:\n        >>> IsSequenceJolly(new int[] {1, 4, 2, 3})\n        \"Jolly\"\n        \n        >>> IsSequenceJolly(new int[] {1, 3})\n        \"Not Jolly\"\n\n        >>> IsSequenceJolly(new int[] {5})\n        \"Jolly\"",
      "sq": "Shkruani një funksion në C# `static string IsSequenceJolly(int[] sequence)` për të zgjidhur problemin në vijim:\nPërcakton nëse një sekuencë ka \"Jolly Jumps\" ku diferencat absolute midis elementeve ngjitur, \n   kur renditen, formojnë një sekuencë të vazhdueshme nga 1 deri në (gjatësia e sekuencës - 1).\n   Një sekuencë me një element të vetëm konsiderohet gjithmonë jolly.\n   \n        Shembuj:\n        >>> IsSequenceJolly(new int[] {1, 4, 2, 3})\n        \"Jolly\"\n        \n        >>> IsSequenceJolly(new int[] {1, 3})\n        \"Not Jolly\"\n\n        >>> IsSequenceJolly(new int[] {5})\n        \"Jolly\"",
      "hy": "Գրեք C# ֆունկցիա `static string IsSequenceJolly(int[] sequence)` հետևյալ խնդիրը լուծելու համար:\nՈրոշում է, արդյոք հաջորդականությունը ունի \"Jolly Jumps\", որտեղ հարևան տարրերի միջև բացարձակ տարբերությունները, \n   երբ դասավորված են, ձևավորում են շարունակական հաջորդականություն 1-ից մինչև (հաջորդականության երկարությունը - 1):\n   Միայն մեկ տարր պարունակող հաջորդականությունը միշտ համարվում է jolly:\n   \n        Օրինակներ:\n        >>> IsSequenceJolly(new int[] {1, 4, 2, 3})\n        \"Jolly\"\n        \n        >>> IsSequenceJolly(new int[] {1, 3})\n        \"Not Jolly\"\n\n        >>> IsSequenceJolly(new int[] {5})\n        \"Jolly\"",
      "bn": "C# ফাংশন `static string IsSequenceJolly(int[] sequence)` লিখুন নিম্নলিখিত সমস্যার সমাধানের জন্য:\nনির্ধারণ করে যদি একটি সিকোয়েন্সে \"Jolly Jumps\" থাকে যেখানে সংলগ্ন উপাদানগুলির মধ্যে পার্থক্যের মান, \n   যখন সাজানো হয়, একটি ধারাবাহিক সিকোয়েন্স গঠন করে 1 থেকে (সিকোয়েন্সের দৈর্ঘ্য - 1) পর্যন্ত।\n   একটি একক উপাদান বিশিষ্ট সিকোয়েন্স সর্বদা জলি হিসাবে বিবেচিত হয়।\n\n        উদাহরণসমূহ:\n        >>> IsSequenceJolly(new int[] {1, 4, 2, 3})\n        \"Jolly\"\n        \n        >>> IsSequenceJolly(new int[] {1, 3})\n        \"Not Jolly\"\n\n        >>> IsSequenceJolly(new int[] {5})\n        \"Jolly\"",
      "bg": "Напишете C# функция `static string IsSequenceJolly(int[] sequence)` за решаване на следния проблем:\nОпределя дали една последователност има \"Jolly Jumps\", където абсолютните разлики между съседни елементи, \n   когато са сортирани, образуват непрекъсната последователност от 1 до (дължина на последователността - 1).\n   Последователност с един елемент винаги се счита за jolly.\n   \n        Примери:\n        >>> IsSequenceJolly(new int[] {1, 4, 2, 3})\n        \"Jolly\"\n        \n        >>> IsSequenceJolly(new int[] {1, 3})\n        \"Not Jolly\"\n\n        >>> IsSequenceJolly(new int[] {5})\n        \"Jolly\"",
      "zh": "编写一个 C# 函数 `static string IsSequenceJolly(int[] sequence)` 来解决以下问题：\n确定一个序列是否具有“Jolly Jumps”，即相邻元素之间的绝对差在排序后形成一个从 1 到（序列长度 - 1）的连续序列。\n只有一个元素的序列始终被认为是 jolly。\n\n        示例：\n        >>> IsSequenceJolly(new int[] {1, 4, 2, 3})\n        \"Jolly\"\n        \n        >>> IsSequenceJolly(new int[] {1, 3})\n        \"Not Jolly\"\n\n        >>> IsSequenceJolly(new int[] {5})\n        \"Jolly\"",
      "fr": "Écrire une fonction C# `static string IsSequenceJolly(int[] sequence)` pour résoudre le problème suivant :  \nDétermine si une séquence a des \"Jolly Jumps\" où les différences absolues entre les éléments adjacents,  \nlorsqu'elles sont triées, forment une séquence continue de 1 à (longueur de la séquence - 1).  \nUne séquence avec un seul élément est toujours considérée comme jolly.\n   \n        Exemples :\n        >>> IsSequenceJolly(new int[] {1, 4, 2, 3})\n        \"Jolly\"\n        \n        >>> IsSequenceJolly(new int[] {1, 3})\n        \"Not Jolly\"\n\n        >>> IsSequenceJolly(new int[] {5})\n        \"Jolly\"",
      "de": "Schreiben Sie eine C#-Funktion `static string IsSequenceJolly(int[] sequence)`, um das folgende Problem zu lösen:\nBestimmt, ob eine Sequenz \"Jolly Jumps\" hat, bei denen die absoluten Unterschiede zwischen benachbarten Elementen, \n   wenn sie sortiert sind, eine kontinuierliche Sequenz von 1 bis (Länge der Sequenz - 1) bilden.\n   Eine Sequenz mit einem einzigen Element wird immer als jolly betrachtet.\n   \n        Beispiele:\n        >>> IsSequenceJolly(new int[] {1, 4, 2, 3})\n        \"Jolly\"\n        \n        >>> IsSequenceJolly(new int[] {1, 3})\n        \"Not Jolly\"\n\n        >>> IsSequenceJolly(new int[] {5})\n        \"Jolly\"",
      "ha": "Rubuta aikin C# `static string IsSequenceJolly(int[] sequence)` don warware matsalar mai zuwa:\nYana tantance idan jerin yana da \"Jolly Jumps\" inda bambance-bambancen darajar tsakanin abubuwan kusa, \n   idan aka jera su, suna samar da jerin ci gaba daga 1 zuwa (tsawon jerin - 1).\n   Jerin da ke da abu guda ana daukarsa koyaushe a matsayin jolly.\n   \n        Misalai:\n        >>> IsSequenceJolly(new int[] {1, 4, 2, 3})\n        \"Jolly\"\n        \n        >>> IsSequenceJolly(new int[] {1, 3})\n        \"Not Jolly\"\n\n        >>> IsSequenceJolly(new int[] {5})\n        \"Jolly\"",
      "hi": "C# फ़ंक्शन `static string IsSequenceJolly(int[] sequence)` लिखें ताकि निम्नलिखित समस्या का समाधान किया जा सके:\nयह निर्धारित करता है कि कोई अनुक्रम \"Jolly Jumps\" है या नहीं, जहाँ आसन्न तत्वों के बीच के परिमाणात्मक अंतर, \n   जब क्रमबद्ध होते हैं, तो 1 से (अनुक्रम की लंबाई - 1) तक का एक सतत अनुक्रम बनाते हैं।\n   एकल तत्व वाला अनुक्रम हमेशा जॉली माना जाता है।\n   \n        उदाहरण:\n        >>> IsSequenceJolly(new int[] {1, 4, 2, 3})\n        \"Jolly\"\n        \n        >>> IsSequenceJolly(new int[] {1, 3})\n        \"Not Jolly\"\n\n        >>> IsSequenceJolly(new int[] {5})\n        \"Jolly\"",
      "hu": "Írj egy C# függvényt `static string IsSequenceJolly(int[] sequence)` a következő probléma megoldására:\nMegállapítja, hogy egy sorozat rendelkezik-e \"Jolly Jumps\"-szal, ahol a szomszédos elemek közötti abszolút különbségek, \n   ha sorba rendezzük, egy folytonos sorozatot alkotnak 1-től (a sorozat hossza - 1)-ig.\n   Egyetlen elemből álló sorozatot mindig jolly-nak tekintünk.\n   \n        Példák:\n        >>> IsSequenceJolly(new int[] {1, 4, 2, 3})\n        \"Jolly\"\n        \n        >>> IsSequenceJolly(new int[] {1, 3})\n        \"Not Jolly\"\n\n        >>> IsSequenceJolly(new int[] {5})\n        \"Jolly\""
    },
    "instruction_bertscore": {
      "sq": "0.9916332910900484",
      "hy": "0.9834936167056197",
      "bn": "0.9727949871223186",
      "bg": "0.9836934388689409",
      "zh": "0.9666374453102371",
      "fr": "0.9928266624193061",
      "de": "0.9945732193597459",
      "ha": "0.9709189231734441",
      "hi": "0.9725196854142043",
      "hu": "0.9829849242997895"
    },
    "level": "middle",
    "test": "    static void Main()\n    {\n\n        Debug.Assert(IsSequenceJolly(new int[] {1, 4, 2, 3}) == \"Jolly\");\n        Debug.Assert(IsSequenceJolly(new int[] {1, 3}) == \"Not Jolly\");\n        Debug.Assert(IsSequenceJolly(new int[] {5}) == \"Jolly\");\n        Debug.Assert(IsSequenceJolly(new int[] {10, 7, 8, 9}) == \"Not Jolly\");\n\n    }\n}",
    "entry_point": "IsSequenceJolly",
    "signature": "static string IsSequenceJolly(int[] sequence)",
    "docstring": {
      "en": "Determines if a sequence has \"Jolly Jumps\" where the absolute differences between adjacent elements, \n   when sorted, form a continuous sequence from 1 to (length of sequence - 1).\n   A sequence with a single element is always considered jolly.\n   \n        Examples:\n        >>> IsSequenceJolly(new int[] {1, 4, 2, 3})\n        \"Jolly\"\n        \n        >>> IsSequenceJolly(new int[] {1, 3})\n        \"Not Jolly\"\n\n        >>> IsSequenceJolly(new int[] {5})\n        \"Jolly\"",
      "sq": "Përcakton nëse një sekuencë ka \"Jolly Jumps\" ku diferencat absolute midis elementeve ngjitur, kur renditen, formojnë një sekuencë të vazhdueshme nga 1 deri në (gjatësia e sekuencës - 1). Një sekuencë me një element të vetëm gjithmonë konsiderohet jolly.\n\n        Shembuj:\n        >>> IsSequenceJolly(new int[] {1, 4, 2, 3})\n        \"Jolly\"\n        \n        >>> IsSequenceJolly(new int[] {1, 3})\n        \"Not Jolly\"\n\n        >>> IsSequenceJolly(new int[] {5})\n        \"Jolly\"",
      "hy": "Հաստատում է, արդյոք հաջորդականությունը ունի \"Jolly Jumps\", որտեղ հարևան տարրերի միջև բացարձակ տարբերությունները, \n   երբ դասավորված են, կազմում են շարունակական հաջորդականություն 1-ից մինչև (հաջորդականության երկարություն - 1):\n   Միայն մեկ տարր պարունակող հաջորդականությունը միշտ համարվում է jolly:\n   \n        Օրինակներ:\n        >>> IsSequenceJolly(new int[] {1, 4, 2, 3})\n        \"Jolly\"\n        \n        >>> IsSequenceJolly(new int[] {1, 3})\n        \"Not Jolly\"\n\n        >>> IsSequenceJolly(new int[] {5})\n        \"Jolly\"",
      "bn": "একটি সিকোয়েন্সে \"Jolly Jumps\" আছে কিনা তা নির্ধারণ করে যেখানে সংলগ্ন উপাদানগুলির মধ্যে পার্থক্যের মান, \n   যখন সাজানো হয়, তখন একটি ধারাবাহিক সিকোয়েন্স গঠন করে 1 থেকে (সিকোয়েন্সের দৈর্ঘ্য - 1) পর্যন্ত।\n   একটি উপাদানযুক্ত সিকোয়েন্স সর্বদা জলি হিসাবে বিবেচিত হয়।\n   \n        উদাহরণসমূহ:\n        >>> IsSequenceJolly(new int[] {1, 4, 2, 3})\n        \"Jolly\"\n        \n        >>> IsSequenceJolly(new int[] {1, 3})\n        \"Not Jolly\"\n\n        >>> IsSequenceJolly(new int[] {5})\n        \"Jolly\"",
      "bg": "Определя дали една последователност има \"Jolly Jumps\", където абсолютните разлики между съседни елементи, когато са сортирани, формират непрекъсната последователност от 1 до (дължина на последователността - 1). Последователност с един елемент винаги се счита за jolly.\n\n        Примери:\n        >>> IsSequenceJolly(new int[] {1, 4, 2, 3})\n        \"Jolly\"\n        \n        >>> IsSequenceJolly(new int[] {1, 3})\n        \"Not Jolly\"\n\n        >>> IsSequenceJolly(new int[] {5})\n        \"Jolly\"",
      "zh": "确定一个序列是否具有“Jolly Jumps”，即相邻元素之间的绝对差值在排序后形成一个从1到（序列长度-1）的连续序列。\n一个只有一个元素的序列总是被认为是jolly的。\n\n        示例：\n        >>> IsSequenceJolly(new int[] {1, 4, 2, 3})\n        \"Jolly\"\n        \n        >>> IsSequenceJolly(new int[] {1, 3})\n        \"Not Jolly\"\n\n        >>> IsSequenceJolly(new int[] {5})\n        \"Jolly\"",
      "fr": "Détermine si une séquence a des \"Jolly Jumps\" où les différences absolues entre les éléments adjacents, \n   lorsqu'elles sont triées, forment une séquence continue de 1 à (longueur de la séquence - 1).\n   Une séquence avec un seul élément est toujours considérée comme jolly.\n   \n        Exemples:\n        >>> IsSequenceJolly(new int[] {1, 4, 2, 3})\n        \"Jolly\"\n        \n        >>> IsSequenceJolly(new int[] {1, 3})\n        \"Not Jolly\"\n\n        >>> IsSequenceJolly(new int[] {5})\n        \"Jolly\"",
      "de": "Bestimmt, ob eine Sequenz \"Jolly Jumps\" hat, bei denen die absoluten Unterschiede zwischen benachbarten Elementen, \n   wenn sie sortiert sind, eine kontinuierliche Sequenz von 1 bis (Länge der Sequenz - 1) bilden.\n   Eine Sequenz mit einem einzigen Element wird immer als jolly betrachtet.\n   \n        Beispiele:\n        >>> IsSequenceJolly(new int[] {1, 4, 2, 3})\n        \"Jolly\"\n        \n        >>> IsSequenceJolly(new int[] {1, 3})\n        \"Not Jolly\"\n\n        >>> IsSequenceJolly(new int[] {5})\n        \"Jolly\"",
      "ha": "Yana tantance ko wata jerin lambobi tana da \"Jolly Jumps\" inda bambance-bambancen darajar lambobi masu makwabtaka, idan an jera su, suna samar da jerin lambobi masu ci gaba daga 1 zuwa (tsawon jerin - 1). \n   Jerin lambobi da ke da abu guda ana daukarsa koyaushe a matsayin jolly.\n   \n        Misalai:\n        >>> IsSequenceJolly(new int[] {1, 4, 2, 3})\n        \"Jolly\"\n        \n        >>> IsSequenceJolly(new int[] {1, 3})\n        \"Not Jolly\"\n\n        >>> IsSequenceJolly(new int[] {5})\n        \"Jolly\"",
      "hi": "यह निर्धारित करता है कि क्या एक अनुक्रम में \"जॉली जंप्स\" हैं जहाँ आसन्न तत्वों के बीच के निरपेक्ष अंतर, जब क्रमबद्ध होते हैं, तो 1 से लेकर (अनुक्रम की लंबाई - 1) तक का एक सतत अनुक्रम बनाते हैं। \n   एकल तत्व वाला अनुक्रम हमेशा जॉली माना जाता है।\n\n        उदाहरण:\n        >>> IsSequenceJolly(new int[] {1, 4, 2, 3})\n        \"Jolly\"\n        \n        >>> IsSequenceJolly(new int[] {1, 3})\n        \"Not Jolly\"\n\n        >>> IsSequenceJolly(new int[] {5})\n        \"Jolly\"",
      "hu": "Meghatározza, hogy egy sorozat rendelkezik-e \"Jolly Jumps\"-szal, ahol a szomszédos elemek közötti abszolút különbségek, \n   ha sorba rendezzük, egy folytonos sorozatot alkotnak 1-től (a sorozat hossza - 1)-ig.\n   Az egyetlen elemet tartalmazó sorozatot mindig jolly-nak tekintjük.\n   \n        Példák:\n        >>> IsSequenceJolly(new int[] {1, 4, 2, 3})\n        \"Jolly\"\n        \n        >>> IsSequenceJolly(new int[] {1, 3})\n        \"Not Jolly\"\n\n        >>> IsSequenceJolly(new int[] {5})\n        \"Jolly\""
    },
    "docstring_bertscore": {
      "sq": "0.9962957420240803",
      "hy": "0.982031895731584",
      "bn": "0.9850651802803678",
      "bg": "0.989398699303406",
      "zh": "0.9596774367587746",
      "fr": "0.9969099071622403",
      "de": "0.9928769159057079",
      "ha": "0.9677142206058272",
      "hi": "0.9841028160842538",
      "hu": "0.994033341984093"
    }
  },
  {
    "task_id": "C#/22",
    "prompt": {
      "en": "using System;\nusing System.Collections.Generic;\nusing System.Diagnostics;\n\nclass Program\n{\n\n    /* Determines the winner in a game of Rock-Paper-Scissors played for a number of rounds.\n    Players A and B have their own repeating patterns of moves.\n    Rock (represented by 0) beats Scissors (2), Scissors beat Paper (5), and Paper beats Rock.\n    If both players choose the same move, the round is a draw.\n\n    Examples:\n    >>> DetermineWinner(10, new List<int> {0, 2, 5}, new List<int> {0, 5, 0, 2})\n    \"A\"\n\n    >>> DetermineWinner(6, new List<int> {2, 5, 0}, new List<int> {5, 0, 2})\n    \"A\"\n\n    >>> DetermineWinner(7, new List<int> {5, 5, 2}, new List<int> {5, 5, 2})\n    \"draw\"\n    */\n\n    static string DetermineWinner(int rounds, List<int> patternA, List<int> patternB)",
      "sq": "using System;\nusing System.Collections.Generic;\nusing System.Diagnostics;\n\nclass Program\n{\n\n    /* Përcakton fituesin në një lojë të Gur-Letër-Gërshërë të luajtur për një numër raundesh.\n    Lojtarët A dhe B kanë modelet e tyre të përsëritura të lëvizjeve.\n    Guri (përfaqësuar nga 0) mund Gërshërët (2), Gërshërët mundin Letërën (5), dhe Letëra mund Gur.\n    Nëse të dy lojtarët zgjedhin të njëjtën lëvizje, raundi është barazim.\n\n    Shembuj:\n    >>> DetermineWinner(10, new List<int> {0, 2, 5}, new List<int> {0, 5, 0, 2})\n    \"A\"\n\n    >>> DetermineWinner(6, new List<int> {2, 5, 0}, new List<int> {5, 0, 2})\n    \"A\"\n\n    >>> DetermineWinner(7, new List<int> {5, 5, 2}, new List<int> {5, 5, 2})\n    \"draw\"\n    */\n\n    static string DetermineWinner(int rounds, List<int> patternA, List<int> patternB)",
      "hy": "using System;\nusing System.Collections.Generic;\nusing System.Diagnostics;\n\nclass Program\n{\n\n    /* Սահմանում է հաղթողին Քար-Մկրատ-Թուղթ խաղում, որը խաղացվում է մի քանի փուլերի համար:\n    Խաղացողներ A-ն և B-ն ունեն իրենց կրկնվող քայլերի նախշերը:\n    Քարը (ներկայացված է 0-ով) հաղթում է Մկրատին (2), Մկրատը հաղթում է Թղթին (5), և Թուղթը հաղթում է Քարին:\n    Եթե երկու խաղացողներն էլ ընտրում են նույն քայլը, փուլը ոչ-ոքի է ավարտվում:\n\n    Օրինակներ:\n    >>> DetermineWinner(10, new List<int> {0, 2, 5}, new List<int> {0, 5, 0, 2})\n    \"A\"\n\n    >>> DetermineWinner(6, new List<int> {2, 5, 0}, new List<int> {5, 0, 2})\n    \"A\"\n\n    >>> DetermineWinner(7, new List<int> {5, 5, 2}, new List<int> {5, 5, 2})\n    \"draw\"\n    */\n\n    static string DetermineWinner(int rounds, List<int> patternA, List<int> patternB)",
      "bn": "using System;\nusing System.Collections.Generic;\nusing System.Diagnostics;\n\nclass Program\n{\n\n    /* একটি নির্দিষ্ট সংখ্যক রাউন্ডের জন্য খেলা রক-পেপার-সিজরস গেমে বিজয়ী নির্ধারণ করে।\n    খেলোয়াড় A এবং B তাদের নিজস্ব পুনরাবৃত্ত প্যাটার্নের চাল রয়েছে।\n    রক (0 দ্বারা প্রতিনিধিত্ব করা) সিজরস (2) কে হারায়, সিজরস পেপার (5) কে হারায়, এবং পেপার রককে হারায়।\n    যদি উভয় খেলোয়াড় একই চাল নির্বাচন করে, তাহলে রাউন্ডটি ড্র হয়।\n\n    উদাহরণ:\n    >>> DetermineWinner(10, new List<int> {0, 2, 5}, new List<int> {0, 5, 0, 2})\n    \"A\"\n\n    >>> DetermineWinner(6, new List<int> {2, 5, 0}, new List<int> {5, 0, 2})\n    \"A\"\n\n    >>> DetermineWinner(7, new List<int> {5, 5, 2}, new List<int> {5, 5, 2})\n    \"draw\"\n    */\n\n    static string DetermineWinner(int rounds, List<int> patternA, List<int> patternB)",
      "bg": "using System;\nusing System.Collections.Generic;\nusing System.Diagnostics;\n\nclass Program\n{\n\n    /* Определя победителя в игра на Камък-Ножица-Хартия, играна за определен брой рундове.\n    Играчите A и B имат свои собствени повтарящи се модели на ходове.\n    Камък (представен от 0) побеждава Ножица (2), Ножица побеждава Хартия (5), а Хартия побеждава Камък.\n    Ако и двамата играчи изберат един и същ ход, рундът е равен.\n\n    Примери:\n    >>> DetermineWinner(10, new List<int> {0, 2, 5}, new List<int> {0, 5, 0, 2})\n    \"A\"\n\n    >>> DetermineWinner(6, new List<int> {2, 5, 0}, new List<int> {5, 0, 2})\n    \"A\"\n\n    >>> DetermineWinner(7, new List<int> {5, 5, 2}, new List<int> {5, 5, 2})\n    \"draw\"\n    */\n\n    static string DetermineWinner(int rounds, List<int> patternA, List<int> patternB)",
      "zh": "using System;\nusing System.Collections.Generic;\nusing System.Diagnostics;\n\nclass Program\n{\n\n    /* 确定在进行若干轮的石头剪刀布游戏中的赢家。\n    玩家A和B有各自重复的出拳模式。\n    石头（用0表示）胜剪刀（2），剪刀胜布（5），布胜石头。\n    如果两位玩家选择相同的出拳，则该轮为平局。\n\n    例子:\n    >>> DetermineWinner(10, new List<int> {0, 2, 5}, new List<int> {0, 5, 0, 2})\n    \"A\"\n\n    >>> DetermineWinner(6, new List<int> {2, 5, 0}, new List<int> {5, 0, 2})\n    \"A\"\n\n    >>> DetermineWinner(7, new List<int> {5, 5, 2}, new List<int> {5, 5, 2})\n    \"draw\"\n    */\n\n    static string DetermineWinner(int rounds, List<int> patternA, List<int> patternB)",
      "fr": "using System;\nusing System.Collections.Generic;\nusing System.Diagnostics;\n\nclass Program\n{\n\n    /* Détermine le gagnant dans un jeu de Pierre-Papier-Ciseaux joué sur un certain nombre de manches.\n    Les joueurs A et B ont leurs propres motifs répétitifs de mouvements.\n    Pierre (représentée par 0) bat Ciseaux (2), Ciseaux battent Papier (5), et Papier bat Pierre.\n    Si les deux joueurs choisissent le même mouvement, la manche est un match nul.\n\n    Exemples:\n    >>> DetermineWinner(10, new List<int> {0, 2, 5}, new List<int> {0, 5, 0, 2})\n    \"A\"\n\n    >>> DetermineWinner(6, new List<int> {2, 5, 0}, new List<int> {5, 0, 2})\n    \"A\"\n\n    >>> DetermineWinner(7, new List<int> {5, 5, 2}, new List<int> {5, 5, 2})\n    \"draw\"\n    */\n\n    static string DetermineWinner(int rounds, List<int> patternA, List<int> patternB)",
      "de": "using System;\nusing System.Collections.Generic;\nusing System.Diagnostics;\n\nclass Program\n{\n\n    /* Bestimmt den Gewinner in einem Spiel von Schere-Stein-Papier, das über eine Anzahl von Runden gespielt wird.\n    Spieler A und B haben ihre eigenen sich wiederholenden Bewegungsmuster.\n    Stein (dargestellt durch 0) schlägt Schere (2), Schere schlägt Papier (5), und Papier schlägt Stein.\n    Wenn beide Spieler denselben Zug wählen, ist die Runde ein Unentschieden.\n\n    Beispiele:\n    >>> DetermineWinner(10, new List<int> {0, 2, 5}, new List<int> {0, 5, 0, 2})\n    \"A\"\n\n    >>> DetermineWinner(6, new List<int> {2, 5, 0}, new List<int> {5, 0, 2})\n    \"A\"\n\n    >>> DetermineWinner(7, new List<int> {5, 5, 2}, new List<int> {5, 5, 2})\n    \"draw\"\n    */\n\n    static string DetermineWinner(int rounds, List<int> patternA, List<int> patternB)",
      "ha": "using System;\nusing System.Collections.Generic;\nusing System.Diagnostics;\n\nclass Program\n{\n\n    /* Yana tantance wanda ya yi nasara a cikin wasan Rock-Paper-Scissors da aka buga na tsawon zagaye da dama.\n    'Yan wasa A da B suna da nasu tsarin maimaita motsi.\n    Rock (wanda aka wakilta da 0) yana doke Scissors (2), Scissors suna doke Paper (5), kuma Paper yana doke Rock.\n    Idan duka 'yan wasan sun zabi motsi iri daya, zagayen ya zama kunnen doki.\n\n    Misalai:\n    >>> DetermineWinner(10, new List<int> {0, 2, 5}, new List<int> {0, 5, 0, 2})\n    \"A\"\n\n    >>> DetermineWinner(6, new List<int> {2, 5, 0}, new List<int> {5, 0, 2})\n    \"A\"\n\n    >>> DetermineWinner(7, new List<int> {5, 5, 2}, new List<int> {5, 5, 2})\n    \"draw\"\n    */\n\n    static string DetermineWinner(int rounds, List<int> patternA, List<int> patternB)",
      "hi": "using System;\nusing System.Collections.Generic;\nusing System.Diagnostics;\n\nclass Program\n{\n\n    /* कई राउंड के लिए खेले गए रॉक-पेपर-सीज़र के खेल में विजेता का निर्धारण करता है।\n    खिलाड़ी A और B के पास अपनी खुद की चालों के दोहराने वाले पैटर्न होते हैं।\n    रॉक (0 द्वारा दर्शाया गया) सीज़र (2) को हराता है, सीज़र पेपर (5) को हराता है, और पेपर रॉक को हराता है।\n    यदि दोनों खिलाड़ी एक ही चाल चुनते हैं, तो राउंड ड्रॉ होता है।\n\n    उदाहरण:\n    >>> DetermineWinner(10, new List<int> {0, 2, 5}, new List<int> {0, 5, 0, 2})\n    \"A\"\n\n    >>> DetermineWinner(6, new List<int> {2, 5, 0}, new List<int> {5, 0, 2})\n    \"A\"\n\n    >>> DetermineWinner(7, new List<int> {5, 5, 2}, new List<int> {5, 5, 2})\n    \"draw\"\n    */\n\n    static string DetermineWinner(int rounds, List<int> patternA, List<int> patternB)",
      "hu": "using System;\nusing System.Collections.Generic;\nusing System.Diagnostics;\n\nclass Program\n{\n\n    /* Meghatározza a nyertest egy Kő-Papír-Olló játékban, amelyet több fordulón keresztül játszanak.\n    A és B játékosoknak saját ismétlődő mozgásmintáik vannak.\n    A kő (0-val jelölve) üti az ollót (2), az olló üti a papírt (5), és a papír üti a követ.\n    Ha mindkét játékos ugyanazt a lépést választja, a forduló döntetlen.\n\n    Példák:\n    >>> DetermineWinner(10, new List<int> {0, 2, 5}, new List<int> {0, 5, 0, 2})\n    \"A\"\n\n    >>> DetermineWinner(6, new List<int> {2, 5, 0}, new List<int> {5, 0, 2})\n    \"A\"\n\n    >>> DetermineWinner(7, new List<int> {5, 5, 2}, new List<int> {5, 5, 2})\n    \"döntetlen\"\n    */\n\n    static string DetermineWinner(int rounds, List<int> patternA, List<int> patternB)"
    },
    "prompt_bertscore": {
      "sq": "0.9962689269226407",
      "hy": "0.9742964341725613",
      "bn": "0.9763878134544777",
      "bg": "0.9957473235420431",
      "zh": "0.9715515609370402",
      "fr": "0.9943136094517332",
      "de": "0.9929523954505012",
      "ha": "0.9752729011257288",
      "hi": "0.9714705197415779",
      "hu": "0.9677612960061325"
    },
    "canonical_solution": "    {\n        int scoreA = 0, scoreB = 0;\n        for (int i = 0; i < rounds; i++)\n        {\n            int moveA = patternA[i % patternA.Count];\n            int moveB = patternB[i % patternB.Count];\n\n            if (moveA == moveB) continue;\n            if ((moveA == 0 && moveB == 2) || (moveA == 2 && moveB == 5) || (moveA == 5 && moveB == 0))\n                scoreA++;\n            else\n                scoreB++;\n        }\n\n        if (scoreA > scoreB) return \"A\";\n        if (scoreB > scoreA) return \"B\";\n        return \"draw\";\n    }",
    "instruction": {
      "en": "Write a C# function `static string DetermineWinner(int rounds, List<int> patternA, List<int> patternB)` to solve the following problem:\nDetermines the winner in a game of Rock-Paper-Scissors played for a number of rounds.\n    Players A and B have their own repeating patterns of moves.\n    Rock (represented by 0) beats Scissors (2), Scissors beat Paper (5), and Paper beats Rock.\n    If both players choose the same move, the round is a draw.\n\n    Examples:\n    >>> DetermineWinner(10, new List<int> {0, 2, 5}, new List<int> {0, 5, 0, 2})\n    \"A\"\n\n    >>> DetermineWinner(6, new List<int> {2, 5, 0}, new List<int> {5, 0, 2})\n    \"A\"\n\n    >>> DetermineWinner(7, new List<int> {5, 5, 2}, new List<int> {5, 5, 2})\n    \"draw\"",
      "sq": "Shkruani një funksion në C# `static string DetermineWinner(int rounds, List<int> patternA, List<int> patternB)` për të zgjidhur problemin në vijim:\nPërcakton fituesin në një lojë Guri-Letër-Gërshërë të luajtur për një numër raundesh.\n    Lojtarët A dhe B kanë modelet e tyre të përsëritura të lëvizjeve.\n    Guri (i përfaqësuar nga 0) mund Gërshërët (2), Gërshërët mundin Letërën (5), dhe Letëra mund Gur.\n    Nëse të dy lojtarët zgjedhin të njëjtën lëvizje, raundi është barazim.\n\n    Shembuj:\n    >>> DetermineWinner(10, new List<int> {0, 2, 5}, new List<int> {0, 5, 0, 2})\n    \"A\"\n\n    >>> DetermineWinner(6, new List<int> {2, 5, 0}, new List<int> {5, 0, 2})\n    \"A\"\n\n    >>> DetermineWinner(7, new List<int> {5, 5, 2}, new List<int> {5, 5, 2})\n    \"draw\"",
      "hy": "Գրեք C# ֆունկցիա `static string DetermineWinner(int rounds, List<int> patternA, List<int> patternB)` հետևյալ խնդիրը լուծելու համար:\nՍահմանում է հաղթողին Քար-Թուղթ-Մկրատ խաղում, որը խաղացվում է մի քանի փուլերի համար:\n    Խաղացողներ A-ն և B-ն ունեն իրենց կրկնվող քայլերի նախշերը:\n    Քարը (ներկայացված է 0-ով) հաղթում է Մկրատին (2), Մկրատը հաղթում է Թղթին (5), իսկ Թուղթը հաղթում է Քարին:\n    Եթե երկու խաղացողներն էլ ընտրում են նույն քայլը, փուլը ոչ-ոքի է ավարտվում:\n\n    Օրինակներ:\n    >>> DetermineWinner(10, new List<int> {0, 2, 5}, new List<int> {0, 5, 0, 2})\n    \"A\"\n\n    >>> DetermineWinner(6, new List<int> {2, 5, 0}, new List<int> {5, 0, 2})\n    \"A\"\n\n    >>> DetermineWinner(7, new List<int> {5, 5, 2}, new List<int> {5, 5, 2})\n    \"draw\"",
      "bn": "C# ফাংশন `static string DetermineWinner(int rounds, List<int> patternA, List<int> patternB)` লিখুন নিম্নলিখিত সমস্যার সমাধান করতে:\nএকটি গেমের বিজয়ী নির্ধারণ করে যেখানে রক-পেপার-সিজার্স খেলা হয় নির্দিষ্ট সংখ্যক রাউন্ডের জন্য।\n    খেলোয়াড় A এবং B তাদের নিজস্ব পুনরাবৃত্ত প্যাটার্নের চাল ব্যবহার করে।\n    রক (0 দ্বারা প্রতিনিধিত্ব করে) সিজার্স (2) কে হারায়, সিজার্স পেপার (5) কে হারায়, এবং পেপার রককে হারায়।\n    যদি উভয় খেলোয়াড় একই চাল নির্বাচন করে, তাহলে রাউন্ডটি ড্র হয়।\n\n    উদাহরণ:\n    >>> DetermineWinner(10, new List<int> {0, 2, 5}, new List<int> {0, 5, 0, 2})\n    \"A\"\n\n    >>> DetermineWinner(6, new List<int> {2, 5, 0}, new List<int> {5, 0, 2})\n    \"A\"\n\n    >>> DetermineWinner(7, new List<int> {5, 5, 2}, new List<int> {5, 5, 2})\n    \"draw\"",
      "bg": "Напишете C# функция `static string DetermineWinner(int rounds, List<int> patternA, List<int> patternB)`, за да решите следния проблем:\nОпределя победителя в игра на Камък-Ножица-Хартия, играна за определен брой рундове.\nИграчите A и B имат свои собствени повтарящи се модели на ходове.\nКамък (представен от 0) побеждава Ножица (2), Ножица побеждава Хартия (5), а Хартия побеждава Камък.\nАко и двамата играчи изберат един и същ ход, рундът е равен.\n\nПримери:\n>>> DetermineWinner(10, new List<int> {0, 2, 5}, new List<int> {0, 5, 0, 2})\n\"A\"\n\n>>> DetermineWinner(6, new List<int> {2, 5, 0}, new List<int> {5, 0, 2})\n\"A\"\n\n>>> DetermineWinner(7, new List<int> {5, 5, 2}, new List<int> {5, 5, 2})\n\"draw\"",
      "zh": "编写一个 C# 函数 `static string DetermineWinner(int rounds, List<int> patternA, List<int> patternB)` 来解决以下问题：\n确定在进行若干轮的剪刀石头布游戏中的获胜者。\n玩家 A 和 B 有各自重复的出招模式。\n石头（用 0 表示）胜剪刀（2），剪刀胜布（5），布胜石头。\n如果两位玩家选择相同的出招，则该轮平局。\n\n示例：\n>>> DetermineWinner(10, new List<int> {0, 2, 5}, new List<int> {0, 5, 0, 2})\n\"A\"\n\n>>> DetermineWinner(6, new List<int> {2, 5, 0}, new List<int> {5, 0, 2})\n\"A\"\n\n>>> DetermineWinner(7, new List<int> {5, 5, 2}, new List<int> {5, 5, 2})\n\"draw\"",
      "fr": "Écrire une fonction C# `static string DetermineWinner(int rounds, List<int> patternA, List<int> patternB)` pour résoudre le problème suivant :\nDétermine le gagnant dans un jeu de Pierre-Papier-Ciseaux joué pendant un certain nombre de manches.\n    Les joueurs A et B ont leurs propres schémas de mouvements répétitifs.\n    Pierre (représentée par 0) bat Ciseaux (2), Ciseaux battent Papier (5), et Papier bat Pierre.\n    Si les deux joueurs choisissent le même mouvement, la manche est un match nul.\n\n    Exemples :\n    >>> DetermineWinner(10, new List<int> {0, 2, 5}, new List<int> {0, 5, 0, 2})\n    \"A\"\n\n    >>> DetermineWinner(6, new List<int> {2, 5, 0}, new List<int> {5, 0, 2})\n    \"A\"\n\n    >>> DetermineWinner(7, new List<int> {5, 5, 2}, new List<int> {5, 5, 2})\n    \"draw\"",
      "de": "Schreiben Sie eine C#-Funktion `static string DetermineWinner(int rounds, List<int> patternA, List<int> patternB)`, um das folgende Problem zu lösen:\nBestimmt den Gewinner in einem Spiel von Schere-Stein-Papier, das über eine Anzahl von Runden gespielt wird.\n    Die Spieler A und B haben ihre eigenen sich wiederholenden Bewegungsmuster.\n    Stein (dargestellt durch 0) schlägt Schere (2), Schere schlägt Papier (5), und Papier schlägt Stein.\n    Wenn beide Spieler denselben Zug wählen, ist die Runde ein Unentschieden.\n\n    Beispiele:\n    >>> DetermineWinner(10, new List<int> {0, 2, 5}, new List<int> {0, 5, 0, 2})\n    \"A\"\n\n    >>> DetermineWinner(6, new List<int> {2, 5, 0}, new List<int> {5, 0, 2})\n    \"A\"\n\n    >>> DetermineWinner(7, new List<int> {5, 5, 2}, new List<int> {5, 5, 2})\n    \"draw\"",
      "ha": "Rubuta aikin C# `static string DetermineWinner(int rounds, List<int> patternA, List<int> patternB)` don warware matsalar mai zuwa:\nTantance wanda ya yi nasara a wasan Rock-Paper-Scissors da aka buga na tsawon zagaye.\n    'Yan wasa A da B suna da nasu maimaita tsarin motsi.\n    Rock (wanda aka wakilta da 0) yana doke Scissors (2), Scissors suna doke Paper (5), kuma Paper tana doke Rock.\n    Idan duka 'yan wasan suka zaɓi motsi iri ɗaya, zagayen ya zama kunnen doki.\n\n    Misalai:\n    >>> DetermineWinner(10, new List<int> {0, 2, 5}, new List<int> {0, 5, 0, 2})\n    \"A\"\n\n    >>> DetermineWinner(6, new List<int> {2, 5, 0}, new List<int> {5, 0, 2})\n    \"A\"\n\n    >>> DetermineWinner(7, new List<int> {5, 5, 2}, new List<int> {5, 5, 2})\n    \"draw\"",
      "hi": "C# फ़ंक्शन `static string DetermineWinner(int rounds, List<int> patternA, List<int> patternB)` लिखें ताकि निम्नलिखित समस्या का समाधान हो सके:\nकिसी खेल में विजेता का निर्धारण करता है जो रॉक-पेपर-सीज़र के लिए कई राउंड तक खेला जाता है।\n    खिलाड़ी A और B के पास अपनी खुद की चालों के दोहराने वाले पैटर्न होते हैं।\n    रॉक (0 द्वारा दर्शाया गया) सीज़र (2) को हराता है, सीज़र पेपर (5) को हराता है, और पेपर रॉक को हराता है।\n    यदि दोनों खिलाड़ी एक ही चाल चुनते हैं, तो राउंड ड्रॉ होता है।\n\n    उदाहरण:\n    >>> DetermineWinner(10, new List<int> {0, 2, 5}, new List<int> {0, 5, 0, 2})\n    \"A\"\n\n    >>> DetermineWinner(6, new List<int> {2, 5, 0}, new List<int> {5, 0, 2})\n    \"A\"\n\n    >>> DetermineWinner(7, new List<int> {5, 5, 2}, new List<int> {5, 5, 2})\n    \"draw\"",
      "hu": "Írj egy C# függvényt `static string DetermineWinner(int rounds, List<int> patternA, List<int> patternB)` a következő probléma megoldására:\nMeghatározza a győztest egy Kő-Papír-Olló játékban, amelyet több fordulón keresztül játszanak.\n    A játékosok A és B saját ismétlődő mozdulatsorozattal rendelkeznek.\n    A Kő (0-val jelölve) üti az Ollót (2), az Olló üti a Papírt (5), és a Papír üti a Követ.\n    Ha mindkét játékos ugyanazt a lépést választja, a forduló döntetlen.\n\n    Példák:\n    >>> DetermineWinner(10, new List<int> {0, 2, 5}, new List<int> {0, 5, 0, 2})\n    \"A\"\n\n    >>> DetermineWinner(6, new List<int> {2, 5, 0}, new List<int> {5, 0, 2})\n    \"A\"\n\n    >>> DetermineWinner(7, new List<int> {5, 5, 2}, new List<int> {5, 5, 2})\n    \"draw\""
    },
    "instruction_bertscore": {
      "sq": "0.9958186318488346",
      "hy": "0.9705802583737796",
      "bn": "0.9720159587678998",
      "bg": "0.9889056986976773",
      "zh": "0.9673664188086352",
      "fr": "0.9832512876407572",
      "de": "0.993105142213517",
      "ha": "0.9825425744412247",
      "hi": "0.9754963603043931",
      "hu": "0.9835522126680251"
    },
    "level": "hard",
    "test": "    static void Main()\n    {\n        Debug.Assert(DetermineWinner(10, new List<int> {0, 2, 5}, new List<int> {0, 5, 0, 2}) == \"A\");\n        Debug.Assert(DetermineWinner(6, new List<int> {2, 5, 0}, new List<int> {5, 0, 2}) == \"A\");\n        Debug.Assert(DetermineWinner(5, new List<int> {0, 0, 0}, new List<int> {2, 2, 2}) == \"A\");\n        Debug.Assert(DetermineWinner(7, new List<int> {5, 5, 2}, new List<int> {5, 5, 2}) == \"draw\");\n    }\n}",
    "entry_point": "DetermineWinner",
    "signature": "static string DetermineWinner(int rounds, List<int> patternA, List<int> patternB)",
    "docstring": {
      "en": "Determines the winner in a game of Rock-Paper-Scissors played for a number of rounds.\n    Players A and B have their own repeating patterns of moves.\n    Rock (represented by 0) beats Scissors (2), Scissors beat Paper (5), and Paper beats Rock.\n    If both players choose the same move, the round is a draw.\n\n    Examples:\n    >>> DetermineWinner(10, new List<int> {0, 2, 5}, new List<int> {0, 5, 0, 2})\n    \"A\"\n\n    >>> DetermineWinner(6, new List<int> {2, 5, 0}, new List<int> {5, 0, 2})\n    \"A\"\n\n    >>> DetermineWinner(7, new List<int> {5, 5, 2}, new List<int> {5, 5, 2})\n    \"draw\"",
      "sq": "Përcakton fituesin në një lojë të Guri-Letra-Gërshërët të luajtur për një numër raundesh.\n    Lojtarët A dhe B kanë modelet e tyre të përsëritura të lëvizjeve.\n    Guri (përfaqësuar nga 0) mund Gërshërët (2), Gërshërët mundin Letrën (5), dhe Letra mund Gur.\n    Nëse të dy lojtarët zgjedhin të njëjtën lëvizje, raundi është barazim.\n\n    Shembuj:\n    >>> DetermineWinner(10, new List<int> {0, 2, 5}, new List<int> {0, 5, 0, 2})\n    \"A\"\n\n    >>> DetermineWinner(6, new List<int> {2, 5, 0}, new List<int> {5, 0, 2})\n    \"A\"\n\n    >>> DetermineWinner(7, new List<int> {5, 5, 2}, new List<int> {5, 5, 2})\n    \"draw\"",
      "hy": "Սահմանում է հաղթողին Քար-Թուղթ-Մկրատ խաղում, որը խաղացվում է մի քանի ռաունդների համար:\n    Խաղացողներ A-ն և B-ն ունեն իրենց կրկնվող քայլերի նախշերը:\n    Քարը (ներկայացված է 0-ով) հաղթում է Մկրատին (2), Մկրատը հաղթում է Թղթին (5), իսկ Թուղթը հաղթում է Քարին:\n    Եթե երկու խաղացողներն էլ ընտրում են նույն քայլը, ռաունդը ոչ-ոքի է:\n\n    Օրինակներ:\n    >>> DetermineWinner(10, new List<int> {0, 2, 5}, new List<int> {0, 5, 0, 2})\n    \"A\"\n\n    >>> DetermineWinner(6, new List<int> {2, 5, 0}, new List<int> {5, 0, 2})\n    \"A\"\n\n    >>> DetermineWinner(7, new List<int> {5, 5, 2}, new List<int> {5, 5, 2})\n    \"draw\"",
      "bn": "খেলাটি কয়েকটি রাউন্ডের জন্য খেলা হয় যেখানে রক-পেপার-সিজার্সের মধ্যে বিজয়ী নির্ধারণ করা হয়।\n    খেলোয়াড় A এবং B এর নিজস্ব পুনরাবৃত্তি প্যাটার্নের চাল রয়েছে।\n    রক (০ দ্বারা প্রতিনিধিত্ব করা হয়েছে) সিজার্স (২) কে হারায়, সিজার্স কাগজ (৫) কে হারায়, এবং কাগজ রককে হারায়।\n    যদি উভয় খেলোয়াড় একই চাল নির্বাচন করে, তাহলে রাউন্ডটি ড্র হয়।\n    উদাহরণসমূহ:\n    >>> DetermineWinner(10, new List<int> {0, 2, 5}, new List<int> {0, 5, 0, 2})\n    \"A\"\n\n    >>> DetermineWinner(6, new List<int> {2, 5, 0}, new List<int> {5, 0, 2})\n    \"A\"\n\n    >>> DetermineWinner(7, new List<int> {5, 5, 2}, new List<int> {5, 5, 2})\n    \"draw\"",
      "bg": "Определя победителя в игра на Камък-Ножица-Хартия, играна за определен брой рундове.\nИграчите A и B имат свои собствени повтарящи се модели на ходове.\nКамък (представен с 0) побеждава Ножица (2), Ножица побеждава Хартия (5), а Хартия побеждава Камък.\nАко и двамата играчи изберат един и същ ход, рундът е равенство.\n\nПримери:\n>>> DetermineWinner(10, new List<int> {0, 2, 5}, new List<int> {0, 5, 0, 2})\n\"A\"\n\n>>> DetermineWinner(6, new List<int> {2, 5, 0}, new List<int> {5, 0, 2})\n\"A\"\n\n>>> DetermineWinner(7, new List<int> {5, 5, 2}, new List<int> {5, 5, 2})\n\"draw\"",
      "zh": "确定在多轮石头剪刀布游戏中获胜者。\n玩家 A 和 B 有自己重复的出拳模式。\n石头（用 0 表示）胜剪刀（2），剪刀胜布（5），布胜石头。\n如果两位玩家选择相同的出拳，该轮为平局。\n\n示例：\n>>> DetermineWinner(10, new List<int> {0, 2, 5}, new List<int> {0, 5, 0, 2})\n\"A\"\n\n>>> DetermineWinner(6, new List<int> {2, 5, 0}, new List<int> {5, 0, 2})\n\"A\"\n\n>>> DetermineWinner(7, new List<int> {5, 5, 2}, new List<int> {5, 5, 2})\n\"draw\"",
      "fr": "Détermine le gagnant dans un jeu de Pierre-Papier-Ciseaux joué sur un certain nombre de manches.\n    Les joueurs A et B ont leurs propres motifs répétitifs de mouvements.\n    Pierre (représentée par 0) bat Ciseaux (2), Ciseaux battent Papier (5), et Papier bat Pierre.\n    Si les deux joueurs choisissent le même mouvement, la manche est un match nul.\n\n    Exemples :\n    >>> DetermineWinner(10, new List<int> {0, 2, 5}, new List<int> {0, 5, 0, 2})\n    \"A\"\n\n    >>> DetermineWinner(6, new List<int> {2, 5, 0}, new List<int> {5, 0, 2})\n    \"A\"\n\n    >>> DetermineWinner(7, new List<int> {5, 5, 2}, new List<int> {5, 5, 2})\n    \"draw\"",
      "de": "Bestimmt den Gewinner in einem Spiel von Schere-Stein-Papier, das über eine Anzahl von Runden gespielt wird.\n    Spieler A und B haben ihre eigenen sich wiederholenden Muster von Zügen.\n    Stein (dargestellt durch 0) schlägt Schere (2), Schere schlägt Papier (5), und Papier schlägt Stein.\n    Wenn beide Spieler denselben Zug wählen, ist die Runde ein Unentschieden.\n\n    Beispiele:\n    >>> DetermineWinner(10, new List<int> {0, 2, 5}, new List<int> {0, 5, 0, 2})\n    \"A\"\n\n    >>> DetermineWinner(6, new List<int> {2, 5, 0}, new List<int> {5, 0, 2})\n    \"A\"\n\n    >>> DetermineWinner(7, new List<int> {5, 5, 2}, new List<int> {5, 5, 2})\n    \"draw\"",
      "ha": "Yana ƙayyade wanda ya yi nasara a cikin wasan Dutsen-Takarda-Almakashi da aka buga don adadin zagaye.\n    'Yan wasa A da B suna da nasu tsarin motsi mai maimaitawa.\n    Dutsen (wanda aka wakilta da 0) yana doke Almakashi (2), Almakashi yana doke Takarda (5), kuma Takarda tana doke Dutsen.\n    Idan duka 'yan wasan suka zaɓi motsi iri ɗaya, zagayen ya zama kunnen doki.\n\n    Misalai:\n    >>> DetermineWinner(10, new List<int> {0, 2, 5}, new List<int> {0, 5, 0, 2})\n    \"A\"\n\n    >>> DetermineWinner(6, new List<int> {2, 5, 0}, new List<int> {5, 0, 2})\n    \"A\"\n\n    >>> DetermineWinner(7, new List<int> {5, 5, 2}, new List<int> {5, 5, 2})\n    \"draw\"",
      "hi": "कई राउंड के लिए खेले गए रॉक-पेपर-सीज़र के खेल में विजेता का निर्धारण करता है।\n    खिलाड़ी A और B के पास अपनी खुद की चालों के दोहराने वाले पैटर्न होते हैं।\n    रॉक (0 द्वारा प्रदर्शित) कैंची (2) को हराता है, कैंची कागज (5) को हराती है, और कागज रॉक को हराता है।\n    यदि दोनों खिलाड़ी एक ही चाल चुनते हैं, तो राउंड ड्रॉ होता है।\n\n    उदाहरण:\n    >>> DetermineWinner(10, new List<int> {0, 2, 5}, new List<int> {0, 5, 0, 2})\n    \"A\"\n\n    >>> DetermineWinner(6, new List<int> {2, 5, 0}, new List<int> {5, 0, 2})\n    \"A\"\n\n    >>> DetermineWinner(7, new List<int> {5, 5, 2}, new List<int> {5, 5, 2})\n    \"draw\"",
      "hu": "Meghatározza a győztest egy Kő-Papír-Olló játékban, amelyet több fordulón keresztül játszanak.\n    A és B játékosok saját ismétlődő mozgásmintákkal rendelkeznek.\n    A Kő (0-val jelölve) legyőzi az Ollót (2), az Olló legyőzi a Papírt (5), és a Papír legyőzi a Követ.\n    Ha mindkét játékos ugyanazt a lépést választja, a forduló döntetlen.\n\n    Példák:\n    >>> DetermineWinner(10, new List<int> {0, 2, 5}, new List<int> {0, 5, 0, 2})\n    \"A\"\n\n    >>> DetermineWinner(6, new List<int> {2, 5, 0}, new List<int> {5, 0, 2})\n    \"A\"\n\n    >>> DetermineWinner(7, new List<int> {5, 5, 2}, new List<int> {5, 5, 2})\n    \"döntetlen\""
    },
    "docstring_bertscore": {
      "sq": "0.9951734803712332",
      "hy": "0.9701204290416838",
      "bn": "0.8878147525737814",
      "bg": "0.9928077925331077",
      "zh": "0.9697313121252364",
      "fr": "0.9840428297091812",
      "de": "0.9967488179232209",
      "ha": "0.9837140964285684",
      "hi": "0.9984832584104176",
      "hu": "0.9747814895630486"
    }
  },
  {
    "task_id": "C#/23",
    "prompt": {
      "en": "using System;\nusing System.Collections.Generic;\nusing System.Diagnostics;\n\nclass Program\n{\n\n\n/* \n    Calculate the dot product of two n-dimensional integer vectors.\n    The dot product is the sum of the products of the corresponding elements of the two vectors.\n\n    Example 1:\n    >>> CalculateDotProduct(new List<int> {1, 3, -5}, new List<int> {4, -2, -1})\n    3\n\n    Example 2:\n    >>> CalculateDotProduct(new List<int> {2, 5, 7}, new List<int> {3, 6, 8})\n    100\n*/\n\nstatic int CalculateDotProduct(List<int> vectorA, List<int> vectorB)",
      "sq": "using System;\nusing System.Collections.Generic;\nusing System.Diagnostics;\n\nclass Program\n{\n\n\n/* \n    Llogarit produktin skalar të dy vektorëve të dimensionit n me numra të plotë.\n    Produkti skalar është shuma e produkteve të elementeve përkatëse të dy vektorëve.\n\n    Shembull 1:\n    >>> CalculateDotProduct(new List<int> {1, 3, -5}, new List<int> {4, -2, -1})\n    3\n\n    Shembull 2:\n    >>> CalculateDotProduct(new List<int> {2, 5, 7}, new List<int> {3, 6, 8})\n    100\n*/\n\nstatic int CalculateDotProduct(List<int> vectorA, List<int> vectorB)",
      "hy": "using System;\nusing System.Collections.Generic;\nusing System.Diagnostics;\n\nclass Program\n{\n\n\n/* \n    Հաշվել երկու n-չափանի ամբողջ թվերի վեկտորների կետային արտադրյալը։\n    Կետային արտադրյալը երկու վեկտորների համապատասխան տարրերի արտադրյալների գումարն է։\n\n    Օրինակ 1:\n    >>> CalculateDotProduct(new List<int> {1, 3, -5}, new List<int> {4, -2, -1})\n    3\n\n    Օրինակ 2:\n    >>> CalculateDotProduct(new List<int> {2, 5, 7}, new List<int> {3, 6, 8})\n    100\n*/\n\nstatic int CalculateDotProduct(List<int> vectorA, List<int> vectorB)",
      "bn": "using System;\nusing System.Collections.Generic;\nusing System.Diagnostics;\n\nclass Program\n{\n\n\n/* \n    দুটি n-মাত্রিক পূর্ণসংখ্যা ভেক্টরের ডট গুণফল গণনা করুন।\n    ডট গুণফল হল দুটি ভেক্টরের সমতুল্য উপাদানগুলির গুণফলের যোগফল।\n\n    উদাহরণ ১:\n    >>> CalculateDotProduct(new List<int> {1, 3, -5}, new List<int> {4, -2, -1})\n    3\n\n    উদাহরণ ২:\n    >>> CalculateDotProduct(new List<int> {2, 5, 7}, new List<int> {3, 6, 8})\n    100\n*/\n\nstatic int CalculateDotProduct(List<int> vectorA, List<int> vectorB)",
      "bg": "using System;\nusing System.Collections.Generic;\nusing System.Diagnostics;\n\nclass Program\n{\n\n\n/* \n    Изчислете скаларното произведение на два n-мерни векторa от цели числа.\n    Скаларното произведение е сумата от произведенията на съответните елементи на двата вектора.\n\n    Пример 1:\n    >>> CalculateDotProduct(new List<int> {1, 3, -5}, new List<int> {4, -2, -1})\n    3\n\n    Пример 2:\n    >>> CalculateDotProduct(new List<int> {2, 5, 7}, new List<int> {3, 6, 8})\n    100\n*/\n\nstatic int CalculateDotProduct(List<int> vectorA, List<int> vectorB)",
      "zh": "using System;\nusing System.Collections.Generic;\nusing System.Diagnostics;\n\nclass Program\n{\n\n\n/* \n    计算两个n维整数向量的点积。\n    点积是两个向量对应元素的乘积之和。\n\n    示例 1:\n    >>> CalculateDotProduct(new List<int> {1, 3, -5}, new List<int> {4, -2, -1})\n    3\n\n    示例 2:\n    >>> CalculateDotProduct(new List<int> {2, 5, 7}, new List<int> {3, 6, 8})\n    100\n*/\n\nstatic int CalculateDotProduct(List<int> vectorA, List<int> vectorB)",
      "fr": "using System;\nusing System.Collections.Generic;\nusing System.Diagnostics;\n\nclass Program\n{\n\n\n/* \n    Calculer le produit scalaire de deux vecteurs entiers n-dimensionnels.\n    Le produit scalaire est la somme des produits des éléments correspondants des deux vecteurs.\n\n    Exemple 1 :\n    >>> CalculateDotProduct(new List<int> {1, 3, -5}, new List<int> {4, -2, -1})\n    3\n\n    Exemple 2 :\n    >>> CalculateDotProduct(new List<int> {2, 5, 7}, new List<int> {3, 6, 8})\n    100\n*/\n\nstatic int CalculateDotProduct(List<int> vectorA, List<int> vectorB)",
      "de": "using System;\nusing System.Collections.Generic;\nusing System.Diagnostics;\n\nclass Program\n{\n\n\n/* \n    Berechne das Skalarprodukt zweier n-dimensionaler Ganzzahlvektoren.\n    Das Skalarprodukt ist die Summe der Produkte der entsprechenden Elemente der beiden Vektoren.\n\n    Beispiel 1:\n    >>> CalculateDotProduct(new List<int> {1, 3, -5}, new List<int> {4, -2, -1})\n    3\n\n    Beispiel 2:\n    >>> CalculateDotProduct(new List<int> {2, 5, 7}, new List<int> {3, 6, 8})\n    100\n*/\n\nstatic int CalculateDotProduct(List<int> vectorA, List<int> vectorB)",
      "ha": "using System;\nusing System.Collections.Generic;\nusing System.Diagnostics;\n\nclass Program\n{\n\n\n/* \n    Lissafa samfurin doti na n-dimensional vectors na integers guda biyu.\n    Samfurin doti shine jimlar samfuran abubuwan da suka dace na vectors guda biyu.\n\n    Misali 1:\n    >>> CalculateDotProduct(new List<int> {1, 3, -5}, new List<int> {4, -2, -1})\n    3\n\n    Misali 2:\n    >>> CalculateDotProduct(new List<int> {2, 5, 7}, new List<int> {3, 6, 8})\n    100\n*/\n\nstatic int CalculateDotProduct(List<int> vectorA, List<int> vectorB)",
      "hi": "using System;\nusing System.Collections.Generic;\nusing System.Diagnostics;\n\nclass Program\n{\n\n\n/* \n    दो n-आयामी पूर्णांक वेक्टरों का डॉट गुणनफल गणना करें।\n    डॉट गुणनफल दो वेक्टरों के संगत तत्वों के गुणनफल का योग होता है।\n\n    उदाहरण 1:\n    >>> CalculateDotProduct(new List<int> {1, 3, -5}, new List<int> {4, -2, -1})\n    3\n\n    उदाहरण 2:\n    >>> CalculateDotProduct(new List<int> {2, 5, 7}, new List<int> {3, 6, 8})\n    100\n*/\n\nstatic int CalculateDotProduct(List<int> vectorA, List<int> vectorB)",
      "hu": "using System;\nusing System.Collections.Generic;\nusing System.Diagnostics;\n\nclass Program\n{\n\n\n/* \n    Két n-dimenziós egész szám vektor skaláris szorzatának kiszámítása.\n    A skaláris szorzat a két vektor megfelelő elemeinek szorzatainak összege.\n\n    1. példa:\n    >>> CalculateDotProduct(new List<int> {1, 3, -5}, new List<int> {4, -2, -1})\n    3\n\n    2. példa:\n    >>> CalculateDotProduct(new List<int> {2, 5, 7}, new List<int> {3, 6, 8})\n    100\n*/\n\nstatic int CalculateDotProduct(List<int> vectorA, List<int> vectorB)"
    },
    "prompt_bertscore": {
      "sq": "0.9878839440176339",
      "hy": "1",
      "bn": "1",
      "bg": "0.9953995217448509",
      "zh": "1",
      "fr": "1",
      "de": "1",
      "ha": "0.9953995217448509",
      "hi": "1",
      "hu": "0.9933774644659158"
    },
    "canonical_solution": "{\n    if (vectorA.Count != vectorB.Count)\n        throw new ArgumentException(\"Vectors must be of the same dimension.\");\n\n    int dotProduct = 0;\n    for (int i = 0; i < vectorA.Count; i++)\n    {\n        dotProduct += vectorA[i] * vectorB[i];\n    }\n    return dotProduct;\n}",
    "instruction": {
      "en": "Write a C# function `static int CalculateDotProduct(List<int> vectorA, List<int> vectorB)` to solve the following problem:\nCalculate the dot product of two n-dimensional integer vectors.\n    The dot product is the sum of the products of the corresponding elements of the two vectors.\n\n    Example 1:\n    >>> CalculateDotProduct(new List<int> {1, 3, -5}, new List<int> {4, -2, -1})\n    3\n\n    Example 2:\n    >>> CalculateDotProduct(new List<int> {2, 5, 7}, new List<int> {3, 6, 8})\n    100",
      "sq": "Shkruani një funksion në C# `static int CalculateDotProduct(List<int> vectorA, List<int> vectorB)` për të zgjidhur problemin e mëposhtëm:\nLlogaritni prodhimin skalar të dy vektorëve të plotë n-dimensionalë.\n    Prodhimi skalar është shuma e produkteve të elementeve përkatëse të dy vektorëve.\n\n    Shembull 1:\n    >>> CalculateDotProduct(new List<int> {1, 3, -5}, new List<int> {4, -2, -1})\n    3\n\n    Shembull 2:\n    >>> CalculateDotProduct(new List<int> {2, 5, 7}, new List<int> {3, 6, 8})\n    100",
      "hy": "Գրեք C# ֆունկցիա `static int CalculateDotProduct(List<int> vectorA, List<int> vectorB)` հետևյալ խնդիրը լուծելու համար:\nՀաշվեք երկու n-չափանի ամբողջ թվերի վեկտորների կետային արտադրյալը։\n    Կետային արտադրյալը երկու վեկտորների համապատասխան տարրերի արտադրյալների գումարն է։\n\n    Օրինակ 1:\n    >>> CalculateDotProduct(new List<int> {1, 3, -5}, new List<int> {4, -2, -1})\n    3\n\n    Օրինակ 2:\n    >>> CalculateDotProduct(new List<int> {2, 5, 7}, new List<int> {3, 6, 8})\n    100",
      "bn": "একটি C# ফাংশন `static int CalculateDotProduct(List<int> vectorA, List<int> vectorB)` লিখুন নিম্নলিখিত সমস্যার সমাধান করতে:\nদুটি n-মাত্রিক পূর্ণসংখ্যা ভেক্টরের ডট গুণফল গণনা করুন।\n    ডট গুণফল হল দুটি ভেক্টরের সংশ্লিষ্ট উপাদানগুলির গুণফলের যোগফল।\n\n    উদাহরণ ১:\n    >>> CalculateDotProduct(new List<int> {1, 3, -5}, new List<int> {4, -2, -1})\n    3\n\n    উদাহরণ ২:\n    >>> CalculateDotProduct(new List<int> {2, 5, 7}, new List<int> {3, 6, 8})\n    100",
      "bg": "Напишете C# функция `static int CalculateDotProduct(List<int> vectorA, List<int> vectorB)`, за да решите следния проблем:\nИзчислете скаларното произведение на два n-мерни векторa от цели числа.\n    Скаларното произведение е сумата от произведенията на съответните елементи на двата вектора.\n\n    Пример 1:\n    >>> CalculateDotProduct(new List<int> {1, 3, -5}, new List<int> {4, -2, -1})\n    3\n\n    Пример 2:\n    >>> CalculateDotProduct(new List<int> {2, 5, 7}, new List<int> {3, 6, 8})\n    100",
      "zh": "编写一个 C# 函数 `static int CalculateDotProduct(List<int> vectorA, List<int> vectorB)` 来解决以下问题：\n计算两个 n 维整数向量的点积。\n点积是两个向量对应元素的乘积之和。\n\n示例 1:\n>>> CalculateDotProduct(new List<int> {1, 3, -5}, new List<int> {4, -2, -1})\n3\n\n示例 2:\n>>> CalculateDotProduct(new List<int> {2, 5, 7}, new List<int> {3, 6, 8})\n100",
      "fr": "Écrire une fonction C# `static int CalculateDotProduct(List<int> vectorA, List<int> vectorB)` pour résoudre le problème suivant :\nCalculer le produit scalaire de deux vecteurs entiers n-dimensionnels.\n    Le produit scalaire est la somme des produits des éléments correspondants des deux vecteurs.\n\n    Exemple 1 :\n    >>> CalculateDotProduct(new List<int> {1, 3, -5}, new List<int> {4, -2, -1})\n    3\n\n    Exemple 2 :\n    >>> CalculateDotProduct(new List<int> {2, 5, 7}, new List<int> {3, 6, 8})\n    100",
      "de": "Schreiben Sie eine C#-Funktion `static int CalculateDotProduct(List<int> vectorA, List<int> vectorB)`, um das folgende Problem zu lösen:\nBerechnen Sie das Skalarprodukt von zwei n-dimensionalen Ganzzahl-Vektoren.\n    Das Skalarprodukt ist die Summe der Produkte der entsprechenden Elemente der beiden Vektoren.\n\n    Beispiel 1:\n    >>> CalculateDotProduct(new List<int> {1, 3, -5}, new List<int> {4, -2, -1})\n    3\n\n    Beispiel 2:\n    >>> CalculateDotProduct(new List<int> {2, 5, 7}, new List<int> {3, 6, 8})\n    100",
      "ha": "Rubuta aikin C# `static int CalculateDotProduct(List<int> vectorA, List<int> vectorB)` don warware matsalar mai zuwa:\nƘididdige dot samfurin na vectors guda biyu masu n-dimension na integers.\n    Dot samfurin shine jumlar samfuran abubuwan da suka dace na vectors guda biyu.\n\n    Misali 1:\n    >>> CalculateDotProduct(new List<int> {1, 3, -5}, new List<int> {4, -2, -1})\n    3\n\n    Misali 2:\n    >>> CalculateDotProduct(new List<int> {2, 5, 7}, new List<int> {3, 6, 8})\n    100",
      "hi": "C# फ़ंक्शन `static int CalculateDotProduct(List<int> vectorA, List<int> vectorB)` लिखें ताकि निम्नलिखित समस्या का समाधान किया जा सके:\nदो n-आयामी पूर्णांक वेक्टरों का डॉट उत्पाद गणना करें।\n    डॉट उत्पाद दो वेक्टरों के संगत तत्वों के गुणनफल का योग होता है।\n\n    उदाहरण 1:\n    >>> CalculateDotProduct(new List<int> {1, 3, -5}, new List<int> {4, -2, -1})\n    3\n\n    उदाहरण 2:\n    >>> CalculateDotProduct(new List<int> {2, 5, 7}, new List<int> {3, 6, 8})\n    100",
      "hu": "Írj egy C# függvényt `static int CalculateDotProduct(List<int> vectorA, List<int> vectorB)` a következő probléma megoldására:\nSzámítsd ki két n-dimenziós egész szám vektor skaláris szorzatát.\n    A skaláris szorzat a két vektor megfelelő elemeinek szorzatainak összege.\n\n    1. példa:\n    >>> CalculateDotProduct(new List<int> {1, 3, -5}, new List<int> {4, -2, -1})\n    3\n\n    2. példa:\n    >>> CalculateDotProduct(new List<int> {2, 5, 7}, new List<int> {3, 6, 8})\n    100"
    },
    "instruction_bertscore": {
      "sq": "0.9949176444404603",
      "hy": "1",
      "bn": "1",
      "bg": "0.9935083618870177",
      "zh": "1",
      "fr": "1",
      "de": "1",
      "ha": "0.9944458972855025",
      "hi": "0.9868345797146266",
      "hu": "1"
    },
    "level": "easy",
    "test": "    static void Main()\n    {\n        Debug.Assert(CalculateDotProduct(new List<int> {1, 3, -5}, new List<int> {4, -2, -1}) == 3);\n        Debug.Assert(CalculateDotProduct(new List<int> {2, 5, 7}, new List<int> {3, 6, 8}) == 92);\n        Debug.Assert(CalculateDotProduct(new List<int> {0, 0, 0}, new List<int> {0, 0, 0}) == 0);\n        Debug.Assert(CalculateDotProduct(new List<int> {1, 2}, new List<int> {3, 4}) == 11);\n\n    }\n}",
    "entry_point": "CalculateDotProduct",
    "signature": "static int CalculateDotProduct(List<int> vectorA, List<int> vectorB)",
    "docstring": {
      "en": "Calculate the dot product of two n-dimensional integer vectors.\n    The dot product is the sum of the products of the corresponding elements of the two vectors.\n\n    Example 1:\n    >>> CalculateDotProduct(new List<int> {1, 3, -5}, new List<int> {4, -2, -1})\n    3\n\n    Example 2:\n    >>> CalculateDotProduct(new List<int> {2, 5, 7}, new List<int> {3, 6, 8})\n    100",
      "sq": "Llogarit produktin skalar të dy vektorëve të dimensionit n me numra të plotë.\n    Produkti skalar është shuma e produkteve të elementeve përkatëse të dy vektorëve.\n\n    Shembull 1:\n    >>> CalculateDotProduct(new List<int> {1, 3, -5}, new List<int> {4, -2, -1})\n    3\n\n    Shembull 2:\n    >>> CalculateDotProduct(new List<int> {2, 5, 7}, new List<int> {3, 6, 8})\n    100",
      "hy": "Հաշվարկել երկու n-չափանի ամբողջ թվերի վեկտորների կետային արտադրյալը։  \nԿետային արտադրյալը երկու վեկտորների համապատասխան տարրերի արտադրյալների գումարն է։\n\nՕրինակ 1:\n>>> CalculateDotProduct(new List<int> {1, 3, -5}, new List<int> {4, -2, -1})\n3\n\nՕրինակ 2:\n>>> CalculateDotProduct(new List<int> {2, 5, 7}, new List<int> {3, 6, 8})\n100",
      "bn": "n-মাত্রিক পূর্ণসংখ্যা ভেক্টরের দুটি ভেক্টরের ডট গুণফল গণনা করুন। \n    ডট গুণফল হল দুটি ভেক্টরের সংশ্লিষ্ট উপাদানগুলির গুণফলের যোগফল।\n\n    উদাহরণ 1:\n    >>> CalculateDotProduct(new List<int> {1, 3, -5}, new List<int> {4, -2, -1})\n    3\n\n    উদাহরণ 2:\n    >>> CalculateDotProduct(new List<int> {2, 5, 7}, new List<int> {3, 6, 8})\n    100",
      "bg": "Изчисляване на скаларното произведение на два n-мерни вектора от цели числа.  \n    Скаларното произведение е сумата от произведенията на съответстващите елементи на двата вектора.\n\n    Пример 1:\n    >>> CalculateDotProduct(new List<int> {1, 3, -5}, new List<int> {4, -2, -1})\n    3\n\n    Пример 2:\n    >>> CalculateDotProduct(new List<int> {2, 5, 7}, new List<int> {3, 6, 8})\n    100",
      "zh": "计算两个n维整数向量的点积。\n    点积是两个向量对应元素的乘积之和。\n\n    示例 1:\n    >>> CalculateDotProduct(new List<int> {1, 3, -5}, new List<int> {4, -2, -1})\n    3\n\n    示例 2:\n    >>> CalculateDotProduct(new List<int> {2, 5, 7}, new List<int> {3, 6, 8})\n    100",
      "fr": "Calculer le produit scalaire de deux vecteurs entiers n-dimensionnels.  \n    Le produit scalaire est la somme des produits des éléments correspondants des deux vecteurs.\n\n    Exemple 1 :\n    >>> CalculateDotProduct(new List<int> {1, 3, -5}, new List<int> {4, -2, -1})\n    3\n\n    Exemple 2 :\n    >>> CalculateDotProduct(new List<int> {2, 5, 7}, new List<int> {3, 6, 8})\n    100",
      "de": "Berechne das Skalarprodukt von zwei n-dimensionalen ganzzahligen Vektoren.\n    Das Skalarprodukt ist die Summe der Produkte der entsprechenden Elemente der beiden Vektoren.\n\n    Beispiel 1:\n    >>> CalculateDotProduct(new List<int> {1, 3, -5}, new List<int> {4, -2, -1})\n    3\n\n    Beispiel 2:\n    >>> CalculateDotProduct(new List<int> {2, 5, 7}, new List<int> {3, 6, 8})\n    100",
      "ha": "Ƙididdige samfurin dot na n-dimensional vectors na integers guda biyu.  \n    Samfurin dot shine jumlar samfuran abubuwan da suka dace na vectors guda biyu.\n\n    Misali 1:\n    >>> CalculateDotProduct(new List<int> {1, 3, -5}, new List<int> {4, -2, -1})\n    3\n\n    Misali 2:\n    >>> CalculateDotProduct(new List<int> {2, 5, 7}, new List<int> {3, 6, 8})\n    100",
      "hi": "दो n-आयामी पूर्णांक वेक्टरों का डॉट उत्पाद गणना करें।  \n    डॉट उत्पाद दो वेक्टरों के संगत तत्वों के गुणनफल का योग होता है।\n\n    उदाहरण 1:\n    >>> CalculateDotProduct(new List<int> {1, 3, -5}, new List<int> {4, -2, -1})\n    3\n\n    उदाहरण 2:\n    >>> CalculateDotProduct(new List<int> {2, 5, 7}, new List<int> {3, 6, 8})\n    100",
      "hu": "Számítsa ki két n-dimenziós egész szám vektor skaláris szorzatát.  \n    A skaláris szorzat a két vektor megfelelő elemeinek szorzatainak összege.\n\n    Példa 1:\n    >>> CalculateDotProduct(new List<int> {1, 3, -5}, new List<int> {4, -2, -1})\n    3\n\n    Példa 2:\n    >>> CalculateDotProduct(new List<int> {2, 5, 7}, new List<int> {3, 6, 8})\n    100"
    },
    "docstring_bertscore": {
      "sq": "0.9929553749062167",
      "hy": "1",
      "bn": "0.9813706551931188",
      "bg": "0.9912688043408494",
      "zh": "1",
      "fr": "1",
      "de": "1",
      "ha": "0.9921815109417047",
      "hi": "0.9921898534177082",
      "hu": "1"
    }
  },
  {
    "task_id": "C#/24",
    "prompt": {
      "en": "using System;\nusing System.Collections.Generic;\nusing System.Diagnostics;\nusing System.Numerics;\nclass Program\n{\n\n    \n\n    /* Calculate the value of 2 raised to the power of a given non-negative integer 'n'.\n    This function uses high-precision arithmetic to handle large exponents.\n    Examples:\n    >>> CalculatePowerOfTwo(3)\n    8\n    >>> CalculatePowerOfTwo(10)\n    1024\n    >>> CalculatePowerOfTwo(0)\n    1\n    */\n\n    static BigInteger CalculatePowerOfTwo(int n)",
      "sq": "using System;\nusing System.Collections.Generic;\nusing System.Diagnostics;\nusing System.Numerics;\nclass Program\n{\n\n    \n\n    /* Llogarit vlerën e 2 të ngritur në fuqinë e një numri të plotë jo-negativ 'n'.\n    Kjo funksion përdor aritmetikë me precizion të lartë për të trajtuar eksponentë të mëdhenj.\n    Shembuj:\n    >>> CalculatePowerOfTwo(3)\n    8\n    >>> CalculatePowerOfTwo(10)\n    1024\n    >>> CalculatePowerOfTwo(0)\n    1\n    */\n\n    static BigInteger CalculatePowerOfTwo(int n)",
      "hy": "using System;\nusing System.Collections.Generic;\nusing System.Diagnostics;\nusing System.Numerics;\nclass Program\n{\n\n    \n\n    /* Հաշվարկել 2-ի արժեքը բարձրացված տրված ոչ բացասական ամբողջ թիվ 'n'-ի աստիճանի:\n    Այս ֆունկցիան օգտագործում է բարձր ճշգրտության թվաբանություն՝ մեծ աստիճանները մշակելու համար:\n    Օրինակներ:\n    >>> CalculatePowerOfTwo(3)\n    8\n    >>> CalculatePowerOfTwo(10)\n    1024\n    >>> CalculatePowerOfTwo(0)\n    1\n    */\n\n    static BigInteger CalculatePowerOfTwo(int n)",
      "bn": "using System;\nusing System.Collections.Generic;\nusing System.Diagnostics;\nusing System.Numerics;\nclass Program\n{\n\n    \n\n    /* একটি প্রদত্ত অ-ঋণাত্মক পূর্ণসংখ্যা 'n' এর জন্য 2 এর ঘাতমূলের মান গণনা করুন।\n    এই ফাংশনটি বড় সূচকের জন্য উচ্চ-নির্ভুলতা গাণিতিক ব্যবহার করে।\n    উদাহরণ:\n    >>> CalculatePowerOfTwo(3)\n    8\n    >>> CalculatePowerOfTwo(10)\n    1024\n    >>> CalculatePowerOfTwo(0)\n    1\n    */\n\n    static BigInteger CalculatePowerOfTwo(int n)",
      "bg": "using System;\nusing System.Collections.Generic;\nusing System.Diagnostics;\nusing System.Numerics;\nclass Program\n{\n\n    \n\n    /* Изчислете стойността на 2, повдигнато на степен дадено неотрицателно цяло число 'n'.\n    Тази функция използва аритметика с висока прецизност, за да се справи с големи експоненти.\n    Примери:\n    >>> CalculatePowerOfTwo(3)\n    8\n    >>> CalculatePowerOfTwo(10)\n    1024\n    >>> CalculatePowerOfTwo(0)\n    1\n    */\n\n    static BigInteger CalculatePowerOfTwo(int n)",
      "zh": "using System;\nusing System.Collections.Generic;\nusing System.Diagnostics;\nusing System.Numerics;\nclass Program\n{\n\n    \n\n    /* 计算2的给定非负整数'n'次幂的值。\n    此函数使用高精度算法来处理大指数。\n    示例:\n    >>> CalculatePowerOfTwo(3)\n    8\n    >>> CalculatePowerOfTwo(10)\n    1024\n    >>> CalculatePowerOfTwo(0)\n    1\n    */\n\n    static BigInteger CalculatePowerOfTwo(int n)",
      "fr": "using System;\nusing System.Collections.Generic;\nusing System.Diagnostics;\nusing System.Numerics;\nclass Program\n{\n\n    \n\n    /* Calculer la valeur de 2 élevé à la puissance d'un entier non négatif 'n' donné.\n    Cette fonction utilise l'arithmétique de haute précision pour gérer les grands exposants.\n    Exemples :\n    >>> CalculatePowerOfTwo(3)\n    8\n    >>> CalculatePowerOfTwo(10)\n    1024\n    >>> CalculatePowerOfTwo(0)\n    1\n    */\n\n    static BigInteger CalculatePowerOfTwo(int n)",
      "de": "using System;\nusing System.Collections.Generic;\nusing System.Diagnostics;\nusing System.Numerics;\nclass Program\n{\n\n    \n\n    /* Berechnet den Wert von 2 hoch einer gegebenen nicht-negativen ganzen Zahl 'n'.\n    Diese Funktion verwendet Hochpräzisionsarithmetik, um mit großen Exponenten umzugehen.\n    Beispiele:\n    >>> CalculatePowerOfTwo(3)\n    8\n    >>> CalculatePowerOfTwo(10)\n    1024\n    >>> CalculatePowerOfTwo(0)\n    1\n    */\n\n    static BigInteger CalculatePowerOfTwo(int n)",
      "ha": "using System;\nusing System.Collections.Generic;\nusing System.Diagnostics;\nusing System.Numerics;\nclass Program\n{\n\n    \n\n    /* Lissafin darajar 2 da aka ɗaga zuwa ƙarfin wani cikakken lamba mara kyau 'n'.\n    Wannan aikin yana amfani da lissafin daidai don sarrafa manyan masu ƙarfi.\n    Misalai:\n    >>> CalculatePowerOfTwo(3)\n    8\n    >>> CalculatePowerOfTwo(10)\n    1024\n    >>> CalculatePowerOfTwo(0)\n    1\n    */\n\n    static BigInteger CalculatePowerOfTwo(int n)",
      "hi": "using System;\nusing System.Collections.Generic;\nusing System.Diagnostics;\nusing System.Numerics;\nclass Program\n{\n\n    \n\n    /* एक दिए गए गैर-ऋणात्मक पूर्णांक 'n' की शक्ति के लिए 2 का मान गणना करें।\n    यह फ़ंक्शन बड़े घातांक को संभालने के लिए उच्च-सटीक अंकगणित का उपयोग करता है।\n    उदाहरण:\n    >>> CalculatePowerOfTwo(3)\n    8\n    >>> CalculatePowerOfTwo(10)\n    1024\n    >>> CalculatePowerOfTwo(0)\n    1\n    */\n\n    static BigInteger CalculatePowerOfTwo(int n)",
      "hu": "using System;\nusing System.Collections.Generic;\nusing System.Diagnostics;\nusing System.Numerics;\nclass Program\n{\n\n    \n\n    /* Számítsa ki a 2 értékét egy adott nem negatív egész szám 'n' hatványára emelve.\n    Ez a függvény nagy pontosságú aritmetikát használ a nagy kitevők kezelésére.\n    Példák:\n    >>> CalculatePowerOfTwo(3)\n    8\n    >>> CalculatePowerOfTwo(10)\n    1024\n    >>> CalculatePowerOfTwo(0)\n    1\n    */\n\n    static BigInteger CalculatePowerOfTwo(int n)"
    },
    "prompt_bertscore": {
      "sq": "0.993435464537178",
      "hy": "0.9974311132820758",
      "bn": "0.9641335107269112",
      "bg": "1",
      "zh": "0.9831203902196552",
      "fr": "1",
      "de": "0.9879137385747891",
      "ha": "0.9739387008563175",
      "hi": "0.9961030705544766",
      "hu": "1"
    },
    "canonical_solution": "    {\n        BigInteger result = 1;\n        for (int i = 0; i < n; i++)\n        {\n            result *= 2;\n        }\n        return result;\n    }",
    "instruction": {
      "en": "Write a C# function `static BigInteger CalculatePowerOfTwo(int n)` to solve the following problem:\nCalculate the value of 2 raised to the power of a given non-negative integer 'n'.\n    This function uses high-precision arithmetic to handle large exponents.\n    Examples:\n    >>> CalculatePowerOfTwo(3)\n    8\n    >>> CalculatePowerOfTwo(10)\n    1024\n    >>> CalculatePowerOfTwo(0)\n    1",
      "sq": "Shkruani një funksion C# `static BigInteger CalculatePowerOfTwo(int n)` për të zgjidhur problemin e mëposhtëm:\nLlogaritni vlerën e 2 të ngritur në fuqinë e një numri të plotë jo-negativ 'n'.\n    Ky funksion përdor aritmetikë me precizion të lartë për të trajtuar eksponentët e mëdhenj.\n    Shembuj:\n    >>> CalculatePowerOfTwo(3)\n    8\n    >>> CalculatePowerOfTwo(10)\n    1024\n    >>> CalculatePowerOfTwo(0)\n    1",
      "hy": "Գրեք C# ֆունկցիա `static BigInteger CalculatePowerOfTwo(int n)` հետևյալ խնդիրը լուծելու համար:\nՀաշվեք 2-ի արժեքը, բարձրացված տրված ոչ բացասական ամբողջ թիվ 'n'-ի աստիճանի:\n    Այս ֆունկցիան օգտագործում է բարձր ճշգրտության թվաբանություն՝ մեծ աստիճաններ մշակելու համար:\n    Օրինակներ:\n    >>> CalculatePowerOfTwo(3)\n    8\n    >>> CalculatePowerOfTwo(10)\n    1024\n    >>> CalculatePowerOfTwo(0)\n    1",
      "bn": "C# ফাংশন `static BigInteger CalculatePowerOfTwo(int n)` লিখুন নিম্নলিখিত সমস্যার সমাধানের জন্য:\nএকটি প্রদত্ত অ-ঋণাত্মক পূর্ণসংখ্যা 'n' এর ঘাত হিসেবে 2 এর মান গণনা করুন।\n    এই ফাংশনটি বড় সূচকের জন্য উচ্চ-নির্ভুলতা গাণিতিক ব্যবহার করে।\n    উদাহরণসমূহ:\n    >>> CalculatePowerOfTwo(3)\n    8\n    >>> CalculatePowerOfTwo(10)\n    1024\n    >>> CalculatePowerOfTwo(0)\n    1",
      "bg": "Напишете C# функция `static BigInteger CalculatePowerOfTwo(int n)`, за да решите следния проблем:  \nИзчислете стойността на 2, повдигнато на степен на дадено неотрицателно цяло число 'n'.  \n    Тази функция използва аритметика с висока прецизност, за да се справи с големи експоненти.  \n    Примери:  \n    >>> CalculatePowerOfTwo(3)  \n    8  \n    >>> CalculatePowerOfTwo(10)  \n    1024  \n    >>> CalculatePowerOfTwo(0)  \n    1",
      "zh": "编写一个 C# 函数 `static BigInteger CalculatePowerOfTwo(int n)` 来解决以下问题：\n计算 2 的 n 次幂的值，其中 n 是给定的非负整数。\n    此函数使用高精度算法来处理大指数。\n    示例:\n    >>> CalculatePowerOfTwo(3)\n    8\n    >>> CalculatePowerOfTwo(10)\n    1024\n    >>> CalculatePowerOfTwo(0)\n    1",
      "fr": "Écrire une fonction C# `static BigInteger CalculatePowerOfTwo(int n)` pour résoudre le problème suivant :  \nCalculer la valeur de 2 élevé à la puissance d'un entier non négatif 'n' donné.  \n    Cette fonction utilise l'arithmétique de haute précision pour gérer les grands exposants.  \n    Exemples :  \n    >>> CalculatePowerOfTwo(3)  \n    8  \n    >>> CalculatePowerOfTwo(10)  \n    1024  \n    >>> CalculatePowerOfTwo(0)  \n    1  ",
      "de": "Schreiben Sie eine C#-Funktion `static BigInteger CalculatePowerOfTwo(int n)`, um das folgende Problem zu lösen:\nBerechnen Sie den Wert von 2 hoch einer gegebenen nicht-negativen ganzen Zahl 'n'.\n    Diese Funktion verwendet Hochpräzisionsarithmetik, um große Exponenten zu verarbeiten.\n    Beispiele:\n    >>> CalculatePowerOfTwo(3)\n    8\n    >>> CalculatePowerOfTwo(10)\n    1024\n    >>> CalculatePowerOfTwo(0)\n    1",
      "ha": "Rubuta aikin C# `static BigInteger CalculatePowerOfTwo(int n)` don warware matsalar mai zuwa:\nƘididdige darajar 2 da aka ɗaga zuwa ƙarfin wani baƙaƙen lamba mara kyau 'n'.\n    Wannan aikin yana amfani da lissafi mai daidaito mai girma don sarrafa manyan masu nuni.\n    Misalai:\n    >>> CalculatePowerOfTwo(3)\n    8\n    >>> CalculatePowerOfTwo(10)\n    1024\n    >>> CalculatePowerOfTwo(0)\n    1",
      "hi": "C# फ़ंक्शन `static BigInteger CalculatePowerOfTwo(int n)` लिखें ताकि निम्नलिखित समस्या का समाधान किया जा सके:\nदिए गए गैर-ऋणात्मक पूर्णांक 'n' के लिए 2 की घात का मान गणना करें।\n    यह फ़ंक्शन बड़े घातांकों को संभालने के लिए उच्च-सटीकता अंकगणित का उपयोग करता है।\n    उदाहरण:\n    >>> CalculatePowerOfTwo(3)\n    8\n    >>> CalculatePowerOfTwo(10)\n    1024\n    >>> CalculatePowerOfTwo(0)\n    1",
      "hu": "Írj egy C# függvényt `static BigInteger CalculatePowerOfTwo(int n)` a következő probléma megoldására:\nSzámítsd ki a 2 értékét egy adott nem negatív egész szám 'n' hatványára emelve.\n    Ez a függvény nagy pontosságú aritmetikát használ a nagy kitevők kezelésére.\n    Példák:\n    >>> CalculatePowerOfTwo(3)\n    8\n    >>> CalculatePowerOfTwo(10)\n    1024\n    >>> CalculatePowerOfTwo(0)\n    1"
    },
    "instruction_bertscore": {
      "sq": "0.9945279316328699",
      "hy": "1",
      "bn": "0.9803973663260479",
      "bg": "0.9977004560787591",
      "zh": "0.9588787439966333",
      "fr": "1",
      "de": "0.9896086516161599",
      "ha": "0.981633641817609",
      "hi": "0.9843352136300646",
      "hu": "1"
    },
    "level": "easy",
    "test": "    static void Main()\n    {           \n        Debug.Assert(CalculatePowerOfTwo(3).Equals(new BigInteger(8)));\n        Debug.Assert(CalculatePowerOfTwo(10).Equals(new BigInteger(1024)));\n        Debug.Assert(CalculatePowerOfTwo(15).Equals(new BigInteger(32768)));\n        Debug.Assert(CalculatePowerOfTwo(0).Equals(new BigInteger(1)));\n\n    }\n}\n",
    "entry_point": "CalculatePowerOfTwo",
    "signature": "static BigInteger CalculatePowerOfTwo(int n)",
    "docstring": {
      "en": "Calculate the value of 2 raised to the power of a given non-negative integer 'n'.\n    This function uses high-precision arithmetic to handle large exponents.\n    Examples:\n    >>> CalculatePowerOfTwo(3)\n    8\n    >>> CalculatePowerOfTwo(10)\n    1024\n    >>> CalculatePowerOfTwo(0)\n    1",
      "sq": "Llogarit vlerën e 2 të ngritur në fuqinë e një numri të plotë jo-negativ 'n'.\n    Kjo funksion përdor aritmetikë me precizion të lartë për të trajtuar eksponentët e mëdhenj.\n    Shembuj:\n    >>> CalculatePowerOfTwo(3)\n    8\n    >>> CalculatePowerOfTwo(10)\n    1024\n    >>> CalculatePowerOfTwo(0)\n    1",
      "hy": "Հաշվարկել 2-ի արժեքը բարձրացված տրված ոչ բացասական ամբողջ թիվ 'n'-ի աստիճանի։\n    Այս ֆունկցիան օգտագործում է բարձր ճշգրտության թվաբանություն մեծ աստիճաններ մշակելու համար։\n    Օրինակներ:\n    >>> CalculatePowerOfTwo(3)\n    8\n    >>> CalculatePowerOfTwo(10)\n    1024\n    >>> CalculatePowerOfTwo(0)\n    1",
      "bn": "একটি প্রদত্ত অ-ঋণাত্মক পূর্ণসংখ্যা 'n' এর জন্য 2 এর ঘাতমূলের মান গণনা করুন।\n    এই ফাংশনটি বড় সূচকগুলি পরিচালনা করার জন্য উচ্চ-নির্ভুলতার গাণিতিক ব্যবহার করে।\n    উদাহরণস্বরূপ:\n    >>> CalculatePowerOfTwo(3)\n    8\n    >>> CalculatePowerOfTwo(10)\n    1024\n    >>> CalculatePowerOfTwo(0)\n    1",
      "bg": "Изчислява стойността на 2, повдигнато на степен на дадено неотрицателно цяло число 'n'.\n    Тази функция използва аритметика с висока прецизност за обработка на големи експоненти.\n    Примери:\n    >>> CalculatePowerOfTwo(3)\n    8\n    >>> CalculatePowerOfTwo(10)\n    1024\n    >>> CalculatePowerOfTwo(0)\n    1",
      "zh": "计算2的给定非负整数'n'次幂的值。\n    此函数使用高精度算术来处理大指数。\n    示例：\n    >>> CalculatePowerOfTwo(3)\n    8\n    >>> CalculatePowerOfTwo(10)\n    1024\n    >>> CalculatePowerOfTwo(0)\n    1",
      "fr": "Calculez la valeur de 2 élevé à la puissance d'un entier non négatif 'n'.\n    Cette fonction utilise l'arithmétique de haute précision pour gérer les grands exposants.\n    Exemples:\n    >>> CalculatePowerOfTwo(3)\n    8\n    >>> CalculatePowerOfTwo(10)\n    1024\n    >>> CalculatePowerOfTwo(0)\n    1",
      "de": "Berechnet den Wert von 2 hoch einer gegebenen nicht-negativen ganzen Zahl 'n'.\n    Diese Funktion verwendet Hochpräzisionsarithmetik, um mit großen Exponenten umzugehen.\n    Beispiele:\n    >>> CalculatePowerOfTwo(3)\n    8\n    >>> CalculatePowerOfTwo(10)\n    1024\n    >>> CalculatePowerOfTwo(0)\n    1",
      "ha": "Ƙididdige ƙimar 2 da aka ɗaga zuwa ƙarfin wani baƙaƙen lamba mara kyau 'n'.\n    Wannan aikin yana amfani da lissafin daidai sosai don sarrafa manyan masu ƙarfi.\n    Misalai:\n    >>> CalculatePowerOfTwo(3)\n    8\n    >>> CalculatePowerOfTwo(10)\n    1024\n    >>> CalculatePowerOfTwo(0)\n    1",
      "hi": "एक दिए गए गैर-ऋणात्मक पूर्णांक 'n' की शक्ति के लिए 2 का मान गणना करें।\n    यह फ़ंक्शन बड़े घातांक को संभालने के लिए उच्च-सटीक अंकगणित का उपयोग करता है।\n    उदाहरण:\n    >>> CalculatePowerOfTwo(3)\n    8\n    >>> CalculatePowerOfTwo(10)\n    1024\n    >>> CalculatePowerOfTwo(0)\n    1",
      "hu": "Számítsa ki a 2 értékét egy adott nem negatív egész szám 'n' hatványára emelve.\n    Ez a függvény nagy pontosságú aritmetikát használ a nagy kitevők kezelésére.\n    Példák:\n    >>> CalculatePowerOfTwo(3)\n    8\n    >>> CalculatePowerOfTwo(10)\n    1024\n    >>> CalculatePowerOfTwo(0)\n    1"
    },
    "docstring_bertscore": {
      "sq": "0.9833510000920367",
      "hy": "1",
      "bn": "0.9920531957155562",
      "bg": "0.9969891606842731",
      "zh": "0.9976281546200624",
      "fr": "0.9912008727505355",
      "de": "0.9826430814140283",
      "ha": "0.9757426619768763",
      "hi": "0.9976281546200624",
      "hu": "1"
    }
  },
  {
    "task_id": "C#/25",
    "prompt": {
      "en": "using System;\nusing System.Collections.Generic;\nusing System.Diagnostics;\n\nclass Program\n{\n\n/* Finds the first character in a string that appears only once.\n   If all characters appear more than once or the string is empty, it returns 'no' as a character.\n   Examples:\n   - FirstUniqueChar(\"aabbcdde\") should return 'c'.\n   - FirstUniqueChar(\"aabbcc\") should return 'n', representing \"no\".\n   - FirstUniqueChar(\"xxyyzz\") should return 'n'.\n   - FirstUniqueChar(\"\") should return 'n'.\n*/\n    static char FirstUniqueChar(string str)",
      "sq": "using System;\nusing System.Collections.Generic;\nusing System.Diagnostics;\n\nclass Program\n{\n\n/* Gjen karakterin e parë në një varg që shfaqet vetëm një herë.\n   Nëse të gjithë karakteret shfaqen më shumë se një herë ose vargu është bosh, kthen 'n' si karakter.\n   Shembuj:\n   - FirstUniqueChar(\"aabbcdde\") duhet të kthejë 'c'.\n   - FirstUniqueChar(\"aabbcc\") duhet të kthejë 'n', që përfaqëson \"jo\".\n   - FirstUniqueChar(\"xxyyzz\") duhet të kthejë 'n'.\n   - FirstUniqueChar(\"\") duhet të kthejë 'n'.\n*/\n    static char FirstUniqueChar(string str)",
      "hy": "using System;\nusing System.Collections.Generic;\nusing System.Diagnostics;\n\nclass Program\n{\n\n/* Գտնում է տողում առաջին նշանը, որը հայտնվում է միայն մեկ անգամ։\n   Եթե բոլոր նշանները հայտնվում են մեկից ավելի անգամ կամ տողը դատարկ է, վերադարձնում է 'no' որպես նշան։\n   Օրինակներ:\n   - FirstUniqueChar(\"aabbcdde\") պետք է վերադարձնի 'c'։\n   - FirstUniqueChar(\"aabbcc\") պետք է վերադարձնի 'n', որը ներկայացնում է \"ոչ\"։\n   - FirstUniqueChar(\"xxyyzz\") պետք է վերադարձնի 'n'։\n   - FirstUniqueChar(\"\") պետք է վերադարձնի 'n'։\n*/\n    static char FirstUniqueChar(string str)",
      "bn": "using System;\nusing System.Collections.Generic;\nusing System.Diagnostics;\n\nclass Program\n{\n\n/* একটি স্ট্রিং-এ প্রথম যে অক্ষরটি কেবল একবারই উপস্থিত হয় তা খুঁজে বের করে।\n   যদি সব অক্ষর একাধিকবার উপস্থিত হয় বা স্ট্রিংটি খালি হয়, তাহলে এটি 'no' একটি অক্ষর হিসেবে ফেরত দেয়।\n   উদাহরণ:\n   - FirstUniqueChar(\"aabbcdde\") 'c' ফেরত দেবে।\n   - FirstUniqueChar(\"aabbcc\") 'n' ফেরত দেবে, যা \"no\" নির্দেশ করে।\n   - FirstUniqueChar(\"xxyyzz\") 'n' ফেরত দেবে।\n   - FirstUniqueChar(\"\") 'n' ফেরত দেবে।\n*/\n    static char FirstUniqueChar(string str)",
      "bg": "using System;\nusing System.Collections.Generic;\nusing System.Diagnostics;\n\nclass Program\n{\n\n/* Намира първия символ в низ, който се появява само веднъж.\n   Ако всички символи се появяват повече от веднъж или низът е празен, връща 'n' като символ.\n   Примери:\n   - FirstUniqueChar(\"aabbcdde\") трябва да върне 'c'.\n   - FirstUniqueChar(\"aabbcc\") трябва да върне 'n', представляващо \"не\".\n   - FirstUniqueChar(\"xxyyzz\") трябва да върне 'n'.\n   - FirstUniqueChar(\"\") трябва да върне 'n'.\n*/\n    static char FirstUniqueChar(string str)",
      "zh": "using System;\nusing System.Collections.Generic;\nusing System.Diagnostics;\n\nclass Program\n{\n\n/* 找到字符串中仅出现一次的第一个字符。\n   如果所有字符出现多次或字符串为空，则返回字符 'n'，表示“无”。\n   示例:\n   - FirstUniqueChar(\"aabbcdde\") 应返回 'c'。\n   - FirstUniqueChar(\"aabbcc\") 应返回 'n'，表示“无”。\n   - FirstUniqueChar(\"xxyyzz\") 应返回 'n'。\n   - FirstUniqueChar(\"\") 应返回 'n'。\n*/\n    static char FirstUniqueChar(string str)",
      "fr": "using System;\nusing System.Collections.Generic;\nusing System.Diagnostics;\n\nclass Program\n{\n\n/* Trouve le premier caractère dans une chaîne qui apparaît une seule fois.\n   Si tous les caractères apparaissent plus d'une fois ou si la chaîne est vide, il retourne 'n' comme caractère.\n   Exemples :\n   - FirstUniqueChar(\"aabbcdde\") devrait retourner 'c'.\n   - FirstUniqueChar(\"aabbcc\") devrait retourner 'n', représentant \"non\".\n   - FirstUniqueChar(\"xxyyzz\") devrait retourner 'n'.\n   - FirstUniqueChar(\"\") devrait retourner 'n'.\n*/\n    static char FirstUniqueChar(string str)",
      "de": "using System;\nusing System.Collections.Generic;\nusing System.Diagnostics;\n\nclass Program\n{\n\n/* Findet das erste Zeichen in einem String, das nur einmal vorkommt.\n   Wenn alle Zeichen mehr als einmal vorkommen oder der String leer ist, gibt es 'n' als Zeichen zurück.\n   Beispiele:\n   - FirstUniqueChar(\"aabbcdde\") sollte 'c' zurückgeben.\n   - FirstUniqueChar(\"aabbcc\") sollte 'n' zurückgeben, was \"nein\" repräsentiert.\n   - FirstUniqueChar(\"xxyyzz\") sollte 'n' zurückgeben.\n   - FirstUniqueChar(\"\") sollte 'n' zurückgeben.\n*/\n    static char FirstUniqueChar(string str)",
      "ha": "using System;\nusing System.Collections.Generic;\nusing System.Diagnostics;\n\nclass Program\n{\n\n/* Nemo harafin farko a cikin wani kirtani wanda ya bayyana sau daya kawai.\n   Idan duk haruffa sun bayyana fiye da sau daya ko kuma kirtanin babu komai, zai dawo da 'no' a matsayin harafi.\n   Misalai:\n   - FirstUniqueChar(\"aabbcdde\") ya kamata ya dawo da 'c'.\n   - FirstUniqueChar(\"aabbcc\") ya kamata ya dawo da 'n', yana nufin \"no\".\n   - FirstUniqueChar(\"xxyyzz\") ya kamata ya dawo da 'n'.\n   - FirstUniqueChar(\"\") ya kamata ya dawo da 'n'.\n*/\n    static char FirstUniqueChar(string str)",
      "hi": "using System;\nusing System.Collections.Generic;\nusing System.Diagnostics;\n\nclass Program\n{\n\n/* एक स्ट्रिंग में पहला ऐसा अक्षर ढूंढता है जो केवल एक बार आता है।\n   यदि सभी अक्षर एक से अधिक बार आते हैं या स्ट्रिंग खाली है, तो यह 'no' के रूप में एक अक्षर लौटाता है।\n   उदाहरण:\n   - FirstUniqueChar(\"aabbcdde\") को 'c' लौटाना चाहिए।\n   - FirstUniqueChar(\"aabbcc\") को 'n' लौटाना चाहिए, जो \"no\" का प्रतिनिधित्व करता है।\n   - FirstUniqueChar(\"xxyyzz\") को 'n' लौटाना चाहिए।\n   - FirstUniqueChar(\"\") को 'n' लौटाना चाहिए।\n*/\n    static char FirstUniqueChar(string str)",
      "hu": "using System;\nusing System.Collections.Generic;\nusing System.Diagnostics;\n\nclass Program\n{\n\n/* Megkeresi az első karaktert egy sztringben, amely csak egyszer fordul elő.\n   Ha minden karakter többször fordul elő, vagy a sztring üres, akkor 'n'-t ad vissza karakterként.\n   Példák:\n   - FirstUniqueChar(\"aabbcdde\") 'c'-t kell visszaadjon.\n   - FirstUniqueChar(\"aabbcc\") 'n'-t kell visszaadjon, ami \"nincs\"-et jelent.\n   - FirstUniqueChar(\"xxyyzz\") 'n'-t kell visszaadjon.\n   - FirstUniqueChar(\"\") 'n'-t kell visszaadjon.\n*/\n    static char FirstUniqueChar(string str)"
    },
    "prompt_bertscore": {
      "sq": "0.9882426704857828",
      "hy": "0.9854060300142237",
      "bn": "0.9744398453076685",
      "bg": "0.9883807186006022",
      "zh": "0.9503157882702192",
      "fr": "0.9916390513710984",
      "de": "0.9865912574978588",
      "ha": "0.9833430548767953",
      "hi": "0.973264350712704",
      "hu": "0.9737710568147241"
    },
    "canonical_solution": "    {\n        if (string.IsNullOrEmpty(str))\n            return 'n';\n\n        Dictionary<char, int> charCount = new Dictionary<char, int>();\n        foreach (char c in str)\n        {\n            if (charCount.ContainsKey(c))\n                charCount[c]++;\n            else\n                charCount[c] = 1;\n        }\n\n        foreach (char c in str)\n        {\n            if (charCount[c] == 1)\n                return c;\n        }\n\n        return 'n';\n    }",
    "instruction": {
      "en": "Write a C# function `static char FirstUniqueChar(string str)` to solve the following problem:\nFinds the first character in a string that appears only once.\n   If all characters appear more than once or the string is empty, it returns 'no' as a character.\n   Examples:\n   - FirstUniqueChar(\"aabbcdde\") should return 'c'.\n   - FirstUniqueChar(\"aabbcc\") should return 'n', representing \"no\".\n   - FirstUniqueChar(\"xxyyzz\") should return 'n'.\n   - FirstUniqueChar(\"\") should return 'n'.",
      "sq": "Shkruani një funksion në C# `static char FirstUniqueChar(string str)` për të zgjidhur problemin në vijim:\nGjen karakterin e parë në një varg që shfaqet vetëm një herë.\n   Nëse të gjithë karakteret shfaqen më shumë se një herë ose vargu është bosh, kthen 'n' si një karakter.\n   Shembuj:\n   - FirstUniqueChar(\"aabbcdde\") duhet të kthejë 'c'.\n   - FirstUniqueChar(\"aabbcc\") duhet të kthejë 'n', që përfaqëson \"no\".\n   - FirstUniqueChar(\"xxyyzz\") duhet të kthejë 'n'.\n   - FirstUniqueChar(\"\") duhet të kthejë 'n'.",
      "hy": "Գրեք C# ֆունկցիա `static char FirstUniqueChar(string str)`՝ հետևյալ խնդիրը լուծելու համար:\nԳտնում է տողում առաջին նիշը, որը հայտնվում է միայն մեկ անգամ:\n   Եթե բոլոր նիշերը հայտնվում են ավելի քան մեկ անգամ կամ տողը դատարկ է, վերադարձնում է 'no' որպես նիշ:\n   Օրինակներ:\n   - FirstUniqueChar(\"aabbcdde\") պետք է վերադարձնի 'c'.\n   - FirstUniqueChar(\"aabbcc\") պետք է վերադարձնի 'n', որը ներկայացնում է \"no\".\n   - FirstUniqueChar(\"xxyyzz\") պետք է վերադարձնի 'n'.\n   - FirstUniqueChar(\"\") պետք է վերադարձնի 'n'.",
      "bn": "C# ফাংশন `static char FirstUniqueChar(string str)` লিখুন নিম্নলিখিত সমস্যার সমাধানের জন্য:\nএকটি স্ট্রিংয়ে প্রথম যে অক্ষরটি শুধুমাত্র একবার উপস্থিত হয় তা খুঁজে বের করে।\n   যদি সমস্ত অক্ষর একাধিকবার উপস্থিত হয় বা স্ট্রিংটি খালি হয়, এটি একটি অক্ষর হিসাবে 'no' ফেরত দেয়।\n   উদাহরণসমূহ:\n   - FirstUniqueChar(\"aabbcdde\") 'c' ফেরত দেবে।\n   - FirstUniqueChar(\"aabbcc\") 'n' ফেরত দেবে, যা \"no\" কে উপস্থাপন করে।\n   - FirstUniqueChar(\"xxyyzz\") 'n' ফেরত দেবে।\n   - FirstUniqueChar(\"\") 'n' ফেরত দেবে।",
      "bg": "Напишете C# функция `static char FirstUniqueChar(string str)`, за да решите следния проблем:\nНамира първия символ в низ, който се появява само веднъж.\n   Ако всички символи се появяват повече от веднъж или низът е празен, връща 'n' като символ.\n   Примери:\n   - FirstUniqueChar(\"aabbcdde\") трябва да върне 'c'.\n   - FirstUniqueChar(\"aabbcc\") трябва да върне 'n', представляващ \"no\".\n   - FirstUniqueChar(\"xxyyzz\") трябва да върне 'n'.\n   - FirstUniqueChar(\"\") трябва да върне 'n'.",
      "zh": "编写一个 C# 函数 `static char FirstUniqueChar(string str)` 来解决以下问题：\n找到字符串中第一个只出现一次的字符。\n如果所有字符都出现多次或字符串为空，则返回字符 'no'。\n示例：\n- FirstUniqueChar(\"aabbcdde\") 应返回 'c'。\n- FirstUniqueChar(\"aabbcc\") 应返回 'n'，表示“no”。\n- FirstUniqueChar(\"xxyyzz\") 应返回 'n'。\n- FirstUniqueChar(\"\") 应返回 'n'。",
      "fr": "Écrivez une fonction C# `static char FirstUniqueChar(string str)` pour résoudre le problème suivant :  \nTrouve le premier caractère dans une chaîne qui apparaît une seule fois.  \nSi tous les caractères apparaissent plus d'une fois ou si la chaîne est vide, elle retourne 'n' comme caractère.  \nExemples :  \n- FirstUniqueChar(\"aabbcdde\") devrait retourner 'c'.  \n- FirstUniqueChar(\"aabbcc\") devrait retourner 'n', représentant \"no\".  \n- FirstUniqueChar(\"xxyyzz\") devrait retourner 'n'.  \n- FirstUniqueChar(\"\") devrait retourner 'n'.",
      "de": "Schreiben Sie eine C#-Funktion `static char FirstUniqueChar(string str)`, um das folgende Problem zu lösen:\nFindet das erste Zeichen in einem String, das nur einmal vorkommt.\n   Wenn alle Zeichen mehr als einmal vorkommen oder der String leer ist, gibt es 'n' als Zeichen zurück.\n   Beispiele:\n   - FirstUniqueChar(\"aabbcdde\") sollte 'c' zurückgeben.\n   - FirstUniqueChar(\"aabbcc\") sollte 'n' zurückgeben, was \"nein\" bedeutet.\n   - FirstUniqueChar(\"xxyyzz\") sollte 'n' zurückgeben.\n   - FirstUniqueChar(\"\") sollte 'n' zurückgeben.",
      "ha": "Rubuta aikin C# `static char FirstUniqueChar(string str)` don warware matsalar mai zuwa:  \nNemo harafin farko a cikin wani igiya wanda ya bayyana sau ɗaya kawai.  \nIdan duk haruffa sun bayyana fiye da sau ɗaya ko kuma igiyar babu komai, zai dawo da 'n' a matsayin harafi.  \nMisalai:  \n- FirstUniqueChar(\"aabbcdde\") ya kamata ya dawo da 'c'.  \n- FirstUniqueChar(\"aabbcc\") ya kamata ya dawo da 'n', yana wakiltar \"no\".  \n- FirstUniqueChar(\"xxyyzz\") ya kamata ya dawo da 'n'.  \n- FirstUniqueChar(\"\") ya kamata ya dawo da 'n'.  ",
      "hi": "C# फ़ंक्शन `static char FirstUniqueChar(string str)` लिखें ताकि निम्नलिखित समस्या का समाधान किया जा सके:\nएक स्ट्रिंग में पहला ऐसा वर्ण खोजें जो केवल एक बार आता है।\n   यदि सभी वर्ण एक से अधिक बार आते हैं या स्ट्रिंग खाली है, तो यह 'no' को एक वर्ण के रूप में लौटाता है।\n   उदाहरण:\n   - FirstUniqueChar(\"aabbcdde\") 'c' लौटाना चाहिए।\n   - FirstUniqueChar(\"aabbcc\") 'n' लौटाना चाहिए, जो \"no\" का प्रतिनिधित्व करता है।\n   - FirstUniqueChar(\"xxyyzz\") 'n' लौटाना चाहिए।\n   - FirstUniqueChar(\"\") 'n' लौटाना चाहिए।",
      "hu": "Írj egy C# függvényt `static char FirstUniqueChar(string str)` a következő probléma megoldására:\nMegtalálja az első karaktert egy karakterláncban, amely csak egyszer fordul elő.\n   Ha minden karakter többször fordul elő, vagy a karakterlánc üres, akkor 'no'-t ad vissza karakterként.\n   Példák:\n   - FirstUniqueChar(\"aabbcdde\") 'c'-t kell, hogy visszaadjon.\n   - FirstUniqueChar(\"aabbcc\") 'n'-t kell, hogy visszaadjon, ami \"no\"-t jelent.\n   - FirstUniqueChar(\"xxyyzz\") 'n'-t kell, hogy visszaadjon.\n   - FirstUniqueChar(\"\") 'n'-t kell, hogy visszaadjon."
    },
    "instruction_bertscore": {
      "sq": "0.9834648153003697",
      "hy": "0.9837663362187806",
      "bn": "0.9666092397961301",
      "bg": "0.9883350336129642",
      "zh": "0.9581896952048233",
      "fr": "0.9891299523978657",
      "de": "0.9799244273888038",
      "ha": "0.9788635425236966",
      "hi": "0.9698332095107074",
      "hu": "0.9802430305199838"
    },
    "level": "middle",
    "test": "    static void Main()\n    {\n        Debug.Assert(FirstUniqueChar(\"aabbcdde\") == 'c');\n        Debug.Assert(FirstUniqueChar(\"aabbcc\") == 'n');\n        Debug.Assert(FirstUniqueChar(\"xxyyazz\") == 'a');\n        Debug.Assert(FirstUniqueChar(\"\") == 'n');\n        Debug.Assert(FirstUniqueChar(\"aabbcceeddf\") == 'f');\n\n    }\n}",
    "entry_point": "FirstUniqueChar",
    "signature": "static char FirstUniqueChar(string str)",
    "docstring": {
      "en": "Finds the first character in a string that appears only once.\n   If all characters appear more than once or the string is empty, it returns 'no' as a character.\n   Examples:\n   - FirstUniqueChar(\"aabbcdde\") should return 'c'.\n   - FirstUniqueChar(\"aabbcc\") should return 'n', representing \"no\".\n   - FirstUniqueChar(\"xxyyzz\") should return 'n'.\n   - FirstUniqueChar(\"\") should return 'n'.",
      "sq": "Gjen karakterin e parë në një varg që shfaqet vetëm një herë. \n   Nëse të gjithë karakteret shfaqen më shumë se një herë ose vargu është bosh, kthen 'n' si një karakter.\n   Shembuj:\n   - FirstUniqueChar(\"aabbcdde\") duhet të kthejë 'c'.\n   - FirstUniqueChar(\"aabbcc\") duhet të kthejë 'n', që përfaqëson \"jo\".\n   - FirstUniqueChar(\"xxyyzz\") duhet të kthejë 'n'.\n   - FirstUniqueChar(\"\") duhet të kthejë 'n'.",
      "hy": "Գտնում է տողում առաջին սիմվոլը, որը հայտնվում է միայն մեկ անգամ:\n   Եթե բոլոր սիմվոլները հայտնվում են մեկից ավելի անգամ կամ տողը դատարկ է, վերադարձնում է 'n' որպես սիմվոլ:\n   Օրինակներ:\n   - FirstUniqueChar(\"aabbcdde\") պետք է վերադարձնի 'c':\n   - FirstUniqueChar(\"aabbcc\") պետք է վերադարձնի 'n', որը ներկայացնում է \"ոչ\":\n   - FirstUniqueChar(\"xxyyzz\") պետք է վերադարձնի 'n':\n   - FirstUniqueChar(\"\") պետք է վերադարձնի 'n':",
      "bn": "প্রথম যে অক্ষরটি শুধুমাত্র একবার প্রদর্শিত হয় তা একটি স্ট্রিংয়ে খুঁজে বের করে।\n   যদি সমস্ত অক্ষর একাধিকবার প্রদর্শিত হয় বা স্ট্রিংটি খালি হয়, এটি একটি অক্ষর হিসাবে 'n' ফেরত দেয়।\n   উদাহরণ:\n   - FirstUniqueChar(\"aabbcdde\") 'c' ফেরত দেবে।\n   - FirstUniqueChar(\"aabbcc\") 'n' ফেরত দেবে, যা \"no\" নির্দেশ করে।\n   - FirstUniqueChar(\"xxyyzz\") 'n' ফেরত দেবে।\n   - FirstUniqueChar(\"\") 'n' ফেরত দেবে।",
      "bg": "Намира първия символ в низ, който се появява само веднъж.\n   Ако всички символи се появяват повече от веднъж или низът е празен, връща 'n' като символ.\n   Примери:\n   - FirstUniqueChar(\"aabbcdde\") трябва да върне 'c'.\n   - FirstUniqueChar(\"aabbcc\") трябва да върне 'n', представляващо \"не\".\n   - FirstUniqueChar(\"xxyyzz\") трябва да върне 'n'.\n   - FirstUniqueChar(\"\") трябва да върне 'n'.",
      "zh": "找到字符串中仅出现一次的第一个字符。\n如果所有字符都出现多次或字符串为空，则返回字符 'n'，表示“没有”。\n示例：\n- FirstUniqueChar(\"aabbcdde\") 应返回 'c'。\n- FirstUniqueChar(\"aabbcc\") 应返回 'n'，表示“没有”。\n- FirstUniqueChar(\"xxyyzz\") 应返回 'n'。\n- FirstUniqueChar(\"\") 应返回 'n'。",
      "fr": "Trouve le premier caractère dans une chaîne qui apparaît une seule fois.\n   Si tous les caractères apparaissent plus d'une fois ou si la chaîne est vide, elle retourne 'n' comme caractère.\n   Exemples :\n   - FirstUniqueChar(\"aabbcdde\") devrait retourner 'c'.\n   - FirstUniqueChar(\"aabbcc\") devrait retourner 'n', représentant \"non\".\n   - FirstUniqueChar(\"xxyyzz\") devrait retourner 'n'.\n   - FirstUniqueChar(\"\") devrait retourner 'n'.",
      "de": "Findet das erste Zeichen in einem String, das nur einmal vorkommt.\n   Wenn alle Zeichen mehr als einmal vorkommen oder der String leer ist, gibt es 'n' als Zeichen zurück.\n   Beispiele:\n   - FirstUniqueChar(\"aabbcdde\") sollte 'c' zurückgeben.\n   - FirstUniqueChar(\"aabbcc\") sollte 'n' zurückgeben, was \"nein\" repräsentiert.\n   - FirstUniqueChar(\"xxyyzz\") sollte 'n' zurückgeben.\n   - FirstUniqueChar(\"\") sollte 'n' zurückgeben.",
      "ha": "Nemo harafin farko a cikin wani kirtani wanda ya bayyana sau daya kawai.\n   Idan duk haruffa sun bayyana fiye da sau ɗaya ko kuma igiyar tana komai, yana dawowa da 'n' a matsayin hali.  \n   Misalai:  \n   - FirstUniqueChar(\"aabbcdde\") ya kamata ya dawo da 'c'.  \n   - FirstUniqueChar(\"aabbcc\") ya kamata ya dawo da 'n', yana wakiltar \"no\".  \n   - FirstUniqueChar(\"xxyyzz\") ya kamata ya dawo da 'n'.  \n   - FirstUniqueChar(\"\") ya kamata ya dawo da 'n'.  ",
      "hi": "पहली बार एक स्ट्रिंग में ऐसा अक्षर ढूंढता है जो केवल एक बार प्रकट होता है।\n   यदि सभी अक्षर एक से अधिक बार प्रकट होते हैं या स्ट्रिंग खाली है, तो यह 'no' के रूप में एक अक्षर लौटाता है।\n   उदाहरण:\n   - FirstUniqueChar(\"aabbcdde\") को 'c' लौटाना चाहिए।\n   - FirstUniqueChar(\"aabbcc\") को 'n' लौटाना चाहिए, जो \"no\" का प्रतिनिधित्व करता है।\n   - FirstUniqueChar(\"xxyyzz\") को 'n' लौटाना चाहिए।\n   - FirstUniqueChar(\"\") को 'n' लौटाना चाहिए।",
      "hu": "Megkeresi az első karaktert egy szövegben, amely csak egyszer fordul elő.\n   Ha minden karakter többször fordul elő, vagy a szöveg üres, akkor 'n'-t ad vissza, mint karaktert.\n   Példák:\n   - FirstUniqueChar(\"aabbcdde\") vissza kell adnia 'c'-t.\n   - FirstUniqueChar(\"aabbcc\") vissza kell adnia 'n'-t, ami a \"no\"-t jelenti.\n   - FirstUniqueChar(\"xxyyzz\") vissza kell adnia 'n'-t.\n   - FirstUniqueChar(\"\") vissza kell adnia 'n'-t."
    },
    "docstring_bertscore": {
      "sq": "0.9713582935762932",
      "hy": "0.9509174396943739",
      "bn": "0.9528084009218261",
      "bg": "0.986091304828794",
      "zh": "0.9362100517610267",
      "fr": "0.9837089320386616",
      "de": "0.9775335134922869",
      "ha": "0.9874092174069605",
      "hi": "0.9667409317387563",
      "hu": "0.9649923884945061"
    }
  },
  {
    "task_id": "C#/26",
    "prompt": {
      "en": "using System;\nusing System.Collections.Generic;\nusing System.Diagnostics;\n\nclass Program\n{\n\n/* Determines if two DNA sequences are related based on the similarity threshold.\n   The function compares two DNA sequences of the same length, base pair by base pair.\n   If the proportion of identical base pairs is greater than or equal to the given threshold,\n   the sequences are considered related.\n   \n   Example:\n   >>> AreDNAsRelated(\"ATCG\", \"ATCC\", 0.75)\n   true\n*/\n\n    static bool AreDNAsRelated(string dnaSequence1, string dnaSequence2, double similarityThreshold)",
      "sq": "using System;\nusing System.Collections.Generic;\nusing System.Diagnostics;\n\nclass Program\n{\n\n/* Përcakton nëse dy sekuenca të ADN-së janë të lidhura bazuar në pragun e ngjashmërisë.\n   Funksioni krahason dy sekuenca të ADN-së me të njëjtën gjatësi, bazë për bazë.\n   Nëse përqindja e çifteve bazë identike është më e madhe ose e barabartë me pragun e dhënë,\n   sekuencat konsiderohen të lidhura.\n   \n   Shembull:\n   >>> AreDNAsRelated(\"ATCG\", \"ATCC\", 0.75)\n   true\n*/\n\n    static bool AreDNAsRelated(string dnaSequence1, string dnaSequence2, double similarityThreshold)",
      "hy": "using System;\nusing System.Collections.Generic;\nusing System.Diagnostics;\n\nclass Program\n{\n\n/* Որոշում է՝ արդյոք երկու ԴՆԹ հաջորդականությունները կապված են՝ հիմնվելով նմանության շեմի վրա։\n   Ֆունկցիան համեմատում է նույն երկարության երկու ԴՆԹ հաջորդականությունները՝ զույգ առ զույգ։\n   Եթե նույնական զույգերի բաժինը մեծ է կամ հավասար է տրված շեմին,\n   հաջորդականությունները համարվում են կապված։\n   \n   Օրինակ:\n   >>> AreDNAsRelated(\"ATCG\", \"ATCC\", 0.75)\n   true\n*/\n\n    static bool AreDNAsRelated(string dnaSequence1, string dnaSequence2, double similarityThreshold)",
      "bn": "using System;\nusing System.Collections.Generic;\nusing System.Diagnostics;\n\nclass Program\n{\n\n/* দুটি ডিএনএ সিকোয়েন্স সম্পর্কিত কিনা তা নির্ধারণ করে নির্দিষ্ট সাদৃশ্য থ্রেশহোল্ডের ভিত্তিতে।\n   ফাংশনটি একই দৈর্ঘ্যের দুটি ডিএনএ সিকোয়েন্সকে তুলনা করে, প্রতিটি বেস পেয়ার ধরে ধরে।\n   যদি অভিন্ন বেস পেয়ারগুলির অনুপাত প্রদত্ত থ্রেশহোল্ডের সমান বা তার বেশি হয়,\n   তাহলে সিকোয়েন্সগুলোকে সম্পর্কিত বলে মনে করা হয়।\n   \n   উদাহরণ:\n   >>> AreDNAsRelated(\"ATCG\", \"ATCC\", 0.75)\n   true\n*/\n\n    static bool AreDNAsRelated(string dnaSequence1, string dnaSequence2, double similarityThreshold)",
      "bg": "using System;\nusing System.Collections.Generic;\nusing System.Diagnostics;\n\nclass Program\n{\n\n/* Определя дали две ДНК последователности са свързани въз основа на прага на сходство.\n   Функцията сравнява две ДНК последователности с еднаква дължина, база по база.\n   Ако пропорцията на идентичните бази е по-голяма или равна на дадения праг,\n   последователностите се считат за свързани.\n   \n   Пример:\n   >>> AreDNAsRelated(\"ATCG\", \"ATCC\", 0.75)\n   true\n*/\n\n    static bool AreDNAsRelated(string dnaSequence1, string dnaSequence2, double similarityThreshold)",
      "zh": "using System;\nusing System.Collections.Generic;\nusing System.Diagnostics;\n\nclass Program\n{\n\n/* 判断两个 DNA 序列是否基于相似性阈值相关。\n   该函数逐个碱基对比较两个长度相同的 DNA 序列。\n   如果相同碱基对的比例大于或等于给定的阈值，\n   则认为这些序列是相关的。\n   \n   示例:\n   >>> AreDNAsRelated(\"ATCG\", \"ATCC\", 0.75)\n   true\n*/\n\n    static bool AreDNAsRelated(string dnaSequence1, string dnaSequence2, double similarityThreshold)",
      "fr": "using System;\nusing System.Collections.Generic;\nusing System.Diagnostics;\n\nclass Program\n{\n\n/* Détermine si deux séquences d'ADN sont liées en fonction du seuil de similarité.\n   La fonction compare deux séquences d'ADN de même longueur, paire de bases par paire de bases.\n   Si la proportion de paires de bases identiques est supérieure ou égale au seuil donné,\n   les séquences sont considérées comme liées.\n   \n   Exemple :\n   >>> AreDNAsRelated(\"ATCG\", \"ATCC\", 0.75)\n   true\n*/\n\n    static bool AreDNAsRelated(string dnaSequence1, string dnaSequence2, double similarityThreshold)",
      "de": "using System;\nusing System.Collections.Generic;\nusing System.Diagnostics;\n\nclass Program\n{\n\n/* Bestimmt, ob zwei DNA-Sequenzen basierend auf dem Ähnlichkeitsschwellenwert verwandt sind.\n   Die Funktion vergleicht zwei DNA-Sequenzen gleicher Länge, Basenpaar für Basenpaar.\n   Wenn der Anteil identischer Basenpaare größer oder gleich dem gegebenen Schwellenwert ist,\n   werden die Sequenzen als verwandt betrachtet.\n   \n   Beispiel:\n   >>> AreDNAsRelated(\"ATCG\", \"ATCC\", 0.75)\n   true\n*/\n\n    static bool AreDNAsRelated(string dnaSequence1, string dnaSequence2, double similarityThreshold)",
      "ha": "using System;\nusing System.Collections.Generic;\nusing System.Diagnostics;\n\nclass Program\n{\n\n/* Yana tantance idan kwayoyin halittar DNA guda biyu suna da alaka bisa ga matakin kamanceceniya.\n   Aikin yana kwatanta kwayoyin halittar DNA guda biyu masu tsawon iri ɗaya, kwayoyin halitta ɗaya bayan ɗaya.\n   Idan yawan kwayoyin halitta masu kama ya fi ko yayi daidai da matakin da aka bayar,\n   ana ɗaukar kwayoyin halittar suna da alaka.\n   \n   Misali:\n   >>> AreDNAsRelated(\"ATCG\", \"ATCC\", 0.75)\n   true\n*/\n\n    static bool AreDNAsRelated(string dnaSequence1, string dnaSequence2, double similarityThreshold)",
      "hi": "using System;\nusing System.Collections.Generic;\nusing System.Diagnostics;\n\nclass Program\n{\n\n/* यह निर्धारित करता है कि दो डीएनए अनुक्रम समानता सीमा के आधार पर संबंधित हैं या नहीं।\n   यह फ़ंक्शन समान लंबाई के दो डीएनए अनुक्रमों की तुलना करता है, प्रत्येक आधार युग्म द्वारा।\n   यदि समान आधार युग्मों का अनुपात दिए गए सीमा से अधिक या उसके बराबर है,\n   तो अनुक्रमों को संबंधित माना जाता है।\n   \n   उदाहरण:\n   >>> AreDNAsRelated(\"ATCG\", \"ATCC\", 0.75)\n   true\n*/\n\n    static bool AreDNAsRelated(string dnaSequence1, string dnaSequence2, double similarityThreshold)",
      "hu": "using System;\nusing System.Collections.Generic;\nusing System.Diagnostics;\n\nclass Program\n{\n\n/* Meghatározza, hogy két DNS-szekvencia kapcsolódik-e a hasonlósági küszöb alapján.\n   A függvény két azonos hosszúságú DNS-szekvenciát hasonlít össze, bázispáronként.\n   Ha az azonos bázispárok aránya nagyobb vagy egyenlő a megadott küszöbértéknél,\n   a szekvenciák kapcsolódónak tekintendők.\n   \n   Példa:\n   >>> AreDNAsRelated(\"ATCG\", \"ATCC\", 0.75)\n   true\n*/\n\n    static bool AreDNAsRelated(string dnaSequence1, string dnaSequence2, double similarityThreshold)"
    },
    "prompt_bertscore": {
      "sq": "0.9877868137613078",
      "hy": "0.9685540298568427",
      "bn": "0.9816405938809453",
      "bg": "0.9804567568099773",
      "zh": "0.9701488331861718",
      "fr": "1",
      "de": "0.9993214786183848",
      "ha": "0.9463968108524009",
      "hi": "0.9877882041739751",
      "hu": "0.9933576014278123"
    },
    "canonical_solution": "    {\n        if (dnaSequence1.Length != dnaSequence2.Length)\n            throw new ArgumentException(\"DNA sequences must be of the same length.\");\n\n        int identicalPairsCount = 0;\n        for (int i = 0; i < dnaSequence1.Length; i++)\n        {\n            if (dnaSequence1[i] == dnaSequence2[i])\n                identicalPairsCount++;\n        }\n\n        double similarity = (double)identicalPairsCount / dnaSequence1.Length;\n        return similarity >= similarityThreshold;\n    }",
    "instruction": {
      "en": "Write a C# function `static bool AreDNAsRelated(string dnaSequence1, string dnaSequence2, double similarityThreshold)` to solve the following problem:\nDetermines if two DNA sequences are related based on the similarity threshold.\n   The function compares two DNA sequences of the same length, base pair by base pair.\n   If the proportion of identical base pairs is greater than or equal to the given threshold,\n   the sequences are considered related.\n   \n   Example:\n   >>> AreDNAsRelated(\"ATCG\", \"ATCC\", 0.75)\n   true",
      "sq": "Shkruani një funksion në C# `static bool AreDNAsRelated(string dnaSequence1, string dnaSequence2, double similarityThreshold)` për të zgjidhur problemin e mëposhtëm:\nPërcakton nëse dy sekuenca të ADN-së janë të lidhura bazuar në pragun e ngjashmërisë.\n   Funksioni krahason dy sekuenca të ADN-së me të njëjtën gjatësi, bazë për bazë.\n   Nëse përqindja e çifteve bazë identike është më e madhe ose e barabartë me pragun e dhënë,\n   sekuencat konsiderohen të lidhura.\n   \n   Shembull:\n   >>> AreDNAsRelated(\"ATCG\", \"ATCC\", 0.75)\n   true",
      "hy": "Գրեք C# ֆունկցիա `static bool AreDNAsRelated(string dnaSequence1, string dnaSequence2, double similarityThreshold)` հետևյալ խնդիրը լուծելու համար:\nՍահմանում է, արդյոք երկու ԴՆԹ հաջորդականությունները կապված են նմանության շեմի հիման վրա:\n   Ֆունկցիան համեմատում է նույն երկարության երկու ԴՆԹ հաջորդականություններ, հիմք առ հիմք:\n   Եթե նույնական հիմքերի զույգերի հարաբերակցությունը մեծ կամ հավասար է տրված շեմին,\n   հաջորդականությունները համարվում են կապված:\n   \n   Օրինակ:\n   >>> AreDNAsRelated(\"ATCG\", \"ATCC\", 0.75)\n   true",
      "bn": "C# ফাংশন `static bool AreDNAsRelated(string dnaSequence1, string dnaSequence2, double similarityThreshold)` লিখুন নিম্নলিখিত সমস্যার সমাধানের জন্য:\nদুটি ডিএনএ সিকোয়েন্স সম্পর্কিত কিনা তা নির্ধারণ করে সাদৃশ্যের থ্রেশহোল্ডের ভিত্তিতে।\n   ফাংশনটি একই দৈর্ঘ্যের দুটি ডিএনএ সিকোয়েন্স তুলনা করে, বেস পেয়ার বাই বেস পেয়ার।\n   যদি অভিন্ন বেস পেয়ারের অনুপাত প্রদত্ত থ্রেশহোল্ডের চেয়ে বেশি বা সমান হয়,\n   তাহলে সিকোয়েন্সগুলোকে সম্পর্কিত বলে বিবেচনা করা হয়।\n   \n   উদাহরণ:\n   >>> AreDNAsRelated(\"ATCG\", \"ATCC\", 0.75)\n   true",
      "bg": "Напишете C# функция `static bool AreDNAsRelated(string dnaSequence1, string dnaSequence2, double similarityThreshold)`, за да решите следния проблем:\nОпределя дали две ДНК последователности са свързани въз основа на прага на сходство.\n   Функцията сравнява две ДНК последователности с еднаква дължина, база по база.\n   Ако пропорцията на идентични бази е по-голяма или равна на дадения праг,\n   последователностите се считат за свързани.\n   \n   Пример:\n   >>> AreDNAsRelated(\"ATCG\", \"ATCC\", 0.75)\n   true",
      "zh": "编写一个 C# 函数 `static bool AreDNAsRelated(string dnaSequence1, string dnaSequence2, double similarityThreshold)` 来解决以下问题：\n确定两个 DNA 序列是否基于相似性阈值相关。\n函数逐个碱基对地比较两个长度相同的 DNA 序列。\n如果相同碱基对的比例大于或等于给定的阈值，则认为这些序列是相关的。\n\n示例:\n>>> AreDNAsRelated(\"ATCG\", \"ATCC\", 0.75)\ntrue",
      "fr": "Écrire une fonction C# `static bool AreDNAsRelated(string dnaSequence1, string dnaSequence2, double similarityThreshold)` pour résoudre le problème suivant :\nDétermine si deux séquences d'ADN sont liées en fonction du seuil de similarité.\n   La fonction compare deux séquences d'ADN de même longueur, paire de bases par paire de bases.\n   Si la proportion de paires de bases identiques est supérieure ou égale au seuil donné,\n   les séquences sont considérées comme liées.\n   \n   Exemple :\n   >>> AreDNAsRelated(\"ATCG\", \"ATCC\", 0.75)\n   true",
      "de": "Schreiben Sie eine C#-Funktion `static bool AreDNAsRelated(string dnaSequence1, string dnaSequence2, double similarityThreshold)`, um das folgende Problem zu lösen:\nBestimmt, ob zwei DNA-Sequenzen basierend auf dem Ähnlichkeitsschwellenwert verwandt sind.\n   Die Funktion vergleicht zwei DNA-Sequenzen gleicher Länge, Basenpaar für Basenpaar.\n   Wenn der Anteil identischer Basenpaare größer oder gleich dem gegebenen Schwellenwert ist,\n   werden die Sequenzen als verwandt betrachtet.\n   \n   Beispiel:\n   >>> AreDNAsRelated(\"ATCG\", \"ATCC\", 0.75)\n   true",
      "ha": "Rubuta aikin C# `static bool AreDNAsRelated(string dnaSequence1, string dnaSequence2, double similarityThreshold)` don warware matsalar mai zuwa:\nYana tantance idan kwayoyin DNA guda biyu suna da alaƙa bisa ga ƙimar kamance.\n   Aikin yana kwatanta kwayoyin DNA guda biyu masu tsawon iri ɗaya, kwayar tushe da kwayar tushe.\n   Idan adadin kwayoyin tushe masu kama ya fi ko ya kai ƙimar da aka bayar,\n   ana ɗaukar kwayoyin suna da alaƙa.\n\n   Misali:\n   >>> AreDNAsRelated(\"ATCG\", \"ATCC\", 0.75)\n   true",
      "hi": "C# फ़ंक्शन `static bool AreDNAsRelated(string dnaSequence1, string dnaSequence2, double similarityThreshold)` लिखें ताकि निम्नलिखित समस्या का समाधान किया जा सके:\nयह निर्धारित करता है कि दो डीएनए अनुक्रम समानता सीमा के आधार पर संबंधित हैं या नहीं।\n   फ़ंक्शन समान लंबाई के दो डीएनए अनुक्रमों की तुलना करता है, बेस जोड़ी दर बेस जोड़ी।\n   यदि समान बेस जोड़ों का अनुपात दिए गए सीमा से अधिक या उसके बराबर है,\n   तो अनुक्रमों को संबंधित माना जाता है। \n\n   उदाहरण:\n   >>> AreDNAsRelated(\"ATCG\", \"ATCC\", 0.75)\n   true",
      "hu": "Írj egy C# függvényt `static bool AreDNAsRelated(string dnaSequence1, string dnaSequence2, double similarityThreshold)` a következő probléma megoldására:\nMegállapítja, hogy két DNS-szekvencia kapcsolódik-e a hasonlósági küszöb alapján.\n   A függvény két azonos hosszúságú DNS-szekvenciát hasonlít össze, bázispáronként.\n   Ha az azonos bázispárok aránya nagyobb vagy egyenlő a megadott küszöbnél,\n   a szekvenciák kapcsolódónak tekintendők.\n   \n   Példa:\n   >>> AreDNAsRelated(\"ATCG\", \"ATCC\", 0.75)\n   true"
    },
    "instruction_bertscore": {
      "sq": "0.9824738483293867",
      "hy": "0.9817418953752731",
      "bn": "0.9779740756774223",
      "bg": "0.9701851825459012",
      "zh": "0.9747364004665536",
      "fr": "0.9900561658646314",
      "de": "0.9965251601141757",
      "ha": "0.9443364179099261",
      "hi": "0.9660745268103842",
      "hu": "0.995900666196202"
    },
    "level": "middle",
    "test": "    static void Main()\n    {\n\n        Debug.Assert(AreDNAsRelated(\"ATCGCCGTAAGTAACGGTTTTAAATAGGCC\", \"ATCGCCGGAAGTAACGGTCTTAAATAGGCC\", 0.85) == true);\n        Debug.Assert(AreDNAsRelated(\"GGCATGAC\", \"TGACATGC\", 0.50) == false);\n        Debug.Assert(AreDNAsRelated(\"AAAA\", \"AAAA\", 1.00) == true);\n        Debug.Assert(AreDNAsRelated(\"CCCC\", \"GGTT\", 0.25) == false);\n\n    }\n}",
    "entry_point": "AreDNAsRelated",
    "signature": "static bool AreDNAsRelated(string dnaSequence1, string dnaSequence2, double similarityThreshold)",
    "docstring": {
      "en": "Determines if two DNA sequences are related based on the similarity threshold.\n   The function compares two DNA sequences of the same length, base pair by base pair.\n   If the proportion of identical base pairs is greater than or equal to the given threshold,\n   the sequences are considered related.\n   \n   Example:\n   >>> AreDNAsRelated(\"ATCG\", \"ATCC\", 0.75)\n   true",
      "sq": "Përcakton nëse dy sekuenca të ADN-së janë të lidhura bazuar në pragun e ngjashmërisë.\n   Funksioni krahason dy sekuenca të ADN-së me të njëjtën gjatësi, bazë për bazë.\n   Nëse përqindja e bazave identike është më e madhe ose e barabartë me pragun e dhënë,\n   sekuencat konsiderohen të lidhura.\n   \n   Shembull:\n   >>> AreDNAsRelated(\"ATCG\", \"ATCC\", 0.75)\n   true",
      "hy": "Սահմանում է՝ արդյոք երկու ԴՆԹ հաջորդականությունները կապված են՝ հիմնված նմանության շեմի վրա։ \n   Ֆունկցիան համեմատում է նույն երկարության երկու ԴՆԹ հաջորդականությունները՝ հիմք զույգ առ հիմք զույգ։ \n   Եթե նույնական հիմք զույգերի բաժինը մեծ է կամ հավասար է տրված շեմին, \n   հաջորդականությունները համարվում են կապված։\n\n   Օրինակ:\n   >>> AreDNAsRelated(\"ATCG\", \"ATCC\", 0.75)\n   true",
      "bn": "দুটি ডিএনএ সিকোয়েন্স সম্পর্কিত কিনা তা নির্ধারণ করে সাদৃশ্যের থ্রেশহোল্ডের উপর ভিত্তি করে। \n   ফাংশনটি একই দৈর্ঘ্যের দুটি ডিএনএ সিকোয়েন্সকে তুলনা করে, প্রতিটি বেস পেয়ার ধরে ধরে। \n   যদি অভিন্ন বেস পেয়ারের অনুপাত প্রদত্ত থ্রেশহোল্ডের চেয়ে বেশি বা সমান হয়, \n   তবে সিকোয়েন্সগুলোকে সম্পর্কিত বলে বিবেচনা করা হয়।\n   \n   উদাহরণ:\n   >>> AreDNAsRelated(\"ATCG\", \"ATCC\", 0.75)\n   true",
      "bg": "Определя дали две ДНК последователности са свързани въз основа на прага на сходство.\n   Функцията сравнява две ДНК последователности с еднаква дължина, базова двойка по базова двойка.\n   Ако пропорцията на идентичните базови двойки е по-голяма или равна на дадения праг,\n   последователностите се считат за свързани.\n   \n   Пример:\n   >>> AreDNAsRelated(\"ATCG\", \"ATCC\", 0.75)\n   true",
      "zh": "确定两个 DNA 序列是否基于相似性阈值相关。\n   该函数逐个碱基对比较两个长度相同的 DNA 序列。\n   如果相同碱基对的比例大于或等于给定的阈值，\n   则认为这些序列是相关的。\n   \n   示例：\n   >>> AreDNAsRelated(\"ATCG\", \"ATCC\", 0.75)\n   true",
      "fr": "Détermine si deux séquences d'ADN sont liées en fonction du seuil de similarité.\n   La fonction compare deux séquences d'ADN de même longueur, paire de bases par paire de bases.\n   Si la proportion de paires de bases identiques est supérieure ou égale au seuil donné,\n   les séquences sont considérées comme liées.\n   \n   Exemple :\n   >>> AreDNAsRelated(\"ATCG\", \"ATCC\", 0.75)\n   true",
      "de": "Bestimmt, ob zwei DNA-Sequenzen basierend auf dem Ähnlichkeitsschwellenwert verwandt sind.\n   Die Funktion vergleicht zwei DNA-Sequenzen gleicher Länge, Basenpaar für Basenpaar.\n   Wenn der Anteil identischer Basenpaare größer oder gleich dem angegebenen Schwellenwert ist,\n   werden die Sequenzen als verwandt betrachtet.\n   \n   Beispiel:\n   >>> AreDNAsRelated(\"ATCG\", \"ATCC\", 0.75)\n   true",
      "ha": "Yana tantance ko kwayoyin halittar DNA guda biyu suna da alaƙa bisa ga ƙimar kusanci.\n   Aikin yana kwatanta kwayoyin halittar DNA guda biyu masu tsawon iri ɗaya, kwayar tushe ta kwayar tushe.\n   Idan adadin kwayoyin tushe masu kama ya fi ko ya kai ga ƙimar da aka bayar,\n   ana ɗaukar kwayoyin halittar suna da alaƙa.\n   \n   Misali:\n   >>> AreDNAsRelated(\"ATCG\", \"ATCC\", 0.75)\n   true",
      "hi": "दो डीएनए अनुक्रमों के समानता सीमा के आधार पर संबंधित होने का निर्धारण करता है। \n   फ़ंक्शन समान लंबाई के दो डीएनए अनुक्रमों की तुलना करता है, प्रत्येक आधार युग्म द्वारा।\n   यदि समान आधार युग्मों का अनुपात दिए गए सीमा से अधिक या उसके बराबर है,\n   तो अनुक्रमों को संबंधित माना जाता है।\n   \n   उदाहरण:\n   >>> AreDNAsRelated(\"ATCG\", \"ATCC\", 0.75)\n   true",
      "hu": "Meghatározza, hogy két DNS-szekvencia rokon-e a hasonlósági küszöb alapján.\n   A függvény összehasonlít két azonos hosszúságú DNS-szekvenciát, bázispáronként.\n   Ha az azonos bázispárok aránya nagyobb vagy egyenlő a megadott küszöbértéknél,\n   a szekvenciákat rokonnak tekintjük.\n   \n   Példa:\n   >>> AreDNAsRelated(\"ATCG\", \"ATCC\", 0.75)\n   true"
    },
    "docstring_bertscore": {
      "sq": "0.9693654349633702",
      "hy": "0.978171514276171",
      "bn": "0.988482417355692",
      "bg": "0.9958319400843639",
      "zh": "0.9515198856400527",
      "fr": "0.9865417985329812",
      "de": "0.991095995909349",
      "ha": "0.921255766264053",
      "hi": "0.9730597614202381",
      "hu": "0.9942734861147642"
    }
  },
  {
    "task_id": "C#/27",
    "prompt": {
      "en": "using System;\nusing System.Text;\nusing System.Collections.Generic;\nusing System.Diagnostics;\n\nclass Program\n{\n\n\n/* This function takes a string as input and returns a 'Close Friend' string based on specific ASCII value manipulations.\n   The Close Friend string is generated by summing the ASCII values of each pair of adjacent characters in the input string,\n   creating a new character from the sum. For the last character of the Close Friend string, sum the ASCII value of the \n   last and first characters of the input string. The input string length should be between 2 and 100 characters, and \n   each character's ASCII value should not exceed 63.\n\n   Example:\n   >>> GenerateCloseFriendString(\"1234\")\n   \"cege\"\n\n*/\n    static string GenerateCloseFriendString(string inputString)",
      "sq": "using System;\nusing System.Text;\nusing System.Collections.Generic;\nusing System.Diagnostics;\n\nclass Program\n{\n\n\n/* Kjo funksion merr një varg si hyrje dhe kthen një varg 'Mik i Afërt' bazuar në manipulime specifike të vlerave ASCII.\n   Vargu Mik i Afërt gjenerohet duke mbledhur vlerat ASCII të secilit çift karakteresh ngjitur në vargun hyrës,\n   duke krijuar një karakter të ri nga shuma. Për karakterin e fundit të vargut Mik i Afërt, mblidhni vlerën ASCII të\n   karakterit të fundit dhe të parë të vargut hyrës. Gjatësia e vargut hyrës duhet të jetë midis 2 dhe 100 karaktere, dhe\n   vlera ASCII e secilit karakter nuk duhet të kalojë 63.\n\n   Shembull:\n   >>> GenerateCloseFriendString(\"1234\")\n   \"cege\"\n\n*/\n    static string GenerateCloseFriendString(string inputString)",
      "hy": "using System;\nusing System.Text;\nusing System.Collections.Generic;\nusing System.Diagnostics;\n\nclass Program\n{\n\n\n/* Այս ֆունկցիան ընդունում է տող որպես մուտք և վերադարձնում է 'Close Friend' տող՝ հիմնված հատուկ ASCII արժեքների մանիպուլյացիաների վրա:\n   'Close Friend' տողը ստեղծվում է մուտքային տողի հարակից յուրաքանչյուր զույգ նիշերի ASCII արժեքների գումարով՝\n   ստեղծելով նոր նիշ այդ գումարից: 'Close Friend' տողի վերջին նիշի համար գումարեք մուտքային տողի վերջին և առաջին նիշերի\n   ASCII արժեքները: Մուտքային տողի երկարությունը պետք է լինի 2-ից 100 նիշ, և\n   յուրաքանչյուր նիշի ASCII արժեքը չպետք է գերազանցի 63-ը:\n\n   Օրինակ:\n   >>> GenerateCloseFriendString(\"1234\")\n   \"cege\"\n\n*/\n    static string GenerateCloseFriendString(string inputString)",
      "bn": "using System;\nusing System.Text;\nusing System.Collections.Generic;\nusing System.Diagnostics;\n\nclass Program\n{\n\n\n/* এই ফাংশনটি একটি স্ট্রিং ইনপুট হিসাবে গ্রহণ করে এবং নির্দিষ্ট ASCII মানের পরিবর্তনের উপর ভিত্তি করে একটি 'Close Friend' স্ট্রিং ফেরত দেয়।\n   Close Friend স্ট্রিংটি ইনপুট স্ট্রিংয়ের প্রতিটি সংলগ্ন অক্ষরের জোড়ার ASCII মান যোগ করে তৈরি করা হয়,\n   যোগফল থেকে একটি নতুন অক্ষর তৈরি করা হয়। Close Friend স্ট্রিংয়ের শেষ অক্ষরের জন্য, ইনপুট স্ট্রিংয়ের \n   শেষ এবং প্রথম অক্ষরের ASCII মান যোগ করতে হবে। ইনপুট স্ট্রিংয়ের দৈর্ঘ্য 2 থেকে 100 অক্ষরের মধ্যে হওয়া উচিত, এবং \n   প্রতিটি অক্ষরের ASCII মান 63 এর বেশি হওয়া উচিত নয়।\n\n   উদাহরণ:\n   >>> GenerateCloseFriendString(\"1234\")\n   \"cege\"\n\n*/\n    static string GenerateCloseFriendString(string inputString)",
      "bg": "using System;\nusing System.Text;\nusing System.Collections.Generic;\nusing System.Diagnostics;\n\nclass Program\n{\n\n\n/* Тази функция приема низ като вход и връща низ 'Close Friend' въз основа на специфични манипулации с ASCII стойности.\n   Низът 'Close Friend' се генерира чрез сумиране на ASCII стойностите на всяка двойка съседни символи в входния низ,\n   създавайки нов символ от сумата. За последния символ на низа 'Close Friend', сумирайте ASCII стойността на \n   последния и първия символ на входния низ. Дължината на входния низ трябва да бъде между 2 и 100 символа, и \n   ASCII стойността на всеки символ не трябва да надвишава 63.\n\n   Пример:\n   >>> GenerateCloseFriendString(\"1234\")\n   \"cege\"\n\n*/\n    static string GenerateCloseFriendString(string inputString)",
      "zh": "using System;\nusing System.Text;\nusing System.Collections.Generic;\nusing System.Diagnostics;\n\nclass Program\n{\n\n\n/* 此函数接受一个字符串作为输入，并基于特定的ASCII值操作返回一个“Close Friend”字符串。\n   “Close Friend”字符串是通过对输入字符串中每对相邻字符的ASCII值求和生成新字符而生成的。\n   对于“Close Friend”字符串的最后一个字符，将输入字符串的最后一个字符和第一个字符的ASCII值相加。\n   输入字符串的长度应在2到100个字符之间，并且每个字符的ASCII值不应超过63。\n\n   示例：\n   >>> GenerateCloseFriendString(\"1234\")\n   \"cege\"\n\n*/\n    static string GenerateCloseFriendString(string inputString)",
      "fr": "using System;\nusing System.Text;\nusing System.Collections.Generic;\nusing System.Diagnostics;\n\nclass Program\n{\n\n\n/* Cette fonction prend une chaîne de caractères en entrée et renvoie une chaîne 'Ami Proche' basée sur des manipulations spécifiques de valeurs ASCII.\n   La chaîne Ami Proche est générée en additionnant les valeurs ASCII de chaque paire de caractères adjacents dans la chaîne d'entrée,\n   créant un nouveau caractère à partir de la somme. Pour le dernier caractère de la chaîne Ami Proche, additionnez la valeur ASCII du \n   dernier et du premier caractère de la chaîne d'entrée. La longueur de la chaîne d'entrée doit être comprise entre 2 et 100 caractères, et \n   la valeur ASCII de chaque caractère ne doit pas dépasser 63.\n\n   Exemple:\n   >>> GenerateCloseFriendString(\"1234\")\n   \"cege\"\n\n*/\n    static string GenerateCloseFriendString(string inputString)",
      "de": "using System;\nusing System.Text;\nusing System.Collections.Generic;\nusing System.Diagnostics;\n\nclass Program\n{\n\n\n/* Diese Funktion nimmt einen String als Eingabe und gibt einen 'Close Friend'-String basierend auf spezifischen ASCII-Wert-Manipulationen zurück.\n   Der Close Friend-String wird erzeugt, indem die ASCII-Werte jedes Paares benachbarter Zeichen im Eingabestring summiert werden,\n   und ein neues Zeichen aus der Summe erstellt wird. Für das letzte Zeichen des Close Friend-Strings wird die Summe der ASCII-Werte des \n   letzten und ersten Zeichens des Eingabestrings gebildet. Die Länge des Eingabestrings sollte zwischen 2 und 100 Zeichen liegen, und \n   der ASCII-Wert jedes Zeichens sollte 63 nicht überschreiten.\n\n   Beispiel:\n   >>> GenerateCloseFriendString(\"1234\")\n   \"cege\"\n\n*/\n    static string GenerateCloseFriendString(string inputString)",
      "ha": "using System;\nusing System.Text;\nusing System.Collections.Generic;\nusing System.Diagnostics;\n\nclass Program\n{\n\n\n/* Wannan aikin yana karɓar kirtani a matsayin shigarwa kuma yana dawowa da kirtani 'Aboki Na Kusa' bisa ga wasu takamaiman sauye-sauyen ƙimar ASCII.\n   Ana samar da kirtanin Aboki Na Kusa ta hanyar tara ƙimar ASCII na kowanne ma'aurata na haruffa masu makwabtaka a cikin kirtanin shigarwa,\n   yana ƙirƙirar sabon hali daga jumlar. Don hali na ƙarshe na kirtanin Aboki Na Kusa, tara ƙimar ASCII na \n   haruffa na ƙarshe da na farko na kirtanin shigarwa. Tsawon kirtanin shigarwa ya kamata ya kasance tsakanin haruffa 2 zuwa 100, kuma \n   ƙimar ASCII na kowanne hali bai kamata ya wuce 63 ba.\n\n   Misali:\n   >>> GenerateCloseFriendString(\"1234\")\n   \"cege\"\n\n*/\n    static string GenerateCloseFriendString(string inputString)",
      "hi": "using System;\nusing System.Text;\nusing System.Collections.Generic;\nusing System.Diagnostics;\n\nclass Program\n{\n\n\n/* यह फ़ंक्शन एक स्ट्रिंग को इनपुट के रूप में लेता है और विशिष्ट ASCII मान हेरफेर के आधार पर एक 'Close Friend' स्ट्रिंग लौटाता है।\n   Close Friend स्ट्रिंग इनपुट स्ट्रिंग में प्रत्येक जोड़ी के आसन्न वर्णों के ASCII मानों को जोड़कर उत्पन्न की जाती है,\n   योग से एक नया वर्ण बनाना। Close Friend स्ट्रिंग के अंतिम वर्ण के लिए, इनपुट स्ट्रिंग के\n   अंतिम और पहले वर्णों के ASCII मान का योग करें। इनपुट स्ट्रिंग की लंबाई 2 से 100 वर्णों के बीच होनी चाहिए, और\n   प्रत्येक वर्ण का ASCII मान 63 से अधिक नहीं होना चाहिए।\n\n   उदाहरण:\n   >>> GenerateCloseFriendString(\"1234\")\n   \"cege\"\n\n*/\n    static string GenerateCloseFriendString(string inputString)",
      "hu": "using System;\nusing System.Text;\nusing System.Collections.Generic;\nusing System.Diagnostics;\n\nclass Program\n{\n\n\n/* Ez a függvény egy karakterláncot vesz bemenetként, és egy 'Közeli Barát' karakterláncot ad vissza specifikus ASCII érték manipulációk alapján.\n   A Közeli Barát karakterlánc úgy jön létre, hogy az input karakterlánc minden szomszédos karakterpárjának ASCII értékeit összeadjuk,\n   és az összegből egy új karaktert hozunk létre. A Közeli Barát karakterlánc utolsó karakteréhez az input karakterlánc utolsó és első karakterének \n   ASCII értékét adjuk össze. Az input karakterlánc hossza 2 és 100 karakter között kell legyen, és minden karakter ASCII értéke nem haladhatja meg a 63-at.\n\n   Példa:\n   >>> GenerateCloseFriendString(\"1234\")\n   \"cege\"\n\n*/\n    static string GenerateCloseFriendString(string inputString)"
    },
    "prompt_bertscore": {
      "sq": "0.9718608284403115",
      "hy": "0.9676212615875028",
      "bn": "0.9494865064293986",
      "bg": "0.9745542564071447",
      "zh": "0.949579664078104",
      "fr": "0.9679714469492674",
      "de": "0.9770754718336204",
      "ha": "0.9788951247542811",
      "hi": "0.9777325411340838",
      "hu": "0.9581046814017403"
    },
    "canonical_solution": "    {\n        if (inputString.Length < 2 || inputString.Length > 100)\n        {\n            throw new ArgumentException(\"Input string length should be between 2 and 100 characters.\");\n        }\n\n        StringBuilder closeFriendString = new StringBuilder();\n\n        for (int i = 0; i < inputString.Length; i++)\n        {\n            int asciiValue = (int)inputString[i];\n            if (asciiValue > 63)\n            {\n                throw new ArgumentException(\"Each character's ASCII value should not exceed 63.\");\n            }\n\n            int nextAsciiValue = (i == inputString.Length - 1) ? (int)inputString[0] : (int)inputString[i + 1];\n            int sum = asciiValue + nextAsciiValue;\n            char closeFriendChar = (char)(sum % 128); // Modulo 128 to ensure the ASCII value is within the valid range\n            closeFriendString.Append(closeFriendChar);\n        }\n\n        return closeFriendString.ToString();\n    }",
    "instruction": {
      "en": "Write a C# function `static string GenerateCloseFriendString(string inputString)` to solve the following problem:\nThis function takes a string as input and returns a 'Close Friend' string based on specific ASCII value manipulations.\n   The Close Friend string is generated by summing the ASCII values of each pair of adjacent characters in the input string,\n   creating a new character from the sum. For the last character of the Close Friend string, sum the ASCII value of the \n   last and first characters of the input string. The input string length should be between 2 and 100 characters, and \n   each character's ASCII value should not exceed 63.\n\n   Example:\n   >>> GenerateCloseFriendString(\"1234\")\n   \"cege\"",
      "sq": "Shkruani një funksion në C# `static string GenerateCloseFriendString(string inputString)` për të zgjidhur problemin në vijim:\nKy funksion merr një varg si hyrje dhe kthen një varg 'Mik i Afërt' bazuar në manipulime specifike të vlerave ASCII.\n   Vargu Mik i Afërt gjenerohet duke mbledhur vlerat ASCII të secilit çift të karaktereve ngjitur në vargun hyrës,\n   duke krijuar një karakter të ri nga shuma. Për karakterin e fundit të vargut Mik i Afërt, mblidhni vlerën ASCII të\n   karakterit të fundit dhe të parë të vargut hyrës. Gjatësia e vargut hyrës duhet të jetë midis 2 dhe 100 karaktere, dhe\n   vlera ASCII e secilit karakter nuk duhet të kalojë 63.\n\n   Shembull:\n   >>> GenerateCloseFriendString(\"1234\")\n   \"cege\"",
      "hy": "Գրեք C# ֆունկցիա `static string GenerateCloseFriendString(string inputString)` հետևյալ խնդիրը լուծելու համար:\nԱյս ֆունկցիան ստանում է տող որպես մուտք և վերադարձնում է 'Close Friend' տողը հատուկ ASCII արժեքների մանիպուլյացիաների հիման վրա:\n   Close Friend տողը գեներացվում է մուտքային տողի հարակից յուրաքանչյուր զույգ նիշերի ASCII արժեքների գումարով,\n   ստեղծելով նոր նիշ այդ գումարից: Close Friend տողի վերջին նիշի համար գումարեք մուտքային տողի վերջին և առաջին նիշերի \n   ASCII արժեքները: Մուտքային տողի երկարությունը պետք է լինի 2-ից 100 նիշ, և \n   յուրաքանչյուր նիշի ASCII արժեքը չպետք է գերազանցի 63:\n\n   Օրինակ:\n   >>> GenerateCloseFriendString(\"1234\")\n   \"cege\"",
      "bn": "C# ফাংশন `static string GenerateCloseFriendString(string inputString)` লিখুন নিম্নলিখিত সমস্যার সমাধানের জন্য:\nএই ফাংশনটি একটি স্ট্রিং ইনপুট হিসেবে গ্রহণ করে এবং নির্দিষ্ট ASCII মানের পরিবর্তনের উপর ভিত্তি করে একটি 'Close Friend' স্ট্রিং ফেরত দেয়।\n   Close Friend স্ট্রিংটি ইনপুট স্ট্রিংয়ের প্রতিটি সংলগ্ন অক্ষরের ASCII মানের যোগফল দ্বারা তৈরি হয়,\n   যোগফল থেকে একটি নতুন অক্ষর তৈরি করে। Close Friend স্ট্রিংয়ের শেষ অক্ষরের জন্য, ইনপুট স্ট্রিংয়ের শেষ এবং প্রথম অক্ষরের \n   ASCII মানের যোগফল নিন। ইনপুট স্ট্রিংয়ের দৈর্ঘ্য 2 থেকে 100 অক্ষরের মধ্যে হওয়া উচিত, এবং \n   প্রতিটি অক্ষরের ASCII মান 63 এর বেশি হওয়া উচিত নয়।\n\n   উদাহরণ:\n   >>> GenerateCloseFriendString(\"1234\")\n   \"cege\"",
      "bg": "Напишете C# функция `static string GenerateCloseFriendString(string inputString)`, за да решите следния проблем:\nТази функция приема низ като вход и връща низ 'Close Friend' въз основа на специфични манипулации с ASCII стойности.\n   Низът Close Friend се генерира чрез сумиране на ASCII стойностите на всяка двойка съседни символи в входния низ,\n   създавайки нов символ от сумата. За последния символ на низа Close Friend, сумирайте ASCII стойността на \n   последния и първия символи на входния низ. Дължината на входния низ трябва да бъде между 2 и 100 символа, и \n   ASCII стойността на всеки символ не трябва да надвишава 63.\n\n   Пример:\n   >>> GenerateCloseFriendString(\"1234\")\n   \"cege\"",
      "zh": "编写一个 C# 函数 `static string GenerateCloseFriendString(string inputString)` 来解决以下问题：  \n此函数接受一个字符串作为输入，并基于特定的 ASCII 值操作返回一个“Close Friend”字符串。  \n“Close Friend”字符串是通过对输入字符串中每对相邻字符的 ASCII 值求和生成新字符而生成的。对于“Close Friend”字符串的最后一个字符，将输入字符串的最后一个字符和第一个字符的 ASCII 值相加。输入字符串的长度应在 2 到 100 个字符之间，并且每个字符的 ASCII 值不应超过 63。  \n\n示例：  \n>>> GenerateCloseFriendString(\"1234\")  \n\"cege\"",
      "fr": "Écrire une fonction C# `static string GenerateCloseFriendString(string inputString)` pour résoudre le problème suivant :\nCette fonction prend une chaîne de caractères en entrée et renvoie une chaîne 'Close Friend' basée sur des manipulations spécifiques des valeurs ASCII.\n   La chaîne Close Friend est générée en additionnant les valeurs ASCII de chaque paire de caractères adjacents dans la chaîne d'entrée,\n   créant un nouveau caractère à partir de la somme. Pour le dernier caractère de la chaîne Close Friend, additionnez la valeur ASCII du\n   dernier et du premier caractère de la chaîne d'entrée. La longueur de la chaîne d'entrée doit être comprise entre 2 et 100 caractères, et\n   la valeur ASCII de chaque caractère ne doit pas dépasser 63.\n\n   Exemple :\n   >>> GenerateCloseFriendString(\"1234\")\n   \"cege\"",
      "de": "Schreiben Sie eine C#-Funktion `static string GenerateCloseFriendString(string inputString)`, um das folgende Problem zu lösen:\nDiese Funktion nimmt einen String als Eingabe und gibt einen 'Close Friend'-String basierend auf spezifischen ASCII-Wert-Manipulationen zurück.\n   Der Close Friend-String wird erzeugt, indem die ASCII-Werte jedes Paares benachbarter Zeichen im Eingabestring summiert werden,\n   und ein neues Zeichen aus der Summe erstellt wird. Für das letzte Zeichen des Close Friend-Strings summieren Sie den ASCII-Wert des\n   letzten und ersten Zeichens des Eingabestrings. Die Länge des Eingabestrings sollte zwischen 2 und 100 Zeichen liegen, und\n   der ASCII-Wert jedes Zeichens sollte 63 nicht überschreiten.\n\n   Beispiel:\n   >>> GenerateCloseFriendString(\"1234\")\n   \"cege\"",
      "ha": "Rubuta aikin C# `static string GenerateCloseFriendString(string inputString)` don warware matsalar mai zuwa:\nWannan aikin yana karɓar kirtani azaman shigarwa kuma yana mayar da kirtani 'Close Friend' bisa wasu sauye-sauyen ƙimar ASCII.\n   Ana samar da kirtanin Close Friend ta hanyar tara ƙimar ASCII na kowanne ma'aurata na haruffa masu makwabtaka a cikin kirtanin shigarwa,\n   ƙirƙirar sabon hali daga tarin. Don hali na ƙarshe na kirtanin Close Friend, tara ƙimar ASCII na\n   harafin ƙarshe da na farko na kirtanin shigarwa. Tsawon kirtanin shigarwa ya kamata ya kasance tsakanin haruffa 2 zuwa 100, kuma\n   ƙimar ASCII na kowanne hali bai kamata ya wuce 63 ba.\n\n   Misali:\n   >>> GenerateCloseFriendString(\"1234\")\n   \"cege\"",
      "hi": "C# फ़ंक्शन `static string GenerateCloseFriendString(string inputString)` लिखें ताकि निम्नलिखित समस्या का समाधान किया जा सके:\nयह फ़ंक्शन एक स्ट्रिंग को इनपुट के रूप में लेता है और विशिष्ट ASCII मान हेरफेर के आधार पर एक 'Close Friend' स्ट्रिंग लौटाता है।\n   Close Friend स्ट्रिंग को इनपुट स्ट्रिंग के प्रत्येक जोड़ी के आसन्न वर्णों के ASCII मानों को जोड़कर उत्पन्न किया जाता है,\n   और जोड़ से एक नया वर्ण बनाता है। Close Friend स्ट्रिंग के अंतिम वर्ण के लिए, इनपुट स्ट्रिंग के अंतिम और पहले वर्णों के \n   ASCII मान को जोड़ें। इनपुट स्ट्रिंग की लंबाई 2 से 100 वर्णों के बीच होनी चाहिए, और \n   प्रत्येक वर्ण का ASCII मान 63 से अधिक नहीं होना चाहिए।\n\n   उदाहरण:\n   >>> GenerateCloseFriendString(\"1234\")\n   \"cege\"",
      "hu": "Írj egy C# függvényt `static string GenerateCloseFriendString(string inputString)` a következő probléma megoldására:\nEz a függvény egy karakterláncot vesz be bemenetként, és egy 'Közeli Barát' karakterláncot ad vissza specifikus ASCII érték manipulációk alapján.\n   A Közeli Barát karakterlánc úgy jön létre, hogy az input karakterlánc minden szomszédos karakterpárjának ASCII értékeit összeadjuk,\n   és az összegből egy új karaktert hozunk létre. A Közeli Barát karakterlánc utolsó karakteréhez az input karakterlánc utolsó és első karakterének\n   ASCII értékét adjuk össze. Az input karakterlánc hossza 2 és 100 karakter között kell legyen, és minden karakter ASCII értéke nem haladhatja meg a 63-at.\n\n   Példa:\n   >>> GenerateCloseFriendString(\"1234\")\n   \"cege\""
    },
    "instruction_bertscore": {
      "sq": "0.9673630420921575",
      "hy": "0.9763860257810484",
      "bn": "0.9531794424735993",
      "bg": "0.9816882651723936",
      "zh": "0.9552922738366674",
      "fr": "0.966284280492757",
      "de": "0.9862180310118943",
      "ha": "0.9732603781050834",
      "hi": "0.9668515688609927",
      "hu": "0.9668783839624324"
    },
    "level": "hard",
    "test": "    static void Main()\n    {\n        Debug.Assert(GenerateCloseFriendString(\"1234\") == \"cege\");\n        Debug.Assert(GenerateCloseFriendString(\"4312\") == \"gdcf\");\n\n    }\n}",
    "entry_point": "GenerateCloseFriendString",
    "signature": "static string GenerateCloseFriendString(string inputString)",
    "docstring": {
      "en": "This function takes a string as input and returns a 'Close Friend' string based on specific ASCII value manipulations.\n   The Close Friend string is generated by summing the ASCII values of each pair of adjacent characters in the input string,\n   creating a new character from the sum. For the last character of the Close Friend string, sum the ASCII value of the \n   last and first characters of the input string. The input string length should be between 2 and 100 characters, and \n   each character's ASCII value should not exceed 63.\n\n   Example:\n   >>> GenerateCloseFriendString(\"1234\")\n   \"cege\"",
      "sq": "Kjo funksion merr një varg si hyrje dhe kthen një varg 'Mik i Afërt' bazuar në manipulime specifike të vlerave ASCII. \n   Vargu Mik i Afërt gjenerohet duke mbledhur vlerat ASCII të secilit çift karakteresh ngjitur në vargun hyrës, \n   duke krijuar një karakter të ri nga shuma. Për karakterin e fundit të vargut Mik i Afërt, mblidhni vlerën ASCII të \n   karakterit të fundit dhe të parë të vargut hyrës. Gjatësia e vargut hyrës duhet të jetë midis 2 dhe 100 karaktere, dhe \n   vlera ASCII e secilit karakter nuk duhet të kalojë 63.\n\n   Shembull:\n   >>> GenerateCloseFriendString(\"1234\")\n   \"cege\"",
      "hy": "Այս ֆունկցիան որպես մուտք ընդունում է տող և վերադարձնում 'Close Friend' տող՝ հիմնված հատուկ ASCII արժեքների մանիպուլյացիաների վրա:\n   'Close Friend' տողը ստեղծվում է մուտքային տողի հարևան յուրաքանչյուր զույգ նիշերի ASCII արժեքների գումարով՝ ստեղծելով նոր նիշ այդ գումարից: 'Close Friend' տողի վերջին նիշի համար գումարեք մուտքային տողի վերջին և առաջին նիշերի ASCII արժեքները: Մուտքային տողի երկարությունը պետք է լինի 2-ից 100 նիշ, և յուրաքանչյուր նիշի ASCII արժեքը չպետք է գերազանցի 63-ը:\n\n   Օրինակ:\n   >>> GenerateCloseFriendString(\"1234\")\n   \"cege\"",
      "bn": "এই ফাংশনটি একটি স্ট্রিং ইনপুট হিসেবে গ্রহণ করে এবং নির্দিষ্ট ASCII মানের পরিবর্তনের উপর ভিত্তি করে একটি 'Close Friend' স্ট্রিং রিটার্ন করে।\n   'Close Friend' স্ট্রিংটি ইনপুট স্ট্রিংয়ের প্রতিটি সংলগ্ন অক্ষরের ASCII মানের যোগফল দ্বারা তৈরি হয়,\n   যোগফল থেকে একটি নতুন অক্ষর তৈরি করা হয়। 'Close Friend' স্ট্রিংয়ের শেষ অক্ষরের জন্য, ইনপুট স্ট্রিংয়ের শেষ এবং প্রথম অক্ষরের ASCII মানের যোগফল নিন। ইনপুট স্ট্রিংয়ের দৈর্ঘ্য 2 থেকে 100 অক্ষরের মধ্যে হওয়া উচিত, এবং \n   প্রতিটি অক্ষরের ASCII মান 63 এর বেশি হওয়া উচিত নয়।\n\n   উদাহরণ:\n   >>> GenerateCloseFriendString(\"1234\")\n   \"cege\"",
      "bg": "Тази функция приема низ като вход и връща низ 'Close Friend' на базата на специфични манипулации с ASCII стойности. \n   Низът 'Close Friend' се генерира чрез сумиране на ASCII стойностите на всяка двойка съседни символи в входния низ,\n   създавайки нов символ от сумата. За последния символ на низа 'Close Friend', сумирайте ASCII стойността на \n   последния и първия символи на входния низ. Дължината на входния низ трябва да бъде между 2 и 100 символа, а \n   ASCII стойността на всеки символ не трябва да надвишава 63.\n\n   Пример:\n   >>> GenerateCloseFriendString(\"1234\")\n   \"cege\"",
      "zh": "此函数接受一个字符串作为输入，并基于特定的ASCII值操作返回一个“Close Friend”字符串。\n   通过对输入字符串中每对相邻字符的ASCII值求和来生成Close Friend字符串，\n   从求和结果创建一个新字符。对于Close Friend字符串的最后一个字符，将输入字符串的最后一个字符和第一个字符的ASCII值相加。输入字符串的长度应在2到100个字符之间，并且每个字符的ASCII值不应超过63。\n\n   示例：\n   >>> GenerateCloseFriendString(\"1234\")\n   \"cege\"",
      "fr": "Cette fonction prend une chaîne de caractères en entrée et renvoie une chaîne 'Ami Proche' basée sur des manipulations spécifiques des valeurs ASCII. La chaîne Ami Proche est générée en additionnant les valeurs ASCII de chaque paire de caractères adjacents dans la chaîne d'entrée, créant un nouveau caractère à partir de la somme. Pour le dernier caractère de la chaîne Ami Proche, additionnez la valeur ASCII du dernier et du premier caractère de la chaîne d'entrée. La longueur de la chaîne d'entrée doit être comprise entre 2 et 100 caractères, et la valeur ASCII de chaque caractère ne doit pas dépasser 63.\n\n   Exemple :\n   >>> GenerateCloseFriendString(\"1234\")\n   \"cege\"",
      "de": "Diese Funktion nimmt einen String als Eingabe und gibt einen 'Close Friend'-String basierend auf spezifischen ASCII-Wert-Manipulationen zurück.\n   Der Close Friend-String wird erzeugt, indem die ASCII-Werte jedes Paares benachbarter Zeichen im Eingabestring summiert werden,\n   und ein neues Zeichen aus der Summe erstellt wird. Für das letzte Zeichen des Close Friend-Strings wird die Summe aus dem ASCII-Wert des \n   letzten und des ersten Zeichens des Eingabestrings gebildet. Die Länge des Eingabestrings sollte zwischen 2 und 100 Zeichen liegen, und \n   der ASCII-Wert jedes Zeichens sollte 63 nicht überschreiten.\n\n   Beispiel:\n   >>> GenerateCloseFriendString(\"1234\")\n   \"cege\"",
      "ha": "Wannan aikin yana ɗaukar kirtani a matsayin shigarwa kuma yana mayar da kirtani 'Aboki Mai Kusa' bisa ga takamaiman sarrafa ƙimar ASCII.\n   Ana samar da kirtanin Aboki Mai Kusa ta hanyar tara ƙimar ASCII na kowanne biyu na haruffa masu makwabtaka a cikin kirtanin shigarwa,\n   yana ƙirƙirar sabon hali daga tarin. Don harafin ƙarshe na kirtanin Aboki Mai Kusa, tara ƙimar ASCII na harafin ƙarshe da na farko na kirtanin shigarwa. Tsawon kirtanin shigarwa ya kamata ya kasance tsakanin haruffa 2 zuwa 100, kuma ƙimar ASCII na kowane hali bai kamata ya wuce 63 ba.\n\n   Misali:\n   >>> GenerateCloseFriendString(\"1234\")\n   \"cege\"",
      "hi": "इस फ़ंक्शन में एक स्ट्रिंग को इनपुट के रूप में लिया जाता है और विशिष्ट ASCII मान हेरफेर के आधार पर एक 'Close Friend' स्ट्रिंग लौटाई जाती है। \n   Close Friend स्ट्रिंग इनपुट स्ट्रिंग में प्रत्येक जोड़ी के आसन्न वर्णों के ASCII मानों को जोड़कर उत्पन्न की जाती है, \n   और योग से एक नया वर्ण बनाया जाता है। Close Friend स्ट्रिंग के अंतिम वर्ण के लिए, इनपुट स्ट्रिंग के अंतिम और पहले वर्णों के \n   ASCII मानों को जोड़ें। इनपुट स्ट्रिंग की लंबाई 2 से 100 वर्णों के बीच होनी चाहिए, और \n   प्रत्येक वर्ण का ASCII मान 63 से अधिक नहीं होना चाहिए।\n\n   उदाहरण:\n   >>> GenerateCloseFriendString(\"1234\")\n   \"cege\"",
      "hu": "Ez a függvény egy karakterláncot vesz bemenetként, és egy 'Közeli Barát' karakterláncot ad vissza specifikus ASCII érték manipulációk alapján.\n   A Közeli Barát karakterlánc úgy jön létre, hogy az input karakterlánc minden szomszédos karakterpárjának ASCII értékeit összeadjuk,\n   és az összegből egy új karaktert hozunk létre. A Közeli Barát karakterlánc utolsó karakteréhez az input karakterlánc utolsó és első karakterének\n   ASCII értékét adjuk össze. Az input karakterlánc hossza 2 és 100 karakter között kell legyen, és minden karakter ASCII értéke nem haladhatja meg a 63-at.\n\n   Példa:\n   >>> GenerateCloseFriendString(\"1234\")\n   \"cege\""
    },
    "docstring_bertscore": {
      "sq": "0.9635036537886497",
      "hy": "0.9627673309661533",
      "bn": "0.9338523091381425",
      "bg": "0.9595669982669192",
      "zh": "0.9517369886465239",
      "fr": "0.9635036537886497",
      "de": "0.9657173893852835",
      "ha": "0.9777424726531356",
      "hi": "0.9655479576702607",
      "hu": "0.9542623753110014"
    }
  },
  {
    "task_id": "C#/28",
    "prompt": {
      "en": "using System;\nusing System.Collections.Generic;\nusing System.Diagnostics;\n\nclass Program\n{\n\n/*\n    Decrypts a cipher text that was encrypted using a Caesar cipher with a 5-letter shift.\n    The function only shifts uppercase alphabetic characters and leaves other characters unchanged.\n    Example:\n    >>> DecryptCaesarCipher(\"NS BFW, JAJSYX TK NRUTWYFSHJ FWJ YMJ WJXZQY TK YWNANFQ HFZXJX\")\n    \"IN WAR, EVENTS OF IMPORTANCE ARE THE RESULT OF TRIVIAL CAUSES\"\n\n*/\n    static string DecryptCaesarCipher(string cipherText)",
      "sq": "using System;\nusing System.Collections.Generic;\nusing System.Diagnostics;\n\nclass Program\n{\n\n/*\n    Dekripton një tekst të koduar që është enkriptuar duke përdorur një kod Caesar me një zhvendosje prej 5 shkronjash.\n    Funksioni zhvendos vetëm karakteret alfabetike me shkronja të mëdha dhe lë karakteret e tjera të pandryshuara.\n    Shembull:\n    >>> DecryptCaesarCipher(\"NS BFW, JAJSYX TK NRUTWYFSHJ FWJ YMJ WJXZQY TK YWNANFQ HFZXJX\")\n    \"IN WAR, EVENTS OF IMPORTANCE ARE THE RESULT OF TRIVIAL CAUSES\"\n\n*/\n    static string DecryptCaesarCipher(string cipherText)",
      "hy": "using System;\nusing System.Collections.Generic;\nusing System.Diagnostics;\n\nclass Program\n{\n\n/*\n    Ապակոդավորում է ծածկագիրը, որը կոդավորվել է Կեսարի ծածկագրով՝ 5 տառի տեղաշարժով:\n    Ֆունկցիան տեղաշարժում է միայն մեծատառ այբբենական նիշերը և թողնում է այլ նիշերը անփոփոխ:\n    Օրինակ:\n    >>> DecryptCaesarCipher(\"NS BFW, JAJSYX TK NRUTWYFSHJ FWJ YMJ WJXZQY TK YWNANFQ HFZXJX\")\n    \"IN WAR, EVENTS OF IMPORTANCE ARE THE RESULT OF TRIVIAL CAUSES\"\n\n*/\n    static string DecryptCaesarCipher(string cipherText)",
      "bn": "using System;\nusing System.Collections.Generic;\nusing System.Diagnostics;\n\nclass Program\n{\n\n/*\n    একটি সিজার সাইফার দিয়ে এনক্রিপ্ট করা সাইফার টেক্সট ডিক্রিপ্ট করে যা ৫-অক্ষরের শিফট ব্যবহার করে এনক্রিপ্ট করা হয়েছিল।\n    ফাংশনটি শুধুমাত্র বড় হাতের বর্ণমালার অক্ষরগুলিকে শিফট করে এবং অন্যান্য অক্ষর অপরিবর্তিত রাখে।\n    উদাহরণ:\n    >>> DecryptCaesarCipher(\"NS BFW, JAJSYX TK NRUTWYFSHJ FWJ YMJ WJXZQY TK YWNANFQ HFZXJX\")\n    \"IN WAR, EVENTS OF IMPORTANCE ARE THE RESULT OF TRIVIAL CAUSES\"\n\n*/\n    static string DecryptCaesarCipher(string cipherText)",
      "bg": "using System;\nusing System.Collections.Generic;\nusing System.Diagnostics;\n\nclass Program\n{\n\n/*\n    Декриптира шифрован текст, който е бил криптиран с шифър на Цезар с 5-буквено изместване.\n    Функцията измествa само главни букви от азбуката и оставя другите символи непроменени.\n    Пример:\n    >>> DecryptCaesarCipher(\"NS BFW, JAJSYX TK NRUTWYFSHJ FWJ YMJ WJXZQY TK YWNANFQ HFZXJX\")\n    \"IN WAR, EVENTS OF IMPORTANCE ARE THE RESULT OF TRIVIAL CAUSES\"\n\n*/\n    static string DecryptCaesarCipher(string cipherText)",
      "zh": "using System;\nusing System.Collections.Generic;\nusing System.Diagnostics;\n\nclass Program\n{\n\n/*\n    解密使用凯撒密码加密的密文，该密码使用了5个字母的移位。\n    该函数仅对大写字母字符进行移位，其他字符保持不变。\n    示例：\n    >>> DecryptCaesarCipher(\"NS BFW, JAJSYX TK NRUTWYFSHJ FWJ YMJ WJXZQY TK YWNANFQ HFZXJX\")\n    \"IN WAR, EVENTS OF IMPORTANCE ARE THE RESULT OF TRIVIAL CAUSES\"\n\n*/\n    static string DecryptCaesarCipher(string cipherText)",
      "fr": "using System;\nusing System.Collections.Generic;\nusing System.Diagnostics;\n\nclass Program\n{\n\n/*\n    Décrypte un texte chiffré qui a été crypté en utilisant un chiffre de César avec un décalage de 5 lettres.\n    La fonction ne décale que les caractères alphabétiques majuscules et laisse les autres caractères inchangés.\n    Exemple:\n    >>> DecryptCaesarCipher(\"NS BFW, JAJSYX TK NRUTWYFSHJ FWJ YMJ WJXZQY TK YWNANFQ HFZXJX\")\n    \"IN WAR, EVENTS OF IMPORTANCE ARE THE RESULT OF TRIVIAL CAUSES\"\n\n*/\n    static string DecryptCaesarCipher(string cipherText)",
      "de": "using System;\nusing System.Collections.Generic;\nusing System.Diagnostics;\n\nclass Program\n{\n\n/*\n    Entschlüsselt einen Chiffretext, der mit einer Caesar-Chiffre mit einer Verschiebung von 5 Buchstaben verschlüsselt wurde.\n    Die Funktion verschiebt nur Großbuchstaben und lässt andere Zeichen unverändert.\n    Beispiel:\n    >>> DecryptCaesarCipher(\"NS BFW, JAJSYX TK NRUTWYFSHJ FWJ YMJ WJXZQY TK YWNANFQ HFZXJX\")\n    \"IN WAR, EVENTS OF IMPORTANCE ARE THE RESULT OF TRIVIAL CAUSES\"\n\n*/\n    static string DecryptCaesarCipher(string cipherText)",
      "ha": "using System;\nusing System.Collections.Generic;\nusing System.Diagnostics;\n\nclass Program\n{\n\n/*\n    Yana warware rubutun sirri da aka ɓoye ta amfani da sirrin Caesar tare da juyawa haruffa 5.\n    Aiki yana juyawa kawai manyan haruffan alphabet kuma yana barin sauran haruffa ba tare da canji ba.\n    Misali:\n    >>> DecryptCaesarCipher(\"NS BFW, JAJSYX TK NRUTWYFSHJ FWJ YMJ WJXZQY TK YWNANFQ HFZXJX\")\n    \"IN WAR, EVENTS OF IMPORTANCE ARE THE RESULT OF TRIVIAL CAUSES\"\n\n*/\n    static string DecryptCaesarCipher(string cipherText)",
      "hi": "using System;\nusing System.Collections.Generic;\nusing System.Diagnostics;\n\nclass Program\n{\n\n/*\n    एक सिफर पाठ को डिक्रिप्ट करता है जिसे एक सीज़र सिफर के साथ 5-अक्षर शिफ्ट का उपयोग करके एन्क्रिप्ट किया गया था।\n    फ़ंक्शन केवल बड़े अक्षरों वाले वर्णों को शिफ्ट करता है और अन्य वर्णों को अपरिवर्तित छोड़ देता है।\n    उदाहरण:\n    >>> DecryptCaesarCipher(\"NS BFW, JAJSYX TK NRUTWYFSHJ FWJ YMJ WJXZQY TK YWNANFQ HFZXJX\")\n    \"IN WAR, EVENTS OF IMPORTANCE ARE THE RESULT OF TRIVIAL CAUSES\"\n\n*/\n    static string DecryptCaesarCipher(string cipherText)",
      "hu": "using System;\nusing System.Collections.Generic;\nusing System.Diagnostics;\n\nclass Program\n{\n\n/*\n    Visszafejt egy titkos szöveget, amelyet egy 5 betűs eltolással rendelkező Caesar-rejtjel segítségével titkosítottak.\n    A függvény csak a nagybetűs alfabetikus karaktereket tolja el, és más karaktereket változatlanul hagy.\n    Példa:\n    >>> DecryptCaesarCipher(\"NS BFW, JAJSYX TK NRUTWYFSHJ FWJ YMJ WJXZQY TK YWNANFQ HFZXJX\")\n    \"IN WAR, EVENTS OF IMPORTANCE ARE THE RESULT OF TRIVIAL CAUSES\"\n\n*/\n    static string DecryptCaesarCipher(string cipherText)"
    },
    "prompt_bertscore": {
      "sq": "0.9856622632057587",
      "hy": "0.9776240889460388",
      "bn": "0.9862309419866615",
      "bg": "0.977761938430477",
      "zh": "0.9540921490744546",
      "fr": "0.982157032871636",
      "de": "0.9734381522961095",
      "ha": "0.9604274650775624",
      "hi": "0.9828079446302873",
      "hu": "0.9775337121226679"
    },
    "canonical_solution": "    {\n        char[] decrypted = new char[cipherText.Length];\n        for (int i = 0; i < cipherText.Length; i++)\n        {\n            char ch = cipherText[i];\n            if (char.IsUpper(ch))\n            {\n                decrypted[i] = (char)((ch - 'A' - 5 + 26) % 26 + 'A');\n            }\n            else\n            {\n                decrypted[i] = ch;\n            }\n        }\n        return new string(decrypted);\n    }",
    "instruction": {
      "en": "Write a C# function `static string DecryptCaesarCipher(string cipherText)` to solve the following problem:\nDecrypts a cipher text that was encrypted using a Caesar cipher with a 5-letter shift.\n    The function only shifts uppercase alphabetic characters and leaves other characters unchanged.\n    Example:\n    >>> DecryptCaesarCipher(\"NS BFW, JAJSYX TK NRUTWYFSHJ FWJ YMJ WJXZQY TK YWNANFQ HFZXJX\")\n    \"IN WAR, EVENTS OF IMPORTANCE ARE THE RESULT OF TRIVIAL CAUSES\"",
      "sq": "Shkruani një funksion në C# `static string DecryptCaesarCipher(string cipherText)` për të zgjidhur problemin e mëposhtëm:\nDekriptimi i një teksti të koduar që është enkriptuar duke përdorur një kod Caesar me një zhvendosje prej 5 shkronjash.\n    Funksioni vetëm zhvendos karakteret alfabetike me shkronja të mëdha dhe lë karakteret e tjera të pandryshuara.\n    Shembull:\n    >>> DecryptCaesarCipher(\"NS BFW, JAJSYX TK NRUTWYFSHJ FWJ YMJ WJXZQY TK YWNANFQ HFZXJX\")\n    \"IN WAR, EVENTS OF IMPORTANCE ARE THE RESULT OF TRIVIAL CAUSES\"",
      "hy": "Գրեք C# ֆունկցիա `static string DecryptCaesarCipher(string cipherText)` հետևյալ խնդիրը լուծելու համար:\nԱպակոդավորում է ծածկագիր տեքստը, որը կոդավորվել է Կեսարի ծածկագրով՝ 5 տառի տեղաշարժով:\n    Ֆունկցիան միայն տեղաշարժում է մեծատառ այբբենական նիշերը և թողնում է այլ նիշերը անփոփոխ:\n    Օրինակ:\n    >>> DecryptCaesarCipher(\"NS BFW, JAJSYX TK NRUTWYFSHJ FWJ YMJ WJXZQY TK YWNANFQ HFZXJX\")\n    \"IN WAR, EVENTS OF IMPORTANCE ARE THE RESULT OF TRIVIAL CAUSES\"",
      "bn": "C# ফাংশন `static string DecryptCaesarCipher(string cipherText)` লিখুন নিম্নলিখিত সমস্যার সমাধানের জন্য:\nএকটি সাইফার টেক্সট ডিক্রিপ্ট করে যা ৫-অক্ষরের শিফট সহ সিজার সাইফার ব্যবহার করে এনক্রিপ্ট করা হয়েছিল।\n    ফাংশন শুধুমাত্র বড় হাতের বর্ণমালার অক্ষরগুলিকে শিফট করে এবং অন্যান্য অক্ষর অপরিবর্তিত রাখে।\n    উদাহরণ:\n    >>> DecryptCaesarCipher(\"NS BFW, JAJSYX TK NRUTWYFSHJ FWJ YMJ WJXZQY TK YWNANFQ HFZXJX\")\n    \"IN WAR, EVENTS OF IMPORTANCE ARE THE RESULT OF TRIVIAL CAUSES\"",
      "bg": "Напишете C# функция `static string DecryptCaesarCipher(string cipherText)` за решаване на следния проблем:  \nДекриптира шифрован текст, който е бил криптиран с шифър на Цезар с 5-буквено изместване.  \nФункцията измествa само главни азбучни символи и оставя другите символи непроменени.  \nПример:  \n>>> DecryptCaesarCipher(\"NS BFW, JAJSYX TK NRUTWYFSHJ FWJ YMJ WJXZQY TK YWNANFQ HFZXJX\")  \n\"IN WAR, EVENTS OF IMPORTANCE ARE THE RESULT OF TRIVIAL CAUSES\"",
      "zh": "编写一个 C# 函数 `static string DecryptCaesarCipher(string cipherText)` 来解决以下问题：\n解密使用凯撒密码加密的密文，该密文使用了5个字母的移位。\n    该函数仅移动大写字母字符，其他字符保持不变。\n    示例:\n    >>> DecryptCaesarCipher(\"NS BFW, JAJSYX TK NRUTWYFSHJ FWJ YMJ WJXZQY TK YWNANFQ HFZXJX\")\n    \"IN WAR, EVENTS OF IMPORTANCE ARE THE RESULT OF TRIVIAL CAUSES\"",
      "fr": "Écrire une fonction C# `static string DecryptCaesarCipher(string cipherText)` pour résoudre le problème suivant :\nDécrypte un texte chiffré qui a été crypté en utilisant un chiffre de César avec un décalage de 5 lettres.\n    La fonction ne décale que les caractères alphabétiques majuscules et laisse les autres caractères inchangés.\n    Exemple :\n    >>> DecryptCaesarCipher(\"NS BFW, JAJSYX TK NRUTWYFSHJ FWJ YMJ WJXZQY TK YWNANFQ HFZXJX\")\n    \"IN WAR, EVENTS OF IMPORTANCE ARE THE RESULT OF TRIVIAL CAUSES\"",
      "de": "Schreiben Sie eine C#-Funktion `static string DecryptCaesarCipher(string cipherText)`, um das folgende Problem zu lösen:\nEntschlüsselt einen Geheimtext, der mit einem Caesar-Verschlüsselungsverfahren mit einer Verschiebung von 5 Buchstaben verschlüsselt wurde.\n    Die Funktion verschiebt nur Großbuchstaben und lässt andere Zeichen unverändert.\n    Beispiel:\n    >>> DecryptCaesarCipher(\"NS BFW, JAJSYX TK NRUTWYFSHJ FWJ YMJ WJXZQY TK YWNANFQ HFZXJX\")\n    \"IN WAR, EVENTS OF IMPORTANCE ARE THE RESULT OF TRIVIAL CAUSES\"",
      "ha": "Rubuta aikin C# `static string DecryptCaesarCipher(string cipherText)` don warware matsalar mai zuwa:\nFassara rubutun sirri wanda aka ɓoye ta amfani da sifirin Caesar tare da juyawa haruffa 5.\n    Aikin yana canza haruffan manyan baƙaƙe kawai kuma yana barin sauran haruffa ba tare da canji ba.\n    Misali:\n    >>> DecryptCaesarCipher(\"NS BFW, JAJSYX TK NRUTWYFSHJ FWJ YMJ WJXZQY TK YWNANFQ HFZXJX\")\n    \"IN WAR, EVENTS OF IMPORTANCE ARE THE RESULT OF TRIVIAL CAUSES\"",
      "hi": "C# फ़ंक्शन `static string DecryptCaesarCipher(string cipherText)` लिखें ताकि निम्नलिखित समस्या का समाधान हो सके:\nएक सिफर टेक्स्ट को डिक्रिप्ट करता है जिसे 5-अक्षर शिफ्ट के साथ एक सीज़र सिफर का उपयोग करके एन्क्रिप्ट किया गया था।\n    फ़ंक्शन केवल अपरकेस वर्णमाला वर्णों को शिफ्ट करता है और अन्य वर्णों को अपरिवर्तित छोड़ देता है।\n    उदाहरण:\n    >>> DecryptCaesarCipher(\"NS BFW, JAJSYX TK NRUTWYFSHJ FWJ YMJ WJXZQY TK YWNANFQ HFZXJX\")\n    \"IN WAR, EVENTS OF IMPORTANCE ARE THE RESULT OF TRIVIAL CAUSES\"",
      "hu": "Írj egy C# függvényt `static string DecryptCaesarCipher(string cipherText)` a következő probléma megoldására:\nDekódol egy titkos szöveget, amelyet egy Caesar-rejtjel segítségével titkosítottak 5 betűs eltolással.\n    A függvény csak a nagybetűs ábécé karaktereket tolja el, és más karaktereket változatlanul hagy.\n    Példa:\n    >>> DecryptCaesarCipher(\"NS BFW, JAJSYX TK NRUTWYFSHJ FWJ YMJ WJXZQY TK YWNANFQ HFZXJX\")\n    \"IN WAR, EVENTS OF IMPORTANCE ARE THE RESULT OF TRIVIAL CAUSES\""
    },
    "instruction_bertscore": {
      "sq": "0.9758834909170301",
      "hy": "0.9813307304865309",
      "bn": "0.978792631477667",
      "bg": "0.9926041963925469",
      "zh": "0.9599620740947976",
      "fr": "0.9781689320812175",
      "de": "0.9717364858217837",
      "ha": "0.9459177143733448",
      "hi": "0.964058031182118",
      "hu": "0.9729477338853344"
    },
    "level": "easy",
    "test": "static void Main()\n    {\n        Debug.Assert(DecryptCaesarCipher(\"NS BFW, JAJSYX TK NRUTWYFSHJ FWJ YMJ WJXZQY TK YWNANFQ HFZXJX\") == \"IN WAR, EVENTS OF IMPORTANCE ARE THE RESULT OF TRIVIAL CAUSES\");\n        Debug.Assert(DecryptCaesarCipher(\"F XYWNFYNTS YT XJHWJY\") == \"A STRIATION TO SECRET\");\n        Debug.Assert(DecryptCaesarCipher(\"YMJ VZNHP TS X HNUMJW\") == \"THE QUICK ON S CIPHER\");\n        Debug.Assert(DecryptCaesarCipher(\"JXU UQFSI QDT TZW YMZXW\") == \"ESP PLAND LYO OUR THUSR\");\n    }\n}",
    "entry_point": "DecryptCaesarCipher",
    "signature": "static string DecryptCaesarCipher(string cipherText)",
    "docstring": {
      "en": "Decrypts a cipher text that was encrypted using a Caesar cipher with a 5-letter shift.\n    The function only shifts uppercase alphabetic characters and leaves other characters unchanged.\n    Example:\n    >>> DecryptCaesarCipher(\"NS BFW, JAJSYX TK NRUTWYFSHJ FWJ YMJ WJXZQY TK YWNANFQ HFZXJX\")\n    \"IN WAR, EVENTS OF IMPORTANCE ARE THE RESULT OF TRIVIAL CAUSES\"",
      "sq": "Dekripton një tekst të koduar që ishte koduar duke përdorur një kod Caesar me një zhvendosje prej 5 shkronjash.\n    Funksioni zhvendos vetëm karakteret alfabetike me shkronja të mëdha dhe lë të pandryshuara karakteret e tjera.\n    Shembull:\n    >>> DecryptCaesarCipher(\"NS BFW, JAJSYX TK NRUTWYFSHJ FWJ YMJ WJXZQY TK YWNANFQ HFZXJX\")\n    \"IN WAR, EVENTS OF IMPORTANCE ARE THE RESULT OF TRIVIAL CAUSES\"",
      "hy": "Վերծանում է գաղտնագիրը, որը կոդավորվել է Կեսարի գաղտնագրով՝ 5 տառի տեղաշարժով:\n    Ֆունկցիան տեղաշարժում է միայն մեծատառ այբուբենային նիշերը և թողնում է այլ նիշերը անփոփոխ:\n    Օրինակ:\n    >>> DecryptCaesarCipher(\"NS BFW, JAJSYX TK NRUTWYFSHJ FWJ YMJ WJXZQY TK YWNANFQ HFZXJX\")\n    \"IN WAR, EVENTS OF IMPORTANCE ARE THE RESULT OF TRIVIAL CAUSES\"",
      "bn": "একটি সিজার সাইফার ব্যবহার করে ৫-অক্ষরের শিফট দিয়ে এনক্রিপ্ট করা সাইফার টেক্সট ডিক্রিপ্ট করে।\n    ফাংশনটি শুধুমাত্র বড় হাতের বর্ণমালার অক্ষরগুলিকে শিফট করে এবং অন্যান্য অক্ষর অপরিবর্তিত রাখে।\n    উদাহরণ:\n    >>> DecryptCaesarCipher(\"NS BFW, JAJSYX TK NRUTWYFSHJ FWJ YMJ WJXZQY TK YWNANFQ HFZXJX\")\n    \"IN WAR, EVENTS OF IMPORTANCE ARE THE RESULT OF TRIVIAL CAUSES\"",
      "bg": "Декриптира шифрован текст, който е бил кодиран с шифър на Цезар с 5-буквено изместване.\n    Функцията изместа само главни азбучни символи и оставя другите символи непроменени.\n    Пример:\n    >>> DecryptCaesarCipher(\"NS BFW, JAJSYX TK NRUTWYFSHJ FWJ YMJ WJXZQY TK YWNANFQ HFZXJX\")\n    \"IN WAR, EVENTS OF IMPORTANCE ARE THE RESULT OF TRIVIAL CAUSES\"",
      "zh": "解密使用凯撒密码加密的密文，该密码使用了5个字母的位移。\n    该函数仅移动大写字母字符，并保持其他字符不变。\n    示例：\n    >>> DecryptCaesarCipher(\"NS BFW, JAJSYX TK NRUTWYFSHJ FWJ YMJ WJXZQY TK YWNANFQ HFZXJX\")\n    \"IN WAR, EVENTS OF IMPORTANCE ARE THE RESULT OF TRIVIAL CAUSES\"",
      "fr": "Déchiffre un texte chiffré qui a été crypté en utilisant un chiffre de César avec un décalage de 5 lettres.\n    La fonction ne décale que les caractères alphabétiques majuscules et laisse les autres caractères inchangés.\n    Exemple :\n    >>> DecryptCaesarCipher(\"NS BFW, JAJSYX TK NRUTWYFSHJ FWJ YMJ WJXZQY TK YWNANFQ HFZXJX\")\n    \"IN WAR, EVENTS OF IMPORTANCE ARE THE RESULT OF TRIVIAL CAUSES\"",
      "de": "Entschlüsselt einen Chiffretext, der mit einem Caesar-Chiffre mit einer Verschiebung von 5 Buchstaben verschlüsselt wurde.\n    Die Funktion verschiebt nur Großbuchstaben und lässt andere Zeichen unverändert.\n    Beispiel:\n    >>> DecryptCaesarCipher(\"NS BFW, JAJSYX TK NRUTWYFSHJ FWJ YMJ WJXZQY TK YWNANFQ HFZXJX\")\n    \"IN WAR, EVENTS OF IMPORTANCE ARE THE RESULT OF TRIVIAL CAUSES\"",
      "ha": "Yana warware rubutun sirri da aka ɓoye ta amfani da sirrin Caesar tare da juyawa haruffa 5.\n    Aikin yana canza haruffa manya ne kawai kuma yana barin sauran haruffa ba tare da canzawa ba.\n    Misali:\n    >>> DecryptCaesarCipher(\"NS BFW, JAJSYX TK NRUTWYFSHJ FWJ YMJ WJXZQY TK YWNANFQ HFZXJX\")\n    \"IN WAR, EVENTS OF IMPORTANCE ARE THE RESULT OF TRIVIAL CAUSES\"",
      "hi": "किसी सिफर पाठ को डिक्रिप्ट करता है जिसे 5-अक्षर शिफ्ट के साथ एक सीज़र सिफर का उपयोग करके एन्क्रिप्ट किया गया था।\n    यह फ़ंक्शन केवल बड़े अक्षरों वाले वर्णमाला वर्णों को शिफ्ट करता है और अन्य वर्णों को अपरिवर्तित छोड़ देता है।\n    उदाहरण:\n    >>> DecryptCaesarCipher(\"NS BFW, JAJSYX TK NRUTWYFSHJ FWJ YMJ WJXZQY TK YWNANFQ HFZXJX\")\n    \"IN WAR, EVENTS OF IMPORTANCE ARE THE RESULT OF TRIVIAL CAUSES\"",
      "hu": "Visszafejt egy titkos szöveget, amelyet egy 5 betűs eltolással titkosítottak Caesar-rejtjel segítségével.\n    A függvény csak a nagybetűs ábécé karaktereit tolja el, és más karaktereket változatlanul hagy.\n    Példa:\n    >>> DecryptCaesarCipher(\"NS BFW, JAJSYX TK NRUTWYFSHJ FWJ YMJ WJXZQY TK YWNANFQ HFZXJX\")\n    \"IN WAR, EVENTS OF IMPORTANCE ARE THE RESULT OF TRIVIAL CAUSES\""
    },
    "docstring_bertscore": {
      "sq": "0.985390536844503",
      "hy": "0.9791239469532332",
      "bn": "0.974629934582319",
      "bg": "0.9865878807813813",
      "zh": "0.9508071998328996",
      "fr": "0.9854733657133945",
      "de": "0.9667256371994166",
      "ha": "0.9660707528331446",
      "hi": "0.9908602216470607",
      "hu": "0.9726100622375752"
    }
  },
  {
    "task_id": "C#/29",
    "prompt": {
      "en": "using System;\nusing System.Collections.Generic;\nusing System.Diagnostics;\n\nclass Program\n{\n    /* Determines which of the two provided strings is a substring of the other. \n    If neither string is a substring of the other, it returns \"No substring\".\n    >>> CheckSubstring(\"hello\", \"world\")\n    \"No substring\"\n    >>> CheckSubstring(\"code\", \"decode\")\n    \"code is substring of decode\"\n    >>> CheckSubstring(\"book\", \"notebook\")\n    \"book is substring of notebook\"\n    */\n\n    static string CheckSubstring(string str1, string str2)",
      "sq": "using System;\nusing System.Collections.Generic;\nusing System.Diagnostics;\n\nclass Program\n{\n    /* Përcakton se cila nga dy vargjet e dhëna është një nënvarg i tjetrit.\n    Nëse asnjëri varg nuk është nënvarg i tjetrit, kthen \"No substring\".\n    >>> CheckSubstring(\"hello\", \"world\")\n    \"No substring\"\n    >>> CheckSubstring(\"code\", \"decode\")\n    \"code is substring of decode\"\n    >>> CheckSubstring(\"book\", \"notebook\")\n    \"book is substring of notebook\"\n    */\n\n    static string CheckSubstring(string str1, string str2)",
      "hy": "using System;\nusing System.Collections.Generic;\nusing System.Diagnostics;\n\nclass Program\n{\n    /* Որոշում է, թե տրված երկու տողերից որը մյուսի ենթատողն է:\n    Եթե ոչ մի տող մյուսի ենթատողը չէ, վերադարձնում է \"No substring\":\n    >>> CheckSubstring(\"hello\", \"world\")\n    \"No substring\"\n    >>> CheckSubstring(\"code\", \"decode\")\n    \"code is substring of decode\"\n    >>> CheckSubstring(\"book\", \"notebook\")\n    \"book is substring of notebook\"\n    */\n\n    static string CheckSubstring(string str1, string str2)",
      "bn": "using System;\nusing System.Collections.Generic;\nusing System.Diagnostics;\n\nclass Program\n{\n    /* প্রদত্ত দুটি স্ট্রিং এর মধ্যে কোনটি অন্যটির সাবস্ট্রিং তা নির্ধারণ করে।\n    যদি কোন স্ট্রিং অন্যটির সাবস্ট্রিং না হয়, তাহলে এটি \"No substring\" ফেরত দেয়।\n    >>> CheckSubstring(\"hello\", \"world\")\n    \"No substring\"\n    >>> CheckSubstring(\"code\", \"decode\")\n    \"code is substring of decode\"\n    >>> CheckSubstring(\"book\", \"notebook\")\n    \"book is substring of notebook\"\n    */\n\n    static string CheckSubstring(string str1, string str2)",
      "bg": "using System;\nusing System.Collections.Generic;\nusing System.Diagnostics;\n\nclass Program\n{\n    /* Определя коя от двете предоставени низове е подниз на другата. \n    Ако нито един от низовете не е подниз на другия, връща \"Няма подниз\".\n    >>> CheckSubstring(\"hello\", \"world\")\n    \"No substring\"\n    >>> CheckSubstring(\"code\", \"decode\")\n    \"code is substring of decode\"\n    >>> CheckSubstring(\"book\", \"notebook\")\n    \"book is substring of notebook\"\n    */\n\n    static string CheckSubstring(string str1, string str2)",
      "zh": "using System;\nusing System.Collections.Generic;\nusing System.Diagnostics;\n\nclass Program\n{\n    /* 确定提供的两个字符串中哪个是另一个的子字符串。\n    如果两个字符串都不是另一个的子字符串，则返回 \"No substring\"。\n    >>> CheckSubstring(\"hello\", \"world\")\n    \"No substring\"\n    >>> CheckSubstring(\"code\", \"decode\")\n    \"code is substring of decode\"\n    >>> CheckSubstring(\"book\", \"notebook\")\n    \"book is substring of notebook\"\n    */\n\n    static string CheckSubstring(string str1, string str2)",
      "fr": "using System;\nusing System.Collections.Generic;\nusing System.Diagnostics;\n\nclass Program\n{\n    /* Détermine laquelle des deux chaînes fournies est une sous-chaîne de l'autre.\n    Si aucune des chaînes n'est une sous-chaîne de l'autre, elle renvoie \"No substring\".\n    >>> CheckSubstring(\"hello\", \"world\")\n    \"No substring\"\n    >>> CheckSubstring(\"code\", \"decode\")\n    \"code is substring of decode\"\n    >>> CheckSubstring(\"book\", \"notebook\")\n    \"book is substring of notebook\"\n    */\n\n    static string CheckSubstring(string str1, string str2)",
      "de": "using System;\nusing System.Collections.Generic;\nusing System.Diagnostics;\n\nclass Program\n{\n    /* Bestimmt, welche der beiden bereitgestellten Zeichenfolgen eine Teilzeichenfolge der anderen ist.\n    Wenn keine der beiden Zeichenfolgen eine Teilzeichenfolge der anderen ist, gibt sie \"Keine Teilzeichenfolge\" zurück.\n    >>> CheckSubstring(\"hello\", \"world\")\n    \"No substring\"\n    >>> CheckSubstring(\"code\", \"decode\")\n    \"code is substring of decode\"\n    >>> CheckSubstring(\"book\", \"notebook\")\n    \"book is substring of notebook\"\n    */\n\n    static string CheckSubstring(string str1, string str2)",
      "ha": "using System;\nusing System.Collections.Generic;\nusing System.Diagnostics;\n\nclass Program\n{\n    /* Yana tantancewa wanne daga cikin igiyoyin guda biyu da aka bayar shine wani ɓangare na ɗayan. \n    Idan babu ɗaya daga cikin igiyoyin da yake wani ɓangare na ɗayan, zai dawo da \"Babu wani ɓangare\".\n    >>> CheckSubstring(\"hello\", \"world\")\n    \"Babu wani ɓangare\"\n    >>> CheckSubstring(\"code\", \"decode\")\n    \"code shine wani ɓangare na decode\"\n    >>> CheckSubstring(\"book\", \"notebook\")\n    \"book shine wani ɓangare na notebook\"\n    */\n\n    static string CheckSubstring(string str1, string str2)",
      "hi": "using System;\nusing System.Collections.Generic;\nusing System.Diagnostics;\n\nclass Program\n{\n    /* यह निर्धारित करता है कि दिए गए दो स्ट्रिंग्स में से कौन सा दूसरे का सबस्ट्रिंग है।\n    यदि कोई भी स्ट्रिंग दूसरे का सबस्ट्रिंग नहीं है, तो यह \"No substring\" लौटाता है।\n    >>> CheckSubstring(\"hello\", \"world\")\n    \"No substring\"\n    >>> CheckSubstring(\"code\", \"decode\")\n    \"code is substring of decode\"\n    >>> CheckSubstring(\"book\", \"notebook\")\n    \"book is substring of notebook\"\n    */\n\n    static string CheckSubstring(string str1, string str2)",
      "hu": "using System;\nusing System.Collections.Generic;\nusing System.Diagnostics;\n\nclass Program\n{\n    /* Meghatározza, hogy a két megadott sztring közül melyik a másik részsztringje.\n    Ha egyik sztring sem részsztringje a másiknak, akkor \"Nincs részsztring\" értéket ad vissza.\n    >>> CheckSubstring(\"hello\", \"world\")\n    \"Nincs részsztring\"\n    >>> CheckSubstring(\"code\", \"decode\")\n    \"code is substring of decode\"\n    >>> CheckSubstring(\"book\", \"notebook\")\n    \"book is substring of notebook\"\n    */\n\n    static string CheckSubstring(string str1, string str2)"
    },
    "prompt_bertscore": {
      "sq": "0.9934102384787865",
      "hy": "0.987907183772215",
      "bn": "0.9960111046880574",
      "bg": "0.9968084070375314",
      "zh": "0.9891158496408122",
      "fr": "0.999999801369619",
      "de": "0.999999801369619",
      "ha": "0.9425890664479621",
      "hi": "0.9960111046880574",
      "hu": "0.9965420436965636"
    },
    "canonical_solution": "    {\n        if (str1.Contains(str2))\n        {\n            return $\"\\\"{str2}\\\" is substring of \\\"{str1}\\\"\";\n        }\n        else if (str2.Contains(str1))\n        {\n            return $\"\\\"{str1}\\\" is substring of \\\"{str2}\\\"\";\n        }\n        else\n        {\n            return \"No substring\";\n        }\n    }",
    "instruction": {
      "en": "Write a C# function `static string CheckSubstring(string str1, string str2)` to solve the following problem:\nDetermines which of the two provided strings is a substring of the other. \n    If neither string is a substring of the other, it returns \"No substring\".\n    >>> CheckSubstring(\"hello\", \"world\")\n    \"No substring\"\n    >>> CheckSubstring(\"code\", \"decode\")\n    \"code is substring of decode\"\n    >>> CheckSubstring(\"book\", \"notebook\")\n    \"book is substring of notebook\"",
      "sq": "Shkruani një funksion C# `static string CheckSubstring(string str1, string str2)` për të zgjidhur problemin e mëposhtëm:\nPërcakton se cila nga dy vargjet e dhëna është një nënvarg i tjetrit. \n    Nëse asnjëri varg nuk është nënvarg i tjetrit, kthen \"No substring\".\n    >>> CheckSubstring(\"hello\", \"world\")\n    \"No substring\"\n    >>> CheckSubstring(\"code\", \"decode\")\n    \"code is substring of decode\"\n    >>> CheckSubstring(\"book\", \"notebook\")\n    \"book is substring of notebook\"",
      "hy": "Գրեք C# ֆունկցիա `static string CheckSubstring(string str1, string str2)` հետևյալ խնդիրը լուծելու համար:\nՈրոշում է, թե երկու տրված տողերից որը մյուսի ենթատողն է:\n    Եթե ոչ մի տող մյուսի ենթատողը չէ, վերադարձնում է \"No substring\":\n    >>> CheckSubstring(\"hello\", \"world\")\n    \"No substring\"\n    >>> CheckSubstring(\"code\", \"decode\")\n    \"code is substring of decode\"\n    >>> CheckSubstring(\"book\", \"notebook\")\n    \"book is substring of notebook\"",
      "bn": "C# ফাংশন `static string CheckSubstring(string str1, string str2)` লিখুন নিম্নলিখিত সমস্যার সমাধানের জন্য:\nদুটি প্রদত্ত স্ট্রিংয়ের মধ্যে কোনটি অন্যটির সাবস্ট্রিং তা নির্ধারণ করে। \n    যদি কোন স্ট্রিংই অন্যটির সাবস্ট্রিং না হয়, তাহলে এটি \"No substring\" রিটার্ন করে।\n    >>> CheckSubstring(\"hello\", \"world\")\n    \"No substring\"\n    >>> CheckSubstring(\"code\", \"decode\")\n    \"code is substring of decode\"\n    >>> CheckSubstring(\"book\", \"notebook\")\n    \"book is substring of notebook\"",
      "bg": "Напишете C# функция `static string CheckSubstring(string str1, string str2)` за решаване на следния проблем:\nОпределя коя от двете предоставени низове е подниз на другата. \n    Ако нито един от низовете не е подниз на другия, връща \"No substring\".\n    >>> CheckSubstring(\"hello\", \"world\")\n    \"No substring\"\n    >>> CheckSubstring(\"code\", \"decode\")\n    \"code is substring of decode\"\n    >>> CheckSubstring(\"book\", \"notebook\")\n    \"book is substring of notebook\"",
      "zh": "编写一个 C# 函数 `static string CheckSubstring(string str1, string str2)` 来解决以下问题：\n确定提供的两个字符串中哪个是另一个的子字符串。\n    如果两个字符串都不是另一个的子字符串，则返回 \"No substring\"。\n    >>> CheckSubstring(\"hello\", \"world\")\n    \"No substring\"\n    >>> CheckSubstring(\"code\", \"decode\")\n    \"code is substring of decode\"\n    >>> CheckSubstring(\"book\", \"notebook\")\n    \"book is substring of notebook\"",
      "fr": "Écrire une fonction C# `static string CheckSubstring(string str1, string str2)` pour résoudre le problème suivant :\nDétermine laquelle des deux chaînes fournies est une sous-chaîne de l'autre. \n    Si aucune des chaînes n'est une sous-chaîne de l'autre, elle renvoie \"No substring\".\n    >>> CheckSubstring(\"hello\", \"world\")\n    \"No substring\"\n    >>> CheckSubstring(\"code\", \"decode\")\n    \"code is substring of decode\"\n    >>> CheckSubstring(\"book\", \"notebook\")\n    \"book is substring of notebook\"",
      "de": "Schreiben Sie eine C#-Funktion `static string CheckSubstring(string str1, string str2)`, um das folgende Problem zu lösen:\nBestimmt, welche der beiden bereitgestellten Zeichenfolgen eine Teilzeichenfolge der anderen ist.\n    Wenn keine der beiden Zeichenfolgen eine Teilzeichenfolge der anderen ist, gibt sie \"No substring\" zurück.\n    >>> CheckSubstring(\"hello\", \"world\")\n    \"No substring\"\n    >>> CheckSubstring(\"code\", \"decode\")\n    \"code is substring of decode\"\n    >>> CheckSubstring(\"book\", \"notebook\")\n    \"book is substring of notebook\"",
      "ha": "Rubuta aikin C# `static string CheckSubstring(string str1, string str2)` don warware matsalar mai zuwa:\nTantance wanne daga cikin igiyoyin guda biyu da aka bayar yana cikin ɗayan. \n    Idan babu ɗayan igiyar da ke cikin ɗayan, yana dawo da \"No substring\".\n    >>> CheckSubstring(\"hello\", \"world\")\n    \"No substring\"\n    >>> CheckSubstring(\"code\", \"decode\")\n    \"code is substring of decode\"\n    >>> CheckSubstring(\"book\", \"notebook\")\n    \"book is substring of notebook\"",
      "hi": "C# फ़ंक्शन `static string CheckSubstring(string str1, string str2)` लिखें ताकि निम्नलिखित समस्या का समाधान किया जा सके:\nनिर्धारित करता है कि दिए गए दो स्ट्रिंग्स में से कौन सा दूसरे का सबस्ट्रिंग है।\n    यदि कोई स्ट्रिंग दूसरे का सबस्ट्रिंग नहीं है, तो यह \"No substring\" लौटाता है।\n    >>> CheckSubstring(\"hello\", \"world\")\n    \"No substring\"\n    >>> CheckSubstring(\"code\", \"decode\")\n    \"code is substring of decode\"\n    >>> CheckSubstring(\"book\", \"notebook\")\n    \"book is substring of notebook\"",
      "hu": "Írj egy C# függvényt `static string CheckSubstring(string str1, string str2)` a következő probléma megoldására:\nMeghatározza, hogy a két megadott string közül melyik a másik részstringje. \n    Ha egyik string sem részstringje a másiknak, akkor \"No substring\" értéket ad vissza.\n    >>> CheckSubstring(\"hello\", \"world\")\n    \"No substring\"\n    >>> CheckSubstring(\"code\", \"decode\")\n    \"code is substring of decode\"\n    >>> CheckSubstring(\"book\", \"notebook\")\n    \"book is substring of notebook\""
    },
    "instruction_bertscore": {
      "sq": "0.9926041963925469",
      "hy": "0.979845769757914",
      "bn": "0.9853249888187614",
      "bg": "0.9867549289318316",
      "zh": "0.9874551010249796",
      "fr": "0.992661004681523",
      "de": "0.8598930812813261",
      "ha": "0.9452542889006883",
      "hi": "0.9847859059646328",
      "hu": "0.9968950098836626"
    },
    "level": "easy",
    "test": "    static void Main()\n    {\n        Debug.Assert(CheckSubstring(\"apple\", \"pineapple\") == \"\\\"apple\\\" is substring of \\\"pineapple\\\"\");\n        Debug.Assert(CheckSubstring(\"star\", \"astrophysics\") == \"No substring\");\n        Debug.Assert(CheckSubstring(\"sun\", \"sunset\") == \"\\\"sun\\\" is substring of \\\"sunset\\\"\");\n        Debug.Assert(CheckSubstring(\"moon\", \"moonlight\") == \"\\\"moon\\\" is substring of \\\"moonlight\\\"\");\n\n\n    }\n}",
    "entry_point": "CheckSubstring",
    "signature": "static string CheckSubstring(string str1, string str2)",
    "docstring": {
      "en": "Determines which of the two provided strings is a substring of the other. \n    If neither string is a substring of the other, it returns \"No substring\".\n    >>> CheckSubstring(\"hello\", \"world\")\n    \"No substring\"\n    >>> CheckSubstring(\"code\", \"decode\")\n    \"code is substring of decode\"\n    >>> CheckSubstring(\"book\", \"notebook\")\n    \"book is substring of notebook\"",
      "sq": "Përcakton se cila nga dy vargjet e dhëna është një nënvarg i tjetrit. \n    Nëse asnjë varg nuk është një nënvarg i tjetrit, kthen \"No substring\".\n    >>> CheckSubstring(\"hello\", \"world\")\n    \"No substring\"\n    >>> CheckSubstring(\"code\", \"decode\")\n    \"code is substring of decode\"\n    >>> CheckSubstring(\"book\", \"notebook\")\n    \"book is substring of notebook\"",
      "hy": "Որոշում է, թե որ երկու տրված տողերից է ենթատող մյուսի համար։ \n    Եթե ոչ մի տող ենթատող չէ մյուսի համար, վերադարձնում է \"No substring\"։\n    >>> CheckSubstring(\"hello\", \"world\")\n    \"No substring\"\n    >>> CheckSubstring(\"code\", \"decode\")\n    \"code is substring of decode\"\n    >>> CheckSubstring(\"book\", \"notebook\")\n    \"book is substring of notebook\"",
      "bn": "নির্ধারণ করে যে প্রদত্ত দুটি স্ট্রিংয়ের মধ্যে কোনটি অন্যটির সাবস্ট্রিং। \n    যদি কোন স্ট্রিংই অন্যটির সাবস্ট্রিং না হয়, তাহলে এটি \"No substring\" রিটার্ন করে।\n    >>> CheckSubstring(\"hello\", \"world\")\n    \"No substring\"\n    >>> CheckSubstring(\"code\", \"decode\")\n    \"code is substring of decode\"\n    >>> CheckSubstring(\"book\", \"notebook\")\n    \"book is substring of notebook\"",
      "bg": "Определя коя от двете предоставени низове е подниз на другата. \nАко нито един от низовете не е подниз на другия, връща \"No substring\".\n>>> CheckSubstring(\"hello\", \"world\")\n\"No substring\"\n>>> CheckSubstring(\"code\", \"decode\")\n\"code is substring of decode\"\n>>> CheckSubstring(\"book\", \"notebook\")\n\"book is substring of notebook\"",
      "zh": "确定提供的两个字符串中哪个是另一个的子字符串。\n    如果两个字符串都不是彼此的子字符串，则返回 \"No substring\"。\n    >>> CheckSubstring(\"hello\", \"world\")\n    \"No substring\"\n    >>> CheckSubstring(\"code\", \"decode\")\n    \"code is substring of decode\"\n    >>> CheckSubstring(\"book\", \"notebook\")\n    \"book is substring of notebook\"",
      "fr": "Détermine laquelle des deux chaînes fournies est une sous-chaîne de l'autre. \n    Si aucune des chaînes n'est une sous-chaîne de l'autre, elle renvoie \"No substring\".\n    >>> CheckSubstring(\"hello\", \"world\")\n    \"No substring\"\n    >>> CheckSubstring(\"code\", \"decode\")\n    \"code is substring of decode\"\n    >>> CheckSubstring(\"book\", \"notebook\")\n    \"book is substring of notebook\"",
      "de": "Bestimmt, welcher der beiden bereitgestellten Strings ein Substring des anderen ist. \n    Wenn keiner der Strings ein Substring des anderen ist, gibt es \"Kein Substring\" zurück.\n    >>> CheckSubstring(\"hello\", \"world\")\n    \"No substring\"\n    >>> CheckSubstring(\"code\", \"decode\")\n    \"code is substring of decode\"\n    >>> CheckSubstring(\"book\", \"notebook\")\n    \"book is substring of notebook\"",
      "ha": "Yana tantance wanne daga cikin kirtani biyu da aka bayar yake cikin wani. \n    Idan babu kirtani da yake cikin wani, zai dawo da \"Babu kirtani\".\n    >>> CheckSubstring(\"hello\", \"world\")\n    \"Babu kirtani\"\n    >>> CheckSubstring(\"code\", \"decode\")\n    \"code yana cikin decode\"\n    >>> CheckSubstring(\"book\", \"notebook\")\n    \"book yana cikin notebook\"",
      "hi": "निर्धारित करता है कि दिए गए दो स्ट्रिंग्स में से कौन सा दूसरे का सबस्ट्रिंग है। \n    यदि कोई भी स्ट्रिंग दूसरे का सबस्ट्रिंग नहीं है, तो यह \"No substring\" लौटाता है।\n    >>> CheckSubstring(\"hello\", \"world\")\n    \"No substring\"\n    >>> CheckSubstring(\"code\", \"decode\")\n    \"code is substring of decode\"\n    >>> CheckSubstring(\"book\", \"notebook\")\n    \"book is substring of notebook\"",
      "hu": "Meghatározza, hogy a két megadott string közül melyik a másik részstringje. \n    Ha egyik string sem részstringje a másiknak, akkor \"Nincs részstring\" értéket ad vissza.\n    >>> CheckSubstring(\"hello\", \"world\")\n    \"Nincs részstring\"\n    >>> CheckSubstring(\"code\", \"decode\")\n    \"code is substring of decode\"\n    >>> CheckSubstring(\"book\", \"notebook\")\n    \"book is substring of notebook\""
    },
    "docstring_bertscore": {
      "sq": "0.9909722491819644",
      "hy": "0.9960647348909368",
      "bn": "0.994591691985182",
      "bg": "0.990298693559875",
      "zh": "0.9831027121157431",
      "fr": "0.9895057610787837",
      "de": "1",
      "ha": "0.8941611918782271",
      "hi": "0.994591691985182",
      "hu": "0.9960647348909368"
    }
  },
  {
    "task_id": "C#/30",
    "prompt": {
      "en": "using System;\nusing System.Collections.Generic;\nusing System.Diagnostics;\n\nclass Program\n{\n\n/* Removes a specific suffix ('er', 'ly', or 'ing') from the given word if it ends with one of these suffixes. \n    The function ensures the remaining word is not empty.\n    Examples:\n        >>> RemoveSuffix(\"happily\")\n        \"happi\"\n        >>> RemoveSuffix(\"dancing\")\n        \"danc\"\n        >>> RemoveSuffix(\"flower\")\n        \"flow\"\n*/\nstatic string RemoveSuffix(string word)",
      "sq": "using System;\nusing System.Collections.Generic;\nusing System.Diagnostics;\n\nclass Program\n{\n\n/* Heq një prapashtesë specifike ('er', 'ly', ose 'ing') nga fjala e dhënë nëse ajo përfundon me njërën nga këto prapashtesa.\n    Funksioni siguron që fjala e mbetur të mos jetë bosh.\n    Shembuj:\n        >>> RemoveSuffix(\"happily\")\n        \"happi\"\n        >>> RemoveSuffix(\"dancing\")\n        \"danc\"\n        >>> RemoveSuffix(\"flower\")\n        \"flow\"\n*/\nstatic string RemoveSuffix(string word)",
      "hy": "using System;\nusing System.Collections.Generic;\nusing System.Diagnostics;\n\nclass Program\n{\n\n/* Հեռացնում է հատուկ վերջածանց ('er', 'ly' կամ 'ing') տրված բառից, եթե այն ավարտվում է այդ վերջածանցներից մեկով։ \n    Ֆունկցիան ապահովում է, որ մնացած բառը դատարկ չլինի։\n    Օրինակներ:\n        >>> RemoveSuffix(\"happily\")\n        \"happi\"\n        >>> RemoveSuffix(\"dancing\")\n        \"danc\"\n        >>> RemoveSuffix(\"flower\")\n        \"flow\"\n*/\nstatic string RemoveSuffix(string word)",
      "bn": "using System;\nusing System.Collections.Generic;\nusing System.Diagnostics;\n\nclass Program\n{\n\n/* প্রদত্ত শব্দ থেকে একটি নির্দিষ্ট প্রত্যয় ('er', 'ly', বা 'ing') সরিয়ে দেয় যদি এটি এই প্রত্যয়গুলির মধ্যে একটি দিয়ে শেষ হয়।\n    ফাংশনটি নিশ্চিত করে যে অবশিষ্ট শব্দটি খালি নয়।\n    উদাহরণ:\n        >>> RemoveSuffix(\"happily\")\n        \"happi\"\n        >>> RemoveSuffix(\"dancing\")\n        \"danc\"\n        >>> RemoveSuffix(\"flower\")\n        \"flow\"\n*/\nstatic string RemoveSuffix(string word)",
      "bg": "using System;\nusing System.Collections.Generic;\nusing System.Diagnostics;\n\nclass Program\n{\n\n/* Премахва конкретно окончание ('er', 'ly' или 'ing') от дадената дума, ако тя завършва с някое от тези окончания.\n    Функцията гарантира, че останалата част от думата не е празна.\n    Примери:\n        >>> RemoveSuffix(\"happily\")\n        \"happi\"\n        >>> RemoveSuffix(\"dancing\")\n        \"danc\"\n        >>> RemoveSuffix(\"flower\")\n        \"flow\"\n*/\nstatic string RemoveSuffix(string word)",
      "zh": "using System;\nusing System.Collections.Generic;\nusing System.Diagnostics;\n\nclass Program\n{\n\n/* 从给定的单词中移除特定的后缀（'er'，'ly' 或 'ing'），如果它以这些后缀之一结尾。\n    该函数确保剩余的单词不为空。\n    示例：\n        >>> RemoveSuffix(\"happily\")\n        \"happi\"\n        >>> RemoveSuffix(\"dancing\")\n        \"danc\"\n        >>> RemoveSuffix(\"flower\")\n        \"flow\"\n*/\nstatic string RemoveSuffix(string word)",
      "fr": "using System;\nusing System.Collections.Generic;\nusing System.Diagnostics;\n\nclass Program\n{\n\n/* Supprime un suffixe spécifique ('er', 'ly', ou 'ing') du mot donné s'il se termine par l'un de ces suffixes. \n    La fonction s'assure que le mot restant n'est pas vide.\n    Exemples :\n        >>> RemoveSuffix(\"happily\")\n        \"happi\"\n        >>> RemoveSuffix(\"dancing\")\n        \"danc\"\n        >>> RemoveSuffix(\"flower\")\n        \"flow\"\n*/\nstatic string RemoveSuffix(string word)",
      "de": "using System;\nusing System.Collections.Generic;\nusing System.Diagnostics;\n\nclass Program\n{\n\n/* Entfernt ein bestimmtes Suffix ('er', 'ly' oder 'ing') von dem gegebenen Wort, wenn es mit einem dieser Suffixe endet.\n    Die Funktion stellt sicher, dass das verbleibende Wort nicht leer ist.\n    Beispiele:\n        >>> RemoveSuffix(\"happily\")\n        \"happi\"\n        >>> RemoveSuffix(\"dancing\")\n        \"danc\"\n        >>> RemoveSuffix(\"flower\")\n        \"flow\"\n*/\nstatic string RemoveSuffix(string word)",
      "ha": "using System;\nusing System.Collections.Generic;\nusing System.Diagnostics;\n\nclass Program\n{\n\n/* Yana cire wata takamaiman ƙari ('er', 'ly', ko 'ing') daga kalmar da aka bayar idan ta ƙare da ɗaya daga cikin waɗannan ƙarin. \n    Aikin yana tabbatar da cewa kalmar da ta rage ba ta zama babu komai ba.\n    Misalai:\n        >>> RemoveSuffix(\"happily\")\n        \"happi\"\n        >>> RemoveSuffix(\"dancing\")\n        \"danc\"\n        >>> RemoveSuffix(\"flower\")\n        \"flow\"\n*/\nstatic string RemoveSuffix(string word)",
      "hi": "using System;\nusing System.Collections.Generic;\nusing System.Diagnostics;\n\nclass Program\n{\n\n/* दिए गए शब्द से एक विशिष्ट प्रत्यय ('er', 'ly', या 'ing') हटाता है यदि यह इन प्रत्ययों में से एक के साथ समाप्त होता है। \n    यह फ़ंक्शन सुनिश्चित करता है कि शेष शब्द खाली न हो।\n    उदाहरण:\n        >>> RemoveSuffix(\"happily\")\n        \"happi\"\n        >>> RemoveSuffix(\"dancing\")\n        \"danc\"\n        >>> RemoveSuffix(\"flower\")\n        \"flow\"\n*/\nstatic string RemoveSuffix(string word)",
      "hu": "using System;\nusing System.Collections.Generic;\nusing System.Diagnostics;\n\nclass Program\n{\n\n/* Eltávolít egy adott utótagot ('er', 'ly' vagy 'ing') a megadott szóból, ha az egyik ilyen utótaggal végződik. \n    A függvény biztosítja, hogy a megmaradt szó ne legyen üres.\n    Példák:\n        >>> RemoveSuffix(\"happily\")\n        \"happi\"\n        >>> RemoveSuffix(\"dancing\")\n        \"danc\"\n        >>> RemoveSuffix(\"flower\")\n        \"flow\"\n*/\nstatic string RemoveSuffix(string word)"
    },
    "prompt_bertscore": {
      "sq": "0.9973947639223464",
      "hy": "0.9920021477076302",
      "bn": "0.9965722355144809",
      "bg": "0.9833742398466178",
      "zh": "0.9888971575912928",
      "fr": "0.9973947639223464",
      "de": "0.9973947639223464",
      "ha": "0.9883382116990607",
      "hi": "0.9945191918961044",
      "hu": "0.990111186480178"
    },
    "canonical_solution": "{\n    if (word.EndsWith(\"er\") && word.Length > 2)\n    {\n        return word.Substring(0, word.Length - 2);\n    }\n    else if (word.EndsWith(\"ly\") && word.Length > 2)\n    {\n        return word.Substring(0, word.Length - 2);\n    }\n    else if (word.EndsWith(\"ing\") && word.Length > 3)\n    {\n        return word.Substring(0, word.Length - 3);\n    }\n    return word;\n}",
    "instruction": {
      "en": "Write a C# function `static string RemoveSuffix(string word)` to solve the following problem:\nRemoves a specific suffix ('er', 'ly', or 'ing') from the given word if it ends with one of these suffixes. \n    The function ensures the remaining word is not empty.\n    Examples:\n        >>> RemoveSuffix(\"happily\")\n        \"happi\"\n        >>> RemoveSuffix(\"dancing\")\n        \"danc\"\n        >>> RemoveSuffix(\"flower\")\n        \"flow\"",
      "sq": "Shkruani një funksion C# `static string RemoveSuffix(string word)` për të zgjidhur problemin e mëposhtëm:\nHeq një prapashtesë specifike ('er', 'ly', ose 'ing') nga fjala e dhënë nëse përfundon me njërën nga këto prapashtesa.\n    Funksioni siguron që fjala e mbetur të mos jetë bosh.\n    Shembuj:\n        >>> RemoveSuffix(\"happily\")\n        \"happi\"\n        >>> RemoveSuffix(\"dancing\")\n        \"danc\"\n        >>> RemoveSuffix(\"flower\")\n        \"flow\"",
      "hy": "Գրեք C# ֆունկցիա `static string RemoveSuffix(string word)` հետևյալ խնդիրը լուծելու համար:\nՀեռացնում է տրված բառի վերջից հատուկ վերջածանց ('er', 'ly' կամ 'ing'), եթե այն ավարտվում է այդ վերջածանցներից մեկով։ \n    Ֆունկցիան ապահովում է, որ մնացած բառը դատարկ չլինի։\n    Օրինակներ:\n        >>> RemoveSuffix(\"happily\")\n        \"happi\"\n        >>> RemoveSuffix(\"dancing\")\n        \"danc\"\n        >>> RemoveSuffix(\"flower\")\n        \"flow\"",
      "bn": "C# ফাংশন `static string RemoveSuffix(string word)` লিখুন নিম্নলিখিত সমস্যার সমাধানের জন্য:\nনির্দিষ্ট একটি সাফিক্স ('er', 'ly', বা 'ing') প্রদত্ত শব্দ থেকে সরিয়ে দেয় যদি এটি এই সাফিক্সগুলির একটির সাথে শেষ হয়। \n    ফাংশনটি নিশ্চিত করে যে অবশিষ্ট শব্দটি খালি নয়।\n    উদাহরণসমূহ:\n        >>> RemoveSuffix(\"happily\")\n        \"happi\"\n        >>> RemoveSuffix(\"dancing\")\n        \"danc\"\n        >>> RemoveSuffix(\"flower\")\n        \"flow\"",
      "bg": "Напишете C# функция `static string RemoveSuffix(string word)`, за да решите следния проблем:  \nПремахва конкретно окончание ('er', 'ly' или 'ing') от дадената дума, ако тя завършва с едно от тези окончания.  \nФункцията гарантира, че останалата дума не е празна.  \nПримери:  \n    >>> RemoveSuffix(\"happily\")  \n    \"happi\"  \n    >>> RemoveSuffix(\"dancing\")  \n    \"danc\"  \n    >>> RemoveSuffix(\"flower\")  \n    \"flow\"",
      "zh": "编写一个 C# 函数 `static string RemoveSuffix(string word)` 来解决以下问题：\n从给定的单词中移除特定后缀（'er'、'ly' 或 'ing'），如果它以这些后缀之一结尾。\n函数确保剩余的单词不为空。\n示例：\n    >>> RemoveSuffix(\"happily\")\n    \"happi\"\n    >>> RemoveSuffix(\"dancing\")\n    \"danc\"\n    >>> RemoveSuffix(\"flower\")\n    \"flow\"",
      "fr": "Écrire une fonction C# `static string RemoveSuffix(string word)` pour résoudre le problème suivant :\nSupprime un suffixe spécifique ('er', 'ly', ou 'ing') du mot donné s'il se termine par l'un de ces suffixes. \n    La fonction s'assure que le mot restant n'est pas vide.\n    Exemples :\n        >>> RemoveSuffix(\"happily\")\n        \"happi\"\n        >>> RemoveSuffix(\"dancing\")\n        \"danc\"\n        >>> RemoveSuffix(\"flower\")\n        \"flow\"",
      "de": "Schreiben Sie eine C#-Funktion `static string RemoveSuffix(string word)`, um das folgende Problem zu lösen:\nEntfernt ein bestimmtes Suffix ('er', 'ly' oder 'ing') aus dem gegebenen Wort, wenn es mit einem dieser Suffixe endet. \n    Die Funktion stellt sicher, dass das verbleibende Wort nicht leer ist.\n    Beispiele:\n        >>> RemoveSuffix(\"happily\")\n        \"happi\"\n        >>> RemoveSuffix(\"dancing\")\n        \"danc\"\n        >>> RemoveSuffix(\"flower\")\n        \"flow\"",
      "ha": "Rubuta aikin C# `static string RemoveSuffix(string word)` don warware matsalar mai zuwa:\nCire wani takamaiman ƙarewa ('er', 'ly', ko 'ing') daga kalmar da aka bayar idan ta ƙare da ɗaya daga cikin waɗannan ƙarewa.\n    Aikin yana tabbatar da cewa kalmar da ta rage ba ta zama babu komai ba.\n    Misalai:\n        >>> RemoveSuffix(\"happily\")\n        \"happi\"\n        >>> RemoveSuffix(\"dancing\")\n        \"danc\"\n        >>> RemoveSuffix(\"flower\")\n        \"flow\"",
      "hi": "C# फ़ंक्शन `static string RemoveSuffix(string word)` लिखें ताकि निम्नलिखित समस्या का समाधान हो सके:\nदिए गए शब्द से एक विशेष प्रत्यय ('er', 'ly', या 'ing') को हटाता है यदि यह इन प्रत्ययों में से किसी एक के साथ समाप्त होता है। \n    फ़ंक्शन यह सुनिश्चित करता है कि शेष शब्द खाली न हो।\n    उदाहरण:\n        >>> RemoveSuffix(\"happily\")\n        \"happi\"\n        >>> RemoveSuffix(\"dancing\")\n        \"danc\"\n        >>> RemoveSuffix(\"flower\")\n        \"flow\"",
      "hu": "Írj egy C# függvényt `static string RemoveSuffix(string word)` a következő probléma megoldására:\nEltávolít egy adott utótagot ('er', 'ly', vagy 'ing') a megadott szóból, ha az egyik ilyen utótaggal végződik. \n    A függvény biztosítja, hogy a megmaradt szó ne legyen üres.\n    Példák:\n        >>> RemoveSuffix(\"happily\")\n        \"happi\"\n        >>> RemoveSuffix(\"dancing\")\n        \"danc\"\n        >>> RemoveSuffix(\"flower\")\n        \"flow\""
    },
    "instruction_bertscore": {
      "sq": "0.9948254799436601",
      "hy": "0.9834868632726645",
      "bn": "0.9916052842063225",
      "bg": "0.9929611351872667",
      "zh": "0.9901538920121006",
      "fr": "0.9948254799436601",
      "de": "0.9948254799436601",
      "ha": "0.9711634371724981",
      "hi": "0.9828955406283237",
      "hu": "0.986125270623951"
    },
    "level": "easy",
    "test": "    static void Main()\n    {\n        Debug.Assert(RemoveSuffix(\"happily\") == \"happi\");\n        Debug.Assert(RemoveSuffix(\"dancing\") == \"danc\");\n        Debug.Assert(RemoveSuffix(\"flower\") == \"flow\");\n        Debug.Assert(RemoveSuffix(\"computer\") == \"comput\");\n        Debug.Assert(RemoveSuffix(\"flying\") == \"fly\");\n        Debug.Assert(RemoveSuffix(\"ing\") == \"ing\");\n        Debug.Assert(RemoveSuffix(\"er\") == \"er\");\n    }\n}",
    "entry_point": "RemoveSuffix",
    "signature": "static string RemoveSuffix(string word)",
    "docstring": {
      "en": "Removes a specific suffix ('er', 'ly', or 'ing') from the given word if it ends with one of these suffixes. \n    The function ensures the remaining word is not empty.\n    Examples:\n        >>> RemoveSuffix(\"happily\")\n        \"happi\"\n        >>> RemoveSuffix(\"dancing\")\n        \"danc\"\n        >>> RemoveSuffix(\"flower\")\n        \"flow\"",
      "sq": "Heq një prapashtesë specifike ('er', 'ly', ose 'ing') nga fjala e dhënë nëse përfundon me njërën nga këto prapashtesa. \n    Funksioni siguron që fjala e mbetur të mos jetë bosh.\n    Shembuj:\n        >>> RemoveSuffix(\"happily\")\n        \"happi\"\n        >>> RemoveSuffix(\"dancing\")\n        \"danc\"\n        >>> RemoveSuffix(\"flower\")\n        \"flow\"",
      "hy": "Հեռացնում է տրված բառից որոշակի վերջածանցը ('er', 'ly' կամ 'ing'), եթե այն ավարտվում է այդ վերջածանցներից մեկով:\n    Ֆունկցիան ապահովում է, որ մնացած բառը դատարկ չլինի:\n    Օրինակներ:\n        >>> RemoveSuffix(\"happily\")\n        \"happi\"\n        >>> RemoveSuffix(\"dancing\")\n        \"danc\"\n        >>> RemoveSuffix(\"flower\")\n        \"flow\"",
      "bn": "একটি নির্দিষ্ট প্রত্যয় ('er', 'ly', বা 'ing') প্রদত্ত শব্দ থেকে সরিয়ে দেয় যদি এটি এই প্রত্যয়গুলির একটির সাথে শেষ হয়। \n    ফাংশনটি নিশ্চিত করে যে অবশিষ্ট শব্দটি খালি নয়।\n    উদাহরণ:\n        >>> RemoveSuffix(\"happily\")\n        \"happi\"\n        >>> RemoveSuffix(\"dancing\")\n        \"danc\"\n        >>> RemoveSuffix(\"flower\")\n        \"flow\"",
      "bg": "Премахва конкретно окончание ('er', 'ly' или 'ing') от дадената дума, ако тя завършва с едно от тези окончания. \n    Функцията гарантира, че останалата част от думата не е празна.\n    Примери:\n        >>> RemoveSuffix(\"happily\")\n        \"happi\"\n        >>> RemoveSuffix(\"dancing\")\n        \"danc\"\n        >>> RemoveSuffix(\"flower\")\n        \"flow\"",
      "zh": "移除给定单词中特定的后缀（'er'、'ly' 或 'ing'），如果单词以这些后缀之一结尾。\n    该函数确保剩余的单词不为空。\n    示例：\n        >>> RemoveSuffix(\"happily\")\n        \"happi\"\n        >>> RemoveSuffix(\"dancing\")\n        \"danc\"\n        >>> RemoveSuffix(\"flower\")\n        \"flow\"",
      "fr": "Supprime un suffixe spécifique ('er', 'ly' ou 'ing') du mot donné s'il se termine par l'un de ces suffixes. \n    La fonction s'assure que le mot restant n'est pas vide.\n    Exemples :\n        >>> RemoveSuffix(\"happily\")\n        \"happi\"\n        >>> RemoveSuffix(\"dancing\")\n        \"danc\"\n        >>> RemoveSuffix(\"flower\")\n        \"flow\"",
      "de": "Entfernt ein bestimmtes Suffix ('er', 'ly' oder 'ing') aus dem gegebenen Wort, wenn es mit einem dieser Suffixe endet. \n    Die Funktion stellt sicher, dass das verbleibende Wort nicht leer ist.\n    Beispiele:\n        >>> RemoveSuffix(\"happily\")\n        \"happi\"\n        >>> RemoveSuffix(\"dancing\")\n        \"danc\"\n        >>> RemoveSuffix(\"flower\")\n        \"flow\"",
      "ha": "Yana cire wani takamaiman ƙarewa ('er', 'ly', ko 'ing') daga kalmar da aka bayar idan ta ƙare da ɗaya daga cikin waɗannan ƙarewa. \n    Aikin yana tabbatar da cewa kalmar da ta rage ba ta zama babu komai ba.\n    Misalai:\n        >>> RemoveSuffix(\"happily\")\n        \"happi\"\n        >>> RemoveSuffix(\"dancing\")\n        \"danc\"\n        >>> RemoveSuffix(\"flower\")\n        \"flow\"",
      "hi": "एक विशिष्ट प्रत्यय ('er', 'ly', या 'ing') को दिए गए शब्द से हटाता है यदि यह इन प्रत्ययों में से किसी एक के साथ समाप्त होता है। \n    फ़ंक्शन यह सुनिश्चित करता है कि शेष शब्द खाली न हो।\n    उदाहरण:\n        >>> RemoveSuffix(\"happily\")\n        \"happi\"\n        >>> RemoveSuffix(\"dancing\")\n        \"danc\"\n        >>> RemoveSuffix(\"flower\")\n        \"flow\"",
      "hu": "Eltávolít egy adott utótagot ('er', 'ly' vagy 'ing') a megadott szóból, ha az egyik ilyen utótaggal végződik. \n    A függvény biztosítja, hogy a megmaradt szó ne legyen üres.\n    Példák:\n        >>> RemoveSuffix(\"happily\")\n        \"happi\"\n        >>> RemoveSuffix(\"dancing\")\n        \"danc\"\n        >>> RemoveSuffix(\"flower\")\n        \"flow\""
    },
    "docstring_bertscore": {
      "sq": "0.9905722075945601",
      "hy": "0.9973039898382134",
      "bn": "0.9827304787816837",
      "bg": "0.9847783580101535",
      "zh": "0.984929515730121",
      "fr": "0.9874016694524812",
      "de": "0.9973039898382134",
      "ha": "0.98952423370422",
      "hi": "0.9958974881101054",
      "hu": "0.9846764606246825"
    }
  },
  {
    "task_id": "C#/31",
    "prompt": {
      "en": "using System;\nusing System.Collections.Generic;\nusing System.Diagnostics;\n\nclass Program\n{\n\n/* \n    Finds the first longest and the first shortest word in a given sentence. \n    A word is defined as a continuous sequence of letters (A-Z, a-z), \n    and words are separated by spaces and commas. Quotation marks and other \n    punctuation are not part of the words.\n\n    Examples:\n    >>> FindLongestAndShortestWord(\"The quick, brown fox jumps over a lazy dog\")\n    (\"quick\", \"a\")\n\n    >>> FindLongestAndShortestWord(\"Hello world, this is an example sentence\")\n    (\"sentence\", \"is\")\n*/\n\n    static (string, string) FindLongestAndShortestWord(string sentence)",
      "sq": "using System;\nusing System.Collections.Generic;\nusing System.Diagnostics;\n\nclass Program\n{\n\n/* \n    Gjen fjalën e parë më të gjatë dhe fjalën e parë më të shkurtër në një fjali të dhënë. \n    Një fjalë përcaktohet si një sekuencë e vazhdueshme shkronjash (A-Z, a-z), \n    dhe fjalët ndahen nga hapësira dhe presje. Thonjëzat dhe shenjat e tjera \n    të pikësimit nuk janë pjesë e fjalëve.\n\n    Shembuj:\n    >>> FindLongestAndShortestWord(\"The quick, brown fox jumps over a lazy dog\")\n    (\"quick\", \"a\")\n\n    >>> FindLongestAndShortestWord(\"Hello world, this is an example sentence\")\n    (\"sentence\", \"is\")\n*/\n\n    static (string, string) FindLongestAndShortestWord(string sentence)",
      "hy": "using System;\nusing System.Collections.Generic;\nusing System.Diagnostics;\n\nclass Program\n{\n\n/* \n    Գտնում է առաջին ամենաերկար և առաջին ամենակարճ բառը տրված նախադասության մեջ։ \n    Բառը սահմանվում է որպես անընդհատ հաջորդող տառերի (A-Z, a-z) հաջորդականություն, \n    և բառերը բաժանվում են բացատներով և ստորակետերով։ Մեջբերումները և այլ \n    կետադրական նշանները բառերի մաս չեն կազմում։\n\n    Օրինակներ:\n    >>> FindLongestAndShortestWord(\"The quick, brown fox jumps over a lazy dog\")\n    (\"quick\", \"a\")\n\n    >>> FindLongestAndShortestWord(\"Hello world, this is an example sentence\")\n    (\"sentence\", \"is\")\n*/\n\n    static (string, string) FindLongestAndShortestWord(string sentence)",
      "bn": "using System;\nusing System.Collections.Generic;\nusing System.Diagnostics;\n\nclass Program\n{\n\n/* \n    প্রদত্ত বাক্যে প্রথম দীর্ঘতম এবং প্রথম ক্ষুদ্রতম শব্দ খুঁজে বের করে।\n    একটি শব্দকে একটি ধারাবাহিক অক্ষরের (A-Z, a-z) ক্রম হিসাবে সংজ্ঞায়িত করা হয়,\n    এবং শব্দগুলি স্পেস এবং কমা দ্বারা পৃথক করা হয়। উদ্ধৃতি চিহ্ন এবং অন্যান্য\n    বিরামচিহ্ন শব্দের অংশ নয়।\n\n    উদাহরণ:\n    >>> FindLongestAndShortestWord(\"The quick, brown fox jumps over a lazy dog\")\n    (\"quick\", \"a\")\n\n    >>> FindLongestAndShortestWord(\"Hello world, this is an example sentence\")\n    (\"sentence\", \"is\")\n*/\n\n    static (string, string) FindLongestAndShortestWord(string sentence)",
      "bg": "using System;\nusing System.Collections.Generic;\nusing System.Diagnostics;\n\nclass Program\n{\n\n/* \n    Намира първата най-дълга и първата най-къса дума в дадено изречение. \n    Думата се определя като непрекъсната последователност от букви (A-Z, a-z), \n    а думите са разделени с интервали и запетаи. Кавичките и другите \n    пунктуационни знаци не са част от думите.\n\n    Примери:\n    >>> FindLongestAndShortestWord(\"The quick, brown fox jumps over a lazy dog\")\n    (\"quick\", \"a\")\n\n    >>> FindLongestAndShortestWord(\"Hello world, this is an example sentence\")\n    (\"sentence\", \"is\")\n*/\n\n    static (string, string) FindLongestAndShortestWord(string sentence)",
      "zh": "using System;\nusing System.Collections.Generic;\nusing System.Diagnostics;\n\nclass Program\n{\n\n/* \n    找到给定句子中第一个最长和第一个最短的单词。\n    单词被定义为连续的字母序列（A-Z, a-z），\n    单词之间由空格和逗号分隔。引号和其他标点符号不属于单词的一部分。\n\n    例子：\n    >>> FindLongestAndShortestWord(\"The quick, brown fox jumps over a lazy dog\")\n    (\"quick\", \"a\")\n\n    >>> FindLongestAndShortestWord(\"Hello world, this is an example sentence\")\n    (\"sentence\", \"is\")\n*/\n\n    static (string, string) FindLongestAndShortestWord(string sentence)",
      "fr": "using System;\nusing System.Collections.Generic;\nusing System.Diagnostics;\n\nclass Program\n{\n\n/* \n    Trouve le premier mot le plus long et le premier mot le plus court dans une phrase donnée.\n    Un mot est défini comme une séquence continue de lettres (A-Z, a-z),\n    et les mots sont séparés par des espaces et des virgules. Les guillemets et autres\n    ponctuations ne font pas partie des mots.\n\n    Exemples :\n    >>> FindLongestAndShortestWord(\"The quick, brown fox jumps over a lazy dog\")\n    (\"quick\", \"a\")\n\n    >>> FindLongestAndShortestWord(\"Hello world, this is an example sentence\")\n    (\"sentence\", \"is\")\n*/\n\n    static (string, string) FindLongestAndShortestWord(string sentence)",
      "de": "using System;\nusing System.Collections.Generic;\nusing System.Diagnostics;\n\nclass Program\n{\n\n/* \n    Findet das erste längste und das erste kürzeste Wort in einem gegebenen Satz.\n    Ein Wort wird als eine kontinuierliche Folge von Buchstaben (A-Z, a-z) definiert,\n    und Wörter werden durch Leerzeichen und Kommas getrennt. Anführungszeichen und andere\n    Satzzeichen sind nicht Teil der Wörter.\n\n    Beispiele:\n    >>> FindLongestAndShortestWord(\"The quick, brown fox jumps over a lazy dog\")\n    (\"quick\", \"a\")\n\n    >>> FindLongestAndShortestWord(\"Hello world, this is an example sentence\")\n    (\"sentence\", \"is\")\n*/\n\n    static (string, string) FindLongestAndShortestWord(string sentence)",
      "ha": "using System;\nusing System.Collections.Generic;\nusing System.Diagnostics;\n\nclass Program\n{\n\n/* \n    Nemi kalmar da ta fi tsawo ta farko da kuma kalmar da ta fi guntu ta farko a cikin wata jimla da aka bayar. \n    Ana ayyana kalma a matsayin jerin haruffa masu ci gaba (A-Z, a-z), \n    kuma ana raba kalmomi ta wurin sarari da kuma alamar rubutu. Alamomin magana da sauran \n    alamomin rubutu ba su cikin kalmomi.\n\n    Misalai:\n    >>> FindLongestAndShortestWord(\"The quick, brown fox jumps over a lazy dog\")\n    (\"quick\", \"a\")\n\n    >>> FindLongestAndShortestWord(\"Hello world, this is an example sentence\")\n    (\"sentence\", \"is\")\n*/\n\n    static (string, string) FindLongestAndShortestWord(string sentence)",
      "hi": "using System;\nusing System.Collections.Generic;\nusing System.Diagnostics;\n\nclass Program\n{\n\n/* \n    दिए गए वाक्य में पहला सबसे लंबा और पहला सबसे छोटा शब्द खोजता है।\n    एक शब्द को अक्षरों (A-Z, a-z) के निरंतर अनुक्रम के रूप में परिभाषित किया गया है,\n    और शब्दों को स्पेस और कॉमाओं द्वारा अलग किया जाता है। उद्धरण चिह्न और अन्य \n    विराम चिह्न शब्दों का हिस्सा नहीं होते हैं।\n\n    उदाहरण:\n    >>> FindLongestAndShortestWord(\"The quick, brown fox jumps over a lazy dog\")\n    (\"quick\", \"a\")\n\n    >>> FindLongestAndShortestWord(\"Hello world, this is an example sentence\")\n    (\"sentence\", \"is\")\n*/\n\n    static (string, string) FindLongestAndShortestWord(string sentence)",
      "hu": "using System;\nusing System.Collections.Generic;\nusing System.Diagnostics;\n\nclass Program\n{\n\n/* \n    Megkeresi az első leghosszabb és az első legrövidebb szót egy adott mondatban.\n    Egy szó egy folyamatos betűsorozatként van definiálva (A-Z, a-z),\n    és a szavakat szóközök és vesszők választják el. Az idézőjelek és más\n    írásjelek nem részei a szavaknak.\n\n    Példák:\n    >>> FindLongestAndShortestWord(\"The quick, brown fox jumps over a lazy dog\")\n    (\"quick\", \"a\")\n\n    >>> FindLongestAndShortestWord(\"Hello world, this is an example sentence\")\n    (\"sentence\", \"is\")\n*/\n\n    static (string, string) FindLongestAndShortestWord(string sentence)"
    },
    "prompt_bertscore": {
      "sq": "0.991875620154911",
      "hy": "0.9889799864601844",
      "bn": "0.9849084609097313",
      "bg": "0.9974275379352172",
      "zh": "0.969921798660649",
      "fr": "0.9928800939918044",
      "de": "0.9974275379352172",
      "ha": "0.976851019503051",
      "hi": "0.9939099925174704",
      "hu": "0.9974275379352172"
    },
    "canonical_solution": "    {\n        // Remove punctuation and split the sentence into words\n        string[] words = sentence.Split(new char[] { ' ', ',', '.', '!', '?', ';', ':' }, StringSplitOptions.RemoveEmptyEntries);\n\n        // Initialize the longest and shortest words with the first word\n        string longestWord = words[0];\n        string shortestWord = words[0];\n\n        // Iterate over the words to find the longest and shortest\n        foreach (string word in words)\n        {\n            if (word.Length > longestWord.Length)\n            {\n                longestWord = word;\n            }\n            else if (word.Length < shortestWord.Length)\n            {\n                shortestWord = word;\n            }\n        }\n\n        // Return the longest and shortest words\n        return (longestWord, shortestWord);\n    }",
    "instruction": {
      "en": "Write a C# function `static (string, string) FindLongestAndShortestWord(string sentence)` to solve the following problem:\nFinds the first longest and the first shortest word in a given sentence. \n    A word is defined as a continuous sequence of letters (A-Z, a-z), \n    and words are separated by spaces and commas. Quotation marks and other \n    punctuation are not part of the words.\n\n    Examples:\n    >>> FindLongestAndShortestWord(\"The quick, brown fox jumps over a lazy dog\")\n    (\"quick\", \"a\")\n\n    >>> FindLongestAndShortestWord(\"Hello world, this is an example sentence\")\n    (\"sentence\", \"is\")",
      "sq": "Shkruani një funksion në C# `static (string, string) FindLongestAndShortestWord(string sentence)` për të zgjidhur problemin e mëposhtëm:\nGjen fjalën e parë më të gjatë dhe fjalën e parë më të shkurtër në një fjali të dhënë.\n    Një fjalë përcaktohet si një sekuencë e vazhdueshme shkronjash (A-Z, a-z),\n    dhe fjalët ndahen nga hapësirat dhe presjet. Thonjëzat dhe shenjat e tjera\n    të pikësimit nuk janë pjesë e fjalëve.\n\n    Shembuj:\n    >>> FindLongestAndShortestWord(\"The quick, brown fox jumps over a lazy dog\")\n    (\"quick\", \"a\")\n\n    >>> FindLongestAndShortestWord(\"Hello world, this is an example sentence\")\n    (\"sentence\", \"is\")",
      "hy": "Գրեք C# ֆունկցիա `static (string, string) FindLongestAndShortestWord(string sentence)` հետևյալ խնդիրը լուծելու համար:\nԳտնում է տրված նախադասության առաջին ամենաերկար և առաջին ամենակարճ բառերը։\n    Բառը սահմանվում է որպես տառերի (A-Z, a-z) շարունակական հաջորդականություն,\n    և բառերը բաժանվում են բացատներով և ստորակետերով։ Մեջբերումները և այլ\n    կետադրական նշանները բառերի մաս չեն կազմում։\n\n    Օրինակներ:\n    >>> FindLongestAndShortestWord(\"The quick, brown fox jumps over a lazy dog\")\n    (\"quick\", \"a\")\n\n    >>> FindLongestAndShortestWord(\"Hello world, this is an example sentence\")\n    (\"sentence\", \"is\")",
      "bn": "C# ফাংশন `static (string, string) FindLongestAndShortestWord(string sentence)` লিখুন নিম্নলিখিত সমস্যার সমাধানের জন্য:\nপ্রদত্ত বাক্যে প্রথম দীর্ঘতম এবং প্রথম সংক্ষিপ্ততম শব্দ খুঁজে বের করে। \n    একটি শব্দকে ধারাবাহিক অক্ষরের (A-Z, a-z) ক্রম হিসেবে সংজ্ঞায়িত করা হয়, \n    এবং শব্দগুলি স্পেস এবং কমা দ্বারা পৃথক করা হয়। উদ্ধৃতি চিহ্ন এবং অন্যান্য \n    বিরামচিহ্ন শব্দের অংশ নয়।\n\n    উদাহরণ:\n    >>> FindLongestAndShortestWord(\"The quick, brown fox jumps over a lazy dog\")\n    (\"quick\", \"a\")\n\n    >>> FindLongestAndShortestWord(\"Hello world, this is an example sentence\")\n    (\"sentence\", \"is\")",
      "bg": "Напишете C# функция `static (string, string) FindLongestAndShortestWord(string sentence)`, за да решите следния проблем:\nНамира първата най-дълга и първата най-къса дума в дадено изречение.\n    Думата се определя като непрекъсната последователност от букви (A-Z, a-z),\n    а думите се разделят с интервали и запетаи. Кавичките и другите\n    пунктуационни знаци не са част от думите.\n\n    Примери:\n    >>> FindLongestAndShortestWord(\"The quick, brown fox jumps over a lazy dog\")\n    (\"quick\", \"a\")\n\n    >>> FindLongestAndShortestWord(\"Hello world, this is an example sentence\")\n    (\"sentence\", \"is\")",
      "zh": "编写一个 C# 函数 `static (string, string) FindLongestAndShortestWord(string sentence)` 来解决以下问题：\n找到给定句子中第一个最长和第一个最短的单词。\n    单词被定义为连续的字母序列 (A-Z, a-z)，\n    单词之间由空格和逗号分隔。引号和其他标点符号不属于单词的一部分。\n\n    示例：\n    >>> FindLongestAndShortestWord(\"The quick, brown fox jumps over a lazy dog\")\n    (\"quick\", \"a\")\n\n    >>> FindLongestAndShortestWord(\"Hello world, this is an example sentence\")\n    (\"sentence\", \"is\")",
      "fr": "Écrire une fonction C# `static (string, string) FindLongestAndShortestWord(string sentence)` pour résoudre le problème suivant :\nTrouve le premier mot le plus long et le premier mot le plus court dans une phrase donnée. \n    Un mot est défini comme une séquence continue de lettres (A-Z, a-z), \n    et les mots sont séparés par des espaces et des virgules. Les guillemets et autres \n    signes de ponctuation ne font pas partie des mots.\n\n    Exemples :\n    >>> FindLongestAndShortestWord(\"The quick, brown fox jumps over a lazy dog\")\n    (\"quick\", \"a\")\n\n    >>> FindLongestAndShortestWord(\"Hello world, this is an example sentence\")\n    (\"sentence\", \"is\")",
      "de": "Schreiben Sie eine C#-Funktion `static (string, string) FindLongestAndShortestWord(string sentence)`, um das folgende Problem zu lösen:\nFindet das erste längste und das erste kürzeste Wort in einem gegebenen Satz.\n    Ein Wort ist definiert als eine kontinuierliche Sequenz von Buchstaben (A-Z, a-z),\n    und Wörter werden durch Leerzeichen und Kommas getrennt. Anführungszeichen und andere\n    Satzzeichen sind nicht Teil der Wörter.\n\n    Beispiele:\n    >>> FindLongestAndShortestWord(\"The quick, brown fox jumps over a lazy dog\")\n    (\"quick\", \"a\")\n\n    >>> FindLongestAndShortestWord(\"Hello world, this is an example sentence\")\n    (\"sentence\", \"is\")",
      "ha": "Rubuta aikin C# `static (string, string) FindLongestAndShortestWord(string sentence)` don warware matsalar mai zuwa:  \nNemo kalma mafi tsawo da kuma kalma mafi guntu a cikin jumla da aka bayar.  \n    Ana ayyana kalma a matsayin jerin haruffa masu ci gaba (A-Z, a-z),  \n    kuma kalmomi suna rabuwa da sarari da kuma wakafi. Alamomin magana da sauran  \n    alamomin rubutu ba su cikin kalmomi.\n\n    Misalai:\n    >>> FindLongestAndShortestWord(\"The quick, brown fox jumps over a lazy dog\")\n    (\"quick\", \"a\")\n\n    >>> FindLongestAndShortestWord(\"Hello world, this is an example sentence\")\n    (\"sentence\", \"is\")",
      "hi": "C# फ़ंक्शन `static (string, string) FindLongestAndShortestWord(string sentence)` लिखें ताकि निम्नलिखित समस्या का समाधान किया जा सके:\nदिए गए वाक्य में पहले सबसे लंबे और पहले सबसे छोटे शब्द को खोजें। \n    एक शब्द को अक्षरों (A-Z, a-z) के निरंतर अनुक्रम के रूप में परिभाषित किया गया है, \n    और शब्दों को स्पेस और कॉमा द्वारा अलग किया जाता है। उद्धरण चिह्न और अन्य \n    विराम चिह्न शब्दों का हिस्सा नहीं होते हैं।\n\n    उदाहरण:\n    >>> FindLongestAndShortestWord(\"The quick, brown fox jumps over a lazy dog\")\n    (\"quick\", \"a\")\n\n    >>> FindLongestAndShortestWord(\"Hello world, this is an example sentence\")\n    (\"sentence\", \"is\")",
      "hu": "Írj egy C# függvényt `static (string, string) FindLongestAndShortestWord(string sentence)` a következő probléma megoldására:\nMegtalálja az első leghosszabb és az első legrövidebb szót egy adott mondatban.\n    Egy szó folyamatos betűsorozatként van definiálva (A-Z, a-z),\n    és a szavakat szóközök és vesszők választják el. Az idézőjelek és más\n    írásjelek nem képezik a szavak részét.\n\n    Példák:\n    >>> FindLongestAndShortestWord(\"The quick, brown fox jumps over a lazy dog\")\n    (\"quick\", \"a\")\n\n    >>> FindLongestAndShortestWord(\"Hello world, this is an example sentence\")\n    (\"sentence\", \"is\")"
    },
    "instruction_bertscore": {
      "sq": "0.9886556230479544",
      "hy": "0.9914167839747204",
      "bn": "0.9713785538751588",
      "bg": "0.99662387941355",
      "zh": "0.9721246095863258",
      "fr": "0.9927277444895507",
      "de": "0.9979773468299218",
      "ha": "0.9680713580309279",
      "hi": "0.9801596057599492",
      "hu": "0.9979773468299218"
    },
    "level": "hard",
    "test": "    static void Main()\n    {\n        Debug.Assert(FindLongestAndShortestWord(\"Fast cars, smooth drives\") == (\"smooth\", \"Fast\"));\n        Debug.Assert(FindLongestAndShortestWord(\"Sunshine brings happiness\") == (\"happiness\", \"brings\"));\n        Debug.Assert(FindLongestAndShortestWord(\"A\") == (\"A\", \"A\")); // Edge case: Only one word\n        Debug.Assert(FindLongestAndShortestWord(\"Every cloud has a silver lining\") == (\"silver\", \"a\"));\n\n\n    }\n}",
    "entry_point": "FindLongestAndShortestWord",
    "signature": "static (string, string) FindLongestAndShortestWord(string sentence)",
    "docstring": {
      "en": "Finds the first longest and the first shortest word in a given sentence. \n    A word is defined as a continuous sequence of letters (A-Z, a-z), \n    and words are separated by spaces and commas. Quotation marks and other \n    punctuation are not part of the words.\n\n    Examples:\n    >>> FindLongestAndShortestWord(\"The quick, brown fox jumps over a lazy dog\")\n    (\"quick\", \"a\")\n\n    >>> FindLongestAndShortestWord(\"Hello world, this is an example sentence\")\n    (\"sentence\", \"is\")",
      "sq": "Gjen fjalën e parë më të gjatë dhe fjalën e parë më të shkurtër në një fjali të dhënë. \n    Një fjalë përcaktohet si një sekuencë e vazhdueshme shkronjash (A-Z, a-z), \n    dhe fjalët ndahen nga hapësirat dhe presjet. Thonjëzat dhe shenjat e tjera \n    të pikësimit nuk janë pjesë e fjalëve.\n\n    Shembuj:\n    >>> FindLongestAndShortestWord(\"The quick, brown fox jumps over a lazy dog\")\n    (\"quick\", \"a\")\n\n    >>> FindLongestAndShortestWord(\"Hello world, this is an example sentence\")\n    (\"sentence\", \"is\")",
      "hy": "Գտնում է առաջին ամենաերկար և առաջին ամենակարճ բառը տրված նախադասության մեջ։ \n    Բառը սահմանվում է որպես տառերի (A-Z, a-z) շարունակական հաջորդականություն, \n    և բառերը բաժանվում են բացատներով և ստորակետերով։ Մեջբերումները և այլ \n    կետադրական նշանները բառերի մաս չեն կազմում։\n\n    Օրինակներ:\n    >>> FindLongestAndShortestWord(\"The quick, brown fox jumps over a lazy dog\")\n    (\"quick\", \"a\")\n\n    >>> FindLongestAndShortestWord(\"Hello world, this is an example sentence\")\n    (\"sentence\", \"is\")",
      "bn": "প্রদত্ত বাক্যে প্রথম দীর্ঘতম এবং প্রথম সংক্ষিপ্ততম শব্দ খুঁজে বের করে। \n    একটি শব্দকে সংজ্ঞায়িত করা হয় ক্রমাগত অক্ষরের (A-Z, a-z) একটি ধারাবাহিকতা হিসাবে, \n    এবং শব্দগুলি স্পেস এবং কমা দ্বারা পৃথক করা হয়। উদ্ধৃতি চিহ্ন এবং অন্যান্য \n    বিরাম চিহ্ন শব্দের অংশ নয়।\n\n    উদাহরণ:\n    >>> FindLongestAndShortestWord(\"The quick, brown fox jumps over a lazy dog\")\n    (\"quick\", \"a\")\n\n    >>> FindLongestAndShortestWord(\"Hello world, this is an example sentence\")\n    (\"sentence\", \"is\")",
      "bg": "Намира първата най-дълга и първата най-къса дума в дадено изречение. \n    Думата се определя като непрекъсната последователност от букви (A-Z, a-z),\n    а думите са разделени с интервали и запетаи. Кавичките и другите \n    пунктуационни знаци не са част от думите.\n\n    Примери:\n    >>> FindLongestAndShortestWord(\"The quick, brown fox jumps over a lazy dog\")\n    (\"quick\", \"a\")\n\n    >>> FindLongestAndShortestWord(\"Hello world, this is an example sentence\")\n    (\"sentence\", \"is\")",
      "zh": "找到给定句子中第一个最长和第一个最短的单词。\n    单词被定义为连续的字母序列（A-Z, a-z），\n    单词之间由空格和逗号分隔。引号和其他标点符号不属于单词的一部分。\n\n    示例：\n    >>> FindLongestAndShortestWord(\"The quick, brown fox jumps over a lazy dog\")\n    (\"quick\", \"a\")\n\n    >>> FindLongestAndShortestWord(\"Hello world, this is an example sentence\")\n    (\"sentence\", \"is\")",
      "fr": "Trouve le premier mot le plus long et le premier mot le plus court dans une phrase donnée. \n    Un mot est défini comme une séquence continue de lettres (A-Z, a-z), \n    et les mots sont séparés par des espaces et des virgules. Les guillemets et autres \n    signes de ponctuation ne font pas partie des mots.\n\n    Exemples :\n    >>> FindLongestAndShortestWord(\"The quick, brown fox jumps over a lazy dog\")\n    (\"quick\", \"a\")\n\n    >>> FindLongestAndShortestWord(\"Hello world, this is an example sentence\")\n    (\"sentence\", \"is\")",
      "de": "Findet das erste längste und das erste kürzeste Wort in einem gegebenen Satz. \n    Ein Wort wird als eine kontinuierliche Folge von Buchstaben (A-Z, a-z) definiert, \n    und Wörter werden durch Leerzeichen und Kommas getrennt. Anführungszeichen und andere \n    Satzzeichen sind nicht Teil der Wörter.\n\n    Beispiele:\n    >>> FindLongestAndShortestWord(\"The quick, brown fox jumps over a lazy dog\")\n    (\"quick\", \"a\")\n\n    >>> FindLongestAndShortestWord(\"Hello world, this is an example sentence\")\n    (\"sentence\", \"is\")",
      "ha": "Yana nemo kalma mafi tsawo da kuma kalma mafi guntu a cikin jumla da aka bayar.\n    Ana ayyana kalma a matsayin jerin haruffa masu ci gaba (A-Z, a-z),\n    kuma ana raba kalmomi ta wurin sarari da kuma alamar rubutu. Alamomin magana da sauran\n    alamar rubutu ba su cikin kalmomi.\n\n    Misalai:\n    >>> FindLongestAndShortestWord(\"The quick, brown fox jumps over a lazy dog\")\n    (\"quick\", \"a\")\n\n    >>> FindLongestAndShortestWord(\"Hello world, this is an example sentence\")\n    (\"sentence\", \"is\")",
      "hi": "पहले सबसे लंबा और पहले सबसे छोटा शब्द एक दिए गए वाक्य में खोजता है। \n    एक शब्द को अक्षरों (A-Z, a-z) की एक निरंतर अनुक्रम के रूप में परिभाषित किया गया है, \n    और शब्दों को रिक्त स्थान और अल्पविराम द्वारा अलग किया जाता है। उद्धरण चिह्न और अन्य \n    विराम चिह्न शब्दों का हिस्सा नहीं होते हैं।\n\n    उदाहरण:\n    >>> FindLongestAndShortestWord(\"The quick, brown fox jumps over a lazy dog\")\n    (\"quick\", \"a\")\n\n    >>> FindLongestAndShortestWord(\"Hello world, this is an example sentence\")\n    (\"sentence\", \"is\")",
      "hu": "Megtalálja az első leghosszabb és az első legrövidebb szót egy adott mondatban. \n    Egy szó folyamatos betűsorozatként van definiálva (A-Z, a-z), \n    és a szavakat szóközök és vesszők választják el. Az idézőjelek és más \n    írásjelek nem részei a szavaknak.\n\n    Példák:\n    >>> FindLongestAndShortestWord(\"The quick, brown fox jumps over a lazy dog\")\n    (\"quick\", \"a\")\n\n    >>> FindLongestAndShortestWord(\"Hello world, this is an example sentence\")\n    (\"sentence\", \"is\")"
    },
    "docstring_bertscore": {
      "sq": "0.9904025772491563",
      "hy": "0.9899693643881192",
      "bn": "0.978928891919057",
      "bg": "0.9974793804646672",
      "zh": "0.9576764343002291",
      "fr": "0.9892880621811695",
      "de": "0.9974793804646672",
      "ha": "0.9499916234883703",
      "hi": "0.9817021692990661",
      "hu": "0.993304567116076"
    }
  },
  {
    "task_id": "C#/32",
    "prompt": {
      "en": "using System;\nusing System.Collections.Generic;\nusing System.Diagnostics;\n\nclass Program\n{\n\n\n/* Calculate the speed of a vehicle and the next palindromic number on the odometer.\n     Given the current palindromic odometer reading and the time elapsed in hours, \n     find the constant speed of the vehicle and the next palindromic odometer reading.\n     The speed is calculated per hour.\n     Example:\n     >>> CalculateSpeedAndNextPalindrome(12321, 2)\n     (50, 12421)\n     >>> CalculateSpeedAndNextPalindrome(23332, 4)\n     (25, 23432)\n*/\nstatic (int, int) CalculateSpeedAndNextPalindrome(int currentPalindrome, int elapsedHours)",
      "sq": "using System;\nusing System.Collections.Generic;\nusing System.Diagnostics;\n\nclass Program\n{\n\n\n/* Llogarit shpejtësinë e një automjeti dhe numrin e ardhshëm palindromik në odometër.\n     Duke pasur parasysh leximin aktual palindromik të odometrit dhe kohën e kaluar në orë,\n     gjeni shpejtësinë konstante të automjetit dhe leximin e ardhshëm palindromik të odometrit.\n     Shpejtësia llogaritet për orë.\n     Shembull:\n     >>> CalculateSpeedAndNextPalindrome(12321, 2)\n     (50, 12421)\n     >>> CalculateSpeedAndNextPalindrome(23332, 4)\n     (25, 23432)\n*/\nstatic (int, int) CalculateSpeedAndNextPalindrome(int currentPalindrome, int elapsedHours)",
      "hy": "using System;\nusing System.Collections.Generic;\nusing System.Diagnostics;\n\nclass Program\n{\n\n\n/* Հաշվարկել տրանսպորտային միջոցի արագությունը և հաջորդ պալինդրոմիկ թիվը օդոմետրին:\n     Տրված է ընթացիկ պալինդրոմիկ օդոմետրի ցուցումը և անցած ժամանակը ժամերով, \n     գտնել տրանսպորտային միջոցի հաստատուն արագությունը և հաջորդ պալինդրոմիկ օդոմետրի ցուցումը:\n     Արագությունը հաշվարկվում է ժամում:\n     Օրինակ:\n     >>> CalculateSpeedAndNextPalindrome(12321, 2)\n     (50, 12421)\n     >>> CalculateSpeedAndNextPalindrome(23332, 4)\n     (25, 23432)\n*/\nstatic (int, int) CalculateSpeedAndNextPalindrome(int currentPalindrome, int elapsedHours)",
      "bn": "using System;\nusing System.Collections.Generic;\nusing System.Diagnostics;\n\nclass Program\n{\n\n\n/* একটি যানবাহনের গতি এবং ওডোমিটারে পরবর্তী প্যালিনড্রোমিক সংখ্যা গণনা করুন।\n     বর্তমান প্যালিনড্রোমিক ওডোমিটার রিডিং এবং ঘন্টায় অতিক্রান্ত সময় দেওয়া আছে,\n     যানবাহনের ধ্রুবক গতি এবং পরবর্তী প্যালিনড্রোমিক ওডোমিটার রিডিং খুঁজে বের করুন।\n     গতি প্রতি ঘন্টায় গণনা করা হয়।\n     উদাহরণ:\n     >>> CalculateSpeedAndNextPalindrome(12321, 2)\n     (50, 12421)\n     >>> CalculateSpeedAndNextPalindrome(23332, 4)\n     (25, 23432)\n*/\nstatic (int, int) CalculateSpeedAndNextPalindrome(int currentPalindrome, int elapsedHours)",
      "bg": "using System;\nusing System.Collections.Generic;\nusing System.Diagnostics;\n\nclass Program\n{\n\n\n/* Изчислете скоростта на превозното средство и следващото палиндромно число на километража.\n     Като се даде текущото палиндромно показание на километража и изминалото време в часове,\n     намерете постоянната скорост на превозното средство и следващото палиндромно показание на километража.\n     Скоростта се изчислява на час.\n     Пример:\n     >>> CalculateSpeedAndNextPalindrome(12321, 2)\n     (50, 12421)\n     >>> CalculateSpeedAndNextPalindrome(23332, 4)\n     (25, 23432)\n*/\nstatic (int, int) CalculateSpeedAndNextPalindrome(int currentPalindrome, int elapsedHours)",
      "zh": "using System;\nusing System.Collections.Generic;\nusing System.Diagnostics;\n\nclass Program\n{\n\n\n/* 计算车辆的速度和里程表上的下一个回文数。\n     给定当前回文的里程表读数和经过的时间（小时），\n     找出车辆的恒定速度和下一个回文的里程表读数。\n     速度是按每小时计算的。\n     示例：\n     >>> CalculateSpeedAndNextPalindrome(12321, 2)\n     (50, 12421)\n     >>> CalculateSpeedAndNextPalindrome(23332, 4)\n     (25, 23432)\n*/\nstatic (int, int) CalculateSpeedAndNextPalindrome(int currentPalindrome, int elapsedHours)",
      "fr": "using System;\nusing System.Collections.Generic;\nusing System.Diagnostics;\n\nclass Program\n{\n\n\n/* Calculer la vitesse d'un véhicule et le prochain nombre palindromique sur l'odomètre.\n     Étant donné la lecture actuelle de l'odomètre palindromique et le temps écoulé en heures,\n     trouver la vitesse constante du véhicule et la prochaine lecture de l'odomètre palindromique.\n     La vitesse est calculée par heure.\n     Exemple :\n     >>> CalculateSpeedAndNextPalindrome(12321, 2)\n     (50, 12421)\n     >>> CalculateSpeedAndNextPalindrome(23332, 4)\n     (25, 23432)\n*/\nstatic (int, int) CalculateSpeedAndNextPalindrome(int currentPalindrome, int elapsedHours)",
      "de": "using System;\nusing System.Collections.Generic;\nusing System.Diagnostics;\n\nclass Program\n{\n\n\n/* Berechne die Geschwindigkeit eines Fahrzeugs und die nächste palindromische Zahl auf dem Kilometerzähler.\n     Gegeben ist der aktuelle palindromische Kilometerzählerstand und die verstrichene Zeit in Stunden,\n     finde die konstante Geschwindigkeit des Fahrzeugs und die nächste palindromische Kilometerzähleranzeige.\n     Die Geschwindigkeit wird pro Stunde berechnet.\n     Beispiel:\n     >>> CalculateSpeedAndNextPalindrome(12321, 2)\n     (50, 12421)\n     >>> CalculateSpeedAndNextPalindrome(23332, 4)\n     (25, 23432)\n*/\nstatic (int, int) CalculateSpeedAndNextPalindrome(int currentPalindrome, int elapsedHours)",
      "ha": "using System;\nusing System.Collections.Generic;\nusing System.Diagnostics;\n\nclass Program\n{\n\n\n/* Lissafi gudun abin hawa da kuma lambar palindrome ta gaba a kan odometer.\n     An ba da karatun odometer palindrome na yanzu da kuma lokacin da ya shude a cikin awanni,\n     nemo gudun dindindin na abin hawa da kuma karatun odometer palindrome na gaba.\n     Ana lissafin gudun a kowane awa.\n     Misali:\n     >>> CalculateSpeedAndNextPalindrome(12321, 2)\n     (50, 12421)\n     >>> CalculateSpeedAndNextPalindrome(23332, 4)\n     (25, 23432)\n*/\nstatic (int, int) CalculateSpeedAndNextPalindrome(int currentPalindrome, int elapsedHours)",
      "hi": "using System;\nusing System.Collections.Generic;\nusing System.Diagnostics;\n\nclass Program\n{\n\n\n/* एक वाहन की गति और ओडोमीटर पर अगली पालिंड्रोमिक संख्या की गणना करें।\n     वर्तमान पालिंड्रोमिक ओडोमीटर रीडिंग और घंटे में बीता समय दिया गया है,\n     वाहन की स्थिर गति और अगली पालिंड्रोमिक ओडोमीटर रीडिंग खोजें।\n     गति प्रति घंटे की गणना की जाती है।\n     उदाहरण:\n     >>> CalculateSpeedAndNextPalindrome(12321, 2)\n     (50, 12421)\n     >>> CalculateSpeedAndNextPalindrome(23332, 4)\n     (25, 23432)\n*/\nstatic (int, int) CalculateSpeedAndNextPalindrome(int currentPalindrome, int elapsedHours)",
      "hu": "using System;\nusing System.Collections.Generic;\nusing System.Diagnostics;\n\nclass Program\n{\n\n\n/* Számítsa ki egy jármű sebességét és a következő palindromikus számot a kilométerórán.\n     Adott a jelenlegi palindromikus kilométeróra állás és az eltelt idő órákban, \n     határozza meg a jármű állandó sebességét és a következő palindromikus kilométeróra állást.\n     A sebességet óránként számítjuk ki.\n     Példa:\n     >>> CalculateSpeedAndNextPalindrome(12321, 2)\n     (50, 12421)\n     >>> CalculateSpeedAndNextPalindrome(23332, 4)\n     (25, 23432)\n*/\nstatic (int, int) CalculateSpeedAndNextPalindrome(int currentPalindrome, int elapsedHours)"
    },
    "prompt_bertscore": {
      "sq": "0.9813875387755069",
      "hy": "0.990167796138773",
      "bn": "0.9955407479457667",
      "bg": "0.98023846202122",
      "zh": "0.9699345110050351",
      "fr": "0.9985372858740591",
      "de": "0.9985372858740591",
      "ha": "0.9790168851778555",
      "hi": "0.9955407479457667",
      "hu": "0.9919036270386369"
    },
    "canonical_solution": "{\n    int nextPalindrome = currentPalindrome;\n    do\n    {\n        nextPalindrome++;\n    } while (!IsPalindrome(nextPalindrome));\n\n    int speed = (nextPalindrome - currentPalindrome) / elapsedHours;\n    return (speed, nextPalindrome);\n}\n\nstatic bool IsPalindrome(int number)\n{\n    string numStr = number.ToString();\n    for (int i = 0; i < numStr.Length / 2; i++)\n    {\n        if (numStr[i] != numStr[numStr.Length - 1 - i])\n        {\n            return false;\n        }\n    }\n    return true;\n}",
    "instruction": {
      "en": "Write a C# function `static (int, int) CalculateSpeedAndNextPalindrome(int currentPalindrome, int elapsedHours)` to solve the following problem:\nCalculate the speed of a vehicle and the next palindromic number on the odometer.\n     Given the current palindromic odometer reading and the time elapsed in hours, \n     find the constant speed of the vehicle and the next palindromic odometer reading.\n     The speed is calculated per hour.\n     Example:\n     >>> CalculateSpeedAndNextPalindrome(12321, 2)\n     (50, 12421)\n     >>> CalculateSpeedAndNextPalindrome(23332, 4)\n     (25, 23432)",
      "sq": "Shkruani një funksion në C# `static (int, int) CalculateSpeedAndNextPalindrome(int currentPalindrome, int elapsedHours)` për të zgjidhur problemin në vijim:\nLlogaritni shpejtësinë e një automjeti dhe numrin e ardhshëm palindromik në odometër.\n     Duke pasur parasysh leximin aktual palindromik të odometrit dhe kohën e kaluar në orë,\n     gjeni shpejtësinë konstante të automjetit dhe leximin e ardhshëm palindromik të odometrit.\n     Shpejtësia llogaritet për orë.\n     Shembull:\n     >>> CalculateSpeedAndNextPalindrome(12321, 2)\n     (50, 12421)\n     >>> CalculateSpeedAndNextPalindrome(23332, 4)\n     (25, 23432)",
      "hy": "Գրեք C# ֆունկցիա `static (int, int) CalculateSpeedAndNextPalindrome(int currentPalindrome, int elapsedHours)` հետևյալ խնդիրը լուծելու համար:\nՀաշվեք տրանսպորտային միջոցի արագությունը և հաջորդ պալինդրոմ թիվը օդոմետրին։\n     Տրված է օդոմետրի ընթացիկ պալինդրոմ ընթերցումը և անցած ժամանակը ժամերով,\n     գտեք տրանսպորտային միջոցի հաստատուն արագությունը և օդոմետրի հաջորդ պալինդրոմ ընթերցումը։\n     Արագությունը հաշվարկվում է ժամում։\n     Օրինակ:\n     >>> CalculateSpeedAndNextPalindrome(12321, 2)\n     (50, 12421)\n     >>> CalculateSpeedAndNextPalindrome(23332, 4)\n     (25, 23432)",
      "bn": "C# ফাংশন `static (int, int) CalculateSpeedAndNextPalindrome(int currentPalindrome, int elapsedHours)` লিখুন নিম্নলিখিত সমস্যার সমাধানের জন্য:\nএকটি যানবাহনের গতি এবং ওডোমিটারে পরবর্তী প্যালিনড্রোমিক সংখ্যা হিসাব করুন।\n     বর্তমান প্যালিনড্রোমিক ওডোমিটার রিডিং এবং অতিবাহিত সময় ঘন্টায় দেওয়া হলে,\n     যানবাহনের ধ্রুবক গতি এবং পরবর্তী প্যালিনড্রোমিক ওডোমিটার রিডিং খুঁজে বের করুন।\n     গতি প্রতি ঘন্টায় হিসাব করা হয়।\n     উদাহরণ:\n     >>> CalculateSpeedAndNextPalindrome(12321, 2)\n     (50, 12421)\n     >>> CalculateSpeedAndNextPalindrome(23332, 4)\n     (25, 23432)",
      "bg": "Напишете C# функция `static (int, int) CalculateSpeedAndNextPalindrome(int currentPalindrome, int elapsedHours)` за решаване на следния проблем:\nИзчислете скоростта на превозно средство и следващото палиндромно число на километража.\n     Дадено е текущото палиндромно показание на километража и изминалото време в часове,\n     намерете постоянната скорост на превозното средство и следващото палиндромно показание на километража.\n     Скоростта се изчислява на час.\n     Пример:\n     >>> CalculateSpeedAndNextPalindrome(12321, 2)\n     (50, 12421)\n     >>> CalculateSpeedAndNextPalindrome(23332, 4)\n     (25, 23432)",
      "zh": "编写一个 C# 函数 `static (int, int) CalculateSpeedAndNextPalindrome(int currentPalindrome, int elapsedHours)` 来解决以下问题：\n计算车辆的速度和里程表上的下一个回文数。\n给定当前回文的里程表读数和经过的时间（小时），\n找到车辆的恒定速度和下一个回文的里程表读数。\n速度以每小时计算。\n例子:\n>>> CalculateSpeedAndNextPalindrome(12321, 2)\n(50, 12421)\n>>> CalculateSpeedAndNextPalindrome(23332, 4)\n(25, 23432)",
      "fr": "Écrire une fonction C# `static (int, int) CalculateSpeedAndNextPalindrome(int currentPalindrome, int elapsedHours)` pour résoudre le problème suivant :\nCalculer la vitesse d'un véhicule et le prochain nombre palindrome sur l'odomètre.\n     Étant donné la lecture actuelle de l'odomètre palindromique et le temps écoulé en heures,\n     trouver la vitesse constante du véhicule et la prochaine lecture palindromique de l'odomètre.\n     La vitesse est calculée par heure.\n     Exemple :\n     >>> CalculateSpeedAndNextPalindrome(12321, 2)\n     (50, 12421)\n     >>> CalculateSpeedAndNextPalindrome(23332, 4)\n     (25, 23432)",
      "de": "Schreiben Sie eine C#-Funktion `static (int, int) CalculateSpeedAndNextPalindrome(int currentPalindrome, int elapsedHours)`, um das folgende Problem zu lösen:\nBerechnen Sie die Geschwindigkeit eines Fahrzeugs und die nächste palindromische Zahl auf dem Kilometerzähler.\n     Gegeben sind der aktuelle palindromische Kilometerzählerstand und die verstrichene Zeit in Stunden,\n     finden Sie die konstante Geschwindigkeit des Fahrzeugs und den nächsten palindromischen Kilometerzählerstand.\n     Die Geschwindigkeit wird pro Stunde berechnet.\n     Beispiel:\n     >>> CalculateSpeedAndNextPalindrome(12321, 2)\n     (50, 12421)\n     >>> CalculateSpeedAndNextPalindrome(23332, 4)\n     (25, 23432)",
      "ha": "Rubuta aikin C# `static (int, int) CalculateSpeedAndNextPalindrome(int currentPalindrome, int elapsedHours)` don warware matsalar mai zuwa:\nƘididdige saurin abin hawa da lambar palindrome mai zuwa akan odometer.\n     An ba da karatun odometer palindrome na yanzu da lokacin da ya wuce a cikin sa'o'i,\n     nemo saurin dindindin na abin hawa da karatun odometer palindrome na gaba.\n     Ana ƙididdige saurin a kowace awa.\n     Misali:\n     >>> CalculateSpeedAndNextPalindrome(12321, 2)\n     (50, 12421)\n     >>> CalculateSpeedAndNextPalindrome(23332, 4)\n     (25, 23432)",
      "hi": "C# फ़ंक्शन `static (int, int) CalculateSpeedAndNextPalindrome(int currentPalindrome, int elapsedHours)` लिखें ताकि निम्नलिखित समस्या का समाधान किया जा सके:\nवाहन की गति और ओडोमीटर पर अगले पालिंड्रोमिक संख्या की गणना करें।\n     दिए गए वर्तमान पालिंड्रोमिक ओडोमीटर रीडिंग और बीते हुए समय (घंटों में),\n     वाहन की स्थिर गति और अगले पालिंड्रोमिक ओडोमीटर रीडिंग का पता लगाएं।\n     गति प्रति घंटे की गणना की जाती है।\n     उदाहरण:\n     >>> CalculateSpeedAndNextPalindrome(12321, 2)\n     (50, 12421)\n     >>> CalculateSpeedAndNextPalindrome(23332, 4)\n     (25, 23432)",
      "hu": "Írj egy C# függvényt `static (int, int) CalculateSpeedAndNextPalindrome(int currentPalindrome, int elapsedHours)` a következő probléma megoldására:\nSzámítsd ki egy jármű sebességét és a következő palindrom számot a kilométerórán.\n     Adott a jelenlegi palindrom kilométeróra állás és az eltelt idő órákban, \n     találd meg a jármű állandó sebességét és a következő palindrom kilométeróra állást.\n     A sebesség óránként van kiszámítva.\n     Példa:\n     >>> CalculateSpeedAndNextPalindrome(12321, 2)\n     (50, 12421)\n     >>> CalculateSpeedAndNextPalindrome(23332, 4)\n     (25, 23432)"
    },
    "instruction_bertscore": {
      "sq": "0.9768420811359044",
      "hy": "0.8945791101999245",
      "bn": "0.9793489951749458",
      "bg": "0.9767914303887406",
      "zh": "0.9742731944179802",
      "fr": "0.992843347371313",
      "de": "0.9970551059707767",
      "ha": "0.9689262631909021",
      "hi": "0.9736075840111323",
      "hu": "0.9804406677491135"
    },
    "level": "middle",
    "test": "    static void Main()\n    {\n        Debug.Assert(CalculateSpeedAndNextPalindrome(12321, 2) == (50, 12421));\n        Debug.Assert(CalculateSpeedAndNextPalindrome(11111, 1) == (100, 11211));\n        Debug.Assert(CalculateSpeedAndNextPalindrome(23332, 2) == (50, 23432));\n        Debug.Assert(CalculateSpeedAndNextPalindrome(45654, 4) == (25, 45754));\n\n    }\n}",
    "entry_point": "CalculateSpeedAndNextPalindrome",
    "signature": "static (int, int) CalculateSpeedAndNextPalindrome(int currentPalindrome, int elapsedHours)",
    "docstring": {
      "en": "Calculate the speed of a vehicle and the next palindromic number on the odometer.\n     Given the current palindromic odometer reading and the time elapsed in hours, \n     find the constant speed of the vehicle and the next palindromic odometer reading.\n     The speed is calculated per hour.\n     Example:\n     >>> CalculateSpeedAndNextPalindrome(12321, 2)\n     (50, 12421)\n     >>> CalculateSpeedAndNextPalindrome(23332, 4)\n     (25, 23432)",
      "sq": "Llogaritni shpejtësinë e një automjeti dhe numrin e ardhshëm palindromik në odometër.\n     Duke pasur parasysh leximin aktual palindromik të odometrit dhe kohën e kaluar në orë,\n     gjeni shpejtësinë konstante të automjetit dhe leximin e ardhshëm palindromik të odometrit.\n     Shpejtësia llogaritet për orë.\n     Shembull:\n     >>> CalculateSpeedAndNextPalindrome(12321, 2)\n     (50, 12421)\n     >>> CalculateSpeedAndNextPalindrome(23332, 4)\n     (25, 23432)",
      "hy": "Հաշվեք տրանսպորտային միջոցի արագությունը և հաջորդ պալինդրոմիկ թիվը ոդոմետրին։ \n     Տրված է ոդոմետրի ընթացիկ պալինդրոմիկ ցուցիչը և անցած ժամանակը ժամերով, \n     գտեք տրանսպորտային միջոցի հաստատուն արագությունը և ոդոմետրի հաջորդ պալինդրոմիկ ցուցիչը։ \n     Արագությունը հաշվարկվում է ժամում։ \n     Օրինակ:\n     >>> CalculateSpeedAndNextPalindrome(12321, 2)\n     (50, 12421)\n     >>> CalculateSpeedAndNextPalindrome(23332, 4)\n     (25, 23432)",
      "bn": "যানবাহনের গতি এবং ওডোমিটারে পরবর্তী প্যালিনড্রোমিক সংখ্যা গণনা করুন।\n     বর্তমান প্যালিনড্রোমিক ওডোমিটার রিডিং এবং ঘন্টায় অতিক্রান্ত সময় দেওয়া হলে,\n     যানবাহনের ধ্রুবক গতি এবং পরবর্তী প্যালিনড্রোমিক ওডোমিটার রিডিং খুঁজুন।\n     গতি প্রতি ঘন্টায় গণনা করা হয়।\n     উদাহরণ:\n     >>> CalculateSpeedAndNextPalindrome(12321, 2)\n     (50, 12421)\n     >>> CalculateSpeedAndNextPalindrome(23332, 4)\n     (25, 23432)",
      "bg": "Изчислете скоростта на превозно средство и следващото палиндромно число на километража.\n     Като се даде текущото палиндромно показание на километража и изминалото време в часове,\n     намерете постоянната скорост на превозното средство и следващото палиндромно показание на километража.\n     Скоростта се изчислява на час.\n     Пример:\n     >>> CalculateSpeedAndNextPalindrome(12321, 2)\n     (50, 12421)\n     >>> CalculateSpeedAndNextPalindrome(23332, 4)\n     (25, 23432)",
      "zh": "计算车辆的速度和里程表上的下一个回文数。\n     给定当前回文里程表读数和经过的时间（小时），\n     找出车辆的恒定速度和下一个回文里程表读数。\n     速度以每小时计算。\n     示例：\n     >>> CalculateSpeedAndNextPalindrome(12321, 2)\n     (50, 12421)\n     >>> CalculateSpeedAndNextPalindrome(23332, 4)\n     (25, 23432)",
      "fr": "Calculer la vitesse d'un véhicule et le prochain nombre palindrome sur l'odomètre.\n     Étant donné la lecture actuelle de l'odomètre palindromique et le temps écoulé en heures,\n     trouver la vitesse constante du véhicule et la prochaine lecture palindromique de l'odomètre.\n     La vitesse est calculée par heure.\n     Exemple :\n     >>> CalculateSpeedAndNextPalindrome(12321, 2)\n     (50, 12421)\n     >>> CalculateSpeedAndNextPalindrome(23332, 4)\n     (25, 23432)",
      "de": "Berechne die Geschwindigkeit eines Fahrzeugs und die nächste palindromische Zahl auf dem Kilometerzähler.\n     Gegeben ist der aktuelle palindromische Kilometerzählerstand und die verstrichene Zeit in Stunden,\n     finde die konstante Geschwindigkeit des Fahrzeugs und den nächsten palindromischen Kilometerzählerstand.\n     Die Geschwindigkeit wird pro Stunde berechnet.\n     Beispiel:\n     >>> CalculateSpeedAndNextPalindrome(12321, 2)\n     (50, 12421)\n     >>> CalculateSpeedAndNextPalindrome(23332, 4)\n     (25, 23432)",
      "ha": "Ƙididdige saurin abin hawa da lambar palindrome na gaba akan odometer.\n     An ba da karatun odometer na palindrome na yanzu da lokacin da ya wuce a cikin sa'o'i,\n     nemo saurin dindindin na abin hawa da karatun odometer na palindrome na gaba.\n     Ana ƙididdige saurin a kowace awa.\n     Misali:\n     >>> CalculateSpeedAndNextPalindrome(12321, 2)\n     (50, 12421)\n     >>> CalculateSpeedAndNextPalindrome(23332, 4)\n     (25, 23432)",
      "hi": "वाहन की गति और ओडोमीटर पर अगली पलिंड्रोमिक संख्या की गणना करें। \n     दिए गए वर्तमान पलिंड्रोमिक ओडोमीटर रीडिंग और बीते हुए समय (घंटों में) के आधार पर, \n     वाहन की स्थिर गति और अगली पलिंड्रोमिक ओडोमीटर रीडिंग का पता लगाएं। \n     गति प्रति घंटे के हिसाब से गणना की जाती है।\n     उदाहरण:\n     >>> CalculateSpeedAndNextPalindrome(12321, 2)\n     (50, 12421)\n     >>> CalculateSpeedAndNextPalindrome(23332, 4)\n     (25, 23432)",
      "hu": "Számítsa ki egy jármű sebességét és a következő palindromikus számot a kilométerórán.\n     Adott a jelenlegi palindromikus kilométeróra állás és az eltelt idő órákban,\n     találja meg a jármű állandó sebességét és a következő palindromikus kilométeróra állást.\n     A sebesség óránként kerül kiszámításra.\n     Példa:\n     >>> CalculateSpeedAndNextPalindrome(12321, 2)\n     (50, 12421)\n     >>> CalculateSpeedAndNextPalindrome(23332, 4)\n     (25, 23432)"
    },
    "docstring_bertscore": {
      "sq": "0.9794342076084097",
      "hy": "0.9692083183319716",
      "bn": "0.9939737528697825",
      "bg": "0.9983962583035243",
      "zh": "0.9658957594674528",
      "fr": "0.9917437295819038",
      "de": "0.9983962583035243",
      "ha": "0.9748136676847762",
      "hi": "0.9744698384952047",
      "hu": "0.9983962583035243"
    }
  },
  {
    "task_id": "C#/33",
    "prompt": {
      "en": "using System;\nusing System.Collections.Generic;\nusing System.Diagnostics;\n\nclass Program\n{\n\n/* Finds all automorphic numbers within a specified limit.\n    An automorphic number is a number whose square ends in the number itself.\n    Examples:\n    >>> FindAutomorphicNumbers(100)\n    [0, 1, 5, 6, 25, 76]\n    >>> FindAutomorphicNumbers(500)\n    [0, 1, 5, 6, 25, 76, 376]\n*/\n\nstatic List<int> FindAutomorphicNumbers(int limit)",
      "sq": "using System;\nusing System.Collections.Generic;\nusing System.Diagnostics;\n\nclass Program\n{\n\n/* Gjen të gjitha numrat automorfikë brenda një kufiri të specifikuar.\n    Një numër automorfik është një numër katrori i të cilit përfundon me vetë numrin.\n    Shembuj:\n    >>> FindAutomorphicNumbers(100)\n    [0, 1, 5, 6, 25, 76]\n    >>> FindAutomorphicNumbers(500)\n    [0, 1, 5, 6, 25, 76, 376]\n*/\n\nstatic List<int> FindAutomorphicNumbers(int limit)",
      "hy": "using System;\nusing System.Collections.Generic;\nusing System.Diagnostics;\n\nclass Program\n{\n\n/* Գտնում է բոլոր ավտոմորֆ թվերը նշված սահմանաչափի մեջ:\n    Ավտոմորֆ թիվը թիվ է, որի քառակուսին ավարտվում է նույն թվով:\n    Օրինակներ:\n    >>> FindAutomorphicNumbers(100)\n    [0, 1, 5, 6, 25, 76]\n    >>> FindAutomorphicNumbers(500)\n    [0, 1, 5, 6, 25, 76, 376]\n*/\n\nstatic List<int> FindAutomorphicNumbers(int limit)",
      "bn": "using System;\nusing System.Collections.Generic;\nusing System.Diagnostics;\n\nclass Program\n{\n\n/* একটি নির্দিষ্ট সীমার মধ্যে সমস্ত অটোমরফিক সংখ্যা খুঁজে বের করে।\n    একটি অটোমরফিক সংখ্যা হল এমন একটি সংখ্যা যার বর্গ শেষ হয় সেই সংখ্যাতেই।\n    উদাহরণ:\n    >>> FindAutomorphicNumbers(100)\n    [0, 1, 5, 6, 25, 76]\n    >>> FindAutomorphicNumbers(500)\n    [0, 1, 5, 6, 25, 76, 376]\n*/\n\nstatic List<int> FindAutomorphicNumbers(int limit)",
      "bg": "using System;\nusing System.Collections.Generic;\nusing System.Diagnostics;\n\nclass Program\n{\n\n/* Намира всички автоморфни числа в рамките на определен лимит.\n    Автоморфно число е число, чийто квадрат завършва със самото число.\n    Примери:\n    >>> FindAutomorphicNumbers(100)\n    [0, 1, 5, 6, 25, 76]\n    >>> FindAutomorphicNumbers(500)\n    [0, 1, 5, 6, 25, 76, 376]\n*/\n\nstatic List<int> FindAutomorphicNumbers(int limit)",
      "zh": "using System;\nusing System.Collections.Generic;\nusing System.Diagnostics;\n\nclass Program\n{\n\n/* 查找指定范围内的所有自守数。\n    自守数是其平方的末尾与该数字本身相同的数字。\n    例子:\n    >>> FindAutomorphicNumbers(100)\n    [0, 1, 5, 6, 25, 76]\n    >>> FindAutomorphicNumbers(500)\n    [0, 1, 5, 6, 25, 76, 376]\n*/\n\nstatic List<int> FindAutomorphicNumbers(int limit)",
      "fr": "using System;\nusing System.Collections.Generic;\nusing System.Diagnostics;\n\nclass Program\n{\n\n/* Trouve tous les nombres automorphes dans une limite spécifiée.\n    Un nombre automorphe est un nombre dont le carré se termine par le nombre lui-même.\n    Exemples :\n    >>> FindAutomorphicNumbers(100)\n    [0, 1, 5, 6, 25, 76]\n    >>> FindAutomorphicNumbers(500)\n    [0, 1, 5, 6, 25, 76, 376]\n*/\n\nstatic List<int> FindAutomorphicNumbers(int limit)",
      "de": "using System;\nusing System.Collections.Generic;\nusing System.Diagnostics;\n\nclass Program\n{\n\n/* Findet alle automorphen Zahlen innerhalb eines angegebenen Limits.\n    Eine automorphe Zahl ist eine Zahl, deren Quadrat in der Zahl selbst endet.\n    Beispiele:\n    >>> FindAutomorphicNumbers(100)\n    [0, 1, 5, 6, 25, 76]\n    >>> FindAutomorphicNumbers(500)\n    [0, 1, 5, 6, 25, 76, 376]\n*/\n\nstatic List<int> FindAutomorphicNumbers(int limit)",
      "ha": "using System;\nusing System.Collections.Generic;\nusing System.Diagnostics;\n\nclass Program\n{\n\n/* Nemi duk lambobin automorphic a cikin iyaka da aka kayyade.\n    Lamba mai automorphic ita ce lamba wadda karshen murdaddenta yake ƙarewa da kanta.\n    Misalai:\n    >>> FindAutomorphicNumbers(100)\n    [0, 1, 5, 6, 25, 76]\n    >>> FindAutomorphicNumbers(500)\n    [0, 1, 5, 6, 25, 76, 376]\n*/\n\nstatic List<int> FindAutomorphicNumbers(int limit)",
      "hi": "using System;\nusing System.Collections.Generic;\nusing System.Diagnostics;\n\nclass Program\n{\n\n/* निर्दिष्ट सीमा के भीतर सभी स्वयंसिद्ध संख्याएँ खोजता है।\n    एक स्वयंसिद्ध संख्या वह संख्या होती है जिसका वर्ग स्वयं संख्या पर समाप्त होता है।\n    उदाहरण:\n    >>> FindAutomorphicNumbers(100)\n    [0, 1, 5, 6, 25, 76]\n    >>> FindAutomorphicNumbers(500)\n    [0, 1, 5, 6, 25, 76, 376]\n*/\n\nstatic List<int> FindAutomorphicNumbers(int limit)",
      "hu": "using System;\nusing System.Collections.Generic;\nusing System.Diagnostics;\n\nclass Program\n{\n\n/* Megtalálja az összes automorf számot egy megadott határértéken belül.\n    Egy automorf szám olyan szám, amelynek a négyzete végződik magával a számmal.\n    Példák:\n    >>> FindAutomorphicNumbers(100)\n    [0, 1, 5, 6, 25, 76]\n    >>> FindAutomorphicNumbers(500)\n    [0, 1, 5, 6, 25, 76, 376]\n*/\n\nstatic List<int> FindAutomorphicNumbers(int limit)"
    },
    "prompt_bertscore": {
      "sq": "0.9982792650090948",
      "hy": "0.9844792206563149",
      "bn": "0.9870995526429271",
      "bg": "0.9939233007529996",
      "zh": "0.9824180331923158",
      "fr": "0.9982792650090948",
      "de": "0.9946761098971219",
      "ha": "0.9929732516405098",
      "hi": "0.9960327553995901",
      "hu": "0.9929464365390701"
    },
    "canonical_solution": "{\n    var automorphicNumbers = new List<int>();\n    for (int i = 0; i <= limit; i++)\n    {\n        long square = (long)i * i;\n        string numberStr = i.ToString();\n        string squareStr = square.ToString();\n        if (squareStr.EndsWith(numberStr))\n        {\n            automorphicNumbers.Add(i);\n        }\n    }\n    return automorphicNumbers;\n}",
    "instruction": {
      "en": "Write a C# function `static List<int> FindAutomorphicNumbers(int limit)` to solve the following problem:\nFinds all automorphic numbers within a specified limit.\n    An automorphic number is a number whose square ends in the number itself.\n    Examples:\n    >>> FindAutomorphicNumbers(100)\n    [0, 1, 5, 6, 25, 76]\n    >>> FindAutomorphicNumbers(500)\n    [0, 1, 5, 6, 25, 76, 376]",
      "sq": "Shkruani një funksion në C# `static List<int> FindAutomorphicNumbers(int limit)` për të zgjidhur problemin e mëposhtëm:\nGjen të gjitha numrat automorfikë brenda një kufiri të specifikuar.\n    Një numër automorfik është një numër katrori i të cilit përfundon me vetë numrin.\n    Shembuj:\n    >>> FindAutomorphicNumbers(100)\n    [0, 1, 5, 6, 25, 76]\n    >>> FindAutomorphicNumbers(500)\n    [0, 1, 5, 6, 25, 76, 376]",
      "hy": "Գրեք C# ֆունկցիա `static List<int> FindAutomorphicNumbers(int limit)` հետևյալ խնդիրը լուծելու համար:\nԳտնում է բոլոր ավտոմորֆ թվերը նշված սահմանափակման մեջ:\n    Ավտոմորֆ թիվը այն թիվն է, որի քառակուսին ավարտվում է հենց այդ թվով:\n    Օրինակներ:\n    >>> FindAutomorphicNumbers(100)\n    [0, 1, 5, 6, 25, 76]\n    >>> FindAutomorphicNumbers(500)\n    [0, 1, 5, 6, 25, 76, 376]",
      "bn": "C# ফাংশন `static List<int> FindAutomorphicNumbers(int limit)` লিখুন নিম্নলিখিত সমস্যার সমাধানের জন্য:\nনির্দিষ্ট সীমার মধ্যে সমস্ত অটোমরফিক সংখ্যা খুঁজে বের করে।\n    একটি অটোমরফিক সংখ্যা হল একটি সংখ্যা যার বর্গ তার নিজের সংখ্যা দিয়ে শেষ হয়।\n    উদাহরণ:\n    >>> FindAutomorphicNumbers(100)\n    [0, 1, 5, 6, 25, 76]\n    >>> FindAutomorphicNumbers(500)\n    [0, 1, 5, 6, 25, 76, 376]",
      "bg": "Напишете C# функция `static List<int> FindAutomorphicNumbers(int limit)`, за да решите следния проблем:\nНамира всички автоморфни числа в рамките на зададен лимит.\n    Автоморфно число е число, чийто квадрат завършва със самото число.\n    Примери:\n    >>> FindAutomorphicNumbers(100)\n    [0, 1, 5, 6, 25, 76]\n    >>> FindAutomorphicNumbers(500)\n    [0, 1, 5, 6, 25, 76, 376]",
      "zh": "编写一个 C# 函数 `static List<int> FindAutomorphicNumbers(int limit)` 来解决以下问题：\n在指定的限制范围内查找所有的自守数。\n    自守数是其平方数的末尾部分与该数本身相同的数。\n    例子:\n    >>> FindAutomorphicNumbers(100)\n    [0, 1, 5, 6, 25, 76]\n    >>> FindAutomorphicNumbers(500)\n    [0, 1, 5, 6, 25, 76, 376]",
      "fr": "Écrire une fonction C# `static List<int> FindAutomorphicNumbers(int limit)` pour résoudre le problème suivant :\nTrouve tous les nombres automorphes dans une limite spécifiée.\n    Un nombre automorphe est un nombre dont le carré se termine par le nombre lui-même.\n    Exemples :\n    >>> FindAutomorphicNumbers(100)\n    [0, 1, 5, 6, 25, 76]\n    >>> FindAutomorphicNumbers(500)\n    [0, 1, 5, 6, 25, 76, 376]",
      "de": "Schreiben Sie eine C#-Funktion `static List<int> FindAutomorphicNumbers(int limit)`, um das folgende Problem zu lösen:\nFindet alle automorphen Zahlen innerhalb eines angegebenen Limits.\n    Eine automorphe Zahl ist eine Zahl, deren Quadrat mit der Zahl selbst endet.\n    Beispiele:\n    >>> FindAutomorphicNumbers(100)\n    [0, 1, 5, 6, 25, 76]\n    >>> FindAutomorphicNumbers(500)\n    [0, 1, 5, 6, 25, 76, 376]",
      "ha": "Rubuta aikin C# `static List<int> FindAutomorphicNumbers(int limit)` don warware matsalar mai zuwa:  \nNemo duk lambobin automorphic a cikin iyaka da aka ayyana.  \n    Lambar automorphic ita ce lamba wadda murdaddiyar ta ke ƙarewa da lambar kanta.  \n    Misalai:  \n    >>> FindAutomorphicNumbers(100)  \n    [0, 1, 5, 6, 25, 76]  \n    >>> FindAutomorphicNumbers(500)  \n    [0, 1, 5, 6, 25, 76, 376]",
      "hi": "C# फ़ंक्शन `static List<int> FindAutomorphicNumbers(int limit)` लिखें ताकि निम्नलिखित समस्या का समाधान किया जा सके:\nनिर्दिष्ट सीमा के भीतर सभी ऑटोमोर्फिक संख्याएँ खोजें।\n    एक ऑटोमोर्फिक संख्या वह संख्या होती है जिसका वर्ग स्वयं संख्या पर समाप्त होता है।\n    उदाहरण:\n    >>> FindAutomorphicNumbers(100)\n    [0, 1, 5, 6, 25, 76]\n    >>> FindAutomorphicNumbers(500)\n    [0, 1, 5, 6, 25, 76, 376]",
      "hu": "Írj egy C# függvényt `static List<int> FindAutomorphicNumbers(int limit)` a következő probléma megoldására:\nMegtalálja az összes automorf számot egy megadott határon belül.\n    Egy automorf szám olyan szám, amelynek a négyzete a számmal végződik.\n    Példák:\n    >>> FindAutomorphicNumbers(100)\n    [0, 1, 5, 6, 25, 76]\n    >>> FindAutomorphicNumbers(500)\n    [0, 1, 5, 6, 25, 76, 376]"
    },
    "instruction_bertscore": {
      "sq": "0.9900780152065453",
      "hy": "0.9884333556515764",
      "bn": "0.9763810600215225",
      "bg": "0.9916076677708949",
      "zh": "0.9844957069779408",
      "fr": "0.9904373375658374",
      "de": "0.9939097938870893",
      "ha": "0.9746368866456552",
      "hi": "0.9769036565540252",
      "hu": "0.9939097938870893"
    },
    "level": "easy",
    "test": "    static void Main()\n    {\n     Debug.Assert(FindAutomorphicNumbers(100).SequenceEqual(new List<int> { 0, 1, 5, 6, 25, 76 }));\n    Debug.Assert(FindAutomorphicNumbers(500).SequenceEqual(new List<int> { 0, 1, 5, 6, 25, 76, 376 }));\n    Debug.Assert(FindAutomorphicNumbers(1000).SequenceEqual(new List<int> { 0, 1, 5, 6, 25, 76, 376, 625 }));\n    Debug.Assert(FindAutomorphicNumbers(200000).SequenceEqual(new List<int> { 0, 1, 5, 6, 25, 76, 376, 625,9376, 90625, 109376 }));\n\n    }\n}",
    "entry_point": "FindAutomorphicNumbers",
    "signature": "static List<int> FindAutomorphicNumbers(int limit)",
    "docstring": {
      "en": "Finds all automorphic numbers within a specified limit.\n    An automorphic number is a number whose square ends in the number itself.\n    Examples:\n    >>> FindAutomorphicNumbers(100)\n    [0, 1, 5, 6, 25, 76]\n    >>> FindAutomorphicNumbers(500)\n    [0, 1, 5, 6, 25, 76, 376]",
      "sq": "Gjen të gjitha numrat automorfikë brenda një kufiri të specifikuar.\n    Një numër automorfik është një numër katrori i të cilit përfundon me vetë numrin.\n    Shembuj:\n    >>> FindAutomorphicNumbers(100)\n    [0, 1, 5, 6, 25, 76]\n    >>> FindAutomorphicNumbers(500)\n    [0, 1, 5, 6, 25, 76, 376]",
      "hy": "Գտնում է բոլոր ավտոմորֆ թվերը նշված սահմաններում:\n    Ավտոմորֆ թիվը թիվ է, որի քառակուսին ավարտվում է հենց այդ թվով:\n    Օրինակներ:\n    >>> FindAutomorphicNumbers(100)\n    [0, 1, 5, 6, 25, 76]\n    >>> FindAutomorphicNumbers(500)\n    [0, 1, 5, 6, 25, 76, 376]",
      "bn": "নির্দিষ্ট সীমার মধ্যে সমস্ত অটোমরফিক সংখ্যা খুঁজে বের করে।  \n    একটি অটোমরফিক সংখ্যা হল এমন একটি সংখ্যা যার বর্গ শেষ হয় সেই সংখ্যা নিজেই দিয়ে।  \n    উদাহরণস্বরূপ:  \n    >>> FindAutomorphicNumbers(100)  \n    [0, 1, 5, 6, 25, 76]  \n    >>> FindAutomorphicNumbers(500)  \n    [0, 1, 5, 6, 25, 76, 376]  ",
      "bg": "Намира всички автоморфни числа в рамките на зададен лимит.\n    Автоморфно число е число, чийто квадрат завършва със самото число.\n    Примери:\n    >>> FindAutomorphicNumbers(100)\n    [0, 1, 5, 6, 25, 76]\n    >>> FindAutomorphicNumbers(500)\n    [0, 1, 5, 6, 25, 76, 376]",
      "zh": "查找指定范围内的所有自守数。\n    自守数是其平方以该数字本身结尾的数字。\n    示例：\n    >>> FindAutomorphicNumbers(100)\n    [0, 1, 5, 6, 25, 76]\n    >>> FindAutomorphicNumbers(500)\n    [0, 1, 5, 6, 25, 76, 376]",
      "fr": "Trouve tous les nombres automorphes dans une limite spécifiée.  \n    Un nombre automorphe est un nombre dont le carré se termine par le nombre lui-même.  \n    Exemples :  \n    >>> FindAutomorphicNumbers(100)  \n    [0, 1, 5, 6, 25, 76]  \n    >>> FindAutomorphicNumbers(500)  \n    [0, 1, 5, 6, 25, 76, 376]  ",
      "de": "Findet alle automorphen Zahlen innerhalb eines festgelegten Limits.\n    Eine automorphe Zahl ist eine Zahl, deren Quadrat mit der Zahl selbst endet.\n    Beispiele:\n    >>> FindAutomorphicNumbers(100)\n    [0, 1, 5, 6, 25, 76]\n    >>> FindAutomorphicNumbers(500)\n    [0, 1, 5, 6, 25, 76, 376]",
      "ha": "Nemi duk lambobin automorphic a cikin iyaka da aka kayyade.\n    Lambar automorphic lamba ce da murabba'inta ke ƙarewa da lambarta kanta.\n    Misalai:\n    >>> FindAutomorphicNumbers(100)\n    [0, 1, 5, 6, 25, 76]\n    >>> FindAutomorphicNumbers(500)\n    [0, 1, 5, 6, 25, 76, 376]",
      "hi": "निर्दिष्ट सीमा के भीतर सभी स्वयंसंबंधी संख्याएँ खोजता है।  \n    एक स्वयंसंबंधी संख्या वह संख्या है जिसका वर्ग स्वयं संख्या पर समाप्त होता है।  \n    उदाहरण:  \n    >>> FindAutomorphicNumbers(100)  \n    [0, 1, 5, 6, 25, 76]  \n    >>> FindAutomorphicNumbers(500)  \n    [0, 1, 5, 6, 25, 76, 376]  ",
      "hu": "Megtalálja az összes automorf számot egy megadott határon belül.\n    Egy automorf szám olyan szám, amelynek a négyzete a számmal végződik.\n    Példák:\n    >>> FindAutomorphicNumbers(100)\n    [0, 1, 5, 6, 25, 76]\n    >>> FindAutomorphicNumbers(500)\n    [0, 1, 5, 6, 25, 76, 376]"
    },
    "docstring_bertscore": {
      "sq": "0.98785633439467",
      "hy": "0.9858160031206796",
      "bn": "0.9741661326426024",
      "bg": "0.9926435252079919",
      "zh": "0.9782293157170521",
      "fr": "0.98785633439467",
      "de": "0.9977270725498177",
      "ha": "0.9977270725498177",
      "hi": "0.9841306243375987",
      "hu": "0.9822001356643205"
    }
  },
  {
    "task_id": "C#/34",
    "prompt": {
      "en": "using System;\nusing System.Collections.Generic;\nusing System.Diagnostics;\n\nclass Program\n{\n\n/* Determine the last remaining person's number in a circular counting game.\n   In this game, people are numbered from 1 to totalPeople and sit in a circle. \n   Starting with the first person, they count from 1 to countNumber. \n   The person who is at countNumber is removed from the circle, \n   and the count resumes from the next person. \n   This process continues until only one person remains.\n\n   Example:\n   >>> LastRemainingPerson(5, 2)\n   3\n   >>> LastRemainingPerson(6, 4)\n   5\n*/\n\nstatic int LastRemainingPerson(int totalPeople, int countNumber)",
      "sq": "using System;\nusing System.Collections.Generic;\nusing System.Diagnostics;\n\nclass Program\n{\n\n/* Përcaktoni numrin e personit të fundit të mbetur në një lojë numërimi rrethore.\n   Në këtë lojë, njerëzit numërohen nga 1 deri në totalPeople dhe ulen në një rreth. \n   Duke filluar me personin e parë, ata numërojnë nga 1 deri në countNumber. \n   Personi që është në countNumber hiqet nga rrethi, \n   dhe numërimi vazhdon nga personi tjetër. \n   Ky proces vazhdon derisa të mbetet vetëm një person.\n\n   Shembull:\n   >>> LastRemainingPerson(5, 2)\n   3\n   >>> LastRemainingPerson(6, 4)\n   5\n*/\n\nstatic int LastRemainingPerson(int totalPeople, int countNumber)",
      "hy": "using System;\nusing System.Collections.Generic;\nusing System.Diagnostics;\n\nclass Program\n{\n\n/* Որոշել վերջին մնացած անձի համարը շրջանաձև հաշվարկի խաղում:\n   Այս խաղում մարդիկ համարակալված են 1-ից մինչև totalPeople և նստած են շրջանաձև: \n   Սկսելով առաջին մարդուց, նրանք հաշվում են 1-ից մինչև countNumber: \n   countNumber-ի վրա գտնվող անձը հեռացվում է շրջանից, \n   և հաշվարկը վերսկսվում է հաջորդ մարդուց: \n   Այս գործընթացը շարունակվում է, մինչև միայն մեկ մարդ մնա:\n\n   Օրինակ:\n   >>> LastRemainingPerson(5, 2)\n   3\n   >>> LastRemainingPerson(6, 4)\n   5\n*/\n\nstatic int LastRemainingPerson(int totalPeople, int countNumber)",
      "bn": "using System;\nusing System.Collections.Generic;\nusing System.Diagnostics;\n\nclass Program\n{\n\n/* একটি বৃত্তাকার গণনা গেমে শেষ অবশিষ্ট ব্যক্তির নম্বর নির্ধারণ করুন।\n   এই গেমে, মানুষদের 1 থেকে totalPeople পর্যন্ত নম্বর দেওয়া হয় এবং তারা একটি বৃত্তে বসে। \n   প্রথম ব্যক্তির সাথে শুরু করে, তারা 1 থেকে countNumber পর্যন্ত গণনা করে। \n   যে ব্যক্তি countNumber এ থাকে তাকে বৃত্ত থেকে সরিয়ে দেওয়া হয়, \n   এবং গণনা পরবর্তী ব্যক্তি থেকে পুনরায় শুরু হয়। \n   এই প্রক্রিয়া চলতে থাকে যতক্ষণ না শুধুমাত্র একজন ব্যক্তি অবশিষ্ট থাকে।\n\n   উদাহরণ:\n   >>> LastRemainingPerson(5, 2)\n   3\n   >>> LastRemainingPerson(6, 4)\n   5\n*/\n\nstatic int LastRemainingPerson(int totalPeople, int countNumber)",
      "bg": "using System;\nusing System.Collections.Generic;\nusing System.Diagnostics;\n\nclass Program\n{\n\n/* Определете номера на последния останал човек в игра на броене в кръг.\n   В тази игра хората са номерирани от 1 до totalPeople и седят в кръг. \n   Започвайки с първия човек, те броят от 1 до countNumber. \n   Човекът, който е на countNumber, се премахва от кръга, \n   и броенето продължава от следващия човек. \n   Този процес продължава, докато остане само един човек.\n\n   Пример:\n   >>> LastRemainingPerson(5, 2)\n   3\n   >>> LastRemainingPerson(6, 4)\n   5\n*/\n\nstatic int LastRemainingPerson(int totalPeople, int countNumber)",
      "zh": "using System;\nusing System.Collections.Generic;\nusing System.Diagnostics;\n\nclass Program\n{\n\n/* 确定圆圈计数游戏中最后剩下的人的编号。\n   在这个游戏中，人们从1到totalPeople编号并坐成一个圆圈。\n   从第一个人开始，他们从1数到countNumber。\n   在countNumber的那个人将被移出圆圈，\n   计数从下一个人继续。\n   这个过程持续到只剩下一个人为止。\n\n   示例：\n   >>> LastRemainingPerson(5, 2)\n   3\n   >>> LastRemainingPerson(6, 4)\n   5\n*/\n\nstatic int LastRemainingPerson(int totalPeople, int countNumber)",
      "fr": "using System;\nusing System.Collections.Generic;\nusing System.Diagnostics;\n\nclass Program\n{\n\n/* Détermine le numéro de la dernière personne restante dans un jeu de comptage circulaire.\n   Dans ce jeu, les personnes sont numérotées de 1 à totalPeople et sont assises en cercle. \n   En commençant par la première personne, elles comptent de 1 à countNumber. \n   La personne qui est à countNumber est retirée du cercle, \n   et le comptage reprend à partir de la personne suivante. \n   Ce processus continue jusqu'à ce qu'il ne reste qu'une seule personne.\n\n   Exemple :\n   >>> LastRemainingPerson(5, 2)\n   3\n   >>> LastRemainingPerson(6, 4)\n   5\n*/\n\nstatic int LastRemainingPerson(int totalPeople, int countNumber)",
      "de": "using System;\nusing System.Collections.Generic;\nusing System.Diagnostics;\n\nclass Program\n{\n\n/* Bestimmen Sie die Nummer der letzten verbleibenden Person in einem kreisförmigen Zählspiel.\n   In diesem Spiel sind die Personen von 1 bis totalPeople nummeriert und sitzen im Kreis. \n   Beginnend mit der ersten Person zählen sie von 1 bis countNumber. \n   Die Person, die bei countNumber ist, wird aus dem Kreis entfernt, \n   und das Zählen wird von der nächsten Person fortgesetzt. \n   Dieser Prozess wird fortgesetzt, bis nur noch eine Person übrig bleibt.\n\n   Beispiel:\n   >>> LastRemainingPerson(5, 2)\n   3\n   >>> LastRemainingPerson(6, 4)\n   5\n*/\n\nstatic int LastRemainingPerson(int totalPeople, int countNumber)",
      "ha": "using System;\nusing System.Collections.Generic;\nusing System.Diagnostics;\n\nclass Program\n{\n\n/* Kwatanta lambar mutumin da ya rage a ƙarshe a cikin wasan ƙidaya mai zagaye.\n   A cikin wannan wasan, mutane suna da lambobi daga 1 zuwa totalPeople kuma suna zaune a cikin zagaye. \n   Fara da mutum na farko, suna ƙidaya daga 1 zuwa countNumber. \n   Mutumin da yake a countNumber ana cire shi daga zagayen, \n   kuma ƙidayar tana ci gaba daga mutumin na gaba. \n   Wannan tsari yana ci gaba har sai mutum ɗaya kawai ya rage.\n\n   Misali:\n   >>> LastRemainingPerson(5, 2)\n   3\n   >>> LastRemainingPerson(6, 4)\n   5\n*/\n\nstatic int LastRemainingPerson(int totalPeople, int countNumber)",
      "hi": "using System;\nusing System.Collections.Generic;\nusing System.Diagnostics;\n\nclass Program\n{\n\n/* एक वृत्ताकार गिनती खेल में अंतिम बचे हुए व्यक्ति की संख्या निर्धारित करें।\n   इस खेल में, लोग 1 से totalPeople तक क्रमांकित होते हैं और एक वृत्त में बैठते हैं।\n   पहले व्यक्ति से शुरू होकर, वे 1 से countNumber तक गिनते हैं।\n   जो व्यक्ति countNumber पर होता है उसे वृत्त से हटा दिया जाता है,\n   और गिनती अगले व्यक्ति से फिर से शुरू होती है।\n   यह प्रक्रिया तब तक जारी रहती है जब तक केवल एक व्यक्ति नहीं बचता।\n\n   उदाहरण:\n   >>> LastRemainingPerson(5, 2)\n   3\n   >>> LastRemainingPerson(6, 4)\n   5\n*/\n\nstatic int LastRemainingPerson(int totalPeople, int countNumber)",
      "hu": "using System;\nusing System.Collections.Generic;\nusing System.Diagnostics;\n\nclass Program\n{\n\n/* Határozza meg az utolsó megmaradt személy számát egy körkörös számolós játékban.\n   Ebben a játékban az embereket 1-től totalPeople-ig számozzák, és körben ülnek. \n   Az első személlyel kezdve 1-től countNumber-ig számolnak. \n   Az a személy, aki a countNumber-nél van, kikerül a körből, \n   és a számolás a következő személynél folytatódik. \n   Ez a folyamat addig folytatódik, amíg csak egy személy marad.\n\n   Példa:\n   >>> LastRemainingPerson(5, 2)\n   3\n   >>> LastRemainingPerson(6, 4)\n   5\n*/\n\nstatic int LastRemainingPerson(int totalPeople, int countNumber)"
    },
    "prompt_bertscore": {
      "sq": "0.9878853344303011",
      "hy": "0.9848707211373346",
      "bn": "0.9907672626287364",
      "bg": "0.9783069801960368",
      "zh": "0.9760616623688184",
      "fr": "0.9807191475433245",
      "de": "0.9857170851909243",
      "ha": "0.9799534274244349",
      "hi": "0.9825985882086765",
      "hu": "0.986785716640892"
    },
    "canonical_solution": "{\n    List<int> people = new List<int>();\n    for (int i = 1; i <= totalPeople; i++)\n    {\n        people.Add(i);\n    }\n\n    int index = 0;\n    while (people.Count > 1)\n    {\n        index = (index + countNumber - 1) % people.Count;\n        people.RemoveAt(index);\n    }\n\n    return people[0];\n}",
    "instruction": {
      "en": "Write a C# function `static int LastRemainingPerson(int totalPeople, int countNumber)` to solve the following problem:\nDetermine the last remaining person's number in a circular counting game.\n   In this game, people are numbered from 1 to totalPeople and sit in a circle. \n   Starting with the first person, they count from 1 to countNumber. \n   The person who is at countNumber is removed from the circle, \n   and the count resumes from the next person. \n   This process continues until only one person remains.\n\n   Example:\n   >>> LastRemainingPerson(5, 2)\n   3\n   >>> LastRemainingPerson(6, 4)\n   5",
      "sq": "Shkruani një funksion në C# `static int LastRemainingPerson(int totalPeople, int countNumber)` për të zgjidhur problemin e mëposhtëm:\nPërcaktoni numrin e personit të fundit të mbetur në një lojë numërimi rrethore.\n   Në këtë lojë, njerëzit janë të numëruar nga 1 deri në totalPeople dhe ulen në një rreth. \n   Duke filluar me personin e parë, ata numërojnë nga 1 deri në countNumber. \n   Personi që është në countNumber largohet nga rrethi, \n   dhe numërimi vazhdon nga personi tjetër. \n   Ky proces vazhdon derisa të mbetet vetëm një person.\n\n   Shembull:\n   >>> LastRemainingPerson(5, 2)\n   3\n   >>> LastRemainingPerson(6, 4)\n   5",
      "hy": "Գրեք C# ֆունկցիա `static int LastRemainingPerson(int totalPeople, int countNumber)` հետևյալ խնդիրը լուծելու համար:\nՈրոշեք վերջին մնացած անձի համարը շրջանաձև հաշվելու խաղում:\n   Այս խաղում մարդիկ համարակալված են 1-ից մինչև totalPeople և նստած են շրջանաձև:\n   Սկսելով առաջին մարդուց, նրանք հաշվում են 1-ից մինչև countNumber:\n   countNumber-ի վրա գտնվող անձը հեռացվում է շրջանից,\n   և հաշվելը վերսկսվում է հաջորդ մարդուց:\n   Այս գործընթացը շարունակվում է, մինչև միայն մեկ մարդ մնա:\n\n   Օրինակ:\n   >>> LastRemainingPerson(5, 2)\n   3\n   >>> LastRemainingPerson(6, 4)\n   5",
      "bn": "C# ফাংশন `static int LastRemainingPerson(int totalPeople, int countNumber)` লিখুন নিম্নলিখিত সমস্যার সমাধানের জন্য:\nএকটি বৃত্তাকার গণনা খেলায় শেষ অবশিষ্ট ব্যক্তির সংখ্যা নির্ধারণ করুন।\n   এই খেলায়, মানুষদের 1 থেকে totalPeople পর্যন্ত নম্বর দেওয়া হয় এবং তারা একটি বৃত্তে বসে। \n   প্রথম ব্যক্তি থেকে শুরু করে, তারা 1 থেকে countNumber পর্যন্ত গণনা করে। \n   যে ব্যক্তি countNumber এ থাকে তাকে বৃত্ত থেকে সরিয়ে দেওয়া হয়, \n   এবং গণনা পরবর্তী ব্যক্তি থেকে পুনরায় শুরু হয়। \n   এই প্রক্রিয়া চলতে থাকে যতক্ষণ না শুধুমাত্র একজন ব্যক্তি অবশিষ্ট থাকে। \n\n   উদাহরণ:\n   >>> LastRemainingPerson(5, 2)\n   3\n   >>> LastRemainingPerson(6, 4)\n   5",
      "bg": "Напишете C# функция `static int LastRemainingPerson(int totalPeople, int countNumber)`, за да решите следния проблем:\nОпределете номера на последния останал човек в игра на броене в кръг.\n   В тази игра хората са номерирани от 1 до totalPeople и седят в кръг.\n   Започвайки с първия човек, те броят от 1 до countNumber.\n   Човекът, който е на countNumber, се премахва от кръга,\n   и броенето продължава от следващия човек.\n   Този процес продължава, докато остане само един човек.\n\n   Пример:\n   >>> LastRemainingPerson(5, 2)\n   3\n   >>> LastRemainingPerson(6, 4)\n   5",
      "zh": "编写一个 C# 函数 `static int LastRemainingPerson(int totalPeople, int countNumber)` 来解决以下问题：\n确定在一个循环计数游戏中最后剩下的人的编号。\n在这个游戏中，人们从1到totalPeople编号，并坐成一个圆圈。\n从第一个人开始，他们从1数到countNumber。\n在countNumber的人被从圆圈中移除，\n计数从下一个人继续。\n这个过程持续到只剩下一个人为止。",
      "fr": "Écrire une fonction C# `static int LastRemainingPerson(int totalPeople, int countNumber)` pour résoudre le problème suivant :\nDéterminer le numéro de la dernière personne restante dans un jeu de comptage circulaire.\n   Dans ce jeu, les personnes sont numérotées de 1 à totalPeople et s'assoient en cercle.\n   En commençant par la première personne, elles comptent de 1 à countNumber.\n   La personne qui est à countNumber est retirée du cercle,\n   et le comptage reprend à partir de la personne suivante.\n   Ce processus continue jusqu'à ce qu'il ne reste qu'une seule personne. \n\n   Exemple :\n   >>> LastRemainingPerson(5, 2)\n   3\n   >>> LastRemainingPerson(6, 4)\n   5",
      "de": "Schreiben Sie eine C#-Funktion `static int LastRemainingPerson(int totalPeople, int countNumber)`, um das folgende Problem zu lösen:\nBestimmen Sie die Nummer der letzten verbleibenden Person in einem kreisförmigen Zählspiel.\n   In diesem Spiel sind die Personen von 1 bis totalPeople nummeriert und sitzen im Kreis.\n   Beginnend mit der ersten Person zählen sie von 1 bis countNumber.\n   Die Person, die bei countNumber ist, wird aus dem Kreis entfernt,\n   und das Zählen wird von der nächsten Person fortgesetzt.\n   Dieser Prozess wird fortgesetzt, bis nur noch eine Person übrig bleibt.\n\n   Beispiel:\n   >>> LastRemainingPerson(5, 2)\n   3\n   >>> LastRemainingPerson(6, 4)\n   5",
      "ha": "Rubuta aikin C# `static int LastRemainingPerson(int totalPeople, int countNumber)` don warware matsalar mai zuwa:\nƘayyade lambar mutumin da ya rage a ƙarshe a cikin wasan ƙidaya na madauwari.\n   A cikin wannan wasan, mutane suna da lambobi daga 1 zuwa totalPeople kuma suna zaune a cikin madauwari.\n   Fara da mutum na farko, suna ƙidaya daga 1 zuwa countNumber.\n   Mutumin da yake a countNumber yana fita daga madauwari,\n   kuma ƙidayar tana ci gaba daga mutumin na gaba.\n   Wannan tsari yana ci gaba har sai mutum ɗaya ya rage.\n\n   Misali:\n   >>> LastRemainingPerson(5, 2)\n   3\n   >>> LastRemainingPerson(6, 4)\n   5",
      "hi": "C# फ़ंक्शन `static int LastRemainingPerson(int totalPeople, int countNumber)` लिखें ताकि निम्नलिखित समस्या का समाधान किया जा सके:\nएक वृत्ताकार गिनती खेल में अंतिम शेष व्यक्ति की संख्या निर्धारित करें।\n   इस खेल में, लोग 1 से totalPeople तक क्रमांकित होते हैं और एक वृत्त में बैठते हैं।\n   पहले व्यक्ति से शुरू करके, वे 1 से countNumber तक गिनते हैं।\n   जो व्यक्ति countNumber पर होता है उसे वृत्त से हटा दिया जाता है,\n   और गिनती अगले व्यक्ति से फिर से शुरू होती है।\n   यह प्रक्रिया तब तक जारी रहती है जब तक केवल एक व्यक्ति शेष नहीं रह जाता।\n\n   उदाहरण:\n   >>> LastRemainingPerson(5, 2)\n   3\n   >>> LastRemainingPerson(6, 4)\n   5",
      "hu": "Írj egy C# függvényt `static int LastRemainingPerson(int totalPeople, int countNumber)` a következő probléma megoldására:\nHatározd meg az utolsó megmaradó személy számát egy körkörös számolós játékban.\n   Ebben a játékban az emberek 1-től totalPeople-ig vannak számozva és körben ülnek.\n   Az első személlyel kezdve 1-től countNumber-ig számolnak.\n   Az a személy, aki a countNumber-nél van, kikerül a körből,\n   és a számolás a következő személynél folytatódik.\n   Ez a folyamat addig folytatódik, amíg csak egy személy marad.\n\n   Példa:\n   >>> LastRemainingPerson(5, 2)\n   3\n   >>> LastRemainingPerson(6, 4)\n   5"
    },
    "instruction_bertscore": {
      "sq": "0.9843961931570423",
      "hy": "0.9781776718179831",
      "bn": "0.9793986527702045",
      "bg": "0.9778455618208927",
      "zh": "0.9303325787862043",
      "fr": "0.9920380998065975",
      "de": "0.9831889177011123",
      "ha": "0.9664123970885246",
      "hi": "0.9790462824742486",
      "hu": "0.9855182561795084"
    },
    "level": "easy",
    "test": "static void Main()\n    {\n        Debug.Assert(LastRemainingPerson(5, 2) == 3);\n        Debug.Assert(LastRemainingPerson(6, 4) == 5);\n        Debug.Assert(LastRemainingPerson(10, 3) == 4);\n        Debug.Assert(LastRemainingPerson(7, 2) == 7);\n\n    }\n}",
    "entry_point": "LastRemainingPerson",
    "signature": "static int LastRemainingPerson(int totalPeople, int countNumber)",
    "docstring": {
      "en": "Determine the last remaining person's number in a circular counting game.\n   In this game, people are numbered from 1 to totalPeople and sit in a circle. \n   Starting with the first person, they count from 1 to countNumber. \n   The person who is at countNumber is removed from the circle, \n   and the count resumes from the next person. \n   This process continues until only one person remains.\n\n   Example:\n   >>> LastRemainingPerson(5, 2)\n   3\n   >>> LastRemainingPerson(6, 4)\n   5",
      "sq": "Përcaktoni numrin e personit të fundit të mbetur në një lojë numërimi rrethore. Në këtë lojë, njerëzit janë të numëruar nga 1 deri në totalPeople dhe ulen në një rreth. Duke filluar me personin e parë, ata numërojnë nga 1 deri në countNumber. Personi që është në countNumber hiqet nga rrethi, dhe numërimi vazhdon nga personi tjetër. Ky proces vazhdon derisa të mbetet vetëm një person.\n\n   Shembull:\n   >>> LastRemainingPerson(5, 2)\n   3\n   >>> LastRemainingPerson(6, 4)\n   5",
      "hy": "Վերջին մնացած անձի համարը որոշել շրջանաձև հաշվելու խաղում։  \n   Այս խաղում մարդիկ համարակալված են 1-ից մինչև totalPeople և նստած են շրջանաձև։  \n   Սկսելով առաջին մարդուց, նրանք հաշվում են 1-ից մինչև countNumber։  \n   countNumber-ում գտնվող անձը հեռացվում է շրջանից,  \n   և հաշվելը վերսկսվում է հաջորդ մարդուց։  \n   Այս գործընթացը շարունակվում է մինչև միայն մեկ մարդ մնա։\n\n   Օրինակ:\n   >>> LastRemainingPerson(5, 2)\n   3\n   >>> LastRemainingPerson(6, 4)\n   5",
      "bn": "একটি বৃত্তাকার গণনা খেলায় শেষ অবশিষ্ট ব্যক্তির সংখ্যা নির্ধারণ করুন।\n   এই খেলায়, মানুষদের 1 থেকে totalPeople পর্যন্ত নম্বর দেওয়া হয় এবং তারা একটি বৃত্তে বসে। \n   প্রথম ব্যক্তির সাথে শুরু করে, তারা 1 থেকে countNumber পর্যন্ত গণনা করে। \n   যে ব্যক্তি countNumber এ থাকে তাকে বৃত্ত থেকে সরিয়ে দেওয়া হয়, \n   এবং গণনা পরবর্তী ব্যক্তি থেকে পুনরায় শুরু হয়। \n   এই প্রক্রিয়া চলতে থাকে যতক্ষণ না শুধুমাত্র একজন ব্যক্তি অবশিষ্ট থাকে।\n\n   উদাহরণ:\n   >>> LastRemainingPerson(5, 2)\n   3\n   >>> LastRemainingPerson(6, 4)\n   5",
      "bg": "Определете номера на последния останал човек в игра на броене в кръг. В тази игра хората са номерирани от 1 до totalPeople и седят в кръг. Започвайки с първия човек, те броят от 1 до countNumber. Човекът, който е на countNumber, се премахва от кръга и броенето продължава от следващия човек. Този процес продължава, докато остане само един човек.\n\nПример:\n>>> LastRemainingPerson(5, 2)\n3\n>>> LastRemainingPerson(6, 4)\n5",
      "zh": "确定在一个循环计数游戏中最后剩下的人的编号。\n在这个游戏中，人们从1到totalPeople编号并围坐成一个圈。\n从第一个人开始，他们从1数到countNumber。\n数到countNumber的人被移出圈子，\n计数从下一个人继续。\n这个过程持续进行，直到只剩下一个人。\n\n示例：\n>>> LastRemainingPerson(5, 2)\n3\n>>> LastRemainingPerson(6, 4)\n5",
      "fr": "Déterminer le numéro de la dernière personne restante dans un jeu de comptage circulaire.  \n   Dans ce jeu, les personnes sont numérotées de 1 à totalPeople et sont assises en cercle.  \n   En commençant par la première personne, elles comptent de 1 à countNumber.  \n   La personne qui est à countNumber est retirée du cercle,  \n   et le comptage reprend à partir de la personne suivante.  \n   Ce processus continue jusqu'à ce qu'il ne reste qu'une seule personne.\n\n   Exemple :\n   >>> LastRemainingPerson(5, 2)\n   3\n   >>> LastRemainingPerson(6, 4)\n   5",
      "de": "Bestimme die Nummer der letzten verbleibenden Person in einem kreisförmigen Zählspiel.\n   In diesem Spiel sind die Personen von 1 bis totalPeople nummeriert und sitzen im Kreis.\n   Beginnend mit der ersten Person zählen sie von 1 bis countNumber.\n   Die Person, die bei countNumber ist, wird aus dem Kreis entfernt,\n   und das Zählen wird von der nächsten Person fortgesetzt.\n   Dieser Vorgang wird fortgesetzt, bis nur noch eine Person übrig bleibt.\n\n   Beispiel:\n   >>> LastRemainingPerson(5, 2)\n   3\n   >>> LastRemainingPerson(6, 4)\n   5",
      "ha": "Gano lambar mutumin da ya rage a ƙarshe a cikin wasan ƙidaya na madauwari.\n   A cikin wannan wasan, mutane suna da lambobi daga 1 zuwa totalPeople kuma suna zaune a cikin madauwari. \n   Fara da mutum na farko, suna ƙidaya daga 1 zuwa countNumber. \n   Mutumin da yake a countNumber ana cire shi daga madauwar, \n   kuma ƙidayar tana ci gaba daga mutumin na gaba. \n   Wannan tsari yana ci gaba har sai mutum guda ya rage.\n\n   Misali:\n   >>> LastRemainingPerson(5, 2)\n   3\n   >>> LastRemainingPerson(6, 4)\n   5",
      "hi": "एक वृत्ताकार गिनती खेल में अंतिम बचे हुए व्यक्ति की संख्या निर्धारित करें।\n   इस खेल में, लोगों को 1 से totalPeople तक क्रमांकित किया जाता है और वे एक वृत्त में बैठते हैं।\n   पहले व्यक्ति से शुरू होकर, वे 1 से countNumber तक गिनती करते हैं।\n   जो व्यक्ति countNumber पर होता है, उसे वृत्त से हटा दिया जाता है,\n   और गिनती अगले व्यक्ति से फिर से शुरू होती है।\n   यह प्रक्रिया तब तक चलती रहती है जब तक केवल एक व्यक्ति नहीं बचता।\n\n   उदाहरण:\n   >>> LastRemainingPerson(5, 2)\n   3\n   >>> LastRemainingPerson(6, 4)\n   5",
      "hu": "Határozza meg az utolsó megmaradt személy számát egy körkörös számolós játékban.\n   Ebben a játékban az embereket 1-től totalPeople-ig számozzák, és körben ülnek.\n   Az első személlyel kezdve 1-től countNumber-ig számolnak.\n   Az a személy, aki a countNumber-nél van, kikerül a körből,\n   és a számolás a következő személlyel folytatódik.\n   Ez a folyamat addig folytatódik, amíg csak egy személy marad.\n\n   Példa:\n   >>> LastRemainingPerson(5, 2)\n   3\n   >>> LastRemainingPerson(6, 4)\n   5"
    },
    "docstring_bertscore": {
      "sq": "0.9850220774876832",
      "hy": "0.9759877718670734",
      "bn": "0.9882585609162657",
      "bg": "0.9807247091939935",
      "zh": "0.9646491551960779",
      "fr": "0.9799427013838591",
      "de": "0.9778372193448892",
      "ha": "0.973754173232336",
      "hi": "0.9855822151622016",
      "hu": "0.9812365796859204"
    }
  },
  {
    "task_id": "C#/35",
    "prompt": {
      "en": "using System;\nusing System.Collections.Generic;\nusing System.Diagnostics;\nusing System.Numerics;\nclass Program\n{\n\n/* Determines the minimum number of steps required to convert a number into a palindrome in a given base (from 2 to 16). \n   The function takes an integer representing the base and a string representing the number in that base. \n   A palindrome is a number that reads the same forwards and backwards in the same base.\n   It calculates the number of steps required to reach a palindrome by repeatedly adding the number to its reverse in the given base.\n   If a palindrome is not obtained within 30 steps, it returns \"Impossible!\".\n\n   Example cases:\n   >>> StepsToPalindrome(10, \"56\")  // In base 10, \"56\" becomes palindrome \"121\" in 1 step\n   \"STEP=1\"\n   >>> StepsToPalindrome(9, \"87\")   // In base 9, \"87\" becomes palindrome \"4884\" in 6 steps\n   \"STEP=6\"\n   >>> StepsToPalindrome(2, \"1001\") \n   \"STEP=0\"\n\n*/\n    public static string StepsToPalindrome(int baseNum, string num)",
      "sq": "using System;\nusing System.Collections.Generic;\nusing System.Diagnostics;\nusing System.Numerics;\nclass Program\n{\n\n/* Përcakton numrin minimal të hapave të nevojshëm për të kthyer një numër në një palindrom në një bazë të caktuar (nga 2 në 16).\n   Funksioni merr një numër të plotë që përfaqëson bazën dhe një varg që përfaqëson numrin në atë bazë.\n   Një palindrom është një numër që lexohet njësoj përpara dhe prapa në të njëjtën bazë.\n   Ai llogarit numrin e hapave të nevojshëm për të arritur një palindrom duke shtuar në mënyrë të përsëritur numrin me të kundërtën e tij në bazën e dhënë.\n   Nëse një palindrom nuk arrihet brenda 30 hapave, ai kthen \"E pamundur!\".\n\n   Shembuj të rasteve:\n   >>> StepsToPalindrome(10, \"56\")  // Në bazën 10, \"56\" bëhet palindrom \"121\" në 1 hap\n   \"STEP=1\"\n   >>> StepsToPalindrome(9, \"87\")   // Në bazën 9, \"87\" bëhet palindrom \"4884\" në 6 hapa\n   \"STEP=6\"\n   >>> StepsToPalindrome(2, \"1001\") \n   \"STEP=0\"\n\n*/\n    public static string StepsToPalindrome(int baseNum, string num)",
      "hy": "using System;\nusing System.Collections.Generic;\nusing System.Diagnostics;\nusing System.Numerics;\nclass Program\n{\n\n/* Որոշում է նվազագույն քայլերի քանակը, որը պահանջվում է թիվը պալինդրոմի վերածելու համար տրված հիմքում (2-ից 16): \n   Ֆունկցիան ընդունում է հիմքը ներկայացնող ամբողջ թիվ և այդ հիմքում թիվը ներկայացնող տող: \n   Պալինդրոմը թիվ է, որը նույն կերպ է կարդացվում առաջ և հետ նույն հիմքում:\n   Այն հաշվարկում է պալինդրոմի հասնելու համար պահանջվող քայլերի քանակը՝ բազմիցս գումարելով թիվը իր հակադարձին տրված հիմքում:\n   Եթե 30 քայլի ընթացքում պալինդրոմ չի ստացվում, վերադարձնում է \"Impossible!\"։\n\n   Օրինակ դեպքեր:\n   >>> StepsToPalindrome(10, \"56\")  // Հիմք 10-ում, \"56\"-ը դառնում է պալինդրոմ \"121\" 1 քայլում\n   \"STEP=1\"\n   >>> StepsToPalindrome(9, \"87\")   // Հիմք 9-ում, \"87\"-ը դառնում է պալինդրոմ \"4884\" 6 քայլում\n   \"STEP=6\"\n   >>> StepsToPalindrome(2, \"1001\") \n   \"STEP=0\"\n\n*/\n    public static string StepsToPalindrome(int baseNum, string num)",
      "bn": "using System;\nusing System.Collections.Generic;\nusing System.Diagnostics;\nusing System.Numerics;\nclass Program\n{\n\n/* একটি নির্দিষ্ট ভিত্তিতে (২ থেকে ১৬ পর্যন্ত) একটি সংখ্যাকে প্যালিনড্রোমে রূপান্তর করার জন্য প্রয়োজনীয় সর্বনিম্ন পদক্ষেপ নির্ধারণ করে। \n   ফাংশনটি একটি পূর্ণসংখ্যা নেয় যা ভিত্তিকে উপস্থাপন করে এবং একটি স্ট্রিং নেয় যা সেই ভিত্তিতে সংখ্যাটিকে উপস্থাপন করে। \n   একটি প্যালিনড্রোম হল একটি সংখ্যা যা একই ভিত্তিতে সামনের দিক থেকে এবং পিছনের দিক থেকে একইভাবে পড়া যায়।\n   এটি প্রদত্ত ভিত্তিতে সংখ্যাটিকে তার বিপরীতের সাথে বারবার যোগ করার মাধ্যমে প্যালিনড্রোমে পৌঁছানোর জন্য প্রয়োজনীয় পদক্ষেপের সংখ্যা গণনা করে।\n   যদি ৩০ ধাপের মধ্যে একটি প্যালিনড্রোম পাওয়া না যায়, তবে এটি \"Impossible!\" ফেরত দেয়।\n\n   উদাহরণ কেস:\n   >>> StepsToPalindrome(10, \"56\")  // ভিত্তি ১০-এ, \"56\" এক ধাপে প্যালিনড্রোম \"121\" হয়ে যায়\n   \"STEP=1\"\n   >>> StepsToPalindrome(9, \"87\")   // ভিত্তি ৯-এ, \"87\" ছয় ধাপে প্যালিনড্রোম \"4884\" হয়ে যায়\n   \"STEP=6\"\n   >>> StepsToPalindrome(2, \"1001\") \n   \"STEP=0\"\n\n*/\n    public static string StepsToPalindrome(int baseNum, string num)",
      "bg": "using System;\nusing System.Collections.Generic;\nusing System.Diagnostics;\nusing System.Numerics;\nclass Program\n{\n\n/* Определя минималния брой стъпки, необходими за преобразуване на число в палиндром в дадена база (от 2 до 16). \n   Функцията приема цяло число, представляващо базата, и низ, представляващ числото в тази база. \n   Палиндром е число, което се чете еднакво напред и назад в същата база.\n   Изчислява броя на стъпките, необходими за достигане на палиндром, като многократно добавя числото към неговото обръщане в дадената база.\n   Ако палиндром не се получи в рамките на 30 стъпки, връща \"Невъзможно!\".\n\n   Примерни случаи:\n   >>> StepsToPalindrome(10, \"56\")  // В база 10, \"56\" става палиндром \"121\" в 1 стъпка\n   \"STEP=1\"\n   >>> StepsToPalindrome(9, \"87\")   // В база 9, \"87\" става палиндром \"4884\" в 6 стъпки\n   \"STEP=6\"\n   >>> StepsToPalindrome(2, \"1001\") \n   \"STEP=0\"\n\n*/\n    public static string StepsToPalindrome(int baseNum, string num)",
      "zh": "using System;\nusing System.Collections.Generic;\nusing System.Diagnostics;\nusing System.Numerics;\nclass Program\n{\n\n/* 确定将一个数字转换为给定进制（从2到16）回文所需的最小步骤数。\n   该函数接受一个表示进制的整数和一个表示该进制下数字的字符串。\n   回文是指在同一进制下正反读都相同的数字。\n   通过在给定进制下反复将数字与其反转相加，计算达到回文所需的步骤数。\n   如果在30步内未获得回文，则返回\"Impossible!\"。\n\n   示例案例：\n   >>> StepsToPalindrome(10, \"56\")  // 在10进制中，\"56\"在1步内变为回文\"121\"\n   \"STEP=1\"\n   >>> StepsToPalindrome(9, \"87\")   // 在9进制中，\"87\"在6步内变为回文\"4884\"\n   \"STEP=6\"\n   >>> StepsToPalindrome(2, \"1001\") \n   \"STEP=0\"\n\n*/\n    public static string StepsToPalindrome(int baseNum, string num)",
      "fr": "using System;\nusing System.Collections.Generic;\nusing System.Diagnostics;\nusing System.Numerics;\nclass Program\n{\n\n/* Détermine le nombre minimum d'étapes nécessaires pour convertir un nombre en palindrome dans une base donnée (de 2 à 16).\n   La fonction prend un entier représentant la base et une chaîne représentant le nombre dans cette base.\n   Un palindrome est un nombre qui se lit de la même manière de gauche à droite et de droite à gauche dans la même base.\n   Elle calcule le nombre d'étapes nécessaires pour atteindre un palindrome en ajoutant de manière répétée le nombre à son inverse dans la base donnée.\n   Si un palindrome n'est pas obtenu en 30 étapes, elle retourne \"Impossible!\".\n\n   Cas d'exemple :\n   >>> StepsToPalindrome(10, \"56\")  // En base 10, \"56\" devient le palindrome \"121\" en 1 étape\n   \"STEP=1\"\n   >>> StepsToPalindrome(9, \"87\")   // En base 9, \"87\" devient le palindrome \"4884\" en 6 étapes\n   \"STEP=6\"\n   >>> StepsToPalindrome(2, \"1001\") \n   \"STEP=0\"\n\n*/\n    public static string StepsToPalindrome(int baseNum, string num)",
      "de": "using System;\nusing System.Collections.Generic;\nusing System.Diagnostics;\nusing System.Numerics;\nclass Program\n{\n\n/* Bestimmt die minimale Anzahl von Schritten, die erforderlich sind, um eine Zahl in eine Palindromzahl in einer gegebenen Basis (von 2 bis 16) umzuwandeln.\n   Die Funktion nimmt eine ganze Zahl, die die Basis darstellt, und einen String, der die Zahl in dieser Basis darstellt.\n   Ein Palindrom ist eine Zahl, die vorwärts und rückwärts in derselben Basis gleich gelesen wird.\n   Sie berechnet die Anzahl der Schritte, die erforderlich sind, um ein Palindrom zu erreichen, indem die Zahl wiederholt zu ihrem Spiegelbild in der gegebenen Basis addiert wird.\n   Wenn innerhalb von 30 Schritten kein Palindrom erreicht wird, gibt sie \"Unmöglich!\" zurück.\n\n   Beispiel-Fälle:\n   >>> StepsToPalindrome(10, \"56\")  // In Basis 10 wird \"56\" in 1 Schritt zum Palindrom \"121\"\n   \"STEP=1\"\n   >>> StepsToPalindrome(9, \"87\")   // In Basis 9 wird \"87\" in 6 Schritten zum Palindrom \"4884\"\n   \"STEP=6\"\n   >>> StepsToPalindrome(2, \"1001\") \n   \"STEP=0\"\n\n*/\n    public static string StepsToPalindrome(int baseNum, string num)",
      "ha": "using System;\nusing System.Collections.Generic;\nusing System.Diagnostics;\nusing System.Numerics;\nclass Program\n{\n\n/* Yana tantance mafi ƙarancin adadin matakai da ake buƙata don canza lamba zuwa palindrome a cikin wata tushe (daga 2 zuwa 16).\n   Aikin yana ɗaukar cikakken lamba da ke wakiltar tushe da kuma kirtani da ke wakiltar lambar a cikin wannan tushe.\n   Palindrome lamba ce da ke karantawa iri ɗaya gaba da baya a cikin tushe ɗaya.\n   Yana ƙididdige adadin matakan da ake buƙata don kaiwa ga palindrome ta hanyar maimaita ƙara lambar zuwa akasin ta a cikin tushe da aka bayar.\n   Idan ba a sami palindrome ba cikin matakai 30, yana mayar da \"Impossible!\".\n\n   Misalan lamura:\n   >>> StepsToPalindrome(10, \"56\")  // A cikin tushe 10, \"56\" ya zama palindrome \"121\" a cikin mataki 1\n   \"STEP=1\"\n   >>> StepsToPalindrome(9, \"87\")   // A cikin tushe 9, \"87\" ya zama palindrome \"4884\" a cikin matakai 6\n   \"STEP=6\"\n   >>> StepsToPalindrome(2, \"1001\") \n   \"STEP=0\"\n\n*/\n    public static string StepsToPalindrome(int baseNum, string num)",
      "hi": "using System;\nusing System.Collections.Generic;\nusing System.Diagnostics;\nusing System.Numerics;\nclass Program\n{\n\n/* यह निर्धारित करता है कि किसी संख्या को दिए गए आधार (2 से 16 तक) में पलिंड्रोम में बदलने के लिए न्यूनतम कितने चरणों की आवश्यकता है।\n   यह फ़ंक्शन एक पूर्णांक लेता है जो आधार का प्रतिनिधित्व करता है और एक स्ट्रिंग लेता है जो उस आधार में संख्या का प्रतिनिधित्व करता है।\n   एक पलिंड्रोम वह संख्या होती है जो आगे और पीछे से एक ही आधार में समान पढ़ी जाती है।\n   यह दिए गए आधार में संख्या को उसके उल्टे में जोड़कर पलिंड्रोम तक पहुंचने के लिए आवश्यक चरणों की संख्या की गणना करता है।\n   यदि 30 चरणों के भीतर पलिंड्रोम प्राप्त नहीं होता है, तो यह \"Impossible!\" लौटाता है।\n\n   उदाहरण मामले:\n   >>> StepsToPalindrome(10, \"56\")  // आधार 10 में, \"56\" 1 चरण में पलिंड्रोम \"121\" बन जाता है\n   \"STEP=1\"\n   >>> StepsToPalindrome(9, \"87\")   // आधार 9 में, \"87\" 6 चरणों में पलिंड्रोम \"4884\" बन जाता है\n   \"STEP=6\"\n   >>> StepsToPalindrome(2, \"1001\") \n   \"STEP=0\"\n\n*/\n    public static string StepsToPalindrome(int baseNum, string num)",
      "hu": "using System;\nusing System.Collections.Generic;\nusing System.Diagnostics;\nusing System.Numerics;\nclass Program\n{\n\n/* Meghatározza a minimális lépések számát, amelyek szükségesek egy szám palindrómmá alakításához egy adott alapban (2-től 16-ig). \n   A függvény egy egész számot vesz fel, amely az alapot jelöli, és egy karakterláncot, amely a számot jelöli ebben az alapban. \n   Egy palindróm olyan szám, amely ugyanúgy olvasható előre és hátra ugyanabban az alapban.\n   Kiszámítja a lépések számát, amelyek szükségesek a palindróm eléréséhez úgy, hogy ismételten hozzáadja a számot a fordítottjához az adott alapban.\n   Ha 30 lépésen belül nem érhető el palindróm, akkor \"Lehetetlen!\"-t ad vissza.\n\n   Példa esetek:\n   >>> StepsToPalindrome(10, \"56\")  // 10-es alapban a \"56\" palindrómmá válik \"121\" 1 lépésben\n   \"STEP=1\"\n   >>> StepsToPalindrome(9, \"87\")   // 9-es alapban a \"87\" palindrómmá válik \"4884\" 6 lépésben\n   \"STEP=6\"\n   >>> StepsToPalindrome(2, \"1001\") \n   \"STEP=0\"\n\n*/\n    public static string StepsToPalindrome(int baseNum, string num)"
    },
    "prompt_bertscore": {
      "sq": "0.9972291061845633",
      "hy": "0.9864651272059017",
      "bn": "0.9879959715525376",
      "bg": "0.9908860435965952",
      "zh": "0.9821572315020171",
      "fr": "0.969466935088079",
      "de": "0.9850079747306297",
      "ha": "0.9890032262147654",
      "hi": "0.9928914159235234",
      "hu": "0.9884643419910178"
    },
    "canonical_solution": "    {\n        const int maxSteps = 30;\n        BigInteger originalNumber = ConvertToBase10(num, baseNum);\n\n        if (IsPalindrome(originalNumber, baseNum)){\n            return \"STEP=0\";\n        }\n\n        for (int step = 1; step <= maxSteps; step++)\n        {\n            BigInteger reversed = ReverseNumber(originalNumber, baseNum);\n            BigInteger sum = originalNumber + reversed;\n\n            if (IsPalindrome(sum, baseNum))\n            {\n                \n                Console.WriteLine($\"STEP={step}\");\n                return $\"STEP={step}\";\n            }\n\n            originalNumber = sum;\n        }\n\n        return \"Impossible!\";\n    }\n\n    private static BigInteger ConvertToBase10(string number, int baseNum)\n    {\n        return number\n            .Select(c => \"0123456789ABCDEF\".IndexOf(Char.ToUpper(c)))\n            .Aggregate(new BigInteger(0), (current, digit) => current * baseNum + digit);\n    }\n\n    private static string ConvertFromBase10(BigInteger number, int baseNum)\n    {\n        string result = \"\";\n        while (number > 0)\n        {\n            int remainder = (int)(number % baseNum);\n            result = \"0123456789ABCDEF\"[remainder] + result;\n            number /= baseNum;\n        }\n        return result == \"\" ? \"0\" : result;\n    }\n\n    private static BigInteger ReverseNumber(BigInteger number, int baseNum)\n    {\n        string reversedStr = new string(ConvertFromBase10(number, baseNum).Reverse().ToArray());\n        return ConvertToBase10(reversedStr, baseNum);\n    }\n\n    private static bool IsPalindrome(BigInteger number, int baseNum)\n    {\n        string numStr = ConvertFromBase10(number, baseNum);\n        return numStr.SequenceEqual(numStr.Reverse());\n    }",
    "instruction": {
      "en": "Write a C# function `public static string StepsToPalindrome(int baseNum, string num)` to solve the following problem:\nDetermines the minimum number of steps required to convert a number into a palindrome in a given base (from 2 to 16). \n   The function takes an integer representing the base and a string representing the number in that base. \n   A palindrome is a number that reads the same forwards and backwards in the same base.\n   It calculates the number of steps required to reach a palindrome by repeatedly adding the number to its reverse in the given base.\n   If a palindrome is not obtained within 30 steps, it returns \"Impossible!\".\n\n   Example cases:\n   >>> StepsToPalindrome(10, \"56\")  // In base 10, \"56\" becomes palindrome \"121\" in 1 step\n   \"STEP=1\"\n   >>> StepsToPalindrome(9, \"87\")   // In base 9, \"87\" becomes palindrome \"4884\" in 6 steps\n   \"STEP=6\"\n   >>> StepsToPalindrome(2, \"1001\") \n   \"STEP=0\"",
      "sq": "Shkruani një funksion C# `public static string StepsToPalindrome(int baseNum, string num)` për të zgjidhur problemin e mëposhtëm:\nPërcakton numrin minimal të hapave të nevojshëm për të kthyer një numër në një palindromë në një bazë të dhënë (nga 2 deri në 16). \n   Funksioni merr një numër të plotë që përfaqëson bazën dhe një varg që përfaqëson numrin në atë bazë. \n   Një palindromë është një numër që lexohet njësoj përpara dhe prapa në të njëjtën bazë.\n   Ai llogarit numrin e hapave të nevojshëm për të arritur një palindromë duke shtuar në mënyrë të përsëritur numrin me të kundërtën e tij në bazën e dhënë.\n   Nëse një palindromë nuk arrihet brenda 30 hapave, kthen \"E pamundur!\".\n\n   Shembuj rastesh:\n   >>> StepsToPalindrome(10, \"56\")  // Në bazën 10, \"56\" bëhet palindromë \"121\" në 1 hap\n   \"STEP=1\"\n   >>> StepsToPalindrome(9, \"87\")   // Në bazën 9, \"87\" bëhet palindromë \"4884\" në 6 hapa\n   \"STEP=6\"\n   >>> StepsToPalindrome(2, \"1001\") \n   \"STEP=0\"",
      "hy": "Գրեք C# ֆունկցիա `public static string StepsToPalindrome(int baseNum, string num)` հետևյալ խնդիրը լուծելու համար:\nՈրոշում է նվազագույն քայլերի քանակը, որը պահանջվում է թիվը պալինդրոմ դարձնելու համար տրված հիմքում (2-ից 16): \n   Ֆունկցիան ընդունում է ամբողջ թիվ, որը ներկայացնում է հիմքը, և տող, որը ներկայացնում է այդ հիմքում թիվը: \n   Պալինդրոմը թիվ է, որը նույն կերպ է կարդացվում առաջ և հետ նույն հիմքում:\n   Այն հաշվարկում է պալինդրոմի հասնելու համար պահանջվող քայլերի քանակը՝ բազմիցս գումարելով թիվը իր հակառակին տրված հիմքում:\n   Եթե պալինդրոմ չի ստացվում 30 քայլի ընթացքում, վերադարձնում է \"Impossible!\":\n\n   Օրինակ դեպքեր:\n   >>> StepsToPalindrome(10, \"56\")  // 10 հիմքում, \"56\"-ը դառնում է պալինդրոմ \"121\" 1 քայլում\n   \"STEP=1\"\n   >>> StepsToPalindrome(9, \"87\")   // 9 հիմքում, \"87\"-ը դառնում է պալինդրոմ \"4884\" 6 քայլում\n   \"STEP=6\"\n   >>> StepsToPalindrome(2, \"1001\") \n   \"STEP=0\"",
      "bn": "C# ফাংশন `public static string StepsToPalindrome(int baseNum, string num)` লিখুন নিম্নলিখিত সমস্যার সমাধানের জন্য:\nএকটি নির্দিষ্ট ভিত্তিতে (২ থেকে ১৬ পর্যন্ত) একটি সংখ্যাকে প্যালিনড্রোমে রূপান্তর করতে প্রয়োজনীয় সর্বনিম্ন ধাপ নির্ধারণ করে। \n   ফাংশনটি একটি পূর্ণসংখ্যা নেয় যা ভিত্তি নির্দেশ করে এবং একটি স্ট্রিং নেয় যা সেই ভিত্তিতে সংখ্যাকে নির্দেশ করে। \n   একটি প্যালিনড্রোম হল একটি সংখ্যা যা একই ভিত্তিতে সামনে এবং পিছনে একইভাবে পড়ে।\n   এটি প্রদত্ত ভিত্তিতে সংখ্যাটিকে তার বিপরীতের সাথে বারবার যোগ করে প্যালিনড্রোমে পৌঁছানোর জন্য প্রয়োজনীয় ধাপের সংখ্যা গণনা করে।\n   যদি ৩০ ধাপের মধ্যে প্যালিনড্রোম পাওয়া না যায়, এটি \"Impossible!\" ফেরত দেয়।\n\n   উদাহরণ কেস:\n   >>> StepsToPalindrome(10, \"56\")  // ভিত্তি ১০ এ, \"56\" প্যালিনড্রোম \"121\" এ ১ ধাপে পরিণত হয়\n   \"STEP=1\"\n   >>> StepsToPalindrome(9, \"87\")   // ভিত্তি ৯ এ, \"87\" প্যালিনড্রোম \"4884\" এ ৬ ধাপে পরিণত হয়\n   \"STEP=6\"\n   >>> StepsToPalindrome(2, \"1001\") \n   \"STEP=0\"",
      "bg": "Напишете C# функция `public static string StepsToPalindrome(int baseNum, string num)` за решаване на следния проблем:\nОпределя минималния брой стъпки, необходими за превръщане на число в палиндром в дадена база (от 2 до 16).\nФункцията приема цяло число, представляващо базата, и низ, представляващ числото в тази база.\nПалиндром е число, което се чете еднакво напред и назад в същата база.\nИзчислява броя на стъпките, необходими за достигане на палиндром, като многократно добавя числото към неговото обратно в дадената база.\nАко палиндром не се получи в рамките на 30 стъпки, връща \"Impossible!\".\n\nПримерни случаи:\n>>> StepsToPalindrome(10, \"56\")  // В база 10, \"56\" става палиндром \"121\" в 1 стъпка\n\"STEP=1\"\n>>> StepsToPalindrome(9, \"87\")   // В база 9, \"87\" става палиндром \"4884\" в 6 стъпки\n\"STEP=6\"\n>>> StepsToPalindrome(2, \"1001\") \n\"STEP=0\"",
      "zh": "编写一个 C# 函数 `public static string StepsToPalindrome(int baseNum, string num)` 来解决以下问题：\n确定在给定进制（从 2 到 16）中将一个数字转换为回文所需的最小步骤数。\n函数接受一个表示进制的整数和一个表示该进制中数字的字符串。\n回文是指在相同进制中正反读都相同的数字。\n通过在给定进制中不断将数字与其反转相加来计算达到回文所需的步骤数。\n如果在 30 步内未获得回文，则返回 \"Impossible!\"。\n\n示例案例：\n>>> StepsToPalindrome(10, \"56\")  // 在 10 进制中，\"56\" 在 1 步内变为回文 \"121\"\n\"STEP=1\"\n>>> StepsToPalindrome(9, \"87\")   // 在 9 进制中，\"87\" 在 6 步内变为回文 \"4884\"\n\"STEP=6\"\n>>> StepsToPalindrome(2, \"1001\") \n\"STEP=0\"",
      "fr": "Écrire une fonction C# `public static string StepsToPalindrome(int baseNum, string num)` pour résoudre le problème suivant :  \nDétermine le nombre minimum d'étapes nécessaires pour convertir un nombre en palindrome dans une base donnée (de 2 à 16).  \n   La fonction prend un entier représentant la base et une chaîne représentant le nombre dans cette base.  \n   Un palindrome est un nombre qui se lit de la même manière de gauche à droite et de droite à gauche dans la même base.  \n   Elle calcule le nombre d'étapes nécessaires pour atteindre un palindrome en ajoutant de manière répétée le nombre à son inverse dans la base donnée.  \n   Si un palindrome n'est pas obtenu en 30 étapes, elle renvoie \"Impossible!\".\n\n   Cas d'exemple :\n   >>> StepsToPalindrome(10, \"56\")  // En base 10, \"56\" devient le palindrome \"121\" en 1 étape\n   \"STEP=1\"\n   >>> StepsToPalindrome(9, \"87\")   // En base 9, \"87\" devient le palindrome \"4884\" en 6 étapes\n   \"STEP=6\"\n   >>> StepsToPalindrome(2, \"1001\") \n   \"STEP=0\"",
      "de": "Schreiben Sie eine C#-Funktion `public static string StepsToPalindrome(int baseNum, string num)`, um das folgende Problem zu lösen:\nBestimmt die minimale Anzahl von Schritten, die erforderlich sind, um eine Zahl in einem gegebenen Zahlensystem (von 2 bis 16) in ein Palindrom zu konvertieren. \n   Die Funktion nimmt eine Ganzzahl, die das Zahlensystem repräsentiert, und einen String, der die Zahl in diesem Zahlensystem darstellt. \n   Ein Palindrom ist eine Zahl, die vorwärts und rückwärts im selben Zahlensystem gleich gelesen wird.\n   Sie berechnet die Anzahl der Schritte, die erforderlich sind, um ein Palindrom zu erreichen, indem sie die Zahl wiederholt zu ihrer Umkehrung im gegebenen Zahlensystem addiert.\n   Wenn innerhalb von 30 Schritten kein Palindrom erreicht wird, gibt sie \"Impossible!\" zurück.\n\n   Beispielhafte Fälle:\n   >>> StepsToPalindrome(10, \"56\")  // Im Zahlensystem 10 wird \"56\" in 1 Schritt zum Palindrom \"121\"\n   \"STEP=1\"\n   >>> StepsToPalindrome(9, \"87\")   // Im Zahlensystem 9 wird \"87\" in 6 Schritten zum Palindrom \"4884\"\n   \"STEP=6\"\n   >>> StepsToPalindrome(2, \"1001\") \n   \"STEP=0\"",
      "ha": "Rubuta aikin C# `public static string StepsToPalindrome(int baseNum, string num)` don warware matsalar mai zuwa:\nYana tantance mafi ƙarancin adadin matakai da ake buƙata don canza lamba zuwa palindrome a cikin wata tushe da aka bayar (daga 2 zuwa 16). \n   Aikin yana ɗaukar cikakken lamba da ke wakiltar tushe da kuma igiyar da ke wakiltar lambar a cikin wannan tushe. \n   Palindrome lamba ce da ke karantawa iri ɗaya gaba da baya a cikin wannan tushe.\n   Yana ƙididdige adadin matakan da ake buƙata don kaiwa ga palindrome ta hanyar maimaita ƙara lambar zuwa akasin ta a cikin tushe da aka bayar.\n   Idan ba a sami palindrome ba cikin matakai 30, yana dawowa da \"Impossible!\".\n\n   Misalan harka:\n   >>> StepsToPalindrome(10, \"56\")  // A cikin tushe 10, \"56\" ya zama palindrome \"121\" a cikin mataki 1\n   \"STEP=1\"\n   >>> StepsToPalindrome(9, \"87\")   // A cikin tushe 9, \"87\" ya zama palindrome \"4884\" a cikin matakai 6\n   \"STEP=6\"\n   >>> StepsToPalindrome(2, \"1001\") \n   \"STEP=0\"",
      "hi": "C# फ़ंक्शन `public static string StepsToPalindrome(int baseNum, string num)` लिखें ताकि निम्नलिखित समस्या का समाधान किया जा सके:\nयह दिए गए आधार (2 से 16 तक) में किसी संख्या को पालिंड्रोम में बदलने के लिए आवश्यक न्यूनतम चरणों की संख्या निर्धारित करता है। \n   फ़ंक्शन एक पूर्णांक लेता है जो आधार का प्रतिनिधित्व करता है और एक स्ट्रिंग लेता है जो उस आधार में संख्या का प्रतिनिधित्व करता है। \n   एक पालिंड्रोम एक संख्या है जो उसी आधार में आगे और पीछे दोनों तरफ से पढ़ने पर समान होती है।\n   यह दिए गए आधार में संख्या को उसके उलटे के साथ बार-बार जोड़कर पालिंड्रोम तक पहुँचने के लिए आवश्यक चरणों की संख्या की गणना करता है।\n   यदि 30 चरणों के भीतर पालिंड्रोम प्राप्त नहीं होता है, तो यह \"Impossible!\" लौटाता है।\n\n   उदाहरण मामले:\n   >>> StepsToPalindrome(10, \"56\")  // आधार 10 में, \"56\" 1 चरण में पालिंड्रोम \"121\" बन जाता है\n   \"STEP=1\"\n   >>> StepsToPalindrome(9, \"87\")   // आधार 9 में, \"87\" 6 चरणों में पालिंड्रोम \"4884\" बन जाता है\n   \"STEP=6\"\n   >>> StepsToPalindrome(2, \"1001\") \n   \"STEP=0\"",
      "hu": "Írj egy C# függvényt `public static string StepsToPalindrome(int baseNum, string num)` a következő probléma megoldására:\nMeghatározza a minimális lépések számát, amely szükséges egy szám palindrómmá alakításához egy adott számrendszerben (2-től 16-ig).\n   A függvény egy egész számot vesz át, amely a számrendszert képviseli, és egy karakterláncot, amely a számot képviseli ebben a számrendszerben.\n   Egy palindróm olyan szám, amely előre és hátrafelé olvasva is ugyanaz a számrendszerben.\n   Kiszámítja a lépések számát, amely szükséges egy palindróm eléréséhez úgy, hogy ismételten hozzáadja a számot a fordítottjához az adott számrendszerben.\n   Ha 30 lépésen belül nem kapunk palindrómot, akkor \"Lehetetlen!\"-t ad vissza.\n\n   Példa esetek:\n   >>> StepsToPalindrome(10, \"56\")  // A 10-es számrendszerben a \"56\" 1 lépésben válik palindrómmá \"121\"\n   \"STEP=1\"\n   >>> StepsToPalindrome(9, \"87\")   // A 9-es számrendszerben a \"87\" 6 lépésben válik palindrómmá \"4884\"\n   \"STEP=6\"\n   >>> StepsToPalindrome(2, \"1001\") \n   \"STEP=0\""
    },
    "instruction_bertscore": {
      "sq": "0.9889988563463827",
      "hy": "0.9824376976000383",
      "bn": "0.9685822353709497",
      "bg": "0.9843129670273887",
      "zh": "0.9838698226472998",
      "fr": "0.9653022518889206",
      "de": "0.9389926647689445",
      "ha": "0.9803854485031859",
      "hi": "0.9820990328003738",
      "hu": "0.9455494536469061"
    },
    "level": "hard",
    "test": "    static void Main()\n    {\n\n        Debug.Assert(StepsToPalindrome(10, \"56\") == \"STEP=1\");\n        Debug.Assert(StepsToPalindrome(9, \"87\") == \"STEP=6\");\n        Debug.Assert(StepsToPalindrome(10, \"87\") == \"STEP=4\");\n        Debug.Assert(StepsToPalindrome(2, \"1001\") == \"STEP=0\"); // Already a palindrome\n        Debug.Assert(StepsToPalindrome(16, \"1A3\") == \"STEP=2\");\n\n\n    }\n}",
    "entry_point": "StepsToPalindrome",
    "signature": "public static string StepsToPalindrome(int baseNum, string num)",
    "docstring": {
      "en": "Determines the minimum number of steps required to convert a number into a palindrome in a given base (from 2 to 16). \n   The function takes an integer representing the base and a string representing the number in that base. \n   A palindrome is a number that reads the same forwards and backwards in the same base.\n   It calculates the number of steps required to reach a palindrome by repeatedly adding the number to its reverse in the given base.\n   If a palindrome is not obtained within 30 steps, it returns \"Impossible!\".\n\n   Example cases:\n   >>> StepsToPalindrome(10, \"56\")  // In base 10, \"56\" becomes palindrome \"121\" in 1 step\n   \"STEP=1\"\n   >>> StepsToPalindrome(9, \"87\")   // In base 9, \"87\" becomes palindrome \"4884\" in 6 steps\n   \"STEP=6\"\n   >>> StepsToPalindrome(2, \"1001\") \n   \"STEP=0\"",
      "sq": "Përcakton numrin minimal të hapave të nevojshëm për të kthyer një numër në një palindrom në një bazë të caktuar (nga 2 deri në 16). \n   Funksioni merr një numër të plotë që përfaqëson bazën dhe një varg që përfaqëson numrin në atë bazë. \n   Një palindrom është një numër që lexohet njësoj përpara dhe prapa në të njëjtën bazë.\n   Ai llogarit numrin e hapave të nevojshëm për të arritur një palindrom duke shtuar në mënyrë të përsëritur numrin me të kundërtën e tij në bazën e dhënë.\n   Nëse një palindrom nuk arrihet brenda 30 hapave, kthen \"E pamundur!\".\n\n   Shembuj rastesh:\n   >>> StepsToPalindrome(10, \"56\")  // Në bazën 10, \"56\" bëhet palindrom \"121\" në 1 hap\n   \"STEP=1\"\n   >>> StepsToPalindrome(9, \"87\")   // Në bazën 9, \"87\" bëhet palindrom \"4884\" në 6 hapa\n   \"STEP=6\"\n   >>> StepsToPalindrome(2, \"1001\") \n   \"STEP=0\"",
      "hy": "Սահմանում է նվազագույն քայլերի քանակը, որը պահանջվում է թիվը պալինդրոմ դարձնելու համար տրված հիմքում (2-ից 16): \n   Ֆունկցիան ընդունում է ամբողջ թիվ, որը ներկայացնում է հիմքը և տող, որը ներկայացնում է թիվը այդ հիմքում: \n   Պալինդրոմը թիվ է, որը նույն կերպ է կարդացվում առաջ և հետ նույն հիմքում:\n   Այն հաշվարկում է պալինդրոմի հասնելու համար պահանջվող քայլերի քանակը՝ բազմիցս գումարելով թիվը իր հակադարձին տրված հիմքում:\n   Եթե պալինդրոմ չի ստացվում 30 քայլի ընթացքում, այն վերադարձնում է \"Անհնար է!\":\n\n   Օրինակ դեպքեր:\n   >>> StepsToPalindrome(10, \"56\")  // 10 հիմքում, \"56\"-ը դառնում է պալինդրոմ \"121\" 1 քայլում\n   \"STEP=1\"\n   >>> StepsToPalindrome(9, \"87\")   // 9 հիմքում, \"87\"-ը դառնում է պալինդրոմ \"4884\" 6 քայլում\n   \"STEP=6\"\n   >>> StepsToPalindrome(2, \"1001\") \n   \"STEP=0\"",
      "bn": "একটি নির্দিষ্ট ভিত্তিতে (২ থেকে ১৬ পর্যন্ত) একটি সংখ্যাকে প্যালিনড্রোমে রূপান্তর করতে প্রয়োজনীয় সর্বনিম্ন ধাপ নির্ধারণ করে। \n   ফাংশনটি একটি পূর্ণসংখ্যা নেয় যা ভিত্তি উপস্থাপন করে এবং একটি স্ট্রিং নেয় যা সেই ভিত্তিতে সংখ্যাকে উপস্থাপন করে। \n   একটি প্যালিনড্রোম হল একটি সংখ্যা যা একই ভিত্তিতে সামনে এবং পিছনে একইভাবে পড়া যায়।\n   এটি প্রদত্ত ভিত্তিতে সংখ্যাটিকে তার বিপরীতের সাথে যোগ করে প্যালিনড্রোমে পৌঁছানোর জন্য প্রয়োজনীয় ধাপের সংখ্যা গণনা করে।\n   যদি ৩০ ধাপের মধ্যে একটি প্যালিনড্রোম পাওয়া না যায়, তবে এটি \"Impossible!\" ফেরত দেয়।\n\n   উদাহরণ কেস:\n   >>> StepsToPalindrome(10, \"56\")  // ভিত্তি ১০ এ, \"56\" এক ধাপে প্যালিনড্রোম \"121\" হয়ে যায়\n   \"STEP=1\"\n   >>> StepsToPalindrome(9, \"87\")   // ভিত্তি ৯ এ, \"87\" ৬ ধাপে প্যালিনড্রোম \"4884\" হয়ে যায়\n   \"STEP=6\"\n   >>> StepsToPalindrome(2, \"1001\") \n   \"STEP=0\"",
      "bg": "Определя минималния брой стъпки, необходими за преобразуване на число в палиндром в дадена база (от 2 до 16). \nФункцията приема цяло число, представляващо базата, и низ, представляващ числото в тази база. \nПалиндром е число, което се чете еднакво напред и назад в същата база.\nИзчислява броя на стъпките, необходими за достигане на палиндром, като многократно добавя числото към неговото обратно в дадената база.\nАко палиндром не бъде получен в рамките на 30 стъпки, връща \"Impossible!\".\n\nПримерни случаи:\n>>> StepsToPalindrome(10, \"56\")  // В база 10, \"56\" става палиндром \"121\" в 1 стъпка\n\"STEP=1\"\n>>> StepsToPalindrome(9, \"87\")   // В база 9, \"87\" става палиндром \"4884\" в 6 стъпки\n\"STEP=6\"\n>>> StepsToPalindrome(2, \"1001\") \n\"STEP=0\"",
      "zh": "确定将一个数字转换为给定进制（从2到16）下的回文所需的最小步骤数。\n该函数接受一个表示进制的整数和一个表示该进制下数字的字符串。\n回文是在相同进制下正反读都相同的数字。\n它通过在给定进制下反复将数字与其反转相加来计算达到回文所需的步骤数。\n如果在30步内没有得到回文，则返回\"Impossible!\"。\n\n示例案例：\n>>> StepsToPalindrome(10, \"56\")  // 在10进制中，\"56\"在1步内变成回文\"121\"\n\"STEP=1\"\n>>> StepsToPalindrome(9, \"87\")   // 在9进制中，\"87\"在6步内变成回文\"4884\"\n\"STEP=6\"\n>>> StepsToPalindrome(2, \"1001\") \n\"STEP=0\"",
      "fr": "Détermine le nombre minimum d'étapes nécessaires pour convertir un nombre en un palindrome dans une base donnée (de 2 à 16). \n   La fonction prend un entier représentant la base et une chaîne représentant le nombre dans cette base. \n   Un palindrome est un nombre qui se lit de la même manière de gauche à droite et de droite à gauche dans la même base.\n   Elle calcule le nombre d'étapes nécessaires pour atteindre un palindrome en ajoutant de manière répétée le nombre à son inverse dans la base donnée.\n   Si un palindrome n'est pas obtenu en 30 étapes, elle renvoie \"Impossible!\".\n\n   Cas d'exemple :\n   >>> StepsToPalindrome(10, \"56\")  // En base 10, \"56\" devient le palindrome \"121\" en 1 étape\n   \"STEP=1\"\n   >>> StepsToPalindrome(9, \"87\")   // En base 9, \"87\" devient le palindrome \"4884\" en 6 étapes\n   \"STEP=6\"\n   >>> StepsToPalindrome(2, \"1001\") \n   \"STEP=0\"",
      "de": "Bestimmt die minimale Anzahl von Schritten, die erforderlich sind, um eine Zahl in eine Palindromzahl in einer gegebenen Basis (von 2 bis 16) umzuwandeln. \n   Die Funktion nimmt eine ganze Zahl, die die Basis darstellt, und einen String, der die Zahl in dieser Basis darstellt. \n   Ein Palindrom ist eine Zahl, die vorwärts und rückwärts in derselben Basis gleich gelesen wird.\n   Sie berechnet die Anzahl der Schritte, die erforderlich sind, um ein Palindrom zu erreichen, indem sie wiederholt die Zahl zu ihrer Umkehrung in der gegebenen Basis addiert.\n   Wenn innerhalb von 30 Schritten kein Palindrom erreicht wird, gibt sie \"Unmöglich!\" zurück.\n\n   Beispielhafte Fälle:\n   >>> StepsToPalindrome(10, \"56\")  // In Basis 10 wird \"56\" in 1 Schritt zum Palindrom \"121\"\n   \"STEP=1\"\n   >>> StepsToPalindrome(9, \"87\")   // In Basis 9 wird \"87\" in 6 Schritten zum Palindrom \"4884\"\n   \"STEP=6\"\n   >>> StepsToPalindrome(2, \"1001\") \n   \"STEP=0\"",
      "ha": "Yana tantance mafi ƙarancin adadin matakai da ake buƙata don canza lamba zuwa palindrome a cikin wata tushe (daga 2 zuwa 16). \n   Aikin yana ɗaukar lamba mai nuni da tushe da kuma kirtani mai nuni da lambar a cikin wannan tushe. \n   Palindrome lamba ce da ake karantawa iri ɗaya a gaba da baya a cikin wannan tushe.\n   Yana ƙididdige adadin matakan da ake buƙata don isa ga palindrome ta hanyar ƙara lambar zuwa juyinta a cikin tushe da aka bayar.\n   Idan ba a sami palindrome ba cikin matakai 30, yana dawowa da \"Impossible!\".\n\n   Misalan lamura:\n   >>> StepsToPalindrome(10, \"56\")  // A cikin tushe 10, \"56\" ya zama palindrome \"121\" a cikin mataki 1\n   \"STEP=1\"\n   >>> StepsToPalindrome(9, \"87\")   // A cikin tushe 9, \"87\" ya zama palindrome \"4884\" a cikin matakai 6\n   \"STEP=6\"\n   >>> StepsToPalindrome(2, \"1001\") \n   \"STEP=0\"",
      "hi": "दिए गए आधार (2 से 16 तक) में किसी संख्या को पालिंड्रोम में बदलने के लिए आवश्यक न्यूनतम चरणों की गणना करता है। \n   यह फ़ंक्शन एक पूर्णांक लेता है जो आधार का प्रतिनिधित्व करता है और एक स्ट्रिंग लेता है जो उस आधार में संख्या का प्रतिनिधित्व करती है। \n   एक पालिंड्रोम वह संख्या है जो उसी आधार में आगे और पीछे से पढ़ने पर समान होती है।\n   यह दिए गए आधार में संख्या को उसके उलट के साथ बार-बार जोड़कर पालिंड्रोम तक पहुंचने के लिए आवश्यक चरणों की संख्या की गणना करता है।\n   यदि 30 चरणों के भीतर पालिंड्रोम प्राप्त नहीं होता है, तो यह \"Impossible!\" लौटाता है।\n\n   उदाहरण मामले:\n   >>> StepsToPalindrome(10, \"56\")  // आधार 10 में, \"56\" 1 चरण में पालिंड्रोम \"121\" बन जाता है\n   \"STEP=1\"\n   >>> StepsToPalindrome(9, \"87\")   // आधार 9 में, \"87\" 6 चरणों में पालिंड्रोम \"4884\" बन जाता है\n   \"STEP=6\"\n   >>> StepsToPalindrome(2, \"1001\") \n   \"STEP=0\"",
      "hu": "Meghatározza a minimális lépések számát, amelyek szükségesek egy szám palindrómmá alakításához egy adott számrendszerben (2-től 16-ig).\n   A függvény egy egész számot vesz, amely a számrendszert jelöli, és egy karakterláncot, amely a számot jelöli ebben a számrendszerben.\n   A palindróm olyan szám, amely előre és hátrafelé olvasva is ugyanaz a számrendszerben.\n   Kiszámítja a lépések számát, amelyek szükségesek a palindróm eléréséhez úgy, hogy ismételten hozzáadja a számot a fordítottjához az adott számrendszerben.\n   Ha 30 lépésen belül nem kapunk palindrómot, akkor \"Lehetetlen!\"-t ad vissza.\n\n   Példa esetek:\n   >>> StepsToPalindrome(10, \"56\")  // 10-es számrendszerben a \"56\" 1 lépésben palindrómmá \"121\" válik\n   \"STEP=1\"\n   >>> StepsToPalindrome(9, \"87\")   // 9-es számrendszerben a \"87\" 6 lépésben palindrómmá \"4884\" válik\n   \"STEP=6\"\n   >>> StepsToPalindrome(2, \"1001\") \n   \"STEP=0\""
    },
    "docstring_bertscore": {
      "sq": "0.9942391230588451",
      "hy": "0.9753457984755687",
      "bn": "0.9739357214006019",
      "bg": "0.9914465785318757",
      "zh": "0.988169375875181",
      "fr": "0.9623124673935834",
      "de": "0.9879618071269995",
      "ha": "0.9588624563053885",
      "hi": "0.9810323876542164",
      "hu": "0.9322571085480514"
    }
  },
  {
    "task_id": "C#/36",
    "prompt": {
      "en": "using System;\nusing System.Collections.Generic;\nusing System.Diagnostics;\n\nclass Program\n{\n\n/* Determines if a given password is secure based on specific criteria.\n   A secure password must:\n   1. Be at least 8 characters long and no more than 16 characters.\n   2. Include characters from at least three of the following categories:\n      - Uppercase letters (A-Z)\n      - Lowercase letters (a-z)\n      - Numbers (0-9)\n      - Special symbols (~, !, @, #, $, %, ^)\n\n   Examples:\n   >>> IsPasswordSecure(\"Password123!\")\n   \"YES\"\n   >>> IsPasswordSecure(\"short\")\n   \"NO\"\n   >>> IsPasswordSecure(\"LongPasswordWithoutNumbersOrSymbols\")\n   \"NO\"\n*/\nstatic string IsPasswordSecure(string password)",
      "sq": "using System;\nusing System.Collections.Generic;\nusing System.Diagnostics;\n\nclass Program\n{\n\n/* Përcakton nëse një fjalëkalim i dhënë është i sigurt bazuar në kritere specifike.\n   Një fjalëkalim i sigurt duhet:\n   1. Të jetë të paktën 8 karaktere i gjatë dhe jo më shumë se 16 karaktere.\n   2. Të përfshijë karaktere nga të paktën tre nga kategoritë e mëposhtme:\n      - Shkronja të mëdha (A-Z)\n      - Shkronja të vogla (a-z)\n      - Numra (0-9)\n      - Simbole speciale (~, !, @, #, $, %, ^)\n\n   Shembuj:\n   >>> IsPasswordSecure(\"Password123!\")\n   \"YES\"\n   >>> IsPasswordSecure(\"short\")\n   \"NO\"\n   >>> IsPasswordSecure(\"LongPasswordWithoutNumbersOrSymbols\")\n   \"NO\"\n*/\nstatic string IsPasswordSecure(string password)",
      "hy": "using System;\nusing System.Collections.Generic;\nusing System.Diagnostics;\n\nclass Program\n{\n\n/* Սահմանում է, արդյոք տրված գաղտնաբառը անվտանգ է որոշակի չափանիշների հիման վրա:\n   Անվտանգ գաղտնաբառը պետք է.\n   1. Լինի առնվազն 8 նիշ երկարությամբ և ոչ ավելի, քան 16 նիշ:\n   2. Ներառի նիշեր առնվազն հետևյալ երեք կատեգորիաներից.\n      - Մեծատառեր (A-Z)\n      - Փոքրատառեր (a-z)\n      - Թվեր (0-9)\n      - Հատուկ սիմվոլներ (~, !, @, #, $, %, ^)\n\n   Օրինակներ:\n   >>> IsPasswordSecure(\"Password123!\")\n   \"YES\"\n   >>> IsPasswordSecure(\"short\")\n   \"NO\"\n   >>> IsPasswordSecure(\"LongPasswordWithoutNumbersOrSymbols\")\n   \"NO\"\n*/\nstatic string IsPasswordSecure(string password)",
      "bn": "using System;\nusing System.Collections.Generic;\nusing System.Diagnostics;\n\nclass Program\n{\n\n/* একটি প্রদত্ত পাসওয়ার্ড নির্দিষ্ট মানদণ্ডের ভিত্তিতে সুরক্ষিত কিনা তা নির্ধারণ করে।\n   একটি সুরক্ষিত পাসওয়ার্ড অবশ্যই:\n   1. কমপক্ষে 8 অক্ষর দীর্ঘ এবং সর্বাধিক 16 অক্ষর হতে হবে।\n   2. নিম্নলিখিত বিভাগগুলির মধ্যে অন্তত তিনটি থেকে অক্ষর অন্তর্ভুক্ত করতে হবে:\n      - বড় হাতের অক্ষর (A-Z)\n      - ছোট হাতের অক্ষর (a-z)\n      - সংখ্যা (0-9)\n      - বিশেষ প্রতীক (~, !, @, #, $, %, ^)\n\n   উদাহরণ:\n   >>> IsPasswordSecure(\"Password123!\")\n   \"YES\"\n   >>> IsPasswordSecure(\"short\")\n   \"NO\"\n   >>> IsPasswordSecure(\"LongPasswordWithoutNumbersOrSymbols\")\n   \"NO\"\n*/\nstatic string IsPasswordSecure(string password)",
      "bg": "using System;\nusing System.Collections.Generic;\nusing System.Diagnostics;\n\nclass Program\n{\n\n/* Определя дали дадена парола е сигурна въз основа на специфични критерии.\n   Сигурната парола трябва да:\n   1. Бъде поне 8 символа дълга и не повече от 16 символа.\n   2. Включва символи от поне три от следните категории:\n      - Главни букви (A-Z)\n      - Малки букви (a-z)\n      - Цифри (0-9)\n      - Специални символи (~, !, @, #, $, %, ^)\n\n   Примери:\n   >>> IsPasswordSecure(\"Password123!\")\n   \"YES\"\n   >>> IsPasswordSecure(\"short\")\n   \"NO\"\n   >>> IsPasswordSecure(\"LongPasswordWithoutNumbersOrSymbols\")\n   \"NO\"\n*/\nstatic string IsPasswordSecure(string password)",
      "zh": "using System;\nusing System.Collections.Generic;\nusing System.Diagnostics;\n\nclass Program\n{\n\n/* 判断给定的密码是否基于特定标准是安全的。\n   一个安全的密码必须：\n   1. 长度至少为8个字符且不超过16个字符。\n   2. 包含至少以下三类字符：\n      - 大写字母 (A-Z)\n      - 小写字母 (a-z)\n      - 数字 (0-9)\n      - 特殊符号 (~, !, @, #, $, %, ^)\n\n   示例:\n   >>> IsPasswordSecure(\"Password123!\")\n   \"YES\"\n   >>> IsPasswordSecure(\"short\")\n   \"NO\"\n   >>> IsPasswordSecure(\"LongPasswordWithoutNumbersOrSymbols\")\n   \"NO\"\n*/\nstatic string IsPasswordSecure(string password)",
      "fr": "using System;\nusing System.Collections.Generic;\nusing System.Diagnostics;\n\nclass Program\n{\n\n/* Détermine si un mot de passe donné est sécurisé en fonction de critères spécifiques.\n   Un mot de passe sécurisé doit :\n   1. Contenir au moins 8 caractères et pas plus de 16 caractères.\n   2. Inclure des caractères provenant d'au moins trois des catégories suivantes :\n      - Lettres majuscules (A-Z)\n      - Lettres minuscules (a-z)\n      - Nombres (0-9)\n      - Symboles spéciaux (~, !, @, #, $, %, ^)\n\n   Exemples :\n   >>> IsPasswordSecure(\"Password123!\")\n   \"YES\"\n   >>> IsPasswordSecure(\"short\")\n   \"NO\"\n   >>> IsPasswordSecure(\"LongPasswordWithoutNumbersOrSymbols\")\n   \"NO\"\n*/\nstatic string IsPasswordSecure(string password)",
      "de": "using System;\nusing System.Collections.Generic;\nusing System.Diagnostics;\n\nclass Program\n{\n\n/* Bestimmt, ob ein gegebenes Passwort basierend auf spezifischen Kriterien sicher ist.\n   Ein sicheres Passwort muss:\n   1. Mindestens 8 Zeichen lang und nicht mehr als 16 Zeichen sein.\n   2. Zeichen aus mindestens drei der folgenden Kategorien enthalten:\n      - Großbuchstaben (A-Z)\n      - Kleinbuchstaben (a-z)\n      - Zahlen (0-9)\n      - Spezielle Symbole (~, !, @, #, $, %, ^)\n\n   Beispiele:\n   >>> IsPasswordSecure(\"Password123!\")\n   \"YES\"\n   >>> IsPasswordSecure(\"short\")\n   \"NO\"\n   >>> IsPasswordSecure(\"LongPasswordWithoutNumbersOrSymbols\")\n   \"NO\"\n*/\nstatic string IsPasswordSecure(string password)",
      "ha": "using System;\nusing System.Collections.Generic;\nusing System.Diagnostics;\n\nclass Program\n{\n\n/* Yana tantancewa idan kalmar sirri da aka bayar tana da tsaro bisa wasu ka'idoji na musamman.\n   Kalmar sirri mai tsaro dole ne:\n   1. Ta kasance aƙalla tana da tsawon haruffa 8 kuma ba fiye da haruffa 16 ba.\n   2. Ta haɗa da haruffa daga aƙalla rukuni uku daga cikin waɗannan:\n      - Manyan haruffa (A-Z)\n      - Ƙananan haruffa (a-z)\n      - Lambobi (0-9)\n      - Alamomin musamman (~, !, @, #, $, %, ^)\n\n   Misalai:\n   >>> IsPasswordSecure(\"Password123!\")\n   \"YES\"\n   >>> IsPasswordSecure(\"short\")\n   \"NO\"\n   >>> IsPasswordSecure(\"LongPasswordWithoutNumbersOrSymbols\")\n   \"NO\"\n*/\nstatic string IsPasswordSecure(string password)",
      "hi": "using System;\nusing System.Collections.Generic;\nusing System.Diagnostics;\n\nclass Program\n{\n\n/* यह निर्धारित करता है कि दिया गया पासवर्ड विशिष्ट मानदंडों के आधार पर सुरक्षित है या नहीं।\n   एक सुरक्षित पासवर्ड को निम्नलिखित मानदंडों को पूरा करना चाहिए:\n   1. कम से कम 8 वर्ण लंबा और अधिकतम 16 वर्ण होना चाहिए।\n   2. निम्नलिखित श्रेणियों में से कम से कम तीन से वर्ण शामिल होना चाहिए:\n      - अपरकेस अक्षर (A-Z)\n      - लोअरकेस अक्षर (a-z)\n      - संख्याएँ (0-9)\n      - विशेष प्रतीक (~, !, @, #, $, %, ^)\n\n   उदाहरण:\n   >>> IsPasswordSecure(\"Password123!\")\n   \"YES\"\n   >>> IsPasswordSecure(\"short\")\n   \"NO\"\n   >>> IsPasswordSecure(\"LongPasswordWithoutNumbersOrSymbols\")\n   \"NO\"\n*/\nstatic string IsPasswordSecure(string password)",
      "hu": "using System;\nusing System.Collections.Generic;\nusing System.Diagnostics;\n\nclass Program\n{\n\n/* Meghatározza, hogy egy adott jelszó biztonságos-e a megadott kritériumok alapján.\n   Egy biztonságos jelszónak meg kell felelnie a következőknek:\n   1. Legalább 8 karakter hosszúnak kell lennie, de nem lehet hosszabb 16 karakternél.\n   2. Tartalmaznia kell karaktereket legalább három az alábbi kategóriák közül:\n      - Nagybetűk (A-Z)\n      - Kisbetűk (a-z)\n      - Számok (0-9)\n      - Speciális szimbólumok (~, !, @, #, $, %, ^)\n\n   Példák:\n   >>> IsPasswordSecure(\"Password123!\")\n   \"YES\"\n   >>> IsPasswordSecure(\"short\")\n   \"NO\"\n   >>> IsPasswordSecure(\"LongPasswordWithoutNumbersOrSymbols\")\n   \"NO\"\n*/\nstatic string IsPasswordSecure(string password)"
    },
    "prompt_bertscore": {
      "sq": "0.999999801369619",
      "hy": "0.9942881847629608",
      "bn": "0.9891490209144451",
      "bg": "0.9919048188209232",
      "zh": "0.981804265314918",
      "fr": "0.9938839719375547",
      "de": "0.9948012470371739",
      "ha": "0.9892185415478073",
      "hi": "0.9687617972354052",
      "hu": "0.9731251108155986"
    },
    "canonical_solution": "{\n    if (password.Length < 8 || password.Length > 16)\n        return \"NO\";\n\n    bool hasUpper = false, hasLower = false, hasDigit = false, hasSymbol = false;\n    foreach (char c in password)\n    {\n        if (char.IsUpper(c)) hasUpper = true;\n        else if (char.IsLower(c)) hasLower = true;\n        else if (char.IsDigit(c)) hasDigit = true;\n        else if (\"~!@#$%^\".Contains(c)) hasSymbol = true;\n    }\n\n    int categories = (hasUpper ? 1 : 0) + (hasLower ? 1 : 0) + (hasDigit ? 1 : 0) + (hasSymbol ? 1 : 0);\n    return categories >= 3 ? \"YES\" : \"NO\";\n}",
    "instruction": {
      "en": "Write a C# function `static string IsPasswordSecure(string password)` to solve the following problem:\nDetermines if a given password is secure based on specific criteria.\n   A secure password must:\n   1. Be at least 8 characters long and no more than 16 characters.\n   2. Include characters from at least three of the following categories:\n      - Uppercase letters (A-Z)\n      - Lowercase letters (a-z)\n      - Numbers (0-9)\n      - Special symbols (~, !, @, #, $, %, ^)\n\n   Examples:\n   >>> IsPasswordSecure(\"Password123!\")\n   \"YES\"\n   >>> IsPasswordSecure(\"short\")\n   \"NO\"\n   >>> IsPasswordSecure(\"LongPasswordWithoutNumbersOrSymbols\")\n   \"NO\"",
      "sq": "Shkruani një funksion në C# `static string IsPasswordSecure(string password)` për të zgjidhur problemin e mëposhtëm:  \nPërcakton nëse një fjalëkalim i dhënë është i sigurt bazuar në kritere specifike.  \n   Një fjalëkalim i sigurt duhet të:  \n   1. Jetë të paktën 8 karaktere i gjatë dhe jo më shumë se 16 karaktere.  \n   2. Përfshijë karaktere nga të paktën tre nga kategoritë e mëposhtme:  \n      - Shkronja të mëdha (A-Z)  \n      - Shkronja të vogla (a-z)  \n      - Numra (0-9)  \n      - Simbole speciale (~, !, @, #, $, %, ^)  \n\n   Shembuj:  \n   >>> IsPasswordSecure(\"Password123!\")  \n   \"YES\"  \n   >>> IsPasswordSecure(\"short\")  \n   \"NO\"  \n   >>> IsPasswordSecure(\"LongPasswordWithoutNumbersOrSymbols\")  \n   \"NO\"",
      "hy": "Գրեք C# ֆունկցիա `static string IsPasswordSecure(string password)`՝ հետևյալ խնդիրը լուծելու համար: \nՍահմանում է, արդյոք տրված գաղտնաբառը անվտանգ է որոշակի չափանիշների հիման վրա:\n   Անվտանգ գաղտնաբառը պետք է՝\n   1. Լինի առնվազն 8 նիշ երկարությամբ և ոչ ավելի, քան 16 նիշ:\n   2. Ներառի նիշեր առնվազն հետևյալ երեք կատեգորիաներից՝\n      - Մեծատառեր (A-Z)\n      - Փոքրատառեր (a-z)\n      - Թվեր (0-9)\n      - Հատուկ սիմվոլներ (~, !, @, #, $, %, ^)\n\n   Օրինակներ:\n   >>> IsPasswordSecure(\"Password123!\")\n   \"YES\"\n   >>> IsPasswordSecure(\"short\")\n   \"NO\"\n   >>> IsPasswordSecure(\"LongPasswordWithoutNumbersOrSymbols\")\n   \"NO\"",
      "bn": "C# ফাংশন `static string IsPasswordSecure(string password)` লিখুন নিম্নলিখিত সমস্যার সমাধানের জন্য:\nনির্দিষ্ট মানদণ্ডের ভিত্তিতে একটি প্রদত্ত পাসওয়ার্ড নিরাপদ কিনা তা নির্ধারণ করে।\n   একটি নিরাপদ পাসওয়ার্ড অবশ্যই:\n   1. কমপক্ষে 8 অক্ষর দীর্ঘ এবং সর্বাধিক 16 অক্ষর হতে হবে।\n   2. নিম্নলিখিত বিভাগগুলির মধ্যে অন্তত তিনটি থেকে অক্ষর অন্তর্ভুক্ত করতে হবে:\n      - বড় হাতের অক্ষর (A-Z)\n      - ছোট হাতের অক্ষর (a-z)\n      - সংখ্যা (0-9)\n      - বিশেষ প্রতীক (~, !, @, #, $, %, ^)\n\n   উদাহরণ:\n   >>> IsPasswordSecure(\"Password123!\")\n   \"YES\"\n   >>> IsPasswordSecure(\"short\")\n   \"NO\"\n   >>> IsPasswordSecure(\"LongPasswordWithoutNumbersOrSymbols\")\n   \"NO\"",
      "bg": "Напишете C# функция `static string IsPasswordSecure(string password)`, за да решите следния проблем:\nОпределя дали дадена парола е сигурна въз основа на специфични критерии.\n   Сигурната парола трябва да:\n   1. Бъде поне 8 символа дълга и не повече от 16 символа.\n   2. Включва символи от поне три от следните категории:\n      - Главни букви (A-Z)\n      - Малки букви (a-z)\n      - Числа (0-9)\n      - Специални символи (~, !, @, #, $, %, ^)\n\n   Примери:\n   >>> IsPasswordSecure(\"Password123!\")\n   \"YES\"\n   >>> IsPasswordSecure(\"short\")\n   \"NO\"\n   >>> IsPasswordSecure(\"LongPasswordWithoutNumbersOrSymbols\")\n   \"NO\"",
      "zh": "编写一个 C# 函数 `static string IsPasswordSecure(string password)` 来解决以下问题：\n确定给定的密码是否基于特定标准是安全的。\n   一个安全的密码必须：\n   1. 至少包含8个字符且不超过16个字符。\n   2. 包含以下至少三类字符：\n      - 大写字母 (A-Z)\n      - 小写字母 (a-z)\n      - 数字 (0-9)\n      - 特殊符号 (~, !, @, #, $, %, ^)\n\n   示例：\n   >>> IsPasswordSecure(\"Password123!\")\n   \"YES\"\n   >>> IsPasswordSecure(\"short\")\n   \"NO\"\n   >>> IsPasswordSecure(\"LongPasswordWithoutNumbersOrSymbols\")\n   \"NO\"",
      "fr": "Écrire une fonction C# `static string IsPasswordSecure(string password)` pour résoudre le problème suivant :\nDétermine si un mot de passe donné est sécurisé en fonction de critères spécifiques.\n   Un mot de passe sécurisé doit :\n   1. Être d'au moins 8 caractères et d'au plus 16 caractères.\n   2. Inclure des caractères d'au moins trois des catégories suivantes :\n      - Lettres majuscules (A-Z)\n      - Lettres minuscules (a-z)\n      - Nombres (0-9)\n      - Symboles spéciaux (~, !, @, #, $, %, ^)\n\n   Exemples :\n   >>> IsPasswordSecure(\"Password123!\")\n   \"YES\"\n   >>> IsPasswordSecure(\"short\")\n   \"NO\"\n   >>> IsPasswordSecure(\"LongPasswordWithoutNumbersOrSymbols\")\n   \"NO\"",
      "de": "Schreiben Sie eine C#-Funktion `static string IsPasswordSecure(string password)`, um das folgende Problem zu lösen:\nBestimmt, ob ein gegebenes Passwort basierend auf spezifischen Kriterien sicher ist.\n   Ein sicheres Passwort muss:\n   1. Mindestens 8 Zeichen lang und höchstens 16 Zeichen lang sein.\n   2. Zeichen aus mindestens drei der folgenden Kategorien enthalten:\n      - Großbuchstaben (A-Z)\n      - Kleinbuchstaben (a-z)\n      - Zahlen (0-9)\n      - Spezielle Symbole (~, !, @, #, $, %, ^)\n\n   Beispiele:\n   >>> IsPasswordSecure(\"Password123!\")\n   \"YES\"\n   >>> IsPasswordSecure(\"short\")\n   \"NO\"\n   >>> IsPasswordSecure(\"LongPasswordWithoutNumbersOrSymbols\")\n   \"NO\"",
      "ha": "Rubuta aikin C# `static string IsPasswordSecure(string password)` don warware matsalar mai zuwa: \nTantance idan kalmar sirri da aka bayar tana da tsaro bisa ka'idodi na musamman.\n   Kalmar sirri mai tsaro dole ne ta kasance:\n   1. A kalla tana da tsawon haruffa 8 kuma ba fiye da haruffa 16 ba.\n   2. Ta haɗa da haruffa daga aƙalla rukuni uku daga cikin waɗannan:\n      - Manyan haruffa (A-Z)\n      - Ƙananan haruffa (a-z)\n      - Lambobi (0-9)\n      - Alamomin musamman (~, !, @, #, $, %, ^)\n\n   Misalai:\n   >>> IsPasswordSecure(\"Password123!\")\n   \"YES\"\n   >>> IsPasswordSecure(\"short\")\n   \"NO\"\n   >>> IsPasswordSecure(\"LongPasswordWithoutNumbersOrSymbols\")\n   \"NO\"",
      "hi": "C# फ़ंक्शन `static string IsPasswordSecure(string password)` लिखें ताकि निम्नलिखित समस्या का समाधान हो सके:\nनिर्धारित करता है कि दिए गए पासवर्ड को विशिष्ट मानदंडों के आधार पर सुरक्षित माना जा सकता है या नहीं।\n   एक सुरक्षित पासवर्ड होना चाहिए:\n   1. कम से कम 8 वर्ण लंबा और अधिकतम 16 वर्ण।\n   2. निम्नलिखित श्रेणियों में से कम से कम तीन से वर्ण शामिल करें:\n      - अपरकेस अक्षर (A-Z)\n      - लोअरकेस अक्षर (a-z)\n      - संख्याएँ (0-9)\n      - विशेष प्रतीक (~, !, @, #, $, %, ^)\n\n   उदाहरण:\n   >>> IsPasswordSecure(\"Password123!\")\n   \"YES\"\n   >>> IsPasswordSecure(\"short\")\n   \"NO\"\n   >>> IsPasswordSecure(\"LongPasswordWithoutNumbersOrSymbols\")\n   \"NO\"",
      "hu": "Írj egy C# függvényt `static string IsPasswordSecure(string password)` a következő probléma megoldására:\nMeghatározza, hogy egy adott jelszó biztonságos-e bizonyos kritériumok alapján.\n   Egy biztonságos jelszónak meg kell felelnie az alábbi követelményeknek:\n   1. Legalább 8 karakter hosszúnak kell lennie, de nem lehet hosszabb 16 karakternél.\n   2. Tartalmaznia kell karaktereket legalább három az alábbi kategóriák közül:\n      - Nagybetűk (A-Z)\n      - Kisbetűk (a-z)\n      - Számok (0-9)\n      - Speciális szimbólumok (~, !, @, #, $, %, ^)\n\n   Példák:\n   >>> IsPasswordSecure(\"Password123!\")\n   \"YES\"\n   >>> IsPasswordSecure(\"short\")\n   \"NO\"\n   >>> IsPasswordSecure(\"LongPasswordWithoutNumbersOrSymbols\")\n   \"NO\""
    },
    "instruction_bertscore": {
      "sq": "0.9951794392826643",
      "hy": "0.9927557513732765",
      "bn": "0.9730555901822364",
      "bg": "0.9980850044964427",
      "zh": "0.9820040874782391",
      "fr": "0.9756308330723537",
      "de": "0.9815394910169986",
      "ha": "0.9816550938987608",
      "hi": "0.9726285348630114",
      "hu": "0.9690035304091247"
    },
    "level": "hard",
    "test": "    static void Main()\n    {\n\n        Debug.Assert(IsPasswordSecure(\"Password123!\") == \"YES\");\n        Debug.Assert(IsPasswordSecure(\"short\") == \"NO\");\n        Debug.Assert(IsPasswordSecure(\"LongPasswordWithoutNumbersOrSymbols\") == \"NO\");\n        Debug.Assert(IsPasswordSecure(\"Good@Pass1\") == \"YES\");\n        Debug.Assert(IsPasswordSecure(\"1234567890\") == \"NO\");\n\n    }\n}",
    "entry_point": "IsPasswordSecure",
    "signature": "static string IsPasswordSecure(string password)",
    "docstring": {
      "en": "Determines if a given password is secure based on specific criteria.\n   A secure password must:\n   1. Be at least 8 characters long and no more than 16 characters.\n   2. Include characters from at least three of the following categories:\n      - Uppercase letters (A-Z)\n      - Lowercase letters (a-z)\n      - Numbers (0-9)\n      - Special symbols (~, !, @, #, $, %, ^)\n\n   Examples:\n   >>> IsPasswordSecure(\"Password123!\")\n   \"YES\"\n   >>> IsPasswordSecure(\"short\")\n   \"NO\"\n   >>> IsPasswordSecure(\"LongPasswordWithoutNumbersOrSymbols\")\n   \"NO\"",
      "sq": "Determinon nëse një fjalëkalim i dhënë është i sigurt bazuar në kritere specifike.\n   Një fjalëkalim i sigurt duhet:\n   1. Të jetë të paktën 8 karaktere i gjatë dhe jo më shumë se 16 karaktere.\n   2. Të përfshijë karaktere nga të paktën tre nga kategoritë e mëposhtme:\n      - Shkronja të mëdha (A-Z)\n      - Shkronja të vogla (a-z)\n      - Numra (0-9)\n      - Simbole speciale (~, !, @, #, $, %, ^)\n\n   Shembuj:\n   >>> IsPasswordSecure(\"Password123!\")\n   \"YES\"\n   >>> IsPasswordSecure(\"short\")\n   \"NO\"\n   >>> IsPasswordSecure(\"LongPasswordWithoutNumbersOrSymbols\")\n   \"NO\"",
      "hy": "Սահմանում է, արդյոք տրված գաղտնաբառը անվտանգ է որոշակի չափանիշների հիման վրա:\n   Անվտանգ գաղտնաբառը պետք է՝\n   1. Լինի առնվազն 8 նիշ երկարությամբ և ոչ ավելի, քան 16 նիշ:\n   2. Ներառի նիշեր առնվազն հետևյալ երեք կատեգորիաներից՝ \n      - Մեծատառեր (A-Z)\n      - Փոքրատառեր (a-z)\n      - Թվեր (0-9)\n      - Հատուկ սիմվոլներ (~, !, @, #, $, %, ^)\n\n   Օրինակներ:\n   >>> IsPasswordSecure(\"Password123!\")\n   \"YES\"\n   >>> IsPasswordSecure(\"short\")\n   \"NO\"\n   >>> IsPasswordSecure(\"LongPasswordWithoutNumbersOrSymbols\")\n   \"NO\"",
      "bn": "নির্দিষ্ট মানদণ্ডের ভিত্তিতে একটি প্রদত্ত পাসওয়ার্ড নিরাপদ কিনা তা নির্ধারণ করে।\n   একটি নিরাপদ পাসওয়ার্ড অবশ্যই:\n   1. কমপক্ষে 8 অক্ষর দীর্ঘ এবং সর্বাধিক 16 অক্ষর হতে হবে।\n   2. নিম্নলিখিত বিভাগগুলির মধ্যে অন্তত তিনটি থেকে অক্ষর অন্তর্ভুক্ত করতে হবে:\n      - বড় হাতের অক্ষর (A-Z)\n      - ছোট হাতের অক্ষর (a-z)\n      - সংখ্যা (0-9)\n      - বিশেষ প্রতীক (~, !, @, #, $, %, ^)\n\n   উদাহরণ:\n   >>> IsPasswordSecure(\"Password123!\")\n   \"YES\"\n   >>> IsPasswordSecure(\"short\")\n   \"NO\"\n   >>> IsPasswordSecure(\"LongPasswordWithoutNumbersOrSymbols\")\n   \"NO\"",
      "bg": "Определя дали дадена парола е сигурна въз основа на конкретни критерии.\n   Сигурната парола трябва да:\n   1. Бъде поне 8 символа дълга и не повече от 16 символа.\n   2. Включва символи от поне три от следните категории:\n      - Главни букви (A-Z)\n      - Малки букви (a-z)\n      - Числа (0-9)\n      - Специални символи (~, !, @, #, $, %, ^)\n\n   Примери:\n   >>> IsPasswordSecure(\"Password123!\")\n   \"YES\"\n   >>> IsPasswordSecure(\"short\")\n   \"NO\"\n   >>> IsPasswordSecure(\"LongPasswordWithoutNumbersOrSymbols\")\n   \"NO\"",
      "zh": "确定给定的密码是否基于特定标准是安全的。\n   一个安全的密码必须：\n   1. 至少包含8个字符且不超过16个字符。\n   2. 包含以下类别中的至少三种字符：\n      - 大写字母 (A-Z)\n      - 小写字母 (a-z)\n      - 数字 (0-9)\n      - 特殊符号 (~, !, @, #, $, %, ^)\n\n   示例：\n   >>> IsPasswordSecure(\"Password123!\")\n   \"YES\"\n   >>> IsPasswordSecure(\"short\")\n   \"NO\"\n   >>> IsPasswordSecure(\"LongPasswordWithoutNumbersOrSymbols\")\n   \"NO\"",
      "fr": "Détermine si un mot de passe donné est sécurisé en fonction de critères spécifiques.\n   Un mot de passe sécurisé doit :\n   1. Être d'au moins 8 caractères et ne pas dépasser 16 caractères.\n   2. Inclure des caractères d'au moins trois des catégories suivantes :\n      - Lettres majuscules (A-Z)\n      - Lettres minuscules (a-z)\n      - Nombres (0-9)\n      - Symboles spéciaux (~, !, @, #, $, %, ^)\n\n   Exemples :\n   >>> IsPasswordSecure(\"Password123!\")\n   \"YES\"\n   >>> IsPasswordSecure(\"short\")\n   \"NO\"\n   >>> IsPasswordSecure(\"LongPasswordWithoutNumbersOrSymbols\")\n   \"NO\"",
      "de": "Bestimmt, ob ein gegebenes Passwort basierend auf spezifischen Kriterien sicher ist.\n   Ein sicheres Passwort muss:\n   1. Mindestens 8 Zeichen lang und nicht mehr als 16 Zeichen sein.\n   2. Zeichen aus mindestens drei der folgenden Kategorien enthalten:\n      - Großbuchstaben (A-Z)\n      - Kleinbuchstaben (a-z)\n      - Zahlen (0-9)\n      - Spezielle Symbole (~, !, @, #, $, %, ^)\n\n   Beispiele:\n   >>> IsPasswordSecure(\"Password123!\")\n   \"YES\"\n   >>> IsPasswordSecure(\"short\")\n   \"NO\"\n   >>> IsPasswordSecure(\"LongPasswordWithoutNumbersOrSymbols\")\n   \"NO\"",
      "ha": "Yana tantance ko kalmar sirri da aka bayar tana da tsaro bisa wasu ka'idoji na musamman.\n   Kalmar sirri mai tsaro dole ne ta:\n   1. Kasance a kalla tana da tsawon haruffa 8 kuma ba fiye da haruffa 16 ba.\n   2. Hada haruffa daga a kalla uku daga cikin wadannan rukuni:\n      - Manyan haruffa (A-Z)\n      - Kananan haruffa (a-z)\n      - Lambobi (0-9)\n      - Alamomin musamman (~, !, @, #, $, %, ^)\n\n   Misalai:\n   >>> IsPasswordSecure(\"Password123!\")\n   \"YES\"\n   >>> IsPasswordSecure(\"short\")\n   \"NO\"\n   >>> IsPasswordSecure(\"LongPasswordWithoutNumbersOrSymbols\")\n   \"NO\"",
      "hi": "निर्धारित करता है कि दी गई पासवर्ड विशिष्ट मानदंडों के आधार पर सुरक्षित है या नहीं।\n   एक सुरक्षित पासवर्ड को निम्नलिखित होना चाहिए:\n   1. कम से कम 8 वर्ण लंबा और अधिकतम 16 वर्ण।\n   2. निम्नलिखित श्रेणियों में से कम से कम तीन से वर्ण शामिल हों:\n      - बड़े अक्षर (A-Z)\n      - छोटे अक्षर (a-z)\n      - संख्याएँ (0-9)\n      - विशेष प्रतीक (~, !, @, #, $, %, ^)\n\n   उदाहरण:\n   >>> IsPasswordSecure(\"Password123!\")\n   \"YES\"\n   >>> IsPasswordSecure(\"short\")\n   \"NO\"\n   >>> IsPasswordSecure(\"LongPasswordWithoutNumbersOrSymbols\")\n   \"NO\"",
      "hu": "Meghatározza, hogy egy adott jelszó biztonságos-e meghatározott kritériumok alapján.\n   Egy biztonságos jelszónak meg kell felelnie az alábbiaknak:\n   1. Legalább 8 karakter hosszúnak kell lennie, de nem lehet több mint 16 karakter.\n   2. Tartalmaznia kell karaktereket legalább három az alábbi kategóriák közül:\n      - Nagybetűk (A-Z)\n      - Kisbetűk (a-z)\n      - Számok (0-9)\n      - Speciális szimbólumok (~, !, @, #, $, %, ^)\n\n   Példák:\n   >>> IsPasswordSecure(\"Password123!\")\n   \"YES\"\n   >>> IsPasswordSecure(\"short\")\n   \"NO\"\n   >>> IsPasswordSecure(\"LongPasswordWithoutNumbersOrSymbols\")\n   \"NO\""
    },
    "docstring_bertscore": {
      "sq": "1",
      "hy": "0.9892135757882814",
      "bn": "0.9875482586736849",
      "bg": "0.9993784855377419",
      "zh": "0.9771704171557551",
      "fr": "0.9766523891220161",
      "de": "0.9938609308133547",
      "ha": "0.9845997892976031",
      "hi": "0.9746176194986947",
      "hu": "0.9714369512071831"
    }
  },
  {
    "task_id": "C#/37",
    "prompt": {
      "en": "using System;\nusing System.Collections.Generic;\nusing System.Diagnostics;\n\nclass Program\n{\n\n\n/* Counts the number of ways a group of kids can queue up to buy tickets, ensuring the ticket seller can always give change.\n   - totalKids: Total number of kids.\n   - oneDollarKids: Number of kids with exactly 1 dollar.\n   - twoDollarKids: Number of kids with exactly 2 dollars.\n   The ticket seller has no change initially, and the ticket costs 1 dollar.\n   Different permutations of kids with the same amount are considered distinct arrangements.\n   Example:\n   >>> CountQueueArrangements(4, 2, 2)\n   8\n\n*/\n    static int CountQueueArrangements(int totalKids, int oneDollarKids, int twoDollarKids)",
      "sq": "using System;\nusing System.Collections.Generic;\nusing System.Diagnostics;\n\nclass Program\n{\n\n\n/* Numëron numrin e mënyrave se si një grup fëmijësh mund të rreshtohen për të blerë bileta, duke siguruar që shitësi i biletave gjithmonë mund të japë kusur.\n   - totalKids: Numri total i fëmijëve.\n   - oneDollarKids: Numri i fëmijëve me saktësisht 1 dollar.\n   - twoDollarKids: Numri i fëmijëve me saktësisht 2 dollarë.\n   Shitësi i biletave nuk ka kusur fillimisht, dhe bileta kushton 1 dollar.\n   Permutime të ndryshme të fëmijëve me të njëjtën shumë konsiderohen si rregullime të dallueshme.\n   Shembull:\n   >>> CountQueueArrangements(4, 2, 2)\n   8\n\n*/\n    static int CountQueueArrangements(int totalKids, int oneDollarKids, int twoDollarKids)",
      "hy": "using System;\nusing System.Collections.Generic;\nusing System.Diagnostics;\n\nclass Program\n{\n\n\n/* Հաշվում է, թե քանի եղանակով կարող է երեխաների խումբը հերթ կանգնել տոմս գնելու համար՝ ապահովելով, որ տոմսավաճառը միշտ կարողանա մանրը վերադարձնել։\n   - totalKids: Երեխաների ընդհանուր քանակը։\n   - oneDollarKids: Երեխաների քանակը, ովքեր ունեն հենց 1 դոլար։\n   - twoDollarKids: Երեխաների քանակը, ովքեր ունեն հենց 2 դոլար։\n   Տոմսավաճառը սկզբում մանրը չունի, և տոմսը արժե 1 դոլար։\n   Նույն գումար ունեցող երեխաների տարբեր փոխատեղումները համարվում են տարբեր դասավորություններ։\n   Օրինակ:\n   >>> CountQueueArrangements(4, 2, 2)\n   8\n\n*/\n    static int CountQueueArrangements(int totalKids, int oneDollarKids, int twoDollarKids)",
      "bn": "using System;\nusing System.Collections.Generic;\nusing System.Diagnostics;\n\nclass Program\n{\n\n\n/* কতভাবে একদল শিশু টিকিট কিনতে লাইনে দাঁড়াতে পারে তা গণনা করে, নিশ্চিত করে যে টিকিট বিক্রেতা সর্বদা চেঞ্জ দিতে পারে।\n   - totalKids: মোট শিশুর সংখ্যা।\n   - oneDollarKids: যেসব শিশুর কাছে ঠিক ১ ডলার আছে তাদের সংখ্যা।\n   - twoDollarKids: যেসব শিশুর কাছে ঠিক ২ ডলার আছে তাদের সংখ্যা।\n   টিকিট বিক্রেতার শুরুতে কোনো চেঞ্জ নেই, এবং টিকিটের দাম ১ ডলার।\n   একই পরিমাণ অর্থ সহ শিশুদের বিভিন্ন বিন্যাস পৃথক বিন্যাস হিসাবে বিবেচিত হয়।\n   উদাহরণ:\n   >>> CountQueueArrangements(4, 2, 2)\n   8\n\n*/\n    static int CountQueueArrangements(int totalKids, int oneDollarKids, int twoDollarKids)",
      "bg": "using System;\nusing System.Collections.Generic;\nusing System.Diagnostics;\n\nclass Program\n{\n\n\n/* Брои броя на начините, по които група деца могат да се наредят на опашка, за да купят билети, като се гарантира, че продавачът на билети винаги може да даде ресто.\n   - totalKids: Общо брой деца.\n   - oneDollarKids: Брой деца с точно 1 долар.\n   - twoDollarKids: Брой деца с точно 2 долара.\n   Продавачът на билети няма ресто в началото, а билетът струва 1 долар.\n   Различните пермутации на деца със същата сума се считат за различни подредби.\n   Пример:\n   >>> CountQueueArrangements(4, 2, 2)\n   8\n\n*/\n    static int CountQueueArrangements(int totalKids, int oneDollarKids, int twoDollarKids)",
      "zh": "using System;\nusing System.Collections.Generic;\nusing System.Diagnostics;\n\nclass Program\n{\n\n\n/* 计算一组孩子排队买票的方式数量，确保售票员总是可以找零。\n   - totalKids: 孩子的总数。\n   - oneDollarKids: 拥有1美元的孩子数量。\n   - twoDollarKids: 拥有2美元的孩子数量。\n   售票员最初没有零钱，票价为1美元。\n   拥有相同金额的孩子的不同排列被视为不同的安排。\n   示例:\n   >>> CountQueueArrangements(4, 2, 2)\n   8\n\n*/\n    static int CountQueueArrangements(int totalKids, int oneDollarKids, int twoDollarKids)",
      "fr": "using System;\nusing System.Collections.Generic;\nusing System.Diagnostics;\n\nclass Program\n{\n\n\n/* Compte le nombre de façons dont un groupe d'enfants peut faire la queue pour acheter des billets, en s'assurant que le vendeur de billets peut toujours rendre la monnaie.\n   - totalKids: Nombre total d'enfants.\n   - oneDollarKids: Nombre d'enfants avec exactement 1 dollar.\n   - twoDollarKids: Nombre d'enfants avec exactement 2 dollars.\n   Le vendeur de billets n'a pas de monnaie au départ, et le billet coûte 1 dollar.\n   Différentes permutations d'enfants avec le même montant sont considérées comme des arrangements distincts.\n   Exemple :\n   >>> CountQueueArrangements(4, 2, 2)\n   8\n\n*/\n    static int CountQueueArrangements(int totalKids, int oneDollarKids, int twoDollarKids)",
      "de": "using System;\nusing System.Collections.Generic;\nusing System.Diagnostics;\n\nclass Program\n{\n\n\n/* Zählt die Anzahl der Möglichkeiten, wie sich eine Gruppe von Kindern anstellen kann, um Tickets zu kaufen, wobei sichergestellt wird, dass der Ticketverkäufer immer Wechselgeld geben kann.\n   - totalKids: Gesamtanzahl der Kinder.\n   - oneDollarKids: Anzahl der Kinder mit genau 1 Dollar.\n   - twoDollarKids: Anzahl der Kinder mit genau 2 Dollar.\n   Der Ticketverkäufer hat anfangs kein Wechselgeld, und das Ticket kostet 1 Dollar.\n   Verschiedene Permutationen von Kindern mit dem gleichen Betrag werden als unterschiedliche Anordnungen betrachtet.\n   Beispiel:\n   >>> CountQueueArrangements(4, 2, 2)\n   8\n\n*/\n    static int CountQueueArrangements(int totalKids, int oneDollarKids, int twoDollarKids)",
      "ha": "using System;\nusing System.Collections.Generic;\nusing System.Diagnostics;\n\nclass Program\n{\n\n\n/* Yana ƙididdige yawan hanyoyin da wata ƙungiyar yara za su iya tsayawa a layi don siyan tikiti, tabbatar da cewa mai siyar da tikiti koyaushe zai iya ba da canji.\n   - totalKids: Jimlar yawan yara.\n   - oneDollarKids: Yawan yaran da ke da dala 1 kawai.\n   - twoDollarKids: Yawan yaran da ke da dala 2 kawai.\n   Mai siyar da tikiti ba shi da canji a farko, kuma tikitin yana da tsada dala 1.\n   Daban-daban juyawa na yara da ke da adadin iri ɗaya ana ɗaukar su a matsayin tsaruka daban-daban.\n   Misali:\n   >>> CountQueueArrangements(4, 2, 2)\n   8\n\n*/\n    static int CountQueueArrangements(int totalKids, int oneDollarKids, int twoDollarKids)",
      "hi": "using System;\nusing System.Collections.Generic;\nusing System.Diagnostics;\n\nclass Program\n{\n\n\n/* यह गणना करता है कि टिकट खरीदने के लिए बच्चों का एक समूह कितने तरीकों से कतार में लग सकता है, यह सुनिश्चित करते हुए कि टिकट विक्रेता हमेशा चेंज दे सकता है।\n   - totalKids: बच्चों की कुल संख्या।\n   - oneDollarKids: बच्चों की संख्या जिनके पास ठीक 1 डॉलर है।\n   - twoDollarKids: बच्चों की संख्या जिनके पास ठीक 2 डॉलर है।\n   टिकट विक्रेता के पास शुरू में कोई चेंज नहीं है, और टिकट की कीमत 1 डॉलर है।\n   समान राशि वाले बच्चों के विभिन्न क्रमों को अलग-अलग व्यवस्थाएँ माना जाता है।\n   उदाहरण:\n   >>> CountQueueArrangements(4, 2, 2)\n   8\n\n*/\n    static int CountQueueArrangements(int totalKids, int oneDollarKids, int twoDollarKids)",
      "hu": "using System;\nusing System.Collections.Generic;\nusing System.Diagnostics;\n\nclass Program\n{\n\n\n/* Megszámolja, hányféleképpen állhatnak sorba a gyerekek jegyvásárlásra úgy, hogy a jegyárus mindig tudjon visszaadni.\n   - totalKids: A gyerekek teljes száma.\n   - oneDollarKids: Azoknak a gyerekeknek a száma, akiknél pontosan 1 dollár van.\n   - twoDollarKids: Azoknak a gyerekeknek a száma, akiknél pontosan 2 dollár van.\n   A jegyárusnak kezdetben nincs aprója, és a jegy 1 dollárba kerül.\n   Az azonos összegű gyerekek különböző permutációi különböző elrendezéseknek számítanak.\n   Példa:\n   >>> CountQueueArrangements(4, 2, 2)\n   8\n\n*/\n    static int CountQueueArrangements(int totalKids, int oneDollarKids, int twoDollarKids)"
    },
    "prompt_bertscore": {
      "sq": "0.9749650240351247",
      "hy": "0.9714162936475554",
      "bn": "0.9561626721663622",
      "bg": "0.980272229185996",
      "zh": "0.9626936390947893",
      "fr": "0.990418269049258",
      "de": "0.9875043613594762",
      "ha": "0.9488113617642611",
      "hi": "0.9636299827109879",
      "hu": "0.95761326983906"
    },
    "canonical_solution": "    {\n        oneDollarTotal = oneDollarKids;\n        twoDollarTotal = twoDollarKids;\n        permutations = Factorial(oneDollarKids) * Factorial(twoDollarKids);\n        arrangements = 0;\n\n        CountArrangements(totalKids, oneDollarKids, twoDollarKids);\n        return arrangements;\n    }\n\n    static int arrangements = 0, oneDollarTotal, twoDollarTotal, permutations;\n\n\n\n    static void CountArrangements(int n, int oneDollarRemaining, int twoDollarRemaining)\n    {\n        // Check if the arrangement is invalid\n        if ((oneDollarTotal - oneDollarRemaining) < (twoDollarTotal - twoDollarRemaining))\n            return;\n\n        // If no kids are left, add the number of permutations to arrangements\n        if (n == 0)\n        {\n            arrangements += permutations;\n            return;\n        }\n\n        // Choose a one-dollar kid\n        if (oneDollarRemaining > 0)\n            CountArrangements(n - 1, oneDollarRemaining - 1, twoDollarRemaining);\n\n        // Choose a two-dollar kid\n        if (twoDollarRemaining > 0)\n            CountArrangements(n - 1, oneDollarRemaining, twoDollarRemaining - 1);\n    }\n\n\n    static int Factorial(int number)\n    {\n        int result = 1;\n        for (int i = 2; i <= number; i++)\n            result *= i;\n        return result;\n    }\n\n",
    "instruction": {
      "en": "Write a C# function `static int CountQueueArrangements(int totalKids, int oneDollarKids, int twoDollarKids)` to solve the following problem:\nCounts the number of ways a group of kids can queue up to buy tickets, ensuring the ticket seller can always give change.\n   - totalKids: Total number of kids.\n   - oneDollarKids: Number of kids with exactly 1 dollar.\n   - twoDollarKids: Number of kids with exactly 2 dollars.\n   The ticket seller has no change initially, and the ticket costs 1 dollar.\n   Different permutations of kids with the same amount are considered distinct arrangements.\n   Example:\n   >>> CountQueueArrangements(4, 2, 2)\n   8",
      "sq": "Shkruani një funksion në C# `static int CountQueueArrangements(int totalKids, int oneDollarKids, int twoDollarKids)` për të zgjidhur problemin në vijim:\nNumëron numrin e mënyrave që një grup fëmijësh mund të rreshtohen për të blerë bileta, duke siguruar që shitësi i biletave gjithmonë mund të japë kusur.\n   - totalKids: Numri total i fëmijëve.\n   - oneDollarKids: Numri i fëmijëve me saktësisht 1 dollar.\n   - twoDollarKids: Numri i fëmijëve me saktësisht 2 dollarë.\n   Shitësi i biletave nuk ka kusur fillimisht, dhe bileta kushton 1 dollar.\n   Permutime të ndryshme të fëmijëve me të njëjtën shumë konsiderohen si rregullime të veçanta.\n   Shembull:\n   >>> CountQueueArrangements(4, 2, 2)\n   8",
      "hy": "Գրեք C# ֆունկցիա `static int CountQueueArrangements(int totalKids, int oneDollarKids, int twoDollarKids)` հետևյալ խնդիրը լուծելու համար:\nՀաշվում է, թե քանի եղանակով կարող են երեխաները հերթ կանգնել տոմս գնելու համար՝ ապահովելով, որ տոմսավաճառը միշտ կարող է մանրը վերադարձնել:\n   - totalKids: Երեխաների ընդհանուր քանակը։\n   - oneDollarKids: Երեխաների քանակը, որոնք ունեն ճիշտ 1 դոլար։\n   - twoDollarKids: Երեխաների քանակը, որոնք ունեն ճիշտ 2 դոլար։\n   Սկզբում տոմսավաճառը մանրը չունի, և տոմսը արժե 1 դոլար։\n   Նույն գումարով երեխաների տարբեր տեղաշարժումները համարվում են տարբեր հերթեր։\n   Օրինակ:\n   >>> CountQueueArrangements(4, 2, 2)\n   8",
      "bn": "একটি C# ফাংশন `static int CountQueueArrangements(int totalKids, int oneDollarKids, int twoDollarKids)` লিখুন নিম্নলিখিত সমস্যার সমাধানের জন্য:\nএকটি শিশুদের দল কতভাবে লাইনে দাঁড়াতে পারে তা গণনা করে, নিশ্চিত করে যে টিকিট বিক্রেতা সর্বদা খুচরা দিতে পারে।\n   - totalKids: মোট শিশুদের সংখ্যা।\n   - oneDollarKids: ঠিক 1 ডলার নিয়ে আসা শিশুদের সংখ্যা।\n   - twoDollarKids: ঠিক 2 ডলার নিয়ে আসা শিশুদের সংখ্যা।\n   টিকিট বিক্রেতার শুরুতে কোনো খুচরা নেই, এবং টিকিটের মূল্য 1 ডলার।\n   একই পরিমাণের শিশুদের বিভিন্ন বিন্যাসকে পৃথক বিন্যাস হিসেবে বিবেচনা করা হয়।\n   উদাহরণ:\n   >>> CountQueueArrangements(4, 2, 2)\n   8",
      "bg": "Напишете C# функция `static int CountQueueArrangements(int totalKids, int oneDollarKids, int twoDollarKids)` за решаване на следния проблем:\nБрои броя на начините, по които група деца могат да се наредят на опашка, за да купят билети, като се гарантира, че продавачът на билети винаги може да върне ресто.\n   - totalKids: Общо брой деца.\n   - oneDollarKids: Брой деца с точно 1 долар.\n   - twoDollarKids: Брой деца с точно 2 долара.\n   Продавачът на билети няма ресто в началото, а билетът струва 1 долар.\n   Различни пермутации на деца с еднаква сума се считат за различни подредби.\n   Пример:\n   >>> CountQueueArrangements(4, 2, 2)\n   8",
      "zh": "编写一个 C# 函数 `static int CountQueueArrangements(int totalKids, int oneDollarKids, int twoDollarKids)` 来解决以下问题：\n计算一组孩子排队买票的不同方式，确保售票员始终可以找零。\n   - totalKids: 孩子的总数。\n   - oneDollarKids: 拥有正好 1 美元的孩子数量。\n   - twoDollarKids: 拥有正好 2 美元的孩子数量。\n   售票员最初没有零钱，票价为 1 美元。\n   拥有相同金额的孩子的不同排列被视为不同的安排。\n   示例:\n   >>> CountQueueArrangements(4, 2, 2)\n   8",
      "fr": "Écrire une fonction C# `static int CountQueueArrangements(int totalKids, int oneDollarKids, int twoDollarKids)` pour résoudre le problème suivant :\nCompte le nombre de façons dont un groupe d'enfants peut faire la queue pour acheter des billets, en s'assurant que le vendeur de billets peut toujours rendre la monnaie.\n   - totalKids: Nombre total d'enfants.\n   - oneDollarKids: Nombre d'enfants avec exactement 1 dollar.\n   - twoDollarKids: Nombre d'enfants avec exactement 2 dollars.\n   Le vendeur de billets n'a pas de monnaie au départ, et le billet coûte 1 dollar.\n   Différentes permutations d'enfants avec le même montant sont considérées comme des arrangements distincts.\n   Exemple :\n   >>> CountQueueArrangements(4, 2, 2)\n   8",
      "de": "Schreiben Sie eine C#-Funktion `static int CountQueueArrangements(int totalKids, int oneDollarKids, int twoDollarKids)`, um das folgende Problem zu lösen:\nZählt die Anzahl der Möglichkeiten, wie sich eine Gruppe von Kindern anstellen kann, um Tickets zu kaufen, wobei sichergestellt wird, dass der Ticketverkäufer immer Wechselgeld geben kann.\n   - totalKids: Gesamtanzahl der Kinder.\n   - oneDollarKids: Anzahl der Kinder mit genau 1 Dollar.\n   - twoDollarKids: Anzahl der Kinder mit genau 2 Dollar.\n   Der Ticketverkäufer hat anfangs kein Wechselgeld, und das Ticket kostet 1 Dollar.\n   Verschiedene Permutationen von Kindern mit dem gleichen Betrag werden als unterschiedliche Anordnungen betrachtet.\n   Beispiel:\n   >>> CountQueueArrangements(4, 2, 2)\n   8",
      "ha": "Rubuta aikin C# `static int CountQueueArrangements(int totalKids, int oneDollarKids, int twoDollarKids)` don warware matsalar mai zuwa:\nYana ƙididdige yawan hanyoyin da za a iya tsara ƙungiyar yara su tsaya a layi don siyan tikiti, yana tabbatar da cewa mai siyar da tikiti koyaushe zai iya ba da canji.\n   - totalKids: Jimlar adadin yara.\n   - oneDollarKids: Yawan yaran da ke da dala 1 kawai.\n   - twoDollarKids: Yawan yaran da ke da dala 2 kawai.\n   Mai siyar da tikiti ba shi da canji a farko, kuma tikitin yana da tsadar dala 1.\n   Daban-daban permutations na yara tare da adadin iri ɗaya ana ɗaukar su a matsayin tsararru daban-daban.\n   Misali:\n   >>> CountQueueArrangements(4, 2, 2)\n   8",
      "hi": "C# फ़ंक्शन `static int CountQueueArrangements(int totalKids, int oneDollarKids, int twoDollarKids)` लिखें ताकि निम्नलिखित समस्या का समाधान किया जा सके:\nयह गणना करता है कि बच्चों का एक समूह कितने तरीकों से टिकट खरीदने के लिए कतार में लग सकता है, यह सुनिश्चित करते हुए कि टिकट विक्रेता हमेशा छुट्टा दे सकता है।\n   - totalKids: बच्चों की कुल संख्या।\n   - oneDollarKids: बच्चों की संख्या जिनके पास ठीक 1 डॉलर है।\n   - twoDollarKids: बच्चों की संख्या जिनके पास ठीक 2 डॉलर है।\n   टिकट विक्रेता के पास शुरू में कोई छुट्टा नहीं है, और टिकट की कीमत 1 डॉलर है।\n   समान राशि वाले बच्चों के विभिन्न क्रम भिन्न व्यवस्थाएं माने जाते हैं।\n   उदाहरण:\n   >>> CountQueueArrangements(4, 2, 2)\n   8",
      "hu": "Írj egy C# függvényt `static int CountQueueArrangements(int totalKids, int oneDollarKids, int twoDollarKids)` a következő probléma megoldására:\nSzámolja meg, hányféleképpen tud egy gyerekcsoport sorba állni jegyvásárlásra úgy, hogy a jegyárus mindig tudjon visszaadni.\n   - totalKids: A gyerekek összlétszáma.\n   - oneDollarKids: Azoknak a gyerekeknek a száma, akiknél pontosan 1 dollár van.\n   - twoDollarKids: Azoknak a gyerekeknek a száma, akiknél pontosan 2 dollár van.\n   A jegyárus kezdetben nem rendelkezik aprópénzzel, és a jegy ára 1 dollár.\n   Az azonos összeggel rendelkező gyerekek különböző permutációi különböző elrendezéseknek számítanak.\n   Példa:\n   >>> CountQueueArrangements(4, 2, 2)\n   8"
    },
    "instruction_bertscore": {
      "sq": "0.9754969561955362",
      "hy": "0.9752804490802082",
      "bn": "0.9461155502328555",
      "bg": "0.9856193590434551",
      "zh": "0.9619736039635379",
      "fr": "0.9936011222749611",
      "de": "0.9851817763140353",
      "ha": "0.947439024461691",
      "hi": "0.9593222856374842",
      "hu": "0.9541507450368598"
    },
    "level": "hard",
    "test": "    static void Main()\n    {\n        Debug.Assert(CountQueueArrangements(4, 2, 2) == 8);\n        Debug.Assert(CountQueueArrangements(5, 3, 2) == 60); // Expected output: True\n        Debug.Assert(CountQueueArrangements(6, 4, 2) == 432); // Expected output: True\n\n    }\n}\n",
    "entry_point": "CountQueueArrangements",
    "signature": "static int CountQueueArrangements(int totalKids, int oneDollarKids, int twoDollarKids)",
    "docstring": {
      "en": "Counts the number of ways a group of kids can queue up to buy tickets, ensuring the ticket seller can always give change.\n   - totalKids: Total number of kids.\n   - oneDollarKids: Number of kids with exactly 1 dollar.\n   - twoDollarKids: Number of kids with exactly 2 dollars.\n   The ticket seller has no change initially, and the ticket costs 1 dollar.\n   Different permutations of kids with the same amount are considered distinct arrangements.\n   Example:\n   >>> CountQueueArrangements(4, 2, 2)\n   8",
      "sq": "Numëron numrin e mënyrave se si një grup fëmijësh mund të rreshtohen për të blerë bileta, duke siguruar që shitësi i biletave të mund të japë gjithmonë kusur.\n   - totalKids: Numri total i fëmijëve.\n   - oneDollarKids: Numri i fëmijëve me saktësisht 1 dollar.\n   - twoDollarKids: Numri i fëmijëve me saktësisht 2 dollarë.\n   Shitësi i biletave nuk ka kusur fillimisht, dhe bileta kushton 1 dollar.\n   Permutime të ndryshme të fëmijëve me të njëjtën shumë konsiderohen si rregullime të veçanta.\n   Shembull:\n   >>> CountQueueArrangements(4, 2, 2)\n   8",
      "hy": "Հաշվում է, թե քանի եղանակով կարող է երեխաների խումբը հերթ կանգնել տոմս գնելու համար՝ ապահովելով, որ տոմս վաճառողը միշտ կարողանա մանրը վերադարձնել:\n   - totalKids: Երեխաների ընդհանուր թիվը:\n   - oneDollarKids: 1 դոլար ունեցող երեխաների թիվը:\n   - twoDollarKids: 2 դոլար ունեցող երեխաների թիվը:\n   Տոմս վաճառողը սկզբում մանրը չունի, և տոմսի արժեքը 1 դոլար է:\n   Նույն գումար ունեցող երեխաների տարբեր տեղաշարժումները համարվում են տարբեր դասավորություններ:\n   Օրինակ:\n   >>> CountQueueArrangements(4, 2, 2)\n   8",
      "bn": "বাচ্চাদের একটি দল কতভাবে টিকিট কিনতে লাইনে দাঁড়াতে পারে তার সংখ্যা গণনা করে, নিশ্চিত করে যে টিকিট বিক্রেতা সর্বদা চেঞ্জ দিতে পারে।\n   - totalKids: মোট বাচ্চার সংখ্যা।\n   - oneDollarKids: ঠিক 1 ডলার থাকা বাচ্চার সংখ্যা।\n   - twoDollarKids: ঠিক 2 ডলার থাকা বাচ্চার সংখ্যা।\n   টিকিট বিক্রেতার শুরুতে কোনো চেঞ্জ নেই, এবং টিকিটের দাম 1 ডলার।\n   একই পরিমাণের বাচ্চাদের বিভিন্ন বিন্যাস ভিন্ন বিন্যাস হিসেবে বিবেচিত হয়।\n   উদাহরণ:\n   >>> CountQueueArrangements(4, 2, 2)\n   8",
      "bg": "Брои броя на начините, по които група деца могат да се наредят на опашка за закупуване на билети, като се гарантира, че продавачът на билети винаги може да даде ресто.\n   - totalKids: Общо брой деца.\n   - oneDollarKids: Брой деца с точно 1 долар.\n   - twoDollarKids: Брой деца с точно 2 долара.\n   Продавачът на билети няма ресто в началото, а билетът струва 1 долар.\n   Различните пермутации на деца със същата сума се считат за различни подреждания.\n   Пример:\n   >>> CountQueueArrangements(4, 2, 2)\n   8",
      "zh": "计算一组孩子排队买票的方式数量，确保售票员始终可以找零。\n   - totalKids: 孩子的总数。\n   - oneDollarKids: 拥有正好1美元的孩子数量。\n   - twoDollarKids: 拥有正好2美元的孩子数量。\n   售票员最初没有零钱，票价为1美元。\n   拥有相同金额的孩子的不同排列被视为不同的安排。\n   示例：\n   >>> CountQueueArrangements(4, 2, 2)\n   8",
      "fr": "Compte le nombre de façons dont un groupe d'enfants peut faire la queue pour acheter des billets, en s'assurant que le vendeur de billets peut toujours rendre la monnaie.\n   - totalKids: Nombre total d'enfants.\n   - oneDollarKids: Nombre d'enfants avec exactement 1 dollar.\n   - twoDollarKids: Nombre d'enfants avec exactement 2 dollars.\n   Le vendeur de billets n'a pas de monnaie au départ, et le billet coûte 1 dollar.\n   Différentes permutations d'enfants avec le même montant sont considérées comme des arrangements distincts.\n   Exemple:\n   >>> CountQueueArrangements(4, 2, 2)\n   8",
      "de": "Zählt die Anzahl der Möglichkeiten, wie sich eine Gruppe von Kindern anstellen kann, um Tickets zu kaufen, wobei sichergestellt wird, dass der Ticketverkäufer immer Wechselgeld geben kann.\n   - totalKids: Gesamtanzahl der Kinder.\n   - oneDollarKids: Anzahl der Kinder mit genau 1 Dollar.\n   - twoDollarKids: Anzahl der Kinder mit genau 2 Dollar.\n   Der Ticketverkäufer hat anfangs kein Wechselgeld, und das Ticket kostet 1 Dollar.\n   Verschiedene Permutationen von Kindern mit demselben Betrag werden als unterschiedliche Anordnungen betrachtet.\n   Beispiel:\n   >>> CountQueueArrangements(4, 2, 2)\n   8",
      "ha": "Yana ƙididdige yawan hanyoyin da wata ƙungiyar yara za su iya tsayawa a layi don siyan tikiti, tabbatar da cewa mai siyar da tikiti koyaushe zai iya ba da canji.\n   - totalKids: Jimlar yawan yara.\n   - oneDollarKids: Yawan yara da suke da dala 1 kawai.\n   - twoDollarKids: Yawan yara da suke da dala 2 kawai.\n   The ticket seller has no change initially, and the ticket costs 1 dollar.\n   Different permutations of kids with the same amount are considered distinct arrangements.\n   Misali:\n   >>> CountQueueArrangements(4, 2, 2)\n   8",
      "hi": "बच्चों के एक समूह के टिकट खरीदने के लिए कतार में लगने के तरीकों की संख्या गिनता है, यह सुनिश्चित करते हुए कि टिकट विक्रेता हमेशा बदलाव दे सकता है।\n   - totalKids: बच्चों की कुल संख्या।\n   - oneDollarKids: उन बच्चों की संख्या जिनके पास ठीक 1 डॉलर है।\n   - twoDollarKids: उन बच्चों की संख्या जिनके पास ठीक 2 डॉलर हैं।\n   टिकट विक्रेता के पास शुरू में कोई बदलाव नहीं है, और टिकट की कीमत 1 डॉलर है।\n   समान राशि वाले बच्चों की विभिन्न व्यवस्थाओं को अलग-अलग व्यवस्थाएं माना जाता है।\n   उदाहरण:\n   >>> CountQueueArrangements(4, 2, 2)\n   8",
      "hu": "Számolja ki, hányféleképpen állhatnak sorba a gyerekek, hogy jegyet vegyenek, biztosítva, hogy a jegyárus mindig tudjon visszaadni.\n   - totalKids: A gyerekek teljes száma.\n   - oneDollarKids: Azoknak a gyerekeknek a száma, akiknek pontosan 1 dollárjuk van.\n   - twoDollarKids: Azoknak a gyerekeknek a száma, akiknek pontosan 2 dollárjuk van.\n   A jegyárus kezdetben nem rendelkezik aprópénzzel, és a jegy ára 1 dollár.\n   Az azonos összeggel rendelkező gyerekek különböző permutációi különböző elrendezéseknek számítanak.\n   Példa:\n   >>> CountQueueArrangements(4, 2, 2)\n   8"
    },
    "docstring_bertscore": {
      "sq": "0.9836642402029288",
      "hy": "0.9497081779346336",
      "bn": "0.9413551745209734",
      "bg": "0.974693297673869",
      "zh": "0.9496005202681126",
      "fr": "0.9754913945448672",
      "de": "0.9831724313794863",
      "ha": "0.9806565789732985",
      "hi": "0.9648485800986368",
      "hu": "0.9239188037825878"
    }
  },
  {
    "task_id": "C#/38",
    "prompt": {
      "en": "using System;\nusing System.Collections.Generic;\nusing System.Diagnostics;\n\nclass Program\n{\n\n/* Determines the minimum absolute difference between elements of two sorted arrays.\n   Each array is assumed to be sorted in ascending order.\n   Examples:\n   >>> MinArrayDistance(new[] {1, 3, 5}, new[] {2, 4, 6})\n   1\n   >>> MinArrayDistance(new[] {10, 20, 30}, new[] {15, 25, 35})\n   5\n*/\nstatic int MinArrayDistance(int[] array1, int[] array2)",
      "sq": "using System;\nusing System.Collections.Generic;\nusing System.Diagnostics;\n\nclass Program\n{\n\n/* Përcakton diferencën minimale absolute midis elementeve të dy vargjeve të renditura.\n   Çdo varg supozohet të jetë i renditur në rritje.\n   Shembuj:\n   >>> MinArrayDistance(new[] {1, 3, 5}, new[] {2, 4, 6})\n   1\n   >>> MinArrayDistance(new[] {10, 20, 30}, new[] {15, 25, 35})\n   5\n*/\nstatic int MinArrayDistance(int[] array1, int[] array2)",
      "hy": "using System;\nusing System.Collections.Generic;\nusing System.Diagnostics;\n\nclass Program\n{\n\n/* Որոշում է նվազագույն բացարձակ տարբերությունը երկու դասավորված զանգվածների տարրերի միջև:\n   Յուրաքանչյուր զանգված ենթադրվում է, որ դասավորված է աճման կարգով:\n   Օրինակներ:\n   >>> MinArrayDistance(new[] {1, 3, 5}, new[] {2, 4, 6})\n   1\n   >>> MinArrayDistance(new[] {10, 20, 30}, new[] {15, 25, 35})\n   5\n*/\nstatic int MinArrayDistance(int[] array1, int[] array2)",
      "bn": "using System;\nusing System.Collections.Generic;\nusing System.Diagnostics;\n\nclass Program\n{\n\n/* দুটি সাজানো অ্যারের উপাদানগুলির মধ্যে সর্বনিম্ন পরম পার্থক্য নির্ধারণ করে।\n   প্রতিটি অ্যারে ক্রমবর্ধমান ক্রমে সাজানো বলে ধরা হয়।\n   উদাহরণ:\n   >>> MinArrayDistance(new[] {1, 3, 5}, new[] {2, 4, 6})\n   1\n   >>> MinArrayDistance(new[] {10, 20, 30}, new[] {15, 25, 35})\n   5\n*/\nstatic int MinArrayDistance(int[] array1, int[] array2)",
      "bg": "using System;\nusing System.Collections.Generic;\nusing System.Diagnostics;\n\nclass Program\n{\n\n/* Определя минималната абсолютна разлика между елементите на два сортирани масива.\n   Всеки масив се приема, че е сортиран във възходящ ред.\n   Примери:\n   >>> MinArrayDistance(new[] {1, 3, 5}, new[] {2, 4, 6})\n   1\n   >>> MinArrayDistance(new[] {10, 20, 30}, new[] {15, 25, 35})\n   5\n*/\nstatic int MinArrayDistance(int[] array1, int[] array2)",
      "zh": "using System;\nusing System.Collections.Generic;\nusing System.Diagnostics;\n\nclass Program\n{\n\n/* 确定两个已排序数组元素之间的最小绝对差。\n   假设每个数组都是按升序排序的。\n   例子:\n   >>> MinArrayDistance(new[] {1, 3, 5}, new[] {2, 4, 6})\n   1\n   >>> MinArrayDistance(new[] {10, 20, 30}, new[] {15, 25, 35})\n   5\n*/\nstatic int MinArrayDistance(int[] array1, int[] array2)",
      "fr": "using System;\nusing System.Collections.Generic;\nusing System.Diagnostics;\n\nclass Program\n{\n\n/* Détermine la différence absolue minimale entre les éléments de deux tableaux triés.\n   Chaque tableau est supposé être trié par ordre croissant.\n   Exemples :\n   >>> MinArrayDistance(new[] {1, 3, 5}, new[] {2, 4, 6})\n   1\n   >>> MinArrayDistance(new[] {10, 20, 30}, new[] {15, 25, 35})\n   5\n*/\nstatic int MinArrayDistance(int[] array1, int[] array2)",
      "de": "using System;\nusing System.Collections.Generic;\nusing System.Diagnostics;\n\nclass Program\n{\n\n/* Bestimmt den minimalen absoluten Unterschied zwischen Elementen von zwei sortierten Arrays.\n   Es wird angenommen, dass jedes Array in aufsteigender Reihenfolge sortiert ist.\n   Beispiele:\n   >>> MinArrayDistance(new[] {1, 3, 5}, new[] {2, 4, 6})\n   1\n   >>> MinArrayDistance(new[] {10, 20, 30}, new[] {15, 25, 35})\n   5\n*/\nstatic int MinArrayDistance(int[] array1, int[] array2)",
      "ha": "using System;\nusing System.Collections.Generic;\nusing System.Diagnostics;\n\nclass Program\n{\n\n/* Yana tantance mafi ƙarancin bambanci tsakanin abubuwan da ke cikin jerin abubuwa guda biyu da aka tsara.\n   Ana ɗaukar kowanne jeri an tsara shi ne a tsari mai ƙaruwa.\n   Misalai:\n   >>> MinArrayDistance(new[] {1, 3, 5}, new[] {2, 4, 6})\n   1\n   >>> MinArrayDistance(new[] {10, 20, 30}, new[] {15, 25, 35})\n   5\n*/\nstatic int MinArrayDistance(int[] array1, int[] array2)",
      "hi": "using System;\nusing System.Collections.Generic;\nusing System.Diagnostics;\n\nclass Program\n{\n\n/* दो क्रमबद्ध ऐरे के तत्वों के बीच न्यूनतम निरपेक्ष अंतर निर्धारित करता है।\n   प्रत्येक ऐरे को आरोही क्रम में क्रमबद्ध माना जाता है।\n   उदाहरण:\n   >>> MinArrayDistance(new[] {1, 3, 5}, new[] {2, 4, 6})\n   1\n   >>> MinArrayDistance(new[] {10, 20, 30}, new[] {15, 25, 35})\n   5\n*/\nstatic int MinArrayDistance(int[] array1, int[] array2)",
      "hu": "using System;\nusing System.Collections.Generic;\nusing System.Diagnostics;\n\nclass Program\n{\n\n/* Meghatározza a minimális abszolút különbséget két rendezett tömb elemei között.\n   Feltételezzük, hogy mindkét tömb növekvő sorrendben van rendezve.\n   Példák:\n   >>> MinArrayDistance(new[] {1, 3, 5}, new[] {2, 4, 6})\n   1\n   >>> MinArrayDistance(new[] {10, 20, 30}, new[] {15, 25, 35})\n   5\n*/\nstatic int MinArrayDistance(int[] array1, int[] array2)"
    },
    "prompt_bertscore": {
      "sq": "1",
      "hy": "1",
      "bn": "0.998668183295161",
      "bg": "0.9977775246666006",
      "zh": "0.9817859913198628",
      "fr": "0.9977775246666006",
      "de": "0.9917431336907607",
      "ha": "0.9836974114765615",
      "hi": "0.9966532767099432",
      "hu": "0.9844951110867977"
    },
    "canonical_solution": "{\n    int i = 0, j = 0;\n    int minDistance = int.MaxValue;\n\n    while (i < array1.Length && j < array2.Length)\n    {\n        int diff = Math.Abs(array1[i] - array2[j]);\n        minDistance = Math.Min(minDistance, diff);\n\n        if (array1[i] < array2[j])\n            i++;\n        else\n            j++;\n    }\n\n    return minDistance;\n}",
    "instruction": {
      "en": "Write a C# function `static int MinArrayDistance(int[] array1, int[] array2)` to solve the following problem:\nDetermines the minimum absolute difference between elements of two sorted arrays.\n   Each array is assumed to be sorted in ascending order.\n   Examples:\n   >>> MinArrayDistance(new[] {1, 3, 5}, new[] {2, 4, 6})\n   1\n   >>> MinArrayDistance(new[] {10, 20, 30}, new[] {15, 25, 35})\n   5",
      "sq": "Shkruani një funksion në C# `static int MinArrayDistance(int[] array1, int[] array2)` për të zgjidhur problemin e mëposhtëm:\nPërcakton diferencën minimale absolute midis elementeve të dy vargjeve të renditura.\n   Çdo varg supozohet të jetë i renditur në rend rritës.\n   Shembuj:\n   >>> MinArrayDistance(new[] {1, 3, 5}, new[] {2, 4, 6})\n   1\n   >>> MinArrayDistance(new[] {10, 20, 30}, new[] {15, 25, 35})\n   5",
      "hy": "Գրեք C# ֆունկցիա `static int MinArrayDistance(int[] array1, int[] array2)` հետևյալ խնդիրը լուծելու համար:\nՈրոշում է երկու սորտավորված զանգվածների տարրերի միջև նվազագույն բացարձակ տարբերությունը:\n   Յուրաքանչյուր զանգված ենթադրվում է, որ սորտավորված է աճման կարգով:\n   Օրինակներ:\n   >>> MinArrayDistance(new[] {1, 3, 5}, new[] {2, 4, 6})\n   1\n   >>> MinArrayDistance(new[] {10, 20, 30}, new[] {15, 25, 35})\n   5",
      "bn": "C# ফাংশন `static int MinArrayDistance(int[] array1, int[] array2)` লিখুন নিম্নলিখিত সমস্যার সমাধানের জন্য:\nদুটি সাজানো অ্যারের উপাদানগুলির মধ্যে সর্বনিম্ন পার্থক্য নির্ধারণ করে।\n   প্রতিটি অ্যারে ক্রমবর্ধমান ক্রমে সাজানো বলে ধরা হয়।\n   উদাহরণ:\n   >>> MinArrayDistance(new[] {1, 3, 5}, new[] {2, 4, 6})\n   1\n   >>> MinArrayDistance(new[] {10, 20, 30}, new[] {15, 25, 35})\n   5",
      "bg": "Напишете C# функция `static int MinArrayDistance(int[] array1, int[] array2)`, за да решите следния проблем:\nОпределя минималната абсолютна разлика между елементите на два сортирани масива.\n   Всеки масив се предполага, че е сортиран във възходящ ред.\n   Примери:\n   >>> MinArrayDistance(new[] {1, 3, 5}, new[] {2, 4, 6})\n   1\n   >>> MinArrayDistance(new[] {10, 20, 30}, new[] {15, 25, 35})\n   5",
      "zh": "编写一个 C# 函数 `static int MinArrayDistance(int[] array1, int[] array2)` 来解决以下问题：\n确定两个已排序数组元素之间的最小绝对差。\n假设每个数组都是按升序排序的。\n示例：\n>>> MinArrayDistance(new[] {1, 3, 5}, new[] {2, 4, 6})\n1\n>>> MinArrayDistance(new[] {10, 20, 30}, new[] {15, 25, 35})\n5",
      "fr": "Écrire une fonction C# `static int MinArrayDistance(int[] array1, int[] array2)` pour résoudre le problème suivant :  \nDétermine la différence absolue minimale entre les éléments de deux tableaux triés.  \n   Chaque tableau est supposé trié par ordre croissant.  \n   Exemples :  \n   >>> MinArrayDistance(new[] {1, 3, 5}, new[] {2, 4, 6})  \n   1  \n   >>> MinArrayDistance(new[] {10, 20, 30}, new[] {15, 25, 35})  \n   5  ",
      "de": "Schreiben Sie eine C#-Funktion `static int MinArrayDistance(int[] array1, int[] array2)`, um das folgende Problem zu lösen:\nBestimmt den minimalen absoluten Unterschied zwischen Elementen von zwei sortierten Arrays.\n   Es wird angenommen, dass jedes Array in aufsteigender Reihenfolge sortiert ist.\n   Beispiele:\n   >>> MinArrayDistance(new[] {1, 3, 5}, new[] {2, 4, 6})\n   1\n   >>> MinArrayDistance(new[] {10, 20, 30}, new[] {15, 25, 35})\n   5",
      "ha": "Rubuta wani aikin C# `static int MinArrayDistance(int[] array1, int[] array2)` don warware matsalar mai zuwa:\nYana tantance mafi ƙarancin bambanci na ainihi tsakanin abubuwan da ke cikin jerin abubuwa guda biyu da aka tsara.\n   Ana ɗauka kowace jeri an tsara ta cikin tsari mai hawa sama.\n   Misalai:\n   >>> MinArrayDistance(new[] {1, 3, 5}, new[] {2, 4, 6})\n   1\n   >>> MinArrayDistance(new[] {10, 20, 30}, new[] {15, 25, 35})\n   5",
      "hi": "C# फ़ंक्शन `static int MinArrayDistance(int[] array1, int[] array2)` लिखें ताकि निम्नलिखित समस्या का समाधान हो सके:\nदो क्रमबद्ध ऐरे के तत्वों के बीच न्यूनतम परिमाणात्मक अंतर निर्धारित करता है।\n   प्रत्येक ऐरे को आरोही क्रम में क्रमबद्ध माना जाता है।\n   उदाहरण:\n   >>> MinArrayDistance(new[] {1, 3, 5}, new[] {2, 4, 6})\n   1\n   >>> MinArrayDistance(new[] {10, 20, 30}, new[] {15, 25, 35})\n   5",
      "hu": "Írj egy C# függvényt `static int MinArrayDistance(int[] array1, int[] array2)` a következő probléma megoldására:\nMeghatározza a minimum abszolút különbséget két rendezett tömb elemei között.\n   Feltételezzük, hogy minden tömb növekvő sorrendben van rendezve.\n   Példák:\n   >>> MinArrayDistance(new[] {1, 3, 5}, new[] {2, 4, 6})\n   1\n   >>> MinArrayDistance(new[] {10, 20, 30}, new[] {15, 25, 35})\n   5"
    },
    "instruction_bertscore": {
      "sq": "0.9949118841594103",
      "hy": "1",
      "bn": "0.9607369312112147",
      "bg": "0.9961658377548835",
      "zh": "0.9815239978472778",
      "fr": "0.9935886085609559",
      "de": "0.993863115747546",
      "ha": "0.990298892190256",
      "hi": "0.9786579600793254",
      "hu": "0.9894972199723993"
    },
    "level": "easy",
    "test": "    static void Main()\n    {\n\n        Debug.Assert(MinArrayDistance(new[] {1, 3, 5}, new[] {2, 4, 6}) == 1);\n        Debug.Assert(MinArrayDistance(new[] {10, 20, 30}, new[] {15, 25, 35}) == 5);\n\n    }\n}",
    "entry_point": "MinArrayDistance",
    "signature": "static int MinArrayDistance(int[] array1, int[] array2)",
    "docstring": {
      "en": "Determines the minimum absolute difference between elements of two sorted arrays.\n   Each array is assumed to be sorted in ascending order.\n   Examples:\n   >>> MinArrayDistance(new[] {1, 3, 5}, new[] {2, 4, 6})\n   1\n   >>> MinArrayDistance(new[] {10, 20, 30}, new[] {15, 25, 35})\n   5",
      "sq": "Përcakton diferencën minimale absolute midis elementeve të dy vargjeve të renditura.\n   Çdo varg supozohet të jetë i renditur në rritje.\n   Shembuj:\n   >>> MinArrayDistance(new[] {1, 3, 5}, new[] {2, 4, 6})\n   1\n   >>> MinArrayDistance(new[] {10, 20, 30}, new[] {15, 25, 35})\n   5",
      "hy": "Հաշվում է երկու դասավորված զանգվածների տարրերի միջև նվազագույն բացարձակ տարբերությունը:\n   Յուրաքանչյուր զանգված ենթադրվում է, որ դասավորված է աճման կարգով:\n   Օրինակներ:\n   >>> MinArrayDistance(new[] {1, 3, 5}, new[] {2, 4, 6})\n   1\n   >>> MinArrayDistance(new[] {10, 20, 30}, new[] {15, 25, 35})\n   5",
      "bn": "দুটি সাজানো অ্যারের উপাদানগুলির মধ্যে সর্বনিম্ন পরম পার্থক্য নির্ধারণ করে।  \nপ্রতিটি অ্যারে ঊর্ধ্বক্রমে সাজানো বলে ধরা হয়।  \nউদাহরণসমূহ:  \n>>> MinArrayDistance(new[] {1, 3, 5}, new[] {2, 4, 6})  \n1  \n>>> MinArrayDistance(new[] {10, 20, 30}, new[] {15, 25, 35})  \n5",
      "bg": "Определя минималната абсолютна разлика между елементите на два сортирани масива.\n   Всеки масив се предполага, че е сортиран във възходящ ред.\n   Примери:\n   >>> MinArrayDistance(new[] {1, 3, 5}, new[] {2, 4, 6})\n   1\n   >>> MinArrayDistance(new[] {10, 20, 30}, new[] {15, 25, 35})\n   5",
      "zh": "确定两个已排序数组元素之间的最小绝对差值。\n   每个数组假定按升序排序。\n   示例：\n   >>> MinArrayDistance(new[] {1, 3, 5}, new[] {2, 4, 6})\n   1\n   >>> MinArrayDistance(new[] {10, 20, 30}, new[] {15, 25, 35})\n   5",
      "fr": "Détermine la différence absolue minimale entre les éléments de deux tableaux triés.\n   Chaque tableau est supposé être trié par ordre croissant.\n   Exemples :\n   >>> MinArrayDistance(new[] {1, 3, 5}, new[] {2, 4, 6})\n   1\n   >>> MinArrayDistance(new[] {10, 20, 30}, new[] {15, 25, 35})\n   5",
      "de": "Bestimmt den minimalen absoluten Unterschied zwischen Elementen von zwei sortierten Arrays.\n   Es wird angenommen, dass jedes Array in aufsteigender Reihenfolge sortiert ist.\n   Beispiele:\n   >>> MinArrayDistance(new[] {1, 3, 5}, new[] {2, 4, 6})\n   1\n   >>> MinArrayDistance(new[] {10, 20, 30}, new[] {15, 25, 35})\n   5",
      "ha": "Yana tantance mafi ƙarancin bambanci na ainihi tsakanin abubuwan da ke cikin jerin abubuwa guda biyu da aka tsara.\n   Ana ɗauka kowanne jerin abubuwa an tsara su ne a cikin tsari mai ƙaruwa.\n   Misalai:\n   >>> MinArrayDistance(new[] {1, 3, 5}, new[] {2, 4, 6})\n   1\n   >>> MinArrayDistance(new[] {10, 20, 30}, new[] {15, 25, 35})\n   5",
      "hi": "न्यूनतम निरपेक्ष अंतर निर्धारित करता है जो दो क्रमबद्ध ऐरे के तत्वों के बीच होता है।  \nप्रत्येक ऐरे को आरोही क्रम में क्रमबद्ध माना जाता है।  \nउदाहरण:  \n>>> MinArrayDistance(new[] {1, 3, 5}, new[] {2, 4, 6})  \n1  \n>>> MinArrayDistance(new[] {10, 20, 30}, new[] {15, 25, 35})  \n5  ",
      "hu": "Meghatározza a két rendezett tömb elemei közötti minimális abszolút különbséget.\n   Feltételezzük, hogy minden tömb növekvő sorrendben van rendezve.\n   Példák:\n   >>> MinArrayDistance(new[] {1, 3, 5}, new[] {2, 4, 6})\n   1\n   >>> MinArrayDistance(new[] {10, 20, 30}, new[] {15, 25, 35})\n   5"
    },
    "docstring_bertscore": {
      "sq": "0.9921825040936099",
      "hy": "0.9833110753854487",
      "bn": "1",
      "bg": "0.9975167229763018",
      "zh": "0.9875468682610177",
      "fr": "0.9903519265019923",
      "de": "0.9921797232682754",
      "ha": "0.9813009359293756",
      "hi": "0.9982955527003397",
      "hu": "0.9881060127836309"
    }
  },
  {
    "task_id": "C#/39",
    "prompt": {
      "en": "using System;\nusing System.Collections.Generic;\nusing System.Diagnostics;\n\nclass Program\n{\n\n\n/* Sort a list of integers in descending order based on their absolute values.\n    Examples:\n    >>> SortByAbsoluteDescending(new List<int> { 3, -4, 2 })\n    [-4, 3, 2]\n    >>> SortByAbsoluteDescending(new List<int> { 0, 1, 2, -3 })\n    [-3, 2, 1, 0]\n*/\nstatic List<int> SortByAbsoluteDescending(List<int> numbers)",
      "sq": "using System;\nusing System.Collections.Generic;\nusing System.Diagnostics;\n\nclass Program\n{\n\n\n/* Rendit një listë të numrave të plotë në rend zbritës bazuar në vlerat e tyre absolute.\n    Shembuj:\n    >>> SortByAbsoluteDescending(new List<int> { 3, -4, 2 })\n    [-4, 3, 2]\n    >>> SortByAbsoluteDescending(new List<int> { 0, 1, 2, -3 })\n    [-3, 2, 1, 0]\n*/\nstatic List<int> SortByAbsoluteDescending(List<int> numbers)",
      "hy": "using System;\nusing System.Collections.Generic;\nusing System.Diagnostics;\n\nclass Program\n{\n\n\n/* Դասավորել ամբողջ թվերի ցուցակը նվազման կարգով՝ հիմնվելով նրանց բացարձակ արժեքների վրա։\n    Օրինակներ:\n    >>> SortByAbsoluteDescending(new List<int> { 3, -4, 2 })\n    [-4, 3, 2]\n    >>> SortByAbsoluteDescending(new List<int> { 0, 1, 2, -3 })\n    [-3, 2, 1, 0]\n*/\nstatic List<int> SortByAbsoluteDescending(List<int> numbers)",
      "bn": "using System;\nusing System.Collections.Generic;\nusing System.Diagnostics;\n\nclass Program\n{\n\n\n/* পূর্ণসংখ্যার একটি তালিকাকে তাদের পরম মানের ভিত্তিতে অবতরণী ক্রমে সাজান।\n    উদাহরণ:\n    >>> SortByAbsoluteDescending(new List<int> { 3, -4, 2 })\n    [-4, 3, 2]\n    >>> SortByAbsoluteDescending(new List<int> { 0, 1, 2, -3 })\n    [-3, 2, 1, 0]\n*/\nstatic List<int> SortByAbsoluteDescending(List<int> numbers)",
      "bg": "using System;\nusing System.Collections.Generic;\nusing System.Diagnostics;\n\nclass Program\n{\n\n\n/* Сортиране на списък от цели числа в низходящ ред въз основа на техните абсолютни стойности.\n    Примери:\n    >>> SortByAbsoluteDescending(new List<int> { 3, -4, 2 })\n    [-4, 3, 2]\n    >>> SortByAbsoluteDescending(new List<int> { 0, 1, 2, -3 })\n    [-3, 2, 1, 0]\n*/\nstatic List<int> SortByAbsoluteDescending(List<int> numbers)",
      "zh": "using System;\nusing System.Collections.Generic;\nusing System.Diagnostics;\n\nclass Program\n{\n\n\n/* 根据整数的绝对值按降序排序列表。\n    例子:\n    >>> SortByAbsoluteDescending(new List<int> { 3, -4, 2 })\n    [-4, 3, 2]\n    >>> SortByAbsoluteDescending(new List<int> { 0, 1, 2, -3 })\n    [-3, 2, 1, 0]\n*/\nstatic List<int> SortByAbsoluteDescending(List<int> numbers)",
      "fr": "using System;\nusing System.Collections.Generic;\nusing System.Diagnostics;\n\nclass Program\n{\n\n\n/* Trier une liste d'entiers par ordre décroissant en fonction de leurs valeurs absolues.\n    Exemples :\n    >>> SortByAbsoluteDescending(new List<int> { 3, -4, 2 })\n    [-4, 3, 2]\n    >>> SortByAbsoluteDescending(new List<int> { 0, 1, 2, -3 })\n    [-3, 2, 1, 0]\n*/\nstatic List<int> SortByAbsoluteDescending(List<int> numbers)",
      "de": "using System;\nusing System.Collections.Generic;\nusing System.Diagnostics;\n\nclass Program\n{\n\n\n/* Sortiere eine Liste von ganzen Zahlen in absteigender Reihenfolge basierend auf ihren Absolutwerten.\n    Beispiele:\n    >>> SortByAbsoluteDescending(new List<int> { 3, -4, 2 })\n    [-4, 3, 2]\n    >>> SortByAbsoluteDescending(new List<int> { 0, 1, 2, -3 })\n    [-3, 2, 1, 0]\n*/\nstatic List<int> SortByAbsoluteDescending(List<int> numbers)",
      "ha": "using System;\nusing System.Collections.Generic;\nusing System.Diagnostics;\n\nclass Program\n{\n\n\n/* Jera jerin lambobin cikakkun lambobi a cikin tsari mai saukowa bisa ga ƙimar su ta cikakke.\n    Misalai:\n    >>> SortByAbsoluteDescending(new List<int> { 3, -4, 2 })\n    [-4, 3, 2]\n    >>> SortByAbsoluteDescending(new List<int> { 0, 1, 2, -3 })\n    [-3, 2, 1, 0]\n*/\nstatic List<int> SortByAbsoluteDescending(List<int> numbers)",
      "hi": "using System;\nusing System.Collections.Generic;\nusing System.Diagnostics;\n\nclass Program\n{\n\n\n/* पूर्णांक की एक सूची को उनके परिमाण के आधार पर अवरोही क्रम में सॉर्ट करें।\n    उदाहरण:\n    >>> SortByAbsoluteDescending(new List<int> { 3, -4, 2 })\n    [-4, 3, 2]\n    >>> SortByAbsoluteDescending(new List<int> { 0, 1, 2, -3 })\n    [-3, 2, 1, 0]\n*/\nstatic List<int> SortByAbsoluteDescending(List<int> numbers)",
      "hu": "using System;\nusing System.Collections.Generic;\nusing System.Diagnostics;\n\nclass Program\n{\n\n\n/* Egy egész számokat tartalmazó lista rendezése csökkenő sorrendben az abszolút értékük alapján.\n    Példák:\n    >>> SortByAbsoluteDescending(new List<int> { 3, -4, 2 })\n    [-4, 3, 2]\n    >>> SortByAbsoluteDescending(new List<int> { 0, 1, 2, -3 })\n    [-3, 2, 1, 0]\n*/\nstatic List<int> SortByAbsoluteDescending(List<int> numbers)"
    },
    "prompt_bertscore": {
      "sq": "1",
      "hy": "1",
      "bn": "0.9989444781551806",
      "bg": "0.9955117479101356",
      "zh": "0.9902246044277491",
      "fr": "1",
      "de": "1",
      "ha": "0.9870073881461269",
      "hi": "0.9863995791801602",
      "hu": "0.9955117479101356"
    },
    "canonical_solution": "{\n    numbers.Sort((a, b) => Math.Abs(b).CompareTo(Math.Abs(a)));\n    return numbers;\n}",
    "instruction": {
      "en": "Write a C# function `static List<int> SortByAbsoluteDescending(List<int> numbers)` to solve the following problem:\nSort a list of integers in descending order based on their absolute values.\n    Examples:\n    >>> SortByAbsoluteDescending(new List<int> { 3, -4, 2 })\n    [-4, 3, 2]\n    >>> SortByAbsoluteDescending(new List<int> { 0, 1, 2, -3 })\n    [-3, 2, 1, 0]",
      "sq": "Shkruani një funksion C# `static List<int> SortByAbsoluteDescending(List<int> numbers)` për të zgjidhur problemin në vijim:\nRenditni një listë të numrave të plotë në rend zbritës bazuar në vlerat e tyre absolute.\n    Shembuj:\n    >>> SortByAbsoluteDescending(new List<int> { 3, -4, 2 })\n    [-4, 3, 2]\n    >>> SortByAbsoluteDescending(new List<int> { 0, 1, 2, -3 })\n    [-3, 2, 1, 0]",
      "hy": "Գրեք C# ֆունկցիա `static List<int> SortByAbsoluteDescending(List<int> numbers)`՝ հետևյալ խնդիրը լուծելու համար:\nՏրված ամբողջ թվերի ցուցակը դասավորել նվազման կարգով՝ հիմնվելով նրանց բացարձակ արժեքների վրա։\n    Օրինակներ:\n    >>> SortByAbsoluteDescending(new List<int> { 3, -4, 2 })\n    [-4, 3, 2]\n    >>> SortByAbsoluteDescending(new List<int> { 0, 1, 2, -3 })\n    [-3, 2, 1, 0]",
      "bn": "একটি C# ফাংশন `static List<int> SortByAbsoluteDescending(List<int> numbers)` লিখুন নিম্নলিখিত সমস্যার সমাধানের জন্য:\nএকটি পূর্ণসংখ্যার তালিকাকে তাদের মানের ভিত্তিতে অবরোহ ক্রমে সাজান।\n    উদাহরণসমূহ:\n    >>> SortByAbsoluteDescending(new List<int> { 3, -4, 2 })\n    [-4, 3, 2]\n    >>> SortByAbsoluteDescending(new List<int> { 0, 1, 2, -3 })\n    [-3, 2, 1, 0]",
      "bg": "Напишете C# функция `static List<int> SortByAbsoluteDescending(List<int> numbers)`, за да решите следния проблем:\nСортирайте списък от цели числа в низходящ ред въз основа на техните абсолютни стойности.\n    Примери:\n    >>> SortByAbsoluteDescending(new List<int> { 3, -4, 2 })\n    [-4, 3, 2]\n    >>> SortByAbsoluteDescending(new List<int> { 0, 1, 2, -3 })\n    [-3, 2, 1, 0]",
      "zh": "编写一个 C# 函数 `static List<int> SortByAbsoluteDescending(List<int> numbers)` 来解决以下问题：  \n根据整数的绝对值以降序排序列表。  \n    示例:  \n    >>> SortByAbsoluteDescending(new List<int> { 3, -4, 2 })  \n    [-4, 3, 2]  \n    >>> SortByAbsoluteDescending(new List<int> { 0, 1, 2, -3 })  \n    [-3, 2, 1, 0]",
      "fr": "Écrire une fonction C# `static List<int> SortByAbsoluteDescending(List<int> numbers)` pour résoudre le problème suivant :\nTrier une liste d'entiers par ordre décroissant en fonction de leurs valeurs absolues.\n    Exemples :\n    >>> SortByAbsoluteDescending(new List<int> { 3, -4, 2 })\n    [-4, 3, 2]\n    >>> SortByAbsoluteDescending(new List<int> { 0, 1, 2, -3 })\n    [-3, 2, 1, 0]",
      "de": "Schreiben Sie eine C#-Funktion `static List<int> SortByAbsoluteDescending(List<int> numbers)`, um das folgende Problem zu lösen:\nSortieren Sie eine Liste von ganzen Zahlen in absteigender Reihenfolge basierend auf ihren absoluten Werten.\n    Beispiele:\n    >>> SortByAbsoluteDescending(new List<int> { 3, -4, 2 })\n    [-4, 3, 2]\n    >>> SortByAbsoluteDescending(new List<int> { 0, 1, 2, -3 })\n    [-3, 2, 1, 0]",
      "ha": "Rubuta aikin C# `static List<int> SortByAbsoluteDescending(List<int> numbers)` don warware matsalar mai zuwa:\nJera jerin lambobi a cikin tsarin saukowa bisa ga ƙimarsu ta cikakke.\n    Misalai:\n    >>> SortByAbsoluteDescending(new List<int> { 3, -4, 2 })\n    [-4, 3, 2]\n    >>> SortByAbsoluteDescending(new List<int> { 0, 1, 2, -3 })\n    [-3, 2, 1, 0]",
      "hi": "C# फ़ंक्शन `static List<int> SortByAbsoluteDescending(List<int> numbers)` लिखें ताकि निम्नलिखित समस्या का समाधान किया जा सके:\nपूर्णांक की एक सूची को उनके परिमाण के आधार पर अवरोही क्रम में क्रमबद्ध करें।\n    उदाहरण:\n    >>> SortByAbsoluteDescending(new List<int> { 3, -4, 2 })\n    [-4, 3, 2]\n    >>> SortByAbsoluteDescending(new List<int> { 0, 1, 2, -3 })\n    [-3, 2, 1, 0]",
      "hu": "Írj egy C# függvényt `static List<int> SortByAbsoluteDescending(List<int> numbers)` a következő probléma megoldására:\nRendezz egy egész számokból álló listát csökkenő sorrendbe az abszolút értékük alapján.\n    Példák:\n    >>> SortByAbsoluteDescending(new List<int> { 3, -4, 2 })\n    [-4, 3, 2]\n    >>> SortByAbsoluteDescending(new List<int> { 0, 1, 2, -3 })\n    [-3, 2, 1, 0]"
    },
    "instruction_bertscore": {
      "sq": "0.999999801369619",
      "hy": "0.9939801090419756",
      "bn": "0.999999801369619",
      "bg": "0.9981161894662651",
      "zh": "0.9861222911682355",
      "fr": "0.999999801369619",
      "de": "0.999999801369619",
      "ha": "0.9855931398331585",
      "hi": "0.9691691881469078",
      "hu": "0.999999801369619"
    },
    "level": "easy",
    "test": "    static void Main()\n    {\n        Debug.Assert(SortByAbsoluteDescending(new List<int> { 3, -4, 2 }).SequenceEqual(new List<int> { -4, 3, 2 }));\n        Debug.Assert(SortByAbsoluteDescending(new List<int> { 0, 1, 2, -3 }).SequenceEqual(new List<int> { -3, 2, 1, 0 }));\n\n\n    }\n}",
    "entry_point": "SortByAbsoluteDescending",
    "signature": "static List<int> SortByAbsoluteDescending(List<int> numbers)",
    "docstring": {
      "en": "Sort a list of integers in descending order based on their absolute values.\n    Examples:\n    >>> SortByAbsoluteDescending(new List<int> { 3, -4, 2 })\n    [-4, 3, 2]\n    >>> SortByAbsoluteDescending(new List<int> { 0, 1, 2, -3 })\n    [-3, 2, 1, 0]",
      "sq": "Rendit një listë të numrave të plotë në rend zbritës bazuar në vlerat e tyre absolute.\n    Shembuj:\n    >>> SortByAbsoluteDescending(new List<int> { 3, -4, 2 })\n    [-4, 3, 2]\n    >>> SortByAbsoluteDescending(new List<int> { 0, 1, 2, -3 })\n    [-3, 2, 1, 0]",
      "hy": "Թվերի ցուցակը դասավորել նվազման կարգով՝ հիմնվելով դրանց բացարձակ արժեքների վրա:\n    Օրինակներ:\n    >>> SortByAbsoluteDescending(new List<int> { 3, -4, 2 })\n    [-4, 3, 2]\n    >>> SortByAbsoluteDescending(new List<int> { 0, 1, 2, -3 })\n    [-3, 2, 1, 0]",
      "bn": "একটি পূর্ণসংখ্যার তালিকাকে তাদের মানের উপর ভিত্তি করে অবরোহী ক্রমে সাজান।\n    উদাহরণসমূহ:\n    >>> SortByAbsoluteDescending(new List<int> { 3, -4, 2 })\n    [-4, 3, 2]\n    >>> SortByAbsoluteDescending(new List<int> { 0, 1, 2, -3 })\n    [-3, 2, 1, 0]",
      "bg": "Сортирайте списък от цели числа в низходящ ред въз основа на техните абсолютни стойности.\n    Примери:\n    >>> SortByAbsoluteDescending(new List<int> { 3, -4, 2 })\n    [-4, 3, 2]\n    >>> SortByAbsoluteDescending(new List<int> { 0, 1, 2, -3 })\n    [-3, 2, 1, 0]",
      "zh": "根据整数的绝对值以降序排序列表。\n    示例：\n    >>> SortByAbsoluteDescending(new List<int> { 3, -4, 2 })\n    [-4, 3, 2]\n    >>> SortByAbsoluteDescending(new List<int> { 0, 1, 2, -3 })\n    [-3, 2, 1, 0]",
      "fr": "Trier une liste d'entiers par ordre décroissant en fonction de leurs valeurs absolues.\n    Exemples:\n    >>> SortByAbsoluteDescending(new List<int> { 3, -4, 2 })\n    [-4, 3, 2]\n    >>> SortByAbsoluteDescending(new List<int> { 0, 1, 2, -3 })\n    [-3, 2, 1, 0]",
      "de": "Sortiere eine Liste von ganzen Zahlen in absteigender Reihenfolge basierend auf ihren Absolutwerten.\n    Beispiele:\n    >>> SortByAbsoluteDescending(new List<int> { 3, -4, 2 })\n    [-4, 3, 2]\n    >>> SortByAbsoluteDescending(new List<int> { 0, 1, 2, -3 })\n    [-3, 2, 1, 0]",
      "ha": "Jera jerin lambobin cikakkun lambobi a cikin tsari mai saukowa bisa ga ƙimar su ta cikakke.\n    Misalai:\n    >>> SortByAbsoluteDescending(new List<int> { 3, -4, 2 })\n    [-4, 3, 2]\n    >>> SortByAbsoluteDescending(new List<int> { 0, 1, 2, -3 })\n    [-3, 2, 1, 0]",
      "hi": "पूर्णांक की एक सूची को उनके परिमाण के आधार पर अवरोही क्रम में क्रमबद्ध करें।\n    उदाहरण:\n    >>> SortByAbsoluteDescending(new List<int> { 3, -4, 2 })\n    [-4, 3, 2]\n    >>> SortByAbsoluteDescending(new List<int> { 0, 1, 2, -3 })\n    [-3, 2, 1, 0]",
      "hu": "Rendezzen egy egész számokból álló listát csökkenő sorrendbe azok abszolút értékei alapján.\n    Példák:\n    >>> SortByAbsoluteDescending(new List<int> { 3, -4, 2 })\n    [-4, 3, 2]\n    >>> SortByAbsoluteDescending(new List<int> { 0, 1, 2, -3 })\n    [-3, 2, 1, 0]"
    },
    "docstring_bertscore": {
      "sq": "1",
      "hy": "0.9833535822869902",
      "bn": "0.9883433760889676",
      "bg": "1",
      "zh": "0.9798368313907675",
      "fr": "1",
      "de": "1",
      "ha": "1",
      "hi": "0.980050557680761",
      "hu": "1"
    }
  },
  {
    "task_id": "C#/40",
    "prompt": {
      "en": "using System;\nusing System.Collections.Generic;\nusing System.Diagnostics;\n\nclass Program\n{\n\n\n/* Calculates the maximum total value of purchases within a budget, considering main items and their accessories.\n    - `totalMoney` is the total budget.\n    - `items` is a list of tuples, where each tuple represents an item with its price, importance, and category (0 for main items, item number of the main item if an accessory).\n    For example:\n    >>> MaxValueOfPurchases(1000, new List<(int, int, int)> { (800, 2, 0), (400, 5, 1), (300, 5, 1), (400, 3, 0), (500, 2, 0) })\n    2200\n    >>> MaxValueOfPurchases(500, new List<(int, int, int)> { (300, 3, 0), (200, 4, 1), (100, 2, 0) })\n    1700\n*/\npublic static int MaxValueOfPurchases(int totalMoney, List<(int price, int importance, int category)> items)",
      "sq": "using System;\nusing System.Collections.Generic;\nusing System.Diagnostics;\n\nclass Program\n{\n\n\n/* Llogarit vlerën maksimale totale të blerjeve brenda një buxheti, duke marrë parasysh artikujt kryesorë dhe aksesorët e tyre.\n    - `totalMoney` është buxheti total.\n    - `items` është një listë tuples, ku secili tuple përfaqëson një artikull me çmimin, rëndësinë dhe kategorinë e tij (0 për artikujt kryesorë, numri i artikullit kryesor nëse është një aksesor).\n    Për shembull:\n    >>> MaxValueOfPurchases(1000, new List<(int, int, int)> { (800, 2, 0), (400, 5, 1), (300, 5, 1), (400, 3, 0), (500, 2, 0) })\n    2200\n    >>> MaxValueOfPurchases(500, new List<(int, int, int)> { (300, 3, 0), (200, 4, 1), (100, 2, 0) })\n    1700\n*/\npublic static int MaxValueOfPurchases(int totalMoney, List<(int price, int importance, int category)> items)",
      "hy": "using System;\nusing System.Collections.Generic;\nusing System.Diagnostics;\n\nclass Program\n{\n\n\n/* Հաշվարկում է գնումների առավելագույն ընդհանուր արժեքը բյուջեի սահմաններում՝ հաշվի առնելով հիմնական իրերն ու դրանց աքսեսուարները։\n    - `totalMoney`-ը ընդհանուր բյուջեն է։\n    - `items`-ը տուփերի ցուցակ է, որտեղ յուրաքանչյուր տուփ ներկայացնում է իր՝ իր գինը, կարևորությունը և կատեգորիան (0 հիմնական իրերի համար, հիմնական իրի համարի աքսեսուարների համար)։\n    Օրինակ՝\n    >>> MaxValueOfPurchases(1000, new List<(int, int, int)> { (800, 2, 0), (400, 5, 1), (300, 5, 1), (400, 3, 0), (500, 2, 0) })\n    2200\n    >>> MaxValueOfPurchases(500, new List<(int, int, int)> { (300, 3, 0), (200, 4, 1), (100, 2, 0) })\n    1700\n*/\npublic static int MaxValueOfPurchases(int totalMoney, List<(int price, int importance, int category)> items)",
      "bn": "using System;\nusing System.Collections.Generic;\nusing System.Diagnostics;\n\nclass Program\n{\n\n\n/* বাজেটের মধ্যে প্রধান আইটেম এবং তাদের আনুষাঙ্গিক বিবেচনা করে ক্রয়ের সর্বাধিক মোট মান গণনা করে।\n    - `totalMoney` হল মোট বাজেট।\n    - `items` হল টিউপলের একটি তালিকা, যেখানে প্রতিটি টিউপল একটি আইটেমকে উপস্থাপন করে যার মূল্য, গুরুত্ব এবং বিভাগ রয়েছে (0 প্রধান আইটেমের জন্য, আনুষাঙ্গিক হলে প্রধান আইটেমের আইটেম নম্বর)।\n    উদাহরণস্বরূপ:\n    >>> MaxValueOfPurchases(1000, new List<(int, int, int)> { (800, 2, 0), (400, 5, 1), (300, 5, 1), (400, 3, 0), (500, 2, 0) })\n    2200\n    >>> MaxValueOfPurchases(500, new List<(int, int, int)> { (300, 3, 0), (200, 4, 1), (100, 2, 0) })\n    1700\n*/\npublic static int MaxValueOfPurchases(int totalMoney, List<(int price, int importance, int category)> items)",
      "bg": "using System;\nusing System.Collections.Generic;\nusing System.Diagnostics;\n\nclass Program\n{\n\n\n/* Изчислява максималната обща стойност на покупките в рамките на бюджет, като се вземат предвид основните артикули и техните аксесоари.\n    - `totalMoney` е общият бюджет.\n    - `items` е списък от кортежи, където всеки кортеж представлява артикул с неговата цена, важност и категория (0 за основни артикули, номер на основния артикул, ако е аксесоар).\n    Например:\n    >>> MaxValueOfPurchases(1000, new List<(int, int, int)> { (800, 2, 0), (400, 5, 1), (300, 5, 1), (400, 3, 0), (500, 2, 0) })\n    2200\n    >>> MaxValueOfPurchases(500, new List<(int, int, int)> { (300, 3, 0), (200, 4, 1), (100, 2, 0) })\n    1700\n*/\npublic static int MaxValueOfPurchases(int totalMoney, List<(int price, int importance, int category)> items)",
      "zh": "using System;\nusing System.Collections.Generic;\nusing System.Diagnostics;\n\nclass Program\n{\n\n\n/* 计算在预算内购买的最大总价值，考虑主商品及其附件。\n    - `totalMoney` 是总预算。\n    - `items` 是一个元组列表，每个元组表示一个商品及其价格、重要性和类别（0表示主商品，如果是附件则为主商品的编号）。\n    例如：\n    >>> MaxValueOfPurchases(1000, new List<(int, int, int)> { (800, 2, 0), (400, 5, 1), (300, 5, 1), (400, 3, 0), (500, 2, 0) })\n    2200\n    >>> MaxValueOfPurchases(500, new List<(int, int, int)> { (300, 3, 0), (200, 4, 1), (100, 2, 0) })\n    1700\n*/\npublic static int MaxValueOfPurchases(int totalMoney, List<(int price, int importance, int category)> items)",
      "fr": "using System;\nusing System.Collections.Generic;\nusing System.Diagnostics;\n\nclass Program\n{\n\n\n/* Calcule la valeur totale maximale des achats dans un budget, en tenant compte des articles principaux et de leurs accessoires.\n    - `totalMoney` est le budget total.\n    - `items` est une liste de tuples, où chaque tuple représente un article avec son prix, son importance et sa catégorie (0 pour les articles principaux, numéro de l'article principal si un accessoire).\n    Par exemple :\n    >>> MaxValueOfPurchases(1000, new List<(int, int, int)> { (800, 2, 0), (400, 5, 1), (300, 5, 1), (400, 3, 0), (500, 2, 0) })\n    2200\n    >>> MaxValueOfPurchases(500, new List<(int, int, int)> { (300, 3, 0), (200, 4, 1), (100, 2, 0) })\n    1700\n*/\npublic static int MaxValueOfPurchases(int totalMoney, List<(int price, int importance, int category)> items)",
      "de": "using System;\nusing System.Collections.Generic;\nusing System.Diagnostics;\n\nclass Program\n{\n\n\n/* Berechnet den maximalen Gesamtwert der Einkäufe innerhalb eines Budgets, unter Berücksichtigung von Hauptartikeln und deren Zubehör.\n    - `totalMoney` ist das Gesamtbudget.\n    - `items` ist eine Liste von Tupeln, wobei jedes Tupel einen Artikel mit seinem Preis, seiner Wichtigkeit und seiner Kategorie darstellt (0 für Hauptartikel, Artikelnummer des Hauptartikels, wenn ein Zubehör).\n    Zum Beispiel:\n    >>> MaxValueOfPurchases(1000, new List<(int, int, int)> { (800, 2, 0), (400, 5, 1), (300, 5, 1), (400, 3, 0), (500, 2, 0) })\n    2200\n    >>> MaxValueOfPurchases(500, new List<(int, int, int)> { (300, 3, 0), (200, 4, 1), (100, 2, 0) })\n    1700\n*/\npublic static int MaxValueOfPurchases(int totalMoney, List<(int price, int importance, int category)> items)",
      "ha": "using System;\nusing System.Collections.Generic;\nusing System.Diagnostics;\n\nclass Program\n{\n\n\n/* Lissafi na mafi girman jimillar darajar sayayya cikin kasafin kudi, la'akari da manyan abubuwa da kayan haɗi.\n    - `totalMoney` shine jimillar kasafin kudi.\n    - `items` jerin tuples ne, inda kowane tuple ke wakiltar abu tare da farashinsa, mahimmanci, da rukuni (0 don manyan abubuwa, lambar abu na babban abu idan kayan haɗi ne).\n    Alal misali:\n    >>> MaxValueOfPurchases(1000, new List<(int, int, int)> { (800, 2, 0), (400, 5, 1), (300, 5, 1), (400, 3, 0), (500, 2, 0) })\n    2200\n    >>> MaxValueOfPurchases(500, new List<(int, int, int)> { (300, 3, 0), (200, 4, 1), (100, 2, 0) })\n    1700\n*/\npublic static int MaxValueOfPurchases(int totalMoney, List<(int price, int importance, int category)> items)",
      "hi": "using System;\nusing System.Collections.Generic;\nusing System.Diagnostics;\n\nclass Program\n{\n\n\n/* बजट के भीतर खरीदारी के अधिकतम कुल मूल्य की गणना करता है, मुख्य वस्तुओं और उनके सहायक उपकरणों को ध्यान में रखते हुए।\n    - `totalMoney` कुल बजट है।\n    - `items` ट्यूपल की एक सूची है, जहां प्रत्येक ट्यूपल एक वस्तु का प्रतिनिधित्व करता है जिसमें उसकी कीमत, महत्व और श्रेणी होती है (मुख्य वस्तुओं के लिए 0, सहायक उपकरण के लिए मुख्य वस्तु का आइटम नंबर)।\n    उदाहरण के लिए:\n    >>> MaxValueOfPurchases(1000, new List<(int, int, int)> { (800, 2, 0), (400, 5, 1), (300, 5, 1), (400, 3, 0), (500, 2, 0) })\n    2200\n    >>> MaxValueOfPurchases(500, new List<(int, int, int)> { (300, 3, 0), (200, 4, 1), (100, 2, 0) })\n    1700\n*/\npublic static int MaxValueOfPurchases(int totalMoney, List<(int price, int importance, int category)> items)",
      "hu": "using System;\nusing System.Collections.Generic;\nusing System.Diagnostics;\n\nclass Program\n{\n\n\n/* Kiszámítja a vásárlások maximális összértékét egy költségvetésen belül, figyelembe véve a fő tételeket és azok kiegészítőit.\n    - `totalMoney` a teljes költségvetés.\n    - `items` egy tuple-ök listája, ahol minden tuple egy tételt képvisel az árával, fontosságával és kategóriájával (0 a fő tételek esetén, a fő tétel sorszáma, ha kiegészítő).\n    Például:\n    >>> MaxValueOfPurchases(1000, new List<(int, int, int)> { (800, 2, 0), (400, 5, 1), (300, 5, 1), (400, 3, 0), (500, 2, 0) })\n    2200\n    >>> MaxValueOfPurchases(500, new List<(int, int, int)> { (300, 3, 0), (200, 4, 1), (100, 2, 0) })\n    1700\n*/\npublic static int MaxValueOfPurchases(int totalMoney, List<(int price, int importance, int category)> items)"
    },
    "prompt_bertscore": {
      "sq": "0.9894002883464542",
      "hy": "0.9762438064282274",
      "bn": "0.9848196731294087",
      "bg": "0.9887855273171513",
      "zh": "0.9621223781189331",
      "fr": "0.990491960920622",
      "de": "0.9988950191903029",
      "ha": "0.9890260687085844",
      "hi": "0.9939799104115946",
      "hu": "0.9849205773629744"
    },
    "canonical_solution": "{\n    int[] dp = new int[totalMoney + 1];\n    foreach (var item in items.Where(i => i.category == 0))\n    {\n        var accessories = items.Where(i => i.category == items.IndexOf(item) + 1).ToList();\n        for (int j = totalMoney; j >= item.price; j--)\n        {\n            dp[j] = Math.Max(dp[j], dp[j - item.price] + item.price * item.importance);\n            foreach (var accessory in accessories)\n            {\n                if (j >= item.price + accessory.price)\n                {\n                    dp[j] = Math.Max(dp[j], dp[j - item.price - accessory.price] + item.price * item.importance + accessory.price * accessory.importance);\n                }\n            }\n        }\n    }\n    return dp[totalMoney];\n}",
    "instruction": {
      "en": "Write a C# function `public static int MaxValueOfPurchases(int totalMoney, List<(int price, int importance, int category)> items)` to solve the following problem:\nCalculates the maximum total value of purchases within a budget, considering main items and their accessories.\n    - `totalMoney` is the total budget.\n    - `items` is a list of tuples, where each tuple represents an item with its price, importance, and category (0 for main items, item number of the main item if an accessory).\n    For example:\n    >>> MaxValueOfPurchases(1000, new List<(int, int, int)> { (800, 2, 0), (400, 5, 1), (300, 5, 1), (400, 3, 0), (500, 2, 0) })\n    2200\n    >>> MaxValueOfPurchases(500, new List<(int, int, int)> { (300, 3, 0), (200, 4, 1), (100, 2, 0) })\n    1700",
      "sq": "Shkruani një funksion në C# `public static int MaxValueOfPurchases(int totalMoney, List<(int price, int importance, int category)> items)` për të zgjidhur problemin e mëposhtëm:\nLlogarit vlerën maksimale totale të blerjeve brenda një buxheti, duke marrë parasysh artikujt kryesorë dhe aksesorët e tyre.\n- `totalMoney` është buxheti total.\n- `items` është një listë e treshëve, ku çdo treshe përfaqëson një artikull me çmimin, rëndësinë dhe kategorinë e tij (0 për artikujt kryesorë, numri i artikullit kryesor nëse është një aksesor).\nPër shembull:\n>>> MaxValueOfPurchases(1000, new List<(int, int, int)> { (800, 2, 0), (400, 5, 1), (300, 5, 1), (400, 3, 0), (500, 2, 0) })\n2200\n>>> MaxValueOfPurchases(500, new List<(int, int, int)> { (300, 3, 0), (200, 4, 1), (100, 2, 0) })\n1700",
      "hy": "Գրեք C# ֆունկցիա `public static int MaxValueOfPurchases(int totalMoney, List<(int price, int importance, int category)> items)` հետևյալ խնդիրը լուծելու համար:\nՀաշվարկում է գնումների առավելագույն ընդհանուր արժեքը բյուջեի սահմաններում՝ հաշվի առնելով հիմնական ապրանքները և դրանց աքսեսուարները:\n   - `totalMoney`-ը ընդհանուր բյուջեն է:\n   - `items`-ը կորտեժների ցուցակ է, որտեղ յուրաքանչյուր կորտեժ ներկայացնում է ապրանքը իր գնով, կարևորությամբ և կատեգորիայով (0 հիմնական ապրանքների համար, հիմնական ապրանքի համարի համար, եթե աքսեսուար է):\nՕրինակ:\n>>> MaxValueOfPurchases(1000, new List<(int, int, int)> { (800, 2, 0), (400, 5, 1), (300, 5, 1), (400, 3, 0), (500, 2, 0) })\n2200\n>>> MaxValueOfPurchases(500, new List<(int, int, int)> { (300, 3, 0), (200, 4, 1), (100, 2, 0) })\n1700",
      "bn": "একটি C# ফাংশন `public static int MaxValueOfPurchases(int totalMoney, List<(int price, int importance, int category)> items)` লিখুন নিম্নলিখিত সমস্যার সমাধানের জন্য:\nএকটি বাজেটের মধ্যে ক্রয়ের সর্বাধিক মোট মান গণনা করে, প্রধান আইটেম এবং তাদের আনুষাঙ্গিক বিবেচনা করে।\n- `totalMoney` হলো মোট বাজেট।\n- `items` হলো টুপলের একটি তালিকা, যেখানে প্রতিটি টুপল একটি আইটেমের দাম, গুরুত্ব এবং শ্রেণীবিভাগ (প্রধান আইটেমের জন্য 0, যদি আনুষাঙ্গিক হয় তবে প্রধান আইটেমের আইটেম নম্বর) উপস্থাপন করে।\nউদাহরণস্বরূপ:",
      "bg": "Напишете C# функция `public static int MaxValueOfPurchases(int totalMoney, List<(int price, int importance, int category)> items)` за решаване на следния проблем:\nИзчислява максималната обща стойност на покупките в рамките на бюджет, като се вземат предвид основни артикули и техните аксесоари.\n- `totalMoney` е общият бюджет.\n- `items` е списък от кортежи, където всеки кортеж представлява артикул с неговата цена, важност и категория (0 за основни артикули, номер на артикул на основния артикул, ако е аксесоар).\nНапример:\n>>> MaxValueOfPurchases(1000, new List<(int, int, int)> { (800, 2, 0), (400, 5, 1), (300, 5, 1), (400, 3, 0), (500, 2, 0) })\n2200\n>>> MaxValueOfPurchases(500, new List<(int, int, int)> { (300, 3, 0), (200, 4, 1), (100, 2, 0) })\n1700",
      "zh": "编写一个C#函数 `public static int MaxValueOfPurchases(int totalMoney, List<(int price, int importance, int category)> items)` 来解决以下问题：\n计算在预算范围内购买的最大总价值，考虑主要物品及其附件。\n- `totalMoney` 是总预算。\n- `items` 是一个元组列表，其中每个元组表示一个物品及其价格、重要性和类别（0表示主要物品，如果是附件则为主要物品的编号）。\n例如：\n>>> MaxValueOfPurchases(1000, new List<(int, int, int)> { (800, 2, 0), (400, 5, 1), (300, 5, 1), (400, 3, 0), (500, 2, 0) })\n2200\n>>> MaxValueOfPurchases(500, new List<(int, int, int)> { (300, 3, 0), (200, 4, 1), (100, 2, 0) })\n1700",
      "fr": "Écrire une fonction C# `public static int MaxValueOfPurchases(int totalMoney, List<(int price, int importance, int category)> items)` pour résoudre le problème suivant :\nCalcule la valeur totale maximale des achats dans un budget, en tenant compte des articles principaux et de leurs accessoires.\n- `totalMoney` est le budget total.\n- `items` est une liste de tuples, où chaque tuple représente un article avec son prix, son importance et sa catégorie (0 pour les articles principaux, numéro de l'article principal si c'est un accessoire).\nPar exemple :\n>>> MaxValueOfPurchases(1000, new List<(int, int, int)> { (800, 2, 0), (400, 5, 1), (300, 5, 1), (400, 3, 0), (500, 2, 0) })\n2200\n>>> MaxValueOfPurchases(500, new List<(int, int, int)> { (300, 3, 0), (200, 4, 1), (100, 2, 0) })\n1700",
      "de": "Schreiben Sie eine C#-Funktion `public static int MaxValueOfPurchases(int totalMoney, List<(int price, int importance, int category)> items)`, um das folgende Problem zu lösen:\nBerechnet den maximalen Gesamtwert der Einkäufe innerhalb eines Budgets, unter Berücksichtigung von Hauptartikeln und deren Zubehör.\n- `totalMoney` ist das Gesamtbudget.\n- `items` ist eine Liste von Tupeln, wobei jedes Tupel einen Artikel mit seinem Preis, seiner Wichtigkeit und seiner Kategorie darstellt (0 für Hauptartikel, Artikelnummer des Hauptartikels, wenn es sich um Zubehör handelt).\nZum Beispiel:",
      "ha": "Rubuta aikin C# `public static int MaxValueOfPurchases(int totalMoney, List<(int price, int importance, int category)> items)` don warware matsalar mai zuwa:\nƘididdige mafi girman jimillar darajar sayayya a cikin kasafin kuɗi, la'akari da manyan abubuwa da kayan haɗi.\n- `totalMoney` shine jimillar kasafin kuɗi.\n- `items` jerin tuples ne, inda kowane tuple ke wakiltar abu tare da farashinsa, mahimmanci, da rukuni (0 don manyan abubuwa, lambar abu na babban abu idan kayan haɗi).\nAlal misali:\n>>> MaxValueOfPurchases(1000, new List<(int, int, int)> { (800, 2, 0), (400, 5, 1), (300, 5, 1), (400, 3, 0), (500, 2, 0) })\n2200\n>>> MaxValueOfPurchases(500, new List<(int, int, int)> { (300, 3, 0), (200, 4, 1), (100, 2, 0) })\n1700",
      "hi": "C# फ़ंक्शन `public static int MaxValueOfPurchases(int totalMoney, List<(int price, int importance, int category)> items)` लिखें ताकि निम्नलिखित समस्या का समाधान किया जा सके:\nकिसी बजट के भीतर खरीदारी का अधिकतम कुल मूल्य गणना करता है, मुख्य वस्तुओं और उनके सहायक उपकरणों को ध्यान में रखते हुए।\n- `totalMoney` कुल बजट है।\n- `items` ट्यूपल की एक सूची है, जहाँ प्रत्येक ट्यूपल एक वस्तु को उसके मूल्य, महत्व और श्रेणी के साथ दर्शाता है (मुख्य वस्तुओं के लिए 0, यदि सहायक उपकरण हो तो मुख्य वस्तु का आइटम नंबर)।\nउदाहरण के लिए:\n>>> MaxValueOfPurchases(1000, new List<(int, int, int)> { (800, 2, 0), (400, 5, 1), (300, 5, 1), (400, 3, 0), (500, 2, 0) })\n2200\n>>> MaxValueOfPurchases(500, new List<(int, int, int)> { (300, 3, 0), (200, 4, 1), (100, 2, 0) })\n1700",
      "hu": "Írj egy C# függvényt `public static int MaxValueOfPurchases(int totalMoney, List<(int price, int importance, int category)> items)` a következő probléma megoldására:\nKiszámítja a vásárlások maximális összértékét egy költségvetésen belül, figyelembe véve a fő tételeket és azok kiegészítőit.\n- `totalMoney` a teljes költségvetés.\n- `items` egy tuple-ök listája, ahol minden tuple egy tételt képvisel az árával, fontosságával és kategóriájával (0 a fő tételek esetén, a fő tétel sorszáma, ha kiegészítő).\nPéldául:\n>>> MaxValueOfPurchases(1000, new List<(int, int, int)> { (800, 2, 0), (400, 5, 1), (300, 5, 1), (400, 3, 0), (500, 2, 0) })\n2200\n>>> MaxValueOfPurchases(500, new List<(int, int, int)> { (300, 3, 0), (200, 4, 1), (100, 2, 0) })\n1700"
    },
    "instruction_bertscore": {
      "sq": "0.8392988847452478",
      "hy": "0.9869958675840269",
      "bn": "0.8394840082603724",
      "bg": "0.8380628078840677",
      "zh": "0.9638298048743089",
      "fr": "0.8371489095009262",
      "de": "0.841605579360206",
      "ha": "0.833674466875864",
      "hi": "0.8352204071314585",
      "hu": "0.9855899617470619"
    },
    "level": "hard",
    "test": "    static void Main()\n    {\n\n        Debug.Assert(MaxValueOfPurchases(1000, new List<(int, int, int)> { (800, 2, 0), (400, 5, 1), (300, 5, 1), (400, 3, 0), (500, 2, 0) }) == 2200);\n        Debug.Assert(MaxValueOfPurchases(500, new List<(int, int, int)> { (300, 3, 0), (200, 4, 1), (100, 2, 0) }) == 1700);\n\n    }\n}\n",
    "entry_point": "MaxValueOfPurchases",
    "signature": "public static int MaxValueOfPurchases(int totalMoney, List<(int price, int importance, int category)> items)",
    "docstring": {
      "en": "Calculates the maximum total value of purchases within a budget, considering main items and their accessories.\n    - `totalMoney` is the total budget.\n    - `items` is a list of tuples, where each tuple represents an item with its price, importance, and category (0 for main items, item number of the main item if an accessory).\n    For example:\n    >>> MaxValueOfPurchases(1000, new List<(int, int, int)> { (800, 2, 0), (400, 5, 1), (300, 5, 1), (400, 3, 0), (500, 2, 0) })\n    2200\n    >>> MaxValueOfPurchases(500, new List<(int, int, int)> { (300, 3, 0), (200, 4, 1), (100, 2, 0) })\n    1700",
      "sq": "Llogarit vlerën maksimale totale të blerjeve brenda një buxheti, duke marrë parasysh artikujt kryesorë dhe aksesorët e tyre.\n- `totalMoney` është buxheti total.\n- `items` është një listë tuples, ku çdo tuple përfaqëson një artikull me çmimin, rëndësinë dhe kategorinë e tij (0 për artikujt kryesorë, numri i artikullit kryesor nëse është një aksesor).\nPër shembull:\n>>> MaxValueOfPurchases(1000, new List<(int, int, int)> { (800, 2, 0), (400, 5, 1), (300, 5, 1), (400, 3, 0), (500, 2, 0) })\n2200\n>>> MaxValueOfPurchases(500, new List<(int, int, int)> { (300, 3, 0), (200, 4, 1), (100, 2, 0) })\n1700",
      "hy": "Հաշվում է գնումների առավելագույն ընդհանուր արժեքը բյուջեի սահմաններում՝ հաշվի առնելով հիմնական ապրանքներն ու դրանց աքսեսուարները։\n- `totalMoney`-ը ընդհանուր բյուջեն է։\n- `items`-ը տուփերի ցուցակ է, որտեղ յուրաքանչյուր տուփ ներկայացնում է ապրանքը իր գնով, կարևորությամբ և կատեգորիայով (0 հիմնական ապրանքների համար, հիմնական ապրանքի աքսեսուարի դեպքում՝ հիմնական ապրանքի համարը)։\nՕրինակ՝\n>>> MaxValueOfPurchases(1000, new List<(int, int, int)> { (800, 2, 0), (400, 5, 1), (300, 5, 1), (400, 3, 0), (500, 2, 0) })\n2200\n>>> MaxValueOfPurchases(500, new List<(int, int, int)> { (300, 3, 0), (200, 4, 1), (100, 2, 0) })\n1700",
      "bn": "ক্রয়ের সর্বাধিক মোট মান গণনা করে একটি বাজেটের মধ্যে, প্রধান আইটেম এবং তাদের আনুষাঙ্গিক বিবেচনা করে।\n- `totalMoney` হল মোট বাজেট।\n- `items` হল টুপলের একটি তালিকা, যেখানে প্রতিটি টুপল একটি আইটেমকে তার মূল্য, গুরুত্ব এবং শ্রেণীবিভাগের সাথে উপস্থাপন করে (0 প্রধান আইটেমের জন্য, আনুষাঙ্গিক হলে প্রধান আইটেমের আইটেম নম্বর)।\nউদাহরণস্বরূপ:\n>>> MaxValueOfPurchases(1000, new List<(int, int, int)> { (800, 2, 0), (400, 5, 1), (300, 5, 1), (400, 3, 0), (500, 2, 0) })\n2200\n>>> MaxValueOfPurchases(500, new List<(int, int, int)> { (300, 3, 0), (200, 4, 1), (100, 2, 0) })\n1700",
      "bg": "Изчислява максималната обща стойност на покупките в рамките на бюджет, като се вземат предвид основните артикули и техните аксесоари.\n- `totalMoney` е общият бюджет.\n- `items` е списък от кортежи, където всеки кортеж представлява артикул с неговата цена, важност и категория (0 за основни артикули, номер на основния артикул, ако е аксесоар).\nНапример:\n>>> MaxValueOfPurchases(1000, new List<(int, int, int)> { (800, 2, 0), (400, 5, 1), (300, 5, 1), (400, 3, 0), (500, 2, 0) })\n2200\n>>> MaxValueOfPurchases(500, new List<(int, int, int)> { (300, 3, 0), (200, 4, 1), (100, 2, 0) })\n1700",
      "zh": "计算在预算范围内购买的最大总价值，考虑主商品及其附件。\n- `totalMoney` 是总预算。\n- `items` 是一个元组列表，其中每个元组表示一个商品及其价格、重要性和类别（0表示主商品，如果是附件则为主商品的编号）。\n例如：\n>>> MaxValueOfPurchases(1000, new List<(int, int, int)> { (800, 2, 0), (400, 5, 1), (300, 5, 1), (400, 3, 0), (500, 2, 0) })\n2200\n>>> MaxValueOfPurchases(500, new List<(int, int, int)> { (300, 3, 0), (200, 4, 1), (100, 2, 0) })\n1700",
      "fr": "Calcule la valeur totale maximale des achats dans un budget, en tenant compte des articles principaux et de leurs accessoires.\n- `totalMoney` est le budget total.\n- `items` est une liste de tuples, où chaque tuple représente un article avec son prix, son importance et sa catégorie (0 pour les articles principaux, numéro de l'article principal si c'est un accessoire).\nPar exemple :\n>>> MaxValueOfPurchases(1000, new List<(int, int, int)> { (800, 2, 0), (400, 5, 1), (300, 5, 1), (400, 3, 0), (500, 2, 0) })\n2200\n>>> MaxValueOfPurchases(500, new List<(int, int, int)> { (300, 3, 0), (200, 4, 1), (100, 2, 0) })\n1700",
      "de": "Berechnet den maximalen Gesamtwert der Einkäufe innerhalb eines Budgets, unter Berücksichtigung von Hauptartikeln und deren Zubehör.\n- `totalMoney` ist das Gesamtbudget.\n- `items` ist eine Liste von Tupeln, wobei jedes Tupel einen Artikel mit seinem Preis, seiner Wichtigkeit und seiner Kategorie darstellt (0 für Hauptartikel, Artikelnummer des Hauptartikels, wenn ein Zubehörteil).\nZum Beispiel:\n>>> MaxValueOfPurchases(1000, new List<(int, int, int)> { (800, 2, 0), (400, 5, 1), (300, 5, 1), (400, 3, 0), (500, 2, 0) })\n2200\n>>> MaxValueOfPurchases(500, new List<(int, int, int)> { (300, 3, 0), (200, 4, 1), (100, 2, 0) })\n1700",
      "ha": "Lissafi na mafi girman jimillar darajar sayayya cikin kasafin kudi, la'akari da manyan abubuwa da kayan haɗi.\n    - `totalMoney` shine jimillar kasafin kudi.  \n    - `items` jerin tuples ne, inda kowanne tuple ke wakiltar abu tare da farashinsa, muhimmanci, da rukuni (0 don manyan abubuwa, lambar abu na babban abu idan kayan haɗi).  \n    Alal misali:  \n    >>> MaxValueOfPurchases(1000, new List<(int, int, int)> { (800, 2, 0), (400, 5, 1), (300, 5, 1), (400, 3, 0), (500, 2, 0) })  \n    2200  \n    >>> MaxValueOfPurchases(500, new List<(int, int, int)> { (300, 3, 0), (200, 4, 1), (100, 2, 0) })  \n    1700  ",
      "hi": "खरीदारी के अधिकतम कुल मूल्य की गणना करता है जो बजट के भीतर है, मुख्य वस्तुओं और उनके सहायक उपकरणों को ध्यान में रखते हुए।\n- `totalMoney` कुल बजट है।\n- `items` ट्यूपल की एक सूची है, जहाँ प्रत्येक ट्यूपल एक वस्तु को उसके मूल्य, महत्व और श्रेणी (मुख्य वस्तुओं के लिए 0, यदि सहायक उपकरण है तो मुख्य वस्तु की संख्या) के साथ दर्शाता है।\n\nउदाहरण के लिए:\n>>> MaxValueOfPurchases(1000, new List<(int, int, int)> { (800, 2, 0), (400, 5, 1), (300, 5, 1), (400, 3, 0), (500, 2, 0) })\n2200\n>>> MaxValueOfPurchases(500, new List<(int, int, int)> { (300, 3, 0), (200, 4, 1), (100, 2, 0) })\n1700",
      "hu": "Kiszámítja a vásárlások maximális összértékét egy adott költségvetésen belül, figyelembe véve a fő tételeket és azok tartozékait.\n- `totalMoney` a teljes költségvetés.\n- `items` egy tuple-ök listája, ahol minden tuple egy tételt képvisel az árával, fontosságával és kategóriájával (0 a fő tételek esetén, a fő tétel sorszáma, ha tartozék).\nPéldául:\n>>> MaxValueOfPurchases(1000, new List<(int, int, int)> { (800, 2, 0), (400, 5, 1), (300, 5, 1), (400, 3, 0), (500, 2, 0) })\n2200\n>>> MaxValueOfPurchases(500, new List<(int, int, int)> { (300, 3, 0), (200, 4, 1), (100, 2, 0) })\n1700"
    },
    "docstring_bertscore": {
      "sq": "0.9900166384188055",
      "hy": "0.9793370773520836",
      "bn": "0.9887593081068546",
      "bg": "0.9870187100778459",
      "zh": "0.9520198383091176",
      "fr": "0.98443413155982",
      "de": "0.9890707605443173",
      "ha": "0.9963624818321081",
      "hi": "0.973918639187833",
      "hu": "0.9782511650589659"
    }
  },
  {
    "task_id": "C#/41",
    "prompt": {
      "en": "using System;\nusing System.Collections.Generic;\nusing System.Diagnostics;\n\nclass Program\n{\n\n/* Calculates the total number of cigarettes Peter can smoke given an initial number of cigarettes and a conversion rate of butts to new cigarettes.\n    It is assumed that Peter can continue smoking and converting butts into new cigarettes as long as he has enough butts to do so.\n    \n    >>> TotalSmokedCigarettes(4, 3)\n    5\n    >>> TotalSmokedCigarettes(10, 3)\n    14\n*/\n\nstatic int TotalSmokedCigarettes(int initialCigarettes, int buttConversionRate)",
      "sq": "using System;\nusing System.Collections.Generic;\nusing System.Diagnostics;\n\nclass Program\n{\n\n/* Llogarit numrin total të cigareve që Pjetri mund të pijë duke pasur një numër fillestar të cigareve dhe një normë konvertimi të bishtave në cigare të reja.\n    Supozohet se Pjetri mund të vazhdojë të pijë dhe të konvertojë bishtat në cigare të reja për sa kohë që ai ka mjaftueshëm bishta për ta bërë këtë.\n    \n    >>> TotalSmokedCigarettes(4, 3)\n    5\n    >>> TotalSmokedCigarettes(10, 3)\n    14\n*/\n\nstatic int TotalSmokedCigarettes(int initialCigarettes, int buttConversionRate)",
      "hy": "using System;\nusing System.Collections.Generic;\nusing System.Diagnostics;\n\nclass Program\n{\n\n/* Հաշվում է, թե քանի ընդհանուր ծխախոտ կարող է ծխել Պետերը՝ հաշվի առնելով սկզբնական ծխախոտների քանակը և ծխախոտի մնացորդների փոխարկման գործակիցը նոր ծխախոտների:\n    Ենթադրվում է, որ Պետերը կարող է շարունակել ծխել և փոխարկել մնացորդները նոր ծխախոտների, քանի դեռ նա ունի բավարար մնացորդներ դա անելու համար.\n    \n    >>> TotalSmokedCigarettes(4, 3)\n    5\n    >>> TotalSmokedCigarettes(10, 3)\n    14\n*/\n\nstatic int TotalSmokedCigarettes(int initialCigarettes, int buttConversionRate)",
      "bn": "using System;\nusing System.Collections.Generic;\nusing System.Diagnostics;\n\nclass Program\n{\n\n/* পিটার কতগুলো সিগারেট খেতে পারবে তা গণনা করে একটি প্রাথমিক সিগারেটের সংখ্যা এবং বাট থেকে নতুন সিগারেটে রূপান্তর হার দেওয়া হলে।\n    এটি অনুমান করা হয় যে পিটার ধূমপান চালিয়ে যেতে পারে এবং নতুন সিগারেটে বাট রূপান্তর করতে পারে যতক্ষণ না তার কাছে যথেষ্ট বাট থাকে তা করার জন্য।\n    \n    >>> TotalSmokedCigarettes(4, 3)\n    5\n    >>> TotalSmokedCigarettes(10, 3)\n    14\n*/\n\nstatic int TotalSmokedCigarettes(int initialCigarettes, int buttConversionRate)",
      "bg": "using System;\nusing System.Collections.Generic;\nusing System.Diagnostics;\n\nclass Program\n{\n\n/* Изчислява общия брой цигари, които Петър може да изпуши, като се има предвид началният брой цигари и курсът на конвертиране на фасове в нови цигари.\n    Предполага се, че Петър може да продължи да пуши и да конвертира фасове в нови цигари, докато има достатъчно фасове, за да го направи.\n    \n    >>> TotalSmokedCigarettes(4, 3)\n    5\n    >>> TotalSmokedCigarettes(10, 3)\n    14\n*/\n\nstatic int TotalSmokedCigarettes(int initialCigarettes, int buttConversionRate)",
      "zh": "using System;\nusing System.Collections.Generic;\nusing System.Diagnostics;\n\nclass Program\n{\n\n/* 计算彼得可以抽的香烟总数，给定初始香烟数量和烟蒂转换为新香烟的比率。\n    假设只要彼得有足够的烟蒂，他就可以继续抽烟并将烟蒂转换为新香烟。\n    \n    >>> TotalSmokedCigarettes(4, 3)\n    5\n    >>> TotalSmokedCigarettes(10, 3)\n    14\n*/\n\nstatic int TotalSmokedCigarettes(int initialCigarettes, int buttConversionRate)",
      "fr": "using System;\nusing System.Collections.Generic;\nusing System.Diagnostics;\n\nclass Program\n{\n\n/* Calcule le nombre total de cigarettes que Peter peut fumer étant donné un nombre initial de cigarettes et un taux de conversion de mégots en nouvelles cigarettes.\n    Il est supposé que Peter peut continuer à fumer et à convertir les mégots en nouvelles cigarettes tant qu'il a suffisamment de mégots pour le faire.\n    \n    >>> TotalSmokedCigarettes(4, 3)\n    5\n    >>> TotalSmokedCigarettes(10, 3)\n    14\n*/\n\nstatic int TotalSmokedCigarettes(int initialCigarettes, int buttConversionRate)",
      "de": "using System;\nusing System.Collections.Generic;\nusing System.Diagnostics;\n\nclass Program\n{\n\n/* Berechnet die Gesamtanzahl der Zigaretten, die Peter rauchen kann, gegeben eine anfängliche Anzahl von Zigaretten und eine Umwandlungsrate von Kippen zu neuen Zigaretten.\n    Es wird angenommen, dass Peter weiter rauchen und Kippen in neue Zigaretten umwandeln kann, solange er genug Kippen dafür hat.\n    \n    >>> TotalSmokedCigarettes(4, 3)\n    5\n    >>> TotalSmokedCigarettes(10, 3)\n    14\n*/\n\nstatic int TotalSmokedCigarettes(int initialCigarettes, int buttConversionRate)",
      "ha": "using System;\nusing System.Collections.Generic;\nusing System.Diagnostics;\n\nclass Program\n{\n\n/* Lissafi jimillar adadin sigari da Peter zai iya sha la'akari da adadin farko na sigari da kuma ƙimar jujjuyawar butts zuwa sababbin sigari.\n    Ana ɗauka cewa Peter zai iya ci gaba da shan sigari da jujjuya butts zuwa sababbin sigari muddin yana da isassun butts don yin haka.\n    \n    >>> TotalSmokedCigarettes(4, 3)\n    5\n    >>> TotalSmokedCigarettes(10, 3)\n    14\n*/\n\nstatic int TotalSmokedCigarettes(int initialCigarettes, int buttConversionRate)",
      "hi": "using System;\nusing System.Collections.Generic;\nusing System.Diagnostics;\n\nclass Program\n{\n\n/* पीटर कुल कितनी सिगरेट पी सकता है यह गणना करता है, जब उसे सिगरेट की एक प्रारंभिक संख्या और बट्स को नई सिगरेट में बदलने की दर दी जाती है।\n    यह माना जाता है कि पीटर तब तक सिगरेट पी सकता है और बट्स को नई सिगरेट में बदल सकता है जब तक उसके पास ऐसा करने के लिए पर्याप्त बट्स हैं।\n    \n    >>> TotalSmokedCigarettes(4, 3)\n    5\n    >>> TotalSmokedCigarettes(10, 3)\n    14\n*/\n\nstatic int TotalSmokedCigarettes(int initialCigarettes, int buttConversionRate)",
      "hu": "using System;\nusing System.Collections.Generic;\nusing System.Diagnostics;\n\nclass Program\n{\n\n/* Kiszámítja, hogy Péter összesen hány cigarettát tud elszívni, ha adott számú cigarettával kezd és van egy konverziós arány a csikkek új cigarettákra váltására.\n    Feltételezzük, hogy Péter folytathatja a dohányzást és a csikkek új cigarettákra váltását, amíg elegendő csikkje van ehhez.\n    \n    >>> TotalSmokedCigarettes(4, 3)\n    5\n    >>> TotalSmokedCigarettes(10, 3)\n    14\n*/\n\nstatic int TotalSmokedCigarettes(int initialCigarettes, int buttConversionRate)"
    },
    "prompt_bertscore": {
      "sq": "0.9855849959875361",
      "hy": "0.9805294555294362",
      "bn": "0.9865666273306105",
      "bg": "0.9774365818663419",
      "zh": "0.9613775141900522",
      "fr": "0.9869732237205889",
      "de": "0.9837748773251651",
      "ha": "0.9940375132220948",
      "hi": "0.9787896520219516",
      "hu": "0.9456793579161029"
    },
    "canonical_solution": "{\n    int totalSmoked = initialCigarettes;\n    int butts = initialCigarettes;\n\n    while (butts >= buttConversionRate)\n    {\n        int newCigarettes = butts / buttConversionRate;\n        totalSmoked += newCigarettes;\n        butts = butts % buttConversionRate + newCigarettes;\n    }\n\n    return totalSmoked;\n}",
    "instruction": {
      "en": "Write a C# function `static int TotalSmokedCigarettes(int initialCigarettes, int buttConversionRate)` to solve the following problem:\nCalculates the total number of cigarettes Peter can smoke given an initial number of cigarettes and a conversion rate of butts to new cigarettes.\n    It is assumed that Peter can continue smoking and converting butts into new cigarettes as long as he has enough butts to do so.\n    \n    >>> TotalSmokedCigarettes(4, 3)\n    5\n    >>> TotalSmokedCigarettes(10, 3)\n    14",
      "sq": "Shkruani një funksion në C# `static int TotalSmokedCigarettes(int initialCigarettes, int buttConversionRate)` për të zgjidhur problemin e mëposhtëm:\nLlogarit numrin total të cigareve që Pjetri mund të pijë duke pasur një numër fillestar të cigareve dhe një normë konvertimi të bishtave në cigare të reja.\n    Supozohet se Pjetri mund të vazhdojë të pijë dhe të konvertojë bishtat në cigare të reja për aq kohë sa ai ka mjaftueshëm bishta për ta bërë këtë.",
      "hy": "Գրեք C# ֆունկցիա `static int TotalSmokedCigarettes(int initialCigarettes, int buttConversionRate)` հետևյալ խնդիրը լուծելու համար:\nՀաշվարկում է ընդհանուր ծխած սիգարետների քանակը, որը Պետրոսը կարող է ծխել՝ հաշվի առնելով սկզբնական սիգարետների քանակը և մնացորդների փոխարկման գործակիցը նոր սիգարետների:\n    Ենթադրվում է, որ Պետրոսը կարող է շարունակել ծխել և մնացորդները փոխարկել նոր սիգարետների այնքան ժամանակ, քանի դեռ նա ունի բավականաչափ մնացորդներ դա անելու համար.\n    \n    >>> TotalSmokedCigarettes(4, 3)\n    5\n    >>> TotalSmokedCigarettes(10, 3)\n    14",
      "bn": "C# ফাংশন `static int TotalSmokedCigarettes(int initialCigarettes, int buttConversionRate)` লিখুন নিম্নলিখিত সমস্যার সমাধানের জন্য:\nপিটার মোট কতগুলো সিগারেট খেতে পারবে তা গণনা করে, যদি তাকে প্রাথমিকভাবে কিছু সিগারেট এবং বাট থেকে নতুন সিগারেট তৈরি করার একটি রূপান্তর হার দেওয়া হয়।\n    এটি অনুমান করা হয় যে পিটার ধূমপান চালিয়ে যেতে পারে এবং বাটকে নতুন সিগারেটে রূপান্তর করতে পারে যতক্ষণ না তার কাছে পর্যাপ্ত বাট থাকে।\n\n    >>> TotalSmokedCigarettes(4, 3)\n    5\n    >>> TotalSmokedCigarettes(10, 3)\n    14",
      "bg": "Напишете C# функция `static int TotalSmokedCigarettes(int initialCigarettes, int buttConversionRate)`, за да решите следния проблем:\nИзчислява общия брой цигари, които Петър може да изпуши, като се има предвид началният брой цигари и курсът на конвертиране на фасове в нови цигари.\n    Предполага се, че Петър може да продължи да пуши и да конвертира фасове в нови цигари, докато има достатъчно фасове, за да го направи.\n    \n    >>> TotalSmokedCigarettes(4, 3)\n    5\n    >>> TotalSmokedCigarettes(10, 3)\n    14",
      "zh": "编写一个 C# 函数 `static int TotalSmokedCigarettes(int initialCigarettes, int buttConversionRate)` 来解决以下问题：\n计算彼得在给定初始香烟数量和烟蒂转换为新香烟的转换率的情况下可以抽的香烟总数。\n假设只要彼得有足够的烟蒂，他就可以继续抽烟并将烟蒂转换为新香烟。\n\n    >>> TotalSmokedCigarettes(4, 3)\n    5\n    >>> TotalSmokedCigarettes(10, 3)\n    14",
      "fr": "Écrire une fonction C# `static int TotalSmokedCigarettes(int initialCigarettes, int buttConversionRate)` pour résoudre le problème suivant :\nCalcule le nombre total de cigarettes que Peter peut fumer étant donné un nombre initial de cigarettes et un taux de conversion de mégots en nouvelles cigarettes.\n    Il est supposé que Peter peut continuer à fumer et à convertir les mégots en nouvelles cigarettes tant qu'il a suffisamment de mégots pour le faire.\n    \n    >>> TotalSmokedCigarettes(4, 3)\n    5\n    >>> TotalSmokedCigarettes(10, 3)\n    14",
      "de": "Schreiben Sie eine C#-Funktion `static int TotalSmokedCigarettes(int initialCigarettes, int buttConversionRate)`, um das folgende Problem zu lösen:\nBerechnet die Gesamtanzahl der Zigaretten, die Peter rauchen kann, gegeben eine anfängliche Anzahl von Zigaretten und eine Umwandlungsrate von Kippen zu neuen Zigaretten.\n    Es wird angenommen, dass Peter weiterhin rauchen und Kippen in neue Zigaretten umwandeln kann, solange er genügend Kippen dafür hat.\n    \n    >>> TotalSmokedCigarettes(4, 3)\n    5\n    >>> TotalSmokedCigarettes(10, 3)\n    14",
      "ha": "Rubuta aikin C# `static int TotalSmokedCigarettes(int initialCigarettes, int buttConversionRate)` don warware matsalar mai zuwa:\nƘididdige jimillar adadin sigari da Peter zai iya sha la'akari da adadin sigari na farko da kuma ƙimar canjin butts zuwa sababbin sigari.\n    Ana ɗauka cewa Peter zai iya ci gaba da shan sigari da canza butts zuwa sababbin sigari muddin yana da isassun butts don yin haka.\n    \n    >>> TotalSmokedCigarettes(4, 3)\n    5\n    >>> TotalSmokedCigarettes(10, 3)\n    14",
      "hi": "C# फ़ंक्शन `static int TotalSmokedCigarettes(int initialCigarettes, int buttConversionRate)` लिखें ताकि निम्नलिखित समस्या का समाधान किया जा सके:\n    प्रारंभिक सिगरेटों की संख्या और बट्स को नई सिगरेटों में बदलने की दर को देखते हुए पीटर कितनी कुल सिगरेट पी सकता है, इसकी गणना करता है।\n    यह माना जाता है कि पीटर तब तक सिगरेट पीना और बट्स को नई सिगरेटों में बदलना जारी रख सकता है जब तक कि उसके पास ऐसा करने के लिए पर्याप्त बट्स हों।",
      "hu": "Írj egy C# függvényt `static int TotalSmokedCigarettes(int initialCigarettes, int buttConversionRate)` a következő probléma megoldására:\nKiszámítja a teljes cigarettaszámot, amit Péter elszívhat, adott egy kezdeti cigarettaszám és egy csikkek új cigarettává alakításának aránya.\n    Feltételezzük, hogy Péter folytathatja a dohányzást és a csikkek új cigarettává alakítását, amíg elegendő csikkje van ehhez.\n    \n    >>> TotalSmokedCigarettes(4, 3)\n    5\n    >>> TotalSmokedCigarettes(10, 3)\n    14"
    },
    "instruction_bertscore": {
      "sq": "0.9212531840690996",
      "hy": "0.9091748678591302",
      "bn": "0.9424526073761912",
      "bg": "0.9766204096306695",
      "zh": "0.9013281732867279",
      "fr": "0.9858509620677418",
      "de": "0.985100933748954",
      "ha": "0.9243331467574266",
      "hi": "0.9199082577591123",
      "hu": "0.9784253639031335"
    },
    "level": "easy",
    "test": "static void Main()\n    {\n        Debug.Assert(TotalSmokedCigarettes(4, 3) == 5);\n        Debug.Assert(TotalSmokedCigarettes(10, 3) == 14);\n        Debug.Assert(TotalSmokedCigarettes(1, 2) == 1); // No conversion possible, should return initial cigarettes\n        Debug.Assert(TotalSmokedCigarettes(20, 4) ==26); // Additional case to test\n\n    }\n}",
    "entry_point": "TotalSmokedCigarettes",
    "signature": "static int TotalSmokedCigarettes(int initialCigarettes, int buttConversionRate)",
    "docstring": {
      "en": "Calculates the total number of cigarettes Peter can smoke given an initial number of cigarettes and a conversion rate of butts to new cigarettes.\n    It is assumed that Peter can continue smoking and converting butts into new cigarettes as long as he has enough butts to do so.\n    \n    >>> TotalSmokedCigarettes(4, 3)\n    5\n    >>> TotalSmokedCigarettes(10, 3)\n    14",
      "sq": "Llogarit numrin total të cigareve që Peter mund të pijë duke pasur një numër fillestar të cigareve dhe një normë konvertimi të bishtave në cigare të reja. \n    Supozohet se Peter mund të vazhdojë të pijë dhe të konvertojë bishtat në cigare të reja për aq kohë sa ka mjaftueshëm bishta për ta bërë këtë.\n    \n    >>> TotalSmokedCigarettes(4, 3)\n    5\n    >>> TotalSmokedCigarettes(10, 3)\n    14",
      "hy": "Հաշվում է ընդհանուր ծխախոտների քանակը, որոնք Պետրոսը կարող է ծխել՝ հաշվի առնելով սկզբնական ծխախոտների քանակը և ծխախոտի մնացորդների փոխակերպման գործակիցը նոր ծխախոտների։ \n    Ենթադրվում է, որ Պետրոսը կարող է շարունակել ծխել և փոխակերպել մնացորդները նոր ծխախոտների, քանի դեռ նա ունի բավարար մնացորդներ դա անելու համար։\n    \n    >>> TotalSmokedCigarettes(4, 3)\n    5\n    >>> TotalSmokedCigarettes(10, 3)\n    14",
      "bn": "প্রাথমিক সিগারেটের সংখ্যা এবং বাট থেকে নতুন সিগারেটের রূপান্তর হার দেওয়া হলে পিটার মোট কত সিগারেট খেতে পারে তা গণনা করে। \n    অনুমান করা হয় যে পিটারের কাছে যথেষ্ট বাট থাকলে তিনি ধূমপান এবং বাটকে নতুন সিগারেটে রূপান্তর করতে পারবেন।\n\n    >>> TotalSmokedCigarettes(4, 3)\n    5\n    >>> TotalSmokedCigarettes(10, 3)\n    14",
      "bg": "Изчислява общия брой цигари, които Петър може да изпуши, като се има предвид началния брой цигари и курсът на конвертиране на фасове в нови цигари. \n    Предполага се, че Петър може да продължи да пуши и да конвертира фасове в нови цигари, докато има достатъчно фасове за това.\n    \n    >>> TotalSmokedCigarettes(4, 3)\n    5\n    >>> TotalSmokedCigarettes(10, 3)\n    14",
      "zh": "计算彼得可以抽的香烟总数，给定初始香烟数量和烟蒂转换为新香烟的转换率。\n假设只要彼得有足够的烟蒂，他就可以继续抽烟并将烟蒂转换为新香烟。\n\n>>> TotalSmokedCigarettes(4, 3)\n5\n>>> TotalSmokedCigarettes(10, 3)\n14",
      "fr": "Calcule le nombre total de cigarettes que Peter peut fumer étant donné un nombre initial de cigarettes et un taux de conversion de mégots en nouvelles cigarettes. Il est supposé que Peter peut continuer à fumer et à convertir les mégots en nouvelles cigarettes tant qu'il a suffisamment de mégots pour le faire.\n\n    >>> TotalSmokedCigarettes(4, 3)\n    5\n    >>> TotalSmokedCigarettes(10, 3)\n    14",
      "de": "Berechnet die Gesamtanzahl der Zigaretten, die Peter rauchen kann, gegeben eine anfängliche Anzahl von Zigaretten und eine Umwandlungsrate von Kippen zu neuen Zigaretten.\n    Es wird angenommen, dass Peter weiter rauchen und Kippen in neue Zigaretten umwandeln kann, solange er genug Kippen dafür hat.\n    \n    >>> TotalSmokedCigarettes(4, 3)\n    5\n    >>> TotalSmokedCigarettes(10, 3)\n    14",
      "ha": "Yana ƙididdige jimillar adadin sigari da Peter zai iya sha la'akari da adadin sigari na farko da kuma ƙimar canjin butts zuwa sabbin sigari.  \nAna ɗauka cewa Peter na iya ci gaba da shan sigari da canza butts zuwa sabbin sigari muddin yana da isassun butts don yin hakan.\n\n    >>> TotalSmokedCigarettes(4, 3)\n    5\n    >>> TotalSmokedCigarettes(10, 3)\n    14",
      "hi": "कुल सिगरेट्स की संख्या की गणना करता है जो पीटर धूम्रपान कर सकता है, दिए गए प्रारंभिक सिगरेट्स की संख्या और बट्स को नई सिगरेट्स में बदलने की दर के आधार पर।\n    यह माना जाता है कि पीटर धूम्रपान करना और बट्स को नई सिगरेट्स में बदलना जारी रख सकता है जब तक कि उसके पास ऐसा करने के लिए पर्याप्त बट्स हों।\n\n    >>> TotalSmokedCigarettes(4, 3)\n    5\n    >>> TotalSmokedCigarettes(10, 3)\n    14",
      "hu": "Számítja ki a teljes cigarettaszámot, amit Péter elszívhat egy kezdeti cigarettaszám és egy csikkek új cigarettává alakítási aránya alapján. Feltételezzük, hogy Péter folytathatja a dohányzást és a csikkek új cigarettává alakítását, amíg elegendő csikke van ehhez.\n\n    >>> TotalSmokedCigarettes(4, 3)\n    5\n    >>> TotalSmokedCigarettes(10, 3)\n    14"
    },
    "docstring_bertscore": {
      "sq": "0.9698828671059662",
      "hy": "0.953667675950183",
      "bn": "0.8861341409198452",
      "bg": "0.9637253252938845",
      "zh": "0.9471819967486318",
      "fr": "0.9786750422920945",
      "de": "0.9811616960322702",
      "ha": "0.9766259712813385",
      "hi": "0.9609075547085236",
      "hu": "0.9739623378716606"
    }
  },
  {
    "task_id": "C#/42",
    "prompt": {
      "en": "using System;\nusing System.Collections.Generic;\nusing System.Diagnostics;\n\nclass Program\n{\n\n/* Determines the number of pairs of students who are considered \"equal opponents\". Two students are equal opponents if the difference in each of their subjects' scores (Chinese, Mathematics, English) does not exceed 5, and the total difference in their scores does not exceed 10.\n    >>> FindEqualOpponents(new List<Tuple<int, int, int>> { Tuple.Create(90, 90, 90), Tuple.Create(85, 95, 90), Tuple.Create(80, 100, 91) })\n    2\n\n*/\n\n\nstatic int FindEqualOpponents(List<Tuple<int, int, int>> scores)",
      "sq": "using System;\nusing System.Collections.Generic;\nusing System.Diagnostics;\n\nclass Program\n{\n\n/* Përcakton numrin e çifteve të studentëve që konsiderohen \"kundërshtarë të barabartë\". Dy studentë janë kundërshtarë të barabartë nëse diferenca në secilën nga notat e tyre (Kinezisht, Matematikë, Anglisht) nuk e kalon 5, dhe diferenca totale në notat e tyre nuk e kalon 10.\n    >>> FindEqualOpponents(new List<Tuple<int, int, int>> { Tuple.Create(90, 90, 90), Tuple.Create(85, 95, 90), Tuple.Create(80, 100, 91) })\n    2\n\n*/\n\n\nstatic int FindEqualOpponents(List<Tuple<int, int, int>> scores)",
      "hy": "using System;\nusing System.Collections.Generic;\nusing System.Diagnostics;\n\nclass Program\n{\n\n/* Որոշում է ուսանողների զույգերի քանակը, որոնք համարվում են \"հավասար մրցակիցներ\": Երկու ուսանող համարվում են հավասար մրցակիցներ, եթե նրանցից յուրաքանչյուրի առարկաների (չինարեն, մաթեմատիկա, անգլերեն) գնահատականների տարբերությունը չի գերազանցում 5-ը, և նրանց ընդհանուր գնահատականների տարբերությունը չի գերազանցում 10-ը։\n    >>> FindEqualOpponents(new List<Tuple<int, int, int>> { Tuple.Create(90, 90, 90), Tuple.Create(85, 95, 90), Tuple.Create(80, 100, 91) })\n    2\n\n*/\n\n\nstatic int FindEqualOpponents(List<Tuple<int, int, int>> scores)",
      "bn": "using System;\nusing System.Collections.Generic;\nusing System.Diagnostics;\n\nclass Program\n{\n\n/* নির্ধারণ করে কত জোড়া ছাত্রকে \"সমান প্রতিদ্বন্দ্বী\" হিসেবে বিবেচনা করা হয়। দুই ছাত্র সমান প্রতিদ্বন্দ্বী যদি তাদের প্রতিটি বিষয়ের (চীনা, গণিত, ইংরেজি) স্কোরের পার্থক্য ৫ এর বেশি না হয় এবং তাদের মোট স্কোরের পার্থক্য ১০ এর বেশি না হয়।\n    >>> FindEqualOpponents(new List<Tuple<int, int, int>> { Tuple.Create(90, 90, 90), Tuple.Create(85, 95, 90), Tuple.Create(80, 100, 91) })\n    2\n\n*/\n\n\nstatic int FindEqualOpponents(List<Tuple<int, int, int>> scores)",
      "bg": "using System;\nusing System.Collections.Generic;\nusing System.Diagnostics;\n\nclass Program\n{\n\n/* Определя броя на двойките ученици, които се считат за \"равни противници\". Двама ученици са равни противници, ако разликата в оценките им по всеки от предметите (Китайски, Математика, Английски) не надвишава 5, и общата разлика в оценките им не надвишава 10.\n    >>> FindEqualOpponents(new List<Tuple<int, int, int>> { Tuple.Create(90, 90, 90), Tuple.Create(85, 95, 90), Tuple.Create(80, 100, 91) })\n    2\n\n*/\n\n\nstatic int FindEqualOpponents(List<Tuple<int, int, int>> scores)",
      "zh": "using System;\nusing System.Collections.Generic;\nusing System.Diagnostics;\n\nclass Program\n{\n\n/* 确定被认为是“势均力敌”的学生对的数量。如果两个学生在每个科目（语文、数学、英语）上的分数差不超过5，并且他们的总分差不超过10，则这两个学生被认为是势均力敌。\n    >>> FindEqualOpponents(new List<Tuple<int, int, int>> { Tuple.Create(90, 90, 90), Tuple.Create(85, 95, 90), Tuple.Create(80, 100, 91) })\n    2\n\n*/\n\n\nstatic int FindEqualOpponents(List<Tuple<int, int, int>> scores)",
      "fr": "using System;\nusing System.Collections.Generic;\nusing System.Diagnostics;\n\nclass Program\n{\n\n/* Détermine le nombre de paires d'élèves qui sont considérés comme \"adversaires égaux\". Deux élèves sont des adversaires égaux si la différence dans chacune de leurs notes de matières (Chinois, Mathématiques, Anglais) ne dépasse pas 5, et si la différence totale de leurs scores ne dépasse pas 10.\n    >>> FindEqualOpponents(new List<Tuple<int, int, int>> { Tuple.Create(90, 90, 90), Tuple.Create(85, 95, 90), Tuple.Create(80, 100, 91) })\n    2\n\n*/\n\n\nstatic int FindEqualOpponents(List<Tuple<int, int, int>> scores)",
      "de": "using System;\nusing System.Collections.Generic;\nusing System.Diagnostics;\n\nclass Program\n{\n\n/* Bestimmt die Anzahl der Paare von Schülern, die als \"gleichwertige Gegner\" gelten. Zwei Schüler sind gleichwertige Gegner, wenn der Unterschied in jedem ihrer Fächer (Chinesisch, Mathematik, Englisch) nicht mehr als 5 beträgt und der Gesamtdifferenz ihrer Punktzahlen nicht mehr als 10 beträgt.\n    >>> FindEqualOpponents(new List<Tuple<int, int, int>> { Tuple.Create(90, 90, 90), Tuple.Create(85, 95, 90), Tuple.Create(80, 100, 91) })\n    2\n\n*/\n\n\nstatic int FindEqualOpponents(List<Tuple<int, int, int>> scores)",
      "ha": "using System;\nusing System.Collections.Generic;\nusing System.Diagnostics;\n\nclass Program\n{\n\n/* Yana tantance adadin ma'aurata na ɗalibai waɗanda ake ɗauka a matsayin \"abokan gaba daidai\". Dalibai biyu suna daidai idan bambancin kowanne daga cikin maki na batutuwansu (Sinanci, Lissafi, Turanci) bai wuce 5 ba, kuma jimillar bambanci a cikin maki nasu bai wuce 10 ba.\n    >>> FindEqualOpponents(new List<Tuple<int, int, int>> { Tuple.Create(90, 90, 90), Tuple.Create(85, 95, 90), Tuple.Create(80, 100, 91) })\n    2\n\n*/\n\n\nstatic int FindEqualOpponents(List<Tuple<int, int, int>> scores)",
      "hi": "using System;\nusing System.Collections.Generic;\nusing System.Diagnostics;\n\nclass Program\n{\n\n/* उन छात्रों की जोड़ी की संख्या निर्धारित करता है जिन्हें \"समान प्रतिद्वंद्वी\" माना जाता है। दो छात्र समान प्रतिद्वंद्वी होते हैं यदि उनके प्रत्येक विषय (चीनी, गणित, अंग्रेजी) के अंकों में अंतर 5 से अधिक नहीं होता है, और उनके अंकों में कुल अंतर 10 से अधिक नहीं होता है।\n    >>> FindEqualOpponents(new List<Tuple<int, int, int>> { Tuple.Create(90, 90, 90), Tuple.Create(85, 95, 90), Tuple.Create(80, 100, 91) })\n    2\n\n*/\n\n\nstatic int FindEqualOpponents(List<Tuple<int, int, int>> scores)",
      "hu": "using System;\nusing System.Collections.Generic;\nusing System.Diagnostics;\n\nclass Program\n{\n\n/* Meghatározza azoknak a diákpároknak a számát, akiket \"egyenlő ellenfeleknek\" tekintenek. Két diák akkor tekinthető egyenlő ellenfélnek, ha a tantárgyaik (kínai, matematika, angol) pontszámainak különbsége nem haladja meg az 5-öt, és a pontszámaik összesített különbsége nem haladja meg a 10-et.\n    >>> FindEqualOpponents(new List<Tuple<int, int, int>> { Tuple.Create(90, 90, 90), Tuple.Create(85, 95, 90), Tuple.Create(80, 100, 91) })\n    2\n\n*/\n\n\nstatic int FindEqualOpponents(List<Tuple<int, int, int>> scores)"
    },
    "prompt_bertscore": {
      "sq": "0.9712804304669276",
      "hy": "0.9824605400938573",
      "bn": "0.9774473079069178",
      "bg": "0.988749575218184",
      "zh": "0.9428536421155006",
      "fr": "0.9957671865801465",
      "de": "0.9851086803338144",
      "ha": "0.9757645113187902",
      "hi": "0.9828508487925909",
      "hu": "0.9704584979502052"
    },
    "canonical_solution": "{\n    int equalOpponentsCount = 0;\n    for (int i = 0; i < scores.Count - 1; i++)\n    {\n        for (int j = i + 1; j < scores.Count; j++)\n        {\n            var score1 = scores[i];\n            var score2 = scores[j];\n            if (Math.Abs(score1.Item1 - score2.Item1) <= 5 &&\n                Math.Abs(score1.Item2 - score2.Item2) <= 5 &&\n                Math.Abs(score1.Item3 - score2.Item3) <= 5 &&\n                Math.Abs((score1.Item1 + score1.Item2 + score1.Item3) - (score2.Item1 + score2.Item2 + score2.Item3)) <= 10)\n            {\n                equalOpponentsCount++;\n            }\n        }\n    }\n    return equalOpponentsCount;\n}",
    "instruction": {
      "en": "Write a C# function `static int FindEqualOpponents(List<Tuple<int, int, int>> scores)` to solve the following problem:\nDetermines the number of pairs of students who are considered \"equal opponents\". Two students are equal opponents if the difference in each of their subjects' scores (Chinese, Mathematics, English) does not exceed 5, and the total difference in their scores does not exceed 10.\n    >>> FindEqualOpponents(new List<Tuple<int, int, int>> { Tuple.Create(90, 90, 90), Tuple.Create(85, 95, 90), Tuple.Create(80, 100, 91) })\n    2",
      "sq": "Shkruani një funksion në C# `static int FindEqualOpponents(List<Tuple<int, int, int>> scores)` për të zgjidhur problemin e mëposhtëm:\nPërcakton numrin e çifteve të studentëve që konsiderohen \"kundërshtarë të barabartë\". Dy studentë janë kundërshtarë të barabartë nëse diferenca në secilën nga notat e tyre të lëndëve (Kinezisht, Matematikë, Anglisht) nuk e kalon 5, dhe diferenca totale në notat e tyre nuk e kalon 10.\n    >>> FindEqualOpponents(new List<Tuple<int, int, int>> { Tuple.Create(90, 90, 90), Tuple.Create(85, 95, 90), Tuple.Create(80, 100, 91) })\n    2",
      "hy": "Գրեք C# ֆունկցիա `static int FindEqualOpponents(List<Tuple<int, int, int>> scores)` հետևյալ խնդիրը լուծելու համար:\nՍահմանում է ուսանողների զույգերի քանակը, որոնք համարվում են \"հավասար մրցակիցներ\": Երկու ուսանող համարվում են հավասար մրցակիցներ, եթե նրանց առարկաների (չինարեն, մաթեմատիկա, անգլերեն) գնահատականների տարբերությունը չի գերազանցում 5-ը, և նրանց ընդհանուր գնահատականների տարբերությունը չի գերազանցում 10-ը:\n    >>> FindEqualOpponents(new List<Tuple<int, int, int>> { Tuple.Create(90, 90, 90), Tuple.Create(85, 95, 90), Tuple.Create(80, 100, 91) })\n    2",
      "bn": "C# ফাংশন `static int FindEqualOpponents(List<Tuple<int, int, int>> scores)` লিখুন নিম্নলিখিত সমস্যার সমাধানের জন্য:\nযে সংখ্যক ছাত্র জোড়া \"সমান প্রতিদ্বন্দ্বী\" বলে বিবেচিত হয় তা নির্ধারণ করে। দুই ছাত্র সমান প্রতিদ্বন্দ্বী হয় যদি তাদের প্রতিটি বিষয়ের (চীনা, গণিত, ইংরেজি) স্কোরের পার্থক্য ৫ এর বেশি না হয়, এবং তাদের মোট স্কোরের পার্থক্য ১০ এর বেশি না হয়।",
      "bg": "Напишете C# функция `static int FindEqualOpponents(List<Tuple<int, int, int>> scores)`, за да решите следния проблем:\nОпределя броя на двойките ученици, които се считат за \"равни противници\". Двама ученици са равни противници, ако разликата в оценките им по всеки от предметите (Китайски, Математика, Английски) не надвишава 5, и общата разлика в техните оценки не надвишава 10.",
      "zh": "编写一个 C# 函数 `static int FindEqualOpponents(List<Tuple<int, int, int>> scores)` 来解决以下问题：\n确定被认为是“势均力敌”的学生对的数量。如果两名学生在每个科目（语文、数学、英语）上的分数差不超过 5，并且他们的总分差不超过 10，则这两名学生被认为是势均力敌。\n    >>> FindEqualOpponents(new List<Tuple<int, int, int>> { Tuple.Create(90, 90, 90), Tuple.Create(85, 95, 90), Tuple.Create(80, 100, 91) })\n    2",
      "fr": "Écrire une fonction C# `static int FindEqualOpponents(List<Tuple<int, int, int>> scores)` pour résoudre le problème suivant :  \nDétermine le nombre de paires d'étudiants qui sont considérés comme des \"adversaires égaux\". Deux étudiants sont des adversaires égaux si la différence dans chacun de leurs scores de matières (Chinois, Mathématiques, Anglais) ne dépasse pas 5, et la différence totale de leurs scores ne dépasse pas 10.  \n    >>> FindEqualOpponents(new List<Tuple<int, int, int>> { Tuple.Create(90, 90, 90), Tuple.Create(85, 95, 90), Tuple.Create(80, 100, 91) })  \n    2",
      "de": "Schreiben Sie eine C#-Funktion `static int FindEqualOpponents(List<Tuple<int, int, int>> scores)`, um das folgende Problem zu lösen:\nBestimmt die Anzahl der Paare von Schülern, die als \"gleichwertige Gegner\" gelten. Zwei Schüler sind gleichwertige Gegner, wenn der Unterschied in jedem ihrer Fachnoten (Chinesisch, Mathematik, Englisch) nicht mehr als 5 beträgt und der Gesamtdifferenz ihrer Noten nicht mehr als 10 beträgt.\n    >>> FindEqualOpponents(new List<Tuple<int, int, int>> { Tuple.Create(90, 90, 90), Tuple.Create(85, 95, 90), Tuple.Create(80, 100, 91) })\n    2",
      "ha": "Rubuta aikin C# `static int FindEqualOpponents(List<Tuple<int, int, int>> scores)` don warware matsalar mai zuwa:\nYana tantance yawan ma'aurata na ɗalibai waɗanda ake ɗauka \"abokan hamayya daidai\". Ana ɗaukar ɗalibai biyu a matsayin abokan hamayya daidai idan bambancin kowanne daga cikin maki na batutuwansu (Sinanci, Lissafi, Turanci) bai wuce 5 ba, kuma jimlar bambancin maki nasu bai wuce 10 ba.\n    >>> FindEqualOpponents(new List<Tuple<int, int, int>> { Tuple.Create(90, 90, 90), Tuple.Create(85, 95, 90), Tuple.Create(80, 100, 91) })\n    2",
      "hi": "C# फ़ंक्शन `static int FindEqualOpponents(List<Tuple<int, int, int>> scores)` लिखें ताकि निम्नलिखित समस्या को हल किया जा सके:\nयह निर्धारित करता है कि कितने जोड़े छात्रों को \"समान प्रतिद्वंद्वी\" माना जाता है। दो छात्र समान प्रतिद्वंद्वी होते हैं यदि उनके प्रत्येक विषय के अंकों (चीनी, गणित, अंग्रेजी) में अंतर 5 से अधिक नहीं होता है, और उनके अंकों में कुल अंतर 10 से अधिक नहीं होता है।",
      "hu": "Írj egy C# függvényt `static int FindEqualOpponents(List<Tuple<int, int, int>> scores)` a következő probléma megoldására:\nMeghatározza azon diákpárok számát, akiket \"egyenlő ellenfeleknek\" tekintünk. Két diák akkor egyenlő ellenfél, ha az egyes tantárgyaik (kínai, matematika, angol) pontszámainak különbsége nem haladja meg az 5-öt, és az összpontszámuk különbsége nem haladja meg a 10-et."
    },
    "instruction_bertscore": {
      "sq": "0.9845419878567219",
      "hy": "0.8823252047331201",
      "bn": "0.862266317073931",
      "bg": "0.8782572545295256",
      "zh": "0.8349730657738686",
      "fr": "0.9876259231526696",
      "de": "0.8910377291364534",
      "ha": "0.9730530079872829",
      "hi": "0.8576215442438111",
      "hu": "0.8780566378446804"
    },
    "level": "hard",
    "test": "    static void Main()\n    {\n        Debug.Assert(FindEqualOpponents(new List<Tuple<int, int, int>> { Tuple.Create(90, 90, 90), Tuple.Create(85, 95, 90), Tuple.Create(80, 100, 91) }) == 2);\n        Debug.Assert(FindEqualOpponents(new List<Tuple<int, int, int>> { Tuple.Create(100, 100, 100), Tuple.Create(92, 95, 98), Tuple.Create(85, 90, 95) }) == 0);\n        Debug.Assert(FindEqualOpponents(new List<Tuple<int, int, int>> { Tuple.Create(100, 95, 90), Tuple.Create(95, 90, 85), Tuple.Create(90, 85, 80) }) == 0);\n        Debug.Assert(FindEqualOpponents(new List<Tuple<int, int, int>> { Tuple.Create(100, 100, 100), Tuple.Create(80, 80, 80) }) == 0);\n        Debug.Assert(FindEqualOpponents(new List<Tuple<int, int, int>> { Tuple.Create(100, 100, 100), Tuple.Create(100, 100, 99), Tuple.Create(101, 100, 99) }) == 3);\n\n    }\n}\n",
    "entry_point": "FindEqualOpponents",
    "signature": "static int FindEqualOpponents(List<Tuple<int, int, int>> scores)",
    "docstring": {
      "en": "Determines the number of pairs of students who are considered \"equal opponents\". Two students are equal opponents if the difference in each of their subjects' scores (Chinese, Mathematics, English) does not exceed 5, and the total difference in their scores does not exceed 10.\n    >>> FindEqualOpponents(new List<Tuple<int, int, int>> { Tuple.Create(90, 90, 90), Tuple.Create(85, 95, 90), Tuple.Create(80, 100, 91) })\n    2",
      "sq": "Përcakton numrin e çifteve të studentëve që konsiderohen \"kundërshtarë të barabartë\". Dy studentë janë kundërshtarë të barabartë nëse diferenca në secilën nga notat e tyre të lëndëve (Kinezisht, Matematikë, Anglisht) nuk e kalon 5, dhe diferenca totale në notat e tyre nuk e kalon 10.\n    >>> FindEqualOpponents(new List<Tuple<int, int, int>> { Tuple.Create(90, 90, 90), Tuple.Create(85, 95, 90), Tuple.Create(80, 100, 91) })\n    2",
      "hy": "Սահմանում է ուսանողների զույգերի քանակը, որոնք համարվում են \"հավասար մրցակիցներ\": Երկու ուսանող համարվում են հավասար մրցակիցներ, եթե նրանց առարկաների (չինարեն, մաթեմատիկա, անգլերեն) գնահատականների տարբերությունը չի գերազանցում 5-ը, և նրանց գնահատականների ընդհանուր տարբերությունը չի գերազանցում 10-ը:\n    >>> FindEqualOpponents(new List<Tuple<int, int, int>> { Tuple.Create(90, 90, 90), Tuple.Create(85, 95, 90), Tuple.Create(80, 100, 91) })\n    2",
      "bn": "সমান প্রতিদ্বন্দ্বী হিসেবে বিবেচিত ছাত্রদের জোড়ার সংখ্যা নির্ধারণ করে। দুই ছাত্র সমান প্রতিদ্বন্দ্বী যদি তাদের প্রতিটি বিষয়ের (চীনা, গণিত, ইংরেজি) স্কোরের পার্থক্য ৫ এর বেশি না হয়, এবং তাদের মোট স্কোরের পার্থক্য ১০ এর বেশি না হয়।\n    >>> FindEqualOpponents(new List<Tuple<int, int, int>> { Tuple.Create(90, 90, 90), Tuple.Create(85, 95, 90), Tuple.Create(80, 100, 91) })\n    2",
      "bg": "Определя броя на двойките ученици, които се считат за \"равни противници\". Двама ученици са равни противници, ако разликата в оценките им по всеки от предметите (Китайски, Математика, Английски) не надвишава 5, и общата разлика в оценките им не надвишава 10.\n    >>> FindEqualOpponents(new List<Tuple<int, int, int>> { Tuple.Create(90, 90, 90), Tuple.Create(85, 95, 90), Tuple.Create(80, 100, 91) })\n    2",
      "zh": "确定被认为是“势均力敌”的学生对数。如果两个学生在每个科目（语文、数学、英语）上的分数差不超过5，并且他们的总分差不超过10，则这两个学生被认为是势均力敌的对手。  \n    >>> FindEqualOpponents(new List<Tuple<int, int, int>> { Tuple.Create(90, 90, 90), Tuple.Create(85, 95, 90), Tuple.Create(80, 100, 91) })\n    2",
      "fr": "Détermine le nombre de paires d'étudiants qui sont considérés comme des \"adversaires égaux\". Deux étudiants sont des adversaires égaux si la différence dans chacun de leurs scores de matières (Chinois, Mathématiques, Anglais) ne dépasse pas 5, et la différence totale de leurs scores ne dépasse pas 10.\n    >>> FindEqualOpponents(new List<Tuple<int, int, int>> { Tuple.Create(90, 90, 90), Tuple.Create(85, 95, 90), Tuple.Create(80, 100, 91) })\n    2",
      "de": "Bestimmt die Anzahl der Paare von Schülern, die als \"gleichwertige Gegner\" betrachtet werden. Zwei Schüler sind gleichwertige Gegner, wenn der Unterschied in jedem ihrer Fächer (Chinesisch, Mathematik, Englisch) nicht mehr als 5 beträgt und der Gesamtdifferenz ihrer Punktzahlen nicht mehr als 10 beträgt.\n    >>> FindEqualOpponents(new List<Tuple<int, int, int>> { Tuple.Create(90, 90, 90), Tuple.Create(85, 95, 90), Tuple.Create(80, 100, 91) })\n    2",
      "ha": "Yana tantance adadin ma'aurata na ɗalibai waɗanda ake ɗauka \"abokan hamayya masu daidaito\". Ana ɗaukar ɗalibai biyu a matsayin abokan hamayya masu daidaito idan bambancin kowanne daga cikin maki na batutuwan su (Sinanci, Lissafi, Turanci) bai wuce 5 ba, kuma jimillar bambancin maki nasu bai wuce 10 ba.\n    >>> FindEqualOpponents(new List<Tuple<int, int, int>> { Tuple.Create(90, 90, 90), Tuple.Create(85, 95, 90), Tuple.Create(80, 100, 91) })\n    2",
      "hi": "उन छात्रों की जोड़ी की संख्या निर्धारित करता है जिन्हें \"समान प्रतिद्वंद्वी\" माना जाता है। दो छात्र समान प्रतिद्वंद्वी होते हैं यदि उनके प्रत्येक विषय (चीनी, गणित, अंग्रेजी) के अंकों में अंतर 5 से अधिक नहीं होता है, और उनके अंकों में कुल अंतर 10 से अधिक नहीं होता है।\n    >>> FindEqualOpponents(new List<Tuple<int, int, int>> { Tuple.Create(90, 90, 90), Tuple.Create(85, 95, 90), Tuple.Create(80, 100, 91) })\n    2",
      "hu": "Meghatározza azoknak a diákpároknak a számát, akiket \"egyenlő ellenfeleknek\" tekintünk. Két diák akkor tekinthető egyenlő ellenfélnek, ha az egyes tantárgyaik (kínai, matematika, angol) pontszámainak különbsége nem haladja meg az 5-öt, és az összpontszámuk különbsége nem haladja meg a 10-et.\n    >>> FindEqualOpponents(new List<Tuple<int, int, int>> { Tuple.Create(90, 90, 90), Tuple.Create(85, 95, 90), Tuple.Create(80, 100, 91) })\n    2"
    },
    "docstring_bertscore": {
      "sq": "0.9748158526189675",
      "hy": "0.9737740362704396",
      "bn": "0.9618043708788961",
      "bg": "0.9750438802963957",
      "zh": "0.9301778457193782",
      "fr": "0.9847620703189085",
      "de": "0.9783548501178662",
      "ha": "0.9939254856871911",
      "hi": "0.9820503683570203",
      "hu": "0.9648986349546577"
    }
  },
  {
    "task_id": "C#/43",
    "prompt": {
      "en": "using System;\nusing System.Collections.Generic;\nusing System.Diagnostics;\n\nclass Program\n{\n\n/* Finds the length of the longest consecutive elements sequence in a given list of integers.\n    The sequence does not need to be in order but must consist of consecutive natural numbers.\n    >>> LongestConsecutiveSequence(new List<int> {1, 5, 6, 2, 3, 4, 5, 6, 8, 9})\n    6\n    >>> LongestConsecutiveSequence(new List<int> {10, 4, 20, 1, 3, 2})\n    4\n*/\n\nstatic int LongestConsecutiveSequence(List<int> sequence)",
      "sq": "using System;\nusing System.Collections.Generic;\nusing System.Diagnostics;\n\nclass Program\n{\n\n/* Gjen gjatësinë e sekuencës më të gjatë të elementeve radhazi në një listë të dhënë të numrave të plotë.\n    Sekuenca nuk ka nevojë të jetë në rregull, por duhet të përbëhet nga numra natyralë radhazi.\n    >>> LongestConsecutiveSequence(new List<int> {1, 5, 6, 2, 3, 4, 5, 6, 8, 9})\n    6\n    >>> LongestConsecutiveSequence(new List<int> {10, 4, 20, 1, 3, 2})\n    4\n*/\n\nstatic int LongestConsecutiveSequence(List<int> sequence)",
      "hy": "using System;\nusing System.Collections.Generic;\nusing System.Diagnostics;\n\nclass Program\n{\n\n/* Գտնում է տրված ամբողջ թվերի ցուցակի ամենաերկար հաջորդական տարրերի հաջորդականության երկարությունը:\n    Հաջորդականությունը կարիք չունի լինել հերթականությամբ, բայց պետք է բաղկացած լինի հաջորդական բնական թվերից:\n    >>> LongestConsecutiveSequence(new List<int> {1, 5, 6, 2, 3, 4, 5, 6, 8, 9})\n    6\n    >>> LongestConsecutiveSequence(new List<int> {10, 4, 20, 1, 3, 2})\n    4\n*/\n\nstatic int LongestConsecutiveSequence(List<int> sequence)",
      "bn": "using System;\nusing System.Collections.Generic;\nusing System.Diagnostics;\n\nclass Program\n{\n\n/* একটি প্রদত্ত পূর্ণসংখ্যার তালিকায় দীর্ঘতম ধারাবাহিক উপাদানগুলির ক্রমের দৈর্ঘ্য খুঁজে বের করে।\n    ক্রমটি ক্রমানুসারে হতে হবে না কিন্তু ধারাবাহিক প্রাকৃতিক সংখ্যার সমন্বয়ে গঠিত হতে হবে।\n    >>> LongestConsecutiveSequence(new List<int> {1, 5, 6, 2, 3, 4, 5, 6, 8, 9})\n    6\n    >>> LongestConsecutiveSequence(new List<int> {10, 4, 20, 1, 3, 2})\n    4\n*/\n\nstatic int LongestConsecutiveSequence(List<int> sequence)",
      "bg": "using System;\nusing System.Collections.Generic;\nusing System.Diagnostics;\n\nclass Program\n{\n\n/* Намира дължината на най-дългата последователност от последователни елементи в даден списък от цели числа.\n    Последователността не е необходимо да бъде в ред, но трябва да се състои от последователни естествени числа.\n    >>> LongestConsecutiveSequence(new List<int> {1, 5, 6, 2, 3, 4, 5, 6, 8, 9})\n    6\n    >>> LongestConsecutiveSequence(new List<int> {10, 4, 20, 1, 3, 2})\n    4\n*/\n\nstatic int LongestConsecutiveSequence(List<int> sequence)",
      "zh": "using System;\nusing System.Collections.Generic;\nusing System.Diagnostics;\n\nclass Program\n{\n\n/* 查找给定整数列表中最长连续元素序列的长度。\n    序列不需要按顺序排列，但必须由连续自然数组成。\n    >>> LongestConsecutiveSequence(new List<int> {1, 5, 6, 2, 3, 4, 5, 6, 8, 9})\n    6\n    >>> LongestConsecutiveSequence(new List<int> {10, 4, 20, 1, 3, 2})\n    4\n*/\n\nstatic int LongestConsecutiveSequence(List<int> sequence)",
      "fr": "using System;\nusing System.Collections.Generic;\nusing System.Diagnostics;\n\nclass Program\n{\n\n/* Trouve la longueur de la plus longue séquence d'éléments consécutifs dans une liste donnée d'entiers.\n    La séquence n'a pas besoin d'être dans l'ordre mais doit être constituée de nombres naturels consécutifs.\n    >>> LongestConsecutiveSequence(new List<int> {1, 5, 6, 2, 3, 4, 5, 6, 8, 9})\n    6\n    >>> LongestConsecutiveSequence(new List<int> {10, 4, 20, 1, 3, 2})\n    4\n*/\n\nstatic int LongestConsecutiveSequence(List<int> sequence)",
      "de": "using System;\nusing System.Collections.Generic;\nusing System.Diagnostics;\n\nclass Program\n{\n\n/* Findet die Länge der längsten Folge von aufeinanderfolgenden Elementen in einer gegebenen Liste von ganzen Zahlen.\n    Die Folge muss nicht in Reihenfolge sein, muss aber aus aufeinanderfolgenden natürlichen Zahlen bestehen.\n    >>> LongestConsecutiveSequence(new List<int> {1, 5, 6, 2, 3, 4, 5, 6, 8, 9})\n    6\n    >>> LongestConsecutiveSequence(new List<int> {10, 4, 20, 1, 3, 2})\n    4\n*/\n\nstatic int LongestConsecutiveSequence(List<int> sequence)",
      "ha": "using System;\nusing System.Collections.Generic;\nusing System.Diagnostics;\n\nclass Program\n{\n\n/* Nemo tsawon jerin abubuwan da suka fi tsawo a jere a cikin jerin lambobi masu cikakken lamba.\n    Jerin ba lallai ne ya kasance a tsari ba amma dole ne ya ƙunshi lambobi na halitta masu jere.\n    >>> LongestConsecutiveSequence(new List<int> {1, 5, 6, 2, 3, 4, 5, 6, 8, 9})\n    6\n    >>> LongestConsecutiveSequence(new List<int> {10, 4, 20, 1, 3, 2})\n    4\n*/\n\nstatic int LongestConsecutiveSequence(List<int> sequence)",
      "hi": "using System;\nusing System.Collections.Generic;\nusing System.Diagnostics;\n\nclass Program\n{\n\n/* दिए गए पूर्णांकों की सूची में सबसे लंबे लगातार तत्वों के अनुक्रम की लंबाई पाता है।\n    अनुक्रम को क्रम में होने की आवश्यकता नहीं है लेकिन इसमें लगातार प्राकृतिक संख्याएँ होनी चाहिए।\n    >>> LongestConsecutiveSequence(new List<int> {1, 5, 6, 2, 3, 4, 5, 6, 8, 9})\n    6\n    >>> LongestConsecutiveSequence(new List<int> {10, 4, 20, 1, 3, 2})\n    4\n*/\n\nstatic int LongestConsecutiveSequence(List<int> sequence)",
      "hu": "using System;\nusing System.Collections.Generic;\nusing System.Diagnostics;\n\nclass Program\n{\n\n/* Megkeresi a leghosszabb egymást követő elemek sorozatának hosszát egy adott egész számokat tartalmazó listában.\n    A sorozatnak nem kell sorrendben lennie, de egymást követő természetes számokból kell állnia.\n    >>> LongestConsecutiveSequence(new List<int> {1, 5, 6, 2, 3, 4, 5, 6, 8, 9})\n    6\n    >>> LongestConsecutiveSequence(new List<int> {10, 4, 20, 1, 3, 2})\n    4\n*/\n\nstatic int LongestConsecutiveSequence(List<int> sequence)"
    },
    "prompt_bertscore": {
      "sq": "0.9885193626065645",
      "hy": "0.9948576580653877",
      "bn": "0.9926316073851298",
      "bg": "0.9885193626065645",
      "zh": "0.9893921445008318",
      "fr": "0.9936060880344869",
      "de": "0.9885193626065645",
      "ha": "0.9602802799652155",
      "hi": "0.9972537363518116",
      "hu": "0.990902132657459"
    },
    "canonical_solution": "{\n    var numberSet = new HashSet<int>(sequence);\n    int longestStreak = 0;\n\n    foreach (int number in numberSet)\n    {\n        if (!numberSet.Contains(number - 1))\n        {\n            int currentNumber = number;\n            int currentStreak = 1;\n\n            while (numberSet.Contains(currentNumber + 1))\n            {\n                currentNumber += 1;\n                currentStreak += 1;\n            }\n\n            longestStreak = Math.Max(longestStreak, currentStreak);\n        }\n    }\n\n    return longestStreak;\n}",
    "instruction": {
      "en": "Write a C# function `static int LongestConsecutiveSequence(List<int> sequence)` to solve the following problem:\nFinds the length of the longest consecutive elements sequence in a given list of integers.\n    The sequence does not need to be in order but must consist of consecutive natural numbers.\n    >>> LongestConsecutiveSequence(new List<int> {1, 5, 6, 2, 3, 4, 5, 6, 8, 9})\n    6\n    >>> LongestConsecutiveSequence(new List<int> {10, 4, 20, 1, 3, 2})\n    4",
      "sq": "Shkruani një funksion C# `static int LongestConsecutiveSequence(List<int> sequence)` për të zgjidhur problemin në vijim:\nGjen gjatësinë e sekuencës më të gjatë të elementeve radhazi në një listë të dhënë të numrave të plotë.\n    Sekuenca nuk ka nevojë të jetë në rend por duhet të përbëhet nga numra natyralë radhazi.\n    >>> LongestConsecutiveSequence(new List<int> {1, 5, 6, 2, 3, 4, 5, 6, 8, 9})\n    6\n    >>> LongestConsecutiveSequence(new List<int> {10, 4, 20, 1, 3, 2})\n    4",
      "hy": "Գրեք C# ֆունկցիա `static int LongestConsecutiveSequence(List<int> sequence)` հետևյալ խնդիրը լուծելու համար:\nԳտնում է ամենաերկար հաջորդական տարրերի հաջորդականության երկարությունը տրված ամբողջ թվերի ցուցակում:\n    Հաջորդականությունը կարիք չունի լինել կարգավորված, բայց պետք է բաղկացած լինի հաջորդական բնական թվերից:\n    >>> LongestConsecutiveSequence(new List<int> {1, 5, 6, 2, 3, 4, 5, 6, 8, 9})\n    6\n    >>> LongestConsecutiveSequence(new List<int> {10, 4, 20, 1, 3, 2})\n    4",
      "bn": "C# ফাংশন `static int LongestConsecutiveSequence(List<int> sequence)` লিখুন নিম্নলিখিত সমস্যার সমাধানের জন্য:\nএকটি প্রদত্ত পূর্ণসংখ্যার তালিকায় সবচেয়ে দীর্ঘ ধারাবাহিক উপাদানগুলির ক্রমের দৈর্ঘ্য খুঁজে বের করে।\n    ক্রমটি ক্রমানুসারে থাকা প্রয়োজন নেই তবে ধারাবাহিক প্রাকৃতিক সংখ্যার সমন্বয়ে গঠিত হতে হবে।\n    >>> LongestConsecutiveSequence(new List<int> {1, 5, 6, 2, 3, 4, 5, 6, 8, 9})\n    6\n    >>> LongestConsecutiveSequence(new List<int> {10, 4, 20, 1, 3, 2})\n    4",
      "bg": "Напишете C# функция `static int LongestConsecutiveSequence(List<int> sequence)`, за да решите следния проблем:\nНамира дължината на най-дългата последователност от последователни елементи в даден списък от цели числа.\n    Последователността не е необходимо да бъде в ред, но трябва да се състои от последователни естествени числа.\n    >>> LongestConsecutiveSequence(new List<int> {1, 5, 6, 2, 3, 4, 5, 6, 8, 9})\n    6\n    >>> LongestConsecutiveSequence(new List<int> {10, 4, 20, 1, 3, 2})\n    4",
      "zh": "编写一个 C# 函数 `static int LongestConsecutiveSequence(List<int> sequence)` 来解决以下问题：\n找到给定整数列表中最长连续元素序列的长度。\n    序列不需要按顺序排列，但必须由连续的自然数组成。\n    >>> LongestConsecutiveSequence(new List<int> {1, 5, 6, 2, 3, 4, 5, 6, 8, 9})\n    6\n    >>> LongestConsecutiveSequence(new List<int> {10, 4, 20, 1, 3, 2})\n    4",
      "fr": "Écrire une fonction C# `static int LongestConsecutiveSequence(List<int> sequence)` pour résoudre le problème suivant :\nTrouve la longueur de la plus longue séquence d'éléments consécutifs dans une liste donnée d'entiers.\n    La séquence n'a pas besoin d'être en ordre mais doit être constituée de nombres naturels consécutifs.\n    >>> LongestConsecutiveSequence(new List<int> {1, 5, 6, 2, 3, 4, 5, 6, 8, 9})\n    6\n    >>> LongestConsecutiveSequence(new List<int> {10, 4, 20, 1, 3, 2})\n    4",
      "de": "Schreiben Sie eine C#-Funktion `static int LongestConsecutiveSequence(List<int> sequence)`, um das folgende Problem zu lösen:\nFindet die Länge der längsten Sequenz von aufeinanderfolgenden Elementen in einer gegebenen Liste von ganzen Zahlen.\n    Die Sequenz muss nicht in Reihenfolge sein, muss aber aus aufeinanderfolgenden natürlichen Zahlen bestehen.\n    >>> LongestConsecutiveSequence(new List<int> {1, 5, 6, 2, 3, 4, 5, 6, 8, 9})\n    6\n    >>> LongestConsecutiveSequence(new List<int> {10, 4, 20, 1, 3, 2})\n    4",
      "ha": "Rubuta aikin C# `static int LongestConsecutiveSequence(List<int> sequence)` don warware matsalar mai zuwa:\nNemo tsawon jerin abubuwan da suka fi tsayi a jere a cikin jerin lambobi na duka.\n    Jerin ba lallai ne ya kasance a tsari ba amma dole ne ya ƙunshi lambobin halitta masu jere.\n    >>> LongestConsecutiveSequence(new List<int> {1, 5, 6, 2, 3, 4, 5, 6, 8, 9})\n    6\n    >>> LongestConsecutiveSequence(new List<int> {10, 4, 20, 1, 3, 2})\n    4",
      "hi": "C# फ़ंक्शन `static int LongestConsecutiveSequence(List<int> sequence)` लिखें ताकि निम्नलिखित समस्या का समाधान किया जा सके:\nदिए गए पूर्णांकों की सूची में सबसे लंबे लगातार तत्वों के अनुक्रम की लंबाई खोजें।\n    अनुक्रम को क्रम में होने की आवश्यकता नहीं है लेकिन इसमें लगातार प्राकृतिक संख्याएँ होनी चाहिए।\n    >>> LongestConsecutiveSequence(new List<int> {1, 5, 6, 2, 3, 4, 5, 6, 8, 9})\n    6\n    >>> LongestConsecutiveSequence(new List<int> {10, 4, 20, 1, 3, 2})\n    4",
      "hu": "Írj egy C# függvényt `static int LongestConsecutiveSequence(List<int> sequence)` a következő probléma megoldására:\nMegtalálja a leghosszabb egymást követő elemek sorozatának hosszát egy adott egész számokat tartalmazó listában.\n    A sorozatnak nem kell sorrendben lennie, de egymást követő természetes számokból kell állnia.\n    >>> LongestConsecutiveSequence(new List<int> {1, 5, 6, 2, 3, 4, 5, 6, 8, 9})\n    6\n    >>> LongestConsecutiveSequence(new List<int> {10, 4, 20, 1, 3, 2})\n    4"
    },
    "instruction_bertscore": {
      "sq": "0.9915085512107585",
      "hy": "0.9911671055857596",
      "bn": "0.9790530359072038",
      "bg": "0.9865733807635657",
      "zh": "0.9882208211438691",
      "fr": "0.9923976207962707",
      "de": "0.9893800280475886",
      "ha": "0.9605633282581902",
      "hi": "0.9745761057490584",
      "hu": "0.9835045413765767"
    },
    "level": "middle",
    "test": "    static void Main()\n    {\n        Debug.Assert(LongestConsecutiveSequence(new List<int> {1, 5, 6, 2, 3, 4, 5, 6, 8, 9}) == 6);\n        Debug.Assert(LongestConsecutiveSequence(new List<int> {10, 4, 20, 1, 3, 2}) == 4);\n        Debug.Assert(LongestConsecutiveSequence(new List<int> {100, 4, 200, 1, 3, 2}) == 4);\n        Debug.Assert(LongestConsecutiveSequence(new List<int> {1, 1}) == 1);\n\n    }\n}\n\n",
    "entry_point": "LongestConsecutiveSequence",
    "signature": "static int LongestConsecutiveSequence(List<int> sequence)",
    "docstring": {
      "en": "Finds the length of the longest consecutive elements sequence in a given list of integers.\n    The sequence does not need to be in order but must consist of consecutive natural numbers.\n    >>> LongestConsecutiveSequence(new List<int> {1, 5, 6, 2, 3, 4, 5, 6, 8, 9})\n    6\n    >>> LongestConsecutiveSequence(new List<int> {10, 4, 20, 1, 3, 2})\n    4",
      "sq": "Gjen gjatësinë e sekuencës më të gjatë të elementeve të njëpasnjëshme në një listë të dhënë të numrave të plotë.\n    Sekuenca nuk ka nevojë të jetë në rregull, por duhet të përbëhet nga numra natyrorë të njëpasnjëshëm.\n    >>> LongestConsecutiveSequence(new List<int> {1, 5, 6, 2, 3, 4, 5, 6, 8, 9})\n    6\n    >>> LongestConsecutiveSequence(new List<int> {10, 4, 20, 1, 3, 2})\n    4",
      "hy": "Գտնում է ամենաերկար հաջորդական տարրերի հաջորդականության երկարությունը տրված ամբողջ թվերի ցուցակում։  \n    Հաջորդականությունը կարիք չունի լինել կարգավորված, բայց պետք է կազմված լինի հաջորդական բնական թվերից։\n    >>> LongestConsecutiveSequence(new List<int> {1, 5, 6, 2, 3, 4, 5, 6, 8, 9})\n    6\n    >>> LongestConsecutiveSequence(new List<int> {10, 4, 20, 1, 3, 2})\n    4",
      "bn": "দেওয়া পূর্ণসংখ্যার তালিকায় দীর্ঘতম ধারাবাহিক উপাদানগুলির ক্রমের দৈর্ঘ্য খুঁজে বের করে। \n    ক্রমটি ক্রমানুসারে হতে হবে না তবে ধারাবাহিক প্রাকৃতিক সংখ্যাগুলি নিয়ে গঠিত হতে হবে।\n    >>> LongestConsecutiveSequence(new List<int> {1, 5, 6, 2, 3, 4, 5, 6, 8, 9})\n    6\n    >>> LongestConsecutiveSequence(new List<int> {10, 4, 20, 1, 3, 2})\n    4",
      "bg": "Намира дължината на най-дългата последователност от последователни елементи в даден списък от цели числа.\n    Последователността не е необходимо да бъде в ред, но трябва да се състои от последователни естествени числа.\n    >>> LongestConsecutiveSequence(new List<int> {1, 5, 6, 2, 3, 4, 5, 6, 8, 9})\n    6\n    >>> LongestConsecutiveSequence(new List<int> {10, 4, 20, 1, 3, 2})\n    4",
      "zh": "找到给定整数列表中最长连续元素序列的长度。  \n序列不需要按顺序排列，但必须由连续的自然数组成。  \n>>> LongestConsecutiveSequence(new List<int> {1, 5, 6, 2, 3, 4, 5, 6, 8, 9})  \n6  \n>>> LongestConsecutiveSequence(new List<int> {10, 4, 20, 1, 3, 2})  \n4",
      "fr": "Trouve la longueur de la plus longue séquence d'éléments consécutifs dans une liste donnée d'entiers.\n    La séquence n'a pas besoin d'être dans l'ordre mais doit être constituée de nombres naturels consécutifs.\n    >>> LongestConsecutiveSequence(new List<int> {1, 5, 6, 2, 3, 4, 5, 6, 8, 9})\n    6\n    >>> LongestConsecutiveSequence(new List<int> {10, 4, 20, 1, 3, 2})\n    4",
      "de": "Findet die Länge der längsten Sequenz aufeinanderfolgender Elemente in einer gegebenen Liste von ganzen Zahlen.\n    Die Sequenz muss nicht geordnet sein, muss aber aus aufeinanderfolgenden natürlichen Zahlen bestehen.\n    >>> LongestConsecutiveSequence(new List<int> {1, 5, 6, 2, 3, 4, 5, 6, 8, 9})\n    6\n    >>> LongestConsecutiveSequence(new List<int> {10, 4, 20, 1, 3, 2})\n    4",
      "ha": "Yana gano tsawon jerin abubuwan da suka fi tsayi a jere a cikin jerin lambobi na integers da aka bayar.\n    Jerin ba dole ne ya kasance a tsari ba amma dole ne ya ƙunshi lambobi na halitta masu jere.\n    >>> LongestConsecutiveSequence(new List<int> {1, 5, 6, 2, 3, 4, 5, 6, 8, 9})\n    6\n    >>> LongestConsecutiveSequence(new List<int> {10, 4, 20, 1, 3, 2})\n    4",
      "hi": "दिए गए पूर्णांकों की सूची में सबसे लंबे लगातार तत्वों के अनुक्रम की लंबाई खोजता है।\n    अनुक्रम को क्रम में होने की आवश्यकता नहीं है लेकिन इसमें लगातार प्राकृतिक संख्याएँ होनी चाहिए।\n    >>> LongestConsecutiveSequence(new List<int> {1, 5, 6, 2, 3, 4, 5, 6, 8, 9})\n    6\n    >>> LongestConsecutiveSequence(new List<int> {10, 4, 20, 1, 3, 2})\n    4",
      "hu": "Megtalálja a leghosszabb egymást követő elemek sorozatának hosszát egy adott egész számokat tartalmazó listában.\n    A sorozatnak nem kell sorrendben lennie, de egymást követő természetes számokból kell állnia.\n    >>> LongestConsecutiveSequence(new List<int> {1, 5, 6, 2, 3, 4, 5, 6, 8, 9})\n    6\n    >>> LongestConsecutiveSequence(new List<int> {10, 4, 20, 1, 3, 2})\n    4"
    },
    "docstring_bertscore": {
      "sq": "0.9872967926112948",
      "hy": "0.989802912128812",
      "bn": "0.9852320298004371",
      "bg": "0.9869027099353216",
      "zh": "0.9805888460133656",
      "fr": "0.9901169467612281",
      "de": "0.9898519738329276",
      "ha": "0.9719621299346394",
      "hi": "0.9914412155115877",
      "hu": "0.9871976760511584"
    }
  },
  {
    "task_id": "C#/44",
    "prompt": {
      "en": "using System;\nusing System.Collections.Generic;\nusing System.Diagnostics;\n\nclass Program\n{\n\n/* Determines whose geometric shape has a larger area: Alice's square with side length a, or Bob's rectangle with sides b and c.\n    - If Alice's square has a larger area, return \"Alice\".\n    - If Bob's rectangle has a larger area, return \"Bob\".\n    \n    Examples:\n    >>> CompareArea(5, 4, 6)\n    \"Alice\"\n    \n    >>> CompareArea(7, 5, 10)\n    \"Bob\"\n*/\n\nstatic string CompareArea(int a, int b, int c)",
      "sq": "using System;\nusing System.Collections.Generic;\nusing System.Diagnostics;\n\nclass Program\n{\n\n/* Përcakton se cila formë gjeometrike ka një sipërfaqe më të madhe: katrori i Alice me gjatësi brinje a, apo drejtkëndëshi i Bob me brinjë b dhe c.\n    - Nëse katrori i Alice ka një sipërfaqe më të madhe, kthe \"Alice\".\n    - Nëse drejtkëndëshi i Bob ka një sipërfaqe më të madhe, kthe \"Bob\".\n    \n    Shembuj:\n    >>> CompareArea(5, 4, 6)\n    \"Alice\"\n    \n    >>> CompareArea(7, 5, 10)\n    \"Bob\"\n*/\n\nstatic string CompareArea(int a, int b, int c)",
      "hy": "using System;\nusing System.Collections.Generic;\nusing System.Diagnostics;\n\nclass Program\n{\n\n/* Որոշում է, թե ում երկրաչափական ձևն ունի ավելի մեծ մակերես՝ Ալիսի քառակուսին կողմի երկարությամբ a, թե՞ Բոբի ուղղանկյունը կողմերով b և c:\n    - Եթե Ալիսի քառակուսին ունի ավելի մեծ մակերես, վերադարձնում է \"Alice\":\n    - Եթե Բոբի ուղղանկյունը ունի ավելի մեծ մակերես, վերադարձնում է \"Bob\":\n    \n    Օրինակներ:\n    >>> CompareArea(5, 4, 6)\n    \"Alice\"\n    \n    >>> CompareArea(7, 5, 10)\n    \"Bob\"\n*/\n\nstatic string CompareArea(int a, int b, int c)",
      "bn": "using System;\nusing System.Collections.Generic;\nusing System.Diagnostics;\n\nclass Program\n{\n\n/* নির্ধারণ করে কার জ্যামিতিক আকারের ক্ষেত্রফল বড়: অ্যালিসের বর্গক্ষেত্র যার বাহুর দৈর্ঘ্য a, অথবা ববের আয়তক্ষেত্র যার বাহুর দৈর্ঘ্য b এবং c।\n    - যদি অ্যালিসের বর্গক্ষেত্রের ক্ষেত্রফল বড় হয়, তাহলে \"Alice\" ফেরত দিন।\n    - যদি ববের আয়তক্ষেত্রের ক্ষেত্রফল বড় হয়, তাহলে \"Bob\" ফেরত দিন।\n    \n    উদাহরণ:\n    >>> CompareArea(5, 4, 6)\n    \"Alice\"\n    \n    >>> CompareArea(7, 5, 10)\n    \"Bob\"\n*/\n\nstatic string CompareArea(int a, int b, int c)",
      "bg": "using System;\nusing System.Collections.Generic;\nusing System.Diagnostics;\n\nclass Program\n{\n\n/* Определя чия геометрична фигура има по-голяма площ: квадратът на Алис със страна a или правоъгълникът на Боб със страни b и c.\n    - Ако квадратът на Алис има по-голяма площ, връща \"Alice\".\n    - Ако правоъгълникът на Боб има по-голяма площ, връща \"Bob\".\n    \n    Примери:\n    >>> CompareArea(5, 4, 6)\n    \"Alice\"\n    \n    >>> CompareArea(7, 5, 10)\n    \"Bob\"\n*/\n\nstatic string CompareArea(int a, int b, int c)",
      "zh": "using System;\nusing System.Collections.Generic;\nusing System.Diagnostics;\n\nclass Program\n{\n\n/* 判断谁的几何形状面积更大：Alice的边长为a的正方形，还是Bob的边长为b和c的矩形。\n    - 如果Alice的正方形面积更大，返回\"Alice\"。\n    - 如果Bob的矩形面积更大，返回\"Bob\"。\n    \n    示例：\n    >>> CompareArea(5, 4, 6)\n    \"Alice\"\n    \n    >>> CompareArea(7, 5, 10)\n    \"Bob\"\n*/\n\nstatic string CompareArea(int a, int b, int c)",
      "fr": "using System;\nusing System.Collections.Generic;\nusing System.Diagnostics;\n\nclass Program\n{\n\n/* Détermine quelle forme géométrique a une plus grande surface : le carré d'Alice avec une longueur de côté a, ou le rectangle de Bob avec des côtés b et c.\n    - Si le carré d'Alice a une plus grande surface, retourne \"Alice\".\n    - Si le rectangle de Bob a une plus grande surface, retourne \"Bob\".\n    \n    Exemples :\n    >>> CompareArea(5, 4, 6)\n    \"Alice\"\n    \n    >>> CompareArea(7, 5, 10)\n    \"Bob\"\n*/\n\nstatic string CompareArea(int a, int b, int c)",
      "de": "using System;\nusing System.Collections.Generic;\nusing System.Diagnostics;\n\nclass Program\n{\n\n/* Bestimmt, wessen geometrische Form eine größere Fläche hat: Alices Quadrat mit Seitenlänge a oder Bobs Rechteck mit den Seiten b und c.\n    - Wenn Alices Quadrat eine größere Fläche hat, gib \"Alice\" zurück.\n    - Wenn Bobs Rechteck eine größere Fläche hat, gib \"Bob\" zurück.\n    \n    Beispiele:\n    >>> CompareArea(5, 4, 6)\n    \"Alice\"\n    \n    >>> CompareArea(7, 5, 10)\n    \"Bob\"\n*/\n\nstatic string CompareArea(int a, int b, int c)",
      "ha": "using System;\nusing System.Collections.Generic;\nusing System.Diagnostics;\n\nclass Program\n{\n\n/* Yana tantance wane siffar lissafi ke da babbar yanki: murabba'in Alice da tsawon gefe a, ko kuma murabba'in Bob da gefuna b da c.\n    - Idan murabba'in Alice yana da babbar yanki, dawo da \"Alice\".\n    - Idan murabba'in Bob yana da babbar yanki, dawo da \"Bob\".\n    \n    Misalai:\n    >>> CompareArea(5, 4, 6)\n    \"Alice\"\n    \n    >>> CompareArea(7, 5, 10)\n    \"Bob\"\n*/\n\nstatic string CompareArea(int a, int b, int c)",
      "hi": "using System;\nusing System.Collections.Generic;\nusing System.Diagnostics;\n\nclass Program\n{\n\n/* यह निर्धारित करता है कि किसका ज्यामितीय आकार बड़ा है: ऐलिस का वर्ग जिसकी भुजा की लंबाई a है, या बॉब का आयत जिसकी भुजाएँ b और c हैं।\n    - यदि ऐलिस के वर्ग का क्षेत्रफल बड़ा है, तो \"Alice\" लौटाएं।\n    - यदि बॉब के आयत का क्षेत्रफल बड़ा है, तो \"Bob\" लौटाएं।\n    \n    उदाहरण:\n    >>> CompareArea(5, 4, 6)\n    \"Alice\"\n    \n    >>> CompareArea(7, 5, 10)\n    \"Bob\"\n*/\n\nstatic string CompareArea(int a, int b, int c)",
      "hu": "using System;\nusing System.Collections.Generic;\nusing System.Diagnostics;\n\nclass Program\n{\n\n/* Meghatározza, hogy kinek a geometriai alakzatának nagyobb a területe: Alice négyzetének, amelynek oldalhossza a, vagy Bob téglalapjának, amelynek oldalai b és c.\n    - Ha Alice négyzete nagyobb területű, akkor térjen vissza az \"Alice\" értékkel.\n    - Ha Bob téglalapja nagyobb területű, akkor térjen vissza a \"Bob\" értékkel.\n    \n    Példák:\n    >>> CompareArea(5, 4, 6)\n    \"Alice\"\n    \n    >>> CompareArea(7, 5, 10)\n    \"Bob\"\n*/\n\nstatic string CompareArea(int a, int b, int c)"
    },
    "prompt_bertscore": {
      "sq": "0.9958684880744744",
      "hy": "0.9826925403789061",
      "bn": "0.9895339665928907",
      "bg": "0.984325679371775",
      "zh": "0.9895339665928907",
      "fr": "0.9958684880744744",
      "de": "0.9975808805893761",
      "ha": "0.976589026030466",
      "hi": "0.9808633531999558",
      "hu": "0.9810097437907784"
    },
    "canonical_solution": "{\n    int squareArea = a * a;\n    int rectangleArea = b * c;\n    return squareArea > rectangleArea ? \"Alice\" : \"Bob\";\n}",
    "instruction": {
      "en": "Write a C# function `static string CompareArea(int a, int b, int c)` to solve the following problem:\nDetermines whose geometric shape has a larger area: Alice's square with side length a, or Bob's rectangle with sides b and c.\n    - If Alice's square has a larger area, return \"Alice\".\n    - If Bob's rectangle has a larger area, return \"Bob\".\n    \n    Examples:\n    >>> CompareArea(5, 4, 6)\n    \"Alice\"\n    \n    >>> CompareArea(7, 5, 10)\n    \"Bob\"",
      "sq": "Shkruani një funksion në C# `static string CompareArea(int a, int b, int c)` për të zgjidhur problemin e mëposhtëm:\nPërcakton se cila formë gjeometrike ka një sipërfaqe më të madhe: katrori i Alice me gjatësi brinje a, apo drejtkëndëshi i Bob me brinjë b dhe c.\n- Nëse katrori i Alice ka një sipërfaqe më të madhe, kthe \"Alice\".\n- Nëse drejtkëndëshi i Bob ka një sipërfaqe më të madhe, kthe \"Bob\".\n\nShembuj:\n>>> CompareArea(5, 4, 6)\n\"Alice\"\n\n>>> CompareArea(7, 5, 10)\n\"Bob\"",
      "hy": "Գրեք C# ֆունկցիա `static string CompareArea(int a, int b, int c)` հետևյալ խնդիրը լուծելու համար:\nՈրոշում է, թե ում երկրաչափական ձևն ունի ավելի մեծ մակերես՝ Ալիսի քառակուսին կողքի երկարությամբ a, թե Բոբի ուղղանկյունը կողմերով b և c:\n   - Եթե Ալիսի քառակուսին ունի ավելի մեծ մակերես, վերադարձնել \"Alice\":\n   - Եթե Բոբի ուղղանկյունը ունի ավելի մեծ մակերես, վերադարձնել \"Bob\":\n   \n   Օրինակներ:\n   >>> CompareArea(5, 4, 6)\n   \"Alice\"\n   \n   >>> CompareArea(7, 5, 10)\n   \"Bob\"",
      "bn": "C# ফাংশন `static string CompareArea(int a, int b, int c)` লিখুন নিম্নলিখিত সমস্যার সমাধানের জন্য: নির্ধারণ করে কার জ্যামিতিক আকারের ক্ষেত্রফল বড়: এলিসের বর্গক্ষেত্র যার বাহুর দৈর্ঘ্য a, অথবা ববের আয়তক্ষেত্র যার বাহুর দৈর্ঘ্য b এবং c।\n    - যদি এলিসের বর্গক্ষেত্রের ক্ষেত্রফল বড় হয়, \"Alice\" রিটার্ন করুন।\n    - যদি ববের আয়তক্ষেত্রের ক্ষেত্রফল বড় হয়, \"Bob\" রিটার্ন করুন।\n    \n    উদাহরণ:\n    >>> CompareArea(5, 4, 6)\n    \"Alice\"\n    \n    >>> CompareArea(7, 5, 10)\n    \"Bob\"",
      "bg": "Напишете C# функция `static string CompareArea(int a, int b, int c)` за решаване на следния проблем:\nОпределя чия геометрична фигура има по-голяма площ: квадратът на Алис със страна a или правоъгълникът на Боб със страни b и c.\n- Ако квадратът на Алис има по-голяма площ, върнете \"Alice\".\n- Ако правоъгълникът на Боб има по-голяма площ, върнете \"Bob\".\n\nПримери:\n>>> CompareArea(5, 4, 6)\n\"Alice\"\n\n>>> CompareArea(7, 5, 10)\n\"Bob\"",
      "zh": "编写一个 C# 函数 `static string CompareArea(int a, int b, int c)` 来解决以下问题：\n确定谁的几何形状面积更大：Alice 的边长为 a 的正方形，还是 Bob 的边长为 b 和 c 的矩形。\n- 如果 Alice 的正方形面积更大，返回 \"Alice\"。\n- 如果 Bob 的矩形面积更大，返回 \"Bob\"。\n\n示例：\n>>> CompareArea(5, 4, 6)\n\"Alice\"\n\n>>> CompareArea(7, 5, 10)\n\"Bob\"",
      "fr": "Écrire une fonction C# `static string CompareArea(int a, int b, int c)` pour résoudre le problème suivant :  \nDétermine quelle forme géométrique a une plus grande surface : le carré d'Alice avec une longueur de côté a, ou le rectangle de Bob avec des côtés b et c.  \n- Si le carré d'Alice a une plus grande surface, retourner \"Alice\".  \n- Si le rectangle de Bob a une plus grande surface, retourner \"Bob\".  \n  \nExemples :  \n>>> CompareArea(5, 4, 6)  \n\"Alice\"  \n  \n>>> CompareArea(7, 5, 10)  \n\"Bob\"",
      "de": "Schreiben Sie eine C#-Funktion `static string CompareArea(int a, int b, int c)`, um das folgende Problem zu lösen:\nBestimmt, wessen geometrische Form eine größere Fläche hat: Alices Quadrat mit Seitenlänge a oder Bobs Rechteck mit den Seiten b und c.\n- Wenn Alices Quadrat eine größere Fläche hat, geben Sie \"Alice\" zurück.\n- Wenn Bobs Rechteck eine größere Fläche hat, geben Sie \"Bob\" zurück.\n\nBeispiele:\n>>> CompareArea(5, 4, 6)\n\"Alice\"\n\n>>> CompareArea(7, 5, 10)\n\"Bob\"",
      "ha": "Rubuta aikin C# `static string CompareArea(int a, int b, int c)` don warware matsalar mai zuwa:\nYana tantance wanda ke da babban yanki na siffar lissafi: murabba'in Alice mai gefen tsawo a, ko kuma murabba'in Bob mai gefen b da c.\n   - Idan murabba'in Alice yana da babban yanki, dawo da \"Alice\".\n   - Idan murabba'in Bob yana da babban yanki, dawo da \"Bob\".\n   \n   Misalai:\n   >>> CompareArea(5, 4, 6)\n   \"Alice\"\n   \n   >>> CompareArea(7, 5, 10)\n   \"Bob\"",
      "hi": "C# फ़ंक्शन `static string CompareArea(int a, int b, int c)` लिखें ताकि निम्नलिखित समस्या का समाधान किया जा सके:\nनिर्धारित करें कि किसका ज्यामितीय आकार बड़ा क्षेत्रफल रखता है: ऐलिस का वर्ग जिसकी भुजा की लंबाई a है, या बॉब का आयत जिसकी भुजाएँ b और c हैं।\n    - यदि ऐलिस के वर्ग का क्षेत्रफल बड़ा है, तो \"Alice\" लौटाएँ।\n    - यदि बॉब के आयत का क्षेत्रफल बड़ा है, तो \"Bob\" लौटाएँ।\n    \n    उदाहरण:\n    >>> CompareArea(5, 4, 6)\n    \"Alice\"\n    \n    >>> CompareArea(7, 5, 10)\n    \"Bob\"",
      "hu": "Írj egy C# függvényt `static string CompareArea(int a, int b, int c)` a következő probléma megoldására:\nMegállapítja, hogy kinek a geometriai alakzata rendelkezik nagyobb területtel: Alice négyzete, amelynek oldalhossza a, vagy Bob téglalapja, amelynek oldalai b és c.\n- Ha Alice négyzetének nagyobb a területe, térjen vissza az \"Alice\" értékkel.\n- Ha Bob téglalapjának nagyobb a területe, térjen vissza a \"Bob\" értékkel.\n\nPéldák:\n>>> CompareArea(5, 4, 6)\n\"Alice\"\n\n>>> CompareArea(7, 5, 10)\n\"Bob\""
    },
    "instruction_bertscore": {
      "sq": "0.9850959679894282",
      "hy": "0.9901761386147765",
      "bn": "0.9749509212780713",
      "bg": "0.9738308445594156",
      "zh": "0.9857830304774279",
      "fr": "0.9879258550280322",
      "de": "0.9857534345506537",
      "ha": "0.9611806714824467",
      "hi": "0.9744181945961358",
      "hu": "0.9714701224808159"
    },
    "level": "easy",
    "test": "    static void Main()\n    {\n        Debug.Assert(CompareArea(5, 4, 6) == \"Alice\");\n        Debug.Assert(CompareArea(7, 5, 10) == \"Bob\");\n        Debug.Assert(CompareArea(2, 2, 8) == \"Bob\"); // Testing with a square of side 2 and a rectangle 2x8\n        Debug.Assert(CompareArea(10, 5, 5) == \"Alice\"); // Testing with a square of side 10 and a rectangle 5x5\n\n\n    }\n}\n\n",
    "entry_point": "CompareArea",
    "signature": "static string CompareArea(int a, int b, int c)",
    "docstring": {
      "en": "Determines whose geometric shape has a larger area: Alice's square with side length a, or Bob's rectangle with sides b and c.\n    - If Alice's square has a larger area, return \"Alice\".\n    - If Bob's rectangle has a larger area, return \"Bob\".\n    \n    Examples:\n    >>> CompareArea(5, 4, 6)\n    \"Alice\"\n    \n    >>> CompareArea(7, 5, 10)\n    \"Bob\"",
      "sq": "Përcakton se cila formë gjeometrike ka një sipërfaqe më të madhe: katrori i Alisës me gjatësi të brinjës a, apo drejtkëndëshi i Bobit me brinjë b dhe c.\n    - Nëse katrori i Alisës ka një sipërfaqe më të madhe, kthe \"Alice\".\n    - Nëse drejtkëndëshi i Bobit ka një sipërfaqe më të madhe, kthe \"Bob\".\n    \n    Shembuj:\n    >>> CompareArea(5, 4, 6)\n    \"Alice\"\n    \n    >>> CompareArea(7, 5, 10)\n    \"Bob\"",
      "hy": "Սահմանում է, թե ում երկրաչափական ձևն ունի ավելի մեծ մակերես՝ Ալիսի քառակուսին կողքի երկարությամբ a, թե՞ Բոբի ուղղանկյունը կողմերով b և c:\n- Եթե Ալիսի քառակուսին ունի ավելի մեծ մակերես, վերադարձնել \"Alice\":\n- Եթե Բոբի ուղղանկյունը ունի ավելի մեծ մակերես, վերադարձնել \"Bob\":\n\nՕրինակներ:\n>>> CompareArea(5, 4, 6)\n\"Alice\"\n\n>>> CompareArea(7, 5, 10)\n\"Bob\"",
      "bn": "যার জ্যামিতিক আকারের ক্ষেত্রফল বড় তা নির্ধারণ করে: অ্যালিসের বর্গক্ষেত্র যার বাহুর দৈর্ঘ্য a, অথবা ববের আয়তক্ষেত্র যার বাহুর দৈর্ঘ্য b এবং c।\n    - যদি অ্যালিসের বর্গক্ষেত্রের ক্ষেত্রফল বড় হয়, তাহলে \"Alice\" ফেরত দিন।\n    - যদি ববের আয়তক্ষেত্রের ক্ষেত্রফল বড় হয়, তাহলে \"Bob\" ফেরত দিন।\n    \n    উদাহরণসমূহ:\n    >>> CompareArea(5, 4, 6)\n    \"Alice\"\n    \n    >>> CompareArea(7, 5, 10)\n    \"Bob\"",
      "bg": "Определя чия геометрична форма има по-голяма площ: квадратът на Алис със страна a или правоъгълникът на Боб със страни b и c.\n    - Ако квадратът на Алис има по-голяма площ, връща \"Alice\".\n    - Ако правоъгълникът на Боб има по-голяма площ, връща \"Bob\".\n    \n    Примери:\n    >>> CompareArea(5, 4, 6)\n    \"Alice\"\n    \n    >>> CompareArea(7, 5, 10)\n    \"Bob\"",
      "zh": "确定谁的几何形状面积更大：Alice 的边长为 a 的正方形，还是 Bob 的边长为 b 和 c 的矩形。\n    - 如果 Alice 的正方形面积更大，返回 \"Alice\"。\n    - 如果 Bob 的矩形面积更大，返回 \"Bob\"。\n    \n    示例：\n    >>> CompareArea(5, 4, 6)\n    \"Alice\"\n    \n    >>> CompareArea(7, 5, 10)\n    \"Bob\"",
      "fr": "Détermine quelle forme géométrique a une plus grande surface : le carré d'Alice avec une longueur de côté a, ou le rectangle de Bob avec des côtés b et c.\n    - Si le carré d'Alice a une plus grande surface, retourne \"Alice\".\n    - Si le rectangle de Bob a une plus grande surface, retourne \"Bob\".\n    \n    Exemples :\n    >>> CompareArea(5, 4, 6)\n    \"Alice\"\n    \n    >>> CompareArea(7, 5, 10)\n    \"Bob\"",
      "de": "Bestimmt, wessen geometrische Form eine größere Fläche hat: Alices Quadrat mit Seitenlänge a oder Bobs Rechteck mit den Seiten b und c.\n- Wenn Alices Quadrat eine größere Fläche hat, gib \"Alice\" zurück.\n- Wenn Bobs Rechteck eine größere Fläche hat, gib \"Bob\" zurück.\n\nBeispiele:\n>>> CompareArea(5, 4, 6)\n\"Alice\"\n\n>>> CompareArea(7, 5, 10)\n\"Bob\"",
      "ha": "Yana tantance wanda ke da babban yanki na siffar jigon lissafi: murabba'in Alice mai tsawon gefe a, ko kuma murabus din Bob mai bangarori b da c.\n   - Idan murabba'in Alice yana da babban yanki, dawo da \"Alice\".\n   - Idan murabus din Bob yana da babban yanki, dawo da \"Bob\".\n    \n   Misalai:\n   >>> CompareArea(5, 4, 6)\n   \"Alice\"\n    \n   >>> CompareArea(7, 5, 10)\n   \"Bob\"",
      "hi": "निर्धारित करता है कि किसका ज्यामितीय आकार बड़ा क्षेत्रफल रखता है: एलिस का वर्ग जिसकी भुजा की लंबाई a है, या बॉब का आयत जिसकी भुजाएँ b और c हैं।\n- यदि एलिस के वर्ग का क्षेत्रफल बड़ा है, तो \"Alice\" लौटाएँ।\n- यदि बॉब के आयत का क्षेत्रफल बड़ा है, तो \"Bob\" लौटाएँ।\n\nउदाहरण:\n>>> CompareArea(5, 4, 6)\n\"Alice\"\n\n>>> CompareArea(7, 5, 10)\n\"Bob\"",
      "hu": "Meghatározza, kinek a geometriai alakzata rendelkezik nagyobb területtel: Alice négyzete az a oldalhosszal, vagy Bob téglalapja a b és c oldalhosszal.\n    - Ha Alice négyzete nagyobb területtel rendelkezik, térjen vissza az \"Alice\" értékkel.\n    - Ha Bob téglalapja nagyobb területtel rendelkezik, térjen vissza a \"Bob\" értékkel.\n    \n    Példák:\n    >>> CompareArea(5, 4, 6)\n    \"Alice\"\n    \n    >>> CompareArea(7, 5, 10)\n    \"Bob\""
    },
    "docstring_bertscore": {
      "sq": "0.9941600681671933",
      "hy": "0.9839087542019826",
      "bn": "0.9791289127127591",
      "bg": "0.9799607767485332",
      "zh": "0.9825699854338076",
      "fr": "0.9842213984217316",
      "de": "0.9931772450418326",
      "ha": "0.9672188364355262",
      "hi": "0.9923390248338654",
      "hu": "0.9843636177745526"
    }
  },
  {
    "task_id": "C#/45",
    "prompt": {
      "en": "using System;\nusing System.Collections.Generic;\nusing System.Diagnostics;\n\nclass Program\n{\n\n/* Finds M positive integers that sum up to N and have the maximum possible product. If multiple solutions exist, \n   returns the one with the lexicographically smallest sequence.\n    >>> MaxProductPartition(6, 3)\n    [2, 2, 2]\n\n*/\n\n\n    public static List<int> MaxProductPartition(int N, int M)",
      "sq": "using System;\nusing System.Collections.Generic;\nusing System.Diagnostics;\n\nclass Program\n{\n\n/* Gjen M numra të plotë pozitivë që shuma e tyre është N dhe kanë produktin maksimal të mundshëm. Nëse ekzistojnë zgjidhje të shumta,\n   kthen atë me sekuencën leksikografikisht më të vogël.\n    >>> MaxProductPartition(6, 3)\n    [2, 2, 2]\n\n*/\n\n\n    public static List<int> MaxProductPartition(int N, int M)",
      "hy": "using System;\nusing System.Collections.Generic;\nusing System.Diagnostics;\n\nclass Program\n{\n\n/* Գտնում է M դրական ամբողջ թվեր, որոնք գումարվում են N-ի և ունեն հնարավոր առավելագույն արտադրյալը։ Եթե գոյություն ունեն բազմաթիվ լուծումներ,\n   վերադարձնում է լեքսիկոգրաֆիկորեն ամենափոքր հաջորդականությունը:\n    >>> MaxProductPartition(6, 3)\n    [2, 2, 2]\n\n*/\n\n\n    public static List<int> MaxProductPartition(int N, int M)",
      "bn": "using System;\nusing System.Collections.Generic;\nusing System.Diagnostics;\n\nclass Program\n{\n\n/* এমন M ধনাত্মক পূর্ণসংখ্যা খুঁজে বের করে যা N এর সমান এবং যাদের গুণফল সম্ভবপর সর্বাধিক। যদি একাধিক সমাধান থাকে,\n   তাহলে লেক্সিকোগ্রাফিকভাবে ক্ষুদ্রতম ক্রমটি ফেরত দেয়।\n    >>> MaxProductPartition(6, 3)\n    [2, 2, 2]\n\n*/\n\n\n    public static List<int> MaxProductPartition(int N, int M)",
      "bg": "using System;\nusing System.Collections.Generic;\nusing System.Diagnostics;\n\nclass Program\n{\n\n/* Намира M положителни цели числа, които се сумират до N и имат максимално възможен произведение. Ако съществуват множество решения,\n   връща това с лексикографски най-малката последователност.\n    >>> MaxProductPartition(6, 3)\n    [2, 2, 2]\n\n*/\n\n\n    public static List<int> MaxProductPartition(int N, int M)",
      "zh": "using System;\nusing System.Collections.Generic;\nusing System.Diagnostics;\n\nclass Program\n{\n\n/* 查找 M 个正整数，这些整数的和为 N，并且具有尽可能大的乘积。如果存在多个解决方案，\n   返回按字典序排列最小的序列。\n    >>> MaxProductPartition(6, 3)\n    [2, 2, 2]\n\n*/\n\n\n    public static List<int> MaxProductPartition(int N, int M)",
      "fr": "using System;\nusing System.Collections.Generic;\nusing System.Diagnostics;\n\nclass Program\n{\n\n/* Trouve M entiers positifs qui s'additionnent pour donner N et qui ont le produit maximal possible. Si plusieurs solutions existent,\n   retourne celle avec la séquence lexicographiquement la plus petite.\n    >>> MaxProductPartition(6, 3)\n    [2, 2, 2]\n\n*/\n\n\n    public static List<int> MaxProductPartition(int N, int M)",
      "de": "using System;\nusing System.Collections.Generic;\nusing System.Diagnostics;\n\nclass Program\n{\n\n/* Findet M positive ganze Zahlen, die sich zu N summieren und das maximal mögliche Produkt haben. Wenn mehrere Lösungen existieren,\n   wird diejenige mit der lexikografisch kleinsten Sequenz zurückgegeben.\n    >>> MaxProductPartition(6, 3)\n    [2, 2, 2]\n\n*/\n\n\n    public static List<int> MaxProductPartition(int N, int M)",
      "ha": "using System;\nusing System.Collections.Generic;\nusing System.Diagnostics;\n\nclass Program\n{\n\n/* Nemi lambobin M masu kyau waɗanda ke ƙara zuwa N kuma suna da mafi girman samfurin da zai yiwu. Idan akwai hanyoyi da dama, \n   dawo da wanda ke da jerin mafi ƙarancin lexicographically.\n    >>> MaxProductPartition(6, 3)\n    [2, 2, 2]\n\n*/\n\n\n    public static List<int> MaxProductPartition(int N, int M)",
      "hi": "using System;\nusing System.Collections.Generic;\nusing System.Diagnostics;\n\nclass Program\n{\n\n/* M धनात्मक पूर्णांक खोजता है जिनका योग N होता है और जिनका गुणनफल संभवतः अधिकतम होता है। यदि कई समाधान मौजूद हैं,\n   तो वह अनुक्रम लौटाता है जो शब्दकोशानुसार सबसे छोटा होता है।\n    >>> MaxProductPartition(6, 3)\n    [2, 2, 2]\n\n*/\n\n\n    public static List<int> MaxProductPartition(int N, int M)",
      "hu": "using System;\nusing System.Collections.Generic;\nusing System.Diagnostics;\n\nclass Program\n{\n\n/* Megtalálja azt az M pozitív egész számot, amelyek összege N és a lehető legnagyobb szorzatot adják. Ha több megoldás létezik, \n   akkor a lexikografikusan legkisebb sorozatot adja vissza.\n    >>> MaxProductPartition(6, 3)\n    [2, 2, 2]\n\n*/\n\n\n    public static List<int> MaxProductPartition(int N, int M)"
    },
    "prompt_bertscore": {
      "sq": "0.985561756232955",
      "hy": "0.9722038631083588",
      "bn": "0.9416531200925258",
      "bg": "1",
      "zh": "0.9547742458029284",
      "fr": "0.9953746929472216",
      "de": "0.9922734768081238",
      "ha": "0.9577977974630415",
      "hi": "0.9561801516398933",
      "hu": "0.9431764164846823"
    },
    "canonical_solution": "    {\n        List<int> partition = new List<int>();\n\n        // If M is greater than N, then we'll have M numbers of 1\n        if (M >= N)\n        {\n            for (int i = 0; i < N; i++)\n            {\n                partition.Add(1);\n            }\n            return partition;\n        }\n\n        // Otherwise, distribute the sum N among M numbers\n        int quotient = N / M;\n        int remainder = N % M;\n\n        // Add M-remainder numbers of quotient\n        for (int i = 0; i < M - remainder; i++)\n        {\n            partition.Add(quotient);\n        }\n\n        // Add remainder numbers of quotient + 1\n        for (int i = 0; i < remainder; i++)\n        {\n            partition.Add(quotient + 1);\n        }\n\n        return partition;\n    }",
    "instruction": {
      "en": "Write a C# function `public static List<int> MaxProductPartition(int N, int M)` to solve the following problem:\nFinds M positive integers that sum up to N and have the maximum possible product. If multiple solutions exist, \n   returns the one with the lexicographically smallest sequence.\n    >>> MaxProductPartition(6, 3)\n    [2, 2, 2]",
      "sq": "Shkruani një funksion në C# `public static List<int> MaxProductPartition(int N, int M)` për të zgjidhur problemin në vijim:  \nGjen M numra të plotë pozitivë që shuma e tyre është N dhe kanë produktin maksimal të mundshëm. Nëse ekzistojnë zgjidhje të shumta,  \n   kthen atë me sekuencën më të vogël leksikografike.  \n    >>> MaxProductPartition(6, 3)  \n    [2, 2, 2]",
      "hy": "Գրեք C# ֆունկցիա `public static List<int> MaxProductPartition(int N, int M)` հետևյալ խնդիրը լուծելու համար:\nԳտնում է M դրական ամբողջ թվեր, որոնք գումարվում են N-ի և ունեն առավելագույն հնարավոր արտադրյալ: Եթե գոյություն ունեն բազմաթիվ լուծումներ, \n   վերադարձնում է լեքսիկոգրաֆիկորեն ամենափոքր հաջորդականությունը:\n    >>> MaxProductPartition(6, 3)\n    [2, 2, 2]",
      "bn": "একটি C# ফাংশন `public static List<int> MaxProductPartition(int N, int M)` লিখুন নিম্নলিখিত সমস্যার সমাধান করার জন্য:\nএমটি ধনাত্মক পূর্ণসংখ্যা খুঁজে বের করে যা এন এর সমান যোগফল এবং সর্বাধিক সম্ভাব্য গুণফল থাকে। যদি একাধিক সমাধান থাকে, \n   তাহলে লেক্সিকোগ্রাফিকভাবে সবচেয়ে ছোট ক্রমটি ফেরত দেয়।\n    >>> MaxProductPartition(6, 3)\n    [2, 2, 2]",
      "bg": "Напишете C# функция `public static List<int> MaxProductPartition(int N, int M)`, за да решите следния проблем:\nНамира M положителни цели числа, които се сумират до N и имат максимално възможен произведение. Ако съществуват множество решения,\n   връща това с лексикографски най-малката последователност.\n    >>> MaxProductPartition(6, 3)\n    [2, 2, 2]",
      "zh": "编写一个 C# 函数 `public static List<int> MaxProductPartition(int N, int M)` 来解决以下问题：  \n寻找 M 个正整数，这些整数的和为 N，并且乘积最大。如果存在多个解决方案，返回字典序最小的序列。  \n    >>> MaxProductPartition(6, 3)  \n    [2, 2, 2]",
      "fr": "Écrire une fonction C# `public static List<int> MaxProductPartition(int N, int M)` pour résoudre le problème suivant :  \nTrouver M entiers positifs dont la somme est égale à N et ayant le produit maximal possible. Si plusieurs solutions existent,  \n   renvoie celle avec la séquence lexicographiquement la plus petite.  \n    >>> MaxProductPartition(6, 3)  \n    [2, 2, 2]",
      "de": "Schreiben Sie eine C#-Funktion `public static List<int> MaxProductPartition(int N, int M)`, um das folgende Problem zu lösen:\nFindet M positive ganze Zahlen, die sich zu N summieren und das maximal mögliche Produkt haben. Wenn mehrere Lösungen existieren, \n   wird diejenige mit der lexikographisch kleinsten Sequenz zurückgegeben.\n    >>> MaxProductPartition(6, 3)\n    [2, 2, 2]",
      "ha": "Rubuta aikin C# `public static List<int> MaxProductPartition(int N, int M)` don warware matsalar mai zuwa:  \nNemo lambobi M masu kyau waɗanda suka haɗa zuwa N kuma suna da mafi girman samfurin da zai yiwu. Idan akwai hanyoyi da yawa,  \n   dawo da wanda ke da jerin mafi ƙanƙanta a cikin tsarin haruffa.  \n    >>> MaxProductPartition(6, 3)  \n    [2, 2, 2]",
      "hi": "C# फ़ंक्शन `public static List<int> MaxProductPartition(int N, int M)` लिखें ताकि निम्नलिखित समस्या का समाधान किया जा सके:\nऐसे M धनात्मक पूर्णांक खोजें जिनका योग N हो और जिनका गुणनफल अधिकतम संभव हो। यदि कई समाधान मौजूद हैं, तो \n   वह लौटाएं जिसमें वर्णक्रमानुसार सबसे छोटा अनुक्रम हो।\n    >>> MaxProductPartition(6, 3)\n    [2, 2, 2]",
      "hu": "Írj egy C# függvényt `public static List<int> MaxProductPartition(int N, int M)` a következő probléma megoldására:\nTalálj M pozitív egész számot, amelyek összege N és a lehető legnagyobb szorzatot adják. Ha több megoldás létezik, \n   add vissza azt, amelyik a lexikografikusan legkisebb sorozat.\n    >>> MaxProductPartition(6, 3)\n    [2, 2, 2]"
    },
    "instruction_bertscore": {
      "sq": "0.959713587488123",
      "hy": "0.9817456693525127",
      "bn": "0.9668501784483254",
      "bg": "0.9294524475678387",
      "zh": "0.9403657965930386",
      "fr": "0.9773162118554347",
      "de": "0.9903950292946769",
      "ha": "0.9362714285487664",
      "hi": "0.8914399556580491",
      "hu": "0.9520200369394987"
    },
    "level": "hard",
    "test": "    static void Main()\n    {\n\n        Debug.Assert(MaxProductPartition(6, 3).SequenceEqual(new List<int> { 2, 2, 2 }));\n        Debug.Assert(MaxProductPartition(8, 3).SequenceEqual(new List<int> { 2, 3, 3 }));\n        Debug.Assert(MaxProductPartition(10, 2).SequenceEqual(new List<int> { 5, 5 }));\n        Debug.Assert(MaxProductPartition(7, 3).SequenceEqual(new List<int> { 2, 2, 3 }));\n\n    }\n}\n",
    "entry_point": "MaxProductPartition",
    "signature": "public static List<int> MaxProductPartition(int N, int M)",
    "docstring": {
      "en": "Finds M positive integers that sum up to N and have the maximum possible product. If multiple solutions exist, \n   returns the one with the lexicographically smallest sequence.\n    >>> MaxProductPartition(6, 3)\n    [2, 2, 2]",
      "sq": "Gjen M numra të plotë pozitivë që shuma e tyre është N dhe kanë produktin maksimal të mundshëm. Nëse ekzistojnë zgjidhje të shumta, kthen atë me sekuencën më të vogël leksikografike.\n    >>> MaxProductPartition(6, 3)\n    [2, 2, 2]",
      "hy": "Գտնում է M դրական ամբողջ թվեր, որոնք գումարվում են N և ունեն առավելագույն հնարավոր արտադրյալը։ Եթե գոյություն ունեն մի քանի լուծումներ, վերադարձնում է այն, որը ունի լեքսիկոգրաֆիկորեն ամենափոքր հաջորդականությունը։  \n    >>> MaxProductPartition(6, 3)  \n    [2, 2, 2]",
      "bn": "এমটি ধনাত্মক পূর্ণসংখ্যা খুঁজে বের করে যা এন-এর সমান এবং সর্বাধিক সম্ভাব্য গুণফল রয়েছে। যদি একাধিক সমাধান থাকে, \n   তাহলে লেক্সিকোগ্রাফিকভাবে ক্ষুদ্রতম ক্রম সহ সমাধানটি ফেরত দেয়।\n    >>> MaxProductPartition(6, 3)\n    [2, 2, 2]",
      "bg": "Намира M положителни цели числа, които се сумират до N и имат максимално възможен произведение. Ако съществуват множество решения, връща това с лексикографски най-малката последователност.\n    >>> MaxProductPartition(6, 3)\n    [2, 2, 2]",
      "zh": "找到 M 个正整数，这些正整数的和为 N，并且乘积最大。如果存在多个解决方案，返回按字典序最小的序列。\n    >>> MaxProductPartition(6, 3)\n    [2, 2, 2]",
      "fr": "Trouve M entiers positifs dont la somme est égale à N et qui ont le produit maximal possible. Si plusieurs solutions existent, retourne celle avec la séquence lexicographiquement la plus petite.\n    >>> MaxProductPartition(6, 3)\n    [2, 2, 2]",
      "de": "Findet M positive ganze Zahlen, die sich zu N summieren und das maximal mögliche Produkt haben. Wenn mehrere Lösungen existieren, wird diejenige mit der lexikografisch kleinsten Sequenz zurückgegeben.\n    >>> MaxProductPartition(6, 3)\n    [2, 2, 2]",
      "ha": "Nemi lambobin M masu kyau waɗanda ke ƙara zuwa N kuma suna da mafi girman samfurin da zai yiwu. Idan akwai hanyoyi da dama, \n   ya dawo da wanda ke da jerin mafi ƙarancin lexicographically.\n    >>> MaxProductPartition(6, 3)\n    [2, 2, 2]",
      "hi": "M सकारात्मक पूर्णांक खोजता है जिनका योग N होता है और जिनका गुणनफल अधिकतम संभव होता है। यदि कई समाधान मौजूद हैं, तो \n   वह समाधान लौटाता है जिसमें क्रमानुसार सबसे छोटा अनुक्रम होता है।\n    >>> MaxProductPartition(6, 3)\n    [2, 2, 2]",
      "hu": "Megtalálja azt az M pozitív egész számot, amelyek összege N és a lehető legnagyobb szorzatot adják. Ha több megoldás létezik, akkor azt adja vissza, amelyik lexikografikusan a legkisebb sorozat.\n    >>> MaxProductPartition(6, 3)\n    [2, 2, 2]"
    },
    "docstring_bertscore": {
      "sq": "0.9417844147743898",
      "hy": "0.976537382131397",
      "bn": "0.9089911347566728",
      "bg": "0.977584958760975",
      "zh": "0.9041723617127665",
      "fr": "0.958558353192024",
      "de": "0.9715352732457954",
      "ha": "0.9378473619918972",
      "hi": "0.9149564023599126",
      "hu": "0.9007408232500077"
    }
  },
  {
    "task_id": "C#/46",
    "prompt": {
      "en": "using System;\nusing System.Collections.Generic;\nusing System.Diagnostics;\n\nclass Program\n{\n\n/* Counts the number of characters in a given title string, excluding spaces and newline characters.\n    >>> CountTitleCharacters(\"234\")\n    3\n    >>> CountTitleCharacters(\"Ca 45\")\n    4\n    >>> CountTitleCharacters(\"Hello World\\n\")\n    10\n    >>> CountTitleCharacters(\" 123 \")\n    3\n*/\n\nstatic int CountTitleCharacters(string title)",
      "sq": "using System;\nusing System.Collections.Generic;\nusing System.Diagnostics;\n\nclass Program\n{\n\n/* Numëron numrin e karaktereve në një varg titulli të dhënë, duke përjashtuar hapësirat dhe karakteret e reja të rreshtit.\n    >>> CountTitleCharacters(\"234\")\n    3\n    >>> CountTitleCharacters(\"Ca 45\")\n    4\n    >>> CountTitleCharacters(\"Hello World\\n\")\n    10\n    >>> CountTitleCharacters(\" 123 \")\n    3\n*/\n\nstatic int CountTitleCharacters(string title)",
      "hy": "using System;\nusing System.Collections.Generic;\nusing System.Diagnostics;\n\nclass Program\n{\n\n/* Հաշվում է տրված վերնագրի տողի սիմվոլների քանակը, բացի բացատներից և նոր տողի սիմվոլներից:\n    >>> CountTitleCharacters(\"234\")\n    3\n    >>> CountTitleCharacters(\"Ca 45\")\n    4\n    >>> CountTitleCharacters(\"Hello World\\n\")\n    10\n    >>> CountTitleCharacters(\" 123 \")\n    3\n*/\n\nstatic int CountTitleCharacters(string title)",
      "bn": "using System;\nusing System.Collections.Generic;\nusing System.Diagnostics;\n\nclass Program\n{\n\n/* একটি প্রদত্ত শিরোনাম স্ট্রিং-এ অক্ষরের সংখ্যা গণনা করে, যেখানে ফাঁকা স্থান এবং নতুন লাইন অক্ষর অন্তর্ভুক্ত নয়।\n    >>> CountTitleCharacters(\"234\")\n    3\n    >>> CountTitleCharacters(\"Ca 45\")\n    4\n    >>> CountTitleCharacters(\"Hello World\\n\")\n    10\n    >>> CountTitleCharacters(\" 123 \")\n    3\n*/\n\nstatic int CountTitleCharacters(string title)",
      "bg": "using System;\nusing System.Collections.Generic;\nusing System.Diagnostics;\n\nclass Program\n{\n\n/* Брои броя на символите в даден низ заглавие, без да включва интервали и знаци за нов ред.\n    >>> CountTitleCharacters(\"234\")\n    3\n    >>> CountTitleCharacters(\"Ca 45\")\n    4\n    >>> CountTitleCharacters(\"Hello World\\n\")\n    10\n    >>> CountTitleCharacters(\" 123 \")\n    3\n*/\n\nstatic int CountTitleCharacters(string title)",
      "zh": "using System;\nusing System.Collections.Generic;\nusing System.Diagnostics;\n\nclass Program\n{\n\n/* 计算给定标题字符串中的字符数，不包括空格和换行符。\n    >>> CountTitleCharacters(\"234\")\n    3\n    >>> CountTitleCharacters(\"Ca 45\")\n    4\n    >>> CountTitleCharacters(\"Hello World\\n\")\n    10\n    >>> CountTitleCharacters(\" 123 \")\n    3\n*/\n\nstatic int CountTitleCharacters(string title)",
      "fr": "using System;\nusing System.Collections.Generic;\nusing System.Diagnostics;\n\nclass Program\n{\n\n/* Compte le nombre de caractères dans une chaîne de titre donnée, en excluant les espaces et les caractères de nouvelle ligne.\n    >>> CountTitleCharacters(\"234\")\n    3\n    >>> CountTitleCharacters(\"Ca 45\")\n    4\n    >>> CountTitleCharacters(\"Hello World\\n\")\n    10\n    >>> CountTitleCharacters(\" 123 \")\n    3\n*/\n\nstatic int CountTitleCharacters(string title)",
      "de": "using System;\nusing System.Collections.Generic;\nusing System.Diagnostics;\n\nclass Program\n{\n\n/* Zählt die Anzahl der Zeichen in einem gegebenen Titelstring, ohne Leerzeichen und Zeilenumbrüche.\n    >>> CountTitleCharacters(\"234\")\n    3\n    >>> CountTitleCharacters(\"Ca 45\")\n    4\n    >>> CountTitleCharacters(\"Hello World\\n\")\n    10\n    >>> CountTitleCharacters(\" 123 \")\n    3\n*/\n\nstatic int CountTitleCharacters(string title)",
      "ha": "using System;\nusing System.Collections.Generic;\nusing System.Diagnostics;\n\nclass Program\n{\n\n/* Yana ƙididdige yawan haruffa a cikin wata takamaiman taken rubutu, ba tare da haɗa sarari da haruffan sabon layi ba.\n    >>> CountTitleCharacters(\"234\")\n    3\n    >>> CountTitleCharacters(\"Ca 45\")\n    4\n    >>> CountTitleCharacters(\"Hello World\\n\")\n    10\n    >>> CountTitleCharacters(\" 123 \")\n    3\n*/\n\nstatic int CountTitleCharacters(string title)",
      "hi": "using System;\nusing System.Collections.Generic;\nusing System.Diagnostics;\n\nclass Program\n{\n\n/* दिए गए शीर्षक स्ट्रिंग में वर्णों की संख्या गिनता है, जिसमें रिक्त स्थान और नई पंक्ति के वर्ण शामिल नहीं होते।\n    >>> CountTitleCharacters(\"234\")\n    3\n    >>> CountTitleCharacters(\"Ca 45\")\n    4\n    >>> CountTitleCharacters(\"Hello World\\n\")\n    10\n    >>> CountTitleCharacters(\" 123 \")\n    3\n*/\n\nstatic int CountTitleCharacters(string title)",
      "hu": "using System;\nusing System.Collections.Generic;\nusing System.Diagnostics;\n\nclass Program\n{\n\n/* Megszámolja a karakterek számát egy adott cím sztringben, a szóközök és az új sor karakterek kivételével.\n    >>> CountTitleCharacters(\"234\")\n    3\n    >>> CountTitleCharacters(\"Ca 45\")\n    4\n    >>> CountTitleCharacters(\"Hello World\\n\")\n    10\n    >>> CountTitleCharacters(\" 123 \")\n    3\n*/\n\nstatic int CountTitleCharacters(string title)"
    },
    "prompt_bertscore": {
      "sq": "0.999999801369619",
      "hy": "0.9913450784071668",
      "bn": "0.9830941710093586",
      "bg": "0.999999801369619",
      "zh": "0.9858448045259297",
      "fr": "0.999999801369619",
      "de": "0.9858954552730936",
      "ha": "0.9818000940769163",
      "hi": "0.9969228181370076",
      "hu": "0.999999801369619"
    },
    "canonical_solution": "{\n    int count = 0;\n    foreach (char c in title)\n    {\n        if (!char.IsWhiteSpace(c)) // Checks for any whitespace character including space and newline.\n        {\n            count++;\n        }\n    }\n    return count;\n}",
    "instruction": {
      "en": "Write a C# function `static int CountTitleCharacters(string title)` to solve the following problem:\nCounts the number of characters in a given title string, excluding spaces and newline characters.\n    >>> CountTitleCharacters(\"234\")\n    3\n    >>> CountTitleCharacters(\"Ca 45\")\n    4\n    >>> CountTitleCharacters(\"Hello World\\n\")\n    10\n    >>> CountTitleCharacters(\" 123 \")\n    3",
      "sq": "Shkruani një funksion në C# `static int CountTitleCharacters(string title)` për të zgjidhur problemin e mëposhtëm:  \nNumëron numrin e karaktereve në një varg titulli të dhënë, duke përjashtuar hapësirat dhe karakteret e reja të rreshtit.  \n    >>> CountTitleCharacters(\"234\")  \n    3  \n    >>> CountTitleCharacters(\"Ca 45\")  \n    4  \n    >>> CountTitleCharacters(\"Hello World\\n\")  \n    10  \n    >>> CountTitleCharacters(\" 123 \")  \n    3",
      "hy": "Գրեք C# ֆունկցիա `static int CountTitleCharacters(string title)` հետևյալ խնդիրը լուծելու համար:\nՀաշվում է տրված վերնագրի տողի մեջ գտնվող սիմվոլների քանակը, բացի բացատներից և նոր տողի սիմվոլներից:",
      "bn": "C# ফাংশন `static int CountTitleCharacters(string title)` লিখুন নিম্নলিখিত সমস্যার সমাধানের জন্য:\nপ্রদত্ত শিরোনাম স্ট্রিংয়ে অক্ষরের সংখ্যা গণনা করে, ফাঁকা স্থান এবং নতুন লাইন অক্ষর বাদ দিয়ে।\n    >>> CountTitleCharacters(\"234\")\n    3\n    >>> CountTitleCharacters(\"Ca 45\")\n    4\n    >>> CountTitleCharacters(\"Hello World\\n\")\n    10\n    >>> CountTitleCharacters(\" 123 \")\n    3",
      "bg": "Напишете C# функция `static int CountTitleCharacters(string title)` за решаване на следния проблем:  \nБрои броя на символите в даден низ на заглавие, изключвайки интервали и символи за нов ред.  \n    >>> CountTitleCharacters(\"234\")  \n    3  \n    >>> CountTitleCharacters(\"Ca 45\")  \n    4  \n    >>> CountTitleCharacters(\"Hello World\\n\")  \n    10  \n    >>> CountTitleCharacters(\" 123 \")  \n    3",
      "zh": "编写一个 C# 函数 `static int CountTitleCharacters(string title)` 来解决以下问题：  \n计算给定标题字符串中的字符数量，排除空格和换行符。  \n    >>> CountTitleCharacters(\"234\")  \n    3  \n    >>> CountTitleCharacters(\"Ca 45\")  \n    4  \n    >>> CountTitleCharacters(\"Hello World\\n\")  \n    10  \n    >>> CountTitleCharacters(\" 123 \")  \n    3  ",
      "fr": "Écrire une fonction C# `static int CountTitleCharacters(string title)` pour résoudre le problème suivant :\nCompte le nombre de caractères dans une chaîne de titre donnée, en excluant les espaces et les caractères de nouvelle ligne.\n    >>> CountTitleCharacters(\"234\")\n    3\n    >>> CountTitleCharacters(\"Ca 45\")\n    4\n    >>> CountTitleCharacters(\"Hello World\\n\")\n    10\n    >>> CountTitleCharacters(\" 123 \")\n    3",
      "de": "Schreiben Sie eine C#-Funktion `static int CountTitleCharacters(string title)`, um das folgende Problem zu lösen:\nZählt die Anzahl der Zeichen in einem gegebenen Titelstring, ohne Leerzeichen und Zeilenumbrüche zu berücksichtigen.\n    >>> CountTitleCharacters(\"234\")\n    3\n    >>> CountTitleCharacters(\"Ca 45\")\n    4\n    >>> CountTitleCharacters(\"Hello World\\n\")\n    10\n    >>> CountTitleCharacters(\" 123 \")\n    3",
      "ha": "Rubuta aikin C# `static int CountTitleCharacters(string title)` don warware matsalar mai zuwa:  \nƘidaya yawan haruffa a cikin wani takamaiman rubutun take, ban da sarari da haruffan sabon layi.  \n    >>> CountTitleCharacters(\"234\")  \n    3  \n    >>> CountTitleCharacters(\"Ca 45\")  \n    4  \n    >>> CountTitleCharacters(\"Hello World\\n\")  \n    10  \n    >>> CountTitleCharacters(\" 123 \")  \n    3  ",
      "hi": "C# फ़ंक्शन `static int CountTitleCharacters(string title)` लिखें ताकि निम्नलिखित समस्या का समाधान किया जा सके:\nदिए गए शीर्षक स्ट्रिंग में वर्णों की संख्या गिनें, जिसमें स्पेस और न्यूलाइन वर्ण शामिल नहीं हैं।",
      "hu": "Írj egy C# függvényt `static int CountTitleCharacters(string title)` a következő probléma megoldására:  \nMegszámolja a karakterek számát egy adott cím sztringben, kihagyva a szóközöket és az új sor karaktereket.  \n    >>> CountTitleCharacters(\"234\")  \n    3  \n    >>> CountTitleCharacters(\"Ca 45\")  \n    4  \n    >>> CountTitleCharacters(\"Hello World\\n\")  \n    10  \n    >>> CountTitleCharacters(\" 123 \")  \n    3"
    },
    "instruction_bertscore": {
      "sq": "0.992211702759622",
      "hy": "0.8346749681051366",
      "bn": "0.8369865819464193",
      "bg": "1",
      "zh": "0.9949416787165656",
      "fr": "0.8368241488279342",
      "de": "0.9778624454032807",
      "ha": "0.9734538440962114",
      "hi": "0.83119774465474",
      "hu": "1"
    },
    "level": "easy",
    "test": "    static void Main()\n    {\n        Debug.Assert(CountTitleCharacters(\"234\") == 3);\n        Debug.Assert(CountTitleCharacters(\"Ca 45\") == 4);\n        Debug.Assert(CountTitleCharacters(\"Hello World\\n\") == 10);\n        Debug.Assert(CountTitleCharacters(\" 123 \") == 3);\n        Debug.Assert(CountTitleCharacters(\"\\nNew\\tLine\") == 7);\n\n    }\n}",
    "entry_point": "CountTitleCharacters",
    "signature": "static int CountTitleCharacters(string title)",
    "docstring": {
      "en": "Counts the number of characters in a given title string, excluding spaces and newline characters.\n    >>> CountTitleCharacters(\"234\")\n    3\n    >>> CountTitleCharacters(\"Ca 45\")\n    4\n    >>> CountTitleCharacters(\"Hello World\\n\")\n    10\n    >>> CountTitleCharacters(\" 123 \")\n    3",
      "sq": "Numëron numrin e karaktereve në një varg titulli të dhënë, duke përjashtuar hapësirat dhe karakteret e rreshtave të rinj.\n    >>> CountTitleCharacters(\"234\")\n    3\n    >>> CountTitleCharacters(\"Ca 45\")\n    4\n    >>> CountTitleCharacters(\"Hello World\\n\")\n    10\n    >>> CountTitleCharacters(\" 123 \")\n    3",
      "hy": "Հաշվում է տրված վերնագրի տողում նիշերի քանակը, բացի բացատներից և նոր տողերի նիշերից:\n    >>> CountTitleCharacters(\"234\")\n    3\n    >>> CountTitleCharacters(\"Ca 45\")\n    4\n    >>> CountTitleCharacters(\"Hello World\\n\")\n    10\n    >>> CountTitleCharacters(\" 123 \")\n    3",
      "bn": "প্রদত্ত শিরোনাম স্ট্রিং-এ অক্ষরের সংখ্যা গণনা করে, যেখানে ফাঁকা স্থান এবং নতুন লাইন অক্ষর অন্তর্ভুক্ত নয়।\n    >>> CountTitleCharacters(\"234\")\n    3\n    >>> CountTitleCharacters(\"Ca 45\")\n    4\n    >>> CountTitleCharacters(\"Hello World\\n\")\n    10\n    >>> CountTitleCharacters(\" 123 \")\n    3",
      "bg": "Брои броя на символите в даден низ за заглавие, като изключва интервалите и символите за нов ред.\n    >>> CountTitleCharacters(\"234\")\n    3\n    >>> CountTitleCharacters(\"Ca 45\")\n    4\n    >>> CountTitleCharacters(\"Hello World\\n\")\n    10\n    >>> CountTitleCharacters(\" 123 \")\n    3",
      "zh": "计算给定标题字符串中的字符数，不包括空格和换行符。  \n    >>> CountTitleCharacters(\"234\")\n    3\n    >>> CountTitleCharacters(\"Ca 45\")\n    4\n    >>> CountTitleCharacters(\"Hello World\\n\")\n    10\n    >>> CountTitleCharacters(\" 123 \")\n    3",
      "fr": "Compte le nombre de caractères dans une chaîne de titre donnée, en excluant les espaces et les caractères de nouvelle ligne.\n    >>> CountTitleCharacters(\"234\")\n    3\n    >>> CountTitleCharacters(\"Ca 45\")\n    4\n    >>> CountTitleCharacters(\"Hello World\\n\")\n    10\n    >>> CountTitleCharacters(\" 123 \")\n    3",
      "de": "Zählt die Anzahl der Zeichen in einem gegebenen Titelstring, ohne Leerzeichen und Zeilenumbrüche zu berücksichtigen.\n    >>> CountTitleCharacters(\"234\")\n    3\n    >>> CountTitleCharacters(\"Ca 45\")\n    4\n    >>> CountTitleCharacters(\"Hello World\\n\")\n    10\n    >>> CountTitleCharacters(\" 123 \")\n    3",
      "ha": "Yana ƙididdige adadin haruffa a cikin wani take na kirtani da aka bayar, ba tare da haɗa sarari da haruffan sabbin layi ba.\n    >>> CountTitleCharacters(\"234\")\n    3\n    >>> CountTitleCharacters(\"Ca 45\")\n    4\n    >>> CountTitleCharacters(\"Hello World\\n\")\n    10\n    >>> CountTitleCharacters(\" 123 \")\n    3",
      "hi": "दिए गए शीर्षक स्ट्रिंग में वर्णों की संख्या की गणना करता है, जिसमें रिक्त स्थान और नई पंक्ति के वर्ण शामिल नहीं होते हैं।\n    >>> CountTitleCharacters(\"234\")\n    3\n    >>> CountTitleCharacters(\"Ca 45\")\n    4\n    >>> CountTitleCharacters(\"Hello World\\n\")\n    10\n    >>> CountTitleCharacters(\" 123 \")\n    3",
      "hu": "Számolja meg a karakterek számát egy adott cím sztringben, kihagyva a szóközöket és az új sor karaktereket.\n    >>> CountTitleCharacters(\"234\")\n    3\n    >>> CountTitleCharacters(\"Ca 45\")\n    4\n    >>> CountTitleCharacters(\"Hello World\\n\")\n    10\n    >>> CountTitleCharacters(\" 123 \")\n    3"
    },
    "docstring_bertscore": {
      "sq": "1",
      "hy": "0.9828139035417184",
      "bn": "0.9700169426131646",
      "bg": "1",
      "zh": "0.9705969433257865",
      "fr": "0.9919220996640732",
      "de": "0.9705594021837709",
      "ha": "0.9859677567317904",
      "hi": "0.9950938295884383",
      "hu": "0.9919220996640732"
    }
  },
  {
    "task_id": "C#/47",
    "prompt": {
      "en": "using System;\nusing System.Collections.Generic;\nusing System.Diagnostics;\n\nclass Program\n{\n\n/* Determines the number of students who have enrolled in both Course A and Course B.\n    Given two lists of student IDs for each course, this function counts how many IDs appear in both lists.\n    - courseAStudents: List<int> representing student IDs enrolled in Course A.\n    - courseBStudents: List<int> representing student IDs enrolled in Course B.\n    \n    Example usage:\n    >>> CountCommonStudents(new List<int> {1, 2, 3, 4, 5}, new List<int> {1, 3, 4, 5, 6})\n    4\n    >>> CountCommonStudents(new List<int> {7, 8, 9}, new List<int> {10, 11, 12})\n    0\n*/\n\n\nstatic int CountCommonStudents(List<int> courseAStudents, List<int> courseBStudents)",
      "sq": "using System;\nusing System.Collections.Generic;\nusing System.Diagnostics;\n\nclass Program\n{\n\n/* Përcakton numrin e studentëve që janë regjistruar në të dy Kursin A dhe Kursin B.\n    Duke pasur dy lista të ID-ve të studentëve për secilin kurs, kjo funksion numëron sa ID shfaqen në të dy listat.\n    - courseAStudents: List<int> që përfaqëson ID-të e studentëve të regjistruar në Kursin A.\n    - courseBStudents: List<int> që përfaqëson ID-të e studentëve të regjistruar në Kursin B.\n    \n    Shembull përdorimi:\n    >>> CountCommonStudents(new List<int> {1, 2, 3, 4, 5}, new List<int> {1, 3, 4, 5, 6})\n    4\n    >>> CountCommonStudents(new List<int> {7, 8, 9}, new List<int> {10, 11, 12})\n    0\n*/\n\n\nstatic int CountCommonStudents(List<int> courseAStudents, List<int> courseBStudents)",
      "hy": "using System;\nusing System.Collections.Generic;\nusing System.Diagnostics;\n\nclass Program\n{\n\n/* Սահմանում է այն ուսանողների քանակը, ովքեր գրանցվել են և՛ Դասընթաց A-ում, և՛ Դասընթաց B-ում:\n    Տրված են ուսանողների ID-ների երկու ցուցակներ յուրաքանչյուր դասընթացի համար, այս ֆունկցիան հաշվում է, թե քանի ID է հայտնվում երկու ցուցակներում:\n    - courseAStudents: List<int> ներկայացնում է ուսանողների ID-ները, ովքեր գրանցվել են Դասընթաց A-ում:\n    - courseBStudents: List<int> ներկայացնում է ուսանողների ID-ները, ովքեր գրանցվել են Դասընթաց B-ում:\n    \n    Օրինակ օգտագործում:\n    >>> CountCommonStudents(new List<int> {1, 2, 3, 4, 5}, new List<int> {1, 3, 4, 5, 6})\n    4\n    >>> CountCommonStudents(new List<int> {7, 8, 9}, new List<int> {10, 11, 12})\n    0\n*/\n\n\nstatic int CountCommonStudents(List<int> courseAStudents, List<int> courseBStudents)",
      "bn": "using System;\nusing System.Collections.Generic;\nusing System.Diagnostics;\n\nclass Program\n{\n\n/* কতজন ছাত্র উভয় কোর্স A এবং কোর্স B-তে ভর্তি হয়েছে তা নির্ধারণ করে।\n    প্রতিটি কোর্সের জন্য ছাত্রদের আইডির দুটি তালিকা দেওয়া হলে, এই ফাংশনটি গণনা করে কতগুলি আইডি উভয় তালিকায় উপস্থিত রয়েছে।\n    - courseAStudents: কোর্স A-তে ভর্তি হওয়া ছাত্রদের আইডি উপস্থাপনকারী List<int>।\n    - courseBStudents: কোর্স B-তে ভর্তি হওয়া ছাত্রদের আইডি উপস্থাপনকারী List<int>।\n    \n    উদাহরণ ব্যবহার:\n    >>> CountCommonStudents(new List<int> {1, 2, 3, 4, 5}, new List<int> {1, 3, 4, 5, 6})\n    4\n    >>> CountCommonStudents(new List<int> {7, 8, 9}, new List<int> {10, 11, 12})\n    0\n*/\n\n\nstatic int CountCommonStudents(List<int> courseAStudents, List<int> courseBStudents)",
      "bg": "using System;\nusing System.Collections.Generic;\nusing System.Diagnostics;\n\nclass Program\n{\n\n/* Определя броя на студентите, които са записани както в Курс А, така и в Курс Б.\n    Като се дадат два списъка с идентификационни номера на студенти за всеки курс, тази функция брои колко идентификационни номера се появяват и в двата списъка.\n    - courseAStudents: List<int> представляващ идентификационни номера на студенти, записани в Курс А.\n    - courseBStudents: List<int> представляващ идентификационни номера на студенти, записани в Курс Б.\n    \n    Пример за използване:\n    >>> CountCommonStudents(new List<int> {1, 2, 3, 4, 5}, new List<int> {1, 3, 4, 5, 6})\n    4\n    >>> CountCommonStudents(new List<int> {7, 8, 9}, new List<int> {10, 11, 12})\n    0\n*/\n\n\nstatic int CountCommonStudents(List<int> courseAStudents, List<int> courseBStudents)",
      "zh": "using System;\nusing System.Collections.Generic;\nusing System.Diagnostics;\n\nclass Program\n{\n\n/* 确定同时注册了课程A和课程B的学生人数。\n    给定每门课程的学生ID列表，此函数计算有多少ID出现在两个列表中。\n    - courseAStudents: List<int> 表示注册课程A的学生ID。\n    - courseBStudents: List<int> 表示注册课程B的学生ID。\n    \n    示例用法：\n    >>> CountCommonStudents(new List<int> {1, 2, 3, 4, 5}, new List<int> {1, 3, 4, 5, 6})\n    4\n    >>> CountCommonStudents(new List<int> {7, 8, 9}, new List<int> {10, 11, 12})\n    0\n*/\n\n\nstatic int CountCommonStudents(List<int> courseAStudents, List<int> courseBStudents)",
      "fr": "using System;\nusing System.Collections.Generic;\nusing System.Diagnostics;\n\nclass Program\n{\n\n/* Détermine le nombre d'étudiants qui se sont inscrits à la fois au Cours A et au Cours B.\n    Étant donné deux listes d'IDs d'étudiants pour chaque cours, cette fonction compte combien d'IDs apparaissent dans les deux listes.\n    - courseAStudents: List<int> représentant les IDs d'étudiants inscrits au Cours A.\n    - courseBStudents: List<int> représentant les IDs d'étudiants inscrits au Cours B.\n    \n    Exemple d'utilisation :\n    >>> CountCommonStudents(new List<int> {1, 2, 3, 4, 5}, new List<int> {1, 3, 4, 5, 6})\n    4\n    >>> CountCommonStudents(new List<int> {7, 8, 9}, new List<int> {10, 11, 12})\n    0\n*/\n\n\nstatic int CountCommonStudents(List<int> courseAStudents, List<int> courseBStudents)",
      "de": "using System;\nusing System.Collections.Generic;\nusing System.Diagnostics;\n\nclass Program\n{\n\n/* Bestimmt die Anzahl der Studenten, die sich sowohl in Kurs A als auch in Kurs B eingeschrieben haben.\n    Gegeben zwei Listen von Studenten-IDs für jeden Kurs, zählt diese Funktion, wie viele IDs in beiden Listen erscheinen.\n    - courseAStudents: List<int> repräsentiert die Studenten-IDs, die in Kurs A eingeschrieben sind.\n    - courseBStudents: List<int> repräsentiert die Studenten-IDs, die in Kurs B eingeschrieben sind.\n    \n    Beispielverwendung:\n    >>> CountCommonStudents(new List<int> {1, 2, 3, 4, 5}, new List<int> {1, 3, 4, 5, 6})\n    4\n    >>> CountCommonStudents(new List<int> {7, 8, 9}, new List<int> {10, 11, 12})\n    0\n*/\n\n\nstatic int CountCommonStudents(List<int> courseAStudents, List<int> courseBStudents)",
      "ha": "using System;\nusing System.Collections.Generic;\nusing System.Diagnostics;\n\nclass Program\n{\n\n/* Yana tantance yawan ɗaliban da suka yi rijista a duka Course A da Course B.\n    An ba da jerin lambobin ID na ɗalibai guda biyu don kowanne kwas, wannan aikin yana ƙidaya yawan ID da suka bayyana a duka jerin.\n    - courseAStudents: List<int> yana wakiltar lambobin ID na ɗalibai da suka yi rijista a Course A.\n    - courseBStudents: List<int> yana wakiltar lambobin ID na ɗalibai da suka yi rijista a Course B.\n    \n    Misalin amfani:\n    >>> CountCommonStudents(new List<int> {1, 2, 3, 4, 5}, new List<int> {1, 3, 4, 5, 6})\n    4\n    >>> CountCommonStudents(new List<int> {7, 8, 9}, new List<int> {10, 11, 12})\n    0\n*/\n\n\nstatic int CountCommonStudents(List<int> courseAStudents, List<int> courseBStudents)",
      "hi": "using System;\nusing System.Collections.Generic;\nusing System.Diagnostics;\n\nclass Program\n{\n\n/* यह निर्धारित करता है कि कितने छात्र Course A और Course B दोनों में नामांकित हैं।\n    प्रत्येक कोर्स के लिए छात्र आईडी की दो सूचियों को दिया गया है, यह फ़ंक्शन गिनता है कि कितनी आईडी दोनों सूचियों में दिखाई देती हैं।\n    - courseAStudents: List<int> जो Course A में नामांकित छात्र आईडी का प्रतिनिधित्व करता है।\n    - courseBStudents: List<int> जो Course B में नामांकित छात्र आईडी का प्रतिनिधित्व करता है।\n    \n    उदाहरण उपयोग:\n    >>> CountCommonStudents(new List<int> {1, 2, 3, 4, 5}, new List<int> {1, 3, 4, 5, 6})\n    4\n    >>> CountCommonStudents(new List<int> {7, 8, 9}, new List<int> {10, 11, 12})\n    0\n*/\n\n\nstatic int CountCommonStudents(List<int> courseAStudents, List<int> courseBStudents)",
      "hu": "using System;\nusing System.Collections.Generic;\nusing System.Diagnostics;\n\nclass Program\n{\n\n/* Meghatározza azon diákok számát, akik beiratkoztak mind az A, mind a B kurzusra.\n    Két lista adott, amelyek a kurzusokhoz tartozó diákazonosítókat tartalmazzák, ez a függvény megszámolja, hány azonosító szerepel mindkét listában.\n    - courseAStudents: List<int> az A kurzusra beiratkozott diákok azonosítóit képviseli.\n    - courseBStudents: List<int> a B kurzusra beiratkozott diákok azonosítóit képviseli.\n    \n    Példa használat:\n    >>> CountCommonStudents(new List<int> {1, 2, 3, 4, 5}, new List<int> {1, 3, 4, 5, 6})\n    4\n    >>> CountCommonStudents(new List<int> {7, 8, 9}, new List<int> {10, 11, 12})\n    0\n*/\n\n\nstatic int CountCommonStudents(List<int> courseAStudents, List<int> courseBStudents)"
    },
    "prompt_bertscore": {
      "sq": "0.9825632320008524",
      "hy": "0.9727181171648581",
      "bn": "0.9760433883737631",
      "bg": "0.9989198479879323",
      "zh": "0.9790284057399554",
      "fr": "0.9801850304487216",
      "de": "0.9912304686773097",
      "ha": "0.9785183229214579",
      "hi": "0.9913285920855409",
      "hu": "0.965976602032534"
    },
    "canonical_solution": "{\n    HashSet<int> courseASet = new HashSet<int>(courseAStudents);\n    int commonStudents = 0;\n    foreach (int studentId in courseBStudents)\n    {\n        if (courseASet.Contains(studentId))\n        {\n            commonStudents++;\n        }\n    }\n    return commonStudents;\n}",
    "instruction": {
      "en": "Write a C# function `static int CountCommonStudents(List<int> courseAStudents, List<int> courseBStudents)` to solve the following problem:\nDetermines the number of students who have enrolled in both Course A and Course B.\n    Given two lists of student IDs for each course, this function counts how many IDs appear in both lists.\n    - courseAStudents: List<int> representing student IDs enrolled in Course A.\n    - courseBStudents: List<int> representing student IDs enrolled in Course B.\n    \n    Example usage:\n    >>> CountCommonStudents(new List<int> {1, 2, 3, 4, 5}, new List<int> {1, 3, 4, 5, 6})\n    4\n    >>> CountCommonStudents(new List<int> {7, 8, 9}, new List<int> {10, 11, 12})\n    0",
      "sq": "Shkruani një funksion në C# `static int CountCommonStudents(List<int> courseAStudents, List<int> courseBStudents)` për të zgjidhur problemin e mëposhtëm:\nPërcakton numrin e studentëve që janë regjistruar si në Kursin A ashtu edhe në Kursin B.\n    Duke pasur dy lista të ID-ve të studentëve për secilin kurs, ky funksion numëron sa ID shfaqen në të dyja listat.\n    - courseAStudents: List<int> që përfaqëson ID-të e studentëve të regjistruar në Kursin A.\n    - courseBStudents: List<int> që përfaqëson ID-të e studentëve të regjistruar në Kursin B.\n    \n    Shembull përdorimi:\n    >>> CountCommonStudents(new List<int> {1, 2, 3, 4, 5}, new List<int> {1, 3, 4, 5, 6})\n    4\n    >>> CountCommonStudents(new List<int> {7, 8, 9}, new List<int> {10, 11, 12})\n    0",
      "hy": "Գրեք C# ֆունկցիա `static int CountCommonStudents(List<int> courseAStudents, List<int> courseBStudents)` հետևյալ խնդիրը լուծելու համար:\nՍահմանում է այն ուսանողների քանակը, ովքեր գրանցվել են և՛ Դասընթաց A-ում, և՛ Դասընթաց B-ում:\n    Տրված են ուսանողների ID-ների երկու ցուցակներ յուրաքանչյուր դասընթացի համար, այս ֆունկցիան հաշվում է, թե քանի ID է հայտնվում երկու ցուցակներում:\n    - courseAStudents: List<int>, որը ներկայացնում է Դասընթաց A-ում գրանցված ուսանողների ID-ները:\n    - courseBStudents: List<int>, որը ներկայացնում է Դասընթաց B-ում գրանցված ուսանողների ID-ները:\n    \n    Օրինակ օգտագործում:\n    >>> CountCommonStudents(new List<int> {1, 2, 3, 4, 5}, new List<int> {1, 3, 4, 5, 6})\n    4\n    >>> CountCommonStudents(new List<int> {7, 8, 9}, new List<int> {10, 11, 12})\n    0",
      "bn": "C# ফাংশন `static int CountCommonStudents(List<int> courseAStudents, List<int> courseBStudents)` লিখুন নিম্নলিখিত সমস্যার সমাধানের জন্য:\nনির্ধারণ করে কতজন শিক্ষার্থী উভয় কোর্স A এবং কোর্স B তে ভর্তি হয়েছে।\n    প্রতিটি কোর্সের জন্য শিক্ষার্থীদের আইডির দুটি তালিকা দেওয়া হলে, এই ফাংশনটি গণনা করে কতটি আইডি উভয় তালিকায় উপস্থিত রয়েছে।\n    - courseAStudents: List<int> যা কোর্স A তে ভর্তি হওয়া শিক্ষার্থীদের আইডি উপস্থাপন করে।\n    - courseBStudents: List<int> যা কোর্স B তে ভর্তি হওয়া শিক্ষার্থীদের আইডি উপস্থাপন করে।\n    \n    উদাহরণ ব্যবহার:\n    >>> CountCommonStudents(new List<int> {1, 2, 3, 4, 5}, new List<int> {1, 3, 4, 5, 6})\n    4\n    >>> CountCommonStudents(new List<int> {7, 8, 9}, new List<int> {10, 11, 12})\n    0",
      "bg": "Напишете C# функция `static int CountCommonStudents(List<int> courseAStudents, List<int> courseBStudents)`, за да решите следния проблем:\nОпределя броя на студентите, които са записани както в Курс A, така и в Курс B.\n    Дадени са два списъка с идентификатори на студенти за всеки курс, тази функция брои колко идентификатора се появяват и в двата списъка.\n    - courseAStudents: List<int>, представляващ идентификатори на студенти, записани в Курс A.\n    - courseBStudents: List<int>, представляващ идентификатори на студенти, записани в Курс B.\n    \n    Пример за използване:\n    >>> CountCommonStudents(new List<int> {1, 2, 3, 4, 5}, new List<int> {1, 3, 4, 5, 6})\n    4\n    >>> CountCommonStudents(new List<int> {7, 8, 9}, new List<int> {10, 11, 12})\n    0",
      "zh": "编写一个 C# 函数 `static int CountCommonStudents(List<int> courseAStudents, List<int> courseBStudents)` 来解决以下问题：\n确定同时注册了课程 A 和课程 B 的学生人数。\n给定每门课程的学生 ID 列表，此函数计算两个列表中出现了多少个相同的 ID。\n- courseAStudents: List<int> 表示注册课程 A 的学生 ID。\n- courseBStudents: List<int> 表示注册课程 B 的学生 ID。\n\n示例用法:\n>>> CountCommonStudents(new List<int> {1, 2, 3, 4, 5}, new List<int> {1, 3, 4, 5, 6})\n4\n>>> CountCommonStudents(new List<int> {7, 8, 9}, new List<int> {10, 11, 12})\n0",
      "fr": "Écrire une fonction C# `static int CountCommonStudents(List<int> courseAStudents, List<int> courseBStudents)` pour résoudre le problème suivant :\nDétermine le nombre d'étudiants qui se sont inscrits à la fois au Cours A et au Cours B.\n    Étant donné deux listes d'identifiants d'étudiants pour chaque cours, cette fonction compte combien d'identifiants apparaissent dans les deux listes.\n    - courseAStudents : List<int> représentant les identifiants d'étudiants inscrits au Cours A.\n    - courseBStudents : List<int> représentant les identifiants d'étudiants inscrits au Cours B.\n    \n    Exemple d'utilisation :\n    >>> CountCommonStudents(new List<int> {1, 2, 3, 4, 5}, new List<int> {1, 3, 4, 5, 6})\n    4\n    >>> CountCommonStudents(new List<int> {7, 8, 9}, new List<int> {10, 11, 12})\n    0",
      "de": "Schreiben Sie eine C#-Funktion `static int CountCommonStudents(List<int> courseAStudents, List<int> courseBStudents)`, um das folgende Problem zu lösen:\nBestimmt die Anzahl der Studenten, die sich sowohl in Kurs A als auch in Kurs B eingeschrieben haben.\n    Gegeben sind zwei Listen von Studenten-IDs für jeden Kurs, diese Funktion zählt, wie viele IDs in beiden Listen erscheinen.\n    - courseAStudents: List<int> repräsentiert die Studenten-IDs, die in Kurs A eingeschrieben sind.\n    - courseBStudents: List<int> repräsentiert die Studenten-IDs, die in Kurs B eingeschrieben sind.\n    \n    Beispielverwendung:\n    >>> CountCommonStudents(new List<int> {1, 2, 3, 4, 5}, new List<int> {1, 3, 4, 5, 6})\n    4\n    >>> CountCommonStudents(new List<int> {7, 8, 9}, new List<int> {10, 11, 12})\n    0",
      "ha": "Rubuta aikin C# `static int CountCommonStudents(List<int> courseAStudents, List<int> courseBStudents)` don warware matsalar mai zuwa:\nYana tantance yawan ɗaliban da suka yi rajista a duka Course A da Course B.\n    An ba da jerin lambobin ID na ɗalibai guda biyu don kowace hanya, wannan aikin yana ƙidaya yawan ID ɗin da suka bayyana a cikin duka jerin.\n    - courseAStudents: List<int> yana wakiltar lambobin ID na ɗalibai da suka yi rajista a Course A.\n    - courseBStudents: List<int> yana wakiltar lambobin ID na ɗalibai da suka yi rajista a Course B.\n    \n    Misalin amfani:\n    >>> CountCommonStudents(new List<int> {1, 2, 3, 4, 5}, new List<int> {1, 3, 4, 5, 6})\n    4\n    >>> CountCommonStudents(new List<int> {7, 8, 9}, new List<int> {10, 11, 12})\n    0",
      "hi": "C# फ़ंक्शन `static int CountCommonStudents(List<int> courseAStudents, List<int> courseBStudents)` लिखें ताकि निम्नलिखित समस्या का समाधान किया जा सके:\nनिर्धारित करता है कि कितने छात्र दोनों कोर्स A और कोर्स B में नामांकित हैं।\n    प्रत्येक कोर्स के लिए छात्र आईडी की दो सूचियों को दिया गया है, यह फ़ंक्शन गिनता है कि कितनी आईडी दोनों सूचियों में दिखाई देती हैं।\n    - courseAStudents: List<int> जो कोर्स A में नामांकित छात्र आईडी का प्रतिनिधित्व करता है।\n    - courseBStudents: List<int> जो कोर्स B में नामांकित छात्र आईडी का प्रतिनिधित्व करता है।\n    \n    उदाहरण उपयोग:\n    >>> CountCommonStudents(new List<int> {1, 2, 3, 4, 5}, new List<int> {1, 3, 4, 5, 6})\n    4\n    >>> CountCommonStudents(new List<int> {7, 8, 9}, new List<int> {10, 11, 12})\n    0",
      "hu": "Írj egy C# függvényt `static int CountCommonStudents(List<int> courseAStudents, List<int> courseBStudents)` a következő probléma megoldására:\nMeghatározza azon diákok számát, akik beiratkoztak mind az A, mind a B kurzusra.\n    Két listát kapunk, amelyek az egyes kurzusokra beiratkozott diákok azonosítóit tartalmazzák, és ez a függvény megszámolja, hány azonosító jelenik meg mindkét listában.\n    - courseAStudents: List<int> az A kurzusra beiratkozott diákok azonosítóit képviseli.\n    - courseBStudents: List<int> a B kurzusra beiratkozott diákok azonosítóit képviseli.\n    \n    Példa használat:\n    >>> CountCommonStudents(new List<int> {1, 2, 3, 4, 5}, new List<int> {1, 3, 4, 5, 6})\n    4\n    >>> CountCommonStudents(new List<int> {7, 8, 9}, new List<int> {10, 11, 12})\n    0"
    },
    "instruction_bertscore": {
      "sq": "0.9770659375753308",
      "hy": "0.9685657490493238",
      "bn": "0.9723897811450074",
      "bg": "0.9787390012747876",
      "zh": "0.973412330346575",
      "fr": "0.9919346133780783",
      "de": "0.9896529461911306",
      "ha": "0.9518398791839",
      "hi": "0.977830068651172",
      "hu": "0.9655284918929193"
    },
    "level": "easy",
    "test": "    static void Main()\n    {\n        Debug.Assert(CountCommonStudents(new List<int> { 1, 2, 3, 4, 5 }, new List<int> { 1, 3, 4, 5, 6 }) == 4);\n        Debug.Assert(CountCommonStudents(new List<int> { 7, 8, 9 }, new List<int> { 10, 11, 12 }) == 0);\n        Debug.Assert(CountCommonStudents(new List<int> { 1, 3, 5, 7, 9 }, new List<int> { 2, 4, 6, 8, 10 }) == 0);\n        Debug.Assert(CountCommonStudents(new List<int> { 2, 4, 6, 8 }, new List<int> { 1, 3, 5, 7, 8 }) == 1);\n\n\n    }\n}",
    "entry_point": "CountCommonStudents",
    "signature": "static int CountCommonStudents(List<int> courseAStudents, List<int> courseBStudents)",
    "docstring": {
      "en": "Determines the number of students who have enrolled in both Course A and Course B.\n    Given two lists of student IDs for each course, this function counts how many IDs appear in both lists.\n    - courseAStudents: List<int> representing student IDs enrolled in Course A.\n    - courseBStudents: List<int> representing student IDs enrolled in Course B.\n    \n    Example usage:\n    >>> CountCommonStudents(new List<int> {1, 2, 3, 4, 5}, new List<int> {1, 3, 4, 5, 6})\n    4\n    >>> CountCommonStudents(new List<int> {7, 8, 9}, new List<int> {10, 11, 12})\n    0",
      "sq": "Përcakton numrin e studentëve që janë regjistruar si në Kursin A ashtu edhe në Kursin B.\n    Duke pasur dy lista të ID-ve të studentëve për secilin kurs, kjo funksion numëron sa ID shfaqen në të dy listat.\n    - courseAStudents: List<int> që përfaqëson ID-të e studentëve të regjistruar në Kursin A.\n    - courseBStudents: List<int> që përfaqëson ID-të e studentëve të regjistruar në Kursin B.\n    \n    Shembull përdorimi:\n    >>> CountCommonStudents(new List<int> {1, 2, 3, 4, 5}, new List<int> {1, 3, 4, 5, 6})\n    4\n    >>> CountCommonStudents(new List<int> {7, 8, 9}, new List<int> {10, 11, 12})\n    0",
      "hy": "Սահմանում է այն ուսանողների քանակը, ովքեր գրանցվել են և՛ Դասընթաց A-ում, և՛ Դասընթաց B-ում:\n    Տրված երկու ցուցակ ուսանողների ID-ներով յուրաքանչյուր դասընթացի համար, այս ֆունկցիան հաշվում է, թե քանի ID է հայտնվում երկու ցուցակներում:\n    - courseAStudents: List<int> ներկայացնում է ուսանողների ID-ները, որոնք գրանցվել են Դասընթաց A-ում:\n    - courseBStudents: List<int> ներկայացնում է ուսանողների ID-ները, որոնք գրանցվել են Դասընթաց B-ում:\n    \n    Օրինակ օգտագործում:\n    >>> CountCommonStudents(new List<int> {1, 2, 3, 4, 5}, new List<int> {1, 3, 4, 5, 6})\n    4\n    >>> CountCommonStudents(new List<int> {7, 8, 9}, new List<int> {10, 11, 12})\n    0",
      "bn": "কতজন ছাত্র উভয় কোর্স A এবং কোর্স B-তে ভর্তি হয়েছে তা নির্ধারণ করে।\n    দুটি কোর্সের জন্য ছাত্রদের আইডির তালিকা দেওয়া হলে, এই ফাংশনটি গণনা করে কতগুলি আইডি উভয় তালিকায় উপস্থিত রয়েছে।\n    - courseAStudents: List<int> যা কোর্স A-তে ভর্তি হওয়া ছাত্রদের আইডি উপস্থাপন করে।\n    - courseBStudents: List<int> যা কোর্স B-তে ভর্তি হওয়া ছাত্রদের আইডি উপস্থাপন করে।\n    \n    উদাহরণ ব্যবহার:\n    >>> CountCommonStudents(new List<int> {1, 2, 3, 4, 5}, new List<int> {1, 3, 4, 5, 6})\n    4\n    >>> CountCommonStudents(new List<int> {7, 8, 9}, new List<int> {10, 11, 12})\n    0",
      "bg": "Определя броя на студентите, които са записани както в Курс A, така и в Курс B.\n    Дадени са два списъка с идентификатори на студенти за всеки курс, тази функция брои колко идентификатора се появяват и в двата списъка.\n    - courseAStudents: List<int> представляващ идентификатори на студенти, записани в Курс A.\n    - courseBStudents: List<int> представляващ идентификатори на студенти, записани в Курс B.\n    \n    Пример за използване:\n    >>> CountCommonStudents(new List<int> {1, 2, 3, 4, 5}, new List<int> {1, 3, 4, 5, 6})\n    4\n    >>> CountCommonStudents(new List<int> {7, 8, 9}, new List<int> {10, 11, 12})\n    0",
      "zh": "确定同时注册了课程A和课程B的学生人数。\n    给定每门课程的学生ID列表，此函数计算有多少ID同时出现在两个列表中。\n    - courseAStudents: List<int> 表示注册课程A的学生ID。\n    - courseBStudents: List<int> 表示注册课程B的学生ID。\n    \n    示例用法：\n    >>> CountCommonStudents(new List<int> {1, 2, 3, 4, 5}, new List<int> {1, 3, 4, 5, 6})\n    4\n    >>> CountCommonStudents(new List<int> {7, 8, 9}, new List<int> {10, 11, 12})\n    0",
      "fr": "Détermine le nombre d'étudiants inscrits à la fois au Cours A et au Cours B.\n    Étant donné deux listes d'IDs d'étudiants pour chaque cours, cette fonction compte combien d'IDs apparaissent dans les deux listes.\n    - courseAStudents: List<int> représentant les IDs d'étudiants inscrits au Cours A.\n    - courseBStudents: List<int> représentant les IDs d'étudiants inscrits au Cours B.\n    \n    Exemple d'utilisation :\n    >>> CountCommonStudents(new List<int> {1, 2, 3, 4, 5}, new List<int> {1, 3, 4, 5, 6})\n    4\n    >>> CountCommonStudents(new List<int> {7, 8, 9}, new List<int> {10, 11, 12})\n    0",
      "de": "Bestimmt die Anzahl der Studenten, die sich sowohl für Kurs A als auch für Kurs B eingeschrieben haben.\n    Gegeben zwei Listen von Studenten-IDs für jeden Kurs, zählt diese Funktion, wie viele IDs in beiden Listen erscheinen.\n    - courseAStudents: List<int> repräsentiert die Studenten-IDs, die in Kurs A eingeschrieben sind.\n    - courseBStudents: List<int> repräsentiert die Studenten-IDs, die in Kurs B eingeschrieben sind.\n    \n    Beispielverwendung:\n    >>> CountCommonStudents(new List<int> {1, 2, 3, 4, 5}, new List<int> {1, 3, 4, 5, 6})\n    4\n    >>> CountCommonStudents(new List<int> {7, 8, 9}, new List<int> {10, 11, 12})\n    0",
      "ha": "Yana tantance yawan ɗaliban da suka yi rijista a duka Course A da Course B.\n    An ba da jerin sunayen IDs ɗalibai biyu don kowane kwas, wannan aikin yana ƙididdige yawan IDs da suka bayyana a cikin duka jerin.  \n    - courseAStudents: List<int> wakiltar IDs ɗalibai da suka yi rijista a Kwas A.  \n    - courseBStudents: List<int> wakiltar IDs ɗalibai da suka yi rijista a Kwas B.  \n    \n    Misalin amfani:  \n    >>> CountCommonStudents(new List<int> {1, 2, 3, 4, 5}, new List<int> {1, 3, 4, 5, 6})  \n    4  \n    >>> CountCommonStudents(new List<int> {7, 8, 9}, new List<int> {10, 11, 12})  \n    0  ",
      "hi": "दोनों कोर्स A और कोर्स B में नामांकित छात्रों की संख्या निर्धारित करता है। \n    प्रत्येक कोर्स के लिए छात्र आईडी की दो सूचियों को दिया गया है, यह फ़ंक्शन गिनता है कि कितनी आईडी दोनों सूचियों में दिखाई देती हैं।\n    - courseAStudents: List<int> जो कोर्स A में नामांकित छात्र आईडी का प्रतिनिधित्व करता है।\n    - courseBStudents: List<int> जो कोर्स B में नामांकित छात्र आईडी का प्रतिनिधित्व करता है।\n\n    उदाहरण उपयोग:\n    >>> CountCommonStudents(new List<int> {1, 2, 3, 4, 5}, new List<int> {1, 3, 4, 5, 6})\n    4\n    >>> CountCommonStudents(new List<int> {7, 8, 9}, new List<int> {10, 11, 12})\n    0",
      "hu": "Meghatározza azon diákok számát, akik beiratkoztak mind az A, mind a B kurzusra.\n    Két lista megadása esetén, amelyek a diákazonosítókat tartalmazzák az egyes kurzusokhoz, ez a függvény megszámolja, hogy hány azonosító jelenik meg mindkét listában.\n    - courseAStudents: List<int> az A kurzusra beiratkozott diákok azonosítóit képviseli.\n    - courseBStudents: List<int> a B kurzusra beiratkozott diákok azonosítóit képviseli.\n    \n    Példa használat:\n    >>> CountCommonStudents(new List<int> {1, 2, 3, 4, 5}, new List<int> {1, 3, 4, 5, 6})\n    4\n    >>> CountCommonStudents(new List<int> {7, 8, 9}, new List<int> {10, 11, 12})\n    0"
    },
    "docstring_bertscore": {
      "sq": "0.9800205644932247",
      "hy": "0.9735990429047479",
      "bn": "0.9710643206123616",
      "bg": "0.9888113492666858",
      "zh": "0.9630624957123711",
      "fr": "0.9753459971059497",
      "de": "0.9879389646331805",
      "ha": "0.9577399960221603",
      "hi": "0.9900869535736918",
      "hu": "0.9718902257367047"
    }
  },
  {
    "task_id": "C#/48",
    "prompt": {
      "en": "using System;\nusing System.Collections.Generic;\nusing System.Diagnostics;\n\nclass Program\n{\n\n/* Calculates the number of whole apples remaining after eating apples for a given amount of time.\n   Each apple takes a specific amount of time to eat, and the function returns how many whole apples are left uneaten.\n   - totalApples: the total number of apples available\n   - timePerApple: the time it takes to eat one apple (timePerApple>=0)\n   - timeElapsed: the total time elapsed\n\n   Examples:\n   >>> RemainingApples(50, 10, 200)\n   30\n\n*/\n\nstatic int RemainingApples(int totalApples, int timePerApple, int timeElapsed)",
      "sq": "using System;\nusing System.Collections.Generic;\nusing System.Diagnostics;\n\nclass Program\n{\n\n/* Llogarit numrin e mollëve të plota që mbeten pasi të keni ngrënë mollët për një periudhë të caktuar kohe.\n   Çdo mollë kërkon një kohë specifike për t'u ngrënë, dhe funksioni kthen sa mollë të plota mbeten të pangrënë.\n   - totalApples: numri total i mollëve të disponueshme\n   - timePerApple: koha që duhet për të ngrënë një mollë (timePerApple>=0)\n   - timeElapsed: koha totale e kaluar\n\n   Shembuj:\n   >>> RemainingApples(50, 10, 200)\n   30\n\n*/\n\nstatic int RemainingApples(int totalApples, int timePerApple, int timeElapsed)",
      "hy": "using System;\nusing System.Collections.Generic;\nusing System.Diagnostics;\n\nclass Program\n{\n\n/* Հաշվում է ամբողջ խնձորների քանակը, որոնք մնում են ուտելուց հետո որոշակի ժամանակահատվածում:\n   Յուրաքանչյուր խնձոր ուտելու համար պահանջվում է որոշակի ժամանակ, և ֆունկցիան վերադարձնում է, թե քանի ամբողջ խնձոր է մնում չուտված:\n   - totalApples: հասանելի խնձորների ընդհանուր քանակը\n   - timePerApple: ժամանակը, որը պահանջվում է մեկ խնձոր ուտելու համար (timePerApple>=0)\n   - timeElapsed: անցած ընդհանուր ժամանակը\n\n   Օրինակներ:\n   >>> RemainingApples(50, 10, 200)\n   30\n\n*/\n\nstatic int RemainingApples(int totalApples, int timePerApple, int timeElapsed)",
      "bn": "using System;\nusing System.Collections.Generic;\nusing System.Diagnostics;\n\nclass Program\n{\n\n/* একটি নির্দিষ্ট সময়ের জন্য আপেল খাওয়ার পর কতগুলি সম্পূর্ণ আপেল অবশিষ্ট থাকবে তা গণনা করে।\n   প্রতিটি আপেল খেতে নির্দিষ্ট পরিমাণ সময় লাগে, এবং ফাংশনটি কতগুলি সম্পূর্ণ আপেল অবশিষ্ট আছে তা ফেরত দেয়।\n   - totalApples: মোট কতগুলি আপেল উপলব্ধ\n   - timePerApple: একটি আপেল খেতে যত সময় লাগে (timePerApple>=0)\n   - timeElapsed: মোট যে সময় অতিবাহিত হয়েছে\n\n   উদাহরণ:\n   >>> RemainingApples(50, 10, 200)\n   30\n\n*/\n\nstatic int RemainingApples(int totalApples, int timePerApple, int timeElapsed)",
      "bg": "using System;\nusing System.Collections.Generic;\nusing System.Diagnostics;\n\nclass Program\n{\n\n/* Изчислява броя на целите ябълки, останали след ядене на ябълки за дадено количество време.\n   Всяка ябълка отнема определено време за ядене, и функцията връща колко цели ябълки остават неядени.\n   - totalApples: общият брой налични ябълки\n   - timePerApple: времето, необходимо за изяждане на една ябълка (timePerApple>=0)\n   - timeElapsed: общото изминало време\n\n   Примери:\n   >>> RemainingApples(50, 10, 200)\n   30\n\n*/\n\nstatic int RemainingApples(int totalApples, int timePerApple, int timeElapsed)",
      "zh": "using System;\nusing System.Collections.Generic;\nusing System.Diagnostics;\n\nclass Program\n{\n\n/* 计算在吃苹果一段时间后剩余的完整苹果数量。\n   每个苹果需要特定的时间来吃，函数返回剩下多少完整的苹果没有被吃掉。\n   - totalApples: 可用苹果的总数\n   - timePerApple: 吃一个苹果所需的时间 (timePerApple>=0)\n   - timeElapsed: 总共经过的时间\n\n   示例:\n   >>> RemainingApples(50, 10, 200)\n   30\n\n*/\n\nstatic int RemainingApples(int totalApples, int timePerApple, int timeElapsed)",
      "fr": "using System;\nusing System.Collections.Generic;\nusing System.Diagnostics;\n\nclass Program\n{\n\n/* Calcule le nombre de pommes entières restantes après avoir mangé des pommes pendant un certain temps.\n   Chaque pomme prend un certain temps à manger, et la fonction renvoie combien de pommes entières restent non mangées.\n   - totalApples: le nombre total de pommes disponibles\n   - timePerApple: le temps qu'il faut pour manger une pomme (timePerApple>=0)\n   - timeElapsed: le temps total écoulé\n\n   Exemples:\n   >>> RemainingApples(50, 10, 200)\n   30\n\n*/\n\nstatic int RemainingApples(int totalApples, int timePerApple, int timeElapsed)",
      "de": "using System;\nusing System.Collections.Generic;\nusing System.Diagnostics;\n\nclass Program\n{\n\n/* Berechnet die Anzahl der ganzen Äpfel, die nach dem Essen von Äpfeln für eine bestimmte Zeit übrig bleiben.\n   Jeder Apfel benötigt eine bestimmte Zeit zum Essen, und die Funktion gibt zurück, wie viele ganze Äpfel uneaten bleiben.\n   - totalApples: die Gesamtanzahl der verfügbaren Äpfel\n   - timePerApple: die Zeit, die benötigt wird, um einen Apfel zu essen (timePerApple>=0)\n   - timeElapsed: die insgesamt vergangene Zeit\n\n   Beispiele:\n   >>> RemainingApples(50, 10, 200)\n   30\n\n*/\n\nstatic int RemainingApples(int totalApples, int timePerApple, int timeElapsed)",
      "ha": "using System;\nusing System.Collections.Generic;\nusing System.Diagnostics;\n\nclass Program\n{\n\n/* Lissafa adadin cikakkun tuffa da suka rage bayan cin tuffa na wani adadin lokaci.\n   Kowace tuffa tana ɗaukar wani adadin lokaci don ci, kuma aikin yana dawo da adadin cikakkun tuffa da suka rage ba a ci ba.\n   - totalApples: jimlar adadin tuffa da ake da su\n   - timePerApple: lokacin da ake ɗauka don cin tuffa ɗaya (timePerApple>=0)\n   - timeElapsed: jimlar lokacin da ya shige\n\n   Misalai:\n   >>> RemainingApples(50, 10, 200)\n   30\n\n*/\n\nstatic int RemainingApples(int totalApples, int timePerApple, int timeElapsed)",
      "hi": "using System;\nusing System.Collections.Generic;\nusing System.Diagnostics;\n\nclass Program\n{\n\n/* दिए गए समय के लिए सेब खाने के बाद बचे हुए पूरे सेबों की संख्या की गणना करता है।\n   प्रत्येक सेब को खाने में एक विशिष्ट समय लगता है, और यह फ़ंक्शन यह बताता है कि कितने पूरे सेब बिना खाए बचे हैं।\n   - totalApples: उपलब्ध सेबों की कुल संख्या\n   - timePerApple: एक सेब खाने में लगने वाला समय (timePerApple>=0)\n   - timeElapsed: कुल बीता हुआ समय\n\n   उदाहरण:\n   >>> RemainingApples(50, 10, 200)\n   30\n\n*/\n\nstatic int RemainingApples(int totalApples, int timePerApple, int timeElapsed)",
      "hu": "using System;\nusing System.Collections.Generic;\nusing System.Diagnostics;\n\nclass Program\n{\n\n/* Kiszámítja, hogy hány egész alma marad meg egy adott időtartam alatt elfogyasztott almák után.\n   Minden alma elfogyasztása egy meghatározott időt vesz igénybe, és a függvény visszaadja, hány egész alma marad érintetlenül.\n   - totalApples: a rendelkezésre álló almák teljes száma\n   - timePerApple: az idő, ami egy alma elfogyasztásához szükséges (timePerApple>=0)\n   - timeElapsed: az eltelt idő teljes hossza\n\n   Példák:\n   >>> RemainingApples(50, 10, 200)\n   30\n\n*/\n\nstatic int RemainingApples(int totalApples, int timePerApple, int timeElapsed)"
    },
    "prompt_bertscore": {
      "sq": "0.9756755249080865",
      "hy": "0.9526002362825016",
      "bn": "0.9592392581382116",
      "bg": "0.98192940245497",
      "zh": "0.965373361565331",
      "fr": "0.9774578353171126",
      "de": "0.9729600489689586",
      "ha": "0.9716788830112836",
      "hi": "0.9660268555189359",
      "hu": "0.9563887135399799"
    },
    "canonical_solution": "{\n    if (timePerApple == 0) return 0; // Prevent division by zero\n\n    // Calculate the number of apples consumed\n    int applesConsumed = timeElapsed / timePerApple;\n\n    // Calculate the remaining apples\n    int remainingApples = totalApples - applesConsumed;\n    if (timeElapsed % timePerApple >  0){\n        remainingApples-=1;\n    } \n    // Ensure remaining apples is non-negative\n    if (remainingApples < 0)\n    {\n        return 0;\n    }\n\n    return remainingApples;\n}",
    "instruction": {
      "en": "Write a C# function `static int RemainingApples(int totalApples, int timePerApple, int timeElapsed)` to solve the following problem:\nCalculates the number of whole apples remaining after eating apples for a given amount of time.\n   Each apple takes a specific amount of time to eat, and the function returns how many whole apples are left uneaten.\n   - totalApples: the total number of apples available\n   - timePerApple: the time it takes to eat one apple (timePerApple>=0)\n   - timeElapsed: the total time elapsed\n\n   Examples:\n   >>> RemainingApples(50, 10, 200)\n   30",
      "sq": "Shkruani një funksion në C# `static int RemainingApples(int totalApples, int timePerApple, int timeElapsed)` për të zgjidhur problemin e mëposhtëm:\nLlogarit numrin e mollëve të plota të mbetura pasi të keni ngrënë mollë për një periudhë të caktuar kohe.\n   Çdo mollë kërkon një sasi specifike kohe për t'u ngrënë, dhe funksioni kthen sa mollë të plota kanë mbetur pa ngrënë.\n   - totalApples: numri total i mollëve të disponueshme\n   - timePerApple: koha që duhet për të ngrënë një mollë (timePerApple>=0)\n   - timeElapsed: koha totale e kaluar\n\n   Shembuj:\n   >>> RemainingApples(50, 10, 200)\n   30",
      "hy": "Գրեք C# ֆունկցիա `static int RemainingApples(int totalApples, int timePerApple, int timeElapsed)` հետևյալ խնդիրը լուծելու համար:\nՀաշվում է ամբողջ խնձորների քանակը, որոնք մնացել են ուտելուց հետո որոշակի ժամանակի ընթացքում:\n   Յուրաքանչյուր խնձոր ուտելու համար պահանջվում է որոշակի ժամանակ, և ֆունկցիան վերադարձնում է, թե քանի ամբողջ խնձոր է մնացել չուտված:\n   - totalApples: առկա խնձորների ընդհանուր քանակը\n   - timePerApple: մեկ խնձոր ուտելու համար պահանջվող ժամանակը (timePerApple>=0)\n   - timeElapsed: անցած ընդհանուր ժամանակը\n\n   Օրինակներ:\n   >>> RemainingApples(50, 10, 200)\n   30",
      "bn": "C# ফাংশন `static int RemainingApples(int totalApples, int timePerApple, int timeElapsed)` লিখুন নিম্নলিখিত সমস্যার সমাধানের জন্য:\nএকটি নির্দিষ্ট সময় ধরে আপেল খাওয়ার পর কতগুলি সম্পূর্ণ আপেল অবশিষ্ট থাকবে তা গণনা করে।\n   প্রতিটি আপেল খেতে একটি নির্দিষ্ট সময় লাগে, এবং ফাংশনটি কতগুলি সম্পূর্ণ আপেল অবশিষ্ট রয়েছে তা ফেরত দেয়।\n   - totalApples: মোট আপেলের সংখ্যা উপলব্ধ\n   - timePerApple: একটি আপেল খেতে যে সময় লাগে (timePerApple>=0)\n   - timeElapsed: মোট সময় অতিবাহিত হয়েছে\n\n   উদাহরণ:\n   >>> RemainingApples(50, 10, 200)\n   30",
      "bg": "Напишете C# функция `static int RemainingApples(int totalApples, int timePerApple, int timeElapsed)` за решаване на следния проблем:\nИзчислява броя на целите ябълки, останали след ядене на ябълки за дадено количество време.\n   Всяка ябълка изисква определено време за изяждане, и функцията връща колко цели ябълки остават неизядени.\n   - totalApples: общият брой на наличните ябълки\n   - timePerApple: времето, необходимо за изяждане на една ябълка (timePerApple>=0)\n   - timeElapsed: общото изтекло време\n\n   Примери:\n   >>> RemainingApples(50, 10, 200)\n   30",
      "zh": "编写一个 C# 函数 `static int RemainingApples(int totalApples, int timePerApple, int timeElapsed)` 来解决以下问题：\n计算在给定时间内吃苹果后剩余的完整苹果数量。\n每个苹果需要特定的时间来吃，函数返回剩下未吃的完整苹果数量。\n- totalApples: 可用苹果的总数\n- timePerApple: 吃一个苹果所需的时间 (timePerApple>=0)\n- timeElapsed: 总共经过的时间\n\n例子:\n>>> RemainingApples(50, 10, 200)\n30",
      "fr": "Écrire une fonction C# `static int RemainingApples(int totalApples, int timePerApple, int timeElapsed)` pour résoudre le problème suivant :\nCalcule le nombre de pommes entières restantes après avoir mangé des pommes pendant un certain temps donné.\n   Chaque pomme prend un certain temps à manger, et la fonction renvoie combien de pommes entières restent non mangées.\n   - totalApples : le nombre total de pommes disponibles\n   - timePerApple : le temps qu'il faut pour manger une pomme (timePerApple>=0)\n   - timeElapsed : le temps total écoulé\n\n   Exemples :\n   >>> RemainingApples(50, 10, 200)\n   30",
      "de": "Schreiben Sie eine C#-Funktion `static int RemainingApples(int totalApples, int timePerApple, int timeElapsed)`, um das folgende Problem zu lösen:\nBerechnet die Anzahl der ganzen Äpfel, die nach dem Essen von Äpfeln für eine bestimmte Zeit übrig bleiben.\n   Jeder Apfel benötigt eine bestimmte Zeit zum Essen, und die Funktion gibt zurück, wie viele ganze Äpfel uneaten bleiben.\n   - totalApples: die Gesamtanzahl der verfügbaren Äpfel\n   - timePerApple: die Zeit, die benötigt wird, um einen Apfel zu essen (timePerApple>=0)\n   - timeElapsed: die insgesamt vergangene Zeit\n\n   Beispiele:\n   >>> RemainingApples(50, 10, 200)\n   30",
      "ha": "Rubuta aikin C# `static int RemainingApples(int totalApples, int timePerApple, int timeElapsed)` don warware matsalar mai zuwa:\nƘididdige yawan cikakkun tuffa da suka rage bayan cin tuffa na wani adadin lokaci.\n   Kowace tuffa tana ɗaukar wani adadin lokaci don ci, kuma aikin yana dawo da yawan cikakkun tuffa da suka rage ba a ci ba.\n   - totalApples: jimillar adadin tuffa da ake da su\n   - timePerApple: lokacin da ake ɗauka don cin tuffa ɗaya (timePerApple>=0)\n   - timeElapsed: jimillar lokacin da ya shige\n\n   Misalai:\n   >>> RemainingApples(50, 10, 200)\n   30",
      "hi": "C# फ़ंक्शन `static int RemainingApples(int totalApples, int timePerApple, int timeElapsed)` लिखें ताकि निम्नलिखित समस्या का समाधान किया जा सके:\n   दिए गए समय के लिए सेब खाने के बाद बचे हुए पूरे सेबों की संख्या की गणना करता है।\n   प्रत्येक सेब को खाने में एक विशिष्ट समय लगता है, और फ़ंक्शन यह लौटाता है कि कितने पूरे सेब बिना खाए बचे हैं।\n   - totalApples: उपलब्ध सेबों की कुल संख्या\n   - timePerApple: एक सेब खाने में लगने वाला समय (timePerApple>=0)\n   - timeElapsed: कुल बीता हुआ समय\n\n   उदाहरण:\n   >>> RemainingApples(50, 10, 200)\n   30",
      "hu": "Írj egy C# függvényt `static int RemainingApples(int totalApples, int timePerApple, int timeElapsed)` a következő probléma megoldására:\nKiszámítja a megmaradt egész almák számát, miután adott ideig ettünk almákat.\n   Minden alma elfogyasztása egy bizonyos időt vesz igénybe, és a függvény visszaadja, hogy hány egész alma maradt meg.\n   - totalApples: a rendelkezésre álló almák teljes száma\n   - timePerApple: az idő, ami egy alma elfogyasztásához szükséges (timePerApple>=0)\n   - timeElapsed: az eltelt idő összesen\n\n   Példák:\n   >>> RemainingApples(50, 10, 200)\n   30"
    },
    "instruction_bertscore": {
      "sq": "0.9834310481355938",
      "hy": "0.9574164271314545",
      "bn": "0.9594728474663087",
      "bg": "0.9861622158748234",
      "zh": "0.9686233518598238",
      "fr": "0.9931534093961084",
      "de": "0.9800712152403886",
      "ha": "0.9761955392456358",
      "hi": "0.9725919868729009",
      "hu": "0.9704733952287828"
    },
    "level": "middle",
    "test": "    static void Main()\n    {\n        Debug.Assert(RemainingApples(50, 10, 200) == 30);\n        Debug.Assert(RemainingApples(10, 2, 5) == 7);\n        Debug.Assert(RemainingApples(5, 15, 10) == 4);\n        Debug.Assert(RemainingApples(20, 0, 100) == 0); // Case to test division by zero handling\n        Debug.Assert(RemainingApples(3, 10, 130) == 0); // Case where all apples are eaten\n\n    }\n}",
    "entry_point": "RemainingApples",
    "signature": "static int RemainingApples(int totalApples, int timePerApple, int timeElapsed)",
    "docstring": {
      "en": "Calculates the number of whole apples remaining after eating apples for a given amount of time.\n   Each apple takes a specific amount of time to eat, and the function returns how many whole apples are left uneaten.\n   - totalApples: the total number of apples available\n   - timePerApple: the time it takes to eat one apple (timePerApple>=0)\n   - timeElapsed: the total time elapsed\n\n   Examples:\n   >>> RemainingApples(50, 10, 200)\n   30",
      "sq": "Llogarit numrin e mollëve të plota të mbetura pasi të keni ngrënë mollë për një periudhë të caktuar kohe. \n   Çdo mollë kërkon një kohë specifike për t'u ngrënë, dhe funksioni kthen sa mollë të plota mbeten të pangrëna.\n   - totalApples: numri total i mollëve në dispozicion\n   - timePerApple: koha që duhet për të ngrënë një mollë (timePerApple>=0)\n   - timeElapsed: koha totale e kaluar\n\n   Shembuj:\n   >>> RemainingApples(50, 10, 200)\n   30",
      "hy": "Հաշվում է ամբողջ խնձորների քանակը, որոնք մնացել են ուտելուց հետո որոշակի ժամանակահատվածում:\n   Յուրաքանչյուր խնձոր ուտելու համար պահանջվում է որոշակի ժամանակ, և ֆունկցիան վերադարձնում է, թե քանի ամբողջ խնձոր է մնացել չուտված:\n   - totalApples: հասանելի խնձորների ընդհանուր քանակը\n   - timePerApple: մեկ խնձոր ուտելու համար պահանջվող ժամանակը (timePerApple>=0)\n   - timeElapsed: անցած ընդհանուր ժամանակը\n\n   Օրինակներ:\n   >>> RemainingApples(50, 10, 200)\n   30",
      "bn": "সম্পূর্ণ আপেল খাওয়ার পর কতগুলি আপেল অবশিষ্ট থাকবে তা গণনা করে।  \nপ্রতিটি আপেল খেতে নির্দিষ্ট পরিমাণ সময় লাগে এবং ফাংশনটি কতগুলি সম্পূর্ণ আপেল অবশিষ্ট রয়েছে তা ফেরত দেয়।  \n- totalApples: উপলব্ধ আপেলের মোট সংখ্যা  \n- timePerApple: একটি আপেল খেতে যে সময় লাগে (timePerApple>=0)  \n- timeElapsed: মোট কেটে যাওয়া সময়  \n\nউদাহরণস্বরূপ:  \n>>> RemainingApples(50, 10, 200)  \n30",
      "bg": "Изчислява броя на целите ябълки, останали след ядене на ябълки за дадено време.  \nВсяка ябълка отнема определено време за ядене, и функцията връща колко цели ябълки остават неядени.  \n- totalApples: общият брой на наличните ябълки  \n- timePerApple: времето, необходимо за изяждане на една ябълка (timePerApple>=0)  \n- timeElapsed: общото изминало време  \n\nПримери:  \n>>> RemainingApples(50, 10, 200)  \n30",
      "zh": "计算在给定时间内吃苹果后剩余的完整苹果数量。\n每个苹果需要特定的时间来吃，函数返回剩下多少完整的苹果未被吃掉。\n- totalApples: 可用的苹果总数\n- timePerApple: 吃一个苹果所需的时间 (timePerApple>=0)\n- timeElapsed: 总共经过的时间\n\n示例：\n>>> RemainingApples(50, 10, 200)\n30",
      "fr": "Calcule le nombre de pommes entières restantes après avoir mangé des pommes pendant un certain temps donné.\n   Chaque pomme prend un certain temps à être mangée, et la fonction retourne combien de pommes entières restent non mangées.\n   - totalApples : le nombre total de pommes disponibles\n   - timePerApple : le temps qu'il faut pour manger une pomme (timePerApple>=0)\n   - timeElapsed : le temps total écoulé\n\n   Exemples :\n   >>> RemainingApples(50, 10, 200)\n   30",
      "de": "Berechnet die Anzahl der ganzen Äpfel, die nach dem Essen von Äpfeln für eine bestimmte Zeit übrig bleiben.\n   Jeder Apfel benötigt eine bestimmte Zeit zum Essen, und die Funktion gibt zurück, wie viele ganze Äpfel uneaten bleiben.\n   - totalApples: die Gesamtanzahl der verfügbaren Äpfel\n   - timePerApple: die Zeit, die benötigt wird, um einen Apfel zu essen (timePerApple>=0)\n   - timeElapsed: die insgesamt verstrichene Zeit\n\n   Beispiele:\n   >>> RemainingApples(50, 10, 200)\n   30",
      "ha": "Yana ƙididdige yawan cikakkun tuffa da suka rage bayan cin tuffa na wani lokaci da aka bayar.\n   Kowace tuffa tana ɗaukar wani takamaiman lokaci don ci, kuma aikin yana dawo da yawan cikakkun tuffa da suka rage ba a ci ba.\n   - totalApples: jimillar yawan tuffa da ake da su\n   - timePerApple: lokacin da ake ɗauka don cin tuffa ɗaya (timePerApple>=0)\n   - timeElapsed: jimillar lokacin da ya shige\n\n   Misalai:\n   >>> RemainingApples(50, 10, 200)\n   30",
      "hi": "कुल समय के बाद खाने के बाद बचे हुए पूरे सेबों की संख्या की गणना करता है।  \nप्रत्येक सेब को खाने में विशिष्ट समय लगता है, और यह फ़ंक्शन यह बताता है कि कितने पूरे सेब बिना खाए बचे हैं।  \n- totalApples: उपलब्ध सेबों की कुल संख्या  \n- timePerApple: एक सेब खाने में लगने वाला समय (timePerApple>=0)  \n- timeElapsed: कुल बीता हुआ समय  \n\nउदाहरण:  \n>>> RemainingApples(50, 10, 200)  \n30",
      "hu": "Kiszámítja a megmaradt egész almák számát, miután almákat ettünk egy adott időtartam alatt.\n   Minden alma elfogyasztása egy meghatározott időt vesz igénybe, és a függvény visszaadja, hány egész alma maradt érintetlenül.\n   - totalApples: az elérhető almák teljes száma\n   - timePerApple: az idő, amely alatt egy almát el lehet fogyasztani (timePerApple>=0)\n   - timeElapsed: az eltelt összidő\n\n   Példák:\n   >>> RemainingApples(50, 10, 200)\n   30"
    },
    "docstring_bertscore": {
      "sq": "0.9709157450873476",
      "hy": "0.9620119396270777",
      "bn": "0.9345812826365406",
      "bg": "0.9767151563224231",
      "zh": "0.9567097002357323",
      "fr": "0.9809042710584489",
      "de": "0.9621553507621848",
      "ha": "0.9708613203629439",
      "hi": "0.9358624485942156",
      "hu": "0.959132792253977"
    }
  },
  {
    "task_id": "C#/49",
    "prompt": {
      "en": "using System;\nusing System.Collections.Generic;\nusing System.Diagnostics;\n\nclass Program\n{\n\n/*\n    Finds the missing (broken) and duplicated ID from a series of ID sequences.\n    IDs are supposed to be continuous but due to an error, one ID is missing and one is duplicated.\n    The function returns a tuple with the first element being the missing ID and the second the duplicated ID.\n\n    Args:\n    ids: A list of lists, each sublist contains a series of ticket IDs.\n\n    Returns:\n    A tuple of two integers: the first is the missing ID (m) and the second is the duplicated ID (n).\n\n    Examples:\n    >>> FindErrorIds(new List<List<int>> { new List<int> {5, 6, 8, 11, 9}, new List<int> {10, 12, 9} })\n    (7, 9)\n    >>> FindErrorIds(new List<List<int>> { new List<int> {1, 2, 4}, new List<int> {3, 3} })\n    (5, 3)\n*/\n\n    static (int, int) FindErrorIds(List<List<int>> ids)",
      "sq": "using System;\nusing System.Collections.Generic;\nusing System.Diagnostics;\n\nclass Program\n{\n\n/*\n    Gjen ID-në që mungon (të prishur) dhe ID-në e kopjuar nga një seri sekuencash ID.\n    ID-të supozohet të jenë të vazhdueshme, por për shkak të një gabimi, një ID mungon dhe një është e kopjuar.\n    Funksioni kthen një dyshe me elementin e parë që është ID-ja që mungon dhe e dyta ID-ja e kopjuar.\n\n    Argumentet:\n    ids: Një listë listash, secila nënlistë përmban një seri ID biletash.\n\n    Kthen:\n    Një dyshe e dy numrave të plotë: e para është ID-ja që mungon (m) dhe e dyta është ID-ja e kopjuar (n).\n\n    Shembuj:\n    >>> FindErrorIds(new List<List<int>> { new List<int> {5, 6, 8, 11, 9}, new List<int> {10, 12, 9} })\n    (7, 9)\n    >>> FindErrorIds(new List<List<int>> { new List<int> {1, 2, 4}, new List<int> {3, 3} })\n    (5, 3)\n*/\n\n    static (int, int) FindErrorIds(List<List<int>> ids)",
      "hy": "using System;\nusing System.Collections.Generic;\nusing System.Diagnostics;\n\nclass Program\n{\n\n/*\n    Գտնում է բացակայող (կոտրված) և կրկնօրինակված ID-ն ID հաջորդականությունների շարքից:\n    ID-ները պետք է լինեն շարունակական, բայց սխալի պատճառով մեկ ID բացակայում է, իսկ մեկը կրկնօրինակված է:\n    Ֆունկցիան վերադարձնում է զույգ, որի առաջին տարրը բացակայող ID-ն է, իսկ երկրորդը՝ կրկնօրինակված ID-ն:\n\n    Արգումենտներ:\n    ids: Ցուցակների ցուցակ, յուրաքանչյուր ենթացուցակ պարունակում է տոմսերի ID-ների շարք:\n\n    Վերադարձնում է:\n    Երկու ամբողջ թվերի զույգ՝ առաջինը բացակայող ID-ն է (m), իսկ երկրորդը՝ կրկնօրինակված ID-ն (n):\n\n    Օրինակներ:\n    >>> FindErrorIds(new List<List<int>> { new List<int> {5, 6, 8, 11, 9}, new List<int> {10, 12, 9} })\n    (7, 9)\n    >>> FindErrorIds(new List<List<int>> { new List<int> {1, 2, 4}, new List<int> {3, 3} })\n    (5, 3)\n*/\n\n    static (int, int) FindErrorIds(List<List<int>> ids)",
      "bn": "using System;\nusing System.Collections.Generic;\nusing System.Diagnostics;\n\nclass Program\n{\n\n/*\n    একটি সিরিজ আইডি সিকোয়েন্স থেকে অনুপস্থিত (ভাঙা) এবং সদৃশ আইডি খুঁজে বের করে।\n    আইডিগুলি ধারাবাহিক হওয়া উচিত কিন্তু একটি ত্রুটির কারণে একটি আইডি অনুপস্থিত এবং একটি সদৃশ।\n    ফাংশনটি একটি টুপল ফেরত দেয় যার প্রথম উপাদানটি অনুপস্থিত আইডি এবং দ্বিতীয়টি সদৃশ আইডি।\n\n    আর্গুমেন্টসমূহ:\n    ids: তালিকার একটি তালিকা, প্রতিটি উপতালিকা একটি সিরিজ টিকিট আইডি ধারণ করে।\n\n    রিটার্নস:\n    দুটি পূর্ণসংখ্যার একটি টুপল: প্রথমটি অনুপস্থিত আইডি (m) এবং দ্বিতীয়টি সদৃশ আইডি (n)।\n\n    উদাহরণ:\n    >>> FindErrorIds(new List<List<int>> { new List<int> {5, 6, 8, 11, 9}, new List<int> {10, 12, 9} })\n    (7, 9)\n    >>> FindErrorIds(new List<List<int>> { new List<int> {1, 2, 4}, new List<int> {3, 3} })\n    (5, 3)\n*/\n\n    static (int, int) FindErrorIds(List<List<int>> ids)",
      "bg": "using System;\nusing System.Collections.Generic;\nusing System.Diagnostics;\n\nclass Program\n{\n\n/*\n    Намира липсващото (счупено) и дублираното ID от серия от последователности на ID.\n    ID-тата трябва да са непрекъснати, но поради грешка едно ID липсва и едно е дублирано.\n    Функцията връща кортеж, като първият елемент е липсващото ID, а вторият е дублираното ID.\n\n    Аргументи:\n    ids: Списък от списъци, като всеки подсписък съдържа серия от ID на билети.\n\n    Връща:\n    Кортеж от две цели числа: първото е липсващото ID (m), а второто е дублираното ID (n).\n\n    Примери:\n    >>> FindErrorIds(new List<List<int>> { new List<int> {5, 6, 8, 11, 9}, new List<int> {10, 12, 9} })\n    (7, 9)\n    >>> FindErrorIds(new List<List<int>> { new List<int> {1, 2, 4}, new List<int> {3, 3} })\n    (5, 3)\n*/\n\n    static (int, int) FindErrorIds(List<List<int>> ids)",
      "zh": "using System;\nusing System.Collections.Generic;\nusing System.Diagnostics;\n\nclass Program\n{\n\n/*\n    查找一系列ID序列中的缺失（损坏）和重复的ID。\n    ID应该是连续的，但由于错误，一个ID缺失，一个ID重复。\n    该函数返回一个元组，第一个元素是缺失的ID，第二个是重复的ID。\n\n    参数:\n    ids: 一个列表的列表，每个子列表包含一系列票据ID。\n\n    返回:\n    一个包含两个整数的元组：第一个是缺失的ID (m)，第二个是重复的ID (n)。\n\n    示例:\n    >>> FindErrorIds(new List<List<int>> { new List<int> {5, 6, 8, 11, 9}, new List<int> {10, 12, 9} })\n    (7, 9)\n    >>> FindErrorIds(new List<List<int>> { new List<int> {1, 2, 4}, new List<int> {3, 3} })\n    (5, 3)\n*/\n\n    static (int, int) FindErrorIds(List<List<int>> ids)",
      "fr": "using System;\nusing System.Collections.Generic;\nusing System.Diagnostics;\n\nclass Program\n{\n\n/*\n    Trouve l'ID manquant (cassé) et l'ID dupliqué à partir d'une série de séquences d'ID.\n    Les IDs sont supposés être continus mais en raison d'une erreur, un ID est manquant et un est dupliqué.\n    La fonction retourne un tuple avec le premier élément étant l'ID manquant et le second l'ID dupliqué.\n\n    Args:\n    ids: Une liste de listes, chaque sous-liste contient une série d'IDs de tickets.\n\n    Returns:\n    Un tuple de deux entiers : le premier est l'ID manquant (m) et le second est l'ID dupliqué (n).\n\n    Examples:\n    >>> FindErrorIds(new List<List<int>> { new List<int> {5, 6, 8, 11, 9}, new List<int> {10, 12, 9} })\n    (7, 9)\n    >>> FindErrorIds(new List<List<int>> { new List<int> {1, 2, 4}, new List<int> {3, 3} })\n    (5, 3)\n*/\n\n    static (int, int) FindErrorIds(List<List<int>> ids)",
      "de": "using System;\nusing System.Collections.Generic;\nusing System.Diagnostics;\n\nclass Program\n{\n\n/*\n    Findet die fehlende (defekte) und doppelte ID aus einer Reihe von ID-Sequenzen.\n    IDs sollen kontinuierlich sein, aber aufgrund eines Fehlers fehlt eine ID und eine ist doppelt vorhanden.\n    Die Funktion gibt ein Tupel zurück, wobei das erste Element die fehlende ID und das zweite die doppelte ID ist.\n\n    Argumente:\n    ids: Eine Liste von Listen, jede Unterliste enthält eine Reihe von Ticket-IDs.\n\n    Rückgabewerte:\n    Ein Tupel aus zwei ganzen Zahlen: die erste ist die fehlende ID (m) und die zweite ist die doppelte ID (n).\n\n    Beispiele:\n    >>> FindErrorIds(new List<List<int>> { new List<int> {5, 6, 8, 11, 9}, new List<int> {10, 12, 9} })\n    (7, 9)\n    >>> FindErrorIds(new List<List<int>> { new List<int> {1, 2, 4}, new List<int> {3, 3} })\n    (5, 3)\n*/\n\n    static (int, int) FindErrorIds(List<List<int>> ids)",
      "ha": "using System;\nusing System.Collections.Generic;\nusing System.Diagnostics;\n\nclass Program\n{\n\n/*\n    Nemi ID da ya ɓace (karye) da kuma wanda aka maimaita daga jerin jerin ID.\n    Ana tsammanin ID za su kasance masu ci gaba amma saboda kuskure, ɗaya ID ya ɓace kuma ɗaya an maimaita.\n    Aikin yana dawowa da tuple tare da abu na farko shine ID da ya ɓace kuma na biyu shine ID da aka maimaita.\n\n    Args:\n    ids: Jerin jerin, kowace ƙaramin jerin tana ɗauke da jerin ID na tikiti.\n\n    Returns:\n    Tuple na lambobi biyu: na farko shine ID da ya ɓace (m) kuma na biyu shine ID da aka maimaita (n).\n\n    Misalai:\n    >>> FindErrorIds(new List<List<int>> { new List<int> {5, 6, 8, 11, 9}, new List<int> {10, 12, 9} })\n    (7, 9)\n    >>> FindErrorIds(new List<List<int>> { new List<int> {1, 2, 4}, new List<int> {3, 3} })\n    (5, 3)\n*/\n\n    static (int, int) FindErrorIds(List<List<int>> ids)",
      "hi": "using System;\nusing System.Collections.Generic;\nusing System.Diagnostics;\n\nclass Program\n{\n\n/*\n    ID अनुक्रमों की एक श्रृंखला से गायब (टूटी हुई) और डुप्लिकेट ID खोजता है।\n    IDs को निरंतर होना चाहिए लेकिन एक त्रुटि के कारण, एक ID गायब है और एक डुप्लिकेट है।\n    फ़ंक्शन एक युग्म लौटाता है जिसमें पहला तत्व गायब ID है और दूसरा डुप्लिकेट ID है।\n\n    तर्क:\n    ids: सूचियों की एक सूची, प्रत्येक उपसूची में टिकट IDs की एक श्रृंखला होती है।\n\n    रिटर्न:\n    दो पूर्णांकों का एक युग्म: पहला गायब ID (m) है और दूसरा डुप्लिकेट ID (n) है।\n\n    उदाहरण:\n    >>> FindErrorIds(new List<List<int>> { new List<int> {5, 6, 8, 11, 9}, new List<int> {10, 12, 9} })\n    (7, 9)\n    >>> FindErrorIds(new List<List<int>> { new List<int> {1, 2, 4}, new List<int> {3, 3} })\n    (5, 3)\n*/\n\n    static (int, int) FindErrorIds(List<List<int>> ids)",
      "hu": "using System;\nusing System.Collections.Generic;\nusing System.Diagnostics;\n\nclass Program\n{\n\n/*\n    Megkeresi a hiányzó (hibás) és a duplikált azonosítót egy azonosítósorozatból.\n    Az azonosítóknak folytonosnak kellene lenniük, de egy hiba miatt egy azonosító hiányzik és egy duplikált.\n    A függvény egy tuple-t ad vissza, amelynek első eleme a hiányzó azonosító, a második pedig a duplikált azonosító.\n\n    Argumentumok:\n    ids: Listák listája, minden allista egy sorozat jegyazonosítót tartalmaz.\n\n    Visszatérési érték:\n    Két egész számot tartalmazó tuple: az első a hiányzó azonosító (m), a második a duplikált azonosító (n).\n\n    Példák:\n    >>> FindErrorIds(new List<List<int>> { new List<int> {5, 6, 8, 11, 9}, new List<int> {10, 12, 9} })\n    (7, 9)\n    >>> FindErrorIds(new List<List<int>> { new List<int> {1, 2, 4}, new List<int> {3, 3} })\n    (5, 3)\n*/\n\n    static (int, int) FindErrorIds(List<List<int>> ids)"
    },
    "prompt_bertscore": {
      "sq": "0.9780199592954414",
      "hy": "0.9716250541780231",
      "bn": "0.9678661728473189",
      "bg": "0.974049735239316",
      "zh": "0.9669645895478015",
      "fr": "0.9840535557497571",
      "de": "0.9798940369405055",
      "ha": "0.9618444942158653",
      "hi": "0.9655972180047574",
      "hu": "0.9532036753800855"
    },
    "canonical_solution": "    {\n        var allIds = ids.SelectMany(idList => idList).OrderBy(id => id).ToList();\n        int missingId = 0, duplicatedId = 0;\n\n        for (int i = 1; i < allIds.Count; i++)\n        {\n            if (allIds[i] == allIds[i - 1])\n            {\n                duplicatedId = allIds[i];\n            }\n            else if (allIds[i] - allIds[i - 1] > 1)\n            {\n                missingId = allIds[i - 1] + 1;\n            }\n        }\n\n        return (missingId, duplicatedId);\n    }",
    "instruction": {
      "en": "Write a C# function `static (int, int) FindErrorIds(List<List<int>> ids)` to solve the following problem:\nFinds the missing (broken) and duplicated ID from a series of ID sequences.\n    IDs are supposed to be continuous but due to an error, one ID is missing and one is duplicated.\n    The function returns a tuple with the first element being the missing ID and the second the duplicated ID.\n\n    Args:\n    ids: A list of lists, each sublist contains a series of ticket IDs.\n\n    Returns:\n    A tuple of two integers: the first is the missing ID (m) and the second is the duplicated ID (n).\n\n    Examples:\n    >>> FindErrorIds(new List<List<int>> { new List<int> {5, 6, 8, 11, 9}, new List<int> {10, 12, 9} })\n    (7, 9)\n    >>> FindErrorIds(new List<List<int>> { new List<int> {1, 2, 4}, new List<int> {3, 3} })\n    (5, 3)",
      "sq": "Shkruani një funksion në C# `static (int, int) FindErrorIds(List<List<int>> ids)` për të zgjidhur problemin e mëposhtëm:\nGjen ID-në që mungon (të prishur) dhe ID-në e kopjuar nga një seri sekuencash ID-sh.\n    ID-të supozohet të jenë të vazhdueshme, por për shkak të një gabimi, një ID mungon dhe një është e kopjuar.\n    Funksioni kthen një dyshe me elementin e parë që është ID-ja që mungon dhe e dyta ID-ja e kopjuar.\n\n    Argumentet:\n    ids: Një listë listash, ku secila nënlistë përmban një seri ID biletash.\n\n    Kthen:\n    Një dyshe me dy numra të plotë: e para është ID-ja që mungon (m) dhe e dyta është ID-ja e kopjuar (n).\n\n    Shembuj:\n    >>> FindErrorIds(new List<List<int>> { new List<int> {5, 6, 8, 11, 9}, new List<int> {10, 12, 9} })\n    (7, 9)\n    >>> FindErrorIds(new List<List<int>> { new List<int> {1, 2, 4}, new List<int> {3, 3} })\n    (5, 3)",
      "hy": "Գրեք C# ֆունկցիա `static (int, int) FindErrorIds(List<List<int>> ids)` հետևյալ խնդիրը լուծելու համար:\nԳտնում է բացակայող (կոտրված) և կրկնվող ID-ն ID հաջորդականությունների շարքից:\n    ID-ները պետք է լինեն շարունակական, բայց սխալի պատճառով մեկ ID բացակայում է և մեկը կրկնվում է:\n    Ֆունկցիան վերադարձնում է զույգ, որի առաջին տարրը բացակայող ID-ն է, իսկ երկրորդը՝ կրկնվող ID-ն:\n\n    Արգումենտներ:\n    ids: Ցուցակ ցուցակների, յուրաքանչյուր ենթացուցակը պարունակում է տոմսերի ID-ների շարք:\n\n    Վերադարձնում է:\n    Երկու ամբողջ թվերի զույգ՝ առաջինը բացակայող ID-ն (m) է, իսկ երկրորդը՝ կրկնվող ID-ն (n):\n\n    Օրինակներ:\n    >>> FindErrorIds(new List<List<int>> { new List<int> {5, 6, 8, 11, 9}, new List<int> {10, 12, 9} })\n    (7, 9)\n    >>> FindErrorIds(new List<List<int>> { new List<int> {1, 2, 4}, new List<int> {3, 3} })\n    (5, 3)",
      "bn": "C# ফাংশন `static (int, int) FindErrorIds(List<List<int>> ids)` লিখুন নিম্নলিখিত সমস্যার সমাধানের জন্য:\nআইডি সিকোয়েন্সের একটি সিরিজ থেকে অনুপস্থিত (ভাঙা) এবং সদৃশ আইডি খুঁজে বের করে।\n    আইডিগুলি ধারাবাহিক হওয়ার কথা ছিল কিন্তু একটি ত্রুটির কারণে একটি আইডি অনুপস্থিত এবং একটি সদৃশ হয়েছে।\n    ফাংশনটি একটি টিউপল রিটার্ন করে যার প্রথম উপাদানটি অনুপস্থিত আইডি এবং দ্বিতীয়টি সদৃশ আইডি।\n\n    আর্গুমেন্টস:\n    ids: একটি তালিকার তালিকা, প্রতিটি উপতালিকায় টিকিট আইডির একটি সিরিজ রয়েছে।\n\n    রিটার্নস:\n    দুটি পূর্ণসংখ্যার একটি টিউপল: প্রথমটি অনুপস্থিত আইডি (m) এবং দ্বিতীয়টি সদৃশ আইডি (n)।\n\n    উদাহরণ:\n    >>> FindErrorIds(new List<List<int>> { new List<int> {5, 6, 8, 11, 9}, new List<int> {10, 12, 9} })\n    (7, 9)\n    >>> FindErrorIds(new List<List<int>> { new List<int> {1, 2, 4}, new List<int> {3, 3} })\n    (5, 3)",
      "bg": "Напишете C# функция `static (int, int) FindErrorIds(List<List<int>> ids)`, за да решите следния проблем:\nНамира липсващото (счупено) и дублираното ID от поредица от ID последователности.\n    ID-тата трябва да са непрекъснати, но поради грешка едно ID липсва и едно е дублирано.\n    Функцията връща кортеж, като първият елемент е липсващото ID, а вторият е дублираното ID.\n\n    Аргументи:\n    ids: Списък от списъци, като всеки подсписък съдържа поредица от ID номера на билети.\n\n    Връща:\n    Кортеж от два цели числа: първото е липсващото ID (m), а второто е дублираното ID (n).\n\n    Примери:\n    >>> FindErrorIds(new List<List<int>> { new List<int> {5, 6, 8, 11, 9}, new List<int> {10, 12, 9} })\n    (7, 9)\n    >>> FindErrorIds(new List<List<int>> { new List<int> {1, 2, 4}, new List<int> {3, 3} })\n    (5, 3)",
      "zh": "编写一个 C# 函数 `static (int, int) FindErrorIds(List<List<int>> ids)` 来解决以下问题：\n查找一系列 ID 序列中缺失（损坏）和重复的 ID。\n    ID 应该是连续的，但由于错误，一个 ID 缺失且一个 ID 重复。\n    该函数返回一个元组，第一个元素是缺失的 ID，第二个是重复的 ID。\n\n    参数：\n    ids: 一个列表的列表，每个子列表包含一系列票据 ID。\n\n    返回：\n    一个包含两个整数的元组：第一个是缺失的 ID (m)，第二个是重复的 ID (n)。\n\n    示例：\n    >>> FindErrorIds(new List<List<int>> { new List<int> {5, 6, 8, 11, 9}, new List<int> {10, 12, 9} })\n    (7, 9)\n    >>> FindErrorIds(new List<List<int>> { new List<int> {1, 2, 4}, new List<int> {3, 3} })\n    (5, 3)",
      "fr": "Écrire une fonction C# `static (int, int) FindErrorIds(List<List<int>> ids)` pour résoudre le problème suivant :\nTrouver l'ID manquant (cassé) et l'ID dupliqué à partir d'une série de séquences d'ID.\n    Les IDs sont supposés être continus mais en raison d'une erreur, un ID est manquant et un est dupliqué.\n    La fonction retourne un tuple dont le premier élément est l'ID manquant et le second l'ID dupliqué.\n\n    Args:\n    ids: Une liste de listes, chaque sous-liste contient une série d'IDs de tickets.\n\n    Returns:\n    Un tuple de deux entiers : le premier est l'ID manquant (m) et le second est l'ID dupliqué (n).\n\n    Examples:\n    >>> FindErrorIds(new List<List<int>> { new List<int> {5, 6, 8, 11, 9}, new List<int> {10, 12, 9} })\n    (7, 9)\n    >>> FindErrorIds(new List<List<int>> { new List<int> {1, 2, 4}, new List<int> {3, 3} })\n    (5, 3)",
      "de": "Schreiben Sie eine C#-Funktion `static (int, int) FindErrorIds(List<List<int>> ids)`, um das folgende Problem zu lösen:\nFindet die fehlende (defekte) und doppelte ID aus einer Reihe von ID-Sequenzen.\n    IDs sollen kontinuierlich sein, aber aufgrund eines Fehlers fehlt eine ID und eine ist doppelt vorhanden.\n    Die Funktion gibt ein Tupel zurück, wobei das erste Element die fehlende ID und das zweite die doppelte ID ist.\n\n    Argumente:\n    ids: Eine Liste von Listen, jede Unterliste enthält eine Reihe von Ticket-IDs.\n\n    Rückgabewerte:\n    Ein Tupel von zwei ganzen Zahlen: die erste ist die fehlende ID (m) und die zweite ist die doppelte ID (n).\n\n    Beispiele:\n    >>> FindErrorIds(new List<List<int>> { new List<int> {5, 6, 8, 11, 9}, new List<int> {10, 12, 9} })\n    (7, 9)\n    >>> FindErrorIds(new List<List<int>> { new List<int> {1, 2, 4}, new List<int> {3, 3} })\n    (5, 3)",
      "ha": "Rubuta aikin C# `static (int, int) FindErrorIds(List<List<int>> ids)` don warware matsalar mai zuwa:\nNemo ID da ya ɓace (ya lalace) da wanda aka maimaita daga jerin ID.\n    IDs ya kamata su kasance masu ci gaba amma saboda kuskure, ɗaya ID ya ɓace kuma ɗaya an maimaita shi.\n    Aikin yana mayar da tuple tare da abu na farko shine ID da ya ɓace kuma na biyu shine ID da aka maimaita.\n\n    Args:\n    ids: Jerin jerin, kowace ƙaramin jerin tana ɗauke da jerin ID na tikiti.\n\n    Returns:\n    Tuple na lambobi biyu: na farko shine ID da ya ɓace (m) kuma na biyu shine ID da aka maimaita (n).\n\n    Misalai:\n    >>> FindErrorIds(new List<List<int>> { new List<int> {5, 6, 8, 11, 9}, new List<int> {10, 12, 9} })\n    (7, 9)\n    >>> FindErrorIds(new List<List<int>> { new List<int> {1, 2, 4}, new List<int> {3, 3} })\n    (5, 3)",
      "hi": "C# फ़ंक्शन `static (int, int) FindErrorIds(List<List<int>> ids)` लिखें ताकि निम्नलिखित समस्या का समाधान किया जा सके:\nखोए हुए (टूटे हुए) और डुप्लिकेट ID को ID अनुक्रमों की एक श्रृंखला से खोजें।\n    IDs को निरंतर होना चाहिए लेकिन एक त्रुटि के कारण, एक ID गायब है और एक डुप्लिकेट है।\n    फ़ंक्शन एक ट्यूपल लौटाता है जिसमें पहला तत्व गायब ID है और दूसरा डुप्लिकेट ID है।\n\n    तर्क:\n    ids: सूचियों की एक सूची, प्रत्येक उप-सूची में टिकट IDs की एक श्रृंखला होती है।\n\n    रिटर्न:\n    दो पूर्णांकों का एक ट्यूपल: पहला गायब ID (m) है और दूसरा डुप्लिकेट ID (n) है।\n\n    उदाहरण:\n    >>> FindErrorIds(new List<List<int>> { new List<int> {5, 6, 8, 11, 9}, new List<int> {10, 12, 9} })\n    (7, 9)\n    >>> FindErrorIds(new List<List<int>> { new List<int> {1, 2, 4}, new List<int> {3, 3} })\n    (5, 3)",
      "hu": "Írj egy C# függvényt `static (int, int) FindErrorIds(List<List<int>> ids)` a következő probléma megoldására:\nMegtalálja a hiányzó (hibás) és a duplikált azonosítót egy azonosítósorozatból.\n    Az azonosítóknak folyamatosnak kellene lenniük, de egy hiba miatt egy azonosító hiányzik, és egy duplikált.\n    A függvény egy tuple-t ad vissza, amelynek első eleme a hiányzó azonosító, a második pedig a duplikált azonosító.\n\n    Argok:\n    ids: Listák listája, minden allista egy sorozat jegyazonosítót tartalmaz.\n\n    Visszatér:\n    Két egész számot tartalmazó tuple: az első a hiányzó azonosító (m), a második a duplikált azonosító (n).\n\n    Példák:\n    >>> FindErrorIds(new List<List<int>> { new List<int> {5, 6, 8, 11, 9}, new List<int> {10, 12, 9} })\n    (7, 9)\n    >>> FindErrorIds(new List<List<int>> { new List<int> {1, 2, 4}, new List<int> {3, 3} })\n    (5, 3)"
    },
    "instruction_bertscore": {
      "sq": "0.9713098277633208",
      "hy": "0.9701299632999735",
      "bn": "0.9679885291620364",
      "bg": "0.9708780053149509",
      "zh": "0.9691141675313611",
      "fr": "0.9803892224804255",
      "de": "0.9739325433145054",
      "ha": "0.9454525220209611",
      "hi": "0.9646020797957726",
      "hu": "0.9553534519940261"
    },
    "level": "middle",
    "test": "static void Main()\n    {\n\n        Debug.Assert(FindErrorIds(new List<List<int>> { new List<int> {5, 6, 8, 11, 9}, new List<int> {10, 12, 9} }) == (7, 9));\n        Debug.Assert(FindErrorIds(new List<List<int>> { new List<int> {1, 2, 4, 6}, new List<int> {3, 3} }) == (5, 3));\n        Debug.Assert(FindErrorIds(new List<List<int>> { new List<int> { 110, 112, 108 }, new List<int> { 107, 109, 108 } }) == (111, 108));\n\n    }\n}",
    "entry_point": "FindErrorIds",
    "signature": "static (int, int) FindErrorIds(List<List<int>> ids)",
    "docstring": {
      "en": "Finds the missing (broken) and duplicated ID from a series of ID sequences.\n    IDs are supposed to be continuous but due to an error, one ID is missing and one is duplicated.\n    The function returns a tuple with the first element being the missing ID and the second the duplicated ID.\n\n    Args:\n    ids: A list of lists, each sublist contains a series of ticket IDs.\n\n    Returns:\n    A tuple of two integers: the first is the missing ID (m) and the second is the duplicated ID (n).\n\n    Examples:\n    >>> FindErrorIds(new List<List<int>> { new List<int> {5, 6, 8, 11, 9}, new List<int> {10, 12, 9} })\n    (7, 9)\n    >>> FindErrorIds(new List<List<int>> { new List<int> {1, 2, 4}, new List<int> {3, 3} })\n    (5, 3)",
      "sq": "Gjen ID-në e munguar (të prishur) dhe të dyfishuar nga një seri sekuencash ID-sh.\n    ID-të supozohet të jenë të pandërprera, por për shkak të një gabimi, një ID mungon dhe një është e dyfishuar.\n    Funksioni kthen një tuple me elementin e parë që është ID-ja e munguar dhe e dyta ID-ja e dyfishuar.\n\n    Argumentet:\n    ids: Një listë listash, çdo nënlistë përmban një seri ID biletash.\n\n    Kthen:\n    Një tuple me dy numra të plotë: i pari është ID-ja e munguar (m) dhe i dyti është ID-ja e dyfishuar (n).\n\n    Shembuj:\n    >>> FindErrorIds(new List<List<int>> { new List<int> {5, 6, 8, 11, 9}, new List<int> {10, 12, 9} })\n    (7, 9)\n    >>> FindErrorIds(new List<List<int>> { new List<int> {1, 2, 4}, new List<int> {3, 3} })\n    (5, 3)",
      "hy": "Գտնում է բացակայող (կոտրված) և կրկնօրինակված ID-ն ID հաջորդականությունների շարքից:\n    ID-ները պետք է լինեն շարունակական, բայց սխալի պատճառով մեկ ID բացակայում է և մեկը կրկնօրինակված է:\n    Ֆունկցիան վերադարձնում է զույգ, որի առաջին տարրը բացակայող ID-ն է, իսկ երկրորդը՝ կրկնօրինակված ID-ն:\n\n    Արգումենտներ:\n    ids: Ցուցակների ցուցակ, յուրաքանչյուր ենթացուցակ պարունակում է տոմսերի ID-ների շարք:\n\n    Վերադարձնում է:\n    Երկու ամբողջ թվերի զույգ. առաջինը բացակայող ID-ն է (m), իսկ երկրորդը կրկնօրինակված ID-ն է (n):\n\n    Օրինակներ.\n    >>> FindErrorIds(new List<List<int>> { new List<int> {5, 6, 8, 11, 9}, new List<int> {10, 12, 9} })\n    (7, 9)\n    >>> FindErrorIds(new List<List<int>> { new List<int> {1, 2, 4}, new List<int> {3, 3} })\n    (5, 3)",
      "bn": "একটি সিরিজ আইডি সিকোয়েন্স থেকে অনুপস্থিত (ভাঙা) এবং সদৃশ আইডি খুঁজে বের করে।\n    আইডি গুলি ধারাবাহিক হওয়ার কথা কিন্তু একটি ত্রুটির কারণে একটি আইডি অনুপস্থিত এবং একটি আইডি পুনরাবৃত্ত।\n    ফাংশনটি একটি টুপল ফেরত দেয় যার প্রথম উপাদানটি অনুপস্থিত আইডি এবং দ্বিতীয়টি পুনরাবৃত্ত আইডি।\n\n    Args:\n    ids: তালিকার একটি তালিকা, প্রতিটি উপতালিকায় টিকিট আইডির একটি সিরিজ থাকে।\n\n    Returns:\n    দুটি পূর্ণসংখ্যার একটি টুপল: প্রথমটি অনুপস্থিত আইডি (m) এবং দ্বিতীয়টি পুনরাবৃত্ত আইডি (n)।\n\n    Examples:\n    >>> FindErrorIds(new List<List<int>> { new List<int> {5, 6, 8, 11, 9}, new List<int> {10, 12, 9} })\n    (7, 9)\n    >>> FindErrorIds(new List<List<int>> { new List<int> {1, 2, 4}, new List<int> {3, 3} })\n    (5, 3)",
      "bg": "Намира липсващото (счупено) и дублираното ID от серия от последователности от ID.\n    ID-тата трябва да бъдат непрекъснати, но поради грешка едно ID липсва и едно е дублирано.\n    Функцията връща кортеж с първия елемент, който е липсващото ID, и втория - дублираното ID.\n\n    Аргументи:\n    ids: Списък от списъци, като всеки подсписък съдържа серия от ID на билети.\n\n    Връща:\n    Кортеж от две цели числа: първото е липсващото ID (m), а второто е дублираното ID (n).\n\n    Примери:\n    >>> FindErrorIds(new List<List<int>> { new List<int> {5, 6, 8, 11, 9}, new List<int> {10, 12, 9} })\n    (7, 9)\n    >>> FindErrorIds(new List<List<int>> { new List<int> {1, 2, 4}, new List<int> {3, 3} })\n    (5, 3)",
      "zh": "查找缺失（损坏）和重复的ID从一系列ID序列中。\n    ID应该是连续的，但由于错误，一个ID缺失且一个ID重复。\n    该函数返回一个元组，第一个元素是缺失的ID，第二个是重复的ID。\n\n    参数：\n    ids: 一个列表的列表，每个子列表包含一系列票据ID。\n\n    返回：\n    一个包含两个整数的元组：第一个是缺失的ID (m)，第二个是重复的ID (n)。\n\n    示例：\n    >>> FindErrorIds(new List<List<int>> { new List<int> {5, 6, 8, 11, 9}, new List<int> {10, 12, 9} })\n    (7, 9)\n    >>> FindErrorIds(new List<List<int>> { new List<int> {1, 2, 4}, new List<int> {3, 3} })\n    (5, 3)",
      "fr": "Trouve l'ID manquant (cassé) et dupliqué à partir d'une série de séquences d'ID.\n    Les IDs sont censés être continus mais en raison d'une erreur, un ID est manquant et un est dupliqué.\n    La fonction renvoie un tuple dont le premier élément est l'ID manquant et le second l'ID dupliqué.\n\n    Args:\n    ids: Une liste de listes, chaque sous-liste contient une série d'IDs de tickets.\n\n    Returns:\n    Un tuple de deux entiers : le premier est l'ID manquant (m) et le second est l'ID dupliqué (n).\n\n    Examples:\n    >>> FindErrorIds(new List<List<int>> { new List<int> {5, 6, 8, 11, 9}, new List<int> {10, 12, 9} })\n    (7, 9)\n    >>> FindErrorIds(new List<List<int>> { new List<int> {1, 2, 4}, new List<int> {3, 3} })\n    (5, 3)",
      "de": "Findet die fehlende (defekte) und doppelte ID aus einer Reihe von ID-Sequenzen.\n    IDs sollen kontinuierlich sein, aber aufgrund eines Fehlers fehlt eine ID und eine ist doppelt vorhanden.\n    Die Funktion gibt ein Tupel zurück, wobei das erste Element die fehlende ID und das zweite die doppelte ID ist.\n\n    Args:\n    ids: Eine Liste von Listen, jede Unterliste enthält eine Reihe von Ticket-IDs.\n\n    Returns:\n    Ein Tupel von zwei ganzen Zahlen: die erste ist die fehlende ID (m) und die zweite ist die doppelte ID (n).\n\n    Examples:\n    >>> FindErrorIds(new List<List<int>> { new List<int> {5, 6, 8, 11, 9}, new List<int> {10, 12, 9} })\n    (7, 9)\n    >>> FindErrorIds(new List<List<int>> { new List<int> {1, 2, 4}, new List<int> {3, 3} })\n    (5, 3)",
      "ha": "Finds the missing (broken) and duplicated ID daga jerin jerin ID.\n    IDs ya kamata su kasance masu ci gaba amma saboda kuskure, ana rasa ID ɗaya kuma ana maimaita ɗaya.\n    Aikin yana dawowa da tuple tare da abu na farko shine ID da aka rasa kuma na biyu shine ID da aka maimaita.\n\n    Args:\n    ids: Jerin jerin, kowace ƙaramin jerin tana ɗauke da jerin ID na tikiti.\n\n    Returns:\n    Tuple na lambobi biyu: na farko shine ID da aka rasa (m) kuma na biyu shine ID da aka maimaita (n).\n\n    Examples:\n    >>> FindErrorIds(new List<List<int>> { new List<int> {5, 6, 8, 11, 9}, new List<int> {10, 12, 9} })\n    (7, 9)\n    >>> FindErrorIds(new List<List<int>> { new List<int> {1, 2, 4}, new List<int> {3, 3} })\n    (5, 3)",
      "hi": "ID अनुक्रमों की एक श्रृंखला से गायब (टूटा हुआ) और डुप्लिकेट ID खोजता है।\n    ID लगातार होनी चाहिए लेकिन एक त्रुटि के कारण, एक ID गायब है और एक डुप्लिकेट है।\n    फ़ंक्शन एक ट्यूपल लौटाता है जिसमें पहला तत्व गायब ID है और दूसरा डुप्लिकेट ID है।\n\n    Args:\n    ids: सूचियों की एक सूची, प्रत्येक उप-सूची में टिकट ID की एक श्रृंखला होती है।\n\n    Returns:\n    दो पूर्णांकों का एक ट्यूपल: पहला गायब ID (m) है और दूसरा डुप्लिकेट ID (n) है।\n\n    Examples:\n    >>> FindErrorIds(new List<List<int>> { new List<int> {5, 6, 8, 11, 9}, new List<int> {10, 12, 9} })\n    (7, 9)\n    >>> FindErrorIds(new List<List<int>> { new List<int> {1, 2, 4}, new List<int> {3, 3} })\n    (5, 3)",
      "hu": "Megtalálja a hiányzó (hibás) és duplikált azonosítót egy azonosítósorozatból.\n    Az azonosítóknak folyamatosnak kellene lenniük, de egy hiba miatt egy azonosító hiányzik és egy duplikált.\n    A függvény egy olyan tuple-t ad vissza, amelynek első eleme a hiányzó azonosító, a második pedig a duplikált azonosító.\n\n    Args:\n    ids: Listák listája, minden allista egy sorozat jegyazonosítót tartalmaz.\n\n    Returns:\n    Egy tuple két egész számmal: az első a hiányzó azonosító (m), a második a duplikált azonosító (n).\n\n    Examples:\n    >>> FindErrorIds(new List<List<int>> { new List<int> {5, 6, 8, 11, 9}, new List<int> {10, 12, 9} })\n    (7, 9)\n    >>> FindErrorIds(new List<List<int>> { new List<int> {1, 2, 4}, new List<int> {3, 3} })\n    (5, 3)"
    },
    "docstring_bertscore": {
      "sq": "0.9843358095212077",
      "hy": "0.9703381279392981",
      "bn": "0.9761693200353393",
      "bg": "0.9804839691721792",
      "zh": "0.9563730217398781",
      "fr": "0.9911102972967836",
      "de": "0.9801234550306008",
      "ha": "0.9750214350633387",
      "hi": "0.9619448025582878",
      "hu": "0.9622769125553782"
    }
  },
  {
    "task_id": "C#/50",
    "prompt": {
      "en": "using System;\nusing System.Collections.Generic;\nusing System.Diagnostics;\n\nclass Program\n{\n\n\n    /* Counts the number of digit, lowercase, and uppercase characters in a given string of length 8.\n        >>> CountCharacters(\"1n2s0e1s\")\n        (4, 4, 0)\n    */\n\n    static (int, int, int) CountCharacters(string s)",
      "sq": "using System;\nusing System.Collections.Generic;\nusing System.Diagnostics;\n\nclass Program\n{\n\n\n    /* Numëron numrin e karaktereve numër, të vogla dhe të mëdha në një varg të dhënë me gjatësi 8.\n        >>> CountCharacters(\"1n2s0e1s\")\n        (4, 4, 0)\n    */\n\n    static (int, int, int) CountCharacters(string s)",
      "hy": "using System;\nusing System.Collections.Generic;\nusing System.Diagnostics;\n\nclass Program\n{\n\n\n    /* Հաշվում է թվանշանների, փոքրատառերի և մեծատառերի քանակը տրված 8 երկարությամբ տողում:\n        >>> CountCharacters(\"1n2s0e1s\")\n        (4, 4, 0)\n    */\n\n    static (int, int, int) CountCharacters(string s)",
      "bn": "using System;\nusing System.Collections.Generic;\nusing System.Diagnostics;\n\nclass Program\n{\n\n\n    /* একটি প্রদত্ত ৮ অক্ষরের স্ট্রিং-এ সংখ্যা, ছোট হাতের, এবং বড় হাতের অক্ষরের সংখ্যা গণনা করে।\n        >>> CountCharacters(\"1n2s0e1s\")\n        (4, 4, 0)\n    */\n\n    static (int, int, int) CountCharacters(string s)",
      "bg": "using System;\nusing System.Collections.Generic;\nusing System.Diagnostics;\n\nclass Program\n{\n\n\n    /* Брои броя на цифрите, малките и главните букви в даден низ с дължина 8.\n        >>> CountCharacters(\"1n2s0e1s\")\n        (4, 4, 0)\n    */\n\n    static (int, int, int) CountCharacters(string s)",
      "zh": "using System;\nusing System.Collections.Generic;\nusing System.Diagnostics;\n\nclass Program\n{\n\n\n    /* 计算给定长度为8的字符串中数字、小写字母和大写字母的数量。\n        >>> CountCharacters(\"1n2s0e1s\")\n        (4, 4, 0)\n    */\n\n    static (int, int, int) CountCharacters(string s)",
      "fr": "using System;\nusing System.Collections.Generic;\nusing System.Diagnostics;\n\nclass Program\n{\n\n\n    /* Compte le nombre de caractères numériques, minuscules et majuscules dans une chaîne donnée de longueur 8.\n        >>> CountCharacters(\"1n2s0e1s\")\n        (4, 4, 0)\n    */\n\n    static (int, int, int) CountCharacters(string s)",
      "de": "using System;\nusing System.Collections.Generic;\nusing System.Diagnostics;\n\nclass Program\n{\n\n\n    /* Zählt die Anzahl der Ziffern, Kleinbuchstaben und Großbuchstaben in einem gegebenen String der Länge 8.\n        >>> CountCharacters(\"1n2s0e1s\")\n        (4, 4, 0)\n    */\n\n    static (int, int, int) CountCharacters(string s)",
      "ha": "using System;\nusing System.Collections.Generic;\nusing System.Diagnostics;\n\nclass Program\n{\n\n\n    /* Yana ƙididdige yawan lambobi, ƙananan haruffa, da manyan haruffa a cikin wani baƙaƙe mai tsawon haruffa 8.\n        >>> CountCharacters(\"1n2s0e1s\")\n        (4, 4, 0)\n    */\n\n    static (int, int, int) CountCharacters(string s)",
      "hi": "using System;\nusing System.Collections.Generic;\nusing System.Diagnostics;\n\nclass Program\n{\n\n\n    /* एक दिए गए 8 अक्षरों की लंबाई वाले स्ट्रिंग में अंक, छोटे अक्षर, और बड़े अक्षर की संख्या गिनता है।\n        >>> CountCharacters(\"1n2s0e1s\")\n        (4, 4, 0)\n    */\n\n    static (int, int, int) CountCharacters(string s)",
      "hu": "using System;\nusing System.Collections.Generic;\nusing System.Diagnostics;\n\nclass Program\n{\n\n\n    /* Megszámolja a számjegy, kisbetűs és nagybetűs karakterek számát egy adott, 8 hosszúságú sztringben.\n        >>> CountCharacters(\"1n2s0e1s\")\n        (4, 4, 0)\n    */\n\n    static (int, int, int) CountCharacters(string s)"
    },
    "prompt_bertscore": {
      "sq": "0.9923221412514774",
      "hy": "0.9778580755348979",
      "bn": "0.9770244238256944",
      "bg": "0.986529483449357",
      "zh": "0.9734137207592423",
      "fr": "0.9923221412514774",
      "de": "0.9836118017823355",
      "ha": "0.9726329047313942",
      "hi": "0.9836118017823355",
      "hu": "1"
    },
    "canonical_solution": "    {\n        int digitCount = 0, lowerCaseCount = 0, upperCaseCount = 0;\n        foreach (char c in s)\n        {\n            if (char.IsDigit(c)) digitCount++;\n            else if (char.IsLower(c)) lowerCaseCount++;\n            else if (char.IsUpper(c)) upperCaseCount++;\n        }\n        return (digitCount, lowerCaseCount, upperCaseCount);\n    }",
    "instruction": {
      "en": "Write a C# function `static (int, int, int) CountCharacters(string s)` to solve the following problem:\nCounts the number of digit, lowercase, and uppercase characters in a given string of length 8.\n        >>> CountCharacters(\"1n2s0e1s\")\n        (4, 4, 0)",
      "sq": "Shkruani një funksion në C# `static (int, int, int) CountCharacters(string s)` për të zgjidhur problemin në vijim:  \nNumëron numrin e karaktereve shifrorë, me shkronja të vogla dhe me shkronja të mëdha në një varg të dhënë me gjatësi 8.",
      "hy": "Գրեք C# ֆունկցիա `static (int, int, int) CountCharacters(string s)` հետևյալ խնդիրը լուծելու համար: Հաշվում է թվանշանների, փոքրատառերի և մեծատառերի քանակը տրված 8 երկարությամբ տողում:",
      "bn": "একটি C# ফাংশন `static (int, int, int) CountCharacters(string s)` লিখুন নিম্নলিখিত সমস্যার সমাধানের জন্য: একটি প্রদত্ত ৮ অক্ষরের স্ট্রিং-এ সংখ্যা, ছোট হাতের এবং বড় হাতের অক্ষরের সংখ্যা গণনা করে।",
      "bg": "Напишете C# функция `static (int, int, int) CountCharacters(string s)` за решаване на следния проблем:  \nБрои броя на цифрите, малките и главните букви в даден низ с дължина 8.",
      "zh": "编写一个 C# 函数 `static (int, int, int) CountCharacters(string s)` 来解决以下问题：  \n计算给定长度为 8 的字符串中数字字符、小写字符和大写字符的数量。  \n        >>> CountCharacters(\"1n2s0e1s\")  \n        (4, 4, 0)",
      "fr": "Écrire une fonction C# `static (int, int, int) CountCharacters(string s)` pour résoudre le problème suivant :  \nCompte le nombre de caractères numériques, minuscules et majuscules dans une chaîne donnée de longueur 8.  \n        >>> CountCharacters(\"1n2s0e1s\")  \n        (4, 4, 0)",
      "de": "Schreiben Sie eine C#-Funktion `static (int, int, int) CountCharacters(string s)`, um das folgende Problem zu lösen:\nZählt die Anzahl der Ziffern, Kleinbuchstaben und Großbuchstaben in einem gegebenen String der Länge 8.\n        >>> CountCharacters(\"1n2s0e1s\")\n        (4, 4, 0)",
      "ha": "Rubuta aikin C# `static (int, int, int) CountCharacters(string s)` don warware matsalar mai zuwa:  \nYana ƙidayar adadin lambobi, ƙananan haruffa, da manyan haruffa a cikin kirtani mai tsawon haruffa 8.  \n        >>> CountCharacters(\"1n2s0e1s\")  \n        (4, 4, 0)",
      "hi": "C# फ़ंक्शन `static (int, int, int) CountCharacters(string s)` लिखें ताकि निम्नलिखित समस्या का समाधान किया जा सके:\nएक दिए गए 8 लंबाई के स्ट्रिंग में अंक, लोअरकेस, और अपरकेस वर्णों की संख्या गिनें।\n        >>> CountCharacters(\"1n2s0e1s\")\n        (4, 4, 0)",
      "hu": "Írj egy C# függvényt `static (int, int, int) CountCharacters(string s)` a következő probléma megoldására:  \nMegszámolja a számjegy, kisbetűs és nagybetűs karakterek számát egy adott, 8 hosszúságú karakterláncban.  \n        >>> CountCharacters(\"1n2s0e1s\")  \n        (4, 4, 0)"
    },
    "instruction_bertscore": {
      "sq": "0.8782663915270532",
      "hy": "0.8887789044433247",
      "bn": "0.8751747096462452",
      "bg": "0.8995704930449502",
      "zh": "0.9781695279723606",
      "fr": "0.9861022294997509",
      "de": "0.8840846726483272",
      "ha": "0.9605821981443885",
      "hi": "0.9718675818732667",
      "hu": "0.9967341192750244"
    },
    "level": "easy",
    "test": "    static void Main()\n    {\n        Debug.Assert(CountCharacters(\"yLAX2022\") == (4, 1, 3));\n        Debug.Assert(CountCharacters(\"MBKKOKOK\") == (0, 0, 8));\n        Debug.Assert(CountCharacters(\"1n2s0e1s\") == (4, 4, 0));\n        Debug.Assert(CountCharacters(\"1234ABCD\") == (4, 0, 4));\n\n\n    }\n}",
    "entry_point": "CountCharacters",
    "signature": "static (int, int, int) CountCharacters(string s)",
    "docstring": {
      "en": "Counts the number of digit, lowercase, and uppercase characters in a given string of length 8.\n        >>> CountCharacters(\"1n2s0e1s\")\n        (4, 4, 0)",
      "sq": "Numëron numrin e karaktereve numerike, me shkronja të vogla dhe me shkronja të mëdha në një varg të dhënë me gjatësi 8.\n        >>> CountCharacters(\"1n2s0e1s\")\n        (4, 4, 0)",
      "hy": "Հաշվում է թվանշանների, փոքրատառերի և մեծատառերի քանակը տրված 8 երկարությամբ տողում:\n        >>> CountCharacters(\"1n2s0e1s\")\n        (4, 4, 0)",
      "bn": "একটি প্রদত্ত ৮ অক্ষরের স্ট্রিং-এ সংখ্যা, ছোট হাতের, এবং বড় হাতের অক্ষরের সংখ্যা গণনা করে।\n        >>> CountCharacters(\"1n2s0e1s\")  \n        (4, 4, 0)  ",
      "bg": "Брои броя на цифрите, малките и главните букви в даден низ с дължина 8.\n        >>> CountCharacters(\"1n2s0e1s\")\n        (4, 4, 0)",
      "zh": "计算给定长度为8的字符串中数字、小写和大写字符的数量。\n        >>> CountCharacters(\"1n2s0e1s\")\n        (4, 4, 0)",
      "fr": "Compte le nombre de caractères numériques, minuscules et majuscules dans une chaîne donnée de longueur 8.\n        >>> CountCharacters(\"1n2s0e1s\")\n        (4, 4, 0)",
      "de": "Zählt die Anzahl der Ziffern, Kleinbuchstaben und Großbuchstaben in einem gegebenen String der Länge 8.\n        >>> CountCharacters(\"1n2s0e1s\")\n        (4, 4, 0)",
      "ha": "Yana ƙidaya adadin lambobi, ƙananan haruffa, da manyan haruffa a cikin wata takamaiman igiyar rubutu mai tsawon haruffa 8.\n        >>> CountCharacters(\"1n2s0e1s\")\n        (4, 4, 0)",
      "hi": "अक्षर, लोअरकेस, और अपरकेस वर्णों की संख्या गिनता है एक दिए गए 8 लंबाई के स्ट्रिंग में।\n        >>> CountCharacters(\"1n2s0e1s\")\n        (4, 4, 0)",
      "hu": "Számolja meg a számjegy, kisbetűs és nagybetűs karakterek számát egy adott, 8 hosszúságú sztringben.\n        >>> CountCharacters(\"1n2s0e1s\")\n        (4, 4, 0)"
    },
    "docstring_bertscore": {
      "sq": "0.9598611698612318",
      "hy": "0.9737511937766206",
      "bn": "1",
      "bg": "0.9778576782741358",
      "zh": "0.9715980404462023",
      "fr": "0.9754838465903879",
      "de": "0.9704076485726603",
      "ha": "0.9559344458585531",
      "hi": "0.9945773905977475",
      "hu": "0.9900220014390935"
    }
  }
]