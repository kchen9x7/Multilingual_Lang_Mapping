[
  {
    "task_id": "Ruby/1",
    "prompt": {
      "en": "# Check if in given list of numbers, any two numbers are closer to each other than\n# given threshold.\n#>>> has_close_elements([1.0, 2.0, 3.0], 0.5)\n#False\n#>>> has_close_elements([1.0, 2.8, 3.0, 4.0, 5.0, 2.0], 0.3)\n#True\ndef has_close_elements(numbers, threshold)",
      "sq": "# Kontrolloni nëse në listën e dhënë të numrave, ndonjë dy numra janë më afër njëri-tjetrit se\n# pragu i dhënë.\n#>>> has_close_elements([1.0, 2.0, 3.0], 0.5)\n#False\n#>>> has_close_elements([1.0, 2.8, 3.0, 4.0, 5.0, 2.0], 0.3)\n#True\ndef has_close_elements(numbers, threshold)",
      "hy": "# Ստուգել, արդյոք տրված թվերի ցուցակում որևէ երկու թիվ իրար ավելի մոտ են, քան\n# տրված շեմը։\n#>>> has_close_elements([1.0, 2.0, 3.0], 0.5)\n#False\n#>>> has_close_elements([1.0, 2.8, 3.0, 4.0, 5.0, 2.0], 0.3)\n#True\ndef has_close_elements(numbers, threshold)",
      "bn": "# প্রদত্ত সংখ্যার তালিকায়, কোনো দুটি সংখ্যা পরস্পরের চেয়ে নির্দিষ্ট সীমার চেয়ে কাছাকাছি আছে কিনা তা পরীক্ষা করুন।\n#>>> has_close_elements([1.0, 2.0, 3.0], 0.5)\n#False\n#>>> has_close_elements([1.0, 2.8, 3.0, 4.0, 5.0, 2.0], 0.3)\n#True\ndef has_close_elements(numbers, threshold)",
      "bg": "# Проверете дали в даден списък от числа, някои две числа са по-близо едно до друго от\n# даден праг.\n#>>> has_close_elements([1.0, 2.0, 3.0], 0.5)\n#False\n#>>> has_close_elements([1.0, 2.8, 3.0, 4.0, 5.0, 2.0], 0.3)\n#True\ndef has_close_elements(numbers, threshold)",
      "zh": "# 检查在给定的数字列表中，是否有任意两个数字之间的距离小于给定的阈值。\n#>>> has_close_elements([1.0, 2.0, 3.0], 0.5)\n#False\n#>>> has_close_elements([1.0, 2.8, 3.0, 4.0, 5.0, 2.0], 0.3)\n#True\ndef has_close_elements(numbers, threshold)",
      "fr": "# Vérifier si, dans une liste donnée de nombres, deux nombres quelconques sont plus proches l'un de l'autre que\n# le seuil donné.\n#>>> has_close_elements([1.0, 2.0, 3.0], 0.5)\n#False\n#>>> has_close_elements([1.0, 2.8, 3.0, 4.0, 5.0, 2.0], 0.3)\n#True\ndef has_close_elements(numbers, threshold)",
      "de": "# Überprüfen, ob in der gegebenen Liste von Zahlen zwei Zahlen näher beieinander liegen als\n# der gegebene Schwellenwert.\n#>>> has_close_elements([1.0, 2.0, 3.0], 0.5)\n#False\n#>>> has_close_elements([1.0, 2.8, 3.0, 4.0, 5.0, 2.0], 0.3)\n#True\ndef has_close_elements(numbers, threshold)",
      "ha": "# Duba idan a cikin jerin lambobi da aka bayar, akwai kowanne lambobi biyu da ke kusa da juna fiye da\n# ƙayyadadden tazara.\n#>>> has_close_elements([1.0, 2.0, 3.0], 0.5)\n#False\n#>>> has_close_elements([1.0, 2.8, 3.0, 4.0, 5.0, 2.0], 0.3)\n#True\ndef has_close_elements(numbers, threshold)",
      "hi": "# जाँच करें कि दिए गए संख्याओं की सूची में, क्या कोई दो संख्याएँ दी गई सीमा से अधिक निकट हैं।\n#>>> has_close_elements([1.0, 2.0, 3.0], 0.5)\n#False\n#>>> has_close_elements([1.0, 2.8, 3.0, 4.0, 5.0, 2.0], 0.3)\n#True\ndef has_close_elements(numbers, threshold)",
      "hu": "# Ellenőrzi, hogy a megadott számok listájában van-e bármely két szám, amelyek közelebb vannak egymáshoz, mint a megadott küszöbérték.\n#>>> has_close_elements([1.0, 2.0, 3.0], 0.5)\n#False\n#>>> has_close_elements([1.0, 2.8, 3.0, 4.0, 5.0, 2.0], 0.3)\n#True\ndef has_close_elements(numbers, threshold)"
    },
    "prompt_bertscore": {
      "sq": "0.9874191489260122",
      "hy": "0.9826778417307095",
      "bn": "0.9675394258705166",
      "bg": "0.9868870181352198",
      "zh": "0.9694015856927186",
      "fr": "0.980210256507113",
      "de": "0.9794598309275633",
      "ha": "0.9657471839424387",
      "hi": "0.9773557393012606",
      "hu": "0.9666195685759439"
    },
    "canonical_solution": "numbers.each_with_index do |elem, idx|\n      numbers.each_with_index do |elem2, idx2|\n        next if idx == idx2\n  \n        distance = (elem - elem2).abs\n        return true if distance < threshold\n      end\n    end\n  \n    false\n  end",
    "instruction": {
      "en": "Write a ruby function `def has_close_elements(numbers, threshold)` to solve the following problem:\nCheck if in given list of numbers, any two numbers are closer to each other than\ngiven threshold.\n>>> has_close_elements([1.0, 2.0, 3.0], 0.5)\nFalse\n>>> has_close_elements([1.0, 2.8, 3.0, 4.0, 5.0, 2.0], 0.3)\nTrue",
      "sq": "Shkruani një funksion ruby `def has_close_elements(numbers, threshold)` për të zgjidhur problemin e mëposhtëm:\nKontrolloni nëse në listën e dhënë të numrave, ndonjë dy numra janë më afër njëri-tjetrit sesa pragu i dhënë.\n>>> has_close_elements([1.0, 2.0, 3.0], 0.5)\nFalse\n>>> has_close_elements([1.0, 2.8, 3.0, 4.0, 5.0, 2.0], 0.3)\nTrue",
      "hy": "Գրեք ruby ֆունկցիա `def has_close_elements(numbers, threshold)` հետևյալ խնդիրը լուծելու համար:\nՍտուգեք, արդյոք տրված թվերի ցանկում որևէ երկու թիվ իրարից ավելի մոտ են, քան տրված շեմը:\n>>> has_close_elements([1.0, 2.0, 3.0], 0.5)\nFalse\n>>> has_close_elements([1.0, 2.8, 3.0, 4.0, 5.0, 2.0], 0.3)\nTrue",
      "bn": "রুবি ফাংশন `def has_close_elements(numbers, threshold)` লিখুন নিম্নলিখিত সমস্যার সমাধানের জন্য:\nযাচাই করুন যে প্রদত্ত সংখ্যার তালিকায়, কোনো দুটি সংখ্যা একে অপরের থেকে প্রদত্ত সীমার চেয়ে কাছাকাছি আছে কিনা।\n>>> has_close_elements([1.0, 2.0, 3.0], 0.5)\nFalse\n>>> has_close_elements([1.0, 2.8, 3.0, 4.0, 5.0, 2.0], 0.3)\nTrue",
      "bg": "Напишете функция на Ruby `def has_close_elements(numbers, threshold)` за решаване на следния проблем:  \nПроверете дали в дадения списък от числа, някои две числа са по-близо едно до друго от дадения праг.  \n>>> has_close_elements([1.0, 2.0, 3.0], 0.5)  \nFalse  \n>>> has_close_elements([1.0, 2.8, 3.0, 4.0, 5.0, 2.0], 0.3)  \nTrue",
      "zh": "编写一个 ruby 函数 `def has_close_elements(numbers, threshold)` 来解决以下问题：  \n检查在给定的数字列表中，是否有任意两个数字之间的距离小于给定的阈值。  \n>>> has_close_elements([1.0, 2.0, 3.0], 0.5)  \nFalse  \n>>> has_close_elements([1.0, 2.8, 3.0, 4.0, 5.0, 2.0], 0.3)  \nTrue  ",
      "fr": "Écrire une fonction ruby `def has_close_elements(numbers, threshold)` pour résoudre le problème suivant :  \nVérifiez si, dans une liste de nombres donnée, deux nombres quelconques sont plus proches l'un de l'autre que le seuil donné.\n>>> has_close_elements([1.0, 2.0, 3.0], 0.5)\nFalse\n>>> has_close_elements([1.0, 2.8, 3.0, 4.0, 5.0, 2.0], 0.3)\nTrue",
      "de": "Schreiben Sie eine Ruby-Funktion `def has_close_elements(numbers, threshold)`, um das folgende Problem zu lösen:\nÜberprüfen Sie, ob in der gegebenen Liste von Zahlen zwei beliebige Zahlen näher beieinander liegen als der angegebene Schwellenwert.\n>>> has_close_elements([1.0, 2.0, 3.0], 0.5)\nFalse\n>>> has_close_elements([1.0, 2.8, 3.0, 4.0, 5.0, 2.0], 0.3)\nTrue",
      "ha": "Rubuta aikin ruby `def has_close_elements(numbers, threshold)` don warware matsalar mai zuwa:\nDuba idan a cikin jerin lambobin da aka bayar, kowanne lambobi biyu sun fi kusa da juna fiye da\nmatsakaicin da aka bayar.\n>>> has_close_elements([1.0, 2.0, 3.0], 0.5)\nFalse\n>>> has_close_elements([1.0, 2.8, 3.0, 4.0, 5.0, 2.0], 0.3)\nTrue",
      "hi": "रूबी फ़ंक्शन `def has_close_elements(numbers, threshold)` लिखें ताकि निम्नलिखित समस्या का समाधान किया जा सके:\nजांचें कि दिए गए संख्याओं की सूची में, क्या कोई दो संख्याएं एक-दूसरे के जितनी करीब हैं उससे अधिक निकट हैं\nदिया गया सीमा।\n>>> has_close_elements([1.0, 2.0, 3.0], 0.5)\nFalse\n>>> has_close_elements([1.0, 2.8, 3.0, 4.0, 5.0, 2.0], 0.3)\nTrue",
      "hu": "Írj egy ruby függvényt `def has_close_elements(numbers, threshold)` a következő probléma megoldására:\nEllenőrizd, hogy a megadott számok listájában bármely két szám közelebb van-e egymáshoz, mint a megadott küszöbérték.\n>>> has_close_elements([1.0, 2.0, 3.0], 0.5)\nFalse\n>>> has_close_elements([1.0, 2.8, 3.0, 4.0, 5.0, 2.0], 0.3)\nTrue"
    },
    "instruction_bertscore": {
      "sq": "0.9903799333857183",
      "hy": "0.9834960002701921",
      "bn": "0.9849334883377416",
      "bg": "0.9885092324571317",
      "zh": "0.9622149398764953",
      "fr": "0.9825239031854074",
      "de": "0.9848186799775035",
      "ha": "0.9903799333857183",
      "hi": "0.9751354489020527",
      "hu": "0.9876489642768697"
    },
    "level": "easy",
    "test": "  # Test cases\n  def check(has_close_elements)\n    raise 'Test failed' unless has_close_elements.call([1.0, 2.0, 3.9, 4.0, 5.0, 2.2], 0.3)\n    raise 'Test failed' if has_close_elements.call([1.0, 2.0, 3.9, 4.0, 5.0, 2.2], 0.05)\n    raise 'Test failed' unless has_close_elements.call([1.0, 2.0, 5.9, 4.0, 5.0], 0.95)\n    raise 'Test failed' if has_close_elements.call([1.0, 2.0, 5.9, 4.0, 5.0], 0.8)\n    raise 'Test failed' unless has_close_elements.call([1.0, 2.0, 3.0, 4.0, 5.0, 2.0], 0.1)\n    raise 'Test failed' unless has_close_elements.call([1.1, 2.2, 3.1, 4.1, 5.1], 1.0)\n    raise 'Test failed' if has_close_elements.call([1.1, 2.2, 3.1, 4.1, 5.1], 0.5)\n  \n    puts 'All tests passed!'\n  end\n  \n  check(method(:has_close_elements))",
    "entry_point": "has_close_elements",
    "signature": "def has_close_elements(numbers, threshold)",
    "docstring": {
      "en": "Check if in given list of numbers, any two numbers are closer to each other than\ngiven threshold.\n>>> has_close_elements([1.0, 2.0, 3.0], 0.5)\nFalse\n>>> has_close_elements([1.0, 2.8, 3.0, 4.0, 5.0, 2.0], 0.3)\nTrue",
      "sq": "Kontrolloni nëse në listën e dhënë të numrave, ndonjë dy numra janë më afër njëri-tjetrit sesa pragu i dhënë.\n>>> has_close_elements([1.0, 2.0, 3.0], 0.5)\nFalse\n>>> has_close_elements([1.0, 2.8, 3.0, 4.0, 5.0, 2.0], 0.3)\nTrue",
      "hy": "Ստուգել, արդյոք տրված թվերի ցանկում որևէ երկու թիվ ավելի մոտ են միմյանց, քան տրված շեմը:\n>>> has_close_elements([1.0, 2.0, 3.0], 0.5)\nFalse\n>>> has_close_elements([1.0, 2.8, 3.0, 4.0, 5.0, 2.0], 0.3)\nTrue",
      "bn": "প্রদত্ত সংখ্যার তালিকায়, কোনো দুটি সংখ্যা প্রদত্ত সীমার চেয়ে কাছাকাছি আছে কিনা তা পরীক্ষা করুন।\n>>> has_close_elements([1.0, 2.0, 3.0], 0.5)\nFalse\n>>> has_close_elements([1.0, 2.8, 3.0, 4.0, 5.0, 2.0], 0.3)\nTrue",
      "bg": "Проверете дали в даден списък от числа, някои две числа са по-близо едно до друго от дадения праг.\n>>> has_close_elements([1.0, 2.0, 3.0], 0.5)\nFalse\n>>> has_close_elements([1.0, 2.8, 3.0, 4.0, 5.0, 2.0], 0.3)\nTrue",
      "zh": "检查给定数字列表中，是否有任意两个数字之间的距离小于给定的阈值。\n>>> has_close_elements([1.0, 2.0, 3.0], 0.5)\nFalse\n>>> has_close_elements([1.0, 2.8, 3.0, 4.0, 5.0, 2.0], 0.3)\nTrue",
      "fr": "Vérifiez si, dans une liste donnée de nombres, deux nombres quelconques sont plus proches l'un de l'autre que le seuil donné.\n>>> has_close_elements([1.0, 2.0, 3.0], 0.5)\nFalse\n>>> has_close_elements([1.0, 2.8, 3.0, 4.0, 5.0, 2.0], 0.3)\nTrue",
      "de": "Überprüfen Sie, ob in der gegebenen Liste von Zahlen zwei Zahlen näher beieinander liegen als der angegebene Schwellenwert.\n>>> has_close_elements([1.0, 2.0, 3.0], 0.5)\nFalse\n>>> has_close_elements([1.0, 2.8, 3.0, 4.0, 5.0, 2.0], 0.3)\nTrue",
      "ha": "Duba idan a cikin jerin lambobi da aka bayar, ko akwai wasu lambobi biyu da suke kusa da juna fiye da ƙayyadadden tazara.\n\n>>> has_close_elements([1.0, 2.0, 3.0], 0.5)\nFalse\n>>> has_close_elements([1.0, 2.8, 3.0, 4.0, 5.0, 2.0], 0.3)\nTrue",
      "hi": "दिए गए संख्याओं की सूची में जाँच करें कि क्या कोई दो संख्याएँ दी गई सीमा से अधिक निकट हैं।\n>>> has_close_elements([1.0, 2.0, 3.0], 0.5)\nFalse\n>>> has_close_elements([1.0, 2.8, 3.0, 4.0, 5.0, 2.0], 0.3)\nTrue",
      "hu": "Ellenőrizze, hogy a megadott számok listájában bármely két szám közelebb van-e egymáshoz, mint a megadott küszöbérték.\n>>> has_close_elements([1.0, 2.0, 3.0], 0.5)\nFalse\n>>> has_close_elements([1.0, 2.8, 3.0, 4.0, 5.0, 2.0], 0.3)\nTrue"
    },
    "docstring_bertscore": {
      "sq": "0.9859016128149057",
      "hy": "0.9668348839089858",
      "bn": "0.9435238210211123",
      "bg": "0.9856437905803225",
      "zh": "0.9452038367839054",
      "fr": "0.9776661985868182",
      "de": "0.9677543439427962",
      "ha": "0.9586534971445397",
      "hi": "0.9528856681400487",
      "hu": "0.9722892741722038"
    }
  },
  {
    "task_id": "Ruby/2",
    "prompt": {
      "en": "# Counts the number of times the digit '1' appears in all numbers from 1 to n.\n# The function takes a single argument, n, which is a positive integer, and \n# returns the total count of the digit '1' appearing in all numbers from 1 to n.\n#\n# Example:\n# >>> count_ones_in_range(15)\n# 8\n# >>> count_ones_in_range(20)\n# 12\n\ndef count_ones_in_range(n)",
      "sq": "# Numëron sa herë shfaqet shifra '1' në të gjitha numrat nga 1 deri në n.\n# Funksioni merr një argument të vetëm, n, i cili është një numër i plotë pozitiv, dhe\n# kthen numrin total të shifrës '1' që shfaqet në të gjitha numrat nga 1 deri në n.\n#\n# Shembull:\n# >>> count_ones_in_range(15)\n# 8\n# >>> count_ones_in_range(20)\n# 12\n\ndef count_ones_in_range(n)",
      "hy": "# Հաշվում է, թե քանի անգամ է թվանշան '1'-ը հանդիպում 1-ից n բոլոր թվերում:\n# Ֆունկցիան ընդունում է մեկ արգումենտ, n, որը դրական ամբողջ թիվ է, և\n# վերադարձնում է թվանշան '1'-ի ընդհանուր քանակը, որը հանդիպում է 1-ից n բոլոր թվերում:\n#\n# Օրինակ:\n# >>> count_ones_in_range(15)\n# 8\n# >>> count_ones_in_range(20)\n# 12\n\ndef count_ones_in_range(n)",
      "bn": "# সংখ্যা 1 থেকে n পর্যন্ত সমস্ত সংখ্যায় অঙ্ক '1' কতবার উপস্থিত হয়েছে তা গণনা করে।\n# ফাংশনটি একটি একক আর্গুমেন্ট গ্রহণ করে, n, যা একটি ধনাত্মক পূর্ণসংখ্যা,\n# এবং 1 থেকে n পর্যন্ত সমস্ত সংখ্যায় অঙ্ক '1' এর মোট গণনা প্রদান করে।\n#\n# উদাহরণ:\n# >>> count_ones_in_range(15)\n# 8\n# >>> count_ones_in_range(20)\n# 12\n\ndef count_ones_in_range(n)",
      "bg": "# Брои колко пъти цифрата '1' се появява във всички числа от 1 до n.\n# Функцията приема един аргумент, n, който е положително цяло число, и\n# връща общия брой на появяванията на цифрата '1' във всички числа от 1 до n.\n#\n# Пример:\n# >>> count_ones_in_range(15)\n# 8\n# >>> count_ones_in_range(20)\n# 12\n\ndef count_ones_in_range(n)",
      "zh": "# 计算从 1 到 n 的所有数字中数字 '1' 出现的次数。\n# 该函数接受一个参数 n，这是一个正整数，并返回从 1 到 n 的所有数字中数字 '1' 出现的总次数。\n#\n# 示例:\n# >>> count_ones_in_range(15)\n# 8\n# >>> count_ones_in_range(20)\n# 12\n\ndef count_ones_in_range(n)",
      "fr": "# Compte le nombre de fois que le chiffre '1' apparaît dans tous les nombres de 1 à n.\n# La fonction prend un seul argument, n, qui est un entier positif, et\n# renvoie le nombre total de fois que le chiffre '1' apparaît dans tous les nombres de 1 à n.\n#\n# Exemple:\n# >>> count_ones_in_range(15)\n# 8\n# >>> count_ones_in_range(20)\n# 12\n\ndef count_ones_in_range(n)",
      "de": "# Zählt, wie oft die Ziffer '1' in allen Zahlen von 1 bis n vorkommt.\n# Die Funktion nimmt ein einzelnes Argument, n, das eine positive ganze Zahl ist,\n# und gibt die Gesamtanzahl der Ziffer '1' zurück, die in allen Zahlen von 1 bis n vorkommt.\n#\n# Beispiel:\n# >>> count_ones_in_range(15)\n# 8\n# >>> count_ones_in_range(20)\n# 12\n\ndef count_ones_in_range(n)",
      "ha": "# Yana ƙididdige adadin lokutan da lamba '1' ta bayyana a duk lambobi daga 1 zuwa n.\n# Aikin yana karɓar hujja guda ɗaya, n, wanda yake lamba mai kyau, kuma\n# yana mayar da jimlar ƙididdigar lamba '1' da ta bayyana a duk lambobi daga 1 zuwa n.\n#\n# Misali:\n# >>> count_ones_in_range(15)\n# 8\n# >>> count_ones_in_range(20)\n# 12\n\ndef count_ones_in_range(n)",
      "hi": "# 1 से n तक सभी संख्याओं में अंक '1' कितनी बार आता है, इसकी गणना करता है।\n# फ़ंक्शन एकल तर्क n लेता है, जो एक धनात्मक पूर्णांक है, और \n# 1 से n तक सभी संख्याओं में अंक '1' के आने की कुल गणना को लौटाता है।\n#\n# उदाहरण:\n# >>> count_ones_in_range(15)\n# 8\n# >>> count_ones_in_range(20)\n# 12\n\ndef count_ones_in_range(n)",
      "hu": "# Megszámolja, hogy az '1' számjegy hányszor fordul elő az összes 1-től n-ig terjedő számban.\n# A függvény egyetlen argumentumot vesz fel, n-t, amely egy pozitív egész szám, és\n# visszaadja az '1' számjegy összes előfordulásának számát az összes 1-től n-ig terjedő számban.\n#\n# Példa:\n# >>> count_ones_in_range(15)\n# 8\n# >>> count_ones_in_range(20)\n# 12\n\ndef count_ones_in_range(n)"
    },
    "prompt_bertscore": {
      "sq": "0.9857727016976141",
      "hy": "0.979879735553071",
      "bn": "0.9738771254381967",
      "bg": "0.9793428376331337",
      "zh": "0.9628630708098121",
      "fr": "0.9864037504181619",
      "de": "0.9791013030897953",
      "ha": "0.9963005091532252",
      "hi": "0.9827839103541821",
      "hu": "0.9837019799753254"
    },
    "canonical_solution": "  count = 0\n  (1..n).each do |num|\n    count += num.to_s.count('1')\n  end\n  count\nend\n",
    "instruction": {
      "en": "Write a ruby function `def count_ones_in_range(n)` to solve the following problem:\nCounts the number of times the digit '1' appears in all numbers from 1 to n.\nThe function takes a single argument, n, which is a positive integer, and\nreturns the total count of the digit '1' appearing in all numbers from 1 to n.\n\nExample:\n>>> count_ones_in_range(15)\n8\n>>> count_ones_in_range(20)\n12",
      "sq": "Shkruani një funksion ruby `def count_ones_in_range(n)` për të zgjidhur problemin e mëposhtëm: Numëron sa herë shfaqet shifra '1' në të gjitha numrat nga 1 deri në n. Funksioni merr një argument të vetëm, n, i cili është një numër i plotë pozitiv, dhe kthen numrin total të shifrës '1' që shfaqet në të gjithë numrat nga 1 deri në n.\n\nShembull:\n>>> count_ones_in_range(15)\n8\n>>> count_ones_in_range(20)\n12",
      "hy": "Գրեք ruby ֆունկցիա `def count_ones_in_range(n)` հետևյալ խնդիրը լուծելու համար:\nՀաշվում է, թե քանի անգամ է թվանշան '1'-ը հայտնվում 1-ից n բոլոր թվերում:\nՖունկցիան ընդունում է մեկ արգումենտ, n, որը դրական ամբողջ թիվ է, և\nվերադարձնում է թվանշան '1'-ի ընդհանուր քանակը, որը հայտնվում է 1-ից n բոլոր թվերում:\n\nՕրինակ:\n>>> count_ones_in_range(15)\n8\n>>> count_ones_in_range(20)\n12",
      "bn": "রুবি ফাংশন `def count_ones_in_range(n)` লিখুন নিম্নলিখিত সমস্যার সমাধানের জন্য:\n১ থেকে n পর্যন্ত সব সংখ্যায় অঙ্ক '1' কতবার উপস্থিত হয়েছে তা গণনা করে।\nফাংশনটি একটি একক আর্গুমেন্ট গ্রহণ করে, n, যা একটি ধনাত্মক পূর্ণসংখ্যা, এবং\n১ থেকে n পর্যন্ত সব সংখ্যায় অঙ্ক '1' এর উপস্থিতির মোট সংখ্যা ফেরত দেয়।\n\nউদাহরণ:\n>>> count_ones_in_range(15)\n8\n>>> count_ones_in_range(20)\n12",
      "bg": "Напишете Ruby функция `def count_ones_in_range(n)` за решаване на следния проблем:\nБрои колко пъти цифрата '1' се появява във всички числа от 1 до n.\nФункцията приема един аргумент, n, който е положително цяло число, и\nвръща общия брой на появяванията на цифрата '1' във всички числа от 1 до n.\n\nПример:\n>>> count_ones_in_range(15)\n8\n>>> count_ones_in_range(20)\n12",
      "zh": "编写一个 ruby 函数 `def count_ones_in_range(n)` 来解决以下问题：  \n计算数字 '1' 在从 1 到 n 的所有数字中出现的次数。  \n该函数接受一个参数 n，它是一个正整数，并返回数字 '1' 在从 1 到 n 的所有数字中出现的总次数。\n\n示例：  \n>>> count_ones_in_range(15)  \n8  \n>>> count_ones_in_range(20)  \n12  ",
      "fr": "Écrire une fonction ruby `def count_ones_in_range(n)` pour résoudre le problème suivant :\nCompte le nombre de fois que le chiffre '1' apparaît dans tous les nombres de 1 à n.\nLa fonction prend un seul argument, n, qui est un entier positif, et\nrenvoie le nombre total de fois que le chiffre '1' apparaît dans tous les nombres de 1 à n.\n\nExemple :\n>>> count_ones_in_range(15)\n8\n>>> count_ones_in_range(20)\n12",
      "de": "Schreiben Sie eine Ruby-Funktion `def count_ones_in_range(n)`, um das folgende Problem zu lösen:\nZählt, wie oft die Ziffer '1' in allen Zahlen von 1 bis n erscheint.\nDie Funktion nimmt ein einziges Argument, n, das eine positive ganze Zahl ist, und\ngibt die Gesamtanzahl der Ziffer '1' zurück, die in allen Zahlen von 1 bis n erscheint.\n\nBeispiel:\n>>> count_ones_in_range(15)\n8\n>>> count_ones_in_range(20)\n12",
      "ha": "Rubuta aikin ruby `def count_ones_in_range(n)` don warware matsalar mai zuwa:  \nYa ƙirga sau nawa lamba '1' ta bayyana a duk lambobi daga 1 zuwa n.  \nAikin yana ɗaukar hujja guda, n, wanda yake lamba mai kyau, kuma  \nyana mayar da jimlar ƙididdigar lamba '1' da ta bayyana a duk lambobi daga 1 zuwa n.\n\nMisali:\n>>> count_ones_in_range(15)\n8\n>>> count_ones_in_range(20)\n12",
      "hi": "रूबी फ़ंक्शन `def count_ones_in_range(n)` लिखें ताकि निम्नलिखित समस्या का समाधान किया जा सके:\n1 से n तक सभी संख्याओं में अंक '1' कितनी बार आता है, इसकी गणना करता है।\nयह फ़ंक्शन एक एकल तर्क लेता है, n, जो एक धनात्मक पूर्णांक है, और\n1 से n तक सभी संख्याओं में अंक '1' की कुल गणना लौटाता है।\n\nउदाहरण:\n>>> count_ones_in_range(15)\n8\n>>> count_ones_in_range(20)\n12",
      "hu": "Írj egy ruby függvényt `def count_ones_in_range(n)` a következő probléma megoldására:\nMegszámolja, hogy az '1' számjegy hányszor jelenik meg az összes 1-től n-ig terjedő számban.\nA függvény egyetlen argumentumot vesz, n, amely egy pozitív egész szám, és\nvisszaadja az '1' számjegy összes előfordulásának számát az 1-től n-ig terjedő összes számban.\n\nPélda:\n>>> count_ones_in_range(15)\n8\n>>> count_ones_in_range(20)\n12"
    },
    "instruction_bertscore": {
      "sq": "0.9875170737038624",
      "hy": "0.986899531849225",
      "bn": "0.9762201694128843",
      "bg": "0.978320288431566",
      "zh": "0.9714315881868951",
      "fr": "0.9860970651098441",
      "de": "0.9842247751382092",
      "ha": "0.9881103826520137",
      "hi": "0.9866679288249383",
      "hu": "0.9837995074924135"
    },
    "level": "easy",
    "test": "raise 'Test failed' unless count_ones_in_range(15) == 8\nraise 'Test failed' unless count_ones_in_range(20) == 12\nraise 'Test failed' unless count_ones_in_range(100) == 21\nraise 'Test failed' unless count_ones_in_range(5) == 1\nraise 'Test failed' unless count_ones_in_range(55) == 16\nraise 'Test failed' unless count_ones_in_range(0) == 0\n\nputs 'All tests passed!'",
    "entry_point": "count_ones_in_range",
    "signature": "def count_ones_in_range(n)",
    "docstring": {
      "en": "Counts the number of times the digit '1' appears in all numbers from 1 to n.\nThe function takes a single argument, n, which is a positive integer, and\nreturns the total count of the digit '1' appearing in all numbers from 1 to n.\n\nExample:\n>>> count_ones_in_range(15)\n8\n>>> count_ones_in_range(20)\n12",
      "sq": "Numëron sa herë shfaqet shifra '1' në të gjitha numrat nga 1 deri në n.\nFunksioni merr një argument të vetëm, n, i cili është një numër i plotë pozitiv, dhe\nkthen numrin total të shifrës '1' që shfaqet në të gjithë numrat nga 1 deri në n.\n\nShembull:\n>>> count_ones_in_range(15)\n8\n>>> count_ones_in_range(20)\n12",
      "hy": "Հաշվում է, թե քանի անգամ է թվանշան '1'-ը հայտնվում 1-ից մինչև n բոլոր թվերի մեջ:\nՖունկցիան ընդունում է մեկ արգումենտ՝ n, որը դրական ամբողջ թիվ է, և\nվերադարձնում է թվանշան '1'-ի ընդհանուր քանակը, որը հայտնվում է 1-ից մինչև n բոլոր թվերի մեջ:\n\nՕրինակ:\n>>> count_ones_in_range(15)\n8\n>>> count_ones_in_range(20)\n12",
      "bn": "সংখ্যা 1 থেকে n পর্যন্ত সমস্ত সংখ্যায় '1' অঙ্কটি কতবার উপস্থিত হয়েছে তা গণনা করে।\nফাংশনটি একটি একক আর্গুমেন্ট n গ্রহণ করে, যা একটি ধনাত্মক পূর্ণসংখ্যা, এবং\n1 থেকে n পর্যন্ত সমস্ত সংখ্যায় '1' অঙ্কটি উপস্থিত হওয়ার মোট সংখ্যা ফেরত দেয়।\n\nউদাহরণ:\n>>> count_ones_in_range(15)\n8\n>>> count_ones_in_range(20)\n12",
      "bg": "Брои колко пъти цифрата '1' се появява във всички числа от 1 до n. \nФункцията приема един аргумент, n, който е положително цяло число, и \nвръща общия брой на появяванията на цифрата '1' във всички числа от 1 до n.\n\nПример:\n>>> count_ones_in_range(15)\n8\n>>> count_ones_in_range(20)\n12",
      "zh": "计算数字 '1' 在从 1 到 n 的所有数字中出现的次数。  \n该函数接受一个参数 n，它是一个正整数，返回数字 '1' 在从 1 到 n 的所有数字中出现的总次数。\n\n示例：\n>>> count_ones_in_range(15)\n8\n>>> count_ones_in_range(20)\n12",
      "fr": "Compte le nombre de fois que le chiffre '1' apparaît dans tous les nombres de 1 à n. La fonction prend un seul argument, n, qui est un entier positif, et retourne le nombre total de fois que le chiffre '1' apparaît dans tous les nombres de 1 à n.\n\nExemple :\n>>> count_ones_in_range(15)\n8\n>>> count_ones_in_range(20)\n12",
      "de": "Zählt die Anzahl der Male, die die Ziffer '1' in allen Zahlen von 1 bis n erscheint. Die Funktion nimmt ein einzelnes Argument, n, das eine positive ganze Zahl ist, und gibt die Gesamtanzahl der Ziffer '1' zurück, die in allen Zahlen von 1 bis n erscheint.\n\nBeispiel:\n>>> count_ones_in_range(15)\n8\n>>> count_ones_in_range(20)\n12",
      "ha": "Yana ƙididdige adadin lokutan da lamba '1' ta bayyana a duk lambobi daga 1 zuwa n. \n\nAikin yana ɗaukar hujja guda, n, wanda yake lamba mai kyau, kuma yana dawowa da jimillar ƙididdigar lamba '1' da ta bayyana a duk lambobi daga 1 zuwa n.\n\nMisali:\n>>> count_ones_in_range(15)\n8\n>>> count_ones_in_range(20)\n12",
      "hi": "सभी संख्याओं में अंक '1' कितनी बार आता है, इसकी गणना 1 से n तक करता है। \nयह फ़ंक्शन एकल तर्क n लेता है, जो एक धनात्मक पूर्णांक है, और 1 से n तक सभी संख्याओं में अंक '1' की कुल गणना लौटाता है।\n\nउदाहरण:\n>>> count_ones_in_range(15)\n8\n>>> count_ones_in_range(20)\n12",
      "hu": "Számolja meg, hogy hányszor jelenik meg az '1' számjegy az összes 1-től n-ig terjedő számban.\nA függvény egyetlen argumentumot, n-t fogad el, amely egy pozitív egész szám, és visszaadja az '1' számjegy összes előfordulásának számát az összes 1-től n-ig terjedő számban.\n\nPélda:\n>>> count_ones_in_range(15)\n8\n>>> count_ones_in_range(20)\n12"
    },
    "docstring_bertscore": {
      "sq": "0.9825968005352472",
      "hy": "0.9817291830308869",
      "bn": "0.9709338204520217",
      "bg": "0.9725915896121389",
      "zh": "0.9630237627880693",
      "fr": "0.9855665233620998",
      "de": "0.9881395813180258",
      "ha": "0.9861715515027322",
      "hi": "0.9788565904603603",
      "hu": "0.9702167647764858"
    }
  },
  {
    "task_id": "Ruby/3",
    "prompt": {
      "en": "# Calculates the total count of the digit '1' in the binary representation of all numbers in a given range [l, r].\n# The function takes two arguments, l and r, where l <= r and both are non-negative integers. It returns the sum \n# of all '1's in the binary representation of each number in the range [l, r].\n#\n# Examples:\n# >>> sum_of_binary_ones(2, 3)\n# 3\n# >>> sum_of_binary_ones(5, 5)\n# 2\n# >>> sum_of_binary_ones(0, 4)\n# 5\n\n\ndef sum_of_binary_ones(l, r)",
      "sq": "# Llogarit numrin total të shifrës '1' në përfaqësimin binar të të gjitha numrave në një interval të dhënë [l, r].\n# Funksioni merr dy argumente, l dhe r, ku l <= r dhe të dy janë numra të plotë jo-negativë. Ai kthen shumën\n# e të gjitha '1'-ve në përfaqësimin binar të secilit numër në intervalin [l, r].\n#\n# Shembuj:\n# >>> sum_of_binary_ones(2, 3)\n# 3\n# >>> sum_of_binary_ones(5, 5)\n# 2\n# >>> sum_of_binary_ones(0, 4)\n# 5\n\n\ndef sum_of_binary_ones(l, r)",
      "hy": "# Հաշվում է '1' թվանշանի ընդհանուր քանակը բոլոր թվերի երկբայական ներկայացման մեջ տրված [l, r] միջակայքում:\n# Ֆունկցիան ընդունում է երկու արգումենտ՝ l և r, որտեղ l <= r և երկուսն էլ ոչ բացասական ամբողջ թվեր են: Այն վերադարձնում է\n# բոլոր '1'-երի գումարը յուրաքանչյուր թվի երկբայական ներկայացման մեջ [l, r] միջակայքում:\n#\n# Օրինակներ:\n# >>> sum_of_binary_ones(2, 3)\n# 3\n# >>> sum_of_binary_ones(5, 5)\n# 2\n# >>> sum_of_binary_ones(0, 4)\n# 5\n\n\ndef sum_of_binary_ones(l, r)",
      "bn": "# প্রদত্ত সীমার [l, r] সকল সংখ্যার বাইনারি রূপে '1' ডিজিটের মোট সংখ্যা গণনা করে।\n# ফাংশনটি দুটি আর্গুমেন্ট গ্রহণ করে, l এবং r, যেখানে l <= r এবং উভয়ই অ-ঋণাত্মক পূর্ণসংখ্যা। এটি সীমার [l, r] প্রতিটি সংখ্যার \n# বাইনারি রূপে সকল '1' এর যোগফল প্রদান করে।\n#\n# উদাহরণ:\n# >>> sum_of_binary_ones(2, 3)\n# 3\n# >>> sum_of_binary_ones(5, 5)\n# 2\n# >>> sum_of_binary_ones(0, 4)\n# 5\n\n\ndef sum_of_binary_ones(l, r)",
      "bg": "# Изчислява общия брой на цифрата '1' в двоичното представяне на всички числа в даден интервал [l, r].\n# Функцията приема два аргумента, l и r, където l <= r и двете са неотрицателни цели числа. Тя връща сумата\n# на всички '1' в двоичното представяне на всяко число в интервала [l, r].\n#\n# Примери:\n# >>> sum_of_binary_ones(2, 3)\n# 3\n# >>> sum_of_binary_ones(5, 5)\n# 2\n# >>> sum_of_binary_ones(0, 4)\n# 5\n\n\ndef sum_of_binary_ones(l, r)",
      "zh": "# 计算给定范围 [l, r] 内所有数字的二进制表示中数字 '1' 的总数。\n# 该函数接受两个参数，l 和 r，其中 l <= r 且两者都是非负整数。它返回范围 [l, r] 内每个数字的二进制表示中所有 '1' 的和。\n#\n# 示例:\n# >>> sum_of_binary_ones(2, 3)\n# 3\n# >>> sum_of_binary_ones(5, 5)\n# 2\n# >>> sum_of_binary_ones(0, 4)\n# 5\n\n\ndef sum_of_binary_ones(l, r)",
      "fr": "# Calcule le nombre total du chiffre '1' dans la représentation binaire de tous les nombres dans une plage donnée [l, r].\n# La fonction prend deux arguments, l et r, où l <= r et les deux sont des entiers non négatifs. Elle renvoie la somme \n# de tous les '1' dans la représentation binaire de chaque nombre dans la plage [l, r].\n#\n# Exemples:\n# >>> sum_of_binary_ones(2, 3)\n# 3\n# >>> sum_of_binary_ones(5, 5)\n# 2\n# >>> sum_of_binary_ones(0, 4)\n# 5\n\n\ndef sum_of_binary_ones(l, r)",
      "de": "# Berechnet die Gesamtanzahl des Ziffer '1' in der Binärdarstellung aller Zahlen in einem gegebenen Bereich [l, r].\n# Die Funktion nimmt zwei Argumente, l und r, wobei l <= r und beide nicht-negative ganze Zahlen sind. Sie gibt die Summe\n# aller '1's in der Binärdarstellung jeder Zahl im Bereich [l, r] zurück.\n#\n# Beispiele:\n# >>> sum_of_binary_ones(2, 3)\n# 3\n# >>> sum_of_binary_ones(5, 5)\n# 2\n# >>> sum_of_binary_ones(0, 4)\n# 5\n\n\ndef sum_of_binary_ones(l, r)",
      "ha": "# Lissafi yawan adadin lamba '1' a cikin wakilcin binary na duk lambobi a cikin kewayon da aka bayar [l, r].\n# Aikin yana ɗaukar hujjoji guda biyu, l da r, inda l <= r kuma duka ba su da lambobi marasa kyau. Yana mayar da jumlar \n# duk '1's a cikin wakilcin binary na kowane lamba a cikin kewayon [l, r].\n#\n# Misalai:\n# >>> sum_of_binary_ones(2, 3)\n# 3\n# >>> sum_of_binary_ones(5, 5)\n# 2\n# >>> sum_of_binary_ones(0, 4)\n# 5\n\n\ndef sum_of_binary_ones(l, r)",
      "hi": "# दिए गए रेंज [l, r] में सभी संख्याओं के बाइनरी प्रतिनिधित्व में अंक '1' की कुल गिनती की गणना करता है।\n# फ़ंक्शन दो तर्क लेता है, l और r, जहाँ l <= r और दोनों गैर-ऋणात्मक पूर्णांक हैं। यह रेंज [l, r] में प्रत्येक संख्या के \n# बाइनरी प्रतिनिधित्व में सभी '1's का योग लौटाता है।\n#\n# उदाहरण:\n# >>> sum_of_binary_ones(2, 3)\n# 3\n# >>> sum_of_binary_ones(5, 5)\n# 2\n# >>> sum_of_binary_ones(0, 4)\n# 5\n\n\ndef sum_of_binary_ones(l, r)",
      "hu": "# Kiszámítja az '1' számjegy teljes számát az összes szám bináris ábrázolásában egy adott [l, r] tartományban.\n# A függvény két argumentumot vesz, l és r, ahol l <= r és mindkettő nemnegatív egész szám. Visszaadja az \n# összes '1' összegét az egyes számok bináris ábrázolásában a [l, r] tartományban.\n#\n# Példák:\n# >>> sum_of_binary_ones(2, 3)\n# 3\n# >>> sum_of_binary_ones(5, 5)\n# 2\n# >>> sum_of_binary_ones(0, 4)\n# 5\n\n\ndef sum_of_binary_ones(l, r)"
    },
    "prompt_bertscore": {
      "sq": "0.9842964807057628",
      "hy": "0.9594216008280017",
      "bn": "0.9701599564875097",
      "bg": "0.9851915092027059",
      "zh": "0.9608022806065751",
      "fr": "0.995342912086256",
      "de": "0.992325716598336",
      "ha": "0.9730345353618467",
      "hi": "0.9896444050847462",
      "hu": "0.969505866642762"
    },
    "canonical_solution": "  total_count = 0\n  (l..r).each do |num|\n    total_count += num.to_s(2).count('1')\n  end\n  total_count\nend",
    "instruction": {
      "en": "Write a ruby function `def sum_of_binary_ones(l, r)` to solve the following problem:\nCalculates the total count of the digit '1' in the binary representation of all numbers in a given range [l, r].\nThe function takes two arguments, l and r, where l <= r and both are non-negative integers. It returns the sum\nof all '1's in the binary representation of each number in the range [l, r].\n\nExamples:\n>>> sum_of_binary_ones(2, 3)\n3\n>>> sum_of_binary_ones(5, 5)\n2\n>>> sum_of_binary_ones(0, 4)\n5",
      "sq": "Shkruani një funksion ruby `def sum_of_binary_ones(l, r)` për të zgjidhur problemin në vijim:\nLlogarit numrin total të shifrës '1' në paraqitjen binare të të gjitha numrave në një interval të dhënë [l, r].\nFunksioni merr dy argumente, l dhe r, ku l <= r dhe të dy janë numra të plotë jo-negativë. Ai kthen shumën\ne të gjitha '1'-ve në paraqitjen binare të secilit numër në intervalin [l, r].\n\nShembuj:\n>>> sum_of_binary_ones(2, 3)\n3\n>>> sum_of_binary_ones(5, 5)\n2\n>>> sum_of_binary_ones(0, 4)\n5",
      "hy": "Գրեք ruby ֆունկցիա `def sum_of_binary_ones(l, r)` հետևյալ խնդիրը լուծելու համար:\nՀաշվում է թվանշան '1'-ի ընդհանուր քանակը բոլոր թվերի բինար ներկայացման մեջ տրված [l, r] միջակայքում:\nՖունկցիան ընդունում է երկու արգումենտ՝ l և r, որտեղ l <= r և երկուսն էլ ոչ բացասական ամբողջ թվեր են: Այն վերադարձնում է\nբոլոր '1'-երի գումարը [l, r] միջակայքում գտնվող յուրաքանչյուր թվի բինար ներկայացման մեջ:\n\nՕրինակներ:\n>>> sum_of_binary_ones(2, 3)\n3\n>>> sum_of_binary_ones(5, 5)\n2\n>>> sum_of_binary_ones(0, 4)\n5",
      "bn": "একটি রুবি ফাংশন `def sum_of_binary_ones(l, r)` লিখুন নিম্নলিখিত সমস্যার সমাধানের জন্য:\nপ্রদত্ত পরিসর [l, r] এর সমস্ত সংখ্যার বাইনারি উপস্থাপনার মধ্যে ডিজিট '1' এর মোট গণনা নির্ণয় করে।\nফাংশনটি দুটি আর্গুমেন্ট গ্রহণ করে, l এবং r, যেখানে l <= r এবং উভয়ই অ-ঋণাত্মক পূর্ণসংখ্যা। এটি পরিসর [l, r] এর প্রতিটি সংখ্যার বাইনারি উপস্থাপনার মধ্যে সমস্ত '1' এর যোগফল প্রদান করে।\n\nউদাহরণসমূহ:\n>>> sum_of_binary_ones(2, 3)\n3\n>>> sum_of_binary_ones(5, 5)\n2\n>>> sum_of_binary_ones(0, 4)\n5",
      "bg": "Напишете функция на Ruby `def sum_of_binary_ones(l, r)` за решаване на следния проблем:\nИзчислява общия брой на цифрата '1' в двоичното представяне на всички числа в даден диапазон [l, r].\nФункцията приема два аргумента, l и r, където l <= r и двете са неотрицателни цели числа. Тя връща сумата\nна всички '1' в двоичното представяне на всяко число в диапазона [l, r].\n\nПримери:\n>>> sum_of_binary_ones(2, 3)\n3\n>>> sum_of_binary_ones(5, 5)\n2\n>>> sum_of_binary_ones(0, 4)\n5",
      "zh": "编写一个 ruby 函数 `def sum_of_binary_ones(l, r)` 来解决以下问题：\n计算给定范围 [l, r] 内所有数字的二进制表示中数字 '1' 的总数。\n该函数接受两个参数，l 和 r，其中 l <= r 且两者都是非负整数。它返回范围 [l, r] 内每个数字的二进制表示中所有 '1' 的总和。\n\n示例：\n>>> sum_of_binary_ones(2, 3)\n3\n>>> sum_of_binary_ones(5, 5)\n2\n>>> sum_of_binary_ones(0, 4)\n5",
      "fr": "Écrire une fonction ruby `def sum_of_binary_ones(l, r)` pour résoudre le problème suivant :\nCalcule le nombre total du chiffre '1' dans la représentation binaire de tous les nombres dans un intervalle donné [l, r].\nLa fonction prend deux arguments, l et r, où l <= r et les deux sont des entiers non négatifs. Elle renvoie la somme\nde tous les '1' dans la représentation binaire de chaque nombre dans l'intervalle [l, r].\n\nExemples :\n>>> sum_of_binary_ones(2, 3)\n3\n>>> sum_of_binary_ones(5, 5)\n2\n>>> sum_of_binary_ones(0, 4)\n5",
      "de": "Schreiben Sie eine Ruby-Funktion `def sum_of_binary_ones(l, r)`, um das folgende Problem zu lösen:\nBerechnet die Gesamtanzahl des Zeichens '1' in der Binärdarstellung aller Zahlen in einem gegebenen Bereich [l, r].\nDie Funktion nimmt zwei Argumente, l und r, wobei l <= r und beide nicht-negative ganze Zahlen sind. Sie gibt die Summe\naller '1's in der Binärdarstellung jeder Zahl im Bereich [l, r] zurück.\n\nBeispiele:\n>>> sum_of_binary_ones(2, 3)\n3\n>>> sum_of_binary_ones(5, 5)\n2\n>>> sum_of_binary_ones(0, 4)\n5",
      "ha": "Rubuta aikin ruby `def sum_of_binary_ones(l, r)` don warware matsalar mai zuwa:\nYana ƙididdige jimillar adadin lambar '1' a cikin wakilcin binary na duk lambobin a cikin kewayon da aka bayar [l, r].\nAikin yana ɗaukar hujjoji guda biyu, l da r, inda l <= r kuma dukansu lambobi ne marasa kyau. Yana mayar da jumlar\ndukkan '1's a cikin wakilcin binary na kowace lamba a cikin kewayon [l, r].\n\nMisalai:\n>>> sum_of_binary_ones(2, 3)\n3\n>>> sum_of_binary_ones(5, 5)\n2\n>>> sum_of_binary_ones(0, 4)\n5",
      "hi": "`def sum_of_binary_ones(l, r)` नामक एक रूबी फ़ंक्शन लिखें ताकि निम्नलिखित समस्या का समाधान किया जा सके:\nदिए गए श्रेणी [l, r] में सभी संख्याओं के बाइनरी प्रतिनिधित्व में अंक '1' की कुल गिनती की गणना करता है।\nफ़ंक्शन दो तर्क लेता है, l और r, जहाँ l <= r और दोनों गैर-ऋणात्मक पूर्णांक हैं। यह श्रेणी [l, r] में प्रत्येक संख्या के बाइनरी प्रतिनिधित्व में सभी '1's का योग लौटाता है।\n\nउदाहरण:\n>>> sum_of_binary_ones(2, 3)\n3\n>>> sum_of_binary_ones(5, 5)\n2\n>>> sum_of_binary_ones(0, 4)\n5",
      "hu": "Írj egy ruby függvényt `def sum_of_binary_ones(l, r)` a következő probléma megoldására:\nKiszámítja az '1' számjegy teljes számát az összes szám bináris ábrázolásában egy adott [l, r] tartományban.\nA függvény két argumentumot vesz, l és r, ahol l <= r és mindkettő nem negatív egész szám. Visszaadja az összes '1' összegét az egyes számok bináris ábrázolásában a [l, r] tartományban.\n\nPéldák:\n>>> sum_of_binary_ones(2, 3)\n3\n>>> sum_of_binary_ones(5, 5)\n2\n>>> sum_of_binary_ones(0, 4)\n5"
    },
    "instruction_bertscore": {
      "sq": "0.98533432444667",
      "hy": "0.9863568736482377",
      "bn": "0.9824833825876763",
      "bg": "0.9914068524556686",
      "zh": "0.9687931808356087",
      "fr": "0.9951188570164486",
      "de": "0.990150118034861",
      "ha": "0.9720598560821085",
      "hi": "0.9906268309493447",
      "hu": "0.9863385996531825"
    },
    "level": "easy",
    "test": "raise 'Test failed' unless sum_of_binary_ones(2, 3) == 3\nraise 'Test failed' unless sum_of_binary_ones(5, 5) == 2\nraise 'Test failed' unless sum_of_binary_ones(0, 4) == 5\nraise 'Test failed' unless sum_of_binary_ones(10, 15) == 17\nraise 'Test failed' unless sum_of_binary_ones(0, 0) == 0\n\n\n\nputs 'All tests passed!'",
    "entry_point": "sum_of_binary_ones",
    "signature": "def sum_of_binary_ones(l, r)",
    "docstring": {
      "en": "Calculates the total count of the digit '1' in the binary representation of all numbers in a given range [l, r].\nThe function takes two arguments, l and r, where l <= r and both are non-negative integers. It returns the sum\nof all '1's in the binary representation of each number in the range [l, r].\n\nExamples:\n>>> sum_of_binary_ones(2, 3)\n3\n>>> sum_of_binary_ones(5, 5)\n2\n>>> sum_of_binary_ones(0, 4)\n5",
      "sq": "Llogarit numrin total të shifrës '1' në përfaqësimin binar të të gjitha numrave në një interval të dhënë [l, r].\nFunksioni merr dy argumente, l dhe r, ku l <= r dhe të dy janë numra të plotë jo-negativë. Ai kthen shumën\ne të gjitha '1'-ve në përfaqësimin binar të secilit numër në intervalin [l, r].\n\nShembuj:\n>>> sum_of_binary_ones(2, 3)\n3\n>>> sum_of_binary_ones(5, 5)\n2\n>>> sum_of_binary_ones(0, 4)\n5",
      "hy": "Հաշվում է թվային '1'-երի ընդհանուր քանակը բոլոր թվերի բինար ներկայացման մեջ տրված [l, r] միջակայքում:\nՖունկցիան ընդունում է երկու արգումենտ՝ l և r, որտեղ l <= r և երկուսն էլ ոչ բացասական ամբողջ թվեր են: Այն վերադարձնում է\nբոլոր '1'-երի գումարը յուրաքանչյուր թվի բինար ներկայացման մեջ [l, r] միջակայքում:\n\nՕրինակներ:\n>>> sum_of_binary_ones(2, 3)\n3\n>>> sum_of_binary_ones(5, 5)\n2\n>>> sum_of_binary_ones(0, 4)\n5",
      "bn": "বাইনারি উপস্থাপনার মধ্যে সংখ্যা '1' এর মোট গণনা নির্ধারণ করে একটি প্রদত্ত পরিসীমা [l, r] এর সমস্ত সংখ্যার জন্য। \nফাংশনটি দুটি আর্গুমেন্ট গ্রহণ করে, l এবং r, যেখানে l <= r এবং উভয়ই অ-ঋণাত্মক পূর্ণসংখ্যা। এটি পরিসীমা [l, r] এর প্রতিটি সংখ্যার বাইনারি উপস্থাপনার মধ্যে সমস্ত '1' এর যোগফল প্রদান করে।\n\nউদাহরণসমূহ:\n>>> sum_of_binary_ones(2, 3)\n3\n>>> sum_of_binary_ones(5, 5)\n2\n>>> sum_of_binary_ones(0, 4)\n5",
      "bg": "Изчислява общия брой на цифрата '1' в двоичното представяне на всички числа в даден диапазон [l, r]. Функцията приема два аргумента, l и r, където l <= r и двете са неотрицателни цели числа. Тя връща сумата на всички '1' в двоичното представяне на всяко число в диапазона [l, r].\n\nПримери:\n>>> sum_of_binary_ones(2, 3)\n3\n>>> sum_of_binary_ones(5, 5)\n2\n>>> sum_of_binary_ones(0, 4)\n5",
      "zh": "计算给定范围 [l, r] 内所有数字的二进制表示中数字 '1' 的总数。  \n该函数接受两个参数，l 和 r，其中 l <= r 且两者都是非负整数。它返回范围 [l, r] 内每个数字的二进制表示中所有 '1' 的总和。\n\n示例：\n>>> sum_of_binary_ones(2, 3)\n3\n>>> sum_of_binary_ones(5, 5)\n2\n>>> sum_of_binary_ones(0, 4)\n5",
      "fr": "Calcule le nombre total du chiffre '1' dans la représentation binaire de tous les nombres dans une plage donnée [l, r].  \nLa fonction prend deux arguments, l et r, où l <= r et les deux sont des entiers non négatifs. Elle renvoie la somme  \nde tous les '1' dans la représentation binaire de chaque nombre dans la plage [l, r].\n\nExemples :\n>>> sum_of_binary_ones(2, 3)\n3\n>>> sum_of_binary_ones(5, 5)\n2\n>>> sum_of_binary_ones(0, 4)\n5",
      "de": "Berechnet die Gesamtanzahl der Ziffer '1' in der Binärdarstellung aller Zahlen in einem gegebenen Bereich [l, r]. Die Funktion nimmt zwei Argumente, l und r, wobei l <= r und beide nicht-negative ganze Zahlen sind. Sie gibt die Summe aller '1's in der Binärdarstellung jeder Zahl im Bereich [l, r] zurück.\n\nBeispiele:\n>>> sum_of_binary_ones(2, 3)\n3\n>>> sum_of_binary_ones(5, 5)\n2\n>>> sum_of_binary_ones(0, 4)\n5",
      "ha": "Yana lissafin jimillar adadin lambar '1' a cikin wakilcin binary na duk lambobi a cikin kewayon da aka bayar [l, r]. \nAikin yana ɗaukar hujjoji guda biyu, l da r, inda l <= r kuma duka biyun lambobi ne marasa kyau. Yana mayar da jumlar duk '1's a cikin wakilcin binary na kowane lamba a cikin kewayon [l, r].\n\nMisalai:\n>>> sum_of_binary_ones(2, 3)\n3\n>>> sum_of_binary_ones(5, 5)\n2\n>>> sum_of_binary_ones(0, 4)\n5",
      "hi": "दिए गए रेंज [l, r] में सभी संख्याओं के बाइनरी प्रतिनिधित्व में अंक '1' की कुल गणना करता है। \nयह फ़ंक्शन दो आर्ग्युमेंट्स लेता है, l और r, जहाँ l <= r और दोनों गैर-ऋणात्मक पूर्णांक हैं। यह रेंज [l, r] में प्रत्येक संख्या के बाइनरी प्रतिनिधित्व में सभी '1's का योग लौटाता है।\n\nउदाहरण:\n>>> sum_of_binary_ones(2, 3)\n3\n>>> sum_of_binary_ones(5, 5)\n2\n>>> sum_of_binary_ones(0, 4)\n5",
      "hu": "Kiszámítja az összes '1' számjegy előfordulását a megadott tartomány [l, r] összes számának bináris ábrázolásában.\nA függvény két argumentumot vesz fel, l és r, ahol l <= r és mindkettő nem-negatív egész szám. Visszaadja az összes '1' összegét a tartomány [l, r] minden számának bináris ábrázolásában.\n\nPéldák:\n>>> sum_of_binary_ones(2, 3)\n3\n>>> sum_of_binary_ones(5, 5)\n2\n>>> sum_of_binary_ones(0, 4)\n5"
    },
    "docstring_bertscore": {
      "sq": "0.9822905124876914",
      "hy": "0.9705397377760485",
      "bn": "0.9788591726553137",
      "bg": "0.9953858162485596",
      "zh": "0.9633785166485976",
      "fr": "0.9936617045411767",
      "de": "0.9911371123982233",
      "ha": "0.9642872506418323",
      "hi": "0.9903253100309337",
      "hu": "0.9717595269459838"
    }
  },
  {
    "task_id": "Ruby/4",
    "prompt": {
      "en": "# Converts a positive integer into a unique binary power representation.\n# The function takes a single argument, n, which is a positive integer, and\n# returns a string representing n as a sum of powers of 2, with the powers \n# themselves also represented as sums of powers of 2 when applicable.\n#\n# The representation is formatted as '2(b)' where 'b' is the power. If 'b' itself \n# is a power of 2, it's represented in a similar nested format. Spaces are not \n# used in the representation.\n#\n# Example:\n# >>> binary_power_representation(137)\n# \"2(2(2)+2+2(0))+2(2+2(0))+2(0)\"\n# >>> binary_power_representation(1315)\n# \"2(2(2+2(0))+2)+2(2(2+2(0)))+2(2(2)+2(0))+2+2(0)\"\n\ndef binary_power_representation(n)",
      "sq": "# Konverton një numër të plotë pozitiv në një përfaqësim unik të fuqisë binare.\n# Funksioni merr një argument të vetëm, n, i cili është një numër i plotë pozitiv, dhe\n# kthen një varg që përfaqëson n si një shumë të fuqive të 2, me fuqitë\n# vetë të përfaqësuara gjithashtu si shuma të fuqive të 2 kur është e aplikueshme.\n#\n# Përfaqësimi është i formatuar si '2(b)' ku 'b' është fuqia. Nëse 'b' vetë\n# është një fuqi e 2, përfaqësohet në një format të ngjashëm të folezuar. Hapësirat nuk\n# përdoren në përfaqësim.\n#\n# Shembull:\n# >>> binary_power_representation(137)\n# \"2(2(2)+2+2(0))+2(2+2(0))+2(0)\"\n# >>> binary_power_representation(1315)\n# \"2(2(2+2(0))+2)+2(2(2+2(0)))+2(2(2)+2(0))+2+2(0)\"",
      "hy": "# Դարձնում է դրական ամբողջ թիվը եզակի երկբայական աստիճանային ներկայացման:\n# Ֆունկցիան ընդունում է մեկ արգումենտ, n, որը դրական ամբողջ թիվ է, և\n# վերադարձնում է տող, որը ներկայացնում է n-ը որպես 2-ի աստիճանների գումար, \n# որտեղ աստիճանները նույնպես ներկայացված են որպես 2-ի աստիճանների գումար, եթե կիրառելի է:\n#\n# Ներկայացումը ձևավորված է որպես '2(b)', որտեղ 'b'-ն աստիճանն է: Եթե 'b'-ն ինքնին\n# 2-ի աստիճան է, այն ներկայացվում է նման ներդրված ձևաչափով: Ներկայացման մեջ բացատներ չեն\n# օգտագործվում:\n#\n# Օրինակ:\n# >>> binary_power_representation(137)\n# \"2(2(2)+2+2(0))+2(2+2(0))+2(0)\"\n# >>> binary_power_representation(1315)\n# \"2(2(2+2(0))+2)+2(2(2+2(0)))+2(2(2)+2(0))+2+2(0)\"\n\ndef binary_power_representation(n)",
      "bn": "# একটি ধনাত্মক পূর্ণসংখ্যাকে একটি অনন্য বাইনারি শক্তি উপস্থাপনে রূপান্তর করে।\n# ফাংশনটি একটি একক আর্গুমেন্ট গ্রহণ করে, n, যা একটি ধনাত্মক পূর্ণসংখ্যা, এবং\n# একটি স্ট্রিং ফেরত দেয় যা n কে 2 এর শক্তির যোগফল হিসাবে উপস্থাপন করে, যেখানে শক্তিগুলিও প্রযোজ্য হলে 2 এর শক্তির যোগফল হিসাবে উপস্থাপিত হয়।\n#\n# উপস্থাপনাটি '2(b)' হিসাবে ফরম্যাট করা হয় যেখানে 'b' হল শক্তি। যদি 'b' নিজেই 2 এর শক্তি হয়, তবে এটি অনুরূপ নেস্টেড ফরম্যাটে উপস্থাপিত হয়। উপস্থাপনায় স্পেস ব্যবহার করা হয় না।\n#\n# উদাহরণ:\n# >>> binary_power_representation(137)\n# \"2(2(2)+2+2(0))+2(2+2(0))+2(0)\"\n# >>> binary_power_representation(1315)\n# \"2(2(2+2(0))+2)+2(2(2+2(0)))+2(2(2)+2(0))+2+2(0)\"",
      "bg": "# Преобразува положително цяло число в уникално представяне като степен на две.\n# Функцията приема един аргумент, n, който е положително цяло число, и\n# връща низ, представляващ n като сума от степени на 2, като самите степени\n# също са представени като суми от степени на 2, когато е приложимо.\n#\n# Представянето е форматирано като '2(b)', където 'b' е степента. Ако 'b' \n# сам по себе си е степен на 2, той се представя в подобен вложен формат. \n# Интервали не се използват в представянето.\n#\n# Пример:\n# >>> binary_power_representation(137)\n# \"2(2(2)+2+2(0))+2(2+2(0))+2(0)\"\n# >>> binary_power_representation(1315)\n# \"2(2(2+2(0))+2)+2(2(2+2(0)))+2(2(2)+2(0))+2+2(0)\" \n\ndef binary_power_representation(n)",
      "zh": "# 将正整数转换为唯一的二进制幂表示。\n# 该函数接受一个参数 n，它是一个正整数，并返回一个字符串，\n# 该字符串将 n 表示为 2 的幂的和，其中幂本身也在适用时表示为 2 的幂的和。\n#\n# 表示格式为 '2(b)'，其中 'b' 是幂。如果 'b' 本身是 2 的幂，\n# 则以类似的嵌套格式表示。不使用空格。\n#\n# 示例:\n# >>> binary_power_representation(137)\n# \"2(2(2)+2+2(0))+2(2+2(0))+2(0)\"\n# >>> binary_power_representation(1315)\n# \"2(2(2+2(0))+2)+2(2(2+2(0)))+2(2(2)+2(0))+2+2(0)\"\n\ndef binary_power_representation(n)",
      "fr": "# Convertit un entier positif en une représentation unique de puissance binaire.\n# La fonction prend un seul argument, n, qui est un entier positif, et\n# retourne une chaîne représentant n comme une somme de puissances de 2, avec les puissances\n# elles-mêmes également représentées comme des sommes de puissances de 2 lorsque c'est applicable.\n#\n# La représentation est formatée comme '2(b)' où 'b' est la puissance. Si 'b' lui-même\n# est une puissance de 2, il est représenté dans un format imbriqué similaire. Les espaces ne sont pas\n# utilisés dans la représentation.\n#\n# Exemple :\n# >>> binary_power_representation(137)\n# \"2(2(2)+2+2(0))+2(2+2(0))+2(0)\"\n# >>> binary_power_representation(1315)\n# \"2(2(2+2(0))+2)+2(2(2+2(0)))+2(2(2)+2(0))+2+2(0)\"\n\ndef binary_power_representation(n)",
      "de": "# Wandelt eine positive ganze Zahl in eine eindeutige Binärpotenzdarstellung um.\n# Die Funktion nimmt ein einzelnes Argument, n, das eine positive ganze Zahl ist, \n# und gibt einen String zurück, der n als Summe von Potenzen von 2 darstellt, wobei \n# die Potenzen selbst, wenn anwendbar, auch als Summen von Potenzen von 2 dargestellt werden.\n#\n# Die Darstellung ist formatiert als '2(b)', wobei 'b' die Potenz ist. Wenn 'b' selbst \n# eine Potenz von 2 ist, wird sie in einem ähnlichen verschachtelten Format dargestellt. \n# Leerzeichen werden in der Darstellung nicht verwendet.\n#\n# Beispiel:\n# >>> binary_power_representation(137)\n# \"2(2(2)+2+2(0))+2(2+2(0))+2(0)\"\n# >>> binary_power_representation(1315)\n# \"2(2(2+2(0))+2)+2(2(2+2(0)))+2(2(2)+2(0))+2+2(0)\" \n\ndef binary_power_representation(n)",
      "ha": "# Canza lamba mai kyau zuwa wakilci na musamman na ƙarfin binary.\n# Aikin yana ɗaukar hujja guda ɗaya, n, wanda yake lamba mai kyau, kuma\n# yana dawowa da igiya da ke wakiltar n a matsayin jumla na ƙarfi na 2, tare da ƙarfinsu\n# kansu kuma an wakilta su a matsayin jumla na ƙarfi na 2 idan ya dace.\n#\n# Wakilcin yana da tsari kamar '2(b)' inda 'b' shine ƙarfin. Idan 'b' kansa\n# shine ƙarfin 2, ana wakilta shi a cikin irin wannan tsarin da aka nannade. Ba a amfani da sarari\n# a cikin wakilcin.\n#\n# Misali:\n# >>> binary_power_representation(137)\n# \"2(2(2)+2+2(0))+2(2+2(0))+2(0)\"\n# >>> binary_power_representation(1315)\n# \"2(2(2+2(0))+2)+2(2(2+2(0)))+2(2(2)+2(0))+2+2(0)\"\n\ndef binary_power_representation(n)",
      "hi": "# एक धनात्मक पूर्णांक को एक अद्वितीय द्विआधारी शक्ति अभ्यावेदन में परिवर्तित करता है।\n# फ़ंक्शन एकल तर्क लेता है, n, जो एक धनात्मक पूर्णांक है, और\n# एक स्ट्रिंग लौटाता है जो n को 2 की शक्तियों के योग के रूप में दर्शाता है, जिसमें शक्तियों को भी \n# लागू होने पर 2 की शक्तियों के योग के रूप में दर्शाया जाता है।\n#\n# अभ्यावेदन को '2(b)' के रूप में स्वरूपित किया गया है जहाँ 'b' शक्ति है। यदि 'b' स्वयं \n# 2 की शक्ति है, तो इसे एक समान नेस्टेड प्रारूप में दर्शाया जाता है। अभ्यावेदन में \n# रिक्त स्थान का उपयोग नहीं किया जाता है।\n#\n# उदाहरण:\n# >>> binary_power_representation(137)\n# \"2(2(2)+2+2(0))+2(2+2(0))+2(0)\"\n# >>> binary_power_representation(1315)\n# \"2(2(2+2(0))+2)+2(2(2+2(0)))+2(2(2)+2(0))+2+2(0)\"\n\ndef binary_power_representation(n)",
      "hu": "# Egy pozitív egész számot egyedi bináris hatvány reprezentációvá alakít.\n# A függvény egyetlen argumentumot vesz fel, n-t, amely egy pozitív egész szám, és\n# visszaad egy karakterláncot, amely n-t a 2 hatványainak összegével reprezentálja, ahol a hatványok\n# maguk is a 2 hatványainak összegével vannak reprezentálva, ha alkalmazható.\n#\n# A reprezentáció formátuma '2(b)', ahol 'b' a hatvány. Ha 'b' maga is\n# 2 hatványa, hasonlóan beágyazott formátumban van reprezentálva. A reprezentációban\n# nem használnak szóközöket.\n#\n# Példa:\n# >>> binary_power_representation(137)\n# \"2(2(2)+2+2(0))+2(2+2(0))+2(0)\"\n# >>> binary_power_representation(1315)\n# \"2(2(2+2(0))+2)+2(2(2+2(0)))+2(2(2)+2(0))+2+2(0)\"\n\ndef binary_power_representation(n)"
    },
    "prompt_bertscore": {
      "sq": "0.9880654921858998",
      "hy": "0.9679891250531795",
      "bn": "0.9646457784796002",
      "bg": "0.9641297367496716",
      "zh": "0.9567486317904151",
      "fr": "0.9993774923858366",
      "de": "0.9724360620237885",
      "ha": "0.963756510263707",
      "hi": "0.9863987846586361",
      "hu": "0.9609846232963652"
    },
    "canonical_solution": "    return '2(0)' if n == 1  # Base case for 1\n  \n    terms = []\n    power = 0\n    while n > 0\n      if n % 2 == 1\n        # If the power is greater than 1, we need to represent it in binary power format\n        if power > 1\n          terms << \"2(#{binary_power_representation(power)})\"\n        else\n          terms << (power == 1 ? '2' : '2(0)')\n        end\n      end\n      n /= 2\n      power += 1\n    end\n    puts terms.reverse.join('+')\n    terms.reverse.join('+')\n    \n  end",
    "instruction": {
      "en": "Write a ruby function `def binary_power_representation(n)` to solve the following problem:\nConverts a positive integer into a unique binary power representation.\nThe function takes a single argument, n, which is a positive integer, and\nreturns a string representing n as a sum of powers of 2, with the powers\nthemselves also represented as sums of powers of 2 when applicable.\n\nThe representation is formatted as '2(b)' where 'b' is the power. If 'b' itself\nis a power of 2, it's represented in a similar nested format. Spaces are not\nused in the representation.\n\nExample:\n>>> binary_power_representation(137)\n\"2(2(2)+2+2(0))+2(2+2(0))+2(0)\"\n>>> binary_power_representation(1315)\n\"2(2(2+2(0))+2)+2(2(2+2(0)))+2(2(2)+2(0))+2+2(0)\"",
      "sq": "Shkruani një funksion ruby `def binary_power_representation(n)` për të zgjidhur problemin e mëposhtëm:\nKonverton një numër të plotë pozitiv në një përfaqësim unik të fuqisë binare.\nFunksioni merr një argument të vetëm, n, i cili është një numër i plotë pozitiv, dhe\nkthehet një varg që përfaqëson n si një shumë të fuqive të 2, me fuqitë\nvetë të përfaqësuara gjithashtu si shuma të fuqive të 2 kur është e zbatueshme.\n\nPërfaqësimi është i formatuar si '2(b)' ku 'b' është fuqia. Nëse 'b' vetë\nështë një fuqi e 2, ajo përfaqësohet në një format të ngjashëm të folezuar. Hapësirat nuk\npërdoren në përfaqësim.\n\nShembull:\n>>> binary_power_representation(137)\n\"2(2(2)+2+2(0))+2(2+2(0))+2(0)\"\n>>> binary_power_representation(1315)\n\"2(2(2+2(0))+2)+2(2(2+2(0)))+2(2(2)+2(0))+2+2(0)\"",
      "hy": "Գրեք ruby ֆունկցիա `def binary_power_representation(n)` հետևյալ խնդիրը լուծելու համար:\nՓոխակերպում է դրական ամբողջ թիվը եզակի երկբայական աստիճանային ներկայացման:\nՖունկցիան ընդունում է մեկ արգումենտ, n, որը դրական ամբողջ թիվ է, և\nվերադարձնում է n-ի տող, որը ներկայացնում է այն որպես 2-ի աստիճանների գումար, որտեղ\nինքնին աստիճանները նույնպես ներկայացված են որպես 2-ի աստիճանների գումար, երբ կիրառելի է:\n\nՆերկայացումը ձևաչափված է որպես '2(b)', որտեղ 'b' աստիճանն է: Եթե 'b'-ն ինքնին\n2-ի աստիճան է, այն ներկայացվում է նման բուն ձևաչափով: Ներկայացման մեջ բացատներ չեն\nօգտագործվում:\n\nՕրինակ:\n>>> binary_power_representation(137)\n\"2(2(2)+2+2(0))+2(2+2(0))+2(0)\"\n>>> binary_power_representation(1315)\n\"2(2(2+2(0))+2)+2(2(2+2(0)))+2(2(2)+2(0))+2+2(0)\"",
      "bn": "রুবি ফাংশন `def binary_power_representation(n)` লিখুন নিম্নলিখিত সমস্যার সমাধানের জন্য:\nএকটি ধনাত্মক পূর্ণসংখ্যাকে একটি অনন্য বাইনারি শক্তি উপস্থাপনায় রূপান্তর করে।\nফাংশনটি একটি একক আর্গুমেন্ট গ্রহণ করে, n, যা একটি ধনাত্মক পূর্ণসংখ্যা, এবং\nn কে 2 এর ঘাতের যোগফল হিসেবে উপস্থাপন করে এমন একটি স্ট্রিং রিটার্ন করে, যেখানে ঘাতগুলো\nযখন প্রযোজ্য, তখন নিজেরাও 2 এর ঘাতের যোগফল হিসেবে উপস্থাপিত হয়।\n\nউপস্থাপনাটি '2(b)' ফরম্যাটে বিন্যস্ত যেখানে 'b' হল ঘাত। যদি 'b' নিজেই\n2 এর ঘাত হয়, তবে এটি অনুরূপ নেস্টেড ফরম্যাটে উপস্থাপিত হয়। উপস্থাপনায়\nস্পেস ব্যবহার করা হয় না।\n\nউদাহরণ:\n>>> binary_power_representation(137)\n\"2(2(2)+2+2(0))+2(2+2(0))+2(0)\"\n>>> binary_power_representation(1315)\n\"2(2(2+2(0))+2)+2(2(2+2(0)))+2(2(2)+2(0))+2+2(0)\"",
      "bg": "Напишете Ruby функция `def binary_power_representation(n)`, за да решите следния проблем:\nПреобразува положително цяло число в уникално представяне като степен на двойката.\nФункцията приема един аргумент, n, който е положително цяло число, и\nвръща низ, представляващ n като сума от степени на 2, като самите степени\nсъщо са представени като суми от степени на 2, когато е приложимо.\n\nПредставянето е форматирано като '2(b)', където 'b' е степента. Ако 'b' сам по себе си\nе степен на 2, той е представен в подобен вложен формат. Интервали не се\nизползват в представянето.\n\nПример:\n>>> binary_power_representation(137)\n\"2(2(2)+2+2(0))+2(2+2(0))+2(0)\"\n>>> binary_power_representation(1315)\n\"2(2(2+2(0))+2)+2(2(2+2(0)))+2(2(2)+2(0))+2+2(0)\"",
      "zh": "编写一个 Ruby 函数 `def binary_power_representation(n)` 来解决以下问题：\n将一个正整数转换为唯一的二进制幂表示。\n该函数接受一个参数 n，它是一个正整数，并返回一个字符串，表示 n 作为 2 的幂的和，其中幂本身也在适用时表示为 2 的幂的和。\n\n表示格式为 '2(b)'，其中 'b' 是幂。如果 'b' 本身是 2 的幂，则以类似的嵌套格式表示。不在表示中使用空格。\n\n示例：\n>>> binary_power_representation(137)\n\"2(2(2)+2+2(0))+2(2+2(0))+2(0)\"\n>>> binary_power_representation(1315)\n\"2(2(2+2(0))+2)+2(2(2+2(0)))+2(2(2)+2(0))+2+2(0)\"",
      "fr": "Écrire une fonction ruby `def binary_power_representation(n)` pour résoudre le problème suivant :\nConvertit un entier positif en une représentation unique de puissance binaire.\nLa fonction prend un seul argument, n, qui est un entier positif, et\nretourne une chaîne représentant n comme une somme de puissances de 2, avec les puissances\nelles-mêmes également représentées comme des sommes de puissances de 2 lorsque c'est applicable.\n\nLa représentation est formatée comme '2(b)' où 'b' est la puissance. Si 'b' lui-même\nest une puissance de 2, il est représenté dans un format imbriqué similaire. Les espaces ne sont pas\nutilisés dans la représentation.\n\nExemple :\n>>> binary_power_representation(137)\n\"2(2(2)+2+2(0))+2(2+2(0))+2(0)\"\n>>> binary_power_representation(1315)\n\"2(2(2+2(0))+2)+2(2(2+2(0)))+2(2(2)+2(0))+2+2(0)\"",
      "de": "Schreiben Sie eine Ruby-Funktion `def binary_power_representation(n)`, um das folgende Problem zu lösen:\nKonvertiert eine positive ganze Zahl in eine eindeutige Binärpotenzdarstellung.\nDie Funktion nimmt ein einziges Argument, n, das eine positive ganze Zahl ist, und\ngibt einen String zurück, der n als Summe von Potenzen von 2 darstellt, wobei die Potenzen\nselbst auch als Summen von Potenzen von 2 dargestellt werden, wenn zutreffend.\n\nDie Darstellung ist formatiert als '2(b)', wobei 'b' die Potenz ist. Wenn 'b' selbst\neine Potenz von 2 ist, wird sie in einem ähnlichen verschachtelten Format dargestellt. Leerzeichen werden in der Darstellung nicht verwendet.\n\nBeispiel:\n>>> binary_power_representation(137)\n\"2(2(2)+2+2(0))+2(2+2(0))+2(0)\"\n>>> binary_power_representation(1315)\n\"2(2(2+2(0))+2)+2(2(2+2(0)))+2(2(2)+2(0))+2+2(0)\"",
      "ha": "Rubuta aikin ruby `def binary_power_representation(n)` don warware matsalar mai zuwa:\nYa canza lambar cikakken adadi mai kyau zuwa wakilcin ƙarfin binary na musamman.\nAikin yana ɗaukar hujja guda ɗaya, n, wanda yake cikakken adadi mai kyau, kuma\nyana mayar da kirtani wanda ke wakiltar n a matsayin jumlar ƙarfi na 2, tare da ƙarfafan\nda kansu kuma ana wakilta su a matsayin jumlar ƙarfi na 2 idan ya dace.\n\nWakilcin yana da tsari kamar '2(b)' inda 'b' shine ƙarfin. Idan 'b' da kansa\nshine ƙarfin 2, ana wakilta shi a cikin irin wannan tsarin haɗin gwiwa. Ba a amfani da sarari\na cikin wakilcin.\n\nMisali:\n>>> binary_power_representation(137)\n\"2(2(2)+2+2(0))+2(2+2(0))+2(0)\"\n>>> binary_power_representation(1315)\n\"2(2(2+2(0))+2)+2(2(2+2(0)))+2(2(2)+2(0))+2+2(0)\"",
      "hi": "रूबी फ़ंक्शन `def binary_power_representation(n)` लिखें ताकि निम्नलिखित समस्या का समाधान किया जा सके:\nएक धनात्मक पूर्णांक को एक अद्वितीय द्विआधारी शक्ति प्रतिनिधित्व में परिवर्तित करता है।\nफ़ंक्शन एकल तर्क लेता है, n, जो एक धनात्मक पूर्णांक है, और\nएक स्ट्रिंग लौटाता है जो n को 2 की शक्तियों के योग के रूप में दर्शाता है, जिसमें शक्तियों को भी लागू होने पर 2 की शक्तियों के योग के रूप में दर्शाया गया है।\n\nप्रतिनिधित्व को '2(b)' के रूप में स्वरूपित किया गया है जहाँ 'b' शक्ति है। यदि 'b' स्वयं\n2 की शक्ति है, तो इसे समान नेस्टेड प्रारूप में दर्शाया जाता है। प्रतिनिधित्व में रिक्त स्थान का उपयोग नहीं किया जाता है।\n\nउदाहरण:\n>>> binary_power_representation(137)\n\"2(2(2)+2+2(0))+2(2+2(0))+2(0)\"\n>>> binary_power_representation(1315)\n\"2(2(2+2(0))+2)+2(2(2+2(0)))+2(2(2)+2(0))+2+2(0)\"",
      "hu": "Írj egy ruby függvényt `def binary_power_representation(n)` a következő probléma megoldására:\nEgy pozitív egész szám átalakítása egyedi bináris hatvány reprezentációvá.\nA függvény egyetlen argumentumot vesz fel, n, amely egy pozitív egész szám, és\nvisszaad egy karakterláncot, amely n-t a 2 hatványainak összegeként ábrázolja, ahol a hatványok\nszintén a 2 hatványainak összegeként vannak ábrázolva, ha alkalmazható.\n\nA reprezentáció formátuma '2(b)', ahol 'b' a hatvány. Ha 'b' maga is\negy 2 hatványa, akkor hasonló beágyazott formátumban van ábrázolva. A reprezentációban nem\nhasználunk szóközöket.\n\nPélda:\n>>> binary_power_representation(137)\n\"2(2(2)+2+2(0))+2(2+2(0))+2(0)\"\n>>> binary_power_representation(1315)\n\"2(2(2+2(0))+2)+2(2(2+2(0)))+2(2(2)+2(0))+2+2(0)\""
    },
    "instruction_bertscore": {
      "sq": "0.9995407665590473",
      "hy": "0.9568733716697051",
      "bn": "0.9817613611526145",
      "bg": "0.9728676858417774",
      "zh": "0.9759202375375216",
      "fr": "0.9995407665590473",
      "de": "0.9816888610635368",
      "ha": "0.9714611841136693",
      "hi": "0.9843443506275922",
      "hu": "0.9611649796823448"
    },
    "level": "hard",
    "test": "raise 'Test failed' unless binary_power_representation(137) == \"2(2(2)+2+2(0))+2(2+2(0))+2(0)\"\nraise 'Test failed' unless binary_power_representation(1315) == \"2(2(2+2(0))+2)+2(2(2+2(0)))+2(2(2)+2(0))+2+2(0)\"\nraise 'Test failed' unless binary_power_representation(1) == \"2(0)\"\nraise 'Test failed' unless binary_power_representation(3) == \"2+2(0)\"\nraise 'Test failed' unless binary_power_representation(10) == \"2(2+2(0))+2\"\n\n\nputs 'All tests passed!'",
    "entry_point": "binary_power_representation",
    "signature": "def binary_power_representation(n)",
    "docstring": {
      "en": "Converts a positive integer into a unique binary power representation.\nThe function takes a single argument, n, which is a positive integer, and\nreturns a string representing n as a sum of powers of 2, with the powers\nthemselves also represented as sums of powers of 2 when applicable.\n\nThe representation is formatted as '2(b)' where 'b' is the power. If 'b' itself\nis a power of 2, it's represented in a similar nested format. Spaces are not\nused in the representation.\n\nExample:\n>>> binary_power_representation(137)\n\"2(2(2)+2+2(0))+2(2+2(0))+2(0)\"\n>>> binary_power_representation(1315)\n\"2(2(2+2(0))+2)+2(2(2+2(0)))+2(2(2)+2(0))+2+2(0)\"",
      "sq": "Konverton një numër të plotë pozitiv në një përfaqësim unik të fuqisë binare.\nFunksioni merr një argument të vetëm, n, i cili është një numër i plotë pozitiv, dhe\nkthen një varg që përfaqëson n si një shumë të fuqive të 2, me fuqitë\nvetë të përfaqësuara gjithashtu si shuma të fuqive të 2 kur është e aplikueshme.\n\nPërfaqësimi është i formatuar si '2(b)' ku 'b' është fuqia. Nëse 'b' vetë\nështë një fuqi e 2, ajo përfaqësohet në një format të ngjashëm të folezuar. Hapësirat nuk\npërdoren në përfaqësim.\n\nShembull:\n>>> binary_power_representation(137)\n\"2(2(2)+2+2(0))+2(2+2(0))+2(0)\"\n>>> binary_power_representation(1315)\n\"2(2(2+2(0))+2)+2(2(2+2(0)))+2(2(2)+2(0))+2+2(0)\"",
      "hy": "Փոխակերպում է դրական ամբողջ թիվը եզակի երկբայական ուժի ներկայացման:\nՖունկցիան ընդունում է մեկ արգումենտ, n, որը դրական ամբողջ թիվ է, և վերադարձնում է տող, որը ներկայացնում է n-ը որպես 2-ի ուժերի գումար, ընդ որում ուժերը նույնպես ներկայացվում են որպես 2-ի ուժերի գումար, երբ կիրառելի է:\n\nՆերկայացումը ձևաչափված է որպես '2(b)', որտեղ 'b'-ն ուժն է: Եթե 'b'-ն ինքնին 2-ի ուժ է, այն ներկայացվում է նմանատիպ ներդրված ձևաչափով: Ներկայացման մեջ բացատներ չեն օգտագործվում:\n\nՕրինակ:\n>>> binary_power_representation(137)\n\"2(2(2)+2+2(0))+2(2+2(0))+2(0)\"\n>>> binary_power_representation(1315)\n\"2(2(2+2(0))+2)+2(2(2+2(0)))+2(2(2)+2(0))+2+2(0)\"",
      "bn": "একটি ধনাত্মক পূর্ণসংখ্যাকে একটি অনন্য বাইনারি শক্তি উপস্থাপনায় রূপান্তর করে। ফাংশনটি একটি একক আর্গুমেন্ট, n, গ্রহণ করে, যা একটি ধনাত্মক পূর্ণসংখ্যা, এবং একটি স্ট্রিং প্রদান করে যা n-কে 2-এর শক্তির যোগফল হিসাবে উপস্থাপন করে, যেখানে প্রযোজ্য হলে শক্তিগুলোকেও 2-এর শক্তির যোগফল হিসাবে উপস্থাপন করা হয়।\n\nউপস্থাপনাটি '2(b)' হিসাবে বিন্যাসিত হয় যেখানে 'b' হল শক্তি। যদি 'b' নিজেই 2-এর একটি শক্তি হয়, তবে এটি একইভাবে নেস্টেড ফরম্যাটে উপস্থাপিত হয়। উপস্থাপনায় স্পেস ব্যবহার করা হয় না।\n\nউদাহরণ:\n>>> binary_power_representation(137)\n\"2(2(2)+2+2(0))+2(2+2(0))+2(0)\"\n>>> binary_power_representation(1315)\n\"2(2(2+2(0))+2)+2(2(2+2(0)))+2(2(2)+2(0))+2+2(0)\"",
      "bg": "Преобразува положително цяло число в уникално представяне чрез степени на двойката.\nФункцията приема един аргумент, n, който е положително цяло число, и\nвръща низ, представляващ n като сума от степени на двойката, като самите степени\nсъщо са представени като суми от степени на двойката, когато е приложимо.\n\nПредставянето е форматирано като '2(b)', където 'b' е степента. Ако 'b' сам по себе си\nе степен на двойката, той е представен в подобен вложен формат. Интервали не се\nизползват в представянето.\n\nПример:\n>>> binary_power_representation(137)\n\"2(2(2)+2+2(0))+2(2+2(0))+2(0)\"\n>>> binary_power_representation(1315)\n\"2(2(2+2(0))+2)+2(2(2+2(0)))+2(2(2)+2(0))+2+2(0)\"",
      "zh": "将正整数转换为唯一的二进制幂表示形式。  \n该函数接受一个参数 n，它是一个正整数，并返回一个字符串，将 n 表示为 2 的幂之和，其中幂本身也在适用时表示为 2 的幂之和。\n\n表示形式格式为 '2(b)'，其中 'b' 是幂。如果 'b' 本身是 2 的幂，则以类似的嵌套格式表示。不在表示中使用空格。\n\n示例：\n>>> binary_power_representation(137)\n\"2(2(2)+2+2(0))+2(2+2(0))+2(0)\"\n>>> binary_power_representation(1315)\n\"2(2(2+2(0))+2)+2(2(2+2(0)))+2(2(2)+2(0))+2+2(0)\"",
      "fr": "Convertit un entier positif en une représentation unique de puissances binaires.\nLa fonction prend un seul argument, n, qui est un entier positif, et\nrenvoie une chaîne représentant n comme une somme de puissances de 2, avec les puissances\nelles-mêmes également représentées comme des sommes de puissances de 2 lorsque c'est applicable.\n\nLa représentation est formatée comme '2(b)' où 'b' est la puissance. Si 'b' lui-même\nest une puissance de 2, il est représenté dans un format imbriqué similaire. Les espaces ne sont pas\nutilisés dans la représentation.\n\nExemple:\n>>> binary_power_representation(137)\n\"2(2(2)+2+2(0))+2(2+2(0))+2(0)\"\n>>> binary_power_representation(1315)\n\"2(2(2+2(0))+2)+2(2(2+2(0)))+2(2(2)+2(0))+2+2(0)\"",
      "de": "Konvertiert eine positive ganze Zahl in eine einzigartige Binärpotenzdarstellung.\nDie Funktion nimmt ein einzelnes Argument, n, das eine positive ganze Zahl ist, und\ngibt einen String zurück, der n als Summe von Potenzen von 2 darstellt, wobei die Potenzen\nselbst auch als Summen von Potenzen von 2 dargestellt werden, wenn zutreffend.\n\nDie Darstellung ist formatiert als '2(b)', wobei 'b' die Potenz ist. Wenn 'b' selbst\neine Potenz von 2 ist, wird sie in einem ähnlichen verschachtelten Format dargestellt. Leerzeichen werden in der Darstellung nicht verwendet.\n\nBeispiel:\n>>> binary_power_representation(137)\n\"2(2(2)+2+2(0))+2(2+2(0))+2(0)\"\n>>> binary_power_representation(1315)\n\"2(2(2+2(0))+2)+2(2(2+2(0)))+2(2(2)+2(0))+2+2(0)\"",
      "ha": "Yana canza lamba mai kyau zuwa wakilcin ƙarfin binary na musamman. \n\nAikin yana ɗaukar hujja guda ɗaya, n, wanda shine lamba mai kyau, kuma yana dawowa da igiyar da ke wakiltar n a matsayin jumla na ƙarfin 2, tare da ƙarfin kansu kuma an wakilta su a matsayin jumla na ƙarfin 2 idan ya dace.\n\nWakilcin yana da tsari kamar '2(b)' inda 'b' shine ƙarfin. Idan 'b' kansa shine ƙarfin 2, ana wakilta shi a cikin irin wannan tsarin da aka haɗa. Ba a amfani da sarari a cikin wakilcin.\n\nMisali:\n>>> binary_power_representation(137)\n\"2(2(2)+2+2(0))+2(2+2(0))+2(0)\"\n>>> binary_power_representation(1315)\n\"2(2(2+2(0))+2)+2(2(2+2(0)))+2(2(2)+2(0))+2+2(0)\"",
      "hi": "एक धनात्मक पूर्णांक को अद्वितीय द्विआधारी घातांक प्रतिनिधित्व में परिवर्तित करता है। \nयह फ़ंक्शन एकल तर्क, n, लेता है, जो एक धनात्मक पूर्णांक है, और \nn को 2 की घाताओं के योग के रूप में एक स्ट्रिंग लौटाता है, जिसमें घातांक \nभी लागू होने पर 2 की घाताओं के योग के रूप में दर्शाए जाते हैं।\n\nप्रतिनिधित्व '2(b)' के रूप में स्वरूपित होता है जहाँ 'b' घातांक है। यदि 'b' स्वयं \n2 की घात है, तो इसे समान नेस्टेड प्रारूप में दर्शाया जाता है। \nप्रतिनिधित्व में रिक्त स्थान का उपयोग नहीं किया जाता है।\n\nउदाहरण:\n>>> binary_power_representation(137)\n\"2(2(2)+2+2(0))+2(2+2(0))+2(0)\"\n>>> binary_power_representation(1315)\n\"2(2(2+2(0))+2)+2(2(2+2(0)))+2(2(2)+2(0))+2+2(0)\"",
      "hu": "Konvertál egy pozitív egész számot egyedi bináris hatvány reprezentációvá.  \nA függvény egyetlen argumentumot vesz fel, n-t, amely egy pozitív egész szám, és  \nvisszaad egy karakterláncot, amely n-t a 2 hatványainak összegével reprezentálja, ahol a hatványok  \nszintén a 2 hatványainak összegével vannak reprezentálva, ha alkalmazható.\n\nA reprezentáció formátuma '2(b)', ahol 'b' a hatvány. Ha 'b' maga is  \na 2 hatványa, akkor hasonló beágyazott formátumban van reprezentálva. A reprezentációban  \nnem használnak szóközöket.\n\nPélda:\n>>> binary_power_representation(137)\n\"2(2(2)+2+2(0))+2(2+2(0))+2(0)\"\n>>> binary_power_representation(1315)\n\"2(2(2+2(0))+2)+2(2(2+2(0)))+2(2(2)+2(0))+2+2(0)\""
    },
    "docstring_bertscore": {
      "sq": "0.9989087246865943",
      "hy": "0.9785727476458614",
      "bn": "0.9708589367983715",
      "bg": "0.9709894369587114",
      "zh": "0.971237526304624",
      "fr": "0.9946699523553099",
      "de": "0.9829958489707463",
      "ha": "0.9770091292863547",
      "hi": "0.9736651868216325",
      "hu": "0.9674244188798973"
    }
  },
  {
    "task_id": "Ruby/5",
    "prompt": {
      "en": "# Finds the maximum possible Least Common Multiple (LCM) of any three numbers chosen between 1 and n.\n# The function takes a single argument, n, which is a positive integer, and returns the highest LCM\n# attainable by any combination of three distinct numbers from 1 to n.\n#\n# Example:\n# >>> max_lcm_of_three(9)\n# 504\n# >>> max_lcm_of_three(10)\n# 630\n\ndef max_lcm_of_three(n)",
      "sq": "# Gjen Numrin më të Madh të Përbashkët (LCM) të mundshëm të çdo treshe numrash të zgjedhur midis 1 dhe n.\n# Funksioni merr një argument të vetëm, n, i cili është një numër i plotë pozitiv, dhe kthen LCM-në më të lartë\n# të arritshme nga çdo kombinim i tre numrave të ndryshëm nga 1 deri në n.\n#\n# Shembull:\n# >>> max_lcm_of_three(9)\n# 504\n# >>> max_lcm_of_three(10)\n# 630\n\ndef max_lcm_of_three(n)",
      "hy": "# Գտնում է 1-ից n միջակայքում ընտրված ցանկացած երեք թվերի առավելագույն հնարավոր ամենափոքր ընդհանուր բազմապատիկը (LCM):\n# Ֆունկցիան ընդունում է մեկ արգումենտ՝ n, որը դրական ամբողջ թիվ է, և վերադարձնում է ամենաբարձր LCM-ը,\n# որը հնարավոր է ստանալ 1-ից n միջակայքում գտնվող երեք տարբեր թվերի ցանկացած համադրությամբ:\n#\n# Օրինակ:\n# >>> max_lcm_of_three(9)\n# 504\n# >>> max_lcm_of_three(10)\n# 630\n\ndef max_lcm_of_three(n)",
      "bn": "# ১ থেকে n এর মধ্যে যেকোনো তিনটি সংখ্যার সর্বাধিক সম্ভাব্য লঘিষ্ঠ সাধারণ গুণনীয়ক (LCM) খুঁজে বের করে।\n# ফাংশনটি একটি একক আর্গুমেন্ট গ্রহণ করে, n, যা একটি ধনাত্মক পূর্ণসংখ্যা, এবং ১ থেকে n এর মধ্যে তিনটি ভিন্ন সংখ্যার যেকোনো সংমিশ্রণের দ্বারা অর্জনযোগ্য সর্বোচ্চ LCM প্রদান করে।\n#\n# উদাহরণ:\n# >>> max_lcm_of_three(9)\n# 504\n# >>> max_lcm_of_three(10)\n# 630\n\ndef max_lcm_of_three(n)",
      "bg": "# Намира максималното възможно най-малко общо кратно (НОК) на три числа, избрани между 1 и n.\n# Функцията приема един аргумент, n, който е положително цяло число, и връща най-високото НОК,\n# което може да бъде постигнато чрез комбинация от три различни числа от 1 до n.\n#\n# Пример:\n# >>> max_lcm_of_three(9)\n# 504\n# >>> max_lcm_of_three(10)\n# 630\n\ndef max_lcm_of_three(n)",
      "zh": "# 查找在1到n之间选择的任意三个数字的最大可能最小公倍数（LCM）。\n# 该函数接受一个参数n，它是一个正整数，并返回从1到n中任意三个不同数字组合可以达到的最高LCM。\n#\n# 示例:\n# >>> max_lcm_of_three(9)\n# 504\n# >>> max_lcm_of_three(10)\n# 630\n\ndef max_lcm_of_three(n)",
      "fr": "# Trouve le Plus Petit Multiple (PPM) maximum possible de n'importe quels trois nombres choisis entre 1 et n.\n# La fonction prend un seul argument, n, qui est un entier positif, et retourne le plus haut PPM\n# atteignable par n'importe quelle combinaison de trois nombres distincts de 1 à n.\n#\n# Exemple:\n# >>> max_lcm_of_three(9)\n# 504\n# >>> max_lcm_of_three(10)\n# 630\n\ndef max_lcm_of_three(n)",
      "de": "# Findet das maximal mögliche kleinste gemeinsame Vielfache (KGV) von drei beliebigen Zahlen, die zwischen 1 und n gewählt werden.\n# Die Funktion nimmt ein einziges Argument, n, das eine positive ganze Zahl ist, und gibt das höchste KGV\n# zurück, das durch eine beliebige Kombination von drei verschiedenen Zahlen von 1 bis n erreichbar ist.\n#\n# Beispiel:\n# >>> max_lcm_of_three(9)\n# 504\n# >>> max_lcm_of_three(10)\n# 630\n\ndef max_lcm_of_three(n)",
      "ha": "# Nemi mafi girman Rabo Mai Karanci (LCM) na kowanne lambobi uku da aka zaɓa tsakanin 1 da n.\n# Aikin yana ɗaukar hujja guda ɗaya, n, wanda yake lamba mai kyau, kuma yana mayar da mafi girman LCM\n# da za a iya samu ta kowanne haɗin lambobi uku daban-daban daga 1 zuwa n.\n#\n# Misali:\n# >>> max_lcm_of_three(9)\n# 504\n# >>> max_lcm_of_three(10)\n# 630\n\ndef max_lcm_of_three(n)",
      "hi": "# 1 से n के बीच चुने गए किसी भी तीन संख्याओं का अधिकतम संभव लघुत्तम समापवर्तक (LCM) खोजता है।\n# फ़ंक्शन एकल तर्क n लेता है, जो एक धनात्मक पूर्णांक है, और 1 से n तक की तीन भिन्न संख्याओं के किसी भी संयोजन द्वारा प्राप्त उच्चतम LCM लौटाता है।\n#\n# उदाहरण:\n# >>> max_lcm_of_three(9)\n# 504\n# >>> max_lcm_of_three(10)\n# 630\n\ndef max_lcm_of_three(n)",
      "hu": "# Megkeresi bármely három szám legnagyobb lehetséges legkisebb közös többszörösét (LKKT), amelyeket 1 és n között választanak ki.\n# A függvény egyetlen argumentumot vesz fel, n-t, amely egy pozitív egész szám, és visszaadja a legnagyobb elérhető LKKT-t\n# bármely három különböző szám kombinációjával 1 és n között.\n#\n# Példa:\n# >>> max_lcm_of_three(9)\n# 504\n# >>> max_lcm_of_three(10)\n# 630\n\ndef max_lcm_of_three(n)"
    },
    "prompt_bertscore": {
      "sq": "0.9629731120409054",
      "hy": "0.9518933107563984",
      "bn": "0.9749062294423384",
      "bg": "0.9673729736112092",
      "zh": "0.9563098572787091",
      "fr": "0.9914906744764654",
      "de": "0.9782364664107693",
      "ha": "0.9647961416780436",
      "hi": "0.969700127155414",
      "hu": "0.9674591791965784"
    },
    "canonical_solution": "    return 1 if n < 3\n  \n    # When n is greater than or equal to 3\n    if n.even?\n        if n % 3 == 0\n            (n-1)*(n-2)*(n-3)\n        else\n            n * (n - 1) * (n - 3)\n        end\n    else\n      n * (n - 1) * (n - 2)\n    end\n  end",
    "instruction": {
      "en": "Write a ruby function `def max_lcm_of_three(n)` to solve the following problem:\nFinds the maximum possible Least Common Multiple (LCM) of any three numbers chosen between 1 and n.\nThe function takes a single argument, n, which is a positive integer, and returns the highest LCM\nattainable by any combination of three distinct numbers from 1 to n.\n\nExample:\n>>> max_lcm_of_three(9)\n504\n>>> max_lcm_of_three(10)\n630",
      "sq": "Shkruani një funksion ruby `def max_lcm_of_three(n)` për të zgjidhur problemin e mëposhtëm:\nGjen Minimumin e Përbashkët të Shumëfishtë (LCM) maksimal të mundshëm të çdo tre numrave të zgjedhur midis 1 dhe n.\nFunksioni merr një argument të vetëm, n, i cili është një numër i plotë pozitiv, dhe kthen LCM-në më të lartë të arritshme nga çdo kombinim i tre numrave të ndryshëm nga 1 deri në n.\n\nShembull:\n>>> max_lcm_of_three(9)\n504\n>>> max_lcm_of_three(10)\n630",
      "hy": "Գրեք ruby ֆունկցիա `def max_lcm_of_three(n)` հետևյալ խնդիրը լուծելու համար:\nԳտնում է ցանկացած երեք թվերի առավելագույն հնարավոր ամենափոքր ընդհանուր բազմապատիկը (LCM), որոնք ընտրված են 1-ից n միջակայքում:\nՖունկցիան ընդունում է մեկ արգումենտ, n, որը դրական ամբողջ թիվ է, և վերադարձնում է 1-ից n միջակայքում գտնվող երեք տարբեր թվերի ցանկացած համադրությամբ հասանելի ամենաբարձր LCM-ը:\n\nՕրինակ:\n>>> max_lcm_of_three(9)\n504\n>>> max_lcm_of_three(10)\n630",
      "bn": "একটি রুবি ফাংশন `def max_lcm_of_three(n)` লিখুন নিম্নলিখিত সমস্যার সমাধানের জন্য:\n১ থেকে n এর মধ্যে যেকোনো তিনটি সংখ্যার সর্বাধিক সম্ভাব্য লিস্ট কমন মাল্টিপল (LCM) খুঁজে বের করে।\nফাংশনটি একটি একক আর্গুমেন্ট গ্রহণ করে, n, যা একটি ধনাত্মক পূর্ণসংখ্যা, এবং ১ থেকে n এর মধ্যে তিনটি ভিন্ন সংখ্যার যেকোনো সংমিশ্রণের দ্বারা অর্জনযোগ্য সর্বোচ্চ LCM প্রদান করে।\n\nউদাহরণ:\n>>> max_lcm_of_three(9)\n504\n>>> max_lcm_of_three(10)\n630",
      "bg": "Напишете функция на Ruby `def max_lcm_of_three(n)` за решаване на следния проблем:  \nНамира максималната възможна Най-малка Обща Кратна (LCM) на произволни три числа, избрани между 1 и n.  \nФункцията приема един аргумент, n, който е положително цяло число, и връща най-високата LCM,  \nпостижима чрез всяка комбинация от три различни числа от 1 до n.\n\nПример:  \n>>> max_lcm_of_three(9)  \n504  \n>>> max_lcm_of_three(10)  \n630",
      "zh": "编写一个 ruby 函数 `def max_lcm_of_three(n)` 来解决以下问题：  \n找出从 1 到 n 中选择的任意三个数字的最大可能最小公倍数（LCM）。  \n该函数接受一个参数 n，这是一个正整数，并返回从 1 到 n 中任意三个不同数字组合所能达到的最高 LCM。\n\n示例：  \n>>> max_lcm_of_three(9)  \n504  \n>>> max_lcm_of_three(10)  \n630  ",
      "fr": "Écrire une fonction ruby `def max_lcm_of_three(n)` pour résoudre le problème suivant :  \nTrouve le Plus Petit Multiple Commun (PPMC) maximal possible de trois nombres choisis entre 1 et n.  \nLa fonction prend un seul argument, n, qui est un entier positif, et retourne le PPMC le plus élevé atteignable par n'importe quelle combinaison de trois nombres distincts de 1 à n.\n\nExemple :\n>>> max_lcm_of_three(9)\n504\n>>> max_lcm_of_three(10)\n630",
      "de": "Schreiben Sie eine Ruby-Funktion `def max_lcm_of_three(n)`, um das folgende Problem zu lösen:\nFindet das maximal mögliche kleinste gemeinsame Vielfache (LCM) von drei beliebigen Zahlen, die zwischen 1 und n gewählt werden.\nDie Funktion nimmt ein einzelnes Argument n, das eine positive ganze Zahl ist, und gibt das höchste LCM zurück,\ndas durch eine beliebige Kombination von drei verschiedenen Zahlen von 1 bis n erreichbar ist.\n\nBeispiel:\n>>> max_lcm_of_three(9)\n504\n>>> max_lcm_of_three(10)\n630",
      "ha": "Rubuta wani aiki na ruby `def max_lcm_of_three(n)` don warware matsalar mai zuwa:\nNemo mafi girman Raba Mai Girma (LCM) na kowanne lambobi uku da aka zaɓa tsakanin 1 da n.\nAikin yana ɗaukar hujja guda ɗaya, n, wanda yake lamba mai kyau, kuma yana mayar da mafi girman LCM da za a iya samu ta kowanne haɗin lambobi uku daban-daban daga 1 zuwa n.\n\nMisali:\n>>> max_lcm_of_three(9)\n504\n>>> max_lcm_of_three(10)\n630",
      "hi": "`def max_lcm_of_three(n)` नामक एक रूबी फ़ंक्शन लिखें ताकि निम्नलिखित समस्या का समाधान हो सके:\n1 और n के बीच चुने गए किसी भी तीन संख्याओं का अधिकतम संभव लघुत्तम समापवर्तक (LCM) खोजें।\nफ़ंक्शन एक एकल तर्क लेता है, n, जो एक धनात्मक पूर्णांक है, और 1 से n के बीच की तीन भिन्न संख्याओं के किसी भी संयोजन द्वारा प्राप्त होने योग्य उच्चतम LCM लौटाता है।\n\nउदाहरण:\n>>> max_lcm_of_three(9)\n504\n>>> max_lcm_of_three(10)\n630",
      "hu": "Írj egy ruby függvényt `def max_lcm_of_three(n)` a következő probléma megoldására:\nMegtalálja bármely három szám legnagyobb lehetséges legkisebb közös többszörösét (LCM), amelyeket 1 és n között választottak ki.\nA függvény egyetlen argumentumot vesz fel, n-t, amely egy pozitív egész szám, és visszaadja a legmagasabb LCM-et, amely bármely három különböző szám kombinációjával elérhető 1 és n között.\n\nPélda:\n>>> max_lcm_of_three(9)\n504\n>>> max_lcm_of_three(10)\n630"
    },
    "instruction_bertscore": {
      "sq": "0.9873478406192208",
      "hy": "0.9596138750368435",
      "bn": "0.980625592633857",
      "bg": "0.981855313322844",
      "zh": "0.9601400469162048",
      "fr": "0.987753443857294",
      "de": "0.9737835705287292",
      "ha": "0.9750275926051507",
      "hi": "0.9769469579770909",
      "hu": "0.967587891683489"
    },
    "level": "easy",
    "test": "raise 'Test failed' unless max_lcm_of_three(9) == 504\nraise 'Test failed' unless max_lcm_of_three(10) == 630\nraise 'Test failed' unless max_lcm_of_three(3) == 6\nraise 'Test failed' unless max_lcm_of_three(5) == 60\nraise 'Test failed' unless max_lcm_of_three(1) == 1\n  \n\nputs 'All tests passed!'",
    "entry_point": "max_lcm_of_three",
    "signature": "def max_lcm_of_three(n)",
    "docstring": {
      "en": "Finds the maximum possible Least Common Multiple (LCM) of any three numbers chosen between 1 and n.\nThe function takes a single argument, n, which is a positive integer, and returns the highest LCM\nattainable by any combination of three distinct numbers from 1 to n.\n\nExample:\n>>> max_lcm_of_three(9)\n504\n>>> max_lcm_of_three(10)\n630",
      "sq": "Gjen Minimumin e Përbashkët Shumëfishin (LCM) maksimal të mundshëm të çdo tre numrave të zgjedhur midis 1 dhe n. Funksioni merr një argument të vetëm, n, i cili është një numër i plotë pozitiv, dhe kthen LCM më të lartë të arritshëm nga çdo kombinim i tre numrave të ndryshëm nga 1 deri në n.\n\nShembull:\n>>> max_lcm_of_three(9)\n504\n>>> max_lcm_of_three(10)\n630",
      "hy": "Գտնում է հնարավոր ամենամեծ նվազագույն ընդհանուր բազմապատիկը (LCM) ցանկացած երեք թվերի, որոնք ընտրված են 1-ից մինչև n միջակայքում: Ֆունկցիան ընդունում է մեկ արգումենտ՝ n, որը դրական ամբողջ թիվ է, և վերադարձնում է ամենաբարձր LCM-ը, որը հնարավոր է ստանալ 1-ից մինչև n միջակայքում գտնվող երեք տարբեր թվերի ցանկացած համադրությամբ:\n\nՕրինակ:\n>>> max_lcm_of_three(9)\n504\n>>> max_lcm_of_three(10)\n630",
      "bn": "১ থেকে n এর মধ্যে যেকোনো তিনটি সংখ্যার সর্বাধিক সম্ভাব্য লঘিষ্ঠ সাধারণ গুণনীয়ক (LCM) খুঁজে বের করে।\nফাংশনটি একটি একক আর্গুমেন্ট গ্রহণ করে, n, যা একটি ধনাত্মক পূর্ণসংখ্যা, এবং 1 থেকে n পর্যন্ত যেকোনো তিনটি ভিন্ন সংখ্যার সংমিশ্রণে প্রাপ্ত সর্বোচ্চ LCM ফেরত দেয়।\n\nউদাহরণ:\n>>> max_lcm_of_three(9)\n504\n>>> max_lcm_of_three(10)\n630",
      "bg": "Намира максималната възможна Най-малка обща кратност (НОК) на три числа, избрани между 1 и n. Функцията приема един аргумент, n, който е положително цяло число, и връща най-високата НОК, постижима от всяка комбинация от три различни числа от 1 до n.\n\nПример:\n>>> max_lcm_of_three(9)\n504\n>>> max_lcm_of_three(10)\n630",
      "zh": "查找在1到n之间选择的任意三个数字的最大可能最小公倍数（LCM）。  \n该函数接受一个参数n，它是一个正整数，并返回从1到n中任意三个不同数字组合可以达到的最高LCM。\n\n示例：\n>>> max_lcm_of_three(9)\n504\n>>> max_lcm_of_three(10)\n630",
      "fr": "Trouve le Plus Petit Multiple Commun (PPMC) maximum possible de trois nombres choisis entre 1 et n. La fonction prend un seul argument, n, qui est un entier positif, et retourne le PPMC le plus élevé atteignable par n'importe quelle combinaison de trois nombres distincts de 1 à n.\n\nExemple :\n>>> max_lcm_of_three(9)\n504\n>>> max_lcm_of_three(10)\n630",
      "de": "Findet das maximal mögliche kleinste gemeinsame Vielfache (KGV) von drei beliebigen Zahlen, die zwischen 1 und n gewählt werden. Die Funktion nimmt ein einziges Argument n, das eine positive ganze Zahl ist, und gibt das höchste KGV zurück, das durch jede Kombination von drei verschiedenen Zahlen von 1 bis n erreichbar ist.\n\nBeispiel:\n>>> max_lcm_of_three(9)\n504\n>>> max_lcm_of_three(10)\n630",
      "ha": "Yana nemo mafi girman Maɗaukakin Maɗaukaki (LCM) na kowanne lambobi uku da aka zaɓa tsakanin 1 da n. Aikin yana ɗaukar hujja guda ɗaya, n, wanda yake lamba mai kyau, kuma yana mayar da mafi girman LCM da za a iya samu ta kowanne haɗin lambobi uku daban-daban daga 1 zuwa n.\n\nMisali:\n>>> max_lcm_of_three(9)\n504\n>>> max_lcm_of_three(10)\n630",
      "hi": "किसी भी तीन संख्याओं के बीच 1 से n के बीच चुनी गई अधिकतम संभव लघुत्तम समापवर्त्य (LCM) को खोजता है। \nयह फ़ंक्शन एकल तर्क n लेता है, जो एक धनात्मक पूर्णांक है, और 1 से n तक की तीन भिन्न संख्याओं के किसी भी संयोजन द्वारा प्राप्त उच्चतम LCM लौटाता है।\n\nउदाहरण:\n>>> max_lcm_of_three(9)\n504\n>>> max_lcm_of_three(10)\n630",
      "hu": "Megkeresi bármely három szám legnagyobb közös többszörösének (LKT) maximálisan elérhető értékét, amelyeket az 1 és n közötti számok közül választanak ki. A függvény egyetlen argumentumot vesz fel, n-t, amely egy pozitív egész szám, és visszaadja a legmagasabb LKT-t, amely bármely három különböző szám kombinációjával elérhető az 1 és n között.\n\nPélda:\n>>> max_lcm_of_three(9)\n504\n>>> max_lcm_of_three(10)\n630"
    },
    "docstring_bertscore": {
      "sq": "0.9726956719318012",
      "hy": "0.9457103442555443",
      "bn": "0.986660778131221",
      "bg": "0.9760578883915787",
      "zh": "0.9479167305280799",
      "fr": "0.9696335859777673",
      "de": "0.9632448384021611",
      "ha": "0.9708333134792181",
      "hi": "0.9572628858469145",
      "hu": "0.9484500531011586"
    }
  },
  {
    "task_id": "Ruby/6",
    "prompt": {
      "en": "# Swaps the case of each letter in a given string.\n# The function takes a single argument, input_string, which is a string containing only English alphabets without any spaces or other types of characters. \n# It returns a new string where every lowercase letter is converted to uppercase and every uppercase letter is converted to lowercase.\n#\n# Example:\n# >>> swap_case(\"HelloWorld\")\n# \"hELLOwORLD\"\n# >>> swap_case(\"Ruby\")\n# \"rUBY\"\n\n\ndef swap_case(input_string)",
      "sq": "# Ndërron rastin e secilës shkronjë në një varg të dhënë.\n# Funksioni merr një argument të vetëm, input_string, i cili është një varg që përmban vetëm alfabetet angleze pa ndonjë hapësirë ose lloje të tjera karakteresh.\n# Kthen një varg të ri ku çdo shkronjë e vogël konvertohet në të madhe dhe çdo shkronjë e madhe konvertohet në të vogël.\n#\n# Shembull:\n# >>> swap_case(\"HelloWorld\")\n# \"hELLOwORLD\"\n# >>> swap_case(\"Ruby\")\n# \"rUBY\"\n\n\ndef swap_case(input_string)",
      "hy": "# Փոխում է տրված տողի յուրաքանչյուր տառի ռեգիստրը։\n# Ֆունկցիան ընդունում է մեկ արգումենտ՝ input_string, որը տող է, որը պարունակում է միայն անգլերեն այբուբենի տառեր՝ առանց բացատների կամ այլ տեսակի սիմվոլների։\n# Այն վերադարձնում է նոր տող, որտեղ յուրաքանչյուր փոքրատառ տառ վերածվում է մեծատառի, իսկ յուրաքանչյուր մեծատառ տառ վերածվում է փոքրատառի։\n#\n# Օրինակ:\n# >>> swap_case(\"HelloWorld\")\n# \"hELLOwORLD\"\n# >>> swap_case(\"Ruby\")\n# \"rUBY\"\n\n\ndef swap_case(input_string)",
      "bn": "# প্রদত্ত স্ট্রিং-এর প্রতিটি অক্ষরের কেস পরিবর্তন করে।\n# ফাংশনটি একটি মাত্র আর্গুমেন্ট নেয়, input_string, যা একটি স্ট্রিং যেখানে শুধুমাত্র ইংরেজি বর্ণমালা রয়েছে, কোনো ফাঁকা স্থান বা অন্যান্য প্রকারের অক্ষর নেই।\n# এটি একটি নতুন স্ট্রিং রিটার্ন করে যেখানে প্রতিটি ছোট হাতের অক্ষর বড় হাতের অক্ষরে এবং প্রতিটি বড় হাতের অক্ষর ছোট হাতের অক্ষরে রূপান্তরিত হয়।\n#\n# উদাহরণ:\n# >>> swap_case(\"HelloWorld\")\n# \"hELLOwORLD\"\n# >>> swap_case(\"Ruby\")\n# \"rUBY\"\n\n\ndef swap_case(input_string)",
      "bg": "# Разменя регистъра на всяка буква в даден низ.\n# Функцията приема един аргумент, input_string, който е низ, съдържащ само английски букви без интервали или други видове символи.\n# Връща нов низ, където всяка малка буква е преобразувана в главна, а всяка главна буква е преобразувана в малка.\n#\n# Пример:\n# >>> swap_case(\"HelloWorld\")\n# \"hELLOwORLD\"\n# >>> swap_case(\"Ruby\")\n# \"rUBY\"\n\n\ndef swap_case(input_string)",
      "zh": "# 交换给定字符串中每个字母的大小写。\n# 该函数接受一个参数，input_string，这是一个仅包含英文字母的字符串，没有空格或其他类型的字符。\n# 它返回一个新字符串，其中每个小写字母转换为大写字母，每个大写字母转换为小写字母。\n#\n# 示例:\n# >>> swap_case(\"HelloWorld\")\n# \"hELLOwORLD\"\n# >>> swap_case(\"Ruby\")\n# \"rUBY\"\n\n\ndef swap_case(input_string)",
      "fr": "# Échange la casse de chaque lettre dans une chaîne donnée.\n# La fonction prend un seul argument, input_string, qui est une chaîne contenant uniquement des alphabets anglais sans espaces ni autres types de caractères.\n# Elle renvoie une nouvelle chaîne où chaque lettre minuscule est convertie en majuscule et chaque lettre majuscule est convertie en minuscule.\n#\n# Exemple:\n# >>> swap_case(\"HelloWorld\")\n# \"hELLOwORLD\"\n# >>> swap_case(\"Ruby\")\n# \"rUBY\"\n\n\ndef swap_case(input_string)",
      "de": "# Vertauscht die Groß- und Kleinschreibung jedes Buchstabens in einem gegebenen String.\n# Die Funktion nimmt ein einziges Argument, input_string, das ein String ist, der nur englische Buchstaben ohne Leerzeichen oder andere Zeichenarten enthält.\n# Sie gibt einen neuen String zurück, bei dem jeder Kleinbuchstabe in einen Großbuchstaben und jeder Großbuchstabe in einen Kleinbuchstaben umgewandelt wird.\n#\n# Beispiel:\n# >>> swap_case(\"HelloWorld\")\n# \"hELLOwORLD\"\n# >>> swap_case(\"Ruby\")\n# \"rUBY\"\n\n\ndef swap_case(input_string)",
      "ha": "# Canza harafin kowane harafi a cikin wani igiyar rubutu da aka bayar.\n# Aikin yana karɓar hujja guda ɗaya, input_string, wanda shine igiyar rubutu da ke ɗauke da haruffan Ingilishi kawai ba tare da sarari ko wasu nau'ikan haruffa ba.\n# Yana mayar da sabon igiyar rubutu inda kowane ƙaramin harafi ya koma babba kuma kowane babban harafi ya koma ƙarami.\n#\n# Misali:\n# >>> swap_case(\"HelloWorld\")\n# \"hELLOwORLD\"\n# >>> swap_case(\"Ruby\")\n# \"rUBY\"\n\n\ndef swap_case(input_string)",
      "hi": "# दिए गए स्ट्रिंग में प्रत्येक अक्षर के केस को स्वैप करता है।\n# फ़ंक्शन एकल तर्क लेता है, input_string, जो एक स्ट्रिंग है जिसमें केवल अंग्रेजी अक्षर होते हैं, बिना किसी स्पेस या अन्य प्रकार के वर्णों के।\n# यह एक नई स्ट्रिंग लौटाता है जहाँ प्रत्येक लोअरकेस अक्षर को अपरकेस में और प्रत्येक अपरकेस अक्षर को लोअरकेस में परिवर्तित किया जाता है।\n#\n# उदाहरण:\n# >>> swap_case(\"HelloWorld\")\n# \"hELLOwORLD\"\n# >>> swap_case(\"Ruby\")\n# \"rUBY\"\n\n\ndef swap_case(input_string)",
      "hu": "# Minden betű esetét megcseréli egy adott sztringben.\n# A függvény egyetlen argumentumot vesz fel, input_string, amely egy sztring, amely csak angol ábécé betűit tartalmazza, szóközök vagy más típusú karakterek nélkül.\n# Visszaad egy új sztringet, ahol minden kisbetű nagybetűvé alakul, és minden nagybetű kisbetűvé alakul.\n#\n# Példa:\n# >>> swap_case(\"HelloWorld\")\n# \"hELLOwORLD\"\n# >>> swap_case(\"Ruby\")\n# \"rUBY\"\n\n\ndef swap_case(input_string)"
    },
    "prompt_bertscore": {
      "sq": "0.9891567674993055",
      "hy": "0.9556809934923527",
      "bn": "0.9824923209548229",
      "bg": "0.9665681233072559",
      "zh": "0.9579420031196728",
      "fr": "0.9883886638158436",
      "de": "0.9737434471917602",
      "ha": "0.9554414452528246",
      "hi": "0.9743506602665839",
      "hu": "0.9728057131628945"
    },
    "canonical_solution": "    input_string.chars.map do |char|\n      if char =~ /[a-z]/\n        char.upcase\n      elsif char =~ /[A-Z]/\n        char.downcase\n      else\n        char\n      end\n    end.join\n  end",
    "instruction": {
      "en": "Write a ruby function `def swap_case(input_string)` to solve the following problem:\nSwaps the case of each letter in a given string.\nThe function takes a single argument, input_string, which is a string containing only English alphabets without any spaces or other types of characters.\nIt returns a new string where every lowercase letter is converted to uppercase and every uppercase letter is converted to lowercase.\n\nExample:\n>>> swap_case(\"HelloWorld\")\n\"hELLOwORLD\"\n>>> swap_case(\"Ruby\")\n\"rUBY\"",
      "sq": "Shkruani një funksion ruby `def swap_case(input_string)` për të zgjidhur problemin e mëposhtëm:\nNdërron shkronjat e mëdha me të vogla dhe anasjelltas në një varg të dhënë.\nFunksioni merr një argument të vetëm, input_string, i cili është një varg që përmban vetëm alfabetet angleze pa hapësira ose lloje të tjera karakteresh.\nKthen një varg të ri ku çdo shkronjë e vogël është konvertuar në shkronjë të madhe dhe çdo shkronjë e madhe është konvertuar në shkronjë të vogël.\n\nShembull:\n>>> swap_case(\"HelloWorld\")\n\"hELLOwORLD\"\n>>> swap_case(\"Ruby\")\n\"rUBY\"",
      "hy": "Գրեք ruby ֆունկցիա `def swap_case(input_string)` հետևյալ խնդիրը լուծելու համար:\nՓոխում է տրված տողի յուրաքանչյուր տառի ռեգիստրը:\nՖունկցիան ընդունում է մեկ արգումենտ՝ input_string, որը տող է, որը պարունակում է միայն անգլերեն այբուբենի տառեր՝ առանց բացատների կամ այլ տեսակի սիմվոլների:\nԱյն վերադարձնում է նոր տող, որտեղ յուրաքանչյուր փոքրատառ տառ փոխակերպվում է մեծատառի, և յուրաքանչյուր մեծատառ տառ փոխակերպվում է փոքրատառի:\n\nՕրինակ:\n>>> swap_case(\"HelloWorld\")\n\"hELLOwORLD\"\n>>> swap_case(\"Ruby\")\n\"rUBY\"",
      "bn": "একটি রুবি ফাংশন `def swap_case(input_string)` লিখুন নিম্নলিখিত সমস্যার সমাধানের জন্য:\nপ্রদত্ত স্ট্রিং-এর প্রতিটি অক্ষরের কেস পরিবর্তন করে।\nফাংশনটি একটি একক আর্গুমেন্ট গ্রহণ করে, input_string, যা শুধুমাত্র ইংরেজি বর্ণমালা ধারণ করে, কোনো স্পেস বা অন্যান্য প্রকারের অক্ষর ছাড়া।\nএটি একটি নতুন স্ট্রিং রিটার্ন করে যেখানে প্রতিটি ছোট হাতের অক্ষর বড় হাতের অক্ষরে রূপান্তরিত হয় এবং প্রতিটি বড় হাতের অক্ষর ছোট হাতের অক্ষরে রূপান্তরিত হয়।\n\nউদাহরণ:\n>>> swap_case(\"HelloWorld\")\n\"hELLOwORLD\"\n>>> swap_case(\"Ruby\")\n\"rUBY\"",
      "bg": "Напишете Ruby функция `def swap_case(input_string)`, за да решите следния проблем:  \nРазменя регистъра на всяка буква в даден низ.  \nФункцията приема един аргумент, input_string, който е низ, съдържащ само английски букви без интервали или други видове символи.  \nТя връща нов низ, където всяка малка буква се преобразува в главна, а всяка главна буква се преобразува в малка.\n\nПример:  \n>>> swap_case(\"HelloWorld\")  \n\"hELLOwORLD\"  \n>>> swap_case(\"Ruby\")  \n\"rUBY\"",
      "zh": "编写一个 ruby 函数 `def swap_case(input_string)` 来解决以下问题：  \n交换给定字符串中每个字母的大小写。  \n该函数接受一个参数 input_string，这是一个仅包含英文字母且不含空格或其他类型字符的字符串。  \n它返回一个新字符串，其中每个小写字母转换为大写字母，每个大写字母转换为小写字母。\n\n示例：  \n>>> swap_case(\"HelloWorld\")  \n\"hELLOwORLD\"  \n>>> swap_case(\"Ruby\")  \n\"rUBY\"  ",
      "fr": "Écrire une fonction ruby `def swap_case(input_string)` pour résoudre le problème suivant :\nÉchange la casse de chaque lettre dans une chaîne donnée.\nLa fonction prend un seul argument, input_string, qui est une chaîne contenant uniquement des alphabets anglais sans espaces ni autres types de caractères.\nElle renvoie une nouvelle chaîne où chaque lettre minuscule est convertie en majuscule et chaque lettre majuscule est convertie en minuscule.\n\nExemple :\n>>> swap_case(\"HelloWorld\")\n\"hELLOwORLD\"\n>>> swap_case(\"Ruby\")\n\"rUBY\"",
      "de": "Schreiben Sie eine Ruby-Funktion `def swap_case(input_string)`, um das folgende Problem zu lösen:\nVertauscht die Groß- und Kleinschreibung jedes Buchstabens in einem gegebenen String.\nDie Funktion nimmt ein einziges Argument, input_string, das ein String ist, der nur englische Buchstaben ohne Leerzeichen oder andere Zeichenarten enthält.\nSie gibt einen neuen String zurück, bei dem jeder Kleinbuchstabe in einen Großbuchstaben und jeder Großbuchstabe in einen Kleinbuchstaben umgewandelt wird.\n\nBeispiel:\n>>> swap_case(\"HelloWorld\")\n\"hELLOwORLD\"\n>>> swap_case(\"Ruby\")\n\"rUBY\"",
      "ha": "Rubuta wani aiki na ruby `def swap_case(input_string)` don warware matsalar mai zuwa:  \nCanza haruffan kowane wasika a cikin wani baƙaƙe.  \nAikin yana ɗaukar hujja guda ɗaya, input_string, wanda shine baƙaƙe mai ɗauke da haruffan Ingilishi kawai ba tare da sarari ko wasu nau'ikan haruffa ba.  \nYana dawowa da sabon baƙaƙe inda kowace ƙaramar wasika ta koma babba kuma kowace babbar wasika ta koma ƙaramar wasika.\n\nMisali:\n>>> swap_case(\"HelloWorld\")\n\"hELLOwORLD\"\n>>> swap_case(\"Ruby\")\n\"rUBY\"",
      "hi": "`def swap_case(input_string)` निम्नलिखित समस्या को हल करने के लिए एक रूबी फ़ंक्शन लिखें:\nदिए गए स्ट्रिंग में प्रत्येक अक्षर का केस बदलता है।\nयह फ़ंक्शन एक एकल तर्क लेता है, `input_string`, जो कि एक स्ट्रिंग है जिसमें केवल अंग्रेजी वर्णमाला के अक्षर होते हैं, बिना किसी स्पेस या अन्य प्रकार के वर्णों के।\nयह एक नई स्ट्रिंग लौटाता है जहां हर लोअरकेस अक्षर को अपरकेस में और हर अपरकेस अक्षर को लोअरकेस में परिवर्तित किया जाता है।\n\nउदाहरण:\n>>> swap_case(\"HelloWorld\")\n\"hELLOwORLD\"\n>>> swap_case(\"Ruby\")\n\"rUBY\"",
      "hu": "Írj egy ruby függvényt `def swap_case(input_string)` a következő probléma megoldására:\nFelcseréli minden betű esetét egy adott szövegben.\nA függvény egyetlen argumentumot vesz, input_string, amely egy szöveg, ami csak angol ábécé betűket tartalmaz, szóközök vagy más karakterek nélkül.\nVisszaad egy új szöveget, ahol minden kisbetű nagybetűvé és minden nagybetű kisbetűvé van alakítva.\n\nPélda:\n>>> swap_case(\"HelloWorld\")\n\"hELLOwORLD\"\n>>> swap_case(\"Ruby\")\n\"rUBY\""
    },
    "instruction_bertscore": {
      "sq": "0.9633930166664132",
      "hy": "0.9568711867355137",
      "bn": "0.970502991155557",
      "bg": "0.9676997205880117",
      "zh": "0.9514052759101956",
      "fr": "0.9885829243284957",
      "de": "0.9719857669499825",
      "ha": "0.9577451604120673",
      "hi": "0.9590020934632559",
      "hu": "0.953559422392519"
    },
    "level": "easy",
    "test": "raise 'Test failed' unless swap_case(\"HelloWorld\") == \"hELLOwORLD\"\nraise 'Test failed' unless swap_case(\"Ruby\") == \"rUBY\"\nraise 'Test failed' unless swap_case(\"AeDb\") == \"aEdB\"\nraise 'Test failed' unless swap_case(\"JAVA\") == \"java\"\nraise 'Test failed' unless swap_case(\"python\") == \"PYTHON\"\n  \n\nputs 'All tests passed!'",
    "entry_point": "swap_case",
    "signature": "def swap_case(input_string)",
    "docstring": {
      "en": "Swaps the case of each letter in a given string.\nThe function takes a single argument, input_string, which is a string containing only English alphabets without any spaces or other types of characters.\nIt returns a new string where every lowercase letter is converted to uppercase and every uppercase letter is converted to lowercase.\n\nExample:\n>>> swap_case(\"HelloWorld\")\n\"hELLOwORLD\"\n>>> swap_case(\"Ruby\")\n\"rUBY\"",
      "sq": "Ndërron rastin e secilës shkronjë në një varg të dhënë.\nFunksioni merr një argument të vetëm, input_string, i cili është një varg që përmban vetëm alfabetin anglez pa hapësira ose lloje të tjera karakteresh.\nKthen një varg të ri ku çdo shkronjë e vogël konvertohet në të madhe dhe çdo shkronjë e madhe konvertohet në të vogël.\n\nShembull:\n>>> swap_case(\"HelloWorld\")\n\"hELLOwORLD\"\n>>> swap_case(\"Ruby\")\n\"rUBY\"",
      "hy": "Փոխում է տրված տողի յուրաքանչյուր տառի ռեգիստրը։\nՖունկցիան ընդունում է մեկ արգումենտ՝ input_string, որը տող է, որը պարունակում է միայն անգլերեն այբուբենի տառեր՝ առանց բացատների կամ այլ տեսակի սիմվոլների։\nԱյն վերադարձնում է նոր տող, որտեղ յուրաքանչյուր փոքրատառ տառ փոխարկվում է մեծատառի, իսկ յուրաքանչյուր մեծատառ տառ՝ փոքրատառի։\n\nՕրինակ:\n>>> swap_case(\"HelloWorld\")\n\"hELLOwORLD\"\n>>> swap_case(\"Ruby\")\n\"rUBY\"",
      "bn": "প্রত্যেকটি অক্ষরের কেস পরিবর্তন করে একটি প্রদত্ত স্ট্রিং-এ। \nফাংশনটি একটি একক আর্গুমেন্ট গ্রহণ করে, input_string, যা একটি স্ট্রিং যা শুধুমাত্র ইংরেজি বর্ণমালা ধারণ করে, কোনো ফাঁকা স্থান বা অন্যান্য ধরনের অক্ষর ছাড়াই। \nএটি একটি নতুন স্ট্রিং ফেরত দেয় যেখানে প্রতিটি ছোট হাতের অক্ষর বড় হাতের অক্ষরে পরিবর্তিত হয় এবং প্রতিটি বড় হাতের অক্ষর ছোট হাতের অক্ষরে পরিবর্তিত হয়।\n\nউদাহরণ:\n>>> swap_case(\"HelloWorld\")\n\"hELLOwORLD\"\n>>> swap_case(\"Ruby\")\n\"rUBY\"",
      "bg": "Разменя регистъра на всяка буква в даден низ. \nФункцията приема един аргумент, input_string, който е низ, съдържащ само английски букви без никакви интервали или други видове символи. \nТя връща нов низ, където всяка малка буква е преобразувана в главна, а всяка главна буква е преобразувана в малка.\n\nПример:\n>>> swap_case(\"HelloWorld\")\n\"hELLOwORLD\"\n>>> swap_case(\"Ruby\")\n\"rUBY\"",
      "zh": "交换给定字符串中每个字母的大小写。\n该函数接受一个参数，input_string，这是一个仅包含英文字母的字符串，没有空格或其他类型的字符。\n它返回一个新字符串，其中每个小写字母转换为大写字母，每个大写字母转换为小写字母。\n\n示例：\n>>> swap_case(\"HelloWorld\")\n\"hELLOwORLD\"\n>>> swap_case(\"Ruby\")\n\"rUBY\"",
      "fr": "Échange la casse de chaque lettre dans une chaîne donnée.  \nLa fonction prend un seul argument, input_string, qui est une chaîne contenant uniquement des alphabets anglais sans espaces ni autres types de caractères.  \nElle retourne une nouvelle chaîne où chaque lettre minuscule est convertie en majuscule et chaque lettre majuscule est convertie en minuscule.  \n\nExemple :  \n>>> swap_case(\"HelloWorld\")  \n\"hELLOwORLD\"  \n>>> swap_case(\"Ruby\")  \n\"rUBY\"  ",
      "de": "Vertauscht die Groß- und Kleinschreibung jedes Buchstabens in einem gegebenen String.  \nDie Funktion nimmt ein einzelnes Argument, input_string, das ein String ist, der nur englische Buchstaben ohne Leerzeichen oder andere Zeichenarten enthält.  \nSie gibt einen neuen String zurück, bei dem jeder Kleinbuchstabe in einen Großbuchstaben und jeder Großbuchstabe in einen Kleinbuchstaben umgewandelt wird.  \n\nBeispiel:  \n>>> swap_case(\"HelloWorld\")  \n\"hELLOwORLD\"  \n>>> swap_case(\"Ruby\")  \n\"rUBY\"  ",
      "ha": "Sauya harafin kowanne harafi a cikin kowane rubutu da aka bayar.\n\nAikin yana ɗaukar hujja guda ɗaya, input_string, wanda rubutu ne da ke ɗauke da haruffan Turanci kawai ba tare da sarari ko wasu nau'ikan haruffa ba.\n\nYana dawo da sabon rubutu inda kowane ƙaramin harafi aka canza zuwa babba kuma kowane babban harafi aka canza zuwa ƙarami.\n\nMisali:\n>>> swap_case(\"HelloWorld\")\n\"hELLOwORLD\"\n>>> swap_case(\"Ruby\")\n\"rUBY\"",
      "hi": "प्रत्येक अक्षर के मामले को दिए गए स्ट्रिंग में बदलता है।  \nयह फ़ंक्शन एकल तर्क लेता है, input_string, जो एक स्ट्रिंग है जिसमें केवल अंग्रेजी अक्षर होते हैं, बिना किसी स्पेस या अन्य प्रकार के वर्णों के।  \nयह एक नया स्ट्रिंग लौटाता है जहाँ प्रत्येक छोटे अक्षर को बड़े अक्षर में और प्रत्येक बड़े अक्षर को छोटे अक्षर में बदला जाता है।  \n\nउदाहरण:  \n>>> swap_case(\"HelloWorld\")  \n\"hELLOwORLD\"  \n>>> swap_case(\"Ruby\")  \n\"rUBY\"  ",
      "hu": "Megcseréli minden betű esetét egy adott sztringben.\nA függvény egyetlen argumentumot vesz fel, az input_string-et, amely egy sztring, amely csak angol ábécé betűit tartalmazza, szóközök vagy más típusú karakterek nélkül.\nEgy új sztringet ad vissza, ahol minden kisbetű nagybetűvé alakul, és minden nagybetű kisbetűvé alakul.\n\nPélda:\n>>> swap_case(\"HelloWorld\")\n\"hELLOwORLD\"\n>>> swap_case(\"Ruby\")\n\"rUBY\""
    },
    "docstring_bertscore": {
      "sq": "0.9586908396561743",
      "hy": "0.9379347593595526",
      "bn": "0.9663929313111831",
      "bg": "0.9709940054574753",
      "zh": "0.9451702682495104",
      "fr": "0.9813901209704603",
      "de": "0.9691507155214715",
      "ha": "0.9251018463320316",
      "hi": "0.9496054860276385",
      "hu": "0.9690351126397092"
    }
  },
  {
    "task_id": "Ruby/7",
    "prompt": {
      "en": "# Finds the maximum value in an array and returns its value along with its index.\n# The function takes a single argument, arr, which is an array of integers. The array size should be between 1 and 100.\n# It returns an array containing the maximum value and its index in the format [max_value, index].\n#\n# Example:\n# >>> find_max_with_index([3, 2, 1])\n# [3, 0]\n# >>> find_max_with_index([10, 20, 30, 40])\n# [40, 3]\n\ndef find_max_with_index(arr)",
      "sq": "# Gjen vlerën maksimale në një varg dhe kthen vlerën e saj së bashku me indeksin e saj.\n# Funksioni merr një argument të vetëm, arr, i cili është një varg me numra të plotë. Madhësia e vargut duhet të jetë midis 1 dhe 100.\n# Kthen një varg që përmban vlerën maksimale dhe indeksin e saj në formatin [max_value, index].\n#\n# Shembull:\n# >>> find_max_with_index([3, 2, 1])\n# [3, 0]\n# >>> find_max_with_index([10, 20, 30, 40])\n# [40, 3]\n\ndef find_max_with_index(arr)",
      "hy": "# Գտնում է զանգվածի առավելագույն արժեքը և վերադարձնում դրա արժեքը և ինդեքսը։\n# Ֆունկցիան ընդունում է մեկ արգումենտ՝ arr, որը ամբողջ թվերի զանգված է։ Զանգվածի չափը պետք է լինի 1-ից մինչև 100։\n# Այն վերադարձնում է զանգված, որը պարունակում է առավելագույն արժեքը և դրա ինդեքսը [max_value, index] ձևաչափով։\n#\n# Օրինակ:\n# >>> find_max_with_index([3, 2, 1])\n# [3, 0]\n# >>> find_max_with_index([10, 20, 30, 40])\n# [40, 3]\n\ndef find_max_with_index(arr)",
      "bn": "# একটি অ্যারেতে সর্বাধিক মান খুঁজে বের করে এবং এর মান এবং সূচক ফেরত দেয়।\n# ফাংশনটি একটি একক আর্গুমেন্ট গ্রহণ করে, arr, যা পূর্ণসংখ্যার একটি অ্যারে। অ্যারের আকার 1 থেকে 100 এর মধ্যে হওয়া উচিত।\n# এটি একটি অ্যারে ফেরত দেয় যা সর্বাধিক মান এবং এর সূচক [max_value, index] বিন্যাসে ধারণ করে।\n#\n# উদাহরণ:\n# >>> find_max_with_index([3, 2, 1])\n# [3, 0]\n# >>> find_max_with_index([10, 20, 30, 40])\n# [40, 3]\n\ndef find_max_with_index(arr)",
      "bg": "# Намира максималната стойност в масив и връща нейната стойност заедно с индекса ѝ.\n# Функцията приема един аргумент, arr, който е масив от цели числа. Размерът на масива трябва да бъде между 1 и 100.\n# Връща масив, съдържащ максималната стойност и нейния индекс във формат [max_value, index].\n#\n# Пример:\n# >>> find_max_with_index([3, 2, 1])\n# [3, 0]\n# >>> find_max_with_index([10, 20, 30, 40])\n# [40, 3]\n\ndef find_max_with_index(arr)",
      "zh": "# 查找数组中的最大值，并返回其值及其索引。\n# 该函数接受一个参数，arr，这是一个整数数组。数组的大小应在1到100之间。\n# 它返回一个包含最大值及其索引的数组，格式为[max_value, index]。\n#\n# 示例:\n# >>> find_max_with_index([3, 2, 1])\n# [3, 0]\n# >>> find_max_with_index([10, 20, 30, 40])\n# [40, 3]\n\ndef find_max_with_index(arr)",
      "fr": "# Trouve la valeur maximale dans un tableau et renvoie sa valeur ainsi que son indice.\n# La fonction prend un seul argument, arr, qui est un tableau d'entiers. La taille du tableau doit être comprise entre 1 et 100.\n# Elle renvoie un tableau contenant la valeur maximale et son indice au format [max_value, index].\n#\n# Exemple:\n# >>> find_max_with_index([3, 2, 1])\n# [3, 0]\n# >>> find_max_with_index([10, 20, 30, 40])\n# [40, 3]\n\ndef find_max_with_index(arr)",
      "de": "# Findet den maximalen Wert in einem Array und gibt diesen Wert zusammen mit seinem Index zurück.\n# Die Funktion nimmt ein einziges Argument, arr, das ein Array von ganzen Zahlen ist. Die Arraygröße sollte zwischen 1 und 100 liegen.\n# Sie gibt ein Array zurück, das den maximalen Wert und seinen Index im Format [max_value, index] enthält.\n#\n# Beispiel:\n# >>> find_max_with_index([3, 2, 1])\n# [3, 0]\n# >>> find_max_with_index([10, 20, 30, 40])\n# [40, 3]\n\ndef find_max_with_index(arr)",
      "ha": "# Nemi mafi girman ƙima a cikin jerin kuma mayar da ƙimar tare da inda take.\n# Aikin yana ɗaukar hujja guda ɗaya, arr, wanda jerin lambobi ne. Girman jerin ya kamata ya kasance tsakanin 1 da 100.\n# Yana mayar da jerin da ke ƙunshe da mafi girman ƙima da inda take a cikin tsarin [max_value, index].\n#\n# Misali:\n# >>> find_max_with_index([3, 2, 1])\n# [3, 0]\n# >>> find_max_with_index([10, 20, 30, 40])\n# [40, 3]\n\ndef find_max_with_index(arr)",
      "hi": "# एक array में अधिकतम मान खोजता है और उसके मान के साथ उसके सूचकांक को लौटाता है।\n# फ़ंक्शन एकल तर्क लेता है, arr, जो पूर्णांकों का एक array है। array का आकार 1 और 100 के बीच होना चाहिए।\n# यह अधिकतम मान और उसके सूचकांक को [max_value, index] प्रारूप में लौटाता है।\n#\n# उदाहरण:\n# >>> find_max_with_index([3, 2, 1])\n# [3, 0]\n# >>> find_max_with_index([10, 20, 30, 40])\n# [40, 3]\n\ndef find_max_with_index(arr)",
      "hu": "# Megkeresi a maximális értéket egy tömbben, és visszaadja annak értékét a hozzá tartozó indexszel együtt.\n# A függvény egyetlen argumentumot vesz fel, az arr-t, amely egy egész számokat tartalmazó tömb. A tömb mérete 1 és 100 között kell legyen.\n# Egy tömböt ad vissza, amely tartalmazza a maximális értéket és annak indexét a következő formátumban: [max_value, index].\n#\n# Példa:\n# >>> find_max_with_index([3, 2, 1])\n# [3, 0]\n# >>> find_max_with_index([10, 20, 30, 40])\n# [40, 3]\n\ndef find_max_with_index(arr)"
    },
    "prompt_bertscore": {
      "sq": "0.9904403170215529",
      "hy": "0.9779865893914275",
      "bn": "0.991385797635279",
      "bg": "0.9884559995150144",
      "zh": "0.9741756669008921",
      "fr": "0.9898523710936896",
      "de": "0.9962663447276872",
      "ha": "0.9556903291202613",
      "hi": "0.9845614536340633",
      "hu": "0.9771876979989051"
    },
    "canonical_solution": "    max_value = arr[0]\n    index = 0\n    arr.each_with_index do |value, idx|\n      if value > max_value\n        max_value = value\n        index = idx\n      end\n    end\n    [max_value, index]\n  end",
    "instruction": {
      "en": "Write a ruby function `def find_max_with_index(arr)` to solve the following problem:\nFinds the maximum value in an array and returns its value along with its index.\nThe function takes a single argument, arr, which is an array of integers. The array size should be between 1 and 100.\nIt returns an array containing the maximum value and its index in the format [max_value, index].\n\nExample:\n>>> find_max_with_index([3, 2, 1])\n[3, 0]\n>>> find_max_with_index([10, 20, 30, 40])\n[40, 3]",
      "sq": "Shkruani një funksion ruby `def find_max_with_index(arr)` për të zgjidhur problemin në vijim:\nGjen vlerën maksimale në një varg dhe kthen vlerën e saj së bashku me indeksin e saj.\nFunksioni merr një argument të vetëm, arr, i cili është një varg me numra të plotë. Madhësia e vargut duhet të jetë midis 1 dhe 100.\nKthen një varg që përmban vlerën maksimale dhe indeksin e saj në formatin [max_value, index].\n\nShembull:\n>>> find_max_with_index([3, 2, 1])\n[3, 0]\n>>> find_max_with_index([10, 20, 30, 40])\n[40, 3]",
      "hy": "Ruby ֆունկցիա գրեք `def find_max_with_index(arr)`՝ հետևյալ խնդիրը լուծելու համար:\nԳտնում է զանգվածի առավելագույն արժեքը և վերադարձնում դրա արժեքը և ինդեքսը:\nՖունկցիան ընդունում է մեկ արգումենտ, arr, որը ամբողջ թվերի զանգված է։ Զանգվածի չափը պետք է լինի 1-ից 100 միջակայքում:\nԱյն վերադարձնում է զանգված, որը պարունակում է առավելագույն արժեքը և դրա ինդեքսը [max_value, index] ձևաչափով:\n\nՕրինակ:\n>>> find_max_with_index([3, 2, 1])\n[3, 0]\n>>> find_max_with_index([10, 20, 30, 40])\n[40, 3]",
      "bn": "রুবি ফাংশন `def find_max_with_index(arr)` লিখুন নিম্নলিখিত সমস্যার সমাধানের জন্য:\nএকটি অ্যারেতে সর্বাধিক মান খুঁজে বের করে এবং এর মান তার সূচকের সাথে ফেরত দেয়।\nফাংশনটি একটি একক আর্গুমেন্ট গ্রহণ করে, arr, যা পূর্ণসংখ্যার একটি অ্যারে। অ্যারের আকার 1 এবং 100 এর মধ্যে হওয়া উচিত।\nএটি একটি অ্যারে ফেরত দেয় যা সর্বাধিক মান এবং তার সূচক [max_value, index] ফরম্যাটে ধারণ করে।\n\nউদাহরণ:\n>>> find_max_with_index([3, 2, 1])\n[3, 0]\n>>> find_max_with_index([10, 20, 30, 40])\n[40, 3]",
      "bg": "Напишете функция на Ruby `def find_max_with_index(arr)` за решаване на следния проблем:\nНамира максималната стойност в масив и връща нейната стойност заедно с индекса й.\nФункцията приема един аргумент, arr, който е масив от цели числа. Размерът на масива трябва да бъде между 1 и 100.\nТя връща масив, съдържащ максималната стойност и нейния индекс във формат [max_value, index].\n\nПример:\n>>> find_max_with_index([3, 2, 1])\n[3, 0]\n>>> find_max_with_index([10, 20, 30, 40])\n[40, 3]",
      "zh": "编写一个 ruby 函数 `def find_max_with_index(arr)` 来解决以下问题：\n查找数组中的最大值，并返回其值及其索引。\n该函数接受一个参数 arr，它是一个整数数组。数组大小应在 1 到 100 之间。\n它返回一个包含最大值及其索引的数组，格式为 [max_value, index]。\n\n示例：\n>>> find_max_with_index([3, 2, 1])\n[3, 0]\n>>> find_max_with_index([10, 20, 30, 40])\n[40, 3]",
      "fr": "Écrire une fonction ruby `def find_max_with_index(arr)` pour résoudre le problème suivant :\nTrouve la valeur maximale dans un tableau et renvoie sa valeur ainsi que son indice.\nLa fonction prend un seul argument, arr, qui est un tableau d'entiers. La taille du tableau doit être comprise entre 1 et 100.\nElle renvoie un tableau contenant la valeur maximale et son indice au format [max_value, index].\n\nExemple :\n>>> find_max_with_index([3, 2, 1])\n[3, 0]\n>>> find_max_with_index([10, 20, 30, 40])\n[40, 3]",
      "de": "Schreiben Sie eine Ruby-Funktion `def find_max_with_index(arr)`, um das folgende Problem zu lösen:\nFindet den maximalen Wert in einem Array und gibt diesen Wert zusammen mit seinem Index zurück.\nDie Funktion nimmt ein einzelnes Argument, arr, das ein Array von ganzen Zahlen ist. Die Arraygröße sollte zwischen 1 und 100 liegen.\nSie gibt ein Array zurück, das den maximalen Wert und seinen Index im Format [max_value, index] enthält.\n\nBeispiel:\n>>> find_max_with_index([3, 2, 1])\n[3, 0]\n>>> find_max_with_index([10, 20, 30, 40])\n[40, 3]",
      "ha": "Rubuta aikin ruby `def find_max_with_index(arr)` don warware matsalar mai zuwa:\nNemo mafi girman ƙima a cikin jerin kuma mayar da ƙimar tare da ma'aunin sa.\nAikin yana ɗaukar hujja guda ɗaya, arr, wanda jerin lambobi ne. Girman jerin ya kamata ya kasance tsakanin 1 da 100.\nYana mayar da jerin da ke ɗauke da mafi girman ƙima da ma'aunin sa a cikin tsarin [max_value, index].\n\nMisali:\n>>> find_max_with_index([3, 2, 1])\n[3, 0]\n>>> find_max_with_index([10, 20, 30, 40])\n[40, 3]",
      "hi": "रूबी फ़ंक्शन `def find_max_with_index(arr)` लिखें ताकि निम्नलिखित समस्या का समाधान किया जा सके:\nएक सरणी में अधिकतम मान खोजता है और उसके मान के साथ उसके इंडेक्स को लौटाता है।\nयह फ़ंक्शन एक एकल तर्क लेता है, arr, जो पूर्णांकों की एक सरणी है। सरणी का आकार 1 और 100 के बीच होना चाहिए।\nयह अधिकतम मान और उसके इंडेक्स को [max_value, index] प्रारूप में एक सरणी के रूप में लौटाता है।\n\nउदाहरण:\n>>> find_max_with_index([3, 2, 1])\n[3, 0]\n>>> find_max_with_index([10, 20, 30, 40])\n[40, 3]",
      "hu": "Írj egy ruby függvényt `def find_max_with_index(arr)` a következő probléma megoldására:\nMegkeresi a maximális értéket egy tömbben, és visszaadja annak értékét a hozzá tartozó indexszel együtt.\nA függvény egyetlen argumentumot vesz fel, arr, amely egy egész számokat tartalmazó tömb. A tömb méretének 1 és 100 között kell lennie.\nEgy tömböt ad vissza, amely a maximális értéket és annak indexét tartalmazza a következő formátumban: [max_value, index].\n\nPélda:\n>>> find_max_with_index([3, 2, 1])\n[3, 0]\n>>> find_max_with_index([10, 20, 30, 40])\n[40, 3]"
    },
    "instruction_bertscore": {
      "sq": "0.9922373260787756",
      "hy": "0.9621275425088399",
      "bn": "0.9907803722338846",
      "bg": "0.9884414994971988",
      "zh": "0.9721818151360639",
      "fr": "0.9897613983791756",
      "de": "0.9949287677417983",
      "ha": "0.965196183265448",
      "hi": "0.9670555622623155",
      "hu": "0.9800648590681955"
    },
    "level": "easy",
    "test": "raise 'Test failed' unless find_max_with_index([3, 2, 1]) == [3, 0]\nraise 'Test failed' unless find_max_with_index([10, 20, 30, 40]) == [40, 3]\nraise 'Test failed' unless find_max_with_index([5]) == [5, 0]\nraise 'Test failed' unless find_max_with_index([-3, -2, -1, -4]) == [-1, 2]\nraise 'Test failed' unless find_max_with_index([100, 200, 100, 50]) == [200, 1]\n  \nputs 'All tests passed!'",
    "entry_point": "find_max_with_index",
    "signature": "def find_max_with_index(arr)",
    "docstring": {
      "en": "Finds the maximum value in an array and returns its value along with its index.\nThe function takes a single argument, arr, which is an array of integers. The array size should be between 1 and 100.\nIt returns an array containing the maximum value and its index in the format [max_value, index].\n\nExample:\n>>> find_max_with_index([3, 2, 1])\n[3, 0]\n>>> find_max_with_index([10, 20, 30, 40])\n[40, 3]",
      "sq": "Gjen vlerën maksimale në një varg dhe kthen vlerën e saj së bashku me indeksin e saj.\nFunksioni merr një argument të vetëm, arr, i cili është një varg me numra të plotë. Madhësia e vargut duhet të jetë midis 1 dhe 100.\nKthen një varg që përmban vlerën maksimale dhe indeksin e saj në formatin [max_value, index].\n\nShembull:\n>>> find_max_with_index([3, 2, 1])\n[3, 0]\n>>> find_max_with_index([10, 20, 30, 40])\n[40, 3]",
      "hy": "Գտնում է զանգվածի առավելագույն արժեքը և վերադարձնում դրա արժեքը և ինդեքսը:\nՖունկցիան ընդունում է մեկ արգումենտ, arr, որը ամբողջ թվերի զանգված է: Զանգվածի չափը պետք է լինի 1-ից մինչև 100:\nԱյն վերադարձնում է զանգված, որը պարունակում է առավելագույն արժեքը և դրա ինդեքսը [max_value, index] ձևաչափով:\n\nՕրինակ:\n>>> find_max_with_index([3, 2, 1])\n[3, 0]\n>>> find_max_with_index([10, 20, 30, 40])\n[40, 3]",
      "bn": "একটি অ্যারের সর্বাধিক মান খুঁজে বের করে এবং এর মান সহ এর সূচক ফেরত দেয়।\nফাংশনটি একটি একক আর্গুমেন্ট গ্রহণ করে, arr, যা পূর্ণসংখ্যার একটি অ্যারে। অ্যারের আকার 1 এবং 100 এর মধ্যে হওয়া উচিত।\nএটি সর্বাধিক মান এবং এর সূচক সহ একটি অ্যারে ফেরত দেয় [max_value, index] বিন্যাসে।\n\nউদাহরণ:\n>>> find_max_with_index([3, 2, 1])\n[3, 0]\n>>> find_max_with_index([10, 20, 30, 40])\n[40, 3]",
      "bg": "Намира максималната стойност в масив и връща нейната стойност заедно с индекса ѝ. \nФункцията приема един аргумент, arr, който е масив от цели числа. Размерът на масива трябва да бъде между 1 и 100. \nТя връща масив, съдържащ максималната стойност и нейния индекс във формата [max_value, index].\n\nПример:\n>>> find_max_with_index([3, 2, 1])\n[3, 0]\n>>> find_max_with_index([10, 20, 30, 40])\n[40, 3]",
      "zh": "查找数组中的最大值，并返回其值及其索引。\n该函数接受一个参数，arr，这是一个整数数组。数组大小应在1到100之间。\n它返回一个数组，包含最大值及其索引，格式为[max_value, index]。\n\n示例：\n>>> find_max_with_index([3, 2, 1])\n[3, 0]\n>>> find_max_with_index([10, 20, 30, 40])\n[40, 3]",
      "fr": "Trouve la valeur maximale dans un tableau et renvoie sa valeur ainsi que son indice. La fonction prend un seul argument, arr, qui est un tableau d'entiers. La taille du tableau doit être comprise entre 1 et 100. Elle renvoie un tableau contenant la valeur maximale et son indice au format [max_value, index].\n\nExemple :\n>>> find_max_with_index([3, 2, 1])\n[3, 0]\n>>> find_max_with_index([10, 20, 30, 40])\n[40, 3]",
      "de": "Findet den maximalen Wert in einem Array und gibt dessen Wert zusammen mit seinem Index zurück.  \nDie Funktion nimmt ein einzelnes Argument, arr, das ein Array von ganzen Zahlen ist. Die Arraygröße sollte zwischen 1 und 100 liegen.  \nSie gibt ein Array zurück, das den maximalen Wert und seinen Index im Format [max_value, index] enthält.\n\nBeispiel:\n>>> find_max_with_index([3, 2, 1])\n[3, 0]\n>>> find_max_with_index([10, 20, 30, 40])\n[40, 3]",
      "ha": "Nemo mafi girman ƙima a cikin jerin kuma ya dawo da ƙimar tare da maƙasudin sa.\nAikin yana ɗaukar hujja guda ɗaya, arr, wanda jerin lambobi ne. Girman jerin ya kamata ya kasance tsakanin 1 da 100.\nYana dawowa da jerin da ke ɗauke da mafi girman ƙima da maƙasudin sa a cikin tsarin [max_value, index].\n\nMisali:\n>>> find_max_with_index([3, 2, 1])\n[3, 0]\n>>> find_max_with_index([10, 20, 30, 40])\n[40, 3]",
      "hi": "एक सरणी में अधिकतम मान खोजता है और उसके मान के साथ उसके सूचकांक को लौटाता है। \nयह फ़ंक्शन एकल तर्क, arr, लेता है, जो पूर्णांकों की एक सरणी है। सरणी का आकार 1 और 100 के बीच होना चाहिए। \nयह एक सरणी लौटाता है जिसमें अधिकतम मान और उसके सूचकांक को [max_value, index] प्रारूप में होता है।\n\nउदाहरण:\n>>> find_max_with_index([3, 2, 1])\n[3, 0]\n>>> find_max_with_index([10, 20, 30, 40])\n[40, 3]",
      "hu": "Megkeresi a maximális értéket egy tömbben, és visszaadja annak értékét a hozzá tartozó indexszel együtt. A függvény egyetlen argumentumot vesz fel, az arr-t, amely egy egész számokat tartalmazó tömb. A tömb méretének 1 és 100 között kell lennie. Egy tömböt ad vissza, amely a maximális értéket és annak indexét tartalmazza a következő formátumban: [max_value, index].\n\nPélda:\n>>> find_max_with_index([3, 2, 1])\n[3, 0]\n>>> find_max_with_index([10, 20, 30, 40])\n[40, 3]"
    },
    "docstring_bertscore": {
      "sq": "0.9886121229945077",
      "hy": "0.9760433883737631",
      "bn": "0.977027204651029",
      "bg": "0.9865783465230916",
      "zh": "0.9730905491292985",
      "fr": "0.9792359744881369",
      "de": "1",
      "ha": "0.9494100337327002",
      "hi": "0.9821314095524825",
      "hu": "0.9734782756330786"
    }
  },
  {
    "task_id": "Ruby/8",
    "prompt": {
      "en": "# Calculates the minimum time required for a character to reach the top of a building with varying floor heights.\n# The character can move up one or two floors at a time, but cannot use the two-floor jump consecutively. \n# Moving up one floor takes one unit of time, while jumping up two floors is instantaneous.\n#\n# Args:\n# - floor_heights (Array): An array of integers representing the height of each floor.\n#\n# Returns:\n# - Integer: The minimum time required to reach the top of the building.\n#\n# Example:\n# >>> minimum_time_to_top([3, 5, 1, 8, 4])\n# 1\n\ndef minimum_time_to_top(heights)",
      "sq": "# Llogarit kohën minimale të kërkuar që një karakter të arrijë majën e një ndërtese me lartësi të ndryshme katësh.\n# Karakteri mund të ngjitet një ose dy kate njëherësh, por nuk mund të përdorë kërcimin me dy kate radhazi.\n# Ngjitja një kat merr një njësi kohe, ndërsa kërcimi me dy kate është i menjëhershëm.\n#\n# Argumentet:\n# - floor_heights (Array): Një varg i numrave të plotë që përfaqëson lartësinë e secilit kat.\n#\n# Kthen:\n# - Integer: Koha minimale e kërkuar për të arritur majën e ndërtesës.\n#\n# Shembull:\n# >>> minimum_time_to_top([3, 5, 1, 8, 4])\n# 1\n\ndef minimum_time_to_top(heights)",
      "hy": "# Հաշվում է նվազագույն ժամանակը, որը պահանջվում է կերպարին հասնելու համար շենքի գագաթին տարբեր հարկերի բարձրություններով:\n# Կերպարը կարող է շարժվել մեկ կամ երկու հարկ բարձրանալով միաժամանակ, բայց չի կարող օգտագործել երկու հարկի թռիչքը հաջորդաբար:\n# Մեկ հարկ բարձրանալը տևում է մեկ միավոր ժամանակ, մինչդեռ երկու հարկ բարձրանալը ակնթարթային է:\n#\n# Պարամետրեր:\n# - floor_heights (Array): Թվերի զանգված, որը ներկայացնում է յուրաքանչյուր հարկի բարձրությունը:\n#\n# Վերադարձնում է:\n# - Integer: Նվազագույն ժամանակը, որը պահանջվում է հասնելու համար շենքի գագաթին:\n#\n# Օրինակ:\n# >>> minimum_time_to_top([3, 5, 1, 8, 4])\n# 1\n\ndef minimum_time_to_top(heights)",
      "bn": "# একটি চরিত্রকে বিভিন্ন তলার উচ্চতার একটি ভবনের শীর্ষে পৌঁছানোর জন্য প্রয়োজনীয় সর্বনিম্ন সময় গণনা করে।\n# চরিত্রটি এক বা দুই তলা উপরে উঠতে পারে, কিন্তু পরপর দুই তলা লাফ দিতে পারে না।\n# এক তলা উপরে উঠতে এক ইউনিট সময় লাগে, যখন দুই তলা লাফ দেওয়া তাৎক্ষণিক।\n#\n# আর্গুমেন্টসমূহ:\n# - floor_heights (Array): প্রতিটি তলার উচ্চতা প্রতিনিধিত্বকারী পূর্ণসংখ্যার একটি অ্যারে।\n#\n# রিটার্ন করে:\n# - পূর্ণসংখ্যা: ভবনের শীর্ষে পৌঁছানোর জন্য প্রয়োজনীয় সর্বনিম্ন সময়।\n#\n# উদাহরণ:\n# >>> minimum_time_to_top([3, 5, 1, 8, 4])\n# 1\n\ndef minimum_time_to_top(heights)",
      "bg": "# Изчислява минималното време, необходимо на герой да достигне върха на сграда с различни височини на етажите.\n# Героят може да се движи нагоре с един или два етажа наведнъж, но не може да използва скока от два етажа последователно.\n# Движението нагоре с един етаж отнема една единица време, докато скокът нагоре с два етажа е мигновен.\n#\n# Аргументи:\n# - floor_heights (Масив): Масив от цели числа, представляващи височината на всеки етаж.\n#\n# Връща:\n# - Цяло число: Минималното време, необходимо за достигане на върха на сградата.\n#\n# Пример:\n# >>> minimum_time_to_top([3, 5, 1, 8, 4])\n# 1\n\ndef minimum_time_to_top(heights)",
      "zh": "# 计算角色到达具有不同楼层高度的建筑物顶部所需的最短时间。\n# 角色每次可以向上移动一层或两层，但不能连续使用两层跳跃。\n# 向上移动一层需要一个时间单位，而跳跃两层是瞬时的。\n#\n# 参数:\n# - floor_heights (数组): 一个整数数组，表示每层的高度。\n#\n# 返回:\n# - 整数: 到达建筑物顶部所需的最短时间。\n#\n# 示例:\n# >>> minimum_time_to_top([3, 5, 1, 8, 4])\n# 1\n\ndef minimum_time_to_top(heights)",
      "fr": "# Calcule le temps minimum requis pour qu'un personnage atteigne le sommet d'un bâtiment avec des hauteurs d'étage variables.\n# Le personnage peut monter d'un ou deux étages à la fois, mais ne peut pas utiliser le saut de deux étages consécutivement.\n# Monter d'un étage prend une unité de temps, tandis que sauter de deux étages est instantané.\n#\n# Arguments:\n# - floor_heights (Array): Un tableau d'entiers représentant la hauteur de chaque étage.\n#\n# Renvoie:\n# - Entier: Le temps minimum requis pour atteindre le sommet du bâtiment.\n#\n# Exemple:\n# >>> minimum_time_to_top([3, 5, 1, 8, 4])\n# 1\n\ndef minimum_time_to_top(heights)",
      "de": "# Berechnet die minimale Zeit, die erforderlich ist, damit eine Figur die Spitze eines Gebäudes mit unterschiedlichen Stockwerkshöhen erreicht.\n# Die Figur kann sich jeweils um ein oder zwei Stockwerke nach oben bewegen, darf jedoch den Zwei-Stockwerke-Sprung nicht hintereinander verwenden.\n# Das Bewegen um ein Stockwerk nach oben dauert eine Zeiteinheit, während der Sprung um zwei Stockwerke sofort erfolgt.\n#\n# Argumente:\n# - floor_heights (Array): Ein Array von ganzen Zahlen, das die Höhe jedes Stockwerks darstellt.\n#\n# Rückgabewert:\n# - Integer: Die minimale Zeit, die erforderlich ist, um die Spitze des Gebäudes zu erreichen.\n#\n# Beispiel:\n# >>> minimum_time_to_top([3, 5, 1, 8, 4])\n# 1\n\ndef minimum_time_to_top(heights)",
      "ha": "# Lissafin lokacin da ake bukata mafi kankanta domin wata alama ta kai saman gini tare da tsayin bene daban-daban.\n# Alamar na iya motsawa sama bene daya ko biyu a lokaci guda, amma ba zai iya amfani da tsalle bene biyu a jere ba.\n# Motsawa sama bene daya yana daukar lokaci daya, yayin da tsalle bene biyu yana nan take.\n#\n# Args:\n# - floor_heights (Array): Wani jerin lambobi da ke wakiltar tsayin kowanne bene.\n#\n# Returns:\n# - Integer: Lokacin da ake bukata mafi kankanta domin kai saman ginin.\n#\n# Misali:\n# >>> minimum_time_to_top([3, 5, 1, 8, 4])\n# 1\n\ndef minimum_time_to_top(heights)",
      "hi": "# एक चरित्र को विभिन्न मंजिल ऊंचाइयों के साथ एक इमारत के शीर्ष पर पहुंचने के लिए आवश्यक न्यूनतम समय की गणना करता है।\n# चरित्र एक समय में एक या दो मंजिल ऊपर जा सकता है, लेकिन लगातार दो मंजिल की छलांग का उपयोग नहीं कर सकता।\n# एक मंजिल ऊपर जाने में एक समय इकाई लगती है, जबकि दो मंजिल ऊपर कूदना तात्कालिक होता है।\n#\n# तर्क:\n# - floor_heights (Array): प्रत्येक मंजिल की ऊंचाई का प्रतिनिधित्व करने वाले पूर्णांकों की एक श्रृंखला।\n#\n# लौटाता है:\n# - पूर्णांक: इमारत के शीर्ष पर पहुंचने के लिए आवश्यक न्यूनतम समय।\n#\n# उदाहरण:\n# >>> minimum_time_to_top([3, 5, 1, 8, 4])\n# 1\n\ndef minimum_time_to_top(heights)",
      "hu": "# Kiszámítja a minimális időt, amely szükséges ahhoz, hogy egy karakter elérje egy épület tetejét különböző emeletmagasságokkal.\n# A karakter egy vagy két emeletet tud egyszerre feljebb lépni, de nem használhatja a két emeletes ugrást egymás után.\n# Egy emelet feljebb lépése egy időegységet vesz igénybe, míg a két emeletes ugrás azonnali.\n#\n# Argumentumok:\n# - floor_heights (Tömb): Egész számokat tartalmazó tömb, amely az egyes emeletek magasságát jelöli.\n#\n# Visszatérési érték:\n# - Egész szám: A minimális idő, amely szükséges az épület tetejének eléréséhez.\n#\n# Példa:\n# >>> minimum_time_to_top([3, 5, 1, 8, 4])\n# 1\n\ndef minimum_time_to_top(heights)"
    },
    "prompt_bertscore": {
      "sq": "0.9740062351858694",
      "hy": "0.9665577945274421",
      "bn": "0.9592549499383134",
      "bg": "0.9773275337871538",
      "zh": "0.9678252549888257",
      "fr": "0.9735168099269994",
      "de": "0.9662006571023414",
      "ha": "0.9603585403353432",
      "hi": "0.9626018718587512",
      "hu": "0.9770796430716222"
    },
    "canonical_solution": "    # Initialize arrays for storing minimum time for climb and jump to each floor.\n    n = heights.length\n    \n    climb_time = [0, heights.first]\n    jump_time  = [0, 0]\n  \n    (2..n).each do |i|\n      climb_time[i] = [climb_time[i - 1], jump_time[i - 1]].min + heights[i-1]\n      jump_time[i]  = [climb_time[i - 1], climb_time[i - 2]].min\n    end\n    [climb_time[n], jump_time[n]].min\n  end",
    "instruction": {
      "en": "Write a ruby function `def minimum_time_to_top(heights)` to solve the following problem:\nCalculates the minimum time required for a character to reach the top of a building with varying floor heights.\nThe character can move up one or two floors at a time, but cannot use the two-floor jump consecutively.\nMoving up one floor takes one unit of time, while jumping up two floors is instantaneous.\n\nArgs:\n- floor_heights (Array): An array of integers representing the height of each floor.\n\nReturns:\n- Integer: The minimum time required to reach the top of the building.\n\nExample:\n>>> minimum_time_to_top([3, 5, 1, 8, 4])\n1",
      "sq": "Shkruani një funksion ruby `def minimum_time_to_top(heights)` për të zgjidhur problemin e mëposhtëm:\nLlogarit kohën minimale të nevojshme që një personazh të arrijë në majë të një ndërtese me lartësi të ndryshme katësh.\nPersonazhi mund të ngjitet një ose dy kate njëherësh, por nuk mund të përdorë kërcimin dy-katësh radhazi.\nNgjitja një kat merr një njësi kohe, ndërsa kërcimi dy kate është i menjëhershëm.\n\nArgumentet:\n- floor_heights (Array): Një varg me numra të plotë që përfaqësojnë lartësinë e secilit kat.\n\nKthen:\n- Integer: Koha minimale e nevojshme për të arritur në majë të ndërtesës.\n\nShembull:\n>>> minimum_time_to_top([3, 5, 1, 8, 4])\n1",
      "hy": "Գրեք ruby ֆունկցիա `def minimum_time_to_top(heights)` հետևյալ խնդիրը լուծելու համար:\nՀաշվում է նվազագույն ժամանակը, որը պահանջվում է կերպարին հասնելու շենքի գագաթին տարբեր հարկերի բարձրություններով:\nԿերպարը կարող է բարձրանալ մեկ կամ երկու հարկ միաժամանակ, բայց չի կարող օգտագործել երկու հարկի ցատկը հաջորդաբար:\nՄեկ հարկ բարձրանալը տևում է մեկ ժամանակային միավոր, մինչդեռ երկու հարկ ցատկելը ակնթարթային է:\n\nԱրգումենտներ:\n- floor_heights (Array): Թվերի զանգված, որը ներկայացնում է յուրաքանչյուր հարկի բարձրությունը:\n\nՎերադարձնում է:\n- Integer: Նվազագույն ժամանակը, որը պահանջվում է շենքի գագաթին հասնելու համար:\n\nՕրինակ:\n>>> minimum_time_to_top([3, 5, 1, 8, 4])\n1",
      "bn": "একটি রুবি ফাংশন `def minimum_time_to_top(heights)` লিখুন নিম্নলিখিত সমস্যার সমাধানের জন্য:\nএকটি চরিত্রের জন্য বিভিন্ন তলার উচ্চতার একটি ভবনের শীর্ষে পৌঁছানোর জন্য প্রয়োজনীয় সর্বনিম্ন সময় গণনা করে।\nচরিত্রটি একবারে এক বা দুই তলা উপরে উঠতে পারে, তবে পরপর দুই তলা লাফ ব্যবহার করতে পারে না।\nএক তলা উপরে উঠতে এক ইউনিট সময় লাগে, যখন দুই তলা লাফ দেওয়া তাৎক্ষণিক হয়।\n\nআর্গুমেন্টস:\n- floor_heights (Array): প্রতিটি তলার উচ্চতা নির্দেশ করে এমন পূর্ণসংখ্যার একটি অ্যারে।\n\nফেরত দেয়:\n- পূর্ণসংখ্যা: ভবনের শীর্ষে পৌঁছানোর জন্য প্রয়োজনীয় সর্বনিম্ন সময়।\n\nউদাহরণ:\n>>> minimum_time_to_top([3, 5, 1, 8, 4])\n1",
      "bg": "Напишете Ruby функция `def minimum_time_to_top(heights)`, за да решите следния проблем:\nИзчислява минималното време, необходимо на един герой да достигне върха на сграда с различни височини на етажите.\nГероят може да се движи нагоре с един или два етажа наведнъж, но не може да използва скок от два етажа последователно.\nДвижението нагоре с един етаж отнема една единица време, докато скокът нагоре с два етажа е мигновен.\n\nАргументи:\n- floor_heights (Array): Масив от цели числа, представляващи височината на всеки етаж.\n\nВръща:\n- Integer: Минималното време, необходимо за достигане до върха на сградата.\n\nПример:\n>>> minimum_time_to_top([3, 5, 1, 8, 4])\n1",
      "zh": "编写一个 ruby 函数 `def minimum_time_to_top(heights)` 来解决以下问题：\n计算角色到达具有不同楼层高度的建筑物顶部所需的最短时间。\n角色每次可以向上移动一层或两层，但不能连续使用两层跳跃。\n向上移动一层需要一个时间单位，而跳跃两层是瞬时的。\n\n参数：\n- floor_heights (Array): 一个整数数组，表示每层的高度。\n\n返回：\n- Integer: 到达建筑物顶部所需的最短时间。\n\n示例：\n>>> minimum_time_to_top([3, 5, 1, 8, 4])\n1",
      "fr": "Écrire une fonction ruby `def minimum_time_to_top(heights)` pour résoudre le problème suivant :\nCalcule le temps minimum nécessaire pour qu'un personnage atteigne le sommet d'un bâtiment avec des hauteurs d'étage variables.\nLe personnage peut monter d'un ou deux étages à la fois, mais ne peut pas utiliser le saut de deux étages consécutivement.\nMonter d'un étage prend une unité de temps, tandis que sauter de deux étages est instantané.\n\nArgs:\n- floor_heights (Array): Un tableau d'entiers représentant la hauteur de chaque étage.\n\nReturns:\n- Integer: Le temps minimum requis pour atteindre le sommet du bâtiment.\n\nExemple:\n>>> minimum_time_to_top([3, 5, 1, 8, 4])\n1",
      "de": "Schreiben Sie eine Ruby-Funktion `def minimum_time_to_top(heights)`, um das folgende Problem zu lösen:\nBerechnet die minimale Zeit, die erforderlich ist, damit eine Figur die Spitze eines Gebäudes mit unterschiedlichen Stockwerkshöhen erreicht.\nDie Figur kann ein oder zwei Stockwerke auf einmal nach oben bewegen, darf jedoch den Zwei-Stockwerk-Sprung nicht aufeinanderfolgend verwenden.\nDas Bewegen um ein Stockwerk nach oben dauert eine Zeiteinheit, während der Sprung um zwei Stockwerke sofort erfolgt.\n\nArgs:\n- floor_heights (Array): Ein Array von ganzen Zahlen, das die Höhe jedes Stockwerks darstellt.\n\nReturns:\n- Integer: Die minimale Zeit, die erforderlich ist, um die Spitze des Gebäudes zu erreichen.\n\nBeispiel:\n>>> minimum_time_to_top([3, 5, 1, 8, 4])\n1",
      "ha": "Rubuta wani aikin ruby `def minimum_time_to_top(heights)` don warware matsalar mai zuwa:\nLissafa mafi ƙarancin lokaci da ake buƙata don wata alama ta kai saman wani gini mai tsayin bene daban-daban.\nAlamar na iya motsawa sama bene ɗaya ko biyu a lokaci guda, amma ba za ta iya amfani da tsalle bene biyu a jere ba.\nMotsawa sama bene ɗaya yana ɗaukar ɗaya na lokaci, yayin da tsalle sama bene biyu ba ya ɗaukar lokaci.\n\nArgs:\n- floor_heights (Array): Jerin lambobi da ke wakiltar tsayin kowanne bene.\n\nReturns:\n- Integer: Mafi ƙarancin lokaci da ake buƙata don kai saman ginin.\n\nMisali:\n>>> minimum_time_to_top([3, 5, 1, 8, 4])\n1",
      "hi": "रूबी फ़ंक्शन `def minimum_time_to_top(heights)` लिखें ताकि निम्नलिखित समस्या का समाधान किया जा सके:\nएक चरित्र के लिए एक इमारत की शीर्ष मंजिल तक पहुँचने के लिए आवश्यक न्यूनतम समय की गणना करता है, जिसमें विभिन्न मंजिल ऊँचाइयाँ होती हैं।  \nचरित्र एक समय में एक या दो मंजिल ऊपर जा सकता है, लेकिन लगातार दो मंजिल की छलांग का उपयोग नहीं कर सकता।  \nएक मंजिल ऊपर जाने में एक समय इकाई लगती है, जबकि दो मंजिल ऊपर कूदना तात्कालिक है।\n\nआर्ग्स:\n- floor_heights (Array): प्रत्येक मंजिल की ऊँचाई का प्रतिनिधित्व करने वाले पूर्णांकों की एक श्रृंखला।\n\nवापसी:\n- Integer: इमारत की शीर्ष मंजिल तक पहुँचने के लिए आवश्यक न्यूनतम समय।\n\nउदाहरण:\n>>> minimum_time_to_top([3, 5, 1, 8, 4])\n1",
      "hu": "Írj egy ruby függvényt `def minimum_time_to_top(heights)` a következő probléma megoldására:\nKiszámítja a minimális időt, amely ahhoz szükséges, hogy egy karakter elérje egy épület tetejét, ahol az emeletek magassága változó.\nA karakter egy vagy két emeletet léphet felfelé egyszerre, de nem használhatja a két emeletes ugrást egymás után.\nEgy emelet felfelé lépése egy időegységet vesz igénybe, míg két emelet ugrása azonnali.\n\nArgs:\n- floor_heights (Array): Egész számokat tartalmazó tömb, amely az egyes emeletek magasságát jelöli.\n\nVisszatér:\n- Integer: A minimális idő, amely szükséges az épület tetejére való eljutáshoz.\n\nPélda:\n>>> minimum_time_to_top([3, 5, 1, 8, 4])\n1"
    },
    "instruction_bertscore": {
      "sq": "0.9703738814078844",
      "hy": "0.9681355156440022",
      "bn": "0.9697605107912486",
      "bg": "0.9739623378716606",
      "zh": "0.9747890375175279",
      "fr": "0.9827785473338941",
      "de": "0.9717182118267285",
      "ha": "0.9550410064046583",
      "hi": "0.9771712116772793",
      "hu": "0.9854674068019634"
    },
    "level": "middle",
    "test": "raise 'Test failed' unless minimum_time_to_top([3, 5, 1, 8, 4]) == 1\nraise 'Test failed' unless minimum_time_to_top([2, 2, 2, 2, 2]) == 2\nraise 'Test failed' unless minimum_time_to_top([1, 1, 1, 1, 1]) == 1\nraise 'Test failed' unless minimum_time_to_top([10]) == 0\n\n\n\nputs 'All tests passed!'",
    "entry_point": "minimum_time_to_top",
    "signature": "def minimum_time_to_top(heights)",
    "docstring": {
      "en": "Calculates the minimum time required for a character to reach the top of a building with varying floor heights.\nThe character can move up one or two floors at a time, but cannot use the two-floor jump consecutively.\nMoving up one floor takes one unit of time, while jumping up two floors is instantaneous.\n\nArgs:\n- floor_heights (Array): An array of integers representing the height of each floor.\n\nReturns:\n- Integer: The minimum time required to reach the top of the building.\n\nExample:\n>>> minimum_time_to_top([3, 5, 1, 8, 4])\n1",
      "sq": "Llogarit kohën minimale të nevojshme që një personazh të arrijë në majë të një ndërtese me lartësi të ndryshme katësh. Personazhi mund të ngjitet një ose dy kate njëherësh, por nuk mund të përdorë kërcimin me dy kate radhazi. Ngjitja një kat merr një njësi kohe, ndërsa kërcimi me dy kate është i menjëhershëm.\n\nArgumentet:\n- floor_heights (Array): Një varg me numra të plotë që përfaqësojnë lartësinë e secilit kat.\n\nKthen:\n- Integer: Koha minimale e nevojshme për të arritur në majë të ndërtesës.\n\nShembull:\n>>> minimum_time_to_top([3, 5, 1, 8, 4])\n1",
      "hy": "Հաշվում է շենքի գագաթին հասնելու համար անհրաժեշտ նվազագույն ժամանակը, որտեղ հարկերի բարձրությունները տարբեր են:\nՏարրը կարող է շարժվել մեկ կամ երկու հարկ վերև միաժամանակ, բայց չի կարող երկու հարկի թռիչքը օգտագործել անընդմեջ:\nՄեկ հարկ վերև շարժվելը տևում է մեկ ժամանակային միավոր, իսկ երկու հարկ վեր թռիչքը ակնթարթային է:\n\nԱրձանագրություններ:\n- floor_heights (Array): Բազմություն, որը ներկայացնում է յուրաքանչյուր հարկի բարձրությունը ամբողջ թվերով:\n\nՎերադարձնում է:\n- Integer: Շենքի գագաթին հասնելու համար անհրաժեշտ նվազագույն ժամանակը:\n\nՕրինակ:\n>>> minimum_time_to_top([3, 5, 1, 8, 4])\n1",
      "bn": "বিভিন্ন মেঝের উচ্চতার একটি ভবনের শীর্ষে পৌঁছানোর জন্য একটি চরিত্রের ন্যূনতম সময় গণনা করে। চরিত্রটি এক বা দুই মেঝে উপরে উঠতে পারে, তবে পরপর দুই মেঝে লাফ দিতে পারে না। এক মেঝে উপরে উঠতে এক ইউনিট সময় লাগে, যখন দুই মেঝে উপরে লাফ দেওয়া তাৎক্ষণিক হয়।\n\nআর্গুমেন্টস:\n- floor_heights (Array): প্রতিটি মেঝের উচ্চতা উপস্থাপনকারী পূর্ণসংখ্যার একটি অ্যারে।\n\nরিটার্নস:\n- পূর্ণসংখ্যা: ভবনের শীর্ষে পৌঁছানোর জন্য প্রয়োজনীয় ন্যূনতম সময়।\n\nউদাহরণ:\n>>> minimum_time_to_top([3, 5, 1, 8, 4])\n1",
      "bg": "Изчислява минималното време, необходимо на един герой да достигне върха на сграда с различни височини на етажите. Героят може да се движи нагоре с един или два етажа наведнъж, но не може да използва скок от два етажа последователно. Движението нагоре с един етаж отнема една единица време, докато скокът нагоре с два етажа е мигновен.\n\nАргументи:\n- floor_heights (Array): Масив от цели числа, представляващи височината на всеки етаж.\n\nВръща:\n- Integer: Минималното време, необходимо за достигане на върха на сградата.\n\nПример:\n>>> minimum_time_to_top([3, 5, 1, 8, 4])\n1",
      "zh": "计算角色到达具有不同楼层高度的建筑物顶部所需的最短时间。\n角色可以每次向上移动一层或两层，但不能连续使用两层跳跃。\n向上移动一层需要一个时间单位，而跳跃两层是瞬时的。\n\n参数:\n- floor_heights (Array): 一个整数数组，表示每层楼的高度。\n\n返回:\n- Integer: 到达建筑物顶部所需的最短时间。\n\n示例:\n>>> minimum_time_to_top([3, 5, 1, 8, 4])\n1",
      "fr": "Calcule le temps minimum nécessaire pour qu'un personnage atteigne le sommet d'un bâtiment avec des hauteurs d'étage variables. Le personnage peut monter d'un ou deux étages à la fois, mais ne peut pas utiliser le saut de deux étages consécutivement. Monter d'un étage prend une unité de temps, tandis que sauter de deux étages est instantané.\n\nArgs:\n- floor_heights (Array): Un tableau d'entiers représentant la hauteur de chaque étage.\n\nReturns:\n- Integer: Le temps minimum nécessaire pour atteindre le sommet du bâtiment.\n\nExample:\n>>> minimum_time_to_top([3, 5, 1, 8, 4])\n1",
      "de": "Berechnet die minimale Zeit, die erforderlich ist, damit ein Charakter die Spitze eines Gebäudes mit unterschiedlichen Stockwerkshöhen erreicht.\nDer Charakter kann sich um ein oder zwei Stockwerke nach oben bewegen, darf jedoch nicht den Zwei-Stockwerk-Sprung aufeinanderfolgend verwenden.\nDas Bewegen um ein Stockwerk nach oben dauert eine Zeiteinheit, während der Sprung um zwei Stockwerke sofort erfolgt.\n\nArgs:\n- floor_heights (Array): Ein Array von ganzen Zahlen, das die Höhe jedes Stockwerks darstellt.\n\nReturns:\n- Integer: Die minimale Zeit, die erforderlich ist, um die Spitze des Gebäudes zu erreichen.\n\nBeispiel:\n>>> minimum_time_to_top([3, 5, 1, 8, 4])\n1",
      "ha": "Lissafa mafi ƙarancin lokaci da ake buƙata don wata alama ta kai saman wani gini mai tsayin bene daban-daban.\nAlamar na iya motsawa sama bene ɗaya ko biyu a lokaci guda, amma ba za ta iya amfani da tsalle bene biyu a jere ba.\nMotsawa sama bene ɗaya yana ɗaukar ɗaya na lokaci, yayin da tsalle sama bene biyu ba ya ɗaukar lokaci.\n\nArgs:\n- floor_heights (Array): Jerin lambobi da ke wakiltar tsayin kowanne bene.\n\nReturns:\n- Integer: Mafi ƙarancin lokaci da ake buƙata don kai saman ginin.\n\nMisali:\n>>> minimum_time_to_top([3, 5, 1, 8, 4])\n1",
      "hi": "चरित्र को विभिन्न मंजिल ऊंचाइयों वाली इमारत के शीर्ष पर पहुंचने के लिए आवश्यक न्यूनतम समय की गणना करता है।\nचरित्र एक समय में एक या दो मंजिल ऊपर जा सकता है, लेकिन लगातार दो-मंजिल की छलांग का उपयोग नहीं कर सकता।\nएक मंजिल ऊपर जाने में एक समय इकाई लगती है, जबकि दो मंजिल ऊपर कूदना तात्कालिक होता है।  \n\nArgs:\n- floor_heights (Array): प्रत्येक मंजिल की ऊंचाई का प्रतिनिधित्व करने वाले पूर्णांकों की एक सरणी।\n\nReturns:\n- Integer: इमारत के शीर्ष पर पहुंचने के लिए आवश्यक न्यूनतम समय।  \n\nExample:  \n>>> minimum_time_to_top([3, 5, 1, 8, 4])  \n1",
      "hu": "Kiszámítja a minimális időt, amely szükséges ahhoz, hogy egy karakter elérje egy épület tetejét különböző emeletmagasságokkal.\nA karakter egyszerre egy vagy két emeletet tud felmenni, de nem használhatja a két emeletes ugrást egymás után.\nEgy emelet felmenetele egy időegységet vesz igénybe, míg két emelet ugrása azonnali.\n\nArgs:\n- floor_heights (Array): Egész számokat tartalmazó tömb, amely az egyes emeletek magasságát reprezentálja.\n\nReturns:\n- Integer: A minimális idő, amely szükséges az épület tetejére való eljutáshoz.\n\nExample:\n>>> minimum_time_to_top([3, 5, 1, 8, 4])\n1"
    },
    "docstring_bertscore": {
      "sq": "0.968356392627713",
      "hy": "0.9359069417995675",
      "bn": "0.9440440339890427",
      "bg": "0.9702324565765875",
      "zh": "0.9565647000575769",
      "fr": "0.9774576366867316",
      "de": "0.9687701397114087",
      "ha": "0.9943384382493626",
      "hi": "1",
      "hu": "0.9759387101629577"
    }
  },
  {
    "task_id": "Ruby/9",
    "prompt": {
      "en": "# Transposes a given n x m matrix.\n# The function takes a single argument, matrix, which is an array of arrays representing the n x m matrix.\n# The matrix has n rows and m columns, where 1 ≤ n ≤ 20 and 1 ≤ m ≤ 20. Each element in the matrix is an integer.\n# The function returns a new matrix which is the transpose of the input matrix.\n#\n# Example:\n# >>> transpose_matrix([[34, 76, -54, 7], [-4, 5, 23, 9]])\n# [[34, -4], [76, 5], [-54, 23], [7, 9]]\n\ndef transpose_matrix(matrix)",
      "sq": "# Transpozon një matricë të dhënë n x m.\n# Funksioni merr një argument të vetëm, matrix, i cili është një varg arrays që përfaqëson matricën n x m.\n# Matrica ka n rreshta dhe m kolona, ku 1 ≤ n ≤ 20 dhe 1 ≤ m ≤ 20. Çdo element në matricë është një numër i plotë.\n# Funksioni kthen një matricë të re e cila është transpozimi i matricës hyrëse.\n#\n# Shembull:\n# >>> transpose_matrix([[34, 76, -54, 7], [-4, 5, 23, 9]])\n# [[34, -4], [76, 5], [-54, 23], [7, 9]]\n\ndef transpose_matrix(matrix)",
      "hy": "# Տրվում է n x m մատրիցի տրանսպոզիցիա։\n# Ֆունկցիան ընդունում է մեկ արգումենտ՝ matrix, որը ներկայացնում է n x m մատրիցի զանգվածների զանգված։\n# Մատրիցն ունի n տող և m սյունակ, որտեղ 1 ≤ n ≤ 20 և 1 ≤ m ≤ 20։ Մատրիցի յուրաքանչյուր տարր ամբողջ թիվ է։\n# Ֆունկցիան վերադարձնում է նոր մատրից, որը մուտքային մատրիցի տրանսպոզիցիան է։\n#\n# Օրինակ:\n# >>> transpose_matrix([[34, 76, -54, 7], [-4, 5, 23, 9]])\n# [[34, -4], [76, 5], [-54, 23], [7, 9]]\n\ndef transpose_matrix(matrix)",
      "bn": "# প্রদত্ত n x m ম্যাট্রিক্স স্থানান্তর করে।\n# ফাংশনটি একটি মাত্র আর্গুমেন্ট গ্রহণ করে, matrix, যা n x m ম্যাট্রিক্সকে উপস্থাপনকারী অ্যারের একটি অ্যারে।\n# ম্যাট্রিক্সের n সারি এবং m কলাম আছে, যেখানে 1 ≤ n ≤ 20 এবং 1 ≤ m ≤ 20। ম্যাট্রিক্সের প্রতিটি উপাদান একটি পূর্ণসংখ্যা।\n# ফাংশনটি একটি নতুন ম্যাট্রিক্স রিটার্ন করে যা ইনপুট ম্যাট্রিক্সের স্থানান্তর।\n#\n# উদাহরণ:\n# >>> transpose_matrix([[34, 76, -54, 7], [-4, 5, 23, 9]])\n# [[34, -4], [76, 5], [-54, 23], [7, 9]]\n\ndef transpose_matrix(matrix)",
      "bg": "# Транспонира дадена n x m матрица.\n# Функцията приема един аргумент, matrix, който е масив от масиви, представляващ n x m матрица.\n# Матрицата има n реда и m колони, където 1 ≤ n ≤ 20 и 1 ≤ m ≤ 20. Всеки елемент в матрицата е цяло число.\n# Функцията връща нова матрица, която е транспонирана версия на входната матрица.\n#\n# Пример:\n# >>> transpose_matrix([[34, 76, -54, 7], [-4, 5, 23, 9]])\n# [[34, -4], [76, 5], [-54, 23], [7, 9]]\n\ndef transpose_matrix(matrix)",
      "zh": "# 转置给定的 n x m 矩阵。\n# 该函数接受一个参数 matrix，它是一个数组的数组，表示 n x m 矩阵。\n# 矩阵有 n 行和 m 列，其中 1 ≤ n ≤ 20 且 1 ≤ m ≤ 20。矩阵中的每个元素都是一个整数。\n# 该函数返回一个新的矩阵，该矩阵是输入矩阵的转置。\n#\n# 示例:\n# >>> transpose_matrix([[34, 76, -54, 7], [-4, 5, 23, 9]])\n# [[34, -4], [76, 5], [-54, 23], [7, 9]]\n\ndef transpose_matrix(matrix)",
      "fr": "# Transpose une matrice n x m donnée.\n# La fonction prend un seul argument, matrix, qui est un tableau de tableaux représentant la matrice n x m.\n# La matrice a n lignes et m colonnes, où 1 ≤ n ≤ 20 et 1 ≤ m ≤ 20. Chaque élément de la matrice est un entier.\n# La fonction renvoie une nouvelle matrice qui est la transposée de la matrice d'entrée.\n#\n# Exemple:\n# >>> transpose_matrix([[34, 76, -54, 7], [-4, 5, 23, 9]])\n# [[34, -4], [76, 5], [-54, 23], [7, 9]]\n\ndef transpose_matrix(matrix)",
      "de": "# Transponiert eine gegebene n x m Matrix.\n# Die Funktion nimmt ein einzelnes Argument, matrix, das ein Array von Arrays darstellt, welches die n x m Matrix repräsentiert.\n# Die Matrix hat n Zeilen und m Spalten, wobei 1 ≤ n ≤ 20 und 1 ≤ m ≤ 20. Jedes Element in der Matrix ist ein Integer.\n# Die Funktion gibt eine neue Matrix zurück, die die Transponierte der Eingabematrix ist.\n#\n# Beispiel:\n# >>> transpose_matrix([[34, 76, -54, 7], [-4, 5, 23, 9]])\n# [[34, -4], [76, 5], [-54, 23], [7, 9]]\n\ndef transpose_matrix(matrix)",
      "ha": "# Yana juyar da matrix n x m da aka bayar.\n# Aikin yana karɓar hujja guda ɗaya, matrix, wanda shine jerin jerarraki da ke wakiltar matrix n x m.\n# Matrix ɗin yana da layuka n da ginshikai m, inda 1 ≤ n ≤ 20 da 1 ≤ m ≤ 20. Kowanne abu a cikin matrix ɗin lamba ce.\n# Aikin yana mayar da sabon matrix wanda shine juyawar matrix ɗin da aka shigar.\n#\n# Misali:\n# >>> transpose_matrix([[34, 76, -54, 7], [-4, 5, 23, 9]])\n# [[34, -4], [76, 5], [-54, 23], [7, 9]]\n\ndef transpose_matrix(matrix)",
      "hi": "# दिए गए n x m मैट्रिक्स का ट्रांसपोज़ करता है।\n# फ़ंक्शन एकल आर्गुमेंट, matrix, लेता है, जो n x m मैट्रिक्स का प्रतिनिधित्व करने वाले ऐरे का एक ऐरे है।\n# मैट्रिक्स में n पंक्तियाँ और m स्तंभ होते हैं, जहाँ 1 ≤ n ≤ 20 और 1 ≤ m ≤ 20। मैट्रिक्स में प्रत्येक तत्व एक पूर्णांक है।\n# फ़ंक्शन एक नया मैट्रिक्स लौटाता है जो इनपुट मैट्रिक्स का ट्रांसपोज़ है।\n#\n# उदाहरण:\n# >>> transpose_matrix([[34, 76, -54, 7], [-4, 5, 23, 9]])\n# [[34, -4], [76, 5], [-54, 23], [7, 9]]\n\ndef transpose_matrix(matrix)",
      "hu": "# Egy adott n x m mátrix transzponálása.\n# A függvény egyetlen argumentumot vesz fel, a mátrixot, amely egy tömbök tömbje, és az n x m mátrixot reprezentálja.\n# A mátrix n sorból és m oszlopból áll, ahol 1 ≤ n ≤ 20 és 1 ≤ m ≤ 20. A mátrix minden eleme egy egész szám.\n# A függvény visszaad egy új mátrixot, amely a bemeneti mátrix transzponáltja.\n#\n# Példa:\n# >>> transpose_matrix([[34, 76, -54, 7], [-4, 5, 23, 9]])\n# [[34, -4], [76, 5], [-54, 23], [7, 9]]\n\ndef transpose_matrix(matrix)"
    },
    "prompt_bertscore": {
      "sq": "0.9987381011892854",
      "hy": "0.9783574323128196",
      "bn": "0.9960335499211144",
      "bg": "0.9858998251414763",
      "zh": "0.9671330281109192",
      "fr": "0.9967335233838812",
      "de": "0.9989200466183134",
      "ha": "0.9788305698804447",
      "hi": "0.996937318154823",
      "hu": "0.98646671624895"
    },
    "canonical_solution": "    return [] if matrix.empty? || matrix[0].empty?\n  \n    transposed = Array.new(matrix[0].size) { Array.new(matrix.size) }\n    matrix.each_with_index do |row, i|\n      row.each_with_index do |value, j|\n        transposed[j][i] = value\n      end\n    end\n    transposed\n  end",
    "instruction": {
      "en": "Write a ruby function `def transpose_matrix(matrix)` to solve the following problem:\nTransposes a given n x m matrix.\nThe function takes a single argument, matrix, which is an array of arrays representing the n x m matrix.\nThe matrix has n rows and m columns, where 1 ≤ n ≤ 20 and 1 ≤ m ≤ 20. Each element in the matrix is an integer.\nThe function returns a new matrix which is the transpose of the input matrix.\n\nExample:\n>>> transpose_matrix([[34, 76, -54, 7], [-4, 5, 23, 9]])\n[[34, -4], [76, 5], [-54, 23], [7, 9]]",
      "sq": "Shkruani një funksion ruby `def transpose_matrix(matrix)` për të zgjidhur problemin e mëposhtëm:\nTranspozon një matricë të dhënë n x m.\nFunksioni merr një argument të vetëm, matrix, i cili është një varg vargjesh që përfaqëson matricën n x m.\nMatrica ka n rreshta dhe m kolona, ku 1 ≤ n ≤ 20 dhe 1 ≤ m ≤ 20. Çdo element në matricë është një numër i plotë.\nFunksioni kthen një matricë të re e cila është transpozimi i matricës hyrëse.\n\nShembull:\n>>> transpose_matrix([[34, 76, -54, 7], [-4, 5, 23, 9]])\n[[34, -4], [76, 5], [-54, 23], [7, 9]]",
      "hy": "Գրեք ruby ֆունկցիա `def transpose_matrix(matrix)` հետևյալ խնդիրը լուծելու համար:\nՏրված n x m մատրիցը տրանսպոզ է անում։\nՖունկցիան ընդունում է մեկ արգումենտ, matrix, որը ներկայացնում է n x m մատրիցը որպես զանգվածների զանգված։\nՄատրիցն ունի n տող և m սյուն, որտեղ 1 ≤ n ≤ 20 և 1 ≤ m ≤ 20։ Մատրիցի յուրաքանչյուր տարր ամբողջ թիվ է։\nՖունկցիան վերադարձնում է նոր մատրից, որը մուտքային մատրիցի տրանսպոզն է։\n\nՕրինակ:\n>>> transpose_matrix([[34, 76, -54, 7], [-4, 5, 23, 9]])\n[[34, -4], [76, 5], [-54, 23], [7, 9]]",
      "bn": "রুবি ফাংশন `def transpose_matrix(matrix)` লিখুন নিম্নলিখিত সমস্যার সমাধানের জন্য:\nএকটি প্রদত্ত n x m ম্যাট্রিক্স ট্রান্সপোজ করে।\nফাংশনটি একটি একক আর্গুমেন্ট গ্রহণ করে, matrix, যা n x m ম্যাট্রিক্স উপস্থাপনকারী অ্যারের অ্যারে।\nম্যাট্রিক্সের n সারি এবং m কলাম রয়েছে, যেখানে 1 ≤ n ≤ 20 এবং 1 ≤ m ≤ 20। ম্যাট্রিক্সের প্রতিটি উপাদান একটি পূর্ণসংখ্যা।\nফাংশনটি একটি নতুন ম্যাট্রিক্স রিটার্ন করে যা ইনপুট ম্যাট্রিক্সের ট্রান্সপোজ।\n\nউদাহরণ:\n>>> transpose_matrix([[34, 76, -54, 7], [-4, 5, 23, 9]])\n[[34, -4], [76, 5], [-54, 23], [7, 9]]",
      "bg": "Напишете Ruby функция `def transpose_matrix(matrix)`, за да решите следния проблем:\nТранспонира дадена n x m матрица.\nФункцията приема един аргумент, matrix, който е масив от масиви, представляващ n x m матрица.\nМатрицата има n реда и m колони, където 1 ≤ n ≤ 20 и 1 ≤ m ≤ 20. Всеки елемент в матрицата е цяло число.\nФункцията връща нова матрица, която е транспонирана версия на входната матрица.\n\nПример:\n>>> transpose_matrix([[34, 76, -54, 7], [-4, 5, 23, 9]])\n[[34, -4], [76, 5], [-54, 23], [7, 9]]",
      "zh": "编写一个 ruby 函数 `def transpose_matrix(matrix)` 来解决以下问题：\n转置给定的 n x m 矩阵。\n该函数接受一个参数，matrix，它是一个表示 n x m 矩阵的数组的数组。\n矩阵有 n 行和 m 列，其中 1 ≤ n ≤ 20 且 1 ≤ m ≤ 20。矩阵中的每个元素都是整数。\n该函数返回一个新的矩阵，该矩阵是输入矩阵的转置。\n\n示例：\n>>> transpose_matrix([[34, 76, -54, 7], [-4, 5, 23, 9]])\n[[34, -4], [76, 5], [-54, 23], [7, 9]]",
      "fr": "Écrire une fonction ruby `def transpose_matrix(matrix)` pour résoudre le problème suivant :  \nTranspose une matrice n x m donnée.  \nLa fonction prend un seul argument, matrix, qui est un tableau de tableaux représentant la matrice n x m.  \nLa matrice a n lignes et m colonnes, où 1 ≤ n ≤ 20 et 1 ≤ m ≤ 20. Chaque élément de la matrice est un entier.  \nLa fonction renvoie une nouvelle matrice qui est la transposée de la matrice d'entrée.  \n\nExemple :  \n>>> transpose_matrix([[34, 76, -54, 7], [-4, 5, 23, 9]])  \n[[34, -4], [76, 5], [-54, 23], [7, 9]]",
      "de": "Schreiben Sie eine Ruby-Funktion `def transpose_matrix(matrix)`, um das folgende Problem zu lösen:\nTransponiert eine gegebene n x m Matrix.\nDie Funktion nimmt ein einzelnes Argument, matrix, das ein Array von Arrays darstellt, das die n x m Matrix repräsentiert.\nDie Matrix hat n Zeilen und m Spalten, wobei 1 ≤ n ≤ 20 und 1 ≤ m ≤ 20. Jedes Element in der Matrix ist eine ganze Zahl.\nDie Funktion gibt eine neue Matrix zurück, die die Transponierte der Eingabematrix ist.\n\nBeispiel:\n>>> transpose_matrix([[34, 76, -54, 7], [-4, 5, 23, 9]])\n[[34, -4], [76, 5], [-54, 23], [7, 9]]",
      "ha": "Rubuta aikin ruby `def transpose_matrix(matrix)` don warware matsalar mai zuwa:\nCanja wurin matrix n x m da aka bayar.\nAikin yana ɗaukar hujja guda ɗaya, matrix, wanda shine jerin jerin abubuwa da ke wakiltar matrix n x m.\nMatrix yana da layuka n da ginshiƙai m, inda 1 ≤ n ≤ 20 da 1 ≤ m ≤ 20. Kowanne abu a cikin matrix lamba ce.\nAikin yana mayar da sabon matrix wanda shine canjin matrix na shigarwa.\n\nMisali:\n>>> transpose_matrix([[34, 76, -54, 7], [-4, 5, 23, 9]])\n[[34, -4], [76, 5], [-54, 23], [7, 9]]",
      "hi": "`def transpose_matrix(matrix)` फ़ंक्शन लिखें ताकि निम्नलिखित समस्या का समाधान किया जा सके:\nएक दिए गए n x m मैट्रिक्स का ट्रांसपोज़ करता है।\nयह फ़ंक्शन एक एकल आर्ग्युमेंट लेता है, matrix, जो n x m मैट्रिक्स का प्रतिनिधित्व करने वाले एरेज़ का एरे होता है।\nमैट्रिक्स में n पंक्तियाँ और m स्तंभ होते हैं, जहाँ 1 ≤ n ≤ 20 और 1 ≤ m ≤ 20। मैट्रिक्स में प्रत्येक तत्व एक पूर्णांक होता है।\nयह फ़ंक्शन एक नया मैट्रिक्स लौटाता है जो इनपुट मैट्रिक्स का ट्रांसपोज़ होता है।\n\nउदाहरण:\n>>> transpose_matrix([[34, 76, -54, 7], [-4, 5, 23, 9]])\n[[34, -4], [76, 5], [-54, 23], [7, 9]]",
      "hu": "Írj egy ruby függvényt `def transpose_matrix(matrix)` a következő probléma megoldására:\nEgy adott n x m mátrix transzponálása.\nA függvény egyetlen argumentumot vesz át, a matrix-t, amely egy tömbök tömbje, ami az n x m mátrixot képviseli.\nA mátrix n sorral és m oszloppal rendelkezik, ahol 1 ≤ n ≤ 20 és 1 ≤ m ≤ 20. A mátrix minden eleme egy egész szám.\nA függvény visszaad egy új mátrixot, amely a bemeneti mátrix transzponáltja.\n\nPélda:\n>>> transpose_matrix([[34, 76, -54, 7], [-4, 5, 23, 9]])\n[[34, -4], [76, 5], [-54, 23], [7, 9]]"
    },
    "instruction_bertscore": {
      "sq": "1",
      "hy": "0.9857371468594088",
      "bn": "0.9942311778436037",
      "bg": "0.9812989496255653",
      "zh": "0.9852300434966268",
      "fr": "0.9974497845378931",
      "de": "0.9975635997462261",
      "ha": "0.981126339824446",
      "hi": "0.9807274900193279",
      "hu": "0.9968352221389711"
    },
    "level": "middle",
    "test": "raise 'Test failed' unless transpose_matrix([[34, 76, -54, 7], [-4, 5, 23, 9]]) == [[34, -4], [76, 5], [-54, 23], [7, 9]]\nraise 'Test failed' unless transpose_matrix([[1, 2, 3], [4, 5, 6]]) == [[1, 4], [2, 5], [3, 6]]\nraise 'Test failed' unless transpose_matrix([[10]]) == [[10]]\nraise 'Test failed' unless transpose_matrix([]) == []\nraise 'Test failed' unless transpose_matrix([[1, 2], [3, 4], [5, 6]]) == [[1, 3, 5], [2, 4, 6]]\n\n\nputs 'All tests passed!'",
    "entry_point": "transpose_matrix",
    "signature": "def transpose_matrix(matrix)",
    "docstring": {
      "en": "Transposes a given n x m matrix.\nThe function takes a single argument, matrix, which is an array of arrays representing the n x m matrix.\nThe matrix has n rows and m columns, where 1 ≤ n ≤ 20 and 1 ≤ m ≤ 20. Each element in the matrix is an integer.\nThe function returns a new matrix which is the transpose of the input matrix.\n\nExample:\n>>> transpose_matrix([[34, 76, -54, 7], [-4, 5, 23, 9]])\n[[34, -4], [76, 5], [-54, 23], [7, 9]]",
      "sq": "Transpozon një matricë të dhënë n x m.\nFunksioni merr një argument të vetëm, matrix, i cili është një varg i vargjeve që përfaqëson matricën n x m.  \nMatrica ka n rreshta dhe m kolona, ku 1 ≤ n ≤ 20 dhe 1 ≤ m ≤ 20. Çdo element në matricë është një numër i plotë.  \nFunksioni kthen një matricë të re e cila është transpozimi i matricës hyrëse.\n\nShembull:  \n>>> transpose_matrix([[34, 76, -54, 7], [-4, 5, 23, 9]])  \n[[34, -4], [76, 5], [-54, 23], [7, 9]]",
      "hy": "Փոխադրում է տրված n x m մատրիցը։\nՖունկցիան ընդունում է մեկ արգումենտ՝ matrix, որը ներկայացնում է n x m մատրիցը՝ զանգվածների զանգված։  \nՄատրիցն ունի n տող և m սյունակ, որտեղ 1 ≤ n ≤ 20 և 1 ≤ m ≤ 20։ Մատրիցի յուրաքանչյուր տարր ամբողջ թիվ է։  \nՖունկցիան վերադարձնում է նոր մատրից, որը մուտքային մատրիցի փոխադրումն է։  \n\nՕրինակ:  \n>>> transpose_matrix([[34, 76, -54, 7], [-4, 5, 23, 9]])  \n[[34, -4], [76, 5], [-54, 23], [7, 9]]",
      "bn": "একটি প্রদত্ত n x m ম্যাট্রিক্স ট্রান্সপোজ করে।\nফাংশনটি একটি মাত্র আর্গুমেন্ট গ্রহণ করে, matrix, যা n x m ম্যাট্রিক্সকে উপস্থাপনকারী অ্যারে অফ অ্যারে। \nম্যাট্রিক্সের n সারি এবং m কলাম রয়েছে, যেখানে 1 ≤ n ≤ 20 এবং 1 ≤ m ≤ 20। ম্যাট্রিক্সের প্রতিটি উপাদান একটি পূর্ণসংখ্যা। \nফাংশনটি একটি নতুন ম্যাট্রিক্স রিটার্ন করে যা ইনপুট ম্যাট্রিক্সের ট্রান্সপোজ।\n\nউদাহরণ:\n>>> transpose_matrix([[34, 76, -54, 7], [-4, 5, 23, 9]])\n[[34, -4], [76, 5], [-54, 23], [7, 9]]",
      "bg": "Транспонира дадена n x m матрица.\nФункцията приема един аргумент, matrix, който е масив от масиви, представляващ n x m матрицата.  \nМатрицата има n реда и m колони, където 1 ≤ n ≤ 20 и 1 ≤ m ≤ 20. Всеки елемент в матрицата е цяло число.  \nФункцията връща нова матрица, която е транспонираната на входната матрица.  \n\nПример:  \n>>> transpose_matrix([[34, 76, -54, 7], [-4, 5, 23, 9]])  \n[[34, -4], [76, 5], [-54, 23], [7, 9]]",
      "zh": "转置给定的 n x m 矩阵。\n该函数接受一个参数 matrix，它是一个数组的数组，表示 n x m 矩阵。\n矩阵有 n 行 m 列，其中 1 ≤ n ≤ 20 且 1 ≤ m ≤ 20。矩阵中的每个元素都是整数。\n该函数返回一个新的矩阵，该矩阵是输入矩阵的转置矩阵。\n\n示例：\n>>> transpose_matrix([[34, 76, -54, 7], [-4, 5, 23, 9]])\n[[34, -4], [76, 5], [-54, 23], [7, 9]]",
      "fr": "Transpose une matrice n x m donnée.\nLa fonction prend un seul argument, matrix, qui est un tableau de tableaux représentant la matrice n x m.  \nLa matrice a n lignes et m colonnes, où 1 ≤ n ≤ 20 et 1 ≤ m ≤ 20. Chaque élément de la matrice est un entier.  \nLa fonction renvoie une nouvelle matrice qui est la transposée de la matrice d'entrée.  \n\nExemple :  \n>>> transpose_matrix([[34, 76, -54, 7], [-4, 5, 23, 9]])  \n[[34, -4], [76, 5], [-54, 23], [7, 9]]",
      "de": "Transponiert eine gegebene n x m Matrix.\nDie Funktion nimmt ein einzelnes Argument, matrix, das ein Array von Arrays darstellt, welches die n x m Matrix repräsentiert.  \nDie Matrix hat n Zeilen und m Spalten, wobei 1 ≤ n ≤ 20 und 1 ≤ m ≤ 20. Jedes Element in der Matrix ist ein ganzzahliger Wert.  \nDie Funktion gibt eine neue Matrix zurück, die die Transponierte der Eingabematrix ist.  \n\nBeispiel:  \n>>> transpose_matrix([[34, 76, -54, 7], [-4, 5, 23, 9]])  \n[[34, -4], [76, 5], [-54, 23], [7, 9]]",
      "ha": "TYana juyar da matrix n x m da aka bayar.\nAikin yana karɓar hujja guda ɗaya, matrix, wanda shine jerin jerin da ke wakiltar matrix n x m.\nMatrix ɗin yana da layuka n da ginshiƙai m, inda 1 ≤ n ≤ 20 da 1 ≤ m ≤ 20. Kowanne abu a cikin matrix ɗin lamba ce.\nAikin yana dawowa da sabon matrix wanda shine transpose na matrix ɗin shigarwa.\n\nMisali:\n>>> transpose_matrix([[34, 76, -54, 7], [-4, 5, 23, 9]])\n[[34, -4], [76, 5], [-54, 23], [7, 9]]",
      "hi": "दिए गए n x m मैट्रिक्स को ट्रांसपोज़ करता है।\nयह फ़ंक्शन एक एकल आर्ग्युमेंट, matrix, लेता है, जो n x m मैट्रिक्स का प्रतिनिधित्व करने वाले एरे का एरे होता है।  \nमैट्रिक्स में n पंक्तियाँ और m स्तंभ होते हैं, जहाँ 1 ≤ n ≤ 20 और 1 ≤ m ≤ 20। मैट्रिक्स में प्रत्येक तत्व एक पूर्णांक होता है।  \nयह फ़ंक्शन एक नया मैट्रिक्स लौटाता है जो इनपुट मैट्रिक्स का ट्रांसपोज़ होता है।  \n\nउदाहरण:  \n>>> transpose_matrix([[34, 76, -54, 7], [-4, 5, 23, 9]])  \n[[34, -4], [76, 5], [-54, 23], [7, 9]]",
      "hu": "Transzponál egy adott n x m mátrixot.\nA függvény egyetlen argumentumot vesz fel, a mátrixot, amely tömbök tömbjeként ábrázolja az n x m mátrixot.  \nA mátrix n sorból és m oszlopból áll, ahol 1 ≤ n ≤ 20 és 1 ≤ m ≤ 20. A mátrix minden eleme egész szám.  \nA függvény visszaad egy új mátrixot, amely a bemeneti mátrix transzponáltja.  \n\nPélda:  \n>>> transpose_matrix([[34, 76, -54, 7], [-4, 5, 23, 9]])  \n[[34, -4], [76, 5], [-54, 23], [7, 9]]"
    },
    "docstring_bertscore": {
      "sq": "0.9980633537849098",
      "hy": "0.9809729971702871",
      "bn": "0.9894779528254388",
      "bg": "0.9932739780373966",
      "zh": "0.9831289313260397",
      "fr": "0.9956198028374187",
      "de": "0.9945422330203044",
      "ha": "0.9837687197833531",
      "hi": "0.9920702779283251",
      "hu": "0.9783272404949023"
    }
  },
  {
    "task_id": "Ruby/10",
    "prompt": {
      "en": "# Sorts a list of students by their scores in descending order. If two students have the same score,\n# they are sorted alphabetically by their names. The function takes an array of arrays as an argument,\n# where each sub-array contains a student's name and their score. The function returns an array of \n# student names sorted as per the mentioned criteria.\n#\n# Example:\n# >>> sort_students_by_score([[\"aaa\", 47], [\"bbb\", 90], [\"ccc\", 70]])\n# [\"bbb\", \"ccc\", \"aaa\"]\n# >>> sort_students_by_score([[\"alice\", 85], [\"bob\", 85], [\"charlie\", 90]])\n# [\"charlie\", \"alice\", \"bob\"]\n\n\ndef sort_students_by_score(student_scores)",
      "sq": "# Rendit një listë studentësh sipas pikëve të tyre në rend zbritës. Nëse dy studentë kanë të njëjtën pikë,\n# ata renditen alfabetikisht sipas emrave të tyre. Funksioni merr një varg vargjesh si argument,\n# ku secili nën-varg përmban emrin e një studenti dhe pikët e tij. Funksioni kthen një varg\n# emrash studentësh të renditur sipas kritereve të përmendura.\n#\n# Shembull:\n# >>> sort_students_by_score([[\"aaa\", 47], [\"bbb\", 90], [\"ccc\", 70]])\n# [\"bbb\", \"ccc\", \"aaa\"]\n# >>> sort_students_by_score([[\"alice\", 85], [\"bob\", 85], [\"charlie\", 90]])\n# [\"charlie\", \"alice\", \"bob\"]\n\n\ndef sort_students_by_score(student_scores)",
      "hy": "# Դասավորում է ուսանողների ցուցակը ըստ նրանց գնահատականների նվազման կարգով։ Եթե երկու ուսանող ունեն նույն գնահատականը,\n# նրանք դասավորվում են այբբենական կարգով ըստ իրենց անունների։ Ֆունկցիան ընդունում է զանգվածների զանգված որպես արգումենտ,\n# որտեղ յուրաքանչյուր ենթազանգված պարունակում է ուսանողի անունը և նրանց գնահատականը։ Ֆունկցիան վերադարձնում է ուսանողների \n# անունների զանգված, որը դասավորված է նշված չափանիշներով։\n#\n# Օրինակ:\n# >>> sort_students_by_score([[\"aaa\", 47], [\"bbb\", 90], [\"ccc\", 70]])\n# [\"bbb\", \"ccc\", \"aaa\"]\n# >>> sort_students_by_score([[\"alice\", 85], [\"bob\", 85], [\"charlie\", 90]])\n# [\"charlie\", \"alice\", \"bob\"]\n\n\ndef sort_students_by_score(student_scores)",
      "bn": "# ছাত্রদের একটি তালিকা তাদের স্কোর অনুযায়ী অবতরণ ক্রমে সাজায়। যদি দুই ছাত্রের স্কোর একই হয়,\n# তাহলে তাদের নামের বর্ণানুক্রমিক ক্রমে সাজানো হয়। ফাংশনটি একটি অ্যারে অফ অ্যারেস আর্গুমেন্ট হিসেবে গ্রহণ করে,\n# যেখানে প্রতিটি সাব-অ্যারে একটি ছাত্রের নাম এবং তাদের স্কোর থাকে। ফাংশনটি ছাত্রদের নামের একটি অ্যারে\n# ফেরত দেয় যা উল্লেখিত মানদণ্ড অনুযায়ী সাজানো হয়।\n#\n# উদাহরণ:\n# >>> sort_students_by_score([[\"aaa\", 47], [\"bbb\", 90], [\"ccc\", 70]])\n# [\"bbb\", \"ccc\", \"aaa\"]\n# >>> sort_students_by_score([[\"alice\", 85], [\"bob\", 85], [\"charlie\", 90]])\n# [\"charlie\", \"alice\", \"bob\"]\n\n\ndef sort_students_by_score(student_scores)",
      "bg": "# Сортира списък от студенти по техните оценки в низходящ ред. Ако двама студенти имат еднаква оценка,\n# те се сортират по азбучен ред според имената им. Функцията приема масив от масиви като аргумент,\n# където всеки подмасив съдържа името на студент и неговата оценка. Функцията връща масив с \n# имената на студентите, сортирани според споменатите критерии.\n#\n# Пример:\n# >>> sort_students_by_score([[\"aaa\", 47], [\"bbb\", 90], [\"ccc\", 70]])\n# [\"bbb\", \"ccc\", \"aaa\"]\n# >>> sort_students_by_score([[\"alice\", 85], [\"bob\", 85], [\"charlie\", 90]])\n# [\"charlie\", \"alice\", \"bob\"]\n\n\ndef sort_students_by_score(student_scores)",
      "zh": "# 按学生的分数以降序排序列表。如果两个学生的分数相同，\n# 则按他们的名字按字母顺序排序。该函数接受一个数组的数组作为参数，\n# 每个子数组包含一个学生的名字和他们的分数。该函数返回一个\n# 按上述标准排序的学生名字数组。\n#\n# 示例:\n# >>> sort_students_by_score([[\"aaa\", 47], [\"bbb\", 90], [\"ccc\", 70]])\n# [\"bbb\", \"ccc\", \"aaa\"]\n# >>> sort_students_by_score([[\"alice\", 85], [\"bob\", 85], [\"charlie\", 90]])\n# [\"charlie\", \"alice\", \"bob\"]\n\n\ndef sort_students_by_score(student_scores)",
      "fr": "# Trie une liste d'étudiants par leurs scores par ordre décroissant. Si deux étudiants ont le même score,\n# ils sont triés par ordre alphabétique de leurs noms. La fonction prend un tableau de tableaux comme argument,\n# où chaque sous-tableau contient le nom d'un étudiant et son score. La fonction renvoie un tableau de \n# noms d'étudiants triés selon les critères mentionnés.\n#\n# Exemple:\n# >>> sort_students_by_score([[\"aaa\", 47], [\"bbb\", 90], [\"ccc\", 70]])\n# [\"bbb\", \"ccc\", \"aaa\"]\n# >>> sort_students_by_score([[\"alice\", 85], [\"bob\", 85], [\"charlie\", 90]])\n# [\"charlie\", \"alice\", \"bob\"]\n\n\ndef sort_students_by_score(student_scores)",
      "de": "# Sortiert eine Liste von Studenten nach ihren Punktzahlen in absteigender Reihenfolge. Wenn zwei Studenten\n# die gleiche Punktzahl haben, werden sie alphabetisch nach ihren Namen sortiert. Die Funktion nimmt ein\n# Array von Arrays als Argument, wobei jedes Unter-Array den Namen eines Studenten und seine Punktzahl enthält.\n# Die Funktion gibt ein Array von Studentennamen zurück, das gemäß den genannten Kriterien sortiert ist.\n#\n# Beispiel:\n# >>> sort_students_by_score([[\"aaa\", 47], [\"bbb\", 90], [\"ccc\", 70]])\n# [\"bbb\", \"ccc\", \"aaa\"]\n# >>> sort_students_by_score([[\"alice\", 85], [\"bob\", 85], [\"charlie\", 90]])\n# [\"charlie\", \"alice\", \"bob\"]\n\n\ndef sort_students_by_score(student_scores)",
      "ha": "# Yana tsara jerin ɗalibai ta maki a cikin tsari mai saukowa. Idan ɗalibai biyu suna da maki iri ɗaya,\n# ana tsara su bisa haruffa ta sunayensu. Aikin yana karɓar jerin jerin azaman hujja,\n# inda kowace ƙaramin jeri ke ɗauke da sunan ɗalibi da maki nasu. Aikin yana dawowa da jerin\n# sunayen ɗalibai da aka tsara bisa ga ka'idodin da aka ambata.\n#\n# Misali:\n# >>> sort_students_by_score([[\"aaa\", 47], [\"bbb\", 90], [\"ccc\", 70]])\n# [\"bbb\", \"ccc\", \"aaa\"]\n# >>> sort_students_by_score([[\"alice\", 85], [\"bob\", 85], [\"charlie\", 90]])\n# [\"charlie\", \"alice\", \"bob\"]\n\n\ndef sort_students_by_score(student_scores)",
      "hi": "# छात्रों की सूची को उनके अंकों के अनुसार घटते क्रम में क्रमबद्ध करता है। यदि दो छात्रों के अंक समान हैं,\n# तो उन्हें उनके नामों के अनुसार वर्णानुक्रम में क्रमबद्ध किया जाता है। यह फ़ंक्शन एक सरणी का तर्क के रूप में लेता है,\n# जहाँ प्रत्येक उप-सरणी में एक छात्र का नाम और उनके अंक होते हैं। यह फ़ंक्शन छात्रों के नामों की एक सरणी लौटाता है\n# जो उल्लेखित मानदंडों के अनुसार क्रमबद्ध होती है।\n#\n# उदाहरण:\n# >>> sort_students_by_score([[\"aaa\", 47], [\"bbb\", 90], [\"ccc\", 70]])\n# [\"bbb\", \"ccc\", \"aaa\"]\n# >>> sort_students_by_score([[\"alice\", 85], [\"bob\", 85], [\"charlie\", 90]])\n# [\"charlie\", \"alice\", \"bob\"]\n\n\ndef sort_students_by_score(student_scores)",
      "hu": "# Egy listát rendez a diákok pontszámai alapján csökkenő sorrendben. Ha két diáknak azonos a pontszáma,\n# akkor ábécé sorrendben rendezi őket a nevük alapján. A függvény egy tömbök tömbjét veszi argumentumként,\n# ahol minden al-tömb tartalmazza egy diák nevét és pontszámát. A függvény egy diákneveket tartalmazó tömböt ad vissza\n# a megadott kritériumok szerinti sorrendben.\n#\n# Példa:\n# >>> sort_students_by_score([[\"aaa\", 47], [\"bbb\", 90], [\"ccc\", 70]])\n# [\"bbb\", \"ccc\", \"aaa\"]\n# >>> sort_students_by_score([[\"alice\", 85], [\"bob\", 85], [\"charlie\", 90]])\n# [\"charlie\", \"alice\", \"bob\"]\n\n\ndef sort_students_by_score(student_scores)"
    },
    "prompt_bertscore": {
      "sq": "0.990463954036896",
      "hy": "0.989484507628013",
      "bn": "0.9855224274175101",
      "bg": "0.9866142986220588",
      "zh": "0.9802019140311096",
      "fr": "0.9978855795938836",
      "de": "0.9914290990583445",
      "ha": "0.9772232528371104",
      "hi": "0.988340595263633",
      "hu": "0.9785650010610011"
    },
    "canonical_solution": "    student_scores.sort do |a, b|\n      if a[1] == b[1]\n        a[0] <=> b[0]\n      else\n        b[1] <=> a[1]\n      end\n    end.map(&:first)\n  end",
    "instruction": {
      "en": "Write a ruby function `def sort_students_by_score(student_scores)` to solve the following problem:\nSorts a list of students by their scores in descending order. If two students have the same score,\nthey are sorted alphabetically by their names. The function takes an array of arrays as an argument,\nwhere each sub-array contains a student's name and their score. The function returns an array of\nstudent names sorted as per the mentioned criteria.\n\nExample:\n>>> sort_students_by_score([[\"aaa\", 47], [\"bbb\", 90], [\"ccc\", 70]])\n[\"bbb\", \"ccc\", \"aaa\"]\n>>> sort_students_by_score([[\"alice\", 85], [\"bob\", 85], [\"charlie\", 90]])\n[\"charlie\", \"alice\", \"bob\"]",
      "sq": "Shkruani një funksion ruby `def sort_students_by_score(student_scores)` për të zgjidhur problemin në vijim:\nRendit një listë studentësh sipas pikëve të tyre në rend zbritës. Nëse dy studentë kanë të njëjtën pikë,\nata renditen alfabetikisht sipas emrave të tyre. Funksioni merr një varg me vargje si argument,\nku çdo nën-varg përmban emrin e një studenti dhe pikët e tij. Funksioni kthen një varg me\nemrat e studentëve të renditur sipas kritereve të përmendura.\n\nShembull:\n>>> sort_students_by_score([[\"aaa\", 47], [\"bbb\", 90], [\"ccc\", 70]])\n[\"bbb\", \"ccc\", \"aaa\"]\n>>> sort_students_by_score([[\"alice\", 85], [\"bob\", 85], [\"charlie\", 90]])\n[\"charlie\", \"alice\", \"bob\"]",
      "hy": "Գրեք ruby ֆունկցիա `def sort_students_by_score(student_scores)` հետևյալ խնդիրը լուծելու համար:\nԴասավորում է ուսանողների ցուցակը ըստ նրանց գնահատականների նվազման կարգով։ Եթե երկու ուսանող ունեն նույն գնահատականը, նրանք դասավորվում են այբբենական կարգով իրենց անուններով։ Ֆունկցիան ընդունում է զանգվածների զանգված որպես արգումենտ, որտեղ յուրաքանչյուր ենթազանգված պարունակում է ուսանողի անունը և նրանց գնահատականը։ Ֆունկցիան վերադարձնում է ուսանողների անունների զանգվածը, որը դասավորված է նշված չափանիշներով։\n\nՕրինակ:\n>>> sort_students_by_score([[\"aaa\", 47], [\"bbb\", 90], [\"ccc\", 70]])\n[\"bbb\", \"ccc\", \"aaa\"]\n>>> sort_students_by_score([[\"alice\", 85], [\"bob\", 85], [\"charlie\", 90]])\n[\"charlie\", \"alice\", \"bob\"]",
      "bn": "রুবি ফাংশন `def sort_students_by_score(student_scores)` লিখুন নিম্নলিখিত সমস্যার সমাধানের জন্য:\nএকটি তালিকায় থাকা ছাত্রদের তাদের স্কোর অনুযায়ী অবরোহ ক্রমে সাজায়। যদি দুইজন ছাত্রের স্কোর একই হয়, তাহলে তাদের নামের বর্ণানুক্রম অনুযায়ী সাজানো হয়। ফাংশনটি একটি অ্যারে অফ অ্যারে আর্গুমেন্ট হিসেবে গ্রহণ করে, যেখানে প্রতিটি সাব-অ্যারে একটি ছাত্রের নাম এবং তাদের স্কোর থাকে। ফাংশনটি উল্লেখিত মানদণ্ড অনুযায়ী সাজানো ছাত্রদের নামের একটি অ্যারে প্রদান করে।\n\nউদাহরণ:\n>>> sort_students_by_score([[\"aaa\", 47], [\"bbb\", 90], [\"ccc\", 70]])\n[\"bbb\", \"ccc\", \"aaa\"]\n>>> sort_students_by_score([[\"alice\", 85], [\"bob\", 85], [\"charlie\", 90]])\n[\"charlie\", \"alice\", \"bob\"]",
      "bg": "Напишете функция на Ruby `def sort_students_by_score(student_scores)`, за да решите следния проблем:\nСортира списък от студенти по техните оценки в низходящ ред. Ако двама студенти имат еднаква оценка,\nте се сортират по азбучен ред по техните имена. Функцията приема масив от масиви като аргумент,\nкъдето всеки подмасив съдържа името на студент и неговата оценка. Функцията връща масив от\nимената на студентите, сортирани според споменатите критерии.\n\nПример:\n>>> sort_students_by_score([[\"aaa\", 47], [\"bbb\", 90], [\"ccc\", 70]])\n[\"bbb\", \"ccc\", \"aaa\"]\n>>> sort_students_by_score([[\"alice\", 85], [\"bob\", 85], [\"charlie\", 90]])\n[\"charlie\", \"alice\", \"bob\"]",
      "zh": "编写一个 ruby 函数 `def sort_students_by_score(student_scores)` 来解决以下问题：\n按学生的分数以降序排列学生列表。如果两个学生的分数相同，则按他们的名字按字母顺序排序。该函数接受一个数组的数组作为参数，其中每个子数组包含一个学生的名字和他们的分数。该函数返回一个按上述标准排序的学生名字数组。\n\n示例：\n>>> sort_students_by_score([[\"aaa\", 47], [\"bbb\", 90], [\"ccc\", 70]])\n[\"bbb\", \"ccc\", \"aaa\"]\n>>> sort_students_by_score([[\"alice\", 85], [\"bob\", 85], [\"charlie\", 90]])\n[\"charlie\", \"alice\", \"bob\"]",
      "fr": "Écrire une fonction ruby `def sort_students_by_score(student_scores)` pour résoudre le problème suivant :\nTrie une liste d'étudiants par leurs scores par ordre décroissant. Si deux étudiants ont le même score, ils sont triés alphabétiquement par leurs noms. La fonction prend un tableau de tableaux comme argument, où chaque sous-tableau contient le nom d'un étudiant et son score. La fonction renvoie un tableau de noms d'étudiants triés selon les critères mentionnés.\n\nExemple :\n>>> sort_students_by_score([[\"aaa\", 47], [\"bbb\", 90], [\"ccc\", 70]])\n[\"bbb\", \"ccc\", \"aaa\"]\n>>> sort_students_by_score([[\"alice\", 85], [\"bob\", 85], [\"charlie\", 90]])\n[\"charlie\", \"alice\", \"bob\"]",
      "de": "Schreiben Sie eine Ruby-Funktion `def sort_students_by_score(student_scores)`, um das folgende Problem zu lösen:\nSortiert eine Liste von Studenten nach ihren Punktzahlen in absteigender Reihenfolge. Wenn zwei Studenten die gleiche Punktzahl haben, werden sie alphabetisch nach ihren Namen sortiert. Die Funktion nimmt ein Array von Arrays als Argument, wobei jedes Unter-Array den Namen eines Studenten und seine Punktzahl enthält. Die Funktion gibt ein Array von Studentennamen zurück, das nach den genannten Kriterien sortiert ist.\n\nBeispiel:\n>>> sort_students_by_score([[\"aaa\", 47], [\"bbb\", 90], [\"ccc\", 70]])\n[\"bbb\", \"ccc\", \"aaa\"]\n>>> sort_students_by_score([[\"alice\", 85], [\"bob\", 85], [\"charlie\", 90]])\n[\"charlie\", \"alice\", \"bob\"]",
      "ha": "Rubuta aikin ruby `def sort_students_by_score(student_scores)` don warware matsalar mai zuwa: \n\nYana tsara jerin ɗalibai bisa ga maki nasu a cikin tsari mai saukarwa. Idan ɗalibai biyu suna da maki iri ɗaya, za a tsara su bisa ga haruffa ta sunayensu. Aikin yana ɗaukar jerin jerin azaman hujja, inda kowace ƙaramin jeri ke ɗauke da sunan ɗalibi da maki nasu. Aikin yana dawowa da jerin sunayen ɗalibai da aka tsara bisa ga ka'idodin da aka ambata.\n\nMisali:\n>>> sort_students_by_score([[\"aaa\", 47], [\"bbb\", 90], [\"ccc\", 70]])\n[\"bbb\", \"ccc\", \"aaa\"]\n>>> sort_students_by_score([[\"alice\", 85], [\"bob\", 85], [\"charlie\", 90]])\n[\"charlie\", \"alice\", \"bob\"]",
      "hi": "`def sort_students_by_score(student_scores)` नामक एक रूबी फ़ंक्शन लिखें ताकि निम्नलिखित समस्या का समाधान किया जा सके:\nछात्रों की एक सूची को उनके अंकों के अनुसार अवरोही क्रम में क्रमबद्ध करता है। यदि दो छात्रों के अंक समान हैं, तो उन्हें उनके नामों के अनुसार वर्णानुक्रम में क्रमबद्ध किया जाता है। यह फ़ंक्शन एक सरणी का तर्क के रूप में लेता है, जहाँ प्रत्येक उप-सरणी में एक छात्र का नाम और उनका अंक होता है। यह फ़ंक्शन छात्रों के नामों की एक सरणी लौटाता है जो उल्लिखित मानदंडों के अनुसार क्रमबद्ध होती है।\n\nउदाहरण:\n>>> sort_students_by_score([[\"aaa\", 47], [\"bbb\", 90], [\"ccc\", 70]])\n[\"bbb\", \"ccc\", \"aaa\"]\n>>> sort_students_by_score([[\"alice\", 85], [\"bob\", 85], [\"charlie\", 90]])\n[\"charlie\", \"alice\", \"bob\"]",
      "hu": "Írj egy Ruby függvényt `def sort_students_by_score(student_scores)` a következő probléma megoldására:\nRendez egy listát a diákokról a pontszámaik alapján csökkenő sorrendben. Ha két diáknak azonos a pontszáma, akkor ábécé sorrendben rendeződnek a nevük alapján. A függvény egy tömböt vesz át argumentumként, ahol minden al-tömb tartalmazza egy diák nevét és pontszámát. A függvény visszaad egy tömböt a diáknevekkel, az említett kritériumok szerint rendezve.\n\nPélda:\n>>> sort_students_by_score([[\"aaa\", 47], [\"bbb\", 90], [\"ccc\", 70]])\n[\"bbb\", \"ccc\", \"aaa\"]\n>>> sort_students_by_score([[\"alice\", 85], [\"bob\", 85], [\"charlie\", 90]])\n[\"charlie\", \"alice\", \"bob\"]"
    },
    "instruction_bertscore": {
      "sq": "0.9876880944619335",
      "hy": "0.9921493328199771",
      "bn": "0.983056629867343",
      "bg": "0.979629461272967",
      "zh": "0.9785751312104338",
      "fr": "0.9942641504868556",
      "de": "0.9974182023073085",
      "ha": "0.979777242276457",
      "hi": "0.9883475473269693",
      "hu": "0.9822895193357862"
    },
    "level": "easy",
    "test": "raise 'Test failed' unless sort_students_by_score([[\"aaa\", 47], [\"bbb\", 90], [\"ccc\", 70]]) == [\"bbb\", \"ccc\", \"aaa\"]\nraise 'Test failed' unless sort_students_by_score([[\"alice\", 85], [\"bob\", 85], [\"charlie\", 90]]) == [\"charlie\", \"alice\", \"bob\"]\nraise 'Test failed' unless sort_students_by_score([[\"zoe\", 95], [\"adam\", 95], [\"mia\", 88]]) == [\"adam\", \"zoe\", \"mia\"]\nraise 'Test failed' unless sort_students_by_score([[\"lara\", 70], [\"max\", 70], [\"sam\", 70]]) == [\"lara\", \"max\", \"sam\"]\nraise 'Test failed' unless sort_students_by_score([[\"john\", 100]]) == [\"john\"]\n\n\nputs 'All tests passed!'",
    "entry_point": "sort_students_by_score",
    "signature": "def sort_students_by_score(student_scores)",
    "docstring": {
      "en": "Sorts a list of students by their scores in descending order. If two students have the same score,\nthey are sorted alphabetically by their names. The function takes an array of arrays as an argument,\nwhere each sub-array contains a student's name and their score. The function returns an array of\nstudent names sorted as per the mentioned criteria.\n\nExample:\n>>> sort_students_by_score([[\"aaa\", 47], [\"bbb\", 90], [\"ccc\", 70]])\n[\"bbb\", \"ccc\", \"aaa\"]\n>>> sort_students_by_score([[\"alice\", 85], [\"bob\", 85], [\"charlie\", 90]])\n[\"charlie\", \"alice\", \"bob\"]",
      "sq": "Rendit një listë studentësh sipas pikëve të tyre në rend zbritës. Nëse dy studentë kanë të njëjtën pikë, ata renditen alfabetikisht sipas emrave të tyre. Funksioni merr një varg arraysh si argument, ku secili nën-array përmban emrin e një studenti dhe pikët e tij. Funksioni kthen një varg emrash studentësh të renditur sipas kritereve të përmendura.\n\nShembull:\n>>> sort_students_by_score([[\"aaa\", 47], [\"bbb\", 90], [\"ccc\", 70]])\n[\"bbb\", \"ccc\", \"aaa\"]\n>>> sort_students_by_score([[\"alice\", 85], [\"bob\", 85], [\"charlie\", 90]])\n[\"charlie\", \"alice\", \"bob\"]",
      "hy": "Դասավորում է ուսանողների ցուցակը ըստ նրանց գնահատականների նվազման կարգով: Եթե երկու ուսանող ունեն նույն գնահատականը, նրանք դասավորվում են այբբենական կարգով իրենց անուններով: Ֆունկցիան ընդունում է զանգվածների զանգված որպես արգումենտ, որտեղ յուրաքանչյուր ենթազանգված պարունակում է ուսանողի անունը և նրանց գնահատականը: Ֆունկցիան վերադարձնում է ուսանողների անունների զանգվածը, դասավորված ըստ նշված չափանիշների:\n\nՕրինակ:\n>>> sort_students_by_score([[\"aaa\", 47], [\"bbb\", 90], [\"ccc\", 70]])\n[\"bbb\", \"ccc\", \"aaa\"]\n>>> sort_students_by_score([[\"alice\", 85], [\"bob\", 85], [\"charlie\", 90]])\n[\"charlie\", \"alice\", \"bob\"]",
      "bn": "ছাত্রদের একটি তালিকা তাদের স্কোর অনুযায়ী অবনমন ক্রমে সাজায়। যদি দুই ছাত্রের একই স্কোর থাকে, তাহলে তাদের নামের বর্ণানুক্রমে সাজানো হয়। ফাংশনটি একটি অ্যারে অফ অ্যারে গ্রহণ করে, যেখানে প্রতিটি উপ-অ্যারে একটি ছাত্রের নাম এবং তাদের স্কোর থাকে। ফাংশনটি উল্লেখিত মানদণ্ড অনুযায়ী সাজানো ছাত্রদের নামের একটি অ্যারে প্রদান করে।\n\nউদাহরণ:\n>>> sort_students_by_score([[\"aaa\", 47], [\"bbb\", 90], [\"ccc\", 70]])\n[\"bbb\", \"ccc\", \"aaa\"]\n>>> sort_students_by_score([[\"alice\", 85], [\"bob\", 85], [\"charlie\", 90]])\n[\"charlie\", \"alice\", \"bob\"]",
      "bg": "Сортира списък от студенти по техните оценки в низходящ ред. Ако двама студенти имат еднаква оценка, те се сортират по азбучен ред на имената си. Функцията приема масив от масиви като аргумент, където всеки подмасив съдържа име на студент и неговата оценка. Функцията връща масив от имена на студенти, сортирани според споменатите критерии.\n\nПример:\n>>> sort_students_by_score([[\"aaa\", 47], [\"bbb\", 90], [\"ccc\", 70]])\n[\"bbb\", \"ccc\", \"aaa\"]\n>>> sort_students_by_score([[\"alice\", 85], [\"bob\", 85], [\"charlie\", 90]])\n[\"charlie\", \"alice\", \"bob\"]",
      "zh": "对学生列表按分数进行降序排序。如果两个学生的分数相同，则按名字的字母顺序排序。该函数接受一个数组的数组作为参数，其中每个子数组包含一个学生的名字和他们的分数。该函数返回一个按上述标准排序的学生名字数组。\n\n示例：\n>>> sort_students_by_score([[\"aaa\", 47], [\"bbb\", 90], [\"ccc\", 70]])\n[\"bbb\", \"ccc\", \"aaa\"]\n>>> sort_students_by_score([[\"alice\", 85], [\"bob\", 85], [\"charlie\", 90]])\n[\"charlie\", \"alice\", \"bob\"]",
      "fr": "Trie une liste d'étudiants par leurs scores dans l'ordre décroissant. Si deux étudiants ont le même score, ils sont triés par ordre alphabétique de leurs noms. La fonction prend un tableau de tableaux en argument, où chaque sous-tableau contient le nom d'un étudiant et son score. La fonction renvoie un tableau de noms d'étudiants triés selon les critères mentionnés.\n\nExemple :\n>>> sort_students_by_score([[\"aaa\", 47], [\"bbb\", 90], [\"ccc\", 70]])\n[\"bbb\", \"ccc\", \"aaa\"]\n>>> sort_students_by_score([[\"alice\", 85], [\"bob\", 85], [\"charlie\", 90]])\n[\"charlie\", \"alice\", \"bob\"]",
      "de": "Sortiert eine Liste von Studenten nach ihren Punkten in absteigender Reihenfolge. Wenn zwei Studenten die gleiche Punktzahl haben, werden sie alphabetisch nach ihren Namen sortiert. Die Funktion nimmt ein Array von Arrays als Argument, wobei jedes Unter-Array den Namen eines Studenten und seine Punktzahl enthält. Die Funktion gibt ein Array von Studentennamen zurück, das nach den genannten Kriterien sortiert ist.\n\nBeispiel:\n>>> sort_students_by_score([[\"aaa\", 47], [\"bbb\", 90], [\"ccc\", 70]])\n[\"bbb\", \"ccc\", \"aaa\"]\n>>> sort_students_by_score([[\"alice\", 85], [\"bob\", 85], [\"charlie\", 90]])\n[\"charlie\", \"alice\", \"bob\"]",
      "ha": "Yana tsara jerin ɗalibai ta maki a cikin tsari mai saukowa. Idan ɗalibai biyu suna da maki iri ɗaya, ana tsara su ta haruffa bisa sunayensu. Aikin yana ɗaukar jerin jerin azaman hujja, inda kowace ƙaramin jeri ke ɗauke da sunan ɗalibi da maki nasu. Aikin yana dawowa da jerin sunayen ɗalibai da aka tsara bisa ga ka'idodin da aka ambata.\n\nMisali:\n>>> sort_students_by_score([[\"aaa\", 47], [\"bbb\", 90], [\"ccc\", 70]])\n[\"bbb\", \"ccc\", \"aaa\"]\n>>> sort_students_by_score([[\"alice\", 85], [\"bob\", 85], [\"charlie\", 90]])\n[\"charlie\", \"alice\", \"bob\"]",
      "hi": "छात्रों की सूची को उनके अंकों के अनुसार अवरोही क्रम में क्रमबद्ध करता है। यदि दो छात्रों के अंक समान हैं, तो उन्हें उनके नामों के अनुसार वर्णानुक्रम में क्रमबद्ध किया जाता है। यह फ़ंक्शन एक तर्क के रूप में उप-ऐरे की एक सरणी लेता है, जहाँ प्रत्येक उप-ऐरे में एक छात्र का नाम और उनका अंक होता है। यह फ़ंक्शन छात्र नामों की एक सरणी लौटाता है जो उल्लिखित मानदंडों के अनुसार क्रमबद्ध होती है।\n\nउदाहरण:\n>>> sort_students_by_score([[\"aaa\", 47], [\"bbb\", 90], [\"ccc\", 70]])\n[\"bbb\", \"ccc\", \"aaa\"]\n>>> sort_students_by_score([[\"alice\", 85], [\"bob\", 85], [\"charlie\", 90]])\n[\"charlie\", \"alice\", \"bob\"]",
      "hu": "Sorba rendezi a diákok listáját a pontszámaik alapján csökkenő sorrendben. Ha két diáknak azonos a pontszáma, akkor ábécé sorrendben kerülnek rendezésre a nevük alapján. A függvény egy tömbök tömbjét veszi argumentumként, ahol minden al-tömb egy diák nevét és pontszámát tartalmazza. A függvény egy diákneveket tartalmazó tömböt ad vissza a megadott kritériumok szerint rendezve.\n\nPélda:\n>>> sort_students_by_score([[\"aaa\", 47], [\"bbb\", 90], [\"ccc\", 70]])\n[\"bbb\", \"ccc\", \"aaa\"]\n>>> sort_students_by_score([[\"alice\", 85], [\"bob\", 85], [\"charlie\", 90]])\n[\"charlie\", \"alice\", \"bob\"]"
    },
    "docstring_bertscore": {
      "sq": "0.9905229472600634",
      "hy": "0.9881951978247155",
      "bn": "0.9779786441761861",
      "bg": "0.9950833021782434",
      "zh": "0.9723148974913572",
      "fr": "0.9905229472600634",
      "de": "0.9979658262678217",
      "ha": "0.9702783401946066",
      "hi": "0.9738000568503551",
      "hu": "0.9871148471822668"
    }
  },
  {
    "task_id": "Ruby/11",
    "prompt": {
      "en": "# Calculates the total number of drinks a customer can enjoy under a promotional offer.\n# Under this offer, for every 3 bottle caps, the customer can get 1 additional drink.\n# The promotion continues as long as the customer has enough caps for exchange.\n#\n# The function takes a single integer argument, n, which represents the initial number\n# of drinks purchased. It returns an integer representing the total number of drinks\n# the customer can enjoy, including those received through the promotion.\n#\n# Examples:\n# >>> total_drinks_with_promo(100)\n# 149\n# >>> total_drinks_with_promo(3)\n# 4\n\ndef total_drinks_with_promo(n)",
      "sq": "# Llogarit numrin total të pijeve që një klient mund të shijojë nën një ofertë promovuese.\n# Nën këtë ofertë, për çdo 3 kapakë shishesh, klienti mund të marrë 1 pije shtesë.\n# Promocioni vazhdon për sa kohë që klienti ka mjaft kapakë për shkëmbim.\n#\n# Funksioni merr një argument të vetëm të tipit integer, n, që përfaqëson numrin fillestar\n# të pijeve të blera. Ai kthen një integer që përfaqëson numrin total të pijeve\n# që klienti mund të shijojë, duke përfshirë ato të marra përmes promocionit.\n#\n# Shembuj:\n# >>> total_drinks_with_promo(100)\n# 149\n# >>> total_drinks_with_promo(3)\n# 4\n\ndef total_drinks_with_promo(n)",
      "hy": "# Հաշվում է խմիչքների ընդհանուր քանակը, որը հաճախորդը կարող է վայելել հատուկ առաջարկի պայմաններում։\n# Այս առաջարկի շրջանակներում, յուրաքանչյուր 3 շշի կափարիչի դիմաց հաճախորդը կարող է ստանալ 1 լրացուցիչ խմիչք։\n# Ակցիան շարունակվում է այնքան ժամանակ, քանի դեռ հաճախորդը ունի բավարար կափարիչներ փոխանակման համար։\n#\n# Ֆունկցիան ընդունում է մեկ ամբողջ թիվ արգումենտ, n, որը ներկայացնում է սկզբնական գնված խմիչքների քանակը։\n# Այն վերադարձնում է ամբողջ թիվ, որը ներկայացնում է խմիչքների ընդհանուր քանակը, որը հաճախորդը կարող է վայելել, ներառյալ ակցիայի միջոցով ստացվածները։\n#\n# Օրինակներ:\n# >>> total_drinks_with_promo(100)\n# 149\n# >>> total_drinks_with_promo(3)\n# 4\n\ndef total_drinks_with_promo(n)",
      "bn": "# একটি প্রচারমূলক অফারের অধীনে একজন গ্রাহক মোট কতগুলি পানীয় উপভোগ করতে পারেন তা গণনা করে।\n# এই অফারের অধীনে, প্রতি ৩টি বোতলের ঢাকনার জন্য, গ্রাহক ১টি অতিরিক্ত পানীয় পেতে পারেন।\n# যতক্ষণ গ্রাহকের কাছে বিনিময়ের জন্য পর্যাপ্ত ঢাকনা থাকে ততক্ষণ প্রচার চলতে থাকে।\n#\n# ফাংশনটি একটি একক পূর্ণসংখ্যা আর্গুমেন্ট গ্রহণ করে, n, যা প্রাথমিকভাবে কেনা পানীয়ের সংখ্যা\n# উপস্থাপন করে। এটি একটি পূর্ণসংখ্যা প্রদান করে যা মোট পানীয়ের সংখ্যা উপস্থাপন করে\n# যা গ্রাহক উপভোগ করতে পারেন, প্রচারের মাধ্যমে প্রাপ্তগুলি সহ।\n#\n# উদাহরণ:\n# >>> total_drinks_with_promo(100)\n# 149\n# >>> total_drinks_with_promo(3)\n# 4\n\ndef total_drinks_with_promo(n)",
      "bg": "# Изчислява общия брой напитки, които клиентът може да се наслади по време на промоционална оферта.\n# При тази оферта, за всеки 3 капачки от бутилки, клиентът може да получи 1 допълнителна напитка.\n# Промоцията продължава, докато клиентът има достатъчно капачки за размяна.\n#\n# Функцията приема единствен аргумент цяло число, n, което представлява първоначалния брой\n# закупени напитки. Тя връща цяло число, представляващо общия брой напитки,\n# на които клиентът може да се наслади, включително тези, получени чрез промоцията.\n#\n# Примери:\n# >>> total_drinks_with_promo(100)\n# 149\n# >>> total_drinks_with_promo(3)\n# 4\n\ndef total_drinks_with_promo(n)",
      "zh": "# 计算顾客在促销活动下可以享用的饮料总数。\n# 在此优惠中，每3个瓶盖，顾客可以获得1瓶额外的饮料。\n# 促销活动会持续进行，只要顾客有足够的瓶盖可以兑换。\n#\n# 该函数接受一个整数参数n，表示最初购买的饮料数量。\n# 它返回一个整数，表示顾客可以享用的饮料总数，包括通过促销获得的饮料。\n#\n# 例子:\n# >>> total_drinks_with_promo(100)\n# 149\n# >>> total_drinks_with_promo(3)\n# 4\n\ndef total_drinks_with_promo(n)",
      "fr": "# Calcule le nombre total de boissons qu'un client peut apprécier dans le cadre d'une offre promotionnelle.\n# Dans le cadre de cette offre, pour chaque 3 capsules, le client peut obtenir 1 boisson supplémentaire.\n# La promotion continue tant que le client a suffisamment de capsules pour l'échange.\n#\n# La fonction prend un seul argument entier, n, qui représente le nombre initial\n# de boissons achetées. Elle renvoie un entier représentant le nombre total de boissons\n# que le client peut apprécier, y compris celles reçues grâce à la promotion.\n#\n# Exemples :\n# >>> total_drinks_with_promo(100)\n# 149\n# >>> total_drinks_with_promo(3)\n# 4\n\ndef total_drinks_with_promo(n)",
      "de": "# Berechnet die Gesamtanzahl der Getränke, die ein Kunde im Rahmen eines Sonderangebots genießen kann.\n# Bei diesem Angebot kann der Kunde für je 3 Kronkorken 1 zusätzliches Getränk erhalten.\n# Die Aktion läuft weiter, solange der Kunde genügend Kronkorken zum Tauschen hat.\n#\n# Die Funktion nimmt ein einzelnes ganzzahliges Argument, n, das die anfängliche Anzahl\n# der gekauften Getränke darstellt. Sie gibt eine ganze Zahl zurück, die die Gesamtanzahl\n# der Getränke darstellt, die der Kunde genießen kann, einschließlich der durch die Aktion erhaltenen.\n#\n# Beispiele:\n# >>> total_drinks_with_promo(100)\n# 149\n# >>> total_drinks_with_promo(3)\n# 4\n\ndef total_drinks_with_promo(n)",
      "ha": "# Lissafi jimillar adadin abin sha da abokin ciniki zai iya morewa a ƙarƙashin tayin talla.\n# A ƙarƙashin wannan tayin, don kowanne kwalba 3, abokin ciniki zai iya samun karin abin sha 1.\n# Tayin yana ci gaba muddin abokin ciniki yana da isassun kwalabe don musanya.\n#\n# Aikin yana karɓar hujja guda ɗaya mai lamba, n, wanda ke wakiltar adadin farko\n# na abin sha da aka saya. Yana dawo da lamba mai wakiltar jimillar adadin abin sha\n# da abokin ciniki zai iya morewa, gami da waɗanda aka samu ta hanyar tayin.\n#\n# Misalai:\n# >>> total_drinks_with_promo(100)\n# 149\n# >>> total_drinks_with_promo(3)\n# 4\n\ndef total_drinks_with_promo(n)",
      "hi": "# एक प्रचारक प्रस्ताव के तहत एक ग्राहक कितने कुल पेय का आनंद ले सकता है, इसकी गणना करता है।\n# इस प्रस्ताव के तहत, हर 3 बोतल कैप्स के लिए, ग्राहक को 1 अतिरिक्त पेय मिल सकता है।\n# प्रचार तब तक जारी रहता है जब तक ग्राहक के पास विनिमय के लिए पर्याप्त कैप्स होते हैं।\n#\n# यह फ़ंक्शन एक एकल पूर्णांक तर्क, n, लेता है, जो खरीदे गए प्रारंभिक पेय की संख्या का प्रतिनिधित्व करता है।\n# यह एक पूर्णांक लौटाता है जो कुल पेय की संख्या का प्रतिनिधित्व करता है\n# जिसका ग्राहक आनंद ले सकता है, उन पेयों सहित जो प्रचार के माध्यम से प्राप्त होते हैं।\n#\n# उदाहरण:\n# >>> total_drinks_with_promo(100)\n# 149\n# >>> total_drinks_with_promo(3)\n# 4\n\ndef total_drinks_with_promo(n)",
      "hu": "# Kiszámítja az összes ital számát, amit egy vásárló élvezhet egy promóciós ajánlat keretében.\n# Ezen ajánlat szerint minden 3 kupakért a vásárló 1 további italt kaphat.\n# A promóció addig folytatódik, amíg a vásárlónak elegendő kupakja van a cseréhez.\n#\n# A függvény egyetlen egész szám argumentumot vesz fel, n, amely az eredetileg vásárolt italok számát jelenti.\n# Egész számot ad vissza, amely az összes italt jelenti, amit a vásárló élvezhet, beleértve a promóció révén kapottakat is.\n#\n# Példák:\n# >>> total_drinks_with_promo(100)\n# 149\n# >>> total_drinks_with_promo(3)\n# 4\n\ndef total_drinks_with_promo(n)"
    },
    "prompt_bertscore": {
      "sq": "0.9880662867074239",
      "hy": "0.983181369746633",
      "bn": "0.9874104091892467",
      "bg": "0.9841069873222555",
      "zh": "0.9616115007789113",
      "fr": "0.9795015433075805",
      "de": "0.9808315723389902",
      "ha": "0.9809702163449525",
      "hi": "0.9877153068241352",
      "hu": "0.9738528925317105"
    },
    "canonical_solution": "    total_drinks = n\n    caps = n\n  \n    while caps >= 3\n      exchanged_drinks = caps / 3\n      total_drinks += exchanged_drinks\n      caps = caps % 3 + exchanged_drinks\n    end\n  \n    total_drinks\n  end",
    "instruction": {
      "en": "Write a ruby function `def total_drinks_with_promo(n)` to solve the following problem:\nCalculates the total number of drinks a customer can enjoy under a promotional offer.\nUnder this offer, for every 3 bottle caps, the customer can get 1 additional drink.\nThe promotion continues as long as the customer has enough caps for exchange.\n\nThe function takes a single integer argument, n, which represents the initial number\nof drinks purchased. It returns an integer representing the total number of drinks\nthe customer can enjoy, including those received through the promotion.\n\nExamples:\n>>> total_drinks_with_promo(100)\n149\n>>> total_drinks_with_promo(3)\n4",
      "sq": "Shkruani një funksion ruby `def total_drinks_with_promo(n)` për të zgjidhur problemin në vijim:\nLlogarit numrin total të pijeve që një klient mund të shijojë nën një ofertë promocionale.\nNën këtë ofertë, për çdo 3 kapakë shishe, klienti mund të marrë 1 pije shtesë.\nPromocioni vazhdon për sa kohë që klienti ka mjaft kapakë për shkëmbim.\n\nFunksioni merr një argument të vetëm integer, n, i cili përfaqëson numrin fillestar\ntë pijeve të blera. Ai kthen një integer që përfaqëson numrin total të pijeve\nqë klienti mund të shijojë, duke përfshirë ato të marra përmes promocionit.\n\nShembuj:\n>>> total_drinks_with_promo(100)\n149\n>>> total_drinks_with_promo(3)\n4",
      "hy": "Գրեք ruby ֆունկցիա `def total_drinks_with_promo(n)` հետևյալ խնդիրը լուծելու համար:\nՀաշվում է խմիչքների ընդհանուր քանակը, որը հաճախորդը կարող է վայելել գովազդային առաջարկի շրջանակներում:\nԱյս առաջարկի համաձայն, յուրաքանչյուր 3 շշի կափարիչի դիմաց հաճախորդը կարող է ստանալ 1 լրացուցիչ խմիչք:\nԳովազդը շարունակվում է այնքան ժամանակ, քանի դեռ հաճախորդը ունի բավարար կափարիչներ փոխանակման համար:\n\nՖունկցիան ընդունում է մեկ ամբողջ թիվ արգումենտ, n, որը ներկայացնում է գնված խմիչքների սկզբնական քանակը: Այն վերադարձնում է ամբողջ թիվ, որը ներկայացնում է խմիչքների ընդհանուր քանակը, որը հաճախորդը կարող է վայելել, ներառյալ գովազդի միջոցով ստացվածները:\n\nՕրինակներ:\n>>> total_drinks_with_promo(100)\n149\n>>> total_drinks_with_promo(3)\n4",
      "bn": "একটি রুবি ফাংশন `def total_drinks_with_promo(n)` লিখুন নিম্নলিখিত সমস্যার সমাধানের জন্য:\nএকটি প্রচারমূলক অফারের অধীনে একজন গ্রাহক মোট কতগুলি পানীয় উপভোগ করতে পারেন তা গণনা করে।\nএই অফারের অধীনে, প্রতি ৩টি বোতলের ঢাকনার জন্য, গ্রাহক ১টি অতিরিক্ত পানীয় পেতে পারেন।\nযতক্ষণ গ্রাহকের কাছে বিনিময়ের জন্য পর্যাপ্ত ঢাকনা থাকে ততক্ষণ প্রচার চালু থাকে।\n\nফাংশনটি একটি একক পূর্ণসংখ্যা আর্গুমেন্ট গ্রহণ করে, n, যা প্রাথমিকভাবে কেনা পানীয়ের সংখ্যা নির্দেশ করে। এটি একটি পূর্ণসংখ্যা ফেরত দেয় যা গ্রাহক মোট কতগুলি পানীয় উপভোগ করতে পারেন তা নির্দেশ করে, প্রচারের মাধ্যমে প্রাপ্ত পানীয় সহ।\n\nউদাহরণ:\n>>> total_drinks_with_promo(100)\n149\n>>> total_drinks_with_promo(3)\n4",
      "bg": "Напишете Ruby функция `def total_drinks_with_promo(n)`, за да решите следния проблем:\nИзчислява общия брой напитки, които клиентът може да се наслади по време на промоционална оферта.\nПри тази оферта, за всеки 3 капачки от бутилки, клиентът може да получи 1 допълнителна напитка.\nПромоцията продължава, докато клиентът има достатъчно капачки за размяна.\n\nФункцията приема един аргумент от тип цяло число, n, който представлява първоначалния брой\nзакупени напитки. Тя връща цяло число, представляващо общия брой напитки,\nкоито клиентът може да се наслади, включително тези, получени чрез промоцията.\n\nПримери:\n>>> total_drinks_with_promo(100)\n149\n>>> total_drinks_with_promo(3)\n4",
      "zh": "编写一个 ruby 函数 `def total_drinks_with_promo(n)` 来解决以下问题：\n计算在促销优惠下，顾客可以享用的饮料总数。\n根据此优惠，每 3 个瓶盖，顾客可以额外获得 1 瓶饮料。\n只要顾客有足够的瓶盖可以兑换，促销活动就会继续。\n\n该函数接受一个整数参数 n，表示最初购买的饮料数量。它返回一个整数，表示顾客可以享用的饮料总数，包括通过促销获得的饮料。\n\n示例：\n>>> total_drinks_with_promo(100)\n149\n>>> total_drinks_with_promo(3)\n4",
      "fr": "Écrire une fonction ruby `def total_drinks_with_promo(n)` pour résoudre le problème suivant :\nCalcule le nombre total de boissons qu'un client peut apprécier dans le cadre d'une offre promotionnelle.\nDans le cadre de cette offre, pour chaque 3 capsules de bouteilles, le client peut obtenir 1 boisson supplémentaire.\nLa promotion continue tant que le client a suffisamment de capsules pour échanger.\n\nLa fonction prend un seul argument entier, n, qui représente le nombre initial\nde boissons achetées. Elle renvoie un entier représentant le nombre total de boissons\nque le client peut apprécier, y compris celles reçues grâce à la promotion.\n\nExemples :\n>>> total_drinks_with_promo(100)\n149\n>>> total_drinks_with_promo(3)\n4",
      "de": "Schreiben Sie eine Ruby-Funktion `def total_drinks_with_promo(n)`, um das folgende Problem zu lösen:\nBerechnet die Gesamtanzahl der Getränke, die ein Kunde im Rahmen eines Sonderangebots genießen kann.\nUnter diesem Angebot kann der Kunde für jede 3 Flaschendeckel 1 zusätzliches Getränk erhalten.\nDie Aktion läuft weiter, solange der Kunde genügend Deckel zum Eintauschen hat.\n\nDie Funktion nimmt ein einzelnes ganzzahliges Argument n, das die anfängliche Anzahl der gekauften Getränke darstellt. Sie gibt eine ganze Zahl zurück, die die Gesamtanzahl der Getränke darstellt, die der Kunde genießen kann, einschließlich derer, die durch die Aktion erhalten wurden.\n\nBeispiele:\n>>> total_drinks_with_promo(100)\n149\n>>> total_drinks_with_promo(3)\n4",
      "ha": "Rubuta aikin ruby `def total_drinks_with_promo(n)` don warware matsalar mai zuwa:\nYana ƙididdige jimillar adadin abin sha da abokin ciniki zai iya morewa ƙarƙashin tayin talla.\nA ƙarƙashin wannan tayin, don kowace kwalba 3, abokin ciniki zai iya samun karin abin sha 1.\nTayin yana ci gaba muddin abokin ciniki yana da isassun kwalabe don musanya.\n\nAikin yana ɗaukar hujja guda ɗaya mai lamba, n, wanda ke wakiltar adadin farko\nna abubuwan sha da aka saya. Yana dawo da lamba mai nuni da jimillar adadin abubuwan sha\nda abokin ciniki zai iya morewa, gami da waɗanda aka samu ta hanyar tayin.\n\nMisalai:\n>>> total_drinks_with_promo(100)\n149\n>>> total_drinks_with_promo(3)\n4",
      "hi": "रूबी फ़ंक्शन `def total_drinks_with_promo(n)` लिखें ताकि निम्नलिखित समस्या का समाधान किया जा सके:\nएक प्रचारात्मक पेशकश के तहत एक ग्राहक कितने कुल पेय का आनंद ले सकता है, इसकी गणना करता है।\nइस पेशकश के तहत, हर 3 बोतल कैप्स के लिए, ग्राहक को 1 अतिरिक्त पेय मिल सकता है।\nप्रचार तब तक जारी रहता है जब तक ग्राहक के पास विनिमय के लिए पर्याप्त कैप्स होते हैं।\n\nयह फ़ंक्शन एक एकल पूर्णांक तर्क लेता है, n, जो खरीदे गए प्रारंभिक पेय की संख्या का प्रतिनिधित्व करता है। यह एक पूर्णांक लौटाता है जो ग्राहक द्वारा आनंदित किए जा सकने वाले कुल पेय की संख्या का प्रतिनिधित्व करता है, जिसमें प्रचार के माध्यम से प्राप्त पेय भी शामिल हैं।\n\nउदाहरण:\n>>> total_drinks_with_promo(100)\n149\n>>> total_drinks_with_promo(3)\n4",
      "hu": "Írj egy ruby függvényt `def total_drinks_with_promo(n)` a következő probléma megoldására:\nKiszámítja az összes ital számát, amelyet egy vásárló élvezhet egy promóciós ajánlat keretében.\nEzen ajánlat szerint minden 3 üvegkupakért a vásárló 1 további italt kaphat.\nA promóció addig folytatódik, amíg a vásárlónak elegendő kupakja van a cseréhez.\n\nA függvény egyetlen egész szám argumentumot vesz fel, n, amely a kezdetben vásárolt italok számát jelenti. Visszaad egy egész számot, amely az összes italt jelenti, amelyet a vásárló élvezhet, beleértve azokat is, amelyeket a promóció révén kapott.\n\nPéldák:\n>>> total_drinks_with_promo(100)\n149\n>>> total_drinks_with_promo(3)\n4"
    },
    "instruction_bertscore": {
      "sq": "0.9960250088147298",
      "hy": "0.9909801943972057",
      "bn": "0.9888268424364065",
      "bg": "0.9773205817238175",
      "zh": "0.9693346472543098",
      "fr": "0.9886772737594872",
      "de": "0.9768611496524838",
      "ha": "0.980260907254277",
      "hi": "0.987087436189684",
      "hu": "0.9905543308602669"
    },
    "level": "easy",
    "test": "raise 'Test failed' unless total_drinks_with_promo(100) == 149\nraise 'Test failed' unless total_drinks_with_promo(3) == 4\nraise 'Test failed' unless total_drinks_with_promo(9) == 13\nraise 'Test failed' unless total_drinks_with_promo(10) == 14\nraise 'Test failed' unless total_drinks_with_promo(1) == 1\n  \nputs 'All tests passed!'",
    "entry_point": "total_drinks_with_promo",
    "signature": "def total_drinks_with_promo(n)",
    "docstring": {
      "en": "Calculates the total number of drinks a customer can enjoy under a promotional offer.\nUnder this offer, for every 3 bottle caps, the customer can get 1 additional drink.\nThe promotion continues as long as the customer has enough caps for exchange.\n\nThe function takes a single integer argument, n, which represents the initial number\nof drinks purchased. It returns an integer representing the total number of drinks\nthe customer can enjoy, including those received through the promotion.\n\nExamples:\n>>> total_drinks_with_promo(100)\n149\n>>> total_drinks_with_promo(3)\n4",
      "sq": "Llogarit numrin total të pijeve që një klient mund të shijojë nën një ofertë promocionale.\nNën këtë ofertë, për çdo 3 tapa shishe, klienti mund të marrë 1 pije shtesë.  \nPromocioni vazhdon për sa kohë që klienti ka mjaft tapa për shkëmbim.\n\nFunksioni merr një argument të vetëm të tipit integer, n, që përfaqëson numrin fillestar  \ntë pijeve të blera. Ai kthen një integer që përfaqëson numrin total të pijeve  \nqë klienti mund të shijojë, duke përfshirë ato të marra përmes promocionit.\n\nShembuj:\n>>> total_drinks_with_promo(100)\n149\n>>> total_drinks_with_promo(3)\n4",
      "hy": "Հաշվում է խմիչքների ընդհանուր քանակը, որը հաճախորդը կարող է վայելել գովազդային առաջարկի շրջանակներում։ Այս առաջարկի համաձայն, յուրաքանչյուր 3 շշի կափարիչի դիմաց հաճախորդը կարող է ստանալ 1 լրացուցիչ խմիչք։ Գովազդը շարունակվում է այնքան ժամանակ, քանի դեռ հաճախորդը բավարար կափարիչներ ունի փոխանակման համար։\n\nՖունկցիան ընդունում է մեկ ամբողջ թիվ արգումենտ, n, որը ներկայացնում է սկզբնական գնված խմիչքների քանակը։ Այն վերադարձնում է ամբողջ թիվ, որը ներկայացնում է խմիչքների ընդհանուր քանակը, որը հաճախորդը կարող է վայելել, ներառյալ այն խմիչքները, որոնք ստացվել են գովազդի միջոցով։\n\nՕրինակներ:\n>>> total_drinks_with_promo(100)\n149\n>>> total_drinks_with_promo(3)\n4",
      "bn": "একটি প্রচারমূলক অফারের অধীনে একজন গ্রাহক মোট কতগুলি পানীয় উপভোগ করতে পারেন তা গণনা করে।\nএই প্রমোশনাল অফারের অধীনে, প্রতি ৩টি বোতলের ঢাকনার জন্য, গ্রাহক ১টি অতিরিক্ত পানীয় পেতে পারেন।  \nপ্রমোশনটি চলতে থাকে যতক্ষণ পর্যন্ত গ্রাহকের কাছে বিনিময়ের জন্য যথেষ্ট ঢাকনা থাকে।\n\nThe function takes a single integer argument, n, which represents the initial number  \nফাংশনটি একটি পূর্ণসংখ্যা আর্গুমেন্ট গ্রহণ করে, n, যা প্রাথমিকভাবে কেনা পানীয়ের সংখ্যা নির্দেশ করে।  \nof drinks purchased. It returns an integer representing the total number of drinks  \nএটি একটি পূর্ণসংখ্যা রিটার্ন করে যা গ্রাহক কতগুলি মোট পানীয় উপভোগ করতে পারবেন তা নির্দেশ করে,  \nthe customer can enjoy, including those received through the promotion.  \nপ্রমোশনের মাধ্যমে প্রাপ্ত পানীয় সহ।\n\nExamples:  \nউদাহরণসমূহ:\n>>> total_drinks_with_promo(100)  \n149  \n>>> total_drinks_with_promo(3)  \n4  ",
      "bg": "Изчислява общия брой напитки, които клиентът може да се наслади по време на промоционална оферта. При тази оферта, за всеки 3 капачки от бутилки, клиентът може да получи 1 допълнителна напитка. Промоцията продължава, докато клиентът има достатъчно капачки за размяна.\n\nФункцията приема един аргумент от тип цяло число, n, който представлява първоначалния брой закупени напитки. Връща цяло число, представляващо общия брой напитки, които клиентът може да се наслади, включително тези, получени чрез промоцията.\n\nПримери:\n>>> total_drinks_with_promo(100)\n149\n>>> total_drinks_with_promo(3)\n4",
      "zh": "计算客户在促销优惠下可以享用的饮料总数。\n在此优惠下，每3个瓶盖，客户可以获得1瓶额外的饮料。\n只要客户有足够的瓶盖进行兑换，促销活动就会继续。  \n\n该函数接受一个整数参数n，表示最初购买的饮料数量。  \n它返回一个整数，表示客户可以享用的饮料总数，包括通过促销获得的饮料。  \n\n示例：  \n>>> total_drinks_with_promo(100)  \n149  \n>>> total_drinks_with_promo(3)  \n4",
      "fr": "Calcule le nombre total de boissons qu'un client peut apprécier dans le cadre d'une offre promotionnelle.  \nDans le cadre de cette offre, pour chaque 3 capsules de bouteilles, le client peut obtenir 1 boisson supplémentaire.  \nLa promotion continue tant que le client a suffisamment de capsules pour un échange.\n\nLa fonction prend un seul argument entier, n, qui représente le nombre initial  \nde boissons achetées. Elle renvoie un entier représentant le nombre total de boissons  \nque le client peut apprécier, y compris celles reçues grâce à la promotion.\n\nExemples :\n>>> total_drinks_with_promo(100)\n149\n>>> total_drinks_with_promo(3)\n4",
      "de": "Berechnet die Gesamtanzahl der Getränke, die ein Kunde im Rahmen eines Sonderangebots genießen kann.\nUnter diesem Angebot kann der Kunde für je 3 Flaschendeckel 1 zusätzliches Getränk erhalten.\nDie Aktion läuft weiter, solange der Kunde genügend Deckel für den Umtausch hat.\n\nDie Funktion nimmt ein einzelnes ganzzahliges Argument, n, das die anfängliche Anzahl der gekauften Getränke darstellt. Sie gibt eine ganze Zahl zurück, die die Gesamtanzahl der Getränke darstellt, die der Kunde genießen kann, einschließlich der durch die Aktion erhaltenen.\n\nBeispiele:\n>>> total_drinks_with_promo(100)\n149\n>>> total_drinks_with_promo(3)\n4",
      "ha": "Yana lissafin jimillar adadin abin sha da abokin ciniki zai iya morewa karkashin tayin talla.\nKarkashin wannan tayin, don kowanne kwalba uku na murfi, abokin ciniki zai iya samun karin abin sha guda daya.  \nTallan yana ci gaba muddin abokin ciniki yana da isassun murfi don musanya.  \n\nAikin yana daukar hujja guda daya mai lamba, n, wanda ke wakiltar adadin farko  \nna abin sha da aka saya. Yana mayar da lamba mai lamba wadda ke wakiltar jimillar adadin abin sha  \nda abokin ciniki zai iya morewa, ciki har da wadanda aka samu ta hanyar talla.  \n\nMisalai:  \n>>> total_drinks_with_promo(100)  \n149  \n>>> total_drinks_with_promo(3)  \n4",
      "hi": "एक प्रचारक प्रस्ताव के तहत एक ग्राहक कितने कुल पेय का आनंद ले सकता है, इसकी गणना करता है।\nइस प्रमोशनल ऑफर के तहत, हर 3 बोतल कैप्स के लिए, ग्राहक को 1 अतिरिक्त ड्रिंक मिल सकती है।  \nप्रमोशन तब तक जारी रहता है जब तक ग्राहक के पास एक्सचेंज के लिए पर्याप्त कैप्स होते हैं।\n\nArgs:  \n    n: यह एकल पूर्णांक तर्क है, जो खरीदी गई प्रारंभिक ड्रिंक्स की संख्या को दर्शाता है।  \n\nReturns:  \n    यह एक पूर्णांक लौटाता है जो ग्राहक द्वारा आनंदित की जा सकने वाली कुल ड्रिंक्स की संख्या को दर्शाता है, जिसमें प्रमोशन के माध्यम से प्राप्त ड्रिंक्स भी शामिल हैं।  \n\nExamples:  \n>>> total_drinks_with_promo(100)  \n149  \n>>> total_drinks_with_promo(3)  \n4  ",
      "hu": "Számítja ki az összes ital számát, amit egy vásárló élvezhet egy promóciós ajánlat keretében. \nEzen ajánlat szerint minden 3 kupakért a vásárló 1 további italt kaphat. \nA promóció addig folytatódik, amíg a vásárlónak elegendő kupakja van a cseréhez.\n\nA függvény egyetlen egész szám argumentumot vesz fel, n, amely az eredetileg vásárolt italok számát jelenti. \nEgész számot ad vissza, amely az összes italt jelenti, amit a vásárló élvezhet, beleértve a promóció révén kapottakat is.\n\nPéldák:\n>>> total_drinks_with_promo(100)\n149\n>>> total_drinks_with_promo(3)\n4"
    },
    "docstring_bertscore": {
      "sq": "0.9866476685260728",
      "hy": "0.9888474999960342",
      "bn": "0.9190541471206624",
      "bg": "0.9730625422455726",
      "zh": "0.9621696521496194",
      "fr": "0.9848832348513399",
      "de": "0.9826228211151629",
      "ha": "0.992069483406801",
      "hi": "0.9468407497540139",
      "hu": "0.9737245773055618"
    }
  },
  {
    "task_id": "Ruby/12",
    "prompt": {
      "en": "# Determines the maximum length of a string that can be accepted by a simplified regular expression.\n# The function takes a single argument, regex, which is a string representing a regular expression \n# composed only of 'x', '(', ')', and '|'. The function returns the length of the longest string \n# that can be accepted by this regular expression.\n#\n# Example:\n# >>> max_regex_string_length(\"((xx|xxx)x|(x|xx))xx\")\n# 6\n# >>> max_regex_string_length(\"x(xx|x)x\")\n# 4\n\ndef max_regex_string_length(regex)",
      "sq": "# Përcakton gjatësinë maksimale të një vargu që mund të pranohet nga një shprehje e rregullt e thjeshtuar.\n# Funksioni merr një argument të vetëm, regex, i cili është një varg që përfaqëson një shprehje të rregullt\n# e përbërë vetëm nga 'x', '(', ')', dhe '|'. Funksioni kthen gjatësinë e vargut më të gjatë\n# që mund të pranohet nga kjo shprehje e rregullt.\n#\n# Shembull:\n# >>> max_regex_string_length(\"((xx|xxx)x|(x|xx))xx\")\n# 6\n# >>> max_regex_string_length(\"x(xx|x)x\")\n# 4\n\ndef max_regex_string_length(regex)",
      "hy": "# Սահմանում է տողի առավելագույն երկարությունը, որը կարող է ընդունվել պարզեցված կանոնավոր արտահայտությամբ։\n# Ֆունկցիան ընդունում է մեկ արգումենտ, regex, որը տող է, ներկայացնող կանոնավոր արտահայտություն,\n# կազմված միայն 'x', '(', ')', և '|' նշաններից։ Ֆունկցիան վերադարձնում է ամենաերկար տողի երկարությունը,\n# որը կարող է ընդունվել այս կանոնավոր արտահայտությամբ։\n#\n# Օրինակ:\n# >>> max_regex_string_length(\"((xx|xxx)x|(x|xx))xx\")\n# 6\n# >>> max_regex_string_length(\"x(xx|x)x\")\n# 4\n\ndef max_regex_string_length(regex)",
      "bn": "# একটি সরলীকৃত নিয়মিত অভিব্যক্তি দ্বারা গৃহীত হতে পারে এমন স্ট্রিংয়ের সর্বাধিক দৈর্ঘ্য নির্ধারণ করে।\n# ফাংশনটি একটি একক আর্গুমেন্ট গ্রহণ করে, regex, যা একটি স্ট্রিং যা একটি নিয়মিত অভিব্যক্তি \n# 'x', '(', ')', এবং '|' নিয়ে গঠিত। ফাংশনটি সেই দীর্ঘতম স্ট্রিংয়ের দৈর্ঘ্য ফেরত দেয় \n# যা এই নিয়মিত অভিব্যক্তি দ্বারা গৃহীত হতে পারে।\n#\n# উদাহরণ:\n# >>> max_regex_string_length(\"((xx|xxx)x|(x|xx))xx\")\n# 6\n# >>> max_regex_string_length(\"x(xx|x)x\")\n# 4\n\ndef max_regex_string_length(regex)",
      "bg": "# Определя максималната дължина на низ, който може да бъде приет от опростено регулярни изрази.\n# Функцията приема един аргумент, regex, който е низ, представляващ регулярни изрази,\n# съставени само от 'x', '(', ')', и '|'. Функцията връща дължината на най-дългия низ,\n# който може да бъде приет от този регулярни израз.\n#\n# Пример:\n# >>> max_regex_string_length(\"((xx|xxx)x|(x|xx))xx\")\n# 6\n# >>> max_regex_string_length(\"x(xx|x)x\")\n# 4\n\ndef max_regex_string_length(regex)",
      "zh": "# 确定可以被简化正则表达式接受的字符串的最大长度。\n# 该函数接受一个参数，regex，这是一个仅由 'x'、'('、')' 和 '|' 组成的字符串，表示正则表达式。\n# 函数返回可以被此正则表达式接受的最长字符串的长度。\n#\n# 示例:\n# >>> max_regex_string_length(\"((xx|xxx)x|(x|xx))xx\")\n# 6\n# >>> max_regex_string_length(\"x(xx|x)x\")\n# 4\n\ndef max_regex_string_length(regex)",
      "fr": "# Détermine la longueur maximale d'une chaîne qui peut être acceptée par une expression régulière simplifiée.\n# La fonction prend un seul argument, regex, qui est une chaîne représentant une expression régulière\n# composée uniquement de 'x', '(', ')', et '|'. La fonction renvoie la longueur de la plus longue chaîne\n# qui peut être acceptée par cette expression régulière.\n#\n# Exemple :\n# >>> max_regex_string_length(\"((xx|xxx)x|(x|xx))xx\")\n# 6\n# >>> max_regex_string_length(\"x(xx|x)x\")\n# 4\n\ndef max_regex_string_length(regex)",
      "de": "# Bestimmt die maximale Länge eines Strings, der von einem vereinfachten regulären Ausdruck akzeptiert werden kann.\n# Die Funktion nimmt ein einzelnes Argument, regex, das einen regulären Ausdruck darstellt, \n# der nur aus 'x', '(', ')', und '|' besteht. Die Funktion gibt die Länge des längsten Strings zurück, \n# der von diesem regulären Ausdruck akzeptiert werden kann.\n#\n# Beispiel:\n# >>> max_regex_string_length(\"((xx|xxx)x|(x|xx))xx\")\n# 6\n# >>> max_regex_string_length(\"x(xx|x)x\")\n# 4\n\ndef max_regex_string_length(regex)",
      "ha": "# Yana ƙayyade tsawon mafi girman kirtani da za a iya karɓa ta hanyar sauƙaƙan magana na yau da kullum.\n# Aikin yana ɗaukar hujja guda ɗaya, regex, wanda kirtani ne da ke wakiltar magana na yau da kullum\n# wanda aka haɗa shi kawai daga 'x', '(', ')', da '|'. Aikin yana dawo da tsawon mafi girman kirtani\n# da za a iya karɓa ta wannan magana na yau da kullum.\n#\n# Misali:\n# >>> max_regex_string_length(\"((xx|xxx)x|(x|xx))xx\")\n# 6\n# >>> max_regex_string_length(\"x(xx|x)x\")\n# 4\n\ndef max_regex_string_length(regex)",
      "hi": "# यह निर्धारित करता है कि एक सरल नियमित अभिव्यक्ति द्वारा स्वीकार की जा सकने वाली स्ट्रिंग की अधिकतम लंबाई क्या है।\n# फ़ंक्शन एकल तर्क, regex, लेता है, जो एक स्ट्रिंग है जो एक नियमित अभिव्यक्ति का प्रतिनिधित्व करता है\n# जो केवल 'x', '(', ')', और '|' से बना होता है। फ़ंक्शन उस सबसे लंबी स्ट्रिंग की लंबाई लौटाता है\n# जिसे यह नियमित अभिव्यक्ति स्वीकार कर सकती है।\n#\n# उदाहरण:\n# >>> max_regex_string_length(\"((xx|xxx)x|(x|xx))xx\")\n# 6\n# >>> max_regex_string_length(\"x(xx|x)x\")\n# 4\n\ndef max_regex_string_length(regex)",
      "hu": "# Meghatározza egy egyszerűsített reguláris kifejezés által elfogadható maximális hosszúságú karakterláncot.\n# A függvény egyetlen argumentumot vesz fel, a regex-et, amely egy reguláris kifejezést reprezentáló karakterlánc,\n# amely csak 'x', '(', ')', és '|' karakterekből áll. A függvény visszaadja a leghosszabb karakterlánc hosszát,\n# amelyet ez a reguláris kifejezés elfogadhat.\n#\n# Példa:\n# >>> max_regex_string_length(\"((xx|xxx)x|(x|xx))xx\")\n# 6\n# >>> max_regex_string_length(\"x(xx|x)x\")\n# 4\n\ndef max_regex_string_length(regex)"
    },
    "prompt_bertscore": {
      "sq": "1",
      "hy": "0.9826621499306077",
      "bn": "0.9919850654948612",
      "bg": "0.9847640566227189",
      "zh": "0.9664282875190073",
      "fr": "1",
      "de": "0.9857768729356158",
      "ha": "0.9892318497833367",
      "hi": "0.9783036034795591",
      "hu": "0.974305372539708"
    },
    "canonical_solution": "    @regex = regex\n    @index = 0\n    dfs\n  end\n  \n  def dfs\n    temp = 0\n    max = 0\n    while @index < @regex.length\n      case @regex[@index]\n      when '('\n        @index += 1\n        temp += dfs\n      when ')'\n        @index += 1\n        break\n      when '|'\n        @index += 1\n        max = temp if temp > max\n        temp = 0\n      else # assuming 'x'\n        @index += 1\n        temp += 1\n      end\n    end\n    max = temp if temp > max\n    max\n  end",
    "instruction": {
      "en": "Write a ruby function `def max_regex_string_length(regex)` to solve the following problem:\nDetermines the maximum length of a string that can be accepted by a simplified regular expression.\nThe function takes a single argument, regex, which is a string representing a regular expression\ncomposed only of 'x', '(', ')', and '|'. The function returns the length of the longest string\nthat can be accepted by this regular expression.\n\nExample:\n>>> max_regex_string_length(\"((xx|xxx)x|(x|xx))xx\")\n6\n>>> max_regex_string_length(\"x(xx|x)x\")\n4",
      "sq": "Shkruani një funksion ruby `def max_regex_string_length(regex)` për të zgjidhur problemin e mëposhtëm:\nPërcakton gjatësinë maksimale të një vargu që mund të pranohet nga një shprehje e rregullt e thjeshtuar.\nFunksioni merr një argument të vetëm, regex, i cili është një varg që përfaqëson një shprehje të rregullt\ne përbërë vetëm nga 'x', '(', ')', dhe '|'. Funksioni kthen gjatësinë e vargut më të gjatë\nqë mund të pranohet nga kjo shprehje e rregullt.\n\nShembull:\n>>> max_regex_string_length(\"((xx|xxx)x|(x|xx))xx\")\n6\n>>> max_regex_string_length(\"x(xx|x)x\")\n4",
      "hy": "Գրեք ruby ֆունկցիա `def max_regex_string_length(regex)` հետևյալ խնդիրը լուծելու համար:\nՍահմանում է տողի առավելագույն երկարությունը, որը կարող է ընդունվել պարզեցված կանոնավոր արտահայտությամբ:\nՖունկցիան ընդունում է մեկ արգումենտ՝ regex, որը տող է, ներկայացնող կանոնավոր արտահայտություն,\nորն բաղկացած է միայն 'x', '(', ')', և '|' սիմվոլներից: Ֆունկցիան վերադարձնում է ամենաերկար տողի երկարությունը,\nորը կարող է ընդունվել այս կանոնավոր արտահայտությամբ:\n\nՕրինակ:\n>>> max_regex_string_length(\"((xx|xxx)x|(x|xx))xx\")\n6\n>>> max_regex_string_length(\"x(xx|x)x\")\n4",
      "bn": "রুবি ফাংশন `def max_regex_string_length(regex)` লিখুন নিম্নলিখিত সমস্যার সমাধানের জন্য:\nএকটি সরলীকৃত নিয়মিত অভিব্যক্তি দ্বারা গৃহীত হতে পারে এমন স্ট্রিংয়ের সর্বাধিক দৈর্ঘ্য নির্ধারণ করে।\nফাংশনটি একটি একক আর্গুমেন্ট গ্রহণ করে, regex, যা একটি স্ট্রিং যা একটি নিয়মিত অভিব্যক্তি উপস্থাপন করে\nশুধুমাত্র 'x', '(', ')', এবং '|' নিয়ে গঠিত। ফাংশনটি সেই সর্বাধিক দৈর্ঘ্যের স্ট্রিংয়ের দৈর্ঘ্য ফেরত দেয়\nযা এই নিয়মিত অভিব্যক্তি দ্বারা গৃহীত হতে পারে।\n\nউদাহরণ:\n>>> max_regex_string_length(\"((xx|xxx)x|(x|xx))xx\")\n6\n>>> max_regex_string_length(\"x(xx|x)x\")\n4",
      "bg": "Напишете Ruby функция `def max_regex_string_length(regex)`, за да решите следния проблем:\nОпределя максималната дължина на низ, който може да бъде приет от опростен регулярен израз.\nФункцията приема един аргумент, regex, който е низ, представляващ регулярен израз,\nсъставен само от 'x', '(', ')', и '|'. Функцията връща дължината на най-дългия низ,\nкойто може да бъде приет от този регулярен израз.\n\nПример:\n>>> max_regex_string_length(\"((xx|xxx)x|(x|xx))xx\")\n6\n>>> max_regex_string_length(\"x(xx|x)x\")\n4",
      "zh": "编写一个 ruby 函数 `def max_regex_string_length(regex)` 来解决以下问题：\n确定可以被简化正则表达式接受的字符串的最大长度。\n该函数接受一个参数，regex，这是一个仅由 'x'、'('、')' 和 '|' 组成的字符串，表示一个正则表达式。\n该函数返回可以被此正则表达式接受的最长字符串的长度。\n\n示例：\n>>> max_regex_string_length(\"((xx|xxx)x|(x|xx))xx\")\n6\n>>> max_regex_string_length(\"x(xx|x)x\")\n4",
      "fr": "Écrire une fonction ruby `def max_regex_string_length(regex)` pour résoudre le problème suivant :\nDétermine la longueur maximale d'une chaîne qui peut être acceptée par une expression régulière simplifiée.\nLa fonction prend un seul argument, regex, qui est une chaîne représentant une expression régulière\ncomposée uniquement de 'x', '(', ')', et '|'. La fonction retourne la longueur de la chaîne la plus longue\nqui peut être acceptée par cette expression régulière.\n\nExemple :\n>>> max_regex_string_length(\"((xx|xxx)x|(x|xx))xx\")\n6\n>>> max_regex_string_length(\"x(xx|x)x\")\n4",
      "de": "Schreiben Sie eine Ruby-Funktion `def max_regex_string_length(regex)`, um das folgende Problem zu lösen:\nBestimmt die maximale Länge eines Strings, der von einem vereinfachten regulären Ausdruck akzeptiert werden kann.\nDie Funktion nimmt ein einziges Argument, regex, das einen regulären Ausdruck darstellt, der nur aus 'x', '(', ')', und '|' besteht. Die Funktion gibt die Länge des längsten Strings zurück, der von diesem regulären Ausdruck akzeptiert werden kann.\n\nBeispiel:\n>>> max_regex_string_length(\"((xx|xxx)x|(x|xx))xx\")\n6\n>>> max_regex_string_length(\"x(xx|x)x\")\n4",
      "ha": "Rubuta aikin ruby `def max_regex_string_length(regex)` don warware matsalar mai zuwa:\nYana tantance tsawon mafi tsawo na wani kirtani da za a iya karɓa ta hanyar sauƙaƙan alamar yau da kullum.\nAikin yana ɗaukar hujja guda ɗaya, regex, wanda kirtani ne da ke wakiltar alamar yau da kullum\nwanda aka haɗa kawai da 'x', '(', ')', da '|'. Aikin yana dawo da tsawon mafi tsawo na kirtani\nda za a iya karɓa ta wannan alamar yau da kullum.\n\nMisali:\n>>> max_regex_string_length(\"((xx|xxx)x|(x|xx))xx\")\n6\n>>> max_regex_string_length(\"x(xx|x)x\")\n4",
      "hi": "`def max_regex_string_length(regex)` नामक एक रूबी फ़ंक्शन लिखें ताकि निम्नलिखित समस्या का समाधान किया जा सके:\nयह निर्धारित करता है कि एक सरलीकृत नियमित अभिव्यक्ति द्वारा स्वीकार की जा सकने वाली स्ट्रिंग की अधिकतम लंबाई क्या है।\nयह फ़ंक्शन एक एकल तर्क लेता है, regex, जो एक स्ट्रिंग है जो एक नियमित अभिव्यक्ति का प्रतिनिधित्व करता है\nजो केवल 'x', '(', ')', और '|' से बना होता है। यह फ़ंक्शन उस सबसे लंबी स्ट्रिंग की लंबाई लौटाता है\nजो इस नियमित अभिव्यक्ति द्वारा स्वीकार की जा सकती है।\n\nउदाहरण:\n>>> max_regex_string_length(\"((xx|xxx)x|(x|xx))xx\")\n6\n>>> max_regex_string_length(\"x(xx|x)x\")\n4",
      "hu": "Készíts egy ruby függvényt `def max_regex_string_length(regex)` a következő probléma megoldására:\nMeghatározza a maximális hosszát annak a karakterláncnak, amelyet egy egyszerűsített reguláris kifejezés elfogadhat.\nA függvény egyetlen argumentumot vesz fel, a regex-et, amely egy reguláris kifejezést reprezentáló karakterlánc,\namely csak 'x', '(', ')', és '|' karaktereket tartalmaz. A függvény visszaadja a leghosszabb karakterlánc hosszát,\namelyet ez a reguláris kifejezés elfogadhat.\n\nPélda:\n>>> max_regex_string_length(\"((xx|xxx)x|(x|xx))xx\")\n6\n>>> max_regex_string_length(\"x(xx|x)x\")\n4"
    },
    "instruction_bertscore": {
      "sq": "0.9915806540390742",
      "hy": "0.9739448583981296",
      "bn": "0.9973562296284256",
      "bg": "0.9917441268426659",
      "zh": "0.9737128581130808",
      "fr": "0.9915806540390742",
      "de": "0.9848135155875966",
      "ha": "0.9794348034995528",
      "hi": "0.9886210613616544",
      "hu": "0.971351142882576"
    },
    "level": "hard",
    "test": "raise 'Test failed' unless max_regex_string_length(\"((xx|xxx)x|(x|xx))xx\") == 6\nraise 'Test failed' unless max_regex_string_length(\"x(xx|x)x\") == 4\nraise 'Test failed' unless max_regex_string_length(\"xx|x\") == 2\nraise 'Test failed' unless max_regex_string_length(\"(xx|x)(x|xx)\") == 4\nraise 'Test failed' unless max_regex_string_length(\"x\") == 1\n  \n\nputs 'All tests passed!'",
    "entry_point": "max_regex_string_length",
    "signature": "def max_regex_string_length(regex)",
    "docstring": {
      "en": "Determines the maximum length of a string that can be accepted by a simplified regular expression.\nThe function takes a single argument, regex, which is a string representing a regular expression\ncomposed only of 'x', '(', ')', and '|'. The function returns the length of the longest string\nthat can be accepted by this regular expression.\n\nExample:\n>>> max_regex_string_length(\"((xx|xxx)x|(x|xx))xx\")\n6\n>>> max_regex_string_length(\"x(xx|x)x\")\n4",
      "sq": "Përcakton gjatësinë maksimale të një vargu që mund të pranohet nga një shprehje e rregullt e thjeshtuar. Funksioni merr një argument të vetëm, regex, i cili është një varg që përfaqëson një shprehje të rregullt të përbërë vetëm nga 'x', '(', ')', dhe '|'. Funksioni kthen gjatësinë e vargut më të gjatë që mund të pranohet nga kjo shprehje e rregullt.\n\nShembull:\n>>> max_regex_string_length(\"((xx|xxx)x|(x|xx))xx\")\n6\n>>> max_regex_string_length(\"x(xx|x)x\")\n4",
      "hy": "Սահմանում է տողի առավելագույն երկարությունը, որը կարող է ընդունվել պարզեցված կանոնավոր արտահայտությամբ։ Ֆունկցիան ընդունում է մեկ արգումենտ՝ regex, որը տող է, ներկայացնող կանոնավոր արտահայտություն, կազմված միայն 'x', '(', ')', և '|' սիմվոլներից։ Ֆունկցիան վերադարձնում է ամենաերկար տողի երկարությունը, որը կարող է ընդունվել այս կանոնավոր արտահայտությամբ։\n\nՕրինակ:\n>>> max_regex_string_length(\"((xx|xxx)x|(x|xx))xx\")\n6\n>>> max_regex_string_length(\"x(xx|x)x\")\n4",
      "bn": "একটি সরলীকৃত নিয়মিত অভিব্যক্তি দ্বারা গৃহীত হতে পারে এমন একটি স্ট্রিংয়ের সর্বাধিক দৈর্ঘ্য নির্ধারণ করে। ফাংশনটি একটি একক আর্গুমেন্ট গ্রহণ করে, regex, যা একটি স্ট্রিং যা একটি নিয়মিত অভিব্যক্তি উপস্থাপন করে যা শুধুমাত্র 'x', '(', ')', এবং '|' নিয়ে গঠিত। ফাংশনটি সেই নিয়মিত অভিব্যক্তি দ্বারা গৃহীত হতে পারে এমন দীর্ঘতম স্ট্রিংয়ের দৈর্ঘ্য ফেরত দেয়।\n\nউদাহরণ:\n>>> max_regex_string_length(\"((xx|xxx)x|(x|xx))xx\")\n6\n>>> max_regex_string_length(\"x(xx|x)x\")\n4",
      "bg": "Определя максималната дължина на низ, който може да бъде приет от опростен регулярен израз. Функцията приема един аргумент, regex, който е низ, представляващ регулярен израз, съставен само от 'x', '(', ')', и '|'. Функцията връща дължината на най-дългия низ, който може да бъде приет от този регулярен израз.\n\nПример:\n>>> max_regex_string_length(\"((xx|xxx)x|(x|xx))xx\")\n6\n>>> max_regex_string_length(\"x(xx|x)x\")\n4",
      "zh": "确定可以被简化正则表达式接受的字符串的最大长度。  \n该函数接受一个参数，regex，这是一个字符串，表示仅由 'x'、'('、')' 和 '|' 组成的正则表达式。  \n该函数返回可以被此正则表达式接受的最长字符串的长度。\n\n示例：\n>>> max_regex_string_length(\"((xx|xxx)x|(x|xx))xx\")\n6\n>>> max_regex_string_length(\"x(xx|x)x\")\n4",
      "fr": "Détermine la longueur maximale d'une chaîne qui peut être acceptée par une expression régulière simplifiée. La fonction prend un seul argument, regex, qui est une chaîne représentant une expression régulière composée uniquement de 'x', '(', ')', et '|'. La fonction renvoie la longueur de la chaîne la plus longue qui peut être acceptée par cette expression régulière.\n\nExemple :\n>>> max_regex_string_length(\"((xx|xxx)x|(x|xx))xx\")\n6\n>>> max_regex_string_length(\"x(xx|x)x\")\n4",
      "de": "Bestimmt die maximale Länge eines Strings, der von einem vereinfachten regulären Ausdruck akzeptiert werden kann. Die Funktion nimmt ein einziges Argument, regex, das einen regulären Ausdruck darstellt, der nur aus 'x', '(', ')', und '|' besteht. Die Funktion gibt die Länge des längsten Strings zurück, der von diesem regulären Ausdruck akzeptiert werden kann.\n\nBeispiel:\n>>> max_regex_string_length(\"((xx|xxx)x|(x|xx))xx\")\n6\n>>> max_regex_string_length(\"x(xx|x)x\")\n4",
      "ha": "Yana ƙayyade tsawon mafi girman kirtani da za a iya karɓa ta hanyar sauƙaƙan magana ta yau da kullun.\nAiki yana ɗaukar hujja guda ɗaya, regex, wanda kirtani ne da ke wakiltar magana ta yau da kullun\nwanda aka haɗa shi kawai da 'x', '(', ')', da '|'. Aiki yana mayar da tsawon mafi tsayin kirtani\nda za a iya karɓa ta wannan magana ta yau da kullun.\n\nMisali:\n>>> max_regex_string_length(\"((xx|xxx)x|(x|xx))xx\")\n6\n>>> max_regex_string_length(\"x(xx|x)x\")\n4",
      "hi": "नियत करता है कि एक सरल नियमित अभिव्यक्ति द्वारा स्वीकार की जा सकने वाली स्ट्रिंग की अधिकतम लंबाई क्या हो सकती है। यह फ़ंक्शन एक एकल तर्क लेता है, regex, जो एक स्ट्रिंग है जो एक नियमित अभिव्यक्ति का प्रतिनिधित्व करता है, जो केवल 'x', '(', ')', और '|' से बनी होती है। यह फ़ंक्शन उस सबसे लंबी स्ट्रिंग की लंबाई लौटाता है जिसे यह नियमित अभिव्यक्ति स्वीकार कर सकती है।\n\nउदाहरण:\n>>> max_regex_string_length(\"((xx|xxx)x|(x|xx))xx\")\n6\n>>> max_regex_string_length(\"x(xx|x)x\")\n4",
      "hu": "Meghatározza a sztring maximális hosszát, amelyet egy egyszerűsített reguláris kifejezés elfogadhat.\nA függvény egyetlen argumentumot, a regex-et veszi át, amely egy reguláris kifejezést reprezentáló sztring, amely csak 'x', '(', ')', és '|' karakterekből áll. A függvény visszaadja a leghosszabb sztring hosszát, amelyet ez a reguláris kifejezés elfogadhat.\n\nPélda:\n>>> max_regex_string_length(\"((xx|xxx)x|(x|xx))xx\")\n6\n>>> max_regex_string_length(\"x(xx|x)x\")\n4"
    },
    "docstring_bertscore": {
      "sq": "0.999999801369619",
      "hy": "0.982584485451623",
      "bn": "0.9859190922884368",
      "bg": "0.9943148012340194",
      "zh": "0.9809304902687456",
      "fr": "0.9909937012631161",
      "de": "0.9843155492223421",
      "ha": "0.9840968571728227",
      "hi": "0.9686892971463275",
      "hu": "0.9687393520023483"
    }
  },
  {
    "task_id": "Ruby/13",
    "prompt": {
      "en": "# Finds the maximum sum of any three numbers from a given array that is divisible by a specified number k.\n# This function takes an array of numbers and an integer k as arguments. It returns the maximum sum \n# of any three numbers from the array such that this sum is divisible by k. It's guaranteed that there \n# are at least three numbers in the array and that a solution exists.\n#\n# Example:\n# >>> max_sum_divisible_by_k([1, 2, 3, 4], 3)\n# 9\n# >>> max_sum_divisible_by_k([4, 5, 10, 20], 5)\n# 35\n\ndef max_sum_divisible_by_k(numbers, k)",
      "sq": "# Gjen shumën maksimale të çdo treshe numrash nga një varg i dhënë që është i pjesëtueshëm me një numër të specifikuar k.\n# Kjo funksion merr një varg numrash dhe një numër të plotë k si argumente. Ajo kthen shumën maksimale\n# të çdo treshe numrash nga vargu në mënyrë që kjo shumë të jetë e pjesëtueshme me k. Është e garantuar që ka\n# të paktën tre numra në varg dhe që ekziston një zgjidhje.\n#\n# Shembull:\n# >>> max_sum_divisible_by_k([1, 2, 3, 4], 3)\n# 9\n# >>> max_sum_divisible_by_k([4, 5, 10, 20], 5)\n# 35\n\ndef max_sum_divisible_by_k(numbers, k)",
      "hy": "# Գտնում է տրված զանգվածից ցանկացած երեք թվերի առավելագույն գումարը, որը բաժանվում է նշված k թվով:\n# Այս ֆունկցիան ընդունում է թվերի զանգված և ամբողջ թիվ k որպես արգումենտներ: Այն վերադարձնում է \n# զանգվածից ցանկացած երեք թվերի առավելագույն գումարը այնպես, որ այս գումարը բաժանվի k թվով: \n# Երաշխավորված է, որ զանգվածում առնվազն երեք թիվ կա և որ լուծում գոյություն ունի:\n#\n# Օրինակ:\n# >>> max_sum_divisible_by_k([1, 2, 3, 4], 3)\n# 9\n# >>> max_sum_divisible_by_k([4, 5, 10, 20], 5)\n# 35\n\ndef max_sum_divisible_by_k(numbers, k)",
      "bn": "# একটি প্রদত্ত অ্যারের যেকোনো তিনটি সংখ্যার সর্বাধিক যোগফল খুঁজে বের করে যা একটি নির্দিষ্ট সংখ্যা k দ্বারা বিভাজ্য।\n# এই ফাংশনটি একটি সংখ্যার অ্যারে এবং একটি পূর্ণসংখ্যা k কে আর্গুমেন্ট হিসেবে গ্রহণ করে। এটি অ্যারের যেকোনো তিনটি সংখ্যার \n# সর্বাধিক যোগফল প্রদান করে যাতে এই যোগফলটি k দ্বারা বিভাজ্য হয়। এটি গ্যারান্টি দেওয়া হয় যে অ্যারেতে অন্তত তিনটি সংখ্যা \n# রয়েছে এবং একটি সমাধান বিদ্যমান।\n#\n# উদাহরণ:\n# >>> max_sum_divisible_by_k([1, 2, 3, 4], 3)\n# 9\n# >>> max_sum_divisible_by_k([4, 5, 10, 20], 5)\n# 35\n\ndef max_sum_divisible_by_k(numbers, k)",
      "bg": "# Намира максималната сума на произволни три числа от даден масив, която е делима на определено число k.\n# Тази функция приема масив от числа и цяло число k като аргументи. Тя връща максималната сума \n# на произволни три числа от масива, така че тази сума да е делима на k. Гарантирано е, че в масива \n# има поне три числа и че съществува решение.\n#\n# Пример:\n# >>> max_sum_divisible_by_k([1, 2, 3, 4], 3)\n# 9\n# >>> max_sum_divisible_by_k([4, 5, 10, 20], 5)\n# 35\n\ndef max_sum_divisible_by_k(numbers, k)",
      "zh": "# 查找给定数组中任意三个数字的最大和，该和可被指定的数字k整除。\n# 此函数接受一个数字数组和一个整数k作为参数。它返回数组中任意三个数字的最大和，\n# 使得该和可被k整除。保证数组中至少有三个数字，并且存在一个解。\n#\n# 示例:\n# >>> max_sum_divisible_by_k([1, 2, 3, 4], 3)\n# 9\n# >>> max_sum_divisible_by_k([4, 5, 10, 20], 5)\n# 35\n\ndef max_sum_divisible_by_k(numbers, k)",
      "fr": "# Trouve la somme maximale de n'importe quels trois nombres d'un tableau donné qui est divisible par un nombre spécifié k.\n# Cette fonction prend un tableau de nombres et un entier k comme arguments. Elle renvoie la somme maximale \n# de n'importe quels trois nombres du tableau telle que cette somme soit divisible par k. Il est garanti qu'il y a \n# au moins trois nombres dans le tableau et qu'une solution existe.\n#\n# Exemple :\n# >>> max_sum_divisible_by_k([1, 2, 3, 4], 3)\n# 9\n# >>> max_sum_divisible_by_k([4, 5, 10, 20], 5)\n# 35\n\ndef max_sum_divisible_by_k(numbers, k)",
      "de": "# Findet die maximale Summe von beliebigen drei Zahlen aus einem gegebenen Array, die durch eine angegebene Zahl k teilbar ist.\n# Diese Funktion nimmt ein Array von Zahlen und eine ganze Zahl k als Argumente. Sie gibt die maximale Summe \n# von beliebigen drei Zahlen aus dem Array zurück, sodass diese Summe durch k teilbar ist. Es ist garantiert, dass es \n# mindestens drei Zahlen im Array gibt und dass eine Lösung existiert.\n#\n# Beispiel:\n# >>> max_sum_divisible_by_k([1, 2, 3, 4], 3)\n# 9\n# >>> max_sum_divisible_by_k([4, 5, 10, 20], 5)\n# 35\n\ndef max_sum_divisible_by_k(numbers, k)",
      "ha": "# Nemi mafi girman jimillar kowanne lambobi uku daga cikin jerin lambobi da aka bayar wanda za a iya raba shi da wani lamba k da aka ayyana.\n# Wannan aikin yana karɓar jerin lambobi da kuma lamba k a matsayin hujjoji. Yana dawo da mafi girman jimillar \n# kowanne lambobi uku daga cikin jerin lambobi wanda wannan jimillar za a iya raba shi da k. An tabbatar da cewa akwai \n# aƙalla lambobi uku a cikin jerin kuma akwai mafita.\n#\n# Misali:\n# >>> max_sum_divisible_by_k([1, 2, 3, 4], 3)\n# 9\n# >>> max_sum_divisible_by_k([4, 5, 10, 20], 5)\n# 35\n\ndef max_sum_divisible_by_k(numbers, k)",
      "hi": "# दिए गए array से तीन संख्याओं का अधिकतम योग खोजें जो किसी निर्दिष्ट संख्या k से विभाज्य हो।\n# यह फ़ंक्शन एक array और एक पूर्णांक k को तर्क के रूप में लेता है। यह array से किसी भी तीन संख्याओं का अधिकतम \n# योग लौटाता है ताकि यह योग k से विभाज्य हो। यह सुनिश्चित है कि array में कम से कम तीन संख्याएँ हैं और \n# एक समाधान मौजूद है।\n#\n# उदाहरण:\n# >>> max_sum_divisible_by_k([1, 2, 3, 4], 3)\n# 9\n# >>> max_sum_divisible_by_k([4, 5, 10, 20], 5)\n# 35\n\ndef max_sum_divisible_by_k(numbers, k)",
      "hu": "# Megkeresi bármely három szám maximális összegét egy adott tömbből, amely osztható egy megadott k számmal.\n# Ez a függvény egy számokból álló tömböt és egy egész számot, k-t vesz argumentumként. Visszaadja bármely három \n# szám maximális összegét a tömbből úgy, hogy ez az összeg osztható legyen k-val. Garantált, hogy a tömbben \n# legalább három szám van, és hogy létezik megoldás.\n#\n# Példa:\n# >>> max_sum_divisible_by_k([1, 2, 3, 4], 3)\n# 9\n# >>> max_sum_divisible_by_k([4, 5, 10, 20], 5)\n# 35\n\ndef max_sum_divisible_by_k(numbers, k)"
    },
    "prompt_bertscore": {
      "sq": "0.9728331241554773",
      "hy": "0.9821834507123136",
      "bn": "0.97395836526404",
      "bg": "0.989615007788353",
      "zh": "0.9628992215391605",
      "fr": "0.9931371217048636",
      "de": "0.9961126048127662",
      "ha": "0.9309936206942885",
      "hi": "0.9705216624113743",
      "hu": "0.9930749503955997"
    },
    "canonical_solution": "    numbers.sort!.reverse!\n    max_sum = 0\n  \n    (0..numbers.length - 3).each do |i|\n      (i+1..numbers.length - 2).each do |j|\n        (j+1..numbers.length - 1).each do |l|\n          sum = numbers[i] + numbers[j] + numbers[l]\n          if sum % k == 0 && sum > max_sum\n            max_sum = sum\n          end\n        end\n      end\n    end\n    # puts max_sum\n    max_sum\n  end",
    "instruction": {
      "en": "Write a ruby function `def max_sum_divisible_by_k(numbers, k)` to solve the following problem:\nFinds the maximum sum of any three numbers from a given array that is divisible by a specified number k.\nThis function takes an array of numbers and an integer k as arguments. It returns the maximum sum\nof any three numbers from the array such that this sum is divisible by k. It's guaranteed that there\nare at least three numbers in the array and that a solution exists.\n\nExample:\n>>> max_sum_divisible_by_k([1, 2, 3, 4], 3)\n9\n>>> max_sum_divisible_by_k([4, 5, 10, 20], 5)\n35",
      "sq": "Shkruani një funksion ruby `def max_sum_divisible_by_k(numbers, k)` për të zgjidhur problemin e mëposhtëm:\nGjen shumën maksimale të çdo tre numrave nga një varg i dhënë që është i pjestueshëm me një numër të specifikuar k.\nKy funksion merr një varg numrash dhe një numër të plotë k si argumente. Ai kthen shumën maksimale\ntë çdo tre numrave nga vargu në mënyrë që kjo shumë të jetë e pjestueshme me k. Është e garantuar që ka\ntë paktën tre numra në varg dhe që ekziston një zgjidhje.\n\nShembull:\n>>> max_sum_divisible_by_k([1, 2, 3, 4], 3)\n9\n>>> max_sum_divisible_by_k([4, 5, 10, 20], 5)\n35",
      "hy": "Գրեք ruby ֆունկցիա `def max_sum_divisible_by_k(numbers, k)` հետևյալ խնդիրը լուծելու համար:\nԳտնում է տրված զանգվածից ցանկացած երեք թվերի առավելագույն գումարը, որը բաժանվում է նշված k թվով:\nԱյս ֆունկցիան ընդունում է թվերի զանգված և ամբողջ թիվ k որպես արգումենտներ։ Այն վերադարձնում է\nցանկացած երեք թվերի առավելագույն գումարը զանգվածից, այնպես որ այս գումարը բաժանվի k թվով։ Երաշխավորված է, որ\nզանգվածում առկա են առնվազն երեք թիվ և որ լուծում գոյություն ունի։\n\nՕրինակ:\n>>> max_sum_divisible_by_k([1, 2, 3, 4], 3)\n9\n>>> max_sum_divisible_by_k([4, 5, 10, 20], 5)\n35",
      "bn": "রুবি ফাংশন `def max_sum_divisible_by_k(numbers, k)` লিখুন নিম্নলিখিত সমস্যার সমাধানের জন্য:\nএকটি নির্দিষ্ট সংখ্যা k দ্বারা বিভাজ্য একটি প্রদত্ত অ্যারের যেকোন তিনটি সংখ্যার সর্বাধিক যোগফল খুঁজে বের করুন। \nএই ফাংশনটি একটি সংখ্যার অ্যারে এবং একটি পূর্ণসংখ্যা k কে আর্গুমেন্ট হিসেবে গ্রহণ করে। এটি অ্যারের যেকোন তিনটি সংখ্যার সর্বাধিক যোগফল প্রদান করে যাতে এই যোগফলটি k দ্বারা বিভাজ্য হয়। এটি নিশ্চিত যে অ্যারেতে অন্তত তিনটি সংখ্যা রয়েছে এবং একটি সমাধান বিদ্যমান।\n\nউদাহরণ:\n>>> max_sum_divisible_by_k([1, 2, 3, 4], 3)\n9\n>>> max_sum_divisible_by_k([4, 5, 10, 20], 5)\n35",
      "bg": "Напишете Ruby функция `def max_sum_divisible_by_k(numbers, k)` за решаване на следния проблем:\nНамира максималната сума на всякакви три числа от даден масив, която е делима на определено число k.\nТази функция приема масив от числа и цяло число k като аргументи. Тя връща максималната сума\nна всякакви три числа от масива, така че тази сума да е делима на k. Гарантирано е, че в масива има\nпоне три числа и че съществува решение.\n\nПример:\n>>> max_sum_divisible_by_k([1, 2, 3, 4], 3)\n9\n>>> max_sum_divisible_by_k([4, 5, 10, 20], 5)\n35",
      "zh": "编写一个 ruby 函数 `def max_sum_divisible_by_k(numbers, k)` 来解决以下问题：\n查找给定数组中任意三个数字的最大和，使其能被指定的数字 k 整除。\n此函数接受一个数字数组和一个整数 k 作为参数。它返回数组中任意三个数字的最大和，使得该和能被 k 整除。保证数组中至少有三个数字，并且存在一个解。\n\n示例：\n>>> max_sum_divisible_by_k([1, 2, 3, 4], 3)\n9\n>>> max_sum_divisible_by_k([4, 5, 10, 20], 5)\n35",
      "fr": "Écrire une fonction ruby `def max_sum_divisible_by_k(numbers, k)` pour résoudre le problème suivant :\nTrouver la somme maximale de trois nombres quelconques d'un tableau donné qui est divisible par un nombre spécifié k.\nCette fonction prend un tableau de nombres et un entier k comme arguments. Elle retourne la somme maximale\nde trois nombres quelconques du tableau telle que cette somme soit divisible par k. Il est garanti qu'il y a\nau moins trois nombres dans le tableau et qu'une solution existe.\n\nExemple :\n>>> max_sum_divisible_by_k([1, 2, 3, 4], 3)\n9\n>>> max_sum_divisible_by_k([4, 5, 10, 20], 5)\n35",
      "de": "Schreiben Sie eine Ruby-Funktion `def max_sum_divisible_by_k(numbers, k)`, um das folgende Problem zu lösen:\nFindet die maximale Summe von beliebigen drei Zahlen aus einem gegebenen Array, die durch eine angegebene Zahl k teilbar ist.\nDiese Funktion nimmt ein Array von Zahlen und eine ganze Zahl k als Argumente. Sie gibt die maximale Summe\nvon beliebigen drei Zahlen aus dem Array zurück, so dass diese Summe durch k teilbar ist. Es ist garantiert, dass es\nmindestens drei Zahlen im Array gibt und dass eine Lösung existiert.\n\nBeispiel:\n>>> max_sum_divisible_by_k([1, 2, 3, 4], 3)\n9\n>>> max_sum_divisible_by_k([4, 5, 10, 20], 5)\n35",
      "ha": "Rubuta aikin ruby `def max_sum_divisible_by_k(numbers, k)` don warware matsalar mai zuwa:\nNemi mafi girman jimillar kowace uku daga cikin lambobi daga wani jeri da za a iya rabawa da wata lamba k da aka fayyace.\nWannan aikin yana karɓar jeri na lambobi da kuma cikakken lamba k a matsayin hujjoji. Yana mayar da mafi girman jimillar\nkowace uku daga cikin lambobi daga jerin da za a iya rabawa da k. Ana tabbatar da cewa akwai aƙalla lambobi uku a cikin jerin kuma cewa akwai mafita.\n\nMisali:\n>>> max_sum_divisible_by_k([1, 2, 3, 4], 3)\n9\n>>> max_sum_divisible_by_k([4, 5, 10, 20], 5)\n35",
      "hi": "रूबी फ़ंक्शन `def max_sum_divisible_by_k(numbers, k)` लिखें ताकि निम्नलिखित समस्या का समाधान किया जा सके:\nकिसी दिए गए array से तीन संख्याओं का अधिकतम योग खोजें जो एक निर्दिष्ट संख्या k से विभाज्य हो।\nयह फ़ंक्शन एक array और एक पूर्णांक k को तर्क के रूप में लेता है। यह array से किसी भी तीन संख्याओं का अधिकतम योग लौटाता है ताकि यह योग k से विभाज्य हो। यह सुनिश्चित है कि array में कम से कम तीन संख्याएँ हैं और एक समाधान मौजूद है।\n\nउदाहरण:\n>>> max_sum_divisible_by_k([1, 2, 3, 4], 3)\n9\n>>> max_sum_divisible_by_k([4, 5, 10, 20], 5)\n35",
      "hu": "Írj egy ruby függvényt `def max_sum_divisible_by_k(numbers, k)` a következő probléma megoldására:\nMegtalálja a maximális összeget bármely három számból egy adott tömbből, amely osztható egy megadott k számmal.\nEz a függvény egy számokat tartalmazó tömböt és egy egész számot, k-t vesz át argumentumként. Visszaadja a maximális összeget\nbármely három számból a tömbből, úgy hogy ez az összeg osztható legyen k-val. Garantált, hogy a tömbben legalább három szám van, és hogy létezik megoldás.\n\nPélda:\n>>> max_sum_divisible_by_k([1, 2, 3, 4], 3)\n9\n>>> max_sum_divisible_by_k([4, 5, 10, 20], 5)\n35"
    },
    "instruction_bertscore": {
      "sq": "0.9959390018597417",
      "hy": "0.9879481016307081",
      "bn": "0.9839480830174275",
      "bg": "0.9898106587136724",
      "zh": "0.9706976489289713",
      "fr": "0.9959390018597417",
      "de": "0.9932076354901309",
      "ha": "0.9509559739882947",
      "hi": "0.9741679203160317",
      "hu": "0.9768347318118061"
    },
    "level": "middle",
    "test": "raise 'Test failed' unless max_sum_divisible_by_k([1, 2, 3, 4], 3) == 9\nraise 'Test failed' unless max_sum_divisible_by_k([4, 5, 10, 20], 5) == 35\nraise 'Test failed' unless max_sum_divisible_by_k([6, 12, 17, 23, 29], 7) == 35\nraise 'Test failed' unless max_sum_divisible_by_k([7, 14, 21, 28], 7) == 63\nraise 'Test failed' unless max_sum_divisible_by_k([10, 15, 25, 30, 40], 10) == 80\n\n\nputs 'All tests passed!'",
    "entry_point": "max_sum_divisible_by_k",
    "signature": "def max_sum_divisible_by_k(numbers, k)",
    "docstring": {
      "en": "Finds the maximum sum of any three numbers from a given array that is divisible by a specified number k.\nThis function takes an array of numbers and an integer k as arguments. It returns the maximum sum\nof any three numbers from the array such that this sum is divisible by k. It's guaranteed that there\nare at least three numbers in the array and that a solution exists.\n\nExample:\n>>> max_sum_divisible_by_k([1, 2, 3, 4], 3)\n9\n>>> max_sum_divisible_by_k([4, 5, 10, 20], 5)\n35",
      "sq": "Gjen shumën maksimale të çdo treshe numrash nga një varg i dhënë që është e pjestueshme me një numër të specifikuar k. Kjo funksion merr një varg numrash dhe një numër të plotë k si argumente. Ajo kthen shumën maksimale të çdo treshe numrash nga vargu në mënyrë që kjo shumë të jetë e pjestueshme me k. Është e garantuar që ka të paktën tre numra në varg dhe që ekziston një zgjidhje.\n\nShembull:\n>>> max_sum_divisible_by_k([1, 2, 3, 4], 3)\n9\n>>> max_sum_divisible_by_k([4, 5, 10, 20], 5)\n35",
      "hy": "Գտնում է տրված զանգվածից որևէ երեք թվերի առավելագույն գումարը, որը բաժանվում է նշված k թվով:\nԱյս ֆունկցիան ընդունում է թվերի զանգված և ամբողջ թիվ k որպես արգումենտներ։ Այն վերադարձնում է զանգվածից որևէ երեք թվերի առավելագույն գումարը, այնպես որ այս գումարը բաժանվի k թվով։ Երաշխավորված է, որ զանգվածում առնվազն երեք թիվ կա և լուծում գոյություն ունի։\n\nՕրինակ:\n>>> max_sum_divisible_by_k([1, 2, 3, 4], 3)\n9\n>>> max_sum_divisible_by_k([4, 5, 10, 20], 5)\n35",
      "bn": "একটি প্রদত্ত অ্যারের যেকোনো তিনটি সংখ্যার সর্বাধিক যোগফল খুঁজে বের করে যা একটি নির্দিষ্ট সংখ্যা k দ্বারা বিভাজ্য।\nএকটি নির্দিষ্ট সংখ্যা k দ্বারা বিভাজ্য প্রদত্ত অ্যারের যেকোনো তিনটি সংখ্যার সর্বাধিক যোগফল খুঁজে বের করে।  \nThis function takes an array of numbers and an integer k as arguments. It returns the maximum sum  \nএই ফাংশনটি একটি সংখ্যা অ্যারে এবং একটি পূর্ণসংখ্যা k কে আর্গুমেন্ট হিসেবে গ্রহণ করে। এটি অ্যারের যেকোনো তিনটি সংখ্যার সর্বাধিক যোগফল প্রদান করে  \nof any three numbers from the array such that this sum is divisible by k. It's guaranteed that there  \nযাতে এই যোগফল k দ্বারা বিভাজ্য হয়। এটি নিশ্চিত যে অ্যারেতে অন্তত তিনটি সংখ্যা রয়েছে এবং একটি সমাধান বিদ্যমান।  \n\nExample:  \n>>> max_sum_divisible_by_k([1, 2, 3, 4], 3)  \n9  \n>>> max_sum_divisible_by_k([4, 5, 10, 20], 5)  \n35  ",
      "bg": "Намира максималната сума на произволни три числа от даден масив, която е делима на определено число k. Тази функция приема масив от числа и цяло число k като аргументи. Тя връща максималната сума на произволни три числа от масива, така че тази сума да е делима на k. Гарантирано е, че в масива има поне три числа и че съществува решение.\n\nПример:\n>>> max_sum_divisible_by_k([1, 2, 3, 4], 3)\n9\n>>> max_sum_divisible_by_k([4, 5, 10, 20], 5)\n35",
      "zh": "找到给定数组中任意三个数字的最大和，使其能被指定的数字k整除。\n此函数接受一个数字数组和一个整数k作为参数。它返回数组中任意三个数字的最大和，使得这个和能被k整除。可以保证数组中至少有三个数字，并且存在一个解。\n\n示例：\n>>> max_sum_divisible_by_k([1, 2, 3, 4], 3)\n9\n>>> max_sum_divisible_by_k([4, 5, 10, 20], 5)\n35",
      "fr": "Trouve la somme maximale de trois nombres quelconques d'un tableau donné qui est divisible par un nombre spécifié k.\nCette fonction prend un tableau de nombres et un entier k comme arguments. Elle renvoie la somme maximale\nde trois nombres quelconques du tableau telle que cette somme soit divisible par k. Il est garanti qu'il y a\nau moins trois nombres dans le tableau et qu'une solution existe.\n\nExemple :\n>>> max_sum_divisible_by_k([1, 2, 3, 4], 3)\n9\n>>> max_sum_divisible_by_k([4, 5, 10, 20], 5)\n35",
      "de": "Findet die maximale Summe von beliebigen drei Zahlen aus einem gegebenen Array, die durch eine angegebene Zahl k teilbar ist.\nDiese Funktion nimmt ein Array von Zahlen und eine ganze Zahl k als Argumente. Sie gibt die maximale Summe\nvon beliebigen drei Zahlen aus dem Array zurück, so dass diese Summe durch k teilbar ist. Es ist garantiert, dass es\nmindestens drei Zahlen im Array gibt und dass eine Lösung existiert.\n\nBeispiel:\n>>> max_sum_divisible_by_k([1, 2, 3, 4], 3)\n9\n>>> max_sum_divisible_by_k([4, 5, 10, 20], 5)\n35",
      "ha": "Nemo mafi girman jimillar kowanne lambobi uku daga wani jeri da aka bayar wanda za a iya raba shi da wani lamba k da aka ƙayyade.\nWannan aikin yana ɗaukar jeri na lambobi da kuma lamba k a matsayin hujjoji. Yana mayar da mafi girman jimillar kowanne lambobi uku daga jerin ta yadda wannan jimillar za a iya raba ta da k. An tabbatar da cewa akwai akalla lambobi uku a cikin jerin kuma akwai mafita.\n\nMisali:\n>>> max_sum_divisible_by_k([1, 2, 3, 4], 3)\n9\n>>> max_sum_divisible_by_k([4, 5, 10, 20], 5)\n35",
      "hi": "दिए गए एरे में से किसी भी तीन संख्याओं का अधिकतम योग खोजता है जो एक निर्दिष्ट संख्या k से विभाज्य है।\nयह फ़ंक्शन एक एरे और एक पूर्णांक k को तर्क के रूप में लेता है। यह एरे से किसी भी तीन संख्याओं का अधिकतम योग लौटाता है ताकि यह योग k से विभाज्य हो। यह सुनिश्चित है कि एरे में कम से कम तीन संख्याएँ हैं और एक समाधान मौजूद है।\n\nउदाहरण:\n>>> max_sum_divisible_by_k([1, 2, 3, 4], 3)\n9\n>>> max_sum_divisible_by_k([4, 5, 10, 20], 5)\n35",
      "hu": "Megkeresi a megadott tömb bármely három számának maximális összegét, amely osztható egy megadott k számmal.\nEz a függvény egy számokból álló tömböt és egy egész számot, k-t vesz át argumentumként. Visszaadja a tömb bármely három számának maximális összegét úgy, hogy ez az összeg osztható legyen k-val. Garantált, hogy a tömbben legalább három szám van, és hogy létezik megoldás.\n\nPélda:\n>>> max_sum_divisible_by_k([1, 2, 3, 4], 3)\n9\n>>> max_sum_divisible_by_k([4, 5, 10, 20], 5)\n35"
    },
    "docstring_bertscore": {
      "sq": "0.9703925526637016",
      "hy": "0.9919077982766387",
      "bn": "0.8610445416001853",
      "bg": "0.9883040472735227",
      "zh": "0.9659454170627115",
      "fr": "0.9919930107101026",
      "de": "0.9877617863332975",
      "ha": "0.9328458489974388",
      "hi": "0.9805600446081155",
      "hu": "0.9806464488238656"
    }
  },
  {
    "task_id": "Ruby/14",
    "prompt": {
      "en": "# Calculates the difference in the number of victories between the most and least successful teams.\n# This function takes a string, team_sequence, representing the sequence of winning teams, where each team\n# is identified by a lowercase letter. It returns an integer representing the difference in the number\n# of victories between the team that won the most and the team that won the least (excluding teams with zero victories).\n#\n# Example:\n# >>> victory_gap_in_teams(\"abaabcaa\")\n# 4\n# >>> victory_gap_in_teams(\"abcd\")\n# 0\n\ndef victory_gap_in_teams(team_sequence)",
      "sq": "# Llogarit diferencën në numrin e fitoreve midis ekipeve më të suksesshme dhe më pak të suksesshme.\n# Kjo funksion merr një varg, team_sequence, që përfaqëson sekuencën e ekipeve fituese, ku çdo ekip\n# identifikohet nga një shkronjë e vogël. Ajo kthen një numër të plotë që përfaqëson diferencën në numrin\n# e fitoreve midis ekipit që fitoi më shumë dhe ekipit që fitoi më pak (duke përjashtuar ekipet me zero fitore).\n#\n# Shembull:\n# >>> victory_gap_in_teams(\"abaabcaa\")\n# 4\n# >>> victory_gap_in_teams(\"abcd\")\n# 0\n\ndef victory_gap_in_teams(team_sequence)",
      "hy": "# Հաշվում է հաղթանակների տարբերությունը ամենահաջողակ և ամենաքիչ հաջողակ թիմերի միջև։\n# Այս ֆունկցիան ընդունում է team_sequence տողը, որը ներկայացնում է հաղթող թիմերի հաջորդականությունը, որտեղ յուրաքանչյուր թիմ\n# նշվում է փոքրատառ տառով։ Այն վերադարձնում է ամբողջ թիվ, որը ներկայացնում է հաղթանակների տարբերությունը\n# ամենաշատ հաղթած թիմի և ամենաքիչ հաղթած թիմի միջև (բացառելով զրո հաղթանակ ունեցող թիմերը)։\n#\n# Օրինակ:\n# >>> victory_gap_in_teams(\"abaabcaa\")\n# 4\n# >>> victory_gap_in_teams(\"abcd\")\n# 0\n\ndef victory_gap_in_teams(team_sequence)",
      "bn": "# সবচেয়ে সফল এবং সবচেয়ে কম সফল দলের মধ্যে বিজয়ের সংখ্যার পার্থক্য গণনা করে।\n# এই ফাংশনটি একটি স্ট্রিং, team_sequence, গ্রহণ করে, যা বিজয়ী দলের ক্রমকে উপস্থাপন করে, যেখানে প্রতিটি দল\n# একটি ছোট হাতের অক্ষর দ্বারা চিহ্নিত করা হয়। এটি একটি পূর্ণসংখ্যা ফেরত দেয় যা সবচেয়ে বেশি জয়ী দল এবং সবচেয়ে কম জয়ী দলের মধ্যে\n# বিজয়ের সংখ্যার পার্থক্য উপস্থাপন করে (যে দলগুলোর জয় সংখ্যা শূন্য, তাদের বাদ দিয়ে)।\n#\n# উদাহরণ:\n# >>> victory_gap_in_teams(\"abaabcaa\")\n# 4\n# >>> victory_gap_in_teams(\"abcd\")\n# 0\n\ndef victory_gap_in_teams(team_sequence)",
      "bg": "# Изчислява разликата в броя на победите между най-успешните и най-малко успешните отбори.\n# Тази функция приема низ, team_sequence, представляващ последователността на печелившите отбори, където всеки отбор\n# е идентифициран с малка буква. Тя връща цяло число, представляващо разликата в броя\n# на победите между отбора, който е спечелил най-много, и отбора, който е спечелил най-малко (изключвайки отбори с нула победи).\n#\n# Пример:\n# >>> victory_gap_in_teams(\"abaabcaa\")\n# 4\n# >>> victory_gap_in_teams(\"abcd\")\n# 0\n\ndef victory_gap_in_teams(team_sequence)",
      "zh": "# 计算最成功和最不成功的团队之间胜利次数的差异。\n# 这个函数接受一个字符串 team_sequence，表示获胜团队的顺序，其中每个团队\n# 由一个小写字母标识。它返回一个整数，表示胜利次数最多的团队和胜利次数最少的团队之间的差异（不包括胜利次数为零的团队）。\n#\n# 例子:\n# >>> victory_gap_in_teams(\"abaabcaa\")\n# 4\n# >>> victory_gap_in_teams(\"abcd\")\n# 0\n\ndef victory_gap_in_teams(team_sequence)",
      "fr": "# Calcule la différence du nombre de victoires entre les équipes les plus et les moins performantes.\n# Cette fonction prend une chaîne de caractères, team_sequence, représentant la séquence des équipes gagnantes, où chaque équipe\n# est identifiée par une lettre minuscule. Elle renvoie un entier représentant la différence du nombre\n# de victoires entre l'équipe qui a gagné le plus et l'équipe qui a gagné le moins (en excluant les équipes avec zéro victoire).\n#\n# Exemple:\n# >>> victory_gap_in_teams(\"abaabcaa\")\n# 4\n# >>> victory_gap_in_teams(\"abcd\")\n# 0\n\ndef victory_gap_in_teams(team_sequence)",
      "de": "# Berechnet die Differenz in der Anzahl der Siege zwischen den erfolgreichsten und den am wenigsten erfolgreichen Teams.\n# Diese Funktion nimmt einen String, team_sequence, der die Sequenz der siegreichen Teams darstellt, wobei jedes Team\n# durch einen Kleinbuchstaben identifiziert wird. Sie gibt eine ganze Zahl zurück, die die Differenz in der Anzahl\n# der Siege zwischen dem Team, das am meisten gewonnen hat, und dem Team, das am wenigsten gewonnen hat, darstellt (ausgenommen Teams mit null Siegen).\n#\n# Beispiel:\n# >>> victory_gap_in_teams(\"abaabcaa\")\n# 4\n# >>> victory_gap_in_teams(\"abcd\")\n# 0\n\ndef victory_gap_in_teams(team_sequence)",
      "ha": "# Lissafa bambanci a cikin adadin nasarori tsakanin ƙungiyoyin da suka fi nasara da waɗanda suka fi rashin nasara.\n# Wannan aikin yana karɓar wani igiyar rubutu, team_sequence, wanda ke wakiltar jerin ƙungiyoyin da suka yi nasara, inda kowace ƙungiya\n# aka gano ta da wata ƙaramin harafi. Yana dawowa da wani lamba wanda ke wakiltar bambanci a cikin adadin\n# nasarori tsakanin ƙungiyar da ta fi nasara da ƙungiyar da ta fi rashin nasara (ba tare da haɗa ƙungiyoyin da ba su yi nasara ba).\n#\n# Misali:\n# >>> victory_gap_in_teams(\"abaabcaa\")\n# 4\n# >>> victory_gap_in_teams(\"abcd\")\n# 0\n\ndef victory_gap_in_teams(team_sequence)",
      "hi": "# सबसे सफल और सबसे कम सफल टीमों के बीच जीत की संख्या में अंतर की गणना करता है।\n# यह फ़ंक्शन एक स्ट्रिंग लेता है, team_sequence, जो विजेता टीमों के अनुक्रम का प्रतिनिधित्व करता है, जहाँ प्रत्येक टीम\n# एक छोटे अक्षर द्वारा पहचानी जाती है। यह एक पूर्णांक लौटाता है जो सबसे अधिक जीतने वाली टीम और सबसे कम जीतने वाली टीम के बीच\n# जीत की संख्या में अंतर का प्रतिनिधित्व करता है (शून्य जीत वाली टीमों को छोड़कर)।\n#\n# उदाहरण:\n# >>> victory_gap_in_teams(\"abaabcaa\")\n# 4\n# >>> victory_gap_in_teams(\"abcd\")\n# 0\n\ndef victory_gap_in_teams(team_sequence)",
      "hu": "# Kiszámítja a győzelmek számának különbségét a legsikeresebb és a legkevésbé sikeres csapatok között.\n# Ez a függvény egy karakterláncot, team_sequence-t vesz át, amely a győztes csapatok sorozatát jelenti, ahol minden csapatot\n# egy kisbetű azonosít. Visszaad egy egész számot, amely a legtöbbet nyert és a legkevesebbet nyert csapat győzelmeinek\n# száma közötti különbséget jelenti (a nulla győzelemmel rendelkező csapatok kizárásával).\n#\n# Példa:\n# >>> victory_gap_in_teams(\"abaabcaa\")\n# 4\n# >>> victory_gap_in_teams(\"abcd\")\n# 0\n\ndef victory_gap_in_teams(team_sequence)"
    },
    "prompt_bertscore": {
      "sq": "0.987417957143726",
      "hy": "0.9606719790766163",
      "bn": "0.9729886517438276",
      "bg": "0.9815096964598433",
      "zh": "0.9670061032974379",
      "fr": "0.9956343028552342",
      "de": "0.9780580963286001",
      "ha": "0.9683585775619044",
      "hi": "0.9744094548593701",
      "hu": "0.9734441112075406"
    },
    "canonical_solution": "    counts = Hash.new(0)\n    team_sequence.each_char { |team| counts[team] += 1 }\n  \n    max_victories = counts.values.max\n    min_victories = counts.values.reject { |v| v == 0 }.min\n  \n    max_victories - min_victories\n  end",
    "instruction": {
      "en": "Write a ruby function `def victory_gap_in_teams(team_sequence)` to solve the following problem:\nCalculates the difference in the number of victories between the most and least successful teams.\nThis function takes a string, team_sequence, representing the sequence of winning teams, where each team\nis identified by a lowercase letter. It returns an integer representing the difference in the number\nof victories between the team that won the most and the team that won the least (excluding teams with zero victories).\n\nExample:\n>>> victory_gap_in_teams(\"abaabcaa\")\n4\n>>> victory_gap_in_teams(\"abcd\")\n0",
      "sq": "Shkruani një funksion ruby `def victory_gap_in_teams(team_sequence)` për të zgjidhur problemin e mëposhtëm:\nLlogarit diferencën në numrin e fitoreve midis ekipeve më të suksesshme dhe më pak të suksesshme.\nKy funksion merr një varg, team_sequence, që përfaqëson sekuencën e ekipeve fituese, ku secili ekip\nidentifikohet nga një shkronjë e vogël. Ai kthen një numër të plotë që përfaqëson diferencën në numrin\ne fitoreve midis ekipit që fitoi më shumë dhe ekipit që fitoi më pak (duke përjashtuar ekipet me zero fitore).\n\nShembull:\n>>> victory_gap_in_teams(\"abaabcaa\")\n4\n>>> victory_gap_in_teams(\"abcd\")\n0",
      "hy": "Գրեք ruby ֆունկցիա `def victory_gap_in_teams(team_sequence)` հետևյալ խնդիրը լուծելու համար:\nՀաշվում է հաղթանակների քանակի տարբերությունը ամենահաջողակ և ամենափոքր հաջողություն ունեցող թիմերի միջև:\nԱյս ֆունկցիան ընդունում է team_sequence տողը, որը ներկայացնում է հաղթող թիմերի հաջորդականությունը, որտեղ յուրաքանչյուր թիմ\nներկայացված է փոքրատառ տառով: Այն վերադարձնում է ամբողջ թիվ, որը ներկայացնում է հաղթանակների քանակի տարբերությունը\nամենաշատ հաղթած և ամենաքիչ հաղթած թիմերի միջև (բացառելով զրո հաղթանակ ունեցող թիմերը):\n\nՕրինակ:\n>>> victory_gap_in_teams(\"abaabcaa\")\n4\n>>> victory_gap_in_teams(\"abcd\")\n0",
      "bn": "রুবি ফাংশন `def victory_gap_in_teams(team_sequence)` লিখুন নিম্নলিখিত সমস্যার সমাধানের জন্য:\nসবচেয়ে সফল এবং সবচেয়ে কম সফল দলের মধ্যে বিজয়ের সংখ্যার পার্থক্য গণনা করে।\nএই ফাংশনটি একটি স্ট্রিং নেয়, team_sequence, যা বিজয়ী দলের ক্রমকে উপস্থাপন করে, যেখানে প্রতিটি দল একটি ছোট হাতের অক্ষর দ্বারা চিহ্নিত করা হয়। এটি একটি পূর্ণসংখ্যা ফেরত দেয় যা সবচেয়ে বেশি বিজয়ী দল এবং সবচেয়ে কম বিজয়ী দলের মধ্যে বিজয়ের সংখ্যার পার্থক্য উপস্থাপন করে (যে দলগুলোর বিজয় সংখ্যা শূন্য তাদের বাদ দিয়ে)।\n\nউদাহরণ:\n>>> victory_gap_in_teams(\"abaabcaa\")\n4\n>>> victory_gap_in_teams(\"abcd\")\n0",
      "bg": "Напишете Ruby функция `def victory_gap_in_teams(team_sequence)` за решаване на следния проблем:\nИзчислява разликата в броя на победите между най-успешните и най-малко успешните отбори.\nТази функция приема низ, team_sequence, представляващ последователността на печелившите отбори, където всеки отбор\nе идентифициран с малка буква. Тя връща цяло число, представляващо разликата в броя\nна победите между отбора с най-много победи и отбора с най-малко победи (без да се включват отбори с нула победи).\n\nПример:\n>>> victory_gap_in_teams(\"abaabcaa\")\n4\n>>> victory_gap_in_teams(\"abcd\")\n0",
      "zh": "编写一个 ruby 函数 `def victory_gap_in_teams(team_sequence)` 来解决以下问题：\n计算最成功和最不成功的团队之间胜利次数的差异。\n此函数接受一个字符串 `team_sequence`，表示获胜团队的顺序，其中每个团队由一个小写字母标识。它返回一个整数，表示获胜次数最多的团队和获胜次数最少的团队之间的差异（不包括胜利次数为零的团队）。\n\n示例：\n>>> victory_gap_in_teams(\"abaabcaa\")\n4\n>>> victory_gap_in_teams(\"abcd\")\n0",
      "fr": "Écrire une fonction ruby `def victory_gap_in_teams(team_sequence)` pour résoudre le problème suivant :\nCalcule la différence dans le nombre de victoires entre les équipes les plus et les moins performantes.\nCette fonction prend une chaîne de caractères, team_sequence, représentant la séquence des équipes gagnantes, où chaque équipe\nest identifiée par une lettre minuscule. Elle renvoie un entier représentant la différence dans le nombre\nde victoires entre l'équipe qui a le plus gagné et l'équipe qui a le moins gagné (en excluant les équipes avec zéro victoire).\n\nExemple :\n>>> victory_gap_in_teams(\"abaabcaa\")\n4\n>>> victory_gap_in_teams(\"abcd\")\n0",
      "de": "Schreiben Sie eine Ruby-Funktion `def victory_gap_in_teams(team_sequence)`, um das folgende Problem zu lösen:\nBerechnet den Unterschied in der Anzahl der Siege zwischen den erfolgreichsten und den am wenigsten erfolgreichen Teams.\nDiese Funktion nimmt einen String, team_sequence, der die Sequenz der siegreichen Teams darstellt, wobei jedes Team durch einen Kleinbuchstaben identifiziert wird. Sie gibt eine ganze Zahl zurück, die den Unterschied in der Anzahl der Siege zwischen dem Team, das am meisten gewonnen hat, und dem Team, das am wenigsten gewonnen hat (ausgenommen Teams mit null Siegen), darstellt.\n\nBeispiel:\n>>> victory_gap_in_teams(\"abaabcaa\")\n4\n>>> victory_gap_in_teams(\"abcd\")\n0",
      "ha": "Rubuta aikin ruby `def victory_gap_in_teams(team_sequence)` don warware matsalar mai zuwa:\nLissafa bambanci a cikin adadin nasarorin tsakanin ƙungiyoyin da suka fi nasara da waɗanda suka fi rashin nasara.\nWannan aikin yana ɗaukar wani igiya, team_sequence, wanda ke wakiltar jerin ƙungiyoyin da suka yi nasara, inda kowace ƙungiya\nana gane ta da wata ƙaramin harafi. Yana dawowa da cikakken lamba wanda ke wakiltar bambanci a cikin adadin\nnasarorin tsakanin ƙungiyar da ta fi nasara da ƙungiyar da ta fi rashin nasara (ban da ƙungiyoyin da ba su da nasara).\n\nMisali:\n>>> victory_gap_in_teams(\"abaabcaa\")\n4\n>>> victory_gap_in_teams(\"abcd\")\n0",
      "hi": "रूबी फ़ंक्शन `def victory_gap_in_teams(team_sequence)` लिखें ताकि निम्नलिखित समस्या का समाधान किया जा सके:\nसबसे सफल और सबसे कम सफल टीमों के बीच जीत की संख्या में अंतर की गणना करता है।\nयह फ़ंक्शन एक स्ट्रिंग लेता है, team_sequence, जो जीतने वाली टीमों के अनुक्रम का प्रतिनिधित्व करता है, जहाँ प्रत्येक टीम को एक लोअरकेस अक्षर द्वारा पहचाना जाता है। यह एक पूर्णांक लौटाता है जो उस टीम के बीच जीत की संख्या में अंतर का प्रतिनिधित्व करता है जिसने सबसे अधिक जीत हासिल की और जिसने सबसे कम (शून्य जीत वाली टीमों को छोड़कर)।\n\nउदाहरण:\n>>> victory_gap_in_teams(\"abaabcaa\")\n4\n>>> victory_gap_in_teams(\"abcd\")\n0",
      "hu": "Írj egy ruby függvényt `def victory_gap_in_teams(team_sequence)` a következő probléma megoldására:\nKiszámítja a győzelmek számának különbségét a legsikeresebb és a legkevésbé sikeres csapatok között.\nEz a függvény egy karakterláncot vesz át, team_sequence, amely a győztes csapatok sorozatát jelenti, ahol minden csapatot egy kisbetű azonosít. Egy egész számot ad vissza, amely a legtöbbet nyert csapat és a legkevesebbet nyert csapat (nulla győzelemmel rendelkező csapatok kizárva) közötti győzelmek számának különbségét jelenti.\n\nPélda:\n>>> victory_gap_in_teams(\"abaabcaa\")\n4\n>>> victory_gap_in_teams(\"abcd\")\n0"
    },
    "instruction_bertscore": {
      "sq": "0.9894773569342957",
      "hy": "0.9674468641129542",
      "bn": "0.9737388786929964",
      "bg": "0.9818072447706335",
      "zh": "0.9681802074797351",
      "fr": "0.9987154573258474",
      "de": "0.985862879890604",
      "ha": "0.9727353980080081",
      "hi": "0.9785598366710941",
      "hu": "0.9805242911395292"
    },
    "level": "easy",
    "test": "raise 'Test failed' unless victory_gap_in_teams(\"abaabcaa\") == 4\nraise 'Test failed' unless victory_gap_in_teams(\"abcd\") == 0\nraise 'Test failed' unless victory_gap_in_teams(\"a\") == 0\nraise 'Test failed' unless victory_gap_in_teams(\"aaabbbccc\") == 0\nraise 'Test failed' unless victory_gap_in_teams(\"abcdaaa\") == 3\n\nputs 'All tests passed!'",
    "entry_point": "victory_gap_in_teams",
    "signature": "def victory_gap_in_teams(team_sequence)",
    "docstring": {
      "en": "Calculates the difference in the number of victories between the most and least successful teams.\nThis function takes a string, team_sequence, representing the sequence of winning teams, where each team\nis identified by a lowercase letter. It returns an integer representing the difference in the number\nof victories between the team that won the most and the team that won the least (excluding teams with zero victories).\n\nExample:\n>>> victory_gap_in_teams(\"abaabcaa\")\n4\n>>> victory_gap_in_teams(\"abcd\")\n0",
      "sq": "Llogarit ndryshimin në numrin e fitoreve midis ekipeve më të suksesshme dhe atyre më pak të suksesshme. Kjo funksion merr një varg, team_sequence, që përfaqëson sekuencën e ekipeve fituese, ku secili ekip identifikohet nga një shkronjë e vogël. Kthen një numër të plotë që përfaqëson ndryshimin në numrin e fitoreve midis ekipit që fitoi më shumë dhe ekipit që fitoi më pak (duke përjashtuar ekipet me zero fitore).\n\nShembull:\n>>> victory_gap_in_teams(\"abaabcaa\")\n4\n>>> victory_gap_in_teams(\"abcd\")\n0",
      "hy": "Հաշվում է հաղթանակների քանակի տարբերությունը ամենահաջողակ և ամենաքիչ հաջողակ թիմերի միջև։  \nԱյս ֆունկցիան ընդունում է team_sequence տողը, որը ներկայացնում է հաղթող թիմերի հաջորդականությունը, որտեղ յուրաքանչյուր թիմ  \nներկայացված է փոքրատառ տառով։ Այն վերադարձնում է ամբողջ թիվ, որը ներկայացնում է հաղթանակների քանակի տարբերությունը  \nամենաշատ հաղթած թիմի և ամենաքիչ հաղթած թիմի միջև (բացառելով զրո հաղթանակ ունեցող թիմերը)։\n\nՕրինակ:  \n>>> victory_gap_in_teams(\"abaabcaa\")  \n4  \n>>> victory_gap_in_teams(\"abcd\")  \n0",
      "bn": "সর্বাধিক এবং সর্বনিম্ন সফল দলের মধ্যে বিজয়ের সংখ্যার পার্থক্য গণনা করে। \nএই ফাংশনটি একটি স্ট্রিং, team_sequence, গ্রহণ করে যা বিজয়ী দলের ক্রমকে উপস্থাপন করে, যেখানে প্রতিটি দল একটি ছোট হাতের অক্ষর দ্বারা চিহ্নিত হয়। এটি একটি পূর্ণসংখ্যা প্রদান করে যা সর্বাধিক বিজয়ী দল এবং সর্বনিম্ন বিজয়ী দলের মধ্যে বিজয়ের সংখ্যার পার্থক্যকে উপস্থাপন করে (শূন্য বিজয়ী দলগুলিকে বাদ দিয়ে)।\n\nউদাহরণ:\n>>> victory_gap_in_teams(\"abaabcaa\")\n4\n>>> victory_gap_in_teams(\"abcd\")\n0",
      "bg": "Изчислява разликата в броя на победите между най-успешните и най-малко успешните отбори.  \nТази функция приема низ, team_sequence, представляващ последователността на печелившите отбори, където всеки отбор е идентифициран с малка буква. Връща цяло число, представляващо разликата в броя на победите между отбора, който е спечелил най-много, и отбора, който е спечелил най-малко (изключвайки отборите с нула победи).\n\nПример:\n>>> victory_gap_in_teams(\"abaabcaa\")\n4\n>>> victory_gap_in_teams(\"abcd\")\n0",
      "zh": "计算最成功和最不成功的团队之间胜利次数的差异。\n此函数接受一个字符串 `team_sequence`，表示获胜团队的序列，其中每个团队由一个小写字母标识。它返回一个整数，表示获胜次数最多的团队和获胜次数最少的团队之间的差异（不包括胜利次数为零的团队）。\n\n示例：\n>>> victory_gap_in_teams(\"abaabcaa\")\n4\n>>> victory_gap_in_teams(\"abcd\")\n0",
      "fr": "Calcule la différence du nombre de victoires entre les équipes les plus et les moins performantes.\nCette fonction prend une chaîne de caractères, team_sequence, représentant la séquence des équipes gagnantes, où chaque équipe est identifiée par une lettre minuscule. Elle renvoie un entier représentant la différence du nombre de victoires entre l'équipe qui a gagné le plus et l'équipe qui a gagné le moins (en excluant les équipes sans victoire).\n\nExemple :\n>>> victory_gap_in_teams(\"abaabcaa\")\n4\n>>> victory_gap_in_teams(\"abcd\")\n0",
      "de": "Berechnet den Unterschied in der Anzahl der Siege zwischen den erfolgreichsten und den am wenigsten erfolgreichen Teams.\nDiese Funktion nimmt einen String, team_sequence, der die Sequenz der siegreichen Teams darstellt, wobei jedes Team durch einen Kleinbuchstaben identifiziert wird. Sie gibt eine ganze Zahl zurück, die den Unterschied in der Anzahl der Siege zwischen dem Team, das am meisten gewonnen hat, und dem Team, das am wenigsten gewonnen hat (ohne Teams mit null Siegen), darstellt.\n\nBeispiel:\n>>> victory_gap_in_teams(\"abaabcaa\")\n4\n>>> victory_gap_in_teams(\"abcd\")\n0",
      "ha": "Yana ƙididdige bambanci a cikin adadin nasarorin tsakanin ƙungiyoyin da suka fi nasara da waɗanda suka fi rashin nasara.\nWannan aikin yana ɗaukar kirtani, team_sequence, wanda ke wakiltar jerin ƙungiyoyin da suka yi nasara, inda kowace ƙungiya\nana gane ta da wata ƙaramin harafi. Yana mayar da cikakken lamba wanda ke wakiltar bambanci a cikin adadin\nnasarorin tsakanin ƙungiyar da ta fi nasara da ƙungiyar da ta fi rashin nasara (ba tare da haɗa ƙungiyoyin da ba su yi nasara ba).\n\nMisali:\n>>> victory_gap_in_teams(\"abaabcaa\")\n4\n>>> victory_gap_in_teams(\"abcd\")\n0",
      "hi": "विजयी टीमों के बीच सबसे अधिक और सबसे कम सफल टीमों के बीच जीत की संख्या में अंतर की गणना करता है।  \nयह फ़ंक्शन एक स्ट्रिंग, team_sequence, लेता है, जो विजयी टीमों के अनुक्रम का प्रतिनिधित्व करता है, जहाँ प्रत्येक टीम को एक छोटे अक्षर द्वारा पहचाना जाता है। यह एक पूर्णांक लौटाता है जो सबसे अधिक जीतने वाली टीम और सबसे कम जीतने वाली टीम के बीच जीत की संख्या में अंतर का प्रतिनिधित्व करता है (शून्य जीत वाली टीमों को छोड़कर)।\n\nउदाहरण:\n>>> victory_gap_in_teams(\"abaabcaa\")\n4\n>>> victory_gap_in_teams(\"abcd\")\n0",
      "hu": "Számítja a győzelmek számának különbségét a legsikeresebb és a legkevésbé sikeres csapatok között.\nEz a függvény egy karakterláncot, team_sequence-t vesz fel, amely a győztes csapatok sorrendjét jelöli, ahol minden csapatot egy kisbetű azonosít. Egy egész számot ad vissza, amely a győzelmek számának különbségét jelenti a legtöbbet nyerő és a legkevesebbet nyerő csapat között (kivéve azokat a csapatokat, amelyeknek nulla győzelmük van).\n\nPélda:\n>>> victory_gap_in_teams(\"abaabcaa\")\n4\n>>> victory_gap_in_teams(\"abcd\")\n0"
    },
    "docstring_bertscore": {
      "sq": "0.9802984483962925",
      "hy": "0.9677610973757514",
      "bn": "0.9704892856592656",
      "bg": "0.9805814966892673",
      "zh": "0.962988009319483",
      "fr": "0.9862519968070512",
      "de": "0.9752164900975149",
      "ha": "0.9581839349237733",
      "hi": "0.9695652571266913",
      "hu": "0.9714145059741262"
    }
  },
  {
    "task_id": "Ruby/15",
    "prompt": {
      "en": "# Determines the maximum number of drop tests needed to find the drop tolerance height of a device from a building with a given height.\n# The function takes a single argument, n, which is the height of the building (number of floors).\n# It returns the maximum number of tests needed to find the exact floor from which if the device is dropped, it will break.\n#\n# The problem assumes the worst-case scenario, where the outcome of each test is the least favorable, thus requiring the maximum number of tests.\n#\n# Example:\n# >>> max_drop_test_height(3)\n# 2\n# >>> max_drop_test_height(10)\n# 4\n\n\ndef max_drop_test_height(n)",
      "sq": "# Përcakton numrin maksimal të testeve të hedhjes që nevojiten për të gjetur lartësinë e tolerancës së hedhjes së një pajisjeje nga një ndërtesë me një lartësi të dhënë.\n# Funksioni merr një argument të vetëm, n, i cili është lartësia e ndërtesës (numri i kateve).\n# Ai kthen numrin maksimal të testeve të nevojshme për të gjetur katin e saktë nga i cili, nëse pajisja hidhet, do të thyhet.\n#\n# Problemi supozon skenarin më të keq, ku rezultati i secilit test është më pak i favorshmi, duke kërkuar kështu numrin maksimal të testeve.\n#\n# Shembull:\n# >>> max_drop_test_height(3)\n# 2\n# >>> max_drop_test_height(10)\n# 4\n\n\ndef max_drop_test_height(n)",
      "hy": "# Սահմանում է սարքի անկման դիմադրողականության բարձրությունը գտնելու համար անհրաժեշտ առավելագույն փորձարկումների քանակը՝ տրված բարձրությամբ շենքից:\n# Ֆունկցիան ընդունում է մեկ արգումենտ՝ n, որը շենքի բարձրությունն է (հարկերի քանակը):\n# Այն վերադարձնում է անհրաժեշտ փորձարկումների առավելագույն քանակը՝ գտնելու համար այն ճշգրիտ հարկը, որից սարքը կկոտրվի, եթե գցվի:\n#\n# Խնդիրը ենթադրում է ամենավատ սցենարը, որտեղ յուրաքանչյուր փորձարկման արդյունքը ամենաանբարենպաստն է, այսպիսով պահանջելով առավելագույն փորձարկումների քանակը:\n#\n# Օրինակ:\n# >>> max_drop_test_height(3)\n# 2\n# >>> max_drop_test_height(10)\n# 4\n\n\ndef max_drop_test_height(n)",
      "bn": "# একটি ভবনের প্রদত্ত উচ্চতা থেকে একটি ডিভাইসের ড্রপ সহনশীলতা উচ্চতা খুঁজে বের করতে প্রয়োজনীয় সর্বাধিক ড্রপ পরীক্ষার সংখ্যা নির্ধারণ করে।\n# ফাংশনটি একটি একক আর্গুমেন্ট গ্রহণ করে, n, যা ভবনের উচ্চতা (তলার সংখ্যা)।\n# এটি প্রয়োজনীয় সর্বাধিক পরীক্ষার সংখ্যা ফেরত দেয়, যা সঠিক তলা খুঁজে বের করতে প্রয়োজন, যেখান থেকে ডিভাইসটি ফেলে দিলে এটি ভেঙে যাবে।\n#\n# সমস্যাটি সবচেয়ে খারাপ পরিস্থিতি ধরে নেয়, যেখানে প্রতিটি পরীক্ষার ফলাফল সবচেয়ে অনুকূল নয়, ফলে সর্বাধিক পরীক্ষার প্রয়োজন হয়।\n#\n# উদাহরণ:\n# >>> max_drop_test_height(3)\n# 2\n# >>> max_drop_test_height(10)\n# 4\n\n\ndef max_drop_test_height(n)",
      "bg": "# Определя максималния брой тестове за изпускане, необходими за намиране на височината на толерантност при изпускане на устройство от сграда с дадена височина.\n# Функцията приема един аргумент, n, който е височината на сградата (брой етажи).\n# Връща максималния брой тестове, необходими за намиране на точния етаж, от който ако устройството бъде изпуснато, ще се счупи.\n#\n# Проблемът предполага най-лошия сценарий, при който резултатът от всеки тест е най-неблагоприятен, което изисква максимален брой тестове.\n#\n# Пример:\n# >>> max_drop_test_height(3)\n# 2\n# >>> max_drop_test_height(10)\n# 4\n\n\ndef max_drop_test_height(n)",
      "zh": "# 确定需要进行的最大跌落测试次数，以找出设备从建筑物的某一高度跌落的耐受高度。\n# 该函数接受一个参数 n，即建筑物的高度（楼层数）。\n# 它返回找到确切楼层所需的最大测试次数，如果设备从该楼层跌落，它将会损坏。\n#\n# 该问题假设最坏情况，即每次测试的结果都是最不利的，因此需要最大次数的测试。\n#\n# 示例:\n# >>> max_drop_test_height(3)\n# 2\n# >>> max_drop_test_height(10)\n# 4\n\n\ndef max_drop_test_height(n)",
      "fr": "# Détermine le nombre maximum de tests de chute nécessaires pour trouver la hauteur de tolérance de chute d'un appareil depuis un bâtiment d'une hauteur donnée.\n# La fonction prend un seul argument, n, qui est la hauteur du bâtiment (nombre d'étages).\n# Elle renvoie le nombre maximum de tests nécessaires pour trouver l'étage exact à partir duquel, si l'appareil est lâché, il se cassera.\n#\n# Le problème suppose le pire des cas, où le résultat de chaque test est le moins favorable, nécessitant ainsi le nombre maximum de tests.\n#\n# Exemple:\n# >>> max_drop_test_height(3)\n# 2\n# >>> max_drop_test_height(10)\n# 4\n\n\ndef max_drop_test_height(n)",
      "de": "# Bestimmt die maximale Anzahl an Falltests, die benötigt werden, um die Falltoleranzhöhe eines Geräts von einem Gebäude mit einer gegebenen Höhe zu finden.\n# Die Funktion nimmt ein einziges Argument, n, das die Höhe des Gebäudes (Anzahl der Stockwerke) ist.\n# Sie gibt die maximale Anzahl an Tests zurück, die benötigt werden, um das genaue Stockwerk zu finden, von dem aus das Gerät, wenn es fallen gelassen wird, zerbrechen wird.\n#\n# Das Problem geht vom schlimmsten Fall aus, bei dem das Ergebnis jedes Tests am ungünstigsten ist, was die maximale Anzahl an Tests erfordert.\n#\n# Beispiel:\n# >>> max_drop_test_height(3)\n# 2\n# >>> max_drop_test_height(10)\n# 4\n\n\ndef max_drop_test_height(n)",
      "ha": "# Yana tantance yawan gwaje-gwajen sauke na'ura da ake bukata don gano tsayin da na'urar za ta iya jurewa idan aka sauke ta daga wani gini mai tsayi da aka bayar.\n# Aikin yana karɓar hujja guda, n, wanda shine tsayin ginin (yawan bene).\n# Yana dawowa da yawan gwaje-gwajen da ake bukata don gano ainihin benen da idan aka sauke na'urar daga gare shi, za ta karye.\n#\n# Matsalar tana ɗauka yanayin mafi muni, inda sakamakon kowanne gwaji shine mafi muni, don haka yana buƙatar yawan gwaje-gwaje.\n#\n# Misali:\n# >>> max_drop_test_height(3)\n# 2\n# >>> max_drop_test_height(10)\n# 4\n\n\ndef max_drop_test_height(n)",
      "hi": "# एक उपकरण की ड्रॉप सहनशीलता ऊंचाई को एक इमारत की दी गई ऊंचाई से खोजने के लिए आवश्यक अधिकतम ड्रॉप परीक्षणों की संख्या निर्धारित करता है।\n# यह फ़ंक्शन एकल तर्क n लेता है, जो इमारत की ऊंचाई (मंजिलों की संख्या) है।\n# यह उन परीक्षणों की अधिकतम संख्या लौटाता है जो उस सटीक मंजिल को खोजने के लिए आवश्यक हैं जिससे यदि उपकरण गिराया जाए, तो वह टूट जाएगा।\n#\n# समस्या सबसे खराब स्थिति मानती है, जहां प्रत्येक परीक्षण का परिणाम सबसे कम अनुकूल होता है, इस प्रकार अधिकतम संख्या में परीक्षणों की आवश्यकता होती है।\n#\n# उदाहरण:\n# >>> max_drop_test_height(3)\n# 2\n# >>> max_drop_test_height(10)\n# 4\n\n\ndef max_drop_test_height(n)",
      "hu": "# Meghatározza a maximális számú ejtési tesztet, amely szükséges ahhoz, hogy megtaláljuk egy eszköz ejtési tűréshatárának magasságát egy adott magasságú épületből.\n# A függvény egyetlen argumentumot vesz fel, n, amely az épület magassága (emeletek száma).\n# Visszaadja a szükséges maximális tesztek számát, hogy megtaláljuk azt a pontos emeletet, ahonnan ha az eszközt ledobjuk, az eltörik.\n#\n# A probléma a legrosszabb esetet feltételezi, ahol minden teszt eredménye a legkedvezőtlenebb, így a maximális számú teszt szükséges.\n#\n# Példa:\n# >>> max_drop_test_height(3)\n# 2\n# >>> max_drop_test_height(10)\n# 4\n\n\ndef max_drop_test_height(n)"
    },
    "prompt_bertscore": {
      "sq": "0.9931824094317395",
      "hy": "0.9597618546707144",
      "bn": "0.9653411834436034",
      "bg": "0.9813607236740671",
      "zh": "0.9444470550321624",
      "fr": "0.9915496676996327",
      "de": "0.9847501524960465",
      "ha": "0.9539727722154526",
      "hi": "0.980170331800525",
      "hu": "0.9784299324018974"
    },
    "canonical_solution": "    dp = Array.new(4) { Array.new(n + 1, 0) }\n    (1..n).each { |j| dp[1][j] = j }\n  \n    (2..3).each do |i|\n      (1..n).each do |j|\n        dp[i][j] = j\n        (1..j).each do |k|\n          num = [1 + dp[i-1][k-1], 1 + dp[i][j-k]].max\n          dp[i][j] = [dp[i][j], num].min\n        end\n      end\n    end\n  \n    dp[3][n]\n  end",
    "instruction": {
      "en": "Write a ruby function `def max_drop_test_height(n)` to solve the following problem:\nDetermines the maximum number of drop tests needed to find the drop tolerance height of a device from a building with a given height.\nThe function takes a single argument, n, which is the height of the building (number of floors).\nIt returns the maximum number of tests needed to find the exact floor from which if the device is dropped, it will break.\n\nThe problem assumes the worst-case scenario, where the outcome of each test is the least favorable, thus requiring the maximum number of tests.\n\nExample:\n>>> max_drop_test_height(3)\n2\n>>> max_drop_test_height(10)\n4",
      "sq": "Shkruani një funksion ruby `def max_drop_test_height(n)` për të zgjidhur problemin e mëposhtëm:\nPërcakton numrin maksimal të testeve të rënies të nevojshme për të gjetur lartësinë e tolerancës së rënies së një pajisjeje nga një ndërtesë me një lartësi të dhënë.\nFunksioni merr një argument të vetëm, n, i cili është lartësia e ndërtesës (numri i kateve).\nKthen numrin maksimal të testeve të nevojshme për të gjetur katin e saktë nga i cili, nëse pajisja bie, do të thyhet.\n\nProblemi supozon skenarin më të keq, ku rezultati i çdo testi është më pak i favorshëm, duke kërkuar kështu numrin maksimal të testeve.\n\nShembull:\n>>> max_drop_test_height(3)\n2\n>>> max_drop_test_height(10)\n4",
      "hy": "Գրեք ruby ֆունկցիա `def max_drop_test_height(n)` հետևյալ խնդիրը լուծելու համար:\nՈրոշում է առավելագույն թեստերի քանակը, որոնք անհրաժեշտ են սարքի անկման դիմացկունության բարձրությունը գտնելու համար շենքի տրված բարձրությունից:\nՖունկցիան ընդունում է մեկ արգումենտ, n, որը շենքի բարձրությունն է (հարկերի քանակը):\nԱյն վերադարձնում է առավելագույն թեստերի քանակը, որոնք անհրաժեշտ են ճշգրիտ հարկը գտնելու համար, որից եթե սարքը գցվի, այն կկոտրվի:\n\nԽնդիրը ենթադրում է ամենավատ սցենարը, որտեղ յուրաքանչյուր թեստի արդյունքը ամենաանբարենպաստն է, այսպիսով պահանջելով առավելագույն թեստերի քանակը:\n\nՕրինակ:\n>>> max_drop_test_height(3)\n2\n>>> max_drop_test_height(10)\n4",
      "bn": "রুবি ফাংশন `def max_drop_test_height(n)` লিখুন নিম্নলিখিত সমস্যার সমাধানের জন্য:\nএকটি বিল্ডিংয়ের একটি নির্দিষ্ট উচ্চতা থেকে একটি ডিভাইসের ড্রপ সহনশীলতা উচ্চতা খুঁজে বের করার জন্য প্রয়োজনীয় সর্বাধিক ড্রপ পরীক্ষার সংখ্যা নির্ধারণ করে।\nফাংশনটি একটি একক আর্গুমেন্ট গ্রহণ করে, n, যা বিল্ডিংয়ের উচ্চতা (তলার সংখ্যা)।\nএটি প্রয়োজনীয় সর্বাধিক পরীক্ষার সংখ্যা ফেরত দেয় যাতে সঠিক তলা খুঁজে পাওয়া যায় যেখান থেকে ডিভাইসটি ফেলে দিলে ভেঙে যাবে।\n\nসমস্যাটি সবচেয়ে খারাপ পরিস্থিতি ধরে নেয়, যেখানে প্রতিটি পরীক্ষার ফলাফল সবচেয়ে অনুকূল নয়, ফলে সর্বাধিক সংখ্যক পরীক্ষার প্রয়োজন হয়।\n\nউদাহরণ:\n>>> max_drop_test_height(3)\n2\n>>> max_drop_test_height(10)\n4",
      "bg": "Напишете Ruby функция `def max_drop_test_height(n)`, за да решите следния проблем:\nОпределя максималния брой тестове на изпускане, необходими за намиране на височината на толерантност на изпускане на устройство от сграда с дадена височина.\nФункцията приема един аргумент, n, който е височината на сградата (брой етажи).\nТя връща максималния брой тестове, необходими за намиране на точния етаж, от който ако устройството бъде изпуснато, ще се счупи.\n\nПроблемът предполага най-лошия сценарий, при който резултатът от всеки тест е най-неблагоприятен, което изисква максималния брой тестове.\n\nПример:\n>>> max_drop_test_height(3)\n2\n>>> max_drop_test_height(10)\n4",
      "zh": "编写一个 ruby 函数 `def max_drop_test_height(n)` 来解决以下问题：\n确定需要进行的最大掉落测试次数，以找出设备从给定高度的建筑物掉落的耐受高度。\n该函数接受一个参数 n，即建筑物的高度（楼层数）。\n它返回找到确切楼层所需的最大测试次数，从该楼层掉落设备将会损坏。\n\n该问题假设最坏情况，每次测试的结果都是最不利的，因此需要最大次数的测试。\n\n示例：\n>>> max_drop_test_height(3)\n2\n>>> max_drop_test_height(10)\n4",
      "fr": "Écrire une fonction ruby `def max_drop_test_height(n)` pour résoudre le problème suivant :\nDétermine le nombre maximum de tests de chute nécessaires pour trouver la hauteur de tolérance de chute d'un appareil depuis un bâtiment d'une hauteur donnée.\nLa fonction prend un seul argument, n, qui est la hauteur du bâtiment (nombre d'étages).\nElle retourne le nombre maximum de tests nécessaires pour trouver l'étage exact à partir duquel, si l'appareil est lâché, il se cassera.\n\nLe problème suppose le pire des cas, où le résultat de chaque test est le moins favorable, nécessitant ainsi le nombre maximum de tests.\n\nExemple :\n>>> max_drop_test_height(3)\n2\n>>> max_drop_test_height(10)\n4",
      "de": "Schreiben Sie eine Ruby-Funktion `def max_drop_test_height(n)`, um das folgende Problem zu lösen:\nBestimmt die maximale Anzahl von Falltests, die erforderlich sind, um die Falltoleranzhöhe eines Geräts von einem Gebäude mit einer gegebenen Höhe zu ermitteln.\nDie Funktion nimmt ein einzelnes Argument n, das die Höhe des Gebäudes (Anzahl der Stockwerke) ist.\nSie gibt die maximale Anzahl von Tests zurück, die erforderlich sind, um das genaue Stockwerk zu finden, von dem aus, wenn das Gerät fallen gelassen wird, es kaputt geht.\n\nDas Problem geht vom schlimmsten Fall aus, bei dem das Ergebnis jedes Tests am ungünstigsten ist, was die maximale Anzahl von Tests erfordert.\n\nBeispiel:\n>>> max_drop_test_height(3)\n2\n>>> max_drop_test_height(10)\n4",
      "ha": "Rubuta aikin ruby `def max_drop_test_height(n)` don warware matsalar mai zuwa:\nYana tantance yawan gwaje-gwajen sauke na'ura da ake bukata don gano tsayin jure sauke na'ura daga gini mai tsayin da aka bayar.\nAikin yana karɓar hujja guda, n, wanda shine tsayin ginin (yawan bene).\nYana dawowa da yawan gwaje-gwajen da ake bukata don gano ainihin bene daga wanda idan aka sauke na'urar, za ta karye.\n\nMatsalar tana ɗauka yanayin mafi muni, inda sakamakon kowanne gwaji shine mafi rashin jin daɗi, don haka yana buƙatar yawan gwaje-gwaje.\n\nMisali:\n>>> max_drop_test_height(3)\n2\n>>> max_drop_test_height(10)\n4",
      "hi": "`def max_drop_test_height(n)` नामक एक रूबी फ़ंक्शन लिखें ताकि निम्नलिखित समस्या का समाधान किया जा सके:\nयह निर्धारित करता है कि किसी उपकरण की ड्रॉप सहनशीलता ऊँचाई को खोजने के लिए अधिकतम कितने ड्रॉप परीक्षणों की आवश्यकता होगी जब उसे एक निश्चित ऊँचाई वाली इमारत से गिराया जाता है।\nफ़ंक्शन एक एकल तर्क n लेता है, जो इमारत की ऊँचाई (मंजिलों की संख्या) है।\nयह उन परीक्षणों की अधिकतम संख्या लौटाता है जो यह पता लगाने के लिए आवश्यक हैं कि किस मंजिल से उपकरण गिराने पर वह टूट जाएगा।\n\nसमस्या सबसे खराब स्थिति मानती है, जहाँ प्रत्येक परीक्षण का परिणाम सबसे कम अनुकूल होता है, इस प्रकार अधिकतम संख्या में परीक्षणों की आवश्यकता होती है।\n\nउदाहरण:\n>>> max_drop_test_height(3)\n2\n>>> max_drop_test_height(10)\n4",
      "hu": "Írj egy ruby függvényt `def max_drop_test_height(n)` a következő probléma megoldására:\nMeghatározza a maximális számú ejtési tesztet, amely szükséges ahhoz, hogy megtaláljuk egy eszköz ejtési tűréshatárának magasságát egy adott magasságú épületből.\nA függvény egyetlen argumentumot vesz fel, n, amely az épület magassága (emeletek száma).\nVisszaadja a szükséges maximális tesztek számát, hogy megtaláljuk azt a pontos emeletet, ahonnan ha az eszközt leejtjük, az eltörik.\n\nA probléma a legrosszabb forgatókönyvet feltételezi, ahol minden teszt kimenetele a legkedvezőtlenebb, így a maximális számú teszt szükséges.\n\nPélda:\n>>> max_drop_test_height(3)\n2\n>>> max_drop_test_height(10)\n4"
    },
    "instruction_bertscore": {
      "sq": "0.981365292172831",
      "hy": "0.9710446562046392",
      "bn": "0.9510445631382363",
      "bg": "0.9832437396862779",
      "zh": "0.9451132613301535",
      "fr": "0.9864138805675947",
      "de": "0.9850022144495797",
      "ha": "0.96178589825346",
      "hi": "0.9478619085429143",
      "hu": "0.9820571217899754"
    },
    "level": "middle",
    "test": "raise 'Test failed' unless max_drop_test_height(3) == 2\nraise 'Test failed' unless max_drop_test_height(10) == 4\nraise 'Test failed' unless max_drop_test_height(15) == 5\nraise 'Test failed' unless max_drop_test_height(6) == 3\nraise 'Test failed' unless max_drop_test_height(100) == 9\n\n\nputs 'All tests passed!'",
    "entry_point": "max_drop_test_height",
    "signature": "def max_drop_test_height(n)",
    "docstring": {
      "en": "Determines the maximum number of drop tests needed to find the drop tolerance height of a device from a building with a given height.\nThe function takes a single argument, n, which is the height of the building (number of floors).\nIt returns the maximum number of tests needed to find the exact floor from which if the device is dropped, it will break.\n\nThe problem assumes the worst-case scenario, where the outcome of each test is the least favorable, thus requiring the maximum number of tests.\n\nExample:\n>>> max_drop_test_height(3)\n2\n>>> max_drop_test_height(10)\n4",
      "sq": "Përcakton numrin maksimal të testeve të hedhjes të nevojshme për të gjetur lartësinë e tolerancës së hedhjes së një pajisjeje nga një ndërtesë me një lartësi të dhënë.\nFunksioni merr një argument të vetëm, n, që është lartësia e ndërtesës (numri i kateve).\nKthen numrin maksimal të testeve të nevojshme për të gjetur katin e saktë nga i cili, nëse pajisja hidhet, do të thyhet.\n\nProblemi supozon skenarin më të keq, ku rezultati i çdo testi është më pak i favorshëm, duke kërkuar kështu numrin maksimal të testeve.\n\nShembull:\n>>> max_drop_test_height(3)\n2\n>>> max_drop_test_height(10)\n4",
      "hy": "Սահմանում է սարքի ընկնելու դիմացկունության բարձրությունը գտնելու համար անհրաժեշտ առավելագույն փորձարկումների քանակը՝ հաշվի առնելով շենքի տրված բարձրությունը:\nՖունկցիան ընդունում է մեկ արգումենտ՝ n, որը շենքի բարձրությունն է (հարկերի քանակը):\nԱյն վերադարձնում է անհրաժեշտ փորձարկումների առավելագույն քանակը՝ ճշգրիտ հարկը գտնելու համար, որից եթե սարքը ընկնի, այն կկոտրվի:\n\nԽնդիրը ենթադրում է ամենավատ սցենարը, որտեղ յուրաքանչյուր փորձարկման արդյունքը ամենաանբարենպաստն է, այդպիսով պահանջելով փորձարկումների առավելագույն քանակը:\n\nՕրինակ:\n>>> max_drop_test_height(3)\n2\n>>> max_drop_test_height(10)\n4",
      "bn": "একটি ভবনের প্রদত্ত উচ্চতা থেকে একটি ডিভাইসের ড্রপ সহনশীলতা উচ্চতা খুঁজে বের করতে প্রয়োজনীয় সর্বাধিক ড্রপ পরীক্ষার সংখ্যা নির্ধারণ করে।\nফাংশনটি একটি একক আর্গুমেন্ট গ্রহণ করে, n, যা ভবনের উচ্চতা (তলার সংখ্যা)।\nএটি প্রয়োজনীয় সর্বাধিক পরীক্ষার সংখ্যা ফেরত দেয় যাতে সঠিক তলা খুঁজে বের করা যায় যেখান থেকে ডিভাইসটি ফেলে দিলে এটি ভেঙে যাবে।\n\nসমস্যাটি সবচেয়ে খারাপ পরিস্থিতি অনুমান করে, যেখানে প্রতিটি পরীক্ষার ফলাফল সবচেয়ে কম অনুকূল, ফলে সর্বাধিক সংখ্যক পরীক্ষার প্রয়োজন হয়।\n\nউদাহরণ:\n>>> max_drop_test_height(3)\n2\n>>> max_drop_test_height(10)\n4",
      "bg": "Определя максималния брой тестове за изпускане, необходими за намиране на височината на толерантност при изпускане на устройство от сграда с дадена височина. \nФункцията приема един аргумент, n, който е височината на сградата (брой етажи). \nТя връща максималния брой тестове, необходими за намиране на точния етаж, от който ако устройството бъде изпуснато, ще се счупи.\n\nПроблемът предполага най-лошия сценарий, при който резултатът от всеки тест е най-неблагоприятен, изисквайки максималния брой тестове.\n\nПример:\n>>> max_drop_test_height(3)\n2\n>>> max_drop_test_height(10)\n4",
      "zh": "确定需要进行的最大跌落测试次数，以找出设备从给定高度的建筑物跌落时的耐受高度。\n该函数接受一个参数 n，即建筑物的高度（楼层数）。\n它返回找到确切楼层所需的最大测试次数，从该楼层跌落设备将会损坏。\n\n该问题假设最坏情况，即每次测试的结果都是最不利的，因此需要最大数量的测试。\n\n示例：\n>>> max_drop_test_height(3)\n2\n>>> max_drop_test_height(10)\n4",
      "fr": "Détermine le nombre maximum de tests de chute nécessaires pour trouver la hauteur de tolérance de chute d'un appareil depuis un bâtiment d'une hauteur donnée.  \nLa fonction prend un seul argument, n, qui est la hauteur du bâtiment (nombre d'étages).  \nElle renvoie le nombre maximum de tests nécessaires pour trouver l'étage exact à partir duquel, si l'appareil est lâché, il se cassera.  \n\nLe problème suppose le pire des cas, où le résultat de chaque test est le moins favorable, nécessitant ainsi le nombre maximum de tests.  \n\nExemple :  \n>>> max_drop_test_height(3)  \n2  \n>>> max_drop_test_height(10)  \n4  ",
      "de": "Bestimmt die maximale Anzahl an Falltests, die benötigt werden, um die Falltoleranzhöhe eines Geräts von einem Gebäude mit einer gegebenen Höhe zu finden. Die Funktion nimmt ein einzelnes Argument, n, das die Höhe des Gebäudes (Anzahl der Stockwerke) ist. Sie gibt die maximale Anzahl an Tests zurück, die benötigt werden, um das genaue Stockwerk zu finden, von dem aus das Gerät, wenn es fallen gelassen wird, kaputt geht.\n\nDas Problem geht vom schlimmsten Fall aus, bei dem das Ergebnis jedes Tests am ungünstigsten ist, was die maximale Anzahl an Tests erfordert.\n\nBeispiel:\n>>> max_drop_test_height(3)\n2\n>>> max_drop_test_height(10)\n4",
      "ha": "Yana tantance yawan gwaje-gwajen da ake bukata don gano tsayin jurewa na'ura daga gini mai tsayi da aka bayar.\nAiki yana karɓar hujja guda ɗaya, n, wanda shine tsayin ginin (yawan bene).\nYana dawowa da yawan gwaje-gwaje da ake bukata don gano ainihin benen da idan aka jefa na'urar, za ta karye.\n\nMatsalar tana ɗauka yanayin mafi muni, inda sakamakon kowanne gwaji shine mafi rashin jin daɗi, don haka yana buƙatar yawan gwaje-gwaje.\n\nMisali:\n>>> max_drop_test_height(3)\n2\n>>> max_drop_test_height(10)\n4",
      "hi": "निर्धारित करता है कि किसी इमारत की दी गई ऊँचाई से एक उपकरण की गिरावट सहनशीलता ऊँचाई खोजने के लिए अधिकतम कितने ड्रॉप परीक्षणों की आवश्यकता होगी। \nयह फ़ंक्शन एकल तर्क n लेता है, जो इमारत की ऊँचाई (मंजिलों की संख्या) है। \nयह यह बताने के लिए अधिकतम परीक्षणों की संख्या लौटाता है कि किस सटीक मंजिल से यदि उपकरण गिराया जाता है, तो वह टूट जाएगा।\n\nसमस्या सबसे खराब स्थिति मानती है, जहाँ प्रत्येक परीक्षण का परिणाम सबसे कम अनुकूल होता है, इस प्रकार अधिकतम परीक्षणों की आवश्यकता होती है।\n\nउदाहरण:\n>>> max_drop_test_height(3)\n2\n>>> max_drop_test_height(10)\n4",
      "hu": "Meghatározza a maximális számú ejtési tesztet, amely szükséges ahhoz, hogy megtaláljuk egy eszköz ejtési tűrésmagasságát egy adott magasságú épületből.\nA függvény egyetlen argumentumot vesz fel, n, amely az épület magassága (emeletek száma).\nVisszaadja a szükséges maximális tesztek számát annak érdekében, hogy megtaláljuk azt a pontos emeletet, ahonnan az eszközt leejtve az eltörik.\n\nA probléma a legrosszabb forgatókönyvet feltételezi, ahol minden teszt kimenetele a legkevésbé kedvező, így a maximális számú teszt szükséges.\n\nPélda:\n>>> max_drop_test_height(3)\n2\n>>> max_drop_test_height(10)\n4"
    },
    "docstring_bertscore": {
      "sq": "0.9842003436013419",
      "hy": "0.9551240339039309",
      "bn": "0.9570813376786486",
      "bg": "0.9847471730403309",
      "zh": "0.936900888226266",
      "fr": "0.9837689184137342",
      "de": "0.9786982820466755",
      "ha": "0.9534289222321791",
      "hi": "0.9731457683752263",
      "hu": "0.9715398417445591"
    }
  },
  {
    "task_id": "Ruby/16",
    "prompt": {
      "en": "# Computes the repeated sum of digits of a given number string until it reduces to a single digit.\n# The function takes a single argument, `input_string`, which is a string representing a non-negative number.\n# It repeatedly sums the digits of the number until the sum is a single digit, then returns this single digit.\n#\n# Example:\n# >>> digit_sum_to_single(\"35379\")\n# 9\n# >>> digit_sum_to_single(\"24815\")\n# 3\n\n\ndef digit_sum_to_single(input_string)",
      "sq": "# Llogarit shumën e përsëritur të shifrave të një vargu numrash të dhënë derisa të reduktohet në një shifër të vetme.\n# Funksioni merr një argument të vetëm, `input_string`, i cili është një varg që përfaqëson një numër jo-negativ.\n# Ai përsëritësisht mbledh shifrat e numrit derisa shuma të jetë një shifër e vetme, pastaj kthen këtë shifër të vetme.\n#\n# Shembull:\n# >>> digit_sum_to_single(\"35379\")\n# 9\n# >>> digit_sum_to_single(\"24815\")\n# 3\n\n\ndef digit_sum_to_single(input_string)",
      "hy": "# Հաշվում է տրված թվային տողի թվանշանների կրկնվող գումարը, մինչև այն կրճատվի մեկ թվանշանի:\n# Ֆունկցիան ընդունում է մեկ արգումենտ՝ `input_string`, որը ներկայացնում է ոչ բացասական թիվ:\n# Այն կրկնվող կերպով գումարում է թվանշանները, մինչև գումարը դառնա մեկ թվանշան, ապա վերադարձնում է այդ մեկ թվանշանը:\n#\n# Օրինակ:\n# >>> digit_sum_to_single(\"35379\")\n# 9\n# >>> digit_sum_to_single(\"24815\")\n# 3\n\n\ndef digit_sum_to_single(input_string)",
      "bn": "# একটি প্রদত্ত সংখ্যা স্ট্রিংয়ের অঙ্কগুলির পুনরাবৃত্ত যোগফল গণনা করে যতক্ষণ না এটি একটি একক অঙ্কে হ্রাস পায়।\n# ফাংশনটি একটি একক আর্গুমেন্ট গ্রহণ করে, `input_string`, যা একটি অ-ঋণাত্মক সংখ্যাকে উপস্থাপন করে এমন একটি স্ট্রিং।\n# এটি সংখ্যার অঙ্কগুলির যোগফল বারবার করে যতক্ষণ না যোগফলটি একটি একক অঙ্ক হয়, তারপর এই একক অঙ্কটি ফেরত দেয়।\n#\n# উদাহরণ:\n# >>> digit_sum_to_single(\"35379\")\n# 9\n# >>> digit_sum_to_single(\"24815\")\n# 3\n\n\ndef digit_sum_to_single(input_string)",
      "bg": "# Изчислява повторяемата сума на цифрите на даден низ от числа, докато се намали до една цифра.\n# Функцията приема един аргумент, `input_string`, който е низ, представляващ неотрицателно число.\n# Тя многократно сумира цифрите на числото, докато сумата стане едноцифрена, след което връща тази едноцифрена стойност.\n#\n# Пример:\n# >>> digit_sum_to_single(\"35379\")\n# 9\n# >>> digit_sum_to_single(\"24815\")\n# 3\n\n\ndef digit_sum_to_single(input_string)",
      "zh": "# 计算给定数字字符串的重复数字和，直到其简化为单个数字。\n# 该函数接受一个参数 `input_string`，这是一个表示非负数的字符串。\n# 它重复地对数字的各位数求和，直到和为单个数字，然后返回这个单个数字。\n#\n# 示例:\n# >>> digit_sum_to_single(\"35379\")\n# 9\n# >>> digit_sum_to_single(\"24815\")\n# 3\n\n\ndef digit_sum_to_single(input_string)",
      "fr": "# Calcule la somme répétée des chiffres d'une chaîne de nombres donnée jusqu'à ce qu'elle se réduise à un seul chiffre.\n# La fonction prend un seul argument, `input_string`, qui est une chaîne représentant un nombre non négatif.\n# Elle additionne de manière répétée les chiffres du nombre jusqu'à ce que la somme soit un seul chiffre, puis retourne ce chiffre unique.\n#\n# Exemple:\n# >>> digit_sum_to_single(\"35379\")\n# 9\n# >>> digit_sum_to_single(\"24815\")\n# 3\n\n\ndef digit_sum_to_single(input_string)",
      "de": "# Berechnet die wiederholte Summe der Ziffern einer gegebenen Zahlenkette, bis sie auf eine einzelne Ziffer reduziert ist.\n# Die Funktion nimmt ein einzelnes Argument, `input_string`, das eine Zeichenkette darstellt, die eine nicht-negative Zahl repräsentiert.\n# Sie summiert wiederholt die Ziffern der Zahl, bis die Summe eine einzelne Ziffer ist, und gibt dann diese einzelne Ziffer zurück.\n#\n# Beispiel:\n# >>> digit_sum_to_single(\"35379\")\n# 9\n# >>> digit_sum_to_single(\"24815\")\n# 3\n\n\ndef digit_sum_to_single(input_string)",
      "ha": "# Lissafin jimillar lambobi da aka maimaita na wani baƙaƙen lamba har sai ya ragu zuwa lamba guda.\n# Aikin yana ɗaukar hujja guda, `input_string`, wanda shine baƙaƙen lamba da ke wakiltar lamba mara kyau.\n# Yana maimaita jimillar lambobin har sai jimillar ta zama lamba guda, sannan yana dawowa da wannan lamba guda.\n#\n# Misali:\n# >>> digit_sum_to_single(\"35379\")\n# 9\n# >>> digit_sum_to_single(\"24815\")\n# 3\n\n\ndef digit_sum_to_single(input_string)",
      "hi": "# एक दिए गए संख्या स्ट्रिंग के अंकों के पुनरावृत्त योग की गणना करता है जब तक कि यह एकल अंक तक नहीं सिमट जाता।\n# फ़ंक्शन एकल तर्क लेता है, `input_string`, जो एक स्ट्रिंग है जो एक गैर-ऋणात्मक संख्या का प्रतिनिधित्व करता है।\n# यह संख्या के अंकों का बार-बार योग करता है जब तक कि योग एकल अंक न हो जाए, फिर इस एकल अंक को लौटाता है।\n#\n# उदाहरण:\n# >>> digit_sum_to_single(\"35379\")\n# 9\n# >>> digit_sum_to_single(\"24815\")\n# 3\n\n\ndef digit_sum_to_single(input_string)",
      "hu": "# Számolja ki egy adott számjegyű sztring ismételt számjegyösszegét, amíg az egyetlen számjegyre nem csökken.\n# A függvény egyetlen argumentumot vesz fel, `input_string`, amely egy nem negatív számot reprezentáló sztring.\n# Ismételten összeadja a számjegyeket, amíg az összeg egyetlen számjegy nem lesz, majd visszaadja ezt az egyetlen számjegyet.\n#\n# Példa:\n# >>> digit_sum_to_single(\"35379\")\n# 9\n# >>> digit_sum_to_single(\"24815\")\n# 3\n\n\ndef digit_sum_to_single(input_string)"
    },
    "prompt_bertscore": {
      "sq": "0.9787429738824084",
      "hy": "0.9602588278840637",
      "bn": "0.9900714604039711",
      "bg": "0.9660292390835082",
      "zh": "0.9661889379098603",
      "fr": "0.9790913715707436",
      "de": "0.9747765238035226",
      "ha": "0.9553639794042209",
      "hi": "0.9918893256512024",
      "hu": "0.9678246590976826"
    },
    "canonical_solution": "    sum = input_string.chars.map(&:to_i).sum\n    while sum > 9\n      sum = sum.to_s.chars.map(&:to_i).sum\n    end\n    sum\n  end",
    "instruction": {
      "en": "Write a ruby function `def digit_sum_to_single(input_string)` to solve the following problem:\nComputes the repeated sum of digits of a given number string until it reduces to a single digit.\nThe function takes a single argument, `input_string`, which is a string representing a non-negative number.\nIt repeatedly sums the digits of the number until the sum is a single digit, then returns this single digit.\n\nExample:\n>>> digit_sum_to_single(\"35379\")\n9\n>>> digit_sum_to_single(\"24815\")\n3",
      "sq": "Shkruani një funksion ruby `def digit_sum_to_single(input_string)` për të zgjidhur problemin e mëposhtëm:\nLlogarit shumën e përsëritur të shifrave të një vargu numrash të dhënë derisa të reduktohet në një shifër të vetme.\nFunksioni merr një argument të vetëm, `input_string`, i cili është një varg që përfaqëson një numër jo-negativ.\nAi përsëritet duke mbledhur shifrat e numrit derisa shuma të jetë një shifër e vetme, pastaj kthen këtë shifër të vetme.\n\nShembull:\n>>> digit_sum_to_single(\"35379\")\n9\n>>> digit_sum_to_single(\"24815\")\n3",
      "hy": "Գրեք ruby ֆունկցիա `def digit_sum_to_single(input_string)`՝ լուծելու հետևյալ խնդիրը:\nՀաշվում է տրված թվային տողի թվանշանների կրկնվող գումարը, մինչև այն կրճատվի մեկ թվանշանի:\nՖունկցիան ընդունում է մեկ արգումենտ՝ `input_string`, որը ներկայացնում է ոչ բացասական թիվ:\nԱյն կրկնվող կերպով գումարում է թվի թվանշանները, մինչև գումարը դառնա մեկ թվանշան, ապա վերադարձնում է այդ մեկ թվանշանը:\n\nՕրինակ:\n>>> digit_sum_to_single(\"35379\")\n9\n>>> digit_sum_to_single(\"24815\")\n3",
      "bn": "একটি রুবি ফাংশন `def digit_sum_to_single(input_string)` লিখুন নিম্নলিখিত সমস্যার সমাধানের জন্য:\nএকটি প্রদত্ত সংখ্যা স্ট্রিং এর অঙ্কগুলির পুনরাবৃত্ত যোগফল গণনা করে যতক্ষণ না এটি একটি একক অঙ্কে হ্রাস পায়।\nফাংশনটি একটি একক আর্গুমেন্ট গ্রহণ করে, `input_string`, যা একটি অ-ঋণাত্মক সংখ্যাকে উপস্থাপন করে এমন একটি স্ট্রিং।\nএটি সংখ্যার অঙ্কগুলির যোগফল বারবার করে যতক্ষণ না যোগফলটি একটি একক অঙ্ক হয়, তারপর এই একক অঙ্কটি ফেরত দেয়।\n\nউদাহরণ:\n>>> digit_sum_to_single(\"35379\")\n9\n>>> digit_sum_to_single(\"24815\")\n3",
      "bg": "Напишете функция на Ruby `def digit_sum_to_single(input_string)`, за да решите следния проблем:\nИзчислява повтарящата се сума на цифрите на даден низ от числа, докато се сведе до една цифра.\nФункцията приема един аргумент, `input_string`, който е низ, представляващ неотрицателно число.\nТя многократно събира цифрите на числото, докато сумата стане едноцифрено число, след което връща тази една цифра.\n\nПример:\n>>> digit_sum_to_single(\"35379\")\n9\n>>> digit_sum_to_single(\"24815\")\n3",
      "zh": "编写一个 ruby 函数 `def digit_sum_to_single(input_string)` 来解决以下问题：\n计算给定数字字符串的重复数字和，直到其减少到一位数字。\n该函数接受一个参数 `input_string`，它是一个表示非负数的字符串。\n它重复对数字的各位数字求和，直到和为一位数字，然后返回这个一位数字。\n\n示例：\n>>> digit_sum_to_single(\"35379\")\n9\n>>> digit_sum_to_single(\"24815\")\n3",
      "fr": "Écrire une fonction ruby `def digit_sum_to_single(input_string)` pour résoudre le problème suivant :\nCalcule la somme répétée des chiffres d'une chaîne de nombre donnée jusqu'à ce qu'elle se réduise à un seul chiffre.\nLa fonction prend un seul argument, `input_string`, qui est une chaîne représentant un nombre non négatif.\nElle additionne de manière répétée les chiffres du nombre jusqu'à ce que la somme soit un seul chiffre, puis retourne ce chiffre unique.\n\nExemple :\n>>> digit_sum_to_single(\"35379\")\n9\n>>> digit_sum_to_single(\"24815\")\n3",
      "de": "Schreiben Sie eine Ruby-Funktion `def digit_sum_to_single(input_string)`, um das folgende Problem zu lösen:\nBerechnet die wiederholte Summe der Ziffern einer gegebenen Zahlenzeichenkette, bis sie auf eine einzelne Ziffer reduziert ist.\nDie Funktion nimmt ein einzelnes Argument, `input_string`, das eine Zeichenkette ist, die eine nicht-negative Zahl darstellt.\nSie summiert wiederholt die Ziffern der Zahl, bis die Summe eine einzelne Ziffer ist, und gibt dann diese einzelne Ziffer zurück.\n\nBeispiel:\n>>> digit_sum_to_single(\"35379\")\n9\n>>> digit_sum_to_single(\"24815\")\n3",
      "ha": "Rubuta aikin ruby `def digit_sum_to_single(input_string)` don warware matsalar mai zuwa:\nLissafa jimillar lambobi na lamba da aka bayar har sai ta ragu zuwa lamba guda.\nAikin yana ɗaukar hujja guda, `input_string`, wanda shine rubutu mai wakiltar lamba mara kyau.\nYana maimaita jimillar lambobin har sai jimillar ta zama lamba guda, sannan ya dawo da wannan lamba guda.\n\nMisali:\n>>> digit_sum_to_single(\"35379\")\n9\n>>> digit_sum_to_single(\"24815\")\n3",
      "hi": "रूबी फ़ंक्शन `def digit_sum_to_single(input_string)` लिखें ताकि निम्नलिखित समस्या का समाधान किया जा सके:\nदिए गए संख्या स्ट्रिंग के अंकों के बार-बार योग की गणना करता है जब तक कि यह एकल अंक तक कम न हो जाए।\nयह फ़ंक्शन एक एकल तर्क लेता है, `input_string`, जो एक गैर-ऋणात्मक संख्या का प्रतिनिधित्व करने वाली स्ट्रिंग है।\nयह संख्या के अंकों का बार-बार योग करता है जब तक कि योग एकल अंक न हो जाए, फिर इस एकल अंक को लौटाता है।\n\nउदाहरण:\n>>> digit_sum_to_single(\"35379\")\n9\n>>> digit_sum_to_single(\"24815\")\n3",
      "hu": "Készíts egy ruby függvényt `def digit_sum_to_single(input_string)` a következő probléma megoldására:\nKiszámítja egy adott számsorozat számjegyeinek ismételt összegét, amíg az egyetlen számjegyre csökken.\nA függvény egyetlen argumentumot vesz fel, `input_string`, amely egy nem-negatív számot reprezentáló karakterlánc.\nIsmételten összegzi a szám számjegyeit, amíg az összeg egyetlen számjegy lesz, majd visszaadja ezt az egyetlen számjegyet.\n\nPélda:\n>>> digit_sum_to_single(\"35379\")\n9\n>>> digit_sum_to_single(\"24815\")\n3"
    },
    "instruction_bertscore": {
      "sq": "0.968822975392764",
      "hy": "0.9714204648855572",
      "bn": "0.9888806712696669",
      "bg": "0.9561330762395881",
      "zh": "0.977551588856961",
      "fr": "0.9847878922684431",
      "de": "0.9797984957272278",
      "ha": "0.9711443686559187",
      "hi": "0.9847120154628878",
      "hu": "0.9790067550284227"
    },
    "level": "easy",
    "test": "raise 'Test failed' unless digit_sum_to_single(\"35379\") == 9\nraise 'Test failed' unless digit_sum_to_single(\"24815\") == 2\nraise 'Test failed' unless digit_sum_to_single(\"9999\") == 9\nraise 'Test failed' unless digit_sum_to_single(\"12345\") == 6\nraise 'Test failed' unless digit_sum_to_single(\"0\") == 0\n  \n\nputs 'All tests passed!'",
    "entry_point": "digit_sum_to_single",
    "signature": "def digit_sum_to_single(input_string)",
    "docstring": {
      "en": "Computes the repeated sum of digits of a given number string until it reduces to a single digit.\nThe function takes a single argument, `input_string`, which is a string representing a non-negative number.\nIt repeatedly sums the digits of the number until the sum is a single digit, then returns this single digit.\n\nExample:\n>>> digit_sum_to_single(\"35379\")\n9\n>>> digit_sum_to_single(\"24815\")\n3",
      "sq": "Llogarit shumën e përsëritur të shifrave të një vargu numrash të dhënë derisa të reduktohet në një shifër të vetme. Funksioni merr një argument të vetëm, `input_string`, i cili është një varg që përfaqëson një numër jo-negativ. Ai përsëritësisht mbledh shifrat e numrit derisa shuma të jetë një shifër e vetme, pastaj kthen këtë shifër të vetme.\n\nShembull:\n>>> digit_sum_to_single(\"35379\")\n9\n>>> digit_sum_to_single(\"24815\")\n3",
      "hy": "Հաշվում է տրված թվային տողի թվանշանների կրկնվող գումարը, մինչև այն կրճատվի մեկ թվանշանի:\nՖունկցիան ընդունում է մեկ արգումենտ՝ `input_string`, որը տող է, որը ներկայացնում է ոչ բացասական թիվ:\nԱյն կրկնվող կերպով գումարում է թվանշանները, մինչև գումարը դառնա մեկ թվանշան, ապա վերադարձնում է այդ մեկ թվանշանը:\n\nՕրինակ:\n>>> digit_sum_to_single(\"35379\")\n9\n>>> digit_sum_to_single(\"24815\")\n3",
      "bn": "একটি প্রদত্ত সংখ্যা স্ট্রিংয়ের অঙ্কগুলির পুনরাবৃত্ত যোগফল গণনা করে যতক্ষণ না এটি একটি একক অঙ্কে হ্রাস পায়। ফাংশনটি একটি একক আর্গুমেন্ট গ্রহণ করে, `input_string`, যা একটি স্ট্রিং যা একটি অ-ঋণাত্মক সংখ্যা উপস্থাপন করে। এটি সংখ্যার অঙ্কগুলির যোগফল বারবার গণনা করে যতক্ষণ না যোগফল একটি একক অঙ্ক হয়, তারপর এই একক অঙ্কটি ফেরত দেয়।\n\nউদাহরণ:\n>>> digit_sum_to_single(\"35379\")\n9\n>>> digit_sum_to_single(\"24815\")\n3",
      "bg": "Изчислява повтарящата се сума на цифрите на даден низ от числа, докато не се намали до една цифра.\nФункцията приема един аргумент, `input_string`, който е низ, представляващ неотрицателно число.\nТя многократно събира цифрите на числото, докато сумата стане една цифра, след което връща тази една цифра.\n\nПример:\n>>> digit_sum_to_single(\"35379\")\n9\n>>> digit_sum_to_single(\"24815\")\n3",
      "zh": "计算给定数字字符串的重复数字和，直到其简化为单个数字。\n该函数接受一个参数，`input_string`，这是一个表示非负数的字符串。\n它反复对数字的各位求和，直到和为单个数字，然后返回这个单个数字。\n\n示例：\n>>> digit_sum_to_single(\"35379\")\n9\n>>> digit_sum_to_single(\"24815\")\n3",
      "fr": "Calcule la somme répétée des chiffres d'une chaîne de nombres donnée jusqu'à ce qu'elle se réduise à un seul chiffre.  \nLa fonction prend un seul argument, `input_string`, qui est une chaîne représentant un nombre non négatif.  \nElle additionne de manière répétée les chiffres du nombre jusqu'à ce que la somme soit un seul chiffre, puis retourne ce chiffre unique.\n\nExemple :\n>>> digit_sum_to_single(\"35379\")\n9\n>>> digit_sum_to_single(\"24815\")\n3",
      "de": "Berechnet die wiederholte Summe der Ziffern einer gegebenen Zahlenzeichenkette, bis sie auf eine einzelne Ziffer reduziert ist.  \nDie Funktion nimmt ein einzelnes Argument, `input_string`, das eine Zeichenkette darstellt, die eine nicht-negative Zahl repräsentiert.  \nSie summiert wiederholt die Ziffern der Zahl, bis die Summe eine einzelne Ziffer ist, und gibt dann diese einzelne Ziffer zurück.\n\nBeispiel:\n>>> digit_sum_to_single(\"35379\")\n9\n>>> digit_sum_to_single(\"24815\")\n3",
      "ha": "Yana lissafin jimillar lambobi da aka maimaita na wata takamaiman lamba har sai ya ragu zuwa lamba guda.\n\nAikin yana daukar hujja guda, `input_string`, wanda yake wakiltar wata lamba mara tabbatacce.\n\nYana maimaita tara lambobin har sai jimillar ta zama lamba guda, sannan yana mayar da wannan lamba guda.\n\nMisali:\n>>> digit_sum_to_single(\"35379\")\n9\n>>> digit_sum_to_single(\"24815\")\n3",
      "hi": "संख्या स्ट्रिंग के अंकों के बार-बार योग की गणना करता है जब तक कि यह एकल अंक तक न सिमट जाए। \nयह फ़ंक्शन एकल तर्क, `input_string`, लेता है, जो एक गैर-ऋणात्मक संख्या का प्रतिनिधित्व करने वाली स्ट्रिंग है। \nयह संख्या के अंकों का बार-बार योग करता है जब तक कि योग एकल अंक न हो, फिर इस एकल अंक को लौटाता है।\n\nउदाहरण:\n>>> digit_sum_to_single(\"35379\")\n9\n>>> digit_sum_to_single(\"24815\")\n3",
      "hu": "Kiszámítja egy adott számjegy-összeg ismételt összegét, amíg az egyetlen számjegyre nem csökken.\nA függvény egyetlen argumentumot vesz fel, `input_string`, amely egy nem negatív számot reprezentáló karakterlánc.\nIsmételten összeadja a számjegyeket, amíg az összeg egyetlen számjegy nem lesz, majd visszaadja ezt az egyetlen számjegyet.\n\nPélda:\n>>> digit_sum_to_single(\"35379\")\n9\n>>> digit_sum_to_single(\"24815\")\n3"
    },
    "docstring_bertscore": {
      "sq": "0.9626749678389721",
      "hy": "0.958957004366761",
      "bn": "0.969517585835243",
      "bg": "0.9655924508756125",
      "zh": "0.9610181918307601",
      "fr": "0.9688331055421967",
      "de": "0.9754220725418861",
      "ha": "0.9251773258768249",
      "hi": "0.9807920448931643",
      "hu": "0.9528139625724951"
    }
  },
  {
    "task_id": "Ruby/17",
    "prompt": {
      "en": "# Calculates the minimum number of seat swaps required to group representatives of the same company together.\n# Given a string representing a sequence of seats occupied by representatives of three companies, A, B, and T,\n# the function returns the minimum number of swaps needed so that all representatives of each company are seated together.\n# The input string contains only the characters 'A', 'B', and 'T', and each character represents a seat taken by a representative from the respective companies.\n#\n# Examples:\n# >>> minimum_swaps_to_group_companies(\\\"TABTABBTTTT\\\")\n# 3\n# >>> minimum_swaps_to_group_companies(\\\"BBTAAT\\\")\n# 1\ndef minimum_swaps_to_group_companies(s)",
      "sq": "# Llogarit numrin minimal të ndërrimeve të vendeve të nevojshme për të grupuar përfaqësuesit e të njëjtës kompani së bashku.\n# Duke pasur një varg që përfaqëson një sekuencë vendesh të zëna nga përfaqësues të tre kompanive, A, B, dhe T,\n# funksioni kthen numrin minimal të ndërrimeve të nevojshme që të gjithë përfaqësuesit e secilës kompani të ulen së bashku.\n# Vargu i hyrjes përmban vetëm karakteret 'A', 'B', dhe 'T', dhe secili karakter përfaqëson një vend të zënë nga një përfaqësues i kompanive përkatëse.\n#\n# Shembuj:\n# >>> minimum_swaps_to_group_companies(\"TABTABBTTTT\")\n# 3\n# >>> minimum_swaps_to_group_companies(\"BBTAAT\")\n# 1\ndef minimum_swaps_to_group_companies(s)",
      "hy": "# Հաշվում է նվազագույն նստատեղերի փոխանակումների քանակը, որը պահանջվում է նույն ընկերության ներկայացուցիչներին միասին խմբավորելու համար։\n# Տրված է տող, որը ներկայացնում է երեք ընկերությունների՝ A, B և T ներկայացուցիչների զբաղեցրած նստատեղերի հաջորդականությունը,\n# ֆունկցիան վերադարձնում է նվազագույն փոխանակումների քանակը, որը պահանջվում է, որպեսզի յուրաքանչյուր ընկերության ներկայացուցիչները նստեն միասին։\n# Մուտքագրված տողը պարունակում է միայն 'A', 'B' և 'T' նիշերը, և յուրաքանչյուր նիշ ներկայացնում է համապատասխան ընկերության ներկայացուցչի զբաղեցրած նստատեղը։\n#\n# Օրինակներ:\n# >>> minimum_swaps_to_group_companies(\\\"TABTABBTTTT\\\")\n# 3\n# >>> minimum_swaps_to_group_companies(\\\"BBTAAT\\\")\n# 1\ndef minimum_swaps_to_group_companies(s)",
      "bn": "# একই কোম্পানির প্রতিনিধিদের একসাথে বসানোর জন্য প্রয়োজনীয় সর্বনিম্ন আসন অদলবদল গণনা করে।\n# তিনটি কোম্পানি, A, B, এবং T এর প্রতিনিধিদের দ্বারা দখলকৃত আসনের একটি ক্রম উপস্থাপনকারী একটি স্ট্রিং দেওয়া হয়েছে,\n# ফাংশনটি প্রয়োজনীয় সর্বনিম্ন অদলবদল সংখ্যা ফেরত দেয় যাতে প্রতিটি কোম্পানির সমস্ত প্রতিনিধি একসাথে বসে থাকে।\n# ইনপুট স্ট্রিং শুধুমাত্র 'A', 'B', এবং 'T' অক্ষরগুলি ধারণ করে এবং প্রতিটি অক্ষর সংশ্লিষ্ট কোম্পানির একজন প্রতিনিধির দ্বারা দখলকৃত একটি আসনকে উপস্থাপন করে।\n#\n# উদাহরণ:\n# >>> minimum_swaps_to_group_companies(\"TABTABBTTTT\")\n# 3\n# >>> minimum_swaps_to_group_companies(\"BBTAAT\")\n# 1\ndef minimum_swaps_to_group_companies(s)",
      "bg": "# Изчислява минималния брой размени на места, необходими за групиране на представители на една и съща компания заедно.\n# Даден е низ, представляващ последователност от места, заети от представители на три компании, A, B и T,\n# функцията връща минималния брой размени, необходими, така че всички представители на всяка компания да седят заедно.\n# Входният низ съдържа само символите 'A', 'B' и 'T', и всеки символ представлява място, заето от представител на съответната компания.\n#\n# Примери:\n# >>> minimum_swaps_to_group_companies(\\\"TABTABBTTTT\\\")\n# 3\n# >>> minimum_swaps_to_group_companies(\\\"BBTAAT\\\")\n# 1\ndef minimum_swaps_to_group_companies(s)",
      "zh": "# 计算将相同公司的代表聚集在一起所需的最少座位交换次数。\n# 给定一个字符串，表示由三家公司 A、B 和 T 的代表占据的座位序列，\n# 该函数返回所需的最少交换次数，以便每个公司的所有代表都坐在一起。\n# 输入字符串仅包含字符 'A'、'B' 和 'T'，每个字符代表一个由相应公司代表占据的座位。\n#\n# 例子:\n# >>> minimum_swaps_to_group_companies(\"TABTABBTTTT\")\n# 3\n# >>> minimum_swaps_to_group_companies(\"BBTAAT\")\n# 1\ndef minimum_swaps_to_group_companies(s)",
      "fr": "# Calcule le nombre minimum d'échanges de sièges nécessaires pour regrouper les représentants de la même entreprise ensemble.\n# Étant donné une chaîne représentant une séquence de sièges occupés par des représentants de trois entreprises, A, B et T,\n# la fonction renvoie le nombre minimum d'échanges nécessaires pour que tous les représentants de chaque entreprise soient assis ensemble.\n# La chaîne d'entrée contient uniquement les caractères 'A', 'B' et 'T', et chaque caractère représente un siège occupé par un représentant des entreprises respectives.\n#\n# Exemples :\n# >>> minimum_swaps_to_group_companies(\"TABTABBTTTT\")\n# 3\n# >>> minimum_swaps_to_group_companies(\"BBTAAT\")\n# 1\ndef minimum_swaps_to_group_companies(s)",
      "de": "# Berechnet die minimale Anzahl an Sitzplatzwechseln, die erforderlich sind, um Vertreter derselben Firma zusammen zu gruppieren.\n# Gegeben ist ein String, der eine Sitzreihe darstellt, die von Vertretern dreier Firmen, A, B und T, besetzt ist.\n# Die Funktion gibt die minimale Anzahl an Wechseln zurück, die benötigt werden, damit alle Vertreter jeder Firma zusammen sitzen.\n# Der Eingabestring enthält nur die Zeichen 'A', 'B' und 'T', und jedes Zeichen repräsentiert einen Sitzplatz, der von einem Vertreter der jeweiligen Firmen eingenommen wird.\n#\n# Beispiele:\n# >>> minimum_swaps_to_group_companies(\\\"TABTABBTTTT\\\")\n# 3\n# >>> minimum_swaps_to_group_companies(\\\"BBTAAT\\\")\n# 1\ndef minimum_swaps_to_group_companies(s)",
      "ha": "# Lissafin mafi ƙarancin adadin sauye-sauyen wurin zama da ake buƙata don tara wakilan kamfani guda ɗaya tare.\n# Ana ba da wata igiya da ke wakiltar jerin kujeru da wakilan kamfanoni uku, A, B, da T suka mamaye,\n# aikin yana dawo da mafi ƙarancin adadin sauye-sauyen da ake buƙata don haka duk wakilan kowanne kamfani suna zaune tare.\n# Igiya mai shigarwa tana ƙunshe da haruffa kawai 'A', 'B', da 'T', kuma kowane hali yana wakiltar kujera da wakili daga kamfanonin da suka dace ya mamaye.\n#\n# Misalai:\n# >>> minimum_swaps_to_group_companies(\"TABTABBTTTT\")\n# 3\n# >>> minimum_swaps_to_group_companies(\"BBTAAT\")\n# 1\ndef minimum_swaps_to_group_companies(s)",
      "hi": "# एक ही कंपनी के प्रतिनिधियों को एक साथ समूहित करने के लिए आवश्यक न्यूनतम सीट अदला-बदली की गणना करता है।\n# एक स्ट्रिंग दी गई है जो तीन कंपनियों, A, B, और T के प्रतिनिधियों द्वारा कब्जा की गई सीटों का अनुक्रम दर्शाती है,\n# यह फ़ंक्शन आवश्यक न्यूनतम अदला-बदली की संख्या लौटाता है ताकि प्रत्येक कंपनी के सभी प्रतिनिधि एक साथ बैठे हों।\n# इनपुट स्ट्रिंग में केवल 'A', 'B', और 'T' वर्ण होते हैं, और प्रत्येक वर्ण संबंधित कंपनियों के प्रतिनिधि द्वारा ली गई सीट का प्रतिनिधित्व करता है।\n#\n# उदाहरण:\n# >>> minimum_swaps_to_group_companies(\"TABTABBTTTT\")\n# 3\n# >>> minimum_swaps_to_group_companies(\"BBTAAT\")\n# 1\ndef minimum_swaps_to_group_companies(s)",
      "hu": "# Kiszámítja a minimális számú helycserét, amely szükséges ahhoz, hogy ugyanazon cég képviselői együtt üljenek.\n# Adott egy karakterlánc, amely három cég, A, B és T képviselői által elfoglalt ülések sorozatát ábrázolja,\n# a függvény visszaadja a szükséges minimális számú cserét, hogy minden cég képviselője együtt üljön.\n# A bemeneti karakterlánc csak az 'A', 'B' és 'T' karaktereket tartalmazza, és minden karakter egy adott cég képviselője által elfoglalt ülést jelöl.\n#\n# Példák:\n# >>> minimum_swaps_to_group_companies(\"TABTABBTTTT\")\n# 3\n# >>> minimum_swaps_to_group_companies(\"BBTAAT\")\n# 1\ndef minimum_swaps_to_group_companies(s)"
    },
    "prompt_bertscore": {
      "sq": "0.9661905269529085",
      "hy": "0.9475276136116325",
      "bn": "0.9605873625342954",
      "bg": "0.9690186263180833",
      "zh": "0.9581249417006059",
      "fr": "0.9731002820179693",
      "de": "0.9600214645787271",
      "ha": "0.9600657591536979",
      "hi": "0.9491998827895652",
      "hu": "0.9534537510298084"
    },
    "canonical_solution": "    def func(s, a, b, c)\n        count_a = count_b = count_c = 0\n        abc = ab = ba = bc = 0\n      \n        s.chars.each_with_index do |char, i|\n        \n          count_a += 1 if char == a\n          count_b += 1 if char == b\n          count_c += 1 if char == c\n        end \n        (0..count_a-1).each do |i|\n           \n            abc += 1 if s.chars[i] != a\n            ab += 1 if s.chars[i] == b\n        end \n        (count_a..count_a+count_b-1).each do |i|\n            ba += 1 if s.chars[i] == a\n            bc += 1 if s.chars[i] == c\n        end\n        res = abc + bc + ba - [ba, ab].min\n        res\n    end\n    permutations = ['BAT', 'ATB', 'TBA', 'BTA', 'ABT', 'TAB']\n    min_swaps = Float::INFINITY\n  \n    permutations.each do |perm|\n      swaps = func(s, perm[0], perm[1], perm[2])\n      min_swaps = [min_swaps, swaps].min\n    end\n    min_swaps\n  end",
    "instruction": {
      "en": "Write a ruby function `def minimum_swaps_to_group_companies(s)` to solve the following problem:\nCalculates the minimum number of seat swaps required to group representatives of the same company together.\nGiven a string representing a sequence of seats occupied by representatives of three companies, A, B, and T,\nthe function returns the minimum number of swaps needed so that all representatives of each company are seated together.\nThe input string contains only the characters 'A', 'B', and 'T', and each character represents a seat taken by a representative from the respective companies.\n\nExamples:\n>>> minimum_swaps_to_group_companies(\\\"TABTABBTTTT\\\")\n3\n>>> minimum_swaps_to_group_companies(\\\"BBTAAT\\\")\n1",
      "sq": "Shkruani një funksion ruby `def minimum_swaps_to_group_companies(s)` për të zgjidhur problemin e mëposhtëm:\nLlogarit numrin minimal të ndërrimeve të vendeve të nevojshme për të grupuar përfaqësuesit e së njëjtës kompani së bashku.\nDuke pasur një varg që përfaqëson një sekuencë vendesh të zëna nga përfaqësues të tre kompanive, A, B, dhe T,\nfunksioni kthen numrin minimal të ndërrimeve të nevojshme në mënyrë që të gjithë përfaqësuesit e secilës kompani të jenë ulur së bashku.\nVargu i hyrjes përmban vetëm karakteret 'A', 'B', dhe 'T', dhe secili karakter përfaqëson një vend të zënë nga një përfaqësues nga kompanitë përkatëse.\n\nShembuj:\n>>> minimum_swaps_to_group_companies(\\\"TABTABBTTTT\\\")\n3\n>>> minimum_swaps_to_group_companies(\\\"BBTAAT\\\")\n1",
      "hy": "Գրեք ruby ֆունկցիա `def minimum_swaps_to_group_companies(s)` հետևյալ խնդիրը լուծելու համար:\nՀաշվում է նվազագույն քանակությամբ նստատեղերի փոխանակումները, որոնք անհրաժեշտ են նույն ընկերության ներկայացուցիչներին միասին խմբավորելու համար:\nՏրված է տող, որը ներկայացնում է երեք ընկերությունների՝ A, B և T ներկայացուցիչների զբաղեցրած նստատեղերի հաջորդականությունը,\nֆունկցիան վերադարձնում է նվազագույն փոխանակումների քանակը, որպեսզի յուրաքանչյուր ընկերության ներկայացուցիչները նստած լինեն միասին:\nՄուտքային տողը պարունակում է միայն 'A', 'B' և 'T' նիշերը, և յուրաքանչյուր նիշ ներկայացնում է համապատասխան ընկերության ներկայացուցչի զբաղեցրած նստատեղ:\n\nՕրինակներ:\n>>> minimum_swaps_to_group_companies(\\\"TABTABBTTTT\\\")\n3\n>>> minimum_swaps_to_group_companies(\\\"BBTAAT\\\")\n1",
      "bn": "একটি রুবি ফাংশন `def minimum_swaps_to_group_companies(s)` লিখুন নিম্নলিখিত সমস্যার সমাধানের জন্য:\nএকই কোম্পানির প্রতিনিধিদের একসাথে বসানোর জন্য প্রয়োজনীয় সর্বনিম্ন আসন পরিবর্তনের সংখ্যা গণনা করে।\nতিনটি কোম্পানি, A, B, এবং T এর প্রতিনিধিদের দ্বারা দখলকৃত আসনের একটি ক্রম উপস্থাপনকারী একটি স্ট্রিং দেওয়া হয়েছে,\nফাংশনটি প্রয়োজনীয় সর্বনিম্ন পরিবর্তনের সংখ্যা ফেরত দেয় যাতে প্রতিটি কোম্পানির সমস্ত প্রতিনিধি একসাথে বসে থাকে।\nইনপুট স্ট্রিং শুধুমাত্র 'A', 'B', এবং 'T' অক্ষরগুলি ধারণ করে এবং প্রতিটি অক্ষর সংশ্লিষ্ট কোম্পানির একজন প্রতিনিধির দ্বারা নেওয়া একটি আসন উপস্থাপন করে।\n\nউদাহরণ:\n>>> minimum_swaps_to_group_companies(\\\"TABTABBTTTT\\\")\n3\n>>> minimum_swaps_to_group_companies(\\\"BBTAAT\\\")\n1",
      "bg": "Напишете функция на Ruby `def minimum_swaps_to_group_companies(s)` за решаване на следния проблем:\nИзчислява минималния брой размени на места, необходими за групиране на представители на една и съща компания заедно.\nДаден е низ, представляващ последователност от места, заети от представители на три компании, A, B и T,\nфункцията връща минималния брой размени, необходими, така че всички представители на всяка компания да седят заедно.\nВходният низ съдържа само символите 'A', 'B' и 'T', и всеки символ представлява място, заето от представител на съответната компания.\n\nПримери:\n>>> minimum_swaps_to_group_companies(\\\"TABTABBTTTT\\\")\n3\n>>> minimum_swaps_to_group_companies(\\\"BBTAAT\\\")\n1",
      "zh": "编写一个 ruby 函数 `def minimum_swaps_to_group_companies(s)` 来解决以下问题：\n计算将相同公司的代表聚集在一起所需的最小座位交换次数。\n给定一个字符串，表示由三家公司 A、B 和 T 的代表占据的座位序列，\n该函数返回所需的最小交换次数，以便每个公司的所有代表都坐在一起。\n输入字符串仅包含字符 'A'、'B' 和 'T'，每个字符代表一个由相应公司代表占据的座位。\n\n示例：\n>>> minimum_swaps_to_group_companies(\\\"TABTABBTTTT\\\")\n3\n>>> minimum_swaps_to_group_companies(\\\"BBTAAT\\\")\n1",
      "fr": "Écrire une fonction ruby `def minimum_swaps_to_group_companies(s)` pour résoudre le problème suivant :\nCalcule le nombre minimum d'échanges de sièges nécessaires pour regrouper les représentants de la même entreprise ensemble.\nÉtant donné une chaîne représentant une séquence de sièges occupés par des représentants de trois entreprises, A, B et T,\nla fonction renvoie le nombre minimum d'échanges nécessaires pour que tous les représentants de chaque entreprise soient assis ensemble.\nLa chaîne d'entrée contient uniquement les caractères 'A', 'B' et 'T', et chaque caractère représente un siège occupé par un représentant des entreprises respectives.\n\nExemples :\n>>> minimum_swaps_to_group_companies(\\\"TABTABBTTTT\\\")\n3\n>>> minimum_swaps_to_group_companies(\\\"BBTAAT\\\")\n1",
      "de": "Schreiben Sie eine Ruby-Funktion `def minimum_swaps_to_group_companies(s)`, um das folgende Problem zu lösen:\nBerechnet die minimale Anzahl von Sitzplatzwechseln, die erforderlich sind, um Vertreter desselben Unternehmens zusammen zu gruppieren.\nGegeben ist ein String, der eine Sitzfolge darstellt, die von Vertretern dreier Unternehmen, A, B und T, besetzt ist,\ngibt die Funktion die minimale Anzahl von Wechseln zurück, die benötigt werden, damit alle Vertreter jedes Unternehmens zusammen sitzen.\nDer Eingabestring enthält nur die Zeichen 'A', 'B' und 'T', und jedes Zeichen repräsentiert einen Sitzplatz, der von einem Vertreter der jeweiligen Unternehmen eingenommen wird.\n\nBeispiele:\n>>> minimum_swaps_to_group_companies(\\\"TABTABBTTTT\\\")\n3\n>>> minimum_swaps_to_group_companies(\\\"BBTAAT\\\")\n1",
      "ha": "Rubuta aikin ruby `def minimum_swaps_to_group_companies(s)` don warware matsalar mai zuwa:\nLissafa adadin mafi ƙarancin musayar wuraren zama da ake buƙata don haɗa wakilan kamfani guda.\nAn ba da wani igiya mai wakiltar jerin wuraren zama da wakilan kamfanoni uku, A, B, da T suka mamaye,\naikin yana dawowa da mafi ƙarancin adadin musayar da ake buƙata don haka duk wakilan kowanne kamfani suna zaune tare.\nIgin shigarwa yana ƙunshe da haruffa kawai 'A', 'B', da 'T', kuma kowanne hali yana wakiltar wurin zama da wakili daga kamfanoni daban-daban ya ɗauka.\n\nMisalai:\n>>> minimum_swaps_to_group_companies(\\\"TABTABBTTTT\\\")\n3\n>>> minimum_swaps_to_group_companies(\\\"BBTAAT\\\")\n1",
      "hi": "रूबी फ़ंक्शन `def minimum_swaps_to_group_companies(s)` लिखें ताकि निम्नलिखित समस्या का समाधान किया जा सके:\nएक ही कंपनी के प्रतिनिधियों को एक साथ समूहित करने के लिए आवश्यक न्यूनतम सीट अदला-बदली की गणना करता है।\nएक स्ट्रिंग दी गई है जो तीन कंपनियों, A, B, और T के प्रतिनिधियों द्वारा कब्जा की गई सीटों का अनुक्रम दर्शाती है,\nफ़ंक्शन न्यूनतम अदला-बदली की संख्या लौटाता है ताकि प्रत्येक कंपनी के सभी प्रतिनिधि एक साथ बैठें।\nइनपुट स्ट्रिंग में केवल 'A', 'B', और 'T' वर्ण होते हैं, और प्रत्येक वर्ण संबंधित कंपनियों के प्रतिनिधि द्वारा ली गई सीट का प्रतिनिधित्व करता है।\n\nउदाहरण:\n>>> minimum_swaps_to_group_companies(\\\"TABTABBTTTT\\\")\n3\n>>> minimum_swaps_to_group_companies(\\\"BBTAAT\\\")\n1",
      "hu": "Írj egy ruby függvényt `def minimum_swaps_to_group_companies(s)` a következő probléma megoldására:\nKiszámítja a minimális számú helycserét, amely szükséges ahhoz, hogy az azonos cég képviselői együtt üljenek.\nAdott egy karakterlánc, amely három cég, A, B és T képviselői által elfoglalt ülések sorozatát jelöli,\na függvény visszaadja a szükséges minimális cserék számát, hogy minden cég képviselői együtt üljenek.\nA bemeneti karakterlánc csak az 'A', 'B' és 'T' karaktereket tartalmazza, és minden karakter egy-egy ülést jelöl, amelyet az adott cégek képviselői foglalnak el.\n\nPéldák:\n>>> minimum_swaps_to_group_companies(\\\"TABTABBTTTT\\\")\n3\n>>> minimum_swaps_to_group_companies(\\\"BBTAAT\\\")\n1"
    },
    "instruction_bertscore": {
      "sq": "0.976202292678591",
      "hy": "0.9503729938199573",
      "bn": "0.9689272563428073",
      "bg": "0.9700052234206836",
      "zh": "0.9588417987457608",
      "fr": "0.9714653553516711",
      "de": "0.9683812214253423",
      "ha": "0.9583638940489909",
      "hi": "0.9508367957596738",
      "hu": "0.9581843321845354"
    },
    "level": "hard",
    "test": "raise 'Test failed' unless minimum_swaps_to_group_companies(\"TABTABBTTTT\") == 3\nraise 'Test failed' unless minimum_swaps_to_group_companies(\"BBTAAT\") == 1\nraise 'Test failed' unless minimum_swaps_to_group_companies(\"AABBBTTT\") == 0\nraise 'Test failed' unless minimum_swaps_to_group_companies(\"ATBT\") == 1\nraise 'Test failed' unless minimum_swaps_to_group_companies(\"TTABAB\") == 1\n  \n\n\n\nputs 'All tests passed!'",
    "entry_point": "minimum_swaps_to_group_companies",
    "signature": "def minimum_swaps_to_group_companies(s)",
    "docstring": {
      "en": "Calculates the minimum number of seat swaps required to group representatives of the same company together.\nGiven a string representing a sequence of seats occupied by representatives of three companies, A, B, and T,\nthe function returns the minimum number of swaps needed so that all representatives of each company are seated together.\nThe input string contains only the characters 'A', 'B', and 'T', and each character represents a seat taken by a representative from the respective companies.\n\nExamples:\n>>> minimum_swaps_to_group_companies(\\\"TABTABBTTTT\\\")\n3\n>>> minimum_swaps_to_group_companies(\\\"BBTAAT\\\")\n1",
      "sq": "Llogarit numrin minimal të ndërrimeve të vendeve të nevojshme për të grupuar së bashku përfaqësuesit e së njëjtës kompani.\nDuke pasur një varg që përfaqëson një sekuencë vendesh të zëna nga përfaqësues të tre kompanive, A, B, dhe T,\nfunksioni kthen numrin minimal të ndërrimeve të nevojshme që të gjithë përfaqësuesit e secilës kompani të ulen së bashku.\nVargu i hyrjes përmban vetëm karakteret 'A', 'B', dhe 'T', dhe secili karakter përfaqëson një vend të zënë nga një përfaqësues nga kompanitë përkatëse.\n\nShembuj:\n>>> minimum_swaps_to_group_companies(\"TABTABBTTTT\")\n3\n>>> minimum_swaps_to_group_companies(\"BBTAAT\")\n1",
      "hy": "Հաշվում է նստատեղերի նվազագույն փոխանակումների քանակը, որը պահանջվում է նույն ընկերության ներկայացուցիչներին միասին խմբավորելու համար:\nՏրված է տող, որը ներկայացնում է երեք ընկերությունների՝ A, B և T ներկայացուցիչների զբաղեցրած նստատեղերի հաջորդականությունը,\nֆունկցիան վերադարձնում է նվազագույն փոխանակումների քանակը, որը պահանջվում է, որպեսզի յուրաքանչյուր ընկերության բոլոր ներկայացուցիչները նստեն միասին:\nՄուտքագրած տողը պարունակում է միայն 'A', 'B' և 'T' նիշերը, և յուրաքանչյուր նիշ ներկայացնում է համապատասխան ընկերությունների ներկայացուցչի զբաղեցրած նստատեղ:\n\nՕրինակներ:\n>>> minimum_swaps_to_group_companies(\"TABTABBTTTT\")\n3\n>>> minimum_swaps_to_group_companies(\"BBTAAT\")\n1",
      "bn": "একই কোম্পানির প্রতিনিধিদের একসাথে বসানোর জন্য প্রয়োজনীয় সর্বনিম্ন আসন বিনিময় সংখ্যা গণনা করে।\nএকটি স্ট্রিং দেওয়া হয়েছে যা তিনটি কোম্পানি, A, B, এবং T এর প্রতিনিধিদের দ্বারা দখল করা আসনের একটি ক্রম উপস্থাপন করে,\nফাংশনটি প্রয়োজনীয় সর্বনিম্ন বিনিময়ের সংখ্যা ফেরত দেয় যাতে প্রতিটি কোম্পানির সমস্ত প্রতিনিধি একসাথে বসে।\nইনপুট স্ট্রিং শুধুমাত্র 'A', 'B', এবং 'T' অক্ষরগুলি ধারণ করে এবং প্রতিটি অক্ষর সংশ্লিষ্ট কোম্পানির প্রতিনিধির দ্বারা নেওয়া একটি আসন উপস্থাপন করে।\n\nউদাহরণ:\n>>> minimum_swaps_to_group_companies(\\\"TABTABBTTTT\\\")\n3\n>>> minimum_swaps_to_group_companies(\\\"BBTAAT\\\")\n1",
      "bg": "Изчислява минималния брой размени на места, необходими за групиране на представители на една и съща компания заедно.\nДаден е низ, представляващ последователност от места, заети от представители на три компании, A, B и T,\nфункцията връща минималния брой размени, необходими, така че всички представители на всяка компания да бъдат седнали заедно.\nВходният низ съдържа само символите 'A', 'B' и 'T', и всеки символ представлява място, заето от представител на съответната компания.\n\nПримери:\n>>> minimum_swaps_to_group_companies(\\\"TABTABBTTTT\\\")\n3\n>>> minimum_swaps_to_group_companies(\\\"BBTAAT\\\")\n1",
      "zh": "计算将同一公司的代表聚集在一起所需的最少座位交换次数。\n给定一个字符串，表示由三家公司 A、B 和 T 的代表占据的座位序列，\n该函数返回所需的最少交换次数，以便每个公司的所有代表都坐在一起。\n输入字符串仅包含字符 'A'、'B' 和 'T'，每个字符代表一个由相应公司代表占据的座位。\n\n示例：\n>>> minimum_swaps_to_group_companies(\"TABTABBTTTT\")\n3\n>>> minimum_swaps_to_group_companies(\"BBTAAT\")\n1",
      "fr": "Calcule le nombre minimum d'échanges de sièges nécessaires pour regrouper les représentants de la même entreprise ensemble.\nÉtant donné une chaîne représentant une séquence de sièges occupés par des représentants de trois entreprises, A, B et T,\nla fonction renvoie le nombre minimum d'échanges nécessaires pour que tous les représentants de chaque entreprise soient assis ensemble.\nLa chaîne d'entrée contient uniquement les caractères 'A', 'B' et 'T', et chaque caractère représente un siège occupé par un représentant des entreprises respectives.\n\nExemples :\n>>> minimum_swaps_to_group_companies(\\\"TABTABBTTTT\\\")\n3\n>>> minimum_swaps_to_group_companies(\\\"BBTAAT\\\")\n1",
      "de": "Berechnet die minimale Anzahl von Sitzplatzwechseln, die erforderlich sind, um Vertreter desselben Unternehmens zusammen zu gruppieren.\nGegeben ist ein String, der eine Sitzreihe darstellt, die von Vertretern dreier Unternehmen, A, B und T, besetzt ist. \nDie Funktion gibt die minimale Anzahl von Wechseln zurück, die erforderlich sind, damit alle Vertreter jedes Unternehmens zusammen sitzen.\nDer Eingabestring enthält nur die Zeichen 'A', 'B' und 'T', und jedes Zeichen repräsentiert einen von einem Vertreter der jeweiligen Unternehmen besetzten Sitz.\n\nBeispiele:\n>>> minimum_swaps_to_group_companies(\\\"TABTABBTTTT\\\")\n3\n>>> minimum_swaps_to_group_companies(\\\"BBTAAT\\\")\n1",
      "ha": "Yana ƙididdige mafi ƙarancin adadin musayar kujeru da ake buƙata don tara wakilai na kamfani ɗaya tare.\nAn ba da wata kirtani da ke wakiltar jerin kujeru da wakilan kamfanoni uku, A, B, da T suka mamaye,\naikin yana dawo da mafi ƙarancin adadin musayar da ake buƙata don duk wakilan kowane kamfani su zauna tare.\nKirtanin shigarwa yana ƙunshe da haruffa 'A', 'B', da 'T' kawai, kuma kowanne hali yana wakiltar kujera da wakili daga kamfanonin da suka dace ya ɗauka.\n\nMisalai:\n>>> minimum_swaps_to_group_companies(\"TABTABBTTTT\")\n3\n>>> minimum_swaps_to_group_companies(\"BBTAAT\")\n1",
      "hi": "प्रतिनिधियों को एक ही कंपनी के साथ समूहबद्ध करने के लिए आवश्यक न्यूनतम सीट अदला-बदली की गणना करता है। तीन कंपनियों, A, B, और T के प्रतिनिधियों द्वारा कब्जा की गई सीटों के अनुक्रम का प्रतिनिधित्व करने वाले एक स्ट्रिंग को दिया गया है, यह फ़ंक्शन आवश्यक न्यूनतम अदला-बदली की संख्या लौटाता है ताकि प्रत्येक कंपनी के सभी प्रतिनिधि एक साथ बैठे हों। इनपुट स्ट्रिंग में केवल 'A', 'B', और 'T' वर्ण होते हैं, और प्रत्येक वर्ण संबंधित कंपनियों के प्रतिनिधि द्वारा ली गई एक सीट का प्रतिनिधित्व करता है।\n\nउदाहरण:\n>>> minimum_swaps_to_group_companies(\"TABTABBTTTT\")\n3\n>>> minimum_swaps_to_group_companies(\"BBTAAT\")\n1",
      "hu": "Kiszámítja a minimálisan szükséges helycserék számát annak érdekében, hogy az azonos vállalat képviselői egymás mellett üljenek.\nEgy karakterláncot kapunk, amely három vállalat, A, B és T képviselői által elfoglalt ülések sorozatát jelöli,\na függvény visszaadja a szükséges minimális helycserék számát, hogy minden vállalat képviselői egymás mellett üljenek.\nA bemeneti karakterlánc csak az 'A', 'B' és 'T' karaktereket tartalmazza, és minden karakter egy adott vállalat képviselője által elfoglalt ülést jelöl.\n\nPéldák:\n>>> minimum_swaps_to_group_companies(\\\"TABTABBTTTT\\\")\n3\n>>> minimum_swaps_to_group_companies(\\\"BBTAAT\\\")\n1"
    },
    "docstring_bertscore": {
      "sq": "0.962896440713826",
      "hy": "0.9565867480298718",
      "bn": "0.9454394124158128",
      "bg": "0.970810272355018",
      "zh": "0.9600055741482443",
      "fr": "0.9743490712235355",
      "de": "0.9565049123128854",
      "ha": "0.9555641988283041",
      "hi": "0.9599519439453648",
      "hu": "0.9256536415305465"
    }
  },
  {
    "task_id": "Ruby/18",
    "prompt": {
      "en": "# Calculates the final minimum weight of fish in a simulated feeding game.\n# In this game, there are 'n' fish, each with an initial weight given in the 'weights' array.\n# The game proceeds for 'm' rounds. In each round, the lightest fish eats the second lightest,\n# and its weight becomes the sum of both. The function returns the weight of the lightest fish\n# after 'm' rounds.\n#\n# Arguments:\n# n (Integer) -- The number of fish.\n# m (Integer) -- The number of rounds the game will be played.\n# weights (Array of Integers) -- An array representing the weights of each fish.\n#\n# Example:\n# >>> final_min_weight_fish(1, [1, 2, 3])\n# 3\n# >>> final_min_weight_fish(2, [4, 3, 2, 1])\n# 4\n\ndef final_min_weight_fish(m, weights)",
      "sq": "# Llogarit peshën minimale përfundimtare të peshkut në një lojë të simuluar ushqimi.\n# Në këtë lojë, ka 'n' peshq, secili me një peshë fillestare të dhënë në vargun 'weights'.\n# Loja vazhdon për 'm' raunde. Në secilin raund, peshku më i lehtë ha të dytin më të lehtë,\n# dhe pesha e tij bëhet shuma e të dyjave. Funksioni kthen peshën e peshkut më të lehtë\n# pas 'm' raundeve.\n#\n# Argumentet:\n# n (Integer) -- Numri i peshqve.\n# m (Integer) -- Numri i raundeve që loja do të luhet.\n# weights (Array of Integers) -- Një varg që përfaqëson peshat e secilit peshk.\n#\n# Shembull:\n# >>> final_min_weight_fish(1, [1, 2, 3])\n# 3\n# >>> final_min_weight_fish(2, [4, 3, 2, 1])\n# 4\n\ndef final_min_weight_fish(m, weights)",
      "hy": "# Հաշվում է ձկների վերջնական նվազագույն քաշը սիմուլացված կերակրման խաղում։\n# Այս խաղում կա 'n' ձուկ, որոնցից յուրաքանչյուրի սկզբնական քաշը տրված է 'weights' զանգվածում։\n# Խաղը շարունակվում է 'm' փուլ։ Յուրաքանչյուր փուլում ամենաթեթև ձուկը ուտում է երկրորդ ամենաթեթևին,\n# և նրա քաշը դառնում է երկուսի գումարը։ Ֆունկցիան վերադարձնում է ամենաթեթև ձկան քաշը\n# 'm' փուլերից հետո։\n#\n# Արգումենտներ:\n# n (Integer) -- Ձկների քանակը։\n# m (Integer) -- Փուլերի քանակը, որոնք խաղը կխաղարկվի։\n# weights (Array of Integers) -- Զանգված, որը ներկայացնում է յուրաքանչյուր ձկան քաշը։\n#\n# Օրինակ:\n# >>> final_min_weight_fish(1, [1, 2, 3])\n# 3\n# >>> final_min_weight_fish(2, [4, 3, 2, 1])\n# 4\n\ndef final_min_weight_fish(m, weights)",
      "bn": "# একটি সিমুলেটেড খাওয়ানোর খেলায় মাছের চূড়ান্ত ন্যূনতম ওজন গণনা করে।\n# এই খেলায়, 'n' টি মাছ আছে, প্রতিটির প্রাথমিক ওজন 'weights' অ্যারেতে দেওয়া আছে।\n# খেলা 'm' রাউন্ডের জন্য চলে। প্রতিটি রাউন্ডে, সবচেয়ে হালকা মাছটি দ্বিতীয় সবচেয়ে হালকা মাছটিকে খায়,\n# এবং তার ওজন উভয়ের যোগফল হয়ে যায়। ফাংশনটি 'm' রাউন্ডের পরে সবচেয়ে হালকা মাছের ওজন ফেরত দেয়।\n#\n# আর্গুমেন্ট:\n# n (পূর্ণসংখ্যা) -- মাছের সংখ্যা।\n# m (পূর্ণসংখ্যা) -- খেলা কত রাউন্ড খেলা হবে।\n# weights (পূর্ণসংখ্যার অ্যারে) -- প্রতিটি মাছের ওজনকে উপস্থাপনকারী একটি অ্যারে।\n#\n# উদাহরণ:\n# >>> final_min_weight_fish(1, [1, 2, 3])\n# 3\n# >>> final_min_weight_fish(2, [4, 3, 2, 1])\n# 4\n\ndef final_min_weight_fish(m, weights)",
      "bg": "# Изчислява крайната минимална тежест на рибите в симулирана игра на хранене.\n# В тази игра има 'n' риби, всяка с начална тежест, дадена в масива 'weights'.\n# Играта продължава 'm' рунда. Във всеки рунд най-леката риба изяжда втората най-лека,\n# и нейната тежест става сумата от двете. Функцията връща тежестта на най-леката риба\n# след 'm' рунда.\n#\n# Аргументи:\n# n (Цяло число) -- Броят на рибите.\n# m (Цяло число) -- Броят на рундовете, в които ще се играе играта.\n# weights (Масив от цели числа) -- Масив, представляващ тежестите на всяка риба.\n#\n# Пример:\n# >>> final_min_weight_fish(1, [1, 2, 3])\n# 3\n# >>> final_min_weight_fish(2, [4, 3, 2, 1])\n# 4\n\ndef final_min_weight_fish(m, weights)",
      "zh": "# 计算在一个模拟的喂食游戏中鱼的最终最小重量。\n# 在这个游戏中，有'n'条鱼，每条鱼的初始重量在'weights'数组中给出。\n# 游戏进行'm'轮。在每一轮中，最轻的鱼吃掉第二轻的鱼，\n# 它的重量变成两者之和。函数返回'm'轮后最轻的鱼的重量。\n#\n# 参数:\n# n (整数) -- 鱼的数量。\n# m (整数) -- 游戏进行的轮数。\n# weights (整数数组) -- 一个数组，表示每条鱼的重量。\n#\n# 示例:\n# >>> final_min_weight_fish(1, [1, 2, 3])\n# 3\n# >>> final_min_weight_fish(2, [4, 3, 2, 1])\n# 4\n\ndef final_min_weight_fish(m, weights)",
      "fr": "# Calcule le poids minimum final des poissons dans un jeu de simulation d'alimentation.\n# Dans ce jeu, il y a 'n' poissons, chacun avec un poids initial donné dans le tableau 'weights'.\n# Le jeu se déroule pendant 'm' tours. À chaque tour, le poisson le plus léger mange le deuxième plus léger,\n# et son poids devient la somme des deux. La fonction renvoie le poids du poisson le plus léger\n# après 'm' tours.\n#\n# Arguments :\n# n (Entier) -- Le nombre de poissons.\n# m (Entier) -- Le nombre de tours pendant lesquels le jeu sera joué.\n# weights (Tableau d'Entiers) -- Un tableau représentant les poids de chaque poisson.\n#\n# Exemple :\n# >>> final_min_weight_fish(1, [1, 2, 3])\n# 3\n# >>> final_min_weight_fish(2, [4, 3, 2, 1])\n# 4\n\ndef final_min_weight_fish(m, weights)",
      "de": "# Berechnet das endgültige Mindestgewicht der Fische in einem simulierten Fütterungsspiel.\n# In diesem Spiel gibt es 'n' Fische, jeder mit einem Anfangsgewicht, das im 'weights'-Array angegeben ist.\n# Das Spiel läuft über 'm' Runden. In jeder Runde frisst der leichteste Fisch den zweitleichtesten,\n# und sein Gewicht wird zur Summe beider. Die Funktion gibt das Gewicht des leichtesten Fisches\n# nach 'm' Runden zurück.\n#\n# Argumente:\n# n (Integer) -- Die Anzahl der Fische.\n# m (Integer) -- Die Anzahl der Runden, die das Spiel gespielt wird.\n# weights (Array von Integern) -- Ein Array, das die Gewichte jedes Fisches darstellt.\n#\n# Beispiel:\n# >>> final_min_weight_fish(1, [1, 2, 3])\n# 3\n# >>> final_min_weight_fish(2, [4, 3, 2, 1])\n# 4\n\ndef final_min_weight_fish(m, weights)",
      "ha": "# Lissafi na karshe na mafi karancin nauyin kifi a cikin wani wasan ciyarwa na kwaikwayo.\n# A cikin wannan wasan, akwai 'n' kifaye, kowanne da nauyin farko da aka bayar a cikin jerin 'weights'.\n# Wasan yana ci gaba na 'm' zagaye. A kowane zagaye, mafi saukin nauyin kifi yana cin na biyu mafi sauki,\n# kuma nauyinsa yana zama jimlar duka biyun. Aikin yana mayar da nauyin mafi saukin kifi\n# bayan 'm' zagaye.\n#\n# Hujojji:\n# n (Lamba) -- Yawan kifaye.\n# m (Lamba) -- Yawan zagayen da za a buga wasan.\n# weights (Jerin Lambobi) -- Jerin da ke wakiltar nauyin kowanne kifi.\n#\n# Misali:\n# >>> final_min_weight_fish(1, [1, 2, 3])\n# 3\n# >>> final_min_weight_fish(2, [4, 3, 2, 1])\n# 4\n\ndef final_min_weight_fish(m, weights)",
      "hi": "# एक सिम्युलेटेड फीडिंग गेम में मछलियों के अंतिम न्यूनतम वजन की गणना करता है।\n# इस खेल में, 'n' मछलियाँ होती हैं, जिनमें से प्रत्येक का प्रारंभिक वजन 'weights' array में दिया गया है।\n# खेल 'm' राउंड के लिए चलता है। प्रत्येक राउंड में, सबसे हल्की मछली दूसरी सबसे हल्की मछली को खा जाती है,\n# और उसका वजन दोनों के योग के बराबर हो जाता है। फ़ंक्शन 'm' राउंड के बाद सबसे हल्की मछली का वजन लौटाता है।\n#\n# तर्क:\n# n (पूर्णांक) -- मछलियों की संख्या।\n# m (पूर्णांक) -- खेल कितने राउंड खेला जाएगा।\n# weights (पूर्णांकों की array) -- प्रत्येक मछली के वजन का प्रतिनिधित्व करने वाली array।\n#\n# उदाहरण:\n# >>> final_min_weight_fish(1, [1, 2, 3])\n# 3\n# >>> final_min_weight_fish(2, [4, 3, 2, 1])\n# 4\n\ndef final_min_weight_fish(m, weights)",
      "hu": "# Kiszámítja a halak végső minimális súlyát egy szimulált etetési játékban.\n# Ebben a játékban 'n' hal van, mindegyik kezdeti súlya a 'weights' tömbben van megadva.\n# A játék 'm' fordulóból áll. Minden fordulóban a legkönnyebb hal megeszi a második legkönnyebbet,\n# és a súlya mindkettő összegévé válik. A függvény visszaadja a legkönnyebb hal súlyát\n# 'm' forduló után.\n#\n# Érvek:\n# n (Egész szám) -- A halak száma.\n# m (Egész szám) -- A játék fordulóinak száma.\n# weights (Egészek tömbje) -- Egy tömb, amely az egyes halak súlyát reprezentálja.\n#\n# Példa:\n# >>> final_min_weight_fish(1, [1, 2, 3])\n# 3\n# >>> final_min_weight_fish(2, [4, 3, 2, 1])\n# 4\n\ndef final_min_weight_fish(m, weights)"
    },
    "prompt_bertscore": {
      "sq": "0.9935981428192455",
      "hy": "0.9881663964194655",
      "bn": "0.9780215483384896",
      "bg": "0.9838318842445222",
      "zh": "0.9552394381553121",
      "fr": "0.9768524099157183",
      "de": "0.9897000215914359",
      "ha": "0.9632168315184353",
      "hi": "0.9754242574760774",
      "hu": "0.9823328207588519"
    },
    "canonical_solution": "  # Sort the weights array to ensure the lightest fish are at the beginning.\n  sorted_weights = weights.sort\n\n  m.times do\n    # The lightest fish eats the second lightest.\n    sorted_weights[0] += sorted_weights[1]\n    # Remove the second lightest fish since it has been eaten.\n    sorted_weights.delete_at(1)\n    # Re-sort the weights to find the new lightest and second lightest for the next round.\n    sorted_weights.sort!\n  end\n\n  # After 'm' rounds, return the weight of the lightest fish.\n  sorted_weights[0]\nend",
    "instruction": {
      "en": "Write a ruby function `def final_min_weight_fish(m, weights)` to solve the following problem:\nCalculates the final minimum weight of fish in a simulated feeding game.\nIn this game, there are 'n' fish, each with an initial weight given in the 'weights' array.\nThe game proceeds for 'm' rounds. In each round, the lightest fish eats the second lightest,\nand its weight becomes the sum of both. The function returns the weight of the lightest fish\nafter 'm' rounds.\n\nArguments:\nn (Integer) -- The number of fish.\nm (Integer) -- The number of rounds the game will be played.\nweights (Array of Integers) -- An array representing the weights of each fish.\n\nExample:\n>>> final_min_weight_fish(1, [1, 2, 3])\n3\n>>> final_min_weight_fish(2, [4, 3, 2, 1])\n4",
      "sq": "Shkruani një funksion ruby `def final_min_weight_fish(m, weights)` për të zgjidhur problemin e mëposhtëm:\nLlogarit peshën minimale përfundimtare të peshkut në një lojë të simuluar ushqimi.\nNë këtë lojë, ka 'n' peshq, secili me një peshë fillestare të dhënë në vargun 'weights'.\nLoja vazhdon për 'm' raunde. Në secilin raund, peshku më i lehtë ha të dytin më të lehtë,\ndhe pesha e tij bëhet shuma e të dyve. Funksioni kthen peshën e peshkut më të lehtë\npas 'm' raundeve.\n\nArgumentet:\nn (Integer) -- Numri i peshqve.\nm (Integer) -- Numri i raundeve që loja do të luhet.\nweights (Array of Integers) -- Një varg që përfaqëson peshat e secilit peshk.\n\nShembull:\n>>> final_min_weight_fish(1, [1, 2, 3])\n3\n>>> final_min_weight_fish(2, [4, 3, 2, 1])\n4",
      "hy": "Գրեք ruby ֆունկցիա `def final_min_weight_fish(m, weights)` հետևյալ խնդիրը լուծելու համար:\nՀաշվարկում է ձկների վերջնական նվազագույն քաշը սիմուլացված կերակրման խաղում:\nԱյս խաղում կա 'n' ձուկ, որոնցից յուրաքանչյուրն ունի սկզբնական քաշ, որը տրված է 'weights' զանգվածում:\nԽաղը շարունակվում է 'm' փուլ: Յուրաքանչյուր փուլում, ամենաթեթև ձուկը ուտում է երկրորդ ամենաթեթևին,\nև նրա քաշը դառնում է երկուսի գումարը: Ֆունկցիան վերադարձնում է ամենաթեթև ձկան քաշը\n'm' փուլից հետո:\n\nԱրգումենտներ:\nn (Integer) -- Ձկների քանակը:\nm (Integer) -- Խաղի փուլերի քանակը:\nweights (Array of Integers) -- Զանգված, որը ներկայացնում է յուրաքանչյուր ձկան քաշը:\n\nՕրինակ:\n>>> final_min_weight_fish(1, [1, 2, 3])\n3\n>>> final_min_weight_fish(2, [4, 3, 2, 1])\n4",
      "bn": "রুবি ফাংশন `def final_min_weight_fish(m, weights)` লিখুন নিম্নলিখিত সমস্যার সমাধানের জন্য:\nএকটি সিমুলেটেড খাওয়ানোর খেলায় মাছের চূড়ান্ত ন্যূনতম ওজন গণনা করে।\nএই খেলায়, 'n' টি মাছ আছে, প্রতিটি মাছের প্রাথমিক ওজন 'weights' অ্যারেতে দেওয়া আছে।\nখেলা 'm' রাউন্ডের জন্য চলে। প্রতিটি রাউন্ডে, সবচেয়ে হালকা মাছটি দ্বিতীয় সবচেয়ে হালকা মাছটিকে খায়,\nএবং এর ওজন উভয়ের যোগফল হয়ে যায়। ফাংশনটি 'm' রাউন্ডের পরে সবচেয়ে হালকা মাছের ওজন ফেরত দেয়।\n\nআর্গুমেন্টসমূহ:\nn (Integer) -- মাছের সংখ্যা।\nm (Integer) -- খেলা কত রাউন্ড খেলা হবে।\nweights (Array of Integers) -- প্রতিটি মাছের ওজনের প্রতিনিধিত্বকারী একটি অ্যারে।\n\nউদাহরণ:\n>>> final_min_weight_fish(1, [1, 2, 3])\n3\n>>> final_min_weight_fish(2, [4, 3, 2, 1])\n4",
      "bg": "Напишете функция на Ruby `def final_min_weight_fish(m, weights)` за решаване на следния проблем:\nИзчислява крайната минимална тежест на рибата в симулирана игра на хранене.\nВ тази игра има 'n' риби, всяка с начална тежест, дадена в масива 'weights'.\nИграта продължава 'm' рунда. Във всеки рунд най-леката риба изяжда втората най-лека,\nи нейната тежест става сумата от двете. Функцията връща тежестта на най-леката риба\nслед 'm' рунда.\n\nАргументи:\nn (Цяло число) -- Броят на рибите.\nm (Цяло число) -- Броят на рундовете, в които ще се играе играта.\nweights (Масив от цели числа) -- Масив, представляващ тежестите на всяка риба.\n\nПример:\n>>> final_min_weight_fish(1, [1, 2, 3])\n3\n>>> final_min_weight_fish(2, [4, 3, 2, 1])\n4",
      "zh": "编写一个 ruby 函数 `def final_min_weight_fish(m, weights)` 来解决以下问题：\n计算在模拟喂食游戏中鱼的最终最小重量。\n在这个游戏中，有 'n' 条鱼，每条鱼的初始重量在 'weights' 数组中给出。\n游戏进行 'm' 轮。在每一轮中，最轻的鱼吃掉第二轻的鱼，\n其重量变为两者之和。函数返回 'm' 轮后最轻的鱼的重量。\n\n参数：\nn (Integer) -- 鱼的数量。\nm (Integer) -- 游戏进行的轮数。\nweights (Array of Integers) -- 一个数组，表示每条鱼的重量。\n\n示例：\n>>> final_min_weight_fish(1, [1, 2, 3])\n3\n>>> final_min_weight_fish(2, [4, 3, 2, 1])\n4",
      "fr": "Écrire une fonction ruby `def final_min_weight_fish(m, weights)` pour résoudre le problème suivant :\nCalcule le poids minimum final des poissons dans un jeu de simulation d'alimentation.\nDans ce jeu, il y a 'n' poissons, chacun avec un poids initial donné dans le tableau 'weights'.\nLe jeu se déroule pendant 'm' tours. À chaque tour, le poisson le plus léger mange le deuxième plus léger,\net son poids devient la somme des deux. La fonction renvoie le poids du poisson le plus léger\naprès 'm' tours.\n\nArguments :\nn (Integer) -- Le nombre de poissons.\nm (Integer) -- Le nombre de tours pendant lesquels le jeu sera joué.\nweights (Array of Integers) -- Un tableau représentant les poids de chaque poisson.\n\nExemple :\n>>> final_min_weight_fish(1, [1, 2, 3])\n3\n>>> final_min_weight_fish(2, [4, 3, 2, 1])\n4",
      "de": "Schreiben Sie eine Ruby-Funktion `def final_min_weight_fish(m, weights)`, um das folgende Problem zu lösen:\nBerechnet das endgültige Mindestgewicht der Fische in einem simulierten Fütterungsspiel.\nIn diesem Spiel gibt es 'n' Fische, jeder mit einem Anfangsgewicht, das im 'weights'-Array angegeben ist.\nDas Spiel geht über 'm' Runden. In jeder Runde frisst der leichteste Fisch den zweitleichtesten,\nund sein Gewicht wird zur Summe von beiden. Die Funktion gibt das Gewicht des leichtesten Fisches\nnach 'm' Runden zurück.\n\nArgumente:\nn (Integer) -- Die Anzahl der Fische.\nm (Integer) -- Die Anzahl der Runden, die das Spiel gespielt wird.\nweights (Array von Ganzzahlen) -- Ein Array, das die Gewichte jedes Fisches darstellt.\n\nBeispiel:\n>>> final_min_weight_fish(1, [1, 2, 3])\n3\n>>> final_min_weight_fish(2, [4, 3, 2, 1])\n4",
      "ha": "Rubuta wani aiki na ruby `def final_min_weight_fish(m, weights)` don warware matsalar mai zuwa:\nYana ƙididdige ƙaramin nauyin kifi na ƙarshe a cikin wasan ciyarwa na kwaikwayo.\nA cikin wannan wasan, akwai kifaye 'n', kowanne da nauyin farko da aka bayar a cikin jerin 'weights'.\nWasan yana tafiya na tsawon zagaye 'm'. A kowane zagaye, kifi mafi sauƙi yana cin kifi na biyu mafi sauƙi,\nkuma nauyinsa yana zama jumlar duka biyun. Aikin yana mayar da nauyin kifi mafi sauƙi\nbayan zagaye 'm'.\n\nHujojji:\nn (Integer) -- Yawan kifaye.\nm (Integer) -- Yawan zagayen da za a yi wasan.\nweights (Array of Integers) -- Jerin da ke wakiltar nauyin kowane kifi.\n\nMisali:\n>>> final_min_weight_fish(1, [1, 2, 3])\n3\n>>> final_min_weight_fish(2, [4, 3, 2, 1])\n4",
      "hi": "रूबी फ़ंक्शन `def final_min_weight_fish(m, weights)` लिखें ताकि निम्नलिखित समस्या का समाधान किया जा सके:\nएक सिम्युलेटेड फीडिंग गेम में मछली के अंतिम न्यूनतम वजन की गणना करता है।\nइस खेल में, 'n' मछलियाँ हैं, जिनमें से प्रत्येक का प्रारंभिक वजन 'weights' array में दिया गया है।\nखेल 'm' राउंड के लिए चलता है। प्रत्येक राउंड में, सबसे हल्की मछली दूसरी सबसे हल्की मछली को खा जाती है,\nऔर उसका वजन दोनों का योग बन जाता है। फ़ंक्शन 'm' राउंड के बाद सबसे हल्की मछली का वजन लौटाता है।\n\nआर्ग्युमेंट्स:\nn (Integer) -- मछलियों की संख्या।\nm (Integer) -- खेल कितने राउंड खेला जाएगा।\nweights (Array of Integers) -- एक array जो प्रत्येक मछली के वजन का प्रतिनिधित्व करता है।\n\nउदाहरण:\n>>> final_min_weight_fish(1, [1, 2, 3])\n3\n>>> final_min_weight_fish(2, [4, 3, 2, 1])\n4",
      "hu": "Írj egy ruby függvényt `def final_min_weight_fish(m, weights)` a következő probléma megoldására:\nKiszámítja a halak végső minimális súlyát egy szimulált etetési játékban.\nEbben a játékban 'n' hal van, mindegyik kezdeti súlya a 'weights' tömbben van megadva.\nA játék 'm' fordulón keresztül zajlik. Minden fordulóban a legkönnyebb hal megeszi a második legkönnyebbet,\nés a súlya mindkettő összegévé válik. A függvény visszaadja a legkönnyebb hal súlyát 'm' forduló után.\n\nArgumentumok:\nn (Egész szám) -- A halak száma.\nm (Egész szám) -- A játék fordulóinak száma.\nweights (Egészek tömbje) -- Egy tömb, amely az egyes halak súlyát reprezentálja.\n\nPélda:\n>>> final_min_weight_fish(1, [1, 2, 3])\n3\n>>> final_min_weight_fish(2, [4, 3, 2, 1])\n4"
    },
    "instruction_bertscore": {
      "sq": "0.9914865032384637",
      "hy": "0.9764841491892796",
      "bn": "0.9803884279589014",
      "bg": "0.9810431136947924",
      "zh": "0.9708597313198957",
      "fr": "0.9813221893801464",
      "de": "0.9834123768797765",
      "ha": "0.9735577277854925",
      "hi": "0.9797285778331034",
      "hu": "0.9824069098909779"
    },
    "level": "hard",
    "test": "raise 'Test failed' unless final_min_weight_fish(1, [1, 2, 3]) == 3\nraise 'Test failed' unless final_min_weight_fish(2, [4, 3, 2, 1]) == 4\nraise 'Test failed' unless final_min_weight_fish(2, [5, 4, 3, 2, 1]) == 4\nraise 'Test failed' unless final_min_weight_fish(2, [3, 2, 1]) == 6\nraise 'Test failed' unless final_min_weight_fish(3, [1, 2, 3, 4]) == 10\n  \nputs 'All tests passed!'",
    "entry_point": "final_min_weight_fish",
    "signature": "def final_min_weight_fish(m, weights)",
    "docstring": {
      "en": "Calculates the final minimum weight of fish in a simulated feeding game.\nIn this game, there are 'n' fish, each with an initial weight given in the 'weights' array.\nThe game proceeds for 'm' rounds. In each round, the lightest fish eats the second lightest,\nand its weight becomes the sum of both. The function returns the weight of the lightest fish\nafter 'm' rounds.\n\nArguments:\nn (Integer) -- The number of fish.\nm (Integer) -- The number of rounds the game will be played.\nweights (Array of Integers) -- An array representing the weights of each fish.\n\nExample:\n>>> final_min_weight_fish(1, [1, 2, 3])\n3\n>>> final_min_weight_fish(2, [4, 3, 2, 1])\n4",
      "sq": "Llogarit peshën përfundimtare minimale të peshkut në një lojë të simuluar ushqimi.\nNë këtë lojë, ka 'n' peshq, secili me një peshë fillestare të dhënë në vargun 'weights'.\nLoja vazhdon për 'm' raunde. Në çdo raund, peshku më i lehtë ha të dytin më të lehtë,\ndhe pesha e tij bëhet shuma e të dyve. Funksioni kthen peshën e peshkut më të lehtë\npas 'm' raundeve.\n\nArgumentet:\nn (Integer) -- Numri i peshqve.\nm (Integer) -- Numri i raundeve që loja do të luhet.\nweights (Array of Integers) -- Një varg që përfaqëson peshat e secilit peshk.\n\nShembull:\n>>> final_min_weight_fish(1, [1, 2, 3])\n3\n>>> final_min_weight_fish(2, [4, 3, 2, 1])\n4",
      "hy": "Հաշվում է ձկների վերջնական նվազագույն քաշը սիմուլացված կերակրման խաղում:\nԱյս խաղում կա 'n' ձուկ, որոնցից յուրաքանչյուրն ունի սկզբնական քաշ, որը տրված է 'weights' զանգվածում:\nԽաղը ընթանում է 'm' փուլերի ընթացքում: Յուրաքանչյուր փուլում ամենաթեթև ձուկը ուտում է երկրորդ ամենաթեթևին,\nև նրա քաշը դառնում է երկուսի գումարը: Ֆունկցիան վերադարձնում է ամենաթեթև ձկան քաշը\n'm' փուլերից հետո:\n\nԱրգումենտներ:\nn (Integer) -- Ձկների քանակը:\nm (Integer) -- Փուլերի քանակը, որ խաղը կխաղարկվի:\nweights (Array of Integers) -- Զանգված, որը ներկայացնում է յուրաքանչյուր ձկան քաշը:\n\nՕրինակ:\n>>> final_min_weight_fish(1, [1, 2, 3])\n3\n>>> final_min_weight_fish(2, [4, 3, 2, 1])\n4",
      "bn": "মাছের একটি সিমুলেটেড খাওয়ানোর খেলায় চূড়ান্ত ন্যূনতম ওজন গণনা করে। \nএই খেলায়, 'n' সংখ্যক মাছ আছে, প্রতিটির প্রাথমিক ওজন 'weights' অ্যারেতে দেওয়া আছে। \nখেলা 'm' রাউন্ডের জন্য চলে। প্রতিটি রাউন্ডে, সবচেয়ে হালকা মাছ দ্বিতীয় সবচেয়ে হালকা মাছকে খায়, \nএবং তার ওজন উভয়ের যোগফল হয়ে যায়। ফাংশনটি 'm' রাউন্ডের পরে সবচেয়ে হালকা মাছের ওজন ফেরত দেয়।\n\nআর্গুমেন্টসমূহ:\nn (পূর্ণসংখ্যা) -- মাছের সংখ্যা।\nm (পূর্ণসংখ্যা) -- খেলা কত রাউন্ড খেলা হবে।\nweights (পূর্ণসংখ্যার অ্যারে) -- প্রতিটি মাছের ওজন উপস্থাপনকারী একটি অ্যারে।\n\nউদাহরণ:\n>>> final_min_weight_fish(1, [1, 2, 3])\n3\n>>> final_min_weight_fish(2, [4, 3, 2, 1])\n4",
      "bg": "Изчислява крайната минимална тежест на рибата в симулирана игра на хранене. В тази игра има 'n' риби, всяка с начална тежест, дадена в масива 'weights'. Играта продължава 'm' рунда. Във всеки рунд най-леката риба изяжда втората най-лека и нейната тежест става сумата от двете. Функцията връща тежестта на най-леката риба след 'm' рунда.\n\nАргументи:\nn (Цяло число) -- Броят на рибите.\nm (Цяло число) -- Броят на рундовете, в които ще се играе играта.\nweights (Масив от цели числа) -- Масив, представляващ тежестите на всяка риба.\n\nПример:\n>>> final_min_weight_fish(1, [1, 2, 3])\n3\n>>> final_min_weight_fish(2, [4, 3, 2, 1])\n4",
      "zh": "计算模拟喂食游戏中鱼的最终最小重量。\n在这个游戏中，有 'n' 条鱼，每条鱼的初始重量在 'weights' 数组中给出。  \n游戏进行 'm' 轮。在每一轮中，最轻的鱼吃掉第二轻的鱼，其重量变为两者之和。  \n该函数返回 'm' 轮后最轻鱼的重量。\n\n参数：\nn (Integer) -- 鱼的数量。  \nm (Integer) -- 游戏进行的轮数。  \nweights (Array of Integers) -- 一个数组，表示每条鱼的重量。\n\n示例：\n>>> final_min_weight_fish(1, [1, 2, 3])  \n3  \n>>> final_min_weight_fish(2, [4, 3, 2, 1])  \n4  ",
      "fr": "Calcule le poids minimum final des poissons dans un jeu de simulation d'alimentation.\nDans ce jeu, il y a 'n' poissons, chacun avec un poids initial donné dans le tableau 'weights'.\nLe jeu se déroule sur 'm' tours. À chaque tour, le poisson le plus léger mange le deuxième plus léger,\net son poids devient la somme des deux. La fonction renvoie le poids du poisson le plus léger\naprès 'm' tours.\n\nArguments:\nn (Integer) -- Le nombre de poissons.\nm (Integer) -- Le nombre de tours pendant lesquels le jeu sera joué.\nweights (Array of Integers) -- Un tableau représentant les poids de chaque poisson.\n\nExemple:\n>>> final_min_weight_fish(1, [1, 2, 3])\n3\n>>> final_min_weight_fish(2, [4, 3, 2, 1])\n4",
      "de": "Berechnet das endgültige Mindestgewicht der Fische in einem simulierten Fütterungsspiel. In diesem Spiel gibt es 'n' Fische, jeder mit einem Anfangsgewicht, das im 'weights'-Array angegeben ist. Das Spiel verläuft über 'm' Runden. In jeder Runde frisst der leichteste Fisch den zweitleichtesten, und sein Gewicht wird zur Summe beider. Die Funktion gibt das Gewicht des leichtesten Fisches nach 'm' Runden zurück.\n\nArgumente:\nn (Integer) -- Die Anzahl der Fische.\nm (Integer) -- Die Anzahl der Runden, die das Spiel gespielt wird.\nweights (Array von Integern) -- Ein Array, das die Gewichte jedes Fisches darstellt.\n\nBeispiel:\n>>> final_min_weight_fish(1, [1, 2, 3])\n3\n>>> final_min_weight_fish(2, [4, 3, 2, 1])\n4",
      "ha": "Lissafi na karshe na mafi karancin nauyin kifi a cikin wani wasan ciyarwa na kwaikwayo.\nA cikin wannan wasan, akwai 'n' kifi, kowanne da nauyin farko da aka bayar a cikin jerin 'weights'.\nWasan yana gudana har na tsawon zagaye 'm'. A kowane zagaye, mafi saukin kifi yana cin na biyu mafi sauki,\nkuma nauyinsa yana zama jimlar duka biyun. Aikin yana dawowa da nauyin mafi saukin kifi\nbayan zagaye 'm'.\n\nArguments:\nn (Integer) -- Yawan kifaye.\nm (Integer) -- Yawan zagayen da za a yi wasan.\nweights (Array of Integers) -- Jerin da ke wakiltar nauyin kowanne kifi.\n\nExample:\n>>> final_min_weight_fish(1, [1, 2, 3])\n3\n>>> final_min_weight_fish(2, [4, 3, 2, 1])\n4",
      "hi": "एक सिम्युलेटेड फीडिंग गेम में मछलियों के अंतिम न्यूनतम वजन की गणना करता है।\nइस खेल में, 'n' मछलियाँ हैं, प्रत्येक की प्रारंभिक वजन 'weights' array में दी गई है। खेल 'm' राउंड के लिए चलता है। प्रत्येक राउंड में, सबसे हल्की मछली दूसरी सबसे हल्की मछली को खाती है, और उसका वजन दोनों का योग बन जाता है। यह फ़ंक्शन 'm' राउंड के बाद सबसे हल्की मछली का वजन लौटाता है।\n\nArguments:\nn (Integer) -- मछलियों की संख्या।\nm (Integer) -- खेल कितने राउंड खेला जाएगा।\nweights (Array of Integers) -- प्रत्येक मछली के वजन को दर्शाने वाला एक array।\n\nExample:\n>>> final_min_weight_fish(1, [1, 2, 3])\n3\n>>> final_min_weight_fish(2, [4, 3, 2, 1])\n4",
      "hu": "Kiszámítja a halak végső minimális súlyát egy szimulált etetési játékban.\nEbben a játékban 'n' hal van, mindegyik kezdeti súlya a 'weights' tömbben van megadva.\nA játék 'm' fordulón keresztül zajlik. Minden fordulóban a legkönnyebb hal megeszi a második legkönnyebbet,\nés a súlya mindkettő összegévé válik. A függvény visszaadja a legkönnyebb hal súlyát 'm' forduló után.\n\nArgumentumok:\nn (Egész szám) -- A halak száma.\nm (Egész szám) -- A játék fordulóinak száma.\nweights (Egész számok tömbje) -- Egy tömb, amely az egyes halak súlyát ábrázolja.\n\nPélda:\n>>> final_min_weight_fish(1, [1, 2, 3])\n3\n>>> final_min_weight_fish(2, [4, 3, 2, 1])\n4"
    },
    "docstring_bertscore": {
      "sq": "0.9908538654748675",
      "hy": "0.9845527138972978",
      "bn": "0.9716111500513507",
      "bg": "0.9788851932352293",
      "zh": "0.9655135946143417",
      "fr": "0.9790607824920642",
      "de": "0.9874262996197295",
      "ha": "0.9842368915914523",
      "hi": "0.9869660730268717",
      "hu": "0.9765330122630141"
    }
  },
  {
    "task_id": "Ruby/19",
    "prompt": {
      "en": "# Sorts a list of patient information based on their age and registration order.\n# The function takes an array of arrays, where each sub-array contains a patient's ID (a string) and age (an integer).\n# The sorting criteria are as follows:\n# 1. Patients aged 60 and above are given priority over younger patients.\n# 2. Elderly patients (aged 60+) are sorted in descending order of age. If ages are equal, they are sorted by their registration order.\n# 3. Younger patients (below 60) are sorted based on their registration order.\n#\n# Example:\n# >>> sort_patients([[\"021075\", 40], [\"004003\", 15], [\"010158\", 67], [\"021033\", 75], [\"102012\", 30]])\n# [[\"021033\", 75], [\"010158\", 67], [\"021075\", 40], [\"004003\", 15], [\"102012\", 30]]\n\n\n\ndef sort_patients(patient_info)",
      "sq": "# Rendit një listë të informacionit të pacientëve bazuar në moshën dhe rendin e regjistrimit të tyre.\n# Funksioni merr një varg arraysh, ku secili nën-array përmban ID-në e pacientit (një string) dhe moshën (një numër i plotë).\n# Kriteret e renditjes janë si më poshtë:\n# 1. Pacientët e moshës 60 vjeç e lart kanë përparësi mbi pacientët më të rinj.\n# 2. Pacientët e moshuar (60+ vjeç) renditen në rend zbritës të moshës. Nëse moshat janë të barabarta, ata renditen sipas rendit të regjistrimit.\n# 3. Pacientët më të rinj (nën 60 vjeç) renditen bazuar në rendin e regjistrimit të tyre.\n#\n# Shembull:\n# >>> sort_patients([[\"021075\", 40], [\"004003\", 15], [\"010158\", 67], [\"021033\", 75], [\"102012\", 30]])\n# [[\"021033\", 75], [\"010158\", 67], [\"021075\", 40], [\"004003\", 15], [\"102012\", 30]]\n\n\n\ndef sort_patients(patient_info)",
      "hy": "# Տեսակավորում է հիվանդների տեղեկատվության ցուցակը՝ հիմնված նրանց տարիքին և գրանցման հերթականությանը:\n# Ֆունկցիան ընդունում է զանգվածների զանգված, որտեղ յուրաքանչյուր ենթազանգված պարունակում է հիվանդի ID (տող) և տարիքը (ամբողջ թիվ):\n# Տեսակավորման չափանիշներն են հետևյալը:\n# 1. 60 և ավելի բարձր տարիքի հիվանդները առաջնահերթություն ունեն ավելի երիտասարդ հիվանդների նկատմամբ:\n# 2. Տարեց հիվանդները (60+) տեսակավորվում են ըստ տարիքների նվազման կարգով: Եթե տարիքները հավասար են, ապա տեսակավորվում են ըստ գրանցման հերթականության:\n# 3. Ավելի երիտասարդ հիվանդները (60-ից ցածր) տեսակավորվում են ըստ գրանցման հերթականության:\n#\n# Օրինակ:\n# >>> sort_patients([[\"021075\", 40], [\"004003\", 15], [\"010158\", 67], [\"021033\", 75], [\"102012\", 30]])\n# [[\"021033\", 75], [\"010158\", 67], [\"021075\", 40], [\"004003\", 15], [\"102012\", 30]]\n\n\n\ndef sort_patients(patient_info)",
      "bn": "# রোগীদের তথ্যের তালিকাটি তাদের বয়স এবং নিবন্ধন ক্রম অনুযায়ী সাজায়।\n# ফাংশনটি একটি অ্যারের অ্যারে নেয়, যেখানে প্রতিটি সাব-অ্যারে একটি রোগীর আইডি (একটি স্ট্রিং) এবং বয়স (একটি পূর্ণসংখ্যা) থাকে।\n# সাজানোর মানদণ্ড নিম্নরূপ:\n# 1. ৬০ বছর বা তার বেশি বয়সী রোগীদের অগ্রাধিকার দেওয়া হয় অপেক্ষাকৃত কম বয়সী রোগীদের উপর।\n# 2. বয়স্ক রোগীরা (বয়স ৬০+) বয়সের অবতরণ ক্রমে সাজানো হয়। যদি বয়স সমান হয়, তাহলে তাদের নিবন্ধন ক্রম অনুযায়ী সাজানো হয়।\n# 3. অপেক্ষাকৃত কম বয়সী রোগীরা (৬০ বছরের নিচে) তাদের নিবন্ধন ক্রম অনুযায়ী সাজানো হয়।\n#\n# উদাহরণ:\n# >>> sort_patients([[\"021075\", 40], [\"004003\", 15], [\"010158\", 67], [\"021033\", 75], [\"102012\", 30]])\n# [[\"021033\", 75], [\"010158\", 67], [\"021075\", 40], [\"004003\", 15], [\"102012\", 30]]\n\n\n\ndef sort_patients(patient_info)",
      "bg": "# Сортира списък с информация за пациенти въз основа на тяхната възраст и ред на регистрация.\n# Функцията приема масив от масиви, където всеки подмасив съдържа ID на пациент (низ) и възраст (цяло число).\n# Критериите за сортиране са следните:\n# 1. Пациентите на възраст 60 и повече години имат приоритет пред по-младите пациенти.\n# 2. Възрастните пациенти (на 60+ години) се сортират в низходящ ред по възраст. Ако възрастите са равни, те се сортират по реда на регистрация.\n# 3. По-младите пациенти (под 60 години) се сортират въз основа на реда на регистрация.\n#\n# Пример:\n# >>> sort_patients([[\"021075\", 40], [\"004003\", 15], [\"010158\", 67], [\"021033\", 75], [\"102012\", 30]])\n# [[\"021033\", 75], [\"010158\", 67], [\"021075\", 40], [\"004003\", 15], [\"102012\", 30]]\n\n\n\ndef sort_patients(patient_info)",
      "zh": "# 根据患者的年龄和注册顺序对患者信息列表进行排序。\n# 该函数接收一个数组的数组，其中每个子数组包含一个患者的ID（字符串）和年龄（整数）。\n# 排序标准如下：\n# 1. 年龄在60岁及以上的患者优先于较年轻的患者。\n# 2. 老年患者（年龄60岁及以上）按年龄降序排序。如果年龄相同，则按注册顺序排序。\n# 3. 年轻患者（年龄低于60岁）按注册顺序排序。\n#\n# 示例：\n# >>> sort_patients([[\"021075\", 40], [\"004003\", 15], [\"010158\", 67], [\"021033\", 75], [\"102012\", 30]])\n# [[\"021033\", 75], [\"010158\", 67], [\"021075\", 40], [\"004003\", 15], [\"102012\", 30]]\n\n\n\ndef sort_patients(patient_info)",
      "fr": "# Trie une liste d'informations sur les patients en fonction de leur âge et de leur ordre d'enregistrement.\n# La fonction prend un tableau de tableaux, où chaque sous-tableau contient l'ID d'un patient (une chaîne) et l'âge (un entier).\n# Les critères de tri sont les suivants :\n# 1. Les patients âgés de 60 ans et plus ont la priorité sur les patients plus jeunes.\n# 2. Les patients âgés (60 ans et plus) sont triés par ordre décroissant d'âge. Si les âges sont égaux, ils sont triés par leur ordre d'enregistrement.\n# 3. Les patients plus jeunes (moins de 60 ans) sont triés en fonction de leur ordre d'enregistrement.\n#\n# Exemple :\n# >>> sort_patients([[\"021075\", 40], [\"004003\", 15], [\"010158\", 67], [\"021033\", 75], [\"102012\", 30]])\n# [[\"021033\", 75], [\"010158\", 67], [\"021075\", 40], [\"004003\", 15], [\"102012\", 30]]\n\n\n\ndef sort_patients(patient_info)",
      "de": "# Sortiert eine Liste von Patienteninformationen basierend auf ihrem Alter und ihrer Registrierungsreihenfolge.\n# Die Funktion nimmt ein Array von Arrays, wobei jedes Unter-Array die ID eines Patienten (ein String) und das Alter (ein Integer) enthält.\n# Die Sortierkriterien sind wie folgt:\n# 1. Patienten im Alter von 60 und älter haben Vorrang vor jüngeren Patienten.\n# 2. Ältere Patienten (im Alter von 60+) werden in absteigender Reihenfolge ihres Alters sortiert. Wenn das Alter gleich ist, werden sie nach ihrer Registrierungsreihenfolge sortiert.\n# 3. Jüngere Patienten (unter 60) werden basierend auf ihrer Registrierungsreihenfolge sortiert.\n#\n# Beispiel:\n# >>> sort_patients([[\"021075\", 40], [\"004003\", 15], [\"010158\", 67], [\"021033\", 75], [\"102012\", 30]])\n# [[\"021033\", 75], [\"010158\", 67], [\"021075\", 40], [\"004003\", 15], [\"102012\", 30]]\n\n\n\ndef sort_patients(patient_info)",
      "ha": "# Yana tsara jerin bayanan marasa lafiya bisa ga shekarunsu da kuma tsarin rijista.\n# Aikin yana ɗaukar jerin jerin, inda kowace ƙaramin jeri ke ɗauke da ID na mara lafiya (kirtani) da shekarunsu (adadi).\n# Ka'idojin tsarawa sune kamar haka:\n# 1. Marasa lafiya masu shekaru 60 da sama suna da fifiko akan marasa lafiya matasa.\n# 2. Marasa lafiya tsofaffi (masu shekaru 60+) ana tsara su ne a cikin tsarin raguwa na shekaru. Idan shekarun suna daidai, ana tsara su bisa ga tsarin rijistarsu.\n# 3. Marasa lafiya matasa (ƙasa da shekaru 60) ana tsara su bisa ga tsarin rijistarsu.\n#\n# Misali:\n# >>> sort_patients([[\"021075\", 40], [\"004003\", 15], [\"010158\", 67], [\"021033\", 75], [\"102012\", 30]])\n# [[\"021033\", 75], [\"010158\", 67], [\"021075\", 40], [\"004003\", 15], [\"102012\", 30]]\n\n\n\ndef sort_patients(patient_info)",
      "hi": "# मरीजों की जानकारी की सूची को उनकी उम्र और पंजीकरण क्रम के आधार पर छांटता है।\n# यह फ़ंक्शन एक सरणी का सरणी लेता है, जहाँ प्रत्येक उप-सरणी में एक मरीज का आईडी (एक स्ट्रिंग) और उम्र (एक पूर्णांक) होता है।\n# छांटने के मानदंड इस प्रकार हैं:\n# 1. 60 और उससे अधिक उम्र के मरीजों को छोटे मरीजों पर प्राथमिकता दी जाती है।\n# 2. वृद्ध मरीजों (60+ उम्र) को उम्र के अवरोही क्रम में छांटा जाता है। यदि उम्र समान है, तो उन्हें उनके पंजीकरण क्रम के अनुसार छांटा जाता है।\n# 3. छोटे मरीजों (60 से कम उम्र) को उनके पंजीकरण क्रम के आधार पर छांटा जाता है।\n#\n# उदाहरण:\n# >>> sort_patients([[\"021075\", 40], [\"004003\", 15], [\"010158\", 67], [\"021033\", 75], [\"102012\", 30]])\n# [[\"021033\", 75], [\"010158\", 67], [\"021075\", 40], [\"004003\", 15], [\"102012\", 30]]\n\ndef sort_patients(patient_info)",
      "hu": "# Egy listát rendez a betegek adatai alapján, életkoruk és regisztrációs sorrendjük szerint.\n# A függvény egy tömböt vesz át, ahol minden al-tömb tartalmazza a beteg azonosítóját (egy string) és életkorát (egy egész szám).\n# A rendezési kritériumok a következők:\n# 1. A 60 éves és idősebb betegek elsőbbséget élveznek a fiatalabb betegekkel szemben.\n# 2. Az idősebb betegek (60 év felett) csökkenő életkor szerint vannak rendezve. Ha az életkor megegyezik, akkor regisztrációs sorrendjük szerint vannak rendezve.\n# 3. A fiatalabb betegek (60 év alatt) a regisztrációs sorrendjük alapján vannak rendezve.\n#\n# Példa:\n# >>> sort_patients([[\"021075\", 40], [\"004003\", 15], [\"010158\", 67], [\"021033\", 75], [\"102012\", 30]])\n# [[\"021033\", 75], [\"010158\", 67], [\"021075\", 40], [\"004003\", 15], [\"102012\", 30]]\n\n\n\ndef sort_patients(patient_info)"
    },
    "prompt_bertscore": {
      "sq": "0.9820698341343617",
      "hy": "0.978683980659241",
      "bn": "0.978615254547403",
      "bg": "0.9708360943045525",
      "zh": "0.9720654177327774",
      "fr": "0.9848035840685448",
      "de": "0.9775345066441921",
      "ha": "0.9569516320398328",
      "hi": "0.9634879619885479",
      "hu": "0.9799488589256712"
    },
    "canonical_solution": "    elderly, non_elderly = patient_info.partition { |_, age| age >= 60 }\n    sorted_elderly = elderly.sort_by { |_, age| -age }\n    sorted_elderly + non_elderly\n  end",
    "instruction": {
      "en": "Write a ruby function `def sort_patients(patient_info)` to solve the following problem:\nSorts a list of patient information based on their age and registration order.\nThe function takes an array of arrays, where each sub-array contains a patient's ID (a string) and age (an integer).\nThe sorting criteria are as follows:\n1. Patients aged 60 and above are given priority over younger patients.\n2. Elderly patients (aged 60+) are sorted in descending order of age. If ages are equal, they are sorted by their registration order.\n3. Younger patients (below 60) are sorted based on their registration order.\n\nExample:\n>>> sort_patients([[\"021075\", 40], [\"004003\", 15], [\"010158\", 67], [\"021033\", 75], [\"102012\", 30]])\n[[\"021033\", 75], [\"010158\", 67], [\"021075\", 40], [\"004003\", 15], [\"102012\", 30]]",
      "sq": "Shkruani një funksion ruby `def sort_patients(patient_info)` për të zgjidhur problemin e mëposhtëm:\nRendit një listë të informacionit të pacientëve bazuar në moshën dhe rendin e regjistrimit të tyre.\nFunksioni merr një varg të vargjeve, ku secili nën-varg përmban ID-në e pacientit (një string) dhe moshën (një numër i plotë).\nKriteret e renditjes janë si më poshtë:\n1. Pacientët e moshës 60 vjeç e lart kanë përparësi mbi pacientët më të rinj.\n2. Pacientët e moshuar (mosha 60+) renditen në rend zbritës të moshës. Nëse moshat janë të barabarta, ata renditen sipas rendit të regjistrimit.\n3. Pacientët më të rinj (nën 60 vjeç) renditen bazuar në rendin e regjistrimit të tyre.\n\nShembull:\n>>> sort_patients([[\"021075\", 40], [\"004003\", 15], [\"010158\", 67], [\"021033\", 75], [\"102012\", 30]])\n[[\"021033\", 75], [\"010158\", 67], [\"021075\", 40], [\"004003\", 15], [\"102012\", 30]]",
      "hy": "Գրեք ruby ֆունկցիա `def sort_patients(patient_info)` հետևյալ խնդիրը լուծելու համար:\nԴասավորում է հիվանդների տեղեկատվության ցանկը ըստ նրանց տարիքի և գրանցման հերթականության:\nՖունկցիան ընդունում է զանգվածների զանգված, որտեղ յուրաքանչյուր ենթազանգված պարունակում է հիվանդի ID (տող) և տարիքը (ամբողջ թիվ):\nԴասավորման չափանիշները հետևյալն են.\n1. 60 և ավելի բարձր տարիքի հիվանդները առաջնահերթություն ունեն ավելի երիտասարդ հիվանդների նկատմամբ:\n2. Տարեց հիվանդները (60+) դասավորվում են ըստ տարիքի նվազման կարգով: Եթե տարիքները հավասար են, ապա դասավորվում են ըստ նրանց գրանցման հերթականության:\n3. Ավելի երիտասարդ հիվանդները (60-ից ցածր) դասավորվում են ըստ նրանց գրանցման հերթականության:\n\nՕրինակ:\n>>> sort_patients([[\"021075\", 40], [\"004003\", 15], [\"010158\", 67], [\"021033\", 75], [\"102012\", 30]])\n[[\"021033\", 75], [\"010158\", 67], [\"021075\", 40], [\"004003\", 15], [\"102012\", 30]]",
      "bn": "রুবি ফাংশন `def sort_patients(patient_info)` লিখুন নিম্নলিখিত সমস্যার সমাধানের জন্য:\nরোগীর তথ্যের একটি তালিকা তাদের বয়স এবং নিবন্ধন ক্রম অনুযায়ী সাজায়।\nফাংশনটি অ্যারে অফ অ্যারে নেয়, যেখানে প্রতিটি সাব-অ্যারে একটি রোগীর আইডি (একটি স্ট্রিং) এবং বয়স (একটি পূর্ণসংখ্যা) থাকে।\nসাজানোর মানদণ্ড নিম্নরূপ:\n1. ৬০ এবং তার বেশি বয়সের রোগীদের অগ্রাধিকার দেওয়া হয় অপেক্ষাকৃত কম বয়সী রোগীদের উপর।\n2. বয়স্ক রোগীরা (বয়স ৬০+) বয়সের অবতরণ ক্রমে সাজানো হয়। যদি বয়স সমান হয়, তবে তারা তাদের নিবন্ধন ক্রম অনুযায়ী সাজানো হয়।\n3. অপেক্ষাকৃত কম বয়সী রোগীরা (৬০ এর নিচে) তাদের নিবন্ধন ক্রম অনুযায়ী সাজানো হয়।\n\nউদাহরণ:\n>>> sort_patients([[\"021075\", 40], [\"004003\", 15], [\"010158\", 67], [\"021033\", 75], [\"102012\", 30]])\n[[\"021033\", 75], [\"010158\", 67], [\"021075\", 40], [\"004003\", 15], [\"102012\", 30]]",
      "bg": "Напишете Ruby функция `def sort_patients(patient_info)`, за да решите следния проблем:\nСортира списък с информация за пациенти въз основа на тяхната възраст и ред на регистрация.\nФункцията приема масив от масиви, където всеки подмасив съдържа идентификационен номер на пациент (низ) и възраст (цяло число).\nКритериите за сортиране са следните:\n1. Пациентите на възраст 60 и повече години имат приоритет пред по-младите пациенти.\n2. Възрастните пациенти (на 60+ години) се сортират в низходящ ред по възраст. Ако възрастите са равни, те се сортират по реда на регистрация.\n3. По-младите пациенти (под 60 години) се сортират въз основа на реда на регистрация.\n\nПример:\n>>> sort_patients([[\"021075\", 40], [\"004003\", 15], [\"010158\", 67], [\"021033\", 75], [\"102012\", 30]])\n[[\"021033\", 75], [\"010158\", 67], [\"021075\", 40], [\"004003\", 15], [\"102012\", 30]]",
      "zh": "编写一个 ruby 函数 `def sort_patients(patient_info)` 来解决以下问题：\n对患者信息列表进行排序，排序依据是他们的年龄和注册顺序。\n该函数接收一个数组的数组，其中每个子数组包含一个患者的 ID（字符串）和年龄（整数）。\n排序标准如下：\n1. 年龄在 60 岁及以上的患者优先于年轻患者。\n2. 老年患者（60 岁及以上）按年龄降序排序。如果年龄相同，则按注册顺序排序。\n3. 年轻患者（60 岁以下）按注册顺序排序。\n\n示例：\n>>> sort_patients([[\"021075\", 40], [\"004003\", 15], [\"010158\", 67], [\"021033\", 75], [\"102012\", 30]])\n[[\"021033\", 75], [\"010158\", 67], [\"021075\", 40], [\"004003\", 15], [\"102012\", 30]]",
      "fr": "Écrire une fonction ruby `def sort_patients(patient_info)` pour résoudre le problème suivant :\nTrie une liste d'informations sur les patients en fonction de leur âge et de leur ordre d'enregistrement.\nLa fonction prend un tableau de tableaux, où chaque sous-tableau contient l'ID d'un patient (une chaîne de caractères) et l'âge (un entier).\nLes critères de tri sont les suivants :\n1. Les patients âgés de 60 ans et plus ont la priorité sur les patients plus jeunes.\n2. Les patients âgés (60 ans et plus) sont triés par ordre décroissant d'âge. Si les âges sont égaux, ils sont triés par leur ordre d'enregistrement.\n3. Les patients plus jeunes (moins de 60 ans) sont triés en fonction de leur ordre d'enregistrement.\n\nExemple :\n>>> sort_patients([[\"021075\", 40], [\"004003\", 15], [\"010158\", 67], [\"021033\", 75], [\"102012\", 30]])\n[[\"021033\", 75], [\"010158\", 67], [\"021075\", 40], [\"004003\", 15], [\"102012\", 30]]",
      "de": "Schreiben Sie eine Ruby-Funktion `def sort_patients(patient_info)`, um das folgende Problem zu lösen:\nSortiert eine Liste von Patienteninformationen basierend auf ihrem Alter und ihrer Registrierungsreihenfolge.\nDie Funktion nimmt ein Array von Arrays, wobei jedes Unter-Array die ID eines Patienten (ein String) und das Alter (ein Integer) enthält.\nDie Sortierkriterien sind wie folgt:\n1. Patienten im Alter von 60 Jahren und älter haben Vorrang vor jüngeren Patienten.\n2. Ältere Patienten (ab 60 Jahren) werden in absteigender Reihenfolge ihres Alters sortiert. Wenn das Alter gleich ist, werden sie nach ihrer Registrierungsreihenfolge sortiert.\n3. Jüngere Patienten (unter 60 Jahren) werden basierend auf ihrer Registrierungsreihenfolge sortiert.\n\nBeispiel:\n>>> sort_patients([[\"021075\", 40], [\"004003\", 15], [\"010158\", 67], [\"021033\", 75], [\"102012\", 30]])\n[[\"021033\", 75], [\"010158\", 67], [\"021075\", 40], [\"004003\", 15], [\"102012\", 30]]",
      "ha": "Rubuta wani aikin ruby `def sort_patients(patient_info)` don warware matsalar mai zuwa:\nTana tsara jerin bayanan marasa lafiya bisa ga shekarunsu da kuma tsarin rijista.\nAikin yana karɓar wani array na arrays, inda kowanne ƙaramin array ya ƙunshi ID na mara lafiya (wani kirtani) da kuma shekaru (wani lamba).\nKa'idojin tsarawa sune kamar haka:\n1. Marasa lafiya masu shekaru 60 da sama suna da fifiko akan marasa lafiya matasa.\n2. Marasa lafiya tsofaffi (masu shekaru 60+) ana tsara su a cikin tsarin raguwa na shekaru. Idan shekarun sun yi daidai, ana tsara su bisa ga tsarin rijistarsu.\n3. Marasa lafiya matasa (ƙasa da shekaru 60) ana tsara su bisa ga tsarin rijistarsu.\n\nMisali:\n>>> sort_patients([[\"021075\", 40], [\"004003\", 15], [\"010158\", 67], [\"021033\", 75], [\"102012\", 30]])\n[[\"021033\", 75], [\"010158\", 67], [\"021075\", 40], [\"004003\", 15], [\"102012\", 30]]",
      "hi": "रूबी फ़ंक्शन `def sort_patients(patient_info)` लिखें ताकि निम्नलिखित समस्या का समाधान किया जा सके:\nरोगियों की जानकारी की सूची को उनकी आयु और पंजीकरण क्रम के आधार पर क्रमबद्ध करता है।\nयह फ़ंक्शन उप-ऐरे की एक सरणी लेता है, जहाँ प्रत्येक उप-ऐरे में एक रोगी की आईडी (एक स्ट्रिंग) और आयु (एक पूर्णांक) होती है।\nक्रमबद्ध करने के मानदंड निम्नलिखित हैं:\n1. 60 वर्ष और उससे अधिक आयु के रोगियों को छोटे रोगियों पर प्राथमिकता दी जाती है।\n2. वृद्ध रोगियों (60+ आयु) को आयु के अवरोही क्रम में क्रमबद्ध किया जाता है। यदि आयु समान है, तो उन्हें उनके पंजीकरण क्रम के अनुसार क्रमबद्ध किया जाता है।\n3. छोटे रोगियों (60 से कम आयु) को उनके पंजीकरण क्रम के आधार पर क्रमबद्ध किया जाता है।\n\nउदाहरण:\n>>> sort_patients([[\"021075\", 40], [\"004003\", 15], [\"010158\", 67], [\"021033\", 75], [\"102012\", 30]])\n[[\"021033\", 75], [\"010158\", 67], [\"021075\", 40], [\"004003\", 15], [\"102012\", 30]]",
      "hu": "Írj egy ruby függvényt `def sort_patients(patient_info)` a következő probléma megoldására:\nRendezi a betegek információit tartalmazó listát életkor és regisztrációs sorrend alapján.\nA függvény egy tömböt vesz át, amely tömbökből áll, ahol minden egyes tömb egy beteg azonosítóját (egy string) és életkorát (egy egész szám) tartalmazza.\nA rendezési kritériumok a következők:\n1. A 60 éves és idősebb betegek elsőbbséget élveznek a fiatalabb betegekkel szemben.\n2. Az idősebb betegek (60+) csökkenő életkor szerinti sorrendben vannak rendezve. Ha az életkorok megegyeznek, akkor a regisztrációs sorrendjük alapján vannak rendezve.\n3. A fiatalabb betegek (60 év alatt) a regisztrációs sorrendjük alapján vannak rendezve.\n\nPélda:\n>>> sort_patients([[\"021075\", 40], [\"004003\", 15], [\"010158\", 67], [\"021033\", 75], [\"102012\", 30]])\n[[\"021033\", 75], [\"010158\", 67], [\"021075\", 40], [\"004003\", 15], [\"102012\", 30]]"
    },
    "instruction_bertscore": {
      "sq": "0.9868663605755922",
      "hy": "0.9748605444547004",
      "bn": "0.9826979033991939",
      "bg": "0.970007606985256",
      "zh": "0.9710520055287375",
      "fr": "0.9836336511242494",
      "de": "0.979361508888951",
      "ha": "0.9818694160798975",
      "hi": "0.9638266267882124",
      "hu": "0.9696117366358535"
    },
    "level": "easy",
    "test": "raise 'Test failed' unless sort_patients([[\"021075\", 40], [\"004003\", 15], [\"010158\", 67], [\"021033\", 75], [\"102012\", 30]]) == [[\"021033\", 75], [\"010158\", 67], [\"021075\", 40], [\"004003\", 15], [\"102012\", 30]]\nraise 'Test failed' unless sort_patients([[\"001122\", 60], [\"003344\", 60], [\"005566\", 30]]) == [[\"001122\", 60], [\"003344\", 60], [\"005566\", 30]]\nraise 'Test failed' unless sort_patients([[\"987654\", 45], [\"123456\", 65], [\"543210\", 55]]) == [[\"123456\", 65], [\"987654\", 45], [\"543210\", 55]]\n\n\n\nputs 'All tests passed!'",
    "entry_point": "sort_patients",
    "signature": "def sort_patients(patient_info)",
    "docstring": {
      "en": "Sorts a list of patient information based on their age and registration order.\nThe function takes an array of arrays, where each sub-array contains a patient's ID (a string) and age (an integer).\nThe sorting criteria are as follows:\n1. Patients aged 60 and above are given priority over younger patients.\n2. Elderly patients (aged 60+) are sorted in descending order of age. If ages are equal, they are sorted by their registration order.\n3. Younger patients (below 60) are sorted based on their registration order.\n\nExample:\n>>> sort_patients([[\"021075\", 40], [\"004003\", 15], [\"010158\", 67], [\"021033\", 75], [\"102012\", 30]])\n[[\"021033\", 75], [\"010158\", 67], [\"021075\", 40], [\"004003\", 15], [\"102012\", 30]]",
      "sq": "Rendit një listë të informacionit të pacientëve bazuar në moshën dhe rendin e regjistrimit të tyre. Funksioni merr një varg me vargje, ku çdo nënvarg përmban ID-në e pacientit (një varg) dhe moshën (një numër i plotë). Kriteret e renditjes janë si më poshtë: \n1. Pacientët e moshës 60 vjeç e lart kanë përparësi mbi pacientët më të rinj. \n2. Pacientët e moshuar (60+ vjeç) renditen në rend zbritës të moshës. Nëse moshat janë të barabarta, ata renditen sipas rendit të regjistrimit. \n3. Pacientët më të rinj (nën 60 vjeç) renditen bazuar në rendin e regjistrimit të tyre.\n\nShembull:\n>>> sort_patients([[\"021075\", 40], [\"004003\", 15], [\"010158\", 67], [\"021033\", 75], [\"102012\", 30]])\n[[\"021033\", 75], [\"010158\", 67], [\"021075\", 40], [\"004003\", 15], [\"102012\", 30]]",
      "hy": "Դասավորում է հիվանդների տեղեկատվության ցուցակը՝ հիմնված նրանց տարիքին և գրանցման կարգին։\nՖունկցիան ընդունում է զանգվածների զանգված, որտեղ յուրաքանչյուր ենթազանգված պարունակում է հիվանդի ID-ն (տող) և տարիքը (ամբողջ թիվ)։\nԴասավորման չափանիշներն են հետևյալը.\n1. 60 և ավելի բարձր տարիքի հիվանդները առաջնահերթություն են ստանում ավելի երիտասարդ հիվանդների նկատմամբ։\n2. Տարեց հիվանդները (60+ տարեկան) դասավորվում են տարիքի նվազման կարգով։ Եթե տարիքները հավասար են, ապա դրանք դասավորվում են գրանցման կարգով։\n3. Ավելի երիտասարդ հիվանդները (60-ից ցածր) դասավորվում են գրանցման կարգով։\n\nՕրինակ:\n>>> sort_patients([[\"021075\", 40], [\"004003\", 15], [\"010158\", 67], [\"021033\", 75], [\"102012\", 30]])\n[[\"021033\", 75], [\"010158\", 67], [\"021075\", 40], [\"004003\", 15], [\"102012\", 30]]",
      "bn": "রোগীর তথ্যের একটি তালিকা তাদের বয়স এবং নিবন্ধন ক্রম অনুসারে সাজায়। \nফাংশনটি একটি অ্যারের অ্যারে নেয়, যেখানে প্রতিটি সাব-অ্যারে একটি রোগীর আইডি (একটি স্ট্রিং) এবং বয়স (একটি পূর্ণসংখ্যা) থাকে। \nসাজানোর মানদণ্ড নিম্নরূপ:\n1. ৬০ এবং তার বেশি বয়সের রোগীদের অগ্রাধিকার দেওয়া হয় অপেক্ষাকৃত কম বয়সী রোগীদের উপর।\n2. প্রবীণ রোগীরা (বয়স ৬০+) বয়সের অবতরণ ক্রমে সাজানো হয়। যদি বয়স সমান হয়, তাহলে তারা তাদের নিবন্ধন ক্রম অনুসারে সাজানো হয়।\n3. অপেক্ষাকৃত কম বয়সী রোগীরা (৬০ বছরের নিচে) তাদের নিবন্ধন ক্রম অনুসারে সাজানো হয়।\n\nউদাহরণ:\n>>> sort_patients([[\"021075\", 40], [\"004003\", 15], [\"010158\", 67], [\"021033\", 75], [\"102012\", 30]])\n[[\"021033\", 75], [\"010158\", 67], [\"021075\", 40], [\"004003\", 15], [\"102012\", 30]]",
      "bg": "Сортира списък с информация за пациенти на базата на тяхната възраст и ред на регистрация.\nФункцията приема масив от масиви, където всеки подмасив съдържа идентификатор на пациент (низ) и възраст (цяло число).\nКритериите за сортиране са следните:\n1. Пациентите на възраст 60 и повече години имат приоритет пред по-младите пациенти.\n2. Възрастните пациенти (на възраст 60+) се сортират в низходящ ред на възраст. Ако възрастите са равни, те се сортират по ред на регистрация.\n3. По-младите пациенти (под 60 години) се сортират на базата на реда на регистрация.\n\nПример:\n>>> sort_patients([[\"021075\", 40], [\"004003\", 15], [\"010158\", 67], [\"021033\", 75], [\"102012\", 30]])\n[[\"021033\", 75], [\"010158\", 67], [\"021075\", 40], [\"004003\", 15], [\"102012\", 30]]",
      "zh": "根据患者的年龄和注册顺序对患者信息列表进行排序。\n该函数接收一个数组的数组，其中每个子数组包含患者的ID（字符串）和年龄（整数）。\n排序标准如下：\n1. 年龄在60岁及以上的患者优先于年轻患者。\n2. 老年患者（60岁及以上）按年龄降序排序。如果年龄相同，则按注册顺序排序。\n3. 年轻患者（60岁以下）按注册顺序排序。\n\n例子：\n>>> sort_patients([[\"021075\", 40], [\"004003\", 15], [\"010158\", 67], [\"021033\", 75], [\"102012\", 30]])\n[[\"021033\", 75], [\"010158\", 67], [\"021075\", 40], [\"004003\", 15], [\"102012\", 30]]",
      "fr": "Trie une liste d'informations sur les patients en fonction de leur âge et de leur ordre d'enregistrement.\nLa fonction prend un tableau de tableaux, où chaque sous-tableau contient l'ID d'un patient (une chaîne) et l'âge (un entier).\nLes critères de tri sont les suivants :\n1. Les patients âgés de 60 ans et plus sont prioritaires par rapport aux patients plus jeunes.\n2. Les patients âgés (60 ans et plus) sont triés par ordre décroissant d'âge. Si les âges sont égaux, ils sont triés par leur ordre d'enregistrement.\n3. Les patients plus jeunes (moins de 60 ans) sont triés en fonction de leur ordre d'enregistrement.\n\nExemple :\n>>> sort_patients([[\"021075\", 40], [\"004003\", 15], [\"010158\", 67], [\"021033\", 75], [\"102012\", 30]])\n[[\"021033\", 75], [\"010158\", 67], [\"021075\", 40], [\"004003\", 15], [\"102012\", 30]]",
      "de": "Sortiert eine Liste von Patienteninformationen basierend auf ihrem Alter und ihrer Registrierungsreihenfolge.\nDie Funktion nimmt ein Array von Arrays, wobei jedes Unter-Array die ID eines Patienten (ein String) und das Alter (ein Integer) enthält.\nDie Sortierkriterien sind wie folgt:\n1. Patienten im Alter von 60 Jahren und älter haben Vorrang vor jüngeren Patienten.\n2. Ältere Patienten (ab 60 Jahren) werden in absteigender Reihenfolge ihres Alters sortiert. Wenn das Alter gleich ist, werden sie nach ihrer Registrierungsreihenfolge sortiert.\n3. Jüngere Patienten (unter 60 Jahren) werden basierend auf ihrer Registrierungsreihenfolge sortiert.\n\nBeispiel:\n>>> sort_patients([[\"021075\", 40], [\"004003\", 15], [\"010158\", 67], [\"021033\", 75], [\"102012\", 30]])\n[[\"021033\", 75], [\"010158\", 67], [\"021075\", 40], [\"004003\", 15], [\"102012\", 30]]",
      "ha": "Yana tsara jerin bayanan marasa lafiya bisa ga shekarunsu da kuma tsarin rajista. Aikin yana karɓar jerin jerin, inda kowace ƙaramin jeri ke ɗauke da ID na mara lafiya (kirtani) da shekaru (lamba).\n\nKa'idojin tsara su ne kamar haka:\n1. Ana ba marasa lafiya masu shekaru 60 da sama fifiko akan marasa lafiya matasa.\n2. Ana tsara tsofaffin marasa lafiya (masu shekaru 60+) a cikin tsarin raguwa na shekaru. Idan shekarun sun yi daidai, ana tsara su bisa ga tsarin rajistarsu.\n3. Ana tsara marasa lafiya matasa (ƙasa da shekaru 60) bisa ga tsarin rajistarsu.\n\nMisali:\n>>> sort_patients([[\"021075\", 40], [\"004003\", 15], [\"010158\", 67], [\"021033\", 75], [\"102012\", 30]])\n[[\"021033\", 75], [\"010158\", 67], [\"021075\", 40], [\"004003\", 15], [\"102012\", 30]]",
      "hi": "उम्र और पंजीकरण क्रम के आधार पर रोगी जानकारी की सूची को क्रमबद्ध करता है।\nयह फ़ंक्शन एक सरणी की सरणी लेता है, जहाँ प्रत्येक उप-सरणी में एक रोगी का आईडी (एक स्ट्रिंग) और उम्र (एक पूर्णांक) होता है।\nक्रमबद्ध करने के मानदंड निम्नलिखित हैं:\n1. 60 और उससे अधिक उम्र के रोगियों को छोटे रोगियों पर प्राथमिकता दी जाती है।\n2. वृद्ध रोगियों (उम्र 60+) को उम्र के अवरोही क्रम में क्रमबद्ध किया जाता है। यदि उम्र समान है, तो उन्हें उनके पंजीकरण क्रम के अनुसार क्रमबद्ध किया जाता है।\n3. छोटे रोगियों (60 से कम उम्र) को उनके पंजीकरण क्रम के आधार पर क्रमबद्ध किया जाता है।\n\nउदाहरण:\n>>> sort_patients([[\"021075\", 40], [\"004003\", 15], [\"010158\", 67], [\"021033\", 75], [\"102012\", 30]])\n[[\"021033\", 75], [\"010158\", 67], [\"021075\", 40], [\"004003\", 15], [\"102012\", 30]]",
      "hu": "Rendezi a betegek adatait tartalmazó listát életkoruk és regisztrációs sorrendjük alapján.\nA függvény egy tömböt vesz át, ahol minden al-tömb egy beteg azonosítóját (egy string) és életkorát (egy egész szám) tartalmazza.\nA rendezési kritériumok a következők:\n1. A 60 éves és idősebb betegek előnyt élveznek a fiatalabb betegekkel szemben.\n2. Az idős betegek (60 éves és idősebbek) életkoruk csökkenő sorrendjében vannak rendezve. Ha az életkorok megegyeznek, akkor regisztrációs sorrendjük alapján vannak rendezve.\n3. A fiatalabb betegek (60 év alattiak) regisztrációs sorrendjük alapján vannak rendezve.\n\nPélda:\n>>> sort_patients([[\"021075\", 40], [\"004003\", 15], [\"010158\", 67], [\"021033\", 75], [\"102012\", 30]])\n[[\"021033\", 75], [\"010158\", 67], [\"021075\", 40], [\"004003\", 15], [\"102012\", 30]]"
    },
    "docstring_bertscore": {
      "sq": "0.9761546213871427",
      "hy": "0.97280869261861",
      "bn": "0.9783870282395938",
      "bg": "0.9717491981661699",
      "zh": "0.963898928246909",
      "fr": "0.9834461440445524",
      "de": "0.9692661197728528",
      "ha": "0.9603581430745811",
      "hi": "0.9815603472070072",
      "hu": "0.9743790644110718"
    }
  },
  {
    "task_id": "Ruby/20",
    "prompt": {
      "en": "# Finds the intersection point of two linear functions.\n# This function takes four arguments: slope1, intercept1, slope2, intercept2.\n# slope1 and slope2 are the slopes of the two lines, while intercept1 and intercept2 are their y-intercepts.\n# The function calculates and returns the coordinates of the intersection point of these two lines, if it exists.\n# The coordinates are returned as a two-element array [x, y], rounded to two decimal places.\n#\n# Example:\n# >>> find_intersection(1.0, 0.0, -1.0, 2.0)\n# [1.00, 1.00]\n# >>> find_intersection(2.0, 3.0, 2.0, -1.0)\n# nil # Parallel lines with no intersection\n\n\ndef find_intersection(slope1, intercept1, slope2, intercept2)",
      "sq": "# Gjen pikën e prerjes së dy funksioneve lineare.\n# Kjo funksion merr katër argumente: slope1, intercept1, slope2, intercept2.\n# slope1 dhe slope2 janë pjerrësitë e dy vijave, ndërsa intercept1 dhe intercept2 janë prerjet e tyre në boshtin y.\n# Funksioni llogarit dhe kthen koordinatat e pikës së prerjes së këtyre dy vijave, nëse ekziston.\n# Koordinatat kthehen si një varg me dy elemente [x, y], të rrumbullakosura në dy vende dhjetore.\n#\n# Shembull:\n# >>> find_intersection(1.0, 0.0, -1.0, 2.0)\n# [1.00, 1.00]\n# >>> find_intersection(2.0, 3.0, 2.0, -1.0)\n# nil # Vija paralele pa pikë prerjeje\n\n\ndef find_intersection(slope1, intercept1, slope2, intercept2)",
      "hy": "# Գտնում է երկու գծային ֆունկցիաների հատման կետը:\n# Այս ֆունկցիան ընդունում է չորս արգումենտ՝ slope1, intercept1, slope2, intercept2:\n# slope1 և slope2-ը երկու գծերի թեքություններն են, իսկ intercept1 և intercept2-ը՝ նրանց y-հատումները:\n# Ֆունկցիան հաշվում և վերադարձնում է այս երկու գծերի հատման կետի կոորդինատները, եթե այն գոյություն ունի:\n# Կոորդինատները վերադարձվում են որպես երկու տարրից բաղկացած զանգված [x, y], կլորացված մինչև երկու տասնորդական տեղ:\n#\n# Օրինակ:\n# >>> find_intersection(1.0, 0.0, -1.0, 2.0)\n# [1.00, 1.00]\n# >>> find_intersection(2.0, 3.0, 2.0, -1.0)\n# nil # Զուգահեռ գծեր, որոնք չունեն հատման կետ\n",
      "bn": "# দুটি সরল রেখার ছেদ বিন্দু খুঁজে বের করে।\n# এই ফাংশনটি চারটি আর্গুমেন্ট নেয়: slope1, intercept1, slope2, intercept2।\n# slope1 এবং slope2 হল দুটি রেখার ঢাল, যেখানে intercept1 এবং intercept2 হল তাদের y-অবস্থান।\n# ফাংশনটি এই দুটি রেখার ছেদ বিন্দুর স্থানাঙ্ক হিসাব করে এবং ফেরত দেয়, যদি এটি বিদ্যমান থাকে।\n# স্থানাঙ্কগুলি একটি দুই-উপাদান বিশিষ্ট অ্যারে [x, y] হিসাবে ফেরত দেওয়া হয়, যা দুই দশমিক স্থানে গড়ানো হয়।\n#\n# উদাহরণ:\n# >>> find_intersection(1.0, 0.0, -1.0, 2.0)\n# [1.00, 1.00]\n# >>> find_intersection(2.0, 3.0, 2.0, -1.0)\n# nil # সমান্তরাল রেখা, কোন ছেদ বিন্দু নেই\n\n\ndef find_intersection(slope1, intercept1, slope2, intercept2)",
      "bg": "# Намира точката на пресичане на две линейни функции.\n# Тази функция приема четири аргумента: slope1, intercept1, slope2, intercept2.\n# slope1 и slope2 са наклоните на двете прави, докато intercept1 и intercept2 са техните y-пресечни точки.\n# Функцията изчислява и връща координатите на точката на пресичане на тези две прави, ако съществува.\n# Координатите се връщат като масив с два елемента [x, y], закръглени до два знака след десетичната запетая.\n#\n# Пример:\n# >>> find_intersection(1.0, 0.0, -1.0, 2.0)\n# [1.00, 1.00]\n# >>> find_intersection(2.0, 3.0, 2.0, -1.0)\n# nil # Успоредни прави без пресечна точка\n\n\ndef find_intersection(slope1, intercept1, slope2, intercept2)",
      "zh": "# 找到两个线性函数的交点。\n# 此函数接受四个参数：slope1, intercept1, slope2, intercept2。\n# slope1 和 slope2 是两条直线的斜率，而 intercept1 和 intercept2 是它们的 y 截距。\n# 该函数计算并返回这两条直线的交点坐标（如果存在）。\n# 坐标以一个两元素数组 [x, y] 的形式返回，保留两位小数。\n#\n# 示例:\n# >>> find_intersection(1.0, 0.0, -1.0, 2.0)\n# [1.00, 1.00]\n# >>> find_intersection(2.0, 3.0, 2.0, -1.0)\n# nil # 平行线没有交点\n\ndef find_intersection(slope1, intercept1, slope2, intercept2)",
      "fr": "# Trouve le point d'intersection de deux fonctions linéaires.\n# Cette fonction prend quatre arguments : slope1, intercept1, slope2, intercept2.\n# slope1 et slope2 sont les pentes des deux lignes, tandis que intercept1 et intercept2 sont leurs ordonnées à l'origine.\n# La fonction calcule et renvoie les coordonnées du point d'intersection de ces deux lignes, si celui-ci existe.\n# Les coordonnées sont renvoyées sous forme d'un tableau à deux éléments [x, y], arrondies à deux décimales.\n#\n# Exemple :\n# >>> find_intersection(1.0, 0.0, -1.0, 2.0)\n# [1.00, 1.00]\n# >>> find_intersection(2.0, 3.0, 2.0, -1.0)\n# nil # Lignes parallèles sans intersection\n\n\ndef find_intersection(slope1, intercept1, slope2, intercept2)",
      "de": "# Findet den Schnittpunkt von zwei linearen Funktionen.\n# Diese Funktion nimmt vier Argumente: slope1, intercept1, slope2, intercept2.\n# slope1 und slope2 sind die Steigungen der beiden Linien, während intercept1 und intercept2 ihre y-Achsenabschnitte sind.\n# Die Funktion berechnet und gibt die Koordinaten des Schnittpunkts dieser beiden Linien zurück, falls er existiert.\n# Die Koordinaten werden als ein zwei Elemente umfassendes Array [x, y] zurückgegeben, gerundet auf zwei Dezimalstellen.\n#\n# Beispiel:\n# >>> find_intersection(1.0, 0.0, -1.0, 2.0)\n# [1.00, 1.00]\n# >>> find_intersection(2.0, 3.0, 2.0, -1.0)\n# nil # Parallele Linien ohne Schnittpunkt\n\n\ndef find_intersection(slope1, intercept1, slope2, intercept2)",
      "ha": "# Nemi wurin haɗuwa na hanyoyi biyu na layi.\n# Wannan aikin yana ɗaukar huɗu huɗu: slope1, intercept1, slope2, intercept2.\n# slope1 da slope2 su ne gangaren layukan biyu, yayin da intercept1 da intercept2 su ne y-intercepts ɗinsu.\n# Aikin yana lissafi kuma yana mayar da haɗin wurin haɗuwa na waɗannan layukan biyu, idan yana akwai.\n# Ana mayar da haɗin a matsayin jerin abubuwa guda biyu [x, y], an zagaye zuwa wurare biyu na adadi.\n#\n# Misali:\n# >>> find_intersection(1.0, 0.0, -1.0, 2.0)\n# [1.00, 1.00]\n# >>> find_intersection(2.0, 3.0, 2.0, -1.0)\n# nil # Layukan da ke layi daya ba tare da haɗuwa ba\n\n\ndef find_intersection(slope1, intercept1, slope2, intercept2)",
      "hi": "# दो रेखीय फलनों के प्रतिच्छेदन बिंदु को खोजता है।\n# यह फ़ंक्शन चार तर्क लेता है: slope1, intercept1, slope2, intercept2।\n# slope1 और slope2 दो रेखाओं के ढलान हैं, जबकि intercept1 और intercept2 उनके y-अवरोधक हैं।\n# फ़ंक्शन इन दो रेखाओं के प्रतिच्छेदन बिंदु के निर्देशांक की गणना करता है और लौटाता है, यदि यह मौजूद है।\n# निर्देशांक को [x, y] के रूप में दो तत्वों की सूची के रूप में लौटाया जाता है, जो दो दशमलव स्थानों तक गोल होते हैं।\n#\n# उदाहरण:\n# >>> find_intersection(1.0, 0.0, -1.0, 2.0)\n# [1.00, 1.00]\n# >>> find_intersection(2.0, 3.0, 2.0, -1.0)\n# nil # समानांतर रेखाएं जिनका कोई प्रतिच्छेदन नहीं है\n\n\ndef find_intersection(slope1, intercept1, slope2, intercept2)",
      "hu": "# Megtalálja két lineáris függvény metszéspontját.\n# Ez a függvény négy argumentumot vesz: slope1, intercept1, slope2, intercept2.\n# A slope1 és slope2 a két egyenes meredekségei, míg az intercept1 és intercept2 azok y-metszetei.\n# A függvény kiszámítja és visszaadja a két egyenes metszéspontjának koordinátáit, ha létezik.\n# A koordináták egy kételemű tömbként [x, y] kerülnek visszaadásra, két tizedesjegyre kerekítve.\n#\n# Példa:\n# >>> find_intersection(1.0, 0.0, -1.0, 2.0)\n# [1.00, 1.00]\n# >>> find_intersection(2.0, 3.0, 2.0, -1.0)\n# nil # Párhuzamos egyenesek, nincs metszéspont\n\n\ndef find_intersection(slope1, intercept1, slope2, intercept2)"
    },
    "prompt_bertscore": {
      "sq": "0.9895786584286236",
      "hy": "0.9737035224851722",
      "bn": "0.9859776882508421",
      "bg": "0.9935540468746558",
      "zh": "0.9869817648269734",
      "fr": "0.9954424259071545",
      "de": "1",
      "ha": "0.9778338426284117",
      "hi": "0.9933752795317244",
      "hu": "0.9876618752516368"
    },
    "canonical_solution": "    # Handle parallel lines which never intersect\n    return nil if slope1 == slope2\n  \n    # Calculate intersection point\n    x = (intercept2 - intercept1).to_f / (slope1 - slope2)\n    y = slope1 * x + intercept1\n  \n    # Round the coordinates to two decimal places\n    [x.round(2), y.round(2)]\n  end",
    "instruction": {
      "en": "Write a ruby function `def find_intersection(slope1, intercept1, slope2, intercept2)` to solve the following problem:\nFinds the intersection point of two linear functions.\nThis function takes four arguments: slope1, intercept1, slope2, intercept2.\nslope1 and slope2 are the slopes of the two lines, while intercept1 and intercept2 are their y-intercepts.\nThe function calculates and returns the coordinates of the intersection point of these two lines, if it exists.\nThe coordinates are returned as a two-element array [x, y], rounded to two decimal places.\n\nExample:\n>>> find_intersection(1.0, 0.0, -1.0, 2.0)\n[1.00, 1.00]\n>>> find_intersection(2.0, 3.0, 2.0, -1.0)\nnil  Parallel lines with no intersection",
      "sq": "Shkruani një funksion ruby `def find_intersection(slope1, intercept1, slope2, intercept2)` për të zgjidhur problemin në vijim:\nGjen pikën e prerjes së dy funksioneve lineare.\nKy funksion merr katër argumente: slope1, intercept1, slope2, intercept2.\nslope1 dhe slope2 janë pjerrësitë e dy linjave, ndërsa intercept1 dhe intercept2 janë prerjet e tyre në boshtin y.\nFunksioni llogarit dhe kthen koordinatat e pikës së prerjes së këtyre dy linjave, nëse ekziston.\nKoordinatat kthehen si një varg me dy elemente [x, y], të rrumbullakosura në dy vende dhjetore.\n\nShembull:\n>>> find_intersection(1.0, 0.0, -1.0, 2.0)\n[1.00, 1.00]\n>>> find_intersection(2.0, 3.0, 2.0, -1.0)\nnil  Linja paralele pa pikë prerjeje",
      "hy": "Ruby ֆունկցիա գրեք `def find_intersection(slope1, intercept1, slope2, intercept2)` հետևյալ խնդիրը լուծելու համար:\nԳտնում է երկու գծային ֆունկցիաների հատման կետը։\nԱյս ֆունկցիան ընդունում է չորս արգումենտ՝ slope1, intercept1, slope2, intercept2։\nslope1 և slope2-ը երկու գծերի թեքություններն են, իսկ intercept1 և intercept2-ը նրանց y-հատումները։\nՖունկցիան հաշվարկում և վերադարձնում է այս երկու գծերի հատման կետի կոորդինատները, եթե այն գոյություն ունի։\nԿոորդինատները վերադարձվում են որպես երկու տարրից բաղկացած զանգված [x, y], կլորացված մինչև երկու տասնորդական։\n\nՕրինակ:\n>>> find_intersection(1.0, 0.0, -1.0, 2.0)\n[1.00, 1.00]\n>>> find_intersection(2.0, 3.0, 2.0, -1.0)\nnil  Զուգահեռ գծեր առանց հատման կետի",
      "bn": "রুবি ফাংশন `def find_intersection(slope1, intercept1, slope2, intercept2)` লিখুন নিম্নলিখিত সমস্যার সমাধানের জন্য:\nদুটি সরলরেখার ছেদবিন্দু খুঁজে বের করে।\nএই ফাংশনটি চারটি আর্গুমেন্ট নেয়: slope1, intercept1, slope2, intercept2।\nslope1 এবং slope2 হল দুটি রেখার ঢাল, যেখানে intercept1 এবং intercept2 হল তাদের y-অবস্থান।\nফাংশনটি এই দুটি রেখার ছেদবিন্দুর স্থানাঙ্ক গণনা করে এবং ফেরত দেয়, যদি তা বিদ্যমান থাকে।\nস্থানাঙ্কগুলি একটি দুই-উপাদান বিশিষ্ট অ্যারে [x, y] হিসাবে ফেরত দেওয়া হয়, যা দুই দশমিক স্থানে রাউন্ড করা হয়।\n\nউদাহরণ:\n>>> find_intersection(1.0, 0.0, -1.0, 2.0)\n[1.00, 1.00]\n>>> find_intersection(2.0, 3.0, 2.0, -1.0)\nnil  সমান্তরাল রেখা, কোনো ছেদবিন্দু নেই",
      "bg": "Напишете функция на Ruby `def find_intersection(slope1, intercept1, slope2, intercept2)`, за да решите следния проблем:\nНамира точката на пресичане на две линейни функции.\nТази функция приема четири аргумента: slope1, intercept1, slope2, intercept2.\nslope1 и slope2 са наклоните на двете прави, докато intercept1 и intercept2 са техните y-пресечки.\nФункцията изчислява и връща координатите на точката на пресичане на тези две прави, ако съществува.\nКоординатите се връщат като масив с два елемента [x, y], закръглени до два знака след десетичната запетая.\n\nПример:\n>>> find_intersection(1.0, 0.0, -1.0, 2.0)\n[1.00, 1.00]\n>>> find_intersection(2.0, 3.0, 2.0, -1.0)\nnil  Паралелни прави без пресечна точка",
      "zh": "编写一个 ruby 函数 `def find_intersection(slope1, intercept1, slope2, intercept2)` 来解决以下问题：\n找到两个线性函数的交点。\n此函数接受四个参数：slope1, intercept1, slope2, intercept2。\nslope1 和 slope2 是两条直线的斜率，而 intercept1 和 intercept2 是它们的 y 截距。\n该函数计算并返回这两条直线的交点坐标（如果存在）。\n坐标以一个两元素数组 [x, y] 的形式返回，四舍五入到小数点后两位。\n\n示例：\n>>> find_intersection(1.0, 0.0, -1.0, 2.0)\n[1.00, 1.00]\n>>> find_intersection(2.0, 3.0, 2.0, -1.0)\nnil  平行线无交点",
      "fr": "Écrire une fonction ruby `def find_intersection(slope1, intercept1, slope2, intercept2)` pour résoudre le problème suivant :\nTrouve le point d'intersection de deux fonctions linéaires.\nCette fonction prend quatre arguments : slope1, intercept1, slope2, intercept2.\nslope1 et slope2 sont les pentes des deux lignes, tandis que intercept1 et intercept2 sont leurs ordonnées à l'origine.\nLa fonction calcule et renvoie les coordonnées du point d'intersection de ces deux lignes, si celui-ci existe.\nLes coordonnées sont renvoyées sous forme d'un tableau à deux éléments [x, y], arrondies à deux décimales.\n\nExemple :\n>>> find_intersection(1.0, 0.0, -1.0, 2.0)\n[1.00, 1.00]\n>>> find_intersection(2.0, 3.0, 2.0, -1.0)\nnil  Lignes parallèles sans intersection",
      "de": "Schreiben Sie eine Ruby-Funktion `def find_intersection(slope1, intercept1, slope2, intercept2)`, um das folgende Problem zu lösen:\nFindet den Schnittpunkt von zwei linearen Funktionen.\nDiese Funktion nimmt vier Argumente: slope1, intercept1, slope2, intercept2.\nslope1 und slope2 sind die Steigungen der beiden Linien, während intercept1 und intercept2 deren y-Achsenabschnitte sind.\nDie Funktion berechnet und gibt die Koordinaten des Schnittpunkts dieser beiden Linien zurück, falls er existiert.\nDie Koordinaten werden als ein zwei-elementiges Array [x, y] zurückgegeben, gerundet auf zwei Dezimalstellen.\n\nBeispiel:\n>>> find_intersection(1.0, 0.0, -1.0, 2.0)\n[1.00, 1.00]\n>>> find_intersection(2.0, 3.0, 2.0, -1.0)\nnil  Parallele Linien ohne Schnittpunkt",
      "ha": "Rubuta aikin ruby `def find_intersection(slope1, intercept1, slope2, intercept2)` don warware matsalar mai zuwa:\nNemo wurin haɗuwa na ayyuka biyu na layi daya.\nWannan aikin yana ɗaukar hujjoji huɗu: slope1, intercept1, slope2, intercept2.\nslope1 da slope2 su ne gangar jikin layukan biyu, yayin da intercept1 da intercept2 su ne y-intercepts nasu.\nAikin yana ƙididdige kuma yana dawowa da haɗin wurin haɗuwa na waɗannan layukan biyu, idan ya wanzu.\nAna dawo da haɗin a matsayin jerin abubuwa biyu [x, y], an zagaye zuwa wurare biyu na goma.\n\nMisali:\n>>> find_intersection(1.0, 0.0, -1.0, 2.0)\n[1.00, 1.00]\n>>> find_intersection(2.0, 3.0, 2.0, -1.0)\nnil  Layukan da ke layi daya ba tare da haɗuwa ba",
      "hi": "रूबी फ़ंक्शन `def find_intersection(slope1, intercept1, slope2, intercept2)` लिखें ताकि निम्नलिखित समस्या का समाधान किया जा सके:\nदो रैखिक फलनों के प्रतिच्छेदन बिंदु को खोजें।\nयह फ़ंक्शन चार तर्क लेता है: slope1, intercept1, slope2, intercept2।\nslope1 और slope2 दो रेखाओं की ढलानें हैं, जबकि intercept1 और intercept2 उनके y-अवरोध हैं।\nफ़ंक्शन इन दो रेखाओं के प्रतिच्छेदन बिंदु के निर्देशांक की गणना करता है और लौटाता है, यदि यह मौजूद है।\nनिर्देशांक को दो तत्वों वाली सरणी [x, y] के रूप में लौटाया जाता है, जो दो दशमलव स्थानों तक गोल होते हैं।\n\nउदाहरण:\n>>> find_intersection(1.0, 0.0, -1.0, 2.0)\n[1.00, 1.00]\n>>> find_intersection(2.0, 3.0, 2.0, -1.0)\nnil  समानांतर रेखाएं जिनका कोई प्रतिच्छेदन नहीं है",
      "hu": "Írj egy ruby függvényt `def find_intersection(slope1, intercept1, slope2, intercept2)` a következő probléma megoldására:\nMegtalálja két lineáris függvény metszéspontját.\nEz a függvény négy argumentumot vesz át: slope1, intercept1, slope2, intercept2.\nA slope1 és a slope2 a két egyenes meredeksége, míg az intercept1 és az intercept2 az y-metszéspontjaik.\nA függvény kiszámítja és visszaadja a két egyenes metszéspontjának koordinátáit, ha léteznek.\nA koordináták egy kételemű tömbként [x, y] formában kerülnek visszaadásra, két tizedesjegyre kerekítve.\n\nPélda:\n>>> find_intersection(1.0, 0.0, -1.0, 2.0)\n[1.00, 1.00]\n>>> find_intersection(2.0, 3.0, 2.0, -1.0)\nnil  Párhuzamos egyenesek, nincs metszéspont"
    },
    "instruction_bertscore": {
      "sq": "0.9937242731112027",
      "hy": "0.9730897546077744",
      "bn": "0.9786323367601719",
      "bg": "0.9853929204090753",
      "zh": "0.9769908552912996",
      "fr": "0.9934283138434608",
      "de": "0.994238527167702",
      "ha": "0.9681559745732488",
      "hi": "0.9843640150353147",
      "hu": "0.9783214802138523"
    },
    "level": "middle",
    "test": "raise 'Test failed' unless find_intersection(1.0, 0.0, -1.0, 2.0) == [1.00, 1.00]\nraise 'Test failed' unless find_intersection(2.0, 3.0, 2.0, -1.0).nil?\nraise 'Test failed' unless find_intersection(0.5, 1.0, -0.5, -1.0) == [-2.00, 0.00]\nraise 'Test failed' unless find_intersection(3.0, 2.0, -1.0, 4.0) == [0.50, 3.50]\nraise 'Test failed' unless find_intersection(2.0, 0.0, 0.0, 2.0) == [1.0, 2.0]\n  \n\nputs 'All tests passed!'",
    "entry_point": "find_intersection",
    "signature": "def find_intersection(slope1, intercept1, slope2, intercept2)",
    "docstring": {
      "en": "Finds the intersection point of two linear functions.\nThis function takes four arguments: slope1, intercept1, slope2, intercept2.\nslope1 and slope2 are the slopes of the two lines, while intercept1 and intercept2 are their y-intercepts.\nThe function calculates and returns the coordinates of the intersection point of these two lines, if it exists.\nThe coordinates are returned as a two-element array [x, y], rounded to two decimal places.\n\nExample:\n>>> find_intersection(1.0, 0.0, -1.0, 2.0)\n[1.00, 1.00]\n>>> find_intersection(2.0, 3.0, 2.0, -1.0)\nnil  Parallel lines with no intersection",
      "sq": "Gjen pikën e prerjes së dy funksioneve lineare.\nKjo funksion merr katër argumente: slope1, intercept1, slope2, intercept2.\nslope1 dhe slope2 janë pjerrësitë e dy vijave, ndërsa intercept1 dhe intercept2 janë prerjet e tyre në boshtin y.\nFunksioni llogarit dhe kthen koordinatat e pikës së prerjes së këtyre dy vijave, nëse ekziston.\nKoordinatat kthehen si një varg me dy elemente [x, y], të rrumbullakosura në dy vende dhjetore.\n\nShembull:\n>>> find_intersection(1.0, 0.0, -1.0, 2.0)\n[1.00, 1.00]\n>>> find_intersection(2.0, 3.0, 2.0, -1.0)\nnil  Vija paralele pa pikë prerjeje",
      "hy": "Գտնում է երկու գծային ֆունկցիաների հատման կետը։\nԱյս ֆունկցիան ընդունում է չորս արգումենտ՝ slope1, intercept1, slope2, intercept2։  \nslope1 և slope2-ը երկու գծերի թեքություններն են, իսկ intercept1 և intercept2-ը՝ նրանց y-հատումները։  \nՖունկցիան հաշվարկում և վերադարձնում է այս երկու գծերի հատման կետի կոորդինատները, եթե այն գոյություն ունի։  \nԿոորդինատները վերադարձվում են որպես երկու տարրերից բաղկացած զանգված՝ [x, y], կլորացված մինչև երկու տասնորդական տեղ։\n\nՕրինակ՝  \n>>> find_intersection(1.0, 0.0, -1.0, 2.0)  \n[1.00, 1.00]  \n>>> find_intersection(2.0, 3.0, 2.0, -1.0)  \nnil  Զուգահեռ գծեր առանց հատման կետի  ",
      "bn": "দুটি সরল রেখার ছেদবিন্দু খুঁজে বের করে।\nএই ফাংশনটি চারটি আর্গুমেন্ট নেয়: slope1, intercept1, slope2, intercept2। \nslope1 এবং slope2 হল দুটি রেখার ঢাল, যেখানে intercept1 এবং intercept2 হল তাদের y-অবস্থানান্তর। \nফাংশনটি এই দুটি রেখার ছেদবিন্দুর স্থানাঙ্ক গণনা করে এবং ফেরত দেয়, যদি তা থাকে। \nস্থানাঙ্কগুলি একটি দুটি উপাদানের অ্যারে [x, y] হিসাবে ফেরত দেওয়া হয়, যা দুই দশমিক স্থান পর্যন্ত গোলাকার।\n\nউদাহরণ:\n>>> find_intersection(1.0, 0.0, -1.0, 2.0)\n[1.00, 1.00]\n>>> find_intersection(2.0, 3.0, 2.0, -1.0)\nnil  সমান্তরাল রেখা যার কোনো ছেদবিন্দু নেই",
      "bg": "Намира точката на пресичане на две линейни функции.\nТази функция приема четири аргумента: slope1, intercept1, slope2, intercept2.  \nslope1 и slope2 са наклоните на двете прави, докато intercept1 и intercept2 са техните y-пресечни точки.  \nФункцията изчислява и връща координатите на точката на пресичане на тези две прави, ако съществува такава.  \nКоординатите се връщат като масив с два елемента [x, y], закръглени до два десетични знака.  \n\nПример:  \n>>> find_intersection(1.0, 0.0, -1.0, 2.0)  \n[1.00, 1.00]  \n>>> find_intersection(2.0, 3.0, 2.0, -1.0)  \nnil  Паралелни прави без пресечна точка",
      "zh": "找到两个线性函数的交点。\n此函数接受四个参数：slope1, intercept1, slope2, intercept2。\nslope1 和 slope2 是两条直线的斜率，而 intercept1 和 intercept2 是它们的 y 截距。\n该函数计算并返回这两条直线的交点坐标（如果存在）。\n坐标以一个两元素数组 [x, y] 的形式返回，保留两位小数。\n\n示例：\n>>> find_intersection(1.0, 0.0, -1.0, 2.0)\n[1.00, 1.00]\n>>> find_intersection(2.0, 3.0, 2.0, -1.0)\nnil  平行线无交点",
      "fr": "Trouve le point d'intersection de deux fonctions linéaires.\nCette fonction prend quatre arguments : slope1, intercept1, slope2, intercept2.  \nslope1 et slope2 sont les pentes des deux lignes, tandis que intercept1 et intercept2 sont leurs ordonnées à l'origine.  \nLa fonction calcule et renvoie les coordonnées du point d'intersection de ces deux lignes, si celui-ci existe.  \nLes coordonnées sont renvoyées sous forme d'un tableau à deux éléments [x, y], arrondies à deux décimales.\n\nExemple :  \n>>> find_intersection(1.0, 0.0, -1.0, 2.0)  \n[1.00, 1.00]  \n>>> find_intersection(2.0, 3.0, 2.0, -1.0)  \nnil  Lignes parallèles sans intersection",
      "de": "Findet den Schnittpunkt von zwei linearen Funktionen.\nDiese Funktion nimmt vier Argumente entgegen: slope1, intercept1, slope2, intercept2.\nslope1 und slope2 sind die Steigungen der beiden Linien, während intercept1 und intercept2 deren y-Achsenabschnitte sind.\nDie Funktion berechnet und gibt die Koordinaten des Schnittpunkts dieser beiden Linien zurück, falls er existiert.\nDie Koordinaten werden als ein zwei Elemente umfassendes Array [x, y] zurückgegeben, gerundet auf zwei Dezimalstellen.\n\nBeispiel:\n>>> find_intersection(1.0, 0.0, -1.0, 2.0)\n[1.00, 1.00]\n>>> find_intersection(2.0, 3.0, 2.0, -1.0)\nnil  Parallele Linien ohne Schnittpunkt",
      "ha": "Nemi wurin haɗuwa na hanyoyi biyu na layi.\nWannan aikin yana samun wurin haɗuwa na hanyoyi biyu masu madaidaiciya.  \nThis function takes four arguments: slope1, intercept1, slope2, intercept2.  \nWannan aikin yana karɓar hujjoji guda huɗu: slope1, intercept1, slope2, intercept2.  \nslope1 and slope2 are the slopes of the two lines, while intercept1 and intercept2 are their y-intercepts.  \nslope1 da slope2 su ne gangaren hanyoyi biyu, yayin da intercept1 da intercept2 su ne wuraren y-intercept ɗinsu.  \nThe function calculates and returns the coordinates of the intersection point of these two lines, if it exists.  \nAikin yana ƙididdige kuma yana dawowa da daidaitattun wuraren haɗuwa na waɗannan hanyoyi biyu, idan suna wanzu.  \nThe coordinates are returned as a two-element array [x, y], rounded to two decimal places.  \nDaidaitattun wuraren suna dawowa a matsayin jerin abubuwa guda biyu [x, y], an zagaye zuwa wurare biyu na goma.  \n\nExample:  \nMisali:  \n>>> find_intersection(1.0, 0.0, -1.0, 2.0)  \n[1.00, 1.00]  \n>>> find_intersection(2.0, 3.0, 2.0, -1.0)  \nnil  Layukan da ke daidai ba su da wurin haɗuwa  ",
      "hi": "दो रेखीय फलनों के प्रतिच्छेदन बिंदु को खोजता है।\nयह फ़ंक्शन चार तर्क लेता है: slope1, intercept1, slope2, intercept2।  \nslope1 और slope2 दो रेखाओं के ढलान हैं, जबकि intercept1 और intercept2 उनके y-अवरोध हैं।  \nयह फ़ंक्शन इन दो रेखाओं के प्रतिच्छेदन बिंदु के निर्देशांक की गणना करता है और लौटाता है, यदि यह मौजूद है।  \nनिर्देशांक को [x, y] के रूप में दो तत्वों की एक सरणी के रूप में लौटाया जाता है, जो दो दशमलव स्थानों तक गोल होते हैं।\n\nउदाहरण:\n>>> find_intersection(1.0, 0.0, -1.0, 2.0)\n[1.00, 1.00]\n>>> find_intersection(2.0, 3.0, 2.0, -1.0)\nnil  समानांतर रेखाएँ जिनका कोई प्रतिच्छेदन नहीं है",
      "hu": "Megtalálja két lineáris függvény metszéspontját.\nEz a függvény négy argumentumot vesz: slope1, intercept1, slope2, intercept2.\nA slope1 és slope2 a két egyenes meredeksége, míg az intercept1 és intercept2 az y-metszéspontjaik.\nA függvény kiszámítja és visszaadja a két egyenes metszéspontjának koordinátáit, ha létezik.\nA koordináták egy kételemű tömbként [x, y] formában kerülnek visszaadásra, két tizedesjegyre kerekítve.\n\nPélda:\n>>> find_intersection(1.0, 0.0, -1.0, 2.0)\n[1.00, 1.00]\n>>> find_intersection(2.0, 3.0, 2.0, -1.0)\nnil  Párhuzamos egyenesek, nincs metszéspont"
    },
    "docstring_bertscore": {
      "sq": "0.9853663039380167",
      "hy": "0.9886621778505286",
      "bn": "0.9788464603109275",
      "bg": "0.9849930774520521",
      "zh": "0.976959074430334",
      "fr": "0.991192331644151",
      "de": "0.9862899352098289",
      "ha": "0.9822257589834741",
      "hi": "0.9935621907202783",
      "hu": "0.9739686940438538"
    }
  },
  {
    "task_id": "Ruby/21",
    "prompt": {
      "en": "# This method calculates the minimum number of steps required to transform a given number into a palindrome by repeatedly reversing its digits and adding the result to the original number. The process is stopped when a palindrome is obtained. If the palindrome is not obtained within 8 steps, the method returns 0.\n# The function takes a single argument, m, which is a positive integer between 12 and 100, and returns the number of steps taken to reach a palindrome. The input number m itself is not a palindrome.\n#\n# Examples:\n# >>> palindrome_sum_steps(12)\n# 1\n# >>> palindrome_sum_steps(87)\n# 4\n# >>> palindrome_sum_steps(89)\n# 0\n\ndef palindrome_sum_steps(m)",
      "sq": "# Kjo metodë llogarit numrin minimal të hapave të nevojshëm për të transformuar një numër të dhënë në një palindrom duke përmbysur në mënyrë të përsëritur shifrat e tij dhe duke shtuar rezultatin në numrin origjinal. Procesi ndalet kur arrihet një palindrom. Nëse palindromi nuk arrihet brenda 8 hapave, metoda kthen 0.\n# Funksioni merr një argument të vetëm, m, i cili është një numër i plotë pozitiv midis 12 dhe 100, dhe kthen numrin e hapave të ndërmarrë për të arritur një palindrom. Vetë numri i futur m nuk është një palindrom.\n#\n# Shembuj:\n# >>> palindrome_sum_steps(12)\n# 1\n# >>> palindrome_sum_steps(87)\n# 4\n# >>> palindrome_sum_steps(89)\n# 0\n\ndef palindrome_sum_steps(m)",
      "hy": "# Այս մեթոդը հաշվարկում է նվազագույն քայլերի քանակը, որը պահանջվում է տրված թիվը պալինդրոմ դարձնելու համար՝ կրկնակի շրջելով նրա թվանշանները և ավելացնելով արդյունքը սկզբնական թվին։ Գործընթացը դադարում է, երբ ստացվում է պալինդրոմ։ Եթե պալինդրոմը չի ստացվում 8 քայլի ընթացքում, մեթոդը վերադարձնում է 0։\n# Ֆունկցիան ընդունում է մեկ արգումենտ, m, որը դրական ամբողջ թիվ է 12-ից մինչև 100, և վերադարձնում է քայլերի քանակը, որը պահանջվում է պալինդրոմի հասնելու համար։ Մուտքային թիվը m ինքնին պալինդրոմ չէ։\n#\n# Օրինակներ:\n# >>> palindrome_sum_steps(12)\n# 1\n# >>> palindrome_sum_steps(87)\n# 4\n# >>> palindrome_sum_steps(89)\n# 0\n\ndef palindrome_sum_steps(m)",
      "bn": "# এই পদ্ধতিটি একটি প্রদত্ত সংখ্যাকে প্যালিনড্রোমে রূপান্তর করার জন্য প্রয়োজনীয় সর্বনিম্ন ধাপগুলি গণনা করে, এর অঙ্কগুলি উল্টিয়ে এবং ফলাফলটি মূল সংখ্যার সাথে যোগ করে বারবার। যখন একটি প্যালিনড্রোম পাওয়া যায় তখন প্রক্রিয়াটি বন্ধ হয়। যদি ৮ ধাপের মধ্যে প্যালিনড্রোম পাওয়া না যায়, তাহলে পদ্ধতিটি ০ ফেরত দেয়।\n# ফাংশনটি একটি একক আর্গুমেন্ট, m গ্রহণ করে, যা ১২ এবং ১০০ এর মধ্যে একটি ধনাত্মক পূর্ণসংখ্যা এবং প্যালিনড্রোমে পৌঁছানোর জন্য নেওয়া ধাপগুলির সংখ্যা ফেরত দেয়। ইনপুট সংখ্যা m নিজেই একটি প্যালিনড্রোম নয়।\n#\n# উদাহরণ:\n# >>> palindrome_sum_steps(12)\n# 1\n# >>> palindrome_sum_steps(87)\n# 4\n# >>> palindrome_sum_steps(89)\n# 0\n\ndef palindrome_sum_steps(m)",
      "bg": "# Този метод изчислява минималния брой стъпки, необходими за трансформиране на дадено число в палиндром, като многократно обръща цифрите му и добавя резултата към оригиналното число. Процесът се спира, когато се получи палиндром. Ако палиндром не се получи в рамките на 8 стъпки, методът връща 0.\n# Функцията приема един аргумент, m, който е положително цяло число между 12 и 100, и връща броя на стъпките, необходими за достигане на палиндром. Самото входно число m не е палиндром.\n#\n# Примери:\n# >>> palindrome_sum_steps(12)\n# 1\n# >>> palindrome_sum_steps(87)\n# 4\n# >>> palindrome_sum_steps(89)\n# 0\n\ndef palindrome_sum_steps(m)",
      "zh": "# 此方法计算将给定数字转换为回文所需的最小步骤数，通过反复反转其数字并将结果加到原始数字上。该过程在获得回文时停止。如果在8步内未获得回文，则该方法返回0。\n# 该函数接收一个参数m，它是一个介于12和100之间的正整数，并返回达到回文所需的步骤数。输入数字m本身不是回文。\n#\n# 示例:\n# >>> palindrome_sum_steps(12)\n# 1\n# >>> palindrome_sum_steps(87)\n# 4\n# >>> palindrome_sum_steps(89)\n# 0\n\ndef palindrome_sum_steps(m)",
      "fr": "# Cette méthode calcule le nombre minimum d'étapes nécessaires pour transformer un nombre donné en un palindrome en inversant à plusieurs reprises ses chiffres et en ajoutant le résultat au nombre original. Le processus s'arrête lorsqu'un palindrome est obtenu. Si le palindrome n'est pas obtenu en 8 étapes, la méthode renvoie 0.\n# La fonction prend un seul argument, m, qui est un entier positif entre 12 et 100, et renvoie le nombre d'étapes nécessaires pour atteindre un palindrome. Le nombre d'entrée m lui-même n'est pas un palindrome.\n#\n# Exemples:\n# >>> palindrome_sum_steps(12)\n# 1\n# >>> palindrome_sum_steps(87)\n# 4\n# >>> palindrome_sum_steps(89)\n# 0\n\ndef palindrome_sum_steps(m)",
      "de": "# Diese Methode berechnet die minimale Anzahl von Schritten, die erforderlich sind, um eine gegebene Zahl in ein Palindrom zu transformieren, indem ihre Ziffern wiederholt umgekehrt und das Ergebnis zur ursprünglichen Zahl addiert werden. Der Prozess wird gestoppt, wenn ein Palindrom erreicht wird. Wenn innerhalb von 8 Schritten kein Palindrom erreicht wird, gibt die Methode 0 zurück.\n# Die Funktion nimmt ein einzelnes Argument, m, das eine positive ganze Zahl zwischen 12 und 100 ist, und gibt die Anzahl der Schritte zurück, die benötigt werden, um ein Palindrom zu erreichen. Die Eingabezahl m selbst ist kein Palindrom.\n#\n# Beispiele:\n# >>> palindrome_sum_steps(12)\n# 1\n# >>> palindrome_sum_steps(87)\n# 4\n# >>> palindrome_sum_steps(89)\n# 0\n\ndef palindrome_sum_steps(m)",
      "ha": "# Wannan hanyar tana ƙididdige mafi ƙarancin adadin matakai da ake buƙata don canza wata lamba zuwa palindrome ta hanyar maimaita juyar da lambobinta da ƙara sakamakon zuwa asalin lambar. Ana dakatar da aikin lokacin da aka sami palindrome. Idan ba a sami palindrome ba cikin matakai 8, hanyar tana dawowa da 0.\n# Aikin yana ɗaukar hujja guda, m, wanda lamba ce mai kyau tsakanin 12 da 100, kuma yana dawowa da adadin matakan da aka ɗauka don isa ga palindrome. Lambar shigar m kanta ba palindrome ba ce.\n#\n# Misalai:\n# >>> palindrome_sum_steps(12)\n# 1\n# >>> palindrome_sum_steps(87)\n# 4\n# >>> palindrome_sum_steps(89)\n# 0\n\ndef palindrome_sum_steps(m)",
      "hi": "# यह विधि एक दिए गए संख्या को एक पालिंड्रोम में बदलने के लिए आवश्यक न्यूनतम चरणों की गणना करती है, इसके अंकों को बार-बार उलटकर और परिणाम को मूल संख्या में जोड़कर। प्रक्रिया तब रोकी जाती है जब एक पालिंड्रोम प्राप्त हो जाता है। यदि पालिंड्रोम 8 चरणों के भीतर प्राप्त नहीं होता है, तो विधि 0 लौटाती है।\n# फ़ंक्शन एकल तर्क, m, लेता है, जो 12 और 100 के बीच एक धनात्मक पूर्णांक है, और पालिंड्रोम तक पहुँचने के लिए लिए गए चरणों की संख्या लौटाता है। इनपुट संख्या m स्वयं एक पालिंड्रोम नहीं है।\n#\n# उदाहरण:\n# >>> palindrome_sum_steps(12)\n# 1\n# >>> palindrome_sum_steps(87)\n# 4\n# >>> palindrome_sum_steps(89)\n# 0\n\ndef palindrome_sum_steps(m)",
      "hu": "# Ez a metódus kiszámítja a minimális lépések számát, amely szükséges ahhoz, hogy egy adott számot palindrómmá alakítsunk azáltal, hogy ismételten megfordítjuk a számjegyeit, és hozzáadjuk az eredményt az eredeti számhoz. A folyamat akkor áll le, amikor palindrómát kapunk. Ha a palindrómát nem kapjuk meg 8 lépésen belül, a metódus 0-t ad vissza.\n# A függvény egyetlen argumentumot vesz fel, m-et, amely egy pozitív egész szám 12 és 100 között, és visszaadja a palindróma eléréséhez szükséges lépések számát. Maga a bemeneti szám m nem palindróma.\n#\n# Példák:\n# >>> palindrome_sum_steps(12)\n# 1\n# >>> palindrome_sum_steps(87)\n# 4\n# >>> palindrome_sum_steps(89)\n# 0\n\ndef palindrome_sum_steps(m)"
    },
    "prompt_bertscore": {
      "sq": "0.9901169467612281",
      "hy": "0.9733459877993094",
      "bn": "0.9800692289365783",
      "bg": "0.9875417038711107",
      "zh": "0.9778453631905116",
      "fr": "0.9915498663300137",
      "de": "0.9825399922462713",
      "ha": "0.9865431889456484",
      "hi": "0.9861985652345528",
      "hu": "0.9911351260944129"
    },
    "canonical_solution": "  steps = 0\n  until m.to_s == m.to_s.reverse || steps == 8\n    m += m.to_s.reverse.to_i\n    steps += 1\n    return steps if m.to_s == m.to_s.reverse\n  end\n  steps < 8 ? steps : 0\nend",
    "instruction": {
      "en": "Write a ruby function `def palindrome_sum_steps(m)` to solve the following problem:\nThis method calculates the minimum number of steps required to transform a given number into a palindrome by repeatedly reversing its digits and adding the result to the original number. The process is stopped when a palindrome is obtained. If the palindrome is not obtained within 8 steps, the method returns 0.\nThe function takes a single argument, m, which is a positive integer between 12 and 100, and returns the number of steps taken to reach a palindrome. The input number m itself is not a palindrome.\n\nExamples:\n>>> palindrome_sum_steps(12)\n1\n>>> palindrome_sum_steps(87)\n4\n>>> palindrome_sum_steps(89)\n0",
      "sq": "Shkruani një funksion ruby `def palindrome_sum_steps(m)` për të zgjidhur problemin e mëposhtëm:\nKjo metodë llogarit numrin minimal të hapave të nevojshëm për të transformuar një numër të dhënë në një palindrom duke përmbysur vazhdimisht shifrat e tij dhe duke shtuar rezultatin në numrin origjinal. Procesi ndalet kur arrihet një palindrom. Nëse palindromi nuk arrihet brenda 8 hapave, metoda kthen 0.\nFunksioni merr një argument të vetëm, m, i cili është një numër i plotë pozitiv midis 12 dhe 100, dhe kthen numrin e hapave të ndërmarrë për të arritur një palindrom. Vetë numri hyrës m nuk është një palindrom.\n\nShembuj:\n>>> palindrome_sum_steps(12)\n1\n>>> palindrome_sum_steps(87)\n4\n>>> palindrome_sum_steps(89)\n0",
      "hy": "Գրեք ruby ֆունկցիա `def palindrome_sum_steps(m)` հետևյալ խնդիրը լուծելու համար:\nԱյս մեթոդը հաշվում է նվազագույն քայլերի քանակը, որը պահանջվում է տրված թիվը պալինդրոմի վերածելու համար՝ բազմիցս շրջելով նրա թվանշանները և գումարելով արդյունքը սկզբնական թվին: Գործընթացը դադարում է, երբ ստացվում է պալինդրոմ: Եթե պալինդրոմը չի ստացվում 8 քայլի ընթացքում, մեթոդը վերադարձնում է 0:\nՖունկցիան ընդունում է մեկ արգումենտ, m, որը դրական ամբողջ թիվ է 12-ից 100 միջակայքում, և վերադարձնում է պալինդրոմի հասնելու համար պահանջվող քայլերի քանակը: Մուտքային թիվը m ինքնին պալինդրոմ չէ:\n\nՕրինակներ:\n>>> palindrome_sum_steps(12)\n1\n>>> palindrome_sum_steps(87)\n4\n>>> palindrome_sum_steps(89)\n0",
      "bn": "রুবি ফাংশন `def palindrome_sum_steps(m)` লিখুন নিম্নলিখিত সমস্যার সমাধানের জন্য:\nএই পদ্ধতিটি একটি প্রদত্ত সংখ্যাকে প্যালিনড্রোমে রূপান্তর করার জন্য প্রয়োজনীয় ন্যূনতম ধাপগুলি গণনা করে, যা তার অঙ্কগুলি উল্টে এবং ফলাফলটিকে মূল সংখ্যার সাথে যোগ করে বারবার করা হয়। প্রক্রিয়াটি তখনই বন্ধ হয় যখন একটি প্যালিনড্রোম পাওয়া যায়। যদি ৮ ধাপের মধ্যে প্যালিনড্রোম পাওয়া না যায়, তাহলে পদ্ধতিটি ০ ফেরত দেয়।\nফাংশনটি একটি একক আর্গুমেন্ট গ্রহণ করে, m, যা ১২ এবং ১০০ এর মধ্যে একটি ধনাত্মক পূর্ণসংখ্যা এবং প্যালিনড্রোমে পৌঁছাতে নেওয়া ধাপগুলির সংখ্যা ফেরত দেয়। ইনপুট সংখ্যা m নিজেই একটি প্যালিনড্রোম নয়।\n\nউদাহরণ:\n>>> palindrome_sum_steps(12)\n1\n>>> palindrome_sum_steps(87)\n4\n>>> palindrome_sum_steps(89)\n0",
      "bg": "Напишете функция на Ruby `def palindrome_sum_steps(m)`, за да решите следния проблем:\nТози метод изчислява минималния брой стъпки, необходими за преобразуване на дадено число в палиндром, като многократно обръща неговите цифри и добавя резултата към оригиналното число. Процесът спира, когато се получи палиндром. Ако палиндромът не се получи в рамките на 8 стъпки, методът връща 0.\nФункцията приема един аргумент, m, който е положително цяло число между 12 и 100, и връща броя на стъпките, необходими за достигане на палиндром. Самото входно число m не е палиндром.\n\nПримери:\n>>> palindrome_sum_steps(12)\n1\n>>> palindrome_sum_steps(87)\n4\n>>> palindrome_sum_steps(89)\n0",
      "zh": "编写一个 ruby 函数 `def palindrome_sum_steps(m)` 来解决以下问题：\n此方法计算将给定数字转换为回文所需的最小步骤数，方法是反复反转其数字并将结果加到原始数字上。当获得回文时，过程停止。如果在 8 步内未获得回文，该方法返回 0。\n函数接受一个参数 m，它是一个介于 12 和 100 之间的正整数，并返回达到回文所需的步骤数。输入数字 m 本身不是回文。\n\n示例：\n>>> palindrome_sum_steps(12)\n1\n>>> palindrome_sum_steps(87)\n4\n>>> palindrome_sum_steps(89)\n0",
      "fr": "Écrire une fonction ruby `def palindrome_sum_steps(m)` pour résoudre le problème suivant :  \nCette méthode calcule le nombre minimum d'étapes nécessaires pour transformer un nombre donné en un palindrome en inversant à plusieurs reprises ses chiffres et en ajoutant le résultat au nombre original. Le processus s'arrête lorsqu'un palindrome est obtenu. Si le palindrome n'est pas obtenu en 8 étapes, la méthode retourne 0.  \nLa fonction prend un seul argument, m, qui est un entier positif compris entre 12 et 100, et retourne le nombre d'étapes nécessaires pour atteindre un palindrome. Le nombre d'entrée m lui-même n'est pas un palindrome.\n\nExemples :\n>>> palindrome_sum_steps(12)\n1\n>>> palindrome_sum_steps(87)\n4\n>>> palindrome_sum_steps(89)\n0",
      "de": "Schreiben Sie eine Ruby-Funktion `def palindrome_sum_steps(m)`, um das folgende Problem zu lösen:\nDiese Methode berechnet die minimale Anzahl von Schritten, die erforderlich sind, um eine gegebene Zahl in ein Palindrom zu transformieren, indem sie wiederholt ihre Ziffern umkehrt und das Ergebnis zur ursprünglichen Zahl addiert. Der Prozess wird gestoppt, wenn ein Palindrom erreicht wird. Wenn das Palindrom nicht innerhalb von 8 Schritten erreicht wird, gibt die Methode 0 zurück.\nDie Funktion nimmt ein einziges Argument, m, das eine positive ganze Zahl zwischen 12 und 100 ist, und gibt die Anzahl der Schritte zurück, die benötigt werden, um ein Palindrom zu erreichen. Die Eingabezahl m selbst ist kein Palindrom.\n\nBeispiele:\n>>> palindrome_sum_steps(12)\n1\n>>> palindrome_sum_steps(87)\n4\n>>> palindrome_sum_steps(89)\n0",
      "ha": "Rubuta aikin ruby `def palindrome_sum_steps(m)` don warware matsalar mai zuwa: Wannan hanyar tana ƙididdige mafi ƙarancin adadin matakai da ake buƙata don canza wata lamba zuwa palindrome ta hanyar maimaita jujjuya lambobinta da ƙara sakamakon zuwa ainihin lambar. Ana dakatar da aikin idan an sami palindrome. Idan ba a sami palindrome ba cikin matakai 8, hanyar tana mayar da 0. \n\nAikin yana ɗaukar hujja guda, m, wanda yake lamba mai kyau tsakanin 12 da 100, kuma yana mayar da adadin matakan da aka ɗauka don isa ga palindrome. Lambar shigarwa m kanta ba palindrome ba ce.\n\nMisalai:\n>>> palindrome_sum_steps(12)\n1\n>>> palindrome_sum_steps(87)\n4\n>>> palindrome_sum_steps(89)\n0",
      "hi": "रूबी फ़ंक्शन `def palindrome_sum_steps(m)` लिखें ताकि निम्नलिखित समस्या का समाधान किया जा सके:\nयह विधि किसी दिए गए संख्या को एक पालिंड्रोम में बदलने के लिए आवश्यक न्यूनतम चरणों की गणना करती है, इसके अंकों को बार-बार उलट कर और परिणाम को मूल संख्या में जोड़कर। जब एक पालिंड्रोम प्राप्त होता है, तो प्रक्रिया को रोक दिया जाता है। यदि पालिंड्रोम 8 चरणों के भीतर प्राप्त नहीं होता है, तो विधि 0 लौटाती है।\nयह फ़ंक्शन एकल तर्क m लेता है, जो 12 और 100 के बीच की एक धनात्मक पूर्णांक है, और पालिंड्रोम तक पहुँचने के लिए लिए गए चरणों की संख्या लौटाता है। इनपुट संख्या m स्वयं पालिंड्रोम नहीं है।\n\nउदाहरण:\n>>> palindrome_sum_steps(12)\n1\n>>> palindrome_sum_steps(87)\n4\n>>> palindrome_sum_steps(89)\n0",
      "hu": "Írj egy ruby függvényt `def palindrome_sum_steps(m)` a következő probléma megoldására:\nEz a metódus kiszámítja a minimális lépések számát, amely szükséges ahhoz, hogy egy adott számot palindrómmá alakítsunk azáltal, hogy ismételten megfordítjuk a számjegyeit, és az eredményt hozzáadjuk az eredeti számhoz. A folyamat akkor áll meg, amikor egy palindrómát kapunk. Ha a palindrómát nem kapjuk meg 8 lépésen belül, a metódus 0-t ad vissza.\nA függvény egyetlen argumentumot vesz fel, m, amely egy pozitív egész szám 12 és 100 között, és visszaadja a palindróma eléréséhez szükséges lépések számát. Maga a bemeneti szám m nem palindróma.\n\nPéldák:\n>>> palindrome_sum_steps(12)\n1\n>>> palindrome_sum_steps(87)\n4\n>>> palindrome_sum_steps(89)\n0"
    },
    "instruction_bertscore": {
      "sq": "0.9892221168946659",
      "hy": "0.9845453645731995",
      "bn": "0.97921352925508",
      "bg": "0.9843423643237819",
      "zh": "0.981189702915996",
      "fr": "0.9908105640518019",
      "de": "0.9836606648560701",
      "ha": "0.9897190901080152",
      "hi": "0.97077034764843",
      "hu": "0.9912852906624753"
    },
    "level": "easy",
    "test": "raise 'Test failed' unless palindrome_sum_steps(12) == 1\nraise 'Test failed' unless palindrome_sum_steps(87) == 4\nraise 'Test failed' unless palindrome_sum_steps(89) == 0\nraise 'Test failed' unless palindrome_sum_steps(56) == 1\nraise 'Test failed' unless palindrome_sum_steps(95) == 3\n\nputs 'All tests passed!'",
    "entry_point": "palindrome_sum_steps",
    "signature": "def palindrome_sum_steps(m)",
    "docstring": {
      "en": "This method calculates the minimum number of steps required to transform a given number into a palindrome by repeatedly reversing its digits and adding the result to the original number. The process is stopped when a palindrome is obtained. If the palindrome is not obtained within 8 steps, the method returns 0.\nThe function takes a single argument, m, which is a positive integer between 12 and 100, and returns the number of steps taken to reach a palindrome. The input number m itself is not a palindrome.\n\nExamples:\n>>> palindrome_sum_steps(12)\n1\n>>> palindrome_sum_steps(87)\n4\n>>> palindrome_sum_steps(89)\n0",
      "sq": "Kjo metodë llogarit numrin minimal të hapave të nevojshëm për të transformuar një numër të dhënë në një palindrom duke përmbysur përsëri shifrat e tij dhe duke shtuar rezultatin në numrin origjinal. Procesi ndalet kur merret një palindrom. Nëse palindromi nuk merret brenda 8 hapave, metoda kthen 0. \n\nFunksioni merr një argument të vetëm, m, i cili është një numër i plotë pozitiv midis 12 dhe 100, dhe kthen numrin e hapave të ndërmarrë për të arritur një palindrom. Vetë numri i futur m nuk është një palindrom.\n\nShembuj:\n>>> palindrome_sum_steps(12)\n1\n>>> palindrome_sum_steps(87)\n4\n>>> palindrome_sum_steps(89)\n0",
      "hy": "Այս մեթոդը հաշվարկում է նվազագույն քայլերի քանակը, որը պահանջվում է տրված թիվը պալինդրոմի վերածելու համար՝ բազմիցս շրջելով նրա թվանշանները և գումարելով արդյունքը սկզբնական թվին: Գործընթացը դադարում է, երբ ստացվում է պալինդրոմ: Եթե պալինդրոմը չի ստացվում 8 քայլի ընթացքում, մեթոդը վերադարձնում է 0:\nՖունկցիան ընդունում է մեկ արգումենտ՝ m, որը դրական ամբողջ թիվ է 12-ից մինչև 100 միջակայքում, և վերադարձնում է քայլերի քանակը, որը պահանջվել է պալինդրոմի հասնելու համար: Մուտքային թիվ m-ն ինքնին պալինդրոմ չէ:\n\nՕրինակներ:\n>>> palindrome_sum_steps(12)\n1\n>>> palindrome_sum_steps(87)\n4\n>>> palindrome_sum_steps(89)\n0",
      "bn": "এই পদ্ধতিটি একটি প্রদত্ত সংখ্যাকে প্যালিনড্রোমে রূপান্তর করতে প্রয়োজনীয় ন্যূনতম ধাপের সংখ্যা গণনা করে, যা এর অঙ্কগুলো উল্টে দিয়ে এবং ফলাফলটিকে মূল সংখ্যার সাথে যোগ করে বারবার করা হয়। যখন একটি প্যালিনড্রোম পাওয়া যায়, তখন প্রক্রিয়াটি বন্ধ করা হয়। যদি ৮ ধাপের মধ্যে প্যালিনড্রোম পাওয়া না যায়, তাহলে পদ্ধতিটি ০ ফেরত দেয়। \n\nArgs:\n    m: একটি ধনাত্মক পূর্ণসংখ্যা যা ১২ এবং ১০০ এর মধ্যে এবং প্যালিনড্রোম নয়।\n\nReturns:\n    প্যালিনড্রোমে পৌঁছানোর জন্য নেওয়া ধাপের সংখ্যা।\n\nExamples:\n>>> palindrome_sum_steps(12)\n1\n>>> palindrome_sum_steps(87)\n4\n>>> palindrome_sum_steps(89)\n0",
      "bg": "Този метод изчислява минималния брой стъпки, необходими за преобразуване на дадено число в палиндром, като многократно обръща цифрите му и добавя резултата към оригиналното число. Процесът се спира, когато се получи палиндром. Ако палиндромът не бъде получен в рамките на 8 стъпки, методът връща 0. \n\nФункцията приема един аргумент, m, който е положително цяло число между 12 и 100, и връща броя на стъпките, необходими за достигане на палиндром. Самото входно число m не е палиндром.\n\nПримери:\n>>> palindrome_sum_steps(12)\n1\n>>> palindrome_sum_steps(87)\n4\n>>> palindrome_sum_steps(89)\n0",
      "zh": "此方法计算将给定数字转换为回文所需的最少步骤数，方法是反复反转其数字并将结果加到原始数字上。当获得回文时，过程停止。如果在8步内未获得回文，该方法返回0。  \n函数接受一个参数m，它是一个介于12和100之间的正整数，并返回达到回文所需的步骤数。输入数字m本身不是回文。\n\n示例：\n>>> palindrome_sum_steps(12)\n1\n>>> palindrome_sum_steps(87)\n4\n>>> palindrome_sum_steps(89)\n0",
      "fr": "Cette méthode calcule le nombre minimum d'étapes nécessaires pour transformer un nombre donné en un palindrome en inversant à plusieurs reprises ses chiffres et en ajoutant le résultat au nombre original. Le processus s'arrête lorsqu'un palindrome est obtenu. Si le palindrome n'est pas obtenu en 8 étapes, la méthode renvoie 0.  \nLa fonction prend un seul argument, m, qui est un entier positif compris entre 12 et 100, et renvoie le nombre d'étapes nécessaires pour atteindre un palindrome. Le nombre d'entrée m lui-même n'est pas un palindrome.\n\nExemples :\n>>> palindrome_sum_steps(12)\n1\n>>> palindrome_sum_steps(87)\n4\n>>> palindrome_sum_steps(89)\n0",
      "de": "Diese Methode berechnet die minimale Anzahl von Schritten, die erforderlich sind, um eine gegebene Zahl in ein Palindrom zu transformieren, indem ihre Ziffern wiederholt umgekehrt und das Ergebnis zur ursprünglichen Zahl addiert werden. Der Prozess wird gestoppt, wenn ein Palindrom erreicht wird. Wenn das Palindrom nicht innerhalb von 8 Schritten erreicht wird, gibt die Methode 0 zurück. \n\nDie Funktion nimmt ein einzelnes Argument, m, das eine positive ganze Zahl zwischen 12 und 100 ist, und gibt die Anzahl der Schritte zurück, die erforderlich sind, um ein Palindrom zu erreichen. Die Eingabezahl m selbst ist kein Palindrom.\n\nBeispiele:\n>>> palindrome_sum_steps(12)\n1\n>>> palindrome_sum_steps(87)\n4\n>>> palindrome_sum_steps(89)\n0",
      "ha": "Wannan hanyar tana ƙididdige mafi ƙarancin adadin matakai da ake buƙata don canza wani lamba zuwa palindrome ta hanyar juyar da lambobinsa kuma ƙara sakamakon zuwa lambar asali. Ana dakatar da aikin lokacin da aka sami palindrome. Idan ba a sami palindrome ba cikin matakai 8, hanyar tana dawowa 0.\nAikin yana ɗaukar hujja guda ɗaya, m, wanda yake lamba mai kyau tsakanin 12 da 100, kuma yana dawowa adadin matakan da aka ɗauka don isa ga palindrome. Lambar shigar m kanta ba palindrome ba ce.\n\nMisalai:\n>>> palindrome_sum_steps(12)\n1\n>>> palindrome_sum_steps(87)\n4\n>>> palindrome_sum_steps(89)\n0",
      "hi": "यह विधि एक दिए गए संख्या को एक पालिंड्रोम में बदलने के लिए आवश्यक न्यूनतम चरणों की गणना करती है, इसके अंकों को बार-बार उलटकर और परिणाम को मूल संख्या में जोड़कर। प्रक्रिया तब रोकी जाती है जब एक पालिंड्रोम प्राप्त हो जाता है। यदि 8 चरणों के भीतर पालिंड्रोम प्राप्त नहीं होता है, तो विधि 0 लौटाती है। \n\nArgs:\n    m: एकल तर्क, जो 12 और 100 के बीच की एक धनात्मक पूर्णांक संख्या है, और पालिंड्रोम तक पहुंचने के लिए लिए गए चरणों की संख्या लौटाती है। इनपुट संख्या m स्वयं एक पालिंड्रोम नहीं है।\n\nउदाहरण:\n>>> palindrome_sum_steps(12)\n1\n>>> palindrome_sum_steps(87)\n4\n>>> palindrome_sum_steps(89)\n0",
      "hu": "Ez a metódus kiszámítja a minimális lépések számát, amely szükséges ahhoz, hogy egy adott számot palindrómmá alakítsunk azáltal, hogy ismételten megfordítjuk a számjegyeit, és hozzáadjuk az eredményt az eredeti számhoz. A folyamat akkor áll le, amikor egy palindrómát kapunk. Ha a palindróma nem érhető el 8 lépésen belül, a metódus 0-t ad vissza.\nA függvény egyetlen argumentumot vesz fel, m-et, amely egy pozitív egész szám 12 és 100 között, és visszaadja a palindróma eléréséhez szükséges lépések számát. Maga a bemeneti szám m nem palindróma.\n\nPéldák:\n>>> palindrome_sum_steps(12)\n1\n>>> palindrome_sum_steps(87)\n4\n>>> palindrome_sum_steps(89)\n0"
    },
    "docstring_bertscore": {
      "sq": "0.9914473730533998",
      "hy": "0.9805544829574465",
      "bn": "0.9223355210153588",
      "bg": "0.9862365036373305",
      "zh": "0.9775464244670542",
      "fr": "0.9908498928672469",
      "de": "0.9879723345371945",
      "ha": "0.9784025214093145",
      "hi": "0.9669270484057859",
      "hu": "0.9853092970186597"
    }
  },
  {
    "task_id": "Ruby/22",
    "prompt": {
      "en": "# This function calculates the number of different prime pairs whose sum equals a given even number.\n# The function accepts a single argument, even_number, which is an even number greater than 6 and less than 32767.\n# It returns the count of distinct prime pairs whose sum equals the given even number.\n# A prime pair is considered distinct if the primes in the pair are different, regardless of their order.\n#\n# Example:\n# >>> count_prime_pairs(10)\n# 2 (since 10 can be expressed as 3+7 and 5+5)\n# >>> count_prime_pairs(14)\n# 2 (since 14 can be expressed as 3+11 and 7+7)\n \ndef count_prime_pairs(even_number)",
      "sq": "# Kjo funksion llogarit numrin e çifteve të ndryshme të numrave të parë, shuma e të cilëve është e barabartë me një numër çift të dhënë.\n# Funksioni pranon një argument të vetëm, even_number, i cili është një numër çift më i madh se 6 dhe më i vogël se 32767.\n# Ai kthen numrin e çifteve të veçantë të numrave të parë, shuma e të cilëve është e barabartë me numrin çift të dhënë.\n# Një çift numrash të parë konsiderohet i veçantë nëse numrat e parë në çift janë të ndryshëm, pavarësisht nga rendi i tyre.\n#\n# Shembull:\n# >>> count_prime_pairs(10)\n# 2 (pasi 10 mund të shprehet si 3+7 dhe 5+5)\n# >>> count_prime_pairs(14)\n# 2 (pasi 14 mund të shprehet si 3+11 dhe 7+7)\n\ndef count_prime_pairs(even_number)",
      "hy": "# Այս ֆունկցիան հաշվում է տարբեր պարզ թվերի զույգերի քանակը, որոնց գումարը հավասար է տրված զույգ թվին։\n# Ֆունկցիան ընդունում է մեկ արգումենտ, even_number, որը զույգ թիվ է՝ մեծ 6-ից և փոքր 32767-ից։\n# Այն վերադարձնում է տարբեր պարզ զույգերի քանակը, որոնց գումարը հավասար է տրված զույգ թվին։\n# Պարզ զույգը համարվում է տարբեր, եթե զույգի պարզ թվերը տարբեր են, անկախ նրանց կարգից։\n#\n# Օրինակ:\n# >>> count_prime_pairs(10)\n# 2 (քանի որ 10-ը կարելի է արտահայտել որպես 3+7 և 5+5)\n# >>> count_prime_pairs(14)\n# 2 (քանի որ 14-ը կարելի է արտահայտել որպես 3+11 և 7+7)\n\ndef count_prime_pairs(even_number)",
      "bn": "# এই ফাংশনটি বিভিন্ন মৌলিক সংখ্যার জোড়ার সংখ্যা গণনা করে যাদের যোগফল একটি প্রদত্ত জোড় সংখ্যার সমান।\n# ফাংশনটি একটি একক আর্গুমেন্ট গ্রহণ করে, even_number, যা ৬ এর চেয়ে বড় এবং ৩২৭৬৭ এর চেয়ে ছোট একটি জোড় সংখ্যা।\n# এটি পৃথক মৌলিক জোড়ার সংখ্যা ফেরত দেয় যাদের যোগফল প্রদত্ত জোড় সংখ্যার সমান।\n# একটি মৌলিক জোড়াকে পৃথক ধরা হয় যদি জোড়ার মৌলিক সংখ্যা ভিন্ন হয়, তাদের ক্রম নির্বিশেষে।\n#\n# উদাহরণ:\n# >>> count_prime_pairs(10)\n# 2 (কারণ 10 কে 3+7 এবং 5+5 হিসাবে প্রকাশ করা যায়)\n# >>> count_prime_pairs(14)\n# 2 (কারণ 14 কে 3+11 এবং 7+7 হিসাবে প্রকাশ করা যায়)\n\ndef count_prime_pairs(even_number)",
      "bg": "# Тази функция изчислява броя на различните двойки прости числа, чиято сума е равна на дадено четно число.\n# Функцията приема един аргумент, even_number, което е четно число по-голямо от 6 и по-малко от 32767.\n# Тя връща броя на различните двойки прости числа, чиято сума е равна на даденото четно число.\n# Двойка прости числа се счита за различна, ако простите числа в двойката са различни, независимо от техния ред.\n#\n# Пример:\n# >>> count_prime_pairs(10)\n# 2 (тъй като 10 може да бъде изразено като 3+7 и 5+5)\n# >>> count_prime_pairs(14)\n# 2 (тъй като 14 може да бъде изразено като 3+11 и 7+7)\n\ndef count_prime_pairs(even_number)",
      "zh": "# 此函数计算和等于给定偶数的不同素数对的数量。\n# 该函数接受一个参数 even_number，它是一个大于 6 且小于 32767 的偶数。\n# 它返回和等于给定偶数的不同素数对的计数。\n# 如果素数对中的素数不同，则认为素数对是不同的，无论它们的顺序如何。\n#\n# 示例：\n# >>> count_prime_pairs(10)\n# 2 (因为 10 可以表示为 3+7 和 5+5)\n# >>> count_prime_pairs(14)\n# 2 (因为 14 可以表示为 3+11 和 7+7)\n\ndef count_prime_pairs(even_number)",
      "fr": "# Cette fonction calcule le nombre de paires de nombres premiers différentes dont la somme est égale à un nombre pair donné.\n# La fonction accepte un seul argument, even_number, qui est un nombre pair supérieur à 6 et inférieur à 32767.\n# Elle renvoie le nombre de paires de nombres premiers distinctes dont la somme est égale au nombre pair donné.\n# Une paire de nombres premiers est considérée comme distincte si les nombres premiers de la paire sont différents, peu importe leur ordre.\n#\n# Exemple :\n# >>> count_prime_pairs(10)\n# 2 (puisque 10 peut être exprimé comme 3+7 et 5+5)\n# >>> count_prime_pairs(14)\n# 2 (puisque 14 peut être exprimé comme 3+11 et 7+7)\n\ndef count_prime_pairs(even_number)",
      "de": "# Diese Funktion berechnet die Anzahl der verschiedenen Primzahlpaare, deren Summe einer gegebenen geraden Zahl entspricht.\n# Die Funktion akzeptiert ein einzelnes Argument, even_number, welches eine gerade Zahl größer als 6 und kleiner als 32767 ist.\n# Sie gibt die Anzahl der verschiedenen Primzahlpaare zurück, deren Summe der gegebenen geraden Zahl entspricht.\n# Ein Primzahlpaar wird als verschieden betrachtet, wenn die Primzahlen im Paar unterschiedlich sind, unabhängig von ihrer Reihenfolge.\n#\n# Beispiel:\n# >>> count_prime_pairs(10)\n# 2 (da 10 als 3+7 und 5+5 ausgedrückt werden kann)\n# >>> count_prime_pairs(14)\n# 2 (da 14 als 3+11 und 7+7 ausgedrückt werden kann)\n\ndef count_prime_pairs(even_number)",
      "ha": "# Wannan aikin yana ƙididdige adadin nau'ikan ma'aurata lambobin farko daban-daban waɗanda jimlarsu ta yi daidai da wata lamba mai ma'ana.\n# Aikin yana karɓar hujja guda, even_number, wanda wata lamba ce mai ma'ana mai girma fiye da 6 kuma ƙasa da 32767.\n# Yana mayar da adadin ma'aurata lambobin farko daban-daban waɗanda jimlarsu ta yi daidai da wannan lamba mai ma'ana.\n# Ana ɗaukar ma'aurata lambobin farko a matsayin daban idan lambobin farko a cikin ma'auratan sun bambanta, ba tare da la'akari da yadda aka jera su ba.\n#\n# Misali:\n# >>> count_prime_pairs(10)\n# 2 (saboda 10 za a iya bayyana shi a matsayin 3+7 da 5+5)\n# >>> count_prime_pairs(14)\n# 2 (saboda 14 za a iya bayyana shi a matsayin 3+11 da 7+7)\n\ndef count_prime_pairs(even_number)",
      "hi": "# यह फ़ंक्शन उन विभिन्न अभाज्य युग्मों की संख्या की गणना करता है जिनका योग एक दिए गए सम संख्या के बराबर होता है।\n# फ़ंक्शन एक एकल तर्क स्वीकार करता है, even_number, जो 6 से बड़ा और 32767 से कम एक सम संख्या है।\n# यह उन विशिष्ट अभाज्य युग्मों की गिनती लौटाता है जिनका योग दिए गए सम संख्या के बराबर होता है।\n# एक अभाज्य युग्म को विशिष्ट माना जाता है यदि युग्म में अभाज्य संख्याएँ भिन्न हैं, चाहे उनका क्रम कुछ भी हो।\n#\n# उदाहरण:\n# >>> count_prime_pairs(10)\n# 2 (क्योंकि 10 को 3+7 और 5+5 के रूप में व्यक्त किया जा सकता है)\n# >>> count_prime_pairs(14)\n# 2 (क्योंकि 14 को 3+11 और 7+7 के रूप में व्यक्त किया जा सकता है)\n\ndef count_prime_pairs(even_number)",
      "hu": "# Ez a függvény kiszámítja a különböző prímszám párok számát, amelyek összege megegyezik egy adott páros számmal.\n# A függvény egyetlen argumentumot fogad el, even_number, amely egy 6-nál nagyobb és 32767-nél kisebb páros szám.\n# Visszaadja azon különböző prímpárok számát, amelyek összege megegyezik a megadott páros számmal.\n# Egy prímpárt akkor tekintünk különbözőnek, ha a párban lévő prímek különböznek, függetlenül a sorrendjüktől.\n#\n# Példa:\n# >>> count_prime_pairs(10)\n# 2 (mivel a 10 kifejezhető mint 3+7 és 5+5)\n# >>> count_prime_pairs(14)\n# 2 (mivel a 14 kifejezhető mint 3+11 és 7+7)\n\ndef count_prime_pairs(even_number)"
    },
    "prompt_bertscore": {
      "sq": "0.9612535688322864",
      "hy": "0.9578484482102053",
      "bn": "0.9661422597703171",
      "bg": "0.9599306904945941",
      "zh": "0.9851245707642973",
      "fr": "0.970849799800844",
      "de": "0.9772222596852053",
      "ha": "0.9488204987617886",
      "hi": "0.984753330582143",
      "hu": "0.9946232742157666"
    },
    "canonical_solution": "    # Helper function to check if a number is prime\n    def is_prime?(num)\n      return false if num <= 1\n      (2...num).none? { |i| num % i == 0 }\n    end\n  \n    # Generating a list of primes up to even_number\n    primes = (2...even_number).select { |num| is_prime?(num) }\n  \n    # Counting distinct prime pairs\n    count = 0\n    primes.each_with_index do |prime, index|\n      count += 1 if primes[index..-1].any? { |other_prime| prime + other_prime == even_number }\n    end\n  \n    count\n  end\n",
    "instruction": {
      "en": "Write a ruby function `def count_prime_pairs(even_number)` to solve the following problem:\nThis function calculates the number of different prime pairs whose sum equals a given even number.\nThe function accepts a single argument, even_number, which is an even number greater than 6 and less than 32767.\nIt returns the count of distinct prime pairs whose sum equals the given even number.\nA prime pair is considered distinct if the primes in the pair are different, regardless of their order.\n\nExample:\n>>> count_prime_pairs(10)\n2 (since 10 can be expressed as 3+7 and 5+5)\n>>> count_prime_pairs(14)\n2 (since 14 can be expressed as 3+11 and 7+7)",
      "sq": "Shkruani një funksion ruby `def count_prime_pairs(even_number)` për të zgjidhur problemin e mëposhtëm:\nKy funksion llogarit numrin e çifteve të ndryshme të numrave të thjeshtë, shuma e të cilëve është e barabartë me një numër çift të dhënë.\nFunksioni pranon një argument të vetëm, even_number, i cili është një numër çift më i madh se 6 dhe më i vogël se 32767.\nAi kthen numrin e çifteve të ndryshme të numrave të thjeshtë, shuma e të cilëve është e barabartë me numrin çift të dhënë.\nNjë çift numrash të thjeshtë konsiderohet i ndryshëm nëse numrat e thjeshtë në çift janë të ndryshëm, pavarësisht nga rendi i tyre.\n\nShembull:\n>>> count_prime_pairs(10)\n2 (pasi 10 mund të shprehet si 3+7 dhe 5+5)\n>>> count_prime_pairs(14)\n2 (pasi 14 mund të shprehet si 3+11 dhe 7+7)",
      "hy": "Գրեք ruby ֆունկցիա `def count_prime_pairs(even_number)` հետևյալ խնդիրը լուծելու համար:\nԱյս ֆունկցիան հաշվում է տարբեր պարզ թվերի զույգերի քանակը, որոնց գումարը հավասար է տրված զույգ թվին։\nՖունկցիան ընդունում է մեկ արգումենտ, even_number, որը զույգ թիվ է, մեծ քան 6 և փոքր քան 32767։\nԱյն վերադարձնում է տարբեր պարզ զույգերի քանակը, որոնց գումարը հավասար է տրված զույգ թվին։\nՊարզ զույգը համարվում է տարբեր, եթե զույգի պարզ թվերը տարբեր են, անկախ նրանց հերթականությունից։\n\nՕրինակ:\n>>> count_prime_pairs(10)\n2 (քանի որ 10-ը կարելի է արտահայտել որպես 3+7 և 5+5)\n>>> count_prime_pairs(14)\n2 (քանի որ 14-ը կարելի է արտահայտել որպես 3+11 և 7+7)",
      "bn": "Ruby ফাংশন `def count_prime_pairs(even_number)` লিখুন নিম্নলিখিত সমস্যার সমাধানের জন্য:\nএই ফাংশনটি বিভিন্ন মৌলিক সংখ্যার জোড়ার সংখ্যা গণনা করে যাদের যোগফল একটি প্রদত্ত জোড় সংখ্যার সমান।\nফাংশনটি একটি একক আর্গুমেন্ট গ্রহণ করে, even_number, যা 6 এর চেয়ে বড় এবং 32767 এর চেয়ে ছোট একটি জোড় সংখ্যা।\nএটি ভিন্ন মৌলিক সংখ্যার জোড়ার সংখ্যা ফেরত দেয় যাদের যোগফল প্রদত্ত জোড় সংখ্যার সমান।\nএকটি মৌলিক সংখ্যার জোড়কে ভিন্ন ধরা হয় যদি জোড়ার মধ্যে মৌলিক সংখ্যা ভিন্ন হয়, তাদের ক্রম নির্বিশেষে।\n\nউদাহরণ:\n>>> count_prime_pairs(10)\n2 (কারণ 10 কে 3+7 এবং 5+5 হিসাবে প্রকাশ করা যায়)\n>>> count_prime_pairs(14)\n2 (কারণ 14 কে 3+11 এবং 7+7 হিসাবে প্রকাশ করা যায়)",
      "bg": "Напишете функция на Ruby `def count_prime_pairs(even_number)` за решаване на следния проблем:\nТази функция изчислява броя на различните двойки прости числа, чиято сума е равна на дадено четно число.\nФункцията приема един аргумент, even_number, което е четно число по-голямо от 6 и по-малко от 32767.\nТя връща броя на различните двойки прости числа, чиято сума е равна на даденото четно число.\nЕдна двойка прости числа се счита за различна, ако простите числа в двойката са различни, независимо от техния ред.\n\nПример:\n>>> count_prime_pairs(10)\n2 (тъй като 10 може да се изрази като 3+7 и 5+5)\n>>> count_prime_pairs(14)\n2 (тъй като 14 може да се изрази като 3+11 и 7+7)",
      "zh": "编写一个 ruby 函数 `def count_prime_pairs(even_number)` 来解决以下问题：\n该函数计算和等于给定偶数的不同素数对的数量。\n函数接受一个参数 even_number，它是一个大于 6 且小于 32767 的偶数。\n它返回和等于给定偶数的不同素数对的数量。\n如果素数对中的素数不同，则无论顺序如何，该素数对被视为不同。\n\n示例：\n>>> count_prime_pairs(10)\n2 (因为 10 可以表示为 3+7 和 5+5)\n>>> count_prime_pairs(14)\n2 (因为 14 可以表示为 3+11 和 7+7)",
      "fr": "Écrire une fonction ruby `def count_prime_pairs(even_number)` pour résoudre le problème suivant :\nCette fonction calcule le nombre de paires de nombres premiers différentes dont la somme est égale à un nombre pair donné.\nLa fonction accepte un seul argument, even_number, qui est un nombre pair supérieur à 6 et inférieur à 32767.\nElle renvoie le compte des paires de nombres premiers distinctes dont la somme est égale au nombre pair donné.\nUne paire de nombres premiers est considérée comme distincte si les nombres premiers dans la paire sont différents, indépendamment de leur ordre.\n\nExemple :\n>>> count_prime_pairs(10)\n2 (puisque 10 peut être exprimé comme 3+7 et 5+5)\n>>> count_prime_pairs(14)\n2 (puisque 14 peut être exprimé comme 3+11 et 7+7)",
      "de": "Schreiben Sie eine Ruby-Funktion `def count_prime_pairs(even_number)`, um das folgende Problem zu lösen:\nDiese Funktion berechnet die Anzahl der verschiedenen Primzahlpaare, deren Summe einer gegebenen geraden Zahl entspricht.\nDie Funktion akzeptiert ein einzelnes Argument, even_number, das eine gerade Zahl größer als 6 und kleiner als 32767 ist.\nSie gibt die Anzahl der unterschiedlichen Primzahlpaare zurück, deren Summe der gegebenen geraden Zahl entspricht.\nEin Primzahlpaar wird als unterschiedlich betrachtet, wenn die Primzahlen im Paar verschieden sind, unabhängig von ihrer Reihenfolge.\n\nBeispiel:\n>>> count_prime_pairs(10)\n2 (da 10 als 3+7 und 5+5 ausgedrückt werden kann)\n>>> count_prime_pairs(14)\n2 (da 14 als 3+11 und 7+7 ausgedrückt werden kann)",
      "ha": "Rubuta aikin ruby `def count_prime_pairs(even_number)` don warware matsalar mai zuwa:\nWannan aikin yana lissafin adadin ma'aurata firam masu bambanci da jimlarsu ta yi daidai da wani adadi mai ma'ana.\nAikin yana karɓar hujja guda, even_number, wanda shi ne adadi mai ma'ana mafi girma fiye da 6 kuma ƙasa da 32767.\nYana dawowa da ƙididdigar ma'aurata firam masu bambanci da jimlarsu ta yi daidai da adadin mai ma'ana da aka bayar.\nAna ɗaukar ma'aurata firam a matsayin masu bambanci idan firam ɗin a cikin ma'auratan sun bambanta, ba tare da la'akari da tsarinsu ba.\n\nMisali:\n>>> count_prime_pairs(10)\n2 (tun da 10 za a iya bayyana shi azaman 3+7 da 5+5)\n>>> count_prime_pairs(14)\n2 (tun da 14 za a iya bayyana shi azaman 3+11 da 7+7)",
      "hi": "रूबी फ़ंक्शन `def count_prime_pairs(even_number)` लिखें ताकि निम्नलिखित समस्या का समाधान हो सके:\nयह फ़ंक्शन उन विभिन्न अभाज्य युग्मों की संख्या की गणना करता है जिनका योग दिए गए सम संख्या के बराबर होता है।\nफ़ंक्शन एक एकल तर्क स्वीकार करता है, even_number, जो 6 से बड़ा और 32767 से कम एक सम संख्या है।\nयह उन विशिष्ट अभाज्य युग्मों की गिनती लौटाता है जिनका योग दिए गए सम संख्या के बराबर होता है।\nएक अभाज्य युग्म को विशिष्ट माना जाता है यदि युग्म में अभाज्य संख्याएँ भिन्न हैं, चाहे उनके क्रम कुछ भी हों।\n\nउदाहरण:\n>>> count_prime_pairs(10)\n2 (क्योंकि 10 को 3+7 और 5+5 के रूप में व्यक्त किया जा सकता है)\n>>> count_prime_pairs(14)\n2 (क्योंकि 14 को 3+11 और 7+7 के रूप में व्यक्त किया जा सकता है)",
      "hu": "Írj egy ruby függvényt `def count_prime_pairs(even_number)` a következő probléma megoldására:\nEz a függvény kiszámítja a különböző prímpárok számát, amelyek összege megegyezik egy adott páros számmal.\nA függvény egyetlen argumentumot fogad el, even_number, amely egy 6-nál nagyobb és 32767-nél kisebb páros szám.\nVisszaadja a különböző prímpárok számát, amelyek összege megegyezik a megadott páros számmal.\nEgy prímpárt akkor tekintünk különbözőnek, ha a párban lévő prímek különböznek, függetlenül a sorrendtől.\n\nPélda:\n>>> count_prime_pairs(10)\n2 (mivel a 10 kifejezhető mint 3+7 és 5+5)\n>>> count_prime_pairs(14)\n2 (mivel a 14 kifejezhető mint 3+11 és 7+7)"
    },
    "instruction_bertscore": {
      "sq": "0.965760293547587",
      "hy": "0.9626553034312496",
      "bn": "0.9545468140166434",
      "bg": "0.9610380548688636",
      "zh": "0.959622614773609",
      "fr": "0.973861830898857",
      "de": "0.983278301372578",
      "ha": "0.991198091925201",
      "hi": "0.9713370401255226",
      "hu": "0.9917512775363831"
    },
    "level": "hard",
    "test": "raise 'Test failed' unless count_prime_pairs(10) == 2\nraise 'Test failed' unless count_prime_pairs(14) == 2\nraise 'Test failed' unless count_prime_pairs(20) == 2\nraise 'Test failed' unless count_prime_pairs(26) == 3\nraise 'Test failed' unless count_prime_pairs(100) == 6\nraise 'Test failed' unless count_prime_pairs(1234) == 25\n\n\nputs 'All tests passed!'",
    "entry_point": "count_prime_pairs",
    "signature": "def count_prime_pairs(even_number)",
    "docstring": {
      "en": "This function calculates the number of different prime pairs whose sum equals a given even number.\nThe function accepts a single argument, even_number, which is an even number greater than 6 and less than 32767.\nIt returns the count of distinct prime pairs whose sum equals the given even number.\nA prime pair is considered distinct if the primes in the pair are different, regardless of their order.\n\nExample:\n>>> count_prime_pairs(10)\n2 (since 10 can be expressed as 3+7 and 5+5)\n>>> count_prime_pairs(14)\n2 (since 14 can be expressed as 3+11 and 7+7)",
      "sq": "Kjo funksion llogarit numrin e çifteve të ndryshme të numrave të parë, shuma e të cilëve është e barabartë me një numër çift të dhënë.\nFunksioni pranon një argument të vetëm, even_number, i cili është një numër çift më i madh se 6 dhe më i vogël se 32767.\nKthen numrin e çifteve të ndryshme të numrave të parë, shuma e të cilëve është e barabartë me numrin çift të dhënë.\nNjë çift numrash të parë konsiderohet i ndryshëm nëse numrat e parë në çift janë të ndryshëm, pavarësisht nga rendi i tyre.\n\nShembull:\n>>> count_prime_pairs(10)\n2 (meqë 10 mund të shprehet si 3+7 dhe 5+5)\n>>> count_prime_pairs(14)\n2 (meqë 14 mund të shprehet si 3+11 dhe 7+7)",
      "hy": "Այս ֆունկցիան հաշվարկում է տարբեր պարզ թվերի զույգերի քանակը, որոնց գումարը հավասար է տրված զույգ թվին։  \nՖունկցիան ընդունում է մեկ արգումենտ՝ even_number, որը զույգ թիվ է՝ մեծ 6-ից և փոքր 32767-ից։  \nԱյն վերադարձնում է տարբեր պարզ զույգերի քանակը, որոնց գումարը հավասար է տրված զույգ թվին։  \nՊարզ զույգը համարվում է տարբեր, եթե զույգի մեջ գտնվող պարզ թվերը տարբեր են՝ անկախ դրանց կարգից։  \n\nՕրինակ:  \n>>> count_prime_pairs(10)  \n2 (քանի որ 10-ը կարող է արտահայտվել որպես 3+7 և 5+5)  \n>>> count_prime_pairs(14)  \n2 (քանի որ 14-ը կարող է արտահայտվել որպես 3+11 և 7+7)",
      "bn": "এই ফাংশনটি বিভিন্ন মৌলিক জোড়ার সংখ্যা গণনা করে যাদের যোগফল একটি প্রদত্ত জোড় সংখ্যার সমান হয়। \nফাংশনটি একটি একক আর্গুমেন্ট গ্রহণ করে, even_number, যা একটি জোড় সংখ্যা যা ৬ এর চেয়ে বড় এবং ৩২৭৬৭ এর চেয়ে ছোট। \nএটি ভিন্ন মৌলিক জোড়ার সংখ্যা ফেরত দেয় যাদের যোগফল প্রদত্ত জোড় সংখ্যার সমান। \nএকটি মৌলিক জোড়াকে ভিন্ন বলে বিবেচনা করা হয় যদি জোড়ার মৌলিক সংখ্যা ভিন্ন হয়, তাদের ক্রম নির্বিশেষে।\n\nউদাহরণ:\n>>> count_prime_pairs(10)\n2 (কারণ 10 কে 3+7 এবং 5+5 হিসাবে প্রকাশ করা যায়)\n>>> count_prime_pairs(14)\n2 (কারণ 14 কে 3+11 এবং 7+7 হিসাবে প্রকাশ করা যায়)",
      "bg": "Тази функция изчислява броя на различните двойки прости числа, чиято сума е равна на дадено четно число. \nФункцията приема един аргумент, even_number, което е четно число по-голямо от 6 и по-малко от 32767. \nТя връща броя на различните двойки прости числа, чиято сума е равна на даденото четно число. \nДвойка прости числа се счита за различна, ако простите числа в двойката са различни, независимо от техния ред.\n\nПример:\n>>> count_prime_pairs(10)\n2 (тъй като 10 може да се изрази като 3+7 и 5+5)\n>>> count_prime_pairs(14)\n2 (тъй като 14 може да се изрази като 3+11 и 7+7)",
      "zh": "该函数计算和等于给定偶数的不同质数对的数量。  \n该函数接受一个参数，even_number，这是一个大于6且小于32767的偶数。  \n它返回和等于给定偶数的不同质数对的数量。  \n如果质数对中的质数不同，则该质数对被视为不同的，无论它们的顺序如何。\n\n示例：  \n>>> count_prime_pairs(10)  \n2 (因为10可以表示为3+7和5+5)  \n>>> count_prime_pairs(14)  \n2 (因为14可以表示为3+11和7+7)",
      "fr": "Cette fonction calcule le nombre de paires de nombres premiers différentes dont la somme est égale à un nombre pair donné.\nLa fonction accepte un seul argument, even_number, qui est un nombre pair supérieur à 6 et inférieur à 32767.\nElle renvoie le nombre de paires de nombres premiers distinctes dont la somme est égale au nombre pair donné.\nUne paire de nombres premiers est considérée comme distincte si les nombres premiers de la paire sont différents, indépendamment de leur ordre.\n\nExemple :\n>>> count_prime_pairs(10)\n2 (puisque 10 peut être exprimé comme 3+7 et 5+5)\n>>> count_prime_pairs(14)\n2 (puisque 14 peut être exprimé comme 3+11 et 7+7)",
      "de": "Diese Funktion berechnet die Anzahl der verschiedenen Primzahlpaare, deren Summe einer gegebenen geraden Zahl entspricht.  \nDie Funktion akzeptiert ein einziges Argument, even_number, das eine gerade Zahl größer als 6 und kleiner als 32767 ist.  \nSie gibt die Anzahl der unterschiedlichen Primzahlpaare zurück, deren Summe der gegebenen geraden Zahl entspricht.  \nEin Primzahlpaar wird als unterschiedlich betrachtet, wenn die Primzahlen im Paar verschieden sind, unabhängig von ihrer Reihenfolge.  \n\nBeispiel:  \n>>> count_prime_pairs(10)  \n2 (da 10 als 3+7 und 5+5 ausgedrückt werden kann)  \n>>> count_prime_pairs(14)  \n2 (da 14 als 3+11 und 7+7 ausgedrückt werden kann)  ",
      "ha": "Wannan aikin yana ƙididdige adadin nau'ikan ma'aurata lambobin farko daban-daban waɗanda jimlarsu ta yi daidai da wani lamba mai ma'ana.\n\nAikin yana karɓar hujja guda ɗaya, even_number, wanda shine lamba mai ma'ana wanda ya fi 6 kuma ƙasa da 32767.\n\nYana mayar da adadin ma'aurata lambobin farko daban-daban waɗanda jimlarsu ta yi daidai da lambar mai ma'ana da aka bayar.\n\nAna ɗaukar ma'aurata lambobin farko daban-daban idan lambobin farko a cikin ma'auratan sun bambanta, ba tare da la'akari da tsarinsu ba.\n\nMisali:\n>>> count_prime_pairs(10)\n2 (saboda 10 za a iya bayyana shi da 3+7 da 5+5)\n>>> count_prime_pairs(14)\n2 (saboda 14 za a iya bayyana shi da 3+11 da 7+7)",
      "hi": "यह फ़ंक्शन उन विभिन्न अभाज्य युग्मों की संख्या की गणना करता है जिनका योग एक दिए गए सम संख्या के बराबर होता है। \nयह फ़ंक्शन एकल तर्क, even_number, को स्वीकार करता है, जो 6 से बड़ा और 32767 से कम एक सम संख्या है। \nयह उन भिन्न अभाज्य युग्मों की गिनती लौटाता है जिनका योग दिए गए सम संख्या के बराबर होता है। \nएक अभाज्य युग्म को भिन्न माना जाता है यदि युग्म में अभाज्य संख्याएँ अलग-अलग हों, चाहे उनकी क्रम कुछ भी हो।\n\nउदाहरण:\n>>> count_prime_pairs(10)\n2 (क्योंकि 10 को 3+7 और 5+5 के रूप में व्यक्त किया जा सकता है)\n>>> count_prime_pairs(14)\n2 (क्योंकि 14 को 3+11 और 7+7 के रूप में व्यक्त किया जा सकता है)",
      "hu": "Ez a függvény kiszámítja azon különböző prímpárok számát, amelyek összege megegyezik egy adott páros számmal.  \nA függvény egyetlen argumentumot fogad el, even_number, amely egy 6-nál nagyobb és 32767-nél kisebb páros szám.  \nVisszaadja azon különböző prímpárok számát, amelyek összege megegyezik a megadott páros számmal.  \nEgy prímpárt akkor tekintünk különbözőnek, ha a párban lévő prímek különböznek, függetlenül a sorrendtől.\n\nPélda:\n>>> count_prime_pairs(10)\n2 (mivel a 10 kifejezhető 3+7 és 5+5 összegeként)\n>>> count_prime_pairs(14)\n2 (mivel a 14 kifejezhető 3+11 és 7+7 összegeként)"
    },
    "docstring_bertscore": {
      "sq": "0.9566479261872305",
      "hy": "0.9548534993249613",
      "bn": "0.9748613389762245",
      "bg": "0.9549937323739719",
      "zh": "0.9626992007454583",
      "fr": "0.9626553034312496",
      "de": "0.9865392163380277",
      "ha": "0.9474322710287358",
      "hi": "0.9886045750400284",
      "hu": "0.9780386305512586"
    }
  },
  {
    "task_id": "Ruby/23",
    "prompt": {
      "en": "# Calculates the minimum number of character operations needed to transform one string into another.\n# The function takes two string arguments, str_a and str_b. The operations allowed are:\n# 1. Delete a character;\n# 2. Insert a character;\n# 3. Replace a character with another.\n# It returns an integer representing the minimum number of operations required to transform str_a into str_b.\n# Both strings should have a length less than 200.\n#\n# Example:\n# >>> min_operations_to_transform(\"apple\", \"aple\")\n# 1\n# >>> min_operations_to_transform(\"kitten\", \"sitting\")\n# 3\n\ndef min_operations_to_transform(str_a, str_b)",
      "sq": "# Llogarit numrin minimal të operacioneve të karaktereve të nevojshme për të transformuar një varg në një tjetër.\n# Funksioni merr dy argumente vargjesh, str_a dhe str_b. Operacionet e lejuara janë:\n# 1. Fshi një karakter;\n# 2. Fut një karakter;\n# 3. Zëvendëso një karakter me një tjetër.\n# Kthen një numër të plotë që përfaqëson numrin minimal të operacioneve të nevojshme për të transformuar str_a në str_b.\n# Të dy vargjet duhet të kenë një gjatësi më pak se 200.\n#\n# Shembull:\n# >>> min_operations_to_transform(\"apple\", \"aple\")\n# 1\n# >>> min_operations_to_transform(\"kitten\", \"sitting\")\n# 3\n\ndef min_operations_to_transform(str_a, str_b)",
      "hy": "# Հաշվում է նվազագույն քանակով գործողությունները, որոնք անհրաժեշտ են մեկ տողը մյուսի վերածելու համար։\n# Ֆունկցիան ընդունում է երկու տողային արգումենտներ՝ str_a և str_b։ Թույլատրված գործողություններն են՝\n# 1. Ջնջել նիշը;\n# 2. Նիշ ավելացնել;\n# 3. Փոխարինել նիշը մեկ այլ նիշով։\n# Վերադարձնում է ամբողջ թիվ, որը ներկայացնում է նվազագույն գործողությունների քանակը, որոնք անհրաժեշտ են str_a-ը str_b-ի վերածելու համար։\n# Երկու տողերի երկարությունը պետք է լինի 200-ից փոքր։\n#\n# Օրինակ:\n# >>> min_operations_to_transform(\"apple\", \"aple\")\n# 1\n# >>> min_operations_to_transform(\"kitten\", \"sitting\")\n# 3\n\ndef min_operations_to_transform(str_a, str_b)",
      "bn": "# একটি স্ট্রিংকে অন্য স্ট্রিংয়ে রূপান্তর করতে প্রয়োজনীয় সর্বনিম্ন সংখ্যক চরিত্র অপারেশন গণনা করে।\n# ফাংশনটি দুটি স্ট্রিং আর্গুমেন্ট নেয়, str_a এবং str_b। অনুমোদিত অপারেশনগুলি হল:\n# 1. একটি চরিত্র মুছে ফেলা;\n# 2. একটি চরিত্র সন্নিবেশ করা;\n# 3. একটি চরিত্রকে অন্যটির সাথে প্রতিস্থাপন করা।\n# এটি একটি পূর্ণসংখ্যা প্রদান করে যা str_a কে str_b তে রূপান্তর করতে প্রয়োজনীয় সর্বনিম্ন অপারেশনের সংখ্যা উপস্থাপন করে।\n# উভয় স্ট্রিংয়ের দৈর্ঘ্য 200 এর কম হওয়া উচিত।\n#\n# উদাহরণ:\n# >>> min_operations_to_transform(\"apple\", \"aple\")\n# 1\n# >>> min_operations_to_transform(\"kitten\", \"sitting\")\n# 3\n\ndef min_operations_to_transform(str_a, str_b)",
      "bg": "# Изчислява минималния брой операции с символи, необходими за преобразуване на един низ в друг.\n# Функцията приема два аргумента от тип низ, str_a и str_b. Позволените операции са:\n# 1. Изтриване на символ;\n# 2. Вмъкване на символ;\n# 3. Замяна на един символ с друг.\n# Връща цяло число, представляващо минималния брой операции, необходими за преобразуване на str_a в str_b.\n# И двата низа трябва да имат дължина по-малка от 200.\n#\n# Пример:\n# >>> min_operations_to_transform(\"apple\", \"aple\")\n# 1\n# >>> min_operations_to_transform(\"kitten\", \"sitting\")\n# 3\n\ndef min_operations_to_transform(str_a, str_b)",
      "zh": "# 计算将一个字符串转换为另一个字符串所需的最小字符操作数。\n# 该函数接受两个字符串参数，str_a 和 str_b。允许的操作有：\n# 1. 删除一个字符；\n# 2. 插入一个字符；\n# 3. 将一个字符替换为另一个字符。\n# 它返回一个整数，表示将 str_a 转换为 str_b 所需的最小操作数。\n# 两个字符串的长度都应小于 200。\n#\n# 示例:\n# >>> min_operations_to_transform(\"apple\", \"aple\")\n# 1\n# >>> min_operations_to_transform(\"kitten\", \"sitting\")\n# 3\n\ndef min_operations_to_transform(str_a, str_b)",
      "fr": "# Calcule le nombre minimum d'opérations de caractères nécessaires pour transformer une chaîne en une autre.\n# La fonction prend deux arguments de type chaîne, str_a et str_b. Les opérations autorisées sont :\n# 1. Supprimer un caractère ;\n# 2. Insérer un caractère ;\n# 3. Remplacer un caractère par un autre.\n# Elle renvoie un entier représentant le nombre minimum d'opérations nécessaires pour transformer str_a en str_b.\n# Les deux chaînes doivent avoir une longueur inférieure à 200.\n#\n# Exemple :\n# >>> min_operations_to_transform(\"apple\", \"aple\")\n# 1\n# >>> min_operations_to_transform(\"kitten\", \"sitting\")\n# 3\n\ndef min_operations_to_transform(str_a, str_b)",
      "de": "# Berechnet die minimale Anzahl an Zeichenoperationen, die benötigt werden, um einen String in einen anderen zu transformieren.\n# Die Funktion nimmt zwei String-Argumente, str_a und str_b. Die erlaubten Operationen sind:\n# 1. Ein Zeichen löschen;\n# 2. Ein Zeichen einfügen;\n# 3. Ein Zeichen durch ein anderes ersetzen.\n# Sie gibt eine ganze Zahl zurück, die die minimale Anzahl an Operationen darstellt, die erforderlich sind, um str_a in str_b zu transformieren.\n# Beide Strings sollten eine Länge von weniger als 200 haben.\n#\n# Beispiel:\n# >>> min_operations_to_transform(\"apple\", \"aple\")\n# 1\n# >>> min_operations_to_transform(\"kitten\", \"sitting\")\n# 3\n\ndef min_operations_to_transform(str_a, str_b)",
      "ha": "# Lissafin mafi ƙarancin adadin ayyukan haruffa da ake buƙata don canza kirtani ɗaya zuwa wani.\n# Aikin yana ɗaukar hujjoji guda biyu na kirtani, str_a da str_b. Ayyukan da aka yarda sune:\n# 1. Goge harafi;\n# 2. Saka harafi;\n# 3. Maye gurbin harafi da wani.\n# Yana dawowa da lamba mai nuna mafi ƙarancin adadin ayyukan da ake buƙata don canza str_a zuwa str_b.\n# Duk kirtani biyu ya kamata su kasance da tsawon ƙasa da 200.\n#\n# Misali:\n# >>> min_operations_to_transform(\"apple\", \"aple\")\n# 1\n# >>> min_operations_to_transform(\"kitten\", \"sitting\")\n# 3\n\ndef min_operations_to_transform(str_a, str_b)",
      "hi": "# एक स्ट्रिंग को दूसरी स्ट्रिंग में बदलने के लिए आवश्यक न्यूनतम वर्ण संचालन की गणना करता है।\n# फ़ंक्शन दो स्ट्रिंग तर्क लेता है, str_a और str_b। अनुमत संचालन हैं:\n# 1. एक वर्ण को हटाना;\n# 2. एक वर्ण जोड़ना;\n# 3. एक वर्ण को दूसरे के साथ बदलना।\n# यह एक पूर्णांक लौटाता है जो str_a को str_b में बदलने के लिए आवश्यक न्यूनतम संचालन की संख्या का प्रतिनिधित्व करता है।\n# दोनों स्ट्रिंग्स की लंबाई 200 से कम होनी चाहिए।\n#\n# उदाहरण:\n# >>> min_operations_to_transform(\"apple\", \"aple\")\n# 1\n# >>> min_operations_to_transform(\"kitten\", \"sitting\")\n# 3\n\ndef min_operations_to_transform(str_a, str_b)",
      "hu": "# Kiszámítja a minimális karakterműveletek számát, amelyek szükségesek egy string másik stringgé alakításához.\n# A függvény két string argumentumot vesz fel, str_a és str_b. Az engedélyezett műveletek a következők:\n# 1. Egy karakter törlése;\n# 2. Egy karakter beszúrása;\n# 3. Egy karakter cseréje egy másikra.\n# Egy egész számot ad vissza, amely a minimális műveletek számát jelenti, amelyek szükségesek str_a str_b-vé alakításához.\n# Mindkét string hossza kevesebb, mint 200 legyen.\n#\n# Példa:\n# >>> min_operations_to_transform(\"apple\", \"aple\")\n# 1\n# >>> min_operations_to_transform(\"kitten\", \"sitting\")\n# 3\n\ndef min_operations_to_transform(str_a, str_b)"
    },
    "prompt_bertscore": {
      "sq": "0.9896652612747547",
      "hy": "0.9782825486591694",
      "bn": "0.9730949189976813",
      "bg": "0.9704392308032448",
      "zh": "0.9820712245470289",
      "fr": "0.9871134567695996",
      "de": "0.9967343179054055",
      "ha": "0.985356769679727",
      "hi": "0.9778038494408754",
      "hu": "0.9698663807843402"
    },
    "canonical_solution": "    m, n = str_a.length, str_b.length\n    dp = Array.new(m + 1) { Array.new(n + 1) }\n  \n    (0..m).each { |i| dp[i][0] = i }\n    (0..n).each { |j| dp[0][j] = j }\n  \n    (1..m).each do |i|\n      (1..n).each do |j|\n        if str_a[i - 1] == str_b[j - 1]\n          dp[i][j] = dp[i - 1][j - 1]\n        else\n          dp[i][j] = [dp[i - 1][j], dp[i][j - 1], dp[i - 1][j - 1]].min + 1\n        end\n      end\n    end\n  \n    dp[m][n]\n  end",
    "instruction": {
      "en": "Write a ruby function `def min_operations_to_transform(str_a, str_b)` to solve the following problem:\nCalculates the minimum number of character operations needed to transform one string into another.\nThe function takes two string arguments, str_a and str_b. The operations allowed are:\n1. Delete a character;\n2. Insert a character;\n3. Replace a character with another.\nIt returns an integer representing the minimum number of operations required to transform str_a into str_b.\nBoth strings should have a length less than 200.\n\nExample:\n>>> min_operations_to_transform(\"apple\", \"aple\")\n1\n>>> min_operations_to_transform(\"kitten\", \"sitting\")\n3",
      "sq": "Shkruani një funksion ruby `def min_operations_to_transform(str_a, str_b)` për të zgjidhur problemin e mëposhtëm:\nLlogarit numrin minimal të operacioneve të karaktereve të nevojshme për të transformuar një varg në një tjetër.\nFunksioni merr dy argumente vargje, str_a dhe str_b. Operacionet e lejuara janë:\n1. Fshini një karakter;\n2. Futni një karakter;\n3. Zëvendësoni një karakter me një tjetër.\nKthen një numër të plotë që përfaqëson numrin minimal të operacioneve të nevojshme për të transformuar str_a në str_b.\nTë dy vargjet duhet të kenë një gjatësi më pak se 200.\n\nShembull:\n>>> min_operations_to_transform(\"apple\", \"aple\")\n1\n>>> min_operations_to_transform(\"kitten\", \"sitting\")\n3",
      "hy": "Գրեք ruby ֆունկցիա `def min_operations_to_transform(str_a, str_b)` հետևյալ խնդիրը լուծելու համար:\nՀաշվում է նվազագույն քանակի գործողությունները, որոնք անհրաժեշտ են մեկ տողը մյուսի վերածելու համար:\nՖունկցիան ընդունում է երկու տողային արգումենտներ՝ str_a և str_b։ Թույլատրված գործողություններն են՝\n1. Ջնջել նիշը;\n2. Նիշ ավելացնել;\n3. Փոխարինել նիշը մեկ այլով։\nԱյն վերադարձնում է ամբողջ թիվ, որը ներկայացնում է նվազագույն գործողությունների քանակը, որոնք անհրաժեշտ են str_a-ը str_b-ի վերածելու համար:\nԵրկու տողերի երկարությունը պետք է լինի 200-ից պակաս։\n\nՕրինակ:\n>>> min_operations_to_transform(\"apple\", \"aple\")\n1\n>>> min_operations_to_transform(\"kitten\", \"sitting\")\n3",
      "bn": "রুবি ফাংশন `def min_operations_to_transform(str_a, str_b)` লিখুন নিম্নলিখিত সমস্যার সমাধানের জন্য:\nএকটি স্ট্রিংকে অন্যটিতে রূপান্তর করতে প্রয়োজনীয় সর্বনিম্ন অক্ষর অপারেশনের সংখ্যা গণনা করে।\nফাংশনটি দুটি স্ট্রিং আর্গুমেন্ট নেয়, str_a এবং str_b। অনুমোদিত অপারেশনগুলি হল:\n1. একটি অক্ষর মুছে ফেলা;\n2. একটি অক্ষর সন্নিবেশ করা;\n3. একটি অক্ষর অন্যটির সাথে প্রতিস্থাপন করা।\nএটি একটি পূর্ণসংখ্যা ফেরত দেয় যা str_a কে str_b তে রূপান্তর করতে প্রয়োজনীয় সর্বনিম্ন অপারেশনের সংখ্যা উপস্থাপন করে।\nউভয় স্ট্রিংয়ের দৈর্ঘ্য 200 এর কম হওয়া উচিত।\n\nউদাহরণ:\n>>> min_operations_to_transform(\"apple\", \"aple\")\n1\n>>> min_operations_to_transform(\"kitten\", \"sitting\")\n3",
      "bg": "Напишете функция на Ruby `def min_operations_to_transform(str_a, str_b)` за решаване на следния проблем:\nИзчислява минималния брой операции с символи, необходими за трансформиране на един низ в друг.\nФункцията приема два аргумента - низове, str_a и str_b. Разрешените операции са:\n1. Изтриване на символ;\n2. Вмъкване на символ;\n3. Замяна на символ с друг.\nВръща цяло число, представляващо минималния брой операции, необходими за трансформиране на str_a в str_b.\nИ двата низа трябва да имат дължина по-малка от 200.\n\nПример:\n>>> min_operations_to_transform(\"apple\", \"aple\")\n1\n>>> min_operations_to_transform(\"kitten\", \"sitting\")\n3",
      "zh": "编写一个 ruby 函数 `def min_operations_to_transform(str_a, str_b)` 来解决以下问题：\n计算将一个字符串转换为另一个字符串所需的最小字符操作数。\n该函数接受两个字符串参数，str_a 和 str_b。允许的操作有：\n1. 删除一个字符；\n2. 插入一个字符；\n3. 将一个字符替换为另一个字符。\n它返回一个整数，表示将 str_a 转换为 str_b 所需的最小操作数。\n两个字符串的长度都应小于 200。\n\n示例：\n>>> min_operations_to_transform(\"apple\", \"aple\")\n1\n>>> min_operations_to_transform(\"kitten\", \"sitting\")\n3",
      "fr": "Écrire une fonction ruby `def min_operations_to_transform(str_a, str_b)` pour résoudre le problème suivant :\nCalcule le nombre minimum d'opérations de caractères nécessaires pour transformer une chaîne en une autre.\nLa fonction prend deux arguments de chaîne, str_a et str_b. Les opérations autorisées sont :\n1. Supprimer un caractère ;\n2. Insérer un caractère ;\n3. Remplacer un caractère par un autre.\nElle renvoie un entier représentant le nombre minimum d'opérations nécessaires pour transformer str_a en str_b.\nLes deux chaînes doivent avoir une longueur inférieure à 200.\n\nExemple :\n>>> min_operations_to_transform(\"apple\", \"aple\")\n1\n>>> min_operations_to_transform(\"kitten\", \"sitting\")\n3",
      "de": "Schreiben Sie eine Ruby-Funktion `def min_operations_to_transform(str_a, str_b)`, um das folgende Problem zu lösen:\nBerechnet die minimale Anzahl von Zeichenoperationen, die erforderlich sind, um einen String in einen anderen zu transformieren.\nDie Funktion nimmt zwei String-Argumente, str_a und str_b. Die erlaubten Operationen sind:\n1. Ein Zeichen löschen;\n2. Ein Zeichen einfügen;\n3. Ein Zeichen durch ein anderes ersetzen.\nSie gibt eine ganze Zahl zurück, die die minimale Anzahl von Operationen darstellt, die erforderlich sind, um str_a in str_b zu transformieren.\nBeide Strings sollten eine Länge von weniger als 200 haben.\n\nBeispiel:\n>>> min_operations_to_transform(\"apple\", \"aple\")\n1\n>>> min_operations_to_transform(\"kitten\", \"sitting\")\n3",
      "ha": "Rubuta aikin ruby `def min_operations_to_transform(str_a, str_b)` don warware matsalar mai zuwa:\nYana lissafa mafi ƙarancin adadin ayyukan haruffa da ake buƙata don canza kirtani ɗaya zuwa wani.\nAikin yana ɗaukar hujjoji guda biyu na kirtani, str_a da str_b. Ayyukan da aka yarda sune:\n1. Goge harafi;\n2. Saka harafi;\n3. Maye gurbin harafi da wani.\nYana dawowa da cikakken lamba da ke wakiltar mafi ƙarancin adadin ayyukan da ake buƙata don canza str_a zuwa str_b.\nDuk kirtanai ya kamata su kasance da tsawon ƙasa da 200.\n\nMisali:\n>>> min_operations_to_transform(\"apple\", \"aple\")\n1\n>>> min_operations_to_transform(\"kitten\", \"sitting\")\n3",
      "hi": "रूबी फ़ंक्शन `def min_operations_to_transform(str_a, str_b)` लिखें ताकि निम्नलिखित समस्या का समाधान किया जा सके:\nयह गणना करता है कि एक स्ट्रिंग को दूसरे में बदलने के लिए न्यूनतम कितनी वर्ण संचालन की आवश्यकता है।\nयह फ़ंक्शन दो स्ट्रिंग आर्ग्युमेंट्स लेता है, str_a और str_b। अनुमत संचालन हैं:\n1. एक वर्ण हटाना;\n2. एक वर्ण जोड़ना;\n3. एक वर्ण को दूसरे के साथ बदलना।\nयह एक पूर्णांक लौटाता है जो str_a को str_b में बदलने के लिए आवश्यक न्यूनतम संचालन की संख्या का प्रतिनिधित्व करता है।\nदोनों स्ट्रिंग्स की लंबाई 200 से कम होनी चाहिए।\n\nउदाहरण:\n>>> min_operations_to_transform(\"apple\", \"aple\")\n1\n>>> min_operations_to_transform(\"kitten\", \"sitting\")\n3",
      "hu": "Írj egy ruby függvényt `def min_operations_to_transform(str_a, str_b)` a következő probléma megoldására:\nKiszámítja a minimális karakterműveletek számát, amelyek szükségesek ahhoz, hogy az egyik karakterláncot a másikká alakítsuk.\nA függvény két karakterlánc argumentumot vesz fel, str_a és str_b. Az engedélyezett műveletek a következők:\n1. Egy karakter törlése;\n2. Egy karakter beszúrása;\n3. Egy karakter másikra cserélése.\nEgész számot ad vissza, amely a str_a str_b-vé alakításához szükséges minimális műveletek számát jelenti.\nMindkét karakterlánc hossza kevesebb mint 200 legyen.\n\nPélda:\n>>> min_operations_to_transform(\"apple\", \"aple\")\n1\n>>> min_operations_to_transform(\"kitten\", \"sitting\")\n3"
    },
    "instruction_bertscore": {
      "sq": "0.9901910358933541",
      "hy": "0.9818537242797957",
      "bn": "0.970189552414284",
      "bg": "0.9700975865478648",
      "zh": "0.985139865303637",
      "fr": "0.9941096160504104",
      "de": "0.9923666344568293",
      "ha": "0.9853388929454339",
      "hi": "0.981400052489512",
      "hu": "0.9757668948833627"
    },
    "level": "hard",
    "test": "raise 'Test failed' unless min_operations_to_transform(\"apple\", \"aple\") == 1\nraise 'Test failed' unless min_operations_to_transform(\"kitten\", \"sitting\") == 3\nraise 'Test failed' unless min_operations_to_transform(\"sfdxbqw\", \"gfdgw\") == 4\nraise 'Test failed' unless min_operations_to_transform(\"horse\", \"ros\") == 3\nraise 'Test failed' unless min_operations_to_transform(\"\", \"abc\") == 3\n\n\n\nputs 'All tests passed!'",
    "entry_point": "min_operations_to_transform",
    "signature": "def min_operations_to_transform(str_a, str_b)",
    "docstring": {
      "en": "Calculates the minimum number of character operations needed to transform one string into another.\nThe function takes two string arguments, str_a and str_b. The operations allowed are:\n1. Delete a character;\n2. Insert a character;\n3. Replace a character with another.\nIt returns an integer representing the minimum number of operations required to transform str_a into str_b.\nBoth strings should have a length less than 200.\n\nExample:\n>>> min_operations_to_transform(\"apple\", \"aple\")\n1\n>>> min_operations_to_transform(\"kitten\", \"sitting\")\n3",
      "sq": "Llogarit numrin minimal të operacioneve të karaktereve të nevojshme për të transformuar një varg në një tjetër. Funksioni merr dy argumente vargjesh, str_a dhe str_b. Operacionet e lejuara janë: \n1. Fshij një karakter; \n2. Fut një karakter; \n3. Zëvendëso një karakter me një tjetër. \nKthen një numër të plotë që përfaqëson numrin minimal të operacioneve të kërkuara për të transformuar str_a në str_b. Të dy vargjet duhet të kenë një gjatësi më pak se 200.\n\nShembull:\n>>> min_operations_to_transform(\"apple\", \"aple\")\n1\n>>> min_operations_to_transform(\"kitten\", \"sitting\")\n3",
      "hy": "Հաշվում է նվազագույն քանակի գործողությունները, որոնք անհրաժեշտ են մեկ տողը մյուսի վերածելու համար:\nՖունկցիան ընդունում է երկու տողային արգումենտներ՝ str_a և str_b: Թույլատրված գործողություններն են՝\n1. Ջնջել նիշը;\n2. Նիշ ավելացնել;\n3. Փոխարինել նիշը մեկ այլ նիշով:\nՎերադարձնում է ամբողջ թիվ, որը ներկայացնում է նվազագույն գործողությունների քանակը, որոնք անհրաժեշտ են str_a-ը str_b-ի վերածելու համար:\nԵրկու տողերը պետք է ունենան 200-ից պակաս երկարություն:\n\nՕրինակ:\n>>> min_operations_to_transform(\"apple\", \"aple\")\n1\n>>> min_operations_to_transform(\"kitten\", \"sitting\")\n3",
      "bn": "একটি স্ট্রিংকে অন্যটিতে রূপান্তর করতে প্রয়োজনীয় সর্বনিম্ন সংখ্যক চরিত্র অপারেশন গণনা করে। \nফাংশনটি দুটি স্ট্রিং আর্গুমেন্ট গ্রহণ করে, str_a এবং str_b। অনুমোদিত অপারেশনগুলি হল:\n1. একটি চরিত্র মুছে ফেলা;\n2. একটি চরিত্র সন্নিবেশ করা;\n3. একটি চরিত্রকে অন্যটির সাথে প্রতিস্থাপন করা।\nএটি একটি পূর্ণসংখ্যা প্রদান করে যা str_a কে str_b তে রূপান্তর করতে প্রয়োজনীয় সর্বনিম্ন অপারেশন সংখ্যা উপস্থাপন করে।\nউভয় স্ট্রিংয়ের দৈর্ঘ্য ২০০ এর কম হওয়া উচিত।\n\nউদাহরণ:\n>>> min_operations_to_transform(\"apple\", \"aple\")\n1\n>>> min_operations_to_transform(\"kitten\", \"sitting\")\n3",
      "bg": "Изчислява минималния брой операции с символи, необходими за трансформиране на един низ в друг. Функцията приема два аргумента от тип низ, str_a и str_b. Позволените операции са:\n1. Изтриване на символ;\n2. Вмъкване на символ;\n3. Замяна на символ с друг.\nВръща цяло число, представляващо минималния брой операции, необходими за трансформиране на str_a в str_b. И двата низа трябва да имат дължина по-малка от 200.\n\nПример:\n>>> min_operations_to_transform(\"apple\", \"aple\")\n1\n>>> min_operations_to_transform(\"kitten\", \"sitting\")\n3",
      "zh": "计算将一个字符串转换为另一个字符串所需的最小字符操作数。\n该函数接受两个字符串参数，str_a 和 str_b。允许的操作是：\n1. 删除一个字符；\n2. 插入一个字符；\n3. 用另一个字符替换一个字符。\n它返回一个整数，表示将 str_a 转换为 str_b 所需的最小操作数。\n两个字符串的长度应小于 200。\n\n示例：\n>>> min_operations_to_transform(\"apple\", \"aple\")\n1\n>>> min_operations_to_transform(\"kitten\", \"sitting\")\n3",
      "fr": "Calcule le nombre minimum d'opérations de caractères nécessaires pour transformer une chaîne en une autre.\nLa fonction prend deux arguments de type chaîne, str_a et str_b. Les opérations autorisées sont :\n1. Supprimer un caractère ;\n2. Insérer un caractère ;\n3. Remplacer un caractère par un autre.\nElle renvoie un entier représentant le nombre minimum d'opérations nécessaires pour transformer str_a en str_b.\nLes deux chaînes doivent avoir une longueur inférieure à 200.\n\nExemple :\n>>> min_operations_to_transform(\"apple\", \"aple\")\n1\n>>> min_operations_to_transform(\"kitten\", \"sitting\")\n3",
      "de": "Berechnet die minimale Anzahl von Zeichenoperationen, die erforderlich sind, um einen String in einen anderen zu transformieren.\nDie Funktion nimmt zwei String-Argumente, str_a und str_b. Die erlaubten Operationen sind:\n1. Ein Zeichen löschen;\n2. Ein Zeichen einfügen;\n3. Ein Zeichen durch ein anderes ersetzen.\nSie gibt eine ganze Zahl zurück, die die minimale Anzahl von Operationen darstellt, die erforderlich sind, um str_a in str_b zu transformieren.\nBeide Strings sollten eine Länge von weniger als 200 haben.\n\nBeispiel:\n>>> min_operations_to_transform(\"apple\", \"aple\")\n1\n>>> min_operations_to_transform(\"kitten\", \"sitting\")\n3",
      "ha": "Yana ƙididdige mafi ƙarancin adadin ayyukan haruffa da ake buƙata don sauya kirtani ɗaya zuwa wani.\nAikin yana ɗaukar hujjoji guda biyu na kirtani, str_a da str_b. Ayyukan da aka yarda su ne:\n1. Goge harafi;\n2. Saka harafi;\n3. Maye gurbin harafi da wani.\nYana mayar da lamba mai nuna mafi ƙarancin adadin ayyukan da ake buƙata don sauya str_a zuwa str_b.\nDuk kirtani ya kamata su kasance da tsawon ƙasa da 200.\n\nMisali:\n>>> min_operations_to_transform(\"apple\", \"aple\")\n1\n>>> min_operations_to_transform(\"kitten\", \"sitting\")\n3",
      "hi": "एक स्ट्रिंग को दूसरी स्ट्रिंग में बदलने के लिए आवश्यक न्यूनतम वर्ण संचालन की गणना करता है।\nयह फ़ंक्शन दो स्ट्रिंग तर्क लेता है, str_a और str_b। अनुमत ऑपरेशन्स हैं:  \n1. एक अक्षर हटाना;  \n2. एक अक्षर जोड़ना;  \n3. एक अक्षर को दूसरे के साथ बदलना।  \nयह एक पूर्णांक लौटाता है जो str_a को str_b में बदलने के लिए आवश्यक न्यूनतम ऑपरेशन्स की संख्या का प्रतिनिधित्व करता है।  \nदोनों स्ट्रिंग्स की लंबाई 200 से कम होनी चाहिए।  \n\nउदाहरण:  \n>>> min_operations_to_transform(\"apple\", \"aple\")  \n1  \n>>> min_operations_to_transform(\"kitten\", \"sitting\")  \n3  ",
      "hu": "Kiszámítja a minimális karakter műveletek számát, amelyek szükségesek ahhoz, hogy az egyik karakterláncot egy másikká alakítsuk.\nA függvény két karakterlánc argumentumot vesz fel, str_a és str_b. Az engedélyezett műveletek a következők:\n1. Egy karakter törlése;\n2. Egy karakter beszúrása;\n3. Egy karakter cseréje egy másikra.\nEgy egész számot ad vissza, amely a minimális műveletek számát jelenti, amelyek szükségesek ahhoz, hogy str_a-t str_b-vé alakítsuk.\nMindkét karakterlánc hossza kevesebb, mint 200.\n\nPélda:\n>>> min_operations_to_transform(\"apple\", \"aple\")\n1\n>>> min_operations_to_transform(\"kitten\", \"sitting\")\n3"
    },
    "docstring_bertscore": {
      "sq": "0.9905449952323583",
      "hy": "0.9827173691765354",
      "bn": "0.9740205365733039",
      "bg": "0.9676296040635063",
      "zh": "0.9730444668808984",
      "fr": "0.9816546966379988",
      "de": "0.9948854663187326",
      "ha": "0.9719676915853083",
      "hi": "0.9824869579345349",
      "hu": "0.963795839079152"
    }
  },
  {
    "task_id": "Ruby/24",
    "prompt": {
      "en": "# Reverses the order of words in a given sentence and reverses each word itself.\n# The function takes a single argument, 'sentence', which is a string. It returns \n# a new string with each word in the sentence reversed and the order of words also reversed.\n# Punctuation (spaces, commas, periods, exclamation marks, question marks) is used to identify words \n# and is removed in the returned string.\n#\n# Example:\n# >>> reverse_words_in_sentence(\"hello world!\")\n# \"dlrow olleh\"\n# >>> reverse_words_in_sentence(\"This is, a test.\")\n# \"tset a si sihT\"\n\ndef reverse_words_in_sentence(sentence)",
      "sq": "# Kthen renditjen e fjalëve në një fjali të dhënë dhe kthen secilën fjalë vetë.\n# Funksioni merr një argument të vetëm, 'sentence', i cili është një varg. Ai kthen\n# një varg të ri me secilën fjalë në fjali të kthyer dhe renditjen e fjalëve gjithashtu të kthyer.\n# Pikësimi (hapësirat, presjet, pikat, shenjat e pikëçuditjes, shenjat e pikëpyetjes) përdoret për të identifikuar fjalët\n# dhe hiqet në vargun e kthyer.\n#\n# Shembull:\n# >>> reverse_words_in_sentence(\"hello world!\")\n# \"dlrow olleh\"\n# >>> reverse_words_in_sentence(\"This is, a test.\")\n# \"tset a si sihT\"\n\ndef reverse_words_in_sentence(sentence)",
      "hy": "# Տրված նախադասության բառերի հերթականությունը շրջում է և շրջում է յուրաքանչյուր բառը։\n# Ֆունկցիան ընդունում է մեկ արգումենտ՝ 'sentence', որը տող է։ Այն վերադարձնում է\n# նոր տող, որտեղ նախադասության յուրաքանչյուր բառ շրջված է, և բառերի հերթականությունը նույնպես շրջված է։\n# Կետադրությունը (դատարկություններ, ստորակետեր, կետեր, բացականչական նշաններ, հարցական նշաններ) օգտագործվում է բառերը \n# նույնականացնելու համար և հեռացվում է վերադարձվող տողում։\n#\n# Օրինակ:\n# >>> reverse_words_in_sentence(\"hello world!\")\n# \"dlrow olleh\"\n# >>> reverse_words_in_sentence(\"This is, a test.\")\n# \"tset a si sihT\"\n\ndef reverse_words_in_sentence(sentence)",
      "bn": "# একটি প্রদত্ত বাক্যে শব্দগুলির ক্রম উল্টে দেয় এবং প্রতিটি শব্দ নিজেই উল্টে দেয়।\n# ফাংশনটি একটি একক আর্গুমেন্ট গ্রহণ করে, 'sentence', যা একটি স্ট্রিং। এটি একটি নতুন স্ট্রিং ফেরত দেয়\n# যেখানে বাক্যের প্রতিটি শব্দ উল্টানো হয় এবং শব্দগুলির ক্রমও উল্টানো হয়।\n# বিরামচিহ্ন (স্পেস, কমা, পিরিয়ড, বিস্ময়বোধক চিহ্ন, প্রশ্নবোধক চিহ্ন) শব্দগুলি সনাক্ত করতে ব্যবহৃত হয়\n# এবং ফেরত দেওয়া স্ট্রিংয়ে সরানো হয়।\n#\n# উদাহরণ:\n# >>> reverse_words_in_sentence(\"hello world!\")\n# \"dlrow olleh\"\n# >>> reverse_words_in_sentence(\"This is, a test.\")\n# \"tset a si sihT\"\n\ndef reverse_words_in_sentence(sentence)",
      "bg": "# Обръща реда на думите в дадено изречение и обръща всяка дума самостоятелно.\n# Функцията приема един аргумент, 'sentence', който е низ. Връща нов низ с всяка дума в изречението обърната и редът на думите също обърнат.\n# Пунктуацията (интервали, запетаи, точки, удивителни знаци, въпросителни знаци) се използва за идентифициране на думите и се премахва в върнатия низ.\n#\n# Пример:\n# >>> reverse_words_in_sentence(\"hello world!\")\n# \"dlrow olleh\"\n# >>> reverse_words_in_sentence(\"This is, a test.\")\n# \"tset a si sihT\"\n\ndef reverse_words_in_sentence(sentence)",
      "zh": "# 反转给定句子中单词的顺序，并且反转每个单词本身。\n# 该函数接受一个参数 'sentence'，它是一个字符串。它返回一个新的字符串，\n# 其中句子中的每个单词被反转，并且单词的顺序也被反转。\n# 标点符号（空格、逗号、句号、感叹号、问号）用于识别单词，并在返回的字符串中被移除。\n#\n# 示例:\n# >>> reverse_words_in_sentence(\"hello world!\")\n# \"dlrow olleh\"\n# >>> reverse_words_in_sentence(\"This is, a test.\")\n# \"tset a si sihT\"\n\ndef reverse_words_in_sentence(sentence)",
      "fr": "# Inverse l'ordre des mots dans une phrase donnée et inverse chaque mot lui-même.\n# La fonction prend un seul argument, 'sentence', qui est une chaîne de caractères. Elle retourne\n# une nouvelle chaîne avec chaque mot dans la phrase inversé et l'ordre des mots également inversé.\n# La ponctuation (espaces, virgules, points, points d'exclamation, points d'interrogation) est utilisée pour identifier les mots\n# et est supprimée dans la chaîne retournée.\n#\n# Exemple :\n# >>> reverse_words_in_sentence(\"hello world!\")\n# \"dlrow olleh\"\n# >>> reverse_words_in_sentence(\"This is, a test.\")\n# \"tset a si sihT\"\n\ndef reverse_words_in_sentence(sentence)",
      "de": "# Kehrt die Reihenfolge der Wörter in einem gegebenen Satz um und kehrt jedes Wort selbst um.\n# Die Funktion nimmt ein einzelnes Argument, 'sentence', das ein String ist. Sie gibt \n# einen neuen String zurück, bei dem jedes Wort im Satz umgekehrt ist und die Reihenfolge der Wörter ebenfalls umgekehrt ist.\n# Satzzeichen (Leerzeichen, Kommas, Punkte, Ausrufezeichen, Fragezeichen) werden verwendet, um Wörter zu identifizieren \n# und werden im zurückgegebenen String entfernt.\n#\n# Beispiel:\n# >>> reverse_words_in_sentence(\"hello world!\")\n# \"dlrow olleh\"\n# >>> reverse_words_in_sentence(\"This is, a test.\")\n# \"tset a si sihT\"\n\ndef reverse_words_in_sentence(sentence)",
      "ha": "# Juya tsarin kalmomi a cikin jumla da aka bayar kuma juya kowace kalma kanta.\n# Aikin yana karɓar hujja guda ɗaya, 'sentence', wanda yake igiya ce. Yana mayar \n# da sabon igiya tare da kowace kalma a cikin jumlar da aka juya kuma tsarin kalmomi ma an juya.\n# Alamomin rubutu (tazara, wakafi, maki, alamar mamaki, alamar tambaya) ana amfani da su don gano kalmomi \n# kuma ana cire su a cikin igiyar da aka mayar.\n#\n# Misali:\n# >>> reverse_words_in_sentence(\"hello world!\")\n# \"dlrow olleh\"\n# >>> reverse_words_in_sentence(\"This is, a test.\")\n# \"tset a si sihT\"\n\ndef reverse_words_in_sentence(sentence)",
      "hi": "# दिए गए वाक्य में शब्दों के क्रम को उलटता है और प्रत्येक शब्द को स्वयं उलटता है।\n# फ़ंक्शन एकल तर्क 'sentence' लेता है, जो एक स्ट्रिंग है। यह एक नई स्ट्रिंग लौटाता है \n# जिसमें वाक्य में प्रत्येक शब्द उलटा होता है और शब्दों का क्रम भी उलटा होता है।\n# विराम चिह्न (स्पेस, कॉमा, पीरियड, विस्मयादिबोधक चिह्न, प्रश्न चिह्न) का उपयोग शब्दों की पहचान के लिए किया जाता है \n# और लौटाई गई स्ट्रिंग में हटा दिया जाता है।\n#\n# उदाहरण:\n# >>> reverse_words_in_sentence(\"hello world!\")\n# \"dlrow olleh\"\n# >>> reverse_words_in_sentence(\"This is, a test.\")\n# \"tset a si sihT\"\n\ndef reverse_words_in_sentence(sentence)",
      "hu": "# Megfordítja a szavak sorrendjét egy adott mondatban, és magukat a szavakat is megfordítja.\n# A függvény egyetlen argumentumot vesz fel, 'sentence', amely egy string. Visszaad egy új stringet, \n# amelyben minden szó a mondatban meg van fordítva, és a szavak sorrendje is meg van fordítva.\n# A központozás (szóközök, vesszők, pontok, felkiáltójelek, kérdőjelek) a szavak azonosítására szolgál, \n# és el van távolítva a visszaadott stringből.\n#\n# Példa:\n# >>> reverse_words_in_sentence(\"hello world!\")\n# \"dlrow olleh\"\n# >>> reverse_words_in_sentence(\"This is, a test.\")\n# \"tset a si sihT\"\n\ndef reverse_words_in_sentence(sentence)"
    },
    "prompt_bertscore": {
      "sq": "0.9782900966136487",
      "hy": "0.9840825557853882",
      "bn": "0.9819695257919391",
      "bg": "0.9795581529661755",
      "zh": "0.9640427366427783",
      "fr": "0.9841798846720953",
      "de": "0.9771994171913863",
      "ha": "0.9823294440423743",
      "hi": "0.978131986830345",
      "hu": "0.9713894785461158"
    },
    "canonical_solution": "    # Removing punctuation and splitting the sentence into words\n    words = sentence.gsub(/[,.!?]/, '').split\n    # Reversing each word and then reversing the order of words\n    reversed_sentence = words.map(&:reverse).reverse.join(' ')\n    reversed_sentence\n  end",
    "instruction": {
      "en": "Write a ruby function `def reverse_words_in_sentence(sentence)` to solve the following problem:\nReverses the order of words in a given sentence and reverses each word itself.\nThe function takes a single argument, 'sentence', which is a string. It returns\na new string with each word in the sentence reversed and the order of words also reversed.\nPunctuation (spaces, commas, periods, exclamation marks, question marks) is used to identify words\nand is removed in the returned string.\n\nExample:\n>>> reverse_words_in_sentence(\"hello world!\")\n\"dlrow olleh\"\n>>> reverse_words_in_sentence(\"This is, a test.\")\n\"tset a si sihT\"",
      "sq": "Shkruani një funksion ruby `def reverse_words_in_sentence(sentence)` për të zgjidhur problemin e mëposhtëm:\nRikthen rendin e fjalëve në një fjali të dhënë dhe rikthen secilën fjalë vetë.\nFunksioni merr një argument të vetëm, 'sentence', i cili është një varg. Ai kthen\nnjë varg të ri me secilën fjalë në fjali të rikthyer dhe rendi i fjalëve gjithashtu i rikthyer.\nPikësimi (hapësira, presje, pika, shenja e pikëçuditjes, shenja e pikëpyetjes) përdoret për të identifikuar fjalët\ndhe hiqet në vargun e kthyer.\n\nShembull:\n>>> reverse_words_in_sentence(\"hello world!\")\n\"dlrow olleh\"\n>>> reverse_words_in_sentence(\"This is, a test.\")\n\"tset a si sihT\"",
      "hy": "Գրեք ruby ֆունկցիա `def reverse_words_in_sentence(sentence)` հետևյալ խնդիրը լուծելու համար:\nՓոխում է տրված նախադասության բառերի հերթականությունը և յուրաքանչյուր բառը ինքնին:\nՖունկցիան ընդունում է մեկ արգումենտ, 'sentence', որը տող է։ Այն վերադարձնում է\nնոր տող, որտեղ նախադասության յուրաքանչյուր բառը շրջված է, և բառերի հերթականությունը նույնպես շրջված է:\nԿետադրությունը (դատարկություններ, ստորակետներ, կետեր, բացականչական նշաններ, հարցական նշաններ) օգտագործվում է բառերը ճանաչելու համար\nև հեռացվում է վերադարձվող տողում:\n\nՕրինակ:\n>>> reverse_words_in_sentence(\"hello world!\")\n\"dlrow olleh\"\n>>> reverse_words_in_sentence(\"This is, a test.\")\n\"tset a si sihT\"",
      "bn": "রুবি ফাংশন `def reverse_words_in_sentence(sentence)` লিখুন নিম্নলিখিত সমস্যার সমাধানের জন্য:\nএকটি প্রদত্ত বাক্যে শব্দগুলির ক্রম উল্টানো এবং প্রতিটি শব্দ নিজেই উল্টানো।\nফাংশনটি একটি একক আর্গুমেন্ট গ্রহণ করে, 'sentence', যা একটি স্ট্রিং। এটি একটি নতুন স্ট্রিং রিটার্ন করে যেখানে বাক্যের প্রতিটি শব্দ উল্টানো হয় এবং শব্দগুলির ক্রমও উল্টানো হয়।\nবিরামচিহ্ন (স্পেস, কমা, পিরিয়ড, বিস্ময়সূচক চিহ্ন, প্রশ্নবোধক চিহ্ন) শব্দগুলি চিহ্নিত করতে ব্যবহৃত হয় এবং রিটার্ন করা স্ট্রিং-এ সরানো হয়।\n\nউদাহরণ:\n>>> reverse_words_in_sentence(\"hello world!\")\n\"dlrow olleh\"\n>>> reverse_words_in_sentence(\"This is, a test.\")\n\"tset a si sihT\"",
      "bg": "Напишете Ruby функция `def reverse_words_in_sentence(sentence)`, за да решите следния проблем:\nОбръща реда на думите в дадено изречение и обръща всяка дума самостоятелно.\nФункцията приема един аргумент, 'sentence', който е низ. Тя връща\nнов низ с всяка дума в изречението обърната и с обърнат ред на думите.\nПунктуацията (интервали, запетаи, точки, удивителни знаци, въпросителни знаци) се използва за идентифициране на думите\nи се премахва в върнатия низ.\n\nПример:\n>>> reverse_words_in_sentence(\"hello world!\")\n\"dlrow olleh\"\n>>> reverse_words_in_sentence(\"This is, a test.\")\n\"tset a si sihT\"",
      "zh": "编写一个 ruby 函数 `def reverse_words_in_sentence(sentence)` 来解决以下问题：\n反转给定句子中单词的顺序，并反转每个单词本身。\n该函数接受一个参数，'sentence'，它是一个字符串。它返回一个新的字符串，其中句子中的每个单词都被反转，单词的顺序也被反转。\n标点符号（空格、逗号、句号、感叹号、问号）用于识别单词，并在返回的字符串中被移除。\n\n示例：\n>>> reverse_words_in_sentence(\"hello world!\")\n\"dlrow olleh\"\n>>> reverse_words_in_sentence(\"This is, a test.\")\n\"tset a si sihT\"",
      "fr": "Écrire une fonction ruby `def reverse_words_in_sentence(sentence)` pour résoudre le problème suivant :\nInverse l'ordre des mots dans une phrase donnée et inverse chaque mot lui-même.\nLa fonction prend un seul argument, 'sentence', qui est une chaîne de caractères. Elle retourne\nune nouvelle chaîne avec chaque mot dans la phrase inversé et l'ordre des mots également inversé.\nLa ponctuation (espaces, virgules, points, points d'exclamation, points d'interrogation) est utilisée pour identifier les mots\net est supprimée dans la chaîne retournée.\n\nExemple :\n>>> reverse_words_in_sentence(\"hello world!\")\n\"dlrow olleh\"\n>>> reverse_words_in_sentence(\"This is, a test.\")\n\"tset a si sihT\"",
      "de": "Schreiben Sie eine Ruby-Funktion `def reverse_words_in_sentence(sentence)`, um das folgende Problem zu lösen:\nKehrt die Reihenfolge der Wörter in einem gegebenen Satz um und kehrt jedes Wort selbst um.\nDie Funktion nimmt ein einziges Argument, 'sentence', das ein String ist. Sie gibt\neinen neuen String zurück, bei dem jedes Wort im Satz umgekehrt ist und die Reihenfolge der Wörter ebenfalls umgekehrt ist.\nInterpunktion (Leerzeichen, Kommas, Punkte, Ausrufezeichen, Fragezeichen) wird verwendet, um Wörter zu identifizieren\nund wird im zurückgegebenen String entfernt.\n\nBeispiel:\n>>> reverse_words_in_sentence(\"hello world!\")\n\"dlrow olleh\"\n>>> reverse_words_in_sentence(\"This is, a test.\")\n\"tset a si sihT\"",
      "ha": "Rubuta aikin ruby `def reverse_words_in_sentence(sentence)` don warware matsalar mai zuwa:\nJuyar da tsarin kalmomi a cikin jimla da kuma juyar da kowace kalma kanta.\nAikin yana ɗaukar hujja guda, 'sentence', wanda yake igiya ce. Yana dawowa\nsabuwar igiya tare da kowace kalma a cikin jimla an juyar da ita kuma tsarin kalmomi ma an juyar da shi.\nAlamomin rubutu (tazara, wakafi, maki, alamun mamaki, tambayoyi) ana amfani da su don gano kalmomi\nkuma ana cire su a cikin igiyar da aka dawo da ita.\n\nMisali:\n>>> reverse_words_in_sentence(\"hello world!\")\n\"dlrow olleh\"\n>>> reverse_words_in_sentence(\"This is, a test.\")\n\"tset a si sihT\"",
      "hi": "रूबी फ़ंक्शन `def reverse_words_in_sentence(sentence)` लिखें ताकि निम्नलिखित समस्या का समाधान हो सके:\nदिए गए वाक्य में शब्दों के क्रम को उलटता है और प्रत्येक शब्द को स्वयं भी उलटता है।\nयह फ़ंक्शन एकल तर्क, 'sentence', लेता है, जो एक स्ट्रिंग है। यह एक नई स्ट्रिंग लौटाता है जिसमें वाक्य के प्रत्येक शब्द को उलटा किया गया है और शब्दों का क्रम भी उलटा किया गया है।\nविराम चिह्न (स्पेस, कॉमा, पीरियड, विस्मयादिबोधक चिह्न, प्रश्न चिह्न) का उपयोग शब्दों की पहचान के लिए किया जाता है और लौटाई गई स्ट्रिंग में हटा दिया जाता है।\n\nउदाहरण:\n>>> reverse_words_in_sentence(\"hello world!\")\n\"dlrow olleh\"\n>>> reverse_words_in_sentence(\"This is, a test.\")\n\"tset a si sihT\"",
      "hu": "Írj egy ruby függvényt `def reverse_words_in_sentence(sentence)` a következő probléma megoldására:\nMegfordítja a szavak sorrendjét egy adott mondatban, és megfordítja magukat a szavakat is.\nA függvény egyetlen argumentumot vesz, 'sentence', amely egy string. Visszaad\negy új stringet, amelyben minden szó a mondatban meg van fordítva, és a szavak sorrendje is meg van fordítva.\nA központozás (szóközök, vesszők, pontok, felkiáltójelek, kérdőjelek) a szavak azonosítására szolgál\nés el van távolítva a visszaadott stringben.\n\nPélda:\n>>> reverse_words_in_sentence(\"hello world!\")\n\"dlrow olleh\"\n>>> reverse_words_in_sentence(\"This is, a test.\")\n\"tset a si sihT\""
    },
    "instruction_bertscore": {
      "sq": "0.999999801369619",
      "hy": "0.9773904996179418",
      "bn": "0.9842966793361438",
      "bg": "0.9844045356330458",
      "zh": "0.9770492526233239",
      "fr": "0.9843137615489128",
      "de": "0.9839999255468777",
      "ha": "0.9790681318161625",
      "hi": "0.9626469609552462",
      "hu": "0.975479079461243"
    },
    "level": "middle",
    "test": "raise 'Test failed' unless reverse_words_in_sentence(\"hello world!\") == \"dlrow olleh\"\nraise 'Test failed' unless reverse_words_in_sentence(\"This is, a test.\") == \"tset a si sihT\"\nraise 'Test failed' unless reverse_words_in_sentence(\"Ruby, programming!\") == \"gnimmargorp ybuR\"\nraise 'Test failed' unless reverse_words_in_sentence(\"Keep calm and code on.\") == \"no edoc dna mlac peeK\"\nraise 'Test failed' unless reverse_words_in_sentence(\"Simple sentence.\") == \"ecnetnes elpmiS\"\n\n\n\nputs 'All tests passed!'",
    "entry_point": "reverse_words_in_sentence",
    "signature": "def reverse_words_in_sentence(sentence)",
    "docstring": {
      "en": "Reverses the order of words in a given sentence and reverses each word itself.\nThe function takes a single argument, 'sentence', which is a string. It returns\na new string with each word in the sentence reversed and the order of words also reversed.\nPunctuation (spaces, commas, periods, exclamation marks, question marks) is used to identify words\nand is removed in the returned string.\n\nExample:\n>>> reverse_words_in_sentence(\"hello world!\")\n\"dlrow olleh\"\n>>> reverse_words_in_sentence(\"This is, a test.\")\n\"tset a si sihT\"",
      "sq": "Kthen renditjen e fjalëve në një fjali të dhënë dhe kthen secilën fjalë vetë.\nFunksioni merr një argument të vetëm, 'sentence', i cili është një varg. Ai kthen\nnjë varg të ri me secilën fjalë në fjali të kthyer dhe renditjen e fjalëve gjithashtu të kthyer.\nPikësimi (hapësirat, presjet, pikat, shenjat e pikëçuditjes, shenjat e pikëpyetjes) përdoret për të identifikuar fjalët\ndhe hiqet në vargun e kthyer.\n\nShembull:\n>>> reverse_words_in_sentence(\"hello world!\")\n\"dlrow olleh\"\n>>> reverse_words_in_sentence(\"This is, a test.\")\n\"tset a si sihT\"",
      "hy": "Փոխում է տրված նախադասության բառերի հերթականությունը և փոխում է յուրաքանչյուր բառը:\nՖունկցիան ընդունում է մեկ արգումենտ, 'sentence', որը տող է։ Այն վերադարձնում է\nնոր տող, որտեղ նախադասության յուրաքանչյուր բառը փոխված է, և բառերի հերթականությունը նույնպես փոխված է:\nԿետադրությունը (բացատներ, ստորակետներ, կետեր, բացականչական նշաններ, հարցական նշաններ) օգտագործվում է բառերը որոշելու համար\nև հեռացվում է վերադարձվող տողում։\n\nՕրինակ:\n>>> reverse_words_in_sentence(\"hello world!\")\n\"dlrow olleh\"\n>>> reverse_words_in_sentence(\"This is, a test.\")\n\"tset a si sihT\"",
      "bn": "প্রদত্ত বাক্যে শব্দগুলির ক্রম উল্টে দেয় এবং প্রতিটি শব্দ নিজেই উল্টে দেয়।\nফাংশনটি একটি একক আর্গুমেন্ট, 'sentence', গ্রহণ করে, যা একটি স্ট্রিং। এটি একটি নতুন স্ট্রিং ফেরত দেয় যেখানে বাক্যের প্রতিটি শব্দ উল্টানো হয় এবং শব্দগুলির ক্রমও উল্টানো হয়। \nবিরামচিহ্ন (স্পেস, কমা, পিরিয়ড, বিস্ময়সূচক চিহ্ন, প্রশ্নবোধক চিহ্ন) শব্দগুলি চিহ্নিত করতে ব্যবহৃত হয় এবং ফেরত দেওয়া স্ট্রিং-এ সরানো হয়।\n\nউদাহরণ:\n>>> reverse_words_in_sentence(\"hello world!\")\n\"dlrow olleh\"\n>>> reverse_words_in_sentence(\"This is, a test.\")\n\"tset a si sihT\"",
      "bg": "Обръща реда на думите в дадено изречение и обръща всяка дума сама по себе си.\nФункцията приема един аргумент, 'sentence', който е низ. Връща нов низ с всяка дума в изречението обърната и редът на думите също обърнат. \nПунктуацията (интервали, запетаи, точки, удивителни знаци, въпросителни знаци) се използва за идентифициране на думите и се премахва в върнатия низ.\n\nПример:\n>>> reverse_words_in_sentence(\"hello world!\")\n\"dlrow olleh\"\n>>> reverse_words_in_sentence(\"This is, a test.\")\n\"tset a si sihT\"",
      "zh": "将给定句子中的单词顺序颠倒，并且每个单词本身也颠倒。\n该函数接受一个参数，'sentence'，它是一个字符串。它返回一个新的字符串，其中句子中的每个单词都被颠倒，单词的顺序也被颠倒。\n标点符号（空格、逗号、句号、感叹号、问号）用于识别单词，并在返回的字符串中被移除。\n\n示例：\n>>> reverse_words_in_sentence(\"hello world!\")\n\"dlrow olleh\"\n>>> reverse_words_in_sentence(\"This is, a test.\")\n\"tset a si sihT\"",
      "fr": "Inverse l'ordre des mots dans une phrase donnée et inverse chaque mot lui-même.\nLa fonction prend un seul argument, 'sentence', qui est une chaîne de caractères. Elle renvoie  \nune nouvelle chaîne avec chaque mot de la phrase inversé et l'ordre des mots également inversé.  \nLa ponctuation (espaces, virgules, points, points d'exclamation, points d'interrogation) est utilisée pour identifier les mots  \net est supprimée dans la chaîne renvoyée.  \n\nExemple :  \n>>> reverse_words_in_sentence(\"hello world!\")  \n\"dlrow olleh\"  \n>>> reverse_words_in_sentence(\"This is, a test.\")  \n\"tset a si sihT\"",
      "de": "Kehrt die Reihenfolge der Wörter in einem gegebenen Satz um und kehrt jedes Wort selbst um.\nDie Funktion nimmt ein einzelnes Argument, 'sentence', das ein String ist. Sie gibt\neinen neuen String zurück, bei dem jedes Wort im Satz umgekehrt ist und die Reihenfolge der Wörter ebenfalls umgekehrt ist.\nInterpunktion (Leerzeichen, Kommas, Punkte, Ausrufezeichen, Fragezeichen) wird verwendet, um Wörter zu identifizieren\nund wird im zurückgegebenen String entfernt.\n\nBeispiel:\n>>> reverse_words_in_sentence(\"hello world!\")\n\"dlrow olleh\"\n>>> reverse_words_in_sentence(\"This is, a test.\")\n\"tset a si sihT\"",
      "ha": "Juya tsarin kalmomi a cikin jumla da aka bayar kuma juya kowace kalma kanta.\nAikin yana ɗaukar hujja guda, 'sentence', wanda yake a matsayin kirtani. Yana dawowa\nda sabon kirtani tare da kowanne kalma a cikin jimla an juyar da ita kuma an juyar da tsarin kalmomin.\nAlamomin rubutu (tazara, wakafi, maki, alamun mamaki, tambayoyi) ana amfani da su don gano kalmomi\nkuma an cire su a cikin sabon kirtani da aka dawo dashi.\n\nMisali:\n>>> reverse_words_in_sentence(\"hello world!\")\n\"dlrow olleh\"\n>>> reverse_words_in_sentence(\"This is, a test.\")\n\"tset a si sihT\"",
      "hi": "शब्दों के क्रम को उलटता है और दिए गए वाक्य में प्रत्येक शब्द को भी उलटता है।\nयह फ़ंक्शन एकल तर्क 'sentence' लेता है, जो एक स्ट्रिंग है। यह एक नई स्ट्रिंग लौटाता है जिसमें वाक्य के प्रत्येक शब्द को उलटा किया गया है और शब्दों का क्रम भी उलटा किया गया है। \nविराम चिह्न (स्पेस, कॉमा, पीरियड, विस्मयादिबोधक चिह्न, प्रश्न चिह्न) का उपयोग शब्दों की पहचान के लिए किया जाता है और लौटाई गई स्ट्रिंग में हटा दिया जाता है।\n\nउदाहरण:\n>>> reverse_words_in_sentence(\"hello world!\")\n\"dlrow olleh\"\n>>> reverse_words_in_sentence(\"This is, a test.\")\n\"tset a si sihT\"",
      "hu": "Megfordítja a szavak sorrendjét egy adott mondatban, és magukat a szavakat is megfordítja.\nA függvény egyetlen argumentumot vesz fel, a 'sentence' nevűt, amely egy karakterlánc. Visszaad\negy új karakterláncot, amelyben minden szó a mondatban meg van fordítva, és a szavak sorrendje is meg van fordítva.\nA központozás (szóközök, vesszők, pontok, felkiáltójelek, kérdőjelek) a szavak azonosítására szolgál\nés el van távolítva a visszaadott karakterláncban.\n\nPélda:\n>>> reverse_words_in_sentence(\"hello world!\")\n\"dlrow olleh\"\n>>> reverse_words_in_sentence(\"This is, a test.\")\n\"tset a si sihT\""
    },
    "docstring_bertscore": {
      "sq": "0.9917856405923022",
      "hy": "0.9646988127913365",
      "bn": "0.9621309192253176",
      "bg": "0.9862057159282701",
      "zh": "0.9611810687432087",
      "fr": "0.9825179442739764",
      "de": "0.9819939573288063",
      "ha": "0.9799454822091935",
      "hi": "0.9600357659661616",
      "hu": "0.970012970005544"
    }
  },
  {
    "task_id": "Ruby/25",
    "prompt": {
      "en": "# Calculates the number of unique permutations of a given string.\n# The function takes a single argument, str, which is a string consisting of\n# lowercase letters. It returns the total number of unique permutations that\n# can be formed with the characters in str.\n#\n# Example:\n# >>> unique_permutations_count(\"aacc\")\n# 6\n# >>> unique_permutations_count(\"abc\")\n# 6\n\ndef unique_permutations_count(str)",
      "sq": "# Llogarit numrin e permutacioneve unike të një vargu të dhënë.\n# Funksioni merr një argument të vetëm, str, i cili është një varg që përbëhet nga\n# shkronja të vogla. Ai kthen numrin total të permutacioneve unike që\n# mund të formohen me karakteret në str.\n#\n# Shembull:\n# >>> unique_permutations_count(\"aacc\")\n# 6\n# >>> unique_permutations_count(\"abc\")\n# 6\n\ndef unique_permutations_count(str)",
      "hy": "# Հաշվում է տրված տողի եզակի փոխատեղումների քանակը։\n# Ֆունկցիան ընդունում է մեկ արգումենտ, str, որը փոքրատառ տառերից կազմված\n# տող է։ Այն վերադարձնում է եզակի փոխատեղումների ընդհանուր քանակը, որը\n# կարող է կազմվել str-ի սիմվոլներով։\n#\n# Օրինակ:\n# >>> unique_permutations_count(\"aacc\")\n# 6\n# >>> unique_permutations_count(\"abc\")\n# 6\n\ndef unique_permutations_count(str)",
      "bn": "# একটি প্রদত্ত স্ট্রিংয়ের অনন্য বিন্যাসের সংখ্যা গণনা করে।\n# ফাংশনটি একটি একক আর্গুমেন্ট গ্রহণ করে, str, যা ছোট হাতের অক্ষর নিয়ে গঠিত একটি স্ট্রিং।\n# এটি মোট অনন্য বিন্যাসের সংখ্যা ফেরত দেয় যা str এর অক্ষর দিয়ে গঠন করা যেতে পারে।\n#\n# উদাহরণ:\n# >>> unique_permutations_count(\"aacc\")\n# 6\n# >>> unique_permutations_count(\"abc\")\n# 6\n\ndef unique_permutations_count(str)",
      "bg": "# Изчислява броя на уникалните пермутации на даден низ.\n# Функцията приема един аргумент, str, който е низ, състоящ се от\n# малки букви. Тя връща общия брой уникални пермутации, които\n# могат да бъдат образувани с буквите в str.\n#\n# Пример:\n# >>> unique_permutations_count(\"aacc\")\n# 6\n# >>> unique_permutations_count(\"abc\")\n# 6\n\ndef unique_permutations_count(str)",
      "zh": "# 计算给定字符串的唯一排列数。\n# 该函数接受一个参数，str，这是一个由小写字母组成的字符串。\n# 它返回可以用 str 中的字符形成的唯一排列的总数。\n#\n# 示例:\n# >>> unique_permutations_count(\"aacc\")\n# 6\n# >>> unique_permutations_count(\"abc\")\n# 6\n\ndef unique_permutations_count(str)",
      "fr": "# Calcule le nombre de permutations uniques d'une chaîne donnée.\n# La fonction prend un seul argument, str, qui est une chaîne composée de\n# lettres minuscules. Elle renvoie le nombre total de permutations uniques qui\n# peuvent être formées avec les caractères de str.\n#\n# Exemple :\n# >>> unique_permutations_count(\"aacc\")\n# 6\n# >>> unique_permutations_count(\"abc\")\n# 6\n\ndef unique_permutations_count(str)",
      "de": "# Berechnet die Anzahl der einzigartigen Permutationen eines gegebenen Strings.\n# Die Funktion nimmt ein einzelnes Argument, str, das ein String bestehend aus\n# Kleinbuchstaben ist. Sie gibt die Gesamtanzahl der einzigartigen Permutationen zurück, die\n# mit den Zeichen in str gebildet werden können.\n#\n# Beispiel:\n# >>> unique_permutations_count(\"aacc\")\n# 6\n# >>> unique_permutations_count(\"abc\")\n# 6\n\ndef unique_permutations_count(str)",
      "ha": "# Lissafa adadin permutations na musamman na wani igiyar kirtani.\n# Aikin yana ɗaukar hujja guda, str, wanda shine igiyar kirtani da ke ƙunshe da\n# haruffa ƙananan. Yana dawo da jimillar adadin permutations na musamman da za a iya\n# samarwa tare da haruffan cikin str.\n#\n# Misali:\n# >>> unique_permutations_count(\"aacc\")\n# 6\n# >>> unique_permutations_count(\"abc\")\n# 6\n\ndef unique_permutations_count(str)",
      "hi": "# दिए गए स्ट्रिंग के अद्वितीय क्रमपरिवर्तन की संख्या की गणना करता है।\n# फ़ंक्शन एकल तर्क लेता है, str, जो छोटे अक्षरों से बना एक स्ट्रिंग है।\n# यह कुल अद्वितीय क्रमपरिवर्तन की संख्या लौटाता है जो str में वर्णों के साथ\n# बनाए जा सकते हैं।\n#\n# उदाहरण:\n# >>> unique_permutations_count(\"aacc\")\n# 6\n# >>> unique_permutations_count(\"abc\")\n# 6\n\ndef unique_permutations_count(str)",
      "hu": "# Kiszámítja egy adott string egyedi permutációinak számát.\n# A függvény egyetlen argumentumot vesz fel, str, amely egy kisbetűkből álló string.\n# Visszaadja az összes egyedi permutáció számát, amely a str karaktereiből képezhető.\n#\n# Példa:\n# >>> unique_permutations_count(\"aacc\")\n# 6\n# >>> unique_permutations_count(\"abc\")\n# 6\n\ndef unique_permutations_count(str)"
    },
    "prompt_bertscore": {
      "sq": "0.9991266222145896",
      "hy": "0.9694901748426601",
      "bn": "0.9801941674462492",
      "bg": "0.9906157076480067",
      "zh": "0.9769513278454737",
      "fr": "0.9941328558049914",
      "de": "1",
      "ha": "0.964724237480109",
      "hi": "0.9877963480195975",
      "hu": "0.9615078157200111"
    },
    "canonical_solution": "    return 1 if str.empty?\n  \n    # Count frequency of each character\n    freq = Hash.new(0)\n    str.each_char { |char| freq[char] += 1 }\n  \n    # Calculate the factorial of the length of the string\n    total_permutations = (1..str.length).inject(:*)\n  \n    # Divide by the factorial of the frequency of each character\n    freq.each_value do |value|\n      total_permutations /= (1..value).inject(:*)\n    end\n  \n    total_permutations\n  end",
    "instruction": {
      "en": "Write a ruby function `def unique_permutations_count(str)` to solve the following problem:\nCalculates the number of unique permutations of a given string.\nThe function takes a single argument, str, which is a string consisting of\nlowercase letters. It returns the total number of unique permutations that\ncan be formed with the characters in str.\n\nExample:\n>>> unique_permutations_count(\"aacc\")\n6\n>>> unique_permutations_count(\"abc\")\n6",
      "sq": "Shkruani një funksion ruby `def unique_permutations_count(str)` për të zgjidhur problemin e mëposhtëm:\nLlogarit numrin e permutacioneve unike të një vargu të dhënë.\nFunksioni merr një argument të vetëm, str, i cili është një varg që përbëhet nga\nshkronja të vogla. Ai kthen numrin total të permutacioneve unike që\nmund të formohen me karakteret në str.\n\nShembull:\n>>> unique_permutations_count(\"aacc\")\n6\n>>> unique_permutations_count(\"abc\")\n6",
      "hy": "Գրեք ruby ֆունկցիա `def unique_permutations_count(str)` հետևյալ խնդիրը լուծելու համար:\nՀաշվում է տրված տողի եզակի փոխատեղումների քանակը:\nՖունկցիան ընդունում է մեկ արգումենտ, str, որը բաղկացած է փոքրատառ տառերից: Այն վերադարձնում է եզակի փոխատեղումների ընդհանուր քանակը, որը կարող է կազմվել str-ի սիմվոլներով:\n\nՕրինակ:\n>>> unique_permutations_count(\"aacc\")\n6\n>>> unique_permutations_count(\"abc\")\n6",
      "bn": "রুবি ফাংশন `def unique_permutations_count(str)` লিখুন নিম্নলিখিত সমস্যার সমাধানের জন্য:\nএকটি প্রদত্ত স্ট্রিংয়ের অনন্য পারমুটেশনের সংখ্যা গণনা করে।\nফাংশনটি একটি একক আর্গুমেন্ট গ্রহণ করে, str, যা ছোট হাতের অক্ষর নিয়ে গঠিত একটি স্ট্রিং। এটি মোট অনন্য পারমুটেশনের সংখ্যা ফেরত দেয় যা str-এর অক্ষরগুলির সাথে গঠন করা যেতে পারে।\n\nউদাহরণ:\n>>> unique_permutations_count(\"aacc\")\n6\n>>> unique_permutations_count(\"abc\")\n6",
      "bg": "Напишете функция на Ruby `def unique_permutations_count(str)` за решаване на следния проблем:\nИзчислява броя на уникалните пермутации на даден низ.\nФункцията приема един аргумент, str, който е низ, състоящ се от\nмалки букви. Тя връща общия брой уникални пермутации, които\nмогат да бъдат образувани с буквите в str.\n\nПример:\n>>> unique_permutations_count(\"aacc\")\n6\n>>> unique_permutations_count(\"abc\")\n6",
      "zh": "编写一个 ruby 函数 `def unique_permutations_count(str)` 来解决以下问题：\n计算给定字符串的唯一排列数。\n该函数接受一个参数，str，这是一个由小写字母组成的字符串。它返回可以用 str 中的字符形成的唯一排列的总数。\n\n示例：\n>>> unique_permutations_count(\"aacc\")\n6\n>>> unique_permutations_count(\"abc\")\n6",
      "fr": "Écrire une fonction ruby `def unique_permutations_count(str)` pour résoudre le problème suivant :  \nCalcule le nombre de permutations uniques d'une chaîne de caractères donnée.  \nLa fonction prend un seul argument, str, qui est une chaîne de caractères composée de lettres minuscules. Elle renvoie le nombre total de permutations uniques qui peuvent être formées avec les caractères de str.\n\nExemple :  \n>>> unique_permutations_count(\"aacc\")  \n6  \n>>> unique_permutations_count(\"abc\")  \n6",
      "de": "Schreiben Sie eine Ruby-Funktion `def unique_permutations_count(str)`, um das folgende Problem zu lösen:\nBerechnet die Anzahl der einzigartigen Permutationen eines gegebenen Strings.\nDie Funktion nimmt ein einziges Argument, str, das ein String aus Kleinbuchstaben ist. Sie gibt die Gesamtanzahl der einzigartigen Permutationen zurück, die mit den Zeichen in str gebildet werden können.\n\nBeispiel:\n>>> unique_permutations_count(\"aacc\")\n6\n>>> unique_permutations_count(\"abc\")\n6",
      "ha": "Rubuta wani aikin ruby `def unique_permutations_count(str)` don warware matsalar mai zuwa:  \nYana lissafa adadin permutations na musamman na wani kirtani da aka bayar.  \nAikin yana ɗaukar hujja guda, str, wanda kirtani ne da ya ƙunshi haruffa ƙanana. Yana dawowa da jimlar adadin permutations na musamman da za a iya samarwa tare da haruffan da ke cikin str.  \n\nMisali:  \n>>> unique_permutations_count(\"aacc\")  \n6  \n>>> unique_permutations_count(\"abc\")  \n6  ",
      "hi": "`def unique_permutations_count(str)` नामक एक रूबी फ़ंक्शन लिखें ताकि निम्नलिखित समस्या का समाधान किया जा सके:\nदिए गए स्ट्रिंग के अद्वितीय क्रमचयों की संख्या की गणना करता है।\nयह फ़ंक्शन एक एकल तर्क लेता है, str, जो कि छोटे अक्षरों से बना एक स्ट्रिंग है। यह उन कुल अद्वितीय क्रमचयों की संख्या लौटाता है जो str में वर्णों के साथ बनाए जा सकते हैं।\n\nउदाहरण:\n>>> unique_permutations_count(\"aacc\")\n6\n>>> unique_permutations_count(\"abc\")\n6",
      "hu": "Írj egy ruby függvényt `def unique_permutations_count(str)` a következő probléma megoldására:\nKiszámítja egy adott string egyedi permutációinak számát.\nA függvény egyetlen argumentumot vesz fel, str, amely egy kisbetűkből álló string. Visszaadja az összes egyedi permutáció számát, amely a str karaktereiből képezhető.\n\nPélda:\n>>> unique_permutations_count(\"aacc\")\n6\n>>> unique_permutations_count(\"abc\")\n6"
    },
    "instruction_bertscore": {
      "sq": "0.998041504442996",
      "hy": "0.9667657605363856",
      "bn": "0.9829861160820756",
      "bg": "0.9856938454363432",
      "zh": "0.9854828999716841",
      "fr": "0.9931468545935342",
      "de": "0.9922315657977255",
      "ha": "0.9859236607872006",
      "hi": "0.972278548131628",
      "hu": "0.9942631573349504"
    },
    "level": "hard",
    "test": "raise 'Test failed' unless unique_permutations_count(\"aacc\") == 6\nraise 'Test failed' unless unique_permutations_count(\"abc\") == 6\nraise 'Test failed' unless unique_permutations_count(\"abcd\") == 24\nraise 'Test failed' unless unique_permutations_count(\"aaa\") == 1\nraise 'Test failed' unless unique_permutations_count(\"ab\") == 2\nraise 'Test failed' unless unique_permutations_count(\"aacdarwqea\") == 151200\n\n  \n\nputs 'All tests passed!'",
    "entry_point": "unique_permutations_count",
    "signature": "def unique_permutations_count(str)",
    "docstring": {
      "en": "Calculates the number of unique permutations of a given string.\nThe function takes a single argument, str, which is a string consisting of\nlowercase letters. It returns the total number of unique permutations that\ncan be formed with the characters in str.\n\nExample:\n>>> unique_permutations_count(\"aacc\")\n6\n>>> unique_permutations_count(\"abc\")\n6",
      "sq": "Llogarit numrin e permutacioneve unike të një vargu të dhënë. Funksioni merr një argument të vetëm, str, i cili është një varg që përbëhet nga shkronja të vogla. Ai kthen numrin total të permutacioneve unike që mund të formohen me karakteret në str.\n\nShembull:\n>>> unique_permutations_count(\"aacc\")\n6\n>>> unique_permutations_count(\"abc\")\n6",
      "hy": "Հաշվում է տրված տողի եզակի փոխատեղումների քանակը։\nՖունկցիան ընդունում է մեկ արգումենտ, str, որը փոքրատառերով բաղկացած տող է։ Այն վերադարձնում է եզակի փոխատեղումների ընդհանուր քանակը, որոնք կարող են կազմվել str-ի սիմվոլներով։\n\nՕրինակ:\n>>> unique_permutations_count(\"aacc\")\n6\n>>> unique_permutations_count(\"abc\")\n6",
      "bn": "একটি প্রদত্ত স্ট্রিংয়ের অনন্য বিন্যাসের সংখ্যা গণনা করে। ফাংশনটি একটি একক আর্গুমেন্ট গ্রহণ করে, str, যা ছোট হাতের অক্ষর সমন্বিত একটি স্ট্রিং। এটি str-এর অক্ষরগুলির সাথে গঠিত হতে পারে এমন অনন্য বিন্যাসের মোট সংখ্যা ফেরত দেয়।\n\nউদাহরণ:\n>>> unique_permutations_count(\"aacc\")\n6\n>>> unique_permutations_count(\"abc\")\n6",
      "bg": "Изчислява броя на уникалните пермутации на даден низ.  \nФункцията приема един аргумент, str, който е низ, състоящ се от малки букви. Връща общия брой уникални пермутации, които могат да бъдат образувани с буквите в str.\n\nПример:\n>>> unique_permutations_count(\"aacc\")\n6\n>>> unique_permutations_count(\"abc\")\n6",
      "zh": "计算给定字符串的唯一排列数量。\n该函数接受一个参数，str，这是一个由小写字母组成的字符串。它返回可以用 str 中的字符形成的唯一排列的总数。\n\n示例：\n>>> unique_permutations_count(\"aacc\")\n6\n>>> unique_permutations_count(\"abc\")\n6",
      "fr": "Calcule le nombre de permutations uniques d'une chaîne donnée.  \nLa fonction prend un seul argument, str, qui est une chaîne composée de lettres minuscules. Elle renvoie le nombre total de permutations uniques qui peuvent être formées avec les caractères de str.\n\nExemple :\n>>> unique_permutations_count(\"aacc\")\n6\n>>> unique_permutations_count(\"abc\")\n6",
      "de": "Berechnet die Anzahl der eindeutigen Permutationen eines gegebenen Strings. Die Funktion nimmt ein einzelnes Argument, str, das ein String bestehend aus Kleinbuchstaben ist. Sie gibt die Gesamtzahl der eindeutigen Permutationen zurück, die mit den Zeichen in str gebildet werden können.\n\nBeispiel:\n>>> unique_permutations_count(\"aacc\")\n6\n>>> unique_permutations_count(\"abc\")\n6",
      "ha": "Yana lissafin adadin permutations na musamman na kirtani da aka bayar. \n\nAikin yana daukar hujja guda, str, wanda kirtani ne da ya kunshi \nharuffa kanana. Yana mayar da jimlar adadin permutations na musamman da za a iya samarwa tare da haruffan da ke cikin str.\n\nMisali:\n>>> unique_permutations_count(\"aacc\")\n6\n>>> unique_permutations_count(\"abc\")\n6",
      "hi": "दिए गए स्ट्रिंग के अद्वितीय क्रमचयों की संख्या की गणना करता है। \nयह फ़ंक्शन एकल तर्क str लेता है, जो छोटे अक्षरों से बना एक स्ट्रिंग है। यह उन अद्वितीय क्रमचयों की कुल संख्या लौटाता है जो str के वर्णों के साथ बनाई जा सकती हैं।\n\nउदाहरण:\n>>> unique_permutations_count(\"aacc\")\n6\n>>> unique_permutations_count(\"abc\")\n6",
      "hu": "Kiszámítja egy adott karakterlánc egyedi permutációinak számát.  \nA függvény egyetlen argumentumot vesz fel, str, amely egy kisbetűkből álló karakterlánc.  \nVisszaadja az összes egyedi permutáció számát, amely a str karaktereivel képezhető.\n\nPélda:\n>>> unique_permutations_count(\"aacc\")\n6\n>>> unique_permutations_count(\"abc\")\n6"
    },
    "docstring_bertscore": {
      "sq": "0.9949015553795965",
      "hy": "0.9848697279854295",
      "bn": "0.9953441038685422",
      "bg": "0.9826019649251542",
      "zh": "0.975928778643906",
      "fr": "0.9902899538231095",
      "de": "0.999999801369619",
      "ha": "0.9894660350025768",
      "hi": "0.982732067824732",
      "hu": "0.9781965417041814"
    }
  },
  {
    "task_id": "Ruby/26",
    "prompt": {
      "en": "# Finds the longest palindrome within a given string.\n# The function takes a single argument, str, which is a string that may include letters, numbers, and symbols.\n# It returns the length of the longest palindrome that can be found within the string.\n# Palindromes are sequences that read the same backward as forward.\n# Note: The function is case-sensitive and considers each character.\n#\n# Example:\n# >>> find_longest_palindrome(\"ABBA\")\n# 4\n# >>> find_longest_palindrome(\"12ABBA\")\n# 4\n# >>> find_longest_palindrome(\"A\")\n# 1\n# >>> find_longest_palindrome(\"ABAKK\")\n# 3\n# >>> find_longest_palindrome(\"51233214\")\n# 6\n# >>> find_longest_palindrome(\"abaaab\")\n# 5\n\n\ndef find_longest_palindrome(str)",
      "sq": "# Gjen palindromën më të gjatë brenda një vargu të dhënë.\n# Funksioni merr një argument të vetëm, str, i cili është një varg që mund të përfshijë shkronja, numra dhe simbole.\n# Ai kthen gjatësinë e palindromës më të gjatë që mund të gjendet brenda vargut.\n# Palindromat janë sekuenca që lexohen njësoj mbrapsht si përpara.\n# Shënim: Funksioni është i ndjeshëm ndaj shkronjave të mëdha dhe konsideron secilën karakter.\n#\n# Shembull:\n# >>> find_longest_palindrome(\"ABBA\")\n# 4\n# >>> find_longest_palindrome(\"12ABBA\")\n# 4\n# >>> find_longest_palindrome(\"A\")\n# 1\n# >>> find_longest_palindrome(\"ABAKK\")\n# 3\n# >>> find_longest_palindrome(\"51233214\")\n# 6\n# >>> find_longest_palindrome(\"abaaab\")\n# 5\n\n\ndef find_longest_palindrome(str)",
      "hy": "# Գտնում է ամենաերկար պալինդրոմը տրված տողի մեջ:\n# Ֆունկցիան ընդունում է մեկ արգումենտ, str, որը տող է, որը կարող է ներառել տառեր, թվեր և սիմվոլներ:\n# Այն վերադարձնում է ամենաերկար պալինդրոմի երկարությունը, որը կարելի է գտնել տողի մեջ:\n# Պալինդրոմները հաջորդականություններ են, որոնք նույն կերպ են կարդացվում հետադարձ և առաջ:\n# Նշում: Ֆունկցիան զգայուն է մեծատառերի նկատմամբ և հաշվի է առնում յուրաքանչյուր սիմվոլը:\n#\n# Օրինակ:\n# >>> find_longest_palindrome(\"ABBA\")\n# 4\n# >>> find_longest_palindrome(\"12ABBA\")\n# 4\n# >>> find_longest_palindrome(\"A\")\n# 1\n# >>> find_longest_palindrome(\"ABAKK\")\n# 3\n# >>> find_longest_palindrome(\"51233214\")\n# 6\n# >>> find_longest_palindrome(\"abaaab\")\n# 5\n\n\ndef find_longest_palindrome(str)",
      "bn": "# প্রদত্ত স্ট্রিংয়ের মধ্যে দীর্ঘতম প্যালিন্ড্রোম খুঁজে বের করে।\n# ফাংশনটি একটি একক আর্গুমেন্ট গ্রহণ করে, str, যা একটি স্ট্রিং যা অক্ষর, সংখ্যা এবং প্রতীক অন্তর্ভুক্ত করতে পারে।\n# এটি স্ট্রিংয়ের মধ্যে পাওয়া দীর্ঘতম প্যালিন্ড্রোমের দৈর্ঘ্য ফেরত দেয়।\n# প্যালিন্ড্রোম হল এমন সিকোয়েন্স যা উল্টো এবং সোজা একইভাবে পড়া যায়।\n# নোট: ফাংশনটি case-sensitive এবং প্রতিটি অক্ষর বিবেচনা করে।\n#\n# উদাহরণ:\n# >>> find_longest_palindrome(\"ABBA\")\n# 4\n# >>> find_longest_palindrome(\"12ABBA\")\n# 4\n# >>> find_longest_palindrome(\"A\")\n# 1\n# >>> find_longest_palindrome(\"ABAKK\")\n# 3\n# >>> find_longest_palindrome(\"51233214\")\n# 6\n# >>> find_longest_palindrome(\"abaaab\")\n# 5\n\n\ndef find_longest_palindrome(str)",
      "bg": "# Намира най-дългия палиндром в даден низ.\n# Функцията приема един аргумент, str, който е низ и може да включва букви, цифри и символи.\n# Връща дължината на най-дългия палиндром, който може да бъде намерен в низа.\n# Палиндрoмите са последователности, които се четат еднакво напред и назад.\n# Забележка: Функцията е чувствителна към малки и големи букви и разглежда всеки символ.\n#\n# Пример:\n# >>> find_longest_palindrome(\"ABBA\")\n# 4\n# >>> find_longest_palindrome(\"12ABBA\")\n# 4\n# >>> find_longest_palindrome(\"A\")\n# 1\n# >>> find_longest_palindrome(\"ABAKK\")\n# 3\n# >>> find_longest_palindrome(\"51233214\")\n# 6\n# >>> find_longest_palindrome(\"abaaab\")\n# 5\n\n\ndef find_longest_palindrome(str)",
      "zh": "# 查找给定字符串中的最长回文。\n# 该函数接受一个参数，str，这是一个可能包含字母、数字和符号的字符串。\n# 它返回可以在字符串中找到的最长回文的长度。\n# 回文是指正反读都相同的序列。\n# 注意：该函数区分大小写，并考虑每个字符。\n#\n# 示例:\n# >>> find_longest_palindrome(\"ABBA\")\n# 4\n# >>> find_longest_palindrome(\"12ABBA\")\n# 4\n# >>> find_longest_palindrome(\"A\")\n# 1\n# >>> find_longest_palindrome(\"ABAKK\")\n# 3\n# >>> find_longest_palindrome(\"51233214\")\n# 6\n# >>> find_longest_palindrome(\"abaaab\")\n# 5\n\n\ndef find_longest_palindrome(str)",
      "fr": "# Trouve le plus long palindrome dans une chaîne donnée.\n# La fonction prend un seul argument, str, qui est une chaîne pouvant inclure des lettres, des chiffres et des symboles.\n# Elle renvoie la longueur du plus long palindrome pouvant être trouvé dans la chaîne.\n# Les palindromes sont des séquences qui se lisent de la même manière à l'envers qu'à l'endroit.\n# Remarque : La fonction est sensible à la casse et considère chaque caractère.\n#\n# Exemple :\n# >>> find_longest_palindrome(\"ABBA\")\n# 4\n# >>> find_longest_palindrome(\"12ABBA\")\n# 4\n# >>> find_longest_palindrome(\"A\")\n# 1\n# >>> find_longest_palindrome(\"ABAKK\")\n# 3\n# >>> find_longest_palindrome(\"51233214\")\n# 6\n# >>> find_longest_palindrome(\"abaaab\")\n# 5\n\n\ndef find_longest_palindrome(str)",
      "de": "# Findet das längste Palindrom innerhalb eines gegebenen Strings.\n# Die Funktion nimmt ein einzelnes Argument, str, das ein String ist, der Buchstaben, Zahlen und Symbole enthalten kann.\n# Sie gibt die Länge des längsten Palindroms zurück, das innerhalb des Strings gefunden werden kann.\n# Palindrome sind Sequenzen, die vorwärts wie rückwärts gleich gelesen werden.\n# Hinweis: Die Funktion ist groß- und kleinschreibungssensitiv und berücksichtigt jedes Zeichen.\n#\n# Beispiel:\n# >>> find_longest_palindrome(\"ABBA\")\n# 4\n# >>> find_longest_palindrome(\"12ABBA\")\n# 4\n# >>> find_longest_palindrome(\"A\")\n# 1\n# >>> find_longest_palindrome(\"ABAKK\")\n# 3\n# >>> find_longest_palindrome(\"51233214\")\n# 6\n# >>> find_longest_palindrome(\"abaaab\")\n# 5\n\n\ndef find_longest_palindrome(str)",
      "ha": "# Nemi mafi tsawon palindrome a cikin wani kirtani da aka bayar.\n# Aikin yana karɓar hujja guda ɗaya, str, wanda shi ne kirtani da zai iya haɗawa da haruffa, lambobi, da alamomi.\n# Yana mayar da tsawon mafi tsawon palindrome da za a iya samu a cikin kirtani.\n# Palindromes su ne jerin abubuwa da ake karantawa iri ɗaya daga baya zuwa gaba.\n# Lura: Aikin yana bambanta manya da ƙanana kuma yana la'akari da kowane hali.\n#\n# Misali:\n# >>> find_longest_palindrome(\"ABBA\")\n# 4\n# >>> find_longest_palindrome(\"12ABBA\")\n# 4\n# >>> find_longest_palindrome(\"A\")\n# 1\n# >>> find_longest_palindrome(\"ABAKK\")\n# 3\n# >>> find_longest_palindrome(\"51233214\")\n# 6\n# >>> find_longest_palindrome(\"abaaab\")\n# 5\n\n\ndef find_longest_palindrome(str)",
      "hi": "# दिए गए स्ट्रिंग के भीतर सबसे लंबा पालिंड्रोम खोजता है।\n# फ़ंक्शन एकल आर्ग्युमेंट लेता है, str, जो एक स्ट्रिंग है जिसमें अक्षर, संख्याएँ, और प्रतीक शामिल हो सकते हैं।\n# यह उस स्ट्रिंग के भीतर पाए जाने वाले सबसे लंबे पालिंड्रोम की लंबाई लौटाता है।\n# पालिंड्रोम वे अनुक्रम होते हैं जो आगे और पीछे से पढ़ने पर समान होते हैं।\n# नोट: फ़ंक्शन केस-सेंसिटिव है और प्रत्येक वर्ण को ध्यान में रखता है।\n#\n# उदाहरण:\n# >>> find_longest_palindrome(\"ABBA\")\n# 4\n# >>> find_longest_palindrome(\"12ABBA\")\n# 4\n# >>> find_longest_palindrome(\"A\")\n# 1\n# >>> find_longest_palindrome(\"ABAKK\")\n# 3\n# >>> find_longest_palindrome(\"51233214\")\n# 6\n# >>> find_longest_palindrome(\"abaaab\")\n# 5\n\n\ndef find_longest_palindrome(str)",
      "hu": "# Megkeresi a leghosszabb palindrómát egy adott szövegben.\n# A függvény egyetlen argumentumot vesz fel, str, amely egy olyan szöveg, ami tartalmazhat betűket, számokat és szimbólumokat.\n# Visszaadja a leghosszabb palindróma hosszát, amely megtalálható a szövegben.\n# A palindrómák olyan sorozatok, amelyek előre és hátra olvasva is ugyanazok.\n# Megjegyzés: A függvény kis- és nagybetű érzékeny, és minden karaktert figyelembe vesz.\n#\n# Példa:\n# >>> find_longest_palindrome(\"ABBA\")\n# 4\n# >>> find_longest_palindrome(\"12ABBA\")\n# 4\n# >>> find_longest_palindrome(\"A\")\n# 1\n# >>> find_longest_palindrome(\"ABAKK\")\n# 3\n# >>> find_longest_palindrome(\"51233214\")\n# 6\n# >>> find_longest_palindrome(\"abaaab\")\n# 5\n\n\ndef find_longest_palindrome(str)"
    },
    "prompt_bertscore": {
      "sq": "0.9959044401734416",
      "hy": "0.9862867571237324",
      "bn": "0.9805439555472517",
      "bg": "0.9786295559348375",
      "zh": "0.9754496821648498",
      "fr": "0.9931869779305034",
      "de": "0.9916785788169244",
      "ha": "0.9916694418193968",
      "hi": "0.9817822173426232",
      "hu": "0.9622612207552764"
    },
    "canonical_solution": "    return 0 if str.nil? || str.empty?\n  \n    longest = 0\n  \n    (0...str.length).each do |i|\n      # check for odd length palindromes\n      odd_palindrome = expand_around_center(str, i, i)\n      longest = [longest, odd_palindrome].max\n  \n      # check for even length palindromes\n      even_palindrome = expand_around_center(str, i, i + 1)\n      longest = [longest, even_palindrome].max\n    end\n  \n    longest\n  end\n  \n  def expand_around_center(str, left, right)\n    while left >= 0 && right < str.length && str[left] == str[right]\n      left -= 1\n      right += 1\n    end\n  \n    right - left - 1\n  end",
    "instruction": {
      "en": "Write a ruby function `def find_longest_palindrome(str)` to solve the following problem:\nFinds the longest palindrome within a given string.\nThe function takes a single argument, str, which is a string that may include letters, numbers, and symbols.\nIt returns the length of the longest palindrome that can be found within the string.\nPalindromes are sequences that read the same backward as forward.\nNote: The function is case-sensitive and considers each character.\n\nExample:\n>>> find_longest_palindrome(\"ABBA\")\n4\n>>> find_longest_palindrome(\"12ABBA\")\n4\n>>> find_longest_palindrome(\"A\")\n1\n>>> find_longest_palindrome(\"ABAKK\")\n3\n>>> find_longest_palindrome(\"51233214\")\n6\n>>> find_longest_palindrome(\"abaaab\")\n5",
      "sq": "Shkruani një funksion ruby `def find_longest_palindrome(str)` për të zgjidhur problemin në vijim:\nGjen palindromën më të gjatë brenda një vargu të dhënë.\nFunksioni merr një argument të vetëm, str, i cili është një varg që mund të përfshijë shkronja, numra dhe simbole.\nKthen gjatësinë e palindromës më të gjatë që mund të gjendet brenda vargut.\nPalindromat janë sekuenca që lexohen njësoj mbrapsht si përpara.\nShënim: Funksioni është i ndjeshëm ndaj shkronjave të mëdha dhe konsideron secilën karakter.\n\nShembull:\n>>> find_longest_palindrome(\"ABBA\")\n4\n>>> find_longest_palindrome(\"12ABBA\")\n4\n>>> find_longest_palindrome(\"A\")\n1\n>>> find_longest_palindrome(\"ABAKK\")\n3\n>>> find_longest_palindrome(\"51233214\")\n6\n>>> find_longest_palindrome(\"abaaab\")\n5",
      "hy": "Գրեք ruby ֆունկցիա `def find_longest_palindrome(str)` հետևյալ խնդիրը լուծելու համար:\nԳտնում է ամենաերկար պալինդրոմը տրված տողի մեջ:\nՖունկցիան ընդունում է մեկ արգումենտ, str, որը տող է, որը կարող է ներառել տառեր, թվեր և սիմվոլներ:\nԱյն վերադարձնում է ամենաերկար պալինդրոմի երկարությունը, որը կարող է գտնվել տողի մեջ:\nՊալինդրոմները հաջորդականություններ են, որոնք կարդացվում են նույն կերպ ինչպես հետ, այնպես էլ առաջ:\nՆշում: Ֆունկցիան զգայուն է մեծատառերի նկատմամբ և հաշվի է առնում յուրաքանչյուր սիմվոլը:\n\nՕրինակ:\n>>> find_longest_palindrome(\"ABBA\")\n4\n>>> find_longest_palindrome(\"12ABBA\")\n4\n>>> find_longest_palindrome(\"A\")\n1\n>>> find_longest_palindrome(\"ABAKK\")\n3\n>>> find_longest_palindrome(\"51233214\")\n6\n>>> find_longest_palindrome(\"abaaab\")\n5",
      "bn": "রুবি ফাংশন `def find_longest_palindrome(str)` লিখুন নিম্নলিখিত সমস্যার সমাধানের জন্য:\nএকটি প্রদত্ত স্ট্রিংয়ের মধ্যে দীর্ঘতম প্যালিনড্রোম খুঁজে বের করে।\nফাংশনটি একটি একক আর্গুমেন্ট গ্রহণ করে, str, যা একটি স্ট্রিং যা অক্ষর, সংখ্যা এবং প্রতীক অন্তর্ভুক্ত করতে পারে।\nএটি স্ট্রিংয়ের মধ্যে পাওয়া দীর্ঘতম প্যালিনড্রোমের দৈর্ঘ্য ফেরত দেয়।\nপ্যালিনড্রোম হল এমন ক্রম যা উল্টো এবং সোজা একইভাবে পড়া যায়।\nদ্রষ্টব্য: ফাংশনটি কেস-সেন্সিটিভ এবং প্রতিটি অক্ষরকে বিবেচনা করে।\n\nউদাহরণ:\n>>> find_longest_palindrome(\"ABBA\")\n4\n>>> find_longest_palindrome(\"12ABBA\")\n4\n>>> find_longest_palindrome(\"A\")\n1\n>>> find_longest_palindrome(\"ABAKK\")\n3\n>>> find_longest_palindrome(\"51233214\")\n6\n>>> find_longest_palindrome(\"abaaab\")\n5",
      "bg": "Напишете функция на Ruby `def find_longest_palindrome(str)` за решаване на следния проблем:\nНамира най-дългия палиндром в даден низ.\nФункцията приема един аргумент, str, който е низ и може да включва букви, цифри и символи.\nТя връща дължината на най-дългия палиндром, който може да бъде намерен в низа.\nПалиндромите са последователности, които се четат еднакво напред и назад.\nЗабележка: Функцията е чувствителна към големината на буквите и разглежда всеки символ.\n\nПример:\n>>> find_longest_palindrome(\"ABBA\")\n4\n>>> find_longest_palindrome(\"12ABBA\")\n4\n>>> find_longest_palindrome(\"A\")\n1\n>>> find_longest_palindrome(\"ABAKK\")\n3\n>>> find_longest_palindrome(\"51233214\")\n6\n>>> find_longest_palindrome(\"abaaab\")\n5",
      "zh": "编写一个 ruby 函数 `def find_longest_palindrome(str)` 来解决以下问题：\n在给定的字符串中找到最长的回文。\n该函数接受一个参数，str，这是一个可能包含字母、数字和符号的字符串。\n它返回可以在字符串中找到的最长回文的长度。\n回文是指正着读和反着读都相同的序列。\n注意：该函数区分大小写，并考虑每个字符。\n\n示例：\n>>> find_longest_palindrome(\"ABBA\")\n4\n>>> find_longest_palindrome(\"12ABBA\")\n4\n>>> find_longest_palindrome(\"A\")\n1\n>>> find_longest_palindrome(\"ABAKK\")\n3\n>>> find_longest_palindrome(\"51233214\")\n6\n>>> find_longest_palindrome(\"abaaab\")\n5",
      "fr": "Écrire une fonction ruby `def find_longest_palindrome(str)` pour résoudre le problème suivant :\nTrouve le plus long palindrome dans une chaîne donnée.\nLa fonction prend un seul argument, str, qui est une chaîne pouvant inclure des lettres, des chiffres et des symboles.\nElle renvoie la longueur du plus long palindrome qui peut être trouvé dans la chaîne.\nLes palindromes sont des séquences qui se lisent de la même manière à l'envers qu'à l'endroit.\nRemarque : La fonction est sensible à la casse et considère chaque caractère.\n\nExemple :\n>>> find_longest_palindrome(\"ABBA\")\n4\n>>> find_longest_palindrome(\"12ABBA\")\n4\n>>> find_longest_palindrome(\"A\")\n1\n>>> find_longest_palindrome(\"ABAKK\")\n3\n>>> find_longest_palindrome(\"51233214\")\n6\n>>> find_longest_palindrome(\"abaaab\")\n5",
      "de": "Schreiben Sie eine Ruby-Funktion `def find_longest_palindrome(str)`, um das folgende Problem zu lösen:\nFindet das längste Palindrom innerhalb eines gegebenen Strings.\nDie Funktion nimmt ein einzelnes Argument, str, das ein String ist, der Buchstaben, Zahlen und Symbole enthalten kann.\nSie gibt die Länge des längsten Palindroms zurück, das im String gefunden werden kann.\nPalindrome sind Sequenzen, die vorwärts wie rückwärts gleich gelesen werden.\nHinweis: Die Funktion ist case-sensitiv und berücksichtigt jedes Zeichen.\n\nBeispiel:\n>>> find_longest_palindrome(\"ABBA\")\n4\n>>> find_longest_palindrome(\"12ABBA\")\n4\n>>> find_longest_palindrome(\"A\")\n1\n>>> find_longest_palindrome(\"ABAKK\")\n3\n>>> find_longest_palindrome(\"51233214\")\n6\n>>> find_longest_palindrome(\"abaaab\")\n5",
      "ha": "Rubuta aikin ruby `def find_longest_palindrome(str)` don warware matsalar mai zuwa:\nNemo mafi tsawon palindrome a cikin wani kirtani da aka bayar.\nAikin yana ɗaukar hujja guda, str, wanda shine kirtani da zai iya haɗawa da haruffa, lambobi, da alamomi.\nYana dawo da tsawon mafi tsawon palindrome da za a iya samu a cikin kirtani.\nPalindromes sune jerin da suke karantawa iri ɗaya baya kamar gaba.\nLura: Aikin yana da bambanci tsakanin manyan baki da ƙananan baki kuma yana la'akari da kowanne hali.\n\nMisali:\n>>> find_longest_palindrome(\"ABBA\")\n4\n>>> find_longest_palindrome(\"12ABBA\")\n4\n>>> find_longest_palindrome(\"A\")\n1\n>>> find_longest_palindrome(\"ABAKK\")\n3\n>>> find_longest_palindrome(\"51233214\")\n6\n>>> find_longest_palindrome(\"abaaab\")\n5",
      "hi": "रूबी फ़ंक्शन `def find_longest_palindrome(str)` लिखें ताकि निम्नलिखित समस्या का समाधान किया जा सके:\nदिए गए स्ट्रिंग के भीतर सबसे लंबा पालिंड्रोम खोजें।\nयह फ़ंक्शन एक एकल तर्क लेता है, str, जो एक स्ट्रिंग है जिसमें अक्षर, संख्याएँ और प्रतीक शामिल हो सकते हैं।\nयह स्ट्रिंग के भीतर पाए जाने वाले सबसे लंबे पालिंड्रोम की लंबाई लौटाता है।\nपालिंड्रोम वे अनुक्रम होते हैं जो आगे और पीछे से पढ़ने पर समान होते हैं।\nनोट: फ़ंक्शन केस-संवेदी है और प्रत्येक वर्ण पर विचार करता है।\n\nउदाहरण:\n>>> find_longest_palindrome(\"ABBA\")\n4\n>>> find_longest_palindrome(\"12ABBA\")\n4\n>>> find_longest_palindrome(\"A\")\n1\n>>> find_longest_palindrome(\"ABAKK\")\n3\n>>> find_longest_palindrome(\"51233214\")\n6\n>>> find_longest_palindrome(\"abaaab\")\n5",
      "hu": "Írj egy ruby függvényt `def find_longest_palindrome(str)` a következő probléma megoldására:\nMegkeresi a leghosszabb palindrómát egy adott sztringben.\nA függvény egyetlen argumentumot vesz át, str, amely egy sztring, ami tartalmazhat betűket, számokat és szimbólumokat.\nVisszaadja a leghosszabb palindróma hosszát, amely megtalálható a sztringben.\nA palindrómák olyan sorozatok, amelyek előre és hátrafelé olvasva is ugyanazok.\nMegjegyzés: A függvény kis- és nagybetű érzékeny, és minden karaktert figyelembe vesz.\n\nPélda:\n>>> find_longest_palindrome(\"ABBA\")\n4\n>>> find_longest_palindrome(\"12ABBA\")\n4\n>>> find_longest_palindrome(\"A\")\n1\n>>> find_longest_palindrome(\"ABAKK\")\n3\n>>> find_longest_palindrome(\"51233214\")\n6\n>>> find_longest_palindrome(\"abaaab\")\n5"
    },
    "instruction_bertscore": {
      "sq": "0.9968304550098263",
      "hy": "0.9887136231192166",
      "bn": "0.9750083254581904",
      "bg": "0.9818936489863838",
      "zh": "0.9754886137195328",
      "fr": "0.9932553067815794",
      "de": "0.9895560145651856",
      "ha": "0.991841455729373",
      "hi": "0.9696923805705536",
      "hu": "0.9786049257675891"
    },
    "level": "hard",
    "test": "raise 'Test failed' unless find_longest_palindrome(\"ABBA\") == 4\nraise 'Test failed' unless find_longest_palindrome(\"12ABBA\") == 4\nraise 'Test failed' unless find_longest_palindrome(\"A\") == 1\nraise 'Test failed' unless find_longest_palindrome(\"ABAKK\") == 3\nraise 'Test failed' unless find_longest_palindrome(\"51233214\") == 6\nraise 'Test failed' unless find_longest_palindrome(\"abaaab\") == 5\n\n\nputs 'All tests passed!'",
    "entry_point": "find_longest_palindrome",
    "signature": "def find_longest_palindrome(str)",
    "docstring": {
      "en": "Finds the longest palindrome within a given string.\nThe function takes a single argument, str, which is a string that may include letters, numbers, and symbols.\nIt returns the length of the longest palindrome that can be found within the string.\nPalindromes are sequences that read the same backward as forward.\nNote: The function is case-sensitive and considers each character.\n\nExample:\n>>> find_longest_palindrome(\"ABBA\")\n4\n>>> find_longest_palindrome(\"12ABBA\")\n4\n>>> find_longest_palindrome(\"A\")\n1\n>>> find_longest_palindrome(\"ABAKK\")\n3\n>>> find_longest_palindrome(\"51233214\")\n6\n>>> find_longest_palindrome(\"abaaab\")\n5",
      "sq": "Gjen palindromën më të gjatë brenda një vargu të dhënë.\nFunksioni merr një argument të vetëm, str, i cili është një varg që mund të përfshijë shkronja, numra dhe simbole.\nKthen gjatësinë e palindromës më të gjatë që mund të gjendet brenda vargut.\nPalindromat janë sekuenca që lexohen njësoj mbrapsht si përpara.\nShënim: Funksioni është i ndjeshëm ndaj shkronjave të mëdha dhe konsideron secilën karakter.\n\nShembull:\n>>> find_longest_palindrome(\"ABBA\")\n4\n>>> find_longest_palindrome(\"12ABBA\")\n4\n>>> find_longest_palindrome(\"A\")\n1\n>>> find_longest_palindrome(\"ABAKK\")\n3\n>>> find_longest_palindrome(\"51233214\")\n6\n>>> find_longest_palindrome(\"abaaab\")\n5",
      "hy": "Գտնում է տրված տողի ամենաերկար պալինդրոմը։\nՖունկցիան ընդունում է մեկ արգումենտ, str, որը տող է, որը կարող է ներառել տառեր, թվեր և սիմվոլներ։\nԱյն վերադարձնում է տողի ներսում գտնված ամենաերկար պալինդրոմի երկարությունը։\nՊալինդրոմները հաջորդականություններ են, որոնք կարդացվում են նույն կերպ ինչպես հետ, այնպես էլ առաջ։\nՆշում: Ֆունկցիան զգայուն է մեծատառերի նկատմամբ և հաշվի է առնում յուրաքանչյուր սիմվոլը։\n\nՕրինակ:\n>>> find_longest_palindrome(\"ABBA\")\n4\n>>> find_longest_palindrome(\"12ABBA\")\n4\n>>> find_longest_palindrome(\"A\")\n1\n>>> find_longest_palindrome(\"ABAKK\")\n3\n>>> find_longest_palindrome(\"51233214\")\n6\n>>> find_longest_palindrome(\"abaaab\")\n5",
      "bn": "প্রদত্ত স্ট্রিংয়ের মধ্যে দীর্ঘতম প্যালিনড্রোম খুঁজে বের করে। \nফাংশনটি একটি মাত্র আর্গুমেন্ট গ্রহণ করে, str, যা একটি স্ট্রিং যা অক্ষর, সংখ্যা এবং প্রতীক অন্তর্ভুক্ত করতে পারে। \nএটি স্ট্রিংয়ের মধ্যে পাওয়া যেতে পারে এমন দীর্ঘতম প্যালিনড্রোমের দৈর্ঘ্য ফেরত দেয়। \nপ্যালিনড্রোম হল এমন সিকোয়েন্স যা উল্টো দিক থেকে পড়লেও একই থাকে। \nদ্রষ্টব্য: ফাংশনটি কেস-সংবেদনশীল এবং প্রতিটি অক্ষর বিবেচনা করে।\n\nউদাহরণ:\n>>> find_longest_palindrome(\"ABBA\")\n4\n>>> find_longest_palindrome(\"12ABBA\")\n4\n>>> find_longest_palindrome(\"A\")\n1\n>>> find_longest_palindrome(\"ABAKK\")\n3\n>>> find_longest_palindrome(\"51233214\")\n6\n>>> find_longest_palindrome(\"abaaab\")\n5",
      "bg": "Намира най-дългия палиндром в даден низ.\nФункцията приема един аргумент, str, който е низ, който може да включва букви, цифри и символи.\nВръща дължината на най-дългия палиндром, който може да бъде намерен в низа.\nПалиндромите са последователности, които се четат еднакво напред и назад.\nЗабележка: Функцията е чувствителна към малки и големи букви и разглежда всеки символ.\n\nПример:\n>>> find_longest_palindrome(\"ABBA\")\n4\n>>> find_longest_palindrome(\"12ABBA\")\n4\n>>> find_longest_palindrome(\"A\")\n1\n>>> find_longest_palindrome(\"ABAKK\")\n3\n>>> find_longest_palindrome(\"51233214\")\n6\n>>> find_longest_palindrome(\"abaaab\")\n5",
      "zh": "查找给定字符串中的最长回文。\n该函数接受一个参数，str，这是一个可能包含字母、数字和符号的字符串。\n它返回可以在字符串中找到的最长回文的长度。\n回文是指正向和反向读取都相同的序列。\n注意：该函数区分大小写，并考虑每个字符。\n\n示例：\n>>> find_longest_palindrome(\"ABBA\")\n4\n>>> find_longest_palindrome(\"12ABBA\")\n4\n>>> find_longest_palindrome(\"A\")\n1\n>>> find_longest_palindrome(\"ABAKK\")\n3\n>>> find_longest_palindrome(\"51233214\")\n6\n>>> find_longest_palindrome(\"abaaab\")\n5",
      "fr": "Trouve le plus long palindrome dans une chaîne donnée.  \nLa fonction prend un seul argument, str, qui est une chaîne pouvant inclure des lettres, des chiffres et des symboles.  \nElle renvoie la longueur du plus long palindrome qui peut être trouvé dans la chaîne.  \nLes palindromes sont des séquences qui se lisent de la même manière à l'envers qu'à l'endroit.  \nRemarque : La fonction est sensible à la casse et considère chaque caractère.  \n\nExemple :  \n>>> find_longest_palindrome(\"ABBA\")  \n4  \n>>> find_longest_palindrome(\"12ABBA\")  \n4  \n>>> find_longest_palindrome(\"A\")  \n1  \n>>> find_longest_palindrome(\"ABAKK\")  \n3  \n>>> find_longest_palindrome(\"51233214\")  \n6  \n>>> find_longest_palindrome(\"abaaab\")  \n5  ",
      "de": "Findet das längste Palindrom innerhalb eines gegebenen Strings.\nDie Funktion nimmt ein einzelnes Argument, str, das ein String ist, der Buchstaben, Zahlen und Symbole enthalten kann.\nSie gibt die Länge des längsten Palindroms zurück, das innerhalb des Strings gefunden werden kann.\nPalindrome sind Sequenzen, die vorwärts wie rückwärts gleich gelesen werden.\nHinweis: Die Funktion ist case-sensitiv und betrachtet jedes Zeichen.\n\nBeispiel:\n>>> find_longest_palindrome(\"ABBA\")\n4\n>>> find_longest_palindrome(\"12ABBA\")\n4\n>>> find_longest_palindrome(\"A\")\n1\n>>> find_longest_palindrome(\"ABAKK\")\n3\n>>> find_longest_palindrome(\"51233214\")\n6\n>>> find_longest_palindrome(\"abaaab\")\n5",
      "ha": "Nemi mafi tsawon palindrome a cikin wani kirtani da aka bayar.\nAikin yana ɗaukar hujja guda ɗaya, str, wanda kirtani ne da zai iya haɗawa da haruffa, lambobi, da alamomi.\nYana mayar da tsawon mafi tsawon palindrome da za a iya samu a cikin kirtani.\nPalindromes sune jerin abubuwa da suke karantawa iri ɗaya a baya kamar yadda suke a gaba.\nLura: Aikin yana bambanta manya da ƙananan haruffa kuma yana la'akari da kowane hali.\n\nMisali:\n>>> find_longest_palindrome(\"ABBA\")\n4\n>>> find_longest_palindrome(\"12ABBA\")\n4\n>>> find_longest_palindrome(\"A\")\n1\n>>> find_longest_palindrome(\"ABAKK\")\n3\n>>> find_longest_palindrome(\"51233214\")\n6\n>>> find_longest_palindrome(\"abaaab\")\n5",
      "hi": "दिए गए स्ट्रिंग के भीतर सबसे लंबा पैलिंड्रोम खोजता है।\nयह फ़ंक्शन एकल तर्क, str लेता है, जो एक स्ट्रिंग है जिसमें अक्षर, संख्याएँ, और प्रतीक शामिल हो सकते हैं।\nयह स्ट्रिंग के भीतर पाया जा सकने वाले सबसे लंबे पैलिंड्रोम की लंबाई लौटाता है।\nपैलिंड्रोम वे अनुक्रम हैं जो आगे और पीछे से पढ़ने पर समान होते हैं।\nध्यान दें: फ़ंक्शन केस-संवेदी है और प्रत्येक वर्ण को ध्यान में रखता है।\n\nउदाहरण:\n>>> find_longest_palindrome(\"ABBA\")\n4\n>>> find_longest_palindrome(\"12ABBA\")\n4\n>>> find_longest_palindrome(\"A\")\n1\n>>> find_longest_palindrome(\"ABAKK\")\n3\n>>> find_longest_palindrome(\"51233214\")\n6\n>>> find_longest_palindrome(\"abaaab\")\n5",
      "hu": "Megkeresi a leghosszabb palindrómát egy adott karakterláncban.\nA függvény egyetlen argumentumot, a str-t veszi át, amely egy olyan karakterlánc, amely betűket, számokat és szimbólumokat tartalmazhat.\nVisszaadja a karakterláncban található leghosszabb palindróma hosszát.\nA palindrómák olyan sorozatok, amelyek előre és hátra olvasva is ugyanazok.\nMegjegyzés: A függvény kis- és nagybetűérzékeny, és minden karaktert figyelembe vesz.\n\nPélda:\n>>> find_longest_palindrome(\"ABBA\")\n4\n>>> find_longest_palindrome(\"12ABBA\")\n4\n>>> find_longest_palindrome(\"A\")\n1\n>>> find_longest_palindrome(\"ABAKK\")\n3\n>>> find_longest_palindrome(\"51233214\")\n6\n>>> find_longest_palindrome(\"abaaab\")\n5"
    },
    "docstring_bertscore": {
      "sq": "0.99157985951755",
      "hy": "0.9737118649611757",
      "bn": "0.9736761114925894",
      "bg": "0.9822265535049982",
      "zh": "0.9706352789893262",
      "fr": "0.991602702011369",
      "de": "0.9905614815539842",
      "ha": "0.9865110108239208",
      "hi": "0.9919177297956904",
      "hu": "0.9718715544808875"
    }
  },
  {
    "task_id": "Ruby/27",
    "prompt": {
      "en": "# Calculates the sum of two integers as perceived by Xiao Ming, a child who \n# simplifies numbers larger than 99 to their last two digits before addition, \n# and also keeps only the last two digits of the result if it exceeds 99.\n#\n# The function takes two arguments, a and b, which are non-negative integers, and \n# returns the final sum according to Xiao Ming's calculation method.\n#\n# Examples:\n# >>> ming_sum(35, 80)\n# 15\n# >>> ming_sum(15, 1152)\n# 67\n\ndef ming_sum(a, b)",
      "sq": "# Llogarit shumën e dy numrave të plotë siç e percepton Xiao Ming, një fëmijë që \n# thjeshton numrat më të mëdhenj se 99 në dy shifrat e tyre të fundit para mbledhjes, \n# dhe gjithashtu mban vetëm dy shifrat e fundit të rezultatit nëse tejkalon 99.\n#\n# Funksioni merr dy argumente, a dhe b, të cilat janë numra të plotë jo-negativë, dhe \n# kthen shumën përfundimtare sipas metodës së llogaritjes së Xiao Ming.\n#\n# Shembuj:\n# >>> ming_sum(35, 80)\n# 15\n# >>> ming_sum(15, 1152)\n# 67\n\ndef ming_sum(a, b)",
      "hy": "# Հաշվում է երկու ամբողջ թվերի գումարը, ինչպես ընկալում է Սյաո Մինը՝ \n# մի երեխա, ով պարզեցնում է 99-ից մեծ թվերը՝ թողնելով միայն վերջին երկու թվանշանները \n# գումարումից առաջ, և եթե արդյունքը գերազանցում է 99-ը, պահում է միայն վերջին երկու թվանշանները։\n#\n# Ֆունկցիան ընդունում է երկու արգումենտ՝ a և b, որոնք ոչ բացասական ամբողջ թվեր են, և \n# վերադարձնում է վերջնական գումարը ըստ Սյաո Մինի հաշվարկի մեթոդի։\n#\n# Օրինակներ:\n# >>> ming_sum(35, 80)\n# 15\n# >>> ming_sum(15, 1152)\n# 67\n\ndef ming_sum(a, b)",
      "bn": "# দুটি পূর্ণসংখ্যার যোগফল গণনা করে যেভাবে শিয়াও মিং, একটি শিশু যে \n# ৯৯ এর চেয়ে বড় সংখ্যাগুলিকে যোগ করার আগে তাদের শেষ দুটি অঙ্কে সরল করে, \n# এবং যদি ফলাফলটি ৯৯ ছাড়িয়ে যায় তবে এর শেষ দুটি অঙ্কই রাখে।\n#\n# ফাংশনটি দুটি আর্গুমেন্ট নেয়, a এবং b, যা অ-ঋণাত্মক পূর্ণসংখ্যা, এবং \n# শিয়াও মিং এর গণনা পদ্ধতি অনুযায়ী চূড়ান্ত যোগফল প্রদান করে।\n#\n# উদাহরণ:\n# >>> ming_sum(35, 80)\n# 15\n# >>> ming_sum(15, 1152)\n# 67\n\ndef ming_sum(a, b)",
      "bg": "# Изчислява сумата на две цели числа, както я възприема Сяо Минг, дете, което\n# опростява числата, по-големи от 99, до последните им две цифри преди събирането,\n# и също така запазва само последните две цифри на резултата, ако той надвишава 99.\n#\n# Функцията приема два аргумента, a и b, които са неотрицателни цели числа, и\n# връща крайната сума според метода на изчисление на Сяо Минг.\n#\n# Примери:\n# >>> ming_sum(35, 80)\n# 15\n# >>> ming_sum(15, 1152)\n# 67\n\ndef ming_sum(a, b)",
      "zh": "# 计算两个整数的和，按照小明的理解，一个孩子在加法前将大于99的数字简化为它们的最后两位数字，\n# 并且如果结果超过99，也只保留结果的最后两位数字。\n#\n# 该函数接受两个参数，a 和 b，它们是非负整数，并根据小明的计算方法返回最终的和。\n#\n# 示例：\n# >>> ming_sum(35, 80)\n# 15\n# >>> ming_sum(15, 1152)\n# 67\n\ndef ming_sum(a, b)",
      "fr": "# Calcule la somme de deux entiers telle que perçue par Xiao Ming, un enfant qui \n# simplifie les nombres supérieurs à 99 à leurs deux derniers chiffres avant l'addition, \n# et conserve également uniquement les deux derniers chiffres du résultat si celui-ci dépasse 99.\n#\n# La fonction prend deux arguments, a et b, qui sont des entiers non négatifs, et \n# renvoie la somme finale selon la méthode de calcul de Xiao Ming.\n#\n# Exemples :\n# >>> ming_sum(35, 80)\n# 15\n# >>> ming_sum(15, 1152)\n# 67\n\ndef ming_sum(a, b)",
      "de": "# Berechnet die Summe von zwei ganzen Zahlen, wie sie von Xiao Ming wahrgenommen wird, einem Kind, das \n# Zahlen größer als 99 auf ihre letzten zwei Ziffern vereinfacht, bevor es sie addiert, \n# und auch nur die letzten zwei Ziffern des Ergebnisses behält, wenn es 99 übersteigt.\n#\n# Die Funktion nimmt zwei Argumente, a und b, die nicht-negative ganze Zahlen sind, und \n# gibt die endgültige Summe gemäß Xiao Mings Berechnungsmethode zurück.\n#\n# Beispiele:\n# >>> ming_sum(35, 80)\n# 15\n# >>> ming_sum(15, 1152)\n# 67\n\ndef ming_sum(a, b)",
      "ha": "# Lissafin jimillar lambobi guda biyu kamar yadda Xiao Ming, wani yaro da ke \n# saukaka lambobi masu girma fiye da 99 zuwa lambobinsu na ƙarshe biyu kafin a haɗa, \n# kuma yana riƙe da lambobin ƙarshe biyu na sakamakon idan ya wuce 99.\n#\n# Aikin yana karɓar hujjoji guda biyu, a da b, waɗanda lambobi ne marasa kyau, kuma \n# yana mayar da jimillar ƙarshe bisa ga hanyar lissafin Xiao Ming.\n#\n# Misalai:\n# >>> ming_sum(35, 80)\n# 15\n# >>> ming_sum(15, 1152)\n# 67\n\ndef ming_sum(a, b)",
      "hi": "# दो पूर्णांकों का योग गणना करता है जैसा कि Xiao Ming, एक बच्चा जो \n# 99 से बड़े संख्याओं को जोड़ने से पहले उनके अंतिम दो अंकों तक सरल करता है, \n# और यदि परिणाम 99 से अधिक होता है तो केवल अंतिम दो अंकों को रखता है।\n#\n# यह फ़ंक्शन दो तर्क लेता है, a और b, जो गैर-ऋणात्मक पूर्णांक हैं, और \n# Xiao Ming की गणना विधि के अनुसार अंतिम योग लौटाता है।\n#\n# उदाहरण:\n# >>> ming_sum(35, 80)\n# 15\n# >>> ming_sum(15, 1152)\n# 67\n\ndef ming_sum(a, b)",
      "hu": "# Kiszámítja két egész szám összegét Xiao Ming, egy gyermek szemszögéből, aki \n# az egyszerűsítés kedvéért a 99-nél nagyobb számokat az utolsó két számjegyükre \n# redukálja az összeadás előtt, és az eredményből is csak az utolsó két számjegyet \n# tartja meg, ha az meghaladja a 99-et.\n#\n# A függvény két argumentumot vesz fel, a és b, amelyek nemnegatív egész számok, \n# és visszaadja a végső összeget Xiao Ming számítási módszere szerint.\n#\n# Példák:\n# >>> ming_sum(35, 80)\n# 15\n# >>> ming_sum(15, 1152)\n# 67\n\ndef ming_sum(a, b)"
    },
    "prompt_bertscore": {
      "sq": "0.9953305970026318",
      "hy": "0.9541696149230582",
      "bn": "0.9508840697903601",
      "bg": "0.9946055961118545",
      "zh": "0.9385022463581693",
      "fr": "0.9964695436074859",
      "de": "0.992296517932324",
      "ha": "0.9532090384003734",
      "hi": "0.9428683407636972",
      "hu": "0.9622498988235574"
    },
    "canonical_solution": "    a %= 100\n    b %= 100\n    (a + b) % 100\n  end",
    "instruction": {
      "en": "Write a ruby function `def ming_sum(a, b)` to solve the following problem:\nCalculates the sum of two integers as perceived by Xiao Ming, a child who\nsimplifies numbers larger than 99 to their last two digits before addition,\nand also keeps only the last two digits of the result if it exceeds 99.\n\nThe function takes two arguments, a and b, which are non-negative integers, and\nreturns the final sum according to Xiao Ming's calculation method.\n\nExamples:\n>>> ming_sum(35, 80)\n15\n>>> ming_sum(15, 1152)\n67",
      "sq": "Shkruani një funksion ruby `def ming_sum(a, b)` për të zgjidhur problemin e mëposhtëm:\nLlogarit shumën e dy numrave të plotë ashtu siç e percepton Xiao Ming, një fëmijë që thjeshton numrat më të mëdhenj se 99 në dy shifrat e fundit të tyre para mbledhjes, dhe gjithashtu mban vetëm dy shifrat e fundit të rezultatit nëse tejkalon 99.\n\nFunksioni merr dy argumente, a dhe b, të cilat janë numra të plotë jo-negativë, dhe kthen shumën përfundimtare sipas metodës së llogaritjes së Xiao Ming.\n\nShembuj:\n>>> ming_sum(35, 80)\n15\n>>> ming_sum(15, 1152)\n67",
      "hy": "Գրեք ruby ֆունկցիա `def ming_sum(a, b)` հետևյալ խնդիրը լուծելու համար:\nՀաշվում է երկու ամբողջ թվերի գումարը, ինչպես այն ընկալում է Սյաո Մինը, մի երեխա, ով պարզեցնում է 99-ից մեծ թվերը՝ թողնելով միայն վերջին երկու թվանշանները մինչև գումարումը, և եթե արդյունքը գերազանցում է 99-ը, նույնպես պահում է միայն վերջին երկու թվանշանները։\n\nՖունկցիան ընդունում է երկու արգումենտ՝ a և b, որոնք ոչ բացասական ամբողջ թվեր են, և վերադարձնում է վերջնական գումարը՝ ըստ Սյաո Մինի հաշվարկման մեթոդի։\n\nՕրինակներ:\n>>> ming_sum(35, 80)\n15\n>>> ming_sum(15, 1152)\n67",
      "bn": "রুবি ফাংশন `def ming_sum(a, b)` লিখুন নিম্নলিখিত সমস্যার সমাধানের জন্য:\nদুটি পূর্ণসংখ্যার যোগফল হিসাব করে যা শিয়াও মিং, একটি শিশু যিনি ৯৯ এর চেয়ে বড় সংখ্যাগুলিকে যোগ করার আগে তাদের শেষ দুটি অঙ্কে সরলীকৃত করে, এবং ফলাফল যদি ৯৯ এর বেশি হয় তবে শুধুমাত্র শেষ দুটি অঙ্ক রাখে।\n\nফাংশনটি দুটি আর্গুমেন্ট নেয়, a এবং b, যা অ-ঋণাত্মক পূর্ণসংখ্যা, এবং শিয়াও মিং এর গণনা পদ্ধতি অনুযায়ী চূড়ান্ত যোগফল ফেরত দেয়।\n\nউদাহরণসমূহ:\n>>> ming_sum(35, 80)\n15\n>>> ming_sum(15, 1152)\n67",
      "bg": "Напишете функция на Ruby `def ming_sum(a, b)` за решаване на следния проблем:\nИзчислява сумата на две цели числа, както я възприема Сяо Мин, дете, което\nопростява числата по-големи от 99 до последните им две цифри преди събиране,\nи също така запазва само последните две цифри от резултата, ако той надвишава 99.\n\nФункцията приема два аргумента, a и b, които са неотрицателни цели числа, и\nвръща крайната сума според метода на изчисление на Сяо Мин.\n\nПримери:\n>>> ming_sum(35, 80)\n15\n>>> ming_sum(15, 1152)\n67",
      "zh": "编写一个 ruby 函数 `def ming_sum(a, b)` 来解决以下问题：\n计算两个整数的和，按照小明的理解，一个孩子在加法之前将大于 99 的数字简化为它们的最后两位数字，并且如果结果超过 99，也只保留结果的最后两位数字。\n\n该函数接受两个参数，a 和 b，它们是非负整数，并根据小明的计算方法返回最终的和。\n\n例子：\n>>> ming_sum(35, 80)\n15\n>>> ming_sum(15, 1152)\n67",
      "fr": "Écrire une fonction ruby `def ming_sum(a, b)` pour résoudre le problème suivant :\nCalcule la somme de deux entiers telle que perçue par Xiao Ming, un enfant qui\nsimplifie les nombres supérieurs à 99 à leurs deux derniers chiffres avant l'addition,\net conserve également uniquement les deux derniers chiffres du résultat si celui-ci dépasse 99.\n\nLa fonction prend deux arguments, a et b, qui sont des entiers non négatifs, et\nrenvoie la somme finale selon la méthode de calcul de Xiao Ming.\n\nExemples :\n>>> ming_sum(35, 80)\n15\n>>> ming_sum(15, 1152)\n67",
      "de": "Schreiben Sie eine Ruby-Funktion `def ming_sum(a, b)`, um das folgende Problem zu lösen:\nBerechnet die Summe von zwei ganzen Zahlen, wie sie von Xiao Ming, einem Kind, wahrgenommen wird, das Zahlen größer als 99 auf ihre letzten zwei Ziffern vereinfacht, bevor es sie addiert, und auch nur die letzten zwei Ziffern des Ergebnisses beibehält, wenn es 99 überschreitet.\n\nDie Funktion nimmt zwei Argumente, a und b, die nicht-negative ganze Zahlen sind, und gibt die endgültige Summe gemäß Xiao Mings Berechnungsmethode zurück.\n\nBeispiele:\n>>> ming_sum(35, 80)\n15\n>>> ming_sum(15, 1152)\n67",
      "ha": "Rubuta aikin ruby `def ming_sum(a, b)` don warware matsalar mai zuwa:\nLissafa jumlar lambobi guda biyu kamar yadda Xiao Ming, yaro wanda\nke saukaka lambobi masu girma fiye da 99 zuwa lambobin ƙarshe guda biyu kafin ƙara,\nkuma yana kuma riƙe lambobin ƙarshe guda biyu na sakamakon idan ya zarce 99.\n\nAikin yana ɗaukar hujjoji guda biyu, a da b, waɗanda lambobi ne marasa kyau,\nkuma yana mayar da jumlar ƙarshe bisa ga hanyar lissafin Xiao Ming.\n\nMisalai:\n>>> ming_sum(35, 80)\n15\n>>> ming_sum(15, 1152)\n67",
      "hi": "रूबी फ़ंक्शन `def ming_sum(a, b)` लिखें ताकि निम्नलिखित समस्या का समाधान किया जा सके:\nदो पूर्णांकों का योग गणना करता है जैसा कि शिआओ मिंग, एक बच्चा जो 99 से बड़े संख्याओं को जोड़ने से पहले उनके अंतिम दो अंकों तक सरल करता है, और यदि परिणाम 99 से अधिक हो जाता है, तो केवल अंतिम दो अंकों को रखता है।\n\nयह फ़ंक्शन दो तर्क लेता है, a और b, जो गैर-ऋणात्मक पूर्णांक हैं, और शिआओ मिंग की गणना विधि के अनुसार अंतिम योग लौटाता है।\n\nउदाहरण:\n>>> ming_sum(35, 80)\n15\n>>> ming_sum(15, 1152)\n67",
      "hu": "Írj egy ruby függvényt `def ming_sum(a, b)` a következő probléma megoldására:\nKiszámítja két egész szám összegét Xiao Ming, egy gyermek által érzékelt módon, aki az egyszerűsítés érdekében a 99-nél nagyobb számokat a két utolsó számjegyükre csökkenti összeadás előtt, és az eredményből is csak az utolsó két számjegyet tartja meg, ha az meghaladja a 99-et.\n\nA függvény két argumentumot vesz fel, a és b, amelyek nem negatív egész számok, és visszaadja a végső összeget Xiao Ming számítási módszere szerint.\n\nPéldák:\n>>> ming_sum(35, 80)\n15\n>>> ming_sum(15, 1152)\n67"
    },
    "instruction_bertscore": {
      "sq": "0.9967257767990209",
      "hy": "0.9601736154505998",
      "bn": "0.9483340529586342",
      "bg": "0.9875303819393918",
      "zh": "0.941961990335035",
      "fr": "0.994187280529395",
      "de": "0.987520053159578",
      "ha": "0.9669808772390464",
      "hi": "0.958551997019831",
      "hu": "0.9795786118954221"
    },
    "level": "easy",
    "test": "raise 'Test failed' unless ming_sum(35, 80) == 15\nraise 'Test failed' unless ming_sum(15, 1152) == 67\nraise 'Test failed' unless ming_sum(1234, 5678) == 12\nraise 'Test failed' unless ming_sum(0, 99) == 99\nraise 'Test failed' unless ming_sum(50, 50) == 0\n\n\n\n\nputs 'All tests passed!'",
    "entry_point": "ming_sum",
    "signature": "def ming_sum(a, b)",
    "docstring": {
      "en": "Calculates the sum of two integers as perceived by Xiao Ming, a child who\nsimplifies numbers larger than 99 to their last two digits before addition,\nand also keeps only the last two digits of the result if it exceeds 99.\n\nThe function takes two arguments, a and b, which are non-negative integers, and\nreturns the final sum according to Xiao Ming's calculation method.\n\nExamples:\n>>> ming_sum(35, 80)\n15\n>>> ming_sum(15, 1152)\n67",
      "sq": "Llogarit shumën e dy numrave të plotë siç e percepton Xiao Ming, një fëmijë që thjeshton numrat më të mëdhenj se 99 në dy shifrat e tyre të fundit para mbledhjes, dhe gjithashtu mban vetëm dy shifrat e fundit të rezultatit nëse tejkalon 99.\n\nFunksioni merr dy argumente, a dhe b, të cilat janë numra të plotë jo-negativë, dhe kthen shumën përfundimtare sipas metodës së llogaritjes së Xiao Ming.\n\nShembuj:\n>>> ming_sum(35, 80)\n15\n>>> ming_sum(15, 1152)\n67",
      "hy": "Հաշվում է երկու ամբողջ թվերի գումարը, ինչպես ընկալում է Սյաո Մինը՝ մի երեխա, ով պարզեցնում է 99-ից մեծ թվերը՝ թողնելով միայն վերջին երկու թվանշանները, նախքան գումարելը, և եթե արդյունքը գերազանցում է 99-ը, պահում է միայն վերջին երկու թվանշանները:\n\nՖունկցիան ընդունում է երկու արգումենտ՝ a և b, որոնք ոչ բացասական ամբողջ թվեր են, և վերադարձնում է վերջնական գումարը՝ ըստ Սյաո Մինի հաշվարկի մեթոդի:\n\nՕրինակներ:\n>>> ming_sum(35, 80)\n15\n>>> ming_sum(15, 1152)\n67",
      "bn": "দুটি পূর্ণসংখ্যার যোগফল হিসাব করে যা শিয়াও মিং, একটি শিশু যিনি ৯৯ এর চেয়ে বড় সংখ্যাগুলিকে যোগ করার আগে তাদের শেষ দুটি অঙ্কে সরলীকৃত করে, এবং ফলাফল যদি ৯৯ এর বেশি হয় তবে শুধুমাত্র শেষ দুটি অঙ্ক রাখে।\n\nফাংশনটি দুটি আর্গুমেন্ট গ্রহণ করে, a এবং b, যা অ-ঋণাত্মক পূর্ণসংখ্যা, এবং\nXiao Ming এর গণনা পদ্ধতি অনুযায়ী চূড়ান্ত যোগফল প্রদান করে।\n\nউদাহরণসমূহ:\n>>> ming_sum(35, 80)\n15\n>>> ming_sum(15, 1152)\n67",
      "bg": "Изчислява сумата на две цели числа, както я възприема Сяо Минг, дете, което опростява числата, по-големи от 99, до последните им две цифри преди събирането, и също така запазва само последните две цифри на резултата, ако той надвишава 99.\n\nФункцията приема два аргумента, a и b, които са неотрицателни цели числа, и връща крайната сума според метода на изчисление на Сяо Минг.\n\nПримери:\n>>> ming_sum(35, 80)\n15\n>>> ming_sum(15, 1152)\n67",
      "zh": "计算两个整数的和，按照小明的理解，一个孩子在加法前将大于99的数字简化为它们的最后两位数字，并且如果结果超过99，也只保留结果的最后两位数字。\n\nArgs:\n    a: 非负整数\n    b: 非负整数\n\nReturns:\n    根据小明的计算方法返回最终的和。\n\nExamples:\n>>> ming_sum(35, 80)\n15\n>>> ming_sum(15, 1152)\n67",
      "fr": "Calcule la somme de deux entiers telle que perçue par Xiao Ming, un enfant qui\nsimplifie les nombres supérieurs à 99 à leurs deux derniers chiffres avant l'addition,\net conserve également uniquement les deux derniers chiffres du résultat si celui-ci dépasse 99.\n\nLa fonction prend deux arguments, a et b, qui sont des entiers non négatifs, et\nrenvoie la somme finale selon la méthode de calcul de Xiao Ming.\n\nExemples :\n>>> ming_sum(35, 80)\n15\n>>> ming_sum(15, 1152)\n67",
      "de": "Berechnet die Summe von zwei ganzen Zahlen, wie sie von Xiao Ming wahrgenommen wird, einem Kind, das Zahlen größer als 99 auf ihre letzten beiden Ziffern vereinfacht, bevor es sie addiert, und auch nur die letzten beiden Ziffern des Ergebnisses behält, wenn es 99 übersteigt.\n\nDie Funktion nimmt zwei Argumente, a und b, die nicht-negative ganze Zahlen sind, und gibt die endgültige Summe gemäß Xiao Mings Berechnungsmethode zurück.\n\nBeispiele:\n>>> ming_sum(35, 80)\n15\n>>> ming_sum(15, 1152)\n67",
      "ha": "Yana lissafin jimillar lambobi guda biyu kamar yadda Xiao Ming, wani yaro da\nke saukaka lambobi masu girma fiye da 99 zuwa lambobin ƙarshe biyu kafin ƙara,\nkuma yana riƙe da lambobin ƙarshe biyu na sakamakon idan ya wuce 99.\n\nAikin yana ɗaukar hujjoji guda biyu, a da b, waɗanda lambobi ne marasa kyau, kuma\nyana mayar da jimillar ƙarshe bisa ga hanyar lissafin Xiao Ming.\n\nMisalai:\n>>> ming_sum(35, 80)\n15\n>>> ming_sum(15, 1152)\n67",
      "hi": "Xiao Ming द्वारा देखे गए दो पूर्णांकों का योग गणना करता है, जो एक बच्चा है जो 99 से बड़े संख्याओं को जोड़ने से पहले उनके अंतिम दो अंकों तक सरल करता है, और यदि परिणाम 99 से अधिक हो जाता है तो केवल अंतिम दो अंकों को रखता है।\n\nयह फ़ंक्शन दो तर्क लेता है, a और b, जो गैर-ऋणात्मक पूर्णांक हैं, और Xiao Ming की गणना विधि के अनुसार अंतिम योग लौटाता है।\n\nउदाहरण:\n>>> ming_sum(35, 80)\n15\n>>> ming_sum(15, 1152)\n67",
      "hu": "Kiszámítja két egész szám összegét úgy, ahogyan Xiao Ming, egy gyermek, aki az\n99-nél nagyobb számokat az utolsó két számjegyükre egyszerűsíti összeadás előtt,\nés az eredményből is csak az utolsó két számjegyet tartja meg, ha az meghaladja a 99-et.\n\nA függvény két argumentumot vesz fel, a és b, amelyek nem negatív egész számok, és\nvisszaadja a végső összeget Xiao Ming számítási módszere szerint.\n\nPéldák:\n>>> ming_sum(35, 80)\n15\n>>> ming_sum(15, 1152)\n67"
    },
    "docstring_bertscore": {
      "sq": "0.9908363860013365",
      "hy": "0.9552918765759053",
      "bn": "0.9936668689310836",
      "bg": "0.9909215984348004",
      "zh": "0.8667217951509245",
      "fr": "0.9916805651207348",
      "de": "0.9865590793761312",
      "ha": "0.9532950453553616",
      "hi": "0.9658786772546838",
      "hu": "0.9750550035977336"
    }
  },
  {
    "task_id": "Ruby/28",
    "prompt": {
      "en": "# Finds the longest word in a given sentence.\n# The function takes a single argument, sentence, which is a string containing multiple words separated by spaces.\n# Each word is composed only of lowercase letters. The function returns the longest word found in the sentence.\n# If there are multiple words of the same longest length, it returns the first one encountered.\n#\n# Example:\n# >>> find_longest_word(\"I am a student\")\n# \"student\"\n# >>> find_longest_word(\"The quick brown fox\")\n# \"quick\"\n\ndef find_longest_word(sentence)",
      "sq": "# Gjen fjalën më të gjatë në një fjali të dhënë.\n# Funksioni merr një argument të vetëm, fjali, që është një varg që përmban disa fjalë të ndara me hapësira.\n# Çdo fjalë përbëhet vetëm nga shkronja të vogla. Funksioni kthen fjalën më të gjatë të gjetur në fjali.\n# Nëse ka disa fjalë me të njëjtën gjatësi më të madhe, kthen të parën që haset.\n#\n# Shembull:\n# >>> find_longest_word(\"I am a student\")\n# \"student\"\n# >>> find_longest_word(\"The quick brown fox\")\n# \"quick\"\n\ndef find_longest_word(sentence)",
      "hy": "# Գտնում է ամենաերկար բառը տրված նախադասության մեջ։\n# Ֆունկցիան ընդունում է մեկ արգումենտ, sentence, որը տող է, պարունակող բազմաթիվ բառեր, որոնք բաժանված են բացատներով։\n# Յուրաքանչյուր բառ կազմված է միայն փոքրատառ տառերից։ Ֆունկցիան վերադարձնում է ամենաերկար բառը, որը գտնվել է նախադասության մեջ։\n# Եթե կան մի քանի նույն երկարությամբ բառեր, վերադարձնում է առաջինը, որը հանդիպել է։\n#\n# Օրինակ:\n# >>> find_longest_word(\"I am a student\")\n# \"student\"\n# >>> find_longest_word(\"The quick brown fox\")\n# \"quick\"\n\ndef find_longest_word(sentence)",
      "bn": "# প্রদত্ত বাক্যে সবচেয়ে দীর্ঘ শব্দটি খুঁজে বের করে।\n# ফাংশনটি একটি একক আর্গুমেন্ট গ্রহণ করে, sentence, যা স্পেস দ্বারা পৃথক একাধিক শব্দের একটি স্ট্রিং।\n# প্রতিটি শব্দ শুধুমাত্র ছোট হাতের অক্ষর নিয়ে গঠিত। ফাংশনটি বাক্যে পাওয়া সবচেয়ে দীর্ঘ শব্দটি ফেরত দেয়।\n# যদি একই দীর্ঘতম দৈর্ঘ্যের একাধিক শব্দ থাকে, তাহলে এটি প্রথমে পাওয়া শব্দটি ফেরত দেয়।\n#\n# উদাহরণ:\n# >>> find_longest_word(\"I am a student\")\n# \"student\"\n# >>> find_longest_word(\"The quick brown fox\")\n# \"quick\"\n\ndef find_longest_word(sentence)",
      "bg": "# Намира най-дългата дума в дадено изречение.\n# Функцията приема един аргумент, sentence, който е низ, съдържащ няколко думи, разделени с интервали.\n# Всяка дума се състои само от малки букви. Функцията връща най-дългата дума, намерена в изречението.\n# Ако има няколко думи с еднаква най-голяма дължина, връща първата срещната.\n#\n# Пример:\n# >>> find_longest_word(\"I am a student\")\n# \"student\"\n# >>> find_longest_word(\"The quick brown fox\")\n# \"quick\"\n\ndef find_longest_word(sentence)",
      "zh": "# 查找给定句子中最长的单词。\n# 该函数接受一个参数，sentence，这是一个包含多个由空格分隔的单词的字符串。\n# 每个单词仅由小写字母组成。函数返回在句子中找到的最长单词。\n# 如果有多个单词具有相同的最长长度，则返回遇到的第一个。\n#\n# 示例：\n# >>> find_longest_word(\"I am a student\")\n# \"student\"\n# >>> find_longest_word(\"The quick brown fox\")\n# \"quick\"\n\ndef find_longest_word(sentence)",
      "fr": "# Trouve le mot le plus long dans une phrase donnée.\n# La fonction prend un seul argument, sentence, qui est une chaîne contenant plusieurs mots séparés par des espaces.\n# Chaque mot est composé uniquement de lettres minuscules. La fonction renvoie le mot le plus long trouvé dans la phrase.\n# S'il y a plusieurs mots de la même longueur maximale, elle renvoie le premier rencontré.\n#\n# Exemple :\n# >>> find_longest_word(\"I am a student\")\n# \"student\"\n# >>> find_longest_word(\"The quick brown fox\")\n# \"quick\"\n\ndef find_longest_word(sentence)",
      "de": "# Findet das längste Wort in einem gegebenen Satz.\n# Die Funktion nimmt ein einzelnes Argument, sentence, das ein String ist, der mehrere durch Leerzeichen getrennte Wörter enthält.\n# Jedes Wort besteht nur aus Kleinbuchstaben. Die Funktion gibt das längste gefundene Wort im Satz zurück.\n# Wenn es mehrere Wörter mit derselben längsten Länge gibt, wird das erste gefundene zurückgegeben.\n#\n# Beispiel:\n# >>> find_longest_word(\"I am a student\")\n# \"student\"\n# >>> find_longest_word(\"The quick brown fox\")\n# \"quick\"\n\ndef find_longest_word(sentence)",
      "ha": "# Nemi kalma mafi tsawo a cikin wata jimla da aka bayar.\n# Aikin yana ɗaukar hujja guda ɗaya, sentence, wanda shi ne igiyar da ke ɗauke da kalmomi da dama da aka raba su da sarari.\n# Kowace kalma an ƙirƙira ta ne kawai da ƙananan haruffa. Aikin yana mayar da kalma mafi tsawo da aka samo a cikin jimlar.\n# Idan akwai kalmomi da yawa masu tsawon tsayi iri ɗaya, yana mayar da na farko da aka ci karo da shi.\n#\n# Misali:\n# >>> find_longest_word(\"I am a student\")\n# \"student\"\n# >>> find_longest_word(\"The quick brown fox\")\n# \"quick\"\n\ndef find_longest_word(sentence)",
      "hi": "# दिए गए वाक्य में सबसे लंबा शब्द खोजता है।\n# यह फ़ंक्शन एकल तर्क लेता है, sentence, जो एक स्ट्रिंग होती है जिसमें कई शब्द स्पेस द्वारा अलग होते हैं।\n# प्रत्येक शब्द केवल छोटे अक्षरों से बना होता है। फ़ंक्शन वाक्य में पाया गया सबसे लंबा शब्द लौटाता है।\n# यदि समान लंबाई के कई शब्द हैं, तो यह पहले मिलने वाले शब्द को लौटाता है।\n#\n# उदाहरण:\n# >>> find_longest_word(\"I am a student\")\n# \"student\"\n# >>> find_longest_word(\"The quick brown fox\")\n# \"quick\"\n\ndef find_longest_word(sentence)",
      "hu": "# Megkeresi a leghosszabb szót egy adott mondatban.\n# A függvény egyetlen argumentumot vesz fel, a sentence-t, amely egy szóközökkel elválasztott szavakat tartalmazó string.\n# Minden szó csak kisbetűkből áll. A függvény visszaadja a mondatban talált leghosszabb szót.\n# Ha több azonos hosszúságú szó van, az elsőként találtat adja vissza.\n#\n# Példa:\n# >>> find_longest_word(\"I am a student\")\n# \"student\"\n# >>> find_longest_word(\"The quick brown fox\")\n# \"quick\"\n\ndef find_longest_word(sentence)"
    },
    "prompt_bertscore": {
      "sq": "0.9850987488147627",
      "hy": "0.9821218752941928",
      "bn": "0.9772981364907606",
      "bg": "0.9837432950945806",
      "zh": "0.9713088346114156",
      "fr": "0.9920106888140148",
      "de": "0.9866440931792141",
      "ha": "0.9783383637962403",
      "hi": "0.991237619371027",
      "hu": "0.982897129671372"
    },
    "canonical_solution": "  words = sentence.split(' ')\n  longest_word = words.max_by(&:length)\n  longest_word\nend",
    "instruction": {
      "en": "Write a ruby function `def find_longest_word(sentence)` to solve the following problem:\nFinds the longest word in a given sentence.\nThe function takes a single argument, sentence, which is a string containing multiple words separated by spaces.\nEach word is composed only of lowercase letters. The function returns the longest word found in the sentence.\nIf there are multiple words of the same longest length, it returns the first one encountered.\n\nExample:\n>>> find_longest_word(\"I am a student\")\n\"student\"\n>>> find_longest_word(\"The quick brown fox\")\n\"quick\"",
      "sq": "Shkruani një funksion ruby `def find_longest_word(sentence)` për të zgjidhur problemin e mëposhtëm:\nGjen fjalën më të gjatë në një fjali të dhënë.\nFunksioni merr një argument të vetëm, sentence, i cili është një varg që përmban fjalë të shumta të ndara me hapësira.\nÇdo fjalë përbëhet vetëm nga shkronja të vogla. Funksioni kthen fjalën më të gjatë të gjetur në fjali.\nNëse ka disa fjalë me të njëjtën gjatësi më të madhe, kthen të parën që haset.\n\nShembull:\n>>> find_longest_word(\"I am a student\")\n\"student\"\n>>> find_longest_word(\"The quick brown fox\")\n\"quick\"",
      "hy": "Գրեք ruby ֆունկցիա `def find_longest_word(sentence)` հետևյալ խնդիրը լուծելու համար:\nԳտնում է ամենաերկար բառը տրված նախադասության մեջ:\nՖունկցիան ընդունում է մեկ արգումենտ, sentence, որը տող է, որը պարունակում է բազմաթիվ բառեր, որոնք բաժանված են բացատներով:\nՅուրաքանչյուր բառ կազմված է միայն փոքրատառ տառերից: Ֆունկցիան վերադարձնում է ամենաերկար բառը, որը գտնվել է նախադասության մեջ:\nԵթե կան մի քանի նույն երկարությամբ բառեր, այն վերադարձնում է առաջինը, որը հանդիպում է:\n\nՕրինակ:\n>>> find_longest_word(\"I am a student\")\n\"student\"\n>>> find_longest_word(\"The quick brown fox\")\n\"quick\"",
      "bn": "রুবি ফাংশন `def find_longest_word(sentence)` লিখুন নিম্নলিখিত সমস্যার সমাধানের জন্য:\nএকটি প্রদত্ত বাক্যে দীর্ঘতম শব্দটি খুঁজে বের করে।\nফাংশনটি একটি একক আর্গুমেন্ট গ্রহণ করে, sentence, যা একটি স্ট্রিং যেখানে একাধিক শব্দ স্পেস দ্বারা পৃথক করা থাকে।\nপ্রতিটি শব্দ শুধুমাত্র ছোট হাতের অক্ষর নিয়ে গঠিত। ফাংশনটি বাক্যে পাওয়া দীর্ঘতম শব্দটি ফেরত দেয়।\nযদি একই দীর্ঘতম দৈর্ঘ্যের একাধিক শব্দ থাকে, তবে এটি প্রথমে পাওয়া শব্দটি ফেরত দেয়।\n\nউদাহরণ:\n>>> find_longest_word(\"I am a student\")\n\"student\"\n>>> find_longest_word(\"The quick brown fox\")\n\"quick\"",
      "bg": "Напишете функция на Ruby `def find_longest_word(sentence)` за решаване на следния проблем:\nНамира най-дългата дума в дадено изречение.\nФункцията приема един аргумент, sentence, който е низ, съдържащ множество думи, разделени с интервали.\nВсяка дума се състои само от малки букви. Функцията връща най-дългата дума, намерена в изречението.\nАко има няколко думи с една и съща най-голяма дължина, тя връща първата срещната.\n\nПример:\n>>> find_longest_word(\"I am a student\")\n\"student\"\n>>> find_longest_word(\"The quick brown fox\")\n\"quick\"",
      "zh": "编写一个 ruby 函数 `def find_longest_word(sentence)` 来解决以下问题：\n在给定的句子中找到最长的单词。\n该函数接受一个参数 sentence，它是一个包含多个单词的字符串，这些单词由空格分隔。\n每个单词仅由小写字母组成。函数返回在句子中找到的最长单词。\n如果有多个单词长度相同，则返回第一个遇到的单词。\n\n示例：\n>>> find_longest_word(\"I am a student\")\n\"student\"\n>>> find_longest_word(\"The quick brown fox\")\n\"quick\"",
      "fr": "Écrire une fonction ruby `def find_longest_word(sentence)` pour résoudre le problème suivant :\nTrouve le mot le plus long dans une phrase donnée.\nLa fonction prend un seul argument, sentence, qui est une chaîne contenant plusieurs mots séparés par des espaces.\nChaque mot est composé uniquement de lettres minuscules. La fonction renvoie le mot le plus long trouvé dans la phrase.\nS'il y a plusieurs mots de la même longueur maximale, elle renvoie le premier rencontré.\n\nExemple :\n>>> find_longest_word(\"I am a student\")\n\"student\"\n>>> find_longest_word(\"The quick brown fox\")\n\"quick\"",
      "de": "Schreiben Sie eine Ruby-Funktion `def find_longest_word(sentence)`, um das folgende Problem zu lösen:\nFindet das längste Wort in einem gegebenen Satz.\nDie Funktion nimmt ein einzelnes Argument, sentence, das ein String ist, der mehrere durch Leerzeichen getrennte Wörter enthält.\nJedes Wort besteht nur aus Kleinbuchstaben. Die Funktion gibt das längste im Satz gefundene Wort zurück.\nWenn es mehrere Wörter mit derselben längsten Länge gibt, wird das zuerst gefundene zurückgegeben.\n\nBeispiel:\n>>> find_longest_word(\"I am a student\")\n\"student\"\n>>> find_longest_word(\"The quick brown fox\")\n\"quick\"",
      "ha": "Rubuta aikin ruby `def find_longest_word(sentence)` don magance matsalar mai zuwa:\nNeman kalma mafi tsawo a cikin jumla da aka bayar.\nAikin yana ɗaukar hujja guda, sentence, wanda shine igiyar da ke ɗauke da kalmomi da yawa da aka raba da sarari.\nKowane kalma an haɗa shi ne kawai da ƙananan haruffa. Aikin yana mayar da kalma mafi tsawo da aka samo a cikin jumlar.\nIdan akwai kalmomi da yawa masu tsawon iri ɗaya, yana mayar da na farko da aka haɗu da shi.\n\nMisali:\n>>> find_longest_word(\"I am a student\")\n\"student\"\n>>> find_longest_word(\"The quick brown fox\")\n\"quick\"",
      "hi": "रूबी फ़ंक्शन `def find_longest_word(sentence)` लिखें ताकि निम्नलिखित समस्या का समाधान किया जा सके:\nदिए गए वाक्य में सबसे लंबा शब्द खोजें।\nयह फ़ंक्शन एकल तर्क लेता है, sentence, जो कि एक स्ट्रिंग है जिसमें कई शब्द स्पेस द्वारा अलग किए गए होते हैं।\nप्रत्येक शब्द केवल छोटे अक्षरों से बना होता है। फ़ंक्शन वाक्य में पाया गया सबसे लंबा शब्द लौटाता है।\nयदि समान लंबाई के कई शब्द हैं, तो यह पहले मिलने वाले शब्द को लौटाता है।\n\nउदाहरण:\n>>> find_longest_word(\"I am a student\")\n\"student\"\n>>> find_longest_word(\"The quick brown fox\")\n\"quick\"",
      "hu": "Írj egy ruby függvényt `def find_longest_word(sentence)` a következő probléma megoldására:\nMegtalálja a leghosszabb szót egy adott mondatban.\nA függvény egyetlen argumentumot vesz fel, a sentence-t, amely egy szóközökkel elválasztott szavakat tartalmazó string.\nMinden szó csak kisbetűkből áll. A függvény visszaadja a mondatban talált leghosszabb szót.\nHa több azonos hosszúságú szó van, az elsőként találkozott szót adja vissza.\n\nPélda:\n>>> find_longest_word(\"I am a student\")\n\"student\"\n>>> find_longest_word(\"The quick brown fox\")\n\"quick\""
    },
    "instruction_bertscore": {
      "sq": "0.992410730401419",
      "hy": "0.977146581510031",
      "bn": "0.9804839691721792",
      "bg": "0.9794125568968769",
      "zh": "0.9664096162631901",
      "fr": "0.9907752078439778",
      "de": "0.9773718283621246",
      "ha": "0.9830727189282068",
      "hi": "0.9807292776927572",
      "hu": "0.9812979564736601"
    },
    "level": "easy",
    "test": "raise 'Test failed' unless find_longest_word(\"I am a student\") == \"student\"\nraise 'Test failed' unless find_longest_word(\"The quick brown fox jumps over the lazy dog\") == \"quick\"\nraise 'Test failed' unless find_longest_word(\"Hello world\") == \"Hello\"\nraise 'Test failed' unless find_longest_word(\"A B C D EFG HI\") == \"EFG\"\nraise 'Test failed' unless find_longest_word(\"Ruby Python Java\") == \"Python\"",
    "entry_point": "find_longest_word",
    "signature": "def find_longest_word(sentence)",
    "docstring": {
      "en": "Finds the longest word in a given sentence.\nThe function takes a single argument, sentence, which is a string containing multiple words separated by spaces.\nEach word is composed only of lowercase letters. The function returns the longest word found in the sentence.\nIf there are multiple words of the same longest length, it returns the first one encountered.\n\nExample:\n>>> find_longest_word(\"I am a student\")\n\"student\"\n>>> find_longest_word(\"The quick brown fox\")\n\"quick\"",
      "sq": "Gjen fjalën më të gjatë në një fjali të dhënë.\nFunksioni merr një argument të vetëm, fjali, i cili është një varg që përmban fjalë të shumta të ndara me hapësira.\nÇdo fjalë përbëhet vetëm nga shkronja të vogla. Funksioni kthen fjalën më të gjatë të gjetur në fjali.\nNëse ka disa fjalë me të njëjtën gjatësi më të madhe, kthen të parën e hasur.\n\nShembull:\n>>> find_longest_word(\"I am a student\")\n\"student\"\n>>> find_longest_word(\"The quick brown fox\")\n\"quick\"",
      "hy": "Գտնում է տրված նախադասության մեջ ամենաերկար բառը։ \nՖունկցիան ընդունում է մեկ արգումենտ՝ sentence, որը տող է, որը պարունակում է մի քանի բառեր, որոնք բաժանված են բացատներով։ \nՅուրաքանչյուր բառ կազմված է միայն փոքրատառ տառերից։ Ֆունկցիան վերադարձնում է նախադասության մեջ գտնված ամենաերկար բառը։ \nԵթե կան մի քանի նույն երկարությամբ բառեր, վերադարձնում է առաջինը։\n\nՕրինակ:\n>>> find_longest_word(\"I am a student\")\n\"student\"\n>>> find_longest_word(\"The quick brown fox\")\n\"quick\"",
      "bn": "একটি প্রদত্ত বাক্যে দীর্ঘতম শব্দটি খুঁজে বের করে। \nফাংশনটি একটি একক আর্গুমেন্ট গ্রহণ করে, sentence, যা একটি স্ট্রিং যা স্পেস দ্বারা পৃথক একাধিক শব্দ ধারণ করে। \nপ্রতিটি শব্দ শুধুমাত্র ছোট হাতের অক্ষর নিয়ে গঠিত। ফাংশনটি বাক্যে পাওয়া দীর্ঘতম শব্দটি ফেরত দেয়। \nযদি একই দীর্ঘতম দৈর্ঘ্যের একাধিক শব্দ থাকে, এটি প্রথমে যে শব্দটি পাওয়া যায় সেটি ফেরত দেয়।\n\nউদাহরণ:\n>>> find_longest_word(\"I am a student\")\n\"student\"\n>>> find_longest_word(\"The quick brown fox\")\n\"quick\"",
      "bg": "Намира най-дългата дума в дадено изречение.\nФункцията приема един аргумент, sentence, който е низ, съдържащ множество думи, разделени с интервали.\nВсяка дума се състои само от малки букви. Функцията връща най-дългата дума, намерена в изречението.\nАко има няколко думи с еднаква най-дълга дължина, връща първата срещната.\n\nПример:\n>>> find_longest_word(\"I am a student\")\n\"student\"\n>>> find_longest_word(\"The quick brown fox\")\n\"quick\"",
      "zh": "查找给定句子中最长的单词。\n该函数接受一个参数，sentence，这是一个包含多个用空格分隔的单词的字符串。\n每个单词仅由小写字母组成。函数返回在句子中找到的最长单词。\n如果有多个单词长度相同，则返回第一个遇到的单词。\n\n示例：\n>>> find_longest_word(\"I am a student\")\n\"student\"\n>>> find_longest_word(\"The quick brown fox\")\n\"quick\"",
      "fr": "Trouve le mot le plus long dans une phrase donnée.\nLa fonction prend un seul argument, sentence, qui est une chaîne contenant plusieurs mots séparés par des espaces.\nChaque mot est composé uniquement de lettres minuscules. La fonction renvoie le mot le plus long trouvé dans la phrase.\nS'il y a plusieurs mots de la même longueur maximale, elle renvoie le premier rencontré.\n\nExemple :\n>>> find_longest_word(\"I am a student\")\n\"student\"\n>>> find_longest_word(\"The quick brown fox\")\n\"quick\"",
      "de": "Findet das längste Wort in einem gegebenen Satz.\nDie Funktion nimmt ein einzelnes Argument, sentence, das ein String ist, der mehrere durch Leerzeichen getrennte Wörter enthält.\nJedes Wort besteht nur aus Kleinbuchstaben. Die Funktion gibt das längste im Satz gefundene Wort zurück.\nWenn es mehrere Wörter mit der gleichen längsten Länge gibt, wird das erste gefundene zurückgegeben.\n\nBeispiel:\n>>> find_longest_word(\"I am a student\")\n\"student\"\n>>> find_longest_word(\"The quick brown fox\")\n\"quick\"",
      "ha": "Yana nemo mafi tsawon kalma a cikin wata jimla da aka bayar. \n\nAikin yana ɗaukar hujja guda ɗaya, sentence, wanda yake shine igiyar rubutu mai ɗauke da kalmomi da yawa da aka raba su da sarari. \n\nKowane kalma an ƙirƙira shi ne kawai da ƙananan haruffa. Aikin yana mayar da mafi tsawon kalma da aka samo a cikin jimlar. \n\nIdan akwai kalmomi da yawa masu tsawon iri ɗaya, yana mayar da na farko da aka ci karo da shi.\n\nMisali:\n>>> find_longest_word(\"I am a student\")\n\"student\"\n>>> find_longest_word(\"The quick brown fox\")\n\"quick\"",
      "hi": "दिए गए वाक्य में सबसे लंबा शब्द खोजता है।\nयह फ़ंक्शन एकल तर्क sentence लेता है, जो एक स्ट्रिंग है जिसमें कई शब्द होते हैं जो स्पेस द्वारा अलग किए गए होते हैं।\nप्रत्येक शब्द केवल छोटे अक्षरों से बना होता है। फ़ंक्शन वाक्य में पाया गया सबसे लंबा शब्द लौटाता है।\nयदि समान सबसे लंबाई के कई शब्द हैं, तो यह पहले मिलने वाले को लौटाता है।\n\nउदाहरण:\n>>> find_longest_word(\"I am a student\")\n\"student\"\n>>> find_longest_word(\"The quick brown fox\")\n\"quick\"",
      "hu": "Megkeresi a leghosszabb szót egy adott mondatban.  \nA függvény egyetlen argumentumot vesz fel, a sentence-t, amely egy szavakat szóközökkel elválasztva tartalmazó string.  \nMinden szó csak kisbetűkből áll. A függvény visszaadja a mondatban talált leghosszabb szót.  \nHa több azonos hosszúságú szó van, az elsőként találtat adja vissza.\n\nPélda:\n>>> find_longest_word(\"I am a student\")\n\"student\"\n>>> find_longest_word(\"The quick brown fox\")\n\"quick\""
    },
    "docstring_bertscore": {
      "sq": "0.9799581945535798",
      "hy": "0.9709471286875511",
      "bn": "0.9813903196008413",
      "bg": "0.9822213891150913",
      "zh": "0.958723216408283",
      "fr": "0.9847962347444466",
      "de": "0.983677349808077",
      "ha": "0.9876664437504007",
      "hi": "0.9863086064656462",
      "hu": "0.9794193103298321"
    }
  },
  {
    "task_id": "Ruby/29",
    "prompt": {
      "en": "# Decrypts a message encrypted with Caesar's cipher.\n# The cipher shifts each letter in the message 5 positions to the right in the alphabet.\n# Non-letter characters are left unchanged. All letters are in uppercase.\n#\n# Example:\n# >>> decrypt_caesar_cipher('NS BFW, JAJSYX TK NRUTWYFSHJ FWJ YMJ WJXZQY TK YWNANFQ HFZXJX')\n# 'IN WAR, EVENTS OF IMPORTANCE ARE THE RESULT OF TRIVIAL CAUSES'\n# >>> decrypt_caesar_cipher('N BTZQI WFYMJW GJ KNWXY NS F QNYYQJ NGJWNFS ANQQFLJ YMFS XJHTSI NS WTRJ')\n# 'I WOULD RATHER BE FIRST IN A LITTLE IBERIAN VILLAGE THAN SECOND IN ROME'\n\ndef decrypt_caesar_cipher(message)",
      "sq": "# Dekripton një mesazh të enkriptuar me shifrën e Cezarit.\n# Shifra zhvendos secilën shkronjë në mesazh 5 pozicione djathtas në alfabet.\n# Karakteret që nuk janë shkronja mbeten të pandryshuara. Të gjitha shkronjat janë me shkronja të mëdha.\n#\n# Shembull:\n# >>> decrypt_caesar_cipher('NS BFW, JAJSYX TK NRUTWYFSHJ FWJ YMJ WJXZQY TK YWNANFQ HFZXJX')\n# 'IN WAR, EVENTS OF IMPORTANCE ARE THE RESULT OF TRIVIAL CAUSES'\n# >>> decrypt_caesar_cipher('N BTZQI WFYMJW GJ KNWXY NS F QNYYQJ NGJWNFS ANQQFLJ YMFS XJHTSI NS WTRJ')\n# 'I WOULD RATHER BE FIRST IN A LITTLE IBERIAN VILLAGE THAN SECOND IN ROME'\n\ndef decrypt_caesar_cipher(message)",
      "hy": "# Վերծանում է Կեսարի ծածկագրով կոդավորված հաղորդագրությունը։\n# Ծածկագիրը յուրաքանչյուր տառը հաղորդագրության մեջ տեղափոխում է 5 դիրքով դեպի աջ այբուբենում։\n# Ոչ տառային նշանները մնում են անփոփոխ։ Բոլոր տառերը մեծատառ են։\n#\n# Օրինակ:\n# >>> decrypt_caesar_cipher('NS BFW, JAJSYX TK NRUTWYFSHJ FWJ YMJ WJXZQY TK YWNANFQ HFZXJX')\n# 'IN WAR, EVENTS OF IMPORTANCE ARE THE RESULT OF TRIVIAL CAUSES'\n# >>> decrypt_caesar_cipher('N BTZQI WFYMJW GJ KNWXY NS F QNYYQJ NGJWNFS ANQQFLJ YMFS XJHTSI NS WTRJ')\n# 'I WOULD RATHER BE FIRST IN A LITTLE IBERIAN VILLAGE THAN SECOND IN ROME'\n\ndef decrypt_caesar_cipher(message)",
      "bn": "# একটি বার্তা ডিক্রিপ্ট করে যা সিজারের সাইফার দিয়ে এনক্রিপ্ট করা হয়েছে।\n# সাইফার প্রতিটি অক্ষরকে বার্তায় বর্ণমালায় ৫টি অবস্থান ডান দিকে সরিয়ে দেয়।\n# অক্ষর ব্যতীত অন্যান্য চরিত্র অপরিবর্তিত থাকে। সমস্ত অক্ষর বড় হাতের।\n#\n# উদাহরণ:\n# >>> decrypt_caesar_cipher('NS BFW, JAJSYX TK NRUTWYFSHJ FWJ YMJ WJXZQY TK YWNANFQ HFZXJX')\n# 'IN WAR, EVENTS OF IMPORTANCE ARE THE RESULT OF TRIVIAL CAUSES'\n# >>> decrypt_caesar_cipher('N BTZQI WFYMJW GJ KNWXY NS F QNYYQJ NGJWNFS ANQQFLJ YMFS XJHTSI NS WTRJ')\n# 'I WOULD RATHER BE FIRST IN A LITTLE IBERIAN VILLAGE THAN SECOND IN ROME'\n\ndef decrypt_caesar_cipher(message)",
      "bg": "# Декриптира съобщение, криптирано с шифъра на Цезар.\n# Шифърът измества всяка буква в съобщението с 5 позиции надясно в азбуката.\n# Символите, които не са букви, остават непроменени. Всички букви са с главни букви.\n#\n# Пример:\n# >>> decrypt_caesar_cipher('NS BFW, JAJSYX TK NRUTWYFSHJ FWJ YMJ WJXZQY TK YWNANFQ HFZXJX')\n# 'IN WAR, EVENTS OF IMPORTANCE ARE THE RESULT OF TRIVIAL CAUSES'\n# >>> decrypt_caesar_cipher('N BTZQI WFYMJW GJ KNWXY NS F QNYYQJ NGJWNFS ANQQFLJ YMFS XJHTSI NS WTRJ')\n# 'I WOULD RATHER BE FIRST IN A LITTLE IBERIAN VILLAGE THAN SECOND IN ROME'\n\ndef decrypt_caesar_cipher(message)",
      "zh": "# 解密使用凯撒密码加密的信息。\n# 密码将消息中的每个字母在字母表中向右移动5个位置。\n# 非字母字符保持不变。所有字母均为大写。\n#\n# 示例:\n# >>> decrypt_caesar_cipher('NS BFW, JAJSYX TK NRUTWYFSHJ FWJ YMJ WJXZQY TK YWNANFQ HFZXJX')\n# 'IN WAR, EVENTS OF IMPORTANCE ARE THE RESULT OF TRIVIAL CAUSES'\n# >>> decrypt_caesar_cipher('N BTZQI WFYMJW GJ KNWXY NS F QNYYQJ NGJWNFS ANQQFLJ YMFS XJHTSI NS WTRJ')\n# 'I WOULD RATHER BE FIRST IN A LITTLE IBERIAN VILLAGE THAN SECOND IN ROME'\n\ndef decrypt_caesar_cipher(message)",
      "fr": "# Décrypte un message chiffré avec le chiffre de César.\n# Le chiffre déplace chaque lettre du message de 5 positions vers la droite dans l'alphabet.\n# Les caractères non alphabétiques restent inchangés. Toutes les lettres sont en majuscules.\n#\n# Exemple:\n# >>> decrypt_caesar_cipher('NS BFW, JAJSYX TK NRUTWYFSHJ FWJ YMJ WJXZQY TK YWNANFQ HFZXJX')\n# 'IN WAR, EVENTS OF IMPORTANCE ARE THE RESULT OF TRIVIAL CAUSES'\n# >>> decrypt_caesar_cipher('N BTZQI WFYMJW GJ KNWXY NS F QNYYQJ NGJWNFS ANQQFLJ YMFS XJHTSI NS WTRJ')\n# 'I WOULD RATHER BE FIRST IN A LITTLE IBERIAN VILLAGE THAN SECOND IN ROME'\n\ndef decrypt_caesar_cipher(message)",
      "de": "# Entschlüsselt eine mit dem Caesar-Verschlüsselung verschlüsselte Nachricht.\n# Der Verschlüsselung verschiebt jeden Buchstaben in der Nachricht um 5 Positionen nach rechts im Alphabet.\n# Nicht-Buchstaben-Zeichen bleiben unverändert. Alle Buchstaben sind in Großbuchstaben.\n#\n# Beispiel:\n# >>> decrypt_caesar_cipher('NS BFW, JAJSYX TK NRUTWYFSHJ FWJ YMJ WJXZQY TK YWNANFQ HFZXJX')\n# 'IN WAR, EVENTS OF IMPORTANCE ARE THE RESULT OF TRIVIAL CAUSES'\n# >>> decrypt_caesar_cipher('N BTZQI WFYMJW GJ KNWXY NS F QNYYQJ NGJWNFS ANQQFLJ YMFS XJHTSI NS WTRJ')\n# 'I WOULD RATHER BE FIRST IN A LITTLE IBERIAN VILLAGE THAN SECOND IN ROME'\n\ndef decrypt_caesar_cipher(message)",
      "ha": "# Yana warware saƙo da aka ɓoye tare da sifirin Caesar.\n# Sifirin yana matsar da kowace harafi a cikin saƙon matsayi 5 zuwa dama a cikin haruffan.\n# Haruffa marasa harafi ba a canza su ba. Duk haruffa suna cikin manyan baƙaƙe.\n#\n# Misali:\n# >>> decrypt_caesar_cipher('NS BFW, JAJSYX TK NRUTWYFSHJ FWJ YMJ WJXZQY TK YWNANFQ HFZXJX')\n# 'IN WAR, EVENTS OF IMPORTANCE ARE THE RESULT OF TRIVIAL CAUSES'\n# >>> decrypt_caesar_cipher('N BTZQI WFYMJW GJ KNWXY NS F QNYYQJ NGJWNFS ANQQFLJ YMFS XJHTSI NS WTRJ')\n# 'I WOULD RATHER BE FIRST IN A LITTLE IBERIAN VILLAGE THAN SECOND IN ROME'\n\ndef decrypt_caesar_cipher(message)",
      "hi": "# एक संदेश को डिक्रिप्ट करता है जो सीज़र के सिफर के साथ एन्क्रिप्ट किया गया है।\n# सिफर संदेश में प्रत्येक अक्षर को वर्णमाला में 5 स्थान दाईं ओर स्थानांतरित करता है।\n# गैर-अक्षर वर्ण अपरिवर्तित रहते हैं। सभी अक्षर बड़े अक्षरों में हैं।\n#\n# उदाहरण:\n# >>> decrypt_caesar_cipher('NS BFW, JAJSYX TK NRUTWYFSHJ FWJ YMJ WJXZQY TK YWNANFQ HFZXJX')\n# 'IN WAR, EVENTS OF IMPORTANCE ARE THE RESULT OF TRIVIAL CAUSES'\n# >>> decrypt_caesar_cipher('N BTZQI WFYMJW GJ KNWXY NS F QNYYQJ NGJWNFS ANQQFLJ YMFS XJHTSI NS WTRJ')\n# 'I WOULD RATHER BE FIRST IN A LITTLE IBERIAN VILLAGE THAN SECOND IN ROME'\n\ndef decrypt_caesar_cipher(message)",
      "hu": "# Dekódol egy Caesar-rejtjelzéssel titkosított üzenetet.\n# A rejtjel minden betűt 5 pozícióval jobbra tol az ábécében.\n# A nem betű karakterek változatlanok maradnak. Minden betű nagybetűs.\n#\n# Példa:\n# >>> decrypt_caesar_cipher('NS BFW, JAJSYX TK NRUTWYFSHJ FWJ YMJ WJXZQY TK YWNANFQ HFZXJX')\n# 'IN WAR, EVENTS OF IMPORTANCE ARE THE RESULT OF TRIVIAL CAUSES'\n# >>> decrypt_caesar_cipher('N BTZQI WFYMJW GJ KNWXY NS F QNYYQJ NGJWNFS ANQQFLJ YMFS XJHTSI NS WTRJ')\n# 'I WOULD RATHER BE FIRST IN A LITTLE IBERIAN VILLAGE THAN SECOND IN ROME'\n\ndef decrypt_caesar_cipher(message)"
    },
    "prompt_bertscore": {
      "sq": "0.9876094368310436",
      "hy": "0.9769986018761599",
      "bn": "0.9865459697709829",
      "bg": "0.988607753126125",
      "zh": "0.9707063886657368",
      "fr": "0.9909925094808298",
      "de": "0.9923247234464309",
      "ha": "0.9885980202374544",
      "hi": "0.9826450677178387",
      "hu": "0.9669040072815859"
    },
    "canonical_solution": "    message.chars.map do |char|\n      if char.match?(/[A-Z]/)\n        ((char.ord - 'A'.ord - 5) % 26 + 'A'.ord).chr\n      else\n        char\n      end\n    end.join\n  end",
    "instruction": {
      "en": "Write a ruby function `def decrypt_caesar_cipher(message)` to solve the following problem:\nDecrypts a message encrypted with Caesar's cipher.\nThe cipher shifts each letter in the message 5 positions to the right in the alphabet.\nNon-letter characters are left unchanged. All letters are in uppercase.\n\nExample:\n>>> decrypt_caesar_cipher('NS BFW, JAJSYX TK NRUTWYFSHJ FWJ YMJ WJXZQY TK YWNANFQ HFZXJX')\n'IN WAR, EVENTS OF IMPORTANCE ARE THE RESULT OF TRIVIAL CAUSES'\n>>> decrypt_caesar_cipher('N BTZQI WFYMJW GJ KNWXY NS F QNYYQJ NGJWNFS ANQQFLJ YMFS XJHTSI NS WTRJ')\n'I WOULD RATHER BE FIRST IN A LITTLE IBERIAN VILLAGE THAN SECOND IN ROME'",
      "sq": "Shkruani një funksion ruby `def decrypt_caesar_cipher(message)` për të zgjidhur problemin e mëposhtëm:\nDekriptimi i një mesazhi të koduar me shifrën e Cezarit.\nShifra zhvendos secilën shkronjë në mesazh 5 pozicione djathtas në alfabet.\nKarakteret që nuk janë shkronja mbeten të pandryshuara. Të gjitha shkronjat janë me shkronja të mëdha.\n\nShembull:\n>>> decrypt_caesar_cipher('NS BFW, JAJSYX TK NRUTWYFSHJ FWJ YMJ WJXZQY TK YWNANFQ HFZXJX')\n'IN WAR, EVENTS OF IMPORTANCE ARE THE RESULT OF TRIVIAL CAUSES'\n>>> decrypt_caesar_cipher('N BTZQI WFYMJW GJ KNWXY NS F QNYYQJ NGJWNFS ANQQFLJ YMFS XJHTSI NS WTRJ')\n'I WOULD RATHER BE FIRST IN A LITTLE IBERIAN VILLAGE THAN SECOND IN ROME'",
      "hy": "Գրեք ruby ֆունկցիա `def decrypt_caesar_cipher(message)` հետևյալ խնդիրը լուծելու համար:\nՎերծանում է հաղորդագրությունը, որը ծածկագրված է Կեսարի ծածկագրով:\nԾածկագիրը յուրաքանչյուր տառը հաղորդագրության մեջ տեղափոխում է 5 դիրքով աջ այբուբենում:\nՈչ տառային նիշերը մնում են անփոփոխ: Բոլոր տառերը մեծատառ են:\n\nՕրինակ:\n>>> decrypt_caesar_cipher('NS BFW, JAJSYX TK NRUTWYFSHJ FWJ YMJ WJXZQY TK YWNANFQ HFZXJX')\n'IN WAR, EVENTS OF IMPORTANCE ARE THE RESULT OF TRIVIAL CAUSES'\n>>> decrypt_caesar_cipher('N BTZQI WFYMJW GJ KNWXY NS F QNYYQJ NGJWNFS ANQQFLJ YMFS XJHTSI NS WTRJ')\n'I WOULD RATHER BE FIRST IN A LITTLE IBERIAN VILLAGE THAN SECOND IN ROME'",
      "bn": "রুবি ফাংশন `def decrypt_caesar_cipher(message)` লিখুন নিম্নলিখিত সমস্যার সমাধানের জন্য:\nকাইসারের সাইফার দিয়ে এনক্রিপ্ট করা একটি বার্তা ডিক্রিপ্ট করে।\nসাইফার বার্তায় প্রতিটি অক্ষরকে বর্ণমালায় ৫ অবস্থান ডানদিকে সরিয়ে দেয়।\nঅক্ষর ব্যতীত অন্যান্য অক্ষর অপরিবর্তিত থাকে। সমস্ত অক্ষর বড় হাতের।\n\nউদাহরণ:\n>>> decrypt_caesar_cipher('NS BFW, JAJSYX TK NRUTWYFSHJ FWJ YMJ WJXZQY TK YWNANFQ HFZXJX')\n'IN WAR, EVENTS OF IMPORTANCE ARE THE RESULT OF TRIVIAL CAUSES'\n>>> decrypt_caesar_cipher('N BTZQI WFYMJW GJ KNWXY NS F QNYYQJ NGJWNFS ANQQFLJ YMFS XJHTSI NS WTRJ')\n'I WOULD RATHER BE FIRST IN A LITTLE IBERIAN VILLAGE THAN SECOND IN ROME'",
      "bg": "Напишете функция на Ruby `def decrypt_caesar_cipher(message)`, за да решите следния проблем:\nДекриптира съобщение, криптирано с шифъра на Цезар.\nШифърът измества всяка буква в съобщението с 5 позиции надясно в азбуката.\nНекнижните символи остават непроменени. Всички букви са с главни букви.\n\nПример:\n>>> decrypt_caesar_cipher('NS BFW, JAJSYX TK NRUTWYFSHJ FWJ YMJ WJXZQY TK YWNANFQ HFZXJX')\n'IN WAR, EVENTS OF IMPORTANCE ARE THE RESULT OF TRIVIAL CAUSES'\n>>> decrypt_caesar_cipher('N BTZQI WFYMJW GJ KNWXY NS F QNYYQJ NGJWNFS ANQQFLJ YMFS XJHTSI NS WTRJ')\n'I WOULD RATHER BE FIRST IN A LITTLE IBERIAN VILLAGE THAN SECOND IN ROME'",
      "zh": "编写一个 ruby 函数 `def decrypt_caesar_cipher(message)` 来解决以下问题：\n解密使用凯撒密码加密的消息。\n密码将消息中的每个字母在字母表中向右移动 5 个位置。\n非字母字符保持不变。所有字母均为大写。\n\n示例：\n>>> decrypt_caesar_cipher('NS BFW, JAJSYX TK NRUTWYFSHJ FWJ YMJ WJXZQY TK YWNANFQ HFZXJX')\n'IN WAR, EVENTS OF IMPORTANCE ARE THE RESULT OF TRIVIAL CAUSES'\n>>> decrypt_caesar_cipher('N BTZQI WFYMJW GJ KNWXY NS F QNYYQJ NGJWNFS ANQQFLJ YMFS XJHTSI NS WTRJ')\n'I WOULD RATHER BE FIRST IN A LITTLE IBERIAN VILLAGE THAN SECOND IN ROME'",
      "fr": "Écrire une fonction ruby `def decrypt_caesar_cipher(message)` pour résoudre le problème suivant :\nDécrypte un message chiffré avec le chiffre de César.\nLe chiffre décale chaque lettre du message de 5 positions vers la droite dans l'alphabet.\nLes caractères non alphabétiques restent inchangés. Toutes les lettres sont en majuscules.\n\nExemple :\n>>> decrypt_caesar_cipher('NS BFW, JAJSYX TK NRUTWYFSHJ FWJ YMJ WJXZQY TK YWNANFQ HFZXJX')\n'IN WAR, EVENTS OF IMPORTANCE ARE THE RESULT OF TRIVIAL CAUSES'\n>>> decrypt_caesar_cipher('N BTZQI WFYMJW GJ KNWXY NS F QNYYQJ NGJWNFS ANQQFLJ YMFS XJHTSI NS WTRJ')\n'I WOULD RATHER BE FIRST IN A LITTLE IBERIAN VILLAGE THAN SECOND IN ROME'",
      "de": "Schreiben Sie eine Ruby-Funktion `def decrypt_caesar_cipher(message)`, um das folgende Problem zu lösen:\nEntschlüsselt eine mit dem Caesar-Verschlüsselung verschlüsselte Nachricht.\nDie Verschlüsselung verschiebt jeden Buchstaben in der Nachricht um 5 Positionen nach rechts im Alphabet.\nNicht-Buchstaben-Zeichen bleiben unverändert. Alle Buchstaben sind in Großbuchstaben.\n\nBeispiel:\n>>> decrypt_caesar_cipher('NS BFW, JAJSYX TK NRUTWYFSHJ FWJ YMJ WJXZQY TK YWNANFQ HFZXJX')\n'IN WAR, EVENTS OF IMPORTANCE ARE THE RESULT OF TRIVIAL CAUSES'\n>>> decrypt_caesar_cipher('N BTZQI WFYMJW GJ KNWXY NS F QNYYQJ NGJWNFS ANQQFLJ YMFS XJHTSI NS WTRJ')\n'I WOULD RATHER BE FIRST IN A LITTLE IBERIAN VILLAGE THAN SECOND IN ROME'",
      "ha": "Rubuta aikin ruby `def decrypt_caesar_cipher(message)` don warware matsalar mai zuwa:  \nFassara saƙo da aka ɓoye tare da sifirin Caesar.  \nSifirin yana matsar da kowane harafi a cikin saƙon matsayi 5 zuwa dama a cikin haruffa.  \nHaruffa marasa haruffa ba a canza su ba. Duk haruffa suna cikin manyan baƙaƙe.\n\nMisali:\n>>> decrypt_caesar_cipher('NS BFW, JAJSYX TK NRUTWYFSHJ FWJ YMJ WJXZQY TK YWNANFQ HFZXJX')\n'IN WAR, EVENTS OF IMPORTANCE ARE THE RESULT OF TRIVIAL CAUSES'\n>>> decrypt_caesar_cipher('N BTZQI WFYMJW GJ KNWXY NS F QNYYQJ NGJWNFS ANQQFLJ YMFS XJHTSI NS WTRJ')\n'I WOULD RATHER BE FIRST IN A LITTLE IBERIAN VILLAGE THAN SECOND IN ROME'",
      "hi": "रूबी फ़ंक्शन `def decrypt_caesar_cipher(message)` लिखें ताकि निम्नलिखित समस्या का समाधान किया जा सके:\nएक संदेश को डिक्रिप्ट करता है जो सीज़र के सिफर के साथ एन्क्रिप्ट किया गया है।\nसिफर संदेश में प्रत्येक अक्षर को वर्णमाला में 5 स्थान दाईं ओर स्थानांतरित करता है।\nगैर-अक्षर वर्ण अपरिवर्तित रहते हैं। सभी अक्षर बड़े अक्षरों में हैं।\n\nउदाहरण:\n>>> decrypt_caesar_cipher('NS BFW, JAJSYX TK NRUTWYFSHJ FWJ YMJ WJXZQY TK YWNANFQ HFZXJX')\n'IN WAR, EVENTS OF IMPORTANCE ARE THE RESULT OF TRIVIAL CAUSES'\n>>> decrypt_caesar_cipher('N BTZQI WFYMJW GJ KNWXY NS F QNYYQJ NGJWNFS ANQQFLJ YMFS XJHTSI NS WTRJ')\n'I WOULD RATHER BE FIRST IN A LITTLE IBERIAN VILLAGE THAN SECOND IN ROME'",
      "hu": "Írj egy ruby függvényt `def decrypt_caesar_cipher(message)` a következő probléma megoldására:\nDekódol egy üzenetet, amelyet Caesar-rejtjel titkosítottak.\nA rejtjel az üzenet minden betűjét 5 pozícióval jobbra tolja az ábécében.\nA nem betűs karakterek változatlanok maradnak. Minden betű nagybetűs.\n\nPélda:\n>>> decrypt_caesar_cipher('NS BFW, JAJSYX TK NRUTWYFSHJ FWJ YMJ WJXZQY TK YWNANFQ HFZXJX')\n'IN WAR, EVENTS OF IMPORTANCE ARE THE RESULT OF TRIVIAL CAUSES'\n>>> decrypt_caesar_cipher('N BTZQI WFYMJW GJ KNWXY NS F QNYYQJ NGJWNFS ANQQFLJ YMFS XJHTSI NS WTRJ')\n'I WOULD RATHER BE FIRST IN A LITTLE IBERIAN VILLAGE THAN SECOND IN ROME'"
    },
    "instruction_bertscore": {
      "sq": "0.9855498384100929",
      "hy": "0.9917198939361797",
      "bn": "0.974459906976153",
      "bg": "0.9775031230439886",
      "zh": "0.9800573111137162",
      "fr": "0.9858366606803073",
      "de": "0.991659311669964",
      "ha": "0.9840054871975467",
      "hi": "0.9820968478661825",
      "hu": "0.9864075243954016"
    },
    "level": "easy",
    "test": "raise 'Test failed' unless decrypt_caesar_cipher('NS BFW, JAJSYX TK NRUTWYFSHJ FWJ YMJ WJXZQY TK YWNANFQ HFZXJX') == 'IN WAR, EVENTS OF IMPORTANCE ARE THE RESULT OF TRIVIAL CAUSES'\nraise 'Test failed' unless decrypt_caesar_cipher('N BTZQI WFYMJW GJ KNWXY NS F QNYYQJ NGJWNFS ANQQFLJ YMFS XJHTSI NS WTRJ') == 'I WOULD RATHER BE FIRST IN A LITTLE IBERIAN VILLAGE THAN SECOND IN ROME'\nraise 'Test failed' unless decrypt_caesar_cipher('IFSLJW PSTBX KZQQ BJQQ YMFY HFJXFW NX RTWJ IFSLJWTZX YMFS MJ') == 'DANGER KNOWS FULL WELL THAT CAESAR IS MORE DANGEROUS THAN HE'\nraise 'Test failed' unless decrypt_caesar_cipher('ABCDEF') == 'VWXYZA'\nraise 'Test failed' unless decrypt_caesar_cipher('XYZ') == 'STU'\n\n  \n\n\nputs 'All tests passed!'",
    "entry_point": "decrypt_caesar_cipher",
    "signature": "def decrypt_caesar_cipher(message)",
    "docstring": {
      "en": "Decrypts a message encrypted with Caesar's cipher.\nThe cipher shifts each letter in the message 5 positions to the right in the alphabet.\nNon-letter characters are left unchanged. All letters are in uppercase.\n\nExample:\n>>> decrypt_caesar_cipher('NS BFW, JAJSYX TK NRUTWYFSHJ FWJ YMJ WJXZQY TK YWNANFQ HFZXJX')\n'IN WAR, EVENTS OF IMPORTANCE ARE THE RESULT OF TRIVIAL CAUSES'\n>>> decrypt_caesar_cipher('N BTZQI WFYMJW GJ KNWXY NS F QNYYQJ NGJWNFS ANQQFLJ YMFS XJHTSI NS WTRJ')\n'I WOULD RATHER BE FIRST IN A LITTLE IBERIAN VILLAGE THAN SECOND IN ROME'",
      "sq": "Dekripton një mesazh të koduar me shifrën e Cezarit. Shifra zhvendos secilën shkronjë në mesazh 5 pozicione djathtas në alfabet. Karakteret që nuk janë shkronja mbeten të pandryshuara. Të gjitha shkronjat janë me shkronja të mëdha.\n\nShembull:\n>>> decrypt_caesar_cipher('NS BFW, JAJSYX TK NRUTWYFSHJ FWJ YMJ WJXZQY TK YWNANFQ HFZXJX')\n'IN WAR, EVENTS OF IMPORTANCE ARE THE RESULT OF TRIVIAL CAUSES'\n>>> decrypt_caesar_cipher('N BTZQI WFYMJW GJ KNWXY NS F QNYYQJ NGJWNFS ANQQFLJ YMFS XJHTSI NS WTRJ')\n'I WOULD RATHER BE FIRST IN A LITTLE IBERIAN VILLAGE THAN SECOND IN ROME'",
      "hy": "Վերծանում է Կեսարի գաղտնագրով կոդավորված հաղորդագրությունը։\nԳաղտնագիրը յուրաքանչյուր տառը հաղորդագրության մեջ տեղափոխում է 5 դիրքով դեպի աջ այբուբենում։  \nՈչ տառային նիշերը մնում են անփոփոխ։ Բոլոր տառերը մեծատառ են։\n\nՕրինակ՝\n>>> decrypt_caesar_cipher('NS BFW, JAJSYX TK NRUTWYFSHJ FWJ YMJ WJXZQY TK YWNANFQ HFZXJX')\n'IN WAR, EVENTS OF IMPORTANCE ARE THE RESULT OF TRIVIAL CAUSES'\n>>> decrypt_caesar_cipher('N BTZQI WFYMJW GJ KNWXY NS F QNYYQJ NGJWNFS ANQQFLJ YMFS XJHTSI NS WTRJ')\n'I WOULD RATHER BE FIRST IN A LITTLE IBERIAN VILLAGE THAN SECOND IN ROME'",
      "bn": "Caesar এর সাইফার দিয়ে এনক্রিপ্ট করা একটি বার্তা ডিক্রিপ্ট করে। \nসাইফারটি বার্তার প্রতিটি অক্ষরকে বর্ণমালায় ৫টি অবস্থান ডানদিকে সরিয়ে দেয়। \nঅক্ষর ছাড়া অন্যান্য অক্ষর অপরিবর্তিত থাকে। সমস্ত অক্ষর বড় হাতের।\n\nউদাহরণ:\n>>> decrypt_caesar_cipher('NS BFW, JAJSYX TK NRUTWYFSHJ FWJ YMJ WJXZQY TK YWNANFQ HFZXJX')\n'IN WAR, EVENTS OF IMPORTANCE ARE THE RESULT OF TRIVIAL CAUSES'\n>>> decrypt_caesar_cipher('N BTZQI WFYMJW GJ KNWXY NS F QNYYQJ NGJWNFS ANQQFLJ YMFS XJHTSI NS WTRJ')\n'I WOULD RATHER BE FIRST IN A LITTLE IBERIAN VILLAGE THAN SECOND IN ROME'",
      "bg": "Декриптира съобщение, криптирано с шифъра на Цезар.\nШифърът измества всяка буква в съобщението с 5 позиции надясно в азбуката. \nСимволите, които не са букви, остават непроменени. Всички букви са с главни букви.\n\nПример:\n>>> decrypt_caesar_cipher('NS BFW, JAJSYX TK NRUTWYFSHJ FWJ YMJ WJXZQY TK YWNANFQ HFZXJX')\n'IN WAR, EVENTS OF IMPORTANCE ARE THE RESULT OF TRIVIAL CAUSES'\n>>> decrypt_caesar_cipher('N BTZQI WFYMJW GJ KNWXY NS F QNYYQJ NGJWNFS ANQQFLJ YMFS XJHTSI NS WTRJ')\n'I WOULD RATHER BE FIRST IN A LITTLE IBERIAN VILLAGE THAN SECOND IN ROME'",
      "zh": "解密使用凯撒密码加密的消息。\n该密码将消息中的每个字母在字母表中向右移动5个位置。\n非字母字符保持不变。所有字母均为大写。\n\n示例：\n>>> decrypt_caesar_cipher('NS BFW, JAJSYX TK NRUTWYFSHJ FWJ YMJ WJXZQY TK YWNANFQ HFZXJX')\n'IN WAR, EVENTS OF IMPORTANCE ARE THE RESULT OF TRIVIAL CAUSES'\n>>> decrypt_caesar_cipher('N BTZQI WFYMJW GJ KNWXY NS F QNYYQJ NGJWNFS ANQQFLJ YMFS XJHTSI NS WTRJ')\n'I WOULD RATHER BE FIRST IN A LITTLE IBERIAN VILLAGE THAN SECOND IN ROME'",
      "fr": "Décrypte un message chiffré avec le chiffre de César.\nLe chiffre déplace chaque lettre du message de 5 positions vers la droite dans l'alphabet.  \nLes caractères non alphabétiques restent inchangés. Toutes les lettres sont en majuscules.\n\nExemple :\n>>> decrypt_caesar_cipher('NS BFW, JAJSYX TK NRUTWYFSHJ FWJ YMJ WJXZQY TK YWNANFQ HFZXJX')\n'IN WAR, EVENTS OF IMPORTANCE ARE THE RESULT OF TRIVIAL CAUSES'\n>>> decrypt_caesar_cipher('N BTZQI WFYMJW GJ KNWXY NS F QNYYQJ NGJWNFS ANQQFLJ YMFS XJHTSI NS WTRJ')\n'I WOULD RATHER BE FIRST IN A LITTLE IBERIAN VILLAGE THAN SECOND IN ROME'",
      "de": "Entschlüsselt eine mit dem Caesar-Verschlüsselung verschlüsselte Nachricht.\nDer Verschlüsselungsalgorithmus verschiebt jeden Buchstaben in der Nachricht um 5 Positionen nach rechts im Alphabet.  \nNicht-Buchstaben-Zeichen bleiben unverändert. Alle Buchstaben sind in Großbuchstaben.\n\nBeispiel:\n>>> decrypt_caesar_cipher('NS BFW, JAJSYX TK NRUTWYFSHJ FWJ YMJ WJXZQY TK YWNANFQ HFZXJX')\n'IN WAR, EVENTS OF IMPORTANCE ARE THE RESULT OF TRIVIAL CAUSES'\n>>> decrypt_caesar_cipher('N BTZQI WFYMJW GJ KNWXY NS F QNYYQJ NGJWNFS ANQQFLJ YMFS XJHTSI NS WTRJ')\n'I WOULD RATHER BE FIRST IN A LITTLE IBERIAN VILLAGE THAN SECOND IN ROME'",
      "ha": "Yana warware saƙo da aka ɓoye tare da sifirin Caesar.\nLambar yana matsar da kowace harafi a cikin saƙon matsayi 5 zuwa dama a cikin haruffa.  \nHaruffa marasa haruffa ba a canza su ba. Duk haruffa suna cikin manyan baƙaƙe.\n\nMisali:\n>>> decrypt_caesar_cipher('NS BFW, JAJSYX TK NRUTWYFSHJ FWJ YMJ WJXZQY TK YWNANFQ HFZXJX')\n'IN WAR, EVENTS OF IMPORTANCE ARE THE RESULT OF TRIVIAL CAUSES'\n>>> decrypt_caesar_cipher('N BTZQI WFYMJW GJ KNWXY NS F QNYYQJ NGJWNFS ANQQFLJ YMFS XJHTSI NS WTRJ')\n'I WOULD RATHER BE FIRST IN A LITTLE IBERIAN VILLAGE THAN SECOND IN ROME'",
      "hi": "संदेश को डिक्रिप्ट करता है जो सीज़र के सिफर के साथ एन्क्रिप्ट किया गया है।\nसिफर संदेश में प्रत्येक अक्षर को वर्णमाला में 5 स्थान दाईं ओर स्थानांतरित करता है।\nगैर-अक्षर वर्ण अपरिवर्तित रहते हैं। सभी अक्षर बड़े अक्षरों में हैं।\nउदाहरण:  \n\n>>> decrypt_caesar_cipher('NS BFW, JAJSYX TK NRUTWYFSHJ FWJ YMJ WJXZQY TK YWNANFQ HFZXJX')  \n'IN WAR, EVENTS OF IMPORTANCE ARE THE RESULT OF TRIVIAL CAUSES'  \n\n>>> decrypt_caesar_cipher('N BTZQI WFYMJW GJ KNWXY NS F QNYYQJ NGJWNFS ANQQFLJ YMFS XJHTSI NS WTRJ')  \n'I WOULD RATHER BE FIRST IN A LITTLE IBERIAN VILLAGE THAN SECOND IN ROME'",
      "hu": "Dekódol egy Caesar-rejtjel segítségével titkosított üzenetet.  \nA rejtjel minden betűt 5 pozícióval jobbra tol az ábécében.  \nA nem betű karakterek változatlanok maradnak. Minden betű nagybetűs.\n\nPélda:\n>>> decrypt_caesar_cipher('NS BFW, JAJSYX TK NRUTWYFSHJ FWJ YMJ WJXZQY TK YWNANFQ HFZXJX')\n'IN WAR, EVENTS OF IMPORTANCE ARE THE RESULT OF TRIVIAL CAUSES'\n>>> decrypt_caesar_cipher('N BTZQI WFYMJW GJ KNWXY NS F QNYYQJ NGJWNFS ANQQFLJ YMFS XJHTSI NS WTRJ')\n'I WOULD RATHER BE FIRST IN A LITTLE IBERIAN VILLAGE THAN SECOND IN ROME'"
    },
    "docstring_bertscore": {
      "sq": "0.9842486107839333",
      "hy": "0.9742592902913078",
      "bn": "0.9754745109624793",
      "bg": "0.9867074562707643",
      "zh": "0.9770202525876928",
      "fr": "0.9901135700447505",
      "de": "0.9922279904508668",
      "ha": "0.9923565043073964",
      "hi": "0.9012304471392587",
      "hu": "0.9639982434374265"
    }
  },
  {
    "task_id": "Ruby/30",
    "prompt": {
      "en": "# Calculates the number of possible photo arrangements for a group of people.\n# In this arrangement, people are lined up in such a way that the age difference\n# between any two adjacent persons is no more than two years.\n# The function takes a single integer argument, n, representing the number of people\n# in the group, where each person has a distinct age from 1 to n years.\n#\n# Example:\n# >>> photo_arrangements_count(4)\n# 4\n# >>> photo_arrangements_count(5)\n# 6\n\ndef photo_arrangements_count(n)",
      "sq": "# Llogarit numrin e mundshëm të rregullimeve të fotografive për një grup njerëzish.\n# Në këtë rregullim, njerëzit janë rreshtuar në një mënyrë të tillë që diferenca e moshës\n# midis çdo dy personave ngjitur nuk është më shumë se dy vjet.\n# Funksioni merr një argument të vetëm të tipit integer, n, që përfaqëson numrin e njerëzve\n# në grup, ku secili person ka një moshë të veçantë nga 1 deri në n vjet.\n#\n# Shembull:\n# >>> photo_arrangements_count(4)\n# 4\n# >>> photo_arrangements_count(5)\n# 6\n\ndef photo_arrangements_count(n)",
      "hy": "# Հաշվում է լուսանկարների հնարավոր դասավորությունների քանակը մարդկանց խմբի համար։\n# Այս դասավորության մեջ մարդիկ շարունակում են այնպես, որ\n# ցանկացած երկու հարակից անձանց միջև տարիքային տարբերությունը ոչ ավելի է, քան երկու տարի։\n# Ֆունկցիան ընդունում է մեկ ամբողջ թիվ արգումենտ, n, որը ներկայացնում է խմբի մարդկանց քանակը,\n# որտեղ յուրաքանչյուր անձ ունի տարբեր տարիք 1-ից մինչև n տարիների միջև։\n#\n# Օրինակ:\n# >>> photo_arrangements_count(4)\n# 4\n# >>> photo_arrangements_count(5)\n# 6\n\ndef photo_arrangements_count(n)",
      "bn": "# মানুষের একটি দলের জন্য সম্ভাব্য ছবি বিন্যাসের সংখ্যা গণনা করে।\n# এই বিন্যাসে, মানুষ এমনভাবে সারিবদ্ধ থাকে যে যে কোনও দুটি সংলগ্ন ব্যক্তির\n# মধ্যে বয়সের পার্থক্য দুই বছরের বেশি নয়।\n# ফাংশনটি একটি একক পূর্ণসংখ্যা আর্গুমেন্ট গ্রহণ করে, n, যা দলে মানুষের সংখ্যা\n# উপস্থাপন করে, যেখানে প্রতিটি ব্যক্তির বয়স 1 থেকে n বছরের মধ্যে পৃথক।\n#\n# উদাহরণ:\n# >>> photo_arrangements_count(4)\n# 4\n# >>> photo_arrangements_count(5)\n# 6\n\ndef photo_arrangements_count(n)",
      "bg": "# Изчислява броя на възможните подредби за снимка за група хора.\n# В тази подредба хората са подредени така, че възрастовата разлика\n# между всеки двама съседни души да не е повече от две години.\n# Функцията приема един аргумент, n, представляващ броя на хората\n# в групата, където всеки човек има различна възраст от 1 до n години.\n#\n# Пример:\n# >>> photo_arrangements_count(4)\n# 4\n# >>> photo_arrangements_count(5)\n# 6\n\ndef photo_arrangements_count(n)",
      "zh": "# 计算一组人的可能照片排列数量。\n# 在这种排列中，人们排列的方式是任何两个相邻的人之间的年龄差不超过两岁。\n# 该函数接受一个整数参数 n，表示组中人的数量，其中每个人的年龄从 1 到 n 岁各不相同。\n#\n# 示例:\n# >>> photo_arrangements_count(4)\n# 4\n# >>> photo_arrangements_count(5)\n# 6\n\ndef photo_arrangements_count(n)",
      "fr": "# Calcule le nombre de dispositions possibles de photos pour un groupe de personnes.\n# Dans cette disposition, les personnes sont alignées de telle sorte que la différence d'âge\n# entre deux personnes adjacentes ne dépasse pas deux ans.\n# La fonction prend un seul argument entier, n, représentant le nombre de personnes\n# dans le groupe, où chaque personne a un âge distinct de 1 à n ans.\n#\n# Exemple:\n# >>> photo_arrangements_count(4)\n# 4\n# >>> photo_arrangements_count(5)\n# 6\n\ndef photo_arrangements_count(n)",
      "de": "# Berechnet die Anzahl der möglichen Fotoanordnungen für eine Gruppe von Personen.\n# In dieser Anordnung stehen die Personen so in einer Reihe, dass der Altersunterschied\n# zwischen zwei benachbarten Personen nicht mehr als zwei Jahre beträgt.\n# Die Funktion nimmt ein einzelnes ganzzahliges Argument n, das die Anzahl der Personen\n# in der Gruppe darstellt, wobei jede Person ein unterschiedliches Alter von 1 bis n Jahren hat.\n#\n# Beispiel:\n# >>> photo_arrangements_count(4)\n# 4\n# >>> photo_arrangements_count(5)\n# 6\n\ndef photo_arrangements_count(n)",
      "ha": "# Lissafa yawan yiwuwar jere hotuna don wata ƙungiya ta mutane.\n# A cikin wannan jeren, mutane suna tsaye a layi ta yadda bambancin shekaru\n# tsakanin kowane mutum biyu masu makwabtaka ba ya wuce shekaru biyu.\n# Aikin yana ɗaukar hujja guda ɗaya ta integer, n, wanda ke wakiltar yawan mutanen\n# a cikin ƙungiyar, inda kowane mutum yana da shekaru daban-daban daga 1 zuwa n.\n#\n# Misali:\n# >>> photo_arrangements_count(4)\n# 4\n# >>> photo_arrangements_count(5)\n# 6\n\ndef photo_arrangements_count(n)",
      "hi": "# एक समूह के लोगों के लिए संभावित फोटो व्यवस्थाओं की संख्या की गणना करता है।\n# इस व्यवस्था में, लोग इस तरह से पंक्तिबद्ध होते हैं कि किसी भी दो आसन्न व्यक्तियों के बीच\n# आयु का अंतर दो वर्षों से अधिक नहीं होता है।\n# यह फ़ंक्शन एकल पूर्णांक तर्क n लेता है, जो समूह में लोगों की संख्या का प्रतिनिधित्व करता है,\n# जहाँ प्रत्येक व्यक्ति की आयु 1 से n वर्षों तक भिन्न होती है।\n#\n# उदाहरण:\n# >>> photo_arrangements_count(4)\n# 4\n# >>> photo_arrangements_count(5)\n# 6\n\ndef photo_arrangements_count(n)",
      "hu": "# Kiszámítja a lehetséges fénykép-elrendezések számát egy csoport ember számára.\n# Ebben az elrendezésben az emberek úgy vannak felsorakoztatva, hogy bármely két\n# szomszédos személy közötti korkülönbség legfeljebb két év.\n# A függvény egyetlen egész szám argumentumot vesz fel, n-t, amely a csoportban\n# lévő emberek számát jelenti, ahol minden személy életkora 1-től n évig különböző.\n#\n# Példa:\n# >>> photo_arrangements_count(4)\n# 4\n# >>> photo_arrangements_count(5)\n# 6\n\ndef photo_arrangements_count(n)"
    },
    "prompt_bertscore": {
      "sq": "0.9796650161111723",
      "hy": "0.977448698319585",
      "bn": "0.9757706688606023",
      "bg": "0.9612867401059193",
      "zh": "0.949488095472447",
      "fr": "0.974009810532728",
      "de": "0.9681754403505902",
      "ha": "0.9490395880720701",
      "hi": "0.968578858654472",
      "hu": "0.967764275461848"
    },
    "canonical_solution": "    # Array to store the count of arrangements for each number up to N\n    arrangements = [1, 1, 2] # Base cases: N=1, N=2, and N=3\n  \n    # Calculating arrangements for N > 3\n    (3...n).each do |i|\n      arrangements[i] = arrangements[i - 1] + arrangements[i - 3] + 1\n    end\n  \n    arrangements[n - 1]\n  end",
    "instruction": {
      "en": "Write a ruby function `def photo_arrangements_count(n)` to solve the following problem:\nCalculates the number of possible photo arrangements for a group of people.\nIn this arrangement, people are lined up in such a way that the age difference\nbetween any two adjacent persons is no more than two years.\nThe function takes a single integer argument, n, representing the number of people\nin the group, where each person has a distinct age from 1 to n years.\n\nExample:\n>>> photo_arrangements_count(4)\n4\n>>> photo_arrangements_count(5)\n6",
      "sq": "Shkruani një funksion në ruby `def photo_arrangements_count(n)` për të zgjidhur problemin e mëposhtëm:\nLlogarit numrin e mundshëm të rregullimeve të fotografive për një grup njerëzish.\nNë këtë rregullim, njerëzit janë rreshtuar në një mënyrë të tillë që diferenca e moshës\nmidis çdo dy personave ngjitur nuk është më shumë se dy vjet.\nFunksioni merr një argument të vetëm integer, n, që përfaqëson numrin e njerëzve\nnë grup, ku secili person ka një moshë të veçantë nga 1 deri në n vjet.\n\nShembull:\n>>> photo_arrangements_count(4)\n4\n>>> photo_arrangements_count(5)\n6",
      "hy": "Գրեք ruby ֆունկցիա `def photo_arrangements_count(n)` հետևյալ խնդիրը լուծելու համար:\nՀաշվում է մարդկանց խմբի համար հնարավոր լուսանկարների դասավորությունների քանակը:\nԱյս դասավորության մեջ մարդիկ շարունակում են այնպես, որ ցանկացած երկու հարակից անձանց միջև տարիքային տարբերությունը չի գերազանցում երկու տարին:\nՖունկցիան ընդունում է մեկ ամբողջ թիվ արգումենտ, n, որը ներկայացնում է խմբի մարդկանց քանակը, որտեղ յուրաքանչյուր անձ ունի 1-ից n տարի տարբեր տարիք:\n\nՕրինակ:\n>>> photo_arrangements_count(4)\n4\n>>> photo_arrangements_count(5)\n6",
      "bn": "রুবি ফাংশন `def photo_arrangements_count(n)` লিখুন নিম্নলিখিত সমস্যার সমাধানের জন্য:\nএকটি দলের লোকজনের জন্য সম্ভাব্য ফটো বিন্যাসের সংখ্যা গণনা করে।\nএই বিন্যাসে, লোকজন এমনভাবে সারিবদ্ধ হয় যে যে কোনো দুটি সংলগ্ন ব্যক্তির মধ্যে বয়সের পার্থক্য দুই বছরের বেশি নয়।\nফাংশনটি একটি একক পূর্ণসংখ্যা আর্গুমেন্ট গ্রহণ করে, n, যা দলের লোকজনের সংখ্যা উপস্থাপন করে, যেখানে প্রতিটি ব্যক্তির বয়স 1 থেকে n বছরের মধ্যে ভিন্ন।\n\nউদাহরণ:\n>>> photo_arrangements_count(4)\n4\n>>> photo_arrangements_count(5)\n6",
      "bg": "Напишете Ruby функция `def photo_arrangements_count(n)` за решаване на следния проблем:\nИзчислява броя на възможните подреждания за снимка на група хора.\nВ това подреждане хората са подредени по такъв начин, че разликата във възрастта\nмежду всеки двама съседни души да не е повече от две години.\nФункцията приема един цял аргумент, n, представляващ броя на хората\nв групата, където всеки човек има различна възраст от 1 до n години.\n\nПример:\n>>> photo_arrangements_count(4)\n4\n>>> photo_arrangements_count(5)\n6",
      "zh": "编写一个 ruby 函数 `def photo_arrangements_count(n)` 来解决以下问题：\n计算一组人可能的照片排列数量。\n在这种排列中，人们排成一行，使得任何两个相邻的人之间的年龄差不超过两岁。\n该函数接受一个整数参数 n，表示组中人的数量，其中每个人的年龄从 1 到 n 岁不等。\n\n示例：\n>>> photo_arrangements_count(4)\n4\n>>> photo_arrangements_count(5)\n6",
      "fr": "Écrire une fonction ruby `def photo_arrangements_count(n)` pour résoudre le problème suivant :\nCalcule le nombre de dispositions possibles pour une photo d'un groupe de personnes.\nDans cette disposition, les personnes sont alignées de telle manière que la différence d'âge\nentre deux personnes adjacentes ne dépasse pas deux ans.\nLa fonction prend un seul argument entier, n, représentant le nombre de personnes\ndans le groupe, où chaque personne a un âge distinct de 1 à n ans.\n\nExemple :\n>>> photo_arrangements_count(4)\n4\n>>> photo_arrangements_count(5)\n6",
      "de": "Schreiben Sie eine Ruby-Funktion `def photo_arrangements_count(n)`, um das folgende Problem zu lösen:\nBerechnet die Anzahl der möglichen Fotoanordnungen für eine Gruppe von Personen.\nIn dieser Anordnung stehen die Personen so in einer Reihe, dass der Altersunterschied\nzwischen zwei benachbarten Personen nicht mehr als zwei Jahre beträgt.\nDie Funktion nimmt ein einzelnes ganzzahliges Argument n, das die Anzahl der Personen\nin der Gruppe darstellt, wobei jede Person ein unterschiedliches Alter von 1 bis n Jahren hat.\n\nBeispiel:\n>>> photo_arrangements_count(4)\n4\n>>> photo_arrangements_count(5)\n6",
      "ha": "Rubuta aikin ruby `def photo_arrangements_count(n)` don warware matsalar mai zuwa:\nLissafa adadin yiwuwar tsarukan daukar hoto ga wani rukuni na mutane.\nA cikin wannan tsari, an jera mutane ta yadda bambancin shekaru\ntsakanin kowanne mutum biyu makwabta ba ya wuce shekaru biyu.\nAikin yana daukar hujja guda daya, n, wanda ke wakiltar adadin mutane\na cikin rukunin, inda kowane mutum yana da shekaru daban-daban daga 1 zuwa n.\n\nMisali:\n>>> photo_arrangements_count(4)\n4\n>>> photo_arrangements_count(5)\n6",
      "hi": "रूबी फ़ंक्शन `def photo_arrangements_count(n)` लिखें ताकि निम्नलिखित समस्या का समाधान हो सके:\nलोगों के समूह के लिए संभावित फोटो व्यवस्थाओं की संख्या की गणना करता है।\nइस व्यवस्था में, लोग इस तरह से पंक्तिबद्ध होते हैं कि किसी भी दो आसन्न व्यक्तियों के बीच आयु का अंतर दो वर्ष से अधिक नहीं होता।\nयह फ़ंक्शन एकल पूर्णांक तर्क n लेता है, जो समूह में लोगों की संख्या का प्रतिनिधित्व करता है, जहाँ प्रत्येक व्यक्ति की आयु 1 से n वर्षों तक भिन्न होती है।\n\nउदाहरण:\n>>> photo_arrangements_count(4)\n4\n>>> photo_arrangements_count(5)\n6",
      "hu": "Készíts egy ruby függvényt `def photo_arrangements_count(n)` a következő probléma megoldására:\nKiszámítja a lehetséges fényképelrendezések számát egy csoport ember számára.\nEbben az elrendezésben az emberek úgy vannak sorba állítva, hogy a szomszédos személyek közötti\néletkorkülönbség legfeljebb két év.\nA függvény egyetlen egész szám argumentumot vesz fel, n, amely a csoportban lévő emberek számát jelenti,\nahol minden személy életkora különbözik, 1-től n évig.\n\nPélda:\n>>> photo_arrangements_count(4)\n4\n>>> photo_arrangements_count(5)\n6"
    },
    "instruction_bertscore": {
      "sq": "0.9866697164983677",
      "hy": "0.9716308144590732",
      "bn": "0.9748255855076383",
      "bg": "0.9764940807083313",
      "zh": "0.9679229811362948",
      "fr": "0.9813482099600619",
      "de": "0.9655394165638762",
      "ha": "0.965157251710765",
      "hi": "0.9807241133028504",
      "hu": "0.9547498142660611"
    },
    "level": "middle",
    "test": "  \nraise 'Test failed' unless photo_arrangements_count(4) == 4\nraise 'Test failed' unless photo_arrangements_count(5) == 6\nraise 'Test failed' unless photo_arrangements_count(6) == 9\nraise 'Test failed' unless photo_arrangements_count(7) == 14\nraise 'Test failed' unless photo_arrangements_count(8) == 21\n  \n\nputs 'All tests passed!'",
    "entry_point": "photo_arrangements_count",
    "signature": "def photo_arrangements_count(n)",
    "docstring": {
      "en": "Calculates the number of possible photo arrangements for a group of people.\nIn this arrangement, people are lined up in such a way that the age difference\nbetween any two adjacent persons is no more than two years.\nThe function takes a single integer argument, n, representing the number of people\nin the group, where each person has a distinct age from 1 to n years.\n\nExample:\n>>> photo_arrangements_count(4)\n4\n>>> photo_arrangements_count(5)\n6",
      "sq": "Llogarit numrin e mundshëm të rregullimeve të fotografive për një grup njerëzish. Në këtë rregullim, njerëzit janë rreshtuar në një mënyrë të tillë që diferenca e moshës midis çdo dy personave ngjitur të mos jetë më shumë se dy vjet. Funksioni merr një argument të vetëm të tipit integer, n, që përfaqëson numrin e njerëzve në grup, ku secili person ka një moshë të dallueshme nga 1 deri në n vjet.\n\nShembull:\n>>> photo_arrangements_count(4)\n4\n>>> photo_arrangements_count(5)\n6",
      "hy": "Հաշվում է մարդկանց խմբի համար հնարավոր լուսանկարների դասավորությունների քանակը։  \nԱյս դասավորության մեջ մարդիկ շարունակում են այնպես, որ ցանկացած երկու հարակից անձանց միջև տարիքային տարբերությունը  \nչգերազանցի երկու տարին։  \nՖունկցիան ընդունում է մեկ ամբողջ թիվ արգումենտ՝ n, որը ներկայացնում է խմբի մարդկանց քանակը,  \nորտեղ յուրաքանչյուր անձ ունի տարբեր տարիքը՝ 1-ից մինչև n տարի։\n\nՕրինակ՝  \n>>> photo_arrangements_count(4)  \n4  \n>>> photo_arrangements_count(5)  \n6",
      "bn": "লোকেদের একটি দলের জন্য সম্ভাব্য ফটো বিন্যাসের সংখ্যা গণনা করে।\nএই বিন্যাসে, লোকেরা এমনভাবে সারিবদ্ধ থাকে যাতে যে কোনও দুটি সংলগ্ন ব্যক্তির মধ্যে বয়সের পার্থক্য দুই বছরের বেশি না হয়।\nফাংশনটি একটি একক পূর্ণসংখ্যা আর্গুমেন্ট, n, গ্রহণ করে, যা দলে লোকেদের সংখ্যা উপস্থাপন করে, যেখানে প্রতিটি ব্যক্তির বয়স 1 থেকে n বছরের মধ্যে পৃথক।\n\nউদাহরণ:\n>>> photo_arrangements_count(4)\n4\n>>> photo_arrangements_count(5)\n6",
      "bg": "Изчислява броя на възможните подредби за снимка за група от хора. В тази подредба хората са подредени по такъв начин, че разликата във възрастта между всеки двама съседни човека е не повече от две години. Функцията приема един аргумент от тип цяло число, n, представляващ броя на хората в групата, където всеки човек има различна възраст от 1 до n години.\n\nПример:\n>>> photo_arrangements_count(4)\n4\n>>> photo_arrangements_count(5)\n6",
      "zh": "计算一组人的可能照片排列数量。\n在这种排列中，人们排列成一行，使得任何两个相邻人的年龄差不超过两岁。\n该函数接受一个整数参数 n，表示组中人的数量，其中每个人的年龄从 1 到 n 岁不等。\n\n示例：\n>>> photo_arrangements_count(4)\n4\n>>> photo_arrangements_count(5)\n6",
      "fr": "Calcule le nombre de dispositions possibles de photos pour un groupe de personnes.\nDans cet arrangement, les personnes sont alignées de telle manière que la différence d'âge\nentre deux personnes adjacentes ne dépasse pas deux ans.\nLa fonction prend un seul argument entier, n, représentant le nombre de personnes\ndans le groupe, où chaque personne a un âge distinct de 1 à n ans.\n\nExemple :\n>>> photo_arrangements_count(4)\n4\n>>> photo_arrangements_count(5)\n6",
      "de": "Berechnet die Anzahl der möglichen Fotoanordnungen für eine Gruppe von Personen. In dieser Anordnung stehen die Personen so in einer Reihe, dass der Altersunterschied zwischen zwei benachbarten Personen nicht mehr als zwei Jahre beträgt. Die Funktion nimmt ein einzelnes ganzzahliges Argument, n, das die Anzahl der Personen in der Gruppe darstellt, wobei jede Person ein unterschiedliches Alter von 1 bis n Jahren hat.\n\nBeispiel:\n>>> photo_arrangements_count(4)\n4\n>>> photo_arrangements_count(5)\n6",
      "ha": "Yana ƙididdige yawan yiwuwar tsararrun hotuna don wata ƙungiyar mutane.  \nA cikin wannan tsari, mutane suna jere a cikin hanya inda bambancin shekaru  \ntsakanin kowane mutum biyu masu makwabtaka ba ya wuce shekaru biyu.  \nAikin yana ɗaukar hujja guda ɗaya, n, wanda ke wakiltar yawan mutane  \na cikin ƙungiyar, inda kowane mutum yana da shekaru daban-daban daga 1 zuwa n shekaru.\n\nMisali:\n>>> photo_arrangements_count(4)\n4\n>>> photo_arrangements_count(5)\n6",
      "hi": "लोगों के एक समूह के लिए संभावित फोटो व्यवस्थाओं की संख्या की गणना करता है। इस व्यवस्था में, लोग इस तरह से पंक्तिबद्ध होते हैं कि किसी भी दो आसन्न व्यक्तियों के बीच आयु का अंतर दो वर्षों से अधिक नहीं होता है। यह फ़ंक्शन एक एकल पूर्णांक तर्क n लेता है, जो समूह में लोगों की संख्या का प्रतिनिधित्व करता है, जहाँ प्रत्येक व्यक्ति की आयु 1 से n वर्षों तक भिन्न होती है।\n\nउदाहरण:\n>>> photo_arrangements_count(4)\n4\n>>> photo_arrangements_count(5)\n6",
      "hu": "Számítja a lehetséges fényképelrendezések számát egy csoport ember számára. Ebben az elrendezésben az emberek úgy vannak sorba állítva, hogy bármely két szomszédos személy közötti korkülönbség legfeljebb két év. A függvény egyetlen egész szám argumentumot vesz fel, n-t, amely a csoportban lévő emberek számát jelenti, ahol minden személynek különböző életkora van 1-től n évig.\n\nPélda:\n>>> photo_arrangements_count(4)\n4\n>>> photo_arrangements_count(5)\n6"
    },
    "docstring_bertscore": {
      "sq": "0.9893516239031007",
      "hy": "0.9688813727247882",
      "bn": "0.9767101905628973",
      "bg": "0.9650976625964546",
      "zh": "0.9613957881851074",
      "fr": "0.9760092239482252",
      "de": "0.9648902924786542",
      "ha": "0.9491575745184049",
      "hi": "0.9779959250193361",
      "hu": "0.9713098277633208"
    }
  },
  {
    "task_id": "Ruby/31",
    "prompt": {
      "en": "# Converts a numerical score into a corresponding letter grade based on predefined ranges.\n# The function takes a single argument, score, which is an integer representing the score.\n# It returns a string representing the letter grade, or an error message for invalid scores.\n#\n# Grade Conversion:\n# 90-100: 'A'\n# 80-89: 'B'\n# 70-79: 'C'\n# 60-69: 'D'\n# 0-59: 'E'\n# Any other score: 'Score is error!'\n#\n# Examples:\n# >>> convert_score_to_grade(56)\n# 'E'\n# >>> convert_score_to_grade(100)\n# 'A'\n# >>> convert_score_to_grade(123)\n# 'Score is error!'\n\ndef convert_score_to_grade(score)",
      "sq": "# Konverton një rezultat numerik në një notë përkatëse me shkronja bazuar në intervalet e paracaktuara.\n# Funksioni merr një argument të vetëm, score, i cili është një numër i plotë që përfaqëson rezultatin.\n# Kthen një varg që përfaqëson notën me shkronja, ose një mesazh gabimi për rezultatet e pavlefshme.\n#\n# Konvertimi i Notës:\n# 90-100: 'A'\n# 80-89: 'B'\n# 70-79: 'C'\n# 60-69: 'D'\n# 0-59: 'E'\n# Çdo rezultat tjetër: 'Score is error!'\n#\n# Shembuj:\n# >>> convert_score_to_grade(56)\n# 'E'\n# >>> convert_score_to_grade(100)\n# 'A'\n# >>> convert_score_to_grade(123)\n# 'Score is error!'\n\ndef convert_score_to_grade(score)",
      "hy": "# Վերածում է թվային գնահատականը համապատասխան տառային գնահատականի՝ հիմնված նախապես սահմանված միջակայքերի վրա։\n# Ֆունկցիան ընդունում է մեկ արգումենտ՝ score, որը ամբողջ թիվ է՝ ներկայացնող գնահատականը։\n# Այն վերադարձնում է տող, որը ներկայացնում է տառային գնահատականը, կամ սխալի հաղորդագրություն՝ անվավեր գնահատականների համար։\n#\n# Գնահատականի փոխարկում:\n# 90-100: 'A'\n# 80-89: 'B'\n# 70-79: 'C'\n# 60-69: 'D'\n# 0-59: 'E'\n# Ցանկացած այլ գնահատական: 'Գնահատականը սխալ է!'\n#\n# Օրինակներ:\n# >>> convert_score_to_grade(56)\n# 'E'\n# >>> convert_score_to_grade(100)\n# 'A'\n# >>> convert_score_to_grade(123)\n# 'Գնահատականը սխալ է!'",
      "bn": "# একটি সংখ্যাসূচক স্কোরকে পূর্বনির্ধারিত সীমার উপর ভিত্তি করে একটি সংশ্লিষ্ট অক্ষর গ্রেডে রূপান্তর করে।\n# ফাংশনটি একটি একক আর্গুমেন্ট নেয়, score, যা স্কোরকে উপস্থাপনকারী একটি পূর্ণসংখ্যা।\n# এটি একটি স্ট্রিং ফেরত দেয় যা অক্ষর গ্রেড উপস্থাপন করে, অথবা অবৈধ স্কোরের জন্য একটি ত্রুটি বার্তা।\n#\n# গ্রেড রূপান্তর:\n# 90-100: 'A'\n# 80-89: 'B'\n# 70-79: 'C'\n# 60-69: 'D'\n# 0-59: 'E'\n# অন্য যেকোনো স্কোর: 'Score is error!'\n#\n# উদাহরণ:\n# >>> convert_score_to_grade(56)\n# 'E'\n# >>> convert_score_to_grade(100)\n# 'A'\n# >>> convert_score_to_grade(123)\n# 'Score is error!'\n\ndef convert_score_to_grade(score)",
      "bg": "# Преобразува числова оценка в съответстваща буквена оценка въз основа на предварително определени диапазони.\n# Функцията приема един аргумент, score, който е цяло число, представляващо оценката.\n# Връща низ, представляващ буквена оценка, или съобщение за грешка при невалидни оценки.\n#\n# Преобразуване на оценка:\n# 90-100: 'A'\n# 80-89: 'B'\n# 70-79: 'C'\n# 60-69: 'D'\n# 0-59: 'E'\n# Всяка друга оценка: 'Score is error!'\n#\n# Примери:\n# >>> convert_score_to_grade(56)\n# 'E'\n# >>> convert_score_to_grade(100)\n# 'A'\n# >>> convert_score_to_grade(123)\n# 'Score is error!'\n\ndef convert_score_to_grade(score)",
      "zh": "# 将数值分数转换为基于预定义范围的相应字母等级。\n# 该函数接受一个参数，score，它是一个表示分数的整数。\n# 它返回一个表示字母等级的字符串，或者对于无效分数返回错误信息。\n#\n# 等级转换：\n# 90-100: 'A'\n# 80-89: 'B'\n# 70-79: 'C'\n# 60-69: 'D'\n# 0-59: 'E'\n# 任何其他分数: 'Score is error!'\n#\n# 示例：\n# >>> convert_score_to_grade(56)\n# 'E'\n# >>> convert_score_to_grade(100)\n# 'A'\n# >>> convert_score_to_grade(123)\n# 'Score is error!'",
      "fr": "# Convertit un score numérique en une note correspondante basée sur des plages prédéfinies.\n# La fonction prend un seul argument, score, qui est un entier représentant le score.\n# Elle renvoie une chaîne de caractères représentant la note, ou un message d'erreur pour les scores invalides.\n#\n# Conversion des notes :\n# 90-100 : 'A'\n# 80-89 : 'B'\n# 70-79 : 'C'\n# 60-69 : 'D'\n# 0-59 : 'E'\n# Tout autre score : 'Score is error!'\n#\n# Exemples :\n# >>> convert_score_to_grade(56)\n# 'E'\n# >>> convert_score_to_grade(100)\n# 'A'\n# >>> convert_score_to_grade(123)\n# 'Score is error!'\n\ndef convert_score_to_grade(score)",
      "de": "# Wandelt eine numerische Punktzahl in eine entsprechende Buchstabennote basierend auf vordefinierten Bereichen um.\n# Die Funktion nimmt ein einziges Argument, score, das ein ganzzahliger Wert ist, der die Punktzahl darstellt.\n# Sie gibt einen String zurück, der die Buchstabennote darstellt, oder eine Fehlermeldung für ungültige Punktzahlen.\n#\n# Notenumwandlung:\n# 90-100: 'A'\n# 80-89: 'B'\n# 70-79: 'C'\n# 60-69: 'D'\n# 0-59: 'E'\n# Jede andere Punktzahl: 'Score is error!'\n#\n# Beispiele:\n# >>> convert_score_to_grade(56)\n# 'E'\n# >>> convert_score_to_grade(100)\n# 'A'\n# >>> convert_score_to_grade(123)\n# 'Score is error!'\n\ndef convert_score_to_grade(score)",
      "ha": "# Yana canza maki na lambobi zuwa harafin daraja mai dacewa bisa ga kewayon da aka riga aka ayyana.\n# Aikin yana daukar hujja guda daya, score, wanda yake wakiltar maki.\n# Yana mayar da kirtani wanda yake wakiltar harafin daraja, ko kuma sako na kuskure ga maki marasa inganci.\n#\n# Canjin Daraja:\n# 90-100: 'A'\n# 80-89: 'B'\n# 70-79: 'C'\n# 60-69: 'D'\n# 0-59: 'E'\n# Duk wani maki daban: 'Score is error!'\n#\n# Misalai:\n# >>> convert_score_to_grade(56)\n# 'E'\n# >>> convert_score_to_grade(100)\n# 'A'\n# >>> convert_score_to_grade(123)\n# 'Score is error!'\n\ndef convert_score_to_grade(score)",
      "hi": "# एक संख्यात्मक स्कोर को पूर्वनिर्धारित श्रेणियों के आधार पर एक संबंधित अक्षर ग्रेड में परिवर्तित करता है।\n# फ़ंक्शन एक एकल तर्क लेता है, score, जो स्कोर का प्रतिनिधित्व करने वाला एक पूर्णांक है।\n# यह एक स्ट्रिंग लौटाता है जो अक्षर ग्रेड का प्रतिनिधित्व करता है, या अमान्य स्कोर के लिए एक त्रुटि संदेश।\n#\n# ग्रेड रूपांतरण:\n# 90-100: 'A'\n# 80-89: 'B'\n# 70-79: 'C'\n# 60-69: 'D'\n# 0-59: 'E'\n# कोई अन्य स्कोर: 'Score is error!'\n#\n# उदाहरण:\n# >>> convert_score_to_grade(56)\n# 'E'\n# >>> convert_score_to_grade(100)\n# 'A'\n# >>> convert_score_to_grade(123)\n# 'Score is error!'\n\ndef convert_score_to_grade(score)",
      "hu": "# Egy numerikus pontszámot alakít át a megfelelő betűjeggyé előre meghatározott tartományok alapján.\n# A függvény egyetlen argumentumot vesz fel, score, amely egy egész számot képvisel.\n# Egy karakterláncot ad vissza, amely a betűjegyet képviseli, vagy egy hibaüzenetet érvénytelen pontszámok esetén.\n#\n# Jegy átváltás:\n# 90-100: 'A'\n# 80-89: 'B'\n# 70-79: 'C'\n# 60-69: 'D'\n# 0-59: 'E'\n# Bármely más pontszám: 'Score is error!'\n#\n# Példák:\n# >>> convert_score_to_grade(56)\n# 'E'\n# >>> convert_score_to_grade(100)\n# 'A'\n# >>> convert_score_to_grade(123)\n# 'Score is error!'\n\ndef convert_score_to_grade(score)"
    },
    "prompt_bertscore": {
      "sq": "0.996897393448235",
      "hy": "0.9701456551000752",
      "bn": "0.9899322205068657",
      "bg": "0.9911738590187148",
      "zh": "0.9624860703466079",
      "fr": "0.9832258629519848",
      "de": "0.9959497279003175",
      "ha": "0.9813841620590292",
      "hi": "0.9914982224309448",
      "hu": "0.9812328057086807"
    },
    "canonical_solution": "    return 'Score is error!' if score < 0 || score > 100\n  \n    case score\n    when 90..100\n      'A'\n    when 80...90\n      'B'\n    when 70...80\n      'C'\n    when 60...70\n      'D'\n    when 0...60\n      'E'\n    else\n      'Score is error!'\n    end\n  end",
    "instruction": {
      "en": "Write a ruby function `def convert_score_to_grade(score)` to solve the following problem:\nConverts a numerical score into a corresponding letter grade based on predefined ranges.\nThe function takes a single argument, score, which is an integer representing the score.\nIt returns a string representing the letter grade, or an error message for invalid scores.\n\nGrade Conversion:\n90-100: 'A'\n80-89: 'B'\n70-79: 'C'\n60-69: 'D'\n0-59: 'E'\nAny other score: 'Score is error!'\n\nExamples:\n>>> convert_score_to_grade(56)\n'E'\n>>> convert_score_to_grade(100)\n'A'\n>>> convert_score_to_grade(123)\n'Score is error!'",
      "sq": "Shkruani një funksion ruby `def convert_score_to_grade(score)` për të zgjidhur problemin në vijim:\nKonverton një rezultat numerik në një notë përkatëse me shkronjë bazuar në intervalet e paracaktuara.\nFunksioni merr një argument të vetëm, score, i cili është një numër i plotë që përfaqëson rezultatin.\nKthen një varg që përfaqëson notën me shkronjë, ose një mesazh gabimi për rezultatet e pavlefshme.\n\nKonvertimi i Notës:\n90-100: 'A'\n80-89: 'B'\n70-79: 'C'\n60-69: 'D'\n0-59: 'E'\nÇdo rezultat tjetër: 'Score is error!'\n\nShembuj:\n>>> convert_score_to_grade(56)\n'E'\n>>> convert_score_to_grade(100)\n'A'\n>>> convert_score_to_grade(123)\n'Score is error!'",
      "hy": "Գրեք ruby ֆունկցիա `def convert_score_to_grade(score)` հետևյալ խնդիրը լուծելու համար:\nՎերածում է թվային գնահատականը համապատասխան տառային գնահատականի՝ հիմնված նախապես սահմանված միջակայքերի վրա։\nՖունկցիան ընդունում է մեկ արգումենտ՝ score, որը ամբողջ թիվ է, ներկայացնող գնահատականը։\nԱյն վերադարձնում է տող, որը ներկայացնում է տառային գնահատականը, կամ սխալի հաղորդագրություն՝ սխալ գնահատականների համար։\n\nԳնահատականների վերածում:\n90-100: 'A'\n80-89: 'B'\n70-79: 'C'\n60-69: 'D'\n0-59: 'E'\nՑանկացած այլ գնահատական: 'Score is error!'\n\nՕրինակներ:\n>>> convert_score_to_grade(56)\n'E'\n>>> convert_score_to_grade(100)\n'A'\n>>> convert_score_to_grade(123)\n'Score is error!'",
      "bn": "একটি রুবি ফাংশন `def convert_score_to_grade(score)` লিখুন নিম্নলিখিত সমস্যার সমাধানের জন্য:\nএকটি সংখ্যাসূচক স্কোরকে পূর্বনির্ধারিত সীমার উপর ভিত্তি করে একটি সংশ্লিষ্ট অক্ষর গ্রেডে রূপান্তর করে।\nফাংশনটি একটি একক আর্গুমেন্ট গ্রহণ করে, score, যা স্কোরের প্রতিনিধিত্বকারী একটি পূর্ণসংখ্যা।\nএটি একটি স্ট্রিং ফেরত দেয় যা অক্ষর গ্রেডের প্রতিনিধিত্ব করে, অথবা অবৈধ স্কোরের জন্য একটি ত্রুটি বার্তা।\n\nগ্রেড রূপান্তর:\n90-100: 'A'\n80-89: 'B'\n70-79: 'C'\n60-69: 'D'\n0-59: 'E'\nঅন্যান্য যেকোনো স্কোর: 'Score is error!'\n\nউদাহরণ:\n>>> convert_score_to_grade(56)\n'E'\n>>> convert_score_to_grade(100)\n'A'\n>>> convert_score_to_grade(123)\n'Score is error!'",
      "bg": "Напишете функция на Ruby `def convert_score_to_grade(score)` за решаване на следния проблем:\nПреобразува числова оценка в съответстваща буквена оценка въз основа на предварително определени диапазони.\nФункцията приема един аргумент, score, който е цяло число, представляващо оценката.\nВръща низ, представляващ буквена оценка, или съобщение за грешка за невалидни оценки.\n\nПреобразуване на оценките:\n90-100: 'A'\n80-89: 'B'\n70-79: 'C'\n60-69: 'D'\n0-59: 'E'\nВсяка друга оценка: 'Score is error!'\n\nПримери:\n>>> convert_score_to_grade(56)\n'E'\n>>> convert_score_to_grade(100)\n'A'\n>>> convert_score_to_grade(123)\n'Score is error!'",
      "zh": "编写一个 ruby 函数 `def convert_score_to_grade(score)` 来解决以下问题：\n将数值分数转换为基于预定义范围的相应字母等级。\n该函数接受一个参数，score，这是一个表示分数的整数。\n它返回一个表示字母等级的字符串，或者对于无效分数返回错误信息。\n\n等级转换：\n90-100: 'A'\n80-89: 'B'\n70-79: 'C'\n60-69: 'D'\n0-59: 'E'\n其他任何分数：'Score is error!'\n\n示例：\n>>> convert_score_to_grade(56)\n'E'\n>>> convert_score_to_grade(100)\n'A'\n>>> convert_score_to_grade(123)\n'Score is error!'",
      "fr": "Écrire une fonction ruby `def convert_score_to_grade(score)` pour résoudre le problème suivant :\nConvertit un score numérique en une note alphabétique correspondante basée sur des plages prédéfinies.\nLa fonction prend un seul argument, score, qui est un entier représentant le score.\nElle renvoie une chaîne de caractères représentant la note alphabétique, ou un message d'erreur pour les scores invalides.\n\nConversion des notes :\n90-100 : 'A'\n80-89 : 'B'\n70-79 : 'C'\n60-69 : 'D'\n0-59 : 'E'\nTout autre score : 'Score is error!'\n\nExemples :\n>>> convert_score_to_grade(56)\n'E'\n>>> convert_score_to_grade(100)\n'A'\n>>> convert_score_to_grade(123)\n'Score is error!'",
      "de": "Schreiben Sie eine Ruby-Funktion `def convert_score_to_grade(score)`, um das folgende Problem zu lösen:\nKonvertiert eine numerische Punktzahl in eine entsprechende Buchstabennote basierend auf vordefinierten Bereichen.\nDie Funktion nimmt ein einzelnes Argument, score, das ein ganzzahliger Wert ist, der die Punktzahl darstellt.\nSie gibt einen String zurück, der die Buchstabennote darstellt, oder eine Fehlermeldung für ungültige Punktzahlen.\n\nNotenumwandlung:\n90-100: 'A'\n80-89: 'B'\n70-79: 'C'\n60-69: 'D'\n0-59: 'E'\nJede andere Punktzahl: 'Score is error!'\n\nBeispiele:\n>>> convert_score_to_grade(56)\n'E'\n>>> convert_score_to_grade(100)\n'A'\n>>> convert_score_to_grade(123)\n'Score is error!'",
      "ha": "Rubuta aikin ruby `def convert_score_to_grade(score)` don warware matsalar mai zuwa:\nYana canza maki na lambobi zuwa harafin daraja mai dacewa bisa ga iyakokin da aka riga aka ayyana.\nAikin yana ɗaukar hujja guda ɗaya, score, wanda yake wakiltar maki a matsayin cikakken lamba.\nYana mayar da kirtani mai wakiltar harafin daraja, ko saƙon kuskure don maki marasa inganci.\n\nCanjin Daraja:\n90-100: 'A'\n80-89: 'B'\n70-79: 'C'\n60-69: 'D'\n0-59: 'E'\nDuk wani maki dabam: 'Score is error!'\n\nMisalai:\n>>> convert_score_to_grade(56)\n'E'\n>>> convert_score_to_grade(100)\n'A'\n>>> convert_score_to_grade(123)\n'Score is error!'",
      "hi": "रूबी फ़ंक्शन `def convert_score_to_grade(score)` लिखें ताकि निम्नलिखित समस्या का समाधान हो सके:\nएक संख्यात्मक स्कोर को पूर्वनिर्धारित श्रेणियों के आधार पर संबंधित अक्षर ग्रेड में परिवर्तित करता है।\nयह फ़ंक्शन एक एकल तर्क लेता है, score, जो स्कोर का प्रतिनिधित्व करने वाला एक पूर्णांक है।\nयह एक स्ट्रिंग लौटाता है जो अक्षर ग्रेड का प्रतिनिधित्व करता है, या अमान्य स्कोर के लिए एक त्रुटि संदेश।\n\nग्रेड रूपांतरण:\n90-100: 'A'\n80-89: 'B'\n70-79: 'C'\n60-69: 'D'\n0-59: 'E'\nकोई अन्य स्कोर: 'Score is error!'\n\nउदाहरण:\n>>> convert_score_to_grade(56)\n'E'\n>>> convert_score_to_grade(100)\n'A'\n>>> convert_score_to_grade(123)\n'Score is error!'",
      "hu": "Írj egy ruby függvényt `def convert_score_to_grade(score)` a következő probléma megoldására:\nÁtalakít egy numerikus pontszámot a megfelelő betűjeggyé előre meghatározott tartományok alapján.\nA függvény egyetlen argumentumot vesz át, score, amely egy egész számot képvisel, ami a pontszám.\nEgy karakterláncot ad vissza, amely a betűjegyet képviseli, vagy egy hibaüzenetet érvénytelen pontszámok esetén.\n\nJegy átalakítás:\n90-100: 'A'\n80-89: 'B'\n70-79: 'C'\n60-69: 'D'\n0-59: 'E'\nBármely más pontszám: 'Score is error!'\n\nPéldák:\n>>> convert_score_to_grade(56)\n'E'\n>>> convert_score_to_grade(100)\n'A'\n>>> convert_score_to_grade(123)\n'Score is error!'"
    },
    "instruction_bertscore": {
      "sq": "0.9964161120349875",
      "hy": "0.9918265584507954",
      "bn": "0.993566759219042",
      "bg": "0.9901280700625661",
      "zh": "0.9821649780868774",
      "fr": "0.9797325504407242",
      "de": "0.9954883095251735",
      "ha": "0.9854254957915651",
      "hi": "0.9799697151156798",
      "hu": "0.988305834946952"
    },
    "level": "easy",
    "test": "raise 'Test failed' unless convert_score_to_grade(56) == 'E'\nraise 'Test failed' unless convert_score_to_grade(67) == 'D'\nraise 'Test failed' unless convert_score_to_grade(100) == 'A'\nraise 'Test failed' unless convert_score_to_grade(123) == 'Score is error!'\nraise 'Test failed' unless convert_score_to_grade(-5) == 'Score is error!'\nraise 'Test failed' unless convert_score_to_grade(85) == 'B'\n  \n\nputs 'All tests passed!'",
    "entry_point": "convert_score_to_grade",
    "signature": "def convert_score_to_grade(score)",
    "docstring": {
      "en": "Converts a numerical score into a corresponding letter grade based on predefined ranges.\nThe function takes a single argument, score, which is an integer representing the score.\nIt returns a string representing the letter grade, or an error message for invalid scores.\n\nGrade Conversion:\n90-100: 'A'\n80-89: 'B'\n70-79: 'C'\n60-69: 'D'\n0-59: 'E'\nAny other score: 'Score is error!'\n\nExamples:\n>>> convert_score_to_grade(56)\n'E'\n>>> convert_score_to_grade(100)\n'A'\n>>> convert_score_to_grade(123)\n'Score is error!'",
      "sq": "Konverton një rezultat numerik në një notë përkatëse me shkronja bazuar në intervale të paracaktuara.\nFunksioni merr një argument të vetëm, score, i cili është një numër i plotë që përfaqëson rezultatin.\nKthen një varg që përfaqëson notën me shkronja, ose një mesazh gabimi për rezultate të pavlefshme.\n\nKonvertimi i Notave:\n90-100: 'A'\n80-89: 'B'\n70-79: 'C'\n60-69: 'D'\n0-59: 'E'\nÇdo rezultat tjetër: 'Rezultati është gabim!'\n\nShembuj:\n>>> convert_score_to_grade(56)\n'E'\n>>> convert_score_to_grade(100)\n'A'\n>>> convert_score_to_grade(123)\n'Rezultati është gabim!'",
      "hy": "Թվային գնահատականը վերածում է համապատասխան տառային գնահատականի՝ հիմնված նախապես սահմանված միջակայքերի վրա։ Ֆունկցիան ընդունում է մեկ արգումենտ՝ score, որը ամբողջ թիվ է, ներկայացնելով գնահատականը։ Այն վերադարձնում է տող, որը ներկայացնում է տառային գնահատականը, կամ սխալի հաղորդագրություն՝ անվավեր գնահատականների համար։\n\nԳնահատականի փոխակերպում:\n90-100: 'A'\n80-89: 'B'\n70-79: 'C'\n60-69: 'D'\n0-59: 'E'\nՑանկացած այլ գնահատական: 'Գնահատականը սխալ է!'\n\nՕրինակներ:\n>>> convert_score_to_grade(56)\n'E'\n>>> convert_score_to_grade(100)\n'A'\n>>> convert_score_to_grade(123)\n'Գնահատականը սխալ է!'",
      "bn": "সংখ্যাসূচক স্কোরকে পূর্বনির্ধারিত সীমার উপর ভিত্তি করে একটি সংশ্লিষ্ট অক্ষর গ্রেডে রূপান্তর করে। ফাংশনটি একটি একক আর্গুমেন্ট গ্রহণ করে, score, যা স্কোরের প্রতিনিধিত্বকারী একটি পূর্ণসংখ্যা। এটি একটি স্ট্রিং প্রদান করে যা অক্ষর গ্রেডের প্রতিনিধিত্ব করে, অথবা অবৈধ স্কোরের জন্য একটি ত্রুটি বার্তা প্রদান করে।\n\nগ্রেড রূপান্তর:\n90-100: 'A'\n80-89: 'B'\n70-79: 'C'\n60-69: 'D'\n0-59: 'E'\nঅন্য কোনো স্কোর: 'Score is error!'\n\nউদাহরণ:\n>>> convert_score_to_grade(56)\n'E'\n>>> convert_score_to_grade(100)\n'A'\n>>> convert_score_to_grade(123)\n'Score is error!'",
      "bg": "Преобразува числова оценка в съответстваща буквена оценка въз основа на предварително определени диапазони. Функцията приема един аргумент, score, който е цяло число, представляващо оценката. Връща низ, представляващ буквена оценка, или съобщение за грешка за невалидни оценки.\n\nПреобразуване на оценки:\n90-100: 'A'\n80-89: 'B'\n70-79: 'C'\n60-69: 'D'\n0-59: 'E'\nВсяка друга оценка: 'Score is error!'\n\nПримери:\n>>> convert_score_to_grade(56)\n'E'\n>>> convert_score_to_grade(100)\n'A'\n>>> convert_score_to_grade(123)\n'Score is error!'",
      "zh": "将数值分数转换为基于预定义范围的相应字母等级。\n该函数接受一个参数，score，它是表示分数的整数。\n它返回一个表示字母等级的字符串，或对于无效分数返回错误信息。\n\n等级转换：\n90-100: 'A'\n80-89: 'B'\n70-79: 'C'\n60-69: 'D'\n0-59: 'E'\n任何其他分数: 'Score is error!'\n\n示例：\n>>> convert_score_to_grade(56)\n'E'\n>>> convert_score_to_grade(100)\n'A'\n>>> convert_score_to_grade(123)\n'Score is error!'",
      "fr": "Convertit un score numérique en une note correspondante basée sur des plages prédéfinies.\nLa fonction prend un seul argument, score, qui est un entier représentant le score.\nElle retourne une chaîne de caractères représentant la note, ou un message d'erreur pour les scores invalides.\n\nConversion des notes :\n90-100 : 'A'\n80-89 : 'B'\n70-79 : 'C'\n60-69 : 'D'\n0-59 : 'E'\nTout autre score : 'Score is error!'\n\nExemples :\n>>> convert_score_to_grade(56)\n'E'\n>>> convert_score_to_grade(100)\n'A'\n>>> convert_score_to_grade(123)\n'Score is error!'",
      "de": "Konvertiert eine numerische Punktzahl in eine entsprechende Buchstabennote basierend auf vordefinierten Bereichen.\nDie Funktion nimmt ein einzelnes Argument, score, das ein ganzzahliger Wert ist, der die Punktzahl darstellt.\nSie gibt einen String zurück, der die Buchstabennote darstellt, oder eine Fehlermeldung für ungültige Punktzahlen.\n\nNotenumwandlung:\n90-100: 'A'\n80-89: 'B'\n70-79: 'C'\n60-69: 'D'\n0-59: 'E'\nJede andere Punktzahl: 'Score is error!'\n\nBeispiele:\n>>> convert_score_to_grade(56)\n'E'\n>>> convert_score_to_grade(100)\n'A'\n>>> convert_score_to_grade(123)\n'Score is error!'",
      "ha": "Yana canza maki na lambobi zuwa harafin daraja daidai da kewayon da aka riga aka ayyana.\nAikin yana ɗaukar hujja guda ɗaya, score, wanda yake wakiltar maki.\nYana mayar da kirtani wanda yake wakiltar harafin daraja, ko kuma saƙon kuskure don maki mara inganci.\n\nCanjin Daraja:\n90-100: 'A'\n80-89: 'B'\n70-79: 'C'\n60-69: 'D'\n0-59: 'E'\nDuk wani maki dabam: 'Score is error!'\n\nMisalai:\n>>> convert_score_to_grade(56)\n'E'\n>>> convert_score_to_grade(100)\n'A'\n>>> convert_score_to_grade(123)\n'Score is error!'",
      "hi": "संख्यात्मक स्कोर को पूर्वनिर्धारित श्रेणियों के आधार पर संबंधित अक्षर ग्रेड में परिवर्तित करता है। \nयह फ़ंक्शन एकल तर्क लेता है, score, जो स्कोर का प्रतिनिधित्व करने वाला एक पूर्णांक है। \nयह एक स्ट्रिंग लौटाता है जो अक्षर ग्रेड का प्रतिनिधित्व करता है, या अमान्य स्कोर के लिए एक त्रुटि संदेश लौटाता है।\n\nग्रेड रूपांतरण:\n90-100: 'A'\n80-89: 'B'\n70-79: 'C'\n60-69: 'D'\n0-59: 'E'\nकोई अन्य स्कोर: 'Score is error!'\n\nउदाहरण:\n>>> convert_score_to_grade(56)\n'E'\n>>> convert_score_to_grade(100)\n'A'\n>>> convert_score_to_grade(123)\n'Score is error!'",
      "hu": "Átalakít egy numerikus pontszámot a megfelelő betűjeggyé előre meghatározott tartományok alapján.\nA függvény egyetlen argumentumot, a score-t fogad, amely egy egész számot képvisel, ami a pontszám.\nEgy karakterláncot ad vissza, amely a betűjegyet képviseli, vagy egy hibaüzenetet érvénytelen pontszámok esetén.\n\nOsztályzat átváltás:\n90-100: 'A'\n80-89: 'B'\n70-79: 'C'\n60-69: 'D'\n0-59: 'E'\nBármely más pontszám: 'Score is error!'\n\nPéldák:\n>>> convert_score_to_grade(56)\n'E'\n>>> convert_score_to_grade(100)\n'A'\n>>> convert_score_to_grade(123)\n'Score is error!'"
    },
    "docstring_bertscore": {
      "sq": "0.981798703664249",
      "hy": "0.9760529226320529",
      "bn": "0.9841981586671505",
      "bg": "0.9893432814270973",
      "zh": "0.9826508279988887",
      "fr": "0.9826510266292697",
      "de": "0.9962067556133768",
      "ha": "0.9661865543452879",
      "hi": "0.9867596960609765",
      "hu": "0.9767697796772078"
    }
  },
  {
    "task_id": "Ruby/32",
    "prompt": {
      "en": "# Calculates the minimum time required to reverse the order of M people standing in a circle.\n# In each minute, only a pair of adjacent people can swap places. The function returns the \n# minimum number of minutes required to reverse the order of the people, such that each person's \n# left neighbor becomes their right neighbor and vice versa.\n#\n# Args:\n# - m: A positive integer representing the number of people in the circle.\n#\n# Returns:\n# - An integer representing the minimum number of minutes required to achieve the reversed order.\n#\n# Examples:\n# >>> min_time_to_reverse_order(4)\n# 2\n# >>> min_time_to_reverse_order(5)\n# 4\n# >>> min_time_to_reverse_order(6)\n# 6\n\ndef min_time_to_reverse_order(m)",
      "sq": "# Llogarit kohën minimale të nevojshme për të kthyer rendin e M personave që qëndrojnë në një rreth.\n# Në çdo minutë, vetëm një çift personash ngjitur mund të ndërrojnë vendet. Funksioni kthen \n# numrin minimal të minutave të nevojshme për të kthyer rendin e personave, në mënyrë që \n# fqinjët e majtë të secilit person të bëhen fqinjët e tyre të djathtë dhe anasjelltas.\n#\n# Argumentet:\n# - m: Një numër i plotë pozitiv që përfaqëson numrin e personave në rreth.\n#\n# Kthen:\n# - Një numër i plotë që përfaqëson numrin minimal të minutave të nevojshme për të arritur rendin e kthyer.\n#\n# Shembuj:\n# >>> min_time_to_reverse_order(4)\n# 2\n# >>> min_time_to_reverse_order(5)\n# 4\n# >>> min_time_to_reverse_order(6)\n# 6\n\ndef min_time_to_reverse_order(m)",
      "hy": "# Հաշվում է նվազագույն ժամանակը, որը պահանջվում է M մարդկանց շրջանի մեջ կարգը շրջելու համար։\n# Յուրաքանչյուր րոպեում միայն հարևան զույգ մարդիկ կարող են տեղերը փոխել։ Ֆունկցիան վերադարձնում է \n# նվազագույն րոպեների քանակը, որը պահանջվում է մարդկանց կարգը շրջելու համար, այնպես, որ յուրաքանչյուր մարդու \n# ձախ հարևանը դառնա նրա աջ հարևանը և հակառակը։\n#\n# Արգումենտներ:\n# - m: Դրական ամբողջ թիվ, որը ներկայացնում է մարդկանց քանակը շրջանի մեջ։\n#\n# Վերադարձնում է:\n# - Ամբողջ թիվ, որը ներկայացնում է նվազագույն րոպեների քանակը, որը պահանջվում է շրջված կարգին հասնելու համար։\n#\n# Օրինակներ:\n# >>> min_time_to_reverse_order(4)\n# 2\n# >>> min_time_to_reverse_order(5)\n# 4\n# >>> min_time_to_reverse_order(6)\n# 6\n\ndef min_time_to_reverse_order(m)",
      "bn": "# একটি বৃত্তে দাঁড়িয়ে থাকা M জন মানুষের ক্রম বিপরীত করার জন্য প্রয়োজনীয় সর্বনিম্ন সময় গণনা করে।\n# প্রতি মিনিটে, শুধুমাত্র একটি জোড়া সংলগ্ন মানুষ স্থান পরিবর্তন করতে পারে। ফাংশনটি সেই \n# সর্বনিম্ন মিনিটের সংখ্যা ফেরত দেয় যা মানুষের ক্রম বিপরীত করতে প্রয়োজন হয়, যাতে প্রতিটি \n# ব্যক্তির বাম প্রতিবেশী তাদের ডান প্রতিবেশী হয়ে যায় এবং এর বিপরীত।\n#\n# আর্গুমেন্টসমূহ:\n# - m: বৃত্তে মানুষের সংখ্যাকে উপস্থাপনকারী একটি ধনাত্মক পূর্ণসংখ্যা।\n#\n# রিটার্নস:\n# - একটি পূর্ণসংখ্যা যা বিপরীত ক্রম অর্জনের জন্য প্রয়োজনীয় সর্বনিম্ন মিনিটের সংখ্যা উপস্থাপন করে।\n#\n# উদাহরণসমূহ:\n# >>> min_time_to_reverse_order(4)\n# 2\n# >>> min_time_to_reverse_order(5)\n# 4\n# >>> min_time_to_reverse_order(6)\n# 6\n\ndef min_time_to_reverse_order(m)",
      "bg": "# Изчислява минималното време, необходимо за обръщане на реда на M души, стоящи в кръг.\n# Всяка минута само двойка съседни хора могат да си разменят местата. Функцията връща\n# минималния брой минути, необходими за обръщане на реда на хората, така че левият съсед\n# на всеки човек да стане десен съсед и обратно.\n#\n# Аргументи:\n# - m: Положително цяло число, представляващо броя на хората в кръга.\n#\n# Връща:\n# - Цяло число, представляващо минималния брой минути, необходими за постигане на обърнатия ред.\n#\n# Примери:\n# >>> min_time_to_reverse_order(4)\n# 2\n# >>> min_time_to_reverse_order(5)\n# 4\n# >>> min_time_to_reverse_order(6)\n# 6\n\ndef min_time_to_reverse_order(m)",
      "zh": "# 计算将站在圆圈中的M个人的顺序反转所需的最短时间。\n# 每分钟内，只能交换一对相邻的人。函数返回反转这些人的顺序所需的最少分钟数，\n# 使得每个人的左邻居变成他们的右邻居，反之亦然。\n#\n# 参数:\n# - m: 表示圆圈中人数的正整数。\n#\n# 返回:\n# - 表示达到反转顺序所需的最少分钟数的整数。\n#\n# 示例:\n# >>> min_time_to_reverse_order(4)\n# 2\n# >>> min_time_to_reverse_order(5)\n# 4\n# >>> min_time_to_reverse_order(6)\n# 6\n\ndef min_time_to_reverse_order(m)",
      "fr": "# Calcule le temps minimum requis pour inverser l'ordre de M personnes debout en cercle.\n# Chaque minute, seule une paire de personnes adjacentes peut échanger leurs places. La fonction retourne le\n# nombre minimum de minutes nécessaires pour inverser l'ordre des personnes, de sorte que le voisin de gauche de chaque personne\n# devienne leur voisin de droite et vice versa.\n#\n# Args:\n# - m: Un entier positif représentant le nombre de personnes dans le cercle.\n#\n# Returns:\n# - Un entier représentant le nombre minimum de minutes nécessaires pour atteindre l'ordre inversé.\n#\n# Examples:\n# >>> min_time_to_reverse_order(4)\n# 2\n# >>> min_time_to_reverse_order(5)\n# 4\n# >>> min_time_to_reverse_order(6)\n# 6\n\ndef min_time_to_reverse_order(m)",
      "de": "# Berechnet die minimale Zeit, die erforderlich ist, um die Reihenfolge von M Personen, die in einem Kreis stehen, umzukehren.\n# In jeder Minute kann nur ein Paar benachbarter Personen die Plätze tauschen. Die Funktion gibt die \n# minimale Anzahl von Minuten zurück, die erforderlich ist, um die Reihenfolge der Personen umzukehren, sodass der linke Nachbar jeder Person zu ihrem rechten Nachbarn wird und umgekehrt.\n#\n# Argumente:\n# - m: Eine positive ganze Zahl, die die Anzahl der Personen im Kreis darstellt.\n#\n# Rückgabewert:\n# - Eine ganze Zahl, die die minimale Anzahl von Minuten darstellt, die erforderlich ist, um die umgekehrte Reihenfolge zu erreichen.\n#\n# Beispiele:\n# >>> min_time_to_reverse_order(4)\n# 2\n# >>> min_time_to_reverse_order(5)\n# 4\n# >>> min_time_to_reverse_order(6)\n# 6\n\ndef min_time_to_reverse_order(m)",
      "ha": "# Lissafi na mafi ƙarancin lokaci da ake buƙata don juyar da tsarin mutane M da ke tsaye a cikin da'ira.\n# A kowane minti, mutum biyu masu makwabtaka kawai za su iya musanya wurare. Aikin yana dawowa da\n# mafi ƙarancin adadin mintuna da ake buƙata don juyar da tsarin mutanen, ta yadda makwabcin hagu\n# na kowane mutum zai zama makwabcin dama nasu kuma akasin haka.\n#\n# Args:\n# - m: Lamba mai kyau da ke wakiltar adadin mutane a cikin da'ira.\n#\n# Returns:\n# - Lamba da ke wakiltar mafi ƙarancin adadin mintuna da ake buƙata don cimma tsarin da aka juyar.\n#\n# Misalai:\n# >>> min_time_to_reverse_order(4)\n# 2\n# >>> min_time_to_reverse_order(5)\n# 4\n# >>> min_time_to_reverse_order(6)\n# 6\n\ndef min_time_to_reverse_order(m)",
      "hi": "# वृत्त में खड़े M लोगों के क्रम को उलटने के लिए आवश्यक न्यूनतम समय की गणना करता है।\n# प्रत्येक मिनट में, केवल एक जोड़ी आसन्न लोग स्थान बदल सकते हैं। फ़ंक्शन उन लोगों के क्रम को उलटने के लिए \n# आवश्यक न्यूनतम मिनटों की संख्या लौटाता है, ताकि प्रत्येक व्यक्ति का बायां पड़ोसी उनका दायां पड़ोसी बन जाए और इसके विपरीत।\n#\n# तर्क:\n# - m: वृत्त में लोगों की संख्या का प्रतिनिधित्व करने वाला एक धनात्मक पूर्णांक।\n#\n# वापसी:\n# - एक पूर्णांक जो उलटे क्रम को प्राप्त करने के लिए आवश्यक न्यूनतम मिनटों का प्रतिनिधित्व करता है।\n#\n# उदाहरण:\n# >>> min_time_to_reverse_order(4)\n# 2\n# >>> min_time_to_reverse_order(5)\n# 4\n# >>> min_time_to_reverse_order(6)\n# 6\n\ndef min_time_to_reverse_order(m)",
      "hu": "# Kiszámítja a minimális időt, amely szükséges ahhoz, hogy M ember sorrendjét megfordítsuk egy körben.\n# Minden percben csak egy pár szomszédos ember cserélhet helyet. A függvény visszaadja a \n# minimális percek számát, amely szükséges ahhoz, hogy az emberek sorrendjét megfordítsuk úgy, \n# hogy minden ember bal szomszédja a jobb szomszédjává váljon és fordítva.\n#\n# Argumentumok:\n# - m: Egy pozitív egész szám, amely az emberek számát jelöli a körben.\n#\n# Visszatérési érték:\n# - Egy egész szám, amely a megfordított sorrend eléréséhez szükséges minimális percek számát jelöli.\n#\n# Példák:\n# >>> min_time_to_reverse_order(4)\n# 2\n# >>> min_time_to_reverse_order(5)\n# 4\n# >>> min_time_to_reverse_order(6)\n# 6\n\ndef min_time_to_reverse_order(m)"
    },
    "prompt_bertscore": {
      "sq": "0.9759041484766577",
      "hy": "0.9714883964758712",
      "bn": "0.9823612249033399",
      "bg": "0.9804305375996808",
      "zh": "0.9660179171517893",
      "fr": "0.9900210082871882",
      "de": "0.9822432384570051",
      "ha": "0.977437177757485",
      "hi": "0.9835105002880077",
      "hu": "0.96684719899261"
    },
    "canonical_solution": "    if m.even?\n      (m / 2) * (m / 2 - 1)\n    else\n      (m - 1) * (m - 1) / 4\n    end\n  end",
    "instruction": {
      "en": "Write a ruby function `def min_time_to_reverse_order(m)` to solve the following problem:\nCalculates the minimum time required to reverse the order of M people standing in a circle.\nIn each minute, only a pair of adjacent people can swap places. The function returns the\nminimum number of minutes required to reverse the order of the people, such that each person's\nleft neighbor becomes their right neighbor and vice versa.\n\nArgs:\n- m: A positive integer representing the number of people in the circle.\n\nReturns:\n- An integer representing the minimum number of minutes required to achieve the reversed order.\n\nExamples:\n>>> min_time_to_reverse_order(4)\n2\n>>> min_time_to_reverse_order(5)\n4\n>>> min_time_to_reverse_order(6)\n6",
      "sq": "Shkruani një funksion ruby `def min_time_to_reverse_order(m)` për të zgjidhur problemin në vijim:\nLlogarit kohën minimale të nevojshme për të kthyer rendin e M personave që qëndrojnë në një rreth.\nNë çdo minutë, vetëm një çift personash ngjitur mund të ndërrojnë vendet. Funksioni kthen\nnumrin minimal të minutave të nevojshme për të kthyer rendin e personave, në mënyrë që çdo fqinj i majtë i një personi të bëhet fqinj i djathtë dhe anasjelltas.\n\nArgumentet:\n- m: Një numër i plotë pozitiv që përfaqëson numrin e personave në rreth.\n\nKthen:\n- Një numër i plotë që përfaqëson numrin minimal të minutave të nevojshme për të arritur rendin e kthyer.\n\nShembuj:\n>>> min_time_to_reverse_order(4)\n2\n>>> min_time_to_reverse_order(5)\n4\n>>> min_time_to_reverse_order(6)\n6",
      "hy": "Գրեք ruby ֆունկցիա `def min_time_to_reverse_order(m)` լուծելու համար հետևյալ խնդիրը:\nՀաշվում է նվազագույն ժամանակը, որը պահանջվում է շրջապատում կանգնած M մարդկանց հերթականությունը շրջելու համար:\nՅուրաքանչյուր րոպեում միայն հարակից զույգ մարդիկ կարող են տեղերը փոխել: Ֆունկցիան վերադարձնում է\nնվազագույն րոպեների քանակը, որը պահանջվում է մարդկանց հերթականությունը շրջելու համար, այնպես, որ յուրաքանչյուր մարդու\nձախ հարևանը դառնա աջ հարևան և հակառակը:\n\nԱրգումենտներ:\n- m: Դրական ամբողջ թիվ, որը ներկայացնում է շրջապատում գտնվող մարդկանց քանակը:\n\nՎերադարձնում է:\n- Ամբողջ թիվ, որը ներկայացնում է նվազագույն րոպեների քանակը, որը պահանջվում է շրջված հերթականությունը ստանալու համար:\n\nՕրինակներ:\n>>> min_time_to_reverse_order(4)\n2\n>>> min_time_to_reverse_order(5)\n4\n>>> min_time_to_reverse_order(6)\n6",
      "bn": "রুবি ফাংশন `def min_time_to_reverse_order(m)` লিখুন নিম্নলিখিত সমস্যার সমাধানের জন্য:\nএম সংখ্যক মানুষ একটি বৃত্তে দাঁড়িয়ে আছে, তাদের ক্রম উল্টাতে প্রয়োজনীয় সর্বনিম্ন সময় গণনা করে।\nপ্রতি মিনিটে, শুধুমাত্র একটি জোড়া সংলগ্ন মানুষ তাদের স্থান পরিবর্তন করতে পারে। ফাংশনটি সেই\nসর্বনিম্ন মিনিটের সংখ্যা প্রদান করে যা মানুষের ক্রম উল্টাতে প্রয়োজন, যাতে প্রতিটি ব্যক্তির\nবাম প্রতিবেশী তাদের ডান প্রতিবেশী হয়ে যায় এবং বিপরীত।\n\nআর্গুমেন্টস:\n- m: একটি ধনাত্মক পূর্ণসংখ্যা যা বৃত্তে মানুষের সংখ্যা উপস্থাপন করে।\n\nফেরত দেয়:\n- একটি পূর্ণসংখ্যা যা উল্টানো ক্রম অর্জনের জন্য প্রয়োজনীয় সর্বনিম্ন মিনিটের সংখ্যা উপস্থাপন করে।\n\nউদাহরণ:\n>>> min_time_to_reverse_order(4)\n2\n>>> min_time_to_reverse_order(5)\n4\n>>> min_time_to_reverse_order(6)\n6",
      "bg": "Напишете Ruby функция `def min_time_to_reverse_order(m)`, за да решите следния проблем:\nИзчислява минималното време, необходимо за обръщане на реда на M души, стоящи в кръг.\nВсяка минута само двойка съседни хора могат да разменят местата си. Функцията връща\nминималния брой минути, необходими за обръщане на реда на хората, така че левият съсед на всеки човек да стане десен съсед и обратно.\n\nАргументи:\n- m: Положително цяло число, представляващо броя на хората в кръга.\n\nВръща:\n- Цяло число, представляващо минималния брой минути, необходими за постигане на обърнатия ред.\n\nПримери:\n>>> min_time_to_reverse_order(4)\n2\n>>> min_time_to_reverse_order(5)\n4\n>>> min_time_to_reverse_order(6)\n6",
      "zh": "编写一个 ruby 函数 `def min_time_to_reverse_order(m)` 来解决以下问题：\n计算将 M 个人按顺序反转所需的最短时间，这些人站在一个圆圈中。\n每分钟内，只能交换一对相邻的人。该函数返回将人的顺序反转所需的最少分钟数，使得每个人的左邻居变为右邻居，反之亦然。\n\n参数:\n- m: 一个正整数，表示圆圈中人的数量。\n\n返回:\n- 一个整数，表示实现顺序反转所需的最少分钟数。\n\n示例:\n>>> min_time_to_reverse_order(4)\n2\n>>> min_time_to_reverse_order(5)\n4\n>>> min_time_to_reverse_order(6)\n6",
      "fr": "Écrire une fonction ruby `def min_time_to_reverse_order(m)` pour résoudre le problème suivant :\nCalcule le temps minimum nécessaire pour inverser l'ordre de M personnes debout en cercle.\nChaque minute, seule une paire de personnes adjacentes peut échanger leurs places. La fonction retourne le\nnombre minimum de minutes nécessaires pour inverser l'ordre des personnes, de sorte que le voisin de gauche de chaque personne devienne son voisin de droite et vice versa.\n\nArgs:\n- m : Un entier positif représentant le nombre de personnes dans le cercle.\n\nReturns:\n- Un entier représentant le nombre minimum de minutes nécessaires pour atteindre l'ordre inversé.\n\nExemples :\n>>> min_time_to_reverse_order(4)\n2\n>>> min_time_to_reverse_order(5)\n4\n>>> min_time_to_reverse_order(6)\n6",
      "de": "Schreiben Sie eine Ruby-Funktion `def min_time_to_reverse_order(m)`, um das folgende Problem zu lösen:\nBerechnet die minimale Zeit, die benötigt wird, um die Reihenfolge von M Personen, die im Kreis stehen, umzukehren.\nIn jeder Minute kann nur ein Paar benachbarter Personen die Plätze tauschen. Die Funktion gibt die\nminimale Anzahl von Minuten zurück, die benötigt wird, um die Reihenfolge der Personen umzukehren, sodass der linke Nachbar jeder Person zu ihrem rechten Nachbarn wird und umgekehrt.\n\nArgs:\n- m: Eine positive ganze Zahl, die die Anzahl der Personen im Kreis darstellt.\n\nReturns:\n- Eine ganze Zahl, die die minimale Anzahl von Minuten darstellt, die benötigt wird, um die umgekehrte Reihenfolge zu erreichen.\n\nBeispiele:\n>>> min_time_to_reverse_order(4)\n2\n>>> min_time_to_reverse_order(5)\n4\n>>> min_time_to_reverse_order(6)\n6",
      "ha": "Rubuta aikin ruby `def min_time_to_reverse_order(m)` don warware matsalar mai zuwa:\nYana lissafa mafi ƙarancin lokaci da ake buƙata don juyar da tsarin mutane M da ke tsaye a cikin da'ira.\nA kowane minti, mutane biyu kawai masu makwabtaka za su iya musanya wurare. Aikin yana mayar da\nmafi ƙarancin adadin mintuna da ake buƙata don juyar da tsarin mutanen, ta yadda makwabcin hagu na kowane mutum zai zama makwabcin dama nasu kuma akasin haka.\n\nArgs:\n- m: Lamba mai kyau da ke wakiltar adadin mutanen da ke cikin da'ira.\n\nReturns:\n- Lamba mai wakiltar mafi ƙarancin adadin mintuna da ake buƙata don cimma tsarin da aka juyar.\n\nMisalai:\n>>> min_time_to_reverse_order(4)\n2\n>>> min_time_to_reverse_order(5)\n4\n>>> min_time_to_reverse_order(6)\n6",
      "hi": "रूबी फ़ंक्शन `def min_time_to_reverse_order(m)` लिखें ताकि निम्नलिखित समस्या का समाधान हो सके:\nM लोगों के एक वृत्त में खड़े होने की क्रम को उलटने के लिए आवश्यक न्यूनतम समय की गणना करता है।\nप्रत्येक मिनट में, केवल एक जोड़ी आसन्न लोग स्थान बदल सकते हैं। फ़ंक्शन उन लोगों के क्रम को उलटने के लिए आवश्यक\nमिनटों की न्यूनतम संख्या लौटाता है, ताकि प्रत्येक व्यक्ति का बायां पड़ोसी उनका दायां पड़ोसी बन जाए और इसके विपरीत।\n\nआर्ग्स:\n- m: वृत्त में लोगों की संख्या को दर्शाने वाला एक धनात्मक पूर्णांक।\n\nरिटर्न्स:\n- एक पूर्णांक जो उलटे क्रम को प्राप्त करने के लिए आवश्यक मिनटों की न्यूनतम संख्या को दर्शाता है।\n\nउदाहरण:\n>>> min_time_to_reverse_order(4)\n2\n>>> min_time_to_reverse_order(5)\n4\n>>> min_time_to_reverse_order(6)\n6",
      "hu": "Írj egy ruby függvényt `def min_time_to_reverse_order(m)` a következő probléma megoldására:\nKiszámítja a minimális időt, amely szükséges ahhoz, hogy M ember sorrendjét megfordítsuk, akik egy körben állnak.\nMinden percben csak egy pár szomszédos ember cserélhet helyet. A függvény visszaadja a minimális percek számát, amely szükséges ahhoz, hogy az emberek sorrendjét megfordítsuk, úgy hogy minden személy bal oldali szomszédja a jobb oldali szomszédjává váljon és fordítva.\n\nArgok:\n- m: Egy pozitív egész szám, amely a körben álló emberek számát jelenti.\n\nVisszatér:\n- Egy egész szám, amely a megfordított sorrend eléréséhez szükséges minimális percek számát jelenti.\n\nPéldák:\n>>> min_time_to_reverse_order(4)\n2\n>>> min_time_to_reverse_order(5)\n4\n>>> min_time_to_reverse_order(6)\n6"
    },
    "instruction_bertscore": {
      "sq": "0.9894449801821871",
      "hy": "0.9765926013773246",
      "bn": "0.977448301058823",
      "bg": "0.9770236293041703",
      "zh": "0.9711697933446911",
      "fr": "0.9939217117099514",
      "de": "0.9918162296709816",
      "ha": "0.9841306243375987",
      "hi": "0.9929331283035407",
      "hu": "0.9898209874934861"
    },
    "level": "easy",
    "test": "raise 'Test failed' unless min_time_to_reverse_order(4) == 2\nraise 'Test failed' unless min_time_to_reverse_order(5) == 4\nraise 'Test failed' unless min_time_to_reverse_order(6) == 6\nraise 'Test failed' unless min_time_to_reverse_order(7) == 9\nraise 'Test failed' unless min_time_to_reverse_order(10) == 20\n\n\n\nputs 'All tests passed!'",
    "entry_point": "min_time_to_reverse_order",
    "signature": "def min_time_to_reverse_order(m)",
    "docstring": {
      "en": "Calculates the minimum time required to reverse the order of M people standing in a circle.\nIn each minute, only a pair of adjacent people can swap places. The function returns the\nminimum number of minutes required to reverse the order of the people, such that each person's\nleft neighbor becomes their right neighbor and vice versa.\n\nArgs:\n- m: A positive integer representing the number of people in the circle.\n\nReturns:\n- An integer representing the minimum number of minutes required to achieve the reversed order.\n\nExamples:\n>>> min_time_to_reverse_order(4)\n2\n>>> min_time_to_reverse_order(5)\n4\n>>> min_time_to_reverse_order(6)\n6",
      "sq": "Llogarit kohën minimale të kërkuar për të kthyer rendin e M personave që qëndrojnë në një rreth. Në çdo minutë, vetëm një çift personash ngjitur mund të ndërrojnë vendet. Funksioni kthen numrin minimal të minutave të kërkuara për të kthyer rendin e personave, në mënyrë që fqinji i majtë i secilit person të bëhet fqinji i tyre i djathtë dhe anasjelltas.\n\nArgs:\n- m: Një numër i plotë pozitiv që përfaqëson numrin e personave në rreth.\n\nReturns:\n- Një numër i plotë që përfaqëson numrin minimal të minutave të kërkuara për të arritur rendin e kthyer.\n\nExamples:\n>>> min_time_to_reverse_order(4)\n2\n>>> min_time_to_reverse_order(5)\n4\n>>> min_time_to_reverse_order(6)\n6",
      "hy": "Հաշվում է նվազագույն ժամանակը, որը պահանջվում է շրջադարձելու համար M մարդկանց հերթականությունը, ովքեր կանգնած են շրջանաձև:\nՅուրաքանչյուր րոպեում միայն հարևան զույգ մարդիկ կարող են փոխել իրենց տեղերը։ Ֆունկցիան վերադարձնում է\nնվազագույն րոպեների քանակը, որը պահանջվում է մարդկանց հերթականությունը շրջադարձելու համար, այնպես, որ յուրաքանչյուր մարդու\nձախ հարևանը դառնա աջ հարևան և հակառակը։\n\nԱրգումենտներ:\n- m: Դրական ամբողջ թիվ, որը ներկայացնում է մարդկանց քանակը շրջանաձև։\n\nՎերադարձնում է:\n- Ամբողջ թիվ, որը ներկայացնում է նվազագույն րոպեների քանակը, որը պահանջվում է շրջադարձված հերթականությունը ստանալու համար։\n\nՕրինակներ:\n>>> min_time_to_reverse_order(4)\n2\n>>> min_time_to_reverse_order(5)\n4\n>>> min_time_to_reverse_order(6)\n6",
      "bn": "বৃত্তে দাঁড়িয়ে থাকা M জন ব্যক্তির ক্রম বিপরীত করতে প্রয়োজনীয় সর্বনিম্ন সময় গণনা করে। \nপ্রতিটি মিনিটে, কেবলমাত্র একটি জোড়া সংলগ্ন ব্যক্তি তাদের স্থান পরিবর্তন করতে পারে। ফাংশনটি প্রয়োজনীয় \nমিনিটের সর্বনিম্ন সংখ্যা ফেরত দেয় যাতে ব্যক্তিদের ক্রম বিপরীত হয়, যাতে প্রতিটি ব্যক্তির বাম পার্শ্বের \nপ্রতিবেশী তাদের ডান পার্শ্বের প্রতিবেশী হয়ে যায় এবং এর বিপরীত।\n\nআর্গস:\n- m: বৃত্তে ব্যক্তিদের সংখ্যা নির্দেশ করে একটি ধনাত্মক পূর্ণসংখ্যা।\n\nরিটার্নস:\n- একটি পূর্ণসংখ্যা যা বিপরীত ক্রম অর্জন করতে প্রয়োজনীয় সর্বনিম্ন মিনিটের সংখ্যা নির্দেশ করে।\n\nউদাহরণ:\n>>> min_time_to_reverse_order(4)\n2\n>>> min_time_to_reverse_order(5)\n4\n>>> min_time_to_reverse_order(6)\n6",
      "bg": "Изчислява минималното време, необходимо за обръщане на реда на M хора, стоящи в кръг. \nВсяка минута само двойка съседни хора могат да разменят местата си. Функцията връща \nминималния брой минути, необходими за обръщане на реда на хората, така че левият съсед на всеки човек да стане десен съсед и обратно.\n\nАргументи:\n- m: Положително цяло число, представляващо броя на хората в кръга.\n\nВръща:\n- Цяло число, представляващо минималния брой минути, необходими за постигане на обърнатия ред.\n\nПримери:\n>>> min_time_to_reverse_order(4)\n2\n>>> min_time_to_reverse_order(5)\n4\n>>> min_time_to_reverse_order(6)\n6",
      "zh": "计算将M个人按顺序反转所需的最短时间，这些人站成一个圆圈。\n在每一分钟内，只能交换一对相邻的人。函数返回反转这些人的顺序所需的最少分钟数，使得每个人的左邻居变成他们的右邻居，反之亦然。\n\n参数：\n- m: 一个正整数，表示圆圈中的人数。\n\n返回：\n- 一个整数，表示实现反转顺序所需的最少分钟数。\n\n示例：\n>>> min_time_to_reverse_order(4)\n2\n>>> min_time_to_reverse_order(5)\n4\n>>> min_time_to_reverse_order(6)\n6",
      "fr": "Calcule le temps minimum nécessaire pour inverser l'ordre de M personnes se tenant en cercle.  \nChaque minute, seule une paire de personnes adjacentes peut échanger leurs places. La fonction retourne le nombre minimum de minutes nécessaires pour inverser l'ordre des personnes, de sorte que le voisin de gauche de chaque personne devienne son voisin de droite et vice versa.\n\nArgs:\n- m: Un entier positif représentant le nombre de personnes dans le cercle.\n\nReturns:\n- Un entier représentant le nombre minimum de minutes nécessaires pour obtenir l'ordre inversé.\n\nExamples:\n>>> min_time_to_reverse_order(4)\n2\n>>> min_time_to_reverse_order(5)\n4\n>>> min_time_to_reverse_order(6)\n6",
      "de": "Berechnet die minimale Zeit, die erforderlich ist, um die Reihenfolge von M Personen in einem Kreis umzukehren.\nIn jeder Minute kann nur ein Paar benachbarter Personen die Plätze tauschen. Die Funktion gibt die\nminimale Anzahl von Minuten zurück, die erforderlich ist, um die Reihenfolge der Personen umzukehren, sodass der linke Nachbar jeder Person zu ihrem rechten Nachbarn wird und umgekehrt.\n\nArgs:\n- m: Eine positive ganze Zahl, die die Anzahl der Personen im Kreis darstellt.\n\nReturns:\n- Eine ganze Zahl, die die minimale Anzahl von Minuten darstellt, die erforderlich ist, um die umgekehrte Reihenfolge zu erreichen.\n\nExamples:\n>>> min_time_to_reverse_order(4)\n2\n>>> min_time_to_reverse_order(5)\n4\n>>> min_time_to_reverse_order(6)\n6",
      "ha": "Lissafi na mafi ƙarancin lokaci da ake buƙata don juyar da tsarin mutane M da ke tsaye a cikin da'ira.\nIn each minute, only a pair of adjacent people can swap places. The function returns the\nminimum number of minutes required to reverse the order of the people, such that each person's\nleft neighbor becomes their right neighbor and vice versa.\n\nArgs:\n- m: Wani cikakken lamba mai kyau wanda ke wakiltar adadin mutanen da ke cikin da'ira.\n\nReturns:\n- Wani cikakken lamba wanda ke wakiltar mafi ƙarancin adadin mintuna da ake buƙata don cimma tsarin da aka juyar.\n\nExamples:\n>>> min_time_to_reverse_order(4)\n2\n>>> min_time_to_reverse_order(5)\n4\n>>> min_time_to_reverse_order(6)\n6",
      "hi": "वृत्त में खड़े M लोगों के क्रम को उलटने के लिए आवश्यक न्यूनतम समय की गणना करता है।\nप्रत्येक मिनट में, केवल एक जोड़ी आसन्न लोग स्थान बदल सकते हैं। यह फ़ंक्शन उन मिनटों की न्यूनतम संख्या लौटाता है जो लोगों के क्रम को उलटने के लिए आवश्यक हैं, ताकि प्रत्येक व्यक्ति का बायां पड़ोसी उनका दायां पड़ोसी बन जाए और इसके विपरीत।\n\nArgs:  \n- m: एक धनात्मक पूर्णांक जो वृत्त में लोगों की संख्या का प्रतिनिधित्व करता है।\n\nReturns:  \n- एक पूर्णांक जो उलटे क्रम को प्राप्त करने के लिए आवश्यक न्यूनतम मिनटों की संख्या का प्रतिनिधित्व करता है।\n\nExamples:  \n>>> min_time_to_reverse_order(4)  \n2  \n>>> min_time_to_reverse_order(5)  \n4  \n>>> min_time_to_reverse_order(6)  \n6  ",
      "hu": "Kiszámítja a minimális időt, amely szükséges ahhoz, hogy M ember sorrendjét megfordítsuk egy körben állva.\nMinden percben csak egy pár szomszédos ember cserélhet helyet. A függvény visszaadja a\nminimális percek számát, amely szükséges ahhoz, hogy az emberek sorrendjét megfordítsuk, úgy, hogy minden személy bal oldali szomszédja jobb oldali szomszédjává váljon és fordítva.\n\nArgs:\n- m: Egy pozitív egész szám, amely a körben álló emberek számát jelöli.\n\nReturns:\n- Egy egész szám, amely a megfordított sorrend eléréséhez szükséges minimális percek számát jelöli.\n\nExamples:\n>>> min_time_to_reverse_order(4)\n2\n>>> min_time_to_reverse_order(5)\n4\n>>> min_time_to_reverse_order(6)\n6"
    },
    "docstring_bertscore": {
      "sq": "0.9874751626934641",
      "hy": "0.9703951348586551",
      "bn": "0.982328450890469",
      "bg": "0.9813297373346257",
      "zh": "0.9655821220957987",
      "fr": "0.9876308889121954",
      "de": "0.9858058729712469",
      "ha": "0.9968725646506057",
      "hi": "0.9920241956799251",
      "hu": "0.9824007523491658"
    }
  },
  {
    "task_id": "Ruby/33",
    "prompt": {
      "en": "# Generates all unique four-digit permutations using the given four digits.\n# Each digit is used exactly once in each permutation. The function accepts\n# four integers as arguments and returns an array of strings, each representing\n# a unique permutation. The permutations are sorted in ascending order.\n#\n# Example:\n# >>> generate_four_digit_permutations(1, 2, 3, 4)\n# [\"1234\", \"1243\", \"1324\", \"1342\", \"1423\", \"1432\", ...]\n# >>> generate_four_digit_permutations(1, 2, 3, 5)\n# [\"1235\", \"1253\", \"1325\", \"1352\", \"1523\", \"1532\", ...]\n\n\ndef generate_four_digit_permutations(*digits)",
      "sq": "# Gjeneron të gjitha permutacionet unike me katër shifra duke përdorur katër shifrat e dhëna.\n# Secila shifër përdoret saktësisht një herë në secilën permutacion. Funksioni pranon\n# katër numra të plotë si argumente dhe kthen një varg me vargje, secila që përfaqëson\n# një permutacion unik. Permutacionet janë të renditura në rend rritës.\n#\n# Shembull:\n# >>> generate_four_digit_permutations(1, 2, 3, 4)\n# [\"1234\", \"1243\", \"1324\", \"1342\", \"1423\", \"1432\", ...]\n# >>> generate_four_digit_permutations(1, 2, 3, 5)\n# [\"1235\", \"1253\", \"1325\", \"1352\", \"1523\", \"1532\", ...]\n\n\ndef generate_four_digit_permutations(*digits)",
      "hy": "# Գեներացնում է բոլոր եզակի չորսանիշ կոմբինացիաները տրված չորս թվանշաններով։\n# Յուրաքանչյուր թվանշան օգտագործվում է ճիշտ մեկ անգամ յուրաքանչյուր կոմբինացիայում։ Ֆունկցիան ընդունում է\n# չորս ամբողջ թիվ որպես արգումենտ և վերադարձնում է տողերի զանգված, որոնցից յուրաքանչյուրը ներկայացնում է\n# եզակի կոմբինացիա։ Կոմբինացիաները դասավորված են աճման կարգով։\n#\n# Օրինակ:\n# >>> generate_four_digit_permutations(1, 2, 3, 4)\n# [\"1234\", \"1243\", \"1324\", \"1342\", \"1423\", \"1432\", ...]\n# >>> generate_four_digit_permutations(1, 2, 3, 5)\n# [\"1235\", \"1253\", \"1325\", \"1352\", \"1523\", \"1532\", ...]\n\n\ndef generate_four_digit_permutations(*digits)",
      "bn": "# প্রদত্ত চারটি অঙ্ক ব্যবহার করে সমস্ত অনন্য চার-অঙ্কের বিন্যাস তৈরি করে।\n# প্রতিটি অঙ্ক প্রতিটি বিন্যাসে ঠিক একবার ব্যবহৃত হয়। ফাংশনটি\n# চারটি পূর্ণসংখ্যা আর্গুমেন্ট হিসেবে গ্রহণ করে এবং স্ট্রিং-এর একটি অ্যারে ফেরত দেয়,\n# প্রতিটি একটি অনন্য বিন্যাস উপস্থাপন করে। বিন্যাসগুলি ঊর্ধ্বক্রমে সাজানো থাকে।\n#\n# উদাহরণ:\n# >>> generate_four_digit_permutations(1, 2, 3, 4)\n# [\"1234\", \"1243\", \"1324\", \"1342\", \"1423\", \"1432\", ...]\n# >>> generate_four_digit_permutations(1, 2, 3, 5)\n# [\"1235\", \"1253\", \"1325\", \"1352\", \"1523\", \"1532\", ...]\n\n\ndef generate_four_digit_permutations(*digits)",
      "bg": "# Генерира всички уникални четирицифрени пермутации, използвайки дадените четири цифри.\n# Всяка цифра се използва точно веднъж във всяка пермутация. Функцията приема\n# четири цели числа като аргументи и връща масив от низове, всеки представляващ\n# уникална пермутация. Пермутациите са сортирани във възходящ ред.\n#\n# Пример:\n# >>> generate_four_digit_permutations(1, 2, 3, 4)\n# [\"1234\", \"1243\", \"1324\", \"1342\", \"1423\", \"1432\", ...]\n# >>> generate_four_digit_permutations(1, 2, 3, 5)\n# [\"1235\", \"1253\", \"1325\", \"1352\", \"1523\", \"1532\", ...]",
      "zh": "# 生成使用给定四个数字的所有唯一四位数排列。\n# 每个数字在每个排列中仅使用一次。函数接受四个整数作为参数，并返回一个字符串数组，每个字符串表示一个唯一的排列。排列按升序排序。\n#\n# 例子:\n# >>> generate_four_digit_permutations(1, 2, 3, 4)\n# [\"1234\", \"1243\", \"1324\", \"1342\", \"1423\", \"1432\", ...]\n# >>> generate_four_digit_permutations(1, 2, 3, 5)\n# [\"1235\", \"1253\", \"1325\", \"1352\", \"1523\", \"1532\", ...]\n\n\ndef generate_four_digit_permutations(*digits)",
      "fr": "# Génère toutes les permutations uniques à quatre chiffres en utilisant les quatre chiffres donnés.\n# Chaque chiffre est utilisé exactement une fois dans chaque permutation. La fonction accepte\n# quatre entiers en tant qu'arguments et retourne un tableau de chaînes de caractères, chacune représentant\n# une permutation unique. Les permutations sont triées par ordre croissant.\n#\n# Exemple:\n# >>> generate_four_digit_permutations(1, 2, 3, 4)\n# [\"1234\", \"1243\", \"1324\", \"1342\", \"1423\", \"1432\", ...]\n# >>> generate_four_digit_permutations(1, 2, 3, 5)\n# [\"1235\", \"1253\", \"1325\", \"1352\", \"1523\", \"1532\", ...] \n\n\ndef generate_four_digit_permutations(*digits)",
      "de": "# Generiert alle einzigartigen vierstelligen Permutationen mit den gegebenen vier Ziffern.\n# Jede Ziffer wird in jeder Permutation genau einmal verwendet. Die Funktion akzeptiert\n# vier ganze Zahlen als Argumente und gibt ein Array von Strings zurück, von denen jeder\n# eine einzigartige Permutation darstellt. Die Permutationen sind in aufsteigender Reihenfolge sortiert.\n#\n# Beispiel:\n# >>> generate_four_digit_permutations(1, 2, 3, 4)\n# [\"1234\", \"1243\", \"1324\", \"1342\", \"1423\", \"1432\", ...]\n# >>> generate_four_digit_permutations(1, 2, 3, 5)\n# [\"1235\", \"1253\", \"1325\", \"1352\", \"1523\", \"1532\", ...]\n\n\ndef generate_four_digit_permutations(*digits)",
      "ha": "# Yana samar da dukkan abubuwan permutations na musamman na lamba huɗu ta amfani da lambobin huɗu da aka bayar.\n# Ana amfani da kowace lamba sau ɗaya kawai a kowane permutation. Aiki yana karɓar lambobi huɗu a matsayin hujjoji\n# kuma yana mayar da jerin kirtani, kowanne yana wakiltar permutation na musamman. Ana tsara permutations a cikin tsari mai hawa.\n#\n# Misali:\n# >>> generate_four_digit_permutations(1, 2, 3, 4)\n# [\"1234\", \"1243\", \"1324\", \"1342\", \"1423\", \"1432\", ...]\n# >>> generate_four_digit_permutations(1, 2, 3, 5)\n# [\"1235\", \"1253\", \"1325\", \"1352\", \"1523\", \"1532\", ...]\n\n\ndef generate_four_digit_permutations(*digits)",
      "hi": "# दिए गए चार अंकों का उपयोग करके सभी अद्वितीय चार-अंकीय क्रमचयों का निर्माण करता है।\n# प्रत्येक क्रमचय में प्रत्येक अंक का उपयोग केवल एक बार किया जाता है। फ़ंक्शन\n# चार पूर्णांकों को तर्क के रूप में स्वीकार करता है और स्ट्रिंग्स की एक array लौटाता है,\n# जिनमें से प्रत्येक एक अद्वितीय क्रमचय का प्रतिनिधित्व करता है। क्रमचय आरोही क्रम में\n# व्यवस्थित होते हैं।\n#\n# उदाहरण:\n# >>> generate_four_digit_permutations(1, 2, 3, 4)\n# [\"1234\", \"1243\", \"1324\", \"1342\", \"1423\", \"1432\", ...]\n# >>> generate_four_digit_permutations(1, 2, 3, 5)\n# [\"1235\", \"1253\", \"1325\", \"1352\", \"1523\", \"1532\", ...]\n\n\ndef generate_four_digit_permutations(*digits)",
      "hu": "# Generálja az összes egyedi négyjegyű permutációt a megadott négy számjegy felhasználásával.\n# Minden számjegy pontosan egyszer szerepel minden permutációban. A függvény négy egész számot\n# fogad el argumentumként, és egy karakterláncokból álló tömböt ad vissza, amelyek mindegyike\n# egyedi permutációt képvisel. A permutációk növekvő sorrendben vannak rendezve.\n#\n# Példa:\n# >>> generate_four_digit_permutations(1, 2, 3, 4)\n# [\"1234\", \"1243\", \"1324\", \"1342\", \"1423\", \"1432\", ...]\n# >>> generate_four_digit_permutations(1, 2, 3, 5)\n# [\"1235\", \"1253\", \"1325\", \"1352\", \"1523\", \"1532\", ...]\n\n\ndef generate_four_digit_permutations(*digits)"
    },
    "prompt_bertscore": {
      "sq": "0.9971035717837493",
      "hy": "0.966944329248936",
      "bn": "0.9657438072259611",
      "bg": "0.981712696709261",
      "zh": "0.978866521979412",
      "fr": "1",
      "de": "0.9823959852200209",
      "ha": "0.974396941145365",
      "hi": "0.9788555973084552",
      "hu": "0.989131740071295"
    },
    "canonical_solution": "    permutations = digits.permutation(4).to_a\n    permutations.map! { |perm| perm.join }\n    permutations.sort\n  end",
    "instruction": {
      "en": "Write a ruby function `def generate_four_digit_permutations(*digits)` to solve the following problem:\nGenerates all unique four-digit permutations using the given four digits.\nEach digit is used exactly once in each permutation. The function accepts\nfour integers as arguments and returns an array of strings, each representing\na unique permutation. The permutations are sorted in ascending order.\n\nExample:\n>>> generate_four_digit_permutations(1, 2, 3, 4)\n[\"1234\", \"1243\", \"1324\", \"1342\", \"1423\", \"1432\", ...]\n>>> generate_four_digit_permutations(1, 2, 3, 5)\n[\"1235\", \"1253\", \"1325\", \"1352\", \"1523\", \"1532\", ...]",
      "sq": "Shkruani një funksion ruby `def generate_four_digit_permutations(*digits)` për të zgjidhur problemin e mëposhtëm:\nGjeneron të gjitha permutacionet unike me katër shifra duke përdorur katër shifrat e dhëna.\nÇdo shifër përdoret saktësisht një herë në secilën permutacion. Funksioni pranon\nkatër numra të plotë si argumente dhe kthen një varg me vargje, secila që përfaqëson\nnjë permutacion unik. Permutacionet janë të renditura në rend rritës.\n\nShembull:\n>>> generate_four_digit_permutations(1, 2, 3, 4)\n[\"1234\", \"1243\", \"1324\", \"1342\", \"1423\", \"1432\", ...]\n>>> generate_four_digit_permutations(1, 2, 3, 5)\n[\"1235\", \"1253\", \"1325\", \"1352\", \"1523\", \"1532\", ...]",
      "hy": "Գրեք ruby ֆունկցիա `def generate_four_digit_permutations(*digits)` հետևյալ խնդիրը լուծելու համար:\nԳեներացնում է բոլոր եզակի չորսանիշ կոմբինացիաները օգտագործելով տրված չորս թվանշանները:\nՅուրաքանչյուր թվանշան օգտագործվում է ճիշտ մեկ անգամ յուրաքանչյուր կոմբինացիայում: Ֆունկցիան ընդունում է\nչորս ամբողջ թիվ որպես արգումենտ և վերադարձնում է տողերի զանգված, որոնցից յուրաքանչյուրը ներկայացնում է\nեզակի կոմբինացիա: Կոմբինացիաները դասավորված են աճման կարգով:\n\nՕրինակ:\n>>> generate_four_digit_permutations(1, 2, 3, 4)\n[\"1234\", \"1243\", \"1324\", \"1342\", \"1423\", \"1432\", ...]\n>>> generate_four_digit_permutations(1, 2, 3, 5)\n[\"1235\", \"1253\", \"1325\", \"1352\", \"1523\", \"1532\", ...]",
      "bn": "রুবি ফাংশন `def generate_four_digit_permutations(*digits)` লিখুন নিম্নলিখিত সমস্যার সমাধানের জন্য:\nপ্রদত্ত চারটি অঙ্ক ব্যবহার করে সমস্ত অনন্য চার-অঙ্কের বিন্যাস তৈরি করে।\nপ্রতিটি বিন্যাসে প্রতিটি অঙ্ক একবারই ব্যবহৃত হয়। ফাংশনটি\nচারটি পূর্ণসংখ্যা আর্গুমেন্ট হিসেবে গ্রহণ করে এবং একটি স্ট্রিং-এর অ্যারে ফেরত দেয়, প্রতিটি\nএকটি অনন্য বিন্যাস উপস্থাপন করে। বিন্যাসগুলি ঊর্ধ্বক্রমে সাজানো থাকে।\n\nউদাহরণ:\n>>> generate_four_digit_permutations(1, 2, 3, 4)\n[\"1234\", \"1243\", \"1324\", \"1342\", \"1423\", \"1432\", ...]\n>>> generate_four_digit_permutations(1, 2, 3, 5)\n[\"1235\", \"1253\", \"1325\", \"1352\", \"1523\", \"1532\", ...]",
      "bg": "Напишете Ruby функция `def generate_four_digit_permutations(*digits)`, за да решите следния проблем:\nГенерира всички уникални четирицифрени пермутации, използвайки дадените четири цифри.\nВсяка цифра се използва точно веднъж във всяка пермутация. Функцията приема\nчетири цели числа като аргументи и връща масив от низове, всеки от които представлява\nуникална пермутация. Пермутациите са сортирани във възходящ ред.\n\nПример:\n>>> generate_four_digit_permutations(1, 2, 3, 4)\n[\"1234\", \"1243\", \"1324\", \"1342\", \"1423\", \"1432\", ...]\n>>> generate_four_digit_permutations(1, 2, 3, 5)\n[\"1235\", \"1253\", \"1325\", \"1352\", \"1523\", \"1532\", ...]",
      "zh": "编写一个 ruby 函数 `def generate_four_digit_permutations(*digits)` 来解决以下问题：\n生成使用给定四个数字的所有唯一的四位数排列。\n每个数字在每个排列中只使用一次。函数接受四个整数作为参数，并返回一个字符串数组，每个字符串代表一个唯一的排列。排列按升序排序。\n\n示例：\n>>> generate_four_digit_permutations(1, 2, 3, 4)\n[\"1234\", \"1243\", \"1324\", \"1342\", \"1423\", \"1432\", ...]\n>>> generate_four_digit_permutations(1, 2, 3, 5)\n[\"1235\", \"1253\", \"1325\", \"1352\", \"1523\", \"1532\", ...]",
      "fr": "Écrire une fonction ruby `def generate_four_digit_permutations(*digits)` pour résoudre le problème suivant :\nGénère toutes les permutations uniques à quatre chiffres en utilisant les quatre chiffres donnés.\nChaque chiffre est utilisé exactement une fois dans chaque permutation. La fonction accepte\nquatre entiers comme arguments et renvoie un tableau de chaînes de caractères, chacune représentant\nune permutation unique. Les permutations sont triées par ordre croissant.\n\nExemple :\n>>> generate_four_digit_permutations(1, 2, 3, 4)\n[\"1234\", \"1243\", \"1324\", \"1342\", \"1423\", \"1432\", ...]\n>>> generate_four_digit_permutations(1, 2, 3, 5)\n[\"1235\", \"1253\", \"1325\", \"1352\", \"1523\", \"1532\", ...]",
      "de": "Schreiben Sie eine Ruby-Funktion `def generate_four_digit_permutations(*digits)`, um das folgende Problem zu lösen:\nGeneriert alle einzigartigen vierstelligen Permutationen unter Verwendung der gegebenen vier Ziffern.\nJede Ziffer wird in jeder Permutation genau einmal verwendet. Die Funktion akzeptiert\nvier ganze Zahlen als Argumente und gibt ein Array von Zeichenfolgen zurück, von denen jede\neine einzigartige Permutation darstellt. Die Permutationen sind in aufsteigender Reihenfolge sortiert.\n\nBeispiel:\n>>> generate_four_digit_permutations(1, 2, 3, 4)\n[\"1234\", \"1243\", \"1324\", \"1342\", \"1423\", \"1432\", ...]\n>>> generate_four_digit_permutations(1, 2, 3, 5)\n[\"1235\", \"1253\", \"1325\", \"1352\", \"1523\", \"1532\", ...]",
      "ha": "Rubuta aikin ruby `def generate_four_digit_permutations(*digits)` don warware matsalar mai zuwa:\nƘirƙiri dukkan na musamman permutations na lambobi huɗu ta amfani da lambobi huɗu da aka bayar.\nAna amfani da kowane lamba sau ɗaya kawai a kowane permutation. Aikin yana karɓar lambobi huɗu a matsayin hujjoji kuma yana dawo da jerin kirtani, kowanne yana wakiltar permutation na musamman. Ana tsara permutations a cikin tsari mai hawa.\n\nMisali:\n>>> generate_four_digit_permutations(1, 2, 3, 4)\n[\"1234\", \"1243\", \"1324\", \"1342\", \"1423\", \"1432\", ...]\n>>> generate_four_digit_permutations(1, 2, 3, 5)\n[\"1235\", \"1253\", \"1325\", \"1352\", \"1523\", \"1532\", ...]",
      "hi": "रूबी फ़ंक्शन `def generate_four_digit_permutations(*digits)` लिखें ताकि निम्नलिखित समस्या का समाधान किया जा सके:\nदिए गए चार अंकों का उपयोग करके सभी अद्वितीय चार-अंकीय क्रमचय उत्पन्न करता है।\nप्रत्येक क्रमचय में प्रत्येक अंक का उपयोग ठीक एक बार किया जाता है। फ़ंक्शन\nचार पूर्णांक को तर्क के रूप में स्वीकार करता है और स्ट्रिंग्स की एक सरणी लौटाता है, जिनमें से प्रत्येक\nएक अद्वितीय क्रमचय का प्रतिनिधित्व करता है। क्रमचयों को आरोही क्रम में क्रमबद्ध किया जाता है।\n\nउदाहरण:\n>>> generate_four_digit_permutations(1, 2, 3, 4)\n[\"1234\", \"1243\", \"1324\", \"1342\", \"1423\", \"1432\", ...]\n>>> generate_four_digit_permutations(1, 2, 3, 5)\n[\"1235\", \"1253\", \"1325\", \"1352\", \"1523\", \"1532\", ...]",
      "hu": "Írj egy ruby függvényt `def generate_four_digit_permutations(*digits)` a következő probléma megoldására:\nGenerálja az összes egyedi négyjegyű permutációt a megadott négy számjegy felhasználásával.\nMinden számjegy pontosan egyszer szerepel minden permutációban. A függvény négy egész számot fogad el argumentumként, és egy karakterláncokat tartalmazó tömböt ad vissza, amelyek mindegyike egy egyedi permutációt képvisel. A permutációk növekvő sorrendben vannak rendezve.\n\nPélda:\n>>> generate_four_digit_permutations(1, 2, 3, 4)\n[\"1234\", \"1243\", \"1324\", \"1342\", \"1423\", \"1432\", ...]\n>>> generate_four_digit_permutations(1, 2, 3, 5)\n[\"1235\", \"1253\", \"1325\", \"1352\", \"1523\", \"1532\", ...]"
    },
    "instruction_bertscore": {
      "sq": "1",
      "hy": "0.9706934776909695",
      "bn": "0.9896515557784633",
      "bg": "0.9967792083715193",
      "zh": "0.9879747181017668",
      "fr": "0.9987520053159578",
      "de": "0.9913142906981064",
      "ha": "0.9794814816390961",
      "hi": "0.9864885655908638",
      "hu": "0.9927342992921249"
    },
    "level": "easy",
    "test": "raise 'Test failed' unless generate_four_digit_permutations(1, 2, 3, 4) == [\"1234\", \"1243\", \"1324\", \"1342\", \"1423\", \"1432\", \"2134\", \"2143\", \"2314\", \"2341\", \"2413\", \"2431\", \"3124\", \"3142\", \"3214\", \"3241\", \"3412\", \"3421\", \"4123\", \"4132\", \"4213\", \"4231\", \"4312\", \"4321\"]\n\nraise 'Test failed' unless generate_four_digit_permutations(1, 2, 3, 5) == [\"1235\", \"1253\", \"1325\", \"1352\", \"1523\", \"1532\", \"2135\", \"2153\", \"2315\", \"2351\", \"2513\", \"2531\", \"3125\", \"3152\", \"3215\", \"3251\", \"3512\", \"3521\", \"5123\", \"5132\", \"5213\", \"5231\", \"5312\", \"5321\"]\n   \n\n\nputs 'All tests passed!'",
    "entry_point": "generate_four_digit_permutations",
    "signature": "def generate_four_digit_permutations(*digits)",
    "docstring": {
      "en": "Generates all unique four-digit permutations using the given four digits.\nEach digit is used exactly once in each permutation. The function accepts\nfour integers as arguments and returns an array of strings, each representing\na unique permutation. The permutations are sorted in ascending order.\n\nExample:\n>>> generate_four_digit_permutations(1, 2, 3, 4)\n[\"1234\", \"1243\", \"1324\", \"1342\", \"1423\", \"1432\", ...]\n>>> generate_four_digit_permutations(1, 2, 3, 5)\n[\"1235\", \"1253\", \"1325\", \"1352\", \"1523\", \"1532\", ...]",
      "sq": "Gjeneron të gjitha permutacionet unike me katër shifra duke përdorur katër shifrat e dhëna. Çdo shifër përdoret saktësisht një herë në secilën permutacion. Funksioni pranon katër numra të plotë si argumente dhe kthen një varg me vargje, secila që përfaqëson një permutacion unik. Permutacionet janë të renditura në rend rritës.\n\nShembull:\n>>> generate_four_digit_permutations(1, 2, 3, 4)\n[\"1234\", \"1243\", \"1324\", \"1342\", \"1423\", \"1432\", ...]\n>>> generate_four_digit_permutations(1, 2, 3, 5)\n[\"1235\", \"1253\", \"1325\", \"1352\", \"1523\", \"1532\", ...]",
      "hy": "Ստեղծում է բոլոր եզակի քառանիշ փոխատեղումները օգտագործելով տրված չորս թվանշանները։ Յուրաքանչյուր թվանշան օգտագործվում է ճիշտ մեկ անգամ յուրաքանչյուր փոխատեղման մեջ։ Ֆունկցիան ընդունում է չորս ամբողջ թիվ որպես արգումենտ և վերադարձնում է տողերի զանգված, որոնցից յուրաքանչյուրը ներկայացնում է եզակի փոխատեղում։ Փոխատեղումները դասավորված են աճման կարգով։\n\nՕրինակ:\n>>> generate_four_digit_permutations(1, 2, 3, 4)\n[\"1234\", \"1243\", \"1324\", \"1342\", \"1423\", \"1432\", ...]\n>>> generate_four_digit_permutations(1, 2, 3, 5)\n[\"1235\", \"1253\", \"1325\", \"1352\", \"1523\", \"1532\", ...]",
      "bn": "প্রদত্ত চারটি অঙ্ক ব্যবহার করে সমস্ত অনন্য চার-অঙ্কের বিন্যাস তৈরি করে। প্রতিটি বিন্যাসে প্রতিটি অঙ্ক ঠিক একবার ব্যবহার করা হয়। ফাংশনটি চারটি পূর্ণসংখ্যা আর্গুমেন্ট হিসাবে গ্রহণ করে এবং একটি স্ট্রিংয়ের অ্যারে ফেরত দেয়, প্রতিটি একটি অনন্য বিন্যাস উপস্থাপন করে। বিন্যাসগুলি ঊর্ধ্বক্রমে সাজানো থাকে।\n\nউদাহরণ:\n>>> generate_four_digit_permutations(1, 2, 3, 4)\n[\"1234\", \"1243\", \"1324\", \"1342\", \"1423\", \"1432\", ...]\n>>> generate_four_digit_permutations(1, 2, 3, 5)\n[\"1235\", \"1253\", \"1325\", \"1352\", \"1523\", \"1532\", ...]",
      "bg": "Генерира всички уникални четирицифрени пермутации, използвайки дадените четири цифри. Всяка цифра се използва точно веднъж във всяка пермутация. Функцията приема четири цели числа като аргументи и връща масив от низове, всеки от които представлява уникална пермутация. Пермутациите са сортирани във възходящ ред.\n\nПример:\n>>> generate_four_digit_permutations(1, 2, 3, 4)\n[\"1234\", \"1243\", \"1324\", \"1342\", \"1423\", \"1432\", ...]\n>>> generate_four_digit_permutations(1, 2, 3, 5)\n[\"1235\", \"1253\", \"1325\", \"1352\", \"1523\", \"1532\", ...]",
      "zh": "生成所有使用给定四个数字的唯一四位数排列。每个排列中每个数字仅使用一次。该函数接受四个整数作为参数，并返回一个字符串数组，每个字符串表示一个唯一的排列。排列按升序排序。\n\n示例：\n>>> generate_four_digit_permutations(1, 2, 3, 4)\n[\"1234\", \"1243\", \"1324\", \"1342\", \"1423\", \"1432\", ...]\n>>> generate_four_digit_permutations(1, 2, 3, 5)\n[\"1235\", \"1253\", \"1325\", \"1352\", \"1523\", \"1532\", ...]",
      "fr": "Génère toutes les permutations uniques à quatre chiffres en utilisant les quatre chiffres donnés. Chaque chiffre est utilisé exactement une fois dans chaque permutation. La fonction accepte quatre entiers en tant qu'arguments et renvoie un tableau de chaînes, chacune représentant une permutation unique. Les permutations sont triées par ordre croissant.\n\nExemple :\n>>> generate_four_digit_permutations(1, 2, 3, 4)\n[\"1234\", \"1243\", \"1324\", \"1342\", \"1423\", \"1432\", ...]\n>>> generate_four_digit_permutations(1, 2, 3, 5)\n[\"1235\", \"1253\", \"1325\", \"1352\", \"1523\", \"1532\", ...]",
      "de": "Erzeugt alle einzigartigen vierstelligen Permutationen mit den gegebenen vier Ziffern. Jede Ziffer wird in jeder Permutation genau einmal verwendet. Die Funktion akzeptiert vier ganze Zahlen als Argumente und gibt ein Array von Strings zurück, wobei jeder String eine einzigartige Permutation darstellt. Die Permutationen sind in aufsteigender Reihenfolge sortiert.\n\nBeispiel:\n>>> generate_four_digit_permutations(1, 2, 3, 4)\n[\"1234\", \"1243\", \"1324\", \"1342\", \"1423\", \"1432\", ...]\n>>> generate_four_digit_permutations(1, 2, 3, 5)\n[\"1235\", \"1253\", \"1325\", \"1352\", \"1523\", \"1532\", ...]",
      "ha": "Yana haifar da dukkan abubuwan haɗin lamba huɗu na musamman ta amfani da lambobin huɗu da aka bayar. Ana amfani da kowace lamba sau ɗaya kawai a kowane haɗin. Aikin yana karɓar lambobi huɗu a matsayin hujjoji kuma yana mayar da jerin kirtani, kowanne yana wakiltar haɗin na musamman. Ana tsara abubuwan haɗin a cikin tsari mai hawa.\n\nMisali:\n>>> generate_four_digit_permutations(1, 2, 3, 4)\n[\"1234\", \"1243\", \"1324\", \"1342\", \"1423\", \"1432\", ...]\n>>> generate_four_digit_permutations(1, 2, 3, 5)\n[\"1235\", \"1253\", \"1325\", \"1352\", \"1523\", \"1532\", ...]",
      "hi": "दिए गए चार अंकों का उपयोग करके सभी अद्वितीय चार-अंकीय क्रमचय उत्पन्न करता है। प्रत्येक क्रमचय में प्रत्येक अंक का उपयोग ठीक एक बार किया जाता है। यह फ़ंक्शन चार पूर्णांकों को तर्क के रूप में स्वीकार करता है और स्ट्रिंग्स की एक सरणी लौटाता है, जिनमें से प्रत्येक एक अद्वितीय क्रमचय का प्रतिनिधित्व करती है। क्रमचय आरोही क्रम में व्यवस्थित होते हैं।\n\nउदाहरण:\n>>> generate_four_digit_permutations(1, 2, 3, 4)\n[\"1234\", \"1243\", \"1324\", \"1342\", \"1423\", \"1432\", ...]\n>>> generate_four_digit_permutations(1, 2, 3, 5)\n[\"1235\", \"1253\", \"1325\", \"1352\", \"1523\", \"1532\", ...]",
      "hu": "Generálja az összes egyedi négyjegyű permutációt a megadott négy számjegy felhasználásával. Minden számjegy pontosan egyszer szerepel minden permutációban. A függvény négy egész számot fogad el argumentumként, és egy karakterláncokat tartalmazó tömböt ad vissza, amelyek mindegyike egy egyedi permutációt képvisel. A permutációk növekvő sorrendben vannak rendezve.\n\nPélda:\n>>> generate_four_digit_permutations(1, 2, 3, 4)\n[\"1234\", \"1243\", \"1324\", \"1342\", \"1423\", \"1432\", ...]\n>>> generate_four_digit_permutations(1, 2, 3, 5)\n[\"1235\", \"1253\", \"1325\", \"1352\", \"1523\", \"1532\", ...]"
    },
    "docstring_bertscore": {
      "sq": "0.9965716396233378",
      "hy": "0.9910459410533283",
      "bn": "0.9497127464333973",
      "bg": "0.9986578545153473",
      "zh": "0.985162906427837",
      "fr": "0.997933052254951",
      "de": "0.9882919308202796",
      "ha": "0.9886683353923407",
      "hi": "0.9952428023742145",
      "hu": "0.9899238780308622"
    }
  },
  {
    "task_id": "Ruby/34",
    "prompt": {
      "en": "# Counts the number of numbers less than or equal to n that are either multiples of 7 or contain the digit '7'.\n# The function takes a single argument, n, which is a positive integer, and returns the count of numbers \n# that are related to 7 as per the criteria.\n#\n# Example:\n# >>> count_seven_related_numbers(20)\n# 3\n# >>> count_seven_related_numbers(15)\n# 2\n\ndef count_seven_related_numbers(n)",
      "sq": "# Numëron numrin e numrave më të vegjël ose të barabartë me n që janë ose shumëfish i 7 ose përmbajnë shifrën '7'.\n# Funksioni merr një argument të vetëm, n, që është një numër i plotë pozitiv, dhe kthen numrin e numrave\n# që janë të lidhur me 7 sipas kritereve.\n#\n# Shembull:\n# >>> count_seven_related_numbers(20)\n# 3\n# >>> count_seven_related_numbers(15)\n# 2\n\ndef count_seven_related_numbers(n)",
      "hy": "# Հաշվում է այն թվերի քանակը, որոնք փոքր կամ հավասար են n-ին և կամ 7-ի բազմապատիկ են, կամ պարունակում են '7' թվանշանը։\n# Ֆունկցիան ընդունում է մեկ արգումենտ՝ n, որը դրական ամբողջ թիվ է, և վերադարձնում է այն թվերի քանակը,\n# որոնք կապված են 7-ի հետ ըստ չափանիշների։\n#\n# Օրինակ:\n# >>> count_seven_related_numbers(20)\n# 3\n# >>> count_seven_related_numbers(15)\n# 2\n\ndef count_seven_related_numbers(n)",
      "bn": "# n এর চেয়ে কম বা সমান সংখ্যাগুলির সংখ্যা গণনা করে যা হয় 7 এর গুণ বা '7' অঙ্কটি ধারণ করে।\n# ফাংশনটি একটি একক আর্গুমেন্ট গ্রহণ করে, n, যা একটি ধনাত্মক পূর্ণসংখ্যা, এবং 7 সম্পর্কিত সংখ্যাগুলির সংখ্যা \n# ফেরত দেয় নির্ধারিত মানদণ্ড অনুযায়ী।\n#\n# উদাহরণ:\n# >>> count_seven_related_numbers(20)\n# 3\n# >>> count_seven_related_numbers(15)\n# 2\n\ndef count_seven_related_numbers(n)",
      "bg": "# Брои броя на числата, по-малки или равни на n, които са или кратни на 7, или съдържат цифрата '7'.\n# Функцията приема един аргумент, n, който е положително цяло число, и връща броя на числата,\n# които са свързани със 7 според критериите.\n#\n# Пример:\n# >>> count_seven_related_numbers(20)\n# 3\n# >>> count_seven_related_numbers(15)\n# 2\n\ndef count_seven_related_numbers(n)",
      "zh": "# 计算小于或等于 n 的数字中是 7 的倍数或包含数字 '7' 的数量。\n# 该函数接受一个参数 n，它是一个正整数，并返回符合条件的与 7 相关的数字的计数。\n#\n# 示例:\n# >>> count_seven_related_numbers(20)\n# 3\n# >>> count_seven_related_numbers(15)\n# 2\n\ndef count_seven_related_numbers(n)",
      "fr": "# Compte le nombre de nombres inférieurs ou égaux à n qui sont soit des multiples de 7, soit contiennent le chiffre '7'.\n# La fonction prend un seul argument, n, qui est un entier positif, et renvoie le compte des nombres\n# qui sont liés à 7 selon les critères.\n#\n# Exemple :\n# >>> count_seven_related_numbers(20)\n# 3\n# >>> count_seven_related_numbers(15)\n# 2\n\ndef count_seven_related_numbers(n)",
      "de": "# Zählt die Anzahl der Zahlen kleiner oder gleich n, die entweder Vielfache von 7 sind oder die Ziffer '7' enthalten.\n# Die Funktion nimmt ein einzelnes Argument, n, das eine positive ganze Zahl ist, und gibt die Anzahl der Zahlen zurück,\n# die gemäß den Kriterien mit 7 in Beziehung stehen.\n#\n# Beispiel:\n# >>> count_seven_related_numbers(20)\n# 3\n# >>> count_seven_related_numbers(15)\n# 2\n\ndef count_seven_related_numbers(n)",
      "ha": "# Yana ƙididdige adadin lambobin da suka fi ƙasa ko daidai da n waɗanda ko dai masu yawa ne na 7 ko kuma suna ɗauke da lambar '7'.\n# Aikin yana ɗaukar hujja guda ɗaya, n, wanda yake lamba ce mai kyau, kuma yana dawo da ƙididdigar lambobin \n# da suka danganci 7 bisa ga ƙa'idodin.\n#\n# Misali:\n# >>> count_seven_related_numbers(20)\n# 3\n# >>> count_seven_related_numbers(15)\n# 2\n\ndef count_seven_related_numbers(n)",
      "hi": "# उन संख्याओं की गणना करता है जो n से कम या बराबर हैं और या तो 7 के गुणज हैं या जिनमें अंक '7' शामिल है।\n# फ़ंक्शन एकल तर्क n लेता है, जो एक धनात्मक पूर्णांक है, और उन संख्याओं की गणना लौटाता है\n# जो दिए गए मानदंडों के अनुसार 7 से संबंधित हैं।\n#\n# उदाहरण:\n# >>> count_seven_related_numbers(20)\n# 3\n# >>> count_seven_related_numbers(15)\n# 2\n\ndef count_seven_related_numbers(n)",
      "hu": "# Megszámolja azokat a számokat, amelyek kisebbek vagy egyenlőek n-nel, és amelyek vagy 7 többszörösei, vagy tartalmazzák a '7' számjegyet.\n# A függvény egyetlen argumentumot vesz fel, n-t, amely egy pozitív egész szám, és visszaadja azon számok számát,\n# amelyek a megadott kritériumok szerint 7-hez kapcsolódnak.\n#\n# Példa:\n# >>> count_seven_related_numbers(20)\n# 3\n# >>> count_seven_related_numbers(15)\n# 2\n\ndef count_seven_related_numbers(n)"
    },
    "prompt_bertscore": {
      "sq": "0.9905880980250429",
      "hy": "0.9853613381784908",
      "bn": "0.9738739473521001",
      "bg": "0.9832759178080055",
      "zh": "0.9517528790770067",
      "fr": "0.9978400932366266",
      "de": "0.9978400932366266",
      "ha": "0.9865112094543018",
      "hi": "0.979794125858845",
      "hu": "0.9822615124520604"
    },
    "canonical_solution": "    count = 0\n    (1..n).each do |num|\n      count += 1 if num % 7 == 0 || num.to_s.include?('7')\n    end\n    count\n  end",
    "instruction": {
      "en": "Write a ruby function `def count_seven_related_numbers(n)` to solve the following problem:\nCounts the number of numbers less than or equal to n that are either multiples of 7 or contain the digit '7'.\nThe function takes a single argument, n, which is a positive integer, and returns the count of numbers\nthat are related to 7 as per the criteria.\n\nExample:\n>>> count_seven_related_numbers(20)\n3\n>>> count_seven_related_numbers(15)\n2",
      "sq": "Shkruani një funksion ruby `def count_seven_related_numbers(n)` për të zgjidhur problemin në vijim:\nNumëron numrin e numrave më të vegjël ose të barabartë me n që janë ose shumëfish i 7 ose përmbajnë shifrën '7'.\nFunksioni merr një argument të vetëm, n, i cili është një numër i plotë pozitiv, dhe kthen numrin e numrave\nqë janë të lidhur me 7 sipas kritereve.\n\nShembull:\n>>> count_seven_related_numbers(20)\n3\n>>> count_seven_related_numbers(15)\n2",
      "hy": "Գրեք ruby ֆունկցիա `def count_seven_related_numbers(n)`՝ հետևյալ խնդիրը լուծելու համար:\nՀաշվում է n-ից փոքր կամ հավասար թվերի քանակը, որոնք կամ 7-ի բազմապատիկ են, կամ պարունակում են '7' թվանշանը:\nՖունկցիան ընդունում է մեկ արգումենտ՝ n, որը դրական ամբողջ թիվ է, և վերադարձնում է թվերի քանակը,\nորոնք կապված են 7-ի հետ նշված չափանիշներով:\n\nՕրինակ:\n>>> count_seven_related_numbers(20)\n3\n>>> count_seven_related_numbers(15)\n2",
      "bn": "রুবি ফাংশন `def count_seven_related_numbers(n)` লিখুন নিম্নলিখিত সমস্যার সমাধানের জন্য:\nn এর চেয়ে কম বা সমান সংখ্যাগুলির সংখ্যা গণনা করে যা হয় 7 এর গুণিতক বা '7' সংখ্যা ধারণ করে।\nফাংশনটি একটি একক আর্গুমেন্ট গ্রহণ করে, n, যা একটি ধনাত্মক পূর্ণসংখ্যা, এবং সংখ্যা গণনা করে ফেরত দেয়\nযা নির্ধারিত মানদণ্ড অনুযায়ী 7 এর সাথে সম্পর্কিত।\n\nউদাহরণ:\n>>> count_seven_related_numbers(20)\n3\n>>> count_seven_related_numbers(15)\n2",
      "bg": "Напишете Ruby функция `def count_seven_related_numbers(n)`, за да решите следния проблем:\nБрои броя на числата, които са по-малки или равни на n и са или кратни на 7, или съдържат цифрата '7'.\nФункцията приема един аргумент, n, който е положително цяло число, и връща броя на числата,\nкоито са свързани със 7 според критериите.\n\nПример:\n>>> count_seven_related_numbers(20)\n3\n>>> count_seven_related_numbers(15)\n2",
      "zh": "编写一个 ruby 函数 `def count_seven_related_numbers(n)` 来解决以下问题：  \n计算小于或等于 n 的数字中是 7 的倍数或包含数字 '7' 的数量。  \n该函数接受一个参数 n，它是一个正整数，并返回符合条件的与 7 相关的数字的数量。\n\n示例：  \n>>> count_seven_related_numbers(20)  \n3  \n>>> count_seven_related_numbers(15)  \n2  ",
      "fr": "Écrire une fonction ruby `def count_seven_related_numbers(n)` pour résoudre le problème suivant :  \nCompte le nombre de nombres inférieurs ou égaux à n qui sont soit des multiples de 7, soit contiennent le chiffre '7'.  \nLa fonction prend un seul argument, n, qui est un entier positif, et renvoie le compte des nombres  \nqui sont liés à 7 selon les critères.\n\nExemple :\n>>> count_seven_related_numbers(20)\n3\n>>> count_seven_related_numbers(15)\n2",
      "de": "Schreiben Sie eine Ruby-Funktion `def count_seven_related_numbers(n)`, um das folgende Problem zu lösen:\nZählt die Anzahl der Zahlen, die kleiner oder gleich n sind und entweder Vielfache von 7 sind oder die Ziffer '7' enthalten.\nDie Funktion nimmt ein einzelnes Argument, n, das eine positive ganze Zahl ist, und gibt die Anzahl der Zahlen zurück,\ndie gemäß den Kriterien mit 7 verwandt sind.\n\nBeispiel:\n>>> count_seven_related_numbers(20)\n3\n>>> count_seven_related_numbers(15)\n2",
      "ha": "Rubuta aikin ruby `def count_seven_related_numbers(n)` don warware matsalar mai zuwa:  \nYana ƙidaya adadin lambobin da suka yi ƙasa ko daidai da n waɗanda ko dai sau na 7 ne ko kuma suna ɗauke da lamba '7'.  \nAikin yana ɗaukar hujja guda, n, wanda yake lamba mai kyau, kuma yana mayar da ƙidayar lambobin  \nda suka shafi 7 bisa ga ƙa'idar.  \n\nMisali:  \n>>> count_seven_related_numbers(20)  \n3  \n>>> count_seven_related_numbers(15)  \n2  ",
      "hi": "`def count_seven_related_numbers(n)` फ़ंक्शन लिखें ताकि निम्नलिखित समस्या का समाधान किया जा सके:\nउन संख्याओं की गिनती करें जो n से कम या बराबर हैं और या तो 7 के गुणज हैं या जिनमें अंक '7' शामिल है।\nयह फ़ंक्शन एक एकल तर्क लेता है, n, जो एक धनात्मक पूर्णांक है, और उन संख्याओं की गिनती लौटाता है\nजो दिए गए मानदंडों के अनुसार 7 से संबंधित हैं।\n\nउदाहरण:\n>>> count_seven_related_numbers(20)\n3\n>>> count_seven_related_numbers(15)\n2",
      "hu": "Készíts egy Ruby függvényt `def count_seven_related_numbers(n)` a következő probléma megoldására:\nSzámolja meg azokat a számokat, amelyek kisebbek vagy egyenlőek n-nel, és amelyek vagy 7 többszörösei, vagy tartalmazzák a '7' számjegyet.\nA függvény egyetlen argumentumot vesz fel, n-t, amely egy pozitív egész szám, és visszaadja a 7-hez kapcsolódó számok számát a megadott kritériumok szerint.\n\nPélda:\n>>> count_seven_related_numbers(20)\n3\n>>> count_seven_related_numbers(15)\n2"
    },
    "instruction_bertscore": {
      "sq": "0.984594227646934",
      "hy": "0.9767544851378681",
      "bn": "0.9814236895048551",
      "bg": "0.9807117982192262",
      "zh": "0.9539985941649871",
      "fr": "0.9898626998735034",
      "de": "0.9866123123182485",
      "ha": "0.9808285928832746",
      "hi": "0.961746172177253",
      "hu": "0.9684485571245132"
    },
    "level": "easy",
    "test": "raise 'Test failed' unless count_seven_related_numbers(20) == 3\nraise 'Test failed' unless count_seven_related_numbers(15) == 2\nraise 'Test failed' unless count_seven_related_numbers(50) == 11\nraise 'Test failed' unless count_seven_related_numbers(28) == 6\nraise 'Test failed' unless count_seven_related_numbers(100) == 30\n  \n\nputs 'All tests passed!'",
    "entry_point": "count_seven_related_numbers",
    "signature": "def count_seven_related_numbers(n)",
    "docstring": {
      "en": "Counts the number of numbers less than or equal to n that are either multiples of 7 or contain the digit '7'.\nThe function takes a single argument, n, which is a positive integer, and returns the count of numbers\nthat are related to 7 as per the criteria.\n\nExample:\n>>> count_seven_related_numbers(20)\n3\n>>> count_seven_related_numbers(15)\n2",
      "sq": "Numëron numrin e numrave më të vegjël ose të barabartë me n që janë ose shumëfish i 7 ose përmbajnë shifrën '7'. Funksioni merr një argument të vetëm, n, i cili është një numër i plotë pozitiv, dhe kthen numrin e numrave që janë të lidhur me 7 sipas kritereve.\n\nShembull:\n>>> count_seven_related_numbers(20)\n3\n>>> count_seven_related_numbers(15)\n2",
      "hy": "Հաշվում է n-ից փոքր կամ հավասար թվերի քանակը, որոնք կամ 7-ի բազմապատիկ են կամ պարունակում են '7' թվանշանը:\nՖունկցիան ընդունում է մեկ արգումենտ՝ n, որը դրական ամբողջ թիվ է, և վերադարձնում է թվերի քանակը,\nորոնք կապված են 7-ի հետ նշված չափանիշներով:\n\nՕրինակ:\n>>> count_seven_related_numbers(20)\n3\n>>> count_seven_related_numbers(15)\n2",
      "bn": "সংখ্যাটি n এর চেয়ে ছোট বা সমান সংখ্যাগুলি গণনা করে যা হয় 7 এর গুণিতক বা '7' অঙ্কটি ধারণ করে।\nফাংশনটি একটি একক আর্গুমেন্ট গ্রহণ করে, n, যা একটি ধনাত্মক পূর্ণসংখ্যা, এবং সংখ্যাগুলির গণনা ফেরত দেয়\nযা নির্ধারিত মানদণ্ড অনুযায়ী 7 এর সাথে সম্পর্কিত।\nউদাহরণ:\n\n>>> count_seven_related_numbers(20)  \n3\n\n>>> count_seven_related_numbers(15)  \n2",
      "bg": "Брои броя на числата, по-малки или равни на n, които са или кратни на 7, или съдържат цифрата '7'. Функцията приема един аргумент, n, който е положително цяло число, и връща броя на числата, свързани със 7 според критериите.\n\nПример:\n>>> count_seven_related_numbers(20)\n3\n>>> count_seven_related_numbers(15)\n2",
      "zh": "计算小于或等于 n 的数字中是 7 的倍数或包含数字 '7' 的数量。\n该函数接受一个参数 n，它是一个正整数，并返回根据标准与 7 相关的数字的计数。\n\n示例：\n>>> count_seven_related_numbers(20)\n3\n>>> count_seven_related_numbers(15)\n2",
      "fr": "Compte le nombre de nombres inférieurs ou égaux à n qui sont soit des multiples de 7, soit contiennent le chiffre '7'.  \nLa fonction prend un seul argument, n, qui est un entier positif, et renvoie le compte des nombres  \nqui sont liés à 7 selon les critères.\n\nExemple :\n>>> count_seven_related_numbers(20)\n3\n>>> count_seven_related_numbers(15)\n2",
      "de": "Zählt die Anzahl der Zahlen, die kleiner oder gleich n sind und entweder Vielfache von 7 sind oder die Ziffer '7' enthalten.\nDie Funktion nimmt ein einzelnes Argument, n, das eine positive ganze Zahl ist, und gibt die Anzahl der Zahlen zurück,\ndie gemäß den Kriterien mit 7 in Beziehung stehen.\n\nBeispiel:\n>>> count_seven_related_numbers(20)\n3\n>>> count_seven_related_numbers(15)\n2",
      "ha": "Yana ƙididdige adadin lambobi da suka yi ƙasa da ko daidai da n waɗanda ko dai sau biyu na 7 ne ko kuma suna ɗauke da lamba '7'. \n\nAikin yana ɗaukar hujja guda ɗaya, n, wanda shi ne cikakken lamba mai kyau, kuma yana dawo da ƙididdigar lambobin da suka danganci 7 bisa ga ƙa'idodin.\n\nMisali:\n>>> count_seven_related_numbers(20)\n3\n>>> count_seven_related_numbers(15)\n2",
      "hi": "7 के गुणक हैं या जिनमें अंक '7' शामिल है, ऐसे n से कम या बराबर संख्याओं की गिनती करता है।  \nयह फ़ंक्शन एकल तर्क n लेता है, जो एक धनात्मक पूर्णांक है, और उन संख्याओं की गिनती लौटाता है  \nजो दिए गए मानदंडों के अनुसार 7 से संबंधित हैं।\n\nउदाहरण:\n>>> count_seven_related_numbers(20)\n3\n>>> count_seven_related_numbers(15)\n2",
      "hu": "Számolja meg azon számok számát, amelyek kisebbek vagy egyenlők n-nél, és amelyek vagy 7 többszörösei, vagy tartalmazzák a '7' számjegyet.\nA függvény egyetlen argumentumot vesz fel, n-t, amely egy pozitív egész szám, és visszaadja azon számok számát, amelyek a megadott kritériumok szerint kapcsolódnak a 7-hez.\n\nPélda:\n>>> count_seven_related_numbers(20)\n3\n>>> count_seven_related_numbers(15)\n2"
    },
    "docstring_bertscore": {
      "sq": "0.9972382431820909",
      "hy": "0.9778270891954565",
      "bn": "0.999999801369619",
      "bg": "0.9822861426193087",
      "zh": "0.9547907321245542",
      "fr": "0.9900073027908969",
      "de": "0.9860613116412578",
      "ha": "0.9830077667936085",
      "hi": "0.9267282318919453",
      "hu": "0.968003823701376"
    }
  },
  {
    "task_id": "Ruby/35",
    "prompt": {
      "en": "# Finds all possible last two digits of a number that, when added to the number 'a',\n# makes it divisible by 'b'. The function takes two arguments, 'a' and 'b', where 'a' is \n# a positive integer less than 10000, and 'b' is a positive integer between 10 and 100.\n# The function returns an array of strings representing the possible two-digit suffixes.\n#\n# Example:\n# >>> find_possible_last_digits(200, 40)\n# [\"00\", \"40\", \"80\"]\n# >>> find_possible_last_digits(1992, 95)\n# [\"15\"]\n\ndef find_possible_last_digits(a, b)",
      "sq": "# Gjen të gjitha dy shifrat e fundit të mundshme të një numri që, kur i shtohen numrit 'a',\n# e bëjnë atë të plotpjesëtueshëm me 'b'. Funksioni merr dy argumente, 'a' dhe 'b', ku 'a' është\n# një numër i plotë pozitiv më pak se 10000, dhe 'b' është një numër i plotë pozitiv midis 10 dhe 100.\n# Funksioni kthen një varg me stringje që përfaqësojnë prapashtesat e mundshme me dy shifra.\n#\n# Shembull:\n# >>> find_possible_last_digits(200, 40)\n# [\"00\", \"40\", \"80\"]\n# >>> find_possible_last_digits(1992, 95)\n# [\"15\"]\n\ndef find_possible_last_digits(a, b)",
      "hy": "# Գտնում է թվի բոլոր հնարավոր վերջին երկու թվանշանները, որոնք, երբ գումարվում են 'a' թվին,\n# դարձնում են այն բաժանվող 'b'-ով: Ֆունկցիան ընդունում է երկու արգումենտ՝ 'a' և 'b', որտեղ 'a'-ն\n# դրական ամբողջ թիվ է, փոքր 10000-ից, իսկ 'b'-ն դրական ամբողջ թիվ է 10-ից 100-ի միջև:\n# Ֆունկցիան վերադարձնում է տողերի զանգված, որը ներկայացնում է հնարավոր երկու թվանշանների վերջավորությունները:\n#\n# Օրինակ:\n# >>> find_possible_last_digits(200, 40)\n# [\"00\", \"40\", \"80\"]\n# >>> find_possible_last_digits(1992, 95)\n# [\"15\"]\n\ndef find_possible_last_digits(a, b)",
      "bn": "# এমন সব সম্ভাব্য শেষ দুটি সংখ্যা খুঁজে বের করে যা সংখ্যাটির সাথে 'a' যোগ করলে,\n# 'b' দ্বারা বিভাজ্য হয়। ফাংশনটি দুটি আর্গুমেন্ট নেয়, 'a' এবং 'b', যেখানে 'a' হল \n# 10000 এর কম একটি ধনাত্মক পূর্ণসংখ্যা, এবং 'b' হল 10 এবং 100 এর মধ্যে একটি ধনাত্মক পূর্ণসংখ্যা।\n# ফাংশনটি সম্ভাব্য দুটি-অঙ্কের উপসর্গগুলির একটি অ্যারে রিটার্ন করে।\n#\n# উদাহরণ:\n# >>> find_possible_last_digits(200, 40)\n# [\"00\", \"40\", \"80\"]\n# >>> find_possible_last_digits(1992, 95)\n# [\"15\"]\n\ndef find_possible_last_digits(a, b)",
      "bg": "# Намира всички възможни последни две цифри на число, които, когато се добавят към числото 'a',\n# го правят делимо на 'b'. Функцията приема два аргумента, 'a' и 'b', където 'a' е\n# положително цяло число по-малко от 10000, а 'b' е положително цяло число между 10 и 100.\n# Функцията връща масив от низове, представляващи възможните двуцифрени суфикси.\n#\n# Пример:\n# >>> find_possible_last_digits(200, 40)\n# [\"00\", \"40\", \"80\"]\n# >>> find_possible_last_digits(1992, 95)\n# [\"15\"]\n\ndef find_possible_last_digits(a, b)",
      "zh": "# 找出所有可能的数字的最后两位，使其加上数字 'a' 后，\n# 可以被 'b' 整除。函数接受两个参数，'a' 和 'b'，其中 'a' 是\n# 小于 10000 的正整数，'b' 是介于 10 和 100 之间的正整数。\n# 函数返回一个字符串数组，表示可能的两位数后缀。\n#\n# 示例:\n# >>> find_possible_last_digits(200, 40)\n# [\"00\", \"40\", \"80\"]\n# >>> find_possible_last_digits(1992, 95)\n# [\"15\"]\n\ndef find_possible_last_digits(a, b)",
      "fr": "# Trouve tous les deux derniers chiffres possibles d'un nombre qui, lorsqu'ils sont ajoutés au nombre 'a',\n# le rendent divisible par 'b'. La fonction prend deux arguments, 'a' et 'b', où 'a' est\n# un entier positif inférieur à 10000, et 'b' est un entier positif entre 10 et 100.\n# La fonction renvoie un tableau de chaînes représentant les suffixes possibles à deux chiffres.\n#\n# Exemple :\n# >>> find_possible_last_digits(200, 40)\n# [\"00\", \"40\", \"80\"]\n# >>> find_possible_last_digits(1992, 95)\n# [\"15\"]\n\ndef find_possible_last_digits(a, b)",
      "de": "# Findet alle möglichen letzten zwei Ziffern einer Zahl, die, wenn sie zur Zahl 'a' hinzugefügt werden,\n# diese durch 'b' teilbar machen. Die Funktion nimmt zwei Argumente, 'a' und 'b', wobei 'a' \n# eine positive ganze Zahl kleiner als 10000 ist und 'b' eine positive ganze Zahl zwischen 10 und 100 ist.\n# Die Funktion gibt ein Array von Zeichenfolgen zurück, das die möglichen zweistelligen Suffixe darstellt.\n#\n# Beispiel:\n# >>> find_possible_last_digits(200, 40)\n# [\"00\", \"40\", \"80\"]\n# >>> find_possible_last_digits(1992, 95)\n# [\"15\"]\n\ndef find_possible_last_digits(a, b)",
      "ha": "# Nemi dukkan yiwuwar lambobin ƙarshe guda biyu na wata lamba wanda, idan aka ƙara shi da lambar 'a',\n# zai sa ta zama mai rarrabuwa da 'b'. Aiki yana ɗaukar hujjoji guda biyu, 'a' da 'b', inda 'a' \n# lamba ce mai kyau ƙasa da 10000, kuma 'b' lamba ce mai kyau tsakanin 10 da 100.\n# Aiki yana dawowa da jerin igiyoyi da ke wakiltar yiwuwar ƙarewa guda biyu.\n#\n# Misali:\n# >>> find_possible_last_digits(200, 40)\n# [\"00\", \"40\", \"80\"]\n# >>> find_possible_last_digits(1992, 95)\n# [\"15\"]\n\ndef find_possible_last_digits(a, b)",
      "hi": "# वह सभी संभावित अंतिम दो अंक खोजता है जो संख्या 'a' में जोड़ने पर,\n# उसे 'b' से विभाज्य बनाते हैं। यह फ़ंक्शन दो तर्क लेता है, 'a' और 'b', जहाँ 'a'\n# 10000 से कम एक धनात्मक पूर्णांक है, और 'b' 10 और 100 के बीच का एक धनात्मक पूर्णांक है।\n# फ़ंक्शन स्ट्रिंग्स की एक array लौटाता है जो संभावित दो-अंकीय प्रत्यय को दर्शाती है।\n#\n# उदाहरण:\n# >>> find_possible_last_digits(200, 40)\n# [\"00\", \"40\", \"80\"]\n# >>> find_possible_last_digits(1992, 95)\n# [\"15\"]\n\ndef find_possible_last_digits(a, b)",
      "hu": "# Megtalálja egy szám összes lehetséges utolsó két számjegyét, amely, ha hozzáadjuk az 'a' számhoz,\n# oszthatóvá teszi 'b'-vel. A függvény két argumentumot vesz fel, 'a' és 'b', ahol 'a' egy\n# pozitív egész szám, amely kisebb, mint 10000, és 'b' egy pozitív egész szám 10 és 100 között.\n# A függvény egy karakterláncokat tartalmazó tömböt ad vissza, amely a lehetséges kétjegyű végződéseket képviseli.\n#\n# Példa:\n# >>> find_possible_last_digits(200, 40)\n# [\"00\", \"40\", \"80\"]\n# >>> find_possible_last_digits(1992, 95)\n# [\"15\"]\n\ndef find_possible_last_digits(a, b)"
    },
    "prompt_bertscore": {
      "sq": "0.9960784403872281",
      "hy": "0.9856551125120414",
      "bn": "0.9647834293336575",
      "bg": "0.9994188075050919",
      "zh": "0.9655046562471951",
      "fr": "0.9917776953770608",
      "de": "0.9941274927847036",
      "ha": "0.9709896355890925",
      "hi": "0.976338553119981",
      "hu": "0.9896569187987513"
    },
    "canonical_solution": "    possible_digits = []\n    (0..99).each do |i|\n      suffix = '%02d' % i # Ensures a two-digit format\n      combined_number = (a.to_s + suffix).to_i\n      possible_digits << suffix if combined_number % b == 0\n    end\n    possible_digits\n  end",
    "instruction": {
      "en": "Write a ruby function `def find_possible_last_digits(a, b)` to solve the following problem:\nFinds all possible last two digits of a number that, when added to the number 'a',\nmakes it divisible by 'b'. The function takes two arguments, 'a' and 'b', where 'a' is\na positive integer less than 10000, and 'b' is a positive integer between 10 and 100.\nThe function returns an array of strings representing the possible two-digit suffixes.\n\nExample:\n>>> find_possible_last_digits(200, 40)\n[\"00\", \"40\", \"80\"]\n>>> find_possible_last_digits(1992, 95)\n[\"15\"]",
      "sq": "Shkruani një funksion ruby `def find_possible_last_digits(a, b)` për të zgjidhur problemin në vijim:\nGjen të gjitha dy shifrat e fundit të mundshme të një numri që, kur i shtohen numrit 'a',\ne bëjnë atë të pjesëtueshëm me 'b'. Funksioni merr dy argumente, 'a' dhe 'b', ku 'a' është\nnjë numër i plotë pozitiv më pak se 10000, dhe 'b' është një numër i plotë pozitiv midis 10 dhe 100.\nFunksioni kthen një varg me vargje që përfaqësojnë prapashtesat e mundshme me dy shifra.\n\nShembull:\n>>> find_possible_last_digits(200, 40)\n[\"00\", \"40\", \"80\"]\n>>> find_possible_last_digits(1992, 95)\n[\"15\"]",
      "hy": "Գրեք ruby ֆունկցիա `def find_possible_last_digits(a, b)` հետևյալ խնդիրը լուծելու համար:\nԳտնում է թվի բոլոր հնարավոր վերջին երկու թվանշանները, որոնք, երբ գումարվում են 'a' թվին,\nդարձնում են այն բաժանվող 'b'-ով: Ֆունկցիան ընդունում է երկու արգումենտ՝ 'a' և 'b', որտեղ 'a'-ն\nդրական ամբողջ թիվ է, որը փոքր է 10000-ից, իսկ 'b'-ն դրական ամբողջ թիվ է 10-ից 100-ի միջև:\nՖունկցիան վերադարձնում է տողերի զանգված, որը ներկայացնում է հնարավոր երկնիշ վերջավորությունները:\n\nՕրինակ:\n>>> find_possible_last_digits(200, 40)\n[\"00\", \"40\", \"80\"]\n>>> find_possible_last_digits(1992, 95)\n[\"15\"]",
      "bn": "রুবি ফাংশন `def find_possible_last_digits(a, b)` লিখুন নিম্নলিখিত সমস্যার সমাধানের জন্য:\nএকটি সংখ্যার সম্ভাব্য শেষ দুইটি অঙ্ক খুঁজে বের করুন যা, যখন সংখ্যা 'a'-এর সাথে যোগ করা হয়, তখন এটি 'b' দ্বারা বিভাজ্য হয়। ফাংশনটি দুটি আর্গুমেন্ট নেয়, 'a' এবং 'b', যেখানে 'a' একটি ধনাত্মক পূর্ণসংখ্যা যা 10000 এর কম, এবং 'b' একটি ধনাত্মক পূর্ণসংখ্যা যা 10 এবং 100 এর মধ্যে। ফাংশনটি সম্ভাব্য দুই-অঙ্কের উপসর্গগুলির একটি অ্যারে রিটার্ন করে।\n\nউদাহরণ:\n>>> find_possible_last_digits(200, 40)\n[\"00\", \"40\", \"80\"]\n>>> find_possible_last_digits(1992, 95)\n[\"15\"]",
      "bg": "Напишете Ruby функция `def find_possible_last_digits(a, b)` за решаване на следния проблем:\nНамира всички възможни последни две цифри на число, което, когато се добави към числото 'a',\nго прави делимо на 'b'. Функцията приема два аргумента, 'a' и 'b', където 'a' е\nположително цяло число по-малко от 10000, а 'b' е положително цяло число между 10 и 100.\nФункцията връща масив от низове, представляващи възможните двуцифрени суфикси.\n\nПример:\n>>> find_possible_last_digits(200, 40)\n[\"00\", \"40\", \"80\"]\n>>> find_possible_last_digits(1992, 95)\n[\"15\"]",
      "zh": "编写一个 ruby 函数 `def find_possible_last_digits(a, b)` 来解决以下问题：\n查找一个数字的所有可能的最后两位数字，当该数字加上数字 'a' 时，\n使其可以被 'b' 整除。该函数接受两个参数，'a' 和 'b'，其中 'a' 是\n小于 10000 的正整数，'b' 是介于 10 和 100 之间的正整数。\n该函数返回一个字符串数组，表示可能的两位数后缀。\n\n示例：\n>>> find_possible_last_digits(200, 40)\n[\"00\", \"40\", \"80\"]\n>>> find_possible_last_digits(1992, 95)\n[\"15\"]",
      "fr": "Écrire une fonction ruby `def find_possible_last_digits(a, b)` pour résoudre le problème suivant :\nTrouve tous les deux derniers chiffres possibles d'un nombre qui, lorsqu'ils sont ajoutés au nombre 'a',\nle rendent divisible par 'b'. La fonction prend deux arguments, 'a' et 'b', où 'a' est\nun entier positif inférieur à 10000, et 'b' est un entier positif entre 10 et 100.\nLa fonction renvoie un tableau de chaînes représentant les suffixes possibles à deux chiffres.\n\nExemple :\n>>> find_possible_last_digits(200, 40)\n[\"00\", \"40\", \"80\"]\n>>> find_possible_last_digits(1992, 95)\n[\"15\"]",
      "de": "Schreiben Sie eine Ruby-Funktion `def find_possible_last_digits(a, b)`, um das folgende Problem zu lösen:\nFindet alle möglichen letzten zwei Ziffern einer Zahl, die, wenn sie zur Zahl 'a' hinzugefügt werden, diese durch 'b' teilbar machen. Die Funktion nimmt zwei Argumente, 'a' und 'b', wobei 'a' eine positive ganze Zahl kleiner als 10000 ist und 'b' eine positive ganze Zahl zwischen 10 und 100. Die Funktion gibt ein Array von Strings zurück, das die möglichen zweistelligen Suffixe darstellt.\n\nBeispiel:\n>>> find_possible_last_digits(200, 40)\n[\"00\", \"40\", \"80\"]\n>>> find_possible_last_digits(1992, 95)\n[\"15\"]",
      "ha": "Rubuta aikin ruby `def find_possible_last_digits(a, b)` don warware matsalar mai zuwa:\nNemo dukkan yiwuwar lambobin ƙarshe biyu na lamba wanda, idan aka ƙara shi zuwa lambar 'a',\nyana sa ya zama mai raba ta 'b'. Aikin yana ɗaukar hujjoji guda biyu, 'a' da 'b', inda 'a' yake\nlamba mai kyau ƙasa da 10000, kuma 'b' lamba ce mai kyau tsakanin 10 da 100.\nAikin yana dawo da jerin igiyoyi masu wakiltar yiwuwar ƙarewa biyu.\n\nMisali:\n>>> find_possible_last_digits(200, 40)\n[\"00\", \"40\", \"80\"]\n>>> find_possible_last_digits(1992, 95)\n[\"15\"]",
      "hi": "`def find_possible_last_digits(a, b)` नामक एक रूबी फ़ंक्शन लिखें ताकि निम्नलिखित समस्या का समाधान किया जा सके:\nऐसे सभी संभावित अंतिम दो अंक खोजें जो किसी संख्या में जोड़ने पर संख्या 'a' को 'b' से विभाज्य बनाते हैं। फ़ंक्शन दो तर्क लेता है, 'a' और 'b', जहाँ 'a' एक धनात्मक पूर्णांक है जो 10000 से कम है, और 'b' एक धनात्मक पूर्णांक है जो 10 और 100 के बीच है। फ़ंक्शन संभावित दो-अंकीय प्रत्ययों का प्रतिनिधित्व करने वाले स्ट्रिंग्स की एक सरणी लौटाता है।\n\nउदाहरण:\n>>> find_possible_last_digits(200, 40)\n[\"00\", \"40\", \"80\"]\n>>> find_possible_last_digits(1992, 95)\n[\"15\"]",
      "hu": "Írj egy ruby függvényt `def find_possible_last_digits(a, b)` a következő probléma megoldására:\nMegtalálja egy szám összes lehetséges utolsó két számjegyét, amely hozzáadva az 'a' számhoz, oszthatóvá teszi azt 'b'-vel. A függvény két argumentumot vesz, 'a' és 'b', ahol 'a' egy pozitív egész szám, amely kisebb, mint 10000, és 'b' egy pozitív egész szám 10 és 100 között. A függvény egy karakterláncokat tartalmazó tömböt ad vissza, amely a lehetséges kétjegyű utótagokat képviseli.\n\nPélda:\n>>> find_possible_last_digits(200, 40)\n[\"00\", \"40\", \"80\"]\n>>> find_possible_last_digits(1992, 95)\n[\"15\"]"
    },
    "instruction_bertscore": {
      "sq": "0.9990725947509481",
      "hy": "0.9890246782959172",
      "bn": "0.9804311334908239",
      "bg": "0.9975387709485967",
      "zh": "0.9739339337271726",
      "fr": "0.9948121717081307",
      "de": "0.994284410785721",
      "ha": "0.9727471172004892",
      "hi": "0.9642455382618149",
      "hu": "0.9987446559918595"
    },
    "level": "easy",
    "test": "raise 'Test failed' unless find_possible_last_digits(200, 40) == [\"00\", \"40\", \"80\"]\nraise 'Test failed' unless find_possible_last_digits(1992, 95) == [\"15\"]\nraise 'Test failed' unless find_possible_last_digits(1500, 25) == [\"00\", \"25\", \"50\", \"75\"]\nraise 'Test failed' unless find_possible_last_digits(300, 30) == [\"00\", \"30\", \"60\", \"90\"]\n  \nputs 'All tests passed!'",
    "entry_point": "find_possible_last_digits",
    "signature": "def find_possible_last_digits(a, b)",
    "docstring": {
      "en": "Finds all possible last two digits of a number that, when added to the number 'a',\nmakes it divisible by 'b'. The function takes two arguments, 'a' and 'b', where 'a' is\na positive integer less than 10000, and 'b' is a positive integer between 10 and 100.\nThe function returns an array of strings representing the possible two-digit suffixes.\n\nExample:\n>>> find_possible_last_digits(200, 40)\n[\"00\", \"40\", \"80\"]\n>>> find_possible_last_digits(1992, 95)\n[\"15\"]",
      "sq": "Gjen të gjitha shifrat e fundit të mundshme të një numri që, kur i shtohen numrit 'a',\ne bëjnë atë të plotpjesëtueshëm me 'b'. Funksioni merr dy argumente, 'a' dhe 'b', ku 'a' është\nnjë numër i plotë pozitiv më pak se 10000, dhe 'b' është një numër i plotë pozitiv midis 10 dhe 100.\nFunksioni kthen një varg me stringje që përfaqësojnë prapashtesat e mundshme me dy shifra.\n\nShembull:\n>>> find_possible_last_digits(200, 40)\n[\"00\", \"40\", \"80\"]\n>>> find_possible_last_digits(1992, 95)\n[\"15\"]",
      "hy": "Հայտնաբերում է թվի բոլոր հնարավոր վերջին երկու թվանշանները, որոնք, երբ գումարվում են 'a' թվին, այն դարձնում են բաժանվող 'b'-ով։ Ֆունկցիան ընդունում է երկու արգումենտ՝ 'a' և 'b', որտեղ 'a'-ն դրական ամբողջ թիվ է, որը փոքր է 10000-ից, իսկ 'b'-ն դրական ամբողջ թիվ է 10-ից մինչև 100 միջակայքում։ Ֆունկցիան վերադարձնում է տողերի զանգված, որը ներկայացնում է հնարավոր երկու թվանշաններից կազմված վերջավորությունները։\n\nՕրինակ:\n>>> find_possible_last_digits(200, 40)\n[\"00\", \"40\", \"80\"]\n>>> find_possible_last_digits(1992, 95)\n[\"15\"]",
      "bn": "সম্ভাব্য সবশেষ দুই অঙ্ক খুঁজে বের করে যা, যখন সংখ্যা 'a'-তে যোগ করা হয়, তখন এটি 'b' দ্বারা বিভাজ্য হয়। ফাংশনটি দুটি আর্গুমেন্ট নেয়, 'a' এবং 'b', যেখানে 'a' হল 10000 এর চেয়ে ছোট একটি ধনাত্মক পূর্ণসংখ্যা, এবং 'b' হল 10 এবং 100 এর মধ্যে একটি ধনাত্মক পূর্ণসংখ্যা। ফাংশনটি সম্ভাব্য দুই অঙ্কের উপসর্গগুলির একটি অ্যারে রিটার্ন করে।\n\nউদাহরণ:\n>>> find_possible_last_digits(200, 40)\n[\"00\", \"40\", \"80\"]\n>>> find_possible_last_digits(1992, 95)\n[\"15\"]",
      "bg": "Намира всички възможни последни две цифри на число, което, когато се добави към числото 'a', го прави делимо на 'b'. Функцията приема два аргумента, 'a' и 'b', където 'a' е положително цяло число по-малко от 10000, а 'b' е положително цяло число между 10 и 100. Функцията връща масив от низове, представляващи възможните двуцифрени суфикси.\n\nПример:\n>>> find_possible_last_digits(200, 40)\n[\"00\", \"40\", \"80\"]\n>>> find_possible_last_digits(1992, 95)\n[\"15\"]",
      "zh": "找到一个数的所有可能的最后两位数字，当它们加到数字 'a' 上时，使其可以被 'b' 整除。该函数接受两个参数，'a' 和 'b'，其中 'a' 是小于 10000 的正整数，'b' 是介于 10 和 100 之间的正整数。函数返回一个字符串数组，表示可能的两位数后缀。\n\n示例：\n>>> find_possible_last_digits(200, 40)\n[\"00\", \"40\", \"80\"]\n>>> find_possible_last_digits(1992, 95)\n[\"15\"]",
      "fr": "Trouve tous les deux derniers chiffres possibles d'un nombre qui, lorsqu'ils sont ajoutés au nombre 'a', le rendent divisible par 'b'. La fonction prend deux arguments, 'a' et 'b', où 'a' est un entier positif inférieur à 10000, et 'b' est un entier positif entre 10 et 100. La fonction renvoie un tableau de chaînes représentant les suffixes possibles à deux chiffres.\n\nExemple :\n>>> find_possible_last_digits(200, 40)\n[\"00\", \"40\", \"80\"]\n>>> find_possible_last_digits(1992, 95)\n[\"15\"]",
      "de": "Findet alle möglichen letzten zwei Ziffern einer Zahl, die, wenn sie zu der Zahl 'a' hinzugefügt werden, diese durch 'b' teilbar machen. Die Funktion nimmt zwei Argumente, 'a' und 'b', wobei 'a' eine positive ganze Zahl kleiner als 10000 ist und 'b' eine positive ganze Zahl zwischen 10 und 100. Die Funktion gibt ein Array von Zeichenketten zurück, das die möglichen zweistelligen Suffixe darstellt.\n\nBeispiel:\n>>> find_possible_last_digits(200, 40)\n[\"00\", \"40\", \"80\"]\n>>> find_possible_last_digits(1992, 95)\n[\"15\"]",
      "ha": "Yana nemo dukkan yiwuwar lambobin ƙarshe guda biyu na wata lamba wanda, idan aka ƙara shi da lambar 'a', zai sa ta zama mai raba ta da 'b'. Aikin yana ɗaukar hujjoji guda biyu, 'a' da 'b', inda 'a' yake zama lamba mai kyau ƙasa da 10000, kuma 'b' yana zama lamba mai kyau tsakanin 10 da 100. Aikin yana dawowa da jerin rubutu waɗanda ke wakiltar yiwuwar ƙarewa guda biyu.\n\nMisali:\n>>> find_possible_last_digits(200, 40)\n[\"00\", \"40\", \"80\"]\n>>> find_possible_last_digits(1992, 95)\n[\"15\"]",
      "hi": "संख्या के सभी संभावित अंतिम दो अंकों को खोजता है, जो संख्या 'a' में जोड़ने पर, 'b' से विभाज्य बनाता है। यह फ़ंक्शन दो तर्क लेता है, 'a' और 'b', जहाँ 'a' एक धनात्मक पूर्णांक है जो 10000 से कम है, और 'b' एक धनात्मक पूर्णांक है जो 10 और 100 के बीच है। यह फ़ंक्शन संभावित दो-अंकीय प्रत्ययों का प्रतिनिधित्व करने वाले स्ट्रिंग्स की एक सरणी लौटाता है।\n\nउदाहरण:\n>>> find_possible_last_digits(200, 40)\n[\"00\", \"40\", \"80\"]\n>>> find_possible_last_digits(1992, 95)\n[\"15\"]",
      "hu": "Megtalálja egy szám összes lehetséges utolsó két számjegyét, amely hozzáadva az 'a' számhoz, oszthatóvá teszi azt 'b'-vel. A függvény két argumentumot vesz fel, 'a' és 'b', ahol 'a' egy pozitív egész szám, amely kisebb, mint 10000, és 'b' egy pozitív egész szám 10 és 100 között. A függvény egy karakterláncokat tartalmazó tömböt ad vissza, amely az összes lehetséges kétjegyű utótagot képviseli.\n\nPélda:\n>>> find_possible_last_digits(200, 40)\n[\"00\", \"40\", \"80\"]\n>>> find_possible_last_digits(1992, 95)\n[\"15\"]"
    },
    "docstring_bertscore": {
      "sq": "0.9824867593041539",
      "hy": "0.9708138477018766",
      "bn": "1",
      "bg": "0.998212326570686",
      "zh": "0.9699595384330456",
      "fr": "0.9927631006973748",
      "de": "0.9959191388216382",
      "ha": "0.9652925190002498",
      "hi": "0.9828780611547926",
      "hu": "0.9945771919673665"
    }
  },
  {
    "task_id": "Ruby/36",
    "prompt": {
      "en": "# Calculates the minimum number of square tiles required to completely cover a square room of size n x n.\n# The tiles used must be smaller than n x n and can be of varying sizes. \n# The function takes a single argument, n, which is a positive integer representing the size of the room, \n# and returns the minimum number of tiles required.\n#\n# Example:\n# >>> min_tiles_required(4)\n# 4\n# >>> min_tiles_required(5)\n# 8\n\n\ndef min_tiles_required(n)",
      "sq": "# Llogarit numrin minimal të pllakave katrore të nevojshme për të mbuluar plotësisht një dhomë katrore me madhësi n x n.\n# Pllakat e përdorura duhet të jenë më të vogla se n x n dhe mund të jenë me madhësi të ndryshme.\n# Funksioni merr një argument të vetëm, n, i cili është një numër i plotë pozitiv që përfaqëson madhësinë e dhomës,\n# dhe kthen numrin minimal të pllakave të nevojshme.\n#\n# Shembull:\n# >>> min_tiles_required(4)\n# 4\n# >>> min_tiles_required(5)\n# 8\n\n\ndef min_tiles_required(n)",
      "hy": "# Հաշվում է քառակուսի սալիկների նվազագույն քանակը, որը անհրաժեշտ է ամբողջությամբ ծածկելու համար n x n չափսի քառակուսի սենյակը։\n# Օգտագործվող սալիկները պետք է լինեն n x n-ից փոքր և կարող են լինել տարբեր չափսերի։\n# Ֆունկցիան ընդունում է մեկ արգումենտ՝ n, որը դրական ամբողջ թիվ է, ներկայացնող սենյակի չափսը,\n# և վերադարձնում է անհրաժեշտ սալիկների նվազագույն քանակը։\n#\n# Օրինակ:\n# >>> min_tiles_required(4)\n# 4\n# >>> min_tiles_required(5)\n# 8\n\n\ndef min_tiles_required(n)",
      "bn": "# একটি বর্গাকার ঘর সম্পূর্ণভাবে ঢাকতে প্রয়োজনীয় সর্বনিম্ন সংখ্যক বর্গাকার টাইল গণনা করে।\n# ব্যবহৃত টাইলগুলি n x n এর চেয়ে ছোট হতে হবে এবং বিভিন্ন আকারের হতে পারে।\n# ফাংশনটি একটি একক আর্গুমেন্ট গ্রহণ করে, n, যা ঘরের আকার নির্দেশ করে একটি ধনাত্মক পূর্ণসংখ্যা,\n# এবং প্রয়োজনীয় টাইলের সর্বনিম্ন সংখ্যা ফেরত দেয়।\n#\n# উদাহরণ:\n# >>> min_tiles_required(4)\n# 4\n# >>> min_tiles_required(5)\n# 8\n\n\ndef min_tiles_required(n)",
      "bg": "# Изчислява минималния брой квадратни плочки, необходими за пълно покриване на квадратна стая с размер n x n.\n# Използваните плочки трябва да са по-малки от n x n и могат да бъдат с различни размери.\n# Функцията приема един аргумент, n, който е положително цяло число, представляващо размера на стаята,\n# и връща минималния брой необходими плочки.\n#\n# Пример:\n# >>> min_tiles_required(4)\n# 4\n# >>> min_tiles_required(5)\n# 8\n\n\ndef min_tiles_required(n)",
      "zh": "# 计算完全覆盖一个边长为 n 的正方形房间所需的最少正方形瓷砖数量。\n# 使用的瓷砖必须小于 n x n，并且可以有不同的尺寸。\n# 该函数接受一个参数 n，它是一个表示房间大小的正整数，\n# 返回所需的最少瓷砖数量。\n#\n# 例子:\n# >>> min_tiles_required(4)\n# 4\n# >>> min_tiles_required(5)\n# 8\n\n\ndef min_tiles_required(n)",
      "fr": "# Calcule le nombre minimum de carreaux carrés nécessaires pour couvrir complètement une pièce carrée de taille n x n.\n# Les carreaux utilisés doivent être plus petits que n x n et peuvent être de tailles variées.\n# La fonction prend un seul argument, n, qui est un entier positif représentant la taille de la pièce,\n# et retourne le nombre minimum de carreaux nécessaires.\n#\n# Exemple:\n# >>> min_tiles_required(4)\n# 4\n# >>> min_tiles_required(5)\n# 8\n\n\ndef min_tiles_required(n)",
      "de": "# Berechnet die minimale Anzahl von quadratischen Fliesen, die benötigt werden, um einen quadratischen Raum der Größe n x n vollständig abzudecken.\n# Die verwendeten Fliesen müssen kleiner als n x n sein und können unterschiedliche Größen haben.\n# Die Funktion nimmt ein einziges Argument n, das eine positive ganze Zahl darstellt, die die Größe des Raumes angibt,\n# und gibt die minimale Anzahl der benötigten Fliesen zurück.\n#\n# Beispiel:\n# >>> min_tiles_required(4)\n# 4\n# >>> min_tiles_required(5)\n# 8\n\n\ndef min_tiles_required(n)",
      "ha": "# Lissafi mafi ƙarancin adadin fale-falen murabba'i da ake buƙata don rufe ɗakin murabba'i mai girman n x n.\n# Fale-falen da aka yi amfani da su dole ne su zama ƙanana fiye da n x n kuma za su iya zama masu girma dabam-dabam.\n# Aikin yana ɗaukar hujja guda, n, wanda yake lamba mai kyau da ke wakiltar girman ɗakin,\n# kuma yana mayar da mafi ƙarancin adadin fale-falen da ake buƙata.\n#\n# Misali:\n# >>> min_tiles_required(4)\n# 4\n# >>> min_tiles_required(5)\n# 8\n\n\ndef min_tiles_required(n)",
      "hi": "# एक वर्गाकार कमरे के आकार n x n को पूरी तरह से ढकने के लिए आवश्यक न्यूनतम संख्या में वर्ग टाइल्स की गणना करता है।\n# उपयोग की जाने वाली टाइल्स n x n से छोटी होनी चाहिए और विभिन्न आकारों की हो सकती हैं।\n# यह फ़ंक्शन एक एकल तर्क n लेता है, जो कमरे के आकार का प्रतिनिधित्व करने वाला एक धनात्मक पूर्णांक है,\n# और आवश्यक टाइल्स की न्यूनतम संख्या लौटाता है।\n#\n# उदाहरण:\n# >>> min_tiles_required(4)\n# 4\n# >>> min_tiles_required(5)\n# 8\n\n\ndef min_tiles_required(n)",
      "hu": "# Kiszámítja a minimális számú négyzet alakú csempe szükségességét egy n x n méretű négyzet alakú szoba teljes lefedéséhez.\n# A használt csempék kisebbek kell legyenek, mint n x n, és különböző méretűek lehetnek.\n# A függvény egyetlen argumentumot vesz fel, n-t, amely egy pozitív egész szám, és a szoba méretét jelöli,\n# és visszaadja a szükséges minimális csempék számát.\n#\n# Példa:\n# >>> min_tiles_required(4)\n# 4\n# >>> min_tiles_required(5)\n# 8\n\n\ndef min_tiles_required(n)"
    },
    "prompt_bertscore": {
      "sq": "0.993828355430865",
      "hy": "0.9910191259518886",
      "bn": "0.978268247271735",
      "bg": "0.9915498663300137",
      "zh": "0.9611560413151983",
      "fr": "0.99409034890345",
      "de": "0.9888131369401151",
      "ha": "0.9930101968913823",
      "hi": "0.9905600911413169",
      "hu": "0.9960053444070074"
    },
    "canonical_solution": "    # Base case: If the room size is 1, only one tile is needed\n    return 1 if n == 1\n  \n    # If the room size is even, divide it into four equal parts\n    if n.even?\n      return 4 \n    else\n    \n      return (n+3)\n    end\n  end",
    "instruction": {
      "en": "Write a ruby function `def min_tiles_required(n)` to solve the following problem:\nCalculates the minimum number of square tiles required to completely cover a square room of size n x n.\nThe tiles used must be smaller than n x n and can be of varying sizes.\nThe function takes a single argument, n, which is a positive integer representing the size of the room,\nand returns the minimum number of tiles required.\n\nExample:\n>>> min_tiles_required(4)\n4\n>>> min_tiles_required(5)\n8",
      "sq": "Shkruani një funksion ruby `def min_tiles_required(n)` për të zgjidhur problemin e mëposhtëm:\nLlogarit numrin minimal të pllakave katrore të nevojshme për të mbuluar plotësisht një dhomë katrore me madhësi n x n.\nPllakat e përdorura duhet të jenë më të vogla se n x n dhe mund të jenë të madhësive të ndryshme.\nFunksioni merr një argument të vetëm, n, i cili është një numër i plotë pozitiv që përfaqëson madhësinë e dhomës,\ndhe kthen numrin minimal të pllakave të nevojshme.\n\nShembull:\n>>> min_tiles_required(4)\n4\n>>> min_tiles_required(5)\n8",
      "hy": "Գրեք ruby ֆունկցիա `def min_tiles_required(n)` լուծելու համար հետևյալ խնդիրը: \nՀաշվում է քառակուսի սալիկների նվազագույն քանակը, որը պահանջվում է ամբողջությամբ ծածկելու համար n x n չափսի սենյակը:\nՕգտագործվող սալիկները պետք է լինեն n x n-ից փոքր և կարող են լինել տարբեր չափերի:\nՖունկցիան ընդունում է մեկ արգումենտ՝ n, որը դրական ամբողջ թիվ է, ներկայացնելով սենյակի չափը,\nև վերադարձնում է պահանջվող սալիկների նվազագույն քանակը:\n\nՕրինակ:\n>>> min_tiles_required(4)\n4\n>>> min_tiles_required(5)\n8",
      "bn": "একটি রুবি ফাংশন `def min_tiles_required(n)` লিখুন নিম্নলিখিত সমস্যার সমাধানের জন্য:\nএকটি n x n আকারের বর্গাকার ঘর সম্পূর্ণরূপে ঢাকার জন্য প্রয়োজনীয় ন্যূনতম সংখ্যক বর্গাকার টাইল গণনা করে।\nব্যবহৃত টাইলগুলি n x n এর চেয়ে ছোট হতে হবে এবং বিভিন্ন আকারের হতে পারে।\nফাংশনটি একটি একক আর্গুমেন্ট গ্রহণ করে, n, যা ঘরের আকার নির্দেশ করে এমন একটি ধনাত্মক পূর্ণসংখ্যা,\nএবং প্রয়োজনীয় টাইলের ন্যূনতম সংখ্যা প্রদান করে।\n\nউদাহরণ:\n>>> min_tiles_required(4)\n4\n>>> min_tiles_required(5)\n8",
      "bg": "Напишете функция на Ruby `def min_tiles_required(n)` за решаване на следния проблем:\nИзчислява минималния брой квадратни плочки, необходими за пълно покриване на квадратна стая с размер n x n.\nИзползваните плочки трябва да бъдат по-малки от n x n и могат да бъдат с различни размери.\nФункцията приема един аргумент, n, който е положително цяло число, представляващо размера на стаята,\nи връща минималния брой необходими плочки.\n\nПример:\n>>> min_tiles_required(4)\n4\n>>> min_tiles_required(5)\n8",
      "zh": "编写一个 ruby 函数 `def min_tiles_required(n)` 来解决以下问题：\n计算完全覆盖一个 n x n 大小的正方形房间所需的最小正方形瓷砖数量。\n使用的瓷砖必须小于 n x n，并且可以是不同的大小。\n该函数接受一个参数 n，这是一个表示房间大小的正整数，\n并返回所需的最小瓷砖数量。\n\n例子：\n>>> min_tiles_required(4)\n4\n>>> min_tiles_required(5)\n8",
      "fr": "Écrire une fonction ruby `def min_tiles_required(n)` pour résoudre le problème suivant :\nCalcule le nombre minimum de carreaux carrés nécessaires pour couvrir complètement une pièce carrée de taille n x n.\nLes carreaux utilisés doivent être plus petits que n x n et peuvent être de tailles variées.\nLa fonction prend un seul argument, n, qui est un entier positif représentant la taille de la pièce,\net renvoie le nombre minimum de carreaux requis.\n\nExemple :\n>>> min_tiles_required(4)\n4\n>>> min_tiles_required(5)\n8",
      "de": "Schreiben Sie eine Ruby-Funktion `def min_tiles_required(n)`, um das folgende Problem zu lösen:\nBerechnet die minimale Anzahl an quadratischen Fliesen, die erforderlich sind, um einen quadratischen Raum der Größe n x n vollständig zu bedecken.\nDie verwendeten Fliesen müssen kleiner als n x n sein und können unterschiedliche Größen haben.\nDie Funktion nimmt ein einziges Argument n, das eine positive ganze Zahl ist, die die Größe des Raumes darstellt, \nund gibt die minimale Anzahl der benötigten Fliesen zurück.\n\nBeispiel:\n>>> min_tiles_required(4)\n4\n>>> min_tiles_required(5)\n8",
      "ha": "Rubuta aikin ruby `def min_tiles_required(n)` don warware matsalar mai zuwa:  \nLissafa mafi ƙarancin adadin fale-falen murabba'i da ake buƙata don rufe ɗakin murabba'i mai girman n x n gaba ɗaya.  \nFale-falen da aka yi amfani da su dole ne su zama ƙanana fiye da n x n kuma za su iya zama masu girma dabam-dabam.  \nAikin yana ɗaukar hujja ɗaya, n, wanda shine cikakken lamba mai kyau da ke wakiltar girman ɗakin,  \nkuma yana dawo da mafi ƙarancin adadin fale-falen da ake buƙata.  \n\nMisali:  \n>>> min_tiles_required(4)  \n4  \n>>> min_tiles_required(5)  \n8",
      "hi": "`def min_tiles_required(n)` नामक एक रूबी फ़ंक्शन लिखें ताकि निम्नलिखित समस्या का समाधान किया जा सके:\nयह n x n आकार के एक वर्गाकार कमरे को पूरी तरह से ढकने के लिए आवश्यक न्यूनतम वर्गाकार टाइलों की संख्या की गणना करता है।\nउपयोग की जाने वाली टाइलें n x n से छोटी होनी चाहिए और विभिन्न आकारों की हो सकती हैं।\nफ़ंक्शन एकल तर्क n लेता है, जो कमरे के आकार का प्रतिनिधित्व करने वाला एक धनात्मक पूर्णांक है,\nऔर आवश्यक टाइलों की न्यूनतम संख्या लौटाता है।\n\nउदाहरण:\n>>> min_tiles_required(4)\n4\n>>> min_tiles_required(5)\n8",
      "hu": "Írj egy ruby függvényt `def min_tiles_required(n)` a következő probléma megoldására:\nKiszámítja a minimálisan szükséges négyzet alakú csempék számát, amelyek teljesen lefedik az n x n méretű négyzet alakú szobát.\nA használt csempék kisebbek kell, hogy legyenek, mint az n x n, és különböző méretűek lehetnek.\nA függvény egyetlen argumentumot vesz fel, n, amely egy pozitív egész szám, ami a szoba méretét jelöli,\nés visszaadja a szükséges csempék minimális számát.\n\nPélda:\n>>> min_tiles_required(4)\n4\n>>> min_tiles_required(5)\n8"
    },
    "instruction_bertscore": {
      "sq": "0.9951401104672194",
      "hy": "0.9910669958737179",
      "bn": "0.9912203385278769",
      "bg": "0.9897379599942135",
      "zh": "0.9768853825589701",
      "fr": "0.9964699408682479",
      "de": "0.9891281647244364",
      "ha": "0.9969971058995145",
      "hi": "0.983079472361162",
      "hu": "0.9881000538721999"
    },
    "level": "easy",
    "test": "raise 'Test failed' unless min_tiles_required(4) == 4\nraise 'Test failed' unless min_tiles_required(5) == 8\nraise 'Test failed' unless min_tiles_required(2) == 4\nraise 'Test failed' unless min_tiles_required(10) == 4\nraise 'Test failed' unless min_tiles_required(7) == 10\n  \nputs 'All tests passed!'   ",
    "entry_point": "min_tiles_required",
    "signature": "def min_tiles_required(n)",
    "docstring": {
      "en": "Calculates the minimum number of square tiles required to completely cover a square room of size n x n.\nThe tiles used must be smaller than n x n and can be of varying sizes.\nThe function takes a single argument, n, which is a positive integer representing the size of the room,\nand returns the minimum number of tiles required.\n\nExample:\n>>> min_tiles_required(4)\n4\n>>> min_tiles_required(5)\n8",
      "sq": "Llogarit numrin minimal të pllakave katrore të nevojshme për të mbuluar plotësisht një dhomë katrore me madhësi n x n. Pllakat e përdorura duhet të jenë më të vogla se n x n dhe mund të jenë të madhësive të ndryshme. Funksioni merr një argument të vetëm, n, i cili është një numër i plotë pozitiv që përfaqëson madhësinë e dhomës, dhe kthen numrin minimal të pllakave të nevojshme.\n\nShembull:\n>>> min_tiles_required(4)\n4\n>>> min_tiles_required(5)\n8",
      "hy": "Հաշվում է քառակուսի սալիկների նվազագույն քանակը, որոնք անհրաժեշտ են n x n չափսի քառակուսի սենյակը ամբողջությամբ ծածկելու համար։ Օգտագործվող սալիկները պետք է լինեն n x n-ից փոքր և կարող են ունենալ տարբեր չափսեր։ Ֆունկցիան ընդունում է մեկ արգումենտ՝ n, որը դրական ամբողջ թիվ է և ներկայացնում է սենյակի չափսը, և վերադարձնում է անհրաժեշտ սալիկների նվազագույն քանակը։\n\nՕրինակ:\n>>> min_tiles_required(4)\n4\n>>> min_tiles_required(5)\n8",
      "bn": "বর্গাকার ঘরের আয়তন n x n সম্পূর্ণভাবে ঢাকতে প্রয়োজনীয় ন্যূনতম সংখ্যক বর্গাকার টাইল গণনা করে। ব্যবহৃত টাইলগুলি n x n এর চেয়ে ছোট হতে হবে এবং বিভিন্ন আকারের হতে পারে। ফাংশনটি একটি একক আর্গুমেন্ট n গ্রহণ করে, যা ঘরের আকার নির্দেশ করে এমন একটি ধনাত্মক পূর্ণসংখ্যা, এবং প্রয়োজনীয় টাইলের ন্যূনতম সংখ্যা প্রদান করে।\n\nউদাহরণ:\n>>> min_tiles_required(4)\n4\n>>> min_tiles_required(5)\n8",
      "bg": "Изчислява минималния брой квадратни плочки, необходими за пълно покриване на квадратна стая с размер n x n. Използваните плочки трябва да бъдат по-малки от n x n и могат да бъдат с различни размери. Функцията приема един аргумент, n, който е положително цяло число, представляващо размера на стаята, и връща минималния брой необходими плочки.\n\nПример:\n>>> min_tiles_required(4)\n4\n>>> min_tiles_required(5)\n8",
      "zh": "计算完全覆盖一个大小为 n x n 的正方形房间所需的最小方形瓷砖数量。\n使用的瓷砖必须小于 n x n，并且可以有不同的尺寸。\n该函数接受一个参数 n，这是一个表示房间大小的正整数，并返回所需的最小瓷砖数量。\n\n示例：\n>>> min_tiles_required(4)\n4\n>>> min_tiles_required(5)\n8",
      "fr": "Calcule le nombre minimum de carreaux carrés nécessaires pour couvrir complètement une pièce carrée de taille n x n.  \nLes carreaux utilisés doivent être plus petits que n x n et peuvent être de tailles variées.  \nLa fonction prend un seul argument, n, qui est un entier positif représentant la taille de la pièce,  \net renvoie le nombre minimum de carreaux nécessaires.\n\nExemple :\n>>> min_tiles_required(4)\n4\n>>> min_tiles_required(5)\n8",
      "de": "Berechnet die minimale Anzahl von quadratischen Fliesen, die benötigt werden, um einen quadratischen Raum der Größe n x n vollständig abzudecken. Die verwendeten Fliesen müssen kleiner als n x n sein und können unterschiedliche Größen haben. Die Funktion nimmt ein einziges Argument, n, das eine positive ganze Zahl darstellt, die die Größe des Raumes angibt, und gibt die minimale Anzahl der benötigten Fliesen zurück.\n\nBeispiel:\n>>> min_tiles_required(4)\n4\n>>> min_tiles_required(5)\n8",
      "ha": "Yana ƙididdige mafi ƙarancin adadin fale-falen murabba'i da ake buƙata don rufe ɗakin murabba'i mai girman n x n gaba ɗaya.\nFale-falen da ake amfani da su dole ne su kasance ƙanana fiye da n x n kuma za su iya zama masu girma dabam-dabam.\nAikin yana ɗaukar hujja guda ɗaya, n, wanda yake lamba mai kyau da ke wakiltar girman ɗakin,\nkuma yana mayar da mafi ƙarancin adadin fale-falen da ake buƙata.\n\nMisali:\n>>> min_tiles_required(4)\n4\n>>> min_tiles_required(5)\n8",
      "hi": "वर्गाकार कमरे के आकार n x n को पूरी तरह से ढकने के लिए आवश्यक न्यूनतम वर्ग टाइलों की संख्या की गणना करता है। उपयोग की जाने वाली टाइलें n x n से छोटी होनी चाहिए और विभिन्न आकारों की हो सकती हैं। यह फ़ंक्शन एकल तर्क n लेता है, जो कमरे के आकार का प्रतिनिधित्व करने वाला एक धनात्मक पूर्णांक है, और आवश्यक टाइलों की न्यूनतम संख्या लौटाता है।\n\nउदाहरण:\n>>> min_tiles_required(4)\n4\n>>> min_tiles_required(5)\n8",
      "hu": "Kiszámítja a minimálisan szükséges négyzet alakú csempék számát, amelyek teljesen lefedik az n x n méretű négyzet alakú szobát. A használt csempék kisebbek kell legyenek, mint az n x n, és különböző méretűek lehetnek. A függvény egyetlen argumentumot vesz fel, n-t, amely egy pozitív egész szám, ami a szoba méretét jelenti, és visszaadja a szükséges csempék minimális számát.\n\nPélda:\n>>> min_tiles_required(4)\n4\n>>> min_tiles_required(5)\n8"
    },
    "docstring_bertscore": {
      "sq": "0.9935151153199729",
      "hy": "0.9858223592928728",
      "bn": "0.9865942369535744",
      "bg": "0.9917077774829365",
      "zh": "0.9660300336050324",
      "fr": "0.9924768743183036",
      "de": "0.9915997225556535",
      "ha": "0.9883431774585866",
      "hi": "0.9887074655774045",
      "hu": "0.9841796860417142"
    }
  },
  {
    "task_id": "Ruby/37",
    "prompt": {
      "en": "# Sorts a list of dates in the format 'MM/DD/YYYY'.\n# The function takes an array of string dates and returns an array of dates sorted in ascending order.\n# The sorting is done based on the chronological order of the dates.\n#\n# Examples:\n# >>> sort_dates([\"15/12/1999\", \"10/21/2003\", \"02/12/2004\"])\n# [\"15/12/1999\", \"10/21/2003\", \"02/12/2004\"]\n# >>> sort_dates([\"12/31/2005\", \"11/30/2005\", \"10/22/2003\"])\n# [\"10/22/2003\", \"11/30/2005\", \"12/31/2005\"]\n\ndef sort_dates(dates)",
      "sq": "# Radhit një listë datash në formatin 'MM/DD/YYYY'.\n# Funksioni merr një varg datash si string dhe kthen një varg datash të renditura në rend rritës.\n# Renditja bëhet bazuar në rendin kronologjik të datave.\n#\n# Shembuj:\n# >>> sort_dates([\"15/12/1999\", \"10/21/2003\", \"02/12/2004\"])\n# [\"15/12/1999\", \"10/21/2003\", \"02/12/2004\"]\n# >>> sort_dates([\"12/31/2005\", \"11/30/2005\", \"10/22/2003\"])\n# [\"10/22/2003\", \"11/30/2005\", \"12/31/2005\"]\n\ndef sort_dates(dates)",
      "hy": "# Դասավորում է ամսաթվերի ցուցակը 'MM/DD/YYYY' ձևաչափով:\n# Ֆունկցիան ընդունում է տողային ամսաթվերի զանգված և վերադարձնում է ամսաթվերի զանգվածը դասավորված աճման կարգով:\n# Դասավորումը կատարվում է ամսաթվերի ժամանակագրական կարգի հիման վրա:\n#\n# Օրինակներ:\n# >>> sort_dates([\"15/12/1999\", \"10/21/2003\", \"02/12/2004\"])\n# [\"15/12/1999\", \"10/21/2003\", \"02/12/2004\"]\n# >>> sort_dates([\"12/31/2005\", \"11/30/2005\", \"10/22/2003\"])\n# [\"10/22/2003\", \"11/30/2005\", \"12/31/2005\"]\n\ndef sort_dates(dates)",
      "bn": "# 'MM/DD/YYYY' বিন্যাসে তারিখগুলির একটি তালিকা সাজায়।\n# ফাংশনটি স্ট্রিং তারিখের একটি অ্যারে গ্রহণ করে এবং তারিখগুলির একটি অ্যারে ফেরত দেয় যা ঊর্ধ্বক্রমে সাজানো থাকে।\n# তারিখগুলির কালানুক্রমিক ক্রমের উপর ভিত্তি করে সাজানো হয়।\n#\n# উদাহরণ:\n# >>> sort_dates([\"15/12/1999\", \"10/21/2003\", \"02/12/2004\"])\n# [\"15/12/1999\", \"10/21/2003\", \"02/12/2004\"]\n# >>> sort_dates([\"12/31/2005\", \"11/30/2005\", \"10/22/2003\"])\n# [\"10/22/2003\", \"11/30/2005\", \"12/31/2005\"]\n\ndef sort_dates(dates)",
      "bg": "# Сортира списък от дати във формат 'MM/DD/YYYY'.\n# Функцията приема масив от дати като низове и връща масив от дати, сортирани във възходящ ред.\n# Сортирането се извършва въз основа на хронологичния ред на датите.\n#\n# Примери:\n# >>> sort_dates([\"15/12/1999\", \"10/21/2003\", \"02/12/2004\"])\n# [\"15/12/1999\", \"10/21/2003\", \"02/12/2004\"]\n# >>> sort_dates([\"12/31/2005\", \"11/30/2005\", \"10/22/2003\"])\n# [\"10/22/2003\", \"11/30/2005\", \"12/31/2005\"]\n\ndef sort_dates(dates)",
      "zh": "# 对格式为 'MM/DD/YYYY' 的日期列表进行排序。\n# 该函数接受一个字符串日期数组，并返回一个按升序排序的日期数组。\n# 排序是基于日期的时间顺序进行的。\n#\n# 示例：\n# >>> sort_dates([\"15/12/1999\", \"10/21/2003\", \"02/12/2004\"])\n# [\"15/12/1999\", \"10/21/2003\", \"02/12/2004\"]\n# >>> sort_dates([\"12/31/2005\", \"11/30/2005\", \"10/22/2003\"])\n# [\"10/22/2003\", \"11/30/2005\", \"12/31/2005\"]\n\ndef sort_dates(dates)",
      "fr": "# Trie une liste de dates au format 'MM/JJ/AAAA'.\n# La fonction prend un tableau de dates sous forme de chaînes de caractères et renvoie un tableau de dates triées par ordre croissant.\n# Le tri est effectué en fonction de l'ordre chronologique des dates.\n#\n# Exemples :\n# >>> sort_dates([\"15/12/1999\", \"10/21/2003\", \"02/12/2004\"])\n# [\"15/12/1999\", \"10/21/2003\", \"02/12/2004\"]\n# >>> sort_dates([\"12/31/2005\", \"11/30/2005\", \"10/22/2003\"])\n# [\"10/22/2003\", \"11/30/2005\", \"12/31/2005\"]\n\ndef sort_dates(dates)",
      "de": "# Sortiert eine Liste von Daten im Format 'MM/DD/YYYY'.\n# Die Funktion nimmt ein Array von Datumsstrings und gibt ein Array von Daten zurück, das in aufsteigender Reihenfolge sortiert ist.\n# Die Sortierung erfolgt basierend auf der chronologischen Reihenfolge der Daten.\n#\n# Beispiele:\n# >>> sort_dates([\"15/12/1999\", \"10/21/2003\", \"02/12/2004\"])\n# [\"15/12/1999\", \"10/21/2003\", \"02/12/2004\"]\n# >>> sort_dates([\"12/31/2005\", \"11/30/2005\", \"10/22/2003\"])\n# [\"10/22/2003\", \"11/30/2005\", \"12/31/2005\"]\n\ndef sort_dates(dates)",
      "ha": "# Yana tsara jerin ranaku a cikin tsarin 'MM/DD/YYYY'.\n# Aikin yana karɓar jerin ranaku na kirtani kuma yana mayar da jerin ranaku da aka tsara a tsari mai hawa.\n# Ana yin tsarawa bisa ga tsarin lokaci na ranakun.\n#\n# Misalai:\n# >>> sort_dates([\"15/12/1999\", \"10/21/2003\", \"02/12/2004\"])\n# [\"15/12/1999\", \"10/21/2003\", \"02/12/2004\"]\n# >>> sort_dates([\"12/31/2005\", \"11/30/2005\", \"10/22/2003\"])\n# [\"10/22/2003\", \"11/30/2005\", \"12/31/2005\"]\n\ndef sort_dates(dates)",
      "hi": "# एक सूची में तिथियों को 'MM/DD/YYYY' प्रारूप में छांटता है।\n# फ़ंक्शन एक स्ट्रिंग तिथियों की array लेता है और एक array लौटाता है जो आरोही क्रम में छांटी गई तिथियों को दर्शाता है।\n# छंटाई तिथियों के कालानुक्रमिक क्रम के आधार पर की जाती है।\n#\n# उदाहरण:\n# >>> sort_dates([\"15/12/1999\", \"10/21/2003\", \"02/12/2004\"])\n# [\"15/12/1999\", \"10/21/2003\", \"02/12/2004\"]\n# >>> sort_dates([\"12/31/2005\", \"11/30/2005\", \"10/22/2003\"])\n# [\"10/22/2003\", \"11/30/2005\", \"12/31/2005\"]\n\ndef sort_dates(dates)",
      "hu": "# Dátumok listáját rendezi 'HH/NN/ÉÉÉÉ' formátumban.\n# A függvény egy dátumokat tartalmazó sztring tömböt vesz át, és egy dátumokat tartalmazó tömböt ad vissza növekvő sorrendben.\n# A rendezés a dátumok időrendi sorrendje alapján történik.\n#\n# Példák:\n# >>> sort_dates([\"15/12/1999\", \"10/21/2003\", \"02/12/2004\"])\n# [\"15/12/1999\", \"10/21/2003\", \"02/12/2004\"]\n# >>> sort_dates([\"12/31/2005\", \"11/30/2005\", \"10/22/2003\"])\n# [\"10/22/2003\", \"11/30/2005\", \"12/31/2005\"]\n\ndef sort_dates(dates)"
    },
    "prompt_bertscore": {
      "sq": "0.992734895183268",
      "hy": "0.9923926550367448",
      "bn": "0.9895957406413926",
      "bg": "0.9947275551658099",
      "zh": "0.9898915012787535",
      "fr": "0.9957290495469878",
      "de": "0.9984637926330762",
      "ha": "0.983067753168681",
      "hi": "0.9789475631748743",
      "hu": "0.9862329282904719"
    },
    "canonical_solution": "    dates.sort_by { |date| date.split('/').rotate(-1).join }\n  end",
    "instruction": {
      "en": "Write a ruby function `def sort_dates(dates)` to solve the following problem:\nSorts a list of dates in the format 'MM/DD/YYYY'.\nThe function takes an array of string dates and returns an array of dates sorted in ascending order.\nThe sorting is done based on the chronological order of the dates.\n\nExamples:\n>>> sort_dates([\"15/12/1999\", \"10/21/2003\", \"02/12/2004\"])\n[\"15/12/1999\", \"10/21/2003\", \"02/12/2004\"]\n>>> sort_dates([\"12/31/2005\", \"11/30/2005\", \"10/22/2003\"])\n[\"10/22/2003\", \"11/30/2005\", \"12/31/2005\"]",
      "sq": "Shkruani një funksion ruby `def sort_dates(dates)` për të zgjidhur problemin e mëposhtëm:\nRendit një listë datash në formatin 'MM/DD/YYYY'.\nFunksioni merr një varg datash si string dhe kthen një varg datash të renditura në rritje.\nRenditja bëhet bazuar në rendin kronologjik të datave.\n\nShembuj:\n>>> sort_dates([\"15/12/1999\", \"10/21/2003\", \"02/12/2004\"])\n[\"15/12/1999\", \"10/21/2003\", \"02/12/2004\"]\n>>> sort_dates([\"12/31/2005\", \"11/30/2005\", \"10/22/2003\"])\n[\"10/22/2003\", \"11/30/2005\", \"12/31/2005\"]",
      "hy": "Գրեք ruby ֆունկցիա `def sort_dates(dates)` հետևյալ խնդիրը լուծելու համար:\nԴասավորում է ամսաթվերի ցուցակը 'MM/DD/YYYY' ձևաչափով:\nՖունկցիան ընդունում է տողային ամսաթվերի զանգված և վերադարձնում է ամսաթվերի զանգվածը դասավորված աճման կարգով:\nԴասավորումը կատարվում է ամսաթվերի ժամանակագրական կարգի հիման վրա:\n\nՕրինակներ:\n>>> sort_dates([\"15/12/1999\", \"10/21/2003\", \"02/12/2004\"])\n[\"15/12/1999\", \"10/21/2003\", \"02/12/2004\"]\n>>> sort_dates([\"12/31/2005\", \"11/30/2005\", \"10/22/2003\"])\n[\"10/22/2003\", \"11/30/2005\", \"12/31/2005\"]",
      "bn": "রুবি ফাংশন `def sort_dates(dates)` লিখুন নিম্নলিখিত সমস্যার সমাধানের জন্য:\nতারিখের একটি তালিকা 'MM/DD/YYYY' ফরম্যাটে সাজান।\nফাংশনটি স্ট্রিং তারিখের একটি অ্যারে গ্রহণ করে এবং তারিখের একটি অ্যারে ফেরত দেয় যা ঊর্ধ্বক্রমে সাজানো থাকে।\nতারিখগুলির কালানুক্রমিক ক্রমের উপর ভিত্তি করে সাজানো হয়।\n\nউদাহরণসমূহ:\n>>> sort_dates([\"15/12/1999\", \"10/21/2003\", \"02/12/2004\"])\n[\"15/12/1999\", \"10/21/2003\", \"02/12/2004\"]\n>>> sort_dates([\"12/31/2005\", \"11/30/2005\", \"10/22/2003\"])\n[\"10/22/2003\", \"11/30/2005\", \"12/31/2005\"]",
      "bg": "Напишете функция на Ruby `def sort_dates(dates)`, за да решите следния проблем:\nСортира списък от дати във формат 'MM/DD/YYYY'.\nФункцията приема масив от дати като низове и връща масив от дати, сортирани във възходящ ред.\nСортирането се извършва въз основа на хронологичния ред на датите.\n\nПримери:\n>>> sort_dates([\"15/12/1999\", \"10/21/2003\", \"02/12/2004\"])\n[\"15/12/1999\", \"10/21/2003\", \"02/12/2004\"]\n>>> sort_dates([\"12/31/2005\", \"11/30/2005\", \"10/22/2003\"])\n[\"10/22/2003\", \"11/30/2005\", \"12/31/2005\"]",
      "zh": "编写一个 ruby 函数 `def sort_dates(dates)` 来解决以下问题：\n对格式为 'MM/DD/YYYY' 的日期列表进行排序。\n该函数接受一个字符串日期数组，并返回一个按升序排序的日期数组。\n排序是基于日期的时间顺序进行的。\n\n例子：\n>>> sort_dates([\"15/12/1999\", \"10/21/2003\", \"02/12/2004\"])\n[\"15/12/1999\", \"10/21/2003\", \"02/12/2004\"]\n>>> sort_dates([\"12/31/2005\", \"11/30/2005\", \"10/22/2003\"])\n[\"10/22/2003\", \"11/30/2005\", \"12/31/2005\"]",
      "fr": "Écrire une fonction ruby `def sort_dates(dates)` pour résoudre le problème suivant :\nTrie une liste de dates au format 'MM/DD/YYYY'.\nLa fonction prend un tableau de dates sous forme de chaînes de caractères et renvoie un tableau de dates triées par ordre croissant.\nLe tri est effectué en fonction de l'ordre chronologique des dates.\n\nExemples :\n>>> sort_dates([\"15/12/1999\", \"10/21/2003\", \"02/12/2004\"])\n[\"15/12/1999\", \"10/21/2003\", \"02/12/2004\"]\n>>> sort_dates([\"12/31/2005\", \"11/30/2005\", \"10/22/2003\"])\n[\"10/22/2003\", \"11/30/2005\", \"12/31/2005\"]",
      "de": "Schreiben Sie eine Ruby-Funktion `def sort_dates(dates)`, um das folgende Problem zu lösen:\nSortiert eine Liste von Daten im Format 'MM/DD/YYYY'.\nDie Funktion nimmt ein Array von Datums-Strings und gibt ein Array von Daten zurück, das in aufsteigender Reihenfolge sortiert ist.\nDie Sortierung erfolgt basierend auf der chronologischen Reihenfolge der Daten.\n\nBeispiele:\n>>> sort_dates([\"15/12/1999\", \"10/21/2003\", \"02/12/2004\"])\n[\"15/12/1999\", \"10/21/2003\", \"02/12/2004\"]\n>>> sort_dates([\"12/31/2005\", \"11/30/2005\", \"10/22/2003\"])\n[\"10/22/2003\", \"11/30/2005\", \"12/31/2005\"]",
      "ha": "Rubuta aikin ruby `def sort_dates(dates)` don warware matsalar mai zuwa:\nTana tsara jerin kwanakin a cikin tsarin 'MM/DD/YYYY'.\nAikin yana ɗaukar jerin kwanakin kirtani kuma yana mayar da jerin kwanakin da aka tsara a cikin tsari mai tashi.\nTsarin yana faruwa bisa ga tsari na lokaci na kwanakin.\n\nMisalai:\n>>> sort_dates([\"15/12/1999\", \"10/21/2003\", \"02/12/2004\"])\n[\"15/12/1999\", \"10/21/2003\", \"02/12/2004\"]\n>>> sort_dates([\"12/31/2005\", \"11/30/2005\", \"10/22/2003\"])\n[\"10/22/2003\", \"11/30/2005\", \"12/31/2005\"]",
      "hi": "रूबी फ़ंक्शन `def sort_dates(dates)` लिखें ताकि निम्नलिखित समस्या का समाधान किया जा सके:\nतिथियों की एक सूची को 'MM/DD/YYYY' प्रारूप में क्रमबद्ध करता है।\nयह फ़ंक्शन स्ट्रिंग तिथियों की एक array लेता है और तिथियों की एक array को आरोही क्रम में क्रमबद्ध करके लौटाता है।\nक्रमबद्धता तिथियों के कालानुक्रमिक क्रम के आधार पर की जाती है।\n\nउदाहरण:\n>>> sort_dates([\"15/12/1999\", \"10/21/2003\", \"02/12/2004\"])\n[\"15/12/1999\", \"10/21/2003\", \"02/12/2004\"]\n>>> sort_dates([\"12/31/2005\", \"11/30/2005\", \"10/22/2003\"])\n[\"10/22/2003\", \"11/30/2005\", \"12/31/2005\"]",
      "hu": "Írj egy ruby függvényt `def sort_dates(dates)` a következő probléma megoldására:\nRendez egy dátumlistát 'MM/DD/YYYY' formátumban.\nA függvény egy karakterlánc dátumokat tartalmazó tömböt vesz át, és egy dátumokat növekvő sorrendben rendezett tömböt ad vissza.\nA rendezés a dátumok időrendi sorrendje alapján történik.\n\nPéldák:\n>>> sort_dates([\"15/12/1999\", \"10/21/2003\", \"02/12/2004\"])\n[\"15/12/1999\", \"10/21/2003\", \"02/12/2004\"]\n>>> sort_dates([\"12/31/2005\", \"11/30/2005\", \"10/22/2003\"])\n[\"10/22/2003\", \"11/30/2005\", \"12/31/2005\"]"
    },
    "instruction_bertscore": {
      "sq": "0.9918003392404988",
      "hy": "0.9917431336907607",
      "bn": "0.9879367796989892",
      "bg": "0.992569833336628",
      "zh": "0.990651858377355",
      "fr": "0.9946657811173081",
      "de": "0.9944784726679922",
      "ha": "0.9869974566270752",
      "hi": "0.9824698757217659",
      "hu": "0.9847594881239551"
    },
    "level": "easy",
    "test": "raise 'Test failed' unless sort_dates([\"10/21/2003\", \"15/12/1999\",  \"02/12/2004\"]) == [\"15/12/1999\", \"10/21/2003\", \"02/12/2004\"]\nraise 'Test failed' unless sort_dates([\"12/31/2005\", \"11/30/2005\", \"10/22/2003\"]) == [\"10/22/2003\", \"11/30/2005\", \"12/31/2005\"]\nraise 'Test failed' unless sort_dates([\"01/01/2000\", \"12/31/1999\"]) == [\"12/31/1999\", \"01/01/2000\"]\n  \n\nputs 'All tests passed!'",
    "entry_point": "sort_dates",
    "signature": "def sort_dates(dates)",
    "docstring": {
      "en": "Sorts a list of dates in the format 'MM/DD/YYYY'.\nThe function takes an array of string dates and returns an array of dates sorted in ascending order.\nThe sorting is done based on the chronological order of the dates.\n\nExamples:\n>>> sort_dates([\"15/12/1999\", \"10/21/2003\", \"02/12/2004\"])\n[\"15/12/1999\", \"10/21/2003\", \"02/12/2004\"]\n>>> sort_dates([\"12/31/2005\", \"11/30/2005\", \"10/22/2003\"])\n[\"10/22/2003\", \"11/30/2005\", \"12/31/2005\"]",
      "sq": "Rendit një listë datash në formatin 'MM/DD/VVVV'. Funksioni merr një varg datash me string dhe kthen një varg datash të renditura në rend rritës. Renditja bëhet bazuar në rendin kronologjik të datave.\n\nShembuj:\n>>> sort_dates([\"15/12/1999\", \"10/21/2003\", \"02/12/2004\"])\n[\"15/12/1999\", \"10/21/2003\", \"02/12/2004\"]\n>>> sort_dates([\"12/31/2005\", \"11/30/2005\", \"10/22/2003\"])\n[\"10/22/2003\", \"11/30/2005\", \"12/31/2005\"]",
      "hy": "Դասավորում է ամսաթվերի ցուցակը 'MM/DD/YYYY' ձևաչափով:\nՖունկցիան ընդունում է տողային ամսաթվերի զանգված և վերադարձնում է ամսաթվերի զանգվածը դասավորված աճման կարգով:\nԴասավորումը կատարվում է ամսաթվերի ժամանակագրական կարգի հիման վրա:\n\nՕրինակներ:\n>>> sort_dates([\"15/12/1999\", \"10/21/2003\", \"02/12/2004\"])\n[\"15/12/1999\", \"10/21/2003\", \"02/12/2004\"]\n>>> sort_dates([\"12/31/2005\", \"11/30/2005\", \"10/22/2003\"])\n[\"10/22/2003\", \"11/30/2005\", \"12/31/2005\"]",
      "bn": "তারিখগুলিকে 'MM/DD/YYYY' বিন্যাসে সাজায়।\nফাংশনটি একটি স্ট্রিং তারিখের অ্যারে গ্রহণ করে এবং ক্রমবর্ধমান ক্রমানুসারে সাজানো তারিখের একটি অ্যারে প্রদান করে।\nতারিখগুলির কালানুক্রমিক ক্রমের উপর ভিত্তি করে সাজানো হয়।\n\nউদাহরণ:\n>>> sort_dates([\"15/12/1999\", \"10/21/2003\", \"02/12/2004\"])\n[\"15/12/1999\", \"10/21/2003\", \"02/12/2004\"]\n>>> sort_dates([\"12/31/2005\", \"11/30/2005\", \"10/22/2003\"])\n[\"10/22/2003\", \"11/30/2005\", \"12/31/2005\"]",
      "bg": "Сортира списък от дати във формат 'MM/DD/YYYY'.  \nФункцията приема масив от низове с дати и връща масив от дати, сортирани във възходящ ред.  \nСортирането се извършва въз основа на хронологичния ред на датите.\n\nПримери:  \n>>> sort_dates([\"15/12/1999\", \"10/21/2003\", \"02/12/2004\"])  \n[\"15/12/1999\", \"10/21/2003\", \"02/12/2004\"]  \n>>> sort_dates([\"12/31/2005\", \"11/30/2005\", \"10/22/2003\"])  \n[\"10/22/2003\", \"11/30/2005\", \"12/31/2005\"]",
      "zh": "对格式为 'MM/DD/YYYY' 的日期列表进行排序。\n该函数接受一个字符串日期数组，并返回一个按升序排序的日期数组。\n排序是根据日期的时间顺序进行的。\n\n示例：\n>>> sort_dates([\"15/12/1999\", \"10/21/2003\", \"02/12/2004\"])\n[\"15/12/1999\", \"10/21/2003\", \"02/12/2004\"]\n>>> sort_dates([\"12/31/2005\", \"11/30/2005\", \"10/22/2003\"])\n[\"10/22/2003\", \"11/30/2005\", \"12/31/2005\"]",
      "fr": "Trie une liste de dates au format 'MM/JJ/AAAA'.\nLa fonction prend un tableau de dates sous forme de chaînes de caractères et renvoie un tableau de dates triées par ordre croissant.\nLe tri est effectué en fonction de l'ordre chronologique des dates.\n\nExemples :\n>>> sort_dates([\"15/12/1999\", \"10/21/2003\", \"02/12/2004\"])\n[\"15/12/1999\", \"10/21/2003\", \"02/12/2004\"]\n>>> sort_dates([\"12/31/2005\", \"11/30/2005\", \"10/22/2003\"])\n[\"10/22/2003\", \"11/30/2005\", \"12/31/2005\"]",
      "de": "Sortiert eine Liste von Daten im Format 'MM/TT/JJJJ'.\nDie Funktion nimmt ein Array von Datumsstrings und gibt ein Array von Daten zurück, das in aufsteigender Reihenfolge sortiert ist.\nDie Sortierung erfolgt basierend auf der chronologischen Reihenfolge der Daten.\n\nBeispiele:\n>>> sort_dates([\"15/12/1999\", \"10/21/2003\", \"02/12/2004\"])\n[\"15/12/1999\", \"10/21/2003\", \"02/12/2004\"]\n>>> sort_dates([\"12/31/2005\", \"11/30/2005\", \"10/22/2003\"])\n[\"10/22/2003\", \"11/30/2005\", \"12/31/2005\"]",
      "ha": "Yana tsara jerin ranaku a cikin tsarin 'MM/DD/YYYY'. \nAikin yana ɗaukar jerin ranakun da aka rubuta a matsayin kirtani kuma yana mayar da jerin ranakun da aka tsara a cikin tsari mai hawa. \nTsarin yana faruwa bisa ga tsarin lokaci na ranakun.\n\nMisalai:\n>>> sort_dates([\"15/12/1999\", \"10/21/2003\", \"02/12/2004\"])\n[\"15/12/1999\", \"10/21/2003\", \"02/12/2004\"]\n>>> sort_dates([\"12/31/2005\", \"11/30/2005\", \"10/22/2003\"])\n[\"10/22/2003\", \"11/30/2005\", \"12/31/2005\"]",
      "hi": "तिथियों की एक सूची को 'MM/DD/YYYY' प्रारूप में क्रमबद्ध करता है। \nयह फ़ंक्शन स्ट्रिंग तिथियों की एक सरणी लेता है और तिथियों की एक सरणी लौटाता है जो आरोही क्रम में क्रमबद्ध होती है। \nक्रमबद्धता तिथियों के कालानुक्रमिक क्रम के आधार पर की जाती है।\n\nउदाहरण:\n>>> sort_dates([\"15/12/1999\", \"10/21/2003\", \"02/12/2004\"])\n[\"15/12/1999\", \"10/21/2003\", \"02/12/2004\"]\n>>> sort_dates([\"12/31/2005\", \"11/30/2005\", \"10/22/2003\"])\n[\"10/22/2003\", \"11/30/2005\", \"12/31/2005\"]",
      "hu": "Rendez egy dátumlistát 'MM/DD/YYYY' formátumban.\nA függvény egy karakterlánc dátumokat tartalmazó tömböt vesz át, és egy dátumokat tartalmazó tömböt ad vissza, amely növekvő sorrendben van rendezve.\nA rendezés a dátumok időrendi sorrendje alapján történik.\n\nPéldák:\n>>> sort_dates([\"15/12/1999\", \"10/21/2003\", \"02/12/2004\"])\n[\"15/12/1999\", \"10/21/2003\", \"02/12/2004\"]\n>>> sort_dates([\"12/31/2005\", \"11/30/2005\", \"10/22/2003\"])\n[\"10/22/2003\", \"11/30/2005\", \"12/31/2005\"]"
    },
    "docstring_bertscore": {
      "sq": "0.9911835919073855",
      "hy": "0.989342486905573",
      "bn": "0.9715400403749402",
      "bg": "0.9971007909584148",
      "zh": "0.9865664287002295",
      "fr": "0.9953468846938767",
      "de": "0.9950084185245932",
      "ha": "0.961263103090576",
      "hi": "0.9879133413140271",
      "hu": "0.9878712316732476"
    }
  },
  {
    "task_id": "Ruby/38",
    "prompt": {
      "en": "# Finds the largest letter(s) in the input string (considering 'A' and 'a' as the same letter) and inserts \"(max)\" after each of its occurrences.\n# The function takes one argument, input_string, which is a string of letters and possibly digits.\n# Returns a new string with \"(max)\" inserted after each occurrence of the largest letter(s).\n#\n# Examples:\n# >>> insert_max_after_largest_letters(\"abcdefgfedcba\")\n# \"abcdefg(max)fedcba\"\n# >>> insert_max_after_largest_letters(\"aAbBcC\")\n# \"aAbBc(max)C(max)\"\n\ndef insert_max_after_largest_letters(input_string)",
      "sq": "# Gjen shkronjën/shkronjat më të madhe(a) në vargun hyrës (duke konsideruar 'A' dhe 'a' si të njëjtën shkronjë) dhe fut \"(max)\" pas çdo paraqitjeje të saj.\n# Funksioni merr një argument, input_string, i cili është një varg shkronjash dhe ndoshta shifrash.\n# Kthen një varg të ri me \"(max)\" të futur pas çdo paraqitjeje të shkronjës/shkronjave më të madhe(a).\n#\n# Shembuj:\n# >>> insert_max_after_largest_letters(\"abcdefgfedcba\")\n# \"abcdefg(max)fedcba\"\n# >>> insert_max_after_largest_letters(\"aAbBcC\")\n# \"aAbBc(max)C(max)\"\n\ndef insert_max_after_largest_letters(input_string)",
      "hy": "# Գտնում է մուտքային տողի ամենամեծ տառ(եր)ը (հաշվի առնելով 'A' և 'a' որպես նույն տառ) և տեղադրում \"(max)\" յուրաքանչյուր հանդիպման հետևից:\n# Ֆունկցիան ընդունում է մեկ արգումենտ՝ input_string, որը տառերի և հնարավոր է թվերի տող է:\n# Վերադարձնում է նոր տող՝ \"(max)\" տեղադրված ամենամեծ տառ(եր)ի յուրաքանչյուր հանդիպման հետևից:\n#\n# Օրինակներ:\n# >>> insert_max_after_largest_letters(\"abcdefgfedcba\")\n# \"abcdefg(max)fedcba\"\n# >>> insert_max_after_largest_letters(\"aAbBcC\")\n# \"aAbBc(max)C(max)\"\n\ndef insert_max_after_largest_letters(input_string)",
      "bn": "# ইনপুট স্ট্রিং-এ সবচেয়ে বড় অক্ষর(গুলি) খুঁজে বের করে (যেখানে 'A' এবং 'a' কে একই অক্ষর হিসেবে গণ্য করা হয়) এবং এর প্রতিটি উপস্থিতির পরে \"(max)\" যোগ করে।\n# ফাংশনটি একটি আর্গুমেন্ট নেয়, input_string, যা একটি অক্ষর এবং সম্ভবত সংখ্যার স্ট্রিং।\n# একটি নতুন স্ট্রিং রিটার্ন করে যেখানে সবচেয়ে বড় অক্ষর(গুলি) এর প্রতিটি উপস্থিতির পরে \"(max)\" যোগ করা হয়েছে।\n#\n# উদাহরণ:\n# >>> insert_max_after_largest_letters(\"abcdefgfedcba\")\n# \"abcdefg(max)fedcba\"\n# >>> insert_max_after_largest_letters(\"aAbBcC\")\n# \"aAbBc(max)C(max)\"\n\ndef insert_max_after_largest_letters(input_string)",
      "bg": "# Намира най-голямата буква(и) в входния низ (като се счита, че 'A' и 'a' са една и съща буква) и вмъква \"(max)\" след всяко нейно появяване.\n# Функцията приема един аргумент, input_string, който е низ от букви и евентуално цифри.\n# Връща нов низ с вмъкнато \"(max)\" след всяко появяване на най-голямата буква(и).\n#\n# Примери:\n# >>> insert_max_after_largest_letters(\"abcdefgfedcba\")\n# \"abcdefg(max)fedcba\"\n# >>> insert_max_after_largest_letters(\"aAbBcC\")\n# \"aAbBc(max)C(max)\"\n\ndef insert_max_after_largest_letters(input_string)",
      "zh": "# 找到输入字符串中最大的字母（将 'A' 和 'a' 视为相同的字母），并在其每次出现后插入 \"(max)\"。\n# 该函数接受一个参数 input_string，它是一个可能包含字母和数字的字符串。\n# 返回一个新字符串，在每个最大字母出现后插入 \"(max)\"。\n#\n# 示例：\n# >>> insert_max_after_largest_letters(\"abcdefgfedcba\")\n# \"abcdefg(max)fedcba\"\n# >>> insert_max_after_largest_letters(\"aAbBcC\")\n# \"aAbBc(max)C(max)\"\n\ndef insert_max_after_largest_letters(input_string)",
      "fr": "# Trouve la ou les plus grandes lettres dans la chaîne d'entrée (en considérant 'A' et 'a' comme la même lettre) et insère \"(max)\" après chacune de ses occurrences.\n# La fonction prend un argument, input_string, qui est une chaîne de lettres et possiblement de chiffres.\n# Renvoie une nouvelle chaîne avec \"(max)\" inséré après chaque occurrence de la ou des plus grandes lettres.\n#\n# Exemples :\n# >>> insert_max_after_largest_letters(\"abcdefgfedcba\")\n# \"abcdefg(max)fedcba\"\n# >>> insert_max_after_largest_letters(\"aAbBcC\")\n# \"aAbBc(max)C(max)\"\n\ndef insert_max_after_largest_letters(input_string)",
      "de": "# Findet die größten Buchstaben im Eingabestring (wobei 'A' und 'a' als derselbe Buchstabe betrachtet werden) und fügt \"(max)\" nach jedem Vorkommen ein.\n# Die Funktion nimmt ein Argument, input_string, das ein String aus Buchstaben und möglicherweise Ziffern ist.\n# Gibt einen neuen String zurück, in dem \"(max)\" nach jedem Vorkommen der größten Buchstaben eingefügt ist.\n#\n# Beispiele:\n# >>> insert_max_after_largest_letters(\"abcdefgfedcba\")\n# \"abcdefg(max)fedcba\"\n# >>> insert_max_after_largest_letters(\"aAbBcC\")\n# \"aAbBc(max)C(max)\"\n\ndef insert_max_after_largest_letters(input_string)",
      "ha": "# Nemi mafi girman haruffa a cikin igiyar shigarwa (ta la'akari da 'A' da 'a' a matsayin harafi daya) kuma saka \"(max)\" bayan kowanne daga cikin faruwar sa.\n# Aikin yana daukar hujja daya, input_string, wanda igiyar haruffa ce kuma watakila lambobi.\n# Yana dawowa da sabon igiya tare da \"(max)\" da aka saka bayan kowanne daga cikin faruwar mafi girman haruffa.\n#\n# Misalai:\n# >>> insert_max_after_largest_letters(\"abcdefgfedcba\")\n# \"abcdefg(max)fedcba\"\n# >>> insert_max_after_largest_letters(\"aAbBcC\")\n# \"aAbBc(max)C(max)\"\n\ndef insert_max_after_largest_letters(input_string)",
      "hi": "# इनपुट स्ट्रिंग में सबसे बड़ा अक्षर (अक्षरों) ढूंढता है (जहाँ 'A' और 'a' को समान अक्षर माना जाता है) और उसके प्रत्येक प्रकट होने के बाद \"(max)\" जोड़ता है।\n# यह फ़ंक्शन एक तर्क लेता है, input_string, जो अक्षरों और संभवतः अंकों की एक स्ट्रिंग है।\n# एक नई स्ट्रिंग लौटाता है जिसमें सबसे बड़े अक्षर (अक्षरों) के प्रत्येक प्रकट होने के बाद \"(max)\" जोड़ा गया होता है।\n#\n# उदाहरण:\n# >>> insert_max_after_largest_letters(\"abcdefgfedcba\")\n# \"abcdefg(max)fedcba\"\n# >>> insert_max_after_largest_letters(\"aAbBcC\")\n# \"aAbBc(max)C(max)\"\n\ndef insert_max_after_largest_letters(input_string)",
      "hu": "# Megkeresi a legnagyobb betű(ke)t a bemeneti sztringben (figyelembe véve, hogy az 'A' és az 'a' ugyanaz a betű) és \"(max)\"-ot szúr be minden előfordulása után.\n# A függvény egy argumentumot vesz, input_string, amely egy betűkből és esetleg számjegyekből álló sztring.\n# Visszaad egy új sztringet, amelyben \"(max)\" van beszúrva a legnagyobb betű(k) minden előfordulása után.\n#\n# Példák:\n# >>> insert_max_after_largest_letters(\"abcdefgfedcba\")\n# \"abcdefg(max)fedcba\"\n# >>> insert_max_after_largest_letters(\"aAbBcC\")\n# \"aAbBc(max)C(max)\"\n\ndef insert_max_after_largest_letters(input_string)"
    },
    "prompt_bertscore": {
      "sq": "0.9905225499993013",
      "hy": "0.9811483877967409",
      "bn": "0.9553427259534503",
      "bg": "0.9903831114718149",
      "zh": "0.9470759281251592",
      "fr": "0.9913915579163289",
      "de": "0.9565172273965096",
      "ha": "0.9671366034577777",
      "hi": "0.9801609961726164",
      "hu": "0.9866341616601624"
    },
    "canonical_solution": "    # Normalize the string to lowercase for comparison\n    normalized_string = input_string.downcase\n  \n    # Find the largest letter\n    largest_letter = normalized_string.chars.max\n  \n    # Insert '(max)' after each occurrence of the largest letter\n    result = ''\n    input_string.each_char do |char|\n      result += char\n      result += '(max)' if char.downcase == largest_letter\n    end\n  \n    result\n  end",
    "instruction": {
      "en": "Write a ruby function `def insert_max_after_largest_letters(input_string)` to solve the following problem:\nFinds the largest letter(s) in the input string (considering 'A' and 'a' as the same letter) and inserts \"(max)\" after each of its occurrences.\nThe function takes one argument, input_string, which is a string of letters and possibly digits.\nReturns a new string with \"(max)\" inserted after each occurrence of the largest letter(s).\n\nExamples:\n>>> insert_max_after_largest_letters(\"abcdefgfedcba\")\n\"abcdefg(max)fedcba\"\n>>> insert_max_after_largest_letters(\"aAbBcC\")\n\"aAbBc(max)C(max)\"",
      "sq": "Shkruani një funksion ruby `def insert_max_after_largest_letters(input_string)` për të zgjidhur problemin e mëposhtëm:\nGjen shkronjën/shkronjat më të mëdha në vargun e dhënë (duke konsideruar 'A' dhe 'a' si të njëjtën shkronjë) dhe fut \"(max)\" pas secilës paraqitje të saj.\nFunksioni merr një argument, input_string, i cili është një varg me shkronja dhe ndoshta shifra.\nKthen një varg të ri me \"(max)\" të futur pas secilës paraqitje të shkronjës/shkronjave më të mëdha.\n\nShembuj:\n>>> insert_max_after_largest_letters(\"abcdefgfedcba\")\n\"abcdefg(max)fedcba\"\n>>> insert_max_after_largest_letters(\"aAbBcC\")\n\"aAbBc(max)C(max)\"",
      "hy": "Գրեք ruby ֆունկցիա `def insert_max_after_largest_letters(input_string)` հետևյալ խնդիրը լուծելու համար:\nԳտնում է մուտքային տողի ամենամեծ տառ(եր)ը (հաշվի առնելով 'A' և 'a' որպես նույն տառ) և տեղադրում \"(max)\" ամեն մի հանդիպման հետո:\nՖունկցիան ընդունում է մեկ արգումենտ, input_string, որը տառերի և հնարավոր թվանշանների տող է:\nՎերադարձնում է նոր տող, որտեղ \"(max)\" տեղադրված է ամենամեծ տառ(եր)ի ամեն մի հանդիպման հետո:\n\nՕրինակներ:\n>>> insert_max_after_largest_letters(\"abcdefgfedcba\")\n\"abcdefg(max)fedcba\"\n>>> insert_max_after_largest_letters(\"aAbBcC\")\n\"aAbBc(max)C(max)\"",
      "bn": "রুবি ফাংশন `def insert_max_after_largest_letters(input_string)` লিখুন নিম্নলিখিত সমস্যার সমাধানের জন্য:\nইনপুট স্ট্রিং-এ সবচেয়ে বড় অক্ষর(গুলি) খুঁজে বের করে (এক্ষেত্রে 'A' এবং 'a' কে একই অক্ষর হিসেবে গণ্য করা হবে) এবং এর প্রতিটি উপস্থিতির পরে \"(max)\" সন্নিবেশ করে।\nফাংশনটি একটি আর্গুমেন্ট নেয়, input_string, যা অক্ষর এবং সম্ভবত সংখ্যার একটি স্ট্রিং।\nএকটি নতুন স্ট্রিং রিটার্ন করে যা সবচেয়ে বড় অক্ষর(গুলি)-এর প্রতিটি উপস্থিতির পরে \"(max)\" সন্নিবেশ করে।\n\nউদাহরণ:\n>>> insert_max_after_largest_letters(\"abcdefgfedcba\")\n\"abcdefg(max)fedcba\"\n>>> insert_max_after_largest_letters(\"aAbBcC\")\n\"aAbBc(max)C(max)\"",
      "bg": "Напишете функция на Ruby `def insert_max_after_largest_letters(input_string)` за решаване на следния проблем:\nНамира най-голямата буква(и) в входния низ (като се счита, че 'A' и 'a' са една и съща буква) и вмъква \"(max)\" след всяко нейно срещане.\nФункцията приема един аргумент, input_string, който е низ от букви и евентуално цифри.\nВръща нов низ с вмъкнато \"(max)\" след всяко срещане на най-голямата буква(и).\n\nПримери:\n>>> insert_max_after_largest_letters(\"abcdefgfedcba\")\n\"abcdefg(max)fedcba\"\n>>> insert_max_after_largest_letters(\"aAbBcC\")\n\"aAbBc(max)C(max)\"",
      "zh": "编写一个 ruby 函数 `def insert_max_after_largest_letters(input_string)` 来解决以下问题：\n在输入字符串中查找最大字母（将 'A' 和 'a' 视为相同的字母），并在每个最大字母的出现位置之后插入 \"(max)\"。\n该函数接受一个参数，input_string，它是一个可能包含字母和数字的字符串。\n返回一个新的字符串，其中在每个最大字母的出现位置之后插入 \"(max)\"。\n\n示例：\n>>> insert_max_after_largest_letters(\"abcdefgfedcba\")\n\"abcdefg(max)fedcba\"\n>>> insert_max_after_largest_letters(\"aAbBcC\")\n\"aAbBc(max)C(max)\"",
      "fr": "Écrire une fonction ruby `def insert_max_after_largest_letters(input_string)` pour résoudre le problème suivant :\nTrouve la ou les plus grandes lettres dans la chaîne d'entrée (en considérant 'A' et 'a' comme la même lettre) et insère \"(max)\" après chacune de ses occurrences.\nLa fonction prend un argument, input_string, qui est une chaîne de lettres et éventuellement de chiffres.\nRenvoie une nouvelle chaîne avec \"(max)\" inséré après chaque occurrence de la ou des plus grandes lettres.\n\nExemples :\n>>> insert_max_after_largest_letters(\"abcdefgfedcba\")\n\"abcdefg(max)fedcba\"\n>>> insert_max_after_largest_letters(\"aAbBcC\")\n\"aAbBc(max)C(max)\"",
      "de": "Schreiben Sie eine Ruby-Funktion `def insert_max_after_largest_letters(input_string)`, um das folgende Problem zu lösen:\nFindet den/die größten Buchstaben im Eingabestring (wobei 'A' und 'a' als derselbe Buchstabe betrachtet werden) und fügt nach jedem Vorkommen \"(max)\" ein.\nDie Funktion nimmt ein Argument, input_string, das ein String aus Buchstaben und möglicherweise Ziffern ist.\nGibt einen neuen String zurück, bei dem \"(max)\" nach jedem Vorkommen des/der größten Buchstaben eingefügt wird.\n\nBeispiele:\n>>> insert_max_after_largest_letters(\"abcdefgfedcba\")\n\"abcdefg(max)fedcba\"\n>>> insert_max_after_largest_letters(\"aAbBcC\")\n\"aAbBc(max)C(max)\"",
      "ha": "Rubuta wani aikin ruby `def insert_max_after_largest_letters(input_string)` don warware matsalar mai zuwa:\nNemo mafi girman harafi (ko haruffa) a cikin rubutun shigarwa (ta la'akari da 'A' da 'a' a matsayin harafi daya) kuma saka \"(max)\" bayan kowanne daga cikin bayyanarsa.\nAikin yana daukar hujja daya, input_string, wanda yake rubutu ne na haruffa da watakila lambobi.\nYana mayar da sabon rubutu tare da \"(max)\" da aka saka bayan kowanne bayyanar mafi girman harafi (ko haruffa).\n\nMisalai:\n>>> insert_max_after_largest_letters(\"abcdefgfedcba\")\n\"abcdefg(max)fedcba\"\n>>> insert_max_after_largest_letters(\"aAbBcC\")\n\"aAbBc(max)C(max)\"",
      "hi": "रूबी फ़ंक्शन `def insert_max_after_largest_letters(input_string)` लिखें ताकि निम्नलिखित समस्या का समाधान किया जा सके:\nइनपुट स्ट्रिंग में सबसे बड़े अक्षर को खोजें (जहाँ 'A' और 'a' को एक ही अक्षर माना जाता है) और उसके प्रत्येक occurrence के बाद \"(max)\" डालें।\nयह फ़ंक्शन एक तर्क लेता है, input_string, जो अक्षरों और संभवतः अंकों की एक स्ट्रिंग है।\nएक नई स्ट्रिंग लौटाता है जिसमें सबसे बड़े अक्षर के प्रत्येक occurrence के बाद \"(max)\" डाला गया है।\n\nउदाहरण:\n>>> insert_max_after_largest_letters(\"abcdefgfedcba\")\n\"abcdefg(max)fedcba\"\n>>> insert_max_after_largest_letters(\"aAbBcC\")\n\"aAbBc(max)C(max)\"",
      "hu": "Írj egy ruby függvényt `def insert_max_after_largest_letters(input_string)` a következő probléma megoldására:\nMegkeresi a legnagyobb betű(ke)t a bemeneti szövegben (tekintve, hogy az 'A' és az 'a' ugyanaz a betű) és beszúrja a \"(max)\" szöveget minden előfordulása után.\nA függvény egy argumentumot vesz fel, input_string, ami egy betűkből és esetleg számjegyekből álló szöveg.\nVisszaad egy új szöveget, amelyben a \"(max)\" be van szúrva a legnagyobb betű(k) minden előfordulása után.\n\nPéldák:\n>>> insert_max_after_largest_letters(\"abcdefgfedcba\")\n\"abcdefg(max)fedcba\"\n>>> insert_max_after_largest_letters(\"aAbBcC\")\n\"aAbBc(max)C(max)\""
    },
    "instruction_bertscore": {
      "sq": "0.9861512912038666",
      "hy": "0.9914594895066429",
      "bn": "0.9728551721277722",
      "bg": "0.9945771919673665",
      "zh": "0.9514297074470629",
      "fr": "0.9930338339067254",
      "de": "0.9780739867590829",
      "ha": "0.9925384497364245",
      "hi": "0.9556273632894732",
      "hu": "0.9624403853589699"
    },
    "level": "middle",
    "test": "raise 'Test failed' unless insert_max_after_largest_letters(\"abcdefgfedcba\") == \"abcdefg(max)fedcba\"\nraise 'Test failed' unless insert_max_after_largest_letters(\"xxxxx\") == \"x(max)x(max)x(max)x(max)x(max)\"\nraise 'Test failed' unless insert_max_after_largest_letters(\"Hello World!\") == \"Hello W(max)orld!\"\nraise 'Test failed' unless insert_max_after_largest_letters(\"Ruby123\") == \"Ruby(max)123\"\nraise 'Test failed' unless insert_max_after_largest_letters(\"\") == \"\"\nraise 'Test failed' unless insert_max_after_largest_letters(\"aAbBcC\") == \"aAbBc(max)C(max)\"\n  \n\nputs 'All tests passed!'",
    "entry_point": "insert_max_after_largest_letters",
    "signature": "def insert_max_after_largest_letters(input_string)",
    "docstring": {
      "en": "Finds the largest letter(s) in the input string (considering 'A' and 'a' as the same letter) and inserts \"(max)\" after each of its occurrences.\nThe function takes one argument, input_string, which is a string of letters and possibly digits.\nReturns a new string with \"(max)\" inserted after each occurrence of the largest letter(s).\n\nExamples:\n>>> insert_max_after_largest_letters(\"abcdefgfedcba\")\n\"abcdefg(max)fedcba\"\n>>> insert_max_after_largest_letters(\"aAbBcC\")\n\"aAbBc(max)C(max)\"",
      "sq": "Gjen shkronjën/shkronjat më të mëdha në vargun hyrës (duke konsideruar 'A' dhe 'a' si të njëjtën shkronjë) dhe fut \"(max)\" pas secilës prej paraqitjeve të saj.\nFunksioni merr një argument, input_string, i cili është një varg shkronjash dhe ndoshta shifrash.\nKthen një varg të ri me \"(max)\" të futur pas secilës paraqitje të shkronjës/shkronjave më të mëdha.\n\nShembuj:\n>>> insert_max_after_largest_letters(\"abcdefgfedcba\")\n\"abcdefg(max)fedcba\"\n>>> insert_max_after_largest_letters(\"aAbBcC\")\n\"aAbBc(max)C(max)\"",
      "hy": "Գտնում է մուտքային տողում ամենամեծ տառ(եր)ը (հաշվի առնելով 'A' և 'a' որպես նույն տառ) և տեղադրում \"(max)\" յուրաքանչյուր հանդիպման հետևից։ \nՖունկցիան ընդունում է մեկ արգումենտ, input_string, որը տառերի և հնարավոր թվերի տող է։ \nՎերադարձնում է նոր տող, որտեղ \"(max)\" տեղադրված է ամենամեծ տառ(եր)ի յուրաքանչյուր հանդիպման հետևից։\n\nՕրինակներ:\n>>> insert_max_after_largest_letters(\"abcdefgfedcba\")\n\"abcdefg(max)fedcba\"\n>>> insert_max_after_largest_letters(\"aAbBcC\")\n\"aAbBc(max)C(max)\"",
      "bn": "ইনপুট স্ট্রিং-এ সবচেয়ে বড় অক্ষর(গুলি) খুঁজে বের করে (যেখানে 'A' এবং 'a' একই অক্ষর হিসেবে বিবেচিত হয়) এবং এর প্রতিটি উপস্থিতির পরে \"(max)\" সন্নিবেশ করে।\nফাংশনটি একটি আর্গুমেন্ট নেয়, input_string, যা অক্ষর এবং সম্ভবত সংখ্যার একটি স্ট্রিং।\nএটি একটি নতুন স্ট্রিং প্রদান করে যেখানে সবচেয়ে বড় অক্ষর(গুলি)-এর প্রতিটি উপস্থিতির পরে \"(max)\" সন্নিবেশ করা হয়েছে।\n\nExamples:\nউদাহরণসমূহ:\n\n>>> insert_max_after_largest_letters(\"abcdefgfedcba\")\n\"abcdefg(max)fedcba\"\n>>> insert_max_after_largest_letters(\"aAbBcC\")\n\"aAbBc(max)C(max)\"",
      "bg": "Намира най-голямата(ите) буква(и) в входния низ (като се разглеждат 'A' и 'a' като една и съща буква) и вмъква \"(max)\" след всяко нейно появяване.\nФункцията приема един аргумент, input_string, който е низ от букви и евентуално цифри.\nВръща нов низ с вмъкнато \"(max)\" след всяко появяване на най-голямата(ите) буква(и).\n\nПримери:\n>>> insert_max_after_largest_letters(\"abcdefgfedcba\")\n\"abcdefg(max)fedcba\"\n>>> insert_max_after_largest_letters(\"aAbBcC\")\n\"aAbBc(max)C(max)\"",
      "zh": "找到输入字符串中最大的字母（将 'A' 和 'a' 视为相同的字母），并在其每次出现后插入 \"(max)\"。\n该函数接受一个参数，input_string，这是一个可能包含字母和数字的字符串。\n返回一个新字符串，在每个最大字母出现后插入 \"(max)\"。\n\n示例：\n>>> insert_max_after_largest_letters(\"abcdefgfedcba\")\n\"abcdefg(max)fedcba\"\n>>> insert_max_after_largest_letters(\"aAbBcC\")\n\"aAbBc(max)C(max)\"",
      "fr": "Trouve la ou les plus grandes lettres dans la chaîne d'entrée (considérant 'A' et 'a' comme la même lettre) et insère \"(max)\" après chacune de ses occurrences.  \nLa fonction prend un argument, input_string, qui est une chaîne de lettres et éventuellement de chiffres.  \nRenvoie une nouvelle chaîne avec \"(max)\" inséré après chaque occurrence de la ou des plus grandes lettres.  \n\nExemples :  \n>>> insert_max_after_largest_letters(\"abcdefgfedcba\")  \n\"abcdefg(max)fedcba\"  \n>>> insert_max_after_largest_letters(\"aAbBcC\")  \n\"aAbBc(max)C(max)\"  ",
      "de": "Findet die größten Buchstaben im Eingabestring (wobei 'A' und 'a' als derselbe Buchstabe betrachtet werden) und fügt \"(max)\" nach jedem Vorkommen ein.\nDie Funktion nimmt ein Argument, input_string, das ein String aus Buchstaben und möglicherweise Ziffern ist.\nGibt einen neuen String zurück, in dem nach jedem Vorkommen der größten Buchstaben \"(max)\" eingefügt wird.\n\nBeispiele:\n>>> insert_max_after_largest_letters(\"abcdefgfedcba\")\n\"abcdefg(max)fedcba\"\n>>> insert_max_after_largest_letters(\"aAbBcC\")\n\"aAbBc(max)C(max)\"",
      "ha": "Nemi mafi girman haruffa a cikin igiyar shigarwa (la'akari da 'A' da 'a' a matsayin harafi daya) kuma saka \"(max)\" bayan kowanne daga cikin bayyanarsa.\nAikin yana daukar hujja daya, input_string, wadda ita ce igiyar haruffa da watakila lambobi.\nYana dawowa da sabon igiya tare da \"(max)\" da aka saka bayan kowanne daga cikin mafi girman haruffa.\nMisalai:\n>>> insert_max_after_largest_letters(\"abcdefgfedcba\")\n\"abcdefg(max)fedcba\"\n>>> insert_max_after_largest_letters(\"aAbBcC\")\n\"aAbBc(max)C(max)\"",
      "hi": "इनपुट स्ट्रिंग में सबसे बड़े अक्षर(अक्षरों) को ढूंढता है (जहां 'A' और 'a' को एक ही अक्षर माना जाता है) और इसके प्रत्येक प्रकट होने के बाद \"(max)\" डालता है।\nयह फ़ंक्शन एक तर्क लेता है, input_string, जो अक्षरों और संभवतः अंकों की एक स्ट्रिंग है।\nएक नई स्ट्रिंग लौटाता है जिसमें सबसे बड़े अक्षर(अक्षरों) के प्रत्येक प्रकट होने के बाद \"(max)\" डाला गया है।\n\nExamples:\nउदाहरण:\n\n>>> insert_max_after_largest_letters(\"abcdefgfedcba\")\n\"abcdefg(max)fedcba\"\n>>> insert_max_after_largest_letters(\"aAbBcC\")\n\"aAbBc(max)C(max)\"",
      "hu": "Megkeresi a legnagyobb betű(ke)t a bemeneti sztringben (az 'A' és 'a' ugyanannak a betűnek számít), és \"(max)\"-t szúr be minden előfordulása után.\nA függvény egy argumentumot vesz fel, input_string, amely egy betűkből és esetleg számjegyekből álló sztring.\nVisszaad egy új sztringet, amelyben \"(max)\" van beszúrva a legnagyobb betű(k) minden előfordulása után.\n\nPéldák:\n>>> insert_max_after_largest_letters(\"abcdefgfedcba\")\n\"abcdefg(max)fedcba\"\n>>> insert_max_after_largest_letters(\"aAbBcC\")\n\"aAbBc(max)C(max)\""
    },
    "docstring_bertscore": {
      "sq": "0.9942707052894297",
      "hy": "0.9787342341456428",
      "bn": "0.999999801369619",
      "bg": "0.999999801369619",
      "zh": "0.940908653424407",
      "fr": "0.9909660916401523",
      "de": "0.9565561589511924",
      "ha": "0.999999801369619",
      "hi": "0.999999801369619",
      "hu": "0.9786873573757185"
    }
  },
  {
    "task_id": "Ruby/39",
    "prompt": {
      "en": "# Calculates the total number of ways to safely place nuclear materials in N pits arranged in a line\n# such that no three consecutive pits contain nuclear materials, avoiding an explosion.\n# The function takes a single argument, n, which is a positive integer representing the number of pits,\n# and returns the total count of safe placement combinations for the given number of pits.\n#\n# Example:\n# >>> count_safe_placements(1)\n# 2\n# >>> count_safe_placements(4)\n# 13\n# >>> count_safe_placements(10)\n# 504\n\ndef count_safe_placements(n)",
      "sq": "# Llogarit numrin total të mënyrave për të vendosur në mënyrë të sigurt materialet bërthamore në N gropa të radhitura në një vijë\n# në mënyrë që asnjë tre gropa radhazi të mos përmbajnë materiale bërthamore, duke shmangur një shpërthim.\n# Funksioni merr një argument të vetëm, n, i cili është një numër i plotë pozitiv që përfaqëson numrin e gropave,\n# dhe kthen numrin total të kombinimeve të vendosjes së sigurt për numrin e dhënë të gropave.\n#\n# Shembull:\n# >>> count_safe_placements(1)\n# 2\n# >>> count_safe_placements(4)\n# 13\n# >>> count_safe_placements(10)\n# 504\n\ndef count_safe_placements(n)",
      "hy": "# Հաշվում է ընդհանուր քանակը, թե քանի եղանակով կարելի է անվտանգ տեղադրել միջուկային նյութերը N փոսերում, որոնք դասավորված են գծով\n# այնպես, որ ոչ մի երեք հաջորդական փոսեր չպարունակեն միջուկային նյութեր՝ խուսափելով պայթյունից։\n# Ֆունկցիան ընդունում է մեկ արգումենտ՝ n, որը դրական ամբողջ թիվ է, ներկայացնելով փոսերի քանակը,\n# և վերադարձնում է անվտանգ տեղադրման համակցությունների ընդհանուր քանակը տվյալ քանակի փոսերի համար։\n#\n# Օրինակ:\n# >>> count_safe_placements(1)\n# 2\n# >>> count_safe_placements(4)\n# 13\n# >>> count_safe_placements(10)\n# 504\n\ndef count_safe_placements(n)",
      "bn": "# পারমাণবিক পদার্থগুলি একটি সরলরেখায় সাজানো N গর্তে নিরাপদে স্থাপন করার মোট সংখ্যা গণনা করে\n# যাতে কোনো তিনটি ক্রমাগত গর্তে পারমাণবিক পদার্থ না থাকে, একটি বিস্ফোরণ এড়ানো যায়।\n# ফাংশনটি একটি একক আর্গুমেন্ট গ্রহণ করে, n, যা গর্তের সংখ্যা নির্দেশ করে একটি ধনাত্মক পূর্ণসংখ্যা,\n# এবং প্রদত্ত গর্তের সংখ্যার জন্য নিরাপদ স্থাপনার সংমিশ্রণের মোট সংখ্যা ফেরত দেয়।\n#\n# উদাহরণ:\n# >>> count_safe_placements(1)\n# 2\n# >>> count_safe_placements(4)\n# 13\n# >>> count_safe_placements(10)\n# 504\n\ndef count_safe_placements(n)",
      "bg": "# Изчислява общия брой начини за безопасно поставяне на ядрени материали в N ями, подредени в линия\n# така че нито три последователни ями да съдържат ядрени материали, избягвайки експлозия.\n# Функцията приема един аргумент, n, който е положително цяло число, представляващо броя на ямите,\n# и връща общия брой безопасни комбинации за поставяне за дадения брой ями.\n#\n# Пример:\n# >>> count_safe_placements(1)\n# 2\n# >>> count_safe_placements(4)\n# 13\n# >>> count_safe_placements(10)\n# 504\n\ndef count_safe_placements(n)",
      "zh": "# 计算在 N 个按直线排列的坑中安全放置核材料的总方法数\n# 确保没有三个连续的坑中含有核材料，以避免爆炸。\n# 该函数接受一个参数 n，它是表示坑数量的正整数，\n# 返回给定数量的坑的安全放置组合的总数。\n#\n# 示例:\n# >>> count_safe_placements(1)\n# 2\n# >>> count_safe_placements(4)\n# 13\n# >>> count_safe_placements(10)\n# 504\n\ndef count_safe_placements(n)",
      "fr": "# Calcule le nombre total de façons de placer en toute sécurité des matériaux nucléaires dans N fosses disposées en ligne\n# de telle sorte qu'aucune trois fosses consécutives ne contiennent de matériaux nucléaires, évitant ainsi une explosion.\n# La fonction prend un seul argument, n, qui est un entier positif représentant le nombre de fosses,\n# et renvoie le nombre total de combinaisons de placement sûres pour le nombre donné de fosses.\n#\n# Exemple :\n# >>> count_safe_placements(1)\n# 2\n# >>> count_safe_placements(4)\n# 13\n# >>> count_safe_placements(10)\n# 504\n\ndef count_safe_placements(n)",
      "de": "# Berechnet die Gesamtanzahl der Möglichkeiten, nukleares Material sicher in N Gruben anzuordnen,\n# die in einer Linie angeordnet sind, so dass keine drei aufeinanderfolgenden Gruben nukleares Material enthalten,\n# um eine Explosion zu vermeiden.\n# Die Funktion nimmt ein einzelnes Argument, n, das eine positive ganze Zahl darstellt, die die Anzahl der Gruben angibt,\n# und gibt die Gesamtanzahl der sicheren Anordnungskombinationen für die gegebene Anzahl von Gruben zurück.\n#\n# Beispiel:\n# >>> count_safe_placements(1)\n# 2\n# >>> count_safe_placements(4)\n# 13\n# >>> count_safe_placements(10)\n# 504\n\ndef count_safe_placements(n)",
      "ha": "# Lissafa jimillar hanyoyin da za a iya sanya kayan nukiliya cikin rami N da aka tsara a jere\n# ta yadda babu ramuka uku a jere da ke dauke da kayan nukiliya, don kauce wa fashewa.\n# Aikin yana daukar hujja guda, n, wanda yake lamba mai kyau da ke wakiltar adadin ramuka,\n# kuma yana dawo da jimillar adadin hanyoyin sanya kayan cikin tsari mai lafiya don adadin ramuka da aka bayar.\n#\n# Misali:\n# >>> count_safe_placements(1)\n# 2\n# >>> count_safe_placements(4)\n# 13\n# >>> count_safe_placements(10)\n# 504\n\ndef count_safe_placements(n)",
      "hi": "# पंक्ति में व्यवस्थित N गड्ढों में परमाणु सामग्री को सुरक्षित रूप से रखने के कुल तरीकों की गणना करता है\n# ताकि कोई तीन लगातार गड्ढे परमाणु सामग्री न रखें, जिससे विस्फोट से बचा जा सके।\n# यह फ़ंक्शन एकल तर्क n लेता है, जो गड्ढों की संख्या का प्रतिनिधित्व करने वाला एक धनात्मक पूर्णांक है,\n# और दिए गए गड्ढों की संख्या के लिए सुरक्षित प्लेसमेंट संयोजनों की कुल गणना लौटाता है।\n#\n# उदाहरण:\n# >>> count_safe_placements(1)\n# 2\n# >>> count_safe_placements(4)\n# 13\n# >>> count_safe_placements(10)\n# 504\n\ndef count_safe_placements(n)",
      "hu": "# Kiszámítja, hogy hányféleképpen lehet biztonságosan elhelyezni a nukleáris anyagokat N gödörben, amelyek egy sorban vannak elrendezve\n# úgy, hogy ne legyen három egymást követő gödör, amely nukleáris anyagokat tartalmaz, elkerülve ezzel a robbanást.\n# A függvény egyetlen argumentumot vesz fel, n, amely egy pozitív egész szám, ami a gödrök számát jelenti,\n# és visszaadja a biztonságos elhelyezési kombinációk teljes számát a megadott gödörszámra.\n#\n# Példa:\n# >>> count_safe_placements(1)\n# 2\n# >>> count_safe_placements(4)\n# 13\n# >>> count_safe_placements(10)\n# 504\n\ndef count_safe_placements(n)"
    },
    "prompt_bertscore": {
      "sq": "0.9943436026392695",
      "hy": "0.9803763115056582",
      "bn": "0.9259116623955108",
      "bg": "0.9907867284060777",
      "zh": "0.9677569261377497",
      "fr": "0.9904683239052788",
      "de": "0.9675988163544459",
      "ha": "0.9193689762746027",
      "hi": "0.9831311162602311",
      "hu": "0.9596782312802987"
    },
    "canonical_solution": "    dp = [0, 2, 4, 7]\n    (4..n).each do |i|\n      dp[i] = dp[i-1] + dp[i-2] + dp[i-3]\n    end\n    dp[n]\n  end",
    "instruction": {
      "en": "Write a ruby function `def count_safe_placements(n)` to solve the following problem:\nCalculates the total number of ways to safely place nuclear materials in N pits arranged in a line\nsuch that no three consecutive pits contain nuclear materials, avoiding an explosion.\nThe function takes a single argument, n, which is a positive integer representing the number of pits,\nand returns the total count of safe placement combinations for the given number of pits.\n\nExample:\n>>> count_safe_placements(1)\n2\n>>> count_safe_placements(4)\n13\n>>> count_safe_placements(10)\n504",
      "sq": "Shkruani një funksion ruby `def count_safe_placements(n)` për të zgjidhur problemin në vijim:\nLlogarit numrin total të mënyrave për të vendosur në mënyrë të sigurt materialet bërthamore në N gropa të rreshtuara në një vijë\ntë tillë që asnjë tre gropa radhazi të mos përmbajnë materiale bërthamore, duke shmangur një shpërthim.\nFunksioni merr një argument të vetëm, n, i cili është një numër i plotë pozitiv që përfaqëson numrin e gropave,\ndhe kthen numrin total të kombinimeve të vendosjes së sigurt për numrin e dhënë të gropave.\n\nShembull:\n>>> count_safe_placements(1)\n2\n>>> count_safe_placements(4)\n13\n>>> count_safe_placements(10)\n504",
      "hy": "Գրեք ruby ֆունկցիա `def count_safe_placements(n)` հետևյալ խնդիրը լուծելու համար:\nՀաշվում է ընդհանուր քանակը, թե քանի եղանակով կարելի է անվտանգ տեղադրել միջուկային նյութերը N փոսերում, որոնք դասավորված են գծով այնպես, որ ոչ մի երեք հաջորդական փոսերում չլինեն միջուկային նյութեր՝ խուսափելով պայթյունից:\nՖունկցիան ընդունում է մեկ արգումենտ, n, որը դրական ամբողջ թիվ է, ներկայացնելով փոսերի քանակը, և վերադարձնում է տրված քանակի փոսերի համար անվտանգ տեղադրման կոմբինացիաների ընդհանուր քանակը:\n\nՕրինակ:\n>>> count_safe_placements(1)\n2\n>>> count_safe_placements(4)\n13\n>>> count_safe_placements(10)\n504",
      "bn": "একটি রুবি ফাংশন `def count_safe_placements(n)` লিখুন নিম্নলিখিত সমস্যার সমাধানের জন্য:\nএন পিট একটি লাইনে সাজানো অবস্থায় পারমাণবিক উপাদান নিরাপদে স্থাপন করার মোট সংখ্যা গণনা করে যাতে কোনো তিনটি পরপর পিট পারমাণবিক উপাদান ধারণ না করে, একটি বিস্ফোরণ এড়ানো যায়।\nফাংশনটি একটি একক আর্গুমেন্ট নেয়, n, যা পিটের সংখ্যা নির্দেশ করে একটি ধনাত্মক পূর্ণসংখ্যা, এবং প্রদত্ত পিটের সংখ্যার জন্য নিরাপদ স্থাপনার সংমিশ্রণের মোট সংখ্যা ফেরত দেয়।\n\nউদাহরণ:\n>>> count_safe_placements(1)\n2\n>>> count_safe_placements(4)\n13\n>>> count_safe_placements(10)\n504",
      "bg": "Напишете функция на ruby `def count_safe_placements(n)` за решаване на следния проблем:\nИзчислява общия брой начини за безопасно поставяне на ядрени материали в N ями, подредени в линия,\nтака че нито три последователни ями да съдържат ядрени материали, избягвайки експлозия.\nФункцията приема един аргумент, n, който е положително цяло число, представляващо броя на ямите,\nи връща общия брой на безопасните комбинации за поставяне за дадения брой ями.\n\nПример:\n>>> count_safe_placements(1)\n2\n>>> count_safe_placements(4)\n13\n>>> count_safe_placements(10)\n504",
      "zh": "编写一个 ruby 函数 `def count_safe_placements(n)` 来解决以下问题：\n计算将核材料安全放置在 N 个按直线排列的坑中的总方法数，\n使得没有三个连续的坑包含核材料，以避免爆炸。\n该函数接受一个参数 n，它是一个表示坑数量的正整数，\n并返回给定数量的坑的安全放置组合的总数。\n\n示例：\n>>> count_safe_placements(1)\n2\n>>> count_safe_placements(4)\n13\n>>> count_safe_placements(10)\n504",
      "fr": "Écrire une fonction ruby `def count_safe_placements(n)` pour résoudre le problème suivant :\nCalcule le nombre total de façons de placer en toute sécurité des matériaux nucléaires dans N fosses disposées en ligne\nde telle sorte qu'aucune trois fosses consécutives ne contiennent de matériaux nucléaires, évitant ainsi une explosion.\nLa fonction prend un seul argument, n, qui est un entier positif représentant le nombre de fosses,\net retourne le nombre total de combinaisons de placements sûrs pour le nombre donné de fosses.\n\nExemple :\n>>> count_safe_placements(1)\n2\n>>> count_safe_placements(4)\n13\n>>> count_safe_placements(10)\n504",
      "de": "Schreiben Sie eine Ruby-Funktion `def count_safe_placements(n)`, um das folgende Problem zu lösen:\nBerechnet die Gesamtanzahl der Möglichkeiten, nukleares Material sicher in N Gruben anzuordnen, die in einer Linie angeordnet sind,\nsodass keine drei aufeinanderfolgenden Gruben nukleares Material enthalten, um eine Explosion zu vermeiden.\nDie Funktion nimmt ein einziges Argument n, das eine positive ganze Zahl darstellt, die die Anzahl der Gruben angibt,\nund gibt die Gesamtanzahl der sicheren Platzierungskombinationen für die gegebene Anzahl von Gruben zurück.\n\nBeispiel:\n>>> count_safe_placements(1)\n2\n>>> count_safe_placements(4)\n13\n>>> count_safe_placements(10)\n504",
      "ha": "Rubuta aikin ruby `def count_safe_placements(n)` don warware matsalar mai zuwa:\nLissafa jimillar hanyoyin da za a iya sanya kayan nukiliya cikin aminci a cikin ramuka N da aka shirya a layi\nta yadda babu ramuka guda uku a jere da ke dauke da kayan nukiliya, don kaucewa fashewa.\nAikin yana daukar hujja guda, n, wanda yake lamba mai kyau da ke wakiltar yawan ramuka,\nkuma yana dawo da jimillar adadin hanyoyin sanya kayan cikin aminci don adadin ramukan da aka bayar.\n\nMisali:\n>>> count_safe_placements(1)\n2\n>>> count_safe_placements(4)\n13\n>>> count_safe_placements(10)\n504",
      "hi": "रूबी फ़ंक्शन `def count_safe_placements(n)` लिखें ताकि निम्नलिखित समस्या का समाधान किया जा सके:\nN गड्ढों में परमाणु सामग्री को सुरक्षित रूप से रखने के कुल तरीकों की गणना करता है जो एक पंक्ति में व्यवस्थित होते हैं\nताकि कोई भी तीन लगातार गड्ढे परमाणु सामग्री न रखें, जिससे विस्फोट से बचा जा सके।\nयह फ़ंक्शन एकल तर्क n लेता है, जो गड्ढों की संख्या का प्रतिनिधित्व करने वाला एक धनात्मक पूर्णांक है,\nऔर दिए गए गड्ढों की संख्या के लिए सुरक्षित प्लेसमेंट संयोजनों की कुल गणना लौटाता है।\n\nउदाहरण:\n>>> count_safe_placements(1)\n2\n>>> count_safe_placements(4)\n13\n>>> count_safe_placements(10)\n504",
      "hu": "Írj egy ruby függvényt `def count_safe_placements(n)` a következő probléma megoldására:\nKiszámítja, hogy hányféleképpen lehet biztonságosan elhelyezni nukleáris anyagokat N gödörben, amelyek egy sorban vannak elrendezve,\núgy, hogy ne legyen három egymást követő gödör, amely nukleáris anyagokat tartalmaz, elkerülve ezzel a robbanást.\nA függvény egyetlen argumentumot vesz fel, n, amely egy pozitív egész szám, és a gödrök számát jelenti,\nés visszaadja a biztonságos elhelyezési kombinációk teljes számát a megadott gödrök számára.\n\nPélda:\n>>> count_safe_placements(1)\n2\n>>> count_safe_placements(4)\n13\n>>> count_safe_placements(10)\n504"
    },
    "instruction_bertscore": {
      "sq": "0.984872906071526",
      "hy": "0.988077608639143",
      "bn": "0.9329658217475839",
      "bg": "0.9852141530661439",
      "zh": "0.9745359824120894",
      "fr": "0.9920561751712718",
      "de": "0.9798094203981846",
      "ha": "0.9513079470234885",
      "hi": "0.9755631001124208",
      "hu": "0.960596102271061"
    },
    "level": "easy",
    "test": "raise 'Test failed' unless count_safe_placements(1) == 2\nraise 'Test failed' unless count_safe_placements(4) == 13\nraise 'Test failed' unless count_safe_placements(10) == 504\nraise 'Test failed' unless count_safe_placements(3) == 7\nraise 'Test failed' unless count_safe_placements(2) == 4\n    \n\nputs 'All tests passed!'",
    "entry_point": "count_safe_placements",
    "signature": "def count_safe_placements(n)",
    "docstring": {
      "en": "Calculates the total number of ways to safely place nuclear materials in N pits arranged in a line\nsuch that no three consecutive pits contain nuclear materials, avoiding an explosion.\nThe function takes a single argument, n, which is a positive integer representing the number of pits,\nand returns the total count of safe placement combinations for the given number of pits.\n\nExample:\n>>> count_safe_placements(1)\n2\n>>> count_safe_placements(4)\n13\n>>> count_safe_placements(10)\n504",
      "sq": "Llogarit numrin total të mënyrave për të vendosur në mënyrë të sigurt materialet bërthamore në N gropa të radhitura në një linjë\ntë tilla që asnjë nga tre gropat e njëpasnjëshme të mos përmbajë materiale bërthamore, duke shmangur një shpërthim.\nFunksioni merr një argument të vetëm, n, i cili është një numër i plotë pozitiv që përfaqëson numrin e gropave,\ndhe kthen numrin total të kombinimeve të vendosjes së sigurt për numrin e dhënë të gropave.\n\nShembull:\n>>> count_safe_placements(1)\n2\n>>> count_safe_placements(4)\n13\n>>> count_safe_placements(10)\n504",
      "hy": "Հաշվում է միջուկային նյութերը N փոսերում անվտանգ տեղադրելու ընդհանուր եղանակների քանակը, որոնք դասավորված են գծով այնպես, որ ոչ մի երեք հաջորդական փոսերում միջուկային նյութեր չլինեն՝ խուսափելով պայթյունից:\nՖունկցիան ընդունում է մեկ արգումենտ՝ n, որը դրական ամբողջ թիվ է, ներկայացնելով փոսերի քանակը, և վերադարձնում է տվյալ քանակի փոսերի համար անվտանգ տեղադրման համակցությունների ընդհանուր քանակը:\n\nՕրինակ:\n>>> count_safe_placements(1)\n2\n>>> count_safe_placements(4)\n13\n>>> count_safe_placements(10)\n504",
      "bn": "নিউক্লিয়ার উপকরণগুলি একটি রেখায় সাজানো N গর্তে নিরাপদে স্থাপন করার মোট পদ্ধতির সংখ্যা গণনা করে\nযাতে কোন তিনটি পরপর গর্তে নিউক্লিয়ার উপকরণ না থাকে, বিস্ফোরণ এড়ানো যায়।\nফাংশনটি একটি একক আর্গুমেন্ট, n গ্রহণ করে, যা গর্তের সংখ্যা নির্দেশ করে একটি ধনাত্মক পূর্ণসংখ্যা,\nএবং প্রদত্ত গর্তের সংখ্যার জন্য নিরাপদ স্থাপনার সংমিশ্রণের মোট সংখ্যা ফেরত দেয়।\n\nউদাহরণ:\n>>> count_safe_placements(1)\n2\n>>> count_safe_placements(4)\n13\n>>> count_safe_placements(10)\n504",
      "bg": "Изчислява общия брой начини за безопасно разполагане на ядрени материали в N ями, подредени в линия, така че нито три последователни ями да съдържат ядрени материали, избягвайки експлозия. Функцията приема един аргумент, n, който е положително цяло число, представляващо броя на ямите, и връща общия брой безопасни комбинации за разполагане за дадения брой ями.\n\nПример:\n>>> count_safe_placements(1)\n2\n>>> count_safe_placements(4)\n13\n>>> count_safe_placements(10)\n504",
      "zh": "计算在排成一行的 N 个坑中安全放置核材料的总方法数，使得没有三个连续的坑包含核材料，从而避免爆炸。该函数接受一个参数 n，它是一个表示坑数量的正整数，并返回给定数量的坑的安全放置组合的总数。\n\n示例：\n>>> count_safe_placements(1)\n2\n>>> count_safe_placements(4)\n13\n>>> count_safe_placements(10)\n504",
      "fr": "Calcule le nombre total de façons de placer en toute sécurité des matériaux nucléaires dans N fosses disposées en ligne de manière à ce qu'aucune trois fosses consécutives ne contiennent de matériaux nucléaires, évitant ainsi une explosion. La fonction prend un seul argument, n, qui est un entier positif représentant le nombre de fosses, et renvoie le nombre total de combinaisons de placement sûres pour le nombre donné de fosses.\n\nExemple :\n>>> count_safe_placements(1)\n2\n>>> count_safe_placements(4)\n13\n>>> count_safe_placements(10)\n504",
      "de": "Berechnet die Gesamtanzahl der Möglichkeiten, nukleares Material sicher in N Gruben anzuordnen, die in einer Linie angeordnet sind, sodass keine drei aufeinanderfolgenden Gruben nukleares Material enthalten, um eine Explosion zu vermeiden. Die Funktion nimmt ein einziges Argument n, das eine positive ganze Zahl ist, die die Anzahl der Gruben darstellt, und gibt die Gesamtanzahl der sicheren Platzierungskombinationen für die gegebene Anzahl von Gruben zurück.\n\nBeispiel:\n>>> count_safe_placements(1)\n2\n>>> count_safe_placements(4)\n13\n>>> count_safe_placements(10)\n504",
      "ha": "Yana lissafin adadin hanyoyin da za a iya sanya kayan nukiliya cikin aminci a cikin ramuka N da aka shirya a layi\nta yadda babu ramuka guda uku a jere da ke dauke da kayan nukiliya, don gujewa fashewa.\nAikin yana daukar hujja guda, n, wanda yake lamba mai kyau da ke wakiltar adadin ramuka,\nkuma yana mayar da jimillar adadin haɗin haɗin da aka sanya cikin aminci don adadin ramuka da aka bayar.\n\nMisali:\n>>> count_safe_placements(1)\n2\n>>> count_safe_placements(4)\n13\n>>> count_safe_placements(10)\n504",
      "hi": "N गड्ढों में परमाणु सामग्री को सुरक्षित रूप से रखने के कुल तरीकों की गणना करता है जो एक पंक्ति में व्यवस्थित होते हैं ताकि कोई तीन लगातार गड्ढे परमाणु सामग्री न रखें, जिससे विस्फोट से बचा जा सके। यह फ़ंक्शन एकल तर्क n लेता है, जो गड्ढों की संख्या का प्रतिनिधित्व करने वाला एक धनात्मक पूर्णांक है, और दिए गए गड्ढों की संख्या के लिए सुरक्षित प्लेसमेंट संयोजनों की कुल गणना लौटाता है।\n\nउदाहरण:\n>>> count_safe_placements(1)\n2\n>>> count_safe_placements(4)\n13\n>>> count_safe_placements(10)\n504",
      "hu": "Kiszámítja, hogy hányféleképpen lehet biztonságosan elhelyezni a nukleáris anyagokat N gödörben, amelyek egy sorban vannak elrendezve, úgy, hogy ne legyen három egymást követő gödör, amely nukleáris anyagokat tartalmaz, elkerülve a robbanást. A függvény egyetlen argumentumot vesz fel, n-t, amely egy pozitív egész szám, ami a gödrök számát jelenti, és visszaadja a biztonságos elhelyezési kombinációk teljes számát a megadott gödrök számához.\n\nPélda:\n>>> count_safe_placements(1)\n2\n>>> count_safe_placements(4)\n13\n>>> count_safe_placements(10)\n504"
    },
    "docstring_bertscore": {
      "sq": "0.9950044459169726",
      "hy": "0.974340132856389",
      "bn": "0.9690817907792524",
      "bg": "0.9875276011140574",
      "zh": "0.9740241119201625",
      "fr": "0.9912848934017132",
      "de": "0.9721780411588242",
      "ha": "0.9734258372124854",
      "hi": "0.9680570566434934",
      "hu": "0.9569718923386984"
    }
  },
  {
    "task_id": "Ruby/40",
    "prompt": {
      "en": "# Calculates the time needed to hang a saline solution.\n#\n# The function takes two arguments: vul, which is the total volume of the saline solution in milliliters,\n# and d, which is the volume of each drop in milliliters. The function assumes that each drop takes \n# one second to fall and there is a one-second pause after a certain number of drops, which increases \n# sequentially (1 drop, then a pause, 2 drops, then a pause, and so on).\n# The function returns the total time in seconds required to hang the entire volume of saline solution.\n#\n# Examples:\n# >>> calculate_hanging_time(10, 1)\n# 13\n# >>> calculate_hanging_time(20, 2)\n# 13\n\n\ndef calculate_hanging_time(vul, d)",
      "sq": "# Llogarit kohën e nevojshme për të varur një solucion fiziologjik.\n#\n# Funksioni merr dy argumente: vul, që është vëllimi total i solucionit fiziologjik në mililitra,\n# dhe d, që është vëllimi i çdo pike në mililitra. Funksioni supozon se çdo pikë bie për një sekondë\n# dhe ka një pauzë prej një sekonde pas një numri të caktuar pikash, që rritet në mënyrë sekuenciale\n# (1 pikë, pastaj një pauzë, 2 pika, pastaj një pauzë, e kështu me radhë).\n# Funksioni kthen kohën totale në sekonda të nevojshme për të varur të gjithë vëllimin e solucionit fiziologjik.\n#\n# Shembuj:\n# >>> calculate_hanging_time(10, 1)\n# 13\n# >>> calculate_hanging_time(20, 2)\n# 13\n\n\ndef calculate_hanging_time(vul, d)",
      "hy": "# Հաշվում է աղի լուծույթի կախման համար անհրաժեշտ ժամանակը։\n#\n# Ֆունկցիան ընդունում է երկու արգումենտ՝ vul, որը աղի լուծույթի ընդհանուր ծավալն է միլիլիտրերով,\n# և d, որը յուրաքանչյուր կաթիլի ծավալն է միլիլիտրերով։ Ֆունկցիան ենթադրում է, որ յուրաքանչյուր կաթիլ\n# ընկնում է մեկ վայրկյանում, և կա մեկ վայրկյան դադար որոշակի քանակությամբ կաթիլներից հետո, որը\n# հաջորդաբար ավելանում է (1 կաթիլ, հետո դադար, 2 կաթիլ, հետո դադար և այդպես շարունակ)։\n# Ֆունկցիան վերադարձնում է ամբողջ աղի լուծույթի կախման համար անհրաժեշտ ընդհանուր ժամանակը վայրկյաններով։\n#\n# Օրինակներ:\n# >>> calculate_hanging_time(10, 1)\n# 13\n# >>> calculate_hanging_time(20, 2)\n# 13\n\n\ndef calculate_hanging_time(vul, d)",
      "bn": "# স্যালাইন সলিউশন ঝুলানোর জন্য প্রয়োজনীয় সময় গণনা করে।\n#\n# ফাংশনটি দুটি আর্গুমেন্ট নেয়: vul, যা স্যালাইন সলিউশনের মোট ভলিউম মিলিলিটারে,\n# এবং d, যা প্রতিটি ড্রপের ভলিউম মিলিলিটারে। ফাংশনটি ধরে নেয় যে প্রতিটি ড্রপ পড়তে এক সেকেন্ড সময় লাগে \n# এবং একটি নির্দিষ্ট সংখ্যক ড্রপের পরে এক সেকেন্ডের বিরতি থাকে, যা ক্রমান্বয়ে বৃদ্ধি পায় \n# (১ ড্রপ, তারপর একটি বিরতি, ২ ড্রপ, তারপর একটি বিরতি, এবং এভাবে চলতে থাকে)।\n# ফাংশনটি স্যালাইন সলিউশনের সম্পূর্ণ ভলিউম ঝুলানোর জন্য প্রয়োজনীয় মোট সময় সেকেন্ডে ফেরত দেয়।\n#\n# উদাহরণ:\n# >>> calculate_hanging_time(10, 1)\n# 13\n# >>> calculate_hanging_time(20, 2)\n# 13\n\n\ndef calculate_hanging_time(vul, d)",
      "bg": "# Изчислява времето, необходимо за окачване на физиологичен разтвор.\n#\n# Функцията приема два аргумента: vul, който е общият обем на физиологичния разтвор в милилитри,\n# и d, който е обемът на всяка капка в милилитри. Функцията предполага, че всяка капка пада \n# за една секунда и има едносекундна пауза след определен брой капки, която се увеличава \n# последователно (1 капка, след това пауза, 2 капки, след това пауза и така нататък).\n# Функцията връща общото време в секунди, необходимо за окачване на целия обем на физиологичния разтвор.\n#\n# Примери:\n# >>> calculate_hanging_time(10, 1)\n# 13\n# >>> calculate_hanging_time(20, 2)\n# 13\n\n\ndef calculate_hanging_time(vul, d)",
      "zh": "# 计算悬挂生理盐水所需的时间。\n#\n# 该函数接受两个参数：vul，即生理盐水的总容量（以毫升为单位），\n# 和 d，即每滴的容量（以毫升为单位）。函数假设每滴需要一秒钟滴落，\n# 并且在一定数量的滴落后有一秒钟的暂停，暂停的频率按顺序增加\n# （1滴后暂停，然后2滴后暂停，依此类推）。\n# 函数返回悬挂整个生理盐水体积所需的总时间（以秒为单位）。\n#\n# 示例：\n# >>> calculate_hanging_time(10, 1)\n# 13\n# >>> calculate_hanging_time(20, 2)\n# 13\n\n\ndef calculate_hanging_time(vul, d)",
      "fr": "# Calcule le temps nécessaire pour suspendre une solution saline.\n#\n# La fonction prend deux arguments : vul, qui est le volume total de la solution saline en millilitres,\n# et d, qui est le volume de chaque goutte en millilitres. La fonction suppose que chaque goutte met \n# une seconde à tomber et qu'il y a une pause d'une seconde après un certain nombre de gouttes, \n# qui augmente séquentiellement (1 goutte, puis une pause, 2 gouttes, puis une pause, et ainsi de suite).\n# La fonction renvoie le temps total en secondes nécessaire pour suspendre l'intégralité du volume de solution saline.\n#\n# Exemples :\n# >>> calculate_hanging_time(10, 1)\n# 13\n# >>> calculate_hanging_time(20, 2)\n# 13\n\n\ndef calculate_hanging_time(vul, d)",
      "de": "# Berechnet die benötigte Zeit, um eine Kochsalzlösung aufzuhängen.\n#\n# Die Funktion nimmt zwei Argumente: vul, das ist das Gesamtvolumen der Kochsalzlösung in Millilitern,\n# und d, das ist das Volumen jedes Tropfens in Millilitern. Die Funktion geht davon aus, dass jeder Tropfen \n# eine Sekunde benötigt, um zu fallen, und es nach einer bestimmten Anzahl von Tropfen eine einsekündige \n# Pause gibt, die sich sequentiell erhöht (1 Tropfen, dann eine Pause, 2 Tropfen, dann eine Pause, usw.).\n# Die Funktion gibt die Gesamtzeit in Sekunden zurück, die benötigt wird, um das gesamte Volumen der \n# Kochsalzlösung aufzuhängen.\n#\n# Beispiele:\n# >>> calculate_hanging_time(10, 1)\n# 13\n# >>> calculate_hanging_time(20, 2)\n# 13\n\n\ndef calculate_hanging_time(vul, d)",
      "ha": "# Lissafin lokacin da ake bukata don rataye ruwan magani.\n#\n# Aikin yana daukar hujjoji guda biyu: vul, wanda shine jimillar adadin ruwan magani a cikin milliliters,\n# da d, wanda shine adadin kowace digo a cikin milliliters. Aikin yana dauka cewa kowace digo tana daukar \n# dakika daya don fadowa kuma akwai tsayawa na dakika daya bayan wani adadin digo, wanda ke karuwa \n# a jere (digo 1, sannan tsayawa, digo 2, sannan tsayawa, da dai sauransu).\n# Aikin yana mayar da jimillar lokaci a cikin dakikoki da ake bukata don rataye dukkan adadin ruwan magani.\n#\n# Misalai:\n# >>> calculate_hanging_time(10, 1)\n# 13\n# >>> calculate_hanging_time(20, 2)\n# 13\n\n\ndef calculate_hanging_time(vul, d)",
      "hi": "# एक खारा घोल लटकाने के लिए आवश्यक समय की गणना करता है।\n#\n# यह फ़ंक्शन दो तर्क लेता है: vul, जो खारा घोल की कुल मात्रा मिलीलीटर में है,\n# और d, जो प्रत्येक बूंद की मात्रा मिलीलीटर में है। फ़ंक्शन मानता है कि प्रत्येक बूंद गिरने में \n# एक सेकंड का समय लेती है और एक निश्चित संख्या में बूंदों के बाद एक सेकंड का विराम होता है, \n# जो क्रमिक रूप से बढ़ता है (1 बूंद, फिर विराम, 2 बूंदें, फिर विराम, और इसी तरह)।\n# फ़ंक्शन खारा घोल की पूरी मात्रा को लटकाने के लिए आवश्यक कुल समय सेकंड में लौटाता है।\n#\n# उदाहरण:\n# >>> calculate_hanging_time(10, 1)\n# 13\n# >>> calculate_hanging_time(20, 2)\n# 13\n\n\ndef calculate_hanging_time(vul, d)",
      "hu": "# Kiszámítja a fiziológiás sóoldat felakasztásához szükséges időt.\n#\n# A függvény két argumentumot vesz: vul, amely a fiziológiás sóoldat teljes térfogata milliliterben,\n# és d, amely minden csepp térfogata milliliterben. A függvény feltételezi, hogy minden csepp egy másodperc alatt esik le,\n# és egy másodperces szünet van egy bizonyos számú csepp után, amely szekvenciálisan növekszik (1 csepp, majd szünet, 2 csepp, majd szünet, és így tovább).\n# A függvény visszaadja a teljes időt másodpercben, amely szükséges a teljes fiziológiás sóoldat felakasztásához.\n#\n# Példák:\n# >>> calculate_hanging_time(10, 1)\n# 13\n# >>> calculate_hanging_time(20, 2)\n# 13\n\n\ndef calculate_hanging_time(vul, d)"
    },
    "prompt_bertscore": {
      "sq": "0.9815160526320365",
      "hy": "0.9645001824103017",
      "bn": "0.9849597075480383",
      "bg": "0.9811166069357753",
      "zh": "0.9508503026255841",
      "fr": "0.9936098620117266",
      "de": "0.982424985255652",
      "ha": "0.9602745196841654",
      "hi": "0.9847908717241586",
      "hu": "0.9722485549440917"
    },
    "canonical_solution": "    time = 0\n    count = 0\n    i = 1\n  \n    while vul > 0\n      vul -= d\n      time += 1\n      count += 1\n  \n      if count == i && vul > 0\n        time += 1\n        i += 1\n        count = 0\n      end\n    end\n  \n    time\n  end",
    "instruction": {
      "en": "Write a ruby function `def calculate_hanging_time(vul, d)` to solve the following problem:\nCalculates the time needed to hang a saline solution.\n\nThe function takes two arguments: vul, which is the total volume of the saline solution in milliliters,\nand d, which is the volume of each drop in milliliters. The function assumes that each drop takes\none second to fall and there is a one-second pause after a certain number of drops, which increases\nsequentially (1 drop, then a pause, 2 drops, then a pause, and so on).\nThe function returns the total time in seconds required to hang the entire volume of saline solution.\n\nExamples:\n>>> calculate_hanging_time(10, 1)\n13\n>>> calculate_hanging_time(20, 2)\n13",
      "sq": "Shkruani një funksion ruby `def calculate_hanging_time(vul, d)` për të zgjidhur problemin e mëposhtëm:\nLlogarit kohën e nevojshme për të varur një zgjidhje saline.\n\nFunksioni merr dy argumente: vul, që është vëllimi total i zgjidhjes saline në mililitra,\ndhe d, që është vëllimi i çdo pike në mililitra. Funksioni supozon se çdo pikë merr\nnjë sekondë për të rënë dhe ka një pauzë një-sekondëshe pas një numri të caktuar pikash, që rritet\nnë mënyrë sekuenciale (1 pikë, pastaj një pauzë, 2 pika, pastaj një pauzë, e kështu me radhë).\nFunksioni kthen kohën totale në sekonda të nevojshme për të varur të gjithë vëllimin e zgjidhjes saline.\n\nShembuj:\n>>> calculate_hanging_time(10, 1)\n13\n>>> calculate_hanging_time(20, 2)\n13",
      "hy": "Գրեք ruby ֆունկցիա `def calculate_hanging_time(vul, d)` հետևյալ խնդիրը լուծելու համար:\nՀաշվում է ֆիզիոլոգիական լուծույթի կախման համար անհրաժեշտ ժամանակը:\n\nՖունկցիան ընդունում է երկու արգումենտ՝ vul, որը ֆիզիոլոգիական լուծույթի ընդհանուր ծավալն է միլիլիտրերով,\nև d, որը յուրաքանչյուր կաթիլի ծավալն է միլիլիտրերով: Ֆունկցիան ենթադրում է, որ յուրաքանչյուր կաթիլ ընկնում է\nմեկ վայրկյանում, և կա մեկ վայրկյան դադար որոշակի քանակի կաթիլներից հետո, որը մեծանում է հաջորդաբար (1 կաթիլ, ապա դադար, 2 կաթիլ, ապա դադար և այլն):\nՖունկցիան վերադարձնում է ամբողջ ֆիզիոլոգիական լուծույթի կախման համար անհրաժեշտ ընդհանուր ժամանակը վայրկյաններով:\n\nՕրինակներ:\n>>> calculate_hanging_time(10, 1)\n13\n>>> calculate_hanging_time(20, 2)\n13",
      "bn": "রুবি ফাংশন `def calculate_hanging_time(vul, d)` লিখুন নিম্নলিখিত সমস্যার সমাধানের জন্য:\nএকটি স্যালাইন সলিউশন ঝুলানোর জন্য প্রয়োজনীয় সময় গণনা করে।\n\nফাংশনটি দুটি আর্গুমেন্ট নেয়: vul, যা মিলিলিটারে স্যালাইন সলিউশনের মোট ভলিউম, এবং d, যা প্রতিটি ড্রপের ভলিউম মিলিলিটারে। ফাংশনটি ধরে নেয় যে প্রতিটি ড্রপ পড়তে এক সেকেন্ড সময় নেয় এবং একটি নির্দিষ্ট সংখ্যক ড্রপের পরে এক সেকেন্ডের বিরতি থাকে, যা ক্রমান্বয়ে বৃদ্ধি পায় (১ ড্রপ, তারপর একটি বিরতি, ২ ড্রপ, তারপর একটি বিরতি, এবং এভাবে চলতে থাকে)। ফাংশনটি স্যালাইন সলিউশনের পুরো ভলিউম ঝুলানোর জন্য প্রয়োজনীয় মোট সময় সেকেন্ডে রিটার্ন করে।\n\nউদাহরণ:\n>>> calculate_hanging_time(10, 1)\n13\n>>> calculate_hanging_time(20, 2)\n13",
      "bg": "Напишете функция на Ruby `def calculate_hanging_time(vul, d)` за решаване на следния проблем:\nИзчислява времето, необходимо за окачване на физиологичен разтвор.\n\nФункцията приема два аргумента: vul, който е общият обем на физиологичния разтвор в милилитри,\nи d, който е обемът на всяка капка в милилитри. Функцията предполага, че всяка капка отнема\nедна секунда да падне и има едносекундна пауза след определен брой капки, която се увеличава\nпоследователно (1 капка, след това пауза, 2 капки, след това пауза и така нататък).\nФункцията връща общото време в секунди, необходимо за окачване на целия обем физиологичен разтвор.\n\nПримери:\n>>> calculate_hanging_time(10, 1)\n13\n>>> calculate_hanging_time(20, 2)\n13",
      "zh": "编写一个 ruby 函数 `def calculate_hanging_time(vul, d)` 来解决以下问题：\n计算悬挂生理盐水所需的时间。\n\n该函数接受两个参数：vul，即生理盐水的总体积（以毫升为单位），以及 d，即每滴的体积（以毫升为单位）。函数假设每滴需要一秒钟落下，并且在一定数量的滴落后有一秒钟的暂停，暂停的频率按顺序增加（1滴，然后暂停，2滴，然后暂停，依此类推）。\n该函数返回悬挂整个生理盐水体积所需的总时间（以秒为单位）。\n\n示例：\n>>> calculate_hanging_time(10, 1)\n13\n>>> calculate_hanging_time(20, 2)\n13",
      "fr": "Écrire une fonction ruby `def calculate_hanging_time(vul, d)` pour résoudre le problème suivant :\nCalcule le temps nécessaire pour suspendre une solution saline.\n\nLa fonction prend deux arguments : vul, qui est le volume total de la solution saline en millilitres, et d, qui est le volume de chaque goutte en millilitres. La fonction suppose que chaque goutte met une seconde à tomber et qu'il y a une pause d'une seconde après un certain nombre de gouttes, qui augmente séquentiellement (1 goutte, puis une pause, 2 gouttes, puis une pause, et ainsi de suite). La fonction renvoie le temps total en secondes nécessaire pour suspendre l'ensemble du volume de la solution saline.\n\nExemples :\n>>> calculate_hanging_time(10, 1)\n13\n>>> calculate_hanging_time(20, 2)\n13",
      "de": "Schreiben Sie eine Ruby-Funktion `def calculate_hanging_time(vul, d)`, um das folgende Problem zu lösen:\nBerechnet die benötigte Zeit, um eine Kochsalzlösung aufzuhängen.\n\nDie Funktion nimmt zwei Argumente: vul, das ist das Gesamtvolumen der Kochsalzlösung in Millilitern,\nund d, das ist das Volumen jedes Tropfens in Millilitern. Die Funktion geht davon aus, dass jeder Tropfen\neine Sekunde zum Fallen benötigt und es nach einer bestimmten Anzahl von Tropfen eine einsekündige Pause gibt, die sich\nsequenziell erhöht (1 Tropfen, dann eine Pause, 2 Tropfen, dann eine Pause, und so weiter).\nDie Funktion gibt die Gesamtzeit in Sekunden zurück, die benötigt wird, um das gesamte Volumen der Kochsalzlösung aufzuhängen.\n\nBeispiele:\n>>> calculate_hanging_time(10, 1)\n13\n>>> calculate_hanging_time(20, 2)\n13",
      "ha": "Rubuta aikin ruby `def calculate_hanging_time(vul, d)` don warware matsalar mai zuwa:\nƘididdige lokacin da ake buƙata don rataye maganin saline.\n\nAikin yana ɗaukar hujjoji guda biyu: vul, wanda shine jimlar adadin maganin saline a cikin milliliters,\nda d, wanda shine adadin kowane digo a cikin milliliters. Aikin yana ɗauka cewa kowane digo yana ɗaukar\nsakan ɗaya don faɗuwa kuma akwai tazara na sakan ɗaya bayan wani adadin digo, wanda ke ƙaruwa\na jere (digo 1, sai tazara, digo 2, sai tazara, da sauransu).\nAikin yana dawowa da jimlar lokacin a cikin sakanni da ake buƙata don rataye dukkan adadin maganin saline.\n\nMisalai:\n>>> calculate_hanging_time(10, 1)\n13\n>>> calculate_hanging_time(20, 2)\n13",
      "hi": "`def calculate_hanging_time(vul, d)` निम्नलिखित समस्या को हल करने के लिए एक रूबी फ़ंक्शन लिखें:\nएक सलाइन समाधान को लटकाने के लिए आवश्यक समय की गणना करता है।\n\nयह फ़ंक्शन दो तर्क लेता है: `vul`, जो सलाइन समाधान की कुल मात्रा मिलीलीटर में है, और `d`, जो प्रत्येक बूंद की मात्रा मिलीलीटर में है। फ़ंक्शन मानता है कि प्रत्येक बूंद गिरने में एक सेकंड का समय लेती है और एक निश्चित संख्या में बूंदों के बाद एक सेकंड का विराम होता है, जो क्रमिक रूप से बढ़ता है (1 बूंद, फिर विराम, 2 बूंदें, फिर विराम, और इसी तरह)।\nफ़ंक्शन पूरे सलाइन समाधान की मात्रा को लटकाने के लिए आवश्यक कुल समय सेकंड में लौटाता है।\n\nउदाहरण:\n>>> calculate_hanging_time(10, 1)\n13\n>>> calculate_hanging_time(20, 2)\n13",
      "hu": "Írj egy ruby függvényt `def calculate_hanging_time(vul, d)` a következő probléma megoldására:\nKiszámítja a szükséges időt egy sóoldat felakasztásához.\n\nA függvény két argumentumot vesz: vul, amely a sóoldat teljes térfogata milliliterben, és d, amely minden csepp térfogata milliliterben. A függvény feltételezi, hogy minden csepp egy másodperc alatt esik le, és van egy másodperces szünet egy bizonyos számú csepp után, amely szekvenciálisan növekszik (1 csepp, majd szünet, 2 csepp, majd szünet, és így tovább).\nA függvény visszaadja a teljes időt másodpercben, amely szükséges a teljes sóoldat térfogatának felakasztásához.\n\nPéldák:\n>>> calculate_hanging_time(10, 1)\n13\n>>> calculate_hanging_time(20, 2)\n13"
    },
    "instruction_bertscore": {
      "sq": "0.9964425298756652",
      "hy": "0.9632686740478854",
      "bn": "0.9920792162954718",
      "bg": "0.9903503374589441",
      "zh": "0.9604747391082487",
      "fr": "0.993942369269579",
      "de": "0.9963857215866891",
      "ha": "0.9749058321815763",
      "hi": "0.9633820919954563",
      "hu": "0.9868478879501559"
    },
    "level": "easy",
    "test": "raise 'Test failed' unless calculate_hanging_time(10, 1) == 13\nraise 'Test failed' unless calculate_hanging_time(20, 2) == 13\nraise 'Test failed' unless calculate_hanging_time(15, 3) == 7\nraise 'Test failed' unless calculate_hanging_time(50, 5) == 13\nraise 'Test failed' unless calculate_hanging_time(100, 10) == 13\n\n  \nputs 'All tests passed!'",
    "entry_point": "calculate_hanging_time",
    "signature": "def calculate_hanging_time(vul, d)",
    "docstring": {
      "en": "Calculates the time needed to hang a saline solution.\n\nThe function takes two arguments: vul, which is the total volume of the saline solution in milliliters,\nand d, which is the volume of each drop in milliliters. The function assumes that each drop takes\none second to fall and there is a one-second pause after a certain number of drops, which increases\nsequentially (1 drop, then a pause, 2 drops, then a pause, and so on).\nThe function returns the total time in seconds required to hang the entire volume of saline solution.\n\nExamples:\n>>> calculate_hanging_time(10, 1)\n13\n>>> calculate_hanging_time(20, 2)\n13",
      "sq": "Llogarit kohën e nevojshme për të varur një solucion fiziologjik.\n\nFunksioni merr dy argumente: vul, që është vëllimi total i solucionit fiziologjik në mililitra, dhe d, që është vëllimi i çdo pike në mililitra. Funksioni supozon se çdo pikë merr një sekondë për të rënë dhe ka një pauzë prej një sekonde pas një numri të caktuar pikash, i cili rritet në mënyrë sekuenciale (1 pikë, pastaj një pauzë, 2 pika, pastaj një pauzë, dhe kështu me radhë). Funksioni kthen kohën totale në sekonda të nevojshme për të varur të gjithë vëllimin e solucionit fiziologjik.\n\nShembuj:\n>>> calculate_hanging_time(10, 1)\n13\n>>> calculate_hanging_time(20, 2)\n13",
      "hy": "Հաշվում է ֆիզիոլոգիական լուծույթի կախման համար անհրաժեշտ ժամանակը:\n\nՖունկցիան ընդունում է երկու արգումենտ՝ vul, որը ֆիզիոլոգիական լուծույթի ընդհանուր ծավալն է միլիլիտրերով, և d, որը յուրաքանչյուր կաթիլի ծավալն է միլիլիտրերով: Ֆունկցիան ենթադրում է, որ յուրաքանչյուր կաթիլ ընկնում է մեկ վայրկյանում և կա մեկ վայրկյան դադար որոշակի քանակի կաթիլներից հետո, որը հաջորդաբար մեծանում է (1 կաթիլ, ապա դադար, 2 կաթիլ, ապա դադար և այլն): Ֆունկցիան վերադարձնում է ընդհանուր ժամանակը վայրկյաններով, որը պահանջվում է ֆիզիոլոգիական լուծույթի ամբողջ ծավալը կախելու համար:\n\nՕրինակներ:\n>>> calculate_hanging_time(10, 1)\n13\n>>> calculate_hanging_time(20, 2)\n13",
      "bn": "স্যালাইন সলিউশন ঝোলানোর জন্য প্রয়োজনীয় সময় গণনা করে।\n\nফাংশনটি দুটি আর্গুমেন্ট নেয়: vul, যা মিলিলিটার হিসাবে স্যালাইন সলিউশনের মোট ভলিউম, এবং d, যা মিলিলিটার হিসাবে প্রতিটি ড্রপের ভলিউম। ফাংশনটি ধরে নেয় যে প্রতিটি ড্রপ পড়তে এক সেকেন্ড সময় নেয় এবং একটি নির্দিষ্ট সংখ্যক ড্রপের পরে এক সেকেন্ডের বিরতি থাকে, যা ক্রমান্বয়ে বৃদ্ধি পায় (১ ড্রপ, তারপর বিরতি, ২ ড্রপ, তারপর বিরতি, এভাবে চলতে থাকে)। ফাংশনটি স্যালাইন সলিউশনের সম্পূর্ণ ভলিউম ঝোলানোর জন্য প্রয়োজনীয় মোট সময় সেকেন্ডে রিটার্ন করে।\n\nউদাহরণ:\n>>> calculate_hanging_time(10, 1)\n13\n>>> calculate_hanging_time(20, 2)\n13",
      "bg": "Изчислява времето, необходимо за окачване на физиологичен разтвор.\n\nФункцията приема два аргумента: vul, който е общият обем на физиологичния разтвор в милилитри,\nи d, който е обемът на всяка капка в милилитри. Функцията предполага, че всяка капка отнема\nедна секунда да падне и има едносекундна пауза след определен брой капки, която се увеличава\nпоследователно (1 капка, след това пауза, 2 капки, след това пауза и така нататък).\nФункцията връща общото време в секунди, необходимо за окачване на целия обем на физиологичния разтвор.\n\nПримери:\n>>> calculate_hanging_time(10, 1)\n13\n>>> calculate_hanging_time(20, 2)\n13",
      "zh": "计算悬挂生理盐水所需的时间。\n\n该函数接受两个参数：vul，表示生理盐水的总体积（以毫升为单位），以及d，表示每滴的体积（以毫升为单位）。函数假设每滴需要一秒钟滴下，并且在一定数量的滴落后会有一秒钟的暂停，这个数量依次增加（1滴，然后暂停，2滴，然后暂停，依此类推）。\n函数返回悬挂整个生理盐水体积所需的总时间（以秒为单位）。\n\n示例：\n>>> calculate_hanging_time(10, 1)\n13\n>>> calculate_hanging_time(20, 2)\n13",
      "fr": "Calcule le temps nécessaire pour suspendre une solution saline.\n\nLa fonction prend deux arguments : vul, qui est le volume total de la solution saline en millilitres, et d, qui est le volume de chaque goutte en millilitres. La fonction suppose que chaque goutte prend une seconde pour tomber et qu'il y a une pause d'une seconde après un certain nombre de gouttes, qui augmente séquentiellement (1 goutte, puis une pause, 2 gouttes, puis une pause, et ainsi de suite). La fonction renvoie le temps total en secondes nécessaire pour suspendre l'ensemble du volume de la solution saline.\n\nExemples :\n>>> calculate_hanging_time(10, 1)\n13\n>>> calculate_hanging_time(20, 2)\n13",
      "de": "Berechnet die benötigte Zeit, um eine Kochsalzlösung aufzuhängen.\n\nDie Funktion nimmt zwei Argumente: vul, das ist das Gesamtvolumen der Kochsalzlösung in Millilitern, und d, das ist das Volumen jedes Tropfens in Millilitern. Die Funktion geht davon aus, dass jeder Tropfen eine Sekunde benötigt, um zu fallen, und es nach einer bestimmten Anzahl von Tropfen eine einsekündige Pause gibt, die sich nacheinander erhöht (1 Tropfen, dann eine Pause, 2 Tropfen, dann eine Pause und so weiter). Die Funktion gibt die Gesamtzeit in Sekunden zurück, die benötigt wird, um das gesamte Volumen der Kochsalzlösung aufzuhängen.\n\nBeispiele:\n>>> calculate_hanging_time(10, 1)\n13\n>>> calculate_hanging_time(20, 2)\n13",
      "ha": "Lissafin lokacin da ake bukata don rataye ruwan magani.\n\nAikin yana ɗaukar hujjoji guda biyu: vul, wanda shine jimillar adadin ruwan gishiri a cikin mililita,\nda d, wanda shine adadin kowace digo a cikin mililita. Aikin yana ɗauka cewa kowace digo tana ɗaukar\ndaukacin dakika ɗaya don faɗuwa kuma akwai dakatarwa na dakika ɗaya bayan wani adadin digo, wanda ke ƙaruwa\na jere (digo 1, sannan dakatarwa, digo 2, sannan dakatarwa, da dai sauransu).\nAikin yana dawowa da jimillar lokaci a cikin dakiku da ake buƙata don rataye dukkan adadin ruwan gishiri.\n\nMisalai:\n>>> calculate_hanging_time(10, 1)\n13\n>>> calculate_hanging_time(20, 2)\n13",
      "hi": "सलाइन घोल को लटकाने के लिए आवश्यक समय की गणना करता है।\n\nयह फ़ंक्शन दो तर्क लेता है: vul, जो मिलीलीटर में सलाइन घोल की कुल मात्रा है, और d, जो प्रत्येक बूंद की मात्रा मिलीलीटर में है। फ़ंक्शन मानता है कि प्रत्येक बूंद गिरने में एक सेकंड का समय लेती है और एक निश्चित संख्या में बूंदों के बाद एक सेकंड का विराम होता है, जो क्रमिक रूप से बढ़ता है (1 बूंद, फिर विराम, 2 बूंदें, फिर विराम, और इसी तरह)।\nफ़ंक्शन सलाइन घोल की पूरी मात्रा को लटकाने के लिए आवश्यक कुल समय सेकंड में लौटाता है।\n\nउदाहरण:\n>>> calculate_hanging_time(10, 1)\n13\n>>> calculate_hanging_time(20, 2)\n13",
      "hu": "Kiszámítja a szükséges időt a sóoldat felakasztásához.\n\nA függvény két argumentumot vesz: vul, amely a sóoldat teljes térfogata milliliterben, és d, amely minden csepp térfogata milliliterben. A függvény feltételezi, hogy minden csepp egy másodperc alatt esik le, és bizonyos számú csepp után egy másodperces szünet van, amely szekvenciálisan növekszik (1 csepp, majd szünet, 2 csepp, majd szünet, és így tovább). A függvény visszaadja a teljes időt másodpercben, amely szükséges a teljes sóoldat térfogatának felakasztásához.\n\nPéldák:\n>>> calculate_hanging_time(10, 1)\n13\n>>> calculate_hanging_time(20, 2)\n13"
    },
    "docstring_bertscore": {
      "sq": "0.9873824023055208",
      "hy": "0.990315378511882",
      "bn": "0.9580389347456179",
      "bg": "0.9888741164670928",
      "zh": "0.9517288448009015",
      "fr": "0.9917147295462727",
      "de": "0.9938223965194339",
      "ha": "0.9502919526244951",
      "hi": "0.9836705963751219",
      "hu": "0.9763371627073137"
    }
  },
  {
    "task_id": "Ruby/41",
    "prompt": {
      "en": "# Counts the number of pairs of students who are considered \"equally matched opponents\".\n# Two students are \"equally matched\" if the difference in scores for each subject (Chinese, Mathematics, English) \n# is no more than 5 points, and the total score difference is no more than 10 points.\n# The function takes an array of arrays, where each sub-array represents a student's scores in the three subjects,\n# and returns the total count of \"equally matched\" student pairs.\n#\n# Example:\n# >>> count_matching_pairs([[90, 90, 90], [85, 95, 90], [80, 100, 91]])\n# 2\n\n\ndef count_matching_pairs(students_scores)",
      "sq": "# Numëron numrin e çifteve të studentëve që konsiderohen \"kundërshtarë të barabartë\".\n# Dy studentë janë \"të barabartë\" nëse diferenca në pikët për çdo lëndë (Kinezisht, Matematikë, Anglisht)\n# nuk është më shumë se 5 pikë, dhe diferenca totale e pikëve nuk është më shumë se 10 pikë.\n# Funksioni merr një varg me vargje, ku çdo nën-varg përfaqëson pikët e një studenti në tre lëndët,\n# dhe kthen numrin total të çifteve të studentëve \"të barabartë\".\n#\n# Shembull:\n# >>> count_matching_pairs([[90, 90, 90], [85, 95, 90], [80, 100, 91]])\n# 2\n\n\ndef count_matching_pairs(students_scores)",
      "hy": "# Հաշվում է ուսանողների զույգերի քանակը, որոնք համարվում են \"հավասարապես համընկնող մրցակիցներ\":\n# Երկու ուսանող \"հավասարապես համընկնող\" են, եթե յուրաքանչյուր առարկայի (չինարեն, մաթեմատիկա, անգլերեն) \n# գնահատականների տարբերությունը չի գերազանցում 5 միավորը, և ընդհանուր գնահատականների տարբերությունը չի գերազանցում 10 միավորը:\n# Ֆունկցիան ընդունում է զանգվածների զանգված, որտեղ յուրաքանչյուր ենթազանգված ներկայացնում է ուսանողի գնահատականները երեք առարկաներում,\n# և վերադարձնում է \"հավասարապես համընկնող\" ուսանողների զույգերի ընդհանուր քանակը:\n#\n# Օրինակ:\n# >>> count_matching_pairs([[90, 90, 90], [85, 95, 90], [80, 100, 91]])\n# 2\n\n\ndef count_matching_pairs(students_scores)",
      "bn": "# \"সমানভাবে মেলানো প্রতিদ্বন্দ্বী\" হিসেবে বিবেচিত ছাত্রদের জোড়ার সংখ্যা গণনা করে।\n# দুই ছাত্র \"সমানভাবে মেলানো\" হয় যদি প্রতিটি বিষয়ের (চীনা, গণিত, ইংরেজি) স্কোরের পার্থক্য \n# ৫ পয়েন্টের বেশি না হয়, এবং মোট স্কোরের পার্থক্য ১০ পয়েন্টের বেশি না হয়।\n# ফাংশনটি একটি অ্যারের অ্যারে নেয়, যেখানে প্রতিটি উপ-অ্যারে একটি ছাত্রের তিনটি বিষয়ে স্কোর উপস্থাপন করে,\n# এবং \"সমানভাবে মেলানো\" ছাত্র জোড়ার মোট সংখ্যা ফেরত দেয়।\n#\n# উদাহরণ:\n# >>> count_matching_pairs([[90, 90, 90], [85, 95, 90], [80, 100, 91]])\n# 2\n\n\ndef count_matching_pairs(students_scores)",
      "bg": "# Брои броя на двойките ученици, които се считат за \"равностойни противници\".\n# Двама ученици са \"равностойни\", ако разликата в точките за всеки предмет (Китайски, Математика, Английски)\n# е не повече от 5 точки, а разликата в общия брой точки е не повече от 10 точки.\n# Функцията приема масив от масиви, където всеки подмасив представлява точките на ученик в трите предмета,\n# и връща общия брой на двойките ученици, които са \"равностойни\".\n#\n# Пример:\n# >>> count_matching_pairs([[90, 90, 90], [85, 95, 90], [80, 100, 91]])\n# 2\n\n\ndef count_matching_pairs(students_scores)",
      "zh": "# 计算被认为是“实力相当的对手”的学生对数。\n# 如果每个科目（语文、数学、英语）的分数差不超过5分，且总分差不超过10分，则两名学生被认为是“实力相当”。\n# 该函数接收一个数组的数组，其中每个子数组表示一名学生在三个科目中的分数，\n# 并返回“实力相当”学生对的总数。\n#\n# 例子:\n# >>> count_matching_pairs([[90, 90, 90], [85, 95, 90], [80, 100, 91]])\n# 2\n\ndef count_matching_pairs(students_scores)",
      "fr": "# Compte le nombre de paires d'étudiants considérés comme des \"adversaires également assortis\".\n# Deux étudiants sont \"également assortis\" si la différence de scores pour chaque matière (Chinois, Mathématiques, Anglais)\n# ne dépasse pas 5 points, et si la différence de score total ne dépasse pas 10 points.\n# La fonction prend un tableau de tableaux, où chaque sous-tableau représente les scores d'un étudiant dans les trois matières,\n# et renvoie le nombre total de paires d'étudiants \"également assortis\".\n#\n# Exemple :\n# >>> count_matching_pairs([[90, 90, 90], [85, 95, 90], [80, 100, 91]])\n# 2\n\n\ndef count_matching_pairs(students_scores)",
      "de": "# Zählt die Anzahl der Paare von Schülern, die als \"gleichwertige Gegner\" betrachtet werden.\n# Zwei Schüler sind \"gleichwertig\", wenn der Unterschied in den Punkten für jedes Fach (Chinesisch, Mathematik, Englisch)\n# nicht mehr als 5 Punkte beträgt und der Gesamtnotenunterschied nicht mehr als 10 Punkte beträgt.\n# Die Funktion nimmt ein Array von Arrays, wobei jedes Unter-Array die Noten eines Schülers in den drei Fächern darstellt,\n# und gibt die Gesamtanzahl der \"gleichwertigen\" Schülerpaare zurück.\n#\n# Beispiel:\n# >>> count_matching_pairs([[90, 90, 90], [85, 95, 90], [80, 100, 91]])\n# 2\n\n\ndef count_matching_pairs(students_scores)",
      "ha": "# Yana ƙididdige yawan ma'auratan ɗalibai waɗanda ake ɗauka \"abokan hamayya masu daidaito\".\n# Ana ɗaukar ɗalibai biyu \"masu daidaito\" idan bambancin maki a kowanne fanni (Sinanci, Lissafi, Turanci)\n# ba ya wuce maki 5, kuma bambancin jimillar maki ba ya wuce maki 10.\n# Aikin yana ɗaukar jerin jerin, inda kowanne ƙaramin jerin ke wakiltar maki na ɗalibi a fannoni uku,\n# kuma yana dawo da jimillar yawan ma'auratan ɗalibai \"masu daidaito\".\n#\n# Misali:\n# >>> count_matching_pairs([[90, 90, 90], [85, 95, 90], [80, 100, 91]])\n# 2\n\n\ndef count_matching_pairs(students_scores)",
      "hi": "# उन छात्रों की जोड़ी की संख्या गिनता है जिन्हें \"समान रूप से मेल खाते प्रतिद्वंद्वी\" माना जाता है।\n# दो छात्र \"समान रूप से मेल खाते\" होते हैं यदि प्रत्येक विषय (चीनी, गणित, अंग्रेजी) के लिए अंकों में अंतर 5 अंकों से अधिक नहीं है,\n# और कुल अंकों का अंतर 10 अंकों से अधिक नहीं है।\n# यह फ़ंक्शन एक सरणी की सरणी लेता है, जहां प्रत्येक उप-सरणी तीन विषयों में एक छात्र के अंकों का प्रतिनिधित्व करती है,\n# और \"समान रूप से मेल खाते\" छात्र जोड़ों की कुल संख्या लौटाता है।\n#\n# उदाहरण:\n# >>> count_matching_pairs([[90, 90, 90], [85, 95, 90], [80, 100, 91]])\n# 2\n\n\ndef count_matching_pairs(students_scores)",
      "hu": "# Megszámolja azon diákpárok számát, akiket \"egyenlően illeszkedő ellenfeleknek\" tekintünk.\n# Két diák \"egyenlően illeszkedő\", ha az egyes tantárgyak (kínai, matematika, angol) pontszámainak különbsége\n# legfeljebb 5 pont, és az összpontszám különbsége legfeljebb 10 pont.\n# A függvény egy tömbök tömbjét veszi át, ahol minden al-tömb egy diák pontszámait jelenti a három tantárgyban,\n# és visszaadja az \"egyenlően illeszkedő\" diákpárok teljes számát.\n#\n# Példa:\n# >>> count_matching_pairs([[90, 90, 90], [85, 95, 90], [80, 100, 91]])\n# 2\n\n\ndef count_matching_pairs(students_scores)"
    },
    "prompt_bertscore": {
      "sq": "0.971220444091855",
      "hy": "0.9763600052011328",
      "bn": "0.9723540276764212",
      "bg": "0.9581436129564231",
      "zh": "0.9392683637378209",
      "fr": "0.9725884115260424",
      "de": "0.9571609884614436",
      "ha": "0.9292367349740349",
      "hi": "0.9665476643780093",
      "hu": "0.9753670519263393"
    },
    "canonical_solution": "  # Initialize a counter for matching pairs\n  matching_pairs_count = 0\n  \n  # Iterate over the array of students_scores with indices\n  students_scores.each_with_index do |student1, index1|\n    # Compare the current student with every other student ahead in the list\n    students_scores[(index1+1)..-1].each do |student2|\n      # Calculate the absolute differences in scores for each subject\n      differences = student1.zip(student2).map { |score1, score2| (score1 - score2).abs }\n      \n      # Calculate the total scores for each student to check the total score difference\n      total_score_diff = (student1.sum - student2.sum).abs\n      \n      # Check if the pair is \"equally matched\"\n      if differences.all? { |diff| diff <= 5 } && total_score_diff <= 10\n        # If they are equally matched, increment the counter\n        matching_pairs_count += 1\n      end\n    end\n  end\n  \n  # Return the total count of equally matched pairs\n\n  matching_pairs_count\nend",
    "instruction": {
      "en": "Write a ruby function `def count_matching_pairs(students_scores)` to solve the following problem:\nCounts the number of pairs of students who are considered \"equally matched opponents\".\n Two students are \"equally matched\" if the difference in scores for each subject (Chinese, Mathematics, English) \n is no more than 5 points, and the total score difference is no more than 10 points.\n The function takes an array of arrays, where each sub-array represents a student's scores in the three subjects,\n and returns the total count of \"equally matched\" student pairs.\n\n Example:\n >>> count_matching_pairs([[90, 90, 90], [85, 95, 90], [80, 100, 91]])\n 2",
      "sq": "Shkruani një funksion ruby `def count_matching_pairs(students_scores)` për të zgjidhur problemin në vijim:\nNumëron çiftet e studentëve që konsiderohen \"kundërshtarë të barabartë\".\n Dy studentë janë \"të barabartë\" nëse diferenca në pikët për çdo lëndë (Kinezisht, Matematikë, Anglisht)\n nuk është më shumë se 5 pikë, dhe diferenca totale e pikëve nuk është më shumë se 10 pikë.\n Funksioni merr një varg me vargje, ku çdo nën-varg përfaqëson pikët e një studenti në tre lëndët,\n dhe kthen numrin total të çifteve të studentëve \"të barabartë\".\n\n Shembull:\n >>> count_matching_pairs([[90, 90, 90], [85, 95, 90], [80, 100, 91]])\n 2",
      "hy": "Գրեք ruby ֆունկցիա `def count_matching_pairs(students_scores)` հետևյալ խնդիրը լուծելու համար:\nՀաշվում է ուսանողների զույգերի քանակը, ովքեր համարվում են \"հավասարապես համընկնող մրցակիցներ\":\nԵրկու ուսանող \"հավասարապես համընկնող\" են, եթե յուրաքանչյուր առարկայի (չինարեն, մաթեմատիկա, անգլերեն) գնահատականների տարբերությունը \nչգերազանցի 5 միավորը, և ընդհանուր գնահատականների տարբերությունը չգերազանցի 10 միավորը:\nՖունկցիան ընդունում է զանգվածների զանգված, որտեղ յուրաքանչյուր ենթազանգված ներկայացնում է ուսանողի գնահատականները երեք առարկաներում,\nև վերադարձնում է \"հավասարապես համընկնող\" ուսանողների զույգերի ընդհանուր քանակը:\n\nՕրինակ:\n>>> count_matching_pairs([[90, 90, 90], [85, 95, 90], [80, 100, 91]])\n2",
      "bn": "রুবি ফাংশন `def count_matching_pairs(students_scores)` লিখুন নিম্নলিখিত সমস্যার সমাধানের জন্য:\nছাত্রদের মধ্যে \"সমানভাবে মেলানো প্রতিপক্ষ\" হিসেবে বিবেচিত জোড়াগুলির সংখ্যা গণনা করে।\n দুটি ছাত্র \"সমানভাবে মেলানো\" হয় যদি প্রতিটি বিষয়ে (চীনা, গণিত, ইংরেজি) স্কোরের পার্থক্য ৫ পয়েন্টের বেশি না হয়, এবং মোট স্কোরের পার্থক্য ১০ পয়েন্টের বেশি না হয়।\n ফাংশনটি অ্যারে অফ অ্যারে নেয়, যেখানে প্রতিটি সাব-অ্যারে একটি ছাত্রের তিনটি বিষয়ে স্কোর উপস্থাপন করে,\n এবং \"সমানভাবে মেলানো\" ছাত্র জোড়াগুলির মোট সংখ্যা ফেরত দেয়।\n\n উদাহরণ:\n >>> count_matching_pairs([[90, 90, 90], [85, 95, 90], [80, 100, 91]])\n 2",
      "bg": "Напишете Ruby функция `def count_matching_pairs(students_scores)`, за да решите следния проблем:\nБрои броя на двойките ученици, които се считат за \"равностойни противници\".\n Двама ученици са \"равностойни\", ако разликата в точките за всеки предмет (Китайски, Математика, Английски)\n не е повече от 5 точки, а общата разлика в точките не е повече от 10 точки.\n Функцията приема масив от масиви, където всеки подмасив представлява точките на ученик в трите предмета,\n и връща общия брой на \"равностойните\" двойки ученици.\n\n Пример:\n >>> count_matching_pairs([[90, 90, 90], [85, 95, 90], [80, 100, 91]])\n 2",
      "zh": "编写一个 ruby 函数 `def count_matching_pairs(students_scores)` 来解决以下问题：\n计算被认为是“势均力敌的对手”的学生对的数量。\n如果两个学生在每个科目（语文、数学、英语）的分数差不超过 5 分，并且总分差不超过 10 分，则认为他们是“势均力敌”的。\n该函数接受一个数组的数组，其中每个子数组代表一个学生在三个科目中的分数，并返回“势均力敌”学生对的总数。\n\n示例：\n>>> count_matching_pairs([[90, 90, 90], [85, 95, 90], [80, 100, 91]])\n2",
      "fr": "Écrire une fonction ruby `def count_matching_pairs(students_scores)` pour résoudre le problème suivant :\nCompte le nombre de paires d'étudiants considérés comme des \"adversaires également assortis\".\nDeux étudiants sont \"également assortis\" si la différence de scores pour chaque matière (Chinois, Mathématiques, Anglais)\nn'est pas supérieure à 5 points, et si la différence de score total n'est pas supérieure à 10 points.\nLa fonction prend un tableau de tableaux, où chaque sous-tableau représente les scores d'un étudiant dans les trois matières,\net retourne le nombre total de paires d'étudiants \"également assortis\".\n\nExemple :\n>>> count_matching_pairs([[90, 90, 90], [85, 95, 90], [80, 100, 91]])\n2",
      "de": "Schreiben Sie eine Ruby-Funktion `def count_matching_pairs(students_scores)`, um das folgende Problem zu lösen:\nZählt die Anzahl der Paare von Schülern, die als \"gleichwertige Gegner\" betrachtet werden.\n Zwei Schüler sind \"gleichwertig\", wenn der Unterschied in den Punkten für jedes Fach (Chinesisch, Mathematik, Englisch) \n nicht mehr als 5 Punkte beträgt und der Gesamtnotenunterschied nicht mehr als 10 Punkte beträgt.\n Die Funktion nimmt ein Array von Arrays, wobei jedes Unter-Array die Punktzahlen eines Schülers in den drei Fächern darstellt,\n und gibt die Gesamtanzahl der \"gleichwertigen\" Schülerpaare zurück.\n\n Beispiel:\n >>> count_matching_pairs([[90, 90, 90], [85, 95, 90], [80, 100, 91]])\n 2",
      "ha": "Rubuta aikin ruby `def count_matching_pairs(students_scores)` don warware matsalar mai zuwa:\nYana ƙidayar adadin ma'aurata na ɗalibai waɗanda ake ɗauka \"abokan hamayya masu daidaituwa\".\n Ana ɗaukar ɗalibai biyu \"masu daidaituwa\" idan bambancin maki a kowace darasi (Sinanci, Lissafi, Turanci)\n ba ya wuce maki 5, kuma bambancin jimillar maki ba ya wuce maki 10.\n Aikin yana ɗaukar jerin jerin, inda kowace ƙaramin jeri ke wakiltar maki na ɗalibi a cikin darussa uku,\n kuma yana dawo da jimillar adadin ma'aurata na ɗalibai \"masu daidaituwa\".\n\n Misali:\n >>> count_matching_pairs([[90, 90, 90], [85, 95, 90], [80, 100, 91]])\n 2",
      "hi": "रूबी फ़ंक्शन `def count_matching_pairs(students_scores)` लिखें ताकि निम्नलिखित समस्या का समाधान किया जा सके:\nउन छात्रों के जोड़ों की संख्या गिनता है जिन्हें \"समान रूप से मेल खाते प्रतिद्वंद्वी\" माना जाता है।\n दो छात्र \"समान रूप से मेल खाते\" होते हैं यदि प्रत्येक विषय (चीनी, गणित, अंग्रेजी) के लिए अंकों का अंतर 5 अंक से अधिक नहीं है, और कुल अंक का अंतर 10 अंक से अधिक नहीं है।\n फ़ंक्शन एक सरणी का सरणी लेता है, जहाँ प्रत्येक उप-सरणी तीन विषयों में एक छात्र के अंक का प्रतिनिधित्व करती है,\n और \"समान रूप से मेल खाते\" छात्र जोड़ों की कुल संख्या लौटाता है।\n\n उदाहरण:\n >>> count_matching_pairs([[90, 90, 90], [85, 95, 90], [80, 100, 91]])\n 2",
      "hu": "Írj egy Ruby függvényt `def count_matching_pairs(students_scores)` a következő probléma megoldására:\nSzámolja meg azoknak a diákpároknak a számát, akiket \"egyenlően illeszkedő ellenfeleknek\" tekintenek.\n Két diák \"egyenlően illeszkedő\", ha az egyes tantárgyak (kínai, matematika, angol) pontszámai közötti különbség\n legfeljebb 5 pont, és az összpontszám különbsége legfeljebb 10 pont.\n A függvény egy tömböt vesz át, ahol minden al-tömb egy diák pontszámait képviseli a három tantárgyban,\n és visszaadja az \"egyenlően illeszkedő\" diákpárok összesített számát.\n\n Példa:\n >>> count_matching_pairs([[90, 90, 90], [85, 95, 90], [80, 100, 91]])\n 2"
    },
    "instruction_bertscore": {
      "sq": "0.9730615490936674",
      "hy": "0.97516564071997",
      "bn": "0.9700453467576526",
      "bg": "0.9702537100273583",
      "zh": "0.9495309996347504",
      "fr": "0.9784343022702802",
      "de": "0.9661794036515706",
      "ha": "0.9347149608829771",
      "hi": "0.9874463612882141",
      "hu": "0.9611171097605155"
    },
    "level": "hard",
    "test": "raise 'Test failed' unless count_matching_pairs([[90, 90, 90], [85, 95, 90], [80, 100, 91]]) == 2\nraise 'Test failed' unless count_matching_pairs([[100, 100, 100], [100, 100, 105], [90, 90, 90]]) == 1\nraise 'Test failed' unless count_matching_pairs([[90, 90, 90], [85, 80, 85], [80, 85, 80], [76, 81, 85]]) == 2\nraise 'Test failed' unless count_matching_pairs([[100, 100, 100]]) == 0\nraise 'Test failed' unless count_matching_pairs([]) == 0",
    "entry_point": "count_matching_pairs",
    "signature": "def count_matching_pairs(students_scores)",
    "docstring": {
      "en": "Counts the number of pairs of students who are considered \"equally matched opponents\".\n Two students are \"equally matched\" if the difference in scores for each subject (Chinese, Mathematics, English) \n is no more than 5 points, and the total score difference is no more than 10 points.\n The function takes an array of arrays, where each sub-array represents a student's scores in the three subjects,\n and returns the total count of \"equally matched\" student pairs.\n\n Example:\n >>> count_matching_pairs([[90, 90, 90], [85, 95, 90], [80, 100, 91]])\n 2",
      "sq": "Numëron numrin e çifteve të studentëve që konsiderohen \"kundërshtarë të barabartë\". Dy studentë janë \"të barabartë\" nëse diferenca në pikët për secilin lëndë (Kinezisht, Matematikë, Anglisht) nuk është më shumë se 5 pikë, dhe diferenca totale e pikëve nuk është më shumë se 10 pikë. Funksioni merr një varg me vargje, ku secili nën-varg përfaqëson pikët e një studenti në tre lëndët, dhe kthen numrin total të çifteve të studentëve \"të barabartë\".\n\nShembull:\n>>> count_matching_pairs([[90, 90, 90], [85, 95, 90], [80, 100, 91]])\n2",
      "hy": "Հաշվում է ուսանողների զույգերի քանակը, որոնք համարվում են \"հավասարապես համընկնող մրցակիցներ\"։ \n Երկու ուսանող \"հավասարապես համընկնող\" են, եթե յուրաքանչյուր առարկայի (չինարեն, մաթեմատիկա, անգլերեն) միավորների տարբերությունը \n չի գերազանցում 5 միավորը, և ընդհանուր միավորների տարբերությունը չի գերազանցում 10 միավորը։\n Ֆունկցիան ընդունում է զանգվածների զանգված, որտեղ յուրաքանչյուր ենթազանգված ներկայացնում է ուսանողի միավորները երեք առարկաներում,\n և վերադարձնում է \"հավասարապես համընկնող\" ուսանողների զույգերի ընդհանուր քանակը։\n\n Օրինակ:\n >>> count_matching_pairs([[90, 90, 90], [85, 95, 90], [80, 100, 91]])\n 2",
      "bn": "ছাত্রদের জোড়ার সংখ্যা গণনা করে যারা \"সমানভাবে মেলানো প্রতিপক্ষ\" হিসেবে বিবেচিত হয়।\n দুটি ছাত্র \"সমানভাবে মেলানো\" হয় যদি প্রতিটি বিষয়ের (চীনা, গণিত, ইংরেজি) স্কোরের পার্থক্য ৫ পয়েন্টের বেশি না হয়, এবং মোট স্কোরের পার্থক্য ১০ পয়েন্টের বেশি না হয়।\n ফাংশনটি একটি অ্যারের অ্যারে নেয়, যেখানে প্রতিটি উপ-অ্যারে তিনটি বিষয়ের মধ্যে একটি ছাত্রের স্কোর উপস্থাপন করে,\n এবং \"সমানভাবে মেলানো\" ছাত্র জোড়ার মোট সংখ্যা ফেরত দেয়।\n\n উদাহরণ:\n >>> count_matching_pairs([[90, 90, 90], [85, 95, 90], [80, 100, 91]])\n 2",
      "bg": "Брои броя на двойките ученици, които се считат за \"равностойни противници\".\n Двама ученици са \"равностойни\", ако разликата в оценките за всеки предмет (Китайски, Математика, Английски)\n е не повече от 5 точки, а разликата в общия резултат е не повече от 10 точки.\n Функцията приема масив от масиви, където всеки подмасив представлява оценките на ученика по трите предмета,\n и връща общия брой на двойките ученици, които са \"равностойни\".\n\n Пример:\n >>> count_matching_pairs([[90, 90, 90], [85, 95, 90], [80, 100, 91]])\n 2",
      "zh": "计算被认为是“势均力敌的对手”的学生对数。 如果两名学生在每个科目（语文、数学、英语）的分数差不超过5分，并且总分差不超过10分，则认为他们是“势均力敌”的。 该函数接受一个数组的数组，其中每个子数组表示一名学生在三个科目中的分数，并返回“势均力敌”学生对的总数。\n\n示例：\n>>> count_matching_pairs([[90, 90, 90], [85, 95, 90], [80, 100, 91]])\n2",
      "fr": "Compte le nombre de paires d'élèves considérés comme des \"adversaires également assortis\".\n Deux élèves sont \"également assortis\" si la différence de scores pour chaque matière (Chinois, Mathématiques, Anglais)\n ne dépasse pas 5 points, et si la différence totale de scores ne dépasse pas 10 points.\n La fonction prend un tableau de tableaux, où chaque sous-tableau représente les scores d'un élève dans les trois matières,\n et renvoie le nombre total de paires d'élèves \"également assortis\".\n\n Exemple :\n >>> count_matching_pairs([[90, 90, 90], [85, 95, 90], [80, 100, 91]])\n 2",
      "de": "Zählt die Anzahl der Paare von Schülern, die als \"gleichwertige Gegner\" betrachtet werden. Zwei Schüler sind \"gleichwertig\", wenn der Unterschied in den Punkten für jedes Fach (Chinesisch, Mathematik, Englisch) nicht mehr als 5 Punkte beträgt und der Gesamtnotenunterschied nicht mehr als 10 Punkte beträgt. Die Funktion nimmt ein Array von Arrays, wobei jedes Unter-Array die Noten eines Schülers in den drei Fächern darstellt, und gibt die Gesamtanzahl der \"gleichwertigen\" Schülerpaare zurück.\n\nBeispiel:\n>>> count_matching_pairs([[90, 90, 90], [85, 95, 90], [80, 100, 91]])\n2",
      "ha": "Yana ƙidaya adadin ma'aurata na ɗalibai waɗanda ake ɗauka \"abokan hamayya daidai gwargwado\". \nAna ɗaukar ɗalibai biyu \"daidai gwargwado\" idan bambancin maki a kowace darasi (Sinanci, Lissafi, Turanci) \nba ya wuce maki 5, kuma bambancin jimillar maki ba ya wuce maki 10. \nAiki yana ɗaukar jerin jerin, inda kowace ƙaramin jeri ke wakiltar maki na ɗalibi a cikin darussa uku, \nkuma yana dawo da jimillar adadin ma'aurata na ɗalibai \"daidai gwargwado\".\n\nMisali:\n>>> count_matching_pairs([[90, 90, 90], [85, 95, 90], [80, 100, 91]])\n2",
      "hi": "उन छात्रों की जोड़ी की संख्या गिनता है जिन्हें \"समान रूप से मेल खाते प्रतिद्वंद्वी\" माना जाता है।\nदो छात्रों को \"समान रूप से मेल खाते प्रतिद्वंद्वी\" माना जाता है यदि प्रत्येक विषय (चीनी, गणित, अंग्रेजी) के लिए अंकों का अंतर 5 अंकों से अधिक नहीं है, और कुल अंकों का अंतर 10 अंकों से अधिक नहीं है। \nयह फ़ंक्शन एक सरणी का सरणी लेता है, जहाँ प्रत्येक उप-सरणी तीन विषयों में एक छात्र के अंकों का प्रतिनिधित्व करती है, और \"समान रूप से मेल खाते\" छात्र जोड़ों की कुल गिनती लौटाता है।\n\nउदाहरण:\n>>> count_matching_pairs([[90, 90, 90], [85, 95, 90], [80, 100, 91]])\n2",
      "hu": "Számolja meg azoknak a diákpároknak a számát, akiket \"egyenlően összemért ellenfeleknek\" tekintünk.\n Két diák akkor \"egyenlően összemért\", ha az egyes tantárgyak (kínai, matematika, angol) pontszámkülönbsége legfeljebb 5 pont, és az összpontszám különbsége legfeljebb 10 pont.\n A függvény egy tömbök tömbjét veszi, ahol minden al-tömb egy diák pontszámait képviseli a három tantárgyban, és visszaadja az \"egyenlően összemért\" diákpárok teljes számát.\n\n Példa:\n >>> count_matching_pairs([[90, 90, 90], [85, 95, 90], [80, 100, 91]])\n 2"
    },
    "docstring_bertscore": {
      "sq": "0.9587895589555486",
      "hy": "0.9654263958770674",
      "bn": "0.973702330702886",
      "bg": "0.9485457929448173",
      "zh": "0.9222975826125811",
      "fr": "0.9776858629945406",
      "de": "0.9419661615730367",
      "ha": "0.919637921810524",
      "hi": "0.9686020984090532",
      "hu": "0.9594863543322191"
    }
  },
  {
    "task_id": "Ruby/42",
    "prompt": {
      "en": "# Calculates the total number of cigarettes Peter can smoke given an initial\n# amount of cigarettes and a conversion rate of cigarette butts to new cigarettes.\n# Peter starts with n cigarettes and can turn every k butts into a new cigarette.\n#\n# The function takes two arguments, n and k, where n is the initial number of\n# cigarettes and k is the number of butts required for a new cigarette. It\n# returns the total number of cigarettes Peter can smoke.\n#\n# Examples:\n# >>> total_smoked_cigarettes(4, 3)\n# 5\n# >>> total_smoked_cigarettes(10, 3)\n# 14\ndef total_smoked_cigarettes(n, k)",
      "sq": "# Llogarit numrin total të cigareve që Peter mund të pijë duke pasur parasysh një sasi fillestare\n# të cigareve dhe një normë konvertimi të bishtave të cigares në cigare të reja.\n# Peter fillon me n cigare dhe mund të kthejë çdo k bishta në një cigare të re.\n#\n# Funksioni merr dy argumente, n dhe k, ku n është numri fillestar i\n# cigareve dhe k është numri i bishtave të nevojshëm për një cigare të re. Ai\n# kthen numrin total të cigareve që Peter mund të pijë.\n#\n# Shembuj:\n# >>> total_smoked_cigarettes(4, 3)\n# 5\n# >>> total_smoked_cigarettes(10, 3)\n# 14\ndef total_smoked_cigarettes(n, k)",
      "hy": "# Հաշվում է ընդհանուր ծխախոտների քանակը, որը կարող է ծխել Պետերը՝ հաշվի առնելով\n# սկզբնական ծխախոտների քանակը և ծխախոտի մնացորդների փոխարկման հարաբերակցությունը նոր ծխախոտների:\n# Պետերը սկսում է n ծխախոտով և կարող է յուրաքանչյուր k մնացորդը փոխարկել նոր ծխախոտի:\n#\n# Ֆունկցիան ընդունում է երկու արգումենտ՝ n և k, որտեղ n-ը սկզբնական ծխախոտների\n# քանակն է, իսկ k-ը՝ նոր ծխախոտի համար պահանջվող մնացորդների քանակը: Այն\n# վերադարձնում է ընդհանուր ծխախոտների քանակը, որը Պետերը կարող է ծխել:\n#\n# Օրինակներ:\n# >>> total_smoked_cigarettes(4, 3)\n# 5\n# >>> total_smoked_cigarettes(10, 3)\n# 14\ndef total_smoked_cigarettes(n, k)",
      "bn": "# পিটার মোট কতগুলি সিগারেট খেতে পারবে তা গণনা করে একটি প্রাথমিক\n# সিগারেটের সংখ্যা এবং সিগারেটের টুকরো থেকে নতুন সিগারেট তৈরির হার দেওয়া হলে।\n# পিটার n সিগারেট দিয়ে শুরু করে এবং প্রতিটি k টুকরোকে একটি নতুন সিগারেটে পরিণত করতে পারে।\n#\n# ফাংশনটি দুটি আর্গুমেন্ট গ্রহণ করে, n এবং k, যেখানে n হল প্রাথমিক সিগারেটের সংখ্যা\n# এবং k হল একটি নতুন সিগারেটের জন্য প্রয়োজনীয় টুকরোর সংখ্যা। এটি\n# পিটার মোট কতগুলি সিগারেট খেতে পারবে তা ফেরত দেয়।\n#\n# উদাহরণ:\n# >>> total_smoked_cigarettes(4, 3)\n# 5\n# >>> total_smoked_cigarettes(10, 3)\n# 14\ndef total_smoked_cigarettes(n, k)",
      "bg": "# Изчислява общия брой цигари, които Петър може да изпуши, като се има предвид начално\n# количество цигари и курс на конверсия на фасове в нови цигари.\n# Петър започва с n цигари и може да превърне всеки k фасове в нова цигара.\n#\n# Функцията приема два аргумента, n и k, където n е началният брой\n# цигари и k е броят на фасовете, необходими за нова цигара. Тя\n# връща общия брой цигари, които Петър може да изпуши.\n#\n# Примери:\n# >>> total_smoked_cigarettes(4, 3)\n# 5\n# >>> total_smoked_cigarettes(10, 3)\n# 14\ndef total_smoked_cigarettes(n, k)",
      "zh": "# 计算彼得可以抽的香烟总数，给定初始香烟数量和烟头转换为新香烟的比率。\n# 彼得从 n 支香烟开始，可以将每 k 个烟头转换为一支新香烟。\n#\n# 该函数接受两个参数，n 和 k，其中 n 是初始香烟数量，k 是需要多少个烟头才能换一支新香烟。\n# 它返回彼得可以抽的香烟总数。\n#\n# 例子:\n# >>> total_smoked_cigarettes(4, 3)\n# 5\n# >>> total_smoked_cigarettes(10, 3)\n# 14\ndef total_smoked_cigarettes(n, k)",
      "fr": "# Calcule le nombre total de cigarettes que Peter peut fumer étant donné un montant initial\n# de cigarettes et un taux de conversion de mégots de cigarette en nouvelles cigarettes.\n# Peter commence avec n cigarettes et peut transformer chaque k mégots en une nouvelle cigarette.\n#\n# La fonction prend deux arguments, n et k, où n est le nombre initial de\n# cigarettes et k est le nombre de mégots requis pour une nouvelle cigarette. Elle\n# renvoie le nombre total de cigarettes que Peter peut fumer.\n#\n# Exemples:\n# >>> total_smoked_cigarettes(4, 3)\n# 5\n# >>> total_smoked_cigarettes(10, 3)\n# 14\ndef total_smoked_cigarettes(n, k)",
      "de": "# Berechnet die Gesamtanzahl der Zigaretten, die Peter rauchen kann, gegeben eine anfängliche\n# Anzahl von Zigaretten und eine Umwandlungsrate von Zigarettenstummeln zu neuen Zigaretten.\n# Peter beginnt mit n Zigaretten und kann jeden k Stummel in eine neue Zigarette umwandeln.\n#\n# Die Funktion nimmt zwei Argumente, n und k, wobei n die anfängliche Anzahl von\n# Zigaretten ist und k die Anzahl der Stummel, die für eine neue Zigarette benötigt werden.\n# Sie gibt die Gesamtanzahl der Zigaretten zurück, die Peter rauchen kann.\n#\n# Beispiele:\n# >>> total_smoked_cigarettes(4, 3)\n# 5\n# >>> total_smoked_cigarettes(10, 3)\n# 14\ndef total_smoked_cigarettes(n, k)",
      "ha": "# Lissafi jimillar adadin sigari da Peter zai iya sha idan aka ba shi adadin\n# sigari na farko da kuma adadin bututun sigari da ake bukata don sabbin sigari.\n# Peter yana farawa da n sigari kuma zai iya juya kowane k bututun sigari zuwa sabon sigari.\n#\n# Aikin yana daukar hujjoji guda biyu, n da k, inda n shine adadin sigari na farko\n# kuma k shine adadin bututun da ake bukata don sabon sigari. Yana\n# dawowa da jimillar adadin sigari da Peter zai iya sha.\n#\n# Misalai:\n# >>> total_smoked_cigarettes(4, 3)\n# 5\n# >>> total_smoked_cigarettes(10, 3)\n# 14\ndef total_smoked_cigarettes(n, k)",
      "hi": "# यह गणना करता है कि पीटर कुल कितनी सिगरेट पी सकता है, जब उसे प्रारंभिक\n# सिगरेट की संख्या और सिगरेट के बट्स को नई सिगरेट में बदलने की दर दी जाती है।\n# पीटर n सिगरेट के साथ शुरू करता है और हर k बट्स को एक नई सिगरेट में बदल सकता है।\n#\n# यह फ़ंक्शन दो तर्क लेता है, n और k, जहाँ n प्रारंभिक सिगरेट की संख्या है\n# और k वह संख्या है जो एक नई सिगरेट के लिए आवश्यक बट्स की है। यह\n# लौटाता है कि पीटर कुल कितनी सिगरेट पी सकता है।\n#\n# उदाहरण:\n# >>> total_smoked_cigarettes(4, 3)\n# 5\n# >>> total_smoked_cigarettes(10, 3)\n# 14\ndef total_smoked_cigarettes(n, k)",
      "hu": "# Kiszámítja, hogy Péter összesen hány cigarettát tud elszívni egy kezdeti\n# cigarettamennyiség és egy konverziós arány alapján, amely a cigarettacsikkeket új cigarettává alakítja.\n# Péter n cigarettával kezd, és minden k csikket új cigarettává tud alakítani.\n#\n# A függvény két argumentumot vesz fel, n és k, ahol n a kezdeti cigaretták száma,\n# és k az új cigarettához szükséges csikkek száma. Visszaadja az összes cigaretta számát, amit Péter el tud szívni.\n#\n# Példák:\n# >>> total_smoked_cigarettes(4, 3)\n# 5\n# >>> total_smoked_cigarettes(10, 3)\n# 14\ndef total_smoked_cigarettes(n, k)"
    },
    "prompt_bertscore": {
      "sq": "0.9881938074120483",
      "hy": "0.9652780189824343",
      "bn": "0.955228116223593",
      "bg": "0.9835740620099389",
      "zh": "0.9555610207422076",
      "fr": "0.9884768557050231",
      "de": "0.9905306938449238",
      "ha": "0.9679942894430864",
      "hi": "0.9573858380527751",
      "hu": "0.9772568213715053"
    },
    "canonical_solution": "    total_smoked = n\n    butts = n\n    \n    while butts >= k\n      new_cigarettes = butts / k\n      total_smoked += new_cigarettes\n      butts = butts % k + new_cigarettes\n    end\n  \n    total_smoked\n  end",
    "instruction": {
      "en": "Write a ruby function `def total_smoked_cigarettes(n, k)` to solve the following problem:\nCalculates the total number of cigarettes Peter can smoke given an initial\n amount of cigarettes and a conversion rate of cigarette butts to new cigarettes.\n Peter starts with n cigarettes and can turn every k butts into a new cigarette.\n\n The function takes two arguments, n and k, where n is the initial number of\n cigarettes and k is the number of butts required for a new cigarette. It\n returns the total number of cigarettes Peter can smoke.\n\n Examples:\n >>> total_smoked_cigarettes(4, 3)\n 5\n >>> total_smoked_cigarettes(10, 3)\n 14",
      "sq": "Shkruani një funksion ruby `def total_smoked_cigarettes(n, k)` për të zgjidhur problemin e mëposhtëm:\nLlogarit numrin total të cigareve që Pjetri mund të pijë duke pasur parasysh një sasi fillestare të cigareve dhe një normë konvertimi të bishtave të cigareve në cigare të reja. \nPjetri fillon me n cigare dhe mund të kthejë çdo k bishta në një cigare të re.\n\nFunksioni merr dy argumente, n dhe k, ku n është numri fillestar i cigareve dhe k është numri i bishtave të nevojshëm për një cigare të re. Ai kthen numrin total të cigareve që Pjetri mund të pijë.\n\nShembuj:\n>>> total_smoked_cigarettes(4, 3)\n5\n>>> total_smoked_cigarettes(10, 3)\n14",
      "hy": "Ruby ֆունկցիա գրեք `def total_smoked_cigarettes(n, k)`՝ հետևյալ խնդիրը լուծելու համար:\nՀաշվում է ընդհանուր ծխած սիգարետների քանակը, որը Պետրոսը կարող է ծխել, հաշվի առնելով սիգարետների սկզբնական քանակը և սիգարետի մնացորդները նոր սիգարետի վերածելու փոխարկման գործակիցը:\nՊետրոսը սկսում է n սիգարետներով և կարող է յուրաքանչյուր k մնացորդը վերածել նոր սիգարետի:\n\nՖունկցիան ընդունում է երկու արգումենտ՝ n և k, որտեղ n-ը սիգարետների սկզբնական քանակն է, իսկ k-ը՝ նոր սիգարետի համար պահանջվող մնացորդների քանակը: Այն վերադարձնում է ընդհանուր ծխած սիգարետների քանակը, որը Պետրոսը կարող է ծխել:\n\nՕրինակներ:\n>>> total_smoked_cigarettes(4, 3)\n5\n>>> total_smoked_cigarettes(10, 3)\n14",
      "bn": "রুবি ফাংশন `def total_smoked_cigarettes(n, k)` লিখুন নিম্নলিখিত সমস্যার সমাধানের জন্য:\nপিটার কতগুলি সিগারেট খেতে পারে তা গণনা করে একটি প্রাথমিক\nসিগারেটের পরিমাণ এবং সিগারেটের বাট থেকে নতুন সিগারেটের রূপান্তর হার দেওয়া আছে।\nপিটার n সিগারেট দিয়ে শুরু করে এবং প্রতিটি k বাটকে একটি নতুন সিগারেটে পরিণত করতে পারে।\n\nফাংশনটি দুটি আর্গুমেন্ট গ্রহণ করে, n এবং k, যেখানে n হল প্রাথমিক সিগারেটের সংখ্যা\nএবং k হল একটি নতুন সিগারেটের জন্য প্রয়োজনীয় বাটের সংখ্যা। এটি\nপিটার কতগুলি সিগারেট খেতে পারে তার মোট সংখ্যা ফেরত দেয়।\n\nউদাহরণ:\n>>> total_smoked_cigarettes(4, 3)\n5\n>>> total_smoked_cigarettes(10, 3)\n14",
      "bg": "Напишете функция на Ruby `def total_smoked_cigarettes(n, k)` за решаване на следния проблем:\nИзчислява общия брой цигари, които Петър може да изпуши, като се има предвид началното количество цигари и курсът на конверсия на фасове в нови цигари. Петър започва с n цигари и може да превърне всеки k фасове в нова цигара.\n\nФункцията приема два аргумента, n и k, където n е началният брой цигари, а k е броят фасове, необходими за нова цигара. Тя връща общия брой цигари, които Петър може да изпуши.\n\nПримери:\n>>> total_smoked_cigarettes(4, 3)\n5\n>>> total_smoked_cigarettes(10, 3)\n14",
      "zh": "编写一个 ruby 函数 `def total_smoked_cigarettes(n, k)` 来解决以下问题：\n计算彼得在给定初始香烟数量和烟蒂转换为新香烟的转换率的情况下可以抽的香烟总数。彼得从 n 支香烟开始，每 k 个烟蒂可以换成一支新香烟。\n\n该函数接受两个参数，n 和 k，其中 n 是初始香烟数量，k 是换取一支新香烟所需的烟蒂数量。它返回彼得可以抽的香烟总数。\n\n例子：\n>>> total_smoked_cigarettes(4, 3)\n5\n>>> total_smoked_cigarettes(10, 3)\n14",
      "fr": "Écrire une fonction ruby `def total_smoked_cigarettes(n, k)` pour résoudre le problème suivant :\nCalcule le nombre total de cigarettes que Peter peut fumer étant donné un montant initial de cigarettes et un taux de conversion de mégots en nouvelles cigarettes. Peter commence avec n cigarettes et peut transformer chaque k mégots en une nouvelle cigarette.\n\nLa fonction prend deux arguments, n et k, où n est le nombre initial de cigarettes et k est le nombre de mégots requis pour une nouvelle cigarette. Elle retourne le nombre total de cigarettes que Peter peut fumer.\n\nExemples :\n>>> total_smoked_cigarettes(4, 3)\n5\n>>> total_smoked_cigarettes(10, 3)\n14",
      "de": "Schreiben Sie eine Ruby-Funktion `def total_smoked_cigarettes(n, k)`, um das folgende Problem zu lösen:\nBerechnet die Gesamtanzahl der Zigaretten, die Peter rauchen kann, gegeben eine anfängliche Menge an Zigaretten und eine Umwandlungsrate von Zigarettenstummeln zu neuen Zigaretten. Peter beginnt mit n Zigaretten und kann jeden k Stummel in eine neue Zigarette umwandeln.\n\nDie Funktion nimmt zwei Argumente, n und k, wobei n die anfängliche Anzahl der Zigaretten ist und k die Anzahl der benötigten Stummel für eine neue Zigarette. Sie gibt die Gesamtanzahl der Zigaretten zurück, die Peter rauchen kann.\n\nBeispiele:\n>>> total_smoked_cigarettes(4, 3)\n5\n>>> total_smoked_cigarettes(10, 3)\n14",
      "ha": "Rubuta aikin ruby `def total_smoked_cigarettes(n, k)` don warware matsalar mai zuwa:\nLissafa jimillar adadin sigari da Peter zai iya sha la'akari da adadin farko\nna sigari da kuma yadda ake canza bututun sigari zuwa sabbin sigari.\nPeter yana farawa da n sigari kuma zai iya juya kowane k bututun zuwa sabuwar sigari.\n\nAikin yana karɓar hujjoji guda biyu, n da k, inda n shine adadin farko na\nsigari kuma k shine adadin bututun da ake buƙata don sabuwar sigari. Yana\nmayar da jimillar adadin sigari da Peter zai iya sha.\n\nMisalai:\n>>> total_smoked_cigarettes(4, 3)\n5\n>>> total_smoked_cigarettes(10, 3)\n14",
      "hi": "रूबी फ़ंक्शन `def total_smoked_cigarettes(n, k)` लिखें ताकि निम्नलिखित समस्या का समाधान किया जा सके:\nपीटर द्वारा धूम्रपान की जा सकने वाली कुल सिगरेटों की संख्या की गणना करता है, दिए गए प्रारंभिक\nसिगरेटों की संख्या और सिगरेट के बट्स को नई सिगरेट में बदलने की दर के आधार पर।\nपीटर n सिगरेटों के साथ शुरू करता है और हर k बट्स को एक नई सिगरेट में बदल सकता है।\n\nयह फ़ंक्शन दो तर्क लेता है, n और k, जहाँ n प्रारंभिक सिगरेटों की संख्या है और k वह संख्या है जो एक नई सिगरेट के लिए आवश्यक बट्स की है। यह\nपीटर द्वारा धूम्रपान की जा सकने वाली कुल सिगरेटों की संख्या लौटाता है।\n\nउदाहरण:\n>>> total_smoked_cigarettes(4, 3)\n5\n>>> total_smoked_cigarettes(10, 3)\n14",
      "hu": "Írj egy ruby függvényt `def total_smoked_cigarettes(n, k)` a következő probléma megoldására:\nKiszámítja a teljes cigarettaszámot, amit Péter elszívhat egy kezdeti cigarettamennyiség és egy konverziós arány alapján, amely a cigarettacsikkeket új cigarettákra váltja. Péter n cigarettával kezd, és minden k csikket új cigarettára tud váltani.\n\nA függvény két argumentumot vesz fel, n és k, ahol n a kezdeti cigarettaszám, és k az új cigarettához szükséges csikkek száma. Visszaadja a teljes cigarettaszámot, amit Péter el tud szívni.\n\nPéldák:\n>>> total_smoked_cigarettes(4, 3)\n5\n>>> total_smoked_cigarettes(10, 3)\n14"
    },
    "instruction_bertscore": {
      "sq": "0.9898650834380759",
      "hy": "0.9582041952226388",
      "bn": "0.9894785487165819",
      "bg": "0.9756540728269348",
      "zh": "0.9667752947946753",
      "fr": "0.9887777807322908",
      "de": "0.9928618199967493",
      "ha": "0.9804668869594101",
      "hi": "0.9614949047452438",
      "hu": "0.9639906954829471"
    },
    "level": "easy",
    "test": "raise 'Test failed' unless total_smoked_cigarettes(4, 3) == 5\nraise 'Test failed' unless total_smoked_cigarettes(10, 3) == 14\nraise 'Test failed' unless total_smoked_cigarettes(20, 4) == 26\nraise 'Test failed' unless total_smoked_cigarettes(1, 2) == 1\nraise 'Test failed' unless total_smoked_cigarettes(100, 5) == 124\n  ",
    "entry_point": "total_smoked_cigarettes",
    "signature": "def total_smoked_cigarettes(n, k)",
    "docstring": {
      "en": "Calculates the total number of cigarettes Peter can smoke given an initial\n amount of cigarettes and a conversion rate of cigarette butts to new cigarettes.\n Peter starts with n cigarettes and can turn every k butts into a new cigarette.\n\n The function takes two arguments, n and k, where n is the initial number of\n cigarettes and k is the number of butts required for a new cigarette. It\n returns the total number of cigarettes Peter can smoke.\n\n Examples:\n >>> total_smoked_cigarettes(4, 3)\n 5\n >>> total_smoked_cigarettes(10, 3)\n 14",
      "sq": "Llogarit numrin total të cigareve që Peter mund të pijë duke pasur parasysh një sasi fillestare të cigareve dhe një normë konvertimi të bishtave të cigareve në cigare të reja. Peter fillon me n cigare dhe mund të kthejë çdo k bishta në një cigare të re.\n\nFunksioni merr dy argumente, n dhe k, ku n është numri fillestar i cigareve dhe k është numri i bishtave të kërkuara për një cigare të re. Ai kthen numrin total të cigareve që Peter mund të pijë.\n\nShembuj:\n>>> total_smoked_cigarettes(4, 3)\n5\n>>> total_smoked_cigarettes(10, 3)\n14",
      "hy": "Հաշվում է ընդհանուր ծխախոտների քանակը, որը Պետերը կարող է ծխել տրված սկզբնական\n ծխախոտների քանակը և ծխախոտի մնացորդների փոխակերպման գործակիցը նոր ծխախոտների։ \n Պետերը սկսում է n ծխախոտներով և կարող է յուրաքանչյուր k մնացորդը վերածել նոր ծխախոտի։\n\n Ֆունկցիան ընդունում է երկու արգումենտ՝ n և k, որտեղ n-ն սկզբնական ծխախոտների\n քանակն է, իսկ k-ն այն մնացորդների քանակն է, որոնք անհրաժեշտ են նոր ծխախոտի համար։ Այն\n վերադարձնում է ընդհանուր ծխախոտների քանակը, որը Պետերը կարող է ծխել։\n\n Օրինակներ:\n >>> total_smoked_cigarettes(4, 3)\n 5\n >>> total_smoked_cigarettes(10, 3)\n 14",
      "bn": "প্রাথমিক সিগারেটের পরিমাণ এবং সিগারেটের বাট থেকে নতুন সিগারেট তৈরির রূপান্তর হার দেওয়া হলে পিটার মোট কতগুলি সিগারেট খেতে পারবে তা গণনা করে। পিটার n সিগারেট দিয়ে শুরু করে এবং প্রতি k বাটকে একটি নতুন সিগারেটে পরিণত করতে পারে।\n\nফাংশনটি দুটি আর্গুমেন্ট গ্রহণ করে, n এবং k, যেখানে n হল প্রাথমিক সিগারেটের সংখ্যা এবং k হল একটি নতুন সিগারেটের জন্য প্রয়োজনীয় বাটের সংখ্যা। এটি পিটার মোট কতগুলি সিগারেট খেতে পারবে তা ফেরত দেয়।\n\nউদাহরণ:\n>>> total_smoked_cigarettes(4, 3)\n5\n>>> total_smoked_cigarettes(10, 3)\n14",
      "bg": "Изчислява общия брой цигари, които Петър може да изпуши, при дадено начално количество цигари и курс на конверсия на фасове в нови цигари. Петър започва с n цигари и може да превърне всеки k фасове в нова цигара.\n\nФункцията приема два аргумента, n и k, където n е началният брой цигари, а k е броят на фасовете, необходими за нова цигара. Тя връща общия брой цигари, които Петър може да изпуши.\n\nПримери:\n>>> total_smoked_cigarettes(4, 3)\n5\n>>> total_smoked_cigarettes(10, 3)\n14",
      "zh": "计算彼得在给定初始香烟数量和烟蒂转换为新香烟的转换率下可以抽的香烟总数。\n彼得从 n 支香烟开始，可以将每 k 个烟蒂转换为一支新香烟。\n\n该函数接受两个参数，n 和 k，其中 n 是初始香烟数量，k 是需要转换为一支新香烟的烟蒂数量。\n它返回彼得可以抽的香烟总数。\n\n示例：\n>>> total_smoked_cigarettes(4, 3)\n5\n>>> total_smoked_cigarettes(10, 3)\n14",
      "fr": "Calcule le nombre total de cigarettes que Peter peut fumer étant donné un nombre initial de cigarettes et un taux de conversion de mégots de cigarette en nouvelles cigarettes. Peter commence avec n cigarettes et peut transformer chaque k mégots en une nouvelle cigarette.\n\nLa fonction prend deux arguments, n et k, où n est le nombre initial de cigarettes et k est le nombre de mégots requis pour une nouvelle cigarette. Elle renvoie le nombre total de cigarettes que Peter peut fumer.\n\nExemples :\n>>> total_smoked_cigarettes(4, 3)\n5\n>>> total_smoked_cigarettes(10, 3)\n14",
      "de": "Berechnet die Gesamtanzahl der Zigaretten, die Peter rauchen kann, gegeben eine anfängliche Menge an Zigaretten und eine Umwandlungsrate von Zigarettenstummeln zu neuen Zigaretten. Peter beginnt mit n Zigaretten und kann jeden k Stummel in eine neue Zigarette umwandeln.\n\nDie Funktion nimmt zwei Argumente, n und k, wobei n die anfängliche Anzahl der Zigaretten ist und k die Anzahl der benötigten Stummel für eine neue Zigarette ist. Sie gibt die Gesamtanzahl der Zigaretten zurück, die Peter rauchen kann.\n\nBeispiele:\n>>> total_smoked_cigarettes(4, 3)\n5\n>>> total_smoked_cigarettes(10, 3)\n14",
      "ha": "Lissafi yawan sigari da Peter zai iya sha idan aka ba shi adadin farko\n    na sigari da kuma adadin canjin bututun sigari zuwa sabbin sigari.\n    Peter yana farawa da sigari n kuma zai iya juya kowane k bututun zuwa sabon sigari.\n\n    Aikin yana karɓar hujjoji guda biyu, n da k, inda n shine adadin farko na\n    sigari kuma k shine adadin bututun da ake buƙata don sabon sigari. Yana\n    dawowa da jimillar yawan sigari da Peter zai iya sha.\n\n    Misalai:\n    >>> total_smoked_cigarettes(4, 3)\n    5\n    >>> total_smoked_cigarettes(10, 3)\n    14",
      "hi": "कुल सिगरेट की संख्या की गणना करता है जो पीटर धूम्रपान कर सकता है, दिए गए प्रारंभिक सिगरेट की मात्रा और सिगरेट के टुकड़ों से नई सिगरेट में बदलने की दर के आधार पर। पीटर n सिगरेट के साथ शुरू करता है और हर k टुकड़ों को एक नई सिगरेट में बदल सकता है।\n\nयह फ़ंक्शन दो तर्क लेता है, n और k, जहाँ n प्रारंभिक सिगरेट की संख्या है और k एक नई सिगरेट के लिए आवश्यक टुकड़ों की संख्या है। यह पीटर द्वारा धूम्रपान की जा सकने वाली कुल सिगरेट की संख्या लौटाता है।\n\nउदाहरण:\n>>> total_smoked_cigarettes(4, 3)\n5\n>>> total_smoked_cigarettes(10, 3)\n14",
      "hu": "Kiszámítja, hogy összesen hány cigarettát tud elszívni Péter, adott egy kezdeti cigarettaszám és egy átváltási arány a cigarettacsikkek új cigarettákra. Péter n cigarettával kezd, és minden k csikket új cigarettára tud váltani.\n\nA függvény két argumentumot vesz fel, n és k, ahol n a kezdeti cigaretták száma, és k az új cigarettához szükséges csikkek száma. Visszaadja az összes cigaretták számát, amit Péter el tud szívni.\n\nPéldák:\n>>> total_smoked_cigarettes(4, 3)\n5\n>>> total_smoked_cigarettes(10, 3)\n14"
    },
    "docstring_bertscore": {
      "sq": "0.9834475344572197",
      "hy": "0.9850727282348472",
      "bn": "0.9803588320321271",
      "bg": "0.9815982856097849",
      "zh": "0.9780141990143913",
      "fr": "0.9933677315772451",
      "de": "0.993321252068083",
      "ha": "0.9541702108142013",
      "hi": "0.9686906875589947",
      "hu": "0.9837039662791357"
    }
  },
  {
    "task_id": "Ruby/43",
    "prompt": {
      "en": "# Finds the length of the longest consecutive sequence in an array of integers.\n# The function takes an array of integers as an argument and returns the length\n# of the longest consecutive sequence of numbers present in the array.\n#\n# Example:\n# >>> longest_consecutive_sequence([1, 5, 6, 2, 3, 4, 5, 6, 8, 9])\n# 6  # Because the longest consecutive sequence is 1, 2, 3, 4, 5, 6\n# >>> longest_consecutive_sequence([10, 4, 20, 1, 3, 2])\n# 4  # Because the longest consecutive sequence is 1, 2, 3, 4\ndef longest_consecutive_sequence(arr)",
      "sq": "# Gjen gjatësinë e sekuencës më të gjatë të njëpasnjëshme në një varg të numrave të plotë.\n# Funksioni merr një varg të numrave të plotë si argument dhe kthen gjatësinë\n# e sekuencës më të gjatë të njëpasnjëshme të numrave të pranishëm në varg.\n#\n# Shembull:\n# >>> longest_consecutive_sequence([1, 5, 6, 2, 3, 4, 5, 6, 8, 9])\n# 6  # Sepse sekuenca më e gjatë e njëpasnjëshme është 1, 2, 3, 4, 5, 6\n# >>> longest_consecutive_sequence([10, 4, 20, 1, 3, 2])\n# 4  # Sepse sekuenca më e gjatë e njëpasnjëshme është 1, 2, 3, 4\ndef longest_consecutive_sequence(arr)",
      "hy": "# Գտնում է ամբողջ թվերի զանգվածում ամենաերկար հաջորդական հաջորդականության երկարությունը:\n# Ֆունկցիան ընդունում է ամբողջ թվերի զանգված որպես արգումենտ և վերադարձնում է\n# զանգվածում առկա ամենաերկար հաջորդական հաջորդականության երկարությունը:\n#\n# Օրինակ:\n# >>> longest_consecutive_sequence([1, 5, 6, 2, 3, 4, 5, 6, 8, 9])\n# 6  # Քանի որ ամենաերկար հաջորդական հաջորդականությունը 1, 2, 3, 4, 5, 6 է\n# >>> longest_consecutive_sequence([10, 4, 20, 1, 3, 2])\n# 4  # Քանի որ ամենաերկար հաջորդական հաջորդականությունը 1, 2, 3, 4 է\ndef longest_consecutive_sequence(arr)",
      "bn": "# একটি পূর্ণসংখ্যার অ্যারের মধ্যে দীর্ঘতম ধারাবাহিক অনুক্রমের দৈর্ঘ্য খুঁজে বের করে।\n# ফাংশনটি একটি পূর্ণসংখ্যার অ্যারে আর্গুমেন্ট হিসেবে গ্রহণ করে এবং অ্যারের মধ্যে উপস্থিত \n# সংখ্যার দীর্ঘতম ধারাবাহিক অনুক্রমের দৈর্ঘ্য ফেরত দেয়।\n#\n# উদাহরণ:\n# >>> longest_consecutive_sequence([1, 5, 6, 2, 3, 4, 5, 6, 8, 9])\n# 6  # কারণ দীর্ঘতম ধারাবাহিক অনুক্রমটি হল 1, 2, 3, 4, 5, 6\n# >>> longest_consecutive_sequence([10, 4, 20, 1, 3, 2])\n# 4  # কারণ দীর্ঘতম ধারাবাহিক অনুক্রমটি হল 1, 2, 3, 4\ndef longest_consecutive_sequence(arr)",
      "bg": "# Намира дължината на най-дългата последователна поредица в масив от цели числа.\n# Функцията приема масив от цели числа като аргумент и връща дължината\n# на най-дългата последователна поредица от числа, присъстващи в масива.\n#\n# Пример:\n# >>> longest_consecutive_sequence([1, 5, 6, 2, 3, 4, 5, 6, 8, 9])\n# 6  # Защото най-дългата последователна поредица е 1, 2, 3, 4, 5, 6\n# >>> longest_consecutive_sequence([10, 4, 20, 1, 3, 2])\n# 4  # Защото най-дългата последователна поредица е 1, 2, 3, 4\ndef longest_consecutive_sequence(arr)",
      "zh": "# 查找整数数组中最长连续序列的长度。\n# 该函数接受一个整数数组作为参数，并返回数组中存在的最长连续数字序列的长度。\n#\n# 示例:\n# >>> longest_consecutive_sequence([1, 5, 6, 2, 3, 4, 5, 6, 8, 9])\n# 6  # 因为最长的连续序列是 1, 2, 3, 4, 5, 6\n# >>> longest_consecutive_sequence([10, 4, 20, 1, 3, 2])\n# 4  # 因为最长的连续序列是 1, 2, 3, 4\ndef longest_consecutive_sequence(arr)",
      "fr": "# Trouve la longueur de la plus longue séquence consécutive dans un tableau d'entiers.\n# La fonction prend un tableau d'entiers comme argument et renvoie la longueur\n# de la plus longue séquence consécutive de nombres présente dans le tableau.\n#\n# Exemple:\n# >>> longest_consecutive_sequence([1, 5, 6, 2, 3, 4, 5, 6, 8, 9])\n# 6  # Parce que la plus longue séquence consécutive est 1, 2, 3, 4, 5, 6\n# >>> longest_consecutive_sequence([10, 4, 20, 1, 3, 2])\n# 4  # Parce que la plus longue séquence consécutive est 1, 2, 3, 4\ndef longest_consecutive_sequence(arr)",
      "de": "# Findet die Länge der längsten aufeinanderfolgenden Sequenz in einem Array von ganzen Zahlen.\n# Die Funktion nimmt ein Array von ganzen Zahlen als Argument und gibt die Länge\n# der längsten aufeinanderfolgenden Zahlenfolge im Array zurück.\n#\n# Beispiel:\n# >>> longest_consecutive_sequence([1, 5, 6, 2, 3, 4, 5, 6, 8, 9])\n# 6  # Weil die längste aufeinanderfolgende Sequenz 1, 2, 3, 4, 5, 6 ist\n# >>> longest_consecutive_sequence([10, 4, 20, 1, 3, 2])\n# 4  # Weil die längste aufeinanderfolgende Sequenz 1, 2, 3, 4 ist\ndef longest_consecutive_sequence(arr)",
      "ha": "# Nemi tsawon jerin lambobi masu jere mafi tsawo a cikin jerin lambobi.\n# Aikin yana ɗaukar jerin lambobi a matsayin hujja kuma yana dawo da tsawon\n# jerin lambobi masu jere mafi tsawo da ke cikin jerin.\n#\n# Misali:\n# >>> longest_consecutive_sequence([1, 5, 6, 2, 3, 4, 5, 6, 8, 9])\n# 6  # Domin jerin lambobi masu jere mafi tsawo su ne 1, 2, 3, 4, 5, 6\n# >>> longest_consecutive_sequence([10, 4, 20, 1, 3, 2])\n# 4  # Domin jerin lambobi masu jere mafi tsawo su ne 1, 2, 3, 4\ndef longest_consecutive_sequence(arr)",
      "hi": "# एक पूर्णांकों की array में सबसे लंबे लगातार अनुक्रम की लंबाई खोजता है।\n# यह फ़ंक्शन एक पूर्णांकों की array को तर्क के रूप में लेता है और array में मौजूद\n# सबसे लंबे लगातार अनुक्रम की लंबाई लौटाता है।\n#\n# उदाहरण:\n# >>> longest_consecutive_sequence([1, 5, 6, 2, 3, 4, 5, 6, 8, 9])\n# 6  # क्योंकि सबसे लंबा लगातार अनुक्रम 1, 2, 3, 4, 5, 6 है\n# >>> longest_consecutive_sequence([10, 4, 20, 1, 3, 2])\n# 4  # क्योंकि सबसे लंबा लगातार अनुक्रम 1, 2, 3, 4 है\ndef longest_consecutive_sequence(arr)",
      "hu": "# Megkeresi a leghosszabb egymást követő sorozat hosszát egy egész számokat tartalmazó tömbben.\n# A függvény egy egész számokat tartalmazó tömböt vesz át argumentumként, és visszaadja a tömbben\n# található leghosszabb egymást követő számok sorozatának hosszát.\n#\n# Példa:\n# >>> longest_consecutive_sequence([1, 5, 6, 2, 3, 4, 5, 6, 8, 9])\n# 6  # Mert a leghosszabb egymást követő sorozat 1, 2, 3, 4, 5, 6\n# >>> longest_consecutive_sequence([10, 4, 20, 1, 3, 2])\n# 4  # Mert a leghosszabb egymást követő sorozat 1, 2, 3, 4\ndef longest_consecutive_sequence(arr)"
    },
    "prompt_bertscore": {
      "sq": "0.995621789141229",
      "hy": "0.98680836050433",
      "bn": "1",
      "bg": "1",
      "zh": "0.9617340557240098",
      "fr": "0.995621789141229",
      "de": "0.9791684401585851",
      "ha": "0.9577249001132017",
      "hi": "0.9838847199258774",
      "hu": "0.9938261704966737"
    },
    "canonical_solution": "    # Return 0 if the array is empty\n    return 0 if arr.empty?\n  \n    # Sort the array\n    sorted_arr = arr.sort.uniq  # Also remove duplicates to handle repeated numbers\n  \n    max_length = 1\n    current_length = 1\n  \n    (1...sorted_arr.length).each do |i|\n      # Check if the current number is consecutive to the previous\n      if sorted_arr[i] == sorted_arr[i - 1] + 1\n        current_length += 1\n        max_length = [max_length, current_length].max\n      else\n        current_length = 1\n      end\n    end\n  \n    max_length\n  end",
    "instruction": {
      "en": "Write a ruby function `def longest_consecutive_sequence(arr)` to solve the following problem:\nFinds the length of the longest consecutive sequence in an array of integers.\n The function takes an array of integers as an argument and returns the length\n of the longest consecutive sequence of numbers present in the array.\n\n Example:\n >>> longest_consecutive_sequence([1, 5, 6, 2, 3, 4, 5, 6, 8, 9])\n 6   Because the longest consecutive sequence is 1, 2, 3, 4, 5, 6\n >>> longest_consecutive_sequence([10, 4, 20, 1, 3, 2])\n 4   Because the longest consecutive sequence is 1, 2, 3, 4",
      "sq": "Shkruani një funksion ruby `def longest_consecutive_sequence(arr)` për të zgjidhur problemin në vijim:\nGjen gjatësinë e sekuencës më të gjatë radhazi në një varg me numra të plotë.\n Funksioni merr një varg me numra të plotë si argument dhe kthen gjatësinë\n e sekuencës më të gjatë radhazi të numrave të pranishëm në varg.\n\n Shembull:\n >>> longest_consecutive_sequence([1, 5, 6, 2, 3, 4, 5, 6, 8, 9])\n 6   Sepse sekuenca më e gjatë radhazi është 1, 2, 3, 4, 5, 6\n >>> longest_consecutive_sequence([10, 4, 20, 1, 3, 2])\n 4   Sepse sekuenca më e gjatë radhazi është 1, 2, 3, 4",
      "hy": "Գրեք ruby ֆունկցիա `def longest_consecutive_sequence(arr)` հետևյալ խնդիրը լուծելու համար:\nԳտնում է ամենաերկար հաջորդական հաջորդականության երկարությունը ամբողջ թվերի զանգվածում:\n Ֆունկցիան ընդունում է ամբողջ թվերի զանգված որպես արգումենտ և վերադարձնում է\n ամենաերկար հաջորդական հաջորդականության երկարությունը, որը առկա է զանգվածում:\n\n Օրինակ:\n >>> longest_consecutive_sequence([1, 5, 6, 2, 3, 4, 5, 6, 8, 9])\n 6   Քանի որ ամենաերկար հաջորդական հաջորդականությունը 1, 2, 3, 4, 5, 6 է\n >>> longest_consecutive_sequence([10, 4, 20, 1, 3, 2])\n 4   Քանի որ ամենաերկար հաջորդական հաջորդականությունը 1, 2, 3, 4 է",
      "bn": "একটি রুবি ফাংশন `def longest_consecutive_sequence(arr)` লিখুন নিম্নলিখিত সমস্যার সমাধানের জন্য:\nএকটি পূর্ণসংখ্যার অ্যারের মধ্যে দীর্ঘতম ধারাবাহিক ক্রমের দৈর্ঘ্য খুঁজে বের করে।\n ফাংশনটি একটি পূর্ণসংখ্যার অ্যারে আর্গুমেন্ট হিসাবে গ্রহণ করে এবং অ্যারের মধ্যে উপস্থিত সংখ্যার দীর্ঘতম ধারাবাহিক ক্রমের দৈর্ঘ্য ফেরত দেয়।\n\n উদাহরণ:\n >>> longest_consecutive_sequence([1, 5, 6, 2, 3, 4, 5, 6, 8, 9])\n 6   কারণ দীর্ঘতম ধারাবাহিক ক্রমটি হল 1, 2, 3, 4, 5, 6\n >>> longest_consecutive_sequence([10, 4, 20, 1, 3, 2])\n 4   কারণ দীর্ঘতম ধারাবাহিক ক্রমটি হল 1, 2, 3, 4",
      "bg": "Напишете функция на Ruby `def longest_consecutive_sequence(arr)` за решаване на следния проблем:\nНамира дължината на най-дългата последователна поредица в масив от цели числа.\nФункцията приема масив от цели числа като аргумент и връща дължината\nна най-дългата последователна поредица от числа, налични в масива.\n\nПример:\n>>> longest_consecutive_sequence([1, 5, 6, 2, 3, 4, 5, 6, 8, 9])\n6   Защото най-дългата последователна поредица е 1, 2, 3, 4, 5, 6\n>>> longest_consecutive_sequence([10, 4, 20, 1, 3, 2])\n4   Защото най-дългата последователна поредица е 1, 2, 3, 4",
      "zh": "编写一个 ruby 函数 `def longest_consecutive_sequence(arr)` 来解决以下问题：\n查找整数数组中最长连续序列的长度。\n该函数接受一个整数数组作为参数，并返回数组中存在的最长连续序列的长度。\n\n示例：\n>>> longest_consecutive_sequence([1, 5, 6, 2, 3, 4, 5, 6, 8, 9])\n6   因为最长的连续序列是 1, 2, 3, 4, 5, 6\n>>> longest_consecutive_sequence([10, 4, 20, 1, 3, 2])\n4   因为最长的连续序列是 1, 2, 3, 4",
      "fr": "Écrire une fonction ruby `def longest_consecutive_sequence(arr)` pour résoudre le problème suivant :\nTrouve la longueur de la plus longue séquence consécutive dans un tableau d'entiers.\nLa fonction prend un tableau d'entiers comme argument et renvoie la longueur\nde la plus longue séquence consécutive de nombres présents dans le tableau.\n\nExemple :\n>>> longest_consecutive_sequence([1, 5, 6, 2, 3, 4, 5, 6, 8, 9])\n6   Parce que la plus longue séquence consécutive est 1, 2, 3, 4, 5, 6\n>>> longest_consecutive_sequence([10, 4, 20, 1, 3, 2])\n4   Parce que la plus longue séquence consécutive est 1, 2, 3, 4",
      "de": "Schreiben Sie eine Ruby-Funktion `def longest_consecutive_sequence(arr)`, um das folgende Problem zu lösen:\nFindet die Länge der längsten aufeinanderfolgenden Sequenz in einem Array von ganzen Zahlen.\n Die Funktion nimmt ein Array von ganzen Zahlen als Argument und gibt die Länge\n der längsten aufeinanderfolgenden Zahlenfolge im Array zurück.\n\n Beispiel:\n >>> longest_consecutive_sequence([1, 5, 6, 2, 3, 4, 5, 6, 8, 9])\n 6   Weil die längste aufeinanderfolgende Sequenz 1, 2, 3, 4, 5, 6 ist\n >>> longest_consecutive_sequence([10, 4, 20, 1, 3, 2])\n 4   Weil die längste aufeinanderfolgende Sequenz 1, 2, 3, 4 ist",
      "ha": "Rubuta aikin ruby `def longest_consecutive_sequence(arr)` don warware matsalar mai zuwa:  \nNemo tsawon jerin lambobi masu jere mafi tsawo a cikin jerin lambobi na integers.  \nAikin yana karɓar jerin lambobi na integers a matsayin hujja kuma yana dawowa da tsawon  \njerin lambobi masu jere mafi tsawo da ke cikin jerin.\n\nMisali:\n>>> longest_consecutive_sequence([1, 5, 6, 2, 3, 4, 5, 6, 8, 9])\n6   Domin jerin lambobi masu jere mafi tsawo sune 1, 2, 3, 4, 5, 6\n>>> longest_consecutive_sequence([10, 4, 20, 1, 3, 2])\n4   Domin jerin lambobi masu jere mafi tsawo sune 1, 2, 3, 4",
      "hi": "रूबी फ़ंक्शन `def longest_consecutive_sequence(arr)` लिखें ताकि निम्नलिखित समस्या का समाधान किया जा सके:\nएक पूर्णांकों की array में सबसे लंबी लगातार अनुक्रम की लंबाई खोजें।\nयह फ़ंक्शन एक पूर्णांकों की array को तर्क के रूप में लेता है और array में उपस्थित संख्याओं के सबसे लंबे लगातार अनुक्रम की लंबाई लौटाता है।\n\nउदाहरण:\n>>> longest_consecutive_sequence([1, 5, 6, 2, 3, 4, 5, 6, 8, 9])\n6   क्योंकि सबसे लंबा लगातार अनुक्रम 1, 2, 3, 4, 5, 6 है\n>>> longest_consecutive_sequence([10, 4, 20, 1, 3, 2])\n4   क्योंकि सबसे लंबा लगातार अनुक्रम 1, 2, 3, 4 है",
      "hu": "Írj egy ruby függvényt `def longest_consecutive_sequence(arr)` a következő probléma megoldására:\nMegtalálja a leghosszabb egymást követő sorozat hosszát egy egész számokat tartalmazó tömbben.\n A függvény egy egész számokat tartalmazó tömböt vesz át argumentumként, és visszaadja\n a tömbben található leghosszabb egymást követő számok sorozatának hosszát.\n\n Példa:\n >>> longest_consecutive_sequence([1, 5, 6, 2, 3, 4, 5, 6, 8, 9])\n 6   Mert a leghosszabb egymást követő sorozat 1, 2, 3, 4, 5, 6\n >>> longest_consecutive_sequence([10, 4, 20, 1, 3, 2])\n 4   Mert a leghosszabb egymást követő sorozat 1, 2, 3, 4"
    },
    "instruction_bertscore": {
      "sq": "1",
      "hy": "0.9872592514692792",
      "bn": "0.9903604676083769",
      "bg": "0.9947927059307894",
      "zh": "0.9626674198844928",
      "fr": "0.9949490280406639",
      "de": "0.9781411238278727",
      "ha": "0.9786180353727374",
      "hi": "0.9892523087125832",
      "hu": "0.9934263275396503"
    },
    "level": "hard",
    "test": "raise 'Test failed' unless longest_consecutive_sequence([1, 5, 6, 2, 3, 4, 5, 6, 8, 9]) ==6\nraise 'Test failed' unless longest_consecutive_sequence([10, 4, 20, 1, 3, 2]) == 4\nraise 'Test failed' unless longest_consecutive_sequence([100, 4, 200, 1, 3, 2]) == 4\nraise 'Test failed' unless longest_consecutive_sequence([1, 2, 0, 1]) == 3\nraise 'Test failed' unless longest_consecutive_sequence([]) == 0\nraise 'Test failed' unless longest_consecutive_sequence([1]) == 1",
    "entry_point": "longest_consecutive_sequence",
    "signature": "def longest_consecutive_sequence(arr)",
    "docstring": {
      "en": "Finds the length of the longest consecutive sequence in an array of integers.\n The function takes an array of integers as an argument and returns the length\n of the longest consecutive sequence of numbers present in the array.\n\n Example:\n >>> longest_consecutive_sequence([1, 5, 6, 2, 3, 4, 5, 6, 8, 9])\n 6   Because the longest consecutive sequence is 1, 2, 3, 4, 5, 6\n >>> longest_consecutive_sequence([10, 4, 20, 1, 3, 2])\n 4   Because the longest consecutive sequence is 1, 2, 3, 4",
      "sq": "Gjen gjatësinë e sekuencës më të gjatë të njëpasnjëshme në një varg të numrave të plotë.\n Funksioni merr një varg të numrave të plotë si argument dhe kthen gjatësinë\n e sekuencës më të gjatë të njëpasnjëshme të numrave të pranishëm në varg.\n\n Shembull:\n >>> longest_consecutive_sequence([1, 5, 6, 2, 3, 4, 5, 6, 8, 9])\n 6   Sepse sekuenca më e gjatë e njëpasnjëshme është 1, 2, 3, 4, 5, 6\n >>> longest_consecutive_sequence([10, 4, 20, 1, 3, 2])\n 4   Sepse sekuenca më e gjatë e njëpasnjëshme është 1, 2, 3, 4",
      "hy": "Գտնում է ամբողջ թվերի զանգվածում ամենաերկար հաջորդական հաջորդականության երկարությունը։ Ֆունկցիան որպես արգումենտ ընդունում է ամբողջ թվերի զանգված և վերադարձնում է զանգվածում առկա ամենաերկար հաջորդական հաջորդականության երկարությունը։\n\nՕրինակ:\n>>> longest_consecutive_sequence([1, 5, 6, 2, 3, 4, 5, 6, 8, 9])\n6   Քանի որ ամենաերկար հաջորդական հաջորդականությունը 1, 2, 3, 4, 5, 6 է\n>>> longest_consecutive_sequence([10, 4, 20, 1, 3, 2])\n4   Քանի որ ամենաերկար հաջորդական հաջորդականությունը 1, 2, 3, 4 է",
      "bn": "একটি পূর্ণসংখ্যার অ্যারের মধ্যে দীর্ঘতম ধারাবাহিক অনুক্রমের দৈর্ঘ্য খুঁজে বের করে।\nইনটিজারগুলির একটি অ্যারের মধ্যে দীর্ঘতম ধারাবাহিক ক্রমের দৈর্ঘ্য খুঁজে বের করে। ফাংশনটি একটি ইনটিজার অ্যারে আর্গুমেন্ট হিসাবে গ্রহণ করে এবং অ্যারেতে উপস্থিত দীর্ঘতম ধারাবাহিক সংখ্যার ক্রমের দৈর্ঘ্য ফেরত দেয়।\n\nউদাহরণ:\n>>> longest_consecutive_sequence([1, 5, 6, 2, 3, 4, 5, 6, 8, 9])\n6   কারণ দীর্ঘতম ধারাবাহিক ক্রমটি হল 1, 2, 3, 4, 5, 6\n>>> longest_consecutive_sequence([10, 4, 20, 1, 3, 2])\n4   কারণ দীর্ঘতম ধারাবাহিক ক্রমটি হল 1, 2, 3, 4",
      "bg": "Намира дължината на най-дългата последователна поредица в масив от цели числа.\nФункцията приема масив от цели числа като аргумент и връща дължината на най-дългата последователна поредица от числа, присъстващи в масива.\n\nПример:\n>>> longest_consecutive_sequence([1, 5, 6, 2, 3, 4, 5, 6, 8, 9])\n6   Защото най-дългата последователна поредица е 1, 2, 3, 4, 5, 6\n>>> longest_consecutive_sequence([10, 4, 20, 1, 3, 2])\n4   Защото най-дългата последователна поредица е 1, 2, 3, 4",
      "zh": "找到整数数组中最长连续序列的长度。该函数接受一个整数数组作为参数，并返回数组中存在的最长连续数字序列的长度。\n\n示例：\n>>> longest_consecutive_sequence([1, 5, 6, 2, 3, 4, 5, 6, 8, 9])\n6   因为最长的连续序列是 1, 2, 3, 4, 5, 6\n>>> longest_consecutive_sequence([10, 4, 20, 1, 3, 2])\n4   因为最长的连续序列是 1, 2, 3, 4",
      "fr": "Trouve la longueur de la plus longue séquence consécutive dans un tableau d'entiers.\n La fonction prend un tableau d'entiers comme argument et renvoie la longueur\n de la plus longue séquence consécutive de nombres présente dans le tableau.\n\n Exemple :\n >>> longest_consecutive_sequence([1, 5, 6, 2, 3, 4, 5, 6, 8, 9])\n 6   Parce que la plus longue séquence consécutive est 1, 2, 3, 4, 5, 6\n >>> longest_consecutive_sequence([10, 4, 20, 1, 3, 2])\n 4   Parce que la plus longue séquence consécutive est 1, 2, 3, 4",
      "de": "Findet die Länge der längsten aufeinanderfolgenden Sequenz in einem Array von ganzen Zahlen.\n Die Funktion nimmt ein Array von ganzen Zahlen als Argument und gibt die Länge\n der längsten aufeinanderfolgenden Zahlenfolge im Array zurück.\n\n Beispiel:\n >>> longest_consecutive_sequence([1, 5, 6, 2, 3, 4, 5, 6, 8, 9])\n 6   Weil die längste aufeinanderfolgende Sequenz 1, 2, 3, 4, 5, 6 ist\n >>> longest_consecutive_sequence([10, 4, 20, 1, 3, 2])\n 4   Weil die längste aufeinanderfolgende Sequenz 1, 2, 3, 4 ist",
      "ha": "Yana gano tsawon mafi tsawo jere mai ci gaba a cikin jerin lambobi masu tsari. Aikin yana karɓar jerin lambobi masu tsari a matsayin hujja kuma yana mayar da tsawon mafi tsawo jere mai ci gaba na lambobi da ke cikin jerin.\n\nMisali:\n>>> longest_consecutive_sequence([1, 5, 6, 2, 3, 4, 5, 6, 8, 9])\n6   Domin mafi tsawo jere mai ci gaba shine 1, 2, 3, 4, 5, 6\n>>> longest_consecutive_sequence([10, 4, 20, 1, 3, 2])\n4   Domin mafi tsawo jere mai ci gaba shine 1, 2, 3, 4",
      "hi": "एक पूर्णांकों की array में सबसे लंबे लगातार अनुक्रम की लंबाई खोजता है।\nयह फ़ंक्शन पूर्णांकों की एक array को तर्क के रूप में लेता है और array में उपस्थित संख्याओं के सबसे लंबे लगातार अनुक्रम की लंबाई लौटाता है।\n\nउदाहरण:\n>>> longest_consecutive_sequence([1, 5, 6, 2, 3, 4, 5, 6, 8, 9])\n6   क्योंकि सबसे लंबा लगातार अनुक्रम 1, 2, 3, 4, 5, 6 है\n>>> longest_consecutive_sequence([10, 4, 20, 1, 3, 2])\n4   क्योंकि सबसे लंबा लगातार अनुक्रम 1, 2, 3, 4 है",
      "hu": "Megtalálja a leghosszabb egymást követő sorozat hosszát egy egész számokat tartalmazó tömbben. \nA függvény egy egész számokat tartalmazó tömböt vesz argumentumként, és visszaadja a tömbben található leghosszabb egymást követő számok sorozatának hosszát.\n\nPélda:\n>>> longest_consecutive_sequence([1, 5, 6, 2, 3, 4, 5, 6, 8, 9])\n6   Mert a leghosszabb egymást követő sorozat 1, 2, 3, 4, 5, 6\n>>> longest_consecutive_sequence([10, 4, 20, 1, 3, 2])\n4   Mert a leghosszabb egymást követő sorozat 1, 2, 3, 4"
    },
    "docstring_bertscore": {
      "sq": "0.9930380051447272",
      "hy": "0.9854511191107186",
      "bn": "0.9892115894844711",
      "bg": "1",
      "zh": "0.9584201064468237",
      "fr": "0.9930380051447272",
      "de": "0.9937201018732009",
      "ha": "0.9866079424498657",
      "hi": "0.9946492947956822",
      "hu": "0.9927219842085007"
    }
  },
  {
    "task_id": "Ruby/44",
    "prompt": {
      "en": "# Compares the area of a square with side length 'a' to the area of a rectangle with sides 'b' and 'c'.\n# The function takes three arguments, a, b, and c, which are positive integers representing the side length of the square and the sides of the rectangle, respectively.\n# It returns a string indicating whose shape has the greater area: \"Alice\" if the square's area is larger, and \"Bob\" if the rectangle's area is larger.\n#\n# Examples:\n# >>> compare_area(5, 4, 6)\n# \"Alice\"\n# >>> compare_area(7, 5, 10)\n# \"Bob\"\n\ndef compare_area(a, b, c)",
      "sq": "# Krahason sipërfaqen e një katrori me gjatësi brinje 'a' me sipërfaqen e një drejtkëndëshi me brinjë 'b' dhe 'c'.\n# Funksioni merr tre argumente, a, b, dhe c, të cilat janë numra të plotë pozitivë që përfaqësojnë gjatësinë e brinjës së katrorit dhe brinjët e drejtkëndëshit, përkatësisht.\n# Kthen një varg që tregon se cila formë ka sipërfaqen më të madhe: \"Alice\" nëse sipërfaqja e katrorit është më e madhe, dhe \"Bob\" nëse sipërfaqja e drejtkëndëshit është më e madhe.\n#\n# Shembuj:\n# >>> compare_area(5, 4, 6)\n# \"Alice\"\n# >>> compare_area(7, 5, 10)\n# \"Bob\"\n\ndef compare_area(a, b, c)",
      "hy": "# Համեմատում է կողմի երկարությունը 'a' ունեցող քառակուսու մակերեսը կողմերի 'b' և 'c' ունեցող ուղղանկյան մակերեսի հետ։\n# Ֆունկցիան ընդունում է երեք արգումենտ՝ a, b և c, որոնք դրական ամբողջ թվեր են՝ համապատասխանաբար ներկայացնելով քառակուսու կողմի երկարությունը և ուղղանկյան կողմերը։\n# Այն վերադարձնում է տող, որը ցույց է տալիս, թե ում ձևն ունի ավելի մեծ մակերես՝ \"Alice\", եթե քառակուսու մակերեսը մեծ է, և \"Bob\", եթե ուղղանկյան մակերեսը մեծ է։\n#\n# Օրինակներ:\n# >>> compare_area(5, 4, 6)\n# \"Alice\"\n# >>> compare_area(7, 5, 10)\n# \"Bob\"\n\ndef compare_area(a, b, c)",
      "bn": "# একটি বর্গক্ষেত্রের বাহুর দৈর্ঘ্য 'a' এর ক্ষেত্রফলকে একটি আয়তক্ষেত্রের বাহু 'b' এবং 'c' এর ক্ষেত্রফলের সাথে তুলনা করে।\n# ফাংশনটি তিনটি আর্গুমেন্ট নেয়, যথাক্রমে a, b, এবং c, যা বর্গক্ষেত্রের বাহুর দৈর্ঘ্য এবং আয়তক্ষেত্রের বাহুগুলি নির্দেশ করে, এবং এরা ধনাত্মক পূর্ণসংখ্যা।\n# এটি একটি স্ট্রিং ফেরত দেয় যা নির্দেশ করে কোন আকৃতির ক্ষেত্রফল বড়: \"Alice\" যদি বর্গক্ষেত্রের ক্ষেত্রফল বড় হয়, এবং \"Bob\" যদি আয়তক্ষেত্রের ক্ষেত্রফল বড় হয়।\n#\n# উদাহরণ:\n# >>> compare_area(5, 4, 6)\n# \"Alice\"\n# >>> compare_area(7, 5, 10)\n# \"Bob\"\n\ndef compare_area(a, b, c)",
      "bg": "# Сравнява площта на квадрат със страна 'a' с площта на правоъгълник със страни 'b' и 'c'.\n# Функцията приема три аргумента, a, b и c, които са положителни цели числа, представляващи дължината на страната на квадрата и страните на правоъгълника, съответно.\n# Връща низ, указващ чия форма има по-голяма площ: \"Alice\", ако площта на квадрата е по-голяма, и \"Bob\", ако площта на правоъгълника е по-голяма.\n#\n# Примери:\n# >>> compare_area(5, 4, 6)\n# \"Alice\"\n# >>> compare_area(7, 5, 10)\n# \"Bob\"\n\ndef compare_area(a, b, c)",
      "zh": "# 比较边长为 'a' 的正方形与边长为 'b' 和 'c' 的矩形的面积。\n# 该函数接受三个参数 a, b 和 c，它们是表示正方形边长和矩形边长的正整数。\n# 它返回一个字符串，指示哪个形状的面积更大：如果正方形的面积更大，则返回 \"Alice\"；如果矩形的面积更大，则返回 \"Bob\"。\n#\n# 例子:\n# >>> compare_area(5, 4, 6)\n# \"Alice\"\n# >>> compare_area(7, 5, 10)\n# \"Bob\"\n\ndef compare_area(a, b, c)",
      "fr": "# Compare la superficie d'un carré avec une longueur de côté 'a' à la superficie d'un rectangle avec des côtés 'b' et 'c'.\n# La fonction prend trois arguments, a, b, et c, qui sont des entiers positifs représentant la longueur du côté du carré et les côtés du rectangle, respectivement.\n# Elle renvoie une chaîne indiquant quelle forme a la plus grande superficie : \"Alice\" si la superficie du carré est plus grande, et \"Bob\" si la superficie du rectangle est plus grande.\n#\n# Exemples :\n# >>> compare_area(5, 4, 6)\n# \"Alice\"\n# >>> compare_area(7, 5, 10)\n# \"Bob\"\n\ndef compare_area(a, b, c)",
      "de": "# Vergleicht die Fläche eines Quadrats mit Seitenlänge 'a' mit der Fläche eines Rechtecks mit den Seiten 'b' und 'c'.\n# Die Funktion nimmt drei Argumente, a, b und c, die positive ganze Zahlen sind und die Seitenlänge des Quadrats bzw. die Seiten des Rechtecks darstellen.\n# Sie gibt einen String zurück, der angibt, welche Form die größere Fläche hat: \"Alice\", wenn die Fläche des Quadrats größer ist, und \"Bob\", wenn die Fläche des Rechtecks größer ist.\n#\n# Beispiele:\n# >>> compare_area(5, 4, 6)\n# \"Alice\"\n# >>> compare_area(7, 5, 10)\n# \"Bob\"\n\ndef compare_area(a, b, c)",
      "ha": "# Yana kwatanta yankin murabba'i tare da tsawon gefe 'a' da yankin murabba'i mai gefe 'b' da 'c'.\n# Aikin yana ɗaukar hujjoji guda uku, a, b, da c, waɗanda su ne lambobi masu kyau da ke wakiltar tsawon gefen murabba'i da gefen murabba'in, bi da bi.\n# Yana dawo da wani igiya da ke nuna wane siffa ke da babban yanki: \"Alice\" idan yankin murabba'i ya fi girma, da \"Bob\" idan yankin murabba'in ya fi girma.\n#\n# Misalai:\n# >>> compare_area(5, 4, 6)\n# \"Alice\"\n# >>> compare_area(7, 5, 10)\n# \"Bob\"\n\ndef compare_area(a, b, c)",
      "hi": "# वर्ग के क्षेत्रफल की तुलना 'a' लंबाई वाले वर्ग से आयत के क्षेत्रफल से करता है जिसके भुजाएँ 'b' और 'c' हैं।\n# यह फ़ंक्शन तीन तर्क लेता है, a, b, और c, जो क्रमशः वर्ग की भुजा की लंबाई और आयत की भुजाओं का प्रतिनिधित्व करते हैं।\n# यह एक स्ट्रिंग लौटाता है जो यह दर्शाता है कि किस आकृति का क्षेत्रफल बड़ा है: \"Alice\" यदि वर्ग का क्षेत्रफल बड़ा है, और \"Bob\" यदि आयत का क्षेत्रफल बड़ा है।\n#\n# उदाहरण:\n# >>> compare_area(5, 4, 6)\n# \"Alice\"\n# >>> compare_area(7, 5, 10)\n# \"Bob\"\n\ndef compare_area(a, b, c)",
      "hu": "# Összehasonlítja egy 'a' oldalhosszúságú négyzet területét egy 'b' és 'c' oldalú téglalap területével.\n# A függvény három argumentumot vesz fel: a, b és c, amelyek pozitív egész számok, és a négyzet oldalhosszát, valamint a téglalap oldalait képviselik.\n# Egy karakterláncot ad vissza, amely jelzi, hogy melyik alakzatnak nagyobb a területe: \"Alice\", ha a négyzet területe nagyobb, és \"Bob\", ha a téglalap területe nagyobb.\n#\n# Példák:\n# >>> compare_area(5, 4, 6)\n# \"Alice\"\n# >>> compare_area(7, 5, 10)\n# \"Bob\"\n\ndef compare_area(a, b, c)"
    },
    "prompt_bertscore": {
      "sq": "0.9868037920055661",
      "hy": "0.9940027529054136",
      "bn": "0.9814520936493432",
      "bg": "0.9759979020165062",
      "zh": "0.9397768575132702",
      "fr": "0.9829050748866134",
      "de": "0.9864639354236154",
      "ha": "0.9888169109173548",
      "hi": "0.9796109886475308",
      "hu": "0.9852574544892095"
    },
    "canonical_solution": "    square_area = a * a\n    rectangle_area = b * c\n    if square_area > rectangle_area\n      \"Alice\"\n    else\n      \"Bob\"\n    end\n  end",
    "instruction": {
      "en": "Write a ruby function `def compare_area(a, b, c)` to solve the following problem:\nCompares the area of a square with side length 'a' to the area of a rectangle with sides 'b' and 'c'.\n The function takes three arguments, a, b, and c, which are positive integers representing the side length of the square and the sides of the rectangle, respectively.\n It returns a string indicating whose shape has the greater area: \"Alice\" if the square's area is larger, and \"Bob\" if the rectangle's area is larger.\n\n Examples:\n >>> compare_area(5, 4, 6)\n \"Alice\"\n >>> compare_area(7, 5, 10)\n \"Bob\"",
      "sq": "Shkruani një funksion ruby `def compare_area(a, b, c)` për të zgjidhur problemin e mëposhtëm:\nKrahason sipërfaqen e një katrori me gjatësi brinje 'a' me sipërfaqen e një drejtkëndëshi me brinjë 'b' dhe 'c'.\n Funksioni merr tre argumente, a, b, dhe c, të cilat janë numra të plotë pozitivë që përfaqësojnë gjatësinë e brinjës së katrorit dhe brinjët e drejtkëndëshit, përkatësisht.\n Ai kthen një varg që tregon se cila formë ka sipërfaqen më të madhe: \"Alice\" nëse sipërfaqja e katrorit është më e madhe, dhe \"Bob\" nëse sipërfaqja e drejtkëndëshit është më e madhe.\n\n Shembuj:\n >>> compare_area(5, 4, 6)\n \"Alice\"\n >>> compare_area(7, 5, 10)\n \"Bob\"",
      "hy": "Գրեք ruby ֆունկցիա `def compare_area(a, b, c)` հետևյալ խնդիրը լուծելու համար:\nՀամեմատում է 'a' կողմով քառակուսու մակերեսը 'b' և 'c' կողմերով ուղղանկյան մակերեսի հետ:\n Ֆունկցիան ընդունում է երեք արգումենտ՝ a, b, և c, որոնք դրական ամբողջ թվեր են, ներկայացնելով համապատասխանաբար քառակուսու և ուղղանկյան կողմերը:\n Այն վերադարձնում է տող, որը ցույց է տալիս, թե ում ձևն ունի ավելի մեծ մակերես՝ \"Alice\", եթե քառակուսու մակերեսը մեծ է, և \"Bob\", եթե ուղղանկյան մակերեսը մեծ է:\n\n Օրինակներ:\n >>> compare_area(5, 4, 6)\n \"Alice\"\n >>> compare_area(7, 5, 10)\n \"Bob\"",
      "bn": "রুবি ফাংশন `def compare_area(a, b, c)` লিখুন নিম্নলিখিত সমস্যার সমাধানের জন্য:\nএকটি বর্গক্ষেত্রের বাহুর দৈর্ঘ্য 'a' এবং একটি আয়তক্ষেত্রের বাহুর দৈর্ঘ্য 'b' এবং 'c' এর ক্ষেত্রফল তুলনা করে।\nফাংশনটি তিনটি আর্গুমেন্ট গ্রহণ করে, a, b, এবং c, যা যথাক্রমে বর্গক্ষেত্রের বাহুর দৈর্ঘ্য এবং আয়তক্ষেত্রের বাহুর দৈর্ঘ্য নির্দেশ করে, এবং এগুলি ধনাত্মক পূর্ণসংখ্যা।\nএটি একটি স্ট্রিং রিটার্ন করে যা নির্দেশ করে কোন আকৃতির ক্ষেত্রফল বড়: \"Alice\" যদি বর্গক্ষেত্রের ক্ষেত্রফল বড় হয়, এবং \"Bob\" যদি আয়তক্ষেত্রের ক্ষেত্রফল বড় হয়।\n\nউদাহরণ:\n>>> compare_area(5, 4, 6)\n\"Alice\"\n>>> compare_area(7, 5, 10)\n\"Bob\"",
      "bg": "Напишете функция на Ruby `def compare_area(a, b, c)` за решаване на следния проблем:\nСравнява площта на квадрат със страна 'a' с площта на правоъгълник със страни 'b' и 'c'.\n Функцията приема три аргумента, a, b и c, които са положителни цели числа, представляващи дължината на страната на квадрата и страните на правоъгълника, съответно.\n Тя връща низ, указващ чия форма има по-голяма площ: \"Alice\", ако площта на квадрата е по-голяма, и \"Bob\", ако площта на правоъгълника е по-голяма.\n\n Примери:\n >>> compare_area(5, 4, 6)\n \"Alice\"\n >>> compare_area(7, 5, 10)\n \"Bob\"",
      "zh": "编写一个 ruby 函数 `def compare_area(a, b, c)` 来解决以下问题：\n比较边长为 'a' 的正方形的面积与边长为 'b' 和 'c' 的矩形的面积。\n该函数接受三个参数，a、b 和 c，它们是表示正方形边长和矩形边长的正整数。\n它返回一个字符串，指示哪个形状的面积更大：“Alice”如果正方形的面积更大，“Bob”如果矩形的面积更大。\n\n示例：\n>>> compare_area(5, 4, 6)\n\"Alice\"\n>>> compare_area(7, 5, 10)\n\"Bob\"",
      "fr": "Écrire une fonction ruby `def compare_area(a, b, c)` pour résoudre le problème suivant :\nCompare l'aire d'un carré avec une longueur de côté 'a' à l'aire d'un rectangle avec les côtés 'b' et 'c'.\nLa fonction prend trois arguments, a, b, et c, qui sont des entiers positifs représentant la longueur du côté du carré et les côtés du rectangle, respectivement.\nElle renvoie une chaîne indiquant quelle forme a la plus grande aire : \"Alice\" si l'aire du carré est plus grande, et \"Bob\" si l'aire du rectangle est plus grande.\n\nExemples :\n>>> compare_area(5, 4, 6)\n\"Alice\"\n>>> compare_area(7, 5, 10)\n\"Bob\"",
      "de": "Schreiben Sie eine Ruby-Funktion `def compare_area(a, b, c)`, um das folgende Problem zu lösen:\nVergleicht die Fläche eines Quadrats mit Seitenlänge 'a' mit der Fläche eines Rechtecks mit den Seiten 'b' und 'c'.\n Die Funktion nimmt drei Argumente, a, b und c, die positive ganze Zahlen sind und die Seitenlänge des Quadrats bzw. die Seiten des Rechtecks darstellen.\n Sie gibt einen String zurück, der angibt, welche Form die größere Fläche hat: \"Alice\", wenn die Fläche des Quadrats größer ist, und \"Bob\", wenn die Fläche des Rechtecks größer ist.\n\n Beispiele:\n >>> compare_area(5, 4, 6)\n \"Alice\"\n >>> compare_area(7, 5, 10)\n \"Bob\"",
      "ha": "Rubuta aikin ruby `def compare_area(a, b, c)` don warware matsalar mai zuwa:\nYa kwatanta yankin murabba'i mai tsawon gefe 'a' da yankin murabba'i mai bangarori 'b' da 'c'.\n Aikin yana ɗaukar hujjoji guda uku, a, b, da c, waɗanda su ne lambobi masu kyau da ke wakiltar tsawon gefen murabba'i da bangarorin murabba'in, bi da bi.\n Yana dawo da kirtani da ke nuna wane siffa ke da girman yanki: \"Alice\" idan yankin murabba'i ya fi girma, kuma \"Bob\" idan yankin murabba'in ya fi girma.\n\n Misalai:\n >>> compare_area(5, 4, 6)\n \"Alice\"\n >>> compare_area(7, 5, 10)\n \"Bob\"",
      "hi": "`def compare_area(a, b, c)` निम्नलिखित समस्या को हल करने के लिए एक रूबी फ़ंक्शन लिखें:\nवर्ग जिसकी भुजा की लंबाई 'a' है, उसके क्षेत्रफल की तुलना आयत के क्षेत्रफल से करता है जिसकी भुजाएँ 'b' और 'c' हैं।\n यह फ़ंक्शन तीन तर्क लेता है, a, b, और c, जो क्रमशः वर्ग की भुजा की लंबाई और आयत की भुजाओं का प्रतिनिधित्व करते हैं।\n यह एक स्ट्रिंग लौटाता है जो यह दर्शाता है कि किस आकृति का क्षेत्रफल अधिक है: \"Alice\" यदि वर्ग का क्षेत्रफल बड़ा है, और \"Bob\" यदि आयत का क्षेत्रफल बड़ा है।\n\n उदाहरण:\n >>> compare_area(5, 4, 6)\n \"Alice\"\n >>> compare_area(7, 5, 10)\n \"Bob\"",
      "hu": "Írj egy ruby függvényt `def compare_area(a, b, c)` a következő probléma megoldására:\nÖsszehasonlítja egy 'a' oldalhosszúságú négyzet területét egy 'b' és 'c' oldalú téglalap területével.\n A függvény három argumentumot vesz fel, a, b és c, amelyek pozitív egész számok, és a négyzet oldalhosszát, valamint a téglalap oldalait képviselik.\n Visszaad egy karakterláncot, amely jelzi, hogy melyik alakzatnak nagyobb a területe: \"Alice\", ha a négyzet területe nagyobb, és \"Bob\", ha a téglalap területe nagyobb.\n\n Példák:\n >>> compare_area(5, 4, 6)\n \"Alice\"\n >>> compare_area(7, 5, 10)\n \"Bob\""
    },
    "instruction_bertscore": {
      "sq": "0.9860944829148905",
      "hy": "0.9694146952978668",
      "bn": "0.963135591692592",
      "bg": "0.9741560024931697",
      "zh": "0.965993882875684",
      "fr": "0.9831245614576569",
      "de": "0.9792405429869008",
      "ha": "0.9668799730054807",
      "hi": "0.9687671602556931",
      "hu": "0.985920284070723"
    },
    "level": "easy",
    "test": "raise 'Test failed' unless compare_area(5, 4, 6) == \"Alice\"\nraise 'Test failed' unless compare_area(7, 5, 10) == \"Bob\"\nraise 'Test failed' unless compare_area(6, 3, 12) == \"Bob\"\nraise 'Test failed' unless compare_area(10, 10, 1) == \"Alice\"\nraise 'Test failed' unless compare_area(8, 8, 8) == \"Bob\" # Case where areas are equal, but based on the problem statement, Bob wins in a tie.",
    "entry_point": "compare_area",
    "signature": "def compare_area(a, b, c)",
    "docstring": {
      "en": "Compares the area of a square with side length 'a' to the area of a rectangle with sides 'b' and 'c'.\n The function takes three arguments, a, b, and c, which are positive integers representing the side length of the square and the sides of the rectangle, respectively.\n It returns a string indicating whose shape has the greater area: \"Alice\" if the square's area is larger, and \"Bob\" if the rectangle's area is larger.\n\n Examples:\n >>> compare_area(5, 4, 6)\n \"Alice\"\n >>> compare_area(7, 5, 10)\n \"Bob\"",
      "sq": "Krahason sipërfaqen e një katrori me gjatësi brinje 'a' me sipërfaqen e një drejtkëndëshi me brinjë 'b' dhe 'c'.\n Funksioni merr tre argumente, a, b, dhe c, të cilat janë numra të plotë pozitivë që përfaqësojnë gjatësinë e brinjës së katrorit dhe brinjët e drejtkëndëshit, përkatësisht.\n Ai kthen një varg që tregon se cila formë ka sipërfaqen më të madhe: \"Alice\" nëse sipërfaqja e katrorit është më e madhe, dhe \"Bob\" nëse sipërfaqja e drejtkëndëshit është më e madhe.\n\n Shembuj:\n >>> compare_area(5, 4, 6)\n \"Alice\"\n >>> compare_area(7, 5, 10)\n \"Bob\"",
      "hy": "Համեմատում է կողմի երկարությունը 'a' ունեցող քառակուսու մակերեսը կողմերի 'b' և 'c' ունեցող ուղղանկյան մակերեսի հետ։ \nՖունկցիան ստանում է երեք արգումենտ՝ a, b և c, որոնք դրական ամբողջ թվեր են՝ ներկայացնելով համապատասխանաբար քառակուսու կողմի երկարությունը և ուղղանկյան կողմերը։\nԱյն վերադարձնում է տող, որը ցույց է տալիս, թե ում ձևն ունի ավելի մեծ մակերես՝ \"Alice\", եթե քառակուսու մակերեսը մեծ է, և \"Bob\", եթե ուղղանկյան մակերեսը մեծ է։\n\nՕրինակներ:\n>>> compare_area(5, 4, 6)\n\"Alice\"\n>>> compare_area(7, 5, 10)\n\"Bob\"",
      "bn": "বর্গক্ষেত্রের বাহুর দৈর্ঘ্য 'a' এবং আয়তক্ষেত্রের বাহুর দৈর্ঘ্য 'b' এবং 'c' এর ক্ষেত্রফল তুলনা করে। \nফাংশনটি তিনটি আর্গুমেন্ট গ্রহণ করে, যথাক্রমে a, b, এবং c, যা বর্গক্ষেত্রের বাহুর দৈর্ঘ্য এবং আয়তক্ষেত্রের বাহুগুলির প্রতিনিধিত্বকারী ধনাত্মক পূর্ণসংখ্যা। \nএটি একটি স্ট্রিং ফেরত দেয় যা নির্দেশ করে কার আকৃতির ক্ষেত্রফল বেশি: \"Alice\" যদি বর্গক্ষেত্রের ক্ষেত্রফল বড় হয়, এবং \"Bob\" যদি আয়তক্ষেত্রের ক্ষেত্রফল বড় হয়।\n\nউদাহরণ:\n>>> compare_area(5, 4, 6)\n\"Alice\"\n>>> compare_area(7, 5, 10)\n\"Bob\"",
      "bg": "Сравнява площта на квадрат със страна 'a' с площта на правоъгълник със страни 'b' и 'c'.\n Функцията приема три аргумента, a, b и c, които са положителни цели числа, представляващи дължината на страната на квадрата и страните на правоъгълника, съответно.\n Връща низ, указващ чия форма има по-голяма площ: \"Alice\", ако площта на квадрата е по-голяма, и \"Bob\", ако площта на правоъгълника е по-голяма.\n\n Примери:\n >>> compare_area(5, 4, 6)\n \"Alice\"\n >>> compare_area(7, 5, 10)\n \"Bob\"",
      "zh": "比较边长为 'a' 的正方形的面积与边长为 'b' 和 'c' 的矩形的面积。\n该函数接受三个参数，a、b 和 c，它们是表示正方形边长和矩形边长的正整数。\n它返回一个字符串，指示哪个形状的面积更大：“Alice”如果正方形的面积更大，“Bob”如果矩形的面积更大。\n\n示例：\n>>> compare_area(5, 4, 6)\n\"Alice\"\n>>> compare_area(7, 5, 10)\n\"Bob\"",
      "fr": "Compare l'aire d'un carré avec une longueur de côté 'a' à l'aire d'un rectangle avec des côtés 'b' et 'c'.\n La fonction prend trois arguments, a, b, et c, qui sont des entiers positifs représentant la longueur du côté du carré et les côtés du rectangle, respectivement.\n Elle renvoie une chaîne indiquant quelle forme a la plus grande aire : \"Alice\" si l'aire du carré est plus grande, et \"Bob\" si l'aire du rectangle est plus grande.\n\n Exemples:\n >>> compare_area(5, 4, 6)\n \"Alice\"\n >>> compare_area(7, 5, 10)\n \"Bob\"",
      "de": "Vergleicht die Fläche eines Quadrats mit Seitenlänge 'a' mit der Fläche eines Rechtecks mit den Seiten 'b' und 'c'.\n Die Funktion nimmt drei Argumente entgegen, a, b und c, die positive ganze Zahlen sind und die Seitenlänge des Quadrats bzw. die Seiten des Rechtecks darstellen.\n Sie gibt einen String zurück, der angibt, wessen Form die größere Fläche hat: \"Alice\", wenn die Fläche des Quadrats größer ist, und \"Bob\", wenn die Fläche des Rechtecks größer ist.\n\n Beispiele:\n >>> compare_area(5, 4, 6)\n \"Alice\"\n >>> compare_area(7, 5, 10)\n \"Bob\"",
      "ha": "Yana kwatanta yankin murabba'i tare da tsawon gefe 'a' da yankin murabba'i mai gefe 'b' da 'c'.\n  Aikin yana ɗaukar hujjoji guda uku, a, b, da c, waɗanda su ne lambobi masu kyau da ke wakiltar tsawon gefen murabba'i da gefunan murabba'in, bi da bi.\n  Yana dawowa da kirtani da ke nuna wane siffa ke da girma mafi girma: \"Alice\" idan yankin murabba'i ya fi girma, da \"Bob\" idan yankin murabba'in ya fi girma.\n\n  Misalai:\n  >>> compare_area(5, 4, 6)\n  \"Alice\"\n  >>> compare_area(7, 5, 10)\n  \"Bob\"",
      "hi": "वर्ग के क्षेत्रफल की तुलना भुजा 'a' के साथ आयत के क्षेत्रफल से करता है जिसकी भुजाएँ 'b' और 'c' हैं। \nयह फ़ंक्शन तीन आर्ग्युमेंट्स लेता है, a, b, और c, जो क्रमशः वर्ग की भुजा की लंबाई और आयत की भुजाओं का प्रतिनिधित्व करते हैं।\nयह एक स्ट्रिंग लौटाता है जो यह दर्शाता है कि किस आकृति का क्षेत्रफल बड़ा है: \"Alice\" यदि वर्ग का क्षेत्रफल बड़ा है, और \"Bob\" यदि आयत का क्षेत्रफल बड़ा है।\n\nउदाहरण:\n>>> compare_area(5, 4, 6)\n\"Alice\"\n>>> compare_area(7, 5, 10)\n\"Bob\"",
      "hu": "Összehasonlítja egy 'a' oldalhosszúságú négyzet területét egy 'b' és 'c' oldalú téglalap területével.  \nA függvény három argumentumot vesz fel, a, b és c, amelyek pozitív egész számok, és a négyzet oldalhosszát, valamint a téglalap oldalait képviselik.  \nEgy karakterláncot ad vissza, amely jelzi, hogy melyik alakzatnak nagyobb a területe: \"Alice\", ha a négyzet területe nagyobb, és \"Bob\", ha a téglalap területe nagyobb.\n\nPéldák:\n>>> compare_area(5, 4, 6)\n\"Alice\"\n>>> compare_area(7, 5, 10)\n\"Bob\""
    },
    "docstring_bertscore": {
      "sq": "0.9863423736304221",
      "hy": "0.9951309734696918",
      "bn": "0.9720697876011603",
      "bg": "0.9731876793856246",
      "zh": "0.969563270822881",
      "fr": "0.9795758310700876",
      "de": "0.9874237174247761",
      "ha": "0.9814733471001139",
      "hi": "0.9627468720369067",
      "hu": "0.986876887985787"
    }
  },
  {
    "task_id": "Ruby/45",
    "prompt": {
      "en": "# Finds M positive integers whose sum is N, such that their product is maximized.\n# The function returns an array of these integers in lexicographically smallest order.\n#\n# Args:\n#   n: A positive integer representing the sum of the integers to find.\n#   m: A positive integer representing the number of integers to find.\n#\n# Returns:\n#   An array of integers that are the lexicographically smallest set of integers\n#   whose sum is N and whose product is maximized.\n#\n# Examples:\n#   >>> max_product_partition(6, 3)\n#   [2, 2, 2]\n#   >>> max_product_partition(8, 3)\n#   [2, 3, 3]\n\n\ndef max_product_partition(n, m)",
      "sq": "# Gjen M numra të plotë pozitivë, shuma e të cilëve është N, të tillë që prodhimi i tyre është maksimal.\n# Funksioni kthen një varg të këtyre numrave në rendin më të vogël leksikografik.\n#\n# Argumentet:\n#   n: Një numër i plotë pozitiv që përfaqëson shumën e numrave për të gjetur.\n#   m: Një numër i plotë pozitiv që përfaqëson numrin e numrave për të gjetur.\n#\n# Kthen:\n#   Një varg numrash që janë grupi më i vogël leksikografik i numrave\n#   shuma e të cilëve është N dhe prodhimi i të cilëve është maksimal.\n#\n# Shembuj:\n#   >>> max_product_partition(6, 3)\n#   [2, 2, 2]\n#   >>> max_product_partition(8, 3)\n#   [2, 3, 3]\n\n\ndef max_product_partition(n, m)",
      "hy": "# Գտնում է M դրական ամբողջ թվեր, որոնց գումարը N է, այնպես, որ նրանց արտադրյալը առավելագույն լինի։\n# Ֆունկցիան վերադարձնում է այս ամբողջ թվերի զանգվածը լեքսիկոգրաֆիկորեն ամենափոքր կարգով։\n#\n# Փաստարկներ:\n#   n: Դրական ամբողջ թիվ, որը ներկայացնում է գտնելու համար ամբողջ թվերի գումարը։\n#   m: Դրական ամբողջ թիվ, որը ներկայացնում է գտնելու համար ամբողջ թվերի քանակը։\n#\n# Վերադարձնում է:\n#   Ամբողջ թվերի զանգված, որը լեքսիկոգրաֆիկորեն ամենափոքր ամբողջ թվերի հավաքածուն է,\n#   որոնց գումարը N է և արտադրյալը առավելագույն է։\n#\n# Օրինակներ:\n#   >>> max_product_partition(6, 3)\n#   [2, 2, 2]\n#   >>> max_product_partition(8, 3)\n#   [2, 3, 3]\n\n\ndef max_product_partition(n, m)",
      "bn": "# এমন M ধনাত্মক পূর্ণসংখ্যা খুঁজে বের করে যাদের যোগফল N, যাতে তাদের গুণফল সর্বাধিক হয়।\n# ফাংশনটি এই পূর্ণসংখ্যাগুলির একটি অ্যারে ফেরত দেয় যা বর্ণানুক্রমিকভাবে ক্ষুদ্রতম ক্রমে থাকে।\n#\n# আর্গুমেন্টসমূহ:\n#   n: পূর্ণসংখ্যা যা খুঁজে বের করতে হবে এমন পূর্ণসংখ্যাগুলির যোগফলকে উপস্থাপন করে।\n#   m: পূর্ণসংখ্যা যা খুঁজে বের করতে হবে এমন পূর্ণসংখ্যাগুলির সংখ্যা উপস্থাপন করে।\n#\n# রিটার্নস:\n#   পূর্ণসংখ্যাগুলির একটি অ্যারে যা বর্ণানুক্রমিকভাবে ক্ষুদ্রতম সেট যাদের যোগফল N এবং যাদের গুণফল সর্বাধিক।\n#\n# উদাহরণ:\n#   >>> max_product_partition(6, 3)\n#   [2, 2, 2]\n#   >>> max_product_partition(8, 3)\n#   [2, 3, 3]\n\n\ndef max_product_partition(n, m)",
      "bg": "# Намира M положителни цели числа, чиято сума е N, така че техният произведение да е максимално.\n# Функцията връща масив от тези числа в лексикографски най-малък ред.\n#\n# Аргументи:\n#   n: Положително цяло число, представляващо сумата на числата, които трябва да се намерят.\n#   m: Положително цяло число, представляващо броя на числата, които трябва да се намерят.\n#\n# Връща:\n#   Масив от цели числа, които са лексикографски най-малкият набор от числа,\n#   чиято сума е N и чието произведение е максимално.\n#\n# Примери:\n#   >>> max_product_partition(6, 3)\n#   [2, 2, 2]\n#   >>> max_product_partition(8, 3)\n#   [2, 3, 3]\n\n\ndef max_product_partition(n, m)",
      "zh": "# 找到M个正整数，其和为N，使得它们的乘积最大化。\n# 该函数返回这些整数的数组，按字典序最小排序。\n#\n# 参数:\n#   n: 一个正整数，表示要找到的整数的和。\n#   m: 一个正整数，表示要找到的整数的数量。\n#\n# 返回:\n#   一个整数数组，它是字典序最小的整数集合，其和为N且乘积最大化。\n#\n# 示例:\n#   >>> max_product_partition(6, 3)\n#   [2, 2, 2]\n#   >>> max_product_partition(8, 3)\n#   [2, 3, 3]\n\n\ndef max_product_partition(n, m)",
      "fr": "# Trouve M entiers positifs dont la somme est N, de sorte que leur produit soit maximisé.\n# La fonction renvoie un tableau de ces entiers dans l'ordre lexicographiquement le plus petit.\n#\n# Args:\n#   n: Un entier positif représentant la somme des entiers à trouver.\n#   m: Un entier positif représentant le nombre d'entiers à trouver.\n#\n# Returns:\n#   Un tableau d'entiers qui est l'ensemble d'entiers lexicographiquement le plus petit\n#   dont la somme est N et dont le produit est maximisé.\n#\n# Exemples:\n#   >>> max_product_partition(6, 3)\n#   [2, 2, 2]\n#   >>> max_product_partition(8, 3)\n#   [2, 3, 3]\n\n\ndef max_product_partition(n, m)",
      "de": "# Findet M positive ganze Zahlen, deren Summe N ist, sodass ihr Produkt maximiert wird.\n# Die Funktion gibt ein Array dieser Zahlen in lexikografisch kleinster Reihenfolge zurück.\n#\n# Argumente:\n#   n: Eine positive ganze Zahl, die die Summe der zu findenden Zahlen darstellt.\n#   m: Eine positive ganze Zahl, die die Anzahl der zu findenden Zahlen darstellt.\n#\n# Rückgabewert:\n#   Ein Array von ganzen Zahlen, das die lexikografisch kleinste Menge von Zahlen ist,\n#   deren Summe N ist und deren Produkt maximiert wird.\n#\n# Beispiele:\n#   >>> max_product_partition(6, 3)\n#   [2, 2, 2]\n#   >>> max_product_partition(8, 3)\n#   [2, 3, 3]\n\n\ndef max_product_partition(n, m)",
      "ha": "# Nemi lambobi masu kyau M waɗanda jimlarsu ita ce N, ta yadda samfurinsu ya fi girma.\n# Aikin yana dawo da jerin waɗannan lambobi a cikin mafi ƙarancin tsari na haruffa.\n#\n# Huɗoɗi:\n#   n: Lamba mai kyau wadda ke wakiltar jimlar lambobin da za a nema.\n#   m: Lamba mai kyau wadda ke wakiltar adadin lambobin da za a nema.\n#\n# Komawa:\n#   Jerin lambobi waɗanda su ne mafi ƙarancin saitin lambobi na haruffa\n#   waɗanda jimlarsu ita ce N kuma samfurinsu ya fi girma.\n#\n# Misalai:\n#   >>> max_product_partition(6, 3)\n#   [2, 2, 2]\n#   >>> max_product_partition(8, 3)\n#   [2, 3, 3]\n\n\ndef max_product_partition(n, m)",
      "hi": "# M धनात्मक पूर्णांक खोजता है जिनका योग N है, ताकि उनका गुणनफल अधिकतम हो।\n# फ़ंक्शन इन पूर्णांकों को वर्णानुक्रम में सबसे छोटे क्रम में एक सरणी के रूप में लौटाता है।\n#\n# तर्क:\n#   n: पूर्णांकों के योग का प्रतिनिधित्व करने वाला एक धनात्मक पूर्णांक जिसे खोजना है।\n#   m: पूर्णांकों की संख्या का प्रतिनिधित्व करने वाला एक धनात्मक पूर्णांक जिसे खोजना है।\n#\n# रिटर्न:\n#   पूर्णांकों की एक सरणी जो वर्णानुक्रम में सबसे छोटे सेट के पूर्णांक हैं\n#   जिनका योग N है और जिनका गुणनफल अधिकतम है।\n#\n# उदाहरण:\n#   >>> max_product_partition(6, 3)\n#   [2, 2, 2]\n#   >>> max_product_partition(8, 3)\n#   [2, 3, 3]\n\n\ndef max_product_partition(n, m)",
      "hu": "# Megkeresi azt az M darab pozitív egész számot, amelyek összege N, úgy, hogy a szorzatuk maximális legyen.\n# A függvény visszaadja ezeknek a számoknak a tömbjét lexikografikusan a legkisebb sorrendben.\n#\n# Argumentumok:\n#   n: Egy pozitív egész szám, amely az összegét képviseli a keresett számoknak.\n#   m: Egy pozitív egész szám, amely a keresett számok darabszámát képviseli.\n#\n# Visszatérési érték:\n#   Egy tömb egész számokkal, amelyek a lexikografikusan legkisebb számhalmazt alkotják,\n#   amelyek összege N és szorzatuk maximális.\n#\n# Példák:\n#   >>> max_product_partition(6, 3)\n#   [2, 2, 2]\n#   >>> max_product_partition(8, 3)\n#   [2, 3, 3]\n\n\ndef max_product_partition(n, m)"
    },
    "prompt_bertscore": {
      "sq": "0.9536209978106398",
      "hy": "0.9749445651058781",
      "bn": "0.9655308754574917",
      "bg": "0.96371102390645",
      "zh": "0.9626042554233236",
      "fr": "0.9931724779126878",
      "de": "0.9657503620285353",
      "ha": "0.9105668695694227",
      "hi": "0.9499826851212237",
      "hu": "0.9512960292006265"
    },
    "canonical_solution": "    # The base number each part should be at least.\n    base = n / m\n    \n    # The remainder when N is not perfectly divisible by M, \n    # indicating how many numbers should be base + 1\n    remainder = n % m\n    \n    # Initialize the result array with base values\n    result = [base] * (m - remainder)\n    \n    # Add the necessary numbers to make the sum equal to N\n    result += [base + 1] * remainder\n    \n    result\n  end",
    "instruction": {
      "en": "Write a ruby function `def max_product_partition(n, m)` to solve the following problem:\nFinds M positive integers whose sum is N, such that their product is maximized.\n The function returns an array of these integers in lexicographically smallest order.\n\n Args:\n   n: A positive integer representing the sum of the integers to find.\n   m: A positive integer representing the number of integers to find.\n\n Returns:\n   An array of integers that are the lexicographically smallest set of integers\n   whose sum is N and whose product is maximized.\n\n Examples:\n   >>> max_product_partition(6, 3)\n   [2, 2, 2]\n   >>> max_product_partition(8, 3)\n   [2, 3, 3]",
      "sq": "Shkruani një funksion ruby `def max_product_partition(n, m)` për të zgjidhur problemin në vijim:\nGjen M numra të plotë pozitivë, shuma e të cilëve është N, në mënyrë që prodhimi i tyre të jetë maksimal.\n Funksioni kthen një varg të këtyre numrave në rendin më të vogël leksikografik.\n\n Argumentet:\n   n: Një numër i plotë pozitiv që përfaqëson shumën e numrave që do të gjenden.\n   m: Një numër i plotë pozitiv që përfaqëson numrin e numrave që do të gjenden.\n\n Kthen:\n   Një varg numrash që janë grupi më i vogël leksikografik i numrave\n   shuma e të cilëve është N dhe prodhimi i të cilëve është maksimal.\n\n Shembuj:\n   >>> max_product_partition(6, 3)\n   [2, 2, 2]\n   >>> max_product_partition(8, 3)\n   [2, 3, 3]",
      "hy": "Գրեք ruby ֆունկցիա `def max_product_partition(n, m)` հետևյալ խնդիրը լուծելու համար:\nԳտնում է M դրական ամբողջ թվեր, որոնց գումարը N է, այնպես, որ նրանց արտադրյալը առավելագույն լինի։\n Ֆունկցիան վերադարձնում է այս թվերի զանգվածը լեքսիկոգրաֆիկորեն փոքրագույն կարգով։\n\n Արգումենտներ:\n   n: Դրական ամբողջ թիվ, որը ներկայացնում է գտնելու թվերի գումարը։\n   m: Դրական ամբողջ թիվ, որը ներկայացնում է գտնելու թվերի քանակը։\n\n Վերադարձնում է:\n   Ամբողջ թվերի զանգված, որոնք լեքսիկոգրաֆիկորեն փոքրագույն թվերի հավաքածուն են,\n   որոնց գումարը N է և արտադրյալը առավելագույն է։\n\n Օրինակներ:\n   >>> max_product_partition(6, 3)\n   [2, 2, 2]\n   >>> max_product_partition(8, 3)\n   [2, 3, 3]",
      "bn": "একটি রুবি ফাংশন `def max_product_partition(n, m)` লিখুন নিম্নলিখিত সমস্যার সমাধানের জন্য:\nএমটি ধনাত্মক পূর্ণসংখ্যা খুঁজে বের করুন যাদের যোগফল এন, যাতে তাদের গুণফল সর্বাধিক হয়। \nফাংশনটি এই পূর্ণসংখ্যাগুলির একটি অ্যারে ফেরত দেয় যা লেক্সিকোগ্রাফিকভাবে সবচেয়ে ছোট ক্রমে থাকে।\n\nআর্গস:\n   n: পূর্ণসংখ্যার যোগফলকে প্রতিনিধিত্বকারী একটি ধনাত্মক পূর্ণসংখ্যা।\n   m: পূর্ণসংখ্যার সংখ্যা প্রতিনিধিত্বকারী একটি ধনাত্মক পূর্ণসংখ্যা।\n\nফেরত দেয়:\n   একটি পূর্ণসংখ্যার অ্যারে যা লেক্সিকোগ্রাফিকভাবে সবচেয়ে ছোট পূর্ণসংখ্যার সেট\n   যার যোগফল এন এবং যার গুণফল সর্বাধিক।\n\nউদাহরণ:\n   >>> max_product_partition(6, 3)\n   [2, 2, 2]\n   >>> max_product_partition(8, 3)\n   [2, 3, 3]",
      "bg": "Напишете Ruby функция `def max_product_partition(n, m)`, за да решите следния проблем:\nНамира M положителни цели числа, чиято сума е N, така че техният произведение да е максимално.\nФункцията връща масив от тези числа в лексикографски най-малък ред.\n\nАргументи:\n   n: Положително цяло число, представляващо сумата на числата, които трябва да се намерят.\n   m: Положително цяло число, представляващо броя на числата, които трябва да се намерят.\n\nВръща:\n   Масив от цели числа, които са лексикографски най-малкият набор от числа,\n   чиято сума е N и чието произведение е максимално.\n\nПримери:\n   >>> max_product_partition(6, 3)\n   [2, 2, 2]\n   >>> max_product_partition(8, 3)\n   [2, 3, 3]",
      "zh": "编写一个 Ruby 函数 `def max_product_partition(n, m)` 来解决以下问题：\n找到 M 个正整数，其和为 N，使得它们的乘积最大化。  \n该函数返回一个按字典序最小顺序排列的整数数组。\n\n参数：\n  n: 一个正整数，表示要找到的整数的和。\n  m: 一个正整数，表示要找到的整数的数量。\n\n返回：\n  一个整数数组，它是按字典序最小的整数集合，其和为 N，且乘积最大化。\n\n示例：\n  >>> max_product_partition(6, 3)\n  [2, 2, 2]\n  >>> max_product_partition(8, 3)\n  [2, 3, 3]",
      "fr": "Écrire une fonction ruby `def max_product_partition(n, m)` pour résoudre le problème suivant :  \nTrouver M entiers positifs dont la somme est N, de sorte que leur produit soit maximisé.  \nLa fonction renvoie un tableau de ces entiers dans l'ordre lexicographiquement le plus petit.\n\nArgs:  \n  n: Un entier positif représentant la somme des entiers à trouver.  \n  m: Un entier positif représentant le nombre d'entiers à trouver.\n\nReturns:  \n  Un tableau d'entiers qui est l'ensemble d'entiers lexicographiquement le plus petit  \n  dont la somme est N et dont le produit est maximisé.\n\nExamples:  \n  >>> max_product_partition(6, 3)  \n  [2, 2, 2]  \n  >>> max_product_partition(8, 3)  \n  [2, 3, 3]",
      "de": "Schreiben Sie eine Ruby-Funktion `def max_product_partition(n, m)`, um das folgende Problem zu lösen:\nFindet M positive ganze Zahlen, deren Summe N ist, sodass ihr Produkt maximiert wird.\nDie Funktion gibt ein Array dieser Zahlen in lexikografisch kleinster Reihenfolge zurück.\n\nArgumente:\n  n: Eine positive ganze Zahl, die die Summe der zu findenden Zahlen darstellt.\n  m: Eine positive ganze Zahl, die die Anzahl der zu findenden Zahlen darstellt.\n\nRückgabewert:\n  Ein Array von ganzen Zahlen, das die lexikografisch kleinste Menge von Zahlen ist,\n  deren Summe N ist und deren Produkt maximiert wird.\n\nBeispiele:\n  >>> max_product_partition(6, 3)\n  [2, 2, 2]\n  >>> max_product_partition(8, 3)\n  [2, 3, 3]",
      "ha": "Rubuta aikin ruby `def max_product_partition(n, m)` don warware matsalar mai zuwa:\nNemo lambobi M masu kyau waɗanda jimlarsu ita ce N, ta yadda samfurin su ya fi girma.\n Aikin yana dawo da jerin waɗannan lambobin a cikin mafi ƙarancin tsari na lexicographically.\n\n Args:\n   n: Lamba mai kyau da ke wakiltar jimlar lambobin da za a nema.\n   m: Lamba mai kyau da ke wakiltar adadin lambobin da za a nema.\n\n Returns:\n   Jerin lambobi da suke mafi ƙarancin saitin lambobi a cikin lexicographically\n   waɗanda jimlarsu ita ce N kuma samfurin su ya fi girma.\n\n Misalai:\n   >>> max_product_partition(6, 3)\n   [2, 2, 2]\n   >>> max_product_partition(8, 3)\n   [2, 3, 3]",
      "hi": "रूबी फ़ंक्शन `def max_product_partition(n, m)` लिखें ताकि निम्नलिखित समस्या का समाधान किया जा सके:\nऐसे M धनात्मक पूर्णांक खोजें जिनका योग N हो, ताकि उनका गुणनफल अधिकतम हो।\n फ़ंक्शन इन पूर्णांकों की एक सरणी को वर्णानुक्रम में सबसे छोटे क्रम में लौटाता है।\n\nआर्ग्स:\n   n: पूर्णांकों के योग का प्रतिनिधित्व करने वाला एक धनात्मक पूर्णांक।\n   m: पूर्णांकों की संख्या का प्रतिनिधित्व करने वाला एक धनात्मक पूर्णांक।\n\nरिटर्न्स:\n   पूर्णांकों की एक सरणी जो वर्णानुक्रम में सबसे छोटे सेट के पूर्णांक हैं\n   जिनका योग N है और जिनका गुणनफल अधिकतम है।\n\nउदाहरण:\n   >>> max_product_partition(6, 3)\n   [2, 2, 2]\n   >>> max_product_partition(8, 3)\n   [2, 3, 3]",
      "hu": "Írj egy ruby függvényt `def max_product_partition(n, m)` a következő probléma megoldására:\nTalálj M pozitív egész számot, amelyek összege N, úgy, hogy a szorzatuk maximális legyen.\nA függvény visszaadja ezeknek az egész számoknak a lexiszográfiailag legkisebb sorrendjét tartalmazó tömböt.\n\nArgs:\n   n: Egy pozitív egész szám, amely az egész számok összegét jelöli, amelyeket meg kell találni.\n   m: Egy pozitív egész szám, amely az egész számok számát jelöli, amelyeket meg kell találni.\n\nReturns:\n   Egy egész számokat tartalmazó tömb, amely a lexiszográfiailag legkisebb egész számok halmaza,\n   amelyek összege N és amelyek szorzata maximális.\n\nPéldák:\n   >>> max_product_partition(6, 3)\n   [2, 2, 2]\n   >>> max_product_partition(8, 3)\n   [2, 3, 3]"
    },
    "instruction_bertscore": {
      "sq": "0.9514626800903148",
      "hy": "0.96520810108831",
      "bn": "0.9671995692885658",
      "bg": "0.9613340141366056",
      "zh": "0.9515314062021528",
      "fr": "0.9922679151574549",
      "de": "0.966500191716942",
      "ha": "0.9428383475761609",
      "hi": "0.9572992352066438",
      "hu": "0.9819725052476546"
    },
    "level": "middle",
    "test": "raise 'Test failed' unless max_product_partition(6, 3) == [2, 2, 2]\nraise 'Test failed' unless max_product_partition(8, 3) == [2, 3, 3]\nraise 'Test failed' unless max_product_partition(10, 2) == [5, 5]\nraise 'Test failed' unless max_product_partition(7, 3) == [2, 2, 3]\nraise 'Test failed' unless max_product_partition(20, 5) == [4, 4, 4, 4, 4]",
    "entry_point": "max_product_partition",
    "signature": "def max_product_partition(n, m)",
    "docstring": {
      "en": "Finds M positive integers whose sum is N, such that their product is maximized.\n The function returns an array of these integers in lexicographically smallest order.\n\n Args:\n   n: A positive integer representing the sum of the integers to find.\n   m: A positive integer representing the number of integers to find.\n\n Returns:\n   An array of integers that are the lexicographically smallest set of integers\n   whose sum is N and whose product is maximized.\n\n Examples:\n   >>> max_product_partition(6, 3)\n   [2, 2, 2]\n   >>> max_product_partition(8, 3)\n   [2, 3, 3]",
      "sq": "Gjen M numra të plotë pozitivë, shuma e të cilëve është N, në mënyrë që prodhimi i tyre të jetë maksimal.\n Funksioni kthen një varg të këtyre numrave në rendin më të vogël leksikografik.\n\n Args:\n   n: Një numër i plotë pozitiv që përfaqëson shumën e numrave për të gjetur.\n   m: Një numër i plotë pozitiv që përfaqëson numrin e numrave për të gjetur.\n\n Returns:\n   Një varg numrash që janë grupi më i vogël leksikografik i numrave\n   shuma e të cilëve është N dhe prodhimi i të cilëve është maksimal.\n\n Examples:\n   >>> max_product_partition(6, 3)\n   [2, 2, 2]\n   >>> max_product_partition(8, 3)\n   [2, 3, 3]",
      "hy": "Գտնում է M դրական ամբողջ թվեր, որոնց գումարը N է, այնպես, որ նրանց արտադրյալը առավելագույն լինի։\nՖունկցիան վերադարձնում է այս թվերի զանգվածը լեքսիկոգրաֆիկորեն ամենափոքր կարգով։\n\nԱրգումենտներ:\n  n: Դրական ամբողջ թիվ, որը ներկայացնում է գտնելու թվերի գումարը։\n  m: Դրական ամբողջ թիվ, որը ներկայացնում է գտնելու թվերի քանակը։\n\nՎերադարձնում է:\n  Ամբողջ թվերի զանգված, որը լեքսիկոգրաֆիկորեն ամենափոքր թվերի հավաքածուն է,\n  որոնց գումարը N է և որոնց արտադրյալը առավելագույն է։\n\nՕրինակներ:\n  >>> max_product_partition(6, 3)\n  [2, 2, 2]\n  >>> max_product_partition(8, 3)\n  [2, 3, 3]",
      "bn": "Mটি ধনাত্মক পূর্ণসংখ্যা খুঁজে বের করে যাদের যোগফল N, যাতে তাদের গুণফল সর্বাধিক হয়। ফাংশনটি এই পূর্ণসংখ্যাগুলির একটি অ্যারে ফেরত দেয় যা বর্ণানুক্রমিকভাবে ক্ষুদ্রতম ক্রমে থাকে।\n\nArgs:\n   n: একটি ধনাত্মক পূর্ণসংখ্যা যা খুঁজে বের করার পূর্ণসংখ্যাগুলির যোগফলকে উপস্থাপন করে।\n   m: একটি ধনাত্মক পূর্ণসংখ্যা যা খুঁজে বের করার পূর্ণসংখ্যাগুলির সংখ্যাকে উপস্থাপন করে।\n\nReturns:\n   একটি পূর্ণসংখ্যার অ্যারে যা বর্ণানুক্রমিকভাবে ক্ষুদ্রতম পূর্ণসংখ্যার সেট যাদের যোগফল N এবং যাদের গুণফল সর্বাধিক।\n\nExamples:\n   >>> max_product_partition(6, 3)\n   [2, 2, 2]\n   >>> max_product_partition(8, 3)\n   [2, 3, 3]",
      "bg": "Намира M положителни цели числа, чиято сума е N, така че техният произведение да е максимално. Функцията връща масив от тези числа в лексикографски най-малък ред.\n\nArgs:\n  n: Положително цяло число, представляващо сумата на числата, които трябва да се намерят.\n  m: Положително цяло число, представляващо броя на числата, които трябва да се намерят.\n\nReturns:\n  Масив от цели числа, които са лексикографски най-малкото множество от числа, чиято сума е N и чието произведение е максимално.\n\nExamples:\n  >>> max_product_partition(6, 3)\n  [2, 2, 2]\n  >>> max_product_partition(8, 3)\n  [2, 3, 3]",
      "zh": "找到 M 个正整数，其和为 N，使其乘积最大化。该函数返回这些整数的数组，以字典序最小的顺序排列。\n\n参数：\n  n: 一个正整数，表示要找到的整数的和。\n  m: 一个正整数，表示要找到的整数的数量。\n\n返回：\n  一个整数数组，它是字典序最小的整数集合，其和为 N，且乘积最大化。\n\n示例：\n  >>> max_product_partition(6, 3)\n  [2, 2, 2]\n  >>> max_product_partition(8, 3)\n  [2, 3, 3]",
      "fr": "Trouve M entiers positifs dont la somme est N, de sorte que leur produit soit maximisé.\nLa fonction renvoie un tableau de ces entiers dans l'ordre lexicographiquement le plus petit.\n\nArgs:\n  n: Un entier positif représentant la somme des entiers à trouver.\n  m: Un entier positif représentant le nombre d'entiers à trouver.\n\nReturns:\n  Un tableau d'entiers qui est l'ensemble d'entiers le plus petit lexicographiquement\n  dont la somme est N et dont le produit est maximisé.\n\nExamples:\n  >>> max_product_partition(6, 3)\n  [2, 2, 2]\n  >>> max_product_partition(8, 3)\n  [2, 3, 3]",
      "de": "Findet M positive ganze Zahlen, deren Summe N ist, sodass ihr Produkt maximiert wird. Die Funktion gibt ein Array dieser ganzen Zahlen in lexikografisch kleinster Reihenfolge zurück.\n\nArgs:\n   n: Eine positive ganze Zahl, die die Summe der zu findenden ganzen Zahlen darstellt.\n   m: Eine positive ganze Zahl, die die Anzahl der zu findenden ganzen Zahlen darstellt.\n\nReturns:\n   Ein Array von ganzen Zahlen, das die lexikografisch kleinste Menge von ganzen Zahlen ist, deren Summe N ist und deren Produkt maximiert wird.\n\nExamples:\n   >>> max_product_partition(6, 3)\n   [2, 2, 2]\n   >>> max_product_partition(8, 3)\n   [2, 3, 3]",
      "ha": "Nemi lambobi masu kyau M waɗanda jimlarsu ita ce N, ta yadda samfurin su ya fi girma.\n Aiki yana dawowa da jerin waɗannan lambobi a cikin mafi ƙarancin tsari na haruffa.\n\n Args:\n   n: Lamba mai kyau wadda ke wakiltar jimlar lambobin da za a nema.\n   m: Lamba mai kyau wadda ke wakiltar adadin lambobin da za a nema.\n\n Returns:\n   Jerin lambobi waɗanda su ne mafi ƙarancin saiti na lambobi\n   waɗanda jimlarsu ita ce N kuma samfurin su ya fi girma.\n\n Misalai:\n   >>> max_product_partition(6, 3)\n   [2, 2, 2]\n   >>> max_product_partition(8, 3)\n   [2, 3, 3]",
      "hi": "M धनात्मक पूर्णांक खोजता है जिनका योग N है, ताकि उनका गुणनफल अधिकतम हो। \nयह फ़ंक्शन इन पूर्णांकों की एक सरणी लौटाता है जो शब्दकोशानुसार सबसे छोटे क्रम में होते हैं।\n\nआर्ग्स:\n   n: एक धनात्मक पूर्णांक जो खोजे जाने वाले पूर्णांकों के योग का प्रतिनिधित्व करता है।\n   m: एक धनात्मक पूर्णांक जो खोजे जाने वाले पूर्णांकों की संख्या का प्रतिनिधित्व करता है।\n\nरिटर्न्स:\n   पूर्णांकों की एक सरणी जो शब्दकोशानुसार सबसे छोटे सेट के पूर्णांक हैं\n   जिनका योग N है और जिनका गुणनफल अधिकतम है।\n\nउदाहरण:\n   >>> max_product_partition(6, 3)\n   [2, 2, 2]\n   >>> max_product_partition(8, 3)\n   [2, 3, 3]",
      "hu": "Megtalálja azt az M pozitív egész számot, amelyek összege N, úgy, hogy a szorzatuk maximális legyen. A függvény visszaad egy tömböt ezekkel az egész számokkal lexikografikusan a legkisebb sorrendben.\n\nArgs:\n   n: Egy pozitív egész szám, amely az egész számok összegét jelenti, amelyeket meg kell találni.\n   m: Egy pozitív egész szám, amely az egész számok számát jelenti, amelyeket meg kell találni.\n\nReturns:\n   Egy egész számokból álló tömb, amely a lexikografikusan legkisebb egész számok halmaza, amelyek összege N és szorzatuk maximális.\n\nExamples:\n   >>> max_product_partition(6, 3)\n   [2, 2, 2]\n   >>> max_product_partition(8, 3)\n   [2, 3, 3]"
    },
    "docstring_bertscore": {
      "sq": "0.9550886776961066",
      "hy": "0.9572728173659663",
      "bn": "0.9626773514035445",
      "bg": "0.9691300579618439",
      "zh": "0.9570805431571244",
      "fr": "0.9770295882156014",
      "de": "0.9828033761315235",
      "ha": "0.8704602175523821",
      "hi": "0.9413134621409561",
      "hu": "0.9584733393889411"
    }
  },
  {
    "task_id": "Ruby/46",
    "prompt": {
      "en": "# Counts the number of characters in a given title, excluding spaces and newline characters.\n# The function takes a single argument, title, which is a string representing the title of an essay.\n# It returns the count of characters in the title, excluding any spaces and newline characters.\n#\n# Examples:\n# >>> count_chars_in_title(\"234\")\n# 3\n# >>> count_chars_in_title(\"Ca 45\")\n# 4\n# >>> count_chars_in_title(\"Hello World\\n\")\n# 10\n\ndef count_chars_in_title(title)",
      "sq": "# Numëron numrin e karaktereve në një titull të dhënë, duke përjashtuar hapësirat dhe karakteret e reja rresht.\n# Funksioni merr një argument të vetëm, title, i cili është një varg që përfaqëson titullin e një eseje.\n# Kthen numrin e karaktereve në titull, duke përjashtuar çdo hapësirë dhe karakter të ri rresht.\n#\n# Shembuj:\n# >>> count_chars_in_title(\"234\")\n# 3\n# >>> count_chars_in_title(\"Ca 45\")\n# 4\n# >>> count_chars_in_title(\"Hello World\\n\")\n# 10\n\ndef count_chars_in_title(title)",
      "hy": "# Հաշվում է տրված վերնագրի մեջ գտնվող սիմվոլների քանակը՝ բացառելով բացատներն ու նոր տողի սիմվոլները։\n# Ֆունկցիան ընդունում է մեկ արգումենտ, title, որը տող է՝ ներկայացնող շարադրանքի վերնագիրը։\n# Այն վերադարձնում է սիմվոլների քանակը վերնագրում՝ բացառելով ցանկացած բացատ և նոր տողի սիմվոլ։\n#\n# Օրինակներ:\n# >>> count_chars_in_title(\"234\")\n# 3\n# >>> count_chars_in_title(\"Ca 45\")\n# 4\n# >>> count_chars_in_title(\"Hello World\\n\")\n# 10\n\ndef count_chars_in_title(title)",
      "bn": "# প্রদত্ত শিরোনামে কতগুলি অক্ষর আছে তা গণনা করে, ফাঁকা স্থান এবং নতুন লাইন অক্ষর বাদ দিয়ে।\n# ফাংশনটি একটি একক আর্গুমেন্ট গ্রহণ করে, title, যা একটি প্রবন্ধের শিরোনামকে উপস্থাপনকারী একটি স্ট্রিং।\n# এটি শিরোনামে অক্ষরের সংখ্যা ফেরত দেয়, যেকোনো ফাঁকা স্থান এবং নতুন লাইন অক্ষর বাদ দিয়ে।\n#\n# উদাহরণ:\n# >>> count_chars_in_title(\"234\")\n# 3\n# >>> count_chars_in_title(\"Ca 45\")\n# 4\n# >>> count_chars_in_title(\"Hello World\\n\")\n# 10\n\ndef count_chars_in_title(title)",
      "bg": "# Брои броя на символите в дадено заглавие, изключвайки интервалите и символите за нов ред.\n# Функцията приема един аргумент, title, който е низ, представляващ заглавието на есе.\n# Връща броя на символите в заглавието, изключвайки всички интервали и символи за нов ред.\n#\n# Примери:\n# >>> count_chars_in_title(\"234\")\n# 3\n# >>> count_chars_in_title(\"Ca 45\")\n# 4\n# >>> count_chars_in_title(\"Hello World\\n\")\n# 10\n\ndef count_chars_in_title(title)",
      "zh": "# 计算给定标题中的字符数，不包括空格和换行符。\n# 该函数接受一个参数，title，这是一个表示文章标题的字符串。\n# 它返回标题中字符的数量，不包括任何空格和换行符。\n#\n# 示例：\n# >>> count_chars_in_title(\"234\")\n# 3\n# >>> count_chars_in_title(\"Ca 45\")\n# 4\n# >>> count_chars_in_title(\"Hello World\\n\")\n# 10\n\ndef count_chars_in_title(title)",
      "fr": "# Compte le nombre de caractères dans un titre donné, à l'exclusion des espaces et des caractères de nouvelle ligne.\n# La fonction prend un seul argument, title, qui est une chaîne représentant le titre d'un essai.\n# Elle renvoie le compte des caractères dans le titre, à l'exclusion des espaces et des caractères de nouvelle ligne.\n#\n# Exemples:\n# >>> count_chars_in_title(\"234\")\n# 3\n# >>> count_chars_in_title(\"Ca 45\")\n# 4\n# >>> count_chars_in_title(\"Hello World\\n\")\n# 10\n\ndef count_chars_in_title(title)",
      "de": "# Zählt die Anzahl der Zeichen in einem gegebenen Titel, ohne Leerzeichen und Zeilenumbrüche.\n# Die Funktion nimmt ein einzelnes Argument, title, das ein String ist, der den Titel eines Aufsatzes darstellt.\n# Sie gibt die Anzahl der Zeichen im Titel zurück, ohne Leerzeichen und Zeilenumbrüche.\n#\n# Beispiele:\n# >>> count_chars_in_title(\"234\")\n# 3\n# >>> count_chars_in_title(\"Ca 45\")\n# 4\n# >>> count_chars_in_title(\"Hello World\\n\")\n# 10\n\ndef count_chars_in_title(title)",
      "ha": "# Yana ƙididdige yawan haruffa a cikin take da aka bayar, ba tare da haɗa sarari da haruffan sabon layi ba.\n# Aikin yana ɗaukar hujja guda ɗaya, title, wanda shine kirtani da ke wakiltar taken rubutu.\n# Yana dawowa da ƙididdigar haruffa a cikin taken, ba tare da haɗa kowane sarari da haruffan sabon layi ba.\n#\n# Misalai:\n# >>> count_chars_in_title(\"234\")\n# 3\n# >>> count_chars_in_title(\"Ca 45\")\n# 4\n# >>> count_chars_in_title(\"Hello World\\n\")\n# 10\n\ndef count_chars_in_title(title)",
      "hi": "# दिए गए शीर्षक में वर्णों की संख्या गिनता है, जिसमें रिक्त स्थान और नई पंक्ति के वर्ण शामिल नहीं होते।\n# यह फ़ंक्शन एक एकल तर्क लेता है, title, जो एक निबंध के शीर्षक का प्रतिनिधित्व करने वाली स्ट्रिंग है।\n# यह शीर्षक में वर्णों की गिनती लौटाता है, जिसमें कोई रिक्त स्थान और नई पंक्ति के वर्ण शामिल नहीं होते।\n#\n# उदाहरण:\n# >>> count_chars_in_title(\"234\")\n# 3\n# >>> count_chars_in_title(\"Ca 45\")\n# 4\n# >>> count_chars_in_title(\"Hello World\\n\")\n# 10\n\ndef count_chars_in_title(title)",
      "hu": "# Megszámolja a karakterek számát egy adott címben, a szóközök és újsor karakterek kivételével.\n# A függvény egyetlen argumentumot vesz fel, a title-t, amely egy esszé címét reprezentáló sztring.\n# Visszaadja a karakterek számát a címben, a szóközök és újsor karakterek kivételével.\n#\n# Példák:\n# >>> count_chars_in_title(\"234\")\n# 3\n# >>> count_chars_in_title(\"Ca 45\")\n# 4\n# >>> count_chars_in_title(\"Hello World\\n\")\n# 10\n\ndef count_chars_in_title(title)"
    },
    "prompt_bertscore": {
      "sq": "0.9918108666506936",
      "hy": "0.9820956560838963",
      "bn": "0.9854211259231823",
      "bg": "0.9852910230236045",
      "zh": "0.9657978346896026",
      "fr": "0.9912886673789529",
      "de": "0.9713878895030674",
      "ha": "0.981001202684394",
      "hi": "0.9942125065877865",
      "hu": "0.9856674275956656"
    },
    "canonical_solution": "    title.count(\"^ \\n\")\n  end",
    "instruction": {
      "en": "Write a ruby function `def count_chars_in_title(title)` to solve the following problem:\nCounts the number of characters in a given title, excluding spaces and newline characters.\n The function takes a single argument, title, which is a string representing the title of an essay.\n It returns the count of characters in the title, excluding any spaces and newline characters.\n\n Examples:\n >>> count_chars_in_title(\"234\")\n 3\n >>> count_chars_in_title(\"Ca 45\")\n 4\n >>> count_chars_in_title(\"Hello World\\n\")\n 10",
      "sq": "Shkruani një funksion ruby `def count_chars_in_title(title)` për të zgjidhur problemin e mëposhtëm:\nNumëron numrin e karaktereve në një titull të dhënë, duke përjashtuar hapësirat dhe karakteret e rreshtave të rinj.\n Funksioni merr një argument të vetëm, title, i cili është një varg që përfaqëson titullin e një eseje.\n Ai kthen numrin e karaktereve në titull, duke përjashtuar çdo hapësirë dhe karakter të rreshtave të rinj.\n\n Shembuj:\n >>> count_chars_in_title(\"234\")\n 3\n >>> count_chars_in_title(\"Ca 45\")\n 4\n >>> count_chars_in_title(\"Hello World\\n\")\n 10",
      "hy": "Գրեք ruby ֆունկցիա `def count_chars_in_title(title)` հետևյալ խնդիրը լուծելու համար:\nՀաշվում է տրված վերնագրում գտնվող սիմվոլների քանակը՝ բացի բացատներից և նոր տողից:\nՖունկցիան ընդունում է մեկ արգումենտ, title, որը տող է, ներկայացնող շարադրանքի վերնագիրը:\nԱյն վերադարձնում է վերնագրում սիմվոլների քանակը՝ բացառելով ցանկացած բացատ և նոր տող:\n\nՕրինակներ:\n>>> count_chars_in_title(\"234\")\n3\n>>> count_chars_in_title(\"Ca 45\")\n4\n>>> count_chars_in_title(\"Hello World\\n\")\n10",
      "bn": "একটি রুবি ফাংশন `def count_chars_in_title(title)` লিখুন নিম্নলিখিত সমস্যার সমাধানের জন্য:\nপ্রদত্ত শিরোনামে কতগুলি অক্ষর আছে তা গণনা করে, ফাঁকা স্থান এবং নতুন লাইন অক্ষর বাদ দিয়ে।\n ফাংশনটি একটি একক আর্গুমেন্ট গ্রহণ করে, title, যা একটি স্ট্রিং যা একটি প্রবন্ধের শিরোনামকে উপস্থাপন করে।\n এটি শিরোনামে অক্ষরের সংখ্যা ফেরত দেয়, কোনো ফাঁকা স্থান এবং নতুন লাইন অক্ষর বাদ দিয়ে।\n\n উদাহরণ:\n >>> count_chars_in_title(\"234\")\n 3\n >>> count_chars_in_title(\"Ca 45\")\n 4\n >>> count_chars_in_title(\"Hello World\\n\")\n 10",
      "bg": "Напишете Ruby функция `def count_chars_in_title(title)` за решаване на следния проблем:\nБрои броя на символите в дадено заглавие, като изключва интервали и символи за нов ред.\nФункцията приема един аргумент, title, който е низ, представляващ заглавието на есе.\nТя връща броя на символите в заглавието, като изключва всякакви интервали и символи за нов ред.\n\nПримери:\n>>> count_chars_in_title(\"234\")\n3\n>>> count_chars_in_title(\"Ca 45\")\n4\n>>> count_chars_in_title(\"Hello World\\n\")\n10",
      "zh": "编写一个 ruby 函数 `def count_chars_in_title(title)` 来解决以下问题：\n计算给定标题中的字符数，不包括空格和换行符。\n该函数接受一个参数，title，这是一个表示文章标题的字符串。\n它返回标题中的字符数，不包括任何空格和换行符。\n\n示例：\n>>> count_chars_in_title(\"234\")\n3\n>>> count_chars_in_title(\"Ca 45\")\n4\n>>> count_chars_in_title(\"Hello World\\n\")\n10",
      "fr": "Écrire une fonction ruby `def count_chars_in_title(title)` pour résoudre le problème suivant :\nCompte le nombre de caractères dans un titre donné, en excluant les espaces et les caractères de nouvelle ligne.\nLa fonction prend un seul argument, title, qui est une chaîne représentant le titre d'un essai.\nElle renvoie le compte des caractères dans le titre, en excluant tous les espaces et les caractères de nouvelle ligne.\n\nExemples :\n>>> count_chars_in_title(\"234\")\n3\n>>> count_chars_in_title(\"Ca 45\")\n4\n>>> count_chars_in_title(\"Hello World\\n\")\n10",
      "de": "Schreiben Sie eine Ruby-Funktion `def count_chars_in_title(title)`, um das folgende Problem zu lösen:\nZählt die Anzahl der Zeichen in einem gegebenen Titel, ohne Leerzeichen und Zeilenumbrüche.\n Die Funktion nimmt ein einziges Argument, title, das ein String ist, der den Titel eines Essays darstellt.\n Sie gibt die Anzahl der Zeichen im Titel zurück, ohne Leerzeichen und Zeilenumbrüche.\n\n Beispiele:\n >>> count_chars_in_title(\"234\")\n 3\n >>> count_chars_in_title(\"Ca 45\")\n 4\n >>> count_chars_in_title(\"Hello World\\n\")\n 10",
      "ha": "Rubuta aikin ruby `def count_chars_in_title(title)` don warware matsalar mai zuwa:  \nYana ƙididdige adadin haruffa a cikin taken da aka bayar, banda sarari da haruffan sabon layi.  \nAikin yana ɗaukar hujja guda, title, wanda shine kirtani da ke wakiltar taken wani rubutu.  \nYana mayar da ƙididdigar haruffa a cikin taken, banda duk wani sarari da haruffan sabon layi.\n\nMisalai:\n >>> count_chars_in_title(\"234\")\n 3\n >>> count_chars_in_title(\"Ca 45\")\n 4\n >>> count_chars_in_title(\"Hello World\\n\")\n 10",
      "hi": "रूबी फ़ंक्शन `def count_chars_in_title(title)` लिखें ताकि निम्नलिखित समस्या का समाधान किया जा सके:\nदिए गए शीर्षक में वर्णों की संख्या गिनता है, जिसमें रिक्त स्थान और नई पंक्ति के वर्ण शामिल नहीं होते हैं।\n यह फ़ंक्शन एक एकल तर्क लेता है, title, जो एक निबंध के शीर्षक का प्रतिनिधित्व करने वाली एक स्ट्रिंग है।\n यह शीर्षक में वर्णों की गिनती लौटाता है, जिसमें कोई भी रिक्त स्थान और नई पंक्ति के वर्ण शामिल नहीं होते हैं।\n\n उदाहरण:\n >>> count_chars_in_title(\"234\")\n 3\n >>> count_chars_in_title(\"Ca 45\")\n 4\n >>> count_chars_in_title(\"Hello World\\n\")\n 10",
      "hu": "Írj egy ruby függvényt `def count_chars_in_title(title)` a következő probléma megoldására:\nMegszámolja a karakterek számát egy adott címben, a szóközök és az új sor karakterek kivételével.\n A függvény egyetlen argumentumot vesz fel, title, amely egy sztring, ami egy esszé címét jelenti.\n Visszaadja a karakterek számát a címben, a szóközök és az új sor karakterek kivételével.\n\n Példák:\n >>> count_chars_in_title(\"234\")\n 3\n >>> count_chars_in_title(\"Ca 45\")\n 4\n >>> count_chars_in_title(\"Hello World\\n\")\n 10"
    },
    "instruction_bertscore": {
      "sq": "0.9971097293255613",
      "hy": "0.9648622855949283",
      "bn": "0.9789862960991761",
      "bg": "0.9912223248316873",
      "zh": "0.9668984456309169",
      "fr": "0.99344738236004",
      "de": "0.9715267321394109",
      "ha": "0.9832105684126451",
      "hi": "0.980944394395418",
      "hu": "0.9938756294615513"
    },
    "level": "easy",
    "test": "raise 'Test failed' unless count_chars_in_title(\"234\") == 3\nraise 'Test failed' unless count_chars_in_title(\"Ca 45\") == 4\nraise 'Test failed' unless count_chars_in_title(\"Hello World\\n\") == 10\nraise 'Test failed' unless count_chars_in_title(\"Ruby Programming 101 \") == 18\nraise 'Test failed' unless count_chars_in_title(\"\\nNew Line\\n\") == 7",
    "entry_point": "count_chars_in_title",
    "signature": "def count_chars_in_title(title)",
    "docstring": {
      "en": "Counts the number of characters in a given title, excluding spaces and newline characters.\n The function takes a single argument, title, which is a string representing the title of an essay.\n It returns the count of characters in the title, excluding any spaces and newline characters.\n\n Examples:\n >>> count_chars_in_title(\"234\")\n 3\n >>> count_chars_in_title(\"Ca 45\")\n 4\n >>> count_chars_in_title(\"Hello World\\n\")\n 10",
      "sq": "Numëron numrin e karaktereve në një titull të dhënë, duke përjashtuar hapësirat dhe karakteret e rreshtave të rinj. \nFunksioni merr një argument të vetëm, title, i cili është një varg që përfaqëson titullin e një eseje. \nAi kthen numrin e karaktereve në titull, duke përjashtuar çdo hapësirë dhe karakter të rreshtave të rinj.\n\nShembuj:\n>>> count_chars_in_title(\"234\")\n3\n>>> count_chars_in_title(\"Ca 45\")\n4\n>>> count_chars_in_title(\"Hello World\\n\")\n10",
      "hy": "Հաշվում է տրված վերնագրի մեջ գտնվող սիմվոլների քանակը՝ բացառելով բացատները և նոր տողի սիմվոլները։\nՖունկցիան ընդունում է մեկ արգումենտ՝ title, որը տող է, որը ներկայացնում է շարադրանքի վերնագիրը։ \nԱյն վերադարձնում է վերնագրի սիմվոլների քանակը՝ բացառելով ցանկացած բացատ և նոր տողի սիմվոլ։\n\nՕրինակներ:\n>>> count_chars_in_title(\"234\")\n3\n>>> count_chars_in_title(\"Ca 45\")\n4\n>>> count_chars_in_title(\"Hello World\\n\")\n10",
      "bn": "প্রদত্ত শিরোনামে অক্ষরের সংখ্যা গণনা করে, ফাঁকা স্থান এবং নতুন লাইন অক্ষর বাদ দিয়ে।\nএই ফাংশনটি একটি একক আর্গুমেন্ট গ্রহণ করে, title, যা একটি প্রবন্ধের শিরোনামকে প্রতিনিধিত্বকারী একটি স্ট্রিং।\nএটি শিরোনামে অক্ষরের সংখ্যা ফেরত দেয়, যেকোনো ফাঁকা স্থান এবং নতুন লাইন অক্ষর বাদ দিয়ে।\nউদাহরণসমূহ:\n>>> count_chars_in_title(\"234\")\n3\n>>> count_chars_in_title(\"Ca 45\")\n4\n>>> count_chars_in_title(\"Hello World\\n\")\n10",
      "bg": "Брои броя на символите в дадено заглавие, изключвайки интервалите и символите за нов ред.\n Функцията приема един аргумент, title, който е низ, представляващ заглавието на есе.\n Връща броя на символите в заглавието, изключвайки всички интервали и символи за нов ред.\n\n Примери:\n >>> count_chars_in_title(\"234\")\n 3\n >>> count_chars_in_title(\"Ca 45\")\n 4\n >>> count_chars_in_title(\"Hello World\\n\")\n 10",
      "zh": "计算给定标题中的字符数量，不包括空格和换行符。\n该函数接受一个参数，title，这是一个表示文章标题的字符串。\n它返回标题中字符的数量，不包括任何空格和换行符。\n\n示例：\n>>> count_chars_in_title(\"234\")\n3\n>>> count_chars_in_title(\"Ca 45\")\n4\n>>> count_chars_in_title(\"Hello World\\n\")\n10",
      "fr": "Compte le nombre de caractères dans un titre donné, en excluant les espaces et les caractères de nouvelle ligne.\n La fonction prend un seul argument, title, qui est une chaîne de caractères représentant le titre d'un essai.\n Elle renvoie le nombre de caractères dans le titre, en excluant les espaces et les caractères de nouvelle ligne.\n\n Exemples :\n >>> count_chars_in_title(\"234\")\n 3\n >>> count_chars_in_title(\"Ca 45\")\n 4\n >>> count_chars_in_title(\"Hello World\\n\")\n 10",
      "de": "Zählt die Anzahl der Zeichen in einem gegebenen Titel, ohne Leerzeichen und Zeilenumbrüche.\n Die Funktion nimmt ein einziges Argument, title, das ein String ist, der den Titel eines Aufsatzes darstellt.\n Sie gibt die Anzahl der Zeichen im Titel zurück, ohne Leerzeichen und Zeilenumbrüche.\n\n Beispiele:\n >>> count_chars_in_title(\"234\")\n 3\n >>> count_chars_in_title(\"Ca 45\")\n 4\n >>> count_chars_in_title(\"Hello World\\n\")\n 10",
      "ha": "Yana ƙididdige adadin haruffa a cikin take da aka bayar, ban da sarari da haruffan sabon layi.\nAikin yana ɗaukar hujja guda ɗaya, title, wanda shine kirtani da ke wakiltar taken wani rubutu.\nYana dawowa da ƙididdigar haruffa a cikin taken, ban da duk wani sarari da haruffan sabon layi.\n\nExamples:\nMisalai:\n >>> count_chars_in_title(\"234\")\n 3\n >>> count_chars_in_title(\"Ca 45\")\n 4\n >>> count_chars_in_title(\"Hello World\\n\")\n 10",
      "hi": "दिए गए शीर्षक में वर्णों की संख्या की गणना करता है, जिसमें रिक्त स्थान और नई पंक्ति के वर्ण शामिल नहीं होते हैं। \nयह फ़ंक्शन एकल तर्क लेता है, title, जो एक निबंध के शीर्षक का प्रतिनिधित्व करने वाली एक स्ट्रिंग है। \nयह शीर्षक में वर्णों की गणना लौटाता है, जिसमें कोई भी रिक्त स्थान और नई पंक्ति के वर्ण शामिल नहीं होते हैं।\n\nउदाहरण:\n>>> count_chars_in_title(\"234\")\n3\n>>> count_chars_in_title(\"Ca 45\")\n4\n>>> count_chars_in_title(\"Hello World\\n\")\n10",
      "hu": "Számolja meg a karakterek számát egy adott címben, kihagyva a szóközöket és az új sor karaktereket.\n A függvény egyetlen argumentumot vesz fel, a title-t, amely egy sztring, és egy esszé címét jelenti.\n Visszaadja a karakterek számát a címben, kihagyva a szóközöket és az új sor karaktereket.\n\n Példák:\n >>> count_chars_in_title(\"234\")\n 3\n >>> count_chars_in_title(\"Ca 45\")\n 4\n >>> count_chars_in_title(\"Hello World\\n\")\n 10"
    },
    "docstring_bertscore": {
      "sq": "0.996566872494193",
      "hy": "0.9763600052011328",
      "bn": "1",
      "bg": "0.9705977378473106",
      "zh": "0.9544655741908001",
      "fr": "0.9916207773760433",
      "de": "0.9660232801720772",
      "ha": "1",
      "hi": "0.9939165473200445",
      "hu": "0.9774439311904402"
    }
  },
  {
    "task_id": "Ruby/47",
    "prompt": {
      "en": "# Counts the number of students who have enrolled in both courses A and B.\n# This function takes four arguments: n and m are the number of students enrolled in courses A and B, respectively.\n# a_n is an array of student IDs enrolled in course A, and b_m is an array of student IDs enrolled in course B.\n# The function returns the count of students who have enrolled in both courses.\n#\n# Example:\n# >>> count_common_students(5, 5, [1, 2, 3, 4, 5], [1, 3, 4, 5, 6])\n# 4\n# >>> count_common_students(3, 2, [1, 2, 3], [2, 4])\n# 1\ndef count_common_students(n, m, a_n, b_m)",
      "sq": "# Numëron numrin e studentëve që janë regjistruar në të dyja kurset A dhe B.\n# Kjo funksion merr katër argumente: n dhe m janë numri i studentëve të regjistruar në kurset A dhe B, përkatësisht.\n# a_n është një varg me ID-të e studentëve të regjistruar në kursin A, dhe b_m është një varg me ID-të e studentëve të regjistruar në kursin B.\n# Funksioni kthen numrin e studentëve që janë regjistruar në të dyja kurset.\n#\n# Shembull:\n# >>> count_common_students(5, 5, [1, 2, 3, 4, 5], [1, 3, 4, 5, 6])\n# 4\n# >>> count_common_students(3, 2, [1, 2, 3], [2, 4])\n# 1\ndef count_common_students(n, m, a_n, b_m)",
      "hy": "# Հաշվում է այն ուսանողների քանակը, ովքեր գրանցվել են և՛ A, և՛ B դասընթացներում։\n# Այս ֆունկցիան ընդունում է չորս արգումենտ՝ n և m-ը ուսանողների քանակն են, ովքեր գրանցվել են համապատասխանաբար A և B դասընթացներում։\n# a_n-ը A դասընթացում գրանցված ուսանողների ID-ների զանգվածն է, իսկ b_m-ը՝ B դասընթացում գրանցված ուսանողների ID-ների զանգվածը։\n# Ֆունկցիան վերադարձնում է այն ուսանողների քանակը, ովքեր գրանցվել են երկու դասընթացներում։\n#\n# Օրինակ:\n# >>> count_common_students(5, 5, [1, 2, 3, 4, 5], [1, 3, 4, 5, 6])\n# 4\n# >>> count_common_students(3, 2, [1, 2, 3], [2, 4])\n# 1\ndef count_common_students(n, m, a_n, b_m)",
      "bn": "# কোর্স A এবং B উভয়টিতে ভর্তি হওয়া শিক্ষার্থীদের সংখ্যা গণনা করে।\n# এই ফাংশনটি চারটি আর্গুমেন্ট নেয়: n এবং m যথাক্রমে কোর্স A এবং B তে ভর্তি হওয়া শিক্ষার্থীদের সংখ্যা।\n# a_n একটি অ্যারে যা কোর্স A তে ভর্তি হওয়া শিক্ষার্থীদের আইডি ধারণ করে, এবং b_m একটি অ্যারে যা কোর্স B তে ভর্তি হওয়া শিক্ষার্থীদের আইডি ধারণ করে।\n# ফাংশনটি উভয় কোর্সে ভর্তি হওয়া শিক্ষার্থীদের সংখ্যা প্রদান করে।\n#\n# উদাহরণ:\n# >>> count_common_students(5, 5, [1, 2, 3, 4, 5], [1, 3, 4, 5, 6])\n# 4\n# >>> count_common_students(3, 2, [1, 2, 3], [2, 4])\n# 1\ndef count_common_students(n, m, a_n, b_m)",
      "bg": "# Брои броя на студентите, които са записани и в двата курса A и B.\n# Тази функция приема четири аргумента: n и m са броят на студентите, записани в курсовете A и B, съответно.\n# a_n е масив от студентски идентификационни номера, записани в курс A, а b_m е масив от студентски идентификационни номера, записани в курс B.\n# Функцията връща броя на студентите, които са записани и в двата курса.\n#\n# Пример:\n# >>> count_common_students(5, 5, [1, 2, 3, 4, 5], [1, 3, 4, 5, 6])\n# 4\n# >>> count_common_students(3, 2, [1, 2, 3], [2, 4])\n# 1\ndef count_common_students(n, m, a_n, b_m)",
      "zh": "# 计算同时注册了课程A和课程B的学生人数。\n# 此函数接受四个参数：n和m分别是注册课程A和课程B的学生人数。\n# a_n是注册课程A的学生ID数组，b_m是注册课程B的学生ID数组。\n# 该函数返回同时注册了两个课程的学生人数。\n#\n# 示例:\n# >>> count_common_students(5, 5, [1, 2, 3, 4, 5], [1, 3, 4, 5, 6])\n# 4\n# >>> count_common_students(3, 2, [1, 2, 3], [2, 4])\n# 1\ndef count_common_students(n, m, a_n, b_m)",
      "fr": "# Compte le nombre d'étudiants qui se sont inscrits aux deux cours A et B.\n# Cette fonction prend quatre arguments : n et m sont le nombre d'étudiants inscrits aux cours A et B, respectivement.\n# a_n est un tableau d'ID d'étudiants inscrits au cours A, et b_m est un tableau d'ID d'étudiants inscrits au cours B.\n# La fonction renvoie le nombre d'étudiants qui se sont inscrits aux deux cours.\n#\n# Exemple:\n# >>> count_common_students(5, 5, [1, 2, 3, 4, 5], [1, 3, 4, 5, 6])\n# 4\n# >>> count_common_students(3, 2, [1, 2, 3], [2, 4])\n# 1\ndef count_common_students(n, m, a_n, b_m)",
      "de": "# Zählt die Anzahl der Studenten, die sich in beide Kurse A und B eingeschrieben haben.\n# Diese Funktion nimmt vier Argumente: n und m sind die Anzahl der Studenten, die in die Kurse A bzw. B eingeschrieben sind.\n# a_n ist ein Array von Studenten-IDs, die in Kurs A eingeschrieben sind, und b_m ist ein Array von Studenten-IDs, die in Kurs B eingeschrieben sind.\n# Die Funktion gibt die Anzahl der Studenten zurück, die sich in beide Kurse eingeschrieben haben.\n#\n# Beispiel:\n# >>> count_common_students(5, 5, [1, 2, 3, 4, 5], [1, 3, 4, 5, 6])\n# 4\n# >>> count_common_students(3, 2, [1, 2, 3], [2, 4])\n# 1\ndef count_common_students(n, m, a_n, b_m)",
      "ha": "# Yana ƙididdige yawan ɗaliban da suka yi rajista a duka darussa A da B.\n# Wannan aikin yana ɗaukar huɗu hujjoji: n da m su ne yawan ɗaliban da suka yi rajista a darussa A da B, bi da bi.\n# a_n tsari ne na lambobin ID na ɗalibai da suka yi rajista a darasi A, kuma b_m tsari ne na lambobin ID na ɗalibai da suka yi rajista a darasi B.\n# Aikin yana mayar da ƙididdigar ɗaliban da suka yi rajista a duka darussa.\n#\n# Misali:\n# >>> count_common_students(5, 5, [1, 2, 3, 4, 5], [1, 3, 4, 5, 6])\n# 4\n# >>> count_common_students(3, 2, [1, 2, 3], [2, 4])\n# 1\ndef count_common_students(n, m, a_n, b_m)",
      "hi": "# यह उन छात्रों की संख्या गिनता है जिन्होंने दोनों पाठ्यक्रम A और B में नामांकन किया है।\n# यह फ़ंक्शन चार तर्क लेता है: n और m क्रमशः पाठ्यक्रम A और B में नामांकित छात्रों की संख्या हैं।\n# a_n उन छात्र आईडी का एक array है जो पाठ्यक्रम A में नामांकित हैं, और b_m उन छात्र आईडी का एक array है जो पाठ्यक्रम B में नामांकित हैं।\n# फ़ंक्शन उन छात्रों की गिनती लौटाता है जिन्होंने दोनों पाठ्यक्रमों में नामांकन किया है।\n#\n# उदाहरण:\n# >>> count_common_students(5, 5, [1, 2, 3, 4, 5], [1, 3, 4, 5, 6])\n# 4\n# >>> count_common_students(3, 2, [1, 2, 3], [2, 4])\n# 1\ndef count_common_students(n, m, a_n, b_m)",
      "hu": "# Megszámolja azon diákok számát, akik beiratkoztak mindkét A és B kurzusra.\n# Ez a függvény négy argumentumot vesz át: n és m az A és B kurzusokra beiratkozott diákok száma.\n# a_n egy tömb az A kurzusra beiratkozott diákok azonosítóival, b_m pedig egy tömb a B kurzusra beiratkozott diákok azonosítóival.\n# A függvény visszaadja azon diákok számát, akik mindkét kurzusra beiratkoztak.\n#\n# Példa:\n# >>> count_common_students(5, 5, [1, 2, 3, 4, 5], [1, 3, 4, 5, 6])\n# 4\n# >>> count_common_students(3, 2, [1, 2, 3], [2, 4])\n# 1\ndef count_common_students(n, m, a_n, b_m)"
    },
    "prompt_bertscore": {
      "sq": "0.9726325074706321",
      "hy": "0.982293690573788",
      "bn": "0.976953512779665",
      "bg": "0.9953973368106596",
      "zh": "0.9716961638544336",
      "fr": "0.9979769495691596",
      "de": "0.9953973368106596",
      "ha": "0.9577880645743707",
      "hi": "0.9878869234733494",
      "hu": "0.9742982218459907"
    },
    "canonical_solution": "    # Using the '&' operator to find the intersection of the two arrays\n    common_students = a_n & b_m\n    \n    # Returning the count of common students\n    common_students.count\n  end",
    "instruction": {
      "en": "Write a ruby function `def count_common_students(n, m, a_n, b_m)` to solve the following problem:\nCounts the number of students who have enrolled in both courses A and B.\n This function takes four arguments: n and m are the number of students enrolled in courses A and B, respectively.\n a_n is an array of student IDs enrolled in course A, and b_m is an array of student IDs enrolled in course B.\n The function returns the count of students who have enrolled in both courses.\n\n Example:\n >>> count_common_students(5, 5, [1, 2, 3, 4, 5], [1, 3, 4, 5, 6])\n 4\n >>> count_common_students(3, 2, [1, 2, 3], [2, 4])\n 1",
      "sq": "Shkruani një funksion ruby `def count_common_students(n, m, a_n, b_m)` për të zgjidhur problemin e mëposhtëm:\nNumëron numrin e studentëve që janë regjistruar në të dyja kurset A dhe B.\n Ky funksion merr katër argumente: n dhe m janë numri i studentëve të regjistruar në kurset A dhe B, përkatësisht.\n a_n është një varg me ID-të e studentëve të regjistruar në kursin A, dhe b_m është një varg me ID-të e studentëve të regjistruar në kursin B.\n Funksioni kthen numrin e studentëve që janë regjistruar në të dyja kurset.\n\n Shembull:\n >>> count_common_students(5, 5, [1, 2, 3, 4, 5], [1, 3, 4, 5, 6])\n 4\n >>> count_common_students(3, 2, [1, 2, 3], [2, 4])\n 1",
      "hy": "Գրեք ruby ֆունկցիա `def count_common_students(n, m, a_n, b_m)` հետևյալ խնդիրը լուծելու համար:\nՀաշվում է այն ուսանողների քանակը, ովքեր գրանցվել են և՛ A, և՛ B դասընթացներում:\nԱյս ֆունկցիան ընդունում է չորս արգումենտ՝ n և m, որոնք համապատասխանաբար A և B դասընթացներում գրանցված ուսանողների քանակներն են:\na_n-ը A դասընթացում գրանցված ուսանողների ID-ների զանգվածն է, իսկ b_m-ը՝ B դասընթացում գրանցված ուսանողների ID-ների զանգվածը:\nՖունկցիան վերադարձնում է այն ուսանողների քանակը, ովքեր գրանցվել են երկու դասընթացներում:\n\nՕրինակ:\n>>> count_common_students(5, 5, [1, 2, 3, 4, 5], [1, 3, 4, 5, 6])\n4\n>>> count_common_students(3, 2, [1, 2, 3], [2, 4])\n1",
      "bn": "একটি রুবি ফাংশন `def count_common_students(n, m, a_n, b_m)` লিখুন নিম্নলিখিত সমস্যার সমাধানের জন্য:\nগণনা করে কতজন শিক্ষার্থী উভয় কোর্স A এবং B-তে ভর্তি হয়েছে।\nএই ফাংশনটি চারটি আর্গুমেন্ট নেয়: n এবং m যথাক্রমে কোর্স A এবং B-তে ভর্তি শিক্ষার্থীদের সংখ্যা।\na_n একটি অ্যারের মধ্যে কোর্স A-তে ভর্তি শিক্ষার্থীদের আইডি এবং b_m একটি অ্যারের মধ্যে কোর্স B-তে ভর্তি শিক্ষার্থীদের আইডি।\nফাংশনটি সেই শিক্ষার্থীদের সংখ্যা ফেরত দেয় যারা উভয় কোর্সে ভর্তি হয়েছে।\n\nউদাহরণ:\n>>> count_common_students(5, 5, [1, 2, 3, 4, 5], [1, 3, 4, 5, 6])\n4\n>>> count_common_students(3, 2, [1, 2, 3], [2, 4])\n1",
      "bg": "Напишете функция на Ruby `def count_common_students(n, m, a_n, b_m)` за решаване на следния проблем:\nБрои броя на студентите, които са записани и в двата курса A и B.\n Тази функция приема четири аргумента: n и m са броят на студентите, записани в курсове A и B, съответно.\n a_n е масив от идентификационни номера на студенти, записани в курс A, а b_m е масив от идентификационни номера на студенти, записани в курс B.\n Функцията връща броя на студентите, които са записани и в двата курса.\n\n Пример:\n >>> count_common_students(5, 5, [1, 2, 3, 4, 5], [1, 3, 4, 5, 6])\n 4\n >>> count_common_students(3, 2, [1, 2, 3], [2, 4])\n 1",
      "zh": "编写一个 ruby 函数 `def count_common_students(n, m, a_n, b_m)` 来解决以下问题：\n计算同时注册了课程 A 和课程 B 的学生人数。\n这个函数接收四个参数：n 和 m 分别是注册课程 A 和课程 B 的学生人数。\na_n 是注册课程 A 的学生 ID 数组，b_m 是注册课程 B 的学生 ID 数组。\n函数返回同时注册了两个课程的学生人数。\n\n示例：\n>>> count_common_students(5, 5, [1, 2, 3, 4, 5], [1, 3, 4, 5, 6])\n4\n>>> count_common_students(3, 2, [1, 2, 3], [2, 4])\n1",
      "fr": "Écrire une fonction ruby `def count_common_students(n, m, a_n, b_m)` pour résoudre le problème suivant :\nCompte le nombre d'étudiants qui se sont inscrits aux deux cours A et B.\nCette fonction prend quatre arguments : n et m sont le nombre d'étudiants inscrits respectivement aux cours A et B.\na_n est un tableau d'IDs d'étudiants inscrits au cours A, et b_m est un tableau d'IDs d'étudiants inscrits au cours B.\nLa fonction renvoie le nombre d'étudiants qui se sont inscrits aux deux cours.\n\nExemple :\n>>> count_common_students(5, 5, [1, 2, 3, 4, 5], [1, 3, 4, 5, 6])\n4\n>>> count_common_students(3, 2, [1, 2, 3], [2, 4])\n1",
      "de": "Schreiben Sie eine Ruby-Funktion `def count_common_students(n, m, a_n, b_m)`, um das folgende Problem zu lösen:\nZählt die Anzahl der Studenten, die sich sowohl für Kurs A als auch für Kurs B eingeschrieben haben.\n Diese Funktion nimmt vier Argumente entgegen: n und m sind die Anzahl der Studenten, die in die Kurse A bzw. B eingeschrieben sind.\n a_n ist ein Array von Studenten-IDs, die im Kurs A eingeschrieben sind, und b_m ist ein Array von Studenten-IDs, die im Kurs B eingeschrieben sind.\n Die Funktion gibt die Anzahl der Studenten zurück, die sich in beide Kurse eingeschrieben haben.\n\n Beispiel:\n >>> count_common_students(5, 5, [1, 2, 3, 4, 5], [1, 3, 4, 5, 6])\n 4\n >>> count_common_students(3, 2, [1, 2, 3], [2, 4])\n 1",
      "ha": "Rubuta aikin ruby `def count_common_students(n, m, a_n, b_m)` don warware matsalar mai zuwa:\nYana ƙidaya yawan ɗaliban da suka yi rijista a cikin duka darussan A da B.\n Wannan aikin yana ɗaukar hujjoji guda huɗu: n da m sune yawan ɗaliban da suka yi rijista a cikin darussan A da B, bi da bi.\n a_n tsari ne na ID ɗin ɗalibai da suka yi rijista a cikin darasi A, kuma b_m tsari ne na ID ɗin ɗalibai da suka yi rijista a cikin darasi B.\n Aikin yana dawo da ƙidayar ɗaliban da suka yi rijista a cikin duka darussan.\n\n Misali:\n >>> count_common_students(5, 5, [1, 2, 3, 4, 5], [1, 3, 4, 5, 6])\n 4\n >>> count_common_students(3, 2, [1, 2, 3], [2, 4])\n 1",
      "hi": "रूबी फ़ंक्शन `def count_common_students(n, m, a_n, b_m)` लिखें ताकि निम्नलिखित समस्या का समाधान किया जा सके:\nगणना करें कि कितने छात्र दोनों पाठ्यक्रम A और B में नामांकित हैं।\n यह फ़ंक्शन चार तर्क लेता है: n और m क्रमशः पाठ्यक्रम A और B में नामांकित छात्रों की संख्या हैं।\n a_n पाठ्यक्रम A में नामांकित छात्र आईडी की एक श्रृंखला है, और b_m पाठ्यक्रम B में नामांकित छात्र आईडी की एक श्रृंखला है।\n फ़ंक्शन उन छात्रों की गिनती लौटाता है जो दोनों पाठ्यक्रमों में नामांकित हैं।\n\n उदाहरण:\n >>> count_common_students(5, 5, [1, 2, 3, 4, 5], [1, 3, 4, 5, 6])\n 4\n >>> count_common_students(3, 2, [1, 2, 3], [2, 4])\n 1",
      "hu": "Írj egy ruby függvényt `def count_common_students(n, m, a_n, b_m)` a következő probléma megoldására:\nSzámolja meg azoknak a diákoknak a számát, akik mindkét A és B kurzusra beiratkoztak.\n Ez a függvény négy argumentumot vesz fel: n és m az A és B kurzusokra beiratkozott diákok száma.\n a_n egy tömb az A kurzusra beiratkozott diákok azonosítóival, és b_m egy tömb a B kurzusra beiratkozott diákok azonosítóival.\n A függvény visszaadja azoknak a diákoknak a számát, akik mindkét kurzusra beiratkoztak.\n\n Példa:\n >>> count_common_students(5, 5, [1, 2, 3, 4, 5], [1, 3, 4, 5, 6])\n 4\n >>> count_common_students(3, 2, [1, 2, 3], [2, 4])\n 1"
    },
    "instruction_bertscore": {
      "sq": "0.9771606842670845",
      "hy": "0.9846077345128444",
      "bn": "0.9777428699138977",
      "bg": "0.9944246438347317",
      "zh": "0.9635030578975066",
      "fr": "0.9905223513689203",
      "de": "0.9822901152269293",
      "ha": "0.9701204290416838",
      "hi": "0.9610773836843085",
      "hu": "0.9782920829174592"
    },
    "level": "easy",
    "test": "raise 'Test failed' unless count_common_students(5, 5, [1, 2, 3, 4, 5], [1, 3, 4, 5, 6]) == 4\nraise 'Test failed' unless count_common_students(3, 2, [1, 2, 3], [2, 4]) == 1\nraise 'Test failed' unless count_common_students(4, 4, [7, 8, 9, 10], [10, 11, 12, 13]) == 1\nraise 'Test failed' unless count_common_students(2, 3, [14, 15], [15, 16, 17]) == 1\nraise 'Test failed' unless count_common_students(6, 5, [18, 19, 20, 21, 22, 23], [20, 21, 24, 25, 26]) == 2",
    "entry_point": "count_common_students",
    "signature": "def count_common_students(n, m, a_n, b_m)",
    "docstring": {
      "en": "Counts the number of students who have enrolled in both courses A and B.\n This function takes four arguments: n and m are the number of students enrolled in courses A and B, respectively.\n a_n is an array of student IDs enrolled in course A, and b_m is an array of student IDs enrolled in course B.\n The function returns the count of students who have enrolled in both courses.\n\n Example:\n >>> count_common_students(5, 5, [1, 2, 3, 4, 5], [1, 3, 4, 5, 6])\n 4\n >>> count_common_students(3, 2, [1, 2, 3], [2, 4])\n 1",
      "sq": "Numëron numrin e studentëve që janë regjistruar në të dy kurset A dhe B. Kjo funksion merr katër argumente: n dhe m janë numri i studentëve të regjistruar në kurset A dhe B, përkatësisht. a_n është një varg i ID-ve të studentëve të regjistruar në kursin A, dhe b_m është një varg i ID-ve të studentëve të regjistruar në kursin B. Funksioni kthen numrin e studentëve që janë regjistruar në të dy kurset.\n\nShembull:\n>>> count_common_students(5, 5, [1, 2, 3, 4, 5], [1, 3, 4, 5, 6])\n4\n>>> count_common_students(3, 2, [1, 2, 3], [2, 4])\n1",
      "hy": "Հաշվում է այն ուսանողների քանակը, ովքեր գրանցվել են ինչպես A, այնպես էլ B դասընթացներում:\n Այս ֆունկցիան ընդունում է չորս արգումենտ՝ n և m-ը համապատասխանաբար A և B դասընթացներում գրանցված ուսանողների քանակն են:\n a_n-ը A դասընթացում գրանցված ուսանողների ID-ների զանգված է, իսկ b_m-ը՝ B դասընթացում գրանցված ուսանողների ID-ների զանգված:\n Ֆունկցիան վերադարձնում է այն ուսանողների քանակը, ովքեր գրանցվել են երկու դասընթացներում:\n\n Օրինակ:\n >>> count_common_students(5, 5, [1, 2, 3, 4, 5], [1, 3, 4, 5, 6])\n 4\n >>> count_common_students(3, 2, [1, 2, 3], [2, 4])\n 1",
      "bn": "কোর্স A এবং B উভয়টিতে ভর্তি হওয়া শিক্ষার্থীদের সংখ্যা গণনা করে।\nএই ফাংশনটি চারটি আর্গুমেন্ট নেয়: n এবং m যথাক্রমে কোর্স A এবং B-তে ভর্তি হওয়া শিক্ষার্থীদের সংখ্যা।  \na_n হল কোর্স A-তে ভর্তি হওয়া শিক্ষার্থীদের আইডির একটি অ্যারে, এবং b_m হল কোর্স B-তে ভর্তি হওয়া শিক্ষার্থীদের আইডির একটি অ্যারে।  \nফাংশনটি উভয় কোর্সে ভর্তি হওয়া শিক্ষার্থীদের সংখ্যা প্রদান করে।\n\nউদাহরণ:\n>>> count_common_students(5, 5, [1, 2, 3, 4, 5], [1, 3, 4, 5, 6])\n4\n>>> count_common_students(3, 2, [1, 2, 3], [2, 4])\n1",
      "bg": "Брои броя на студентите, които са записани и в двата курса A и B. \nТази функция приема четири аргумента: n и m са броят на студентите, записани в курсовете A и B, съответно. \na_n е масив от студентски идентификатори, записани в курс A, а b_m е масив от студентски идентификатори, записани в курс B. \nФункцията връща броя на студентите, които са записани и в двата курса.\n\nПример:\n>>> count_common_students(5, 5, [1, 2, 3, 4, 5], [1, 3, 4, 5, 6])\n4\n>>> count_common_students(3, 2, [1, 2, 3], [2, 4])\n1",
      "zh": "计算同时注册了课程A和课程B的学生人数。\n此函数接受四个参数：n和m分别是注册课程A和课程B的学生人数。  \na_n是注册课程A的学生ID数组，b_m是注册课程B的学生ID数组。  \n该函数返回同时注册了两个课程的学生人数。\n\n示例：\n>>> count_common_students(5, 5, [1, 2, 3, 4, 5], [1, 3, 4, 5, 6])\n4\n>>> count_common_students(3, 2, [1, 2, 3], [2, 4])\n1",
      "fr": "Compte le nombre d'étudiants qui se sont inscrits aux deux cours A et B.\n Cette fonction prend quatre arguments : n et m sont le nombre d'étudiants inscrits aux cours A et B, respectivement.\n a_n est un tableau d'ID d'étudiants inscrits au cours A, et b_m est un tableau d'ID d'étudiants inscrits au cours B.\n La fonction renvoie le nombre d'étudiants qui se sont inscrits aux deux cours.\n\n Exemple:\n >>> count_common_students(5, 5, [1, 2, 3, 4, 5], [1, 3, 4, 5, 6])\n 4\n >>> count_common_students(3, 2, [1, 2, 3], [2, 4])\n 1",
      "de": "Zählt die Anzahl der Studenten, die sich sowohl in Kurs A als auch in Kurs B eingeschrieben haben.\n Diese Funktion nimmt vier Argumente entgegen: n und m sind die Anzahl der Studenten, die sich in die Kurse A bzw. B eingeschrieben haben.\n a_n ist ein Array von Studenten-IDs, die in Kurs A eingeschrieben sind, und b_m ist ein Array von Studenten-IDs, die in Kurs B eingeschrieben sind.\n Die Funktion gibt die Anzahl der Studenten zurück, die sich in beide Kurse eingeschrieben haben.\n\n Beispiel:\n >>> count_common_students(5, 5, [1, 2, 3, 4, 5], [1, 3, 4, 5, 6])\n 4\n >>> count_common_students(3, 2, [1, 2, 3], [2, 4])\n 1",
      "ha": "Yana ƙidaya yawan ɗaliban da suka yi rajista a duka darussa A da B. \nWannan aikin yana ɗaukar huɗu huɗu: n da m suna nufin yawan ɗaliban da suka yi rajista a darussa A da B, bi da bi. \na_n tsari ne na lambobin ID ɗalibai da suka yi rajista a darasi A, kuma b_m tsari ne na lambobin ID ɗalibai da suka yi rajista a darasi B. \nAikin yana mayar da ƙidayar ɗaliban da suka yi rajista a duka darussa.\n\nMisali:\n>>> count_common_students(5, 5, [1, 2, 3, 4, 5], [1, 3, 4, 5, 6])\n4\n>>> count_common_students(3, 2, [1, 2, 3], [2, 4])\n1",
      "hi": "दोनों पाठ्यक्रम A और B में नामांकित छात्रों की संख्या गिनता है।\nयह फ़ंक्शन चार तर्क लेता है: n और m क्रमशः पाठ्यक्रम A और B में नामांकित छात्रों की संख्या हैं।\na_n पाठ्यक्रम A में नामांकित छात्र आईडी की एक array है, और b_m पाठ्यक्रम B में नामांकित छात्र आईडी की एक array है।\nफ़ंक्शन उन छात्रों की संख्या लौटाता है जो दोनों पाठ्यक्रमों में नामांकित हैं।\n\nउदाहरण:\n>>> count_common_students(5, 5, [1, 2, 3, 4, 5], [1, 3, 4, 5, 6])\n4\n>>> count_common_students(3, 2, [1, 2, 3], [2, 4])\n1",
      "hu": "Számolja meg azon diákok számát, akik mindkét kurzusra, A-ra és B-re beiratkoztak.\n Ez a függvény négy argumentumot vesz fel: n és m a kurzusokra A és B beiratkozott diákok száma.\n a_n egy tömb, amely az A kurzusra beiratkozott diákok azonosítóit tartalmazza, és b_m egy tömb, amely a B kurzusra beiratkozott diákok azonosítóit tartalmazza.\n A függvény visszaadja azon diákok számát, akik mindkét kurzusra beiratkoztak.\n\n Példa:\n >>> count_common_students(5, 5, [1, 2, 3, 4, 5], [1, 3, 4, 5, 6])\n 4\n >>> count_common_students(3, 2, [1, 2, 3], [2, 4])\n 1"
    },
    "docstring_bertscore": {
      "sq": "0.994375383500235",
      "hy": "0.9976470245062607",
      "bn": "0.982937451638722",
      "bg": "0.994375383500235",
      "zh": "0.9524047839875632",
      "fr": "0.9920251888318303",
      "de": "0.9839584117972414",
      "ha": "0.9470072020133211",
      "hi": "0.9852806942437906",
      "hu": "0.9663561846906916"
    }
  },
  {
    "task_id": "Ruby/48",
    "prompt": {
      "en": "# Calculates the total earnings of Deliv-e-droid based on the number of successfully delivered\n# and failed deliveries. For each successful delivery, Deliv-e-droid earns 50 units of money,\n# and for each failed delivery, it loses 10 units. If the number of successful deliveries is\n# greater than the number of failed ones, Deliv-e-droid receives a bonus of 500 units.\n#\n# Arguments:\n# - delivered: Integer representing the number of successfully delivered packages (0 <= delivered <= 100).\n# - failed: Integer representing the number of failed deliveries (0 <= failed <= 100).\n#\n# Returns:\n# - Integer: The total earnings of Deliv-e-droid, which can be negative if the losses outweigh the gains.\n#\n# Examples:\n# >>> calculate_droid_earnings(5, 2)\n# 730\n# >>> calculate_droid_earnings(0, 10)\n# -100\n\ndef calculate_droid_earnings(delivered, failed)",
      "sq": "# Llogarit fitimet totale të Deliv-e-droid bazuar në numrin e dorëzimeve të suksesshme\n# dhe dështimeve. Për çdo dorëzim të suksesshëm, Deliv-e-droid fiton 50 njësi parash,\n# dhe për çdo dështim, humbet 10 njësi. Nëse numri i dorëzimeve të suksesshme është\n# më i madh se numri i dështimeve, Deliv-e-droid merr një bonus prej 500 njësish.\n#\n# Argumentet:\n# - delivered: Numër i plotë që përfaqëson numrin e pakove të dorëzuara me sukses (0 <= delivered <= 100).\n# - failed: Numër i plotë që përfaqëson numrin e dështimeve të dorëzimeve (0 <= failed <= 100).\n#\n# Kthen:\n# - Numër i plotë: Fitimet totale të Deliv-e-droid, të cilat mund të jenë negative nëse humbjet tejkalojnë fitimet.\n#\n# Shembuj:\n# >>> calculate_droid_earnings(5, 2)\n# 730\n# >>> calculate_droid_earnings(0, 10)\n# -100\n\ndef calculate_droid_earnings(delivered, failed)",
      "hy": "# Հաշվում է Deliv-e-droid-ի ընդհանուր եկամուտը՝ հիմնված հաջողությամբ առաքված\n# և ձախողված առաքումների քանակի վրա։ Յուրաքանչյուր հաջող առաքման համար Deliv-e-droid-ը վաստակում է 50 միավոր գումար,\n# և յուրաքանչյուր ձախողված առաքման համար կորցնում է 10 միավոր։ Եթե հաջող առաքումների քանակը\n# մեծ է ձախողվածների քանակից, Deliv-e-droid-ը ստանում է 500 միավոր բոնուս։\n#\n# Փոփոխականներ:\n# - delivered: Integer, որը ներկայացնում է հաջողությամբ առաքված փաթեթների քանակը (0 <= delivered <= 100):\n# - failed: Integer, որը ներկայացնում է ձախողված առաքումների քանակը (0 <= failed <= 100):\n#\n# Վերադարձնում է:\n# - Integer: Deliv-e-droid-ի ընդհանուր եկամուտը, որը կարող է լինել բացասական, եթե կորուստները գերազանցում են շահույթները։\n#\n# Օրինակներ:\n# >>> calculate_droid_earnings(5, 2)\n# 730\n# >>> calculate_droid_earnings(0, 10)\n# -100\n\ndef calculate_droid_earnings(delivered, failed)",
      "bn": "# Deliv-e-droid এর মোট উপার্জন গণনা করে সফলভাবে বিতরণ করা এবং ব্যর্থ বিতরণের সংখ্যার উপর ভিত্তি করে।\n# প্রতিটি সফল বিতরণের জন্য, Deliv-e-droid 50 ইউনিট অর্থ উপার্জন করে,\n# এবং প্রতিটি ব্যর্থ বিতরণের জন্য, এটি 10 ইউনিট হারায়। যদি সফল বিতরণের সংখ্যা\n# ব্যর্থগুলোর চেয়ে বেশি হয়, Deliv-e-droid 500 ইউনিট বোনাস পায়।\n#\n# আর্গুমেন্টসমূহ:\n# - delivered: সফলভাবে বিতরণ করা প্যাকেজের সংখ্যা নির্দেশকারী পূর্ণসংখ্যা (0 <= delivered <= 100)।\n# - failed: ব্যর্থ বিতরণের সংখ্যা নির্দেশকারী পূর্ণসংখ্যা (0 <= failed <= 100)।\n#\n# রিটার্নস:\n# - পূর্ণসংখ্যা: Deliv-e-droid এর মোট উপার্জন, যা নেতিবাচক হতে পারে যদি ক্ষতি লাভের চেয়ে বেশি হয়।\n#\n# উদাহরণসমূহ:\n# >>> calculate_droid_earnings(5, 2)\n# 730\n# >>> calculate_droid_earnings(0, 10)\n# -100\n\ndef calculate_droid_earnings(delivered, failed)",
      "bg": "# Изчислява общите приходи на Deliv-e-droid въз основа на броя на успешно доставените\n# и неуспешните доставки. За всяка успешна доставка Deliv-e-droid печели 50 единици пари,\n# а за всяка неуспешна доставка губи 10 единици. Ако броят на успешните доставки е\n# по-голям от броя на неуспешните, Deliv-e-droid получава бонус от 500 единици.\n#\n# Аргументи:\n# - delivered: Цяло число, представляващо броя на успешно доставените пакети (0 <= delivered <= 100).\n# - failed: Цяло число, представляващо броя на неуспешните доставки (0 <= failed <= 100).\n#\n# Връща:\n# - Цяло число: Общите приходи на Deliv-e-droid, които могат да бъдат отрицателни, ако загубите надвишават печалбите.\n#\n# Примери:\n# >>> calculate_droid_earnings(5, 2)\n# 730\n# >>> calculate_droid_earnings(0, 10)\n# -100\n\ndef calculate_droid_earnings(delivered, failed)",
      "zh": "# 计算Deliv-e-droid的总收入，基于成功交付和失败交付的数量。\n# 每次成功交付，Deliv-e-droid赚取50个单位的金钱，\n# 每次失败交付，它损失10个单位。如果成功交付的数量\n# 大于失败的数量，Deliv-e-droid会获得500个单位的奖金。\n#\n# 参数：\n# - delivered: 表示成功交付包裹数量的整数 (0 <= delivered <= 100)。\n# - failed: 表示失败交付数量的整数 (0 <= failed <= 100)。\n#\n# 返回：\n# - 整数: Deliv-e-droid的总收入，如果损失超过收益，可能为负数。\n#\n# 示例：\n# >>> calculate_droid_earnings(5, 2)\n# 730\n# >>> calculate_droid_earnings(0, 10)\n# -100\n\ndef calculate_droid_earnings(delivered, failed)",
      "fr": "# Calcule les gains totaux de Deliv-e-droid en fonction du nombre de livraisons réussies\n# et de livraisons échouées. Pour chaque livraison réussie, Deliv-e-droid gagne 50 unités d'argent,\n# et pour chaque livraison échouée, il perd 10 unités. Si le nombre de livraisons réussies est\n# supérieur au nombre de livraisons échouées, Deliv-e-droid reçoit un bonus de 500 unités.\n#\n# Arguments:\n# - delivered: Entier représentant le nombre de colis livrés avec succès (0 <= delivered <= 100).\n# - failed: Entier représentant le nombre de livraisons échouées (0 <= failed <= 100).\n#\n# Renvoie:\n# - Entier: Les gains totaux de Deliv-e-droid, qui peuvent être négatifs si les pertes dépassent les gains.\n#\n# Exemples:\n# >>> calculate_droid_earnings(5, 2)\n# 730\n# >>> calculate_droid_earnings(0, 10)\n# -100\n\ndef calculate_droid_earnings(delivered, failed)",
      "de": "# Berechnet die Gesamteinnahmen von Deliv-e-droid basierend auf der Anzahl der erfolgreich zugestellten\n# und fehlgeschlagenen Lieferungen. Für jede erfolgreiche Lieferung verdient Deliv-e-droid 50 Geldeinheiten,\n# und für jede fehlgeschlagene Lieferung verliert es 10 Einheiten. Wenn die Anzahl der erfolgreichen Lieferungen\n# größer ist als die der fehlgeschlagenen, erhält Deliv-e-droid einen Bonus von 500 Einheiten.\n#\n# Argumente:\n# - delivered: Ganzzahl, die die Anzahl der erfolgreich zugestellten Pakete darstellt (0 <= delivered <= 100).\n# - failed: Ganzzahl, die die Anzahl der fehlgeschlagenen Lieferungen darstellt (0 <= failed <= 100).\n#\n# Rückgabewert:\n# - Ganzzahl: Die Gesamteinnahmen von Deliv-e-droid, die negativ sein können, wenn die Verluste die Gewinne überwiegen.\n#\n# Beispiele:\n# >>> calculate_droid_earnings(5, 2)\n# 730\n# >>> calculate_droid_earnings(0, 10)\n# -100\n\ndef calculate_droid_earnings(delivered, failed)",
      "ha": "# Lissafin jimillar kudin shiga na Deliv-e-droid bisa ga adadin isar da aka yi nasara\n# da kuma isar da aka kasa. Don kowane isarwa da aka yi nasara, Deliv-e-droid yana samun 50 raka'a na kudi,\n# kuma don kowane isarwa da aka kasa, yana rasa 10 raka'a. Idan adadin isarwa da aka yi nasara ya\n# fi na wadanda aka kasa, Deliv-e-droid yana samun karin 500 raka'a.\n#\n# Huɗa:\n# - delivered: Lamba mai nuna adadin fakitoci da aka isar da nasara (0 <= delivered <= 100).\n# - failed: Lamba mai nuna adadin isar da aka kasa (0 <= failed <= 100).\n#\n# Komawa:\n# - Lamba: Jimillar kudin shiga na Deliv-e-droid, wanda zai iya zama mara kyau idan asarar ta fi riba.\n#\n# Misalai:\n# >>> calculate_droid_earnings(5, 2)\n# 730\n# >>> calculate_droid_earnings(0, 10)\n# -100\n\ndef calculate_droid_earnings(delivered, failed)",
      "hi": "# Deliv-e-droid की कुल कमाई की गणना करता है जो सफलतापूर्वक वितरित और असफल डिलीवरी की संख्या पर आधारित है।\n# प्रत्येक सफल डिलीवरी के लिए, Deliv-e-droid 50 यूनिट धन कमाता है, और प्रत्येक असफल डिलीवरी के लिए, यह 10 यूनिट खोता है।\n# यदि सफल डिलीवरी की संख्या असफल डिलीवरी की संख्या से अधिक है, तो Deliv-e-droid को 500 यूनिट का बोनस मिलता है।\n#\n# तर्क:\n# - delivered: सफलतापूर्वक वितरित पैकेजों की संख्या का प्रतिनिधित्व करने वाला पूर्णांक (0 <= delivered <= 100)।\n# - failed: असफल डिलीवरी की संख्या का प्रतिनिधित्व करने वाला पूर्णांक (0 <= failed <= 100)।\n#\n# लौटाता है:\n# - पूर्णांक: Deliv-e-droid की कुल कमाई, जो नकारात्मक हो सकती है यदि नुकसान लाभ से अधिक हो।\n#\n# उदाहरण:\n# >>> calculate_droid_earnings(5, 2)\n# 730\n# >>> calculate_droid_earnings(0, 10)\n# -100\n\ndef calculate_droid_earnings(delivered, failed)",
      "hu": "# Kiszámítja a Deliv-e-droid összes bevételét a sikeresen kézbesített és sikertelen kézbesítések száma alapján.\n# Minden sikeres kézbesítésért a Deliv-e-droid 50 egységnyi pénzt keres, és minden sikertelen kézbesítésért 10 egységet veszít.\n# Ha a sikeres kézbesítések száma meghaladja a sikertelenekét, a Deliv-e-droid 500 egység bónuszt kap.\n#\n# Argumentumok:\n# - delivered: Egész szám, amely a sikeresen kézbesített csomagok számát jelöli (0 <= delivered <= 100).\n# - failed: Egész szám, amely a sikertelen kézbesítések számát jelöli (0 <= failed <= 100).\n#\n# Visszatérési érték:\n# - Egész szám: A Deliv-e-droid összes bevétele, amely negatív is lehet, ha a veszteségek meghaladják a nyereségeket.\n#\n# Példák:\n# >>> calculate_droid_earnings(5, 2)\n# 730\n# >>> calculate_droid_earnings(0, 10)\n# -100\n\ndef calculate_droid_earnings(delivered, failed)"
    },
    "prompt_bertscore": {
      "sq": "0.9668400482988927",
      "hy": "0.9738816939369604",
      "bn": "0.9826347389380249",
      "bg": "0.980711003697702",
      "zh": "0.9731817204741935",
      "fr": "0.9944872124047577",
      "de": "0.9852340161042474",
      "ha": "0.9548924308796441",
      "hi": "0.9783804734370196",
      "hu": "0.9689862495659747"
    },
    "canonical_solution": "    earnings = delivered * 50 - failed * 10\n    earnings += 500 if delivered > failed\n    earnings\n  end",
    "instruction": {
      "en": "Write a ruby function `def calculate_droid_earnings(delivered, failed)` to solve the following problem:\nCalculates the total earnings of Deliv-e-droid based on the number of successfully delivered\n and failed deliveries. For each successful delivery, Deliv-e-droid earns 50 units of money,\n and for each failed delivery, it loses 10 units. If the number of successful deliveries is\n greater than the number of failed ones, Deliv-e-droid receives a bonus of 500 units.\n\n Arguments:\n - delivered: Integer representing the number of successfully delivered packages (0 <= delivered <= 100).\n - failed: Integer representing the number of failed deliveries (0 <= failed <= 100).\n\n Returns:\n - Integer: The total earnings of Deliv-e-droid, which can be negative if the losses outweigh the gains.\n\n Examples:\n >>> calculate_droid_earnings(5, 2)\n 730\n >>> calculate_droid_earnings(0, 10)\n -100",
      "sq": "Shkruani një funksion ruby `def calculate_droid_earnings(delivered, failed)` për të zgjidhur problemin në vijim:\nLlogarit fitimet totale të Deliv-e-droid bazuar në numrin e dorëzimeve të suksesshme dhe dështimeve. Për çdo dorëzim të suksesshëm, Deliv-e-droid fiton 50 njësi parash, dhe për çdo dorëzim të dështuar, humb 10 njësi. Nëse numri i dorëzimeve të suksesshme është më i madh se numri i dështimeve, Deliv-e-droid merr një bonus prej 500 njësish.\n\nArgumentet:\n- delivered: Integer që përfaqëson numrin e pakove të dorëzuara me sukses (0 <= delivered <= 100).\n- failed: Integer që përfaqëson numrin e dorëzimeve të dështuara (0 <= failed <= 100).\n\nKthen:\n- Integer: Fitimet totale të Deliv-e-droid, të cilat mund të jenë negative nëse humbjet tejkalojnë fitimet.\n\nShembuj:\n>>> calculate_droid_earnings(5, 2)\n730\n>>> calculate_droid_earnings(0, 10)\n-100",
      "hy": "Գրեք ruby ֆունկցիա `def calculate_droid_earnings(delivered, failed)` հետևյալ խնդիրը լուծելու համար:\nՀաշվում է Deliv-e-droid-ի ընդհանուր եկամուտը հիմնվելով հաջողությամբ առաքված և ձախողված առաքումների քանակի վրա։ Յուրաքանչյուր հաջողված առաքման համար Deliv-e-droid-ը վաստակում է 50 միավոր գումար, իսկ յուրաքանչյուր ձախողվածի համար կորցնում է 10 միավոր։ Եթե հաջողված առաքումների քանակը գերազանցում է ձախողվածներին, Deliv-e-droid-ը ստանում է 500 միավոր բոնուս։\n\nԱրգումենտներ:\n- delivered: Integer, որը ներկայացնում է հաջողությամբ առաքված փաթեթների քանակը (0 <= delivered <= 100)։\n- failed: Integer, որը ներկայացնում է ձախողված առաքումների քանակը (0 <= failed <= 100)։\n\nՎերադարձնում է:\n- Integer: Deliv-e-droid-ի ընդհանուր եկամուտը, որը կարող է լինել բացասական, եթե կորուստները գերազանցում են շահույթները։\n\nՕրինակներ:\n>>> calculate_droid_earnings(5, 2)\n730\n>>> calculate_droid_earnings(0, 10)\n-100",
      "bn": "Ruby ফাংশন `def calculate_droid_earnings(delivered, failed)` লিখুন নিম্নলিখিত সমস্যার সমাধানের জন্য:\nDeliv-e-droid এর মোট উপার্জন হিসাব করে সফলভাবে বিতরণ এবং ব্যর্থ বিতরণের সংখ্যার উপর ভিত্তি করে। প্রতিটি সফল বিতরণের জন্য, Deliv-e-droid 50 ইউনিট অর্থ উপার্জন করে, এবং প্রতিটি ব্যর্থ বিতরণের জন্য, এটি 10 ইউনিট হারায়। যদি সফল বিতরণের সংখ্যা ব্যর্থগুলির চেয়ে বেশি হয়, তবে Deliv-e-droid 500 ইউনিট বোনাস পায়।\n\nআর্গুমেন্ট:\n- delivered: সফলভাবে বিতরণ করা প্যাকেজের সংখ্যা নির্দেশ করে এমন পূর্ণসংখ্যা (0 <= delivered <= 100)।\n- failed: ব্যর্থ বিতরণের সংখ্যা নির্দেশ করে এমন পূর্ণসংখ্যা (0 <= failed <= 100)।\n\nফেরত দেয়:\n- পূর্ণসংখ্যা: Deliv-e-droid এর মোট উপার্জন, যা নেতিবাচক হতে পারে যদি ক্ষতি লাভের চেয়ে বেশি হয়।\n\nউদাহরণ:\n>>> calculate_droid_earnings(5, 2)\n730\n>>> calculate_droid_earnings(0, 10)\n-100",
      "bg": "Напишете Ruby функция `def calculate_droid_earnings(delivered, failed)` за решаване на следния проблем:\nИзчислява общите приходи на Deliv-e-droid въз основа на броя на успешно доставените и неуспешно доставените пратки. За всяка успешна доставка, Deliv-e-droid печели 50 единици пари, а за всяка неуспешна доставка губи 10 единици. Ако броят на успешните доставки е по-голям от броя на неуспешните, Deliv-e-droid получава бонус от 500 единици.\n\nАргументи:\n- delivered: Цяло число, представляващо броя на успешно доставените пакети (0 <= delivered <= 100).\n- failed: Цяло число, представляващо броя на неуспешните доставки (0 <= failed <= 100).\n\nВръща:\n- Цяло число: Общите приходи на Deliv-e-droid, които могат да бъдат отрицателни, ако загубите надвишават печалбите.\n\nПримери:\n>>> calculate_droid_earnings(5, 2)\n730\n>>> calculate_droid_earnings(0, 10)\n-100",
      "zh": "编写一个 ruby 函数 `def calculate_droid_earnings(delivered, failed)` 来解决以下问题：\n计算 Deliv-e-droid 的总收入，基于成功交付和失败交付的数量。每次成功交付，Deliv-e-droid 赚取 50 个单位的金钱，每次失败交付，损失 10 个单位。如果成功交付的数量大于失败交付的数量，Deliv-e-droid 将获得 500 个单位的奖金。\n\n参数：\n- delivered: 整数，表示成功交付的包裹数量 (0 <= delivered <= 100)。\n- failed: 整数，表示失败交付的数量 (0 <= failed <= 100)。\n\n返回值：\n- 整数：Deliv-e-droid 的总收入，如果损失超过收益，可能为负数。\n\n示例：\n>>> calculate_droid_earnings(5, 2)\n730\n>>> calculate_droid_earnings(0, 10)\n-100",
      "fr": "Écrire une fonction ruby `def calculate_droid_earnings(delivered, failed)` pour résoudre le problème suivant :\nCalcule les gains totaux de Deliv-e-droid en fonction du nombre de livraisons réussies et de livraisons échouées. Pour chaque livraison réussie, Deliv-e-droid gagne 50 unités d'argent, et pour chaque livraison échouée, il perd 10 unités. Si le nombre de livraisons réussies est supérieur au nombre de livraisons échouées, Deliv-e-droid reçoit un bonus de 500 unités.\n\nArguments :\n- delivered : Entier représentant le nombre de colis livrés avec succès (0 <= delivered <= 100).\n- failed : Entier représentant le nombre de livraisons échouées (0 <= failed <= 100).\n\nRenvoie :\n- Entier : Les gains totaux de Deliv-e-droid, qui peuvent être négatifs si les pertes dépassent les gains.\n\nExemples :\n>>> calculate_droid_earnings(5, 2)\n730\n>>> calculate_droid_earnings(0, 10)\n-100",
      "de": "Schreiben Sie eine Ruby-Funktion `def calculate_droid_earnings(delivered, failed)`, um das folgende Problem zu lösen:\nBerechnet den Gesamtertrag von Deliv-e-droid basierend auf der Anzahl der erfolgreich zugestellten\nund fehlgeschlagenen Lieferungen. Für jede erfolgreiche Lieferung verdient Deliv-e-droid 50 Einheiten Geld,\nund für jede fehlgeschlagene Lieferung verliert es 10 Einheiten. Wenn die Anzahl der erfolgreichen Lieferungen\ngrößer ist als die der fehlgeschlagenen, erhält Deliv-e-droid einen Bonus von 500 Einheiten.\n\nArgumente:\n- delivered: Integer, der die Anzahl der erfolgreich zugestellten Pakete darstellt (0 <= delivered <= 100).\n- failed: Integer, der die Anzahl der fehlgeschlagenen Lieferungen darstellt (0 <= failed <= 100).\n\nRückgabewert:\n- Integer: Der Gesamtertrag von Deliv-e-droid, der negativ sein kann, wenn die Verluste die Gewinne überwiegen.\n\nBeispiele:\n>>> calculate_droid_earnings(5, 2)\n730\n>>> calculate_droid_earnings(0, 10)\n-100",
      "ha": "Rubuta wani aiki na ruby `def calculate_droid_earnings(delivered, failed)` don warware matsalar mai zuwa:\nƘididdige jimillar kudaden shiga na Deliv-e-droid bisa ga adadin nasarorin da aka samu\nda kuma gazawar isarwa. Don kowane nasarar isarwa, Deliv-e-droid yana samun 50 raka'a na kudi,\nkuma don kowane gazawar isarwa, yana rasa 10 raka'a. Idan adadin nasarorin isarwa ya\nfi yawa akan adadin gazawar, Deliv-e-droid yana samun kari na 500 raka'a.\n\nHuɗɗa:\n- delivered: Lamba wadda ke wakiltar adadin fakitoci da aka isar da nasara (0 <= delivered <= 100).\n- failed: Lamba wadda ke wakiltar adadin gazawar isarwa (0 <= failed <= 100).\n\nKomawa:\n- Lamba: Jimillar kudaden shiga na Deliv-e-droid, wanda zai iya zama mara kyau idan asarar ta fi ribar yawa.\n\nMisalai:\n>>> calculate_droid_earnings(5, 2)\n730\n>>> calculate_droid_earnings(0, 10)\n-100",
      "hi": "रूबी फ़ंक्शन `def calculate_droid_earnings(delivered, failed)` लिखें ताकि निम्नलिखित समस्या का समाधान किया जा सके:\nसफलतापूर्वक वितरित और असफल डिलीवरी की संख्या के आधार पर Deliv-e-droid की कुल कमाई की गणना करता है। प्रत्येक सफल डिलीवरी के लिए, Deliv-e-droid 50 इकाइयों की कमाई करता है, और प्रत्येक असफल डिलीवरी के लिए, यह 10 इकाइयों का नुकसान करता है। यदि सफल डिलीवरी की संख्या असफल डिलीवरी की संख्या से अधिक है, तो Deliv-e-droid को 500 इकाइयों का बोनस मिलता है।\n\nआर्गुमेंट्स:\n- delivered: सफलतापूर्वक वितरित पैकेजों की संख्या का प्रतिनिधित्व करने वाला पूर्णांक (0 <= delivered <= 100)।\n- failed: असफल डिलीवरी की संख्या का प्रतिनिधित्व करने वाला पूर्णांक (0 <= failed <= 100)।\n\nरिटर्न करता है:\n- पूर्णांक: Deliv-e-droid की कुल कमाई, जो नकारात्मक हो सकती है यदि नुकसान लाभ से अधिक हो।\n\nउदाहरण:\n>>> calculate_droid_earnings(5, 2)\n730\n>>> calculate_droid_earnings(0, 10)\n-100",
      "hu": "Írj egy ruby függvényt `def calculate_droid_earnings(delivered, failed)` a következő probléma megoldására:\nKiszámítja a Deliv-e-droid összes bevételét a sikeresen kézbesített és a sikertelen kézbesítések száma alapján. Minden sikeres kézbesítésért a Deliv-e-droid 50 egység pénzt keres, és minden sikertelen kézbesítésért 10 egységet veszít. Ha a sikeres kézbesítések száma nagyobb, mint a sikerteleneké, a Deliv-e-droid 500 egység bónuszt kap.\n\nArgumentumok:\n- delivered: Egész szám, amely a sikeresen kézbesített csomagok számát jelenti (0 <= delivered <= 100).\n- failed: Egész szám, amely a sikertelen kézbesítések számát jelenti (0 <= failed <= 100).\n\nVisszatérési érték:\n- Egész szám: A Deliv-e-droid összes bevétele, amely negatív is lehet, ha a veszteségek meghaladják a nyereséget.\n\nPéldák:\n>>> calculate_droid_earnings(5, 2)\n730\n>>> calculate_droid_earnings(0, 10)\n-100"
    },
    "instruction_bertscore": {
      "sq": "0.9753130244626979",
      "hy": "0.9831188011766069",
      "bn": "0.9732323712213574",
      "bg": "0.9761486624757116",
      "zh": "0.9780590894805052",
      "fr": "0.9876070532664712",
      "de": "0.990532282887972",
      "ha": "0.9719903354487462",
      "hi": "0.985590557638205",
      "hu": "0.9807360311257124"
    },
    "level": "easy",
    "test": "raise 'Test failed' unless calculate_droid_earnings(5, 2) == 730\nraise 'Test failed' unless calculate_droid_earnings(0, 10) == -100\nraise 'Test failed' unless calculate_droid_earnings(10, 0) == 1000\nraise 'Test failed' unless calculate_droid_earnings(3, 5) == 100\nraise 'Test failed' unless calculate_droid_earnings(20, 20) == 800",
    "entry_point": "calculate_droid_earnings",
    "signature": "def calculate_droid_earnings(delivered, failed)",
    "docstring": {
      "en": "Calculates the total earnings of Deliv-e-droid based on the number of successfully delivered\n and failed deliveries. For each successful delivery, Deliv-e-droid earns 50 units of money,\n and for each failed delivery, it loses 10 units. If the number of successful deliveries is\n greater than the number of failed ones, Deliv-e-droid receives a bonus of 500 units.\n\n Arguments:\n - delivered: Integer representing the number of successfully delivered packages (0 <= delivered <= 100).\n - failed: Integer representing the number of failed deliveries (0 <= failed <= 100).\n\n Returns:\n - Integer: The total earnings of Deliv-e-droid, which can be negative if the losses outweigh the gains.\n\n Examples:\n >>> calculate_droid_earnings(5, 2)\n 730\n >>> calculate_droid_earnings(0, 10)\n -100",
      "sq": "Llogarit fitimet totale të Deliv-e-droid bazuar në numrin e dërgesave të suksesshme dhe dërgesave të dështuara. Për çdo dërgesë të suksesshme, Deliv-e-droid fiton 50 njësi parash, dhe për çdo dërgesë të dështuar, humbet 10 njësi. Nëse numri i dërgesave të suksesshme është më i madh se numri i atyre të dështuara, Deliv-e-droid merr një bonus prej 500 njësish.\n\nArgumentet:\n- delivered: Numër i plotë që përfaqëson numrin e pakove të dorëzuara me sukses (0 <= delivered <= 100).\n- failed: Numër i plotë që përfaqëson numrin e dërgesave të dështuara (0 <= failed <= 100).\n\nKthen:\n- Numër i plotë: Fitimet totale të Deliv-e-droid, të cilat mund të jenë negative nëse humbjet tejkalojnë fitimet.\n\nShembuj:\n>>> calculate_droid_earnings(5, 2)\n730\n>>> calculate_droid_earnings(0, 10)\n-100",
      "hy": "Հաշվում է Deliv-e-droid-ի ընդհանուր եկամուտը՝ հիմնվելով հաջողությամբ առաքված և ձախողված առաքումների քանակի վրա։ Յուրաքանչյուր հաջողությամբ առաքման համար Deliv-e-droid-ը վաստակում է 50 միավոր գումար, իսկ յուրաքանչյուր ձախողված առաքման համար կորցնում է 10 միավոր։ Եթե հաջողությամբ առաքումների քանակը գերազանցում է ձախողվածների քանակին, Deliv-e-droid-ը ստանում է 500 միավոր բոնուս։\n\nԱրգումենտներ:\n- delivered: Integer, որը ներկայացնում է հաջողությամբ առաքված փաթեթների քանակը (0 <= delivered <= 100)։\n- failed: Integer, որը ներկայացնում է ձախողված առաքումների քանակը (0 <= failed <= 100)։\n\nՎերադարձնում է:\n- Integer: Deliv-e-droid-ի ընդհանուր եկամուտը, որը կարող է լինել բացասական, եթե կորուստները գերազանցում են շահույթները։\n\nՕրինակներ:\n>>> calculate_droid_earnings(5, 2)\n730\n>>> calculate_droid_earnings(0, 10)\n-100",
      "bn": "Deliv-e-droid এর মোট উপার্জন গণনা করে সফলভাবে বিতরণ করা এবং ব্যর্থ বিতরণগুলির সংখ্যার উপর ভিত্তি করে। প্রতিটি সফল বিতরণের জন্য, Deliv-e-droid 50 ইউনিট অর্থ উপার্জন করে, এবং প্রতিটি ব্যর্থ বিতরণের জন্য, এটি 10 ইউনিট হারায়। যদি সফল বিতরণের সংখ্যা ব্যর্থগুলির চেয়ে বেশি হয়, Deliv-e-droid 500 ইউনিট বোনাস পায়।\n\nArguments:\n- delivered: সফলভাবে বিতরণ করা প্যাকেজের সংখ্যা নির্দেশকারী পূর্ণসংখ্যা (0 <= delivered <= 100)।\n- failed: ব্যর্থ বিতরণের সংখ্যা নির্দেশকারী পূর্ণসংখ্যা (0 <= failed <= 100)।\n\nReturns:\n- Integer: Deliv-e-droid এর মোট উপার্জন, যা নেতিবাচক হতে পারে যদি ক্ষতি লাভকে ছাড়িয়ে যায়।\n\nExamples:\n>>> calculate_droid_earnings(5, 2)\n730\n>>> calculate_droid_earnings(0, 10)\n-100",
      "bg": "Изчислява общите приходи на Deliv-e-droid въз основа на броя на успешно доставените и неуспешните доставки. За всяка успешна доставка Deliv-e-droid печели 50 единици пари, а за всяка неуспешна губи 10 единици. Ако броят на успешните доставки е по-голям от броя на неуспешните, Deliv-e-droid получава бонус от 500 единици.\n\nАргументи:\n- delivered: Цяло число, представляващо броя на успешно доставените пакети (0 <= delivered <= 100).\n- failed: Цяло число, представляващо броя на неуспешните доставки (0 <= failed <= 100).\n\nВръща:\n- Цяло число: Общите приходи на Deliv-e-droid, които могат да бъдат отрицателни, ако загубите надвишават печалбите.\n\nПримери:\n>>> calculate_droid_earnings(5, 2)\n730\n>>> calculate_droid_earnings(0, 10)\n-100",
      "zh": "计算 Deliv-e-droid 的总收入，基于成功交付和失败交付的数量。对于每次成功交付，Deliv-e-droid 赚取 50 个单位的金钱，而每次失败交付则损失 10 个单位。如果成功交付的数量大于失败的数量，Deliv-e-droid 将获得 500 个单位的奖金。\n\n参数:\n- delivered: 表示成功交付包裹数量的整数 (0 <= delivered <= 100)。\n- failed: 表示失败交付数量的整数 (0 <= failed <= 100)。\n\n返回:\n- 整数: Deliv-e-droid 的总收入，如果损失大于收益，则可能为负数。\n\n示例:\n>>> calculate_droid_earnings(5, 2)\n730\n>>> calculate_droid_earnings(0, 10)\n-100",
      "fr": "Calcule les gains totaux de Deliv-e-droid en fonction du nombre de livraisons réussies et échouées. Pour chaque livraison réussie, Deliv-e-droid gagne 50 unités d'argent, et pour chaque livraison échouée, il perd 10 unités. Si le nombre de livraisons réussies est supérieur au nombre de livraisons échouées, Deliv-e-droid reçoit un bonus de 500 unités.\n\nArguments:\n- delivered: Entier représentant le nombre de colis livrés avec succès (0 <= delivered <= 100).\n- failed: Entier représentant le nombre de livraisons échouées (0 <= failed <= 100).\n\nRetourne:\n- Entier: Les gains totaux de Deliv-e-droid, qui peuvent être négatifs si les pertes dépassent les gains.\n\nExemples:\n>>> calculate_droid_earnings(5, 2)\n730\n>>> calculate_droid_earnings(0, 10)\n-100",
      "de": "Berechnet die Gesamteinnahmen von Deliv-e-droid basierend auf der Anzahl der erfolgreich zugestellten und fehlgeschlagenen Lieferungen. Für jede erfolgreiche Lieferung verdient Deliv-e-droid 50 Geldeinheiten, und für jede fehlgeschlagene Lieferung verliert es 10 Einheiten. Wenn die Anzahl der erfolgreichen Lieferungen größer ist als die der fehlgeschlagenen, erhält Deliv-e-droid einen Bonus von 500 Einheiten.\n\nArgumente:\n- delivered: Ganzzahl, die die Anzahl der erfolgreich zugestellten Pakete darstellt (0 <= delivered <= 100).\n- failed: Ganzzahl, die die Anzahl der fehlgeschlagenen Lieferungen darstellt (0 <= failed <= 100).\n\nRückgabewerte:\n- Ganzzahl: Die Gesamteinnahmen von Deliv-e-droid, die negativ sein können, wenn die Verluste die Gewinne überwiegen.\n\nBeispiele:\n>>> calculate_droid_earnings(5, 2)\n730\n>>> calculate_droid_earnings(0, 10)\n-100",
      "ha": "Ƙididdige jimillar kudaden shiga na Deliv-e-droid bisa ga adadin nasarorin da aka samu\nda kuma gazawar isarwa. Don kowane nasarar isarwa, Deliv-e-droid yana samun 50 raka'a na kudi,\nkuma don kowane gazawar isarwa, yana rasa 10 raka'a. Idan adadin nasarorin isarwa ya\nfi yawa akan adadin gazawar, Deliv-e-droid yana samun kari na 500 raka'a.\n\n Huɗɗa:\n - delivered: Lamba mai nuna yawan fakitoci da aka kai nasara (0 <= delivered <= 100).\n - failed: Lamba mai nuna yawan fakitoci da aka kasa kaiwa (0 <= failed <= 100).\n\n Dawowa:\n - Lamba: Jimillar kudaden shiga na Deliv-e-droid, wanda zai iya zama mara kyau idan asarar ta fi riba.\n\n Misalai:\n >>> calculate_droid_earnings(5, 2)\n 730\n >>> calculate_droid_earnings(0, 10)\n -100",
      "hi": "सफलतापूर्वक वितरित और असफल डिलीवरी की संख्या के आधार पर Deliv-e-droid की कुल कमाई की गणना करता है। प्रत्येक सफल डिलीवरी के लिए, Deliv-e-droid 50 इकाइयों की कमाई करता है, और प्रत्येक असफल डिलीवरी के लिए, यह 10 इकाइयों का नुकसान करता है। यदि सफल डिलीवरी की संख्या असफल डिलीवरी की संख्या से अधिक है, तो Deliv-e-droid को 500 इकाइयों का बोनस मिलता है।\n\n तर्क:\n - delivered: सफलतापूर्वक वितरित किए गए पैकेजों की संख्या को दर्शाने वाला पूर्णांक (0 <= delivered <= 100)।\n - failed: असफल डिलीवरी की संख्या को दर्शाने वाला पूर्णांक (0 <= failed <= 100)।\n\n वापसी:\n - पूर्णांक: Deliv-e-droid की कुल कमाई, जो नकारात्मक हो सकती है यदि नुकसान लाभ से अधिक हो।\n\n उदाहरण:\n >>> calculate_droid_earnings(5, 2)\n 730\n >>> calculate_droid_earnings(0, 10)\n -100",
      "hu": "Kiszámítja a Deliv-e-droid összes bevételét a sikeresen kézbesített és a sikertelen kézbesítések száma alapján. Minden sikeres kézbesítésért a Deliv-e-droid 50 egységnyi pénzt keres, és minden sikertelen kézbesítésért 10 egységet veszít. Ha a sikeres kézbesítések száma nagyobb, mint a sikerteleneké, a Deliv-e-droid 500 egységnyi bónuszt kap.\n\nArgumentumok:\n- delivered: Egész szám, amely a sikeresen kézbesített csomagok számát jelöli (0 <= delivered <= 100).\n- failed: Egész szám, amely a sikertelen kézbesítések számát jelöli (0 <= failed <= 100).\n\nVisszatérési érték:\n- Egész szám: A Deliv-e-droid összes bevétele, amely negatív is lehet, ha a veszteségek meghaladják a nyereségeket.\n\nPéldák:\n>>> calculate_droid_earnings(5, 2)\n730\n>>> calculate_droid_earnings(0, 10)\n-100"
    },
    "docstring_bertscore": {
      "sq": "0.9756071960570105",
      "hy": "0.9891295551371037",
      "bn": "0.9702322579462065",
      "bg": "0.9783435281861472",
      "zh": "0.9753964492227325",
      "fr": "0.9912259001785458",
      "de": "0.983381191909954",
      "ha": "0.9634335372641444",
      "hi": "0.9906103446277188",
      "hu": "0.9954241519120993"
    }
  },
  {
    "task_id": "Ruby/49",
    "prompt": {
      "en": "# Finds the missing (broken) and duplicate ID in a sequence of ticket IDs.\n# The function takes a nested array (array of arrays) where each sub-array\n# contains ticket IDs for a particular batch. It returns an array with two elements:\n# the first is the missing ID, and the second is the duplicate ID.\n#\n# Example:\n# >>> find_missing_and_duplicate_ids([[5, 6, 8, 11, 9], [10, 12, 9]])\n# [7, 9]\n# >>> find_missing_and_duplicate_ids([[1, 2, 4], [3, 5, 5]])\n# [6, 5]\n\ndef find_missing_and_duplicate_ids(ids)",
      "sq": "# Gjen ID-të e humbura (të prishura) dhe të dyfishta në një sekuencë ID-sh biletash.\n# Funksioni merr një varg të folezuar (varg vargjesh) ku secili nën-varg\n# përmban ID-të e biletave për një grup të caktuar. Ai kthen një varg me dy elemente:\n# i pari është ID-ja e humbur, dhe i dyti është ID-ja e dyfishtë.\n#\n# Shembull:\n# >>> find_missing_and_duplicate_ids([[5, 6, 8, 11, 9], [10, 12, 9]])\n# [7, 9]\n# >>> find_missing_and_duplicate_ids([[1, 2, 4], [3, 5, 5]])\n# [6, 5]\n\ndef find_missing_and_duplicate_ids(ids)",
      "hy": "# Գտնում է բացակայող (կոտրված) և կրկնօրինակ ID-ները տոմսերի ID-ների հաջորդականության մեջ։\n# Ֆունկցիան ընդունում է ներդրված զանգված (զանգվածների զանգված), որտեղ յուրաքանչյուր ենթազանգված\n# պարունակում է տոմսերի ID-ներ տվյալ խմբաքանակի համար։ Այն վերադարձնում է զանգված երկու տարրերով՝\n# առաջինը բացակայող ID-ն է, իսկ երկրորդը՝ կրկնօրինակ ID-ն։\n#\n# Օրինակ:\n# >>> find_missing_and_duplicate_ids([[5, 6, 8, 11, 9], [10, 12, 9]])\n# [7, 9]\n# >>> find_missing_and_duplicate_ids([[1, 2, 4], [3, 5, 5]])\n# [6, 5]\n\ndef find_missing_and_duplicate_ids(ids)",
      "bn": "# টিকিট আইডির একটি ক্রমে অনুপস্থিত (ভাঙা) এবং সদৃশ আইডি খুঁজে বের করে।\n# ফাংশনটি একটি নেস্টেড অ্যারে (অ্যারের অ্যারে) গ্রহণ করে যেখানে প্রতিটি সাব-অ্যারে\n# একটি নির্দিষ্ট ব্যাচের জন্য টিকিট আইডি থাকে। এটি দুটি উপাদান সহ একটি অ্যারে ফেরত দেয়:\n# প্রথমটি অনুপস্থিত আইডি, এবং দ্বিতীয়টি সদৃশ আইডি।\n#\n# উদাহরণ:\n# >>> find_missing_and_duplicate_ids([[5, 6, 8, 11, 9], [10, 12, 9]])\n# [7, 9]\n# >>> find_missing_and_duplicate_ids([[1, 2, 4], [3, 5, 5]])\n# [6, 5]\n\ndef find_missing_and_duplicate_ids(ids)",
      "bg": "# Намира липсващото (счупено) и дублираното ID в последователност от ID на билети.\n# Функцията приема вложен масив (масив от масиви), където всеки подмасив\n# съдържа ID на билети за определена партида. Връща масив с два елемента:\n# първият е липсващото ID, а вторият е дублираното ID.\n#\n# Пример:\n# >>> find_missing_and_duplicate_ids([[5, 6, 8, 11, 9], [10, 12, 9]])\n# [7, 9]\n# >>> find_missing_and_duplicate_ids([[1, 2, 4], [3, 5, 5]])\n# [6, 5]\n\ndef find_missing_and_duplicate_ids(ids)",
      "zh": "# 查找序列中缺失（损坏）和重复的票据ID。\n# 该函数接受一个嵌套数组（数组的数组），其中每个子数组包含一个特定批次的票据ID。\n# 它返回一个包含两个元素的数组：第一个是缺失的ID，第二个是重复的ID。\n#\n# 示例:\n# >>> find_missing_and_duplicate_ids([[5, 6, 8, 11, 9], [10, 12, 9]])\n# [7, 9]\n# >>> find_missing_and_duplicate_ids([[1, 2, 4], [3, 5, 5]])\n# [6, 5]\n\ndef find_missing_and_duplicate_ids(ids)",
      "fr": "# Trouve l'ID manquant (cassé) et l'ID en double dans une séquence d'IDs de tickets.\n# La fonction prend un tableau imbriqué (tableau de tableaux) où chaque sous-tableau\n# contient des IDs de tickets pour un lot particulier. Elle renvoie un tableau avec deux éléments :\n# le premier est l'ID manquant, et le second est l'ID en double.\n#\n# Exemple :\n# >>> find_missing_and_duplicate_ids([[5, 6, 8, 11, 9], [10, 12, 9]])\n# [7, 9]\n# >>> find_missing_and_duplicate_ids([[1, 2, 4], [3, 5, 5]])\n# [6, 5]\n\ndef find_missing_and_duplicate_ids(ids)",
      "de": "# Findet die fehlende (defekte) und doppelte ID in einer Sequenz von Ticket-IDs.\n# Die Funktion nimmt ein verschachteltes Array (Array von Arrays), wobei jedes Unter-Array\n# Ticket-IDs für eine bestimmte Charge enthält. Sie gibt ein Array mit zwei Elementen zurück:\n# das erste ist die fehlende ID, und das zweite ist die doppelte ID.\n#\n# Beispiel:\n# >>> find_missing_and_duplicate_ids([[5, 6, 8, 11, 9], [10, 12, 9]])\n# [7, 9]\n# >>> find_missing_and_duplicate_ids([[1, 2, 4], [3, 5, 5]])\n# [6, 5]\n\ndef find_missing_and_duplicate_ids(ids)",
      "ha": "# Nemi ID da ya ɓace (wanda ya lalace) da kuma ID mai maimaitawa a cikin jerin ID na tikiti.\n# Aikin yana ɗaukar tsararren array (array na arrays) inda kowace ƙaramin array\n# ke ɗauke da ID na tikiti don takamaiman batch. Yana dawowa da array mai abubuwa biyu:\n# na farko shine ID da ya ɓace, kuma na biyu shine ID mai maimaitawa.\n#\n# Misali:\n# >>> find_missing_and_duplicate_ids([[5, 6, 8, 11, 9], [10, 12, 9]])\n# [7, 9]\n# >>> find_missing_and_duplicate_ids([[1, 2, 4], [3, 5, 5]])\n# [6, 5]\n\ndef find_missing_and_duplicate_ids(ids)",
      "hi": "# टिकट आईडी के अनुक्रम में गायब (टूटी हुई) और डुप्लिकेट आईडी खोजता है।\n# यह फ़ंक्शन एक नेस्टेड ऐरे (ऐरे का ऐरे) लेता है जहाँ प्रत्येक उप-ऐरे\n# एक विशेष बैच के लिए टिकट आईडी शामिल करता है। यह एक ऐरे लौटाता है जिसमें दो तत्व होते हैं:\n# पहला गायब आईडी है, और दूसरा डुप्लिकेट आईडी है।\n#\n# उदाहरण:\n# >>> find_missing_and_duplicate_ids([[5, 6, 8, 11, 9], [10, 12, 9]])\n# [7, 9]\n# >>> find_missing_and_duplicate_ids([[1, 2, 4], [3, 5, 5]])\n# [6, 5]\n\ndef find_missing_and_duplicate_ids(ids)",
      "hu": "# Megkeresi a hiányzó (hibás) és a duplikált azonosítót egy jegyazonosító-sorozatban.\n# A függvény egy beágyazott tömböt (tömbök tömbjét) vesz át, ahol minden al-tömb\n# egy adott tételhez tartozó jegyazonosítókat tartalmaz. Egy tömböt ad vissza két elemmel:\n# az első a hiányzó azonosító, a második a duplikált azonosító.\n#\n# Példa:\n# >>> find_missing_and_duplicate_ids([[5, 6, 8, 11, 9], [10, 12, 9]])\n# [7, 9]\n# >>> find_missing_and_duplicate_ids([[1, 2, 4], [3, 5, 5]])\n# [6, 5]\n\ndef find_missing_and_duplicate_ids(ids)"
    },
    "prompt_bertscore": {
      "sq": "0.9911263863576474",
      "hy": "0.98662601781454",
      "bn": "0.9973498734562325",
      "bg": "0.9900404740645297",
      "zh": "0.9657702250666388",
      "fr": "0.9919763257580957",
      "de": "0.989649966735415",
      "ha": "0.9554366781236797",
      "hi": "0.9899518849145881",
      "hu": "0.9655858960730384"
    },
    "canonical_solution": "    all_ids = ids.flatten.sort\n    missing_id = nil\n    duplicate_id = nil\n    expected_sum = (all_ids.first..all_ids.last).sum\n    actual_sum = all_ids.sum\n  \n    all_ids.each_with_index do |id, index|\n      if index > 0 && id == all_ids[index - 1]\n        duplicate_id = id\n      end\n    end\n  \n    missing_id = expected_sum - actual_sum + duplicate_id\n    [missing_id, duplicate_id]\n  end",
    "instruction": {
      "en": "Write a ruby function `def find_missing_and_duplicate_ids(ids)` to solve the following problem:\nFinds the missing (broken) and duplicate ID in a sequence of ticket IDs.\n The function takes a nested array (array of arrays) where each sub-array\n contains ticket IDs for a particular batch. It returns an array with two elements:\n the first is the missing ID, and the second is the duplicate ID.\n\n Example:\n >>> find_missing_and_duplicate_ids([[5, 6, 8, 11, 9], [10, 12, 9]])\n [7, 9]\n >>> find_missing_and_duplicate_ids([[1, 2, 4], [3, 5, 5]])\n [6, 5]",
      "sq": "Shkruani një funksion ruby `def find_missing_and_duplicate_ids(ids)` për të zgjidhur problemin e mëposhtëm:\nGjen ID-të që mungojnë (të prishura) dhe ID-të e dyfishta në një sekuencë të ID-ve të biletave.\n Funksioni merr një varg të folezuar (varg arraysh) ku çdo nën-array\n përmban ID-të e biletave për një grup të caktuar. Ai kthen një varg me dy elemente:\n i pari është ID-ja që mungon, dhe i dyti është ID-ja e dyfishtë.\n\n Shembull:\n >>> find_missing_and_duplicate_ids([[5, 6, 8, 11, 9], [10, 12, 9]])\n [7, 9]\n >>> find_missing_and_duplicate_ids([[1, 2, 4], [3, 5, 5]])\n [6, 5]",
      "hy": "Գրեք ruby ֆունկցիա `def find_missing_and_duplicate_ids(ids)` հետևյալ խնդիրը լուծելու համար:\nԳտնում է բացակայող (կոտրված) և կրկնվող ID-ները տոմսերի ID-ների հաջորդականության մեջ։\n Ֆունկցիան ընդունում է ներդրված զանգված (զանգվածների զանգված), որտեղ յուրաքանչյուր ենթազանգված\n պարունակում է տոմսերի ID-ներ կոնկրետ խմբաքանակի համար։ Այն վերադարձնում է զանգված երկու տարրերով՝\n առաջինը բացակայող ID-ն է, իսկ երկրորդը կրկնվող ID-ն։\n\n Օրինակ:\n >>> find_missing_and_duplicate_ids([[5, 6, 8, 11, 9], [10, 12, 9]])\n [7, 9]\n >>> find_missing_and_duplicate_ids([[1, 2, 4], [3, 5, 5]])\n [6, 5]",
      "bn": "রুবি ফাংশন `def find_missing_and_duplicate_ids(ids)` লিখুন নিম্নলিখিত সমস্যার সমাধানের জন্য:\nটিকিট আইডির একটি ক্রমে অনুপস্থিত (ভাঙা) এবং সদৃশ আইডি খুঁজে বের করে।\n ফাংশনটি একটি নেস্টেড অ্যারে (অ্যারের অ্যারে) গ্রহণ করে যেখানে প্রতিটি সাব-অ্যারে\n একটি নির্দিষ্ট ব্যাচের জন্য টিকিট আইডি থাকে। এটি দুটি উপাদান সহ একটি অ্যারে ফেরত দেয়:\n প্রথমটি অনুপস্থিত আইডি, এবং দ্বিতীয়টি সদৃশ আইডি।\n\n উদাহরণ:\n >>> find_missing_and_duplicate_ids([[5, 6, 8, 11, 9], [10, 12, 9]])\n [7, 9]\n >>> find_missing_and_duplicate_ids([[1, 2, 4], [3, 5, 5]])\n [6, 5]",
      "bg": "Напишете функция на Ruby `def find_missing_and_duplicate_ids(ids)`, за да решите следния проблем:\nНамира липсващото (счупено) и дублираното ID в последователност от ID на билети.\nФункцията приема вложен масив (масив от масиви), където всеки подмасив\nсъдържа ID на билети за определена партида. Тя връща масив с два елемента:\nпървият е липсващото ID, а вторият е дублираното ID.\n\nПример:\n>>> find_missing_and_duplicate_ids([[5, 6, 8, 11, 9], [10, 12, 9]])\n[7, 9]\n>>> find_missing_and_duplicate_ids([[1, 2, 4], [3, 5, 5]])\n[6, 5]",
      "zh": "编写一个 ruby 函数 `def find_missing_and_duplicate_ids(ids)` 来解决以下问题：\n查找票据 ID 序列中缺失（损坏）和重复的 ID。\n该函数接受一个嵌套数组（数组的数组），每个子数组包含一个特定批次的票据 ID。它返回一个包含两个元素的数组：第一个是缺失的 ID，第二个是重复的 ID。\n\n例子：\n>>> find_missing_and_duplicate_ids([[5, 6, 8, 11, 9], [10, 12, 9]])\n[7, 9]\n>>> find_missing_and_duplicate_ids([[1, 2, 4], [3, 5, 5]])\n[6, 5]",
      "fr": "Écrire une fonction ruby `def find_missing_and_duplicate_ids(ids)` pour résoudre le problème suivant :  \nTrouve l'ID manquant (cassé) et l'ID en double dans une séquence d'IDs de tickets.  \nLa fonction prend un tableau imbriqué (tableau de tableaux) où chaque sous-tableau  \ncontient des IDs de tickets pour un lot particulier. Elle renvoie un tableau avec deux éléments :  \nle premier est l'ID manquant, et le second est l'ID en double.  \n\nExemple :  \n>>> find_missing_and_duplicate_ids([[5, 6, 8, 11, 9], [10, 12, 9]])  \n[7, 9]  \n>>> find_missing_and_duplicate_ids([[1, 2, 4], [3, 5, 5]])  \n[6, 5]  ",
      "de": "Schreiben Sie eine Ruby-Funktion `def find_missing_and_duplicate_ids(ids)`, um das folgende Problem zu lösen:\nFindet die fehlende (defekte) und doppelte ID in einer Sequenz von Ticket-IDs.\n Die Funktion nimmt ein verschachteltes Array (Array von Arrays) entgegen, wobei jedes Unter-Array\n Ticket-IDs für eine bestimmte Charge enthält. Sie gibt ein Array mit zwei Elementen zurück:\n das erste ist die fehlende ID, und das zweite ist die doppelte ID.\n\n Beispiel:\n >>> find_missing_and_duplicate_ids([[5, 6, 8, 11, 9], [10, 12, 9]])\n [7, 9]\n >>> find_missing_and_duplicate_ids([[1, 2, 4], [3, 5, 5]])\n [6, 5]",
      "ha": "Rubuta aikin ruby `def find_missing_and_duplicate_ids(ids)` don warware matsalar mai zuwa:\nNemo ID da ya ɓace (karya) da kuma ID mai maimaitawa a cikin jerin ID na tikiti.\n Aikin yana ɗaukar tsararren array (array na arrays) inda kowanne ƙaramin array\n ya ƙunshi ID na tikiti don takamaiman batch. Yana dawowa da array mai abubuwa biyu:\n na farko shine ID da ya ɓace, kuma na biyu shine ID mai maimaitawa.\n\n Misali:\n >>> find_missing_and_duplicate_ids([[5, 6, 8, 11, 9], [10, 12, 9]])\n [7, 9]\n >>> find_missing_and_duplicate_ids([[1, 2, 4], [3, 5, 5]])\n [6, 5]",
      "hi": "Ruby फ़ंक्शन `def find_missing_and_duplicate_ids(ids)` लिखें ताकि निम्नलिखित समस्या का समाधान किया जा सके:\nटिकट आईडी के अनुक्रम में गायब (टूटी हुई) और डुप्लिकेट आईडी को खोजें।\n फ़ंक्शन एक नेस्टेड ऐरे (ऐरे का ऐरे) लेता है जहाँ प्रत्येक उप-ऐरे\n एक विशेष बैच के लिए टिकट आईडी शामिल करता है। यह दो तत्वों के साथ एक ऐरे लौटाता है:\n पहला गायब आईडी है, और दूसरा डुप्लिकेट आईडी है।\n\n उदाहरण:\n >>> find_missing_and_duplicate_ids([[5, 6, 8, 11, 9], [10, 12, 9]])\n [7, 9]\n >>> find_missing_and_duplicate_ids([[1, 2, 4], [3, 5, 5]])\n [6, 5]",
      "hu": "Írj egy ruby függvényt `def find_missing_and_duplicate_ids(ids)` a következő probléma megoldására:\nMegkeresi a hiányzó (hibás) és a duplikált azonosítót egy jegyazonosító sorozatban.\n A függvény egy beágyazott tömböt (tömbök tömbje) vesz át, ahol minden al-tömb\n egy adott tételhez tartozó jegyazonosítókat tartalmaz. Visszaad egy tömböt két elemmel:\n az első a hiányzó azonosító, a második a duplikált azonosító.\n\n Példa:\n >>> find_missing_and_duplicate_ids([[5, 6, 8, 11, 9], [10, 12, 9]])\n [7, 9]\n >>> find_missing_and_duplicate_ids([[1, 2, 4], [3, 5, 5]])\n [6, 5]"
    },
    "instruction_bertscore": {
      "sq": "0.9829225543601444",
      "hy": "0.9938255746055304",
      "bn": "0.9918621132890006",
      "bg": "0.9929655050556494",
      "zh": "0.9835248016754422",
      "fr": "0.9908918038776452",
      "de": "0.9747056127574932",
      "ha": "0.9777426712835167",
      "hi": "0.9759778403480217",
      "hu": "0.96637505457689"
    },
    "level": "middle",
    "test": "raise 'Test failed' unless find_missing_and_duplicate_ids([[5, 6, 8, 11, 9], [10, 12, 9]]) == [7, 9]\nraise 'Test failed' unless find_missing_and_duplicate_ids([[1, 2, 4], [3, 5, 5, 7]]) == [6, 5]\nraise 'Test failed' unless find_missing_and_duplicate_ids([[20, 21, 23], [22, 24, 24, 26]]) == [25, 24]\nraise 'Test failed' unless find_missing_and_duplicate_ids([[100, 102, 106], [101, 103, 103, 105]]) == [104, 103]",
    "entry_point": "find_missing_and_duplicate_ids",
    "signature": "def find_missing_and_duplicate_ids(ids)",
    "docstring": {
      "en": "Finds the missing (broken) and duplicate ID in a sequence of ticket IDs.\n The function takes a nested array (array of arrays) where each sub-array\n contains ticket IDs for a particular batch. It returns an array with two elements:\n the first is the missing ID, and the second is the duplicate ID.\n\n Example:\n >>> find_missing_and_duplicate_ids([[5, 6, 8, 11, 9], [10, 12, 9]])\n [7, 9]\n >>> find_missing_and_duplicate_ids([[1, 2, 4], [3, 5, 5]])\n [6, 5]",
      "sq": "Gjen ID-në që mungon (të prishur) dhe ID-në e dublikuar në një sekuencë ID-sh biletash. Funksioni merr një varg të folezuar (varg vargjesh) ku secili nën-varg përmban ID-të e biletave për një grup të caktuar. Ai kthen një varg me dy elemente: i pari është ID-ja që mungon, dhe i dyti është ID-ja e dublikuar.\n\nShembull:\n>>> find_missing_and_duplicate_ids([[5, 6, 8, 11, 9], [10, 12, 9]])\n[7, 9]\n>>> find_missing_and_duplicate_ids([[1, 2, 4], [3, 5, 5]])\n[6, 5]",
      "hy": "Գտնում է բացակայող (կոտրված) և կրկնօրինակ ID-ները տոմսերի ID-ների հաջորդականության մեջ։ Ֆունկցիան ընդունում է ներդրված զանգված (զանգվածների զանգված), որտեղ յուրաքանչյուր ենթազանգված պարունակում է տոմսերի ID-ները որոշակի խմբաքանակի համար։ Այն վերադարձնում է զանգված երկու տարրերով՝ առաջինը բացակայող ID-ն է, իսկ երկրորդը՝ կրկնօրինակ ID-ն։\n\nՕրինակ:\n>>> find_missing_and_duplicate_ids([[5, 6, 8, 11, 9], [10, 12, 9]])\n[7, 9]\n>>> find_missing_and_duplicate_ids([[1, 2, 4], [3, 5, 5]])\n[6, 5]",
      "bn": "টিকিট আইডির একটি ক্রমে অনুপস্থিত (ভাঙা) এবং সদৃশ আইডি খুঁজে বের করে।\nফাংশনটি একটি নেস্টেড অ্যারে (অ্যারের অ্যারে) গ্রহণ করে যেখানে প্রতিটি সাব-অ্যারে একটি নির্দিষ্ট ব্যাচের টিকেট আইডি থাকে। এটি একটি অ্যারে ফেরত দেয় যার দুটি উপাদান রয়েছে: প্রথমটি হল অনুপস্থিত আইডি, এবং দ্বিতীয়টি হল সদৃশ আইডি।\n\nউদাহরণ:\n>>> find_missing_and_duplicate_ids([[5, 6, 8, 11, 9], [10, 12, 9]])\n[7, 9]\n>>> find_missing_and_duplicate_ids([[1, 2, 4], [3, 5, 5]])\n[6, 5]",
      "bg": "Намира липсващото (счупено) и дублираното ID в последователност от ID на билети. Функцията приема вложен масив (масив от масиви), където всеки подмасив съдържа ID на билети за определена партида. Връща масив с два елемента: първият е липсващото ID, а вторият е дублираното ID.\n\nПример:\n>>> find_missing_and_duplicate_ids([[5, 6, 8, 11, 9], [10, 12, 9]])\n[7, 9]\n>>> find_missing_and_duplicate_ids([[1, 2, 4], [3, 5, 5]])\n[6, 5]",
      "zh": "查找序列中的缺失（损坏）和重复ID。\n该函数接受一个嵌套数组（数组的数组），其中每个子数组包含特定批次的票据ID。它返回一个包含两个元素的数组：第一个是缺失的ID，第二个是重复的ID。\n\n示例：\n>>> find_missing_and_duplicate_ids([[5, 6, 8, 11, 9], [10, 12, 9]])\n[7, 9]\n>>> find_missing_and_duplicate_ids([[1, 2, 4], [3, 5, 5]])\n[6, 5]",
      "fr": "Trouve l'ID manquant (cassé) et l'ID dupliqué dans une séquence d'IDs de tickets. La fonction prend un tableau imbriqué (tableau de tableaux) où chaque sous-tableau contient des IDs de tickets pour un lot particulier. Elle renvoie un tableau avec deux éléments : le premier est l'ID manquant, et le second est l'ID dupliqué.\n\nExemple :\n>>> find_missing_and_duplicate_ids([[5, 6, 8, 11, 9], [10, 12, 9]])\n[7, 9]\n>>> find_missing_and_duplicate_ids([[1, 2, 4], [3, 5, 5]])\n[6, 5]",
      "de": "Findet die fehlende (defekte) und doppelte ID in einer Sequenz von Ticket-IDs. Die Funktion nimmt ein verschachteltes Array (Array von Arrays) an, wobei jedes Unter-Array Ticket-IDs für eine bestimmte Charge enthält. Sie gibt ein Array mit zwei Elementen zurück: das erste ist die fehlende ID und das zweite die doppelte ID.\n\nBeispiel:\n>>> find_missing_and_duplicate_ids([[5, 6, 8, 11, 9], [10, 12, 9]])\n[7, 9]\n>>> find_missing_and_duplicate_ids([[1, 2, 4], [3, 5, 5]])\n[6, 5]",
      "ha": "Yana gano ID da ya ɓace (wanda ya karye) da kuma wanda aka maimaita a cikin jerin ID na tikiti. \nAikin yana karɓar tsararren array (array na arrays) inda kowace ƙaramin array \nke ɗauke da ID na tikiti don kowane batch. Yana dawowa da array tare da abubuwa biyu: \nna farko shine ID da ya ɓace, na biyu kuma shine ID da aka maimaita.\n\nMisali:\n>>> find_missing_and_duplicate_ids([[5, 6, 8, 11, 9], [10, 12, 9]])\n[7, 9]\n>>> find_missing_and_duplicate_ids([[1, 2, 4], [3, 5, 5]])\n[6, 5]",
      "hi": "टिकट आईडी के अनुक्रम में गायब (टूटा हुआ) और डुप्लिकेट आईडी खोजता है। \nयह फ़ंक्शन एक नेस्टेड ऐरे (ऐरे का ऐरे) लेता है जहाँ प्रत्येक उप-ऐरे में किसी विशेष बैच के लिए टिकट आईडी होती हैं। यह एक ऐरे लौटाता है जिसमें दो तत्व होते हैं: पहला गायब आईडी है, और दूसरा डुप्लिकेट आईडी है।\n\nउदाहरण:\n>>> find_missing_and_duplicate_ids([[5, 6, 8, 11, 9], [10, 12, 9]])\n[7, 9]\n>>> find_missing_and_duplicate_ids([[1, 2, 4], [3, 5, 5]])\n[6, 5]",
      "hu": "Megkeresi a hiányzó (törött) és a duplikált azonosítót egy jegyazonosító-sorozatban. A függvény egy beágyazott tömböt (tömbök tömbje) vesz fel, ahol minden al-tömb egy adott tétel jegyazonosítóit tartalmazza. Egy két elemből álló tömböt ad vissza: az első a hiányzó azonosító, a második a duplikált azonosító.\n\nPélda:\n>>> find_missing_and_duplicate_ids([[5, 6, 8, 11, 9], [10, 12, 9]])\n[7, 9]\n>>> find_missing_and_duplicate_ids([[1, 2, 4], [3, 5, 5]])\n[6, 5]"
    },
    "docstring_bertscore": {
      "sq": "0.9795863584802825",
      "hy": "0.9895023843623062",
      "bn": "0.9973387501548946",
      "bg": "0.9892366169124814",
      "zh": "0.9663810134883211",
      "fr": "0.9892896512242177",
      "de": "0.9892868703988833",
      "ha": "0.9391489868788189",
      "hi": "0.9884204446768091",
      "hu": "0.9648525527062576"
    }
  },
  {
    "task_id": "Ruby/50",
    "prompt": {
      "en": "# Counts the number of digits, lowercase letters, and uppercase letters in a given string.\n# The function takes a single argument, s, which is a string of length 8,\n# and returns an array with three integers representing the count of digits,\n# lowercase letters, and uppercase letters in the string, respectively.\n#\n# Examples:\n# >>> count_chars_types(\"yLOI2022\")\n# [4, 1, 3]\n# >>> count_chars_types(\"IAKIOIOI\")\n# [0, 0, 8]\n# >>> count_chars_types(\"1n2s0e1s\")\n# [4, 4, 0]\ndef count_chars_types(s)",
      "sq": "# Numëron numrin e shifrave, shkronjave të vogla dhe shkronjave të mëdha në një varg të dhënë.\n# Funksioni merr një argument të vetëm, s, i cili është një varg me gjatësi 8,\n# dhe kthen një varg me tre numra të plotë që përfaqësojnë numrin e shifrave,\n# shkronjave të vogla dhe shkronjave të mëdha në varg, përkatësisht.\n#\n# Shembuj:\n# >>> count_chars_types(\"yLOI2022\")\n# [4, 1, 3]\n# >>> count_chars_types(\"IAKIOIOI\")\n# [0, 0, 8]\n# >>> count_chars_types(\"1n2s0e1s\")\n# [4, 4, 0]\ndef count_chars_types(s)",
      "hy": "# Հաշվում է թվանշանների, փոքրատառերի և մեծատառերի քանակը տրված տողում։\n# Ֆունկցիան ընդունում է մեկ արգումենտ, s, որը 8 նիշ երկարությամբ տող է,\n# և վերադարձնում է երեք ամբողջ թվերից բաղկացած զանգված, որը ներկայացնում է թվանշանների,\n# փոքրատառերի և մեծատառերի քանակը տողում, համապատասխանաբար։\n#\n# Օրինակներ:\n# >>> count_chars_types(\"yLOI2022\")\n# [4, 1, 3]\n# >>> count_chars_types(\"IAKIOIOI\")\n# [0, 0, 8]\n# >>> count_chars_types(\"1n2s0e1s\")\n# [4, 4, 0]\ndef count_chars_types(s)",
      "bn": "# প্রদত্ত স্ট্রিং-এ সংখ্যা, ছোট হাতের অক্ষর, এবং বড় হাতের অক্ষরের সংখ্যা গণনা করে।\n# ফাংশনটি একটি একক আর্গুমেন্ট গ্রহণ করে, s, যা একটি 8 দৈর্ঘ্যের স্ট্রিং,\n# এবং একটি অ্যারে ফেরত দেয় যা তিনটি পূর্ণসংখ্যা ধারণ করে যা যথাক্রমে স্ট্রিং-এ সংখ্যা,\n# ছোট হাতের অক্ষর, এবং বড় হাতের অক্ষরের সংখ্যা নির্দেশ করে।\n#\n# উদাহরণ:\n# >>> count_chars_types(\"yLOI2022\")\n# [4, 1, 3]\n# >>> count_chars_types(\"IAKIOIOI\")\n# [0, 0, 8]\n# >>> count_chars_types(\"1n2s0e1s\")\n# [4, 4, 0]\ndef count_chars_types(s)",
      "bg": "# Брои броя на цифрите, малките букви и главните букви в даден низ.\n# Функцията приема един аргумент, s, който е низ с дължина 8,\n# и връща масив с три цели числа, представляващи броя на цифрите,\n# малките букви и главните букви в низа, съответно.\n#\n# Примери:\n# >>> count_chars_types(\"yLOI2022\")\n# [4, 1, 3]\n# >>> count_chars_types(\"IAKIOIOI\")\n# [0, 0, 8]\n# >>> count_chars_types(\"1n2s0e1s\")\n# [4, 4, 0]\ndef count_chars_types(s)",
      "zh": "# 统计给定字符串中数字、小写字母和大写字母的数量。\n# 该函数接受一个参数 s，它是一个长度为 8 的字符串，\n# 并返回一个包含三个整数的数组，分别表示字符串中数字、\n# 小写字母和大写字母的数量。\n#\n# 例子:\n# >>> count_chars_types(\"yLOI2022\")\n# [4, 1, 3]\n# >>> count_chars_types(\"IAKIOIOI\")\n# [0, 0, 8]\n# >>> count_chars_types(\"1n2s0e1s\")\n# [4, 4, 0]\ndef count_chars_types(s)",
      "fr": "# Compte le nombre de chiffres, de lettres minuscules et de lettres majuscules dans une chaîne donnée.\n# La fonction prend un seul argument, s, qui est une chaîne de longueur 8,\n# et renvoie un tableau avec trois entiers représentant le compte de chiffres,\n# de lettres minuscules et de lettres majuscules dans la chaîne, respectivement.\n#\n# Exemples :\n# >>> count_chars_types(\"yLOI2022\")\n# [4, 1, 3]\n# >>> count_chars_types(\"IAKIOIOI\")\n# [0, 0, 8]\n# >>> count_chars_types(\"1n2s0e1s\")\n# [4, 4, 0]\ndef count_chars_types(s)",
      "de": "# Zählt die Anzahl der Ziffern, Kleinbuchstaben und Großbuchstaben in einem gegebenen String.\n# Die Funktion nimmt ein einziges Argument, s, das ein String der Länge 8 ist,\n# und gibt ein Array mit drei ganzen Zahlen zurück, die die Anzahl der Ziffern,\n# Kleinbuchstaben und Großbuchstaben im String darstellen.\n#\n# Beispiele:\n# >>> count_chars_types(\"yLOI2022\")\n# [4, 1, 3]\n# >>> count_chars_types(\"IAKIOIOI\")\n# [0, 0, 8]\n# >>> count_chars_types(\"1n2s0e1s\")\n# [4, 4, 0]\ndef count_chars_types(s)",
      "ha": "# Yana ƙididdige yawan lambobi, ƙananan haruffa, da manyan haruffa a cikin wani igiyar rubutu.\n# Aikin yana ɗaukar hujja guda, s, wanda igiyar rubutu ce mai tsawon 8,\n# kuma yana mayar da jerin lambobi guda uku da ke wakiltar ƙididdigar lambobi,\n# ƙananan haruffa, da manyan haruffa a cikin igiyar rubutu, bi da bi.\n#\n# Misalai:\n# >>> count_chars_types(\"yLOI2022\")\n# [4, 1, 3]\n# >>> count_chars_types(\"IAKIOIOI\")\n# [0, 0, 8]\n# >>> count_chars_types(\"1n2s0e1s\")\n# [4, 4, 0]\ndef count_chars_types(s)",
      "hi": "# दिए गए स्ट्रिंग में अंकों, छोटे अक्षरों, और बड़े अक्षरों की संख्या गिनता है।\n# फ़ंक्शन एक एकल तर्क लेता है, s, जो 8 लंबाई का एक स्ट्रिंग है,\n# और तीन पूर्णांकों की एक array लौटाता है जो क्रमशः स्ट्रिंग में अंकों,\n# छोटे अक्षरों, और बड़े अक्षरों की गिनती का प्रतिनिधित्व करते हैं।\n#\n# उदाहरण:\n# >>> count_chars_types(\"yLOI2022\")\n# [4, 1, 3]\n# >>> count_chars_types(\"IAKIOIOI\")\n# [0, 0, 8]\n# >>> count_chars_types(\"1n2s0e1s\")\n# [4, 4, 0]\ndef count_chars_types(s)",
      "hu": "# Megszámolja a számjegyek, kisbetűk és nagybetűk számát egy adott szövegben.\n# A függvény egyetlen argumentumot vesz fel, s, amely egy 8 hosszúságú szöveg,\n# és egy tömböt ad vissza három egész számmal, amelyek a számjegyek,\n# kisbetűk és nagybetűk számát jelzik a szövegben, ebben a sorrendben.\n#\n# Példák:\n# >>> count_chars_types(\"yLOI2022\")\n# [4, 1, 3]\n# >>> count_chars_types(\"IAKIOIOI\")\n# [0, 0, 8]\n# >>> count_chars_types(\"1n2s0e1s\")\n# [4, 4, 0]\ndef count_chars_types(s)"
    },
    "prompt_bertscore": {
      "sq": "0.9923644495226379",
      "hy": "0.9797476463496828",
      "bn": "0.9877335808191905",
      "bg": "0.993281923252638",
      "zh": "0.9700632234919458",
      "fr": "1",
      "de": "0.9896169940921633",
      "ha": "0.9846913579032601",
      "hi": "0.9943418149658402",
      "hu": "0.9673455626186265"
    },
    "canonical_solution": "    digits_count = s.count(\"0-9\")\n    lowercase_count = s.count(\"a-z\")\n    uppercase_count = s.count(\"A-Z\")\n    [digits_count, lowercase_count, uppercase_count]\n  end",
    "instruction": {
      "en": "Write a ruby function `def count_chars_types(s)` to solve the following problem:\nCounts the number of digits, lowercase letters, and uppercase letters in a given string.\n The function takes a single argument, s, which is a string of length 8,\n and returns an array with three integers representing the count of digits,\n lowercase letters, and uppercase letters in the string, respectively.\n\n Examples:\n >>> count_chars_types(\"yLOI2022\")\n [4, 1, 3]\n >>> count_chars_types(\"IAKIOIOI\")\n [0, 0, 8]\n >>> count_chars_types(\"1n2s0e1s\")\n [4, 4, 0]",
      "sq": "Shkruani një funksion ruby `def count_chars_types(s)` për të zgjidhur problemin e mëposhtëm:\nNumëron numrin e shifrave, shkronjave të vogla dhe shkronjave të mëdha në një varg të dhënë.\n Funksioni merr një argument të vetëm, s, i cili është një varg me gjatësi 8,\n dhe kthen një varg me tre numra të plotë që përfaqësojnë numrin e shifrave,\n shkronjave të vogla dhe shkronjave të mëdha në varg, përkatësisht.\n\n Shembuj:\n >>> count_chars_types(\"yLOI2022\")\n [4, 1, 3]\n >>> count_chars_types(\"IAKIOIOI\")\n [0, 0, 8]\n >>> count_chars_types(\"1n2s0e1s\")\n [4, 4, 0]",
      "hy": "Գրեք ruby ֆունկցիա `def count_chars_types(s)` հետևյալ խնդիրը լուծելու համար:\nՀաշվում է թվանշանների, փոքրատառերի և մեծատառերի քանակը տրված տողում:\nՖունկցիան ընդունում է մեկ արգումենտ, s, որը 8 երկարությամբ տող է,\nև վերադարձնում է զանգված երեք ամբողջ թվերով, որոնք ներկայացնում են թվանշանների,\nփոքրատառերի և մեծատառերի քանակը տողում, համապատասխանաբար:\n\nՕրինակներ:\n>>> count_chars_types(\"yLOI2022\")\n[4, 1, 3]\n>>> count_chars_types(\"IAKIOIOI\")\n[0, 0, 8]\n>>> count_chars_types(\"1n2s0e1s\")\n[4, 4, 0]",
      "bn": "Ruby ফাংশন `def count_chars_types(s)` লিখুন নিম্নলিখিত সমস্যার সমাধানের জন্য:\nএকটি প্রদত্ত স্ট্রিং-এ সংখ্যার সংখ্যা, ছোট হাতের অক্ষর, এবং বড় হাতের অক্ষর গুনে বের করে।\nফাংশনটি একটি একক আর্গুমেন্ট গ্রহণ করে, s, যা ৮ দৈর্ঘ্যের একটি স্ট্রিং,\nএবং একটি অ্যারে রিটার্ন করে যা তিনটি পূর্ণসংখ্যা ধারণ করে, যথাক্রমে সংখ্যার সংখ্যা,\nছোট হাতের অক্ষর, এবং বড় হাতের অক্ষর স্ট্রিং-এ।\n\nউদাহরণ:\n>>> count_chars_types(\"yLOI2022\")\n[4, 1, 3]\n>>> count_chars_types(\"IAKIOIOI\")\n[0, 0, 8]\n>>> count_chars_types(\"1n2s0e1s\")\n[4, 4, 0]",
      "bg": "Напишете Ruby функция `def count_chars_types(s)` за решаване на следния проблем:  \nБрои броя на цифрите, малките букви и главните букви в даден низ.  \nФункцията приема един аргумент, s, който е низ с дължина 8,  \nи връща масив с три цели числа, представляващи броя на цифрите,  \nмалките букви и главните букви в низа, съответно.\n\nПримери:\n>>> count_chars_types(\"yLOI2022\")\n[4, 1, 3]\n>>> count_chars_types(\"IAKIOIOI\")\n[0, 0, 8]\n>>> count_chars_types(\"1n2s0e1s\")\n[4, 4, 0]",
      "zh": "编写一个 ruby 函数 `def count_chars_types(s)` 来解决以下问题：  \n统计给定字符串中数字、小写字母和大写字母的数量。  \n该函数接受一个参数 s，这是一个长度为 8 的字符串，  \n并返回一个包含三个整数的数组，分别表示字符串中数字、  \n小写字母和大写字母的数量。\n\n示例：\n>>> count_chars_types(\"yLOI2022\")\n[4, 1, 3]\n>>> count_chars_types(\"IAKIOIOI\")\n[0, 0, 8]\n>>> count_chars_types(\"1n2s0e1s\")\n[4, 4, 0]",
      "fr": "Écrire une fonction ruby `def count_chars_types(s)` pour résoudre le problème suivant :\nCompte le nombre de chiffres, de lettres minuscules et de lettres majuscules dans une chaîne donnée.\nLa fonction prend un seul argument, s, qui est une chaîne de longueur 8,\net retourne un tableau avec trois entiers représentant le compte des chiffres,\ndes lettres minuscules et des lettres majuscules dans la chaîne, respectivement.\n\nExemples :\n>>> count_chars_types(\"yLOI2022\")\n[4, 1, 3]\n>>> count_chars_types(\"IAKIOIOI\")\n[0, 0, 8]\n>>> count_chars_types(\"1n2s0e1s\")\n[4, 4, 0]",
      "de": "Schreiben Sie eine Ruby-Funktion `def count_chars_types(s)`, um das folgende Problem zu lösen:\nZählt die Anzahl der Ziffern, Kleinbuchstaben und Großbuchstaben in einem gegebenen String.\n Die Funktion nimmt ein einzelnes Argument, s, das ein String der Länge 8 ist,\n und gibt ein Array mit drei ganzen Zahlen zurück, die die Anzahl der Ziffern,\n Kleinbuchstaben und Großbuchstaben im String darstellen.\n\n Beispiele:\n >>> count_chars_types(\"yLOI2022\")\n [4, 1, 3]\n >>> count_chars_types(\"IAKIOIOI\")\n [0, 0, 8]\n >>> count_chars_types(\"1n2s0e1s\")\n [4, 4, 0]",
      "ha": "Rubuta aikin ruby `def count_chars_types(s)` don warware matsalar mai zuwa:\nYana ƙidaya adadin lambobi, ƙananan haruffa, da manyan haruffa a cikin wani igiyar rubutu da aka bayar.\n Aikin yana ɗaukar hujja guda ɗaya, s, wanda igiyar rubutu ce mai tsawon 8,\n kuma yana mayar da wani jerin lambobi guda uku da ke wakiltar ƙidayar lambobi,\n ƙananan haruffa, da manyan haruffa a cikin igiyar rubutu, bi da bi.\n\n Misalai:\n >>> count_chars_types(\"yLOI2022\")\n [4, 1, 3]\n >>> count_chars_types(\"IAKIOIOI\")\n [0, 0, 8]\n >>> count_chars_types(\"1n2s0e1s\")\n [4, 4, 0]",
      "hi": "Ruby फ़ंक्शन `def count_chars_types(s)` लिखें ताकि निम्नलिखित समस्या का समाधान किया जा सके:\nदिए गए स्ट्रिंग में अंकों, छोटे अक्षरों, और बड़े अक्षरों की संख्या गिनें।\nयह फ़ंक्शन एक एकल तर्क लेता है, s, जो कि 8 लंबाई का एक स्ट्रिंग है,\nऔर एक array लौटाता है जिसमें तीन पूर्णांक होते हैं जो क्रमशः स्ट्रिंग में अंकों,\nछोटे अक्षरों, और बड़े अक्षरों की संख्या का प्रतिनिधित्व करते हैं।\n\nउदाहरण:\n>>> count_chars_types(\"yLOI2022\")\n[4, 1, 3]\n>>> count_chars_types(\"IAKIOIOI\")\n[0, 0, 8]\n>>> count_chars_types(\"1n2s0e1s\")\n[4, 4, 0]",
      "hu": "Írj egy ruby függvényt `def count_chars_types(s)` a következő probléma megoldására:\nMegszámolja a számjegyek, kisbetűk és nagybetűk számát egy adott sztringben.\n A függvény egyetlen argumentumot vesz fel, s, amely egy 8 hosszúságú sztring,\n és egy tömböt ad vissza három egész számmal, amelyek a számjegyek,\n kisbetűk és nagybetűk számát képviselik a sztringben, ebben a sorrendben.\n\n Példák:\n >>> count_chars_types(\"yLOI2022\")\n [4, 1, 3]\n >>> count_chars_types(\"IAKIOIOI\")\n [0, 0, 8]\n >>> count_chars_types(\"1n2s0e1s\")\n [4, 4, 0]"
    },
    "instruction_bertscore": {
      "sq": "0.9940236090954223",
      "hy": "0.9893071306977489",
      "bn": "0.9785457339140406",
      "bg": "0.9921111957868184",
      "zh": "0.970975334201658",
      "fr": "0.9949968979624932",
      "de": "0.9896036858566339",
      "ha": "0.9877107383253715",
      "hi": "0.9733728029007491",
      "hu": "0.9843914260278974"
    },
    "level": "easy",
    "test": "raise 'Test failed' unless count_chars_types(\"yLOI2022\") == [4, 1, 3]\nraise 'Test failed' unless count_chars_types(\"IAKIOIOI\") == [0, 0, 8]\nraise 'Test failed' unless count_chars_types(\"1n2s0e1s\") == [4, 4, 0]\nraise 'Test failed' unless count_chars_types(\"12345678\") == [8, 0, 0]\nraise 'Test failed' unless count_chars_types(\"abcdefgh\") == [0, 8, 0]",
    "entry_point": "count_chars_types",
    "signature": "def count_chars_types(s)",
    "docstring": {
      "en": "Counts the number of digits, lowercase letters, and uppercase letters in a given string.\n The function takes a single argument, s, which is a string of length 8,\n and returns an array with three integers representing the count of digits,\n lowercase letters, and uppercase letters in the string, respectively.\n\n Examples:\n >>> count_chars_types(\"yLOI2022\")\n [4, 1, 3]\n >>> count_chars_types(\"IAKIOIOI\")\n [0, 0, 8]\n >>> count_chars_types(\"1n2s0e1s\")\n [4, 4, 0]",
      "sq": "Numëron numrin e shifrave, shkronjave të vogla dhe shkronjave të mëdha në një varg të dhënë.\n Funksioni merr një argument të vetëm, s, i cili është një varg me gjatësi 8,\n dhe kthen një varg me tre numra të plotë që përfaqësojnë numrin e shifrave,\n shkronjave të vogla dhe shkronjave të mëdha në varg, përkatësisht.\n\n Shembuj:\n >>> count_chars_types(\"yLOI2022\")\n [4, 1, 3]\n >>> count_chars_types(\"IAKIOIOI\")\n [0, 0, 8]\n >>> count_chars_types(\"1n2s0e1s\")\n [4, 4, 0]",
      "hy": "Հաշվում է թվանշանների, փոքրատառերի և մեծատառերի քանակը տրված տողում։ \nՖունկցիան ընդունում է մեկ արգումենտ, s, որը 8 երկարությամբ տող է, \nև վերադարձնում է զանգված երեք ամբողջ թվերով, որոնք ներկայացնում են թվանշանների, \nփոքրատառերի և մեծատառերի քանակը տողում, համապատասխանաբար։\n\nՕրինակներ:\n>>> count_chars_types(\"yLOI2022\")\n[4, 1, 3]\n>>> count_chars_types(\"IAKIOIOI\")\n[0, 0, 8]\n>>> count_chars_types(\"1n2s0e1s\")\n[4, 4, 0]",
      "bn": "সংখ্যা, ছোট হাতের অক্ষর এবং বড় হাতের অক্ষরের সংখ্যা গণনা করে একটি প্রদত্ত স্ট্রিং-এ। ফাংশনটি একটি একক আর্গুমেন্ট গ্রহণ করে, s, যা একটি 8 দৈর্ঘ্যের স্ট্রিং, এবং একটি অ্যারে ফেরত দেয় যা তিনটি পূর্ণসংখ্যা নিয়ে গঠিত যা যথাক্রমে স্ট্রিং-এ সংখ্যা, ছোট হাতের অক্ষর এবং বড় হাতের অক্ষরের সংখ্যা উপস্থাপন করে।\n\nউদাহরণ:\n>>> count_chars_types(\"yLOI2022\")\n[4, 1, 3]\n>>> count_chars_types(\"IAKIOIOI\")\n[0, 0, 8]\n>>> count_chars_types(\"1n2s0e1s\")\n[4, 4, 0]",
      "bg": "Брои броя на цифрите, малките букви и главните букви в даден низ. \nФункцията приема един аргумент, s, който е низ с дължина 8, \nи връща масив с три цели числа, представляващи броя на цифрите, \nмалките букви и главните букви в низа, съответно.\n\nПримери:\n>>> count_chars_types(\"yLOI2022\")\n[4, 1, 3]\n>>> count_chars_types(\"IAKIOIOI\")\n[0, 0, 8]\n>>> count_chars_types(\"1n2s0e1s\")\n[4, 4, 0]",
      "zh": "计算给定字符串中数字、小写字母和大写字母的数量。\n该函数接受一个参数 s，它是一个长度为 8 的字符串，\n并返回一个包含三个整数的数组，分别表示字符串中数字、\n小写字母和大写字母的数量。\n\n示例：\n>>> count_chars_types(\"yLOI2022\")\n[4, 1, 3]\n>>> count_chars_types(\"IAKIOIOI\")\n[0, 0, 8]\n>>> count_chars_types(\"1n2s0e1s\")\n[4, 4, 0]",
      "fr": "Compte le nombre de chiffres, de lettres minuscules et de lettres majuscules dans une chaîne donnée. La fonction prend un seul argument, s, qui est une chaîne de longueur 8, et renvoie un tableau avec trois entiers représentant le compte des chiffres, des lettres minuscules et des lettres majuscules dans la chaîne, respectivement.\n\nExemples :\n>>> count_chars_types(\"yLOI2022\")\n[4, 1, 3]\n>>> count_chars_types(\"IAKIOIOI\")\n[0, 0, 8]\n>>> count_chars_types(\"1n2s0e1s\")\n[4, 4, 0]",
      "de": "Zählt die Anzahl der Ziffern, Kleinbuchstaben und Großbuchstaben in einem gegebenen String. Die Funktion nimmt ein einzelnes Argument, s, das ein String der Länge 8 ist, und gibt ein Array mit drei ganzen Zahlen zurück, die die Anzahl der Ziffern, Kleinbuchstaben und Großbuchstaben im String darstellen.\n\nBeispiele:\n>>> count_chars_types(\"yLOI2022\")\n[4, 1, 3]\n>>> count_chars_types(\"IAKIOIOI\")\n[0, 0, 8]\n>>> count_chars_types(\"1n2s0e1s\")\n[4, 4, 0]",
      "ha": "Yana ƙididdige adadin lambobi, ƙananan haruffa, da manyan haruffa a cikin wani baƙaƙe da aka bayar. \nAikin yana ɗaukar hujja guda ɗaya, s, wanda shine baƙaƙe na tsawon 8, \nkuma yana dawo da jerin lambobi uku da ke wakiltar ƙididdigar lambobi, \nƙananan haruffa, da manyan haruffa a cikin baƙaƙen, bi da bi.\n\nMisalai:\n>>> count_chars_types(\"yLOI2022\")\n[4, 1, 3]\n>>> count_chars_types(\"IAKIOIOI\")\n[0, 0, 8]\n>>> count_chars_types(\"1n2s0e1s\")\n[4, 4, 0]",
      "hi": "अक्षरों, छोटे अक्षरों, और बड़े अक्षरों की संख्या को गिने एक दिए गए स्ट्रिंग में।\nयह फ़ंक्शन एकल तर्क लेता है, s, जो कि 8 लंबाई का एक स्ट्रिंग है,\nऔर एक सरणी लौटाता है जिसमें तीन पूर्णांक होते हैं जो क्रमशः स्ट्रिंग में अंकों,\nछोटे अक्षरों, और बड़े अक्षरों की गिनती का प्रतिनिधित्व करते हैं।\n\nउदाहरण:\n>>> count_chars_types(\"yLOI2022\")\n[4, 1, 3]\n>>> count_chars_types(\"IAKIOIOI\")\n[0, 0, 8]\n>>> count_chars_types(\"1n2s0e1s\")\n[4, 4, 0]",
      "hu": "Számolja meg a számjegyek, kisbetűk és nagybetűk számát egy adott sztringben. A függvény egyetlen argumentumot vesz fel, s, amely egy 8 karakter hosszú sztring, és egy tömböt ad vissza három egész számmal, amelyek a számjegyek, kisbetűk és nagybetűk számát jelölik a sztringben, sorrendben.\n\nPéldák:\n>>> count_chars_types(\"yLOI2022\")\n[4, 1, 3]\n>>> count_chars_types(\"IAKIOIOI\")\n[0, 0, 8]\n>>> count_chars_types(\"1n2s0e1s\")\n[4, 4, 0]"
    },
    "docstring_bertscore": {
      "sq": "0.9894062472578853",
      "hy": "0.9787832958497584",
      "bn": "0.9893637403563438",
      "bg": "0.995331987415299",
      "zh": "0.9601050879691427",
      "fr": "0.9944625822375094",
      "de": "0.9866431000273089",
      "ha": "0.9827453760602614",
      "hi": "0.9909442422982384",
      "hu": "0.9796099954956257"
    }
  }
]