[
  {
    "task_id": "TypeScript/1",
    "prompt": {
      "en": "\n// return \"Hello, MMCODEEVAL: Masssively Multilingual Code Evaluation\"\nfunction hello_mmcodeeval(): string",
      "sq": "// kthen \"Hello, MMCODEEVAL: Masssively Multilingual Code Evaluation\"\nfunction hello_mmcodeeval(): string",
      "hy": "// վերադարձնել \"Hello, MMCODEEVAL: Masssively Multilingual Code Evaluation\"\nfunction hello_mmcodeeval(): string",
      "bn": "// \"হ্যালো, MMCODEEVAL: ব্যাপকভাবে বহু ভাষার কোড মূল্যায়ন\" ফেরত দিন\nfunction hello_mmcodeeval(): string",
      "bg": "// връща \"Hello, MMCODEEVAL: Masssively Multilingual Code Evaluation\"\nfunction hello_mmcodeeval(): string",
      "zh": "// 返回 \"Hello, MMCODEEVAL: Masssively Multilingual Code Evaluation\"\nfunction hello_mmcodeeval(): string",
      "fr": "// renvoyer \"Hello, MMCODEEVAL: Masssively Multilingual Code Evaluation\"\nfunction hello_mmcodeeval(): string",
      "de": "// Rückgabe \"Hello, MMCODEEVAL: Masssively Multilingual Code Evaluation\"\nfunction hello_mmcodeeval(): string",
      "ha": "// mayar da \"Hello, MMCODEEVAL: Masssively Multilingual Code Evaluation\"\nfunction hello_mmcodeeval(): string",
      "hi": "// \"Hello, MMCODEEVAL: Masssively Multilingual Code Evaluation\" लौटाएं\nfunction hello_mmcodeeval(): string",
      "hu": "// adja vissza a \"Hello, MMCODEEVAL: Masssively Multilingual Code Evaluation\""
    },
    "prompt_bertscore": {
      "sq": "0.9927956760798646",
      "hy": "1",
      "bn": "0.9160365543719804",
      "bg": "0.9927956760798646",
      "zh": "0.9955177068215667",
      "fr": "1",
      "de": "0.9955177068215667",
      "ha": "1",
      "hi": "0.9955177068215667",
      "hu": "0.8490569994743488"
    },
    "canonical_solution": "{\n    return \"Hello, MMCODEEVAL: Masssively Multilingual Code Evaluation\";\n}",
    "instruction": {
      "en": "Write a TypeScript function `function hello_mmcodeeval(): string` to solve the following problem:\nreturn \"Hello, MMCODEEVAL: Massively Multilingual Code Evaluation\"",
      "sq": "Shkruani një funksion TypeScript `function hello_mmcodeeval(): string` për të zgjidhur problemin e mëposhtëm:  \nkthe \"Hello, MMCODEEVAL: Massively Multilingual Code Evaluation\"",
      "hy": "Գրեք TypeScript ֆունկցիա `function hello_mmcodeeval(): string` հետևյալ խնդիրը լուծելու համար:\nվերադարձնել \"Hello, MMCODEEVAL: Massively Multilingual Code Evaluation\"",
      "bn": "একটি TypeScript ফাংশন `function hello_mmcodeeval(): string` লিখুন নিম্নলিখিত সমস্যার সমাধানের জন্য:  \nreturn \"Hello, MMCODEEVAL: Massively Multilingual Code Evaluation\"",
      "bg": "Напишете функция на TypeScript `function hello_mmcodeeval(): string`, за да решите следния проблем:  \nвръщане на \"Hello, MMCODEEVAL: Massively Multilingual Code Evaluation\"",
      "zh": "编写一个 TypeScript 函数 `function hello_mmcodeeval(): string` 来解决以下问题：  \n返回 \"Hello, MMCODEEVAL: Massively Multilingual Code Evaluation\"",
      "fr": "Écrire une fonction TypeScript `function hello_mmcodeeval(): string` pour résoudre le problème suivant :  \nretourner \"Hello, MMCODEEVAL: Massively Multilingual Code Evaluation\"",
      "de": "Schreiben Sie eine TypeScript-Funktion `function hello_mmcodeeval(): string`, um das folgende Problem zu lösen:  \nreturn \"Hello, MMCODEEVAL: Massively Multilingual Code Evaluation\"",
      "ha": "Rubuta aikin TypeScript `function hello_mmcodeeval(): string` don warware matsalar mai zuwa:\nmayar da \"Hello, MMCODEEVAL: Massively Multilingual Code Evaluation\"",
      "hi": "TypeScript फ़ंक्शन `function hello_mmcodeeval(): string` लिखें ताकि निम्नलिखित समस्या का समाधान हो सके:\n\"Hello, MMCODEEVAL: Massively Multilingual Code Evaluation\" लौटाएं",
      "hu": "Írj egy TypeScript függvényt `function hello_mmcodeeval(): string` a következő probléma megoldására:  \nvisszaadja a \"Hello, MMCODEEVAL: Massively Multilingual Code Evaluation\" szöveget"
    },
    "instruction_bertscore": {
      "sq": "1",
      "hy": "1",
      "bn": "1",
      "bg": "0.9871929089220135",
      "zh": "0.9949186375923655",
      "fr": "1",
      "de": "1",
      "ha": "1",
      "hi": "0.48589372450416446",
      "hu": "0.9740934339231436"
    },
    "level": "easy",
    "test": "(() => {\n    console.assert(hello_mmcodeeval() === \"Hello, MMCODEEVAL: Masssively Multilingual Code Evaluation\");\n})();",
    "entry_point": "hello_mmcodeeval",
    "signature": "function hello_mmcodeeval(): string",
    "docstring": {
      "en": "return \"Hello, MMCODEEVAL: Massively Multilingual Code Evaluation\"",
      "sq": "return \"Hello, MMCODEEVAL: Massively Multilingual Code Evaluation\"",
      "hy": "return \"Hello, MMCODEEVAL: Massively Multilingual Code Evaluation\"",
      "bn": "return \"Hello, MMCODEEVAL: Massively Multilingual Code Evaluation\"",
      "bg": "return \"Hello, MMCODEEVAL: Масово многоезична оценка на код\"",
      "zh": "return \"Hello, MMCODEEVAL: Massively Multilingual Code Evaluation\"",
      "fr": "return \"Hello, MMCODEEVAL: Évaluation de code massivement multilingue\"",
      "de": "return \"Hello, MMCODEEVAL: Massively Multilingual Code Evaluation\"",
      "ha": "return \"Hello, MMCODEEVAL: Massively Multilingual Code Evaluation\"",
      "hi": "return \"Hello, MMCODEEVAL: Massively Multilingual Code Evaluation\"",
      "hu": "return \"Hello, MMCODEEVAL: Tömeges Többnyelvű Kódértékelés\""
    },
    "docstring_bertscore": {
      "sq": "1",
      "hy": "1",
      "bn": "1",
      "bg": "0.9613445415468004",
      "zh": "1",
      "fr": "1",
      "de": "1",
      "ha": "1",
      "hi": "1",
      "hu": "0.9613445415468004"
    }
  },
  {
    "task_id": "TypeScript/2",
    "prompt": {
      "en": "\n/**\n * Calculate the area of a triangle given its three sides.\n * \n * @param a - Length of side 'a'.\n * @param b - Length of side 'b'.\n * @param c - Length of side 'c'.\n * @returns If the provided sides form a triangle, return the calculated area with 2 decimal places.\n *          Otherwise, return \"-1\".\n * \n * @example\n * calculateTriangleArea(3, 5, 4)  // 6\n */\nfunction calculateTriangleArea(a: number, b: number, c: number): number",
      "sq": "/**\n * Llogarit sipërfaqen e një trekëndëshi duke pasur parasysh tre anët e tij.\n * \n * @param a - Gjatësia e anës 'a'.\n * @param b - Gjatësia e anës 'b'.\n * @param c - Gjatësia e anës 'c'.\n * @returns Nëse anët e dhëna formojnë një trekëndësh, kthen sipërfaqen e llogaritur me 2 vende dhjetore.\n *          Përndryshe, kthen \"-1\".\n * \n * @example\n * calculateTriangleArea(3, 5, 4)  // 6\n */\nfunction calculateTriangleArea(a: number, b: number, c: number): number",
      "hy": "/**\n * Հաշվարկել եռանկյան մակերեսը, եթե տրված են նրա երեք կողմերը։\n * \n * @param a - Կողմ 'a'-ի երկարությունը։\n * @param b - Կողմ 'b'-ի երկարությունը։\n * @param c - Կողմ 'c'-ի երկարությունը։\n * @returns Եթե տրված կողմերը կազմում են եռանկյուն, վերադարձնել հաշվարկված մակերեսը 2 տասնորդական թվանշանով։\n *          Հակառակ դեպքում, վերադարձնել \"-1\"։\n * \n * @example\n * calculateTriangleArea(3, 5, 4)  // 6\n */\nfunction calculateTriangleArea(a: number, b: number, c: number): number",
      "bn": "/**\n * একটি ত্রিভুজের তিন বাহু দেওয়া থাকলে তার ক্ষেত্রফল গণনা করুন।\n * \n * @param a - বাহু 'a' এর দৈর্ঘ্য।\n * @param b - বাহু 'b' এর দৈর্ঘ্য।\n * @param c - বাহু 'c' এর দৈর্ঘ্য।\n * @returns যদি প্রদত্ত বাহুগুলি একটি ত্রিভুজ গঠন করে, তবে 2 দশমিক স্থানে গণনা করা ক্ষেত্রফল ফেরত দিন।\n *          অন্যথায়, \"-1\" ফেরত দিন।\n * \n * @example\n * calculateTriangleArea(3, 5, 4)  // 6\n */\nfunction calculateTriangleArea(a: number, b: number, c: number): number",
      "bg": "/**\n * Изчислява площта на триъгълник, дадени неговите три страни.\n * \n * @param a - Дължина на страна 'a'.\n * @param b - Дължина на страна 'b'.\n * @param c - Дължина на страна 'c'.\n * @returns Ако предоставените страни образуват триъгълник, връща изчислената площ с 2 десетични знака.\n *          В противен случай, връща \"-1\".\n * \n * @example\n * calculateTriangleArea(3, 5, 4)  // 6\n */\nfunction calculateTriangleArea(a: number, b: number, c: number): number",
      "zh": "/**\n * 计算给定三边的三角形面积。\n * \n * @param a - 边 'a' 的长度。\n * @param b - 边 'b' 的长度。\n * @param c - 边 'c' 的长度。\n * @returns 如果提供的边能够构成三角形，返回计算出的面积，保留两位小数。\n *          否则，返回 \"-1\"。\n * \n * @example\n * calculateTriangleArea(3, 5, 4)  // 6\n */\nfunction calculateTriangleArea(a: number, b: number, c: number): number",
      "fr": "/**\n * Calculer l'aire d'un triangle donné par ses trois côtés.\n * \n * @param a - Longueur du côté 'a'.\n * @param b - Longueur du côté 'b'.\n * @param c - Longueur du côté 'c'.\n * @returns Si les côtés fournis forment un triangle, retourne l'aire calculée avec 2 décimales.\n *          Sinon, retourne \"-1\".\n * \n * @example\n * calculateTriangleArea(3, 5, 4)  // 6\n */\nfunction calculateTriangleArea(a: number, b: number, c: number): number",
      "de": "/**\n * Berechne die Fläche eines Dreiecks, gegeben seine drei Seiten.\n * \n * @param a - Länge der Seite 'a'.\n * @param b - Länge der Seite 'b'.\n * @param c - Länge der Seite 'c'.\n * @returns Wenn die angegebenen Seiten ein Dreieck bilden, gib die berechnete Fläche mit 2 Dezimalstellen zurück.\n *          Andernfalls gib \"-1\" zurück.\n * \n * @example\n * calculateTriangleArea(3, 5, 4)  // 6\n */\nfunction calculateTriangleArea(a: number, b: number, c: number): number",
      "ha": "/**\n * Lissafin yankin wani kusurwar mai kusurwa uku idan aka ba da bangarorinsa uku.\n * \n * @param a - Tsawon gefen 'a'.\n * @param b - Tsawon gefen 'b'.\n * @param c - Tsawon gefen 'c'.\n * @returns Idan bangarorin da aka bayar sun samar da kusurwar mai kusurwa uku, dawo da yankin da aka lissafa tare da wurare guda biyu na goma.\n *          In ba haka ba, dawo da \"-1\".\n * \n * @example\n * calculateTriangleArea(3, 5, 4)  // 6\n */\nfunction calculateTriangleArea(a: number, b: number, c: number): number",
      "hi": "/**\n * दिए गए तीन भुजाओं के आधार पर एक त्रिभुज का क्षेत्रफल गणना करें।\n * \n * @param a - भुजा 'a' की लंबाई।\n * @param b - भुजा 'b' की लंबाई।\n * @param c - भुजा 'c' की लंबाई।\n * @returns यदि दी गई भुजाएँ एक त्रिभुज बनाती हैं, तो गणना किया गया क्षेत्रफल 2 दशमलव स्थानों के साथ लौटाएं।\n *          अन्यथा, \"-1\" लौटाएं।\n * \n * @example\n * calculateTriangleArea(3, 5, 4)  // 6\n */\nfunction calculateTriangleArea(a: number, b: number, c: number): number",
      "hu": "/**\n * Számítsa ki egy háromszög területét a három oldalának megadásával.\n * \n * @param a - Az 'a' oldal hossza.\n * @param b - A 'b' oldal hossza.\n * @param c - A 'c' oldal hossza.\n * @returns Ha a megadott oldalak háromszöget alkotnak, adja vissza a kiszámított területet 2 tizedesjegyre kerekítve.\n *          Ellenkező esetben adja vissza \"-1\".\n * \n * @example\n * calculateTriangleArea(3, 5, 4)  // 6\n */\nfunction calculateTriangleArea(a: number, b: number, c: number): number"
    },
    "prompt_bertscore": {
      "sq": "0.9941280886758467",
      "hy": "0.9965164203774102",
      "bn": "0.9928109706192043",
      "bg": "0.9960055430373884",
      "zh": "0.9827088280701509",
      "fr": "0.980443249944067",
      "de": "0.9928878405766648",
      "ha": "0.9957290495469878",
      "hi": "0.9829394379425325",
      "hu": "0.9632678795263613"
    },
    "canonical_solution": "{\n    if (a + b > c && a + c > b && b + c > a) {\n        const s: number = (a + b + c) / 2.0;\n        return parseFloat(Math.sqrt(s * (s - a) * (s - b) * (s - c)).toFixed(2));\n    } else {\n        return -1; // Use a special value to indicate not a triangle\n    }\n}",
    "instruction": {
      "en": "Write a TypeScript function `function calculateTriangleArea(a: number, b: number, c: number): number` to solve the following problem:\nCalculate the area of a triangle given its three sides.\n\n@param a - Length of side 'a'.\n@param b - Length of side 'b'.\n@param c - Length of side 'c'.\n@returns If the provided sides form a triangle, return the calculated area with 2 decimal places.\n         Otherwise, return \"-1\".\n\n@example\ncalculateTriangleArea(3, 5, 4)  // 6",
      "sq": "Shkruani një funksion TypeScript `function calculateTriangleArea(a: number, b: number, c: number): number` për të zgjidhur problemin e mëposhtëm:\nLlogaritni sipërfaqen e një trekëndëshi të dhënë tre anët e tij.\n\n@param a - Gjatësia e anës 'a'.\n@param b - Gjatësia e anës 'b'.\n@param c - Gjatësia e anës 'c'.\n@returns Nëse anët e dhëna formojnë një trekëndësh, kthejeni sipërfaqen e llogaritur me 2 vende dhjetore.\n         Përndryshe, kthe \"-1\".\n\n@example\ncalculateTriangleArea(3, 5, 4)  // 6",
      "hy": "TypeScript ֆունկցիա գրեք `function calculateTriangleArea(a: number, b: number, c: number): number` հետևյալ խնդիրը լուծելու համար:\nՀաշվեք եռանկյան մակերեսը, եթե տրված են նրա երեք կողմերը։\n\n@param a - Կողմ 'a'-ի երկարությունը։\n@param b - Կողմ 'b'-ի երկարությունը։\n@param c - Կողմ 'c'-ի երկարությունը։\n@returns Եթե տրված կողմերը կազմում են եռանկյուն, վերադարձնել հաշվարկված մակերեսը 2 տասնորդական թվանշաններով։\n         Հակառակ դեպքում վերադարձնել \"-1\"։\n\n@example\ncalculateTriangleArea(3, 5, 4)  // 6",
      "bn": "TypeScript ফাংশন `function calculateTriangleArea(a: number, b: number, c: number): number` লিখুন নিম্নলিখিত সমস্যার সমাধানের জন্য:\nতিনটি বাহু দেওয়া থাকলে একটি ত্রিভুজের ক্ষেত্রফল গণনা করুন।\n\n@param a - বাহু 'a' এর দৈর্ঘ্য।\n@param b - বাহু 'b' এর দৈর্ঘ্য।\n@param c - বাহু 'c' এর দৈর্ঘ্য।\n@returns যদি প্রদত্ত বাহুগুলি একটি ত্রিভুজ তৈরি করে, তবে গণনা করা ক্ষেত্রফল 2 দশমিক স্থান পর্যন্ত ফেরত দিন।\n         অন্যথায়, \"-1\" ফেরত দিন।\n\n@example\ncalculateTriangleArea(3, 5, 4)  // 6",
      "bg": "Напишете функция на TypeScript `function calculateTriangleArea(a: number, b: number, c: number): number`, за да решите следния проблем:\nИзчислете площта на триъгълник, дадени неговите три страни.\n\n@param a - Дължина на страна 'a'.\n@param b - Дължина на страна 'b'.\n@param c - Дължина на страна 'c'.\n@returns Ако предоставените страни образуват триъгълник, върнете изчислената площ с 2 знака след десетичната запетая.\n         В противен случай, върнете \"-1\".\n\n@example\ncalculateTriangleArea(3, 5, 4)  // 6",
      "zh": "编写一个 TypeScript 函数 `function calculateTriangleArea(a: number, b: number, c: number): number` 来解决以下问题：\n计算给定三边的三角形面积。\n\n@param a - 边 'a' 的长度。\n@param b - 边 'b' 的长度。\n@param c - 边 'c' 的长度。\n@returns 如果提供的边能够构成一个三角形，返回计算出的面积，保留两位小数。\n         否则，返回 \"-1\"。\n\n@example\ncalculateTriangleArea(3, 5, 4)  // 6",
      "fr": "Écrire une fonction TypeScript `function calculateTriangleArea(a: number, b: number, c: number): number` pour résoudre le problème suivant :\nCalculer l'aire d'un triangle donné ses trois côtés.\n\n@param a - Longueur du côté 'a'.\n@param b - Longueur du côté 'b'.\n@param c - Longueur du côté 'c'.\n@returns Si les côtés fournis forment un triangle, retourner l'aire calculée avec 2 décimales.\n         Sinon, retourner \"-1\".\n\n@example\ncalculateTriangleArea(3, 5, 4)  // 6",
      "de": "Schreiben Sie eine TypeScript-Funktion `function calculateTriangleArea(a: number, b: number, c: number): number`, um das folgende Problem zu lösen:\nBerechnen Sie die Fläche eines Dreiecks, gegeben seine drei Seiten.\n\n@param a - Länge der Seite 'a'.\n@param b - Länge der Seite 'b'.\n@param c - Länge der Seite 'c'.\n@returns Wenn die angegebenen Seiten ein Dreieck bilden, geben Sie die berechnete Fläche mit 2 Dezimalstellen zurück.\n         Andernfalls geben Sie \"-1\" zurück.\n\n@example\ncalculateTriangleArea(3, 5, 4)  // 6",
      "ha": "Rubuta aikin TypeScript `function calculateTriangleArea(a: number, b: number, c: number): number` don warware matsalar mai zuwa:\nƘididdige yanki na alwatika idan aka ba da gefen ta uku.\n\n@param a - Tsawon gefen 'a'.\n@param b - Tsawon gefen 'b'.\n@param c - Tsawon gefen 'c'.\n@returns Idan gefen da aka bayar sun samar da alwatika, dawo da yankin da aka ƙididdige tare da wurare guda 2 na goma.\n         In ba haka ba, dawo da \"-1\".\n\n@example\ncalculateTriangleArea(3, 5, 4)  // 6",
      "hi": "TypeScript फ़ंक्शन `function calculateTriangleArea(a: number, b: number, c: number): number` लिखें ताकि निम्नलिखित समस्या का समाधान किया जा सके:\nइसके तीन भुजाओं के दिए गए माप के आधार पर एक त्रिभुज का क्षेत्रफल निकालें।\n\n@param a - भुजा 'a' की लंबाई।\n@param b - भुजा 'b' की लंबाई।\n@param c - भुजा 'c' की लंबाई।\n@returns यदि दी गई भुजाएँ एक त्रिभुज बनाती हैं, तो 2 दशमलव स्थानों के साथ गणना किया गया क्षेत्रफल लौटाएँ।\n         अन्यथा, \"-1\" लौटाएँ।\n\n@example\ncalculateTriangleArea(3, 5, 4)  // 6",
      "hu": "Írj egy TypeScript függvényt `function calculateTriangleArea(a: number, b: number, c: number): number` a következő probléma megoldására:\nSzámítsd ki egy háromszög területét a három oldalának ismeretében.\n\n@param a - Az 'a' oldal hossza.\n@param b - A 'b' oldal hossza.\n@param c - A 'c' oldal hossza.\n@returns Ha a megadott oldalak háromszöget alkotnak, térj vissza a kiszámított területtel 2 tizedesjegyre kerekítve.\n         Ellenkező esetben térj vissza \"-1\" értékkel.\n\n@example\ncalculateTriangleArea(3, 5, 4)  // 6"
    },
    "instruction_bertscore": {
      "sq": "0.9840426310788002",
      "hy": "0.984332035543968",
      "bn": "0.9714345676426107",
      "bg": "0.995662111108579",
      "zh": "0.9853065161933252",
      "fr": "0.999999801369619",
      "de": "0.9935063755832074",
      "ha": "0.9968620372404108",
      "hi": "0.9660473144481824",
      "hu": "0.9719305477040547"
    },
    "level": "easy",
    "test": "(() => {\n    let area: number;\n\n    // Triangle with sides 3, 5, 4 should return area 6\n    area = calculateTriangleArea(3, 5, 4);\n    console.assert(Math.abs(area - 6) < 1e-6);\n\n    // Not a triangle with sides 1, 1, 4 should return \"-1\"\n    area = calculateTriangleArea(1, 1, 4);\n    console.assert(area === -1);\n\n    // Triangle with sides 7, 24, 25 should return area 84\n    area = calculateTriangleArea(7, 24, 25);\n    console.assert(Math.abs(area - 84) < 1e-6);\n\n    // Triangle with sides 10.5, 6.2, 7.3 should return a correct area\n    area = calculateTriangleArea(10.5, 6.2, 7.3);\n    // For precision issues, we test if the calculated area is close enough to the expected value\n    console.assert(Math.abs(area - 22.15) < 1e-2);\n\n    // console.log(\"All tests passed successfully.\");\n})();",
    "entry_point": "calculateTriangleArea",
    "signature": "function calculateTriangleArea(a: number, b: number, c: number): number",
    "docstring": {
      "en": "Calculate the area of a triangle given its three sides.\n\n@param a - Length of side 'a'.\n@param b - Length of side 'b'.\n@param c - Length of side 'c'.\n@returns If the provided sides form a triangle, return the calculated area with 2 decimal places.\n         Otherwise, return \"-1\".\n\n@example\ncalculateTriangleArea(3, 5, 4)  // 6",
      "sq": "Llogarit sipërfaqen e një trekëndëshi duke pasur parasysh tre anët e tij.\n\n@param a - Gjatësia e anës 'a'.\n@param b - Gjatësia e anës 'b'.\n@param c - Gjatësia e anës 'c'.\n@returns Nëse anët e dhëna formojnë një trekëndësh, kthe sipërfaqen e llogaritur me 2 vende dhjetore.\n         Përndryshe, kthe \"-1\".\n\n@example\ncalculateTriangleArea(3, 5, 4)  // 6",
      "hy": "Հաշվարկել եռանկյան մակերեսը՝ հաշվի առնելով նրա երեք կողմերը։\n\n@param a - Կողմ 'a'-ի երկարությունը։\n@param b - Կողմ 'b'-ի երկարությունը։\n@param c - Կողմ 'c'-ի երկարությունը։\n@returns Եթե տրված կողմերը կազմում են եռանկյուն, վերադարձնել հաշվարկված մակերեսը՝ 2 տասնորդական թվանշանով։\n         Հակառակ դեպքում վերադարձնել \"-1\"։\n\n@example\ncalculateTriangleArea(3, 5, 4)  // 6",
      "bn": "Calculate the area of a triangle given its three sides.\n\n@param a - বাহু 'a' এর দৈর্ঘ্য।\n@param b - বাহু 'b' এর দৈর্ঘ্য।\n@param c - বাহু 'c' এর দৈর্ঘ্য।\n@returns যদি প্রদত্ত বাহুগুলি একটি ত্রিভুজ গঠন করে, তবে গণনা করা ক্ষেত্রফল 2 দশমিক স্থান পর্যন্ত প্রদান করে।\n         অন্যথায়, \"-1\" প্রদান করে।\n\n@example\ncalculateTriangleArea(3, 5, 4)  // 6",
      "bg": "Изчисляване на лицето на триъгълник, дадени са трите му страни.\n\n@param a - Дължина на страната 'a'.\n@param b - Дължина на страната 'b'.\n@param c - Дължина на страната 'c'.\n@returns Ако предоставените страни образуват триъгълник, връща изчисленото лице с 2 знака след десетичната запетая.\n         В противен случай връща \"-1\".\n\n@example\ncalculateTriangleArea(3, 5, 4)  // 6",
      "zh": "计算给定三边的三角形面积。\n\n@param a - 边 'a' 的长度。\n@param b - 边 'b' 的长度。\n@param c - 边 'c' 的长度。\n@returns 如果提供的边能构成一个三角形，返回计算出的面积，保留两位小数。\n         否则，返回 \"-1\"。\n\n@example\ncalculateTriangleArea(3, 5, 4)  // 6",
      "fr": "Calculer l'aire d'un triangle donné ses trois côtés.\n\n@param a - Longueur du côté 'a'.\n@param b - Longueur du côté 'b'.\n@param c - Longueur du côté 'c'.\n@returns Si les côtés fournis forment un triangle, retourne l'aire calculée avec 2 décimales.\n         Sinon, retourne \"-1\".\n\n@example\ncalculateTriangleArea(3, 5, 4)  // 6",
      "de": "Berechne die Fläche eines Dreiecks, gegeben durch seine drei Seiten.\n\n@param a - Länge der Seite 'a'.\n@param b - Länge der Seite 'b'.\n@param c - Länge der Seite 'c'.\n@returns Wenn die angegebenen Seiten ein Dreieck bilden, gib die berechnete Fläche mit 2 Dezimalstellen zurück.\n         Andernfalls gib \"-1\" zurück.\n\n@example\ncalculateTriangleArea(3, 5, 4)  // 6",
      "ha": "Calculate the area of a triangle given its three sides.\n\n@param a - Tsawon gefen 'a'.\n@param b - Tsawon gefen 'b'.\n@param c - Tsawon gefen 'c'.\n@returns Idan gefen da aka bayar sun samar da alwatika, dawo da yankin da aka ƙididdige tare da wurare guda 2 na decimal.\n         In ba haka ba, dawo da \"-1\".\n\n@example\ncalculateTriangleArea(3, 5, 4)  // 6",
      "hi": "त्रिभुज के तीन भुजाओं के आधार पर उसका क्षेत्रफल गणना करें।\n\n@param a - भुजा 'a' की लंबाई।\n@param b - भुजा 'b' की लंबाई।\n@param c - भुजा 'c' की लंबाई।\n@returns यदि दी गई भुजाएं एक त्रिभुज बनाती हैं, तो 2 दशमलव स्थानों के साथ गणना किया गया क्षेत्रफल लौटाएं।\n         अन्यथा, \"-1\" लौटाएं।\n\n@example\ncalculateTriangleArea(3, 5, 4)  // 6",
      "hu": "Számítsa ki egy háromszög területét a három oldalának ismeretében.\n\n@param a - Az 'a' oldal hossza.\n@param b - A 'b' oldal hossza.\n@param c - A 'c' oldal hossza.\n@returns Ha a megadott oldalak háromszöget alkotnak, térjen vissza a kiszámított területtel 2 tizedesjegy pontossággal.\n         Ellenkező esetben térjen vissza \"-1\" értékkel.\n\n@example\ncalculateTriangleArea(3, 5, 4)  // 6"
    },
    "docstring_bertscore": {
      "sq": "0.9953989258537078",
      "hy": "0.9953989258537078",
      "bn": "0.9846436866118118",
      "bg": "0.9891700757348348",
      "zh": "0.9639152159381539",
      "fr": "0.9743224547524769",
      "de": "0.9876310875425764",
      "ha": "0.9953989258537078",
      "hi": "0.9868691414009266",
      "hu": "0.9503225417031744"
    }
  },
  {
    "task_id": "TypeScript/3",
    "prompt": {
      "en": "\n/**\n * Calculate the value of the function for a given input.\n * \n * Parameters:\n * - x (number): Input value for the function.\n * \n * Returns:\n * - string: If x is not in the defined domain, returns \"Not define\".\n *   Otherwise, returns the calculated function value rounded to 5 decimal places.\n * \n * Function Definitions:\n * - For 0 <= x < 10: y = cos(x + 3.0)\n * - For 10 <= x < 20: y = (cos(x + 7.5))^2\n * - For 20 <= x < 30: y = (cos(x + 4.0))^4\n * \n * Example usage:\n * calculateFunctionValue(40); // Returns \"Not define\"\n */\nfunction calculateFunctionValue(x: number): string",
      "sq": "/**\n * Llogarit vlerën e funksionit për një hyrje të dhënë.\n * \n * Parametrat:\n * - x (numër): Vlera e hyrjes për funksionin.\n * \n * Kthen:\n * - string: Nëse x nuk është në domenin e përcaktuar, kthen \"Not define\".\n *   Përndryshe, kthen vlerën e llogaritur të funksionit të rrumbullakosur në 5 shifra dhjetore.\n * \n * Përcaktimet e Funksionit:\n * - Për 0 <= x < 10: y = cos(x + 3.0)\n * - Për 10 <= x < 20: y = (cos(x + 7.5))^2\n * - Për 20 <= x < 30: y = (cos(x + 4.0))^4\n * \n * Shembull përdorimi:\n * calculateFunctionValue(40); // Kthen \"Not define\"\n */\nfunction calculateFunctionValue(x: number): string",
      "hy": "/**\n * Հաշվել ֆունկցիայի արժեքը տրված մուտքային արժեքի համար։\n * \n * Պարամետրեր:\n * - x (թիվ): Մուտքային արժեք ֆունկցիայի համար։\n * \n * Վերադարձնում է:\n * - string: Եթե x-ը սահմանված տիրույթում չէ, վերադարձնում է \"Not define\"։\n *   Հակառակ դեպքում, վերադարձնում է հաշվարկված ֆունկցիայի արժեքը, կլորացված մինչև 5 տասնորդական նշան։\n * \n * Ֆունկցիայի սահմանումներ:\n * - 0 <= x < 10: y = cos(x + 3.0)\n * - 10 <= x < 20: y = (cos(x + 7.5))^2\n * - 20 <= x < 30: y = (cos(x + 4.0))^4\n * \n * Օրինակ օգտագործում:\n * calculateFunctionValue(40); // Վերադարձնում է \"Not define\"\n */\nfunction calculateFunctionValue(x: number): string",
      "bn": "/**\n * প্রদত্ত ইনপুটের জন্য ফাংশনের মান গণনা করুন।\n * \n * প্যারামিটার:\n * - x (number): ফাংশনের জন্য ইনপুট মান।\n * \n * রিটার্ন:\n * - string: যদি x সংজ্ঞায়িত ডোমেইনে না থাকে, তাহলে \"Not define\" রিটার্ন করে।\n *   অন্যথায়, গণনা করা ফাংশনের মান 5 দশমিক স্থানে রাউন্ড করে রিটার্ন করে।\n * \n * ফাংশনের সংজ্ঞা:\n * - 0 <= x < 10 এর জন্য: y = cos(x + 3.0)\n * - 10 <= x < 20 এর জন্য: y = (cos(x + 7.5))^2\n * - 20 <= x < 30 এর জন্য: y = (cos(x + 4.0))^4\n * \n * উদাহরণ ব্যবহার:\n * calculateFunctionValue(40); // \"Not define\" রিটার্ন করে\n */\nfunction calculateFunctionValue(x: number): string",
      "bg": "/**\n * Изчислява стойността на функцията за даден вход.\n * \n * Параметри:\n * - x (number): Входна стойност за функцията.\n * \n * Връща:\n * - string: Ако x не е в определения домейн, връща \"Not define\".\n *   В противен случай, връща изчислената стойност на функцията, закръглена до 5 десетични знака.\n * \n * Дефиниции на функцията:\n * - За 0 <= x < 10: y = cos(x + 3.0)\n * - За 10 <= x < 20: y = (cos(x + 7.5))^2\n * - За 20 <= x < 30: y = (cos(x + 4.0))^4\n * \n * Пример за използване:\n * calculateFunctionValue(40); // Връща \"Not define\"\n */\nfunction calculateFunctionValue(x: number): string",
      "zh": "/**\n * 计算给定输入的函数值。\n * \n * 参数:\n * - x (number): 函数的输入值。\n * \n * 返回:\n * - string: 如果 x 不在定义域内，返回 \"Not define\"。\n *   否则，返回计算后的函数值，四舍五入到小数点后5位。\n * \n * 函数定义:\n * - 对于 0 <= x < 10: y = cos(x + 3.0)\n * - 对于 10 <= x < 20: y = (cos(x + 7.5))^2\n * - 对于 20 <= x < 30: y = (cos(x + 4.0))^4\n * \n * 示例用法:\n * calculateFunctionValue(40); // 返回 \"Not define\"\n */\nfunction calculateFunctionValue(x: number): string",
      "fr": "/**\n * Calculer la valeur de la fonction pour une entrée donnée.\n * \n * Paramètres:\n * - x (nombre): Valeur d'entrée pour la fonction.\n * \n * Renvoie:\n * - string: Si x n'est pas dans le domaine défini, renvoie \"Not define\".\n *   Sinon, renvoie la valeur calculée de la fonction arrondie à 5 décimales.\n * \n * Définitions de la fonction:\n * - Pour 0 <= x < 10: y = cos(x + 3.0)\n * - Pour 10 <= x < 20: y = (cos(x + 7.5))^2\n * - Pour 20 <= x < 30: y = (cos(x + 4.0))^4\n * \n * Exemple d'utilisation:\n * calculateFunctionValue(40); // Returns \"Not define\"\n */\nfunction calculateFunctionValue(x: number): string",
      "de": "/**\n * Berechnet den Wert der Funktion für eine gegebene Eingabe.\n * \n * Parameter:\n * - x (number): Eingabewert für die Funktion.\n * \n * Rückgabe:\n * - string: Wenn x nicht im definierten Bereich liegt, wird \"Not define\" zurückgegeben.\n *   Andernfalls wird der berechnete Funktionswert auf 5 Dezimalstellen gerundet zurückgegeben.\n * \n * Funktionsdefinitionen:\n * - Für 0 <= x < 10: y = cos(x + 3.0)\n * - Für 10 <= x < 20: y = (cos(x + 7.5))^2\n * - Für 20 <= x < 30: y = (cos(x + 4.0))^4\n * \n * Beispielverwendung:\n * calculateFunctionValue(40); // Gibt \"Not define\" zurück\n */\nfunction calculateFunctionValue(x: number): string",
      "ha": "/**\n * Lissafa darajar aikin don wani shigarwar.\n * \n * Sigogi:\n * - x (namba): Shigarwar darajar aikin.\n * \n * Komawa:\n * - string: Idan x ba ya cikin kewayon da aka ayyana, yana mayar da \"Not define\".\n *   In ba haka ba, yana mayar da darajar aikin da aka lissafa an zagaye zuwa wurare 5 na bayan faɗi.\n * \n * Ma'anar Aiki:\n * - Don 0 <= x < 10: y = cos(x + 3.0)\n * - Don 10 <= x < 20: y = (cos(x + 7.5))^2\n * - Don 20 <= x < 30: y = (cos(x + 4.0))^4\n * \n * Misalin amfani:\n * calculateFunctionValue(40); // Yana mayar da \"Not define\"\n */\nfunction calculateFunctionValue(x: number): string",
      "hi": "/**\n * दिए गए इनपुट के लिए फ़ंक्शन का मान गणना करें।\n * \n * पैरामीटर्स:\n * - x (number): फ़ंक्शन के लिए इनपुट मान।\n * \n * रिटर्न्स:\n * - string: यदि x परिभाषित डोमेन में नहीं है, तो \"Not define\" लौटाता है।\n *   अन्यथा, गणना किए गए फ़ंक्शन मान को 5 दशमलव स्थानों तक राउंड करके लौटाता है।\n * \n * फ़ंक्शन परिभाषाएँ:\n * - 0 <= x < 10 के लिए: y = cos(x + 3.0)\n * - 10 <= x < 20 के लिए: y = (cos(x + 7.5))^2\n * - 20 <= x < 30 के लिए: y = (cos(x + 4.0))^4\n * \n * उदाहरण उपयोग:\n * calculateFunctionValue(40); // \"Not define\" लौटाता है\n */\nfunction calculateFunctionValue(x: number): string",
      "hu": "/**\n * Számítsa ki a függvény értékét egy adott bemenetre.\n * \n * Paraméterek:\n * - x (szám): A függvény bemeneti értéke.\n * \n * Visszatérési érték:\n * - string: Ha x nincs a meghatározott tartományban, \"Not define\" értéket ad vissza.\n *   Egyébként visszaadja a kiszámított függvényértéket 5 tizedesjegyre kerekítve.\n * \n * Függvénydefiníciók:\n * - Ha 0 <= x < 10: y = cos(x + 3.0)\n * - Ha 10 <= x < 20: y = (cos(x + 7.5))^2\n * - Ha 20 <= x < 30: y = (cos(x + 4.0))^4\n * \n * Példa használat:\n * calculateFunctionValue(40); // Visszaadja: \"Not define\"\n */\nfunction calculateFunctionValue(x: number): string"
    },
    "prompt_bertscore": {
      "sq": "0.9858535442626952",
      "hy": "0.9622965769631007",
      "bn": "0.980022352166654",
      "bg": "0.9842005422317229",
      "zh": "0.9798751670543072",
      "fr": "0.974260084812832",
      "de": "0.9733932618299956",
      "ha": "0.9845092138438511",
      "hi": "0.9896948572015289",
      "hu": "0.970838875129887"
    },
    "canonical_solution": "{\n    let y: number;\n\n    if (0 <= x && x < 10) {\n        y = Math.cos(x + 3.0);\n        return y.toFixed(5);\n    } else if (10 <= x && x < 20) {\n        y = Math.cos(x + 7.5);\n        return (y * y).toFixed(5);\n    } else if (20 <= x && x < 30) {\n        y = Math.cos(x + 4.0);\n        return Math.pow(y, 4).toFixed(5);\n    } else {\n        return \"Not define\";\n    }\n}",
    "instruction": {
      "en": "Write a TypeScript function `function calculateFunctionValue(x: number): string` to solve the following problem:\nCalculate the value of the function for a given input.\n\nParameters:\n- x (number): Input value for the function.\n\nReturns:\n- string: If x is not in the defined domain, returns \"Not define\".\n  Otherwise, returns the calculated function value rounded to 5 decimal places.\n\nFunction Definitions:\n- For 0 <= x < 10: y = cos(x + 3.0)\n- For 10 <= x < 20: y = (cos(x + 7.5))^2\n- For 20 <= x < 30: y = (cos(x + 4.0))^4\n\nExample usage:\ncalculateFunctionValue(40); // Returns \"Not define\"\n",
      "sq": "Shkruani një funksion TypeScript `function calculateFunctionValue(x: number): string` për të zgjidhur problemin e mëposhtëm:\nLlogaritni vlerën e funksionit për një hyrje të dhënë.\n\nParametrat:\n- x (numër): Vlera e hyrjes për funksionin.\n\nKthen:\n- string: Nëse x nuk është në domenin e përcaktuar, kthen \"Not define\".\n  Përndryshe, kthen vlerën e llogaritur të funksionit të rrumbullakosur në 5 vende dhjetore.\n\nPërkufizimet e funksionit:\n- Për 0 <= x < 10: y = cos(x + 3.0)\n- Për 10 <= x < 20: y = (cos(x + 7.5))^2\n- Për 20 <= x < 30: y = (cos(x + 4.0))^4\n\nShembull përdorimi:\ncalculateFunctionValue(40); // Kthen \"Not define\"",
      "hy": "Գրեք TypeScript ֆունկցիա `function calculateFunctionValue(x: number): string`՝ հետևյալ խնդիրը լուծելու համար:\nՀաշվեք ֆունկցիայի արժեքը տրված մուտքագծի համար։\n\nՊարամետրեր:\n- x (number): Մուտքագծի արժեք ֆունկցիայի համար։\n\nՎերադարձնում է:\n- string: Եթե x-ը սահմանված դոմեյնում չէ, վերադարձնում է \"Not define\"։\n  Հակառակ դեպքում, վերադարձնում է հաշվարկված ֆունկցիայի արժեքը կլորացված մինչև 5 տասնորդական նիշ։\n\nՖունկցիայի սահմանումներ:\n- 0 <= x < 10: y = cos(x + 3.0)\n- 10 <= x < 20: y = (cos(x + 7.5))^2\n- 20 <= x < 30: y = (cos(x + 4.0))^4\n\nՕրինակ օգտագործում:\ncalculateFunctionValue(40); // Վերադարձնում է \"Not define\"",
      "bn": "একটি TypeScript ফাংশন `function calculateFunctionValue(x: number): string` লিখুন নিম্নলিখিত সমস্যার সমাধানের জন্য:\nএকটি প্রদত্ত ইনপুটের জন্য ফাংশনের মান গণনা করুন।\n\nপ্যারামিটারসমূহ:\n- x (number): ফাংশনের জন্য ইনপুট মান।\n\nফেরত দেয়:\n- string: যদি x সংজ্ঞায়িত ডোমেইনে না থাকে, তাহলে \"Not define\" ফেরত দেয়।\n  অন্যথায়, গণনা করা ফাংশনের মান ৫ দশমিক স্থান পর্যন্ত রাউন্ড করে ফেরত দেয়।\n\nফাংশনের সংজ্ঞাসমূহ:\n- 0 <= x < 10 এর জন্য: y = cos(x + 3.0)\n- 10 <= x < 20 এর জন্য: y = (cos(x + 7.5))^2\n- 20 <= x < 30 এর জন্য: y = (cos(x + 4.0))^4\n\nউদাহরণ ব্যবহার:\ncalculateFunctionValue(40); // \"Not define\" ফেরত দেয়",
      "bg": "Напишете TypeScript функция `function calculateFunctionValue(x: number): string`, за да решите следния проблем:\nИзчислете стойността на функцията за даден вход.\n\nПараметри:\n- x (number): Входна стойност за функцията.\n\nВръща:\n- string: Ако x не е в определения домейн, връща \"Not define\".\n  В противен случай връща изчислената стойност на функцията, закръглена до 5 знака след десетичната запетая.\n\nДефиниции на функцията:\n- За 0 <= x < 10: y = cos(x + 3.0)\n- За 10 <= x < 20: y = (cos(x + 7.5))^2\n- За 20 <= x < 30: y = (cos(x + 4.0))^4\n\nПример за използване:\ncalculateFunctionValue(40); // Връща \"Not define\"",
      "zh": "编写一个 TypeScript 函数 `function calculateFunctionValue(x: number): string` 来解决以下问题：\n计算给定输入的函数值。\n\n参数：\n- x (number): 函数的输入值。\n\n返回值：\n- string: 如果 x 不在定义域内，返回 \"Not define\"。\n  否则，返回计算出的函数值，保留 5 位小数。\n\n函数定义：\n- 对于 0 <= x < 10: y = cos(x + 3.0)\n- 对于 10 <= x < 20: y = (cos(x + 7.5))^2\n- 对于 20 <= x < 30: y = (cos(x + 4.0))^4\n\n示例用法：\ncalculateFunctionValue(40); // 返回 \"Not define\"",
      "fr": "Écrire une fonction TypeScript `function calculateFunctionValue(x: number): string` pour résoudre le problème suivant :\nCalculer la valeur de la fonction pour une entrée donnée.\n\nParamètres :\n- x (number): Valeur d'entrée pour la fonction.\n\nRenvoie :\n- string: Si x n'est pas dans le domaine défini, renvoie \"Not define\".\n  Sinon, renvoie la valeur calculée de la fonction arrondie à 5 décimales.\n\nDéfinitions de la fonction :\n- Pour 0 <= x < 10: y = cos(x + 3.0)\n- Pour 10 <= x < 20: y = (cos(x + 7.5))^2\n- Pour 20 <= x < 30: y = (cos(x + 4.0))^4\n\nExemple d'utilisation :\ncalculateFunctionValue(40); // Renvoie \"Not define\"",
      "de": "Schreiben Sie eine TypeScript-Funktion `function calculateFunctionValue(x: number): string`, um das folgende Problem zu lösen:\nBerechnen Sie den Wert der Funktion für eine gegebene Eingabe.\n\nParameter:\n- x (number): Eingabewert für die Funktion.\n\nRückgabewerte:\n- string: Wenn x nicht im definierten Bereich liegt, wird \"Not define\" zurückgegeben.\n  Andernfalls wird der berechnete Funktionswert auf 5 Dezimalstellen gerundet zurückgegeben.\n\nFunktionsdefinitionen:\n- Für 0 <= x < 10: y = cos(x + 3.0)\n- Für 10 <= x < 20: y = (cos(x + 7.5))^2\n- Für 20 <= x < 30: y = (cos(x + 4.0))^4\n\nBeispielverwendung:\ncalculateFunctionValue(40); // Gibt \"Not define\" zurück",
      "ha": "Rubuta wani aikin TypeScript `function calculateFunctionValue(x: number): string` don warware matsalar mai zuwa:\nƘididdige ƙimar aikin don wani shigarwar da aka bayar.\n\nSigogi:\n- x (number): Ƙimar shigarwa don aikin.\n\nMayarwa:\n- string: Idan x ba ya cikin kewayon da aka ayyana, yana mayar da \"Not define\".\n  In ba haka ba, yana mayar da ƙimar aikin da aka ƙididdige an zagaye zuwa wurare 5 na decimal.\n\nMa'anar Aiki:\n- Don 0 <= x < 10: y = cos(x + 3.0)\n- Don 10 <= x < 20: y = (cos(x + 7.5))^2\n- Don 20 <= x < 30: y = (cos(x + 4.0))^4\n\nMisalin amfani:\ncalculateFunctionValue(40); // Yana mayar da \"Not define\"",
      "hi": "TypeScript फ़ंक्शन `function calculateFunctionValue(x: number): string` लिखें ताकि निम्नलिखित समस्या का समाधान किया जा सके:\nदिए गए इनपुट के लिए फ़ंक्शन का मान गणना करें।\n\nपैरामीटर्स:\n- x (number): फ़ंक्शन के लिए इनपुट मान।\n\nवापसी:\n- string: यदि x परिभाषित डोमेन में नहीं है, तो \"Not define\" लौटाता है।\n  अन्यथा, गणना किया गया फ़ंक्शन मान 5 दशमलव स्थानों तक राउंड किया हुआ लौटाता है।\n\nफ़ंक्शन परिभाषाएँ:\n- 0 <= x < 10 के लिए: y = cos(x + 3.0)\n- 10 <= x < 20 के लिए: y = (cos(x + 7.5))^2\n- 20 <= x < 30 के लिए: y = (cos(x + 4.0))^4\n\nउदाहरण उपयोग:\ncalculateFunctionValue(40); // \"Not define\" लौटाता है",
      "hu": "Írj egy TypeScript függvényt `function calculateFunctionValue(x: number): string` a következő probléma megoldására:\nSzámítsd ki a függvény értékét egy adott bemenetre.\n\nParaméterek:\n- x (number): A függvény bemeneti értéke.\n\nVisszatérési érték:\n- string: Ha x nincs a meghatározott tartományban, akkor \"Not define\" értéket ad vissza.\n  Ellenkező esetben a kiszámított függvényértéket adja vissza 5 tizedesjegyre kerekítve.\n\nFüggvény definíciók:\n- Ha 0 <= x < 10: y = cos(x + 3.0)\n- Ha 10 <= x < 20: y = (cos(x + 7.5))^2\n- Ha 20 <= x < 30: y = (cos(x + 4.0))^4\n\nPélda használat:\ncalculateFunctionValue(40); // Visszaadja \"Not define\""
    },
    "instruction_bertscore": {
      "sq": "0.9868182920233817",
      "hy": "0.9548165540740888",
      "bn": "0.9819951491110925",
      "bg": "0.9895625693677598",
      "zh": "0.9803941882399514",
      "fr": "0.9789545152382105",
      "de": "0.9709719574851804",
      "ha": "0.9732377342416454",
      "hi": "0.9660006363086392",
      "hu": "0.9645847989526225"
    },
    "level": "middle",
    "test": "function testCalculateFunctionValue(): void {\n    console.assert(calculateFunctionValue(40) === \"Not define\", \"Test failed: x = 40 should be 'Not define'\");\n    console.assert(calculateFunctionValue(5) === \"-0.14550\", \"Test failed: x = 5 should be '-0.14550'\");\n    console.assert(calculateFunctionValue(15) === \"0.76266\", \"Test failed: x = 15 should be '0.76266'\");\n    console.assert(calculateFunctionValue(25) === \"0.31314\", \"Test failed: x = 25 should be '0.31314'\");\n    console.assert(calculateFunctionValue(-1) === \"Not define\", \"Test failed: x = -1 should be 'Not define'\");\n}\n\ntestCalculateFunctionValue();",
    "entry_point": "calculateFunctionValue",
    "signature": "function calculateFunctionValue(x: number): string",
    "docstring": {
      "en": "Calculate the value of the function for a given input.\n\nParameters:\n- x (number): Input value for the function.\n\nReturns:\n- string: If x is not in the defined domain, returns \"Not define\".\n  Otherwise, returns the calculated function value rounded to 5 decimal places.\n\nFunction Definitions:\n- For 0 <= x < 10: y = cos(x + 3.0)\n- For 10 <= x < 20: y = (cos(x + 7.5))^2\n- For 20 <= x < 30: y = (cos(x + 4.0))^4\n\nExample usage:\ncalculateFunctionValue(40); // Returns \"Not define\"\n",
      "sq": "Llogarit vlerën e funksionit për një hyrje të dhënë.\n\nParametrat:\n- x (numër): Vlera e hyrjes për funksionin.\n\nKthen:\n- string: Nëse x nuk është në domenin e përcaktuar, kthen \"Not define\".\n  Përndryshe, kthen vlerën e llogaritur të funksionit të rrumbullakosur në 5 shifra dhjetore.\n\nPërcaktimet e funksionit:\n- Për 0 <= x < 10: y = cos(x + 3.0)\n- Për 10 <= x < 20: y = (cos(x + 7.5))^2\n- Për 20 <= x < 30: y = (cos(x + 4.0))^4\n\nShembull përdorimi:\ncalculateFunctionValue(40); // Kthen \"Not define\"",
      "hy": "Հաշվարկել ֆունկցիայի արժեքը տրված մուտքագրվածի համար։\n\nՊարամետրեր՝\n- x (թիվ): Մուտքագրված արժեքը ֆունկցիայի համար։\n\nՎերադարձնում է՝\n- string: Եթե x-ը սահմանված տիրույթում չէ, վերադարձնում է \"Not define\"։\n  Հակառակ դեպքում, վերադարձնում է հաշվարկված ֆունկցիայի արժեքը կլորացված մինչև 5 տասնորդական նշան։\n\nՖունկցիայի սահմանումներ՝\n- 0 <= x < 10: y = cos(x + 3.0)\n- 10 <= x < 20: y = (cos(x + 7.5))^2\n- 20 <= x < 30: y = (cos(x + 4.0))^4\n\nՕրինակ օգտագործում՝\ncalculateFunctionValue(40); // Վերադարձնում է \"Not define\"",
      "bn": "ফাংশনের প্রদত্ত ইনপুটের জন্য মান গণনা করুন।\n\nপ্যারামিটারসমূহ:\n- x (সংখ্যা): ফাংশনের জন্য ইনপুট মান।\n\nফেরত দেয়:\n- string: যদি x সংজ্ঞায়িত ডোমেইনে না থাকে, তাহলে \"Not define\" ফেরত দেয়।\n  অন্যথায়, গণনা করা ফাংশনের মান ৫ দশমিক স্থান পর্যন্ত রাউন্ড করে ফেরত দেয়।\n\nফাংশনের সংজ্ঞাসমূহ:\n- 0 <= x < 10 এর জন্য: y = cos(x + 3.0)\n- 10 <= x < 20 এর জন্য: y = (cos(x + 7.5))^2\n- 20 <= x < 30 এর জন্য: y = (cos(x + 4.0))^4\n\nব্যবহারের উদাহরণ:\ncalculateFunctionValue(40); // \"Not define\" ফেরত দেয়",
      "bg": "Изчислява стойността на функцията за даден вход.\n\nПараметри:\n- x (число): Входна стойност за функцията.\n\nВръща:\n- низ: Ако x не е в определения домейн, връща \"Not define\".\n  В противен случай, връща изчислената стойност на функцията, закръглена до 5 знака след десетичната запетая.\n\nДефиниции на функцията:\n- За 0 <= x < 10: y = cos(x + 3.0)\n- За 10 <= x < 20: y = (cos(x + 7.5))^2\n- За 20 <= x < 30: y = (cos(x + 4.0))^4\n\nПример за използване:\ncalculateFunctionValue(40); // Връща \"Not define\"",
      "zh": "计算给定输入的函数值。\n\n参数：\n- x (number): 函数的输入值。\n\n返回：\n- string: 如果 x 不在定义域内，返回 \"Not define\"。\n  否则，返回计算后的函数值，四舍五入到小数点后5位。\n\n函数定义：\n- 对于 0 <= x < 10: y = cos(x + 3.0)\n- 对于 10 <= x < 20: y = (cos(x + 7.5))^2\n- 对于 20 <= x < 30: y = (cos(x + 4.0))^4\n\n示例用法：\ncalculateFunctionValue(40); // 返回 \"Not define\"",
      "fr": "Calculer la valeur de la fonction pour une entrée donnée.\n\nParamètres :\n- x (nombre) : Valeur d'entrée pour la fonction.\n\nRenvoie :\n- string : Si x n'est pas dans le domaine défini, renvoie \"Not define\".\n  Sinon, renvoie la valeur calculée de la fonction arrondie à 5 décimales.\n\nDéfinitions de la fonction :\n- Pour 0 <= x < 10 : y = cos(x + 3.0)\n- Pour 10 <= x < 20 : y = (cos(x + 7.5))^2\n- Pour 20 <= x < 30 : y = (cos(x + 4.0))^4\n\nExemple d'utilisation :\ncalculateFunctionValue(40); // Renvoie \"Not define\"",
      "de": "Berechnen Sie den Wert der Funktion für eine gegebene Eingabe.\n\nParameter:\n- x (number): Eingabewert für die Funktion.\n\nRückgabewerte:\n- string: Wenn x nicht im definierten Bereich liegt, wird \"Not define\" zurückgegeben.\n  Andernfalls wird der berechnete Funktionswert auf 5 Dezimalstellen gerundet zurückgegeben.\n\nFunktionsdefinitionen:\n- Für 0 <= x < 10: y = cos(x + 3.0)\n- Für 10 <= x < 20: y = (cos(x + 7.5))^2\n- Für 20 <= x < 30: y = (cos(x + 4.0))^4\n\nBeispielverwendung:\ncalculateFunctionValue(40); // Gibt \"Not define\" zurück",
      "ha": "Ƙididdige ƙimar aikin don wani shigarwar da aka bayar.\n\nSigogi:\n- x (lamba): Ƙimar shigarwa don aikin.\n\nAbin da ake dawowa da shi:\n- string: Idan x ba ya cikin yankin da aka ayyana, yana dawowa da \"Not define\".\n  In ba haka ba, yana dawowa da ƙimar aikin da aka ƙididdige an zagaye zuwa wurare 5 na ɗigo.\n\nMa'anar Ayyuka:\n- Don 0 <= x < 10: y = cos(x + 3.0)\n- Don 10 <= x < 20: y = (cos(x + 7.5))^2\n- Don 20 <= x < 30: y = (cos(x + 4.0))^4\n\nMisalin amfani:\ncalculateFunctionValue(40); // Yana dawowa da \"Not define\"",
      "hi": "दिए गए इनपुट के लिए फ़ंक्शन का मान गणना करें।\n\nपैरामीटर्स:\n- x (संख्या): फ़ंक्शन के लिए इनपुट मान।\n\nवापसी:\n- string: यदि x परिभाषित डोमेन में नहीं है, तो \"Not define\" लौटाता है।\n  अन्यथा, गणना किए गए फ़ंक्शन मान को 5 दशमलव स्थानों तक राउंड करके लौटाता है।\n\nफ़ंक्शन परिभाषाएँ:\n- 0 <= x < 10 के लिए: y = cos(x + 3.0)\n- 10 <= x < 20 के लिए: y = (cos(x + 7.5))^2\n- 20 <= x < 30 के लिए: y = (cos(x + 4.0))^4\n\nउदाहरण उपयोग:\ncalculateFunctionValue(40); // \"Not define\" लौटाता है",
      "hu": "Számítsa ki a függvény értékét egy adott bemenetre.\n\nParaméterek:\n- x (szám): A függvény bemeneti értéke.\n\nVisszatérési érték:\n- string: Ha x nincs a meghatározott tartományban, \"Not define\" értéket ad vissza.\n  Ellenkező esetben a kiszámított függvényértéket adja vissza 5 tizedesjegyre kerekítve.\n\nFüggvénydefiníciók:\n- Ha 0 <= x < 10: y = cos(x + 3.0)\n- Ha 10 <= x < 20: y = (cos(x + 7.5))^2\n- Ha 20 <= x < 30: y = (cos(x + 4.0))^4\n\nPélda használat:\ncalculateFunctionValue(40); // Visszatér \"Not define\" értékkel"
    },
    "docstring_bertscore": {
      "sq": "0.9813160318383343",
      "hy": "0.9470141540766573",
      "bn": "0.9783099596517523",
      "bg": "0.9843530903643577",
      "zh": "0.9785222955290785",
      "fr": "0.9728682817329205",
      "de": "0.966904603172729",
      "ha": "0.9796934202556603",
      "hi": "0.9877174917583267",
      "hu": "0.9571899884970747"
    }
  },
  {
    "task_id": "TypeScript/4",
    "prompt": {
      "en": "\n/**\n * Find the maximum and minimum of three distinct integers.\n *\n * @param a - The first integer.\n * @param b - The second integer.\n * @param c - The third integer.\n * @returns A tuple containing the maximum and minimum values respectively.\n *\n * @example\n * const [max, min] = findMaxMin(1, 2, 3);\n * console.assert(max === 3 && min === 1);\n */\nfunction findMaxMin(a: number, b: number, c: number): [number, number]",
      "sq": "/**\n * Gjeni maksimumin dhe minimumin e tre numrave të plotë të ndryshëm.\n *\n * @param a - Numri i parë i plotë.\n * @param b - Numri i dytë i plotë.\n * @param c - Numri i tretë i plotë.\n * @returns Një dyshe që përmban vlerat maksimale dhe minimale përkatësisht.\n *\n * @example\n * const [max, min] = findMaxMin(1, 2, 3);\n * console.assert(max === 3 && min === 1);\n */\nfunction findMaxMin(a: number, b: number, c: number): [number, number]",
      "hy": "/**\n * Գտնել երեք տարբեր ամբողջ թվերի առավելագույնը և նվազագույնը:\n *\n * @param a - Առաջին ամբողջ թիվը:\n * @param b - Երկրորդ ամբողջ թիվը:\n * @param c - Երրորդ ամբողջ թիվը:\n * @returns Զույգ, որը պարունակում է համապատասխանաբար առավելագույն և նվազագույն արժեքները:\n *\n * @example\n * const [max, min] = findMaxMin(1, 2, 3);\n * console.assert(max === 3 && min === 1);\n */\nfunction findMaxMin(a: number, b: number, c: number): [number, number]",
      "bn": "/**\n * তিনটি ভিন্ন পূর্ণসংখ্যার মধ্যে সর্বাধিক এবং সর্বনিম্ন খুঁজে বের করুন।\n *\n * @param a - প্রথম পূর্ণসংখ্যা।\n * @param b - দ্বিতীয় পূর্ণসংখ্যা।\n * @param c - তৃতীয় পূর্ণসংখ্যা।\n * @returns একটি টুপল যা যথাক্রমে সর্বাধিক এবং সর্বনিম্ন মান ধারণ করে।\n *\n * @example\n * const [max, min] = findMaxMin(1, 2, 3);\n * console.assert(max === 3 && min === 1);\n */\nfunction findMaxMin(a: number, b: number, c: number): [number, number]",
      "bg": "/**\n * Намерете максимума и минимума на три различни цели числа.\n *\n * @param a - Първото цяло число.\n * @param b - Второто цяло число.\n * @param c - Третото цяло число.\n * @returns Кортеж, съдържащ съответно максималните и минималните стойности.\n *\n * @example\n * const [max, min] = findMaxMin(1, 2, 3);\n * console.assert(max === 3 && min === 1);\n */\nfunction findMaxMin(a: number, b: number, c: number): [number, number]",
      "zh": "/**\n * 查找三个不同整数的最大值和最小值。\n *\n * @param a - 第一个整数。\n * @param b - 第二个整数。\n * @param c - 第三个整数。\n * @returns 一个包含最大值和最小值的元组。\n *\n * @example\n * const [max, min] = findMaxMin(1, 2, 3);\n * console.assert(max === 3 && min === 1);\n */\nfunction findMaxMin(a: number, b: number, c: number): [number, number]",
      "fr": "/**\n * Trouver le maximum et le minimum de trois entiers distincts.\n *\n * @param a - Le premier entier.\n * @param b - Le deuxième entier.\n * @param c - Le troisième entier.\n * @returns Un tuple contenant respectivement les valeurs maximum et minimum.\n *\n * @example\n * const [max, min] = findMaxMin(1, 2, 3);\n * console.assert(max === 3 && min === 1);\n */\nfunction findMaxMin(a: number, b: number, c: number): [number, number]",
      "de": "/**\n * Finde das Maximum und Minimum von drei verschiedenen ganzen Zahlen.\n *\n * @param a - Die erste ganze Zahl.\n * @param b - Die zweite ganze Zahl.\n * @param c - Die dritte ganze Zahl.\n * @returns Ein Tupel, das die Maximal- und Minimalwerte enthält.\n *\n * @example\n * const [max, min] = findMaxMin(1, 2, 3);\n * console.assert(max === 3 && min === 1);\n */\nfunction findMaxMin(a: number, b: number, c: number): [number, number]",
      "ha": "/**\n * Nemo mafi girma da mafi ƙanƙanta daga cikin lambobi guda uku masu bambanta.\n *\n * @param a - Lamba ta farko.\n * @param b - Lamba ta biyu.\n * @param c - Lamba ta uku.\n * @returns Wani tuple da ke dauke da mafi girma da mafi ƙanƙanta bi da bi.\n *\n * @example\n * const [max, min] = findMaxMin(1, 2, 3);\n * console.assert(max === 3 && min === 1);\n */\nfunction findMaxMin(a: number, b: number, c: number): [number, number]",
      "hi": "/**\n * तीन अलग-अलग पूर्णांकों का अधिकतम और न्यूनतम मान खोजें।\n *\n * @param a - पहला पूर्णांक।\n * @param b - दूसरा पूर्णांक।\n * @param c - तीसरा पूर्णांक।\n * @returns एक युग्म जिसमें क्रमशः अधिकतम और न्यूनतम मान होते हैं।\n *\n * @example\n * const [max, min] = findMaxMin(1, 2, 3);\n * console.assert(max === 3 && min === 1);\n */\nfunction findMaxMin(a: number, b: number, c: number): [number, number]",
      "hu": "/**\n * Keresse meg három különböző egész szám maximumát és minimumát.\n *\n * @param a - Az első egész szám.\n * @param b - A második egész szám.\n * @param c - A harmadik egész szám.\n * @returns Egy tuple, amely tartalmazza a maximum és minimum értékeket ebben a sorrendben.\n *\n * @example\n * const [max, min] = findMaxMin(1, 2, 3);\n * console.assert(max === 3 && min === 1);\n */\nfunction findMaxMin(a: number, b: number, c: number): [number, number]"
    },
    "prompt_bertscore": {
      "sq": "0.996777619328471",
      "hy": "0.9887398423295132",
      "bn": "0.9790043714638502",
      "bg": "0.9949859732915363",
      "zh": "0.9885290954952352",
      "fr": "1",
      "de": "0.991243776912839",
      "ha": "0.9561032816824329",
      "hi": "0.9757595455592644",
      "hu": "0.9803105648495357"
    },
    "canonical_solution": "{\n    let max: number;\n    let min: number;\n\n    if (a > b) {\n        if (a > c) {\n            max = a;\n            min = b < c ? b : c;\n        } else {\n            max = c;\n            min = b;\n        }\n    } else {\n        if (b > c) {\n            max = b;\n            min = a < c ? a : c;\n        } else {\n            max = c;\n            min = a;\n        }\n    }\n\n    return [max, min];\n}",
    "instruction": {
      "en": "Write a TypeScript function `function findMaxMin(a: number, b: number, c: number): [number, number]` to solve the following problem:\nFind the maximum and minimum of three distinct integers.\n\n@param a - The first integer.\n@param b - The second integer.\n@param c - The third integer.\n@returns A tuple containing the maximum and minimum values respectively.\n\n@example\nconst [max, min] = findMaxMin(1, 2, 3);\nconsole.assert(max === 3 && min === 1);",
      "sq": "Shkruani një funksion TypeScript `function findMaxMin(a: number, b: number, c: number): [number, number]` për të zgjidhur problemin në vijim:\nGjeni maksimumin dhe minimumin e tre numrave të plotë të ndryshëm.\n\n@param a - Numri i parë i plotë.\n@param b - Numri i dytë i plotë.\n@param c - Numri i tretë i plotë.\n@returns Një dyshe që përmban vlerat maksimale dhe minimale përkatësisht.\n\n@example\nconst [max, min] = findMaxMin(1, 2, 3);\nconsole.assert(max === 3 && min === 1);",
      "hy": "Գրեք TypeScript ֆունկցիա `function findMaxMin(a: number, b: number, c: number): [number, number]` հետևյալ խնդիրը լուծելու համար:\nԳտնել երեք տարբեր ամբողջ թվերի առավելագույնը և նվազագույնը։\n\n@param a - Առաջին ամբողջ թիվը։\n@param b - Երկրորդ ամբողջ թիվը։\n@param c - Երրորդ ամբողջ թիվը։\n@returns Զույգ, որը պարունակում է առավելագույն և նվազագույն արժեքները համապատասխանաբար։\n\n@example\nconst [max, min] = findMaxMin(1, 2, 3);\nconsole.assert(max === 3 && min === 1);",
      "bn": "TypeScript ফাংশন `function findMaxMin(a: number, b: number, c: number): [number, number]` লিখুন নিম্নলিখিত সমস্যার সমাধানের জন্য:\nতিনটি ভিন্ন পূর্ণসংখ্যার মধ্যে সর্বাধিক এবং সর্বনিম্ন খুঁজে বের করুন।\n\n@param a - প্রথম পূর্ণসংখ্যা।\n@param b - দ্বিতীয় পূর্ণসংখ্যা।\n@param c - তৃতীয় পূর্ণসংখ্যা।\n@returns একটি টিউপল যা যথাক্রমে সর্বাধিক এবং সর্বনিম্ন মান ধারণ করে।\n\n@example\nconst [max, min] = findMaxMin(1, 2, 3);\nconsole.assert(max === 3 && min === 1);",
      "bg": "Напишете функция на TypeScript `function findMaxMin(a: number, b: number, c: number): [number, number]`, за да решите следния проблем:\nНамерете максимума и минимума на три различни цели числа.\n\n@param a - Първото цяло число.\n@param b - Второто цяло число.\n@param c - Третото цяло число.\n@returns Кортеж, съдържащ съответно максималната и минималната стойност.\n\n@example\nconst [max, min] = findMaxMin(1, 2, 3);\nconsole.assert(max === 3 && min === 1);",
      "zh": "编写一个 TypeScript 函数 `function findMaxMin(a: number, b: number, c: number): [number, number]` 来解决以下问题：\n找到三个不同整数的最大值和最小值。\n\n@param a - 第一个整数。\n@param b - 第二个整数。\n@param c - 第三个整数。\n@returns 一个包含最大值和最小值的元组。\n\n@example\nconst [max, min] = findMaxMin(1, 2, 3);\nconsole.assert(max === 3 && min === 1);",
      "fr": "Écrire une fonction TypeScript `function findMaxMin(a: number, b: number, c: number): [number, number]` pour résoudre le problème suivant :\nTrouver le maximum et le minimum de trois entiers distincts.\n\n@param a - Le premier entier.\n@param b - Le deuxième entier.\n@param c - Le troisième entier.\n@returns Un tuple contenant respectivement les valeurs maximale et minimale.\n\n@example\nconst [max, min] = findMaxMin(1, 2, 3);\nconsole.assert(max === 3 && min === 1);",
      "de": "Schreiben Sie eine TypeScript-Funktion `function findMaxMin(a: number, b: number, c: number): [number, number]`, um das folgende Problem zu lösen:\nFinden Sie das Maximum und Minimum von drei verschiedenen ganzen Zahlen.\n\n@param a - Die erste ganze Zahl.\n@param b - Die zweite ganze Zahl.\n@param c - Die dritte ganze Zahl.\n@returns Ein Tupel, das die maximalen und minimalen Werte enthält.\n\n@example\nconst [max, min] = findMaxMin(1, 2, 3);\nconsole.assert(max === 3 && min === 1);",
      "ha": "Rubuta aikin TypeScript `function findMaxMin(a: number, b: number, c: number): [number, number]` don warware matsalar mai zuwa:\nNemo mafi girma da mafi ƙanƙanta daga cikin lambobi guda uku daban-daban.\n\n@param a - Lamba ta farko.\n@param b - Lamba ta biyu.\n@param c - Lamba ta uku.\n@returns Wani tuple da ke ɗauke da ƙimomin mafi girma da mafi ƙanƙanta bi da bi.\n\n@example\nconst [max, min] = findMaxMin(1, 2, 3);\nconsole.assert(max === 3 && min === 1);",
      "hi": "TypeScript फ़ंक्शन `function findMaxMin(a: number, b: number, c: number): [number, number]` लिखें ताकि निम्नलिखित समस्या का समाधान किया जा सके:\nतीन भिन्न पूर्णांकों का अधिकतम और न्यूनतम मान खोजें।\n\n@param a - पहला पूर्णांक।\n@param b - दूसरा पूर्णांक।\n@param c - तीसरा पूर्णांक।\n@returns एक युग्म जो क्रमशः अधिकतम और न्यूनतम मानों को दर्शाता है।\n\n@example\nconst [max, min] = findMaxMin(1, 2, 3);\nconsole.assert(max === 3 && min === 1);",
      "hu": "Írj egy TypeScript függvényt `function findMaxMin(a: number, b: number, c: number): [number, number]` a következő probléma megoldására:\nHárom különböző egész szám maximumának és minimumának megtalálása.\n\n@param a - Az első egész szám.\n@param b - A második egész szám.\n@param c - A harmadik egész szám.\n@returns Egy tuple, amely tartalmazza a maximum és minimum értékeket ebben a sorrendben.\n\n@example\nconst [max, min] = findMaxMin(1, 2, 3);\nconsole.assert(max === 3 && min === 1);"
    },
    "instruction_bertscore": {
      "sq": "0.9965400573927533",
      "hy": "0.9903811251680045",
      "bn": "0.9742412149266336",
      "bg": "0.9945303151974423",
      "zh": "0.9888242602414531",
      "fr": "1",
      "de": "0.989888720453419",
      "ha": "0.9650261556592821",
      "hi": "0.9559549047877998",
      "hu": "0.9791299058646643"
    },
    "level": "middle",
    "test": "(() => {\n    let max: number, min: number, result: [number, number];\n\n    result = findMaxMin(1, 2, 3);\n    [max, min] = result;\n    console.assert(max === 3 && min === 1, 'Test failed for input (1, 2, 3)');\n\n    // Additional tests\n    result = findMaxMin(5, 3, 4);\n    [max, min] = result;\n    console.assert(max === 5 && min === 3, 'Test failed for input (5, 3, 4)');\n\n    result = findMaxMin(10, -2, 7);\n    [max, min] = result;\n    console.assert(max === 10 && min === -2, 'Test failed for input (10, -2, 7)');\n\n    result = findMaxMin(-1, -3, -2);\n    [max, min] = result;\n    console.assert(max === -1 && min === -3, 'Test failed for input (-1, -3, -2)');\n})();",
    "entry_point": "findMaxMin",
    "signature": "function findMaxMin(a: number, b: number, c: number): [number, number]",
    "docstring": {
      "en": "Find the maximum and minimum of three distinct integers.\n\n@param a - The first integer.\n@param b - The second integer.\n@param c - The third integer.\n@returns A tuple containing the maximum and minimum values respectively.\n\n@example\nconst [max, min] = findMaxMin(1, 2, 3);\nconsole.assert(max === 3 && min === 1);",
      "sq": "Gjeni maksimumin dhe minimumin e tre numrave të plotë të ndryshëm.\n\n@param a - Numri i parë i plotë.\n@param b - Numri i dytë i plotë.\n@param c - Numri i tretë i plotë.\n@returns Një dyshe që përmban vlerat maksimale dhe minimale përkatësisht.\n\n@example\nconst [max, min] = findMaxMin(1, 2, 3);\nconsole.assert(max === 3 && min === 1);",
      "hy": "Find the maximum and minimum of three distinct integers.\n\n@param a - Առաջին ամբողջ թիվը:\n@param b - Երկրորդ ամբողջ թիվը:\n@param c - Երրորդ ամբողջ թիվը:\n@returns Կորտեժ, որը պարունակում է առավելագույն և նվազագույն արժեքները համապատասխանաբար:\n\n@example\nconst [max, min] = findMaxMin(1, 2, 3);\nconsole.assert(max === 3 && min === 1);",
      "bn": "Find the maximum and minimum of three distinct integers.\n\n@param a - প্রথম পূর্ণসংখ্যা।\n@param b - দ্বিতীয় পূর্ণসংখ্যা।\n@param c - তৃতীয় পূর্ণসংখ্যা।\n@returns একটি টিউপল যা যথাক্রমে সর্বাধিক এবং সর্বনিম্ন মান ধারণ করে।\n\n@example\nconst [max, min] = findMaxMin(1, 2, 3);\nconsole.assert(max === 3 && min === 1);",
      "bg": "Намерете максималното и минималното от три различни цели числа.\n\n@param a - Първото цяло число.\n@param b - Второто цяло число.\n@param c - Третото цяло число.\n@returns Кортеж, съдържащ максималната и минималната стойности съответно.\n\n@example\nconst [max, min] = findMaxMin(1, 2, 3);\nconsole.assert(max === 3 && min === 1);",
      "zh": "Find the maximum and minimum of three distinct integers.\n\n@param a - 第一个整数。\n@param b - 第二个整数。\n@param c - 第三个整数。\n@returns 一个包含最大值和最小值的元组。\n\n@example\nconst [max, min] = findMaxMin(1, 2, 3);\nconsole.assert(max === 3 && min === 1);",
      "fr": "Trouver le maximum et le minimum de trois entiers distincts.\n\n@param a - Le premier entier.\n@param b - Le deuxième entier.\n@param c - Le troisième entier.\n@returns Un tuple contenant respectivement les valeurs maximum et minimum.\n\n@example\nconst [max, min] = findMaxMin(1, 2, 3);\nconsole.assert(max === 3 && min === 1);",
      "de": "Finden Sie das Maximum und Minimum von drei verschiedenen ganzen Zahlen.\n\n@param a - Die erste ganze Zahl.\n@param b - Die zweite ganze Zahl.\n@param c - Die dritte ganze Zahl.\n@returns Ein Tupel, das die maximalen und minimalen Werte enthält.\n\n@example\nconst [max, min] = findMaxMin(1, 2, 3);\nconsole.assert(max === 3 && min === 1);",
      "ha": "Find the maximum and minimum of three distinct integers.\n\n@param a - Na farko cikakken lamba.\n@param b - Na biyu cikakken lamba.\n@param c - Na uku cikakken lamba.\n@returns Wani tuple da ke dauke da mafi girma da mafi karancin kima bi da bi.\n\n@example\nconst [max, min] = findMaxMin(1, 2, 3);\nconsole.assert(max === 3 && min === 1);",
      "hi": "Find the maximum and minimum of three distinct integers.\n\n@param a - पहला पूर्णांक।\n@param b - दूसरा पूर्णांक।\n@param c - तीसरा पूर्णांक।\n@returns एक युग्म जिसमें क्रमशः अधिकतम और न्यूनतम मान होते हैं।\n\n@example\nconst [max, min] = findMaxMin(1, 2, 3);\nconsole.assert(max === 3 && min === 1);",
      "hu": "Find the maximum and minimum of three distinct integers.\n\n@param a - Az első egész szám.\n@param b - A második egész szám.\n@param c - A harmadik egész szám.\n@returns Egy tuple, amely tartalmazza a maximum és minimum értékeket ebben a sorrendben.\n\n@example\nconst [max, min] = findMaxMin(1, 2, 3);\nconsole.assert(max === 3 && min === 1);"
    },
    "docstring_bertscore": {
      "sq": "0.9865183601480191",
      "hy": "1",
      "bn": "0.9833045205828745",
      "bg": "0.995371316230744",
      "zh": "0.993059854486641",
      "fr": "1",
      "de": "0.9883825062740315",
      "ha": "1",
      "hi": "0.9732113164009677",
      "hu": "0.9791229538013281"
    }
  },
  {
    "task_id": "TypeScript/5",
    "prompt": {
      "en": "\n/**\n * Calculate the distance between two points A (xa, ya) and B (xb, yb).\n * \n * @param xa - x-coordinate of point A\n * @param ya - y-coordinate of point A\n * @param xb - x-coordinate of point B\n * @param yb - y-coordinate of point B\n * @returns The distance between points A and B\n * \n * Example:\n * ```\n * calculateDistance(0, 0, 3, 4) === 5\n * ```\n */\nfunction calculateDistance(xa: number, ya: number, xb: number, yb: number): number",
      "sq": "/**\n * Llogarit distancën midis dy pikave A (xa, ya) dhe B (xb, yb).\n * \n * @param xa - koordinata x e pikës A\n * @param ya - koordinata y e pikës A\n * @param xb - koordinata x e pikës B\n * @param yb - koordinata y e pikës B\n * @returns Distanca midis pikave A dhe B\n * \n * Shembull:\n * ```\n * calculateDistance(0, 0, 3, 4) === 5\n * ```\n */\nfunction calculateDistance(xa: number, ya: number, xb: number, yb: number): number",
      "hy": "/**\n * Հաշվել հեռավորությունը երկու կետերի A (xa, ya) և B (xb, yb) միջև։\n * \n * @param xa - A կետի x-կոորդինատը\n * @param ya - A կետի y-կոորդինատը\n * @param xb - B կետի x-կոորդինատը\n * @param yb - B կետի y-կոորդինատը\n * @returns Հեռավորությունը A և B կետերի միջև\n * \n * Օրինակ:\n * ```\n * calculateDistance(0, 0, 3, 4) === 5\n * ```\n */\nfunction calculateDistance(xa: number, ya: number, xb: number, yb: number): number",
      "bn": "/**\n * দুটি বিন্দু A (xa, ya) এবং B (xb, yb) এর মধ্যে দূরত্ব গণনা করুন।\n * \n * @param xa - বিন্দু A এর x-সমন্বয়\n * @param ya - বিন্দু A এর y-সমন্বয়\n * @param xb - বিন্দু B এর x-সমন্বয়\n * @param yb - বিন্দু B এর y-সমন্বয়\n * @returns বিন্দু A এবং B এর মধ্যে দূরত্ব\n * \n * উদাহরণ:\n * ```\n * calculateDistance(0, 0, 3, 4) === 5\n * ```\n */\nfunction calculateDistance(xa: number, ya: number, xb: number, yb: number): number",
      "bg": "/**\n * Изчислява разстоянието между две точки A (xa, ya) и B (xb, yb).\n * \n * @param xa - x-координата на точка A\n * @param ya - y-координата на точка A\n * @param xb - x-координата на точка B\n * @param yb - y-координата на точка B\n * @returns Разстоянието между точките A и B\n * \n * Пример:\n * ```\n * calculateDistance(0, 0, 3, 4) === 5\n * ```\n */\nfunction calculateDistance(xa: number, ya: number, xb: number, yb: number): number",
      "zh": "/**\n * 计算两点 A (xa, ya) 和 B (xb, yb) 之间的距离。\n * \n * @param xa - 点 A 的 x 坐标\n * @param ya - 点 A 的 y 坐标\n * @param xb - 点 B 的 x 坐标\n * @param yb - 点 B 的 y 坐标\n * @returns 点 A 和 B 之间的距离\n * \n * 例子:\n * ```\n * calculateDistance(0, 0, 3, 4) === 5\n * ```\n */\nfunction calculateDistance(xa: number, ya: number, xb: number, yb: number): number",
      "fr": "/**\n * Calculer la distance entre deux points A (xa, ya) et B (xb, yb).\n * \n * @param xa - coordonnée x du point A\n * @param ya - coordonnée y du point A\n * @param xb - coordonnée x du point B\n * @param yb - coordonnée y du point B\n * @returns La distance entre les points A et B\n * \n * Exemple:\n * ```\n * calculateDistance(0, 0, 3, 4) === 5\n * ```\n */\nfunction calculateDistance(xa: number, ya: number, xb: number, yb: number): number",
      "de": "/**\n * Berechne die Entfernung zwischen zwei Punkten A (xa, ya) und B (xb, yb).\n * \n * @param xa - x-Koordinate des Punktes A\n * @param ya - y-Koordinate des Punktes A\n * @param xb - x-Koordinate des Punktes B\n * @param yb - y-Koordinate des Punktes B\n * @returns Die Entfernung zwischen den Punkten A und B\n * \n * Beispiel:\n * ```\n * calculateDistance(0, 0, 3, 4) === 5\n * ```\n */\nfunction calculateDistance(xa: number, ya: number, xb: number, yb: number): number",
      "ha": "/**\n * Lissafin nisan tsakanin maki biyu A (xa, ya) da B (xb, yb).\n * \n * @param xa - x-kowodin na maki A\n * @param ya - y-kowodin na maki A\n * @param xb - x-kowodin na maki B\n * @param yb - y-kowodin na maki B\n * @returns Nisan tsakanin maki A da B\n * \n * Misali:\n * ```\n * calculateDistance(0, 0, 3, 4) === 5\n * ```\n */\nfunction calculateDistance(xa: number, ya: number, xb: number, yb: number): number",
      "hi": "/**\n * दो बिंदुओं A (xa, ya) और B (xb, yb) के बीच की दूरी की गणना करें।\n * \n * @param xa - बिंदु A का x-निर्देशांक\n * @param ya - बिंदु A का y-निर्देशांक\n * @param xb - बिंदु B का x-निर्देशांक\n * @param yb - बिंदु B का y-निर्देशांक\n * @returns बिंदुओं A और B के बीच की दूरी\n * \n * उदाहरण:\n * ```\n * calculateDistance(0, 0, 3, 4) === 5\n * ```\n */\nfunction calculateDistance(xa: number, ya: number, xb: number, yb: number): number",
      "hu": "/**\n * Számítsa ki a távolságot két pont, A (xa, ya) és B (xb, yb) között.\n * \n * @param xa - A pont x-koordinátája\n * @param ya - A pont y-koordinátája\n * @param xb - B pont x-koordinátája\n * @param yb - B pont y-koordinátája\n * @returns A távolság az A és B pontok között\n * \n * Példa:\n * ```\n * calculateDistance(0, 0, 3, 4) === 5\n * ```\n */\nfunction calculateDistance(xa: number, ya: number, xb: number, yb: number): number"
    },
    "prompt_bertscore": {
      "sq": "0.9589097303360747",
      "hy": "0.999999801369619",
      "bn": "0.9937659854912201",
      "bg": "0.9986616284925869",
      "zh": "0.9654973069230968",
      "fr": "0.9654973069230968",
      "de": "0.999999801369619",
      "ha": "0.9903145839903578",
      "hi": "0.9953520490837836",
      "hu": "0.9679831661417484"
    },
    "canonical_solution": "{\n    return Math.sqrt((xa - xb) ** 2 + (ya - yb) ** 2);\n}",
    "instruction": {
      "en": "Write a TypeScript function `function calculateDistance(xa: number, ya: number, xb: number, yb: number): number` to solve the following problem:\nCalculate the distance between two points A (xa, ya) and B (xb, yb).\n\n@param xa - x-coordinate of point A\n@param ya - y-coordinate of point A\n@param xb - x-coordinate of point B\n@param yb - y-coordinate of point B\n@returns The distance between points A and B\n\nExample:\ncalculateDistance(0, 0, 3, 4) === 5",
      "sq": "Shkruani një funksion TypeScript `function calculateDistance(xa: number, ya: number, xb: number, yb: number): number` për të zgjidhur problemin e mëposhtëm:\nLlogaritni distancën midis dy pikave A (xa, ya) dhe B (xb, yb).\n\n@param xa - koordinata x e pikës A\n@param ya - koordinata y e pikës A\n@param xb - koordinata x e pikës B\n@param yb - koordinata y e pikës B\n@returns Distanca midis pikave A dhe B\n\nShembull:\ncalculateDistance(0, 0, 3, 4) === 5",
      "hy": "Գրեք TypeScript ֆունկցիա `function calculateDistance(xa: number, ya: number, xb: number, yb: number): number` հետևյալ խնդիրը լուծելու համար:\nՀաշվեք A (xa, ya) և B (xb, yb) կետերի միջև հեռավորությունը։\n\n@param xa - A կետի x-կոորդինատը\n@param ya - A կետի y-կոորդինատը\n@param xb - B կետի x-կոորդինատը\n@param yb - B կետի y-կոորդինատը\n@returns A և B կետերի միջև հեռավորությունը\n\nՕրինակ:\ncalculateDistance(0, 0, 3, 4) === 5",
      "bn": "TypeScript ফাংশন `function calculateDistance(xa: number, ya: number, xb: number, yb: number): number` লিখুন নিম্নলিখিত সমস্যার সমাধানের জন্য:\nদুটি বিন্দু A (xa, ya) এবং B (xb, yb) এর মধ্যে দূরত্ব গণনা করুন।\n\n@param xa - বিন্দু A এর x-সমন্বয়\n@param ya - বিন্দু A এর y-সমন্বয়\n@param xb - বিন্দু B এর x-সমন্বয়\n@param yb - বিন্দু B এর y-সমন্বয়\n@returns বিন্দু A এবং B এর মধ্যে দূরত্ব\n\nউদাহরণ:\ncalculateDistance(0, 0, 3, 4) === 5",
      "bg": "Напишете функция на TypeScript `function calculateDistance(xa: number, ya: number, xb: number, yb: number): number`, за да решите следния проблем:\nИзчислете разстоянието между две точки A (xa, ya) и B (xb, yb).\n\n@param xa - x-координата на точка A\n@param ya - y-координата на точка A\n@param xb - x-координата на точка B\n@param yb - y-координата на точка B\n@returns Разстоянието между точките A и B\n\nПример:\ncalculateDistance(0, 0, 3, 4) === 5",
      "zh": "编写一个 TypeScript 函数 `function calculateDistance(xa: number, ya: number, xb: number, yb: number): number` 来解决以下问题：\n计算两点 A (xa, ya) 和 B (xb, yb) 之间的距离。\n\n@param xa - 点 A 的 x 坐标\n@param ya - 点 A 的 y 坐标\n@param xb - 点 B 的 x 坐标\n@param yb - 点 B 的 y 坐标\n@returns 点 A 和点 B 之间的距离\n\n示例:\ncalculateDistance(0, 0, 3, 4) === 5",
      "fr": "Écrire une fonction TypeScript `function calculateDistance(xa: number, ya: number, xb: number, yb: number): number` pour résoudre le problème suivant :\nCalculer la distance entre deux points A (xa, ya) et B (xb, yb).\n\n@param xa - coordonnée x du point A\n@param ya - coordonnée y du point A\n@param xb - coordonnée x du point B\n@param yb - coordonnée y du point B\n@returns La distance entre les points A et B\n\nExemple :\ncalculateDistance(0, 0, 3, 4) === 5",
      "de": "Schreiben Sie eine TypeScript-Funktion `function calculateDistance(xa: number, ya: number, xb: number, yb: number): number`, um das folgende Problem zu lösen:\nBerechnen Sie die Entfernung zwischen zwei Punkten A (xa, ya) und B (xb, yb).\n\n@param xa - x-Koordinate des Punktes A\n@param ya - y-Koordinate des Punktes A\n@param xb - x-Koordinate des Punktes B\n@param yb - y-Koordinate des Punktes B\n@returns Die Entfernung zwischen den Punkten A und B\n\nBeispiel:\ncalculateDistance(0, 0, 3, 4) === 5",
      "ha": "Rubuta aikin TypeScript `function calculateDistance(xa: number, ya: number, xb: number, yb: number): number` don warware matsalar mai zuwa:\nƘididdige nisan tsakanin maki biyu A (xa, ya) da B (xb, yb).\n\n@param xa - x-coordinate na maki A\n@param ya - y-coordinate na maki A\n@param xb - x-coordinate na maki B\n@param yb - y-coordinate na maki B\n@returns Nisan tsakanin maki A da B\n\nMisali:\ncalculateDistance(0, 0, 3, 4) === 5",
      "hi": "TypeScript फ़ंक्शन `function calculateDistance(xa: number, ya: number, xb: number, yb: number): number` लिखें ताकि निम्नलिखित समस्या का समाधान किया जा सके:\nबिंदु A (xa, ya) और B (xb, yb) के बीच की दूरी की गणना करें।\n\n@param xa - बिंदु A का x-निर्देशांक\n@param ya - बिंदु A का y-निर्देशांक\n@param xb - बिंदु B का x-निर्देशांक\n@param yb - बिंदु B का y-निर्देशांक\n@returns बिंदु A और B के बीच की दूरी\n\nउदाहरण:\ncalculateDistance(0, 0, 3, 4) === 5",
      "hu": "Írj egy TypeScript függvényt `function calculateDistance(xa: number, ya: number, xb: number, yb: number): number` a következő probléma megoldására:\nSzámítsd ki a távolságot két pont, A (xa, ya) és B (xb, yb) között.\n\n@param xa - A pont x-koordinátája\n@param ya - A pont y-koordinátája\n@param xb - B pont x-koordinátája\n@param yb - B pont y-koordinátája\n@returns Az A és B pontok közötti távolság\n\nPélda:\ncalculateDistance(0, 0, 3, 4) === 5"
    },
    "instruction_bertscore": {
      "sq": "0.9693469623379339",
      "hy": "0.9941827120306312",
      "bn": "0.9748329348317366",
      "bg": "0.9944449041335973",
      "zh": "0.9657070606054696",
      "fr": "0.9693469623379339",
      "de": "1",
      "ha": "0.9916809623814968",
      "hi": "0.9706696420452453",
      "hu": "0.9687234615718655"
    },
    "level": "easy",
    "test": "const testCalculateDistance = (): void => {\n    console.assert(Math.abs(calculateDistance(0, 0, 3, 4) - 5) < 1e-6);\n    console.assert(Math.abs(calculateDistance(0, 0, 0, 0) - 0) < 1e-6);\n    console.assert(Math.abs(calculateDistance(-1, -1, 2, 2) - 4.242640687) < 1e-6);\n    console.assert(Math.abs(calculateDistance(1.5, 3.9, 4.2, -1.1) - 5.68243) < 1e-6);\n    // console.log(\"All test cases passed!\");\n};\n\ntestCalculateDistance();",
    "entry_point": "calculateDistance",
    "signature": "function calculateDistance(xa: number, ya: number, xb: number, yb: number): number",
    "docstring": {
      "en": "Calculate the distance between two points A (xa, ya) and B (xb, yb).\n\n@param xa - x-coordinate of point A\n@param ya - y-coordinate of point A\n@param xb - x-coordinate of point B\n@param yb - y-coordinate of point B\n@returns The distance between points A and B\n\nExample:\ncalculateDistance(0, 0, 3, 4) === 5",
      "sq": "Llogarit distancën midis dy pikave A (xa, ya) dhe B (xb, yb).\n\n@param xa - koordinata x e pikës A\n@param ya - koordinata y e pikës A\n@param xb - koordinata x e pikës B\n@param yb - koordinata y e pikës B\n@returns Distanca midis pikave A dhe B\n\nShembull:\ncalculateDistance(0, 0, 3, 4) === 5",
      "hy": "Հաշվել հեռավորությունը երկու կետերի A (xa, ya) և B (xb, yb) միջև։\n\n@param xa - A կետի x-կոորդինատը\n@param ya - A կետի y-կոորդինատը\n@param xb - B կետի x-կոորդինատը\n@param yb - B կետի y-կոորդինատը\n@returns Հեռավորությունը A և B կետերի միջև\n\nՕրինակ:\ncalculateDistance(0, 0, 3, 4) === 5",
      "bn": "Calculate the distance between two points A (xa, ya) and B (xb, yb).\n\n@param xa - বিন্দু A এর x-সমন্বয়\n@param ya - বিন্দু A এর y-সমন্বয়\n@param xb - বিন্দু B এর x-সমন্বয়\n@param yb - বিন্দু B এর y-সমন্বয়\n@returns বিন্দু A এবং B এর মধ্যে দূরত্ব\n\nউদাহরণ:\ncalculateDistance(0, 0, 3, 4) === 5",
      "bg": "Изчислете разстоянието между две точки A (xa, ya) и B (xb, yb).\n\n@param xa - x-координата на точка A\n@param ya - y-координата на точка A\n@param xb - x-координата на точка B\n@param yb - y-координата на точка B\n@returns Разстоянието между точките A и B\n\nПример:\ncalculateDistance(0, 0, 3, 4) === 5",
      "zh": "计算两点 A (xa, ya) 和 B (xb, yb) 之间的距离。\n\n@param xa - 点 A 的 x 坐标\n@param ya - 点 A 的 y 坐标\n@param xb - 点 B 的 x 坐标\n@param yb - 点 B 的 y 坐标\n@returns 点 A 和点 B 之间的距离\n\n示例:\ncalculateDistance(0, 0, 3, 4) === 5",
      "fr": "Calculer la distance entre deux points A (xa, ya) et B (xb, yb).\n\n@param xa - coordonnée x du point A\n@param ya - coordonnée y du point A\n@param xb - coordonnée x du point B\n@param yb - coordonnée y du point B\n@returns La distance entre les points A et B\n\nExemple:\ncalculateDistance(0, 0, 3, 4) === 5",
      "de": "Berechne die Entfernung zwischen zwei Punkten A (xa, ya) und B (xb, yb).\n\n@param xa - x-Koordinate des Punktes A\n@param ya - y-Koordinate des Punktes A\n@param xb - x-Koordinate des Punktes B\n@param yb - y-Koordinate des Punktes B\n@returns Die Entfernung zwischen den Punkten A und B\n\nBeispiel:\ncalculateDistance(0, 0, 3, 4) === 5",
      "ha": "Calculate nisan tsakanin maki biyu A (xa, ya) da B (xb, yb).\n\n@param xa - x-kwatance na maki A\n@param ya - y-kwatance na maki A\n@param xb - x-kwatance na maki B\n@param yb - y-kwatance na maki B\n@returns Nisan tsakanin maki A da B\n\nMisali:\ncalculateDistance(0, 0, 3, 4) === 5",
      "hi": "दो बिंदुओं A (xa, ya) और B (xb, yb) के बीच की दूरी की गणना करें।\n\n@param xa - बिंदु A का x-निर्देशांक\n@param ya - बिंदु A का y-निर्देशांक\n@param xb - बिंदु B का x-निर्देशांक\n@param yb - बिंदु B का y-निर्देशांक\n@returns बिंदुओं A और B के बीच की दूरी\n\nउदाहरण:\ncalculateDistance(0, 0, 3, 4) === 5",
      "hu": "Számítsa ki a távolságot két pont, A (xa, ya) és B (xb, yb) között.\n\n@param xa - A pont x-koordinátája\n@param ya - A pont y-koordinátája\n@param xb - B pont x-koordinátája\n@param yb - B pont y-koordinátája\n@returns A és B pontok közötti távolság\n\nPélda:\ncalculateDistance(0, 0, 3, 4) === 5"
    },
    "docstring_bertscore": {
      "sq": "0.9512012825088728",
      "hy": "0.9941902599851106",
      "bn": "0.9883902528588918",
      "bg": "1",
      "zh": "0.9859333936758713",
      "fr": "0.9512012825088728",
      "de": "1",
      "ha": "0.9941902599851106",
      "hi": "0.9941902599851106",
      "hu": "0.9882392937693053"
    }
  },
  {
    "task_id": "TypeScript/6",
    "prompt": {
      "en": "\n/**\n * Finds the factorial of N and applies modulo 10007 to the result.\n *\n * Parameters:\n * - N (number): A non-negative integer (N <= 10000).\n *\n * Returns:\n * - number: The factorial of N modulo 10007.\n *\n * Examples:\n * processRequest(1) // returns 1\n * processRequest(2) // returns 2\n * processRequest(10) // returns 6266\n */\nfunction processRequest(n: number): number",
      "sq": "/**\n * Gjen faktorielin e N dhe aplikon modulo 10007 në rezultat.\n *\n * Parametrat:\n * - N (numër): Një numër i plotë jo-negativ (N <= 10000).\n *\n * Kthen:\n * - numër: Faktorieli i N modulo 10007.\n *\n * Shembuj:\n * processRequest(1) // kthen 1\n * processRequest(2) // kthen 2\n * processRequest(10) // kthen 6266\n */\nfunction processRequest(n: number): number",
      "hy": "/**\n * Գտնում է N-ի ֆակտորիալը և արդյունքին կիրառում մոդուլո 10007:\n *\n * Պարամետրեր:\n * - N (թիվ): Ոչ բացասական ամբողջ թիվ (N <= 10000):\n *\n * Վերադարձնում է:\n * - թիվ: N-ի ֆակտորիալը մոդուլո 10007:\n *\n * Օրինակներ:\n * processRequest(1) // վերադարձնում է 1\n * processRequest(2) // վերադարձնում է 2\n * processRequest(10) // վերադարձնում է 6266\n */\nfunction processRequest(n: number): number",
      "bn": "/**\n * N এর ফ্যাক্টোরিয়াল খুঁজে বের করে এবং ফলাফলের সাথে 10007 মডুলো প্রয়োগ করে।\n *\n * প্যারামিটারসমূহ:\n * - N (সংখ্যা): একটি অ-ঋণাত্মক পূর্ণসংখ্যা (N <= 10000)।\n *\n * রিটার্নস:\n * - সংখ্যা: N এর ফ্যাক্টোরিয়াল মডুলো 10007।\n *\n * উদাহরণসমূহ:\n * processRequest(1) // 1 রিটার্ন করে\n * processRequest(2) // 2 রিটার্ন করে\n * processRequest(10) // 6266 রিটার্ন করে\n */\nfunction processRequest(n: number): number",
      "bg": "/**\n * Намира факториела на N и прилага модул 10007 към резултата.\n *\n * Параметри:\n * - N (число): Ненегативно цяло число (N <= 10000).\n *\n * Връща:\n * - число: Факториелът на N модул 10007.\n *\n * Примери:\n * processRequest(1) // връща 1\n * processRequest(2) // връща 2\n * processRequest(10) // връща 6266\n */\nfunction processRequest(n: number): number",
      "zh": "/**\n * 计算N的阶乘并对结果取模10007。\n *\n * 参数:\n * - N (number): 一个非负整数 (N <= 10000)。\n *\n * 返回:\n * - number: N的阶乘对10007取模的结果。\n *\n * 例子:\n * processRequest(1) // returns 1\n * processRequest(2) // returns 2\n * processRequest(10) // returns 6266\n */\nfunction processRequest(n: number): number",
      "fr": "/**\n * Trouve la factorielle de N et applique le modulo 10007 au résultat.\n *\n * Paramètres:\n * - N (nombre): Un entier non négatif (N <= 10000).\n *\n * Renvoie:\n * - nombre: La factorielle de N modulo 10007.\n *\n * Exemples:\n * processRequest(1) // renvoie 1\n * processRequest(2) // renvoie 2\n * processRequest(10) // renvoie 6266\n */\nfunction processRequest(n: number): number",
      "de": "/**\n * Findet die Fakultät von N und wendet Modulo 10007 auf das Ergebnis an.\n *\n * Parameter:\n * - N (number): Eine nicht-negative ganze Zahl (N <= 10000).\n *\n * Rückgabewert:\n * - number: Die Fakultät von N modulo 10007.\n *\n * Beispiele:\n * processRequest(1) // gibt 1 zurück\n * processRequest(2) // gibt 2 zurück\n * processRequest(10) // gibt 6266 zurück\n */\nfunction processRequest(n: number): number",
      "ha": "/**\n * Nemi fassarar N kuma yi amfani da modulo 10007 ga sakamakon.\n *\n * Sigogi:\n * - N (lamba): Lamba maras kyau (N <= 10000).\n *\n * Komawa:\n * - lamba: Fassarar N modulo 10007.\n *\n * Misalai:\n * processRequest(1) // returns 1\n * processRequest(2) // returns 2\n * processRequest(10) // returns 6266\n */\nfunction processRequest(n: number): number",
      "hi": "/**\n * N का फैक्टोरियल खोजता है और परिणाम पर 10007 का मॉड्यूलो लागू करता है।\n *\n * पैरामीटर्स:\n * - N (संख्या): एक गैर-ऋणात्मक पूर्णांक (N <= 10000)।\n *\n * रिटर्न्स:\n * - संख्या: N का फैक्टोरियल 10007 का मॉड्यूलो।\n *\n * उदाहरण:\n * processRequest(1) // returns 1\n * processRequest(2) // returns 2\n * processRequest(10) // returns 6266\n */\nfunction processRequest(n: number): number",
      "hu": "/**\n * Megkeresi N faktoriálisát, és 10007-tel veszi a maradékot az eredményből.\n *\n * Paraméterek:\n * - N (szám): Egy nem negatív egész szám (N <= 10000).\n *\n * Visszatér:\n * - szám: N faktoriálisa modulo 10007.\n *\n * Példák:\n * processRequest(1) // visszaadja 1\n * processRequest(2) // visszaadja 2\n * processRequest(10) // visszaadja 6266\n */\nfunction processRequest(n: number): number"
    },
    "prompt_bertscore": {
      "sq": "1",
      "hy": "0.9954243505424804",
      "bn": "1",
      "bg": "0.9954243505424804",
      "zh": "0.9681758376113523",
      "fr": "1",
      "de": "0.9936789853843268",
      "ha": "0.951988653339295",
      "hi": "0.9815226074346106",
      "hu": "0.9743891945605047"
    },
    "canonical_solution": "{\n    let a: number[] = Array(10001).fill(0);\n    a[0] = 1;\n    a[1] = 1;\n    for (let i = 2; i <= 10000; i++) {\n        a[i] = (a[i - 1] * i) % 10007;\n    }\n    return a[n];\n}",
    "instruction": {
      "en": "Write a TypeScript function `function processRequest(n: number): number` to solve the following problem:\nFinds the factorial of N and applies modulo 10007 to the result.\n\nParameters:\n- N (number): A non-negative integer (N <= 10000).\n\nReturns:\n- number: The factorial of N modulo 10007.\n\nExamples:\nprocessRequest(1) // returns 1\nprocessRequest(2) // returns 2\nprocessRequest(10) // returns 6266",
      "sq": "Shkruani një funksion TypeScript `function processRequest(n: number): number` për të zgjidhur problemin e mëposhtëm:\nGjen faktorielin e N dhe aplikon modulo 10007 në rezultat.\n\nParametrat:\n- N (numër): Një numër i plotë jo-negativ (N <= 10000).\n\nKthen:\n- numër: Faktorieli i N modulo 10007.\n\nShembuj:\nprocessRequest(1) // kthen 1\nprocessRequest(2) // kthen 2\nprocessRequest(10) // kthen 6266",
      "hy": "Գրեք TypeScript ֆունկցիա `function processRequest(n: number): number` հետևյալ խնդիրը լուծելու համար:\nԳտնում է N-ի ֆակտորիալը և արդյունքին կիրառում մոդուլո 10007-ը։\n\nՊարամետրեր:\n- N (number): Ոչ բացասական ամբողջ թիվ (N <= 10000)։\n\nՎերադարձնում է:\n- number: N-ի ֆակտորիալը մոդուլո 10007։\n\nՕրինակներ:\nprocessRequest(1) // վերադարձնում է 1\nprocessRequest(2) // վերադարձնում է 2\nprocessRequest(10) // վերադարձնում է 6266",
      "bn": "TypeScript ফাংশন `function processRequest(n: number): number` লিখুন নিম্নলিখিত সমস্যার সমাধানের জন্য:\nN এর ফ্যাক্টোরিয়াল খুঁজে বের করুন এবং ফলাফলে 10007 দ্বারা মডুলো প্রয়োগ করুন।\n\nপ্যারামিটারসমূহ:\n- N (number): একটি অ-ঋণাত্মক পূর্ণসংখ্যা (N <= 10000)।\n\nরিটার্নস:\n- number: N এর ফ্যাক্টোরিয়াল মডুলো 10007।\n\nউদাহরণসমূহ:\nprocessRequest(1) // returns 1\nprocessRequest(2) // returns 2\nprocessRequest(10) // returns 6266",
      "bg": "Напишете TypeScript функция `function processRequest(n: number): number`, за да решите следния проблем:\nНамира факториела на N и прилага модул 10007 към резултата.\n\nПараметри:\n- N (number): Неотрицателно цяло число (N <= 10000).\n\nВръща:\n- number: Факториелът на N модул 10007.\n\nПримери:\nprocessRequest(1) // returns 1\nprocessRequest(2) // returns 2\nprocessRequest(10) // returns 6266",
      "zh": "编写一个 TypeScript 函数 `function processRequest(n: number): number` 来解决以下问题：\n找到 N 的阶乘并将结果应用模 10007。\n\n参数：\n- N (number): 一个非负整数 (N <= 10000)。\n\n返回：\n- number: N 的阶乘模 10007。\n\n示例：\nprocessRequest(1) // 返回 1\nprocessRequest(2) // 返回 2\nprocessRequest(10) // 返回 6266",
      "fr": "Écrire une fonction TypeScript `function processRequest(n: number): number` pour résoudre le problème suivant :\nTrouve la factorielle de N et applique le modulo 10007 au résultat.\n\nParamètres :\n- N (number): Un entier non négatif (N <= 10000).\n\nRenvoie :\n- number: La factorielle de N modulo 10007.\n\nExemples :\nprocessRequest(1) // renvoie 1\nprocessRequest(2) // renvoie 2\nprocessRequest(10) // renvoie 6266",
      "de": "Schreiben Sie eine TypeScript-Funktion `function processRequest(n: number): number`, um das folgende Problem zu lösen:\nFindet die Fakultät von N und wendet Modulo 10007 auf das Ergebnis an.\n\nParameter:\n- N (number): Eine nicht-negative ganze Zahl (N <= 10000).\n\nRückgabewert:\n- number: Die Fakultät von N modulo 10007.\n\nBeispiele:\nprocessRequest(1) // returns 1\nprocessRequest(2) // returns 2\nprocessRequest(10) // returns 6266",
      "ha": "Rubuta aikin TypeScript `function processRequest(n: number): number` don warware matsalar mai zuwa:\nNemo factorial na N kuma yi amfani da modulo 10007 ga sakamakon.\n\nSigogi:\n- N (number): Lamba mai kyau (N <= 10000).\n\nDawowa:\n- number: Factorial na N modulo 10007.\n\nMisalai:\nprocessRequest(1) // returns 1\nprocessRequest(2) // returns 2\nprocessRequest(10) // returns 6266",
      "hi": "TypeScript फ़ंक्शन `function processRequest(n: number): number` लिखें ताकि निम्नलिखित समस्या का समाधान किया जा सके:\nN का फैक्टोरियल खोजता है और परिणाम पर 10007 का मॉड्यूलो लागू करता है।\n\nपैरामीटर्स:\n- N (number): एक गैर-ऋणात्मक पूर्णांक (N <= 10000)।\n\nवापसी:\n- number: N का फैक्टोरियल 10007 के मॉड्यूलो के साथ।\n\nउदाहरण:\nprocessRequest(1) // returns 1\nprocessRequest(2) // returns 2\nprocessRequest(10) // returns 6266",
      "hu": "Írj egy TypeScript függvényt `function processRequest(n: number): number` a következő probléma megoldására:\nMegtalálja N faktoriálisát, és 10007-tel veszi a maradékot az eredményből.\n\nParaméterek:\n- N (number): Egy nem negatív egész szám (N <= 10000).\n\nVisszatér:\n- number: N faktoriálisa 10007-tel vett maradéka.\n\nPéldák:\nprocessRequest(1) // visszaadja 1\nprocessRequest(2) // visszaadja 2\nprocessRequest(10) // visszaadja 6266"
    },
    "instruction_bertscore": {
      "sq": "0.9945517672785941",
      "hy": "0.9945984454181372",
      "bn": "0.9676498643623719",
      "bg": "0.9891311441801519",
      "zh": "0.9945517672785941",
      "fr": "0.9945517672785941",
      "de": "0.9906254405366774",
      "ha": "0.9761065528349323",
      "hi": "0.9606129858534489",
      "hu": "0.9434139784204"
    },
    "level": "easy",
    "test": "const testProcessRequest = () => {\n    console.assert(processRequest(0) === 1, \"processRequest(0) should return 1\"); // Added test for boundary condition\n    console.assert(processRequest(1) === 1, \"processRequest(1) should return 1\");\n    console.assert(processRequest(2) === 2, \"processRequest(2) should return 2\");\n    console.assert(processRequest(3) === 6, \"processRequest(3) should return 6\");\n    console.assert(processRequest(4) === 24, \"processRequest(4) should return 24\");\n    console.assert(processRequest(10) === 6266, \"processRequest(10) should return 6266\"); // 10! % 10007 = 3628800 % 10007 = 6266\n    console.assert(processRequest(10000) === 6991, \"processRequest(10000) should return 6991\"); // Added a test for upper boundary condition\n};\n\ntestProcessRequest();",
    "entry_point": "processRequest",
    "signature": "function processRequest(n: number): number",
    "docstring": {
      "en": "Finds the factorial of N and applies modulo 10007 to the result.\n\nParameters:\n- N (number): A non-negative integer (N <= 10000).\n\nReturns:\n- number: The factorial of N modulo 10007.\n\nExamples:\nprocessRequest(1) // returns 1\nprocessRequest(2) // returns 2\nprocessRequest(10) // returns 6266",
      "sq": "Gjen faktorielin e N dhe aplikon modulo 10007 në rezultat.\n\nParametrat:\n- N (number): Një numër i plotë jo-negativ (N <= 10000).\n\nKthen:\n- number: Faktorieli i N modulo 10007.\n\nShembuj:\nprocessRequest(1) // kthen 1\nprocessRequest(2) // kthen 2\nprocessRequest(10) // kthen 6266",
      "hy": "Գտնում է N-ի ֆակտորիալը և արդյունքին կիրառում է 10007 մոդուլը:\n\nՊարամետրեր:\n- N (թիվ): Ոչ բացասական ամբողջ թիվ (N <= 10000):\n\nՎերադարձնում է:\n- թիվ: N-ի ֆակտորիալը մոդուլ 10007:\n\nՕրինակներ:\nprocessRequest(1) // վերադարձնում է 1\nprocessRequest(2) // վերադարձնում է 2\nprocessRequest(10) // վերադարձնում է 6266",
      "bn": "Finds the factorial of N and applies modulo 10007 to the result.\n\nপ্যারামিটারসমূহ:\n- N (number): একটি অ-ঋণাত্মক পূর্ণসংখ্যা (N <= 10000)।\n\nরিটার্নস:\n- number: N এর ফ্যাক্টোরিয়াল 10007 দ্বারা মডুলো।\n\nউদাহরণ:\nprocessRequest(1) // returns 1\nprocessRequest(2) // returns 2\nprocessRequest(10) // returns 6266",
      "bg": "Намира факториела на N и прилага модул 10007 към резултата.\n\nПараметри:\n- N (number): Неотрицателно цяло число (N <= 10000).\n\nВръща:\n- number: Факториелът на N модул 10007.\n\nПримери:\nprocessRequest(1) // връща 1\nprocessRequest(2) // връща 2\nprocessRequest(10) // връща 6266",
      "zh": "计算N的阶乘并对结果应用模10007。\n\n参数：\n- N (number): 一个非负整数 (N <= 10000)。\n\n返回：\n- number: N的阶乘模10007。\n\n示例：\nprocessRequest(1) // 返回 1\nprocessRequest(2) // 返回 2\nprocessRequest(10) // 返回 6266",
      "fr": "Trouve la factorielle de N et applique le modulo 10007 au résultat.\n\nParamètres:\n- N (nombre): Un entier non négatif (N <= 10000).\n\nRenvoie:\n- nombre: La factorielle de N modulo 10007.\n\nExemples:\nprocessRequest(1) // renvoie 1\nprocessRequest(2) // renvoie 2\nprocessRequest(10) // renvoie 6266",
      "de": "Findet die Fakultät von N und wendet Modulo 10007 auf das Ergebnis an.\n\nParameter:\n- N (number): Eine nicht-negative ganze Zahl (N <= 10000).\n\nRückgabewert:\n- number: Die Fakultät von N modulo 10007.\n\nBeispiele:\nprocessRequest(1) // gibt 1 zurück\nprocessRequest(2) // gibt 2 zurück\nprocessRequest(10) // gibt 6266 zurück",
      "ha": "Yana samun factorial na N kuma yana amfani da modulo 10007 ga sakamakon.\n\nSigogi:\n- N (namba): Wani lamba mara kyau (N <= 10000).\n\nYana dawowa:\n- namba: Factorial na N modulo 10007.\n\nMisalai:\nprocessRequest(1) // yana dawowa 1\nprocessRequest(2) // yana dawowa 2\nprocessRequest(10) // yana dawowa 6266",
      "hi": "Finds the factorial of N and applies modulo 10007 to the result.\n\nमापदंड:\n- N (संख्या): एक गैर-ऋणात्मक पूर्णांक (N <= 10000)।\n\nवापसी:\n- संख्या: N का फैक्टोरियल 10007 से मापांकित।\n\nउदाहरण:\nprocessRequest(1) // 1 लौटाता है\nprocessRequest(2) // 2 लौटाता है\nprocessRequest(10) // 6266 लौटाता है",
      "hu": "Megkeresi N faktoriálisát, és a kapott eredményre alkalmazza a 10007 modult.\n\nParaméterek:\n- N (szám): Egy nem negatív egész szám (N <= 10000).\n\nVisszatér:\n- szám: N faktoriálisa modulo 10007.\n\nPéldák:\nprocessRequest(1) // visszaadja 1\nprocessRequest(2) // visszaadja 2\nprocessRequest(10) // visszaadja 6266"
    },
    "docstring_bertscore": {
      "sq": "0.9902335427948956",
      "hy": "0.9768704852803924",
      "bn": "0.9898835560635121",
      "bg": "0.9945636851014561",
      "zh": "0.9822047041630844",
      "fr": "0.9902335427948956",
      "de": "0.9824512044659487",
      "ha": "0.9924774702094468",
      "hi": "0.9882194307312018",
      "hu": "0.9799399205585245"
    }
  },
  {
    "task_id": "TypeScript/7",
    "prompt": {
      "en": "\n/**\n * Calculate the area of a triangle given its base and height.\n * \n * @param base The base length of the triangle.\n * @param height The height of the triangle.\n * \n * @returns The calculated area of the triangle, rounded to one decimal place.\n * \n * Examples:\n * calculateTriangleArea(1, 2) returns 1.0\n * calculateTriangleArea(3, 4) returns 6.0\n */\nfunction calculateTriangleArea(base: number, height: number): number",
      "sq": "/**\n * Llogarit sipërfaqen e një trekëndëshi duke pasur bazën dhe lartësinë e tij.\n * \n * @param base Gjatësia e bazës së trekëndëshit.\n * @param height Lartësia e trekëndëshit.\n * \n * @returns Sipërfaqja e llogaritur e trekëndëshit, e rrumbullakosur në një vend dhjetor.\n * \n * Shembuj:\n * calculateTriangleArea(1, 2) returns 1.0\n * calculateTriangleArea(3, 4) returns 6.0\n */\nfunction calculateTriangleArea(base: number, height: number): number",
      "hy": "/**\n * Հաշվարկել եռանկյունու մակերեսը, տրված նրա հիմքը և բարձրությունը։\n * \n * @param base Եռանկյունու հիմքի երկարությունը։\n * @param height Եռանկյունու բարձրությունը։\n * \n * @returns Հաշվարկված եռանկյունու մակերեսը, կլորացված մինչև մեկ տասնորդական։\n * \n * Օրինակներ:\n * calculateTriangleArea(1, 2) վերադարձնում է 1.0\n * calculateTriangleArea(3, 4) վերադարձնում է 6.0\n */\nfunction calculateTriangleArea(base: number, height: number): number",
      "bn": "/**\n * একটি ত্রিভুজের ভিত্তি এবং উচ্চতা দেওয়া হলে এর ক্ষেত্রফল গণনা করুন।\n * \n * @param base ত্রিভুজের ভিত্তির দৈর্ঘ্য।\n * @param height ত্রিভুজের উচ্চতা।\n * \n * @returns ত্রিভুজের গণনা করা ক্ষেত্রফল, এক দশমিক স্থানে গোলাকার।\n * \n * উদাহরণ:\n * calculateTriangleArea(1, 2) 1.0 প্রদান করে\n * calculateTriangleArea(3, 4) 6.0 প্রদান করে\n */\nfunction calculateTriangleArea(base: number, height: number): number",
      "bg": "/**\n * Изчислява площта на триъгълник, дадени неговата основа и височина.\n * \n * @param base Дължината на основата на триъгълника.\n * @param height Височината на триъгълника.\n * \n * @returns Изчислената площ на триъгълника, закръглена до едно десетично място.\n * \n * Примери:\n * calculateTriangleArea(1, 2) връща 1.0\n * calculateTriangleArea(3, 4) връща 6.0\n */\nfunction calculateTriangleArea(base: number, height: number): number",
      "zh": "/**\n * 计算三角形的面积，给定其底边和高。\n * \n * @param base 三角形的底边长度。\n * @param height 三角形的高度。\n * \n * @returns 计算出的三角形面积，四舍五入到小数点后一位。\n * \n * 示例:\n * calculateTriangleArea(1, 2) 返回 1.0\n * calculateTriangleArea(3, 4) 返回 6.0\n */\nfunction calculateTriangleArea(base: number, height: number): number",
      "fr": "/**\n * Calculer l'aire d'un triangle donné sa base et sa hauteur.\n * \n * @param base La longueur de la base du triangle.\n * @param height La hauteur du triangle.\n * \n * @returns L'aire calculée du triangle, arrondie à une décimale.\n * \n * Exemples :\n * calculateTriangleArea(1, 2) returns 1.0\n * calculateTriangleArea(3, 4) returns 6.0\n */\nfunction calculateTriangleArea(base: number, height: number): number",
      "de": "/**\n * Berechne die Fläche eines Dreiecks, gegeben durch seine Basis und Höhe.\n * \n * @param base Die Basislänge des Dreiecks.\n * @param height Die Höhe des Dreiecks.\n * \n * @returns Die berechnete Fläche des Dreiecks, gerundet auf eine Dezimalstelle.\n * \n * Beispiele:\n * calculateTriangleArea(1, 2) gibt 1.0 zurück\n * calculateTriangleArea(3, 4) gibt 6.0 zurück\n */\nfunction calculateTriangleArea(base: number, height: number): number",
      "ha": "/**\n * Lissafi yanki na alwatika idan aka ba da tushe da tsawo.\n * \n * @param base Tsawon tushe na alwatika.\n * @param height Tsawon alwatika.\n * \n * @returns Yankin da aka lissafa na alwatika, an zagaye zuwa wuri daya na goma.\n * \n * Misalai:\n * calculateTriangleArea(1, 2) returns 1.0\n * calculateTriangleArea(3, 4) returns 6.0\n */\nfunction calculateTriangleArea(base: number, height: number): number",
      "hi": "/**\n * त्रिभुज का क्षेत्रफल इसकी आधार और ऊँचाई के आधार पर गणना करें।\n * \n * @param base त्रिभुज की आधार लंबाई।\n * @param height त्रिभुज की ऊँचाई।\n * \n * @returns त्रिभुज का गणना किया गया क्षेत्रफल, एक दशमलव स्थान तक गोल किया गया।\n * \n * उदाहरण:\n * calculateTriangleArea(1, 2) 1.0 लौटाता है\n * calculateTriangleArea(3, 4) 6.0 लौटाता है\n */\nfunction calculateTriangleArea(base: number, height: number): number",
      "hu": "/**\n * Számítsa ki egy háromszög területét az alapja és magassága alapján.\n * \n * @param base A háromszög alapjának hossza.\n * @param height A háromszög magassága.\n * \n * @returns A háromszög kiszámított területe, egy tizedesjegyre kerekítve.\n * \n * Példák:\n * calculateTriangleArea(1, 2) visszaadja 1.0\n * calculateTriangleArea(3, 4) visszaadja 6.0\n */\nfunction calculateTriangleArea(base: number, height: number): number"
    },
    "prompt_bertscore": {
      "sq": "0.990275851066056",
      "hy": "0.9920871615107132",
      "bn": "0.9885721982879198",
      "bg": "0.9886967395368287",
      "zh": "0.9837639526542082",
      "fr": "0.990275851066056",
      "de": "0.9965595231700947",
      "ha": "0.9794918104189099",
      "hi": "0.9911490302210854",
      "hu": "0.9797818107752208"
    },
    "canonical_solution": "{\n    return (base * height) / 2.0;\n}",
    "instruction": {
      "en": "Write a TypeScript function `function calculateTriangleArea(base: number, height: number): number` to solve the following problem:\nCalculate the area of a triangle given its base and height.\n\n@param base The base length of the triangle.\n@param height The height of the triangle.\n\n@returns The calculated area of the triangle, rounded to one decimal place.\n\nExamples:\ncalculateTriangleArea(1, 2) returns 1.0\ncalculateTriangleArea(3, 4) returns 6.0\n",
      "sq": "Shkruani një funksion TypeScript `function calculateTriangleArea(base: number, height: number): number` për të zgjidhur problemin e mëposhtëm:\nLlogaritni sipërfaqen e një trekëndëshi duke pasur bazën dhe lartësinë e tij.\n\n@param base Gjatësia e bazës së trekëndëshit.\n@param height Lartësia e trekëndëshit.\n\n@returns Sipërfaqja e llogaritur e trekëndëshit, e rrumbullakosur në një vend dhjetor.\n\nShembuj:\ncalculateTriangleArea(1, 2) kthen 1.0\ncalculateTriangleArea(3, 4) kthen 6.0",
      "hy": "Գրեք TypeScript ֆունկցիա `function calculateTriangleArea(base: number, height: number): number` հետևյալ խնդիրը լուծելու համար:\nՀաշվեք եռանկյան մակերեսը, եթե տրված են նրա հիմքը և բարձրությունը։\n\n@param base Եռանկյան հիմքի երկարությունը։\n@param height Եռանկյան բարձրությունը։\n\n@returns Հաշվարկված եռանկյան մակերեսը, կլորացված մինչև մեկ տասնորդական։\n\nՕրինակներ:\ncalculateTriangleArea(1, 2) վերադարձնում է 1.0\ncalculateTriangleArea(3, 4) վերադարձնում է 6.0",
      "bn": "TypeScript ফাংশন `function calculateTriangleArea(base: number, height: number): number` লিখুন নিম্নলিখিত সমস্যার সমাধানের জন্য:\nত্রিভুজের ভিত্তি এবং উচ্চতা দেওয়া হলে এর ক্ষেত্রফল গণনা করুন।\n\n@param base ত্রিভুজের ভিত্তির দৈর্ঘ্য।\n@param height ত্রিভুজের উচ্চতা।\n\n@returns ত্রিভুজের গণনা করা ক্ষেত্রফল, এক দশমিক স্থানে গোলাকার করা।\n\nউদাহরণ:\ncalculateTriangleArea(1, 2) 1.0 প্রদান করে\ncalculateTriangleArea(3, 4) 6.0 প্রদান করে",
      "bg": "Напишете TypeScript функция `function calculateTriangleArea(base: number, height: number): number`, за да решите следния проблем:  \nИзчислете площта на триъгълник, дадени неговата основа и височина.\n\n@param base Дължината на основата на триъгълника.  \n@param height Височината на триъгълника.\n\n@returns Изчислената площ на триъгълника, закръглена до едно десетично място.\n\nПримери:  \ncalculateTriangleArea(1, 2) връща 1.0  \ncalculateTriangleArea(3, 4) връща 6.0",
      "zh": "编写一个 TypeScript 函数 `function calculateTriangleArea(base: number, height: number): number` 来解决以下问题：\n计算给定底边和高的三角形面积。\n\n@param base 三角形的底边长度。\n@param height 三角形的高度。\n\n@returns 计算出的三角形面积，四舍五入到小数点后一位。\n\n示例：\ncalculateTriangleArea(1, 2) 返回 1.0\ncalculateTriangleArea(3, 4) 返回 6.0",
      "fr": "Écrire une fonction TypeScript `function calculateTriangleArea(base: number, height: number): number` pour résoudre le problème suivant :\nCalculer l'aire d'un triangle donné sa base et sa hauteur.\n\n@param base La longueur de la base du triangle.\n@param height La hauteur du triangle.\n\n@returns L'aire calculée du triangle, arrondie à un chiffre après la virgule.\n\nExemples :\ncalculateTriangleArea(1, 2) returns 1.0\ncalculateTriangleArea(3, 4) returns 6.0",
      "de": "Schreiben Sie eine TypeScript-Funktion `function calculateTriangleArea(base: number, height: number): number`, um das folgende Problem zu lösen:\nBerechnen Sie die Fläche eines Dreiecks, gegeben seine Basis und Höhe.\n\n@param base Die Basislänge des Dreiecks.\n@param height Die Höhe des Dreiecks.\n\n@returns Die berechnete Fläche des Dreiecks, gerundet auf eine Dezimalstelle.\n\nBeispiele:\ncalculateTriangleArea(1, 2) returns 1.0\ncalculateTriangleArea(3, 4) returns 6.0",
      "ha": "Rubuta aikin TypeScript `function calculateTriangleArea(base: number, height: number): number` don warware matsalar mai zuwa:\nƘididdige yanki na kusurwar mai kusurwa uku da aka ba da tushe da tsawo.\n\n@param base Tsawon tushe na kusurwar mai kusurwa uku.\n@param height Tsawon kusurwar mai kusurwa uku.\n\n@returns Yankin da aka ƙididdige na kusurwar mai kusurwa uku, an zagaye zuwa wuri ɗaya na ɗabi'u.\n\nMisalai:\ncalculateTriangleArea(1, 2) returns 1.0\ncalculateTriangleArea(3, 4) returns 6.0",
      "hi": "TypeScript फ़ंक्शन `function calculateTriangleArea(base: number, height: number): number` लिखें ताकि निम्नलिखित समस्या का समाधान किया जा सके:\nदिए गए आधार और ऊँचाई के साथ एक त्रिभुज का क्षेत्रफल गणना करें।\n\n@param base त्रिभुज की आधार लंबाई।\n@param height त्रिभुज की ऊँचाई।\n\n@returns त्रिभुज का गणना किया गया क्षेत्रफल, जिसे एक दशमलव स्थान तक गोल किया गया है।\n\nउदाहरण:\ncalculateTriangleArea(1, 2) returns 1.0\ncalculateTriangleArea(3, 4) returns 6.0",
      "hu": "Készítsen egy TypeScript függvényt `function calculateTriangleArea(base: number, height: number): number` a következő probléma megoldására:\nSzámítsa ki egy háromszög területét az alapja és magassága alapján.\n\n@param base A háromszög alapjának hossza.\n@param height A háromszög magassága.\n\n@returns A kiszámított háromszög területe, egy tizedesjegyre kerekítve.\n\nPéldák:\ncalculateTriangleArea(1, 2) visszaadja 1.0\ncalculateTriangleArea(3, 4) visszaadja 6.0"
    },
    "instruction_bertscore": {
      "sq": "0.9881850676752828",
      "hy": "0.9913826195491824",
      "bn": "0.9590030866151611",
      "bg": "0.9881850676752828",
      "zh": "0.9832022259366415",
      "fr": "0.9881850676752828",
      "de": "0.9964226668375616",
      "ha": "0.985106296769242",
      "hi": "0.9515049883614751",
      "hu": "0.9778374179752702"
    },
    "level": "easy",
    "test": "const testCalculateTriangleArea = () => {\n    // The equivalent of C's assertion with a floating-point comparison in TypeScript.\n    const assertCloseTo = (value: number, expected: number, tolerance: number = 1e-6) => {\n        console.assert(Math.abs(value - expected) < tolerance);\n    };\n\n    assertCloseTo(calculateTriangleArea(1, 2), 1.0);\n    assertCloseTo(calculateTriangleArea(3, 4), 6.0);\n    assertCloseTo(calculateTriangleArea(5, 8), 20.0);\n    assertCloseTo(calculateTriangleArea(7, 3), 10.5);\n    assertCloseTo(calculateTriangleArea(10, 10), 50.0);\n\n    // Uncomment to log the outcome to the console.\n    // console.log(\"All tests passed.\");\n};\n\ntestCalculateTriangleArea();",
    "entry_point": "calculateTriangleArea",
    "signature": "function calculateTriangleArea(base: number, height: number): number",
    "docstring": {
      "en": "Calculate the area of a triangle given its base and height.\n\n@param base The base length of the triangle.\n@param height The height of the triangle.\n\n@returns The calculated area of the triangle, rounded to one decimal place.\n\nExamples:\ncalculateTriangleArea(1, 2) returns 1.0\ncalculateTriangleArea(3, 4) returns 6.0\n",
      "sq": "Llogarit sipërfaqen e një trekëndëshi duke pasur bazën dhe lartësinë e tij.\n\n@param base Gjatësia e bazës së trekëndëshit.\n@param height Lartësia e trekëndëshit.\n\n@returns Sipërfaqja e llogaritur e trekëndëshit, e rrumbullakosur në një vend dhjetor.\n\nShembuj:\ncalculateTriangleArea(1, 2) kthen 1.0\ncalculateTriangleArea(3, 4) kthen 6.0",
      "hy": "Հաշվել եռանկյան մակերեսը՝ հաշվի առնելով դրա հիմքը և բարձրությունը։\n\n@param base Եռանկյան հիմքի երկարությունը։\n@param height Եռանկյան բարձրությունը։\n\n@returns Հաշվարկված մակերեսը, կլորացված մինչև մեկ տասնորդական տեղ։\n\nՕրինակներ:\ncalculateTriangleArea(1, 2) վերադարձնում է 1.0\ncalculateTriangleArea(3, 4) վերադարձնում է 6.0",
      "bn": "Calculate the area of a triangle given its base and height.\n\n@param base ত্রিভুজের ভিত্তির দৈর্ঘ্য।\n@param height ত্রিভুজের উচ্চতা।\n\n@returns ত্রিভুজের গণনা করা ক্ষেত্রফল, এক দশমিক স্থানে রাউন্ড করা।\n\nExamples:\ncalculateTriangleArea(1, 2) returns 1.0\ncalculateTriangleArea(3, 4) returns 6.0",
      "bg": "Изчисляване на лицето на триъгълник, дадени неговата основа и височина.\n\n@param base Дължината на основата на триъгълника.\n@param height Височината на триъгълника.\n\n@returns Изчисленото лице на триъгълника, закръглено до едно десетично място.\n\nПримери:\ncalculateTriangleArea(1, 2) връща 1.0\ncalculateTriangleArea(3, 4) връща 6.0",
      "zh": "计算给定底边和高的三角形面积。\n\n@param base 三角形的底边长度。\n@param height 三角形的高度。\n\n@returns 计算出的三角形面积，四舍五入到小数点后一位。\n\n示例：\ncalculateTriangleArea(1, 2) 返回 1.0\ncalculateTriangleArea(3, 4) 返回 6.0",
      "fr": "Calculer l'aire d'un triangle donné sa base et sa hauteur.\n\n@param base La longueur de la base du triangle.\n@param height La hauteur du triangle.\n\n@returns L'aire calculée du triangle, arrondie à un chiffre après la virgule.\n\nExemples :\ncalculateTriangleArea(1, 2) returns 1.0\ncalculateTriangleArea(3, 4) returns 6.0",
      "de": "Berechnen Sie die Fläche eines Dreiecks, gegeben seine Basis und Höhe.\n\n@param base Die Basislänge des Dreiecks.\n@param height Die Höhe des Dreiecks.\n\n@returns Die berechnete Fläche des Dreiecks, gerundet auf eine Dezimalstelle.\n\nBeispiele:\ncalculateTriangleArea(1, 2) returns 1.0\ncalculateTriangleArea(3, 4) returns 6.0",
      "ha": "Calculate the area of a triangle given its base and height.\n\n@param base Tsawon tushe na alwatika.\n@param height Tsawon tsawo na alwatika.\n\n@returns Yankin da aka lissafa na alwatika, an zagaye zuwa wuri daya na goma.\n\nMisalai:\ncalculateTriangleArea(1, 2) returns 1.0\ncalculateTriangleArea(3, 4) returns 6.0",
      "hi": "त्रिभुज का क्षेत्रफल इसकी आधार और ऊँचाई के आधार पर गणना करें।\n\n@param base त्रिभुज की आधार लंबाई।\n@param height त्रिभुज की ऊँचाई।\n\n@returns त्रिभुज का गणना किया गया क्षेत्रफल, एक दशमलव स्थान तक गोल किया गया।\n\nउदाहरण:\ncalculateTriangleArea(1, 2) returns 1.0\ncalculateTriangleArea(3, 4) returns 6.0",
      "hu": "Számítsa ki egy háromszög területét az alapja és magassága alapján.\n\n@param base A háromszög alapjának hossza.\n@param height A háromszög magassága.\n\n@returns A háromszög kiszámított területe, egy tizedesjegyre kerekítve.\n\nPéldák:\ncalculateTriangleArea(1, 2) visszaadja 1.0\ncalculateTriangleArea(3, 4) visszaadja 6.0"
    },
    "docstring_bertscore": {
      "sq": "0.988567232528394",
      "hy": "0.983432041287499",
      "bn": "0.9720975958545052",
      "bg": "0.9820835396306531",
      "zh": "0.9809048669495921",
      "fr": "0.9855998932661137",
      "de": "0.9954128299803803",
      "ha": "0.966136499489267",
      "hi": "0.9742094340656681",
      "hu": "0.9754419355799895"
    }
  },
  {
    "task_id": "TypeScript/8",
    "prompt": {
      "en": "\n/**\n * Calculate the Hamming distance between two integers in binary representation.\n * Parameters:\n * - x (number): The first positive integer (x <= 1,000,000,000).\n * - y (number): The second positive integer (y <= 1,000,000,000).\n * Returns:\n * - number: The Hamming distance between x and y, i.e., the number of bits\n *           that need to be flipped to transform x into y in binary.\n * Example usage:\n *   hamming_distance(1, 2); // returns 2\n *   hamming_distance(4, 7); // returns 2\n */\nfunction hamming_distance(x: number, y: number): number",
      "sq": "/**\n * Llogarit distancën Hamming midis dy numrave të plotë në përfaqësimin binar.\n * Parametrat:\n * - x (numër): Numri i parë pozitiv (x <= 1,000,000,000).\n * - y (numër): Numri i dytë pozitiv (y <= 1,000,000,000).\n * Kthen:\n * - numër: Distanca Hamming midis x dhe y, dmth., numri i biteve\n *           që duhet të ndryshohen për të transformuar x në y në binar.\n * Shembull përdorimi:\n *   hamming_distance(1, 2); // kthen 2\n *   hamming_distance(4, 7); // kthen 2\n */\nfunction hamming_distance(x: number, y: number): number",
      "hy": "/**\n * Հաշվել Հեմինգի հեռավորությունը երկու ամբողջ թվերի միջև երկբայն ներկայացման մեջ:\n * Պարամետրեր:\n * - x (number): Առաջին դրական ամբողջ թիվը (x <= 1,000,000,000):\n * - y (number): Երկրորդ դրական ամբողջ թիվը (y <= 1,000,000,000):\n * Վերադարձնում է:\n * - number: Հեմինգի հեռավորությունը x և y միջև, այսինքն՝ բիթերի քանակը,\n *           որոնք պետք է փոխվեն՝ x-ը y-ի վերածելու համար երկբայն:\n * Օրինակ օգտագործում:\n *   hamming_distance(1, 2); // վերադարձնում է 2\n *   hamming_distance(4, 7); // վերադարձնում է 2\n */\nfunction hamming_distance(x: number, y: number): number",
      "bn": "/**\n * দুটি পূর্ণসংখ্যার বাইনারি উপস্থাপনার মধ্যে হ্যামিং দূরত্ব গণনা করুন।\n * প্যারামিটার:\n * - x (number): প্রথম ধনাত্মক পূর্ণসংখ্যা (x <= 1,000,000,000)।\n * - y (number): দ্বিতীয় ধনাত্মক পূর্ণসংখ্যা (y <= 1,000,000,000)।\n * রিটার্ন:\n * - number: x এবং y এর মধ্যে হ্যামিং দূরত্ব, অর্থাৎ x কে বাইনারিতে y তে রূপান্তর করতে যে সংখ্যক বিট\n *           পরিবর্তন করতে হবে।\n * উদাহরণ ব্যবহার:\n *   hamming_distance(1, 2); // returns 2\n *   hamming_distance(4, 7); // returns 2\n */\nfunction hamming_distance(x: number, y: number): number",
      "bg": "/**\n * Изчислява разстоянието на Хаминг между две цели числа в двоична форма.\n * Параметри:\n * - x (number): Първото положително цяло число (x <= 1,000,000,000).\n * - y (number): Второто положително цяло число (y <= 1,000,000,000).\n * Връща:\n * - number: Разстоянието на Хаминг между x и y, т.е. броят на битовете,\n *           които трябва да се обърнат, за да се преобразува x в y в двоична форма.\n * Пример за използване:\n *   hamming_distance(1, 2); // връща 2\n *   hamming_distance(4, 7); // връща 2\n */\nfunction hamming_distance(x: number, y: number): number",
      "zh": "/**\n * 计算两个整数在二进制表示中的汉明距离。\n * 参数：\n * - x (number): 第一个正整数 (x <= 1,000,000,000)。\n * - y (number): 第二个正整数 (y <= 1,000,000,000)。\n * 返回：\n * - number: x 和 y 之间的汉明距离，即需要翻转的位数\n *           以将 x 转换为二进制形式的 y。\n * 示例用法：\n *   hamming_distance(1, 2); // returns 2\n *   hamming_distance(4, 7); // returns 2\n */\nfunction hamming_distance(x: number, y: number): number",
      "fr": "/**\n * Calculer la distance de Hamming entre deux entiers en représentation binaire.\n * Paramètres :\n * - x (number) : Le premier entier positif (x <= 1,000,000,000).\n * - y (number) : Le deuxième entier positif (y <= 1,000,000,000).\n * Renvoie :\n * - number : La distance de Hamming entre x et y, c'est-à-dire le nombre de bits\n *            qui doivent être inversés pour transformer x en y en binaire.\n * Exemple d'utilisation :\n *   hamming_distance(1, 2); // renvoie 2\n *   hamming_distance(4, 7); // renvoie 2\n */\nfunction hamming_distance(x: number, y: number): number",
      "de": "/**\n * Berechne die Hamming-Distanz zwischen zwei ganzen Zahlen in binärer Darstellung.\n * Parameter:\n * - x (number): Die erste positive ganze Zahl (x <= 1,000,000,000).\n * - y (number): Die zweite positive ganze Zahl (y <= 1,000,000,000).\n * Rückgabe:\n * - number: Die Hamming-Distanz zwischen x und y, d.h. die Anzahl der Bits,\n *           die umgekehrt werden müssen, um x in y in binär zu transformieren.\n * Beispielverwendung:\n *   hamming_distance(1, 2); // gibt 2 zurück\n *   hamming_distance(4, 7); // gibt 2 zurück\n */\nfunction hamming_distance(x: number, y: number): number",
      "ha": "/**\n * Lissafi nesa ta Hamming tsakanin lambobi biyu a wakilcin binary.\n * Sigogi:\n * - x (lamba): Lamba ta farko mai kyau (x <= 1,000,000,000).\n * - y (lamba): Lamba ta biyu mai kyau (y <= 1,000,000,000).\n * Komawa:\n * - lamba: Nesa ta Hamming tsakanin x da y, wato, yawan bits\n *           da ake bukatar a juya don canza x zuwa y a binary.\n * Misalin amfani:\n *   hamming_distance(1, 2); // yana dawowa 2\n *   hamming_distance(4, 7); // yana dawowa 2\n */\nfunction hamming_distance(x: number, y: number): number",
      "hi": "/**\n * दो पूर्णांकों के द्विआधारी अभ्यावेदन में हैमिंग दूरी की गणना करें।\n * पैरामीटर:\n * - x (संख्या): पहला धनात्मक पूर्णांक (x <= 1,000,000,000)।\n * - y (संख्या): दूसरा धनात्मक पूर्णांक (y <= 1,000,000,000)।\n * रिटर्न करता है:\n * - संख्या: x और y के बीच की हैमिंग दूरी, अर्थात्, x को द्विआधारी में y में बदलने के लिए\n *           जिन बिट्स को उलटना आवश्यक है उनकी संख्या।\n * उदाहरण उपयोग:\n *   hamming_distance(1, 2); // 2 लौटाता है\n *   hamming_distance(4, 7); // 2 लौटाता है\n */\nfunction hamming_distance(x: number, y: number): number",
      "hu": "/**\n * Számítsa ki a Hamming-távolságot két egész szám bináris ábrázolása között.\n * Paraméterek:\n * - x (szám): Az első pozitív egész szám (x <= 1,000,000,000).\n * - y (szám): A második pozitív egész szám (y <= 1,000,000,000).\n * Visszatér:\n * - szám: A Hamming-távolság x és y között, azaz a bitek száma,\n *         amelyeket meg kell változtatni ahhoz, hogy x-et y-ra alakítsuk binárisan.\n * Példa használat:\n *   hamming_distance(1, 2); // visszaadja 2\n *   hamming_distance(4, 7); // visszaadja 2\n */\nfunction hamming_distance(x: number, y: number): number"
    },
    "prompt_bertscore": {
      "sq": "0.990059343950728",
      "hy": "0.9932151834446102",
      "bn": "0.9815911349160676",
      "bg": "0.9895260213776493",
      "zh": "0.9819166901105838",
      "fr": "0.9960168649691074",
      "de": "0.9990275056544532",
      "ha": "0.9863795175116756",
      "hi": "0.9842279532243058",
      "hu": "0.9856320713878414"
    },
    "canonical_solution": "{\n    let distance = 0;\n    let xor_result = x ^ y; // XOR x and y to get a number where set bits are the differences\n\n    // Count the number of bits set in xor_result\n    while (xor_result) {\n        if (xor_result & 1) {\n            distance++;\n        }\n        xor_result >>>= 1;\n    }\n\n    return distance;\n}",
    "instruction": {
      "en": "Write a TypeScript function `function hamming_distance(x: number, y: number): number` to solve the following problem:\nCalculate the Hamming distance between two integers in binary representation.\nParameters:\n- x (number): The first positive integer (x <= 1,000,000,000).\n- y (number): The second positive integer (y <= 1,000,000,000).\nReturns:\n- number: The Hamming distance between x and y, i.e., the number of bits that need to be flipped to transform x into y in binary.\nExample usage:\n  hamming_distance(1, 2); // returns 2\n  hamming_distance(4, 7); // returns 2",
      "sq": "Shkruani një funksion TypeScript `function hamming_distance(x: number, y: number): number` për të zgjidhur problemin e mëposhtëm:\nLlogaritni distancën Hamming midis dy numrave të plotë në përfaqësimin binar.\nParametrat:\n- x (number): Numri i parë pozitiv (x <= 1,000,000,000).\n- y (number): Numri i dytë pozitiv (y <= 1,000,000,000).\nKthen:\n- number: Distanca Hamming midis x dhe y, dmth., numri i bitëve që duhet të ndryshohen për të transformuar x në y në binar.\nShembull përdorimi:\n  hamming_distance(1, 2); // kthen 2\n  hamming_distance(4, 7); // kthen 2",
      "hy": "Գրեք TypeScript ֆունկցիա `function hamming_distance(x: number, y: number): number` հետևյալ խնդիրը լուծելու համար:\nՀաշվարկել Հեմինգի հեռավորությունը երկու ամբողջ թվերի միջև բինար ներկայացման մեջ:\nՊարամետրեր:\n- x (number): Առաջին դրական ամբողջ թիվը (x <= 1,000,000,000):\n- y (number): Երկրորդ դրական ամբողջ թիվը (y <= 1,000,000,000):\nՎերադարձնում է:\n- number: Հեմինգի հեռավորությունը x-ի և y-ի միջև, այսինքն՝ բիթերի քանակը, որոնք պետք է փոխվեն x-ը y-ի վերածելու համար բինար ձևով:\nՕրինակ օգտագործում:\n  hamming_distance(1, 2); // վերադարձնում է 2\n  hamming_distance(4, 7); // վերադարձնում է 2",
      "bn": "TypeScript ফাংশন `function hamming_distance(x: number, y: number): number` লিখুন নিম্নলিখিত সমস্যার সমাধানের জন্য:\nদুটি পূর্ণসংখ্যার বাইনারি উপস্থাপনার মধ্যে হ্যামিং দূরত্ব গণনা করুন।\nপ্যারামিটারসমূহ:\n- x (number): প্রথম ধনাত্মক পূর্ণসংখ্যা (x <= 1,000,000,000)।\n- y (number): দ্বিতীয় ধনাত্মক পূর্ণসংখ্যা (y <= 1,000,000,000)।\nরিটার্নস:\n- number: x এবং y এর মধ্যে হ্যামিং দূরত্ব, অর্থাৎ x কে বাইনারিতে y তে রূপান্তর করতে যে সংখ্যক বিট পরিবর্তন করতে হবে।\nউদাহরণ ব্যবহার:\n  hamming_distance(1, 2); // returns 2\n  hamming_distance(4, 7); // returns 2",
      "bg": "Напишете функция на TypeScript `function hamming_distance(x: number, y: number): number`, за да решите следния проблем:\nИзчислете Хаминговото разстояние между две цели числа в двоична форма.\nПараметри:\n- x (number): Първото положително цяло число (x <= 1,000,000,000).\n- y (number): Второто положително цяло число (y <= 1,000,000,000).\nВръща:\n- number: Хаминговото разстояние между x и y, т.е. броят на битовете, които трябва да бъдат обърнати, за да се трансформира x в y в двоична форма.\nПример за използване:\n  hamming_distance(1, 2); // връща 2\n  hamming_distance(4, 7); // връща 2",
      "zh": "编写一个 TypeScript 函数 `function hamming_distance(x: number, y: number): number` 来解决以下问题：\n计算两个整数在二进制表示中的汉明距离。\n参数：\n- x (number): 第一个正整数 (x <= 1,000,000,000)。\n- y (number): 第二个正整数 (y <= 1,000,000,000)。\n返回：\n- number: x 和 y 之间的汉明距离，即需要翻转的位数以将 x 转换为二进制中的 y。\n示例用法：\n  hamming_distance(1, 2); // returns 2\n  hamming_distance(4, 7); // returns 2",
      "fr": "Écrire une fonction TypeScript `function hamming_distance(x: number, y: number): number` pour résoudre le problème suivant :\nCalculer la distance de Hamming entre deux entiers en représentation binaire.\nParamètres :\n- x (number) : Le premier entier positif (x <= 1,000,000,000).\n- y (number) : Le deuxième entier positif (y <= 1,000,000,000).\nRenvoie :\n- number : La distance de Hamming entre x et y, c'est-à-dire le nombre de bits qui doivent être inversés pour transformer x en y en binaire.\nExemple d'utilisation :\n  hamming_distance(1, 2); // returns 2\n  hamming_distance(4, 7); // returns 2",
      "de": "Schreiben Sie eine TypeScript-Funktion `function hamming_distance(x: number, y: number): number`, um das folgende Problem zu lösen:\nBerechnen Sie den Hamming-Abstand zwischen zwei ganzen Zahlen in Binärdarstellung.\nParameter:\n- x (number): Die erste positive ganze Zahl (x <= 1,000,000,000).\n- y (number): Die zweite positive ganze Zahl (y <= 1,000,000,000).\nRückgabewert:\n- number: Der Hamming-Abstand zwischen x und y, d.h. die Anzahl der Bits, die umgekehrt werden müssen, um x in y in Binärform zu transformieren.\nBeispielverwendung:\n  hamming_distance(1, 2); // returns 2\n  hamming_distance(4, 7); // returns 2",
      "ha": "Rubuta aikin TypeScript `function hamming_distance(x: number, y: number): number` don warware matsalar mai zuwa:\nƘididdige nisan Hamming tsakanin lambobi biyu a wakilcin binary.\nSigogi:\n- x (number): Lamba ta farko mai kyau (x <= 1,000,000,000).\n- y (number): Lamba ta biyu mai kyau (y <= 1,000,000,000).\nYa dawo:\n- number: Nisan Hamming tsakanin x da y, wato, adadin bits da ake buƙatar juyawa don canza x zuwa y a cikin binary.\nMisalin amfani:\n  hamming_distance(1, 2); // returns 2\n  hamming_distance(4, 7); // returns 2",
      "hi": "TypeScript फ़ंक्शन `function hamming_distance(x: number, y: number): number` लिखें ताकि निम्नलिखित समस्या का समाधान किया जा सके:\nदो पूर्णांकों के बीच बाइनरी प्रतिनिधित्व में हैमिंग दूरी की गणना करें।\nपैरामीटर्स:\n- x (number): पहला धनात्मक पूर्णांक (x <= 1,000,000,000)।\n- y (number): दूसरा धनात्मक पूर्णांक (y <= 1,000,000,000)।\nवापसी मान:\n- number: x और y के बीच हैमिंग दूरी, अर्थात्, x को बाइनरी में y में बदलने के लिए कितने बिट्स को उलटना आवश्यक है।\nउदाहरण उपयोग:\n  hamming_distance(1, 2); // returns 2\n  hamming_distance(4, 7); // returns 2",
      "hu": "Írj egy TypeScript függvényt `function hamming_distance(x: number, y: number): number` a következő probléma megoldására:\nSzámítsd ki a Hamming-távolságot két egész szám bináris ábrázolása között.\nParaméterek:\n- x (number): Az első pozitív egész szám (x <= 1,000,000,000).\n- y (number): A második pozitív egész szám (y <= 1,000,000,000).\nVisszatérési érték:\n- number: A Hamming-távolság x és y között, azaz a bitek száma, amelyeket meg kell változtatni, hogy x-et y-á alakítsuk binárisan.\nPélda használat:\n  hamming_distance(1, 2); // returns 2\n  hamming_distance(4, 7); // returns 2"
    },
    "instruction_bertscore": {
      "sq": "0.986444271015893",
      "hy": "0.9734276248859147",
      "bn": "0.9747687772186623",
      "bg": "0.9889791919386602",
      "zh": "0.9937572457544545",
      "fr": "0.9962786598113114",
      "de": "0.9926641827676195",
      "ha": "0.9869833538700217",
      "hi": "0.966090615871248",
      "hu": "0.9795952968474291"
    },
    "level": "easy",
    "test": "(() => {\n    console.assert(hamming_distance(1, 2) === 2, '01 and 10 have 2 different bits');\n    console.assert(hamming_distance(4, 7) === 2, '100 and 111 have 2 different bits');\n    console.assert(hamming_distance(25, 30) === 3, '11001 and 11110 have 3 different bits');\n    console.assert(hamming_distance(0, 0) === 0, 'Same numbers have 0 different bits');\n    console.assert(hamming_distance(0xFFFFFFF, 0) === 28, 'Max unsigned int and 0 have 28 different bits');\n\n    // If no assertion fails, log success message to the console\n    // console.log(\"All tests passed!\");\n})();",
    "entry_point": "hamming_distance",
    "signature": "function hamming_distance(x: number, y: number): number",
    "docstring": {
      "en": "Calculate the Hamming distance between two integers in binary representation.\nParameters:\n- x (number): The first positive integer (x <= 1,000,000,000).\n- y (number): The second positive integer (y <= 1,000,000,000).\nReturns:\n- number: The Hamming distance between x and y, i.e., the number of bits that need to be flipped to transform x into y in binary.\nExample usage:\n  hamming_distance(1, 2); // returns 2\n  hamming_distance(4, 7); // returns 2",
      "sq": "Llogarit distancën Hamming midis dy numrave të plotë në përfaqësimin binar.\nParametrat:\n- x (numër): Numri i parë pozitiv i plotë (x <= 1,000,000,000).\n- y (numër): Numri i dytë pozitiv i plotë (y <= 1,000,000,000).\nKthen:\n- numër: Distanca Hamming midis x dhe y, dmth., numri i biteve që duhet të ndryshohen për të transformuar x në y në binar.\nShembull përdorimi:\n  hamming_distance(1, 2); // kthen 2\n  hamming_distance(4, 7); // kthen 2",
      "hy": "Հաշվարկել Հեմինգի հեռավորությունը երկու ամբողջ թվերի միջև երկբայն ներկայացմամբ։  \nՊարամետրեր:  \n- x (թիվ): Առաջին դրական ամբողջ թիվը (x <= 1,000,000,000)։  \n- y (թիվ): Երկրորդ դրական ամբողջ թիվը (y <= 1,000,000,000)։  \nՎերադարձնում է:  \n- թիվ: Հեմինգի հեռավորությունը x-ի և y-ի միջև, այսինքն՝ բիթերի քանակը, որոնք պետք է փոխել՝ x-ը y դարձնելու համար երկբայն։  \nՕրինակ օգտագործում:  \n  hamming_distance(1, 2); // վերադարձնում է 2  \n  hamming_distance(4, 7); // վերադարձնում է 2  ",
      "bn": "Calculate the Hamming distance between two integers in binary representation.\nParameters:\n- x (number): প্রথম ধনাত্মক পূর্ণসংখ্যা (x <= 1,000,000,000)।\n- y (number): দ্বিতীয় ধনাত্মক পূর্ণসংখ্যা (y <= 1,000,000,000)।\nReturns:\n- number: x এবং y এর মধ্যে হ্যামিং দূরত্ব, অর্থাৎ x কে y তে রূপান্তর করতে যে সংখ্যক বিট পরিবর্তন করতে হবে তার সংখ্যা।\nExample usage:\n  hamming_distance(1, 2); // 2 ফেরত দেয়\n  hamming_distance(4, 7); // 2 ফেরত দেয়",
      "bg": "Изчислете разстоянието на Хаминг между две цели числа в двоична форма.\nПараметри:\n- x (number): Първото положително цяло число (x <= 1,000,000,000).\n- y (number): Второто положително цяло число (y <= 1,000,000,000).\nВръща:\n- number: Разстоянието на Хаминг между x и y, т.е. броят на битовете, които трябва да бъдат обърнати, за да се трансформира x в y в двоична форма.\nПример за използване:\n  hamming_distance(1, 2); // връща 2\n  hamming_distance(4, 7); // връща 2",
      "zh": "计算两个整数在二进制表示中的汉明距离。\n参数：\n- x (number): 第一个正整数 (x <= 1,000,000,000)。\n- y (number): 第二个正整数 (y <= 1,000,000,000)。\n返回：\n- number: x 和 y 之间的汉明距离，即需要翻转的位数以将 x 转换为 y 的二进制形式。\n示例用法：\n  hamming_distance(1, 2); // 返回 2\n  hamming_distance(4, 7); // 返回 2",
      "fr": "Calculer la distance de Hamming entre deux entiers en représentation binaire.\nParamètres :\n- x (nombre) : Le premier entier positif (x <= 1,000,000,000).\n- y (nombre) : Le deuxième entier positif (y <= 1,000,000,000).\nRenvoie :\n- nombre : La distance de Hamming entre x et y, c'est-à-dire le nombre de bits qui doivent être inversés pour transformer x en y en binaire.\nExemple d'utilisation :\n  hamming_distance(1, 2); // renvoie 2\n  hamming_distance(4, 7); // renvoie 2",
      "de": "Berechnen Sie den Hamming-Abstand zwischen zwei ganzen Zahlen in binärer Darstellung.\nParameter:\n- x (number): Die erste positive ganze Zahl (x <= 1.000.000.000).\n- y (number): Die zweite positive ganze Zahl (y <= 1.000.000.000).\nRückgabewert:\n- number: Der Hamming-Abstand zwischen x und y, d.h., die Anzahl der Bits, die umgekippt werden müssen, um x in y im Binärformat zu transformieren.\nBeispielverwendung:\n  hamming_distance(1, 2); // gibt 2 zurück\n  hamming_distance(4, 7); // gibt 2 zurück",
      "ha": "Calculate the Hamming distance between two integers in binary representation.\nSigogi:\n- x (number): Lamba na farko mai kyau (x <= 1,000,000,000).\n- y (number): Lamba na biyu mai kyau (y <= 1,000,000,000).\nAbin da ake dawowa da shi:\n- number: Nisan Hamming tsakanin x da y, wato, adadin bits da ake buƙatar juyawa don canza x zuwa y a cikin binary.\nMisalin amfani:\n  hamming_distance(1, 2); // yana dawowa 2\n  hamming_distance(4, 7); // yana dawowa 2",
      "hi": "Calculate the Hamming distance between two integers in binary representation.\nParameters:\n- x (number): पहला धनात्मक पूर्णांक (x <= 1,000,000,000)।\n- y (number): दूसरा धनात्मक पूर्णांक (y <= 1,000,000,000)।\nReturns:\n- number: x और y के बीच का हैमिंग दूरी, अर्थात्, x को y में परिवर्तित करने के लिए कितने बिट्स को उलटना आवश्यक है।\nExample usage:\n  hamming_distance(1, 2); // returns 2\n  hamming_distance(4, 7); // returns 2",
      "hu": "Számítsa ki a Hamming-távolságot két egész szám bináris ábrázolása között.\nParaméterek:\n- x (szám): Az első pozitív egész szám (x <= 1,000,000,000).\n- y (szám): A második pozitív egész szám (y <= 1,000,000,000).\nVisszatérési érték:\n- szám: A Hamming-távolság x és y között, azaz a bitek száma, amelyeket meg kell változtatni ahhoz, hogy x-et y-ra alakítsuk binárisan.\nPélda használat:\n  hamming_distance(1, 2); // visszaadja: 2\n  hamming_distance(4, 7); // visszaadja: 2"
    },
    "docstring_bertscore": {
      "sq": "0.9911686946288079",
      "hy": "0.989939768461345",
      "bn": "0.9781913773142744",
      "bg": "0.9866746822578935",
      "zh": "0.9862273666398029",
      "fr": "0.9893377197764283",
      "de": "0.9905090431333909",
      "ha": "0.9852582490107337",
      "hi": "0.9851591324505973",
      "hu": "0.9694615720677912"
    }
  },
  {
    "task_id": "TypeScript/9",
    "prompt": {
      "en": "\n/**\n * Counts the number of odd integers in a given list of numbers.\n * \n * @param count - The count of numbers to evaluate.\n * @param numbers - A list of integers to be checked for oddness.\n * @returns The count of odd numbers in the input list.\n *\n * @example\n * ```\n * countOddNumbers(5, [1, 4, 3, 2, 5]) // returns 3\n * ```\n */\nfunction countOddNumbers(count: number, numbers: number[]): number",
      "sq": "/**\n * Numëron numrin e numrave tek në një listë të dhënë numrash.\n * \n * @param count - Numri i numrave për t'u vlerësuar.\n * @param numbers - Një listë e numrave të plotë për t'u kontrolluar për tek.\n * @returns Numri i numrave tek në listën hyrëse.\n *\n * @example\n * ```\n * countOddNumbers(5, [1, 4, 3, 2, 5]) // returns 3\n * ```\n */\nfunction countOddNumbers(count: number, numbers: number[]): number",
      "hy": "/**\n * Հաշվում է տրված թվերի ցուցակում կենտ ամբողջ թվերի քանակը։\n * \n * @param count - Քննելու համար թվերի քանակը։\n * @param numbers - Ցուցակ ամբողջ թվերի, որոնք պետք է ստուգվեն կենտ լինելու համար։\n * @returns Կենտ թվերի քանակը մուտքային ցուցակում։\n *\n * @example\n * ```\n * countOddNumbers(5, [1, 4, 3, 2, 5]) // վերադարձնում է 3\n * ```\n */\nfunction countOddNumbers(count: number, numbers: number[]): number",
      "bn": "/**\n * প্রদত্ত সংখ্যার তালিকায় কতগুলি বিজোড় পূর্ণসংখ্যা আছে তা গণনা করে।\n * \n * @param count - মূল্যায়ন করার জন্য সংখ্যার সংখ্যা।\n * @param numbers - বিজোড়তা যাচাই করার জন্য পূর্ণসংখ্যার একটি তালিকা।\n * @returns ইনপুট তালিকায় বিজোড় সংখ্যার সংখ্যা।\n *\n * @example\n * ```\n * countOddNumbers(5, [1, 4, 3, 2, 5]) // returns 3\n * ```\n */\nfunction countOddNumbers(count: number, numbers: number[]): number",
      "bg": "/**\n * Брои броя на нечетните цели числа в даден списък от числа.\n * \n * @param count - Броят на числата, които да се оценят.\n * @param numbers - Списък от цели числа, които да бъдат проверени за нечетност.\n * @returns Броят на нечетните числа в входния списък.\n *\n * @example\n * ```\n * countOddNumbers(5, [1, 4, 3, 2, 5]) // returns 3\n * ```\n */\nfunction countOddNumbers(count: number, numbers: number[]): number",
      "zh": "/**\n * 计算给定数字列表中奇数的数量。\n * \n * @param count - 要评估的数字数量。\n * @param numbers - 要检查奇偶性的整数列表。\n * @returns 输入列表中奇数的数量。\n *\n * @example\n * ```\n * countOddNumbers(5, [1, 4, 3, 2, 5]) // returns 3\n * ```\n */\nfunction countOddNumbers(count: number, numbers: number[]): number",
      "fr": "/**\n * Compte le nombre d'entiers impairs dans une liste donnée de nombres.\n * \n * @param count - Le nombre de nombres à évaluer.\n * @param numbers - Une liste d'entiers à vérifier pour l'impairité.\n * @returns Le nombre de nombres impairs dans la liste d'entrée.\n *\n * @example\n * ```\n * countOddNumbers(5, [1, 4, 3, 2, 5]) // returns 3\n * ```\n */\nfunction countOddNumbers(count: number, numbers: number[]): number",
      "de": "/**\n * Zählt die Anzahl der ungeraden ganzen Zahlen in einer gegebenen Liste von Zahlen.\n * \n * @param count - Die Anzahl der zu bewertenden Zahlen.\n * @param numbers - Eine Liste von ganzen Zahlen, die auf Ungeradzahligkeit überprüft werden sollen.\n * @returns Die Anzahl der ungeraden Zahlen in der Eingabeliste.\n *\n * @example\n * ```\n * countOddNumbers(5, [1, 4, 3, 2, 5]) // returns 3\n * ```\n */\nfunction countOddNumbers(count: number, numbers: number[]): number",
      "ha": "/**\n * Yana ƙidaya yawan lambobin da ba su da ma'aurata a cikin jerin lambobi da aka bayar.\n * \n * @param count - Yawan lambobin da za a tantance.\n * @param numbers - Jerin lambobi da za a duba don rashin ma'aurata.\n * @returns Yawan lambobin da ba su da ma'aurata a cikin jerin shigarwa.\n *\n * @example\n * ```\n * countOddNumbers(5, [1, 4, 3, 2, 5]) // returns 3\n * ```\n */\nfunction countOddNumbers(count: number, numbers: number[]): number",
      "hi": "/**\n * दिए गए संख्याओं की सूची में विषम पूर्णांकों की संख्या की गणना करता है।\n * \n * @param count - मूल्यांकन के लिए संख्याओं की संख्या।\n * @param numbers - पूर्णांकों की एक सूची जिसे विषमता के लिए जांचा जाना है।\n * @returns इनपुट सूची में विषम संख्याओं की संख्या।\n *\n * @example\n * ```\n * countOddNumbers(5, [1, 4, 3, 2, 5]) // returns 3\n * ```\n */\nfunction countOddNumbers(count: number, numbers: number[]): number",
      "hu": "/**\n * Megszámolja a páratlan egész számok számát egy adott számok listájában.\n * \n * @param count - Az értékelendő számok száma.\n * @param numbers - Egy egész számokból álló lista, amelyet páratlanság szempontjából ellenőrzünk.\n * @returns A páratlan számok száma a bemeneti listában.\n *\n * @példa\n * ```\n * countOddNumbers(5, [1, 4, 3, 2, 5]) // visszaadja: 3\n * ```\n */\nfunction countOddNumbers(count: number, numbers: number[]): number"
    },
    "prompt_bertscore": {
      "sq": "0.9814880457483105",
      "hy": "0.9899965767503209",
      "bn": "0.9798247149375243",
      "bg": "0.9890848633013708",
      "zh": "0.9680997621754159",
      "fr": "0.9873794228498053",
      "de": "0.9890848633013708",
      "ha": "0.9759257991881906",
      "hi": "0.9903876799705786",
      "hu": "0.985043529568835"
    },
    "canonical_solution": "{\n    let ans = 0;\n    numbers.slice(0, count).forEach(num => {\n        if (num % 2 === 1)\n            ans++;\n    });\n    return ans;\n}",
    "instruction": {
      "en": "Write a TypeScript function `function countOddNumbers(count: number, numbers: number[]): number` to solve the following problem:\nCounts the number of odd integers in a given list of numbers.\n\n@param count - The count of numbers to evaluate.\n@param numbers - A list of integers to be checked for oddness.\n@returns The count of odd numbers in the input list.\n\n@example\n```\ncountOddNumbers(5, [1, 4, 3, 2, 5]) // returns 3\n```",
      "sq": "Shkruani një funksion TypeScript `function countOddNumbers(count: number, numbers: number[]): number` për të zgjidhur problemin në vijim:\nNumëron numrin e numrave tek në një listë të dhënë numrash.\n\n@param count - Numri i numrave për t'u vlerësuar.\n@param numbers - Një listë e numrave të plotë që do të kontrollohen për tekësi.\n@returns Numri i numrave tek në listën hyrëse.\n\n@example\n```\ncountOddNumbers(5, [1, 4, 3, 2, 5]) // returns 3\n```",
      "hy": "Գրեք TypeScript ֆունկցիա `function countOddNumbers(count: number, numbers: number[]): number` հետևյալ խնդիրը լուծելու համար:\nՀաշվում է տրված թվերի ցուցակում կենտ ամբողջ թվերի քանակը:\n\n@param count - Քննելու համար թվերի քանակը:\n@param numbers - Կենտ լինելը ստուգելու համար ամբողջ թվերի ցուցակ:\n@returns Մուտքային ցուցակում գտնվող կենտ թվերի քանակը:\n\n@example\n```\ncountOddNumbers(5, [1, 4, 3, 2, 5]) // returns 3\n```",
      "bn": "TypeScript ফাংশন `function countOddNumbers(count: number, numbers: number[]): number` লিখুন নিম্নলিখিত সমস্যার সমাধানের জন্য:\nপ্রদত্ত সংখ্যার তালিকায় বিজোড় পূর্ণসংখ্যার সংখ্যা গণনা করে।\n\n@param count - মূল্যায়ন করার জন্য সংখ্যার গণনা।\n@param numbers - বিজোড়তা যাচাই করার জন্য পূর্ণসংখ্যার একটি তালিকা।\n@returns ইনপুট তালিকায় বিজোড় সংখ্যার গণনা।\n\n@example\n```\ncountOddNumbers(5, [1, 4, 3, 2, 5]) // returns 3\n```",
      "bg": "Напишете TypeScript функция `function countOddNumbers(count: number, numbers: number[]): number`, за да решите следния проблем:\nБрои броя на нечетните цели числа в даден списък от числа.\n\n@param count - Броят на числата, които да се оценят.\n@param numbers - Списък от цели числа, които да бъдат проверени за нечетност.\n@returns Броят на нечетните числа в входния списък.\n\n@example\n```\ncountOddNumbers(5, [1, 4, 3, 2, 5]) // returns 3\n```",
      "zh": "编写一个 TypeScript 函数 `function countOddNumbers(count: number, numbers: number[]): number` 来解决以下问题：\n计算给定数字列表中奇数的数量。\n\n@param count - 要评估的数字数量。\n@param numbers - 要检查奇偶性的整数列表。\n@returns 输入列表中奇数的数量。\n\n@example\n```\ncountOddNumbers(5, [1, 4, 3, 2, 5]) // returns 3\n```",
      "fr": "Écrire une fonction TypeScript `function countOddNumbers(count: number, numbers: number[]): number` pour résoudre le problème suivant :\nCompte le nombre d'entiers impairs dans une liste donnée de nombres.\n\n@param count - Le nombre de nombres à évaluer.\n@param numbers - Une liste d'entiers à vérifier pour l'impairité.\n@returns Le nombre de nombres impairs dans la liste d'entrée.\n\n@example\n```\ncountOddNumbers(5, [1, 4, 3, 2, 5]) // returns 3\n```",
      "de": "Schreiben Sie eine TypeScript-Funktion `function countOddNumbers(count: number, numbers: number[]): number`, um das folgende Problem zu lösen:\nZählt die Anzahl der ungeraden Ganzzahlen in einer gegebenen Liste von Zahlen.\n\n@param count - Die Anzahl der zu bewertenden Zahlen.\n@param numbers - Eine Liste von Ganzzahlen, die auf Ungeradzahligkeit überprüft werden sollen.\n@returns Die Anzahl der ungeraden Zahlen in der Eingabeliste.\n\n@example\n```\ncountOddNumbers(5, [1, 4, 3, 2, 5]) // returns 3\n```",
      "ha": "Rubuta aikin TypeScript `function countOddNumbers(count: number, numbers: number[]): number` don warware matsalar mai zuwa:\nYana ƙididdige adadin lambobin tsaka-tsaki a cikin jerin lambobi da aka bayar.\n\n@param count - Adadin lambobin da za a tantance.\n@param numbers - Jerin lambobi don a duba tsaka-tsakarsu.\n@returns Adadin lambobin tsaka-tsaki a cikin jerin shigarwa.\n\n@example\n```\ncountOddNumbers(5, [1, 4, 3, 2, 5]) // returns 3\n```",
      "hi": "TypeScript फ़ंक्शन `function countOddNumbers(count: number, numbers: number[]): number` लिखें ताकि निम्नलिखित समस्या का समाधान किया जा सके:\nदिए गए संख्याओं की सूची में विषम पूर्णांकों की संख्या गिनता है।\n\n@param count - मूल्यांकन के लिए संख्याओं की गिनती।\n@param numbers - विषमता के लिए जाँची जाने वाली पूर्णांकों की सूची।\n@returns इनपुट सूची में विषम संख्याओं की गिनती।\n\n@example\n```\ncountOddNumbers(5, [1, 4, 3, 2, 5]) // returns 3\n```",
      "hu": "Írj egy TypeScript függvényt `function countOddNumbers(count: number, numbers: number[]): number` a következő probléma megoldására:\nMegszámolja a páratlan egész számok számát egy adott számok listájában.\n\n@param count - Az értékelendő számok száma.\n@param numbers - Egy egész számokból álló lista, amelyet páratlanság szempontjából kell ellenőrizni.\n@returns A bemeneti listában található páratlan számok száma.\n\n@example\n```\ncountOddNumbers(5, [1, 4, 3, 2, 5]) // returns 3\n```"
    },
    "instruction_bertscore": {
      "sq": "0.9865950314750985",
      "hy": "0.9798433861933417",
      "bn": "0.9683240158756043",
      "bg": "0.9893385142979524",
      "zh": "0.968908783717371",
      "fr": "0.9835148701563905",
      "de": "0.9893385142979524",
      "ha": "0.9713821292220175",
      "hi": "0.9621444260912279",
      "hu": "0.9842615217587006"
    },
    "level": "easy",
    "test": "const testCountOddNumbers = (): void => {\n    console.assert(countOddNumbers(5, [1, 4, 3, 2, 5]) === 3, \"Test 1 failed\");\n    console.assert(countOddNumbers(4, [2, 2, 0, 0]) === 0, \"Test 2 failed\");\n    console.assert(countOddNumbers(6, [7, 7, 8, 1, 9, 10]) === 4, \"Test 3 failed\");\n    // console.log(\"All tests passed!\");\n};\n\ntestCountOddNumbers();",
    "entry_point": "countOddNumbers",
    "signature": "function countOddNumbers(count: number, numbers: number[]): number",
    "docstring": {
      "en": "Counts the number of odd integers in a given list of numbers.\n\n@param count - The count of numbers to evaluate.\n@param numbers - A list of integers to be checked for oddness.\n@returns The count of odd numbers in the input list.\n\n@example\n```\ncountOddNumbers(5, [1, 4, 3, 2, 5]) // returns 3\n```",
      "sq": "Counts the number of odd integers in a given list of numbers.\n\n@param count - Numri i numrave për t'u vlerësuar.\n@param numbers - Një listë e numrave të plotë që do të kontrollohen për tekësi.\n@returns Numri i numrave tek në listën e dhënë.\n\n@example\n```\ncountOddNumbers(5, [1, 4, 3, 2, 5]) // returns 3\n```",
      "hy": "Հաշվում է տրված թվերի ցուցակում կենտ ամբողջ թվերի քանակը։\n\n@param count - Քննելու համար թվերի քանակը։\n@param numbers - Ցուցակ, որը պարունակում է ամբողջ թվեր, որոնք պետք է ստուգվեն կենտ լինելու համար։\n@returns Մուտքային ցուցակում գտնվող կենտ թվերի քանակը։\n\n@example\n```\ncountOddNumbers(5, [1, 4, 3, 2, 5]) // վերադարձնում է 3\n```",
      "bn": "Counts the number of odd integers in a given list of numbers.\n\n@param count - মূল্যায়ন করার জন্য সংখ্যার সংখ্যা।\n@param numbers - বিজোড়তা যাচাই করার জন্য পূর্ণসংখ্যার একটি তালিকা।\n@returns ইনপুট তালিকায় বিজোড় সংখ্যার সংখ্যা।\n\n@example\n```\ncountOddNumbers(5, [1, 4, 3, 2, 5]) // returns 3\n```",
      "bg": "Брои броя на нечетните цели числа в даден списък от числа.\n\n@param count - Броят на числата за оценка.\n@param numbers - Списък от цели числа, които да бъдат проверени за нечетност.\n@returns Броят на нечетните числа в входния списък.\n\n@example\n```\ncountOddNumbers(5, [1, 4, 3, 2, 5]) // връща 3\n```",
      "zh": "计算给定数字列表中奇数的数量。\n\n@param count - 要评估的数字数量。\n@param numbers - 要检查奇偶性的整数列表。\n@returns 输入列表中奇数的数量。\n\n@example\n```\ncountOddNumbers(5, [1, 4, 3, 2, 5]) // returns 3\n```",
      "fr": "Compte le nombre d'entiers impairs dans une liste donnée de nombres.\n\n@param count - Le nombre de nombres à évaluer.\n@param numbers - Une liste d'entiers à vérifier pour l'impairité.\n@returns Le nombre de nombres impairs dans la liste d'entrée.\n\n@example\n```\ncountOddNumbers(5, [1, 4, 3, 2, 5]) // returns 3\n```",
      "de": "Zählt die Anzahl der ungeraden ganzen Zahlen in einer gegebenen Liste von Zahlen.\n\n@param count - Die Anzahl der zu bewertenden Zahlen.\n@param numbers - Eine Liste von ganzen Zahlen, die auf Ungeradzahligkeit überprüft werden sollen.\n@returns Die Anzahl der ungeraden Zahlen in der Eingabeliste.\n\n@example\n```\ncountOddNumbers(5, [1, 4, 3, 2, 5]) // returns 3\n```",
      "ha": "Counts the number of odd integers in a given list of numbers.\n\n@param count - Yawan lambobin da za a tantance.\n@param numbers - Jerin lambobin da za a duba don ganin ko lambobi ne marasa daidaituwa.\n@returns Yawan lambobin marasa daidaituwa a cikin jerin shigarwa.\n\n@example\n```\ncountOddNumbers(5, [1, 4, 3, 2, 5]) // returns 3\n```",
      "hi": "Counts the number of odd integers in a given list of numbers.\n\n@param count - मूल्यांकन करने के लिए संख्याओं की गिनती।\n@param numbers - विषम होने के लिए जाँची जाने वाली पूर्णांकों की सूची।\n@returns इनपुट सूची में विषम संख्याओं की गिनती।\n\n@example\n```\ncountOddNumbers(5, [1, 4, 3, 2, 5]) // returns 3\n```",
      "hu": "Számolja meg a páratlan egész számok számát egy adott számok listájában.\n\n@param count - Az értékelendő számok száma.\n@param numbers - Egy lista egész számokkal, amelyeket páratlanság szempontjából kell ellenőrizni.\n@returns A bemeneti listában található páratlan számok száma.\n\n@example\n```\ncountOddNumbers(5, [1, 4, 3, 2, 5]) // returns 3\n```"
    },
    "docstring_bertscore": {
      "sq": "0.9761550186479048",
      "hy": "0.9770873896564826",
      "bn": "0.9844200288027665",
      "bg": "0.9901824947869696",
      "zh": "0.9552529450212225",
      "fr": "0.9844200288027665",
      "de": "0.9861796953483546",
      "ha": "0.968550057249222",
      "hi": "0.9759653266340165",
      "hu": "0.9726313156883458"
    }
  },
  {
    "task_id": "TypeScript/10",
    "prompt": {
      "en": "\n/**\n * Calculate the sum of even numbers in a given list.\n * \n * @param numbers An array of integers.\n * @param size The size of the array.\n * @returns The sum of even numbers in the input array.\n * \n * Examples:\n * \n * calculateEvenSum([1, 4, 3, 2, 5], 5); // Returns 6\n * calculateEvenSum([2, 2, 0, 0], 4); // Returns 4\n * calculateEvenSum([7, 11, 19], 3); // Returns 0 (no even numbers)\n */\nfunction calculateEvenSum(numbers: number[], size: number): number",
      "sq": "/**\n * Llogarit shumën e numrave çift në një listë të dhënë.\n * \n * @param numbers Një varg i numrave të plotë.\n * @param size Madhësia e vargut.\n * @returns Shuma e numrave çift në vargun hyrës.\n * \n * Shembuj:\n * \n * calculateEvenSum([1, 4, 3, 2, 5], 5); // Kthen 6\n * calculateEvenSum([2, 2, 0, 0], 4); // Kthen 4\n * calculateEvenSum([7, 11, 19], 3); // Kthen 0 (pa numra çift)\n */\nfunction calculateEvenSum(numbers: number[], size: number): number",
      "hy": "/**\n * Հաշվել տրված ցուցակի զույգ թվերի գումարը։\n * \n * @param numbers Թվերի զանգված։\n * @param size Զանգվածի չափը։\n * @returns Մուտքային զանգվածի զույգ թվերի գումարը։\n * \n * Օրինակներ:\n * \n * calculateEvenSum([1, 4, 3, 2, 5], 5); // Վերադարձնում է 6\n * calculateEvenSum([2, 2, 0, 0], 4); // Վերադարձնում է 4\n * calculateEvenSum([7, 11, 19], 3); // Վերադարձնում է 0 (չկան զույգ թվեր)\n */\nfunction calculateEvenSum(numbers: number[], size: number): number",
      "bn": "/**\n * প্রদত্ত তালিকায় জোড় সংখ্যাগুলোর যোগফল গণনা করুন।\n * \n * @param numbers পূর্ণসংখ্যার একটি অ্যারে।\n * @param size অ্যারের আকার।\n * @returns ইনপুট অ্যারেতে জোড় সংখ্যাগুলোর যোগফল।\n * \n * উদাহরণ:\n * \n * calculateEvenSum([1, 4, 3, 2, 5], 5); // 6 প্রদান করে\n * calculateEvenSum([2, 2, 0, 0], 4); // 4 প্রদান করে\n * calculateEvenSum([7, 11, 19], 3); // 0 প্রদান করে (কোনো জোড় সংখ্যা নেই)\n */\nfunction calculateEvenSum(numbers: number[], size: number): number",
      "bg": "/**\n * Изчислява сумата на четните числа в даден списък.\n * \n * @param numbers Масив от цели числа.\n * @param size Размерът на масива.\n * @returns Сумата на четните числа в входния масив.\n * \n * Примери:\n * \n * calculateEvenSum([1, 4, 3, 2, 5], 5); // Връща 6\n * calculateEvenSum([2, 2, 0, 0], 4); // Връща 4\n * calculateEvenSum([7, 11, 19], 3); // Връща 0 (няма четни числа)\n */\nfunction calculateEvenSum(numbers: number[], size: number): number",
      "zh": "/**\n * 计算给定列表中偶数的和。\n * \n * @param numbers 整数数组。\n * @param size 数组的大小。\n * @returns 输入数组中偶数的和。\n * \n * 示例:\n * \n * calculateEvenSum([1, 4, 3, 2, 5], 5); // 返回 6\n * calculateEvenSum([2, 2, 0, 0], 4); // 返回 4\n * calculateEvenSum([7, 11, 19], 3); // 返回 0 (没有偶数)\n */\nfunction calculateEvenSum(numbers: number[], size: number): number",
      "fr": "/**\n * Calculer la somme des nombres pairs dans une liste donnée.\n * \n * @param numbers Un tableau d'entiers.\n * @param size La taille du tableau.\n * @returns La somme des nombres pairs dans le tableau d'entrée.\n * \n * Exemples :\n * \n * calculateEvenSum([1, 4, 3, 2, 5], 5); // Retourne 6\n * calculateEvenSum([2, 2, 0, 0], 4); // Retourne 4\n * calculateEvenSum([7, 11, 19], 3); // Retourne 0 (aucun nombre pair)\n */\nfunction calculateEvenSum(numbers: number[], size: number): number",
      "de": "/**\n * Berechne die Summe der geraden Zahlen in einer gegebenen Liste.\n * \n * @param numbers Ein Array von ganzen Zahlen.\n * @param size Die Größe des Arrays.\n * @returns Die Summe der geraden Zahlen im Eingabearray.\n * \n * Beispiele:\n * \n * calculateEvenSum([1, 4, 3, 2, 5], 5); // Gibt 6 zurück\n * calculateEvenSum([2, 2, 0, 0], 4); // Gibt 4 zurück\n * calculateEvenSum([7, 11, 19], 3); // Gibt 0 zurück (keine geraden Zahlen)\n */\nfunction calculateEvenSum(numbers: number[], size: number): number",
      "ha": "/**\n * Lissafin adadin lambobin da suka kasance ma'aurata a cikin jerin da aka bayar.\n * \n * @param numbers Wani tsararren lambobi.\n * @param size Girman tsararren.\n * @returns Lissafin adadin lambobin ma'aurata a cikin tsararren shigarwa.\n * \n * Misalai:\n * \n * calculateEvenSum([1, 4, 3, 2, 5], 5); // Yana dawowa 6\n * calculateEvenSum([2, 2, 0, 0], 4); // Yana dawowa 4\n * calculateEvenSum([7, 11, 19], 3); // Yana dawowa 0 (babu lambobin ma'aurata)\n */\nfunction calculateEvenSum(numbers: number[], size: number): number",
      "hi": "/**\n * दिए गए सूची में सम संख्याओं का योग गणना करें।\n * \n * @param numbers पूर्णांकों की एक array।\n * @param size array का आकार।\n * @returns इनपुट array में सम संख्याओं का योग।\n * \n * उदाहरण:\n * \n * calculateEvenSum([1, 4, 3, 2, 5], 5); // 6 लौटाता है\n * calculateEvenSum([2, 2, 0, 0], 4); // 4 लौटाता है\n * calculateEvenSum([7, 11, 19], 3); // 0 लौटाता है (कोई सम संख्या नहीं)\n */\nfunction calculateEvenSum(numbers: number[], size: number): number",
      "hu": "/**\n * Számítsa ki a páros számok összegét egy adott listában.\n * \n * @param numbers Egész számok tömbje.\n * @param size A tömb mérete.\n * @returns A bemeneti tömb páros számainak összege.\n * \n * Példák:\n * \n * calculateEvenSum([1, 4, 3, 2, 5], 5); // Visszatér 6\n * calculateEvenSum([2, 2, 0, 0], 4); // Visszatér 4\n * calculateEvenSum([7, 11, 19], 3); // Visszatér 0 (nincs páros szám)\n */\nfunction calculateEvenSum(numbers: number[], size: number): number"
    },
    "prompt_bertscore": {
      "sq": "1",
      "hy": "0.9666193699455629",
      "bn": "0.9950403980159399",
      "bg": "0.9916442157610054",
      "zh": "0.9894247198833215",
      "fr": "1",
      "de": "0.9916174006595656",
      "ha": "0.9826200402898283",
      "hi": "0.9961485569117335",
      "hu": "0.9929659023164115"
    },
    "canonical_solution": "{\n    let sum = 0;\n    for (let i = 0; i < size; i++) {\n        if (numbers[i] % 2 === 0) { // Only sum the even numbers\n            sum += numbers[i];\n        }\n    }\n    return sum;\n}",
    "instruction": {
      "en": "Write a TypeScript function `function calculateEvenSum(numbers: number[], size: number): number` to solve the following problem:\nCalculate the sum of even numbers in a given list.\n\n@param numbers An array of integers.\n@param size The size of the array.\n@returns The sum of even numbers in the input array.\n\nExamples:\n\ncalculateEvenSum([1, 4, 3, 2, 5], 5); // Returns 6\ncalculateEvenSum([2, 2, 0, 0], 4); // Returns 4\ncalculateEvenSum([7, 11, 19], 3); // Returns 0 (no even numbers)",
      "sq": "Shkruani një funksion TypeScript `function calculateEvenSum(numbers: number[], size: number): number` për të zgjidhur problemin e mëposhtëm:\nLlogaritni shumën e numrave çift në një listë të dhënë.\n\n@param numbers Një varg me numra të plotë.\n@param size Madhësia e vargut.\n@returns Shuma e numrave çift në vargun e dhënë.\n\nShembuj:\n\ncalculateEvenSum([1, 4, 3, 2, 5], 5); // Kthen 6\ncalculateEvenSum([2, 2, 0, 0], 4); // Kthen 4\ncalculateEvenSum([7, 11, 19], 3); // Kthen 0 (nuk ka numra çift)",
      "hy": "Գրեք TypeScript ֆունկցիա `function calculateEvenSum(numbers: number[], size: number): number` հետևյալ խնդիրը լուծելու համար:\nՀաշվեք զույգ թվերի գումարը տրված ցուցակում:\n\n@param numbers Թվերի զանգված:\n@param size Զանգվածի չափը:\n@returns Մուտքային զանգվածում զույգ թվերի գումարը:\n\nՕրինակներ:\n\ncalculateEvenSum([1, 4, 3, 2, 5], 5); // Վերադարձնում է 6\ncalculateEvenSum([2, 2, 0, 0], 4); // Վերադարձնում է 4\ncalculateEvenSum([7, 11, 19], 3); // Վերադարձնում է 0 (զույգ թվեր չկան)",
      "bn": "TypeScript ফাংশন `function calculateEvenSum(numbers: number[], size: number): number` লিখুন নিম্নলিখিত সমস্যার সমাধানের জন্য:\nপ্রদত্ত তালিকায় জোড় সংখ্যার যোগফল গণনা করুন।\n\n@param numbers পূর্ণসংখ্যার একটি অ্যারে।\n@param size অ্যারের আকার।\n@returns ইনপুট অ্যারের জোড় সংখ্যার যোগফল।\n\nউদাহরণসমূহ:\n\ncalculateEvenSum([1, 4, 3, 2, 5], 5); // Returns 6\ncalculateEvenSum([2, 2, 0, 0], 4); // Returns 4\ncalculateEvenSum([7, 11, 19], 3); // Returns 0 (কোনো জোড় সংখ্যা নেই)",
      "bg": "Напишете TypeScript функция `function calculateEvenSum(numbers: number[], size: number): number`, за да решите следния проблем:\nИзчислете сумата на четните числа в даден списък.\n\n@param numbers Масив от цели числа.\n@param size Размерът на масива.\n@returns Сумата на четните числа в входния масив.\n\nПримери:\n\ncalculateEvenSum([1, 4, 3, 2, 5], 5); // Връща 6\ncalculateEvenSum([2, 2, 0, 0], 4); // Връща 4\ncalculateEvenSum([7, 11, 19], 3); // Връща 0 (няма четни числа)",
      "zh": "编写一个 TypeScript 函数 `function calculateEvenSum(numbers: number[], size: number): number` 来解决以下问题：\n计算给定列表中偶数的和。\n\n@param numbers 整数数组。\n@param size 数组的大小。\n@returns 输入数组中偶数的和。\n\n例子：\n\ncalculateEvenSum([1, 4, 3, 2, 5], 5); // 返回 6\ncalculateEvenSum([2, 2, 0, 0], 4); // 返回 4\ncalculateEvenSum([7, 11, 19], 3); // 返回 0 (没有偶数)",
      "fr": "Écrire une fonction TypeScript `function calculateEvenSum(numbers: number[], size: number): number` pour résoudre le problème suivant :\nCalculer la somme des nombres pairs dans une liste donnée.\n\n@param numbers Un tableau d'entiers.\n@param size La taille du tableau.\n@returns La somme des nombres pairs dans le tableau d'entrée.\n\nExemples :\n\ncalculateEvenSum([1, 4, 3, 2, 5], 5); // Retourne 6\ncalculateEvenSum([2, 2, 0, 0], 4); // Retourne 4\ncalculateEvenSum([7, 11, 19], 3); // Retourne 0 (aucun nombre pair)",
      "de": "Schreiben Sie eine TypeScript-Funktion `function calculateEvenSum(numbers: number[], size: number): number`, um das folgende Problem zu lösen:\nBerechnen Sie die Summe der geraden Zahlen in einer gegebenen Liste.\n\n@param numbers Ein Array von ganzen Zahlen.\n@param size Die Größe des Arrays.\n@returns Die Summe der geraden Zahlen im Eingabearray.\n\nBeispiele:\n\ncalculateEvenSum([1, 4, 3, 2, 5], 5); // Gibt 6 zurück\ncalculateEvenSum([2, 2, 0, 0], 4); // Gibt 4 zurück\ncalculateEvenSum([7, 11, 19], 3); // Gibt 0 zurück (keine geraden Zahlen)",
      "ha": "Rubuta aikin TypeScript `function calculateEvenSum(numbers: number[], size: number): number` don warware matsalar mai zuwa:\nƘididdige jimillar lambobi masu lamba biyu a cikin jerin da aka bayar.\n\n@param numbers Jeri na lambobin tsari.\n@param size Girman jerin.\n@returns Jimillar lambobi masu lamba biyu a cikin jerin shigarwa.\n\nMisalai:\n\ncalculateEvenSum([1, 4, 3, 2, 5], 5); // Ya dawo da 6\ncalculateEvenSum([2, 2, 0, 0], 4); // Ya dawo da 4\ncalculateEvenSum([7, 11, 19], 3); // Ya dawo da 0 (babu lambobi masu lamba biyu)",
      "hi": "TypeScript फ़ंक्शन `function calculateEvenSum(numbers: number[], size: number): number` लिखें ताकि निम्नलिखित समस्या का समाधान किया जा सके:\nदिए गए सूची में सम संख्याओं का योग गणना करें।\n\n@param numbers पूर्णांकों की एक array।\n@param size array का आकार।\n@returns इनपुट array में सम संख्याओं का योग।\n\nउदाहरण:\n\ncalculateEvenSum([1, 4, 3, 2, 5], 5); // 6 लौटाता है\ncalculateEvenSum([2, 2, 0, 0], 4); // 4 लौटाता है\ncalculateEvenSum([7, 11, 19], 3); // 0 लौटाता है (कोई सम संख्या नहीं)",
      "hu": "Írj egy TypeScript függvényt `function calculateEvenSum(numbers: number[], size: number): number` a következő probléma megoldására:\nSzámítsd ki a páros számok összegét egy adott listában.\n\n@param numbers Egész számok tömbje.\n@param size A tömb mérete.\n@returns A bemeneti tömb páros számainak összege.\n\nPéldák:\n\ncalculateEvenSum([1, 4, 3, 2, 5], 5); // Visszatérési érték: 6\ncalculateEvenSum([2, 2, 0, 0], 4); // Visszatérési érték: 4\ncalculateEvenSum([7, 11, 19], 3); // Visszatérési érték: 0 (nincs páros szám)"
    },
    "instruction_bertscore": {
      "sq": "0.9934501631853746",
      "hy": "0.9462442627197661",
      "bn": "0.9808889765191092",
      "bg": "0.9848069607850224",
      "zh": "0.9724900894874301",
      "fr": "1",
      "de": "0.9906661597647896",
      "ha": "0.9929730530101287",
      "hi": "0.979936543842047",
      "hu": "0.9707757106687179"
    },
    "level": "easy",
    "test": "(() => {\n    console.assert(calculateEvenSum([1, 4, 3, 2, 5], 5) === 6, \"Test 1 failed\");\n    console.assert(calculateEvenSum([2, 2, 0, 0], 4) === 4, \"Test 2 failed\");\n    console.assert(calculateEvenSum([7, 11, 19], 3) === 0, \"Test 3 failed - no even numbers\");\n    console.assert(calculateEvenSum([12, 14, 16, 18, 20], 5) === (12 + 14 + 16 + 18 + 20), \"Test 4 failed - all even numbers\");\n    // console.log(\"All tests passed successfully.\");\n})();",
    "entry_point": "calculateEvenSum",
    "signature": "function calculateEvenSum(numbers: number[], size: number): number",
    "docstring": {
      "en": "Calculate the sum of even numbers in a given list.\n\n@param numbers An array of integers.\n@param size The size of the array.\n@returns The sum of even numbers in the input array.\n\nExamples:\n\ncalculateEvenSum([1, 4, 3, 2, 5], 5); // Returns 6\ncalculateEvenSum([2, 2, 0, 0], 4); // Returns 4\ncalculateEvenSum([7, 11, 19], 3); // Returns 0 (no even numbers)",
      "sq": "Llogarit shumën e numrave çift në një listë të dhënë.\n\n@param numbers Një varg me numra të plotë.\n@param size Madhësia e vargut.\n@returns Shuma e numrave çift në vargun e dhënë.\n\nShembuj:\n\ncalculateEvenSum([1, 4, 3, 2, 5], 5); // Kthen 6\ncalculateEvenSum([2, 2, 0, 0], 4); // Kthen 4\ncalculateEvenSum([7, 11, 19], 3); // Kthen 0 (asnjë numër çift)",
      "hy": "Հաշվել զույգ թվերի գումարը տրված ցուցակում։\n\n@param numbers Թվերի զանգված։\n@param size Զանգվածի չափը։\n@returns Մուտքային զանգվածում զույգ թվերի գումարը։\n\nՕրինակներ:\n\ncalculateEvenSum([1, 4, 3, 2, 5], 5); // Վերադարձնում է 6\ncalculateEvenSum([2, 2, 0, 0], 4); // Վերադարձնում է 4\ncalculateEvenSum([7, 11, 19], 3); // Վերադարձնում է 0 (զույգ թվեր չկան)",
      "bn": "Calculate the sum of even numbers in a given list.\n\n@param numbers পূর্ণসংখ্যার একটি অ্যারে।\n@param size অ্যারের আকার।\n@returns ইনপুট অ্যারের জোড় সংখ্যাগুলির যোগফল।\n\nউদাহরণসমূহ:\n\ncalculateEvenSum([1, 4, 3, 2, 5], 5); // 6 ফেরত দেয়\ncalculateEvenSum([2, 2, 0, 0], 4); // 4 ফেরত দেয়\ncalculateEvenSum([7, 11, 19], 3); // 0 ফেরত দেয় (কোনও জোড় সংখ্যা নেই)",
      "bg": "Изчисляване на сумата от четни числа в даден списък.\n\n@param numbers Масив от цели числа.\n@param size Размерът на масива.\n@returns Сумата от четните числа в входния масив.\n\nПримери:\n\ncalculateEvenSum([1, 4, 3, 2, 5], 5); // Връща 6\ncalculateEvenSum([2, 2, 0, 0], 4); // Връща 4\ncalculateEvenSum([7, 11, 19], 3); // Връща 0 (няма четни числа)",
      "zh": "计算给定列表中偶数的和。\n\n@param numbers 一个整数数组。\n@param size 数组的大小。\n@returns 输入数组中偶数的和。\n\n示例：\n\ncalculateEvenSum([1, 4, 3, 2, 5], 5); // 返回 6\ncalculateEvenSum([2, 2, 0, 0], 4); // 返回 4\ncalculateEvenSum([7, 11, 19], 3); // 返回 0（没有偶数）",
      "fr": "Calculer la somme des nombres pairs dans une liste donnée.\n\n@param numbers Un tableau d'entiers.\n@param size La taille du tableau.\n@returns La somme des nombres pairs dans le tableau d'entrée.\n\nExemples :\n\ncalculateEvenSum([1, 4, 3, 2, 5], 5); // Renvoie 6\ncalculateEvenSum([2, 2, 0, 0], 4); // Renvoie 4\ncalculateEvenSum([7, 11, 19], 3); // Renvoie 0 (aucun nombre pair)",
      "de": "Berechnen Sie die Summe der geraden Zahlen in einer gegebenen Liste.\n\n@param numbers Ein Array von ganzen Zahlen.\n@param size Die Größe des Arrays.\n@returns Die Summe der geraden Zahlen im Eingabearray.\n\nBeispiele:\n\ncalculateEvenSum([1, 4, 3, 2, 5], 5); // Gibt 6 zurück\ncalculateEvenSum([2, 2, 0, 0], 4); // Gibt 4 zurück\ncalculateEvenSum([7, 11, 19], 3); // Gibt 0 zurück (keine geraden Zahlen)",
      "ha": "Calculate the sum of even numbers in a given list.\n\n@param numbers Wani tsararren lambobi.\n@param size Girman tsararren.\n@returns Jimillar lambobin da suka rabu da biyu a cikin tsararren da aka shigar.\n\nMisalai:\n\ncalculateEvenSum([1, 4, 3, 2, 5], 5); // Yana dawowa 6\ncalculateEvenSum([2, 2, 0, 0], 4); // Yana dawowa 4\ncalculateEvenSum([7, 11, 19], 3); // Yana dawowa 0 (babu lambobin da suka rabu da biyu)",
      "hi": "Calculate the sum of even numbers in a given list.\n\n@param numbers पूर्णांकों की एक array।\n@param size array का आकार।\n@returns इनपुट array में सम संख्याओं का योग।\n\nउदाहरण:\n\ncalculateEvenSum([1, 4, 3, 2, 5], 5); // 6 लौटाता है\ncalculateEvenSum([2, 2, 0, 0], 4); // 4 लौटाता है\ncalculateEvenSum([7, 11, 19], 3); // 0 लौटाता है (कोई सम संख्या नहीं)",
      "hu": "Számítsa ki a páros számok összegét egy adott listában.\n\n@param numbers Egész számok tömbje.\n@param size A tömb mérete.\n@returns A bemeneti tömb páros számainak összege.\n\nPéldák:\n\ncalculateEvenSum([1, 4, 3, 2, 5], 5); // Visszatér 6\ncalculateEvenSum([2, 2, 0, 0], 4); // Visszatér 4\ncalculateEvenSum([7, 11, 19], 3); // Visszatér 0 (nincs páros szám)"
    },
    "docstring_bertscore": {
      "sq": "0.9922758603726963",
      "hy": "0.9723977263602488",
      "bn": "0.9959954128879556",
      "bg": "0.9899693643881192",
      "zh": "0.9957689742535758",
      "fr": "0.9941735750331037",
      "de": "0.9897107476320117",
      "ha": "0.9442696781018983",
      "hi": "0.9769175606806977",
      "hu": "0.9922218329090549"
    }
  },
  {
    "task_id": "TypeScript/11",
    "prompt": {
      "en": "\n/**\n * Determine if two closed intervals intersect.\n * Args:\n *    a, b: Representing the first closed interval [a, b] where 0 <= a <= b <= 1000.\n *    c, d: Representing the second closed interval [c, d] where 0 <= c <= d <= 1000.\n * Returns:\n *    boolean: true if the intervals intersect, false otherwise.\n */\nfunction areIntervalsIntersecting(a: number, b: number, c: number, d: number): boolean",
      "sq": "/**\n * Përcaktoni nëse dy intervale të mbyllura ndërpriten.\n * Argumentet:\n *    a, b: Përfaqësojnë intervalin e parë të mbyllur [a, b] ku 0 <= a <= b <= 1000.\n *    c, d: Përfaqësojnë intervalin e dytë të mbyllur [c, d] ku 0 <= c <= d <= 1000.\n * Kthen:\n *    boolean: true nëse intervalet ndërpriten, false përndryshe.\n */\nfunction areIntervalsIntersecting(a: number, b: number, c: number, d: number): boolean",
      "hy": "/**\n * Պարզել՝ արդյոք երկու փակ միջակայքերը հատվում են:\n * Արձանագրություններ:\n *    a, b: Ներկայացնում են առաջին փակ միջակայքը [a, b], որտեղ 0 <= a <= b <= 1000:\n *    c, d: Ներկայացնում են երկրորդ փակ միջակայքը [c, d], որտեղ 0 <= c <= d <= 1000:\n * Վերադարձնում է:\n *    boolean: true, եթե միջակայքերը հատվում են, false՝ հակառակ դեպքում:\n */\nfunction areIntervalsIntersecting(a: number, b: number, c: number, d: number): boolean",
      "bn": "/**\n * দুটি বন্ধ ইন্টারভাল পরস্পরকে ছেদ করে কিনা তা নির্ধারণ করুন।\n * Args:\n *    a, b: প্রথম বন্ধ ইন্টারভাল [a, b] কে উপস্থাপন করছে যেখানে 0 <= a <= b <= 1000।\n *    c, d: দ্বিতীয় বন্ধ ইন্টারভাল [c, d] কে উপস্থাপন করছে যেখানে 0 <= c <= d <= 1000।\n * Returns:\n *    boolean: যদি ইন্টারভালগুলি পরস্পরকে ছেদ করে তবে true, অন্যথায় false।\n */\nfunction areIntervalsIntersecting(a: number, b: number, c: number, d: number): boolean",
      "bg": "/**\n * Определете дали два затворени интервала се пресичат.\n * Args:\n *    a, b: Представлява първия затворен интервал [a, b], където 0 <= a <= b <= 1000.\n *    c, d: Представлява втория затворен интервал [c, d], където 0 <= c <= d <= 1000.\n * Returns:\n *    boolean: true ако интервалите се пресичат, false в противен случай.\n */\nfunction areIntervalsIntersecting(a: number, b: number, c: number, d: number): boolean",
      "zh": "/**\n * 判断两个闭区间是否相交。\n * 参数:\n *    a, b: 表示第一个闭区间 [a, b]，其中 0 <= a <= b <= 1000。\n *    c, d: 表示第二个闭区间 [c, d]，其中 0 <= c <= d <= 1000。\n * 返回:\n *    boolean: 如果区间相交则返回 true，否则返回 false。\n */\nfunction areIntervalsIntersecting(a: number, b: number, c: number, d: number): boolean",
      "fr": "/**\n * Déterminer si deux intervalles fermés s'intersectent.\n * Args:\n *    a, b: Représentant le premier intervalle fermé [a, b] où 0 <= a <= b <= 1000.\n *    c, d: Représentant le second intervalle fermé [c, d] où 0 <= c <= d <= 1000.\n * Returns:\n *    boolean: true si les intervalles s'intersectent, false sinon.\n */\nfunction areIntervalsIntersecting(a: number, b: number, c: number, d: number): boolean",
      "de": "/**\n * Bestimmen, ob zwei geschlossene Intervalle sich überschneiden.\n * Args:\n *    a, b: Repräsentieren das erste geschlossene Intervall [a, b], wobei 0 <= a <= b <= 1000.\n *    c, d: Repräsentieren das zweite geschlossene Intervall [c, d], wobei 0 <= c <= d <= 1000.\n * Returns:\n *    boolean: true, wenn die Intervalle sich überschneiden, false andernfalls.\n */\nfunction areIntervalsIntersecting(a: number, b: number, c: number, d: number): boolean",
      "ha": "/**\n * Tantance ko wasu tazara biyu masu rufewa suna haduwa.\n * Args:\n *    a, b: Wakiltar tazara na farko mai rufewa [a, b] inda 0 <= a <= b <= 1000.\n *    c, d: Wakiltar tazara na biyu mai rufewa [c, d] inda 0 <= c <= d <= 1000.\n * Returns:\n *    boolean: gaskiya idan tazarorin suna haduwa, karya idan ba haka ba.\n */\nfunction areIntervalsIntersecting(a: number, b: number, c: number, d: number): boolean",
      "hi": "/**\n * यह निर्धारित करें कि क्या दो बंद अंतराल एक-दूसरे को काटते हैं।\n * तर्क:\n *    a, b: पहले बंद अंतराल [a, b] का प्रतिनिधित्व करते हैं जहाँ 0 <= a <= b <= 1000।\n *    c, d: दूसरे बंद अंतराल [c, d] का प्रतिनिधित्व करते हैं जहाँ 0 <= c <= d <= 1000।\n * वापसी:\n *    boolean: यदि अंतराल एक-दूसरे को काटते हैं तो true, अन्यथा false।\n */\nfunction areIntervalsIntersecting(a: number, b: number, c: number, d: number): boolean",
      "hu": "/**\n * Határozza meg, hogy két zárt intervallum metszi-e egymást.\n * Args:\n *    a, b: Az első zárt intervallumot [a, b] jelöli, ahol 0 <= a <= b <= 1000.\n *    c, d: A második zárt intervallumot [c, d] jelöli, ahol 0 <= c <= d <= 1000.\n * Returns:\n *    boolean: igaz, ha az intervallumok metszik egymást, különben hamis.\n */\nfunction areIntervalsIntersecting(a: number, b: number, c: number, d: number): boolean"
    },
    "prompt_bertscore": {
      "sq": "0.9789878851422243",
      "hy": "0.9673388091856713",
      "bn": "0.966745301607139",
      "bg": "0.9839828433341087",
      "zh": "0.9590712168358562",
      "fr": "1",
      "de": "0.9770397183650341",
      "ha": "0.9875492518255901",
      "hi": "0.966341287412114",
      "hu": "0.9763268339275"
    },
    "canonical_solution": "{\n    return (c <= a && b <= d) ||\n           (a <= c && c <= b && b <= d) ||\n           (a <= c && d <= b) ||\n           (c <= a && a <= d && d <= b);\n}",
    "instruction": {
      "en": "Write a TypeScript function `function areIntervalsIntersecting(a: number, b: number, c: number, d: number): boolean` to solve the following problem:\nDetermine if two closed intervals intersect.\nArgs:\n    a, b: Representing the first closed interval [a, b] where 0 <= a <= b <= 1000.\n    c, d: Representing the second closed interval [c, d] where 0 <= c <= d <= 1000.\nReturns:\n    boolean: true if the intervals intersect, false otherwise.",
      "sq": "Shkruani një funksion TypeScript `function areIntervalsIntersecting(a: number, b: number, c: number, d: number): boolean` për të zgjidhur problemin e mëposhtëm:\nPërcaktoni nëse dy intervale të mbyllura ndërpriten.\nArgumentet:\n    a, b: Përfaqësojnë intervalin e parë të mbyllur [a, b] ku 0 <= a <= b <= 1000.\n    c, d: Përfaqësojnë intervalin e dytë të mbyllur [c, d] ku 0 <= c <= d <= 1000.\nKthen:\n    boolean: true nëse intervalet ndërpriten, false përndryshe.",
      "hy": "Գրեք TypeScript ֆունկցիա `function areIntervalsIntersecting(a: number, b: number, c: number, d: number): boolean` հետևյալ խնդիրը լուծելու համար:\nՍահմանեք՝ արդյոք երկու փակ միջակայքերը հատվում են:\nԱրգումենտներ:\n    a, b: Ներկայացնում են առաջին փակ միջակայքը [a, b], որտեղ 0 <= a <= b <= 1000:\n    c, d: Ներկայացնում են երկրորդ փակ միջակայքը [c, d], որտեղ 0 <= c <= d <= 1000:\nՎերադարձնում է:\n    boolean: true, եթե միջակայքերը հատվում են, false՝ հակառակ դեպքում:",
      "bn": "TypeScript ফাংশন `function areIntervalsIntersecting(a: number, b: number, c: number, d: number): boolean` লিখুন নিম্নলিখিত সমস্যার সমাধানের জন্য:\nনির্ধারণ করুন দুটি বন্ধ ইন্টারভাল ছেদ করে কিনা।\nআর্গুমেন্টসমূহ:\n    a, b: প্রথম বন্ধ ইন্টারভাল [a, b] প্রতিনিধিত্ব করে যেখানে 0 <= a <= b <= 1000।\n    c, d: দ্বিতীয় বন্ধ ইন্টারভাল [c, d] প্রতিনিধিত্ব করে যেখানে 0 <= c <= d <= 1000।\nরিটার্ন:\n    boolean: true যদি ইন্টারভালগুলি ছেদ করে, অন্যথায় false।",
      "bg": "Напишете TypeScript функция `function areIntervalsIntersecting(a: number, b: number, c: number, d: number): boolean`, за да решите следния проблем:\nОпределете дали два затворени интервала се пресичат.\nАргументи:\n    a, b: Представляващи първия затворен интервал [a, b], където 0 <= a <= b <= 1000.\n    c, d: Представляващи втория затворен интервал [c, d], където 0 <= c <= d <= 1000.\nВръща:\n    boolean: true ако интервалите се пресичат, false в противен случай.",
      "zh": "编写一个 TypeScript 函数 `function areIntervalsIntersecting(a: number, b: number, c: number, d: number): boolean` 来解决以下问题：\n确定两个闭区间是否相交。\n参数：\n    a, b: 表示第一个闭区间 [a, b]，其中 0 <= a <= b <= 1000。\n    c, d: 表示第二个闭区间 [c, d]，其中 0 <= c <= d <= 1000。\n返回：\n    boolean: 如果区间相交则为 true，否则为 false。",
      "fr": "Écrire une fonction TypeScript `function areIntervalsIntersecting(a: number, b: number, c: number, d: number): boolean` pour résoudre le problème suivant :\nDéterminer si deux intervalles fermés s'intersectent.\nArgs:\n    a, b: Représentant le premier intervalle fermé [a, b] où 0 <= a <= b <= 1000.\n    c, d: Représentant le second intervalle fermé [c, d] où 0 <= c <= d <= 1000.\nReturns:\n    boolean: true si les intervalles s'intersectent, false sinon.",
      "de": "Schreiben Sie eine TypeScript-Funktion `function areIntervalsIntersecting(a: number, b: number, c: number, d: number): boolean`, um das folgende Problem zu lösen:\nBestimmen Sie, ob sich zwei geschlossene Intervalle überschneiden.\nArgs:\n    a, b: Repräsentieren das erste geschlossene Intervall [a, b], wobei 0 <= a <= b <= 1000.\n    c, d: Repräsentieren das zweite geschlossene Intervall [c, d], wobei 0 <= c <= d <= 1000.\nReturns:\n    boolean: true, wenn sich die Intervalle überschneiden, false andernfalls.",
      "ha": "Rubuta aikin TypeScript `function areIntervalsIntersecting(a: number, b: number, c: number, d: number): boolean` don warware matsalar mai zuwa:\nGano ko wasu tazara biyu masu rufewa suna haduwa.\nArgs:\n    a, b: Wakiltar tazara na farko mai rufewa [a, b] inda 0 <= a <= b <= 1000.\n    c, d: Wakiltar tazara na biyu mai rufewa [c, d] inda 0 <= c <= d <= 1000.\nReturns:\n    boolean: gaskiya idan tazarorin suna haduwa, karya idan ba haka ba.",
      "hi": "TypeScript फ़ंक्शन `function areIntervalsIntersecting(a: number, b: number, c: number, d: number): boolean` लिखें ताकि निम्नलिखित समस्या का समाधान किया जा सके:\nनिर्धारित करें कि क्या दो बंद अंतराल एक-दूसरे को काटते हैं।\nआर्ग्स:\n    a, b: पहले बंद अंतराल [a, b] का प्रतिनिधित्व करते हैं जहाँ 0 <= a <= b <= 1000।\n    c, d: दूसरे बंद अंतराल [c, d] का प्रतिनिधित्व करते हैं जहाँ 0 <= c <= d <= 1000।\nरिटर्न्स:\n    boolean: true यदि अंतराल एक-दूसरे को काटते हैं, अन्यथा false।",
      "hu": "Írjon egy TypeScript függvényt `function areIntervalsIntersecting(a: number, b: number, c: number, d: number): boolean` a következő probléma megoldására:\nHatározza meg, hogy két zárt intervallum metszi-e egymást.\nArgs:\n    a, b: Az első zárt intervallumot [a, b] képviselik, ahol 0 <= a <= b <= 1000.\n    c, d: A második zárt intervallumot [c, d] képviselik, ahol 0 <= c <= d <= 1000.\nVisszatérési érték:\n    boolean: true, ha az intervallumok metszik egymást, különben false."
    },
    "instruction_bertscore": {
      "sq": "0.982305211135888",
      "hy": "0.975330503936229",
      "bn": "0.9604495130498572",
      "bg": "0.9853007559122752",
      "zh": "0.9656001974604729",
      "fr": "0.999999801369619",
      "de": "0.9846399126345721",
      "ha": "0.9901697824425834",
      "hi": "0.9669892197150498",
      "hu": "0.9770828211577187"
    },
    "level": "easy",
    "test": "(() => {\n    console.assert(areIntervalsIntersecting(1, 1, 1, 2) === true);\n    console.assert(areIntervalsIntersecting(3, 5, 2, 6) === true);\n    console.assert(areIntervalsIntersecting(3, 5, 4, 7) === true);\n    console.assert(areIntervalsIntersecting(3, 5, 6, 7) === false);\n    // Additional test cases\n    console.assert(areIntervalsIntersecting(0, 0, 0, 0) === true);\n    console.assert(areIntervalsIntersecting(1, 3, 2, 4) === true);\n    console.assert(areIntervalsIntersecting(1, 3, 4, 6) === false);\n    console.assert(areIntervalsIntersecting(10, 20, 20, 30) === true);\n    console.assert(areIntervalsIntersecting(10, 20, 21, 30) === false);\n})();",
    "entry_point": "areIntervalsIntersecting",
    "signature": "function areIntervalsIntersecting(a: number, b: number, c: number, d: number): boolean",
    "docstring": {
      "en": "Determine if two closed intervals intersect.\nArgs:\n    a, b: Representing the first closed interval [a, b] where 0 <= a <= b <= 1000.\n    c, d: Representing the second closed interval [c, d] where 0 <= c <= d <= 1000.\nReturns:\n    boolean: true if the intervals intersect, false otherwise.",
      "sq": "Përcaktoni nëse dy intervale të mbyllura ndërpriten.\nArgs:\n    a, b: Duke përfaqësuar intervalin e parë të mbyllur [a, b] ku 0 <= a <= b <= 1000.\n    c, d: Duke përfaqësuar intervalin e dytë të mbyllur [c, d] ku 0 <= c <= d <= 1000.\nReturns:\n    boolean: true nëse intervalet ndërpriten, false përndryshe.",
      "hy": "Սահմանել, արդյոք երկու փակ միջակայքերը հատվում են:\nԱրգումենտներ:\n    a, b: Ներկայացնում է առաջին փակ միջակայքը [a, b], որտեղ 0 <= a <= b <= 1000:\n    c, d: Ներկայացնում է երկրորդ փակ միջակայքը [c, d], որտեղ 0 <= c <= d <= 1000:\nՎերադարձնում է:\n    boolean: true, եթե միջակայքերը հատվում են, false՝ հակառակ դեպքում:",
      "bn": "Determine if two closed intervals intersect.\nArgs:\n    a, b: প্রথম বন্ধ ইন্টারভাল [a, b] উপস্থাপন করছে যেখানে 0 <= a <= b <= 1000।\n    c, d: দ্বিতীয় বন্ধ ইন্টারভাল [c, d] উপস্থাপন করছে যেখানে 0 <= c <= d <= 1000।\nReturns:\n    boolean: যদি ইন্টারভালগুলি ছেদ করে তবে true, অন্যথায় false।",
      "bg": "Определете дали два затворени интервала се пресичат.\nАргументи:\n    a, b: Представляващи първия затворен интервал [a, b], където 0 <= a <= b <= 1000.\n    c, d: Представляващи втория затворен интервал [c, d], където 0 <= c <= d <= 1000.\nВръща:\n    boolean: true ако интервалите се пресичат, false в противен случай.",
      "zh": "确定两个闭区间是否相交。\n参数:\n    a, b: 表示第一个闭区间 [a, b]，其中 0 <= a <= b <= 1000。\n    c, d: 表示第二个闭区间 [c, d]，其中 0 <= c <= d <= 1000。\n返回:\n    boolean: 如果区间相交则为 true，否则为 false。",
      "fr": "Déterminer si deux intervalles fermés s'intersectent.\nArgs:\n    a, b: Représentant le premier intervalle fermé [a, b] où 0 <= a <= b <= 1000.\n    c, d: Représentant le second intervalle fermé [c, d] où 0 <= c <= d <= 1000.\nReturns:\n    boolean: vrai si les intervalles s'intersectent, faux sinon.",
      "de": "Bestimmen Sie, ob zwei geschlossene Intervalle sich überschneiden.\nArgs:\n    a, b: Repräsentiert das erste geschlossene Intervall [a, b], wobei 0 <= a <= b <= 1000.\n    c, d: Repräsentiert das zweite geschlossene Intervall [c, d], wobei 0 <= c <= d <= 1000.\nReturns:\n    boolean: true, wenn sich die Intervalle überschneiden, false andernfalls.",
      "ha": "Determine if two closed intervals intersect.  \nArgs:  \n    a, b: Wakiltar zangon rufe na farko [a, b] inda 0 <= a <= b <= 1000.  \n    c, d: Wakiltar zangon rufe na biyu [c, d] inda 0 <= c <= d <= 1000.  \nReturns:  \n    boolean: gaskiya idan zangon suna haduwa, ƙarya idan ba haka ba.  ",
      "hi": "Determine if two closed intervals intersect.  \nतय करें कि दो बंद अंतराल एक-दूसरे को काटते हैं या नहीं।\n\nArgs:  \n    a, b: पहले बंद अंतराल [a, b] का प्रतिनिधित्व करते हैं जहाँ 0 <= a <= b <= 1000।  \n    c, d: दूसरे बंद अंतराल [c, d] का प्रतिनिधित्व करते हैं जहाँ 0 <= c <= d <= 1000।  \n\nReturns:  \n    boolean: यदि अंतराल एक-दूसरे को काटते हैं तो true, अन्यथा false।",
      "hu": "Határozza meg, hogy két zárt intervallum metszi-e egymást.\nArgs:\n    a, b: Az első zárt intervallumot [a, b] képviseli, ahol 0 <= a <= b <= 1000.\n    c, d: A második zárt intervallumot [c, d] képviseli, ahol 0 <= c <= d <= 1000.\nReturns:\n    boolean: igaz, ha az intervallumok metszik egymást, különben hamis."
    },
    "docstring_bertscore": {
      "sq": "1",
      "hy": "0.9599670398543234",
      "bn": "0.9765610191467401",
      "bg": "0.9758324429091041",
      "zh": "0.954213909498029",
      "fr": "1",
      "de": "0.9684344543674597",
      "ha": "0.9873669091358",
      "hi": "0.9568686045405602",
      "hu": "0.9680238853698606"
    }
  },
  {
    "task_id": "TypeScript/12",
    "prompt": {
      "en": "\n/**\n * You are given three digits a, b, c. Two of them are equal, but the third one\n * is different from the other two. Find the value that occurs exactly once.\n * \n * Examples:\n * ```\n * extraNumber(0, 0, 1) // returns 1\n * ```\n */\nfunction extraNumber(a: number, b: number, c: number): number",
      "sq": "/**\n * Ju jepen tre shifra a, b, c. Dy prej tyre janë të barabarta, por e treta\n * është e ndryshme nga dy të tjerat. Gjeni vlerën që ndodh saktësisht një herë.\n * \n * Shembuj:\n * ```\n * extraNumber(0, 0, 1) // kthen 1\n * ```\n */\nfunction extraNumber(a: number, b: number, c: number): number",
      "hy": "/**\n * Ձեզ տրված են երեք թվանշան a, b, c։ Նրանցից երկուսը հավասար են, բայց երրորդը\n * տարբերվում է մյուս երկուսից։ Գտեք այն արժեքը, որը հանդիպում է միայն մեկ անգամ։\n * \n * Օրինակներ:\n * ```\n * extraNumber(0, 0, 1) // վերադարձնում է 1\n * ```\n */\nfunction extraNumber(a: number, b: number, c: number): number",
      "bn": "/**\n * আপনাকে তিনটি সংখ্যা দেওয়া হয়েছে a, b, c। এর মধ্যে দুটি সমান, কিন্তু তৃতীয়টি\n * অন্য দুটি থেকে ভিন্ন। সেই মানটি খুঁজে বের করুন যা ঠিক একবার ঘটে।\n * \n * উদাহরণ:\n * ```\n * extraNumber(0, 0, 1) // returns 1\n * ```\n */\nfunction extraNumber(a: number, b: number, c: number): number",
      "bg": "/**\n * Дадени са ви три цифри a, b, c. Две от тях са равни, но третата\n * е различна от другите две. Намерете стойността, която се среща точно веднъж.\n * \n * Примери:\n * ```\n * extraNumber(0, 0, 1) // returns 1\n * ```\n */\nfunction extraNumber(a: number, b: number, c: number): number",
      "zh": "/**\n * 给定三个数字 a, b, c。其中两个是相等的，但第三个与其他两个不同。\n * 找出只出现一次的值。\n * \n * 例子:\n * ```\n * extraNumber(0, 0, 1) // returns 1\n * ```\n */\nfunction extraNumber(a: number, b: number, c: number): number",
      "fr": "/**\n * On vous donne trois chiffres a, b, c. Deux d'entre eux sont égaux, mais le troisième\n * est différent des deux autres. Trouvez la valeur qui apparaît exactement une fois.\n * \n * Exemples :\n * ```\n * extraNumber(0, 0, 1) // returns 1\n * ```\n */\nfunction extraNumber(a: number, b: number, c: number): number",
      "de": "/**\n * Sie haben drei Ziffern a, b, c. Zwei von ihnen sind gleich, aber die dritte\n * unterscheidet sich von den anderen beiden. Finden Sie den Wert, der genau einmal vorkommt.\n * \n * Beispiele:\n * ```\n * extraNumber(0, 0, 1) // gibt 1 zurück\n * ```\n */\nfunction extraNumber(a: number, b: number, c: number): number",
      "ha": "/**\n * An ba ka lambobi guda uku a, b, c. Biyu daga cikinsu suna daidai, amma na uku\n * ya bambanta daga sauran biyun. Nemo darajar da ta bayyana sau daya kawai.\n * \n * Misalai:\n * ```\n * extraNumber(0, 0, 1) // returns 1\n * ```\n */\nfunction extraNumber(a: number, b: number, c: number): number",
      "hi": "/**\n * आपके पास तीन अंक a, b, c दिए गए हैं। इनमें से दो समान हैं, लेकिन तीसरा\n * अन्य दो से भिन्न है। उस मान को खोजें जो केवल एक बार आता है।\n * \n * उदाहरण:\n * ```\n * extraNumber(0, 0, 1) // returns 1\n * ```\n */\nfunction extraNumber(a: number, b: number, c: number): number",
      "hu": "/**\n * Három számjegyet kap, a, b, c. Kettő közülük egyenlő, de a harmadik\n * különbözik a másik kettőtől. Találja meg azt az értéket, amely pontosan egyszer fordul elő.\n * \n * Példák:\n * ```\n * extraNumber(0, 0, 1) // visszaadja 1\n * ```\n */\nfunction extraNumber(a: number, b: number, c: number): number"
    },
    "prompt_bertscore": {
      "sq": "0.9874902586024228",
      "hy": "0.9867283124607729",
      "bn": "0.9897202818903015",
      "bg": "0.9933955398305899",
      "zh": "0.9592706417384151",
      "fr": "0.9840706379625261",
      "de": "0.97547272328905",
      "ha": "0.9693590787911771",
      "hi": "0.9672412816685831",
      "hu": "0.9770599786638997"
    },
    "canonical_solution": "{\n    if (a === b) {\n        return c;\n    } else if (a === c) {\n        return b;\n    } else {\n        return a;\n    }\n}",
    "instruction": {
      "en": "Write a TypeScript function `function extraNumber(a: number, b: number, c: number): number` to solve the following problem:\nYou are given three digits a, b, c. Two of them are equal, but the third one\nis different from the other two. Find the value that occurs exactly once.\n\nExamples:\nextraNumber(0, 0, 1) // returns 1\n",
      "sq": "Shkruani një funksion TypeScript `function extraNumber(a: number, b: number, c: number): number` për të zgjidhur problemin e mëposhtëm:\nJu jepen tre shifra a, b, c. Dy prej tyre janë të barabarta, por e treta është e ndryshme nga dy të tjerat. Gjeni vlerën që ndodh saktësisht një herë.\n\nShembuj:\nextraNumber(0, 0, 1) // kthen 1",
      "hy": "Տիպի TypeScript ֆունկցիա `function extraNumber(a: number, b: number, c: number): number` լուծելու համար հետևյալ խնդիրը:\nՁեզ տրված են երեք թվանշան a, b, c։ Դրանցից երկուսը հավասար են, բայց երրորդը տարբերվում է մյուս երկուսից։ Գտեք այն արժեքը, որը հանդիպում է միայն մեկ անգամ։\n\nՕրինակներ:\nextraNumber(0, 0, 1) // վերադարձնում է 1",
      "bn": "TypeScript ফাংশন `function extraNumber(a: number, b: number, c: number): number` লিখুন নিম্নলিখিত সমস্যার সমাধানের জন্য:\nআপনাকে তিনটি সংখ্যা দেওয়া হয়েছে a, b, c। এদের মধ্যে দুটি সমান, কিন্তু তৃতীয়টি অন্য দুটি থেকে আলাদা। যে মানটি ঠিক একবার ঘটে তা খুঁজে বের করুন।\n\nউদাহরণ:\nextraNumber(0, 0, 1) // 1 রিটার্ন করে",
      "bg": "Напишете функция на TypeScript `function extraNumber(a: number, b: number, c: number): number`, за да решите следния проблем:\nДадени са ви три цифри a, b, c. Две от тях са равни, но третата е различна от другите две. Намерете стойността, която се среща точно веднъж.\n\nПримери:\nextraNumber(0, 0, 1) // връща 1",
      "zh": "编写一个 TypeScript 函数 `function extraNumber(a: number, b: number, c: number): number` 来解决以下问题：\n给定三个数字 a, b, c。其中两个是相等的，但第三个与其他两个不同。找出只出现一次的值。\n\n示例：\nextraNumber(0, 0, 1) // 返回 1",
      "fr": "Écrire une fonction TypeScript `function extraNumber(a: number, b: number, c: number): number` pour résoudre le problème suivant :  \nOn vous donne trois chiffres a, b, c. Deux d'entre eux sont égaux, mais le troisième est différent des deux autres. Trouvez la valeur qui apparaît exactement une fois.\n\nExemples :  \nextraNumber(0, 0, 1) // retourne 1",
      "de": "Schreiben Sie eine TypeScript-Funktion `function extraNumber(a: number, b: number, c: number): number`, um das folgende Problem zu lösen:\nSie haben drei Ziffern a, b, c. Zwei von ihnen sind gleich, aber die dritte ist anders als die anderen beiden. Finden Sie den Wert, der genau einmal vorkommt.\n\nBeispiele:\nextraNumber(0, 0, 1) // gibt 1 zurück",
      "ha": "Rubuta aikin TypeScript `function extraNumber(a: number, b: number, c: number): number` don warware matsalar mai zuwa:  \nAn ba ku lambobi uku a, b, c. Biyu daga cikinsu suna daidai, amma na uku  \nya bambanta da sauran biyun. Nemo ƙimar da ta bayyana sau ɗaya kawai.\n\nMisalai:  \nextraNumber(0, 0, 1) // returns 1",
      "hi": "TypeScript फ़ंक्शन `function extraNumber(a: number, b: number, c: number): number` लिखें ताकि निम्नलिखित समस्या का समाधान हो सके:\nआपको तीन अंक a, b, c दिए गए हैं। इनमें से दो समान हैं, लेकिन तीसरा अन्य दो से भिन्न है। उस मान को खोजें जो केवल एक बार आता है।\n\nउदाहरण:\nextraNumber(0, 0, 1) // 1 लौटाता है",
      "hu": "Írj egy TypeScript függvényt `function extraNumber(a: number, b: number, c: number): number` a következő probléma megoldására:\nHárom számjegyet kapsz: a, b, c. Kettő közülük egyenlő, de a harmadik különbözik a másik kettőtől. Találd meg azt az értéket, amely pontosan egyszer fordul elő.\n\nPéldák:\nextraNumber(0, 0, 1) // visszaadja 1"
    },
    "instruction_bertscore": {
      "sq": "0.9921411889743547",
      "hy": "0.9679517825415449",
      "bn": "0.9665609726135387",
      "bg": "0.9848971389780122",
      "zh": "0.9682040431254593",
      "fr": "0.9851309269364903",
      "de": "0.984354679407406",
      "ha": "0.9717299310192096",
      "hi": "0.9486361697681882",
      "hu": "0.9870522786122408"
    },
    "level": "easy",
    "test": "(() => {\n    console.assert(extraNumber(2, 7, 2) === 7, \"Test 1 failed\");\n    console.assert(extraNumber(3, 2, 2) === 3, \"Test 2 failed\");\n    console.assert(extraNumber(5, 5, 1) === 1, \"Test 3 failed\");\n    console.assert(extraNumber(500000000, 3, 500000000) === 3, \"Test 4 failed\");\n    console.assert(extraNumber(500000000, 500000000, 3) === 3, \"Test 5 failed\");\n\n    // console.log(\"All tests passed!\");\n})();",
    "entry_point": "extraNumber",
    "signature": "function extraNumber(a: number, b: number, c: number): number",
    "docstring": {
      "en": "You are given three digits a, b, c. Two of them are equal, but the third one\nis different from the other two. Find the value that occurs exactly once.\n\nExamples:\nextraNumber(0, 0, 1) // returns 1\n",
      "sq": "Ju jepen tre shifra a, b, c. Dy prej tyre janë të barabarta, por e treta\nështë e ndryshme nga dy të tjerat. Gjeni vlerën që shfaqet saktësisht një herë.\n\nShembuj:\nextraNumber(0, 0, 1) // kthen 1",
      "hy": "Ձեզ տրված են երեք թվանշաններ a, b, c։ Նրանցից երկուսը հավասար են, բայց երրորդը տարբերվում է մյուս երկուսից։ Գտեք այն արժեքը, որը հանդիպում է միայն մեկ անգամ։\n\nՕրինակներ:\nextraNumber(0, 0, 1) // վերադարձնում է 1",
      "bn": "তোমাকে তিনটি সংখ্যা দেওয়া হয়েছে a, b, c। এদের মধ্যে দুটি সংখ্যা সমান, কিন্তু তৃতীয়টি অন্য দুটি থেকে ভিন্ন। যে মানটি ঠিক একবার ঘটে তা খুঁজে বের করো।\n\nউদাহরণসমূহ:\nextraNumber(0, 0, 1) // 1 ফেরত দেয়",
      "bg": "Дадени са ви три цифри a, b, c. Две от тях са равни, но третата е различна от другите две. Намерете стойността, която се среща точно веднъж.\n\nПримери:\nextraNumber(0, 0, 1) // връща 1",
      "zh": "你有三个数字 a, b, c。其中两个是相等的，但第三个与其他两个不同。找出只出现一次的值。\n\n示例:\nextraNumber(0, 0, 1) // 返回 1",
      "fr": "Vous avez trois chiffres a, b, c. Deux d'entre eux sont égaux, mais le troisième est différent des deux autres. Trouvez la valeur qui apparaît exactement une fois.\n\nExemples :\nextraNumber(0, 0, 1) // retourne 1",
      "de": "Du hast drei Ziffern a, b, c. Zwei von ihnen sind gleich, aber die dritte ist anders als die anderen beiden. Finde den Wert, der genau einmal vorkommt.\n\nBeispiele:\nextraNumber(0, 0, 1) // gibt 1 zurück",
      "ha": "An ba ku lambobi uku a, b, c. Biyu daga cikinsu suna daidai, amma na uku\nya bambanta daga sauran biyun. Nemo ƙimar da ta bayyana sau ɗaya kawai.\n\nMisalai:\nextraNumber(0, 0, 1) // yana dawowa 1",
      "hi": "आपको तीन अंक दिए गए हैं a, b, c। इनमें से दो समान हैं, लेकिन तीसरा अन्य दो से भिन्न है। उस मान को खोजें जो केवल एक बार आता है।\n\nउदाहरण:\nextraNumber(0, 0, 1) // 1 लौटाता है",
      "hu": "Három számjegy van megadva: a, b, c. Kettő közülük egyenlő, de a harmadik különbözik a másik kettőtől. Találd meg azt az értéket, amely pontosan egyszer fordul elő.\n\nPéldák:\nextraNumber(0, 0, 1) // visszaadja 1"
    },
    "docstring_bertscore": {
      "sq": "0.9812254563845824",
      "hy": "0.9714927663442539",
      "bn": "0.9635425853433325",
      "bg": "0.9951029665859659",
      "zh": "0.9570022827869967",
      "fr": "0.964405237088167",
      "de": "0.972199691870357",
      "ha": "0.955586246800599",
      "hi": "0.9494934584927348",
      "hu": "0.9685854134570462"
    }
  },
  {
    "task_id": "TypeScript/13",
    "prompt": {
      "en": "\n/**\n * Calculate the total score for a student based on the scores in different subjects.\n * @param score1 - The score for the first subject.\n * @param score2 - The score for the second subject.\n * @param score3 - The score for the third subject.\n * @param score4 - The score for the fourth subject.\n * @param score5 - The score for the fifth subject.\n * @returns The total score obtained by summing up the scores in all subjects.\n * @example\n * calculateTotalScore(100, 100, 100, 100, 100); // returns 500\n */\nfunction calculateTotalScore(score1: number, score2: number, score3: number, score4: number, score5: number): number",
      "sq": "/**\n * Llogarit totalin e pikëve për një student bazuar në pikët në lëndë të ndryshme.\n * @param score1 - Pikët për lëndën e parë.\n * @param score2 - Pikët për lëndën e dytë.\n * @param score3 - Pikët për lëndën e tretë.\n * @param score4 - Pikët për lëndën e katërt.\n * @param score5 - Pikët për lëndën e pestë.\n * @returns Totali i pikëve të marra duke mbledhur pikët në të gjitha lëndët.\n * @example\n * calculateTotalScore(100, 100, 100, 100, 100); // returns 500\n */\nfunction calculateTotalScore(score1: number, score2: number, score3: number, score4: number, score5: number): number",
      "hy": "/**\n * Հաշվել ուսանողի ընդհանուր միավորները տարբեր առարկաների միավորների հիման վրա։\n * @param score1 - Առաջին առարկայի միավորը։\n * @param score2 - Երկրորդ առարկայի միավորը։\n * @param score3 - Երրորդ առարկայի միավորը։\n * @param score4 - Չորրորդ առարկայի միավորը։\n * @param score5 - Հինգերորդ առարկայի միավորը։\n * @returns Ընդհանուր միավորները, ստացված բոլոր առարկաների միավորների գումարով։\n * @example\n * calculateTotalScore(100, 100, 100, 100, 100); // վերադարձնում է 500\n */\nfunction calculateTotalScore(score1: number, score2: number, score3: number, score4: number, score5: number): number",
      "bn": "/**\n * বিভিন্ন বিষয়ের স্কোরের উপর ভিত্তি করে একজন শিক্ষার্থীর মোট স্কোর গণনা করুন।\n * @param score1 - প্রথম বিষয়ের স্কোর।\n * @param score2 - দ্বিতীয় বিষয়ের স্কোর।\n * @param score3 - তৃতীয় বিষয়ের স্কোর।\n * @param score4 - চতুর্থ বিষয়ের স্কোর।\n * @param score5 - পঞ্চম বিষয়ের স্কোর।\n * @returns সমস্ত বিষয়ের স্কোর যোগ করে প্রাপ্ত মোট স্কোর।\n * @example\n * calculateTotalScore(100, 100, 100, 100, 100); // returns 500\n */\nfunction calculateTotalScore(score1: number, score2: number, score3: number, score4: number, score5: number): number",
      "bg": "/**\n * Изчислява общия резултат за студент въз основа на резултатите по различни предмети.\n * @param score1 - Резултатът за първия предмет.\n * @param score2 - Резултатът за втория предмет.\n * @param score3 - Резултатът за третия предмет.\n * @param score4 - Резултатът за четвъртия предмет.\n * @param score5 - Резултатът за петия предмет.\n * @returns Общият резултат, получен чрез сумиране на резултатите по всички предмети.\n * @example\n * calculateTotalScore(100, 100, 100, 100, 100); // returns 500\n */\nfunction calculateTotalScore(score1: number, score2: number, score3: number, score4: number, score5: number): number",
      "zh": "/**\n * 计算学生在不同科目中的总分。\n * @param score1 - 第一科目的分数。\n * @param score2 - 第二科目的分数。\n * @param score3 - 第三科目的分数。\n * @param score4 - 第四科目的分数。\n * @param score5 - 第五科目的分数。\n * @returns 通过将所有科目的分数相加获得的总分。\n * @example\n * calculateTotalScore(100, 100, 100, 100, 100); // returns 500\n */\nfunction calculateTotalScore(score1: number, score2: number, score3: number, score4: number, score5: number): number",
      "fr": "/**\n * Calculer le score total pour un étudiant basé sur les scores dans différentes matières.\n * @param score1 - Le score pour la première matière.\n * @param score2 - Le score pour la deuxième matière.\n * @param score3 - Le score pour la troisième matière.\n * @param score4 - Le score pour la quatrième matière.\n * @param score5 - Le score pour la cinquième matière.\n * @returns Le score total obtenu en additionnant les scores dans toutes les matières.\n * @example\n * calculateTotalScore(100, 100, 100, 100, 100); // returns 500\n */\nfunction calculateTotalScore(score1: number, score2: number, score3: number, score4: number, score5: number): number",
      "de": "/**\n * Berechnet die Gesamtpunktzahl für einen Schüler basierend auf den Punktzahlen in verschiedenen Fächern.\n * @param score1 - Die Punktzahl für das erste Fach.\n * @param score2 - Die Punktzahl für das zweite Fach.\n * @param score3 - Die Punktzahl für das dritte Fach.\n * @param score4 - Die Punktzahl für das vierte Fach.\n * @param score5 - Die Punktzahl für das fünfte Fach.\n * @returns Die Gesamtpunktzahl, die durch das Addieren der Punktzahlen in allen Fächern erreicht wird.\n * @example\n * calculateTotalScore(100, 100, 100, 100, 100); // returns 500\n */\nfunction calculateTotalScore(score1: number, score2: number, score3: number, score4: number, score5: number): number",
      "ha": "/**\n * Lissafa jimillar maki ga ɗalibi bisa ga maki a fannoni daban-daban.\n * @param score1 - Maki na farko don fanni na farko.\n * @param score2 - Maki na biyu don fanni na biyu.\n * @param score3 - Maki na uku don fanni na uku.\n * @param score4 - Maki na huɗu don fanni na huɗu.\n * @param score5 - Maki na biyar don fanni na biyar.\n * @returns Jimillar maki da aka samu ta hanyar tara maki a duk fannoni.\n * @example\n * calculateTotalScore(100, 100, 100, 100, 100); // returns 500\n */\nfunction calculateTotalScore(score1: number, score2: number, score3: number, score4: number, score5: number): number",
      "hi": "/**\n * विभिन्न विषयों में अंकों के आधार पर एक छात्र के लिए कुल स्कोर की गणना करें।\n * @param score1 - पहले विषय के लिए अंक।\n * @param score2 - दूसरे विषय के लिए अंक।\n * @param score3 - तीसरे विषय के लिए अंक।\n * @param score4 - चौथे विषय के लिए अंक।\n * @param score5 - पांचवें विषय के लिए अंक।\n * @returns सभी विषयों में अंकों को जोड़कर प्राप्त कुल स्कोर।\n * @example\n * calculateTotalScore(100, 100, 100, 100, 100); // 500 लौटाता है\n */\nfunction calculateTotalScore(score1: number, score2: number, score3: number, score4: number, score5: number): number",
      "hu": "/**\n * Számítsa ki a diák összpontszámát a különböző tantárgyakban elért pontszámok alapján.\n * @param score1 - Az első tantárgy pontszáma.\n * @param score2 - A második tantárgy pontszáma.\n * @param score3 - A harmadik tantárgy pontszáma.\n * @param score4 - A negyedik tantárgy pontszáma.\n * @param score5 - Az ötödik tantárgy pontszáma.\n * @returns Az összpontszám, amelyet az összes tantárgy pontszámának összeadásával kapunk.\n * @example\n * calculateTotalScore(100, 100, 100, 100, 100); // returns 500\n */\nfunction calculateTotalScore(score1: number, score2: number, score3: number, score4: number, score5: number): number"
    },
    "prompt_bertscore": {
      "sq": "0.9730259942554622",
      "hy": "0.9629850298637675",
      "bn": "0.960994753445798",
      "bg": "0.9904655430799443",
      "zh": "0.9603784033734467",
      "fr": "0.9915236471197172",
      "de": "0.9892755484671644",
      "ha": "0.9770643485322825",
      "hi": "0.9474662368238927",
      "hu": "0.9827213417841562"
    },
    "canonical_solution": "{\n    return score1 + score2 + score3 + score4 + score5;\n}",
    "instruction": {
      "en": "Write a TypeScript function `function calculateTotalScore(score1: number, score2: number, score3: number, score4: number, score5: number): number` to solve the following problem:\nCalculate the total score for a student based on the scores in different subjects.\n@param score1 - The score for the first subject.\n@param score2 - The score for the second subject.\n@param score3 - The score for the third subject.\n@param score4 - The score for the fourth subject.\n@param score5 - The score for the fifth subject.\n@returns The total score obtained by summing up the scores in all subjects.\n@example\ncalculateTotalScore(100, 100, 100, 100, 100); // returns 500",
      "sq": "Shkruani një funksion TypeScript `function calculateTotalScore(score1: number, score2: number, score3: number, score4: number, score5: number): number` për të zgjidhur problemin në vijim:  \nLlogaritni totalin e pikëve për një student bazuar në pikët në lëndë të ndryshme.  \n@param score1 - Pikët për lëndën e parë.  \n@param score2 - Pikët për lëndën e dytë.  \n@param score3 - Pikët për lëndën e tretë.  \n@param score4 - Pikët për lëndën e katërt.  \n@param score5 - Pikët për lëndën e pestë.  \n@returns Totali i pikëve të marra duke mbledhur pikët në të gjitha lëndët.  \n@example  \ncalculateTotalScore(100, 100, 100, 100, 100); // returns 500",
      "hy": "TypeScript ֆունկցիա գրեք `function calculateTotalScore(score1: number, score2: number, score3: number, score4: number, score5: number): number` հետևյալ խնդիրը լուծելու համար:\nՀաշվեք ուսանողի ընդհանուր միավորը տարբեր առարկաներում ստացված միավորների հիման վրա։\n@param score1 - Առաջին առարկայի միավորը։\n@param score2 - Երկրորդ առարկայի միավորը։\n@param score3 - Երրորդ առարկայի միավորը։\n@param score4 - Չորրորդ առարկայի միավորը։\n@param score5 - Հինգերորդ առարկայի միավորը։\n@returns Ընդհանուր միավորը, որը ստացվում է բոլոր առարկաների միավորների գումարով։\n@example\ncalculateTotalScore(100, 100, 100, 100, 100); // returns 500",
      "bn": "TypeScript ফাংশন `function calculateTotalScore(score1: number, score2: number, score3: number, score4: number, score5: number): number` লিখুন নিম্নলিখিত সমস্যার সমাধানের জন্য:\nবিভিন্ন বিষয়ের স্কোরের উপর ভিত্তি করে একজন শিক্ষার্থীর মোট স্কোর গণনা করুন।\n@param score1 - প্রথম বিষয়ের জন্য স্কোর।\n@param score2 - দ্বিতীয় বিষয়ের জন্য স্কোর।\n@param score3 - তৃতীয় বিষয়ের জন্য স্কোর।\n@param score4 - চতুর্থ বিষয়ের জন্য স্কোর।\n@param score5 - পঞ্চম বিষয়ের জন্য স্কোর।\n@returns সমস্ত বিষয়ের স্কোর যোগ করে প্রাপ্ত মোট স্কোর।\n@example\ncalculateTotalScore(100, 100, 100, 100, 100); // returns 500",
      "bg": "Напишете функция на TypeScript `function calculateTotalScore(score1: number, score2: number, score3: number, score4: number, score5: number): number`, за да решите следния проблем:\nИзчислете общия резултат за студент въз основа на резултатите в различни предмети.\n@param score1 - Резултатът за първия предмет.\n@param score2 - Резултатът за втория предмет.\n@param score3 - Резултатът за третия предмет.\n@param score4 - Резултатът за четвъртия предмет.\n@param score5 - Резултатът за петия предмет.\n@returns Общият резултат, получен чрез сумиране на резултатите във всички предмети.\n@example\ncalculateTotalScore(100, 100, 100, 100, 100); // returns 500",
      "zh": "编写一个 TypeScript 函数 `function calculateTotalScore(score1: number, score2: number, score3: number, score4: number, score5: number): number` 来解决以下问题：\n计算学生在不同科目中的总分。\n@param score1 - 第一科目的分数。\n@param score2 - 第二科目的分数。\n@param score3 - 第三科目的分数。\n@param score4 - 第四科目的分数。\n@param score5 - 第五科目的分数。\n@returns 通过将所有科目的分数相加获得的总分。\n@example\ncalculateTotalScore(100, 100, 100, 100, 100); // returns 500",
      "fr": "Écrire une fonction TypeScript `function calculateTotalScore(score1: number, score2: number, score3: number, score4: number, score5: number): number` pour résoudre le problème suivant :\nCalculer le score total pour un étudiant basé sur les scores dans différentes matières.\n@param score1 - Le score pour la première matière.\n@param score2 - Le score pour la deuxième matière.\n@param score3 - Le score pour la troisième matière.\n@param score4 - Le score pour la quatrième matière.\n@param score5 - Le score pour la cinquième matière.\n@returns Le score total obtenu en additionnant les scores dans toutes les matières.\n@example\ncalculateTotalScore(100, 100, 100, 100, 100); // returns 500",
      "de": "Schreiben Sie eine TypeScript-Funktion `function calculateTotalScore(score1: number, score2: number, score3: number, score4: number, score5: number): number`, um das folgende Problem zu lösen:\nBerechnen Sie die Gesamtpunktzahl für einen Schüler basierend auf den Punktzahlen in verschiedenen Fächern.\n@param score1 - Die Punktzahl für das erste Fach.\n@param score2 - Die Punktzahl für das zweite Fach.\n@param score3 - Die Punktzahl für das dritte Fach.\n@param score4 - Die Punktzahl für das vierte Fach.\n@param score5 - Die Punktzahl für das fünfte Fach.\n@returns Die Gesamtpunktzahl, die durch das Addieren der Punktzahlen in allen Fächern erhalten wird.\n@example\ncalculateTotalScore(100, 100, 100, 100, 100); // returns 500",
      "ha": "Rubuta aikin TypeScript `function calculateTotalScore(score1: number, score2: number, score3: number, score4: number, score5: number): number` don warware matsalar mai zuwa:\nƘididdige jimillar maki ga ɗalibi bisa ga maki a fannoni daban-daban.\n@param score1 - Maki na fannin farko.\n@param score2 - Maki na fannin na biyu.\n@param score3 - Maki na fannin na uku.\n@param score4 - Maki na fannin na huɗu.\n@param score5 - Maki na fannin na biyar.\n@returns Jimillar maki da aka samu ta hanyar tara maki a dukkan fannoni.\n@example\ncalculateTotalScore(100, 100, 100, 100, 100); // returns 500",
      "hi": "TypeScript फ़ंक्शन `function calculateTotalScore(score1: number, score2: number, score3: number, score4: number, score5: number): number` लिखें ताकि निम्नलिखित समस्या का समाधान किया जा सके:\nविभिन्न विषयों में प्राप्त अंकों के आधार पर एक छात्र के कुल अंक की गणना करें।\n@param score1 - पहले विषय के लिए अंक।\n@param score2 - दूसरे विषय के लिए अंक।\n@param score3 - तीसरे विषय के लिए अंक।\n@param score4 - चौथे विषय के लिए अंक।\n@param score5 - पाँचवें विषय के लिए अंक।\n@returns कुल अंक जो सभी विषयों में प्राप्त अंकों को जोड़कर प्राप्त होते हैं।\n@example\ncalculateTotalScore(100, 100, 100, 100, 100); // returns 500",
      "hu": "Írj egy TypeScript függvényt `function calculateTotalScore(score1: number, score2: number, score3: number, score4: number, score5: number): number` a következő probléma megoldására:\nSzámítsd ki a diák összpontszámát a különböző tantárgyakban elért pontszámok alapján.\n@param score1 - Az első tantárgy pontszáma.\n@param score2 - A második tantárgy pontszáma.\n@param score3 - A harmadik tantárgy pontszáma.\n@param score4 - A negyedik tantárgy pontszáma.\n@param score5 - Az ötödik tantárgy pontszáma.\n@returns Az összpontszám, amelyet az összes tantárgy pontszámainak összeadásával kapunk.\n@example\ncalculateTotalScore(100, 100, 100, 100, 100); // returns 500"
    },
    "instruction_bertscore": {
      "sq": "0.9932741766677776",
      "hy": "0.960909342381953",
      "bn": "0.9552642669529414",
      "bg": "0.9939511090063445",
      "zh": "0.9612873359970624",
      "fr": "0.9932741766677776",
      "de": "0.9932741766677776",
      "ha": "0.9771676363304206",
      "hi": "0.9355668865872357",
      "hu": "0.9816548952683798"
    },
    "level": "easy",
    "test": "const testCalculateTotalScore = (): void => {\n    console.assert(calculateTotalScore(100, 100, 100, 100, 100) === 500);\n    console.assert(calculateTotalScore(0, 0, 0, 0, 0) === 0);\n    console.assert(calculateTotalScore(20, 30, 40, 10, 50) === 150);\n    console.assert(calculateTotalScore(23, 45, 67, 89, 12) === 236);\n    console.assert(calculateTotalScore(5, 5, 5, 5, 5) === 25);\n};\n\ntestCalculateTotalScore();",
    "entry_point": "calculateTotalScore",
    "signature": "function calculateTotalScore(score1: number, score2: number, score3: number, score4: number, score5: number): number",
    "docstring": {
      "en": "Calculate the total score for a student based on the scores in different subjects.\n@param score1 - The score for the first subject.\n@param score2 - The score for the second subject.\n@param score3 - The score for the third subject.\n@param score4 - The score for the fourth subject.\n@param score5 - The score for the fifth subject.\n@returns The total score obtained by summing up the scores in all subjects.\n@example\ncalculateTotalScore(100, 100, 100, 100, 100); // returns 500",
      "sq": "Calculate totalin e pikëve për një student bazuar në pikët në lëndë të ndryshme.\n@param score1 - Pikët për lëndën e parë.\n@param score2 - Pikët për lëndën e dytë.\n@param score3 - Pikët për lëndën e tretë.\n@param score4 - Pikët për lëndën e katërt.\n@param score5 - Pikët për lëndën e pestë.\n@returns Totali i pikëve i marrë duke mbledhur pikët në të gjitha lëndët.\n@example\ncalculateTotalScore(100, 100, 100, 100, 100); // returns 500",
      "hy": "Հաշվել ուսանողի ընդհանուր միավորը տարբեր առարկաներում ստացված միավորների հիման վրա։\n@param score1 - Առաջին առարկայի միավորը։\n@param score2 - Երկրորդ առարկայի միավորը։\n@param score3 - Երրորդ առարկայի միավորը։\n@param score4 - Չորրորդ առարկայի միավորը։\n@param score5 - Հինգերորդ առարկայի միավորը։\n@returns Ընդհանուր միավորը, որը ստացվում է բոլոր առարկաների միավորների գումարման արդյունքում։\n@example\ncalculateTotalScore(100, 100, 100, 100, 100); // returns 500",
      "bn": "Calculate the total score for a student based on the scores in different subjects.\n@param score1 - প্রথম বিষয়ের জন্য প্রাপ্ত স্কোর।\n@param score2 - দ্বিতীয় বিষয়ের জন্য প্রাপ্ত স্কোর।\n@param score3 - তৃতীয় বিষয়ের জন্য প্রাপ্ত স্কোর।\n@param score4 - চতুর্থ বিষয়ের জন্য প্রাপ্ত স্কোর।\n@param score5 - পঞ্চম বিষয়ের জন্য প্রাপ্ত স্কোর।\n@returns সকল বিষয়ের স্কোর যোগ করে প্রাপ্ত মোট স্কোর।\n@example\ncalculateTotalScore(100, 100, 100, 100, 100); // returns 500",
      "bg": "Изчислява общия резултат за ученик въз основа на резултатите по различни предмети.\n@param score1 - Резултатът за първия предмет.\n@param score2 - Резултатът за втория предмет.\n@param score3 - Резултатът за третия предмет.\n@param score4 - Резултатът за четвъртия предмет.\n@param score5 - Резултатът за петия предмет.\n@returns Общият резултат, получен чрез сумиране на резултатите по всички предмети.\n@example\ncalculateTotalScore(100, 100, 100, 100, 100); // returns 500",
      "zh": "计算学生在不同科目中的总分。\n\n@param score1 - 第一个科目的分数。\n@param score2 - 第二个科目的分数。\n@param score3 - 第三个科目的分数。\n@param score4 - 第四个科目的分数。\n@param score5 - 第五个科目的分数。\n\n@returns 通过将所有科目的分数相加得到的总分。\n\n@example\ncalculateTotalScore(100, 100, 100, 100, 100); // returns 500",
      "fr": "Calculer le score total pour un étudiant basé sur les scores dans différentes matières.\n@param score1 - Le score pour la première matière.\n@param score2 - Le score pour la deuxième matière.\n@param score3 - Le score pour la troisième matière.\n@param score4 - Le score pour la quatrième matière.\n@param score5 - Le score pour la cinquième matière.\n@returns Le score total obtenu en additionnant les scores de toutes les matières.\n@example\ncalculateTotalScore(100, 100, 100, 100, 100); // returns 500",
      "de": "Berechnen Sie die Gesamtpunktzahl für einen Schüler basierend auf den Punktzahlen in verschiedenen Fächern.\n@param score1 - Die Punktzahl für das erste Fach.\n@param score2 - Die Punktzahl für das zweite Fach.\n@param score3 - Die Punktzahl für das dritte Fach.\n@param score4 - Die Punktzahl für das vierte Fach.\n@param score5 - Die Punktzahl für das fünfte Fach.\n@returns Die Gesamtpunktzahl, die durch das Aufsummieren der Punktzahlen in allen Fächern erreicht wird.\n@example\ncalculateTotalScore(100, 100, 100, 100, 100); // gibt 500 zurück",
      "ha": "Calculate the total score for a student based on the scores in different subjects.  \n@param score1 - Makasudin darasi na farko.  \n@param score2 - Makasudin darasi na biyu.  \n@param score3 - Makasudin darasi na uku.  \n@param score4 - Makasudin darasi na hudu.  \n@param score5 - Makasudin darasi na biyar.  \n@returns Jimlar maki da aka samu ta hanyar tara maki a dukkan darussa.  \n@example  \ncalculateTotalScore(100, 100, 100, 100, 100); // returns 500  ",
      "hi": "Calculate the total score for a student based on the scores in different subjects.\n@param score1 - पहले विषय के लिए स्कोर।\n@param score2 - दूसरे विषय के लिए स्कोर।\n@param score3 - तीसरे विषय के लिए स्कोर।\n@param score4 - चौथे विषय के लिए स्कोर।\n@param score5 - पांचवें विषय के लिए स्कोर।\n@returns सभी विषयों में स्कोर को जोड़कर प्राप्त कुल स्कोर।\n@example\ncalculateTotalScore(100, 100, 100, 100, 100); // 500 लौटाता है",
      "hu": "Számítsa ki a diák összpontszámát a különböző tantárgyakban elért pontszámok alapján.\n@param score1 - Az első tantárgy pontszáma.\n@param score2 - A második tantárgy pontszáma.\n@param score3 - A harmadik tantárgy pontszáma.\n@param score4 - A negyedik tantárgy pontszáma.\n@param score5 - Az ötödik tantárgy pontszáma.\n@returns Az összpontszám, amelyet az összes tantárgy pontszámainak összeadásával kapunk.\n@example\ncalculateTotalScore(100, 100, 100, 100, 100); // returns 500"
    },
    "docstring_bertscore": {
      "sq": "0.9902661181773853",
      "hy": "0.9721897603513053",
      "bn": "0.9573530640399043",
      "bg": "0.9914573045724515",
      "zh": "0.9455728920318682",
      "fr": "0.9825636292616144",
      "de": "0.998280456791381",
      "ha": "0.9693821199153771",
      "hi": "0.957488132699008",
      "hu": "0.9769574853872858"
    }
  },
  {
    "task_id": "TypeScript/14",
    "prompt": {
      "en": "\n/**\n * Decode a series of numbers to reveal the pattern and understand the actual values\n * each digit represents.\n * 0000=4 8888=8 1234=1 5678=3 9012=2 1357=0 2468=4\n *\n * Parameters:\n * - dataStr: A string representing a series of numbers. Length does not exceed 100.\n *\n * Returns:\n * number: The result of each data string corresponding to the right-hand side of the equation.\n *\n * Example usage:\n * console.assert(decodeNumbers(\"0000\") === 4);\n */\nfunction decodeNumbers(dataStr: string): number",
      "sq": "/**\n * Dekodoni një seri numrash për të zbuluar modelin dhe për të kuptuar vlerat aktuale\n * që përfaqëson secila shifër.\n * 0000=4 8888=8 1234=1 5678=3 9012=2 1357=0 2468=4\n *\n * Parametrat:\n * - dataStr: Një varg që përfaqëson një seri numrash. Gjatësia nuk e kalon 100.\n *\n * Kthen:\n * numri: Rezultati i secilit varg të dhënash që korrespondon me anën e djathtë të ekuacionit.\n *\n * Shembull përdorimi:\n * console.assert(decodeNumbers(\"0000\") === 4);\n */\nfunction decodeNumbers(dataStr: string): number",
      "hy": "/**\n * Վերծանել թվերի շարք՝ բացահայտելու համար օրինաչափությունը և հասկանալու իրական արժեքները,\n * որոնք ներկայացնում է յուրաքանչյուր թիվ։\n * 0000=4 8888=8 1234=1 5678=3 9012=2 1357=0 2468=4\n *\n * Պարամետրեր:\n * - dataStr: Թվերի շարքը ներկայացնող տող։ Երկարությունը չի գերազանցում 100-ը։\n *\n * Վերադարձնում է:\n * number: Յուրաքանչյուր տվյալ տողի արդյունքը, որը համապատասխանում է հավասարման աջ կողմին։\n *\n * Օրինակ օգտագործում:\n * console.assert(decodeNumbers(\"0000\") === 4);\n */\nfunction decodeNumbers(dataStr: string): number",
      "bn": "/**\n * সংখ্যার একটি সিরিজ ডিকোড করে প্যাটার্নটি প্রকাশ করুন এবং প্রতিটি অঙ্ক প্রকৃতপক্ষে কোন মান উপস্থাপন করে তা বুঝুন।\n * 0000=4 8888=8 1234=1 5678=3 9012=2 1357=0 2468=4\n *\n * প্যারামিটার:\n * - dataStr: একটি স্ট্রিং যা সংখ্যার একটি সিরিজ উপস্থাপন করে। দৈর্ঘ্য 100 অতিক্রম করে না।\n *\n * রিটার্নস:\n * number: প্রতিটি ডেটা স্ট্রিং এর সমীকরণের ডান পাশে যা আছে তার সাথে মিলে যাওয়া ফলাফল।\n *\n * উদাহরণ ব্যবহার:\n * console.assert(decodeNumbers(\"0000\") === 4);\n */\nfunction decodeNumbers(dataStr: string): number",
      "bg": "/**\n * Декодирайте серия от числа, за да разкриете модела и да разберете действителните стойности,\n * които всяка цифра представлява.\n * 0000=4 8888=8 1234=1 5678=3 9012=2 1357=0 2468=4\n *\n * Параметри:\n * - dataStr: Низ, представляващ серия от числа. Дължината не надвишава 100.\n *\n * Връща:\n * number: Резултатът от всеки низ от данни, съответстващ на дясната страна на уравнението.\n *\n * Пример за използване:\n * console.assert(decodeNumbers(\"0000\") === 4);\n */\nfunction decodeNumbers(dataStr: string): number",
      "zh": "/**\n * 解码一系列数字以揭示模式并理解每个数字实际代表的值。\n * 0000=4 8888=8 1234=1 5678=3 9012=2 1357=0 2468=4\n *\n * 参数：\n * - dataStr: 一个表示一系列数字的字符串。长度不超过100。\n *\n * 返回：\n * number: 每个数据字符串对应方程右侧的结果。\n *\n * 示例用法：\n * console.assert(decodeNumbers(\"0000\") === 4);\n */\nfunction decodeNumbers(dataStr: string): number",
      "fr": "/**\n * Décoder une série de nombres pour révéler le motif et comprendre les valeurs réelles\n * que chaque chiffre représente.\n * 0000=4 8888=8 1234=1 5678=3 9012=2 1357=0 2468=4\n *\n * Paramètres:\n * - dataStr: Une chaîne représentant une série de nombres. La longueur ne dépasse pas 100.\n *\n * Renvoie:\n * number: Le résultat de chaque chaîne de données correspondant au côté droit de l'équation.\n *\n * Exemple d'utilisation:\n * console.assert(decodeNumbers(\"0000\") === 4);\n */\nfunction decodeNumbers(dataStr: string): number",
      "de": "/**\n * Dekodiere eine Reihe von Zahlen, um das Muster zu erkennen und die tatsächlichen Werte zu verstehen,\n * die jede Ziffer darstellt.\n * 0000=4 8888=8 1234=1 5678=3 9012=2 1357=0 2468=4\n *\n * Parameter:\n * - dataStr: Ein String, der eine Reihe von Zahlen darstellt. Die Länge überschreitet nicht 100.\n *\n * Rückgabewert:\n * number: Das Ergebnis jeder Datenzeichenfolge, das der rechten Seite der Gleichung entspricht.\n *\n * Beispielverwendung:\n * console.assert(decodeNumbers(\"0000\") === 4);\n */\nfunction decodeNumbers(dataStr: string): number",
      "ha": "/**\n * Fassar da jerin lambobi don bayyana tsarin kuma fahimtar ainihin ƙimar\n * kowace lamba ke wakilta.\n * 0000=4 8888=8 1234=1 5678=3 9012=2 1357=0 2468=4\n *\n * Sigogi:\n * - dataStr: Wani igiyar rubutu da ke wakiltar jerin lambobi. Tsawon ba ya wuce 100.\n *\n * Komawa:\n * number: Sakamakon kowane igiyar bayanai da ya dace da gefen dama na lissafin.\n *\n * Misalin amfani:\n * console.assert(decodeNumbers(\"0000\") === 4);\n */\nfunction decodeNumbers(dataStr: string): number",
      "hi": "/**\n * संख्याओं की एक श्रृंखला को डिकोड करें ताकि पैटर्न का पता चल सके और समझ सकें कि प्रत्येक अंक का वास्तविक मूल्य क्या है।\n * 0000=4 8888=8 1234=1 5678=3 9012=2 1357=0 2468=4\n *\n * पैरामीटर्स:\n * - dataStr: एक स्ट्रिंग जो संख्याओं की एक श्रृंखला का प्रतिनिधित्व करती है। लंबाई 100 से अधिक नहीं होती।\n *\n * रिटर्न करता है:\n * number: प्रत्येक डेटा स्ट्रिंग का परिणाम जो समीकरण के दाईं ओर के अनुरूप होता है।\n *\n * उदाहरण उपयोग:\n * console.assert(decodeNumbers(\"0000\") === 4);\n */\nfunction decodeNumbers(dataStr: string): number",
      "hu": "/**\n * Dekódolja a számok sorozatát, hogy felfedje a mintát és megértse, hogy az egyes számjegyek milyen tényleges értékeket képviselnek.\n * 0000=4 8888=8 1234=1 5678=3 9012=2 1357=0 2468=4\n *\n * Paraméterek:\n * - dataStr: Egy karakterlánc, amely számok sorozatát képviseli. Hossza nem haladja meg a 100-at.\n *\n * Visszatér:\n * number: Az egyes adatkarakterláncok eredménye, amely megfelel az egyenlet jobb oldalának.\n *\n * Példa használat:\n * console.assert(decodeNumbers(\"0000\") === 4);\n */\nfunction decodeNumbers(dataStr: string): number"
    },
    "prompt_bertscore": {
      "sq": "0.9827751706174166",
      "hy": "0.9664692053775005",
      "bn": "0.9665927534745042",
      "bg": "0.9909545710780522",
      "zh": "0.9690688798044852",
      "fr": "0.9891067126432846",
      "de": "0.9781220553112933",
      "ha": "0.9599432042085992",
      "hi": "0.9785606311926183",
      "hu": "0.9788772480199879"
    },
    "canonical_solution": "{\n    const a: number[] = [1, 0, 0, 0, 1, 0, 1, 0, 2, 1];\n    let ans: number = 0;\n    \n    for (let i = 0; i < dataStr.length; i++) {\n        ans += a[parseInt(dataStr[i])];\n    }\n    \n    return ans;\n}",
    "instruction": {
      "en": "Write a TypeScript function `function decodeNumbers(dataStr: string): number` to solve the following problem:\nDecode a series of numbers to reveal the pattern and understand the actual values\n each digit represents.\n 0000=4 8888=8 1234=1 5678=3 9012=2 1357=0 2468=4\n\n Parameters:\n - dataStr: A string representing a series of numbers. Length does not exceed 100.\n\n Returns:\n number: The result of each data string corresponding to the right-hand side of the equation.\n\n Example usage:\n console.assert(decodeNumbers(\"0000\") === 4);",
      "sq": "Shkruani një funksion TypeScript `function decodeNumbers(dataStr: string): number` për të zgjidhur problemin e mëposhtëm:\nDekodoni një seri numrash për të zbuluar modelin dhe për të kuptuar vlerat aktuale që përfaqëson secila shifër.\n 0000=4 8888=8 1234=1 5678=3 9012=2 1357=0 2468=4\n\n Parametrat:\n - dataStr: Një varg që përfaqëson një seri numrash. Gjatësia nuk i kalon 100.\n\n Kthen:\n numër: Rezultati i secilës varg të dhënash që korrespondon me anën e djathtë të ekuacionit.\n\n Shembull përdorimi:\n console.assert(decodeNumbers(\"0000\") === 4);",
      "hy": "Գրեք TypeScript ֆունկցիա `function decodeNumbers(dataStr: string): number`՝ լուծելու հետևյալ խնդիրը:\nՎերծանեք թվերի շարք՝ բացահայտելու համար օրինաչափությունը և հասկանալու համար, թե ինչ արժեքներ են իրականում ներկայացնում յուրաքանչյուր թվանշան:\n 0000=4 8888=8 1234=1 5678=3 9012=2 1357=0 2468=4\n\n Պարամետրեր:\n - dataStr: Տող, որը ներկայացնում է թվերի շարք։ Երկարությունը չի գերազանցում 100-ը։\n\n Վերադարձնում է:\n number: Յուրաքանչյուր տվյալ տողի արդյունքը, որը համապատասխանում է հավասարման աջ կողմին։\n\n Օրինակ օգտագործում:\n console.assert(decodeNumbers(\"0000\") === 4);",
      "bn": "TypeScript ফাংশন `function decodeNumbers(dataStr: string): number` লিখুন নিম্নলিখিত সমস্যার সমাধানের জন্য:\nসংখ্যার একটি সিরিজ ডিকোড করুন প্যাটার্নটি প্রকাশ করতে এবং প্রতিটি অঙ্ক প্রকৃতপক্ষে কোন মানগুলি উপস্থাপন করে তা বুঝতে।\n 0000=4 8888=8 1234=1 5678=3 9012=2 1357=0 2468=4\n\n প্যারামিটারসমূহ:\n - dataStr: একটি স্ট্রিং যা সংখ্যার একটি সিরিজ উপস্থাপন করে। দৈর্ঘ্য 100 অতিক্রম করে না।\n\n রিটার্নস:\n number: প্রতিটি ডেটা স্ট্রিংয়ের ফলাফল যা সমীকরণের ডানপাশের সাথে মিলে যায়।\n\n উদাহরণ ব্যবহার:\n console.assert(decodeNumbers(\"0000\") === 4);",
      "bg": "Напишете TypeScript функция `function decodeNumbers(dataStr: string): number`, за да решите следния проблем:\nДекодирайте серия от числа, за да разкриете модела и разберете действителните стойности, които всяка цифра представлява.\n 0000=4 8888=8 1234=1 5678=3 9012=2 1357=0 2468=4\n\n Параметри:\n - dataStr: Низ, представляващ серия от числа. Дължината не надвишава 100.\n\n Връща:\n number: Резултатът от всеки низ от данни, съответстващ на дясната страна на уравнението.\n\n Пример за използване:\n console.assert(decodeNumbers(\"0000\") === 4);",
      "zh": "编写一个 TypeScript 函数 `function decodeNumbers(dataStr: string): number` 来解决以下问题：\n解码一系列数字以揭示模式并理解每个数字所代表的实际值。\n0000=4 8888=8 1234=1 5678=3 9012=2 1357=0 2468=4\n\n参数：\n- dataStr: 一个表示一系列数字的字符串。长度不超过100。\n\n返回：\nnumber: 每个数据字符串对应于等式右侧的结果。\n\n示例用法：\nconsole.assert(decodeNumbers(\"0000\") === 4);",
      "fr": "Écrire une fonction TypeScript `function decodeNumbers(dataStr: string): number` pour résoudre le problème suivant :\nDécoder une série de chiffres pour révéler le motif et comprendre les valeurs réelles que chaque chiffre représente.\n0000=4 8888=8 1234=1 5678=3 9012=2 1357=0 2468=4\n\nParamètres :\n- dataStr : Une chaîne représentant une série de chiffres. La longueur ne dépasse pas 100.\n\nRenvoie :\nnumber : Le résultat de chaque chaîne de données correspondant au côté droit de l'équation.\n\nExemple d'utilisation :\nconsole.assert(decodeNumbers(\"0000\") === 4);",
      "de": "Schreiben Sie eine TypeScript-Funktion `function decodeNumbers(dataStr: string): number`, um das folgende Problem zu lösen:\nDekodieren Sie eine Reihe von Zahlen, um das Muster zu erkennen und die tatsächlichen Werte zu verstehen, die jede Ziffer darstellt.\n0000=4 8888=8 1234=1 5678=3 9012=2 1357=0 2468=4\n\nParameter:\n- dataStr: Ein String, der eine Reihe von Zahlen darstellt. Die Länge überschreitet nicht 100.\n\nRückgabewert:\nnumber: Das Ergebnis jedes Datenstrings, das der rechten Seite der Gleichung entspricht.\n\nBeispielverwendung:\nconsole.assert(decodeNumbers(\"0000\") === 4);",
      "ha": "Rubuta aikin TypeScript `function decodeNumbers(dataStr: string): number` don warware matsalar mai zuwa:\nFassara jerin lambobi don bayyana tsarin kuma fahimci ainihin ƙimar da kowace lamba ke wakilta.\n0000=4 8888=8 1234=1 5678=3 9012=2 1357=0 2468=4\n\nSigogi:\n- dataStr: Wani kirtani da ke wakiltar jerin lambobi. Tsawon ba zai wuce 100 ba.\n\nDawowa:\nnumber: Sakamakon kowane kirtani na bayanai da ya dace da gefen dama na lissafin.\n\nMisalin amfani:\nconsole.assert(decodeNumbers(\"0000\") === 4);",
      "hi": "TypeScript फ़ंक्शन `function decodeNumbers(dataStr: string): number` लिखें ताकि निम्नलिखित समस्या का समाधान किया जा सके:\nसंख्याओं की एक श्रृंखला को डिकोड करें ताकि पैटर्न का पता चल सके और समझ सकें कि प्रत्येक अंक का वास्तविक मूल्य क्या है।\n0000=4 8888=8 1234=1 5678=3 9012=2 1357=0 2468=4\n\nपैरामीटर्स:\n- dataStr: एक स्ट्रिंग जो संख्याओं की एक श्रृंखला का प्रतिनिधित्व करती है। लंबाई 100 से अधिक नहीं है।\n\nवापसी:\nnumber: प्रत्येक डेटा स्ट्रिंग का परिणाम जो समीकरण के दाहिने हाथ की ओर संबंधित है।\n\nउदाहरण उपयोग:\nconsole.assert(decodeNumbers(\"0000\") === 4);",
      "hu": "Írj egy TypeScript függvényt `function decodeNumbers(dataStr: string): number` a következő probléma megoldására:\nDekódolj egy számsorozatot, hogy felfedd a mintát és megértsd, hogy az egyes számjegyek valójában mit képviselnek.\n 0000=4 8888=8 1234=1 5678=3 9012=2 1357=0 2468=4\n\n Paraméterek:\n - dataStr: Egy számsorozatot reprezentáló string. Hossza nem haladja meg a 100-at.\n\n Visszatérési érték:\n number: Az egyes adat stringek eredménye, amely megfelel az egyenlet jobb oldalának.\n\n Példa használat:\n console.assert(decodeNumbers(\"0000\") === 4);"
    },
    "instruction_bertscore": {
      "sq": "0.9885139995862765",
      "hy": "0.979071309902259",
      "bn": "0.9659017183788838",
      "bg": "0.9929615324480288",
      "zh": "0.9791587072699144",
      "fr": "0.9847974265267327",
      "de": "0.9813422510486309",
      "ha": "0.9678312139002567",
      "hi": "0.9718763216100322",
      "hu": "0.9743371534006735"
    },
    "level": "easy",
    "test": "const testDecodeNumbers = (): void => {\n    console.assert(decodeNumbers(\"0000\") === 4);\n    console.assert(decodeNumbers(\"8888\") === 8);\n    console.assert(decodeNumbers(\"1234\") === 1);\n    console.assert(decodeNumbers(\"5678\") === 3);\n    console.assert(decodeNumbers(\"9012\") === 2);\n    console.assert(decodeNumbers(\"1357\") === 0);\n    console.assert(decodeNumbers(\"2468\") === 4);\n\n    // Additional test samples\n    console.assert(decodeNumbers(\"9999\") === 4);\n    console.assert(decodeNumbers(\"1111\") === 0);\n    console.assert(decodeNumbers(\"2222\") === 0);\n    console.assert(decodeNumbers(\"3333\") === 0);\n    console.assert(decodeNumbers(\"4444\") === 4);\n    console.assert(decodeNumbers(\"5555\") === 0);\n    console.assert(decodeNumbers(\"6666\") === 4);\n    console.assert(decodeNumbers(\"7777\") === 0);\n    console.assert(decodeNumbers(\"0001\") === 3);\n    console.assert(decodeNumbers(\"2301\") === 1);\n};\n\ntestDecodeNumbers();",
    "entry_point": "decodeNumbers",
    "signature": "function decodeNumbers(dataStr: string): number",
    "docstring": {
      "en": "Decode a series of numbers to reveal the pattern and understand the actual values\n each digit represents.\n 0000=4 8888=8 1234=1 5678=3 9012=2 1357=0 2468=4\n\n Parameters:\n - dataStr: A string representing a series of numbers. Length does not exceed 100.\n\n Returns:\n number: The result of each data string corresponding to the right-hand side of the equation.\n\n Example usage:\n console.assert(decodeNumbers(\"0000\") === 4);",
      "sq": "Dekodo një seri numrash për të zbuluar modelin dhe për të kuptuar vlerat aktuale që përfaqëson secila shifër.\n 0000=4 8888=8 1234=1 5678=3 9012=2 1357=0 2468=4\n\n Parametrat:\n - dataStr: Një varg që përfaqëson një seri numrash. Gjatësia nuk e kalon 100.\n\n Kthen:\n number: Rezultati i secilit varg të dhënash që korrespondon me anën e djathtë të ekuacionit.\n\n Shembull përdorimi:\n console.assert(decodeNumbers(\"0000\") === 4);",
      "hy": "Թվերի շարք վերծանեք՝ բացահայտելու համար օրինաչափությունը և հասկանալու համար իրական արժեքները, որոնք ներկայացնում է յուրաքանչյուր թվանշան:\n 0000=4 8888=8 1234=1 5678=3 9012=2 1357=0 2468=4\n\n Պարամետրեր:\n - dataStr: Թվերի շարքը ներկայացնող տող։ Երկարությունը չի գերազանցում 100-ը։\n\n Վերադարձնում է:\n number: Յուրաքանչյուր տվյալ տողի արդյունքը, որը համապատասխանում է հավասարման աջ կողմին։\n\n Օրինակ օգտագործում:\n console.assert(decodeNumbers(\"0000\") === 4);",
      "bn": "Decode a series of numbers to reveal the pattern and understand the actual values each digit represents.\n0000=4 8888=8 1234=1 5678=3 9012=2 1357=0 2468=4\n\nপ্যারামিটারসমূহ:\n- dataStr: একটি স্ট্রিং যা সংখ্যার একটি সিরিজ উপস্থাপন করে। দৈর্ঘ্য 100 অতিক্রম করে না।\n\nফেরত দেয়:\nnumber: প্রতিটি ডেটা স্ট্রিং এর ফলাফল যা সমীকরণের ডানপাশের সাথে মিলে যায়।\n\nব্যবহারের উদাহরণ:\nconsole.assert(decodeNumbers(\"0000\") === 4);",
      "bg": "Декодирайте поредица от числа, за да разкриете модела и да разберете действителните стойности, които всяка цифра представлява.\n 0000=4 8888=8 1234=1 5678=3 9012=2 1357=0 2468=4\n\n Параметри:\n - dataStr: Низ, представляващ поредица от числа. Дължината не надвишава 100.\n\n Връща:\n number: Резултатът от всеки низ от данни, съответстващ на дясната страна на уравнението.\n\n Пример за използване:\n console.assert(decodeNumbers(\"0000\") === 4);",
      "zh": "解码一系列数字以揭示模式并理解每个数字实际代表的值。\n0000=4 8888=8 1234=1 5678=3 9012=2 1357=0 2468=4\n\n参数：\n- dataStr: 一个表示一系列数字的字符串。长度不超过100。\n\n返回：\nnumber: 每个数据字符串对应方程右侧的结果。\n\n示例用法：\nconsole.assert(decodeNumbers(\"0000\") === 4);",
      "fr": "Décoder une série de chiffres pour révéler le motif et comprendre les valeurs réelles que chaque chiffre représente.  \n0000=4 8888=8 1234=1 5678=3 9012=2 1357=0 2468=4\n\nParamètres:\n- dataStr: Une chaîne représentant une série de chiffres. La longueur ne dépasse pas 100.\n\nRenvoie:\nnumber: Le résultat de chaque chaîne de données correspondant au côté droit de l'équation.\n\nExemple d'utilisation:\nconsole.assert(decodeNumbers(\"0000\") === 4);",
      "de": "Dekodiere eine Serie von Zahlen, um das Muster zu erkennen und die tatsächlichen Werte zu verstehen, die jede Ziffer darstellt.\n 0000=4 8888=8 1234=1 5678=3 9012=2 1357=0 2468=4\n\n Parameter:\n - dataStr: Ein String, der eine Serie von Zahlen darstellt. Die Länge überschreitet nicht 100.\n\n Rückgabe:\n number: Das Ergebnis jedes Datenstrings, das der rechten Seite der Gleichung entspricht.\n\n Beispielverwendung:\n console.assert(decodeNumbers(\"0000\") === 4);",
      "ha": "Decode jerin lambobi don bayyana tsarin kuma fahimtar ainihin ƙimomin da kowace lamba ke wakilta.\n 0000=4 8888=8 1234=1 5678=3 9012=2 1357=0 2468=4\n\n Sigogi:\n - dataStr: Wani kirtani da ke wakiltar jerin lambobi. Tsawon ba zai wuce 100 ba.\n\n Abubuwan da ake dawowa da su:\n number: Sakamakon kowanne kirtani na bayanai da ya dace da gefen dama na lissafin.\n\n Misalin amfani:\n console.assert(decodeNumbers(\"0000\") === 4);",
      "hi": "Decode a series of numbers to reveal the pattern and understand the actual values each digit represents.\nसंख्याओं की एक श्रृंखला को डिकोड करें ताकि पैटर्न का पता चल सके और प्रत्येक अंक का वास्तविक मान समझ सकें।\n0000=4 8888=8 1234=1 5678=3 9012=2 1357=0 2468=4\n\nParameters:\n- dataStr: A string representing a series of numbers. Length does not exceed 100.\n- dataStr: संख्याओं की एक श्रृंखला का प्रतिनिधित्व करने वाला एक स्ट्रिंग। लंबाई 100 से अधिक नहीं है।\n\nReturns:\nnumber: The result of each data string corresponding to the right-hand side of the equation.\nnumber: प्रत्येक डेटा स्ट्रिंग का परिणाम जो समीकरण के दाईं ओर के अनुरूप होता है।\n\nExample usage:\nconsole.assert(decodeNumbers(\"0000\") === 4);",
      "hu": "Dekódoljon egy számsorozatot, hogy felfedje a mintát és megértse, hogy az egyes számjegyek valójában milyen értékeket képviselnek.\n 0000=4 8888=8 1234=1 5678=3 9012=2 1357=0 2468=4\n\n Paraméterek:\n - dataStr: Egy számsorozatot reprezentáló karakterlánc. Hossza nem haladja meg a 100-at.\n\n Visszatérési érték:\n number: Az egyes adatkarakterláncok eredménye, amely megfelel az egyenlet jobb oldalának.\n\n Példa használat:\n console.assert(decodeNumbers(\"0000\") === 4);"
    },
    "docstring_bertscore": {
      "sq": "0.9919624216314232",
      "hy": "0.957715564485293",
      "bn": "0.9737498033639533",
      "bg": "0.9859806677065576",
      "zh": "0.9711719782788826",
      "fr": "0.9833490137882264",
      "de": "0.9728915214875016",
      "ha": "0.9737349060853757",
      "hi": "1",
      "hu": "0.9686318929662084"
    }
  },
  {
    "task_id": "TypeScript/15",
    "prompt": {
      "en": "\n/**\n * Counts the number of different coloring methods for `n` squares with `m` colors,\n * considering the requirement that adjacent squares and the first/last squares\n * must have different colors.\n * \n * Args:\n * - n (number): The number of squares.\n * - m (number): The number of colors.\n * \n * Returns:\n * - number: The count of different coloring methods satisfying the specified conditions.\n *           The result is modulo 1000003.\n * \n * Example calls:\n * ```\n * countColoringMethods(1, 1) // returns 1\n * ```\n */\nfunction countColoringMethods(n: number, m: number): number {",
      "sq": "/**\n * Numëron numrin e metodave të ndryshme të ngjyrosjes për `n` katrorë me `m` ngjyra,\n * duke konsideruar kërkesën që katrorët ngjitur dhe katrorët e parë/fundit\n * duhet të kenë ngjyra të ndryshme.\n * \n * Argumentet:\n * - n (numër): Numri i katrorëve.\n * - m (numër): Numri i ngjyrave.\n * \n * Kthen:\n * - numër: Numri i metodave të ndryshme të ngjyrosjes që plotësojnë kushtet e specifikuara.\n *           Rezultati është modulo 1000003.\n * \n * Thirrje shembull:\n * ```\n * countColoringMethods(1, 1) // kthen 1\n * ```\n */\nfunction countColoringMethods(n: number, m: number): number {",
      "hy": "/**\n * Հաշվում է տարբեր գունավորման մեթոդների քանակը `n` քառակուսիների համար `m` գույներով,\n * հաշվի առնելով այն պահանջը, որ հարակից քառակուսիները և առաջին/վերջին քառակուսիները\n * պետք է ունենան տարբեր գույներ։\n * \n * Պարամետրեր:\n * - n (number): Քառակուսիների քանակը։\n * - m (number): Գույների քանակը։\n * \n * Վերադարձնում է:\n * - number: Տարբեր գունավորման մեթոդների քանակը, որոնք բավարարում են նշված պայմանները։\n *           Արդյունքը վերադարձվում է 1000003 մոդուլով։\n * \n * Օրինակ կանչեր:\n * ```\n * countColoringMethods(1, 1) // վերադարձնում է 1\n * ```\n */\nfunction countColoringMethods(n: number, m: number): number {",
      "bn": "/**\n * `n` টি বর্গক্ষেত্রের জন্য `m` টি রঙের বিভিন্ন রঙ করার পদ্ধতির সংখ্যা গণনা করে,\n * যেখানে শর্ত হল যে সংলগ্ন বর্গক্ষেত্র এবং প্রথম/শেষ বর্গক্ষেত্রগুলির রঙ ভিন্ন হতে হবে।\n * \n * আর্গুমেন্ট:\n * - n (number): বর্গক্ষেত্রের সংখ্যা।\n * - m (number): রঙের সংখ্যা।\n * \n * রিটার্নস:\n * - number: নির্দিষ্ট শর্তগুলি পূরণ করে এমন বিভিন্ন রঙ করার পদ্ধতির সংখ্যা।\n *           ফলাফলটি 1000003 দ্বারা মডুলো।\n * \n * উদাহরণ কল:\n * ```\n * countColoringMethods(1, 1) // 1 রিটার্ন করে\n * ```\n */\nfunction countColoringMethods(n: number, m: number): number {",
      "bg": "/**\n * Брои броя на различните методи за оцветяване на `n` квадрата с `m` цвята,\n * като се взема предвид изискването съседните квадрати и първият/последният квадрат\n * да са с различни цветове.\n * \n * Аргументи:\n * - n (number): Броят на квадратите.\n * - m (number): Броят на цветовете.\n * \n * Връща:\n * - number: Броят на различните методи за оцветяване, които удовлетворяват посочените условия.\n *           Резултатът е модуло 1000003.\n * \n * Примери за извикване:\n * ```\n * countColoringMethods(1, 1) // връща 1\n * ```\n */\nfunction countColoringMethods(n: number, m: number): number {",
      "zh": "/**\n * 计算使用 `m` 种颜色为 `n` 个方块上色的不同方法数，\n * 考虑到相邻方块以及首尾方块必须有不同颜色的要求。\n * \n * 参数:\n * - n (number): 方块的数量。\n * - m (number): 颜色的数量。\n * \n * 返回:\n * - number: 满足指定条件的不同上色方法的数量。\n *           结果对 1000003 取模。\n * \n * 示例调用:\n * ```\n * countColoringMethods(1, 1) // returns 1\n * ```\n */\nfunction countColoringMethods(n: number, m: number): number {",
      "fr": "/**\n * Compte le nombre de méthodes de coloration différentes pour `n` carrés avec `m` couleurs,\n * en considérant l'exigence que les carrés adjacents et les premiers/derniers carrés\n * doivent avoir des couleurs différentes.\n * \n * Args:\n * - n (nombre): Le nombre de carrés.\n * - m (nombre): Le nombre de couleurs.\n * \n * Returns:\n * - nombre: Le compte des différentes méthodes de coloration satisfaisant les conditions spécifiées.\n *           Le résultat est modulo 1000003.\n * \n * Appels d'exemple:\n * ```\n * countColoringMethods(1, 1) // returns 1\n * ```\n */\nfunction countColoringMethods(n: number, m: number): number {",
      "de": "/**\n * Zählt die Anzahl der verschiedenen Färbemethoden für `n` Quadrate mit `m` Farben,\n * unter Berücksichtigung der Anforderung, dass benachbarte Quadrate und die ersten/letzten Quadrate\n * unterschiedliche Farben haben müssen.\n * \n * Argumente:\n * - n (number): Die Anzahl der Quadrate.\n * - m (number): Die Anzahl der Farben.\n * \n * Rückgabe:\n * - number: Die Anzahl der verschiedenen Färbemethoden, die die angegebenen Bedingungen erfüllen.\n *           Das Ergebnis ist modulo 1000003.\n * \n * Beispielaufrufe:\n * ```\n * countColoringMethods(1, 1) // gibt 1 zurück\n * ```\n */\nfunction countColoringMethods(n: number, m: number): number {",
      "ha": "/**\n * Yana ƙidaya adadin hanyoyin launuka daban-daban don `n` murabba'ai tare da `m` launuka,\n * la'akari da buƙatar cewa murabba'ai masu makwabtaka da kuma murabba'ai na farko/na ƙarshe\n * dole ne su kasance da launuka daban-daban.\n * \n * Args:\n * - n (number): Yawan murabba'ai.\n * - m (number): Yawan launuka.\n * \n * Returns:\n * - number: Adadin hanyoyin launuka daban-daban da suka cika ka'idodin da aka fayyace.\n *           Sakamakon yana cikin modulo 1000003.\n * \n * Misalan kira:\n * ```\n * countColoringMethods(1, 1) // returns 1\n * ```\n */\nfunction countColoringMethods(n: number, m: number): number {",
      "hi": "/**\n * `n` वर्गों के लिए `m` रंगों के विभिन्न रंगाई तरीकों की संख्या गिनता है,\n * इस आवश्यकता को ध्यान में रखते हुए कि आसन्न वर्ग और पहले/अंतिम वर्गों के\n * रंग भिन्न होने चाहिए।\n * \n * तर्क:\n * - n (संख्या): वर्गों की संख्या।\n * - m (संख्या): रंगों की संख्या।\n * \n * लौटाता है:\n * - संख्या: निर्दिष्ट शर्तों को संतोषजनक बनाने वाले विभिन्न रंगाई तरीकों की संख्या।\n *           परिणाम 1000003 के मापांक में है।\n * \n * उदाहरण कॉल्स:\n * ```\n * countColoringMethods(1, 1) // 1 लौटाता है\n * ```\n */\nfunction countColoringMethods(n: number, m: number): number {",
      "hu": "/**\n * Számolja meg a `n` négyzet különböző színezési módszereit `m` színnel,\n * figyelembe véve azt a követelményt, hogy a szomszédos négyzetek és az első/utolsó négyzetek\n * különböző színűek legyenek.\n * \n * Argumentumok:\n * - n (szám): A négyzetek száma.\n * - m (szám): A színek száma.\n * \n * Visszatér:\n * - szám: A különböző színezési módszerek száma, amelyek megfelelnek a megadott feltételeknek.\n *           Az eredmény modulo 1000003.\n * \n * Példa hívások:\n * ```\n * countColoringMethods(1, 1) // visszaadja 1\n * ```\n */\nfunction countColoringMethods(n: number, m: number): number {"
    },
    "prompt_bertscore": {
      "sq": "0.9825586635020885",
      "hy": "0.9688962700033659",
      "bn": "0.9533953536977842",
      "bg": "0.9790182755905227",
      "zh": "0.9411225783447815",
      "fr": "1",
      "de": "0.9821411424411532",
      "ha": "0.9912060371404424",
      "hi": "0.9803810786348031",
      "hu": "0.9684779544209063"
    },
    "canonical_solution": "const MOD = 1000003;\n    let f: number[] = new Array(n + 1); // Array to store results\n\n    if (n === 1) return m;\n    if (n === 2) return (m * (m - 1)) % MOD;\n\n    // Initialize the first three elements\n    f[1] = m;\n    f[2] = (m * (m - 1)) % MOD;\n    f[3] = (f[2] * (m - 2)) % MOD;\n\n    for (let i = 4; i <= n; i++) {\n        f[i] = ((f[i - 1] * (m - 2)) % MOD + (f[i - 2] * (m - 1)) % MOD) % MOD;\n    }\n\n    return f[n];\n}",
    "instruction": {
      "en": "Write a TypeScript function `function countColoringMethods(n: number, m: number): number` to solve the following problem:\nCounts the number of different coloring methods for `n` squares with `m` colors,\nconsidering the requirement that adjacent squares and the first/last squares\nmust have different colors.\n\nArgs:\n- n (number): The number of squares.\n- m (number): The number of colors.\n\nReturns:\n- number: The count of different coloring methods satisfying the specified conditions.\nThe result is modulo 1000003.\n\nExample calls:\ncountColoringMethods(1, 1) // returns 1\n",
      "sq": "Shkruani një funksion TypeScript `function countColoringMethods(n: number, m: number): number` për të zgjidhur problemin e mëposhtëm:\nNumëron numrin e metodave të ndryshme të ngjyrosjes për `n` katrorë me `m` ngjyra,\nduke marrë parasysh kërkesën që katrorët ngjitur dhe katrorët e parë/fundit\nduhet të kenë ngjyra të ndryshme.\n\nArgumentet:\n- n (numër): Numri i katrorëve.\n- m (numër): Numri i ngjyrave.\n\nKthen:\n- numër: Numri i metodave të ndryshme të ngjyrosjes që plotësojnë kushtet e specifikuara.\nRezultati është modulo 1000003.\n\nShembuj thirrjesh:\ncountColoringMethods(1, 1) // kthen 1",
      "hy": "TypeScript ֆունկցիա գրեք `function countColoringMethods(n: number, m: number): number` հետևյալ խնդիրը լուծելու համար:\nՀաշվում է տարբեր ներկման մեթոդների քանակը `n` քառակուսիների համար `m` գույներով,\nհաշվի առնելով պահանջը, որ հարակից քառակուսիները և առաջին/վերջին քառակուսիները\nպետք է ունենան տարբեր գույներ։\n\nԱրգումենտներ:\n- n (number): Քառակուսիների քանակը։\n- m (number): Գույների քանակը։\n\nՎերադարձնում է:\n- number: Տարբեր ներկման մեթոդների քանակը, որոնք բավարարում են նշված պայմանները։\nԱրդյունքը մոդուլով 1000003։\n\nՕրինակ կանչեր:\ncountColoringMethods(1, 1) // վերադարձնում է 1",
      "bn": "TypeScript ফাংশন `function countColoringMethods(n: number, m: number): number` লিখুন নিম্নলিখিত সমস্যাটি সমাধানের জন্য:\n`n` স্কোয়ারের জন্য `m` রঙের বিভিন্ন রঙ করার পদ্ধতির সংখ্যা গণনা করে,\nযেখানে শর্ত হল যে সংলগ্ন স্কোয়ার এবং প্রথম/শেষ স্কোয়ারের রঙ ভিন্ন হতে হবে।\n\nআর্গুমেন্ট:\n- n (number): স্কোয়ারের সংখ্যা।\n- m (number): রঙের সংখ্যা।\n\nরিটার্নস:\n- number: নির্দিষ্ট শর্তগুলি পূরণ করে এমন বিভিন্ন রঙ করার পদ্ধতির সংখ্যা।\nফলাফলটি 1000003 দ্বারা মডুলো করা হয়।\n\nউদাহরণ কল:\ncountColoringMethods(1, 1) // 1 রিটার্ন করে",
      "bg": "Напишете функция на TypeScript `function countColoringMethods(n: number, m: number): number`, за да решите следния проблем:\nБрои броя на различните методи за оцветяване на `n` квадрата с `m` цвята,\nкато се има предвид изискването съседните квадрати и първият/последният квадрат\nда имат различни цветове.\n\nАргументи:\n- n (number): Броят на квадратите.\n- m (number): Броят на цветовете.\n\nВръща:\n- number: Броят на различните методи за оцветяване, които удовлетворяват указаните условия.\nРезултатът е модуло 1000003.\n\nПримери за извикване:\ncountColoringMethods(1, 1) // връща 1",
      "zh": "编写一个 TypeScript 函数 `function countColoringMethods(n: number, m: number): number` 来解决以下问题：\n计算使用 `m` 种颜色为 `n` 个方块上色的不同方法数量，\n考虑到相邻方块以及第一个/最后一个方块必须具有不同颜色的要求。\n\n参数：\n- n (number): 方块的数量。\n- m (number): 颜色的数量。\n\n返回：\n- number: 满足指定条件的不同上色方法的数量。\n结果取模 1000003。\n\n示例调用：\ncountColoringMethods(1, 1) // 返回 1",
      "fr": "Écrire une fonction TypeScript `function countColoringMethods(n: number, m: number): number` pour résoudre le problème suivant :\nCompte le nombre de méthodes de coloration différentes pour `n` carrés avec `m` couleurs,\nen considérant l'exigence que les carrés adjacents et les premiers/derniers carrés\ndoivent avoir des couleurs différentes.\n\nArgs:\n- n (number): Le nombre de carrés.\n- m (number): Le nombre de couleurs.\n\nReturns:\n- number: Le compte des différentes méthodes de coloration satisfaisant les conditions spécifiées.\nLe résultat est modulo 1000003.\n\nAppels d'exemple:\ncountColoringMethods(1, 1) // retourne 1",
      "de": "Schreiben Sie eine TypeScript-Funktion `function countColoringMethods(n: number, m: number): number`, um das folgende Problem zu lösen:\nZählt die Anzahl der verschiedenen Färbemethoden für `n` Quadrate mit `m` Farben,\nunter Berücksichtigung der Anforderung, dass benachbarte Quadrate und die ersten/letzten Quadrate\nunterschiedliche Farben haben müssen.\n\nArgumente:\n- n (number): Die Anzahl der Quadrate.\n- m (number): Die Anzahl der Farben.\n\nRückgabewert:\n- number: Die Anzahl der verschiedenen Färbemethoden, die die angegebenen Bedingungen erfüllen.\nDas Ergebnis ist modulo 1000003.\n\nBeispielaufrufe:\ncountColoringMethods(1, 1) // gibt 1 zurück",
      "ha": "Rubuta aikin TypeScript `function countColoringMethods(n: number, m: number): number` don warware matsalar mai zuwa:\nYana ƙidaya yawan hanyoyin launi daban-daban don murabba'i `n` tare da launuka `m`,\nla'akari da buƙatar cewa murabba'i masu makwabtaka da murabba'i na farko/na ƙarshe\ndole ne su sami launuka daban-daban.\n\nArgs:\n- n (number): Yawan murabba'ai.\n- m (number): Yawan launuka.\n\nReturns:\n- number: Yawan hanyoyin launi daban-daban da suka cika yanayin da aka fayyace.\nSakamakon yana cikin modulo 1000003.\n\nMisalan kira:\ncountColoringMethods(1, 1) // yana dawowa 1",
      "hi": "TypeScript फ़ंक्शन `function countColoringMethods(n: number, m: number): number` लिखें ताकि निम्नलिखित समस्या का समाधान किया जा सके:\n`n` वर्गों के लिए `m` रंगों के विभिन्न रंगने के तरीकों की गिनती करता है,\nइस आवश्यकता को ध्यान में रखते हुए कि आसन्न वर्ग और पहले/अंतिम वर्गों के रंग अलग-अलग होने चाहिए।\n\nआर्ग्स:\n- n (number): वर्गों की संख्या।\n- m (number): रंगों की संख्या।\n\nवापसी:\n- number: निर्दिष्ट शर्तों को संतुष्ट करने वाले विभिन्न रंगने के तरीकों की गिनती।\nपरिणाम 1000003 के माड्यूलो में है।\n\nउदाहरण कॉल्स:\ncountColoringMethods(1, 1) // 1 लौटाता है",
      "hu": "Írj egy TypeScript függvényt `function countColoringMethods(n: number, m: number): number` a következő probléma megoldására:\nMegszámolja az `n` négyzet különböző színezési módszereit `m` színnel,\nfigyelembe véve azt a követelményt, hogy a szomszédos négyzetek és az első/utolsó négyzetek\nkülönböző színűek legyenek.\n\nArgok:\n- n (number): A négyzetek száma.\n- m (number): A színek száma.\n\nVisszatér:\n- number: A különböző színezési módszerek száma, amelyek megfelelnek a megadott feltételeknek.\nAz eredmény modulo 1000003.\n\nPélda hívások:\ncountColoringMethods(1, 1) // visszaadja 1"
    },
    "instruction_bertscore": {
      "sq": "0.9730343367314657",
      "hy": "0.969449455614548",
      "bn": "0.951856961396669",
      "bg": "0.9725037949837214",
      "zh": "0.9455403166493785",
      "fr": "0.9952511448502179",
      "de": "0.9788953233846621",
      "ha": "0.976230100931936",
      "hi": "0.9659497869310943",
      "hu": "0.977926801646736"
    },
    "level": "middle",
    "test": "function runTests() {\n    console.assert(countColoringMethods(1, 1) === 1);\n    console.assert(countColoringMethods(2, 2) === 2);\n    console.assert(countColoringMethods(3, 3) === 6);\n    console.assert(countColoringMethods(4, 2) === 2);\n    // The expected result for this case is not provided in the C code, but it is required to pass the test\n    console.assert(countColoringMethods(1000, 10) === 566585); \n\n    // Additional test cases.\n    console.assert(countColoringMethods(2, 3) === 6);\n    console.assert(countColoringMethods(1000, 1000) === 67911);\n    console.assert(countColoringMethods(999, 66) === 501817);\n    console.assert(countColoringMethods(5, 3) === 30); // Example of an expected output\n\n}\n\nrunTests();",
    "entry_point": "countColoringMethods",
    "signature": "function countColoringMethods(n: number, m: number): number",
    "docstring": {
      "en": "Counts the number of different coloring methods for `n` squares with `m` colors,\nconsidering the requirement that adjacent squares and the first/last squares\nmust have different colors.\n\nArgs:\n- n (number): The number of squares.\n- m (number): The number of colors.\n\nReturns:\n- number: The count of different coloring methods satisfying the specified conditions.\nThe result is modulo 1000003.\n\nExample calls:\ncountColoringMethods(1, 1) // returns 1\n",
      "sq": "Numëron numrin e metodave të ndryshme të ngjyrosjes për `n` katrorë me `m` ngjyra, duke marrë parasysh kërkesën që katrorët ngjitur dhe katrorët e parë/fundit duhet të kenë ngjyra të ndryshme.\n\nArgumentet:\n- n (numër): Numri i katrorëve.\n- m (numër): Numri i ngjyrave.\n\nKthen:\n- numër: Numri i metodave të ndryshme të ngjyrosjes që plotësojnë kushtet e specifikuara. Rezultati është modulo 1000003.\n\nShembuj thirrjesh:\ncountColoringMethods(1, 1) // kthen 1",
      "hy": "Հաշվում է տարբեր գունավորման մեթոդների քանակը `n` քառակուսիների համար `m` գույներով՝ հաշվի առնելով այն պահանջը, որ հարակից քառակուսիները և առաջին/վերջին քառակուսիները պետք է ունենան տարբեր գույներ:\n\nԱրգումենտներ:\n- n (number): Քառակուսիների քանակը։\n- m (number): Գույների քանակը։\n\nՎերադարձնում է:\n- number: Տարբեր գունավորման մեթոդների քանակը, որոնք բավարարում են նշված պայմաններին։ Արդյունքը մոդուլո 1000003 է։\n\nՕրինակ կանչեր:\ncountColoringMethods(1, 1) // վերադարձնում է 1",
      "bn": "`n` বর্গক্ষেত্র এবং `m` রঙের জন্য বিভিন্ন রঙ করার পদ্ধতির সংখ্যা গণনা করে, যেখানে শর্ত হল যে সংলগ্ন বর্গক্ষেত্র এবং প্রথম/শেষ বর্গক্ষেত্রগুলির রঙ ভিন্ন হতে হবে।\n\nআর্গস:\n- n (সংখ্যা): বর্গক্ষেত্রের সংখ্যা।\n- m (সংখ্যা): রঙের সংখ্যা।\n\nরিটার্নস:\n- সংখ্যা: নির্দিষ্ট শর্তগুলি পূরণ করে এমন বিভিন্ন রঙ করার পদ্ধতির সংখ্যা। ফলাফলটি 1000003 দ্বারা মডুলো।\n\nউদাহরণ কল:\ncountColoringMethods(1, 1) // 1 রিটার্ন করে",
      "bg": "Брои броя на различните методи за оцветяване на `n` квадрата с `m` цвята,\nкато се взема предвид изискването съседните квадрати и първият/последният квадрат\nда имат различни цветове.\n\nАргументи:\n- n (number): Броят на квадратите.\n- m (number): Броят на цветовете.\n\nВръща:\n- number: Броят на различните методи за оцветяване, които удовлетворяват посочените условия.\nРезултатът е модуло 1000003.\n\nПримери за извикване:\ncountColoringMethods(1, 1) // връща 1",
      "zh": "计算 `n` 个方块使用 `m` 种颜色的不同着色方法的数量，考虑到相邻方块和第一个/最后一个方块必须具有不同颜色的要求。\n\n参数:\n- n (number): 方块的数量。\n- m (number): 颜色的数量。\n\n返回:\n- number: 满足指定条件的不同着色方法的数量。结果取模 1000003。\n\n示例调用:\ncountColoringMethods(1, 1) // 返回 1",
      "fr": "Compte le nombre de méthodes de coloration différentes pour `n` carrés avec `m` couleurs, en considérant l'exigence que les carrés adjacents et les premiers/derniers carrés doivent avoir des couleurs différentes.\n\nArgs:\n- n (nombre) : Le nombre de carrés.\n- m (nombre) : Le nombre de couleurs.\n\nReturns:\n- nombre : Le compte des différentes méthodes de coloration satisfaisant les conditions spécifiées. Le résultat est modulo 1000003.\n\nExemples d'appels :\ncountColoringMethods(1, 1) // retourne 1",
      "de": "Zählt die Anzahl der verschiedenen Färbemethoden für `n` Quadrate mit `m` Farben,\nunter Berücksichtigung der Anforderung, dass benachbarte Quadrate und die ersten/letzten Quadrate\nunterschiedliche Farben haben müssen.\n\nArgumente:\n- n (number): Die Anzahl der Quadrate.\n- m (number): Die Anzahl der Farben.\n\nRückgabewert:\n- number: Die Anzahl der verschiedenen Färbemethoden, die die angegebenen Bedingungen erfüllen.\nDas Ergebnis ist modulo 1000003.\n\nBeispielaufrufe:\ncountColoringMethods(1, 1) // gibt 1 zurück",
      "ha": "Yana ƙidaya adadin hanyoyin launi daban-daban don murabba'ai `n` tare da launuka `m`, la'akari da buƙatar cewa murabba'ai masu makwabtaka da murabba'ai na farko/na ƙarshe dole ne su sami launuka daban-daban.\n\nArgs:\n- n (number): Yawan murabba'ai.\n- m (number): Yawan launuka.\n\nReturns:\n- number: Adadin hanyoyin launi daban-daban da suka cika ka'idodin da aka fayyace. Sakamakon yana cikin modulo 1000003.\n\nMisalan kira:\ncountColoringMethods(1, 1) // yana dawowa 1",
      "hi": "Counts the number of different coloring methods for `n` squares with `m` colors, considering the requirement that adjacent squares and the first/last squares must have different colors.\n\nविभिन्न रंग भरने की विधियों की संख्या की गणना करता है `n` वर्गों के लिए `m` रंगों के साथ, इस आवश्यकता को ध्यान में रखते हुए कि आसन्न वर्गों और पहले/अंतिम वर्गों के रंग अलग-अलग होने चाहिए।\n\nArgs:\n- n (number): वर्गों की संख्या।\n- m (number): रंगों की संख्या।\n\nReturns:\n- number: विभिन्न रंग भरने की विधियों की संख्या जो निर्दिष्ट शर्तों को पूरा करती हैं। परिणाम 1000003 के मापांक में है।\n\nExample calls:\ncountColoringMethods(1, 1) // 1 लौटाता है",
      "hu": "Számolja meg a különböző színezési módszerek számát `n` négyzetre `m` színnel, figyelembe véve azt a követelményt, hogy a szomszédos négyzetek és az első/utolsó négyzetek különböző színűek legyenek.\n\nArgumentumok:\n- n (szám): A négyzetek száma.\n- m (szám): A színek száma.\n\nVisszatérési érték:\n- szám: A megadott feltételeknek megfelelő különböző színezési módszerek száma. Az eredmény modulo 1000003.\n\nPélda hívások:\ncountColoringMethods(1, 1) // visszaadja 1"
    },
    "docstring_bertscore": {
      "sq": "0.9787495286849824",
      "hy": "0.9674989052727854",
      "bn": "0.9233713784524556",
      "bg": "0.9721214315002293",
      "zh": "0.9343884125365557",
      "fr": "0.995325233982344",
      "de": "0.9735344880309115",
      "ha": "0.9808810313038678",
      "hi": "0.9787950150422394",
      "hu": "0.9611041987857482"
    }
  },
  {
    "task_id": "TypeScript/16",
    "prompt": {
      "en": "\n/**\n * Counts the number of valid coin toss sequences with no consecutive heads in n tosses.\n * \n * @param n - The number of coin tosses.\n * @returns The count of valid sequences.\n * \n * Examples:\n * countValidCoinTossSequences(1) returns 2\n * countValidCoinTossSequences(2) returns 3\n */\nfunction countValidCoinTossSequences(n: number): number",
      "sq": "/**\n * Numëron numrin e sekuencave të vlefshme të hedhjeve të monedhës pa krye të njëpasnjëshme në n hedhje.\n * \n * @param n - Numri i hedhjeve të monedhës.\n * @returns Numri i sekuencave të vlefshme.\n * \n * Shembuj:\n * countValidCoinTossSequences(1) kthen 2\n * countValidCoinTossSequences(2) kthen 3\n */\nfunction countValidCoinTossSequences(n: number): number",
      "hy": "/**\n * Հաշվում է վավեր մետաղադրամի նետումների հաջորդականությունների քանակը՝ առանց հաջորդական գլուխների n նետումների դեպքում:\n * \n * @param n - Մետաղադրամի նետումների քանակը:\n * @returns Վավեր հաջորդականությունների քանակը:\n * \n * Օրինակներ:\n * countValidCoinTossSequences(1) վերադարձնում է 2\n * countValidCoinTossSequences(2) վերադարձնում է 3\n */\nfunction countValidCoinTossSequences(n: number): number",
      "bn": "/**\n * n টসের মধ্যে পরপর কোনো মাথা না থাকার বৈধ কয়েন টস সিকোয়েন্সের সংখ্যা গণনা করে।\n * \n * @param n - কয়েন টসের সংখ্যা।\n * @returns বৈধ সিকোয়েন্সের সংখ্যা।\n * \n * উদাহরণ:\n * countValidCoinTossSequences(1) 2 ফেরত দেয়\n * countValidCoinTossSequences(2) 3 ফেরত দেয়\n */\nfunction countValidCoinTossSequences(n: number): number",
      "bg": "/**\n * Брои броя на валидните последователности от хвърляния на монета без последователни ези в n хвърляния.\n * \n * @param n - Броят на хвърлянията на монета.\n * @returns Броят на валидните последователности.\n * \n * Примери:\n * countValidCoinTossSequences(1) returns 2\n * countValidCoinTossSequences(2) returns 3\n */\nfunction countValidCoinTossSequences(n: number): number",
      "zh": "/**\n * 计算在 n 次投掷中没有连续正面的有效硬币投掷序列的数量。\n * \n * @param n - 投掷硬币的次数。\n * @returns 有效序列的数量。\n * \n * 例子:\n * countValidCoinTossSequences(1) 返回 2\n * countValidCoinTossSequences(2) 返回 3\n */\nfunction countValidCoinTossSequences(n: number): number",
      "fr": "/**\n * Compte le nombre de séquences de lancers de pièce valides sans faces consécutives dans n lancers.\n * \n * @param n - Le nombre de lancers de pièce.\n * @returns Le compte des séquences valides.\n * \n * Exemples :\n * countValidCoinTossSequences(1) returns 2\n * countValidCoinTossSequences(2) returns 3\n */\nfunction countValidCoinTossSequences(n: number): number",
      "de": "/**\n * Zählt die Anzahl der gültigen Münzwurfsequenzen ohne aufeinanderfolgende Köpfe in n Würfen.\n * \n * @param n - Die Anzahl der Münzwürfe.\n * @returns Die Anzahl der gültigen Sequenzen.\n * \n * Beispiele:\n * countValidCoinTossSequences(1) gibt 2 zurück\n * countValidCoinTossSequences(2) gibt 3 zurück\n */\nfunction countValidCoinTossSequences(n: number): number",
      "ha": "/**\n * Yana ƙidaya adadin jerin jefa tsabar kudi masu inganci ba tare da kai biyu a jere ba a cikin jefa n.\n * \n * @param n - Adadin jefa tsabar kudi.\n * @returns Adadin jerin masu inganci.\n * \n * Misalai:\n * countValidCoinTossSequences(1) returns 2\n * countValidCoinTossSequences(2) returns 3\n */\nfunction countValidCoinTossSequences(n: number): number",
      "hi": "/**\n * n उछालों में बिना लगातार हेड्स के वैध सिक्का उछाल अनुक्रमों की संख्या गिनता है।\n * \n * @param n - सिक्का उछालों की संख्या।\n * @returns वैध अनुक्रमों की गिनती।\n * \n * उदाहरण:\n * countValidCoinTossSequences(1) returns 2\n * countValidCoinTossSequences(2) returns 3\n */\nfunction countValidCoinTossSequences(n: number): number",
      "hu": "/**\n * Megszámolja az érvényes pénzfeldobás sorozatok számát, ahol nincs két egymást követő fej az n dobásban.\n * \n * @param n - A pénzfeldobások száma.\n * @returns Az érvényes sorozatok száma.\n * \n * Példák:\n * countValidCoinTossSequences(1) visszaadja 2\n * countValidCoinTossSequences(2) visszaadja 3\n */\nfunction countValidCoinTossSequences(n: number): number"
    },
    "prompt_bertscore": {
      "sq": "0.979908139697559",
      "hy": "0.981285840020417",
      "bn": "0.9836811237853167",
      "bg": "0.9866860041896125",
      "zh": "0.9742837218281751",
      "fr": "0.9882440608984502",
      "de": "0.9919926134493405",
      "ha": "0.965857225173532",
      "hi": "0.979048864669202",
      "hu": "0.980659359798633"
    },
    "canonical_solution": "{\n    let a: number[][] = Array.from({ length: n + 1 }, () => Array(2).fill(0));\n    a[1][0] = a[1][1] = 1;\n    \n    for (let i = 2; i <= n; i++) {\n        a[i][0] = a[i - 1][1] + a[i - 1][0];\n        a[i][1] = a[i - 1][0];\n    }\n    \n    return a[n][0] + a[n][1];\n}",
    "instruction": {
      "en": "Write a TypeScript function `function countValidCoinTossSequences(n: number): number` to solve the following problem:\nCounts the number of valid coin toss sequences with no consecutive heads in n tosses.\n\n@param n - The number of coin tosses.\n@returns The count of valid sequences.\n\nExamples:\ncountValidCoinTossSequences(1) returns 2\ncountValidCoinTossSequences(2) returns 3\n",
      "sq": "Shkruani një funksion TypeScript `function countValidCoinTossSequences(n: number): number` për të zgjidhur problemin e mëposhtëm:\nNumëron numrin e sekuencave të vlefshme të hedhjeve të monedhës pa koka radhazi në n hedhje.\n\n@param n - Numri i hedhjeve të monedhës.\n@returns Numri i sekuencave të vlefshme.\n\nShembuj:\ncountValidCoinTossSequences(1) kthen 2\ncountValidCoinTossSequences(2) kthen 3",
      "hy": "Գրեք TypeScript ֆունկցիա `function countValidCoinTossSequences(n: number): number` հետևյալ խնդիրը լուծելու համար:\nՀաշվում է վավեր մետաղադրամի նետումների հաջորդականությունների քանակը, որտեղ n նետումների դեպքում չկա հաջորդական գլուխներ:\n\n@param n - Մետաղադրամի նետումների քանակը։\n@returns Վավեր հաջորդականությունների քանակը։\n\nՕրինակներ:\ncountValidCoinTossSequences(1) վերադարձնում է 2\ncountValidCoinTossSequences(2) վերադարձնում է 3",
      "bn": "TypeScript ফাংশন `function countValidCoinTossSequences(n: number): number` লিখুন নিম্নলিখিত সমস্যার সমাধানের জন্য:\nn বার টসের মধ্যে কোনো পরপর হেড না থাকার বৈধ কয়েন টস সিকোয়েন্সের সংখ্যা গণনা করে।\n\n@param n - কয়েন টসের সংখ্যা।\n@returns বৈধ সিকোয়েন্সের সংখ্যা।\n\nউদাহরণসমূহ:\ncountValidCoinTossSequences(1) 2 রিটার্ন করে\ncountValidCoinTossSequences(2) 3 রিটার্ন করে",
      "bg": "Напишете TypeScript функция `function countValidCoinTossSequences(n: number): number`, за да решите следния проблем:\nБрои броя на валидните последователности от хвърляния на монета без последователни ези в n хвърляния.\n\n@param n - Броят на хвърлянията на монетата.\n@returns Броят на валидните последователности.\n\nПримери:\ncountValidCoinTossSequences(1) връща 2\ncountValidCoinTossSequences(2) връща 3",
      "zh": "编写一个 TypeScript 函数 `function countValidCoinTossSequences(n: number): number` 来解决以下问题：\n计算在 n 次投掷中没有连续正面的有效硬币投掷序列的数量。\n\n@param n - 投掷硬币的次数。\n@returns 有效序列的数量。\n\n示例：\ncountValidCoinTossSequences(1) 返回 2\ncountValidCoinTossSequences(2) 返回 3",
      "fr": "Écrire une fonction TypeScript `function countValidCoinTossSequences(n: number): number` pour résoudre le problème suivant :\nCompte le nombre de séquences de lancers de pièce valides sans têtes consécutives dans n lancers.\n\n@param n - Le nombre de lancers de pièce.\n@returns Le compte des séquences valides.\n\nExemples :\ncountValidCoinTossSequences(1) retourne 2\ncountValidCoinTossSequences(2) retourne 3",
      "de": "Schreiben Sie eine TypeScript-Funktion `function countValidCoinTossSequences(n: number): number`, um das folgende Problem zu lösen:\nZählt die Anzahl der gültigen Münzwurfsequenzen ohne aufeinanderfolgende Köpfe in n Würfen.\n\n@param n - Die Anzahl der Münzwürfe.\n@returns Die Anzahl der gültigen Sequenzen.\n\nBeispiele:\ncountValidCoinTossSequences(1) gibt 2 zurück\ncountValidCoinTossSequences(2) gibt 3 zurück",
      "ha": "Rubuta aikin TypeScript `function countValidCoinTossSequences(n: number): number` don warware matsalar mai zuwa:\nYana ƙidaya adadin sahihan jerin jefa tsabar kudi ba tare da kai biyu a jere ba a cikin jefa n.\n\n@param n - Yawan jefa tsabar kudi.\n@returns Adadin sahihan jerin.\n\nMisalai:\ncountValidCoinTossSequences(1) returns 2\ncountValidCoinTossSequences(2) returns 3",
      "hi": "TypeScript फ़ंक्शन `function countValidCoinTossSequences(n: number): number` लिखें ताकि निम्नलिखित समस्या का समाधान किया जा सके:\nn बार सिक्का उछालने पर बिना लगातार हेड्स के वैध सिक्का उछाल अनुक्रमों की संख्या गिनें।\n\n@param n - सिक्का उछालने की संख्या।\n@returns वैध अनुक्रमों की गिनती।\n\nउदाहरण:\ncountValidCoinTossSequences(1) returns 2\ncountValidCoinTossSequences(2) returns 3",
      "hu": "Írj egy TypeScript függvényt `function countValidCoinTossSequences(n: number): number` a következő probléma megoldására:\nMegszámolja az érvényes pénzfeldobási sorozatok számát, ahol n dobásban nincs egymást követő fej.\n\n@param n - A pénzfeldobások száma.\n@returns Az érvényes sorozatok száma.\n\nPéldák:\ncountValidCoinTossSequences(1) visszaadja 2\ncountValidCoinTossSequences(2) visszaadja 3"
    },
    "instruction_bertscore": {
      "sq": "0.9923932509278879",
      "hy": "0.980517140445812",
      "bn": "0.9575054135421581",
      "bg": "0.9923932509278879",
      "zh": "0.9684431941042252",
      "fr": "0.9911537973502302",
      "de": "0.9923932509278879",
      "ha": "0.9801276262686025",
      "hi": "0.9563630902208264",
      "hu": "0.9870453265489046"
    },
    "level": "easy",
    "test": "const testCountValidCoinTossSequences = (): void => {\n    console.assert(countValidCoinTossSequences(1) === 2);\n    console.assert(countValidCoinTossSequences(2) === 3);\n    console.assert(countValidCoinTossSequences(3) === 5);\n    console.assert(countValidCoinTossSequences(4) === 8); // Additional test\n    console.assert(countValidCoinTossSequences(5) === 13); // Additional test\n    // Feel free to add more tests here\n    console.assert(countValidCoinTossSequences(40) === 267914296); // Additional test\n    console.assert(countValidCoinTossSequences(39) === 165580141);\n    console.assert(countValidCoinTossSequences(38) === 102334155);\n    // Uncomment the next line to log a message on successful test pass\n    // console.log(\"All tests passed!\");\n};\n\ntestCountValidCoinTossSequences();",
    "entry_point": "countValidCoinTossSequences",
    "signature": "function countValidCoinTossSequences(n: number): number",
    "docstring": {
      "en": "Counts the number of valid coin toss sequences with no consecutive heads in n tosses.\n\n@param n - The number of coin tosses.\n@returns The count of valid sequences.\n\nExamples:\ncountValidCoinTossSequences(1) returns 2\ncountValidCoinTossSequences(2) returns 3\n",
      "sq": "Counts the number of valid coin toss sequences with no consecutive heads in n tosses.\n\n@param n - Numri i hedhjeve të monedhës.\n@returns Numri i sekuencave të vlefshme.\n\nShembuj:\ncountValidCoinTossSequences(1) returns 2\ncountValidCoinTossSequences(2) returns 3",
      "hy": "Հաշվում է n նետումների դեպքում առանց հաջորդական գցվածների վավեր մետաղադրամի նետումների հաջորդականությունների քանակը:\n\n@param n - Մետաղադրամի նետումների քանակը:\n@returns Վավեր հաջորդականությունների քանակը:\n\nՕրինակներ:\ncountValidCoinTossSequences(1) վերադարձնում է 2\ncountValidCoinTossSequences(2) վերադարձնում է 3",
      "bn": "Counts the number of valid coin toss sequences with no consecutive heads in n tosses.\n\n@param n - কয়েন টসের সংখ্যা।\n@returns বৈধ সিকোয়েন্সের সংখ্যা।\n\nউদাহরণ:\ncountValidCoinTossSequences(1) returns 2\ncountValidCoinTossSequences(2) returns 3",
      "bg": "Брои броя на валидните последователности на хвърляне на монета без последователни ези в n хвърляния.\n\n@param n - Броят на хвърлянията на монета.\n@returns Броят на валидните последователности.\n\nПримери:\ncountValidCoinTossSequences(1) връща 2\ncountValidCoinTossSequences(2) връща 3",
      "zh": "计算在 n 次投掷中没有连续正面的有效硬币投掷序列的数量。\n\n@param n - 硬币投掷的次数。\n@returns 有效序列的数量。\n\n示例：\ncountValidCoinTossSequences(1) 返回 2\ncountValidCoinTossSequences(2) 返回 3",
      "fr": "Compte le nombre de séquences de lancer de pièces valides sans faces consécutives dans n lancers.\n\n@param n - Le nombre de lancers de pièce.\n@returns Le compte des séquences valides.\n\nExemples :\ncountValidCoinTossSequences(1) returns 2\ncountValidCoinTossSequences(2) returns 3",
      "de": "Zählt die Anzahl der gültigen Münzwurfsequenzen ohne aufeinanderfolgende Köpfe in n Würfen.\n\n@param n - Die Anzahl der Münzwürfe.\n@returns Die Anzahl der gültigen Sequenzen.\n\nBeispiele:\ncountValidCoinTossSequences(1) returns 2\ncountValidCoinTossSequences(2) returns 3",
      "ha": "Counts the number of valid coin toss sequences with no consecutive heads in n tosses.\n\n@param n - Yawan jefa kudin.\n@returns Adadin sahihan jeri.\n\nMisalai:\ncountValidCoinTossSequences(1) returns 2\ncountValidCoinTossSequences(2) returns 3",
      "hi": "Counts the number of valid coin toss sequences with no consecutive heads in n tosses.\n\n@param n - सिक्के उछालने की संख्या।\n@returns वैध अनुक्रमों की गिनती।\n\nउदाहरण:\ncountValidCoinTossSequences(1) returns 2\ncountValidCoinTossSequences(2) returns 3",
      "hu": "Számolja meg az érvényes pénzérme dobássorozatok számát, amelyekben nincs egymást követő fej az n dobás során.\n\n@param n - A pénzérme dobások száma.\n@returns Az érvényes sorozatok száma.\n\nPéldák:\ncountValidCoinTossSequences(1) returns 2\ncountValidCoinTossSequences(2) returns 3"
    },
    "docstring_bertscore": {
      "sq": "0.9824146564758383",
      "hy": "0.9505364666235491",
      "bn": "0.9795821872422807",
      "bg": "0.9896134187453046",
      "zh": "0.9694007911711945",
      "fr": "0.9865388190772656",
      "de": "0.9896134187453046",
      "ha": "0.9824146564758383",
      "hi": "0.9799246260191848",
      "hu": "0.9742100299568112"
    }
  },
  {
    "task_id": "TypeScript/17",
    "prompt": {
      "en": "\n/**\n * Find the length of the longest consecutive sequence of 1s in the binary representation of a non-negative integer.\n *\n * Parameters:\n * - n (number): A non-negative integer (0 ≤ n ≤ 2^64 - 1).\n *\n * Returns:\n * - number: The length of the longest consecutive sequence of 1s in the binary representation of the given integer.\n *\n * Examples:\n * extraNumber(7) returns 3\n * extraNumber(13) returns 2\n * extraNumber(12345) returns 3\n * extraNumber(0b11011101111) returns 4\n * extraNumber(0xFFFFFFFF) returns 32\n * extraNumber(0) returns 0\n */\nfunction findLongestConsecutiveOnesLength(n: number): number",
      "sq": "/**\n * Gjeni gjatësinë e sekuencës më të gjatë të njëshave radhazi në përfaqësimin binar të një numri jo-negativ.\n *\n * Parametrat:\n * - n (numër): Një numër jo-negativ (0 ≤ n ≤ 2^64 - 1).\n *\n * Kthen:\n * - numër: Gjatësia e sekuencës më të gjatë të njëshave radhazi në përfaqësimin binar të numrit të dhënë.\n *\n * Shembuj:\n * extraNumber(7) kthen 3\n * extraNumber(13) kthen 2\n * extraNumber(12345) kthen 3\n * extraNumber(0b11011101111) kthen 4\n * extraNumber(0xFFFFFFFF) kthen 32\n * extraNumber(0) kthen 0\n */\nfunction findLongestConsecutiveOnesLength(n: number): number",
      "hy": "/**\n * Գտնել ամենաերկար հաջորդական 1-երի երկարությունը ոչ բացասական ամբողջ թվի բինար ներկայացման մեջ:\n *\n * Պարամետրեր:\n * - n (number): Ոչ բացասական ամբողջ թիվ (0 ≤ n ≤ 2^64 - 1):\n *\n * Վերադարձնում է:\n * - number: Տրված ամբողջ թվի բինար ներկայացման մեջ ամենաերկար հաջորդական 1-երի երկարությունը:\n *\n * Օրինակներ:\n * extraNumber(7) վերադարձնում է 3\n * extraNumber(13) վերադարձնում է 2\n * extraNumber(12345) վերադարձնում է 3\n * extraNumber(0b11011101111) վերադարձնում է 4\n * extraNumber(0xFFFFFFFF) վերադարձնում է 32\n * extraNumber(0) վերադարձնում է 0\n */\nfunction findLongestConsecutiveOnesLength(n: number): number",
      "bn": "/**\n * একটি অ-ঋণাত্মক পূর্ণসংখ্যার বাইনারি উপস্থাপনার মধ্যে 1-এর দীর্ঘতম ক্রমিক অনুক্রমের দৈর্ঘ্য খুঁজে বের করুন।\n *\n * প্যারামিটারসমূহ:\n * - n (number): একটি অ-ঋণাত্মক পূর্ণসংখ্যা (0 ≤ n ≤ 2^64 - 1)।\n *\n * রিটার্নস:\n * - number: প্রদত্ত পূর্ণসংখ্যার বাইনারি উপস্থাপনার মধ্যে 1-এর দীর্ঘতম ক্রমিক অনুক্রমের দৈর্ঘ্য।\n *\n * উদাহরণসমূহ:\n * extraNumber(7) returns 3\n * extraNumber(13) returns 2\n * extraNumber(12345) returns 3\n * extraNumber(0b11011101111) returns 4\n * extraNumber(0xFFFFFFFF) returns 32\n * extraNumber(0) returns 0\n */\nfunction findLongestConsecutiveOnesLength(n: number): number",
      "bg": "/**\n * Намерете дължината на най-дългата последователност от 1-ци в двоичното представяне на неотрицателно цяло число.\n *\n * Параметри:\n * - n (number): Неотрицателно цяло число (0 ≤ n ≤ 2^64 - 1).\n *\n * Връща:\n * - number: Дължината на най-дългата последователност от 1-ци в двоичното представяне на даденото цяло число.\n *\n * Примери:\n * extraNumber(7) връща 3\n * extraNumber(13) връща 2\n * extraNumber(12345) връща 3\n * extraNumber(0b11011101111) връща 4\n * extraNumber(0xFFFFFFFF) връща 32\n * extraNumber(0) връща 0\n */\nfunction findLongestConsecutiveOnesLength(n: number): number",
      "zh": "/**\n * 找到非负整数的二进制表示中最长连续1的序列的长度。\n *\n * 参数:\n * - n (number): 一个非负整数 (0 ≤ n ≤ 2^64 - 1)。\n *\n * 返回:\n * - number: 给定整数的二进制表示中最长连续1的序列的长度。\n *\n * 示例:\n * extraNumber(7) returns 3\n * extraNumber(13) returns 2\n * extraNumber(12345) returns 3\n * extraNumber(0b11011101111) returns 4\n * extraNumber(0xFFFFFFFF) returns 32\n * extraNumber(0) returns 0\n */\nfunction findLongestConsecutiveOnesLength(n: number): number",
      "fr": "/**\n * Trouver la longueur de la plus longue séquence consécutive de 1s dans la représentation binaire d'un entier non négatif.\n *\n * Paramètres:\n * - n (nombre): Un entier non négatif (0 ≤ n ≤ 2^64 - 1).\n *\n * Renvoie:\n * - nombre: La longueur de la plus longue séquence consécutive de 1s dans la représentation binaire de l'entier donné.\n *\n * Exemples:\n * extraNumber(7) returns 3\n * extraNumber(13) returns 2\n * extraNumber(12345) returns 3\n * extraNumber(0b11011101111) returns 4\n * extraNumber(0xFFFFFFFF) returns 32\n * extraNumber(0) returns 0\n */\nfunction findLongestConsecutiveOnesLength(n: number): number",
      "de": "/**\n * Finde die Länge der längsten aufeinanderfolgenden Sequenz von 1en in der binären Darstellung einer nicht-negativen ganzen Zahl.\n *\n * Parameter:\n * - n (number): Eine nicht-negative ganze Zahl (0 ≤ n ≤ 2^64 - 1).\n *\n * Rückgabewerte:\n * - number: Die Länge der längsten aufeinanderfolgenden Sequenz von 1en in der binären Darstellung der gegebenen ganzen Zahl.\n *\n * Beispiele:\n * extraNumber(7) returns 3\n * extraNumber(13) returns 2\n * extraNumber(12345) returns 3\n * extraNumber(0b11011101111) returns 4\n * extraNumber(0xFFFFFFFF) returns 32\n * extraNumber(0) returns 0\n */\nfunction findLongestConsecutiveOnesLength(n: number): number",
      "ha": "/**\n * Nemo tsawon jere mafi tsawo na 1s a cikin wakilcin binary na lamba mara kyau.\n *\n * Sigogi:\n * - n (lamba): Lamba mara kyau (0 ≤ n ≤ 2^64 - 1).\n *\n * Mayarwa:\n * - lamba: Tsawon jere mafi tsawo na 1s a cikin wakilcin binary na lambar da aka bayar.\n *\n * Misalai:\n * extraNumber(7) returns 3\n * extraNumber(13) returns 2\n * extraNumber(12345) returns 3\n * extraNumber(0b11011101111) returns 4\n * extraNumber(0xFFFFFFFF) returns 32\n * extraNumber(0) returns 0\n */\nfunction findLongestConsecutiveOnesLength(n: number): number",
      "hi": "/**\n * एक गैर-ऋणात्मक पूर्णांक के द्विआधारी प्रतिनिधित्व में लगातार 1s के सबसे लंबे अनुक्रम की लंबाई खोजें।\n *\n * पैरामीटर:\n * - n (संख्या): एक गैर-ऋणात्मक पूर्णांक (0 ≤ n ≤ 2^64 - 1)।\n *\n * रिटर्न करता है:\n * - संख्या: दिए गए पूर्णांक के द्विआधारी प्रतिनिधित्व में लगातार 1s के सबसे लंबे अनुक्रम की लंबाई।\n *\n * उदाहरण:\n * extraNumber(7) returns 3\n * extraNumber(13) returns 2\n * extraNumber(12345) returns 3\n * extraNumber(0b11011101111) returns 4\n * extraNumber(0xFFFFFFFF) returns 32\n * extraNumber(0) returns 0\n */\nfunction findLongestConsecutiveOnesLength(n: number): number",
      "hu": "/**\n * Határozza meg a leghosszabb egymást követő 1-es sorozat hosszát egy nem negatív egész szám bináris ábrázolásában.\n *\n * Paraméterek:\n * - n (szám): Egy nem negatív egész szám (0 ≤ n ≤ 2^64 - 1).\n *\n * Visszatér:\n * - szám: A leghosszabb egymást követő 1-es sorozat hossza a megadott egész szám bináris ábrázolásában.\n *\n * Példák:\n * extraNumber(7) visszaadja 3\n * extraNumber(13) visszaadja 2\n * extraNumber(12345) visszaadja 3\n * extraNumber(0b11011101111) visszaadja 4\n * extraNumber(0xFFFFFFFF) visszaadja 32\n * extraNumber(0) visszaadja 0\n */\nfunction findLongestConsecutiveOnesLength(n: number): number"
    },
    "prompt_bertscore": {
      "sq": "0.9741766600527972",
      "hy": "0.9890328221415396",
      "bn": "1",
      "bg": "0.9837415074211513",
      "zh": "0.9979123946953233",
      "fr": "1",
      "de": "0.9944693356704646",
      "ha": "0.9711433755040135",
      "hi": "0.9979123946953233",
      "hu": "0.9892872676596454"
    },
    "canonical_solution": "{\n    let max = 0;\n    let ans = 0;\n    while (n) {\n        if (n & 1) {\n            ans++;\n        } else {\n            if (ans > max) {\n                max = ans;\n            }\n            ans = 0;\n        }\n        n >>>= 1; // In TypeScript, >>> is used for unsigned right shift\n    }\n    if (ans > max) {\n        max = ans;\n    }\n    return max;\n}",
    "instruction": {
      "en": "Write a TypeScript function `function findLongestConsecutiveOnesLength(n: number): number` to solve the following problem:\nFind the length of the longest consecutive sequence of 1s in the binary representation of a non-negative integer.\n\nParameters:\n- n (number): A non-negative integer (0 ≤ n ≤ 2^64 - 1).\n\nReturns:\n- number: The length of the longest consecutive sequence of 1s in the binary representation of the given integer.\n\nExamples:\nextraNumber(7) returns 3\nextraNumber(13) returns 2\nextraNumber(12345) returns 3\nextraNumber(0b11011101111) returns 4\nextraNumber(0xFFFFFFFF) returns 32\nextraNumber(0) returns 0\n",
      "sq": "Shkruani një funksion TypeScript `function findLongestConsecutiveOnesLength(n: number): number` për të zgjidhur problemin e mëposhtëm:  \nGjeni gjatësinë e sekuencës më të gjatë të njëshave radhazi në përfaqësimin binar të një numri të plotë jo-negativ.\n\nParametrat:\n- n (numër): Një numër i plotë jo-negativ (0 ≤ n ≤ 2^64 - 1).\n\nKthen:\n- numër: Gjatësia e sekuencës më të gjatë të njëshave radhazi në përfaqësimin binar të numrit të dhënë.\n\nShembuj:\nextraNumber(7) kthen 3\nextraNumber(13) kthen 2\nextraNumber(12345) kthen 3\nextraNumber(0b11011101111) kthen 4\nextraNumber(0xFFFFFFFF) kthen 32\nextraNumber(0) kthen 0",
      "hy": "Գրեք TypeScript ֆունկցիա `function findLongestConsecutiveOnesLength(n: number): number` հետևյալ խնդիրը լուծելու համար:\nԳտեք 1-երի ամենաերկար հաջորդականության երկարությունը ոչ բացասական ամբողջ թվի բինար ներկայացման մեջ:\n\nՊարամետրեր:\n- n (number): Ոչ բացասական ամբողջ թիվ (0 ≤ n ≤ 2^64 - 1):\n\nՎերադարձնում է:\n- number: Տրված ամբողջ թվի բինար ներկայացման մեջ 1-երի ամենաերկար հաջորդականության երկարությունը:\n\nՕրինակներ:\nextraNumber(7) վերադարձնում է 3\nextraNumber(13) վերադարձնում է 2\nextraNumber(12345) վերադարձնում է 3\nextraNumber(0b11011101111) վերադարձնում է 4\nextraNumber(0xFFFFFFFF) վերադարձնում է 32\nextraNumber(0) վերադարձնում է 0",
      "bn": "একটি TypeScript ফাংশন `function findLongestConsecutiveOnesLength(n: number): number` লিখুন নিম্নলিখিত সমস্যাটি সমাধান করতে:\nএকটি অ-ঋণাত্মক পূর্ণসংখ্যার বাইনারি উপস্থাপনার মধ্যে 1 এর দীর্ঘতম ক্রমাগত ক্রমের দৈর্ঘ্য খুঁজুন।\n\nপ্যারামিটারসমূহ:\n- n (number): একটি অ-ঋণাত্মক পূর্ণসংখ্যা (0 ≤ n ≤ 2^64 - 1)।\n\nফেরত দিবে:\n- number: প্রদত্ত পূর্ণসংখ্যার বাইনারি উপস্থাপনার মধ্যে 1 এর দীর্ঘতম ক্রমাগত ক্রমের দৈর্ঘ্য।\n\nউদাহরণসমূহ:\nextraNumber(7) returns 3\nextraNumber(13) returns 2\nextraNumber(12345) returns 3\nextraNumber(0b11011101111) returns 4\nextraNumber(0xFFFFFFFF) returns 32\nextraNumber(0) returns 0",
      "bg": "Напишете TypeScript функция `function findLongestConsecutiveOnesLength(n: number): number`, за да решите следния проблем:\nНамерете дължината на най-дългата последователност от 1-ци в двоичното представяне на неотрицателно цяло число.\n\nПараметри:\n- n (number): Неотрицателно цяло число (0 ≤ n ≤ 2^64 - 1).\n\nВръща:\n- number: Дължината на най-дългата последователност от 1-ци в двоичното представяне на даденото число.\n\nПримери:\nextraNumber(7) връща 3\nextraNumber(13) връща 2\nextraNumber(12345) връща 3\nextraNumber(0b11011101111) връща 4\nextraNumber(0xFFFFFFFF) връща 32\nextraNumber(0) връща 0",
      "zh": "编写一个 TypeScript 函数 `function findLongestConsecutiveOnesLength(n: number): number` 来解决以下问题：\n找到非负整数的二进制表示中最长连续 1 序列的长度。\n\n参数：\n- n (number): 一个非负整数 (0 ≤ n ≤ 2^64 - 1)。\n\n返回：\n- number: 给定整数的二进制表示中最长连续 1 序列的长度。\n\n示例：\nextraNumber(7) 返回 3\nextraNumber(13) 返回 2\nextraNumber(12345) 返回 3\nextraNumber(0b11011101111) 返回 4\nextraNumber(0xFFFFFFFF) 返回 32\nextraNumber(0) 返回 0",
      "fr": "Écrire une fonction TypeScript `function findLongestConsecutiveOnesLength(n: number): number` pour résoudre le problème suivant :  \nTrouver la longueur de la plus longue séquence consécutive de 1 dans la représentation binaire d'un entier non négatif.\n\nParamètres :\n- n (number) : Un entier non négatif (0 ≤ n ≤ 2^64 - 1).\n\nRenvoie :\n- number : La longueur de la plus longue séquence consécutive de 1 dans la représentation binaire de l'entier donné.\n\nExemples :\nextraNumber(7) returns 3  \nextraNumber(13) returns 2  \nextraNumber(12345) returns 3  \nextraNumber(0b11011101111) returns 4  \nextraNumber(0xFFFFFFFF) returns 32  \nextraNumber(0) returns 0  ",
      "de": "Schreiben Sie eine TypeScript-Funktion `function findLongestConsecutiveOnesLength(n: number): number`, um das folgende Problem zu lösen:\nFinden Sie die Länge der längsten aufeinanderfolgenden Sequenz von 1en in der Binärdarstellung einer nicht-negativen ganzen Zahl.\n\nParameter:\n- n (number): Eine nicht-negative ganze Zahl (0 ≤ n ≤ 2^64 - 1).\n\nRückgabewert:\n- number: Die Länge der längsten aufeinanderfolgenden Sequenz von 1en in der Binärdarstellung der gegebenen Zahl.\n\nBeispiele:\nextraNumber(7) gibt 3 zurück\nextraNumber(13) gibt 2 zurück\nextraNumber(12345) gibt 3 zurück\nextraNumber(0b11011101111) gibt 4 zurück\nextraNumber(0xFFFFFFFF) gibt 32 zurück\nextraNumber(0) gibt 0 zurück",
      "ha": "Rubuta aikin TypeScript `function findLongestConsecutiveOnesLength(n: number): number` don warware matsalar mai zuwa:\nNemo tsawon jere mafi tsawo na 1s a cikin wakilcin binary na lamba mara kyau.\n\nSigogi:\n- n (number): Lamba mara kyau (0 ≤ n ≤ 2^64 - 1).\n\nDawowa:\n- number: Tsawon jere mafi tsawo na 1s a cikin wakilcin binary na lambar da aka bayar.\n\nMisalai:\nextraNumber(7) returns 3\nextraNumber(13) returns 2\nextraNumber(12345) returns 3\nextraNumber(0b11011101111) returns 4\nextraNumber(0xFFFFFFFF) returns 32\nextraNumber(0) returns 0",
      "hi": "TypeScript फ़ंक्शन `function findLongestConsecutiveOnesLength(n: number): number` लिखें ताकि निम्नलिखित समस्या का समाधान किया जा सके:\nएक गैर-ऋणात्मक पूर्णांक के बाइनरी प्रतिनिधित्व में 1s के सबसे लंबे अनुक्रम की लंबाई खोजें।\n\nपैरामीटर्स:\n- n (number): एक गैर-ऋणात्मक पूर्णांक (0 ≤ n ≤ 2^64 - 1)।\n\nवापसी मान:\n- number: दिए गए पूर्णांक के बाइनरी प्रतिनिधित्व में 1s के सबसे लंबे अनुक्रम की लंबाई।\n\nउदाहरण:\nextraNumber(7) returns 3\nextraNumber(13) returns 2\nextraNumber(12345) returns 3\nextraNumber(0b11011101111) returns 4\nextraNumber(0xFFFFFFFF) returns 32\nextraNumber(0) returns 0",
      "hu": "Írj egy TypeScript függvényt `function findLongestConsecutiveOnesLength(n: number): number` a következő probléma megoldására:\nTaláld meg a leghosszabb egymást követő 1-esek sorozatának hosszát egy nem negatív egész szám bináris ábrázolásában.\n\nParaméterek:\n- n (number): Egy nem negatív egész szám (0 ≤ n ≤ 2^64 - 1).\n\nVisszatérési érték:\n- number: A leghosszabb egymást követő 1-esek sorozatának hossza a megadott egész szám bináris ábrázolásában.\n\nPéldák:\nextraNumber(7) visszaadja 3\nextraNumber(13) visszaadja 2\nextraNumber(12345) visszaadja 3\nextraNumber(0b11011101111) visszaadja 4\nextraNumber(0xFFFFFFFF) visszaadja 32\nextraNumber(0) visszaadja 0"
    },
    "instruction_bertscore": {
      "sq": "0.9782046855498038",
      "hy": "0.9808216408199384",
      "bn": "1",
      "bg": "0.9822571425836776",
      "zh": "1",
      "fr": "1",
      "de": "0.9913655373364134",
      "ha": "0.9814274634820949",
      "hi": "0.9733765768779887",
      "hu": "0.994335458793647"
    },
    "level": "middle",
    "test": "const testFindLongestConsecutiveOnesLength = (): void => {\n    console.assert(findLongestConsecutiveOnesLength(7) === 3, \"Failed on input 7\");\n    console.assert(findLongestConsecutiveOnesLength(13) === 2, \"Failed on input 13\");\n    console.assert(findLongestConsecutiveOnesLength(12345) === 3, \"Failed on input 12345\");\n    console.assert(findLongestConsecutiveOnesLength(0b11011101111) === 4, \"Failed on input 0b11011101111\");\n    console.assert(findLongestConsecutiveOnesLength(0xFFFFFFFF) === 32, \"Failed on input 0xFFFFFFFF\");\n    console.assert(findLongestConsecutiveOnesLength(0) === 0, \"Failed on input 0\");\n\n    // console.log(\"All tests passed!\");\n};\n\ntestFindLongestConsecutiveOnesLength();",
    "entry_point": "findLongestConsecutiveOnesLength",
    "signature": "function findLongestConsecutiveOnesLength(n: number): number",
    "docstring": {
      "en": "Find the length of the longest consecutive sequence of 1s in the binary representation of a non-negative integer.\n\nParameters:\n- n (number): A non-negative integer (0 ≤ n ≤ 2^64 - 1).\n\nReturns:\n- number: The length of the longest consecutive sequence of 1s in the binary representation of the given integer.\n\nExamples:\nextraNumber(7) returns 3\nextraNumber(13) returns 2\nextraNumber(12345) returns 3\nextraNumber(0b11011101111) returns 4\nextraNumber(0xFFFFFFFF) returns 32\nextraNumber(0) returns 0\n",
      "sq": "Gjeni gjatësinë e sekuencës më të gjatë të njëshave të njëpasnjëshme në përfaqësimin binar të një numri të plotë jo-negativ.\n\nParametrat:\n- n (numër): Një numër i plotë jo-negativ (0 ≤ n ≤ 2^64 - 1).\n\nKthen:\n- numër: Gjatësia e sekuencës më të gjatë të njëshave të njëpasnjëshme në përfaqësimin binar të numrit të dhënë.\n\nShembuj:\nextraNumber(7) kthen 3\nextraNumber(13) kthen 2\nextraNumber(12345) kthen 3\nextraNumber(0b11011101111) kthen 4\nextraNumber(0xFFFFFFFF) kthen 32\nextraNumber(0) kthen 0",
      "hy": "Գտնել ամենաերկար հաջորդական 1-երի երկարությունը ոչ բացասական ամբողջ թվի բինար ներկայացման մեջ:\n\nՊարամետրեր:\n- n (number): Ոչ բացասական ամբողջ թիվ (0 ≤ n ≤ 2^64 - 1):\n\nՎերադարձնում է:\n- number: Տրված ամբողջ թվի բինար ներկայացման մեջ ամենաերկար հաջորդական 1-երի երկարությունը:\n\nՕրինակներ:\nextraNumber(7) վերադարձնում է 3\nextraNumber(13) վերադարձնում է 2\nextraNumber(12345) վերադարձնում է 3\nextraNumber(0b11011101111) վերադարձնում է 4\nextraNumber(0xFFFFFFFF) վերադարձնում է 32\nextraNumber(0) վերադարձնում է 0",
      "bn": "Find the length of the longest consecutive sequence of 1s in the binary representation of a non-negative integer.\n\nপ্যারামিটারসমূহ:\n- n (number): একটি অ-ঋণাত্মক পূর্ণসংখ্যা (0 ≤ n ≤ 2^64 - 1)।\n\nরিটার্নস:\n- number: প্রদত্ত পূর্ণসংখ্যার বাইনারি উপস্থাপনার মধ্যে 1s এর দীর্ঘতম ধারাবাহিক অনুক্রমের দৈর্ঘ্য।\n\nউদাহরণসমূহ:\nextraNumber(7) returns 3\nextraNumber(13) returns 2\nextraNumber(12345) returns 3\nextraNumber(0b11011101111) returns 4\nextraNumber(0xFFFFFFFF) returns 32\nextraNumber(0) returns 0",
      "bg": "Намерете дължината на най-дългата последователност от 1-ци в двоичното представяне на неотрицателно цяло число.\n\nПараметри:\n- n (number): Неотрицателно цяло число (0 ≤ n ≤ 2^64 - 1).\n\nВръща:\n- number: Дължината на най-дългата последователност от 1-ци в двоичното представяне на даденото цяло число.\n\nПримери:\nextraNumber(7) връща 3\nextraNumber(13) връща 2\nextraNumber(12345) връща 3\nextraNumber(0b11011101111) връща 4\nextraNumber(0xFFFFFFFF) връща 32\nextraNumber(0) връща 0",
      "zh": "找到非负整数的二进制表示中最长连续1序列的长度。\n\n参数:\n- n (number): 一个非负整数 (0 ≤ n ≤ 2^64 - 1)。\n\n返回:\n- number: 给定整数的二进制表示中最长连续1序列的长度。\n\n示例:\nextraNumber(7) 返回 3\nextraNumber(13) 返回 2\nextraNumber(12345) 返回 3\nextraNumber(0b11011101111) 返回 4\nextraNumber(0xFFFFFFFF) 返回 32\nextraNumber(0) 返回 0",
      "fr": "Trouver la longueur de la plus longue séquence consécutive de 1 dans la représentation binaire d'un entier non négatif.\n\nParamètres :\n- n (number): Un entier non négatif (0 ≤ n ≤ 2^64 - 1).\n\nRenvoie :\n- number: La longueur de la plus longue séquence consécutive de 1 dans la représentation binaire de l'entier donné.\n\nExemples :\nextraNumber(7) renvoie 3\nextraNumber(13) renvoie 2\nextraNumber(12345) renvoie 3\nextraNumber(0b11011101111) renvoie 4\nextraNumber(0xFFFFFFFF) renvoie 32\nextraNumber(0) renvoie 0",
      "de": "Finde die Länge der längsten aufeinanderfolgenden Sequenz von 1en in der Binärdarstellung einer nicht-negativen ganzen Zahl.\n\nParameter:\n- n (number): Eine nicht-negative ganze Zahl (0 ≤ n ≤ 2^64 - 1).\n\nRückgabewert:\n- number: Die Länge der längsten aufeinanderfolgenden Sequenz von 1en in der Binärdarstellung der gegebenen ganzen Zahl.\n\nBeispiele:\nextraNumber(7) gibt 3 zurück\nextraNumber(13) gibt 2 zurück\nextraNumber(12345) gibt 3 zurück\nextraNumber(0b11011101111) gibt 4 zurück\nextraNumber(0xFFFFFFFF) gibt 32 zurück\nextraNumber(0) gibt 0 zurück",
      "ha": "Find the length of the longest consecutive sequence of 1s in the binary representation of a non-negative integer.\n\nSigogi:\n- n (number): Wani lamba mara kyau (0 ≤ n ≤ 2^64 - 1).\n\nDawowa:\n- number: Tsawon mafi tsawo jere na 1s a cikin wakilcin binary na lambar da aka bayar.\n\nMisalai:\nextraNumber(7) returns 3\nextraNumber(13) returns 2\nextraNumber(12345) returns 3\nextraNumber(0b11011101111) returns 4\nextraNumber(0xFFFFFFFF) returns 32\nextraNumber(0) returns 0",
      "hi": "Find the length of the longest consecutive sequence of 1s in the binary representation of a non-negative integer.\n\nपैरामीटर्स:\n- n (number): एक गैर-ऋणात्मक पूर्णांक (0 ≤ n ≤ 2^64 - 1)।\n\nवापसी:\n- number: दिए गए पूर्णांक के बाइनरी प्रतिनिधित्व में 1s के सबसे लंबे अनुक्रम की लंबाई।\n\nउदाहरण:\nextraNumber(7) returns 3\nextraNumber(13) returns 2\nextraNumber(12345) returns 3\nextraNumber(0b11011101111) returns 4\nextraNumber(0xFFFFFFFF) returns 32\nextraNumber(0) returns 0",
      "hu": "Find the length of the longest consecutive sequence of 1s in the binary representation of a non-negative integer.\n\nParaméterek:\n- n (number): Egy nemnegatív egész szám (0 ≤ n ≤ 2^64 - 1).\n\nVisszatérési érték:\n- number: A leghosszabb egymást követő 1-es sorozat hossza a megadott egész szám bináris ábrázolásában.\n\nPéldák:\nextraNumber(7) visszaadja 3\nextraNumber(13) visszaadja 2\nextraNumber(12345) visszaadja 3\nextraNumber(0b11011101111) visszaadja 4\nextraNumber(0xFFFFFFFF) visszaadja 32\nextraNumber(0) visszaadja 0"
    },
    "docstring_bertscore": {
      "sq": "0.9730085147819311",
      "hy": "0.9869843470219268",
      "bn": "1",
      "bg": "0.9815271759333744",
      "zh": "0.9976907231900883",
      "fr": "1",
      "de": "0.9846875839260205",
      "ha": "0.9919884422113389",
      "hi": "0.9942393216892261",
      "hu": "0.994090150273069"
    }
  },
  {
    "task_id": "TypeScript/18",
    "prompt": {
      "en": "\n/**\n * Creates an ID by combining two words in a specific manner.\n * Parameters:\n * - word1 (string): The first word to be used in the ID.\n * - word2 (string): The second word to be used in the ID.\n * Returns:\n *  string: A unique ID formed by reversing every other character of the second\n *          word and combining it with the first word.\n * e.g.:\n *      createId('fish', 'cat')  // returns 'ftiasch'\n */\nfunction createId(word1: string, word2: string): string",
      "sq": "/**\n * Krijon një ID duke kombinuar dy fjalë në një mënyrë specifike.\n * Parametrat:\n * - word1 (string): Fjala e parë që do të përdoret në ID.\n * - word2 (string): Fjala e dytë që do të përdoret në ID.\n * Kthen:\n *  string: Një ID unike e formuar duke kthyer mbrapsht çdo karakter të dytë të \n *          fjalës së dytë dhe duke e kombinuar atë me fjalën e parë.\n * p.sh.:\n *      createId('fish', 'cat')  // kthen 'ftiasch'\n */\nfunction createId(word1: string, word2: string): string",
      "hy": "/**\n * Ստեղծում է ID երկու բառերի համադրությամբ հատուկ ձևով։\n * Պարամետրեր:\n * - word1 (string): Առաջին բառը, որը կօգտագործվի ID-ում։\n * - word2 (string): Երկրորդ բառը, որը կօգտագործվի ID-ում։\n * Վերադարձնում է:\n *  string: Ունիկալ ID, որը կազմված է երկրորդ բառի յուրաքանչյուր երկրորդ\n *          նիշը շրջելով և առաջին բառի հետ համադրելով։\n * օրինակ:\n *      createId('fish', 'cat')  // վերադարձնում է 'ftiasch'\n */\nfunction createId(word1: string, word2: string): string",
      "bn": "/**\n * একটি আইডি তৈরি করে দুটি শব্দকে একটি নির্দিষ্ট পদ্ধতিতে সংযুক্ত করে।\n * প্যারামিটার:\n * - word1 (string): প্রথম শব্দ যা আইডিতে ব্যবহৃত হবে।\n * - word2 (string): দ্বিতীয় শব্দ যা আইডিতে ব্যবহৃত হবে।\n * রিটার্নস:\n *  string: দ্বিতীয় শব্দের প্রতিটি বিকল্প অক্ষর উল্টিয়ে প্রথম শব্দের সাথে সংযুক্ত করে একটি অনন্য আইডি তৈরি করে।\n * উদাহরণ:\n *      createId('fish', 'cat')  // 'ftiasch' রিটার্ন করে\n */\nfunction createId(word1: string, word2: string): string",
      "bg": "/**\n * Създава ID, като комбинира две думи по специфичен начин.\n * Параметри:\n * - word1 (string): Първата дума, която ще се използва в ID.\n * - word2 (string): Втората дума, която ще се използва в ID.\n * Връща:\n *  string: Уникално ID, образувано чрез обръщане на всеки втори символ от втората\n *          дума и комбинирането му с първата дума.\n * напр.:\n *      createId('fish', 'cat')  // връща 'ftiasch'\n */\nfunction createId(word1: string, word2: string): string",
      "zh": "/**\n * 通过特定方式组合两个单词来创建一个ID。\n * 参数：\n * - word1 (string): 用于ID的第一个单词。\n * - word2 (string): 用于ID的第二个单词。\n * 返回：\n *  string: 一个唯一的ID，通过反转第二个单词的每隔一个字符并将其与第一个单词组合而成。\n * 例如：\n *      createId('fish', 'cat')  // 返回 'ftiasch'\n */\nfunction createId(word1: string, word2: string): string",
      "fr": "/**\n * Crée un ID en combinant deux mots d'une manière spécifique.\n * Paramètres:\n * - word1 (string): Le premier mot à utiliser dans l'ID.\n * - word2 (string): Le deuxième mot à utiliser dans l'ID.\n * Retourne:\n *  string: Un ID unique formé en inversant chaque autre caractère du deuxième\n *          mot et en le combinant avec le premier mot.\n * e.g.:\n *      createId('fish', 'cat')  // returns 'ftiasch'\n */\nfunction createId(word1: string, word2: string): string",
      "de": "/**\n * Erstellt eine ID, indem zwei Wörter auf eine bestimmte Weise kombiniert werden.\n * Parameter:\n * - word1 (string): Das erste Wort, das in der ID verwendet werden soll.\n * - word2 (string): Das zweite Wort, das in der ID verwendet werden soll.\n * Rückgabe:\n *  string: Eine eindeutige ID, die durch das Umkehren jedes zweiten Zeichens des zweiten\n *          Wortes und die Kombination mit dem ersten Wort gebildet wird.\n * z.B.:\n *      createId('fish', 'cat')  // gibt 'ftiasch' zurück\n */\nfunction createId(word1: string, word2: string): string",
      "ha": "/**\n * Yana ƙirƙirar ID ta hanyar haɗa kalmomi biyu a wata hanya ta musamman.\n * Sigogi:\n * - word1 (string): Kalma ta farko da za a yi amfani da ita a ID.\n * - word2 (string): Kalma ta biyu da za a yi amfani da ita a ID.\n * Yana dawowa:\n *  string: Wani ID na musamman da aka samar ta hanyar juyar da kowane harafi na biyu na kalma ta biyu\n *          da haɗa shi da kalma ta farko.\n * e.g.:\n *      createId('fish', 'cat')  // returns 'ftiasch'\n */\nfunction createId(word1: string, word2: string): string",
      "hi": "/**\n * दो शब्दों को एक विशेष तरीके से मिलाकर एक आईडी बनाता है।\n * पैरामीटर्स:\n * - word1 (string): आईडी में उपयोग के लिए पहला शब्द।\n * - word2 (string): आईडी में उपयोग के लिए दूसरा शब्द।\n * रिटर्न करता है:\n *  string: दूसरे शब्द के हर दूसरे अक्षर को उलटकर और पहले शब्द के साथ मिलाकर एक अद्वितीय आईडी बनाता है।\n * उदाहरण:\n *      createId('fish', 'cat')  // 'ftiasch' रिटर्न करता है\n */\nfunction createId(word1: string, word2: string): string",
      "hu": "/**\n * Létrehoz egy azonosítót két szó specifikus módon történő kombinálásával.\n * Paraméterek:\n * - word1 (string): Az első szó, amelyet az azonosítóban használunk.\n * - word2 (string): A második szó, amelyet az azonosítóban használunk.\n * Visszatér:\n *  string: Egy egyedi azonosító, amelyet a második szó minden második karakterének\n *          megfordításával és az első szóval való kombinálásával hozunk létre.\n * pl.:\n *      createId('fish', 'cat')  // visszaadja 'ftiasch'\n */\nfunction createId(word1: string, word2: string): string"
    },
    "prompt_bertscore": {
      "sq": "0.9917242638045625",
      "hy": "0.9765141423768159",
      "bn": "0.9741689134679369",
      "bg": "0.9936952730755716",
      "zh": "0.9565990631134959",
      "fr": "0.9891416715903468",
      "de": "0.9936952730755716",
      "ha": "0.9792463032679507",
      "hi": "0.9486244505757072",
      "hu": "0.9571327829473366"
    },
    "canonical_solution": "{\n    let result: string[] = [];\n    let j: number = 0;\n    let k: number = word2.length - 1;\n\n    for (let i = 0; i < word1.length + word2.length; i++) {\n        if (i % 2 === 0) {\n            // Take character from word1\n            result.push(word1[j++]);\n        } else {\n            // Take character from word2 in reverse\n            result.push(word2[k--]);\n        }\n    }\n    return result.join('');\n}",
    "instruction": {
      "en": "Write a TypeScript function `function createId(word1: string, word2: string): string` to solve the following problem:\nCreates an ID by combining two words in a specific manner.\nParameters:\n- word1 (string): The first word to be used in the ID.\n- word2 (string): The second word to be used in the ID.\nReturns:\n string: A unique ID formed by reversing every other character of the second\n         word and combining it with the first word.\ne.g.:\n     createId('fish', 'cat')  // returns 'ftiasch'\n",
      "sq": "Shkruani një funksion TypeScript `function createId(word1: string, word2: string): string` për të zgjidhur problemin e mëposhtëm:\nKrijon një ID duke kombinuar dy fjalë në një mënyrë specifike.\nParametrat:\n- word1 (string): Fjala e parë që do të përdoret në ID.\n- word2 (string): Fjala e dytë që do të përdoret në ID.\nKthen:\n string: Një ID unike e formuar duke përmbysur çdo karakter tjetër të fjalës së dytë dhe duke e kombinuar atë me fjalën e parë.\np.sh.:\n     createId('fish', 'cat')  // kthen 'ftiasch'",
      "hy": "Գրեք TypeScript ֆունկցիա `function createId(word1: string, word2: string): string` հետևյալ խնդիրը լուծելու համար:\nՍտեղծում է ID՝ երկու բառերը հատուկ ձևով համադրելով:\nՊարամետրեր:\n- word1 (string): Առաջին բառը, որը կօգտագործվի ID-ում:\n- word2 (string): Երկրորդ բառը, որը կօգտագործվի ID-ում:\nՎերադարձնում է:\n string: Ունիկալ ID, որը ձևավորվում է երկրորդ բառի ամեն երկրորդ սիմվոլը շրջելով և այն առաջին բառի հետ համադրելով:\nօրինակ:\n     createId('fish', 'cat')  // վերադարձնում է 'ftiasch'",
      "bn": "TypeScript ফাংশন `function createId(word1: string, word2: string): string` লিখুন নিম্নলিখিত সমস্যার সমাধানের জন্য:\nদুটি শব্দকে একটি নির্দিষ্ট পদ্ধতিতে সংযুক্ত করে একটি আইডি তৈরি করে।\nপ্যারামিটারসমূহ:\n- word1 (string): আইডিতে ব্যবহৃত প্রথম শব্দ।\n- word2 (string): আইডিতে ব্যবহৃত দ্বিতীয় শব্দ।\nরিটার্ন করে:\n string: দ্বিতীয় শব্দের প্রতিটি বিকল্প অক্ষর উল্টিয়ে এবং প্রথম শব্দের সাথে সংযুক্ত করে একটি অনন্য আইডি তৈরি করে।\nউদাহরণ:\n     createId('fish', 'cat')  // রিটার্ন করে 'ftiasch'",
      "bg": "Напишете функция на TypeScript `function createId(word1: string, word2: string): string`, за да решите следния проблем:\nСъздава ID, като комбинира две думи по специфичен начин.\nПараметри:\n- word1 (string): Първата дума, която ще бъде използвана в ID.\n- word2 (string): Втората дума, която ще бъде използвана в ID.\nВръща:\n string: Уникално ID, образувано чрез обръщане на всеки втори символ на втората\n         дума и комбинирането му с първата дума.\nнапр.:\n     createId('fish', 'cat')  // връща 'ftiasch'",
      "zh": "编写一个 TypeScript 函数 `function createId(word1: string, word2: string): string` 来解决以下问题：\n通过以特定方式组合两个单词来创建一个 ID。\n参数：\n- word1 (string): 用于 ID 的第一个单词。\n- word2 (string): 用于 ID 的第二个单词。\n返回：\n string: 一个唯一的 ID，通过反转第二个单词的每隔一个字符并将其与第一个单词组合而成。\n例如：\n     createId('fish', 'cat')  // 返回 'ftiasch'",
      "fr": "Écrire une fonction TypeScript `function createId(word1: string, word2: string): string` pour résoudre le problème suivant :\nCrée un identifiant en combinant deux mots d'une manière spécifique.\nParamètres :\n- word1 (string) : Le premier mot à utiliser dans l'identifiant.\n- word2 (string) : Le deuxième mot à utiliser dans l'identifiant.\nRenvoie :\n string : Un identifiant unique formé en inversant chaque autre caractère du deuxième\n          mot et en le combinant avec le premier mot.\ne.g.:\n     createId('fish', 'cat')  // returns 'ftiasch'",
      "de": "Schreiben Sie eine TypeScript-Funktion `function createId(word1: string, word2: string): string`, um das folgende Problem zu lösen:\nErstellt eine ID, indem zwei Wörter auf eine bestimmte Weise kombiniert werden.\nParameter:\n- word1 (string): Das erste Wort, das in der ID verwendet werden soll.\n- word2 (string): Das zweite Wort, das in der ID verwendet werden soll.\nRückgabewert:\n string: Eine eindeutige ID, die gebildet wird, indem jeder zweite Buchstabe des zweiten\n         Wortes umgekehrt und mit dem ersten Wort kombiniert wird.\nz.B.:\n     createId('fish', 'cat')  // gibt 'ftiasch' zurück",
      "ha": "Rubuta aikin TypeScript `function createId(word1: string, word2: string): string` don warware matsalar mai zuwa:\nYana ƙirƙirar ID ta hanyar haɗa kalmomi biyu ta wata hanya ta musamman.\nSigogi:\n- word1 (string): Kalma ta farko da za a yi amfani da ita a cikin ID.\n- word2 (string): Kalma ta biyu da za a yi amfani da ita a cikin ID.\nYana dawowa:\n string: Wani ID na musamman da aka samar ta hanyar juyar da kowace harafi ta biyu na kalma ta biyu\n         da haɗa shi da kalma ta farko.\ne.g.:\n     createId('fish', 'cat')  // returns 'ftiasch'",
      "hi": "TypeScript फ़ंक्शन `function createId(word1: string, word2: string): string` लिखें ताकि निम्नलिखित समस्या का समाधान हो सके:\nदो शब्दों को एक विशिष्ट तरीके से मिलाकर एक ID बनाता है।\nपैरामीटर्स:\n- word1 (string): ID में उपयोग के लिए पहला शब्द।\n- word2 (string): ID में उपयोग के लिए दूसरा शब्द।\nवापसी:\n string: एक अद्वितीय ID जो दूसरे शब्द के हर दूसरे अक्षर को उलट कर और पहले शब्द के साथ मिलाकर बनाई जाती है।\nउदाहरण:\n     createId('fish', 'cat')  // returns 'ftiasch'",
      "hu": "Készíts egy TypeScript függvényt `function createId(word1: string, word2: string): string` a következő probléma megoldására:\nLétrehoz egy azonosítót két szó egyedi módon történő kombinálásával.\nParaméterek:\n- word1 (string): Az első szó, amelyet az azonosítóban használunk.\n- word2 (string): A második szó, amelyet az azonosítóban használunk.\nVisszatérési érték:\n string: Egy egyedi azonosító, amelyet a második szó minden második karakterének megfordításával és az első szóval való kombinálásával hozunk létre.\npl.:\n     createId('fish', 'cat')  // returns 'ftiasch'"
    },
    "instruction_bertscore": {
      "sq": "0.9985988612921799",
      "hy": "0.981342846939774",
      "bn": "0.9410542494937055",
      "bg": "0.990571611703417",
      "zh": "0.9618500558665342",
      "fr": "0.9710627315693133",
      "de": "0.982527081271504",
      "ha": "0.9771545267252724",
      "hi": "0.9620657684603381",
      "hu": "0.9436886842373713"
    },
    "level": "middle",
    "test": "const testCreateId = (): void => {\n    let id: string;\n\n    id = createId(\"fish\", \"cat\");\n    console.assert(id === \"ftiasch\", `Test failed: Expected ftiasch, got ${id}`);\n  \n    id = createId(\"icpc\", \"acm\");\n    console.assert(id === \"imccpac\", `Test failed: Expected imccpac, got ${id}`);\n  \n    id = createId(\"oo\", \"w\");\n    console.assert(id === \"owo\", `Test failed: Expected owo, got ${id}`);\n  \n    id = createId(\"hello\", \"world\");\n    console.assert(id === \"hdellrloow\", `Test failed: Expected hdellrloow, got ${id}`);\n  \n    id = createId(\"abc\", \"def\");\n    console.assert(id === \"afbecd\", `Test failed: Expected afbecd, got ${id}`);\n  \n    id = createId(\"buaanb\", \"nbbuaa\");\n    console.assert(id === \"bauaauabnbbn\", `Test failed: Expected bauaauabnbbn, got ${id}`);\n    \n    id = createId(\"xtuisgood\", \"ilovextu\");\n    console.assert(id === \"xuttuxiesvgooloid\", `Test failed: Expected xuttuxiesvgooloid, got ${id}`);\n};\n\ntestCreateId();",
    "entry_point": "createId",
    "signature": "function createId(word1: string, word2: string): string",
    "docstring": {
      "en": "Creates an ID by combining two words in a specific manner.\nParameters:\n- word1 (string): The first word to be used in the ID.\n- word2 (string): The second word to be used in the ID.\nReturns:\n string: A unique ID formed by reversing every other character of the second\n         word and combining it with the first word.\ne.g.:\n     createId('fish', 'cat')  // returns 'ftiasch'\n",
      "sq": "Krijon një ID duke kombinuar dy fjalë në një mënyrë specifike.  \nParametrat:  \n- word1 (string): Fjala e parë që do të përdoret në ID.  \n- word2 (string): Fjala e dytë që do të përdoret në ID.  \nKthen:  \n string: Një ID unike e formuar duke përmbysur çdo karakter tjetër të fjalës së dytë dhe duke e kombinuar atë me fjalën e parë.  \np.sh.:  \n     createId('fish', 'cat')  // kthen 'ftiasch'  ",
      "hy": "Ստեղծում է ID՝ երկու բառերը հատուկ ձևով համադրելով։  \nՊարամետրեր՝  \n- word1 (string): Առաջին բառը, որը կօգտագործվի ID-ում։  \n- word2 (string): Երկրորդ բառը, որը կօգտագործվի ID-ում։  \nՎերադարձնում է՝  \n string: Ունիկալ ID, որը ձևավորվում է երկրորդ բառի յուրաքանչյուր երկրորդ նիշը շրջելով և այն առաջին բառի հետ համադրելով։  \nօրինակ՝  \n     createId('fish', 'cat')  // վերադարձնում է 'ftiasch'  ",
      "bn": "Creates an ID by combining two words in a specific manner.  \nপ্যারামিটারসমূহ:\n- word1 (string): আইডিতে ব্যবহৃত প্রথম শব্দ।\n- word2 (string): আইডিতে ব্যবহৃত দ্বিতীয় শব্দ।\nরিটার্ন:\n string: দ্বিতীয় শব্দের প্রতিটি বিকল্প অক্ষর উল্টিয়ে এবং প্রথম শব্দের সাথে\n         মিলিয়ে একটি অনন্য আইডি তৈরি করে।\nউদাহরণ:\n     createId('fish', 'cat')  // 'ftiasch' রিটার্ন করে",
      "bg": "Създава ID, като комбинира две думи по специфичен начин.\nПараметри:\n- word1 (string): Първата дума, която ще се използва в ID.\n- word2 (string): Втората дума, която ще се използва в ID.\nВръща:\n string: Уникален ID, образуван чрез обръщане на всеки втори символ на втората\n         дума и комбинирането му с първата дума.\nнапр.:\n     createId('fish', 'cat')  // връща 'ftiasch'",
      "zh": "Creates an ID by combining two words in a specific manner.  \n参数:  \n- word1 (string): 用于ID的第一个单词。  \n- word2 (string): 用于ID的第二个单词。  \n返回:  \n string: 一个唯一的ID，通过反转第二个单词的每隔一个字符并将其与第一个单词组合而成。  \n例如:  \n     createId('fish', 'cat')  // 返回 'ftiasch'  ",
      "fr": "Crée un identifiant en combinant deux mots d'une manière spécifique.\nParamètres :\n- word1 (string): Le premier mot à utiliser dans l'identifiant.\n- word2 (string): Le deuxième mot à utiliser dans l'identifiant.\nRenvoie :\n string: Un identifiant unique formé en inversant chaque autre caractère du deuxième\n         mot et en le combinant avec le premier mot.\nex. :\n     createId('fish', 'cat')  // renvoie 'ftiasch'",
      "de": "Erstellt eine ID, indem zwei Wörter auf eine bestimmte Weise kombiniert werden.  \nParameter:  \n- word1 (string): Das erste Wort, das in der ID verwendet werden soll.  \n- word2 (string): Das zweite Wort, das in der ID verwendet werden soll.  \nRückgabewert:  \n string: Eine eindeutige ID, die gebildet wird, indem jeder zweite Buchstabe des zweiten  \n         Wortes umgekehrt und mit dem ersten Wort kombiniert wird.  \nz.B.:  \n     createId('fish', 'cat')  // gibt 'ftiasch' zurück  ",
      "ha": "Creates an ID by combining two words in a specific manner.  \nSigogi:  \n- word1 (string): Kalma ta farko da za a yi amfani da ita a cikin ID.  \n- word2 (string): Kalma ta biyu da za a yi amfani da ita a cikin ID.  \nDawo da:  \n string: Wani ID na musamman wanda aka samar ta hanyar juyar da kowanne harafi na biyu na kalma ta biyu kuma a haɗa shi da kalma ta farko.  \ne.g.:  \n     createId('fish', 'cat')  // returns 'ftiasch'  ",
      "hi": "Creates an ID by combining two words in a specific manner.  \nपैरामीटर्स:  \n- word1 (string): ID में उपयोग के लिए पहला शब्द।  \n- word2 (string): ID में उपयोग के लिए दूसरा शब्द।  \nरिटर्न्स:  \n string: एक अद्वितीय ID जो दूसरे शब्द के हर दूसरे अक्षर को उलट कर और इसे पहले शब्द के साथ जोड़ कर बनाई जाती है।  \nउदाहरण:  \n     createId('fish', 'cat')  // 'ftiasch' लौटाता है  \n",
      "hu": "Creates an ID by combining two words in a specific manner.  \nParaméterek:  \n- word1 (string): Az első szó, amelyet az azonosítóban használunk.  \n- word2 (string): A második szó, amelyet az azonosítóban használunk.  \nVisszatér:  \n string: Egy egyedi azonosító, amely a második szó minden második karakterének megfordításával és az első szóval való kombinálásával jön létre.  \npl.:  \n     createId('fish', 'cat')  // visszaadja 'ftiasch'  "
    },
    "docstring_bertscore": {
      "sq": "0.9964977491215928",
      "hy": "0.9752218531178029",
      "bn": "0.9361786681608232",
      "bg": "0.9910948041270629",
      "zh": "0.8643453812722232",
      "fr": "0.9534410386854222",
      "de": "0.9782579184919211",
      "ha": "0.9782561308184918",
      "hi": "0.9673644325048247",
      "hu": "0.9542786630022463"
    }
  },
  {
    "task_id": "TypeScript/19",
    "prompt": {
      "en": "\n/*\nCount the number of different permutation schemes for a binary string of length n,\nwhere the number of '1's is m and the number of '0's is n - m.\n\nParameters:\n- n (number): Length of the binary string.\n- m (number): Number of '1's in the binary string.\n\nReturns:\nnumber: The total number of different permutation schemes.\n*/\nfunction countPermutationsOfBinaryString(n: number, m: number): number",
      "sq": "/*\nNumëroni numrin e skemave të ndryshme të permutimit për një varg binar me gjatësi n,\nku numri i '1'-ve është m dhe numri i '0'-ve është n - m.\n\nParametrat:\n- n (numër): Gjatësia e vargut binar.\n- m (numër): Numri i '1'-ve në vargun binar.\n\nKthen:\nnumër: Numri total i skemave të ndryshme të permutimit.\n*/\nfunction countPermutationsOfBinaryString(n: number, m: number): number",
      "hy": "/*\nՀաշվել տարբեր փոխատեղման սխեմաների քանակը երկբայական տողի համար, որի երկարությունը n է,\nորտեղ '1'-երի քանակը m է, իսկ '0'-երի քանակը n - m է։\n\nՊարամետրեր:\n- n (թիվ): Երկբայական տողի երկարությունը։\n- m (թիվ): '1'-երի քանակը երկբայական տողում։\n\nՎերադարձնում է:\nթիվ: Տարբեր փոխատեղման սխեմաների ընդհանուր քանակը։\n*/\nfunction countPermutationsOfBinaryString(n: number, m: number): number",
      "bn": "/*\nএকটি বাইনারি স্ট্রিংয়ের জন্য বিভিন্ন বিন্যাস স্কিমের সংখ্যা গণনা করুন যার দৈর্ঘ্য n,\nযেখানে '1' এর সংখ্যা m এবং '0' এর সংখ্যা n - m।\n\nপ্যারামিটারসমূহ:\n- n (number): বাইনারি স্ট্রিংয়ের দৈর্ঘ্য।\n- m (number): বাইনারি স্ট্রিংয়ে '1' এর সংখ্যা।\n\nফেরত দেয়:\nnumber: বিভিন্ন বিন্যাস স্কিমের মোট সংখ্যা।\n*/\nfunction countPermutationsOfBinaryString(n: number, m: number): number",
      "bg": "/*\nБройте броя на различните схеми на пермутации за двоичен низ с дължина n,\nкъдето броят на '1' е m и броят на '0' е n - m.\n\nПараметри:\n- n (number): Дължина на двоичния низ.\n- m (number): Брой на '1' в двоичния низ.\n\nВръща:\nnumber: Общият брой на различните схеми на пермутации.\n*/\nfunction countPermutationsOfBinaryString(n: number, m: number): number",
      "zh": "/*\n计算长度为 n 的二进制字符串的不同排列方案的数量，\n其中 '1' 的数量为 m，'0' 的数量为 n - m。\n\n参数：\n- n (number): 二进制字符串的长度。\n- m (number): 二进制字符串中 '1' 的数量。\n\n返回：\nnumber: 不同排列方案的总数量。\n*/\nfunction countPermutationsOfBinaryString(n: number, m: number): number",
      "fr": "/*\nCompter le nombre de différents schémas de permutation pour une chaîne binaire de longueur n,\noù le nombre de '1' est m et le nombre de '0' est n - m.\n\nParamètres :\n- n (nombre) : Longueur de la chaîne binaire.\n- m (nombre) : Nombre de '1' dans la chaîne binaire.\n\nRenvoie :\nnombre : Le nombre total de différents schémas de permutation.\n*/\nfunction countPermutationsOfBinaryString(n: number, m: number): number",
      "de": "/*\nZähle die Anzahl der verschiedenen Permutationsschemata für einen Binärstring der Länge n,\nwobei die Anzahl der '1's m ist und die Anzahl der '0's n - m ist.\n\nParameter:\n- n (number): Länge des Binärstrings.\n- m (number): Anzahl der '1's im Binärstring.\n\nRückgabe:\nnumber: Die Gesamtanzahl der verschiedenen Permutationsschemata.\n*/\nfunction countPermutationsOfBinaryString(n: number, m: number): number",
      "ha": "/*\nƘirga yawan tsarin permutation daban-daban don wata igiyar binary mai tsawon n,\ninda yawan '1's shine m kuma yawan '0's shine n - m.\n\nSigogi:\n- n (lamba): Tsawon igiyar binary.\n- m (lamba): Yawan '1's a cikin igiyar binary.\n\nDawowa:\nlamba: Jimillar yawan tsarin permutation daban-daban.\n*/\nfunction countPermutationsOfBinaryString(n: number, m: number): number",
      "hi": "/*\nबाइनरी स्ट्रिंग की लंबाई n के लिए विभिन्न क्रमपरिवर्तन योजनाओं की संख्या गिनें,\nजहां '1's की संख्या m है और '0's की संख्या n - m है।\n\nपैरामीटर्स:\n- n (number): बाइनरी स्ट्रिंग की लंबाई।\n- m (number): बाइनरी स्ट्रिंग में '1's की संख्या।\n\nवापसी:\nnumber: विभिन्न क्रमपरिवर्तन योजनाओं की कुल संख्या।\n*/\nfunction countPermutationsOfBinaryString(n: number, m: number): number",
      "hu": "/*\nSzámolja meg a különböző permutációs sémák számát egy n hosszúságú bináris karakterláncra,\nahol az '1'-ek száma m, és a '0'-k száma n - m.\n\nParaméterek:\n- n (szám): A bináris karakterlánc hossza.\n- m (szám): Az '1'-ek száma a bináris karakterláncban.\n\nVisszatér:\nszám: A különböző permutációs sémák összes száma.\n*/\nfunction countPermutationsOfBinaryString(n: number, m: number): number"
    },
    "prompt_bertscore": {
      "sq": "1",
      "hy": "0.9778862810490049",
      "bn": "0.9885068488925594",
      "bg": "1",
      "zh": "0.9707556490002334",
      "fr": "0.9879177111824098",
      "de": "0.9985557584994953",
      "ha": "0.9808492504429023",
      "hi": "0.9867271206784867",
      "hu": "0.9873526077483655"
    },
    "canonical_solution": "{\n    let factorial = 1.0;\n    let i: number;\n\n    // Calculate n factorial (n!)\n    for (i = 2; i <= n; ++i) {\n        factorial *= i;\n    }\n\n    let numerator = factorial; // n!\n\n    // Calculate (n+m)/2 factorial\n    factorial = 1.0;\n    for (i = 2; i <= (n + m) / 2; ++i) {\n        factorial *= i;\n    }\n\n    let denominator1 = factorial; // ((n+m)/2)!\n\n    // Calculate (n-m)/2 factorial\n    factorial = 1.0;\n    for (i = 2; i <= (n - m) / 2; ++i) {\n        factorial *= i;\n    }\n\n    let denominator2 = factorial; // ((n-m)/2)!\n\n    if ((n + m) & 1) {\n        return 0;\n    } else if (n === m) {\n        return 1;\n    } else {\n        // Calculating the number of permutations using the factorial values\n        return Math.round(numerator / denominator1 / denominator2);\n    }\n}",
    "instruction": {
      "en": "Write a TypeScript function `function countPermutationsOfBinaryString(n: number, m: number): number` to solve the following problem:\nCount the number of different permutation schemes for a binary string of length n, where the number of '1's is m and the number of '0's is n - m.\n\nParameters:\n- n (number): Length of the binary string.\n- m (number): Number of '1's in the binary string.\n\nReturns:\nnumber: The total number of different permutation schemes.",
      "sq": "Shkruani një funksion TypeScript `function countPermutationsOfBinaryString(n: number, m: number): number` për të zgjidhur problemin e mëposhtëm:\nNumëroni numrin e skemave të ndryshme të permutimit për një varg binar me gjatësi n, ku numri i '1'-ve është m dhe numri i '0'-ve është n - m.\n\nParametrat:\n- n (number): Gjatësia e vargut binar.\n- m (number): Numri i '1'-ve në vargun binar.\n\nKthen:\nnumber: Numri total i skemave të ndryshme të permutimit.",
      "hy": "Գրեք TypeScript ֆունկցիա `function countPermutationsOfBinaryString(n: number, m: number): number` հետևյալ խնդիրը լուծելու համար:\nՀաշվեք տարբեր տեղաբաշխման սխեմաների քանակը երկբայական տողի համար, որի երկարությունը n է, որտեղ '1'-երի քանակը m է և '0'-երի քանակը n - m է:\n\nՊարամետրեր:\n- n (number): Երկբայական տողի երկարությունը։\n- m (number): '1'-երի քանակը երկբայական տողում։\n\nՎերադարձնում է:\nnumber: Տարբեր տեղաբաշխման սխեմաների ընդհանուր քանակը։",
      "bn": "TypeScript ফাংশন `function countPermutationsOfBinaryString(n: number, m: number): number` লিখুন নিম্নলিখিত সমস্যার সমাধানের জন্য:\nদৈর্ঘ্য n এর একটি বাইনারি স্ট্রিংয়ের জন্য বিভিন্ন বিন্যাস প্রকল্পের সংখ্যা গণনা করুন, যেখানে '1' এর সংখ্যা m এবং '0' এর সংখ্যা n - m।\n\nপ্যারামিটারসমূহ:\n- n (number): বাইনারি স্ট্রিংয়ের দৈর্ঘ্য।\n- m (number): বাইনারি স্ট্রিংয়ে '1' এর সংখ্যা।\n\nফেরত দেয়:\nnumber: বিভিন্ন বিন্যাস প্রকল্পের মোট সংখ্যা।",
      "bg": "Напишете функция на TypeScript `function countPermutationsOfBinaryString(n: number, m: number): number`, за да решите следния проблем:\nПребройте броя на различните схеми на пермутация за двоична низ с дължина n, където броят на '1'-ците е m, а броят на '0'-ците е n - m.\n\nПараметри:\n- n (number): Дължина на двоичния низ.\n- m (number): Брой на '1'-ците в двоичния низ.\n\nВръща:\nnumber: Общият брой на различните схеми на пермутация.",
      "zh": "编写一个 TypeScript 函数 `function countPermutationsOfBinaryString(n: number, m: number): number` 来解决以下问题：\n计算长度为 n 的二进制字符串中，不同排列方案的数量，其中 '1' 的数量为 m，'0' 的数量为 n - m。\n\n参数：\n- n (number): 二进制字符串的长度。\n- m (number): 二进制字符串中 '1' 的数量。\n\n返回：\nnumber: 不同排列方案的总数。",
      "fr": "Écrire une fonction TypeScript `function countPermutationsOfBinaryString(n: number, m: number): number` pour résoudre le problème suivant :\nCompter le nombre de différents schémas de permutation pour une chaîne binaire de longueur n, où le nombre de '1' est m et le nombre de '0' est n - m.\n\nParamètres :\n- n (number) : Longueur de la chaîne binaire.\n- m (number) : Nombre de '1' dans la chaîne binaire.\n\nRenvoie :\nnumber : Le nombre total de différents schémas de permutation.",
      "de": "Schreiben Sie eine TypeScript-Funktion `function countPermutationsOfBinaryString(n: number, m: number): number`, um das folgende Problem zu lösen:\nZählen Sie die Anzahl der verschiedenen Permutationsschemata für einen Binärstring der Länge n, wobei die Anzahl der '1's m ist und die Anzahl der '0's n - m ist.\n\nParameter:\n- n (number): Länge des Binärstrings.\n- m (number): Anzahl der '1's im Binärstring.\n\nRückgabewert:\nnumber: Die Gesamtanzahl der verschiedenen Permutationsschemata.",
      "ha": "Rubuta aikin TypeScript `function countPermutationsOfBinaryString(n: number, m: number): number` don warware matsalar mai zuwa:\nƘirga adadin tsarin permutation daban-daban don wani binary string mai tsawon n, inda adadin '1's shine m kuma adadin '0's shine n - m.\n\nSigogi:\n- n (number): Tsawon binary string.\n- m (number): Adadin '1's a cikin binary string.\n\nDawo:\nnumber: Jimillar adadin tsarin permutation daban-daban.",
      "hi": "TypeScript फ़ंक्शन `function countPermutationsOfBinaryString(n: number, m: number): number` लिखें ताकि निम्नलिखित समस्या का समाधान किया जा सके:\nलंबाई n के एक बाइनरी स्ट्रिंग के लिए विभिन्न क्रमपरिवर्तन योजनाओं की संख्या गिनें, जहाँ '1's की संख्या m है और '0's की संख्या n - m है।\n\nपैरामीटर्स:\n- n (number): बाइनरी स्ट्रिंग की लंबाई।\n- m (number): बाइनरी स्ट्रिंग में '1's की संख्या।\n\nवापसी:\nnumber: विभिन्न क्रमपरिवर्तन योजनाओं की कुल संख्या।",
      "hu": "Írj egy TypeScript függvényt `function countPermutationsOfBinaryString(n: number, m: number): number` a következő probléma megoldására:\nSzámold meg a különböző permutációs sémák számát egy n hosszúságú bináris karakterláncra, ahol az '1'-ek száma m, és a '0'-k száma n - m.\n\nParaméterek:\n- n (number): A bináris karakterlánc hossza.\n- m (number): Az '1'-ek száma a bináris karakterláncban.\n\nVisszatérési érték:\nnumber: A különböző permutációs sémák teljes száma."
    },
    "instruction_bertscore": {
      "sq": "0.9999996027392379",
      "hy": "0.980073598804961",
      "bn": "0.9803508868168858",
      "bg": "0.9788444740071172",
      "zh": "0.9670029252113412",
      "fr": "0.9890000481286689",
      "de": "0.9847028784653602",
      "ha": "0.9844333370382958",
      "hi": "0.9803508868168858",
      "hu": "0.9856570988158517"
    },
    "level": "hard",
    "test": "(() => {\n    console.assert(countPermutationsOfBinaryString(2, 0) === 2);\n    console.assert(countPermutationsOfBinaryString(2, 1) === 0);\n    console.assert(countPermutationsOfBinaryString(3, 0) === 0);\n    console.assert(countPermutationsOfBinaryString(3, 1) === 3);\n    console.assert(countPermutationsOfBinaryString(3, 2) === 0);\n    console.assert(countPermutationsOfBinaryString(30, 2) === 145422675);\n    console.assert(countPermutationsOfBinaryString(4, 2) === 4);\n    console.assert(countPermutationsOfBinaryString(5, 5) === 1);\n    console.assert(countPermutationsOfBinaryString(33, 17) === 13884156);\n    console.assert(countPermutationsOfBinaryString(1000, 1000) === 1);\n    // Add more test cases if necessary\n})();",
    "entry_point": "countPermutationsOfBinaryString",
    "signature": "function countPermutationsOfBinaryString(n: number, m: number): number",
    "docstring": {
      "en": "Count the number of different permutation schemes for a binary string of length n, where the number of '1's is m and the number of '0's is n - m.\n\nParameters:\n- n (number): Length of the binary string.\n- m (number): Number of '1's in the binary string.\n\nReturns:\nnumber: The total number of different permutation schemes.",
      "sq": "Numëroni numrin e skemave të ndryshme të permutimit për një varg binar me gjatësi n, ku numri i '1' është m dhe numri i '0' është n - m.\n\nParametrat:\n- n (numër): Gjatësia e vargut binar.\n- m (numër): Numri i '1' në vargun binar.\n\nKthen:\nnumër: Numri total i skemave të ndryshme të permutimit.",
      "hy": "Հաշվել տարբեր տեղափոխման սխեմաների քանակը երկբաղադրիչ տողի համար, որի երկարությունը n է, որտեղ '1'-երի քանակը m է, իսկ '0'-երի քանակը n - m է։\n\nՊարամետրեր:\n- n (թիվ): Երկբաղադրիչ տողի երկարությունը։\n- m (թիվ): '1'-երի քանակը երկբաղադրիչ տողի մեջ։\n\nՎերադարձնում է:\nթիվ: Տարբեր տեղափոխման սխեմաների ընդհանուր քանակը։",
      "bn": "বাইনারি স্ট্রিংয়ের দৈর্ঘ্য n এর জন্য বিভিন্ন বিন্যাস স্কিমের সংখ্যা গণনা করুন, যেখানে '1' এর সংখ্যা m এবং '0' এর সংখ্যা n - m।\n\nপ্যারামিটারসমূহ:\n- n (number): বাইনারি স্ট্রিংয়ের দৈর্ঘ্য।\n- m (number): বাইনারি স্ট্রিংয়ে '1' এর সংখ্যা।\n\nফেরত দেয়:\nnumber: বিভিন্ন বিন্যাস স্কিমের মোট সংখ্যা।",
      "bg": "Бройте броя на различните схеми на пермутации за двоична верига с дължина n, където броят на '1' е m, а броят на '0' е n - m.\n\nПараметри:\n- n (number): Дължина на двоичната верига.\n- m (number): Брой на '1' в двоичната верига.\n\nВръща:\nnumber: Общият брой на различните схеми на пермутации.",
      "zh": "计算长度为 n 的二进制字符串的不同排列方案数量，其中 '1' 的数量为 m，'0' 的数量为 n - m。\n\n参数：\n- n (number): 二进制字符串的长度。\n- m (number): 二进制字符串中 '1' 的数量。\n\n返回：\nnumber: 不同排列方案的总数。",
      "fr": "Comptez le nombre de différents schémas de permutation pour une chaîne binaire de longueur n, où le nombre de '1' est m et le nombre de '0' est n - m.\n\nParamètres :\n- n (nombre) : Longueur de la chaîne binaire.\n- m (nombre) : Nombre de '1' dans la chaîne binaire.\n\nRenvoie :\nnombre : Le nombre total de différents schémas de permutation.",
      "de": "Zähle die Anzahl der verschiedenen Permutationsschemata für einen Binärstring der Länge n, wobei die Anzahl der '1's m ist und die Anzahl der '0's n - m ist.\n\nParameter:\n- n (Zahl): Länge des Binärstrings.\n- m (Zahl): Anzahl der '1's im Binärstring.\n\nRückgabe:\nZahl: Die Gesamtanzahl der verschiedenen Permutationsschemata.",
      "ha": "Count the number of different permutation schemes for a binary string of length n, where the number of '1's is m and the number of '0's is n - m.\n\nSigogi:\n- n (number): Tsawon igiyar binary.\n- m (number): Yawan '1's a cikin igiyar binary.\n\nDawowa:\nnumber: Jimillar adadin tsarin permutation daban-daban.",
      "hi": "बाइनरी स्ट्रिंग की लंबाई n के लिए विभिन्न क्रमपरिवर्तन योजनाओं की संख्या गिनें, जहां '1' की संख्या m है और '0' की संख्या n - m है।\n\nपैरामीटर्स:\n- n (number): बाइनरी स्ट्रिंग की लंबाई।\n- m (number): बाइनरी स्ट्रिंग में '1' की संख्या।\n\nवापसी:\nnumber: विभिन्न क्रमपरिवर्तन योजनाओं की कुल संख्या।",
      "hu": "Számolja meg a különböző permutációs sémák számát egy n hosszúságú bináris karakterláncra, ahol az '1'-ek száma m, és a '0'-k száma n - m.\n\nParaméterek:\n- n (szám): A bináris karakterlánc hossza.\n- m (szám): Az '1'-ek száma a bináris karakterláncban.\n\nVisszatér:\nszám: A különböző permutációs sémák összesített száma."
    },
    "docstring_bertscore": {
      "sq": "1",
      "hy": "0.948349943389117",
      "bn": "0.9650237720947097",
      "bg": "0.9924250317888536",
      "zh": "0.9611151234567051",
      "fr": "0.9851607214936455",
      "de": "0.9969665168208351",
      "ha": "0.9964159134046064",
      "hi": "0.9964159134046064",
      "hu": "0.9818704092318027"
    }
  },
  {
    "task_id": "TypeScript/20",
    "prompt": {
      "en": "\n/**\n * Answer a series of questions by providing choices A, B, C, or D for each question.\n * Question 1:\n *  Constants like 1e6 belong to which data type?\n *      A. unsigned int\n *      B. int\n *      C. float\n *      D. double\n * Question 2:\n *  Given 21! = 51,090,942,171,709,440,000, which data type can be used to store this value?\n *      A. int\n *      B. long long\n *      C. double\n *      D. None of the above\n * Question 3:\n *  Which statement about left values in expressions is incorrect?\n *      A. Variable name expressions are left values.\n *      B. Increment operation requires the operand to be a left value.\n *      C. Pointer dereference expressions are left values.\n *      D. Prefix increment operation expressions are left values.\n * Question 4:\n *  Which statement about functions is incorrect?\n *      A. Formal parameters of a function are local variables.\n *      B. Local variables are allocated space in the stack.\n *      C. The function type is the same as the return value type.\n *      D. A function can call itself from within its body.\n * Question 5:\n *  Which statement about pointers is incorrect?\n *      A. Subtracting two pointers equals the difference in their address values.\n *      B. Pointer dereference involves resolving based on the pointer's type.\n *      C. int *p[4], p is an array of int pointers.\n *      D. Function names can be assigned to function pointers.\n * \n * You're supposed to only return strings similar to \"AAAAA\", which stand for the choices of the question.\n */\nfunction answerQuestions(): string",
      "sq": "/**\n * Përgjigju një serie pyetjesh duke dhënë zgjedhjet A, B, C, ose D për secilën pyetje.\n * Pyetja 1:\n *  Konstante si 1e6 i përkasin cilit lloj të dhënash?\n *      A. unsigned int\n *      B. int\n *      C. float\n *      D. double\n * Pyetja 2:\n *  Duke pasur 21! = 51,090,942,171,709,440,000, cili lloj i dhënash mund të përdoret për të ruajtur këtë vlerë?\n *      A. int\n *      B. long long\n *      C. double\n *      D. Asnjë nga më sipër\n * Pyetja 3:\n *  Cila deklaratë për vlerat e majta në shprehje është e pasaktë?\n *      A. Shprehjet e emrave të variablave janë vlera të majta.\n *      B. Operacioni i rritjes kërkon që operand të jetë një vlerë e majtë.\n *      C. Shprehjet e dereferencimit të pointerëve janë vlera të majta.\n *      D. Shprehjet e operacionit të rritjes prefiks janë vlera të majta.\n * Pyetja 4:\n *  Cila deklaratë për funksionet është e pasaktë?\n *      A. Parametrat formalë të një funksioni janë variabla lokale.\n *      B. Variablat lokale alokohen hapësirë në stack.\n *      C. Lloji i funksionit është i njëjtë me llojin e vlerës së kthimit.\n *      D. Një funksion mund të thërrasë veten nga brenda trupit të tij.\n * Pyetja 5:\n *  Cila deklaratë për pointerët është e pasaktë?\n *      A. Zbritja e dy pointerëve është e barabartë me diferencën në vlerat e adresave të tyre.\n *      B. Dereferencimi i pointerit përfshin zgjidhjen bazuar në llojin e pointerit.\n *      C. int *p[4], p është një varg i pointerëve int.\n *      D. Emrat e funksioneve mund të caktohen te pointerët e funksioneve.\n * \n * Duhet të ktheni vetëm vargje të ngjashme me \"AAAAA\", të cilat përfaqësojnë zgjedhjet e pyetjeve.\n */\nfunction answerQuestions(): string",
      "hy": "/**\n * Պատասխանեք մի շարք հարցերի՝ յուրաքանչյուր հարցի համար տրամադրելով ընտրանքներ A, B, C կամ D:\n * Հարց 1:\n *  1e6 նման հաստատունները որ տվյալների տիպին են պատկանում?\n *      A. unsigned int\n *      B. int\n *      C. float\n *      D. double\n * Հարց 2:\n *  Տրված է 21! = 51,090,942,171,709,440,000, որ տվյալների տիպը կարող է պահել այս արժեքը?\n *      A. int\n *      B. long long\n *      C. double\n *      D. Վերը նշվածներից ոչ մեկը\n * Հարց 3:\n *  Որ արտահայտությունը ձախ արժեքների մասին սխալ է?\n *      A. Փոփոխականի անունով արտահայտությունները ձախ արժեքներ են:\n *      B. Ինկրեմենտ գործողությունը պահանջում է, որ օպերանդը լինի ձախ արժեք:\n *      C. Ցուցիչի ապահղման արտահայտությունները ձախ արժեքներ են:\n *      D. Նախածանց ինկրեմենտ գործողության արտահայտությունները ձախ արժեքներ են:\n * Հարց 4:\n *  Որ արտահայտությունը ֆունկցիաների մասին սխալ է?\n *      A. Ֆունկցիայի ֆորմալ պարամետրերը տեղական փոփոխականներ են:\n *      B. Տեղական փոփոխականները հատկացվում են ստեկում:\n *      C. Ֆունկցիայի տիպը նույնն է, ինչ վերադարձվող արժեքի տիպը:\n *      D. Ֆունկցիան կարող է ինքն իրեն կանչել իր մարմնից:\n * Հարց 5:\n *  Որ արտահայտությունը ցուցիչների մասին սխալ է?\n *      A. Երկու ցուցիչների հանումը հավասար է նրանց հասցեների արժեքների տարբերությանը:\n *      B. Ցուցիչի ապահղումը ներառում է լուծում ցուցիչի տիպի հիման վրա:\n *      C. int *p[4], p-ն int ցուցիչների զանգված է:\n *      D. Ֆունկցիաների անունները կարող են վերագրվել ֆունկցիայի ցուցիչներին:\n * \n * Դուք պետք է վերադարձնեք միայն \"AAAAA\" նման տողեր, որոնք ներկայացնում են հարցի ընտրանքները:\n */\nfunction answerQuestions(): string",
      "bn": "/**\n * প্রতিটি প্রশ্নের জন্য A, B, C, বা D বিকল্প প্রদান করে প্রশ্নগুলির উত্তর দিন।\n * প্রশ্ন 1:\n *  1e6 এর মতো ধ্রুবক কোন ডেটা টাইপের অন্তর্ভুক্ত?\n *      A. unsigned int\n *      B. int\n *      C. float\n *      D. double\n * প্রশ্ন 2:\n *  21! = 51,090,942,171,709,440,000 দেওয়া হলে, কোন ডেটা টাইপ এই মান সংরক্ষণ করতে ব্যবহার করা যেতে পারে?\n *      A. int\n *      B. long long\n *      C. double\n *      D. উপরোক্ত কোনোটিই নয়\n * প্রশ্ন 3:\n *  এক্সপ্রেশনে বাম মান সম্পর্কে কোন বিবৃতি ভুল?\n *      A. ভেরিয়েবল নাম এক্সপ্রেশনগুলি বাম মান।\n *      B. ইনক্রিমেন্ট অপারেশনটির জন্য অপারেন্ডটি একটি বাম মান হতে হবে।\n *      C. পয়েন্টার ডেরেফারেন্স এক্সপ্রেশনগুলি বাম মান।\n *      D. প্রিফিক্স ইনক্রিমেন্ট অপারেশন এক্সপ্রেশনগুলি বাম মান।\n * প্রশ্ন 4:\n *  ফাংশন সম্পর্কে কোন বিবৃতি ভুল?\n *      A. একটি ফাংশনের আনুষ্ঠানিক প্যারামিটারগুলি স্থানীয় ভেরিয়েবল।\n *      B. স্থানীয় ভেরিয়েবলগুলি স্ট্যাকে স্থান বরাদ্দ করা হয়।\n *      C. ফাংশনের প্রকার এবং রিটার্ন মানের প্রকার একই।\n *      D. একটি ফাংশন তার দেহের মধ্যে নিজেকে কল করতে পারে।\n * প্রশ্ন 5:\n *  পয়েন্টার সম্পর্কে কোন বিবৃতি ভুল?\n *      A. দুটি পয়েন্টার বিয়োগ করলে তাদের ঠিকানা মানের পার্থক্য সমান হয়।\n *      B. পয়েন্টার ডেরেফারেন্স পয়েন্টারের প্রকারের উপর ভিত্তি করে সমাধান করা হয়।\n *      C. int *p[4], p একটি int পয়েন্টারের অ্যারে।\n *      D. ফাংশনের নামগুলি ফাংশন পয়েন্টারগুলিতে বরাদ্দ করা যেতে পারে।\n * \n * আপনি শুধুমাত্র \"AAAAA\" এর মতো স্ট্রিং ফেরত দেওয়ার কথা, যা প্রশ্নের বিকল্পগুলির জন্য দাঁড়ায়।\n */\nfunction answerQuestions(): string",
      "bg": "/**\n * Отговорете на серия от въпроси, като предоставите избори A, B, C или D за всеки въпрос.\n * Въпрос 1:\n *  Константи като 1e6 принадлежат към кой тип данни?\n *      A. unsigned int\n *      B. int\n *      C. float\n *      D. double\n * Въпрос 2:\n *  Дадено 21! = 51,090,942,171,709,440,000, кой тип данни може да се използва за съхранение на тази стойност?\n *      A. int\n *      B. long long\n *      C. double\n *      D. Нито едно от горните\n * Въпрос 3:\n *  Кое твърдение за леви стойности в изрази е неправилно?\n *      A. Изразите с имена на променливи са леви стойности.\n *      B. Операцията на инкремент изисква операндът да е лява стойност.\n *      C. Изразите за разадресиране на указатели са леви стойности.\n *      D. Изразите за префикс инкремент операция са леви стойности.\n * Въпрос 4:\n *  Кое твърдение за функциите е неправилно?\n *      A. Формалните параметри на функцията са локални променливи.\n *      B. Локалните променливи се разпределят в стека.\n *      C. Типът на функцията е същият като типа на връщаната стойност.\n *      D. Функцията може да извика себе си от тялото си.\n * Въпрос 5:\n *  Кое твърдение за указателите е неправилно?\n *      A. Изваждането на два указателя е равно на разликата в техните адресни стойности.\n *      B. Разадресирането на указател включва разрешаване на базата на типа на указателя.\n *      C. int *p[4], p е масив от указатели към int.\n *      D. Имената на функциите могат да бъдат присвоени на указатели към функции.\n * \n * Очаква се да върнете само низове, подобни на \"AAAAA\", които представляват изборите за въпросите.\n */\nfunction answerQuestions(): string",
      "zh": "/**\n * 通过为每个问题提供选择 A、B、C 或 D 来回答一系列问题。\n * 问题 1:\n *  常量如 1e6 属于哪种数据类型？\n *      A. unsigned int\n *      B. int\n *      C. float\n *      D. double\n * 问题 2:\n *  给定 21! = 51,090,942,171,709,440,000，哪种数据类型可以用来存储这个值？\n *      A. int\n *      B. long long\n *      C. double\n *      D. 以上都不是\n * 问题 3:\n *  关于表达式中的左值，哪种说法是不正确的？\n *      A. 变量名表达式是左值。\n *      B. 增量操作要求操作数是左值。\n *      C. 指针解引用表达式是左值。\n *      D. 前缀增量操作表达式是左值。\n * 问题 4:\n *  关于函数，哪种说法是不正确的？\n *      A. 函数的形式参数是局部变量。\n *      B. 局部变量在栈中分配空间。\n *      C. 函数类型与返回值类型相同。\n *      D. 函数可以在其主体内调用自身。\n * 问题 5:\n *  关于指针，哪种说法是不正确的？\n *      A. 两个指针相减等于它们地址值的差。\n *      B. 指针解引用涉及基于指针的类型进行解析。\n *      C. int *p[4], p 是一个 int 指针数组。\n *      D. 函数名可以赋值给函数指针。\n * \n * 你应该只返回类似于 \"AAAAA\" 的字符串，代表问题的选择。\n */\nfunction answerQuestions(): string",
      "fr": "/**\n * Répondez à une série de questions en fournissant les choix A, B, C ou D pour chaque question.\n * Question 1 :\n *  Les constantes comme 1e6 appartiennent à quel type de données ?\n *      A. unsigned int\n *      B. int\n *      C. float\n *      D. double\n * Question 2 :\n *  Étant donné 21! = 51,090,942,171,709,440,000, quel type de données peut être utilisé pour stocker cette valeur ?\n *      A. int\n *      B. long long\n *      C. double\n *      D. Aucun des choix ci-dessus\n * Question 3 :\n *  Quelle affirmation concernant les valeurs à gauche dans les expressions est incorrecte ?\n *      A. Les expressions de noms de variables sont des valeurs à gauche.\n *      B. L'opération d'incrément nécessite que l'opérande soit une valeur à gauche.\n *      C. Les expressions de déréférencement de pointeur sont des valeurs à gauche.\n *      D. Les expressions d'opération d'incrément préfixé sont des valeurs à gauche.\n * Question 4 :\n *  Quelle affirmation concernant les fonctions est incorrecte ?\n *      A. Les paramètres formels d'une fonction sont des variables locales.\n *      B. Les variables locales sont allouées dans la pile.\n *      C. Le type de la fonction est le même que le type de la valeur de retour.\n *      D. Une fonction peut s'appeler elle-même à l'intérieur de son corps.\n * Question 5 :\n *  Quelle affirmation concernant les pointeurs est incorrecte ?\n *      A. Soustraire deux pointeurs équivaut à la différence de leurs valeurs d'adresse.\n *      B. Le déréférencement de pointeur implique une résolution basée sur le type du pointeur.\n *      C. int *p[4], p est un tableau de pointeurs int.\n *      D. Les noms de fonctions peuvent être assignés à des pointeurs de fonction.\n * \n * Vous êtes censé seulement retourner des chaînes similaires à \"AAAAA\", qui représentent les choix des questions.\n */\nfunction answerQuestions(): string",
      "de": "/**\n * Beantworten Sie eine Reihe von Fragen, indem Sie für jede Frage die Auswahlmöglichkeiten A, B, C oder D angeben.\n * Frage 1:\n *  Konstanten wie 1e6 gehören zu welchem Datentyp?\n *      A. unsigned int\n *      B. int\n *      C. float\n *      D. double\n * Frage 2:\n *  Angenommen 21! = 51,090,942,171,709,440,000, welcher Datentyp kann verwendet werden, um diesen Wert zu speichern?\n *      A. int\n *      B. long long\n *      C. double\n *      D. Keine der oben genannten\n * Frage 3:\n *  Welche Aussage über linke Werte in Ausdrücken ist falsch?\n *      A. Variablennamenausdrücke sind linke Werte.\n *      B. Der Inkrementierungsoperator erfordert, dass der Operand ein linker Wert ist.\n *      C. Zeigerdereferenzierungsausdrücke sind linke Werte.\n *      D. Präfix-Inkrementoperationen sind linke Werte.\n * Frage 4:\n *  Welche Aussage über Funktionen ist falsch?\n *      A. Formale Parameter einer Funktion sind lokale Variablen.\n *      B. Lokale Variablen werden im Stapel Speicherplatz zugewiesen.\n *      C. Der Funktionstyp ist derselbe wie der Rückgabewerttyp.\n *      D. Eine Funktion kann sich selbst innerhalb ihres Körpers aufrufen.\n * Frage 5:\n *  Welche Aussage über Zeiger ist falsch?\n *      A. Das Subtrahieren zweier Zeiger ergibt die Differenz ihrer Adresswerte.\n *      B. Zeigerdereferenzierung beinhaltet die Auflösung basierend auf dem Typ des Zeigers.\n *      C. int *p[4], p ist ein Array von int-Zeigern.\n *      D. Funktionsnamen können Funktionszeigern zugewiesen werden.\n * \n * Sie sollen nur Zeichenfolgen wie \"AAAAA\" zurückgeben, die für die Auswahlmöglichkeiten der Frage stehen.\n */\nfunction answerQuestions(): string",
      "ha": "/**\n * Amsa jerin tambayoyi ta hanyar bayar da zaɓuɓɓuka A, B, C, ko D ga kowace tambaya.\n * Tambaya ta 1:\n *  Constants kamar 1e6 suna cikin wane nau'in bayanai?\n *      A. unsigned int\n *      B. int\n *      C. float\n *      D. double\n * Tambaya ta 2:\n *  Idan aka ba 21! = 51,090,942,171,709,440,000, wane nau'in bayanai za a iya amfani da shi don adana wannan ƙima?\n *      A. int\n *      B. long long\n *      C. double\n *      D. Babu ɗaya daga cikin waɗannan\n * Tambaya ta 3:\n *  Wane bayani game da ƙimar hagu a cikin maganganu ba daidai ba ne?\n *      A. Maganganun sunayen canji ƙimar hagu ne.\n *      B. Aikin ƙara yana buƙatar operand ya zama ƙimar hagu.\n *      C. Maganganun cirewa mai nuna alama ƙimar hagu ne.\n *      D. Maganganun aikin ƙara na farko ƙimar hagu ne.\n * Tambaya ta 4:\n *  Wane bayani game da ayyuka ba daidai ba ne?\n *      A. Sigogin hukuma na aiki canje-canje na gida ne.\n *      B. Canje-canje na gida suna samun sarari a cikin faifai.\n *      C. Nau'in aiki yana daidai da nau'in ƙimar dawowa.\n *      D. Aiki na iya kiran kansa daga cikin jikin sa.\n * Tambaya ta 5:\n *  Wane bayani game da masu nuna alama ba daidai ba ne?\n *      A. Rage masu nuna alama biyu yana daidai da bambanci a ƙimar adireshin su.\n *      B. Cire mai nuna alama yana buƙatar warwarewa bisa nau'in mai nuna alama.\n *      C. int *p[4], p tsari ne na masu nuna alama int.\n *      D. Ana iya sanya sunayen ayyuka ga masu nuna alama ayyuka.\n * \n * Ya kamata ka dawo da kirtani mai kama da \"AAAAA\", wanda ke wakiltar zaɓuɓɓukan tambayoyin.\n */\nfunction answerQuestions(): string",
      "hi": "/**\n * प्रत्येक प्रश्न के लिए विकल्प A, B, C, या D प्रदान करके प्रश्नों की एक श्रृंखला का उत्तर दें।\n * प्रश्न 1:\n *  1e6 जैसी स्थिरांक किस डेटा प्रकार से संबंधित हैं?\n *      A. unsigned int\n *      B. int\n *      C. float\n *      D. double\n * प्रश्न 2:\n *  दिए गए 21! = 51,090,942,171,709,440,000, इस मान को संग्रहीत करने के लिए किस डेटा प्रकार का उपयोग किया जा सकता है?\n *      A. int\n *      B. long long\n *      C. double\n *      D. उपरोक्त में से कोई नहीं\n * प्रश्न 3:\n *  अभिव्यक्तियों में बाएँ मानों के बारे में कौन सा कथन गलत है?\n *      A. वेरिएबल नाम अभिव्यक्तियाँ बाएँ मान हैं।\n *      B. वृद्धि ऑपरेशन के लिए ऑपरेन्ड का बाएँ मान होना आवश्यक है।\n *      C. पॉइंटर डीरिफरेंस अभिव्यक्तियाँ बाएँ मान हैं।\n *      D. उपसर्ग वृद्धि ऑपरेशन अभिव्यक्तियाँ बाएँ मान हैं।\n * प्रश्न 4:\n *  कार्यों के बारे में कौन सा कथन गलत है?\n *      A. एक फ़ंक्शन के औपचारिक पैरामीटर स्थानीय वेरिएबल होते हैं।\n *      B. स्थानीय वेरिएबल स्टैक में स्पेस आवंटित करते हैं।\n *      C. फ़ंक्शन प्रकार वही है जो रिटर्न मान प्रकार है।\n *      D. एक फ़ंक्शन अपने शरीर के भीतर से खुद को कॉल कर सकता है।\n * प्रश्न 5:\n *  पॉइंटर्स के बारे में कौन सा कथन गलत है?\n *      A. दो पॉइंटर्स को घटाने से उनके पते के मानों में अंतर होता है।\n *      B. पॉइंटर डीरिफरेंस में पॉइंटर के प्रकार के आधार पर समाधान शामिल होता है।\n *      C. int *p[4], p एक int पॉइंटर्स की सरणी है।\n *      D. फ़ंक्शन नामों को फ़ंक्शन पॉइंटर्स को सौंपा जा सकता है।\n * \n * आपको केवल \"AAAAA\" जैसे स्ट्रिंग्स लौटाने हैं, जो प्रश्न के विकल्पों के लिए खड़े होते हैं।\n */\nfunction answerQuestions(): string",
      "hu": "/**\n * Válaszolj egy sor kérdésre az A, B, C vagy D választási lehetőségek megadásával minden kérdésre.\n * 1. kérdés:\n *  Az olyan konstansok, mint az 1e6, melyik adattípushoz tartoznak?\n *      A. unsigned int\n *      B. int\n *      C. float\n *      D. double\n * 2. kérdés:\n *  Tekintve, hogy 21! = 51,090,942,171,709,440,000, melyik adattípus használható ennek az értéknek a tárolására?\n *      A. int\n *      B. long long\n *      C. double\n *      D. Egyik sem a fentiek közül\n * 3. kérdés:\n *  Melyik állítás helytelen a balértékekkel kapcsolatban a kifejezésekben?\n *      A. A változónév kifejezések balértékek.\n *      B. Az inkrementálás művelet megköveteli, hogy az operandus balérték legyen.\n *      C. A pointer dereferálás kifejezések balértékek.\n *      D. A prefix inkrementálás művelet kifejezések balértékek.\n * 4. kérdés:\n *  Melyik állítás helytelen a függvényekkel kapcsolatban?\n *      A. A függvény formális paraméterei lokális változók.\n *      B. A lokális változók a veremben kapnak helyet.\n *      C. A függvény típusa megegyezik a visszatérési érték típusával.\n *      D. Egy függvény meghívhatja önmagát a törzsén belül.\n * 5. kérdés:\n *  Melyik állítás helytelen a pointerekkel kapcsolatban?\n *      A. Két pointer kivonása egyenlő a címértékeik különbségével.\n *      B. A pointer dereferálás a pointer típusának alapján történik.\n *      C. int *p[4], p egy int pointerek tömbje.\n *      D. A függvénynevek hozzárendelhetők függvénypointerekhez.\n * \n * Csak olyan karakterláncokat kell visszaadnod, mint például \"AAAAA\", amelyek a kérdések választásait jelölik.\n */\nfunction answerQuestions(): string"
    },
    "prompt_bertscore": {
      "sq": "0.9588717919332971",
      "hy": "0.9409001123180225",
      "bn": "0.9445122057971419",
      "bg": "0.9449265487719807",
      "zh": "0.9439161160236562",
      "fr": "0.95287633251214",
      "de": "0.9456215564752217",
      "ha": "0.9427318816919262",
      "hi": "0.9538190323005316",
      "hu": "0.9259686693148679"
    },
    "canonical_solution": "{\n    return \"DDDBA\";\n}",
    "instruction": {
      "en": "Write a TypeScript function `function answerQuestions(): string` to solve the following problem:\nAnswer a series of questions by providing choices A, B, C, or D for each question.\nQuestion 1:\nConstants like 1e6 belong to which data type?\n    A. unsigned int\n    B. int\n    C. float\n    D. double\nQuestion 2:\nGiven 21! = 51,090,942,171,709,440,000, which data type can be used to store this value?\n    A. int\n    B. long long\n    C. double\n    D. None of the above\nQuestion 3:\nWhich statement about left values in expressions is incorrect?\n    A. Variable name expressions are left values.\n    B. Increment operation requires the operand to be a left value.\n    C. Pointer dereference expressions are left values.\n    D. Prefix increment operation expressions are left values.\nQuestion 4:\nWhich statement about functions is incorrect?\n    A. Formal parameters of a function are local variables.\n    B. Local variables are allocated space in the stack.\n    C. The function type is the same as the return value type.\n    D. A function can call itself from within its body.\nQuestion 5:\nWhich statement about pointers is incorrect?\n    A. Subtracting two pointers equals the difference in their address values.\n    B. Pointer dereference involves resolving based on the pointer's type.\n    C. int *p[4], p is an array of int pointers.\n    D. Function names can be assigned to function pointers.\n\nYou're supposed to only return strings similar to \"AAAAA\", which stand for the choices of the question.",
      "sq": "Shkruani një funksion TypeScript `function answerQuestions(): string` për të zgjidhur problemin e mëposhtëm: \nPërgjigjuni një serie pyetjesh duke dhënë zgjedhjet A, B, C, ose D për secilën pyetje. \nPyetja 1: \nKonstantet si 1e6 i përkasin cilit tip të dhënash? \n    A. unsigned int \n    B. int \n    C. float \n    D. double \nPyetja 2: \nDuke pasur parasysh 21! = 51,090,942,171,709,440,000, cili tip i të dhënave mund të përdoret për të ruajtur këtë vlerë? \n    A. int \n    B. long long \n    C. double \n    D. Asnjë nga më sipër \nPyetja 3: \nCila deklaratë për vlerat e majta në shprehje është e pasaktë? \n    A. Shprehjet e emrave të variablave janë vlera të majta. \n    B. Operacioni i inkrementit kërkon që operandi të jetë një vlerë e majtë. \n    C. Shprehjet e dereferencimit të treguesve janë vlera të majta. \n    D. Shprehjet e operacionit të inkrementit prefiks janë vlera të majta. \nPyetja 4: \nCila deklaratë për funksionet është e pasaktë? \n    A. Parametrat formalë të një funksioni janë variabla lokale. \n    B. Variablat lokale alokohen hapësirë në stack. \n    C. Tipi i funksionit është i njëjtë me tipin e vlerës së kthimit. \n    D. Një funksion mund të thërrasë veten nga brenda trupit të tij. \nPyetja 5: \nCila deklaratë për treguesit është e pasaktë? \n    A. Zbritja e dy treguesve është e barabartë me diferencën në vlerat e adresave të tyre. \n    B. Dereferencimi i treguesit përfshin zgjidhjen bazuar në tipin e treguesit. \n    C. int *p[4], p është një varg treguesish int. \n    D. Emrat e funksioneve mund të caktohen te treguesit e funksioneve.\n\nJu duhet të ktheni vetëm vargje të ngjashme me \"AAAAA\", të cilat përfaqësojnë zgjedhjet e pyetjes.",
      "hy": "TypeScript ֆունկցիա գրեք `function answerQuestions(): string`՝ հետևյալ խնդիրը լուծելու համար:\nՊատասխանեք մի շարք հարցերի՝ յուրաքանչյուր հարցի համար տրամադրելով ընտրանքներ A, B, C կամ D:\nՀարց 1:\nՆման 1e6 հաստատունները որ տվյալների տիպին են պատկանում?\n    A. unsigned int\n    B. int\n    C. float\n    D. double\nՀարց 2:\nՀաշվի առնելով 21! = 51,090,942,171,709,440,000, որ տվյալների տիպը կարող է օգտագործվել այս արժեքը պահելու համար?\n    A. int\n    B. long long\n    C. double\n    D. Վերը նշվածներից ոչ մեկը\nՀարց 3:\nՈր հայտարարությունն է սխալ ձախ արժեքների մասին արտահայտություններում?\n    A. Փոփոխականի անվան արտահայտությունները ձախ արժեքներ են:\n    B. Ինկրեմենտի գործողությունը պահանջում է, որ օպերանդը լինի ձախ արժեք:\n    C. Ցուցիչի ապահղման արտահայտությունները ձախ արժեքներ են:\n    D. Նախածանց ինկրեմենտի գործողության արտահայտությունները ձախ արժեքներ են:\nՀարց 4:\nՈր հայտարարությունն է սխալ ֆունկցիաների մասին?\n    A. Ֆունկցիայի ֆորմալ պարամետրերը տեղական փոփոխականներ են:\n    B. Տեղական փոփոխականները տեղադրվում են ստեկում:\n    C. Ֆունկցիայի տիպը նույնն է, ինչ վերադարձվող արժեքի տիպը:\n    D. Ֆունկցիան կարող է ինքն իրեն կանչել իր մարմնից:\nՀարց 5:\nՈր հայտարարությունն է սխալ ցուցիչների մասին?\n    A. Երկու ցուցիչների հանումը հավասար է նրանց հասցեների արժեքների տարբերությանը:\n    B. Ցուցիչի ապահղումը ներառում է լուծում ցուցիչի տիպի հիման վրա:\n    C. int *p[4], p-ն int ցուցիչների զանգված է:\n    D. Ֆունկցիաների անունները կարող են վերագրվել ֆունկցիայի ցուցիչներին:\n\nԴուք պետք է վերադարձնեք միայն նմանատիպ տողեր \"AAAAA\", որոնք ներկայացնում են հարցերի ընտրանքները:",
      "bn": "TypeScript ফাংশন `function answerQuestions(): string` লিখুন নিম্নলিখিত সমস্যার সমাধানের জন্য:\nপ্রতিটি প্রশ্নের জন্য A, B, C, বা D পছন্দ প্রদান করে প্রশ্নগুলির একটি সিরিজের উত্তর দিন।\nপ্রশ্ন 1:\n1e6 এর মতো ধ্রুবক কোন ডেটা টাইপের অন্তর্ভুক্ত?\n    A. unsigned int\n    B. int\n    C. float\n    D. double\nপ্রশ্ন 2:\n21! = 51,090,942,171,709,440,000 দেওয়া হলে, কোন ডেটা টাইপ এই মান সংরক্ষণ করতে ব্যবহার করা যেতে পারে?\n    A. int\n    B. long long\n    C. double\n    D. উপরের কোনোটিই নয়\nপ্রশ্ন 3:\nএক্সপ্রেশনে বাম মান সম্পর্কে কোন বিবৃতি ভুল?\n    A. ভেরিয়েবল নাম এক্সপ্রেশনগুলি বাম মান।\n    B. ইনক্রিমেন্ট অপারেশনটির জন্য অপারেন্ডকে বাম মান হতে হবে।\n    C. পয়েন্টার ডেরেফারেন্স এক্সপ্রেশনগুলি বাম মান।\n    D. প্রিফিক্স ইনক্রিমেন্ট অপারেশন এক্সপ্রেশনগুলি বাম মান।\nপ্রশ্ন 4:\nফাংশন সম্পর্কে কোন বিবৃতি ভুল?\n    A. একটি ফাংশনের আনুষ্ঠানিক প্যারামিটারগুলি স্থানীয় ভেরিয়েবল।\n    B. স্থানীয় ভেরিয়েবলগুলি স্ট্যাকে স্থান বরাদ্দ করে।\n    C. ফাংশনের টাইপ এবং রিটার্ন ভ্যালুর টাইপ একই।\n    D. একটি ফাংশন তার দেহের ভিতরে নিজেকে কল করতে পারে।\nপ্রশ্ন 5:\nপয়েন্টার সম্পর্কে কোন বিবৃতি ভুল?\n    A. দুটি পয়েন্টার বিয়োগ করলে তাদের ঠিকানা মানের পার্থক্য হয়।\n    B. পয়েন্টার ডেরেফারেন্স পয়েন্টারের টাইপের উপর ভিত্তি করে সমাধান করা হয়।\n    C. int *p[4], p একটি int পয়েন্টারের অ্যারে।\n    D. ফাংশনের নাম ফাংশন পয়েন্টারগুলিতে বরাদ্দ করা যেতে পারে।\n\nআপনাকে শুধুমাত্র \"AAAAA\" এর মতো স্ট্রিংগুলি ফেরত দিতে হবে, যা প্রশ্নের পছন্দগুলির জন্য দাঁড়ায়।",
      "bg": "Напишете функция на TypeScript `function answerQuestions(): string`, за да решите следния проблем:  \nОтговорете на серия от въпроси, като предоставите избори A, B, C или D за всеки въпрос.  \nВъпрос 1:  \nКонстанти като 1e6 принадлежат към кой тип данни?  \n    A. unsigned int  \n    B. int  \n    C. float  \n    D. double  \nВъпрос 2:  \nДадено е 21! = 51,090,942,171,709,440,000, кой тип данни може да се използва за съхранение на тази стойност?  \n    A. int  \n    B. long long  \n    C. double  \n    D. Нито едно от горните  \nВъпрос 3:  \nКое твърдение за левите стойности в изразите е неправилно?  \n    A. Изразите с имена на променливи са леви стойности.  \n    B. Операцията за инкрементиране изисква операндът да е лява стойност.  \n    C. Изразите за разреференция на указател са леви стойности.  \n    D. Изразите за префиксно инкрементиране са леви стойности.  \nВъпрос 4:  \nКое твърдение за функциите е неправилно?  \n    A. Формалните параметри на функцията са локални променливи.  \n    B. Локалните променливи са разпределени в стека.  \n    C. Типът на функцията е същият като типа на връщаната стойност.  \n    D. Функцията може да извика себе си от своето тяло.  \nВъпрос 5:  \nКое твърдение за указателите е неправилно?  \n    A. Изваждането на два указателя е равно на разликата в техните адресни стойности.  \n    B. Разреференцията на указател включва разрешаване на базата на типа на указателя.  \n    C. int *p[4], p е масив от указатели към int.  \n    D. Имената на функции могат да бъдат присвоени на указатели към функции.  \n\nТрябва да върнете само низове, подобни на \"AAAAA\", които представляват изборите на въпросите.",
      "zh": "编写一个 TypeScript 函数 `function answerQuestions(): string` 来解决以下问题：\n通过为每个问题提供选项 A、B、C 或 D 来回答一系列问题。\n问题 1：\n常量如 1e6 属于哪种数据类型？\n    A. unsigned int\n    B. int\n    C. float\n    D. double\n问题 2：\n给定 21! = 51,090,942,171,709,440,000，哪种数据类型可以用来存储这个值？\n    A. int\n    B. long long\n    C. double\n    D. 以上都不是\n问题 3：\n关于表达式中的左值，哪个说法是不正确的？\n    A. 变量名表达式是左值。\n    B. 增量操作要求操作数是左值。\n    C. 指针解引用表达式是左值。\n    D. 前缀增量操作表达式是左值。\n问题 4：\n关于函数，哪个说法是不正确的？\n    A. 函数的形式参数是局部变量。\n    B. 局部变量在栈中分配空间。\n    C. 函数类型与返回值类型相同。\n    D. 函数可以在其主体内调用自身。\n问题 5：\n关于指针，哪个说法是不正确的？\n    A. 两个指针相减等于它们地址值的差。\n    B. 指针解引用涉及根据指针的类型进行解析。\n    C. int *p[4]，p 是一个 int 指针数组。\n    D. 函数名可以赋值给函数指针。\n\n你应该只返回类似于 \"AAAAA\" 的字符串，这些字符串代表问题的选择。",
      "fr": "Écrire une fonction TypeScript `function answerQuestions(): string` pour résoudre le problème suivant :  \nRépondre à une série de questions en fournissant des choix A, B, C ou D pour chaque question.  \nQuestion 1 :  \nLes constantes comme 1e6 appartiennent à quel type de données ?  \n    A. unsigned int  \n    B. int  \n    C. float  \n    D. double  \nQuestion 2 :  \nÉtant donné 21! = 51,090,942,171,709,440,000, quel type de données peut être utilisé pour stocker cette valeur ?  \n    A. int  \n    B. long long  \n    C. double  \n    D. Aucun des précédents  \nQuestion 3 :  \nQuelle affirmation concernant les valeurs à gauche dans les expressions est incorrecte ?  \n    A. Les expressions de noms de variables sont des valeurs à gauche.  \n    B. L'opération d'incrémentation nécessite que l'opérande soit une valeur à gauche.  \n    C. Les expressions de déréférencement de pointeur sont des valeurs à gauche.  \n    D. Les expressions d'opération d'incrémentation préfixée sont des valeurs à gauche.  \nQuestion 4 :  \nQuelle affirmation concernant les fonctions est incorrecte ?  \n    A. Les paramètres formels d'une fonction sont des variables locales.  \n    B. Les variables locales sont allouées dans la pile.  \n    C. Le type de la fonction est le même que le type de la valeur de retour.  \n    D. Une fonction peut s'appeler elle-même depuis son corps.  \nQuestion 5 :  \nQuelle affirmation concernant les pointeurs est incorrecte ?  \n    A. Soustraire deux pointeurs équivaut à la différence de leurs valeurs d'adresse.  \n    B. Le déréférencement de pointeur implique une résolution basée sur le type du pointeur.  \n    C. int *p[4], p est un tableau de pointeurs int.  \n    D. Les noms de fonctions peuvent être assignés à des pointeurs de fonction.  \n\nVous êtes censé ne retourner que des chaînes similaires à \"AAAAA\", qui représentent les choix des questions.",
      "de": "Schreiben Sie eine TypeScript-Funktion `function answerQuestions(): string`, um das folgende Problem zu lösen:\nBeantworten Sie eine Reihe von Fragen, indem Sie für jede Frage die Auswahlmöglichkeiten A, B, C oder D angeben.\nFrage 1:\nKonstanten wie 1e6 gehören zu welchem Datentyp?\n    A. unsigned int\n    B. int\n    C. float\n    D. double\nFrage 2:\nGegeben 21! = 51,090,942,171,709,440,000, welcher Datentyp kann verwendet werden, um diesen Wert zu speichern?\n    A. int\n    B. long long\n    C. double\n    D. Keine der oben genannten\nFrage 3:\nWelche Aussage über linke Werte in Ausdrücken ist falsch?\n    A. Variablennamenausdrücke sind linke Werte.\n    B. Die Inkrementoperation erfordert, dass der Operand ein linker Wert ist.\n    C. Zeiger-Dereferenz-Ausdrücke sind linke Werte.\n    D. Präfix-Inkrement-Operation-Ausdrücke sind linke Werte.\nFrage 4:\nWelche Aussage über Funktionen ist falsch?\n    A. Formale Parameter einer Funktion sind lokale Variablen.\n    B. Lokale Variablen werden im Stack Speicherplatz zugewiesen.\n    C. Der Funktionstyp ist derselbe wie der Rückgabewerttyp.\n    D. Eine Funktion kann sich selbst aus ihrem Körper heraus aufrufen.\nFrage 5:\nWelche Aussage über Zeiger ist falsch?\n    A. Das Subtrahieren von zwei Zeigern entspricht der Differenz ihrer Adresswerte.\n    B. Zeiger-Dereferenzierung beinhaltet die Auflösung basierend auf dem Typ des Zeigers.\n    C. int *p[4], p ist ein Array von int-Zeigern.\n    D. Funktionsnamen können Funktionszeigern zugewiesen werden.\n\nSie sollen nur Zeichenfolgen wie \"AAAAA\" zurückgeben, die für die Auswahlmöglichkeiten der Frage stehen.",
      "ha": "Rubuta aikin TypeScript `function answerQuestions(): string` don warware matsalar mai zuwa: \nAmsa jerin tambayoyi ta hanyar bayar da zaɓuɓɓuka A, B, C, ko D don kowace tambaya. \nTambaya ta 1: \nConstant kamar 1e6 yana cikin wane nau'in bayanai? \n    A. unsigned int \n    B. int \n    C. float \n    D. double \nTambaya ta 2: \nAn ba da 21! = 51,090,942,171,709,440,000, wane nau'in bayanai za a iya amfani da shi don adana wannan ƙima? \n    A. int \n    B. long long \n    C. double \n    D. Babu ɗaya daga cikin waɗannan \nTambaya ta 3: \nWane bayani game da ƙimar hagu a cikin maganganu ba daidai ba ne? \n    A. Maganganun sunayen canji suna da ƙimar hagu. \n    B. Aikin ƙara yana buƙatar mai aiki ya zama ƙimar hagu. \n    C. Maganganun cire alamar mai nuna suna da ƙimar hagu. \n    D. Maganganun aikin ƙara na farko suna da ƙimar hagu. \nTambaya ta 4: \nWane bayani game da ayyuka ba daidai ba ne? \n    A. Sigogin aiki na aiki canje-canje ne na gida. \n    B. Canje-canje na gida suna samun sarari a cikin tsari. \n    C. Nau'in aiki yana daidai da nau'in ƙimar dawowa. \n    D. Aiki na iya kiran kansa daga cikin jikinsa. \nTambaya ta 5: \nWane bayani game da masu nuna ba daidai ba ne? \n    A. Cirewa masu nuna biyu yana daidai da bambancin a cikin ƙimar adireshinsu. \n    B. Cire alamar mai nuna yana da alaƙa da nau'in mai nuna. \n    C. int *p[4], p tsari ne na masu nuna int. \n    D. Ana iya sanya sunayen ayyuka ga masu nuna ayyuka. \n\nAna tsammanin ka dawo da kirtani mai kama da \"AAAAA\", wanda ke nufin zaɓuɓɓukan tambayar.",
      "hi": "TypeScript फ़ंक्शन `function answerQuestions(): string` लिखें ताकि निम्नलिखित समस्या का समाधान किया जा सके:\nप्रत्येक प्रश्न के लिए विकल्प A, B, C, या D प्रदान करके प्रश्नों की एक श्रृंखला का उत्तर दें।\nप्रश्न 1:\n1e6 जैसी स्थिरांक किस डेटा प्रकार से संबंधित हैं?\n    A. unsigned int\n    B. int\n    C. float\n    D. double\nप्रश्न 2:\nदिया गया 21! = 51,090,942,171,709,440,000, इस मान को संग्रहीत करने के लिए किस डेटा प्रकार का उपयोग किया जा सकता है?\n    A. int\n    B. long long\n    C. double\n    D. उपरोक्त में से कोई नहीं\nप्रश्न 3:\nअभिव्यक्तियों में बाएँ मानों के बारे में कौन सा कथन गलत है?\n    A. चर नाम अभिव्यक्तियाँ बाएँ मान हैं।\n    B. वृद्धि ऑपरेशन के लिए ऑपरेण्ड का बाएँ मान होना आवश्यक है।\n    C. पॉइंटर डिरेफरेंस अभिव्यक्तियाँ बाएँ मान हैं।\n    D. उपसर्ग वृद्धि ऑपरेशन अभिव्यक्तियाँ बाएँ मान हैं।\nप्रश्न 4:\nकार्यों के बारे में कौन सा कथन गलत है?\n    A. एक फ़ंक्शन के औपचारिक पैरामीटर स्थानीय चर होते हैं।\n    B. स्थानीय चर स्टैक में स्थान आवंटित करते हैं।\n    C. फ़ंक्शन प्रकार वही है जो रिटर्न मान प्रकार है।\n    D. एक फ़ंक्शन अपने शरीर के भीतर से स्वयं को कॉल कर सकता है।\nप्रश्न 5:\nपॉइंटर्स के बारे में कौन सा कथन गलत है?\n    A. दो पॉइंटर्स को घटाने से उनके पते के मानों में अंतर के बराबर होता है।\n    B. पॉइंटर डिरेफरेंस में पॉइंटर के प्रकार के आधार पर समाधान शामिल होता है।\n    C. int *p[4], p int पॉइंटर्स की एक सरणी है।\n    D. फ़ंक्शन नाम फ़ंक्शन पॉइंटर्स को सौंपे जा सकते हैं।\n\nआपको केवल \"AAAAA\" जैसे स्ट्रिंग्स लौटाने हैं, जो प्रश्न के विकल्पों का प्रतिनिधित्व करते हैं।",
      "hu": "Írj egy TypeScript függvényt `function answerQuestions(): string` a következő probléma megoldására:\nVálaszolj egy sor kérdésre úgy, hogy minden kérdéshez A, B, C vagy D választ adsz.\n1. kérdés:\nAz olyan konstansok, mint az 1e6, melyik adattípushoz tartoznak?\n    A. unsigned int\n    B. int\n    C. float\n    D. double\n2. kérdés:\nTekintve, hogy 21! = 51,090,942,171,709,440,000, melyik adattípus használható ennek az értéknek a tárolására?\n    A. int\n    B. long long\n    C. double\n    D. Egyik sem\n3. kérdés:\nMelyik állítás helytelen a balértékekkel kapcsolatban a kifejezésekben?\n    A. A változónév kifejezések balértékek.\n    B. Az inkrementáló művelet megköveteli, hogy az operandus balérték legyen.\n    C. A pointer dereferálási kifejezések balértékek.\n    D. A prefix inkrementáló művelet kifejezései balértékek.\n4. kérdés:\nMelyik állítás helytelen a függvényekkel kapcsolatban?\n    A. A függvény formális paraméterei lokális változók.\n    B. A lokális változók a veremben kapnak helyet.\n    C. A függvény típusa megegyezik a visszatérési érték típusával.\n    D. Egy függvény meghívhatja önmagát a saját törzsén belül.\n5. kérdés:\nMelyik állítás helytelen a pointerekkel kapcsolatban?\n    A. Két pointer kivonása az címértékeik különbségével egyenlő.\n    B. A pointer dereferálás a pointer típusának megfelelően történik.\n    C. int *p[4], p egy int pointerek tömbje.\n    D. A függvénynevek hozzárendelhetők függvénypointerekhez.\n\nCsak olyan karakterláncokat kell visszaadnod, mint például \"AAAAA\", amelyek a kérdések választásait jelölik."
    },
    "instruction_bertscore": {
      "sq": "0.9608930546907081",
      "hy": "0.9359434897896779",
      "bn": "0.9329296710182355",
      "bg": "0.9392457198743829",
      "zh": "0.9388842125808994",
      "fr": "0.9544909988795727",
      "de": "0.9490942114268547",
      "ha": "0.9260119707379335",
      "hi": "0.9393613227561451",
      "hu": "0.9283869942039676"
    },
    "level": "easy",
    "test": "function testAnswerQuestions(): void {\n    const expectedAnswers = \"DDDBA\";\n    console.assert(answerQuestions() === expectedAnswers, `Expected answers string '${expectedAnswers}' does not match the result.`);\n}\n\ntestAnswerQuestions();",
    "entry_point": "answerQuestions",
    "signature": "function answerQuestions(): string",
    "docstring": {
      "en": "Answer a series of questions by providing choices A, B, C, or D for each question.\nQuestion 1:\nConstants like 1e6 belong to which data type?\n    A. unsigned int\n    B. int\n    C. float\n    D. double\nQuestion 2:\nGiven 21! = 51,090,942,171,709,440,000, which data type can be used to store this value?\n    A. int\n    B. long long\n    C. double\n    D. None of the above\nQuestion 3:\nWhich statement about left values in expressions is incorrect?\n    A. Variable name expressions are left values.\n    B. Increment operation requires the operand to be a left value.\n    C. Pointer dereference expressions are left values.\n    D. Prefix increment operation expressions are left values.\nQuestion 4:\nWhich statement about functions is incorrect?\n    A. Formal parameters of a function are local variables.\n    B. Local variables are allocated space in the stack.\n    C. The function type is the same as the return value type.\n    D. A function can call itself from within its body.\nQuestion 5:\nWhich statement about pointers is incorrect?\n    A. Subtracting two pointers equals the difference in their address values.\n    B. Pointer dereference involves resolving based on the pointer's type.\n    C. int *p[4], p is an array of int pointers.\n    D. Function names can be assigned to function pointers.\n\nYou're supposed to only return strings similar to \"AAAAA\", which stand for the choices of the question.",
      "sq": "Përgjigjuni një serie pyetjesh duke dhënë zgjedhjet A, B, C, ose D për secilën pyetje.\nPyetja 1:\nKonstantet si 1e6 i përkasin cilit tip të dhënash?\n    A. unsigned int\n    B. int\n    C. float\n    D. double\nPyetja 2:\nDuke pasur parasysh 21! = 51,090,942,171,709,440,000, cili tip i të dhënave mund të përdoret për të ruajtur këtë vlerë?\n    A. int\n    B. long long\n    C. double\n    D. Asnjë nga të mësipërmet\nPyetja 3:\nCila deklaratë për vlerat e majta në shprehje është e pasaktë?\n    A. Shprehjet me emra variablash janë vlera të majta.\n    B. Operacioni i inkrementimit kërkon që operandi të jetë një vlerë e majtë.\n    C. Shprehjet e dereferencimit të treguesve janë vlera të majta.\n    D. Shprehjet e operacionit të inkrementimit prefiks janë vlera të majta.\nPyetja 4:\nCila deklaratë për funksionet është e pasaktë?\n    A. Parametrat formalë të një funksioni janë variabla lokale.\n    B. Variablat lokale kanë hapësirë të caktuar në stack.\n    C. Lloji i funksionit është i njëjtë me llojin e vlerës së kthimit.\n    D. Një funksion mund të thërrasë veten brenda trupit të tij.\nPyetja 5:\nCila deklaratë për treguesit është e pasaktë?\n    A. Zbritja e dy treguesve është e barabartë me diferencën në vlerat e adresave të tyre.\n    B. Dereferencimi i treguesit përfshin zgjidhjen bazuar në llojin e treguesit.\n    C. int *p[4], p është një varg treguesish int.\n    D. Emrat e funksioneve mund të caktohen te treguesit e funksioneve.\n\nJu duhet të ktheni vetëm vargje të ngjashme me \"AAAAA\", të cilat përfaqësojnë zgjedhjet e pyetjes.",
      "hy": "Պատասխանեք մի շարք հարցերի՝ յուրաքանչյուր հարցի համար տրամադրելով ընտրանքներ A, B, C կամ D:\nՀարց 1:\nՆման հաստատունները, ինչպիսիք են 1e6-ը, պատկանում են որ տվյալների տիպին:\n    A. unsigned int\n    B. int\n    C. float\n    D. double\nՀարց 2:\nՀաշվի առնելով 21! = 51,090,942,171,709,440,000, որ տվյալների տիպը կարող է օգտագործվել այս արժեքը պահելու համար:\n    A. int\n    B. long long\n    C. double\n    D. Վերը նշվածներից ոչ մեկը\nՀարց 3:\nՈ՞ր հայտարարությունը ձախ արժեքների մասին արտահայտություններում սխալ է:\n    A. Փոփոխականի անվան արտահայտությունները ձախ արժեքներ են:\n    B. Ինկրեմենտի գործողությունը պահանջում է, որ օպերանդը լինի ձախ արժեք:\n    C. Ցուցիչի ապահղման արտահայտությունները ձախ արժեքներ են:\n    D. Նախաբառի ինկրեմենտի գործողության արտահայտությունները ձախ արժեքներ են:\nՀարց 4:\nՈ՞ր հայտարարությունը ֆունկցիաների մասին սխալ է:\n    A. Ֆունկցիայի ֆորմալ պարամետրերը տեղական փոփոխականներ են:\n    B. Տեղական փոփոխականների համար տարածք է հատկացվում stack-ում:\n    C. Ֆունկցիայի տիպը նույնն է, ինչ վերադարձվող արժեքի տիպը:\n    D. Ֆունկցիան կարող է ինքն իրեն կանչել իր մարմնի ներսից:\nՀարց 5:\nՈ՞ր հայտարարությունը ցուցիչների մասին սխալ է:\n    A. Երկու ցուցիչների հանումը հավասար է նրանց հասցեների արժեքների տարբերությանը:\n    B. Ցուցիչի ապահղումը ներառում է լուծում ցուցիչի տիպի հիման վրա:\n    C. int *p[4], p-ն int ցուցիչների զանգված է:\n    D. Ֆունկցիաների անունները կարող են նշանակվել ֆունկցիոնալ ցուցիչներին:\n\nԴուք պետք է վերադարձնեք միայն այնպիսի տողեր, ինչպիսիք են \"AAAAA\"-ն, որոնք ներկայացնում են հարցի ընտրանքները:",
      "bn": "একটি সিরিজ প্রশ্নের উত্তর দিন প্রতিটি প্রশ্নের জন্য A, B, C, বা D বিকল্প প্রদান করে।\nপ্রশ্ন ১:\n1e6 এর মত ধ্রুবক কোন ডেটা টাইপের অন্তর্গত?\n    A. unsigned int\n    B. int\n    C. float\n    D. double\nপ্রশ্ন ২:\nযদি 21! = 51,090,942,171,709,440,000 হয়, তাহলে কোন ডেটা টাইপ এই মানটি সংরক্ষণ করতে ব্যবহার করা যেতে পারে?\n    A. int\n    B. long long\n    C. double\n    D. উপরোক্ত কোনোটিই নয়\nপ্রশ্ন ৩:\nএক্সপ্রেশনে বাম মান সম্পর্কে কোন বিবৃতিটি ভুল?\n    A. ভেরিয়েবল নাম এক্সপ্রেশনগুলি বাম মান।\n    B. ইনক্রিমেন্ট অপারেশনটির জন্য অপারেন্ডটি একটি বাম মান হতে হবে।\n    C. পয়েন্টার ডেরেফারেন্স এক্সপ্রেশনগুলি বাম মান।\n    D. প্রিফিক্স ইনক্রিমেন্ট অপারেশন এক্সপ্রেশনগুলি বাম মান।\nপ্রশ্ন ৪:\nফাংশন সম্পর্কে কোন বিবৃতিটি ভুল?\n    A. একটি ফাংশনের আনুষ্ঠানিক প্যারামিটারগুলি স্থানীয় ভেরিয়েবল।\n    B. স্থানীয় ভেরিয়েবলগুলি স্ট্যাকে স্থান বরাদ্দ করে।\n    C. ফাংশনের টাইপ এবং রিটার্ন ভ্যালুর টাইপ একই।\n    D. একটি ফাংশন তার দেহের ভিতর থেকে নিজেকে কল করতে পারে।\nপ্রশ্ন ৫:\nপয়েন্টার সম্পর্কে কোন বিবৃতিটি ভুল?\n    A. দুটি পয়েন্টার বিয়োগ করলে তাদের ঠিকানা মানের পার্থক্য সমান হয়।\n    B. পয়েন্টার ডেরেফারেন্স পয়েন্টারের টাইপের উপর ভিত্তি করে সমাধান করা হয়।\n    C. int *p[4], p একটি int পয়েন্টারের অ্যারে।\n    D. ফাংশনের নাম ফাংশন পয়েন্টারগুলিতে বরাদ্দ করা যেতে পারে।\n\nআপনাকে প্রশ্নের বিকল্পগুলির জন্য শুধুমাত্র \"AAAAA\" এর মত স্ট্রিং ফেরত দিতে হবে।",
      "bg": "Отговорете на серия от въпроси, като предоставите избори A, B, C или D за всеки въпрос.\nВъпрос 1:\nКонстанти като 1e6 принадлежат към кой тип данни?\n    A. unsigned int\n    B. int\n    C. float\n    D. double\nВъпрос 2:\nДадено е 21! = 51,090,942,171,709,440,000, кой тип данни може да се използва за съхраняване на тази стойност?\n    A. int\n    B. long long\n    C. double\n    D. Нито едно от горните\nВъпрос 3:\nКое твърдение за левите стойности в изразите е неправилно?\n    A. Изразите с имена на променливи са леви стойности.\n    B. Операцията за инкрементиране изисква операндът да бъде лява стойност.\n    C. Изразите за дереференция на указатели са леви стойности.\n    D. Изразите за префиксно инкрементиране са леви стойности.\nВъпрос 4:\nКое твърдение за функциите е неправилно?\n    A. Формалните параметри на функцията са локални променливи.\n    B. Локалните променливи се разпределят в стека.\n    C. Типът на функцията е същият като типа на връщаната стойност.\n    D. Функцията може да извика себе си от своето тяло.\nВъпрос 5:\nКое твърдение за указателите е неправилно?\n    A. Изваждането на два указателя е равно на разликата в техните адресни стойности.\n    B. Дереференцията на указател включва разрешаване на базата на типа на указателя.\n    C. int *p[4], p е масив от указатели към int.\n    D. Имената на функции могат да бъдат присвоени на указатели към функции.\n\nТрябва да върнете само низове, подобни на \"AAAAA\", които представляват изборите на въпросите.",
      "zh": "回答一系列问题，为每个问题提供选择A、B、C或D。\n\n问题1：  \n像1e6这样的常量属于哪种数据类型？  \nA. unsigned int  \nB. int  \nC. float  \nD. double  \n\n问题2：  \n给定21! = 51,090,942,171,709,440,000，哪种数据类型可以用来存储这个值？  \nA. int  \nB. long long  \nC. double  \nD. 以上都不是  \n\n问题3：  \n关于表达式中的左值，哪种说法是不正确的？  \nA. 变量名表达式是左值。  \nB. 增量操作要求操作数是左值。  \nC. 指针解引用表达式是左值。  \nD. 前缀增量操作表达式是左值。  \n\n问题4：  \n关于函数，哪种说法是不正确的？  \nA. 函数的形式参数是局部变量。  \nB. 局部变量在栈中分配空间。  \nC. 函数类型与返回值类型相同。  \nD. 函数可以在其体内调用自身。  \n\n问题5：  \n关于指针，哪种说法是不正确的？  \nA. 两个指针相减等于它们地址值的差。  \nB. 指针解引用涉及根据指针的类型进行解析。  \nC. int *p[4]，p是一个int指针数组。  \nD. 函数名可以赋值给函数指针。  \n\n你应该只返回类似于\"AAAAA\"的字符串，代表问题的选择。",
      "fr": "Répondez à une série de questions en fournissant les choix A, B, C ou D pour chaque question.\n\nQuestion 1 :\nLes constantes comme 1e6 appartiennent à quel type de données ?\n    A. unsigned int\n    B. int\n    C. float\n    D. double\n\nQuestion 2 :\nÉtant donné 21! = 51,090,942,171,709,440,000, quel type de données peut être utilisé pour stocker cette valeur ?\n    A. int\n    B. long long\n    C. double\n    D. Aucun des précédents\n\nQuestion 3 :\nQuelle affirmation concernant les valeurs à gauche dans les expressions est incorrecte ?\n    A. Les expressions de nom de variable sont des valeurs à gauche.\n    B. L'opération d'incrémentation nécessite que l'opérande soit une valeur à gauche.\n    C. Les expressions de déréférencement de pointeur sont des valeurs à gauche.\n    D. Les expressions d'opération de pré-incrémentation sont des valeurs à gauche.\n\nQuestion 4 :\nQuelle affirmation concernant les fonctions est incorrecte ?\n    A. Les paramètres formels d'une fonction sont des variables locales.\n    B. Les variables locales sont allouées dans la pile.\n    C. Le type de la fonction est le même que le type de la valeur de retour.\n    D. Une fonction peut s'appeler elle-même depuis son corps.\n\nQuestion 5 :\nQuelle affirmation concernant les pointeurs est incorrecte ?\n    A. Soustraire deux pointeurs équivaut à la différence de leurs valeurs d'adresse.\n    B. Le déréférencement de pointeur implique une résolution basée sur le type du pointeur.\n    C. int *p[4], p est un tableau de pointeurs int.\n    D. Les noms de fonctions peuvent être assignés à des pointeurs de fonction.\n\nVous êtes censé ne retourner que des chaînes similaires à \"AAAAA\", qui représentent les choix de la question.",
      "de": "Beantworten Sie eine Reihe von Fragen, indem Sie für jede Frage die Auswahlmöglichkeiten A, B, C oder D angeben.\nFrage 1:\nKonstanten wie 1e6 gehören zu welchem Datentyp?\n    A. unsigned int\n    B. int\n    C. float\n    D. double\nFrage 2:\nGegeben 21! = 51,090,942,171,709,440,000, welcher Datentyp kann verwendet werden, um diesen Wert zu speichern?\n    A. int\n    B. long long\n    C. double\n    D. Keine der oben genannten\nFrage 3:\nWelche Aussage über linke Werte in Ausdrücken ist falsch?\n    A. Variablennamenausdrücke sind linke Werte.\n    B. Die Inkrementoperation erfordert, dass der Operand ein linker Wert ist.\n    C. Pointer-Dereferenzierungsausdrücke sind linke Werte.\n    D. Präfix-Inkrementoperationen sind linke Werte.\nFrage 4:\nWelche Aussage über Funktionen ist falsch?\n    A. Formale Parameter einer Funktion sind lokale Variablen.\n    B. Lokale Variablen werden im Stapel Speicherplatz zugewiesen.\n    C. Der Funktionstyp ist derselbe wie der Rückgabewerttyp.\n    D. Eine Funktion kann sich selbst aus ihrem Körper heraus aufrufen.\nFrage 5:\nWelche Aussage über Zeiger ist falsch?\n    A. Das Subtrahieren zweier Zeiger ergibt den Unterschied in ihren Adresswerten.\n    B. Die Dereferenzierung eines Zeigers beinhaltet die Auflösung basierend auf dem Typ des Zeigers.\n    C. int *p[4], p ist ein Array von int-Zeigern.\n    D. Funktionsnamen können Funktionszeigern zugewiesen werden.\n\nSie sollen nur Zeichenfolgen wie \"AAAAA\" zurückgeben, die für die Auswahlmöglichkeiten der Frage stehen.",
      "ha": "Amsa jerin tambayoyi ta hanyar bayar da zaɓuɓɓuka A, B, C, ko D ga kowace tambaya.\n\nTambaya ta 1:\nDindindin kamar 1e6 suna cikin wane nau'in bayanai?\n    A. unsigned int\n    B. int\n    C. float\n    D. double\n\nTambaya ta 2:\nAn bayar da 21! = 51,090,942,171,709,440,000, wane nau'in bayanai za a iya amfani da shi don adana wannan ƙima?\n    A. int\n    B. long long\n    C. double\n    D. Babu ɗaya daga cikin waɗannan\n\nTambaya ta 3:\nWane bayani game da ƙimar hagu a cikin jimloli ba daidai ba ne?\n    A. Jimlolin sunayen canji suna ƙimar hagu.\n    B. Aiki na ƙaruwa yana buƙatar mai aiki ya zama ƙimar hagu.\n    C. Jimlolin cire alamar mai nuna suna ƙimar hagu.\n    D. Jimlolin aikin ƙaruwa na farko suna ƙimar hagu.\n\nTambaya ta 4:\nWane bayani game da ayyuka ba daidai ba ne?\n    A. Sigogin tsari na aiki su ne canje-canje na gida.\n    B. Canje-canje na gida suna samun sarari a cikin tari.\n    C. Nau'in aiki yana daidai da nau'in ƙimar dawowa.\n    D. Aiki na iya kiran kansa daga cikin jikinsa.\n\nTambaya ta 5:\nWane bayani game da masu nuna ba daidai ba ne?\n    A. Rage masu nuna biyu yana daidai da bambanci a cikin ƙimar adireshinsu.\n    B. Cire alamar mai nuna yana da alaƙa da warwarewa bisa nau'in mai nuna.\n    C. int *p[4], p tsari ne na masu nuna int.\n    D. Ana iya sanya sunayen ayyuka zuwa masu nuna ayyuka.\n\nDole ne ka dawo da kirtani makamancin \"AAAAA\", wanda ke wakiltar zaɓuɓɓukan tambayar.",
      "hi": "प्रश्नों की एक श्रृंखला का उत्तर देकर प्रत्येक प्रश्न के लिए विकल्प A, B, C, या D प्रदान करें।  \nप्रश्न 1:  \n1e6 जैसी स्थिरांक किस डेटा प्रकार से संबंधित हैं?  \n    A. unsigned int  \n    B. int  \n    C. float  \n    D. double  \nप्रश्न 2:  \nयदि 21! = 51,090,942,171,709,440,000 है, तो इस मान को संग्रहीत करने के लिए किस डेटा प्रकार का उपयोग किया जा सकता है?  \n    A. int  \n    B. long long  \n    C. double  \n    D. उपरोक्त में से कोई नहीं  \nप्रश्न 3:  \nअभिव्यक्तियों में बाएँ मानों के बारे में कौन सा कथन गलत है?  \n    A. चर नाम अभिव्यक्तियाँ बाएँ मान हैं।  \n    B. वृद्धि ऑपरेशन के लिए ऑपरेन्ड का बाएँ मान होना आवश्यक है।  \n    C. पॉइंटर डिरेफरेंस अभिव्यक्तियाँ बाएँ मान हैं।  \n    D. उपसर्ग वृद्धि ऑपरेशन अभिव्यक्तियाँ बाएँ मान हैं।  \nप्रश्न 4:  \nफंक्शनों के बारे में कौन सा कथन गलत है?  \n    A. एक फ़ंक्शन के औपचारिक पैरामीटर स्थानीय चर होते हैं।  \n    B. स्थानीय चर स्टैक में स्थान आवंटित करते हैं।  \n    C. फ़ंक्शन प्रकार वही है जो रिटर्न मान प्रकार है।  \n    D. एक फ़ंक्शन अपने शरीर के भीतर से खुद को कॉल कर सकता है।  \nप्रश्न 5:  \nपॉइंटर्स के बारे में कौन सा कथन गलत है?  \n    A. दो पॉइंटर्स को घटाने से उनके पते के मानों में अंतर होता है।  \n    B. पॉइंटर डिरेफरेंस में पॉइंटर के प्रकार के आधार पर समाधान शामिल होता है।  \n    C. int *p[4], p एक int पॉइंटर्स की सरणी है।  \n    D. फ़ंक्शन नामों को फ़ंक्शन पॉइंटर्स को सौंपा जा सकता है।  \n\nआपको केवल \"AAAAA\" जैसे स्ट्रिंग्स लौटाने हैं, जो प्रश्न के विकल्पों के लिए खड़े होते हैं।",
      "hu": "Válaszolj egy sor kérdésre azzal, hogy megadod az A, B, C vagy D választ minden kérdéshez.\nKérdés 1:\nAz olyan konstansok, mint az 1e6, melyik adattípushoz tartoznak?\n    A. unsigned int\n    B. int\n    C. float\n    D. double\nKérdés 2:\nTekintettel arra, hogy 21! = 51,090,942,171,709,440,000, melyik adattípus használható ennek az értéknek a tárolására?\n    A. int\n    B. long long\n    C. double\n    D. A fentiek egyike sem\nKérdés 3:\nMelyik állítás helytelen a baloldali értékekkel kapcsolatban a kifejezésekben?\n    A. A változónév kifejezések baloldali értékek.\n    B. Az inkrementáló művelet megköveteli, hogy az operandus baloldali érték legyen.\n    C. A pointer dereferálási kifejezések baloldali értékek.\n    D. A prefix inkrementáló művelet kifejezések baloldali értékek.\nKérdés 4:\nMelyik állítás helytelen a függvényekkel kapcsolatban?\n    A. A függvény formális paraméterei helyi változók.\n    B. A helyi változók számára helyet foglalnak a veremben.\n    C. A függvény típusa megegyezik a visszatérési érték típusával.\n    D. Egy függvény meghívhatja önmagát a törzsén belül.\nKérdés 5:\nMelyik állítás helytelen a pointerekkel kapcsolatban?\n    A. Két pointer kivonása egyenlő a címértékeik különbségével.\n    B. A pointer dereferálás a pointer típusán alapuló megoldást von maga után.\n    C. int *p[4], p egy int pointerek tömbje.\n    D. A függvénynevek hozzárendelhetők függvénypointerekhez.\n\nCsak olyan karakterláncokat kell visszaadnod, mint például \"AAAAA\", amelyek a kérdések választásait jelölik."
    },
    "docstring_bertscore": {
      "sq": "0.9528570653651797",
      "hy": "0.9361562229277662",
      "bn": "0.929687427308603",
      "bg": "0.9402106662654504",
      "zh": "0.9414596541013978",
      "fr": "0.9628559201160949",
      "de": "0.9352705300587316",
      "ha": "0.9255799496591826",
      "hi": "0.9246765786862359",
      "hu": "0.9288267618675788"
    }
  },
  {
    "task_id": "TypeScript/21",
    "prompt": {
      "en": "\n/**\n * Determines if it is possible to assemble wooden squares from a number of buckets\n * into a single larger square. Each bucket contains a set number of squares,\n * with each square having a side length of 1.\n * \n * @param length - The number of buckets.\n * @param squares - An array where each element represents the number of squares in a bucket.\n * @returns A boolean indicating whether it is possible to form a larger square.\n *\n * Examples:\n *   IsSquare(1, [9]) returns true.\n *   IsSquare(2, [14, 2]) returns true.\n *   IsSquare(2, [7, 7]) returns false.\n */\nfunction isSquare(length: number, squares: number[]): boolean",
      "sq": "/**\n * Përcakton nëse është e mundur të montohen katrorë druri nga një numër kovash\n * në një katror më të madh. Çdo kovë përmban një numër të caktuar katrorësh,\n * ku çdo katror ka një gjatësi anësore prej 1.\n * \n * @param length - Numri i kovave.\n * @param squares - Një varg ku çdo element përfaqëson numrin e katrorëve në një kovë.\n * @returns Një vlerë boolean që tregon nëse është e mundur të formohet një katror më i madh.\n *\n * Shembuj:\n *   IsSquare(1, [9]) kthen true.\n *   IsSquare(2, [14, 2]) kthen true.\n *   IsSquare(2, [7, 7]) kthen false.\n */\nfunction isSquare(length: number, squares: number[]): boolean",
      "hy": "/**\n * Որոշում է՝ արդյոք հնարավոր է փայտե քառակուսիներ հավաքել մի քանի դույլերից\n * մեկ մեծ քառակուսի մեջ։ Յուրաքանչյուր դույլ պարունակում է որոշակի քանակությամբ քառակուսիներ,\n * որոնցից յուրաքանչյուրի կողքի երկարությունը 1 է։\n * \n * @param length - Դույլերի քանակը։\n * @param squares - Զանգված, որտեղ յուրաքանչյուր տարր ներկայացնում է դույլում գտնվող քառակուսիների քանակը։\n * @returns Բուլյան արժեք, որը ցույց է տալիս՝ արդյոք հնարավոր է ձևավորել մեծ քառակուսի։\n *\n * Օրինակներ:\n *   IsSquare(1, [9]) վերադարձնում է true։\n *   IsSquare(2, [14, 2]) վերադարձնում է true։\n *   IsSquare(2, [7, 7]) վերադարձնում է false։\n */\nfunction isSquare(length: number, squares: number[]): boolean",
      "bn": "/**\n * কাঠের বর্গক্ষেত্রগুলি একত্রিত করে একটি বড় বর্গক্ষেত্র তৈরি করা সম্ভব কিনা তা নির্ধারণ করে\n * একটি নির্দিষ্ট সংখ্যক বালতি থেকে। প্রতিটি বালতিতে নির্দিষ্ট সংখ্যক বর্গক্ষেত্র থাকে,\n * যেখানে প্রতিটি বর্গক্ষেত্রের বাহুর দৈর্ঘ্য 1।\n * \n * @param length - বালতির সংখ্যা।\n * @param squares - একটি অ্যারে যেখানে প্রতিটি উপাদান একটি বালতিতে থাকা বর্গক্ষেত্রের সংখ্যা নির্দেশ করে।\n * @returns একটি বুলিয়ান যা নির্দেশ করে যে একটি বড় বর্গক্ষেত্র তৈরি করা সম্ভব কিনা।\n *\n * উদাহরণ:\n *   IsSquare(1, [9]) true প্রদান করে।\n *   IsSquare(2, [14, 2]) true প্রদান করে।\n *   IsSquare(2, [7, 7]) false প্রদান করে।\n */\nfunction isSquare(length: number, squares: number[]): boolean",
      "bg": "/**\n * Определя дали е възможно да се сглобят дървени квадрати от даден брой кофи\n * в един по-голям квадрат. Всяка кофа съдържа определен брой квадрати,\n * като всеки квадрат има страна с дължина 1.\n * \n * @param length - Броят на кофите.\n * @param squares - Масив, където всеки елемент представлява броя на квадратите в една кофа.\n * @returns Булева стойност, указваща дали е възможно да се формира по-голям квадрат.\n *\n * Примери:\n *   IsSquare(1, [9]) връща true.\n *   IsSquare(2, [14, 2]) връща true.\n *   IsSquare(2, [7, 7]) връща false.\n */\nfunction isSquare(length: number, squares: number[]): boolean",
      "zh": "/**\n * 确定是否可以将多个桶中的木制正方形组装成一个更大的正方形。\n * 每个桶包含一定数量的正方形，每个正方形的边长为1。\n * \n * @param length - 桶的数量。\n * @param squares - 一个数组，其中每个元素表示一个桶中的正方形数量。\n * @returns 一个布尔值，指示是否可以形成一个更大的正方形。\n *\n * 示例:\n *   IsSquare(1, [9]) 返回 true。\n *   IsSquare(2, [14, 2]) 返回 true。\n *   IsSquare(2, [7, 7]) 返回 false。\n */ \nfunction isSquare(length: number, squares: number[]): boolean",
      "fr": "/**\n * Détermine s'il est possible d'assembler des carrés en bois à partir d'un certain nombre de seaux\n * en un seul carré plus grand. Chaque seau contient un nombre défini de carrés,\n * chaque carré ayant une longueur de côté de 1.\n * \n * @param length - Le nombre de seaux.\n * @param squares - Un tableau où chaque élément représente le nombre de carrés dans un seau.\n * @returns Un booléen indiquant s'il est possible de former un carré plus grand.\n *\n * Exemples :\n *   IsSquare(1, [9]) retourne true.\n *   IsSquare(2, [14, 2]) retourne true.\n *   IsSquare(2, [7, 7]) retourne false.\n */\nfunction isSquare(length: number, squares: number[]): boolean",
      "de": "/**\n * Bestimmt, ob es möglich ist, aus einer Anzahl von Eimern Holzquadrate\n * zu einem einzigen größeren Quadrat zusammenzusetzen. Jeder Eimer enthält eine festgelegte Anzahl von Quadraten,\n * wobei jedes Quadrat eine Seitenlänge von 1 hat.\n * \n * @param length - Die Anzahl der Eimer.\n * @param squares - Ein Array, in dem jedes Element die Anzahl der Quadrate in einem Eimer darstellt.\n * @returns Ein boolescher Wert, der angibt, ob es möglich ist, ein größeres Quadrat zu bilden.\n *\n * Beispiele:\n *   IsSquare(1, [9]) gibt true zurück.\n *   IsSquare(2, [14, 2]) gibt true zurück.\n *   IsSquare(2, [7, 7]) gibt false zurück.\n */\nfunction isSquare(length: number, squares: number[]): boolean",
      "ha": "/**\n * Yana tantance ko yana yiwuwa a tara murabba'ai na katako daga adadin kwanduna\n * zuwa murabba'i guda mafi girma. Kowanne kwando yana dauke da adadin murabba'ai,\n * tare da kowanne murabba'i yana da tsawon gefe daya.\n * \n * @param length - Adadin kwanduna.\n * @param squares - Wani tsari inda kowanne abu ke wakiltar adadin murabba'ai a cikin kwando.\n * @returns Wani boolean yana nuna ko yana yiwuwa a samar da murabba'i mafi girma.\n *\n * Misalai:\n *   IsSquare(1, [9]) returns true.\n *   IsSquare(2, [14, 2]) returns true.\n *   IsSquare(2, [7, 7]) returns false.\n */\nfunction isSquare(length: number, squares: number[]): boolean",
      "hi": "/**\n * यह निर्धारित करता है कि क्या लकड़ी के वर्गों को कई बाल्टियों से इकट्ठा करके\n * एक बड़े वर्ग में बनाया जा सकता है। प्रत्येक बाल्टी में एक निश्चित संख्या में वर्ग होते हैं,\n * जिनमें से प्रत्येक वर्ग की भुजा की लंबाई 1 होती है।\n * \n * @param length - बाल्टियों की संख्या।\n * @param squares - एक array जहाँ प्रत्येक तत्व एक बाल्टी में वर्गों की संख्या को दर्शाता है।\n * @returns एक boolean जो यह दर्शाता है कि क्या एक बड़ा वर्ग बनाना संभव है।\n *\n * उदाहरण:\n *   IsSquare(1, [9]) true लौटाता है।\n *   IsSquare(2, [14, 2]) true लौटाता है।\n *   IsSquare(2, [7, 7]) false लौटाता है।\n */\nfunction isSquare(length: number, squares: number[]): boolean",
      "hu": "/**\n * Meghatározza, hogy lehetséges-e fa négyzeteket összeállítani egy nagyobb négyzetté\n * egy adott számú vödörből. Minden vödör egy meghatározott számú négyzetet tartalmaz,\n * ahol minden négyzet oldalhossza 1.\n * \n * @param length - A vödrök száma.\n * @param squares - Egy tömb, ahol minden elem egy vödörben lévő négyzetek számát jelöli.\n * @returns Egy logikai érték, amely jelzi, hogy lehetséges-e egy nagyobb négyzetet kialakítani.\n *\n * Példák:\n *   IsSquare(1, [9]) visszatérési értéke true.\n *   IsSquare(2, [14, 2]) visszatérési értéke true.\n *   IsSquare(2, [7, 7]) visszatérési értéke false.\n */\nfunction isSquare(length: number, squares: number[]): boolean"
    },
    "prompt_bertscore": {
      "sq": "0.9873003679581533",
      "hy": "0.9709286560621148",
      "bn": "0.9656955400433697",
      "bg": "0.9834979865740026",
      "zh": "0.965322114927024",
      "fr": "0.9910779205446749",
      "de": "0.9783804734370196",
      "ha": "0.9527772159520036",
      "hi": "0.9527803940381002",
      "hu": "0.9694192637966307"
    },
    "canonical_solution": "{\n    let sum: number = 0;\n    for (let i = 0; i < length; ++i) {\n        sum += squares[i]; // Sum the squares\n    }\n    let root: number = Math.floor(Math.sqrt(sum));\n    return root * root === sum; // Check if sum is a perfect square\n}",
    "instruction": {
      "en": "Write a TypeScript function `function isSquare(length: number, squares: number[]): boolean` to solve the following problem:\nDetermines if it is possible to assemble wooden squares from a number of buckets into a single larger square. Each bucket contains a set number of squares, with each square having a side length of 1.\n\nParameters:\n- length - The number of buckets.\n- squares - An array where each element represents the number of squares in a bucket.\n\nReturns A boolean indicating whether it is possible to form a larger square.\n\nExamples:\n  IsSquare(1, [9]) returns true.\n  IsSquare(2, [14, 2]) returns true.\n  IsSquare(2, [7, 7]) returns false.",
      "sq": "Shkruani një funksion TypeScript `function isSquare(length: number, squares: number[]): boolean` për të zgjidhur problemin e mëposhtëm:\nPërcakton nëse është e mundur të montohen katrorë prej druri nga një numër kovash në një katror më të madh. Çdo kovë përmban një numër të caktuar katrorësh, ku çdo katror ka një gjatësi anësore prej 1.\n\nParametrat:\n- length - Numri i kovave.\n- squares - Një varg ku çdo element përfaqëson numrin e katrorëve në një kovë.\n\nKthen Një boolean që tregon nëse është e mundur të formohet një katror më i madh.\n\nShembuj:\n  IsSquare(1, [9]) kthen true.\n  IsSquare(2, [14, 2]) kthen true.\n  IsSquare(2, [7, 7]) kthen false.",
      "hy": "TypeScript ֆունկցիա գրեք `function isSquare(length: number, squares: number[]): boolean`՝ հետևյալ խնդիրը լուծելու համար:\nՈրոշում է, արդյոք հնարավոր է փայտե քառակուսիները մի քանի դույլերից հավաքել մեկ մեծ քառակուսի: Յուրաքանչյուր դույլ պարունակում է որոշակի քանակությամբ քառակուսիներ, որոնցից յուրաքանչյուրի կողի երկարությունը 1 է:\n\nՊարամետրեր:\n- length - Դույլերի քանակը:\n- squares - Զանգված, որտեղ յուրաքանչյուր տարր ներկայացնում է քառակուսիների քանակը մեկ դույլում:\n\nՎերադարձնում է boolean, որը ցույց է տալիս, արդյոք հնարավոր է ձևավորել մեծ քառակուսի:\n\nՕրինակներ:\n  IsSquare(1, [9]) վերադարձնում է true:\n  IsSquare(2, [14, 2]) վերադարձնում է true:\n  IsSquare(2, [7, 7]) վերադարձնում է false:",
      "bn": "TypeScript ফাংশন `function isSquare(length: number, squares: number[]): boolean` লিখুন নিম্নলিখিত সমস্যার সমাধান করতে:\nবুঝুন যে কাঠের বর্গক্ষেত্রগুলি একাধিক বালতি থেকে একটি বড় বর্গক্ষেত্রে একত্রিত করা সম্ভব কিনা। প্রতিটি বালতিতে নির্দিষ্ট সংখ্যক বর্গক্ষেত্র থাকে, যেখানে প্রতিটি বর্গক্ষেত্রের পার্শ্ব দৈর্ঘ্য 1।\n\nপ্যারামিটারসমূহ:\n- length - বালতির সংখ্যা।\n- squares - একটি অ্যারে যেখানে প্রতিটি উপাদান একটি বালতিতে থাকা বর্গক্ষেত্রের সংখ্যা নির্দেশ করে।\n\nফিরে দেয় একটি বুলিয়ান যা নির্দেশ করে যে একটি বড় বর্গক্ষেত্র তৈরি করা সম্ভব কিনা।\n\nউদাহরণসমূহ:\n  IsSquare(1, [9]) true ফেরত দেয়।\n  IsSquare(2, [14, 2]) true ফেরত দেয়।\n  IsSquare(2, [7, 7]) false ফেরত দেয়।",
      "bg": "Напишете TypeScript функция `function isSquare(length: number, squares: number[]): boolean`, за да решите следния проблем:\nОпределя дали е възможно да се сглобят дървени квадрати от определен брой кофи в един по-голям квадрат. Всяка кофа съдържа определен брой квадрати, като всеки квадрат има страна с дължина 1.\n\nПараметри:\n- length - Броят на кофите.\n- squares - Масив, където всеки елемент представлява броя на квадратите в една кофа.\n\nВръща Булева стойност, указваща дали е възможно да се формира по-голям квадрат.\n\nПримери:\n  IsSquare(1, [9]) връща true.\n  IsSquare(2, [14, 2]) връща true.\n  IsSquare(2, [7, 7]) връща false.",
      "zh": "编写一个 TypeScript 函数 `function isSquare(length: number, squares: number[]): boolean` 来解决以下问题：\n确定是否可以将若干桶中的木制正方形组装成一个更大的正方形。每个桶包含一定数量的正方形，每个正方形的边长为 1。\n\n参数：\n- length - 桶的数量。\n- squares - 一个数组，其中每个元素表示一个桶中的正方形数量。\n\n返回值 一个布尔值，指示是否可以形成一个更大的正方形。\n\n示例：\n  IsSquare(1, [9]) 返回 true。\n  IsSquare(2, [14, 2]) 返回 true。\n  IsSquare(2, [7, 7]) 返回 false。",
      "fr": "Écrire une fonction TypeScript `function isSquare(length: number, squares: number[]): boolean` pour résoudre le problème suivant :\nDétermine s'il est possible d'assembler des carrés en bois à partir d'un certain nombre de seaux en un seul carré plus grand. Chaque seau contient un nombre défini de carrés, chaque carré ayant une longueur de côté de 1.\n\nParamètres :\n- length - Le nombre de seaux.\n- squares - Un tableau où chaque élément représente le nombre de carrés dans un seau.\n\nRenvoie Un booléen indiquant s'il est possible de former un carré plus grand.\n\nExemples :\n  IsSquare(1, [9]) renvoie true.\n  IsSquare(2, [14, 2]) renvoie true.\n  IsSquare(2, [7, 7]) renvoie false.",
      "de": "Schreiben Sie eine TypeScript-Funktion `function isSquare(length: number, squares: number[]): boolean`, um das folgende Problem zu lösen:\nBestimmt, ob es möglich ist, Holzquadrate aus einer Anzahl von Eimern zu einem einzigen größeren Quadrat zusammenzusetzen. Jeder Eimer enthält eine bestimmte Anzahl von Quadraten, wobei jedes Quadrat eine Seitenlänge von 1 hat.\n\nParameter:\n- length - Die Anzahl der Eimer.\n- squares - Ein Array, bei dem jedes Element die Anzahl der Quadrate in einem Eimer darstellt.\n\nGibt einen booleschen Wert zurück, der angibt, ob es möglich ist, ein größeres Quadrat zu formen.\n\nBeispiele:\n  IsSquare(1, [9]) gibt true zurück.\n  IsSquare(2, [14, 2]) gibt true zurück.\n  IsSquare(2, [7, 7]) gibt false zurück.",
      "ha": "Rubuta aikin TypeScript `function isSquare(length: number, squares: number[]): boolean` don warware matsalar mai zuwa:\nYana tantance ko yana yiwuwa a tara murabba'ai na katako daga adadin guga zuwa murabba'i guda mafi girma. Kowace guga tana dauke da adadin murabba'ai, tare da kowanne murabba'i yana da tsawon gefe 1.\n\nSigogi:\n- length - Yawan guga.\n- squares - Jeri inda kowane abu ke wakiltar adadin murabba'ai a cikin guga.\n\nYana dawowa da Boolean yana nuna ko yana yiwuwa a samar da murabba'i mafi girma.\n\nMisalai:\n  IsSquare(1, [9]) yana dawowa da true.\n  IsSquare(2, [14, 2]) yana dawowa da true.\n  IsSquare(2, [7, 7]) yana dawowa da false.",
      "hi": "TypeScript फ़ंक्शन `function isSquare(length: number, squares: number[]): boolean` लिखें ताकि निम्नलिखित समस्या का समाधान किया जा सके:\nयह निर्धारित करता है कि क्या लकड़ी के वर्गों को कई बाल्टियों से एक बड़े वर्ग में इकट्ठा करना संभव है। प्रत्येक बाल्टी में वर्गों की एक निश्चित संख्या होती है, जिसमें प्रत्येक वर्ग की भुजा की लंबाई 1 होती है।\n\nपैरामीटर्स:\n- length - बाल्टियों की संख्या।\n- squares - एक array जिसमें प्रत्येक तत्व एक बाल्टी में वर्गों की संख्या का प्रतिनिधित्व करता है।\n\nवापसी एक boolean जो यह इंगित करता है कि क्या एक बड़ा वर्ग बनाना संभव है।\n\nउदाहरण:\n  IsSquare(1, [9]) true लौटाता है।\n  IsSquare(2, [14, 2]) true लौटाता है।\n  IsSquare(2, [7, 7]) false लौटाता है।",
      "hu": "Írj egy TypeScript függvényt `function isSquare(length: number, squares: number[]): boolean` a következő probléma megoldására:\nMeghatározza, hogy lehetséges-e fa négyzeteket összeszerelni egyes vödrökből egyetlen nagyobb négyzetté. Minden vödör egy meghatározott számú négyzetet tartalmaz, ahol minden négyzet oldalhossza 1.\n\nParaméterek:\n- length - A vödrök száma.\n- squares - Egy tömb, ahol minden elem egy vödörben lévő négyzetek számát jelenti.\n\nVisszatérési érték Egy logikai érték, amely jelzi, hogy lehetséges-e egy nagyobb négyzetet kialakítani.\n\nPéldák:\n  IsSquare(1, [9]) visszaadja true.\n  IsSquare(2, [14, 2]) visszaadja true.\n  IsSquare(2, [7, 7]) visszaadja false."
    },
    "instruction_bertscore": {
      "sq": "0.980517736336955",
      "hy": "0.9557254866977044",
      "bn": "0.9436934513665161",
      "bg": "0.9757617304934557",
      "zh": "0.9604101842344123",
      "fr": "0.9830627874091551",
      "de": "0.9891285619851985",
      "ha": "0.9727816788867892",
      "hi": "0.9493438898158155",
      "hu": "0.9816852857166781"
    },
    "level": "easy",
    "test": "const testIsSquare = (): void => {\n    console.assert(isSquare(1, [9]) === true, \"Test 1 failed\");\n    console.assert(isSquare(2, [14, 2]) === true, \"Test 2 failed\");\n    console.assert(isSquare(2, [7, 7]) === false, \"Test 3 failed\");\n    console.assert(isSquare(7, [1, 2, 3, 4, 5, 6, 7]) === false, \"Test 4 failed\");\n    console.assert(isSquare(6, [1, 3, 5, 7, 9, 11]) === true, \"Test 5 failed\");\n    console.assert(isSquare(4, [2, 2, 2, 2]) === false, \"Test 6 failed\");\n    \n    // Additional test cases\n    console.assert(isSquare(3, [4, 5, 6]) === false, \"Additional Test 1 failed\");\n    console.assert(isSquare(4, [16, 9, 4, 1]) === false, \"Additional Test 2 failed\");\n    console.assert(isSquare(5, [1, 1, 1, 1, 1]) === false, \"Additional Test 3 failed\");\n    console.assert(isSquare(2, [25, 25]) === false, \"Additional Test 4 failed\");\n    console.assert(isSquare(3, [10, 10, 5]) === true, \"Additional Test 5 failed\");\n    \n    // console.info(\"All tests passed!\");\n};\n\ntestIsSquare();",
    "entry_point": "isSquare",
    "signature": "function isSquare(length: number, squares: number[]): boolean",
    "docstring": {
      "en": "Determines if it is possible to assemble wooden squares from a number of buckets into a single larger square. Each bucket contains a set number of squares, with each square having a side length of 1.\n\nParameters:\n- length - The number of buckets.\n- squares - An array where each element represents the number of squares in a bucket.\n\nReturns A boolean indicating whether it is possible to form a larger square.\n\nExamples:\n  IsSquare(1, [9]) returns true.\n  IsSquare(2, [14, 2]) returns true.\n  IsSquare(2, [7, 7]) returns false.",
      "sq": "Përcakton nëse është e mundur të montohen katrorë druri nga një numër kovash në një katror më të madh. Çdo kovë përmban një numër të caktuar katrorësh, ku çdo katror ka një gjatësi anësore prej 1.\n\nParametrat:\n- length - Numri i kovave.\n- squares - Një varg ku çdo element përfaqëson numrin e katrorëve në një kovë.\n\nKthen Një vlerë boolean që tregon nëse është e mundur të formohet një katror më i madh.\n\nShembuj:\n  IsSquare(1, [9]) kthen true.\n  IsSquare(2, [14, 2]) kthen true.\n  IsSquare(2, [7, 7]) kthen false.",
      "hy": "Determines if it is possible to assemble wooden squares from a number of buckets into a single larger square. Each bucket contains a set number of squares, with each square having a side length of 1.\n\nՊարամետրեր:\n- length - դույլերի քանակը:\n- squares - զանգված, որտեղ յուրաքանչյուր տարր ներկայացնում է դույլում եղած քառակուսիների քանակը:\n\nՎերադարձնում է Boolean, որը ցույց է տալիս՝ արդյոք հնարավոր է կազմել ավելի մեծ քառակուսի:\n\nՕրինակներ:\n  IsSquare(1, [9]) վերադարձնում է true:\n  IsSquare(2, [14, 2]) վերադարձնում է true:\n  IsSquare(2, [7, 7]) վերադարձնում է false:",
      "bn": "একটি বৃহত্তর বর্গক্ষেত্র তৈরি করা সম্ভব কিনা তা নির্ধারণ করে, যেখানে কাঠের বর্গক্ষেত্রগুলি একাধিক বালতি থেকে একত্রিত করা হয়। প্রতিটি বালতিতে নির্দিষ্ট সংখ্যক বর্গক্ষেত্র থাকে, এবং প্রতিটি বর্গক্ষেত্রের পার্শ্ব দৈর্ঘ্য 1।\n\nপ্যারামিটারসমূহ:\n- length - বালতির সংখ্যা।\n- squares - একটি অ্যারে যেখানে প্রতিটি উপাদান একটি বালতিতে থাকা বর্গক্ষেত্রের সংখ্যা নির্দেশ করে।\n\nফলাফল একটি বুলিয়ান যা নির্দেশ করে যে একটি বৃহত্তর বর্গক্ষেত্র তৈরি করা সম্ভব কিনা।\n\nউদাহরণ:\n  IsSquare(1, [9]) true প্রদান করে।\n  IsSquare(2, [14, 2]) true প্রদান করে।\n  IsSquare(2, [7, 7]) false প্রদান করে।",
      "bg": "Определя дали е възможно да се сглобят дървени квадрати от определен брой кофи в един по-голям квадрат. Всяка кофа съдържа определен брой квадрати, като всеки квадрат има дължина на страната 1.\n\nПараметри:\n- length - Броят на кофите.\n- squares - Масив, където всеки елемент представлява броя на квадратите в една кофа.\n\nВръща Булева стойност, указваща дали е възможно да се образува по-голям квадрат.\n\nПримери:\n  IsSquare(1, [9]) връща true.\n  IsSquare(2, [14, 2]) връща true.\n  IsSquare(2, [7, 7]) връща false.",
      "zh": "确定是否可以将多个桶中的木制方块组合成一个更大的正方形。每个桶包含一定数量的方块，每个方块的边长为1。\n\n参数：\n- length - 桶的数量。\n- squares - 一个数组，其中每个元素表示一个桶中的方块数量。\n\n返回值 一个布尔值，指示是否可以形成一个更大的正方形。\n\n示例：\n  IsSquare(1, [9]) 返回 true。\n  IsSquare(2, [14, 2]) 返回 true。\n  IsSquare(2, [7, 7]) 返回 false。",
      "fr": "Détermine s'il est possible d'assembler des carrés en bois à partir d'un certain nombre de seaux en un seul carré plus grand. Chaque seau contient un nombre défini de carrés, chaque carré ayant une longueur de côté de 1.\n\nParamètres :\n- length - Le nombre de seaux.\n- squares - Un tableau où chaque élément représente le nombre de carrés dans un seau.\n\nRenvoie Un booléen indiquant s'il est possible de former un carré plus grand.\n\nExemples :\n  IsSquare(1, [9]) renvoie true.\n  IsSquare(2, [14, 2]) renvoie true.\n  IsSquare(2, [7, 7]) renvoie false.",
      "de": "Bestimmt, ob es möglich ist, aus einer Anzahl von Eimern Holzquadrate zu einem einzigen größeren Quadrat zusammenzusetzen. Jeder Eimer enthält eine bestimmte Anzahl von Quadraten, wobei jedes Quadrat eine Seitenlänge von 1 hat.\n\nParameter:\n- length - Die Anzahl der Eimer.\n- squares - Ein Array, bei dem jedes Element die Anzahl der Quadrate in einem Eimer darstellt.\n\nGibt einen booleschen Wert zurück, der angibt, ob es möglich ist, ein größeres Quadrat zu bilden.\n\nBeispiele:\n  IsSquare(1, [9]) gibt true zurück.\n  IsSquare(2, [14, 2]) gibt true zurück.\n  IsSquare(2, [7, 7]) gibt false zurück.",
      "ha": "Determines if it is possible to assemble wooden squares from a number of buckets into a single larger square. Each bucket contains a set number of squares, with each square having a side length of 1.\n\nParameters:\n- length - Yawan kwando.\n- squares - Wani tsari inda kowane abu ke wakiltar yawan murabba'ai a cikin kwando.\n\nReturns A boolean indicating whether it is possible to form a larger square.\n\nExamples:\n  IsSquare(1, [9]) returns true.\n  IsSquare(2, [14, 2]) returns true.\n  IsSquare(2, [7, 7]) returns false.",
      "hi": "यह निर्धारित करता है कि क्या लकड़ी के वर्गों की एक संख्या को एकल बड़े वर्ग में इकट्ठा करना संभव है। प्रत्येक बाल्टी में वर्गों की एक निश्चित संख्या होती है, जिसमें प्रत्येक वर्ग की भुजा की लंबाई 1 होती है।\n\nपैरामीटर्स:\n- length - बाल्टियों की संख्या।\n- squares - एक ऐरे जिसमें प्रत्येक तत्व एक बाल्टी में वर्गों की संख्या का प्रतिनिधित्व करता है।\n\nवापसी मान एक बूलियन जो इंगित करता है कि एक बड़ा वर्ग बनाना संभव है या नहीं।\n\nउदाहरण:\n  IsSquare(1, [9]) true लौटाता है।\n  IsSquare(2, [14, 2]) true लौटाता है।\n  IsSquare(2, [7, 7]) false लौटाता है।",
      "hu": "Meghatározza, hogy lehetséges-e fa négyzeteket összeszerelni egy nagyobb négyzetté egy adott számú vödörből. Minden vödör egy meghatározott számú négyzetet tartalmaz, ahol minden négyzet oldalhossza 1.\n\nParaméterek:\n- length - A vödrök száma.\n- squares - Egy tömb, ahol minden elem egy vödörben lévő négyzetek számát jelöli.\n\nVisszatérési érték Egy logikai érték, amely jelzi, hogy lehetséges-e egy nagyobb négyzetet kialakítani.\n\nPéldák:\n  IsSquare(1, [9]) visszaadja true.\n  IsSquare(2, [14, 2]) visszaadja true.\n  IsSquare(2, [7, 7]) visszaadja false."
    },
    "docstring_bertscore": {
      "sq": "0.985971729339411",
      "hy": "0.963465715385872",
      "bn": "0.9411692564843247",
      "bg": "0.9743482767020114",
      "zh": "0.9211610195722995",
      "fr": "0.9827759651389407",
      "de": "0.9855496397797119",
      "ha": "0.994414513685299",
      "hi": "0.9522365440548266",
      "hu": "0.9635421880825704"
    }
  },
  {
    "task_id": "TypeScript/22",
    "prompt": {
      "en": "\n/**\n * Given integers c and d, where a + b = c and a * b = d, find and return the\n * possible value of a (a <= b). If there are multiple pairs, output the pair with\n * the smallest a.\n * \n * @param c - The sum of a and b.\n * @param d - The product of a and b.\n * @returns A possible value of a or -1 if valid values do not exist.\n *\n * Examples:\n *   findIntegers(7, 11) // -1\n *   findIntegers(5, 6)  // 2\n */\nfunction findIntegers(c: number, d: number): number",
      "sq": "/**\n * Duke pasur parasysh numrat e plotë c dhe d, ku a + b = c dhe a * b = d, gjeni dhe ktheni\n * vlerën e mundshme të a (a <= b). Nëse ka çifte të shumta, jepni çiftin me\n * vlerën më të vogël të a.\n * \n * @param c - Shuma e a dhe b.\n * @param d - Produkti i a dhe b.\n * @returns Një vlerë e mundshme e a ose -1 nëse vlerat e vlefshme nuk ekzistojnë.\n *\n * Shembuj:\n *   findIntegers(7, 11) // -1\n *   findIntegers(5, 6)  // 2\n */\nfunction findIntegers(c: number, d: number): number",
      "hy": "/**\n * Տրված են ամբողջ թվեր c և d, որտեղ a + b = c և a * b = d, գտնել և վերադարձնել\n * a-ի հնարավոր արժեքը (a <= b): Եթե կան բազմաթիվ զույգեր, վերադարձնել զույգը\n * ամենափոքր a-ով:\n * \n * @param c - a-ի և b-ի գումարը:\n * @param d - a-ի և b-ի արտադրյալը:\n * @returns a-ի հնարավոր արժեքը կամ -1, եթե վավեր արժեքներ չեն գոյություն ունի:\n *\n * Օրինակներ:\n *   findIntegers(7, 11) // -1\n *   findIntegers(5, 6)  // 2\n */\nfunction findIntegers(c: number, d: number): number",
      "bn": "/**\n * প্রদত্ত পূর্ণসংখ্যা c এবং d, যেখানে a + b = c এবং a * b = d, a এর সম্ভাব্য মান খুঁজে বের করুন এবং ফেরত দিন (a <= b)। \n * যদি একাধিক জোড়া থাকে, তাহলে সবচেয়ে ছোট a সহ জোড়াটি আউটপুট করুন।\n * \n * @param c - a এবং b এর যোগফল।\n * @param d - a এবং b এর গুণফল।\n * @returns a এর একটি সম্ভাব্য মান বা -1 যদি বৈধ মান বিদ্যমান না থাকে।\n *\n * উদাহরণ:\n *   findIntegers(7, 11) // -1\n *   findIntegers(5, 6)  // 2\n */\nfunction findIntegers(c: number, d: number): number",
      "bg": "/**\n * Дадени са цели числа c и d, където a + b = c и a * b = d, намерете и върнете\n * възможната стойност на a (a <= b). Ако има множество двойки, изведете двойката с\n * най-малката a.\n * \n * @param c - Сумата на a и b.\n * @param d - Произведението на a и b.\n * @returns Възможна стойност на a или -1, ако не съществуват валидни стойности.\n *\n * Примери:\n *   findIntegers(7, 11) // -1\n *   findIntegers(5, 6)  // 2\n */\nfunction findIntegers(c: number, d: number): number",
      "zh": "/**\n * 给定整数 c 和 d，其中 a + b = c 且 a * b = d，找到并返回 a 的可能值 (a <= b)。\n * 如果有多个配对，输出具有最小 a 的配对。\n * \n * @param c - a 和 b 的和。\n * @param d - a 和 b 的积。\n * @returns a 的可能值，如果不存在有效值则返回 -1。\n *\n * 例子:\n *   findIntegers(7, 11) // -1\n *   findIntegers(5, 6)  // 2\n */\nfunction findIntegers(c: number, d: number): number",
      "fr": "/**\n * Étant donné les entiers c et d, où a + b = c et a * b = d, trouver et retourner la\n * valeur possible de a (a <= b). S'il y a plusieurs paires, retourner la paire avec\n * le plus petit a.\n * \n * @param c - La somme de a et b.\n * @param d - Le produit de a et b.\n * @returns Une valeur possible de a ou -1 si des valeurs valides n'existent pas.\n *\n * Exemples :\n *   findIntegers(7, 11) // -1\n *   findIntegers(5, 6)  // 2\n */\nfunction findIntegers(c: number, d: number): number",
      "de": "/**\n * Gegeben sind die ganzen Zahlen c und d, wobei a + b = c und a * b = d. Finde und gib den\n * möglichen Wert von a zurück (a <= b). Wenn es mehrere Paare gibt, gib das Paar mit\n * dem kleinsten a aus.\n * \n * @param c - Die Summe von a und b.\n * @param d - Das Produkt von a und b.\n * @returns Einen möglichen Wert von a oder -1, wenn keine gültigen Werte existieren.\n *\n * Beispiele:\n *   findIntegers(7, 11) // -1\n *   findIntegers(5, 6)  // 2\n */\nfunction findIntegers(c: number, d: number): number",
      "ha": "/**\n * An ba da lambobi c da d, inda a + b = c kuma a * b = d, nemo kuma dawo da\n * yiwuwar ƙimar a (a <= b). Idan akwai ma'aurata da yawa, fitar da ma'aurata tare da\n * ƙaramin a.\n * \n * @param c - Jimillar a da b.\n * @param d - Samfurin a da b.\n * @returns Yiwuwar ƙimar a ko -1 idan babu ƙimar da ta dace.\n *\n * Misalai:\n *   findIntegers(7, 11) // -1\n *   findIntegers(5, 6)  // 2\n */\nfunction findIntegers(c: number, d: number): number",
      "hi": "/**\n * दिए गए पूर्णांक c और d के लिए, जहाँ a + b = c और a * b = d, a का संभावित मान खोजें और लौटाएँ (a <= b)। \n * यदि कई जोड़े हैं, तो सबसे छोटे a वाले जोड़े को आउटपुट करें।\n * \n * @param c - a और b का योग।\n * @param d - a और b का गुणनफल।\n * @returns a का संभावित मान या -1 यदि मान्य मान मौजूद नहीं हैं।\n *\n * उदाहरण:\n *   findIntegers(7, 11) // -1\n *   findIntegers(5, 6)  // 2\n */\nfunction findIntegers(c: number, d: number): number",
      "hu": "/**\n * Adott két egész szám, c és d, ahol a + b = c és a * b = d, találja meg és adja vissza\n * a lehetséges a értékét (a <= b). Ha több pár is létezik, adja vissza azt a párt,\n * amelyiknél a legkisebb az a.\n * \n * @param c - a és b összege.\n * @param d - a és b szorzata.\n * @returns A lehetséges a értéke vagy -1, ha nem léteznek érvényes értékek.\n *\n * Példák:\n *   findIntegers(7, 11) // -1\n *   findIntegers(5, 6)  // 2\n */\nfunction findIntegers(c: number, d: number): number"
    },
    "prompt_bertscore": {
      "sq": "0.9812393605112548",
      "hy": "0.9835752537922251",
      "bn": "0.9702417922044961",
      "bg": "0.989814829951674",
      "zh": "0.9786317408690288",
      "fr": "0.9921342369110184",
      "de": "0.9799677288118694",
      "ha": "0.984576946803784",
      "hi": "0.9659509787133805",
      "hu": "0.9661851639326207"
    },
    "canonical_solution": "{\n    for (let i = 0; i <= c / 2; i++) {\n        if (i * (c - i) !== d) continue;\n        return i;\n    }\n    return -1; // Return -1 if no valid pairs (a, b) are found.\n}",
    "instruction": {
      "en": "Write a TypeScript function `function findIntegers(c: number, d: number): number` to solve the following problem:\nGiven integers c and d, where a + b = c and a * b = d, find and return the\npossible value of a (a <= b). If there are multiple pairs, output the pair with\nthe smallest a.\n\n@param c - The sum of a and b.\n@param d - The product of a and b.\n@returns A possible value of a or -1 if valid values do not exist.\n\nExamples:\n  findIntegers(7, 11) // -1\n  findIntegers(5, 6)  // 2",
      "sq": "Shkruani një funksion TypeScript `function findIntegers(c: number, d: number): number` për të zgjidhur problemin e mëposhtëm:\nDuke pasur parasysh numrat c dhe d, ku a + b = c dhe a * b = d, gjeni dhe ktheni\nvlerën e mundshme të a (a <= b). Nëse ka disa çifte, jepni çiftin me\nvlerën më të vogël të a.\n\n@param c - Shuma e a dhe b.\n@param d - Produkti i a dhe b.\n@returns Një vlerë e mundshme e a ose -1 nëse vlerat e vlefshme nuk ekzistojnë.\n\nShembuj:\n  findIntegers(7, 11) // -1\n  findIntegers(5, 6)  // 2",
      "hy": "Գրեք TypeScript ֆունկցիա `function findIntegers(c: number, d: number): number`՝ լուծելու հետևյալ խնդիրը:\nՏրված են ամբողջ թվեր c և d, որտեղ a + b = c և a * b = d, գտնել և վերադարձնել\na-ի հնարավոր արժեքը (a <= b): Եթե գոյություն ունեն բազմաթիվ զույգեր, վերադարձնել զույգը ամենափոքր a-ով:\n\n@param c - a-ի և b-ի գումարը:\n@param d - a-ի և b-ի արտադրյալը:\n@returns a-ի հնարավոր արժեքը կամ -1, եթե վավեր արժեքներ գոյություն չունեն:\n\nՕրինակներ:\n  findIntegers(7, 11) // -1\n  findIntegers(5, 6)  // 2",
      "bn": "TypeScript ফাংশন `function findIntegers(c: number, d: number): number` লিখুন নিম্নলিখিত সমস্যার সমাধানের জন্য:\nপ্রদত্ত পূর্ণসংখ্যা c এবং d, যেখানে a + b = c এবং a * b = d, a এর সম্ভাব্য মান খুঁজে বের করুন এবং ফেরত দিন (a <= b)। যদি একাধিক জোড়া থাকে, তাহলে সবচেয়ে ছোট a সহ জোড়াটি আউটপুট করুন।\n\n@param c - a এবং b এর যোগফল।\n@param d - a এবং b এর গুণফল।\n@returns a এর একটি সম্ভাব্য মান বা -1 যদি বৈধ মান বিদ্যমান না থাকে।\n\nউদাহরণ:\n  findIntegers(7, 11) // -1\n  findIntegers(5, 6)  // 2",
      "bg": "Напишете функция на TypeScript `function findIntegers(c: number, d: number): number`, за да решите следния проблем:\nДадени са цели числа c и d, където a + b = c и a * b = d, намерете и върнете\nвъзможната стойност на a (a <= b). Ако има множество двойки, изведете двойката с\nнай-малката a.\n\n@param c - Сумата на a и b.\n@param d - Произведението на a и b.\n@returns Възможна стойност на a или -1, ако не съществуват валидни стойности.\n\nПримери:\n  findIntegers(7, 11) // -1\n  findIntegers(5, 6)  // 2",
      "zh": "编写一个 TypeScript 函数 `function findIntegers(c: number, d: number): number` 来解决以下问题：\n给定整数 c 和 d，其中 a + b = c 且 a * b = d，找到并返回 a 的可能值 (a <= b)。如果有多个配对，输出具有最小 a 的配对。\n\n@param c - a 和 b 的和。\n@param d - a 和 b 的积。\n@returns a 的一个可能值，如果不存在有效值则返回 -1。\n\n示例：\n  findIntegers(7, 11) // -1\n  findIntegers(5, 6)  // 2",
      "fr": "Écrire une fonction TypeScript `function findIntegers(c: number, d: number): number` pour résoudre le problème suivant :\nÉtant donné les entiers c et d, où a + b = c et a * b = d, trouver et retourner la\nvaleur possible de a (a <= b). S'il y a plusieurs paires, afficher la paire avec\nle plus petit a.\n\n@param c - La somme de a et b.\n@param d - Le produit de a et b.\n@returns Une valeur possible de a ou -1 si des valeurs valides n'existent pas.\n\nExemples :\n  findIntegers(7, 11) // -1\n  findIntegers(5, 6)  // 2",
      "de": "Schreiben Sie eine TypeScript-Funktion `function findIntegers(c: number, d: number): number`, um das folgende Problem zu lösen:\nGegeben sind die ganzen Zahlen c und d, wobei a + b = c und a * b = d, finden und geben Sie den möglichen Wert von a zurück (a <= b). Wenn es mehrere Paare gibt, geben Sie das Paar mit dem kleinsten a aus.\n\n@param c - Die Summe von a und b.\n@param d - Das Produkt von a und b.\n@returns Ein möglicher Wert von a oder -1, wenn keine gültigen Werte existieren.\n\nBeispiele:\n  findIntegers(7, 11) // -1\n  findIntegers(5, 6)  // 2",
      "ha": "Rubuta aikin TypeScript `function findIntegers(c: number, d: number): number` don warware matsalar mai zuwa:\nAn ba da lambobi c da d, inda a + b = c da a * b = d, nemo kuma dawo da\nyuwuwar ƙimar a (a <= b). Idan akwai nau'i-nau'i da yawa, fitar da nau'i tare da\nkaramin a.\n\n@param c - Jimillar a da b.\n@param d - Samfurin a da b.\n@returns Yuwuwar ƙimar a ko -1 idan ba a sami ƙimar da ta dace ba.\n\nMisalai:\n  findIntegers(7, 11) // -1\n  findIntegers(5, 6)  // 2",
      "hi": "TypeScript फ़ंक्शन `function findIntegers(c: number, d: number): number` लिखें ताकि निम्नलिखित समस्या का समाधान किया जा सके:\nदिए गए पूर्णांक c और d, जहाँ a + b = c और a * b = d, a का संभावित मान खोजें और लौटाएँ (a <= b)। यदि कई जोड़े हैं, तो सबसे छोटे a वाले जोड़े को आउटपुट करें।\n\n@param c - a और b का योग।\n@param d - a और b का गुणनफल।\n@returns a का संभावित मान या -1 यदि मान्य मान मौजूद नहीं हैं।\n\nउदाहरण:\n  findIntegers(7, 11) // -1\n  findIntegers(5, 6)  // 2",
      "hu": "Írj egy TypeScript függvényt `function findIntegers(c: number, d: number): number` a következő probléma megoldására:\nAdottak az egész számok c és d, ahol a + b = c és a * b = d, találd meg és add vissza a\nlehetséges a értékét (a <= b). Ha több pár is létezik, add vissza azt a párt, amelyiknél a legkisebb az a.\n\n@param c - Az a és b összege.\n@param d - Az a és b szorzata.\n@returns Egy lehetséges a érték vagy -1, ha nem léteznek érvényes értékek.\n\nPéldák:\n  findIntegers(7, 11) // -1\n  findIntegers(5, 6)  // 2"
    },
    "instruction_bertscore": {
      "sq": "0.978917371356957",
      "hy": "0.984759289493574",
      "bn": "0.9808869902152989",
      "bg": "0.9885372393408577",
      "zh": "0.9825179442739764",
      "fr": "0.9917312158678986",
      "de": "0.9903646388463786",
      "ha": "0.9720248971350464",
      "hi": "0.963909852917866",
      "hu": "0.9793307211798906"
    },
    "level": "easy",
    "test": "const testFindIntegers = () => {\n    console.assert(findIntegers(5, 6) === 2, 'Test 1 failed');\n    console.assert(findIntegers(6, 9) === 3, 'Test 2 failed');\n    console.assert(findIntegers(7, 12) === 3, 'Test 3 failed');\n    console.assert(findIntegers(7, 11) === -1, 'Test 4 failed');\n    console.assert(findIntegers(9, 8) === 1, 'Test 5 failed');\n    console.assert(findIntegers(10, 25) === 5, 'Test 6 failed');\n    console.assert(findIntegers(10000, 8765) === -1, 'Test 7 failed');\n\n    // console.log(\"All tests passed successfully.\");\n};\n\ntestFindIntegers();",
    "entry_point": "findIntegers",
    "signature": "function findIntegers(c: number, d: number): number",
    "docstring": {
      "en": "Given integers c and d, where a + b = c and a * b = d, find and return the\npossible value of a (a <= b). If there are multiple pairs, output the pair with\nthe smallest a.\n\n@param c - The sum of a and b.\n@param d - The product of a and b.\n@returns A possible value of a or -1 if valid values do not exist.\n\nExamples:\n  findIntegers(7, 11) // -1\n  findIntegers(5, 6)  // 2",
      "sq": "Given numrat e plotë c dhe d, ku a + b = c dhe a * b = d, gjeni dhe ktheni\nvlerën e mundshme të a (a <= b). Nëse ka disa çifte, jepni çiftin me\nvlerën më të vogël të a.\n\n@param c - Shuma e a dhe b.\n@param d - Produkti i a dhe b.\n@returns Një vlerë e mundshme e a ose -1 nëse vlerat e vlefshme nuk ekzistojnë.\n\nShembuj:\n  findIntegers(7, 11) // -1\n  findIntegers(5, 6)  // 2",
      "hy": "Տրված են ամբողջ թվեր c և d, որտեղ a + b = c և a * b = d, գտնել և վերադարձնել a-ի հնարավոր արժեքը (a <= b): Եթե գոյություն ունեն բազմաթիվ զույգեր, վերադարձնել զույգը ամենափոքր a-ով:\n\n@param c - a-ի և b-ի գումարը:\n@param d - a-ի և b-ի արտադրյալը:\n@returns a-ի հնարավոր արժեքը կամ -1, եթե վավեր արժեքներ չեն գոյություն ունենում:\n\nՕրինակներ:\n  findIntegers(7, 11) // -1\n  findIntegers(5, 6)  // 2",
      "bn": "Given integers c and d, where a + b = c and a * b = d, find and return the possible value of a (a <= b). If there are multiple pairs, output the pair with the smallest a.\n\n@param c - a এবং b এর যোগফল।\n@param d - a এবং b এর গুণফল।\n@returns a এর একটি সম্ভাব্য মান বা -1 যদি বৈধ মান বিদ্যমান না থাকে।\n\nউদাহরণসমূহ:\n  findIntegers(7, 11) // -1\n  findIntegers(5, 6)  // 2",
      "bg": "Дадени са цели числа c и d, където a + b = c и a * b = d, намерете и върнете\nвъзможната стойност на a (a <= b). Ако има няколко двойки, изведете двойката с\nнай-малката стойност на a.\n\n@param c - Сборът на a и b.\n@param d - Произведението на a и b.\n@returns Възможна стойност на a или -1, ако не съществуват валидни стойности.\n\nПримери:\n  findIntegers(7, 11) // -1\n  findIntegers(5, 6)  // 2",
      "zh": "Given integers c and d, where a + b = c and a * b = d, find and return the possible value of a (a <= b). If there are multiple pairs, output the pair with the smallest a.\n\n@param c - a 和 b 的和。\n@param d - a 和 b 的积。\n@returns a 的一个可能值，如果不存在有效值则返回 -1。\n\nExamples:\n  findIntegers(7, 11) // -1\n  findIntegers(5, 6)  // 2",
      "fr": "Given integers c and d, where a + b = c and a * b = d, find and return the possible value of a (a <= b). If there are multiple pairs, output the pair with the smallest a.\n\n@param c - La somme de a et b.\n@param d - Le produit de a et b.\n@returns Une valeur possible de a ou -1 si des valeurs valides n'existent pas.\n\nExemples:\n  findIntegers(7, 11) // -1\n  findIntegers(5, 6)  // 2",
      "de": "Given integers c and d, wobei a + b = c und a * b = d, finde und gib den möglichen Wert von a zurück (a <= b). Wenn es mehrere Paare gibt, gib das Paar mit dem kleinsten a aus.\n\n@param c - Die Summe von a und b.\n@param d - Das Produkt von a und b.\n@returns Ein möglicher Wert von a oder -1, wenn keine gültigen Werte existieren.\n\nBeispiele:\n  findIntegers(7, 11) // -1\n  findIntegers(5, 6)  // 2",
      "ha": "Given integers c and d, where a + b = c and a * b = d, find and return the possible value of a (a <= b). If there are multiple pairs, output the pair with the smallest a.\n\n@param c - Jimillar a da b.\n@param d - Samfurin a da b.\n@returns Wata ƙima ta a ko -1 idan ƙimar da ta dace ba ta wanzu ba.\n\nMisalai:\n  findIntegers(7, 11) // -1\n  findIntegers(5, 6)  // 2",
      "hi": "Given integers c and d, where a + b = c and a * b = d, find and return the possible value of a (a <= b). If there are multiple pairs, output the pair with the smallest a.\n\n@param c - a और b का योग।\n@param d - a और b का गुणनफल।\n@returns a का एक संभावित मान या -1 यदि मान्य मान मौजूद नहीं हैं।\n\nउदाहरण:\n  findIntegers(7, 11) // -1\n  findIntegers(5, 6)  // 2",
      "hu": "Given integers c and d, where a + b = c and a * b = d, find and return the possible value of a (a <= b). If there are multiple pairs, output the pair with the smallest a.\n\n@param c - a és b összege.\n@param d - a és b szorzata.\n@returns A lehetséges a érték vagy -1, ha nincsenek érvényes értékek.\n\nPéldák:\n  findIntegers(7, 11) // -1\n  findIntegers(5, 6)  // 2"
    },
    "docstring_bertscore": {
      "sq": "0.977277677561514",
      "hy": "0.9795847694372342",
      "bn": "0.9803461196877409",
      "bg": "0.9854179478370858",
      "zh": "0.9832679725927641",
      "fr": "0.9966079889830672",
      "de": "0.9923956344924604",
      "ha": "0.9763314024262637",
      "hi": "0.9801604002814733",
      "hu": "0.9828558145521167"
    }
  },
  {
    "task_id": "TypeScript/23",
    "prompt": {
      "en": "\n/**\n * Count the number of acute-angled triangles that can be formed by selecting any 3 edges out of a given set of edges.\n * \n * @param edges An array of integers representing the lengths of the edges.\n * @returns The count of distinct acute-angled triangles that can be formed.\n * \n * Examples:\n * ```\n * countAcuteTriangles([1, 1, 1, 1])\n * // returns 4\n * ```\n */\nfunction countAcuteTriangles(edges: number[]): number",
      "sq": "/**\n * Numëron numrin e trekëndëshave këndakut që mund të formohen duke zgjedhur cilindo 3 brinjë nga një grup i dhënë brinjësh.\n * \n * @param edges Një varg me numra të plotë që përfaqësojnë gjatësitë e brinjëve.\n * @returns Numri i trekëndëshave të dallueshëm këndakut që mund të formohen.\n * \n * Shembuj:\n * ```\n * countAcuteTriangles([1, 1, 1, 1])\n * // kthen 4\n * ```\n */\nfunction countAcuteTriangles(edges: number[]): number",
      "hy": "/**\n * Հաշվել սուրանկյուն եռանկյունիների քանակը, որոնք կարող են կազմվել ընտրելով ցանկացած 3 կողերից տրված կողերի հավաքածուից։\n * \n * @param edges Թվերի զանգված, որը ներկայացնում է կողերի երկարությունները։\n * @returns Տարբեր սուրանկյուն եռանկյունիների քանակը, որոնք կարող են կազմվել։\n * \n * Օրինակներ:\n * ```\n * countAcuteTriangles([1, 1, 1, 1])\n * // վերադարձնում է 4\n * ```\n */\nfunction countAcuteTriangles(edges: number[]): number",
      "bn": "/**\n * প্রদত্ত প্রান্তগুলির একটি সেট থেকে যেকোন 3টি প্রান্ত নির্বাচন করে কতগুলি তীক্ষ্ণ-কোণযুক্ত ত্রিভুজ তৈরি করা যায় তা গণনা করুন।\n * \n * @param edges প্রান্তগুলির দৈর্ঘ্য উপস্থাপনকারী পূর্ণসংখ্যার একটি অ্যারে।\n * @returns গঠিত হতে পারে এমন স্বতন্ত্র তীক্ষ্ণ-কোণযুক্ত ত্রিভুজের সংখ্যা।\n * \n * উদাহরণ:\n * ```\n * countAcuteTriangles([1, 1, 1, 1])\n * // returns 4\n * ```\n */\nfunction countAcuteTriangles(edges: number[]): number",
      "bg": "/**\n * Пребройте броя на острите триъгълници, които могат да бъдат образувани чрез избиране на произволни 3 ръба от даден набор от ръбове.\n * \n * @param edges Масив от цели числа, представляващи дължините на ръбовете.\n * @returns Броят на различните остри триъгълници, които могат да бъдат образувани.\n * \n * Примери:\n * ```\n * countAcuteTriangles([1, 1, 1, 1])\n * // returns 4\n * ```\n */\nfunction countAcuteTriangles(edges: number[]): number",
      "zh": "/**\n * 计算可以通过从给定的边集合中选择任意3条边形成的锐角三角形的数量。\n * \n * @param edges 一个整数数组，表示边的长度。\n * @returns 可以形成的不同锐角三角形的数量。\n * \n * 示例:\n * ```\n * countAcuteTriangles([1, 1, 1, 1])\n * // 返回 4\n * ```\n */\nfunction countAcuteTriangles(edges: number[]): number",
      "fr": "/**\n * Compter le nombre de triangles acutangles qui peuvent être formés en sélectionnant 3 arêtes parmi un ensemble donné d'arêtes.\n * \n * @param edges Un tableau d'entiers représentant les longueurs des arêtes.\n * @returns Le nombre de triangles acutangles distincts qui peuvent être formés.\n * \n * Exemples :\n * ```\n * countAcuteTriangles([1, 1, 1, 1])\n * // returns 4\n * ```\n */\nfunction countAcuteTriangles(edges: number[]): number",
      "de": "/**\n * Zähle die Anzahl der spitzwinkligen Dreiecke, die gebildet werden können, indem beliebige 3 Kanten aus einem gegebenen Satz von Kanten ausgewählt werden.\n * \n * @param edges Ein Array von ganzen Zahlen, das die Längen der Kanten darstellt.\n * @returns Die Anzahl der verschiedenen spitzwinkligen Dreiecke, die gebildet werden können.\n * \n * Beispiele:\n * ```\n * countAcuteTriangles([1, 1, 1, 1])\n * // gibt 4 zurück\n * ```\n */\nfunction countAcuteTriangles(edges: number[]): number",
      "ha": "/**\n * Ƙirga adadin kusurwoyi masu kaifi da za a iya samarwa ta hanyar zaɓar kowane gefuna 3 daga cikin wani saiti na gefuna.\n * \n * @param edges Wani tsari na lambobi da ke wakiltar tsawon gefuna.\n * @returns Adadin kusurwoyi masu kaifi daban-daban da za a iya samarwa.\n * \n * Misalai:\n * ```\n * countAcuteTriangles([1, 1, 1, 1])\n * // returns 4\n * ```\n */\nfunction countAcuteTriangles(edges: number[]): number",
      "hi": "/**\n * दिए गए किनारों के सेट में से किसी भी 3 किनारों का चयन करके बनने वाले तीव्र कोण वाले त्रिभुजों की संख्या गिनें।\n * \n * @param edges किनारों की लंबाई का प्रतिनिधित्व करने वाले पूर्णांकों की एक सरणी।\n * @returns बनने वाले विभिन्न तीव्र कोण वाले त्रिभुजों की गिनती।\n * \n * उदाहरण:\n * ```\n * countAcuteTriangles([1, 1, 1, 1])\n * // returns 4\n * ```\n */\nfunction countAcuteTriangles(edges: number[]): number",
      "hu": "/**\n * Számolja meg a hegyesszögű háromszögek számát, amelyeket a megadott élek halmazából bármely 3 él kiválasztásával lehet kialakítani.\n * \n * @param edges Egész számokat tartalmazó tömb, amely az élek hosszát jelöli.\n * @returns A kialakítható különböző hegyesszögű háromszögek száma.\n * \n * Példák:\n * ```\n * countAcuteTriangles([1, 1, 1, 1])\n * // visszaadja: 4\n * ```\n */\nfunction countAcuteTriangles(edges: number[]): number"
    },
    "prompt_bertscore": {
      "sq": "0.9669771032618067",
      "hy": "0.9394560694478988",
      "bn": "0.9765782999898901",
      "bg": "0.9714303964046089",
      "zh": "0.9552243422463534",
      "fr": "0.9657420195525318",
      "de": "0.9673976037784576",
      "ha": "0.9523634688683079",
      "hi": "0.9861405651632906",
      "hu": "0.9616845967591321"
    },
    "canonical_solution": "{\n    // Sort the edges in non-decreasing order\n    edges.sort((a, b) => a - b);\n\n    let sum = 0;\n    for (let i = 0; i < edges.length - 2; i++) {\n        for (let j = i + 1; j < edges.length - 1; j++) {\n            for (let k = j + 1; k < edges.length; k++) {\n                let x = edges[i], y = edges[j], z = edges[k];\n                // Check if the edges form an acute-angled triangle\n                if (x + y > z && x * x + y * y > z * z) {\n                    sum++;\n                }\n            }\n        }\n    }\n\n    return sum;\n}",
    "instruction": {
      "en": "Write a TypeScript function `function countAcuteTriangles(edges: number[]): number` to solve the following problem:\nCount the number of acute-angled triangles that can be formed by selecting any 3 edges out of a given set of edges.\n\n@param edges An array of integers representing the lengths of the edges.\n@returns The count of distinct acute-angled triangles that can be formed.\n\nExamples:\ncountAcuteTriangles([1, 1, 1, 1])\n// returns 4",
      "sq": "Shkruani një funksion TypeScript `function countAcuteTriangles(edges: number[]): number` për të zgjidhur problemin e mëposhtëm:\nNumëroni numrin e trekëndëshave me kënd të mprehtë që mund të formohen duke zgjedhur çdo 3 brinjë nga një grup i dhënë brinjësh.\n\n@param edges Një varg i numrave të plotë që përfaqësojnë gjatësitë e brinjëve.\n@returns Numri i trekëndëshave të dallueshëm me kënd të mprehtë që mund të formohen.\n\nShembuj:\ncountAcuteTriangles([1, 1, 1, 1])\n// kthen 4",
      "hy": "Գրեք TypeScript ֆունկցիա `function countAcuteTriangles(edges: number[]): number`՝ լուծելու հետևյալ խնդիրը:\nՀաշվեք սուրանկյուն եռանկյունիների քանակը, որոնք կարող են կազմվել տրված կողերի հավաքածուից ցանկացած 3 կող ընտրելով:\n\n@param edges Թվերի զանգված, որը ներկայացնում է կողերի երկարությունները:\n@returns Տարբեր սուրանկյուն եռանկյունիների քանակը, որոնք կարող են կազմվել:\n\nՕրինակներ:\ncountAcuteTriangles([1, 1, 1, 1])\n// վերադարձնում է 4",
      "bn": "TypeScript ফাংশন `function countAcuteTriangles(edges: number[]): number` লিখুন নিম্নলিখিত সমস্যার সমাধানের জন্য:\nপ্রদত্ত প্রান্তগুলির একটি সেট থেকে যেকোনো 3 প্রান্ত নির্বাচন করে গঠিত তীক্ষ্ণ-কোণী ত্রিভুজগুলির সংখ্যা গণনা করুন।\n\n@param edges প্রান্তগুলির দৈর্ঘ্য উপস্থাপনকারী পূর্ণসংখ্যার একটি অ্যারে।\n@returns গঠিত হতে পারে এমন স্বতন্ত্র তীক্ষ্ণ-কোণী ত্রিভুজগুলির সংখ্যা।\n\nউদাহরণ:\ncountAcuteTriangles([1, 1, 1, 1])\n// 4 ফেরত দেয়",
      "bg": "Напишете TypeScript функция `function countAcuteTriangles(edges: number[]): number`, за да решите следния проблем:  \nПребройте броя на острите триъгълници, които могат да бъдат образувани чрез избиране на произволни 3 ръба от даден набор от ръбове.\n\n@param edges Масив от цели числа, представляващи дължините на ръбовете.\n@returns Броят на различните остри триъгълници, които могат да бъдат образувани.\n\nПримери:\ncountAcuteTriangles([1, 1, 1, 1])\n// връща 4",
      "zh": "编写一个 TypeScript 函数 `function countAcuteTriangles(edges: number[]): number` 来解决以下问题：\n计算可以通过从给定的边集中选择任意 3 条边形成的锐角三角形的数量。\n\n@param edges 一个整数数组，表示边的长度。\n@returns 可以形成的不同锐角三角形的数量。\n\n例子：\ncountAcuteTriangles([1, 1, 1, 1])\n// 返回 4",
      "fr": "Écrire une fonction TypeScript `function countAcuteTriangles(edges: number[]): number` pour résoudre le problème suivant :\nCompter le nombre de triangles acutangles qui peuvent être formés en sélectionnant 3 arêtes parmi un ensemble donné d'arêtes.\n\n@param edges Un tableau d'entiers représentant les longueurs des arêtes.\n@returns Le nombre de triangles acutangles distincts qui peuvent être formés.\n\nExemples :\ncountAcuteTriangles([1, 1, 1, 1])\n// returns 4",
      "de": "Schreiben Sie eine TypeScript-Funktion `function countAcuteTriangles(edges: number[]): number`, um das folgende Problem zu lösen:\nZählen Sie die Anzahl der spitzwinkligen Dreiecke, die gebildet werden können, indem Sie beliebige 3 Kanten aus einem gegebenen Satz von Kanten auswählen.\n\n@param edges Ein Array von ganzen Zahlen, das die Längen der Kanten darstellt.\n@returns Die Anzahl der unterschiedlichen spitzwinkligen Dreiecke, die gebildet werden können.\n\nBeispiele:\ncountAcuteTriangles([1, 1, 1, 1])\n// gibt 4 zurück",
      "ha": "Rubuta aikin TypeScript `function countAcuteTriangles(edges: number[]): number` don warware matsalar mai zuwa:\nƘirga adadin kusurwoyin triangles masu kaifi waɗanda za a iya samarwa ta hanyar zaɓar kowane 3 gefuna daga saitin gefuna da aka bayar.\n\n@param edges Wani tsararren lambobi da ke wakiltar tsawon gefuna.\n@returns Adadin kusurwoyin triangles masu kaifi daban-daban waɗanda za a iya samarwa.\n\nMisalai:\ncountAcuteTriangles([1, 1, 1, 1])\n// yana dawowa 4",
      "hi": "TypeScript फ़ंक्शन `function countAcuteTriangles(edges: number[]): number` लिखें ताकि निम्नलिखित समस्या का समाधान किया जा सके:\nदिए गए किनारों के सेट में से किसी भी 3 किनारों का चयन करके बनने वाले तीव्र कोण त्रिभुजों की संख्या गिनें।\n\n@param edges किनारों की लंबाई को दर्शाने वाले पूर्णांकों की एक सरणी।\n@returns बनने वाले विशिष्ट तीव्र कोण त्रिभुजों की संख्या।\n\nउदाहरण:\ncountAcuteTriangles([1, 1, 1, 1])\n// 4 लौटाता है",
      "hu": "Írj egy TypeScript függvényt `function countAcuteTriangles(edges: number[]): number` a következő probléma megoldására:\nSzámold meg, hány hegyesszögű háromszög alakítható ki úgy, hogy a megadott élek halmazából bármely 3 élt kiválasztasz.\n\n@param edges Egész számokat tartalmazó tömb, amely az élek hosszát jelöli.\n@returns A különböző hegyesszögű háromszögek száma, amelyek kialakíthatók.\n\nPéldák:\ncountAcuteTriangles([1, 1, 1, 1])\n// visszaadja: 4"
    },
    "instruction_bertscore": {
      "sq": "0.9750661268990716",
      "hy": "0.9614875554211455",
      "bn": "0.9629850298637675",
      "bg": "0.9654675123659416",
      "zh": "0.9565678781436734",
      "fr": "0.9720443629123877",
      "de": "0.976497854685571",
      "ha": "0.9609474794151117",
      "hi": "0.970064216643851",
      "hu": "0.9596730668903918"
    },
    "level": "hard",
    "test": "(() => {\n    // Test function using console.assert for validation\n    console.assert(countAcuteTriangles([1, 1, 1, 1]) === 4, \"Test 1 Failed\");\n    console.assert(countAcuteTriangles([1, 2, 3]) === 0, \"Test 2 Failed\");\n    // Additional tests to ensure correctness\n    console.assert(countAcuteTriangles([3, 4, 5, 7, 10]) === 0, \"Test 3 Failed\");\n    console.assert(countAcuteTriangles([6, 8, 10, 5, 5, 5]) === 4, \"Test 4 Failed\");\n    // console.log(\"All tests passed!\");\n})();",
    "entry_point": "countAcuteTriangles",
    "signature": "function countAcuteTriangles(edges: number[]): number",
    "docstring": {
      "en": "Count the number of acute-angled triangles that can be formed by selecting any 3 edges out of a given set of edges.\n\n@param edges An array of integers representing the lengths of the edges.\n@returns The count of distinct acute-angled triangles that can be formed.\n\nExamples:\ncountAcuteTriangles([1, 1, 1, 1])\n// returns 4",
      "sq": "Numëroni numrin e trekëndëshave këndakut që mund të formohen duke zgjedhur çdo 3 brinjë nga një grup i dhënë brinjësh.\n\n@param edges Një varg me numra të plotë që përfaqësojnë gjatësitë e brinjëve.\n@returns Numri i trekëndëshave të dallueshëm këndakut që mund të formohen.\n\nShembuj:\ncountAcuteTriangles([1, 1, 1, 1])\n// kthen 4",
      "hy": "Count the number of acute-angled triangles that can be formed by selecting any 3 edges out of a given set of edges.\n\n@param edges Անկյունների երկարությունները ներկայացնող ամբողջ թվերի զանգված:\n@returns Տարբեր սուրանկյուն եռանկյունների քանակը, որոնք կարող են կազմվել:\n\nՕրինակներ:\ncountAcuteTriangles([1, 1, 1, 1])\n// վերադարձնում է 4",
      "bn": "Count the number of acute-angled triangles that can be formed by selecting any 3 edges out of a given set of edges.\n\n@param edges প্রান্তগুলির দৈর্ঘ্য উপস্থাপনকারী পূর্ণসংখ্যার একটি অ্যারে।\n@returns ভিন্ন তীক্ষ্ণ-কোণী ত্রিভুজের সংখ্যা যা গঠন করা যেতে পারে।\n\nউদাহরণ:\ncountAcuteTriangles([1, 1, 1, 1])\n// 4 ফেরত দেয়",
      "bg": "Бройте броя на остроъгълните триъгълници, които могат да бъдат образувани чрез избиране на всякакви 3 ръба от даден набор от ръбове.\n\n@param edges Масив от цели числа, представляващи дължините на ръбовете.\n@returns Броят на различните остроъгълни триъгълници, които могат да бъдат образувани.\n\nПримери:\ncountAcuteTriangles([1, 1, 1, 1])\n// връща 4",
      "zh": "计算可以通过从给定的一组边中选择任意3条边形成的锐角三角形的数量。\n\n@param edges 一个整数数组，表示边的长度。\n@returns 可以形成的不同锐角三角形的数量。\n\n示例：\ncountAcuteTriangles([1, 1, 1, 1])\n// 返回 4",
      "fr": "Compter le nombre de triangles acutangles qui peuvent être formés en sélectionnant 3 arêtes parmi un ensemble donné d'arêtes.\n\n@param edges Un tableau d'entiers représentant les longueurs des arêtes.\n@returns Le nombre de triangles acutangles distincts qui peuvent être formés.\n\nExemples :\ncountAcuteTriangles([1, 1, 1, 1])\n// returns 4",
      "de": "Zähle die Anzahl der spitzwinkligen Dreiecke, die gebildet werden können, indem beliebige 3 Kanten aus einem gegebenen Satz von Kanten ausgewählt werden.\n\n@param edges Ein Array von ganzen Zahlen, das die Längen der Kanten darstellt.\n@returns Die Anzahl der verschiedenen spitzwinkligen Dreiecke, die gebildet werden können.\n\nBeispiele:\ncountAcuteTriangles([1, 1, 1, 1])\n// gibt 4 zurück",
      "ha": "Count the number of acute-angled triangles that can be formed by selecting any 3 edges out of a given set of edges.\n\n@param edges Wani tsararren jerin lambobi da ke wakiltar tsawon gefuna.\n@returns Adadin tsararrun kusurwoyi masu kaifi da za a iya samarwa.\n\nMisalai:\ncountAcuteTriangles([1, 1, 1, 1])\n// returns 4",
      "hi": "तीव्र कोण वाले त्रिभुजों की संख्या गिनें जो किन्हीं 3 किनारों को चुनकर दिए गए किनारों के सेट से बनाए जा सकते हैं।\n\n@param edges किनारों की लंबाई का प्रतिनिधित्व करने वाली पूर्णांकों की एक सरणी।\n@returns उन विशिष्ट तीव्र कोण वाले त्रिभुजों की संख्या जो बनाए जा सकते हैं।\n\nउदाहरण:\ncountAcuteTriangles([1, 1, 1, 1])\n// 4 लौटाता है",
      "hu": "Számolja meg a hegyesszögű háromszögek számát, amelyek úgy képezhetők, hogy a megadott élek halmazából bármely 3 élt kiválasztunk.\n\n@param edges Egészek tömbje, amely az élek hosszát jelöli.\n@returns A különböző hegyesszögű háromszögek száma, amelyek képezhetők.\n\nPéldák:\ncountAcuteTriangles([1, 1, 1, 1])\n// visszaadja 4"
    },
    "docstring_bertscore": {
      "sq": "0.9375351150329104",
      "hy": "0.9881147525203964",
      "bn": "0.9911075164714491",
      "bg": "0.9528737503171866",
      "zh": "0.9371527515494182",
      "fr": "0.9778058357446857",
      "de": "0.958746257532483",
      "ha": "0.9664735752458833",
      "hi": "0.980642674846626",
      "hu": "0.9692653252513287"
    }
  },
  {
    "task_id": "TypeScript/24",
    "prompt": {
      "en": "\n/**\n * Reads an integer and a character, then returns them as a formatted string separated by a comma.\n * @param integer_value The input integer.\n * @param char_value The input character.\n * @returns A string containing the integer and character separated by a comma.\n * @example\n * processIntegerAndChar(234, 'H')  // Returns \"234,H\"\n */\nfunction processIntegerAndChar(integer_value: number, char_value: string): string",
      "sq": "/**\n * Lexon një numër të plotë dhe një karakter, pastaj i kthen ato si një varg i formatuar i ndarë me presje.\n * @param integer_value Numri i plotë i dhënë si hyrje.\n * @param char_value Karakteri i dhënë si hyrje.\n * @returns Një varg që përmban numrin e plotë dhe karakterin të ndarë me presje.\n * @example\n * processIntegerAndChar(234, 'H')  // Kthen \"234,H\"\n */\nfunction processIntegerAndChar(integer_value: number, char_value: string): string",
      "hy": "/**\n * Կարդում է ամբողջ թիվ և սիմվոլ, ապա վերադարձնում է դրանք որպես ձևաչափված տող, որը բաժանված է ստորակետով։\n * @param integer_value Մուտքային ամբողջ թիվը։\n * @param char_value Մուտքային սիմվոլը։\n * @returns Տող, որը պարունակում է ամբողջ թիվը և սիմվոլը, որոնք բաժանված են ստորակետով։\n * @example\n * processIntegerAndChar(234, 'H')  // Վերադարձնում է \"234,H\"\n */\nfunction processIntegerAndChar(integer_value: number, char_value: string): string",
      "bn": "/**\n * একটি পূর্ণসংখ্যা এবং একটি অক্ষর পড়ে, তারপর সেগুলিকে একটি বিন্যাসিত স্ট্রিং হিসাবে কমা দ্বারা পৃথক করে ফেরত দেয়।\n * @param integer_value ইনপুট পূর্ণসংখ্যা।\n * @param char_value ইনপুট অক্ষর।\n * @returns একটি স্ট্রিং যা পূর্ণসংখ্যা এবং অক্ষরকে কমা দ্বারা পৃথক করে ধারণ করে।\n * @example\n * processIntegerAndChar(234, 'H')  // \"234,H\" ফেরত দেয়\n */\nfunction processIntegerAndChar(integer_value: number, char_value: string): string",
      "bg": "/**\n * Чете цяло число и символ, след което ги връща като форматиран низ, разделен със запетая.\n * @param integer_value Входното цяло число.\n * @param char_value Входният символ.\n * @returns Низ, съдържащ цялото число и символа, разделени със запетая.\n * @example\n * processIntegerAndChar(234, 'H')  // Връща \"234,H\"\n */\nfunction processIntegerAndChar(integer_value: number, char_value: string): string",
      "zh": "/**\n * 读取一个整数和一个字符，然后将它们作为用逗号分隔的格式化字符串返回。\n * @param integer_value 输入的整数。\n * @param char_value 输入的字符。\n * @returns 一个包含整数和字符并用逗号分隔的字符串。\n * @example\n * processIntegerAndChar(234, 'H')  // 返回 \"234,H\"\n */\nfunction processIntegerAndChar(integer_value: number, char_value: string): string",
      "fr": "/**\n * Lit un entier et un caractère, puis les renvoie sous forme de chaîne formatée séparée par une virgule.\n * @param integer_value L'entier d'entrée.\n * @param char_value Le caractère d'entrée.\n * @returns Une chaîne contenant l'entier et le caractère séparés par une virgule.\n * @example\n * processIntegerAndChar(234, 'H')  // Renvoie \"234,H\"\n */\nfunction processIntegerAndChar(integer_value: number, char_value: string): string",
      "de": "/**\n * Liest eine Ganzzahl und ein Zeichen ein und gibt sie dann als formatierte Zeichenkette, getrennt durch ein Komma, zurück.\n * @param integer_value Die Eingabe-Ganzzahl.\n * @param char_value Das Eingabe-Zeichen.\n * @returns Eine Zeichenkette, die die Ganzzahl und das Zeichen, getrennt durch ein Komma, enthält.\n * @example\n * processIntegerAndChar(234, 'H')  // Gibt \"234,H\" zurück\n */\nfunction processIntegerAndChar(integer_value: number, char_value: string): string",
      "ha": "/**\n * Yana karanta lamba da harafi, sannan yana mayar da su azaman jeren rubutu da aka raba da alamar kwafi.\n * @param integer_value Lambar shigarwa.\n * @param char_value Harafin shigarwa.\n * @returns Jeren rubutu da ke dauke da lambar da harafin da aka raba da alamar kwafi.\n * @example\n * processIntegerAndChar(234, 'H')  // Yana mayar da \"234,H\"\n */\nfunction processIntegerAndChar(integer_value: number, char_value: string): string",
      "hi": "/**\n * एक पूर्णांक और एक वर्ण पढ़ता है, फिर उन्हें अल्पविराम से अलग किए गए स्वरूपित स्ट्रिंग के रूप में लौटाता है।\n * @param integer_value इनपुट पूर्णांक।\n * @param char_value इनपुट वर्ण।\n * @returns एक स्ट्रिंग जो पूर्णांक और वर्ण को अल्पविराम से अलग करके रखती है।\n * @example\n * processIntegerAndChar(234, 'H')  // \"234,H\" लौटाता है\n */\nfunction processIntegerAndChar(integer_value: number, char_value: string): string",
      "hu": "/**\n * Beolvas egy egész számot és egy karaktert, majd visszaadja őket egy formázott, vesszővel elválasztott karakterláncként.\n * @param integer_value A bemeneti egész szám.\n * @param char_value A bemeneti karakter.\n * @returns Egy karakterlánc, amely az egész számot és a karaktert vesszővel elválasztva tartalmazza.\n * @example\n * processIntegerAndChar(234, 'H')  // Visszaadja: \"234,H\"\n */\nfunction processIntegerAndChar(integer_value: number, char_value: string): string"
    },
    "prompt_bertscore": {
      "sq": "0.9757082989209573",
      "hy": "1",
      "bn": "0.981126339824446",
      "bg": "0.9890757263038432",
      "zh": "0.9945676577090768",
      "fr": "0.9960303718350177",
      "de": "0.9826800266649008",
      "ha": "0.953969395498975",
      "hi": "0.977801664506684",
      "hu": "0.9802607086238959"
    },
    "canonical_solution": "{\n    // Format the string\n    return `${integer_value},${char_value}`;\n}",
    "instruction": {
      "en": "Write a TypeScript function `function processIntegerAndChar(integer_value: number, char_value: string): string` to solve the following problem:\nReads an integer and a character, then returns them as a formatted string separated by a comma.\n@param integer_value The input integer.\n@param char_value The input character.\n@returns A string containing the integer and character separated by a comma.\n@example\nprocessIntegerAndChar(234, 'H')  // Returns \"234,H\"",
      "sq": "Shkruani një funksion TypeScript `function processIntegerAndChar(integer_value: number, char_value: string): string` për të zgjidhur problemin e mëposhtëm:\nLexon një numër të plotë dhe një karakter, pastaj i kthen ato si një varg të formatuar të ndarë me presje.\n@param integer_value Numri i plotë i dhënë si hyrje.\n@param char_value Karakteri i dhënë si hyrje.\n@returns Një varg që përmban numrin e plotë dhe karakterin të ndarë me presje.\n@example\nprocessIntegerAndChar(234, 'H')  // Kthen \"234,H\"",
      "hy": "Գրեք TypeScript ֆունկցիա `function processIntegerAndChar(integer_value: number, char_value: string): string` հետևյալ խնդիրը լուծելու համար:\nԿարդում է ամբողջ թիվ և սիմվոլ, ապա վերադարձնում է դրանք ձևաչափված տողում, որը բաժանված է ստորակետով։\n@param integer_value Մուտքային ամբողջ թիվը։\n@param char_value Մուտքային սիմվոլը։\n@returns Տող, որը պարունակում է ամբողջ թիվը և սիմվոլը, բաժանված ստորակետով։\n@example\nprocessIntegerAndChar(234, 'H')  // Վերադարձնում է \"234,H\"",
      "bn": "TypeScript ফাংশন `function processIntegerAndChar(integer_value: number, char_value: string): string` লিখুন নিম্নলিখিত সমস্যার সমাধানের জন্য:\nএকটি পূর্ণসংখ্যা এবং একটি অক্ষর পড়ে, তারপর সেগুলিকে একটি কমা দ্বারা পৃথক করা ফরম্যাট করা স্ট্রিং হিসেবে ফেরত দেয়।\n@param integer_value ইনপুট পূর্ণসংখ্যা।\n@param char_value ইনপুট অক্ষর।\n@returns একটি স্ট্রিং যা পূর্ণসংখ্যা এবং অক্ষরকে একটি কমা দ্বারা পৃথক করে।\n@example\nprocessIntegerAndChar(234, 'H')  // Returns \"234,H\"",
      "bg": "Напишете TypeScript функция `function processIntegerAndChar(integer_value: number, char_value: string): string`, за да решите следния проблем:\nЧете цяло число и символ, след което ги връща като форматиран низ, разделен със запетая.\n@param integer_value Входното цяло число.\n@param char_value Входният символ.\n@returns Низ, съдържащ цялото число и символа, разделени със запетая.\n@example\nprocessIntegerAndChar(234, 'H')  // Returns \"234,H\"",
      "zh": "编写一个 TypeScript 函数 `function processIntegerAndChar(integer_value: number, char_value: string): string` 来解决以下问题：\n读取一个整数和一个字符，然后将它们作为用逗号分隔的格式化字符串返回。\n@param integer_value 输入的整数。\n@param char_value 输入的字符。\n@returns 一个包含整数和字符并用逗号分隔的字符串。\n@example\nprocessIntegerAndChar(234, 'H')  // Returns \"234,H\"",
      "fr": "Écrire une fonction TypeScript `function processIntegerAndChar(integer_value: number, char_value: string): string` pour résoudre le problème suivant :\nLit un entier et un caractère, puis les renvoie sous forme de chaîne formatée séparée par une virgule.\n@param integer_value L'entier d'entrée.\n@param char_value Le caractère d'entrée.\n@returns Une chaîne contenant l'entier et le caractère séparés par une virgule.\n@example\nprocessIntegerAndChar(234, 'H')  // Returns \"234,H\"",
      "de": "Schreiben Sie eine TypeScript-Funktion `function processIntegerAndChar(integer_value: number, char_value: string): string`, um das folgende Problem zu lösen:\nLiest eine Ganzzahl und ein Zeichen und gibt sie dann als formatierte Zeichenkette getrennt durch ein Komma zurück.\n@param integer_value Die Eingabeganzzahl.\n@param char_value Das Eingabezeichen.\n@returns Eine Zeichenkette, die die Ganzzahl und das Zeichen durch ein Komma getrennt enthält.\n@example\nprocessIntegerAndChar(234, 'H')  // Gibt \"234,H\" zurück",
      "ha": "Rubuta aikin TypeScript `function processIntegerAndChar(integer_value: number, char_value: string): string` don warware matsalar mai zuwa:\nKaranta lamba da harafi, sannan ya mayar da su a matsayin kirtani mai tsari da aka raba da alamar rubutu.\n@param integer_value Lambar da aka shigar.\n@param char_value Harafin da aka shigar.\n@returns Kirtani mai dauke da lamba da harafi da aka raba da alamar rubutu.\n@example\nprocessIntegerAndChar(234, 'H')  // Returns \"234,H\"",
      "hi": "TypeScript फ़ंक्शन `function processIntegerAndChar(integer_value: number, char_value: string): string` लिखें ताकि निम्नलिखित समस्या का समाधान किया जा सके:\nएक पूर्णांक और एक वर्ण पढ़ता है, फिर उन्हें एक फॉर्मेटेड स्ट्रिंग के रूप में अल्पविराम से अलग करके लौटाता है।\n@param integer_value इनपुट पूर्णांक।\n@param char_value इनपुट वर्ण।\n@returns एक स्ट्रिंग जो पूर्णांक और वर्ण को अल्पविराम से अलग करके रखती है।\n@example\nprocessIntegerAndChar(234, 'H')  // Returns \"234,H\"",
      "hu": "Írj egy TypeScript függvényt `function processIntegerAndChar(integer_value: number, char_value: string): string` a következő probléma megoldására:\nBeolvas egy egész számot és egy karaktert, majd visszaadja őket egy vesszővel elválasztott formázott sztringként.\n@param integer_value A bemeneti egész szám.\n@param char_value A bemeneti karakter.\n@returns Egy sztring, amely az egész számot és a karaktert vesszővel elválasztva tartalmazza.\n@example\nprocessIntegerAndChar(234, 'H')  // Visszaadja: \"234,H\""
    },
    "instruction_bertscore": {
      "sq": "0.9779909592598103",
      "hy": "0.9909925094808298",
      "bn": "0.9551772668460482",
      "bg": "1",
      "zh": "0.9953667477319802",
      "fr": "0.9950515213172778",
      "de": "0.9928278542015923",
      "ha": "0.9832316232330347",
      "hi": "0.9598266081749318",
      "hu": "0.9930004640027116"
    },
    "level": "easy",
    "test": "const testProcessIntegerAndChar = (): void => {\n    console.assert(processIntegerAndChar(234, 'H') === \"234,H\", \"Test 1 Failed\");\n    console.assert(processIntegerAndChar(123, 'A') === \"123,A\", \"Test 2 Failed\");\n    console.assert(processIntegerAndChar(0, 'Z') === \"0,Z\", \"Test 3 Failed\");\n    \n    // Additional tests can be added here with different input values\n    // Example:\n    console.assert(processIntegerAndChar(567, 'X') === \"567,X\", \"Example Test Failed\");\n};\n\ntestProcessIntegerAndChar();",
    "entry_point": "processIntegerAndChar",
    "signature": "function processIntegerAndChar(integer_value: number, char_value: string): string",
    "docstring": {
      "en": "Reads an integer and a character, then returns them as a formatted string separated by a comma.\n@param integer_value The input integer.\n@param char_value The input character.\n@returns A string containing the integer and character separated by a comma.\n@example\nprocessIntegerAndChar(234, 'H')  // Returns \"234,H\"",
      "sq": "Lexon një numër të plotë dhe një karakter, pastaj i kthen ato si një varg i formatuar i ndarë nga një presje.\n@param integer_value Numri i plotë i dhënë si hyrje.\n@param char_value Karakteri i dhënë si hyrje.\n@returns Një varg që përmban numrin e plotë dhe karakterin e ndarë nga një presje.\n@example\nprocessIntegerAndChar(234, 'H')  // Kthen \"234,H\"",
      "hy": "Կարդում է ամբողջ թիվ և նիշ, ապա վերադարձնում է դրանք ձևաչափված տողում, որը բաժանված է ստորակետով:\n@param integer_value Մուտքային ամբողջ թիվը:\n@param char_value Մուտքային նիշը:\n@returns Տող, որը պարունակում է ամբողջ թիվը և նիշը, բաժանված ստորակետով:\n@example\nprocessIntegerAndChar(234, 'H')  // Վերադարձնում է \"234,H\"",
      "bn": "Reads an integer and a character, then returns them as a formatted string separated by a comma.\n@param integer_value ইনপুট পূর্ণসংখ্যা।\n@param char_value ইনপুট অক্ষর।\n@returns একটি স্ট্রিং প্রদান করে যা পূর্ণসংখ্যা এবং অক্ষরকে কমা দ্বারা পৃথক করে।\n@example\nprocessIntegerAndChar(234, 'H')  // \"234,H\" প্রদান করে",
      "bg": "Чете цяло число и символ, след което ги връща като форматиран низ, разделен със запетая.\n@param integer_value Входното цяло число.\n@param char_value Входният символ.\n@returns Низ, съдържащ цялото число и символа, разделени със запетая.\n@example\nprocessIntegerAndChar(234, 'H')  // Връща \"234,H\"",
      "zh": "读取一个整数和一个字符，然后将它们作为用逗号分隔的格式化字符串返回。\n@param integer_value 输入的整数。\n@param char_value 输入的字符。\n@returns 一个包含整数和字符并用逗号分隔的字符串。\n@example\nprocessIntegerAndChar(234, 'H')  // 返回 \"234,H\"",
      "fr": "Lit un entier et un caractère, puis les renvoie sous forme de chaîne formatée séparée par une virgule.\n@param integer_value L'entier d'entrée.\n@param char_value Le caractère d'entrée.\n@returns Une chaîne contenant l'entier et le caractère séparés par une virgule.\n@example\nprocessIntegerAndChar(234, 'H')  // Renvoie \"234,H\"",
      "de": "Liest eine ganze Zahl und ein Zeichen und gibt sie dann als formatierte Zeichenkette, getrennt durch ein Komma, zurück.\n@param integer_value Die eingegebene ganze Zahl.\n@param char_value Das eingegebene Zeichen.\n@returns Eine Zeichenkette, die die ganze Zahl und das Zeichen, getrennt durch ein Komma, enthält.\n@example\nprocessIntegerAndChar(234, 'H')  // Gibt \"234,H\" zurück",
      "ha": "Reads an integer and a character, then returns them as a formatted string separated by a comma.\n@param integer_value Lambar shigarwa.\n@param char_value Harafin shigarwa.\n@returns Wani kirtani da ke dauke da lambar da harafin da aka raba su da alamar rubutu.\n@example\nprocessIntegerAndChar(234, 'H')  // Returns \"234,H\"",
      "hi": "Reads an integer and a character, then returns them as a formatted string separated by a comma.  \n@param integer_value इनपुट पूर्णांक।  \n@param char_value इनपुट वर्ण।  \n@returns एक स्ट्रिंग जो पूर्णांक और वर्ण को अल्पविराम से अलग करके रखती है।  \n@example  \nprocessIntegerAndChar(234, 'H')  // Returns \"234,H\"  ",
      "hu": "Olvassa be egy egész számot és egy karaktert, majd adja vissza őket egy formázott karakterláncként, vesszővel elválasztva.\n@param integer_value A bemeneti egész szám.\n@param char_value A bemeneti karakter.\n@returns Egy karakterlánc, amely az egész számot és a karaktert vesszővel elválasztva tartalmazza.\n@example\nprocessIntegerAndChar(234, 'H')  // Visszaadja: \"234,H\""
    },
    "docstring_bertscore": {
      "sq": "0.9703224361391963",
      "hy": "0.9876116217652351",
      "bn": "0.9519173450325036",
      "bg": "0.9854884616223532",
      "zh": "0.9896243434162616",
      "fr": "0.9950175555221209",
      "de": "0.9674415010926664",
      "ha": "0.9646507442391261",
      "hi": "0.9633600440231614",
      "hu": "0.9838124184671807"
    }
  },
  {
    "task_id": "TypeScript/25",
    "prompt": {
      "en": "\n/**\n * Shifts all characters by 5 positions in alphabetical order. Only letters\n * are replaced, and all letters are in uppercase.\n * \n * @param text The input text to be processed.\n * @returns The transformed text with characters shifted by 5 positions.\n * \n * Example:\n * shiftCharacters(\"NS BFW, JAJSYX TK NRUTWYFSHJ FWJ YMJ WJXZQY TK YWNANFQ HFZXJX\")\n * returns \"IN WAR, EVENTS OF IMPORTANCE ARE THE RESULT OF TRIVIAL CAUSES\"\n */\nfunction shiftCharacters(text: string): string",
      "sq": "/**\n * Zhvendos të gjitha karakteret me 5 pozicione në rend alfabetik. Vetëm shkronjat\n * zëvendësohen, dhe të gjitha shkronjat janë me shkronja të mëdha.\n * \n * @param text Teksti hyrës që do të përpunohet.\n * @returns Teksti i transformuar me karaktere të zhvendosura me 5 pozicione.\n * \n * Shembull:\n * shiftCharacters(\"NS BFW, JAJSYX TK NRUTWYFSHJ FWJ YMJ WJXZQY TK YWNANFQ HFZXJX\")\n * returns \"IN WAR, EVENTS OF IMPORTANCE ARE THE RESULT OF TRIVIAL CAUSES\"\n */\nfunction shiftCharacters(text: string): string",
      "hy": "/**\n * Տեղափոխում է բոլոր տառերը այբբենական կարգով 5 դիրքով։ Միայն տառերն են փոխարինվում, և բոլոր տառերը մեծատառ են։\n * \n * @param text Մուտքային տեքստը, որը պետք է մշակվի։\n * @returns Փոխակերպված տեքստը՝ տառերը տեղափոխված 5 դիրքով։\n * \n * Օրինակ:\n * shiftCharacters(\"NS BFW, JAJSYX TK NRUTWYFSHJ FWJ YMJ WJXZQY TK YWNANFQ HFZXJX\")\n * returns \"IN WAR, EVENTS OF IMPORTANCE ARE THE RESULT OF TRIVIAL CAUSES\"\n */\nfunction shiftCharacters(text: string): string",
      "bn": "/**\n * বর্ণানুক্রমিক ক্রমে সমস্ত অক্ষরকে ৫ অবস্থানে স্থানান্তরিত করে। শুধুমাত্র অক্ষরগুলি প্রতিস্থাপিত হয়, এবং সমস্ত অক্ষর বড় হাতের।\n * \n * @param text প্রক্রিয়াকরণের জন্য ইনপুট টেক্সট।\n * @returns রূপান্তরিত টেক্সট যেখানে অক্ষরগুলি ৫ অবস্থানে স্থানান্তরিত।\n * \n * উদাহরণ:\n * shiftCharacters(\"NS BFW, JAJSYX TK NRUTWYFSHJ FWJ YMJ WJXZQY TK YWNANFQ HFZXJX\")\n * returns \"IN WAR, EVENTS OF IMPORTANCE ARE THE RESULT OF TRIVIAL CAUSES\"\n */\nfunction shiftCharacters(text: string): string",
      "bg": "/**\n * Премества всички символи с 5 позиции в азбучен ред. Само букви\n * се заменят и всички букви са с главни букви.\n * \n * @param text Входният текст, който да бъде обработен.\n * @returns Преобразуваният текст със символи, преместени с 5 позиции.\n * \n * Пример:\n * shiftCharacters(\"NS BFW, JAJSYX TK NRUTWYFSHJ FWJ YMJ WJXZQY TK YWNANFQ HFZXJX\")\n * returns \"IN WAR, EVENTS OF IMPORTANCE ARE THE RESULT OF TRIVIAL CAUSES\"\n */\nfunction shiftCharacters(text: string): string",
      "zh": "/**\n * 将所有字符按字母顺序向后移动5个位置。只有字母被替换，并且所有字母都是大写。\n * \n * @param text 要处理的输入文本。\n * @returns 字符被移动5个位置后的转换文本。\n * \n * 示例:\n * shiftCharacters(\"NS BFW, JAJSYX TK NRUTWYFSHJ FWJ YMJ WJXZQY TK YWNANFQ HFZXJX\")\n * returns \"IN WAR, EVENTS OF IMPORTANCE ARE THE RESULT OF TRIVIAL CAUSES\"\n */\nfunction shiftCharacters(text: string): string",
      "fr": "/**\n * Décale tous les caractères de 5 positions dans l'ordre alphabétique. Seules les lettres\n * sont remplacées, et toutes les lettres sont en majuscules.\n * \n * @param text Le texte d'entrée à traiter.\n * @returns Le texte transformé avec les caractères décalés de 5 positions.\n * \n * Exemple:\n * shiftCharacters(\"NS BFW, JAJSYX TK NRUTWYFSHJ FWJ YMJ WJXZQY TK YWNANFQ HFZXJX\")\n * returns \"IN WAR, EVENTS OF IMPORTANCE ARE THE RESULT OF TRIVIAL CAUSES\"\n */\nfunction shiftCharacters(text: string): string",
      "de": "/**\n * Verschiebt alle Zeichen um 5 Positionen in alphabetischer Reihenfolge. Nur Buchstaben\n * werden ersetzt, und alle Buchstaben sind in Großbuchstaben.\n * \n * @param text Der Eingabetext, der verarbeitet werden soll.\n * @returns Der transformierte Text mit um 5 Positionen verschobenen Zeichen.\n * \n * Beispiel:\n * shiftCharacters(\"NS BFW, JAJSYX TK NRUTWYFSHJ FWJ YMJ WJXZQY TK YWNANFQ HFZXJX\")\n * returns \"IN WAR, EVENTS OF IMPORTANCE ARE THE RESULT OF TRIVIAL CAUSES\"\n */\nfunction shiftCharacters(text: string): string",
      "ha": "/**\n * Mayar da dukkan haruffa zuwa matsayi na 5 a cikin tsari na haruffa. Dukkan haruffa\n * ne kawai za a maye gurbinsu, kuma dukkan haruffa suna cikin manyan baki.\n * \n * @param text Rubutun shigarwa da za a sarrafa.\n * @returns Rubutun da aka canza tare da haruffa da aka mayar da su zuwa matsayi na 5.\n * \n * Misali:\n * shiftCharacters(\"NS BFW, JAJSYX TK NRUTWYFSHJ FWJ YMJ WJXZQY TK YWNANFQ HFZXJX\")\n * returns \"IN WAR, EVENTS OF IMPORTANCE ARE THE RESULT OF TRIVIAL CAUSES\"\n */\nfunction shiftCharacters(text: string): string",
      "hi": "/**\n * वर्णमाला में सभी अक्षरों को 5 स्थानों से स्थानांतरित करता है। केवल अक्षरों को\n * बदला जाता है, और सभी अक्षर बड़े अक्षरों में होते हैं।\n * \n * @param text वह इनपुट पाठ जिसे संसाधित किया जाना है।\n * @returns परिवर्तित पाठ जिसमें अक्षर 5 स्थानों से स्थानांतरित होते हैं।\n * \n * उदाहरण:\n * shiftCharacters(\"NS BFW, JAJSYX TK NRUTWYFSHJ FWJ YMJ WJXZQY TK YWNANFQ HFZXJX\")\n * returns \"IN WAR, EVENTS OF IMPORTANCE ARE THE RESULT OF TRIVIAL CAUSES\"\n */\nfunction shiftCharacters(text: string): string",
      "hu": "/**\n * Az összes karaktert 5 pozícióval eltolja ábécé sorrendben. Csak a betűk\n * kerülnek cserére, és minden betű nagybetűs.\n * \n * @param text A feldolgozandó bemeneti szöveg.\n * @returns Az átalakított szöveg, amelynek karakterei 5 pozícióval eltolva.\n * \n * Példa:\n * shiftCharacters(\"NS BFW, JAJSYX TK NRUTWYFSHJ FWJ YMJ WJXZQY TK YWNANFQ HFZXJX\")\n * returns \"IN WAR, EVENTS OF IMPORTANCE ARE THE RESULT OF TRIVIAL CAUSES\"\n */\nfunction shiftCharacters(text: string): string"
    },
    "prompt_bertscore": {
      "sq": "0.9908459202596261",
      "hy": "0.9849563308315606",
      "bn": "0.9657505606589163",
      "bg": "0.9980456756809978",
      "zh": "0.9648479842074937",
      "fr": "0.9940611502374379",
      "de": "0.999999801369619",
      "ha": "0.9531917575572234",
      "hi": "0.9714311909261331",
      "hu": "0.9964484887870962"
    },
    "canonical_solution": "{\n    let result = \"\";\n    for (let i = 0; i < text.length; ++i) {\n        let charCode = text.charCodeAt(i);\n        if (charCode >= 65 && charCode <= 69) { // 'A'.charCodeAt(0) == 65, 'E'.charCodeAt(0) == 69\n            result += String.fromCharCode(charCode + 21); // 'V'.charCodeAt(0) == 86; 'V' - 'A' = 21\n        } else if (charCode >= 70 && charCode <= 90) { // 'F'.charCodeAt(0) == 70, 'Z'.charCodeAt(0) == 90\n            result += String.fromCharCode(charCode - 5);\n        } else {\n            result += text[i];\n        }\n    }\n    return result;\n}",
    "instruction": {
      "en": "Write a TypeScript function `function shiftCharacters(text: string): string` to solve the following problem:\nShifts all characters by 5 positions in alphabetical order. Only letters are replaced, and all letters are in uppercase.\n\n@param text The input text to be processed.\n@returns The transformed text with characters shifted by 5 positions.\n\nExample:\nshiftCharacters(\"NS BFW, JAJSYX TK NRUTWYFSHJ FWJ YMJ WJXZQY TK YWNANFQ HFZXJX\")\nreturns \"IN WAR, EVENTS OF IMPORTANCE ARE THE RESULT OF TRIVIAL CAUSES\"",
      "sq": "Shkruani një funksion TypeScript `function shiftCharacters(text: string): string` për të zgjidhur problemin e mëposhtëm:\nZhvendos të gjitha karakteret me 5 pozicione në rend alfabetik. Vetëm shkronjat zëvendësohen, dhe të gjitha shkronjat janë me shkronja të mëdha.\n\n@param text Teksti hyrës për t'u përpunuar.\n@returns Teksti i transformuar me karaktere të zhvendosura me 5 pozicione.\n\nShembull:\nshiftCharacters(\"NS BFW, JAJSYX TK NRUTWYFSHJ FWJ YMJ WJXZQY TK YWNANFQ HFZXJX\")\nkthen \"IN WAR, EVENTS OF IMPORTANCE ARE THE RESULT OF TRIVIAL CAUSES\"",
      "hy": "Գրեք TypeScript ֆունկցիա `function shiftCharacters(text: string): string` հետևյալ խնդիրը լուծելու համար:\nՏեղափոխում է բոլոր տառերը 5 դիրքով այբբենական կարգով։ Միայն տառերն են փոխարինվում, և բոլոր տառերը մեծատառ են։\n\n@param text Մուտքային տեքստը, որը պետք է մշակվի։\n@returns Փոխակերպված տեքստը, որտեղ տառերը տեղափոխված են 5 դիրքով։\n\nՕրինակ:\nshiftCharacters(\"NS BFW, JAJSYX TK NRUTWYFSHJ FWJ YMJ WJXZQY TK YWNANFQ HFZXJX\")\nվերադարձնում է \"IN WAR, EVENTS OF IMPORTANCE ARE THE RESULT OF TRIVIAL CAUSES\"",
      "bn": "TypeScript ফাংশন `function shiftCharacters(text: string): string` লিখুন নিম্নলিখিত সমস্যার সমাধানের জন্য:\nসমস্ত অক্ষর বর্ণানুক্রমিক ক্রমে 5 অবস্থানে স্থানান্তরিত হয়। শুধুমাত্র অক্ষরগুলি প্রতিস্থাপিত হয় এবং সমস্ত অক্ষর বড় হাতের।\n\n@param text প্রক্রিয়াকরণের জন্য ইনপুট টেক্সট।\n@returns রূপান্তরিত টেক্সট যা 5 অবস্থানে অক্ষর স্থানান্তরিত করে।\n\nউদাহরণ:\nshiftCharacters(\"NS BFW, JAJSYX TK NRUTWYFSHJ FWJ YMJ WJXZQY TK YWNANFQ HFZXJX\")\nফেরত দেয় \"IN WAR, EVENTS OF IMPORTANCE ARE THE RESULT OF TRIVIAL CAUSES\"",
      "bg": "Напишете функция на TypeScript `function shiftCharacters(text: string): string`, за да решите следния проблем:\nПремества всички символи с 5 позиции в азбучен ред. Само буквите се заменят и всички букви са с главни букви.\n\n@param text Входният текст, който ще бъде обработен.\n@returns Преобразуваният текст със символи, преместени с 5 позиции.\n\nПример:\nshiftCharacters(\"NS BFW, JAJSYX TK NRUTWYFSHJ FWJ YMJ WJXZQY TK YWNANFQ HFZXJX\")\nвръща \"IN WAR, EVENTS OF IMPORTANCE ARE THE RESULT OF TRIVIAL CAUSES\"",
      "zh": "编写一个 TypeScript 函数 `function shiftCharacters(text: string): string` 来解决以下问题：\n将所有字符在字母表中移动5个位置。只有字母被替换，并且所有字母都为大写。\n\n@param text 要处理的输入文本。\n@returns 字符移动了5个位置后的转换文本。\n\n示例：\nshiftCharacters(\"NS BFW, JAJSYX TK NRUTWYFSHJ FWJ YMJ WJXZQY TK YWNANFQ HFZXJX\")\n返回 \"IN WAR, EVENTS OF IMPORTANCE ARE THE RESULT OF TRIVIAL CAUSES\"",
      "fr": "Écrire une fonction TypeScript `function shiftCharacters(text: string): string` pour résoudre le problème suivant :\nDécale tous les caractères de 5 positions dans l'ordre alphabétique. Seules les lettres sont remplacées, et toutes les lettres sont en majuscules.\n\n@param text Le texte d'entrée à traiter.\n@returns Le texte transformé avec les caractères décalés de 5 positions.\n\nExemple :\nshiftCharacters(\"NS BFW, JAJSYX TK NRUTWYFSHJ FWJ YMJ WJXZQY TK YWNANFQ HFZXJX\")\nrenvoie \"IN WAR, EVENTS OF IMPORTANCE ARE THE RESULT OF TRIVIAL CAUSES\"",
      "de": "Schreiben Sie eine TypeScript-Funktion `function shiftCharacters(text: string): string`, um das folgende Problem zu lösen:\nVerschiebt alle Zeichen um 5 Positionen in alphabetischer Reihenfolge. Nur Buchstaben werden ersetzt, und alle Buchstaben sind in Großbuchstaben.\n\n@param text Der Eingabetext, der verarbeitet werden soll.\n@returns Der transformierte Text mit um 5 Positionen verschobenen Zeichen.\n\nBeispiel:\nshiftCharacters(\"NS BFW, JAJSYX TK NRUTWYFSHJ FWJ YMJ WJXZQY TK YWNANFQ HFZXJX\")\nreturns \"IN WAR, EVENTS OF IMPORTANCE ARE THE RESULT OF TRIVIAL CAUSES\"",
      "ha": "Rubuta aikin TypeScript `function shiftCharacters(text: string): string` don magance matsalar mai zuwa:\nYa matsar da duk haruffa da matsayi 5 a cikin tsarin haruffa. Haruffa kawai ake maye gurbinsu, kuma duk haruffa suna cikin manyan baƙaƙe.\n\n@param text Rubutun shigar da za a sarrafa.\n@returns Rubutun da aka canza tare da haruffa da aka matsar da matsayi 5.\n\nMisali:\nshiftCharacters(\"NS BFW, JAJSYX TK NRUTWYFSHJ FWJ YMJ WJXZQY TK YWNANFQ HFZXJX\")\nreturns \"IN WAR, EVENTS OF IMPORTANCE ARE THE RESULT OF TRIVIAL CAUSES\"",
      "hi": "TypeScript फ़ंक्शन `function shiftCharacters(text: string): string` लिखें ताकि निम्नलिखित समस्या का समाधान किया जा सके:\nसभी वर्णों को वर्णमाला क्रम में 5 स्थानों से स्थानांतरित करता है। केवल अक्षरों को बदला जाता है, और सभी अक्षर बड़े अक्षरों में होते हैं।\n\n@param text वह इनपुट टेक्स्ट जिसे संसाधित किया जाना है।\n@returns परिवर्तित टेक्स्ट जिसमें वर्ण 5 स्थानों से स्थानांतरित होते हैं।\n\nउदाहरण:\nshiftCharacters(\"NS BFW, JAJSYX TK NRUTWYFSHJ FWJ YMJ WJXZQY TK YWNANFQ HFZXJX\")\nreturns \"IN WAR, EVENTS OF IMPORTANCE ARE THE RESULT OF TRIVIAL CAUSES\"",
      "hu": "Készíts egy TypeScript függvényt `function shiftCharacters(text: string): string` a következő probléma megoldására:\nAz összes karaktert 5 pozícióval eltolja az ábécében. Csak a betűk kerülnek cserére, és minden betű nagybetűs.\n\n@param text A feldolgozandó bemeneti szöveg.\n@returns Az átalakított szöveg, amelyben a karakterek 5 pozícióval eltolódtak.\n\nPélda:\nshiftCharacters(\"NS BFW, JAJSYX TK NRUTWYFSHJ FWJ YMJ WJXZQY TK YWNANFQ HFZXJX\")\nvisszaadja \"IN WAR, EVENTS OF IMPORTANCE ARE THE RESULT OF TRIVIAL CAUSES\""
    },
    "instruction_bertscore": {
      "sq": "0.9909488107970023",
      "hy": "0.9794419541932701",
      "bn": "0.9530151751484834",
      "bg": "0.9920559765408907",
      "zh": "0.9631020231581972",
      "fr": "0.9900110767681365",
      "de": "1",
      "ha": "0.9774359859751988",
      "hi": "0.968640831333355",
      "hu": "0.9731819191045745"
    },
    "level": "hard",
    "test": "function testShiftCharacters() {\n    let test1 = \"NS BFW, JAJSYX TK NRUTWYFSHJ FWJ YMJ WJXZQY TK YWNANFQ HFZXJX\";\n    let test2 = \"N BTZQI WFYMJW GJ KNWXY NS F QNYYQJ NGJWNFS ANQQFLJ YMFS XJHTSI NS WTRJ\";\n    let test3 = \"IFSLJW PSTBX KZQQ BJQQ YMFY HFJXFW NX RTWJ IFSLJWTZX YMFS MJ\";\n\n    console.assert(shiftCharacters(test1) === \"IN WAR, EVENTS OF IMPORTANCE ARE THE RESULT OF TRIVIAL CAUSES\", \"Test 1 failed\");\n    console.assert(shiftCharacters(test2) === \"I WOULD RATHER BE FIRST IN A LITTLE IBERIAN VILLAGE THAN SECOND IN ROME\", \"Test 2 failed\");\n    console.assert(shiftCharacters(test3) === \"DANGER KNOWS FULL WELL THAT CAESAR IS MORE DANGEROUS THAN HE\", \"Test 3 failed\");\n}\n\ntestShiftCharacters();",
    "entry_point": "shiftCharacters",
    "signature": "function shiftCharacters(text: string): string",
    "docstring": {
      "en": "Shifts all characters by 5 positions in alphabetical order. Only letters are replaced, and all letters are in uppercase.\n\n@param text The input text to be processed.\n@returns The transformed text with characters shifted by 5 positions.\n\nExample:\nshiftCharacters(\"NS BFW, JAJSYX TK NRUTWYFSHJ FWJ YMJ WJXZQY TK YWNANFQ HFZXJX\")\nreturns \"IN WAR, EVENTS OF IMPORTANCE ARE THE RESULT OF TRIVIAL CAUSES\"",
      "sq": "Zhvendos të gjitha karakteret me 5 pozicione në rend alfabetik. Vetëm shkronjat zëvendësohen, dhe të gjitha shkronjat janë me shkronja të mëdha.\n\n@param text Teksti hyrës që do të përpunohet.\n@returns Teksti i transformuar me karaktere të zhvendosura me 5 pozicione.\n\nShembull:\nshiftCharacters(\"NS BFW, JAJSYX TK NRUTWYFSHJ FWJ YMJ WJXZQY TK YWNANFQ HFZXJX\")\nreturns \"IN WAR, EVENTS OF IMPORTANCE ARE THE RESULT OF TRIVIAL CAUSES\"",
      "hy": "Shifts all characters by 5 positions in alphabetical order. Only letters are replaced, and all letters are in uppercase.\n\n@param text Մուտքային տեքստը, որը պետք է մշակվի:\n@returns Փոխակերպված տեքստը, որտեղ նիշերը տեղափոխված են 5 դիրքով:\n\nՕրինակ:\nshiftCharacters(\"NS BFW, JAJSYX TK NRUTWYFSHJ FWJ YMJ WJXZQY TK YWNANFQ HFZXJX\")\nreturns \"IN WAR, EVENTS OF IMPORTANCE ARE THE RESULT OF TRIVIAL CAUSES\"",
      "bn": "অক্ষরগুলিকে বর্ণানুক্রমিক ক্রমে ৫টি অবস্থানে স্থানান্তরিত করে। শুধুমাত্র অক্ষরগুলি প্রতিস্থাপিত হয় এবং সমস্ত অক্ষর বড় হাতের।\n\n@param text প্রক্রিয়াকরণের জন্য ইনপুট টেক্সট।\n@returns রূপান্তরিত টেক্সট যা অক্ষরগুলিকে ৫টি অবস্থানে স্থানান্তরিত করে।\n\nউদাহরণ:\nshiftCharacters(\"NS BFW, JAJSYX TK NRUTWYFSHJ FWJ YMJ WJXZQY TK YWNANFQ HFZXJX\")\nreturns \"IN WAR, EVENTS OF IMPORTANCE ARE THE RESULT OF TRIVIAL CAUSES\"",
      "bg": "Премества всички символи с 5 позиции в азбучен ред. Само буквите се заменят и всички букви са с главни букви.\n\n@param text Входният текст, който ще бъде обработен.\n@returns Преобразуваният текст със символи, преместени с 5 позиции.\n\nПример:\nshiftCharacters(\"NS BFW, JAJSYX TK NRUTWYFSHJ FWJ YMJ WJXZQY TK YWNANFQ HFZXJX\")\nвръща \"IN WAR, EVENTS OF IMPORTANCE ARE THE RESULT OF TRIVIAL CAUSES\"",
      "zh": "Shifts all characters by 5 positions in alphabetical order. Only letters are replaced, and all letters are in uppercase.\n\n@param text 要处理的输入文本。\n@returns 转换后的文本，其中字符按字母顺序移动了5个位置。\n\nExample:\nshiftCharacters(\"NS BFW, JAJSYX TK NRUTWYFSHJ FWJ YMJ WJXZQY TK YWNANFQ HFZXJX\")\nreturns \"IN WAR, EVENTS OF IMPORTANCE ARE THE RESULT OF TRIVIAL CAUSES\"",
      "fr": "Décale tous les caractères de 5 positions dans l'ordre alphabétique. Seules les lettres sont remplacées, et toutes les lettres sont en majuscules.\n\n@param text Le texte d'entrée à traiter.\n@returns Le texte transformé avec des caractères décalés de 5 positions.\n\nExemple :\nshiftCharacters(\"NS BFW, JAJSYX TK NRUTWYFSHJ FWJ YMJ WJXZQY TK YWNANFQ HFZXJX\")\nreturns \"IN WAR, EVENTS OF IMPORTANCE ARE THE RESULT OF TRIVIAL CAUSES\"",
      "de": "Verschiebt alle Zeichen um 5 Positionen in alphabetischer Reihenfolge. Nur Buchstaben werden ersetzt, und alle Buchstaben sind in Großbuchstaben.\n\n@param text Der Eingabetext, der verarbeitet werden soll.\n@returns Der transformierte Text mit um 5 Positionen verschobenen Zeichen.\n\nBeispiel:\nshiftCharacters(\"NS BFW, JAJSYX TK NRUTWYFSHJ FWJ YMJ WJXZQY TK YWNANFQ HFZXJX\")\nreturns \"IN WAR, EVENTS OF IMPORTANCE ARE THE RESULT OF TRIVIAL CAUSES\"",
      "ha": "Shifts duk haruffa ta wurin matsar da su wurare 5 a cikin tsarin haruffa. Haruffa kawai ake maye gurbinsu, kuma duk haruffa suna cikin manyan baƙaƙe.\n\n@param text Rubutun shigarwa da za a sarrafa.\n@returns Rubutun da aka sauya tare da haruffa da aka matsar da su wurare 5.\n\nMisali:\nshiftCharacters(\"NS BFW, JAJSYX TK NRUTWYFSHJ FWJ YMJ WJXZQY TK YWNANFQ HFZXJX\")\nreturns \"IN WAR, EVENTS OF IMPORTANCE ARE THE RESULT OF TRIVIAL CAUSES\"",
      "hi": "Shifts all characters by 5 positions in alphabetical order. केवल अक्षरों को बदला जाता है, और सभी अक्षर बड़े अक्षरों में होते हैं।\n\n@param text संसाधित किए जाने वाले इनपुट पाठ।\n@returns परिवर्तित पाठ जिसमें अक्षरों को 5 स्थानों से स्थानांतरित किया गया है।\n\nउदाहरण:\nshiftCharacters(\"NS BFW, JAJSYX TK NRUTWYFSHJ FWJ YMJ WJXZQY TK YWNANFQ HFZXJX\")\nreturns \"IN WAR, EVENTS OF IMPORTANCE ARE THE RESULT OF TRIVIAL CAUSES\"",
      "hu": "Az összes karaktert 5 pozícióval eltolja az ábécében. Csak a betűk kerülnek lecserélésre, és minden betű nagybetűs.\n\n@param text A feldolgozandó bemeneti szöveg.\n@returns Az átalakított szöveg, amelyben a karakterek 5 pozícióval eltolódtak.\n\nPélda:\nshiftCharacters(\"NS BFW, JAJSYX TK NRUTWYFSHJ FWJ YMJ WJXZQY TK YWNANFQ HFZXJX\")\nreturns \"IN WAR, EVENTS OF IMPORTANCE ARE THE RESULT OF TRIVIAL CAUSES\""
    },
    "docstring_bertscore": {
      "sq": "0.9864502299273241",
      "hy": "0.9780769662147983",
      "bn": "0.9453961109927471",
      "bg": "0.9938406705144891",
      "zh": "0.9738892418914398",
      "fr": "0.9905364541259738",
      "de": "1",
      "ha": "0.9638087500539192",
      "hi": "0.9793376732432267",
      "hu": "0.9633489207218234"
    }
  },
  {
    "task_id": "TypeScript/26",
    "prompt": {
      "en": "\n/**\n * Classify the integer x based on the following method:\n * If x is a single-digit number, x belongs to its own class.\n * Otherwise, sum the digits of x, get a new x, and iterate until the class is determined.\n *\n * @param x - The string representation of the integer to be classified.\n * @returns The class to which the integer x belongs.\n * \n * @example\n * ```typescript\n * classifyInteger(\"24\") // returns 6\n * ```\n */\nfunction classifyInteger(x: string): number",
      "sq": "/**\n * Klasifikoni numrin e plotë x bazuar në metodën e mëposhtme:\n * Nëse x është një numër me një shifër, x i përket klasës së vet.\n * Përndryshe, mblidhni shifrat e x, merrni një x të ri dhe iteroni derisa klasa të përcaktohet.\n *\n * @param x - Përfaqësimi si varg i numrit të plotë që do të klasifikohet.\n * @returns Klasa së cilës i përket numri i plotë x.\n * \n * @example\n * ```typescript\n * classifyInteger(\"24\") // returns 6\n * ```\n */\nfunction classifyInteger(x: string): number",
      "hy": "/**\n * Դասակարգել ամբողջ թիվ x-ը հետևյալ մեթոդով.\n * Եթե x-ը միանիշ թիվ է, ապա x-ը պատկանում է իր սեփական դասին։\n * Հակառակ դեպքում, գումարել x-ի թվանշանները, ստանալ նոր x և կրկնել, մինչև դասը որոշվի։\n *\n * @param x - Դասակարգվող ամբողջ թվի տողային ներկայացումը։\n * @returns Դասը, որին պատկանում է ամբողջ թիվ x-ը։\n * \n * @example\n * ```typescript\n * classifyInteger(\"24\") // returns 6\n * ```\n */\nfunction classifyInteger(x: string): number",
      "bn": "/**\n * নিম্নলিখিত পদ্ধতির উপর ভিত্তি করে পূর্ণসংখ্যা x শ্রেণীবদ্ধ করুন:\n * যদি x এক অঙ্কের সংখ্যা হয়, তাহলে x তার নিজের শ্রেণীতে অন্তর্ভুক্ত।\n * অন্যথায়, x এর অঙ্কগুলির যোগফল নিন, একটি নতুন x পান, এবং শ্রেণী নির্ধারণ না হওয়া পর্যন্ত পুনরাবৃত্তি করুন।\n *\n * @param x - শ্রেণীবদ্ধ করার জন্য পূর্ণসংখ্যার স্ট্রিং উপস্থাপনা।\n * @returns সেই শ্রেণী যা পূর্ণসংখ্যা x এর অন্তর্গত।\n * \n * @example\n * ```typescript\n * classifyInteger(\"24\") // returns 6\n * ```\n */\nfunction classifyInteger(x: string): number",
      "bg": "/**\n * Класифицирайте цялото число x въз основа на следния метод:\n * Ако x е едноцифрено число, x принадлежи към собствен клас.\n * В противен случай, съберете цифрите на x, получете ново x и итерайте, докато класът бъде определен.\n *\n * @param x - Стринг представянето на цялото число, което трябва да бъде класифицирано.\n * @returns Класът, към който принадлежи цялото число x.\n * \n * @example\n * ```typescript\n * classifyInteger(\"24\") // returns 6\n * ```\n */\nfunction classifyInteger(x: string): number",
      "zh": "/**\n * 根据以下方法对整数 x 进行分类：\n * 如果 x 是一个个位数，x 属于它自己的类。\n * 否则，将 x 的各位数字相加，得到一个新的 x，并迭代直到确定类。\n *\n * @param x - 要分类的整数的字符串表示。\n * @returns 整数 x 所属的类。\n * \n * @example\n * ```typescript\n * classifyInteger(\"24\") // returns 6\n * ```\n */\nfunction classifyInteger(x: string): number",
      "fr": "/**\n * Classifier l'entier x selon la méthode suivante :\n * Si x est un nombre à un chiffre, x appartient à sa propre classe.\n * Sinon, additionner les chiffres de x, obtenir un nouveau x, et itérer jusqu'à ce que la classe soit déterminée.\n *\n * @param x - La représentation sous forme de chaîne de l'entier à classifier.\n * @returns La classe à laquelle appartient l'entier x.\n * \n * @example\n * ```typescript\n * classifyInteger(\"24\") // returns 6\n * ```\n */\nfunction classifyInteger(x: string): number",
      "de": "/**\n * Klassifiziere die ganze Zahl x basierend auf der folgenden Methode:\n * Wenn x eine einstellige Zahl ist, gehört x zu seiner eigenen Klasse.\n * Andernfalls summiere die Ziffern von x, erhalte ein neues x und iteriere, bis die Klasse bestimmt ist.\n *\n * @param x - Die String-Darstellung der zu klassifizierenden ganzen Zahl.\n * @returns Die Klasse, zu der die ganze Zahl x gehört.\n * \n * @example\n * ```typescript\n * classifyInteger(\"24\") // returns 6\n * ```\n */\nfunction classifyInteger(x: string): number",
      "ha": "/**\n * Rarraba lambar x bisa ga hanyar da ke biye:\n * Idan x lamba ce mai lamba guda ɗaya, x tana cikin ajinta.\n * In ba haka ba, a tara lambobin x, a sami sabon x, a ci gaba har sai an tantance ajin.\n *\n * @param x - Wakilcin kirtani na lambar da za a rarraba.\n * @returns Aji wanda lambar x take ciki.\n * \n * @example\n * ```typescript\n * classifyInteger(\"24\") // returns 6\n * ```\n */\nfunction classifyInteger(x: string): number",
      "hi": "/**\n * निम्नलिखित विधि के आधार पर पूर्णांक x को वर्गीकृत करें:\n * यदि x एक एकल-अंक संख्या है, तो x अपने स्वयं के वर्ग से संबंधित है।\n * अन्यथा, x के अंकों का योग करें, एक नया x प्राप्त करें, और तब तक दोहराएं जब तक कि वर्ग निर्धारित न हो जाए।\n *\n * @param x - वर्गीकृत किए जाने वाले पूर्णांक का स्ट्रिंग प्रतिनिधित्व।\n * @returns वह वर्ग जिसमें पूर्णांक x संबंधित है।\n * \n * @example\n * ```typescript\n * classifyInteger(\"24\") // returns 6\n * ```\n */\nfunction classifyInteger(x: string): number",
      "hu": "/**\n * Osztályozza az x egész számot a következő módszer alapján:\n * Ha x egyjegyű szám, akkor x a saját osztályába tartozik.\n * Ellenkező esetben összeadja x számjegyeit, új x-et kap, és iterál, amíg az osztály meg nem határozódik.\n *\n * @param x - Az osztályozandó egész szám string reprezentációja.\n * @returns Az osztály, amelyhez az x egész szám tartozik.\n * \n * @példa\n * ```typescript\n * classifyInteger(\"24\") // returns 6\n * ```\n */\nfunction classifyInteger(x: string): number"
    },
    "prompt_bertscore": {
      "sq": "0.9953228504177715",
      "hy": "0.9715531499800885",
      "bn": "0.9662320407025449",
      "bg": "0.9939304514467169",
      "zh": "0.9779049523048221",
      "fr": "0.9854693931057737",
      "de": "0.9986014434871333",
      "ha": "0.9555882331044093",
      "hi": "0.9597866834683437",
      "hu": "0.9902567825494767"
    },
    "canonical_solution": "{\n    let n = 0;\n    for (let i = 0; i < x.length; i++) {\n        n += parseInt(x[i]);\n    }\n    while (n > 9) {\n        let t = n;\n        let a = 0;\n        while (t) {\n            a += t % 10;\n            t = Math.floor(t / 10);\n        }\n        n = a;\n    }\n    return n;\n}",
    "instruction": {
      "en": "Write a TypeScript function `function classifyInteger(x: string): number` to solve the following problem:\nClassify the integer x based on the following method:\nIf x is a single-digit number, x belongs to its own class.\nOtherwise, sum the digits of x, get a new x, and iterate until the class is determined.\n\nParameters:\n- x (string): The string representation of the integer to be classified.\n\nReturns:\nThe class to which the integer x belongs.\n\nExample:\nclassifyInteger(\"24\") // returns 6",
      "sq": "Shkruani një funksion TypeScript `function classifyInteger(x: string): number` për të zgjidhur problemin e mëposhtëm:\nKlasifikoni numrin e plotë x bazuar në metodën e mëposhtme:\nNëse x është një numër me një shifër, x i përket klasës së vet.\nPërndryshe, mblidhni shifrat e x, merrni një x të ri dhe përsëritni derisa klasa të përcaktohet.\n\nParametrat:\n- x (string): Përfaqësimi si varg i numrit të plotë që do të klasifikohet.\n\nKthen:\nKlasa së cilës i përket numri i plotë x.\n\nShembull:\nclassifyInteger(\"24\") // kthen 6",
      "hy": "Գրեք TypeScript ֆունկցիա `function classifyInteger(x: string): number` հետևյալ խնդիրը լուծելու համար:\nԴասակարգեք ամբողջ թիվը x-ը հետևյալ մեթոդով:\nԵթե x-ը միանիշ թիվ է, ապա x-ը պատկանում է իր սեփական դասին:\nՀակառակ դեպքում, գումարեք x-ի թվանշանները, ստացեք նոր x և կրկնեք, մինչև դասը որոշվի:\n\nՊարամետրեր:\n- x (string): Դասակարգվող ամբողջ թվի տողի ներկայացումը:\n\nՎերադարձնում է:\nԴասը, որին պատկանում է ամբողջ թիվը x-ը:\n\nՕրինակ:\nclassifyInteger(\"24\") // վերադարձնում է 6",
      "bn": "TypeScript ফাংশন `function classifyInteger(x: string): number` লিখুন নিম্নলিখিত সমস্যার সমাধানের জন্য:\nনিম্নলিখিত পদ্ধতির ভিত্তিতে পূর্ণসংখ্যা x শ্রেণীবদ্ধ করুন:\nযদি x এক অঙ্কের সংখ্যা হয়, তবে x তার নিজস্ব শ্রেণীতে অন্তর্ভুক্ত।\nঅন্যথায়, x এর অঙ্কগুলোর যোগফল নিন, একটি নতুন x পান, এবং শ্রেণী নির্ধারিত না হওয়া পর্যন্ত পুনরাবৃত্তি করুন।\n\nপ্যারামিটারসমূহ:\n- x (string): শ্রেণীবদ্ধ করার জন্য পূর্ণসংখ্যার স্ট্রিং উপস্থাপনা।\n\nফেরত দেয়:\nপূর্ণসংখ্যা x যে শ্রেণীর অন্তর্ভুক্ত তা।\n\nউদাহরণ:\nclassifyInteger(\"24\") // 6 ফেরত দেয়",
      "bg": "Напишете функция на TypeScript `function classifyInteger(x: string): number`, за да решите следния проблем:\nКласифицирайте цялото число x въз основа на следния метод:\nАко x е едноцифрено число, x принадлежи към своя собствен клас.\nВ противен случай, съберете цифрите на x, получете ново x и итерайте, докато класът не бъде определен.\n\nПараметри:\n- x (string): Стринг представяне на цялото число, което трябва да бъде класифицирано.\n\nВръща:\nКласът, към който принадлежи цялото число x.\n\nПример:\nclassifyInteger(\"24\") // връща 6",
      "zh": "编写一个 TypeScript 函数 `function classifyInteger(x: string): number` 来解决以下问题：\n根据以下方法对整数 x 进行分类：\n如果 x 是一位数，则 x 属于它自己的类别。\n否则，将 x 的各位数字相加，得到一个新的 x，并迭代直到确定类别。\n\n参数：\n- x (string): 要分类的整数的字符串表示。\n\n返回：\n整数 x 所属的类别。\n\n示例：\nclassifyInteger(\"24\") // 返回 6",
      "fr": "Écrire une fonction TypeScript `function classifyInteger(x: string): number` pour résoudre le problème suivant :\nClassifiez l'entier x selon la méthode suivante :\nSi x est un nombre à un seul chiffre, x appartient à sa propre classe.\nSinon, additionnez les chiffres de x, obtenez un nouveau x, et itérez jusqu'à ce que la classe soit déterminée.\n\nParamètres :\n- x (string) : La représentation sous forme de chaîne de l'entier à classer.\n\nRenvoie :\nLa classe à laquelle appartient l'entier x.\n\nExemple :\nclassifyInteger(\"24\") // returns 6",
      "de": "Schreiben Sie eine TypeScript-Funktion `function classifyInteger(x: string): number`, um das folgende Problem zu lösen:\nKlassifizieren Sie die ganze Zahl x basierend auf der folgenden Methode:\nWenn x eine einstellige Zahl ist, gehört x zu seiner eigenen Klasse.\nAndernfalls summieren Sie die Ziffern von x, erhalten ein neues x und iterieren, bis die Klasse bestimmt ist.\n\nParameter:\n- x (string): Die String-Darstellung der zu klassifizierenden ganzen Zahl.\n\nRückgabe:\nDie Klasse, zu der die ganze Zahl x gehört.\n\nBeispiel:\nclassifyInteger(\"24\") // gibt 6 zurück",
      "ha": "Rubuta aikin TypeScript `function classifyInteger(x: string): number` don warware matsalar mai zuwa:\nRarraba lambar x bisa ga hanyar da ke gaba:\nIdan x lamba ce mai lamba guda ɗaya, x tana cikin ajinta.\nIn ba haka ba, tara lambobin x, sami sabon x, kuma maimaita har sai an tantance ajin.\n\nSigogi:\n- x (string): Wakilcin kirtani na lambar da za a rarraba.\n\nDawowa:\nAjin da lambar x ta ke ciki.\n\nMisali:\nclassifyInteger(\"24\") // returns 6",
      "hi": "TypeScript फ़ंक्शन `function classifyInteger(x: string): number` लिखें ताकि निम्नलिखित समस्या का समाधान किया जा सके:\nनिम्नलिखित विधि के आधार पर पूर्णांक x को वर्गीकृत करें:\nयदि x एकल-अंक संख्या है, तो x अपने स्वयं के वर्ग से संबंधित है।\nअन्यथा, x के अंकों का योग करें, एक नया x प्राप्त करें, और तब तक पुनरावृत्ति करें जब तक कि वर्ग निर्धारित न हो जाए।\n\nपैरामीटर्स:\n- x (string): वर्गीकृत किए जाने वाले पूर्णांक का स्ट्रिंग प्रतिनिधित्व।\n\nवापसी:\nवर्ग जिसमें पूर्णांक x संबंधित है।\n\nउदाहरण:\nclassifyInteger(\"24\") // returns 6",
      "hu": "Írj egy TypeScript függvényt `function classifyInteger(x: string): number` a következő probléma megoldására:\nOsztályozd az egész számot x az alábbi módszer alapján:\nHa x egyjegyű szám, akkor x a saját osztályába tartozik.\nEgyébként add össze x számjegyeit, kapj egy új x-et, és ismételd, amíg az osztály meg nem határozódik.\n\nParaméterek:\n- x (string): Az osztályozandó egész szám string reprezentációja.\n\nVisszatér:\nAz osztály, amelyhez az egész szám x tartozik.\n\nPélda:\nclassifyInteger(\"24\") // returns 6"
    },
    "instruction_bertscore": {
      "sq": "0.9847227415034636",
      "hy": "0.9791207688671367",
      "bn": "0.9545964716119022",
      "bg": "0.9899616178032589",
      "zh": "0.9657136154080438",
      "fr": "0.9835136783741043",
      "de": "0.9904846115965237",
      "ha": "0.9537947993940453",
      "hi": "0.9686001121052428",
      "hu": "0.9869954703232648"
    },
    "level": "easy",
    "test": "const testClassifyInteger = (): void => {\n    console.assert(classifyInteger(\"24\") === 6, \"Test failed for input '24'\");\n    console.assert(classifyInteger(\"39\") === 3, \"Test failed for input '39'\");\n    console.assert(classifyInteger(\"123456789\") === 9, \"Test failed for input '123456789'\");\n    console.assert(classifyInteger(\"123456789012345678901234567890\") === 9, \"Test failed for input '123456789012345678901234567890'\");\n    console.assert(classifyInteger(\"12345\") === 6, \"Test failed for input '12345'\");\n    console.assert(classifyInteger(\"999999999\") === 9, \"Test failed for input '999999999'\");\n};\n\ntestClassifyInteger();",
    "entry_point": "classifyInteger",
    "signature": "function classifyInteger(x: string): number",
    "docstring": {
      "en": "Classify the integer x based on the following method:\nIf x is a single-digit number, x belongs to its own class.\nOtherwise, sum the digits of x, get a new x, and iterate until the class is determined.\n\nParameters:\n- x (string): The string representation of the integer to be classified.\n\nReturns:\nThe class to which the integer x belongs.\n\nExample:\nclassifyInteger(\"24\") // returns 6",
      "sq": "Klasifikoni numrin e plotë x bazuar në metodën e mëposhtme:  \nNëse x është një numër njëshifror, x i përket klasës së vet.  \nPërndryshe, mblidhni shifrat e x, merrni një x të ri dhe përsëritni derisa të përcaktohet klasa.\n\nParametrat:  \n- x (string): Përfaqësimi si string i numrit të plotë që do të klasifikohet.\n\nKthen:  \nKlasa të cilës i përket numri i plotë x.\n\nShembull:  \nclassifyInteger(\"24\") // kthen 6",
      "hy": "Դասակարգել ամբողջ թիվը x հետևյալ մեթոդով:\nԵթե x-ը միանիշ թիվ է, ապա x-ը պատկանում է իր սեփական դասին:\nՀակառակ դեպքում, գումարեք x-ի թվանշանները, ստացեք նոր x և կրկնեք, մինչև դասը որոշվի:\n\nՊարամետրեր:\n- x (string): Դասակարգվող ամբողջ թվի տողի ներկայացումը։\n\nՎերադարձնում է:\nԴասը, որին պատկանում է ամբողջ թիվը x:\n\nՕրինակ:\nclassifyInteger(\"24\") // վերադարձնում է 6",
      "bn": "Classify the integer x based on the following method:\nযদি x একটি এক অঙ্কের সংখ্যা হয়, x তার নিজের শ্রেণীতে অন্তর্ভুক্ত।\nঅন্যথায়, x এর অঙ্কগুলির যোগফল নিন, একটি নতুন x পান, এবং পুনরাবৃত্তি করুন যতক্ষণ না শ্রেণী নির্ধারিত হয়।\n\nParameters:\n- x (string): শ্রেণীবদ্ধ করার জন্য পূর্ণসংখ্যার স্ট্রিং উপস্থাপনা।\n\nReturns:\nপূর্ণসংখ্যা x যে শ্রেণীতে অন্তর্ভুক্ত।\n\nExample:\nclassifyInteger(\"24\") // returns 6",
      "bg": "Класифицирайте цялото число x въз основа на следния метод:\nАко x е едноцифрено число, x принадлежи към своя собствен клас.\nВ противен случай, съберете цифрите на x, получете ново x и повтаряйте, докато класът бъде определен.\n\nПараметри:\n- x (string): Стринг представянето на цялото число, което трябва да бъде класифицирано.\n\nВръща:\nКласът, към който принадлежи цялото число x.\n\nПример:\nclassifyInteger(\"24\") // връща 6",
      "zh": "根据以下方法对整数 x 进行分类：\n如果 x 是一个个位数，则 x 属于它自己的类别。\n否则，将 x 的各位数字相加，得到一个新的 x，并迭代直到确定类别。\n\n参数:\n- x (string): 要分类的整数的字符串表示。\n\n返回:\n整数 x 所属的类别。\n\n示例:\nclassifyInteger(\"24\") // returns 6",
      "fr": "Classifiez l'entier x selon la méthode suivante :\nSi x est un nombre à un chiffre, x appartient à sa propre classe.\nSinon, additionnez les chiffres de x, obtenez un nouveau x, et itérez jusqu'à ce que la classe soit déterminée.\n\nParamètres :\n- x (string): La représentation sous forme de chaîne de l'entier à classer.\n\nRenvoie :\nLa classe à laquelle appartient l'entier x.\n\nExemple :\nclassifyInteger(\"24\") // renvoie 6",
      "de": "Klassifizieren Sie die ganze Zahl x basierend auf der folgenden Methode:\nWenn x eine einstellige Zahl ist, gehört x zu seiner eigenen Klasse.\nAndernfalls summieren Sie die Ziffern von x, erhalten ein neues x und iterieren, bis die Klasse bestimmt ist.\n\nParameter:\n- x (string): Die Zeichenfolgenrepräsentation der zu klassifizierenden ganzen Zahl.\n\nRückgabe:\nDie Klasse, zu der die ganze Zahl x gehört.\n\nBeispiel:\nclassifyInteger(\"24\") // gibt 6 zurück",
      "ha": "Classify integer x bisa ga hanyar da ke biye:\n\nIdan x lamba ce mai ɗigo ɗaya, x na cikin ajinsa.\n\nIn ba haka ba, tara lambobin x, sami sabon x, kuma maimaita har sai an tantance ajin.\n\nParameters:\n- x (string): Wakilcin kirtani na cikakken lambar da za a tantance.\n\nReturns:\nAjin da cikakken lamba x ke ciki.\n\nExample:\nclassifyInteger(\"24\") // returns 6",
      "hi": "Integer x को निम्नलिखित विधि के आधार पर वर्गीकृत करें:\nयदि x एक एकल-अंक संख्या है, तो x अपनी स्वयं की श्रेणी में आता है।\nअन्यथा, x के अंकों का योग करें, एक नया x प्राप्त करें, और तब तक पुनरावृत्ति करें जब तक कि श्रेणी निर्धारित न हो जाए।\n\nपैरामीटर्स:\n- x (string): वर्गीकृत किए जाने वाले पूर्णांक का स्ट्रिंग प्रतिनिधित्व।\n\nवापसी:\nवह श्रेणी जिसमें पूर्णांक x आता है।\n\nउदाहरण:\nclassifyInteger(\"24\") // 6 लौटाता है",
      "hu": "Osztályozza az x egész számot a következő módszer alapján:\nHa x egyjegyű szám, akkor x a saját osztályába tartozik.\nEgyébként adja össze x számjegyeit, kapjon egy új x-et, és ismételje meg, amíg az osztály meg nem határozódik.\n\nParaméterek:\n- x (string): Az osztályozandó egész szám string reprezentációja.\n\nVisszatér:\nAz osztály, amelyhez az x egész szám tartozik.\n\nPélda:\nclassifyInteger(\"24\") // visszaadja a 6-ot"
    },
    "docstring_bertscore": {
      "sq": "0.9832111643037882",
      "hy": "0.9783562405305334",
      "bn": "0.9481475390308425",
      "bg": "0.9817381213980334",
      "zh": "0.9570843171343641",
      "fr": "0.9819091421561045",
      "de": "0.9971834211969253",
      "ha": "0.9589295933741783",
      "hi": "0.9322475742897617",
      "hu": "0.9754906000233431"
    }
  },
  {
    "task_id": "TypeScript/27",
    "prompt": {
      "en": "\n/**\n * Transforms the case of a given letter.\n * \n * Parameters:\n * - letter (string): The input letter to be transformed.\n * \n * Returns:\n * - string: The letter with its case reversed. If the input is lowercase, \n *           it returns the uppercase version, and if the input is uppercase, \n *           it returns the lowercase version.\n * \n * Examples:\n * transformLetterCase('b') // Returns 'B'\n */\nfunction transformLetterCase(letter: string): string",
      "sq": "/**\n * Transformon rastin e një shkronje të dhënë.\n * \n * Parametrat:\n * - letter (string): Shkronja hyrëse që do të transformohet.\n * \n * Kthen:\n * - string: Shkronja me rastin e saj të përmbysur. Nëse hyrja është me shkronja të vogla,\n *           kthen versionin me shkronja të mëdha, dhe nëse hyrja është me shkronja të mëdha,\n *           kthen versionin me shkronja të vogla.\n * \n * Shembuj:\n * transformLetterCase('b') // Kthen 'B'\n */\nfunction transformLetterCase(letter: string): string",
      "hy": "/**\n * Փոխակերպում է տրված տառի գրությունը։\n * \n * Պարամետրեր:\n * - letter (string): Մուտքային տառը, որը պետք է փոխակերպվի։\n * \n * Վերադարձնում է:\n * - string: Տառը իր գրությունը հակադարձված։ Եթե մուտքը փոքրատառ է, \n *           վերադարձնում է մեծատառ տարբերակը, իսկ եթե մուտքը մեծատառ է, \n *           վերադարձնում է փոքրատառ տարբերակը։\n * \n * Օրինակներ:\n * transformLetterCase('b') // Վերադարձնում է 'B'\n */\nfunction transformLetterCase(letter: string): string",
      "bn": "/**\n * প্রদত্ত একটি অক্ষরের কেস পরিবর্তন করে।\n * \n * প্যারামিটার:\n * - letter (string): পরিবর্তন করার জন্য ইনপুট অক্ষর।\n * \n * রিটার্নস:\n * - string: অক্ষরটি যার কেস বিপরীত হয়েছে। যদি ইনপুট ছোট হাতের হয়, \n *           এটি বড় হাতের সংস্করণ প্রদান করে, এবং যদি ইনপুট বড় হাতের হয়, \n *           এটি ছোট হাতের সংস্করণ প্রদান করে।\n * \n * উদাহরণ:\n * transformLetterCase('b') // 'B' প্রদান করে\n */\nfunction transformLetterCase(letter: string): string",
      "bg": "/**\n * Преобразува регистъра на дадена буква.\n * \n * Параметри:\n * - letter (string): Входната буква, която ще бъде преобразувана.\n * \n * Връща:\n * - string: Буквата с обърнат регистър. Ако входът е с малки букви,\n *           връща версията с главни букви, а ако входът е с главни букви,\n *           връща версията с малки букви.\n * \n * Примери:\n * transformLetterCase('b') // Връща 'B'\n */\nfunction transformLetterCase(letter: string): string",
      "zh": "/**\n * 转换给定字母的大小写。\n * \n * 参数:\n * - letter (string): 要转换的输入字母。\n * \n * 返回:\n * - string: 大小写已反转的字母。如果输入是小写字母，\n *           则返回大写版本；如果输入是大写字母，\n *           则返回小写版本。\n * \n * 示例:\n * transformLetterCase('b') // 返回 'B'\n */\nfunction transformLetterCase(letter: string): string",
      "fr": "/**\n * Transforme la casse d'une lettre donnée.\n * \n * Paramètres:\n * - letter (string): La lettre d'entrée à transformer.\n * \n * Renvoie:\n * - string: La lettre avec sa casse inversée. Si l'entrée est en minuscule,\n *           elle renvoie la version majuscule, et si l'entrée est en majuscule,\n *           elle renvoie la version minuscule.\n * \n * Exemples:\n * transformLetterCase('b') // Renvoie 'B'\n */\nfunction transformLetterCase(letter: string): string",
      "de": "/**\n * Wandelt den Fall eines gegebenen Buchstabens um.\n * \n * Parameter:\n * - letter (string): Der Eingabebuchstabe, der umgewandelt werden soll.\n * \n * Rückgabe:\n * - string: Der Buchstabe mit umgekehrtem Fall. Wenn die Eingabe klein ist,\n *           wird die Großbuchstabenversion zurückgegeben, und wenn die Eingabe groß ist,\n *           wird die Kleinbuchstabenversion zurückgegeben.\n * \n * Beispiele:\n * transformLetterCase('b') // Gibt 'B' zurück\n */\nfunction transformLetterCase(letter: string): string",
      "ha": "/**\n * Canza harafin da aka bayar daga babba zuwa ƙanana ko akasin haka.\n * \n * Sigogi:\n * - letter (string): Harafin shigarwa da za a canza.\n * \n * Yana dawowa:\n * - string: Harafin da aka canza daga babba zuwa ƙanana ko daga ƙanana zuwa babba. Idan shigarwar harafi ne ƙanana, \n *           yana dawowa da babba, idan kuma babba ne, yana dawowa da ƙanana.\n * \n * Misalai:\n * transformLetterCase('b') // Yana dawowa da 'B'\n */\nfunction transformLetterCase(letter: string): string",
      "hi": "/**\n * दिए गए अक्षर के मामले को बदलता है।\n * \n * पैरामीटर:\n * - letter (string): इनपुट अक्षर जिसे बदला जाना है।\n * \n * रिटर्न करता है:\n * - string: अक्षर जिसका मामला उलट दिया गया है। यदि इनपुट लोअरकेस है,\n *           तो यह अपरकेस संस्करण लौटाता है, और यदि इनपुट अपरकेस है,\n *           तो यह लोअरकेस संस्करण लौटाता है।\n * \n * उदाहरण:\n * transformLetterCase('b') // Returns 'B'\n */\nfunction transformLetterCase(letter: string): string",
      "hu": "/**\n * Egy adott betű esetének átalakítása.\n * \n * Paraméterek:\n * - letter (string): Az átalakítandó bemeneti betű.\n * \n * Visszatér:\n * - string: A betű megfordított esettel. Ha a bemenet kisbetűs, \n *           akkor a nagybetűs változatot adja vissza, és ha a bemenet nagybetűs, \n *           akkor a kisbetűs változatot adja vissza.\n * \n * Példák:\n * transformLetterCase('b') // Visszaadja: 'B'\n */\nfunction transformLetterCase(letter: string): string"
    },
    "prompt_bertscore": {
      "sq": "0.989569720061477",
      "hy": "0.9812709427418393",
      "bn": "0.9522178727990094",
      "bg": "0.9749105993107212",
      "zh": "0.9695046748604756",
      "fr": "0.9910803041092473",
      "de": "0.9752317846368547",
      "ha": "0.8840002547363873",
      "hi": "0.9630376669147418",
      "hu": "0.9778050412231616"
    },
    "canonical_solution": "{\n    if (letter >= 'A' && letter <= 'Z') {\n        return letter.toLowerCase();\n    } else if (letter >= 'a' && letter <= 'z') {\n        return letter.toUpperCase();\n    } else {\n        // Non-alphabetic characters are returned unchanged\n        return letter;\n    }\n}",
    "instruction": {
      "en": "Write a TypeScript function `function transformLetterCase(letter: string): string` to solve the following problem:\nTransforms the case of a given letter.\n\nParameters:\n- letter (string): The input letter to be transformed.\n\nReturns:\n- string: The letter with its case reversed. If the input is lowercase, it returns the uppercase version, and if the input is uppercase, it returns the lowercase version.\n\nExamples:\ntransformLetterCase('b') // Returns 'B'",
      "sq": "Shkruani një funksion TypeScript `function transformLetterCase(letter: string): string` për të zgjidhur problemin e mëposhtëm:\nTransformon rastin e një shkronje të dhënë.\n\nParametrat:\n- letter (string): Shkronja hyrëse që do të transformohet.\n\nKthen:\n- string: Shkronja me rastin e saj të kthyer. Nëse hyrja është me shkronja të vogla, kthen versionin me shkronja të mëdha, dhe nëse hyrja është me shkronja të mëdha, kthen versionin me shkronja të vogla.\n\nShembuj:\ntransformLetterCase('b') // Kthen 'B'",
      "hy": "TypeScript ֆունկցիա գրեք `function transformLetterCase(letter: string): string` հետևյալ խնդիրը լուծելու համար:\nՓոխակերպում է տրված տառի ռեգիստրը։\n\nՊարամետրեր:\n- letter (string): Մուտքային տառը, որը պետք է փոխակերպվի։\n\nՎերադարձնում է:\n- string: Տառը՝ իր ռեգիստրը փոխված։ Եթե մուտքագրումը փոքրատառ է, վերադարձնում է մեծատառ տարբերակը, և եթե մուտքագրումը մեծատառ է, վերադարձնում է փոքրատառ տարբերակը։\n\nՕրինակներ:\ntransformLetterCase('b') // Վերադարձնում է 'B'",
      "bn": "TypeScript ফাংশন `function transformLetterCase(letter: string): string` লিখুন নিম্নলিখিত সমস্যার সমাধানের জন্য:\nএকটি প্রদত্ত অক্ষরের কেস পরিবর্তন করে।\n\nপ্যারামিটারসমূহ:\n- letter (string): পরিবর্তনের জন্য ইনপুট অক্ষর।\n\nফেরত দেয়:\n- string: অক্ষরটি যার কেস উল্টানো হয়েছে। যদি ইনপুট ছোট হাতের হয়, এটি বড় হাতের সংস্করণ ফেরত দেয়, এবং যদি ইনপুট বড় হাতের হয়, এটি ছোট হাতের সংস্করণ ফেরত দেয়।\n\nউদাহরণ:\ntransformLetterCase('b') // Returns 'B'",
      "bg": "Напишете TypeScript функция `function transformLetterCase(letter: string): string`, за да решите следния проблем:\nПреобразува регистъра на дадена буква.\n\nПараметри:\n- letter (string): Входната буква, която ще бъде преобразувана.\n\nВръща:\n- string: Буквата с обърнат регистър. Ако входът е с малки букви, връща версията с главни букви, а ако входът е с главни букви, връща версията с малки букви.\n\nПримери:\ntransformLetterCase('b') // Връща 'B'",
      "zh": "编写一个 TypeScript 函数 `function transformLetterCase(letter: string): string` 来解决以下问题：\n将给定字母的大小写转换。\n\n参数：\n- letter (string): 要转换的输入字母。\n\n返回：\n- string: 大小写已反转的字母。如果输入是小写，则返回大写版本；如果输入是大写，则返回小写版本。\n\n示例：\ntransformLetterCase('b') // 返回 'B'",
      "fr": "Écrire une fonction TypeScript `function transformLetterCase(letter: string): string` pour résoudre le problème suivant :\nTransforme la casse d'une lettre donnée.\n\nParamètres :\n- letter (string) : La lettre d'entrée à transformer.\n\nRenvoie :\n- string : La lettre avec sa casse inversée. Si l'entrée est en minuscule, elle renvoie la version majuscule, et si l'entrée est en majuscule, elle renvoie la version minuscule.\n\nExemples :\ntransformLetterCase('b') // Renvoie 'B'",
      "de": "Schreiben Sie eine TypeScript-Funktion `function transformLetterCase(letter: string): string`, um das folgende Problem zu lösen:\nTransformiert die Groß-/Kleinschreibung eines gegebenen Buchstabens.\n\nParameter:\n- letter (string): Der zu transformierende Eingabebuchstabe.\n\nRückgabewert:\n- string: Der Buchstabe mit umgekehrter Groß-/Kleinschreibung. Wenn die Eingabe klein geschrieben ist, wird die Großbuchstabenversion zurückgegeben, und wenn die Eingabe groß geschrieben ist, wird die Kleinbuchstabenversion zurückgegeben.\n\nBeispiele:\ntransformLetterCase('b') // Gibt 'B' zurück",
      "ha": "Rubuta aikin TypeScript `function transformLetterCase(letter: string): string` don warware matsalar mai zuwa:\nCanza yanayin harafin da aka bayar.\n\nSigogi:\n- letter (string): Harafin shigarwa da za a canza.\n\nDawowa:\n- string: Harafin tare da yanayin da aka juya. Idan shigarwar tana cikin ƙananan haruffa, tana mayar da sigar manyan haruffa, kuma idan shigarwar tana cikin manyan haruffa, tana mayar da sigar ƙananan haruffa.\n\nMisalai:\ntransformLetterCase('b') // Yana dawowa 'B'",
      "hi": "TypeScript फ़ंक्शन `function transformLetterCase(letter: string): string` लिखें ताकि निम्नलिखित समस्या का समाधान किया जा सके:\nदिए गए अक्षर के केस को बदलता है।\n\nपैरामीटर्स:\n- letter (string): वह इनपुट अक्षर जिसे परिवर्तित किया जाना है।\n\nवापसी:\n- string: अक्षर जिसके केस को उलट दिया गया है। यदि इनपुट लोअरकेस है, तो यह अपरकेस संस्करण लौटाता है, और यदि इनपुट अपरकेस है, तो यह लोअरकेस संस्करण लौटाता है।\n\nउदाहरण:\ntransformLetterCase('b') // 'B' लौटाता है",
      "hu": "Készíts egy TypeScript függvényt `function transformLetterCase(letter: string): string` a következő probléma megoldására:\nÁtalakítja egy adott betű esetét.\n\nParaméterek:\n- letter (string): Az átalakítandó bemeneti betű.\n\nVisszatérési érték:\n- string: A betű az ellentétes esettel. Ha a bemenet kisbetűs, akkor a nagybetűs változatot adja vissza, és ha a bemenet nagybetűs, akkor a kisbetűs változatot adja vissza.\n\nPéldák:\ntransformLetterCase('b') // Returns 'B'"
    },
    "instruction_bertscore": {
      "sq": "1",
      "hy": "0.973150138243609",
      "bn": "0.9458021114915824",
      "bg": "0.9837138977981874",
      "zh": "0.9654661219532743",
      "fr": "0.9905243376727306",
      "de": "0.9780390278120207",
      "ha": "0.9748448526545986",
      "hi": "0.9674385216369508",
      "hu": "0.978183233468652"
    },
    "level": "easy",
    "test": "const testTransformLetterCase = (): void => {\n    console.assert(transformLetterCase('b') === 'B', 'Test failed: transformLetterCase(\\'b\\') should return \\'B\\'');\n    console.assert(transformLetterCase('B') === 'b', 'Test failed: transformLetterCase(\\'B\\') should return \\'b\\'');\n    console.assert(transformLetterCase('z') === 'Z', 'Test failed: transformLetterCase(\\'z\\') should return \\'Z\\'');\n    console.assert(transformLetterCase('Z') === 'z', 'Test failed: transformLetterCase(\\'Z\\') should return \\'z\\'');\n    console.assert(transformLetterCase('m') === 'M', 'Test failed: transformLetterCase(\\'m\\') should return \\'M\\'');\n    console.assert(transformLetterCase('M') === 'm', 'Test failed: transformLetterCase(\\'M\\') should return \\'m\\'');\n    console.assert(transformLetterCase('1') === '1', 'Test failed: transformLetterCase(\\'1\\') should return \\'1\\' (unchanged)');\n    console.assert(transformLetterCase('!') === '!', 'Test failed: transformLetterCase(\\'!\\') should return \\'!\\' (unchanged)');\n\n    // console.log(\"All tests passed successfully.\");\n};\n\ntestTransformLetterCase();",
    "entry_point": "transformLetterCase",
    "signature": "function transformLetterCase(letter: string): string",
    "docstring": {
      "en": "Transforms the case of a given letter.\n\nParameters:\n- letter (string): The input letter to be transformed.\n\nReturns:\n- string: The letter with its case reversed. If the input is lowercase, it returns the uppercase version, and if the input is uppercase, it returns the lowercase version.\n\nExamples:\ntransformLetterCase('b') // Returns 'B'",
      "sq": "Transformon rastin e një shkronje të dhënë.\n\nParametrat:\n- letter (string): Shkronja hyrëse që do të transformohet.\n\nKthen:\n- string: Shkronja me rastin e saj të kthyer. Nëse hyrja është me shkronja të vogla, kthen versionin me shkronja të mëdha, dhe nëse hyrja është me shkronja të mëdha, kthen versionin me shkronja të vogla.\n\nShembuj:\ntransformLetterCase('b') // Kthen 'B'",
      "hy": "Փոխակերպում է տրված տառի ռեգիստրը։\n\nՊարամետրեր:\n- letter (string): Մուտքային տառը, որը պետք է փոխակերպվի։\n\nՎերադարձնում է:\n- string: Տառը՝ իր ռեգիստրը հակադարձված։ Եթե մուտքը փոքրատառ է, վերադարձնում է մեծատառ տարբերակը, իսկ եթե մուտքը մեծատառ է, վերադարձնում է փոքրատառ տարբերակը։\n\nՕրինակներ:\ntransformLetterCase('b') // Վերադարձնում է 'B'",
      "bn": "একটি প্রদত্ত অক্ষরের কেস পরিবর্তন করে।\n\nপ্যারামিটারসমূহ:\n- letter (string): পরিবর্তন করার জন্য ইনপুট অক্ষর।\n\nফেরত দেয়:\n- string: অক্ষরটি যার কেস বিপরীত করা হয়েছে। যদি ইনপুট ছোট হাতের হয়, এটি বড় হাতের সংস্করণ ফেরত দেয়, এবং যদি ইনপুট বড় হাতের হয়, এটি ছোট হাতের সংস্করণ ফেরত দেয়।\n\nউদাহরণ:\ntransformLetterCase('b') // Returns 'B'",
      "bg": "Преобразува регистъра на дадена буква.\n\nПараметри:\n- letter (string): Входната буква, която ще бъде преобразувана.\n\nВръща:\n- string: Буквата с обърнат регистър. Ако входът е с малки букви, връща версията с главни букви, а ако входът е с главни букви, връща версията с малки букви.\n\nПримери:\ntransformLetterCase('b') // Връща 'B'",
      "zh": "转换给定字母的大小写。\n\n参数：\n- letter (string): 要转换的输入字母。\n\n返回：\n- string: 大小写已反转的字母。如果输入为小写，则返回大写版本；如果输入为大写，则返回小写版本。\n\n示例：\ntransformLetterCase('b') // 返回 'B'",
      "fr": "Transforme la casse d'une lettre donnée.\n\nParamètres :\n- letter (string): La lettre d'entrée à transformer.\n\nRenvoie :\n- string: La lettre avec sa casse inversée. Si l'entrée est en minuscule, elle renvoie la version majuscule, et si l'entrée est en majuscule, elle renvoie la version minuscule.\n\nExemples :\ntransformLetterCase('b') // Renvoie 'B'",
      "de": "Verändert die Groß- und Kleinschreibung eines gegebenen Buchstabens.\n\nParameter:\n- letter (string): Der Eingabebuchstabe, der transformiert werden soll.\n\nRückgabewert:\n- string: Der Buchstabe mit umgekehrter Groß- und Kleinschreibung. Wenn die Eingabe klein geschrieben ist, wird die Großbuchstabenversion zurückgegeben, und wenn die Eingabe groß geschrieben ist, wird die Kleinbuchstabenversion zurückgegeben.\n\nBeispiele:\ntransformLetterCase('b') // Gibt 'B' zurück",
      "ha": "Transforms the case of a given letter.\n\nParameters:\n- letter (string): Harafin shigarwa da za a canza.\n\nReturns:\n- string: Harafin tare da canjin rubutunsa. Idan shigarwar harafi ƙarami ne, zai dawo da babbar sigar, kuma idan shigarwar babba ce, zai dawo da ƙaramin sigar.\n\nExamples:\ntransformLetterCase('b') // Returns 'B'",
      "hi": "Transforms the case of a given letter.\n\nमापदंड:\n- letter (string): इनपुट अक्षर जिसे परिवर्तित किया जाना है।\n\nवापसी:\n- string: अक्षर जिसका केस उलट दिया गया है। यदि इनपुट लोअरकेस है, तो यह अपरकेस संस्करण लौटाता है, और यदि इनपुट अपरकेस है, तो यह लोअरकेस संस्करण लौटाता है।\n\nउदाहरण:\ntransformLetterCase('b') // Returns 'B'",
      "hu": "Átalakítja egy adott betű esetét.\n\nParaméterek:\n- letter (string): Az átalakítandó bemeneti betű.\n\nVisszatér:\n- string: A betű, amelynek az esete megfordult. Ha a bemenet kisbetűs, akkor a nagybetűs változatot adja vissza, és ha a bemenet nagybetűs, akkor a kisbetűs változatot adja vissza.\n\nPéldák:\ntransformLetterCase('b') // Visszaadja 'B'"
    },
    "docstring_bertscore": {
      "sq": "1",
      "hy": "0.9717478077535027",
      "bn": "0.9281148705819499",
      "bg": "0.9648527513366386",
      "zh": "0.9534698400906723",
      "fr": "0.9749874692681817",
      "de": "0.9620037957814552",
      "ha": "0.9803739279410858",
      "hi": "0.979020460524714",
      "hu": "0.983847774675005"
    }
  },
  {
    "task_id": "TypeScript/28",
    "prompt": {
      "en": "\n/**\n * Display the ASCII information for a given character.\n * \n * Parameters:\n * - character (string): The input character for which ASCII information is to be displayed.\n *    \n * Returns:\n * - number: corresponding ASCII code\n *    \n * Examples:\n * ```\n * console.log(display_ascii_info('A'));\n * // expected output: 65\n * ```\n */\nfunction display_ascii_info(character: string): number",
      "sq": "/**\n * Shfaq informacionin ASCII për një karakter të dhënë.\n * \n * Parametrat:\n * - character (string): Karakteri hyrës për të cilin do të shfaqet informacioni ASCII.\n *    \n * Kthen:\n * - number: kodi përkatës ASCII\n *    \n * Shembuj:\n * ```\n * console.log(display_ascii_info('A'));\n * // rezultati i pritur: 65\n * ```\n */\nfunction display_ascii_info(character: string): number",
      "hy": "/**\n * Ցուցադրել ASCII տեղեկատվությունը տրված սիմվոլի համար:\n * \n * Պարամետրեր:\n * - character (string): Մուտքային սիմվոլը, որի համար պետք է ցուցադրվի ASCII տեղեկատվությունը:\n *    \n * Վերադարձնում է:\n * - number: համապատասխան ASCII կոդը\n *    \n * Օրինակներ:\n * ```\n * console.log(display_ascii_info('A'));\n * // սպասվող արդյունք: 65\n * ```\n */\nfunction display_ascii_info(character: string): number",
      "bn": "/**\n * প্রদত্ত অক্ষরের জন্য ASCII তথ্য প্রদর্শন করুন।\n * \n * প্যারামিটার:\n * - character (string): ইনপুট অক্ষর যার জন্য ASCII তথ্য প্রদর্শন করা হবে।\n *    \n * রিটার্নস:\n * - number: সংশ্লিষ্ট ASCII কোড\n *    \n * উদাহরণ:\n * ```\n * console.log(display_ascii_info('A'));\n * // প্রত্যাশিত আউটপুট: 65\n * ```\n */\nfunction display_ascii_info(character: string): number",
      "bg": "/**\n * Показва ASCII информацията за даден символ.\n * \n * Параметри:\n * - character (string): Входният символ, за който ще се покаже ASCII информацията.\n *    \n * Връща:\n * - number: съответстващ ASCII код\n *    \n * Примери:\n * ```\n * console.log(display_ascii_info('A'));\n * // очакван изход: 65\n * ```\n */\nfunction display_ascii_info(character: string): number",
      "zh": "/**\n * 显示给定字符的ASCII信息。\n * \n * 参数:\n * - character (string): 要显示ASCII信息的输入字符。\n *    \n * 返回:\n * - number: 对应的ASCII码\n *    \n * 示例:\n * ```\n * console.log(display_ascii_info('A'));\n * // 预期输出: 65\n * ```\n */\nfunction display_ascii_info(character: string): number",
      "fr": "/**\n * Afficher les informations ASCII pour un caractère donné.\n * \n * Paramètres:\n * - character (string): Le caractère d'entrée pour lequel les informations ASCII doivent être affichées.\n *    \n * Renvoie:\n * - number: code ASCII correspondant\n *    \n * Exemples:\n * ```\n * console.log(display_ascii_info('A'));\n * // résultat attendu: 65\n * ```\n */\nfunction display_ascii_info(character: string): number",
      "de": "/**\n * Zeigt die ASCII-Informationen für ein gegebenes Zeichen an.\n * \n * Parameter:\n * - character (string): Das Eingabezeichen, für das die ASCII-Informationen angezeigt werden sollen.\n *    \n * Rückgabewerte:\n * - number: entsprechender ASCII-Code\n *    \n * Beispiele:\n * ```\n * console.log(display_ascii_info('A'));\n * // erwartete Ausgabe: 65\n * ```\n */\nfunction display_ascii_info(character: string): number",
      "ha": "/**\n * Nuna bayanin ASCII don wata alama da aka bayar.\n * \n * Sigogi:\n * - character (string): Alamar shigarwa wadda za a nuna bayanin ASCII dinta.\n *    \n * Komawa:\n * - number: lambar ASCII da ta dace\n *    \n * Misalai:\n * ```\n * console.log(display_ascii_info('A'));\n * // sakamakon da ake tsammani: 65\n * ```\n */\nfunction display_ascii_info(character: string): number",
      "hi": "/**\n * दिए गए वर्ण के लिए ASCII जानकारी प्रदर्शित करें।\n * \n * पैरामीटर्स:\n * - character (string): इनपुट वर्ण जिसके लिए ASCII जानकारी प्रदर्शित की जानी है।\n *    \n * रिटर्न करता है:\n * - number: संबंधित ASCII कोड\n *    \n * उदाहरण:\n * ```\n * console.log(display_ascii_info('A'));\n * // अपेक्षित आउटपुट: 65\n * ```\n */\nfunction display_ascii_info(character: string): number",
      "hu": "/**\n * Megjeleníti a megadott karakter ASCII információit.\n * \n * Paraméterek:\n * - character (string): Az a bemeneti karakter, amelynek az ASCII információit meg kell jeleníteni.\n *    \n * Visszatér:\n * - number: a megfelelő ASCII kód\n *    \n * Példák:\n * ```\n * console.log(display_ascii_info('A'));\n * // várt kimenet: 65\n * ```\n */\nfunction display_ascii_info(character: string): number"
    },
    "prompt_bertscore": {
      "sq": "0.9824855675218677",
      "hy": "0.9819911765034719",
      "bn": "0.9715563280661851",
      "bg": "0.9865316683835483",
      "zh": "0.9739724680210934",
      "fr": "0.9835512195161199",
      "de": "0.9791511593154351",
      "ha": "0.9657426154436749",
      "hi": "0.9782581171223022",
      "hu": "0.9725314046066853"
    },
    "canonical_solution": "{\n    return character.charCodeAt(0);\n}",
    "instruction": {
      "en": "Write a TypeScript function `function display_ascii_info(character: string): number` to solve the following problem:\nDisplay the ASCII information for a given character.\n\nParameters:\n- character (string): The input character for which ASCII information is to be displayed.\n\nReturns:\n- number: corresponding ASCII code\n\nExamples:\n```\nconsole.log(display_ascii_info('A'));\n// expected output: 65\n```\n",
      "sq": "Shkruani një funksion TypeScript `function display_ascii_info(character: string): number` për të zgjidhur problemin e mëposhtëm:\nShfaq informacionin ASCII për një karakter të dhënë.\n\nParametrat:\n- character (string): Karakteri hyrës për të cilin do të shfaqet informacioni ASCII.\n\nKthen:\n- number: kodi përkatës ASCII\n\nShembuj:\n```\nconsole.log(display_ascii_info('A'));\n// expected output: 65\n```",
      "hy": "TypeScript ֆունկցիա գրեք `function display_ascii_info(character: string): number` հետևյալ խնդիրը լուծելու համար:\nՑուցադրել ASCII տեղեկատվությունը տրված սիմվոլի համար:\n\nՊարամետրեր:\n- character (string): Մուտքային սիմվոլը, որի համար պետք է ցուցադրվի ASCII տեղեկատվությունը:\n\nՎերադարձնում է:\n- number: համապատասխան ASCII կոդը\n\nՕրինակներ:\n```\nconsole.log(display_ascii_info('A'));\n// expected output: 65\n```",
      "bn": "একটি TypeScript ফাংশন `function display_ascii_info(character: string): number` লিখুন নিম্নলিখিত সমস্যার সমাধানের জন্য:\nএকটি প্রদত্ত অক্ষরের জন্য ASCII তথ্য প্রদর্শন করুন।\n\nপ্যারামিটারসমূহ:\n- character (string): ইনপুট অক্ষর যার জন্য ASCII তথ্য প্রদর্শন করা হবে।\n\nরিটার্নস:\n- number: সংশ্লিষ্ট ASCII কোড\n\nউদাহরণসমূহ:\n```\nconsole.log(display_ascii_info('A'));\n// expected output: 65\n```",
      "bg": "Напишете TypeScript функция `function display_ascii_info(character: string): number`, за да решите следния проблем:  \nПоказване на ASCII информацията за даден символ.\n\nПараметри:\n- character (string): Входният символ, за който трябва да се покаже ASCII информацията.\n\nВръща:\n- number: съответстващ ASCII код\n\nПримери:\n```\nconsole.log(display_ascii_info('A'));\n// expected output: 65\n```",
      "zh": "编写一个 TypeScript 函数 `function display_ascii_info(character: string): number` 来解决以下问题：\n显示给定字符的 ASCII 信息。\n\n参数：\n- character (string): 要显示 ASCII 信息的输入字符。\n\n返回：\n- number: 对应的 ASCII 码\n\n示例：\n```\nconsole.log(display_ascii_info('A'));\n// 预期输出: 65\n```",
      "fr": "Écrire une fonction TypeScript `function display_ascii_info(character: string): number` pour résoudre le problème suivant :\nAfficher les informations ASCII pour un caractère donné.\n\nParamètres :\n- character (string): Le caractère d'entrée pour lequel les informations ASCII doivent être affichées.\n\nRenvoie :\n- number: code ASCII correspondant\n\nExemples :\n```\nconsole.log(display_ascii_info('A'));\n// expected output: 65\n```",
      "de": "Schreiben Sie eine TypeScript-Funktion `function display_ascii_info(character: string): number`, um das folgende Problem zu lösen:\nZeigen Sie die ASCII-Informationen für ein gegebenes Zeichen an.\n\nParameter:\n- character (string): Das Eingabezeichen, für das die ASCII-Informationen angezeigt werden sollen.\n\nRückgabewert:\n- number: entsprechender ASCII-Code\n\nBeispiele:\n```\nconsole.log(display_ascii_info('A'));\n// erwartete Ausgabe: 65\n```",
      "ha": "Rubuta aikin TypeScript `function display_ascii_info(character: string): number` don warware matsalar mai zuwa: Nuna bayanin ASCII don wata alama da aka bayar.\n\nSigogi:\n- character (string): Harafin shigarwa wanda za a nuna bayanin ASCII.\n\nDawowa:\n- number: lambar ASCII da ta dace\n\nMisalai:\n```\nconsole.log(display_ascii_info('A'));\n// expected output: 65\n```",
      "hi": "TypeScript फ़ंक्शन `function display_ascii_info(character: string): number` लिखें ताकि निम्नलिखित समस्या का समाधान किया जा सके:\nदिए गए वर्ण के लिए ASCII जानकारी प्रदर्शित करें।\n\nपैरामीटर्स:\n- character (string): वह इनपुट वर्ण जिसके लिए ASCII जानकारी प्रदर्शित की जानी है।\n\nवापसी:\n- number: संबंधित ASCII कोड\n\nउदाहरण:\n```\nconsole.log(display_ascii_info('A'));\n// अपेक्षित आउटपुट: 65\n```",
      "hu": "Írj egy TypeScript függvényt `function display_ascii_info(character: string): number` a következő probléma megoldására:  \nJelenítsd meg az ASCII információt egy adott karakterhez.\n\nParaméterek:\n- character (string): Az a bemeneti karakter, amelyhez az ASCII információt meg kell jeleníteni.\n\nVisszatérési érték:\n- number: a megfelelő ASCII kód\n\nPéldák:\n```\nconsole.log(display_ascii_info('A'));\n// elvárt kimenet: 65\n```"
    },
    "instruction_bertscore": {
      "sq": "0.9868464975374887",
      "hy": "0.966773308490865",
      "bn": "0.9846873852956395",
      "bg": "0.9898571382228345",
      "zh": "0.9581116334650766",
      "fr": "0.9882806088885605",
      "de": "0.9870034155385062",
      "ha": "0.98245338940014",
      "hi": "0.9618768709679739",
      "hu": "0.9801373591572733"
    },
    "level": "easy",
    "test": "const testDisplayAsciiInfo = (): void => {\n    console.assert(display_ascii_info('A') === 65);\n    console.assert(display_ascii_info('B') === 66); // Additional test case\n    console.assert(display_ascii_info('0') === 48); // Additional test case\n    console.assert(display_ascii_info(' ') === 32); // Additional test case\n    // console.log(\"All tests passed.\");\n};\n\ntestDisplayAsciiInfo();",
    "entry_point": "display_ascii_info",
    "signature": "function display_ascii_info(character: string): number",
    "docstring": {
      "en": "Display the ASCII information for a given character.\n\nParameters:\n- character (string): The input character for which ASCII information is to be displayed.\n\nReturns:\n- number: corresponding ASCII code\n\nExamples:\n```\nconsole.log(display_ascii_info('A'));\n// expected output: 65\n```\n",
      "sq": "Shfaq informacionin ASCII për një karakter të dhënë.\n\nParametra:\n- character (string): Karakteri i hyrjes për të cilin informacioni ASCII do të shfaqet.\n\nKthen:\n- number: kodi përkatës ASCII\n\nShembuj:\n```\nconsole.log(display_ascii_info('A'));\n// expected output: 65\n```",
      "hy": "Display the ASCII տեղեկատվությունը տրված սիմվոլի համար։\n\nՊարամետրեր:\n- character (string): Մուտքային սիմվոլը, որի համար պետք է ցուցադրվի ASCII տեղեկատվությունը։\n\nՎերադարձնում է:\n- number: համապատասխան ASCII կոդը\n\nՕրինակներ:\n```\nconsole.log(display_ascii_info('A'));\n// expected output: 65\n```",
      "bn": "Display the ASCII তথ্য একটি প্রদত্ত অক্ষরের জন্য।\n\nParameters:\n- character (string): ইনপুট অক্ষর যার জন্য ASCII তথ্য প্রদর্শন করা হবে।\n\nReturns:\n- number: সংশ্লিষ্ট ASCII কোড\n\nExamples:\n```\nconsole.log(display_ascii_info('A'));\n// expected output: 65\n```",
      "bg": "Показва ASCII информацията за даден символ.\n\nПараметри:\n- character (string): Входният символ, за който трябва да се покаже ASCII информация.\n\nВръща:\n- number: съответстващ ASCII код\n\nПримери:\n```\nconsole.log(display_ascii_info('A'));\n// очакван резултат: 65\n```",
      "zh": "显示给定字符的ASCII信息。\n\n参数:\n- character (string): 要显示ASCII信息的输入字符。\n\n返回:\n- number: 对应的ASCII码\n\n示例:\n```\nconsole.log(display_ascii_info('A'));\n// 预期输出: 65\n```",
      "fr": "Afficher les informations ASCII pour un caractère donné.\n\nParamètres:\n- character (string): Le caractère d'entrée pour lequel les informations ASCII doivent être affichées.\n\nRenvoie:\n- number: code ASCII correspondant\n\nExemples:\n```\nconsole.log(display_ascii_info('A'));\n// expected output: 65\n```",
      "de": "Zeigt die ASCII-Informationen für ein gegebenes Zeichen an.\n\nParameter:\n- character (string): Das Eingabezeichen, für das die ASCII-Informationen angezeigt werden sollen.\n\nRückgabewert:\n- number: entsprechender ASCII-Code\n\nBeispiele:\n```\nconsole.log(display_ascii_info('A'));\n// erwartete Ausgabe: 65\n```",
      "ha": "Nuna bayanin ASCII don wata alama da aka bayar.\n\nSigogi:\n- character (string): Harafin shigarwa wanda za a nuna bayanin ASCII.\n\nDawowa:\n- number: lambar ASCII da ta dace\n\nMisalai:\n```\nconsole.log(display_ascii_info('A'));\n// expected output: 65\n```",
      "hi": "Display the ASCII जानकारी किसी दिए गए अक्षर के लिए।\n\nपैरामीटर्स:\n- character (string): इनपुट अक्षर जिसके लिए ASCII जानकारी प्रदर्शित की जानी है।\n\nवापसी:\n- number: संबंधित ASCII कोड\n\nउदाहरण:\n```\nconsole.log(display_ascii_info('A'));\n// अपेक्षित आउटपुट: 65\n```",
      "hu": "Adja meg egy adott karakter ASCII információját.\n\nParaméterek:\n- character (string): Az a bemeneti karakter, amelynek ASCII információját meg kell jeleníteni.\n\nVisszatér:\n- number: a megfelelő ASCII kód\n\nPéldák:\n```\nconsole.log(display_ascii_info('A'));\n// várható kimenet: 65\n```"
    },
    "docstring_bertscore": {
      "sq": "0.9805983802716552",
      "hy": "0.9790286043703365",
      "bn": "0.9784491995488578",
      "bg": "0.9696417298233898",
      "zh": "0.9705623816394865",
      "fr": "0.9872761350516671",
      "de": "0.9707429366558472",
      "ha": "0.9472316543438906",
      "hi": "0.9813637031297826",
      "hu": "0.9650772036672081"
    }
  },
  {
    "task_id": "TypeScript/29",
    "prompt": {
      "en": "\n/**\n * Evaluate the grade for an input integer.\n * @param score - The integer score to be evaluated.\n * @returns The grade corresponding to the input score.\n *          If the score is between 90 and 100 (inclusive), returns 'A'.\n *          Otherwise, returns 'B'.\n * \n * Examples:\n * evaluateIntegerGrade(90) // returns 'A'\n *\n */\nfunction evaluateIntegerGrade(score: number): string",
      "sq": "/**\n * Vlerëson notën për një numër të plotë hyrës.\n * @param score - Nota e plotë që do të vlerësohet.\n * @returns Nota që korrespondon me notën hyrëse.\n *          Nëse nota është midis 90 dhe 100 (përfshirëse), kthen 'A'.\n *          Përndryshe, kthen 'B'.\n * \n * Shembuj:\n * evaluateIntegerGrade(90) // kthen 'A'\n *\n */\nfunction evaluateIntegerGrade(score: number): string",
      "hy": "/**\n * Գնահատել գնահատականը մուտքային ամբողջ թվի համար։\n * @param score - Գնահատման ենթակա ամբողջ թիվը։\n * @returns Մուտքային գնահատականին համապատասխանող գնահատականը։\n *          Եթե գնահատականը 90 և 100 (ներառյալ) միջև է, վերադարձնում է 'A'։\n *          Հակառակ դեպքում, վերադարձնում է 'B'։\n * \n * Օրինակներ:\n * evaluateIntegerGrade(90) // վերադարձնում է 'A'\n *\n */\nfunction evaluateIntegerGrade(score: number): string",
      "bn": "/**\n * একটি ইনপুট পূর্ণসংখ্যার জন্য গ্রেড মূল্যায়ন করুন।\n * @param score - মূল্যায়ন করার জন্য পূর্ণসংখ্যার স্কোর।\n * @returns ইনপুট স্কোরের সাথে সম্পর্কিত গ্রেড।\n *          যদি স্কোর 90 এবং 100 এর মধ্যে (অন্তর্ভুক্ত) হয়, তবে 'A' প্রদান করে।\n *          অন্যথায়, 'B' প্রদান করে।\n * \n * উদাহরণ:\n * evaluateIntegerGrade(90) // 'A' প্রদান করে\n *\n */\nfunction evaluateIntegerGrade(score: number): string",
      "bg": "/**\n * Оценете оценката за входящо цяло число.\n * @param score - Цялото число, което трябва да бъде оценено.\n * @returns Оценката, съответстваща на входящия резултат.\n *          Ако резултатът е между 90 и 100 (включително), връща 'A'.\n *          В противен случай, връща 'B'.\n * \n * Примери:\n * evaluateIntegerGrade(90) // връща 'A'\n *\n */\nfunction evaluateIntegerGrade(score: number): string",
      "zh": "/**\n * 评估输入整数的等级。\n * @param score - 要评估的整数分数。\n * @returns 与输入分数对应的等级。\n *          如果分数在90到100之间（包括90和100），返回 'A'。\n *          否则，返回 'B'。\n * \n * 示例:\n * evaluateIntegerGrade(90) // returns 'A'\n *\n */\nfunction evaluateIntegerGrade(score: number): string",
      "fr": "/**\n * Évaluer la note pour un entier en entrée.\n * @param score - Le score entier à évaluer.\n * @returns La note correspondant au score en entrée.\n *          Si le score est entre 90 et 100 (inclus), retourne 'A'.\n *          Sinon, retourne 'B'.\n * \n * Exemples:\n * evaluateIntegerGrade(90) // returns 'A'\n *\n */\nfunction evaluateIntegerGrade(score: number): string",
      "de": "/**\n * Bewerte die Note für eine Eingabeganzzahl.\n * @param score - Die zu bewertende Ganzzahlpunktzahl.\n * @returns Die Note, die der Eingabepunktzahl entspricht.\n *          Wenn die Punktzahl zwischen 90 und 100 (einschließlich) liegt, wird 'A' zurückgegeben.\n *          Andernfalls wird 'B' zurückgegeben.\n * \n * Beispiele:\n * evaluateIntegerGrade(90) // returns 'A'\n *\n */\nfunction evaluateIntegerGrade(score: number): string",
      "ha": "/**\n * Kimanta darajar don wani adadi mai shigowa.\n * @param score - Adadin da za a kimanta.\n * @returns Darajar da ta dace da adadin da aka shigar.\n *          Idan adadin yana tsakanin 90 da 100 (ciki har da), zai dawo da 'A'.\n *          In ba haka ba, zai dawo da 'B'.\n * \n * Misalai:\n * evaluateIntegerGrade(90) // returns 'A'\n *\n */\nfunction evaluateIntegerGrade(score: number): string",
      "hi": "/**\n * एक इनपुट पूर्णांक के लिए ग्रेड का मूल्यांकन करें।\n * @param score - मूल्यांकन के लिए पूर्णांक स्कोर।\n * @returns इनपुट स्कोर के अनुरूप ग्रेड।\n *          यदि स्कोर 90 और 100 (समावेशी) के बीच है, तो 'A' लौटाता है।\n *          अन्यथा, 'B' लौटाता है।\n * \n * उदाहरण:\n * evaluateIntegerGrade(90) // 'A' लौटाता है\n *\n */\nfunction evaluateIntegerGrade(score: number): string",
      "hu": "/**\n * Értékeli a bemeneti egész szám osztályzatát.\n * @param score - Az értékelendő egész szám pontszám.\n * @returns Az osztályzat, amely megfelel a bemeneti pontszámnak.\n *          Ha a pontszám 90 és 100 között van (beleértve), 'A'-t ad vissza.\n *          Egyébként 'B'-t ad vissza.\n * \n * Példák:\n * evaluateIntegerGrade(90) // returns 'A'\n *\n */\nfunction evaluateIntegerGrade(score: number): string"
    },
    "prompt_bertscore": {
      "sq": "0.9735672620437823",
      "hy": "0.9897713298982274",
      "bn": "0.9757017441183832",
      "bg": "0.9898948779952311",
      "zh": "0.9634569756491065",
      "fr": "0.9947805894775462",
      "de": "0.9745260508930377",
      "ha": "0.9539852859294577",
      "hi": "0.9533854221787325",
      "hu": "0.9820106422808133"
    },
    "canonical_solution": "{\n    return (score >= 90 && score <= 100) ? 'A' : 'B';\n}",
    "instruction": {
      "en": "Write a TypeScript function `function evaluateIntegerGrade(score: number): string` to solve the following problem:\nEvaluate the grade for an input integer.\n@param score - The integer score to be evaluated.\n@returns The grade corresponding to the input score.\n         If the score is between 90 and 100 (inclusive), returns 'A'.\n         Otherwise, returns 'B'.\n\nExamples:\n evaluateIntegerGrade(90) // returns 'A'\n\n",
      "sq": "Shkruani një funksion TypeScript `function evaluateIntegerGrade(score: number): string` për të zgjidhur problemin e mëposhtëm:\nVlerësoni notën për një numër të plotë të dhënë si hyrje.\n@param score - Nota e plotë që do të vlerësohet.\n@returns Nota që korrespondon me notën e dhënë si hyrje.\n         Nëse nota është midis 90 dhe 100 (përfshirë), kthen 'A'.\n         Përndryshe, kthen 'B'.\n\nShembuj:\n evaluateIntegerGrade(90) // kthen 'A'",
      "hy": "Գրեք TypeScript ֆունկցիա `function evaluateIntegerGrade(score: number): string` հետևյալ խնդիրը լուծելու համար:\nԳնահատել մուտքային ամբողջ թվի գնահատականը:\n@param score - Գնահատվող ամբողջ թվային միավորը:\n@returns Մուտքային միավորին համապատասխան գնահատականը:\n         Եթե միավորը 90-ից 100 (ներառյալ) միջակայքում է, վերադարձնում է 'A':\n         Հակառակ դեպքում, վերադարձնում է 'B'.\n\nՕրինակներ:\n evaluateIntegerGrade(90) // returns 'A'",
      "bn": "TypeScript ফাংশন `function evaluateIntegerGrade(score: number): string` লিখুন নিম্নলিখিত সমস্যার সমাধানের জন্য:\nইনপুট পূর্ণসংখ্যার জন্য গ্রেড মূল্যায়ন করুন।\n@param score - মূল্যায়ন করার জন্য পূর্ণসংখ্যা স্কোর।\n@returns ইনপুট স্কোরের সাথে সম্পর্কিত গ্রেড।\n         যদি স্কোর 90 এবং 100 (অন্তর্ভুক্ত) এর মধ্যে হয়, তাহলে 'A' ফেরত দেয়।\n         অন্যথায়, 'B' ফেরত দেয়।\n\nউদাহরণ:\n evaluateIntegerGrade(90) // returns 'A'",
      "bg": "Напишете функция на TypeScript `function evaluateIntegerGrade(score: number): string`, за да решите следния проблем:\nОценете оценката за входящо цяло число.\n@param score - Целочислената оценка, която трябва да бъде оценена.\n@returns Оценката, съответстваща на входящата оценка.\n         Ако оценката е между 90 и 100 (включително), връща 'A'.\n         В противен случай връща 'B'.\n\nПримери:\n evaluateIntegerGrade(90) // връща 'A'",
      "zh": "编写一个 TypeScript 函数 `function evaluateIntegerGrade(score: number): string` 来解决以下问题：\n评估输入整数的等级。\n@param score - 要评估的整数分数。\n@returns 与输入分数对应的等级。\n         如果分数在 90 到 100 之间（包括 90 和 100），返回 'A'。\n         否则，返回 'B'。\n\n例子:\n evaluateIntegerGrade(90) // returns 'A'",
      "fr": "Écrire une fonction TypeScript `function evaluateIntegerGrade(score: number): string` pour résoudre le problème suivant :\nÉvaluer la note pour un entier en entrée.\n@param score - Le score entier à évaluer.\n@returns La note correspondant au score d'entrée.\n         Si le score est entre 90 et 100 (inclus), retourne 'A'.\n         Sinon, retourne 'B'.\n\nExemples :\n evaluateIntegerGrade(90) // returns 'A'",
      "de": "Schreiben Sie eine TypeScript-Funktion `function evaluateIntegerGrade(score: number): string`, um das folgende Problem zu lösen:\nBewerten Sie die Note für eine eingegebene ganze Zahl.\n@param score - Die zu bewertende ganze Zahl.\n@returns Die Note, die der eingegebenen Punktzahl entspricht.\n         Wenn die Punktzahl zwischen 90 und 100 (einschließlich) liegt, wird 'A' zurückgegeben.\n         Andernfalls wird 'B' zurückgegeben.\n\nBeispiele:\n evaluateIntegerGrade(90) // returns 'A'",
      "ha": "Rubuta aikin TypeScript `function evaluateIntegerGrade(score: number): string` don warware matsalar mai zuwa:\nKimanta darajar don shigarwar lamba.\n@param score - Lambar da za a kimanta.\n@returns Darajar da ta dace da shigarwar lambar.\n         Idan lambar tana tsakanin 90 da 100 (ciki har da), yana dawowa 'A'.\n         In ba haka ba, yana dawowa 'B'.\n\nMisalai:\n evaluateIntegerGrade(90) // yana dawowa 'A'",
      "hi": "TypeScript फ़ंक्शन `function evaluateIntegerGrade(score: number): string` लिखें ताकि निम्नलिखित समस्या का समाधान किया जा सके:\nइनपुट पूर्णांक के लिए ग्रेड का मूल्यांकन करें।\n@param score - मूल्यांकन के लिए पूर्णांक स्कोर।\n@returns इनपुट स्कोर के अनुरूप ग्रेड।\n         यदि स्कोर 90 और 100 (समावेशी) के बीच है, तो 'A' लौटाता है।\n         अन्यथा, 'B' लौटाता है।\n\nउदाहरण:\n evaluateIntegerGrade(90) // returns 'A'",
      "hu": "Készíts egy TypeScript függvényt `function evaluateIntegerGrade(score: number): string` a következő probléma megoldására:\nÉrtékeld ki az osztályzatot egy egész számú bemenetre.\n@param score - Az értékelendő egész számú pontszám.\n@returns A bemeneti pontszámnak megfelelő osztályzat.\n         Ha a pontszám 90 és 100 között van (beleértve), 'A'-t ad vissza.\n         Egyébként 'B'-t ad vissza.\n\nPéldák:\n evaluateIntegerGrade(90) // returns 'A'"
    },
    "instruction_bertscore": {
      "sq": "0.974880804753566",
      "hy": "0.9739220159043106",
      "bn": "0.9566385905593219",
      "bg": "0.9835122879614371",
      "zh": "0.9689955851938833",
      "fr": "0.9953051723138594",
      "de": "0.9699597370634266",
      "ha": "0.9553202807203933",
      "hi": "0.9455186659378457",
      "hu": "0.9862968872731651"
    },
    "level": "easy",
    "test": "const testEvaluateIntegerGrade = (): void => {\n    console.assert(evaluateIntegerGrade(90) === 'A', \"Expected 'A' for score 90\");\n    console.assert(evaluateIntegerGrade(89) === 'B', \"Expected 'B' for score 89\");\n    console.assert(evaluateIntegerGrade(95) === 'A', \"Expected 'A' for score 95\");\n    console.assert(evaluateIntegerGrade(100) === 'A', \"Expected 'A' for score 100\");\n    console.assert(evaluateIntegerGrade(101) === 'B', \"Expected 'B' for score 101\");\n    \n    // console.log(\"All tests passed\");\n};\n\ntestEvaluateIntegerGrade();",
    "entry_point": "evaluateIntegerGrade",
    "signature": "function evaluateIntegerGrade(score: number): string",
    "docstring": {
      "en": "Evaluate the grade for an input integer.\n@param score - The integer score to be evaluated.\n@returns The grade corresponding to the input score.\n         If the score is between 90 and 100 (inclusive), returns 'A'.\n         Otherwise, returns 'B'.\n\nExamples:\n evaluateIntegerGrade(90) // returns 'A'\n\n",
      "sq": "Evaluate notën për një numër të plotë hyrës.\n@param score - Rezultati numerik që do të vlerësohet.\n@returns Nota që korrespondon me rezultatin hyrës.\n         Nëse rezultati është midis 90 dhe 100 (përfshirë), kthen 'A'.\n         Përndryshe, kthen 'B'.\n\nShembuj:\n evaluateIntegerGrade(90) // kthen 'A'",
      "hy": "Գնահատել մուտքային ամբողջ թվի գնահատականը։  \n@param score - Գնահատվող ամբողջ թվային միավորը։  \n@returns Մուտքային միավորին համապատասխան գնահատականը։  \n         Եթե միավորը 90-ից 100 (ներառյալ) միջակայքում է, վերադարձնում է 'A':  \n         Հակառակ դեպքում, վերադարձնում է 'B':  \n\nՕրինակներ:  \n evaluateIntegerGrade(90) // վերադարձնում է 'A'  ",
      "bn": "Evaluate the grade for an input integer.  \n@param score - মূল্যায়ন করার জন্য পূর্ণসংখ্যা স্কোর।  \n@returns ইনপুট স্কোরের সাথে সম্পর্কিত গ্রেড।  \n         যদি স্কোর 90 এবং 100 এর মধ্যে হয় (অন্তর্ভুক্ত), 'A' প্রদান করে।  \n         অন্যথায়, 'B' প্রদান করে।  \n\nউদাহরণ:  \n evaluateIntegerGrade(90) // 'A' প্রদান করে  ",
      "bg": "Оценете оценката за входящо цяло число.\n@param score - Цялото число, което трябва да бъде оценено.\n@returns Оценката, съответстваща на входящия резултат.\n         Ако резултатът е между 90 и 100 (включително), връща 'A'.\n         В противен случай връща 'B'.\n\nПримери:\n evaluateIntegerGrade(90) // връща 'A'",
      "zh": "评估输入整数的等级。\n@param score - 要评估的整数分数。\n@returns 与输入分数对应的等级。\n         如果分数在90到100之间（包括90和100），返回 'A'。\n         否则，返回 'B'。\n\n示例：\n evaluateIntegerGrade(90) // 返回 'A'",
      "fr": "Évaluer la note pour un entier en entrée.\n@param score - Le score entier à évaluer.\n@returns La note correspondant au score d'entrée.\n         Si le score est entre 90 et 100 (inclus), retourne 'A'.\n         Sinon, retourne 'B'.\n\nExemples:\n evaluateIntegerGrade(90) // retourne 'A'",
      "de": "Bewerten Sie die Note für eine eingegebene ganze Zahl.\n@param score - Die zu bewertende ganze Zahl.\n@returns Die Note, die der eingegebenen Punktzahl entspricht.\n         Wenn die Punktzahl zwischen 90 und 100 (einschließlich) liegt, wird 'A' zurückgegeben.\n         Andernfalls wird 'B' zurückgegeben.\n\nBeispiele:\n evaluateIntegerGrade(90) // gibt 'A' zurück",
      "ha": "Evaluate darajar don wani shigarwar cikakken lamba.\n@param score - Cikakken lambar maki da za a tantance.\n@returns Darajar da ta dace da shigarwar maki.\n         Idan maki yana tsakanin 90 da 100 (ciki har da), yana dawowa da 'A'.\n         In ba haka ba, yana dawowa da 'B'.\n\nMisalai:\n evaluateIntegerGrade(90) // yana dawowa da 'A'",
      "hi": "इनपुट पूर्णांक के लिए ग्रेड का मूल्यांकन करें।\n@param score - मूल्यांकन के लिए पूर्णांक स्कोर।\n@returns इनपुट स्कोर के अनुरूप ग्रेड।\n         यदि स्कोर 90 और 100 (समावेशी) के बीच है, तो 'A' लौटाता है।\n         अन्यथा, 'B' लौटाता है।\n\nउदाहरण:\n evaluateIntegerGrade(90) // 'A' लौटाता है",
      "hu": "Értékeli a bemeneti egész szám osztályzatát.\n@param score - Az értékelendő egész szám pontszám.\n@returns Az osztályzat, amely megfelel a bemeneti pontszámnak.\n         Ha a pontszám 90 és 100 között van (beleértve), 'A'-t ad vissza.\n         Egyébként 'B'-t ad vissza.\n\nPéldák:\n evaluateIntegerGrade(90) // 'A'-t ad vissza"
    },
    "docstring_bertscore": {
      "sq": "0.9684406119092718",
      "hy": "0.9652281627567946",
      "bn": "0.9635541059054326",
      "bg": "0.9855067356174083",
      "zh": "0.9579275031018573",
      "fr": "0.9931361285529584",
      "de": "0.9582039965922577",
      "ha": "0.9848377484940829",
      "hi": "0.9666990207283579",
      "hu": "0.9885990133893595"
    }
  },
  {
    "task_id": "TypeScript/30",
    "prompt": {
      "en": "\n/**\n * Checks if a three-character string has exactly two characters that are the same.\n *\n * @param str The three-character string to be checked.\n * @return Returns 'Yes' if the input has exactly two equal characters, otherwise 'No'.\n * \n * Examples:\n *  checkTwoEqualDigits(\"112\") // Returns 'Yes'\n */\nfunction checkTwoEqualDigits(str: string): string",
      "sq": "/**\n * Kontrollon nëse një varg me tre karaktere ka saktësisht dy karaktere që janë të njëjta.\n *\n * @param str Vargu me tre karaktere që do të kontrollohet.\n * @return Kthen 'Yes' nëse inputi ka saktësisht dy karaktere të barabartë, përndryshe 'No'.\n * \n * Shembuj:\n *  checkTwoEqualDigits(\"112\") // Kthen 'Yes'\n */\nfunction checkTwoEqualDigits(str: string): string",
      "hy": "/**\n * Ստուգում է, արդյոք երեք նիշից բաղկացած տողը ունի՞ հենց երկու նիշ, որոնք նույնն են:\n *\n * @param str Երեք նիշից բաղկացած տողը, որը պետք է ստուգել:\n * @return Վերադարձնում է 'Yes', եթե մուտքագրումը ունի հենց երկու հավասար նիշ, հակառակ դեպքում՝ 'No':\n * \n * Օրինակներ:\n *  checkTwoEqualDigits(\"112\") // Վերադարձնում է 'Yes'\n */\nfunction checkTwoEqualDigits(str: string): string",
      "bn": "/**\n * পরীক্ষা করে যে একটি তিন-অক্ষরের স্ট্রিং-এ ঠিক দুটি অক্ষর একই কিনা।\n *\n * @param str যে তিন-অক্ষরের স্ট্রিংটি পরীক্ষা করা হবে।\n * @return যদি ইনপুটে ঠিক দুটি সমান অক্ষর থাকে তবে 'Yes' ফেরত দেয়, অন্যথায় 'No'।\n * \n * উদাহরণ:\n *  checkTwoEqualDigits(\"112\") // 'Yes' ফেরত দেয়\n */\nfunction checkTwoEqualDigits(str: string): string",
      "bg": "/**\n * Проверява дали низ с три знака има точно два еднакви знака.\n *\n * @param str Три-знаковият низ, който ще бъде проверен.\n * @return Връща 'Yes', ако входът има точно два еднакви знака, в противен случай 'No'.\n * \n * Примери:\n *  checkTwoEqualDigits(\"112\") // Връща 'Yes'\n */\nfunction checkTwoEqualDigits(str: string): string",
      "zh": "/**\n * 检查一个由三个字符组成的字符串是否有恰好两个相同的字符。\n *\n * @param str 要检查的三个字符的字符串。\n * @return 如果输入有恰好两个相同的字符，则返回 'Yes'，否则返回 'No'。\n * \n * 示例:\n *  checkTwoEqualDigits(\"112\") // 返回 'Yes'\n */\nfunction checkTwoEqualDigits(str: string): string",
      "fr": "/**\n * Vérifie si une chaîne de trois caractères a exactement deux caractères identiques.\n *\n * @param str La chaîne de trois caractères à vérifier.\n * @return Renvoie 'Yes' si l'entrée a exactement deux caractères égaux, sinon 'No'.\n * \n * Exemples :\n *  checkTwoEqualDigits(\"112\") // Renvoie 'Yes'\n */\nfunction checkTwoEqualDigits(str: string): string",
      "de": "/**\n * Überprüft, ob ein dreistelliger String genau zwei gleiche Zeichen hat.\n *\n * @param str Der dreistellige String, der überprüft werden soll.\n * @return Gibt 'Yes' zurück, wenn der Eingabewert genau zwei gleiche Zeichen hat, andernfalls 'No'.\n * \n * Beispiele:\n *  checkTwoEqualDigits(\"112\") // Gibt 'Yes' zurück\n */\nfunction checkTwoEqualDigits(str: string): string",
      "ha": "/**\n * Duba idan wani igiyar haruffa guda uku yana da daidai haruffa biyu waɗanda suke iri ɗaya.\n *\n * @param str Igiyar haruffa guda uku da za a duba.\n * @return Yana dawowa 'Yes' idan shigarwar tana da daidai haruffa biyu masu daidaito, in ba haka ba 'No'.\n * \n * Misalai:\n *  checkTwoEqualDigits(\"112\") // Yana dawowa 'Yes'\n */\nfunction checkTwoEqualDigits(str: string): string",
      "hi": "/**\n * जाँचता है कि क्या तीन-अक्षरों की स्ट्रिंग में ठीक दो अक्षर समान हैं।\n *\n * @param str वह तीन-अक्षरों की स्ट्रिंग जिसे जांचा जाना है।\n * @return 'Yes' लौटाता है यदि इनपुट में ठीक दो समान अक्षर हैं, अन्यथा 'No'।\n * \n * उदाहरण:\n *  checkTwoEqualDigits(\"112\") // 'Yes' लौटाता है\n */\nfunction checkTwoEqualDigits(str: string): string",
      "hu": "/**\n * Ellenőrzi, hogy egy három karakterből álló karakterláncban pontosan két azonos karakter van-e.\n *\n * @param str Az ellenőrizendő három karakterből álló karakterlánc.\n * @return Visszaadja, hogy 'Yes', ha a bemenetben pontosan két egyenlő karakter van, különben 'No'.\n * \n * Példák:\n *  checkTwoEqualDigits(\"112\") // Visszaadja 'Yes'\n */\nfunction checkTwoEqualDigits(str: string): string"
    },
    "prompt_bertscore": {
      "sq": "0.9807785380272539",
      "hy": "1",
      "bn": "0.9831754108352019",
      "bg": "0.9738395842961811",
      "zh": "0.9542373478829911",
      "fr": "0.9601910949241308",
      "de": "0.9738395842961811",
      "ha": "0.9606584722107059",
      "hi": "0.9713592867281985",
      "hu": "0.9688712425753554"
    },
    "canonical_solution": "{\n    if ((str[0] === str[1] && str[1] !== str[2]) ||\n        (str[0] === str[2] && str[0] !== str[1]) ||\n        (str[1] === str[2] && str[0] !== str[1])) {\n        return \"Yes\";\n    } else {\n        return \"No\";\n    }\n}",
    "instruction": {
      "en": "Write a TypeScript function `function checkTwoEqualDigits(str: string): string` to solve the following problem:\nChecks if a three-character string has exactly two characters that are the same.\n\nParameters:\n- str: The three-character string to be checked.\n\nReturns:\n- Returns 'Yes' if the input has exactly two equal characters, otherwise 'No'.\n\nExamples:\n- checkTwoEqualDigits(\"112\") // Returns 'Yes'",
      "sq": "Shkruani një funksion TypeScript `function checkTwoEqualDigits(str: string): string` për të zgjidhur problemin e mëposhtëm:  \nKontrollon nëse një varg me tre karaktere ka saktësisht dy karaktere që janë të njëjta.\n\nParametrat:\n- str: Vargu me tre karaktere që do të kontrollohet.\n\nKthen:\n- Kthen 'Yes' nëse inputi ka saktësisht dy karaktere të barabartë, përndryshe 'No'.\n\nShembuj:\n- checkTwoEqualDigits(\"112\") // Kthen 'Yes'",
      "hy": "Գրեք TypeScript ֆունկցիա `function checkTwoEqualDigits(str: string): string` հետևյալ խնդիրը լուծելու համար:\nՍտուգում է, արդյոք երեք նիշից բաղկացած տողը ունի ճիշտ երկու նիշ, որոնք նույնն են:\n\nՊարամետրեր:\n- str: Երեք նիշից բաղկացած տողը, որը պետք է ստուգվի:\n\nՎերադարձնում է:\n- Վերադարձնում է 'Yes', եթե մուտքագրումը ունի ճիշտ երկու հավասար նիշ, հակառակ դեպքում 'No':\n\nՕրինակներ:\n- checkTwoEqualDigits(\"112\") // Վերադարձնում է 'Yes'",
      "bn": "TypeScript ফাংশন `function checkTwoEqualDigits(str: string): string` লিখুন নিম্নলিখিত সমস্যার সমাধানের জন্য:\nযাচাই করে যে একটি তিন-অক্ষরের স্ট্রিং-এ ঠিক দুটি অক্ষর একই কি না।\n\nপ্যারামিটার:\n- str: তিন-অক্ষরের স্ট্রিং যা পরীক্ষা করা হবে।\n\nরিটার্নস:\n- ইনপুটে যদি ঠিক দুটি সমান অক্ষর থাকে তাহলে 'Yes' রিটার্ন করে, অন্যথায় 'No'।\n\nউদাহরণ:\n- checkTwoEqualDigits(\"112\") // 'Yes' রিটার্ন করে",
      "bg": "Напишете TypeScript функция `function checkTwoEqualDigits(str: string): string`, за да решите следния проблем:  \nПроверява дали низ с три символа има точно два еднакви символа.\n\nПараметри:\n- str: Три-символният низ, който трябва да бъде проверен.\n\nВръща:\n- Връща 'Yes', ако входът има точно два еднакви символа, в противен случай 'No'.\n\nПримери:\n- checkTwoEqualDigits(\"112\") // Връща 'Yes'",
      "zh": "编写一个 TypeScript 函数 `function checkTwoEqualDigits(str: string): string` 来解决以下问题：\n检查一个三字符的字符串是否恰好有两个字符相同。\n\n参数：\n- str: 要检查的三字符字符串。\n\n返回：\n- 如果输入恰好有两个相同的字符，则返回 'Yes'，否则返回 'No'。\n\n示例：\n- checkTwoEqualDigits(\"112\") // 返回 'Yes'",
      "fr": "Écrire une fonction TypeScript `function checkTwoEqualDigits(str: string): string` pour résoudre le problème suivant :\nVérifie si une chaîne de trois caractères a exactement deux caractères identiques.\n\nParamètres :\n- str : La chaîne de trois caractères à vérifier.\n\nRenvoie :\n- Renvoie 'Yes' si l'entrée a exactement deux caractères égaux, sinon 'No'.\n\nExemples :\n- checkTwoEqualDigits(\"112\") // Renvoie 'Yes'",
      "de": "Schreiben Sie eine TypeScript-Funktion `function checkTwoEqualDigits(str: string): string`, um das folgende Problem zu lösen:\nPrüft, ob ein dreistelliger String genau zwei gleiche Zeichen hat.\n\nParameter:\n- str: Der dreistellige String, der überprüft werden soll.\n\nRückgabewerte:\n- Gibt 'Yes' zurück, wenn die Eingabe genau zwei gleiche Zeichen hat, andernfalls 'No'.\n\nBeispiele:\n- checkTwoEqualDigits(\"112\") // Gibt 'Yes' zurück",
      "ha": "Rubuta aikin TypeScript `function checkTwoEqualDigits(str: string): string` don warware matsalar mai zuwa:\nDuba idan wani kirtani mai haruffa uku yana da daidai haruffa biyu da suke daidai.\n\nSigogi:\n- str: Kirtani mai haruffa uku da za a duba.\n\nMayarwa:\n- Ya dawo 'Yes' idan shigarwar tana da daidai haruffa biyu da suke daidai, in ba haka ba 'No'.\n\nMisalai:\n- checkTwoEqualDigits(\"112\") // Ya dawo 'Yes'",
      "hi": "TypeScript फ़ंक्शन `function checkTwoEqualDigits(str: string): string` लिखें ताकि निम्नलिखित समस्या को हल किया जा सके:\nजाँच करता है कि क्या तीन-अक्षर की स्ट्रिंग में ठीक दो अक्षर समान हैं।\n\nपैरामीटर्स:\n- str: तीन-अक्षर की स्ट्रिंग जिसे जाँचना है।\n\nवापसी:\n- 'Yes' लौटाता है यदि इनपुट में ठीक दो समान अक्षर हैं, अन्यथा 'No'।\n\nउदाहरण:\n- checkTwoEqualDigits(\"112\") // 'Yes' लौटाता है",
      "hu": "Írj egy TypeScript függvényt `function checkTwoEqualDigits(str: string): string` a következő probléma megoldására:\nEllenőrzi, hogy egy három karakter hosszú string pontosan két azonos karaktert tartalmaz-e.\n\nParaméterek:\n- str: Az ellenőrizendő három karakter hosszú string.\n\nVisszatérési érték:\n- 'Yes'-t ad vissza, ha a bemenet pontosan két azonos karaktert tartalmaz, különben 'No'-t.\n\nPéldák:\n- checkTwoEqualDigits(\"112\") // Visszatér 'Yes'"
    },
    "instruction_bertscore": {
      "sq": "0.984069843441002",
      "hy": "0.9863564763874756",
      "bn": "0.9493224377346638",
      "bg": "0.9711864782966981",
      "zh": "0.9596790258018228",
      "fr": "0.964667627821514",
      "de": "0.9751302845121458",
      "ha": "0.9672448570154417",
      "hi": "0.9548163554437078",
      "hu": "0.9657549305272991"
    },
    "level": "easy",
    "test": "function testCheckTwoEqualDigits(): void {\n    // Testing the logic with various cases.\n    console.assert(checkTwoEqualDigits(\"112\") === \"Yes\");\n    console.assert(checkTwoEqualDigits(\"123\") === \"No\");\n    console.assert(checkTwoEqualDigits(\"232\") === \"Yes\");\n    console.assert(checkTwoEqualDigits(\"444\") === \"No\"); // All three characters are equal, not two.\n    console.assert(checkTwoEqualDigits(\"121\") === \"Yes\");\n\n    // Additional test cases to cover more scenarios\n    console.assert(checkTwoEqualDigits(\"787\") === \"Yes\");\n    console.assert(checkTwoEqualDigits(\"999\") === \"No\"); // All three characters are equal\n    console.assert(checkTwoEqualDigits(\"890\") === \"No\");\n    console.assert(checkTwoEqualDigits(\"556\") === \"Yes\");\n    console.assert(checkTwoEqualDigits(\"353\") === \"Yes\"); // No two characters are equal\n\n    // Uncomment the next line if you wish to print to console upon successful tests\n    //console.log(\"All tests passed successfully.\");\n}\n\n// Run the tests\ntestCheckTwoEqualDigits();",
    "entry_point": "checkTwoEqualDigits",
    "signature": "function checkTwoEqualDigits(str: string): string",
    "docstring": {
      "en": "Checks if a three-character string has exactly two characters that are the same.\n\nParameters:\n- str: The three-character string to be checked.\n\nReturns:\n- Returns 'Yes' if the input has exactly two equal characters, otherwise 'No'.\n\nExamples:\n- checkTwoEqualDigits(\"112\") // Returns 'Yes'",
      "sq": "Kontrollon nëse një varg me tre karaktere ka saktësisht dy karaktere që janë të njëjta.\n\nParametrat:\n- str: Vargu me tre karaktere që do të kontrollohet.\n\nKthen:\n- Kthen 'Po' nëse hyrja ka saktësisht dy karaktere të barabartë, përndryshe 'Jo'.\n\nShembuj:\n- checkTwoEqualDigits(\"112\") // Kthen 'Po'",
      "hy": "Ստուգում է, արդյոք երեք նիշից բաղկացած տողը ունի՞ հենց երկու նույնական նիշ:\n\nՊարամետրեր:\n- str: Երեք նիշից բաղկացած տողը, որը պետք է ստուգվի:\n\nՎերադարձնում է:\n- Վերադարձնում է 'Yes', եթե մուտքագրումը ունի հենց երկու հավասար նիշ, հակառակ դեպքում՝ 'No':\n\nՕրինակներ:\n- checkTwoEqualDigits(\"112\") // Վերադարձնում է 'Yes'",
      "bn": "Checks if a three-character string has exactly two characters that are the same.\n\nParameters:\n- str: যাচাই করার জন্য তিন-অক্ষরের স্ট্রিং।\n\nReturns:\n- যদি ইনপুটে ঠিক দুটি সমান অক্ষর থাকে তবে 'Yes' রিটার্ন করে, অন্যথায় 'No'।\n\nExamples:\n- checkTwoEqualDigits(\"112\") // Returns 'Yes'",
      "bg": "Проверява дали низ от три знака има точно два еднакви знака.\n\nПараметри:\n- str: Тристойностният низ, който ще бъде проверен.\n\nВръща:\n- Връща 'Yes', ако входът има точно два еднакви знака, в противен случай 'No'.\n\nПримери:\n- checkTwoEqualDigits(\"112\") // Връща 'Yes'",
      "zh": "检查一个三字符字符串是否恰好有两个字符相同。\n\n参数:\n- str: 要检查的三字符字符串。\n\n返回:\n- 如果输入恰好有两个相同的字符，则返回 'Yes'，否则返回 'No'。\n\n示例:\n- checkTwoEqualDigits(\"112\") // 返回 'Yes'",
      "fr": "Vérifie si une chaîne de trois caractères a exactement deux caractères identiques.\n\nParamètres:\n- str: La chaîne de trois caractères à vérifier.\n\nRenvoie:\n- Renvoie 'Yes' si l'entrée a exactement deux caractères égaux, sinon 'No'.\n\nExemples:\n- checkTwoEqualDigits(\"112\") // Renvoie 'Yes'",
      "de": "Prüft, ob ein dreistelliger String genau zwei gleiche Zeichen hat.\n\nParameter:\n- str: Der zu überprüfende dreistellige String.\n\nRückgabewerte:\n- Gibt 'Yes' zurück, wenn der Eingabewert genau zwei gleiche Zeichen hat, andernfalls 'No'.\n\nBeispiele:\n- checkTwoEqualDigits(\"112\") // Gibt 'Yes' zurück",
      "ha": "Checks if a three-character string has exactly two characters that are the same.\n\nParameters:\n- str: The three-character string to be checked.\n\nReturns:\n- Returns 'Yes' if the input has exactly two equal characters, otherwise 'No'.\n\nExamples:\n- checkTwoEqualDigits(\"112\") // Returns 'Yes'\n\nDuba idan kirtani mai haruffa uku yana da daidai haruffa biyu waɗanda suke daidai.\n\nSigogi:\n- str: Kirtani mai haruffa uku da za a duba.\n\nDawowa:\n- Ya dawo da 'Yes' idan shigarwar tana da daidai haruffa biyu masu daidaituwa, in ba haka ba 'No'.\n\nMisalai:\n- checkTwoEqualDigits(\"112\") // Ya dawo da 'Yes'",
      "hi": "जाँचता है कि क्या तीन-अक्षरों की स्ट्रिंग में ठीक दो अक्षर समान हैं।\n\nपैरामीटर्स:\n- str: तीन-अक्षरों की स्ट्रिंग जिसे जांचा जाना है।\n\nवापसी:\n- यदि इनपुट में ठीक दो समान अक्षर हैं, तो 'Yes' लौटाता है, अन्यथा 'No'।\n\nउदाहरण:\n- checkTwoEqualDigits(\"112\") // 'Yes' लौटाता है",
      "hu": "Ellenőrzi, hogy egy három karakterből álló karakterláncban pontosan két azonos karakter van-e.\n\nParaméterek:\n- str: A három karakterből álló karakterlánc, amelyet ellenőrizni kell.\n\nVisszatérési érték:\n- 'Yes'-t ad vissza, ha a bemenetben pontosan két egyenlő karakter van, különben 'No'-t.\n\nPéldák:\n- checkTwoEqualDigits(\"112\") // 'Yes'-t ad vissza"
    },
    "docstring_bertscore": {
      "sq": "0.989518274792789",
      "hy": "0.975393469767017",
      "bn": "0.9772091500800569",
      "bg": "0.9595066146310846",
      "zh": "0.9460682762021693",
      "fr": "0.9485360600561467",
      "de": "0.9414677979470202",
      "ha": "1",
      "hi": "0.9631939890246163",
      "hu": "0.9564910081862129"
    }
  },
  {
    "task_id": "TypeScript/31",
    "prompt": {
      "en": "\n/**\n * Given a string consisting of lowercase English letters, you can change one character to another\n * in each round. This function calculates the minimum number of rounds needed to make the string\n * composed of the same character.\n * \n * @param s The input string.\n * @returns The minimum number of rounds to make all characters in the string the same.\n * \n * Examples:\n * minRoundsToSameChar(\"aab\") // returns 1\n */\nfunction minRoundsToSameChar(s: string): number",
      "sq": "/**\n * Duke pasur një varg që përbëhet nga shkronja të vogla të anglishtes, ju mund të ndryshoni një karakter në një tjetër\n * në çdo raund. Kjo funksion llogarit numrin minimal të raundeve të nevojshme për ta bërë vargun\n * të përbërë nga i njëjti karakter.\n * \n * @param s Vargu hyrës.\n * @returns Numri minimal i raundeve për të bërë të gjithë karakteret në varg të njëjtë.\n * \n * Shembuj:\n * minRoundsToSameChar(\"aab\") // kthen 1\n */\nfunction minRoundsToSameChar(s: string): number",
      "hy": "/**\n * Տրված է փոքրատառ անգլերեն տառերից բաղկացած տող, դուք կարող եք յուրաքանչյուր փուլում փոխել մեկ նիշը մեկ այլով:\n * Այս ֆունկցիան հաշվարկում է նվազագույն փուլերի քանակը, որը անհրաժեշտ է տողը նույն նիշից կազմված դարձնելու համար:\n * \n * @param s Մուտքային տողը:\n * @returns Նվազագույն փուլերի քանակը, որպեսզի տողի բոլոր նիշերը դառնան նույնը:\n * \n * Օրինակներ:\n * minRoundsToSameChar(\"aab\") // վերադարձնում է 1\n */\nfunction minRoundsToSameChar(s: string): number",
      "bn": "/**\n * একটি স্ট্রিং দেওয়া হয়েছে যা ছোট হাতের ইংরেজি অক্ষর নিয়ে গঠিত, আপনি প্রতিটি রাউন্ডে একটি অক্ষরকে অন্য অক্ষরে পরিবর্তন করতে পারেন।\n * এই ফাংশনটি স্ট্রিংটিকে একই অক্ষর দিয়ে গঠিত করতে প্রয়োজনীয় ন্যূনতম রাউন্ডের সংখ্যা গণনা করে।\n * \n * @param s ইনপুট স্ট্রিং।\n * @returns স্ট্রিংয়ের সমস্ত অক্ষরকে একই করতে ন্যূনতম রাউন্ডের সংখ্যা।\n * \n * উদাহরণ:\n * minRoundsToSameChar(\"aab\") // 1 ফেরত দেয়\n */\nfunction minRoundsToSameChar(s: string): number",
      "bg": "/**\n * Даден е низ, състоящ се от малки английски букви, можете да промените един символ на друг\n * във всеки рунд. Тази функция изчислява минималния брой рундове, необходими, за да се направи низът\n * съставен от един и същ символ.\n * \n * @param s Входният низ.\n * @returns Минималният брой рундове, за да се направят всички символи в низа еднакви.\n * \n * Примери:\n * minRoundsToSameChar(\"aab\") // връща 1\n */\nfunction minRoundsToSameChar(s: string): number",
      "zh": "/**\n * 给定一个由小写英文字母组成的字符串，你可以在每一轮中将一个字符更改为另一个字符。\n * 此函数计算使字符串由相同字符组成所需的最小轮数。\n * \n * @param s 输入字符串。\n * @returns 使字符串中的所有字符相同所需的最小轮数。\n * \n * 示例:\n * minRoundsToSameChar(\"aab\") // 返回 1\n */\nfunction minRoundsToSameChar(s: string): number",
      "fr": "/**\n * Étant donné une chaîne composée de lettres minuscules anglaises, vous pouvez changer un caractère en un autre\n * à chaque tour. Cette fonction calcule le nombre minimum de tours nécessaires pour rendre la chaîne\n * composée du même caractère.\n * \n * @param s La chaîne d'entrée.\n * @returns Le nombre minimum de tours pour que tous les caractères de la chaîne soient identiques.\n * \n * Exemples :\n * minRoundsToSameChar(\"aab\") // returns 1\n */\nfunction minRoundsToSameChar(s: string): number",
      "de": "/**\n * Gegeben ist ein String, der aus Kleinbuchstaben des englischen Alphabets besteht. Sie können in jeder Runde ein Zeichen in ein anderes ändern. Diese Funktion berechnet die minimale Anzahl von Runden, die benötigt werden, um den String aus demselben Zeichen bestehen zu lassen.\n * \n * @param s Der Eingabestring.\n * @returns Die minimale Anzahl von Runden, um alle Zeichen im String gleich zu machen.\n * \n * Beispiele:\n * minRoundsToSameChar(\"aab\") // gibt 1 zurück\n */\nfunction minRoundsToSameChar(s: string): number",
      "ha": "/**\n * An ba da wata kirtani da ke kunshe da ƙananan haruffan Turanci, za ka iya canza harafi ɗaya zuwa wani\n * a kowace zagaye. Wannan aikin yana ƙididdige adadin mafi ƙarancin zagaye da ake buƙata don sanya kirtani\n * ya ƙunshi harafi iri ɗaya.\n * \n * @param s Kirtanin shigarwa.\n * @returns Adadin mafi ƙarancin zagaye don sanya duk haruffa a cikin kirtani su zama iri ɗaya.\n * \n * Misalai:\n * minRoundsToSameChar(\"aab\") // returns 1\n */\nfunction minRoundsToSameChar(s: string): number",
      "hi": "/**\n * दिए गए स्ट्रिंग में छोटे अंग्रेजी अक्षरों से मिलकर बना होता है, आप प्रत्येक राउंड में एक अक्षर को दूसरे में बदल सकते हैं।\n * यह फ़ंक्शन न्यूनतम राउंड की संख्या की गणना करता है जो स्ट्रिंग को एक ही अक्षर से मिलकर बनाने के लिए आवश्यक है।\n * \n * @param s इनपुट स्ट्रिंग।\n * @returns न्यूनतम राउंड की संख्या जिससे स्ट्रिंग के सभी अक्षर समान हो जाएं।\n * \n * उदाहरण:\n * minRoundsToSameChar(\"aab\") // 1 लौटाता है\n */\nfunction minRoundsToSameChar(s: string): number",
      "hu": "/**\n * Adott egy kisbetűs angol betűkből álló karakterlánc, minden körben megváltoztathatsz egy karaktert egy másikra.\n * Ez a függvény kiszámítja a minimális körök számát, amely szükséges ahhoz, hogy a karakterlánc\n * ugyanabból a karakterből álljon.\n * \n * @param s A bemeneti karakterlánc.\n * @returns A minimális körök száma, hogy a karakterlánc összes karaktere ugyanaz legyen.\n * \n * Példák:\n * minRoundsToSameChar(\"aab\") // visszaadja: 1\n */\nfunction minRoundsToSameChar(s: string): number"
    },
    "prompt_bertscore": {
      "sq": "0.9811150178927269",
      "hy": "0.9556859592518785",
      "bn": "0.9648108403262402",
      "bg": "1",
      "zh": "0.9721065342216517",
      "fr": "0.9685204613224478",
      "de": "0.9694101267991031",
      "ha": "0.9769445744125185",
      "hi": "0.9489565605727975",
      "hu": "0.962242152238697"
    },
    "canonical_solution": "{\n    const charCount = new Array(26).fill(0); // Assuming only lowercase letters\n    for (const char of s) {\n        charCount[char.charCodeAt(0) - 'a'.charCodeAt(0)]++;\n    }\n    let maxCount = 0;\n    for (const count of charCount) {\n        if (count !== 0) {\n            maxCount++;\n        }\n    }\n\n    return maxCount - 1;\n}",
    "instruction": {
      "en": "Write a TypeScript function `function minRoundsToSameChar(s: string): number` to solve the following problem:\nGiven a string consisting of lowercase English letters, you can change one character to another\nin each round. This function calculates the minimum number of rounds needed to make the string\ncomposed of the same character.\n\n@param s The input string.\n@returns The minimum number of rounds to make all characters in the string the same.\n\nExamples:\nminRoundsToSameChar(\"aab\") // returns 1",
      "sq": "Shkruani një funksion TypeScript `function minRoundsToSameChar(s: string): number` për të zgjidhur problemin e mëposhtëm:  \nDuke pasur një varg që përbëhet nga shkronja të vogla të anglishtes, ju mund të ndryshoni një karakter në një tjetër në çdo raund. Ky funksion llogarit numrin minimal të raundeve të nevojshëm për ta bërë vargun të përbërë nga i njëjti karakter.\n\n@param s Vargu hyrës.\n@returns Numri minimal i raundeve për t'i bërë të gjithë karakteret në varg të njëjta.\n\nShembuj:\nminRoundsToSameChar(\"aab\") // kthen 1",
      "hy": "TypeScript ֆունկցիա գրեք `function minRoundsToSameChar(s: string): number`՝ լուծելու համար հետևյալ խնդիրը:\nՏրված է փոքրատառ անգլերեն տառերից կազմված տող, դուք կարող եք յուրաքանչյուր փուլում փոխել մեկ նիշը մեկ այլով: Այս ֆունկցիան հաշվում է նվազագույն փուլերի քանակը, որը անհրաժեշտ է տողը նույն նիշից կազմված դարձնելու համար:\n\n@param s Մուտքային տողը:\n@returns Նվազագույն փուլերի քանակը, որպեսզի տողի բոլոր նիշերը նույնը դառնան:\n\nՕրինակներ:\nminRoundsToSameChar(\"aab\") // վերադարձնում է 1",
      "bn": "TypeScript ফাংশন `function minRoundsToSameChar(s: string): number` লিখুন নিম্নলিখিত সমস্যার সমাধানের জন্য:\nনিম্নবর্ণিত ইংরেজি অক্ষর নিয়ে গঠিত একটি স্ট্রিং দেওয়া আছে, আপনি প্রতিটি রাউন্ডে একটি অক্ষরকে অন্য অক্ষরে পরিবর্তন করতে পারেন। এই ফাংশনটি স্ট্রিংটিকে একই অক্ষর দিয়ে গঠিত করতে ন্যূনতম কতগুলি রাউন্ড প্রয়োজন তা গণনা করে।\n\n@param s ইনপুট স্ট্রিং।\n@returns স্ট্রিংয়ের সমস্ত অক্ষরকে একই করতে ন্যূনতম রাউন্ড সংখ্যা।\n\nউদাহরণ:\nminRoundsToSameChar(\"aab\") // returns 1",
      "bg": "Напишете TypeScript функция `function minRoundsToSameChar(s: string): number`, за да решите следния проблем:  \nДаден е низ, състоящ се от малки английски букви, можете да промените един символ на друг във всеки рунд. Тази функция изчислява минималния брой рундове, необходими, за да се направи низът съставен от един и същ символ.\n\n@param s Входният низ.\n@returns Минималният брой рундове, за да се направят всички символи в низа еднакви.\n\nПримери:\nminRoundsToSameChar(\"aab\") // връща 1",
      "zh": "编写一个 TypeScript 函数 `function minRoundsToSameChar(s: string): number` 来解决以下问题：\n给定一个由小写英文字母组成的字符串，你可以在每一轮中将一个字符更改为另一个字符。此函数计算将字符串变为由相同字符组成所需的最小轮数。\n\n@param s 输入字符串。\n@returns 将字符串中的所有字符变为相同所需的最小轮数。\n\n示例：\nminRoundsToSameChar(\"aab\") // 返回 1",
      "fr": "Écrire une fonction TypeScript `function minRoundsToSameChar(s: string): number` pour résoudre le problème suivant :\nÉtant donné une chaîne composée de lettres minuscules anglaises, vous pouvez changer un caractère en un autre à chaque tour. Cette fonction calcule le nombre minimum de tours nécessaires pour que la chaîne soit composée du même caractère.\n\n@param s La chaîne d'entrée.\n@returns Le nombre minimum de tours pour que tous les caractères de la chaîne soient identiques.\n\nExemples :\nminRoundsToSameChar(\"aab\") // retourne 1",
      "de": "Schreiben Sie eine TypeScript-Funktion `function minRoundsToSameChar(s: string): number`, um das folgende Problem zu lösen:\nGegeben ist ein String, der aus kleinen englischen Buchstaben besteht. Sie können in jeder Runde ein Zeichen in ein anderes ändern. Diese Funktion berechnet die minimale Anzahl von Runden, die benötigt werden, um den String aus demselben Zeichen zu machen.\n\n@param s Der Eingabestring.\n@returns Die minimale Anzahl von Runden, um alle Zeichen im String gleich zu machen.\n\nBeispiele:\nminRoundsToSameChar(\"aab\") // gibt 1 zurück",
      "ha": "Rubuta aikin TypeScript `function minRoundsToSameChar(s: string): number` don warware matsalar mai zuwa:\nAn ba da wani igiyar rubutu da ke dauke da ƙananan haruffan Ingilishi, za ka iya canza harafi ɗaya zuwa wani a kowace zagaye. Wannan aikin yana ƙididdige mafi ƙarancin adadin zagaye da ake buƙata don sanya igiyar rubutu ta ƙunshi harafi ɗaya.\n\n@param s Igiyar rubutu da aka shigar.\n@returns Mafi ƙarancin adadin zagaye don sanya duk haruffa a cikin igiyar rubutu su zama iri ɗaya.\n\nMisalai:\nminRoundsToSameChar(\"aab\") // returns 1",
      "hi": "TypeScript फ़ंक्शन `function minRoundsToSameChar(s: string): number` लिखें ताकि निम्नलिखित समस्या का समाधान किया जा सके:\nदिए गए स्ट्रिंग में छोटे अंग्रेजी अक्षर होते हैं, आप प्रत्येक राउंड में एक अक्षर को दूसरे में बदल सकते हैं। यह फ़ंक्शन न्यूनतम राउंड की गणना करता है जो स्ट्रिंग को एक ही अक्षर से युक्त बनाने के लिए आवश्यक हैं।\n\n@param s इनपुट स्ट्रिंग।\n@returns न्यूनतम राउंड की संख्या जिससे स्ट्रिंग के सभी अक्षर समान हो जाएं।\n\nउदाहरण:\nminRoundsToSameChar(\"aab\") // returns 1",
      "hu": "Írj egy TypeScript függvényt `function minRoundsToSameChar(s: string): number` a következő probléma megoldására:\nAdott egy kisbetűs angol betűkből álló karakterlánc, minden körben megváltoztathatsz egy karaktert egy másikra. Ez a függvény kiszámítja a minimális körök számát, amelyek szükségesek ahhoz, hogy a karakterlánc ugyanabból a karakterből álljon.\n\n@param s A bemeneti karakterlánc.\n@returns A minimális körök száma, hogy az összes karakter a karakterláncban ugyanaz legyen.\n\nPéldák:\nminRoundsToSameChar(\"aab\") // visszaadja 1"
    },
    "instruction_bertscore": {
      "sq": "0.9960695020200816",
      "hy": "0.980557661043543",
      "bn": "0.9398598850125428",
      "bg": "0.9960695020200816",
      "zh": "0.9833289521197418",
      "fr": "0.9811799700273254",
      "de": "0.9960695020200816",
      "ha": "0.987542895653397",
      "hi": "0.9446389319802422",
      "hu": "0.9846554058042928"
    },
    "level": "middle",
    "test": "const testMinRoundsToSameChar = (): void => {\n    console.assert(minRoundsToSameChar(\"aab\") === 1, \"Expected 1 round for 'aab'\");\n    console.assert(minRoundsToSameChar(\"abc\") === 2, \"Expected 2 rounds for 'abc'\");\n    console.assert(minRoundsToSameChar(\"aaa\") === 0, \"Expected 0 rounds for 'aaa'\");\n    console.assert(minRoundsToSameChar(\"abab\") === 1, \"Expected 1 round for 'abab'\");\n    console.assert(minRoundsToSameChar(\"zzzzz\") === 0, \"Expected 0 rounds for 'zzzzz'\");\n};\n\ntestMinRoundsToSameChar();",
    "entry_point": "minRoundsToSameChar",
    "signature": "function minRoundsToSameChar(s: string): number",
    "docstring": {
      "en": "Given a string consisting of lowercase English letters, you can change one character to another\nin each round. This function calculates the minimum number of rounds needed to make the string\ncomposed of the same character.\n\n@param s The input string.\n@returns The minimum number of rounds to make all characters in the string the same.\n\nExamples:\nminRoundsToSameChar(\"aab\") // returns 1",
      "sq": "Duke pasur një varg që përbëhet nga shkronja të vogla të anglishtes, ju mund të ndryshoni një karakter në një tjetër\nnë secilën raund. Kjo funksion llogarit numrin minimal të raundeve të nevojshme për ta bërë vargun\ntë përbërë nga i njëjti karakter.\n\n@param s Vargu hyrës.\n@returns Numri minimal i raundeve për të bërë të gjitha karakteret në varg të njëjta.\n\nShembuj:\nminRoundsToSameChar(\"aab\") // kthen 1",
      "hy": "Given a string consisting of lowercase English letters, you can change one character to another in each round. This function calculates the minimum number of rounds needed to make the string composed of the same character.\n\n@param s Մուտքային տողը:\n@returns Նվազագույն ռաունդների քանակը, որպեսզի տողի բոլոր սիմվոլները լինեն նույնը:\n\nՕրինակներ:\nminRoundsToSameChar(\"aab\") // վերադարձնում է 1",
      "bn": "Given a string consisting of lowercase English letters, you can change one character to another in each round. This function calculates the minimum number of rounds needed to make the string composed of the same character.\n\n@param s ইনপুট স্ট্রিং।\n@returns স্ট্রিংয়ের সব অক্ষর একই করতে প্রয়োজনীয় সর্বনিম্ন রাউন্ডের সংখ্যা।\n\nExamples:\nminRoundsToSameChar(\"aab\") // returns 1",
      "bg": "Даден е низ, състоящ се от малки английски букви, можете да промените един символ на друг\nвъв всеки кръг. Тази функция изчислява минималния брой кръгове, необходими, за да се направи низът\nсъставен от един и същ символ.\n\n@param s Входният низ.\n@returns Минималният брой кръгове, за да се направят всички символи в низа еднакви.\n\nПримери:\nminRoundsToSameChar(\"aab\") // връща 1",
      "zh": "给定一个由小写英文字母组成的字符串，你可以在每一轮中将一个字符更改为另一个字符。此函数计算将字符串变为由相同字符组成所需的最小轮数。\n\n@param s 输入字符串。\n@returns 使字符串中的所有字符相同所需的最小轮数。\n\n示例：\nminRoundsToSameChar(\"aab\") // 返回 1",
      "fr": "Given a string consisting of lowercase English letters, you can change one character to another in each round. Cette fonction calcule le nombre minimum de tours nécessaires pour que la chaîne soit composée du même caractère.\n\n@param s La chaîne d'entrée.\n@returns Le nombre minimum de tours pour que tous les caractères de la chaîne soient identiques.\n\nExemples :\nminRoundsToSameChar(\"aab\") // retourne 1",
      "de": "Given a string consisting of lowercase English letters, you can change one character to another in each round. This function calculates the minimum number of rounds needed to make the string composed of the same character.\n\n@param s Der Eingabestring.\n@returns Die minimale Anzahl von Runden, um alle Zeichen im String gleich zu machen.\n\nBeispiele:\nminRoundsToSameChar(\"aab\") // gibt 1 zurück",
      "ha": "An bayar da wani kirtani da ya ƙunshi ƙananan haruffan Ingilishi, za ka iya canza harafi ɗaya zuwa wani a kowace zagaye. Wannan aikin yana ƙididdige mafi ƙarancin adadin zagaye da ake buƙata don sanya kirtani ya ƙunshi harafi ɗaya.\n\n@param s Kirtanin shigarwa.\n@returns Mafi ƙarancin adadin zagaye don sanya duk haruffa a cikin kirtani su zama iri ɗaya.\n\nMisalai:\nminRoundsToSameChar(\"aab\") // yana mayar da 1",
      "hi": "Given a string consisting of lowercase English letters, you can change one character to another in each round. This function calculates the minimum number of rounds needed to make the string composed of the same character.\n\n@param s इनपुट स्ट्रिंग।\n@returns स्ट्रिंग में सभी अक्षरों को समान बनाने के लिए न्यूनतम राउंड्स की संख्या।\n\nउदाहरण:\nminRoundsToSameChar(\"aab\") // 1 लौटाता है",
      "hu": "Adott egy kisbetűs angol betűkből álló karakterlánc, amelyben minden körben megváltoztathat egy karaktert egy másikra. Ez a függvény kiszámítja a minimális körök számát, amely szükséges ahhoz, hogy a karakterlánc azonos karakterekből álljon.\n\n@param s A bemeneti karakterlánc.\n@returns A minimális körök száma, hogy a karakterlánc összes karaktere azonos legyen.\n\nPéldák:\nminRoundsToSameChar(\"aab\") // visszaadja 1"
    },
    "docstring_bertscore": {
      "sq": "0.9799685233333936",
      "hy": "0.9668106510024995",
      "bn": "0.9787101998695376",
      "bg": "1",
      "zh": "0.9748156539885865",
      "fr": "0.9783741172648266",
      "de": "1",
      "ha": "0.9707351900709869",
      "hi": "0.9843864602683716",
      "hu": "0.9632799959796043"
    }
  },
  {
    "task_id": "TypeScript/32",
    "prompt": {
      "en": "\n/**\n * Calculates the year Y_n when the n-th event occurs, considering that each\n * event has a periodicity of a_i years. The countdown for event i+1 starts\n * the year after event i occurs.\n *\n * @param n - the total number of events\n * @param signs - an array representing the periodicities of the events\n * @returns The year when the n-th event occurs\n * \n * Example:\n * apocalypseYear(6, [3,2,4,5,9,18]) // returns 36\n */\nfunction apocalypseYear(n: number, signs: number[]): number",
      "sq": "/**\n * Llogarit vitin Y_n kur ndodh ngjarja e n-të, duke marrë parasysh që çdo\n * ngjarje ka një periodicitet prej a_i vitesh. Numërimi mbrapsht për ngjarjen i+1 fillon\n * vitin pas ngjarjes i që ndodh.\n *\n * @param n - numri total i ngjarjeve\n * @param signs - një varg që përfaqëson periodicitetet e ngjarjeve\n * @returns Viti kur ndodh ngjarja e n-të\n * \n * Shembull:\n * apocalypseYear(6, [3,2,4,5,9,18]) // kthen 36\n */\nfunction apocalypseYear(n: number, signs: number[]): number",
      "hy": "/**\n * Հաշվում է Y_n տարին, երբ տեղի է ունենում n-րդ իրադարձությունը, հաշվի առնելով, որ\n * յուրաքանչյուր իրադարձություն ունի a_i տարիների պարբերականություն։ i+1 իրադարձության\n * համար հաշվողությունը սկսվում է այն տարվա հաջորդ տարում, երբ տեղի է ունենում i իրադարձությունը։\n *\n * @param n - իրադարձությունների ընդհանուր քանակը\n * @param signs - զանգված, որը ներկայացնում է իրադարձությունների պարբերականությունները\n * @returns Տարին, երբ տեղի է ունենում n-րդ իրադարձությունը\n * \n * Օրինակ:\n * apocalypseYear(6, [3,2,4,5,9,18]) // վերադարձնում է 36\n */\nfunction apocalypseYear(n: number, signs: number[]): number",
      "bn": "/**\n * n-তম ঘটনা কখন ঘটে তার বছর Y_n গণনা করে, বিবেচনা করে যে প্রতিটি\n * ঘটনার একটি a_i বছর পরপর ঘটে। ঘটনা i+1 এর জন্য কাউন্টডাউন শুরু হয়\n * ঘটনা i ঘটার পরের বছর থেকে।\n *\n * @param n - মোট ঘটনার সংখ্যা\n * @param signs - ঘটনাগুলির পর্যাবৃত্তিকতা উপস্থাপনকারী একটি অ্যারে\n * @returns n-তম ঘটনা কখন ঘটে তার বছর\n * \n * উদাহরণ:\n * apocalypseYear(6, [3,2,4,5,9,18]) // 36 প্রদান করে\n */\nfunction apocalypseYear(n: number, signs: number[]): number",
      "bg": "/**\n * Изчислява годината Y_n, когато се случва n-тото събитие, като се има предвид, че всяко\n * събитие има периодичност от a_i години. Обратното броене за събитие i+1 започва\n * годината след като се случи събитие i.\n *\n * @param n - общият брой на събитията\n * @param signs - масив, представляващ периодичностите на събитията\n * @returns Годината, когато се случва n-тото събитие\n * \n * Пример:\n * apocalypseYear(6, [3,2,4,5,9,18]) // връща 36\n */\nfunction apocalypseYear(n: number, signs: number[]): number",
      "zh": "/**\n * 计算第 n 个事件发生的年份 Y_n，考虑到每个事件的周期性为 a_i 年。事件 i+1 的倒计时从事件 i 发生后的下一年开始。\n *\n * @param n - 事件的总数\n * @param signs - 一个数组，表示事件的周期性\n * @returns 第 n 个事件发生的年份\n * \n * 示例:\n * apocalypseYear(6, [3,2,4,5,9,18]) // returns 36\n */\nfunction apocalypseYear(n: number, signs: number[]): number",
      "fr": "/**\n * Calcule l'année Y_n lorsque le n-ième événement se produit, en considérant que chaque\n * événement a une périodicité de a_i années. Le compte à rebours pour l'événement i+1 commence\n * l'année après que l'événement i se produit.\n *\n * @param n - le nombre total d'événements\n * @param signs - un tableau représentant les périodicités des événements\n * @returns L'année où le n-ième événement se produit\n * \n * Exemple:\n * apocalypseYear(6, [3,2,4,5,9,18]) // returns 36\n */\nfunction apocalypseYear(n: number, signs: number[]): number",
      "de": "/**\n * Berechnet das Jahr Y_n, in dem das n-te Ereignis eintritt, wobei jedes\n * Ereignis eine Periodizität von a_i Jahren hat. Der Countdown für Ereignis i+1 beginnt\n * im Jahr nach dem Eintreten von Ereignis i.\n *\n * @param n - die Gesamtzahl der Ereignisse\n * @param signs - ein Array, das die Periodizitäten der Ereignisse darstellt\n * @returns Das Jahr, in dem das n-te Ereignis eintritt\n * \n * Beispiel:\n * apocalypseYear(6, [3,2,4,5,9,18]) // gibt 36 zurück\n */\nfunction apocalypseYear(n: number, signs: number[]): number",
      "ha": "/**\n * Lissafa shekarar Y_n lokacin da taron na n-th ya faru, la'akari da cewa kowanne\n * taro yana da lokaci na a_i shekaru. Kirga don taro i+1 yana farawa\n * shekarar bayan taro i ya faru.\n *\n * @param n - jimillar adadin taruka\n * @param signs - wani tsari da ke wakiltar lokutan tarukan\n * @returns Shekarar da taron na n-th ya faru\n * \n * Misali:\n * apocalypseYear(6, [3,2,4,5,9,18]) // returns 36\n */\nfunction apocalypseYear(n: number, signs: number[]): number",
      "hi": "/**\n * गणना करता है वर्ष Y_n जब n-वां घटना होती है, यह मानते हुए कि प्रत्येक\n * घटना की आवृत्ति a_i वर्षों की होती है। घटना i+1 की उलटी गिनती\n * घटना i के होने के अगले वर्ष से शुरू होती है।\n *\n * @param n - घटनाओं की कुल संख्या\n * @param signs - घटनाओं की आवृत्तियों का प्रतिनिधित्व करने वाला एक array\n * @returns वह वर्ष जब n-वां घटना होती है\n * \n * उदाहरण:\n * apocalypseYear(6, [3,2,4,5,9,18]) // returns 36\n */\nfunction apocalypseYear(n: number, signs: number[]): number",
      "hu": "/**\n * Kiszámítja az Y_n évet, amikor az n-edik esemény bekövetkezik, figyelembe véve, hogy minden\n * eseménynek a_i éves periódusa van. Az i+1 esemény visszaszámlálása az i esemény bekövetkezése\n * utáni évben kezdődik.\n *\n * @param n - az események összes száma\n * @param signs - egy tömb, amely az események periódusait jelöli\n * @returns Az év, amikor az n-edik esemény bekövetkezik\n * \n * Példa:\n * apocalypseYear(6, [3,2,4,5,9,18]) // returns 36\n */\nfunction apocalypseYear(n: number, signs: number[]): number"
    },
    "prompt_bertscore": {
      "sq": "0.9986608339710628",
      "hy": "0.9592249567507771",
      "bn": "0.9689264618212832",
      "bg": "0.9951152816695901",
      "zh": "0.9612899181920158",
      "fr": "1",
      "de": "0.9709896355890925",
      "ha": "0.9672144665671434",
      "hi": "0.9662427667431207",
      "hu": "0.9729570695132431"
    },
    "canonical_solution": "{\n    let year = 0;\n    for (let i = 0; i < n; ++i) {\n        let period = signs[i];\n        let nextOccurrence = Math.floor(year / period + 1) * period;\n        year = nextOccurrence;\n    }\n    return year;\n}",
    "instruction": {
      "en": "Write a TypeScript function `function apocalypseYear(n: number, signs: number[]): number` to solve the following problem:\nCalculates the year Y_n when the n-th event occurs, considering that each event has a periodicity of a_i years. The countdown for event i+1 starts the year after event i occurs.\n\nParameters:\n- n - the total number of events\n- signs - an array representing the periodicities of the events\n\nReturns The year when the n-th event occurs\n\nExample:\napocalypseYear(6, [3,2,4,5,9,18]) // returns 36\n",
      "sq": "Shkruani një funksion TypeScript `function apocalypseYear(n: number, signs: number[]): number` për të zgjidhur problemin e mëposhtëm:\nLlogarit vitin Y_n kur ndodh ngjarja e n-të, duke marrë parasysh që çdo ngjarje ka një periodikë prej a_i vitesh. Numërimi mbrapsht për ngjarjen i+1 fillon vitin pas ngjarjes i.\n\nParametrat:\n- n - numri total i ngjarjeve\n- signs - një varg që përfaqëson periodikët e ngjarjeve\n\nKthen Vitin kur ndodh ngjarja e n-të\n\nShembull:\napocalypseYear(6, [3,2,4,5,9,18]) // kthen 36",
      "hy": "Գրեք TypeScript ֆունկցիա `function apocalypseYear(n: number, signs: number[]): number` հետևյալ խնդիրը լուծելու համար:\nՀաշվում է Y_n տարին, երբ տեղի է ունենում n-րդ իրադարձությունը, հաշվի առնելով, որ յուրաքանչյուր իրադարձություն ունի a_i տարիների պարբերականություն։ i+1 իրադարձության համար հետհաշվարկը սկսվում է i իրադարձության տեղի ունենալուց հետո։\n\nՊարամետրեր:\n- n - իրադարձությունների ընդհանուր քանակը\n- signs - զանգված, որը ներկայացնում է իրադարձությունների պարբերականությունները\n\nՎերադարձնում է Տարին, երբ տեղի է ունենում n-րդ իրադարձությունը\n\nՕրինակ:\napocalypseYear(6, [3,2,4,5,9,18]) // վերադարձնում է 36",
      "bn": "TypeScript ফাংশন `function apocalypseYear(n: number, signs: number[]): number` লিখুন নিম্নলিখিত সমস্যার সমাধানের জন্য:\nপ্রতিটি ঘটনার একটি a_i বছরের পর্যায়ক্রমিকতা বিবেচনা করে n-তম ঘটনা যখন ঘটে তখন Y_n বছর গণনা করে। ঘটনা i ঘটার পরের বছর থেকে ঘটনা i+1 এর কাউন্টডাউন শুরু হয়।\n\nপ্যারামিটারসমূহ:\n- n - মোট ঘটনার সংখ্যা\n- signs - ঘটনাগুলির পর্যায়ক্রমিকতা প্রতিনিধিত্বকারী একটি অ্যারে\n\nফেরত দেয় যে বছর n-তম ঘটনা ঘটে\n\nউদাহরণ:\napocalypseYear(6, [3,2,4,5,9,18]) // 36 ফেরত দেয়",
      "bg": "Напишете TypeScript функция `function apocalypseYear(n: number, signs: number[]): number`, за да решите следния проблем:\nИзчислява годината Y_n, когато се случва n-тото събитие, като се има предвид, че всяко събитие има периодичност от a_i години. Обратното броене за събитие i+1 започва годината след като се случи събитие i.\n\nПараметри:\n- n - общият брой на събитията\n- signs - масив, представляващ периодичностите на събитията\n\nВръща Годината, когато се случва n-тото събитие\n\nПример:\napocalypseYear(6, [3,2,4,5,9,18]) // връща 36",
      "zh": "编写一个 TypeScript 函数 `function apocalypseYear(n: number, signs: number[]): number` 来解决以下问题：\n计算第 n 个事件发生的年份 Y_n，考虑到每个事件都有一个 a_i 年的周期性。事件 i+1 的倒计时在事件 i 发生后的下一年开始。\n\n参数：\n- n - 事件的总数\n- signs - 一个数组，表示事件的周期性\n\n返回 第 n 个事件发生的年份\n\n示例：\napocalypseYear(6, [3,2,4,5,9,18]) // 返回 36",
      "fr": "Écrire une fonction TypeScript `function apocalypseYear(n: number, signs: number[]): number` pour résoudre le problème suivant :\nCalcule l'année Y_n lorsque le n-ème événement se produit, en considérant que chaque événement a une périodicité de a_i années. Le compte à rebours pour l'événement i+1 commence l'année après que l'événement i se produit.\n\nParamètres :\n- n - le nombre total d'événements\n- signs - un tableau représentant les périodicités des événements\n\nRenvoie L'année où le n-ème événement se produit\n\nExemple :\napocalypseYear(6, [3,2,4,5,9,18]) // renvoie 36",
      "de": "Schreiben Sie eine TypeScript-Funktion `function apocalypseYear(n: number, signs: number[]): number`, um das folgende Problem zu lösen:\nBerechnet das Jahr Y_n, in dem das n-te Ereignis eintritt, wobei jedes Ereignis eine Periodizität von a_i Jahren hat. Der Countdown für das Ereignis i+1 beginnt im Jahr nach dem Eintreten des Ereignisses i.\n\nParameter:\n- n - die Gesamtanzahl der Ereignisse\n- signs - ein Array, das die Periodizitäten der Ereignisse darstellt\n\nGibt das Jahr zurück, in dem das n-te Ereignis eintritt\n\nBeispiel:\napocalypseYear(6, [3,2,4,5,9,18]) // gibt 36 zurück",
      "ha": "Rubuta aikin TypeScript `function apocalypseYear(n: number, signs: number[]): number` don warware matsalar mai zuwa:\nLissafin shekarar Y_n lokacin da abin da ya faru na n-th ya faru, la'akari da cewa kowane abu yana da maimaituwa na a_i shekaru. Kirga don abin da ya faru na i+1 yana farawa shekara bayan abin da ya faru na i ya faru.\n\nSigogi:\n- n - jimlar adadin abubuwan da suka faru\n- signs - jerin lambobi da ke wakiltar maimaituwar abubuwan da suka faru\n\nDawowa Shekarar da abin da ya faru na n-th ya faru\n\nMisali:\napocalypseYear(6, [3,2,4,5,9,18]) // returns 36",
      "hi": "TypeScript फ़ंक्शन `function apocalypseYear(n: number, signs: number[]): number` लिखें ताकि निम्नलिखित समस्या का समाधान हो सके:\nगणना करता है वर्ष Y_n जब n-वां घटना होती है, यह मानते हुए कि प्रत्येक घटना की आवृत्ति a_i वर्षों की होती है। घटना i+1 की उलटी गिनती घटना i के होने के अगले वर्ष से शुरू होती है।\n\nपैरामीटर्स:\n- n - घटनाओं की कुल संख्या\n- signs - घटनाओं की आवृत्तियों का प्रतिनिधित्व करने वाला एक ऐरे\n\nवापसी करता है वह वर्ष जब n-वां घटना होती है\n\nउदाहरण:\napocalypseYear(6, [3,2,4,5,9,18]) // 36 लौटाता है",
      "hu": "Készíts egy TypeScript függvényt `function apocalypseYear(n: number, signs: number[]): number` a következő probléma megoldására:\nKiszámítja az Y_n évet, amikor az n-edik esemény bekövetkezik, figyelembe véve, hogy minden eseménynek a_i években van egy periodicitása. Az i+1 esemény visszaszámlálása az i esemény bekövetkezése utáni évben kezdődik.\n\nParaméterek:\n- n - az események teljes száma\n- signs - egy tömb, amely az események periodicitásait képviseli\n\nVisszatérési érték Az év, amikor az n-edik esemény bekövetkezik\n\nPélda:\napocalypseYear(6, [3,2,4,5,9,18]) // visszaadja 36"
    },
    "instruction_bertscore": {
      "sq": "0.9858932703389023",
      "hy": "0.9756574495434124",
      "bn": "0.9606062324204937",
      "bg": "0.9915262293146706",
      "zh": "0.9596480394623814",
      "fr": "0.9986159435049489",
      "de": "0.9778715824008083",
      "ha": "0.9509043300892257",
      "hi": "0.9509976863683121",
      "hu": "0.9647307922826832"
    },
    "level": "easy",
    "test": "const testApocalypseYear = (): void => {\n    console.assert(apocalypseYear(6, [3, 2, 4, 5, 9, 18]) === 36);\n    console.assert(apocalypseYear(5, [1, 2, 3, 4, 5]) === 5);\n    console.assert(apocalypseYear(5, [1, 1, 1, 1, 1]) === 5);\n    console.assert(apocalypseYear(6, [50, 30, 711, 200, 503, 1006]) === 2012);\n    console.assert(apocalypseYear(2, [1, 2]) === 2);\n    console.assert(apocalypseYear(3, [3, 1, 2]) === 6);\n    console.assert(apocalypseYear(3, [2, 3, 4]) === 4);\n    console.assert(apocalypseYear(4, [1, 2, 3, 4]) === 4);\n    console.assert(apocalypseYear(4, [5, 7, 11, 13]) === 13);\n    console.assert(apocalypseYear(5, [2, 2, 2, 2, 2]) === 10);\n    console.assert(apocalypseYear(3, [6, 10, 15]) === 15);\n    console.assert(apocalypseYear(3, [4, 6, 14]) === 14);\n    console.assert(apocalypseYear(4, [50, 30, 711, 200]) === 800);\n    console.assert(apocalypseYear(6, [1, 1, 1, 1, 1, 1]) === 6);\n    console.assert(apocalypseYear(2, [1000000, 999999]) === 1999998);\n};\n\ntestApocalypseYear();",
    "entry_point": "apocalypseYear",
    "signature": "function apocalypseYear(n: number, signs: number[]): number",
    "docstring": {
      "en": "Calculates the year Y_n when the n-th event occurs, considering that each event has a periodicity of a_i years. The countdown for event i+1 starts the year after event i occurs.\n\nParameters:\n- n - the total number of events\n- signs - an array representing the periodicities of the events\n\nReturns The year when the n-th event occurs\n\nExample:\napocalypseYear(6, [3,2,4,5,9,18]) // returns 36\n",
      "sq": "Llogarit vitin Y_n kur ndodh ngjarja e n-të, duke marrë parasysh që çdo ngjarje ka një periodikë prej a_i vitesh. Numërimi mbrapsht për ngjarjen i+1 fillon vitin pas ngjarjes i.\n\nParametrat:\n- n - numri total i ngjarjeve\n- signs - një varg që përfaqëson periodikët e ngjarjeve\n\nKthen Vitin kur ndodh ngjarja e n-të\n\nShembull:\napocalypseYear(6, [3,2,4,5,9,18]) // kthen 36",
      "hy": "Հաշվում է Y_n տարին, երբ տեղի է ունենում n-րդ իրադարձությունը՝ հաշվի առնելով, որ յուրաքանչյուր իրադարձություն ունի a_i տարիների պարբերականություն։ Իրադարձություն i+1-ի համար հետհաշվարկը սկսվում է իրադարձություն i-ի տեղի ունենալուց հետո։\n\nՊարամետրեր:\n- n - իրադարձությունների ընդհանուր քանակը\n- signs - զանգված, որը ներկայացնում է իրադարձությունների պարբերականությունները\n\nՎերադարձնում է այն տարին, երբ տեղի է ունենում n-րդ իրադարձությունը\n\nՕրինակ:\napocalypseYear(6, [3,2,4,5,9,18]) // վերադարձնում է 36",
      "bn": "n-তম ঘটনা কখন ঘটে তা গণনা করে, প্রতিটি ঘটনার একটি a_i বছরের পর্যায়কাল রয়েছে বিবেচনা করে। ঘটনা i ঘটনার পরবর্তী বছর থেকে ঘটনা i+1 এর কাউন্টডাউন শুরু হয়।\n\nপ্যারামিটারসমূহ:\n- n - মোট ঘটনার সংখ্যা\n- signs - ঘটনাগুলির পর্যায়কাল প্রতিনিধিত্বকারী একটি অ্যারে\n\nফেরত দেয় n-তম ঘটনা যখন ঘটে\n\nউদাহরণ:\napocalypseYear(6, [3,2,4,5,9,18]) // 36 ফেরত দেয়",
      "bg": "Изчислява годината Y_n, когато се случва n-тото събитие, като се има предвид, че всяко събитие има периодичност от a_i години. Обратното броене за събитие i+1 започва годината след като събитие i се случи.\n\nПараметри:\n- n - общият брой на събитията\n- signs - масив, представляващ периодичностите на събитията\n\nВръща Годината, когато се случва n-тото събитие\n\nПример:\napocalypseYear(6, [3,2,4,5,9,18]) // връща 36",
      "zh": "计算第 n 个事件发生的年份 Y_n，考虑到每个事件的周期性为 a_i 年。事件 i+1 的倒计时从事件 i 发生后的下一年开始。\n\n参数：\n- n - 事件的总数\n- signs - 一个数组，表示事件的周期性\n\n返回 第 n 个事件发生的年份\n\n示例：\napocalypseYear(6, [3,2,4,5,9,18]) // 返回 36",
      "fr": "Calcule l'année Y_n lorsque le n-ième événement se produit, en considérant que chaque événement a une périodicité de a_i années. Le compte à rebours pour l'événement i+1 commence l'année après que l'événement i se produit.\n\nParamètres :\n- n - le nombre total d'événements\n- signs - un tableau représentant les périodicités des événements\n\nRetourne L'année où le n-ième événement se produit\n\nExemple :\napocalypseYear(6, [3,2,4,5,9,18]) // retourne 36",
      "de": "Berechnet das Jahr Y_n, in dem das n-te Ereignis eintritt, wobei berücksichtigt wird, dass jedes Ereignis eine Periodizität von a_i Jahren hat. Der Countdown für Ereignis i+1 beginnt im Jahr nach dem Eintreten von Ereignis i.\n\nParameter:\n- n - die Gesamtanzahl der Ereignisse\n- signs - ein Array, das die Periodizitäten der Ereignisse darstellt\n\nGibt das Jahr zurück, in dem das n-te Ereignis eintritt\n\nBeispiel:\napocalypseYear(6, [3,2,4,5,9,18]) // gibt 36 zurück",
      "ha": "Yana ƙididdige shekarar Y_n lokacin da abin da ya faru na n-th ya faru, la'akari da cewa kowane abin da ya faru yana da maimaituwa na a_i shekaru. Kirga don abin da ya faru i+1 yana farawa shekara bayan abin da ya faru i ya faru.\n\nSigogi:\n- n - jimlar adadin abubuwan da suka faru\n- signs - wani tsari da ke wakiltar maimaituwar abubuwan da suka faru\n\nDawo da Shekarar da abin da ya faru na n-th ya faru\n\nMisali:\napocalypseYear(6, [3,2,4,5,9,18]) // ya dawo da 36",
      "hi": "Calculates the year Y_n जब n-वां घटना होती है, यह मानते हुए कि प्रत्येक घटना की आवृत्ति a_i वर्षों की होती है। घटना i+1 की उलटी गिनती घटना i के होने के अगले वर्ष से शुरू होती है।\n\nपैरामीटर्स:\n- n - घटनाओं की कुल संख्या\n- signs - घटनाओं की आवृत्तियों का प्रतिनिधित्व करने वाला एक सरणी\n\nवापसी करता है वह वर्ष जब n-वां घटना होती है\n\nउदाहरण:\napocalypseYear(6, [3,2,4,5,9,18]) // 36 लौटाता है",
      "hu": "Kiszámítja az Y_n évet, amikor az n-edik esemény bekövetkezik, figyelembe véve, hogy minden eseménynek a_i éves periódusa van. Az i+1 esemény visszaszámlálása az i esemény bekövetkezése utáni évben kezdődik.\n\nParaméterek:\n- n - az események teljes száma\n- signs - egy tömb, amely az események periódusait képviseli\n\nVisszatér Az év, amikor az n-edik esemény bekövetkezik\n\nPélda:\napocalypseYear(6, [3,2,4,5,9,18]) // visszatér 36"
    },
    "docstring_bertscore": {
      "sq": "0.9836578840307356",
      "hy": "0.9714673416554814",
      "bn": "0.9074362561339318",
      "bg": "0.9976990656660919",
      "zh": "0.9562838366987936",
      "fr": "0.9975987573236692",
      "de": "0.964951867896775",
      "ha": "0.9313585047042495",
      "hi": "0.9523783661468855",
      "hu": "0.9595528955098657"
    }
  },
  {
    "task_id": "TypeScript/33",
    "prompt": {
      "en": "\n/**\n * This problem introduces a new modulo operation, denoted by the symbol \"⊕\".\n * When calculating x ⊕ y, if x is not a multiple of y, the result is the remainder of x divided by y.\n * Otherwise, divide x by y repeatedly until x is no longer a multiple of y, denoting the final value as x'.\n * Then the result is the remainder of x' divided by y.\n * For example, 4⊕5=4, 20⊕5=4, 100⊕5=4.\n * Given a prime number p, there will be several queries. For each query, an integer n is given,\n * and you need to compute the value of n! ⊕ p, where n! is the factorial of n,\n * i.e. the product of all positive integers less than or equal to n.\n * \n * @example\n * newModuloFactorial(3, 7); // returns 6\n */\nfunction newModuloFactorial(n: number, p: number): number {",
      "sq": "/**\n * Ky problem prezanton një operacion të ri modulo, i shënuar me simbolin \"⊕\".\n * Kur llogaritni x ⊕ y, nëse x nuk është shumëfish i y, rezultati është mbetja e x pjesëtuar me y.\n * Përndryshe, pjesëtoni x me y në mënyrë të përsëritur derisa x të mos jetë më shumëfish i y, duke e shënuar vlerën përfundimtare si x'.\n * Pastaj rezultati është mbetja e x' pjesëtuar me y.\n * Për shembull, 4⊕5=4, 20⊕5=4, 100⊕5=4.\n * Duke pasur një numër të thjeshtë p, do të ketë disa pyetje. Për çdo pyetje, jepet një numër i plotë n,\n * dhe ju duhet të llogaritni vlerën e n! ⊕ p, ku n! është faktoriali i n,\n * dmth. prodhimi i të gjitha numrave të plotë pozitivë më të vegjël ose të barabartë me n.\n * \n * @example\n * newModuloFactorial(3, 7); // returns 6\n */\nfunction newModuloFactorial(n: number, p: number): number {",
      "hy": "/**\n * Այս խնդիրը ներկայացնում է նոր մոդուլո գործողություն, որը նշված է \"⊕\" սիմվոլով:\n * Երբ հաշվարկում ենք x ⊕ y, եթե x-ը y-ի բազմապատիկ չէ, արդյունքը x-ի բաժանումից y-ի մնացորդն է:\n * Հակառակ դեպքում, բազմիցս բաժանեք x-ը y-ի վրա, մինչև x-ը այլևս y-ի բազմապատիկ չլինի, վերջնական արժեքը նշելով որպես x':\n * Ապա արդյունքը x'-ի բաժանումից y-ի մնացորդն է:\n * Օրինակ, 4⊕5=4, 20⊕5=4, 100⊕5=4:\n * Տրված է պարզ թիվ p, լինելու են մի քանի հարցումներ: Յուրաքանչյուր հարցման համար տրված է n ամբողջ թիվ,\n * և դուք պետք է հաշվարկեք n! ⊕ p արժեքը, որտեղ n! -ը n-ի ֆակտորիալն է,\n * այսինքն՝ n-ից փոքր կամ հավասար բոլոր դրական ամբողջ թվերի արտադրյալը:\n * \n * @example\n * newModuloFactorial(3, 7); // վերադարձնում է 6\n */\nfunction newModuloFactorial(n: number, p: number): number {",
      "bn": "/**\n * এই সমস্যাটি একটি নতুন মডুলো অপারেশন পরিচয় করায়, যা \"⊕\" প্রতীক দ্বারা নির্দেশিত।\n * যখন x ⊕ y গণনা করা হয়, যদি x y এর গুণিতক না হয়, তবে ফলাফল হল x কে y দিয়ে ভাগ করলে যে অবশিষ্ট থাকে।\n * অন্যথায়, x কে y দিয়ে বারবার ভাগ করুন যতক্ষণ না x আর y এর গুণিতক থাকে না, এবং চূড়ান্ত মানটিকে x' হিসাবে নির্দেশ করুন।\n * তারপর ফলাফল হল x' কে y দিয়ে ভাগ করলে যে অবশিষ্ট থাকে।\n * উদাহরণস্বরূপ, 4⊕5=4, 20⊕5=4, 100⊕5=4।\n * একটি মৌলিক সংখ্যা p দেওয়া হয়েছে, এবং বেশ কয়েকটি প্রশ্ন থাকবে। প্রতিটি প্রশ্নের জন্য, একটি পূর্ণসংখ্যা n দেওয়া হয়,\n * এবং আপনাকে n! ⊕ p এর মান গণনা করতে হবে, যেখানে n! হল n এর ফ্যাক্টরিয়াল,\n * অর্থাৎ n এর চেয়ে ছোট বা সমান সমস্ত ধনাত্মক পূর্ণসংখ্যার গুণফল।\n * \n * @example\n * newModuloFactorial(3, 7); // returns 6\n */\nfunction newModuloFactorial(n: number, p: number): number {",
      "bg": "/**\n * Този проблем въвежда нова операция модуло, обозначена със символа \"⊕\".\n * При изчисляване на x ⊕ y, ако x не е кратно на y, резултатът е остатъкът от x, разделен на y.\n * В противен случай, разделяйте x на y многократно, докато x вече не е кратно на y, обозначавайки крайната стойност като x'.\n * Тогава резултатът е остатъкът от x', разделен на y.\n * Например, 4⊕5=4, 20⊕5=4, 100⊕5=4.\n * Дадено е просто число p, ще има няколко заявки. За всяка заявка е дадено цяло число n,\n * и трябва да изчислите стойността на n! ⊕ p, където n! е факториелът на n,\n * т.е. произведението на всички положителни цели числа, по-малки или равни на n.\n * \n * @example\n * newModuloFactorial(3, 7); // returns 6\n */\nfunction newModuloFactorial(n: number, p: number): number {",
      "zh": "/**\n * 这个问题引入了一种新的模运算，用符号“⊕”表示。\n * 计算 x ⊕ y 时，如果 x 不是 y 的倍数，结果是 x 除以 y 的余数。\n * 否则，反复将 x 除以 y，直到 x 不再是 y 的倍数，将最终值记为 x'。\n * 然后结果是 x' 除以 y 的余数。\n * 例如，4⊕5=4, 20⊕5=4, 100⊕5=4。\n * 给定一个素数 p，会有若干查询。对于每个查询，给定一个整数 n，\n * 你需要计算 n! ⊕ p 的值，其中 n! 是 n 的阶乘，\n * 即小于或等于 n 的所有正整数的乘积。\n * \n * @example\n * newModuloFactorial(3, 7); // returns 6\n */\nfunction newModuloFactorial(n: number, p: number): number {",
      "fr": "/**\n * Ce problème introduit une nouvelle opération modulo, notée par le symbole \"⊕\".\n * Lors du calcul de x ⊕ y, si x n'est pas un multiple de y, le résultat est le reste de x divisé par y.\n * Sinon, divisez x par y de manière répétée jusqu'à ce que x ne soit plus un multiple de y, en notant la valeur finale comme x'.\n * Ensuite, le résultat est le reste de x' divisé par y.\n * Par exemple, 4⊕5=4, 20⊕5=4, 100⊕5=4.\n * Étant donné un nombre premier p, il y aura plusieurs requêtes. Pour chaque requête, un entier n est donné,\n * et vous devez calculer la valeur de n! ⊕ p, où n! est la factorielle de n,\n * c'est-à-dire le produit de tous les entiers positifs inférieurs ou égaux à n.\n * \n * @example\n * newModuloFactorial(3, 7); // returns 6\n */\nfunction newModuloFactorial(n: number, p: number): number {",
      "de": "/**\n * Dieses Problem führt eine neue Modulo-Operation ein, die durch das Symbol \"⊕\" dargestellt wird.\n * Bei der Berechnung von x ⊕ y, wenn x kein Vielfaches von y ist, ist das Ergebnis der Rest von x geteilt durch y.\n * Andernfalls teile x wiederholt durch y, bis x kein Vielfaches von y mehr ist, und bezeichne den Endwert als x'.\n * Dann ist das Ergebnis der Rest von x' geteilt durch y.\n * Zum Beispiel, 4⊕5=4, 20⊕5=4, 100⊕5=4.\n * Gegeben ist eine Primzahl p, es wird mehrere Anfragen geben. Für jede Anfrage wird eine ganze Zahl n gegeben,\n * und Sie müssen den Wert von n! ⊕ p berechnen, wobei n! die Fakultät von n ist,\n * d.h. das Produkt aller positiven ganzen Zahlen, die kleiner oder gleich n sind.\n * \n * @example\n * newModuloFactorial(3, 7); // gibt 6 zurück\n */\nfunction newModuloFactorial(n: number, p: number): number {",
      "ha": "/**\n * Wannan matsalar tana gabatar da sabon aikin modulo, wanda aka nuna da alamar \"⊕\".\n * Lokacin da ake lissafin x ⊕ y, idan x ba ya kasu da y ba tare da saura ba, sakamakon shi ne saura na x raba da y.\n * In ba haka ba, a raba x da y akai-akai har sai x ba ya kasu da y, ana nuna ƙimar ƙarshe da x'.\n * Sannan sakamakon shi ne saura na x' raba da y.\n * Alal misali, 4⊕5=4, 20⊕5=4, 100⊕5=4.\n * An ba da lambar farko p, za a sami tambayoyi da yawa. Don kowace tambaya, an ba da cikakken lamba n,\n * kuma kuna buƙatar lissafin ƙimar n! ⊕ p, inda n! shine factorial na n,\n * wato samfurin duk lambobin kirki da suka fi ƙarami ko daidai da n.\n * \n * @example\n * newModuloFactorial(3, 7); // returns 6\n */\nfunction newModuloFactorial(n: number, p: number): number {",
      "hi": "/**\n * यह समस्या एक नए माड्यूलो ऑपरेशन को प्रस्तुत करती है, जिसे प्रतीक \"⊕\" द्वारा दर्शाया गया है।\n * जब x ⊕ y की गणना करते हैं, यदि x, y का गुणज नहीं है, तो परिणाम x को y से विभाजित करने पर शेषफल होता है।\n * अन्यथा, x को y से बार-बार विभाजित करें जब तक कि x अब y का गुणज न हो, अंतिम मान को x' के रूप में दर्शाते हुए।\n * फिर परिणाम x' को y से विभाजित करने पर शेषफल होता है।\n * उदाहरण के लिए, 4⊕5=4, 20⊕5=4, 100⊕5=4।\n * एक अभाज्य संख्या p दी गई है, और कई क्वेरीज़ होंगी। प्रत्येक क्वेरी के लिए, एक पूर्णांक n दिया गया है,\n * और आपको n! ⊕ p का मान निकालना है, जहाँ n! n का फैक्टोरियल है,\n * अर्थात n से कम या बराबर सभी धनात्मक पूर्णांकों का गुणनफल।\n * \n * @example\n * newModuloFactorial(3, 7); // returns 6\n */\nfunction newModuloFactorial(n: number, p: number): number {",
      "hu": "/**\n * Ez a probléma egy új modulo műveletet vezet be, amelyet a \"⊕\" szimbólum jelöl.\n * Amikor az x ⊕ y-t számoljuk, ha x nem osztható y-nal, az eredmény x maradéka y-nal osztva.\n * Ellenkező esetben osszuk el x-et y-nal ismételten, amíg x már nem osztható y-nal, és a végső értéket jelöljük x'-ként.\n * Ekkor az eredmény x' maradéka y-nal osztva.\n * Például, 4⊕5=4, 20⊕5=4, 100⊕5=4.\n * Adott egy prímszám p, több lekérdezés lesz. Minden lekérdezéshez adott egy egész szám n,\n * és ki kell számítani az n! ⊕ p értékét, ahol n! az n faktoriálisa,\n * azaz az összes pozitív egész szám szorzata, amely kisebb vagy egyenlő n-nel.\n * \n * @example\n * newModuloFactorial(3, 7); // returns 6\n */\nfunction newModuloFactorial(n: number, p: number): number {"
    },
    "prompt_bertscore": {
      "sq": "0.9923559084162533",
      "hy": "0.9801856263398647",
      "bn": "0.9616083226928147",
      "bg": "0.996840187898497",
      "zh": "0.977346403673352",
      "fr": "0.9878771905846787",
      "de": "0.9813444359828223",
      "ha": "0.9625575772837804",
      "hi": "0.9743973384061271",
      "hu": "0.9662296571379725"
    },
    "canonical_solution": "const pj: number[] = new Array(p).fill(1);\n    for (let i = 2; i < p; i++) pj[i] = (i * pj[i - 1]) % p;\n    \n    let ans = 1;\n    while (n > 0) {\n        ans = (ans * pj[n % p]) % p;\n        ans = ((n / p) & 1) ? p - ans : ans;\n        n = Math.floor(n / p);\n    }\n    return ans;\n}",
    "instruction": {
      "en": "Write a TypeScript function `function newModuloFactorial(n: number, p: number): number` to solve the following problem:\nThis problem introduces a new modulo operation, denoted by the symbol '⊕'.\nWhen calculating x ⊕ y, if x is not a multiple of y, the result is the remainder of x divided by y.\nOtherwise, divide x by y repeatedly until x is no longer a multiple of y, denoting the final value as x'.\nThen the result is the remainder of x' divided by y.\nFor example, 4⊕5=4, 20⊕5=4, 100⊕5=4.\nGiven a prime number p, there will be several queries. For each query, an integer n is given,\nand you need to compute the value of n! ⊕ p, where n! is the factorial of n,\ni.e. the product of all positive integers less than or equal to n.\n\n@example\nnewModuloFactorial(3, 7); // returns 6",
      "sq": "Shkruani një funksion TypeScript `function newModuloFactorial(n: number, p: number): number` për të zgjidhur problemin e mëposhtëm:\nKy problem prezanton një operacion të ri modulo, i shënuar me simbolin '⊕'.\nKur llogaritni x ⊕ y, nëse x nuk është shumëfish i y, rezultati është mbetja e x pjesëtuar me y.\nPërndryshe, ndani x me y në mënyrë të përsëritur derisa x të mos jetë më shumëfish i y, duke e shënuar vlerën përfundimtare si x'.\nAtëherë rezultati është mbetja e x' pjesëtuar me y.\nPër shembull, 4⊕5=4, 20⊕5=4, 100⊕5=4.\nDuke pasur një numër të plotë p, do të ketë disa kërkesa. Për çdo kërkesë, jepet një numër i plotë n,\ndhe ju duhet të llogaritni vlerën e n! ⊕ p, ku n! është faktoriali i n,\nd.m.th. prodhimi i të gjithë numrave të plotë pozitivë më të vegjël ose të barabartë me n.\n\n@example\nnewModuloFactorial(3, 7); // kthen 6",
      "hy": "Գրեք TypeScript ֆունկցիա `function newModuloFactorial(n: number, p: number): number` հետևյալ խնդիրը լուծելու համար:\nԱյս խնդիրը ներկայացնում է նոր մոդուլո գործողություն, որը նշվում է '⊕' նշանով:\nԵրբ հաշվարկում ենք x ⊕ y, եթե x-ը y-ի բազմապատիկ չէ, արդյունքը x-ի y-ով բաժանման մնացորդն է:\nՀակառակ դեպքում, բաժանեք x-ը y-ով կրկնակի, մինչև x-ը այլևս y-ի բազմապատիկ չլինի, վերջնական արժեքը նշելով որպես x':\nԱյնուհետև արդյունքը x'-ի y-ով բաժանման մնացորդն է:\nՕրինակ, 4⊕5=4, 20⊕5=4, 100⊕5=4:\nՏրված է p պարզ թիվ, և կլինեն մի քանի հարցումներ: Յուրաքանչյուր հարցման համար տրված է n ամբողջ թիվ,\nև դուք պետք է հաշվեք n! ⊕ p արժեքը, որտեղ n! n-ի ֆակտորիալն է,\nայսինքն՝ n-ից փոքր կամ հավասար բոլոր դրական ամբողջ թվերի արտադրյալը:\n\n@example\nnewModuloFactorial(3, 7); // վերադարձնում է 6",
      "bn": "TypeScript ফাংশন `function newModuloFactorial(n: number, p: number): number` লিখুন নিম্নলিখিত সমস্যার সমাধানের জন্য:\nএই সমস্যা একটি নতুন মডুলো অপারেশন পরিচয় করায়, যা '⊕' প্রতীকে চিহ্নিত।\nযখন x ⊕ y গণনা করা হয়, যদি x y এর গুণিতক না হয়, তাহলে ফলাফল হয় x কে y দিয়ে ভাগ করার পরে অবশিষ্টাংশ।\nঅন্যথায়, x কে y দিয়ে বারবার ভাগ করুন যতক্ষণ না x আর y এর গুণিতক থাকে না, চূড়ান্ত মানটিকে x' হিসাবে চিহ্নিত করুন।\nতারপর ফলাফল হয় x' কে y দিয়ে ভাগ করার পরে অবশিষ্টাংশ।\nউদাহরণস্বরূপ, 4⊕5=4, 20⊕5=4, 100⊕5=4।\nএকটি মৌলিক সংখ্যা p দেওয়া হলে, অনেকগুলি প্রশ্ন থাকবে। প্রতিটি প্রশ্নের জন্য, একটি পূর্ণসংখ্যা n দেওয়া হয়,\nএবং আপনাকে n! ⊕ p এর মান গণনা করতে হবে, যেখানে n! হল n এর ফ্যাক্টোরিয়াল,\nঅর্থাৎ n এর চেয়ে সমান বা ছোট সকল ধনাত্মক পূর্ণসংখ্যার গুণফল।\n\n@example\nnewModuloFactorial(3, 7); // returns 6",
      "bg": "Напишете функция на TypeScript `function newModuloFactorial(n: number, p: number): number`, за да решите следния проблем:\nТози проблем въвежда нова операция за модул, обозначена със символа '⊕'.\nКогато се изчислява x ⊕ y, ако x не е кратно на y, резултатът е остатъкът от x, разделен на y.\nВ противен случай, разделяйте x на y многократно, докато x вече не е кратно на y, обозначавайки крайната стойност като x'.\nТогава резултатът е остатъкът от x', разделен на y.\nНапример, 4⊕5=4, 20⊕5=4, 100⊕5=4.\nДадено е просто число p, ще има няколко запитвания. За всяко запитване е дадено цяло число n,\nи трябва да изчислите стойността на n! ⊕ p, където n! е факториелът на n,\nт.е. произведението на всички положителни цели числа, по-малки или равни на n.\n\n@example\nnewModuloFactorial(3, 7); // връща 6",
      "zh": "编写一个 TypeScript 函数 `function newModuloFactorial(n: number, p: number): number` 来解决以下问题：\n这个问题引入了一种新的模运算，用符号 '⊕' 表示。\n计算 x ⊕ y 时，如果 x 不是 y 的倍数，结果是 x 除以 y 的余数。\n否则，反复将 x 除以 y，直到 x 不再是 y 的倍数，将最终值记为 x'。\n然后结果是 x' 除以 y 的余数。\n例如，4⊕5=4，20⊕5=4，100⊕5=4。\n给定一个素数 p，会有若干查询。对于每个查询，给定一个整数 n，\n你需要计算 n! ⊕ p 的值，其中 n! 是 n 的阶乘，\n即小于或等于 n 的所有正整数的乘积。\n\n@example\nnewModuloFactorial(3, 7); // 返回 6",
      "fr": "Écrire une fonction TypeScript `function newModuloFactorial(n: number, p: number): number` pour résoudre le problème suivant :\nCe problème introduit une nouvelle opération modulo, notée par le symbole '⊕'.\nLors du calcul de x ⊕ y, si x n'est pas un multiple de y, le résultat est le reste de x divisé par y.\nSinon, divisez x par y de manière répétée jusqu'à ce que x ne soit plus un multiple de y, en notant la valeur finale comme x'.\nEnsuite, le résultat est le reste de x' divisé par y.\nPar exemple, 4⊕5=4, 20⊕5=4, 100⊕5=4.\nÉtant donné un nombre premier p, il y aura plusieurs requêtes. Pour chaque requête, un entier n est donné,\net vous devez calculer la valeur de n! ⊕ p, où n! est la factorielle de n,\nc'est-à-dire le produit de tous les entiers positifs inférieurs ou égaux à n.\n\n@example\nnewModuloFactorial(3, 7); // retourne 6",
      "de": "Schreiben Sie eine TypeScript-Funktion `function newModuloFactorial(n: number, p: number): number`, um das folgende Problem zu lösen:\nDieses Problem führt eine neue Modulo-Operation ein, die durch das Symbol '⊕' dargestellt wird.\nBeim Berechnen von x ⊕ y, wenn x kein Vielfaches von y ist, ist das Ergebnis der Rest von x geteilt durch y.\nAndernfalls teilen Sie x wiederholt durch y, bis x kein Vielfaches von y mehr ist, und bezeichnen den Endwert als x'.\nDann ist das Ergebnis der Rest von x' geteilt durch y.\nZum Beispiel, 4⊕5=4, 20⊕5=4, 100⊕5=4.\nGegeben eine Primzahl p, wird es mehrere Anfragen geben. Für jede Anfrage wird eine ganze Zahl n gegeben,\nund Sie müssen den Wert von n! ⊕ p berechnen, wobei n! die Fakultät von n ist,\nd.h. das Produkt aller positiven ganzen Zahlen kleiner oder gleich n.\n\n@example\nnewModuloFactorial(3, 7); // gibt 6 zurück",
      "ha": "Rubuta aikin TypeScript `function newModuloFactorial(n: number, p: number): number` don warware matsalar mai zuwa:\nWannan matsalar tana gabatar da sabon aiki na modulo, wanda aka nuna da alamar '⊕'.\nLokacin da ake lissafin x ⊕ y, idan x ba ya raba y ba tare da saura ba, sakamakon shine saura na x raba da y.\nIn ba haka ba, raba x da y akai-akai har sai x ba ya sake raba y ba tare da saura ba, ana nuna ƙimar ƙarshe a matsayin x'.\nSannan sakamakon shine saura na x' raba da y.\nMisali, 4⊕5=4, 20⊕5=4, 100⊕5=4.\nAn ba da lamba mai lamba p, za a sami tambayoyi da yawa. Don kowace tambaya, ana ba da cikakken lamba n,\nkuma kuna buƙatar lissafin ƙimar n! ⊕ p, inda n! shine factorial na n,\nwato, samfurin duk lambobi masu kyau da suka yi ƙasa ko daidai da n.\n\n@example\nnewModuloFactorial(3, 7); // returns 6",
      "hi": "TypeScript फ़ंक्शन `function newModuloFactorial(n: number, p: number): number` लिखें ताकि निम्नलिखित समस्या को हल किया जा सके:\nयह समस्या एक नए मॉड्यूलो ऑपरेशन को प्रस्तुत करती है, जिसे प्रतीक '⊕' द्वारा दर्शाया गया है।\nजब x ⊕ y की गणना की जाती है, यदि x, y का गुणज नहीं है, तो परिणाम x को y से विभाजित करने का शेषफल होता है।\nअन्यथा, x को y से बार-बार विभाजित करें जब तक कि x, y का गुणज न रह जाए, अंतिम मान को x' के रूप में दर्शाते हुए।\nफिर परिणाम x' को y से विभाजित करने का शेषफल होता है।\nउदाहरण के लिए, 4⊕5=4, 20⊕5=4, 100⊕5=4।\nएक अभाज्य संख्या p दी गई है, कई क्वेरीज़ होंगी। प्रत्येक क्वेरी के लिए, एक पूर्णांक n दिया गया है,\nऔर आपको n! ⊕ p का मान गणना करने की आवश्यकता है, जहाँ n! n का फैक्टोरियल है,\nअर्थात n से कम या बराबर सभी धनात्मक पूर्णांकों का गुणनफल।\n\n@example\nnewModuloFactorial(3, 7); // returns 6",
      "hu": "Írj egy TypeScript függvényt `function newModuloFactorial(n: number, p: number): number` a következő probléma megoldására:\nEz a probléma bevezet egy új modulo műveletet, amelyet a '⊕' szimbólum jelöl.\nAmikor az x ⊕ y-t számítjuk, ha x nem osztható y-nal, az eredmény x maradéka y-nal osztva.\nEgyébként osszuk el x-et y-nal ismételten, amíg x már nem osztható y-nal, az utolsó értéket x'-ként jelölve.\nEzután az eredmény x' maradéka y-nal osztva.\nPéldául, 4⊕5=4, 20⊕5=4, 100⊕5=4.\nAdott egy prímszám p, több lekérdezés lesz. Minden lekérdezéshez adott egy egész szám n,\nés ki kell számítanod az n! ⊕ p értékét, ahol n! az n faktoriálisa,\nazaz az összes pozitív egész szám szorzata, amely kisebb vagy egyenlő n-nel.\n\n@example\nnewModuloFactorial(3, 7); // visszaadja 6"
    },
    "instruction_bertscore": {
      "sq": "0.9860791883755509",
      "hy": "0.9833122671677349",
      "bn": "0.9669908087580982",
      "bg": "0.9931373203352446",
      "zh": "0.9781939595092279",
      "fr": "0.9875037654683331",
      "de": "0.9821653753476395",
      "ha": "0.9627564062951964",
      "hi": "0.9717515817307424",
      "hu": "0.9740848928167591"
    },
    "level": "easy",
    "test": "(function testNewModuloFactorial(): void {\n    console.assert(newModuloFactorial(3, 7) === 6, 'Test at n=3, p=7 failed');\n    console.assert(newModuloFactorial(10, 3) === 1, 'Test at n=10, p=3 failed');\n    console.assert(newModuloFactorial(11, 7) === 4, 'Test at n=11, p=7 failed');\n    console.assert(newModuloFactorial(45, 7) === 1, 'Test at n=45, p=7 failed');\n    console.assert(newModuloFactorial(14, 7) === 2, 'Test at n=14, p=7 failed');\n    console.assert(newModuloFactorial(1919, 10007) === 3152, 'Test at n=1919, p=10007 failed');\n    console.assert(newModuloFactorial(810, 10007) === 3679, 'Test at n=810, p=10007 failed');\n    console.assert(newModuloFactorial(1, 2) === 1, 'Test at n=1, p=2 failed');\n    console.assert(newModuloFactorial(5, 11) === 10, 'Test at n=5, p=11 failed');\n    console.assert(newModuloFactorial(6, 13) === 5, 'Test at n=6, p=13 failed');\n    console.assert(newModuloFactorial(8, 17) === 13, 'Test at n=8, p=17 failed');\n    console.assert(newModuloFactorial(15, 19) === 16, 'Test at n=15, p=19 failed');\n    console.assert(newModuloFactorial(21, 23) === 1, 'Test at n=21, p=23 failed');\n    console.assert(newModuloFactorial(30, 29) === 28, 'Test at n=30, p=29 failed');\n    console.assert(newModuloFactorial(100, 101) === 100, 'Test at n=100, p=101 failed');\n})();",
    "entry_point": "newModuloFactorial",
    "signature": "function newModuloFactorial(n: number, p: number): number",
    "docstring": {
      "en": "This problem introduces a new modulo operation, denoted by the symbol '⊕'.\nWhen calculating x ⊕ y, if x is not a multiple of y, the result is the remainder of x divided by y.\nOtherwise, divide x by y repeatedly until x is no longer a multiple of y, denoting the final value as x'.\nThen the result is the remainder of x' divided by y.\nFor example, 4⊕5=4, 20⊕5=4, 100⊕5=4.\nGiven a prime number p, there will be several queries. For each query, an integer n is given,\nand you need to compute the value of n! ⊕ p, where n! is the factorial of n,\ni.e. the product of all positive integers less than or equal to n.\n\n@example\nnewModuloFactorial(3, 7); // returns 6",
      "sq": "Ky problem prezanton një operacion të ri modulo, i shënuar me simbolin '⊕'.  \nKur llogarit x ⊕ y, nëse x nuk është shumëfish i y, rezultati është mbetja e x e ndarë me y.  \nPërndryshe, ndaj x me y në mënyrë të përsëritur derisa x të mos jetë më shumëfish i y, duke e shënuar vlerën përfundimtare si x'.  \nAtëherë rezultati është mbetja e x' e ndarë me y.  \nPër shembull, 4⊕5=4, 20⊕5=4, 100⊕5=4.  \nDuke pasur një numër të plotë p, do të ketë disa kërkesa. Për çdo kërkesë, jepet një numër i plotë n,  \ndhe ju duhet të llogaritni vlerën e n! ⊕ p, ku n! është faktoriali i n,  \ndmth. produkti i të gjithë numrave të plotë pozitivë më të vegjël ose të barabartë me n.\n\n@example  \nnewModuloFactorial(3, 7); // kthen 6",
      "hy": "Այս խնդիրը ներկայացնում է նոր մնացորդային գործողություն, որը նշվում է '⊕' սիմվոլով:  \nԵրբ հաշվարկում ենք x ⊕ y, եթե x-ը y-ի բազմապատիկ չէ, արդյունքը x-ի y-ով բաժանման մնացորդն է:  \nՀակառակ դեպքում, բաժանեք x-ը y-ի վրա կրկնակի, մինչև x-ը այլևս y-ի բազմապատիկ չլինի, վերջնական արժեքը նշելով որպես x':  \nԱյնուհետև արդյունքը x'-ի y-ով բաժանման մնացորդն է:  \nՕրինակ, 4⊕5=4, 20⊕5=4, 100⊕5=4:  \nՏրված է p պարզ թիվը, և կլինեն մի քանի հարցումներ: Յուրաքանչյուր հարցման համար տրված է n ամբողջ թիվը,  \nև դուք պետք է հաշվարկեք n! ⊕ p արժեքը, որտեղ n! n-ի ֆակտորիալն է,  \nայսինքն՝ n-ից փոքր կամ հավասար բոլոր դրական ամբողջ թվերի արտադրյալը:\n\n@example  \nnewModuloFactorial(3, 7); // վերադարձնում է 6",
      "bn": "এই সমস্যাটি একটি নতুন মডুলো অপারেশন পরিচয় করায়, যা '⊕' প্রতীক দ্বারা চিহ্নিত। \nযখন x ⊕ y গণনা করা হয়, যদি x y এর গুণিতক না হয়, তবে ফলাফল হয় x কে y দ্বারা ভাগ করলে যে অবশিষ্ট থাকে। \nঅন্যথায়, x কে y দ্বারা বারবার ভাগ করুন যতক্ষণ না x আর y এর গুণিতক থাকে, চূড়ান্ত মানটিকে x' হিসাবে চিহ্নিত করুন। \nতারপর ফলাফল হয় x' কে y দ্বারা ভাগ করলে যে অবশিষ্ট থাকে। \nউদাহরণস্বরূপ, 4⊕5=4, 20⊕5=4, 100⊕5=4। \nএকটি মৌলিক সংখ্যা p দেওয়া হলে, কয়েকটি প্রশ্ন থাকবে। প্রতিটি প্রশ্নের জন্য, একটি পূর্ণসংখ্যা n দেওয়া হয়, \nএবং আপনাকে n! ⊕ p এর মান গণনা করতে হবে, যেখানে n! হল n এর ফ্যাক্টোরিয়াল, \nঅর্থাৎ n এর চেয়ে ছোট বা সমান সকল ধনাত্মক পূর্ণসংখ্যার গুণফল।\n\n@example\nnewModuloFactorial(3, 7); // 6 ফেরত দেয়",
      "bg": "Този проблем въвежда нова операция за модулно деление, обозначена със символа '⊕'.  \nКогато се изчислява x ⊕ y, ако x не е кратно на y, резултатът е остатъкът от x, разделен на y.  \nВ противен случай, разделяйте x на y многократно, докато x вече не е кратно на y, като обозначите крайната стойност като x'.  \nТогава резултатът е остатъкът от x', разделен на y.  \nНапример, 4⊕5=4, 20⊕5=4, 100⊕5=4.  \nДадено е просто число p, ще има няколко запитвания. За всяко запитване е дадено цяло число n,  \nи трябва да изчислите стойността на n! ⊕ p, където n! е факториелът на n,  \nт.е. произведението на всички положителни цели числа, по-малки или равни на n.\n\n@example  \nnewModuloFactorial(3, 7); // връща 6",
      "zh": "这个问题引入了一种新的取模运算，用符号 '⊕' 表示。\n在计算 x ⊕ y 时，如果 x 不是 y 的倍数，结果是 x 除以 y 的余数。\n否则，反复将 x 除以 y，直到 x 不再是 y 的倍数，记最终值为 x'。\n然后结果是 x' 除以 y 的余数。\n例如，4⊕5=4，20⊕5=4，100⊕5=4。\n给定一个质数 p，将会有若干查询。对于每个查询，给定一个整数 n，\n你需要计算 n! ⊕ p 的值，其中 n! 是 n 的阶乘，\n即小于或等于 n 的所有正整数的乘积。\n\n@example\nnewModuloFactorial(3, 7); // returns 6",
      "fr": "Ce problème introduit une nouvelle opération modulo, notée par le symbole '⊕'.\nLors du calcul de x ⊕ y, si x n'est pas un multiple de y, le résultat est le reste de la division de x par y.\nSinon, divisez x par y de manière répétée jusqu'à ce que x ne soit plus un multiple de y, en notant la valeur finale comme x'.\nEnsuite, le résultat est le reste de la division de x' par y.\nPar exemple, 4⊕5=4, 20⊕5=4, 100⊕5=4.\nÉtant donné un nombre premier p, il y aura plusieurs requêtes. Pour chaque requête, un entier n est donné,\net vous devez calculer la valeur de n! ⊕ p, où n! est la factorielle de n,\nc'est-à-dire le produit de tous les entiers positifs inférieurs ou égaux à n.\n\n@example\nnewModuloFactorial(3, 7); // retourne 6",
      "de": "Dieses Problem führt eine neue Modulo-Operation ein, die durch das Symbol '⊕' dargestellt wird.  \nBei der Berechnung von x ⊕ y, wenn x kein Vielfaches von y ist, ist das Ergebnis der Rest von x geteilt durch y.  \nAndernfalls teilen Sie x wiederholt durch y, bis x kein Vielfaches von y mehr ist, und bezeichnen den Endwert als x'.  \nDann ist das Ergebnis der Rest von x' geteilt durch y.  \nZum Beispiel, 4⊕5=4, 20⊕5=4, 100⊕5=4.  \nGegeben eine Primzahl p, wird es mehrere Anfragen geben. Für jede Anfrage wird eine ganze Zahl n gegeben,  \nund Sie müssen den Wert von n! ⊕ p berechnen, wobei n! die Fakultät von n ist,  \nd.h. das Produkt aller positiven ganzen Zahlen kleiner oder gleich n.\n\n@Beispiel  \nnewModuloFactorial(3, 7); // gibt 6 zurück",
      "ha": "Wannan matsala tana gabatar da sabon aikin modulo, wanda aka nuna da alamar '⊕'. \nLokacin da ake lissafin x ⊕ y, idan x ba ya raba y ba tare da saura ba, sakamakon shine saura na x raba da y. \nIn ba haka ba, a raba x da y sau da yawa har sai x ba ya raba y ba tare da saura ba, ana nuna ƙimar ƙarshe da x'. \nSannan sakamakon shine saura na x' raba da y. \nMisali, 4⊕5=4, 20⊕5=4, 100⊕5=4. \nAn ba da lambar firam p, za a sami tambayoyi da yawa. Don kowace tambaya, ana ba da cikakken lamba n, \nkuma kuna buƙatar lissafin ƙimar n! ⊕ p, inda n! shine factorial na n, \nwato samfurin duk lambobin kirki ƙasa ko daidai da n.\n\n@example\nnewModuloFactorial(3, 7); // yana dawowa 6",
      "hi": "इस समस्या में एक नया माड्यूलो ऑपरेशन प्रस्तुत किया गया है, जिसे प्रतीक '⊕' द्वारा दर्शाया गया है। \nजब x ⊕ y की गणना की जाती है, यदि x, y का गुणज नहीं है, तो परिणाम x को y से विभाजित करने पर शेषफल होता है। \nअन्यथा, x को y से बार-बार विभाजित करें जब तक कि x अब y का गुणज न हो, अंतिम मान को x' के रूप में दर्शाते हुए। \nफिर परिणाम x' को y से विभाजित करने पर शेषफल होता है। \nउदाहरण के लिए, 4⊕5=4, 20⊕5=4, 100⊕5=4। \nएक अभाज्य संख्या p दी गई है, कई प्रश्न होंगे। प्रत्येक प्रश्न के लिए, एक पूर्णांक n दिया गया है, \nऔर आपको n! ⊕ p का मान गणना करने की आवश्यकता है, जहाँ n! n का फैक्टोरियल है, \nअर्थात n से कम या बराबर सभी धनात्मक पूर्णांकों का गुणनफल।\n\n@example\nnewModuloFactorial(3, 7); // 6 लौटाता है",
      "hu": "Ez a probléma egy új modulo műveletet vezet be, amelyet a '⊕' szimbólum jelöl.  \nAmikor az x ⊕ y értéket számítjuk, ha x nem osztható maradék nélkül y-nal, az eredmény x osztva y maradéka.  \nEllenkező esetben osszuk el x-et y-nal ismételten, amíg x már nem osztható maradék nélkül y-nal, és jelöljük a végső értéket x'-ként.  \nEkkor az eredmény x' osztva y maradéka.  \nPéldául, 4⊕5=4, 20⊕5=4, 100⊕5=4.  \nAdott egy prímszám p, több lekérdezés lesz. Minden lekérdezéshez adott egy egész szám n,  \nés ki kell számítani az n! ⊕ p értékét, ahol n! az n faktoriálisa,  \nazaz az összes n-nél kisebb vagy egyenlő pozitív egész szám szorzata.\n\n@example\nnewModuloFactorial(3, 7); // visszaadja a 6-ot"
    },
    "docstring_bertscore": {
      "sq": "0.9791432141001937",
      "hy": "0.9878223685995131",
      "bn": "0.9718028283690493",
      "bg": "0.9861932022142649",
      "zh": "0.9753956547012084",
      "fr": "0.9709578547281269",
      "de": "0.9797506258053983",
      "ha": "0.9491907457920377",
      "hi": "0.9662715681483708",
      "hu": "0.9453291725543385"
    }
  },
  {
    "task_id": "TypeScript/34",
    "prompt": {
      "en": "\n/**\n * You are given an array a of n integers. You can perform at most one operation where\n * you select three integers i, j, x (1 <= i <= j <= n) and replace all elements from a[i] to a[j]\n * with x, at a cost of (j - i + 1).\n * Find the minimum cost to make all elements in the array equal.\n */\nfunction makeEqualAgain(n: number, a: number[]): number {",
      "sq": "/**\n * Ju jepet një varg a me n numra të plotë. Ju mund të kryeni maksimumi një operacion ku\n * zgjidhni tre numra të plotë i, j, x (1 <= i <= j <= n) dhe zëvendësoni të gjitha elementet nga a[i] deri te a[j]\n * me x, me një kosto prej (j - i + 1).\n * Gjeni koston minimale për t'i bërë të gjitha elementet në varg të barabarta.\n */\nfunction makeEqualAgain(n: number, a: number[]): number {",
      "hy": "/**\n * Ձեզ տրված է n ամբողջ թվերի զանգված a։ Դուք կարող եք կատարել առավելագույնը մեկ գործողություն, որի ընթացքում\n * ընտրում եք երեք ամբողջ թվեր i, j, x (1 <= i <= j <= n) և փոխարինում a[i]-ից a[j] բոլոր տարրերը\n * x-ով, արժեքով (j - i + 1)։\n * Գտեք նվազագույն արժեքը, որպեսզի զանգվածի բոլոր տարրերը դառնան հավասար։\n */\nfunction makeEqualAgain(n: number, a: number[]): number {",
      "bn": "/**\n * আপনাকে n পূর্ণসংখ্যার একটি অ্যারে a দেওয়া হয়েছে। আপনি সর্বাধিক একটি অপারেশন করতে পারেন যেখানে\n * আপনি তিনটি পূর্ণসংখ্যা i, j, x (1 <= i <= j <= n) নির্বাচন করেন এবং a[i] থেকে a[j] পর্যন্ত সমস্ত উপাদানকে\n * x দিয়ে প্রতিস্থাপন করেন, যার খরচ (j - i + 1)।\n * অ্যারের সমস্ত উপাদান সমান করতে ন্যূনতম খরচ খুঁজে বের করুন।\n */\nfunction makeEqualAgain(n: number, a: number[]): number {",
      "bg": "/**\n * Даден е масив a от n цели числа. Можете да извършите най-много една операция, при която\n * избирате три цели числа i, j, x (1 <= i <= j <= n) и заменяте всички елементи от a[i] до a[j]\n * с x, на цена (j - i + 1).\n * Намерете минималната цена, за да направите всички елементи в масива равни.\n */\nfunction makeEqualAgain(n: number, a: number[]): number {",
      "zh": "/**\n * 给定一个包含 n 个整数的数组 a。你最多可以执行一次操作，\n * 选择三个整数 i, j, x (1 <= i <= j <= n)，并将从 a[i] 到 a[j] 的所有元素替换为 x，\n * 其代价为 (j - i + 1)。\n * 找出使数组中所有元素相等的最小代价。\n */\nfunction makeEqualAgain(n: number, a: number[]): number {",
      "fr": "/**\n * On vous donne un tableau a de n entiers. Vous pouvez effectuer au plus une opération où\n * vous sélectionnez trois entiers i, j, x (1 <= i <= j <= n) et remplacez tous les éléments de a[i] à a[j]\n * par x, à un coût de (j - i + 1).\n * Trouvez le coût minimum pour rendre tous les éléments du tableau égaux.\n */\nfunction makeEqualAgain(n: number, a: number[]): number {",
      "de": "/**\n * Sie haben ein Array a mit n ganzen Zahlen. Sie können höchstens eine Operation ausführen, bei der\n * Sie drei ganze Zahlen i, j, x (1 <= i <= j <= n) auswählen und alle Elemente von a[i] bis a[j]\n * durch x ersetzen, zu Kosten von (j - i + 1).\n * Finden Sie die minimalen Kosten, um alle Elemente im Array gleich zu machen.\n */\nfunction makeEqualAgain(n: number, a: number[]): number {",
      "ha": "/**\n * An ba ku wani array a na lambobi n. Kuna iya aiwatar da akalla aiki daya inda\n * za ku zaɓi lambobi uku i, j, x (1 <= i <= j <= n) kuma ku maye gurbin dukkan abubuwa daga a[i] zuwa a[j]\n * da x, a kan farashi na (j - i + 1).\n * Nemo mafi ƙarancin farashi don sanya duk abubuwan cikin array ɗin su zama daidai.\n */\nfunction makeEqualAgain(n: number, a: number[]): number {",
      "hi": "/**\n * आपको n पूर्णांकों की एक array a दी गई है। आप अधिकतम एक ऑपरेशन कर सकते हैं जहाँ\n * आप तीन पूर्णांक i, j, x (1 <= i <= j <= n) का चयन करते हैं और a[i] से a[j] तक के सभी तत्वों को\n * x से बदलते हैं, जिसकी लागत (j - i + 1) होती है।\n * सभी तत्वों को array में समान बनाने की न्यूनतम लागत खोजें।\n */\nfunction makeEqualAgain(n: number, a: number[]): number {",
      "hu": "/**\n * Adott egy n egész számot tartalmazó tömb, a. Legfeljebb egy műveletet hajthatsz végre, ahol\n * kiválasztasz három egész számot i, j, x (1 <= i <= j <= n), és az a[i] és a[j] közötti összes elemet\n * x-szel helyettesíted, (j - i + 1) költségen.\n * Találd meg a minimális költséget, hogy az összes elem a tömbben egyenlő legyen.\n */\nfunction makeEqualAgain(n: number, a: number[]): number {"
    },
    "prompt_bertscore": {
      "sq": "0.9956321179210428",
      "hy": "0.9401729264930537",
      "bn": "0.9941652325571002",
      "bg": "0.9871241828101754",
      "zh": "0.9596943203411625",
      "fr": "0.9986806970091663",
      "de": "0.9880188140463566",
      "ha": "0.9800749892176283",
      "hi": "0.9896751927938066",
      "hu": "0.978997816661276"
    },
    "canonical_solution": "let j = 0, p = 1, q = 0, c, d;\n  let k = n;\n  for (p = 1; p < k; p++) {\n      if (a[p] !== a[p - 1])\n          break;\n  }\n  for (q = k - 1; q > p; q--) {\n      if (a[q] !== a[p - 1])\n          break;\n  }\n  for (d = k - 2; d >= 0; d--) {\n      if (a[d] !== a[d + 1])\n          break;\n  }\n  for (c = 0; c < d; c++) {\n      if (a[c] !== a[c + 1])\n          break;\n  }\n  if (q - p + 1 < d - c + 1)\n      return q - p + 1;\n  else\n      return d - c + 1;\n};",
    "instruction": {
      "en": "Write a TypeScript function `function makeEqualAgain(n: number, a: number[]): number` to solve the following problem:\nYou are given an array a of n integers. You can perform at most one operation where\nyou select three integers i, j, x (1 <= i <= j <= n) and replace all elements from a[i] to a[j]\nwith x, at a cost of (j - i + 1).\nFind the minimum cost to make all elements in the array equal.",
      "sq": "Shkruani një funksion TypeScript `function makeEqualAgain(n: number, a: number[]): number` për të zgjidhur problemin e mëposhtëm:\nJu jepet një varg a me n numra të plotë. Ju mund të kryeni maksimumi një operacion ku\nzgjidhni tre numra të plotë i, j, x (1 <= i <= j <= n) dhe zëvendësoni të gjitha elementet nga a[i] në a[j]\nme x, me një kosto prej (j - i + 1).\nGjeni koston minimale për të bërë të gjitha elementet në varg të barabarta.",
      "hy": "Գրեք TypeScript ֆունկցիա `function makeEqualAgain(n: number, a: number[]): number`՝ հետևյալ խնդիրը լուծելու համար:\nՁեզ տրված է n ամբողջ թվերի զանգված a։ Դուք կարող եք կատարել առավելագույնը մեկ գործողություն, որտեղ\nընտրում եք երեք ամբողջ թիվ i, j, x (1 <= i <= j <= n) և փոխարինում a[i]-ից a[j]-ը բոլոր տարրերը x-ով, արժեքով (j - i + 1)։\nԳտեք նվազագույն արժեքը, որպեսզի զանգվածի բոլոր տարրերը հավասար լինեն։",
      "bn": "TypeScript ফাংশন `function makeEqualAgain(n: number, a: number[]): number` লিখুন নিম্নলিখিত সমস্যার সমাধানের জন্য:\nআপনাকে n পূর্ণসংখ্যার একটি অ্যারে a দেওয়া হয়েছে। আপনি সর্বাধিক একটি অপারেশন করতে পারেন যেখানে আপনি তিনটি পূর্ণসংখ্যা i, j, x (1 <= i <= j <= n) নির্বাচন করেন এবং a[i] থেকে a[j] পর্যন্ত সমস্ত উপাদানকে x দিয়ে প্রতিস্থাপন করেন, যার খরচ (j - i + 1)।\nঅ্যারের সমস্ত উপাদান সমান করতে ন্যূনতম খরচ খুঁজে বের করুন।",
      "bg": "Напишете TypeScript функция `function makeEqualAgain(n: number, a: number[]): number`, за да решите следния проблем:\nДаден ви е масив a от n цели числа. Можете да извършите най-много една операция, при която\nизбирате три цели числа i, j, x (1 <= i <= j <= n) и заменяте всички елементи от a[i] до a[j]\nс x, на цена (j - i + 1).\nНамерете минималната цена, за да направите всички елементи в масива равни.",
      "zh": "编写一个 TypeScript 函数 `function makeEqualAgain(n: number, a: number[]): number` 来解决以下问题：\n给定一个包含 n 个整数的数组 a。你可以最多执行一次操作，在该操作中你可以选择三个整数 i, j, x (1 <= i <= j <= n)，并将从 a[i] 到 a[j] 的所有元素替换为 x，代价为 (j - i + 1)。\n找出使数组中所有元素相等的最小代价。",
      "fr": "Écrivez une fonction TypeScript `function makeEqualAgain(n: number, a: number[]): number` pour résoudre le problème suivant :\nOn vous donne un tableau a de n entiers. Vous pouvez effectuer au plus une opération où\nvous sélectionnez trois entiers i, j, x (1 <= i <= j <= n) et remplacez tous les éléments de a[i] à a[j]\npar x, à un coût de (j - i + 1).\nTrouvez le coût minimum pour rendre tous les éléments du tableau égaux.",
      "de": "Schreiben Sie eine TypeScript-Funktion `function makeEqualAgain(n: number, a: number[]): number`, um das folgende Problem zu lösen:\nSie haben ein Array a mit n ganzen Zahlen. Sie können höchstens eine Operation durchführen, bei der\nSie drei ganze Zahlen i, j, x (1 <= i <= j <= n) auswählen und alle Elemente von a[i] bis a[j]\ndurch x ersetzen, zu Kosten von (j - i + 1).\nFinden Sie die minimalen Kosten, um alle Elemente im Array gleich zu machen.",
      "ha": "Rubuta aikin TypeScript `function makeEqualAgain(n: number, a: number[]): number` don warware matsalar mai zuwa:\nAn ba ku wani array a na lambobi n. Kuna iya yin aiki daya kawai inda\nza ku zaɓi lambobi uku i, j, x (1 <= i <= j <= n) kuma ku maye gurbin dukkan abubuwa daga a[i] zuwa a[j]\nda x, a kan farashin (j - i + 1).\nNemo mafi ƙarancin farashi don sanya duk abubuwan cikin array ɗin su zama daidai.",
      "hi": "TypeScript फ़ंक्शन `function makeEqualAgain(n: number, a: number[]): number` लिखें ताकि निम्नलिखित समस्या का समाधान किया जा सके:\nआपको n पूर्णांकों का एक array a दिया गया है। आप अधिकतम एक ऑपरेशन कर सकते हैं जहाँ\nआप तीन पूर्णांक i, j, x (1 <= i <= j <= n) का चयन करते हैं और a[i] से a[j] तक के सभी तत्वों को\nx से बदलते हैं, जिसकी लागत (j - i + 1) होती है।\nसभी तत्वों को array में समान बनाने के लिए न्यूनतम लागत खोजें।",
      "hu": "Írj egy TypeScript függvényt `function makeEqualAgain(n: number, a: number[]): number` a következő probléma megoldására:\nAdott egy a tömb n egész számmal. Legfeljebb egy műveletet hajthatsz végre, ahol kiválasztasz három egész számot i, j, x (1 <= i <= j <= n), és az a[i] és a[j] közötti összes elemet x-re cseréled, (j - i + 1) költséggel.\nTaláld meg a minimális költséget, hogy az összes elem a tömbben egyenlő legyen."
    },
    "instruction_bertscore": {
      "sq": "0.9956480083515256",
      "hy": "0.953599744359869",
      "bn": "0.9793434335242768",
      "bg": "0.9963668517004909",
      "zh": "0.9781651581039779",
      "fr": "0.9986481216266766",
      "de": "0.9894267061871319",
      "ha": "0.9777724658406719",
      "hi": "0.9798314683704795",
      "hu": "0.9784925009719233"
    },
    "level": "middle",
    "test": "function testMakeEqualAgain(): void {\n  console.assert(makeEqualAgain(6, [1, 2, 3, 4, 5, 1]) === 4);\n  console.assert(makeEqualAgain(7, [1, 1, 1, 1, 1, 1, 1]) === 0);\n  console.assert(makeEqualAgain(8, [8, 8, 8, 1, 2, 8, 8, 8]) === 2);\n  console.assert(makeEqualAgain(3, [1, 2, 3]) === 2);\n  console.assert(makeEqualAgain(7, [4, 3, 2, 7, 1, 1, 3]) === 6);\n  console.assert(makeEqualAgain(9, [9, 9, 2, 9, 2, 5, 5, 5, 3]) === 7);\n  \n  console.assert(makeEqualAgain(3, [1, 2, 1]) === 1);\n  console.assert(makeEqualAgain(5, [5, 5, 1, 5, 5]) === 1);\n  console.assert(makeEqualAgain(4, [1, 1, 1, 1]) === 0);\n  console.assert(makeEqualAgain(6, [2, 2, 2, 3, 2, 2]) === 1);\n  console.assert(makeEqualAgain(1, [1]) === 0);\n  console.assert(makeEqualAgain(2, [1, 2]) === 1);\n  console.assert(makeEqualAgain(4, [1, 2, 2, 1]) === 2);\n  console.assert(makeEqualAgain(7, [4, 4, 4, 3, 3, 4, 4]) === 2);\n  console.assert(makeEqualAgain(6, [5, 4, 4, 4, 5, 5]) === 3);\n  console.assert(makeEqualAgain(7, [1, 2, 1, 2, 1, 2, 1]) === 5);\n\n};\n\ntestMakeEqualAgain();",
    "entry_point": "makeEqualAgain",
    "signature": "function makeEqualAgain(n: number, a: number[]): number",
    "docstring": {
      "en": "You are given an array a of n integers. You can perform at most one operation where\nyou select three integers i, j, x (1 <= i <= j <= n) and replace all elements from a[i] to a[j]\nwith x, at a cost of (j - i + 1).\nFind the minimum cost to make all elements in the array equal.",
      "sq": "Ju jeni dhënë një varg a me n numra të plotë. Ju mund të kryeni maksimumi një operacion ku zgjidhni tre numra të plotë i, j, x (1 <= i <= j <= n) dhe zëvendësoni të gjitha elementet nga a[i] deri te a[j] me x, me një kosto prej (j - i + 1). Gjeni koston minimale për të bërë të gjithë elementet në varg të barabartë.",
      "hy": "Դուք ունեք n ամբողջ թվերից կազմված զանգված a։ Դուք կարող եք կատարել առավելագույնը մեկ գործողություն, որտեղ ընտրում եք երեք ամբողջ թիվ i, j, x (1 <= i <= j <= n) և փոխարինում եք a[i]-ից a[j]-ին բոլոր տարրերը x-ով՝ (j - i + 1) արժեքով։ \nԳտեք նվազագույն արժեքը, որպեսզի զանգվածի բոլոր տարրերը հավասարվեն։",
      "bn": "আপনাকে n পূর্ণসংখ্যার একটি অ্যারে a দেওয়া হয়েছে। আপনি সর্বাধিক একটি অপারেশন করতে পারেন যেখানে আপনি তিনটি পূর্ণসংখ্যা i, j, x (1 <= i <= j <= n) নির্বাচন করেন এবং a[i] থেকে a[j] পর্যন্ত সমস্ত উপাদান x দিয়ে প্রতিস্থাপন করেন, যার খরচ (j - i + 1) হয়। অ্যারের সমস্ত উপাদান সমান করতে ন্যূনতম খরচ খুঁজে বের করুন।",
      "bg": "Даден е масив a от n цели числа. Можете да извършите най-много една операция, при която избирате три цели числа i, j, x (1 <= i <= j <= n) и заменяте всички елементи от a[i] до a[j] с x, на цена (j - i + 1). Намерете минималната цена, за да направите всички елементи в масива равни.",
      "zh": "你有一个包含 n 个整数的数组 a。你最多可以执行一次操作，在该操作中你选择三个整数 i, j, x (1 <= i <= j <= n)，并将从 a[i] 到 a[j] 的所有元素替换为 x，代价为 (j - i + 1)。  \n找出使数组中所有元素相等的最低代价。",
      "fr": "Vous avez un tableau `a` de `n` entiers. Vous pouvez effectuer au plus une opération où vous sélectionnez trois entiers `i`, `j`, `x` (1 <= i <= j <= n) et remplacez tous les éléments de `a[i]` à `a[j]` par `x`, à un coût de `(j - i + 1)`. Trouvez le coût minimum pour rendre tous les éléments du tableau égaux.",
      "de": "Du hast ein Array a mit n ganzen Zahlen. Du kannst höchstens eine Operation durchführen, bei der du drei ganze Zahlen i, j, x (1 <= i <= j <= n) auswählst und alle Elemente von a[i] bis a[j] mit x ersetzt, zu Kosten von (j - i + 1).\nFinde die minimalen Kosten, um alle Elemente im Array gleich zu machen.",
      "ha": "An ba ku wani tsari a na n lambobi. Kuna iya aiwatar da mafi yawan aiki guda daya inda\nkuke zaɓar lambobi uku i, j, x (1 <= i <= j <= n) kuma ku maye gurbin dukkan abubuwa daga a[i] zuwa a[j]\nda x, a kan farashin (j - i + 1).\nNemo mafi ƙarancin farashi don sanya duk abubuwa a cikin tsari su zama daidai.",
      "hi": "आपको n पूर्णांकों की एक array a दी गई है। आप अधिकतम एक ऑपरेशन कर सकते हैं जहाँ आप तीन पूर्णांक i, j, x (1 <= i <= j <= n) का चयन करते हैं और a[i] से a[j] तक के सभी तत्वों को x से बदल देते हैं, जिसकी लागत (j - i + 1) होती है। सभी तत्वों को array में समान बनाने की न्यूनतम लागत खोजें।",
      "hu": "Önnek adott egy n egész számot tartalmazó a tömb. Legfeljebb egy műveletet hajthat végre, amely során kiválaszt három egész számot: i, j, x (1 <= i <= j <= n), és az a[i] és a[j] közötti összes elemet x-re cseréli, (j - i + 1) költséggel. \n\nKeresse meg a minimális költséget, hogy a tömb összes eleme egyenlő legyen."
    },
    "docstring_bertscore": {
      "sq": "0.9931416902036274",
      "hy": "0.9566342206909391",
      "bn": "0.9912167631810183",
      "bg": "0.9804106745615773",
      "zh": "0.9724595004087507",
      "fr": "0.8952395562168655",
      "de": "0.9778082193092581",
      "ha": "0.9708013339878714",
      "hi": "0.9867775727952696",
      "hu": "0.9701889565231409"
    }
  },
  {
    "task_id": "TypeScript/35",
    "prompt": {
      "en": "\n/**\n * Given a sequence of N piles of stones numbered from 1 to N, each containing a positive number of stones,\n * this function identifies the winner of a game played by Charlie and Dan. The game starts with Charlie,\n * and they alternate turns moving stones from the leftmost non-empty pile to the adjacent right pile.\n * Movement is done in positive numbers. The player forced to only move stones in the last pile loses.\n * Assuming optimal play, the function determines the winner.\n *\n * @example\n * gameWinner([3, 1, 2, 2]) // returns \"Dan\"\n */\nfunction gameWinner(piles: number[]): string",
      "sq": "/**\n * Duke pasur një sekuencë prej N grumbuj gurësh të numëruar nga 1 deri në N, secili që përmban një numër pozitiv gurësh,\n * kjo funksion identifikon fituesin e një loje të luajtur nga Charlie dhe Dan. Loja fillon me Charlie,\n * dhe ata ndërrojnë radhën duke lëvizur gurë nga grumbulli më i majtë jo-bosh në grumbullin ngjitur në të djathtë.\n * Lëvizja bëhet në numra pozitivë. Lojtari i detyruar të lëvizë gurë vetëm në grumbullin e fundit humbet.\n * Duke supozuar lojë optimale, funksioni përcakton fituesin.\n *\n * @example\n * gameWinner([3, 1, 2, 2]) // kthen \"Dan\"\n */\nfunction gameWinner(piles: number[]): string",
      "hy": "/**\n * Տրված է N քարերի կույտերի հաջորդականություն, որոնք համարակալված են 1-ից N, և յուրաքանչյուրում կա դրական թվով քարեր,\n * այս ֆունկցիան որոշում է խաղի հաղթողին, որը խաղում են Չարլին և Դենը։ Խաղը սկսում է Չարլին,\n * և նրանք հերթով տեղափոխում են քարերը ձախից աջ ամենամոտ դատարկ չեղած կույտից դեպի հարևան աջ կույտ։\n * Տեղափոխումը կատարվում է դրական թվերով։ Խաղացողը, որը ստիպված է միայն տեղափոխել քարերը վերջին կույտում, պարտվում է։\n * Ենթադրելով օպտիմալ խաղ, ֆունկցիան որոշում է հաղթողին։\n *\n * @example\n * gameWinner([3, 1, 2, 2]) // վերադարձնում է \"Dan\"\n */\nfunction gameWinner(piles: number[]): string",
      "bn": "/**\n * ১ থেকে N পর্যন্ত নম্বরযুক্ত N পাথরের স্তূপের একটি ক্রম দেওয়া হয়েছে, প্রতিটিতে একটি ধনাত্মক সংখ্যক পাথর রয়েছে,\n * এই ফাংশনটি চার্লি এবং ড্যান দ্বারা খেলা একটি গেমের বিজয়ীকে চিহ্নিত করে। গেমটি চার্লি দিয়ে শুরু হয়,\n * এবং তারা পালাক্রমে পালা করে বামদিকের প্রথম খালি না থাকা স্তূপ থেকে ডানদিকে সংলগ্ন স্তূপে পাথর সরায়।\n * স্থানান্তর ধনাত্মক সংখ্যায় করা হয়। যে খেলোয়াড়কে শুধুমাত্র শেষ স্তূপে পাথর সরাতে বাধ্য করা হয় সে হেরে যায়।\n * সর্বোত্তম খেলার অনুমান করে, ফাংশনটি বিজয়ী নির্ধারণ করে।\n *\n * @example\n * gameWinner([3, 1, 2, 2]) // \"Dan\" ফেরত দেয়\n */\nfunction gameWinner(piles: number[]): string",
      "bg": "/**\n * Дадена е последователност от N купчини камъни, номерирани от 1 до N, всяка съдържаща положителен брой камъни,\n * тази функция идентифицира победителя в игра, играна от Чарли и Дан. Играта започва с Чарли,\n * и те се редуват да преместват камъни от най-лявата непразна купчина към съседната дясна купчина.\n * Преместването се извършва с положителни числа. Играчът, принуден да премества камъни само в последната купчина, губи.\n * Приемайки оптимална игра, функцията определя победителя.\n *\n * @example\n * gameWinner([3, 1, 2, 2]) // връща \"Dan\"\n */\nfunction gameWinner(piles: number[]): string",
      "zh": "/**\n * 给定一个编号从1到N的石堆序列，每堆包含一个正数的石头，\n * 此函数用于识别由Charlie和Dan进行的游戏的获胜者。游戏由Charlie开始，\n * 他们轮流将石头从最左边的非空堆移动到相邻的右边堆。\n * 移动以正数进行。被迫只能在最后一堆移动石头的玩家输掉游戏。\n * 假设最佳玩法，函数确定获胜者。\n *\n * @example\n * gameWinner([3, 1, 2, 2]) // returns \"Dan\"\n */\nfunction gameWinner(piles: number[]): string",
      "fr": "/**\n * Étant donné une séquence de N tas de pierres numérotés de 1 à N, chacun contenant un nombre positif de pierres,\n * cette fonction identifie le gagnant d'un jeu joué par Charlie et Dan. Le jeu commence avec Charlie,\n * et ils alternent les tours en déplaçant des pierres du tas non vide le plus à gauche vers le tas adjacent à droite.\n * Le mouvement se fait en nombres positifs. Le joueur forcé de ne déplacer des pierres que dans le dernier tas perd.\n * En supposant un jeu optimal, la fonction détermine le gagnant.\n *\n * @example\n * gameWinner([3, 1, 2, 2]) // returns \"Dan\"\n */\nfunction gameWinner(piles: number[]): string",
      "de": "/**\n * Gegeben eine Sequenz von N Steinhaufen, nummeriert von 1 bis N, die jeweils eine positive Anzahl von Steinen enthalten,\n * identifiziert diese Funktion den Gewinner eines Spiels, das von Charlie und Dan gespielt wird. Das Spiel beginnt mit Charlie,\n * und sie wechseln sich ab, indem sie Steine vom linken, nicht leeren Haufen zum benachbarten rechten Haufen bewegen.\n * Die Bewegung erfolgt in positiven Zahlen. Der Spieler, der gezwungen ist, nur Steine im letzten Haufen zu bewegen, verliert.\n * Bei optimalem Spiel bestimmt die Funktion den Gewinner.\n *\n * @example\n * gameWinner([3, 1, 2, 2]) // gibt \"Dan\" zurück\n */\nfunction gameWinner(piles: number[]): string",
      "ha": "/**\n * An ba da jerin N na tarin duwatsu da aka lamba daga 1 zuwa N, kowanne yana dauke da adadi mai kyau na duwatsu,\n * wannan aikin yana gano wanda ya lashe wasa da Charlie da Dan suka buga. Wasa yana farawa da Charlie,\n * kuma suna juyawa suna motsa duwatsu daga mafi hagu wanda ba komai ba zuwa tarin dama kusa.\n * Motsawa ana yin sa ne da adadi mai kyau. Dan wasan da aka tilasta ya motsa duwatsu kawai a cikin tarin karshe ya yi rashin nasara.\n * Idan aka dauki wasa mai kyau, aikin yana tantance wanda ya yi nasara.\n *\n * @example\n * gameWinner([3, 1, 2, 2]) // returns \"Dan\"\n */\nfunction gameWinner(piles: number[]): string",
      "hi": "/**\n * 1 से N तक क्रमांकित पत्थरों के N ढेरों की एक अनुक्रमणिका दी गई है, प्रत्येक में कुछ सकारात्मक संख्या में पत्थर हैं,\n * यह फ़ंक्शन चार्ली और डैन द्वारा खेले गए खेल के विजेता की पहचान करता है। खेल चार्ली से शुरू होता है,\n * और वे बारी-बारी से बाएं से दाएं सबसे निकटतम गैर-खाली ढेर से पत्थरों को दाएं सटे ढेर में स्थानांतरित करते हैं।\n * स्थानांतरण सकारात्मक संख्याओं में किया जाता है। जिस खिलाड़ी को केवल अंतिम ढेर में पत्थर स्थानांतरित करने के लिए मजबूर किया जाता है, वह हार जाता है।\n * इष्टतम खेल को मानते हुए, फ़ंक्शन विजेता का निर्धारण करता है।\n *\n * @example\n * gameWinner([3, 1, 2, 2]) // \"Dan\" लौटाता है\n */\nfunction gameWinner(piles: number[]): string",
      "hu": "/**\n * Adott egy N kövekből álló halom sorozat, amelyeket 1-től N-ig számoztak, mindegyik pozitív számú követ tartalmaz,\n * ez a függvény meghatározza a Charlie és Dan által játszott játék nyertesét. A játékot Charlie kezdi,\n * és felváltva mozgatják a köveket a bal szélső nem üres halomból a szomszédos jobb halomba.\n * A mozgatás pozitív számokkal történik. Az a játékos, akit arra kényszerítenek, hogy csak az utolsó halomban mozgasson köveket, veszít.\n * Feltételezve az optimális játékot, a függvény meghatározza a nyertest.\n *\n * @példa\n * gameWinner([3, 1, 2, 2]) // visszaadja \"Dan\"\n */\nfunction gameWinner(piles: number[]): string"
    },
    "prompt_bertscore": {
      "sq": "0.976588628769704",
      "hy": "0.971391067589164",
      "bn": "0.9558518156200426",
      "bg": "0.9763492791605569",
      "zh": "0.9684263105218373",
      "fr": "0.9771714103076603",
      "de": "0.9777208219416028",
      "ha": "0.9595932174772158",
      "hi": "0.9332748906204742",
      "hu": "0.9639046885279591"
    },
    "canonical_solution": "{\n    const n = piles.length;\n    const firstPileStones = piles[0];\n    \n    // With only two piles, Charlie always wins.\n    if (n === 2) {\n        return \"Charlie\";\n    }\n    // If the first pile has only one stone, Dan wins.\n    if (firstPileStones === 1) {\n        return \"Dan\";\n    }\n    // In all other cases, Charlie wins.\n    return \"Charlie\";\n}",
    "instruction": {
      "en": "Write a TypeScript function `function gameWinner(piles: number[]): string` to solve the following problem:\nGiven a sequence of N piles of stones numbered from 1 to N, each containing a positive number of stones,\nthis function identifies the winner of a game played by Charlie and Dan. The game starts with Charlie,\nand they alternate turns moving stones from the leftmost non-empty pile to the adjacent right pile.\nMovement is done in positive numbers. The player forced to only move stones in the last pile loses.\nAssuming optimal play, the function determines the winner.\n\n@example\ngameWinner([3, 1, 2, 2]) // returns \"Dan\"\n",
      "sq": "Shkruani një funksion TypeScript `function gameWinner(piles: number[]): string` për të zgjidhur problemin e mëposhtëm:\nDuke pasur një sekuencë prej N pirgjesh gurësh të numëruara nga 1 deri në N, secila që përmban një numër pozitiv gurësh,\nky funksion identifikon fituesin e një loje të luajtur nga Charlie dhe Dan. Loja fillon me Charlie,\ndhe ata alternojnë radhën duke lëvizur gurë nga pirgu më i majtë jo-bosh në pirgun ngjitur në të djathtë.\nLëvizja bëhet me numra pozitivë. Lojtari i detyruar të lëvizë gurë vetëm në pirgun e fundit humbet.\nDuke supozuar lojë optimale, funksioni përcakton fituesin.\n\n@example\ngameWinner([3, 1, 2, 2]) // returns \"Dan\"",
      "hy": "Գրեք TypeScript ֆունկցիա `function gameWinner(piles: number[]): string`՝ հետևյալ խնդիրը լուծելու համար:\nՏրված է N քարերի կույտերի հաջորդականություն, որոնք համարակալված են 1-ից N, և յուրաքանչյուրում կա դրական թվով քարեր,\nայս ֆունկցիան որոշում է խաղի հաղթողին, որը խաղում են Չարլին և Դանը: Խաղը սկսում է Չարլին,\nև նրանք հերթով տեղափոխում են քարերը ձախից աջ ամենամոտ չդատարկ կույտից դեպի հարևան աջ կույտ:\nՏեղափոխությունը կատարվում է դրական թվերով: Խաղացողը, որը ստիպված է միայն տեղափոխել քարերը վերջին կույտում, պարտվում է:\nԵնթադրելով օպտիմալ խաղ, ֆունկցիան որոշում է հաղթողին:\n\n@example\ngameWinner([3, 1, 2, 2]) // վերադարձնում է \"Dan\"",
      "bn": "TypeScript ফাংশন `function gameWinner(piles: number[]): string` লিখুন নিম্নলিখিত সমস্যার সমাধানের জন্য:\nধরা যাক N সংখ্যক পাথরের স্তূপের একটি ক্রম আছে, যা 1 থেকে N পর্যন্ত নম্বরযুক্ত, প্রতিটিতে একটি পজিটিভ সংখ্যক পাথর রয়েছে,\nএই ফাংশনটি চার্লি এবং ড্যান দ্বারা খেলা একটি গেমের বিজয়ীকে চিহ্নিত করে। গেমটি চার্লি দিয়ে শুরু হয়,\nএবং তারা পালাক্রমে পালা করে পাথরগুলিকে বামদিকের প্রথম খালি নয় এমন স্তূপ থেকে ডানপাশের সংলগ্ন স্তূপে সরায়।\nচলাচল পজিটিভ সংখ্যায় করা হয়। যে খেলোয়াড়কে শুধুমাত্র শেষ স্তূপে পাথর সরাতে বাধ্য করা হয় সে হেরে যায়।\nসর্বোত্তম খেলার অনুমান করে, ফাংশনটি বিজয়ীকে নির্ধারণ করে।\n\n@example\ngameWinner([3, 1, 2, 2]) // returns \"Dan\"",
      "bg": "Напишете функция на TypeScript `function gameWinner(piles: number[]): string`, за да решите следния проблем:\nДадена е последователност от N купчини камъни, номерирани от 1 до N, всяка съдържаща положителен брой камъни,\nтази функция идентифицира победителя в игра, играна от Чарли и Дан. Играта започва с Чарли,\nи те се редуват да преместват камъни от най-лявата непразна купчина към съседната дясна купчина.\nПреместването се извършва с положителни числа. Играчът, принуден да премества камъни само в последната купчина, губи.\nПриемайки оптимална игра, функцията определя победителя.\n\n@example\ngameWinner([3, 1, 2, 2]) // връща \"Dan\"",
      "zh": "编写一个 TypeScript 函数 `function gameWinner(piles: number[]): string` 来解决以下问题：\n给定一个从 1 到 N 编号的 N 堆石头的序列，每堆包含一个正数的石头，\n此函数识别由 Charlie 和 Dan 玩的游戏的获胜者。游戏由 Charlie 开始，\n他们轮流将石头从最左边的非空堆移动到相邻的右边堆。\n移动是以正数进行的。被迫只能在最后一堆移动石头的玩家输掉比赛。\n假设最佳玩法，函数确定获胜者。\n\n@example\ngameWinner([3, 1, 2, 2]) // returns \"Dan\"",
      "fr": "Écrire une fonction TypeScript `function gameWinner(piles: number[]): string` pour résoudre le problème suivant :\nÉtant donné une séquence de N piles de pierres numérotées de 1 à N, chacune contenant un nombre positif de pierres,\ncette fonction identifie le gagnant d'un jeu joué par Charlie et Dan. Le jeu commence avec Charlie,\net ils alternent les tours en déplaçant des pierres de la pile la plus à gauche non vide vers la pile adjacente à droite.\nLe mouvement se fait en nombres positifs. Le joueur contraint de ne déplacer des pierres que dans la dernière pile perd.\nEn supposant un jeu optimal, la fonction détermine le gagnant.\n\n@example\ngameWinner([3, 1, 2, 2]) // returns \"Dan\"",
      "de": "Schreiben Sie eine TypeScript-Funktion `function gameWinner(piles: number[]): string`, um das folgende Problem zu lösen:\nGegeben ist eine Sequenz von N Steinhaufen, nummeriert von 1 bis N, wobei jeder Haufen eine positive Anzahl von Steinen enthält. Diese Funktion identifiziert den Gewinner eines Spiels, das von Charlie und Dan gespielt wird. Das Spiel beginnt mit Charlie, und sie wechseln sich ab, indem sie Steine vom linken, nicht leeren Haufen zum angrenzenden rechten Haufen bewegen. Die Bewegung erfolgt in positiven Zahlen. Der Spieler, der gezwungen ist, nur Steine im letzten Haufen zu bewegen, verliert. Bei optimalem Spiel bestimmt die Funktion den Gewinner.\n\n@example\ngameWinner([3, 1, 2, 2]) // gibt \"Dan\" zurück",
      "ha": "Rubuta aikin TypeScript `function gameWinner(piles: number[]): string` don warware matsalar mai zuwa:\nAn ba da jerin N na tarin duwatsu da aka lamba daga 1 zuwa N, kowanne yana dauke da adadi mai kyau na duwatsu,\nwannan aikin yana gano wanda ya yi nasara a wasan da Charlie da Dan suka buga. Wasan yana farawa da Charlie,\nkuma suna yin juyin juya hali suna motsa duwatsu daga tarin da ba komai a hagu zuwa tarin da ke kusa da dama.\nAna yin motsi a cikin lambobi masu kyau. Dan wasan da aka tilasta kawai ya motsa duwatsu a cikin tarin karshe ya yi rashin nasara.\nIdan ana tsammanin wasa mai kyau, aikin yana tantance wanda ya yi nasara.\n\n@example\ngameWinner([3, 1, 2, 2]) // returns \"Dan\"",
      "hi": "TypeScript फ़ंक्शन `function gameWinner(piles: number[]): string` लिखें ताकि निम्नलिखित समस्या का समाधान किया जा सके:\nदिए गए पत्थरों के N ढेरों की एक अनुक्रमणिका, जो 1 से N तक क्रमांकित हैं, और प्रत्येक में पत्थरों की एक सकारात्मक संख्या है,\nयह फ़ंक्शन एक खेल के विजेता की पहचान करता है जो चार्ली और डैन द्वारा खेला जाता है। खेल की शुरुआत चार्ली से होती है,\nऔर वे बारी-बारी से बाएँ से दाएँ सबसे निकटतम खाली न होने वाले ढेर से पत्थरों को दाएँ के निकटतम ढेर में ले जाते हैं।\nगति सकारात्मक संख्याओं में की जाती है। खिलाड़ी जिसे केवल अंतिम ढेर में पत्थरों को ले जाना पड़ता है, हार जाता है।\nसर्वोत्तम खेल मानते हुए, फ़ंक्शन विजेता का निर्धारण करता है।\n\n@example\ngameWinner([3, 1, 2, 2]) // \"Dan\" लौटाता है",
      "hu": "Írj egy TypeScript függvényt `function gameWinner(piles: number[]): string` a következő probléma megoldására:\nAdott egy N kövekből álló halom sorozat, amelyeket 1-től N-ig számoztak, mindegyik pozitív számú követ tartalmaz,\nez a függvény azonosítja a győztest egy játékban, amelyet Charlie és Dan játszik. A játék Charlie-val kezdődik,\nés felváltva mozgatják a köveket a bal oldali nem üres halomból a szomszédos jobb halomba.\nA mozgatás pozitív számokkal történik. Az a játékos veszít, akit arra kényszerítenek, hogy csak az utolsó halomban mozgassa a köveket.\nFeltételezve az optimális játékot, a függvény meghatározza a győztest.\n\n@example\ngameWinner([3, 1, 2, 2]) // returns \"Dan\""
    },
    "instruction_bertscore": {
      "sq": "0.9746217907366965",
      "hy": "0.9717776023106579",
      "bn": "0.9497919999554303",
      "bg": "0.9782829459199316",
      "zh": "0.9671685829491243",
      "fr": "0.9781280142227243",
      "de": "0.962093576713683",
      "ha": "0.9586310519114828",
      "hi": "0.934031275111455",
      "hu": "0.9630191942893056"
    },
    "level": "middle",
    "test": "(() => {\n    console.assert(gameWinner([1, 2, 2]) === \"Dan\", \"Test 1 failed\");\n    console.assert(gameWinner([5, 5, 5, 5, 5]) === \"Charlie\", \"Test 2 failed\");\n    console.assert(gameWinner([2, 1, 2]) === \"Charlie\", \"Test 3 failed\");\n    console.assert(gameWinner([3, 3, 3, 3]) === \"Charlie\", \"Test 4 failed\");\n    console.assert(gameWinner([1, 1]) === \"Charlie\", \"Test 5 failed\");\n    console.assert(gameWinner([2, 1]) === \"Charlie\", \"Test 6 failed\");\n    console.assert(gameWinner([1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1]) === \"Dan\", \"Test 7 failed\");\n    console.assert(gameWinner([2, 2, 2, 2, 2, 2, 2, 2, 2, 1]) === \"Charlie\", \"Test 8 failed\");\n    console.assert(gameWinner([10, 10, 10, 10, 10, 10, 10, 10, 10, 10]) === \"Charlie\", \"Test 9 failed\");\n    console.assert(gameWinner([1, 2, 3, 4, 5, 6, 7, 8, 9, 10]) === \"Dan\", \"Test 10 failed\");\n})();",
    "entry_point": "gameWinner",
    "signature": "function gameWinner(piles: number[]): string",
    "docstring": {
      "en": "Given a sequence of N piles of stones numbered from 1 to N, each containing a positive number of stones,\nthis function identifies the winner of a game played by Charlie and Dan. The game starts with Charlie,\nand they alternate turns moving stones from the leftmost non-empty pile to the adjacent right pile.\nMovement is done in positive numbers. The player forced to only move stones in the last pile loses.\nAssuming optimal play, the function determines the winner.\n\n@example\ngameWinner([3, 1, 2, 2]) // returns \"Dan\"\n",
      "sq": "Duke pasur një sekuencë prej N grumbuj gurësh të numëruar nga 1 deri në N, secili që përmban një numër pozitiv gurësh, kjo funksion identifikon fituesin e një loje të luajtur nga Charlie dhe Dan. Loja fillon me Charlie, dhe ata alternojnë radhët duke lëvizur gurë nga grumbulli më i majtë jo bosh në grumbullin ngjitur në të djathtë. Lëvizja bëhet me numra pozitivë. Lojtari i detyruar të lëvizë gurë vetëm në grumbullin e fundit humbet. Duke supozuar lojë optimale, funksioni përcakton fituesin.\n\n@example\ngameWinner([3, 1, 2, 2]) // kthen \"Dan\"",
      "hy": "Տրված է N քարերի կույտերի հաջորդականություն, որոնք համարակալված են 1-ից N, և որոնցից յուրաքանչյուրը պարունակում է դրական թվով քարեր, \nայս ֆունկցիան որոշում է խաղի հաղթողին, որը խաղում են Չարլին և Դենը: Խաղը սկսում է Չարլին, \nև նրանք հերթափոխով տեղափոխում են քարերը ձախից ամենաառաջին ոչ դատարկ կույտից դեպի հարևան աջ կույտ: \nՏեղափոխումը կատարվում է դրական թվերով: Խաղացողը, որը ստիպված է տեղափոխել քարեր միայն վերջին կույտում, պարտվում է: \nԵնթադրելով օպտիմալ խաղ, ֆունկցիան որոշում է հաղթողին:\n\n@example\ngameWinner([3, 1, 2, 2]) // վերադարձնում է \"Dan\"",
      "bn": "একটি ক্রমে ১ থেকে N পর্যন্ত নম্বরযুক্ত Nটি পাথরের স্তূপ দেওয়া আছে, প্রতিটি স্তূপে একটি ধনাত্মক সংখ্যা পাথর রয়েছে, এই ফাংশনটি চার্লি এবং ড্যান দ্বারা খেলা একটি গেমের বিজয়ী নির্ধারণ করে। গেমটি চার্লি দিয়ে শুরু হয়, এবং তারা পালাক্রমে বাঁ দিকের প্রথম খালি না থাকা স্তূপ থেকে ডান পাশের সংলগ্ন স্তূপে পাথর সরানোর পালা নেয়। স্থানান্তর ধনাত্মক সংখ্যায় করা হয়। যে খেলোয়াড়কে শুধুমাত্র শেষ স্তূপে পাথর সরাতে বাধ্য করা হয়, সে হেরে যায়। সর্বোত্তম খেলার ধরণ ধরে নিয়ে, ফাংশনটি বিজয়ী নির্ধারণ করে।\n\n@example\ngameWinner([3, 1, 2, 2]) // \"Dan\" ফেরত দেয়",
      "bg": "Дадена е последователност от N купчини камъни, номерирани от 1 до N, всяка съдържаща положителен брой камъни, тази функция идентифицира победителя в игра, играна от Чарли и Дан. Играта започва с Чарли и те се редуват да местят камъни от най-лявата непразна купчина към съседната дясна купчина. Преместването се извършва в положителни числа. Играчът, който е принуден да мести камъни само в последната купчина, губи. Приемайки оптимална игра, функцията определя победителя.\n\n@example\ngameWinner([3, 1, 2, 2]) // връща \"Dan\"",
      "zh": "给定一个编号从1到N的石堆序列，每堆包含一个正数的石头，这个函数识别由Charlie和Dan玩的游戏的获胜者。游戏由Charlie开始，他们轮流将石头从最左边的非空堆移动到相邻的右边堆。移动以正数进行。被迫只能在最后一堆移动石头的玩家输掉比赛。假设最优游戏策略，函数确定获胜者。\n\n@example\ngameWinner([3, 1, 2, 2]) // returns \"Dan\"",
      "fr": "Étant donné une séquence de N piles de pierres numérotées de 1 à N, chacune contenant un nombre positif de pierres, cette fonction identifie le gagnant d'un jeu joué par Charlie et Dan. Le jeu commence avec Charlie, et ils alternent les tours en déplaçant des pierres de la pile non vide la plus à gauche vers la pile adjacente à droite. Le mouvement se fait en nombres positifs. Le joueur contraint de ne déplacer des pierres que dans la dernière pile perd. En supposant un jeu optimal, la fonction détermine le gagnant.\n\n@example\ngameWinner([3, 1, 2, 2]) // retourne \"Dan\"",
      "de": "Given a sequence of N piles of stones numbered from 1 to N, each containing a positive number of stones, this function identifies the winner of a game played by Charlie and Dan. The game starts with Charlie, and they alternate turns moving stones from the leftmost non-empty pile to the adjacent right pile. Movement is done in positive numbers. The player forced to only move stones in the last pile loses. Assuming optimal play, the function determines the winner.\n\n@Beispiel\ngameWinner([3, 1, 2, 2]) // gibt \"Dan\" zurück",
      "ha": "Given a sequence of N piles of stones numbered from 1 to N, each containing a positive number of stones, this function identifies the winner of a game played by Charlie and Dan. The game starts with Charlie, and they alternate turns moving stones from the leftmost non-empty pile to the adjacent right pile. Movement is done in positive numbers. The player forced to only move stones in the last pile loses. Assuming optimal play, the function determines the winner.\n\n@example\ngameWinner([3, 1, 2, 2]) // returns \"Dan\"",
      "hi": "एक अनुक्रम में N पत्थरों के ढेर दिए गए हैं, जिन्हें 1 से N तक क्रमांकित किया गया है, प्रत्येक में सकारात्मक संख्या में पत्थर होते हैं, यह फ़ंक्शन चार्ली और डैन द्वारा खेले गए खेल के विजेता की पहचान करता है। खेल की शुरुआत चार्ली से होती है, और वे बारी-बारी से पत्थरों को बाईं ओर के सबसे पहले गैर-खाली ढेर से सटे हुए दाईं ढेर में ले जाते हैं। पत्थरों का स्थानांतरण सकारात्मक संख्या में किया जाता है। जिस खिलाड़ी को केवल अंतिम ढेर में पत्थरों को स्थानांतरित करने के लिए मजबूर किया जाता है, वह हार जाता है। इष्टतम खेल को मानते हुए, यह फ़ंक्शन विजेता का निर्धारण करता है।\n\n@example\ngameWinner([3, 1, 2, 2]) // \"Dan\" लौटाता है",
      "hu": "Adott egy N számú kőhalomból álló sorozat, amelyeket 1-től N-ig számoztak, és mindegyik pozitív számú követ tartalmaz. Ez a függvény azonosítja a Charlie és Dan által játszott játék győztesét. A játék Charlie-val kezdődik, és felváltva mozgatják a köveket a legbaloldalibb nem üres halomból a szomszédos jobb oldali halomba. A mozgatás pozitív számokban történik. Az a játékos veszít, akit arra kényszerítenek, hogy csak az utolsó halomban mozgasson köveket. Feltételezve az optimális játékot, a függvény meghatározza a győztest.\n\n@example\ngameWinner([3, 1, 2, 2]) // visszaadja \"Dan\""
    },
    "docstring_bertscore": {
      "sq": "0.9730097065642174",
      "hy": "0.9622095768562073",
      "bn": "0.9329999861731219",
      "bg": "0.9707194982708851",
      "zh": "0.9682550911333853",
      "fr": "0.9787846862624257",
      "de": "0.9999996027392379",
      "ha": "0.9999996027392379",
      "hi": "0.9488578412734232",
      "hu": "0.9651943955920186"
    }
  },
  {
    "task_id": "TypeScript/36",
    "prompt": {
      "en": "\n/**\n * Given n doors arranged in a circle, the player starts in front of door 1.\n * Each turn, the player can choose a number i and pay a cost C_i to move i steps\n * to the right and then open the door at that position. It is guaranteed that\n * C_i >= C_{i+1} for 1 <= i < n.\n * The task is to determine the minimum total cost required to open all doors.\n *\n * Example:\n *     > minTotalCost(3, [1, 1, 1])\n *     3\n */\nfunction minTotalCost(n: number, C: number[]): number",
      "sq": "/**\n * Duke pasur n dyer të radhitura në një rreth, lojtari fillon përballë derës 1.\n * Çdo radhë, lojtari mund të zgjedhë një numër i dhe të paguajë një kosto C_i për të lëvizur i hapa\n * djathtas dhe pastaj të hapë derën në atë pozicion. Është e garantuar që\n * C_i >= C_{i+1} për 1 <= i < n.\n * Detyra është të përcaktohet kostoja totale minimale e nevojshme për të hapur të gjitha dyert.\n *\n * Shembull:\n *     > minTotalCost(3, [1, 1, 1])\n *     3\n */\nfunction minTotalCost(n: number, C: number[]): number",
      "hy": "/**\n * Տրված է n դռներ, որոնք դասավորված են շրջանաձև, խաղացողը սկսում է դուռ 1-ի դիմաց:\n * Յուրաքանչյուր քայլի ժամանակ, խաղացողը կարող է ընտրել թիվ i և վճարել արժեք C_i՝\n * i քայլ աջ շարժվելու և այն դիրքում գտնվող դուռը բացելու համար: Երաշխավորված է, որ\n * C_i >= C_{i+1} 1 <= i < n-ի համար:\n * Խնդիրը կայանում է որոշել բոլոր դռները բացելու համար պահանջվող նվազագույն ընդհանուր արժեքը:\n *\n * Օրինակ:\n *     > minTotalCost(3, [1, 1, 1])\n *     3\n */\nfunction minTotalCost(n: number, C: number[]): number",
      "bn": "/**\n * একটি বৃত্তে সাজানো n টি দরজা দেওয়া আছে, খেলোয়াড় দরজা 1 এর সামনে শুরু করে।\n * প্রতিটি পালায়, খেলোয়াড় একটি সংখ্যা i বেছে নিতে পারে এবং i ধাপ ডানে যাওয়ার জন্য একটি খরচ C_i প্রদান করতে পারে\n * এবং তারপর সেই অবস্থানে দরজা খুলতে পারে। এটি নিশ্চিত যে\n * C_i >= C_{i+1} যেখানে 1 <= i < n।\n * কাজটি হল সমস্ত দরজা খোলার জন্য প্রয়োজনীয় সর্বনিম্ন মোট খরচ নির্ধারণ করা।\n *\n * উদাহরণ:\n *     > minTotalCost(3, [1, 1, 1])\n *     3\n */ \nfunction minTotalCost(n: number, C: number[]): number",
      "bg": "/**\n * Дадени са n врати, подредени в кръг, играчът започва пред врата 1.\n * Всеки ход, играчът може да избере число i и да плати цена C_i, за да се премести i стъпки\n * надясно и след това да отвори вратата на тази позиция. Гарантирано е, че\n * C_i >= C_{i+1} за 1 <= i < n.\n * Задачата е да се определи минималната обща цена, необходима за отваряне на всички врати.\n *\n * Пример:\n *     > minTotalCost(3, [1, 1, 1])\n *     3\n */ \nfunction minTotalCost(n: number, C: number[]): number",
      "zh": "/**\n * 给定 n 扇门排列成一个圆圈，玩家从门 1 前面开始。\n * 每回合，玩家可以选择一个数字 i 并支付一个代价 C_i 向右移动 i 步，\n * 然后打开该位置的门。保证 C_i >= C_{i+1} 对于 1 <= i < n。\n * 任务是确定打开所有门所需的最小总成本。\n *\n * 示例:\n *     > minTotalCost(3, [1, 1, 1])\n *     3\n */\nfunction minTotalCost(n: number, C: number[]): number",
      "fr": "/**\n * Étant donné n portes disposées en cercle, le joueur commence devant la porte 1.\n * À chaque tour, le joueur peut choisir un nombre i et payer un coût C_i pour avancer de i pas\n * vers la droite puis ouvrir la porte à cette position. Il est garanti que\n * C_i >= C_{i+1} pour 1 <= i < n.\n * La tâche consiste à déterminer le coût total minimum nécessaire pour ouvrir toutes les portes.\n *\n * Exemple :\n *     > minTotalCost(3, [1, 1, 1])\n *     3\n */\nfunction minTotalCost(n: number, C: number[]): number",
      "de": "/**\n * Gegeben sind n Türen, die in einem Kreis angeordnet sind, beginnt der Spieler vor Tür 1.\n * In jedem Zug kann der Spieler eine Zahl i wählen und einen Kosten C_i zahlen, um i Schritte\n * nach rechts zu gehen und dann die Tür an dieser Position zu öffnen. Es ist garantiert, dass\n * C_i >= C_{i+1} für 1 <= i < n.\n * Die Aufgabe besteht darin, die minimalen Gesamtkosten zu bestimmen, die erforderlich sind, um alle Türen zu öffnen.\n *\n * Beispiel:\n *     > minTotalCost(3, [1, 1, 1])\n *     3\n */",
      "ha": "/**\n * An ba n ƙofofi da aka shirya a cikin da'ira, ɗan wasa yana farawa a gaban ƙofa ta 1.\n * Kowace juyawa, ɗan wasa zai iya zaɓar lamba i kuma ya biya farashi C_i don matsawa matakai i\n * zuwa dama sannan ya buɗe ƙofar a wannan matsayi. An tabbatar da cewa\n * C_i >= C_{i+1} don 1 <= i < n.\n * Aikin shi ne tantance mafi ƙarancin jimillar farashi da ake buƙata don buɗe duk ƙofofi.\n *\n * Misali:\n *     > minTotalCost(3, [1, 1, 1])\n *     3\n */\nfunction minTotalCost(n: number, C: number[]): number",
      "hi": "/**\n * दिए गए n दरवाजे जो एक वृत्त में व्यवस्थित हैं, खिलाड़ी दरवाजा 1 के सामने से शुरू करता है।\n * प्रत्येक चाल में, खिलाड़ी एक संख्या i चुन सकता है और i कदम दाईं ओर जाने के लिए एक लागत C_i का भुगतान कर सकता है \n * और फिर उस स्थिति पर दरवाजा खोल सकता है। यह सुनिश्चित है कि \n * C_i >= C_{i+1} जहाँ 1 <= i < n।\n * कार्य यह निर्धारित करना है कि सभी दरवाजे खोलने के लिए न्यूनतम कुल लागत क्या होगी।\n *\n * उदाहरण:\n *     > minTotalCost(3, [1, 1, 1])\n *     3\n */\nfunction minTotalCost(n: number, C: number[]): number",
      "hu": "/**\n * Adott n ajtó, amelyek körben vannak elrendezve, a játékos az 1-es ajtó előtt kezd.\n * Minden körben a játékos választhat egy számot i, és fizethet egy C_i költséget, hogy i lépést\n * jobbra lépjen, majd kinyissa az adott pozíción lévő ajtót. Garantált, hogy\n * C_i >= C_{i+1} minden 1 <= i < n esetén.\n * A feladat annak meghatározása, hogy mi a minimális összköltség az összes ajtó kinyitásához.\n *\n * Példa:\n *     > minTotalCost(3, [1, 1, 1])\n *     3\n */\nfunction minTotalCost(n: number, C: number[]): number"
    },
    "prompt_bertscore": {
      "sq": "0.9944530479792197",
      "hy": "0.9770424991903687",
      "bn": "0.9719001572557564",
      "bg": "0.9977868602945092",
      "zh": "0.9922722850258376",
      "fr": "0.9977868602945092",
      "de": "0.9461435571165815",
      "ha": "0.9869851415434511",
      "hi": "0.9679325153945846",
      "hu": "0.9782134252865693"
    },
    "canonical_solution": "{\n   return C[n-2] * (n - 1) + C[n-1];\n}",
    "instruction": {
      "en": "Write a TypeScript function `function minTotalCost(n: number, C: number[]): number` to solve the following problem:\nGiven n doors arranged in a circle, the player starts in front of door 1.\nEach turn, the player can choose a number i and pay a cost C_i to move i steps\nto the right and then open the door at that position. It is guaranteed that\nC_i >= C_{i+1} for 1 <= i < n.\nThe task is to determine the minimum total cost required to open all doors.\n\nExample:\n    > minTotalCost(3, [1, 1, 1])\n    3\n",
      "sq": "Shkruani një funksion TypeScript `function minTotalCost(n: number, C: number[]): number` për të zgjidhur problemin e mëposhtëm:\nDuke pasur parasysh n dyer të renditura në një rreth, lojtari fillon përballë derës 1.\nÇdo radhë, lojtari mund të zgjedhë një numër i dhe të paguajë një kosto C_i për të lëvizur i hapa\nnë të djathtë dhe pastaj të hapë derën në atë pozicion. Është e garantuar që\nC_i >= C_{i+1} për 1 <= i < n.\nDetyra është të përcaktohet kostoja totale minimale e nevojshme për të hapur të gjitha dyert.\n\nShembull:\n    > minTotalCost(3, [1, 1, 1])\n    3",
      "hy": "TypeScript ֆունկցիա գրեք `function minTotalCost(n: number, C: number[]): number` հետևյալ խնդիրը լուծելու համար:\nՏրված է n դռներ, որոնք դասավորված են շրջանաձև, խաղացողը սկսում է դուռ 1-ի դիմաց:\nՅուրաքանչյուր քայլում, խաղացողը կարող է ընտրել թիվ i և վճարել արժեք C_i՝ i քայլ աջ շարժվելու\nև այն դիրքում գտնվող դուռը բացելու համար: Երաշխավորված է, որ\nC_i >= C_{i+1} 1 <= i < n-ի համար:\nԽնդիրն է որոշել նվազագույն ընդհանուր արժեքը, որը պահանջվում է բոլոր դռները բացելու համար:\n\nՕրինակ:\n    > minTotalCost(3, [1, 1, 1])\n    3",
      "bn": "TypeScript ফাংশন `function minTotalCost(n: number, C: number[]): number` লিখুন নিম্নলিখিত সমস্যার সমাধান করতে:\nn টি দরজা একটি বৃত্তে সাজানো আছে, খেলোয়াড় দরজা 1 এর সামনে শুরু করে।\nপ্রতিটি পালায়, খেলোয়াড় একটি সংখ্যা i বেছে নিতে পারে এবং i ধাপ ডানদিকে যেতে এবং তারপর সেই অবস্থানে থাকা দরজা খুলতে C_i খরচ দিতে পারে। এটি নিশ্চিত যে C_i >= C_{i+1} যেখানে 1 <= i < n।\nসমস্ত দরজা খুলতে প্রয়োজনীয় সর্বনিম্ন মোট খরচ নির্ধারণ করা কাজ।\n\nউদাহরণ:\n    > minTotalCost(3, [1, 1, 1])\n    3",
      "bg": "Напишете TypeScript функция `function minTotalCost(n: number, C: number[]): number`, за да решите следния проблем:\nДадени са n врати, подредени в кръг, играчът започва пред врата 1.\nНа всеки ход играчът може да избере число i и да плати цена C_i, за да се премести i стъпки\nнадясно и след това да отвори вратата на тази позиция. Гарантирано е, че\nC_i >= C_{i+1} за 1 <= i < n.\nЗадачата е да се определи минималната обща цена, необходима за отваряне на всички врати.\n\nПример:\n    > minTotalCost(3, [1, 1, 1])\n    3",
      "zh": "编写一个 TypeScript 函数 `function minTotalCost(n: number, C: number[]): number` 来解决以下问题：\n给定 n 扇门排列成一个圆圈，玩家从门 1 前面开始。\n每回合，玩家可以选择一个数字 i 并支付一个代价 C_i 来向右移动 i 步，\n然后打开该位置的门。可以保证 C_i >= C_{i+1} 对于 1 <= i < n。\n任务是确定打开所有门所需的最小总成本。\n\n示例：\n    > minTotalCost(3, [1, 1, 1])\n    3",
      "fr": "Écrire une fonction TypeScript `function minTotalCost(n: number, C: number[]): number` pour résoudre le problème suivant :\nÉtant donné n portes disposées en cercle, le joueur commence devant la porte 1.\nÀ chaque tour, le joueur peut choisir un nombre i et payer un coût C_i pour avancer de i pas\nvers la droite puis ouvrir la porte à cette position. Il est garanti que\nC_i >= C_{i+1} pour 1 <= i < n.\nLa tâche consiste à déterminer le coût total minimum requis pour ouvrir toutes les portes.\n\nExemple :\n    > minTotalCost(3, [1, 1, 1])\n    3",
      "de": "Schreiben Sie eine TypeScript-Funktion `function minTotalCost(n: number, C: number[]): number`, um das folgende Problem zu lösen:\nGegeben sind n Türen, die in einem Kreis angeordnet sind, der Spieler beginnt vor Tür 1.\nJede Runde kann der Spieler eine Zahl i wählen und einen Kosten C_i zahlen, um i Schritte\nnach rechts zu gehen und dann die Tür an dieser Position zu öffnen. Es ist garantiert, dass\nC_i >= C_{i+1} für 1 <= i < n.\nDie Aufgabe besteht darin, die minimalen Gesamtkosten zu bestimmen, die erforderlich sind, um alle Türen zu öffnen.\n\nBeispiel:\n    > minTotalCost(3, [1, 1, 1])\n    3",
      "ha": "Rubuta wani aikin TypeScript `function minTotalCost(n: number, C: number[]): number` don warware matsalar mai zuwa:\nAn ba da ƙofofi n da aka shirya a cikin madauwari, ɗan wasan yana farawa a gaban kofa ta 1.\nKowace juyawa, ɗan wasan na iya zaɓar lamba i kuma ya biya farashi C_i don matsawa matakai i\nzuwa dama sannan ya buɗe ƙofar a wannan matsayi. An tabbatar da cewa\nC_i >= C_{i+1} don 1 <= i < n.\nAikin shine tantance mafi ƙarancin jimlar kuɗi da ake buƙata don buɗe duk ƙofofi.\n\nMisali:\n    > minTotalCost(3, [1, 1, 1])\n    3",
      "hi": "TypeScript फ़ंक्शन `function minTotalCost(n: number, C: number[]): number` लिखें ताकि निम्नलिखित समस्या का समाधान हो सके:\nदिए गए n दरवाज़े जो एक वृत्त में व्यवस्थित हैं, खिलाड़ी दरवाज़ा 1 के सामने से शुरू करता है।\nप्रत्येक चाल में, खिलाड़ी एक संख्या i चुन सकता है और i कदम दाईं ओर जाने के लिए C_i लागत का भुगतान कर सकता है और फिर उस स्थिति पर दरवाज़ा खोल सकता है। यह सुनिश्चित किया गया है कि C_i >= C_{i+1} जहाँ 1 <= i < n।\nकार्य यह निर्धारित करना है कि सभी दरवाज़े खोलने के लिए न्यूनतम कुल लागत क्या होगी।\n\nउदाहरण:\n    > minTotalCost(3, [1, 1, 1])\n    3",
      "hu": "Írj egy TypeScript függvényt `function minTotalCost(n: number, C: number[]): number` a következő probléma megoldására:\nAdott n ajtó, amelyek körben vannak elrendezve, a játékos az 1-es ajtó előtt kezd.\nMinden körben a játékos választhat egy számot i, és kifizethet egy C_i költséget, hogy i lépést tegyen jobbra, majd kinyissa az ajtót az adott pozíción. Garantált, hogy C_i >= C_{i+1} minden 1 <= i < n esetén.\nA feladat annak meghatározása, hogy mi a minimális összköltség az összes ajtó kinyitásához.\n\nPélda:\n    > minTotalCost(3, [1, 1, 1])\n    3"
    },
    "instruction_bertscore": {
      "sq": "0.9876584985351593",
      "hy": "0.9694655446754118",
      "bn": "0.9610495754309636",
      "bg": "0.9789126042278121",
      "zh": "0.9977701753425023",
      "fr": "0.9976952916888522",
      "de": "0.991129365813363",
      "ha": "0.9951482543128418",
      "hi": "0.9592253540115392",
      "hu": "0.9750875789802232"
    },
    "level": "easy",
    "test": "function testMinTotalCost(): void {\n    console.assert(minTotalCost(5, [4, 3, 3, 3, 3]) === 15);\n    console.assert(minTotalCost(3, [1, 1, 1]) === 3);\n    console.assert(minTotalCost(4, [5, 4, 3, 2]) === 11);\n    console.assert(minTotalCost(4, [100, 99, 98, 97]) === 391);\n    console.assert(minTotalCost(6, [10, 9, 8, 7, 6, 5]) === 35);\n    console.assert(minTotalCost(7, [2, 2, 2, 2, 2, 2, 2]) === 14);\n    console.assert(minTotalCost(8, [9, 7, 7, 7, 7, 7, 7, 7]) === 56);\n    console.assert(minTotalCost(9, [3, 2, 2, 2, 2, 2, 2, 2, 2]) === 18);\n    console.assert(minTotalCost(10, [6, 5, 5, 5, 5, 5, 5, 5, 5, 5]) === 50);\n    console.assert(minTotalCost(11, [8, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1]) === 11);\n}\n\ntestMinTotalCost();",
    "entry_point": "minTotalCost",
    "signature": "function minTotalCost(n: number, C: number[]): number",
    "docstring": {
      "en": "Given n doors arranged in a circle, the player starts in front of door 1.\nEach turn, the player can choose a number i and pay a cost C_i to move i steps\nto the right and then open the door at that position. It is guaranteed that\nC_i >= C_{i+1} for 1 <= i < n.\nThe task is to determine the minimum total cost required to open all doors.\n\nExample:\n    > minTotalCost(3, [1, 1, 1])\n    3\n",
      "sq": "Duke pasur n dyer të rregulluara në një rreth, lojtari fillon përpara derës 1. \nÇdo radhë, lojtari mund të zgjedhë një numër i dhe të paguajë një kosto C_i për të lëvizur i hapa \nnë të djathtë dhe pastaj të hapë derën në atë pozicion. Është e garantuar që \nC_i >= C_{i+1} për 1 <= i < n. \nDetyra është të përcaktohet kostoja totale minimale e kërkuar për të hapur të gjitha dyert.\n\nShembull:\n    > minTotalCost(3, [1, 1, 1])\n    3",
      "hy": "Տրված են n դռներ, որոնք դասավորված են շրջանաձև: Խաղացողը սկսում է դուռ 1-ի դիմաց: Յուրաքանչյուր քայլի ժամանակ խաղացողը կարող է ընտրել թիվ i և վճարել արժեք C_i՝ i քայլ աջ շարժվելու և այն դիրքում գտնվող դուռը բացելու համար: Երաշխավորված է, որ C_i >= C_{i+1} 1 <= i < n-ի համար: Խնդիրը կայանում է որոշել բոլոր դռները բացելու համար անհրաժեշտ նվազագույն ընդհանուր արժեքը:\n\nՕրինակ:\n    > minTotalCost(3, [1, 1, 1])\n    3",
      "bn": "নির্দিষ্ট n দরজা একটি বৃত্তে সাজানো আছে, খেলোয়াড় দরজা 1 এর সামনে থেকে শুরু করে। \nপ্রতিটি পালায়, খেলোয়াড় একটি সংখ্যা i বেছে নিতে পারে এবং i ধাপ ডানদিকে যেতে C_i খরচ দিতে পারে \nএবং তারপর সেই অবস্থানে দরজা খুলতে পারে। এটি নিশ্চিত করা হয়েছে যে \nC_i >= C_{i+1} যেখানে 1 <= i < n। \nকাজটি হল সমস্ত দরজা খোলার জন্য প্রয়োজনীয় সর্বনিম্ন মোট খরচ নির্ধারণ করা।\n\nউদাহরণ:\n    > minTotalCost(3, [1, 1, 1])\n    3",
      "bg": "Дадени са n врати, подредени в кръг, играчът започва пред врата 1. \nВсеки ход играчът може да избере число i и да плати цена C_i, за да се премести i стъпки \nнадясно и след това да отвори вратата на тази позиция. Гарантирано е, че \nC_i >= C_{i+1} за 1 <= i < n. \nЗадачата е да се определи минималната обща цена, необходима за отваряне на всички врати.\n\nПример:\n    > minTotalCost(3, [1, 1, 1])\n    3",
      "zh": "给定 n 个门按圆形排列，玩家从门 1 前开始。  \n每回合，玩家可以选择一个数字 i 并支付费用 C_i 向右移动 i 步，然后打开该位置的门。保证 C_i >= C_{i+1} 对于 1 <= i < n。  \n任务是确定打开所有门所需的最小总费用。\n\n示例：\n    > minTotalCost(3, [1, 1, 1])\n    3",
      "fr": "Étant donné n portes disposées en cercle, le joueur commence devant la porte 1. À chaque tour, le joueur peut choisir un nombre i et payer un coût C_i pour avancer de i pas vers la droite, puis ouvrir la porte à cette position. Il est garanti que C_i >= C_{i+1} pour 1 <= i < n. La tâche consiste à déterminer le coût total minimum nécessaire pour ouvrir toutes les portes.\n\nExemple :\n    > minTotalCost(3, [1, 1, 1])\n    3",
      "de": "Gegeben n Türen, die in einem Kreis angeordnet sind, beginnt der Spieler vor Tür 1. Bei jedem Zug kann der Spieler eine Zahl i wählen und einen Kosten C_i zahlen, um i Schritte nach rechts zu gehen und dann die Tür an dieser Position zu öffnen. Es ist garantiert, dass C_i >= C_{i+1} für 1 <= i < n. Die Aufgabe besteht darin, die minimalen Gesamtkosten zu bestimmen, die erforderlich sind, um alle Türen zu öffnen.\n\nBeispiel:\n    > minTotalCost(3, [1, 1, 1])\n    3",
      "ha": "An ba da ƙofofi n da aka shirya a cikin da'ira, ɗan wasa yana farawa a gaban ƙofa ta 1. Kowanne juyi, ɗan wasa zai iya zaɓar wani lamba i kuma ya biya farashi C_i don matsawa matakai i zuwa dama sannan ya buɗe ƙofar a wannan matsayi. An tabbatar da cewa C_i >= C_{i+1} don 1 <= i < n. Aikin shine a ƙayyade mafi ƙarancin jimlar kuɗi da ake buƙata don buɗe duk ƙofofin.\n\nMisali:\n    > minTotalCost(3, [1, 1, 1])\n    3",
      "hi": "दिए गए n दरवाजे जो एक वृत्त में व्यवस्थित हैं, खिलाड़ी दरवाजा 1 के सामने से शुरू करता है।  \nप्रत्येक चाल में, खिलाड़ी एक संख्या i चुन सकता है और i कदम दाईं ओर जाने के लिए एक लागत C_i का भुगतान कर सकता है और फिर उस स्थिति पर दरवाजा खोल सकता है। यह गारंटी है कि C_i >= C_{i+1} जहाँ 1 <= i < n।  \nकार्य यह निर्धारित करना है कि सभी दरवाजे खोलने के लिए न्यूनतम कुल लागत क्या होगी।\n\nउदाहरण:\n    > minTotalCost(3, [1, 1, 1])\n    3",
      "hu": "Adott n ajtó, amelyek körben vannak elrendezve, a játékos az 1-es ajtó előtt kezd.\nMinden körben a játékos választhat egy számot i, és fizet egy C_i költséget, hogy i lépést tegyen jobbra, majd kinyissa az ajtót azon a helyen. Garantált, hogy C_i >= C_{i+1} minden 1 <= i < n esetén.\nA feladat annak meghatározása, hogy mi a minimális összköltség az összes ajtó kinyitásához.\n\nPélda:\n    > minTotalCost(3, [1, 1, 1])\n    3"
    },
    "docstring_bertscore": {
      "sq": "0.9962850159835045",
      "hy": "0.9616458638348303",
      "bn": "0.9539074228200921",
      "bg": "0.996128296612868",
      "zh": "0.9942685203552383",
      "fr": "0.9905416185158807",
      "de": "0.9878495809617148",
      "ha": "0.979629262642586",
      "hi": "0.9678484947434068",
      "hu": "0.9700799084439528"
    }
  },
  {
    "task_id": "TypeScript/37",
    "prompt": {
      "en": "\n/**\n * Calculates the total number of handshakes in a classroom where each student shakes\n * hands with every student already in the room with a smaller student ID. The student\n * IDs range from 0 to N-1, and the sequence of ID entries represents the order in which\n * they enter the classroom.\n * \n * @param n - the number of students\n * @param order - the sequence of student IDs entering the classroom\n * @returns the total number of handshakes\n * \n * Examples:\n *    countHandshakes(3, [2, 1, 0])  // returns 0\n */\nfunction countHandshakes(n: number, order: number[]): number",
      "sq": "/**\n * Llogarit numrin total të shtrëngimeve të duarve në një klasë ku çdo student shtrëngon\n * duart me çdo student që tashmë është në dhomë me një ID studenti më të vogël. ID-të e studentëve\n * variojnë nga 0 deri në N-1, dhe sekuenca e hyrjeve të ID-ve përfaqëson rendin në të cilin\n * ata hyjnë në klasë.\n * \n * @param n - numri i studentëve\n * @param order - sekuenca e ID-ve të studentëve që hyjnë në klasë\n * @returns numri total i shtrëngimeve të duarve\n * \n * Shembuj:\n *    countHandshakes(3, [2, 1, 0])  // kthen 0\n */\nfunction countHandshakes(n: number, order: number[]): number",
      "hy": "/**\n * Հաշվում է ընդհանուր ձեռքսեղմումների քանակը դասարանում, որտեղ յուրաքանչյուր ուսանող\n * ձեռքսեղմում է սենյակում արդեն գտնվող յուրաքանչյուր ուսանողի հետ, ում ուսանողի ID-ն փոքր է:\n * Ուսանողների ID-ները տատանվում են 0-ից մինչև N-1, և ID-ների մուտքագրման հաջորդականությունը\n * ներկայացնում է այն կարգը, որով նրանք մտնում են դասարան:\n * \n * @param n - ուսանողների քանակը\n * @param order - ուսանողների ID-ների հաջորդականությունը, որով նրանք մտնում են դասարան\n * @returns ձեռքսեղմումների ընդհանուր քանակը\n * \n * Օրինակներ:\n *    countHandshakes(3, [2, 1, 0])  // վերադարձնում է 0\n */ \nfunction countHandshakes(n: number, order: number[]): number",
      "bn": "/**\n * একটি শ্রেণীকক্ষে মোট কতগুলি করমর্দন হয় তা গণনা করে যেখানে প্রতিটি ছাত্র ইতিমধ্যে ঘরে থাকা প্রতিটি ছাত্রের সাথে করমর্দন করে যার ছাত্র আইডি ছোট। \n * ছাত্র আইডি 0 থেকে N-1 পর্যন্ত থাকে, এবং আইডি প্রবেশের ক্রম তাদের শ্রেণীকক্ষে প্রবেশের ক্রমকে উপস্থাপন করে।\n * \n * @param n - ছাত্রদের সংখ্যা\n * @param order - শ্রেণীকক্ষে প্রবেশের ছাত্র আইডির ক্রম\n * @returns মোট করমর্দনের সংখ্যা\n * \n * উদাহরণ:\n *    countHandshakes(3, [2, 1, 0])  // 0 ফেরত দেয়\n */\nfunction countHandshakes(n: number, order: number[]): number",
      "bg": "/**\n * Изчислява общия брой ръкостискания в класна стая, където всеки ученик се ръкува\n * с всеки ученик, който вече е в стаята с по-малък идентификационен номер. Идентификационните\n * номера на учениците варират от 0 до N-1, а последователността на въвеждане на ID представлява\n * реда, в който те влизат в класната стая.\n * \n * @param n - броят на учениците\n * @param order - последователността на идентификационните номера на учениците, които влизат в класната стая\n * @returns общия брой ръкостискания\n * \n * Примери:\n *    countHandshakes(3, [2, 1, 0])  // връща 0\n */\nfunction countHandshakes(n: number, order: number[]): number",
      "zh": "/**\n * 计算在一个教室里，学生之间的握手总数，其中每个学生与已经在教室里的每个学生握手，\n * 这些学生的学生ID比当前学生小。学生ID的范围是从0到N-1，ID的顺序表示他们进入教室的顺序。\n * \n * @param n - 学生的数量\n * @param order - 学生进入教室的ID顺序\n * @returns 握手的总数\n * \n * 示例:\n *    countHandshakes(3, [2, 1, 0])  // 返回 0\n */\nfunction countHandshakes(n: number, order: number[]): number",
      "fr": "/**\n * Calcule le nombre total de poignées de main dans une salle de classe où chaque élève serre\n * la main de chaque élève déjà dans la salle avec un ID étudiant plus petit. Les IDs des étudiants\n * vont de 0 à N-1, et la séquence d'entrées des IDs représente l'ordre dans lequel\n * ils entrent dans la salle de classe.\n * \n * @param n - le nombre d'élèves\n * @param order - la séquence des IDs des étudiants entrant dans la salle de classe\n * @returns le nombre total de poignées de main\n * \n * Exemples :\n *    countHandshakes(3, [2, 1, 0])  // returns 0\n */\nfunction countHandshakes(n: number, order: number[]): number",
      "de": "/**\n * Berechnet die Gesamtanzahl der Händedrucke in einem Klassenzimmer, in dem jeder Schüler\n * jedem Schüler, der sich bereits im Raum befindet und eine kleinere Schüler-ID hat, die Hand gibt.\n * Die Schüler-IDs reichen von 0 bis N-1, und die Reihenfolge der ID-Einträge repräsentiert die\n * Reihenfolge, in der sie das Klassenzimmer betreten.\n * \n * @param n - die Anzahl der Schüler\n * @param order - die Reihenfolge der Schüler-IDs, die das Klassenzimmer betreten\n * @returns die Gesamtanzahl der Händedrucke\n * \n * Beispiele:\n *    countHandshakes(3, [2, 1, 0])  // gibt 0 zurück\n */\nfunction countHandshakes(n: number, order: number[]): number",
      "ha": "/**\n * Yana ƙididdige jimillar yawan gaisuwar hannu a cikin aji inda kowane ɗalibi ke gaisawa\n * da kowane ɗalibi da ke riga ya shiga ɗakin da ƙaramin ID ɗin ɗalibi. ID ɗin ɗalibai suna \n * daga 0 zuwa N-1, kuma jerin shigarwar ID yana wakiltar tsarin da suke shiga aji.\n * \n * @param n - yawan ɗalibai\n * @param order - jerin shigarwar ID ɗin ɗalibai cikin aji\n * @returns jimillar yawan gaisuwar hannu\n * \n * Misalai:\n *    countHandshakes(3, [2, 1, 0])  // yana dawowa 0\n */\nfunction countHandshakes(n: number, order: number[]): number",
      "hi": "/**\n * गणना करता है कि कक्षा में कुल कितनी बार हाथ मिलाए जाते हैं जहाँ प्रत्येक छात्र\n * पहले से कमरे में मौजूद प्रत्येक छात्र से हाथ मिलाता है जिनका छात्र आईडी उससे छोटा है।\n * छात्र आईडी 0 से N-1 तक होती हैं, और आईडी प्रविष्टियों का क्रम यह दर्शाता है कि वे किस क्रम में\n * कक्षा में प्रवेश करते हैं।\n * \n * @param n - छात्रों की संख्या\n * @param order - कक्षा में प्रवेश करने वाले छात्र आईडी का क्रम\n * @returns कुल हाथ मिलाने की संख्या\n * \n * उदाहरण:\n *    countHandshakes(3, [2, 1, 0])  // 0 लौटाता है\n */\nfunction countHandshakes(n: number, order: number[]): number",
      "hu": "/**\n * Kiszámítja az összes kézfogás számát egy osztályteremben, ahol minden diák kezet fog\n * minden már a teremben lévő diákkal, akinek kisebb a diákazonosítója. A diákazonosítók\n * 0-tól N-1-ig terjednek, és az azonosítók sorrendje azt a sorrendet jelenti, ahogyan\n * belépnek az osztályterembe.\n * \n * @param n - a diákok száma\n * @param order - a diákazonosítók sorrendje, ahogyan belépnek az osztályterembe\n * @returns az összes kézfogás száma\n * \n * Példák:\n *    countHandshakes(3, [2, 1, 0])  // visszaadja: 0\n */\nfunction countHandshakes(n: number, order: number[]): number"
    },
    "prompt_bertscore": {
      "sq": "0.9758817032436008",
      "hy": "0.9733877001793267",
      "bn": "0.956229610604771",
      "bg": "0.9657052729320403",
      "zh": "0.9337962953706908",
      "fr": "0.9972767774760117",
      "de": "0.9718508969212598",
      "ha": "0.9423129702183236",
      "hi": "0.9554331027768211",
      "hu": "0.9672827954182194"
    },
    "canonical_solution": "{\n    let ans = 0;\n    const tr = new Array(n + 1).fill(0); // Increase the size to accommodate 1-indexed values.\n    for (let i = 0; i < n; ++i) {\n        let x = order[i] + 1; // Convert 0-indexed to 1-indexed\n        for (let j = x - 1; j > 0; j -= j & (-j)) {\n            ans += tr[j];\n        }\n        for (let j = x; j <= n; j += j & (-j)) {\n            tr[j]++;\n        }\n    }\n    return ans;\n};",
    "instruction": {
      "en": "Write a TypeScript function `function countHandshakes(n: number, order: number[]): number` to solve the following problem:\nCalculates the total number of handshakes in a classroom where each student shakes hands with every student already in the room with a smaller student ID. The student IDs range from 0 to N-1, and the sequence of ID entries represents the order in which they enter the classroom.\n\n@param n - the number of students\n@param order - the sequence of student IDs entering the classroom\n@returns the total number of handshakes\n\nExamples:\n   countHandshakes(3, [2, 1, 0])  // returns 0\n",
      "sq": "Shkruani një funksion TypeScript `function countHandshakes(n: number, order: number[]): number` për të zgjidhur problemin e mëposhtëm:\nLlogarit numrin total të shtrëngimeve të duarve në një klasë ku çdo student shtrëngon duart me çdo student që është tashmë në dhomë me një ID studenti më të vogël. ID-të e studentëve variojnë nga 0 deri në N-1, dhe sekuenca e hyrjeve të ID-ve përfaqëson rendin në të cilin ata hyjnë në klasë.\n\n@param n - numri i studentëve\n@param order - sekuenca e ID-ve të studentëve që hyjnë në klasë\n@returns numri total i shtrëngimeve të duarve\n\nShembuj:\n   countHandshakes(3, [2, 1, 0])  // kthen 0",
      "hy": "Գրեք TypeScript ֆունկցիա `function countHandshakes(n: number, order: number[]): number`՝ հետևյալ խնդիրը լուծելու համար:\nՀաշվում է ընդհանուր ձեռքսեղմումների քանակը դասարանում, որտեղ յուրաքանչյուր ուսանող ձեռք է սեղմում արդեն սենյակում գտնվող յուրաքանչյուր ուսանողի հետ, ում ուսանողի ID-ն ավելի փոքր է: Ուսանողների ID-ները տատանվում են 0-ից մինչև N-1, և ID-ների մուտքի հաջորդականությունը ներկայացնում է այն հերթականությունը, որով նրանք մտնում են դասարան:\n\n@param n - ուսանողների քանակը\n@param order - դասարան մտնող ուսանողների ID-ների հաջորդականությունը\n@returns ձեռքսեղմումների ընդհանուր քանակը\n\nՕրինակներ:\n   countHandshakes(3, [2, 1, 0])  // վերադարձնում է 0",
      "bn": "একটি TypeScript ফাংশন `function countHandshakes(n: number, order: number[]): number` লিখুন নিম্নলিখিত সমস্যার সমাধানের জন্য:\nএকটি শ্রেণীকক্ষে মোট কতগুলি হ্যান্ডশেক হয় তা গণনা করে যেখানে প্রতিটি ছাত্র ইতিমধ্যে শ্রেণীকক্ষে উপস্থিত প্রতিটি ছাত্রের সাথে হ্যান্ডশেক করে যার ছাত্র আইডি ছোট। ছাত্র আইডি 0 থেকে N-1 পর্যন্ত থাকে এবং আইডি প্রবেশের ক্রম তাদের শ্রেণীকক্ষে প্রবেশের ক্রমকে উপস্থাপন করে।\n\n@param n - ছাত্রদের সংখ্যা\n@param order - শ্রেণীকক্ষে প্রবেশের ছাত্র আইডির ক্রম\n@returns মোট হ্যান্ডশেকের সংখ্যা\n\nউদাহরণ:\n   countHandshakes(3, [2, 1, 0])  // 0 প্রদান করে",
      "bg": "Напишете функция на TypeScript `function countHandshakes(n: number, order: number[]): number`, за да решите следния проблем:\nИзчислява общия брой ръкостискания в класна стая, където всеки ученик се ръкува с всеки ученик, който вече е в стаята с по-малък идентификационен номер. Идентификационните номера на учениците варират от 0 до N-1, а последователността на влизане на идентификационните номера представлява реда, в който те влизат в класната стая.\n\n@param n - броят на учениците\n@param order - последователността на идентификационните номера на учениците, влизащи в класната стая\n@returns общия брой ръкостискания\n\nПримери:\n   countHandshakes(3, [2, 1, 0])  // връща 0",
      "zh": "编写一个 TypeScript 函数 `function countHandshakes(n: number, order: number[]): number` 来解决以下问题：\n计算在一个教室里，总的握手次数，其中每个学生与已经在房间里的每个学生握手，这些学生的学生ID比自己小。学生ID的范围是从0到N-1，ID进入的顺序表示他们进入教室的顺序。\n\n@param n - 学生的数量\n@param order - 学生ID进入教室的顺序\n@returns 握手的总次数\n\n例子：\n   countHandshakes(3, [2, 1, 0])  // 返回 0",
      "fr": "Écrire une fonction TypeScript `function countHandshakes(n: number, order: number[]): number` pour résoudre le problème suivant :\nCalcule le nombre total de poignées de main dans une salle de classe où chaque étudiant serre la main de chaque étudiant déjà dans la salle avec un identifiant étudiant plus petit. Les identifiants des étudiants vont de 0 à N-1, et la séquence des entrées d'identifiants représente l'ordre dans lequel ils entrent dans la salle de classe.\n\n@param n - le nombre d'étudiants\n@param order - la séquence des identifiants d'étudiants entrant dans la salle de classe\n@returns le nombre total de poignées de main\n\nExemples :\n   countHandshakes(3, [2, 1, 0])  // retourne 0",
      "de": "Schreiben Sie eine TypeScript-Funktion `function countHandshakes(n: number, order: number[]): number`, um das folgende Problem zu lösen:\nBerechnet die Gesamtanzahl der Händedrucke in einem Klassenzimmer, in dem jeder Schüler jedem Schüler, der sich bereits im Raum befindet und eine kleinere Schüler-ID hat, die Hand schüttelt. Die Schüler-IDs reichen von 0 bis N-1, und die Reihenfolge der ID-Einträge stellt die Reihenfolge dar, in der sie das Klassenzimmer betreten.\n\n@param n - die Anzahl der Schüler\n@param order - die Reihenfolge der Schüler-IDs, die das Klassenzimmer betreten\n@returns die Gesamtanzahl der Händedrucke\n\nBeispiele:\n   countHandshakes(3, [2, 1, 0])  // gibt 0 zurück",
      "ha": "Rubuta aikin TypeScript `function countHandshakes(n: number, order: number[]): number` don warware matsalar mai zuwa:\nYana ƙididdige adadin musabaha a cikin aji inda kowane ɗalibi ke musabaha da kowane ɗalibi da ke cikin ɗakin tare da ƙaramin ID ɗin ɗalibi. ID ɗin ɗalibai suna daga 0 zuwa N-1, kuma jerin shigar ID yana wakiltar tsarin da suke shiga cikin aji.\n\n@param n - adadin ɗalibai\n@param order - jerin ID ɗin ɗalibai da ke shigowa cikin aji\n@returns adadin musabaha\n\nMisalai:\n   countHandshakes(3, [2, 1, 0])  // yana dawowa 0",
      "hi": "TypeScript फ़ंक्शन `function countHandshakes(n: number, order: number[]): number` लिखें ताकि निम्नलिखित समस्या का समाधान किया जा सके:\nकक्षा में कुल कितने हैंडशेक होते हैं, यह गणना करता है जहाँ प्रत्येक छात्र पहले से कमरे में मौजूद प्रत्येक छात्र से हाथ मिलाता है जिसका छात्र आईडी उससे छोटी होती है। छात्र आईडी 0 से N-1 तक होती हैं, और आईडी प्रविष्टियों का क्रम यह दर्शाता है कि वे कक्षा में किस क्रम में प्रवेश करते हैं।\n\n@param n - छात्रों की संख्या\n@param order - कक्षा में प्रवेश करने वाले छात्र आईडी का क्रम\n@returns कुल हैंडशेक की संख्या\n\nउदाहरण:\n   countHandshakes(3, [2, 1, 0])  // 0 लौटाता है",
      "hu": "Írj egy TypeScript függvényt `function countHandshakes(n: number, order: number[]): number` a következő probléma megoldására:\nKiszámítja az összes kézfogás számát egy osztályteremben, ahol minden diák kezet fog minden már bent lévő diákkal, akinek kisebb a diákazonosítója. A diákazonosítók 0-tól N-1-ig terjednek, és az azonosítók belépési sorrendje azt a sorrendet jelenti, amelyben belépnek az osztályterembe.\n\n@param n - a diákok száma\n@param order - a diákazonosítók belépési sorrendje az osztályterembe\n@returns az összes kézfogás száma\n\nPéldák:\n   countHandshakes(3, [2, 1, 0])  // visszaadja 0"
    },
    "instruction_bertscore": {
      "sq": "0.977414533894047",
      "hy": "0.9734782756330786",
      "bn": "0.9490234990112063",
      "bg": "0.9622063987701108",
      "zh": "0.9497878287174285",
      "fr": "0.9987676971160595",
      "de": "0.9796215160577256",
      "ha": "0.9498343082265908",
      "hi": "0.944307815135057",
      "hu": "0.9762726078334775"
    },
    "level": "middle",
    "test": "(() => {\n    console.assert(countHandshakes(4, [2, 1, 3, 0]) === 2, \"Test 1 failed\");\n    console.assert(countHandshakes(6, [0, 1, 2, 3, 4, 5]) === 15, \"Test 2 failed\");\n    console.assert(countHandshakes(3, [1, 2, 0]) === 1, \"Test 3 failed\");\n    console.assert(countHandshakes(4, [3, 2, 1, 0]) === 0, \"Test 4 failed\");\n    console.assert(countHandshakes(4, [0, 1, 2, 3]) === 6, \"Test 5 failed\");\n    console.assert(countHandshakes(6, [5, 4, 3, 2, 1, 0]) === 0, \"Test 6 failed\");\n    console.assert(countHandshakes(4, [0, 2, 1, 3]) === 5, \"Test 7 failed\");\n    console.assert(countHandshakes(5, [3, 1, 4, 2, 0]) === 3, \"Test 8 failed\");\n    console.assert(countHandshakes(4, [1, 0, 3, 2]) === 4, \"Test 9 failed\");\n    console.assert(countHandshakes(3, [2, 0, 1]) === 1, \"Test 10 failed\");\n    console.assert(countHandshakes(5, [1, 3, 0, 2, 4]) === 7, \"Test 11 failed\");\n    console.assert(countHandshakes(5, [4, 3, 2, 1, 0]) === 0, \"Test 12 failed\");\n})();",
    "entry_point": "countHandshakes",
    "signature": "function countHandshakes(n: number, order: number[]): number",
    "docstring": {
      "en": "Calculates the total number of handshakes in a classroom where each student shakes hands with every student already in the room with a smaller student ID. The student IDs range from 0 to N-1, and the sequence of ID entries represents the order in which they enter the classroom.\n\n@param n - the number of students\n@param order - the sequence of student IDs entering the classroom\n@returns the total number of handshakes\n\nExamples:\n   countHandshakes(3, [2, 1, 0])  // returns 0\n",
      "sq": "Llogarit numrin total të shtrëngimeve të duarve në një klasë ku çdo student shtrëngon duart me çdo student që tashmë është në dhomë me një ID studenti më të vogël. ID-të e studentëve variojnë nga 0 deri në N-1, dhe rendi i hyrjes së ID-ve përfaqëson rendin në të cilin ata hyjnë në klasë.\n\n@param n - numri i studentëve\n@param order - rendi i ID-ve të studentëve që hyjnë në klasë\n@returns numri total i shtrëngimeve të duarve\n\nShembuj:\n   countHandshakes(3, [2, 1, 0])  // kthen 0",
      "hy": "Հաշվում է ընդհանուր ձեռքսեղմումների քանակը դասարանում, որտեղ յուրաքանչյուր ուսանող ձեռք է սեղմում արդեն սենյակում գտնվող յուրաքանչյուր ուսանողի հետ, ում ուսանողի ID-ն ավելի փոքր է: Ուսանողների ID-ները տատանվում են 0-ից մինչև N-1, և ID-ների մուտքագրման հաջորդականությունը ներկայացնում է նրանց դասարան մուտք գործելու կարգը:\n\n@param n - ուսանողների քանակը\n@param order - ուսանողների ID-ների հաջորդականությունը, որոնք մուտք են գործում դասարան\n@returns ձեռքսեղմումների ընդհանուր քանակը\n\nՕրինակներ:\n   countHandshakes(3, [2, 1, 0])  // վերադարձնում է 0",
      "bn": "ক্লাসরুমে মোট কতগুলি হ্যান্ডশেক হয় তা গণনা করে যেখানে প্রতিটি ছাত্র ইতিমধ্যে রুমে থাকা প্রতিটি ছাত্রের সাথে হ্যান্ডশেক করে যার ছাত্র আইডি ছোট। ছাত্র আইডি 0 থেকে N-1 পর্যন্ত থাকে, এবং আইডি প্রবেশের ক্রম তাদের ক্লাসরুমে প্রবেশের ক্রমকে উপস্থাপন করে।\n\n@param n - ছাত্রদের সংখ্যা\n@param order - ক্লাসরুমে প্রবেশকারী ছাত্রদের আইডির ক্রম\n@returns মোট হ্যান্ডশেকের সংখ্যা\n\nউদাহরণ:\n   countHandshakes(3, [2, 1, 0])  // 0 প্রদান করে",
      "bg": "Изчислява общия брой ръкостискания в класна стая, където всеки ученик се ръкува с всеки ученик, който вече е в стаята с по-малък идентификационен номер. Идентификационните номера на учениците варират от 0 до N-1, а последователността на влизане на идентификационните номера представлява реда, в който те влизат в класната стая.\n\n@param n - броят на учениците\n@param order - последователността на влизане на идентификационните номера на учениците в класната стая\n@returns общият брой ръкостискания\n\nПримери:\n   countHandshakes(3, [2, 1, 0])  // връща 0",
      "zh": "计算一个教室中握手的总次数，其中每个学生与房间中已经存在的每个学生（学生ID较小）握手。学生ID的范围是从0到N-1，ID进入的顺序表示他们进入教室的顺序。\n\n@param n - 学生的数量\n@param order - 学生ID进入教室的顺序\n@returns 握手的总次数\n\n示例：\n   countHandshakes(3, [2, 1, 0])  // 返回 0",
      "fr": "Calcule le nombre total de poignées de main dans une salle de classe où chaque étudiant serre la main de chaque étudiant déjà présent dans la salle avec un identifiant étudiant plus petit. Les identifiants des étudiants vont de 0 à N-1, et la séquence des entrées d'identifiants représente l'ordre dans lequel ils entrent dans la salle de classe.\n\n@param n - le nombre d'étudiants\n@param order - la séquence des identifiants des étudiants entrant dans la salle de classe\n@returns le nombre total de poignées de main\n\nExemples:\n   countHandshakes(3, [2, 1, 0])  // retourne 0",
      "de": "Berechnet die Gesamtanzahl der Händedrucke in einem Klassenzimmer, in dem jeder Schüler jedem Schüler, der sich bereits im Raum befindet und eine kleinere Schüler-ID hat, die Hand schüttelt. Die Schüler-IDs reichen von 0 bis N-1, und die Reihenfolge der ID-Einträge stellt die Reihenfolge dar, in der sie das Klassenzimmer betreten.\n\n@param n - die Anzahl der Schüler\n@param order - die Reihenfolge der Schüler-IDs, die das Klassenzimmer betreten\n@returns die Gesamtanzahl der Händedrucke\n\nBeispiele:\n   countHandshakes(3, [2, 1, 0])  // gibt 0 zurück",
      "ha": "Calculates the total number of handshakes in a classroom where each student shakes hands with every student already in the room with a smaller student ID. The student IDs range from 0 to N-1, and the sequence of ID entries represents the order in which they enter the classroom.\n\n@param n - adadin ɗalibai\n@param order - jerin shigar ɗalibai ID a cikin aji\n@returns jimlar adadin musabaha\n\nMisalai:\n   countHandshakes(3, [2, 1, 0])  // ya dawo da 0",
      "hi": "कक्षा में कुल कितने हैंडशेक होते हैं, यह गणना करता है जहाँ प्रत्येक छात्र पहले से कमरे में मौजूद प्रत्येक छात्र से हाथ मिलाता है जिसका छात्र आईडी उससे छोटा है। छात्र आईडी 0 से N-1 तक होते हैं, और आईडी प्रविष्टियों का क्रम उस क्रम का प्रतिनिधित्व करता है जिसमें वे कक्षा में प्रवेश करते हैं।\n\n@param n - छात्रों की संख्या\n@param order - कक्षा में प्रवेश करने वाले छात्रों के आईडी का क्रम\n@returns कुल हैंडशेक की संख्या\n\nउदाहरण:\n   countHandshakes(3, [2, 1, 0])  // 0 लौटाता है",
      "hu": "Kiszámítja az összes kézfogás számát egy osztályteremben, ahol minden diák kezet fog minden már a teremben lévő diákkal, akiknek kisebb a diákazonosítójuk. A diákazonosítók 0-tól N-1-ig terjednek, és az azonosítók belépési sorrendje azt a sorrendet képviseli, ahogyan belépnek az osztályterembe.\n\n@param n - a diákok száma\n@param order - a diákazonosítók belépési sorrendje az osztályterembe\n@returns az összes kézfogás száma\n\nPéldák:\n   countHandshakes(3, [2, 1, 0])  // visszaadja: 0"
    },
    "docstring_bertscore": {
      "sq": "0.9609619794329272",
      "hy": "0.975319777895653",
      "bn": "0.9372292242461167",
      "bg": "0.9583583323983219",
      "zh": "0.9341675355528449",
      "fr": "0.9938754308311702",
      "de": "0.9735954675578892",
      "ha": "0.9779488496190308",
      "hi": "0.9457901936687204",
      "hu": "0.9776175341434646"
    }
  },
  {
    "task_id": "TypeScript/38",
    "prompt": {
      "en": "\n/**\n * Given n positive integers representing the count of each number from 1 to n, \n * find the maximum sum of the mode (most frequent element) for all prefixes of \n * a sequence constructed from these numbers. The mode is the largest number \n * among the most frequent elements in a sequence.\n * For example:\n *   maxModeSum(3, [1, 2, 3])\n *   A sequence that reaches its maximum value is [3, 2, 3, 1, 2, 2], and the sum is 17.\n */\nfunction maxModeSum(n: number, counts: number[]): number",
      "sq": "/**\n * Duke pasur n numra pozitivë që përfaqësojnë numrin e secilit numër nga 1 deri në n,\n * gjeni shumën maksimale të modës (elementi më i shpeshtë) për të gjitha prefikset e\n * një sekuence të ndërtuar nga këta numra. Moda është numri më i madh\n * ndër elementët më të shpeshtë në një sekuencë.\n * Për shembull:\n *   maxModeSum(3, [1, 2, 3])\n *   Një sekuencë që arrin vlerën e saj maksimale është [3, 2, 3, 1, 2, 2], dhe shuma është 17.\n */\nfunction maxModeSum(n: number, counts: number[]): number",
      "hy": "/**\n * Տրված են n դրական ամբողջ թվեր, որոնք ներկայացնում են 1-ից n թվերի քանակը,\n * գտնել մաքսիմալ գումարը մոդի (ամենահաճախ հանդիպող տարր) բոլոր նախածանցների համար\n * հաջորդականության, որը կազմված է այս թվերից։ Մոդը ամենամեծ թիվն է\n * հաջորդականության ամենահաճախ հանդիպող տարրերի մեջ։\n * Օրինակ:\n *   maxModeSum(3, [1, 2, 3])\n *   Հաջորդականություն, որը հասնում է իր մաքսիմալ արժեքին, [3, 2, 3, 1, 2, 2] է, և գումարը 17 է։\n */\nfunction maxModeSum(n: number, counts: number[]): number",
      "bn": "/**\n * ১ থেকে n পর্যন্ত প্রতিটি সংখ্যার গণনা উপস্থাপনকারী n টি ধনাত্মক পূর্ণসংখ্যা দেওয়া হলে, \n * এই সংখ্যাগুলি থেকে নির্মিত একটি ক্রমের সমস্ত উপসর্গের জন্য মোডের (সবচেয়ে ঘন ঘন উপাদান) সর্বাধিক \n * যোগফল খুঁজে বের করুন। মোড হল একটি ক্রমের সবচেয়ে ঘন ঘন উপাদানগুলির মধ্যে বৃহত্তম সংখ্যা।\n * উদাহরণস্বরূপ:\n *   maxModeSum(3, [1, 2, 3])\n *   একটি ক্রম যা তার সর্বাধিক মানে পৌঁছায় তা হল [3, 2, 3, 1, 2, 2], এবং যোগফল হল 17।\n */\nfunction maxModeSum(n: number, counts: number[]): number",
      "bg": "/**\n * Дадени са n положителни цели числа, представляващи броя на всяко число от 1 до n,\n * намерете максималната сума на модата (най-често срещания елемент) за всички префикси на\n * последователност, изградена от тези числа. Модата е най-голямото число\n * сред най-често срещаните елементи в последователност.\n * Например:\n *   maxModeSum(3, [1, 2, 3])\n *   Последователност, която достига максималната си стойност, е [3, 2, 3, 1, 2, 2], и сумата е 17.\n */\nfunction maxModeSum(n: number, counts: number[]): number",
      "zh": "/**\n * 给定 n 个正整数，表示从 1 到 n 的每个数字的计数，\n * 找出从这些数字构建的序列的所有前缀中众数（最频繁元素）的最大和。\n * 众数是序列中最频繁元素中最大的数字。\n * 例如：\n *   maxModeSum(3, [1, 2, 3])\n *   一个达到最大值的序列是 [3, 2, 3, 1, 2, 2]，其和为 17。\n */\nfunction maxModeSum(n: number, counts: number[]): number",
      "fr": "/**\n * Étant donné n entiers positifs représentant le compte de chaque nombre de 1 à n,\n * trouver la somme maximale du mode (élément le plus fréquent) pour tous les préfixes d'une\n * séquence construite à partir de ces nombres. Le mode est le plus grand nombre\n * parmi les éléments les plus fréquents dans une séquence.\n * Par exemple :\n *   maxModeSum(3, [1, 2, 3])\n *   Une séquence qui atteint sa valeur maximale est [3, 2, 3, 1, 2, 2], et la somme est 17.\n */\nfunction maxModeSum(n: number, counts: number[]): number",
      "de": "/**\n * Gegeben sind n positive ganze Zahlen, die die Anzahl jedes Zahl von 1 bis n darstellen,\n * finde die maximale Summe des Modus (häufigstes Element) für alle Präfixe einer\n * Sequenz, die aus diesen Zahlen konstruiert wird. Der Modus ist die größte Zahl\n * unter den häufigsten Elementen in einer Sequenz.\n * Zum Beispiel:\n *   maxModeSum(3, [1, 2, 3])\n *   Eine Sequenz, die ihren maximalen Wert erreicht, ist [3, 2, 3, 1, 2, 2], und die Summe ist 17.\n */\nfunction maxModeSum(n: number, counts: number[]): number",
      "ha": "/**\n * An ba da n lambobi masu kyau waɗanda ke wakiltar adadin kowace lamba daga 1 zuwa n,\n * nemo mafi girman jimlar yanayin (abu mafi yawan faruwa) don dukkanin farkon\n * jerin da aka gina daga waɗannan lambobin. Yanayin shine mafi girman lamba\n * tsakanin abubuwan da suka fi yawa a cikin jerin.\n * Alal misali:\n *   maxModeSum(3, [1, 2, 3])\n *   Jerin da ya kai matsakaicin ƙimarsa shine [3, 2, 3, 1, 2, 2], kuma jimlar ita ce 17.\n */\nfunction maxModeSum(n: number, counts: number[]): number",
      "hi": "/**\n * n धनात्मक पूर्णांक दिए गए हैं जो 1 से n तक प्रत्येक संख्या की गिनती का प्रतिनिधित्व करते हैं,\n * उन सभी अनुक्रमों के उपसर्गों के लिए मोड (सबसे अधिक बार आने वाला तत्व) का अधिकतम योग खोजें \n * जो इन संख्याओं से निर्मित होते हैं। मोड एक अनुक्रम में सबसे अधिक बार आने वाले तत्वों में सबसे बड़ा संख्या है।\n * उदाहरण के लिए:\n *   maxModeSum(3, [1, 2, 3])\n *   एक अनुक्रम जो अपने अधिकतम मान तक पहुँचता है वह है [3, 2, 3, 1, 2, 2], और योग 17 है।\n */\nfunction maxModeSum(n: number, counts: number[]): number",
      "hu": "/**\n * Adott n pozitív egész szám, amelyek az 1-től n-ig terjedő számok számosságát képviselik,\n * keresse meg a módusz (leggyakoribb elem) maximális összegét a \n * ezekből a számokból felépített sorozat összes előtagjára. A módusz a legnagyobb szám \n * a sorozat leggyakoribb elemei között.\n * Például:\n *   maxModeSum(3, [1, 2, 3])\n *   Egy sorozat, amely eléri a maximális értékét: [3, 2, 3, 1, 2, 2], és az összeg 17.\n */\nfunction maxModeSum(n: number, counts: number[]): number"
    },
    "prompt_bertscore": {
      "sq": "0.9942577943146624",
      "hy": "0.9717456228193113",
      "bn": "0.9937349991517785",
      "bg": "0.9888220753072616",
      "zh": "0.9737227896321325",
      "fr": "0.9986648065786835",
      "de": "0.9938309376258184",
      "ha": "0.9562780764177435",
      "hi": "0.963847482978221",
      "hu": "0.9801107426862146"
    },
    "canonical_solution": "{\n  let ans = 0;\n  let mx = 0;\n  let f = new Array(100000).fill(0); // Initialize the array with zeroes\n  \n  for (let i = 0; i < n; ++i) {\n    f[i] = 0;\n  }\n  \n  for (let i = n; i > 0; --i) {\n    while (mx < counts[i - 1]) {\n      mx++;\n      f[mx] = f[mx - 1] + i;\n    }\n    ans += f[counts[i - 1]];\n  }\n  return ans;\n}",
    "instruction": {
      "en": "Write a TypeScript function `function maxModeSum(n: number, counts: number[]): number` to solve the following problem:\nGiven n positive integers representing the count of each number from 1 to n, find the maximum sum of the mode (most frequent element) for all prefixes of a sequence constructed from these numbers. The mode is the largest number among the most frequent elements in a sequence.\nFor example:\n  maxModeSum(3, [1, 2, 3])\n  A sequence that reaches its maximum value is [3, 2, 3, 1, 2, 2], and the sum is 17.",
      "sq": "Shkruani një funksion TypeScript `function maxModeSum(n: number, counts: number[]): number` për të zgjidhur problemin në vijim:\nDuke pasur n numra pozitivë që përfaqësojnë numrin e secilit numër nga 1 deri në n, gjeni shumën maksimale të modës (elementi më i shpeshtë) për të gjitha prefikset e një sekuence të ndërtuar nga këta numra. Moda është numri më i madh ndër elementët më të shpeshtë në një sekuencë.\nPër shembull:\n  maxModeSum(3, [1, 2, 3])\n  Një sekuencë që arrin vlerën e saj maksimale është [3, 2, 3, 1, 2, 2], dhe shuma është 17.",
      "hy": "Գրեք TypeScript ֆունկցիա `function maxModeSum(n: number, counts: number[]): number` հետևյալ խնդիրը լուծելու համար:\nՏրված է n դրական ամբողջ թիվ, որոնք ներկայացնում են 1-ից n թվերի քանակը, գտնել մաքսիմալ գումարը մոդի (ամենահաճախ հանդիպող տարրը) բոլոր նախածանցների համար հաջորդականության, որը կառուցված է այս թվերից: Մոդը հաջորդականության ամենահաճախ հանդիպող տարրերի մեջ ամենամեծ թիվն է:\nՕրինակ:\n  maxModeSum(3, [1, 2, 3])\n  Հաջորդականություն, որը հասնում է իր մաքսիմալ արժեքին, [3, 2, 3, 1, 2, 2] է, և գումարը 17 է:",
      "bn": "TypeScript ফাংশন `function maxModeSum(n: number, counts: number[]): number` লিখুন নিম্নলিখিত সমস্যার সমাধানের জন্য:\nnটি ধনাত্মক পূর্ণসংখ্যা দেওয়া হয়েছে যা 1 থেকে n পর্যন্ত প্রতিটি সংখ্যার গণনা উপস্থাপন করে, একটি ক্রম থেকে নির্মিত সমস্ত উপসর্গের জন্য মোডের (সবচেয়ে ঘন ঘন উপাদান) সর্বাধিক যোগফল খুঁজে বের করুন। মোড হল একটি ক্রমের সবচেয়ে ঘন ঘন উপাদানগুলির মধ্যে বৃহত্তম সংখ্যা।\nউদাহরণস্বরূপ:\n  maxModeSum(3, [1, 2, 3])\n  একটি ক্রম যা তার সর্বাধিক মানে পৌঁছায় তা হল [3, 2, 3, 1, 2, 2], এবং যোগফল হল 17।",
      "bg": "Напишете функция на TypeScript `function maxModeSum(n: number, counts: number[]): number`, за да решите следния проблем:  \nДадени са n положителни цели числа, представляващи броя на всяко число от 1 до n, намерете максималната сума на модата (най-често срещания елемент) за всички префикси на последователност, конструирана от тези числа. Модата е най-голямото число сред най-често срещаните елементи в последователност.  \nНапример:  \n  maxModeSum(3, [1, 2, 3])  \n  Последователност, която достига максималната си стойност, е [3, 2, 3, 1, 2, 2], и сумата е 17.",
      "zh": "编写一个 TypeScript 函数 `function maxModeSum(n: number, counts: number[]): number` 来解决以下问题：\n给定 n 个正整数，表示从 1 到 n 的每个数字的计数，找到从这些数字构造的序列的所有前缀的众数（最频繁元素）的最大和。众数是在序列中最频繁元素中最大的数字。\n例如：\n  maxModeSum(3, [1, 2, 3])\n  一个达到最大值的序列是 [3, 2, 3, 1, 2, 2]，和为 17。",
      "fr": "Écrire une fonction TypeScript `function maxModeSum(n: number, counts: number[]): number` pour résoudre le problème suivant :\nÉtant donné n entiers positifs représentant le nombre de chaque nombre de 1 à n, trouver la somme maximale du mode (élément le plus fréquent) pour tous les préfixes d'une séquence construite à partir de ces nombres. Le mode est le plus grand nombre parmi les éléments les plus fréquents dans une séquence.\nPar exemple :\n  maxModeSum(3, [1, 2, 3])\n  Une séquence qui atteint sa valeur maximale est [3, 2, 3, 1, 2, 2], et la somme est 17.",
      "de": "Schreiben Sie eine TypeScript-Funktion `function maxModeSum(n: number, counts: number[]): number`, um das folgende Problem zu lösen:\nGegeben sind n positive ganze Zahlen, die die Anzahl jedes Zahl von 1 bis n darstellen. Finden Sie die maximale Summe des Modus (häufigstes Element) für alle Präfixe einer Sequenz, die aus diesen Zahlen konstruiert wird. Der Modus ist die größte Zahl unter den häufigsten Elementen in einer Sequenz.\nZum Beispiel:\n  maxModeSum(3, [1, 2, 3])\n  Eine Sequenz, die ihren maximalen Wert erreicht, ist [3, 2, 3, 1, 2, 2], und die Summe ist 17.",
      "ha": "Rubuta aikin TypeScript `function maxModeSum(n: number, counts: number[]): number` don warware matsalar mai zuwa:\nAn ba da lambobi masu kyau n da ke wakiltar adadin kowace lamba daga 1 zuwa n, nemo mafi girman jimillar yanayin (abun da ya fi yawa) don dukkanin farkon jerin da aka gina daga waɗannan lambobin. Yanayin shine mafi girman lamba a cikin abubuwan da suka fi yawa a cikin jerin.\nMisali:\n  maxModeSum(3, [1, 2, 3])\n  Jerin da ya kai matsakaicin ƙimarsa shine [3, 2, 3, 1, 2, 2], kuma jimillar ita ce 17.",
      "hi": "TypeScript फ़ंक्शन `function maxModeSum(n: number, counts: number[]): number` लिखें ताकि निम्नलिखित समस्या का समाधान किया जा सके:\nदिए गए n धनात्मक पूर्णांक, जो 1 से n तक प्रत्येक संख्या की गिनती का प्रतिनिधित्व करते हैं, के लिए उन सभी अनुक्रमों के उपसर्गों के लिए मोड (सबसे अधिक बार आने वाला तत्व) का अधिकतम योग खोजें। मोड एक अनुक्रम में सबसे अधिक बार आने वाले तत्वों में सबसे बड़ी संख्या है।\nउदाहरण के लिए:\n  maxModeSum(3, [1, 2, 3])\n  एक अनुक्रम जो अपने अधिकतम मान तक पहुँचता है वह है [3, 2, 3, 1, 2, 2], और योग 17 है।",
      "hu": "Írj egy TypeScript függvényt `function maxModeSum(n: number, counts: number[]): number` a következő probléma megoldására:\nAdott n pozitív egész szám, amelyek az 1-től n-ig terjedő számok előfordulásait képviselik. Találd meg a módusz (leggyakrabban előforduló elem) maximális összegét a számokból felépített sorozat minden prefixére. A módusz a sorozat leggyakrabban előforduló elemei közül a legnagyobb szám.\nPéldául:\n  maxModeSum(3, [1, 2, 3])\n  Egy sorozat, amely eléri a maximális értékét: [3, 2, 3, 1, 2, 2], és az összeg 17."
    },
    "instruction_bertscore": {
      "sq": "0.9903676183020941",
      "hy": "0.9605611433239988",
      "bn": "0.9659209855258443",
      "bg": "0.981086415117858",
      "zh": "0.9813180181421446",
      "fr": "1",
      "de": "0.9920104901836337",
      "ha": "0.962537515615296",
      "hi": "0.9438382529142906",
      "hu": "0.956451282110006"
    },
    "level": "easy",
    "test": "(function testMaxModeSum(): void {\n  console.assert(maxModeSum(3, [1, 3, 2]) === 17, 'Test case 1 failed');\n  console.assert(maxModeSum(4, [4, 1, 2, 3]) === 37, 'Test case 2 failed');\n  console.assert(maxModeSum(2, [1, 1]) === 4, 'Test case 3 failed');\n  console.assert(maxModeSum(5, [1, 2, 3, 4, 5]) === 75, 'Test case 4 failed');\n  console.assert(maxModeSum(1, [100000]) === 100000, 'Test case 5 failed');\n  console.assert(maxModeSum(5, [5, 3, 2, 4, 1]) === 62, 'Test case 6 failed');\n  console.assert(maxModeSum(3, [100000, 100000, 100000]) === 900000, 'Test case 7 failed');\n  console.assert(maxModeSum(3, [2, 2, 5]) === 27, 'Test case 8 failed');\n  console.assert(maxModeSum(4, [4, 4, 4, 4]) === 64, 'Test case 9 failed');\n  console.assert(maxModeSum(6, [1, 2, 3, 4, 5, 6]) === 126, 'Test case 10 failed');\n  console.assert(maxModeSum(3, [3, 1, 2]) === 16, 'Test case 11 failed');\n})();",
    "entry_point": "maxModeSum",
    "signature": "function maxModeSum(n: number, counts: number[]): number",
    "docstring": {
      "en": "Given n positive integers representing the count of each number from 1 to n, find the maximum sum of the mode (most frequent element) for all prefixes of a sequence constructed from these numbers. The mode is the largest number among the most frequent elements in a sequence.\nFor example:\n  maxModeSum(3, [1, 2, 3])\n  A sequence that reaches its maximum value is [3, 2, 3, 1, 2, 2], and the sum is 17.",
      "sq": "Duke pasur n numra të plotë pozitivë që përfaqësojnë numrin e secilit numër nga 1 deri në n, gjeni shumën maksimale të modës (elementi më i shpeshtë) për të gjitha parashtesat e një sekuence të ndërtuar nga këta numra. Moda është numri më i madh ndër elementët më të shpeshtë në një sekuencë.\nPër shembull:\n  maxModeSum(3, [1, 2, 3])\n  Një sekuencë që arrin vlerën e saj maksimale është [3, 2, 3, 1, 2, 2], dhe shuma është 17.",
      "hy": "Տրված են n դրական ամբողջ թվեր, որոնք ներկայացնում են 1-ից n թվերի քանակը, գտնել մաքսիմալ գումարը մոդի (ամենահաճախ հանդիպող տարրը) բոլոր նախածանցների համար, որոնք կառուցված են այս թվերից։ Մոդը ամենամեծ թիվն է ամենահաճախ հանդիպող տարրերի շարքում։\nՕրինակ՝\n  maxModeSum(3, [1, 2, 3])\n  Շարքը, որը հասնում է իր մաքսիմալ արժեքին, [3, 2, 3, 1, 2, 2] է, և գումարը 17 է։",
      "bn": "প্রদত্ত n টি ধনাত্মক পূর্ণসংখ্যা যা 1 থেকে n পর্যন্ত প্রতিটি সংখ্যার গণনা উপস্থাপন করে, এই সংখ্যাগুলি থেকে নির্মিত একটি ক্রমের সমস্ত উপসর্গের জন্য মোডের (সবচেয়ে ঘন ঘন উপাদান) সর্বাধিক যোগফল খুঁজুন। মোড হল একটি ক্রমের সবচেয়ে ঘন ঘন উপাদানগুলির মধ্যে বৃহত্তম সংখ্যা। উদাহরণস্বরূপ:\n  maxModeSum(3, [1, 2, 3])\n  একটি ক্রম যা তার সর্বাধিক মানে পৌঁছায় তা হল [3, 2, 3, 1, 2, 2], এবং যোগফল হল 17।",
      "bg": "Дадени са n положителни цели числа, представляващи броя на всяко число от 1 до n. Намерете максималната сума на модата (най-често срещания елемент) за всички префикси на последователност, конструирана от тези числа. Модата е най-голямото число сред най-често срещаните елементи в последователност.\nНапример:\n  maxModeSum(3, [1, 2, 3])\n  Последователност, която достига максималната си стойност, е [3, 2, 3, 1, 2, 2], и сумата е 17.",
      "zh": "给定 n 个正整数，表示从 1 到 n 的每个数字的计数，找出从这些数字构造的序列的所有前缀的众数（最频繁元素）的最大和。众数是序列中最频繁元素中最大的数字。\n例如：\n  maxModeSum(3, [1, 2, 3])\n  达到其最大值的序列是 [3, 2, 3, 1, 2, 2]，和为 17。",
      "fr": "Étant donné n entiers positifs représentant le compte de chaque nombre de 1 à n, trouvez la somme maximale du mode (élément le plus fréquent) pour tous les préfixes d'une séquence construite à partir de ces nombres. Le mode est le plus grand nombre parmi les éléments les plus fréquents dans une séquence.\nPar exemple :\n  maxModeSum(3, [1, 2, 3])\n  Une séquence qui atteint sa valeur maximale est [3, 2, 3, 1, 2, 2], et la somme est 17.",
      "de": "Given n positive integers representing the count of each number from 1 to n, find the maximum sum of the mode (most frequent element) for all prefixes of a sequence constructed from these numbers. The mode is the largest number among the most frequent elements in a sequence.\n\nGegeben n positive ganze Zahlen, die die Anzahl jedes Zahl von 1 bis n darstellen, finde die maximale Summe des Modus (häufigstes Element) für alle Präfixe einer aus diesen Zahlen konstruierten Sequenz. Der Modus ist die größte Zahl unter den häufigsten Elementen in einer Sequenz.\n\nFor example:\n\nZum Beispiel:\n\n  maxModeSum(3, [1, 2, 3])\n  A sequence that reaches its maximum value is [3, 2, 3, 1, 2, 2], and the sum is 17.\n\n  Eine Sequenz, die ihren Maximalwert erreicht, ist [3, 2, 3, 1, 2, 2], und die Summe ist 17.",
      "ha": "An ba n lambobi masu kyau da ke wakiltar adadin kowace lamba daga 1 zuwa n, nemo mafi girman jimillar yanayin (abubuwan da suka fi yawan faruwa) don dukkan farkon jerin da aka gina daga waɗannan lambobin. Yanayin shine mafi girman lamba tsakanin abubuwan da suka fi yawan faruwa a cikin jerin.\nMisali:\n  maxModeSum(3, [1, 2, 3])\n  Wani jeri da ya kai darajarsa mafi girma shine [3, 2, 3, 1, 2, 2], kuma jimillar ita ce 17.",
      "hi": "दिए गए n धनात्मक पूर्णांक जो 1 से n तक प्रत्येक संख्या की गिनती का प्रतिनिधित्व करते हैं, उन सभी अनुक्रमों के उपसर्गों के लिए मोड (सबसे अधिक बार आने वाला तत्व) का अधिकतम योग खोजें जो इन संख्याओं से निर्मित होते हैं। मोड अनुक्रम में सबसे अधिक बार आने वाले तत्वों में सबसे बड़ी संख्या है।\nउदाहरण के लिए:\n  maxModeSum(3, [1, 2, 3])\n  एक अनुक्रम जो अपने अधिकतम मान तक पहुँचता है वह है [3, 2, 3, 1, 2, 2], और योग 17 है।",
      "hu": "Adott n pozitív egész szám, amelyek az 1-től n-ig terjedő számok számosságát jelölik. Keresse meg a legnagyobb összegét a módusznak (leggyakoribb elem) a sorozat minden előtagjára, amelyet ezekből a számokból állítanak össze. A módusz a legnagyobb szám a sorozat leggyakoribb elemei között.\nPéldául:\n  maxModeSum(3, [1, 2, 3])\n  Egy sorozat, amely eléri a maximális értékét, az [3, 2, 3, 1, 2, 2], és az összeg 17."
    },
    "docstring_bertscore": {
      "sq": "0.9948592471084361",
      "hy": "0.9448613980070012",
      "bn": "0.9956066932322704",
      "bg": "0.9763347791427414",
      "zh": "0.9795486187078858",
      "fr": "0.999999801369619",
      "de": "0.999999801369619",
      "ha": "0.9454515288690559",
      "hi": "0.9771310883403103",
      "hu": "0.9333801647224227"
    }
  },
  {
    "task_id": "TypeScript/39",
    "prompt": {
      "en": "\n/**\n * Given an array A of integers, the task is to calculate the sum of the XOR of all subarrays.\n * A subarray is defined by a pair of indices (L, R) such that 1 <= L <= R <= the length of the array.\n * The XOR sum of a subarray is the result of XORing all elements from L to R.\n * The final result is the sum of the XOR sums for all possible subarrays.\n *\n * Example:\n * sumOfXorSubarrays([1, 2, 3, 4, 5])  // returns 39\n */\nfunction sumOfXorSubarrays(A: number[]): number",
      "sq": "/**\n * Duke pasur një varg A të numrave të plotë, detyra është të llogaritet shuma e XOR-it të të gjitha nënvargjeve.\n * Një nënvarg është i përcaktuar nga një çift indeksesh (L, R) të tilla që 1 <= L <= R <= gjatësia e vargut.\n * Shuma e XOR-it të një nënvargu është rezultati i XOR-it të të gjitha elementeve nga L deri në R.\n * Rezultati përfundimtar është shuma e shumave të XOR-it për të gjitha nënvargjet e mundshme.\n *\n * Shembull:\n * sumOfXorSubarrays([1, 2, 3, 4, 5])  // kthen 39\n */\nfunction sumOfXorSubarrays(A: number[]): number",
      "hy": "/**\n * Տրված է ամբողջ թվերի զանգված A, խնդիրն է հաշվել բոլոր ենթազանգվածների XOR-ի գումարը։\n * Ենթազանգվածը սահմանվում է (L, R) զույգ ինդեքսներով, այնպես որ 1 <= L <= R <= զանգվածի երկարությունը։\n * Ենթազանգվածի XOR գումարը արդյունքն է՝ XOR անելով բոլոր տարրերը L-ից R։\n * Վերջնական արդյունքը բոլոր հնարավոր ենթազանգվածների XOR գումարների գումարն է։\n *\n * Օրինակ:\n * sumOfXorSubarrays([1, 2, 3, 4, 5])  // վերադարձնում է 39\n */\nfunction sumOfXorSubarrays(A: number[]): number",
      "bn": "/**\n * একটি পূর্ণসংখ্যার অ্যারে A দেওয়া হলে, কাজটি হল সমস্ত উপঅ্যারের XOR এর যোগফল গণনা করা।\n * একটি উপঅ্যারে একটি জোড়া সূচক (L, R) দ্বারা সংজ্ঞায়িত করা হয় যেখানে 1 <= L <= R <= অ্যারের দৈর্ঘ্য।\n * একটি উপঅ্যারের XOR যোগফল হল L থেকে R পর্যন্ত সমস্ত উপাদানের XOR করার ফলাফল।\n * চূড়ান্ত ফলাফল হল সমস্ত সম্ভাব্য উপঅ্যারের জন্য XOR যোগফলগুলির যোগফল।\n *\n * উদাহরণ:\n * sumOfXorSubarrays([1, 2, 3, 4, 5])  // 39 প্রদান করে\n */\nfunction sumOfXorSubarrays(A: number[]): number",
      "bg": "/**\n * Даден е масив A от цели числа, задачата е да се изчисли сумата на XOR на всички подмасиви.\n * Подмасив се определя от двойка индекси (L, R) така че 1 <= L <= R <= дължината на масива.\n * XOR сумата на подмасив е резултатът от XOR на всички елементи от L до R.\n * Крайният резултат е сумата на XOR сумите за всички възможни подмасиви.\n *\n * Пример:\n * sumOfXorSubarrays([1, 2, 3, 4, 5])  // връща 39\n */\nfunction sumOfXorSubarrays(A: number[]): number",
      "zh": "/**\n * 给定一个整数数组A，任务是计算所有子数组的异或和的总和。\n * 子数组由一对索引(L, R)定义，其中1 <= L <= R <= 数组的长度。\n * 子数组的异或和是从L到R的所有元素的异或结果。\n * 最终结果是所有可能子数组的异或和的总和。\n *\n * 示例:\n * sumOfXorSubarrays([1, 2, 3, 4, 5])  // 返回39\n */\nfunction sumOfXorSubarrays(A: number[]): number",
      "fr": "/**\n * Étant donné un tableau A d'entiers, la tâche consiste à calculer la somme du XOR de tous les sous-tableaux.\n * Un sous-tableau est défini par une paire d'indices (L, R) telle que 1 <= L <= R <= la longueur du tableau.\n * La somme XOR d'un sous-tableau est le résultat du XOR de tous les éléments de L à R.\n * Le résultat final est la somme des sommes XOR pour tous les sous-tableaux possibles.\n *\n * Exemple:\n * sumOfXorSubarrays([1, 2, 3, 4, 5])  // retourne 39\n */\nfunction sumOfXorSubarrays(A: number[]): number",
      "de": "/**\n * Gegeben ein Array A von ganzen Zahlen, besteht die Aufgabe darin, die Summe des XOR aller Teilarrays zu berechnen.\n * Ein Teilarray wird durch ein Paar von Indizes (L, R) definiert, so dass 1 <= L <= R <= die Länge des Arrays.\n * Die XOR-Summe eines Teilarrays ist das Ergebnis des XORs aller Elemente von L bis R.\n * Das Endergebnis ist die Summe der XOR-Summen für alle möglichen Teilarrays.\n *\n * Beispiel:\n * sumOfXorSubarrays([1, 2, 3, 4, 5])  // gibt 39 zurück\n */\nfunction sumOfXorSubarrays(A: number[]): number",
      "ha": "/**\n * An ba da jerin A na lambobin tsaka-tsaki, aikin shi ne a lissafta jimillar XOR na dukkan ƙananan jerin.\n * An ayyana ƙaramin jeri ta hanyar ma'aurata na alamomin (L, R) ta yadda 1 <= L <= R <= tsawon jerin.\n * Jimillar XOR na ƙaramin jeri ita ce sakamakon XORing dukkan abubuwa daga L zuwa R.\n * Sakamakon ƙarshe shi ne jimillar XOR sums don dukkan yiwuwar ƙananan jerin.\n *\n * Misali:\n * sumOfXorSubarrays([1, 2, 3, 4, 5])  // yana dawowa 39\n */\nfunction sumOfXorSubarrays(A: number[]): number",
      "hi": "/**\n * दिए गए पूर्णांकों की एक array A के लिए, कार्य यह है कि सभी subarrays के XOR का योग गणना करें।\n * एक subarray को (L, R) सूचकांक की एक जोड़ी द्वारा परिभाषित किया जाता है जिससे 1 <= L <= R <= array की लंबाई।\n * एक subarray का XOR योग L से R तक के सभी तत्वों का XOR करने का परिणाम है।\n * अंतिम परिणाम सभी संभावित subarrays के लिए XOR योग का योग है।\n *\n * उदाहरण:\n * sumOfXorSubarrays([1, 2, 3, 4, 5])  // 39 लौटाता है\n */\nfunction sumOfXorSubarrays(A: number[]): number",
      "hu": "/**\n * Adott egy A egész számokat tartalmazó tömb, a feladat az, hogy kiszámítsuk az összes részhalmaz XOR összegét.\n * Egy részhalmazt egy (L, R) indexpár határoz meg, ahol 1 <= L <= R <= a tömb hossza.\n * Egy részhalmaz XOR összege az L-től R-ig terjedő összes elem XOR-olásának eredménye.\n * A végső eredmény az összes lehetséges részhalmaz XOR összegeinek összege.\n *\n * Példa:\n * sumOfXorSubarrays([1, 2, 3, 4, 5])  // visszaadja 39\n */\nfunction sumOfXorSubarrays(A: number[]): number"
    },
    "prompt_bertscore": {
      "sq": "0.9919703668466646",
      "hy": "0.9789829193826984",
      "bn": "0.9911245986842181",
      "bg": "0.9914346607090135",
      "zh": "0.9649032034534215",
      "fr": "0.9927948815583405",
      "de": "0.9927948815583405",
      "ha": "0.9673177543652816",
      "hi": "0.9827058486144354",
      "hu": "0.9780680278476518"
    },
    "canonical_solution": "{\n    const n: number = A.length;\n    let q: number[] = new Array(n + 1).fill(0);\n    let w: number[][] = Array.from({ length: 21 }, () => [0, 0]);\n    let ans: number = 0;\n\n    for (let i = 1; i <= n; i++) {\n        q[i] = q[i - 1] ^ A[i - 1];\n    }\n\n    for (let i = 0; i <= n; i++) {\n        for (let j = 20; j >= 0; j--) {\n            w[j][(q[i] >> j) & 1]++;\n        }\n    }\n\n    for (let i = 0; i <= 20; i++) {\n        ans += w[i][0] * w[i][1] * (1 << i);\n    }\n\n    return ans;\n};",
    "instruction": {
      "en": "Write a TypeScript function `function sumOfXorSubarrays(A: number[]): number` to solve the following problem:\nGiven an array A of integers, the task is to calculate the sum of the XOR of all subarrays.\nA subarray is defined by a pair of indices (L, R) such that 1 <= L <= R <= the length of the array.\nThe XOR sum of a subarray is the result of XORing all elements from L to R.\nThe final result is the sum of the XOR sums for all possible subarrays.\n\nExample:\nsumOfXorSubarrays([1, 2, 3, 4, 5])  // returns 39\n",
      "sq": "Shkruani një funksion TypeScript `function sumOfXorSubarrays(A: number[]): number` për të zgjidhur problemin e mëposhtëm:\nDuke pasur një varg A të numrave të plotë, detyra është të llogaritet shuma e XOR e të gjitha nënvargjeve.\nNjë nënvarg përcaktohet nga një çift indeksesh (L, R) të tilla që 1 <= L <= R <= gjatësia e vargut.\nShuma XOR e një nënvargu është rezultati i XOR-it të të gjithë elementeve nga L në R.\nRezultati përfundimtar është shuma e shumave XOR për të gjitha nënvargjet e mundshme.\n\nShembull:\nsumOfXorSubarrays([1, 2, 3, 4, 5])  // kthen 39",
      "hy": "Գրեք TypeScript ֆունկցիա `function sumOfXorSubarrays(A: number[]): number`՝ լուծելու հետևյալ խնդիրը:\nՏրված է ամբողջ թվերի զանգված A, խնդիրը հաշվարկել է բոլոր ենթազանգվածների XOR-ի գումարը:\nԵնթազանգվածը սահմանվում է (L, R) զույգ ինդեքսներով, այնպես, որ 1 <= L <= R <= զանգվածի երկարությունը:\nԵնթազանգվածի XOR գումարը արդյունքն է՝ XOR անելով բոլոր տարրերը L-ից R:\nՎերջնական արդյունքը բոլոր հնարավոր ենթազանգվածների XOR գումարների գումարն է:\n\nՕրինակ:\nsumOfXorSubarrays([1, 2, 3, 4, 5])  // վերադարձնում է 39",
      "bn": "TypeScript ফাংশন `function sumOfXorSubarrays(A: number[]): number` লিখুন নিম্নলিখিত সমস্যার সমাধানের জন্য:\nএকটি পূর্ণসংখ্যার অ্যারে A দেওয়া আছে, কাজটি হল সমস্ত উপঅ্যারের XOR এর যোগফল গণনা করা।\nএকটি উপঅ্যারে একটি জোড়া সূচক (L, R) দ্বারা সংজ্ঞায়িত হয় যেখানে 1 <= L <= R <= অ্যারের দৈর্ঘ্য।\nএকটি উপঅ্যারের XOR যোগফল হল L থেকে R পর্যন্ত সমস্ত উপাদান XOR করার ফলাফল।\nচূড়ান্ত ফলাফল হল সমস্ত সম্ভাব্য উপঅ্যারের জন্য XOR যোগফলের যোগফল।\n\nউদাহরণ:\nsumOfXorSubarrays([1, 2, 3, 4, 5])  // 39 ফেরত দেয়",
      "bg": "Напишете TypeScript функция `function sumOfXorSubarrays(A: number[]): number`, за да решите следния проблем:\nДаден е масив A от цели числа, задачата е да се изчисли сумата от XOR на всички подмасиви.\nПодмасив се определя от двойка индекси (L, R), такива че 1 <= L <= R <= дължината на масива.\nXOR сумата на подмасив е резултатът от XOR на всички елементи от L до R.\nКрайният резултат е сумата от XOR сумите за всички възможни подмасиви.\n\nПример:\nsumOfXorSubarrays([1, 2, 3, 4, 5])  // връща 39",
      "zh": "编写一个 TypeScript 函数 `function sumOfXorSubarrays(A: number[]): number` 来解决以下问题：\n给定一个整数数组 A，任务是计算所有子数组的异或和的总和。\n子数组由一对索引 (L, R) 定义，其中 1 <= L <= R <= 数组的长度。\n子数组的异或和是从 L 到 R 的所有元素进行异或运算的结果。\n最终结果是所有可能子数组的异或和的总和。\n\n示例：\nsumOfXorSubarrays([1, 2, 3, 4, 5])  // 返回 39",
      "fr": "Écrire une fonction TypeScript `function sumOfXorSubarrays(A: number[]): number` pour résoudre le problème suivant :\nÉtant donné un tableau A d'entiers, la tâche consiste à calculer la somme du XOR de tous les sous-tableaux.\nUn sous-tableau est défini par une paire d'indices (L, R) telle que 1 <= L <= R <= la longueur du tableau.\nLa somme XOR d'un sous-tableau est le résultat du XOR de tous les éléments de L à R.\nLe résultat final est la somme des sommes XOR pour tous les sous-tableaux possibles.\n\nExemple :\nsumOfXorSubarrays([1, 2, 3, 4, 5])  // retourne 39",
      "de": "Schreiben Sie eine TypeScript-Funktion `function sumOfXorSubarrays(A: number[]): number`, um das folgende Problem zu lösen:\nGegeben ein Array A von ganzen Zahlen, besteht die Aufgabe darin, die Summe des XOR aller Teilarrays zu berechnen.\nEin Teilarray wird durch ein Paar von Indizes (L, R) definiert, so dass 1 <= L <= R <= die Länge des Arrays.\nDie XOR-Summe eines Teilarrays ist das Ergebnis des XORs aller Elemente von L bis R.\nDas Endergebnis ist die Summe der XOR-Summen für alle möglichen Teilarrays.\n\nBeispiel:\nsumOfXorSubarrays([1, 2, 3, 4, 5])  // gibt 39 zurück",
      "ha": "Rubuta aikin TypeScript `function sumOfXorSubarrays(A: number[]): number` don warware matsalar mai zuwa:\nAn ba da jerin lambobi A, aikin shi ne a ƙididdige jimillar XOR na dukkan ƙananan jerin.\nAna ayyana ƙaramin jeri ta hanyar ma'aurata na alamomi (L, R) inda 1 <= L <= R <= tsawon jerin.\nJimillar XOR na ƙaramin jeri ita ce sakamakon XORing dukkan abubuwa daga L zuwa R.\nSakamakon ƙarshe shi ne jimillar XOR sums don dukkan yiwuwar ƙananan jerin.\n\nMisali:\nsumOfXorSubarrays([1, 2, 3, 4, 5])  // yana dawowa da 39",
      "hi": "TypeScript फ़ंक्शन `function sumOfXorSubarrays(A: number[]): number` लिखें ताकि निम्नलिखित समस्या का समाधान किया जा सके:\nदिए गए पूर्णांकों की एक array A के लिए, कार्य यह है कि सभी subarrays के XOR का योग गणना करें।\nएक subarray को (L, R) सूचकांक की एक जोड़ी द्वारा परिभाषित किया जाता है ताकि 1 <= L <= R <= array की लंबाई हो।\nएक subarray का XOR योग L से R तक के सभी तत्वों का XOR करने का परिणाम होता है।\nअंतिम परिणाम सभी संभावित subarrays के लिए XOR योग का योग है।\n\nउदाहरण:\nsumOfXorSubarrays([1, 2, 3, 4, 5])  // 39 लौटाता है",
      "hu": "Írj egy TypeScript függvényt `function sumOfXorSubarrays(A: number[]): number` a következő probléma megoldására:\nAdott egy A egész számokat tartalmazó tömb, a feladat az, hogy kiszámítsuk az összes részhalmaz XOR összegét.\nEgy részhalmazt egy (L, R) indexpár határoz meg, ahol 1 <= L <= R <= a tömb hosszúsága.\nEgy részhalmaz XOR összege az L-től R-ig terjedő összes elem XOR-olásának eredménye.\nA végső eredmény az összes lehetséges részhalmaz XOR összegeinek összege.\n\nPélda:\nsumOfXorSubarrays([1, 2, 3, 4, 5])  // visszaadja 39"
    },
    "instruction_bertscore": {
      "sq": "0.9881544785966034",
      "hy": "0.9810822438798562",
      "bn": "0.9650553543252942",
      "bg": "0.9870663813692943",
      "zh": "0.9656395262759178",
      "fr": "0.9940663146273447",
      "de": "0.9940663146273447",
      "ha": "0.9626578856262031",
      "hi": "0.9793837554916269",
      "hu": "0.9848119265445483"
    },
    "level": "middle",
    "test": "const testSumOfXorSubarrays = (): void => {\n    console.assert(sumOfXorSubarrays([1, 2, 3, 4, 5]) === 39);\n    console.assert(sumOfXorSubarrays([1, 1, 1]) === 4);\n    console.assert(sumOfXorSubarrays([2, 3, 1]) === 9);\n    console.assert(sumOfXorSubarrays([4, 5, 7, 9]) === 74);\n    console.assert(sumOfXorSubarrays([0, 0, 0, 0]) === 0);\n    console.assert(sumOfXorSubarrays([8, 8, 8, 8, 8]) === 72);\n    console.assert(sumOfXorSubarrays([3, 6, 9, 12, 15]) === 125);\n    console.assert(sumOfXorSubarrays([10, 20, 30, 40, 50]) === 390);\n    console.assert(sumOfXorSubarrays([16, 16, 16, 16, 16, 16]) === 192);\n    console.assert(sumOfXorSubarrays([1, 3, 5, 7, 9, 11, 13]) === 192);\n    console.assert(sumOfXorSubarrays([0, 1, 2, 3, 4, 5, 6, 7, 8, 9]) === 218);\n};\n\ntestSumOfXorSubarrays();",
    "entry_point": "sumOfXorSubarrays",
    "signature": "function sumOfXorSubarrays(A: number[]): number",
    "docstring": {
      "en": "Given an array A of integers, the task is to calculate the sum of the XOR of all subarrays.\nA subarray is defined by a pair of indices (L, R) such that 1 <= L <= R <= the length of the array.\nThe XOR sum of a subarray is the result of XORing all elements from L to R.\nThe final result is the sum of the XOR sums for all possible subarrays.\n\nExample:\nsumOfXorSubarrays([1, 2, 3, 4, 5])  // returns 39\n",
      "sq": "Duke pasur një varg A të numrave të plotë, detyra është të llogaritet shuma e XOR-it të të gjitha nënvargjeve.\nNjë nënvarg përcaktohet nga një çift indeksesh (L, R) të tilla që 1 <= L <= R <= gjatësia e vargut.\nShuma XOR e një nënvargu është rezultati i XOR-it të të gjithë elementeve nga L në R.\nRezultati përfundimtar është shuma e shumave XOR për të gjitha nënvargjet e mundshme.\n\nShembull:\nsumOfXorSubarrays([1, 2, 3, 4, 5])  // kthen 39",
      "hy": "Տրված է A ամբողջ թվերի զանգվածը, խնդիրն է հաշվարկել բոլոր ենթազանգվածների XOR-ի գումարը։  \nԵնթազանգվածը սահմանվում է (L, R) ինդեքսների զույգով, այնպես որ 1 <= L <= R <= զանգվածի երկարությունը։  \nԵնթազանգվածի XOR-ի գումարը L-ից R բոլոր տարրերի XOR-ի արդյունքն է։  \nՎերջնական արդյունքը բոլոր հնարավոր ենթազանգվածների համար XOR-ի գումարների գումարն է։  \n\nՕրինակ:  \nsumOfXorSubarrays([1, 2, 3, 4, 5])  // վերադարձնում է 39",
      "bn": "একটি পূর্ণসংখ্যার অ্যারে A দেওয়া হয়েছে, কাজটি হল সমস্ত উপঅ্যারের XOR এর যোগফল গণনা করা।\nএকটি উপঅ্যারে (L, R) জোড়া দ্বারা সংজ্ঞায়িত করা হয় যেখানে 1 <= L <= R <= অ্যারের দৈর্ঘ্য।\nএকটি উপঅ্যারের XOR যোগফল হল L থেকে R পর্যন্ত সমস্ত উপাদানের XOR এর ফলাফল।\nচূড়ান্ত ফলাফল হল সমস্ত সম্ভাব্য উপঅ্যারের জন্য XOR যোগফলের যোগফল।\n\nউদাহরণ:\nsumOfXorSubarrays([1, 2, 3, 4, 5])  // 39 প্রদান করে",
      "bg": "Даден е масив A от цели числа, задачата е да се изчисли сумата на XOR на всички подмасиви.\nПодмасив се дефинира чрез двойка индекси (L, R), така че 1 <= L <= R <= дължината на масива.\nXOR сумата на подмасив е резултатът от XOR на всички елементи от L до R.\nКрайният резултат е сумата от XOR сумите за всички възможни подмасиви.\n\nПример:\nsumOfXorSubarrays([1, 2, 3, 4, 5])  // връща 39",
      "zh": "给定一个整数数组 A，任务是计算所有子数组的异或和的总和。\n子数组由一对索引 (L, R) 定义，其中 1 <= L <= R <= 数组的长度。\n子数组的异或和是从 L 到 R 的所有元素进行异或运算的结果。\n最终结果是所有可能子数组的异或和的总和。\n\n示例：\nsumOfXorSubarrays([1, 2, 3, 4, 5])  // 返回 39",
      "fr": "Étant donné un tableau A d'entiers, la tâche consiste à calculer la somme du XOR de tous les sous-tableaux.\nUn sous-tableau est défini par une paire d'indices (L, R) telle que 1 <= L <= R <= la longueur du tableau.\nLa somme XOR d'un sous-tableau est le résultat du XOR de tous les éléments de L à R.\nLe résultat final est la somme des sommes XOR pour tous les sous-tableaux possibles.\n\nExemple :\nsumOfXorSubarrays([1, 2, 3, 4, 5])  // retourne 39",
      "de": "Gegeben ein Array A von ganzen Zahlen, besteht die Aufgabe darin, die Summe des XOR aller Teilarrays zu berechnen.\nEin Teilarray wird durch ein Paar von Indizes (L, R) definiert, so dass 1 <= L <= R <= die Länge des Arrays.\nDie XOR-Summe eines Teilarrays ist das Ergebnis des XORs aller Elemente von L bis R.\nDas Endergebnis ist die Summe der XOR-Summen für alle möglichen Teilarrays.\n\nBeispiel:\nsumOfXorSubarrays([1, 2, 3, 4, 5])  // gibt 39 zurück",
      "ha": "An ba da wani tsararren A na lambobin cikakke, aikin shi ne a ƙididdige jimillar XOR na dukkan ƙananan tsararraki.\nAna ayyana ƙananan tsararrai ta hanyar ma'aurata na alamomin (L, R) inda 1 <= L <= R <= tsawon tsararren.\nJimillar XOR na wani ƙaramin tsararre ita ce sakamakon XORing dukkan abubuwa daga L zuwa R.\nSakamakon ƙarshe shi ne jimillar XOR sums don dukkan yiwuwar ƙananan tsararraki.\n\nMisali:\nsumOfXorSubarrays([1, 2, 3, 4, 5])  // yana dawowa 39",
      "hi": "दिए गए पूर्णांकों की एक सरणी A के लिए, कार्य सभी उपसरणियों के XOR का योग गणना करना है। \nएक उपसरणी को (L, R) सूचकांकों की एक जोड़ी द्वारा परिभाषित किया जाता है, जहाँ 1 <= L <= R <= सरणी की लंबाई। \nएक उपसरणी का XOR योग L से R तक के सभी तत्वों का XOR करने का परिणाम है। \nअंतिम परिणाम सभी संभावित उपसरणियों के लिए XOR योगों का योग है।\n\nउदाहरण:\nsumOfXorSubarrays([1, 2, 3, 4, 5])  // 39 लौटाता है",
      "hu": "Egy A egész számokat tartalmazó tömb esetén a feladat az összes részhalmaz XOR összegének kiszámítása.\nEgy részhalmazt egy (L, R) indexpár határoz meg, ahol 1 <= L <= R <= a tömb hossza.\nEgy részhalmaz XOR összege az L-től R-ig terjedő elemek XOR-ának eredménye.\nA végső eredmény az összes lehetséges részhalmaz XOR összegeinek összege.\n\nPélda:\nsumOfXorSubarrays([1, 2, 3, 4, 5])  // visszaadja 39"
    },
    "docstring_bertscore": {
      "sq": "0.9897832477210895",
      "hy": "0.9730170558883157",
      "bn": "0.9483622584727411",
      "bg": "0.9820628820710254",
      "zh": "0.9598971219601992",
      "fr": "0.9910803041092473",
      "de": "0.9910803041092473",
      "ha": "0.9575572560716082",
      "hi": "0.9891571647600675",
      "hu": "0.9518732490879138"
    }
  },
  {
    "task_id": "TypeScript/40",
    "prompt": {
      "en": "\n/**\n * Given two positive integers n and k, find the number of positive integers x,\n * where 1 <= x <= n, that can be expressed as x = a^b with a and b being positive integers\n * and b >= k. Different legal representations of the same number are counted only once.\n * Example:\n *   countPowerNumbers(99, 1) returns 99\n */\nfunction countPowerNumbers(n: number, k: number): number {",
      "sq": "/**\n * Duke pasur dy numra të plotë pozitivë n dhe k, gjeni numrin e numrave të plotë pozitivë x,\n * ku 1 <= x <= n, që mund të shprehen si x = a^b me a dhe b që janë numra të plotë pozitivë\n * dhe b >= k. Përfaqësimet e ndryshme të ligjshme të të njëjtit numër numërohen vetëm një herë.\n * Shembull:\n *   countPowerNumbers(99, 1) kthen 99\n */\nfunction countPowerNumbers(n: number, k: number): number {",
      "hy": "/**\n * Տրված են n և k դրական ամբողջ թվերը, գտնել դրական ամբողջ թվերի x քանակը,\n * որտեղ 1 <= x <= n, որոնք կարող են արտահայտվել որպես x = a^b, որտեղ a և b դրական ամբողջ թվեր են\n * և b >= k։ Նույն թվի տարբեր թույլատրելի ներկայացումները հաշվում են միայն մեկ անգամ։\n * Օրինակ:\n *   countPowerNumbers(99, 1) վերադարձնում է 99\n */\nfunction countPowerNumbers(n: number, k: number): number {",
      "bn": "/**\n * দুটি ধনাত্মক পূর্ণসংখ্যা n এবং k দেওয়া আছে, 1 <= x <= n এর মধ্যে কতগুলি ধনাত্মক পূর্ণসংখ্যা x আছে তা খুঁজে বের করুন,\n * যা x = a^b হিসাবে প্রকাশ করা যায় যেখানে a এবং b ধনাত্মক পূর্ণসংখ্যা এবং b >= k। একই সংখ্যার বিভিন্ন বৈধ উপস্থাপনাকে কেবল একবার গণনা করা হয়।\n * উদাহরণ:\n *   countPowerNumbers(99, 1) 99 প্রদান করে\n */\nfunction countPowerNumbers(n: number, k: number): number {",
      "bg": "/**\n * Дадени са две положителни цели числа n и k, намерете броя на положителните цели числа x,\n * където 1 <= x <= n, които могат да бъдат изразени като x = a^b с a и b, които са положителни цели числа\n * и b >= k. Различните легални представяния на едно и също число се броят само веднъж.\n * Пример:\n *   countPowerNumbers(99, 1) връща 99\n */\nfunction countPowerNumbers(n: number, k: number): number {",
      "zh": "/**\n * 给定两个正整数 n 和 k，找出有多少个正整数 x，\n * 其中 1 <= x <= n，可以表示为 x = a^b，a 和 b 为正整数\n * 且 b >= k。相同数字的不同合法表示只计数一次。\n * 例子:\n *   countPowerNumbers(99, 1) 返回 99\n */\nfunction countPowerNumbers(n: number, k: number): number {",
      "fr": "/**\n * Étant donnés deux entiers positifs n et k, trouver le nombre d'entiers positifs x,\n * où 1 <= x <= n, qui peuvent être exprimés comme x = a^b avec a et b étant des entiers positifs\n * et b >= k. Les différentes représentations légales du même nombre sont comptées une seule fois.\n * Exemple :\n *   countPowerNumbers(99, 1) retourne 99\n */\nfunction countPowerNumbers(n: number, k: number): number {",
      "de": "/**\n * Gegeben zwei positive ganze Zahlen n und k, finde die Anzahl der positiven ganzen Zahlen x,\n * wobei 1 <= x <= n, die als x = a^b ausgedrückt werden können, wobei a und b positive ganze Zahlen sind\n * und b >= k. Verschiedene zulässige Darstellungen derselben Zahl werden nur einmal gezählt.\n * Beispiel:\n *   countPowerNumbers(99, 1) gibt 99 zurück\n */\nfunction countPowerNumbers(n: number, k: number): number {",
      "ha": "/**\n * An ba da lambobi guda biyu masu kyau n da k, nemo yawan lambobi masu kyau x,\n * inda 1 <= x <= n, waɗanda za a iya bayyana su a matsayin x = a^b tare da a da b kasancewa lambobi masu kyau\n * kuma b >= k. Ana ƙidaya daban-daban halattattun wakilcin lamba ɗaya sau ɗaya kawai.\n * Misali:\n *   countPowerNumbers(99, 1) returns 99\n */\nfunction countPowerNumbers(n: number, k: number): number {",
      "hi": "/**\n * दिए गए दो धनात्मक पूर्णांक n और k, उन धनात्मक पूर्णांकों x की संख्या खोजें,\n * जहाँ 1 <= x <= n, जिसे x = a^b के रूप में व्यक्त किया जा सकता है जहाँ a और b धनात्मक पूर्णांक हैं\n * और b >= k. एक ही संख्या के विभिन्न वैध अभ्यावेदन केवल एक बार गिने जाते हैं।\n * उदाहरण:\n *   countPowerNumbers(99, 1) returns 99\n */\nfunction countPowerNumbers(n: number, k: number): number {",
      "hu": "/**\n * Két pozitív egész szám, n és k esetén, találja meg azon pozitív egész számok x számát,\n * ahol 1 <= x <= n, és amelyek kifejezhetők x = a^b alakban, ahol a és b pozitív egész számok\n * és b >= k. Ugyanazon szám különböző legális reprezentációi csak egyszer számítanak.\n * Példa:\n *   countPowerNumbers(99, 1) visszaadja 99\n */\nfunction countPowerNumbers(n: number, k: number): number {"
    },
    "prompt_bertscore": {
      "sq": "0.9928840665994252",
      "hy": "0.9811362713434977",
      "bn": "0.9494229447074675",
      "bg": "0.9928840665994252",
      "zh": "0.967968864754314",
      "fr": "1",
      "de": "0.9860770034413595",
      "ha": "0.9631689615966058",
      "hi": "0.9889996508679069",
      "hu": "0.9561048707254811"
    },
    "canonical_solution": "let count = 0;\n    let x = 0;\n    const mp: boolean[] = new Array(n + 1).fill(false);\n    \n    for (let i = 2; i <= Math.cbrt(n); ++i) {\n        let t = i * i;\n        let m = 2;\n        while (t <= n / i) {\n            t *= i;\n            m++;\n            if (m < k || mp[t]) continue;\n            if (Math.pow(Math.floor(Math.sqrt(t)), 2) === t) x++;\n            mp[t] = true;\n            count++;\n        }\n    }\n    if (k === 1) {\n        count = n;\n    } else if (k >= 3) {\n        count += 1;\n    } else {\n        count += Math.floor(Math.sqrt(n)) - x;\n    }\n    return count;\n}",
    "instruction": {
      "en": "Write a TypeScript function `function countPowerNumbers(n: number, k: number): number` to solve the following problem:\nGiven two positive integers n and k, find the number of positive integers x, where 1 <= x <= n, that can be expressed as x = a^b with a and b being positive integers and b >= k. Different legal representations of the same number are counted only once.\nExample:\n  countPowerNumbers(99, 1) returns 99",
      "sq": "Shkruani një funksion TypeScript `function countPowerNumbers(n: number, k: number): number` për të zgjidhur problemin në vijim:  \nDuke pasur dy numra të plotë pozitivë n dhe k, gjeni numrin e numrave të plotë pozitivë x, ku 1 <= x <= n, që mund të shprehen si x = a^b me a dhe b që janë numra të plotë pozitivë dhe b >= k. Përfaqësimet e ndryshme të ligjshme të të njëjtit numër numërohen vetëm një herë.  \nShembull:  \n  countPowerNumbers(99, 1) kthen 99",
      "hy": "Գրեք TypeScript ֆունկցիա `function countPowerNumbers(n: number, k: number): number`՝ հետևյալ խնդիրը լուծելու համար:\nՏրված են n և k դրական ամբողջ թվերը, գտնել դրական ամբողջ թվերի քանակը x, որտեղ 1 <= x <= n, որոնք կարող են արտահայտվել որպես x = a^b, որտեղ a և b դրական ամբողջ թվեր են և b >= k: Նույն թվի տարբեր թույլատրելի ներկայացումները հաշվում են միայն մեկ անգամ:\nՕրինակ:\n  countPowerNumbers(99, 1) վերադարձնում է 99",
      "bn": "TypeScript ফাংশন `function countPowerNumbers(n: number, k: number): number` লিখুন নিম্নলিখিত সমস্যার সমাধানের জন্য:  \nদুটি ধনাত্মক পূর্ণসংখ্যা n এবং k দেওয়া আছে, 1 <= x <= n এর মধ্যে কতগুলি ধনাত্মক পূর্ণসংখ্যা x আছে তা খুঁজে বের করুন, যা x = a^b আকারে প্রকাশ করা যায় যেখানে a এবং b ধনাত্মক পূর্ণসংখ্যা এবং b >= k। একই সংখ্যার বিভিন্ন বৈধ উপস্থাপনা শুধুমাত্র একবার গণনা করা হয়।\nউদাহরণ:\n  countPowerNumbers(99, 1) 99 প্রদান করে",
      "bg": "Напишете TypeScript функция `function countPowerNumbers(n: number, k: number): number`, за да решите следния проблем:  \nДадени са две положителни цели числа n и k, намерете броя на положителните цели числа x, където 1 <= x <= n, които могат да бъдат изразени като x = a^b, където a и b са положителни цели числа и b >= k. Различните легални представяния на едно и също число се броят само веднъж.  \nПример:  \n  countPowerNumbers(99, 1) връща 99",
      "zh": "编写一个 TypeScript 函数 `function countPowerNumbers(n: number, k: number): number` 来解决以下问题：\n给定两个正整数 n 和 k，找出有多少个正整数 x，满足 1 <= x <= n，可以表示为 x = a^b，其中 a 和 b 是正整数且 b >= k。相同数字的不同合法表示只计数一次。\n示例：\n  countPowerNumbers(99, 1) 返回 99",
      "fr": "Écrire une fonction TypeScript `function countPowerNumbers(n: number, k: number): number` pour résoudre le problème suivant :  \nÉtant donné deux entiers positifs n et k, trouver le nombre d'entiers positifs x, où 1 <= x <= n, qui peuvent être exprimés comme x = a^b avec a et b étant des entiers positifs et b >= k. Différentes représentations légales du même nombre sont comptées une seule fois.  \nExemple :  \n  countPowerNumbers(99, 1) retourne 99",
      "de": "Schreiben Sie eine TypeScript-Funktion `function countPowerNumbers(n: number, k: number): number`, um das folgende Problem zu lösen:\nGegeben zwei positive ganze Zahlen n und k, finde die Anzahl der positiven ganzen Zahlen x, wobei 1 <= x <= n, die als x = a^b ausgedrückt werden können, wobei a und b positive ganze Zahlen sind und b >= k. Verschiedene gültige Darstellungen derselben Zahl werden nur einmal gezählt.\nBeispiel:\n  countPowerNumbers(99, 1) gibt 99 zurück",
      "ha": "Rubuta aikin TypeScript `function countPowerNumbers(n: number, k: number): number` don warware matsalar mai zuwa:\nAn ba da lambobi guda biyu masu kyau n da k, nemo yawan lambobi masu kyau x, inda 1 <= x <= n, wanda za a iya bayyana su kamar x = a^b tare da a da b suna kasancewa lambobi masu kyau kuma b >= k. Ana kirga wakilcin doka daban-daban na wannan lambar sau daya kawai.\nMisali:\n  countPowerNumbers(99, 1) returns 99",
      "hi": "TypeScript फ़ंक्शन `function countPowerNumbers(n: number, k: number): number` लिखें ताकि निम्नलिखित समस्या का समाधान किया जा सके:\nदिए गए दो धनात्मक पूर्णांक n और k, उन धनात्मक पूर्णांकों x की संख्या खोजें, जहाँ 1 <= x <= n, जिसे x = a^b के रूप में व्यक्त किया जा सकता है जहाँ a और b धनात्मक पूर्णांक हैं और b >= k है। एक ही संख्या के विभिन्न वैध अभ्यावेदन केवल एक बार गिने जाते हैं।\nउदाहरण:\n  countPowerNumbers(99, 1) returns 99",
      "hu": "Írj egy TypeScript függvényt `function countPowerNumbers(n: number, k: number): number` a következő probléma megoldására:\nAdott két pozitív egész szám, n és k, találd meg azon pozitív egész számok x számát, ahol 1 <= x <= n, és amelyek kifejezhetők x = a^b alakban, ahol a és b pozitív egész számok és b >= k. Ugyanazon szám különböző érvényes reprezentációi csak egyszer számítanak.\nPélda:\n  countPowerNumbers(99, 1) visszaadja 99"
    },
    "instruction_bertscore": {
      "sq": "0.9927021211703971",
      "hy": "0.9810739014038528",
      "bn": "0.9249012296471864",
      "bg": "0.9855671192532429",
      "zh": "0.9623075016340575",
      "fr": "1",
      "de": "0.9855671192532429",
      "ha": "0.9795396803407392",
      "hi": "0.9710144643867219",
      "hu": "0.9590557236661353"
    },
    "level": "hard",
    "test": "const testCountPowerNumbers = (): void => {\n    console.assert(countPowerNumbers(99, 1) === 99, `Expected 99, got ${countPowerNumbers(99, 1)}`);\n    console.assert(countPowerNumbers(99, 3) === 7, `Expected 7, got ${countPowerNumbers(99, 3)}`);\n    console.assert(countPowerNumbers(99, 2) === 12, `Expected 12, got ${countPowerNumbers(99, 2)}`);\n    console.assert(countPowerNumbers(10, 1) === 10, `Expected 10, got ${countPowerNumbers(10, 1)}`);\n    console.assert(countPowerNumbers(10, 2) === 4, `Expected 4, got ${countPowerNumbers(10, 2)}`);\n    console.assert(countPowerNumbers(500, 1) === 500, `Expected 500, got ${countPowerNumbers(500, 1)}`);\n    console.assert(countPowerNumbers(500, 2) === 30, `Expected 30, got ${countPowerNumbers(500, 2)}`);\n    console.assert(countPowerNumbers(500, 3) === 13, `Expected 13, got ${countPowerNumbers(500, 3)}`);\n    console.assert(countPowerNumbers(1000, 1) === 1000, `Expected 1000, got ${countPowerNumbers(1000, 1)}`);\n    console.assert(countPowerNumbers(1000, 2) === 41, `Expected 41, got ${countPowerNumbers(1000, 2)}`);\n    console.assert(countPowerNumbers(1000, 3) === 17, `Expected 17, got ${countPowerNumbers(1000, 3)}`);\n    console.assert(countPowerNumbers(1000, 93) === 1, `Expected 1, got ${countPowerNumbers(1000, 93)}`);\n    console.assert(countPowerNumbers(50, 2) === 10, `Expected 10, got ${countPowerNumbers(50, 2)}`);\n    console.assert(countPowerNumbers(50, 3) === 5, `Expected 5, got ${countPowerNumbers(50, 3)}`);\n    console.assert(countPowerNumbers(2, 3) === 1, `Expected 1, got ${countPowerNumbers(2, 3)}`);\n};\n\ntestCountPowerNumbers();",
    "entry_point": "countPowerNumbers",
    "signature": "function countPowerNumbers(n: number, k: number): number",
    "docstring": {
      "en": "Given two positive integers n and k, find the number of positive integers x, where 1 <= x <= n, that can be expressed as x = a^b with a and b being positive integers and b >= k. Different legal representations of the same number are counted only once.\nExample:\n  countPowerNumbers(99, 1) returns 99",
      "sq": "Duke pasur dy numra të plotë pozitivë n dhe k, gjeni numrin e numrave të plotë pozitivë x, ku 1 <= x <= n, që mund të shprehen si x = a^b me a dhe b që janë numra të plotë pozitivë dhe b >= k. Përfaqësimet e ndryshme të ligjshme të të njëjtit numër numërohen vetëm një herë.\nShembull:\n  countPowerNumbers(99, 1) kthen 99",
      "hy": "Տրված են երկու դրական ամբողջ թվեր՝ n և k, գտնել դրական ամբողջ թվերի x քանակը, որտեղ 1 <= x <= n, որոնք կարող են արտահայտվել որպես x = a^b, որտեղ a և b դրական ամբողջ թվեր են և b >= k։ Նույն թվի տարբեր թույլատրելի ներկայացումները հաշվում են միայն մեկ անգամ։\n\nՕրինակ:\n  countPowerNumbers(99, 1) վերադարձնում է 99",
      "bn": "দুটি ধনাত্মক পূর্ণসংখ্যা n এবং k দেওয়া আছে, ধনাত্মক পূর্ণসংখ্যা x এর সংখ্যা খুঁজে বের করুন, যেখানে 1 <= x <= n, যা x = a^b আকারে প্রকাশ করা যায় যেখানে a এবং b ধনাত্মক পূর্ণসংখ্যা এবং b >= k। একই সংখ্যার বিভিন্ন বৈধ উপস্থাপনাকে শুধুমাত্র একবার গণনা করা হয়।\n\nউদাহরণ:\n  countPowerNumbers(99, 1) 99 প্রদান করে",
      "bg": "Дадени са две положителни цели числа n и k, намерете броя на положителните цели числа x, където 1 <= x <= n, които могат да бъдат изразени като x = a^b с a и b, които са положителни цели числа и b >= k. Различните легални представяния на едно и също число се броят само веднъж.\nПример:\n  countPowerNumbers(99, 1) връща 99",
      "zh": "给定两个正整数 n 和 k，找出有多少个正整数 x，满足 1 <= x <= n，并且可以表示为 x = a^b，其中 a 和 b 是正整数且 b >= k。相同数字的不同合法表示仅计数一次。\n示例：\n  countPowerNumbers(99, 1) 返回 99",
      "fr": "Étant donné deux entiers positifs n et k, trouvez le nombre d'entiers positifs x, où 1 <= x <= n, qui peuvent être exprimés comme x = a^b avec a et b étant des entiers positifs et b >= k. Différentes représentations légales du même nombre sont comptées une seule fois.\nExemple :\n  countPowerNumbers(99, 1) retourne 99",
      "de": "Gegeben zwei positive ganze Zahlen n und k, finde die Anzahl der positiven ganzen Zahlen x, wobei 1 <= x <= n, die als x = a^b ausgedrückt werden können, wobei a und b positive ganze Zahlen sind und b >= k. Verschiedene gültige Darstellungen derselben Zahl werden nur einmal gezählt.\nBeispiel:\n  countPowerNumbers(99, 1) gibt 99 zurück",
      "ha": "An ba da lambobi guda biyu masu kyau n da k, nemo yawan lambobi masu kyau x, inda 1 <= x <= n, waɗanda za a iya bayyana su a matsayin x = a^b tare da a da b kasancewa lambobi masu kyau kuma b >= k. Ana ƙidaya wakilcin doka daban-daban na wannan lambar sau ɗaya kawai.\n\nMisali:\n  countPowerNumbers(99, 1) yana dawo da 99",
      "hi": "दो धनात्मक पूर्णांक n और k दिए गए हैं, उन धनात्मक पूर्णांकों x की संख्या खोजें, जहाँ 1 <= x <= n, जिन्हें x = a^b के रूप में व्यक्त किया जा सकता है, जहाँ a और b धनात्मक पूर्णांक हैं और b >= k है। एक ही संख्या के विभिन्न वैध निरूपणों को केवल एक बार गिना जाता है।\nउदाहरण:\n  countPowerNumbers(99, 1) returns 99",
      "hu": "Két pozitív egész szám, n és k megadása esetén találjuk meg azon pozitív egész számok x számát, ahol 1 <= x <= n, és amelyek kifejezhetők x = a^b formában, ahol a és b pozitív egész számok, és b >= k. Ugyanazon szám különböző érvényes ábrázolásai csak egyszer számítanak.\n\nPélda:\n  countPowerNumbers(99, 1) visszaadja 99"
    },
    "docstring_bertscore": {
      "sq": "0.9890787057595587",
      "hy": "0.9823332180196139",
      "bn": "0.95048482272448",
      "bg": "0.9904204539834495",
      "zh": "0.9432449439661393",
      "fr": "1",
      "de": "0.9814814909457363",
      "ha": "0.9782326924335297",
      "hi": "0.9647651553386022",
      "hu": "0.9561882954855158"
    }
  },
  {
    "task_id": "TypeScript/41",
    "prompt": {
      "en": "\n/**\n * Computes the number of sequences consisting of n '(' and m ')', such that the longest balanced\n * subsequence is of length 2 * k, modulo 1,000,000,007 (10^9 + 7).\n * \n * Example:\n *   countBalancedSubsequences(2, 2, 2) returns 2\n *\n * @param n The number of '(' characters.\n * @param m The number of ')' characters.\n * @param k The half-length of the longest balanced subsequence.\n * @returns The number of valid sequences modulo 10^9 + 7.\n */\nfunction countBalancedSubsequences(n: number, m: number, k: number): number {",
      "sq": "/**\n * Llogarit numrin e sekuencave që përbëhen nga n '(' dhe m ')', të tilla që nënsekuenca më e gjatë\n * e balancuar është me gjatësi 2 * k, modulo 1,000,000,007 (10^9 + 7).\n * \n * Shembull:\n *   countBalancedSubsequences(2, 2, 2) kthen 2\n *\n * @param n Numri i karaktereve '('.\n * @param m Numri i karaktereve ')'.\n * @param k Gjysma e gjatësisë së nënsekuencës më të gjatë të balancuar.\n * @returns Numri i sekuencave të vlefshme modulo 10^9 + 7.\n */\nfunction countBalancedSubsequences(n: number, m: number, k: number): number {",
      "hy": "/**\n * Հաշվում է n '(' և m ')' բաղկացած հաջորդականությունների քանակը, այնպես, որ ամենաերկար հավասարակշռված\n * ենթահաջորդականությունը լինի 2 * k երկարությամբ, մոդուլո 1,000,000,007 (10^9 + 7):\n * \n * Օրինակ:\n *   countBalancedSubsequences(2, 2, 2) վերադարձնում է 2\n *\n * @param n '(' սիմվոլների քանակը:\n * @param m ')' սիմվոլների քանակը:\n * @param k Ամենաերկար հավասարակշռված ենթահաջորդականության կես երկարությունը:\n * @returns Վավեր հաջորդականությունների քանակը մոդուլո 10^9 + 7:\n */\nfunction countBalancedSubsequences(n: number, m: number, k: number): number {",
      "bn": "/**\n * n '(' এবং m ')' নিয়ে গঠিত ক্রমগুলির সংখ্যা গণনা করে, যাতে দীর্ঘতম সুষম উপধারা 2 * k দৈর্ঘ্যের হয়, 1,000,000,007 (10^9 + 7) দ্বারা মডুলো।\n * \n * উদাহরণ:\n *   countBalancedSubsequences(2, 2, 2) 2 প্রদান করে\n *\n * @param n '(' অক্ষরের সংখ্যা।\n * @param m ')' অক্ষরের সংখ্যা।\n * @param k দীর্ঘতম সুষম উপধারার অর্ধেক দৈর্ঘ্য।\n * @returns বৈধ ক্রমগুলির সংখ্যা 10^9 + 7 দ্বারা মডুলো।\n */\nfunction countBalancedSubsequences(n: number, m: number, k: number): number {",
      "bg": "/**\n * Изчислява броя на последователностите, състоящи се от n '(' и m ')', така че най-дългата балансирана\n * подредба да е с дължина 2 * k, модуло 1,000,000,007 (10^9 + 7).\n * \n * Пример:\n *   countBalancedSubsequences(2, 2, 2) връща 2\n *\n * @param n Броят на символите '('.\n * @param m Броят на символите ')'.\n * @param k Половината от дължината на най-дългата балансирана подредба.\n * @returns Броят на валидните последователности модуло 10^9 + 7.\n */\nfunction countBalancedSubsequences(n: number, m: number, k: number): number {",
      "zh": "/**\n * 计算由 n 个 '(' 和 m 个 ')' 组成的序列数量，使得最长的平衡子序列的长度为 2 * k，结果对 1,000,000,007 (10^9 + 7) 取模。\n * \n * 示例:\n *   countBalancedSubsequences(2, 2, 2) 返回 2\n *\n * @param n '(' 字符的数量。\n * @param m ')' 字符的数量。\n * @param k 最长平衡子序列的一半长度。\n * @returns 有效序列的数量，对 10^9 + 7 取模。\n */\nfunction countBalancedSubsequences(n: number, m: number, k: number): number {",
      "fr": "/**\n * Calcule le nombre de séquences composées de n '(' et m ')', telles que la plus longue sous-séquence\n * équilibrée soit de longueur 2 * k, modulo 1,000,000,007 (10^9 + 7).\n * \n * Exemple :\n *   countBalancedSubsequences(2, 2, 2) retourne 2\n *\n * @param n Le nombre de caractères '('.\n * @param m Le nombre de caractères ')'.\n * @param k La demi-longueur de la plus longue sous-séquence équilibrée.\n * @returns Le nombre de séquences valides modulo 10^9 + 7.\n */\nfunction countBalancedSubsequences(n: number, m: number, k: number): number {",
      "de": "/**\n * Berechnet die Anzahl der Sequenzen, die aus n '(' und m ')' bestehen, sodass die längste\n * balancierte Teilsequenz die Länge 2 * k hat, modulo 1.000.000.007 (10^9 + 7).\n * \n * Beispiel:\n *   countBalancedSubsequences(2, 2, 2) gibt 2 zurück\n *\n * @param n Die Anzahl der '(' Zeichen.\n * @param m Die Anzahl der ')' Zeichen.\n * @param k Die halbe Länge der längsten balancierten Teilsequenz.\n * @returns Die Anzahl der gültigen Sequenzen modulo 10^9 + 7.\n */\nfunction countBalancedSubsequences(n: number, m: number, k: number): number {",
      "ha": "/**\n * Lissafi yawan jerin abubuwa da suka ƙunshi n '(' da m ')', ta yadda mafi tsawon daidaitaccen\n * subsequence yana da tsawon 2 * k, modulo 1,000,000,007 (10^9 + 7).\n * \n * Misali:\n *   countBalancedSubsequences(2, 2, 2) yana dawowa da 2\n *\n * @param n Yawan haruffan '('.\n * @param m Yawan haruffan ')'.\n * @param k Rabin tsawon mafi tsawon daidaitaccen subsequence.\n * @returns Yawan jerin abubuwan da suka dace modulo 10^9 + 7.\n */\nfunction countBalancedSubsequences(n: number, m: number, k: number): number {",
      "hi": "/**\n * n '(' और m ')' से बनी अनुक्रमों की संख्या की गणना करता है, ताकि सबसे लंबा संतुलित उप-अनुक्रम\n * की लंबाई 2 * k हो, 1,000,000,007 (10^9 + 7) से मापांकित।\n * \n * उदाहरण:\n *   countBalancedSubsequences(2, 2, 2) 2 लौटाता है\n *\n * @param n '(' वर्णों की संख्या।\n * @param m ')' वर्णों की संख्या।\n * @param k सबसे लंबे संतुलित उप-अनुक्रम की अर्ध-लंबाई।\n * @returns मान्य अनुक्रमों की संख्या 10^9 + 7 से मापांकित।\n */\nfunction countBalancedSubsequences(n: number, m: number, k: number): number {",
      "hu": "/**\n * Kiszámítja az n '(' és m ')' karakterekből álló sorozatok számát úgy, hogy a leghosszabb kiegyensúlyozott\n * részsorozat hossza 2 * k, modulo 1,000,000,007 (10^9 + 7).\n * \n * Példa:\n *   countBalancedSubsequences(2, 2, 2) visszaadja 2\n *\n * @param n Az '(' karakterek száma.\n * @param m A ')' karakterek száma.\n * @param k A leghosszabb kiegyensúlyozott részsorozat félhossza.\n * @returns Az érvényes sorozatok száma modulo 10^9 + 7.\n */\nfunction countBalancedSubsequences(n: number, m: number, k: number): number {"
    },
    "prompt_bertscore": {
      "sq": "0.9698397643132816",
      "hy": "0.9599797521987097",
      "bn": "0.9606978010261508",
      "bg": "0.974163550447649",
      "zh": "0.9539531078077301",
      "fr": "0.9961320705901077",
      "de": "0.9777377055239908",
      "ha": "0.9705445049051933",
      "hi": "0.95895680573638",
      "hu": "0.9761504501491409"
    },
    "canonical_solution": "const P = 1e9 + 7;\n    const C = Array.from({ length: 4003 }, () => Array(4003).fill(0));\n \n    // Compute binomial coefficients only once.\n    if (C[0][0] === 0) {\n        for (let i = 0; i <= 4002; i++) C[i][0] = 1;\n        for (let i = 1; i <= 4002; i++)\n            for (let j = 1; j <= i; j++)\n                C[i][j] = (C[i - 1][j - 1] + C[i - 1][j]) % P;\n    }\n \n    // Calculate the number of balanced subsequences.\n    if (k > n || k > m) return 0;\n    \n    return (C[n + m][k] - C[n + m][k - 1] + P) % P;\n}",
    "instruction": {
      "en": "Write a TypeScript function `function countBalancedSubsequences(n: number, m: number, k: number): number` to solve the following problem:\nComputes the number of sequences consisting of n '(' and m ')', such that the longest balanced\nsubsequence is of length 2 * k, modulo 1,000,000,007 (10^9 + 7).\n\nExample:\ncountBalancedSubsequences(2, 2, 2) returns 2\n\n@param n The number of '(' characters.\n@param m The number of ')' characters.\n@param k The half-length of the longest balanced subsequence.\n@returns The number of valid sequences modulo 10^9 + 7.",
      "sq": "Shkruani një funksion TypeScript `function countBalancedSubsequences(n: number, m: number, k: number): number` për të zgjidhur problemin e mëposhtëm:\nLlogarit numrin e sekuencave që përbëhen nga n '(' dhe m ')', të tilla që nënsekuenca më e gjatë e balancuar është me gjatësi 2 * k, modulo 1,000,000,007 (10^9 + 7).\n\nShembull:\ncountBalancedSubsequences(2, 2, 2) kthen 2\n\n@param n Numri i karaktereve '('.\n@param m Numri i karaktereve ')'.\n@param k Gjysma e gjatësisë së nënsekuencës më të gjatë të balancuar.\n@returns Numri i sekuencave të vlefshme modulo 10^9 + 7.",
      "hy": "Գրեք TypeScript ֆունկցիա `function countBalancedSubsequences(n: number, m: number, k: number): number` հետևյալ խնդիրը լուծելու համար:\nՀաշվում է n '(' և m ')' բաղադրող հաջորդականությունների քանակը, այնպես, որ ամենաերկար հավասարակշռված\nենթահաջորդականությունը լինի 2 * k երկարությամբ, մոդուլո 1,000,000,007 (10^9 + 7):\n\nՕրինակ:\ncountBalancedSubsequences(2, 2, 2) վերադարձնում է 2\n\n@param n '(' սիմվոլների քանակը:\n@param m ')' սիմվոլների քանակը:\n@param k ամենաերկար հավասարակշռված ենթահաջորդականության կես երկարությունը:\n@returns Վավեր հաջորդականությունների քանակը մոդուլո 10^9 + 7:",
      "bn": "TypeScript ফাংশন `function countBalancedSubsequences(n: number, m: number, k: number): number` লিখুন নিম্নলিখিত সমস্যার সমাধানের জন্য:\nn '(' এবং m ')' নিয়ে গঠিত সিকোয়েন্সের সংখ্যা গণনা করে, যাতে দীর্ঘতম ব্যালেন্সড সাবসিকোয়েন্সের দৈর্ঘ্য 2 * k হয়, মডুলো 1,000,000,007 (10^9 + 7)।\n\nউদাহরণ:\ncountBalancedSubsequences(2, 2, 2) 2 রিটার্ন করে\n\n@param n '(' অক্ষরের সংখ্যা।\n@param m ')' অক্ষরের সংখ্যা।\n@param k দীর্ঘতম ব্যালেন্সড সাবসিকোয়েন্সের অর্ধেক দৈর্ঘ্য।\n@returns বৈধ সিকোয়েন্সের সংখ্যা মডুলো 10^9 + 7।",
      "bg": "Напишете TypeScript функция `function countBalancedSubsequences(n: number, m: number, k: number): number`, за да решите следния проблем:\nИзчислява броя на последователностите, състоящи се от n '(' и m ')', така че най-дългата балансирана\nподпоследователност е с дължина 2 * k, модул 1,000,000,007 (10^9 + 7).\n\nПример:\ncountBalancedSubsequences(2, 2, 2) връща 2\n\n@param n Броят на символите '('.\n@param m Броят на символите ')'.\n@param k Половината от дължината на най-дългата балансирана подпоследователност.\n@returns Броят на валидните последователности модул 10^9 + 7.",
      "zh": "编写一个 TypeScript 函数 `function countBalancedSubsequences(n: number, m: number, k: number): number` 来解决以下问题：\n计算由 n 个 '(' 和 m 个 ')' 组成的序列的数量，使得最长的平衡子序列的长度为 2 * k，结果对 1,000,000,007 (10^9 + 7) 取模。\n\n示例：\ncountBalancedSubsequences(2, 2, 2) 返回 2\n\n@param n '(' 字符的数量。\n@param m ')' 字符的数量。\n@param k 最长平衡子序列的一半长度。\n@returns 有效序列的数量，对 10^9 + 7 取模。",
      "fr": "Écrire une fonction TypeScript `function countBalancedSubsequences(n: number, m: number, k: number): number` pour résoudre le problème suivant :\nCalcule le nombre de séquences composées de n '(' et m ')', telles que la plus longue sous-séquence équilibrée soit de longueur 2 * k, modulo 1,000,000,007 (10^9 + 7).\n\nExemple :\ncountBalancedSubsequences(2, 2, 2) retourne 2\n\n@param n Le nombre de caractères '('.\n@param m Le nombre de caractères ')'.\n@param k La demi-longueur de la plus longue sous-séquence équilibrée.\n@returns Le nombre de séquences valides modulo 10^9 + 7.",
      "de": "Schreiben Sie eine TypeScript-Funktion `function countBalancedSubsequences(n: number, m: number, k: number): number`, um das folgende Problem zu lösen:\nBerechnet die Anzahl der Sequenzen, die aus n '(' und m ')' bestehen, so dass die längste ausgeglichene\nTeilsequenz eine Länge von 2 * k hat, modulo 1.000.000.007 (10^9 + 7).\n\nBeispiel:\ncountBalancedSubsequences(2, 2, 2) gibt 2 zurück\n\n@param n Die Anzahl der '(' Zeichen.\n@param m Die Anzahl der ')' Zeichen.\n@param k Die halbe Länge der längsten ausgeglichenen Teilsequenz.\n@returns Die Anzahl der gültigen Sequenzen modulo 10^9 + 7.",
      "ha": "Rubuta aikin TypeScript `function countBalancedSubsequences(n: number, m: number, k: number): number` don warware matsalar mai zuwa:\nLissafa yawan jerin da suka ƙunshi n '(' da m ')', ta yadda mafi tsawon daidaitaccen subsequence shine tsawon 2 * k, modulo 1,000,000,007 (10^9 + 7).\n\nMisali:\ncountBalancedSubsequences(2, 2, 2) returns 2\n\n@param n Yawan haruffan '('.\n@param m Yawan haruffan ')'.\n@param k Rabin tsawon mafi tsawon daidaitaccen subsequence.\n@returns Yawan sahihan jerin modulo 10^9 + 7.",
      "hi": "TypeScript फ़ंक्शन `function countBalancedSubsequences(n: number, m: number, k: number): number` लिखें ताकि निम्नलिखित समस्या का समाधान किया जा सके:\nऐसे अनुक्रमों की संख्या की गणना करता है जो n '(' और m ')' से बने होते हैं, ताकि सबसे लंबा संतुलित उप-अनुक्रम की लंबाई 2 * k हो, 1,000,000,007 (10^9 + 7) के मापांक के साथ।\n\nउदाहरण:\ncountBalancedSubsequences(2, 2, 2) 2 लौटाता है\n\n@param n '(' वर्णों की संख्या।\n@param m ')' वर्णों की संख्या।\n@param k सबसे लंबे संतुलित उप-अनुक्रम की आधी लंबाई।\n@returns मान्य अनुक्रमों की संख्या 10^9 + 7 के मापांक के साथ।",
      "hu": "Írj egy TypeScript függvényt `function countBalancedSubsequences(n: number, m: number, k: number): number` a következő probléma megoldására:\nKiszámítja azon sorozatok számát, amelyek n '(' és m ')' karakterből állnak, úgy, hogy a leghosszabb kiegyensúlyozott részsorozat hossza 2 * k, modulo 1,000,000,007 (10^9 + 7).\n\nPélda:\ncountBalancedSubsequences(2, 2, 2) visszaadja 2\n\n@param n Az '(' karakterek száma.\n@param m A ')' karakterek száma.\n@param k A leghosszabb kiegyensúlyozott részsorozat félhossza.\n@returns Az érvényes sorozatok száma modulo 10^9 + 7."
    },
    "instruction_bertscore": {
      "sq": "0.973270110993754",
      "hy": "0.972404678423585",
      "bn": "0.9466033864486773",
      "bg": "0.9829245406639548",
      "zh": "0.961456370451323",
      "fr": "0.9937059991161475",
      "de": "0.9788834055618",
      "ha": "0.9752675381054409",
      "hi": "0.937225251638496",
      "hu": "0.9723041714507814"
    },
    "level": "hard",
    "test": "(() => {\n    console.assert(countBalancedSubsequences(2, 2, 2) === 2, 'Test case 1 failed');\n    console.assert(countBalancedSubsequences(3, 2, 3) === 0, 'Test case 2 failed');\n    console.assert(countBalancedSubsequences(3, 2, 1) === 4, 'Test case 3 failed');\n    console.assert(countBalancedSubsequences(4, 3, 2) === 14, 'Test case 4 failed');\n    console.assert(countBalancedSubsequences(5, 5, 2) === 35, 'Test case 5 failed');\n    console.assert(countBalancedSubsequences(6, 1, 1) === 6, 'Test case 6 failed');\n    console.assert(countBalancedSubsequences(1, 6, 1) === 6, 'Test case 7 failed');\n    console.assert(countBalancedSubsequences(7, 2, 2) === 27, 'Test case 8 failed');\n    console.assert(countBalancedSubsequences(8, 3, 3) === 110, 'Test case 9 failed');\n    console.assert(countBalancedSubsequences(10, 10, 5) === 10659, 'Test case 10 failed');\n    console.assert(countBalancedSubsequences(20, 20, 10) === 574221648, 'Test case 11 failed');\n    console.assert(countBalancedSubsequences(2000, 2000, 1000) === 854104531, 'Test case 12 failed');\n    console.assert(countBalancedSubsequences(2000, 1999, 1000) === 334874485, 'Test case 13 failed');\n    console.assert(countBalancedSubsequences(2000, 2000, 1999) === 259428024, 'Test case 14 failed');\n})();",
    "entry_point": "countBalancedSubsequences",
    "signature": "function countBalancedSubsequences(n: number, m: number, k: number): number",
    "docstring": {
      "en": "Computes the number of sequences consisting of n '(' and m ')', such that the longest balanced\nsubsequence is of length 2 * k, modulo 1,000,000,007 (10^9 + 7).\n\nExample:\ncountBalancedSubsequences(2, 2, 2) returns 2\n\n@param n The number of '(' characters.\n@param m The number of ')' characters.\n@param k The half-length of the longest balanced subsequence.\n@returns The number of valid sequences modulo 10^9 + 7.",
      "sq": "Llogarit numrin e sekuencave që përbëhen nga n '(' dhe m ')', të tilla që nënsekuenca më e gjatë e balancuar është me gjatësi 2 * k, modulo 1,000,000,007 (10^9 + 7).\n\nShembull:\ncountBalancedSubsequences(2, 2, 2) kthen 2\n\n@param n Numri i karaktereve '('.\n@param m Numri i karaktereve ')'.\n@param k Gjysma e gjatësisë së nënsekuencës më të gjatë të balancuar.\n@returns Numri i sekuencave të vlefshme modulo 10^9 + 7.",
      "hy": "Հաշվում է n '(' և m ')' բաղադրիչներից կազմված հաջորդականությունների քանակը, այնպես, որ ամենաերկար հավասարակշռված ենթահաջորդականությունը լինի երկարությամբ 2 * k, մոդուլո 1,000,000,007 (10^9 + 7):\n\nՕրինակ:\ncountBalancedSubsequences(2, 2, 2) վերադարձնում է 2\n\n@param n '(' նիշերի քանակը:\n@param m ')' նիշերի քանակը:\n@param k ամենաերկար հավասարակշռված ենթահաջորդականության կես երկարությունը:\n@returns Վավեր հաջորդականությունների քանակը մոդուլո 10^9 + 7:",
      "bn": "n '(' এবং m ')' নিয়ে গঠিত সিকোয়েন্সের সংখ্যা গণনা করে, যাতে দীর্ঘতম ব্যালান্সড সাবসিকোয়েন্সের দৈর্ঘ্য 2 * k হয়, মডুলো 1,000,000,007 (10^9 + 7)।\n\nউদাহরণ:\ncountBalancedSubsequences(2, 2, 2) 2 প্রদান করে\n\n@param n '(' অক্ষরের সংখ্যা।\n@param m ')' অক্ষরের সংখ্যা।\n@param k দীর্ঘতম ব্যালান্সড সাবসিকোয়েন্সের অর্ধেক দৈর্ঘ্য।\n@returns বৈধ সিকোয়েন্সের সংখ্যা মডুলো 10^9 + 7।",
      "bg": "Изчислява броя на последователностите, състоящи се от n '(' и m ')', така че най-дългата балансирана\nподпоследователност да е с дължина 2 * k, модуло 1,000,000,007 (10^9 + 7).\n\nПример:\ncountBalancedSubsequences(2, 2, 2) връща 2\n\n@param n Броят на символите '('.\n@param m Броят на символите ')'.\n@param k Половината от дължината на най-дългата балансирана подпоследователност.\n@returns Броят на валидните последователности модуло 10^9 + 7.",
      "zh": "计算由 n 个 '(' 和 m 个 ')' 组成的序列数量，使得最长平衡子序列的长度为 2 * k，对 1,000,000,007 (10^9 + 7) 取模。\n\n示例:\ncountBalancedSubsequences(2, 2, 2) 返回 2\n\n@param n '(' 字符的数量。\n@param m ')' 字符的数量。\n@param k 最长平衡子序列的半长度。\n@returns 有效序列的数量，对 10^9 + 7 取模。",
      "fr": "Calcule le nombre de séquences constituées de n '(' et m ')', de sorte que la plus longue sous-séquence équilibrée soit de longueur 2 * k, modulo 1,000,000,007 (10^9 + 7).\n\nExemple :\ncountBalancedSubsequences(2, 2, 2) retourne 2\n\n@param n Le nombre de caractères '('.\n@param m Le nombre de caractères ')'.\n@param k La demi-longueur de la plus longue sous-séquence équilibrée.\n@returns Le nombre de séquences valides modulo 10^9 + 7.",
      "de": "Berechnet die Anzahl der Sequenzen, die aus n '(' und m ')' bestehen, sodass die längste ausgeglichene\nTeilsequenz die Länge 2 * k hat, modulo 1.000.000.007 (10^9 + 7).\n\nBeispiel:\ncountBalancedSubsequences(2, 2, 2) gibt 2 zurück\n\n@param n Die Anzahl der '(' Zeichen.\n@param m Die Anzahl der ')' Zeichen.\n@param k Die Halblänge der längsten ausgeglichenen Teilsequenz.\n@returns Die Anzahl der gültigen Sequenzen modulo 10^9 + 7.",
      "ha": "Yana ƙididdige adadin jerin abubuwan da suka ƙunshi n '(' da m ')', ta yadda mafi tsawon daidaitaccen ƙananan jeri shine tsawon 2 * k, modulo 1,000,000,007 (10^9 + 7).\n\nMisali:\ncountBalancedSubsequences(2, 2, 2) yana dawowa 2\n\n@param n Yawan haruffan '('.\n@param m Yawan haruffan ')'.\n@param k Rabin tsawon mafi tsawon daidaitaccen ƙananan jeri.\n@returns Yawan jerin da suka dace modulo 10^9 + 7.",
      "hi": "लंबाई 2 * k के सबसे लंबे संतुलित उपक्रम के साथ n '(' और m ')' से बनी अनुक्रमों की संख्या की गणना करता है, 1,000,000,007 (10^9 + 7) के मापांक के साथ।\n\nउदाहरण:\ncountBalancedSubsequences(2, 2, 2) 2 लौटाता है\n\n@param n '(' वर्णों की संख्या।\n@param m ')' वर्णों की संख्या।\n@param k सबसे लंबे संतुलित उपक्रम की आधी लंबाई।\n@returns 10^9 + 7 के मापांक के साथ मान्य अनुक्रमों की संख्या।",
      "hu": "Számolja ki az n darab '(' és m darab ')' karakterből álló sorozatok számát úgy, hogy a leghosszabb kiegyensúlyozott részszekvencia hossza 2 * k, 1,000,000,007 (10^9 + 7) maradékával.\n\nPélda:\ncountBalancedSubsequences(2, 2, 2) visszaadja 2\n\n@param n Az '(' karakterek száma.\n@param m A ')' karakterek száma.\n@param k A leghosszabb kiegyensúlyozott részszekvencia félhossza.\n@returns Az érvényes sorozatok száma 10^9 + 7 maradékkal."
    },
    "docstring_bertscore": {
      "sq": "0.9644783330683878",
      "hy": "0.9695455927189689",
      "bn": "0.9233743579081712",
      "bg": "0.9781397334152053",
      "zh": "0.94898774554262",
      "fr": "0.9908896189434538",
      "de": "0.977602835495268",
      "ha": "0.9624660086781234",
      "hi": "0.9159388282245112",
      "hu": "0.9271509173427875"
    }
  },
  {
    "task_id": "TypeScript/42",
    "prompt": {
      "en": "\n/**\n * Given a rectangle paper of size n x m placed on a plane Cartesian coordinate system with its bottom-left\n * corner at (0,0) and top-right corner at (n,m), you need to calculate the expected number of operations\n * to cut the paper such that the remaining area is less than k. In each operation, a line is randomly\n * chosen that is parallel to the axes, passes through points with integer coordinates, and cuts through\n * (not just touching the edge) the paper. The bottom or right part of the paper along this line is then\n * discarded. The answer should be modulo 10^9+7.\n *\n * For example:\n *    expectedCuts(3, 3, 4) // returns 3\n *    expectedCuts(5, 5, 12) // returns 2\n */\nfunction expectedCuts(n: number, m: number, k: number): number",
      "sq": "/**\n * Duke pasur një letër drejtkëndëshe me madhësi n x m të vendosur në një sistem koordinativ Kartesian në plan\n * me këndin e poshtëm të majtë në (0,0) dhe këndin e sipërm të djathtë në (n,m), ju duhet të llogaritni numrin\n * e pritur të operacioneve për të prerë letrën në mënyrë që sipërfaqja e mbetur të jetë më pak se k. Në çdo\n * operacion, një vijë zgjidhet rastësisht që është paralele me boshtet, kalon përmes pikave me koordinata\n * të plota, dhe pret (jo vetëm prek skajin) letrën. Pjesa e poshtme ose e djathtë e letrës përgjatë kësaj\n * vije pastaj hidhet. Përgjigjja duhet të jetë modulo 10^9+7.\n *\n * Për shembull:\n *    expectedCuts(3, 3, 4) // kthen 3\n *    expectedCuts(5, 5, 12) // kthen 2\n */\nfunction expectedCuts(n: number, m: number, k: number): number",
      "hy": "/**\n * Տրված է n x m չափսերով ուղղանկյուն թուղթ, որը տեղադրված է հարթության վրա Կարտեզյան կոորդինատային համակարգում՝\n * իր ներքևի ձախ անկյունը (0,0) կետում և վերևի աջ անկյունը (n,m) կետում, անհրաժեշտ է հաշվարկել գործողությունների\n * սպասվող քանակը, որպեսզի թղթի մնացած մակերեսը լինի k-ից փոքր։ Յուրաքանչյուր գործողության ժամանակ պատահականորեն\n * ընտրվում է գիծ, որը զուգահեռ է առանցքներին, անցնում է ամբողջ թվային կոորդինատներով կետերով և հատում է\n * (ոչ միայն հպվում է եզրին) թուղթը։ Այս գծի երկայնքով թղթի ներքևի կամ աջ մասը ապա հեռացվում է։ Պատասխանը պետք է\n * լինի 10^9+7 մոդուլով։\n *\n * Օրինակ:\n *    expectedCuts(3, 3, 4) // վերադարձնում է 3\n *    expectedCuts(5, 5, 12) // վերադարձնում է 2\n */\nfunction expectedCuts(n: number, m: number, k: number): number",
      "bn": "/**\n * একটি আয়তাকার কাগজের টুকরো n x m আকারের একটি সমতল কার্টেসিয়ান স্থানাঙ্ক পদ্ধতিতে রাখা হয়েছে যার নিচের-বাম\n * কোণটি (0,0) এবং উপরের-ডান কোণটি (n,m) এ রয়েছে, আপনাকে কাগজটি কাটার প্রত্যাশিত সংখ্যক অপারেশন\n * গণনা করতে হবে যাতে অবশিষ্ট এলাকা k এর চেয়ে কম হয়। প্রতিটি অপারেশনে, একটি রেখা এলোমেলোভাবে\n * নির্বাচিত হয় যা অক্ষগুলির সমান্তরাল, পূর্ণসংখ্যা স্থানাঙ্ক সহ বিন্দুগুলির মধ্য দিয়ে যায়, এবং কাগজের\n * মধ্য দিয়ে কাটে (শুধু প্রান্ত স্পর্শ করে না)। এই রেখা বরাবর কাগজের নিচের বা ডান অংশটি তারপর\n * বাতিল করা হয়। উত্তরটি 10^9+7 মডুলোতে হওয়া উচিত।\n *\n * উদাহরণস্বরূপ:\n *    expectedCuts(3, 3, 4) // 3 ফেরত দেয়\n *    expectedCuts(5, 5, 12) // 2 ফেরত দেয়\n */\nfunction expectedCuts(n: number, m: number, k: number): number",
      "bg": "/**\n * Даден е правоъгълен лист хартия с размер n x m, поставен в равнинна декартова координатна система с долния ляв\n * ъгъл в (0,0) и горния десен ъгъл в (n,m), трябва да изчислите очаквания брой операции\n * за да се изреже хартията така, че останалата площ да е по-малка от k. При всяка операция, линия се избира на случаен принцип,\n * която е успоредна на осите, минава през точки с цели координати и пресича\n * (не само докосва ръба) хартията. Долната или дясната част на хартията по тази линия след това\n * се изхвърля. Отговорът трябва да бъде модул 10^9+7.\n *\n * Например:\n *    expectedCuts(3, 3, 4) // връща 3\n *    expectedCuts(5, 5, 12) // връща 2\n */\nfunction expectedCuts(n: number, m: number, k: number): number",
      "zh": "/**\n * 给定一个大小为 n x m 的矩形纸张，放置在平面直角坐标系中，其左下角在 (0,0) 处，右上角在 (n,m) 处，\n * 你需要计算切割纸张的期望操作次数，使得剩余面积小于 k。在每次操作中，随机选择一条平行于坐标轴的线，\n * 该线通过整数坐标的点，并切割（不仅仅是接触边缘）纸张。然后沿着这条线丢弃纸张的底部或右侧部分。\n * 答案应对 10^9+7 取模。\n *\n * 例如:\n *    expectedCuts(3, 3, 4) // 返回 3\n *    expectedCuts(5, 5, 12) // 返回 2\n */\nfunction expectedCuts(n: number, m: number, k: number): number",
      "fr": "/**\n * Étant donné un papier rectangulaire de taille n x m placé sur un système de coordonnées cartésiennes avec son coin inférieur gauche\n * à (0,0) et son coin supérieur droit à (n,m), vous devez calculer le nombre attendu d'opérations\n * pour couper le papier de sorte que la surface restante soit inférieure à k. À chaque opération, une ligne est choisie aléatoirement\n * qui est parallèle aux axes, passe par des points avec des coordonnées entières, et coupe (ne fait pas que toucher le bord) le papier. La partie inférieure ou droite du papier le long de cette ligne est ensuite\n * jetée. La réponse doit être modulo 10^9+7.\n *\n * Par exemple :\n *    expectedCuts(3, 3, 4) // retourne 3\n *    expectedCuts(5, 5, 12) // retourne 2\n */\nfunction expectedCuts(n: number, m: number, k: number): number",
      "de": "/**\n * Gegeben ist ein rechteckiges Papier der Größe n x m, das in einem kartesischen Koordinatensystem\n * mit seiner unteren linken Ecke bei (0,0) und der oberen rechten Ecke bei (n,m) platziert ist. Sie müssen\n * die erwartete Anzahl von Operationen berechnen, um das Papier so zu schneiden, dass die verbleibende\n * Fläche kleiner als k ist. Bei jeder Operation wird eine Linie zufällig gewählt, die parallel zu den Achsen\n * verläuft, durch Punkte mit ganzzahligen Koordinaten geht und das Papier durchschneidet (nicht nur den Rand\n * berührt). Der untere oder rechte Teil des Papiers entlang dieser Linie wird dann verworfen. Die Antwort\n * sollte modulo 10^9+7 sein.\n *\n * Zum Beispiel:\n *    expectedCuts(3, 3, 4) // gibt 3 zurück\n *    expectedCuts(5, 5, 12) // gibt 2 zurück\n */\nfunction expectedCuts(n: number, m: number, k: number): number",
      "ha": "/**\n * An ba takardar murabba'i mai girman n x m da aka sanya a kan tsarin daidaitawa na Cartesian tare da kusurwar ƙasa-hagu\n * a (0,0) da kusurwar sama-dama a (n,m), kana buƙatar ƙididdige yawan ayyukan da ake tsammani\n * don yanke takardar ta yadda yankin da ya rage ya zama ƙasa da k. A cikin kowane aiki, ana zaɓar layi da bazuwar\n * wanda yake daidai da ginshiƙai, yana wucewa ta wuraren da ke da daidaitattun lambobi, kuma yana yanke\n * (ba kawai taɓa gefen ba) takardar. Sashin ƙasa ko dama na takardar tare da wannan layin sai a yar da shi. Amsar ya kamata ta zama modulo 10^9+7.\n *\n * Alal misali:\n *    expectedCuts(3, 3, 4) // yana dawowa 3\n *    expectedCuts(5, 5, 12) // yana dawowa 2\n */\nfunction expectedCuts(n: number, m: number, k: number): number",
      "hi": "/**\n * दिए गए आयताकार कागज का आकार n x m है, जो एक समतल कार्टेशियन निर्देशांक प्रणाली पर रखा गया है,\n * जिसका निचला-बायाँ कोना (0,0) पर है और ऊपरी-दायाँ कोना (n,m) पर है। आपको उन ऑपरेशनों की अपेक्षित संख्या\n * की गणना करनी है जिनके बाद शेष क्षेत्रफल k से कम हो जाता है। प्रत्येक ऑपरेशन में, एक रेखा यादृच्छिक रूप से\n * चुनी जाती है जो अक्षों के समानांतर होती है, पूर्णांक निर्देशांक वाले बिंदुओं से गुजरती है, और कागज को काटती है\n * (सिर्फ किनारे को छूने वाली नहीं)। इस रेखा के साथ कागज का निचला या दायाँ हिस्सा फिर छोड़ दिया जाता है।\n * उत्तर 10^9+7 के मापांक में होना चाहिए।\n *\n * उदाहरण के लिए:\n *    expectedCuts(3, 3, 4) // 3 लौटाता है\n *    expectedCuts(5, 5, 12) // 2 लौटाता है\n */\nfunction expectedCuts(n: number, m: number, k: number): number",
      "hu": "/**\n * Adott egy n x m méretű téglalap alakú papír, amely egy síkbeli derékszögű koordináta-rendszerben helyezkedik el úgy, hogy az alsó-bal\n * sarka a (0,0) pontban van, a jobb-felső sarka pedig az (n,m) pontban, ki kell számítanod a várható műveletek számát\n * ahhoz, hogy a maradék terület kisebb legyen, mint k. Minden művelet során egy véletlenszerűen kiválasztott vonal\n * párhuzamos a tengelyekkel, egész koordinátájú pontokon halad át, és átvágja (nem csak érinti a szélét) a papírt. A papír\n * ezen vonal mentén lévő alsó vagy jobb részét el kell dobni. Az eredményt 10^9+7 modullal kell megadni.\n *\n * Például:\n *    expectedCuts(3, 3, 4) // visszaadja 3\n *    expectedCuts(5, 5, 12) // visszaadja 2\n */\nfunction expectedCuts(n: number, m: number, k: number): number"
    },
    "prompt_bertscore": {
      "sq": "0.9623948990017129",
      "hy": "0.9383645955041121",
      "bn": "0.9536917102262883",
      "bg": "0.9595755393733036",
      "zh": "0.9419397437323591",
      "fr": "0.9754284287140792",
      "de": "0.9524508662359633",
      "ha": "0.9540601695831079",
      "hi": "0.9482118952742977",
      "hu": "0.9145629155750825"
    },
    "canonical_solution": "{\n    const MD: number = 1000000007;\n    const N: number = 1000000;\n    let vv: number[] = new Array(N * 2 + 2).fill(0);\n    let ans: number = 1;\n\n    vv[1] = 1;\n    for (let i = 2; i <= N * 2; i++)\n        vv[i] = vv[i - MD % i] * (Math.floor(MD / i) + 1) % MD;\n    if (k > n * m) {\n        return 0;\n    }\n\n    for (let i = Math.floor((k + m - 1) / m); i < n; i++) {\n        ans = (ans + vv[i + Math.floor((k + i - 1) / i) - 1]) % MD;\n    }\n    for (let j = Math.floor((k + n - 1) / n); j < m; j++)\n        ans = (ans + vv[Math.floor((k + j - 1) / j) + j - 1]) % MD;\n\n    return ans;\n}",
    "instruction": {
      "en": "Write a TypeScript function `function expectedCuts(n: number, m: number, k: number): number` to solve the following problem:\nGiven a rectangle paper of size n x m placed on a plane Cartesian coordinate system with its bottom-left corner at (0,0) and top-right corner at (n,m), you need to calculate the expected number of operations to cut the paper such that the remaining area is less than k. In each operation, a line is randomly chosen that is parallel to the axes, passes through points with integer coordinates, and cuts through (not just touching the edge) the paper. The bottom or right part of the paper along this line is then discarded. The answer should be modulo 10^9+7.\n\nFor example:\n   expectedCuts(3, 3, 4) // returns 3\n   expectedCuts(5, 5, 12) // returns 2\n",
      "sq": "Shkruani një funksion TypeScript `function expectedCuts(n: number, m: number, k: number): number` për të zgjidhur problemin e mëposhtëm:\nDuke pasur një letër drejtkëndëshe me përmasa n x m të vendosur në një sistem koordinativ kartezian me këndin e poshtëm të majtë në (0,0) dhe këndin e sipërm të djathtë në (n,m), ju duhet të llogaritni numrin e pritur të operacioneve për të prerë letrën në mënyrë që sipërfaqja e mbetur të jetë më pak se k. Në secilën operacion, zgjidhet rastësisht një vijë që është paralele me boshtet, kalon përmes pikave me koordinata të plota dhe pret (jo vetëm prek skajin) letrën. Pjesa e poshtme ose e djathtë e letrës përgjatë kësaj vije më pas hidhet poshtë. Përgjigjja duhet të jetë modulo 10^9+7.\n\nPër shembull:\n   expectedCuts(3, 3, 4) // kthen 3\n   expectedCuts(5, 5, 12) // kthen 2",
      "hy": "TypeScript ֆունկցիա գրեք `function expectedCuts(n: number, m: number, k: number): number` հետևյալ խնդիրը լուծելու համար:\nՏրված է n x m չափսի ուղղանկյուն թուղթ, որը տեղադրված է հարթության կարտեզյան կոորդինատային համակարգում՝ իր ներքևի ձախ անկյունը (0,0) կետում և վերևի աջ անկյունը (n,m) կետում, դուք պետք է հաշվեք գործողությունների սպասվող քանակը՝ թուղթը կտրելու համար այնպես, որ մնացած մակերեսը լինի k-ից փոքր: Յուրաքանչյուր գործողության ժամանակ պատահականորեն ընտրվում է գիծ, որը զուգահեռ է առանցքներին, անցնում է ամբողջ թվային կոորդինատներով կետերով և կտրում է թուղթը (ոչ միայն եզրին դիպչելով): Թղթի այս գծի երկայնքով ներքևի կամ աջ հատվածը ապա հեռացվում է: Պատասխանը պետք է լինի 10^9+7 մոդուլով:\n\nՕրինակ՝\n   expectedCuts(3, 3, 4) // վերադարձնում է 3\n   expectedCuts(5, 5, 12) // վերադարձնում է 2",
      "bn": "TypeScript ফাংশন `function expectedCuts(n: number, m: number, k: number): number` লিখুন নিম্নলিখিত সমস্যার সমাধানের জন্য:\nধরা যাক একটি আয়তাকার কাগজের আকার n x m, যা একটি সমতল কার্টেসিয়ান স্থানাঙ্ক পদ্ধতিতে (0,0) থেকে (n,m) পর্যন্ত স্থাপন করা হয়েছে, আপনাকে কাগজটি কাটার জন্য প্রত্যাশিত অপারেশনের সংখ্যা গণনা করতে হবে যাতে অবশিষ্ট এলাকা k এর চেয়ে কম হয়। প্রতিটি অপারেশনে, একটি লাইন এলোমেলোভাবে নির্বাচন করা হয় যা অক্ষের সমান্তরাল, পূর্ণসংখ্যা স্থানাঙ্ক সহ বিন্দুগুলির মধ্য দিয়ে যায় এবং কাগজের মধ্য দিয়ে কাটে (শুধু প্রান্ত স্পর্শ নয়)। এই লাইনের বরাবর কাগজের নিচের বা ডানদিকের অংশটি তারপর বাতিল করা হয়। উত্তরটি 10^9+7 মডুলোতে হওয়া উচিত।\n\nউদাহরণস্বরূপ:\n   expectedCuts(3, 3, 4) // 3 রিটার্ন করে\n   expectedCuts(5, 5, 12) // 2 রিটার্ন করে",
      "bg": "Напишете функция на TypeScript `function expectedCuts(n: number, m: number, k: number): number`, за да решите следния проблем:\nДаден е правоъгълен лист хартия с размер n x m, разположен в равнинна декартова координатна система с долния ляв ъгъл в (0,0) и горния десен ъгъл в (n,m). Трябва да изчислите очаквания брой операции за изрязване на хартията така, че останалата площ да е по-малка от k. При всяка операция се избира произволна линия, която е успоредна на осите, минава през точки с цели координати и пресича (не само докосва ръба) хартията. Долната или дясната част на хартията по тази линия след това се изхвърля. Отговорът трябва да бъде модул 10^9+7.\n\nНапример:\n   expectedCuts(3, 3, 4) // връща 3\n   expectedCuts(5, 5, 12) // връща 2",
      "zh": "编写一个 TypeScript 函数 `function expectedCuts(n: number, m: number, k: number): number` 来解决以下问题：\n给定一个大小为 n x m 的矩形纸张，放置在平面笛卡尔坐标系中，其左下角在 (0,0) 处，右上角在 (n,m) 处，你需要计算操作的期望次数，以便将纸张切割到剩余面积小于 k。在每次操作中，随机选择一条与坐标轴平行的线，该线通过整数坐标的点，并切割（不仅仅是触碰边缘）纸张。然后沿着这条线丢弃纸张的底部或右侧部分。答案应为模 10^9+7。\n\n例如：\n   expectedCuts(3, 3, 4) // 返回 3\n   expectedCuts(5, 5, 12) // 返回 2",
      "fr": "Écrire une fonction TypeScript `function expectedCuts(n: number, m: number, k: number): number` pour résoudre le problème suivant :\nÉtant donné un papier rectangulaire de taille n x m placé sur un système de coordonnées cartésiennes avec son coin inférieur gauche à (0,0) et son coin supérieur droit à (n,m), vous devez calculer le nombre attendu d'opérations pour couper le papier de sorte que la surface restante soit inférieure à k. À chaque opération, une ligne est choisie au hasard, parallèle aux axes, passant par des points avec des coordonnées entières, et coupe (sans seulement toucher le bord) le papier. La partie inférieure ou droite du papier le long de cette ligne est ensuite jetée. La réponse doit être modulo 10^9+7.\n\nPar exemple :\n   expectedCuts(3, 3, 4) // retourne 3\n   expectedCuts(5, 5, 12) // retourne 2",
      "de": "Schreiben Sie eine TypeScript-Funktion `function expectedCuts(n: number, m: number, k: number): number`, um das folgende Problem zu lösen:\nGegeben ist ein rechteckiges Papier der Größe n x m, das in einem kartesischen Koordinatensystem auf einer Ebene platziert ist, mit seiner unteren linken Ecke bei (0,0) und der oberen rechten Ecke bei (n,m). Sie müssen die erwartete Anzahl von Operationen berechnen, um das Papier so zu schneiden, dass die verbleibende Fläche kleiner als k ist. Bei jeder Operation wird zufällig eine Linie gewählt, die parallel zu den Achsen verläuft, durch Punkte mit ganzzahligen Koordinaten geht und das Papier durchschneidet (nicht nur den Rand berührt). Der untere oder rechte Teil des Papiers entlang dieser Linie wird dann verworfen. Die Antwort sollte modulo 10^9+7 sein.\n\nZum Beispiel:\n   expectedCuts(3, 3, 4) // gibt 3 zurück\n   expectedCuts(5, 5, 12) // gibt 2 zurück",
      "ha": "Rubuta aikin TypeScript `function expectedCuts(n: number, m: number, k: number): number` don warware matsalar mai zuwa:\nAn ba da takardar rectangle mai girman n x m da aka sanya a kan tsarin daidaitawa na Cartesian tare da kusurwar ƙasa-hagu a (0,0) da kusurwar sama-dama a (n,m), kuna buƙatar ƙididdige adadin ayyukan da ake tsammani don yanke takardar ta yadda yankin da ya rage ya zama ƙasa da k. A kowane aiki, ana zaɓar layi da bazuwar wanda yake daidai da ginshiƙai, yana wucewa ta wuraren da ke da daidaitattun lambobi, kuma yana yanke (ba kawai taɓa gefen ba) takardar. Sashin ƙasa ko dama na takardar tare da wannan layin sai a yar da shi. Amsar ya kamata ta zama modulo 10^9+7.\n\nAlal misali:\n   expectedCuts(3, 3, 4) // yana dawowa 3\n   expectedCuts(5, 5, 12) // yana dawowa 2",
      "hi": "TypeScript फ़ंक्शन `function expectedCuts(n: number, m: number, k: number): number` लिखें ताकि निम्नलिखित समस्या का समाधान किया जा सके:\nदिया गया है एक आयताकार कागज जिसका आकार n x m है, जो एक समतल कार्टेशियन निर्देशांक प्रणाली पर रखा गया है, जिसमें इसका निचला-बायां कोना (0,0) पर है और ऊपरी-दायां कोना (n,m) पर है। आपको उन ऑपरेशनों की अपेक्षित संख्या की गणना करनी है जिनके द्वारा कागज को इस तरह काटा जाए कि शेष क्षेत्रफल k से कम हो। प्रत्येक ऑपरेशन में, एक रेखा यादृच्छिक रूप से चुनी जाती है जो अक्षों के समानांतर होती है, पूर्णांक निर्देशांक वाले बिंदुओं से गुजरती है, और कागज को काटती है (सिर्फ किनारे को छूने के बजाय)। इस रेखा के साथ कागज का निचला या दायां भाग तब हटा दिया जाता है। उत्तर को 10^9+7 के माड्यूलो में होना चाहिए।\n\nउदाहरण के लिए:\n   expectedCuts(3, 3, 4) // 3 लौटाता है\n   expectedCuts(5, 5, 12) // 2 लौटाता है",
      "hu": "Írj egy TypeScript függvényt `function expectedCuts(n: number, m: number, k: number): number` a következő probléma megoldására:\nAdott egy n x m méretű téglalap alakú papír, amely a sík Descartes-koordinátarendszerben helyezkedik el úgy, hogy az alsó-bal sarok a (0,0) pontban van, a felső-jobb sarok pedig az (n,m) pontban. Ki kell számítanod a várható műveletek számát ahhoz, hogy a papírt úgy vágd fel, hogy a megmaradó terület kisebb legyen, mint k. Minden művelet során véletlenszerűen választunk egy vonalat, amely párhuzamos a tengelyekkel, egész koordinátájú pontokon halad át, és átvágja (nem csak érinti a szélét) a papírt. A vonal mentén a papír alsó vagy jobb oldali része el lesz távolítva. Az eredményt a 10^9+7 modullal kell megadni.\n\nPéldául:\n   expectedCuts(3, 3, 4) // visszaadja 3\n   expectedCuts(5, 5, 12) // visszaadja 2"
    },
    "instruction_bertscore": {
      "sq": "0.9665127054309471",
      "hy": "0.943077697185308",
      "bn": "0.9362444148169458",
      "bg": "0.9459475089305001",
      "zh": "0.9671328294805381",
      "fr": "0.973890433673726",
      "de": "0.969706086066845",
      "ha": "0.9536380800234088",
      "hi": "0.9573123448117922",
      "hu": "0.933968110650286"
    },
    "level": "hard",
    "test": "function testExpectedCuts(): void {\n    console.assert(expectedCuts(2, 4, 10) === 0, 'Test 1 failed');\n    console.assert(expectedCuts(2, 4, 8) === 1, 'Test 2 failed');\n    console.assert(expectedCuts(2, 4, 2) === 833333342, 'Test 3 failed');\n    console.assert(expectedCuts(2, 4, 6) === 250000003, 'Test 4 failed');\n    console.assert(expectedCuts(3, 3, 4) === 666666673, 'Test 5 failed');\n    console.assert(expectedCuts(5, 5, 12) === 666666673, 'Test 6 failed');\n    console.assert(expectedCuts(6, 7, 20) === 722222229, 'Test 7 failed');\n    console.assert(expectedCuts(10, 10, 50) === 714285721, 'Test 9 failed');\n    console.assert(expectedCuts(1, 10, 5) === 945634929, 'Test 10 failed');\n    console.assert(expectedCuts(10, 1, 5) === 945634929, 'Test 11 failed');\n}\n\ntestExpectedCuts();",
    "entry_point": "expectedCuts",
    "signature": "function expectedCuts(n: number, m: number, k: number): number",
    "docstring": {
      "en": "Given a rectangle paper of size n x m placed on a plane Cartesian coordinate system with its bottom-left corner at (0,0) and top-right corner at (n,m), you need to calculate the expected number of operations to cut the paper such that the remaining area is less than k. In each operation, a line is randomly chosen that is parallel to the axes, passes through points with integer coordinates, and cuts through (not just touching the edge) the paper. The bottom or right part of the paper along this line is then discarded. The answer should be modulo 10^9+7.\n\nFor example:\n   expectedCuts(3, 3, 4) // returns 3\n   expectedCuts(5, 5, 12) // returns 2\n",
      "sq": "Given një letër drejtkëndore me përmasa n x m e vendosur në një sistem koordinativ Kartesian të planit me këndin e poshtëm të majtë në (0,0) dhe këndin e sipërm të djathtë në (n,m), ju duhet të llogaritni numrin e pritur të operacioneve për të prerë letrën në mënyrë që sipërfaqja e mbetur të jetë më pak se k. Në secilën operacion, zgjidhet rastësisht një vijë që është paralele me boshtet, kalon përmes pikave me koordinata të plota, dhe pret (jo vetëm prek skajin) letrën. Pjesa e poshtme ose e djathtë e letrës përgjatë kësaj vije më pas hidhet poshtë. Përgjigja duhet të jetë modulo 10^9+7.\n\nPër shembull:\n   expectedCuts(3, 3, 4) // kthen 3\n   expectedCuts(5, 5, 12) // kthen 2",
      "hy": "Տրված է n x m չափսի ուղղանկյուն թուղթ, որը տեղադրված է հարթության Կարտեզյան կոորդինատային համակարգում՝ իր ներքևի ձախ անկյունով (0,0) կետում և վերևի աջ անկյունով (n,m) կետում, դուք պետք է հաշվեք սպասվող գործողությունների քանակը, որպեսզի կտրեք թուղթը այնպես, որ մնացած մակերեսը լինի փոքր քան k: Յուրաքանչյուր գործողության ժամանակ պատահականորեն ընտրվում է գիծ, որը զուգահեռ է առանցքներին, անցնում է ամբողջ թվային կոորդինատներով կետերով և կտրում է թուղթը (ոչ միայն հպվում է եզրին): Թղթի այս գծի երկայնքով ներքևի կամ աջ մասերը ապա հեռացվում են: Պատասխանը պետք է լինի 10^9+7 մոդուլով:\n\nՕրինակ՝\n   expectedCuts(3, 3, 4) // վերադարձնում է 3\n   expectedCuts(5, 5, 12) // վերադարձնում է 2",
      "bn": "একটি আয়তাকার কাগজের আকার n x m একটি প্লেন কার্টেসিয়ান কোঅর্ডিনেট সিস্টেমে রাখা হয়েছে যার নিচের-বাম কোণ (0,0) এবং উপরের-ডান কোণ (n,m) এ। আপনাকে এমন অপারেশনগুলির প্রত্যাশিত সংখ্যা গণনা করতে হবে যাতে কাগজ কাটার পর অবশিষ্ট এলাকা k এর চেয়ে কম হয়। প্রতিটি অপারেশনে, একটি লাইন এলোমেলোভাবে নির্বাচিত হয় যা অক্ষের সমান্তরাল, পূর্ণসংখ্যা কোঅর্ডিনেট সহ বিন্দুগুলির মধ্য দিয়ে যায় এবং কাগজের মধ্য দিয়ে কাটে (শুধুমাত্র প্রান্ত স্পর্শ করে না)। এই লাইনের বরাবর কাগজের নিচ বা ডান অংশটি তারপর বাতিল করা হয়। উত্তরটি 10^9+7 দ্বারা মডুলো করা উচিত।\n\nউদাহরণস্বরূপ:\n   expectedCuts(3, 3, 4) // 3 ফেরত দেয়\n   expectedCuts(5, 5, 12) // 2 ফেরত দেয়",
      "bg": "Даден е правоъгълен лист хартия с размер n x m, разположен в равнинна декартова координатна система с долен ляв ъгъл в (0,0) и горен десен ъгъл в (n,m). Трябва да изчислите очаквания брой операции за рязане на хартията така, че оставащата площ да е по-малка от k. При всяка операция се избира случайна линия, която е успоредна на осите, минава през точки с цели координати и пресича (не само докосва ръба) хартията. Долната или дясната част на хартията по тази линия след това се изхвърля. Отговорът трябва да бъде модул 10^9+7.\n\nНапример:\n   expectedCuts(3, 3, 4) // връща 3\n   expectedCuts(5, 5, 12) // връща 2",
      "zh": "给定一个大小为 n x m 的矩形纸张，放置在平面直角坐标系中，其左下角在 (0,0) 处，右上角在 (n,m) 处，你需要计算切割纸张的期望操作次数，使得剩余面积小于 k。在每次操作中，随机选择一条平行于坐标轴的直线，该直线通过整数坐标的点，并切割（不仅仅是接触边缘）纸张。然后沿着这条线丢弃纸张的底部或右侧部分。答案应取模 10^9+7。\n\n例如：\n   expectedCuts(3, 3, 4) // 返回 3\n   expectedCuts(5, 5, 12) // 返回 2",
      "fr": "Étant donné un papier rectangulaire de taille n x m placé sur un système de coordonnées cartésiennes avec son coin inférieur gauche à (0,0) et son coin supérieur droit à (n,m), vous devez calculer le nombre attendu d'opérations pour couper le papier de sorte que la surface restante soit inférieure à k. À chaque opération, une ligne est choisie au hasard, parallèle aux axes, passant par des points avec des coordonnées entières, et coupant (pas seulement touchant le bord) le papier. La partie inférieure ou droite du papier le long de cette ligne est ensuite jetée. La réponse doit être modulo 10^9+7.\n\nPar exemple :\n   expectedCuts(3, 3, 4) // retourne 3\n   expectedCuts(5, 5, 12) // retourne 2",
      "de": "Angenommen, ein rechteckiges Papier der Größe n x m liegt in einem kartesischen Koordinatensystem mit seiner unteren linken Ecke bei (0,0) und der oberen rechten Ecke bei (n,m). Sie müssen die erwartete Anzahl von Operationen berechnen, um das Papier so zu schneiden, dass die verbleibende Fläche kleiner als k ist. Bei jeder Operation wird eine Linie zufällig gewählt, die parallel zu den Achsen verläuft, durch Punkte mit ganzzahligen Koordinaten geht und das Papier durchschneidet (nicht nur den Rand berührt). Der untere oder rechte Teil des Papiers entlang dieser Linie wird dann verworfen. Die Antwort sollte modulo 10^9+7 sein.\n\nZum Beispiel:\n   expectedCuts(3, 3, 4) // gibt 3 zurück\n   expectedCuts(5, 5, 12) // gibt 2 zurück",
      "ha": "An ba takardar murabba'i mai girman n x m da aka sanya a kan tsarin daidaitawa na Cartesian tare da kusurwar ƙasa-hagu a (0,0) da kusurwar sama-dama a (n,m), kuna buƙatar ƙididdige adadin ayyukan da ake tsammani don yanke takardar ta yadda yankin da ya rage ya zama ƙasa da k. A cikin kowane aiki, ana zaɓar layi da bazuwar wanda yake daidai da ginshiƙai, yana wucewa ta wuraren da ke da daidaitattun lambobi, kuma yana yanke (ba kawai taɓa gefen ba) takardar. Ana zubar da ƙasa ko ɓangaren dama na takardar tare da wannan layin. Amsar ya kamata ta zama modulo 10^9+7.\n\nMisali:\n   expectedCuts(3, 3, 4) // yana dawowa 3\n   expectedCuts(5, 5, 12) // yana dawowa 2",
      "hi": "Given a rectangle paper of size n x m placed on a plane Cartesian coordinate system with its bottom-left corner at (0,0) and top-right corner at (n,m), you need to calculate the expected number of operations to cut the paper such that the remaining area is less than k. In each operation, a line is randomly chosen that is parallel to the axes, passes through points with integer coordinates, and cuts through (not just touching the edge) the paper. The bottom or right part of the paper along this line is then discarded. The answer should be modulo 10^9+7.\n\nउदाहरण के लिए:\n   expectedCuts(3, 3, 4) // 3 लौटाता है\n   expectedCuts(5, 5, 12) // 2 लौटाता है",
      "hu": "Adott egy n x m méretű téglalap alakú papír, amely a sík derékszögű koordináta-rendszerben helyezkedik el, bal alsó sarka a (0,0) pontban, jobb felső sarka pedig az (n,m) pontban van. Ki kell számítani a várható műveletek számát, hogy a papírt úgy vágjuk el, hogy a megmaradt terület kisebb legyen, mint k. Minden művelet során véletlenszerűen választunk egy vonalat, amely párhuzamos a tengelyekkel, egész koordinátájú pontokon halad át, és átvágja (nem csak érinti a szélét) a papírt. A papír ezen vonal mentén lévő alsó vagy jobb része ezután eldobásra kerül. Az eredményt 10^9+7 modulo szerint kell megadni.\n\nPéldául:\n   expectedCuts(3, 3, 4) // visszaadja 3\n   expectedCuts(5, 5, 12) // visszaadja 2"
    },
    "docstring_bertscore": {
      "sq": "0.9578869825041261",
      "hy": "0.9558639320732858",
      "bn": "0.9532205589624735",
      "bg": "0.9448707336349099",
      "zh": "0.9498875411687081",
      "fr": "0.9736816731432584",
      "de": "0.9565440424979492",
      "ha": "0.9378491496653266",
      "hi": "0.999999801369619",
      "hu": "0.9309171479975901"
    }
  },
  {
    "task_id": "TypeScript/43",
    "prompt": {
      "en": "\n/**\n * Given a permutation q of n elements and an integer k, find the number of permutations p of n elements\n * such that f(p) = q, where f(p) is the lexicographically smallest permutation that can be obtained by\n * dividing p into exactly k non-empty contiguous segments and sorting each segment (i.e., choose k-1\n * breakpoints 1 <= x1 < x2 < ... < x(k-1) < n, and divide it into [1, x1], (x1, x2], ..., (x(k-1), n]).\n * The result should be modulo 998244353.\n *\n * @example\n * countPermutations(2, 1, [1, 2]) // returns 2\n */\nfunction countPermutations(n: number, k: number, q: number[]): number",
      "sq": "/**\n * Duke pasur një permutacion q të n elementeve dhe një numër të plotë k, gjeni numrin e permutacioneve p të n elementeve\n * të tilla që f(p) = q, ku f(p) është permutacioni më i vogël leksikografik që mund të merret duke\n * ndarë p në saktësisht k segmente të pandryshueshme dhe duke renditur secilin segment (dmth, zgjidhni k-1\n * pika ndarjeje 1 <= x1 < x2 < ... < x(k-1) < n, dhe ndajeni atë në [1, x1], (x1, x2], ..., (x(k-1), n]).\n * Rezultati duhet të jetë modulo 998244353.\n *\n * @example\n * countPermutations(2, 1, [1, 2]) // kthen 2\n */\nfunction countPermutations(n: number, k: number, q: number[]): number",
      "hy": "/**\n * Տրված է n տարրերի q փոխատեղումը և k ամբողջ թիվը, գտնել n տարրերի p փոխատեղումների քանակը,\n * այնպես, որ f(p) = q, որտեղ f(p)-ն լեքսիկոգրաֆիկորեն ամենափոքր փոխատեղումն է, որը կարելի է ստանալ\n * p-ն բաժանելով ճիշտ k ոչ դատարկ հարակից հատվածների և դասավորելով յուրաքանչյուր հատվածը (այսինքն՝ ընտրել k-1\n * կոտրման կետեր 1 <= x1 < x2 < ... < x(k-1) < n, և բաժանել այն [1, x1], (x1, x2], ..., (x(k-1), n]).\n * Արդյունքը պետք է լինի 998244353 մոդուլով:\n *\n * @example\n * countPermutations(2, 1, [1, 2]) // վերադարձնում է 2\n */\nfunction countPermutations(n: number, k: number, q: number[]): number",
      "bn": "/**\n * n উপাদানের একটি permutation q এবং একটি পূর্ণসংখ্যা k দেওয়া আছে, এমন n উপাদানের permutation p এর সংখ্যা খুঁজে বের করুন\n * যাতে f(p) = q, যেখানে f(p) হল lexicographically ক্ষুদ্রতম permutation যা পাওয়া যেতে পারে\n * p কে ঠিক k টি খালি না থাকা contiguous segment এ ভাগ করে এবং প্রতিটি segment কে সাজিয়ে (অর্থাৎ, k-1\n * breakpoints 1 <= x1 < x2 < ... < x(k-1) < n নির্বাচন করে, এবং এটিকে [1, x1], (x1, x2], ..., (x(k-1), n] এ ভাগ করুন)।\n * ফলাফলটি 998244353 দ্বারা modulo করা উচিত।\n *\n * @example\n * countPermutations(2, 1, [1, 2]) // returns 2\n */\nfunction countPermutations(n: number, k: number, q: number[]): number",
      "bg": "/**\n * Дадена е пермутация q от n елемента и цяло число k, намерете броя на пермутациите p от n елемента\n * такива че f(p) = q, където f(p) е лексикографски най-малката пермутация, която може да бъде получена чрез\n * разделяне на p на точно k непразни съседни сегмента и сортиране на всеки сегмент (т.е. изберете k-1\n * точки на прекъсване 1 <= x1 < x2 < ... < x(k-1) < n, и го разделете на [1, x1], (x1, x2], ..., (x(k-1), n]).\n * Резултатът трябва да бъде модуло 998244353.\n *\n * @пример\n * countPermutations(2, 1, [1, 2]) // връща 2\n */\nfunction countPermutations(n: number, k: number, q: number[]): number",
      "zh": "/**\n * 给定一个由 n 个元素组成的排列 q 和一个整数 k，找出有多少个 n 个元素的排列 p\n * 满足 f(p) = q，其中 f(p) 是可以通过将 p 分成恰好 k 个非空连续段并对每个段进行排序得到的字典序最小的排列\n * （即选择 k-1 个断点 1 <= x1 < x2 < ... < x(k-1) < n，并将其分为 [1, x1], (x1, x2], ..., (x(k-1), n]）。\n * 结果应对 998244353 取模。\n *\n * @example\n * countPermutations(2, 1, [1, 2]) // returns 2\n */\nfunction countPermutations(n: number, k: number, q: number[]): number",
      "fr": "/**\n * Étant donné une permutation q de n éléments et un entier k, trouvez le nombre de permutations p de n éléments\n * telles que f(p) = q, où f(p) est la permutation lexicographiquement la plus petite qui peut être obtenue en\n * divisant p en exactement k segments contigus non vides et en triant chaque segment (c'est-à-dire, choisissez k-1\n * points de rupture 1 <= x1 < x2 < ... < x(k-1) < n, et divisez-le en [1, x1], (x1, x2], ..., (x(k-1), n]).\n * Le résultat doit être modulo 998244353.\n *\n * @example\n * countPermutations(2, 1, [1, 2]) // returns 2\n */\nfunction countPermutations(n: number, k: number, q: number[]): number",
      "de": "/**\n * Gegeben eine Permutation q von n Elementen und eine ganze Zahl k, finde die Anzahl der Permutationen p von n Elementen\n * so dass f(p) = q, wobei f(p) die lexikographisch kleinste Permutation ist, die durch\n * Aufteilen von p in genau k nicht-leere zusammenhängende Segmente und Sortieren jedes Segments erhalten werden kann (d.h., wähle k-1\n * Trennpunkte 1 <= x1 < x2 < ... < x(k-1) < n, und teile es in [1, x1], (x1, x2], ..., (x(k-1), n]).\n * Das Ergebnis sollte modulo 998244353 sein.\n *\n * @example\n * countPermutations(2, 1, [1, 2]) // gibt 2 zurück\n */\nfunction countPermutations(n: number, k: number, q: number[]): number",
      "ha": "/**\n * An ba permutation q na abubuwa n da kuma lamba k, nemo yawan permutations p na abubuwa n\n * ta yadda f(p) = q, inda f(p) shine permutation mafi ƙarami a cikin jerin haruffa wanda za'a iya samu ta\n * hanyar raba p zuwa k yankuna masu cike da abubuwa kuma a tsara kowane yanki (wato, zaɓi k-1\n * wuraren tsagi 1 <= x1 < x2 < ... < x(k-1) < n, kuma a raba shi zuwa [1, x1], (x1, x2], ..., (x(k-1), n]).\n * Sakamakon ya kasance modulo 998244353.\n *\n * @example\n * countPermutations(2, 1, [1, 2]) // returns 2\n */\nfunction countPermutations(n: number, k: number, q: number[]): number",
      "hi": "/**\n * दिए गए n तत्वों के एक क्रमचय q और एक पूर्णांक k के लिए, n तत्वों के क्रमचयों की संख्या खोजें\n * ताकि f(p) = q हो, जहाँ f(p) वह शब्दकोशीय रूप से सबसे छोटा क्रमचय है जो प्राप्त किया जा सकता है\n * p को ठीक k गैर-खाली सन्निहित खंडों में विभाजित करके और प्रत्येक खंड को क्रमबद्ध करके (यानी, k-1\n * ब्रेकपॉइंट चुनें 1 <= x1 < x2 < ... < x(k-1) < n, और इसे [1, x1], (x1, x2], ..., (x(k-1), n] में विभाजित करें)।\n * परिणाम 998244353 के मापांक में होना चाहिए।\n *\n * @example\n * countPermutations(2, 1, [1, 2]) // 2 लौटाता है\n */\nfunction countPermutations(n: number, k: number, q: number[]): number",
      "hu": "/**\n * Adott egy q permutáció n elemről és egy egész szám k, keresse meg az n elem p permutációinak számát\n * úgy, hogy f(p) = q, ahol f(p) a lexikográfiailag legkisebb permutáció, amelyet úgy lehet megkapni,\n * hogy p-t pontosan k nem üres, összefüggő szegmensre osztjuk, és minden szegmenst rendezünk (azaz válasszunk k-1\n * töréspontot 1 <= x1 < x2 < ... < x(k-1) < n, és osszuk fel [1, x1], (x1, x2], ..., (x(k-1), n] részekre).\n * Az eredménynek 998244353-mal vett maradéka kell legyen.\n *\n * @példa\n * countPermutations(2, 1, [1, 2]) // visszaadja 2\n */\nfunction countPermutations(n: number, k: number, q: number[]): number"
    },
    "prompt_bertscore": {
      "sq": "0.9807952229792608",
      "hy": "0.9949037403137879",
      "bn": "0.9985092789903331",
      "bg": "0.9939465405075808",
      "zh": "0.9791990292372644",
      "fr": "0.9972430103112357",
      "de": "0.9962677351403545",
      "ha": "0.9578214344783846",
      "hi": "0.9920228052672578",
      "hu": "0.9685492627276979"
    },
    "canonical_solution": "{\n    const P = 998244353;\n    let dp: number[][] = Array.from({length: n + 1}, () => new Array(n + 1).fill(0));\n    let jc: number[] = new Array(n + 1).fill(0);\n    let f: number[] = new Array(n + 1).fill(0);\n\n    dp[0][0] = f[0] = jc[0] = 1;\n\n    for (let i = 1; i <= n; i++) {\n        jc[i] = (jc[i - 1] * i) % P;\n    }\n\n    for (let i = 1; i <= n; i++) {\n        f[i] = jc[i];\n        for (let j = 1; j < i; j++) {\n            f[i] = (f[i] + P - (f[j] * jc[i - j]) % P) % P;\n        }\n    }\n\n    for (let i = 1; i <= n; i++) {\n        for (let j = 0; j < i; j++) {\n            for (let kk = 1; kk <= n; kk++) {\n                dp[i][kk] = (dp[i][kk] + dp[j][kk - 1] * f[i - j]) % P;\n            }\n        }\n    }\n\n    let m = 0;\n    for (let i = 1; i < n; i++) {\n        if (q[i - 1] > q[i]) {\n            m = i;\n            break;\n        }\n    }\n\n    let ans = 0;\n    if (m === n || m === 0) {\n        for (let i = k; i <= n; i++) {\n            ans = (ans + dp[n][i]) % P;\n        }\n    } else {\n        for (let i = m + 1; i <= n; i++) {\n            if (i !== m + 1 && (q[i - 2] > q[i - 1] || q[i - 1] < q[m - 1])) {\n                break;\n            }\n            let c = k - 1 + i - n;\n            if (c >= 0) {\n                ans = (ans + dp[m][c] * jc[i - m - 1]) % P;\n            }\n        }\n    }\n\n    return ans;\n};",
    "instruction": {
      "en": "Write a TypeScript function `function countPermutations(n: number, k: number, q: number[]): number` to solve the following problem:\nGiven a permutation q of n elements and an integer k, find the number of permutations p of n elements such that f(p) = q, where f(p) is the lexicographically smallest permutation that can be obtained by dividing p into exactly k non-empty contiguous segments and sorting each segment (i.e., choose k-1 breakpoints 1 <= x1 < x2 < ... < x(k-1) < n, and divide it into [1, x1], (x1, x2], ..., (x(k-1), n]). The result should be modulo 998244353.\n\n@example\ncountPermutations(2, 1, [1, 2]) // returns 2",
      "sq": "Shkruani një funksion TypeScript `function countPermutations(n: number, k: number, q: number[]): number` për të zgjidhur problemin e mëposhtëm:\nDuke pasur një permutacion q të n elementeve dhe një numër të plotë k, gjeni numrin e permutacioneve p të n elementeve të tilla që f(p) = q, ku f(p) është permutacioni leksikografikisht më i vogël që mund të merret duke ndarë p në saktësisht k segmente të pandara dhe duke renditur secilin segment (d.m.th., zgjidhni k-1 pika ndarjeje 1 <= x1 < x2 < ... < x(k-1) < n, dhe ndajeni në [1, x1], (x1, x2], ..., (x(k-1), n]). Rezultati duhet të jetë modulo 998244353.\n\n@example\ncountPermutations(2, 1, [1, 2]) // kthen 2",
      "hy": "Գրեք TypeScript ֆունկցիա `function countPermutations(n: number, k: number, q: number[]): number`՝ հետևյալ խնդիրը լուծելու համար:\nՏրված է n տարրերի q փոխադրումը և k ամբողջ թիվը, գտնել n տարրերի p փոխադրումների քանակը, այնպես որ f(p) = q, որտեղ f(p)-ն լեքսիկոգրաֆիկորեն ամենափոքր փոխադրումն է, որը կարելի է ստանալ p-ն ճշգրիտ k ոչ դատարկ հարակից հատվածների բաժանելով և յուրաքանչյուր հատվածը դասավորելով (այսինքն՝ ընտրեք k-1 կոտրման կետեր 1 <= x1 < x2 < ... < x(k-1) < n, և բաժանեք այն [1, x1], (x1, x2], ..., (x(k-1), n] հատվածների): Արդյունքը պետք է լինի 998244353 մոդուլով:\n\n@example\ncountPermutations(2, 1, [1, 2]) // վերադարձնում է 2",
      "bn": "একটি TypeScript ফাংশন `function countPermutations(n: number, k: number, q: number[]): number` লিখুন নিম্নলিখিত সমস্যার সমাধানের জন্য:\nধরা যাক n উপাদানের একটি permutation q এবং একটি পূর্ণসংখ্যা k দেওয়া আছে, n উপাদানের কতগুলো permutation p আছে তা খুঁজে বের করুন যাতে f(p) = q, যেখানে f(p) হল লেক্সিকোগ্রাফিকভাবে ক্ষুদ্রতম permutation যা ঠিক k টি খালি নয় এমন ধারাবাহিক সেগমেন্টে p কে ভাগ করে এবং প্রতিটি সেগমেন্টকে সাজিয়ে পাওয়া যায় (অর্থাৎ, k-1 টি ব্রেকপয়েন্ট 1 <= x1 < x2 < ... < x(k-1) < n বেছে নিয়ে, এটিকে [1, x1], (x1, x2], ..., (x(k-1), n] এ ভাগ করা হয়)। ফলাফলটি 998244353 মডুলোতে হওয়া উচিত।\n\n@example\ncountPermutations(2, 1, [1, 2]) // 2 ফেরত দেয়",
      "bg": "Напишете функция на TypeScript `function countPermutations(n: number, k: number, q: number[]): number`, за да решите следния проблем:\nДадена е пермутация q от n елемента и цяло число k, намерете броя на пермутациите p от n елемента, такива че f(p) = q, където f(p) е лексикографски най-малката пермутация, която може да бъде получена чрез разделяне на p на точно k непразни съседни сегменти и сортиране на всеки сегмент (т.е. изберете k-1 точки на прекъсване 1 <= x1 < x2 < ... < x(k-1) < n, и го разделете на [1, x1], (x1, x2], ..., (x(k-1), n]). Резултатът трябва да бъде по модул 998244353.\n\n@example\ncountPermutations(2, 1, [1, 2]) // връща 2",
      "zh": "编写一个 TypeScript 函数 `function countPermutations(n: number, k: number, q: number[]): number` 来解决以下问题：\n给定一个 n 个元素的排列 q 和一个整数 k，找出有多少个 n 个元素的排列 p 使得 f(p) = q，其中 f(p) 是通过将 p 分成恰好 k 个非空连续段并对每个段进行排序可以得到的字典序最小的排列（即，选择 k-1 个断点 1 <= x1 < x2 < ... < x(k-1) < n，并将其划分为 [1, x1], (x1, x2], ..., (x(k-1), n]）。结果应对 998244353 取模。\n\n@example\ncountPermutations(2, 1, [1, 2]) // 返回 2",
      "fr": "Écrire une fonction TypeScript `function countPermutations(n: number, k: number, q: number[]): number` pour résoudre le problème suivant :\nÉtant donné une permutation q de n éléments et un entier k, trouver le nombre de permutations p de n éléments telles que f(p) = q, où f(p) est la permutation lexicographiquement la plus petite qui peut être obtenue en divisant p en exactement k segments contigus non vides et en triant chaque segment (c'est-à-dire, choisir k-1 points de rupture 1 <= x1 < x2 < ... < x(k-1) < n, et le diviser en [1, x1], (x1, x2], ..., (x(k-1), n]). Le résultat doit être modulo 998244353.\n\n@example\ncountPermutations(2, 1, [1, 2]) // retourne 2",
      "de": "Schreiben Sie eine TypeScript-Funktion `function countPermutations(n: number, k: number, q: number[]): number`, um das folgende Problem zu lösen:\nGegeben eine Permutation q von n Elementen und eine ganze Zahl k, finde die Anzahl der Permutationen p von n Elementen, so dass f(p) = q, wobei f(p) die lexikographisch kleinste Permutation ist, die erhalten werden kann, indem p in genau k nicht-leere zusammenhängende Segmente unterteilt und jedes Segment sortiert wird (d.h., wähle k-1 Trennpunkte 1 <= x1 < x2 < ... < x(k-1) < n, und teile es in [1, x1], (x1, x2], ..., (x(k-1), n]). Das Ergebnis sollte modulo 998244353 sein.\n\n@example\ncountPermutations(2, 1, [1, 2]) // returns 2",
      "ha": "Rubuta aikin TypeScript `function countPermutations(n: number, k: number, q: number[]): number` don warware matsalar mai zuwa:\nAn ba da permutation q na abubuwa n da kuma lamba k, gano yawan permutations p na abubuwa n irin wanda f(p) = q, inda f(p) shine mafi ƙarancin permutation a cikin tsarin haruffa wanda za'a iya samu ta hanyar raba p zuwa daidai k sassa masu ci gaba kuma a jera kowanne sashe (wato, zaɓi k-1 wuraren rarrabawa 1 <= x1 < x2 < ... < x(k-1) < n, kuma raba shi zuwa [1, x1], (x1, x2], ..., (x(k-1), n]). Sakamakon ya zama modulo 998244353.\n\n@example\ncountPermutations(2, 1, [1, 2]) // returns 2",
      "hi": "TypeScript फ़ंक्शन `function countPermutations(n: number, k: number, q: number[]): number` लिखें ताकि निम्नलिखित समस्या का समाधान किया जा सके:\nदिए गए n तत्वों के एक क्रमचय q और एक पूर्णांक k के लिए, n तत्वों के क्रमचयों की संख्या खोजें ताकि f(p) = q हो, जहाँ f(p) वह शब्दकोशीय रूप से सबसे छोटा क्रमचय है जो p को ठीक k गैर-खाली सतत खंडों में विभाजित करके और प्रत्येक खंड को क्रमबद्ध करके प्राप्त किया जा सकता है (अर्थात, k-1 ब्रेकपॉइंट चुनें 1 <= x1 < x2 < ... < x(k-1) < n, और इसे [1, x1], (x1, x2], ..., (x(k-1), n] में विभाजित करें)। परिणाम 998244353 के मापांक के रूप में होना चाहिए।\n\n@example\ncountPermutations(2, 1, [1, 2]) // returns 2",
      "hu": "Írj egy TypeScript függvényt `function countPermutations(n: number, k: number, q: number[]): number` a következő probléma megoldására:\nAdott egy q permutáció n elemről és egy egész szám k, találd meg azon p permutációk számát n elemről, amelyekre f(p) = q, ahol f(p) a lexikografikusan legkisebb permutáció, amelyet úgy kaphatunk meg, hogy p-t pontosan k nem üres, összefüggő szegmensre osztjuk, és mindegyik szegmenst sorba rendezzük (azaz válasszunk k-1 töréspontot 1 <= x1 < x2 < ... < x(k-1) < n, és osszuk fel [1, x1], (x1, x2], ..., (x(k-1), n] részekre). Az eredményt 998244353-mal kell modulozni.\n\n@example\ncountPermutations(2, 1, [1, 2]) // visszaadja 2"
    },
    "instruction_bertscore": {
      "sq": "0.9804343115769204",
      "hy": "0.9948435553083343",
      "bn": "0.985772105806471",
      "bg": "1",
      "zh": "0.991796168002497",
      "fr": "0.99682350294649",
      "de": "1",
      "ha": "0.9681313444060005",
      "hi": "0.9801582153472819",
      "hu": "0.9800573111137162"
    },
    "level": "hard",
    "test": "console.assert(countPermutations(2, 1, [1, 2]) === 2, 'Test failed for input ([1, 2])');\nconsole.assert(countPermutations(3, 3, [3, 1, 2]) === 1, 'Test failed for input ([3, 1, 2])');\nconsole.assert(countPermutations(6, 3, [1, 2, 3, 6, 5, 4]) === 13, 'Test failed for input ([1, 2, 3, 6, 5, 4])');\nconsole.assert(countPermutations(6, 1, [1, 2, 3, 4, 5, 6]) === 720, 'Test failed for input ([1, 2, 3, 4, 5, 6])');\nconsole.assert(countPermutations(6, 3, [1, 2, 5, 3, 4, 5]) === 0, 'Test failed for input ([1, 2, 5, 3, 4, 5])');\nconsole.assert(countPermutations(9, 9, [1, 2, 3, 4, 5, 6, 7, 8, 9]) === 1, 'Test failed for input ([1, 2, 3, 4, 5, 6, 7, 8, 9])');\nconsole.assert(countPermutations(9, 2, [1, 2, 3, 4, 5, 6, 7, 9, 8]) === 29093);",
    "entry_point": "countPermutations",
    "signature": "function countPermutations(n: number, k: number, q: number[]): number",
    "docstring": {
      "en": "Given a permutation q of n elements and an integer k, find the number of permutations p of n elements such that f(p) = q, where f(p) is the lexicographically smallest permutation that can be obtained by dividing p into exactly k non-empty contiguous segments and sorting each segment (i.e., choose k-1 breakpoints 1 <= x1 < x2 < ... < x(k-1) < n, and divide it into [1, x1], (x1, x2], ..., (x(k-1), n]). The result should be modulo 998244353.\n\n@example\ncountPermutations(2, 1, [1, 2]) // returns 2",
      "sq": "Given a permutation q of n elements and an integer k, find the number of permutations p of n elements such that f(p) = q, where f(p) is the lexicographically smallest permutation that can be obtained by dividing p into exactly k non-empty contiguous segments and sorting each segment (i.e., choose k-1 breakpoints 1 <= x1 < x2 < ... < x(k-1) < n, and divide it into [1, x1], (x1, x2], ..., (x(k-1), n]). The result should be modulo 998244353.\n\n@example\ncountPermutations(2, 1, [1, 2]) // kthen 2",
      "hy": "Տրված է n տարրերի q տեղադրումը և k ամբողջ թիվը, գտնել n տարրերի p տեղադրումների քանակը, այնպես որ f(p) = q, որտեղ f(p)-ն լեքսիկոգրաֆիկորեն ամենափոքր տեղադրումն է, որը կարելի է ստանալ p-ն ճշգրիտ k ոչ դատարկ հարակից հատվածների բաժանելով և յուրաքանչյուր հատվածը դասավորելով (այսինքն՝ ընտրել k-1 կոտրման կետեր 1 <= x1 < x2 < ... < x(k-1) < n, և բաժանել այն [1, x1], (x1, x2], ..., (x(k-1), n])։ Արդյունքը պետք է լինի 998244353 մոդուլով։\n\n@example\ncountPermutations(2, 1, [1, 2]) // վերադարձնում է 2",
      "bn": "প্রদত্ত একটি n উপাদানের পারমুটেশন q এবং একটি পূর্ণসংখ্যা k, এমন কতগুলি পারমুটেশন p আছে তা খুঁজে বের করুন যেখানে f(p) = q, যেখানে f(p) হল লেক্সিকোগ্রাফিকভাবে ক্ষুদ্রতম পারমুটেশন যা p কে ঠিক k টি খালি না থাকা সন্নিহিত সেগমেন্টে ভাগ করে এবং প্রতিটি সেগমেন্টকে সাজিয়ে প্রাপ্ত করা যায় (অর্থাৎ, k-1 টি ব্রেকপয়েন্ট 1 <= x1 < x2 < ... < x(k-1) < n নির্বাচন করুন, এবং এটিকে [1, x1], (x1, x2], ..., (x(k-1), n] এ ভাগ করুন)। ফলাফলটি 998244353 দ্বারা মডুলো করা উচিত।\n\n@example\ncountPermutations(2, 1, [1, 2]) // 2 ফেরত দেয়",
      "bg": "Дадена е пермутация q от n елемента и цяло число k, намерете броя на пермутациите p от n елемента, такива че f(p) = q, където f(p) е лексикографски най-малката пермутация, която може да бъде получена чрез разделяне на p на точно k непразни съседни сегмента и сортиране на всеки сегмент (т.е., изберете k-1 точки на прекъсване 1 <= x1 < x2 < ... < x(k-1) < n, и го разделете на [1, x1], (x1, x2], ..., (x(k-1), n]). Резултатът трябва да бъде модуло 998244353.\n\n@example\ncountPermutations(2, 1, [1, 2]) // връща 2",
      "zh": "给定一个由 n 个元素组成的排列 q 和一个整数 k，找出有多少个排列 p 使得 f(p) = q，其中 f(p) 是通过将 p 精确地分成 k 个非空连续段并对每个段进行排序后得到的字典序最小的排列（即选择 k-1 个断点 1 <= x1 < x2 < ... < x(k-1) < n，并将其划分为 [1, x1], (x1, x2], ..., (x(k-1), n]）。结果应对 998244353 取模。\n\n@example\ncountPermutations(2, 1, [1, 2]) // 返回 2",
      "fr": "Étant donné une permutation q de n éléments et un entier k, trouvez le nombre de permutations p de n éléments tel que f(p) = q, où f(p) est la permutation lexicographiquement la plus petite qui peut être obtenue en divisant p en exactement k segments contigus non vides et en triant chaque segment (c'est-à-dire, choisissez k-1 points de rupture 1 <= x1 < x2 < ... < x(k-1) < n, et divisez-le en [1, x1], (x1, x2], ..., (x(k-1), n]). Le résultat doit être modulo 998244353.\n\n@example\ncountPermutations(2, 1, [1, 2]) // returns 2",
      "de": "Given a permutation q of n elements and an integer k, find the number of permutations p of n elements such that f(p) = q, where f(p) is the lexicographically smallest permutation that can be obtained by dividing p into exactly k non-empty contiguous segments and sorting each segment (i.e., choose k-1 breakpoints 1 <= x1 < x2 < ... < x(k-1) < n, and divide it into [1, x1], (x1, x2], ..., (x(k-1), n]). The result should be modulo 998244353.\n\n@Beispiel\ncountPermutations(2, 1, [1, 2]) // gibt 2 zurück",
      "ha": "Given a permutation q of n elements and an integer k, find the number of permutations p of n elements such that f(p) = q, where f(p) is the lexicographically smallest permutation that can be obtained by dividing p into exactly k non-empty contiguous segments and sorting each segment (i.e., choose k-1 breakpoints 1 <= x1 < x2 < ... < x(k-1) < n, and divide it into [1, x1], (x1, x2], ..., (x(k-1), n]). The result should be modulo 998244353.\n\n@example\ncountPermutations(2, 1, [1, 2]) // returns 2",
      "hi": "दी गई n तत्वों की एक क्रमचय q और एक पूर्णांक k के लिए, n तत्वों की उन क्रमचयों की संख्या खोजें जिनके लिए f(p) = q है, जहाँ f(p) वह शब्दकोशानुसार सबसे छोटी क्रमचय है जो p को ठीक k गैर-खाली संलग्न खंडों में विभाजित करके और प्रत्येक खंड को क्रमबद्ध करके प्राप्त की जा सकती है (अर्थात, k-1 ब्रेकपॉइंट चुनें 1 <= x1 < x2 < ... < x(k-1) < n, और इसे [1, x1], (x1, x2], ..., (x(k-1), n] में विभाजित करें)। परिणाम को 998244353 से मापांकित किया जाना चाहिए।\n\n@example\ncountPermutations(2, 1, [1, 2]) // 2 लौटाता है",
      "hu": "Adott egy n elemű q permutáció és egy k egész szám, meg kell találni azon n elemű p permutációk számát, amelyekre f(p) = q, ahol f(p) az a lexikografikusan legkisebb permutáció, amelyet úgy lehet megkapni, hogy p-t pontosan k nem üres, összefüggő szegmensre osztjuk, és minden szegmenst rendezzünk (azaz válasszunk k-1 töréspontot 1 <= x1 < x2 < ... < x(k-1) < n, és osszuk fel [1, x1], (x1, x2], ..., (x(k-1), n] részekre). Az eredményt 998244353-mal modulozva kell megadni.\n\n@példa\ncountPermutations(2, 1, [1, 2]) // visszaadja 2"
    },
    "docstring_bertscore": {
      "sq": "1",
      "hy": "0.9917079761133175",
      "bn": "0.9718961846481358",
      "bg": "1",
      "zh": "0.9573375708701836",
      "fr": "0.9961094267266697",
      "de": "0.9993038005144728",
      "ha": "0.9657646634159698",
      "hi": "0.9874034571259105",
      "hu": "0.950336843090609"
    }
  },
  {
    "task_id": "TypeScript/44",
    "prompt": {
      "en": "\n/**\n * Determines the number of ways to choose a triplet (a, b, c)\n * from an array of distinct integers representing heights such that the\n * greatest common divisor (GCD) of the maximum and minimum values\n * of the triplet is 1.\n *\n * @example\n * countTriplets([1, 5, 7])\n * // Returns: 1\n */\nfunction countTriplets(heights: number[]): number",
      "sq": "/**\n * Përcakton numrin e mënyrave për të zgjedhur një treshe (a, b, c)\n * nga një varg me numra të plotë të ndryshëm që përfaqësojnë lartësitë në mënyrë të tillë që\n * faktori më i madh i përbashkët (GCD) i vlerave maksimale dhe minimale\n * të treshes është 1.\n *\n * @example\n * countTriplets([1, 5, 7])\n * // Kthen: 1\n */\nfunction countTriplets(heights: number[]): number",
      "hy": "/**\n * Որոշում է, թե քանի եղանակով կարելի է ընտրել եռյակ (a, b, c)\n * տարբեր բարձրություններ ներկայացնող ամբողջ թվերի զանգվածից այնպես, որ\n * եռյակի առավելագույն և նվազագույն արժեքների ամենամեծ ընդհանուր բաժանարարը (GCD) լինի 1:\n *\n * @օրինակ\n * countTriplets([1, 5, 7])\n * // Վերադարձնում է: 1\n */\nfunction countTriplets(heights: number[]): number",
      "bn": "/**\n * একটি অ্যারের ভিন্ন পূর্ণসংখ্যা যা উচ্চতা উপস্থাপন করে, সেখান থেকে একটি ত্রয়ী (a, b, c) নির্বাচন করার উপায়ের সংখ্যা নির্ধারণ করে\n * যাতে ত্রয়ীর সর্বাধিক এবং সর্বনিম্ন মানের গসাগু (GCD) 1 হয়।\n *\n * @example\n * countTriplets([1, 5, 7])\n * // রিটার্ন করে: 1\n */\nfunction countTriplets(heights: number[]): number",
      "bg": "/**\n * Определя броя на начините за избор на тройка (a, b, c)\n * от масив от различни цели числа, представляващи височини, така че\n * най-големият общ делител (НОД) на максималната и минималната стойности\n * на тройката да е 1.\n *\n * @пример\n * countTriplets([1, 5, 7])\n * // Връща: 1\n */\nfunction countTriplets(heights: number[]): number",
      "zh": "/**\n * 确定从表示高度的不同整数数组中选择三元组 (a, b, c) 的方法数，\n * 使得三元组的最大值和最小值的最大公约数 (GCD) 为 1。\n *\n * @example\n * countTriplets([1, 5, 7])\n * // 返回: 1\n */\nfunction countTriplets(heights: number[]): number",
      "fr": "/**\n * Détermine le nombre de façons de choisir un triplet (a, b, c)\n * à partir d'un tableau d'entiers distincts représentant des hauteurs de sorte que le\n * plus grand commun diviseur (PGCD) des valeurs maximale et minimale\n * du triplet soit 1.\n *\n * @example\n * countTriplets([1, 5, 7])\n * // Renvoie : 1\n */\nfunction countTriplets(heights: number[]): number",
      "de": "/**\n * Bestimmt die Anzahl der Möglichkeiten, ein Tripel (a, b, c)\n * aus einem Array von verschiedenen ganzen Zahlen, die Höhen darstellen, auszuwählen, so dass der\n * größte gemeinsame Teiler (GCD) der maximalen und minimalen Werte\n * des Tripels 1 ist.\n *\n * @example\n * countTriplets([1, 5, 7])\n * // Gibt zurück: 1\n */\nfunction countTriplets(heights: number[]): number",
      "ha": "/**\n * Yana tantance adadin hanyoyin zaɓar triplet (a, b, c)\n * daga jerin lambobi masu bambanci da ke wakiltar tsayi ta yadda\n * mafi girman rabo (GCD) na mafi girma da ƙananan ƙimomi\n * na triplet ɗin shine 1.\n *\n * @example\n * countTriplets([1, 5, 7])\n * // Yana dawowa: 1\n */\nfunction countTriplets(heights: number[]): number",
      "hi": "/**\n * यह निर्धारित करता है कि एक त्रिक (a, b, c) को कितने तरीकों से चुना जा सकता है\n * एक विशिष्ट पूर्णांकों की array से जो ऊँचाइयों का प्रतिनिधित्व करते हैं ताकि\n * त्रिक के अधिकतम और न्यूनतम मानों का महत्तम समापवर्तक (GCD) 1 हो।\n *\n * @example\n * countTriplets([1, 5, 7])\n * // लौटाता है: 1\n */\nfunction countTriplets(heights: number[]): number",
      "hu": "/**\n * Meghatározza, hogy hányféleképpen lehet kiválasztani egy hármast (a, b, c)\n * egy különböző egész számokat tartalmazó tömbből, amely a magasságokat reprezentálja úgy, hogy\n * a hármas legnagyobb és legkisebb értékeinek legnagyobb közös osztója (GCD) 1.\n *\n * @example\n * countTriplets([1, 5, 7])\n * // Visszatér: 1\n */\nfunction countTriplets(heights: number[]): number"
    },
    "prompt_bertscore": {
      "sq": "0.9978047370288025",
      "hy": "0.9842944944019524",
      "bn": "0.9433204235109326",
      "bg": "0.9932008820571758",
      "zh": "0.9704602856236345",
      "fr": "0.999999801369619",
      "de": "0.9894461719644733",
      "ha": "0.9706269365133228",
      "hi": "0.9718765202404133",
      "hu": "0.961040239803055"
    },
    "canonical_solution": "{\n    let count = 0;\n    const n = heights.length;\n    for (let i = 0; i < n; ++i) {\n        for (let j = i + 1; j < n; ++j) {\n            for (let k = j + 1; k < n; ++k) {\n                const minVal = Math.min(heights[i], heights[j], heights[k]);\n                const maxVal = Math.max(heights[i], heights[j], heights[k]);\n                if (gcd(minVal, maxVal) === 1) {\n                    count++;\n                }\n            }\n        }\n    }\n    return count;\n}\n\n// Helper function to find the greatest common divisor\nfunction gcd(a: number, b: number): number {\n    while (b !== 0) {\n        let t = b;\n        b = a % b;\n        a = t;\n    }\n    return a;\n}",
    "instruction": {
      "en": "Write a TypeScript function `function countTriplets(heights: number[]): number` to solve the following problem:\nDetermines the number of ways to choose a triplet (a, b, c)\nfrom an array of distinct integers representing heights such that the\ngreatest common divisor (GCD) of the maximum and minimum values\nof the triplet is 1.\n\n@example\ncountTriplets([1, 5, 7])\n// Returns: 1\n",
      "sq": "Shkruani një funksion TypeScript `function countTriplets(heights: number[]): number` për të zgjidhur problemin në vijim:\nPërcakton numrin e mënyrave për të zgjedhur një treshe (a, b, c)\nnga një varg i numrave të plotë të dallueshëm që përfaqësojnë lartësitë në mënyrë të tillë që\npërbashkuesi më i madh i përbashkët (GCD) i vlerave maksimale dhe minimale\ntë tresheve është 1.\n\n@example\ncountTriplets([1, 5, 7])\n// Kthen: 1",
      "hy": "Գրեք TypeScript ֆունկցիա `function countTriplets(heights: number[]): number`՝ հետևյալ խնդիրը լուծելու համար:\nՈրոշում է, թե քանի եղանակով կարելի է ընտրել եռյակ (a, b, c)\nտարբեր ամբողջ թվերի զանգվածից, որոնք ներկայացնում են բարձրությունները, այնպես, որ\nեռյակի առավելագույն և նվազագույն արժեքների\nամենամեծ ընդհանուր բաժանարարը (GCD) լինի 1:\n\n@example\ncountTriplets([1, 5, 7])\n// Վերադարձնում է: 1",
      "bn": "TypeScript ফাংশন `function countTriplets(heights: number[]): number` লিখুন নিম্নলিখিত সমস্যার সমাধানের জন্য:\nএকটি ভিন্ন পূর্ণসংখ্যার অ্যারের মধ্যে থেকে একটি ত্রয়ী (a, b, c) বেছে নেওয়ার উপায়ের সংখ্যা নির্ধারণ করে যা উচ্চতাকে উপস্থাপন করে যাতে ত্রয়ীর সর্বাধিক এবং সর্বনিম্ন মানের গরিষ্ঠ সাধারণ গুণক (GCD) 1 হয়।\n\n@example\ncountTriplets([1, 5, 7])\n// Returns: 1",
      "bg": "Напишете TypeScript функция `function countTriplets(heights: number[]): number`, за да решите следния проблем:  \nОпределя броя на начините за избор на тройка (a, b, c) от масив от различни цели числа, представляващи височини, така че най-големият общ делител (НОД) на максималните и минималните стойности на тройката да е 1.\n\n@example\ncountTriplets([1, 5, 7])\n// Връща: 1",
      "zh": "编写一个 TypeScript 函数 `function countTriplets(heights: number[]): number` 来解决以下问题：\n确定从表示高度的不同整数数组中选择三元组 (a, b, c) 的方法数量，使得该三元组的最大值和最小值的最大公约数 (GCD) 为 1。\n\n@example\ncountTriplets([1, 5, 7])\n// 返回: 1",
      "fr": "Écrire une fonction TypeScript `function countTriplets(heights: number[]): number` pour résoudre le problème suivant :\nDétermine le nombre de façons de choisir un triplet (a, b, c)\nà partir d'un tableau d'entiers distincts représentant des hauteurs, tel que le\nplus grand diviseur commun (PGCD) des valeurs maximale et minimale\ndu triplet soit 1.\n\n@example\ncountTriplets([1, 5, 7])\n// Renvoie : 1",
      "de": "Schreiben Sie eine TypeScript-Funktion `function countTriplets(heights: number[]): number`, um das folgende Problem zu lösen:\nBestimmt die Anzahl der Möglichkeiten, ein Tripel (a, b, c) aus einem Array von verschiedenen ganzen Zahlen, die Höhen darstellen, auszuwählen, so dass der größte gemeinsame Teiler (GCD) der maximalen und minimalen Werte des Tripels 1 ist.\n\n@example\ncountTriplets([1, 5, 7])\n// Gibt zurück: 1",
      "ha": "Rubuta wani aikin TypeScript `function countTriplets(heights: number[]): number` don warware matsalar mai zuwa:\nYana tantance yawan hanyoyin zaɓar triplet (a, b, c)\ndaga wani tsari na lambobi masu bambanci da ke wakiltar tsayi ta yadda\nbabban mai raba kashi (GCD) na mafi girma da mafi ƙanƙanta\nna triplet ɗin shine 1.\n\n@example\ncountTriplets([1, 5, 7])\n// Yana dawowa: 1",
      "hi": "TypeScript फ़ंक्शन `function countTriplets(heights: number[]): number` लिखें ताकि निम्नलिखित समस्या का समाधान किया जा सके:\nयह निर्धारित करता है कि ऊंचाइयों को दर्शाने वाले विशिष्ट पूर्णांकों की एक array से एक triplet (a, b, c) चुनने के कितने तरीके हैं ताकि triplet के अधिकतम और न्यूनतम मानों का महत्तम समापवर्तक (GCD) 1 हो।\n\n@example\ncountTriplets([1, 5, 7])\n// Returns: 1",
      "hu": "Írj egy TypeScript függvényt `function countTriplets(heights: number[]): number` a következő probléma megoldására:\nMeghatározza, hogy hányféleképpen lehet választani egy hármast (a, b, c)\negy különböző egész számokat tartalmazó tömbből, amely a magasságokat képviseli úgy, hogy a hármas maximum és minimum értékeinek legnagyobb közös osztója (GCD) 1 legyen.\n\n@example\ncountTriplets([1, 5, 7])\n// Visszatér: 1"
    },
    "instruction_bertscore": {
      "sq": "0.9889966714121914",
      "hy": "0.9747916197124813",
      "bn": "0.9673978024088387",
      "bg": "0.9880905196139101",
      "zh": "0.971874931197365",
      "fr": "0.9880905196139101",
      "de": "0.9816008678047383",
      "ha": "0.9591167031931132",
      "hi": "0.964706758006578",
      "hu": "0.9775206025175196"
    },
    "level": "hard",
    "test": "const main = (): void => {\n    console.assert(countTriplets([1, 5, 7]) === 1);\n    console.assert(countTriplets([1, 6, 2, 3]) === 3);\n    console.assert(countTriplets([16, 4, 8, 2]) === 0);\n    console.assert(countTriplets([10, 1, 6, 7, 9, 8, 4, 3, 5, 2]) === 77);\n    console.assert(countTriplets([4, 5, 9, 11, 14]) === 7);\n    console.assert(countTriplets([15, 10, 6, 9, 7, 3, 12, 8, 11, 1, 2]) === 104);\n    console.assert(countTriplets([3, 7, 11, 13]) === 4);\n    console.assert(countTriplets([5, 12, 13, 17, 19]) === 10);\n    console.assert(countTriplets([2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12]) === 87);\n    console.assert(countTriplets([1, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17]) === 122);\n}\n\nmain();",
    "entry_point": "countTriplets",
    "signature": "function countTriplets(heights: number[]): number",
    "docstring": {
      "en": "Determines the number of ways to choose a triplet (a, b, c)\nfrom an array of distinct integers representing heights such that the\ngreatest common divisor (GCD) of the maximum and minimum values\nof the triplet is 1.\n\n@example\ncountTriplets([1, 5, 7])\n// Returns: 1\n",
      "sq": "Përcakton numrin e mënyrave për të zgjedhur një treshe (a, b, c)\nnga një varg me numra të plotë të ndryshëm që përfaqësojnë lartësitë në mënyrë të tillë që\ndivizori më i madh i përbashkët (GCD) i vlerave maksimale dhe minimale\ntë treshes është 1.\n\n@example\ncountTriplets([1, 5, 7])\n// Kthen: 1",
      "hy": "Որոշում է, թե քանի եղանակով կարելի է ընտրել եռյակ (a, b, c) \nտարբեր բարձրությունները ներկայացնող ամբողջ թվերի զանգվածից այնպես, որ \nեռյակի առավելագույն և նվազագույն արժեքների ամենամեծ ընդհանուր բաժանարարը (GCD) լինի 1:\n\n@example\ncountTriplets([1, 5, 7])\n// Վերադարձնում է: 1",
      "bn": "নির্ধারণ করে কতভাবে একটি ত্রয়ী (a, b, c) নির্বাচন করা যায় একটি পৃথক পূর্ণসংখ্যার অ্যারে থেকে যা উচ্চতা উপস্থাপন করে, যাতে ত্রয়ীর সর্বাধিক এবং সর্বনিম্ন মানের গরিষ্ঠ সাধারণ বিভাজক (GCD) হয় 1।\n\n@example\ncountTriplets([1, 5, 7])\n// Returns: 1",
      "bg": "Определя броя на начините за избор на тройка (a, b, c) от масив от различни цели числа, представляващи височини, така че най-големият общ делител (НОД) на максималните и минималните стойности на тройката да е 1.\n\n@example\ncountTriplets([1, 5, 7])\n// Връща: 1",
      "zh": "确定从一个表示高度的不同整数数组中选择一个三元组 (a, b, c) 的方法数量，使得该三元组的最大值和最小值的最大公约数 (GCD) 为 1。\n\n@example\ncountTriplets([1, 5, 7])\n// 返回: 1",
      "fr": "Détermine le nombre de façons de choisir un triplet (a, b, c) à partir d'un tableau d'entiers distincts représentant des hauteurs, de sorte que le plus grand commun diviseur (PGCD) des valeurs maximale et minimale du triplet soit 1.\n\n@example\ncountTriplets([1, 5, 7])\n// Returns: 1",
      "de": "Bestimmt die Anzahl der Möglichkeiten, ein Tripel (a, b, c) aus einem Array von verschiedenen ganzen Zahlen zu wählen, die Höhen darstellen, so dass der größte gemeinsame Teiler (GCD) der maximalen und minimalen Werte des Tripels 1 ist.\n\n@example\ncountTriplets([1, 5, 7])\n// Gibt zurück: 1",
      "ha": "Yana tantance yawan hanyoyin zaɓar triplet (a, b, c) daga cikin jerin lambobi daban-daban masu wakiltar tsawo ta yadda mafi girman rabo na gama gari (GCD) na mafi girma da mafi ƙanƙanta ƙimomi na triplet ɗin shine 1.\n\n@misali\ncountTriplets([1, 5, 7])\n// Yana dawowa: 1",
      "hi": "निर्धारित करता है कि एक सरणी से एक त्रय (a, b, c) चुनने के कितने तरीके हैं जिसमें ऊंचाई को दर्शाने वाले भिन्न पूर्णांक होते हैं ताकि त्रय के अधिकतम और न्यूनतम मानों का महत्तम समापवर्तक (GCD) 1 हो।\n\n@example\ncountTriplets([1, 5, 7])\n// वापसी: 1",
      "hu": "Meghatározza, hogy hányféleképpen lehet kiválasztani egy hármast (a, b, c) egy különböző egész számokat tartalmazó tömbből, amely a magasságokat képviseli, úgy, hogy a hármas maximumának és minimumának legnagyobb közös osztója (GCD) 1 legyen.\n\n@example\ncountTriplets([1, 5, 7])\n// Visszatér: 1"
    },
    "docstring_bertscore": {
      "sq": "0.999999801369619",
      "hy": "0.9585659011465033",
      "bn": "0.9541942450903065",
      "bg": "0.995063836400902",
      "zh": "0.9771392321859327",
      "fr": "0.9843290560882525",
      "de": "0.989985254818602",
      "ha": "0.9403663924841817",
      "hi": "0.9550900681087738",
      "hu": "0.949334951448669"
    }
  },
  {
    "task_id": "TypeScript/45",
    "prompt": {
      "en": "\n/**\n * Given a 1 by n pixel image, each pixel has a color represented by an integer. You can change all\n * connected pixels of the same color to a chosen color, where two pixels are connected if they are\n * adjacent and have the same color. The goal is to find the minimum number of operations required\n * to make all pixels the same color.\n * Note: For each color, there are at most 20 pixels of that color.\n *\n * Examples:\n *    minOperations(5, [1, 2, 3, 2, 1]) returns 2\n */\nfunction minOperations(n: number, pixels: number[]): number",
      "sq": "/**\n * Duke pasur një imazh 1 me n piksel, secili piksel ka një ngjyrë të përfaqësuar nga një numër i plotë. Ju mund të ndryshoni të gjithë\n * piksela të lidhur të së njëjtës ngjyrë në një ngjyrë të zgjedhur, ku dy piksela janë të lidhur nëse janë\n * ngjitur dhe kanë të njëjtën ngjyrë. Qëllimi është të gjendet numri minimal i operacioneve të kërkuara\n * për të bërë të gjithë piksela të së njëjtës ngjyrë.\n * Shënim: Për çdo ngjyrë, ka maksimumi 20 piksela të asaj ngjyre.\n *\n * Shembuj:\n *    minOperations(5, [1, 2, 3, 2, 1]) kthen 2\n */\nfunction minOperations(n: number, pixels: number[]): number",
      "hy": "/**\n * Տրված է 1xն պիքսել պատկեր, որտեղ յուրաքանչյուր պիքսել ունի գույն, որը ներկայացված է ամբողջ թվով։ Դուք կարող եք փոխել\n * նույն գույնի բոլոր միացված պիքսելները ընտրված գույնի, որտեղ երկու պիքսելները միացված են, եթե դրանք հարակից են և ունեն նույն գույնը։\n * Նպատակն է գտնել նվազագույն գործողությունների քանակը, որը պահանջվում է բոլոր պիքսելները նույն գույնի դարձնելու համար։\n * Նշում. Յուրաքանչյուր գույնի համար առավելագույնը կա 20 պիքսել։\n *\n * Օրինակներ:\n *    minOperations(5, [1, 2, 3, 2, 1]) վերադարձնում է 2\n */\nfunction minOperations(n: number, pixels: number[]): number",
      "bn": "/**\n * একটি 1 বাই n পিক্সেল ইমেজ দেওয়া আছে, যেখানে প্রতিটি পিক্সেলের একটি রঙ একটি পূর্ণসংখ্যা দ্বারা প্রতিনিধিত্ব করা হয়। \n * আপনি একই রঙের সংযুক্ত সমস্ত পিক্সেল একটি পছন্দের রঙে পরিবর্তন করতে পারেন, যেখানে দুটি পিক্সেল সংযুক্ত থাকে যদি তারা সংলগ্ন হয় এবং একই রঙের হয়। \n * লক্ষ্য হল সমস্ত পিক্সেলকে একই রঙে পরিণত করতে প্রয়োজনীয় সর্বনিম্ন সংখ্যক অপারেশন খুঁজে বের করা।\n * লক্ষ্য করুন: প্রতিটি রঙের জন্য, সেই রঙের সর্বাধিক 20টি পিক্সেল থাকতে পারে।\n *\n * উদাহরণ:\n *    minOperations(5, [1, 2, 3, 2, 1]) 2 প্রদান করে\n */\nfunction minOperations(n: number, pixels: number[]): number",
      "bg": "/**\n * Дадено е изображение с размер 1 на n пиксела, като всеки пиксел има цвят, представен от цяло число. Можете да промените всички\n * свързани пиксели със същия цвят на избран цвят, където два пиксела са свързани, ако са\n * съседни и имат същия цвят. Целта е да се намери минималният брой операции, необходими\n * за да се направят всички пиксели с един и същ цвят.\n * Забележка: За всеки цвят има най-много 20 пиксела от този цвят.\n *\n * Примери:\n *    minOperations(5, [1, 2, 3, 2, 1]) връща 2\n */ \nfunction minOperations(n: number, pixels: number[]): number",
      "zh": "/**\n * 给定一个1乘n的像素图像，每个像素都有一个用整数表示的颜色。你可以将所有相同颜色的相连像素更改为一个选定的颜色，\n * 其中如果两个像素相邻且颜色相同，则它们是相连的。目标是找到使所有像素颜色相同所需的最小操作次数。\n * 注意：对于每种颜色，最多有20个该颜色的像素。\n *\n * 示例:\n *    minOperations(5, [1, 2, 3, 2, 1]) 返回 2\n */\nfunction minOperations(n: number, pixels: number[]): number",
      "fr": "/**\n * Étant donné une image de 1 par n pixels, chaque pixel a une couleur représentée par un entier. Vous pouvez changer tous\n * les pixels connectés de la même couleur en une couleur choisie, où deux pixels sont connectés s'ils sont\n * adjacents et ont la même couleur. Le but est de trouver le nombre minimum d'opérations nécessaires\n * pour rendre tous les pixels de la même couleur.\n * Remarque : Pour chaque couleur, il y a au plus 20 pixels de cette couleur.\n *\n * Exemples :\n *    minOperations(5, [1, 2, 3, 2, 1]) renvoie 2\n */\nfunction minOperations(n: number, pixels: number[]): number",
      "de": "/**\n * Gegeben ein 1x n Pixel-Bild, wobei jedes Pixel durch eine ganze Zahl repräsentiert wird. Sie können alle\n * verbundenen Pixel derselben Farbe in eine gewählte Farbe ändern, wobei zwei Pixel verbunden sind, wenn sie\n * benachbart sind und die gleiche Farbe haben. Das Ziel ist es, die minimale Anzahl von Operationen zu finden,\n * die erforderlich sind, um alle Pixel in die gleiche Farbe zu bringen.\n * Hinweis: Für jede Farbe gibt es höchstens 20 Pixel dieser Farbe.\n *\n * Beispiele:\n *    minOperations(5, [1, 2, 3, 2, 1]) gibt 2 zurück\n */\nfunction minOperations(n: number, pixels: number[]): number",
      "ha": "/**\n * An ba hoton pixel 1 ta n, kowanne pixel yana da launi wanda aka wakilta da lamba. Za ka iya canza duk\n * pixels masu haɗuwa na launi ɗaya zuwa launi da aka zaɓa, inda pixels biyu suke haɗuwa idan suna\n * kusa kuma suna da launi ɗaya. Manufar ita ce a nemo mafi ƙarancin adadin ayyuka da ake buƙata\n * don sanya duk pixels su zama launi ɗaya.\n * Lura: Ga kowanne launi, akwai a kalla pixels 20 na wannan launi.\n *\n * Misalai:\n *    minOperations(5, [1, 2, 3, 2, 1]) yana dawowa 2\n */\nfunction minOperations(n: number, pixels: number[]): number",
      "hi": "/**\n * दिए गए 1 बाय n पिक्सेल छवि में, प्रत्येक पिक्सेल का रंग एक पूर्णांक द्वारा दर्शाया गया है। आप सभी\n * जुड़े हुए पिक्सेल को एक चुने हुए रंग में बदल सकते हैं, जहाँ दो पिक्सेल जुड़े होते हैं यदि वे\n * आसन्न होते हैं और उनका रंग समान होता है। लक्ष्य यह है कि सभी पिक्सेल को एक ही रंग में बदलने के लिए\n * आवश्यक न्यूनतम ऑपरेशनों की संख्या का पता लगाना।\n * ध्यान दें: प्रत्येक रंग के लिए, उस रंग के अधिकतम 20 पिक्सेल होते हैं।\n *\n * उदाहरण:\n *    minOperations(5, [1, 2, 3, 2, 1]) 2 लौटाता है\n */\nfunction minOperations(n: number, pixels: number[]): number",
      "hu": "/**\n * Adott egy 1 x n pixeles kép, ahol minden pixel színét egy egész szám képviseli. Megváltoztathatod az összes\n * összekapcsolt, azonos színű pixelt egy választott színre, ahol két pixel akkor kapcsolódik, ha\n * szomszédosak és azonos színűek. A cél az, hogy megtaláljuk a minimális műveletszámot, amely szükséges ahhoz,\n * hogy minden pixel azonos színű legyen.\n * Megjegyzés: Minden színhez legfeljebb 20 pixel tartozik.\n *\n * Példák:\n *    minOperations(5, [1, 2, 3, 2, 1]) visszaadja 2\n */\nfunction minOperations(n: number, pixels: number[]): number"
    },
    "prompt_bertscore": {
      "sq": "0.9888459109529859",
      "hy": "0.9724066647273955",
      "bn": "0.9466826399707101",
      "bg": "0.97939587194487",
      "zh": "0.9819335736929717",
      "fr": "0.9989027657751632",
      "de": "0.9809463806992283",
      "ha": "0.9898859396280846",
      "hi": "0.9565841658349182",
      "hu": "0.9583754146110909"
    },
    "canonical_solution": "{\n    let pre = new Array(n+1).fill(0),\n        u = new Array(n+1).fill(0),\n        f = Array.from({length: n+1}, () => new Array(n+1).fill(Infinity));\n\n    for (let i = 1; i <= n; i++) {\n        pre[i] = u[pixels[i-1]];\n        u[pixels[i-1]] = i;\n    }\n    \n    for (let i = 1; i <= n; i++) {\n        f[i][i] = 0;\n    }\n    \n    for (let len = 2; len <= n; len++) {\n        for (let i = 1; i <= n - len + 1; i++) {\n            let j = i + len - 1;\n            f[i][j] = f[i][j - 1] + 1;\n            for (let l = pre[j]; l >= i; l = pre[l]) {\n                f[i][j] = Math.min(f[i][j], f[i][l] + f[l + 1][j]);\n            }\n        }\n    }\n    \n    return f[1][n];\n}",
    "instruction": {
      "en": "Write a TypeScript function `function minOperations(n: number, pixels: number[]): number` to solve the following problem:\nGiven a 1 by n pixel image, each pixel has a color represented by an integer. You can change all\nconnected pixels of the same color to a chosen color, where two pixels are connected if they are\nadjacent and have the same color. The goal is to find the minimum number of operations required\nto make all pixels the same color.\nNote: For each color, there are at most 20 pixels of that color.\n\nExamples:\n   minOperations(5, [1, 2, 3, 2, 1]) returns 2\n",
      "sq": "Shkruani një funksion TypeScript `function minOperations(n: number, pixels: number[]): number` për të zgjidhur problemin e mëposhtëm:\nDuke pasur një imazh 1 me n pikselë, secili piksel ka një ngjyrë të përfaqësuar nga një numër i plotë. Ju mund të ndryshoni të gjithë pikselët e lidhur të së njëjtës ngjyrë në një ngjyrë të zgjedhur, ku dy pikselë janë të lidhur nëse janë ngjitur dhe kanë të njëjtën ngjyrë. Qëllimi është të gjeni numrin minimal të operacioneve të nevojshme për të bërë që të gjithë pikselët të kenë të njëjtën ngjyrë.\nShënim: Për çdo ngjyrë, ka maksimumi 20 pikselë të asaj ngjyre.\n\nShembuj:\n   minOperations(5, [1, 2, 3, 2, 1]) kthen 2",
      "hy": "Գրեք TypeScript ֆունկցիա `function minOperations(n: number, pixels: number[]): number` հետևյալ խնդիրը լուծելու համար:\nՏրված է 1 x n պիքսել պատկեր, որտեղ յուրաքանչյուր պիքսել ունի գույն, որը ներկայացված է ամբողջ թվով: Դուք կարող եք փոխել բոլոր\nմիացված նույն գույնի պիքսելները ընտրված գույնի, որտեղ երկու պիքսելները միացված են, եթե նրանք\nհարակից են և ունեն նույն գույնը: Նպատակն է գտնել նվազագույն գործողությունների քանակը, որը պահանջվում է\nբոլոր պիքսելները նույն գույնի դարձնելու համար:\nՆշում: Յուրաքանչյուր գույնի համար առավելագույնը կա 20 պիքսել:\n\nՕրինակներ:\n   minOperations(5, [1, 2, 3, 2, 1]) վերադարձնում է 2",
      "bn": "TypeScript ফাংশন `function minOperations(n: number, pixels: number[]): number` লিখুন নিম্নলিখিত সমস্যার সমাধানের জন্য:\nধরা যাক একটি 1 বাই n পিক্সেল ইমেজ, প্রতিটি পিক্সেলের একটি রঙ আছে যা একটি পূর্ণসংখ্যা দ্বারা প্রতিনিধিত্ব করা হয়। আপনি একই রঙের সংযুক্ত সমস্ত পিক্সেল একটি নির্বাচিত রঙে পরিবর্তন করতে পারেন, যেখানে দুটি পিক্সেল সংযুক্ত যদি তারা সংলগ্ন হয় এবং একই রঙের হয়। লক্ষ্য হল সমস্ত পিক্সেল একই রঙে করতে প্রয়োজনীয় সর্বনিম্ন সংখ্যক অপারেশন খুঁজে বের করা।\nবিঃদ্রঃ: প্রতিটি রঙের জন্য, সেই রঙের সর্বাধিক 20টি পিক্সেল থাকতে পারে।\n\nউদাহরণ:\n   minOperations(5, [1, 2, 3, 2, 1]) 2 রিটার্ন করে",
      "bg": "Напишете функция на TypeScript `function minOperations(n: number, pixels: number[]): number`, за да решите следния проблем:  \nДадено е изображение с размер 1 на n пиксела, като всеки пиксел има цвят, представен от цяло число. Можете да промените всички свързани пиксели със същия цвят на избран цвят, където два пиксела са свързани, ако са съседни и имат същия цвят. Целта е да се намери минималният брой операции, необходими, за да се направят всички пиксели с един и същи цвят.  \nЗабележка: За всеки цвят има най-много 20 пиксела от този цвят.\n\nПримери:  \n   minOperations(5, [1, 2, 3, 2, 1]) връща 2",
      "zh": "编写一个 TypeScript 函数 `function minOperations(n: number, pixels: number[]): number` 来解决以下问题：\n给定一个 1 x n 的像素图像，每个像素都有一个由整数表示的颜色。你可以将所有相同颜色的相连像素更改为一个选择的颜色，其中如果两个像素相邻且颜色相同，则它们是相连的。目标是找到使所有像素颜色相同所需的最小操作次数。\n注意：对于每种颜色，最多有 20 个该颜色的像素。\n\n示例：\n   minOperations(5, [1, 2, 3, 2, 1]) 返回 2",
      "fr": "Écrire une fonction TypeScript `function minOperations(n: number, pixels: number[]): number` pour résoudre le problème suivant :  \nÉtant donné une image de 1 par n pixels, chaque pixel a une couleur représentée par un entier. Vous pouvez changer tous les pixels connectés de la même couleur en une couleur choisie, où deux pixels sont connectés s'ils sont adjacents et ont la même couleur. L'objectif est de trouver le nombre minimum d'opérations nécessaires pour que tous les pixels soient de la même couleur.  \nRemarque : Pour chaque couleur, il y a au plus 20 pixels de cette couleur.\n\nExemples :  \n   minOperations(5, [1, 2, 3, 2, 1]) retourne 2",
      "de": "Schreiben Sie eine TypeScript-Funktion `function minOperations(n: number, pixels: number[]): number`, um das folgende Problem zu lösen:\nGegeben ist ein 1x n Pixel-Bild, wobei jedes Pixel eine Farbe hat, die durch eine ganze Zahl dargestellt wird. Sie können alle verbundenen Pixel der gleichen Farbe in eine gewählte Farbe ändern, wobei zwei Pixel verbunden sind, wenn sie benachbart sind und die gleiche Farbe haben. Das Ziel ist es, die minimale Anzahl von Operationen zu finden, die erforderlich sind, um alle Pixel in die gleiche Farbe zu bringen.\nHinweis: Für jede Farbe gibt es höchstens 20 Pixel dieser Farbe.\n\nBeispiele:\n   minOperations(5, [1, 2, 3, 2, 1]) gibt 2 zurück",
      "ha": "Rubuta aikin TypeScript `function minOperations(n: number, pixels: number[]): number` don warware matsalar mai zuwa:\nAn ba da hoton pixel 1 ta n, kowanne pixel yana da launi da aka wakilta da lamba. Za ka iya canza duk\npixels masu haɗi na launi ɗaya zuwa wani launi da aka zaɓa, inda pixels biyu suna haɗuwa idan suna\nmakwabtaka kuma suna da launi ɗaya. Manufar ita ce nemo mafi ƙarancin adadin ayyuka da ake buƙata\ndon sanya duk pixels su zama launi ɗaya.\nLura: Ga kowanne launi, akwai akalla pixels 20 na wannan launi.\n\nMisalai:\n   minOperations(5, [1, 2, 3, 2, 1]) returns 2",
      "hi": "TypeScript फ़ंक्शन `function minOperations(n: number, pixels: number[]): number` लिखें ताकि निम्नलिखित समस्या का समाधान किया जा सके:\nदिया गया है एक 1 बाई n पिक्सेल छवि, प्रत्येक पिक्सेल का एक रंग होता है जो एक पूर्णांक द्वारा दर्शाया जाता है। आप सभी जुड़े हुए पिक्सेल को एक चुने हुए रंग में बदल सकते हैं, जहाँ दो पिक्सेल जुड़े हुए होते हैं यदि वे आसन्न होते हैं और उनका रंग समान होता है। लक्ष्य यह है कि सभी पिक्सेल को एक ही रंग में बनाने के लिए आवश्यक न्यूनतम ऑपरेशनों की संख्या का पता लगाना है।\nनोट: प्रत्येक रंग के लिए, उस रंग के अधिकतम 20 पिक्सेल होते हैं।\n\nउदाहरण:\n   minOperations(5, [1, 2, 3, 2, 1]) 2 लौटाता है",
      "hu": "Írj egy TypeScript függvényt `function minOperations(n: number, pixels: number[]): number` a következő probléma megoldására:\nAdott egy 1 x n pixel kép, ahol minden pixel színe egy egész számmal van ábrázolva. Megváltoztathatod az összes összekapcsolt, azonos színű pixelt egy választott színre, ahol két pixel akkor van összekapcsolva, ha szomszédosak és azonos színűek. A cél az, hogy megtaláljuk a minimális műveletek számát, amely szükséges ahhoz, hogy az összes pixel azonos színű legyen.\nMegjegyzés: Minden színhez legfeljebb 20 pixel tartozik.\n\nPéldák:\n   minOperations(5, [1, 2, 3, 2, 1]) visszaadja 2"
    },
    "instruction_bertscore": {
      "sq": "0.9856408111246069",
      "hy": "0.9835140756348664",
      "bn": "0.9655259096979658",
      "bg": "0.9754008190911153",
      "zh": "0.9715831431676247",
      "fr": "0.9920835861638545",
      "de": "0.983648548402827",
      "ha": "0.9749985925695197",
      "hi": "0.9622890290086213",
      "hu": "0.9606251023066921"
    },
    "level": "hard",
    "test": "(() => {\n    console.assert(minOperations(5, [1, 2, 3, 2, 1]) === 2);\n    console.assert(minOperations(4, [1, 1, 2, 2]) === 1);\n    console.assert(minOperations(5, [1, 2, 1, 4, 2]) === 3);\n    console.assert(minOperations(5, [5, 5, 5, 5, 5]) === 0);\n    console.assert(minOperations(6, [1, 1, 1, 2, 2, 2]) === 1);\n    console.assert(minOperations(7, [1, 3, 3, 3, 2, 2, 2]) === 2);\n    console.assert(minOperations(8, [4, 4, 4, 4, 3, 3, 3, 3]) === 1);\n    console.assert(minOperations(9, [1, 2, 3, 4, 5, 6, 7, 8, 9]) === 8);\n    console.assert(minOperations(10, [1, 2, 1, 2, 1, 2, 1, 2, 1, 2]) === 5);\n    console.assert(minOperations(3, [3, 3, 3]) === 0);\n    console.assert(minOperations(4, [2, 1, 1, 2]) === 1);\n})();",
    "entry_point": "minOperations",
    "signature": "function minOperations(n: number, pixels: number[]): number",
    "docstring": {
      "en": "Given a 1 by n pixel image, each pixel has a color represented by an integer. You can change all\nconnected pixels of the same color to a chosen color, where two pixels are connected if they are\nadjacent and have the same color. The goal is to find the minimum number of operations required\nto make all pixels the same color.\nNote: For each color, there are at most 20 pixels of that color.\n\nExamples:\n   minOperations(5, [1, 2, 3, 2, 1]) returns 2\n",
      "sq": "Duke pasur një imazh 1 me n piksel, secili piksel ka një ngjyrë të përfaqësuar nga një numër i plotë. Ju mund të ndryshoni të gjithë piksela të lidhur të së njëjtës ngjyrë në një ngjyrë të zgjedhur, ku dy piksela janë të lidhur nëse janë ngjitur dhe kanë të njëjtën ngjyrë. Qëllimi është të gjendet numri minimal i operacioneve të kërkuara për të bërë të gjithë piksela të kenë të njëjtën ngjyrë.\nShënim: Për çdo ngjyrë, ka më së shumti 20 piksela të asaj ngjyre.\n\nShembuj:\n   minOperations(5, [1, 2, 3, 2, 1]) kthen 2",
      "hy": "Տրված է 1 x n պիքսել պատկեր, որտեղ յուրաքանչյուր պիքսել ունի գույն, որը ներկայացված է ամբողջ թվով: Դուք կարող եք փոխել նույն գույնի բոլոր միացված պիքսելները ընտրված գույնի, որտեղ երկու պիքսելներ միացված են, եթե նրանք հարակից են և ունեն նույն գույնը: Նպատակն է գտնել նվազագույն գործողությունների քանակը, որը պահանջվում է բոլոր պիքսելները նույն գույնի դարձնելու համար:\nՆշում: Յուրաքանչյուր գույնի համար առավելագույնը 20 պիքսել կա այդ գույնի:\n\nՕրինակներ:\n   minOperations(5, [1, 2, 3, 2, 1]) վերադարձնում է 2",
      "bn": "একটি 1 বাই n পিক্সেল চিত্র দেওয়া হয়েছে, যেখানে প্রতিটি পিক্সেল একটি পূর্ণসংখ্যা দ্বারা প্রতিনিধিত্ব করে একটি রঙ ধারণ করে। আপনি একই রঙের সংযুক্ত পিক্সেলগুলিকে একটি নির্বাচিত রঙে পরিবর্তন করতে পারেন, যেখানে দুটি পিক্সেল সংযুক্ত থাকে যদি তারা সংলগ্ন হয় এবং একই রঙের হয়। লক্ষ্য হল সমস্ত পিক্সেলকে একই রঙে পরিণত করতে প্রয়োজনীয় সর্বনিম্ন সংখ্যক অপারেশন খুঁজে বের করা।\n\nউদাহরণ:\n   minOperations(5, [1, 2, 3, 2, 1]) 2 প্রদান করে",
      "bg": "Дадено е изображение с размер 1 на n пиксела, като всеки пиксел има цвят, представен с цяло число. Можете да промените всички свързани пиксели със същия цвят на избран цвят, където два пиксела са свързани, ако са съседни и имат същия цвят. Целта е да се намери минималният брой операции, необходими за да се направят всички пиксели с един и същ цвят.\nЗабележка: За всеки цвят има най-много 20 пиксела с този цвят.\n\nПримери:\n   minOperations(5, [1, 2, 3, 2, 1]) връща 2",
      "zh": "给定一个 1 x n 像素的图像，每个像素的颜色由一个整数表示。您可以将所有连接的同色像素更改为选定的颜色，其中两个像素如果相邻且颜色相同，则视为连接。目标是找到使所有像素颜色相同所需的最小操作次数。\n注意：对于每种颜色，最多有 20 个该颜色的像素。\n\n示例：\n   minOperations(5, [1, 2, 3, 2, 1]) 返回 2",
      "fr": "Étant donné une image de 1 par n pixels, chaque pixel a une couleur représentée par un entier. Vous pouvez changer tous les pixels connectés de la même couleur en une couleur choisie, où deux pixels sont connectés s'ils sont adjacents et ont la même couleur. L'objectif est de trouver le nombre minimum d'opérations nécessaires pour que tous les pixels soient de la même couleur.\nRemarque : Pour chaque couleur, il y a au plus 20 pixels de cette couleur.\n\nExemples :\n   minOperations(5, [1, 2, 3, 2, 1]) retourne 2",
      "de": "Given a 1 by n Pixelbild, hat jeder Pixel eine durch eine ganze Zahl dargestellte Farbe. Sie können alle verbundenen Pixel derselben Farbe in eine gewählte Farbe ändern, wobei zwei Pixel verbunden sind, wenn sie benachbart sind und dieselbe Farbe haben. Das Ziel ist es, die minimale Anzahl von Operationen zu finden, die erforderlich sind, um alle Pixel in dieselbe Farbe zu ändern.\nHinweis: Für jede Farbe gibt es höchstens 20 Pixel dieser Farbe.\n\nBeispiele:\n   minOperations(5, [1, 2, 3, 2, 1]) gibt 2 zurück",
      "ha": "An ba da hoton pixel 1 ta n, kowane pixel yana da launi da aka wakilta da lamba. Za ka iya canza duk pixels masu alaƙa na launi ɗaya zuwa launi da aka zaɓa, inda pixels biyu suke da alaƙa idan suna kusa kuma suna da launi ɗaya. Manufar ita ce samun mafi ƙarancin adadin ayyuka da ake buƙata don sanya duk pixels su zama launi ɗaya.\nLura: Don kowane launi, akwai a kalla pixels 20 na wannan launi.\n\nMisalai:\n   minOperations(5, [1, 2, 3, 2, 1]) returns 2",
      "hi": "1 by n पिक्सेल छवि दी गई है, प्रत्येक पिक्सेल का रंग एक पूर्णांक द्वारा दर्शाया गया है। आप एक चुने हुए रंग में समान रंग के सभी जुड़े पिक्सेल को बदल सकते हैं, जहाँ दो पिक्सेल जुड़े होते हैं यदि वे आसन्न हैं और उनका रंग समान है। लक्ष्य यह है कि सभी पिक्सेल को एक ही रंग में बनाने के लिए आवश्यक न्यूनतम ऑपरेशनों की संख्या का पता लगाना है।\nनोट: प्रत्येक रंग के लिए, उस रंग के अधिकतम 20 पिक्सेल होते हैं।\n\nउदाहरण:\n   minOperations(5, [1, 2, 3, 2, 1]) 2 लौटाता है",
      "hu": "Egy 1 x n pixeles képet kapunk, ahol minden pixel színe egy egész számmal van ábrázolva. Megváltoztathatja az összes összekapcsolt, azonos színű pixelt egy választott színre, ahol két pixel akkor van összekapcsolva, ha szomszédosak és azonos színűek. A cél az, hogy megtaláljuk a minimális számú műveletet, amely szükséges ahhoz, hogy az összes pixel azonos színű legyen.\nMegjegyzés: Minden szín esetében legfeljebb 20 pixel lehet az adott színből.\n\nPéldák:\n   minOperations(5, [1, 2, 3, 2, 1]) visszaadja 2"
    },
    "docstring_bertscore": {
      "sq": "0.9802080715729217",
      "hy": "0.9724718154923748",
      "bn": "0.9208287109448281",
      "bg": "0.9712480537148189",
      "zh": "0.9609713150608359",
      "fr": "0.9918352981875609",
      "de": "0.9920035381202975",
      "ha": "0.9867048740758108",
      "hi": "0.9473395106407925",
      "hu": "0.9709993684777632"
    }
  },
  {
    "task_id": "TypeScript/46",
    "prompt": {
      "en": "\n/**\n * Given an integer n, write a function to compute the sum of all numbers from 1 to n\n * that are multiples of either 3 or 5. If a number is a multiple of both 3 and 5,\n * it should only be counted once.\n * \n * For example:\n *     sumOfMultiples(10); // returns 33 (3 + 5 + 6 + 9 + 10)\n */\nfunction sumOfMultiples(n: number): number {",
      "sq": "/**\n * Duke pasur një numër të plotë n, shkruani një funksion për të llogaritur shumën e të gjithë numrave nga 1 deri në n\n * që janë shumëfish i 3 ose 5. Nëse një numër është shumëfish i të dyjave 3 dhe 5,\n * ai duhet të numërohet vetëm një herë.\n * \n * Për shembull:\n *     sumOfMultiples(10); // kthen 33 (3 + 5 + 6 + 9 + 10)\n */\nfunction sumOfMultiples(n: number): number {",
      "hy": "/**\n * Տրված է ամբողջ թիվ n, գրեք ֆունկցիա՝ հաշվելու համար 1-ից n բոլոր թվերի գումարը,\n * որոնք բազմապատիկ են 3-ի կամ 5-ի։ Եթե թիվը բազմապատիկ է և՛ 3-ի, և՛ 5-ի,\n * այն պետք է հաշվել միայն մեկ անգամ։\n * \n * Օրինակ:\n *     sumOfMultiples(10); // վերադարձնում է 33 (3 + 5 + 6 + 9 + 10)\n */\nfunction sumOfMultiples(n: number): number {",
      "bn": "/**\n * একটি পূর্ণসংখ্যা n দেওয়া হলে, 1 থেকে n পর্যন্ত সমস্ত সংখ্যার যোগফল গণনা করার জন্য একটি ফাংশন লিখুন\n * যা 3 বা 5 এর গুণিতক। যদি কোনো সংখ্যা 3 এবং 5 উভয়ের গুণিতক হয়,\n * তবে এটি শুধুমাত্র একবার গণনা করা উচিত।\n * \n * উদাহরণস্বরূপ:\n *     sumOfMultiples(10); // 33 ফেরত দেয় (3 + 5 + 6 + 9 + 10)\n */\nfunction sumOfMultiples(n: number): number {",
      "bg": "/**\n * Дадено е цяло число n, напишете функция за изчисляване на сумата на всички числа от 1 до n,\n * които са кратни на 3 или 5. Ако едно число е кратно и на 3, и на 5,\n * то трябва да бъде преброено само веднъж.\n * \n * Например:\n *     sumOfMultiples(10); // връща 33 (3 + 5 + 6 + 9 + 10)\n */\nfunction sumOfMultiples(n: number): number {",
      "zh": "/**\n * 给定一个整数 n，编写一个函数来计算从 1 到 n 之间所有是 3 或 5 的倍数的数字之和。\n * 如果一个数字同时是 3 和 5 的倍数，则它只应被计算一次。\n * \n * 例如:\n *     sumOfMultiples(10); // 返回 33 (3 + 5 + 6 + 9 + 10)\n */\nfunction sumOfMultiples(n: number): number {",
      "fr": "/**\n * Étant donné un entier n, écrivez une fonction pour calculer la somme de tous les nombres de 1 à n\n * qui sont des multiples de 3 ou 5. Si un nombre est un multiple à la fois de 3 et de 5,\n * il ne doit être compté qu'une seule fois.\n * \n * Par exemple :\n *     sumOfMultiples(10); // retourne 33 (3 + 5 + 6 + 9 + 10)\n */\nfunction sumOfMultiples(n: number): number {",
      "de": "/**\n * Gegeben eine ganze Zahl n, schreiben Sie eine Funktion, um die Summe aller Zahlen von 1 bis n zu berechnen,\n * die Vielfache von entweder 3 oder 5 sind. Wenn eine Zahl ein Vielfaches von sowohl 3 als auch 5 ist,\n * sollte sie nur einmal gezählt werden.\n * \n * Zum Beispiel:\n *     sumOfMultiples(10); // gibt 33 zurück (3 + 5 + 6 + 9 + 10)\n */\nfunction sumOfMultiples(n: number): number {",
      "ha": "/**\n * Idan aka ba da cikakken lamba n, rubuta wani aiki don lissafin jimillar duk lambobi daga 1 zuwa n\n * waɗanda suke masu yawa na ko dai 3 ko 5. Idan lamba tana da yawa na duka 3 da 5,\n * ya kamata a ƙidaya shi sau ɗaya kawai.\n * \n * Alal misali:\n *     sumOfMultiples(10); // ya dawo da 33 (3 + 5 + 6 + 9 + 10)\n */\nfunction sumOfMultiples(n: number): number {",
      "hi": "/**\n * दिए गए पूर्णांक n के लिए, एक फ़ंक्शन लिखें जो 1 से n तक के उन सभी संख्याओं का योग गणना करे\n * जो या तो 3 या 5 के गुणज हैं। यदि कोई संख्या 3 और 5 दोनों की गुणज है,\n * तो उसे केवल एक बार गिना जाना चाहिए।\n * \n * उदाहरण के लिए:\n *     sumOfMultiples(10); // 33 लौटाता है (3 + 5 + 6 + 9 + 10)\n */\nfunction sumOfMultiples(n: number): number {",
      "hu": "/**\n * Adott egy egész szám n, írj egy függvényt, amely kiszámítja az 1-től n-ig terjedő összes szám összegét,\n * amelyek 3 vagy 5 többszörösei. Ha egy szám mind a 3, mind az 5 többszöröse,\n * akkor azt csak egyszer kell számolni.\n * \n * Például:\n *     sumOfMultiples(10); // visszaadja a 33-at (3 + 5 + 6 + 9 + 10)\n */\nfunction sumOfMultiples(n: number): number {"
    },
    "prompt_bertscore": {
      "sq": "0.9916982432246468",
      "hy": "0.9861393733810044",
      "bn": "0.9663112942245778",
      "bg": "0.9874419914198312",
      "zh": "0.9796185366020101",
      "fr": "0.9924750866448743",
      "de": "0.9970026675501835",
      "ha": "0.9962139063070939",
      "hi": "0.9866542233286469",
      "hu": "0.9859385580657782"
    },
    "canonical_solution": "let sum = 0;\n    for (let i = 1; i <= n; ++i) {\n        if (i % 3 === 0 || i % 5 === 0) {\n            sum += i;\n        }\n    }\n    return sum;\n}",
    "instruction": {
      "en": "Write a TypeScript function `function sumOfMultiples(n: number): number` to solve the following problem:\nGiven an integer n, write a function to compute the sum of all numbers from 1 to n that are multiples of either 3 or 5. If a number is a multiple of both 3 and 5, it should only be counted once.\n\nFor example:\n    sumOfMultiples(10); // returns 33 (3 + 5 + 6 + 9 + 10)",
      "sq": "Shkruani një funksion TypeScript `function sumOfMultiples(n: number): number` për të zgjidhur problemin e mëposhtëm:\nDuke pasur një numër të plotë n, shkruani një funksion për të llogaritur shumën e të gjithë numrave nga 1 deri në n që janë shumëfish i 3 ose 5. Nëse një numër është shumëfish i të dyve, 3 dhe 5, ai duhet të numërohet vetëm një herë.\n\nPër shembull:\n    sumOfMultiples(10); // kthen 33 (3 + 5 + 6 + 9 + 10)",
      "hy": "Գրեք TypeScript ֆունկցիա `function sumOfMultiples(n: number): number` հետևյալ խնդիրը լուծելու համար:\nՏրված է ամբողջ թիվ n, գրեք ֆունկցիա՝ հաշվելու համար 1-ից n բոլոր այն թվերի գումարը, որոնք բազմապատիկ են 3-ի կամ 5-ի: Եթե թիվը բազմապատիկ է և՛ 3-ի, և՛ 5-ի, այն պետք է հաշվել միայն մեկ անգամ:\n\nՕրինակ:\n    sumOfMultiples(10); // վերադարձնում է 33 (3 + 5 + 6 + 9 + 10)",
      "bn": "একটি TypeScript ফাংশন `function sumOfMultiples(n: number): number` লিখুন নিম্নলিখিত সমস্যার সমাধানের জন্য:\nএকটি পূর্ণসংখ্যা n দেওয়া হলে, 1 থেকে n পর্যন্ত সমস্ত সংখ্যার যোগফল গণনা করার জন্য একটি ফাংশন লিখুন যা 3 বা 5 এর গুণিতক। যদি কোনো সংখ্যা 3 এবং 5 উভয়ের গুণিতক হয়, তবে এটি শুধুমাত্র একবার গণনা করা উচিত।\n\nউদাহরণস্বরূপ:\n    sumOfMultiples(10); // 33 ফেরত দেয় (3 + 5 + 6 + 9 + 10)",
      "bg": "Напишете TypeScript функция `function sumOfMultiples(n: number): number`, за да решите следния проблем:\nДадено е цяло число n, напишете функция, която да изчисли сумата на всички числа от 1 до n, които са кратни на 3 или 5. Ако едно число е кратно и на 3, и на 5, то трябва да бъде преброено само веднъж.\n\nНапример:\n    sumOfMultiples(10); // връща 33 (3 + 5 + 6 + 9 + 10)",
      "zh": "编写一个 TypeScript 函数 `function sumOfMultiples(n: number): number` 来解决以下问题：\n给定一个整数 n，编写一个函数来计算从 1 到 n 之间所有是 3 或 5 的倍数的数字之和。如果一个数字同时是 3 和 5 的倍数，则只应计算一次。\n\n例如：\n    sumOfMultiples(10); // 返回 33 (3 + 5 + 6 + 9 + 10)",
      "fr": "Écrivez une fonction TypeScript `function sumOfMultiples(n: number): number` pour résoudre le problème suivant :  \nÉtant donné un entier n, écrivez une fonction pour calculer la somme de tous les nombres de 1 à n qui sont des multiples de 3 ou 5. Si un nombre est un multiple à la fois de 3 et de 5, il ne doit être compté qu'une seule fois.\n\nPar exemple :  \n    sumOfMultiples(10); // renvoie 33 (3 + 5 + 6 + 9 + 10)",
      "de": "Schreiben Sie eine TypeScript-Funktion `function sumOfMultiples(n: number): number`, um das folgende Problem zu lösen:\nGegeben eine ganze Zahl n, schreiben Sie eine Funktion, um die Summe aller Zahlen von 1 bis n zu berechnen, die Vielfache von entweder 3 oder 5 sind. Wenn eine Zahl ein Vielfaches von sowohl 3 als auch 5 ist, sollte sie nur einmal gezählt werden.\n\nZum Beispiel:\n    sumOfMultiples(10); // gibt 33 zurück (3 + 5 + 6 + 9 + 10)",
      "ha": "Rubuta aikin TypeScript `function sumOfMultiples(n: number): number` don warware matsalar mai zuwa:\nAn ba da cikakken lamba n, rubuta wani aiki don lissafin jimillar duk lambobin daga 1 zuwa n waɗanda suke masu yawa na ko dai 3 ko 5. Idan lamba tana da yawa na duka 3 da 5, ya kamata a ƙidaya sau ɗaya kawai.\n\nMisali:\n    sumOfMultiples(10); // yana dawowa 33 (3 + 5 + 6 + 9 + 10)",
      "hi": "TypeScript फ़ंक्शन `function sumOfMultiples(n: number): number` लिखें ताकि निम्नलिखित समस्या का समाधान किया जा सके:\nदिए गए पूर्णांक n के लिए, एक फ़ंक्शन लिखें जो 1 से n तक के उन सभी संख्याओं का योग गणना करे जो 3 या 5 के गुणज हैं। यदि कोई संख्या 3 और 5 दोनों का गुणज है, तो उसे केवल एक बार गिना जाना चाहिए।\n\nउदाहरण के लिए:\n    sumOfMultiples(10); // returns 33 (3 + 5 + 6 + 9 + 10)",
      "hu": "Írj egy TypeScript függvényt `function sumOfMultiples(n: number): number` a következő probléma megoldására:\nAdott egy egész szám n, írj egy függvényt, amely kiszámítja az összes 1-től n-ig terjedő szám összegét, amelyek 3 vagy 5 többszörösei. Ha egy szám mind a 3, mind az 5 többszöröse, akkor csak egyszer kell számolni.\n\nPéldául:\n    sumOfMultiples(10); // visszaadja a 33-at (3 + 5 + 6 + 9 + 10)"
    },
    "instruction_bertscore": {
      "sq": "0.9911275781399336",
      "hy": "0.9871084910100737",
      "bn": "0.9911275781399336",
      "bg": "0.9896116310718753",
      "zh": "0.9879057933595478",
      "fr": "0.9918217913216506",
      "de": "0.995832535975507",
      "ha": "0.9867638672989781",
      "hi": "0.9699196137264575",
      "hu": "0.9903167689245492"
    },
    "level": "easy",
    "test": "const testSumOfMultiples = (): void => {\n    console.assert(sumOfMultiples(10) === 33, 'Test case n=10 failed');\n    console.assert(sumOfMultiples(15) === 60, 'Test case n=15 failed');\n    console.assert(sumOfMultiples(20) === 98, 'Test case n=20 failed');\n    console.assert(sumOfMultiples(5) === 8, 'Test case n=5 failed');\n    console.assert(sumOfMultiples(3) === 3, 'Test case n=3 failed');\n    console.assert(sumOfMultiples(6) === 14, 'Test case n=6 failed');\n    console.assert(sumOfMultiples(9) === 23, 'Test case n=9 failed');\n    console.assert(sumOfMultiples(12) === 45, 'Test case n=12 failed');\n    console.assert(sumOfMultiples(17) === 60, 'Test case n=17 failed');\n    console.assert(sumOfMultiples(21) === 119, 'Test case n=21 failed');\n    console.assert(sumOfMultiples(25) === 168, 'Test case n=25 failed');\n};\n\ntestSumOfMultiples();",
    "entry_point": "sumOfMultiples",
    "signature": "function sumOfMultiples(n: number): number",
    "docstring": {
      "en": "Given an integer n, write a function to compute the sum of all numbers from 1 to n that are multiples of either 3 or 5. If a number is a multiple of both 3 and 5, it should only be counted once.\n\nFor example:\n    sumOfMultiples(10); // returns 33 (3 + 5 + 6 + 9 + 10)",
      "sq": "Duke pasur një numër të plotë n, shkruani një funksion për të llogaritur shumën e të gjithë numrave nga 1 deri në n që janë shumëfish i 3 ose 5. Nëse një numër është shumëfish i të dyjave, 3 dhe 5, ai duhet të numërohet vetëm një herë.\n\nPër shembull:\n    sumOfMultiples(10); // kthen 33 (3 + 5 + 6 + 9 + 10)",
      "hy": "Տրված ամբողջ թիվ n-ի դեպքում, գրեք ֆունկցիա՝ հաշվելու համար 1-ից n բոլոր այն թվերի գումարը, որոնք բազմապատիկ են 3-ի կամ 5-ի։ Եթե թիվը բազմապատիկ է և՛ 3-ի, և՛ 5-ի, այն պետք է հաշվել միայն մեկ անգամ։\n\nՕրինակ:\n    sumOfMultiples(10); // վերադարձնում է 33 (3 + 5 + 6 + 9 + 10)",
      "bn": "একটি পূর্ণসংখ্যা n দেওয়া হলে, এমন একটি ফাংশন লিখুন যা 1 থেকে n পর্যন্ত সমস্ত সংখ্যার যোগফল গণনা করে যা হয় 3 অথবা 5 এর গুণিতক। যদি কোনো সংখ্যা 3 এবং 5 উভয়েরই গুণিতক হয়, তবে এটি শুধুমাত্র একবার গণনা করা উচিত।\n\nউদাহরণস্বরূপ:\n    sumOfMultiples(10); // 33 ফেরত দেয় (3 + 5 + 6 + 9 + 10)",
      "bg": "Дадено е цяло число n, напишете функция за изчисляване на сумата на всички числа от 1 до n, които са кратни на 3 или 5. Ако едно число е кратно и на 3, и на 5, то трябва да бъде преброено само веднъж.\n\nНапример:\n    sumOfMultiples(10); // връща 33 (3 + 5 + 6 + 9 + 10)",
      "zh": "给定一个整数 n，编写一个函数来计算从 1 到 n 之间所有是 3 或 5 的倍数的数字之和。如果一个数字同时是 3 和 5 的倍数，则它只应被计算一次。\n\n例如：\n    sumOfMultiples(10); // 返回 33 (3 + 5 + 6 + 9 + 10)",
      "fr": "Étant donné un entier n, écrivez une fonction pour calculer la somme de tous les nombres de 1 à n qui sont des multiples de 3 ou 5. Si un nombre est un multiple à la fois de 3 et de 5, il ne doit être compté qu'une seule fois.\n\nPar exemple :\n    sumOfMultiples(10); // retourne 33 (3 + 5 + 6 + 9 + 10)",
      "de": "Given an integer n, write a function to compute the sum of all numbers from 1 to n that are multiples of either 3 or 5. If a number is a multiple of both 3 and 5, it should only be counted once.\n\nAuf Deutsch:\nGegeben eine ganze Zahl n, schreiben Sie eine Funktion, um die Summe aller Zahlen von 1 bis n zu berechnen, die Vielfache von entweder 3 oder 5 sind. Wenn eine Zahl ein Vielfaches von sowohl 3 als auch 5 ist, sollte sie nur einmal gezählt werden.\n\nFor example:\nZum Beispiel:\n    sumOfMultiples(10); // returns 33 (3 + 5 + 6 + 9 + 10)",
      "ha": "An ba da wani lamba n, rubuta wata hanya don lissafa jimillar duk lambobi daga 1 zuwa n waɗanda suke masu yawa na ko dai 3 ko 5. Idan lamba tana mai yawa na duka 3 da 5, ya kamata a ƙidaya shi sau ɗaya kawai.\n\nMisali:\n    sumOfMultiples(10); // ya dawo da 33 (3 + 5 + 6 + 9 + 10)",
      "hi": "Given an integer n, एक फ़ंक्शन लिखें जो 1 से n तक सभी संख्याओं का योग गणना करे जो या तो 3 या 5 के गुणज हैं। यदि कोई संख्या 3 और 5 दोनों की गुणज है, तो उसे केवल एक बार गिना जाना चाहिए।\n\nउदाहरण के लिए:\n    sumOfMultiples(10); // 33 लौटाता है (3 + 5 + 6 + 9 + 10)",
      "hu": "Adott egy egész szám n, írj egy függvényt, amely kiszámítja az összes olyan szám összegét 1-től n-ig, amelyek 3 vagy 5 többszörösei. Ha egy szám mind a 3, mind az 5 többszöröse, akkor azt csak egyszer kell számolni.\n\nPéldául:\n    sumOfMultiples(10); // visszatér 33 (3 + 5 + 6 + 9 + 10)"
    },
    "docstring_bertscore": {
      "sq": "0.9834084042721558",
      "hy": "0.9852149475876681",
      "bn": "0.9928052103381543",
      "bg": "0.9887452053498011",
      "zh": "0.9857192701251157",
      "fr": "0.9898460149214965",
      "de": "0.9031476275770075",
      "ha": "0.9841157270590211",
      "hi": "0.9928052103381543",
      "hu": "0.9887376573953218"
    }
  },
  {
    "task_id": "TypeScript/47",
    "prompt": {
      "en": "\n/**\n * Determine if a given string is a palindrome.\n * A palindrome is a word, phrase, number, or other sequence of characters\n * that reads the same forward and backward (ignoring spaces, punctuation,\n * and capitalization).\n * \n * Examples:\n * isPalindrome(\"racecar\") // returns true\n */\nfunction isPalindrome(str: string): boolean",
      "sq": "/**\n * Përcaktoni nëse një varg i dhënë është një palindrom.\n * Një palindrom është një fjalë, frazë, numër, ose një sekuencë tjetër karakteresh\n * që lexohet njësoj përpara dhe prapa (duke injoruar hapësirat, shenjat e pikësimit,\n * dhe shkronjat e mëdha).\n * \n * Shembuj:\n * isPalindrome(\"racecar\") // kthen true\n */\nfunction isPalindrome(str: string): boolean",
      "hy": "/**\n * Սահմանել, արդյոք տրված տողը պալինդրոմ է:\n * Պալինդրոմը բառ է, արտահայտություն, թիվ կամ այլ նիշերի հաջորդականություն,\n * որը կարդացվում է նույն կերպ առաջ և հետ (անտեսելով բացատները, կետադրությունը\n * և մեծատառերը):\n * \n * Օրինակներ:\n * isPalindrome(\"racecar\") // վերադարձնում է true\n */\nfunction isPalindrome(str: string): boolean",
      "bn": "/**\n * নির্ধারণ করুন একটি প্রদত্ত স্ট্রিং প্যালিনড্রোম কি না।\n * একটি প্যালিনড্রোম হল একটি শব্দ, বাক্যাংশ, সংখ্যা, বা অন্যান্য অক্ষরের ক্রম\n * যা সামনের দিকে এবং পিছনের দিকে একইভাবে পড়ে (স্পেস, বিরামচিহ্ন,\n * এবং বড় হাতের অক্ষর উপেক্ষা করে)।\n * \n * উদাহরণসমূহ:\n * isPalindrome(\"racecar\") // true রিটার্ন করে\n */\nfunction isPalindrome(str: string): boolean",
      "bg": "/**\n * Определете дали даден низ е палиндром.\n * Палиндром е дума, фраза, число или друга последователност от символи,\n * която се чете еднакво напред и назад (като се игнорират интервали, пунктуация\n * и главни букви).\n * \n * Примери:\n * isPalindrome(\"racecar\") // връща true\n */\nfunction isPalindrome(str: string): boolean",
      "zh": "/**\n * 确定给定的字符串是否是回文。\n * 回文是一个单词、短语、数字或其他字符序列，\n * 无论正向还是反向读取都是相同的（忽略空格、标点符号和大小写）。\n * \n * 例子:\n * isPalindrome(\"racecar\") // returns true\n */\nfunction isPalindrome(str: string): boolean",
      "fr": "/**\n * Déterminer si une chaîne donnée est un palindrome.\n * Un palindrome est un mot, une phrase, un nombre ou une autre séquence de caractères\n * qui se lit de la même manière de l'avant vers l'arrière (en ignorant les espaces, la ponctuation,\n * et la capitalisation).\n * \n * Exemples :\n * isPalindrome(\"racecar\") // retourne true\n */\nfunction isPalindrome(str: string): boolean",
      "de": "/**\n * Bestimmen, ob eine gegebene Zeichenkette ein Palindrom ist.\n * Ein Palindrom ist ein Wort, ein Satz, eine Zahl oder eine andere Zeichenfolge,\n * die vorwärts und rückwärts gleich gelesen wird (unter Ignorieren von Leerzeichen, Interpunktion\n * und Groß- und Kleinschreibung).\n * \n * Beispiele:\n * isPalindrome(\"racecar\") // gibt true zurück\n */\nfunction isPalindrome(str: string): boolean",
      "ha": "/**\n * Tantance ko wani kirtani da aka bayar palindrome ne.\n * Palindrome kalma ce, jimla, lamba, ko wata jerin haruffa\n * da ke karantawa iri daya gaba da baya (ba tare da la'akari da sarari, alamomin rubutu,\n * da manyan ba).\n * \n * Misalai:\n * isPalindrome(\"racecar\") // returns true\n */\nfunction isPalindrome(str: string): boolean",
      "hi": "/**\n * निर्धारित करें कि कोई दिया गया स्ट्रिंग पलिंड्रोम है या नहीं।\n * एक पलिंड्रोम एक शब्द, वाक्यांश, संख्या, या अन्य वर्णों का अनुक्रम होता है\n * जो आगे और पीछे से समान रूप से पढ़ा जाता है (स्पेस, विराम चिह्न,\n * और बड़े अक्षरों की अनदेखी करते हुए)।\n * \n * उदाहरण:\n * isPalindrome(\"racecar\") // true लौटाता है\n */\nfunction isPalindrome(str: string): boolean",
      "hu": "/**\n * Határozza meg, hogy egy adott string palindróm-e.\n * Egy palindróm egy szó, kifejezés, szám vagy más karakterekből álló sorozat,\n * amely előre és hátrafelé olvasva is ugyanaz (figyelmen kívül hagyva a szóközöket, írásjeleket\n * és a nagybetűket).\n * \n * Példák:\n * isPalindrome(\"racecar\") // visszaadja: true\n */\nfunction isPalindrome(str: string): boolean"
    },
    "prompt_bertscore": {
      "sq": "1",
      "hy": "0.9968127769059142",
      "bn": "0.9991752866579432",
      "bg": "1",
      "zh": "0.9797859820132225",
      "fr": "1",
      "de": "0.9938343143422961",
      "ha": "1",
      "hi": "0.9768786291260149",
      "hu": "0.9960122964703436"
    },
    "canonical_solution": "{\n  let start: number = 0;\n  let end: number = str.length - 1;\n\n  while (start < end) {\n    // Skip non-alphanumeric characters and handle case insensitivity\n    while (!isalnum(str[start]) && start < end) start++;\n    while (!isalnum(str[end]) && start < end) end--;\n    if (str[start].toLowerCase() !== str[end].toLowerCase())\n      return false;\n    start++;\n    end--;\n  }\n  return true;\n}\n\n// Helper function to check if a character is alphanumeric\nfunction isalnum(char: string): boolean {\n  let code: number = char.charCodeAt(0);\n  return (code > 47 && code < 58) || // numeric (0-9)\n         (code > 64 && code < 91) || // upper alpha (A-Z)\n         (code > 96 && code < 123);  // lower alpha (a-z)\n}",
    "instruction": {
      "en": "Write a TypeScript function `function isPalindrome(str: string): boolean` to solve the following problem:\nDetermine if a given string is a palindrome.\nA palindrome is a word, phrase, number, or other sequence of characters\nthat reads the same forward and backward (ignoring spaces, punctuation,\nand capitalization).\n\nExamples:\nisPalindrome(\"racecar\") // returns true\n",
      "sq": "Shkruani një funksion TypeScript `function isPalindrome(str: string): boolean` për të zgjidhur problemin e mëposhtëm:  \nPërcaktoni nëse një varg i dhënë është një palindrom.  \nNjë palindrom është një fjalë, frazë, numër, ose një sekuencë tjetër karakteresh  \nqë lexohet njësoj përpara dhe prapa (duke injoruar hapësirat, shenjat e pikësimit,  \ndhe kapitalizimin).\n\nShembuj:  \nisPalindrome(\"racecar\") // kthen true",
      "hy": "Գրեք TypeScript ֆունկցիա `function isPalindrome(str: string): boolean` լուծելու համար հետևյալ խնդիրը:  \nՈրոշեք, արդյոք տրված տողը պալինդրոմ է:  \nՊալինդրոմը բառ է, արտահայտություն, թիվ կամ այլ նիշերի հաջորդականություն,  \nորն ընթերցվում է նույն կերպ առաջ և հետ (անտեսելով բացատները, կետադրությունը  \nև մեծատառերը):\n\nՕրինակներ:  \nisPalindrome(\"racecar\") // վերադարձնում է true",
      "bn": "TypeScript ফাংশন `function isPalindrome(str: string): boolean` লিখুন নিম্নলিখিত সমস্যার সমাধানের জন্য:\nনির্ধারণ করুন একটি প্রদত্ত স্ট্রিং প্যালিনড্রোম কিনা।\nএকটি প্যালিনড্রোম হল এমন একটি শব্দ, বাক্যাংশ, সংখ্যা, বা অন্যান্য অক্ষরের ক্রম\nযা সামনের দিকে এবং পিছনের দিকে একইভাবে পড়ে (স্পেস, বিরামচিহ্ন,\nএবং বড় হাতের অক্ষর উপেক্ষা করে)।\n\nউদাহরণ:\nisPalindrome(\"racecar\") // returns true",
      "bg": "Напишете TypeScript функция `function isPalindrome(str: string): boolean`, за да решите следния проблем:\nОпределете дали даден низ е палиндром.\nПалиндром е дума, фраза, число или друга последователност от символи,\nкоято се чете еднакво напред и назад (като се игнорират интервали, пунктуация\nи главни букви).\n\nПримери:\nisPalindrome(\"racecar\") // връща true",
      "zh": "编写一个 TypeScript 函数 `function isPalindrome(str: string): boolean` 来解决以下问题：  \n确定给定的字符串是否是回文。  \n回文是一个词、短语、数字或其他字符序列，正着读和反着读都一样（忽略空格、标点符号和大小写）。  \n\n示例：  \nisPalindrome(\"racecar\") // 返回 true  ",
      "fr": "Écrire une fonction TypeScript `function isPalindrome(str: string): boolean` pour résoudre le problème suivant :  \nDéterminer si une chaîne donnée est un palindrome.  \nUn palindrome est un mot, une phrase, un nombre ou une autre séquence de caractères  \nqui se lit de la même façon de l'avant vers l'arrière et de l'arrière vers l'avant (en ignorant les espaces, la ponctuation  \net la capitalisation).\n\nExemples :  \nisPalindrome(\"racecar\") // renvoie true",
      "de": "Schreiben Sie eine TypeScript-Funktion `function isPalindrome(str: string): boolean`, um das folgende Problem zu lösen:\nBestimmen Sie, ob ein gegebener String ein Palindrom ist.\nEin Palindrom ist ein Wort, ein Satz, eine Zahl oder eine andere Zeichenfolge,\ndie vorwärts und rückwärts gleich gelesen wird (ohne Berücksichtigung von Leerzeichen, Interpunktion\nund Groß- und Kleinschreibung).\n\nBeispiele:\nisPalindrome(\"racecar\") // gibt true zurück",
      "ha": "Rubuta aikin TypeScript `function isPalindrome(str: string): boolean` don warware matsalar mai zuwa:\nGano idan wani kirtani da aka bayar palindrome ne.\nPalindrome kalma ce, jimla, lamba, ko wata jerin haruffa\nwanda yake karantawa iri daya gaba da baya (ba tare da la'akari da sarari, rubutu,\nda manyan ba).\n\nMisalai:\nisPalindrome(\"racecar\") // returns true",
      "hi": "TypeScript फ़ंक्शन `function isPalindrome(str: string): boolean` लिखें ताकि निम्नलिखित समस्या का समाधान किया जा सके:\nयह निर्धारित करें कि दिया गया स्ट्रिंग एक पालिंड्रोम है या नहीं।\nएक पालिंड्रोम एक शब्द, वाक्यांश, संख्या, या अन्य वर्णों का अनुक्रम होता है\nजो आगे और पीछे से समान रूप से पढ़ा जाता है (स्पेस, विराम चिह्न,\nऔर बड़े अक्षरों की अनदेखी करते हुए)।\n\nउदाहरण:\nisPalindrome(\"racecar\") // returns true",
      "hu": "Írj egy TypeScript függvényt `function isPalindrome(str: string): boolean` a következő probléma megoldására:\nHatározd meg, hogy egy adott string palindróm-e.\nEgy palindróm olyan szó, kifejezés, szám vagy más karakterlánc,\namely előre és hátrafelé olvasva is ugyanaz (figyelmen kívül hagyva a szóközöket, írásjeleket és a nagybetűket).\n\nPéldák:\nisPalindrome(\"racecar\") // visszaadja, hogy true"
    },
    "instruction_bertscore": {
      "sq": "1",
      "hy": "0.9967881467386659",
      "bn": "0.9775392737733369",
      "bg": "1",
      "zh": "0.9842241792470661",
      "fr": "1",
      "de": "1",
      "ha": "1",
      "hi": "0.9571371528157194",
      "hu": "1"
    },
    "level": "hard",
    "test": "const testIsPalindrome = (): void => {\n  console.assert(isPalindrome(\"A man a plan a canal Panama\") === true, \"Test 1 failed\");\n  console.assert(isPalindrome(\"No lemon, no melon\") === true, \"Test 2 failed\");\n  console.assert(isPalindrome(\"Was it a car or a cat I saw\") === true, \"Test 3 failed\");\n  console.assert(isPalindrome(\"Madam, in Eden, I'm Adam\") === true, \"Test 4 failed\");\n  console.assert(isPalindrome(\"Never odd or even\") === true, \"Test 5 failed\");\n  console.assert(isPalindrome(\"Eva, can I see bees in a cave\") === true, \"Test 6 failed\");\n  console.assert(isPalindrome(\"hello\") === false, \"Test 7 failed\");\n  console.assert(isPalindrome(\"GitHub\") === false, \"Test 8 failed\");\n  console.assert(isPalindrome(\"programming\") === false, \"Test 9 failed\");\n};\n\ntestIsPalindrome();",
    "entry_point": "isPalindrome",
    "signature": "function isPalindrome(str: string): boolean",
    "docstring": {
      "en": "Determine if a given string is a palindrome.\nA palindrome is a word, phrase, number, or other sequence of characters\nthat reads the same forward and backward (ignoring spaces, punctuation,\nand capitalization).\n\nExamples:\nisPalindrome(\"racecar\") // returns true\n",
      "sq": "Determine nëse një varg i dhënë është një palindrom.  \nNjë palindrom është një fjalë, frazë, numër, ose një sekuencë tjetër karakteresh  \nqë lexohet njësoj përpara dhe prapa (duke injoruar hapësirat, shenjat e pikësimit,  \ndhe kapitalizimin).\n\nShembuj:  \nisPalindrome(\"racecar\") // kthen true",
      "hy": "Պարզել, արդյոք տրված տողը պալինդրոմ է:\nՊալինդրոմը բառ, արտահայտություն, թիվ կամ այլ նշանների հաջորդականություն է,\nորն ընթերցվում է նույն կերպ առաջ և հետ (անտեսելով բացատները, կետադրությունը\nև մեծատառերը):\n\nՕրինակներ:\nisPalindrome(\"racecar\") // վերադարձնում է true",
      "bn": "Determine if a given string is a palindrome.  \nএকটি প্রদত্ত স্ট্রিং প্যালিনড্রোম কিনা তা নির্ধারণ করুন।  \nA palindrome is a word, phrase, number, or other sequence of characters  \nপ্যালিনড্রোম হল এমন একটি শব্দ, বাক্যাংশ, সংখ্যা, বা অন্যান্য অক্ষরের ক্রম  \nthat reads the same forward and backward (ignoring spaces, punctuation,  \nযা সামনের দিকে এবং পিছনের দিকে একইভাবে পড়া যায় (স্পেস, যতিচিহ্ন উপেক্ষা করে,  \nand capitalization).  \nএবং বড় হাতের অক্ষর)।  \n\nExamples:  \nউদাহরণ:  \nisPalindrome(\"racecar\") // returns true",
      "bg": "Определете дали даден низ е палиндром.  \nПалиндром е дума, фраза, число или друга последователност от символи,  \nкоято се чете еднакво напред и назад (като се игнорират интервали, пунктуация  \nи главни букви).\n\nПримери:  \nisPalindrome(\"racecar\") // връща true",
      "zh": "确定给定的字符串是否是回文。  \n回文是指无论正向还是反向读取都相同的单词、短语、数字或其他字符序列（忽略空格、标点符号和大小写）。\n\n示例：\nisPalindrome(\"racecar\") // 返回 true",
      "fr": "Déterminer si une chaîne donnée est un palindrome.  \nUn palindrome est un mot, une phrase, un nombre ou une autre séquence de caractères  \nqui se lit de la même manière de l'avant vers l'arrière et de l'arrière vers l'avant (en ignorant les espaces, la ponctuation, et la capitalisation).\n\nExemples :  \nisPalindrome(\"racecar\") // retourne true",
      "de": "Bestimmen, ob ein gegebener String ein Palindrom ist.\nEin Palindrom ist ein Wort, ein Satz, eine Zahl oder eine andere Zeichenfolge,\ndie vorwärts und rückwärts gleich gelesen wird (unter Ignorierung von Leerzeichen, Interpunktion\nund Groß-/Kleinschreibung).\n\nBeispiele:\nisPalindrome(\"racecar\") // gibt true zurück",
      "ha": "Determine if a given string is a palindrome.  \nKalmar palindrome kalma ce, jimla, lamba, ko wata jerin haruffa  \nwanda yake karantawa iri ɗaya gaba da baya (ba tare da la'akari da sarari, rubutun rubutu,  \nda manyan ba).\n\nMisalai:  \nisPalindrome(\"racecar\") // yana dawowa da gaskiya",
      "hi": "Determine if a given string is a palindrome.  \nयह निर्धारित करें कि दिया गया स्ट्रिंग एक पालिंड्रोम है या नहीं।  \nA palindrome is a word, phrase, number, or other sequence of characters  \nपालिंड्रोम एक शब्द, वाक्यांश, संख्या, या अन्य वर्णों का अनुक्रम है  \nthat reads the same forward and backward (ignoring spaces, punctuation,  \nजो आगे और पीछे से समान रूप से पढ़ा जाता है (स्पेस, विराम चिह्न,  \nand capitalization).  \nऔर बड़े अक्षरों को नजरअंदाज करते हुए)।  \n\nExamples:  \nउदाहरण:  \nisPalindrome(\"racecar\") // returns true  \n",
      "hu": "Határozza meg, hogy egy adott karakterlánc palindróm-e.\nA palindróm olyan szó, kifejezés, szám vagy más karakterlánc,\namely előre és hátrafelé olvasva is ugyanaz (figyelmen kívül hagyva a szóközöket, írásjeleket és a nagybetűket).\n\nPéldák:\nisPalindrome(\"racecar\") // visszaadja, hogy igaz"
    },
    "docstring_bertscore": {
      "sq": "1",
      "hy": "0.9947047126719909",
      "bn": "0.853088997578976",
      "bg": "1",
      "zh": "0.9953727066434113",
      "fr": "1",
      "de": "0.9722499453567589",
      "ha": "0.9815784225716814",
      "hi": "0.8406086534777919",
      "hu": "1"
    }
  },
  {
    "task_id": "TypeScript/48",
    "prompt": {
      "en": "\n/**\n * Given a non-negative integer num, repeatedly add all its digits until\n * the result has only one digit. \n * For example:\n *   addDigits(38)  // returns 2\n *   Explanation: 3 + 8 = 11, and 1 + 1 = 2. Since 2 has only one digit, 2 is the result.\n */\nfunction addDigits(num: number): number {",
      "sq": "/**\n * Duke pasur një numër jo-negativ num, shto vazhdimisht të gjitha shifrat e tij derisa\n * rezultati të ketë vetëm një shifër.\n * Për shembull:\n *   addDigits(38)  // kthen 2\n *   Shpjegim: 3 + 8 = 11, dhe 1 + 1 = 2. Meqenëse 2 ka vetëm një shifër, 2 është rezultati.\n */\nfunction addDigits(num: number): number {",
      "hy": "/**\n * Տրված է ոչ բացասական ամբողջ թիվ num, բազմիցս գումարեք դրա բոլոր թվանշանները մինչև\n * արդյունքը կունենա միայն մեկ թվանշան:\n * Օրինակ:\n *   addDigits(38)  // վերադարձնում է 2\n *   Բացատրություն: 3 + 8 = 11, և 1 + 1 = 2: Քանի որ 2-ն ունի միայն մեկ թվանշան, 2-ն է արդյունքը:\n */\nfunction addDigits(num: number): number {",
      "bn": "/**\n * একটি অ-ঋণাত্মক পূর্ণসংখ্যা num দেওয়া হলে, তার সমস্ত অঙ্ক বারবার যোগ করুন যতক্ষণ না\n * ফলাফল শুধুমাত্র একটি অঙ্ক থাকে।\n * উদাহরণস্বরূপ:\n *   addDigits(38)  // 2 প্রদান করে\n *   ব্যাখ্যা: 3 + 8 = 11, এবং 1 + 1 = 2। যেহেতু 2 এর শুধুমাত্র একটি অঙ্ক রয়েছে, 2 হল ফলাফল।\n */\nfunction addDigits(num: number): number {",
      "bg": "/**\n * Дадено е неотрицателно цяло число num, повтаряйте събирането на всичките му цифри, докато\n * резултатът не стане едноцифрено число.\n * Например:\n *   addDigits(38)  // връща 2\n *   Обяснение: 3 + 8 = 11, и 1 + 1 = 2. Тъй като 2 е едноцифрено число, 2 е резултатът.\n */\nfunction addDigits(num: number): number {",
      "zh": "/**\n * 给定一个非负整数 num，重复将所有位上的数字相加，直到结果只有一位数字。\n * 例如:\n *   addDigits(38)  // 返回 2\n *   解释: 3 + 8 = 11, 然后 1 + 1 = 2。由于 2 只有一位数字，2 是结果。\n */\nfunction addDigits(num: number): number {",
      "fr": "/**\n * Étant donné un entier non négatif num, ajoutez de manière répétée tous ses chiffres jusqu'à ce que\n * le résultat n'ait qu'un seul chiffre. \n * Par exemple :\n *   addDigits(38)  // retourne 2\n *   Explication : 3 + 8 = 11, et 1 + 1 = 2. Puisque 2 n'a qu'un seul chiffre, 2 est le résultat.\n */\nfunction addDigits(num: number): number {",
      "de": "/**\n * Gegeben eine nicht-negative ganze Zahl num, addiere wiederholt alle ihre Ziffern, bis\n * das Ergebnis nur noch eine Ziffer hat. \n * Zum Beispiel:\n *   addDigits(38)  // gibt 2 zurück\n *   Erklärung: 3 + 8 = 11, und 1 + 1 = 2. Da 2 nur eine Ziffer hat, ist 2 das Ergebnis.\n */\nfunction addDigits(num: number): number {",
      "ha": "/**\n * An ba da wani lamba mara kyau num, a ci gaba da ƙara duk lambobinsa har\n * sakamakon yana da lamba ɗaya kawai.\n * Alal misali:\n *   addDigits(38)  // returns 2\n *   Bayani: 3 + 8 = 11, kuma 1 + 1 = 2. Tun da 2 yana da lamba ɗaya kawai, 2 shine sakamakon.\n */\nfunction addDigits(num: number): number {",
      "hi": "/**\n * दिए गए एक गैर-ऋणात्मक पूर्णांक num के लिए, इसकी सभी अंकों को तब तक जोड़ते रहें\n * जब तक परिणाम में केवल एक अंक न रह जाए।\n * उदाहरण के लिए:\n *   addDigits(38)  // 2 लौटाता है\n *   व्याख्या: 3 + 8 = 11, और 1 + 1 = 2. चूंकि 2 में केवल एक अंक है, 2 परिणाम है।\n */\nfunction addDigits(num: number): number {",
      "hu": "/**\n * Adott egy nem negatív egész szám, ismételten add össze az összes számjegyét,\n * amíg az eredmény csak egy számjegyből áll. \n * Például:\n *   addDigits(38)  // visszaadja a 2-t\n *   Magyarázat: 3 + 8 = 11, és 1 + 1 = 2. Mivel a 2 csak egy számjegyből áll, a 2 az eredmény.\n */\nfunction addDigits(num: number): number {"
    },
    "prompt_bertscore": {
      "sq": "0.9904081388998253",
      "hy": "0.9931599641986826",
      "bn": "1",
      "bg": "0.9560333637883085",
      "zh": "0.9629621873699485",
      "fr": "0.9977723602766937",
      "de": "1",
      "ha": "0.9700572645805148",
      "hi": "0.984661960606867",
      "hu": "0.9653815054109535"
    },
    "canonical_solution": "while (num >= 10) {\n        let sum = 0;\n        while (num > 0) {\n            sum += num % 10;\n            num = Math.floor(num / 10);\n        }\n        num = sum;\n    }\n    return num;\n}",
    "instruction": {
      "en": "Write a TypeScript function `function addDigits(num: number): number` to solve the following problem:\nGiven a non-negative integer num, repeatedly add all its digits until the result has only one digit.\nFor example:\n  addDigits(38)  // returns 2\n  Explanation: 3 + 8 = 11, and 1 + 1 = 2. Since 2 has only one digit, 2 is the result.",
      "sq": "Shkruani një funksion TypeScript `function addDigits(num: number): number` për të zgjidhur problemin e mëposhtëm:\nDuke pasur një numër të plotë jo-negativ num, shtoni vazhdimisht të gjitha shifrat e tij derisa rezultati të ketë vetëm një shifër.\nPër shembull:\n  addDigits(38)  // kthen 2\n  Shpjegim: 3 + 8 = 11, dhe 1 + 1 = 2. Meqenëse 2 ka vetëm një shifër, 2 është rezultati.",
      "hy": "Գրեք TypeScript ֆունկցիա `function addDigits(num: number): number` հետևյալ խնդիրը լուծելու համար:\nՏրված է ոչ բացասական ամբողջ թիվ num, կրկնվող կերպով գումարեք դրա բոլոր թվանշանները, մինչև արդյունքը կունենա միայն մեկ թվանշան:\nՕրինակ:\n  addDigits(38)  // վերադարձնում է 2\n  Բացատրություն: 3 + 8 = 11, և 1 + 1 = 2։ Քանի որ 2-ը ունի միայն մեկ թվանշան, 2-ը արդյունքն է։",
      "bn": "একটি TypeScript ফাংশন `function addDigits(num: number): number` লিখুন নিম্নলিখিত সমস্যার সমাধানের জন্য:\nএকটি অ-ঋণাত্মক পূর্ণসংখ্যা num দেওয়া হলে, তার সমস্ত অঙ্ক বারবার যোগ করুন যতক্ষণ না ফলাফলে শুধুমাত্র একটি অঙ্ক থাকে।\nউদাহরণস্বরূপ:\n  addDigits(38)  // 2 ফেরত দেয়\n  ব্যাখ্যা: 3 + 8 = 11, এবং 1 + 1 = 2। যেহেতু 2-এ শুধুমাত্র একটি অঙ্ক রয়েছে, তাই 2 হল ফলাফল।",
      "bg": "Напишете функция на TypeScript `function addDigits(num: number): number`, за да решите следния проблем:\nДадено е неотрицателно цяло число num, многократно събирайте всичките му цифри, докато резултатът не остане само една цифра.\nНапример:\n  addDigits(38)  // връща 2\n  Обяснение: 3 + 8 = 11, и 1 + 1 = 2. Тъй като 2 има само една цифра, 2 е резултатът.",
      "zh": "编写一个 TypeScript 函数 `function addDigits(num: number): number` 来解决以下问题：\n给定一个非负整数 num，重复将所有位数相加，直到结果只有一位数字。\n例如：\n  addDigits(38)  // 返回 2\n  解释：3 + 8 = 11，1 + 1 = 2。由于 2 只有一位数字，所以结果是 2。",
      "fr": "Écrire une fonction TypeScript `function addDigits(num: number): number` pour résoudre le problème suivant :\nÉtant donné un entier non négatif num, additionnez à plusieurs reprises tous ses chiffres jusqu'à ce que le résultat n'ait qu'un seul chiffre.\nPar exemple :\n  addDigits(38)  // renvoie 2\n  Explication : 3 + 8 = 11, et 1 + 1 = 2. Puisque 2 n'a qu'un seul chiffre, 2 est le résultat.",
      "de": "Schreiben Sie eine TypeScript-Funktion `function addDigits(num: number): number`, um das folgende Problem zu lösen:\nGegeben ist eine nicht-negative ganze Zahl num, addieren Sie wiederholt alle ihre Ziffern, bis das Ergebnis nur noch eine Ziffer hat.\nZum Beispiel:\n  addDigits(38)  // gibt 2 zurück\n  Erklärung: 3 + 8 = 11, und 1 + 1 = 2. Da 2 nur eine Ziffer hat, ist 2 das Ergebnis.",
      "ha": "Rubuta aikin TypeScript `function addDigits(num: number): number` don warware matsalar mai zuwa:\nAn ba da lamba mai kyau num, a ci gaba da ƙara duk lambobinta har sai sakamakon yana da lamba ɗaya kawai.\nMisali:\n  addDigits(38)  // returns 2\n  Bayani: 3 + 8 = 11, kuma 1 + 1 = 2. Tun da 2 yana da lamba ɗaya kawai, 2 shine sakamakon.",
      "hi": "TypeScript फ़ंक्शन `function addDigits(num: number): number` लिखें ताकि निम्नलिखित समस्या का समाधान किया जा सके:\nदिए गए गैर-ऋणात्मक पूर्णांक num के सभी अंकों को तब तक जोड़ें जब तक परिणाम में केवल एक अंक न रह जाए।\nउदाहरण के लिए:\n  addDigits(38)  // 2 लौटाता है\n  व्याख्या: 3 + 8 = 11, और 1 + 1 = 2. चूंकि 2 में केवल एक अंक है, 2 परिणाम है।",
      "hu": "Írj egy TypeScript függvényt `function addDigits(num: number): number` a következő probléma megoldására:\nAdott egy nem negatív egész szám num, ismételten add össze az összes számjegyét, amíg az eredmény csak egy számjegyből áll.\nPéldául:\n  addDigits(38)  // visszatér 2\n  Magyarázat: 3 + 8 = 11, és 1 + 1 = 2. Mivel a 2 csak egy számjegyből áll, 2 az eredmény."
    },
    "instruction_bertscore": {
      "sq": "1",
      "hy": "0.9952815352985163",
      "bn": "1",
      "bg": "0.9805276678560068",
      "zh": "0.9651749298146772",
      "fr": "1",
      "de": "1",
      "ha": "0.9952815352985163",
      "hi": "0.956053226826412",
      "hu": "0.9746029208504982"
    },
    "level": "easy",
    "test": "const testAddDigits = (): void => {\n    console.assert(addDigits(38) === 2, 'Test 1 failed');\n    console.assert(addDigits(0) === 0, 'Test 2 failed');\n    console.assert(addDigits(9) === 9, 'Test 3 failed');\n    console.assert(addDigits(123) === 6, 'Test 4 failed');\n    console.assert(addDigits(456) === 6, 'Test 5 failed');\n    console.assert(addDigits(9999) === 9, 'Test 6 failed');\n    console.assert(addDigits(100) === 1, 'Test 7 failed');\n    console.assert(addDigits(1010) === 2, 'Test 8 failed');\n    console.assert(addDigits(1234) === 1, 'Test 9 failed');\n    console.assert(addDigits(9876) === 3, 'Test 10 failed');\n    console.assert(addDigits(199) === 1, 'Test 11 failed');\n};\n\ntestAddDigits();",
    "entry_point": "addDigits",
    "signature": "function addDigits(num: number): number",
    "docstring": {
      "en": "Given a non-negative integer num, repeatedly add all its digits until the result has only one digit.\nFor example:\n  addDigits(38)  // returns 2\n  Explanation: 3 + 8 = 11, and 1 + 1 = 2. Since 2 has only one digit, 2 is the result.",
      "sq": "Duke pasur një numër të plotë jo-negativ num, shtoni vazhdimisht të gjitha shifrat e tij derisa rezultati të ketë vetëm një shifër.\nPër shembull:\n  addDigits(38)  // kthen 2\n  Shpjegim: 3 + 8 = 11, dhe 1 + 1 = 2. Meqenëse 2 ka vetëm një shifër, 2 është rezultati.",
      "hy": "Տրված է ոչ բացասական ամբողջ թիվ num, բազմիցս գումարեք դրա բոլոր թվանշանները, մինչև արդյունքը ունենա միայն մեկ թվանշան:\nՕրինակ:\n  addDigits(38)  // վերադարձնում է 2\n  Բացատրություն: 3 + 8 = 11, և 1 + 1 = 2։ Քանի որ 2-ը ունի միայն մեկ թվանշան, 2-ը արդյունքն է։",
      "bn": "একটি অ-ঋণাত্মক পূর্ণসংখ্যা num দেওয়া হলে, এর সমস্ত অঙ্ক বারবার যোগ করুন যতক্ষণ না ফলাফলটি কেবল একটি অঙ্ক থাকে। \nউদাহরণস্বরূপ:\n  addDigits(38)  // 2 ফেরত দেয়\n  ব্যাখ্যা: 3 + 8 = 11, এবং 1 + 1 = 2। যেহেতু 2 এর কেবল একটি অঙ্ক রয়েছে, তাই 2 হল ফলাফল।",
      "bg": "Дадено е неотрицателно цяло число num, повтаряйте събирането на всичките му цифри, докато резултатът има само една цифра.\nНапример:\n  addDigits(38)  // връща 2\n  Обяснение: 3 + 8 = 11, и 1 + 1 = 2. Тъй като 2 има само една цифра, 2 е резултатът.",
      "zh": "给定一个非负整数 num，重复相加其所有数字，直到结果只有一位数字。\n\n例如：\n  addDigits(38)  // 返回 2\n  解释：3 + 8 = 11，1 + 1 = 2。由于 2 只有一位数字，2 是结果。",
      "fr": "Étant donné un entier non négatif num, additionnez de manière répétée tous ses chiffres jusqu'à ce que le résultat n'ait qu'un seul chiffre.\nPar exemple :\n  addDigits(38)  // retourne 2\n  Explication : 3 + 8 = 11, et 1 + 1 = 2. Puisque 2 n'a qu'un seul chiffre, 2 est le résultat.",
      "de": "Gegeben eine nicht-negative ganze Zahl num, addiere wiederholt alle ihre Ziffern, bis das Ergebnis nur noch eine Ziffer hat.\nZum Beispiel:\n  addDigits(38)  // gibt 2 zurück\n  Erklärung: 3 + 8 = 11, und 1 + 1 = 2. Da 2 nur eine Ziffer hat, ist 2 das Ergebnis.",
      "ha": "An ba da wani lamba mai kyau num, a ci gaba da ƙara duk lambobinsa har sai sakamakon yana da lamba daya kawai.\n\nMisali:\n  addDigits(38)  // ya dawo da 2\n  Bayani: 3 + 8 = 11, kuma 1 + 1 = 2. Tun da 2 yana da lamba daya kawai, 2 shine sakamakon.",
      "hi": "एक गैर-ऋणात्मक पूर्णांक num दिया गया है, इसके सभी अंकों को बार-बार जोड़ें जब तक परिणाम में केवल एक अंक न रह जाए।\n\nउदाहरण:\n  addDigits(38)  // 2 लौटाता है\n  व्याख्या: 3 + 8 = 11, और 1 + 1 = 2। चूंकि 2 में केवल एक अंक है, 2 परिणाम है।",
      "hu": "Adott egy nem negatív egész szám, ismételten add össze az összes számjegyét, amíg az eredmény csak egy számjegyből áll.\n\nPéldául:\n  addDigits(38)  // visszaadja a 2-t\n  Magyarázat: 3 + 8 = 11, és 1 + 1 = 2. Mivel a 2 csak egy számjegyből áll, 2 az eredmény."
    },
    "docstring_bertscore": {
      "sq": "0.9937584375367408",
      "hy": "0.993703019660432",
      "bn": "1",
      "bg": "1",
      "zh": "0.9595080050437519",
      "fr": "1",
      "de": "1",
      "ha": "0.993703019660432",
      "hi": "0.9739009610839209",
      "hu": "0.9782795692034539"
    }
  },
  {
    "task_id": "TypeScript/49",
    "prompt": {
      "en": "\n/**\n * You are playing a game called Nim. In this game, you start with a pile\n * of n stones, and you and your opponent take turns to remove 1 to 3\n * stones from the pile. The one who removes the last stone wins the game.\n * Given the number of stones n, determine if you can win the game if both\n * you and your opponent play optimally.\n * Note: You always take the first turn.\n *\n * Here are some cases:\n *   canWinNim(1) // returns true\n */\nfunction canWinNim(n: number): boolean",
      "sq": "/**\n * Ju po luani një lojë të quajtur Nim. Në këtë lojë, ju filloni me një grumbull\n * prej n gurësh, dhe ju dhe kundërshtari juaj merrni me radhë për të hequr 1 deri në 3\n * gurë nga grumbulli. Ai që heq gurin e fundit fiton lojën.\n * Duke pasur parasysh numrin e gurëve n, përcaktoni nëse mund ta fitoni lojën nëse të dy\n * ju dhe kundërshtari juaj luani në mënyrë optimale.\n * Shënim: Ju gjithmonë merrni lëvizjen e parë.\n *\n * Ja disa raste:\n *   canWinNim(1) // kthen true\n */",
      "hy": "/**\n * Դուք խաղում եք Նիմ կոչվող խաղը։ Այս խաղում դուք սկսում եք n քարերով կույտից,\n * և դուք ու ձեր մրցակիցը հերթով հեռացնում եք 1-ից 3 քար կույտից։\n * Նա, ով հեռացնում է վերջին քարը, հաղթում է խաղը։\n * Տրված է քարերի քանակը n, որոշեք՝ արդյոք դուք կարող եք հաղթել խաղը, եթե\n * դուք և ձեր մրցակիցը խաղում եք օպտիմալ։\n * Նշում. Դուք միշտ առաջինն եք խաղում։\n *\n * Ահա մի քանի դեպքեր.\n *   canWinNim(1) // վերադարձնում է true\n */\nfunction canWinNim(n: number): boolean",
      "bn": "/**\n * তুমি একটি খেলা খেলছো যার নাম নিম। এই খেলায়, তুমি n পাথর দিয়ে শুরু করো,\n * এবং তুমি ও তোমার প্রতিদ্বন্দ্বী পালা করে ১ থেকে ৩টি পাথর সরিয়ে নাও।\n * যে শেষ পাথরটি সরাবে সে খেলাটি জিতে যাবে।\n * পাথরের সংখ্যা n দেওয়া আছে, নির্ধারণ করো তুমি খেলাটি জিততে পারবে কিনা\n * যদি তুমি ও তোমার প্রতিদ্বন্দ্বী উভয়ই সর্বোত্তমভাবে খেলে।\n * নোট: তুমি সবসময় প্রথম পালা নাও।\n *\n * এখানে কিছু উদাহরণ:\n *   canWinNim(1) // true রিটার্ন করে\n */\nfunction canWinNim(n: number): boolean",
      "bg": "/**\n * Играете игра, наречена Nim. В тази игра започвате с купчина\n * от n камъка, и вие и вашият противник се редувате да махате от 1 до 3\n * камъка от купчината. Този, който махне последния камък, печели играта.\n * Даден е броят на камъните n, определете дали можете да спечелите играта, ако и двамата\n * вие и вашият противник играете оптимално.\n * Забележка: Винаги вие взимате първия ход.\n *\n * Ето някои случаи:\n *   canWinNim(1) // връща true\n */\nfunction canWinNim(n: number): boolean",
      "zh": "/**\n * 你正在玩一个叫做 Nim 的游戏。在这个游戏中，你从一堆 n 个石头开始，你和你的对手轮流从堆中移除 1 到 3 个石头。移除最后一个石头的人赢得游戏。\n * 给定石头的数量 n，如果你和你的对手都以最佳方式进行游戏，确定你是否能赢得游戏。\n * 注意：你总是先开始。\n *\n * 这里有一些情况：\n *   canWinNim(1) // 返回 true\n */",
      "fr": "/**\n * Vous jouez à un jeu appelé Nim. Dans ce jeu, vous commencez avec un tas\n * de n pierres, et vous et votre adversaire prenez à tour de rôle entre 1 et 3\n * pierres du tas. Celui qui enlève la dernière pierre gagne la partie.\n * Étant donné le nombre de pierres n, déterminez si vous pouvez gagner la partie si vous et\n * votre adversaire jouez de manière optimale.\n * Remarque : Vous jouez toujours en premier.\n *\n * Voici quelques cas :\n *   canWinNim(1) // retourne true\n */\nfunction canWinNim(n: number): boolean",
      "de": "/**\n * Du spielst ein Spiel namens Nim. In diesem Spiel beginnst du mit einem Haufen\n * von n Steinen, und du und dein Gegner wechseln euch ab, um 1 bis 3\n * Steine aus dem Haufen zu entfernen. Derjenige, der den letzten Stein entfernt, gewinnt das Spiel.\n * Gegeben ist die Anzahl der Steine n, bestimme, ob du das Spiel gewinnen kannst, wenn sowohl\n * du als auch dein Gegner optimal spielen.\n * Hinweis: Du bist immer derjenige, der den ersten Zug macht.\n *\n * Hier sind einige Fälle:\n *   canWinNim(1) // gibt true zurück\n */\nfunction canWinNim(n: number): boolean",
      "ha": "/**\n * Kuna wasa wani wasa da ake kira Nim. A cikin wannan wasa, kuna farawa da tarin\n * duwatsu n, kuma ku da abokin hamayyarku kuna juyawa don cire 1 zuwa 3\n * duwatsu daga tarin. Wanda ya cire dutse na ƙarshe ya ci nasara a wasan.\n * An ba da adadin duwatsu n, tantance idan za ku iya cin nasara a wasan idan duka\n * ku da abokin hamayyarku kuna wasa da hikima.\n * Lura: Kullum kuna fara juyawa na farko.\n *\n * Ga wasu lokuta:\n *   canWinNim(1) // returns true\n */\nfunction canWinNim(n: number): boolean",
      "hi": "/**\n * आप एक खेल खेल रहे हैं जिसे निम कहा जाता है। इस खेल में, आप n पत्थरों के ढेर से शुरू करते हैं,\n * और आप और आपका प्रतिद्वंद्वी बारी-बारी से 1 से 3 पत्थर ढेर से हटाते हैं। जो अंतिम पत्थर हटाता है वह खेल जीतता है।\n * दिए गए पत्थरों की संख्या n के साथ, यह निर्धारित करें कि क्या आप खेल जीत सकते हैं यदि आप और आपका प्रतिद्वंद्वी दोनों\n * आदर्श रूप से खेलते हैं।\n * नोट: आप हमेशा पहली बारी लेते हैं।\n *\n * यहाँ कुछ मामले हैं:\n *   canWinNim(1) // true लौटाता है\n */\nfunction canWinNim(n: number): boolean",
      "hu": "/**\n * Egy Nim nevű játékot játszol. Ebben a játékban egy halom n kővel kezdesz,\n * és te, valamint az ellenfeled felváltva távolítotok el 1-3 követ a halomból.\n * Az nyer, aki az utolsó követ eltávolítja. Adott a kövek száma n, határozd meg,\n * hogy meg tudod-e nyerni a játékot, ha mindketten optimálisan játszotok.\n * Megjegyzés: Mindig te kezded az első kört.\n *\n * Íme néhány eset:\n *   canWinNim(1) // visszaadja: true\n */\nfunction canWinNim(n: number): boolean"
    },
    "prompt_bertscore": {
      "sq": "0.9611506782949104",
      "hy": "0.9686251395332532",
      "bn": "0.9575969821478152",
      "bg": "0.9875742792536005",
      "zh": "0.9393221925710813",
      "fr": "0.9775374860999076",
      "de": "0.9792045908879334",
      "ha": "0.9904244265910701",
      "hi": "0.9868409358868196",
      "hu": "0.9586109902429982"
    },
    "canonical_solution": "{\n    return n % 4 !== 0;\n}",
    "instruction": {
      "en": "Write a TypeScript function `function canWinNim(n: number): boolean` to solve the following problem:\nYou are playing a game called Nim. In this game, you start with a pile\nof n stones, and you and your opponent take turns to remove 1 to 3\nstones from the pile. The one who removes the last stone wins the game.\nGiven the number of stones n, determine if you can win the game if both\nyou and your opponent play optimally.\nNote: You always take the first turn.\n\nHere are some cases:\n  canWinNim(1) // returns true\n",
      "sq": "Shkruani një funksion TypeScript `function canWinNim(n: number): boolean` për të zgjidhur problemin e mëposhtëm:\nJu po luani një lojë të quajtur Nim. Në këtë lojë, ju filloni me një grumbull\nprej n gurësh, dhe ju dhe kundërshtari juaj merrni radhë për të hequr 1 deri në 3\ngurë nga grumbulli. Ai që heq gurin e fundit fiton lojën.\nDuke pasur parasysh numrin e gurëve n, përcaktoni nëse mund të fitoni lojën nëse të dy\nju dhe kundërshtari juaj luani në mënyrë optimale.\nShënim: Ju gjithmonë merrni radhën e parë.\n\nJa disa raste:\n  canWinNim(1) // kthen true",
      "hy": "TypeScript ֆունկցիա `function canWinNim(n: number): boolean` գրեք հետևյալ խնդիրը լուծելու համար:\nԴուք խաղում եք Nim կոչվող խաղը։ Այս խաղում դուք սկսում եք n քարերով կույտից, և դուք ու ձեր մրցակիցը հերթով հեռացնում եք 1-ից 3 քար կույտից։ Նա, ով հեռացնում է վերջին քարը, հաղթում է խաղը։ Տրված է քարերի n քանակը, որոշեք՝ արդյոք դուք կարող եք հաղթել խաղը, եթե դուք և ձեր մրցակիցը խաղում եք օպտիմալ կերպով։\nՆշում: Դուք միշտ առաջինն եք խաղում։\n\nԱհա մի քանի դեպքեր:\n  canWinNim(1) // վերադարձնում է true",
      "bn": "TypeScript ফাংশন `function canWinNim(n: number): boolean` লিখুন নিম্নলিখিত সমস্যার সমাধানের জন্য:\nআপনি একটি গেম খেলছেন যার নাম নিম। এই গেমে, আপনি একটি n পাথরের স্তূপ দিয়ে শুরু করেন, এবং আপনি এবং আপনার প্রতিপক্ষ পালা করে 1 থেকে 3 পাথর স্তূপ থেকে সরিয়ে নেন। যে শেষ পাথরটি সরায় সে গেমটি জিতে। পাথরের সংখ্যা n দেওয়া হলে, নির্ধারণ করুন আপনি গেমটি জিততে পারবেন কিনা যদি আপনি এবং আপনার প্রতিপক্ষ উভয়ই সর্বোত্তমভাবে খেলেন।\nদ্রষ্টব্য: আপনি সর্বদা প্রথম পালা নেন।\n\nকিছু উদাহরণ এখানে:\n  canWinNim(1) // true রিটার্ন করে",
      "bg": "Напишете TypeScript функция `function canWinNim(n: number): boolean`, за да решите следния проблем:\nВие играете игра, наречена Nim. В тази игра започвате с купчина от n камъка и вие и вашият противник се редувате да премахвате от 1 до 3 камъка от купчината. Този, който премахне последния камък, печели играта. \nДаден е броят на камъните n, определете дали можете да спечелите играта, ако и вие, и вашият противник играете оптимално.\nЗабележка: Винаги вие правите първия ход.\n\nЕто някои случаи:\n  canWinNim(1) // връща true",
      "zh": "编写一个 TypeScript 函数 `function canWinNim(n: number): boolean` 来解决以下问题：\n你正在玩一个叫做 Nim 的游戏。在这个游戏中，你从一堆 n 个石头开始，你和你的对手轮流从堆中移除 1 到 3 个石头。移除最后一个石头的人赢得比赛。\n给定石头的数量 n，如果你和你的对手都以最佳方式进行游戏，确定你是否可以赢得比赛。\n注意：你总是先出手。\n\n以下是一些情况：\n  canWinNim(1) // 返回 true",
      "fr": "Écrivez une fonction TypeScript `function canWinNim(n: number): boolean` pour résoudre le problème suivant :\nVous jouez à un jeu appelé Nim. Dans ce jeu, vous commencez avec un tas\nde n pierres, et vous et votre adversaire prenez à tour de rôle entre 1 et 3\npierres du tas. Celui qui enlève la dernière pierre gagne la partie.\nÉtant donné le nombre de pierres n, déterminez si vous pouvez gagner la partie si vous et votre adversaire jouez de manière optimale.\nRemarque : Vous prenez toujours le premier tour.\n\nVoici quelques cas :\n  canWinNim(1) // retourne true",
      "de": "Schreiben Sie eine TypeScript-Funktion `function canWinNim(n: number): boolean`, um das folgende Problem zu lösen:\nSie spielen ein Spiel namens Nim. In diesem Spiel beginnen Sie mit einem Haufen von n Steinen, und Sie und Ihr Gegner wechseln sich ab, um 1 bis 3 Steine aus dem Haufen zu entfernen. Derjenige, der den letzten Stein entfernt, gewinnt das Spiel. Gegeben die Anzahl der Steine n, bestimmen Sie, ob Sie das Spiel gewinnen können, wenn sowohl Sie als auch Ihr Gegner optimal spielen.\nHinweis: Sie sind immer der Erste, der an der Reihe ist.\n\nHier sind einige Fälle:\n  canWinNim(1) // gibt true zurück",
      "ha": "Rubuta aikin TypeScript `function canWinNim(n: number): boolean` don warware matsalar mai zuwa:\nKana wasa mai suna Nim. A cikin wannan wasa, ka fara da tarin duwatsu n, kai da abokin hamayyarka kuna daukar matakai don cire 1 zuwa 3 duwatsu daga tarin. Wanda ya cire dutse na ƙarshe ya ci wasan. An ba da yawan duwatsu n, tantance idan zaka iya cin nasara idan kai da abokin hamayyarka kuna wasa cikin hikima.\nLura: Kai ne kullum ke fara wasa.\n\nGa wasu lokuta:\n  canWinNim(1) // returns true",
      "hi": "TypeScript फ़ंक्शन `function canWinNim(n: number): boolean` लिखें ताकि निम्नलिखित समस्या का समाधान हो सके:\nआप एक खेल खेल रहे हैं जिसे निम कहा जाता है। इस खेल में, आप n पत्थरों के ढेर से शुरू करते हैं, और आप और आपका प्रतिद्वंद्वी बारी-बारी से 1 से 3 पत्थर ढेर से हटाते हैं। जो अंतिम पत्थर हटाता है वह खेल जीतता है। दिए गए पत्थरों की संख्या n के आधार पर, यह निर्धारित करें कि क्या आप खेल जीत सकते हैं यदि आप और आपका प्रतिद्वंद्वी दोनों ही सर्वोत्तम तरीके से खेलते हैं।\nध्यान दें: आप हमेशा पहली बारी लेते हैं।\n\nयहाँ कुछ उदाहरण हैं:\n  canWinNim(1) // true लौटाता है",
      "hu": "Írj egy TypeScript függvényt `function canWinNim(n: number): boolean` a következő probléma megoldására:\nEgy Nim nevű játékot játszol. Ebben a játékban egy halom n kővel kezdesz, és te, valamint az ellenfeled felváltva távolítotok el 1-től 3-ig terjedő számú követ a halomból. Az nyeri a játékot, aki az utolsó követ eltávolítja.\nAdott a kövek száma n, határozd meg, hogy meg tudod-e nyerni a játékot, ha te és az ellenfeled is optimálisan játszotok.\nMegjegyzés: Mindig te kezded az első kört.\n\nÍme néhány eset:\n  canWinNim(1) // visszaadja, hogy true"
    },
    "instruction_bertscore": {
      "sq": "0.999999801369619",
      "hy": "0.9712849989656914",
      "bn": "0.9770150881977858",
      "bg": "0.9873591625509397",
      "zh": "0.9810512575404148",
      "fr": "0.9899417547651553",
      "de": "0.9858543387842194",
      "ha": "0.9774550544917782",
      "hi": "0.9724215620059731",
      "hu": "0.9869940799105976"
    },
    "level": "easy",
    "test": "function testCanWinNim(): void {\n    console.assert(canWinNim(1) === true, \"Test case 1 failed\");\n    console.assert(canWinNim(2) === true, \"Test case 2 failed\");\n    console.assert(canWinNim(3) === true, \"Test case 3 failed\");\n    console.assert(canWinNim(4) === false, \"Test case 4 failed\");\n    console.assert(canWinNim(5) === true, \"Test case 5 failed\");\n    console.assert(canWinNim(6) === true, \"Test case 6 failed\");\n    console.assert(canWinNim(7) === true, \"Test case 7 failed\");\n    console.assert(canWinNim(8) === false, \"Test case 8 failed\");\n    console.assert(canWinNim(9) === true, \"Test case 9 failed\");\n    console.assert(canWinNim(10) === true, \"Test case 10 failed\");\n    console.assert(canWinNim(11) === true, \"Test case 11 failed\");\n    console.assert(canWinNim(12) === false, \"Test case 12 failed\");\n    console.assert(canWinNim(13) === true, \"Test case 13 failed\");\n    console.assert(canWinNim(14) === true, \"Test case 14 failed\");\n    console.assert(canWinNim(15) === true, \"Test case 15 failed\");\n    console.assert(canWinNim(16) === false, \"Test case 16 failed\");\n    console.assert(canWinNim(17) === true, \"Test case 17 failed\");\n    console.assert(canWinNim(18) === true, \"Test case 18 failed\");\n    console.assert(canWinNim(19) === true, \"Test case 19 failed\");\n    console.assert(canWinNim(20) === false, \"Test case 20 failed\");\n}\ntestCanWinNim();",
    "entry_point": "canWinNim",
    "signature": "function canWinNim(n: number): boolean",
    "docstring": {
      "en": "You are playing a game called Nim. In this game, you start with a pile\nof n stones, and you and your opponent take turns to remove 1 to 3\nstones from the pile. The one who removes the last stone wins the game.\nGiven the number of stones n, determine if you can win the game if both\nyou and your opponent play optimally.\nNote: You always take the first turn.\n\nHere are some cases:\n  canWinNim(1) // returns true\n",
      "sq": "Ju po luani një lojë të quajtur Nim. Në këtë lojë, ju filloni me një grumbull prej n gurësh, dhe ju dhe kundërshtari juaj merrni me radhë për të hequr 1 deri në 3 gurë nga grumbulli. Ai që heq gurin e fundit fiton lojën. Duke pasur parasysh numrin e gurëve n, përcaktoni nëse mund të fitoni lojën nëse si ju ashtu edhe kundërshtari juaj luani në mënyrë optimale. \nShënim: Ju gjithmonë luani të parët.\n\nKëtu janë disa raste:\n  canWinNim(1) // kthen true",
      "hy": "Դուք խաղում եք Nim կոչվող խաղը։ Այս խաղում դուք սկսում եք n քարերով կույտից, և դուք ու ձեր մրցակիցը հերթով հեռացնում եք 1-ից 3 քար կույտից։ Նա, ով հեռացնում է վերջին քարը, հաղթում է խաղը։ Տրված է քարերի քանակը n, որոշեք, արդյոք դուք կարող եք հաղթել խաղը, եթե դուք և ձեր մրցակիցը խաղում եք օպտիմալ կերպով։ Նշում. դուք միշտ առաջինն եք խաղում։\n\nԱհա որոշ դեպքեր.\n  canWinNim(1) // վերադարձնում է true",
      "bn": "আপনি একটি খেলা খেলছেন যার নাম নিম। এই খেলায়, আপনি একটি পাথরের স্তূপ দিয়ে শুরু করেন, এবং আপনি এবং আপনার প্রতিপক্ষ পালাক্রমে স্তূপ থেকে ১ থেকে ৩টি পাথর সরান। যে ব্যক্তি শেষ পাথরটি সরায় সে খেলা জিতে। পাথরের সংখ্যা n দেওয়া হলে, নির্ধারণ করুন আপনি খেলা জিততে পারবেন কিনা যদি আপনি এবং আপনার প্রতিপক্ষ উভয়েই সর্বোত্তমভাবে খেলেন।\nনোট: আপনি সর্বদা প্রথম পালা নেন।\n\nএখানে কিছু উদাহরণ রয়েছে:\n  canWinNim(1) // true ফেরত দেয়",
      "bg": "Играете игра, наречена Nim. В тази игра започвате с купчина от n камъка, и вие и вашият противник се редувате да премахвате от 1 до 3 камъка от купчината. Този, който премахне последния камък, печели играта. Даден е броят на камъните n, определете дали можете да спечелите играта, ако и вие, и вашият противник играете оптимално. \nЗабележка: Винаги вие започвате първи.\n\nЕто няколко случая:\n  canWinNim(1) // връща true",
      "zh": "你正在玩一个叫做 Nim 的游戏。在这个游戏中，你从一堆 n 个石头开始，你和你的对手轮流从堆中移除 1 到 3 个石头。移除最后一个石头的人赢得游戏。给定石头的数量 n，判断如果你和你的对手都以最佳方式进行游戏，你是否能赢得比赛。\n注意：你总是先走。\n\n以下是一些情况：\n  canWinNim(1) // 返回 true",
      "fr": "Vous jouez à un jeu appelé Nim. Dans ce jeu, vous commencez avec un tas de n pierres, et vous et votre adversaire prenez à tour de rôle entre 1 et 3 pierres du tas. Celui qui enlève la dernière pierre gagne la partie. Étant donné le nombre de pierres n, déterminez si vous pouvez gagner la partie si vous et votre adversaire jouez de manière optimale.  \nRemarque : Vous jouez toujours en premier.\n\nVoici quelques cas :  \n  canWinNim(1) // retourne true",
      "de": "Du spielst ein Spiel namens Nim. In diesem Spiel beginnst du mit einem Haufen von n Steinen, und du und dein Gegner wechseln euch ab, um 1 bis 3 Steine aus dem Haufen zu entfernen. Derjenige, der den letzten Stein entfernt, gewinnt das Spiel. Gegeben ist die Anzahl der Steine n, bestimme, ob du das Spiel gewinnen kannst, wenn sowohl du als auch dein Gegner optimal spielen.\nHinweis: Du bist immer der Erste, der an der Reihe ist.\n\nHier sind einige Fälle:\n  canWinNim(1) // gibt true zurück",
      "ha": "You are playing a game called Nim. A cikin wannan wasa, ka fara da tarin\nduwatsu n, kuma kai da abokin hamayyarka kuna juyawa don cire 1 zuwa 3\nduwatsu daga tarin. Wanda ya cire dutse na karshe shi ne zai ci wasan.\nAn ba da adadin duwatsu n, ka tantance idan za ka iya cin wasan idan duk\nkai da abokin hamayyarka kuna wasa da hikima.\nLura: Kai ne koyaushe ke fara wasa.\n\nGa wasu lokuta:\n  canWinNim(1) // yana dawowa gaskiya",
      "hi": "You are playing a game called Nim. In this game, you start with a pile\nof n stones, and you and your opponent take turns to remove 1 to 3\nstones from the pile. The one who removes the last stone wins the game.\nGiven the number of stones n, determine if you can win the game if both\nyou and your opponent play optimally.\nध्यान दें: आप हमेशा पहला मोड़ लेते हैं।\n\nयहाँ कुछ मामले हैं:\n  canWinNim(1) // returns true",
      "hu": "Egy Nim nevű játékot játszol. Ebben a játékban egy halom n kővel kezdesz, és te, valamint az ellenfeled felváltva távolítotok el 1-3 követ a halomból. Az nyer, aki az utolsó követ eltávolítja. Adott a kövek száma, n, határozd meg, hogy nyerhetsz-e, ha mind te, mind az ellenfeled optimálisan játszik. Megjegyzés: Mindig te kezded az első kört.\n\nÍme néhány eset:\n  canWinNim(1) // visszaadja: true"
    },
    "docstring_bertscore": {
      "sq": "0.9882259855337759",
      "hy": "0.9712105125728033",
      "bn": "0.9810480794543183",
      "bg": "0.9811098535028201",
      "zh": "0.9762215598255515",
      "fr": "0.9762362584737481",
      "de": "0.9824414715772779",
      "ha": "0.9786853710719082",
      "hi": "0.999999801369619",
      "hu": "0.9622896248997644"
    }
  },
  {
    "task_id": "TypeScript/50",
    "prompt": {
      "en": "\n/**\n * Given two integers a and b, return the sum if the sum is even,\n * or return the product of a and b if the sum is odd.\n * Examples:\n *   evenSumOrOddProduct(2, 3) returns 6\n *   evenSumOrOddProduct(5, 5) returns 10\n */\nfunction evenSumOrOddProduct(a: number, b: number): number {",
      "sq": "/**\n * Duke pasur dy numra të plotë a dhe b, kthejeni shumën nëse shuma është çift,\n * ose kthejeni prodhimin e a dhe b nëse shuma është tek.\n * Shembuj:\n *   evenSumOrOddProduct(2, 3) kthen 6\n *   evenSumOrOddProduct(5, 5) kthen 10\n */\nfunction evenSumOrOddProduct(a: number, b: number): number {",
      "hy": "/**\n * Տրված է երկու ամբողջ թիվ a և b, վերադարձնել գումարը, եթե գումարը զույգ է,\n * կամ վերադարձնել a և b արտադրյալը, եթե գումարը կենտ է։\n * Օրինակներ:\n *   evenSumOrOddProduct(2, 3) վերադարձնում է 6\n *   evenSumOrOddProduct(5, 5) վերադարձնում է 10\n */\nfunction evenSumOrOddProduct(a: number, b: number): number {",
      "bn": "/**\n * দুটি পূর্ণসংখ্যা a এবং b দেওয়া হলে, যোগফল জোড় হলে যোগফল ফেরত দিন,\n * অথবা যদি যোগফল বিজোড় হয় তবে a এবং b এর গুণফল ফেরত দিন।\n * উদাহরণসমূহ:\n *   evenSumOrOddProduct(2, 3) 6 ফেরত দেয়\n *   evenSumOrOddProduct(5, 5) 10 ফেরত দেয়\n */\nfunction evenSumOrOddProduct(a: number, b: number): number {",
      "bg": "/**\n * Дадени са две цели числа a и b, върни сумата, ако сумата е четна,\n * или върни произведението на a и b, ако сумата е нечетна.\n * Примери:\n *   evenSumOrOddProduct(2, 3) връща 6\n *   evenSumOrOddProduct(5, 5) връща 10\n */\nfunction evenSumOrOddProduct(a: number, b: number): number {",
      "zh": "/**\n * 给定两个整数 a 和 b，如果它们的和是偶数则返回和，\n * 如果和是奇数则返回 a 和 b 的乘积。\n * 例子：\n *   evenSumOrOddProduct(2, 3) 返回 6\n *   evenSumOrOddProduct(5, 5) 返回 10\n */\nfunction evenSumOrOddProduct(a: number, b: number): number {",
      "fr": "/**\n * Étant donné deux entiers a et b, retourner la somme si la somme est paire,\n * ou retourner le produit de a et b si la somme est impaire.\n * Exemples :\n *   evenSumOrOddProduct(2, 3) returns 6\n *   evenSumOrOddProduct(5, 5) returns 10\n */\nfunction evenSumOrOddProduct(a: number, b: number): number {",
      "de": "/**\n * Gegeben zwei ganze Zahlen a und b, gib die Summe zurück, wenn die Summe gerade ist,\n * oder gib das Produkt von a und b zurück, wenn die Summe ungerade ist.\n * Beispiele:\n *   evenSumOrOddProduct(2, 3) gibt 6 zurück\n *   evenSumOrOddProduct(5, 5) gibt 10 zurück\n */\nfunction evenSumOrOddProduct(a: number, b: number): number {",
      "ha": "/**\n * Idan aka ba da lambobi guda biyu a da b, dawo da jumlar idan jumlar tana da lamba mai ma'ana,\n * ko kuma dawo da samfurin a da b idan jumlar tana da lamba mai lamba.\n * Misalai:\n *   evenSumOrOddProduct(2, 3) yana dawowa 6\n *   evenSumOrOddProduct(5, 5) yana dawowa 10\n */\nfunction evenSumOrOddProduct(a: number, b: number): number {",
      "hi": "/**\n * दिए गए दो पूर्णांक a और b, यदि योग सम है तो योग लौटाएं,\n * या यदि योग विषम है तो a और b का गुणनफल लौटाएं।\n * उदाहरण:\n *   evenSumOrOddProduct(2, 3) 6 लौटाता है\n *   evenSumOrOddProduct(5, 5) 10 लौटाता है\n */\nfunction evenSumOrOddProduct(a: number, b: number): number {",
      "hu": "/**\n * Két egész szám, a és b esetén térj vissza az összegükkel, ha az összeg páros,\n * vagy térj vissza a és b szorzatával, ha az összeg páratlan.\n * Példák:\n *   evenSumOrOddProduct(2, 3) visszatér 6\n *   evenSumOrOddProduct(5, 5) visszatér 10\n */\nfunction evenSumOrOddProduct(a: number, b: number): number {"
    },
    "prompt_bertscore": {
      "sq": "1",
      "hy": "1",
      "bn": "0.9871964842688722",
      "bg": "1",
      "zh": "0.9685661463100859",
      "fr": "1",
      "de": "1",
      "ha": "0.9575143519093047",
      "hi": "0.9975677709842278",
      "hu": "0.9846260085078996"
    },
    "canonical_solution": "let sum = a + b;\n    if (sum % 2 === 0) {\n        return sum;\n    } else {\n        return a * b;\n    }\n}",
    "instruction": {
      "en": "Write a TypeScript function `function evenSumOrOddProduct(a: number, b: number): number` to solve the following problem:\nGiven two integers a and b, return the sum if the sum is even,\nor return the product of a and b if the sum is odd.\nExamples:\nevenSumOrOddProduct(2, 3) returns 6\nevenSumOrOddProduct(5, 5) returns 10\n",
      "sq": "Shkruani një funksion TypeScript `function evenSumOrOddProduct(a: number, b: number): number` për të zgjidhur problemin e mëposhtëm:  \nDuke pasur dy numra të plotë a dhe b, kthejeni shumën nëse shuma është çift,  \nose kthejeni produktin e a dhe b nëse shuma është tek.  \nShembuj:  \nevenSumOrOddProduct(2, 3) kthen 6  \nevenSumOrOddProduct(5, 5) kthen 10  ",
      "hy": "Գրեք TypeScript ֆունկցիա `function evenSumOrOddProduct(a: number, b: number): number` հետևյալ խնդիրը լուծելու համար: Տրված են երկու ամբողջ թիվ a և b, վերադարձնել գումարը, եթե գումարը զույգ է, կամ վերադարձնել a և b-ի արտադրյալը, եթե գումարը կենտ է: Օրինակներ: evenSumOrOddProduct(2, 3) վերադարձնում է 6 evenSumOrOddProduct(5, 5) վերադարձնում է 10",
      "bn": "একটি TypeScript ফাংশন `function evenSumOrOddProduct(a: number, b: number): number` লিখুন নিম্নলিখিত সমস্যার সমাধানের জন্য:\nদুটি পূর্ণসংখ্যা a এবং b দেওয়া হলে, যদি যোগফলটি জোড় হয় তবে যোগফলটি ফেরত দিন,\nঅথবা যদি যোগফলটি বিজোড় হয় তবে a এবং b এর গুণফল ফেরত দিন।\nউদাহরণ:\nevenSumOrOddProduct(2, 3) 6 ফেরত দেয়\nevenSumOrOddProduct(5, 5) 10 ফেরত দেয়",
      "bg": "Напишете TypeScript функция `function evenSumOrOddProduct(a: number, b: number): number`, за да решите следния проблем:\nДадени са две цели числа a и b, върнете сумата, ако сумата е четна,\nили върнете произведението на a и b, ако сумата е нечетна.\nПримери:\nevenSumOrOddProduct(2, 3) връща 6\nevenSumOrOddProduct(5, 5) връща 10",
      "zh": "编写一个 TypeScript 函数 `function evenSumOrOddProduct(a: number, b: number): number` 来解决以下问题：  \n给定两个整数 a 和 b，如果它们的和是偶数，则返回和；如果和是奇数，则返回 a 和 b 的乘积。  \n示例：  \nevenSumOrOddProduct(2, 3) 返回 6  \nevenSumOrOddProduct(5, 5) 返回 10  ",
      "fr": "Écrire une fonction TypeScript `function evenSumOrOddProduct(a: number, b: number): number` pour résoudre le problème suivant :\nÉtant donné deux entiers a et b, retourner la somme si la somme est paire,\nou retourner le produit de a et b si la somme est impaire.\nExemples :\nevenSumOrOddProduct(2, 3) returns 6\nevenSumOrOddProduct(5, 5) returns 10",
      "de": "Schreiben Sie eine TypeScript-Funktion `function evenSumOrOddProduct(a: number, b: number): number`, um das folgende Problem zu lösen:\nGegeben zwei ganze Zahlen a und b, geben Sie die Summe zurück, wenn die Summe gerade ist,\noder geben Sie das Produkt von a und b zurück, wenn die Summe ungerade ist.\nBeispiele:\nevenSumOrOddProduct(2, 3) returns 6\nevenSumOrOddProduct(5, 5) returns 10",
      "ha": "Rubuta aikin TypeScript `function evenSumOrOddProduct(a: number, b: number): number` don warware matsalar mai zuwa:  \nAn ba da lambobi biyu a da b, dawo da jumlar idan jumlar ta zama lamba mai maɗaukaki,  \nko dawo da samfurin a da b idan jumlar ta zama lamba mai banbanci.  \nMisalai:  \nevenSumOrOddProduct(2, 3) returns 6  \nevenSumOrOddProduct(5, 5) returns 10  ",
      "hi": "TypeScript फ़ंक्शन `function evenSumOrOddProduct(a: number, b: number): number` लिखें ताकि निम्नलिखित समस्या का समाधान हो:\nदिए गए दो पूर्णांक a और b के लिए, योग को लौटाएं यदि योग सम है,\nया यदि योग विषम है तो a और b का गुणनफल लौटाएं।\nउदाहरण:\nevenSumOrOddProduct(2, 3) 6 लौटाता है\nevenSumOrOddProduct(5, 5) 10 लौटाता है",
      "hu": "Írj egy TypeScript függvényt `function evenSumOrOddProduct(a: number, b: number): number` a következő probléma megoldására:\nAdott két egész szám, a és b, add vissza az összegüket, ha az összeg páros,\nvagy add vissza a és b szorzatát, ha az összeg páratlan.\nPéldák:\nevenSumOrOddProduct(2, 3) visszaadja 6\nevenSumOrOddProduct(5, 5) visszaadja 10"
    },
    "instruction_bertscore": {
      "sq": "0.999999801369619",
      "hy": "0.999999801369619",
      "bn": "0.9750587775749733",
      "bg": "0.999999801369619",
      "zh": "0.971311416806369",
      "fr": "0.999999801369619",
      "de": "0.999999801369619",
      "ha": "0.9798999958519365",
      "hi": "0.975223044900089",
      "hu": "0.9898126450174827"
    },
    "level": "easy",
    "test": "const testEvenSumOrOddProduct = (): void => {\n    console.assert(evenSumOrOddProduct(2, 3) === 6, 'Test Case 1 Failed');\n    console.assert(evenSumOrOddProduct(5, 5) === 10, 'Test Case 2 Failed');\n    console.assert(evenSumOrOddProduct(1, 1) === 2, 'Test Case 3 Failed');\n    console.assert(evenSumOrOddProduct(0, 0) === 0, 'Test Case 4 Failed');\n    console.assert(evenSumOrOddProduct(-1, -1) === -2, 'Test Case 5 Failed');\n    console.assert(evenSumOrOddProduct(100, 200) === 300, 'Test Case 6 Failed');\n    console.assert(evenSumOrOddProduct(3, 4) === 12, 'Test Case 7 Failed');\n    console.assert(evenSumOrOddProduct(-5, 5) === 0, 'Test Case 8 Failed');\n    console.assert(evenSumOrOddProduct(7, 8) === 56, 'Test Case 9 Failed');\n    console.assert(evenSumOrOddProduct(9, 10) === 90, 'Test Case 10 Failed');\n    console.assert(evenSumOrOddProduct(11, 14) === 154, 'Test Case 11 Failed');\n};\n\ntestEvenSumOrOddProduct();",
    "entry_point": "evenSumOrOddProduct",
    "signature": "function evenSumOrOddProduct(a: number, b: number): number",
    "docstring": {
      "en": "Given two integers a and b, return the sum if the sum is even,\nor return the product of a and b if the sum is odd.\nExamples:\nevenSumOrOddProduct(2, 3) returns 6\nevenSumOrOddProduct(5, 5) returns 10\n",
      "sq": "Given dy numra të plotë a dhe b, kthe shumën nëse shuma është çift,\nose kthe prodhimin e a dhe b nëse shuma është tek.\nShembuj:\nevenSumOrOddProduct(2, 3) kthen 6\nevenSumOrOddProduct(5, 5) kthen 10",
      "hy": "Տրված երկու ամբողջ թիվ a և b, վերադարձնել գումարը, եթե գումարը զույգ է,  \nկամ վերադարձնել a և b արտադրյալը, եթե գումարը կենտ է։  \nՕրինակներ:  \nevenSumOrOddProduct(2, 3) վերադարձնում է 6  \nevenSumOrOddProduct(5, 5) վերադարձնում է 10  ",
      "bn": "দুটি পূর্ণসংখ্যা a এবং b দেওয়া হলে, যদি যোগফলটি জোড় হয় তবে যোগফলটি ফেরত দিন, অথবা যদি যোগফলটি বিজোড় হয় তবে a এবং b এর গুণফল ফেরত দিন।\nউদাহরণসমূহ:\nevenSumOrOddProduct(2, 3) 6 ফেরত দেয়\nevenSumOrOddProduct(5, 5) 10 ফেরত দেয়",
      "bg": "Дадени са две цели числа a и b, върнете сумата, ако сумата е четна, или върнете произведението на a и b, ако сумата е нечетна.\nПримери:\nevenSumOrOddProduct(2, 3) връща 6\nevenSumOrOddProduct(5, 5) връща 10",
      "zh": "给定两个整数 a 和 b，如果它们的和是偶数，则返回和；如果和是奇数，则返回 a 和 b 的乘积。\n\n示例：\nevenSumOrOddProduct(2, 3) 返回 6\nevenSumOrOddProduct(5, 5) 返回 10",
      "fr": "Étant donné deux entiers a et b, renvoyer la somme si la somme est paire, ou renvoyer le produit de a et b si la somme est impaire.\nExemples :\nevenSumOrOddProduct(2, 3) renvoie 6\nevenSumOrOddProduct(5, 5) renvoie 10",
      "de": "Given two integers a and b, return the sum if the sum is even,  \nor return the product of a and b if the sum is odd.  \nBeispiele:  \nevenSumOrOddProduct(2, 3) gibt 6 zurück  \nevenSumOrOddProduct(5, 5) gibt 10 zurück  ",
      "ha": "Given two integers a and b, return the sum if the sum is even,  \nor return the product of a and b if the sum is odd.  \nMisalai:  \nevenSumOrOddProduct(2, 3) returns 6  \nevenSumOrOddProduct(5, 5) returns 10  ",
      "hi": "दो पूर्णांक a और b दिए गए हैं, यदि योग सम है तो योग लौटाएं, या यदि योग विषम है तो a और b का गुणनफल लौटाएं।\n\nउदाहरण:\nevenSumOrOddProduct(2, 3) 6 लौटाता है\nevenSumOrOddProduct(5, 5) 10 लौटाता है",
      "hu": "Két egész szám, a és b esetén térjen vissza az összeggel, ha az összeg páros, vagy térjen vissza a és b szorzatával, ha az összeg páratlan.\nPéldák:\nevenSumOrOddProduct(2, 3) visszaadja 6\nevenSumOrOddProduct(5, 5) visszaadja 10"
    },
    "docstring_bertscore": {
      "sq": "0.9999996027392379",
      "hy": "0.9999996027392379",
      "bn": "0.9676945561981047",
      "bg": "0.9999996027392379",
      "zh": "0.9502895690599227",
      "fr": "0.9999996027392379",
      "de": "0.9999996027392379",
      "ha": "0.9999996027392379",
      "hi": "0.9370488678601371",
      "hu": "0.9760503404370994"
    }
  }
]